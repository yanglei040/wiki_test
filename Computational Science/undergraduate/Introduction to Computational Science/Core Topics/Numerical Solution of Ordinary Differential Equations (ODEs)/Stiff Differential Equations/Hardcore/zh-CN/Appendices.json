{
    "hands_on_practices": [
        {
            "introduction": "这个练习将为你提供处理刚性方程的基础经验。我们将分析一个经典例子，其中标准的显式方法（前向欧拉法）会彻底失效，而一个简单的隐式方法（后向欧拉法）却能保持稳定和准确。通过从零开始推导精确解和数值方法，你将从第一性原理的层面，深刻理解为何刚性问题需要特殊处理，并直观地看到显式与隐式方法在性能上的巨大差异。",
            "id": "3198039",
            "problem": "考虑常微分方程 (ODE) 的初值问题 (IVP)：$y^{\\prime}(t) = -\\dfrac{1}{\\epsilon} y(t) + \\sin(t)$，区间为 $t \\in [0, 10]$，初始条件为 $y(0) = 0$。参数 $\\epsilon$ 是一个小的正常数，给定为 $\\epsilon = 10^{-6}$，并且正弦函数中 $t$ 的角度单位是弧度。由于项 $-\\dfrac{1}{\\epsilon} y(t)$ 的存在，该 IVP 表现出刚性，该项在解中引入了一个快速衰减的分量。\n\n从基本定义和经过充分检验的事实出发，完成以下任务：\n\n1. 基于线性 ODE 结构，使用积分因子法推导给定 IVP 的精确闭式解 $y(t)$。您的推导必须从一阶线性 ODE 的定义和积分因子的构造开始，不得依赖任何提供给您的快捷公式。\n\n2. 使用导数的差商极限定义以及使用固定步长 $h$ 进行时间离散化的思想，推导：\n   - 通过在每个时间步的左端点近似 $y^{\\prime}(t)$ 来推导显式前向欧拉更新规则。\n   - 通过在每个时间步的右端点近似 $y^{\\prime}(t)$ 来推导隐式后向欧拉更新规则。\n   两种推导都必须源于定义 $y^{\\prime}(t) = \\lim_{h \\to 0} \\dfrac{y(t+h) - y(t)}{h}$，并且不得假设任何预先形成的离散更新公式。\n\n3. 使用 Dahlquist 测试方程 $y^{\\prime} = \\lambda y$ 的线性稳定性分析，解释为什么当 $\\epsilon$ 很小时 IVP 是刚性的，以及这对允许的显式步长有何影响。特别是，从第一性原理出发，确定显式方法对 $h$ 的约束，并将其与隐式方法的行为进行对比。\n\n4. 实现所推导的两种方法，对一组固定的时间步长 $h$，在 $t \\in [0, 10]$ 上数值近似 $y(t)$。对于每种方法和每个时间步长，计算在离散网格点上与您推导的精确解相比的最大绝对误差。如果在显式积分过程中数值解变为非有限值（例如由于溢出），则将该情况下的最大误差视为 $+\\infty$。\n\n角度单位说明：所有三角函数求值必须使用弧度。\n\n测试套件：\n- 参数：$\\epsilon = 10^{-6}$。\n- 初始条件：$y(0) = 0$。\n- 区间：$[0, 10]$。\n- 步长：$h \\in \\{1.0, 0.1, 0.01, 0.001\\}$。\n\n对于上述集合中的每个步长 $h$，评估：\n- 在离散时间网格 $\\{0, h, 2h, \\dots, 10\\}$ 上，显式前向欧拉法的最大绝对误差。\n- 在同一网格上，隐式后向欧拉法的最大绝对误差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,...]”）。该列表必须按以下顺序汇总结果：对于每个按升序排列的 $h$，首先是显式方法的最大误差，然后是隐式方法的最大误差，因此最终输出有八个条目，按顺序对应于 $h = 0.001、h = 0.01、h = 0.1$ 和 $h = 1.0$。",
            "solution": "该问题被评估为有效，因为它具有科学依据、问题提出得当、客观且自洽。它展示了刚性常微分方程 (ODE) 的一个典型例子，并要求进行计算科学领域基础的推导和分析。问题陈述没有矛盾或谬误。\n\n解答分为四个部分，对应于问题描述中列出的任务。\n\n### 1. 精确闭式解的推导\n\n给定的初值问题 (IVP) 是：\n$$\ny^{\\prime}(t) = -\\frac{1}{\\epsilon} y(t) + \\sin(t), \\quad y(0) = 0, \\quad t \\in [0, 10]\n$$\n这是一个一阶线性 ODE。此类方程的标准形式是 $y' + p(t)y = q(t)$。通过重新排列给定的 ODE，我们确定相应的项：\n$$\ny^{\\prime}(t) + \\frac{1}{\\epsilon} y(t) = \\sin(t)\n$$\n此处，$p(t) = \\frac{1}{\\epsilon}$ 且 $q(t) = \\sin(t)$。\n\n为了求解该方程，我们使用积分因子法。积分因子 $I(t)$ 定义为：\n$$\nI(t) = e^{\\int p(t) dt}\n$$\n对于本题，积分为：\n$$\n\\int p(t) dt = \\int \\frac{1}{\\epsilon} dt = \\frac{t}{\\epsilon}\n$$\n因此，积分因子为 $I(t) = e^{t/\\epsilon}$。我们将标准形式的 ODE 乘以 $I(t)$：\n$$\ne^{t/\\epsilon} y^{\\prime}(t) + \\frac{1}{\\epsilon} e^{t/\\epsilon} y(t) = e^{t/\\epsilon} \\sin(t)\n$$\n根据微分的乘法法则，左侧是 $y(t)I(t)$ 的导数：\n$$\n\\frac{d}{dt} \\left( y(t) e^{t/\\epsilon} \\right) = e^{t/\\epsilon} \\sin(t)\n$$\n为了求得 $y(t)$，我们对两边关于 $t$ 进行积分：\n$$\n\\int \\frac{d}{dt} \\left( y(t) e^{t/\\epsilon} \\right) dt = \\int e^{t/\\epsilon} \\sin(t) dt\n$$\n$$\ny(t) e^{t/\\epsilon} = \\int e^{t/\\epsilon} \\sin(t) dt\n$$\n右侧的积分可以使用两次分部积分法求解。形如 $\\int e^{at}\\sin(bt)dt$ 的积分通解为 $\\frac{e^{at}}{a^2+b^2}(a\\sin(bt) - b\\cos(bt))$。当 $a = 1/\\epsilon$ 且 $b = 1$ 时，我们有：\n$$\n\\int e^{t/\\epsilon} \\sin(t) dt = \\frac{e^{t/\\epsilon}}{(1/\\epsilon)^2 + 1^2} \\left( \\frac{1}{\\epsilon}\\sin(t) - 1\\cos(t) \\right) + C\n$$\n其中 $C$ 是积分常数。简化此表达式：\n$$\n\\int e^{t/\\epsilon} \\sin(t) dt = \\frac{e^{t/\\epsilon}}{(1+\\epsilon^2)/\\epsilon^2} \\left( \\frac{\\sin(t) - \\epsilon\\cos(t)}{\\epsilon} \\right) + C = \\frac{\\epsilon^2 e^{t/\\epsilon}}{1+\\epsilon^2} \\frac{\\sin(t) - \\epsilon\\cos(t)}{\\epsilon} + C\n$$\n$$\n= \\frac{\\epsilon e^{t/\\epsilon}}{1+\\epsilon^2} (\\sin(t) - \\epsilon\\cos(t)) + C = \\frac{e^{t/\\epsilon}}{1+\\epsilon^2} (\\epsilon\\sin(t) - \\epsilon^2\\cos(t)) + C\n$$\n将其代回关于 $y(t)e^{t/\\epsilon}$ 的方程中：\n$$\ny(t) e^{t/\\epsilon} = \\frac{e^{t/\\epsilon}}{1+\\epsilon^2} (\\epsilon\\sin(t) - \\epsilon^2\\cos(t)) + C\n$$\n通过乘以 $e^{-t/\\epsilon}$ 来求解 $y(t)$：\n$$\ny(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + C e^{-t/\\epsilon}\n$$\n现在，我们应用初始条件 $y(0) = 0$ 来求出常数 $C$：\n$$\ny(0) = 0 = \\frac{\\epsilon\\sin(0) - \\epsilon^2\\cos(0)}{1+\\epsilon^2} + C e^{0}\n$$\n$$\n0 = \\frac{0 - \\epsilon^2(1)}{1+\\epsilon^2} + C \\implies C = \\frac{\\epsilon^2}{1+\\epsilon^2}\n$$\n将 $C$ 的值代回，得到该 IVP 的精确闭式解：\n$$\ny(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + \\frac{\\epsilon^2}{1+\\epsilon^2} e^{-t/\\epsilon}\n$$\n\n### 2. 数值方法的推导\n\n我们从导数的极限定义 $y^{\\prime}(t) = \\lim_{h \\to 0} \\frac{y(t+h) - y(t)}{h}$ 推导数值更新规则。我们考虑一个离散时间网格 $t_n = n h$，其中 $n=0, 1, 2, \\dots$，$h$ 是步长。设 $y_n$ 是 $y(t_n)$ 的数值近似。\n\n**显式前向欧拉法**\n前向欧拉法在时间步的起点 $t_n$ 处近似导数 $y'(t)$。基于极限定义，使用一阶前向差商：\n$$\ny^{\\prime}(t_n) \\approx \\frac{y(t_{n+1}) - y(t_n)}{h}\n$$\n将此代入时间点 $t_n$ 的 ODE $y'(t) = f(t, y(t)) = -\\frac{1}{\\epsilon} y(t) + \\sin(t)$ 中：\n$$\n\\frac{y_{n+1} - y_n}{h} = -\\frac{1}{\\epsilon} y_n + \\sin(t_n)\n$$\n求解 $y_{n+1}$ 得到显式前向欧拉更新规则：\n$$\ny_{n+1} = y_n + h \\left( -\\frac{1}{\\epsilon} y_n + \\sin(t_n) \\right)\n$$\n此规则是“显式”的，因为 $y_{n+1}$ 是直接根据时间点 $t_n$ 的已知值计算的。\n\n**隐式后向欧拉法**\n后向欧拉法通过在时间步的终点 $t_{n+1}$ 处评估 ODE 来近似导数。导数 $y'(t_{n+1})$ 使用后向差商来近似：\n$$\ny^{\\prime}(t_{n+1}) \\approx \\frac{y(t_{n+1}) - y(t_n)}{h}\n$$\n将此代入时间点 $t_{n+1}$ 的 ODE 中：\n$$\n\\frac{y_{n+1} - y_n}{h} = -\\frac{1}{\\epsilon} y_{n+1} + \\sin(t_{n+1})\n$$\n此方程是“隐式”的，因为未知数 $y_{n+1}$ 出现在方程两边。我们必须求解 $y_{n+1}$：\n$$\ny_{n+1} - y_n = h \\left( -\\frac{1}{\\epsilon} y_{n+1} + \\sin(t_{n+1}) \\right)\n$$\n$$\ny_{n+1} - y_n = -\\frac{h}{\\epsilon} y_{n+1} + h\\sin(t_{n+1})\n$$\n合并含有 $y_{n+1}$ 的项：\n$$\ny_{n+1} + \\frac{h}{\\epsilon} y_{n+1} = y_n + h\\sin(t_{n+1})\n$$\n$$\ny_{n+1} \\left( 1 + \\frac{h}{\\epsilon} \\right) = y_n + h\\sin(t_{n+1})\n$$\n最后，求解 $y_{n+1}$ 得到隐式后向欧拉更新规则：\n$$\ny_{n+1} = \\frac{y_n + h\\sin(t_{n+1})}{1 + h/\\epsilon}\n$$\n\n### 3. 稳定性分析与刚性\n\n刚性概念使用 Dahlquist 测试方程 $y' = \\lambda y$ 进行分析，其中 $\\text{Re}(\\lambda)  0$。对于给定的 ODE，其动态主要由齐次部分 $y' = -\\frac{1}{\\epsilon} y$ 决定。因此，我们确定 $\\lambda = -1/\\epsilon$。由于 $\\epsilon = 10^{-6}$ 是一个小的正常数，$\\lambda = -10^6$ 是一个大的负实数。\n\n**前向欧拉稳定性**\n将前向欧拉规则应用于 $y'=\\lambda y$：\n$$\ny_{n+1} = y_n + h(\\lambda y_n) = (1+h\\lambda) y_n\n$$\n为了使数值解保持有界（即稳定），放大因子 $R(h\\lambda) = 1+h\\lambda$ 必须满足 $|R(h\\lambda)| \\le 1$。\n$$\n|1 + h\\lambda| \\le 1\n$$\n当 $\\lambda = -1/\\epsilon$ 时，这变为 $|1 - h/\\epsilon| \\le 1$。该不等式等价于 $-1 \\le 1 - h/\\epsilon \\le 1$。\n右侧不等式 $1 - h/\\epsilon \\le 1$ 意味着 $h/\\epsilon \\ge 0$，对于正的 $h$ 和 $\\epsilon$ 这总是成立的。\n左侧不等式 $-1 \\le 1 - h/\\epsilon$ 意味着 $h/\\epsilon \\le 2$，即 $h \\le 2\\epsilon$。\n对于 $\\epsilon=10^{-6}$，步长必须满足 $h \\le 2 \\times 10^{-6}$。这是一个非常严格的限制。对于任何步长 $h > 2\\epsilon$，数值解将变得无界，并表现出指数增长的振荡。\n\n**后向欧拉稳定性**\n将后向欧拉规则应用于 $y'=\\lambda y$：\n$$\ny_{n+1} = y_n + h(\\lambda y_{n+1}) \\implies y_{n+1}(1 - h\\lambda) = y_n \\implies y_{n+1} = \\frac{1}{1-h\\lambda} y_n\n$$\n放大因子为 $R(h\\lambda) = \\frac{1}{1-h\\lambda}$。为保证稳定性，我们要求 $|R(h\\lambda)| \\le 1$。\n$$\n\\left| \\frac{1}{1-h\\lambda} \\right| \\le 1\n$$\n当 $\\lambda = -1/\\epsilon$ 时，这变为 $\\left| \\frac{1}{1+h/\\epsilon} \\right|$。由于 $h > 0$ 且 $\\epsilon > 0$，分母 $1+h/\\epsilon$ 总是大于 1。因此，其倒数的绝对值总是小于 1。该方法对于任何 $h > 0$ 的选择都是稳定的。这个性质被称为 A-稳定性。\n\n**刚性解释**\n该 IVP 是刚性的，因为其精确解 $y(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + \\frac{\\epsilon^2}{1+\\epsilon^2} e^{-t/\\epsilon}$ 包含两个时间尺度差异巨大的分量。\n1. 一个快速衰减的瞬态分量，与 $e^{-t/\\epsilon}$ 成正比，其特征时间尺度为 $\\tau_{fast} = \\epsilon = 10^{-6}$。这个分量几乎瞬间就可以忽略不计。\n2. 一个缓慢变化的分量，其振荡的时间尺度为 $\\tau_{slow} \\approx 2\\pi$。\n\n刚性的产生是因为像前向欧拉法这样的显式方法的稳定性由最快的时间尺度 ($\\tau_{fast}$) 控制，这迫使我们即使在快速分量已经消失很久之后，仍需使用一个不切实际的小步长 ($h \\le 2\\epsilon$)。而像后向欧拉法这样的隐式方法，由于对本问题是无条件稳定的，其稳定性不受 $\\tau_{fast}$ 的约束。它可以使用一个更大的步长 $h$，该步长由捕捉慢速分量所需的精度决定，这使得它在处理刚性问题时效率要高得多。\n\n### 4. 实现与误差分析\n\n我们实现前向和后向欧拉法，使用步长 $h \\in \\{0.001, 0.01, 0.1, 1.0\\}$ 在 $t \\in [0, 10]$ 上求解该 IVP。由于所有这些步长都违反了前向欧拉法的稳定性条件 ($h > 2 \\times 10^{-6}$)，显式方法预计会产生数值不稳定的解，该解会无界增长，导致无穷大的最大误差。而隐式方法是稳定的，应该会产生精确的结果，其误差随着 $h$ 的减小而减小。对于每种情况，我们在网格点上计算数值解与精确解之间的最大绝对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a stiff ODE using Forward and Backward Euler methods,\n    and calculates the maximum absolute error against the exact solution.\n    \"\"\"\n    \n    # Define problem parameters from the statement\n    epsilon = 1e-6\n    t_end = 10.0\n    y0 = 0.0\n    \n    # Test suite of step sizes, in increasing order as required for output.\n    h_values = [0.001, 0.01, 0.1, 1.0]\n    \n    # List to store the results in the specified order.\n    results = []\n\n    # Exact solution derived via integrating factor\n    # y(t) = (epsilon*sin(t) - epsilon^2*cos(t))/(1 + epsilon^2) \n    #        + (epsilon^2 / (1 + epsilon^2)) * exp(-t/epsilon)\n    def y_exact(t, eps):\n        term1 = (eps * np.sin(t) - eps**2 * np.cos(t)) / (1 + eps**2)\n        term2 = (eps**2 / (1 + eps**2)) * np.exp(-t / eps)\n        return term1 + term2\n\n    # Loop over each step size\n    for h in h_values:\n        # Create a stable time grid from 0 to t_end\n        # Using np.linspace is more robust against floating point errors than np.arange\n        num_steps = int(round(t_end / h))\n        t_points = np.linspace(0, t_end, num_steps + 1)\n        \n        # --- Explicit Forward Euler Method ---\n        y_fe = np.zeros(num_steps + 1)\n        y_fe[0] = y0\n        is_finite_fe = True\n        \n        for n in range(num_steps):\n            # y_{n+1} = y_n + h * f(t_n, y_n)\n            # f(t,y) = -y/epsilon + sin(t)\n            y_fe[n+1] = y_fe[n] + h * (-y_fe[n] / epsilon + np.sin(t_points[n]))\n            # Check for overflow at each step to prevent warnings and handle correctly.\n            if not np.isfinite(y_fe[n+1]):\n                is_finite_fe = False\n                break\n        \n        # Calculate maximum absolute error for Forward Euler\n        if is_finite_fe:\n            y_true = y_exact(t_points, epsilon)\n            error_fe = np.max(np.abs(y_fe - y_true))\n        else:\n            # As per problem, if solution is non-finite, error is +inf\n            error_fe = float('inf')\n        \n        results.append(error_fe)\n        \n        # --- Implicit Backward Euler Method ---\n        y_be = np.zeros(num_steps + 1)\n        y_be[0] = y0\n        \n        for n in range(num_steps):\n            # y_{n+1} = (y_n + h*sin(t_{n+1})) / (1 + h/epsilon)\n            numerator = y_be[n] + h * np.sin(t_points[n+1])\n            denominator = 1 + h / epsilon\n            y_be[n+1] = numerator / denominator\n\n        # Calculate maximum absolute error for Backward Euler\n        y_true = y_exact(t_points, epsilon)\n        error_be = np.max(np.abs(y_be - y_true))\n        results.append(error_be)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然隐式方法提供了卓越的稳定性，但它们也带来了一个挑战：每个时间步都需要求解一个代数方程。对于非线性常微分方程，这意味着要求解一个非线性代数方程。本练习将引导你掌握解决这一常见问题的标准方法：使用牛顿法在隐式积分的每一步（特别是后向欧拉法）中寻找解。这项实践对于理解现实世界科学软件中隐式求解器的工作原理至关重要。",
            "id": "2442982",
            "problem": "给定一个标量常微分方程（ODE）\n$$\n\\frac{dy}{dt} = f(t,y) = -k\\,(y - \\sin t) - b\\,y^3,\n$$\n其初始条件为\n$$\ny(0) = y_0,\n$$\n该方程定义在区间\n$$\nt \\in [0,T]\n$$\n上的均匀时间网格上，其中\n$$\nt_n = n\\,h, \\quad n=0,1,\\dots,N, \\quad \\text{且 } Nh = T \\text{ 和 } h>0.\n$$\n函数 $\\sin t$ 中的角度必须以弧度为单位。在每一步，使用隐式单步更新\n$$\ny_{n+1} = y_n + h\\,f(t_{n+1}, y_{n+1}),\n$$\n并使用牛顿法求解所得的关于 $y_{n+1}$ 的非线性代数方程，残差或牛顿步长的绝对停止容差为 $10^{-12}$，且每个时间步最多迭代 50 次。在每一步中，使用 $y_{n}$ 初始化牛顿法。\n\n实现一个程序，对下面测试套件中的每组参数，使用上述方法将数值解从 $t=0$ 推进到 $t=T$，并返回 $y(T)$ 的近似值。\n\n测试套件（每个元组为 $(k,b,y_0,T,h)$）：\n- 情况 A（刚性，非线性，受迫）：$(1000, 10, 0, 0.1, 0.001)$。\n- 情况 B（刚性，线性，受迫）：$(1000, 0, 1, 0.1, 0.001)$。\n- 情况 C（单大步，刚性，非线性）：$(1000, 5, 1, 0.05, 0.05)$。\n- 情况 D（非刚性，纯非线性）：$(0, 50, 1, 0.02, 0.005)$。\n\n你的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，列表项按 A、B、C、D 的顺序分别是对应情况下 $y(T)$ 的近似值，每个值都四舍五入到恰好 $8$ 位小数。例如，包含四个结果的输出必须如下所示\n$$\n[\\text{res}_A,\\text{res}_B,\\text{res}_C,\\text{res}_D].\n$$",
            "solution": "所给问题是一个形如 $\\frac{dy}{dt} = f(t,y)$ 的标量常微分方程（ODE），需要进行数值求解。该问题定义明确，科学上合理，并包含了通过指定算法获得唯一解所需的所有信息。因此，我将着手解决该问题。\n\n控制方程为：\n$$\n\\frac{dy}{dt} = f(t,y) = -k\\,(y - \\sin t) - b\\,y^3, \\quad y(0) = y_0\n$$\n该方程描述了一个系统，其包含一个以速率 $k$ 趋向于正弦驱动函数 $\\sin t$ 的线性松弛项，以及一个与 $y^3$ 成正比的非线性阻尼项。$k$ 的大小决定了方程的刚性。对于大的 $k$，显式数值方法需要极小的时间步长 $h \\ll 1/k$ 来维持稳定性。该问题正确地指定了使用隐式方法来处理这种刚性。\n\n数值积分采用隐式单步后向欧拉法进行。对于均匀时间网格 $t_n = n\\,h$，从时间 $t_n$ 到 $t_{n+1}$ 的更新规则由下式给出：\n$$\ny_{n+1} = y_n + h\\,f(t_{n+1}, y_{n+1})\n$$\n其中 $y_n$ 是 $y(t_n)$ 的近似值。该方程是隐式的，因为未知值 $y_{n+1}$ 出现在方程的两边。为了在每个时间步求解 $y_{n+1}$，我们必须求解一个非线性代数方程。这个方程可以通过定义一个残差函数 $R(x)$ 来表示，我们需要寻找该函数的根：\n$$\nR(x) = x - y_n - h\\,f(t_{n+1}, x) = 0\n$$\n其中 $x$ 代表未知数 $y_{n+1}$。\n\n为找到 $R(x)=0$ 的根，我们采用牛顿法，这是一个由下式定义的迭代过程：\n$$\nx^{(j+1)} = x^{(j)} - \\frac{R(x^{(j)})}{R'(x^{(j)})}\n$$\n其中 $x^{(j)}$ 是第 $j$ 次迭代时对根的猜测值，而 $R'(x) = \\frac{dR}{dx}$ 是残差函数关于 $x$ 的导数。每个时间步的初始猜测值被指定为上一步的值，即 $x^{(0)} = y_n$。\n\n导数 $R'(x)$ 计算如下：\n$$\nR'(x) = \\frac{d}{dx} \\left( x - y_n - h\\,f(t_{n+1}, x) \\right) = 1 - h\\,\\frac{\\partial f}{\\partial y}(t_{n+1}, x)\n$$\n对于给定的函数 $f(t,y)$，其关于 $y$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial y}(t,y) = \\frac{\\partial}{\\partial y} \\left( -k\\,(y - \\sin t) - b\\,y^3 \\right) = -k - 3\\,b\\,y^2\n$$\n将此代入 $R'(x)$ 的表达式中，我们得到：\n$$\nR'(x) = 1 - h\\,(-k - 3\\,b\\,x^2) = 1 + h\\,k + 3\\,h\\,b\\,x^2\n$$\n因此，求解 $y_{n+1}$ 的牛顿迭代是一个循环过程，它不断更新猜测值 $x^{(j)}$，直到满足停止准则。该准则是残差的绝对值 $|R(x^{(j)})|$ 或牛顿步长的绝对值 $|x^{(j+1)} - x^{(j)}|$ 的容差为 $10^{-12}$。如果在 50 次迭代内未达到收敛，则该过程终止。\n\n每个测试用例的总体算法如下：\n1.  初始化参数 $(k, b, y_0, T, h)$ 并计算总步数 $N = T/h$。\n2.  设置初始解 $y = y_0$ 和时间 $t = 0$。\n3.  从 $n=0$ 循环到 $N-1$：\n    a.  确定下一个时间点 $t_{n+1} = (n+1)h$。\n    b.  将牛顿法对 $y_{n+1}$ 的猜测值初始化为 $x^{(0)} = y_n$。\n    c.  使用牛顿法迭代最多 50 步来寻找解 $R(x)=0$ 的 $x$。在每次迭代 $j$ 中：\n        i.  计算残差 $R(x^{(j)})$。如果其绝对值小于 $10^{-12}$，则达到收敛。该时间步的结果为 $x^{(j)}$。\n        ii. 计算导数 $R'(x^{(j)})$。\n        iii. 计算牛顿步长 $\\Delta x = -R(x^{(j)}) / R'(x^{(j)})$。\n        iv. 更新猜测值：$x^{(j+1)} = x^{(j)} + \\Delta x$。\n        v. 如果步长的绝对值 $|\\Delta x|$ 小于 $10^{-12}$，则达到收敛。该时间步的结果为 $x^{(j+1)}$。\n    d.  更新下一个时间步的解：$y_{n+1} = x_{\\text{converged}}$。\n4.  经过 $N$ 步后 $y$ 的最终值即为所求的 $y(T)$ 的近似值。对所有指定的测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(k, b, y0, T, h):\n    \"\"\"\n    Solves the ODE dy/dt = -k*(y - sin(t)) - b*y^3 using Backward Euler\n    with Newton's method for the nonlinear solve.\n    \n    Args:\n        k (float): Stiffness parameter.\n        b (float): Nonlinearity parameter.\n        y0 (float): Initial condition y(0).\n        T (float): Final time.\n        h (float): Time step size.\n\n    Returns:\n        float: The numerical solution y(T).\n    \"\"\"\n\n    # Define the ODE function f(t, y)\n    def f(t, y, k, b):\n        return -k * (y - np.sin(t)) - b * y**3\n\n    # Define the partial derivative of f with respect to y, df/dy\n    def df_dy(t, y, k, b):\n        return -k - 3 * b * y**2\n\n    # Ensure n_steps is integer\n    n_steps = int(round(T / h))\n    if not np.isclose(n_steps * h, T):\n        # This case is not expected based on the problem statement's test cases\n        # but is good practice.\n        raise ValueError(\"T must be an integer multiple of h.\")\n\n    y_current = y0\n\n    # Main time-stepping loop\n    for n in range(n_steps):\n        t_next = (n + 1) * h\n        y_guess = y_current\n        \n        # Newton's method to solve y_next = y_current + h * f(t_next, y_next)\n        # This is equivalent to finding the root of R(y_next) = 0 where\n        # R(y_next) = y_next - y_current - h * f(t_next, y_next)\n        for _ in range(50): # Maximum of 50 iterations\n            \n            # Calculate residual at the current guess\n            residual = y_guess - y_current - h * f(t_next, y_guess, k, b)\n\n            # Check for convergence on residual\n            if abs(residual)  1e-12:\n                break\n                \n            # Calculate Jacobian of the residual function\n            # R'(y) = 1 - h * df/dy\n            jac_residual = 1.0 - h * df_dy(t_next, y_guess, k, b)\n            \n            # Avoid division by zero, although not an issue for this problem's parameters\n            if jac_residual == 0:\n                break\n\n            # Calculate Newton step\n            step = -residual / jac_residual\n            \n            # Update the guess\n            y_guess += step\n            \n            # Check for convergence on the step size\n            if abs(step)  1e-12:\n                break\n        \n        y_current = y_guess\n\n    return y_current\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (k, b, y0, T, h)\n    test_cases = [\n        (1000, 10, 0, 0.1, 0.001),     # Case A\n        (1000, 0, 1, 0.1, 0.001),      # Case B\n        (1000, 5, 1, 0.05, 0.05),       # Case C\n        (0, 50, 1, 0.02, 0.005)        # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        y_final = run_simulation(*params)\n        results.append(y_final)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际应用中，一个问题并非总是全程都具有刚性。一个高效的求解器应该能够检测刚性，并在计算成本较低的显式方法与更稳健的隐式方法之间切换。这项高级实践将指导你构建自己的“刚性检测器”。你将学习如何使用雅可比矩阵来近似常微分方程系统的局部行为，分析其特征值，并应用稳定性理论来创建一个可以智能决策使用何种类型求解器的实用工具。",
            "id": "3279238",
            "problem": "要求您设计并实现一个程序，对于一个给定的形式为 $\\frac{d y}{d t} = f(y)$ 的自治常微分方程（ODE）系统，在指定的点 $(t, y)$ 和时间步长 $h$ 处，构建一个局部的“刚性检测器”。该检测器必须在点 $(t, y)$ 处数值估计雅可比矩阵 $J = \\frac{\\partial f}{\\partial y}$，并使用基于显式单步法绝对稳定性要求的原则性稳定性测试，来决定使用显式求解器还是隐式求解器。决策准则必须从基本定义推导得出（不使用题目说明中提供的快捷公式）：对系统进行局部线性化，描述该方法下各模态的放大情况，并确定确保所有模态衰减而非增长的条件。\n\n您的程序必须：\n- 在 $(t, y)$ 处使用有限差分实现一个数值雅可比矩阵估计器。您可以假设 $f$ 在 $(t, y)$ 的一个邻域内足够光滑，并且系统维度等于状态维度，因此 $J$ 是方阵。\n- 计算估计的雅可比矩阵的特征值，并通过检查局部线性化和显式更新所隐含的模态放大因子来应用显式方法的绝对稳定性要求。使用保守的决策规则：如果在给定的 $h$ 下，任何模态违反了严格的稳定性要求，检测器必须选择隐式求解器；否则，它必须选择显式求解器。\n- 为每个测试用例返回一个布尔决策，其中 $\\text{True}$ 表示“选择隐式求解器”，$\\text{False}$ 表示“选择显式求解器”。\n\n在以下测试套件上实现并评估您的检测器，该套件涵盖了标量、线性多维和非线性系统，包括正常路径、边界和边缘情况。在下面的所有情况中，系统都是自治的，因此 $f$ 仅依赖于 $y$；但为了接口的一致性，您仍需将 $t$ 传递给函数，但 $t$ 在计算中并未使用。\n\n测试用例：\n1. 标量线性衰减（正常路径，显式稳定性成立）：\n   - 系统：$\\frac{d y}{d t} = -1000\\, y$\n   - 评估点：$t = 0$, $y = 1$\n   - 时间步长：$h = 10^{-3}$\n   - 预期检测器决策：显式求解器可接受。\n2. 标量线性衰减（边界/显式不稳定；保守决策选择隐式）：\n   - 系统：$\\frac{d y}{d t} = -1000\\, y$\n   - 评估点：$t = 0$, $y = 1$\n   - 时间步长：$h = 2\\times 10^{-3}$\n   - 预期检测器决策：显式求解器在此 $h$ 下违反严格稳定性；选择隐式。\n3. 二维阻尼振子（小步长下显式稳定性成立）：\n   - 系统：$\\frac{d}{dt}\\begin{bmatrix} y_1 \\\\ y_2 \\end{bmatrix} = \\begin{bmatrix} y_2 \\\\ -\\omega^2 y_1 - 2 \\zeta \\omega y_2 \\end{bmatrix}$，其中 $\\omega = 50$ 且 $\\zeta = 0.05$\n   - 评估点：$t = 0$, $y = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$\n   - 时间步长：$h = 10^{-3}$\n   - 预期检测器决策：显式求解器可接受。\n4. 二维阻尼振子（较大步长下显式不稳定）：\n   - 系统：与情况3相同\n   - 评估点：$t = 0$, $y = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$\n   - 时间步长：$h = 5\\times 10^{-2}$\n   - 预期检测器决策：选择隐式求解器。\n5. 二维非线性反应模型（小步长下显式稳定性成立）：\n   - 系统：$\\frac{d}{dt}\\begin{bmatrix} y_1 \\\\ y_2 \\end{bmatrix} = \\begin{bmatrix} -k_1 y_1 + k_2 y_2^2 \\\\ k_1 y_1 - k_2 y_2^2 - k_3 y_2 \\end{bmatrix}$，其中 $k_1 = 1$, $k_2 = 1$, $k_3 = 1000$\n   - 评估点：$t = 0$, $y = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$\n   - 时间步长：$h = 10^{-3}$\n   - 预期检测器决策：显式求解器可接受。\n6. 二维非线性反应模型（较大步长下显式不稳定）：\n   - 系统：与情况5相同\n   - 评估点：$t = 0$, $y = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$\n   - 时间步长：$h = 10^{-2}$\n   - 预期检测器决策：选择隐式求解器。\n\n数值雅可比矩阵估计要求：\n- 对 $J$ 的每一列 $j$ 使用中心有限差分近似，通过一个小的增量 $\\delta_j$ 来扰动 $y_j$，增量选择为 $\\delta_j = \\sqrt{\\varepsilon}\\,\\max\\{1, |y_j|\\}$，其中 $\\varepsilon$ 是双精度浮点运算的机器ε。\n\n求解器决策规则：\n- 在点 $(t, y)$ 处对系统进行形式上的线性化，并对所有特征模态应用显式单步法的绝对稳定性要求。如果在给定的 $h$ 下，任何模态未能满足严格的稳定性要求，则返回 $\\text{True}$（选择隐式）；否则返回 $\\text{False}$（选择显式）。在检测器中，将等于稳定性边界的情况视为显式方法不稳定。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4,result5,result6]\"），其中每个结果是按上述顺序列出的相应测试用例的布尔决策。",
            "solution": "该问题要求为自治常微分方程（ODE）系统 $\\frac{d y}{d t} = f(y)$ 设计并实现一个数值刚性检测器。该检测器的目的是，在给定的点 $(t, y)$ 和特定的时间步长 $h$ 下，决定是使用显式求解器还是隐式求解器更合适。该决策必须基于应用于 ODE 系统局部线性化的原型显式单步法的绝对稳定性属性。\n\n### 原理一：局部线性化\n一个一般的非线性 ODE 系统 $\\frac{d y}{d t} = f(y)$，可以通过考虑一个小扰动 $\\delta y(t) = y(t) - y_0$ 的演化，在点 $y_0$ 附近进行局部分析。$f(y)$ 在 $y_0$ 附近的一阶泰勒展开为：\n$$ f(y) = f(y_0) + \\frac{\\partial f}{\\partial y}\\bigg|_{y_0} (y - y_0) + \\mathcal{O}(\\|y - y_0\\|^2) $$\n令 $J(y_0) = \\frac{\\partial f}{\\partial y}\\big|_{y_0}$ 为在 $y_0$ 处计算的 $f$ 的雅可比矩阵。那么扰动的变化率为：\n$$ \\frac{d(\\delta y)}{dt} = \\frac{d y}{dt} = f(y) \\approx f(y_0) + J(y_0) \\delta y $$\n对于在特定状态 $y_0$ 下评估的自治系统，我们可以通过分析扰动的齐次方程来研究线性化系统的稳定性：\n$$ \\frac{d(\\delta y)}{dt} \\approx J(y_0) \\delta y $$\n原始非线性系统的局部稳定性和刚性特征由这个线性系统的性质决定，特别是雅可比矩阵 $J(y_0)$ 的特征值。\n\n### 原理二：显式方法的绝对稳定性\n我们考虑前向欧拉法作为求解 ODE 的代表性显式单步法。其更新规则是：\n$$ y_{n+1} = y_n + h f(y_n) $$\n其中 $h$ 是时间步长。将此方法应用于线性化的扰动方程，得到扰动 $\\delta y_n$ 从一步到下一步的更新规则：\n$$ \\delta y_{n+1} = \\delta y_n + h (J \\cdot \\delta y_n) = (I + hJ) \\delta y_n $$\n这里，$I$ 是单位矩阵，$J$ 是在关注点计算的雅可比矩阵。矩阵 $G = I + hJ$ 被称为放大矩阵，因为它决定了扰动在从一步到下一步的过程中是如何被放大或衰减的。\n\n为了分析 $G$ 的行为，我们考虑它对 $J$ 的特征向量的作用。设 $\\{\\lambda_k\\}$ 是 $J$ 的特征值，对应的特征向量为 $\\{v_k\\}$。如果我们将一个扰动 $\\delta y_n$ 表示为这些特征向量的线性组合，即 $\\delta y_n = \\sum_k c_k v_k$，其演化过程为：\n$$ \\delta y_{n+1} = (I + hJ) \\sum_k c_k v_k = \\sum_k c_k (I + hJ) v_k = \\sum_k c_k (v_k + h \\lambda_k v_k) = \\sum_k c_k (1 + h\\lambda_k) v_k $$\n为了使数值解稳定，任何扰动都必须随时间衰减。这要求每个模态的放大因子 $g_k = 1 + h\\lambda_k$ 的模长严格小于 1。这给出了绝对稳定性要求：\n$$ |1 + h\\lambda_k|  1 \\quad \\text{对于 } J \\text{ 的所有特征值 } \\lambda_k $$\n满足 $|1+z|  1$ 的复数集合 $z = h\\lambda$ 构成了绝对稳定域。这个不等式描述了复平面上以 $(-1, 0)$ 为中心、半径为 1 的圆的内部。\n\n### 刚性检测器算法\n该检测器将此稳定性检查形式化为一个决策规则。如果给定的步长 $h$ 太大，以至于无法用显式方法稳定地解析系统衰减最快的模态，则认为系统相对于该步长是“刚性”的。\n\n1.  **决策准则：** 给定系统 $f$、点 $(t, y_0)$ 和步长 $h$，检测器将计算雅可比矩阵 $J(y_0)$ 的特征值 $\\{\\lambda_k\\}$。然后它将检查是否满足稳定性条件。问题指定了一个保守规则：如果任何模态违反了条件（包括在边界上），则应选择隐式方法。因此，如果存在以下情况，检测器将返回 `True`（选择隐式）：\n    $$ \\exists k \\text{ 使得 } |1 + h\\lambda_k| \\ge 1 $$\n    否则，如果对所有 $k$ 都有 $|1 + h\\lambda_k|  1$，它将返回 `False`（选择显式）。\n\n2.  **数值雅可比矩阵估计：** 由于解析雅可比矩阵可能不可用，因此对其进行数值估计。对于雅可比矩阵 $J$ 的每一列 $j$，我们使用中心有限差分近似。这涉及在两个方向上用一个小的量 $\\delta_j$ 扰动状态向量 $y$ 的第 $j$ 个分量。\n    $$ J_{:,j} = \\frac{\\partial f}{\\partial y_j} \\approx \\frac{f(y + \\delta_j \\mathbf{e}_j) - f(y - \\delta_j \\mathbf{e}_j)}{2 \\delta_j} $$\n    其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量。扰动大小 $\\delta_j$ 的选择是为了平衡截断误差（来自泰勒近似）和舍入误差（来自浮点运算）。一个稳健的选择，如题目所指定，是：\n    $$ \\delta_j = \\sqrt{\\varepsilon} \\cdot \\max\\{1, |y_j|\\} $$\n    其中 $\\varepsilon$ 是双精度浮点数的机器ε。\n\n3.  **总体步骤：**\n    a. 给定 $f$，$t_0$，$y_0$ 和 $h$。\n    b. 使用中心差分公式为每一列在 $y_0$ 处构建数值雅可比矩阵 $J_{num}$。\n    c. 计算 $J_{num}$ 的特征值 $\\{\\lambda_k\\}$。这些特征值可能是复数。\n    d. 对于每个特征值 $\\lambda_k$，计算复数 $z_k = h\\lambda_k$ 的值。\n    e. 检查是否有 $|1 + z_k| \\ge 1$。如果对任何 $k$ 成立，则决策为 `True`。\n    f. 如果对于所有特征值，(e) 中的条件都不满足，则决策为 `False`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerical_jacobian(f, t, y, machine_eps):\n    \"\"\"\n    Computes the Jacobian of f at (t, y) using central finite differences.\n\n    Args:\n        f (callable): The RHS function of the ODE, f(t, y).\n        t (float): The current time.\n        y (np.ndarray or float): The current state.\n        machine_eps (float): The machine epsilon for float precision.\n\n    Returns:\n        np.ndarray: The estimated Jacobian matrix.\n    \"\"\"\n    y = np.atleast_1d(y).astype(float)\n    n = len(y)\n    J = np.zeros((n, n), dtype=float)\n    \n    for j in range(n):\n        # Create a perturbation vector\n        pert_vec = np.zeros_like(y)\n        \n        # Calculate optimal perturbation size\n        delta = np.sqrt(machine_eps) * max(1.0, abs(y[j]))\n        pert_vec[j] = delta\n        \n        # Central difference formula\n        f_plus = f(t, y + pert_vec)\n        f_minus = f(t, y - pert_vec)\n        \n        J[:, j] = (f_plus - f_minus) / (2 * delta)\n        \n    return J\n\ndef stiffness_detector(f, t, y, h):\n    \"\"\"\n    Decides whether to use an implicit or explicit solver based on stability.\n    \n    Args:\n        f (callable): The RHS function of the ODE, f(t, y).\n        t (float): The evaluation time.\n        y (np.ndarray or float): The evaluation point.\n        h (float): The time step.\n        \n    Returns:\n        bool: True if an implicit solver is recommended, False otherwise.\n    \"\"\"\n    machine_eps = np.finfo(float).eps\n    J = numerical_jacobian(f, t, y, machine_eps)\n    eigenvalues = np.linalg.eigvals(J)\n    \n    # Check the absolute stability condition for Forward Euler for each eigenvalue.\n    # The region of absolute stability is |1 + h*lambda|  1.\n    # If any eigenvalue falls outside or on the boundary, we need an implicit method.\n    for lam in eigenvalues:\n        amplification_factor = 1 + h * lam\n        if np.abs(amplification_factor) >= 1.0:\n            return True  # Choose implicit solver\n\n    return False  # Explicit solver is acceptable\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the ODE functions for the test cases\n    def f1(t, y):\n        return -1000.0 * y\n\n    def f3(t, y):\n        omega = 50.0\n        zeta = 0.05\n        # y is a numpy array [y1, y2]\n        return np.array([y[1], -omega**2 * y[0] - 2 * zeta * omega * y[1]])\n\n    def f5(t, y):\n        k1 = 1.0\n        k2 = 1.0\n        k3 = 1000.0\n        # y is a numpy array [y1, y2]\n        return np.array([\n            -k1 * y[0] + k2 * y[1]**2,\n            k1 * y[0] - k2 * y[1]**2 - k3 * y[1]\n        ])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Scalar linear decay (happy path)\n        (f1, 0.0, 1.0, 1e-3),\n        # 2. Scalar linear decay (boundary)\n        (f1, 0.0, 1.0, 2e-3),\n        # 3. Damped oscillator (stable)\n        (f3, 0.0, np.array([1.0, 0.0]), 1e-3),\n        # 4. Damped oscillator (unstable)\n        (f3, 0.0, np.array([1.0, 0.0]), 5e-2),\n        # 5. Nonlinear reaction (stable)\n        (f5, 0.0, np.array([1.0, 1.0]), 1e-3),\n        # 6. Nonlinear reaction (unstable)\n        (f5, 0.0, np.array([1.0, 1.0]), 1e-2),\n    ]\n\n    results = []\n    for f, t, y, h in test_cases:\n        decision = stiffness_detector(f, t, y, h)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}