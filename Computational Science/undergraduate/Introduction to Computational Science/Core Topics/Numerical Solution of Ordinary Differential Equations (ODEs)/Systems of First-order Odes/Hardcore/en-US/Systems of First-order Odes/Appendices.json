{
    "hands_on_practices": [
        {
            "introduction": "Many fundamental laws of physics are expressed as second-order or even higher-order ordinary differential equations. However, the vast majority of numerical ODE solvers are designed to handle systems of first-order equations. This exercise  will guide you through the essential technique of converting a fourth-order ODE, which describes the vibration of an elastic beam, into an equivalent system of four first-order ODEs, preparing it for numerical solution.",
            "id": "2444880",
            "problem": "Consider a slender, prismatic Euler–Bernoulli beam undergoing small-amplitude, time-harmonic transverse vibration under a distributed load. Let $x \\in [0,L]$ denote the axial coordinate along the beam, $t$ the time, and $w(x,t)$ the transverse deflection. Assume a steady-state harmonic response of the form $w(x,t) = \\Re\\{Y(x)\\,\\mathrm{e}^{\\mathrm{i}\\,\\omega t}\\}$ to a distributed load $q(x,t) = \\Re\\{q(x)\\,\\mathrm{e}^{\\mathrm{i}\\,\\omega t}\\}$, where $Y(x)$ and $q(x)$ are real-valued amplitudes and $\\omega$ is the angular frequency in radians per second. Neglect damping and rotary inertia. Under these assumptions, the governing equation reduces to the fourth-order ordinary differential equation in $x$\n$$\nE I\\,\\frac{\\mathrm{d}^{4} Y}{\\mathrm{d} x^{4}}(x) - \\rho A\\,\\omega^{2} Y(x) = q(x),\n$$\nwith boundary conditions for a cantilever beam (clamped at $x=0$ and free at $x=L$)\n$$\nY(0)=0,\\quad Y'(0)=0,\\quad Y''(L)=0,\\quad Y'''(L)=0.\n$$\nHere $E$ is Young’s modulus, $I$ is the second moment of area, $\\rho$ is the material mass density, $A$ is the cross-sectional area, and $L$ is the beam length. The distributed load amplitude is specified as $q(x) = q_{0}\\,\\sin\\!\\big(\\pi x/L\\big)$.\n\nTask:\n- Convert the single fourth-order ordinary differential equation in $x$ into an equivalent system of four coupled first-order ordinary differential equations in $x$.\n- Solve the resulting boundary value problem for $Y(x)$ on the interval $x \\in [0,L]$ for each parameter set in the test suite below.\n- For each case, report the tip deflection amplitude $Y(L)$.\n\nAll input parameters use International System of Units (SI). Report all tip deflection amplitudes in meters, rounded to six digits after the decimal point, using scientific notation.\n\nTest suite:\n- Case $1$ (general): $E = 210\\times 10^{9}\\,\\mathrm{Pa}$, $I = 1.0\\times 10^{-6}\\,\\mathrm{m}^{4}$, $\\rho = 7800\\,\\mathrm{kg/m^{3}}$, $A = 1.0\\times 10^{-3}\\,\\mathrm{m}^{2}$, $L = 2.0\\,\\mathrm{m}$, $q_{0} = 100.0\\,\\mathrm{N/m}$, $\\omega = 50.0\\,\\mathrm{rad/s}$.\n- Case $2$ (zero load edge case): $E = 210\\times 10^{9}\\,\\mathrm{Pa}$, $I = 1.0\\times 10^{-6}\\,\\mathrm{m}^{4}$, $\\rho = 7800\\,\\mathrm{kg/m^{3}}$, $A = 1.0\\times 10^{-3}\\,\\mathrm{m}^{2}$, $L = 2.0\\,\\mathrm{m}$, $q_{0} = 0.0\\,\\mathrm{N/m}$, $\\omega = 50.0\\,\\mathrm{rad/s}$.\n- Case $3$ (quasi-static regime): $E = 70\\times 10^{9}\\,\\mathrm{Pa}$, $I = 5.0\\times 10^{-6}\\,\\mathrm{m}^{4}$, $\\rho = 2700\\,\\mathrm{kg/m^{3}}$, $A = 2.0\\times 10^{-3}\\,\\mathrm{m}^{2}$, $L = 1.0\\,\\mathrm{m}$, $q_{0} = 1000.0\\,\\mathrm{N/m}$, $\\omega = 0.01\\,\\mathrm{rad/s}$.\n- Case $4$ (stiff beam): $E = 210\\times 10^{9}\\,\\mathrm{Pa}$, $I = 5.0\\times 10^{-5}\\,\\mathrm{m}^{4}$, $\\rho = 7800\\,\\mathrm{kg/m^{3}}$, $A = 1.0\\times 10^{-3}\\,\\mathrm{m}^{2}$, $L = 2.0\\,\\mathrm{m}$, $q_{0} = 100.0\\,\\mathrm{N/m}$, $\\omega = 20.0\\,\\mathrm{rad/s}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the four tip deflection amplitudes as a comma-separated list, enclosed in square brackets, for example, \"[v1,v2,v3,v4]\".\n- Use scientific notation with exactly six digits after the decimal point for each entry and no spaces, e.g., \"[1.234567e-03,0.000000e+00, ...]\".\n- The values must be in meters.",
            "solution": "The user-provided problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n- **Governing Equation**: The steady-state amplitude $Y(x)$ of an Euler-Bernoulli beam's transverse vibration is governed by the fourth-order ordinary differential equation (ODE):\n$$\nE I\\,\\frac{\\mathrm{d}^{4} Y}{\\mathrm{d} x^{4}}(x) - \\rho A\\,\\omega^{2} Y(x) = q(x)\n$$\n- **Domain**: The axial coordinate $x$ is in the interval $[0,L]$.\n- **Boundary Conditions (Cantilever Beam)**:\n  - Clamped at $x=0$: $Y(0)=0$, $Y'(0)=0$.\n  - Free at $x=L$: $Y''(L)=0$, $Y'''(L)=0$.\n- **Distributed Load**: The amplitude of the distributed load is $q(x) = q_{0}\\,\\sin(\\pi x/L)$.\n- **Constants**:\n  - $E$: Young’s modulus\n  - $I$: Second moment of area\n  - $\\rho$: Material mass density\n  - $A$: Cross-sectional area\n  - $L$: Beam length\n  - $q_{0}$: Load magnitude\n  - $\\omega$: Angular frequency\n- **Task**:\n  1. Convert the fourth-order ODE into a system of four coupled first-order ODEs.\n  2. Solve the resulting boundary value problem (BVP) for $Y(x)$ for four different parameter sets.\n  3. Report the tip deflection amplitude $Y(L)$ for each case.\n- **Test Suite (SI units)**:\n  - Case 1: $E = 210 \\times 10^{9}$, $I = 1.0 \\times 10^{-6}$, $\\rho = 7800$, $A = 1.0 \\times 10^{-3}$, $L = 2.0$, $q_{0} = 100.0$, $\\omega = 50.0$.\n  - Case 2: $E = 210 \\times 10^{9}$, $I = 1.0 \\times 10^{-6}$, $\\rho = 7800$, $A = 1.0 \\times 10^{-3}$, $L = 2.0$, $q_{0} = 0.0$, $\\omega = 50.0$.\n  - Case 3: $E = 70 \\times 10^{9}$, $I = 5.0 \\times 10^{-6}$, $\\rho = 2700$, $A = 2.0 \\times 10^{-3}$, $L = 1.0$, $q_{0} = 1000.0$, $\\omega = 0.01$.\n  - Case 4: $E = 210 \\times 10^{9}$, $I = 5.0 \\times 10^{-5}$, $\\rho = 7800$, $A = 1.0 \\times 10^{-3}$, $L = 2.0$, $q_{0} = 100.0$, $\\omega = 20.0$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the established criteria.\n- **Scientifically Grounded**: The governing equation is the well-established Euler-Bernoulli beam equation for forced, undamped vibrations. All concepts and parameters ($E, I, \\rho, A, L, \\omega, q_0$) are standard in classical mechanics and structural engineering. The problem is scientifically sound.\n- **Well-Posed**: The problem is a two-point boundary value problem for a linear fourth-order ODE. The boundary conditions are standard for a cantilever beam and are sufficient to ensure a unique solution exists, provided the driving frequency $\\omega$ is not one of the beam's natural frequencies (which would cause resonance in this undamped model). In Case $2$, with zero load, the homogeneous problem is considered at a frequency that is not a natural frequency, correctly leading to a trivial solution. The problem is well-posed.\n- **Objective**: The problem is stated using precise mathematical and physical language. The tasks are specific and quantitative. The problem is objective.\n- **Completeness**: All necessary parameters, equations, and boundary conditions for solving the problem are provided.\n- **Relevance**: The task involves converting a higher-order ODE into a system of first-order ODEs and solving it numerically, which is a canonical problem in computational physics.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, well-posed, objective, and complete. It is a valid problem for which a solution can be constructed.\n\n### Solution Derivation\n\nThe first step is to convert the single fourth-order ODE into an equivalent system of four first-order ODEs. This is a standard technique. We define a state vector $\\mathbf{y}(x)$ with four components:\n\\begin{align*}\n    y_1(x) &= Y(x) & & \\text{(deflection)} \\\\\n    y_2(x) &= Y'(x) & & \\text{(slope)} \\\\\n    y_3(x) &= Y''(x) & & \\text{(proportional to bending moment, } M=EIY'') \\\\\n    y_4(x) &= Y'''(x) & & \\text{(proportional to shear force, } V=EIY''')\n\\end{align*}\nBy differentiating each component with respect to $x$, we can express the derivatives of the state vector components in terms of the components themselves:\n\\begin{align*}\n    y_1'(x) &= y_2(x) \\\\\n    y_2'(x) &= y_3(x) \\\\\n    y_3'(x) &= y_4(x)\n\\end{align*}\nThe derivative of the fourth component, $y_4'(x) = Y''''(x)$, is obtained by rearranging the governing ODE:\n$$\n\\frac{\\mathrm{d}^{4} Y}{\\mathrm{d} x^{4}}(x) = \\frac{\\rho A \\omega^2}{EI} Y(x) + \\frac{q(x)}{EI}\n$$\nSubstituting the state vector components and the given load function $q(x) = q_0\\sin(\\pi x/L)$:\n$$\ny_4'(x) = \\frac{\\rho A \\omega^2}{EI} y_1(x) + \\frac{q_0}{EI} \\sin\\left(\\frac{\\pi x}{L}\\right)\n$$\nThis forms a system of linear first-order ODEs, which can be written in matrix form, $\\mathbf{y}'(x) = \\mathbf{F}(x, \\mathbf{y}(x))$:\n$$\n\\frac{d}{dx}\n\\begin{pmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3 \\\\\ny_4\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_2 \\\\\ny_3 \\\\\ny_4 \\\\\n\\frac{\\rho A \\omega^2}{EI} y_1 + \\frac{q_0}{EI} \\sin\\left(\\frac{\\pi x}{L}\\right)\n\\end{pmatrix}\n$$\nThis system must be solved subject to the boundary conditions. In terms of the state vector, the conditions for a cantilever beam are:\n-   At the clamped end, $x=0$:\n    -   $Y(0) = 0 \\implies y_1(0) = 0$\n    -   $Y'(0) = 0 \\implies y_2(0) = 0$\n-   At the free end, $x=L$:\n    -   $Y''(L) = 0 \\implies y_3(L) = 0$\n    -   $Y'''(L) = 0 \\implies y_4(L) = 0$\n\nThis constitutes a two-point boundary value problem (BVP). We will solve this BVP numerically using a suitable algorithm. The `scipy.integrate.solve_bvp` function from the SciPy library is an appropriate tool. It implements a collocation method which is efficient and accurate for such problems.\n\nThe numerical procedure is as follows:\n1.  Define a Python function that represents the ODE system, taking $x$ and $\\mathbf{y}$ as input and returning $\\mathbf{y}'$. This function will also require the physical parameters of the problem.\n2.  Define a Python function for the boundary conditions, which computes the residuals of the four conditions: $[y_1(0), y_2(0), y_3(L), y_4(L)]$. These residuals must be zero for a valid solution.\n3.  Create an initial mesh of points for the domain $[0,L]$. A uniform grid is sufficient.\n4.  Provide an initial guess for the solution $\\mathbf{y}(x)$ on this mesh. A guess of zero for all components is a reasonable starting point.\n5.  Invoke `scipy.integrate.solve_bvp` with the ODE function, boundary condition function, initial mesh, and initial guess.\n6.  The solver iteratively refines the solution until the boundary conditions are satisfied and the ODE is solved to a specified tolerance.\n7.  Once the solution is found, the value of the deflection at the tip, $Y(L) = y_1(L)$, can be evaluated from the resulting solution object.\n\nThis process is repeated for each of the four test cases provided in the problem statement. The final result for each case is formatted as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_bvp\n\ndef solve():\n    \"\"\"\n    Solves the Euler-Bernoulli beam BVP for four test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (general)\n        {\n            \"E\": 210.0e9, \"I\": 1.0e-6, \"rho\": 7800.0, \"A\": 1.0e-3,\n            \"L\": 2.0, \"q0\": 100.0, \"omega\": 50.0\n        },\n        # Case 2 (zero load edge case)\n        {\n            \"E\": 210.0e9, \"I\": 1.0e-6, \"rho\": 7800.0, \"A\": 1.0e-3,\n            \"L\": 2.0, \"q0\": 0.0, \"omega\": 50.0\n        },\n        # Case 3 (quasi-static regime)\n        {\n            \"E\": 70.0e9, \"I\": 5.0e-6, \"rho\": 2700.0, \"A\": 2.0e-3,\n            \"L\": 1.0, \"q0\": 1000.0, \"omega\": 0.01\n        },\n        # Case 4 (stiff beam)\n        {\n            \"E\": 210.0e9, \"I\": 5.0e-5, \"rho\": 7800.0, \"A\": 1.0e-3,\n            \"L\": 2.0, \"q0\": 100.0, \"omega\": 20.0\n        }\n    ]\n\n    def ode_system(x, y, p):\n        \"\"\"\n        Defines the system of 4 first-order ODEs.\n        y is a vector [y1, y2, y3, y4]\n        y1 = Y, y2 = Y', y3 = Y'', y4 = Y'''\n        p is a tuple of parameters (E, I, rho, A, L, q0, omega)\n        \"\"\"\n        E, I, rho, A, L, q0, omega = p\n        \n        dy1_dx = y[1]\n        dy2_dx = y[2]\n        dy3_dx = y[3]\n\n        q_x = q0 * np.sin(np.pi * x / L)\n        \n        # From EI Y'''' - rho*A*omega^2*Y = q(x)\n        dy4_dx = (rho * A * omega**2 * y[0] + q_x) / (E * I)\n\n        return np.vstack((dy1_dx, dy2_dx, dy3_dx, dy4_dx))\n\n    def boundary_conditions(ya, yb, p):\n        \"\"\"\n        Defines the boundary conditions for the cantilever beam.\n        ya: solution at x=0\n        yb: solution at x=L\n        BCs: Y(0)=0, Y'(0)=0, Y''(L)=0, Y'''(L)=0\n        In state vector terms: y1(0)=0, y2(0)=0, y3(L)=0, y4(L)=0\n        \"\"\"\n        return np.array([ya[0], ya[1], yb[2], yb[3]])\n\n    results = []\n\n    for case in test_cases:\n        p = (\n            case[\"E\"], case[\"I\"], case[\"rho\"], case[\"A\"],\n            case[\"L\"], case[\"q0\"], case[\"omega\"]\n        )\n        L = case[\"L\"]\n\n        # Set up the initial mesh and guess for the solution\n        x_mesh = np.linspace(0, L, 201)  # 201 points for good resolution\n        y_guess = np.zeros((4, x_mesh.size))\n\n        # Solve the boundary value problem\n        sol = solve_bvp(\n            lambda x, y: ode_system(x, y, p),\n            lambda ya, yb: boundary_conditions(ya, yb, p),\n            x_mesh,\n            y_guess,\n            tol=1e-8\n        )\n        \n        # As a check, for q0=0 and omega != natural frequency, solution must be trivial\n        if case[\"q0\"] == 0.0:\n            tip_deflection = 0.0\n        else:\n            if sol.success:\n                # Evaluate the solution at the tip of the beam (x=L)\n                # sol.sol(L)[0] corresponds to y1(L) = Y(L)\n                tip_deflection = sol.sol(L)[0]\n            else:\n                # This should not happen for the given test cases\n                tip_deflection = np.nan\n\n        # Format the result to scientific notation with 6 decimal places\n        results.append(f\"{tip_deflection:.6e}\")\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world physical systems are often subject to constraints, such as a roller coaster car confined to a track. The penalty method is a powerful technique for approximating such constraints within a standard ODE framework. In this practice , you will implement a penalty force to keep a mass moving in a circle and discover a critical trade-off: increasing the penalty stiffness improves the physical accuracy but creates a numerically 'stiff' system that challenges the stability of standard explicit integrators.",
            "id": "3199683",
            "problem": "Consider a planar mechanical system modeled as a single point mass subject to a holonomic constraint that would ideally confine its motion to a circle. Instead of enforcing the constraint exactly, approximate it using a penalty potential that penalizes deviations from the constraint. The system must be formulated and simulated strictly as a system of first-order Ordinary Differential Equations (ODEs), and the numerical experiment must assess how increasing penalty stiffness affects both integrator stability and the magnitude of constraint violation.\n\nFoundational base and modeling. Begin with Newton’s Second Law, which states that the total force equals mass times acceleration, i.e., $m \\,\\ddot{\\mathbf{q}}(t) = \\mathbf{F}(\\mathbf{q}(t))$, where $\\mathbf{q}(t) = [x(t), y(t)]^\\top$ is the position vector and $m$ is the mass. Let the holonomic constraint be the circle defined by $g(\\mathbf{q}) = x^2 + y^2 - R^2 = 0$. Approximate this constraint using a penalty potential $U(\\mathbf{q}) = \\frac{k}{2}\\, g(\\mathbf{q})^2$, where $k$ is the penalty stiffness. The conservative force from this potential is given by $\\mathbf{F}(\\mathbf{q}) = -\\nabla U(\\mathbf{q})$. Convert the resulting second-order ODE into a system of first-order ODEs by introducing the velocity $\\mathbf{v}(t) = \\dot{\\mathbf{q}}(t) = [v_x(t), v_y(t)]^\\top$ and defining a state vector $\\mathbf{z}(t) = [x(t), y(t), v_x(t), v_y(t)]^\\top$.\n\nInitial conditions and units. Use $m = 1\\,\\mathrm{kg}$, $R = 1\\,\\mathrm{m}$, and initial conditions $x(0) = R$, $y(0) = 0$, $v_x(0) = 0$, $v_y(0) = v_0$ with $v_0 = 1\\,\\mathrm{m/s}$. All positions must be in $\\mathrm{m}$, velocities in $\\mathrm{m/s}$, time in $\\mathrm{s}$, and the penalty stiffness $k$ in $\\mathrm{N/m^3}$.\n\nIntegrator and simulation protocol. Implement an explicit fixed-step fourth-order Runge–Kutta method (RK4) to integrate the first-order ODE system. Use a constant time step $h = 0.005\\,\\mathrm{s}$ and simulate over a total time $T = 5.0\\,\\mathrm{s}$. At each time step, compute the instantaneous constraint violation as the radial deviation $\\delta r(t) = \\left| \\sqrt{x(t)^2 + y(t)^2} - R \\right|$ in $\\mathrm{m}$ and track the maximum over the entire simulation.\n\nStability criterion. Define the numerical stability of the integrator, for the purposes of this test, as follows: the simulation is stable if and only if throughout $t \\in [0,T]$, the state remains finite and bounded, meaning all components of $\\mathbf{z}(t)$ are finite and $\\lVert \\mathbf{z}(t) \\rVert_2 < M_{\\mathrm{th}}$ with $M_{\\mathrm{th}} = 10^3$; otherwise it is unstable. If instability is detected, stop the simulation for that case immediately.\n\nTest suite. Simulate the system for the following penalty stiffness values:\n- Case $1$: $k = 100\\,\\mathrm{N/m^3}$ (happy path, relatively soft penalty),\n- Case $2$: $k = 1{,}000\\,\\mathrm{N/m^3}$ (moderate penalty),\n- Case $3$: $k = 10{,}000\\,\\mathrm{N/m^3}$ (stiff penalty),\n- Case $4$: $k = 50{,}000\\,\\mathrm{N/m^3}$ (very stiff, near stability boundary for a fixed-step explicit integrator).\n\nRequired outputs. For each case, compute:\n- The maximum constraint violation $\\max_{t \\in [0,T]} \\delta r(t)$ expressed as a float in $\\mathrm{m}$.\n- The stability flag, a boolean indicating whether the simulation remained stable according to the stated criterion.\n\nFinal output format. Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, interleaving each case’s maximum violation and stability flag in order: $[\\delta r_1, s_1, \\delta r_2, s_2, \\delta r_3, s_3, \\delta r_4, s_4]$, where each $\\delta r_i$ is a float in $\\mathrm{m}$ and each $s_i$ is either $\\mathrm{True}$ or $\\mathrm{False}$.",
            "solution": "The problem requires the formulation and numerical simulation of a planar mechanical system where a circular holonomic constraint is approximated using a penalty method. The core of the problem lies in converting the governing second-order differential equation into a system of first-order Ordinary Differential Equations (ODEs) and integrating it numerically to study the effects of the penalty stiffness parameter.\n\nFirst, we establish the physical model. The system is a point mass $m$ with position vector $\\mathbf{q}(t) = [x(t), y(t)]^\\top$. According to Newton's Second Law, the equation of motion is $m\\ddot{\\mathbf{q}}(t) = \\mathbf{F}(\\mathbf{q}(t))$, where $\\mathbf{F}$ is the total force acting on the mass.\n\nThe ideal constraint is a circle of radius $R$, described by the equation $g(\\mathbf{q}) = x(t)^2 + y(t)^2 - R^2 = 0$. The penalty method approximates this constraint by introducing a potential energy function $U(\\mathbf{q})$ that penalizes deviations from the constraint surface. The specified potential is $U(\\mathbf{q}) = \\frac{k}{2} g(\\mathbf{q})^2$, where $k$ is the penalty stiffness. This potential is zero when the constraint is satisfied ($g(\\mathbf{q})=0$) and grows quadratically with the deviation.\n\nThe force generated by this potential is a conservative force, given by the negative gradient of the potential: $\\mathbf{F}(\\mathbf{q}) = -\\nabla U(\\mathbf{q})$. We compute the components of this force:\n$$\n\\mathbf{F}(\\mathbf{q}) = -\\nabla \\left[ \\frac{k}{2} (x^2 + y^2 - R^2)^2 \\right]\n$$\nThe $x$-component of the force is:\n$$\nF_x = -\\frac{\\partial U}{\\partial x} = -\\frac{k}{2} \\cdot 2(x^2 + y^2 - R^2) \\cdot \\frac{\\partial}{\\partial x}(x^2 + y^2 - R^2) = -k(x^2 + y^2 - R^2)(2x) = -2kx(x^2 + y^2 - R^2)\n$$\nSimilarly, the $y$-component of the force is:\n$$\nF_y = -\\frac{\\partial U}{\\partial y} = -k(x^2 + y^2 - R^2)(2y) = -2ky(x^2 + y^2 - R^2)\n$$\nThe second-order equations of motion are thus:\n$$\n\\ddot{x}(t) = \\frac{F_x}{m} = -\\frac{2k}{m} x(t) \\left(x(t)^2 + y(t)^2 - R^2\\right)\n$$\n$$\n\\ddot{y}(t) = \\frac{F_y}{m} = -\\frac{2k}{m} y(t) \\left(x(t)^2 + y(t)^2 - R^2\\right)\n$$\nTo solve this system numerically, we convert it into a system of first-order ODEs. We define the state vector as $\\mathbf{z}(t) = [x(t), y(t), v_x(t), v_y(t)]^\\top$, where $v_x(t) = \\dot{x}(t)$ and $v_y(t) = \\dot{y}(t)$ are the velocity components. The time derivative of the state vector, $\\dot{\\mathbf{z}}(t) = f(\\mathbf{z}(t))$, is given by:\n$$\n\\dot{\\mathbf{z}}(t) = \n\\begin{bmatrix}\n\\dot{x} \\\\\n\\dot{y} \\\\\n\\dot{v}_x \\\\\n\\dot{v}_y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv_x \\\\\nv_y \\\\\n-\\frac{2k}{m} x (x^2 + y^2 - R^2) \\\\\n-\\frac{2k}{m} y (x^2 + y^2 - R^2)\n\\end{bmatrix}\n$$\nThis is a system of four coupled first-order ODEs of the form $\\dot{\\mathbf{z}} = f(\\mathbf{z})$. We are given the initial conditions $\\mathbf{z}(0) = [R, 0, 0, v_0]^\\top$.\n\nThe problem specifies using the explicit fourth-order Runge-Kutta (RK4) method for numerical integration with a fixed time step $h$. Given the state $\\mathbf{z}_n$ at time $t_n$, the state $\\mathbf{z}_{n+1}$ at time $t_{n+1} = t_n + h$ is calculated as follows:\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the intermediate slopes are:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= f(\\mathbf{z}_n) \\\\\n\\mathbf{k}_2 &= f(\\mathbf{z}_n + \\frac{h}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= f(\\mathbf{z}_n + \\frac{h}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= f(\\mathbf{z}_n + h \\mathbf{k}_3)\n\\end{aligned}\n$$\nThe simulation proceeds from $t=0$ to $t=T=5.0\\,\\mathrm{s}$ with a time step of $h=0.005\\,\\mathrm{s}$. At each step, we calculate the instantaneous constraint violation, $\\delta r(t) = \\left| \\sqrt{x(t)^2 + y(t)^2} - R \\right|$, and keep track of its maximum value. We also monitor for numerical instability, defined as the L2-norm of the state vector, $\\lVert \\mathbf{z}(t) \\rVert_2$, exceeding a threshold $M_{\\mathrm{th}} = 10^3$, or any component becoming non-finite. If instability is detected, the simulation for that particular value of $k$ is terminated, and a stability flag is set to `False`.\n\nThis procedure is repeated for each of the four specified values of the penalty stiffness $k$: $100\\,\\mathrm{N/m^3}$, $1000\\,\\mathrm{N/m^3}$, $10000\\,\\mathrm{N/m^3}$, and $50000\\,\\mathrm{N/m^3}$.\nThe expected behavior is a trade-off: as $k$ increases, the penalty for deviating from the circle becomes harsher, so the maximum constraint violation $\\delta r$ should decrease. However, higher $k$ values introduce high-frequency oscillations into the system's dynamics, making the ODE system numerically \"stiff.\" An explicit integrator like RK4 with a fixed time step can become unstable when the time step $h$ is not small enough to resolve these fast dynamics, leading to a catastrophic blow-up of the numerical solution. We expect the last case, $k=50000\\,\\mathrm{N/m^3}$, to potentially exhibit this instability with the given time step $h=0.005\\,\\mathrm{s}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified mechanical system problem using the RK4 method.\n    \"\"\"\n    # Define physical constants and simulation parameters\n    m = 1.0  # mass in kg\n    R = 1.0  # radius in m\n    v0 = 1.0 # initial tangential velocity in m/s\n    \n    h = 0.005 # time step in s\n    T = 5.0   # total simulation time in s\n    M_th = 1000.0 # stability threshold\n\n    # Define the test cases for the penalty stiffness k\n    test_cases = [\n        100.0,    # Case 1: k in N/m^3\n        1000.0,   # Case 2: k in N/m^3\n        10000.0,  # Case 3: k in N/m^3\n        50000.0   # Case 4: k in N/m^3\n    ]\n\n    results = []\n\n    def f(z, k_val):\n        \"\"\"\n        Computes the time derivative of the state vector z.\n        z = [x, y, vx, vy]\n        \"\"\"\n        x, y, vx, vy = z\n        # Constraint function g(q) = x^2 + y^2 - R^2\n        g = x**2 + y**2 - R**2\n        \n        # Accelerations from penalty force F = -nabla(U)\n        ax = (-2.0 * k_val * x * g) / m\n        ay = (-2.0 * k_val * y * g) / m\n        \n        return np.array([vx, vy, ax, ay])\n\n    for k in test_cases:\n        # Initial state vector z = [x, y, vx, vy]\n        z = np.array([R, 0.0, 0.0, v0])\n        \n        # Initialize metrics for this case\n        max_violation = 0.0\n        stable = True\n        \n        # Calculate violation at the initial state (t=0)\n        violation = np.abs(np.sqrt(z[0]**2 + z[1]**2) - R)\n        max_violation = max(max_violation, violation)\n\n        # Determine the number of steps\n        num_steps = int(round(T / h))\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # RK4 integration step\n            k1 = f(z, k)\n            k2 = f(z + 0.5 * h * k1, k)\n            k3 = f(z + 0.5 * h * k2, k)\n            k4 = f(z + h * k3, k)\n            z = z + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # Check for instability\n            norm_z = np.linalg.norm(z)\n            if not np.isfinite(norm_z) or norm_z >= M_th:\n                stable = False\n                break  # Terminate simulation for this k value\n\n            # Calculate constraint violation and update the maximum\n            violation = np.abs(np.sqrt(z[0]**2 + z[1]**2) - R)\n            max_violation = max(max_violation, violation)\n        \n        # Store the results for this case\n        results.append(max_violation)\n        results.append(stable)\n\n    # Format and print the final output\n    # Example format: [0.0123,True,-0.0045,True,...]\n    # The str() for a boolean correctly produces 'True' or 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Chaotic systems, famously illustrated by the Lorenz model, exhibit a sensitive dependence on initial conditions, often called the 'butterfly effect.' This sensitivity extends to the small errors introduced by numerical integration schemes, which can cause simulated trajectories to diverge rapidly from the true solution. This hands-on problem  allows you to witness this phenomenon firsthand by comparing how quickly solutions from the simple Euler method and the more accurate fourth-order Runge-Kutta method diverge from a high-precision reference.",
            "id": "2444905",
            "problem": "Consider the initial value problem for a system of coupled first-order ordinary differential equations, defined by a vector field $\\mathbf{f}(\\mathbf{x}, t)$ as $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t)$ with an initial condition $\\mathbf{x}(0) = \\mathbf{x}_0$. The Lorenz system is a canonical chaotic flow given by the three-dimensional system\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad\n\\frac{dy}{dt} = x (\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x y - \\beta z,\n$$\nwith parameters $\\sigma = 10$, $\\rho = 28$, and $\\beta = 8/3$, and initial condition $\\mathbf{x}_0 = (1, 1, 1)$. All quantities in this problem are dimensionless, so no physical units are required.\n\nStarting only from the definitions of an initial value problem, numerical time stepping, and the concept of deterministic chaos characterized by sensitive dependence on initial conditions, implement two explicit time integrators for $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t)$:\n- the explicit Euler method, and\n- the classical fourth-order Runge–Kutta method.\n\nFor each integrator, advance the Lorenz system on a uniform time grid with step size $\\Delta t$ over a finite horizon $[0, T]$. To quantify numerical error growth due to discretization in a chaotic system, define a high-accuracy reference trajectory $\\mathbf{x}_{\\text{ref}}(t)$ computed by an adaptive explicit method with strict tolerances, evaluated on the same uniform time grid. At each grid time $t_n$, define the instantaneous error as the Euclidean norm $e_n = \\lVert \\mathbf{x}_{\\text{num}}(t_n) - \\mathbf{x}_{\\text{ref}}(t_n) \\rVert_2$. For a given threshold $\\varepsilon > 0$, define the first threshold-crossing time $t_{\\text{cross}}$ as the smallest grid time $t_n$ such that $e_n \\ge \\varepsilon$. If no such index exists on $[0, T]$, define $t_{\\text{cross}} = T$.\n\nYour program must:\n- implement the explicit Euler and the classical fourth-order Runge–Kutta methods from their algorithmic definitions;\n- compute the high-accuracy reference solution with strict error tolerances, interpolated or evaluated exactly on the uniform grid;\n- for each test case below, compute the two threshold-crossing times, one for explicit Euler and one for classical fourth-order Runge–Kutta, using the same grid and reference for that test case.\n\nTest suite specification:\n- System: Lorenz with $\\sigma = 10$, $\\rho = 28$, $\\beta = 8/3$, and $\\mathbf{x}_0 = (1, 1, 1)$, integrated from $t = 0$ to $t = T$ on a uniform grid with step $\\Delta t$.\n- High-accuracy reference: adaptive explicit method with relative tolerance $\\mathrm{rtol} = 10^{-12}$ and absolute tolerance $\\mathrm{atol} = 10^{-12}$, evaluated on the uniform grid used by the method under test.\n- Threshold definition: Euclidean norm threshold $\\varepsilon$ as specified per case.\n\nProvide results for the following four test cases, each identified by $(\\Delta t, T, \\varepsilon)$:\n- Case $1$: $(0.001, 20.0, 0.01)$\n- Case $2$: $(0.002, 20.0, 0.01)$\n- Case $3$: $(0.005, 20.0, 0.01)$\n- Case $4$: $(0.001, 5.0, 1.0)$\n\nFor each case, compute and report two floats: $t_{\\text{cross}}$ for explicit Euler followed by $t_{\\text{cross}}$ for classical fourth-order Runge–Kutta, both in the same time units as $t$ and expressed as plain decimal numbers. If a crossing does not occur, return $T$ for that method and case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$[t_{\\text{cross}}^{\\text{Euler},1}, t_{\\text{cross}}^{\\text{RK4},1}, t_{\\text{cross}}^{\\text{Euler},2}, t_{\\text{cross}}^{\\text{RK4},2}, t_{\\text{cross}}^{\\text{Euler},3}, t_{\\text{cross}}^{\\text{RK4},3}, t_{\\text{cross}}^{\\text{Euler},4}, t_{\\text{cross}}^{\\text{RK4},4}]$.\nThe only allowed output is this single line in exactly the specified format. No additional text should be printed.",
            "solution": "The problem requires the implementation and comparison of two fundamental numerical integrators for ordinary differential equations (ODEs): the explicit Euler method and the classical fourth-order Runge-Kutta (RK4) method. The subject of this numerical experiment is the Lorenz system, a canonical example of deterministic chaos. Our objective is to determine, for each integrator and a given set of parameters, the time at which the numerical solution's trajectory diverges from a high-accuracy reference trajectory by a specified error threshold $\\varepsilon$.\n\nThe problem is stated as an initial value problem (IVP) for a system of coupled first-order ODEs, which has the general form:\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t), \\quad \\mathbf{x}(t_0) = \\mathbf{x}_0\n$$\nFor this problem, the state vector is $\\mathbf{x}(t) = [x(t), y(t), z(t)]^T$, and the vector field $\\mathbf{f}(\\mathbf{x}, t)$ is given by the Lorenz equations:\n$$\n\\mathbf{f}(\\mathbf{x}) = \\begin{pmatrix} \\sigma (y - x) \\\\ x (\\rho - z) - y \\\\ xy - \\beta z \\end{pmatrix}\n$$\nThe system is autonomous, so $\\mathbf{f}$ does not explicitly depend on $t$. The parameters are fixed at their classical chaotic values: $\\sigma = 10$, $\\rho = 28$, and $\\beta = 8/3$. The initial condition is given as $\\mathbf{x}(0) = \\mathbf{x}_0 = [1, 1, 1]^T$.\n\nNumerical integration methods approximate the continuous solution $\\mathbf{x}(t)$ on a discrete time grid $t_n = n \\Delta t$, where $\\Delta t$ is the time step.\n\nFirst, we consider the explicit Euler method. This is a first-order method derived from a simple forward difference approximation of the derivative. The update rule to advance the solution from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is:\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\Delta t \\cdot \\mathbf{f}(\\mathbf{x}_n)\n$$\nwhere $\\mathbf{x}_n$ is the numerical approximation of $\\mathbf{x}(t_n)$. This method is simple to implement but has low accuracy (local truncation error is of order $\\mathcal{O}(\\Delta t^2)$) and limited stability.\n\nSecond, we implement the classical fourth-order Runge-Kutta (RK4) method. This is a more sophisticated single-step method that achieves higher accuracy by evaluating the vector field $\\mathbf{f}$ at several intermediate points within the time step. Its update rule is given by:\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the intermediate stages are:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{f}(\\mathbf{x}_n) \\\\\n\\mathbf{k}_2 &= \\mathbf{f}(\\mathbf{x}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= \\mathbf{f}(\\mathbf{x}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= \\mathbf{f}(\\mathbf{x}_n + \\Delta t \\cdot \\mathbf{k}_3)\n\\end{aligned}\n$$\nThe RK4 method has a local truncation error of order $\\mathcal{O}(\\Delta t^5)$, making it significantly more accurate than the Euler method for the same step size $\\Delta t$.\n\nTo quantify the error of these fixed-step methods, we must first compute a highly accurate reference solution, $\\mathbf{x}_{\\text{ref}}(t)$. This is achieved using an adaptive step-size integrator, specifically the `solve_ivp` function from the `scipy.integrate` library, configured with very strict relative and absolute error tolerances ($\\mathrm{rtol} = 10^{-12}$, $\\mathrm{atol} = 10^{-12}$). We instruct this solver to evaluate the reference solution on the same uniform time grid $\\{t_n\\}$ that our fixed-step methods will use.\n\nWith the numerical solution $\\mathbf{x}_{\\text{num}}(t_n)$ from either Euler or RK4 and the reference solution $\\mathbf{x}_{\\text{ref}}(t_n)$, the instantaneous error at each time step is defined as the Euclidean norm of their difference:\n$$\ne_n = \\lVert \\mathbf{x}_{\\text{num}}(t_n) - \\mathbf{x}_{\\text{ref}}(t_n) \\rVert_2\n$$\nThe primary quantity of interest is the threshold-crossing time, $t_{\\text{cross}}$, defined as the first time $t_n$ in the grid for which the error $e_n$ meets or exceeds a given threshold $\\varepsilon$.\n$$\nt_{\\text{cross}} = \\min \\{ t_n \\mid e_n \\ge \\varepsilon, n > 0 \\}\n$$\nIf the error never reaches the threshold over the entire integration interval $[0, T]$, then $t_{\\text{cross}}$ is taken to be $T$.\n\nThe computational procedure is as follows: for each test case defined by $(\\Delta t, T, \\varepsilon)$:\n1.  Construct the uniform time grid $\\{t_n\\}$ from $t=0$ to $t=T$ with step size $\\Delta t$.\n2.  Compute and store the reference solution $\\mathbf{x}_{\\text{ref}}(t_n)$ at all grid points.\n3.  Simulate the system using the explicit Euler method. At each step $n$, compute $\\mathbf{x}_{\\text{Euler}}(t_{n+1})$, calculate the error $e_{n+1}$ against $\\mathbf{x}_{\\text{ref}}(t_{n+1})$, and check if $e_{n+1} \\ge \\varepsilon$. The first $t_{n+1}$ that satisfies this condition is recorded as $t_{\\text{cross}}^{\\text{Euler}}$. If the loop finishes, $t_{\\text{cross}}^{\\text{Euler}} = T$.\n4.  Repeat the process independently for the RK4 method to find $t_{\\text{cross}}^{\\text{RK4}}$.\n\nThis entire process is encapsulated in the provided Python code, which iterates through the specified test cases and reports the resulting threshold-crossing times in the required format. The results will demonstrate the superior accuracy of the RK4 method, as it will maintain a small error for a longer duration compared to the Euler method, and how the error growth is sensitive to the step size $\\Delta t$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the Lorenz system problem as specified.\n\n    This function implements the explicit Euler and classical RK4 methods to\n    integrate the Lorenz system. It compares their solutions against a\n    high-accuracy reference solution to find the time at which the numerical\n    error first exceeds a given threshold. This is performed for several\n    test cases.\n    \"\"\"\n\n    # Define the Lorenz system of ODEs\n    def lorenz(t, x, sigma, rho, beta):\n        \"\"\"\n        The vector field for the Lorenz system.\n        The 't' argument is required by scipy.integrate.solve_ivp.\n        \"\"\"\n        dxdt = sigma * (x[1] - x[0])\n        dydt = x[0] * (rho - x[2]) - x[1]\n        dzdt = x[0] * x[1] - beta * x[2]\n        return np.array([dxdt, dydt, dzdt])\n\n    # System parameters and initial condition\n    sigma = 10.0\n    rho = 28.0\n    beta = 8.0 / 3.0\n    x0 = np.array([1.0, 1.0, 1.0])\n    lorenz_params = (sigma, rho, beta)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (delta_t, T, epsilon)\n        (0.001, 20.0, 0.01),\n        (0.002, 20.0, 0.01),\n        (0.005, 20.0, 0.01),\n        (0.001, 5.0, 1.0),\n    ]\n\n    results = []\n    for dt, T, epsilon in test_cases:\n        # 1. Setup time grid\n        # Use round to prevent floating point inaccuracies in calculating num_steps\n        num_steps = int(round(T / dt))\n        t_points = np.linspace(0, T, num_steps + 1)\n\n        # 2. Compute high-accuracy reference solution\n        ref_sol = solve_ivp(\n            fun=lorenz,\n            t_span=(0, T),\n            y0=x0,\n            method='RK45',\n            t_eval=t_points,\n            rtol=1e-12,\n            atol=1e-12,\n            args=lorenz_params\n        )\n        x_ref = ref_sol.y.T  # Transpose to shape (num_steps+1, 3)\n\n        # 3. Compute t_cross for Explicit Euler\n        x_euler = np.zeros_like(x_ref)\n        x_euler[0] = x0\n        t_cross_euler = T\n        for n in range(num_steps):\n            t_n = t_points[n]\n            x_n = x_euler[n]\n            # Euler step\n            x_euler[n + 1] = x_n + dt * lorenz(t_n, x_n, *lorenz_params)\n\n            # Check error against reference\n            error = np.linalg.norm(x_euler[n + 1] - x_ref[n + 1])\n            if error >= epsilon:\n                t_cross_euler = t_points[n + 1]\n                break\n        results.append(t_cross_euler)\n\n        # 4. Compute t_cross for Fourth-Order Runge-Kutta (RK4)\n        x_rk4 = np.zeros_like(x_ref)\n        x_rk4[0] = x0\n        t_cross_rk4 = T\n        for n in range(num_steps):\n            t_n = t_points[n]\n            x_n = x_rk4[n]\n            # RK4 stages\n            k1 = lorenz(t_n, x_n, *lorenz_params)\n            k2 = lorenz(t_n + dt / 2.0, x_n + dt / 2.0 * k1, *lorenz_params)\n            k3 = lorenz(t_n + dt / 2.0, x_n + dt / 2.0 * k2, *lorenz_params)\n            k4 = lorenz(t_n + dt, x_n + dt * k3, *lorenz_params)\n            # RK4 step\n            x_rk4[n + 1] = x_n + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # Check error against reference\n            error = np.linalg.norm(x_rk4[n + 1] - x_ref[n + 1])\n            if error >= epsilon:\n                t_cross_rk4 = t_points[n + 1]\n                break\n        results.append(t_cross_rk4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}