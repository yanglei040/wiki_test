{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，真正的挑战在于实践。本练习将引导你实现一个有限差分求解器，并探索一个核心概念：局部截断误差如何影响全局收敛阶。通过对比不同精度的边界条件处理方式，你将亲眼见证，即使只是在单个边界点上使用低阶近似，也会如何“污染”整个求解区域，从而降低方法的整体精度 。",
            "id": "3127744",
            "problem": "考虑一个线性二阶常微分方程边值问题（BVP）：寻找一个足够光滑的函数 $u(x)$，使得在 $x \\in [0,1]$ 上满足 $-u''(x) + u(x) = f(x)$，并服从混合边界条件，即左端点为 Robin 条件，右端点为 Dirichlet 条件。在 $x=0$ 处的 Robin 边界条件为 $u'(0) + \\beta\\,u(0) = g$，在 $x=1$ 处的 Dirichlet 边界条件为 $u(1) = u_{R}$。使用精确解 $u(x) = \\sin(\\pi x)$ 来一致地定义数据：设 $f(x) = (\\pi^2 + 1)\\sin(\\pi x)$，选择固定参数 $\\beta = 1$，则设 $g = u'(0) + \\beta\\,u(0) = \\pi$ 且 $u_{R} = u(1) = \\sin(\\pi) = 0$。采用有限差分法（FDM），内部格式使用由泰勒级数展开和二阶导数定义推导出的二阶中心差分。对于 $x=0$ 处的 Robin 边界，实现两种闭合方案：一种是一阶单边导数近似，另一种是通过泰勒级数展开推导的二阶单边导数近似。此外，还需考虑两端均为 Dirichlet 边界条件的情况。对于每种情况，构建离散线性系统并使用直接法求解网格函数。通过对一系列 $N$ 值加密网格间距 $h = 1/N$，计算经验收敛率，从而量化全局精度阶。使用定义在包含两个端点的网格上的误差无穷范数，该误差是数值解与精确函数 $u(x)$ 之间的差。目标是展示，即使内部格式为二阶，在单个边界处的一阶截断误差也会如何降低全局精度。\n\n需要使用的基本原理：二阶导数的定义、围绕某点的泰勒级数展开以推导有限差分近似，以及截断误差的定义，即连续算子作用于 $u(x)$ 与离散算子作用于其网格表示之间的差。经验收敛率应计算为对数尺度上误差与网格间距关系的斜率。\n\n实现一个单一程序，为以下四个测试用例构建并求解离散系统：\n- 情况 1（标准情况，混合边界，左侧一阶闭合）：$x=0$ 处为 Robin 条件，使用一阶单边导数近似；$x=1$ 处为 Dirichlet 条件；网格细化级别 $N \\in \\{16,32,64,128\\}$。\n- 情况 2（混合边界，左侧二阶闭合）：$x=0$ 处为 Robin 条件，使用二阶单边导数近似；$x=1$ 处为 Dirichlet 条件；网格细化级别 $N \\in \\{16,32,64,128\\}$。\n- 情况 3（两端均为 Dirichlet）：$x=0$ 和 $x=1$ 处均为 Dirichlet 条件；网格细化级别 $N \\in \\{16,32,64,128\\}$。\n- 情况 4（特殊情况，粗网格上混合边界，左侧一阶闭合）：$x=0$ 处为 Robin 条件，使用一阶单边导数近似；$x=1$ 处为 Dirichlet 条件；网格细化级别 $N \\in \\{4,8,16,32\\}$。\n\n对于每种情况，通过对序列中连续细化得到的成对收敛率进行平均，计算经验全局精度阶，结果为一个实数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述情况的顺序列出结果，每个数字四舍五入到三位小数（例如，$[p_1,p_2,p_3,p_4]$）。本问题不涉及物理单位；请报告纯数值。若有角度，应以弧度为单位，但本问题不直接涉及角度。测试用例的最终答案必须是您的程序计算出的实数。",
            "solution": "在尝试求解之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **微分方程：** $-u''(x) + u(x) = f(x)$，对于 $x \\in [0,1]$。\n- **精确解：** $u(x) = \\sin(\\pi x)$。\n- **强迫函数（源于精确解）：** $f(x) = (\\pi^2 + 1)\\sin(\\pi x)$。\n- **边界条件（混合）：**\n    - $x=0$ 处的 Robin 条件：$u'(0) + \\beta\\,u(0) = g$，其中 $\\beta=1$ 且 $g=\\pi$。\n    - $x=1$ 处的 Dirichlet 条件：$u(1) = u_{R}$，其中 $u_R=0$。\n- **数值方法：** 有限差分法（FDM），使用均匀网格，有 $N$ 个区间， $h=1/N$。\n    - 内部节点：二阶中心差分。\n    - $x=0$ 处的 Robin 边界：用于 $u'(0)$ 的一阶和二阶单边近似。\n- **误差分析：** 通过在一系列网格细化上使用误差的无穷范数 $\\| \\mathbf{U} - \\mathbf{u} \\|_{\\infty}$，从经验收敛率得到全局精度阶。\n- **测试用例：**\n    1.  混合边界条件（一阶 Robin 闭合），$N \\in \\{16,32,64,128\\}$。\n    2.  混合边界条件（二阶 Robin 闭合），$N \\in \\{16,32,64,128\\}$。\n    3.  两端均为 Dirichlet 边界条件，$N \\in \\{16,32,64,128\\}$。\n    4.  混合边界条件（一阶 Robin 闭合），$N \\in \\{4,8,16,32\\}$。\n- **输出：** 每个情况的平均经验收敛率，四舍五入到三位小数，以列表 `[p1, p2, p3, p4]` 的形式表示。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学或事实层面的不健全性：** 该问题在数学上是健全的。BVP、使用给定精确解以确保一致性、FDM 以及制造解方法都是数值分析中的标准且正确的概念。从 $u(x)=\\sin(\\pi x)$ 推导问题数据（$f(x)$, $g$, $u_R$）是正确的：\n    - $u'(x) = \\pi \\cos(\\pi x)$, $u''(x) = -\\pi^2 \\sin(\\pi x)$。\n    - $-u''(x) + u(x) = -(-\\pi^2 \\sin(\\pi x)) + \\sin(\\pi x) = (\\pi^2+1)\\sin(\\pi x) = f(x)$。\n    - $u'(0) + \\beta u(0) = \\pi \\cos(0) + (1)\\sin(0) = \\pi = g$。\n    - $u(1) = \\sin(\\pi) = 0 = u_R$。\n2.  **适定性：** 该问题是适定的。带有指定的 Dirichlet 和 Robin 边界条件的亥姆霍兹型方程保证了唯一、稳定解的存在。\n3.  **客观性：** 该问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n4.  **完备性：** 该问题是自包含的。数值实验所需的所有必要方程、参数和步骤都已明确说明。它正确地暗示了必须推导或已知标准的有限差分公式。\n5.  **核心概念演示：** 该问题设计精良，旨在演示微分方程数值方法的一个基本原理：全局精度阶受限于整个离散系统中最低阶的局部截断误差，而这通常发生在边界处。\n\n### 步骤 3：结论与操作\n该问题是**有效的**，因为它构成了一个适定、科学上健全且计算科学中的标准练习。详细解答如下。\n\n### 解答\n\n任务是使用有限差分法求解一个线性二阶边值问题，并针对不同的边界条件实现方式，分析其经验精度阶。\n\n**1. 域和方程的离散化**\n将域 $[0,1]$ 离散化为 $N$ 个宽度为 $h = 1/N$ 的均匀区间。网格点为 $x_i = ih$，其中 $i=0, 1, \\dots, N$。设 $U_i$ 是对精确解 $u(x_i)$ 的数值近似。\n\n控制常微分方程为 $-u''(x) + u(x) = f(x)$。在内部网格点 $x_i$（对于 $i=1, \\dots, N-1$），我们使用由泰勒级数展开推导出的二阶中心差分公式来近似二阶导数 $u''(x_i)$：\n$$ u''(x_i) = \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} + O(h^2) $$\n将此式代入常微分方程，并用 $U_i$ 替换 $u(x_i)$，得到内部节点的离散方程：\n$$ -\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} + U_i = f(x_i) $$\n整理后得到一个涉及三个相邻网格值的线性代数方程：\n$$ -U_{i-1} + (2 + h^2)U_i - U_{i+1} = h^2 f(x_i), \\quad \\text{for } i=1, \\dots, N-1 $$\n这 $N-1$ 个方程构成了我们线性系统的核心。系统的第一个和最后一个方程由边界条件确定。\n\n**2. 边界条件的离散化**\n\n**情况 1、2 和 4：混合边界条件**\n在 $x=1$ 处的边界条件是 Dirichlet 条件 $u(1)=0$，其精确实现为 $U_N = 0$。这固定了其中一个网格点的值。\n在 $x=0$ 处的边界条件是 Robin 条件 $u'(0) + \\beta u(0) = g$，其中 $\\beta=1$ 且 $g=\\pi$。我们必须近似导数 $u'(0)$。系统中的未知数是 $U_0, U_1, \\dots, U_{N-1}$，从而构成一个 $N \\times N$ 的线性系统。\n\n*   **情况 1 和 4（一阶闭合）：** 我们使用一阶向前差分来近似 $u'(0)$。泰勒展开式 $u(h) = u(0) + h u'(0) + O(h^2)$ 给出：\n    $$ u'(0) = \\frac{u(h) - u(0)}{h} + O(h) $$\n    离散的 Robin 条件变为：\n    $$ \\frac{U_1 - U_0}{h} + \\beta U_0 = g $$\n    当 $\\beta=1$ 时，该式简化为 $(h-1)U_0 + U_1 = hg$。这是线性系统的第一个方程（第 $0$ 行）。此近似的局部截断误差为 $O(h)$，预计这将主导全局误差，导致方法只有一阶精度。\n\n*   **情况 2（二阶闭合）：** 为保持内部格式的二阶精度，我们使用一个二阶单边近似来处理 $u'(0)$。这可以通过结合 $u(h)$ 和 $u(2h)$ 在 $x=0$ 附近的泰勒展开式，消去 $u''(0)$ 项并求解 $u'(0)$ 来推导：\n    $$ u'(0) = \\frac{-3u(0) + 4u(h) - u(2h)}{2h} + O(h^2) $$\n    离散的 Robin 条件为：\n    $$ \\frac{-3U_0 + 4U_1 - U_2}{2h} + \\beta U_0 = g $$\n    当 $\\beta=1$ 时，该式简化为 $(2h-3)U_0 + 4U_1 - U_2 = 2hg$。这是系统的第一个方程。由于所有离散化（内部和边界）的局部截断误差至少为 $O(h^2)$，预计全局误差将为 $O(h^2)$。\n\n**情况 3：Dirichlet-Dirichlet 边界条件**\n在这里，我们在两端都有 Dirichlet 条件：$u(0)=0$ 和 $u(1)=0$。这些条件被精确地实现为 $U_0 = 0$ 和 $U_N = 0$。未知数是内部点 $U_1, \\dots, U_{N-1}$。系统是 $(N-1) \\times (N-1)$ 的。对于第一个内部节点 $i=1$，方程为 $-U_0 + (2+h^2)U_1 - U_2 = h^2f(x_1)$。由于 $U_0=0$，方程变为 $(2+h^2)U_1 - U_2 = h^2f(x_1)$。类似地，对于最后一个内部节点 $i=N-1$，已知 $U_N=0$，可得 $-U_{N-2} + (2+h^2)U_{N-1} = h^2f(x_{N-1})$。得到的矩阵是一个对称、正定、三对角矩阵。该格式是一致二阶的，因此预计全局精度为 $O(h^2)$。\n\n**3. 系统组装与求解**\n对于每种情况，我们组装系统 $A\\mathbf{U} = \\mathbf{b}$ 的矩阵 $A$ 和右侧向量 $\\mathbf{b}$。\n-   **对于情况 1、2、4：** $A$ 是一个 $N \\times N$ 矩阵，$\\mathbf{U}=[U_0, \\dots, U_{N-1}]^T$。最终解向量通过附加 $U_N=0$ 形成。\n-   **对于情况 3：** $A$ 是一个 $(N-1) \\times (N-1)$ 矩阵，$\\mathbf{U}=[U_1, \\dots, U_{N-1}]^T$。最终解向量通过前置 $U_0=0$ 和附加 $U_N=0$ 形成。\n\n该系统使用直接线性求解器求解。\n\n**4. 经验收敛率**\n全局误差在无穷范数下度量：$E_N = \\max_{0 \\le i \\le N} |U_i - u(x_i)|$。如果方法的精度阶为 $p$，那么对于某个常数 $C$ 和小的 $h$，有 $E_N \\approx C h^p$。\n给定具有 $N_1$ 和 $N_2$ 个区间的网格的误差 $E_{N_1}$ 和 $E_{N_2}$，其中 $N_2 = 2N_1$，收敛率 $p$ 可以估计为：\n$$ p \\approx \\log_2\\left(\\frac{E_{N_1}}{E_{N_2}}\\right) $$\n问题要求计算在给定 $N$ 序列的连续细化中得到的这些成对收敛率的平均值。\n\n分析将表明，尽管内部格式为二阶，情况 1 和 4 中边界上的一阶近似将全局收敛率降低到 $p \\approx 1$。而情况 2 和 3 完全使用二阶近似，将表现出 $p \\approx 2$ 的收敛率。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve_bvp(N, case_type):\n    \"\"\"\n    Constructs and solves the finite difference system for the BVP.\n\n    Args:\n        N (int): The number of intervals in the grid.\n        case_type (str): The type of case to solve. One of \n                         'mixed_1st', 'mixed_2nd', 'dirichlet'.\n\n    Returns:\n        float: The infinity norm of the error between the numerical\n               and exact solutions.\n    \"\"\"\n    h = 1.0 / N\n    x_full = np.linspace(0, 1, N + 1)\n\n    # Problem data from the exact solution u(x) = sin(pi*x)\n    pi = np.pi\n    beta = 1.0\n    g = pi\n    u_R = 0.0\n\n    def f(x):\n        return (pi**2 + 1) * np.sin(pi * x)\n\n    exact_solution = np.sin(pi * x_full)\n\n    if case_type == 'dirichlet':\n        num_unknowns = N - 1\n        if num_unknowns == 0:\n            return np.max(np.abs(np.array([0.0, 0.0]) - np.sin(pi * np.array([0.0, 1.0]))))\n\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        # Grid for interior points\n        x_interior = x_full[1:-1]\n        \n        # Fill matrix A\n        # Diagonal\n        np.fill_diagonal(A, 2 + h**2)\n        # Off-diagonals\n        np.fill_diagonal(A[1:], -1)\n        np.fill_diagonal(A[:, 1:], -1)\n\n        # Fill vector b\n        b = h**2 * f(x_interior)\n        \n        # Dirichlet conditions are handled by adjusting the RHS,\n        # but here u(0)=0 and u(1)=0, so no adjustments needed.\n        # U_0 = 0, U_N = 0.\n\n        # Solve system\n        U_interior = np.linalg.solve(A, b)\n        U_full = np.concatenate(([0.0], U_interior, [u_R]))\n\n    elif case_type in ('mixed_1st', 'mixed_2nd'):\n        num_unknowns = N\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        # Interior equations (rows 1 to N-1)\n        for i in range(1, num_unknowns):\n            x_i = x_full[i]\n            if i > 0:\n                A[i, i-1] = -1\n            A[i, i] = 2 + h**2\n            if i < num_unknowns - 1:\n                A[i, i+1] = -1\n            b[i] = h**2 * f(x_i)\n        \n        # Handle U_N = u_R = 0 in the last equation (row N-1)\n        # The term -U_N is 0, so no change to b[N-1] needed.\n\n        # Boundary equation at x=0 (row 0)\n        if case_type == 'mixed_1st':\n            A[0, 0] = h * beta - 1\n            A[0, 1] = 1\n            b[0] = h * g\n        elif case_type == 'mixed_2nd':\n            A[0, 0] = 2 * h * beta - 3\n            A[0, 1] = 4\n            A[0, 2] = -1\n            b[0] = 2 * h * g\n        \n        # Solve system\n        U_unknowns = np.linalg.solve(A, b)\n        U_full = np.concatenate((U_unknowns, [u_R]))\n    \n    else:\n        raise ValueError(\"Invalid case type\")\n        \n    error = np.max(np.abs(U_full - exact_solution))\n    return error\n\ndef compute_avg_rate(case_type, N_list):\n    \"\"\"\n    Computes the average empirical convergence rate for a given case.\n\n    Args:\n        case_type (str): The type of case.\n        N_list (list of int): A sequence of refinement levels N.\n\n    Returns:\n        float: The average convergence rate.\n    \"\"\"\n    errors = [solve_bvp(N, case_type) for N in N_list]\n    rates = []\n    for i in range(len(N_list) - 1):\n        # Assuming N_list[i+1] is a refinement of N_list[i], typically N*2\n        ratio_h = N_list[i] / N_list[i+1]\n        rate = math.log(errors[i] / errors[i+1]) / math.log(1/ratio_h)\n        rates.append(rate)\n    return np.mean(rates)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define test cases\n    case1_N = [16, 32, 64, 128]\n    case2_N = [16, 32, 64, 128]\n    case3_N = [16, 32, 64, 128]\n    case4_N = [4, 8, 16, 32]\n    \n    # Compute rates\n    p1 = compute_avg_rate('mixed_1st', case1_N)\n    p2 = compute_avg_rate('mixed_2nd', case2_N)\n    p3 = compute_avg_rate('dirichlet', case3_N)\n    p4 = compute_avg_rate('mixed_1st', case4_N)\n    \n    results = [p1, p2, p3, p4]\n    \n    # Format and print output\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "有限差分法的精度分析通常依赖于解的足够光滑性这一假设。本练习将带你探究当这个理想条件不被满足时会发生什么。你将通过编程解决一个源函数 $f(x)$ 存在跳跃间断的边界值问题，其精确解的平滑度因此降低。通过这个实践，你将量化并理解为何标准二阶差分格式的收敛阶会从理论上的 $O(h^2)$ 在实际计算中退化，这对于在应用中正确评估数值方法的表现至关重要 。",
            "id": "3127793",
            "problem": "考虑闭区间 $[0,1]$ 上标量函数 $u(x)$ 的一维边值问题 (BVP)，其具有齐次 Dirichlet 边界条件，\n$$\n-u''(x) = f(x), \\quad x \\in (0,1), \\quad u(0) = 0, \\quad u(1) = 0.\n$$\n仅从光滑函数在某点周围的 Taylor 展开和二阶导数的定义出发，您必须：\n- 推导在具有 $N$ 个内部点和网格间距 $h = \\frac{1}{N+1}$ 的均匀网格上的经典二阶中心有限差分 (FD) 格式，使用三点模板来近似 $u''(x)$。不要在间断点附近引入任何特殊处理；在每个内部网格点上应用相同的模板。\n- 实现所得到的线性系统，该系统在给定的 Dirichlet 边界条件下近似 $-u''(x) = f(x)$。\n- 通过以下公式计算在内部网格节点 $\\{x_i = i h\\}_{i=1}^{N}$ 上定义的离散 $\\ell_{\\infty}$ 误差：\n$$\n\\|e\\|_{\\infty} = \\max_{1 \\le i \\le N} \\left|u_{\\text{num}}(x_i) - u_{\\text{exact}}(x_i)\\right|,\n$$\n其中 $u_{\\text{num}}$ 是数值解，$u_{\\text{exact}}$ 是在相同网格节点上求值的连续 BVP 的精确解。\n- 对于由网格间距 $h_1 > h_2 > \\cdots$ 表征的一系列网格加密，通过以下公式计算两次连续加密之间的观测收敛阶：\n$$\np = \\frac{\\log\\left(\\|e(h_1)\\|_{\\infty} / \\|e(h_2)\\|_{\\infty}\\right)}{\\log\\left(h_1/h_2\\right)}.\n$$\n目标是证明当连续解仅为 $C^1$ (一阶连续可微) 而非 $C^2$ 时，标准二阶中心有限差分法的观测收敛阶会从大约 $2$ 降低到大约 $1$。\n\n使用三个测试用例，它们共享相同的算子，但右端项 $f(x)$ 不同，这样选择是为了控制精确解的正则性：\n\n- 用例 A (光滑的“理想情况”)：$f(x) = \\sin(2\\pi x)$。精确解为 $u(x) = \\dfrac{\\sin(2\\pi x)}{(2\\pi)^2}$，满足 $u(0) = 0$ 和 $u(1) = 0$。使用 $N \\in \\{32, 64, 128, 256\\}$。\n\n- 用例 B (与网格节点对齐的阶梯右端项)：令 $s = \\tfrac{1}{2}$，$f_{\\text{L}} = 1$ 和 $f_{\\text{R}} = 2$。定义\n$$\nf(x) = \n\\begin{cases}\nf_{\\text{L}},  0 \\le x  s,\\\\\nf_{\\text{R}},  s \\le x \\le 1.\n\\end{cases}\n$$\n则精确解 $u(x)$ 是分段二次的，$C^1$ 但非 $C^2$，并通过在 $x = s$ 处强制 $u(0) = 0$，$u(1) = 0$ 以及 $u$ 和 $u'$ 的连续性来确定。具体来说，对于 $0 \\le x  s$，\n$$\nu(x) = -\\frac{f_{\\text{L}}}{2} x^2 + A x,\n$$\n而对于 $s \\le x \\le 1$，\n$$\nu(x) = -\\frac{f_{\\text{R}}}{2} x^2 + C x + D,\n$$\n其中常数 $A, C, D$ 由界面和边界条件确定。使用 $N \\in \\{31, 63, 127, 255\\}$，以使 $s = \\tfrac{1}{2}$ 恰好落在一个网格节点 $x_i = i h$ 上。\n\n- 用例 C (不在网格上的阶梯右端项)：令 $s = \\tfrac{3}{10}$，$f_{\\text{L}} = 1$，$f_{\\text{R}} = 2$，且 $f(x)$ 的定义如用例 B 所示。精确解同样是分段二次的，$C^1$ 但非 $C^2$，其形式和常数确定方法与用例 B 相同，但现在的界面位置不同，$s = \\tfrac{3}{10}$。使用 $N \\in \\{32, 64, 128, 256\\}$。\n\n对于用例 B 和 C，您的实现必须基于由下式所蕴含的分段精确解：\n$$\n-u''(x) =\n\\begin{cases}\nf_{\\text{L}},  0 \\le x  s,\\\\\nf_{\\text{R}},  s \\le x \\le 1,\n\\end{cases}\n$$\n以及界面条件（$u$ 在 $x=s$ 处连续，$u'$ 在 $x=s$ 处连续）和边界条件 $u(0) = 0$，$u(1) = 0$。这些条件唯一地确定了分段二次精确解中的常数。\n\n您的程序必须：\n- 对于每个测试用例，为指定集合中的每个 $N$ 计算离散 $\\ell_{\\infty}$ 误差，然后仅使用该用例中最密的两次加密来计算观测阶 $p$。\n- 生成单行输出，包含一个含有三个浮点数的列表 $[p_{\\text{A}}, p_{\\text{B}}, p_{\\text{C}}]$，其中 $p_{\\text{A}}$ 对应于用例 A，$p_{\\text{B}}$ 对应于用例 B，$p_{\\text{C}}$ 对应于用例 C。每个数字表示为四舍五入到两位小数。\n\n本问题不涉及物理单位。三角函数中出现的所有角度，均应理解为以弧度为单位。\n\n最终输出格式：\n- 单行输出，包含由方括号括起来的三个以逗号分隔的结果，例如 $[1.98,1.03,1.01]$。",
            "solution": "所提出的问题是一个适定的一维边值问题 (BVP)，需要使用有限差分法求其数值解。任务是推导数值格式，针对解具有不同正则性的三种不同情况进行实现，并分析计算收敛阶，以展示解光滑性降低带来的影响。该问题在科学上是合理的、自洽的，并且在数学上是严谨的。\n\n### 1. 中心有限差分格式的推导\n\n有限差分法的基础是使用 Taylor 级数展开来近似导数。考虑一个足够光滑的标量函数 $u(x)$。其在点 $x_i$ 周围的 Taylor 展开式为：\n$$\nu(x_i + h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + O(h^5)\n$$\n$$\nu(x_i - h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + O(h^5)\n$$\n其中 $h$ 是一个小的步长。\n\n将这两个展开式相加，奇数次幂的导数项（$u'$, $u'''$ 等）会相互抵消：\n$$\nu(x_i + h) + u(x_i - h) = 2u(x_i) + h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)\n$$\n重新整理该方程以求解二阶导数 $u''(x_i)$，可得：\n$$\nh^2 u''(x_i) = u(x_i + h) - 2u(x_i) + u(x_i - h) - \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)\n$$\n两边同除以 $h^2$，我们得到 $u''(x_i)$ 的表达式：\n$$\nu''(x_i) = \\frac{u(x_i + h) - 2u(x_i) + u(x_i - h)}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + O(h^4)\n$$\n表达式 $\\frac{u(x_i + h) - 2u(x_i) + u(x_i - h)}{h^2}$ 是二阶导数的经典三点中心有限差分近似。项 $-\\frac{h^2}{12} u^{(4)}(\\xi)$（对于某个 $\\xi \\in (x_i-h, x_i+h)$）是局部截断误差的主项。因此，只要解 $u(x)$ 至少是四阶连续可微的（$u \\in C^4$），该近似就是二阶精确的，记为 $O(h^2)$。\n\n### 2. 边值问题的离散化\n\n待求解的 BVP 是 $-u''(x) = f(x)$，定义在 $x \\in (0,1)$ 上，且满足 $u(0)=0$ 和 $u(1)=0$。我们引入一个具有 $N$ 个内部点的均匀网格。网格间距为 $h = \\frac{1}{N+1}$，网格点为 $x_i = i h$，其中 $i=0, 1, \\dots, N+1$。在这些点上的数值解记为 $u_i \\approx u(x_i)$。\n\n我们在每个内部网格点 $x_i$（$i=1, \\dots, N$）处，用其有限差分近似替换 BVP 中的连续二阶导数：\n$$\n- \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} = f(x_i)\n$$\n两边同乘以 $h^2$ 并重新整理，得到每个内部节点的离散方程：\n$$\n-u_{i-1} + 2u_i - u_{i+1} = h^2 f_i, \\quad \\text{对于 } i = 1, 2, \\dots, N,\n$$\n其中 $f_i = f(x_i)$。\n\n这组 $N$ 个线性方程必须包含齐次 Dirichlet 边界条件，$u(0)=0$ 和 $u(1)=0$。在我们的离散表示法中，这意味着 $u_0 = 0$ 和 $u_{N+1} = 0$。\n\n对于第一个内部点 ($i=1$)：\n$$\n-u_0 + 2u_1 - u_2 = h^2 f_1 \\implies 2u_1 - u_2 = h^2 f_1\n$$\n对于最后一个内部点 ($i=N$)：\n$$\n-u_{N-1} + 2u_N - u_{N+1} = h^2 f_N \\implies -u_{N-1} + 2u_N = h^2 f_N\n$$\n这些方程构成一个线性系统 $A\\mathbf{u}_{\\text{num}} = \\mathbf{b}$，其中 $\\mathbf{u}_{\\text{num}} = [u_1, u_2, \\dots, u_N]^T$ 是内部点上未知解值的向量。矩阵 $A$ 是一个 $N \\times N$ 的对称、三对角、正定矩阵：\n$$\nA = \\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots  \\cdots  -1  2  -1 \\\\\n0  \\cdots  0  -1  2\n\\end{pmatrix}\n$$\n右端项向量 $\\mathbf{b}$ 由下式给出：\n$$\n\\mathbf{b} = h^2 \\begin{pmatrix} f(x_1) \\\\ f(x_2) \\\\ \\vdots \\\\ f(x_N) \\end{pmatrix}\n$$\n求解这个线性系统即可得到数值解 $\\mathbf{u}_{\\text{num}}$。\n\n### 3. 收敛性分析与解的正则性\n\n该方法的全局误差 $\\|u_{\\text{num}} - u_{\\text{exact}}\\|_\\infty$ 预计为 $O(h^2)$，这意味着观测到的收敛阶 $p$ 应约为 $2$。这在解 $u(x)$ 足够光滑（具体来说，$u \\in C^4[0,1]$）时成立。\n\n本问题研究了这种光滑性条件被破坏的情景。如果解 $u(x)$ 仅为 $C^1$，那么其二阶导数 $u''(x)$ 连续但不可微，其三阶导数 $u'''(x)$ 具有跳跃间断点。当源项 $f(x)$ 是分段连续的（例如，阶梯函数）时，就会发生这种情况。在 $f(x)$ 不连续的点上或其附近，用于证明 $O(h^2)$ 截断误差的 Taylor 级数论证会失效。如果在间断点上计算，局部截断误差会变为 $O(1)$ 或 $O(h^{-1})$；如果模板跨越了该点，则误差为 $O(h)$。这个较大的局部误差会污染全局解，通常导致整体收敛率降低到 $p \\approx 1$。\n\n设计的三个测试用例旨在展示这一现象：\n- **用例 A**：$f(x)$ 是 $C^\\infty$ 的，因此精确解 $u(x)$ 也是 $C^\\infty$ 的。我们预计观测到 $p \\approx 2$。\n- **用例 B**：$f(x)$ 在 $x=1/2$ 处有一个阶跃间断点。选择的网格使得这个间断点始终与一个网格点对齐。有限差分模板被朴素地应用于该点上。\n- **用例 C**：$f(x)$ 在 $x=3/10$ 处有一个阶跃间断点。网格的设置使得间断点位于网格点之间。\n\n对于用例 B 和 C，精确解是分段二次且 $C^1$ 的。分段解中的常数通过强制执行边界条件 $u(0)=u(1)=0$ 以及在界面点 $s$ 处 $u$ 和 $u'$ 的连续性来找到。这得到了一般形式：\n对于 $x  s$：$u(x) = -\\frac{f_{\\text{L}}}{2}x^2 + C_1 x$\n对于 $x \\ge s$：$u(x) = -\\left(f_{\\text{L}}sx - \\frac{f_{\\text{L}}}{2}s^2 + \\frac{f_{\\text{R}}}{2}(x-s)^2\\right) + C_1 x$\n其中 $C_1 = f_{\\text{L}}s - \\frac{f_{\\text{L}}}{2}s^2 + \\frac{f_{\\text{R}}}{2}(1-s)^2$。\n\n数值实验将计算一系列网格加密下的离散 $\\ell_\\infty$ 误差，然后使用最密的两个网格的结果计算观测收敛阶 $p$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve_bvp(N, f_func):\n    \"\"\"\n    Solves the BVP -u'' = f(x) on [0,1] with u(0)=u(1)=0\n    using a central finite difference scheme with N interior points.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n    \n    # Construct the right-hand side vector b\n    b = h**2 * f_func(x)\n    \n    # Construct the tridiagonal matrix A in banded format for solve_banded.\n    # The matrix ab has 3 rows.\n    # ab[0, :] = super-diagonal (not used at index 0)\n    # ab[1, :] = main diagonal\n    # ab[2, :] = sub-diagonal (not used at last index)\n    ab = np.zeros((3, N))\n    ab[0, 1:] = -1.0\n    ab[1, :] = 2.0\n    ab[2, :-1] = -1.0\n    \n    # Solve the linear system Au = b\n    u_num = linalg.solve_banded((1, 1), ab, b)\n    \n    return x, u_num\n\ndef calculate_order(errors, h_values):\n    \"\"\"\n    Calculates the order of convergence p from the last two refinements.\n    \"\"\"\n    # Use data from the two finest grids\n    e1 = errors[-2]  # Error on coarser grid\n    e2 = errors[-1]  # Error on finer grid\n    h1 = h_values[-2]  # Coarser grid spacing\n    h2 = h_values[-1]  # Finer grid spacing\n\n    p = np.log(e1 / e2) / np.log(h1 / h2)\n    return p\n\ndef run_case(f_func, u_exact_func, N_values):\n    \"\"\"\n    Runs a test case for a given f, u_exact, and list of N values.\n    Returns the observed order of convergence.\n    \"\"\"\n    errors = []\n    h_values = []\n    \n    for N in N_values:\n        h = 1.0 / (N + 1)\n        x_grid, u_num = solve_bvp(N, f_func)\n        u_exact = u_exact_func(x_grid)\n        \n        # Calculate discrete l-infinity error\n        l_inf_error = np.max(np.abs(u_num - u_exact))\n        \n        errors.append(l_inf_error)\n        h_values.append(h)\n        \n    # Compute order of convergence from the two finest grids\n    order = calculate_order(errors, h_values)\n    return order\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print the final results.\n    \"\"\"\n    # --- Case A: Smooth solution ---\n    f_A = lambda x: np.sin(2 * np.pi * x)\n    u_exact_A = lambda x: np.sin(2 * np.pi * x) / (2 * np.pi)**2\n    N_A = [32, 64, 128, 256]\n\n    # --- Case B: C^1 solution, discontinuity on grid node ---\n    s_B, fL_B, fR_B = 0.5, 1.0, 2.0\n    f_B = lambda x: np.where(x  s_B, fL_B, fR_B)\n    C1_B = fL_B * s_B - fL_B / 2 * s_B**2 + fR_B / 2 * (1 - s_B)**2\n    u_exact_B = lambda x: np.where(\n        x  s_B,\n        -0.5 * fL_B * x**2 + C1_B * x,\n        -(fL_B * s_B * x - 0.5 * fL_B * s_B**2 + 0.5 * fR_B * (x - s_B)**2) + C1_B * x\n    )\n    N_B = [31, 63, 127, 255]\n\n    # --- Case C: C^1 solution, discontinuity off-grid ---\n    s_C, fL_C, fR_C = 0.3, 1.0, 2.0\n    f_C = lambda x: np.where(x  s_C, fL_C, fR_C)\n    C1_C = fL_C * s_C - fL_C / 2 * s_C**2 + fR_C / 2 * (1 - s_C)**2\n    u_exact_C = lambda x: np.where(\n        x  s_C,\n        -0.5 * fL_C * x**2 + C1_C * x,\n        -(fL_C * s_C * x - 0.5 * fL_C * s_C**2 + 0.5 * fR_C * (x - s_C)**2) + C1_C * x\n    )\n    N_C = [32, 64, 128, 256]\n\n    test_cases = [\n        (f_A, u_exact_A, N_A),\n        (f_B, u_exact_B, N_B),\n        (f_C, u_exact_C, N_C),\n    ]\n\n    results = []\n    for f_func, u_exact_func, N_values in test_cases:\n        p = run_case(f_func, u_exact_func, N_values)\n        results.append(p)\n    \n    # Format the final output string with results rounded to two decimal places.\n    formatted_results = [f\"{r:.2f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的物理和工程问题往往本质上是非线性的，这超出了我们此前学习的线性方程求解范畴。本练习将你的技能提升到一个新水平，你将学习如何运用有限差分法求解非线性边界值问题。你将实现牛顿法这一强大的迭代算法来处理非线性项，并结合简单的参数延拓策略，追踪解在一个参数 $\\lambda$ 变化时形成的“解分支” 。",
            "id": "3127756",
            "problem": "考虑在区间 $[0,1]$ 上的非线性边值问题 (BVP)，其具有齐次 Dirichlet 边界条件：寻找一个函数 $u:[0,1]\\to\\mathbb{R}$，使得 $$-u''(x)+\\lambda\\,u(x)^3=f(x),\\quad x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=0,$$ 其中 $f(x)$ 是一个给定的源函数，$\\lambda\\in\\mathbb{R}$ 是一个延拓参数。目标是使用有限差分法 (FDM) 来近似解 $u(x)$，并使用离散牛顿延拓法在 $\\lambda$ 变化时追踪解分支。\n\n从基本原理开始：\n- 通过导数的定义推导出的标准中心差分来近似二阶导数，$$u''(x_i)\\approx\\frac{u(x_{i-1})-2u(x_i)+u(x_{i+1})}{h^2},$$ 其中 $x_i$ 是网格点，$h$ 是均匀的网格间距。\n- 通过在内部网格点上强制执行微分方程来构建离散非线性系统。\n- 使用牛顿法，该方法源于非线性方程 $F(y)=0$ 的求根原理，它在每次迭代时通过雅可比矩阵将系统线性化，并求解牛顿更新量。\n\n需要实现的离散化细节：\n- 使用一个包含 $N$ 个内部点的均匀网格，网格间距为 $h=\\frac{1}{N+1}$，内部节点为 $x_i=i\\,h$，其中 $i=1,2,\\dots,N$。\n- 令 $u_i\\approx u(x_i)$，并按分量定义离散残差向量 $F(u;\\lambda)\\in\\mathbb{R}^N$：$$F_i(u;\\lambda)=\\frac{2u_i-u_{i-1}-u_{i+1}}{h^2}+\\lambda\\,u_i^3-f(x_i),\\quad i=1,\\dots,N,$$ 根据边界条件，约定 $u_0=0$ 和 $u_{N+1}=0$。\n- 对于牛顿法，使用雅可比矩阵 $$J(u;\\lambda)=L+\\operatorname{diag}\\big(3\\lambda\\,u_1^2,\\dots,3\\lambda\\,u_N^2\\big),$$ 其中 $L\\in\\mathbb{R}^{N\\times N}$ 是表示内部节点上离散算子 $-\\frac{d^2}{dx^2}$ 的三对角矩阵，即 $L$ 的对角线元素为 $\\frac{2}{h^2}$，次对角线元素为 $-\\frac{1}{h^2}$。\n\n需要实现的延拓策略：\n- 在 $\\lambda=0$ 时，精确求解线性系统 $L\\,u=f$ 以获得初始解。\n- 对于指定序列中的后续 $\\lambda$ 值，使用先前收敛的解作为牛顿法的初始猜测，并使用合适的停止准则进行迭代直至收敛。\n\n源函数规格：\n- 使用强制函数 $f(x)=\\sin(\\pi x)$，该函数是光滑的且与边界条件兼容。\n\n需要实现的收敛和数值细节：\n- 对于牛顿法的收敛，使用残差欧几里得范数的容差为 $10^{-10}$。\n- 将牛顿迭代次数限制为 $50$ 次。\n- 对牛顿步长采用简单的回溯线搜索以增强鲁棒性：如果一个完整的牛顿步长没有充分减小残差范数，则几何级数地减小步长，直到观察到足够的减小或达到最小步长阈值。\n\n确保覆盖率的测试套件：\n- 情况 1 (happy path): $N=50$, $\\lambda$ 序列 $[0.0,\\,0.5,\\,1.0]$。\n- 情况 2 (粗网格，更强非线性): $N=10$, $\\lambda$ 序列 $[0.0,\\,2.0]$。\n- 情况 3 (细网格，中等非线性): $N=150$, $\\lambda$ 序列 $[0.0,\\,1.5]$。\n- 情况 4 (负参数分支): $N=50$, $\\lambda$ 序列 $[0.0,\\,-1.0]$。\n\n要求的最终输出：\n- 对于每种情况，沿指定的 $\\lambda$ 序列执行离散牛顿延拓。在每个 $\\lambda$ 值处，牛顿法收敛后，计算解的离散 $\\ell_\\infty$ 范数，即 $\\max_i |u_i|$。\n- 按照上面列出的顺序以及每个情况中 $\\lambda$ 序列的顺序汇总所有情况的结果。\n- 将每个报告的 $\\ell_\\infty$ 范数四舍五入到 $6$ 位小数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），其中每个 $r_k$ 是一个四舍五入到 $6$ 位小数的浮点数。不应打印任何额外文本。",
            "solution": "该问题要求使用有限差分法 (FDM) 对非线性边值问题 (BVP) 进行数值求解。得到的非线性代数方程组将使用牛顿法求解。为了处理问题的参数依赖性，采用了一种简单的延拓法，即从 $\\lambda=0$ 处的已知解开始，追踪一系列参数值 $\\lambda$ 的解。\n\nBVP 由以下公式给出：\n$$\n-u''(x) + \\lambda u(x)^3 = f(x), \\quad x \\in (0, 1)\n$$\n具有齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$。源函数指定为 $f(x) = \\sin(\\pi x)$。\n\n**1. 有限差分法离散化**\n\n我们首先对域 $[0,1]$ 进行离散化。我们引入一个具有 $N$ 个内部点的均匀网格，由节点 $x_i = i h$ 定义，其中 $i=0, 1, \\dots, N+1$，$h = \\frac{1}{N+1}$ 是网格间距。边界点是 $x_0=0$ 和 $x_{N+1}=1$。我们寻求在内部网格点 $x_i$ ($i=1, \\dots, N$) 处的近似解 $u_i \\approx u(x_i)$。未知向量是 $u = [u_1, u_2, \\dots, u_N]^T \\in \\mathbb{R}^N$。\n\n在每个内部节点 $x_i$ 处，使用二阶中心差分公式来近似二阶导数 $u''(x)$：\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n将此式代入微分方程，并在每个内部节点 $x_i$ 处进行计算，得到一个包含 $N$ 个代数方程的系统：\n$$\n-\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} + \\lambda u_i^3 = f(x_i), \\quad i=1, \\dots, N\n$$\n通过设置 $u_0=0$ 和 $u_{N+1}=0$ 来引入边界条件 $u(0)=0$ 和 $u(1)=0$。该方程组可以重写为：\n$$\n\\frac{2u_i - u_{i-1} - u_{i+1}}{h^2} + \\lambda u_i^3 = f_i, \\quad i=1, \\dots, N\n$$\n其中 $f_i = f(x_i) = \\sin(\\pi x_i)$。必须求解该系统以得到未知向量 $u$。\n\n我们定义一个残差函数 $F: \\mathbb{R}^N \\to \\mathbb{R}^N$，我们寻求根 $u$ 使得 $F(u; \\lambda) = 0$。残差的第 $i$ 个分量是：\n$$\nF_i(u; \\lambda) = \\frac{2u_i - u_{i-1} - u_{i+1}}{h^2} + \\lambda u_i^3 - f_i\n$$\n该系统可以用紧凑的矩阵-向量形式表示：\n$$\nF(u; \\lambda) = L u + \\lambda u^{\\circ 3} - f = 0\n$$\n在这里，$u^{\\circ 3}$ 表示向量 $u$ 的逐元素立方，即 $(u^{\\circ 3})_i = u_i^3$。向量 $f \\in \\mathbb{R}^N$ 的分量为 $f_i = f(x_i)$。矩阵 $L \\in \\mathbb{R}^{N \\times N}$ 是带有齐次 Dirichlet 边界条件的负二阶导数算子 $-\\frac{d^2}{dx^2}$ 的离散表示。它是一个对称的三对角矩阵，其元素为：\n$$\nL_{ij} = \\begin{cases}\n2/h^2  \\text{if } i=j \\\\\n-1/h^2  \\text{if } |i-j|=1 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n\n**2. 牛顿法**\n\n为求解非线性系统 $F(u;\\lambda)=0$，我们采用牛顿法。从一个初始猜测 $u^{(0)}$ 开始，我们生成一系列迭代 $u^{(k)}$，并希望它们收敛到解。从 $u^{(k)}$ 到 $u^{(k+1)}$ 的更新由以下公式给出：\n$$\nu^{(k+1)} = u^{(k)} + \\Delta u^{(k)}\n$$\n其中牛顿步长 $\\Delta u^{(k)}$ 是线性系统的解：\n$$\nJ(u^{(k)}; \\lambda) \\Delta u^{(k)} = -F(u^{(k)}; \\lambda)\n$$\n$J(u^{(k)}; \\lambda)$ 是 $F$ 相对于 $u$ 的雅可比矩阵，在 $u^{(k)}$ 处求值。雅可比矩阵的元素是 $J_{ij}(u; \\lambda) = \\frac{\\partial F_i}{\\partial u_j}$。\n$$\n\\frac{\\partial F_i}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left( \\frac{2u_i - u_{i-1} - u_{i+1}}{h^2} + \\lambda u_i^3 - f_i \\right) =\n\\begin{cases}\n2/h^2 + 3\\lambda u_i^2  \\text{if } i=j \\\\\n-1/h^2  \\text{if } |i-j|=1 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n因此，雅可比矩阵是常数矩阵 $L$ 和一个依赖于 $u$ 的对角矩阵之和：\n$$\nJ(u; \\lambda) = L + \\operatorname{diag}(3\\lambda u_1^2, 3\\lambda u_2^2, \\dots, 3\\lambda u_N^2)\n$$\n当残差向量的欧几里得范数低于指定的容差 $\\|F(u^{(k)}; \\lambda)\\|_2  10^{-10}$ 时，或者达到最大迭代次数（50次）时，牛顿迭代终止。\n\n**3. 延拓法与线搜索**\n\n我们使用一个简单的参数延拓法来寻找一系列 $\\lambda$ 值的解。\n- **初始步骤 ($\\lambda=0$)：** 对于 $\\lambda_0 = 0$，BVP 变为线性：$-u''(x)=f(x)$。离散系统为 $L u = f$。该系统有唯一解，可通过直接线性求解得到。\n- **延拓步骤：** 对于序列中的每个后续参数值 $\\lambda_k$，我们使用先前计算的解 $u(\\lambda_{k-1})$ 作为牛顿法的初始猜测 $u^{(0)}$ 来寻找 $u(\\lambda_k)$。\n\n为了提高牛顿法的鲁棒性，特别是当初始猜测远离解时，我们引入了回溯线搜索。一个完整的牛顿步长 $\\Delta u^{(k)}$ 可能不会减小残差范数。因此，更新被修改为 $u^{(k+1)} = u^{(k)} + \\alpha \\Delta u^{(k)}$，其中 $\\alpha \\in (0, 1]$ 是一个步长参数。我们从 $\\alpha=1$ 开始，如果条件 $\\|F(u^{(k)} + \\alpha \\Delta u^{(k)})\\|_2 \\ge \\|F(u^{(k)})\\|_2$ 成立，我们通过一个固定因子（例如 $\\alpha \\leftarrow \\alpha/2$）减小 $\\alpha$ 并重新检查。重复此过程，直到残差范数有足够的减小或达到最小步长。\n\n**4. 算法摘要**\n\n对于由 $(N, \\{\\lambda_k\\})$ 指定的每个测试用例：\n1.  设置网格间距 $h = 1/(N+1)$。创建网格点 $x_i = i h$，其中 $i=1,\\dots,N$。\n2.  构建源向量 $f$，其分量为 $f_i = \\sin(\\pi x_i)$。\n3.  构建常数三对角矩阵 $L$。\n4.  处理 $\\lambda_0=0$：求解线性系统 $Lu = f$ 以获得初始解 $u_{sol}$。计算并存储其离散 $\\ell_\\infty$-范数，$\\max_i |(u_{sol})_i|$。\n5.  遍历剩余的 $\\lambda_k$ 值：\n    a. 使用上一步的 $u_{sol}$ 作为牛顿法的初始猜测 $u_{current}$。\n    b. 开始牛顿循环（对于 $j=0, 1, \\dots, 49$）：\n        i.   计算残差向量 $F_{current} = L u_{current} + \\lambda_k u_{current}^{\\circ 3} - f$。\n        ii.  如果 $\\|F_{current}\\|_2  10^{-10}$，则方法已收敛。跳出循环。\n        iii. 计算雅可比矩阵 $J_{current} = L + \\operatorname{diag}(3\\lambda_k u_{current}^{\\circ 2})$。\n        iv.  求解线性系统 $J_{current} \\Delta u = -F_{current}$ 以获得牛顿步长 $\\Delta u$。\n        v.   执行回溯线搜索以找到合适的步长 $\\alpha$。\n        vi.  更新解：$u_{current} \\leftarrow u_{current} + \\alpha \\Delta u$。\n    c. 收敛的解是最终的 $u_{current}$。设置 $u_{sol} = u_{current}$。\n    d. 计算并存储 $u_{sol}$ 的 $\\ell_\\infty$-范数。\n6.  收集所有计算出的范数，将它们四舍五入到 $6$ 位小数，并为最终输出进行格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear BVP using FDM and Newton continuation for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (50, [0.0, 0.5, 1.0]),\n        (10, [0.0, 2.0]),\n        (150, [0.0, 1.5]),\n        (50, [0.0, -1.0])\n    ]\n\n    all_results = []\n    \n    for N, lambdas in test_cases:\n        # 1. Grid and problem setup\n        h = 1.0 / (N + 1)\n        x = np.linspace(h, 1.0 - h, N)\n        f = np.sin(np.pi * x)\n\n        # 2. Assemble the discrete Laplacian matrix L\n        diag_val = 2.0 / h**2\n        off_diag_val = -1.0 / h**2\n        L = np.diag(np.full(N, diag_val)) + \\\n            np.diag(np.full(N - 1, off_diag_val), k=1) + \\\n            np.diag(np.full(N - 1, off_diag_val), k=-1)\n\n        # 3. Continuation loop\n        u_sol = None\n        for lambd in lambdas:\n            if lambd == 0.0:\n                # 4. For lambda=0, solve the linear system\n                u_sol = np.linalg.solve(L, f)\n            else:\n                # 5. For lambda != 0, use Newton's method\n                u_current = u_sol.copy()  # Use previous solution as initial guess\n                \n                max_iter = 50\n                tol = 1e-10\n\n                for _ in range(max_iter):\n                    # a. Compute residual F(u)\n                    residual = L @ u_current + lambd * u_current**3 - f\n                    res_norm = np.linalg.norm(residual)\n\n                    if res_norm  tol:\n                        break\n\n                    # b. Compute Jacobian J(u)\n                    jacobian_diag = 3.0 * lambd * u_current**2\n                    jacobian = L + np.diag(jacobian_diag)\n\n                    # c. Solve for Newton step\n                    try:\n                        newton_step = np.linalg.solve(jacobian, -residual)\n                    except np.linalg.LinAlgError:\n                        # Jacobian is singular, convergence fails\n                        # For the purposes of this problem, we can expect this not to happen.\n                        # Marking the result as NaN if it does.\n                        u_current.fill(np.nan)\n                        break\n\n                    # d. Backtracking line search\n                    alpha = 1.0\n                    for _ in range(10): # max 10 backtracking steps\n                        u_next = u_current + alpha * newton_step\n                        next_residual = L @ u_next + lambd * u_next**3 - f\n                        if np.linalg.norm(next_residual)  res_norm:\n                            break\n                        alpha *= 0.5\n                    \n                    u_current = u_current + alpha * newton_step\n                \n                u_sol = u_current\n\n            # 6. Compute and store the l_infinity norm of the solution\n            l_inf_norm = np.max(np.abs(u_sol))\n            all_results.append(round(l_inf_norm, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}