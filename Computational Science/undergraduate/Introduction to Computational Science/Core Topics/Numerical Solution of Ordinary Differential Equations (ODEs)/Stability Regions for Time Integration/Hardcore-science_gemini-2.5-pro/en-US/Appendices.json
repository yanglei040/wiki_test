{
    "hands_on_practices": [
        {
            "introduction": "This first practice is about making the abstract concept of a stability region concrete and visual. By numerically tracing the boundary where $|R(z)| = 1$, you will map out the stability \"landscape\" for several fundamental methods. This hands-on exploration will build your intuition and allow you to empirically verify key properties like A-stability, connecting the mathematical definition of the stability function $R(z)$ to observable geometric behavior .",
            "id": "3197800",
            "problem": "Consider the linear test problem $y'(t)=\\lambda\\,y(t)$ with complex $\\lambda$, and define $z=h\\,\\lambda$ for time step $h$. When a one-step method is applied to this problem, it produces an update $y_{n+1}=R(z)\\,y_n$ for some scalar function $R(z)$, called the stability function. A method is said to have A-stability if for every $z$ with $\\operatorname{Re}(z)\\le 0$, the inequality $|R(z)|\\le 1$ holds. A method is said to have L-stability if it is A-stable and additionally $\\lim_{|z|\\to\\infty,\\,\\operatorname{Re}(z)0} R(z)=0$. Starting from these base definitions and the standard construction of the stability function by applying a method to $y'(t)=\\lambda\\,y(t)$, derive $R(z)$ for each method in the test suite below, and design a numerical experiment that traces the real-axis intersection of the boundary $|R(z)|=1$ and infers A-stability by exploring large negative real $z$ and small negative real $z$ on a fine grid.\n\nYour program must:\n- Implement a procedure that, given a method specification, constructs the corresponding stability function $R(z)$ entirely from first principles, by applying the method to the test problem $y'(t)=\\lambda\\,y(t)$ and eliminating intermediate variables to obtain the factor relating $y_{n+1}$ to $y_n$ as a function of $z$.\n- For each method, generate a fine grid of real $z$ values over $[-50,0]$ and compute $|R(z)|$ on that grid.\n- Numerically identify and count all real-axis points in $[-50,0]$ where the boundary condition $|R(z)|=1$ is met. You must detect both crossing events and exact hits to within a small tolerance.\n- Infer A-stability on the real axis by checking whether $|R(z)|\\le 1$ for all $z\\in[-50,0]$ on the grid (this is an empirical inference restricted to the negative real axis). Report this inference as a boolean.\n- Infer L-stability by checking whether $|R(z)|$ evaluated at a large negative real value $z=-1000$ is below $0.01$. Report this inference as a boolean.\n\nUse the following test suite of Runge–Kutta methods expressed by their Butcher tableau $(A,b)$:\n- Explicit (forward) Euler: $A=\\begin{bmatrix}0\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$.\n- Implicit (backward) Euler: $A=\\begin{bmatrix}1\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$.\n- Trapezoidal rule (two-stage implicit): $A=\\begin{bmatrix}0  0 \\\\ \\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}$, $b=\\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}$.\n\nNumerical parameters to use:\n- Real-axis exploration range $z\\in[-50,0]$ with a uniform grid of $5001$ points.\n- Boundary detection tolerance for equality $|R(z)|=1$ of $10^{-8}$.\n- L-stability threshold at $z=-1000$ of $0.01$.\n\nFor each method, your program must return a list of three items:\n- The integer count of distinct real-axis boundary points in $[-50,0]$ where $|R(z)|=1$.\n- A boolean indicating the empirical A-stability inference on the negative real axis based on the grid.\n- A boolean indicating the empirical L-stability inference based on the threshold at $z=-1000$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three method results as a comma-separated list enclosed in square brackets, where each method result is itself a comma-separated list enclosed in square brackets. For example: $[[a_1,a_2,a_3],[b_1,b_2,b_3],[c_1,c_2,c_3]]$.",
            "solution": "The analysis of a numerical method's stability is fundamental to computational science. It determines the range of time steps $h$ for which the numerical solution to a differential equation remains bounded. The standard approach involves applying the method to the linear test problem $y'(t) = \\lambda y(t)$, where $\\lambda$ is a complex number with $\\operatorname{Re}(\\lambda) \\le 0$. This models the behavior of stiff systems, where different components evolve on vastly different time scales. Applying a one-step numerical method to this equation yields a recurrence relation of the form $y_{n+1} = R(z) y_n$, where $z = h\\lambda$ and $R(z)$ is the stability function. For the numerical solution to be stable, we require $|R(z)| \\le 1$.\n\nA general $s$-stage Runge-Kutta (RK) method is defined by its Butcher tableau, consisting of a matrix $A \\in \\mathbb{R}^{s \\times s}$ and a vector of weights $b \\in \\mathbb{R}^s$. When applied to the test problem $y'(t) = \\lambda y(t)$, the update rule is:\n$$ y_{n+1} = y_n + h \\sum_{i=1}^s b_i k_i $$\nThe internal stage derivatives $k_i$ are given by:\n$$ k_i = f(t_n + c_i h, Y_i) = \\lambda Y_i = \\lambda \\left( y_n + h \\sum_{j=1}^s a_{ij} k_j \\right) $$\nfor $i=1, \\dots, s$. Let $z=h\\lambda$. The equations for the stage derivatives become:\n$$ k_i = \\frac{z}{h} \\left( y_n + h \\sum_{j=1}^s a_{ij} k_j \\right) = \\frac{z}{h} y_n + z \\sum_{j=1}^s a_{ij} k_j $$\nThis is a system of $s$ linear equations for the vector $\\mathbf{k} = [k_1, \\dots, k_s]^T$. In matrix form, with $\\mathbf{1}$ being the vector of ones:\n$$ \\mathbf{k} - z A \\mathbf{k} = \\frac{z}{h} y_n \\mathbf{1} \\implies (I - zA) \\mathbf{k} = \\frac{z}{h} y_n \\mathbf{1} $$\nSolving for $\\mathbf{k}$ yields:\n$$ \\mathbf{k} = \\frac{z}{h} y_n (I - zA)^{-1} \\mathbf{1} $$\nSubstituting this back into the update formula for $y_{n+1}$, written with vector notation as $y_{n+1} = y_n + h \\mathbf{b}^T \\mathbf{k}$:\n$$ y_{n+1} = y_n + h \\mathbf{b}^T \\left( \\frac{z}{h} y_n (I - zA)^{-1} \\mathbf{1} \\right) = y_n + z y_n \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1} $$\nFactoring out $y_n$, we identify the stability function $R(z)$:\n$$ R(z) = 1 + z \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1} $$\nThis general formula allows us to derive $R(z)$ for any RK method given its Butcher tableau $(A, b)$.\n\nWe now apply this formula to the specified methods.\n\n1.  **Explicit (Forward) Euler Method**:\n    The Butcher tableau is $s=1$, $A=\\begin{bmatrix}0\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$.\n    The matrix $(I - zA)$ is the $1 \\times 1$ matrix $[1 - z(0)] = [1]$, whose inverse is $[1]$.\n    $$ R(z) = 1 + z [1] [1] [1] = 1 + z $$\n\n2.  **Implicit (Backward) Euler Method**:\n    The Butcher tableau is $s=1$, $A=\\begin{bmatrix}1\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$.\n    The matrix $(I - zA)$ is $[1 - z(1)] = [1-z]$, whose inverse is $[(1-z)^{-1}]$.\n    $$ R(z) = 1 + z [1] [(1-z)^{-1}] [1] = 1 + \\frac{z}{1-z} = \\frac{1-z+z}{1-z} = \\frac{1}{1-z} $$\n\n3.  **Trapezoidal Rule**:\n    This is a $2$-stage implicit method with $A=\\begin{bmatrix}0  0 \\\\ \\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}$ and $b=\\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}^T$.\n    First, we compute $(I - zA)^{-1}$:\n    $$ I - zA = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix} - z\\begin{bmatrix}0  0 \\\\ \\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix} = \\begin{bmatrix}1  0 \\\\ -z/2  1 - z/2\\end{bmatrix} $$\n    The inverse is:\n    $$ (I - zA)^{-1} = \\frac{1}{1(1-z/2) - 0} \\begin{bmatrix}1 - z/2  0 \\\\ z/2  1\\end{bmatrix} = \\frac{1}{1 - z/2} \\begin{bmatrix}1 - z/2  0 \\\\ z/2  1\\end{bmatrix} $$\n    Now we substitute this into the formula for $R(z)$:\n    $$ R(z) = 1 + z \\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix} \\frac{1}{1-z/2} \\begin{bmatrix}1-z/2  0 \\\\ z/2  1\\end{bmatrix} \\begin{bmatrix}1 \\\\ 1\\end{bmatrix} $$\n    $$ R(z) = 1 + \\frac{z}{1-z/2} \\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix} \\begin{bmatrix}1-z/2 \\\\ 1+z/2\\end{bmatrix} = 1 + \\frac{z}{1-z/2} \\left( \\frac{1}{2}(1-z/2) + \\frac{1}{2}(1+z/2) \\right) $$\n    $$ R(z) = 1 + \\frac{z}{1-z/2} (1) = \\frac{1-z/2+z}{1-z/2} = \\frac{1+z/2}{1-z/2} $$\n\nThe numerical experiment is designed as follows:\n\n1.  **Stability Function Implementation**: A general function is created that takes $A$ and $b$ and returns the corresponding stability function $R(z)$. This function computes $R(z) = 1 + z \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1}$ and is vectorized to operate over an array of $z$ values.\n\n2.  **Grid Generation**: A uniform grid of $5001$ complex-valued points is generated for $z$ on the real-axis interval $[-50, 0]$.\n\n3.  **Boundary Point Counting**: To find where $|R(z)| = 1$, we analyze the function $g(z) = |R(z)| - 1$ on the grid. We count the number of \"boundary events\" using a stateful algorithm that iterates through the grid. An event is counted if we encounter a contiguous region of points where $|g(z_i)| \\le 10^{-8}$ (a \"hit\") or if there is a sign change $g(z_i)g(z_{i+1})  0$ between two non-hit points (a \"crossing\"). This prevents double-counting.\n\n4.  **A-stability Inference**: A-stability requires $|R(z)| \\le 1$ for all $\\operatorname{Re}(z) \\le 0$. Our experiment provides an empirical test restricted to the negative real axis. We compute $\\max(|R(z)|)$ over our grid $z \\in [-50, 0]$ and check if this maximum is less than or equal to $1$ (allowing for a small tolerance of $10^{-8}$). The result is a boolean.\n\n5.  **L-stability Inference**: L-stability requires A-stability and $\\lim_{|z|\\to\\infty,\\,\\operatorname{Re}(z)0} R(z)=0$. We test this second condition empirically by evaluating $|R(z)|$ at a large-magnitude negative real value, $z=-1000$. If the method is inferred to be A-stable from the previous step and $|R(-1000)|  0.01$, we infer it is L-stable. The result is a boolean.\n\nThis procedure is applied to each of the three methods, and the results are compiled.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and analyzes the stability functions for three Runge-Kutta methods.\n    \"\"\"\n\n    def get_stability_function(A, b):\n        \"\"\"\n        Constructs the stability function R(z) for a given Butcher tableau.\n        \n        Args:\n            A (np.ndarray): The A matrix of the Butcher tableau.\n            b (np.ndarray): The b vector of the Butcher tableau.\n\n        Returns:\n            A function that computes R(z) for a scalar or vector z.\n        \"\"\"\n        s = A.shape[0]\n        I = np.identity(s)\n        ones_s = np.ones((s, 1))\n        b_T = b.reshape(1, -1)\n\n        def R(z):\n            \"\"\"The stability function R(z).\"\"\"\n            # Vectorized implementation\n            if not np.isscalar(z):\n                z = np.asarray(z, dtype=np.complex128)\n                results = np.zeros_like(z, dtype=np.complex128)\n                for i, z_val in enumerate(z):\n                    if z_val == 0:\n                        results[i] = 1.0 + 0.0j\n                        continue\n                    try:\n                        mat_inv = np.linalg.inv(I - z_val * A)\n                        r_val = 1.0 + z_val * b_T @ mat_inv @ ones_s\n                        results[i] = r_val.item()\n                    except np.linalg.LinAlgError:\n                        results[i] = np.inf + 0.0j\n                return results\n\n            # Scalar implementation\n            z = complex(z)\n            if z == 0:\n                return 1.0 + 0.0j\n            try:\n                mat_inv = np.linalg.inv(I - z * A)\n                r_val = 1.0 + z * b_T @ mat_inv @ ones_s\n                return r_val.item()\n            except np.linalg.LinAlgError:\n                return np.inf + 0.0j\n        \n        return R\n\n    # Define the Butcher tableaus for the methods in the test suite.\n    test_cases = [\n        {\n            \"name\": \"Explicit (Forward) Euler\",\n            \"A\": np.array([[0.0]]),\n            \"b\": np.array([1.0]),\n        },\n        {\n            \"name\": \"Implicit (Backward) Euler\",\n            \"A\": np.array([[1.0]]),\n            \"b\": np.array([1.0]),\n        },\n        {\n            \"name\": \"Trapezoidal Rule\",\n            \"A\": np.array([[0.0, 0.0], [0.5, 0.5]]),\n            \"b\": np.array([0.5, 0.5]),\n        },\n    ]\n\n    # Numerical parameters from the problem statement\n    z_min = -50.0\n    z_max = 0.0\n    num_points = 5001\n    tolerance = 1e-8\n    l_stability_z = -1000.0\n    l_stability_threshold = 0.01\n\n    z_grid = np.linspace(z_min, z_max, num_points)\n    \n    final_results = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        b = case[\"b\"]\n        \n        # 1. Construct the stability function R(z)\n        R = get_stability_function(A, b)\n        \n        # 2. Compute |R(z)| on the grid\n        abs_R = np.abs(R(z_grid))\n\n        # 3. Count real-axis boundary points where |R(z)| = 1\n        g = abs_R - 1.0\n        boundary_points_count = 0\n        in_hit_region = False\n        for i in range(len(g) - 1):\n            is_current_hit = np.abs(g[i]) = tolerance\n            if is_current_hit:\n                if not in_hit_region:\n                    boundary_points_count += 1\n                in_hit_region = True\n            else:\n                if in_hit_region:\n                    in_hit_region = False\n                \n                # Check for a crossing only if the next point is not the start of a new hit region.\n                # This prevents double counting a crossing that leads into a hit.\n                is_next_hit = np.abs(g[i+1]) = tolerance\n                if g[i] * g[i+1]  0 and not is_next_hit:\n                    boundary_points_count += 1\n        \n        # Check the last point for a hit\n        is_last_hit = np.abs(g[-1]) = tolerance\n        if is_last_hit and not in_hit_region:\n            boundary_points_count += 1\n\n        # 4. Infer A-stability on the negative real axis\n        # Allow for small floating point errors near the boundary\n        is_A_stable_real = np.all(abs_R = 1.0 + tolerance)\n        \n        # 5. Infer L-stability\n        abs_R_inf = np.abs(R(l_stability_z))\n        is_L_stable = is_A_stable_real and (abs_R_inf  l_stability_threshold)\n        \n        final_results.append([boundary_points_count, is_A_stable_real, is_L_stable])\n\n    # Format the final output string as specified.\n    # e.g., [[a1,a2,a3],[b1,b2,b3],[c1,c2,c3]]\n    # Python's bool `True`/`False` needs to be lowercase `true`/`false` for some environments.\n    # However, the example shows list of lists, which implies `str()` on bool is fine. `str(True)` is 'True'.\n    # If JSON is intended, it would be `true`. But the format is a string of Python lists.\n    # The problem asks for comma-separated list of items, so the Python `str` representation is correct.\n    \n    formatted_results = []\n    for res in final_results:\n        # str(True) - \"True\", str(False) - \"False\"\n        formatted_results.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Now that you have visualized stability regions, this practice explores their profound impact on solving stiff differential equations, where different components evolve on vastly different time scales. Higher-order accuracy does not always guarantee better performance, and this exercise highlights the critical trade-off between accuracy and strong numerical damping. By comparing the A-stable Trapezoidal Rule with the L-stable Backward Euler method, you will discover why L-stability is such a coveted property for stiff problems .",
            "id": "3197729",
            "problem": "Consider the scalar linear ordinary differential equation that models a single-step stiff decay in chemical kinetics, given by $y'(t) = \\lambda y(t)$ with $\\lambda \\in \\mathbb{C}$ and $\\operatorname{Re}(\\lambda)  0$. This model captures the essential behavior of a stiff chemical kinetics step when $\\lambda$ is large in magnitude and negative. Let the initial condition be $y(0) = 1$. Let the one-step numerical solution be computed at time $t = h$ for step size $h > 0$, and define the dimensionless stiffness parameter $z = h \\lambda$.\n\nA-stability is defined as the property that the numerical method remains stable for any $z$ with $\\operatorname{Re}(z) \\le 0$, in the sense that the method’s stability function $R(z)$ satisfies $\\lvert R(z) \\rvert \\le 1$ for all such $z$. $L$-stability (often called \"stiff decay\" stability) strengthens this by additionally requiring $\\lim_{\\lvert z \\rvert \\to \\infty, \\operatorname{Re}(z)  0} R(z) = 0$, so that extremely stiff components are strongly damped by the integrator.\n\nYour task is to analyze the trade-off between accuracy and damping for two implicit time-integration methods applied to the scalar test equation $y'(t) = \\lambda y(t)$:\n- The first-order backward Euler method, which is known to be $L$-stable.\n- The second-order trapezoidal rule (also known as the Crank–Nicolson method), which is known to be $A$-stable but not $L$-stable.\n\nStarting only from the method definitions and the scalar test equation $y'(t) = \\lambda y(t)$, perform the following steps in your program:\n\n1. Derive the one-step update formula for each method when applied to $y'(t) = \\lambda y(t)$ over one step of size $h$, and from it derive the corresponding stability function $R(z)$ for each method, where $z = h \\lambda$.\n2. Use the derived $R(z)$ to compute the one-step numerical solutions $y_{\\text{BE}}(h)$ and $y_{\\text{TR}}(h)$ for backward Euler and trapezoidal rule, respectively, starting from $y(0) = 1$.\n3. Compute the exact solution at $t = h$, which is $y_{\\text{exact}}(h) = \\exp(z)$, and the absolute errors $\\lvert y_{\\text{BE}}(h) - y_{\\text{exact}}(h) \\rvert$ and $\\lvert y_{\\text{TR}}(h) - y_{\\text{exact}}(h) \\rvert$.\n4. Compute the damping factors $\\lvert R_{\\text{BE}}(z) \\rvert$ and $\\lvert R_{\\text{TR}}(z) \\rvert$ as measures of how strongly each method suppresses stiff modes in one step.\n5. For each test case, determine two boolean statements:\n   - Whether the trapezoidal rule is more accurate for the one-step solution, i.e., whether $\\lvert y_{\\text{TR}}(h) - y_{\\text{exact}}(h) \\rvert  \\lvert y_{\\text{BE}}(h) - y_{\\text{exact}}(h) \\rvert$.\n   - Whether backward Euler damps more strongly in one step, i.e., whether $\\lvert R_{\\text{BE}}(z) \\rvert  \\lvert R_{\\text{TR}}(z) \\rvert$.\n\nAll quantities reported are dimensionless, and all floating-point outputs must be rounded to $6$ decimal places.\n\nUse the following test suite of parameter values, which cover mild stiffness, moderate stiffness, and severe stiffness:\n- Test case $1$: $\\lambda = -1000$ and $h = 0.01$ so $z = -10$.\n- Test case $2$: $\\lambda = -10^6$ and $h = 0.01$ so $z = -10^4$.\n- Test case $3$: $\\lambda = -5$ and $h = 0.2$ so $z = -1$.\n- Test case $4$: $\\lambda = -0.5$ and $h = 0.2$ so $z = -0.1$.\n\nYour program should produce a single line of output containing the results of all test cases as a comma-separated list enclosed in square brackets, with each test case contributing a sub-list in the following order:\n$[\\lvert y_{\\text{BE}}(h) - y_{\\text{exact}}(h) \\rvert, \\lvert y_{\\text{TR}}(h) - y_{\\text{exact}}(h) \\rvert, \\lvert R_{\\text{BE}}(z) \\rvert, \\lvert R_{\\text{TR}}(z) \\rvert, \\text{TR\\_more\\_accurate}, \\text{BE\\_damps\\_stronger}]$\nwhere the last two entries are boolean values. The exact required output format is:\n$[[e_{\\text{BE},1},e_{\\text{TR},1},d_{\\text{BE},1},d_{\\text{TR},1},b_{1},c_{1}],[e_{\\text{BE},2},e_{\\text{TR},2},d_{\\text{BE},2},d_{\\text{TR},2},b_{2},c_{2}],[e_{\\text{BE},3},e_{\\text{TR},3},d_{\\text{BE},3},d_{\\text{TR},3},b_{3},c_{3}],[e_{\\text{BE},4},e_{\\text{TR},4},d_{\\text{BE},4},d_{\\text{TR},4},b_{4},c_{4}]]$\nwith no spaces anywhere, and all floating-point values rounded to $6$ decimal places.",
            "solution": "The problem requires an analysis of the trade-off between accuracy and damping for two numerical time-integration methods, the backward Euler method and the trapezoidal rule, when applied to a stiff scalar ordinary differential equation (ODE). The analysis is based on the standard test equation $y'(t) = \\lambda y(t)$ with initial condition $y(0) = 1$. The numerical solution after one step of size $h$ is denoted $y_1$. The dimensionless stiffness parameter is $z = h\\lambda$.\n\nThe numerical solution after one step for this linear test equation can be expressed in the form $y_1 = R(z) y_0$, where $R(z)$ is the stability function of the method. Given $y_0 = y(0) = 1$, the one-step numerical solution is simply $y_1 = R(z)$.\n\nFirst, we derive the stability function $R(z)$ for each method.\n\n**1. Backward Euler (BE) Method**\n\nThe backward Euler method is a first-order implicit method defined by the update formula:\n$$\ny_{n+1} = y_n + h f(t_{n+1}, y_{n+1})\n$$\nApplying this to the test equation $f(t, y) = \\lambda y$, we have:\n$$\ny_1 = y_0 + h (\\lambda y_1)\n$$\nWe solve for $y_1$:\n$$\ny_1 - h \\lambda y_1 = y_0\n$$\n$$\ny_1 (1 - h \\lambda) = y_0\n$$\n$$\ny_1 = \\frac{1}{1 - h \\lambda} y_0\n$$\nSubstituting $z = h\\lambda$, we find the stability function for the backward Euler method:\n$$\nR_{\\text{BE}}(z) = \\frac{1}{1 - z}\n$$\nThis method is known to be $L$-stable because for $\\operatorname{Re}(z) \\le 0$, we have $\\lvert 1-z \\rvert \\ge 1$, which implies $\\lvert R_{\\text{BE}}(z) \\rvert = \\frac{1}{\\lvert 1-z \\rvert} \\le 1$. Furthermore, as $\\lvert z \\rvert \\to \\infty$ with $\\operatorname{Re}(z)  0$, we have $\\lvert R_{\\text{BE}}(z) \\rvert \\to 0$.\n\n**2. Trapezoidal Rule (TR) Method**\n\nThe trapezoidal rule (or Crank–Nicolson method) is a second-order implicit method defined by:\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left[ f(t_n, y_n) + f(t_{n+1}, y_{n+1}) \\right]\n$$\nApplying this to the test equation $f(t, y) = \\lambda y$:\n$$\ny_1 = y_0 + \\frac{h}{2} (\\lambda y_0 + \\lambda y_1)\n$$\nWe solve for $y_1$:\n$$\ny_1 - \\frac{h \\lambda}{2} y_1 = y_0 + \\frac{h \\lambda}{2} y_0\n$$\n$$\ny_1 \\left(1 - \\frac{h \\lambda}{2}\\right) = y_0 \\left(1 + \\frac{h \\lambda}{2}\\right)\n$$\n$$\ny_1 = \\frac{1 + h \\lambda / 2}{1 - h \\lambda / 2} y_0\n$$\nSubstituting $z = h\\lambda$, we find the stability function for the trapezoidal rule:\n$$\nR_{\\text{TR}}(z) = \\frac{1 + z/2}{1 - z/2}\n$$\nThis method is $A$-stable, as for any $z$ with $\\operatorname{Re}(z) \\le 0$, we have $\\lvert 1 + z/2 \\rvert \\le \\lvert 1 - z/2 \\rvert$, which implies $\\lvert R_{\\text{TR}}(z) \\rvert \\le 1$. However, it is not $L$-stable, because as $\\lvert z \\rvert \\to \\infty$ with $\\operatorname{Re}(z)  0$:\n$$\n\\lim_{\\lvert z \\rvert \\to \\infty, \\operatorname{Re}(z)  0} \\lvert R_{\\text{TR}}(z) \\rvert = \\lim_{\\lvert z \\rvert \\to \\infty} \\left\\lvert \\frac{z/2(2/z + 1)}{z/2(2/z - 1)} \\right\\rvert = \\left\\lvert \\frac{1}{-1} \\right\\rvert = 1\n$$\nThis means extremely stiff components are not damped away by the trapezoidal rule.\n\n**3. Analysis Metrics**\n\nFor each test case defined by a value of $z$, we compute the following quantities:\n\n- **Exact Solution**: The exact solution to $y'(t) = \\lambda y(t)$ with $y(0) = 1$ is $y(t) = e^{\\lambda t}$. At time $t=h$, this is $y_{\\text{exact}}(h) = e^z$.\n- **Numerical Solutions**: Since $y(0)=1$, the one-step numerical solutions are $y_{\\text{BE}}(h) = R_{\\text{BE}}(z)$ and $y_{\\text{TR}}(h) = R_{\\text{TR}}(z)$.\n- **Absolute Errors**: The errors after one step are $e_{\\text{BE}} = \\lvert y_{\\text{BE}}(h) - y_{\\text{exact}}(h) \\rvert = \\lvert R_{\\text{BE}}(z) - e^z \\rvert$ and $e_{\\text{TR}} = \\lvert y_{\\text{TR}}(h) - y_{\\text{exact}}(h) \\rvert = \\lvert R_{\\text{TR}}(z) - e^z \\rvert$.\n- **Damping Factors**: The damping of the numerical solution in one step is quantified by the magnitude of the stability function, $d_{\\text{BE}} = \\lvert R_{\\text{BE}}(z) \\rvert$ and $d_{\\text{TR}} = \\lvert R_{\\text{TR}}(z) \\rvert$.\n\nFinally, we determine the boolean values for:\n- $\\text{TR\\_more\\_accurate}$: $e_{\\text{TR}}  e_{\\text{BE}}$\n- $\\text{BE\\_damps\\_stronger}$: $d_{\\text{BE}}  d_{\\text{TR}}$\n\nThe program will now systematically compute these quantities for the given test cases. The test cases correspond to $z = -10$, $z = -10^4$, $z = -1$, and $z = -0.1$. The results illustrate the trade-off: the trapezoidal rule is generally more accurate for small $\\lvert z \\rvert$ due to its higher order, while the backward Euler method provides superior damping for large $\\lvert z \\rvert$ due to its $L$-stability.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the accuracy and damping properties of Backward Euler and Trapezoidal Rule\n    for a stiff scalar ODE.\n    \"\"\"\n    # The problem provides lambda and h, but the calculations only depend on z = h*lambda.\n    # Test case 1: lambda = -1000, h = 0.01  = z = -10.0\n    # Test case 2: lambda = -10^6,  h = 0.01  = z = -10000.0\n    # Test case 3: lambda = -5,    h = 0.2   = z = -1.0\n    # Test case 4: lambda = -0.5,   h = 0.2   = z = -0.1\n    test_cases_z = [-10.0, -10000.0, -1.0, -0.1]\n\n    all_results = []\n    \n    for z in test_cases_z:\n        # 1. Derive/Use stability functions R(z)\n        # For backward Euler: y_1 = y_0 + h * lambda * y_1 = y_1(1-h*lambda) = y_0 = y_1 = y_0 / (1-z)\n        # So, R_BE(z) = 1 / (1 - z)\n        R_be = 1.0 / (1.0 - z)\n\n        # For trapezoidal rule: y_1 = y_0 + h/2 * (lambda*y_0 + lambda*y_1) = y_1(1 - z/2) = y_0(1 + z/2)\n        # So, R_TR(z) = (1 + z/2) / (1 - z/2)\n        R_tr = (1.0 + z / 2.0) / (1.0 - z / 2.0)\n\n        # 2. Compute the one-step numerical solutions (y(0)=1, so y_1 = R(z))\n        y_be = R_be\n        y_tr = R_tr\n\n        # 3. Compute the exact solution and absolute errors\n        # Exact solution to y'=lambda*y is y(t)=y(0)*exp(lambda*t).\n        # At t=h, y(h) = 1 * exp(h*lambda) = exp(z)\n        y_exact = np.exp(z)\n        \n        # Absolute errors\n        e_be = np.abs(y_be - y_exact)\n        e_tr = np.abs(y_tr - y_exact)\n        \n        # 4. Compute the damping factors\n        d_be = np.abs(R_be)\n        d_tr = np.abs(R_tr)\n\n        # 5. Determine boolean statements\n        tr_more_accurate = e_tr  e_be\n        be_damps_stronger = d_be  d_tr\n\n        # Store the results for the current test case.\n        # [e_BE, e_TR, d_BE, d_TR, TR_more_accurate, BE_damps_stronger]\n        case_results = [e_be, e_tr, d_be, d_tr, tr_more_accurate, be_damps_stronger]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required.\n    # No spaces, 6 decimal places for floats, Python booleans as strings.\n    formatted_sublists = []\n    for case in all_results:\n        e_be_str = f\"{case[0]:.6f}\"\n        e_tr_str = f\"{case[1]:.6f}\"\n        d_be_str = f\"{case[2]:.6f}\"\n        d_tr_str = f\"{case[3]:.6f}\"\n        bool1_str = str(case[4])\n        bool2_str = str(case[5])\n        \n        sublist_str = f\"[{e_be_str},{e_tr_str},{d_be_str},{d_tr_str},{bool1_str},{bool2_str}]\"\n        formatted_sublists.append(sublist_str)\n\n    # Join the sublists with commas and enclose in brackets.\n    final_output = f\"[{','.join(formatted_sublists)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice synthesizes these concepts by applying them to a system of linear ODEs, $y' = Ay$. The stability of such a system is constrained by its \"fastest\" dynamic mode, which corresponds to an eigenvalue $\\lambda_i$ of the matrix $A$. Your challenge is to develop a program that determines the absolute \"speed limit\" for a given numerical method—the maximum stable time step $\\Delta t$—by ensuring that all scaled eigenvalues $z = \\Delta t \\lambda_i$ remain safely within the method's stability region .",
            "id": "3197733",
            "problem": "You are given the initial value problem $y'(t)=A_{\\text{sys}}\\,y(t)$, where $A_{\\text{sys}}$ is a complex-valued matrix and $y(t)$ is a complex-valued vector function. Consider integrating this system using a fixed-step explicit Runge–Kutta method described by a Butcher tableau. The stability of the time integration is governed by the behavior of the method on the linear test equation $y'(t)=\\lambda\\,y(t)$, where $\\lambda\\in\\mathbb{C}$. For an explicit Runge–Kutta method, its stability region is the set of $z\\in\\mathbb{C}$ such that the corresponding scalar amplification factor applied to $y'(t)=\\lambda\\,y(t)$ satisfies $\\lvert R(z)\\rvert\\leq 1$, where $z=\\Delta t\\,\\lambda$ and $\\Delta t$ is the time step size. A method is called A-stable if its stability region includes the entire left half-plane $\\{z\\in\\mathbb{C}:\\Re(z)\\leq 0\\}$, and L-stable if it is A-stable and additionally $R(z)\\to 0$ as $z\\to -\\infty$ along the real axis. Explicit Runge–Kutta methods are not A-stable, so the maximal stable $\\Delta t$ is generally finite, even when $\\Re(\\lambda)0$.\n\nStarting from the fundamental base of the linear test equation and the definition of the Runge–Kutta method through its Butcher tableau, derive the stability function $R(z)$ for the given method, justify the stability criterion $\\lvert R(\\Delta t\\,\\lambda)\\rvert\\leq 1$ for each eigenvalue $\\lambda$ of $A_{\\text{sys}}$, and construct a numerical search procedure that, for a fixed Runge–Kutta method and a given system matrix $A_{\\text{sys}}$, finds the maximal $\\Delta t0$ such that all scaled eigenvalues $z_i=\\Delta t\\,\\lambda_i$ lie within the stability region, i.e., $\\lvert R(z_i)\\rvert\\leq 1$ for all eigenvalues $\\lambda_i$ of $A_{\\text{sys}}$. Your program must not assume a pre-tabulated stability polynomial; it must obtain $R(z)$ directly from the Butcher tableau and the definition of the method applied to $y'(t)=\\lambda\\,y(t)$.\n\nUse the classical $4$-stage explicit Runge–Kutta method (often referred to as \"RK$4$\") with the following Butcher tableau:\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix},\\quad\nc=\\begin{bmatrix}\n0\\\\\n\\frac{1}{2}\\\\\n\\frac{1}{2}\\\\\n1\n\\end{bmatrix}.\n$$\n\nDesign your program to apply this single RK method to each of the following test matrices $A_{\\text{sys}}^{(k)}$ and for each matrix compute a single float value: the maximal $\\Delta t$ such that the stability condition $\\lvert R(\\Delta t\\,\\lambda_i)\\rvert\\leq 1$ holds simultaneously for all eigenvalues $\\lambda_i$ of $A_{\\text{sys}}^{(k)}$. The search must be performed along the rays $z=\\Delta t\\,\\lambda_i$ in $\\mathbb{C}$ for $\\Delta t\\geq 0$, and should return the largest $\\Delta t$ satisfying the constraint. If the constraint only holds for $\\Delta t=0$, your program must return $0.0$ for that case. All numerical outputs must be rounded to $8$ decimal places.\n\nTest suite:\n- Case $1$ (general negative real eigenvalues):\n$$\nA_{\\text{sys}}^{(1)}=\\begin{bmatrix}\n-2  0\\\\\n0  -5\n\\end{bmatrix}.\n$$\n- Case $2$ (positive real eigenvalues):\n$$\nA_{\\text{sys}}^{(2)}=\\begin{bmatrix}\n1  0\\\\\n0  \\frac{1}{2}\n\\end{bmatrix}.\n$$\n- Case $3$ (complex-conjugate pair with negative real part):\n$$\nA_{\\text{sys}}^{(3)}=\\begin{bmatrix}\n-1  -4\\\\\n1  -1\n\\end{bmatrix}.\n$$\n- Case $4$ (highly oscillatory with small damping):\n$$\nA_{\\text{sys}}^{(4)}=\\begin{bmatrix}\n-0.1  10\\\\\n-10  -0.1\n\\end{bmatrix}.\n$$\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, with each float rounded to $8$ decimal places and no spaces. For example, the output must look like $[d_1,d_2,d_3,d_4]$ where each $d_k$ is a decimal string with exactly $8$ digits after the decimal point.",
            "solution": "### 1. The Explicit Runge-Kutta Method and the Stability Function\n\nAn $s$-stage explicit Runge–Kutta (ERK) method for solving the initial value problem $y'(t) = f(t, y(t))$ is defined by the equations:\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i k_i \\\\\nk_i = f\\left(t_n + c_i \\Delta t, y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\nThe coefficients $a_{ij}$, $b_i$, and $c_i$ are given by a Butcher tableau, which for an explicit method has a strictly lower triangular matrix $A = (a_{ij})$.\n\nTo analyze the stability of the method, we apply it to the Dahlquist test equation, $y'(t) = \\lambda y(t)$, where $\\lambda \\in \\mathbb{C}$. In this case, $f(t, y) = \\lambda y$. The stage values $k_i$ become:\n$$\nk_i = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\nLet us define the scaled time step $z = \\Delta t \\lambda$. We can observe that each stage vector $k_i$ must be proportional to $\\lambda y_n$. Let $k_i = K_i(z) \\lambda y_n$ for some function $K_i(z)$. Substituting this into the stage equation:\n$$\nK_i(z) \\lambda y_n = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} (K_j(z) \\lambda y_n)\\right)\n$$\nDividing by $\\lambda y_n$ (assuming $\\lambda, y_n \\neq 0$), we obtain a recurrence relation for the stage polynomials $K_i(z)$:\n$$\nK_i(z) = 1 + z \\sum_{j=1}^{i-1} a_{ij} K_j(z)\n$$\nwith $K_1(z) = 1$ since the sum is empty for $i=1$. Because $A$ is strictly lower triangular, we can compute each $K_i(z)$ sequentially. $K_i(z)$ is a polynomial in $z$ of degree $i-1$.\n\nThe numerical solution is updated as:\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i (K_i(z) \\lambda y_n) = y_n \\left(1 + z \\sum_{i=1}^s b_i K_i(z)\\right)\n$$\nThe term in the parenthesis is the amplification factor, which maps $y_n$ to $y_{n+1}$. This is the stability function $R(z)$:\n$$\nR(z) = 1 + z \\sum_{i=1}^s b_i K_i(z)\n$$\nFor an $s$-stage ERK method, $R(z)$ is a polynomial in $z$ of degree at most $s$.\n\n### 2. Stability Function for the Classical RK4 Method\n\nThe problem provides the Butcher tableau for the classical $4$-stage Runge-Kutta method ($s=4$):\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix}\n$$\nWe derive the stage polynomials $K_i(z)$:\n\\begin{align*}\nK_1(z) = 1 \\\\\nK_2(z) = 1 + z a_{21} K_1(z) = 1 + z \\left(\\frac{1}{2}\\right)(1) = 1 + \\frac{z}{2} \\\\\nK_3(z) = 1 + z (a_{31} K_1(z) + a_{32} K_2(z)) = 1 + z \\left(0 + \\frac{1}{2}\\left(1 + \\frac{z}{2}\\right)\\right) = 1 + \\frac{z}{2} + \\frac{z^2}{4} \\\\\nK_4(z) = 1 + z (a_{41} K_1 + a_{42} K_2 + a_{43} K_3) = 1 + z \\left(0 + 0 + 1\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right)\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\n\\end{align*}\nNow, we construct the stability function $R(z)$:\n$$\nR(z) = 1 + z \\left( b_1 K_1(z) + b_2 K_2(z) + b_3 K_3(z) + b_4 K_4(z) \\right)\n$$\nSubstituting the values of $b_i$ and polynomials $K_i(z)$:\n$$\nR(z) = 1 + z \\left[ \\frac{1}{6}(1) + \\frac{1}{3}\\left(1+\\frac{z}{2}\\right) + \\frac{1}{3}\\left(1+\\frac{z}{2}+\\frac{z^2}{4}\\right) + \\frac{1}{6}\\left(1+z+\\frac{z^2}{2}+\\frac{z^3}{4}\\right) \\right]\n$$\nCombining terms by powers of $z$ inside the brackets:\n\\begin{itemize}\n    \\item Constant term: $\\frac{1}{6} + \\frac{1}{3} + \\frac{1}{3} + \\frac{1}{6} = 1$\n    \\item Term in $z$: $\\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{6}(1) = \\frac{1}{6} + \\frac{1}{6} + \\frac{1}{6} = \\frac{1}{2}$\n    \\item Term in $z^2$: $\\frac{1}{3}\\left(\\frac{1}{4}\\right) + \\frac{1}{6}\\left(\\frac{1}{2}\\right) = \\frac{1}{12} + \\frac{1}{12} = \\frac{1}{6}$\n    \\item Term in $z^3$: $\\frac{1}{6}\\left(\\frac{1}{4}\\right) = \\frac{1}{24}$\n\\end{itemize}\nMultiplying the expression in brackets by $z$ and adding $1$, we get:\n$$\nR(z) = 1 + z\\left(1 + \\frac{1}{2}z + \\frac{1}{6}z^2 + \\frac{1}{24}z^3\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} = \\sum_{k=0}^{4} \\frac{z^k}{k!}\n$$\nThis is the Taylor series expansion of $e^z$ truncated to the 4th order.\n\n### 3. Stability Criterion for Linear Systems\n\nFor the system of ODEs $y'(t) = A_{\\text{sys}} y(t)$, assuming $A_{\\text{sys}}$ is diagonalizable, there exists an invertible matrix $P$ such that $A_{\\text{sys}} = P \\Lambda P^{-1}$, where $\\Lambda$ is the diagonal matrix of eigenvalues $\\lambda_i$ of $A_{\\text{sys}}$.\nBy the change of variables $u(t) = P^{-1} y(t)$, the system decouples into a set of independent scalar equations: $u_i'(t) = \\lambda_i u_i(t)$.\nApplying a Runge-Kutta method to the original system $y' = A_{\\text{sys}} y$ is equivalent to applying the same method to each of these scalar equations. The update rule for the transformed variables is:\n$u_{i, n+1} = R(\\Delta t \\lambda_i) u_{i, n}$.\nFor the numerical solution $y_n$ to remain bounded as $n \\to \\infty$, all components $u_{i,n}$ must remain bounded. This requires that the amplification factor for each component has a magnitude no greater than one:\n$$\n|R(\\Delta t \\lambda_i)| \\leq 1 \\quad \\text{for all eigenvalues } \\lambda_i \\text{ of } A_{\\text{sys}}\n$$\nThis is the condition for numerical stability.\n\n### 4. Algorithm for Maximal Stable Time Step $\\Delta t_{\\max}$\n\nWe seek the largest $\\Delta t \\geq 0$ that satisfies the stability condition for all eigenvalues simultaneously. This is $\\Delta t_{\\max} = \\sup\\{\\Delta t \\geq 0 \\mid |R(\\Delta t \\lambda_i)| \\leq 1 \\text{ for all } i\\}$.\n\nThe algorithm is as follows:\n1.  Compute the set of eigenvalues $\\{\\lambda_i\\}$ of the matrix $A_{\\text{sys}}$.\n2.  For each eigenvalue $\\lambda_i$:\n    a. If $\\Re(\\lambda_i)  0$, the physical system is unstable. The numerical method will also be unstable for any $\\Delta t  0$, because for small $z=\\Delta t \\lambda_i$, $|R(z)| \\approx |1+z| = \\sqrt{(1+\\Delta t \\Re(\\lambda_i))^2 + (\\Delta t \\Im(\\lambda_i))^2}  1$. Thus, $\\Delta t_{\\max} = 0$.\n    b. If $\\lambda_i=0$, $R(0)=1$, so this eigenvalue imposes no restriction on $\\Delta t$.\n    c. If $\\Re(\\lambda_i) \\leq 0$ and $\\lambda_i \\neq 0$, we must find the smallest positive $\\Delta t_i^*$ such that $|R(\\Delta t_i^* \\lambda_i)| = 1$. This value represents the boundary of the stability region along the ray defined by $\\lambda_i$.\n3.  The overall maximal stable time step is the minimum of these individual limits: $\\Delta t_{\\max} = \\min_{i} \\{\\Delta t_i^*\\}$.\n\nTo find $\\Delta t_i^*$, we solve the equation $|R(\\Delta t \\lambda_i)| - 1 = 0$ for the smallest positive root $\\Delta t$. This is a nonlinear equation that we can solve numerically. A robust approach is to first bracket the root and then use a root-finding algorithm like Brent's method.\n-   **Bracketing**: For a given $\\lambda_i$ with $\\Re(\\lambda_i) \\le 0$, the function $h(\\Delta t) = |R(\\Delta t \\lambda_i)| - 1$ is non-positive for small $\\Delta t0$. Since the stability region of any explicit RK method is bounded, we can find an upper bound $b$ where $h(b)  0$ by starting with a guess and increasing it (e.g., by doubling) until the condition is met. This provides an interval $[a, b]$ containing the root.\n-   **Root-finding**: With the root bracketed in $[a, b]$, `scipy.optimize.brentq` can efficiently find the precise value of $\\Delta t_i^*$.\n\nThe implementation will compute $R(z)$ from the Butcher tableau as derived, then execute this numerical search for each test matrix.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the maximum stable time step for the classical RK4 method\n    for several linear systems.\n    \"\"\"\n    # Butcher tableau for the classical 4-stage Runge-Kutta method (RK4)\n    A_rk4 = np.array([\n        [0.0, 0.0, 0.0, 0.0],\n        [0.5, 0.0, 0.0, 0.0],\n        [0.0, 0.5, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 0.0]\n    ], dtype=float)\n    b_rk4 = np.array([1/6, 1/3, 1/3, 1/6], dtype=float)\n\n    # Test suite of system matrices A_sys\n    test_cases = [\n        # Case 1: general negative real eigenvalues\n        np.array([[-2.0, 0.0], [0.0, -5.0]], dtype=float),\n        # Case 2: positive real eigenvalues\n        np.array([[1.0, 0.0], [0.0, 0.5]], dtype=float),\n        # Case 3: complex-conjugate pair with negative real part\n        np.array([[-1.0, -4.0], [1.0, -1.0]], dtype=float),\n        # Case 4: highly oscillatory with small damping\n        np.array([[-0.1, 10.0], [-10.0, -0.1]], dtype=float)\n    ]\n\n    results = []\n    for A_sys in test_cases:\n        max_dt = find_max_dt(A_sys, A_rk4, b_rk4)\n        results.append(f\"{max_dt:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_R_from_tableau(z, A, b):\n    \"\"\"\n    Computes the value of the stability function R(z) for a given z\n    and a Runge-Kutta method specified by its Butcher tableau (A, b).\n    \"\"\"\n    s = len(b)\n    K = np.zeros(s, dtype=np.complex128)\n    for i in range(s):\n        # K_i(z) = 1 + z * sum(a[i,j] * K_j(z) for j  i)\n        stage_sum = np.dot(A[i, :i], K[:i])\n        K[i] = 1.0 + z * stage_sum\n    \n    # R(z) = 1 + z * sum(b_i * K_i(z))\n    return 1.0 + z * np.dot(b, K)\n\ndef find_max_dt(A_sys, butcher_A, butcher_b):\n    \"\"\"\n    Finds the maximum stable time step dt for a system y'(t) = A_sys*y(t)\n    using the stability function derived from the provided Butcher tableau.\n    \"\"\"\n    try:\n        eigenvalues = np.linalg.eigvals(A_sys)\n    except np.linalg.LinAlgError:\n        return 0.0\n\n    # If any eigenvalue has a positive real part, the system is unstable,\n    # and the time integration will be unstable for any dt  0.\n    if any(lam.real  1e-9 for lam in eigenvalues):\n        return 0.0\n        \n    min_dt_root = float('inf')\n    \n    for lam in eigenvalues:\n        if abs(lam)  1e-9:  # An eigenvalue of 0 imposes no stability constraint.\n            continue\n\n        def h(dt):\n            \"\"\"Target function for root finding: |R(dt*lam)| - 1.\"\"\"\n            z = dt * lam\n            R_val = compute_R_from_tableau(z, butcher_A, butcher_b)\n            return abs(R_val) - 1.0\n\n        # Search for the smallest positive root of h(dt) = 0.\n        # This determines the stability limit for this eigenvalue.\n        \n        # Step 1: Bracket the root. Find an interval [a, b] such that\n        # h(a) = 0 and h(b)  0.\n        # For stable/neutral eigenvalues, h(dt) = 0 for small dt  0.\n        a = 1e-9 # Small positive number to start the search interval.\n        b = 1e-3 # Initial guess for the upper bound.\n        \n        # Exponentially increase b until h(b)  0.\n        while h(b) = 0:\n            b *= 2.0\n            if b  1e6: # Safety break to avoid infinite loops\n                b = float('inf')\n                break\n        \n        if b == float('inf'):\n            # This eigenvalue does not seem to impose a stability constraint\n            # within a reasonable range. This shouldn't happen for explicit methods.\n            continue\n            \n        a = b / 2.0\n        if a == 0: a = 1e-9\n\n        # Step 2: Use Brent's method to find the root within the bracketed interval.\n        try:\n            root = brentq(h, a, b)\n            min_dt_root = min(min_dt_root, root)\n        except ValueError:\n            # Should not happen with the bracketing logic above.\n            # If it does, it implies immediate instability for this eigenvalue.\n            min_dt_root = 0.0\n            break\n\n    if min_dt_root == float('inf'):\n        # This case would occur if all eigenvalues were zero.\n        # Any dt would be stable, so there's no finite maximum.\n        # The problem cases avoid this scenario. Returning 0.0 as a safe default.\n        return 0.0\n        \n    return min_dt_root\n\nsolve()\n```"
        }
    ]
}