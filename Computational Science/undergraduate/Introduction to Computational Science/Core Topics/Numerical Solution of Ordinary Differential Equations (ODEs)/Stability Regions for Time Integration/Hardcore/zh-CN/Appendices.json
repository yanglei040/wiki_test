{
    "hands_on_practices": [
        {
            "introduction": "理论知识是基础，但真正的理解来自于实践。本节的动手实践旨在将时间积分稳定性区域的抽象概念转化为具体的计算技能。在深入研究复杂应用之前，建立对稳定性区域几何形状的直观理解至关重要。这个练习将指导您从基本定义出发，为几种经典方法推导其稳定性函数 $R(z)$，并通过数值实验来追踪稳定性边界 $|R(z)|=1$。通过这个过程，您将能够凭经验推断一种方法是否是A-稳定的，从而将抽象的数学属性与可观察的数值行为联系起来。",
            "id": "3197800",
            "problem": "考虑线性测试问题 $y'(t)=\\lambda\\,y(t)$，其中 $\\lambda$ 为复数，并为时间步长 $h$ 定义 $z=h\\,\\lambda$。当将单步法应用于此问题时，它会产生一个更新式 $y_{n+1}=R(z)\\,y_n$，其中某个标量函数 $R(z)$ 被称为稳定性函数。如果对于每一个满足 $\\operatorname{Re}(z)\\le 0$ 的 $z$，不等式 $|R(z)|\\le 1$ 都成立，则称该方法为A-稳定的。如果一个方法是 A-稳定的，并且还满足 $\\lim_{|z|\\to\\infty,\\,\\operatorname{Re}(z)0} R(z)=0$，则称该方法是L-稳定的。从这些基本定义和通过将方法应用于 $y'(t)=\\lambda\\,y(t)$ 来构造稳定性函数的标准方法出发，为下面测试套件中的每种方法推导出 $R(z)$，并设计一个数值实验，该实验追踪边界 $|R(z)|=1$ 与实轴的交点，并通过在精细网格上探索大的负实数 $z$ 和小的负实数 $z$ 来推断 A-稳定性。\n\n您的程序必须：\n- 实现一个程序，该程序根据给定的方法规范，完全从第一性原理出发构造相应的稳定性函数 $R(z)$，方法是将该方法应用于测试问题 $y'(t)=\\lambda\\,y(t)$ 并消去中间变量，以获得联系 $y_{n+1}$ 与 $y_n$ 的因子，并将其表示为 $z$ 的函数。\n- 对于每种方法，在 $[-50, 0]$ 上生成一个精细的实数 $z$ 值网格，并在该网格上计算 $|R(z)|$。\n- 在 $[-50, 0]$ 区间内数值化地识别并计数所有满足边界条件 $|R(z)|=1$ 的实轴点。您必须在小容差范围内检测到穿越事件和精确击中。\n- 通过检查网格上所有 $z\\in[-50, 0]$ 是否都满足 $|R(z)|\\le 1$ 来推断实轴上的 A-稳定性（这是一个仅限于负实轴的经验性推断）。将此推断报告为布尔值。\n- 通过检查在大的负实数值 $z=-1000$ 处计算的 $|R(z)|$ 是否低于 $0.01$ 来推断 L-稳定性。将此推断报告为布尔值。\n\n使用以下由其 Butcher 表 $(A,b)$ 表示的 Runge–Kutta 方法测试套件：\n- 显式（前向）欧拉法：$A=\\begin{bmatrix}0\\end{bmatrix}$，$b=\\begin{bmatrix}1\\end{bmatrix}$。\n- 隐式（后向）欧拉法：$A=\\begin{bmatrix}1\\end{bmatrix}$，$b=\\begin{bmatrix}1\\end{bmatrix}$。\n- 梯形法则（两阶段隐式）：$A=\\begin{bmatrix}0  0 \\\\ \\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}$，$b=\\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}$。\n\n使用的数值参数：\n- 实轴探索范围 $z\\in[-50, 0]$，使用包含 $5001$ 个点的均匀网格。\n- 用于等式 $|R(z)|=1$ 的边界检测容差为 $10^{-8}$。\n- 在 $z=-1000$ 处的 L-稳定性阈值为 $0.01$。\n\n对于每种方法，您的程序必须返回一个包含三个项目的列表：\n- 在 $[-50, 0]$ 区间内 $|R(z)|=1$ 的不同实轴边界点的整数计数。\n- 一个布尔值，表示基于网格在负实轴上的经验性 A-稳定性推断。\n- 一个布尔值，表示基于在 $z=-1000$ 处的阈值的经验性 L-稳定性推断。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个方法的结果，格式为一个逗号分隔的列表，并用方括号括起来，其中每个方法的结果本身也是一个用方括号括起来的逗号分隔列表。例如：$[[a_1,a_2,a_3],[b_1,b_2,b_3],[c_1,c_2,c_3]]$。",
            "solution": "数值方法稳定性的分析是计算科学的基础。它决定了对于一个微分方程，其数值解保持有界的时间步长 $h$ 的范围。标准方法是把该方法应用于线性测试问题 $y'(t) = \\lambda y(t)$，其中 $\\lambda$ 是一个满足 $\\operatorname{Re}(\\lambda) \\le 0$ 的复数。这模拟了刚性系统的行为，其中不同分量在迥异的时间尺度上进行演化。将单步数值方法应用于此方程，会得到一个形式为 $y_{n+1} = R(z) y_n$ 的递推关系，其中 $z = h\\lambda$，$R(z)$ 是稳定性函数。为使数值解稳定，我们要求 $|R(z)| \\le 1$。\n\n一个通用的 $s$ 阶 Runge-Kutta (RK) 方法由其 Butcher 表定义，该表由一个矩阵 $A \\in \\mathbb{R}^{s \\times s}$ 和一个权重向量 $b \\in \\mathbb{R}^s$ 组成。当应用于测试问题 $y'(t) = \\lambda y(t)$ 时，更新规则为：\n$$ y_{n+1} = y_n + h \\sum_{i=1}^s b_i k_i $$\n内部阶段的导数 $k_i$ 由以下公式给出：\n$$ k_i = f(t_n + c_i h, Y_i) = \\lambda Y_i = \\lambda \\left( y_n + h \\sum_{j=1}^s a_{ij} k_j \\right) $$\n对于 $i=1, \\dots, s$。令 $z=h\\lambda$。阶段导数的方程变为：\n$$ k_i = \\frac{z}{h} \\left( y_n + h \\sum_{j=1}^s a_{ij} k_j \\right) = \\frac{z}{h} y_n + z \\sum_{j=1}^s a_{ij} k_j $$\n这是一个关于向量 $\\mathbf{k} = [k_1, \\dots, k_s]^T$ 的 $s$ 个线性方程组。以矩阵形式表示，其中 $\\mathbf{1}$ 是全一向量：\n$$ \\mathbf{k} - z A \\mathbf{k} = \\frac{z}{h} y_n \\mathbf{1} \\implies (I - zA) \\mathbf{k} = \\frac{z}{h} y_n \\mathbf{1} $$\n求解 $\\mathbf{k}$ 可得：\n$$ \\mathbf{k} = \\frac{z}{h} y_n (I - zA)^{-1} \\mathbf{1} $$\n将此结果代回到 $y_{n+1}$ 的更新公式中，用向量表示法写作 $y_{n+1} = y_n + h \\mathbf{b}^T \\mathbf{k}$：\n$$ y_{n+1} = y_n + h \\mathbf{b}^T \\left( \\frac{z}{h} y_n (I - zA)^{-1} \\mathbf{1} \\right) = y_n + z y_n \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1} $$\n提取出 $y_n$ 后，我们便可确定稳定性函数 $R(z)$：\n$$ R(z) = 1 + z \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1} $$\n这个通用公式允许我们根据任意 RK 方法的 Butcher 表 $(A, b)$ 推导出其 $R(z)$。\n\n现在我们将此公式应用于指定的方法。\n\n1.  **显式（前向）欧拉法**：\n    Butcher 表为 $s=1$, $A=\\begin{bmatrix}0\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$。\n    矩阵 $(I - zA)$ 是 $1 \\times 1$ 矩阵 $[1 - z(0)] = [1]$，其逆矩阵为 $[1]$。\n    $$ R(z) = 1 + z [1] [1] [1] = 1 + z $$\n\n2.  **隐式（后向）欧拉法**：\n    Butcher 表为 $s=1$, $A=\\begin{bmatrix}1\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$。\n    矩阵 $(I - zA)$ 是 $[1 - z(1)] = [1-z]$，其逆矩阵为 $[(1-z)^{-1}]$。\n    $$ R(z) = 1 + z [1] [(1-z)^{-1}] [1] = 1 + \\frac{z}{1-z} = \\frac{1-z+z}{1-z} = \\frac{1}{1-z} $$\n\n3.  **梯形法则**：\n    这是一个两阶段隐式方法，其 $A=\\begin{bmatrix}0  0 \\\\ \\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}$ 且 $b=\\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}^T$。\n    首先，我们计算 $(I - zA)^{-1}$：\n    $$ I - zA = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix} - z\\begin{bmatrix}0  0 \\\\ \\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix} = \\begin{bmatrix}1  0 \\\\ -z/2  1 - z/2\\end{bmatrix} $$\n    其逆矩阵为：\n    $$ (I - zA)^{-1} = \\frac{1}{1(1-z/2) - 0} \\begin{bmatrix}1 - z/2  0 \\\\ z/2  1\\end{bmatrix} = \\frac{1}{1 - z/2} \\begin{bmatrix}1 - z/2  0 \\\\ z/2  1\\end{bmatrix} $$\n    现在我们将此结果代入 $R(z)$ 的公式中：\n    $$ R(z) = 1 + z \\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix} \\frac{1}{1-z/2} \\begin{bmatrix}1-z/2  0 \\\\ z/2  1\\end{bmatrix} \\begin{bmatrix}1 \\\\ 1\\end{bmatrix} $$\n    $$ R(z) = 1 + \\frac{z}{1-z/2} \\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix} \\begin{bmatrix}1-z/2 \\\\ 1+z/2\\end{bmatrix} = 1 + \\frac{z}{1-z/2} \\left( \\frac{1}{2}(1-z/2) + \\frac{1}{2}(1+z/2) \\right) $$\n    $$ R(z) = 1 + \\frac{z}{1-z/2} (1) = \\frac{1-z/2+z}{1-z/2} = \\frac{1+z/2}{1-z/2} $$\n\n数值实验设计如下：\n\n1.  **稳定性函数实现**：创建一个通用函数，该函数接收 $A$ 和 $b$，并返回相应的稳定性函数 $R(z)$。此函数计算 $R(z) = 1 + z \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1}$，并被向量化以对 $z$ 值的数组进行操作。\n\n2.  **网格生成**：在实轴区间 $[-50, 0]$ 上为 $z$ 生成一个包含 $5001$ 个复数值点的均匀网格。\n\n3.  **边界点计数**：为了找到 $|R(z)| = 1$ 的位置，我们在网格上分析函数 $g(z) = |R(z)| - 1$。我们使用一个有状态的算法来遍历网格，并计算“边界事件”的数量。如果遇到一个连续的点区域，其中 $|g(z_i)| \\le 10^{-8}$（称为“击中”），或者在两个非击中点之间存在符号变化 $g(z_i)g(z_{i+1})  0$（称为“穿越”），则计为一个事件。这样可以防止重复计数。\n\n4.  **A-稳定性推断**：A-稳定性要求对于所有 $\\operatorname{Re}(z) \\le 0$ 都满足 $|R(z)| \\le 1$。我们的实验提供了一个仅限于负实轴的经验性测试。我们在网格 $z \\in [-50, 0]$ 上计算 $\\max(|R(z)|)$，并检查这个最大值是否小于或等于 $1$（允许 $10^{-8}$ 的小容差）。结果是一个布尔值。\n\n5.  **L-稳定性推断**：L-稳定性要求方法是 A-稳定的，并且满足 $\\lim_{|z|\\to\\infty,\\,\\operatorname{Re}(z)0} R(z)=0$。我们通过在量级很大的负实数值 $z=-1000$ 处评估 $|R(z)|$ 来经验性地测试这第二个条件。如果根据上一步推断该方法是 A-稳定的，并且 $|R(-1000)|  0.01$，我们就推断它是 L-稳定的。结果是一个布尔值。\n\n将此程序应用于三种方法中的每一种，并汇编结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and analyzes the stability functions for three Runge-Kutta methods.\n    \"\"\"\n\n    def get_stability_function(A, b):\n        \"\"\"\n        Constructs the stability function R(z) for a given Butcher tableau.\n        \n        Args:\n            A (np.ndarray): The A matrix of the Butcher tableau.\n            b (np.ndarray): The b vector of the Butcher tableau.\n\n        Returns:\n            A function that computes R(z) for a scalar or vector z.\n        \"\"\"\n        s = A.shape[0]\n        I = np.identity(s)\n        ones_s = np.ones((s, 1))\n        b_T = b.reshape(1, -1)\n\n        def R(z):\n            \"\"\"The stability function R(z).\"\"\"\n            # Vectorized implementation\n            if not np.isscalar(z):\n                z = np.asarray(z, dtype=np.complex128)\n                results = np.zeros_like(z, dtype=np.complex128)\n                for i, z_val in enumerate(z):\n                    if z_val == 0:\n                        results[i] = 1.0 + 0.0j\n                        continue\n                    try:\n                        mat_inv = np.linalg.inv(I - z_val * A)\n                        r_val = 1.0 + z_val * b_T @ mat_inv @ ones_s\n                        results[i] = r_val.item()\n                    except np.linalg.LinAlgError:\n                        results[i] = np.inf + 0.0j\n                return results\n\n            # Scalar implementation\n            z = complex(z)\n            if z == 0:\n                return 1.0 + 0.0j\n            try:\n                mat_inv = np.linalg.inv(I - z * A)\n                r_val = 1.0 + z * b_T @ mat_inv @ ones_s\n                return r_val.item()\n            except np.linalg.LinAlgError:\n                return np.inf + 0.0j\n        \n        return R\n\n    # Define the Butcher tableaus for the methods in the test suite.\n    test_cases = [\n        {\n            \"name\": \"Explicit (Forward) Euler\",\n            \"A\": np.array([[0.0]]),\n            \"b\": np.array([1.0]),\n        },\n        {\n            \"name\": \"Implicit (Backward) Euler\",\n            \"A\": np.array([[1.0]]),\n            \"b\": np.array([1.0]),\n        },\n        {\n            \"name\": \"Trapezoidal Rule\",\n            \"A\": np.array([[0.0, 0.0], [0.5, 0.5]]),\n            \"b\": np.array([0.5, 0.5]),\n        },\n    ]\n\n    # Numerical parameters from the problem statement\n    z_min = -50.0\n    z_max = 0.0\n    num_points = 5001\n    tolerance = 1e-8\n    l_stability_z = -1000.0\n    l_stability_threshold = 0.01\n\n    z_grid = np.linspace(z_min, z_max, num_points)\n    \n    final_results = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        b = case[\"b\"]\n        \n        # 1. Construct the stability function R(z)\n        R = get_stability_function(A, b)\n        \n        # 2. Compute |R(z)| on the grid\n        abs_R = np.abs(R(z_grid))\n\n        # 3. Count real-axis boundary points where |R(z)| = 1\n        g = abs_R - 1.0\n        boundary_points_count = 0\n        in_hit_region = False\n        for i in range(len(g) - 1):\n            is_current_hit = np.abs(g[i]) = tolerance\n            if is_current_hit:\n                if not in_hit_region:\n                    boundary_points_count += 1\n                in_hit_region = True\n            else:\n                if in_hit_region:\n                    in_hit_region = False\n                \n                # Check for a crossing only if the next point is not the start of a new hit region.\n                # This prevents double counting a crossing that leads into a hit.\n                is_next_hit = np.abs(g[i+1]) = tolerance\n                if g[i] * g[i+1]  0 and not is_next_hit:\n                    boundary_points_count += 1\n        \n        # Check the last point for a hit\n        is_last_hit = np.abs(g[-1]) = tolerance\n        if is_last_hit and not in_hit_region:\n            boundary_points_count += 1\n\n        # 4. Infer A-stability on the negative real axis\n        # Allow for small floating point errors near the boundary\n        is_A_stable_real = np.all(abs_R = 1.0 + tolerance)\n        \n        # 5. Infer L-stability\n        abs_R_inf = np.abs(R(l_stability_z))\n        is_L_stable = is_A_stable_real and (abs_R_inf  l_stability_threshold)\n        \n        final_results.append([boundary_points_count, is_A_stable_real, is_L_stable])\n\n    # Format the final output string as specified.\n    # e.g., [[a1,a2,a3],[b1,b2,b3],[c1,c2,c3]]\n    # Python's bool `True`/`False` needs to be lowercase `true`/`false` for some environments.\n    # However, the example shows list of lists, which implies `str()` on bool is fine. `str(True)` is 'True'.\n    # If JSON is intended, it would be `true`. But the format is a string of Python lists.\n    # The problem asks for comma-separated list of items, so the Python `str` representation is correct.\n    \n    formatted_results = []\n    for res in final_results:\n        # str(True) -> \"True\", str(False) -> \"False\"\n        formatted_results.append(f\"[{res[0]},{str(res[1])},{str(res[2])}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了稳定性区域的形状后，下一个实际步骤是利用它来确定一个可行的步长。本练习要求您针对一个给定的线性系统 $y'=Ay$，计算显式龙格-库塔方法所允许的最大稳定时间步长 $\\Delta t$。您需要确保系统的所有特征值 $\\lambda_i$ 在经过步长缩放后（即 $z_i = \\Delta t \\lambda_i$），都落在该方法的稳定性区域内，这是一个在实践中选择步长时至关重要的核心技能。",
            "id": "3197733",
            "problem": "给定初值问题 $y'(t)=A_{\\text{sys}}\\,y(t)$，其中 $A_{\\text{sys}}$ 是一个复值矩阵，$y(t)$ 是一个复值向量函数。考虑使用定步长显式龙格-库塔方法对此系统进行积分，该方法由一个布彻表 (Butcher tableau) 描述。时间积分的稳定性取决于该方法在线性检验方程 $y'(t)=\\lambda\\,y(t)$（其中 $\\lambda\\in\\mathbb{C}$）上的表现。对于一个显式龙格-库塔方法，其稳定区域是满足对应标量放大因子 $\\lvert R(z)\\rvert\\leq 1$ 的 $z\\in\\mathbb{C}$ 的集合，其中 $z=\\Delta t\\,\\lambda$，$\\Delta t$ 是时间步长。如果一个方法的稳定区域包含整个左半平面 $\\{z\\in\\mathbb{C}:\\Re(z)\\leq 0\\}$，则称其为A-稳定的；如果其为A-稳定且额外满足当 $z$ 沿实轴趋向于 $-\\infty$ 时 $R(z)\\to 0$，则称其为L-稳定的。显式龙格-库塔方法不是A-稳定的，因此即使当 $\\Re(\\lambda)0$ 时，最大的稳定 $\\Delta t$ 通常也是有限的。\n\n从线性检验方程的基本原理和通过其布彻表定义的龙格-库塔方法出发，推导给定方法的稳定函数 $R(z)$，为 $A_{\\text{sys}}$ 的每个特征值 $\\lambda$ 证明稳定性判据 $\\lvert R(\\Delta t\\,\\lambda)\\rvert\\leq 1$ 的合理性，并构建一个数值搜索过程，该过程对于一个固定的龙格-库塔方法和给定的系统矩阵 $A_{\\text{sys}}$，找出最大的 $\\Delta t0$，使得所有缩放后的特征值 $z_i=\\Delta t\\,\\lambda_i$ 都位于稳定区域内，即对于 $A_{\\text{sys}}$ 的所有特征值 $\\lambda_i$，都有 $\\lvert R(z_i)\\rvert\\leq 1$。您的程序不能假定一个预先制表的稳定多项式；它必须直接从布彻表和应用于 $y'(t)=\\lambda\\,y(t)$ 的方法定义中获得 $R(z)$。\n\n使用经典的4阶显式龙格-库塔方法（常称为“RK4”），其布彻表如下：\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix},\\quad\nc=\\begin{bmatrix}\n0\\\\\n\\frac{1}{2}\\\\\n\\frac{1}{2}\\\\\n1\n\\end{bmatrix}.\n$$\n\n请设计您的程序，将此单一RK方法应用于以下每个测试矩阵 $A_{\\text{sys}}^{(k)}$，并为每个矩阵计算一个浮点数值：最大的 $\\Delta t$，使得稳定性条件 $\\lvert R(\\Delta t\\,\\lambda_i)\\rvert\\leq 1$ 对 $A_{\\text{sys}}^{(k)}$ 的所有特征值 $\\lambda_i$ 同时成立。搜索必须沿着复平面 $\\mathbb{C}$ 中 $\\Delta t\\geq 0$ 的射线 $z=\\Delta t\\,\\lambda_i$ 进行，并应返回满足约束的最大 $\\Delta t$。如果该约束仅在 $\\Delta t=0$ 时成立，您的程序在这种情况下必须返回 0.0。所有数值输出必须四舍五入到8位小数。\n\n测试集：\n- 情况1（一般负实数特征值）：\n$$\nA_{\\text{sys}}^{(1)}=\\begin{bmatrix}\n-2  0\\\\\n0  -5\n\\end{bmatrix}.\n$$\n- 情况2（正实数特征值）：\n$$\nA_{\\text{sys}}^{(2)}=\\begin{bmatrix}\n1  0\\\\\n0  \\frac{1}{2}\n\\end{bmatrix}.\n$$\n- 情况3（具有负实部的复共轭对）：\n$$\nA_{\\text{sys}}^{(3)}=\\begin{bmatrix}\n-1  -4\\\\\n1  -1\n\\end{bmatrix}.\n$$\n- 情况4（具有小阻尼的高振荡）：\n$$\nA_{\\text{sys}}^{(4)}=\\begin{bmatrix}\n-0.1  10\\\\\n-10  -0.1\n\\end{bmatrix}.\n$$\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含四个案例的结果，形式为方括号内由逗号分隔的列表，每个浮点数四舍五入到8位小数且无空格。例如，输出必须类似 $[d_1,d_2,d_3,d_4]$，其中每个 $d_k$ 是一个小数点后恰好有8位数字的十进制字符串。",
            "solution": "用户提供的问题已经过验证，并被确定为常微分方程数值分析领域中一个定义明确、具有科学依据的问题。所有必要信息均已提供，问题没有矛盾或含糊之处。我现在将着手提供完整解答。\n\n### 1. 显式龙格-库塔方法与稳定函数\n\n一个求解初值问题 $y'(t) = f(t, y(t))$ 的 $s$ 阶显式龙格-库塔（ERK）方法由以下方程定义：\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i k_i \\\\\nk_i = f\\left(t_n + c_i \\Delta t, y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\n系数 $a_{ij}$、$b_i$ 和 $c_i$ 由布彻表 (Butcher tableau) 给出，对于显式方法，其矩阵 $A = (a_{ij})$ 是一个严格下三角矩阵。\n\n为了分析该方法的稳定性，我们将其应用于达尔奎斯特检验方程 (Dahlquist test equation)，$y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$。在这种情况下，$f(t, y) = \\lambda y$。阶段值 $k_i$ 变为：\n$$\nk_i = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\n我们定义缩放时间步长 $z = \\Delta t \\lambda$。可以观察到，每个阶段向量 $k_i$ 必定与 $\\lambda y_n$ 成比例。设 $k_i = K_i(z) \\lambda y_n$，其中 $K_i(z)$ 是某个关于 $z$ 的函数。将此代入阶段方程：\n$$\nK_i(z) \\lambda y_n = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} (K_j(z) \\lambda y_n)\\right)\n$$\n两边同除以 $\\lambda y_n$（假设 $\\lambda, y_n \\neq 0$），我们得到阶段多项式 $K_i(z)$ 的一个递推关系：\n$$\nK_i(z) = 1 + z \\sum_{j=1}^{i-1} a_{ij} K_j(z)\n$$\n其中 $K_1(z) = 1$，因为当 $i=1$ 时求和为空。由于 $A$ 是严格下三角矩阵，我们可以依次计算出每个 $K_i(z)$。$K_i(z)$ 是一个关于 $z$ 的 $i-1$ 次多项式。\n\n数值解按如下方式更新：\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i (K_i(z) \\lambda y_n) = y_n \\left(1 + z \\sum_{i=1}^s b_i K_i(z)\\right)\n$$\n括号中的项是放大因子，它将 $y_n$ 映射到 $y_{n+1}$。这就是稳定函数 $R(z)$：\n$$\nR(z) = 1 + z \\sum_{i=1}^s b_i K_i(z)\n$$\n对于一个 $s$ 阶ERK方法，$R(z)$ 是一个关于 $z$ 的至多 $s$ 次的多项式。\n\n### 2. 经典RK4方法的稳定函数\n\n问题给出了经典的4阶龙格-库塔方法（$s=4$）的布彻表：\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix}\n$$\n我们推导阶段多项式 $K_i(z)$：\n\\begin{align*}\nK_1(z) = 1 \\\\\nK_2(z) = 1 + z a_{21} K_1(z) = 1 + z \\left(\\frac{1}{2}\\right)(1) = 1 + \\frac{z}{2} \\\\\nK_3(z) = 1 + z (a_{31} K_1(z) + a_{32} K_2(z)) = 1 + z \\left(0 + \\frac{1}{2}\\left(1 + \\frac{z}{2}\\right)\\right) = 1 + \\frac{z}{2} + \\frac{z^2}{4} \\\\\nK_4(z) = 1 + z (a_{41} K_1 + a_{42} K_2 + a_{43} K_3) = 1 + z \\left(0 + 0 + 1\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right)\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\n\\end{align*}\n现在，我们构建稳定函数 $R(z)$：\n$$\nR(z) = 1 + z \\left( b_1 K_1(z) + b_2 K_2(z) + b_3 K_3(z) + b_4 K_4(z) \\right)\n$$\n代入 $b_i$ 的值和多项式 $K_i(z)$：\n$$\nR(z) = 1 + z \\left[ \\frac{1}{6}(1) + \\frac{1}{3}\\left(1+\\frac{z}{2}\\right) + \\frac{1}{3}\\left(1+\\frac{z}{2}+\\frac{z^2}{4}\\right) + \\frac{1}{6}\\left(1+z+\\frac{z^2}{2}+\\frac{z^3}{4}\\right) \\right]\n$$\n将括号内的项按 $z$ 的幂次合并：\n\\begin{itemize}\n    \\item 常数项：$\\frac{1}{6} + \\frac{1}{3} + \\frac{1}{3} + \\frac{1}{6} = 1$\n    \\item $z$ 的一次项：$\\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{6}(1) = \\frac{1}{6} + \\frac{1}{6} + \\frac{1}{6} = \\frac{1}{2}$\n    \\item $z$ 的二次项：$\\frac{1}{3}\\left(\\frac{1}{4}\\right) + \\frac{1}{6}\\left(\\frac{1}{2}\\right) = \\frac{1}{12} + \\frac{1}{12} = \\frac{1}{6}$\n    \\item $z$ 的三次项：$\\frac{1}{6}\\left(\\frac{1}{4}\\right) = \\frac{1}{24}$\n\\end{itemize}\n将括号中的表达式乘以 $z$ 再加上 $1$，我们得到：\n$$\nR(z) = 1 + z\\left(1 + \\frac{1}{2}z + \\frac{1}{6}z^2 + \\frac{1}{24}z^3\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} = \\sum_{k=0}^{4} \\frac{z^k}{k!}\n$$\n这是 $e^z$ 的泰勒级数展开式截断到4阶的结果。\n\n### 3. 线性系统的稳定性判据\n\n对于常微分方程组 $y'(t) = A_{\\text{sys}} y(t)$，假设 $A_{\\text{sys}}$ 是可对角化的，则存在一个可逆矩阵 $P$ 使得 $A_{\\text{sys}} = P \\Lambda P^{-1}$，其中 $\\Lambda$ 是由 $A_{\\text{sys}}$ 的特征值 $\\lambda_i$ 构成的对角矩阵。\n通过变量替换 $u(t) = P^{-1} y(t)$，系统解耦为一组独立的标量方程：$u_i'(t) = \\lambda_i u_i(t)$。\n将龙格-库塔方法应用于原系统 $y' = A_{\\text{sys}} y$ 等价于将相同的方法应用于这些标量方程中的每一个。变换后变量的更新规则是：\n$u_{i, n+1} = R(\\Delta t \\lambda_i) u_{i, n}$。\n为了使数值解 $y_n$ 在 $n \\to \\infty$ 时保持有界，所有分量 $u_{i,n}$ 都必须保持有界。这要求每个分量的放大因子模长不大于1：\n$$\n|R(\\Delta t \\lambda_i)| \\leq 1 \\quad \\text{for all eigenvalues } \\lambda_i \\text{ of } A_{\\text{sys}}\n$$\n这就是数值稳定性的条件。\n\n### 4. 最大稳定时间步长 $\\Delta t_{\\max}$ 的算法\n\n我们寻求满足所有特征值的稳定性条件的最大 $\\Delta t \\geq 0$。即 $\\Delta t_{\\max} = \\sup\\{\\Delta t \\geq 0 \\mid |R(\\Delta t \\lambda_i)| \\leq 1 \\text{ for all } i\\}$。\n\n算法如下：\n1.  计算矩阵 $A_{\\text{sys}}$ 的特征值集合 $\\{\\lambda_i\\}$。\n2.  对每个特征值 $\\lambda_i$：\n    a. 如果 $\\Re(\\lambda_i) > 0$，物理系统本身是不稳定的。数值方法对于任何 $\\Delta t > 0$ 也将不稳定，因为对于小的 $z=\\Delta t \\lambda_i$，有 $|R(z)| \\approx |1+z| = \\sqrt{(1+\\Delta t \\Re(\\lambda_i))^2 + (\\Delta t \\Im(\\lambda_i))^2} > 1$。因此，$\\Delta t_{\\max} = 0$。\n    b. 如果 $\\lambda_i=0$，$R(0)=1$，所以该特征值对 $\\Delta t$ 不施加任何限制。\n    c. 如果 $\\Re(\\lambda_i) \\leq 0$ 且 $\\lambda_i \\neq 0$，我们必须找到最小的正数 $\\Delta t_i^*$，使得 $|R(\\Delta t_i^* \\lambda_i)| = 1$。这个值代表了沿 $\\lambda_i$ 定义的射线方向上稳定区域的边界。\n3.  总体的最大稳定时间步长是这些单个极限中的最小值：$\\Delta t_{\\max} = \\min_{i} \\{\\Delta t_i^*\\}$。\n\n为了找到 $\\Delta t_i^*$，我们求解方程 $|R(\\Delta t \\lambda_i)| - 1 = 0$，以得到最小的正根 $\\Delta t$。这是一个非线性方程，我们可以用数值方法求解。一个稳健的方法是首先为根划定区间，然后使用像布伦特方法 (Brent's method) 这样的求根算法。\n-   **划定区间**：对于一个给定的 $\\Re(\\lambda_i) \\le 0$ 的特征值 $\\lambda_i$，函数 $h(\\Delta t) = |R(\\Delta t \\lambda_i)| - 1$ 对于小的 $\\Delta t>0$ 是非正的。由于任何显式RK方法的稳定区域都是有界的，我们可以通过从一个猜测值开始并增加它（例如，通过倍增）直到条件满足，来找到一个上界 $b$ 使得 $h(b) > 0$。这样就提供了一个包含根的区间 $[a, b]$。\n-   **求根**：在将根划定在 $[a, b]$ 区间后，`scipy.optimize.brentq` 可以高效地找到 $\\Delta t_i^*$ 的精确值。\n\n实现将按照推导从布彻表计算 $R(z)$，然后对每个测试矩阵执行此数值搜索。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the maximum stable time step for the classical RK4 method\n    for several linear systems.\n    \"\"\"\n    # Butcher tableau for the classical 4-stage Runge-Kutta method (RK4)\n    A_rk4 = np.array([\n        [0.0, 0.0, 0.0, 0.0],\n        [0.5, 0.0, 0.0, 0.0],\n        [0.0, 0.5, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 0.0]\n    ], dtype=float)\n    b_rk4 = np.array([1/6, 1/3, 1/3, 1/6], dtype=float)\n\n    # Test suite of system matrices A_sys\n    test_cases = [\n        # Case 1: general negative real eigenvalues\n        np.array([[-2.0, 0.0], [0.0, -5.0]], dtype=float),\n        # Case 2: positive real eigenvalues\n        np.array([[1.0, 0.0], [0.0, 0.5]], dtype=float),\n        # Case 3: complex-conjugate pair with negative real part\n        np.array([[-1.0, -4.0], [1.0, -1.0]], dtype=float),\n        # Case 4: highly oscillatory with small damping\n        np.array([[-0.1, 10.0], [-10.0, -0.1]], dtype=float)\n    ]\n\n    results = []\n    for A_sys in test_cases:\n        max_dt = find_max_dt(A_sys, A_rk4, b_rk4)\n        results.append(f\"{max_dt:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_R_from_tableau(z, A, b):\n    \"\"\"\n    Computes the value of the stability function R(z) for a given z\n    and a Runge-Kutta method specified by its Butcher tableau (A, b).\n    \"\"\"\n    s = len(b)\n    K = np.zeros(s, dtype=np.complex128)\n    for i in range(s):\n        # K_i(z) = 1 + z * sum(a[i,j] * K_j(z) for j  i)\n        stage_sum = np.dot(A[i, :i], K[:i])\n        K[i] = 1.0 + z * stage_sum\n    \n    # R(z) = 1 + z * sum(b_i * K_i(z))\n    return 1.0 + z * np.dot(b, K)\n\ndef find_max_dt(A_sys, butcher_A, butcher_b):\n    \"\"\"\n    Finds the maximum stable time step dt for a system y'(t) = A_sys*y(t)\n    using the stability function derived from the provided Butcher tableau.\n    \"\"\"\n    try:\n        eigenvalues = np.linalg.eigvals(A_sys)\n    except np.linalg.LinAlgError:\n        return 0.0\n\n    # If any eigenvalue has a positive real part, the system is unstable,\n    # and the time integration will be unstable for any dt > 0.\n    if any(lam.real > 1e-9 for lam in eigenvalues):\n        return 0.0\n        \n    min_dt_root = float('inf')\n    \n    for lam in eigenvalues:\n        if abs(lam)  1e-9:  # An eigenvalue of 0 imposes no stability constraint.\n            continue\n\n        def h(dt):\n            \"\"\"Target function for root finding: |R(dt*lam)| - 1.\"\"\"\n            z = dt * lam\n            R_val = compute_R_from_tableau(z, butcher_A, butcher_b)\n            return abs(R_val) - 1.0\n\n        # Search for the smallest positive root of h(dt) = 0.\n        # This determines the stability limit for this eigenvalue.\n        \n        # Step 1: Bracket the root. Find an interval [a, b] such that\n        # h(a) = 0 and h(b) > 0.\n        # For stable/neutral eigenvalues, h(dt) = 0 for small dt > 0.\n        a = 1e-9 # Small positive number to start the search interval.\n        b = 1e-3 # Initial guess for the upper bound.\n        \n        # Exponentially increase b until h(b) > 0.\n        while h(b) = 0:\n            b *= 2.0\n            if b > 1e6: # Safety break to avoid infinite loops\n                b = float('inf')\n                break\n        \n        if b == float('inf'):\n            # This eigenvalue does not seem to impose a stability constraint\n            # within a reasonable range. This shouldn't happen for explicit methods.\n            continue\n            \n        a = b / 2.0\n        if a == 0: a = 1e-9\n\n        # Step 2: Use Brent's method to find the root within the bracketed interval.\n        try:\n            root = brentq(h, a, b)\n            min_dt_root = min(min_dt_root, root)\n        except ValueError:\n            # Should not happen with the bracketing logic above.\n            # If it does, it implies immediate instability for this eigenvalue.\n            min_dt_root = 0.0\n            break\n\n    if min_dt_root == float('inf'):\n        # This case would occur if all eigenvalues were zero.\n        # Any dt would be stable, so there's no finite maximum.\n        # The problem cases avoid this scenario. Returning 0.0 as a safe default.\n        return 0.0\n        \n    return min_dt_root\n\nsolve()\n```"
        }
    ]
}