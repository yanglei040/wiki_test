{
    "hands_on_practices": [
        {
            "introduction": "将理论知识转化为实践能力的第一步，是掌握求解常微分方程边值问题的基本方法。有限差分法通过将连续的微分方程转化为离散的代数方程组，为数值求解提供了一条直观而强大的路径。在本练习中，我们将使用“人造解”方法——一种在科学计算中用于验证代码正确性的核心技术——来构建一个具有已知精确解的问题，并一步步实现有限差分求解器。",
            "id": "3104017",
            "problem": "考虑以下在区间 $[0,1]$ 上的一个常微分方程（ODE）的线性两点边值问题（BVP）的构造解基准问题。其精确解指定为 $u(x)=e^{x}-x$，狄利克雷边界条件为 $u(0)=1$ 和 $u(1)=e-1$。您的任务如下：\n\n1) 推导一个线性常系数二阶常微分方程，其右端项为多项式，使得精确解 $u(x)=e^{x}-x$ 满足该常微分方程和边界条件。从一阶和二阶导数的定义出发，计算 $u'(x)$ 和 $u''(x)$，以构造一个形如 $u''(x)-u(x)=g(x)$ 的常微分方程，然后确定使 $u(x)$ 成为精确解的 $g(x)$。\n\n2) 在均匀网格 $x_{i}=ih$（其中 $i\\in\\{0,1,\\dots,N+1\\}$，$N$ 为内部点数量，$h=1/(N+1)$）上离散化所得的边值问题。使用从泰勒展开推导出的二阶导数中心差分近似，为未知数 $\\{u_{1},u_{2},\\dots,u_{N}\\}$ 建立相应的三对角线性系统，并施加边界条件 $u_{0}=1$ 和 $u_{N+1}=e-1$。\n\n3) 实现一个完整、可运行的程序，该程序：\n- 对测试集 $N\\in\\{1,10,20,40\\}$ 中的每个 $N$，构建并求解三对角线性系统。\n- 重构包含边界值的网格函数，并与精确解 $u(x)=e^{x}-x$ 比较，计算所有网格点 $x_{i}$（$i\\in\\{0,1,\\dots,N+1\\}$）上的最大绝对误差。\n- 对每个 $N$，报告最大绝对误差，结果为一个四舍五入到八位小数的浮点数。\n\n您可以使用的基础知识：\n- 一阶导数 $u'(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-u(x)}{h}$ 和二阶导数 $u''(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-2u(x)+u(x-h)}{h^{2}}$ 的定义。\n- 足够光滑的函数在点 $x$ 处的泰勒展开。\n- 用于求解线性系统的标准线性代数知识。\n\n科学真实性要求：\n- 纯粹在数学层面进行，不涉及物理单位。\n- 不涉及角度和百分比。\n\n测试集和输出规范：\n- 使用测试集 $N\\in\\{1,10,20,40\\}$。\n- 对每个 $N$，计算包括端点在内的完整网格上的最大绝对误差。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按测试集 $N$ 值的顺序排列。每个条目必须四舍五入到八位小数。例如，一个包含三个假设结果的输出应如下所示：[$r_{1},$ $r_{2},$ $r_{3}$]，其中每个 $r_{k}$ 是一个四舍五入到八位小数的十进制数。\n- 程序必须是自包含的，且无需用户输入。",
            "solution": "用户提供的问题是数值分析中一个定义明确的练习，具体而言是有限差分法在两点边值问题（BVP）中的应用。该问题是有效的，因为它在数学上是合理的、自包含的且客观的。它基于微积分和数值方法的既定原理。所有提供的数据，包括构造解和边界条件，都是一致的。\n$u(x) = e^x - x$\n$u(0) = e^0 - 0 = 1$\n$u(1) = e^1 - 1 = e-1$\n边界条件陈述正确。问题将按要求分三部分解决。\n\n### 第一部分：边值问题的推导\n\n问题要求推导一个形如 $u''(x) - u(x) = g(x)$ 的线性常系数二阶常微分方程，其精确解为 $u(x) = e^x - x$。\n\n首先，我们计算给定解 $u(x)$ 的一阶和二阶导数。\n精确解为：\n$$u(x) = e^x - x$$\n\n一阶导数 $u'(x)$ 为：\n$$u'(x) = \\frac{d}{dx}(e^x - x) = e^x - 1$$\n\n二阶导数 $u''(x)$ 为：\n$$u''(x) = \\frac{d}{dx}(e^x - 1) = e^x$$\n\n现在，我们将 $u(x)$ 和 $u''(x)$ 代入指定形式的常微分方程 $u''(x) - u(x) = g(x)$，以求得右端函数 $g(x)$：\n$$g(x) = u''(x) - u(x) = (e^x) - (e^x - x)$$\n$$g(x) = e^x - e^x + x = x$$\n\n函数 $g(x) = x$ 是一个多项式，符合要求。因此，完整的边值问题是：\n$$\n\\begin{cases}\nu''(x) - u(x) = x,  x \\in [0, 1] \\\\\nu(0) = 1 \\\\\nu(1) = e - 1\n\\end{cases}\n$$\n\n### 第二部分：离散化与线性系统的构建\n\n接下来，我们使用有限差分法在均匀网格上离散化推导出的边值问题。定义域 $[0, 1]$ 被划分为 $N+1$ 个等宽子区间，宽度为 $h = 1/(N+1)$。网格点为 $x_i = ih$，其中 $i = 0, 1, \\dots, N+1$。解在这些网格点上的值表示为 $u_i = u(x_i)$。\n\n常微分方程 $u''(x) - u(x) = x$ 必须在每个内部网格点 $x_i$（其中 $i = 1, 2, \\dots, N$）上成立：\n$$u''(x_i) - u(x_i) = x_i$$\n\n我们使用二阶中心差分公式来近似二阶导数 $u''(x_i)$：\n$$u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$$\n\n将此近似代入常微分方程，得到关于未知内部值 $\\{u_1, u_2, \\dots, u_N\\}$ 的代数方程组：\n$$\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} - u_i = x_i, \\quad \\text{for } i = 1, 2, \\dots, N$$\n\n为构成一个线性系统，我们整理该方程，将包含未知数的项归到左侧：\n$$u_{i-1} - 2u_i - h^2 u_i + u_{i+1} = h^2 x_i$$\n$$1 \\cdot u_{i-1} + (-2 - h^2)u_i + 1 \\cdot u_{i+1} = h^2 (ih) = ih^3$$\n\n这组 $N$ 个方程构成一个三对角线性系统 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$。\n\n这个 $N \\times N$ 矩阵 $A$ 具有以下结构：\n- 主对角线元素：$A_{ii} = -2 - h^2$\n- 次对角线元素：$A_{i, i-1} = 1$\n- 超对角线元素：$A_{i, i+1} = 1$\n\n$$A = \\begin{pmatrix}\n-2-h^2  & 1 & 0 & \\dots & 0 \\\\\n1 & -2-h^2 & 1 & \\dots & 0 \\\\\n0 & 1 & -2-h^2 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & 1 \\\\\n0 & \\dots & 0 & 1 & -2-h^2\n\\end{pmatrix}$$\n\n右端向量 $\\mathbf{b}$ 是一个 $N \\times 1$ 的列向量。我们必须计入给定的狄利克雷边界条件，$u_0 = 1$ 和 $u_{N+1} = e-1$。\n\n对于第一个方程（$i=1$）：\n$$u_0 + (-2 - h^2)u_1 + u_2 = 1 \\cdot h^3$$\n由于 $u_0 = 1$ 已知，我们将其移到右侧：\n$$(-2 - h^2)u_1 + u_2 = h^3 - u_0 = h^3 - 1$$\n因此，向量 $\\mathbf{b}$ 的第一个元素是 $b_1 = h^3 - 1$。\n\n对于最后一个方程（$i=N$）：\n$$u_{N-1} + (-2 - h^2)u_N + u_{N+1} = N h^3$$\n由于 $u_{N+1} = e-1$ 已知，我们将其移到右侧：\n$$u_{N-1} + (-2 - h^2)u_N = Nh^3 - u_{N+1} = Nh^3 - (e-1)$$\n因此，向量 $\\mathbf{b}$ 的最后一个元素是 $b_N = Nh^3 - e + 1$。\n\n对于一般的内部方程（$i=2, \\dots, N-1$）：\n$$u_{i-1} + (-2-h^2)u_i + u_{i+1} = ih^3$$\n$\\mathbf{b}$ 的相应元素是 $b_i = ih^3$。\n\n总之，右端向量 $\\mathbf{b} = [b_1, b_2, \\dots, b_N]^T$ 为：\n$$b_i = \\begin{cases}\nh^3 - 1 & \\text{当 } i=1 \\text{ 时} \\\\\nih^3 & \\text{当 } 2 \\le i \\le N-1 \\text{ 时} \\\\\nNh^3 - (e-1) & \\text{当 } i=N \\text{ 时}\n\\end{cases}$$\n对于 $N=1$ 的特殊情况，第一个和最后一个方程的条件同时适用于 $b_1$。因此，$b_1 = (ih^3)|_{i=1} - u_0 - u_{N+1} = h^3 - 1 - (e-1) = h^3 - e$。这与单个方程 $(-2 - h^2)u_1 = h^3 - u_0 - u_2$ (其中 $u_2 = u_{N+1}$) 的右侧项一致。\n\n### 第三部分：实现算法\n\n对于测试集 $\\{1, 10, 20, 40\\}$ 中的每个 $N$ 值，实现将执行以下步骤：\n1.  **初始化参数**：计算步长 $h = 1/(N+1)$ 和 $e$ 的值。\n2.  **构建线性系统**：\n    -   以适用于高效求解器（例如 `scipy.linalg.solve_banded`）的带状格式创建三对角矩阵 $A$。这需要创建一个 $3 \\times N$ 的数组，其中各行分别代表超对角线、主对角线和次对角线。\n    -   根据第二部分推导的公式构造大小为 $N$ 的右端向量 $\\mathbf{b}$。\n3.  **求解系统**：求解线性系统 $A\\mathbf{u} = \\mathbf{b}$，得到内部解向量 $\\mathbf{u} = [u_1, \\dots, u_N]^T$。\n4.  **重构完整解**：组装包含边界值的完整数值解向量：$U_{num} = [u_0, u_1, \\dots, u_N, u_{N+1}] = [1, \\mathbf{u}^T, e-1]^T$。\n5.  **计算精确解**：创建网格点向量 $X = [x_0, x_1, \\dots, x_{N+1}]$，其中 $x_i = ih$。在每个网格点上计算精确解 $u(x) = e^x - x$ 的值，得到向量 $U_{exact}$。\n6.  **计算误差**：计算数值解与精确解在所有网格点上的最大绝对误差：$E_{max} = \\max_{i \\in \\{0, \\dots, N+1\\}} |U_{num, i} - U_{exact, i}|$。\n7.  **存储并格式化结果**：将计算出的最大误差四舍五入到八位小数并存储。处理完所有 $N$ 值后，将收集到的结果格式化为指定的字符串格式。\n\n此过程将按要求封装在一个使用 `numpy` 和 `scipy` 库的 Python 程序中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the BVP u''(x) - u(x) = x on [0,1] with u(0)=1, u(1)=e-1\n    using a finite difference scheme for a given set of N values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10, 20, 40]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Initialize Parameters\n        # N: number of interior points\n        # There are N+2 total points (including boundaries)\n        h = 1.0 / (N + 1)\n        \n        # Exact boundary values\n        u0 = 1.0\n        uN_plus_1 = np.e - 1.0\n\n        # Step 2: Construct the tridiagonal linear system A*u = b\n        \n        # Construct the tridiagonal matrix A in banded format for SciPy.\n        # The format is a (3, N) array:\n        # Row 0: Super-diagonal (padded with a 0 at the start)\n        # Row 1: Main diagonal\n        # Row 2: Sub-diagonal (padded with a 0 at the end)\n        ab = np.zeros((3, N))\n        ab[0, 1:] = 1.0  # Super-diagonal\n        ab[1, :] = -2.0 - h**2  # Main diagonal\n        ab[2, :-1] = 1.0  # Sub-diagonal\n\n        # Construct the right-hand side vector b\n        # Start with the base value b_i = i * h^3\n        b = np.array([(i + 1) * h**3 for i in range(N)])\n        \n        # Incorporate boundary conditions\n        b[0] -= u0\n        b[-1] -= uN_plus_1\n        \n        # Step 3: Solve the system for the interior points u\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Step 4: Reconstruct the full numerical solution grid function\n        u_numerical = np.concatenate(([u0], u_interior, [uN_plus_1]))\n\n        # Step 5: Compute the exact solution at grid points\n        # Grid points x_i = i*h for i = 0, ..., N+1\n        x = np.linspace(0, 1, N + 2)\n        u_exact = np.exp(x) - x\n\n        # Step 6: Calculate the maximum absolute error\n        # The error at the boundaries is zero by construction (up to float precision)\n        max_error = np.max(np.abs(u_numerical - u_exact))\n        \n        # Add the rounded result to the list\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to eight decimal places.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了处理狄利克雷（Dirichlet）边界条件后，我们自然会遇到更复杂的情况，例如涉及导数值的诺伊曼（Neumann）边界条件。本练习将引导你学习如何使用“幽灵点法”来优雅地处理这类边界，同时保持数值格式的二阶精度。此外，你还将学习如何通过数值实验来验证方法的收敛阶，这是衡量和确保数值算法可靠性的基石。",
            "id": "3211343",
            "problem": "你的任务是为一个带有 Neumann 边界条件的一维常微分方程边值问题设计并实现一个二阶有限差分求解器。数学模型是线性 Poisson 方程\n$$\nu''(x) = f(x), \\quad x \\in [0,1],\n$$\n其在左端点具有 Neumann 边界条件，在右端点具有 Dirichlet 边界条件：\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\n你必须使用一个将区间 $[0,1]$ 进行 $m$ 等分的均匀网格，网格点为 $x_i = i h$，其中 $h = 1/m$ 且 $i = 0,1,\\dots,m$。你的数值方法必须：\n- 在内部节点处，使用标准的二阶中心差分来近似二阶导数。\n- 在 $x=0$ 处使用“虚拟点”方法实现 Neumann 条件，从而使边界上的导数能通过中心差分来近似，并通过引用常微分方程 $u''(x)=f(x)$ 和适当的 Taylor 展开来消除该虚拟点，以保持二阶精度。设计必须从基本定义（网格、Taylor 展开和常微分方程）出发，并避免使用特设公式。\n- 在 $x=1$ 处，以在最后一个内部节点上保持二阶精度的方式来引入 Dirichlet 边界条件。\n\n你的程序必须求解离散线性系统以获得内部未知数 $u(x_i)$（其中 $i=1,2,\\dots,m-1$），然后计算在内部网格点 $\\{x_i\\}_{i=1}^{m-1}$ 上相对于精确解析解的最大绝对误差。\n\n为了进行验证，通过对 $u''(x)=f(x)$ 进行两次积分并利用边界条件确定积分常数，来推导精确解析解。对于下方的每个测试用例，程序必须计算：\n- 使用你在 $x=0$ 处采用虚拟点处理的二阶格式计算出的内部网格点上的数值解。\n- 相同内部网格点上的精确解。\n- 内部点上的最大绝对误差（点态误差向量的无穷范数），表示为一个实数。\n\n此外，对于收敛性评估测试，需要计算由下式定义的观测精度阶 $p$\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right),\n$$\n其中 $E_{h}$ 和 $E_{h/2}$ 分别是使用 $m$ 和 $2m$ 个子区间的网格所对应的最大绝对误差。\n\n使用以下测试套件：\n1. 正常情况：$f(x) = 2$，$\\alpha = 1$，$\\beta = 0$，$$m = 50$$。通过求解带有给定边界条件的 $u''(x)=2$ 来找到精确解。\n2. 边界条件主导的粗网格：$f(x) = 0$，$\\alpha = 0$，$\\beta = 1$，$$m = 4$$。精确解为常数。\n3. 振荡强迫项：$f(x) = -\\pi^2 \\sin(\\pi x)$，$\\alpha = 0$，$\\beta = 0$，$$m = 64$$。通过求解带有给定边界条件的 $u''(x) = -\\pi^2 \\sin(\\pi x)$ 来获得精确解。\n4. 收敛阶：$f(x) = x$，$\\alpha = 0$，$\\beta = 0$，使用两个网格 $m=20$ 和 $m=40$。计算如上定义的观测阶 $p$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容按上述测试套件的顺序排列。前三个条目必须是代表每个案例最大绝对误差的实数，最后一个条目必须是代表收敛性测试的观测阶的实数。例如，输出应类似于 $[e_1,e_2,e_3,p]$，其中每个 $e_i$ 和 $p$ 都是实数。",
            "solution": "用户提供的问题是有效的，因为它在科学上基于常微分方程数值方法的理论，在数学上是适定的，并且是使用客观、形式化的标准定义的。本文档为验证目的，提供了数值方法和解析解的完整推导。\n\n问题是在区间 $x \\in [0,1]$ 上求解一维 Poisson 方程，这是一个线性二阶常微分方程 (ODE)：\n$$\nu''(x) = f(x)\n$$\n其在 $x=0$ 处有 Neumann 边界条件，在 $x=1$ 处有 Dirichlet 边界条件：\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\n\n我们将构建一个二阶有限差分格式来近似该解。\n\n**1. 区域离散化**\n\n将区域 $[0,1]$ 离散化为一个有 $m$ 个子区间的均匀网格。网格间距为 $h = 1/m$。网格点定义为 $x_i = i h$，其中 $i = 0, 1, \\dots, m$。设 $U_i$ 为精确解 $u(x_i)$ 在网格点 $x_i$ 处的数值近似。$x=1$ 处的边界条件给出 $U_m = u(1) = \\beta$。待求解的值为 $U_0, U_1, \\dots, U_{m-1}$。\n\n**2. 内部点的有限差分近似**\n\n对于任何内部网格点 $x_i$（其中 $i = 1, 2, \\dots, m-1$），我们使用二阶中心差分公式来近似二阶导数 $u''(x_i)$。这由 $u(x_{i+1})$ 和 $u(x_{i-1})$ 在 $x_i$ 附近的 Taylor 级数展开式推导得出：\n$$\nu(x_{i+1}) = u(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n$$\nu(x_{i-1}) = u(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n将这两个展开式相加并整理得到 $u''(x_i)$：\n$$\nu''(x_i) = \\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + \\dots\n$$\n该近似具有二阶精度，局部截断误差为 $O(h^2)$。将 $u(x_i)$ 替换为 $U_i$，并根据常微分方程将 $u''(x_i)$ 替换为 $f(x_i)$，我们得到内部节点的离散方程：\n$$\n\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i), \\quad \\text{对于 } i = 1, 2, \\dots, m-1.\n$$\n\n**3. $x=0$ 处 Neumann 边界条件的离散化**\n\n该问题要求使用虚拟点来保持二阶精度。我们在 $x_{-1} = -h$ 处引入一个虚拟点。\n首先，我们在 $x_0 = 0$ 处使用二阶中心差分来近似导数 $u'(0) = \\alpha$：\n$$\nu'(0) = \\frac{u(x_1) - u(x_{-1})}{2h} + O(h^2) \\implies \\frac{U_1 - U_{-1}}{2h} = \\alpha\n$$\n这给出了虚拟值 $U_{-1}$ 的表达式：\n$$\nU_{-1} = U_1 - 2h\\alpha\n$$\n接下来，我们假设常微分方程 $u''(x) = f(x)$ 在边界点 $x_0=0$ 处也成立。我们对 $u''(0)$ 应用中心差分公式：\n$$\n\\frac{U_{-1} - 2U_0 + U_1}{h^2} = f(x_0)\n$$\n现在，我们将 $U_{-1}$ 的表达式代入此方程以消除虚拟点：\n$$\n\\frac{(U_1 - 2h\\alpha) - 2U_0 + U_1}{h^2} = f(x_0)\n$$\n化简此表达式得到节点 $i=0$ 的方程：\n$$\n\\frac{-2U_0 + 2U_1 - 2h\\alpha}{h^2} = f(x_0) \\implies -2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha\n$$\n该边界格式的局部截断误差为 $O(h)$，这足以保证整个方法的全局误差为 $O(h^2)$。\n\n**4. 线性系统的组装**\n\n我们得到了一个关于 $m$ 个未知数 $U_0, U_1, \\dots, U_{m-1}$ 的 $m$ 个线性方程组。设 $\\mathbf{U} = [U_0, U_1, \\dots, U_{m-1}]^T$ 为未知数向量。该系统可以写成 $A \\mathbf{U} = \\mathbf{b}$。\n\n方程组如下：\n- 对于 $i=0$：$-2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha$\n- 对于 $i=1, \\dots, m-2$：$U_{i-1} - 2U_i + U_{i+1} = h^2 f(x_i)$\n- 对于 $i=m-1$：$U_{m-2} - 2U_{m-1} + U_m = h^2 f(x_{m-1})$。由于 $U_m = \\beta$，该方程变为 $U_{m-2} - 2U_{m-1} = h^2 f(x_{m-1}) - \\beta$。\n\n$m \\times m$ 的系数矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n-2 & 2 & 0 & \\cdots & \\cdots & 0 \\\\\n1 & -2 & 1 & \\ddots &  & \\vdots \\\\\n0 & 1 & -2 & 1 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots &  & \\ddots & 1 & -2 & 1 \\\\\n0 & \\cdots & \\cdots & 0 & 1 & -2\n\\end{pmatrix}\n$$\n大小为 $m$ 的右端向量 $\\mathbf{b}$ 为：\n$$\n\\mathbf{b} = \\begin{pmatrix}\nh^2 f(x_0) + 2h\\alpha \\\\\nh^2 f(x_1) \\\\\n\\vdots \\\\\nh^2 f(x_{m-2}) \\\\\nh^2 f(x_{m-1}) - \\beta\n\\end{pmatrix}\n$$\n这个线性系统 $A \\mathbf{U} = \\mathbf{b}$ 是非奇异的，可以求解以得到数值解 $\\mathbf{U}$。\n\n**5. 误差计算与收敛阶**\n\n最大绝对误差 $E_h$ 是在内部网格点 $\\{x_i\\}_{i=1}^{m-1}$ 上计算的，其值为误差向量的无穷范数：\n$$\nE_h = \\max_{i=1,\\dots,m-1} |U_i - u(x_i)|\n$$\n对于一个二阶精度的方法，误差预计表现为 $E_h \\approx C h^2$，其中 $C$ 为某个常数。精度阶 $p$ 可以通过比较两种不同网格尺寸 $h$ 和 $h/2$ 的误差来数值观测。\n$$\nE_h \\approx C h^p \\quad \\text{和} \\quad E_{h/2} \\approx C (h/2)^p\n$$\n取其比值可得 $\\frac{E_h}{E_{h/2}} \\approx 2^p$。求解 $p$ 可得：\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right)\n$$\n\n**6. 测试用例的解析解**\n\n精确解 $u(x)$ 是通过对 $u''(x) = f(x)$ 进行两次积分，并应用边界条件 $u'(0) = \\alpha$ 和 $u(1) = \\beta$ 来确定积分常数而得到的。\n\n- **情况 1:** $f(x) = 2$, $\\alpha = 1$, $\\beta = 0$。\n$u'' = 2 \\implies u'(x) = 2x+C_1$。$u'(0)=C_1=1$。所以 $u'(x)=2x+1$。\n$u(x) = x^2+x+C_2$。$u(1)=1+1+C_2=0 \\implies C_2=-2$。\n$u(x) = x^2+x-2$。\n\n- **情况 2:** $f(x) = 0$, $\\alpha = 0$, $\\beta = 1$。\n$u'' = 0 \\implies u'(x) = C_1$。$u'(0)=C_1=0$。所以 $u'(x)=0$。\n$u(x) = C_2$。$u(1)=C_2=1$。\n$u(x) = 1$。\n\n- **情况 3:** $f(x) = -\\pi^2 \\sin(\\pi x)$, $\\alpha = 0$, $\\beta = 0$。\n$u''(x) = -\\pi^2 \\sin(\\pi x) \\implies u'(x) = \\pi \\cos(\\pi x)+C_1$。$u'(0)=\\pi+C_1=0 \\implies C_1=-\\pi$。\n$u'(x) = \\pi \\cos(\\pi x) - \\pi$。\n$u(x) = \\sin(\\pi x) - \\pi x + C_2$。$u(1)=\\sin(\\pi)-\\pi+C_2=0 \\implies C_2=\\pi$。\n$u(x) = \\sin(\\pi x) - \\pi x + \\pi$。\n\n- **情况 4:** $f(x) = x$, $\\alpha = 0$, $\\beta = 0$。\n$u''(x) = x \\implies u'(x) = x^2/2+C_1$。$u'(0)=C_1=0$。所以 $u'(x)=x^2/2$。\n$u(x) = x^3/6+C_2$。$u(1)=1/6+C_2=0 \\implies C_2=-1/6$。\n$u(x) = \\frac{x^3}{6} - \\frac{1}{6}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the finite difference solver.\n    \"\"\"\n\n    def run_solver(f, alpha, beta, m):\n        \"\"\"\n        Solves u''(x) = f(x) with u'(0)=alpha, u(1)=beta on a grid with m subdivisions.\n        \n        Args:\n            f (callable): The forcing function f(x).\n            alpha (float): The Neumann boundary condition value at x=0.\n            beta (float): The Dirichlet boundary condition value at x=1.\n            m (int): The number of grid subdivisions.\n            \n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: Grid points for the interior, x_1, ..., x_{m-1}.\n                - np.ndarray: Numerical solution at the interior points, U_1, ..., U_{m-1}.\n        \"\"\"\n        # Grid setup\n        h = 1.0 / m\n        # We solve for unknowns at x_0, x_1, ..., x_{m-1}\n        x_nodes = np.linspace(0, 1, m + 1)\n        \n        # Assemble the m x m matrix A\n        A = np.zeros((m, m))\n        \n        # Fill diagonals for the standard interior stencil (1, -2, 1)\n        np.fill_diagonal(A, -2.0)\n        # Lower diagonal (k=-1): A[i, i-1] = 1 for i=1,...,m-1\n        np.fill_diagonal(A[1:], 1.0)\n        # Upper diagonal (k=1): A[i, i+1] = 1 for i=0,...,m-2\n        np.fill_diagonal(A[:, 1:], 1.0)\n        \n        # Modify the first row for the Neumann condition: -2*U_0 + 2*U_1 = ...\n        A[0, 1] = 2.0\n        \n        # Assemble the right-hand side vector b of size m\n        # We evaluate f at x_0, ..., x_{m-1}\n        b = h**2 * f(x_nodes[0:m])\n        \n        # Modify first and last elements of b for boundary conditions\n        # b_0 = h^2*f(x_0) + 2*h*alpha\n        b[0] += 2.0 * h * alpha\n        # b_{m-1} = h^2*f(x_{m-1}) - beta\n        b[m-1] -= beta\n        \n        # Solve the linear system A*U = b for U = [U_0, ..., U_{m-1}]\n        U = np.linalg.solve(A, b)\n        \n        # Return interior grid points and corresponding solution values\n        return x_nodes[1:m], U[1:]\n\n    results = []\n\n    # Test Case 1: Happy path\n    f1 = lambda x: 2.0 * np.ones_like(x)\n    u_exact1 = lambda x: x**2 + x - 2.0\n    alpha1, beta1, m1 = 1.0, 0.0, 50\n    x_interior1, U_interior1 = run_solver(f1, alpha1, beta1, m1)\n    u_exact_vals1 = u_exact1(x_interior1)\n    error1 = np.max(np.abs(U_interior1 - u_exact_vals1))\n    results.append(error1)\n\n    # Test Case 2: Boundary-condition-dominant coarse grid\n    f2 = lambda x: np.zeros_like(x)\n    u_exact2 = lambda x: np.ones_like(x)\n    alpha2, beta2, m2 = 0.0, 1.0, 4\n    x_interior2, U_interior2 = run_solver(f2, alpha2, beta2, m2)\n    u_exact_vals2 = u_exact2(x_interior2)\n    error2 = np.max(np.abs(U_interior2 - u_exact_vals2))\n    results.append(error2)\n\n    # Test Case 3: Oscillatory forcing\n    f3 = lambda x: -np.pi**2 * np.sin(np.pi * x)\n    u_exact3 = lambda x: np.sin(np.pi * x) - np.pi * x + np.pi\n    alpha3, beta3, m3 = 0.0, 0.0, 64\n    x_interior3, U_interior3 = run_solver(f3, alpha3, beta3, m3)\n    u_exact_vals3 = u_exact3(x_interior3)\n    error3 = np.max(np.abs(U_interior3 - u_exact_vals3))\n    results.append(error3)\n\n    # Test Case 4: Convergence order\n    f4 = lambda x: x\n    u_exact4 = lambda x: x**3 / 6.0 - 1.0 / 6.0\n    alpha4, beta4 = 0.0, 0.0\n    \n    # Solve on grid with m=20\n    m_h = 20\n    x_h, U_h = run_solver(f4, alpha4, beta4, m_h)\n    u_h = u_exact4(x_h)\n    E_h = np.max(np.abs(U_h - u_h))\n    \n    # Solve on grid with m=40\n    m_h2 = 40\n    x_h2, U_h2 = run_solver(f4, alpha4, beta4, m_h2)\n    u_h2 = u_exact4(x_h2)\n    E_h2 = np.max(np.abs(U_h2 - u_h2))\n    \n    order_p = np.log2(E_h / E_h2)\n    results.append(order_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管有限差分法非常强大，但对于某些在长区间上具有内在不稳定性的“刚性”边值问题，它可能会失效。本练习将介绍一种完全不同的策略——打靶法，及其更稳健的推广形式——多重打靶法。该技术将边值问题重新构建为一系列初值问题进行求解，对于解决物理和工程领域中许多具有挑战性的问题至关重要。",
            "id": "2377617",
            "problem": "考虑在区间 $[0,L]$ 上的标量场 $y(x)$ 的两点边值问题 (BVP)，该问题由以下线性常微分方程控制：\n$$\n\\frac{d^2 y}{dx^2} - k^2\\, y(x) = -1,\n$$\n其边界条件为\n$$\ny(0) = A,\\quad y(L) = B,\n$$\n其中 $k>0$、$L>0$ 和 $A,B\\in\\mathbb{R}$ 是给定常数。自变量 $x$ 是无量纲的，所有量也都是无量纲的。你的任务是编写一个完整的程序，求解下面列出的参数集的 BVP，并在每种情况下计算解在三个内部点 $x=L/4$、$x=L/2$ 和 $x=3L/4$ 处的值。\n\n所有计算都必须使用标准浮点运算完成。报告每种测试情况下 $y(L/4)$、$y(L/2)$ 和 $y(3L/4)$ 的值。\n\n参数集 $(k,L,A,B)$ 的测试套件：\n- 情况 1：$k=1$, $L=50$, $A=0$, $B=0$。\n- 情况 2：$k=0.5$, $L=80$, $A=0$, $B=1$。\n- 情况 3：$k=2$, $L=30$, $A=1$, $B=-1$。\n\n你的程序必须生成单行输出，其中包含九个结果，按测试用例排序，且在每个用例中，按三个评估点 $x=L/4$、$x=L/2$ 和 $x=3L/4$ 的顺序排列。最终输出格式必须是方括号括起来的单个逗号分隔列表。例如，输出必须如下所示\n$$\n[\\,\\text{y1\\_L4},\\text{y1\\_L2},\\text{y1\\_3L4},\\text{y2\\_L4},\\text{y2\\_L2},\\text{y2\\_3L4},\\text{y3\\_L4},\\text{y3\\_L2},\\text{y3\\_3L4}\\,],\n$$\n其中每个 $\\text{yX\\_Y}$ 是一个浮点数，对应于所需的计算值。不涉及单位，也不使用角度。",
            "solution": "我们从第一性原理开始。该两点边值问题 (BVP) 为\n$$\ny''(x) - k^2 y(x) = -1,\\qquad y(0)=A,\\quad y(L)=B,\n$$\n其中 $k>0$ 且 $L>0$。通过定义 $v(x)=y'(x)$ 和状态向量 $s(x) = \\begin{bmatrix} y(x) \\\\ v(x) \\end{bmatrix}$，引入一阶系统。该系统可以写成\n$$\n\\frac{d}{dx}\n\\begin{bmatrix}\ny \\\\ v\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 & 1\\\\\nk^2 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\ny \\\\ v\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n0 \\\\ -1\n\\end{bmatrix},\n$$\n即 $s'(x) = J s(x) + b$，其中常数雅可比矩阵 $J = \\begin{bmatrix} 0 & 1\\\\ k^2 & 0 \\end{bmatrix}$，常数非齐次项 $b = \\begin{bmatrix} 0 \\\\ -1 \\end{bmatrix}$。边界条件为 $y(0)=A$ 和 $y(L)=B$。\n\n为了在长区间 $[0,L]$ 上稳健地求解此 BVP，我们将区间划分为 $M$ 个子区间，节点为 $0=x_0 < x_1 < \\dots < x_M=L$。为简单起见，我们选择均匀步长 $h = L/M$。在每个子区间 $[x_i,x_{i+1}]$ 上，线性非齐次系统允许从初始状态 $s(x_i)$ 到终止状态 $s(x_{i+1})$ 的精确仿射映射：\n$$\ns(x_{i+1}) \\;=\\; \\Phi(h)\\, s(x_i) \\;+\\; \\eta(h),\n$$\n其中，使用双曲函数，基本转移矩阵 $\\Phi(h)$ 和非齐次增量 $\\eta(h)$ 为\n$$\n\\Phi(h) = \\begin{bmatrix}\n\\cosh(kh) & \\frac{1}{k}\\sinh(kh)\\\\\nk\\,\\sinh(kh) & \\cosh(kh)\n\\end{bmatrix},\\qquad\n\\eta(h) = \\begin{bmatrix}\n\\frac{1}{k^2}\\big(1 - \\cosh(kh)\\big)\\\\\n-\\frac{1}{k}\\sinh(kh)\n\\end{bmatrix}.\n$$\n这些表达式是通过在每个子区间上精确求解标量方程 $y''-k^2 y=-1$ 得出的：齐次解是 $\\cosh(kx)$ 和 $\\sinh(kx)$ 的线性组合，一个特解是 $y_p=1/k^2$。用 $y(x_i)$ 和 $v(x_i)$ 参数化通解，即可得到上述仿射映射。\n\n将未知量向量定义为所有子区间起点的初始状态列表，\n$$\nU = \\begin{bmatrix} s(x_0) \\\\ s(x_1) \\\\ \\vdots \\\\ s(x_{M-1}) \\end{bmatrix} \\in \\mathbb{R}^{2M}.\n$$\n我们通过构造一个残差向量 $g(U)\\in\\mathbb{R}^{2M}$ 来强制跨子区间的连续性并施加两个边界条件：\n- 对每个内部索引 $i=0,1,\\dots,M-2$，强制\n$$\ng_{2i:2i+2}(U) \\;=\\; s(x_{i+1}) \\;-\\; \\big(\\Phi(h)\\,s(x_i) + \\eta(h)\\big) \\;=\\; \\mathbf{0}.\n$$\n- 通过以下方式强制左边界 $y(0)=A$\n$$\ng_{2(M-1)}(U) \\;=\\; e_y^\\top s(x_0) - A \\;=\\; 0,\\qquad e_y = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}.\n$$\n- 使用最后一个子区间的终止值强制右边界 $y(L)=B$\n$$\ng_{2(M-1)+1}(U) \\;=\\; e_y^\\top\\Big(\\Phi(h)\\,s(x_{M-1}) + \\eta(h)\\Big) - B \\;=\\; 0.\n$$\n这产生一个维数为 $2M$ 的方形线性系统 $g(U)=0$。其关于 $U$ 的雅可比矩阵是块双对角矩阵，并为边界条件增加了两行：\n- 对于索引 $i$ 处的每个内部约束，其偏导数为\n$$\n\\frac{\\partial g_{2i:2i+2}}{\\partial s(x_i)} \\;=\\; -\\Phi(h),\\qquad \\frac{\\partial g_{2i:2i+2}}{\\partial s(x_{i+1})} \\;=\\; I_2,\n$$\n在其他地方为零。\n- 对于左边界行，关于 $s(x_0)$ 的导数是 $[1\\;\\;0]$，在其他地方为零。\n- 对于右边界行，关于 $s(x_{M-1})$ 的导数是 $e_y^\\top \\Phi(h)$，在其他地方为零。\n\n由于基础微分方程是线性的且系数恒定，因此 $g(U)$ 相对于 $U$ 是仿射的，而其雅可比矩阵是常数。因此，应用于 $g(U)=0$ 的 Newton 法从任何初始猜测开始，在单次迭代中即可收敛。我们求解线性系统\n$$\nJ\\,\\Delta U \\;=\\; -g(U),\n$$\n更新 $U \\leftarrow U + \\Delta U$，并在子区间起点获得连续解的精确离散表示。要在任何内部点 $x\\in[x_i,x_{i+1}]$ 处评估解，使用相同的仿射映射，并附带局部偏移量 $\\delta = x - x_i$：\n$$\ns(x) \\;=\\; \\Phi(\\delta)\\, s(x_i) \\;+\\; \\eta(\\delta),\\qquad y(x) = e_y^\\top s(x).\n$$\n\n为保证在长区间上的数值稳健性，选择子区间的数量 $M$，使得步长 $h$ 满足 $kh \\le 1$ 和 $h\\le 1/2$，例如通过取\n$$\nh = \\min\\!\\left(\\frac{1}{2},\\,\\frac{1}{k}\\right),\\qquad M = \\left\\lceil \\frac{L}{h} \\right\\rceil,\\qquad h = \\frac{L}{M}.\n$$\n这可以使 $\\Phi(h)$ 和 $\\eta(h)$ 的条目保持良好的尺度，并避免双曲函数中的溢出。在为每个测试用例组装并求解线性系统后，通过在适当的子区间内评估仿射映射来计算 $y(L/4)$、$y(L/2)$ 和 $y(3L/4)$。\n\n最后，按照问题陈述中指定的顺序，生成包含九个浮点值的单行输出。",
            "answer": "```python\nimport numpy as np\n\ndef phi_eta(k: float, h: float):\n    \"\"\"Return (Phi, eta) for the linear system s' = J s + b over step h,\n    where J = [[0,1],[k^2,0]] and b = [0,-1].\"\"\"\n    kh = k * h\n    c = np.cosh(kh)\n    s = np.sinh(kh)\n    # Transition matrix Phi(h)\n    Phi = np.array([[c, s / k],\n                    [k * s, c]], dtype=float)\n    # Inhomogeneous increment eta(h)\n    eta = np.array([ (1.0 / (k**2)) * (1.0 - c),\n                    -(1.0 / k) * s ], dtype=float)\n    return Phi, eta\n\ndef solve_bvp_multiple_shooting(k: float, L: float, A: float, B: float):\n    \"\"\"Solve y'' - k^2 y = -1 on [0,L] with y(0)=A, y(L)=B via multiple shooting.\n    Returns a function y_of_x(x) that evaluates the solution.\"\"\"\n    # Choose step to keep kh = 1 and h = 0.5\n    h_cap = min(0.5, 1.0 / max(k, 1e-12))\n    M = int(np.ceil(L / h_cap))\n    if M  1:\n        M = 1\n    h = L / M\n\n    # Precompute Phi and eta for the uniform segment length h\n    Phi_seg, eta_seg = phi_eta(k, h)\n\n    # Unknown vector U stacks s_i = [y_i, v_i] for i=0..M-1\n    n = 2 * M\n    U = np.zeros(n, dtype=float)\n\n    # Assemble Jacobian J (2M x 2M) and residual g (2M)\n    # For a linear problem, J is constant; build once.\n    J = np.zeros((n, n), dtype=float)\n\n    # Continuity constraints for i=0..M-2\n    I2 = np.eye(2)\n    for i in range(M - 1):\n        row = 2 * i\n        col_i = 2 * i\n        col_ip1 = 2 * (i + 1)\n        # Derivative wrt s_i: -Phi\n        J[row:row+2, col_i:col_i+2] = -Phi_seg\n        # Derivative wrt s_{i+1}: +I\n        J[row:row+2, col_ip1:col_ip1+2] = I2\n\n    # Left boundary row index and right boundary row index\n    lb_row = 2 * (M - 1)\n    rb_row = lb_row + 1\n\n    # Left boundary derivative wrt s_0: [1, 0]\n    J[lb_row, 0] = 1.0\n    J[lb_row, 1] = 0.0\n\n    # Right boundary derivative wrt s_{M-1}: e_y^T Phi(h) => first row of Phi\n    J[rb_row, 2*(M-1):2*(M-1)+2] = Phi_seg[0, :]\n\n    # Newton iteration (one step suffices, but include a safeguard)\n    for _ in range(2):\n        g = np.zeros(n, dtype=float)\n        # Continuity residuals\n        for i in range(M - 1):\n            row = 2 * i\n            si = U[2*i:2*i+2]\n            sip1 = U[2*(i+1):2*(i+1)+2]\n            pred = Phi_seg @ si + eta_seg\n            g[row:row+2] = sip1 - pred\n\n        # Left boundary residual: y(0) - A = 0\n        g[lb_row] = U[0] - A\n\n        # Right boundary residual: y(L) - B = e_y^T (Phi * s_{M-1} + eta) - B\n        s_last = U[2*(M-1):2*(M-1)+2]\n        y_end = (Phi_seg @ s_last + eta_seg)[0]\n        g[rb_row] = y_end - B\n\n        # Solve linear system J * delta = -g\n        try:\n            delta = np.linalg.solve(J, -g)\n        except np.linalg.LinAlgError:\n            # In the unlikely event of singularity, abort update\n            break\n\n        U = U + delta\n\n        # Check convergence\n        if np.linalg.norm(delta, ord=np.inf)  1e-12:\n            break\n\n    # Build an evaluator for y(x)\n    def y_of_x(x: float) -> float:\n        # Clamp x to [0, L]\n        if x = 0.0:\n            return U[0]\n        if x >= L:\n            # y at L computed from last segment\n            s_last = U[2*(M-1):2*(M-1)+2]\n            return float((Phi_seg @ s_last + eta_seg)[0])\n        # Identify segment index and local offset\n        seg = int(np.floor(x / h))\n        # Ensure seg in [0, M-1)\n        if seg >= M:\n            seg = M - 1\n        x_i = seg * h\n        dx = x - x_i\n        Phi_dx, eta_dx = phi_eta(k, dx)\n        s_i = U[2*seg:2*seg+2]\n        yx = (Phi_dx @ s_i + eta_dx)[0]\n        return float(yx)\n\n    return y_of_x\n\ndef solve():\n    # Define the test cases: (k, L, A, B)\n    test_cases = [\n        (1.0, 50.0, 0.0, 0.0),   # Case 1\n        (0.5, 80.0, 0.0, 1.0),   # Case 2\n        (2.0, 30.0, 1.0, -1.0),  # Case 3\n    ]\n\n    results = []\n    for (k, L, A, B) in test_cases:\n        y_eval = solve_bvp_multiple_shooting(k, L, A, B)\n        # Evaluate at x = L/4, L/2, 3L/4\n        xs = [L * 0.25, L * 0.5, L * 0.75]\n        for x in xs:\n            results.append(y_eval(x))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}