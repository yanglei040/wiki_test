{
    "hands_on_practices": [
        {
            "introduction": "前缀和（扫描）是并行计算中的一个基本构件。理解并行程序的性能需要对底层的硬件和软件进行建模。本练习将对比共享内存（线程和屏障）和分布式内存（MPI和消息传递）两种模型，对它们的协调成本进行量化分析。这项练习旨在培养一项关键技能：为特定任务选择合适的并行工具。",
            "id": "3169829",
            "problem": "您正在研究对 $N$ 个双精度元素进行并行前缀和（扫描）计算，使用两种编程模型：一种是基于线程的共享内存实现，另一种是基于进程的消息传递接口（MPI）实现。假设结合操作为加法。您的目标是在一个简单的成本模型下，比较这两种实现的总工作量和关键路径长度（跨度），然后量化由不同协调模式产生的 $\\Theta(\\log_2 P)$ 跨度项中的常数因子差异。\n\n基本依据和假设：\n- 对 $N$ 个项目进行顺序扫描需要执行 $N-1$ 次加法。\n- 在分叉-连接模型中，工作量 $T_1$ 是所有处理单元执行的基本操作总数，而跨度 $T_{\\infty}$ 是最长相关操作链（即关键路径）的长度。\n- 一个具有 $P$ 个叶节点的平衡二叉树的高度为 $\\log_2 P$。\n\n两种实现及其成本模型：\n- 基于线程的共享内存实现：数据被划分为 $P$ 个连续的块，每个线程一个。各线程计算其块内的局部扫描，然后使用平衡树的上扫和下扫，对 $P$ 个块的总和进行线程间扫描，最后将每个块的偏移量加到其局部元素上。在关键路径上，每个树层级会产生一次延迟为 $b$ 的屏障和一次耗时为常数 $c$ 的局部合并成本。\n- 使用递归倍增的基于 MPI 的实现：每个进程首先对其块进行局部扫描，然后参与 $\\log_2 P$ 轮的点对点消息交换（递归倍增），以计算块总和的前缀。在关键路径上，每一轮都会产生一次消息延迟 $L$，一次传输 $s$ 字节有效载荷（一个部分和）的每字节传输时间 $g$，以及一次局部合并成本 $c$。\n\n在比较跨度时，请重点关注产生 $\\Theta(\\log_2 P)$ 项的协调部分。在计算比率时，您可以忽略两种模型中相同的局部块扫描和偏移量应用部分的贡献，因为这些贡献会相互抵消，并且不影响 $\\Theta(\\log_2 P)$ 协调项或其常数因子。\n\n给定参数：\n- 处理单元数量 $P = 1024$。\n- 线程屏障延迟 $b = 0.3$ 微秒。\n- 局部合并成本 $c = 0.01$ 微秒。\n- MPI 每消息延迟 $L = 4.8$ 微秒。\n- MPI 逆带宽 $g = 0.003$ 微秒/字节。\n- 有效载荷大小 $s = 8$ 字节。\n\n任务：\n1) 使用上述核心定义，以 $N$ 和 $P$ 为变量，符号化地描述每种实现的主导项工作量 $T_1$，并保留两者之间任何在 $P$ 上渐进不可忽略的差异性依赖关系。\n2) 在给定的成本模型下，为每种实现推导协调跨度 $T_{\\infty}$ 作为 $P$ 的函数的渐进形式和常数因子，并从第一性原理出发证明其 $\\Theta(\\log_2 P)$ 的依赖关系。\n3) 使用给定的数值参数，计算协调跨度的比率 $R$，\n$$\nR \\equiv \\frac{T_{\\infty}^{\\text{threads}}}{T_{\\infty}^{\\text{MPI}}}.\n$$\n将您的答案四舍五入到四位有效数字。以纯数字形式报告 R，不带单位。",
            "solution": "该问题要求分析两种并行前缀和实现，一种使用共享内存线程，另一种使用 MPI。分析内容包括确定每种实现的总工作量 ($T_1$) 和协调跨度 ($T_{\\infty}$)，然后对它们的协调跨度进行数值比较。\n\n### 任务 1：工作量 ($T_1$) 的描述\n\n工作量 $T_1$ 代表所有处理单元执行的加法总次数。输入包含 $N$ 个元素，被划分为 $P$ 个大小为 $N/P$ 的块。\n\n**1. 基于线程的共享内存实现：**\n该算法分三个阶段进行。我们计算每个阶段的工作量。\n- **局部扫描：** $P$ 个线程中的每一个都在其大小为 $N/P$ 的局部块上执行顺序前缀和。对 $k$ 个项目进行顺序扫描需要 $k-1$ 次加法。因此，一个线程的工作量是 $(N/P) - 1$。对于所有 $P$ 个线程，总工作量为 $W_{\\text{local}} = P \\left( \\frac{N}{P} - 1 \\right) = N - P$。\n- **线程间扫描：** 使用涉及上扫和下扫的平衡二叉树结构（Blelloch 扫描），对 $P$ 个块的总和（每个局部扫描的最后一个元素）执行并行扫描。使用此方法对 $P$ 个元素进行并行扫描的工作量是 $2(P-1)$ 次加法。所以，$W_{\\text{inter}} = 2(P-1)$。\n- **偏移量应用：** 从 $1$ 到 $P-1$ 的每个线程都将其对应的块总和前缀值加到其局部块中的所有 $N/P$ 个元素上。线程 $0$ 不需要偏移量。这导致 $(P-1)$ 个线程各自执行 $N/P$ 次加法。总工作量为 $W_{\\text{offset}} = (P-1)\\frac{N}{P} = N - \\frac{N}{P}$。\n\n基于线程的模型的总工作量 $T_{1}^{\\text{threads}}$ 是所有阶段工作量的总和：\n$$T_{1}^{\\text{threads}} = W_{\\text{local}} + W_{\\text{inter}} + W_{\\text{offset}}$$\n$$T_{1}^{\\text{threads}} = (N-P) + 2(P-1) + \\left(N - \\frac{N}{P}\\right)$$\n$$T_{1}^{\\text{threads}} = 2N + P - \\frac{N}{P} - 2$$\n\n**2. 基于 MPI 的实现：**\n该算法也分为三个阶段。\n- **局部扫描：** 此阶段与基于线程的模型相同。工作量为 $W_{\\text{local}} = N - P$。\n- **进程间扫描（递归倍增）：** 使用递归倍增算法计算 $P$ 个块总和的前缀和。这需要 $\\log_2 P$ 轮通信。在每一轮 $k$ 中（其中 $k$ 的范围从 $0$ 到 $\\log_2 P - 1$），进程 $i \\in [2^k, P-1]$ 接收一个部分和并执行一次加法。第 $k$ 轮的加法次数是 $P - 2^k$。总工作量是所有轮次的总和：\n$$W_{\\text{inter}} = \\sum_{k=0}^{\\log_2 P - 1} (P - 2^k) = P \\sum_{k=0}^{\\log_2 P - 1} 1 - \\sum_{k=0}^{\\log_2 P - 1} 2^k = P\\log_2 P - (2^{\\log_2 P} - 1) = P\\log_2 P - P + 1$$\n- **偏移量应用：** 此阶段与基于线程的模型相同。工作量为 $W_{\\text{offset}} = N - \\frac{N}{P}$。\n\n基于 MPI 的模型的总工作量 $T_{1}^{\\text{MPI}}$ 是：\n$$T_{1}^{\\text{MPI}} = W_{\\text{local}} + W_{\\text{inter}} + W_{\\text{offset}}$$\n$$T_{1}^{\\text{MPI}} = (N-P) + (P\\log_2 P - P + 1) + \\left(N - \\frac{N}{P}\\right)$$\n$$T_{1}^{\\text{MPI}} = 2N + P\\log_2 P - 2P - \\frac{N}{P} + 1$$\n\n### 任务 2：协调跨度 ($T_{\\infty}$) 的推导\n\n跨度 $T_{\\infty}$ 代表关键路径长度。我们被要求只分析协调部分。\n\n**1. 基于线程的协调跨度：**\n协调阶段包括在高度为 $\\log_2 P$ 的平衡二叉树上进行一次上扫和一次下扫。\n- **上扫：** 关键路径从一个叶节点到根节点，遍历 $\\log_2 P$ 个层级。每个层级都需要同步（延迟为 $b$ 的屏障），然后进行一次局部合并操作（成本为 $c$）。一个层级的跨度是 $b+c$。因此，上扫的跨度是 $(\\log_2 P)(b+c)$。\n- **下扫：** 关键路径从根节点到一个叶节点，同样遍历 $\\log_2 P$ 个层级。每个层级产生相同的成本 $b+c$。下扫的跨度也是 $(\\log_2 P)(b+c)$。\n\n总协调跨度 $T_{\\infty}^{\\text{threads}}$ 是这两个顺序阶段跨度的总和：\n$$T_{\\infty}^{\\text{threads}} = (\\log_2 P)(b+c) + (\\log_2 P)(b+c) = 2(b+c)\\log_2 P$$\n这具有所要求的 $\\Theta(\\log_2 P)$ 依赖关系，其理由是遍历了一个深度为 $\\log_2 P$ 的树两次，一次向上，一次向下。\n\n**2. 基于 MPI 的协调跨度：**\n协调阶段使用递归倍增，包括 $\\log_2 P$ 个顺序轮次。\n- **单轮跨度：** 在每一轮中，一个处于关键路径上的进程等待一条消息，接收它，然后执行一次局部合并。此操作的时间是消息延迟 $L$、传输时间 $g \\cdot s$（其中 $s$ 是有效载荷大小，$g$ 是逆带宽）以及局部合并成本 $c$ 的总和。因此，每轮的跨度是 $L+gs+c$。\n\n总协调跨度 $T_{\\infty}^{\\text{MPI}}$ 是每轮的跨度乘以轮数：\n$$T_{\\infty}^{\\text{MPI}} = (L+gs+c)\\log_2 P$$\n这具有所要求的 $\\Theta(\\log_2 P)$ 依赖关系，其理由是递归倍增算法固有的 $\\log_2 P$ 个顺序通信阶段。\n\n### 任务 3：比率 $R$ 的计算\n\n协调跨度的比率 $R$ 定义为：\n$$R = \\frac{T_{\\infty}^{\\text{threads}}}{T_{\\infty}^{\\text{MPI}}}$$\n代入任务 2 中推导出的表达式：\n$$R = \\frac{2(b+c)\\log_2 P}{(L+gs+c)\\log_2 P}$$\n$\\log_2 P$ 项相互抵消，得到：\n$$R = \\frac{2(b+c)}{L+gs+c}$$\n现在，我们代入给定的数值参数：\n- $b = 0.3 \\, \\mu s$\n- $c = 0.01 \\, \\mu s$\n- $L = 4.8 \\, \\mu s$\n- $g = 0.003 \\, \\mu s / \\text{字节}$\n- $s = 8 \\, \\text{字节}$\n\n分子是：\n$$2(b+c) = 2(0.3 + 0.01) = 2(0.31) = 0.62$$\n分母是：\n$$L+gs+c = 4.8 + (0.003 \\times 8) + 0.01 = 4.8 + 0.024 + 0.01 = 4.834$$\n比率 $R$ 是：\n$$R = \\frac{0.62}{4.834} \\approx 0.1282579644$$\n四舍五入到四位有效数字，我们得到：\n$$R \\approx 0.1283$$",
            "answer": "$$\\boxed{0.1283}$$"
        },
        {
            "introduction": "在比较了不同的并行模型之后，我们来尝试在单一模型内进行优化。在许多实际的循环中，每次迭代的工作量并非均等。本练习将探讨如何利用数学建模来解决动态调度中的一个基本权衡问题：小块（chunk）能改善负载均衡但会增加调度开销，而大块则相反。通过推导最优块大小，你将深入理解在像OpenMP这样的实用并行编程框架中进行性能调优的原理。",
            "id": "3169831",
            "problem": "考虑一个在 $P$ 个硬件线程上使用 Open Multi-Processing (OpenMP) 动态调度执行的共享内存循环。该循环有 $N$ 次迭代，索引为 $i \\in \\{1,2,\\dots,N\\}$，每次迭代的计算时间建模为 $c(i)=a+bi$，其中 $a>0$ 和 $b\\geq 0$ 是常数。OpenMP 运行时使用固定的块大小 $s$（每个块的迭代次数）。每次块分配会产生 $\\delta$ 时间单位的调度开销；除了每次分块的这个成本外，没有其他开销或同步源。动态调度器在线程变为空闲时将块分配给它们。\n\n采用以下与动态调度和单调递增的单次迭代成本曲线相一致的科学合理建模假设：\n- 动态调度器消除了大部分负载不平衡，除了在循环末尾，由于块的不可分割性，导致在处理最后一个块时最多有 $P-1$ 个线程处于空闲状态。\n- 在此尾部阶段，每个空闲线程的平均空闲时间约等于一个代表性尾部块计算时间的一半。\n- 当 $s \\ll N$ 时，一个代表性尾部块的计算时间可以建模为块大小乘以接近 $i \\approx N$ 处的单次迭代成本。\n\n利用这些假设和第一性原理，构建一个总低效时间（定义为所有线程的总空闲时间加上总调度开销之和）的模型，该模型是块大小 $s$ 以及参数 $a$、$b$、$N$、$P$ 和 $\\delta$ 的函数。然后，推导出使此低效时间最小化的实值块大小 $s^{\\ast}$。\n\n最后，对以下参数值计算您的表达式：$N=10{,}000$，$P=8$，$a=2$，$b=0.005$ 和 $\\delta=3$。报告最优的实值块大小 $s^{\\ast}$（单位为每次分块的迭代次数），并四舍五入到三位有效数字。在最终的数值答案中不要包含任何单位。",
            "solution": "该场景是一个采用 Open Multi-Processing (OpenMP) 动态调度的并行循环。根据定义，动态调度在线程可用时，将大小为 $s$ 次迭代的块分配给它们。每次分配会产生 $\\delta$ 时间单位的开销。执行的块总数为 $N/s$，假设 $s$ 能整除 $N$；为了建模和优化，我们可以将 $s$ 视为一个正实数变量，并连续地解释 $N/s$。\n\n基本建模步骤：\n1. 调度开销。由于每次块分配的成本为 $\\delta$，并且总共发出了 $N/s$ 个块，因此总调度开销为\n$$\nT_{\\text{overhead}}(s) = \\delta \\frac{N}{s}.\n$$\n\n2. 尾部空闲时间。对于动态调度和单调递增的单次迭代成本 $c(i)=a+bi$，主要的负载不平衡发生在循环的末尾，因为块是不可分割的。在最后的尾部阶段，当一个线程完成最后一个块时，最多可以有 $P-1$ 个线程处于空闲状态。对于具有不可分割粒度的任务，一个标准的排队和调度论证是，在尾部区间内，每个空闲线程的平均空闲时间大约是最后一个块计算时间的一半。因此，尾部所有线程的总空闲时间可以建模为\n$$\nT_{\\text{idle}}(s) \\approx \\frac{P-1}{2} \\, T_{\\text{chunk,tail}}(s).\n$$\n当 $s \\ll N$ 并且 $c(i)$ 在块内的变化缓慢时，一个代表性尾部块的计算时间可以近似为块大小乘以接近 $i \\approx N$ 处的单次迭代成本，即\n$$\nT_{\\text{chunk,tail}}(s) \\approx s \\big(a + bN\\big).\n$$\n结合这些，\n$$\nT_{\\text{idle}}(s) \\approx \\frac{P-1}{2} \\, s \\big(a + bN\\big).\n$$\n\n3. 总低效时间。将两部分贡献相加，\n$$\nL(s) = T_{\\text{idle}}(s) + T_{\\text{overhead}}(s) \\approx \\frac{P-1}{2} \\, s \\big(a + bN\\big) + \\delta \\frac{N}{s}.\n$$\n我们寻求使 $L(s)$ 最小化的实值块大小 $s>0$。\n\n通过微积分进行优化：\n计算关于 $s$ 的导数：\n$$\n\\frac{dL}{ds} = \\frac{P-1}{2} \\big(a + bN\\big) - \\delta \\frac{N}{s^{2}}.\n$$\n为求最优解，令 $\\frac{dL}{ds}=0$：\n$$\n\\frac{P-1}{2} \\big(a + bN\\big) = \\delta \\frac{N}{s^{2}}.\n$$\n求解 $s^{2}$：\n$$\ns^{2} = \\frac{\\delta N}{\\frac{P-1}{2} \\big(a + bN\\big)} = \\frac{2 \\delta N}{(P-1)\\big(a + bN\\big)}.\n$$\n因此，最优的实值块大小是\n$$\ns^{\\ast} = \\sqrt{\\frac{2 \\delta N}{(P-1)\\big(a + bN\\big)}}.\n$$\n\n数值计算：\n给定 $N=10{,}000$，$P=8$，$a=2$，$b=0.005$ 和 $\\delta=3$，\n- 计算 $a+bN$：\n$$\na + bN = 2 + 0.005 \\times 10{,}000 = 2 + 50 = 52.\n$$\n- 计算 $(P-1)\\big(a + bN\\big)$：\n$$\n(P-1)\\big(a + bN\\big) = 7 \\times 52 = 364.\n$$\n- 计算 $2 \\delta N$：\n$$\n2 \\delta N = 2 \\times 3 \\times 10{,}000 = 60{,}000.\n$$\n因此，\n$$\ns^{\\ast} = \\sqrt{\\frac{60{,}000}{364}} \\approx \\sqrt{164.8351648} \\approx 12.8411\\ldots\n$$\n四舍五入到三位有效数字，\n$$\ns^{\\ast} \\approx 12.8.\n$$\n\n这个 $s^{\\ast}$ 是模型下的一个实值最优解。它满足 $s \\ll N$ 的假设，因此与所使用的尾部块近似方法一致。",
            "answer": "$$\\boxed{12.8}$$"
        },
        {
            "introduction": "实现高性能通常需要避免使用锁，但无锁算法会引入新的挑战，例如活锁（livelock）——线程虽然在忙碌运行但却无法取得任何进展。本练习通过为一个无锁队列中的活锁场景建模，深入探讨了并发编程的核心问题。你将运用概率论来分析退避（backoff）策略如何缓解竞争，从而将抽象的竞争概念与具体、可量化的系统吞吐量指标联系起来。",
            "id": "3169794",
            "problem": "考虑一个基于指针链表实现的多生产者单消费者无锁队列。每个入队操作通过使用硬件原语“比较并交换”（CAS）来更新一个共享的尾指针，从而追加一个节点。CAS 的定义如下：比较并交换（CAS）接受一个内存地址和两个值，如果该内存地址的当前内容等于预期的旧值，则原子地将该内存地址赋为新值，并返回操作是否成功。假设在同一尾指针上，任何与其他 CAS 尝试在时间上重叠的 CAS 尝试都会因竞争而失败，并且成功的 CAS 更新完成一次入队操作。\n\n在高竞争环境下，构造一个最小活锁场景如下：两个分别标记为 $A$ 和 $B$ 的线程同时尝试入队。每个线程都读取当前的尾指针，准备好自己的新节点，并发出 CAS 操作以将尾指针更新到该节点。由于这些 CAS 操作重叠，两者都失败了。在没有任何退避或延迟的情况下，两个线程都立即重试，读取相同的尾指针，并再次几乎在同一时间发出 CAS 操作，从而反复失败。这种没有进展的重复相互干扰构成了活锁。\n\n为了缓解活锁，提出一种概率性退避策略：在一次 CAS 失败后，一个线程通过选择一个以离散时间槽为单位的随机延迟来推迟其下一次尝试，因此在任何给定的时间槽中，它都以独立的概率 $r$ 尝试 CAS。该概率 $r$ 可由退避策略调整，并能响应竞争而自适应变化。假设有 $N$ 个相同的生产者线程，时间被划分为均等的时间槽，并且每个时间槽内的尝试在线程间是独立的。\n\n将竞争概率 $p$ 定义为：在给定一个线程在某个时间槽中尝试 CAS 的条件下，至少有另一个线程也在同一时间槽中尝试 CAS 的概率（因此如果发生，会导致该次尝试的冲突）。在独立性和相同尝试概率的假设下，每个线程的尝试概率 $r$ 和竞争概率 $p$ 之间存在固定的关系。\n\n仅从上述定义和独立伯努利试验的标准概率定律出发，推导每个时间槽的预期入队吞吐量 $T(p)$ 作为 $p$ 和 $N$ 的函数的闭式解析表达式。将您的最终答案表示为单个简化的符号表达式。不要提供任何数值近似或四舍五入。",
            "solution": "目标是推导每个时间槽的预期入队吞吐量 $T$，即每个时间槽中成功入队操作的期望数量。\n\n根据问题描述，当且仅当在一个给定的时间槽中恰好有一个线程尝试 CAS 操作时，才会发生一次成功的入队。如果没有线程尝试，则没有入队。如果有两个或更多线程尝试，它们的 CAS 操作会发生冲突，并且全部失败，导致没有入队。\n\n设 $r$ 为单个线程在给定时间槽中尝试 CAS 的概率。我们有 $N$ 个相同且独立的线程。设 $K$ 为代表在给定时间槽中尝试 CAS 的线程数量的随机变量。由于每个线程的尝试都是成功概率为 $r$ 的独立伯努利试验，因此总尝试次数 $K$ 服从参数为 $N$ 和 $r$ 的二项分布。\n$K$ 的概率质量函数由下式给出：\n$$P(K=k) = \\binom{N}{k} r^k (1-r)^{N-k}$$\n对于 $k \\in \\{0, 1, \\dots, N\\}$。\n\n吞吐量 $T$ 是成功入队的期望数量。只有当 $K=1$ 时才会成功。因此，预期吞吐量是：\n$$T = 1 \\cdot P(K=1) + 0 \\cdot P(K \\neq 1) = P(K=1)$$\n将 $k=1$ 代入二项概率质量函数，我们将吞吐量表示为 $r$ 和 $N$ 的函数：\n$$T(r) = \\binom{N}{1} r^1 (1-r)^{N-1} = N r (1-r)^{N-1}$$\n\n问题要求将吞吐量 $T$ 表示为竞争概率 $p$ 和 $N$ 的函数。因此，我们必须建立 $r$ 和 $p$ 之间的关系。\n\n竞争概率 $p$ 被定义为“在给定一个线程在某个时间槽中尝试 CAS 的条件下，至少有另一个线程也在同一时间槽中尝试 CAS 的概率”。\n\n让我们考虑一个特定的线程，比如线程 $i$。条件事件是“$A_i$：线程 $i$ 尝试 CAS”。我们关心的事件是“$C_i$：其他 $N-1$ 个线程中至少有一个尝试 CAS”。\n因此，根据定义，$p = P(C_i | A_i)$。\n由于各线程的尝试是独立的，事件 $A_i$ 不提供关于其他 $N-1$ 个线程行为的任何信息。因此，条件概率等于无条件概率：\n$$p = P(C_i | A_i) = P(C_i)$$\n事件 $C_i$ 是指其他 $N-1$ 个线程中至少有一个尝试 CAS。计算其补事件 $\\neg C_i$ 的概率会更简单，即其他 $N-1$ 个线程中没有一个尝试 CAS。\n这 $N-1$ 个线程中的每一个都以概率 $r$ 尝试，以概率 $1-r$ 不尝试。其中单个线程不尝试的概率是 $1-r$。由于它们都是独立的，它们中没有一个尝试的概率是：\n$$P(\\neg C_i) = (1-r)^{N-1}$$\n于是概率 $p$ 为：\n$$p = P(C_i) = 1 - P(\\neg C_i) = 1 - (1-r)^{N-1}$$\n这就提供了 $p$ 和 $r$ 之间所需的关系。先验假设 $N \\ge 2$（由“多生产者”和活锁场景所暗示）确保了 $N-1 \\ge 1$，从而使此表达式定义良好。\n\n现在我们可以用 $p$ 和 $N$ 来表示 $T$。我们有两个方程：\n$$1) \\quad T = N r (1-r)^{N-1}$$\n$$2) \\quad p = 1 - (1-r)^{N-1}$$\n\n从方程 (2)，我们可以直接用 $p$ 来表示项 $(1-r)^{N-1}$：\n$$(1-r)^{N-1} = 1-p$$\n接下来，我们从方程 (2) 中解出 $r$。\n$$(1-r)^{N-1} = 1-p$$\n$$1-r = (1-p)^{\\frac{1}{N-1}}$$\n$$r = 1 - (1-p)^{\\frac{1}{N-1}}$$\n\n现在，我们将 $r$ 和 $(1-r)^{N-1}$ 的这些表达式代回到 $T$ 的方程中：\n$$T(p) = N \\cdot r \\cdot (1-r)^{N-1} = N \\left( 1 - (1-p)^{\\frac{1}{N-1}} \\right) (1-p)$$\n\n这就是每个时间槽的预期吞吐量 $T(p)$ 作为竞争概率 $p$ 和线程数 $N$ 的函数的闭式解析表达式。该表达式已按要求进行了简化。",
            "answer": "$$\\boxed{N(1-p)\\left(1 - (1-p)^{\\frac{1}{N-1}}\\right)}$$"
        }
    ]
}