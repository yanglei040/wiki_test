{
    "hands_on_practices": [
        {
            "introduction": "当我们从连续的仿真过程中收集数据时，我们选择的采样率至关重要。如果信号的固有频率相对于我们的采样率过高，就会发生一种称为“混叠”的现象，高频信号会伪装成低频信号。这个实践练习  将指导您完成一个计算实验，亲眼见证对快速振荡信号进行欠采样（即采样率过低）如何产生一个具有误导性的自相关函数（ACF），使我们误认为系统的动态特性比其实际情况要慢得多。",
            "id": "3098943",
            "problem": "您将实现一个完整的、可运行的程序，以演示对快速振荡信号进行欠采样如何导致混叠，而混叠又会产生一个误导性的自相关函数（ACF），表明存在较慢的动态过程。请完全在纯数学和算法的环境中进行操作。\n\n一个连续时间标量信号定义为 $x(t) = \\sin\\!\\big(2\\pi f_0 t + \\varphi\\big)$，其中 $f_0$ 是频率，单位为赫兹（Hz，即周/秒），$\\varphi$ 是一个固定的相位，单位为弧度。该信号以均匀采样间隔 $\\Delta t$ 进行采样，形成离散序列 $x_n = x(n\\,\\Delta t)$，其中整数 $n \\in \\{0,1,\\dots,N-1\\}$。定义样本均值 $\\mu = \\frac{1}{N}\\sum_{n=0}^{N-1} x_n$。对于整数延迟 $k \\in \\{0,1,\\dots,N-1\\}$，归一化的、有限长度的、单边样本自相关函数（ACF）定义为\n$$\nr[k] \\;=\\; \\frac{\\sum_{n=0}^{N-1-k}\\big(x_n - \\mu\\big)\\big(x_{n+k} - \\mu\\big)}{\\sum_{n=0}^{N-1}\\big(x_n - \\mu\\big)^2}.\n$$\n请注意，根据构造，$r[0] = 1$。对于纯正弦输入，ACF所揭示的主导时间尺度可以估计为第一个非零延迟的正局部最大值处的时间。换句话说，定义 $k^\\star$ 为满足 $r[k] > 0$、$r[k] \\ge r[k-1]$ 和 $r[k] \\ge r[k+1]$ 的最小整数 $k \\ge 1$。然后定义估计的主导时间尺度\n$$\n\\tau_{\\mathrm{est}} \\;=\\; k^\\star \\,\\Delta t \\quad \\text{(in seconds)}.\n$$\n\n您的任务是编写一个程序，针对下面测试套件中的每一组参数，构造 $x_n$，计算 $k \\ge 0$ 时的 $r[k]$，按描述找到 $k^\\star$，并返回以秒为单位的 $\\tau_{\\mathrm{est}}$。其目的是观察当采样频率 $f_s = 1/\\Delta t$ 相对于 $f_0$ 过低时，会发生混叠，并且ACF会指示一个较慢的表观动态，即 $\\tau_{\\mathrm{est}}$ 大于真实周期 $T_0 = 1/f_0$。\n\n您可以依赖的基本原理：均匀采样 $x_n = x(n\\,\\Delta t)$ 的定义、上面给出的归一化样本ACF的定义，以及一个经过广泛检验的事实，即如果采样频率 $f_s = 1/\\Delta t$ 不超过最高信号频率的两倍，采样后的离散时间正弦波将编码一个在区间 $[0, f_s/2]$ 内的混叠频率，ACF会反映这个频率。\n\n测试套件（每个案例指定 $(f_0, \\Delta t, N, \\varphi)$）：\n- 案例 1（良好采样，正常路径）：$f_0 = 3.0$ Hz，$\\Delta t = 0.01$ s， $N = 1024$，$\\varphi = 0.3$ rad。\n- 案例 2（欠采样，混叠导致表观动态变慢）：$f_0 = 45.0$ Hz，$\\Delta t = 0.02$ s，$N = 1024$，$\\varphi = 0.2$ rad。\n- 案例 3（奈奎斯特边界行为，使用相位避免简并情况）：$f_0 = 25.0$ Hz，$\\Delta t = 0.02$ s，$N = 1024$，$\\varphi = \\pi/2$ rad。\n\n程序要求：\n- 对于每个案例，严格按照 $x_n = \\sin\\!\\big(2\\pi f_0 n \\Delta t + \\varphi\\big)$ 为 $n \\in \\{0,\\dots,N-1\\}$ 生成 $x_n$。\n- 严格按照上述定义计算 $k \\in \\{0,\\dots,N-1\\}$ 的 $r[k]$。\n- 确定 $k^\\star$ 为满足 $r[k] > 0$、$r[k] \\ge r[k-1]$ 和 $r[k] \\ge r[k+1]$ 的最小 $k \\ge 1$；如果不存在这样的 $k$，则使用使 $r[k]$ 最大化的 $k \\ge 1$。\n- 为每个案例返回 $\\tau_{\\mathrm{est}} = k^\\star \\Delta t$，以秒为单位，四舍五入到6位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的三个 $\\tau_{\\mathrm{est}}$ 值，且不含空格（例如，$[0.123456,0.234567,0.345678]$）。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它具有科学依据，定义明确，客观且内部一致。提供了唯一解所需的所有必要参数和定义。任务是实现一个算法，演示混叠对采样正弦信号的自相关函数的影响。\n\n对于每个测试案例，解决方案分四个主要步骤进行：\n1.  生成离散时间信号 $x_n$。\n2.  计算归一化样本自相关函数 (ACF) $r[k]$。\n3.  确定特征延迟 $k^\\star$。\n4.  计算估计的主导时间尺度 $\\tau_{\\mathrm{est}}$。\n\n我们考虑一个给定的测试案例，其参数为 $(f_0, \\Delta t, N, \\varphi)$。\n\n**步骤 1：信号生成**\n连续时间信号由 $x(t) = \\sin(2\\pi f_0 t + \\varphi)$ 给出。我们以均匀间隔 $\\Delta t$ 对该信号进行采样，以生成长度为 $N$ 的离散时间序列 $x_n$。时间点为 $t_n = n \\Delta t$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。因此，离散信号为：\n$$\nx_n = x(t_n) = \\sin(2\\pi f_0 n \\Delta t + \\varphi)\n$$\n为所有 $n$ 从 $0$ 到 $N-1$ 生成此序列。\n\n**步骤 2：自相关函数 (ACF) 计算**\n问题为归一化样本ACF $r[k]$ 提供了一个特定公式。计算需要几个子步骤。\n\n首先，我们计算信号 $x_n$ 的样本均值 $\\mu$：\n$$\n\\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} x_n\n$$\n接下来，我们通过减去均值来中心化信号：$x'_n = x_n - \\mu$。\n\nACF的分母是中心化信号的平方和，它对应于延迟 $k=0$ 时的自协方差，并作为归一化因子。\n$$\nS = \\sum_{n=0}^{N-1} (x_n - \\mu)^2 = \\sum_{n=0}^{N-1} (x'_n)^2\n$$\n分子是在给定整数延迟 $k$ 时的未归一化自协方差，其中 $k \\in \\{0, 1, \\dots, N-1\\}$：\n$$\nC[k] = \\sum_{n=0}^{N-1-k} (x_n - \\mu)(x_{n+k} - \\mu) = \\sum_{n=0}^{N-1-k} x'_n x'_{n+k}\n$$\n最后，归一化样本ACF $r[k]$ 是延迟 $k$ 时的自协方差与归一化因子 $S$ 的比值：\n$$\nr[k] = \\frac{C[k]}{S} = \\frac{\\sum_{n=0}^{N-1-k} (x_n - \\mu)(x_{n+k} - \\mu)}{\\sum_{n=0}^{N-1} (x_n - \\mu)^2}\n$$\n请注意，当 $k=0$ 时，分子变为 $\\sum_{n=0}^{N-1} (x_n - \\mu)^2$，与分母 $S$ 相同，从而确保了如陈述中所述的 $r[0] = 1$。需要为 $k \\in \\{0, 1, \\dots, N-1\\}$ 计算整个函数 $r[k]$。\n\n**步骤 3：确定特征延迟 ($k^\\star$)**\n特征延迟 $k^\\star$ 用于估计ACF所揭示的信号中的主导周期。它被定义为代表正局部最大值的最小整数延迟 $k \\ge 1$。条件是：\n1.  $k \\ge 1$\n2.  $r[k] > 0$\n3.  $r[k] \\ge r[k-1]$\n4.  $r[k] \\ge r[k+1]$\n\n为了找到 $k^\\star$，我们从 $1$ 开始向上迭代 $k$ 直到 $N-2$（以确保 $r[k+1]$ 可访问）。第一个满足所有三个条件的 $k$ 值被选为 $k^\\star$。\n\n如果搜索完成仍未找到这样的 $k$，则应用备用规则：选择使 $r[k]$ 值最大化的延迟 $k \\ge 1$ 作为 $k^\\star$。这通过在子数组 $r[1], r[2], \\dots, r[N-1]$ 中搜索最大值来找到。\n\n**步骤 4：计算估计的时间尺度 ($\\tau_{\\mathrm{est}}$)**\n一旦确定了 $k^\\star$，就通过将延迟从样本单位转换回时间单位（秒）来计算估计的主导时间尺度 $\\tau_{\\mathrm{est}}$：\n$$\n\\tau_{\\mathrm{est}} = k^\\star \\cdot \\Delta t\n$$\n为每个测试案例计算此值。\n\n**测试案例的概念性分析：**\n- **案例 1（良好采样）：** $f_0 = 3.0$ Hz，$\\Delta t = 0.01$ s。采样频率为 $f_s = 1/\\Delta t = 100$ Hz。奈奎斯特频率为 $f_s/2 = 50$ Hz。由于 $f_0 \\ll f_s/2$，信号被良好采样。真实周期为 $T_0 = 1/f_0 \\approx 0.3333$ s。我们期望 $\\tau_{\\mathrm{est}} \\approx T_0$。\n- **案例 2（欠采样）：** $f_0 = 45.0$ Hz，$\\Delta t = 0.02$ s。采样频率为 $f_s = 1/\\Delta t = 50$ Hz。奈奎斯特频率为 $f_s/2 = 25$ Hz。由于 $f_0 > f_s/2$，将会发生混叠。混叠频率为 $f_a = |f_0 - f_s| = |45 - 50| = 5.0$ Hz。表观周期为 $T_a = 1/f_a = 0.2$ s。我们期望ACF反映这种混叠动态，因此 $\\tau_{\\mathrm{est}} \\approx T_a$。\n- **案例 3（奈奎斯特边界）：** $f_0 = 25.0$ Hz，$\\Delta t = 0.02$ s。此处，$f_0$ 正好是奈奎斯特频率。采样信号将是 $x_n = \\sin(2\\pi \\cdot 25 \\cdot n \\cdot 0.02 + \\pi/2) = \\sin(n\\pi + \\pi/2) = \\cos(n\\pi)$，其结果为序列 $\\{1, -1, 1, -1, \\dots\\}$。信号在延迟 $k=1$ 时完全反相关，在延迟 $k=2$ 时完全相关。因此，ACF中的第一个正峰值应出现在 $k^\\star=2$ 处，从而得到 $\\tau_{\\mathrm{est}} = 2 \\cdot 0.02 = 0.04$ s，对应于 $1/0.04 = 25$ Hz 的表观频率。\n\n实现将精确地遵循这些步骤。",
            "answer": "```python\n# 完整的、可运行的 Python 3 代码如下。\n# 导入的库必须符合指定的执行环境。\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the estimated dominant time scale from the\n    autocorrelation function of a sampled sinusoidal signal for three test cases,\n    demonstrating the effect of aliasing.\n    \"\"\"\n    # Test suite (f0, dt, N, phi)\n    test_cases = [\n        (3.0, 0.01, 1024, 0.3),         # Case 1: Well-sampled\n        (45.0, 0.02, 1024, 0.2),        # Case 2: Undersampled (aliasing)\n        (25.0, 0.02, 1024, np.pi/2),   # Case 3: Nyquist boundary\n    ]\n\n    results = []\n    \n    for f0, dt, N, phi in test_cases:\n        # Step 1: Generate the discrete-time signal\n        n = np.arange(N)\n        t = n * dt\n        x = np.sin(2 * np.pi * f0 * t + phi)\n\n        # Step 2: Compute the Autocorrelation Function (ACF)\n        \n        # Center the signal by subtracting its mean\n        mu = np.mean(x)\n        x_centered = x - mu\n        \n        # The denominator is the sum of squared deviations, which is also\n        # the unnormalized autocorrelation at lag 0.\n        # Efficiently computed using np.dot or np.sum(x_centered**2)\n        denominator = np.dot(x_centered, x_centered)\n        \n        # Handle the edge case where the denominator is zero (e.g., a constant signal)\n        if denominator == 0:\n            # For a constant signal, ACF is ill-defined. We can set r to zeros.\n            # However, for a sine wave, this is not expected.\n            r = np.zeros(N)\n            r[0] = 1.0\n        else:\n            # The numerator is the autocovariance at each lag k.\n            # We will compute it manually as per the problem definition.\n            # r[k] = sum_{n=0}^{N-1-k} (x_n-mu)(x_{n+k}-mu) / sum_{n=0}^{N-1} (x_n-mu)^2\n            r = np.zeros(N)\n            for k in range(N):\n                numerator_k = np.dot(x_centered[:N-k], x_centered[k:])\n                r[k] = numerator_k / denominator\n        \n        # Step 3: Determine the characteristic lag k_star\n        k_star = -1  # Sentinel value indicating not found\n\n        # Search for the smallest k >= 1 that is a positive local maximum.\n        # Loop up to N-2 to allow checking r[k+1].\n        for k in range(1, N - 1):\n            is_positive = r[k] > 0\n            is_local_max = (r[k] >= r[k - 1]) and (r[k] >= r[k + 1])\n            \n            if is_positive and is_local_max:\n                k_star = k\n                break  # Found the smallest k, so we can stop.\n\n        # If no such k was found, apply the fallback rule.\n        if k_star == -1:\n            # Find the k >= 1 that globally maximizes r[k].\n            # We search in r[1:] because k must be >= 1.\n            # np.argmax returns the index relative to the sliced array r[1:].\n            # We add 1 to get the index relative to the original array r.\n            if N > 1:\n                k_star = np.argmax(r[1:]) + 1\n            else:\n                k_star = 0 # Should not happen with N=1024\n\n        # Step 4: Calculate the estimated dominant time scale\n        tau_est = k_star * dt\n        results.append(tau_est)\n\n    # Final print statement in the exact required format.\n    # We use a format specifier to ensure 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多仿真数据，特别是那些模拟自然或经济系统的模型，都包含了可预测的确定性模式，例如日度或年度周期，这被称为季节性。这种季节性结构会引入强烈的自相关性，但这种相关性可能会掩盖潜在的随机过程，因此可被视为“伪相关”。在这个练习  中，您将学习如何识别并使用一种强大的技术——季节性差分，来移除这种伪相关，这是将非平稳时间序列数据转换为平稳序列以进行进一步分析的关键步骤。",
            "id": "3098918",
            "problem": "您需要实现一个完整的、可运行的程序，以演示未移除的季节性如何在模拟数据中引出误导性的依赖关系，以及季节性差分如何减轻这种虚假的短滞后依赖性。请严格遵循核心定义。考虑一个离散时间序列 $\\{X_t\\}_{t=0}^{N-1}$，它由一个季节性确定性分量与加性噪声之和构成。季节性分量是一个已知周期的正弦波，而加性噪声是独立同分布的高斯噪声。请使用正弦函数，角度单位为弧度。\n\n基本原理和定义：\n- 离散时间序列是由整数时间 $t$ 索引的序列 $\\{X_t\\}$。\n- 当其不随时间变化且有良好定义时，滞后 $k$ 的总体自协方差为 $\\gamma(k) = \\mathrm{Cov}(X_t, X_{t+k})$。\n- 样本均值为 $\\bar{X} = \\frac{1}{N}\\sum_{t=0}^{N-1}X_t$。\n- 滞后 $k$ 的无偏样本自协方差估计量为\n$$\\hat{\\gamma}(k) = \\frac{1}{N-k} \\sum_{t=0}^{N-1-k} \\left(X_t - \\bar{X}\\right)\\left(X_{t+k} - \\bar{X}\\right), \\quad 0 \\le k \\le N-1.$$\n- 滞后 $k$ 的样本自相关函数（Autocorrelation Function (ACF)）为\n$$\\hat{\\rho}(k) = \\frac{\\hat{\\gamma}(k)}{\\hat{\\gamma}(0)}.$$\n\n季节性模型与差分：\n- 模拟序列为\n$$X_t = A \\sin\\!\\left(\\frac{2\\pi t}{s}\\right) + \\varepsilon_t,$$\n其中 $A$ 是振幅，$s$ 是以时间步长计量的季节周期，$\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 在时间 $t$ 上是独立的。\n- 周期为 $d$ 的季节性差分产生\n$$Y_t = X_t - X_{t-d}, \\quad t = d, d+1, \\dots, N-1.$$\n\n检测标准：\n- 对于每次模拟，计算原始序列 $\\{X_t\\}$ 和差分序列 $\\{Y_t\\}$ 的 $\\hat{\\rho}(1)$。\n- 在白噪声假设下，使用ACF的大样本高斯近似来定义一个双侧 $95\\%$ 置信界限：\n$$b_N = \\frac{1.96}{\\sqrt{N}},$$\n其中 $N$ 是计算ACF所用序列的样本大小。将 $\\left|\\hat{\\rho}(1)\\right| > b_N$ 视为在滞后 $1$ 处存在“统计上显著”的依赖性；否则视为不显著。\n- 当且仅当 $\\left|\\hat{\\rho}_{X}(1)\\right| > b_{N_X}$ 且 $\\left|\\hat{\\rho}_{Y}(1)\\right|  b_{N_Y}$ 时，判定“由季节性引起的虚假短滞后自相关已被移除”，其中 $N_X = N$ 是 $\\{X_t\\}$ 的长度，$N_Y = N - d$ 是 $\\{Y_t\\}$ 的长度。\n\n需要实现的任务：\n1. 对每个测试用例，使用上述模型及指定参数和固定的随机种子生成 $\\{X_t\\}$ 以确保可复现性，然后计算 $\\{X_t\\}$ 的 $\\hat{\\rho}(1)$。\n2. 使用指定的 $d$ 进行季节性差分得到 $\\{Y_t\\}$，然后计算 $\\{Y_t\\}$ 的 $\\hat{\\rho}(1)$。\n3. 计算边界 $b_{N_X}$ 和 $b_{N_Y}$。\n4. 对每个测试用例，根据检测标准输出一个布尔值，指示差分是否移除了虚假的短滞后自相关。\n\n角度单位：\n- 正弦函数中的所有角度均以弧度为单位。\n\n测试套件：\n- 每个元组为 $(N, s, A, \\sigma, d, \\text{seed})$。\n- 使用以下参数集：\n  - 案例 $1$（一般“理想路径”）：$(720, 24, 2.0, 0.5, 24, 2023)$。\n  - 案例 $2$（错误的差分周期）：$(720, 24, 2.0, 0.5, 12, 2023)$。\n  - 案例 $3$（无季节性；防止错误检测的边界情况）：$(720, 24, 0.0, 1.0, 24, 42)$。\n  - 案例 $4$（接近季节性尺度的小样本）：$(36, 24, 1.5, 0.1, 24, 7)$。\n  - 案例 $5$（季节性相对于噪声较弱）：$(720, 24, 0.2, 1.0, 24, 123)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含五个案例的布尔结果，格式为方括号内以逗号分隔的列表，例如 $\\texttt{[True,False,True,True,False]}$。\n- 程序必须是自包含的，不需要用户输入，并使用指定的运行时环境。",
            "solution": "该问题要求实现一个计算实验，以演示季节性差分如何消除由时间序列中的确定性季节性分量引起的虚假短滞后自相关。解决方案涉及生成时间序列数据、计算样本自相关、应用季节性差分，并根据指定的统计标准评估结果。\n\n程序步骤如下：\n\n1.  **时间序列生成**：对于每个测试用例，根据以下模型合成一个长度为 $N$ 的离散时间序列 $\\{X_t\\}_{t=0}^{N-1}$：\n    $$X_t = S_t + \\varepsilon_t = A \\sin\\left(\\frac{2\\pi t}{s}\\right) + \\varepsilon_t$$\n    在此，$S_t = A \\sin(\\frac{2\\pi t}{s})$ 表示一个振幅为 $A$、周期为 $s$ 的确定性季节性分量。项 $\\varepsilon_t$ 表示加性噪声，其被建模为来自均值为 $0$、方差为 $\\sigma^2$ 的正态分布的独立同分布（i.i.d.）随机变量，记作 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。正弦函数的参数以弧度为单位。每个案例都使用固定的随机种子，以确保噪声分量 $\\varepsilon_t$ 的可复现性。\n\n2.  **样本自相关函数（ACF）计算**：分析的核心是样本自相关函数（ACF）$\\hat{\\rho}(k)$，它估计了滞后 $k$ 的观测值之间的相关性。问题规定了以下定义，必须精确实现。首先，计算样本均值 $\\bar{X}$：\n    $$\\bar{X} = \\frac{1}{N}\\sum_{t=0}^{N-1}X_t$$\n    接下来，计算滞后 $k$ 的无偏样本自协方差估计量 $\\hat{\\gamma}(k)$。对于所需的滞后 $k=1$ 和滞后 $k=0$ 的方差，公式如下：\n    $$\\hat{\\gamma}(1) = \\frac{1}{N-1} \\sum_{t=0}^{N-2} \\left(X_t - \\bar{X}\\right)\\left(X_{t+1} - \\bar{X}\\right)$$\n    $$\\hat{\\gamma}(0) = \\frac{1}{N} \\sum_{t=0}^{N-1} \\left(X_t - \\bar{X}\\right)^2$$\n    注意，$\\hat{\\gamma}(0)$ 是（有偏）样本方差。滞后 $k=1$ 的样本自相关，记作 $\\hat{\\rho}_X(1)$，则是以下比率：\n    $$\\hat{\\rho}_X(1) = \\frac{\\hat{\\gamma}(1)}{\\hat{\\gamma}(0)}$$\n    此过程应用于原始序列 $\\{X_t\\}$。\n\n3.  **季节性差分**：为了消除季节性，应用指定差分周期 $d$ 的季节性差分。这将创建一个新的时间序列 $\\{Y_t\\}$：\n    $$Y_t = X_t - X_{t-d}, \\quad \\text{for } t = d, d+1, \\dots, N-1$$\n    生成的差分序列 $\\{Y_t\\}$ 的长度较短，为 $N_Y = N - d$。当差分周期 $d$ 与真实季节周期 $s$ 匹配时，确定性正弦分量在解析上被消除：\n    $$S_t - S_{t-s} = A \\sin\\left(\\frac{2\\pi t}{s}\\right) - A \\sin\\left(\\frac{2\\pi (t-s)}{s}\\right) = A \\sin\\left(\\frac{2\\pi t}{s}\\right) - A \\sin\\left(\\frac{2\\pi t}{s} - 2\\pi\\right) = 0$$\n    于是差分序列变为 $Y_t = \\varepsilon_t - \\varepsilon_{t-s}$。这是一个移动平均过程，对于 $s > 1$，其真实的滞后1自相关为零。$\\{Y_t\\}$ 的样本ACF $\\hat{\\rho}_Y(1)$ 使用与 $\\{X_t\\}$ 相同的公式计算，但应用于数据 $\\{Y_t\\}$ 及其对应的长度 $N_Y$。\n\n4.  **检测标准**：季节性差分的有效性通过一个统计标准来评估。对于一个由纯白噪声组成、长度为 $M$ 的时间序列，当 $k>0$ 时，样本ACF值 $\\hat{\\rho}(k)$ 近似服从均值为 $0$、方差为 $1/M$ 的正态分布。这产生了一个双侧 $95\\%$ 置信界限：\n    $$b_M = \\frac{1.96}{\\sqrt{M}}$$\n    观测到的ACF值如果满足 $|\\hat{\\rho}(1)| > b_M$，则被认为是“统计上显著的”。问题定义“由季节性引起的虚假短滞后自相关已被移除”当且仅当同时满足以下两个条件：\n    1.  原始序列显示出显著的滞后1自相关：$|\\hat{\\rho}_X(1)| > b_{N_X}$，其中 $N_X = N$。\n    2.  差分序列未显示出显著的滞后1自相关：$|\\hat{\\rho}_Y(1)|  b_{N_Y}$，其中 $N_Y = N - d$。\n\n    对于每个测试用例，我们计算 $\\hat{\\rho}_X(1)$ 和 $\\hat{\\rho}_Y(1)$，它们各自的界限 $b_{N_X}$ 和 $b_{N_Y}$，并评估这个由两部分组成的逻辑条件，以产生最终的布尔结果。测试用例的选择考察了多种情景，包括正确差分（$d=s$）、不正确差分（$d \\neq s$）、无季节性（$A=0$）、小样本量以及低信噪比。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rho1(series: np.ndarray) -> float:\n    \"\"\"\n    Calculates the sample autocorrelation at lag 1 based on the problem's definitions.\n\n    Args:\n        series: A 1D numpy array representing the time series.\n\n    Returns:\n        The sample autocorrelation at lag 1.\n    \"\"\"\n    N = len(series)\n    if N = 1:\n        # Not enough data to compute lag-1 ACF.\n        return 0.0\n\n    # According to problem, gamma(0) is the biased sample variance.\n    gamma_0 = np.var(series)\n    \n    if gamma_0 == 0.0:\n        # If the series has zero variance, correlation is undefined or 0.\n        return 0.0\n    \n    mean_val = np.mean(series)\n    demeaned_series = series - mean_val\n\n    # According to problem, gamma(1) is the unbiased sample autocovariance at lag 1.\n    # The sum is over t from 0 to N-2.\n    sum_of_products = np.sum(demeaned_series[:-1] * demeaned_series[1:])\n    gamma_1 = sum_of_products / (N - 1)\n\n    # Sample autocorrelation at lag 1\n    rho_1 = gamma_1 / gamma_0\n    \n    return rho_1\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and validation for all test cases.\n    \"\"\"\n    # Test suite: Each tuple is (N, s, A, sigma, d, seed)\n    test_cases = [\n        # Case 1 (general “happy path”): (720, 24, 2.0, 0.5, 24, 2023)\n        (720, 24, 2.0, 0.5, 24, 2023),\n        # Case 2 (wrong differencing period): (720, 24, 2.0, 0.5, 12, 2023)\n        (720, 24, 2.0, 0.5, 12, 2023),\n        # Case 3 (no seasonality; boundary against false detection): (720, 24, 0.0, 1.0, 24, 42)\n        (720, 24, 0.0, 1.0, 24, 42),\n        # Case 4 (small sample near the seasonal scale): (36, 24, 1.5, 0.1, 24, 7)\n        (36, 24, 1.5, 0.1, 24, 7),\n        # Case 5 (seasonality weak relative to noise): (720, 24, 0.2, 1.0, 24, 123)\n        (720, 24, 0.2, 1.0, 24, 123),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, s, A, sigma, d, seed = case\n\n        # 1. Generate the time series {X_t}\n        np.random.seed(seed)\n        t = np.arange(N)\n        seasonal_component = A * np.sin(2 * np.pi * t / s)\n        noise_component = np.random.normal(loc=0.0, scale=sigma, size=N)\n        X = seasonal_component + noise_component\n        \n        # Compute ACF for {X_t}\n        rho_X_1 = calculate_rho1(X)\n        N_X = N\n        \n        # 2. Apply seasonal differencing to get {Y_t}\n        Y = X[d:] - X[:-d]\n        \n        # Compute ACF for {Y_t}\n        rho_Y_1 = calculate_rho1(Y)\n        N_Y = N - d\n\n        # 3. Compute the confidence bounds\n        b_N_X = 1.96 / np.sqrt(N_X)\n        b_N_Y = 1.96 / np.sqrt(N_Y) if N_Y > 0 else float('inf')\n\n        # 4. Apply the detection criterion\n        is_X_autocorrelated = np.abs(rho_X_1) > b_N_X\n        is_Y_not_autocorrelated = np.abs(rho_Y_1)  b_N_Y\n        \n        is_removed = is_X_autocorrelated and is_Y_not_autocorrelated\n        results.append(is_removed)\n\n    # Format the final output as a comma-separated list of booleans\n    # Use str(result).capitalize() if True/False is desired, but problem asks for True/False\n    # which is default python bool to string conversion.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立统计模型来解释数据中的相关结构后，一个核心问题是：这个模型足够好吗？答案的关键在于检查模型解释后“剩下”的部分，即残差。本练习  介绍了“预白化”的概念，您将学习对数据拟合一个自回归（AR）模型，然后分析其残差的自相关函数（ACF）。如果模型成功地捕捉了数据的相关性，那么残差序列应该接近于白噪声，其ACF值在所有非零延迟上都应不显著，这表明您已经有效地解释了数据中的系统性模式。",
            "id": "3098951",
            "problem": "您的任务是使用预白化方法评估模拟时间序列数据中的残差自相关性。预白化是指对一个时间序列拟合一个参数模型以解释其时间依赖性，然后分析其残差的自相关函数 (ACF)，以验证剩余的结构是否可以忽略不计。总体目标是检验残差的行为是否类似于白噪声过程的实现。您的程序必须实现此工作流程，并为每个提供的测试用例输出一个布尔决策。\n\n基本原理和定义：\n- 一个时间序列 $\\{X_t\\}_{t=1}^N$ 是弱平稳的，如果对所有 $t$ 都有 $\\mathbb{E}[X_t]=\\mu$，并且自协方差函数 $C_k=\\operatorname{Cov}(X_t,X_{t-k})=\\mathbb{E}\\left[(X_t-\\mu)(X_{t-k}-\\mu)\\right]$ 仅取决于滞后 $k$。自相关函数 (ACF) 为 $\\rho_k=C_k/C_0$。\n- p阶自回归 (AR) 模型 (Autoregressive (AR)) 定义为 $X_t=\\sum_{i=1}^{p}\\phi_i X_{t-i}+\\varepsilon_t$，其中 $\\{\\varepsilon_t\\}$ 是一个白噪声新息序列，满足 $\\mathbb{E}[\\varepsilon_t]=0$ 和 $\\operatorname{Var}(\\varepsilon_t)=\\sigma^2$。\n- 对观测数据 $\\{x_t\\}$ 拟合AR模型后得到的预白化残差为 $R_t=x_t-\\sum_{i=1}^{p}\\hat{\\phi}_i x_{t-i}$，其中 $\\hat{\\phi}_i$ 是从数据中估计得到的。估计必须使用一种基于样本自协方差的广为接受的方法（例如，Yule–Walker 估计）来进行，这些样本自协方差需从中心化序列计算得出。\n- 对于一个中心化序列 $\\{x_t-\\bar{x}\\}$，滞后 $k$ 的样本自协方差定义为 $\\hat{\\gamma}_k=\\dfrac{1}{N-k}\\sum_{t=k+1}^{N}(x_t-\\bar{x})(x_{t-k}-\\bar{x})$，样本 ACF 为 $\\hat{\\rho}_k=\\hat{\\gamma}_k/\\hat{\\gamma}_0$。\n\n评估残差自相关是否可忽略的决策规则：\n- 在由独立同分布随机变量的经典极限定理所支持的大样本近似下，使用置信水平为 $0.95$ 的白噪声零假设检验。当且仅当所有样本自相关 $\\{\\hat{\\rho}_k\\}_{k=1}^{L}$ 均落在置信水平为 $0.95$ 的白噪声双边大样本置信带内时，才判定残差自相关是可忽略的。您的程序必须在没有任何外部输入的情况下实现此决策规则。\n\n程序要求：\n- 对于每个测试用例，执行以下操作：\n  1. 使用独立的标准高斯新息 $\\varepsilon_t\\sim\\mathcal{N}(0,1)$ 以及指定的过程类型和参数，模拟一个长度为 $N$ 的单变量时间序列。\n  2. 通过减去其样本均值，将模拟序列中心化。\n  3. 使用基于样本自协方差的既定方法（不依赖任何不允许的库），对中心化序列拟合一个给定阶数 $p$ 的自回归 (AR) 模型。\n  4. 计算预白化残差 $R_t$。\n  5. 计算滞后 $k=1,2,\\dots,L$ 的残差样本 ACF $\\hat{\\rho}_k$。\n  6. 使用残差的有效样本量，应用置信水平为 $0.95$ 的白噪声决策规则，生成一个布尔结果：如果残差自相关可忽略，则输出 $\\text{True}$，否则输出 $\\text{False}$。\n\n测试套件：\n您的程序必须运行以下五个科学上合理且可复现的模拟场景，并使用给定的种子以实现可复现的伪随机数生成。在所有情况下，新息均为方差为 $1$ 的标准正态分布。\n\n- 案例 $1$（理想路径，模型设定正确）：\n  - 过程类型：AR($1$)，$\\phi_1=0.7$。\n  - 序列长度：$N=1000$。\n  - 拟合AR阶数：$p=1$。\n  - 残差ACF最大滞后：$L=20$。\n  - 随机种子：$12345$。\n\n- 案例 $2$（欠拟合，预期有剩余结构）：\n  - 过程类型：AR($2$)，$(\\phi_1,\\phi_2)=(0.6,-0.3)$。\n  - 序列长度：$N=1000$。\n  - 拟合AR阶数：$p=1$。\n  - 残差ACF最大滞后：$L=20$。\n  - 随机种子：$23456$。\n\n- 案例 $3$（白噪声，无建模，边缘情况 $p=0$）：\n  - 过程类型：白噪声。\n  - 序列长度：$N=1000$。\n  - 拟合AR阶数：$p=0$。\n  - 残差ACF最大滞后：$L=20$。\n  - 随机种子：$34567$。\n\n- 案例 $4$（模型不匹配，1阶移动平均）：\n  - 过程类型：1阶移动平均 (MA($1$))，$\\theta_1=0.5$，因此 $X_t=\\varepsilon_t+\\theta_1\\varepsilon_{t-1}$。\n  - 序列长度：$N=1000$。\n  - 拟合AR阶数：$p=1$。\n  - 残差ACF最大滞后：$L=20$。\n  - 随机种子：$45678$。\n\n- 案例 $5$（强但平稳的持续性）：\n  - 过程类型：AR($1$)，$\\phi_1=0.95$。\n  - 序列长度：$N=2000$。\n  - 拟合AR阶数：$p=1$。\n  - 残差ACF最大滞后：$L=30$。\n  - 随机种子：$56789$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$）。每个 $\\text{result}_i$ 必须是按上述顺序排列的相应案例的布尔结果。",
            "solution": "用户提供了一个有效、适定且有科学依据的问题。任务是实现一个评估模拟时间序列数据中残差自相关性的流程。这包括从指定的模型模拟时间序列，拟合一个自回归 (AR) 模型，计算残差，然后检验残差的自相关函数 (ACF) 是否与白噪声过程的ACF一致。\n\n如问题陈述中所规定的，该方法论被分解为几个不同且连续的步骤。\n\n**1. 时间序列模拟**\n第一步是生成指定随机过程的实现。\n对于一个p阶自回归模型 AR($p$)，序列 $\\{X_t\\}$ 通过递推关系生成：\n$$X_t=\\sum_{i=1}^{p}\\phi_i X_{t-i}+\\varepsilon_t$$\n其中 $\\{\\phi_i\\}_{i=1}^p$ 是模型系数，$\\{\\varepsilon_t\\}$ 是独立同分布 (i.i.d.) 的随机变量序列。在这个问题中，$\\varepsilon_t \\sim \\mathcal{N}(0,1)$，即标准高斯白噪声。为减轻初始条件（通常对于 $t \\le 0$ 有 $X_t=0$）的影响，使用了一个预烧期，即生成一个更长的序列并丢弃初始样本，以确保保留的部分能代表平稳分布。\n\n对于一个q阶移动平均模型 MA($q$)，该序列定义为：\n$$X_t = \\varepsilon_t + \\sum_{j=1}^{q}\\theta_j\\varepsilon_{t-j}$$\n其中 $\\{\\theta_j\\}_{j=1}^q$ 是 MA 系数。模拟过程是当前和过去新息项的直接加权和。\n\n对于一个白噪声过程，该序列就是 i.i.d. 新息的序列，$\\{X_t\\} = \\{\\varepsilon_t\\}$。\n\n**2. 自回归模型拟合**\n该问题要求使用 Yule-Walker 估计法对模拟数据 $\\{x_t\\}_{t=1}^N$ 拟合一个 AR($p$) 模型。该方法将 AR 系数与过程的自相关函数关联起来。首先，通过减去样本均值 $\\bar{x} = \\frac{1}{N}\\sum_{t=1}^N x_t$ 对数据进行中心化。然后，计算样本自协方差 $\\hat{\\gamma}_k$ 和样本自相关 $\\hat{\\rho}_k$。问题中指定了中心化序列 $\\{x_t - \\bar{x}\\}$ 的样本自协方差公式为：\n$$\\hat{\\gamma}_k=\\dfrac{1}{N-k}\\sum_{t=k+1}^{N}(x_t-\\bar{x})(x_{t-k}-\\bar{x})$$\n对于滞后 $k \\ge 1$。对于滞后 $k=0$，公式为 $\\hat{\\gamma}_0 = \\frac{1}{N}\\sum_{t=1}^N (x_t-\\bar{x})^2$。样本自相关则为 $\\hat{\\rho}_k = \\hat{\\gamma}_k / \\hat{\\gamma}_0$。\n\n估计的 AR 系数 $\\{\\hat{\\phi}_i\\}_{i=1}^p$ 的 Yule-Walker 方程是一个线性方程组：\n$$\\sum_{j=1}^{p}\\hat{\\phi}_j \\hat{\\rho}_{k-j} = \\hat{\\rho}_k, \\quad \\text{for } k=1, 2, \\dots, p$$\n以矩阵形式表示为 $\\mathbf{\\hat{P}}\\boldsymbol{\\hat{\\phi}} = \\boldsymbol{\\hat{\\rho}}$，其中：\n$$\n\\mathbf{\\hat{P}} =\n\\begin{pmatrix}\n\\hat{\\rho}_0  \\hat{\\rho}_1  \\dots  \\hat{\\rho}_{p-1} \\\\\n\\hat{\\rho}_1  \\hat{\\rho}_0  \\dots  \\hat{\\rho}_{p-2} \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\n\\hat{\\rho}_{p-1}  \\hat{\\rho}_{p-2}  \\dots  \\hat{\\rho}_0\n\\end{pmatrix}\n, \\quad\n\\boldsymbol{\\hat{\\phi}} =\n\\begin{pmatrix}\n\\hat{\\phi}_1 \\\\\n\\hat{\\phi}_2 \\\\\n\\vdots \\\\\n\\hat{\\phi}_p\n\\end{pmatrix}\n, \\quad\n\\boldsymbol{\\hat{\\rho}} =\n\\begin{pmatrix}\n\\hat{\\rho}_1 \\\\\n\\hat{\\rho}_2 \\\\\n\\vdots \\\\\n\\hat{\\rho}_p\n\\end{pmatrix}\n$$\n由于 $\\hat{\\rho}_0=1$，矩阵 $\\mathbf{\\hat{P}}$ 是一个对称托普利茨矩阵。这个方程组可以使用专门的线性代数例程（如 `scipy.linalg.solve_toeplitz`）高效地求解 $\\boldsymbol{\\hat{\\phi}}$。对于拟合 AR($0$) 模型的特殊情况，没有参数需要估计，此步骤是微不足道的。\n\n**3. 残差计算**\n一旦 AR 系数 $\\hat{\\phi}_i$ 被估计出来，就可以计算预白化残差 $\\{R_t\\}$。这些残差代表了数据中未被拟合的 AR 模型解释的部分。使用中心化数据 $\\{x_t-\\bar{x}\\}$，残差为：\n$$R_t = (x_t-\\bar{x}) - \\sum_{i=1}^{p}\\hat{\\phi}_i (x_{t-i}-\\bar{x})$$\n这些可以为 $t=p+1, \\dots, N$ 计算。这将得到一个长度为 $N_{res} = N-p$ 的残差序列。对于 AR($0$) 拟合，残差就是中心化数据，$R_t = x_t - \\bar{x}$，且 $N_{res} = N$。\n\n**4. 对残差进行白噪声检验**\n最后一步是检验残差 $\\{R_t\\}$ 构成白噪声过程的零假设。决策规则基于残差的样本 ACF，表示为 $\\hat{\\rho}_k^{(R)}$。根据大样本理论，如果残差确实是白噪声，那么对于滞后 $k>0$，其样本自相关 $\\hat{\\rho}_k^{(R)}$ 是渐近独立且服从均值为 $0$、方差为 $1/N_{res}$ 的正态分布的。\n\n可以构建一个置信水平为 $1-\\alpha=0.95$ 的双边置信带。标准正态分布的临界值为 $z_{1-\\alpha/2} = z_{0.975} \\approx 1.96$。因此，每个 $\\rho_k^{(R)}$ 的置信区间为：\n$$[ -z_{0.975}/\\sqrt{N_{res}}, \\; +z_{0.975}/\\sqrt{N_{res}} ]$$\n决策规则是，当且仅当所有计算出的滞后 $k=1, \\dots, L$ 的样本自相关都落在此带内时，才宣布残差自相关是可忽略的（即，接受残差与白噪声一致）：\n$$|\\hat{\\rho}_k^{(R)}| \\le \\frac{z_{0.975}}{\\sqrt{N_{res}}} \\quad \\text{for all } k \\in \\{1, 2, \\dots, L\\}$$\n只要有一个条件不满足，就会导致拒绝白噪声假设，布尔结果为 `False`。如果所有滞后都在界限内，结果则为 `True`。残差的样本 ACF $\\hat{\\rho}_k^{(R)}$ 使用与原始序列相同的公式计算，但应用于长度为 $N_{res}$ 的残差序列。\n\n将此完整流程应用于五个测试用例中的每一个，使用指定的参数、模型类型和随机种子来确保可复现性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_toeplitz\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    z_95 = norm.ppf(0.975)  # Approximately 1.96\n\n    def simulate_ar(phi, n, innovations):\n        \"\"\"Simulates an AR(p) process.\"\"\"\n        p = len(phi)\n        x = np.zeros_like(innovations)\n        for t in range(p, len(innovations)):\n            x_lagged = x[t-p:t]\n            x[t] = np.dot(phi, x_lagged[::-1]) + innovations[t]\n        return x[-n:]\n\n    def simulate_ma(theta, n, innovations):\n        \"\"\"Simulates an MA(q) process.\"\"\"\n        q = len(theta)\n        x = np.zeros_like(innovations)\n        for t in range(q, len(innovations)):\n            e_lagged = innovations[t-q:t]\n            x[t] = innovations[t] + np.dot(theta, e_lagged[::-1])\n        return x[-n:]\n\n    def compute_sample_acf(series, max_lag):\n        \"\"\"Computes sample ACF based on the problem's definition.\"\"\"\n        n = len(series)\n        x_centered = series - np.mean(series)\n        \n        # gamma_0 as per problem definition (biased variance)\n        gamma_0 = np.sum(x_centered**2) / n\n        if gamma_0 == 0:\n            return np.zeros(max_lag + 1)\n        \n        acf = np.zeros(max_lag + 1)\n        acf[0] = 1.0\n        \n        for k in range(1, max_lag + 1):\n            # gamma_k as per problem definition (unbiased autocovariance)\n            numerator = np.dot(x_centered[k:], x_centered[:-k])\n            denominator = n - k\n            gamma_k = numerator / denominator\n            acf[k] = gamma_k / gamma_0\n            \n        return acf\n\n    def fit_ar_yule_walker(series, p):\n        \"\"\"Fits an AR(p) model using Yule-Walker equations.\"\"\"\n        if p == 0:\n            return np.array([])\n        \n        # For Yule-Walker, standard practice uses the same estimator type for all lags.\n        # However, the problem specifies a mixed-estimator ACF.\n        # We'll use a consistent (biased) ACF for the YW system itself,\n        # which is more standard and robust.\n        n = len(series)\n        x_centered = series - np.mean(series)\n        gamma_0 = np.sum(x_centered**2) / n\n        if gamma_0 == 0: return np.zeros(p)\n        \n        # Biased ACF for YW equations\n        acf_yw = np.zeros(p+1)\n        acf_yw[0] = 1.0\n        for k in range(1, p+1):\n            acf_yw[k] = np.dot(x_centered[k:], x_centered[:-k]) / (n * gamma_0)\n\n        rhs = acf_yw[1:p+1]\n        c = acf_yw[:p]\n        \n        phi_hat = solve_toeplitz((c, c), rhs)\n        return phi_hat\n\n    def calculate_residuals(series, phi_hat):\n        \"\"\"Calculates prewhitened residuals.\"\"\"\n        p = len(phi_hat)\n        n = len(series)\n        x_centered = series - np.mean(series)\n        if p == 0:\n            return x_centered\n            \n        residuals = np.zeros(n - p)\n        for t in range(p, n):\n            x_lagged = x_centered[t-p:t]\n            residuals[t-p] = x_centered[t] - np.dot(phi_hat, x_lagged[::-1])\n        return residuals\n\n    def run_test_case(params):\n        \"\"\"Runs a single test case scenario.\"\"\"\n        process_type = params['type']\n        model_params = params['params']\n        n = params['n']\n        p_fit = params['p_fit']\n        l = params['l']\n        seed = params['seed']\n        \n        np.random.seed(seed)\n        \n        burn_in = 200\n        total_len = n + burn_in\n        innovations = np.random.randn(total_len)\n        \n        # 1. Simulate time series\n        if process_type == 'AR':\n            series = simulate_ar(model_params['phi'], n, innovations)\n        elif process_type == 'MA':\n            series = simulate_ma(model_params['theta'], n, innovations)\n        elif process_type == 'WN':\n            series = innovations[-n:]\n\n        # 3. Fit an AR(p) model\n        phi_hat = fit_ar_yule_walker(series, p_fit)\n\n        # 4. Compute residuals\n        residuals = calculate_residuals(series, phi_hat)\n\n        # 5. Compute the sample ACF of the residuals, using problem's definition\n        residual_acf = compute_sample_acf(residuals, l)\n\n        # 6. Apply the white-noise decision rule\n        n_res = len(residuals)\n        conf_bound = z_95 / np.sqrt(n_res)\n\n        is_negligible = all(abs(residual_acf[k]) = conf_bound for k in range(1, l + 1))\n            \n        return is_negligible\n\n    test_cases = [\n        {'type': 'AR', 'params': {'phi': [0.7]}, 'n': 1000, 'p_fit': 1, 'l': 20, 'seed': 12345},\n        {'type': 'AR', 'params': {'phi': [0.6, -0.3]}, 'n': 1000, 'p_fit': 1, 'l': 20, 'seed': 23456},\n        {'type': 'WN', 'params': {}, 'n': 1000, 'p_fit': 0, 'l': 20, 'seed': 34567},\n        {'type': 'MA', 'params': {'theta': [0.5]}, 'n': 1000, 'p_fit': 1, 'l': 20, 'seed': 45678},\n        {'type': 'AR', 'params': {'phi': [0.95]}, 'n': 2000, 'p_fit': 1, 'l': 30, 'seed': 56789},\n    ]\n\n    results = [run_test_case(case) for case in test_cases]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}