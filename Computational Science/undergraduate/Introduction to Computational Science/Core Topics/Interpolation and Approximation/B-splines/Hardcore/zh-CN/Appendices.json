{
    "hands_on_practices": [
        {
            "introduction": "理论的最好理解方式是通过实践。第一个练习将挑战你将 B 样条的基本递归定义转化为一个可执行的程序。通过实现 Cox-de Boor 算法并验证夹持样条的端点插值属性 ()，你将从零开始，建立对这些曲线如何构造的扎实、可用的理解。",
            "id": "3207506",
            "problem": "要求您编写一个完整、可运行的程序，用于构建和求值一条基样条（B-spline）曲线，并保证该曲线插值其首尾控制点。您的设计必须从B样条基函数的核心递归定义出发，并进行算法实现，同时要考虑到数值稳定性和正确性。\n\n请从以下基本依据出发：B样条基函数的 Cox–de Boor 递归定义。对于一个给定的非递减节点向量 $\\{t_0, t_1, \\dots, t_m\\}$ 和次数 $p \\ge 0$，基函数 $N_{i,p}(u)$ 由以下方式递归定义：\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1,  t_i \\le u  t_{i+1} \\\\\n0,  \\text{其他情况}\n\\end{cases}\n$$\n对于 $p \\ge 1$，\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u),\n$$\n约定分母为零的项按零处理。参数化曲线则由下式给出：\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i,\n$$\n其中 $\\{\\mathbf{P}_0,\\dots,\\mathbf{P}_n\\}$ 是控制点。当节点向量是钳位（也称开放）的，即首尾节点各重复 $p+1$ 次时，该曲线保证在其参数域的端点处插值首尾控制点。您的任务是实现一个使用这些定义的求值算法，并通过一个测试套件来证明您的曲线精确地通过其首尾控制点。\n\n要求：\n- 基于上述递归基函数定义实现B样条曲线求值，使用适合于高年级本科生数值方法课程水平的数值稳定方法。您必须通过在两端使用重复度为 $p+1$ 的钳位节点向量来确保端点插值。\n- 求值域必须为 $[t_p, t_{m-p}]$。在 $u = t_p$ 和 $u = t_{m-p}$ 处，曲线必须分别返回 $\\mathbf{P}_0$ 和 $\\mathbf{P}_n$。\n- 使用欧几里得距离比较向量的相等性，绝对容差为 $10^{-9}$，相对容差为零。如果范数差小于或等于 $10^{-9}$，则视为相等。\n\n测试套件和参数：\n对于下面的每个测试用例，请在左端点 $u = t_p$ 和右端点 $u = t_{m-p}$ 处对曲线进行求值，并检查这些点是否在容差范围内与首尾控制点匹配。您的程序应为每个测试用例生成一个布尔值，表示两个端点检查是否都通过。\n\n设每个控制点 $\\mathbf{P}_i$ 是一个按规定在二维或三维空间中的坐标向量。节点向量要么是明确给出的，要么必须构建为钳位开放均匀节点向量。一个长度为 $m+1 = n + p + 2$ 的开放均匀钳位节点向量，其前 $p+1$ 项等于 $0$，后 $p+1$ 项等于 $1$，内部节点在 $(0,1)$ 区间内均匀分布。\n\n- 测试用例 1 (正常路径，二维，二次钳位开放均匀):\n  - 次数 $p = 2$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_4$: $\\{(0,0),(1,2),(2,0.5),(3,3),(4,0)\\}$。\n  - 为 $n=4, p=2$ 构建一个钳位开放均匀节点向量。\n- 测试用例 2 (具有最少内部节点的边界情况，三次钳位开放均匀，类贝塞尔):\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_3$: $\\{(0,0),(1,2),(3,2),(4,0)\\}$。\n  - 为 $n=3, p=3$ 构建一个钳位开放均匀节点向量。\n- 测试用例 3 (非均匀钳位，二维):\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_6$: $\\{(0,0),(1,1),(2,-1),(3,2),(4,-0.5),(5,1.5),(6,0)\\}$。\n  - 显式钳位非均匀节点向量: $\\{0,0,0,0,0.15,0.6,0.85,1,1,1,1\\}$。\n- 测试用例 4 (边缘情况，线性钳位开放均匀):\n  - 次数 $p = 1$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_2$: $\\{(0,1),(1,0),(2,1.5)\\}$。\n  - 为 $n=2, p=1$ 构建一个钳位开放均匀节点向量。\n- 测试用例 5 (三维，三次钳位开放均匀):\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_5$: $\\{(0,0,0),(1,2,1),(2,-1,2),(3,3,2),(4,0,1),(5,1,0)\\}$。\n  - 为 $n=5, p=3$ 构建一个钳位开放均匀节点向量。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $\\texttt{[true,false,true]}$。请使用小写的Python布尔值格式。该列表必须为每个测试用例包含一个布尔值，并按上面列出的顺序排列。",
            "solution": "该问题要求实现和验证B样条曲线的求值，并展示钳位节点向量的端点插值属性。解决方案直接源于问题描述中提供的B样条基函数的基本递归定义。\n\n一条 $p$ 次的B样条曲线 $\\mathbf{C}(u)$ 是一条参数化曲线，定义为 $n+1$ 个控制点 $\\{\\mathbf{P}_0, \\dots, \\mathbf{P}_n\\}$ 的加权和：\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i\n$$\n权重是B样条基函数 $N_{i,p}(u)$，它们是 $p$ 次的分段多项式。它们的定义依赖于一个称为节点向量的非递减实数序列 $T = \\{t_0, t_1, \\dots, t_m\\}$，其中必须满足关系式 $m = n+p+1$。这些基函数由 Cox–de Boor 递归公式定义。\n\n对于 $p=0$：\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1,  \\text{if } t_i \\le u  t_{i+1} \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n这个定义意味着，对于任何零长度区间，即 $t_i = t_{i+1}$，基函数 $N_{i,0}(u)$ 恒为 $0$。对于参数值 $u$ 位于定义域最末端的情况，需要进行特殊考虑。如果曲线定义域是 $[t_p, t_{n+1}]$，那么对于 $u = t_{n+1}$，相关的非零0次基函数被取为 $N_{n,0}(t_{n+1})=1$。\n\n对于 $p \\ge 1$：\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u)\n$$\n问题指明，如果此表达式中的分母为零，则相应的项按零处理。\n\n任务的核心是基于这些定义实现一个计算 $\\mathbf{C}(u)$ 的算法，并验证对于一个钳位节点向量，有 $\\mathbf{C}(t_p) = \\mathbf{P}_0$ 和 $\\mathbf{C}(t_{n+1}) = \\mathbf{P}_n$。钳位节点向量的首尾各有 $p+1$ 个节点相等。这种结构确保了 $N_{0,p}(t_p)=1$ 和 $N_{n,p}(t_{n+1})=1$，而所有其他基函数 $N_{i,p}$ 在各自的端点处为零，从而实现了插值。\n\n对于每个测试用例，整体算法按以下步骤进行：\n1.  **参数设置**：定义次数 $p$ 和由 $n+1$ 个控制点组成的集合 $\\{\\mathbf{P}_i\\}$。\n2.  **节点向量构建**：构建节点向量 $T$。对于需要钳位开放均匀节点向量的情况，将前 $p+1$ 个节点设为 $0$，后 $p+1$ 个节点设为 $1$，并将 $n-p$ 个内部节点在区间 $(0,1)$ 内均匀分布。节点数量为 $m+1 = n+p+2$。\n3.  **端点曲线求值**：\n    *   在其定义域的左端点 $u_{left} = t_p$ 处对曲线求值。\n    *   在其定义域的右端点 $u_{right} = t_{n+1}$ 处对曲线求值。\n    *   求值本身，即 $\\mathbf{C}(u)$，由一个计算 $\\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i$ 的函数执行。\n4.  **基函数计算**：每个基函数 $N_{i,p}(u)$ 的值通过一个直接实现 Cox-de Boor 公式的递归函数计算。为确保计算可行性，该递归函数采用记忆化（动态规划的一种形式），以防止对相同基函数值的重复计算。递归基例 $N_{i,0}(u)$ 的实现必须仔细处理半开区间以及定义域右端点的特殊情况。\n5.  **验证**：将计算出的点 $\\mathbf{C}(u_{left})$ 与第一个控制点 $\\mathbf{P}_0$ 进行比较，并将 $\\mathbf{C}(u_{right})$ 与最后一个控制点 $\\mathbf{P}_n$ 进行比较。比较是通过计算向量间的欧几里得距离来完成的。如果两个端点的距离都在指定的 $10^{-9}$ 容差范围内，则该测试用例被视为通过。\n\n实现封装了这些步骤。一个主函数遍历测试套件，调用辅助函数来构建节点向量并求值B样条曲线。求值函数 `b_spline_eval` 使用一个嵌套的辅助函数 `_basis_function` 来递归计算基函数。这种嵌套结构使得递归函数能够保持简洁，同时可以访问参数 $u$、节点向量 $T$ 和记忆化字典，从而避免了使用全局状态。每个测试用例的结果（一个布尔值）被收集起来，并以指定的格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_clamped_uniform_knot_vector(n, p):\n    \"\"\"\n    Constructs a clamped open-uniform knot vector.\n    The domain for the interior knots is (0, 1).\n    \n    Args:\n        n (int): The number of control points minus 1.\n        p (int): The degree of the B-spline.\n        \n    Returns:\n        np.ndarray: The knot vector of length n + p + 2.\n    \"\"\"\n    num_knots = n + p + 2\n    T = np.zeros(num_knots, dtype=float)\n    \n    num_interior_knots = n - p\n    if num_interior_knots > 0:\n      denominator = float(n - p + 1)\n      T[p + 1 : n + 1] = np.arange(1, num_interior_knots + 1) / denominator\n    \n    T[n + 1:] = 1.0\n    return T\n\ndef b_spline_eval(u, p, control_points, T):\n    \"\"\"\n    Evaluates the B-spline curve at a parameter value u using the recursive\n    Cox-de Boor basis function definition with memoization.\n    \n    Args:\n        u (float): The parameter value.\n        p (int): The degree of the B-spline.\n        control_points (np.ndarray): Array of control points.\n        T (np.ndarray): The knot vector.\n        \n    Returns:\n        np.ndarray: The computed point on the curve.\n    \"\"\"\n    n = len(control_points) - 1\n    memo = {}\n\n    def _basis_function(i, deg):\n        \"\"\"\n        Computes the value of the B-spline basis function N_i,deg(u) via\n        a memoized recursion. This is a nested function to capture u, T, n, and memo.\n        \"\"\"\n        if (i, deg) in memo:\n            return memo[(i, deg)]\n\n        if deg == 0:\n            # The curve domain is [t_p, t_{n+1}]. At the right boundary u = t_{n+1},\n            # the convention is that u falls in the last interval [t_n, t_{n+1}],\n            # making N_{n,0}(t_{n+1}) = 1.\n            if u == T[n + 1] and i == n:\n                res = 1.0\n            else:\n                # Standard definition for half-open interval [t_i, t_{i+1}).\n                # This is 0 if t_i == t_{i+1}.\n                res = 1.0 if T[i] = u  T[i + 1] else 0.0\n            memo[(i, deg)] = res\n            return res\n\n        # Recursive step\n        term1 = 0.0\n        den1 = T[i + deg] - T[i]\n        if den1 != 0.0:\n            term1 = ((u - T[i]) / den1) * _basis_function(i, deg - 1)\n\n        term2 = 0.0\n        den2 = T[i + deg + 1] - T[i + 1]\n        if den2 != 0.0:\n            term2 = ((T[i + deg + 1] - u) / den2) * _basis_function(i + 1, deg - 1)\n\n        res = term1 + term2\n        memo[(i, deg)] = res\n        return res\n\n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(n + 1):\n        basis_val = _basis_function(i, p)\n        # Optimization: only add if the basis function is non-zero\n        if basis_val > 1e-12: # Check against small tolerance\n            curve_point += basis_val * control_points[i]\n            \n    return curve_point\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify endpoint interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: 2D quadratic\n        {\n            \"p\": 2,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [2, 0.5], [3, 3], [4, 0]\n            ]),\n            \"knot_vector\": None \n        },\n        # Case 2: 2D cubic, Bezier-like\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [3, 2], [4, 0]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 3: 2D cubic, non-uniform knots\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 1], [2, -1], [3, 2], [4, -0.5], [5, 1.5], [6, 0]\n            ]),\n            \"knot_vector\": np.array([0, 0, 0, 0, 0.15, 0.6, 0.85, 1, 1, 1, 1])\n        },\n        # Case 4: 2D linear\n        {\n            \"p\": 1,\n            \"control_points\": np.array([\n                [0, 1], [1, 0], [2, 1.5]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 5: 3D cubic\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0, 0], [1, 2, 1], [2, -1, 2], [3, 3, 2], [4, 0, 1], [5, 1, 0]\n            ]),\n            \"knot_vector\": None\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        p = case[\"p\"]\n        P = case[\"control_points\"]\n        n = len(P) - 1\n\n        if case[\"knot_vector\"] is None:\n            T = build_clamped_uniform_knot_vector(n, p)\n        else:\n            T = case[\"knot_vector\"]\n        \n        # Endpoints of the parametric domain for a clamped knot vector\n        u_left = T[p]\n        u_right = T[n + 1]\n\n        # Evaluate curve at endpoints\n        C_left = b_spline_eval(u_left, p, P, T)\n        C_right = b_spline_eval(u_right, p, P, T)\n\n        # Verify interpolation\n        dist_left = np.linalg.norm(C_left - P[0])\n        dist_right = np.linalg.norm(C_right - P[-1])\n\n        check_left = dist_left = tolerance\n        check_right = dist_right = tolerance\n        \n        results.append(check_left and check_right)\n\n    # Format output as required\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```"
        },
        {
            "introduction": "除了简单的曲线生成，设计师还需要对形状和连续性进行精确控制。本练习探讨 B 样条形状控制中最强大的工具之一：节点重数。你将定量地研究增加节点的重数如何降低连续性，从而产生尖角或将曲线拉近控制点，进而获得对局部形状控制的直观认识 ()。",
            "id": "3099558",
            "problem": "您将研究在三次B样条中增加节点重数如何影响局部形状，包括相对于基准曲线可能出现的过冲以及尖角或平坦点的产生。请在纯数学环境下，使用二维控制点和标准的B样条定义进行全部工作。您的程序必须是一个完整、可运行的实现，能够从第一性原理出发评估曲线及其导数，并为一个小规模测试套件计算量化指标。\n\n基本依据和定义：\n- 一个次数为 $p$，控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^{N-1}$，非递减节点向量为 $\\{t_j\\}_{j=0}^{N+p}$ 的B样条曲线定义为\n$$\n\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i,\n$$\n其中 $N_{i,p}(t)$ 是由 Cox–de Boor 递归公式定义的B样条基函数：\n$$\nN_{i,0}(t) =\n\\begin{cases}\n1,  t_i \\le t  t_{i+1},\\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n对于 $p \\ge 1$\n$$\nN_{i,p}(t) = \\frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \\frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\n约定分母为零的项贡献为 $0$。\n- 曲线的导数使用基函数的导数：\n$$\n\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i,\n$$\n其中\n$$\n\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\n同样，将除以零的情况解释为贡献为 $0$。\n- 对于次数为 $p$ 的B样条中重数为 $m$ 的节点，曲线在该节点处的连续性为 $C^{p-m}$，意味着前 $p-m$ 阶导数是连续的，而第 $(p-m+1)$ 阶导数通常会有一个跳跃。特别地，如果 $m = p+1$，曲线在该节点处会断开（没有位置连续性）。\n\n场景和建模设置：\n- 使用次数 $p = 3$（三次）和 $\\mathbb{R}^2$ 中的 $N = 8$ 个控制点。\n- 使用两端重复的开放节点向量：\n$$\n\\underbrace{0,0,0,0}_{p+1\\text{ 次}}, \\text{内部节点}, \\underbrace{1,1,1,1}_{p+1\\text{ 次}}.\n$$\n- 令我们关注的内部节点位置为 $u_0 = 0.5$。内部节点条目的总数为 $N - p - 1 = 4$。对于在 $u_0$ 处选定的重数 $m \\in \\{1,2,3,4\\}$，按如下方式构建内部节点多重集。包含 $m$ 个 $u_0$ 的副本，并从固定列表 $\\{0.25,\\,0.33,\\,0.75\\}$ 中使用剩下的 $4 - m$ 个条目，从该列表中取最小的 $4-m$ 个元素，然后对所有内部条目进行排序。这样可以为每个 $m$ 生成恰好四个内部节点条目。\n- 定义两种控制点场景：\n  - 场景 A（驼峰状）：\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 1.0)$,\n    - $\\mathbf{P}_2=(2.0, 2.0)$,\n    - $\\mathbf{P}_3=(3.0, 4.0)$,\n    - $\\mathbf{P}_4=(4.0, 2.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.5)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 1.1)$.\n  - 场景 B（局部平坦区域）：\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 0.5)$,\n    - $\\mathbf{P}_2=(2.0, 1.0)$,\n    - $\\mathbf{P}_3=(3.0, 1.0)$,\n    - $\\mathbf{P}_4=(4.0, 1.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.0)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 2.0)$.\n\n需要计算的量：\n- 定义基准曲线为在 $u_0=0.5$ 处重数为 $m=1$ 的三次B样条，使用上述内部节点构造方法。将此基准表示为 $\\mathbf{C}_{\\mathrm{base}}(t)$。\n- 对于每种场景和每个 $m \\in \\{1,2,3,4\\}$，构建相应的节点向量并计算：\n  1. 在参数值的均匀采样上与基准线的最大绝对偏差：\n     $$\n     D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2.\n     $$\n     使用欧几里得范数。令样本 $\\mathcal{T}$ 为开区间 $(0,1)$ 内的 $4001$ 个等距点，例如，$t_k$ 从 $10^{-6}$ 到 $1-10^{-6}$ 线性间隔，以避免在节点处精确求值。\n  2. 内部节点 $u_0$ 处斜率不连续性的数值度量：\n     $$\n     J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2.\n     $$\n     为评估单侧导数而不精确落在节点上，选择\n     $$\n     \\delta = \\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right),\n     $$\n     其中 $u_\\text{L}$ 是所构造节点向量中严格小于 $u_0$ 的最大节点，而 $u_\\text{R}$ 是严格大于 $u_0$ 的最小节点。然后通过使用上面的基函数导数公式评估 $\\mathbf{C}_m'(u_0 - \\delta)$ 和 $\\mathbf{C}_m'(u_0 + \\delta)$ 来近似单侧导数。它们差的欧几里得范数即为 $J(m)$。\n\n测试套件和要求的输出：\n- 使用场景 A 和场景 B 的控制点。\n- 对于每个场景，为 $m = 1, 2, 3, 4$ 计算数值对 $\\left(D_{\\max}(m), J(m)\\right)$。\n- 将每个报告的浮点结果四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含两个场景的所有结果，形式为方括号内以逗号分隔的列表。排序必须是：\n  - 场景 A：$D_{\\max}(1)$, $J(1)$, $D_{\\max}(2)$, $J(2)$, $D_{\\max}(3)$, $J(3)$, $D_{\\max}(4)$, $J(4)$,\n  - 然后是按相同顺序排列的场景 B。\n也就是说，输出格式为\n$$\n[\\;D_{\\max}^{A}(1),J^{A}(1),D_{\\max}^{A}(2),J^{A}(2),D_{\\max}^{A}(3),J^{A}(3),D_{\\max}^{A}(4),J^{A}(4),D_{\\max}^{B}(1),J^{B}(1),D_{\\max}^{B}(2),J^{B}(2),D_{\\max}^{B}(3),J^{B}(3),D_{\\max}^{B}(4),J^{B}(4)\\;].\n$$\n所有量都是无量纲的，因此不需要单位。",
            "solution": "用户提供了一个关于B样条曲线属性的明确定义的计算问题。我将首先验证问题陈述，然后基于基本原理提供一个全面的解决方案。\n\n### 问题验证\n\n1.  **提取给定条件**：\n    - **曲线类型**：次数为 $p=3$、在 $\\mathbb{R}^2$ 中有 $N=8$ 个控制点的B样条曲线。\n    - **曲线定义**：$\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i$，其中基函数 $N_{i,p}(t)$ 由 Cox–de Boor 递归公式定义。\n    - **曲线导数**：$\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i$，其中 $\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)$。\n    - **节点向量**：开放节点向量，在 $0$ 处有 $p+1=4$ 个节点，在 $1$ 处有 $4$ 个节点。它包含 $N-p-1=4$ 个内部节点。\n    - **内部节点构造**：对于在 $u_0 = 0.5$ 处重数为 $m \\in \\{1,2,3,4\\}$ 的情况，四个内部节点由 $m$ 个 $0.5$ 的副本和集合 $\\{0.25, 0.33, 0.75\\}$ 中最小的 $4-m$ 个值组成，并进行排序。\n    - **控制点场景**：提供了两组控制点，场景 A（驼峰状）和场景 B（局部平坦区域）。\n    - **度量指标**：\n        1.  $D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2$，其中 $\\mathbf{C}_{\\mathrm{base}}$ 是 $m=1$ 时的曲线。评估网格 $\\mathcal{T}$ 在 $(0,1)$ 内有 $4001$ 个点。\n        2.  $J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2$，其中单侧导数在 $u_0 \\pm \\delta$ 处近似。$\\delta$ 定义为 $\\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right)$。\n    - **输出格式**：单行包含一个逗号分隔的列表，内含 $16$ 个浮点数值，四舍五入到六位小数，代表两种场景下每个 $m \\in \\{1,2,3,4\\}$ 的 $(D_{\\max}(m), J(m))$。\n\n2.  **根据标准进行验证**：\n    - **科学性**：该问题植根于B样条的标准数学理论，这是计算科学和计算机辅助几何设计的核心课题。所有定义和公式都是正确的。\n    - **适定性**：问题以高度精确的方式被指定。所有参数、数据、构造规则以及待计算量的公式都已明确给出。该设置是自洽的，足以产生唯一、确定性的解。\n    - **客观性**：问题陈述完全是客观的，使用了精确的数学语言和量化定义。没有主观或模糊的元素。\n    - **其他标准**：该问题并非微不足道，因为它需要从第一性原理正确实现一个不平凡的算法。它没有矛盾、不切实际或不适定的地方。\n\n3.  **结论和行动**：\n    问题陈述是**有效的**。我将继续制定并实施解决方案。\n\n### 解决方案设计\n\n该解决方案需要根据提供的基本定义来实现B样条曲线及其导数的评估。直接递归实现 Cox-de Boor 公式在计算上是低效的。将采用一种更稳健、性能更高的方法，该方法基于标准文献（例如，Piegl 和 Tiller 的《The NURBS Book》）中的算法。这符合“从第一性原理出发”的要求，因为这些算法是数学定义的直接实现。\n\n1.  **核心算法**：\n    - **节点区间搜索**：将实现一个函数 `find_span` 来高效地定位包含给定参数值 $t$ 的节点区间（span）。这是高效评估基函数的前提，通常使用二分搜索实现。\n    - **基函数评估**：将实现一个函数 `basis_funs` 来采用迭代的动态规划方法（来自《The NURBS Book》的算法 A2.2），以计算在其节点区间内，给定次数和参数 $t$ 的所有非零基函数的值。这比朴素的递归方法效率高得多。\n    - **曲线评估**：函数 `evaluate_bspline` 将结合 `find_span` 和 `basis_funs` 来计算曲线 $\\mathbf{C}(t)$ 上的点。它找到相关的节点区间，计算非零基函数，然后将它们与相应的控制点进行加权求和。\n    - **曲线导数评估**：函数 `evaluate_bspline_derivative` 将通过直接实现求和 $\\sum_i \\frac{d N_{i,p}(t)}{dt} \\mathbf{P}_i$ 来计算 $\\mathbf{C}'(t)$。基函数的导数 $\\frac{d N_{i,p}(t)}{dt}$ 将使用提供的公式计算，而这又需要次数为 $p-1$ 的基函数。这些将使用相同的 `basis_funs` 算法高效计算。\n\n2.  **单个案例（$m$，场景）的工作流程**：\n    - **节点向量构造**：通过连接起始重复节点（$p+1$ 个零）、四个指定的内部节点和结尾重复节点（$p+1$ 个一），构造出长度为 $N+p+1=12$ 的完整节点向量。\n    - **$D_{\\max}$ 的曲线评估**：对于每个 $m$，在 $(0,1)$ 内的 $4001$ 个采样点上评估曲线 $\\mathbf{C}_m(t)$。对于 $m=1$，这些点定义了基准曲线 $\\mathbf{C}_{\\mathrm{base}}$。对于 $m1$，计算与相应基准点的欧几里得距离，这些距离的最大值即为 $D_{\\max}(m)$。根据定义，$D_{\\max}(1)=0$。\n    - **$J(m)$ 的导数跳跃计算**：根据问题的规则确定小偏移量 $\\delta$。在 $u_0 - \\delta$ 和 $u_0 + \\delta$ 处评估导数 $\\mathbf{C}_m'(t)$。这两个导数向量之差的欧几里得范数即为跳跃值 $J(m)$。B样条的连续性性质表明，$J(1)$ 和 $J(2)$ 应接近于零，而 $J(3)$ 和 $J(4)$ 可能显著非零，这为实现提供了一个很好的健全性检查。\n\n3.  **整体结构**：\n    主程序将遍历两种控制点场景。在每个场景内，它将遍历从 $1$ 到 $4$ 的重数 $m$。在每个子案例中，它将构造相应的节点向量，计算数值对 $(D_{\\max}(m), J(m))$，并存储结果。最后，所有 $16$ 个标量结果将按要求格式化为单个字符串。",
            "answer": "```python\nimport numpy as np\n\ndef find_span(num_cp, degree, t, knots):\n    \"\"\"\n    Finds the knot span index for a given parameter t.\n    num_cp: number of control points (N).\n    degree: degree of the curve (p).\n    t: parameter value.\n    knots: knot vector.\n    Returns the index k such that knots[k] = t  knots[k+1].\n    \"\"\"\n    # For t=1.0, which can occur at the end of the domain for an open knot vector.\n    # The valid parameter range is [knots[p], knots[N]]. For an open knot vector,\n    # this is [0, 1]. The last span index is N-1.\n    if t >= knots[num_cp]:\n        return num_cp - 1\n    \n    # Binary search for the span. The search space is [p, N-1].\n    low = degree\n    high = num_cp\n    \n    while low  high:\n        mid = (low + high) // 2\n        if t  knots[mid]:\n            high = mid\n        else:\n            low = mid + 1\n    return low - 1\n\ndef basis_funs(span, t, degree, knots):\n    \"\"\"\n    Computes the non-zero B-spline basis functions for a given parameter t.\n    (Algorithm A2.2 from The NURBS Book by Piegl and Tiller).\n    span: knot span index.\n    t: parameter value.\n    degree: degree of the curve.\n    knots: knot vector.\n    Returns an array of p+1 basis function values, N_{span-degree, degree}, ..., N_{span, degree}.\n    \"\"\"\n    basis = np.zeros(degree + 1)\n    left = np.zeros(degree + 1)\n    right = np.zeros(degree + 1)\n    \n    basis[0] = 1.0\n    for j in range(1, degree + 1):\n        left[j] = t - knots[span + 1 - j]\n        right[j] = knots[span + j] - t\n        saved = 0.0\n        for r in range(j):\n            den = knots[span + r + 1] - knots[span + r + 1 - j]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = basis[r] / den\n            basis[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        basis[j] = saved\n    return basis\n\ndef evaluate_bspline(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t > knots[num_cp]:\n        if t = knots[degree]: return control_points[0]\n        else: return control_points[-1]\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values = basis_funs(span, t, degree, knots)\n    \n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(degree + 1):\n        curve_point += basis_values[i] * control_points[span - degree + i]\n    return curve_point\n\ndef evaluate_bspline_derivative(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates the derivative of a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t > knots[num_cp]:\n        return np.zeros_like(control_points[0], dtype=float)\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values_p_minus_1 = basis_funs(span, t, degree - 1, knots)\n    \n    deriv_point = np.zeros_like(control_points[0], dtype=float)\n    \n    for i in range(span - degree, span + 1):\n        # Contribution from control point P_i\n        # dN_{i,p}/dt = p/(t_{i+p}-t_i) * N_{i,p-1} - p/(t_{i+p+1}-t_{i+1}) * N_{i+1,p-1}\n        \n        # Term 1: involving N_{i, p-1}\n        num1 = 0.0\n        # The non-zero basis functions of degree p-1 for span k are N_{k-(p-1),p-1} to N_{k,p-1}\n        # In our case, span=span, degree=p-1. So N_{span-(p-1),p-1} to N_{span,p-1}.\n        if (span - (degree - 1)) = i = span:\n            num1 = basis_values_p_minus_1[i - (span - (degree - 1))]\n        \n        den1 = knots[i + degree] - knots[i]\n        term1 = 0.0\n        if den1 != 0.0:\n            term1 = degree * num1 / den1\n\n        # Term 2: involving N_{i+1, p-1}\n        num2 = 0.0\n        if (span - (degree - 1)) = (i + 1) = span:\n            num2 = basis_values_p_minus_1[i + 1 - (span - (degree - 1))]\n\n        den2 = knots[i + degree + 1] - knots[i + 1]\n        term2 = 0.0\n        if den2 != 0.0:\n            term2 = degree * num2 / den2\n        \n        d_basis = term1 - term2\n        deriv_point += d_basis * control_points[i]\n        \n    return deriv_point\n\n\ndef solve():\n    p = 3\n    N = 8\n    u0 = 0.5\n    \n    P_A = np.array([\n        [0.0, 0.0], [1.0, 1.0], [2.0, 2.0], [3.0, 4.0],\n        [4.0, 2.0], [5.0, 1.5], [6.0, 1.2], [7.0, 1.1]\n    ], dtype=float)\n    \n    P_B = np.array([\n        [0.0, 0.0], [1.0, 0.5], [2.0, 1.0], [3.0, 1.0],\n        [4.0, 1.0], [5.0, 1.0], [6.0, 1.2], [7.0, 2.0]\n    ], dtype=float)\n\n    scenarios = [(\"A\", P_A), (\"B\", P_B)]\n    interior_knot_pool = [0.25, 0.33, 0.75]\n    \n    t_samples = np.linspace(1e-6, 1.0 - 1e-6, 4001)\n    \n    all_results = []\n    \n    for _, P in scenarios:\n        C_base_pts = None\n        \n        for m in range(1, 5):\n            # 1. Construct knot vector\n            num_other_knots = 4 - m\n            interior_knots = sorted(interior_knot_pool[:num_other_knots] + [u0] * m)\n            knots = np.concatenate((np.zeros(p + 1, dtype=float), np.array(interior_knots, dtype=float), np.ones(p + 1, dtype=float)))\n\n            # 2. Compute curve points for D_max calculation\n            C_m_pts = np.array([evaluate_bspline(t, N, p, knots, P) for t in t_samples])\n            \n            if m == 1:\n                C_base_pts = C_m_pts\n                D_max = 0.0\n            else:\n                deviations = np.linalg.norm(C_m_pts - C_base_pts, axis=1)\n                D_max = np.max(deviations)\n\n            # 3. Compute slope discontinuity J(m)\n            unique_knots = sorted(list(set(knots)))\n            u_L_idx = np.searchsorted(unique_knots, u0, side='left') - 1\n            u_R_idx = np.searchsorted(unique_knots, u0, side='right')\n            u_L = unique_knots[u_L_idx] if u_L_idx >= 0 else knots[0]\n            u_R = unique_knots[u_R_idx] if u_R_idx  len(unique_knots) else knots[-1]\n            \n            term_L = 0.1 * (u0 - u_L) if u_L  u0 else np.inf\n            term_R = 0.1 * (u_R - u0) if u_R > u0 else np.inf\n            delta = min(term_L, term_R, 1e-3)\n            \n            dC_left = evaluate_bspline_derivative(u0 - delta, N, p, knots, P)\n            dC_right = evaluate_bspline_derivative(u0 + delta, N, p, knots, P)\n            J_m = np.linalg.norm(dC_right - dC_left)\n            \n            all_results.extend([D_max, J_m])\n            \n    print(f\"[{','.join(f'{r:.6f}' for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们将我们的知识应用到几何建模中的一个经典而实际的问题上：寻找 B 样条曲线上距离任意外部点最近的点。这个练习将 B 样条微积分与数值优化相结合，要求你实现一个稳健的 Newton-Raphson 方法 ()。成功完成此任务表明你不仅掌握了 B 样条的理论，还掌握了其在解决实际计算挑战中的应用。",
            "id": "3207471",
            "problem": "设计并实现一个完整且数值稳定的程序，该程序针对给定的平面B样条曲线和一组外部点，使用带有安全保障的牛顿-拉夫逊（Newton–Raphson）方法，计算曲线上离每个外部点最近的点。该曲线由一个次数、一个非递减的节点向量以及一个控制点序列定义。您的实现必须是自包含的，且不得读取任何输入。\n\n您必须从以下基本定义和事实出发。\n\n1. 一条次数为 $p$、控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^n \\subset \\mathbb{R}^2$、非递减节点向量为 $\\{U_j\\}_{j=0}^m$ 的B样条曲线，由参数域 $u \\in [U_p, U_{m-p}]$ 上的B样条基函数 $\\{N_{i,p}(u)\\}_{i=0}^n$ 的线性组合给出，即 $\\mathbf{C}(u) = \\sum_{i=0}^n N_{i,p}(u)\\,\\mathbf{P}_i$。Cox–de Boor 递推公式定义 $N_{i,0}(u)$ 为：如果 $U_i \\le u  U_{i+1}$ 则 $N_{i,0}(u) = 1$，否则为 $0$；对于 $p \\ge 1$，$N_{i,p}(u) = \\alpha_{i,p}(u)\\,N_{i,p-1}(u) + \\beta_{i+1,p}(u)\\,N_{i+1,p-1}(u)$，其系数为 $\\alpha_{i,p}(u) = \\dfrac{u - U_i}{U_{i+p} - U_i}$（当分母为0时，解释为0）和 $\\beta_{i+1,p}(u) = \\dfrac{U_{i+p+1} - u}{U_{i+p+1} - U_{i+1}}$（当分母为0时，解释为0）。de Boor 算法是 $\\mathbf{C}(u)$ 的一种数值稳定的求值方法，它在代数上等价于上述递推。\n2. 曲线上一点到固定点 $\\mathbf{q} \\in \\mathbb{R}^2$ 的欧几里得距离平方为 $d^2(u) = \\|\\mathbf{C}(u) - \\mathbf{q}\\|_2^2$。在闭区间 $[U_p, U_{m-p}]$ 上最小化 $\\tfrac{1}{2} d^2(u)$ 可得到最近点。您必须从第一性原理出发推导 $\\tfrac{1}{2} d^2(u)$ 关于 $u$ 的一阶和二阶导数，用 $\\mathbf{C}(u)$、$\\mathbf{C}'(u)$ 和 $\\mathbf{C}''(u)$ 表示，并在牛顿-拉夫逊（Newton–Raphson）迭代中使用这些导数。在没有根据微分定义和链式法则进行论证的情况下，不要假定任何导数公式。\n\n您的算法设计要求如下。\n\n- 使用 de Boor 算法来计算 $\\mathbf{C}(u)$，并构造导数控制多边形来可靠地计算 $\\mathbf{C}'(u)$ 和 $\\mathbf{C}''(u)$。对于导数控制多边形，请使用经过充分检验的、连续控制点与节点向量之间的有限差分关系；不要在代码中对基函数进行符号微分。\n- 对通过微分 $\\tfrac{1}{2} d^2(u)$ 得到的标量函数实现一个带有安全保障的牛顿-拉夫逊（Newton–Raphson）方法。您的方法必须包含以下所有数值安全保障措施：\n  1. 参数域投影，将迭代值保持在闭区间 $[U_p, U_{m-p}]$ 内。\n  2. 通过在定义域上扫描一个包含 $M$ 个采样参数的均匀网格来检测一阶导数的符号变化，从而实现根的区间限定；随后在每个区间内执行一个带有安全保障的牛顿步，当牛顿步超出该区间或曲率信息不可靠时，该步骤将退化为二分法。\n  3. 当从有希望的种子点开始运行无区间限定的投影牛顿法进行精化时，采用一种阻尼或回溯步长策略，以防止 $\\tfrac{1}{2} d^2(u)$ 的值增加。\n  4. 全局最小化子的选择，通过评估求根阶段返回的所有平稳候选点以及两个边界参数 $U_p$ 和 $U_{m-p}$ 处的距离平方来实现。\n\n测试和输出规范。\n\n- 使用以下测试曲线数据（所有坐标和节点都是无单位的）：\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0 = (0,0)$, $\\mathbf{P}_1 = (1,2)$, $\\mathbf{P}_2 = (3,3)$, $\\mathbf{P}_3 = (6,2)$, $\\mathbf{P}_4 = (7,0)$, $\\mathbf{P}_5 = (8,-1)$。\n  - 开放均匀节点向量 $U = [0,0,0,0,\\tfrac{1}{3},\\tfrac{2}{3},1,1,1,1]$。\n  - 因此，参数域为 $[0,1]$。\n- 使用以下外部查询点 $\\mathbf{q}$ 集合来构成您的测试套件：\n  1. $\\mathbf{q}_1 = (4,1.5)$，一个一般位置点。\n  2. $\\mathbf{q}_2 = (0,0)$，恰好在曲线的左端点。\n  3. $\\mathbf{q}_3 = (10,-2)$，远在曲线右侧。\n  4. $\\mathbf{q}_4 = (2.5,2.5)$，靠近曲线内部。\n  5. $\\mathbf{q}_5 = (6.8,-0.8)$，靠近曲线右侧部分。\n- 实现细节：\n  - 使用双精度浮点运算。\n  - 使用包含 $M = 200$ 个采样点的均匀网格进行初始区间限定。\n  - 在牛顿-拉夫逊方法中，对一阶导数的绝对值使用 $\\varepsilon = 10^{-10}$ 的收敛容差，对于区间收缩，使用 $\\delta = 10^{-12}$ 的参数容差。将每个根的带安全保障的最大迭代次数限制为50次。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须为每个测试点包含一个条目，顺序与输入相同，每个条目是一个包含两个元素的列表 $[u^\\star, d]$。其中，$u^\\star$ 是 $[0,1]$ 区间内的最小化参数，$d$ 是外部点到曲线上最近点的欧几里得距离。两个条目都必须是浮点数。例如，输出格式应类似于 $[[u_1,d_1],[u_2,d_2],[u_3,d_3],[u_4,d_4],[u_5,d_5]]$，不含空格。",
            "solution": "所提出的问题是，对于给定的平面B样条曲线和一组查询点，确定曲线上的参数 $u^\\star$，该参数对应的点 $\\mathbf{C}(u^\\star)$ 离每个查询点最近。这是计算几何学中一个经典的非线性优化问题。\n\n首先根据指定标准对问题进行验证。\n\n### 步骤1：提取给定条件\n- **曲线定义**：一条次数为 $p$ 的B样条曲线定义为 $\\mathbf{C}(u) = \\sum_{i=0}^n N_{i,p}(u)\\,\\mathbf{P}_i$，其参数 $u \\in [U_p, U_{m-p}]$，控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^n \\subset \\mathbb{R}^2$，非递减节点向量为 $\\{U_j\\}_{j=0}^m$。关系式 $m=n+p+1$ 成立。\n- **基函数**：基函数 $N_{i,p}(u)$ 由 Cox–de Boor 递推公式定义。\n- **求值**：指定使用 de Boor 算法对 $\\mathbf{C}(u)$ 进行数值稳定的求值。\n- **目标函数**：要最小化的量是曲线上一点到固定外部点 $\\mathbf{q}$ 的欧几里得距离平方 $d^2(u) = \\|\\mathbf{C}(u) - \\mathbf{q}\\|_2^2$，或等价地，最小化 $f(u) = \\tfrac{1}{2} d^2(u)$。\n- **导数**：必须从第一性原理推导 $f(u)$ 的一阶和二阶导数，并用于牛顿-拉夫逊（Newton–Raphson）方法中。曲线导数 $\\mathbf{C}'(u)$ 和 $\\mathbf{C}''(u)$ 将通过导数控制多边形计算。\n- **算法**：要求使用带有安全保障的牛顿-拉夫逊（Newton–Raphson）方法，该方法包含：1) 域投影，2) 带有退化为二分法机制的根的区间限定，3) 用于无区间限定精化的阻尼/回溯步，以及 4) 从驻点和边界点中选择全局最小值。\n- **测试数据**：\n  - 次数：$p = 3$。\n  - 控制点：$\\mathbf{P}_0 = (0,0)$、$\\mathbf{P}_1 = (1,2)$、$\\mathbf{P}_2 = (3,3)$、$\\mathbf{P}_3 = (6,2)$、$\\mathbf{P}_4 = (7,0)$、$\\mathbf{P}_5 = (8,-1)$。这意味着 $n=5$。\n  - 节点向量：$U = [0,0,0,0,\\tfrac{1}{3},\\tfrac{2}{3},1,1,1,1]$。这意味着 $m=9$。关系式 $m=n+p+1$（$9=5+3+1$）得到满足。\n  - 参数域：$[U_p, U_{m-p}] = [U_3, U_6] = [0,1]$。\n  - 查询点：$\\mathbf{q}_1 = (4,1.5)$、$\\mathbf{q}_2 = (0,0)$、$\\mathbf{q}_3 = (10,-2)$、$\\mathbf{q}_4 = (2.5,2.5)$、$\\mathbf{q}_5 = (6.8,-0.8)$。\n- **数值参数**：\n  - 网格采样点数：$M = 200$。\n  - 收敛容差（导数）：$\\varepsilon = 10^{-10}$。\n  - 收敛容差（参数）：$\\delta = 10^{-12}$。\n  - 最大迭代次数：$50$。\n- **输出格式**：单行 `[[u1,d1],[u2,d2],...]`，其中 $u_k$ 是最优参数，$d_k$ 是第 $k$ 个查询点的最小距离。\n\n### 步骤2：使用提取的给定条件进行验证\n对问题进行验证：\n- **科学依据**：该问题是数值方法和计算机辅助几何设计中一个标准且经过深入研究的课题。所有概念（B样条、de Boor算法、牛顿法）都是基础性的，并且陈述正确。\n- **适定性**：最近点的存在性由极值定理保证，因为我们是在一个紧集（曲线的参数域）上最小化一个连续函数（距离）。所要求的算法是寻找全局最小值的一个鲁棒过程。\n- **客观性**：该问题使用精确的数学和算法语言进行描述，没有任何主观性。\n- **完整性和一致性**：所有必要数据，包括曲线定义、查询点和算法的数值参数，均已提供。B样条的 $m=n+p+1$ 关系得到满足。数据是自洽的。\n- **可行性**：所指定算法的实现虽然复杂，但在给定环境（带有NumPy的Python）下是完全可行的。\n\n### 步骤3：结论与行动\n问题是 **有效的**。它具有科学依据、是适定的、客观的、完整的、一致的且可行的。我现在将提供一个完整的解决方案。\n\n### 基于原理的解决方案\n问题的核心是找到参数 $u^\\star$，该参数能最小化B样条曲线上一点 $\\mathbf{C}(u)$ 与给定外部点 $\\mathbf{q}$ 之间的距离。这等价于最小化距离平方函数，该函数在计算上更方便，因为它避免了开方运算。\n设目标函数为 $f(u)$：\n$$f(u) = \\frac{1}{2} \\|\\mathbf{C}(u) - \\mathbf{q}\\|_2^2 = \\frac{1}{2} (\\mathbf{C}(u) - \\mathbf{q}) \\cdot (\\mathbf{C}(u) - \\mathbf{q})$$\n最小化在有效参数域 $u \\in [U_p, U_{m-p}]$ 上执行。在域内任意内部点取得局部最小值的必要条件是目标函数的一阶导数为零。\n\n**1. 目标函数的导数**\n我们使用向量值函数的链式法则和乘积法则来推导 $f(u)$ 所需的导数。设 $\\mathbf{r}(u) = \\mathbf{C}(u) - \\mathbf{q}$。则 $f(u) = \\frac{1}{2} \\mathbf{r}(u) \\cdot \\mathbf{r}(u)$。\n\n一阶导数 $f'(u)$ 为：\n$$f'(u) = \\frac{d}{du} \\left( \\frac{1}{2} \\mathbf{r}(u) \\cdot \\mathbf{r}(u) \\right) = \\mathbf{r}'(u) \\cdot \\mathbf{r}(u)$$\n由于 $\\mathbf{r}'(u) = \\mathbf{C}'(u) - \\frac{d\\mathbf{q}}{du} = \\mathbf{C}'(u)$（因为 $\\mathbf{q}$ 是一个常数点），我们得到：\n$$f'(u) = \\mathbf{C}'(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q})$$\n$f(u)$ 的驻点是标量方程 $f'(u) = 0$ 的根。这个条件有一个清晰的几何解释：从查询点到曲线上最近点的向量 $\\mathbf{C}(u) - \\mathbf{q}$ 必须与曲线的切向量 $\\mathbf{C}'(u)$ 正交。\n\n二阶导数 $f''(u)$ 可通过对 $f'(u)$ 使用乘积法则关于 $u$ 求导得到：\n$$f''(u) = \\frac{d}{du} \\left( \\mathbf{C}'(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q}) \\right) = \\mathbf{C}''(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q}) + \\mathbf{C}'(u) \\cdot \\mathbf{C}'(u)$$\n$$f''(u) = \\mathbf{C}''(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q}) + \\|\\mathbf{C}'(u)\\|_2^2$$\n这两个导数 $f'(u)$ 和 $f''(u)$ 构成了求解 $f'(u)$ 根的牛顿-拉夫逊（Newton–Raphson）方法的基础。迭代公式为 $u_{k+1} = u_k - \\frac{f'(u_k)}{f''(u_k)}$。\n\n**2. B样条曲线及其导数求值**\n为了计算 $f'(u)$ 和 $f''(u)$，我们需要 $\\mathbf{C}(u)$、$\\mathbf{C}'(u)$ 和 $\\mathbf{C}''(u)$。按照规定，这些值通过数值方法计算。\n$\\mathbf{C}(u)$ 使用 de Boor 算法进行求值，该算法是一种数值稳定的递推关系，作用于包含 $u$ 的节点区间内的控制点。\nB样条曲线的导数本身是次数更低的B样条曲线。一条次数为 $p$、控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^n$、节点向量为 $\\{U_j\\}_{j=0}^m$ 的B样条曲线 $\\mathbf{C}(u)$，其导数 $\\mathbf{C}'(u)$ 是一条次数为 $p-1$ 的B样条曲线。它的控制点 $\\{\\mathbf{P}'_i\\}_{i=0}^{n-1}$ 和节点向量 $\\{U'_j\\}_{j=0}^{m-2}$ 是从原始曲线推导出来的。控制点由下式给出：\n$$\\mathbf{P}'_i = p \\frac{\\mathbf{P}_{i+1} - \\mathbf{P}_i}{U_{i+p+1} - U_{i+1}} \\quad \\text{for } i \\in [0, n-1]$$\n$\\mathbf{C}'(u)$ 的节点向量是 $\\{U_j\\}_{j=1}^{m-1}$。然后通过对这个新定义的曲线应用 de Boor 算法来计算 $\\mathbf{C}'(u)$。二阶导数 $\\mathbf{C}''(u)$ 是通过对 $\\mathbf{C}'(u)$ 应用相同的过程得到的。这会产生一条次数为 $p-2$ 的B样条曲线，其控制点 $\\{\\mathbf{P}''_i\\}$ 和节点可以类似地推导出来。\n\n**3. 数值最小化算法**\n在紧区间 $[U_p, U_{m-p}]$ 上，$f(u)$ 的全局最小值必然出现在边界点（$U_p$ 或 $U_{m-p}$）或 $f'(u)=0$ 的内部点。该算法系统地找出所有这些候选点，并选择产生最小距离的那个。\n\n**阶段1：区间限定与带安全保障的求根**\n为确保找到 $f'(u)$ 的所有根，首先对定义域 $[U_p, U_{m-p}]$ 进行扫描。\n1.  创建一个包含 $M=200$ 个参数值 $\\{u_j\\}_{j=0}^{M-1}$ 的均匀网格。\n2.  为每个网格点计算 $f'(u_j)$。\n3.  任何使得 $f'(u_j)$ 和 $f'(u_{j+1})$ 符号相反的区间 $[u_j, u_{j+1}]$ 都必须包含至少一个根。这些区间成为求根算法的限定区间。\n4.  对每个限定区间，采用带有安全保障的牛顿-拉夫逊方法。从一个初始猜测（例如，区间的中点）开始，计算标准的牛顿步 $u_{k+1} = u_k - f'(u_k)/f''(u_k)$。\n    -   **安全保障**：如果新的估计值 $u_{k+1}$ 落在了限定区间之外，或者 $|f''(u_k)|$ 接近于零（表示这是一个不可靠的步），该方法将退化为二分法步，$u_{k+1} = (a+b)/2$，其中 $[a, b]$ 是当前的限定区间。\n    -   根据 $f'(u_{k+1})$ 的符号更新限定区间。迭代过程持续进行，直到限定区间的宽度小于容差 $\\delta=10^{-12}$ 或 $|f'(u_k)|$ 小于容差 $\\varepsilon=10^{-10}$。将得到的根添加到一个候选参数集合中。\n\n**阶段2：从有希望的种子点进行无区间限定的精化**\n如果 $f'(u)$ 触及零点但未穿越（即偶数重根），或者两个根非常接近，区间限定阶段可能会漏掉根。为了找到额外的候选者，我们在网格上搜索距离本身的局部最小值。\n1.  为每个网格点 $u_j$ 计算距离平方 $d^2(u_j)$。\n2.  在网格上是局部最小值的点 $u_j$（即 $d^2(u_{j-1}) > d^2(u_j)  d^2(u_{j+1})$）被识别为“有希望的种子点”。\n3.  从每个种子点开始，启动一个投影、阻尼的牛顿法来精化局部最小值的估计。\n    -   **投影**：在每一步之后，新的参数值被限制在有效域 $[U_p, U_{m-p}]$ 内。\n    -   **阻尼/回溯**：牛顿步旨在找到 $f'(u)$ 的根，而不一定能减小 $f(u)$。为了确保进展，使用回溯线搜索。只有当完整步长能够减小目标函数 $f(u)$ 时才采用。否则，步长将连续减半，直到实现减小或步长变得过小。\n    这个精化过程会产生额外的候选参数。\n\n**阶段3：全局最小值选择**\n最终的候选集包括：\n- 定义域的边界参数 $U_p$ 和 $U_{m-p}$。\n- 通过带安全保障的、有区间限定的求根器找到的所有根。\n- 从无区间限定搜索中得到的所有精化的局部最小值。\n\n移除重复项后，对该集合中的每个候选参数 $u$ 计算目标函数 $f(u)$ 的值。产生 $f(u)$ 最小值的参数 $u^\\star$ 就是全局最优参数。最终的最近距离是 $d = \\sqrt{2f(u^\\star)} = \\|\\mathbf{C}(u^\\star) - \\mathbf{q}\\|_2$。这种全面的搜索策略是鲁棒的，旨在找到真正的全局最小值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_span(n, p, u, U):\n    \"\"\"\n    Determine the knot span index.\n    n: number of control points - 1\n    p: degree\n    u: parameter\n    U: knot vector\n    \"\"\"\n    # For open knot vectors, the end of the domain needs special handling.\n    if u >= U[n + 1]:\n        return n\n    \n    low = p\n    high = n + 1\n    mid = (low + high) // 2\n    \n    while u  U[mid] or u >= U[mid + 1]:\n        if u  U[mid]:\n            high = mid\n        else:\n            low = mid\n        mid = (low + high) // 2\n    return mid\n\ndef de_boor(p, U, P, u):\n    \"\"\"\n    Evaluate curve point and derivatives using de Boor's algorithm.\n    p: degree\n    U: knot vector\n    P: control points\n    u: parameter\n    Returns: C(u), C'(u), C''(u)\n    \"\"\"\n    n = len(P) - 1\n    \n    # --- C(u) ---\n    span = find_span(n, p, u, U)\n    pts = P[span - p : span + 1].copy()\n    for r in range(1, p + 1):\n        for j in range(p, r - 1, -1):\n            alpha = (u - U[span - p + j]) / (U[span - p + j + p - r + 1] - U[span - p + j])\n            pts[j] = (1.0 - alpha) * pts[j - 1] + alpha * pts[j]\n    C = pts[p]\n\n    # --- C'(u) ---\n    if p > 0:\n        P_prime = []\n        for i in range(n):\n            denom = U[i + p + 1] - U[i + 1]\n            if denom > 1e-12:\n                P_prime.append(p * (P[i + 1] - P[i]) / denom)\n            else:\n                # This case is complex, but for non-degenerate curves it's often zero\n                # or handled by context. For this problem, assume non-zero denominator.\n                P_prime.append(np.zeros_like(P[0]))\n        \n        P_prime = np.array(P_prime)\n        U_prime = U[1:-1]\n        \n        span_prime = find_span(len(P_prime) - 1, p - 1, u, U_prime)\n        pts_prime = P_prime[span_prime - (p - 1) : span_prime + 1].copy()\n\n        for r in range(1, p):\n            for j in range(p - 1, r - 1, -1):\n                alpha = (u - U_prime[span_prime - (p - 1) + j]) / (U_prime[span_prime - (p - 1) + j + (p - 1) - r + 1] - U_prime[span_prime - (p - 1) + j])\n                pts_prime[j] = (1.0 - alpha) * pts_prime[j - 1] + alpha * pts_prime[j]\n        C_prime = pts_prime[p - 1]\n    else:\n        C_prime = np.zeros_like(C)\n\n    # --- C''(u) ---\n    if p > 1:\n        P_prime2 = []\n        n_prime = len(P_prime) - 1\n        p_prime = p - 1\n        for i in range(n_prime):\n            denom = U_prime[i + p_prime + 1] - U_prime[i + 1]\n            if denom > 1e-12:\n                P_prime2.append(p_prime * (P_prime[i + 1] - P_prime[i]) / denom)\n            else:\n                P_prime2.append(np.zeros_like(P[0]))\n        \n        P_prime2 = np.array(P_prime2)\n        U_prime2 = U_prime[1:-1]\n        \n        span_prime2 = find_span(len(P_prime2) - 1, p - 2, u, U_prime2)\n        pts_prime2 = P_prime2[span_prime2 - (p - 2) : span_prime2 + 1].copy()\n        for r in range(1, p-1):\n            for j in range(p - 2, r - 1, -1):\n                alpha = (u - U_prime2[span_prime2 - (p - 2) + j]) / (U_prime2[span_prime2 - (p - 2) + j + (p - 2) - r + 1] - U_prime2[span_prime2 - (p - 2) + j])\n                pts_prime2[j] = (1.0 - alpha) * pts_prime2[j - 1] + alpha * pts_prime2[j]\n\n        C_prime2 = pts_prime2[p - 2]\n    else:\n        C_prime2 = np.zeros_like(C)\n\n    return C, C_prime, C_prime2\n\ndef find_closest_point(p, U, P, q, M, epsilon, delta, max_iter):\n    u_min, u_max = U[p], U[len(P)]\n\n    memo = {}\n    def get_ders(u):\n        u_rounded = round(u, 15) # Mitigate floating point re-computation issues\n        if u_rounded not in memo:\n            memo[u_rounded] = de_boor(p, U, P, u)\n        return memo[u_rounded]\n\n    def obj_fun_prime(u):\n        C, C_prime, _ = get_ders(u)\n        return np.dot(C_prime, C - q)\n    \n    def obj_fun_second(u):\n        C, C_prime, C_prime2 = get_ders(u)\n        return np.dot(C_prime2, C - q) + np.dot(C_prime, C_prime)\n\n    candidates = {u_min, u_max}\n\n    # Stage 1: Bracketing and Safeguarded Root-Finding\n    grid = np.linspace(u_min, u_max, M)\n    grid_vals = np.array([obj_fun_prime(u) for u in grid])\n    \n    for i in range(M - 1):\n        if np.sign(grid_vals[i]) != np.sign(grid_vals[i+1]):\n            a, b = grid[i], grid[i+1]\n            u_k = (a + b) / 2.0\n            for _ in range(max_iter):\n                if b - a  delta: break\n                \n                f_prime = obj_fun_prime(u_k)\n                if abs(f_prime)  epsilon: break\n\n                f_second = obj_fun_second(u_k)\n                if abs(f_second) > 1e-9:\n                    u_next = u_k - f_prime / f_second\n                    if u_next > a and u_next  b:\n                        u_k = u_next\n                    else:\n                        u_k = (a + b) / 2.0\n                else: # Unreliable curvature, revert to bisection\n                    u_k = (a + b) / 2.0\n                \n                f_prime_next = obj_fun_prime(u_k)\n                if np.sign(f_prime_next) == np.sign(obj_fun_prime(a)):\n                    a = u_k\n                else:\n                    b = u_k\n            \n            candidates.add(np.clip(u_k, u_min, u_max))\n\n    # Stage 2: Unbracketed Refinement (Optional, but included for robustness as per spec)\n    # The bracketed search is generally quite effective. For simplicity and to meet spec,\n    # we can consider local minima of distance on grid as seeds.\n    dist_sq_grid = [np.sum((de_boor(p, U, P, u)[0] - q)**2) for u in grid]\n    for i in range(1, M - 1):\n        if dist_sq_grid[i-1] > dist_sq_grid[i]  dist_sq_grid[i+1]:\n            u_k = grid[i]\n            for _ in range(max_iter):\n                f_prime = obj_fun_prime(u_k)\n                if abs(f_prime)  epsilon: break\n                \n                f_second = obj_fun_second(u_k)\n                if abs(f_second) > 1e-9:\n                    # Damped Newton step\n                    step = -f_prime/f_second\n                    alpha = 1.0\n                    current_dist_sq = np.sum((de_boor(p, U, P, u_k)[0] - q)**2)\n                    \n                    for _ in range(5): # Backtracking\n                        u_next = np.clip(u_k + alpha * step, u_min, u_max)\n                        next_dist_sq = np.sum((de_boor(p, U, P, u_next)[0] - q)**2)\n                        if next_dist_sq  current_dist_sq:\n                            break\n                        alpha /= 2.0\n                    else: # Damping failed, fall back to gradient descent\n                        alpha = 0.1 # Small-ish learning rate\n                        u_next = np.clip(u_k - alpha * f_prime, u_min, u_max)\n                    \n                    if abs(u_next - u_k)  delta: break\n                    u_k = u_next\n                else: # Gradient descent-like step if curvature is zero\n                    u_k = np.clip(u_k - 0.01 * f_prime, u_min, u_max)\n            candidates.add(u_k)\n\n    # Stage 3: Global Minimum Selection\n    best_u = -1\n    min_dist_sq = float('inf')\n    \n    for u in candidates:\n        C = de_boor(p, U, P, u)[0]\n        dist_sq = np.sum((C - q)**2)\n        if dist_sq  min_dist_sq:\n            min_dist_sq = dist_sq\n            best_u = u\n            \n    return [best_u, np.sqrt(min_dist_sq)]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n    # Test curve data\n    p = 3\n    P = np.array([\n        [0.0, 0.0], [1.0, 2.0], [3.0, 3.0], \n        [6.0, 2.0], [7.0, 0.0], [8.0, -1.0]\n    ])\n    U = np.array([0.0, 0.0, 0.0, 0.0, 1/3, 2/3, 1.0, 1.0, 1.0, 1.0])\n\n    # External query points\n    queries = [\n        np.array([4.0, 1.5]),\n        np.array([0.0, 0.0]),\n        np.array([10.0, -2.0]),\n        np.array([2.5, 2.5]),\n        np.array([6.8, -0.8]),\n    ]\n\n    # Numerical parameters\n    M = 200\n    epsilon = 1e-10\n    delta = 1e-12\n    max_iter = 50\n\n    results = []\n    for q in queries:\n        u_star, dist = find_closest_point(p, U, P, q, M, epsilon, delta, max_iter)\n        results.append(f\"[{u_star},{dist}]\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}