{
    "hands_on_practices": [
        {
            "introduction": "要理解龙格现象的根本原因，我们需要探究插值多项式构造的内在机制。重心插值公式为我们提供了一个稳定的计算框架，其核心是重心权重。这个练习将引导你深入分析均匀分布节点下的重心权重，通过计算权重大小的比率，你将亲眼见证中心节点与端点节点权重的巨大差异，从而揭示导致插值不稳定的一个关键因素。",
            "id": "2199710",
            "problem": "在多项式插值的研究中，插值点（节点）的选择显著影响所得多项式的准确性和稳定性。重心插值公式提供了一种数值稳定的方法来计算插值多项式，其性质与称为重心权的量密切相关。\n\n考虑在区间 $[-1, 1]$ 上的 $n+1$ 个均匀分布的插值节点 $x_j$，其中 $j=0, 1, \\ldots, n$。节点由公式 $x_j = -1 + j \\cdot h$ 给出，其中步长为 $h = \\frac{2}{n}$。\n\n节点 $x_j$ 的重心权 $w_j$ 定义为：\n$$\nw_j = \\left(\\prod_{k=0, k \\neq j}^{n} (x_j - x_k)\\right)^{-1}\n$$\n\n对于 $n=10$ 的特定情况（此时有 11 个插值节点），确定比值 $\\frac{|w_{10}|}{|w_5|}$ 的精确值。该比值比较了区间右端点（$x_{10}=1$）的重心权大小与区间中心点（$x_5=0$）的重心权大小。\n\n将最终答案表示为最简分数形式。",
            "solution": "我们有均匀间隔的节点 $x_{j}=-1+jh$，其中 $h=\\frac{2}{n}$ 且 $j=0,1,\\ldots,n$。重心权为\n$$\nw_{j}=\\left(\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})\\right)^{-1}.\n$$\n对于均匀间隔，\n$$\nx_{j}-x_{k}=(-1+jh)-(-1+kh)=(j-k)h,\n$$\n因此，对 $n$ 个项（不包括 $k=j$）的乘积可以分解为\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})=h^{n}\\prod_{k=0,\\,k\\neq j}^{n}(j-k).\n$$\n因此\n$$\nw_{j}=h^{-n}\\left(\\prod_{k=0,\\,k\\neq j}^{n}(j-k)\\right)^{-1}.\n$$\n通过在 $j$ 处拆分来计算整数乘积：\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(j-k)=\\left(\\prod_{k=0}^{j-1}(j-k)\\right)\\left(\\prod_{k=j+1}^{n}(j-k)\\right)\n=j!\\cdot\\left[\\prod_{m=1}^{n-j}(-m)\\right]=(-1)^{n-j}j!(n-j)!.\n$$\n因此，取绝对值，\n$$\n|w_{j}|=h^{-n}\\left|(-1)^{n-j}j!(n-j)!\\right|^{-1}=h^{-n}\\frac{1}{j!(n-j)!}.\n$$\n对于 $n=10$，我们得到\n$$\n\\frac{|w_{10}|}{|w_{5}|}=\\frac{h^{-10}/\\left(10!\\cdot 0!\\right)}{h^{-10}/\\left(5!\\cdot 5!\\right)}=\\frac{(5!)^{2}}{10!\\cdot 0!}=\\frac{(5!)^{2}}{10!}.\n$$\n使用 $10!=10\\cdot 9\\cdot 8\\cdot 7\\cdot 6\\cdot 5!$ 和 $5!=120$ 进行化简：\n$$\n\\frac{(5!)^{2}}{10!}=\\frac{5!}{10\\cdot 9\\cdot 8\\cdot 7\\cdot 6}=\\frac{120}{30240}=\\frac{1}{252}.\n$$\n因此，精确的比值为 $\\frac{1}{252}$。",
            "answer": "$$\\boxed{\\frac{1}{252}}$$"
        },
        {
            "introduction": "虽然切比雪夫节点在高阶多项式插值中通常能有效抑制龙格现象，但这并非一条放之四海而皆准的铁律。本练习提出了一个有趣的反例，挑战了“切比雪夫节点永远更优”的简单看法。通过分析一个低阶多项式对一个在边界上导数无穷的函数的插值情况，你将发现，在特定条件下，等距节点有时可能会产生更小的全局误差。这有助于培养批判性思维，让你更深刻地理解不同节点选择的适用场景。",
            "id": "2199752",
            "problem": "在数值分析中，插值节点的选择显著影响多项式逼近的精度。尽管对于高次多项式，Chebyshev节点因其能够抑制使用等距节点时出现的Runge现象中的大幅振荡而备受推崇，但它们的性能并非对所有函数或所有多项式次数都普遍更优。\n\n考虑函数 $f(x) = \\sqrt{R^2 - x^2}$，它描述了在区间 $[-R, R]$ 上一个半径为 $R  0$ 的半圆。我们希望使用一个二次多项式 $P_2(x)$ 来逼近该函数，该多项式在三个不同的节点上对 $f(x)$ 进行插值。我们将比较两组不同的节点：\n\n**情况 A：** 多项式 $P_{2,A}(x)$ 在三个**等距**节点上对 $f(x)$ 进行插值，这些节点包括区间的端点。\n\n**情况 B：** 多项式 $P_{2,B}(x)$ 在区间 $[-R, R]$ 上的三个**第一类Chebyshev节点**上对 $f(x)$ 进行插值。这些节点由公式 $x_k = R \\cos\\left(\\frac{(2k+1)\\pi}{2(n+1)}\\right)$ 给出，其中 $k=0, 1, \\dots, n$，且 $n=2$。\n\n令 $\\mathcal{E}_A = \\max_{x \\in [-R, R]} |f(x) - P_{2,A}(x)|$ 为情况 A 的最大绝对插值误差，$\\mathcal{E}_B = \\max_{x \\in [-R, R]} |f(x) - P_{2,B}(x)|$ 为情况 B 的最大绝对插值误差。\n\n计算比值 $\\frac{\\mathcal{E}_B}{\\mathcal{E}_A}$。将答案表示为最简分数。",
            "solution": "令 $f(x)=\\sqrt{R^{2}-x^{2}}$ 在区间 $[-R,R]$ 上。在两种情况下，三个插值节点都关于 $0$ 对称且包含 $0$，并且 $f$ 是偶函数，所以二次插值多项式具有 $P_{2}(x)=A+Bx^{2}$ 的形式。\n\n情况 A (等距节点为 $x=-R,0,R$)：由 $P_{2,A}(0)=f(0)$ 可得 $A=R$。由 $P_{2,A}(R)=f(R)=0$ 可得 $0=R+BR^{2}$，因此 $B=-\\frac{1}{R}$。所以\n$$\nP_{2,A}(x)=R-\\frac{x^{2}}{R}.\n$$\n\n情况 B (在 $[-R,R]$ 上 $n=2$ 的Chebyshev节点)：节点为 $x=\\pm \\frac{\\sqrt{3}}{2}R$ 和 $x=0$。和之前一样，$A=R$。在 $x=a=\\frac{\\sqrt{3}}{2}R$ 处，我们有 $f(a)=\\sqrt{R^{2}-a^{2}}=\\frac{R}{2}$，所以\n$$\n\\frac{R}{2}=R+B a^{2}=R+B\\left(\\frac{3}{4}R^{2}\\right)\\quad\\Rightarrow\\quad B=-\\frac{2}{3R}.\n$$\n因此\n$$\nP_{2,B}(x)=R-\\frac{2}{3R}x^{2}.\n$$\n\n为了比较最大误差，我们进行换元 $x=Rt$，其中 $t\\in[-1,1]$。则\n$$\nf(Rt)=R\\sqrt{1-t^{2}},\\quad P_{2,A}(Rt)=R\\left(1-t^{2}\\right),\\quad P_{2,B}(Rt)=R\\left(1-\\frac{2}{3}t^{2}\\right).\n$$\n因此，误差函数（以 $R$ 为单位）为\n$$\ne_{A}(t)=\\sqrt{1-t^{2}}-\\left(1-t^{2}\\right),\\qquad e_{B}(t)=\\sqrt{1-t^{2}}-\\left(1-\\frac{2}{3}t^{2}\\right).\n$$\n更一般地，设 $e_{c}(t)=\\sqrt{1-t^{2}}-1+c t^{2}$，其中 $c=1$ (情况 A) 或 $c=\\frac{2}{3}$ (情况 B)。对于 $t\\in[0,1]$，\n$$\ne_{c}'(t)=-\\frac{t}{\\sqrt{1-t^{2}}}+2ct=t\\left(2c-\\frac{1}{\\sqrt{1-t^{2}}}\\right).\n$$\n临界点出现在 $t=0$ 以及当 $\\sqrt{1-t^{2}}=\\frac{1}{2c}$ 时（这在 $c\\geq\\frac{1}{2}$ 时是可能的）。令 $s=\\sqrt{1-t^{2}}=\\frac{1}{2c}$；则 $t^{2}=1-s^{2}$ 且\n$$\ne_{c}(t)=s-1+c(1-s^{2})=\\frac{1}{4c}+c-1.\n$$\n\n情况 A ($c=1$)：内部临界点有 $s=\\frac{1}{2}$，给出\n$$\n\\max_{t\\in[0,1]} e_{A}(t)=\\frac{1}{4}+1-1=\\frac{1}{4},\\qquad e_{A}(1)=0.\n$$\n因此 $\\mathcal{E}_{A}=R\\cdot\\frac{1}{4}$。\n\n情况 B ($c=\\frac{2}{3}$)：内部正极值为\n$$\n\\max_{t\\in[0,1]} e_{B}(t)=\\frac{1}{4\\cdot\\frac{2}{3}}+\\frac{2}{3}-1=\\frac{3}{8}-\\frac{1}{3}=\\frac{1}{24}.\n$$\n在端点处，\n$$\ne_{B}(1)=0-\\left(1-\\frac{2}{3}\\right)=-\\frac{1}{3},\n$$\n所以最大绝对误差在 $t=1$ 处取得，即 $|e_{B}(1)|=\\frac{1}{3}$。因此 $\\mathcal{E}_{B}=R\\cdot\\frac{1}{3}$。\n\n该比值为\n$$\n\\frac{\\mathcal{E}_{B}}{\\mathcal{E}_{A}}=\\frac{R\\cdot\\frac{1}{3}}{R\\cdot\\frac{1}{4}}=\\frac{4}{3}.\n$$",
            "answer": "$$\\boxed{\\frac{4}{3}}$$"
        },
        {
            "introduction": "理论学习之后，最好的巩固方式莫过于通过计算实验来亲手验证。这个编程练习将指导你将龙格现象从经典的 $f(x) = \\frac{1}{1+25x^2}$ 函数推广到一个更广泛的函数族。你将编写代码来计算并比较等距节点和切比雪夫节点下的插值误差，从而在实践中确认龙格现象的普遍性，并验证切比雪夫节点作为一种有效解决方案的强大能力。",
            "id": "3188768",
            "problem": "您的任务是研究 Runge 现象，具体背景为在区间 $[-1,1]$ 上对函数族 $f_{\\alpha}(x)=\\frac{1}{1+\\alpha x^2}$ 进行多项式插值，其中 $\\alpha \\ge 0$ 控制函数在端点附近的曲率。目标是通过计算证明，不仅对于经典例子 $f(x)=\\frac{1}{1+25x^2}$，而且对于一系列的 $\\alpha$ 值，使用等距节点的高次多项式插值都可能失败，并将此情况与使用切比雪夫节点的行为进行对比。研究必须从多项式插值和插值误差的上确界范数的基本定义出发，并且必须避免使用任何预先指定的快捷公式。\n\n定义与设置：\n- 令 $n$ 表示多项式次数。对于给定的 $n$，定义 $n+1$ 个插值节点 $x_k$。\n- 对于等距节点，设置 $x_k=-1+\\frac{2k}{n}$，其中 $k=0,1,\\dots,n$。\n- 对于 $[-1,1]$ 上的第一类切比雪夫节点，设置 $x_k=\\cos\\left(\\frac{2k+1}{2(n+1)}\\pi\\right)$，其中 $k=0,1,\\dots,n$。\n- 给定节点 $\\{x_k\\}_{k=0}^n$ 和样本 $y_k=f_{\\alpha}(x_k)$，令 $p_{n,\\alpha}(x)$ 表示次数至多为 $n$ 的唯一多项式，它在这些节点上对 $f_{\\alpha}(x)$ 进行插值，即对所有 $k$ 满足 $p_{n,\\alpha}(x_k)=y_k$。\n- 对于固定的 $\\alpha$ 和 $n$，将 $[-1,1]$ 区间上一个包含 $1001$ 个点的稠密网格 $G$ 上的最大绝对插值误差定义为 $E_{n,\\alpha}=\\max_{x \\in G}\\left|p_{n,\\alpha}(x)-f_{\\alpha}(x)\\right|$，其中 $G=\\left\\{-1+\\frac{2j}{1000}\\mid j=0,1,\\dots,1000\\right\\}$。\n\n您的任务：\n1. 等距节点的阈值识别。对于集合 $\\{\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5,\\alpha_6\\}=\\{0,0.1,1,5,25,100\\}$ 中的每个 $\\alpha$，以及多项式次数集合 $S=\\{5,10,15,20,25,30,35,40\\}$，使用上面定义的等距节点计算 $E_{n,\\alpha}$。使用失效阈值 $\\tau=0.05$，为每个 $\\alpha$ 定义使得 $E_{n,\\alpha}\\tau$ 的最小次数 $n \\in S$。如果在集合 $S$ 中没有次数导致 $E_{n,\\alpha}\\tau$，则为该 $\\alpha$ 报告 $-1$。这将按给定 $\\alpha$ 值的顺序产生六个整数。\n2. 高次情况下的切比雪夫节点比较。对于 $\\alpha=25$ 和 $n=40$，分别使用等距节点计算 $E_{n,\\alpha}^{\\mathrm{eq}}$ 和使用切比雪夫节点计算 $E_{n,\\alpha}^{\\mathrm{ch}}$，两者均按设置中的定义。判断切比雪夫节点是否将最大误差相对于等距节点减小了至少10倍，即 $E_{n,\\alpha}^{\\mathrm{ch}}\\le \\frac{1}{10}E_{n,\\alpha}^{\\mathrm{eq}}$ 是否成立。为这一个测试案例报告一个布尔值。\n\n通用要求：\n- 所有计算均为纯数学计算，定义域为 $[-1,1]$，不涉及物理单位。\n- 三角函数定义中使用的角度必须是弧度。\n- 最终输出必须将所有测试案例的结果聚合到单行中。输出格式必须是一个包含在方括号中的逗号分隔列表：具体来说，是任务1中按 $\\alpha=\\{0,0.1,1,5,25,100\\}$ 顺序排列的六个整数阈值，后跟任务2中的单个布尔值。例如，最后一行应类似于 $[n_{\\alpha=0},n_{\\alpha=0.1},n_{\\alpha=1},n_{\\alpha=5},n_{\\alpha=25},n_{\\alpha=100},\\mathrm{bool}]$。\n\n测试套件摘要：\n- 任务1测试在 $\\alpha=\\{0,0.1,1,5,25,100\\}$ 和次数 $S=\\{5,10,15,20,25,30,35,40\\}$ 范围内，使用阈值 $\\tau=0.05$ 和网格大小 $1001$ 时的插值失效阈值。\n- 任务2测试在 $n=40$ 和 $\\alpha=25$ 的高次情况下，比较等距节点与切比雪夫节点的行为。\n\n您的程序必须生成一行输出，其中包含按上述规定格式化的、方括号括起来的逗号分隔结果列表。",
            "solution": "用户要求通过计算多项式插值误差，并比较等距节点与切比雪夫节点的性能，来研究函数族 $f_{\\alpha}(x) = \\frac{1}{1+\\alpha x^2}$ 的龙格现象。\n\n该问题是有效的，因为它在科学上基于数值分析的原理，特别是多项式插值理论。问题是适定的，为得到唯一的、可计算的解提供了所有必要的参数和定义。语言是客观的，任务是可验证的计算过程。\n\n解法如下：\n首先，我们确定构建和求值插值多项式的方法。给定一组 $n+1$ 个不同的节点 $\\{x_k\\}_{k=0}^n$ 和对应的函数值 $\\{y_k = f_{\\alpha}(x_k)\\}_{k=0}^n$，存在一个次数至多为 $n$ 的唯一插值多项式 $p_{n,\\alpha}(x)$。虽然这可以用拉格朗日基表示，$p_{n,\\alpha}(x) = \\sum_{k=0}^n y_k L_k(x)$，但直接求值通常效率低下且数值不稳定。一种更优的求值方法是第二重心插值公式：\n$$\np_{n,\\alpha}(x) = \\frac{\\sum_{k=0}^n \\frac{w_k}{x-x_k} y_k}{\\sum_{k=0}^n \\frac{w_k}{x-x_k}}\n$$\n此公式适用于任何不为插值节点的 $x$。如果 $x = x_j$（某个节点 $j$），则多项式的值就是 $y_j$。重心权重 $w_k$ 仅取决于节点集，定义为：\n$$\nw_k = \\frac{1}{\\prod_{j=0, j \\neq k}^n (x_k - x_j)}\n$$\n这些权重的任何常数倍数也可以使用，因为该公式关于 $w_k$ 是齐次的。\n\n插值节点的选择至关重要。龙格现象描述了高次多项式插值收敛失败的情况，特别是当在固定区间上对某些解析函数使用等距节点时。误差在区间端点附近趋于无界增长。使用在端点附近聚集的节点，如切比雪夫节点，可以减轻或消除这种现象。问题要求比较这两种节点分布：\n1.  **等距节点**：$x_k = -1 + \\frac{2k}{n}$，其中 $k=0, 1, \\dots, n$。\n2.  **切比雪夫节点**：$x_k = \\cos\\left(\\frac{2k+1}{2(n+1)}\\pi\\right)$，其中 $k=0, 1, \\dots, n$。\n\n对于算法实现，我们将为每组节点计算重心权重。对于等距节点，我们将直接使用定义性的乘积公式，因为它是一个基本定义。对于切比雪夫节点，存在一个众所周知的简化权重公式，该公式计算效率高且数值稳定：$w_k = (-1)^k \\sin\\left(\\frac{2k+1}{2(n+1)}\\pi\\right)$，前提是节点按降序排列，而给定的余弦定义恰好满足此条件。\n\n算法的核心涉及一个函数，该函数对于给定的次数 $n$、参数 $\\alpha$ 和节点类型，执行以下步骤：\n1.  生成 $n+1$ 个插值节点 $\\{x_k\\}$。\n2.  计算相应的函数值 $y_k = f_{\\alpha}(x_k)$。\n3.  计算重心权重 $\\{w_k\\}$。\n4.  定义从 $-1$ 到 $1$ 的包含 $1001$ 个点的稠密求值网格 $G$。\n5.  使用重心公式对每个 $x \\in G$ 求值插值多项式 $p_{n,\\alpha}(x)$，并小心处理 $x$ 接近节点的情况以确保数值稳定性。\n6.  对每个 $x \\in G$ 求值真实函数 $f_{\\alpha}(x)$。\n7.  计算最大绝对误差 $E_{n,\\alpha} = \\max_{x \\in G} |p_{n,\\alpha}(x) - f_{\\alpha}(x)|$。\n\n然后应用此误差计算函数来解决指定的两个任务：\n- **任务1**：对于每个 $\\alpha \\in \\{0, 0.1, 1, 5, 25, 100\\}$，我们使用等距节点遍历次数 $n \\in \\{5, 10, \\dots, 40\\}$。我们找到使误差 $E_{n,\\alpha}$ 超过阈值 $\\tau=0.05$ 的最小次数 $n$。如果对于集合中的任何 $n$ 误差都未超过阈值，我们报告 $-1$。对于 $\\alpha=0$，函数为 $f_0(x)=1$，是一个0次多项式。插值将是精确的，误差为 $0$。因此，$\\alpha=0$ 的预期结果是 $-1$。\n- **任务2**：我们固定 $n=40$ 和 $\\alpha=25$（经典的龙格函数参数）。我们计算等距节点（$E_{40,25}^{\\mathrm{eq}}$）和切比雪夫节点（$E_{40,25}^{\\mathrm{ch}}$）的误差。然后我们判断条件 $E_{40,25}^{\\mathrm{ch}} \\le \\frac{1}{10} E_{40,25}^{\\mathrm{eq}}$ 的布尔值。\n\n最终输出是这两个任务结果的聚合，形成一个单一的格式化字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of investigating Runge's phenomenon by computing\n    interpolation errors for a family of functions.\n    \"\"\"\n    # Define parameters from the problem statement.\n    ALPHA_SET = [0.0, 0.1, 1.0, 5.0, 25.0, 100.0]\n    DEGREE_SET = [5, 10, 15, 20, 25, 30, 35, 40]\n    FAILURE_THRESHOLD = 0.05\n    EVAL_GRID_SIZE = 1001\n\n    eval_grid = np.linspace(-1.0, 1.0, EVAL_GRID_SIZE)\n\n    def f_alpha(x, alpha):\n        \"\"\"The function to be interpolated.\"\"\"\n        return 1.0 / (1.0 + alpha * x**2)\n\n    def get_nodes(n, node_type):\n        \"\"\"Generates interpolation nodes.\"\"\"\n        if node_type == 'equispaced':\n            return np.linspace(-1.0, 1.0, n + 1)\n        elif node_type == 'chebyshev':\n            k = np.arange(n + 1)\n            # Chebyshev nodes of the first kind (roots of T_{n+1})\n            # The formula provided orders them from largest to smallest.\n            return np.cos((2.0 * k + 1.0) * np.pi / (2.0 * (n + 1.0)))\n        else:\n            raise ValueError(\"Invalid node type specified.\")\n\n    def get_barycentric_weights(nodes, n, node_type):\n        \"\"\"Computes barycentric interpolation weights.\"\"\"\n        if node_type == 'equispaced':\n            # Use the fundamental definition: w_k = 1 / product(x_k - x_j) for j != k\n            weights = np.ones(n + 1, dtype=np.float64)\n            for k in range(n + 1):\n                diffs = nodes[k] - np.delete(nodes, k)\n                weights[k] = 1.0 / np.prod(diffs)\n            return weights\n        elif node_type == 'chebyshev':\n            # Use the simplified, well-known formula for Chebyshev nodes of the first kind,\n            # which is valid for a descending order of nodes.\n            k = np.arange(n + 1)\n            return ((-1.0)**k) * np.sin((2.0 * k + 1.0) * np.pi / (2.0 * (n + 1.0)))\n        else:\n            raise ValueError(\"Invalid node type specified.\")\n\n    def evaluate_barycentric(eval_points, nodes, y_values, weights):\n        \"\"\"Evaluates the interpolating polynomial using the barycentric formula.\"\"\"\n        p_eval = np.zeros_like(eval_points, dtype=np.float64)\n        for i, x in enumerate(eval_points):\n            # If x is very close to a node, use the node's y-value to avoid\n            # numerical instability from division by a very small number.\n            close_node_indices = np.where(np.isclose(x, nodes))\n            if close_node_indices[0].size > 0:\n                p_eval[i] = y_values[close_node_indices[0][0]]\n                continue\n\n            # If x is not a node, use the standard barycentric formula.\n            terms = weights / (x - nodes)\n            p_eval[i] = np.sum(terms * y_values) / np.sum(terms)\n        return p_eval\n\n    def compute_interpolation_error(n, alpha, node_type, grid):\n        \"\"\"Computes the maximum absolute interpolation error on a grid.\"\"\"\n        nodes = get_nodes(n, node_type)\n        y_values = f_alpha(nodes, alpha)\n        weights = get_barycentric_weights(nodes, n, node_type)\n        \n        p_eval = evaluate_barycentric(grid, nodes, y_values, weights)\n        f_eval = f_alpha(grid, alpha)\n        \n        error = np.max(np.abs(p_eval - f_eval))\n        return error\n\n    # --- Task 1: Threshold identification for equispaced nodes ---\n    task1_results = []\n    for alpha in ALPHA_SET:\n        failure_degree = -1\n        for n in DEGREE_SET:\n            error = compute_interpolation_error(n, alpha, 'equispaced', eval_grid)\n            if error > FAILURE_THRESHOLD:\n                failure_degree = n\n                break\n        task1_results.append(failure_degree)\n\n    # --- Task 2: Chebyshev comparison at high degree ---\n    n_task2 = 40\n    alpha_task2 = 25.0\n    err_eq = compute_interpolation_error(n_task2, alpha_task2, 'equispaced', eval_grid)\n    err_ch = compute_interpolation_error(n_task2, alpha_task2, 'chebyshev', eval_grid)\n    task2_result = err_ch = (1.0 / 10.0) * err_eq\n\n    # --- Aggregate results and print ---\n    final_results = task1_results + [task2_result]\n    # The boolean result must be represented as a string 'True' or 'False'\n    # which map(str, ...) does automatically.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}