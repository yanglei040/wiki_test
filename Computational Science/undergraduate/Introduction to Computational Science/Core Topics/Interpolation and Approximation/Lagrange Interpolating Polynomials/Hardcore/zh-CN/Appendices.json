{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。此练习将引导您直接从给定的数据点出发，通过建立和求解线性方程组来确定插值多项式的系数。这个过程不仅能加深您对多项式如何拟合数据的理解，而且是许多科学与工程建模任务中的一项基本技能 。",
            "id": "2183505",
            "problem": "一个函数 $f(x)$ 在三个点处的值为：$(x_0, f(x_0)) = (0, \\exp(-1))$、$(x_1, f(x_1)) = (1, 1)$ 和 $(x_2, f(x_2)) = (2, \\exp(1))$。利用这三个点构造一个二次拉格朗日插值多项式 $P_2(x)$ 来近似 $f(x)$。该多项式可以写成标准形式 $P_2(x) = ax^2 + bx + c$。求系数 $a$ 的精确值。常数 $e$ 是自然对数的底。",
            "solution": "设 $P_{2}(x)=ax^{2}+bx+c$ 对这三个点进行插值。代入插值条件：\n1) $P_{2}(0)=c=\\exp(-1)$。\n2) $P_{2}(1)=a+b+c=1$，因此 $a+b=1-\\exp(-1)$。\n3) $P_{2}(2)=4a+2b+c=\\exp(1)$，因此 $4a+2b=\\exp(1)-\\exp(-1)$。\n\n将 $a+b=1-\\exp(-1)$ 乘以 $2$ 得到 $2a+2b=2-2\\exp(-1)$。从 $4a+2b=\\exp(1)-\\exp(-1)$ 中减去此式：\n$$\n(4a+2b)-(2a+2b)=\\left[\\exp(1)-\\exp(-1)\\right]-\\left[2-2\\exp(-1)\\right],\n$$\n化简得\n$$\n2a=\\exp(1)-2+\\exp(-1).\n$$\n因此，\n$$\na=\\frac{1}{2}\\left(\\exp(1)-2+\\exp(-1)\\right)=\\frac{\\exp(1)+\\exp(-1)}{2}-1.\n$$",
            "answer": "$$\\boxed{\\frac{\\exp(1)+\\exp(-1)}{2}-1}$$"
        },
        {
            "introduction": "拉格朗日插值多项式的唯一性定理不仅仅是一个理论上的结论，更是一个强大的解题工具。本题设计了一个巧妙的场景，旨在考察您对这一定理的运用 。在投入繁琐的计算之前，尝试利用理论知识寻找捷径，这正是培养高效科学思维的关键一步。",
            "id": "2183527",
            "problem": "已知某一物理量可由一个多项式函数 $f(x)$ 描述。为了确定该函数，进行了一项实验，得到四个数据点 $(x_i, y_i)$:\n- $(x_0, y_0) = (0, 7)$\n- $(x_1, y_1) = (1, 7)$\n- $(x_2, y_2) = (-1, -3)$\n- $(x_3, y_3) = (2, 9)$\n\n设 $P(x)$ 是穿过这四个数据点的、次数最多为3的唯一拉格朗日插值多项式。在构造出这个多项式之后，发现描述该物理量的真实函数恰好是 $f(x) = 2x^3 - 5x^2 + 3x + 7$。\n\n计算 $P(3)$ 的值。",
            "solution": "我们已知四个数据点，并且 $P(x)$ 是对它们进行插值的、次数最多为3的唯一多项式。真实的函数是 $f(x)=2x^{3}-5x^{2}+3x+7$。根据次数最多为3的拉格朗日插值多项式的唯一性，如果 $f(x)$ 也经过这四个点，那么对于所有的 $x$ 都有 $P(x)=f(x)$。\n\n验证对于每个给定的点，都有 $f(x_{i})=y_{i}$：\n1) 当 $x_{0}=0$ 时：$f(0)=2\\cdot 0^{3}-5\\cdot 0^{2}+3\\cdot 0+7=7=y_{0}$。\n2) 当 $x_{1}=1$ 时：$f(1)=2\\cdot 1^{3}-5\\cdot 1^{2}+3\\cdot 1+7=2-5+3+7=7=y_{1}$。\n3) 当 $x_{2}=-1$ 时：$f(-1)=2\\cdot(-1)^{3}-5\\cdot(-1)^{2}+3\\cdot(-1)+7=-2-5-3+7=-3=y_{2}$。\n4) 当 $x_{3}=2$ 时：$f(2)=2\\cdot 2^{3}-5\\cdot 2^{2}+3\\cdot 2+7=16-20+6+7=9=y_{3}$。\n\n由于 $f(x)$ 与所有四个数据点都匹配，且其次数为3，根据唯一性定理，可得 $P(x)=f(x)$。因此，\n$$\nP(3)=f(3)=2\\cdot 3^{3}-5\\cdot 3^{2}+3\\cdot 3+7=54-45+9+7=25.\n$$",
            "answer": "$$\\boxed{25}$$"
        },
        {
            "introduction": "现在，让我们将理论应用于一个更接近现实的工程问题：传感器校准。在实际应用中，为了获得高精度的插值结果，插值节点的选择至关重要。这个高级练习将引导您使用切比雪夫节点来最小化插值误差，并要求您通过编程实现从节点生成、多项式构造到误差分析的完整流程 。这不仅是对拉格朗日插值理论的综合运用，更是计算科学实践能力的真实考验。",
            "id": "3150109",
            "problem": "一位校准工程师将仪器的电压响应建模为电流的函数，记为非线性曲线 $V(I)$。根据多项式插值的基本定义，对于 $n$ 个不同的输入电流 $I_k$ 和测得的电压 $V_k$，存在一个唯一的、次数至多为 $n-1$ 的多项式，在指定点处与给定的数据对匹配。你的任务是构造这样一个多项式插值，其节点选择旨在减少大幅振荡：使用从标准区间 $[-1,1]$ 线性映射到指定电流范围 $[I_{\\min}, I_{\\max}]$ 的 $n$ 个第一类 Chebyshev 节点。插值必须根据插值的第一性原理显式构建，以确保其在所选节点处的电压值完全匹配，然后在一个密集均匀的电流范围网格上进行求值，以量化最大绝对校准误差。校准误差是真实值 $V(I)$ 与插值之间的绝对差，需要报告的量是在网格上的上确界，该值通过数值近似计算。三角函数中出现的所有角度都必须以弧度为单位。所有误差以伏特为单位报告，并四舍五入到8位小数。\n\n实现一个完整、可运行的程序，该程序：\n- 在 $[-1,1]$ 上生成 $n$ 个第一类 Chebyshev 节点，将它们线性映射到 $[I_{\\min}, I_{\\max}]$，在这些映射后的节点上对真实的 $V(I)$ 进行采样，构造与这些样本匹配的唯一的、次数 $\\le n-1$ 的多项式插值，并在 $[I_{\\min}, I_{\\max}]$ 上的一个包含 $M$ 个点的均匀网格上，对插值和真实曲线进行求值。\n- 为每个测试用例计算最大绝对校准误差 $\\max_{I \\in \\text{grid}} \\left| V(I) - P_n(I) \\right|$，其中 $P_n$ 是多项式插值。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是第 $i$ 个测试用例的最大绝对误差（以伏特为单位），四舍五入到8位小数。输出不得包含单位符号和任何附加文本。\n\n使用以下包含四个科学上合理的用例的测试套件，这些用例共同检验了一个典型场景、一个边界条件、一个包含负电流的边缘范围以及一个多项式精确性检查：\n- 用例 1（正常路径）：$I_{\\min} = 0$, $I_{\\max} = 10$, $n = 8$, $M = 10001$，以及\n  $$V(I) = \\ln(1 + I) + \\frac{0.02 I^3}{1 + I^2} + 0.1 \\sin(I)。$$\n- 用例 2（$n$ 的边界情况）：$I_{\\min} = 0$, $I_{\\max} = 10$, $n = 1$, $M = 10001$，以及\n  $$V(I) = e^{0.1 I} + 0.5 \\cos(I)。$$\n- 用例 3（范围包含负电流）：$I_{\\min} = -5$, $I_{\\max} = 5$, $n = 20$, $M = 20001$，以及\n  $$V(I) = \\frac{1}{1 + 25 I^2} + 0.2 I。$$\n- 用例 4（多项式精确性检查）：$I_{\\min} = -2$, $I_{\\max} = 2$, $n = 4$, $M = 10001$，以及\n  $$V(I) = 0.7 + 1.2 I - 0.5 I^2 + 0.03 I^3。$$\n\n你的程序应按照上述用例的顺序，生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个以伏特为单位的浮点数值，四舍五入到8位小数。$\\sin(\\cdot)$ 和 $\\cos(\\cdot)$ 中的角度应以弧度解释。数值代表伏特级别的误差；输出中不要包含单位符号。",
            "solution": "该问题要求针对代表电压响应的给定函数 $V(I)$，在指定的电流区间 $[I_{\\min}, I_{\\max}]$ 上构造一个多项式插值 $P_n(I)$。插值需在 $n$ 个被称为切比雪夫节点的离散点上进行。最终目标是计算最大绝对校准误差，该误差定义为区间内一个精细均匀网格上 $|V(I) - P_n(I)|$ 的最大值。解决方案的步骤是：定义节点、构造插值，然后评估误差。\n\n### 第1步：切比雪夫节点生成\n在数值分析中，使用切比雪夫节点是一种标准技术，用于最小化多项式插值误差，特别是为了避免使用等距节点时可能在区间端点附近出现的大幅振荡（即龙格现象）。\n\n在标准区间 $[-1, 1]$ 上的 $n$ 个第一类切比雪夫节点（记为 $x_k$）被定义为 $n$ 次第一类切比雪夫多项式 $T_n(x)$ 的根。这些根由以下公式给出：\n$$\nx_k = \\cos\\left(\\frac{2k-1}{2n}\\pi\\right), \\quad \\text{for } k = 1, 2, \\ldots, n\n$$\n这些节点不是均匀分布的；它们在区间端点 $-1$ 和 $1$ 附近分布得更密集。\n\n为了在任意区间 $[I_{\\min}, I_{\\max}]$ 上使用这些节点进行插值，我们必须应用一个线性（仿射）变换，将标准区间 $[-1, 1]$ 映射到 $[I_{\\min}, I_{\\max}]$。一个点 $x \\in [-1, 1]$ 通过以下公式映射到点 $I \\in [I_{\\min}, I_{\\max}]$：\n$$\nI(x) = \\frac{I_{\\max} - I_{\\min}}{2} x + \\frac{I_{\\max} + I_{\\min}}{2}\n$$\n将此映射应用于每个标准切比雪夫节点 $x_k$，即可得到目标电流范围内的 $n$ 个插值节点集合 $\\{I_k\\}_{k=1}^n$：\n$$\nI_k = \\frac{I_{\\max} - I_{\\min}}{2} \\cos\\left(\\frac{2k-1}{2n}\\pi\\right) + \\frac{I_{\\max} + I_{\\min}}{2}\n$$\n\n### 第2步：拉格朗日多项式插值\n给定 $n$ 个不同的插值节点 $I_k$ 和对应的测量电压值 $V_k = V(I_k)$，多项式插值基本定理保证了存在一个唯一的、次数至多为 $n-1$ 的多项式 $P_n(I)$，使得对于所有 $k = 1, \\ldots, n$，都有 $P_n(I_k) = V_k$。\n\n这个唯一的多项式可以使用拉格朗日形式进行显式构造，它将 $P_n(I)$ 表示为拉格朗日基多项式 $L_k(I)$ 的线性组合：\n$$\nP_n(I) = \\sum_{k=1}^{n} V_k L_k(I)\n$$\n基多项式定义为：\n$$\nL_k(I) = \\prod_{\\substack{j=1 \\\\ j \\neq k}}^{n} \\frac{I - I_j}{I_k - I_j}\n$$\n根据构造，每个基多项式 $L_k(I)$ 都具有一个性质，即它在节点 $I_k$ 处等于 1，而在所有其他节点 $I_j$ (其中 $j \\neq k$) 处等于 0，即 $L_k(I_j) = \\delta_{kj}$，其中 $\\delta_{kj}$ 是克罗内克δ符号。这个性质确保了插值多项式 $P_n(I)$ 能正确地穿过每个数据点 $(I_k, V_k)$。为了实现高效且数值稳定的计算，最好使用其重心形式来计算该多项式，这是拉格朗日公式的一种代数重排形式。\n\n### 第3步：误差评估\n在任意电流 $I$ 处的校准误差是绝对差 $|V(I) - P_n(I)|$。为了找到整个区间的最大误差，我们在一个包含 $M$ 个点的密集均匀网格上计算这个差值。该网格 $\\{I'_j\\}_{j=0}^{M-1}$ 定义如下：\n$$\nI'_j = I_{\\min} + j \\frac{I_{\\max} - I_{\\min}}{M-1}, \\quad \\text{for } j = 0, 1, \\ldots, M-1\n$$\n最大绝对校准误差 $E_{\\max}$ 接着通过取此网格上的最大值来近似：\n$$\nE_{\\max} = \\max_{j \\in \\{0, \\ldots, M-1\\}} |V(I'_j) - P_n(I'_j)|\n$$\n这个值可作为误差函数真实上确界范数 $\\|V - P_n\\|_{\\infty}$ 的一个数值近似。\n\n### 第4步：特定测试用例分析\n所提供的测试用例旨在针对不同条件验证实现的正确性：\n- **用例 1 ($n=8$，平滑函数):** 这代表了一个典型应用场景，其中切比雪夫插值预期会提供一个良好的近似，其误差微小但非零。\n- **用例 2 ($n=1$):** 当只有一个节点 $I_1 = (I_{\\min} + I_{\\max})/2$ 时，插值是一个常数多项式 $P_1(I) = V(I_1)$。其次数为 0，满足次数 $\\le n-1$ 的条件。\n- **用例 3 ($n=20$，类龙格函数):** 函数 $V(I)$ 是著名的龙格函数的一个变体，对于等距节点插值来说，该函数是有问题的。使用 $n=20$ 个切比雪夫节点预期能有效抑制振荡并产生较低的误差，从而展示其优越性。\n- **用例 4 ($n=4$，三次多项式):** 函数 $V(I)$ 是一个 3 次多项式。由于我们使用 $n=4$ 个节点，唯一的次数至多为 $n-1=3$ 的插值多项式必须与 $V(I)$ 本身完全相同。因此，理论插值误差精确为 0。计算结果应该是一个在机器浮点精度量级上的值，四舍五入后为 0.0。此用例可作为对算法正确性的关键检验。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the maximum absolute error of a polynomial\n    interpolant constructed using Chebyshev nodes.\n    \"\"\"\n\n    # Define the true voltage functions V(I) for each case.\n    v_funcs = [\n        lambda i: np.log(1 + i) + (0.02 * i**3) / (1 + i**2) + 0.1 * np.sin(i),\n        lambda i: np.exp(0.1 * i) + 0.5 * np.cos(i),\n        lambda i: 1 / (1 + 25 * i**2) + 0.2 * i,\n        lambda i: 0.7 + 1.2 * i - 0.5 * i**2 + 0.03 * i**3\n    ]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (I_min, I_max, n, M, v_func)\n        (0.0, 10.0, 8, 10001, v_funcs[0]),\n        # Case 2\n        (0.0, 10.0, 1, 10001, v_funcs[1]),\n        # Case 3\n        (-5.0, 5.0, 20, 20001, v_funcs[2]),\n        # Case 4\n        (-2.0, 2.0, 4, 10001, v_funcs[3])\n    ]\n\n    results = []\n    for case in test_cases:\n        I_min, I_max, n, M, v_func = case\n\n        # Step 1: Generate n Chebyshev nodes of the first kind\n        # Generate canonical nodes on the interval [-1, 1]\n        k = np.arange(1, n + 1)\n        x_cheb = np.cos((2 * k - 1) * np.pi / (2 * n))\n        \n        # Linearly map the canonical nodes to the target interval [I_min, I_max]\n        # These are the interpolation nodes I_k\n        I_nodes = 0.5 * (I_max - I_min) * x_cheb + 0.5 * (I_max + I_min)\n\n        # Step 2: Sample the true function V(I) at the interpolation nodes\n        # These are the corresponding values V_k\n        V_nodes = v_func(I_nodes)\n\n        # Construct the unique polynomial interpolant P_n(I).\n        # We use scipy's BarycentricInterpolator, which is a numerically stable\n        # and efficient implementation of the Lagrange interpolating polynomial.\n        # This adheres to the \"first principles\" requirement as it is a direct\n        # representation of the Lagrange polynomial in its barycentric form.\n        interpolant = BarycentricInterpolator(I_nodes, V_nodes)\n        \n        # Step 3: Evaluate on a dense uniform grid and compute error\n        # Create the uniform evaluation grid of M points\n        I_grid = np.linspace(I_min, I_max, M)\n        \n        # Evaluate the true function V(I) on the grid\n        V_true_on_grid = v_func(I_grid)\n        \n        # Evaluate the interpolating polynomial P_n(I) on the grid\n        V_interp_on_grid = interpolant(I_grid)\n        \n        # Compute the maximum absolute calibration error\n        max_error = np.max(np.abs(V_true_on_grid - V_interp_on_grid))\n        \n        # Store the result, rounded to 8 decimal places\n        results.append(f\"{max_error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}