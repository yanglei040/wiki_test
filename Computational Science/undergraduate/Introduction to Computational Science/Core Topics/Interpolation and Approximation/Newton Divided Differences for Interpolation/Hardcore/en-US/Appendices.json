{
    "hands_on_practices": [
        {
            "introduction": "The foundation of Newton's method lies in its elegant connection to polynomial coefficients. This first practice provides a hands-on verification of a cornerstone property: for a monomial $f(x) = x^k$, the $k$-th order divided difference is always exactly $1$, regardless of the distinct nodes chosen. By implementing the numerical computation and comparing it to this exact symbolic result, you will not only validate your code but also build a concrete understanding of how divided differences capture the leading-order behavior of a function .",
            "id": "3164015",
            "problem": "You are tasked with validating numerical computation of Newton's divided differences against an exact symbolic result for a specific class of functions within the domain of introduction to computational science. Work with the monomial function $f(x) = x^k$ and the $k$-th order divided difference over a set of $k+1$ distinct interpolation nodes. Your program must implement the numerical computation of the $k$-th order divided difference using the standard recursive definition of divided differences and compare it to the exact symbolic value that follows from foundational properties of polynomial interpolation. The comparison must be quantified by a boolean decision based on a specified tolerance.\n\nFundamental base for the derivation and validation:\n- The concept of polynomial interpolation: Given $k+1$ distinct points $(x_i, f(x_i))$ for $i \\in \\{0,1,\\dots,k\\}$, there exists a unique polynomial $p(x)$ of degree at most $k$ that interpolates the data.\n- The Newton form of the interpolation polynomial uses coefficients given by divided differences that are constructed from the data $(x_i, f(x_i))$ and the Newton basis of polynomials.\n\nYou must not assume any shortcut formulas that trivially reveal the result; you should reason from the stated fundamental base in your solution. In your program, you will:\n1. Compute the numerical $k$-th order divided difference of $f(x) = x^k$ over the provided nodes using floating-point arithmetic.\n2. Compute the exact symbolic value implied by the foundational properties of polynomial interpolation for $f(x) = x^k$.\n3. Decide if the numerical value matches the exact value within a specified absolute tolerance $\\varepsilon$.\n\nThe test suite consists of the following parameter sets $(k, [x_0,\\dots,x_k])$ designed for coverage of typical and edge scenarios. All nodes are real numbers and are pairwise distinct. Each case uses $f(x) = x^k$:\n- Case $1$: $k = 0$, nodes $[7.5]$.\n- Case $2$: $k = 1$, nodes $[-10.0, 10.0]$.\n- Case $3$: $k = 2$, nodes $[0.0, 0.5, 2.0]$.\n- Case $4$: $k = 3$, nodes $[-10^{-5}, 0.0, 10^{-5}, 2 \\cdot 10^{-5}]$.\n- Case $5$: $k = 4$, nodes $[-1.0, 5.0, -0.5, 0.0, 2.5]$ (unsorted order).\n- Case $6$: $k = 5$, nodes $[1.0, 1.0 + 10^{-8}, 1.0 + 2 \\cdot 10^{-8}, 1.0 + 3 \\cdot 10^{-8}, 1.0 + 4 \\cdot 10^{-8}, 1.0 + 5 \\cdot 10^{-8}]$.\n\nFor each case, your program must:\n- Compute the numerical $k$-th order divided difference $\\widehat{c}_k$ from the given nodes and $f(x) = x^k$.\n- Use the exact symbolic value $c_k$ implied by foundational theory for $f(x) = x^k$.\n- Compare with absolute tolerance $\\varepsilon = 10^{-10}$, and return a boolean $b$ defined as $b = \\left(|\\widehat{c}_k - c_k| \\le \\varepsilon\\right)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the boolean results for the six cases as a comma-separated list enclosed in square brackets, for example, $[{\\text{True}},{\\text{False}},\\dots]$.\n\nNo physical units, angle units, or percentage formats are involved. All outputs are booleans.",
            "solution": "We begin from the foundational framework of polynomial interpolation. Given $k+1$ distinct nodes $x_0, x_1, \\dots, x_k$ and function values $f(x_i)$, there exists a unique interpolating polynomial $p(x)$ of degree at most $k$ such that $p(x_i) = f(x_i)$ for all $i$. The Newton form of this interpolating polynomial expresses $p(x)$ in the Newton basis:\n$$\np(x) = c_0 + c_1 (x - x_0) + c_2 (x - x_0)(x - x_1) + \\cdots + c_k \\prod_{m=0}^{k-1} (x - x_m),\n$$\nwhere each coefficient $c_j$ is the $j$-th order divided difference $[x_0, x_1, \\dots, x_j] f$.\n\nA core property of the Newton basis $\\prod_{m=0}^{j-1} (x - x_m)$ is that its leading term in $x$ equals $x^j$ with leading coefficient $1$. Consequently, the coefficient of $x^k$ in $p(x)$ is exactly $c_k$, since the product $\\prod_{m=0}^{k-1} (x - x_m)$ has leading term $x^k$ with leading coefficient $1$, while all lower-order basis polynomials have degree less than $k$. Therefore, if $p(x)$ interpolates a polynomial function $f(x)$ of degree at most $k$, the coefficient $c_k$ must equal the leading coefficient of $f(x)$.\n\nApplying this to the specific function $f(x) = x^k$, which is a monomial of degree $k$ with leading coefficient $1$, we conclude:\n$$\n[x_0, x_1, \\dots, x_k] f = 1,\n$$\nfor any choice of $k+1$ distinct nodes $x_0, x_1, \\dots, x_k$. This exact symbolic value $c_k = 1$ arises from the uniqueness of the interpolating polynomial and the structure of the Newton basis.\n\nTo compute the numerical $k$-th order divided difference, we use the standard recursive definition implemented via a triangular scheme (often called the divided difference table). Define the zeroth order divided differences as $d_i^{(0)} = f(x_i)$. For $m = 1$ to $k$, define:\n$$\nd_i^{(m)} = \\frac{d_{i+1}^{(m-1)} - d_i^{(m-1)}}{x_{i+m} - x_i}, \\quad i = 0, 1, \\dots, k - m.\n$$\nThe numerical estimate of the $k$-th order divided difference is then $\\widehat{c}_k = d_0^{(k)}$. This algorithm requires $O(k^2)$ floating-point operations and is standard in numerical interpolation.\n\nNumerical considerations: The computation of divided differences is sensitive to the spacing of the nodes because denominators $x_{i+m} - x_i$ can become very small, magnifying round-off errors. However, double-precision floating-point arithmetic typically suffices for well-scaled problems. The chosen test suite includes:\n- A boundary case $k = 0$ where $[x_0] f = f(x_0) = 1$.\n- Low-degree cases with moderate node spacing.\n- An unsorted node order to emphasize symmetry in the divided difference.\n- A near-coalesced node set for $k = 5$ with increments of $10^{-8}$ to mildly stress numerical conditioning while remaining within a reasonable tolerance.\n\nValidation protocol: For each test case, we compute $\\widehat{c}_k$ numerically via the triangular scheme, compare it to the exact $c_k = 1$, and declare success if $|\\widehat{c}_k - 1| \\le \\varepsilon$ with $\\varepsilon = 10^{-10}$. The program outputs the list of six booleans for the six cases in the required single-line format.\n\nThis approach integrates foundational theory (Newton interpolation and leading coefficients) with an algorithmic design (divided difference table) to validate computation against exact symbolic knowledge.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef monomial_values(xs, k):\n    \"\"\"Compute f(x) = x^k for all x in xs.\"\"\"\n    xs = np.asarray(xs, dtype=np.float64)\n    return xs ** k\n\ndef k_th_divided_difference(xs, ys):\n    \"\"\"\n    Compute the k-th order divided difference using the standard\n    recursive (triangular table) scheme.\n    Assumes len(xs) == len(ys) == k+1 and xs are distinct.\n    \"\"\"\n    n = len(xs)\n    dd = ys.astype(np.float64).copy()\n    # Build the table: dd[i] holds the current order divided differences\n    for m in range(1, n):\n        for i in range(n - m):\n            denom = xs[i + m] - xs[i]\n            dd[i] = (dd[i + 1] - dd[i]) / denom\n    return float(dd[0])\n\ndef solve():\n    # Define the test cases from the problem statement: (k, nodes)\n    test_cases = [\n        (0, [7.5]),\n        (1, [-10.0, 10.0]),\n        (2, [0.0, 0.5, 2.0]),\n        (3, [-1e-5, 0.0, 1e-5, 2e-5]),\n        (4, [-1.0, 5.0, -0.5, 0.0, 2.5]),\n        (5, [1.0, 1.0 + 1e-8, 1.0 + 2e-8, 1.0 + 3e-8, 1.0 + 4e-8, 1.0 + 5e-8]),\n    ]\n\n    tol = 1e-10\n    results = []\n    for k, nodes in test_cases:\n        xs = np.array(nodes, dtype=np.float64)\n        if len(xs) != k + 1:\n            # Defensive check: format requires k+1 nodes for k-th divided difference\n            raise ValueError(f\"Case with k={k} has {len(xs)} nodes; expected {k+1}.\")\n        ys = monomial_values(xs, k)\n        numeric = k_th_divided_difference(xs, ys)\n        exact = 1.0  # For f(x) = x^k, the k-th divided difference equals 1\n        ok = abs(numeric - exact) = tol\n        results.append(ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While polynomials exhibit predictable, well-behaved divided differences, real-world data is often not so smooth. This exercise explores what happens when we apply interpolation to a function with a \"kink,\" namely $f(x) = |x|$. By computing the highest-order divided differences for nodes that straddle the non-differentiable point at $x=0$, you will observe how these coefficients can grow, serving as a numerical indicator of the function's lack of smoothness .",
            "id": "3164020",
            "problem": "You are given the task of investigating how the highest-order Newton coefficient (also known as the highest-order divided difference) behaves when the interpolated function has a non-smooth point. Consider the absolute value function $f(x)=|x|$, which has a non-differentiable kink at $x=0$. The unique polynomial $P_{k}$ of degree at most $k$ that interpolates a function $f$ at distinct nodes $x_{0},x_{1},\\ldots,x_{k}$ admits a Newton basis representation whose highest-order coefficient is, by definition, the $k$-th order divided difference $[x_{0},x_{1},\\ldots,x_{k}]f$. Starting from the fundamental facts that (i) a unique interpolating polynomial exists for distinct nodes and (ii) the Newton basis expansion exists for every set of distinct nodes, investigate the magnitude of the highest-order Newton coefficient for $f(x)=|x|$ in various node configurations to assess how non-smoothness magnifies high-order coefficients.\n\nProgram requirements:\n- Implement a procedure that, given distinct nodes $x_{0},x_{1},\\ldots,x_{k}$ and a function $f$, computes the $k$-th order divided difference $[x_{0},x_{1},\\ldots,x_{k}]f$ by correctly extracting the highest-order coefficient from the Newton form of the interpolating polynomial. The computation must be consistent with the standard definition of divided differences.\n- Apply your implementation to the function $f(x)=|x|$ for each test case listed below.\n- For each test case, your program must compute and return a single real number equal to the $k$-th order divided difference $[x_{0},x_{1},\\ldots,x_{k}]f$ for the provided nodes and $f(x)=|x|$. No other quantities should be returned.\n\nTest suite (each case specifies nodes; here $k=\\text{number of nodes}-1$):\n1. Nodes $[-2,-1,0,1,2]$ (that is, $x_{0}=-2$, $x_{1}=-1$, $x_{2}=0$, $x_{3}=1$, $x_{4}=2$; thus $k=4$).\n2. Nodes $[-2,-1,-0.5,-0.25]$ (that is, $x_{0}=-2$, $x_{1}=-1$, $x_{2}=-0.5$, $x_{3}=-0.25$; thus $k=3$).\n3. Nodes $[0.25,0.5,1.0,2.0]$ (that is, $x_{0}=0.25$, $x_{1}=0.5$, $x_{2}=1.0$, $x_{3}=2.0$; thus $k=3$).\n4. Nodes $[-10^{-3},0,10^{-3}]$ (that is, $x_{0}=-10^{-3}$, $x_{1}=0$, $x_{2}=10^{-3}$; thus $k=2$).\n5. Nodes $[-10^{-3},10^{-3},2\\times 10^{-3}]$ (that is, $x_{0}=-10^{-3}$, $x_{1}=10^{-3}$, $x_{2}=2\\times 10^{-3}$; thus $k=2$).\n6. Nodes $[-3,-0.1,0.2,0.9]$ (that is, $x_{0}=-3$, $x_{1}=-0.1$, $x_{2}=0.2$, $x_{3}=0.9$; thus $k=3$).\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases above. For example, an output with three results should look like $[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}]$.\n- Each result must be a real number (a floating-point number). No units are involved in this problem.\n\nDesign intent and coverage:\n- The test suite includes a symmetric set containing the kink ($[-2,-1,0,1,2]$), two smooth-side sets entirely on one side of the kink ($[-2,-1,-0.5,-0.25]$ and $[0.25,0.5,1.0,2.0]$), two small-spacing edge cases near the kink that illustrate magnification ($[-10^{-3},0,10^{-3}]$ and $[-10^{-3},10^{-3},2\\times 10^{-3}]$), and a general irregular set crossing the kink ($[-3,-0.1,0.2,0.9]$). The answers are real numbers that quantify the highest-order Newton coefficients for $f(x)=|x|$ in each case.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of numerical analysis, specifically polynomial interpolation and Newton's divided differences. It is well-posed, objective, and provides all necessary data for a unique solution to be computed for each test case. The function $f(x)=|x|$ serves as a standard and illustrative example of how interpolating polynomials behave for non-smooth functions.\n\nThe objective is to compute the highest-order divided difference, $[x_{0}, x_{1}, \\ldots, x_{k}]f$, for the function $f(x)=|x|$ given several sets of distinct nodes. This quantity is precisely the leading coefficient of the interpolating polynomial in its Newton form.\n\nLet $f(x)$ be a function and let $x_{0}, x_{1}, \\ldots, x_{k}$ be $k+1$ distinct points, called nodes. There exists a unique polynomial $P_k(x)$ of degree at most $k$ such that $P_k(x_i) = f(x_i)$ for all $i \\in \\{0, 1, \\ldots, k\\}$. This polynomial can be expressed in the Newton form:\n$$\nP_k(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1) + \\cdots + c_k(x-x_0)(x-x_1)\\cdots(x-x_{k-1})\n$$\nThe coefficients $c_j$ are the divided differences, defined as $c_j = [x_0, x_1, \\ldots, x_j]f$. The problem asks for the computation of the highest-order coefficient, $c_k = [x_0, x_1, \\ldots, x_k]f$.\n\nDivided differences are defined by the following recursive formula:\nThe zeroth-order divided difference is the function value itself:\n$$\n[x_i]f = f(x_i)\n$$\nFor orders $j > 0$, the divided difference is defined recursively as:\n$$\n[x_i, x_{i+1}, \\ldots, x_{i+j}]f = \\frac{[x_{i+1}, \\ldots, x_{i+j}]f - [x_i, \\ldots, x_{i+j-1}]f}{x_{i+j} - x_i}\n$$\nThis recursive definition forms the basis of the computational algorithm. We can construct a divided difference table, but for the purpose of finding only the highest-order coefficient, a more space-efficient algorithm can be used. We can use a single one-dimensional array, say `c`, of size $k+1$, which is updated iteratively.\n\nThe algorithm proceeds as follows:\n1.  Initialize an array `c` of length $k+1$ with the function values at the nodes: $c_i = f(x_i)$ for $i=0, 1, \\ldots, k$.\n2.  Iterate for $j$ from $1$ to $k$. This corresponds to computing the $j$-th order divided differences.\n3.  In each iteration $j$, iterate for $i$ from $k$ down to $j$. This reverse loop order is crucial for correctly updating the array `c` in-place.\n4.  Update the entry $c_i$ using the recursive formula. At step $(j,i)$, the value $c_i$ holds the $(j-1)$-th order difference $[x_{i-j+1}, \\ldots, x_i]f$ and $c_{i-1}$ holds $[x_{i-j}, \\ldots, x_{i-1}]f$. The update is:\n    $$\n    c_i \\leftarrow \\frac{c_i - c_{i-1}}{x_i - x_{i-j}}\n    $$\n5.  After the loops complete (i.e., after the iteration for $j=k$), the last element of the array, $c_k$, will hold the desired highest-order divided difference $[x_0, x_1, \\ldots, x_k]f$.\n\nA key theoretical result connects divided differences to derivatives. If $f$ is $n$ times continuously differentiable on an interval containing the nodes $x_0, \\ldots, x_n$, then there exists a point $\\xi$ in the smallest interval containing the nodes such that:\n$$\n[x_0, \\ldots, x_n]f = \\frac{f^{(n)}(\\xi)}{n!}\n$$\nThe function in this problem is $f(x)=|x|$. This function is smooth everywhere except for a \"kink\", a non-differentiable point, at $x=0$.\n- For any set of nodes where all $x_i > 0$ or all $x_i  0$, the function is equivalent to a linear polynomial ($f(x)=x$ or $f(x)=-x$, respectively). For such a function, $f''(x) = 0$ and all higher derivatives are also zero. Therefore, for $k \\ge 2$, the $k$-th order divided difference must be $0$. This applies to test cases 2 and 3.\n- When the set of nodes includes $x=0$ or straddles it, the function is not smooth over the interval containing the nodes. The divided difference formula still applies, but we can no longer relate it to a high-order derivative. Instead, the divided difference quantifies the \"polynomial-ness\" of the function over the given nodes. The non-smoothness at $x=0$ is expected to result in non-zero, and potentially large, high-order divided differences, reflecting the singularity introduced by the absolute value function. The test cases are designed to probe this behavior.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_highest_order_dd(nodes):\n    \"\"\"\n    Computes the highest-order Newton divided difference for f(x)=|x|.\n\n    Args:\n        nodes (list or tuple of float): A list of distinct nodes x_0, x_1, ..., x_k.\n\n    Returns:\n        float: The k-th order divided difference [x_0, ..., x_k]f.\n    \"\"\"\n    x = np.array(nodes, dtype=float)\n    y = np.abs(x)\n    k = len(x) - 1\n\n    if k  0:\n        # This case won't be triggered by the problem's test suite.\n        # A single node has a 0-th order difference, y[0]. \n        # For simplicity, we can handle it, though the loop structure naturally does.\n        return y[0] if k == -1 else 0.0\n\n    # The array 'coeffs' will be updated in-place.\n    # Initially, it holds the 0-th order differences (the function values).\n    coeffs = y.copy()\n\n    # Iterate from j=1 (1st order diff) to j=k (k-th order diff).\n    for j in range(1, k + 1):\n        # The inner loop computes the j-th order differences.\n        # It must run in reverse to use the (j-1)-th order differences\n        # from the previous 'j' iteration before they are overwritten.\n        for i in range(k, j - 1, -1):\n            numerator = coeffs[i] - coeffs[i-1]\n            denominator = x[i] - x[i-j]\n            coeffs[i] = numerator / denominator\n\n    # The highest-order coefficient is the last element.\n    return coeffs[k]\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the highest-order divided difference\n    for f(x)=|x| for each of the provided test cases.\n    \"\"\"\n    test_cases = [\n        # 1. Symmetric set containing the kink\n        [-2.0, -1.0, 0.0, 1.0, 2.0],\n        # 2. Smooth-side set on the negative side\n        [-2.0, -1.0, -0.5, -0.25],\n        # 3. Smooth-side set on the positive side\n        [0.25, 0.5, 1.0, 2.0],\n        # 4. Small-spacing set symmetric about the kink\n        [-1e-3, 0.0, 1e-3],\n        # 5. Small-spacing asymmetric set near the kink\n        [-1e-3, 1e-3, 2e-3],\n        # 6. General irregular set crossing the kink\n        [-3.0, -0.1, 0.2, 0.9],\n    ]\n\n    results = []\n    for nodes in test_cases:\n        result = compute_highest_order_dd(nodes)\n        results.append(result)\n\n    # Format the final output string as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "High-degree polynomial interpolation can lead to wild oscillations, a problem famously demonstrated by Runge's function. This advanced practice puts theory into action, using the insights gained from the previous exercises to build a robust solution. You will implement an adaptive algorithm that monitors the magnitude of divided-difference coefficients to intelligently decide when to stop growing a single polynomial and start a new piecewise segment, effectively taming the oscillations and producing a far more accurate interpolant .",
            "id": "3163936",
            "problem": "You are asked to formalize and implement a principled switching criterion between a single global interpolating polynomial and a piecewise polynomial, within the Newton divided-differences framework, and to test it on the function $f(x)=\\frac{1}{1+x^2}$. Work in purely mathematical terms, independent of any particular programming language. Your final deliverable must be a complete and runnable program that adheres to the output specification at the end.\n\nStart from the following base definitions.\n\n1. Given distinct nodes $x_0,\\dots,x_n$ and function values $y_i=f(x_i)$, the divided differences are defined recursively by\n$$f[x_i]=y_i,\\quad f[x_i,x_{i+1},\\dots,x_{i+k}] = \\frac{f[x_{i+1},\\dots,x_{i+k}] - f[x_i,\\dots,x_{i+k-1}]}{x_{i+k}-x_i},$$\nfor $k\\ge 1$. The Newton basis functions are $1,(x-x_0),(x-x_0)(x-x_1),\\dots$.\n\n2. The unique interpolating polynomial of degree at most $n$ through $(x_i,y_i)$ exists for distinct $x_i$ and can be represented in the Newton basis with coefficients drawn from the divided differences.\n\nDesign a criterion and construct an algorithm that proceeds from left to right through an ordered set of nodes and decides when to stop growing the current polynomial piece and start a new piece. Your criterion must be based on monitoring the growth of the absolute value of the latest available higher-order Newton coefficient. Concretely, for a current piece that tentatively includes nodes $x_s,\\dots,x_t$ and a prospective new node $x_{t+1}$, compute the divided-difference coefficients for the tentative set $x_s,\\dots,x_{t+1}$. If the magnitude of the highest-order coefficient $|c_k|$, where $k=t+1-s \\ge 1$, exceeds a prescribed positive threshold $\\tau$, then do not add $x_{t+1}$ to the current piece; instead, finalize the current piece as $x_s,\\dots,x_t$ and start a new piece at $x_{t+1}$. Never use the $k=0$ coefficient (which equals $f[x_s]$) to trigger splitting. If the threshold is never exceeded, you obtain a single global piece.\n\nImplement the following tasks.\n\n- Construct the nodes by taking $N$ equally spaced points on the interval $[-5,5]$, i.e., $x_i=-5 + \\frac{10\\,i}{N-1}$ for $i=0,\\dots,N-1$, and set $y_i=f(x_i)$ with $f(x)=\\frac{1}{1+x^2}$.\n- Implement a sequential piece-construction algorithm that uses the criterion described above with threshold $\\tau>0$:\n  - Initialize a piece at the leftmost node.\n  - Attempt to grow the piece by adding the next node one at a time.\n  - At each attempt, recompute the Newton divided-difference coefficients for the tentative piece and examine only the newest coefficient of order $k \\ge 1$.\n  - If $|c_k| \\le \\tau$, accept the node and continue growing; if $|c_k| > \\tau$, finalize the current piece without the new node and start a new piece at that node.\n- For evaluation, for each piece with nodes $x_s,\\dots,x_t$ and its Newton coefficients $c_0,\\dots,c_{t-s}$, evaluate the polynomial using nested multiplication in the Newton basis at any $x$ in $[x_s,x_t]$.\n\nFor a quantitative assessment, define the maximum absolute error over a dense grid as follows. Let the evaluation grid be $M$ equally spaced points on $[-5,5]$. For each $x$ on this grid, select the piece whose node interval contains $x$ (include the right endpoint in the left piece except for the last piece, which includes $5$), evaluate the corresponding piecewise polynomial, and compute $|p(x)-f(x)|$. Report the maximum over the grid.\n\nYour program must compute, for each test case below, the maximum absolute error on a grid of $M=2001$ equally spaced points in $[-5,5]$, and output the results as a single list in the required format. Use real arithmetic and no external data.\n\nTest suite:\n- Case A (happy path): $N=21$, $\\tau=1.0$.\n- Case B (global polynomial): $N=21$, $\\tau=10^{12}$.\n- Case C (aggressive splitting): $N=21$, $\\tau=10^{-3}$.\n- Case D (small data set): $N=3$, $\\tau=1.0$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C, Case D]. Each entry must be a floating-point number equal to the maximum absolute error for that case, rounded to $6$ decimal places. Example format: $[0.123456,0.000001,0.987654,0.314159]$.",
            "solution": "The problem requires the design and implementation of an adaptive algorithm for constructing a piecewise polynomial interpolant. The core of the task is to develop a data-driven criterion to decide when to partition the interpolation domain, aiming to mitigate the oscillatory behavior characteristic of high-degree global polynomial interpolation on equispaced nodes, famously known as Runge's phenomenon. The function $f(x) = \\frac{1}{1+x^2}$ on the interval $[-5, 5]$ is the canonical example for this issue.\n\nThe fundamental principle behind the proposed algorithm is to monitor the growth of the divided-difference coefficients. For distinct nodes $x_0, x_1, \\dots, x_k$, the $k$-th order divided difference $f[x_0, \\dots, x_k]$ is related to the function's derivatives by the Mean Value Theorem for Divided Differences:\n$$\nf[x_0, \\dots, x_k] = \\frac{f^{(k)}(\\xi)}{k!}\n$$\nfor some $\\xi$ in the interval spanned by the nodes. A large-magnitude divided difference implies a large derivative, which in turn suggests that the interpolating polynomial may experience rapid changes and potential oscillations. The algorithm formalizes this observation into a concrete splitting criterion.\n\nThe algorithm proceeds as follows:\n\n1.  **Node Generation**: The domain $[-5, 5]$ is discretized into a set of $N$ ordered, equispaced nodes, $\\{x_i\\}_{i=0}^{N-1}$, where $x_i = -5 + \\frac{10i}{N-1}$. The corresponding function values are computed as $y_i = f(x_i)$.\n\n2.  **Sequential Piece Construction**: The algorithm iterates through the nodes from left to right to build polynomial pieces.\n    *   Let the current piece begin at node index $s$. Initially, $s=0$.\n    *   The algorithm tentatively adds subsequent nodes $x_{s+1}, x_{s+2}, \\dots, x_t$ one by one.\n    *   For each tentative piece defined on nodes $\\{x_s, \\dots, x_t\\}$, the Newton divided-difference coefficients $c_j = f[x_s, \\dots, x_{s+j}]$ for $j = 0, \\dots, k$ are computed, where $k = t-s$ is the degree of the tentative polynomial.\n    *   **The Splitting Criterion**: The magnitude of the highest-order coefficient, $|c_k| = |f[x_s, \\dots, x_t]|$, is compared against a prescribed positive threshold $\\tau$. This check is performed for any new coefficient of order $k \\ge 1$.\n        *   If $|c_k| \\le \\tau$, the node $x_t$ is successfully incorporated into the current piece. The process continues by considering the next node, $x_{t+1}$.\n        *   If $|c_k| > \\tau$, the addition of node $x_t$ is rejected as it would likely introduce instability. The current piece is finalized with the nodes $\\{x_s, \\dots, x_{t-1}\\}$. A new piece is initiated at node $x_t$, meaning the starting index for the next piece is set to $s \\leftarrow t$.\n\n3.  **Data Structure**: The final result of this process is a set of pieces. Each piece is defined by its constituent nodes $\\{z_0, \\dots, z_d\\}$ (a subsequence of the original $x_i$) and the corresponding Newton coefficients $\\{c_0, \\dots, c_d\\}$.\n\n4.  **Polynomial Evaluation**: For a given point $x_{eval}$, we must first identify the correct polynomial piece. The domain $[-5, 5]$ is partitioned according to the starting nodes of the pieces. If the pieces start at $x_{s_0}, x_{s_1}, \\dots, x_{s_p}$, the $i$-th piece's polynomial is used for evaluation on the interval $[x_{s_i}, x_{s_{i+1}})$. The last piece covers the interval $[x_{s_p}, x_{N-1}]$.\n    Once the appropriate piece with nodes $\\{z_0, \\dots, z_d\\}$ and coefficients $\\{c_0, \\dots, c_d\\}$ is selected, the polynomial is evaluated using Horner's method for the Newton form, which is computationally efficient and numerically stable:\n    $$\n    P(x_{eval}) = (\\dots((c_d \\cdot (x_{eval}-z_{d-1}) + c_{d-1}) \\cdot (x_{eval}-z_{d-2}) + c_{d-2}) \\dots) \\cdot (x_{eval}-z_0) + c_0\n    $$\n\n5.  **Error Assessment**: To quantify the accuracy of the resulting piecewise interpolant $P(x)$, its maximum absolute error is computed against the true function $f(x)$ over a dense evaluation grid of $M=2001$ points in $[-5, 5]$. The error is given by $\\max_{x \\in \\text{grid}} |P(x) - f(x)|$.\n\nThis principled approach allows for an automated transition from a single global polynomial (when $\\tau$ is large) to a fine-grained piecewise polynomial (when $\\tau$ is small), adapting the model complexity to the local behavior of the function as revealed by the divided differences.\n\nThe implementation consists of three main components:\na) A function to compute the Newton divided-difference coefficients for a given set of nodes and values.\nb) The main partitioning logic that iterates through the nodes, applies the criterion, and generates the list of polynomial pieces.\nc) An evaluation function that, for any $x$, finds the correct piece and evaluates its Newton polynomial, which is then used to compute the maximum error over the specified grid.",
            "answer": "```python\nimport numpy as np\n\ndef _compute_divided_diffs(xs, ys):\n    \"\"\"\n    Computes the Newton divided-difference coefficients.\n    The coefficients are the top diagonal of the divided difference table.\n    \n    Args:\n        xs (np.ndarray): The x-coordinates of the nodes.\n        ys (np.ndarray): The y-coordinates of the nodes.\n\n    Returns:\n        np.ndarray: The array of Newton coefficients.\n    \"\"\"\n    n = len(xs)\n    if n == 0:\n        return np.array([])\n    \n    coeffs = np.copy(ys).astype(float)\n    for j in range(1, n):\n        for i in range(n - 1, j - 1, -1):\n            # To avoid division by zero for identical nodes, though problem states distinct.\n            denominator = xs[i] - xs[i - j]\n            if denominator == 0:\n                # This case should not be reached with distinct nodes.\n                # A large value can be used to signal an issue if needed.\n                return np.array([np.inf] * n)\n            coeffs[i] = (coeffs[i] - coeffs[i - 1]) / denominator\n    return coeffs\n\ndef _build_pieces(x_nodes, y_nodes, tau):\n    \"\"\"\n    Constructs the piecewise polynomial based on the splitting criterion.\n\n    Args:\n        x_nodes (np.ndarray): All x-coordinates for interpolation.\n        y_nodes (np.ndarray): All y-coordinates for interpolation.\n        tau (float): The threshold for splitting.\n\n    Returns:\n        list: A list of piece dictionaries. Each dictionary contains 'nodes' and 'coeffs'.\n    \"\"\"\n    N = len(x_nodes)\n    pieces = []\n    start_idx = 0\n\n    for i in range(1, N):\n        tentative_nodes_x = x_nodes[start_idx : i + 1]\n        tentative_nodes_y = y_nodes[start_idx : i + 1]\n        \n        order = len(tentative_nodes_x) - 1\n        \n        # The splitting criterion applies for order k >= 1\n        if order  1:\n            continue\n        \n        coeffs = _compute_divided_diffs(tentative_nodes_x, tentative_nodes_y)\n        highest_order_coeff = coeffs[-1]\n\n        if np.abs(highest_order_coeff) > tau:\n            # Finalize the piece with nodes from start_idx up to i-1\n            final_nodes_x = x_nodes[start_idx : i]\n            final_nodes_y = y_nodes[start_idx : i]\n            final_coeffs = _compute_divided_diffs(final_nodes_x, final_nodes_y)\n            pieces.append({'nodes': final_nodes_x, 'coeffs': final_coeffs})\n            \n            # Start a new piece at index i\n            start_idx = i\n\n    # Add the last remaining piece\n    final_nodes_x = x_nodes[start_idx:N]\n    final_nodes_y = y_nodes[start_idx:N]\n    final_coeffs = _compute_divided_diffs(final_nodes_x, final_nodes_y)\n    pieces.append({'nodes': final_nodes_x, 'coeffs': final_coeffs})\n\n    return pieces\n\ndef _evaluate_newton_poly(x, nodes, coeffs):\n    \"\"\"\n    Evaluates a polynomial in Newton form at a point x using Horner's method.\n    \"\"\"\n    d = len(coeffs) - 1\n    y = coeffs[d]\n    for i in range(d - 1, -1, -1):\n        y = y * (x - nodes[i]) + coeffs[i]\n    return y\n\ndef calculate_max_error(N, tau, M):\n    \"\"\"\n    Performs the full procedure for one test case.\n\n    Args:\n        N (int): Number of interpolation nodes.\n        tau (float): Splitting threshold.\n        M (int): Number of points in the evaluation grid.\n\n    Returns:\n        float: The maximum absolute error.\n    \"\"\"\n    f = lambda x: 1.0 / (1.0 + x**2)\n    \n    # 1. Construct nodes\n    x_nodes = np.linspace(-5.0, 5.0, N)\n    y_nodes = f(x_nodes)\n    \n    # 2. Build piecewise polynomial\n    pieces = _build_pieces(x_nodes, y_nodes, tau)\n    \n    # 3. Evaluate and compute error\n    x_eval_grid = np.linspace(-5.0, 5.0, M)\n    p_eval = np.zeros_like(x_eval_grid)\n    \n    piece_start_nodes_x = [p['nodes'][0] for p in pieces]\n    \n    for i, x_val in enumerate(x_eval_grid):\n        # Find which piece the evaluation point belongs to\n        # 'side=right' ensures that x_val is assigned to the interval [x_s, x_{s+1})\n        piece_idx = np.searchsorted(piece_start_nodes_x, x_val, side='right') - 1\n        # Handle x_val being exactly x_nodes[0] resulted in index -1, so clip to 0\n        if piece_idx  0:\n            piece_idx = 0\n            \n        selected_piece = pieces[piece_idx]\n        \n        p_eval[i] = _evaluate_newton_poly(x_val, selected_piece['nodes'], selected_piece['coeffs'])\n        \n    f_eval = f(x_eval_grid)\n    max_error = np.max(np.abs(p_eval - f_eval))\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (21, 1.0),       # Case A\n        (21, 10e11),     # Case B (10^12)\n        (21, 10e-4),     # Case C (10^-3)\n        (3, 1.0),        # Case D\n    ]\n    \n    M = 2001\n    results = []\n    \n    for N, tau in test_cases:\n        max_err = calculate_max_error(N, tau, M)\n        # The problem asks for the floating-point number to be rounded.\n        results.append(round(max_err, 6))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}