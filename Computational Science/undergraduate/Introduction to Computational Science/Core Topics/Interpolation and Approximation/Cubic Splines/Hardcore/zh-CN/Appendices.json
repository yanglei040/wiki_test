{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式就是动手实践。第一个练习将引导你通过一个简单的数据集，亲手计算并比较两种常见的插值方法：分段线性插值和自然三次样条插值。通过这个直接的对比 ，你将直观地感受到样条插值在提供平滑曲线方面的优势，并为后续更复杂的应用打下坚实的基础。",
            "id": "2164998",
            "problem": "一位工程师正在对一根细柔性杆的形状进行建模，该杆被约束穿过二维笛卡尔平面中的三个点：$P_0=(-1, 1)$, $P_1=(0, 0)$ 和 $P_2=(1, 1)$。提出了两种简单的模型来估计杆在其他水平位置 $x$ 处的垂直位置 $y$。\n\n模型A是分段线性插值，它用直线段连接指定的点。\n模型B是自然三次样条，它通过匹配内点处的一阶和二阶导数来确保曲线光滑，并且在端点处二阶导数为零。\n\n计算由模型A和模型B预测的，当 $x=0.5$ 时杆的垂直位置。分别设这些值为 $y_A$ 和 $y_B$。以一对精确分数 $(y_A, y_B)$ 的形式给出你的答案。",
            "solution": "我们将节点标记为 $x_{0}=-1$、$x_{1}=0$、$x_{2}=1$，对应的数值为 $y_{0}=1$、$y_{1}=0$、$y_{2}=1$。\n\n模型A（分段线性插值）：对于 $x \\in [x_{1},x_{2}]$，穿过 $(0,0)$ 和 $(1,1)$ 的直线的斜率为\n$$\nm=\\frac{y_{2}-y_{1}}{x_{2}-x_{1}}=\\frac{1-0}{1-0}=1,\n$$\n所以插值函数为\n$$\ny(x)=y_{1}+m(x-x_{1})=0+1\\cdot(x-0)=x.\n$$\n在 $x=\\frac{1}{2}$ 处求值得到\n$$\ny_{A}=y\\!\\left(\\frac{1}{2}\\right)=\\frac{1}{2}.\n$$\n\n模型B（自然三次样条）：设 $M_{i}=S''(x_{i})$。自然边界条件给出 $M_{0}=0$ 和 $M_{2}=0$。当 $h_{0}=x_{1}-x_{0}=1$ 且 $h_{1}=x_{2}-x_{1}=1$ 时，在内节点 $i=1$ 处的三次样条方程组为\n$$\nh_{0}M_{0}+2(h_{0}+h_{1})M_{1}+h_{1}M_{2}=6\\left(\\frac{y_{2}-y_{1}}{h_{1}}-\\frac{y_{1}-y_{0}}{h_{0}}\\right).\n$$\n代入数值，\n$$\n1\\cdot 0+2(1+1)M_{1}+1\\cdot 0=6\\left(\\frac{1-0}{1}-\\frac{0-1}{1}\\right)=6(1-(-1))=12,\n$$\n所以\n$$\n4M_{1}=12 \\quad \\Rightarrow \\quad M_{1}=3.\n$$\n在区间 $[x_{1},x_{2}]=[0,1]$ 上，样条函数为\n$$\nS(x)=\\frac{M_{1}}{6h_{1}}(x_{2}-x)^{3}+\\frac{M_{2}}{6h_{1}}(x-x_{1})^{3}+\\left(y_{1}-\\frac{M_{1}h_{1}^{2}}{6}\\right)\\frac{x_{2}-x}{h_{1}}+\\left(y_{2}-\\frac{M_{2}h_{1}^{2}}{6}\\right)\\frac{x-x_{1}}{h_{1}}.\n$$\n当 $h_{1}=1$、$M_{1}=3$、$M_{2}=0$、$y_{1}=0$ 且 $y_{2}=1$ 时，上式简化为\n$$\nS(x)=\\frac{3}{6}(1-x)^{3}+0+\\left(0-\\frac{3}{6}\\right)(1-x)+\\left(1-0\\right)x\n=\\frac{1}{2}(1-x)^{3}-\\frac{1}{2}(1-x)+x.\n$$\n展开并合并同类项，\n$$\nS(x)=\\frac{1}{2}-\\frac{3}{2}x+\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}-\\frac{1}{2}+\\frac{1}{2}x+x\n=-\\frac{1}{2}x^{3}+\\frac{3}{2}x^{2}.\n$$\n在 $x=\\frac{1}{2}$ 处求值得到\n$$\ny_{B}=S\\!\\left(\\frac{1}{2}\\right)=\\frac{3}{2}\\left(\\frac{1}{2}\\right)^{2}-\\frac{1}{2}\\left(\\frac{1}{2}\\right)^{3}\n=\\frac{3}{2}\\cdot\\frac{1}{4}-\\frac{1}{2}\\cdot\\frac{1}{8}\n=\\frac{3}{8}-\\frac{1}{16}\n=\\frac{5}{16}.\n$$\n\n因此，所求的数对是 $\\left(\\frac{1}{2},\\frac{5}{16}\\right)$。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{2} & \\frac{5}{16}\\end{pmatrix}}$$"
        },
        {
            "introduction": "掌握了从数据点到样条曲线的正向构建过程后，让我们来挑战一个逆向问题。本练习提供了一个独特的场景：在数据点不完全确定的情况下，利用样条曲线的一个已知内在属性（特定点的二阶导数值）来反推出未知的数据。这个过程  将加深你对样条构造方程中数据点与曲线曲率之间内在联系的理解。",
            "id": "2164965",
            "problem": "一个记作 $S(x)$ 的自然三次样条被用来插值一组三个数据点：$(x_0, y_0) = (0, 0)$、$(x_1, y_1) = (1, y_1)$ 和 $(x_2, y_2) = (2, 0)$。纵坐标 $y_1$ 的值是未知的。三次样条是一个分段三次且二阶连续可微的函数。对于自然三次样条，其在端点处的二阶导数为零。\n\n另外，已知该样条在内点 $x_1=1$ 处的二阶导数恰好为 $S''(1) = 6$。利用此信息，求 $y_1$ 的值。",
            "solution": "设 $x_{0}=0$，$x_{1}=1$，$x_{2}=2$，其中 $y_{0}=0$，$y_{1}$ 未知，且 $y_{2}=0$。记 $M_{i}=S''(x_{i})$。对于自然三次样条，有 $M_{0}=0$ 和 $M_{2}=0$，并且已知 $M_{1}=6$。\n\n对于三次样条，节点处的二阶导数满足标准的三对角关系（通过在内部节点处强制 $S'(x)$ 连续得到）：\n$$\nh_{0} M_{0} + 2\\left(h_{0}+h_{1}\\right) M_{1} + h_{1} M_{2}\n= 6\\left(\\frac{y_{2}-y_{1}}{h_{1}} - \\frac{y_{1}-y_{0}}{h_{0}}\\right),\n$$\n其中 $h_{i}=x_{i+1}-x_{i}$。在本题中，$h_{0}=x_{1}-x_{0}=1$ 且 $h_{1}=x_{2}-x_{1}=1$，所以方程变为\n$$\nM_{0} + 4 M_{1} + M_{2} = 6\\left((y_{2}-y_{1}) - (y_{1}-y_{0})\\right) = 6(y_{2} - 2 y_{1} + y_{0}).\n$$\n将 $M_{0}=0$，$M_{1}=6$，$M_{2}=0$，$y_{0}=0$ 及 $y_{2}=0$ 代入，我们得到\n$$\n0 + 4\\cdot 6 + 0 = 6(0 - 2 y_{1} + 0),\n$$\n因此\n$$\n24 = -12 y_{1} \\quad \\Longrightarrow \\quad y_{1} = -2.\n$$",
            "answer": "$$\\boxed{-2}$$"
        },
        {
            "introduction": "最后一个练习将带领你从理论走向实践的巅峰，要求你从零开始编写代码来实现三次样条。这个综合性问题  不仅涵盖了样条的构建，还引入了“边界条件”这一关键概念，并让你直面“过冲”（overshoot）这一在实际应用中常见的数值陷阱。通过亲手实现并比较不同边界条件下的样条行为，你将学会如何诊断并解决实际插值问题，获得宝贵的计算科学实践经验。",
            "id": "3220873",
            "problem": "要求您从基本原理出发，实现具有两种不同端点边界条件（自然边界条件和钳位边界条件）的三次样条插值的构建与评估。三次样条定义为一个函数，它由在连续子区间上的分段三次多项式组成，对给定的数据点进行插值，并且在整个定义域上是二阶连续可导的。自然边界条件将端点处的二阶导数设置为零，而钳位边界条件则指定端点处的一阶导数。您的任务是：\n- 针对严格递增的横坐标 $\\{x_i\\}_{i=0}^{n-1}$ 和纵坐标 $\\{y_i\\}_{i=0}^{n-1}$，在自然或钳位边界条件下，推导出一个计算唯一三次样条插值的算法公式。推导必须从其定义属性开始：各区间内为三次多项式、满足插值约束，以及在内部节点处直至二阶导数都连续。\n- 实现两种边界条件的选择。对于钳位边界条件，使用由单边割线斜率给出的端点导数，\n$$\ns_0 \\equiv \\frac{y_1 - y_0}{x_1 - x_0}, \\quad s_{n-1} \\equiv \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}}.\n$$\n\n为了量化反直觉的振荡，将单个子区间 $[x_i,x_{i+1}]$ 上的过冲幅度定义如下。令 $m_i = \\min\\{y_i,y_{i+1}\\}$ 且 $M_i = \\max\\{y_i,y_{i+1}\\}$。令 $S(x)$ 表示样条函数值。在 $[x_i,x_{i+1}]$ 上的过冲幅度为\n$$\n\\Delta_i \\equiv \\max\\Big\\{ \\max_{x \\in [x_i,x_{i+1}]} \\big(S(x) - M_i\\big), \\ \\max_{x \\in [x_i,x_{i+1}]}\\big(m_i - S(x)\\big), \\ 0 \\Big\\}.\n$$\n全局过冲为 $\\Delta \\equiv \\max_i \\Delta_i$。通过在每个子区间 $[x_i,x_{i+1}]$ 上的一个包含1001个点的均匀网格上评估 $S(x)$ 的值，来数值近似子区间上的最大值。\n\n实现一个单独的程序，该程序：\n- 为测试套件中的每个数据集构建自然样条和钳位样条（使用上述的 $s_0$ 和 $s_{n-1}$）。\n- 对每种样条评估并报告其全局过冲 $\\Delta$。\n\n您的实现必须是完全自包含的，并且除了指定的库之外，不得调用其他外部库。所有计算均在纯数学范畴内进行（无物理单位）。\n\n测试套件。使用以下数据集，每个数据集都以等长且 $x$ 值严格递增的列表 $x$ 和 $y$ 的形式给出：\n\n- 案例 A（左端陡峭，导致自然样条在左端点附近产生较大振荡）：\n  - $x = [\\,0.0,\\,0.5,\\,0.6,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,10.0,\\,12.0\\,]$\n\n- 案例 B（近线性，理想情况）：\n  - $x = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n\n- 案例 C（右端陡峭，导致自然样条在右端点附近产生较大振荡）：\n  - $x = [\\,0.0,\\,1.4,\\,1.5,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,2.0,\\,3.0,\\,3.2\\,]$\n\n对于每个案例，计算并返回一对浮点数形式的过冲幅度 $\\Delta_{\\text{natural}}$ 和 $\\Delta_{\\text{clamped}}$。您的程序应生成单行输出，其中包含按以下顺序连接成的、用方括号括起来的逗号分隔列表的所有结果：\n$$\n[\\,\\Delta_{\\text{natural}}^{(A)},\\,\\Delta_{\\text{clamped}}^{(A)},\\,\\Delta_{\\text{natural}}^{(B)},\\,\\Delta_{\\text{clamped}}^{(B)},\\,\\Delta_{\\text{natural}}^{(C)},\\,\\Delta_{\\text{clamped}}^{(C)}\\,].\n$$",
            "solution": "用户要求对自然和钳位两种边界条件下的三次样条插值进行推导和实现。推导必须从基本原理出发，实现部分必须计算几个测试用例的全局过冲。\n\n### 三次样条插值的推导\n\n一个对 $n$ 个具有严格递增横坐标 $x_0 x_1 \\ldots x_{n-1}$ 的数据点 $(x_i, y_i)$（$i=0, 1, \\ldots, n-1$）进行插值的三次样条 $S(x)$，是在 $[x_0, x_{n-1}]$ 上定义的分段函数。对于每个子区间 $[x_i, x_{i+1}]$，样条段 $S_i(x)$ 是一个三次多项式。整个样条函数 $S(x)$ 必须满足以下性质：\n1.  **插值性**：对所有 $i=0, \\ldots, n-1$，有 $S(x_i) = y_i$。\n2.  **连续性**：$S(x)$ 在 $[x_0, x_{n-1}]$ 上是二阶连续可导的，即 $S \\in C^2[x_0, x_{n-1}]$。这意味着在每个内部节点 $x_i$（$i=1, \\ldots, n-2$）处，有 $S_{i-1}(x_i) = S_i(x_i)$，$S'_{i-1}(x_i) = S'_i(x_i)$ 和 $S''_{i-1}(x_i) = S''_i(x_i)$。\n\n让我们将在节点处的样条二阶导数定义为 $M_i = S''(x_i)$，其中 $i=0, \\ldots, n-1$。由于每个样条段 $S_i(x)$ 是一个三次多项式，其二阶导数 $S_i''(x)$ 是一个线性函数。在区间 $[x_i, x_{i+1}]$ 上，$S_i''(x)$ 经过点 $(x_i, M_i)$ 和 $(x_{i+1}, M_{i+1})$。令 $h_i = x_{i+1} - x_i$。线性函数 $S_i''(x)$ 可以用 Lagrange 的线性插值公式写出：\n$$\nS_i''(x) = M_i \\frac{x_{i+1} - x}{h_i} + M_{i+1} \\frac{x - x_i}{h_i}\n$$\n对 $S_i''(x)$ 关于 $x$ 积分两次，得到三次多项式 $S_i(x)$ 的一般形式：\n$$\nS_i(x) = M_i \\frac{(x_{i+1} - x)^3}{6h_i} + M_{i+1} \\frac{(x - x_i)^3}{6h_i} + C(x-x_i) + D(x_{i+1}-x)\n$$\n其中 $C$ 和 $D$ 是积分常数，其表达式形式便于应用插值条件。\n我们强制施加插值条件 $S_i(x_i) = y_i$ 和 $S_i(x_{i+1}) = y_{i+1}$：\n在 $x=x_i$ 处： $y_i = M_i \\frac{h_i^3}{6h_i} + D h_i \\implies D = \\frac{y_i}{h_i} - \\frac{M_i h_i}{6}$。\n在 $x=x_{i+1}$ 处： $y_{i+1} = M_{i+1} \\frac{h_i^3}{6h_i} + C h_i \\implies C = \\frac{y_{i+1}}{h_i} - \\frac{M_{i+1} h_i}{6}$。\n\n将这些常数代回，我们得到样条段 $S_i(x)$ 关于已知数据点和未知二阶导数 $M_i$ 的表达式：\n$$\nS_i(x) = \\frac{M_i}{6h_i}(x_{i+1}-x)^3 + \\frac{M_{i+1}}{6h_i}(x-x_i)^3 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right)(x-x_i) + \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)(x_{i+1}-x)\n$$\n此方程定义了在每个子区间 $[x_i, x_{i+1}]$（$i=0, \\ldots, n-2$）上的样条。为了找到未知值 $M_i$，我们在内部节点 $x_i$（$i=1, \\ldots, n-2$）处使用一阶导数的连续性条件 $S'_{i-1}(x_i) = S'_i(x_i)$。\n\n首先，我们求导数 $S'_i(x)$：\n$$\nS'_i(x) = -\\frac{M_i}{2h_i}(x_{i+1}-x)^2 + \\frac{M_{i+1}}{2h_i}(x-x_i)^2 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right) - \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)\n$$\n在节点处计算导数值：\n$S'_i(x_i) = -\\frac{M_i h_i}{2} + \\frac{y_{i+1}-y_i}{h_i} - \\frac{M_{i+1}h_i}{6} + \\frac{M_i h_i}{6} = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}$。\n$S'_{i-1}(x_i) = \\frac{M_{i-1}h_{i-1}}{6} + \\frac{M_i h_{i-1}}{3} + \\frac{y_i-y_{i-1}}{h_{i-1}}$。\n\n对于 $i=1, \\ldots, n-2$，令 $S'_{i-1}(x_i) = S'_i(x_i)$：\n$$\n\\frac{y_i-y_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{6}M_{i-1} + \\frac{h_{i-1}}{3}M_i = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}\n$$\n重新排列各项，将未知数 $M_{i-1}$，$M_i$ 和 $M_{i+1}$ 组合在一起：\n$$\nh_{i-1}M_{i-1} + (2h_{i-1} + 2h_i)M_i + h_iM_{i+1} = 6\\left(\\frac{y_{i+1}-y_i}{h_i} - \\frac{y_i-y_{i-1}}{h_{i-1}}\\right)\n$$\n这个基本关系为 $n$ 个未知数 $M_0, \\ldots, M_{n-1}$ 提供了 $n-2$ 个线性方程组成的方程组。为了获得唯一解，我们需要另外两个方程，这两个方程由边界条件提供。\n\n### 边界条件\n\n**1. 自然样条：**\n自然边界条件指定了端点处的曲率为零：$S''(x_0)=0$ 和 $S''(x_{n-1})=0$。这直接转化为：\n$$\nM_0 = 0, \\quad M_{n-1} = 0\n$$\n将这些代入一般方程组，剩下 $n-2$ 个方程求解 $n-2$ 个未知数 $M_1, \\ldots, M_{n-2}$。该方程组构成一个严格对角占优的三对角矩阵，从而保证了解的唯一性。\n\n**2. 钳位样条：**\n钳位边界条件指定了端点处的一阶导数：$S'(x_0)=s_0$ 和 $S'(x_{n-1})=s_{n-1}$。\n使用我们关于 $S'_i(x_i)$ 的表达式，我们设置 $i=0$：\n$S'(x_0) = S'_0(x_0) = \\frac{y_1-y_0}{h_0} - \\frac{h_0}{3}M_0 - \\frac{h_0}{6}M_1 = s_0$。\n重新整理得到第一个边界方程：\n$$\n2h_0M_0 + h_0M_1 = 6\\left(\\frac{y_1-y_0}{h_0} - s_0\\right)\n$$\n对于在 $x_{n-1}$ 处的条件，我们计算 $S'_{n-2}(x_{n-1})=s_{n-1}$：\n$S'_{n-2}(x_{n-1}) = \\frac{y_{n-1}-y_{n-2}}{h_{n-2}} + \\frac{h_{n-2}}{6}M_{n-2} + \\frac{h_{n-2}}{3}M_{n-1} = s_{n-1}$。\n重新整理得到第二个边界方程：\n$$\nh_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 6\\left(s_{n-1} - \\frac{y_{n-1}-y_{n-2}}{h_{n-2}}\\right)\n$$\n问题指定了 $s_0$ 和 $s_{n-1}$ 的特定值：\n$s_0 = \\frac{y_1 - y_0}{x_1 - x_0} = \\frac{y_1 - y_0}{h_0}$\n$s_{n-1} = \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}} = \\frac{y_{n-1} - y_{n-2}}{h_{n-2}}$\n通过这些选择，两个边界方程的右侧都变为零：\n$2h_0M_0 + h_0M_1 = 0 \\implies 2M_0 + M_1 = 0$。\n$h_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 0 \\implies M_{n-2} + 2M_{n-1} = 0$。\n这两个方程与 $n-2$ 个内部方程相结合，为未知数 $M_0, \\ldots, M_{n-1}$ 构成一个完整的 $n \\times n$ 三对角方程组。该系统也是严格对角占优的，并有唯一解。\n\n### 过冲计算\n\n在子区间 $[x_i, x_{i+1}]$ 上的过冲幅度定义为：\n$$\n\\Delta_i = \\max\\left\\{ \\max_{x \\in [x_i,x_{i+1}]} \\left(S(x) - \\max\\{y_i,y_{i+1}\\}\\right), \\ \\max_{x \\in [x_i,x_{i+1}]}\\left(\\min\\{y_i,y_{i+1}\\} - S(x)\\right), \\ 0 \\right\\}\n$$\n全局过冲是所有子区间的最大值，即 $\\Delta = \\max_i \\Delta_i$。在计算上，通过在跨越 $[x_i, x_{i+1}]$ 的一个包含1001个点的精细均匀网格上评估样条函数 $S(x)$ 的值来近似每个子区间上的最大值。这个过程量化了样条函数在其插值数据点范围之外振荡的程度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tdma(lower, main, upper, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d using the Thomas algorithm.\n\n    Args:\n        lower (np.ndarray): The lower diagonal of A (length n-1).\n        main (np.ndarray): The main diagonal of A (length n).\n        upper (np.ndarray): The upper diagonal of A (length n-1).\n        d (np.ndarray): The right-hand side vector (length n).\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(main)\n    c_p = np.zeros(n)\n    d_p = np.zeros(n)\n\n    # Forward elimination\n    c_p[0] = upper[0] / main[0]\n    d_p[0] = d[0] / main[0]\n    for i in range(1, n):\n        denom = main[i] - lower[i-1] * c_p[i-1]\n        if i  n - 1:\n            c_p[i] = upper[i] / denom\n        d_p[i] = (d[i] - lower[i-1] * d_p[i-1]) / denom\n\n    # Backward substitution\n    x = np.zeros(n)\n    x[n-1] = d_p[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_p[i] - c_p[i] * x[i+1]\n    return x\n\nclass CubicSpline:\n    \"\"\"\n    A class for computing and evaluating cubic spline interpolants.\n    \"\"\"\n    def __init__(self, x, y, bc_type='natural'):\n        self.x = np.asarray(x, dtype=float)\n        self.y = np.asarray(y, dtype=float)\n        self.n = len(x)\n        \n        if self.n  2:\n            raise ValueError(\"Need at least 2 points for interpolation.\")\n        \n        self.h = self.x[1:] - self.x[:-1]\n        \n        if np.any(self.h = 0):\n            raise ValueError(\"x coordinates must be strictly increasing.\")\n\n        if bc_type == 'natural':\n            self._compute_natural_spline()\n        elif bc_type == 'clamped':\n            self._compute_clamped_spline()\n        else:\n            raise ValueError(f\"Unsupported boundary condition type: {bc_type}\")\n\n    def _compute_natural_spline(self):\n        \"\"\"Computes the second derivatives M for a natural spline.\"\"\"\n        if self.n == 2:\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n - 2  # Size of the internal system\n        \n        A_lower = self.h[1:-1]\n        A_main = 2 * (self.h[:-1] + self.h[1:])\n        A_upper = self.h[1:-1]\n\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        b_rhs = 6 * (delta[1:] - delta[:-1])\n\n        M_internal = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n        \n        self.M = np.zeros(self.n)\n        self.M[1:-1] = M_internal\n\n    def _compute_clamped_spline(self):\n        \"\"\"Computes the second derivatives M for a clamped spline with specified derivatives.\"\"\"\n        if self.n == 2:\n            # Linear interpolation for 2 points, second derivatives are zero\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n\n        A_lower = np.zeros(N - 1)\n        A_main = np.zeros(N)\n        A_upper = np.zeros(N - 1)\n        b_rhs = np.zeros(N)\n\n        # First row from boundary condition: 2*M_0 + M_1 = 0\n        A_main[0] = 2.0\n        A_upper[0] = 1.0\n        b_rhs[0] = 0.0\n\n        # Internal rows\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        internal_rhs = 6 * (delta[1:] - delta[:-1])\n        b_rhs[1:-1] = internal_rhs\n\n        A_main[1:-1] = 2 * (self.h[:-1] + self.h[1:])\n        A_lower[:-1] = self.h[:-1]\n        A_upper[1:] = self.h[1:]\n\n        # Last row from boundary condition: M_{n-2} + 2*M_{n-1} = 0\n        A_lower[-1] = 1.0\n        A_main[-1] = 2.0\n        b_rhs[-1] = 0.0\n        \n        self.M = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n\n    def evaluate(self, x_eval):\n        \"\"\"Evaluates the spline at given points.\"\"\"\n        x_eval = np.asarray(x_eval)\n        indices = np.searchsorted(self.x, x_eval, side='right') - 1\n        indices = np.clip(indices, 0, self.n - 2)\n\n        xi = self.x[indices]\n        xi1 = self.x[indices + 1]\n        yi = self.y[indices]\n        yi1 = self.y[indices + 1]\n        hi = self.h[indices]\n        Mi = self.M[indices]\n        Mi1 = self.M[indices + 1]\n\n        t = x_eval - xi\n        t_comp = xi1 - x_eval\n        \n        term1 = (Mi / (6 * hi)) * (t_comp**3)\n        term2 = (Mi1 / (6 * hi)) * (t**3)\n        term3 = (yi1 / hi - Mi1 * hi / 6) * t\n        term4 = (yi / hi - Mi * hi / 6) * t_comp\n        \n        return term1 + term2 + term3 + term4\n\ndef calculate_overshoot(spline, n_grid=1001):\n    \"\"\"Calculates the global overshoot magnitude for a given spline.\"\"\"\n    max_overshoot = 0.0\n    for i in range(spline.n - 1):\n        xi, xi1 = spline.x[i], spline.x[i+1]\n        yi, yi1 = spline.y[i], spline.y[i+1]\n        \n        m_i = min(yi, yi1)\n        M_i = max(yi, yi1)\n        \n        x_grid = np.linspace(xi, xi1, n_grid)\n        y_grid = spline.evaluate(x_grid)\n        \n        overshoot = np.max(y_grid) - M_i\n        undershoot = m_i - np.min(y_grid)\n        \n        interval_max_deviation = max(overshoot, undershoot, 0.0)\n        \n        if interval_max_deviation > max_overshoot:\n            max_overshoot = interval_max_deviation\n            \n    return max_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (left-end steepening)\n        {'x': [0.0, 0.5, 0.6, 2.0], 'y': [0.0, 1.0, 10.0, 12.0]},\n        # Case B (near-linear)\n        {'x': [0.0, 1.0, 2.0, 3.0], 'y': [0.0, 1.0, 2.0, 3.0]},\n        # Case C (right-end steepening)\n        {'x': [0.0, 1.4, 1.5, 2.0], 'y': [0.0, 2.0, 3.0, 3.2]}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x = case['x']\n        y = case['y']\n        \n        # Natural Spline\n        natural_spline = CubicSpline(x, y, bc_type='natural')\n        delta_natural = calculate_overshoot(natural_spline)\n        results.append(delta_natural)\n        \n        # Clamped Spline\n        clamped_spline = CubicSpline(x, y, bc_type='clamped')\n        delta_clamped = calculate_overshoot(clamped_spline)\n        results.append(delta_clamped)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}