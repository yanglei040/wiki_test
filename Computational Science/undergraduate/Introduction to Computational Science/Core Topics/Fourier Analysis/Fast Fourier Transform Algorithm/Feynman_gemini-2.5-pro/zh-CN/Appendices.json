{
    "hands_on_practices": [
        {
            "introduction": "快速傅里叶变换 (FFT) 算法的效率源于其“分而治之”的策略。在经典的按时间抽取 (Decimation-In-Time, DIT) FFT 实现中，一个关键的初始步骤是对输入数据进行重新排序。这个动手练习将帮助您掌握这种被称为“位倒序” (bit-reversal) 的基本数据整理机制，这是理解 FFT 如何高效组织其计算流程的第一步。通过这个简单的练习 ，您将亲手计算一个样本在位倒序后的新索引，从而对算法的内部工作原理有一个具体而直观的认识。",
            "id": "1717784",
            "problem": "一位嵌入式系统工程师的任务是在一个内存有限的微控制器上实现一个实时音频频谱分析仪。为此，该工程师决定使用基2时间抽取（DIT）快速傅里叶变换（FFT）算法。该算法的第一个关键步骤是在主蝶形运算开始之前，对输入的时域样本进行重新排序。这个重排序是通过将原始序列中索引为 $n$ 的样本 $x[n]$ 放置到乱序序列中的新位置（索引为 $k$）来完成的。新索引 $k$ 是通过反转原始索引 $n$ 的二进制表示来得到的。\n\n考虑一个离散时间信号，它被采样产生一个 $N=8$ 点的序列，记为 $x[n]$，其中 $n=0, 1, 2, ..., 7$。根据 DIT-FFT 的位反转（bit-reversal）过程，样本 $x[6]$ 将被移动到重新排序后的输入缓冲区中的一个新索引位置。这个新索引的数值是多少？",
            "solution": "在序列长度为 $N=2^{m}$ 的基2 DIT-FFT中，位反转重排序通过反转索引 $n$ 的 $m$ 位二进制表示，将其映射到新索引 $k$。形式上，如果 $n=\\sum_{i=0}^{m-1} b_{i} 2^{i}$，其中 $b_{i}\\in\\{0,1\\}$，那么位反转后的索引是\n$$\nk=\\sum_{i=0}^{m-1} b_{i} 2^{m-1-i}.\n$$\n对于 $N=8$，我们有 $m=\\log_{2}(8)=3$。索引 $n=6$ 的3位二进制表示为\n$$\n6=1\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}\\;\\Rightarrow\\;(110)_{2},\n$$\n所以 $b_{2}=1$，$b_{1}=1$，$b_{0}=0$。反转这三位得到 $(011)_{2}$，其十进制值为\n$$\nk=0\\cdot 2^{2}+1\\cdot 2^{1}+1\\cdot 2^{0}=3.\n$$\n因此，在 $N=8$ 的 DIT-FFT 位反转重排序下，样本 $x[6]$ 被移动到索引 $k=3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在使用 FFT 分析信号频谱时，一个常见的问题是如何更清晰地观察感兴趣的频率。补零 (zero-padding) 是一种常用技术，但其效果常常被误解。这个实践项目  旨在通过编程实验，揭示“表观分辨率”和“真实分辨率”之间的本质区别。您将亲手验证，补零虽然能够提供一个采样更密集的频谱（即频谱插值），但并不能提高区分两个相近频率的根本能力——后者由原始信号的观测时长决定。通过完成这个练习，您将深刻理解频谱泄漏以及频率分辨率的真正含义，从而避免在频谱分析中落入常见陷阱。",
            "id": "3127394",
            "problem": "你需要编写一个完整、可运行的程序，使用快速傅里叶变换（FFT）算法，以通过经验证明补零对离散傅里叶变换（DFT）插值的影响，表明对有限序列 $x_n$ 进行补零会增加表观频率分辨率（即更密集的频率采样），但不会提高真实的分辨能力（即区分两个频率相近的正弦波的能力）。从有限序列 $x_n$, $n \\in \\{0,1,\\dots,N-1\\}$ 的离散傅里叶变换（DFT）的基本定义开始，\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / N},\n$$\n并使用快速傅里叶变换（FFT）算法实现其计算。使用由于将 $x_n$ 截断到 $n \\in \\{0,\\dots,N-1\\}$ 而隐式引入的长度为 $N$ 的矩形窗。对于补零，定义一个扩展长度 $M > N$ 并考虑以下DFT\n$$\nX^{(M)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / M},\n$$\n它在更精细的 $k$ 值网格上对相同的底层频谱进行采样。\n\n你的程序必须构建形式为 $x_n = \\sin(2\\pi f_0 n)$ 或 $x_n = \\sin(2\\pi f_1 n) + \\sin(2\\pi f_2 n)$ 的离散时间信号，其中角度以弧度为单位， $f_0, f_1, f_2$ 是以周/采样点为单位的离散时间频率，并满足 $0 < f < 1/2$。采样率为 $f_s = 1$ 采样点/单位时间，因此频率的单位是周/采样点。对于单音情况，通过在正频率半谱上选择最大幅度的DFT样本的索引 $k$ 来估计频率，并将其映射为 $\\hat f = k/M$ （对于补零长度 $M$）或 $\\hat f = k/N$ （对于未补零长度 $N$）。以浮点数形式报告绝对估计误差 $|\\hat f - f_0|$，单位为周/采样点。对于双音情况，通过计算正频率幅度谱上的显著局部最大值的数量来确定两个峰值是否被分辨：如果位于频点 $k$ 的峰值严格大于其近邻，并且其幅度至少是该谱上最大幅度的一半，则该峰值为显著的。对于未补零和补零的情况，以布尔值形式报告分辨率。角度必须以弧度为单位，所有报告的频率和误差都必须以周/采样点为单位。\n\n使用指定的参数实现以下测试套件：\n\n- 情况1（单音不落在DFT频点上）：\n  - $N = 128$, $M = 2048$, $f_0 = 0.163$，相位 $0$ 弧度。\n  - 输出：两个浮点数，分别是未补零情况下的绝对误差和补零情况下的绝对误差。\n\n- 情况2（两个等幅度的音调，其间距小于序列长度所决定的分辨率）：\n  - $N = 128$, $M = 4096$, $f_1 = 0.200$, $f_2 = 0.200 + \\frac{0.6}{128}$，两个振幅均为 $1$。\n  - 输出：两个布尔值，分别表示在未补零情况下两个峰值是否被分辨，以及在补零情况下是否被分辨。\n\n- 情况3（两个等幅度的音调，其间距大于序列长度所决定的分辨率）：\n  - $N = 128$, $M = 4096$, $f_1 = 0.200$, $f_2 = 0.200 + \\frac{1.2}{128}$，两个振幅均为 $1$。\n  - 输出：两个布尔值，分别表示在未补零情况下两个峰值是否被分辨，以及在补零情况下是否被分辨。\n\n- 情况4（单音恰好落在DFT频点上）：\n  - $N = 128$, $M = 2048$, $f_0 = \\frac{17}{128}$，相位 $0$ 弧度。\n  - 输出：两个浮点数，分别是未补零情况下的绝对误差和补零情况下的绝对误差。\n\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须是按顺序连接上述案例输出的结果：\n$$\n[\\text{err1\\_unpadded},\\text{err1\\_padded},\\text{res2\\_unpadded},\\text{res2\\_padded},\\text{res3\\_unpadded},\\text{res3\\_padded},\\text{err4\\_unpadded},\\text{err4\\_padded}].\n$$\n所有浮点数均以周/采样点为单位，布尔值以编程语言的常规布尔文字表示。",
            "solution": "该问题是有效的，因为它科学地基于数字信号处理的原理，问题陈述清晰，提供了所有必要的参数和定义，并且其表述是客观的。它提出了一个标准的、不平凡的计算练习，旨在在快速傅里叶变换（FFT）的背景下，通过补零来演示频率分辨率和频谱插值的概念。\n\n### 基于原理的解决方案\n\n这个问题的核心在于理解离散傅里叶变换（DFT）的性质，以及它们如何受到信号有限长度和补零技术的影响。\n\n**1. 离散傅里叶变换 (DFT)**\n\n对于一个长度为 $N$ 的有限长度离散时间信号 $x_n$，定义于 $n \\in \\{0, 1, ..., N-1\\}$，其 DFT $X_k$ 由下式给出：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / N}\n$$\n其中 $k \\in \\{0, 1, ..., N-1\\}$，$j$ 是虚数单位。DFT 提供了信号的频域表示，它在 $N$ 个离散频率点 $f_k = k/N$ 上对其频谱进行采样（对于采样率为 $f_s=1$ 周/采样点的情况）。该计算可使用快速傅里叶变换（FFT）算法高效执行，其计算复杂度为 $O(N \\log N)$，而直接计算 DFT 的复杂度为 $O(N^2)$。\n\n**2. 加窗与频谱泄漏**\n\n观察一个有限时长 $N$ 的信号，等同于将一个无限长的信号与一个长度为 $N$ 的矩形窗相乘。在频域中，这种乘法对应于信号的真实频谱与矩形窗的傅里叶变换进行卷积。矩形窗的变换是一个 sinc 函数（$\\text{sinc}(f) = \\sin(\\pi f) / (\\pi f)$）。这种卷积导致单个正弦频率的能量“泄漏”到相邻的频率点中，这种现象称为频谱泄漏。\n\n如果一个信号的频率 $f_0$ 正好与一个 DFT 频点频率重合（即 $f_0 = k_0/N$ 对于某个整数 $k_0$），其所有能量都集中在该单个频点（及其负频率对应点）中，没有泄漏。然而，如果 $f_0$ 落在两个 DFT 频点之间，那么频谱中产生的 sinc 函数的峰值也会位于频点之间，其能量会扩散到所有频率点。$N$点 DFT 以 $1/N$ 的粗略间隔对这个 sinc 形频谱进行采样，这意味着测得的峰值幅度可能远低于真实峰值，并且其表观位置将是最近的频点，从而引入估计误差。\n\n**3. 补零与频谱插值**\n\n补零是在执行 DFT 之前，在信号序列末尾追加零的过程。如果我们将 $M-N$ 个零附加到我们的 $N$ 点序列 $x_n$ 以创建一个长度为 $M > N$ 的新序列 $x'_n$，其 DFT 为：\n$$\nX^{(M)}_k = \\sum_{n=0}^{M-1} x'_n \\, e^{-j 2\\pi k n / M} = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / M}\n$$\n此操作不会向信号添加新信息。相反，它在更精细的频率网格 $f_k = k/M$ 上计算 DFT。底层的连续频谱（DTFT，离散时间傅里叶变换）保持不变，但我们是在 $M$ 个点而不是 $N$ 个点上对其进行采样。这个过程是频谱插值的一种形式。它通过揭示由加窗引起的底层 sinc 形谱瓣的更多细节，提供了一个“更好看”的频谱。\n\n**4. 频率分辨率**\n\n频率分辨率是区分两个频率相近的频率分量的能力。它从根本上取决于窗函数变换的主瓣宽度。对于长度为 $N$ 的矩形窗，主瓣宽度约为 $2/N$。瑞利判据（Rayleigh criterion）表明，如果两个等幅正弦波的频率间隔至少为 $\\Delta f \\approx 1/N$，则它们是可分辨的。\n\n补零增加了 DFT 频点的数量，因此通过更密集地采样频谱来提供更高的“表观”分辨率。然而，它并不会使频谱分量的主瓣变窄。如果两个频率非常接近，以至于它们的主瓣合并成一个单峰，补零只会对那个单一的、合并的峰进行插值。它不会提高“真实”的分辨能力，该能力仍然受限于原始信号时长 $N$。\n\n### 测试案例分析\n\n**情况1：单音不落在 DFT 频点上**\n- $f_0 = 0.163$。对于 $N=128$，最近的频点是 $k = \\text{round}(0.163 \\times 128) = \\text{round}(20.864) = 21$。不补零时的估计频率将是 $21/128 = 0.1640625$。\n- 补零到 $M=2048$ 允许对以真实频率 $f_0 = 0.163$ 为中心的 sinc 频谱峰值进行更精细的采样。最近的频点将是 $k = \\text{round}(0.163 \\times 2048) = \\text{round}(333.824) = 334$。新的估计是 $334/2048 \\approx 0.1630859$。补零后的误差将显著减小。\n\n**情况2：两个音调的间距小于分辨率极限**\n- 频率间隔为 $\\Delta f = 0.6/128$，小于瑞利判据的 $\\approx 1/128$。\n- 两个频谱分量的主瓣将大幅重叠，在频谱中形成一个更宽的单峰。\n- 无论是未补零的 $N=128$ DFT 还是补零的 $M=4096$ DFT 都无法将它们分辨成两个独立的峰。我们预期分辨率测试对两者都返回 `False`。\n\n**情况3：两个音调的间距大于分辨率极限**\n- 频率间隔为 $\\Delta f = 1.2/128$，大于瑞利判据。两个主瓣应该有足够的分离度以被区分。\n- 在未补零的 $N=128$ 情况下，如果采样点落在不利位置，DFT的粗略采样可能仍无法揭示两个不同的局部最大值。\n- 在补零的 $M=4096$ 情况下，频谱的精细采样几乎肯定会揭示两个不同的峰值。我们预期未补零情况下为`False`（或可能为`True`），补零情况下为`True`，这清楚地展示了补零对于峰值可视化的效用。\n\n**情况4：单音恰好落在 DFT 频点上**\n- $f_0 = 17/128$。这个频率对于 $N=128$ 点的 DFT 来说恰好是一个频点中心（在 $k=17$ 处）。\n- 它对于 $M=2048$ 点的 DFT 来说也是一个精确的频点中心，因为 $f_0 = 17/128 = (17 \\times 16) / (128 \\times 16) = 272/2048$（在 $k=272$ 处）。\n- 在这两种情况下，都没有频谱泄漏。峰值将在完全正确的频点上找到，因此未补零和补零变换的估计误差均为 $0.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and demonstrate the effects of zero-padding.\n    \"\"\"\n\n    def estimate_single_tone_error(N, M, f0):\n        \"\"\"\n        Calculates frequency estimation error for a single-tone signal.\n        \"\"\"\n        # Generate N-point signal\n        n = np.arange(N)\n        x_n = np.sin(2 * np.pi * f0 * n)\n\n        # --- Unpadded case ---\n        # Compute N-point FFT\n        X_k_unpadded = np.fft.fft(x_n)\n        # Get magnitudes for positive frequencies (k=1 to N/2)\n        # We search from k=1 because f>0\n        mags_unpadded = np.abs(X_k_unpadded[1:N//2 + 1])\n        # Find index of max magnitude (add 1 to map back to original k index)\n        k_max_unpadded = np.argmax(mags_unpadded) + 1\n        f_hat_unpadded = k_max_unpadded / N\n        err_unpadded = abs(f_hat_unpadded - f0)\n\n        # --- Padded case ---\n        # Create zero-padded signal\n        x_n_padded = np.zeros(M)\n        x_n_padded[:N] = x_n\n        # Compute M-point FFT\n        X_k_padded = np.fft.fft(x_n_padded)\n        # Get magnitudes for positive frequencies (k=1 to M/2)\n        mags_padded = np.abs(X_k_padded[1:M//2 + 1])\n        # Find index of max magnitude\n        k_max_padded = np.argmax(mags_padded) + 1\n        f_hat_padded = k_max_padded / M\n        err_padded = abs(f_hat_padded - f0)\n        \n        return err_unpadded, err_padded\n\n    def check_two_tone_resolution(N, M, f1, f2):\n        \"\"\"\n        Determines if two tones are resolved for unpadded and padded FFTs.\n        \"\"\"\n        # Generate N-point signal\n        n = np.arange(N)\n        x_n = np.sin(2 * np.pi * f1 * n) + np.sin(2 * np.pi * f2 * n)\n\n        def count_significant_peaks(spectrum, L):\n            \"\"\"\n            Counts peaks based on the problem's definition.\n            A peak at bin k is significant if it is strictly greater than its\n            immediate neighbors and its magnitude is at least one-half of the\n            largest magnitude on the positive-frequency spectrum.\n            \"\"\"\n            # We only analyze the positive frequency half of the spectrum\n            mags = np.abs(spectrum[1:L//2 + 1])\n            max_mag = np.max(mags)\n            \n            # If max_mag is zero or very small, no peaks\n            if max_mag  1e-9:\n                return 0\n            \n            peak_count = 0\n            # Iterate from k=2 to L/2-1 to have neighbors k-1 and k+1\n            # The search range is wide enough for the problem's frequencies\n            for k_idx in range(1, len(mags) - 1):\n                # k_idx is index in mags array, k is actual DFT bin index\n                if mags[k_idx] > mags[k_idx - 1] and \\\n                   mags[k_idx] > mags[k_idx + 1] and \\\n                   mags[k_idx] >= 0.5 * max_mag:\n                    peak_count += 1\n            return peak_count\n\n        # --- Unpadded case ---\n        X_k_unpadded = np.fft.fft(x_n, N)\n        peaks_unpadded = count_significant_peaks(X_k_unpadded, N)\n        res_unpadded = (peaks_unpadded >= 2)\n\n        # --- Padded case ---\n        X_k_padded = np.fft.fft(x_n, M)\n        peaks_padded = count_significant_peaks(X_k_padded, M)\n        res_padded = (peaks_padded >= 2)\n\n        return res_unpadded, res_padded\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {'type': 'single', 'N': 128, 'M': 2048, 'f0': 0.163},\n        {'type': 'two', 'N': 128, 'M': 4096, 'f1': 0.200, 'f2': 0.200 + 0.6 / 128},\n        {'type': 'two', 'N': 128, 'M': 4096, 'f1': 0.200, 'f2': 0.200 + 1.2 / 128},\n        {'type': 'single', 'N': 128, 'M': 2048, 'f0': 17.0 / 128},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'single':\n            err_unpadded, err_padded = estimate_single_tone_error(case['N'], case['M'], case['f0'])\n            results.extend([err_unpadded, err_padded])\n        elif case['type'] == 'two':\n            res_unpadded, res_padded = check_two_tone_resolution(case['N'], case['M'], case['f1'], case['f2'])\n            results.extend([res_unpadded, res_padded])\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "快速傅里叶变换最重要的应用之一是实现快速卷积，这是数字滤波、图像处理等众多领域的基石。卷积定理指出，时域中的卷积等效于频域中的逐点相乘。然而，FFT/DFT 内在地假设信号是周期性的，这导致其计算的是“循环卷积”，而非通常所需的“线性卷积”。本编码练习  将指导您揭示循环卷积产生的“环绕”失真，并学习如何通过正确地使用补零来获得准确的线性卷积结果。掌握这一技能对于将 FFT 应用于实际滤波问题至关重要。",
            "id": "3282547",
            "problem": "要求你研究快速傅里叶变换 (FFT) 算法中固有的周期性假设如何影响卷积，以及零填充如何减轻环绕失真 (wrap-around artifacts)。所有工作都必须在离散时间内完成。你的程序必须从核心定义开始，实现以下内容。\n\n设一个有限长度的非周期离散时间信号定义为 $x[n] = n + 1$（对于 $n \\in \\{0,1,\\dots,N-1\\}$），其他情况下 $x[n] = 0$，其中 $N = 10$。设一个有限长度的非周期平均核定义为 $h[n] = \\frac{1}{M}$（对于 $n \\in \\{0,1,\\dots,M-1\\}$），其他情况下 $h[n] = 0$，其中 $M = 4$。定义线性卷积 $y_{\\mathrm{lin}}[n]$ 为\n$$\ny_{\\mathrm{lin}}[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k],\n$$\n其中 $x[n]$ 和 $h[n]$ 在其指定的支撑集之外均取零值。该和是有限的，且 $y_{\\mathrm{lin}}[n]$ 的长度为 $N+M-1 = 13$。\n\n对于支撑集为 $\\{0,1,\\dots,L-1\\}$ 的序列 $a[n]$，定义其长度为 $L$ 的离散傅里叶变换 (DFT) 为\n$$\nA_L[m] = \\sum_{n=0}^{L-1} a[n]\\,e^{-2\\pi i \\frac{mn}{L}},\\quad m=0,1,\\dots,L-1,\n$$\n及其逆变换为\n$$\na[n] = \\frac{1}{L}\\sum_{m=0}^{L-1} A_L[m]\\,e^{2\\pi i \\frac{mn}{L}}.\n$$\n对于给定的长度 $L$，构建零填充版本 $x_L[n]$ 和 $h_L[n]$ 如下：\n$$\nx_L[n] = \\begin{cases}\nx[n], 0\\le n\\le N-1\\\\\n0, \\text{otherwise}\n\\end{cases},\\quad\nh_L[n] = \\begin{cases}\nh[n], 0\\le n\\le M-1\\\\\n0, \\text{otherwise}\n\\end{cases},\n$$\n其中 $n\\in\\{0,1,\\dots,L-1\\}$。使用快速傅里叶变换 (FFT)，通过在 DFT 域中进行逐点相乘来计算长度为 $L$ 的循环卷积\n$$\ny_{\\mathrm{circ},L}[n] = \\sum_{k=0}^{L-1} x_L[k]\\,h_L[(n-k)\\bmod L],\\quad n=0,1,\\dots,L-1,\n$$\n一个经过充分验证的事实是，DFT 的乘积对应于时域中的循环卷积。\n\n为了量化环绕失真，对每个 $L$ 定义误差\n$$\nE(L) = \\max_{0\\le n \\le L-1} \\left| y_{\\mathrm{circ},L}[n] - y_{\\mathrm{lin},L}[n] \\right|,\n$$\n其中 $y_{\\mathrm{lin},L}[n]$ 是线性卷积 $y_{\\mathrm{lin}}[n]$（如果 $L \\le N+M-1$，则截断为其前 $L$ 个样本；如果 $L \\ge N+M-1$，则在末尾填充 $L-(N+M-1)$ 个零）。这种通用的比较长度确保了在 $L$ 个样本上的逐点误差。如果 $E(L)$ 显著大于数值舍入误差，则表明存在环绕失真。\n\n你的任务是：\n- 实现上述定义，并为一组填充长度测试集 $L \\in \\{10,12,13,16,64\\}$ 计算 $E(L)$。\n- 解读结果以评估三种填充策略 $L$：不填充 $L=N$，最小填充 $L=N+M-1$，以及 2 的幂次填充 $L=\\min\\{2^p: 2^p\\ge N+M-1\\}$，并使用一个额外的超大填充 $L=64$ 来探究数值稳定性。\n\n你的程序应产生单行输出，其中包含按测试集顺序排列的结果，形式为逗号分隔的浮点误差列表，并用方括号括起来，例如 $[e_{10},e_{12},e_{13},e_{16},e_{64}]$，其中每个 $e_L$ 是针对该 $L$ 计算出的 $E(L)$。不允许有任何其他输出。\n\n请确保你的实现是自包含的，不使用用户输入，并遵循上述定义。根据定义，复指数中的角度以弧度为单位。不涉及任何物理单位。目标受众是学习数值方法和科学计算的高年级本科生。",
            "solution": "该问题要求研究如何使用快速傅里叶变换 (FFT) 来计算两个离散时间信号的线性卷积。所考察的核心原理是离散傅里叶变换 (DFT) 的卷积定理，该定理指出，两个序列循环卷积的 DFT 是它们各自 DFT 的逐点乘积。只有当信号被零填充到足够长的长度，以防止时域混叠（也称为环绕误差）时，才能通过此方法正确计算线性卷积。本练习旨在演示和量化这种效应。\n\n流程结构如下：\n\n首先，我们定义输入信号。主信号是一个有限长度的斜坡序列 $x[n] = n + 1$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$ 且 $N=10$，其他情况下 $x[n]=0$。第二个信号是一个有限长度的平均核 $h[n] = \\frac{1}{M}$，其中 $n \\in \\{0, 1, \\dots, M-1\\}$ 且 $M=4$，其他情况下 $h[n]=0$。\n\n其次，我们计算真实的线性卷积，记为 $y_{\\mathrm{lin}}[n]$，它将作为我们的基准真相 (ground truth)。它由卷积和定义：\n$$\ny_{\\mathrm{lin}}[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k]\n$$\n对于长度为 $N$ 的信号和长度为 $M$ 的核，结果序列 $y_{\\mathrm{lin}}[n]$ 的长度为 $N+M-1$。在本例中，长度为 $10+4-1=13$。这个计算是直接在时域中执行的。\n\n第三，对于集合 $\\{10, 12, 13, 16, 64\\}$ 中的每个指定变换长度 $L$，我们计算长度为 $L$ 的循环卷积 $y_{\\mathrm{circ},L}[n]$。这通过利用卷积定理来完成。步骤如下：\n1.  通过将原始信号 $x[n]$ 和 $h[n]$ 零填充到长度 $L$，创建长度为 $L$ 的版本 $x_L[n]$ 和 $h_L[n]$。\n2.  使用 FFT 算法高效地计算填充后信号的长度为 $L$ 的 DFT，$X_L[m] = \\text{DFT}\\{x_L[n]\\}$ 和 $H_L[m] = \\text{DFT}\\{h_L[n]\\}$。DFT 定义为 $A_L[m] = \\sum_{n=0}^{L-1} a[n]\\,e^{-2\\pi i \\frac{mn}{L}}$。\n3.  在频域中执行逐点相乘：$Y_{\\mathrm{circ},L}[m] = X_L[m] \\cdot H_L[m]$。\n4.  计算乘积的逆 DFT，$y_{\\mathrm{circ},L}[n] = \\text{IDFT}\\{Y_{\\mathrm{circ},L}[m]\\}$，以在时域中获得循环卷积结果。逆 DFT 定义为 $a[n] = \\frac{1}{L}\\sum_{m=0}^{L-1} A_L[m]\\,e^{2\\pi i \\frac{mn}{L}}$。\n\n第四，我们量化循环卷积和线性卷积之间的差异。通过对基准真相 $y_{\\mathrm{lin}}[n]$ 进行截断或零填充以匹配长度 $L$，创建一个比较信号 $y_{\\mathrm{lin},L}[n]$。然后，给定长度 $L$ 的误差定义为所有采样点上两个结果之间的最大绝对差：\n$$\nE(L) = \\max_{0\\le n \\le L-1} \\left| y_{\\mathrm{circ},L}[n] - y_{\\mathrm{lin},L}[n] \\right|\n$$\n一个不可忽略的 $E(L)$ 值表明存在环绕失真。\n\n此分析的理论基础是，当且仅当 $L \\ge N+M-1$ 时，以长度 $L$ 计算的循环卷积等价于线性卷积。\n- 如果 $L  N+M-1$，线性卷积结果的尾部（其延伸到索引 $N+M-2$）会“环绕”并加到循环卷积结果的初始样本上，从而导致混叠。因此，对于 $L=10$ 和 $L=12$，我们预计 $E(L)$ 会显著大于零。\n- 如果 $L \\ge N+M-1$，则有足够的填充来容纳整个线性卷积结果，而不会发生环绕。在这种情况下，$y_{\\mathrm{circ},L}[n]$ 将与 $y_{\\mathrm{lin},L}[n]$ 完全相同。因此，对于 $L=13$、$L=16$ 和 $L=64$，我们预计误差 $E(L)$ 将在机器浮点精度的数量级上。\n\n选择这些测试用例是为了说明关键的填充策略：$L=10$（填充不足）、$L=13$（最小充分填充）以及 $L=16$（2的幂次填充，通常为了 FFT 效率而选择）。$L=64$ 的情况进一步确认了超大填充下的稳定性。该实现为每种情况都计算了 $E(L)$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes convolution error E(L) to demonstrate the effect of zero-padding.\n    \"\"\"\n    # Define signal and kernel parameters as per the problem statement.\n    N = 10\n    M = 4\n\n    # Define the discrete-time signal x[n] = n + 1.\n    x = np.arange(1, N + 1, dtype=float)\n\n    # Define the averaging kernel h[n] = 1/M.\n    h = np.ones(M, dtype=float) / M\n\n    # Compute the ground-truth linear convolution y_lin[n].\n    # The length of the result is N + M - 1 = 13.\n    L_lin = N + M - 1\n    y_lin = np.convolve(x, h)\n\n    # Define the test suite of padding lengths L.\n    test_Ls = [10, 12, 13, 16, 64]\n    \n    results = []\n\n    # Iterate through each padding length L to compute the error E(L).\n    for L in test_Ls:\n        # Step 1: Create the comparison linear convolution y_lin_L[n] of length L.\n        # This is done by truncating or padding y_lin to length L.\n        y_lin_L = np.zeros(L)\n        len_to_copy = min(L, L_lin)\n        y_lin_L[:len_to_copy] = y_lin[:len_to_copy]\n\n        # Step 2: Create zero-padded versions of x and h to length L.\n        x_L = np.zeros(L)\n        x_L[:N] = x\n        \n        h_L = np.zeros(L)\n        h_L[:M] = h\n\n        # Step 3: Compute circular convolution via FFT.\n        # This uses the convolution theorem: IDFT{DFT{x} * DFT{h}}.\n        X_L = np.fft.fft(x_L)\n        H_L = np.fft.fft(h_L)\n        Y_circ_L = X_L * H_L\n        y_circ_L = np.fft.ifft(Y_circ_L)\n\n        # Step 4: Calculate the error E(L) as the maximum absolute difference.\n        # np.abs handles the case where y_circ_L has a tiny imaginary part\n        # due to numerical precision.\n        error = np.max(np.abs(y_circ_L - y_lin_L))\n        results.append(error)\n\n    # Print the results in the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}