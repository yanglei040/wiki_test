{
    "hands_on_practices": [
        {
            "introduction": "在我们深入探讨快速傅里叶变换 (FFT) 的复杂应用之前，首先必须理解它为何如此重要。这项练习将通过直接比较离散傅里叶变换 (DFT) 和 Cooley-Tukey FFT 算法的计算成本，让你直观地感受FFT在效率上的巨大优势。通过这个基础计算 ，你将深刻体会到从 $O(N^2)$ 到 $O(N \\log N)$ 的复杂度降低在实际工程中意味着什么。",
            "id": "3282537",
            "problem": "一位软件工程师需要决定，对于一个大小为 $N=1024$ 的数据集，是直接实现离散傅里叶变换 (DFT)，还是通过基2 Cooley–Tukey 快速傅里叶变换 (FFT) 来实现。该工程师仅通过浮点乘法的次数来衡量成本，具体定义如下：\n- 一次复数乘法以朴素的方式实现，计为 $4$ 次实数乘法。\n- 旋转因子的预计算时间被忽略。\n- 不对特殊旋转因子值（如 $1$, $-1$, $\\mathrm{i}$, $-\\mathrm{i}$）进行代数简化；每次出现旋转因子都按一次常规复数乘法计算。\n\n仅使用 DFT 的定义和作为 Cooley–Tukey FFT 基础的基2抽取原理，确定对于 $N=1024$，直接 DFT 计算所有 $N$ 个输出与基2 Cooley–Tukey FFT 计算所有 $N$ 个输出，两者在实数浮点乘法总次数上的确切差值。请以整数形式提供最终答案，无需四舍五入。",
            "solution": "将通过首先提取给定信息，然后评估其科学和逻辑完整性来验证该问题。\n\n### 步骤 1：提取已知条件\n- 数据集大小为 $N=1024$。\n- 成本度量是实数浮点乘法总次数。\n- 一次复数乘法定义为消耗 $4$ 次实数乘法。\n- 预计算旋转因子的时间被忽略。\n- 不考虑对特殊旋转因子值（例如 $1$, $-1$, $\\mathrm{i}$, $-\\mathrm{i}$）的代数简化。每次旋转因子乘法都计为一次常规的复数乘法。\n- 目标是找出直接离散傅里叶变换 (DFT) 计算与基2 Cooley–Tukey 快速傅里叶变换 (FFT) 计算之间实数乘法总次数的差值。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 这个问题是计算复杂度分析中的一个标准练习，旨在比较 DFT 和 FFT 算法的性能。这是数值方法和信号处理中的一个基本课题。所提供的假设，如复数乘法的朴素成本和忽略特殊情况的优化，虽然是简化的，但表述清晰，并且对于理论分析而言在科学上是一致的。\n- **良构性：** 这个问题是良构的。输入大小 $N=1024$ 是 $2$ 的幂（$N=2^{10}$），这是标准基2 Cooley–Tukey 算法的一个要求。成本函数有明确定义。预期会有一个唯一的整数值解，并且可以从所提供的信息中确定。\n- **客观性：** 问题陈述是客观的，并使用了精确、无歧义的语言。\n- **完整性与一致性：** 这个问题是自洽的，提供了所有必要的数据和定义。没有矛盾之处。\n\n### 步骤 3：结论与行动\n问题有效。现在将推导完整的解答过程。\n\n### 解题推导\n\n目标是计算对于长度为 $N=1024$ 的信号，直接 DFT 和基2 FFT 在实数浮点乘法次数上的差值。\n\n**1. 直接 DFT 的成本**\n\n长度为 $N$ 的序列 $x_n$ 的离散傅里叶变换 (DFT) 由一组 $N$ 个复数 $X_k$ 定义：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n e^{-i \\frac{2\\pi kn}{N}} \\quad \\text{for } k = 0, 1, \\dots, N-1\n$$\n让我们分析计算单个输出系数 $X_k$ 的计算成本。计算涉及 $N$ 个项的和。和中的每一项都形如 $x_n \\cdot e^{-i \\frac{2\\pi kn}{N}}$。这是两个复数的乘积（输入样本 $x_n$，在一般情况下为复数，以及旋转因子 $e^{-i \\frac{2\\pi kn}{N}}$）。根据问题陈述，我们必须将每个这样的运算计为一次常规的复数乘法。\n\n因此，对于 $N$ 个输出系数 $X_k$ 中的每一个，我们都必须执行 $N$ 次复数乘法。因此，直接 DFT 的复数乘法总次数为：\n$$\n\\text{Cost}_{\\text{complex, DFT}} = N \\times N = N^2\n$$\n问题规定一次复数乘法消耗 $4$ 次实数乘法。因此，直接 DFT 的实数乘法总次数为：\n$$\n\\text{Cost}_{\\text{real, DFT}} = 4 \\times N^2\n$$\n\n**2. 基2 Cooley–Tukey FFT 的成本**\n\n基2 Cooley–Tukey 算法是一种计算 DFT 的递归方法。它的工作原理是将一个大小为 $N$ 的 DFT分解为两个大小为 $N/2$ 的 DFT。令 $C_{\\text{complex}}(N)$ 为大小为 $N$ 的 FFT 所需的复数乘法次数。其递推关系为：\n$$\nC_{\\text{complex}}(N) = 2 \\cdot C_{\\text{complex}}(N/2) + (\\text{组合步骤中的乘法次数})\n$$\n组合步骤，或称“蝶形”运算阶段，从两个子问题的输出计算最终输出。对于 $k = 0, 1, \\dots, N/2 - 1$，计算如下：\n$$\nX_k = E_k + e^{-i \\frac{2\\pi k}{N}} O_k\n$$\n$$\nX_{k+N/2} = E_k - e^{-i \\frac{2\\pi k}{N}} O_k\n$$\n其中 $E_k$ 和 $O_k$ 分别是输入信号偶数索引部分和奇数索引部分的 DFT。\n\n乘法发生在 $e^{-i \\frac{2\\pi k}{N}} O_k$ 这一项。对于从 $0$ 到 $N/2 - 1$ 的每个 $k$ 值，都必须执行此乘法。这总计为 $N/2$ 次复数乘法。问题明确指出不对特殊值进行简化，因此即使对于 $k=0$（此时旋转因子为 $1$），我们也必须将其计为一次完整的复数乘法。\n\n因此，递推关系变为：\n$$\nC_{\\text{complex}}(N) = 2 C_{\\text{complex}}(N/2) + \\frac{N}{2}\n$$\n递归的基例是大小为 $N=1$ 的 DFT，它只是一个恒等变换（$X_0 = x_0$），需要 $0$ 次乘法。所以，$C_{\\text{complex}}(1) = 0$。\n\n由于 $N$ 是 $2$ 的幂，设 $N = 2^m$。递归共有 $m = \\log_2(N)$ 个阶段。在每个阶段，所有蝶形运算总共执行 $N/2$ 次复数乘法。因此，FFT 的复数乘法总次数为：\n$$\nC_{\\text{complex, FFT}}(N) = (\\log_2 N) \\times \\frac{N}{2} = \\frac{N}{2} \\log_2(N)\n$$\n实数乘法总次数是该值的 $4$ 倍：\n$$\n\\text{Cost}_{\\text{real, FFT}} = 4 \\times \\left(\\frac{N}{2} \\log_2(N)\\right) = 2N \\log_2(N)\n$$\n\n**3. 计算差值**\n\n我们需要求直接 DFT 和 FFT 在实数乘法次数上的差值。设此差值为 $\\Delta M$。\n$$\n\\Delta M = \\text{Cost}_{\\text{real, DFT}} - \\text{Cost}_{\\text{real, FFT}}\n$$\n$$\n\\Delta M = 4N^2 - 2N \\log_2(N)\n$$\n代入给定值 $N = 1024$。我们首先注意到 $1024 = 2^{10}$，所以 $\\log_2(1024) = 10$。\n$$\n\\Delta M = 4(1024)^2 - 2(1024)(10)\n$$\n$$\n\\Delta M = 4(1048576) - 20(1024)\n$$\n$$\n\\Delta M = 4194304 - 20480\n$$\n$$\n\\Delta M = 4173824\n$$\n或者，我们可以在计算前对表达式进行因式分解：\n$$\n\\Delta M = 2N(2N - \\log_2(N))\n$$\n$$\n\\Delta M = 2(1024)(2(1024) - 10)\n$$\n$$\n\\Delta M = 2048(2048 - 10)\n$$\n$$\n\\Delta M = 2048 \\times 2038\n$$\n$$\n\\Delta M = (2040+8)(2040-2) = 2040^2 - 4080 + 16320 - 16 = 4161600 + 12240 - 16 = 4173840 - 16 = 4173824\n$$\n实数浮点乘法总次数的差值为 $4,173,824$。",
            "answer": "$$\n\\boxed{4173824}\n$$"
        },
        {
            "introduction": "能够快速计算频谱后，下一个挑战是如何正确地解读它。这项动手编程练习  探讨了补零 (zero-padding) 技术，这是一个在信号处理中常用但容易引起误解的方法。通过本练习，你将亲手验证补零如何提高频谱的“表观”分辨率（即更密集的频率采样），但并不能提高区分两个相近频率的“真实”能力，从而加深对频谱泄漏和分辨率限制的理解。",
            "id": "3127394",
            "problem": "您需要编写一个完整、可运行的程序，使用快速傅里叶变换 (FFT) 算法，通过实验证明补零对离散傅里叶变换 (DFT) 插值的影响，表明对有限序列 $x_n$ 进行补零会提高表观频率分辨率（即更密集的频率采样），但不会提高真实分辨能力（即分辨两个紧密间隔正弦波的能力）。从有限序列 $x_n$, $n \\in \\{0,1,\\dots,N-1\\}$ 的离散傅里叶变换 (DFT) 的基本定义开始：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / N},\n$$\n并使用快速傅里叶变换 (FFT) 算法来实现其计算。使用因将 $x_n$ 截断至 $n \\in \\{0,\\dots,N-1\\}$ 而隐式产生的长度为 $N$ 的矩形窗。对于补零，定义一个扩展长度 $M > N$ 并考虑以下 DFT：\n$$\nX^{(M)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / M},\n$$\n该 DFT 在更精细的 $k$ 值网格上对相同的底层频谱进行采样。\n\n您的程序必须构建形式为 $x_n = \\sin(2\\pi f_0 n)$ 或 $x_n = \\sin(2\\pi f_1 n) + \\sin(2\\pi f_2 n)$ 的离散时间信号，其中角度以弧度为单位，$f_0, f_1, f_2$ 是以“周/采样点”为单位的离散时间频率，并满足 $0  f  1/2$。采样率为 $f_s = 1$ 采样点/单位时间，因此频率单位为“周/采样点”。对于单音情况，通过在正半频谱上选择幅度最大的 DFT 样本的索引 $k$ 来估计频率，并将其映射为 $\\hat f = k/M$（对于补零长度 $M$）或 $\\hat f = k/N$（对于未补零长度 $N$）。以浮点数形式报告绝对估计误差 $|\\hat f - f_0|$，单位为“周/采样点”。对于双音情况，通过计算正频率幅值谱上的显著局部最大值数量来判断两个峰值是否被分辨：如果谱线 $k$ 处的峰值严格大于其紧邻的邻居，并且其幅度至少是该频谱上最大幅度的一半，则该峰值是显著的。对于未补零和补零的情况，将分辨率报告为布尔值。角度必须以弧度为单位，所有报告的频率和误差单位必须为“周/采样点”。\n\n实现以下具有指定参数的测试套件：\n\n- 案例 1（不在DFT谱线上的单音）：\n  - $N = 128$, $M = 2048$, $f_0 = 0.163$，相位 $0$ 弧度。\n  - 输出：两个浮点数，分别为未补零情况下的绝对误差和补零情况下的绝对误差。\n\n- 案例 2（两个等幅音，其间距小于序列长度所致的分辨率）：\n  - $N = 128$, $M = 4096$, $f_1 = 0.200$, $f_2 = 0.200 + \\frac{0.6}{128}$，两个幅度都等于 $1$。\n  - 输出：两个布尔值，分别为在未补零情况下两个峰值是否被分辨和在补零情况下两个峰值是否被分辨。\n\n- 案例 3（两个等幅音，其间距大于序列长度所致的分辨率）：\n  - $N = 128$, $M = 4096$, $f_1 = 0.200$, $f_2 = 0.200 + \\frac{1.2}{128}$，两个幅度都等于 $1$。\n  - 输出：两个布尔值，分别为在未补零情况下两个峰值是否被分辨和在补零情况下两个峰值是否被分辨。\n\n- 案例 4（恰好在DFT谱线上的单音）：\n  - $N = 128$, $M = 2048$, $f_0 = \\frac{17}{128}$，相位 $0$ 弧度。\n  - 输出：两个浮点数，分别为未补零情况下的绝对误差和补零情况下的绝对误差。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。该列表必须是以上案例输出的按序拼接：\n$$\n[\\text{err1\\_unpadded},\\text{err1\\_padded},\\text{res2\\_unpadded},\\text{res2\\_padded},\\text{res3\\_unpadded},\\text{res3\\_padded},\\text{err4\\_unpadded},\\text{err4\\_padded}].\n$$\n所有浮点数单位均为“周/采样点”，布尔值以编程语言的常规布尔字面量表示。",
            "solution": "该问题是有效的，因为它科学上基于数字信号处理的原理，提法明确且提供了所有必要的参数和定义，其表述是客观的。它提出了一个标准的、非平凡的计算练习，旨在快速傅里叶变换 (FFT) 的背景下，演示频率分辨率和通过补零实现的频谱插值等概念。\n\n### 基于原理的解决方案\n\n该问题的核心在于理解离散傅里叶变换 (DFT) 的属性，以及这些属性如何受到信号有限长度和补零技术的影响。\n\n**1. 离散傅里叶变换 (DFT)**\n\n对于一个长度为 $N$ 的有限长度离散时间信号 $x_n$（定义于 $n \\in \\{0, 1, ..., N-1\\}$），其 DFT, $X_k$, 由下式给出：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / N}\n$$\n其中 $k \\in \\{0, 1, ..., N-1\\}$，$j$ 是虚数单位。DFT 提供了信号的频域表示，在 $N$ 个离散频率点 $f_k = k/N$ 上对其频谱进行采样（采样率为 $f_s=1$ 周/采样点）。该计算可通过快速傅里叶变换 (FFT) 算法高效执行，其计算复杂度为 $O(N \\log N)$，而直接计算 DFT 的复杂度为 $O(N^2)$。\n\n**2. 加窗与频谱泄漏**\n\n在有限时长 $N$ 内观察信号，等同于将一个无限长信号乘以一个长度为 $N$ 的矩形窗。在频域中，这种乘法对应于信号的真实频谱与矩形窗的傅里叶变换进行卷积。矩形窗的变换是一个 sinc 函数（$\\text{sinc}(f) = \\sin(\\pi f) / (\\pi f)$）。这种卷积导致单个正弦频率的能量“泄漏”到相邻的频率仓中，这种现象被称为频谱泄漏。\n\n如果信号的频率 $f_0$ 恰好与 DFT 谱线频率重合（即，对于某个整数 $k_0$，有 $f_0 = k_0/N$），其所有能量都集中在该单个谱线（及其负频率对应谱线）中，没有泄漏。然而，如果 $f_0$ 落在两个 DFT 谱线之间，频谱中产生的 sinc 函数的峰值也将位于谱线之间，其能量会扩散到所有频率仓中。$N$ 点 DFT 以 $1/N$ 的粗略间隔对这个 sinc 形频谱进行采样，这意味着测得的峰值幅度可能远低于真实峰值，其表观位置将位于最近的谱线上，从而引入估计误差。\n\n**3. 补零与频谱插值**\n\n补零是在进行 DFT 之前，在信号序列末尾追加零的过程。如果我们将 $M-N$ 个零追加到我们的 $N$ 点序列 $x_n$ 之后，创建一个长度为 $M > N$ 的新序列 $x'_n$，其 DFT 为：\n$$\nX^{(M)}_k = \\sum_{n=0}^{M-1} x'_n \\, e^{-j 2\\pi k n / M} = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / M}\n$$\n此操作并未给信号增加新信息。相反，它在更精细的频率网格 $f_k = k/M$ 上计算 DFT。底层的连续频谱（DTFT，离散时间傅里叶变换）保持不变，但我们是在 $M$ 个点而不是 $N$ 个点上对其进行采样。这个过程是频谱插值的一种形式。它通过揭示由加窗引起的底层 sinc 形谱瓣的更多细节，提供了一个“更好看”的频谱。\n\n**4. 频率分辨率**\n\n频率分辨率是区分两个紧密间隔的频率分量的能力。它从根本上由窗函数变换的主瓣宽度决定。对于长度为 $N$ 的矩形窗，主瓣宽度约为 $2/N$。Rayleigh 判据表明，如果两个等幅正弦波的频率间隔至少为 $\\Delta f \\approx 1/N$，则它们是可分辨的。\n\n补零增加了 DFT 谱线的数量，从而通过更密集地采样频谱来提供更高的“表观”分辨率。然而，它并不会使频谱分量的主瓣变窄。如果两个频率如此接近以至于它们的主瓣合并成一个单一的峰值，补零只会对那个单一的、合并的峰值进行插值。它不会提高“真实”的分辨能力，该能力仍然受限于原始信号时长 $N$。\n\n### 测试案例分析\n\n**案例 1：不在DFT谱线上的单音**\n- $f_0 = 0.163$。对于 $N=128$，最近的谱线是 $k = \\text{round}(0.163 \\times 128) = \\text{round}(20.864) = 21$。未补零时估计的频率将是 $21/128 = 0.1640625$。\n- 补零到 $M=2048$ 允许对中心在真实频率 $f_0 = 0.163$ 的 sinc 频谱峰值进行更精细的采样。最近的谱线将是 $k = \\text{round}(0.163 \\times 2048) = \\text{round}(333.824) = 334$。新的估计是 $334/2048 \\approx 0.1630859$。补零后误差将显著减小。\n\n**案例 2：两个间距小于分辨率极限的音调**\n- 频率间隔为 $\\Delta f = 0.6/128$，小于 Rayleigh 判据的 $\\approx 1/128$。\n- 两个频谱分量的主瓣将大量重叠，在频谱中形成一个更宽的单峰。\n- 无论是未补零的 $N=128$ DFT 还是补零的 $M=4096$ DFT 都无法将它们分辨为两个不同的峰值。我们预计两种情况下的分辨率测试都将返回 `False`。\n\n**案例 3：两个间距大于分辨率极限的音调**\n- 频率间隔为 $\\Delta f = 1.2/128$，大于 Rayleigh 判据。两个主瓣应该有足够的分离度以被区分。\n- 在未补零的 $N=128$ 情况下，如果采样点的位置不利，DFT 的粗略采样可能仍然无法揭示两个不同的局部最大值。\n- 在补零的 $M=4096$ 情况下，频谱的精细采样几乎肯定会揭示出两个不同的峰值。我们预计未补零情况下为 `False`（或可能为 `True`），补零情况下为 `True`，这清楚地展示了补零在峰值可视化方面的效用。\n\n**案例 4：恰好在DFT谱线上的单音**\n- $f_0 = 17/128$。这个频率对于 $N=128$ 点的 DFT 来说恰好是一个谱线中心（在 $k=17$ 处）。\n- 它对于 $M=2048$ 点的 DFT 来说也是一个精确的谱线中心，因为 $f_0 = 17/128 = (17 \\times 16) / (128 \\times 16) = 272/2048$（在 $k=272$ 处）。\n- 在这两种情况下，都没有频谱泄漏。峰值将在完全正确的谱线上找到，导致未补零和补零变换的估计误差均为 $0.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and demonstrate the effects of zero-padding.\n    \"\"\"\n\n    def estimate_single_tone_error(N, M, f0):\n        \"\"\"\n        Calculates frequency estimation error for a single-tone signal.\n        \"\"\"\n        # Generate N-point signal\n        n = np.arange(N)\n        x_n = np.sin(2 * np.pi * f0 * n)\n\n        # --- Unpadded case ---\n        # Compute N-point FFT\n        X_k_unpadded = np.fft.fft(x_n)\n        # Get magnitudes for positive frequencies (k=1 to N/2)\n        # We search from k=1 because f0\n        mags_unpadded = np.abs(X_k_unpadded[1:N//2 + 1])\n        # Find index of max magnitude (add 1 to map back to original k index)\n        k_max_unpadded = np.argmax(mags_unpadded) + 1\n        f_hat_unpadded = k_max_unpadded / N\n        err_unpadded = abs(f_hat_unpadded - f0)\n\n        # --- Padded case ---\n        # Create zero-padded signal\n        x_n_padded = np.zeros(M)\n        x_n_padded[:N] = x_n\n        # Compute M-point FFT\n        X_k_padded = np.fft.fft(x_n_padded)\n        # Get magnitudes for positive frequencies (k=1 to M/2)\n        mags_padded = np.abs(X_k_padded[1:M//2 + 1])\n        # Find index of max magnitude\n        k_max_padded = np.argmax(mags_padded) + 1\n        f_hat_padded = k_max_padded / M\n        err_padded = abs(f_hat_padded - f0)\n        \n        return err_unpadded, err_padded\n\n    def check_two_tone_resolution(N, M, f1, f2):\n        \"\"\"\n        Determines if two tones are resolved for unpadded and padded FFTs.\n        \"\"\"\n        # Generate N-point signal\n        n = np.arange(N)\n        x_n = np.sin(2 * np.pi * f1 * n) + np.sin(2 * np.pi * f2 * n)\n\n        def count_significant_peaks(spectrum, L):\n            \"\"\"\n            Counts peaks based on the problem's definition.\n            A peak at bin k is significant if it is strictly greater than its\n            immediate neighbors and its magnitude is at least one-half of the\n            largest magnitude on the positive-frequency spectrum.\n            \"\"\"\n            # We only analyze the positive frequency half of the spectrum\n            mags = np.abs(spectrum[1:L//2 + 1])\n            max_mag = np.max(mags)\n            \n            # If max_mag is zero or very small, no peaks\n            if max_mag  1e-9:\n                return 0\n            \n            peak_count = 0\n            # Iterate from k=2 to L/2-1 to have neighbors k-1 and k+1\n            # The search range is wide enough for the problem's frequencies\n            for k_idx in range(1, len(mags) - 1):\n                # k_idx is index in mags array, k is actual DFT bin index\n                if mags[k_idx]  mags[k_idx - 1] and \\\n                   mags[k_idx]  mags[k_idx + 1] and \\\n                   mags[k_idx] = 0.5 * max_mag:\n                    peak_count += 1\n            return peak_count\n\n        # --- Unpadded case ---\n        X_k_unpadded = np.fft.fft(x_n, N)\n        peaks_unpadded = count_significant_peaks(X_k_unpadded, N)\n        res_unpadded = (peaks_unpadded = 2)\n\n        # --- Padded case ---\n        X_k_padded = np.fft.fft(x_n, M)\n        peaks_padded = count_significant_peaks(X_k_padded, M)\n        res_padded = (peaks_padded = 2)\n\n        return res_unpadded, res_padded\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {'type': 'single', 'N': 128, 'M': 2048, 'f0': 0.163},\n        {'type': 'two', 'N': 128, 'M': 4096, 'f1': 0.200, 'f2': 0.200 + 0.6 / 128},\n        {'type': 'two', 'N': 128, 'M': 4096, 'f1': 0.200, 'f2': 0.200 + 1.2 / 128},\n        {'type': 'single', 'N': 128, 'M': 2048, 'f0': 17.0 / 128},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'single':\n            err_unpadded, err_padded = estimate_single_tone_error(case['N'], case['M'], case['f0'])\n            results.extend([err_unpadded, err_padded])\n        elif case['type'] == 'two':\n            res_unpadded, res_padded = check_two_tone_resolution(case['N'], case['M'], case['f1'], case['f2'])\n            results.extend([res_unpadded, res_padded])\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了频谱分析，FFT 的另一个强大应用是加速卷积运算，这在数字滤波等领域至关重要。然而，基于FFT的卷积利用了DFT的循环周期性，这可能导致不期望的“环绕”失真。这项实践  将指导你通过编码实验，比较线性卷积和循环卷积的结果，并展示如何通过恰当的补零策略来利用FFT正确地实现线性卷积，这是信号处理工程师必须掌握的关键技能。",
            "id": "3282547",
            "problem": "要求您研究快速傅里叶变换（FFT）算法中固有的周期性假设如何影响卷积，以及补零如何减轻环绕失真。请完全在离散时间内进行操作。您的程序必须从核心定义开始，实现以下内容。\n\n设一个有限长度的非周期离散时间信号定义为 $x[n] = n + 1$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，且 $N = 10$；在其他情况下 $x[n] = 0$。设一个有限长度的非周期平均核定义为 $h[n] = \\frac{1}{M}$，其中 $n \\in \\{0,1,\\dots,M-1\\}$，且 $M = 4$；在其他情况下 $h[n] = 0$。定义线性卷积 $y_{\\mathrm{lin}}[n]$ 为\n$$\ny_{\\mathrm{lin}}[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k],\n$$\n其中，$x[n]$ 和 $h[n]$ 在其指定的支撑域之外均被视为零。此和是有限的，且 $y_{\\mathrm{lin}}[n]$ 的长度为 $N+M-1 = 13$。\n\n对于支撑域为 $\\{0,1,\\dots,L-1\\}$ 的序列 $a[n]$，定义其长度为 $L$ 的离散傅里叶变换（DFT）为\n$$\nA_L[m] = \\sum_{n=0}^{L-1} a[n]\\,e^{-2\\pi i \\frac{mn}{L}},\\quad m=0,1,\\dots,L-1,\n$$\n及其逆变换为\n$$\na[n] = \\frac{1}{L}\\sum_{m=0}^{L-1} A_L[m]\\,e^{2\\pi i \\frac{mn}{L}}.\n$$\n对于给定的长度 $L$，通过以下方式构成补零版本 $x_L[n]$ 和 $h_L[n]$\n$$\nx_L[n] = \\begin{cases}\nx[n], 0\\le n\\le N-1\\\\\n0, \\text{otherwise}\n\\end{cases},\\quad\nh_L[n] = \\begin{cases}\nh[n], 0\\le n\\le M-1\\\\\n0, \\text{otherwise}\n\\end{cases},\n$$\n对于 $n\\in\\{0,1,\\dots,L-1\\}$。使用快速傅里叶变换（FFT），通过在DFT域中进行逐点相乘来计算长度为 $L$ 的循环卷积\n$$\ny_{\\mathrm{circ},L}[n] = \\sum_{k=0}^{L-1} x_L[k]\\,h_L[(n-k)\\bmod L],\\quad n=0,1,\\dots,L-1,\n$$\n一个经过充分检验的事实是，DFT的乘积对应于时域中的循环卷积。\n\n为量化环绕失真，对每个 $L$ 定义误差\n$$\nE(L) = \\max_{0\\le n \\le L-1} \\left| y_{\\mathrm{circ},L}[n] - y_{\\mathrm{lin},L}[n] \\right|,\n$$\n其中，$y_{\\mathrm{lin},L}[n]$ 是线性卷积 $y_{\\mathrm{lin}}[n]$ 的一个版本：如果 $L \\le N+M-1$，则截断为前 $L$ 个样本；如果 $L \\ge N+M-1$，则在末尾补上 $L-(N+M-1)$ 个零。这个共同的比较长度确保了在 $L$ 个样本上的逐点误差计算。如果 $E(L)$ 显著大于数值舍入误差，则表明存在环绕失真。\n\n您的任务是：\n- 实现上述定义，并针对一组测试补零长度 $L \\in \\{10,12,13,16,64\\}$ 计算 $E(L)$。\n- 解读结果以评估三种补零策略 $L$：不补零 $L=N$、最小补零 $L=N+M-1$ 和2的幂次补零 $L=\\min\\{2^p: 2^p\\ge N+M-1\\}$，并使用一个额外的过度补零 $L=64$ 来探究数值稳定性。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、按测试组顺序排列的浮点误差逗号分隔列表，例如 $[e_{10},e_{12},e_{13},e_{16},e_{64}]$，其中每个 $e_L$ 是为该 $L$ 计算出的 $E(L)$。不允许有任何其他输出。\n\n请确保您的实现是自包含的，不使用用户输入，并遵循上述定义。根据定义，复指数中的角度以弧度为单位。不涉及物理单位。目标受众是学习数值方法和科学计算的高年级本科生。",
            "solution": "该问题要求研究如何使用快速傅里叶变换（FFT）计算两个离散时间信号的线性卷积。所要考察的核心原理是离散傅里叶变换（DFT）的卷积定理，该定理指出，两个序列循环卷积的DFT是它们各自DFT的逐点乘积。只有当信号被补零到足够长度以防止时域混叠（也称为环绕误差）时，才能通过此方法正确计算线性卷积。本练习旨在演示并量化这种效应。\n\n该过程的结构如下：\n\n首先，我们定义输入信号。主信号是一个有限长度的斜坡序列 $x[n] = n + 1$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$，且 $N=10$；在其他情况下 $x[n]=0$。第二个信号是一个有限长度的平均核 $h[n] = \\frac{1}{M}$，其中 $n \\in \\{0, 1, \\dots, M-1\\}$，且 $M=4$；在其他情况下 $h[n]=0$。\n\n其次，我们计算真实的线性卷积，记为 $y_{\\mathrm{lin}}[n]$，它将作为我们的参考标准。它由卷积和定义：\n$$\ny_{\\mathrm{lin}}[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k]\n$$\n对于长度为 $N$ 的信号和长度为 $M$ 的核，得到的序列 $y_{\\mathrm{lin}}[n]$ 的长度为 $N+M-1$。在本例中，长度为 $10+4-1=13$。该计算在时域中直接执行。\n\n第三，对于集合 $\\{10, 12, 13, 16, 64\\}$ 中每个指定的变换长度 $L$，我们计算长度为 $L$ 的循环卷积 $y_{\\mathrm{circ},L}[n]$。这通过利用卷积定理来完成。步骤如下：\n1.  通过将原始信号 $x[n]$ 和 $h[n]$ 补零至长度 $L$，创建长度为 $L$ 的输入信号版本 $x_L[n]$ 和 $h_L[n]$。\n2.  使用FFT算法（为提高效率）计算补零后信号的长度为 $L$ 的DFT，$X_L[m] = \\text{DFT}\\{x_L[n]\\}$ 和 $H_L[m] = \\text{DFT}\\{h_L[n]\\}$。DFT定义为 $A_L[m] = \\sum_{n=0}^{L-1} a[n]\\,e^{-2\\pi i \\frac{mn}{L}}$。\n3.  在频域中执行逐点相乘：$Y_{\\mathrm{circ},L}[m] = X_L[m] \\cdot H_L[m]$。\n4.  计算乘积的DFT逆变换 $y_{\\mathrm{circ},L}[n] = \\text{IDFT}\\{Y_{\\mathrm{circ},L}[m]\\}$，以在时域中获得循环卷积的结果。DFT逆变换定义为 $a[n] = \\frac{1}{L}\\sum_{m=0}^{L-1} A_L[m]\\,e^{2\\pi i \\frac{mn}{L}}$。\n\n第四，我们量化循环卷积与线性卷积之间的差异。通过将参考标准 $y_{\\mathrm{lin}}[n]$ 截断或用零填充以匹配长度 $L$，创建一个用于比较的信号 $y_{\\mathrm{lin},L}[n]$。然后，给定长度 $L$ 的误差定义为两个结果在所有采样点上的最大绝对差：\n$$\nE(L) = \\max_{0\\le n \\le L-1} \\left| y_{\\mathrm{circ},L}[n] - y_{\\mathrm{lin},L}[n] \\right|\n$$\n$E(L)$ 的值不可忽略则表明存在环绕失真。\n\n此分析的理论基础是：当且仅当 $L \\ge N+M-1$ 时，以长度 $L$ 计算的循环卷积等效于线性卷积。\n- 如果 $L  N+M-1$，线性卷积结果的尾部（延伸至索引 $N+M-2$）会“环绕”并叠加到循环卷积结果的初始样本上，从而导致混叠。因此，对于 $L=10$ 和 $L=12$，我们预期 $E(L)$ 会显著大于零。\n- 如果 $L \\ge N+M-1$，则有足够的补零来容纳整个线性卷积结果而不会产生环繞。在这种情况下，$y_{\\mathrm{circ},L}[n]$ 将与 $y_{\\mathrm{lin},L}[n]$ 完全相同。因此，对于 $L=13$、$L=16$ 和 $L=64$，我们预期误差 $E(L)$ 将处于机器浮点精度的量级。\n\n选择这些测试用例是为了说明关键的补零策略：$L=10$（补零不足）、$L=13$（最小有效补零）和 $L=16$（2的幂次补零，通常为了FFT效率而选择）。$L=64$ 的情况则用以进一步验证过度补零时的稳定性。实现部分会计算每种情况下的 $E(L)$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes convolution error E(L) to demonstrate the effect of zero-padding.\n    \"\"\"\n    # Define signal and kernel parameters as per the problem statement.\n    N = 10\n    M = 4\n\n    # Define the discrete-time signal x[n] = n + 1.\n    x = np.arange(1, N + 1, dtype=float)\n\n    # Define the averaging kernel h[n] = 1/M.\n    h = np.ones(M, dtype=float) / M\n\n    # Compute the ground-truth linear convolution y_lin[n].\n    # The length of the result is N + M - 1 = 13.\n    L_lin = N + M - 1\n    y_lin = np.convolve(x, h)\n\n    # Define the test suite of padding lengths L.\n    test_Ls = [10, 12, 13, 16, 64]\n    \n    results = []\n\n    # Iterate through each padding length L to compute the error E(L).\n    for L in test_Ls:\n        # Step 1: Create the comparison linear convolution y_lin_L[n] of length L.\n        # This is done by truncating or padding y_lin to length L.\n        y_lin_L = np.zeros(L)\n        len_to_copy = min(L, L_lin)\n        y_lin_L[:len_to_copy] = y_lin[:len_to_copy]\n\n        # Step 2: Create zero-padded versions of x and h to length L.\n        x_L = np.zeros(L)\n        x_L[:N] = x\n        \n        h_L = np.zeros(L)\n        h_L[:M] = h\n\n        # Step 3: Compute circular convolution via FFT.\n        # This uses the convolution theorem: IDFT{DFT{x} * DFT{h}}.\n        X_L = np.fft.fft(x_L)\n        H_L = np.fft.fft(h_L)\n        Y_circ_L = X_L * H_L\n        y_circ_L = np.fft.ifft(Y_circ_L)\n\n        # Step 4: Calculate the error E(L) as the maximum absolute difference.\n        # np.abs handles the case where y_circ_L has a tiny imaginary part\n        # due to numerical precision.\n        error = np.max(np.abs(y_circ_L - y_lin_L))\n        results.append(error)\n\n    # Print the results in the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}