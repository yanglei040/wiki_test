{
    "hands_on_practices": [
        {
            "introduction": "为真正掌握离散傅里叶变换（DFT），我们首先分析它对最简单、最基本的信号——纯复指数信号的响应。这个练习  展示了离散傅里叶变换作为频率分析器的核心原理。通过计算其自身的一个基函数的变换，你将揭示其正交性，并亲眼见证离散傅里叶变换是如何分离出单个频率分量的。",
            "id": "1759639",
            "problem": "在数字信号处理中，离散傅里叶变换 (DFT) 是分析有限长度信号频率内容的基本工具。考虑一个采样后纯音信号的简化模型。该信号记为 $x[n]$，由单个复指数表示。\n\n该信号是一个长度为 $N$ 的序列，定义为：\n$$x[n] = \\exp\\left(j \\frac{2\\pi k_0 n}{N}\\right)$$\n其中时间索引 $n = 0, 1, \\ldots, N-1$。这里，$k_0$ 是一个整数常数，表示该音调的归一化频率，且满足 $0 \\le k_0  N$。\n\n你的任务是计算该信号的 $N$ 点 DFT。DFT 记为 $X[k]$，由以下分析方程定义：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right)$$\n其中 $k$ 是频率索引，取整数值 $k = 0, 1, \\ldots, N-1$。\n\n求出用 $N$、$k$ 和 $k_0$ 表示的 $X[k]$ 的单一闭式解析表达式。",
            "solution": "我们从 DFT 分析方程开始，并代入给定的信号。根据定义，\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right).\n$$\n当 $x[n] = \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)$ 时，方程变为\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)\\exp\\left(-j \\frac{2\\pi k n}{N}\\right) \n= \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi (k_{0}-k) n}{N}\\right).\n$$\n定义比率\n$$\nr \\triangleq \\exp\\left(j \\frac{2\\pi (k_{0}-k)}{N}\\right).\n$$\n则\n$$\nX[k] = \\sum_{n=0}^{N-1} r^{n}.\n$$\n这是一个有限几何级数。使用几何级数求和公式，\n$$\n\\sum_{n=0}^{N-1} r^{n} = \n\\begin{cases}\n\\frac{1 - r^{N}}{1 - r},  r \\neq 1, \\\\\nN,  r = 1,\n\\end{cases}\n$$\n并注意到\n$$\nr^{N} = \\exp\\left(j \\frac{2\\pi (k_{0}-k) N}{N}\\right) = \\exp\\left(j 2\\pi (k_{0}-k)\\right) = 1,\n$$\n我们得到：\n- 如果 $r \\neq 1$ （对于 $k,k_{0}\\in\\{0,\\ldots,N-1\\}$，等价于 $k \\neq k_{0}$），则 $1 - r^{N} = 0$ 而 $1 - r \\neq 0$，所以 $X[k] = 0$。\n- 如果 $r = 1$ （等价于 $k = k_{0}$），则级数的每一项都等于 $1$，所以 $X[k] = N$。\n\n综合这两种情况，得到闭式表达式\n$$\nX[k] = N\\,\\delta_{k,k_{0}},\n$$\n其中 $\\delta_{k,k_{0}}$ 是克罗内克 δ (Kronecker delta)，当 $k=k_{0}$ 时等于 $1$，否则等于 $0$。",
            "answer": "$$\\boxed{N\\,\\delta_{k,k_{0}}}$$"
        },
        {
            "introduction": "除了分析频率分量，离散傅里叶变换还保留了信号的基本属性，其中最著名的是能量。这个实践  让你探索帕塞瓦尔定理（Parseval's theorem），该定理指出信号的总能量在时域和频域之间是守恒的。通过结合数学推导和数值验证，你将证实这一重要性质，并体会它在确保离散傅里叶变换是物理上有意义的转换中的重要性。",
            "id": "3222975",
            "problem": "要求您设计并实现一个程序，以数值方式验证离散傅里叶变换 (DFT) 下离散时间序列域与离散频率域之间的能量守恒性质。请仅从以下基本基础出发：离散傅里叶变换 (DFT) 及其在非归一化正变换约定下的逆变换的定义，即\n- 正向 DFT：对于长度为 $N$ 的序列 $x[n]$，其变换 $X[k]$ 定义为 $X[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi kn/N}$，其中 $k \\in \\{0,1,\\dots,N-1\\}$。\n- 逆向 DFT：$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j 2\\pi kn/N}$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。\n\n您的任务是：\n1) 基于上述基础，推导在给定约定下，$x[n]$ 的时域平方 $\\ell_2$-范数与 $X[k]$ 的相应频域平方 $\\ell_2$-范数之间的关系。\n2) 设计一个数值实验来验证多个序列的这种关系。对于每个测试序列，计算时域能量 $E_{\\mathrm{time}} = \\sum_{n=0}^{N-1} |x[n]|^2$ 和频域能量 $E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]|^2$。对每个测试用例，计算无量纲的相对差异\n$$\nr \\;=\\; \\begin{cases}\n\\displaystyle \\frac{\\big| E_{\\mathrm{time}} - E_{\\mathrm{freq}} \\big|}{\\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}},  \\text{若 } \\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}  0,\\\\\n0,  \\text{若 } E_{\\mathrm{time}} = E_{\\mathrm{freq}} = 0,\n\\end{cases}\n$$\n\n测试套件。您的程序必须精确评估以下六个序列，每个序列的详细说明如下。在所有情况下，$n$ 和 $k$ 均为整数索引，角度以弧度为单位：\n- 情况 A（随机复数，正常路径）：长度 $N=128$。设 $x[n]$ 为复数值，其实部和虚部独立地从标准正态分布中抽取，为保证可复现性，使用固定的种子 $12345$。\n- 情况 B（单频点复指数）：长度 $N=64$。设 $x[n] = c \\, e^{j 2\\pi m n / N}$，其中 $m=7$ 且 $c = 1.2 \\, e^{j\\,0.4}$。\n- 情况 C（频谱泄漏实正弦波）：长度 $N=36$。设 $x[n] = A \\sin\\!\\big(2\\pi f n / N + \\varphi\\big)$，其中 $A=1.0$，$f=\\sqrt{2}$，$\\varphi=0.3$。\n- 情况 D（脉冲）：长度 $N=50$。设在索引 $n_0=17$ 处 $x[n] = A$，其他位置 $x[n]=0$，其中 $A=3.0$。\n- 情况 E（斜坡，中心化）：长度 $N=32$。设 $x[n] = n - \\frac{N-1}{2}$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。\n- 情况 F（全零，边界情况）：长度 $N=10$。设对所有 $n$，$x[n]=0$。\n\n实现要求：\n- 使用如上所述的非归一化正向 DFT 约定。\n- 使用从第一性原理出发的正确实现，或与所述约定一致的库函数来计算 $X[k]$。\n- 对于每种情况，按定义计算 $E_{\\mathrm{time}}$、$E_{\\mathrm{freq}}$ 和相对差异 $r$。\n- 数值精度：浮点运算会引入舍入误差；相对差异 $r$ 应接近于 $0$。除上述定义外，不得应用任何额外的缩放。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个相对差异值，以逗号分隔的列表形式并用方括号括起，顺序为 [情况 A, 情况 B, 情况 C, 情况 D, 情况 E, 情况 F]。例如：\"[rA,rB,rC,rD,rE,rF]\"。\n- 每个 $r$ 必须是浮点数。不涉及单位。",
            "solution": "该问题要求推导并随后数值验证离散傅里叶变换 (DFT) 的能量守恒性质，通常称为 Parseval 定理。要使用的特定 DFT 约定是非归一化正变换。\n\n分析分两个阶段进行：首先，从给定的 DFT 定义中，对预期的能量关系进行形式化的数学推导；其次，设计并实现一个数值实验，用一组测试信号来验证此关系，并使用相对误差度量来量化任何差异。\n\n**1. Parseval 定理的数学推导**\n\n对于长度为 $N$ 的有限离散时间序列 $x[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$，我们有以下定义：\n\n- 正向 DFT：$X[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi kn/N}$\n- 逆向 DFT：$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j 2\\pi kn/N}$\n\n目标是在时域能量（定义为序列 $x[n]$ 的平方 $\\ell_2$-范数），\n$$E_{\\mathrm{time}} = \\sum_{n=0}^{N-1} |x[n]|^2$$\n与频域能量（以特定缩放因子定义为）之间建立关系\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]|^2$$\n\n我们从频域能量 $E_{\\mathrm{freq}}$ 的表达式开始推导。\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] X^*[k]$$\n其中 $X^*[k]$ 表示 $X[k]$ 的复共轭。\n\n将正向 DFT 的定义代入 $X[k]$，将其共轭代入 $X^*[k]$。为清晰起见，我们在共轭项中使用一个不同的求和索引 $m$。\n$$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N}$$\n$$X^*[k] = \\left( \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi km/N} \\right)^* = \\sum_{m=0}^{N-1} x^*[m] e^{j 2\\pi km/N}$$\n\n将这些代入 $E_{\\mathrm{freq}}$ 的表达式，得到：\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N} \\right) \\left( \\sum_{m=0}^{N-1} x^*[m] e^{j 2\\pi km/N} \\right)$$\n\n由于是有限和，我们可以重新排列求和顺序：\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x[n] x^*[m] \\left( \\sum_{k=0}^{N-1} e^{-j 2\\pi kn/N} e^{j 2\\pi km/N} \\right)$$\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x[n] x^*[m] \\left( \\sum_{k=0}^{N-1} e^{j 2\\pi k(m-n)/N} \\right)$$\n\n最内层的和（关于索引 $k$）是一个复指数的几何级数。它具有一个基本的正交性：\n$$ \\sum_{k=0}^{N-1} e^{j 2\\pi k(m-n)/N} = \\begin{cases} N  \\text{若 } m = n \\\\ 0  \\text{若 } m \\neq n \\end{cases} $$\n这可以使用克罗内克 δ 符号 $\\delta_{m,n}$ 紧凑地写为 $N \\delta_{m,n}$。\n\n将此结果代回我们的 $E_{\\mathrm{freq}}$ 表达式：\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x[n] x^*[m] (N \\delta_{m,n})$$\n\n$N$ 因子被消去。克罗内克 δ $\\delta_{m,n}$ 使得关于 $m$ 的内层求和仅在 $m=n$ 时非零。这将双重求和简化为单个求和：\n$$E_{\\mathrm{freq}} = \\sum_{n=0}^{N-1} x[n] x^*[n]$$\n\n由于对任何复数 $z$ 都有 $z z^* = |z|^2$，我们得到最终结果：\n$$E_{\\mathrm{freq}} = \\sum_{n=0}^{N-1} |x[n]|^2$$\n\n这证明了，对于给定的 DFT 约定，所定义的时域能量和频域能量是相同的：\n$$E_{\\mathrm{time}} = E_{\\mathrm{freq}}$$\n\n**2. 数值验证设计**\n\n任务的第二部分是数值验证此恒等式。由于浮点运算的精度有限，直接进行相等性检查 $E_{\\mathrm{time}} == E_{\\mathrm{freq}}$ 是不明智的。相反，我们计算无量纲的相对差异 $r$，定义为：\n$$\nr \\;=\\; \\begin{cases}\n\\displaystyle \\frac{\\big| E_{\\mathrm{time}} - E_{\\mathrm{freq}} \\big|}{\\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}},  \\text{若 } \\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}  0,\\\\\n0,  \\text{若 } E_{\\mathrm{time}} = E_{\\mathrm{freq}} = 0,\n\\end{cases}\n$$\n理论上，$r$ 应精确为 $0$。在实践中，我们期望 $r$ 是一个与机器精度（machine epsilon）数量级相近的小数，反映了浮点舍入误差的累积。\n\n数值实现将使用 Python 及其 NumPy 库。函数 `numpy.fft.fft` 根据定义 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N}$ 计算正向 DFT，这与问题中指定的非归一化约定完全匹配。\n\n验证将在六个不同的测试用例上进行，每个用例都旨在探究 DFT 的不同方面：\n- **情况 A**：一个长度为 $N=128$ 的随机复数序列，代表一个通用的、非周期性信号。其实部和虚部从标准正态分布中抽取，并使用固定种子以保证可复现性。\n- **情况 B**：一个长度为 $N=64$ 的单频复指数，$x[n] = 1.2 e^{j0.4} \\, e^{j 2\\pi (7) n / 64}$。其 DFT 仅在单个频率点上非零，代表一个频谱纯净的信号。\n- **情况 C**：一个长度为 $N=36$ 的实值正弦波，其频率 $f=\\sqrt{2}$ 不是频率分辨率 $1/N$ 的整数倍。这测试了频谱泄漏的情况，此时能量分布在所有频率点上。\n- **情况 D**：一个长度为 $N=50$ 的离散脉冲，$x[n] = 3.0$ 在 $n=17$ 处，其他位置为 $0$。其变换在所有频率上具有恒定的幅度。\n- **情况 E**：一个长度为 $N=32$ 的实值线性斜坡序列，经过中心化以使其均值为零。\n- **情况 F**：一个长度为 $N=10$ 的全零序列的平凡情况，其时域和频域能量在解析上均为零。\n\n对于每种情况，程序将生成序列 $x[n]$，通过 `numpy.fft.fft` 计算 $X[k]$，然后计算 $E_{\\mathrm{time}}$、$E_{\\mathrm{freq}}$ 和相对差异 $r$。最终输出将是所有测试用例计算出的 $r$ 值的集合。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and numerically verifies Parseval's theorem for the DFT.\n    \"\"\"\n    \n    def calculate_discrepancy(x: np.ndarray) - float:\n        \"\"\"\n        Computes the relative discrepancy between time and frequency domain energies.\n\n        Args:\n            x: A 1D numpy array representing the time-domain sequence x[n].\n\n        Returns:\n            The dimensionless relative discrepancy r.\n        \"\"\"\n        N = len(x)\n        if N == 0:\n            return 0.0\n\n        # Compute time-domain energy: E_time = sum(|x[n]|^2)\n        # Using np.vdot is numerically robust and efficient for sum of squares of a complex vector.\n        E_time = np.vdot(x, x).real\n\n        # Compute frequency-domain signal X[k] using the unnormalized forward DFT\n        X = np.fft.fft(x)\n\n        # Compute frequency-domain energy: E_freq = (1/N) * sum(|X[k]|^2)\n        E_freq = (1 / N) * np.vdot(X, X).real\n\n        # Compute the dimensionless relative discrepancy r\n        max_E = max(E_time, E_freq)\n        \n        if max_E  0:\n            r = np.abs(E_time - E_freq) / max_E\n        else:\n            # This case handles E_time = E_freq = 0, e.g., for an all-zero signal.\n            r = 0.0\n            \n        return r\n\n    results = []\n\n    # Case A: Random complex, happy path\n    N_A = 128\n    seed_A = 12345\n    rng = np.random.default_rng(seed_A)\n    real_part_A = rng.standard_normal(N_A)\n    imag_part_A = rng.standard_normal(N_A)\n    x_A = real_part_A + 1j * imag_part_A\n    results.append(calculate_discrepancy(x_A))\n\n    # Case B: Single-bin complex exponential\n    N_B = 64\n    m_B = 7\n    c_B = 1.2 * np.exp(1j * 0.4)\n    n_B = np.arange(N_B)\n    x_B = c_B * np.exp(1j * 2 * np.pi * m_B * n_B / N_B)\n    results.append(calculate_discrepancy(x_B))\n\n    # Case C: Spectral leakage real sinusoid\n    N_C = 36\n    A_C = 1.0\n    f_C = np.sqrt(2)\n    phi_C = 0.3\n    n_C = np.arange(N_C)\n    x_C = A_C * np.sin(2 * np.pi * f_C * n_C / N_C + phi_C)\n    results.append(calculate_discrepancy(x_C))\n\n    # Case D: Impulse\n    N_D = 50\n    A_D = 3.0\n    n0_D = 17\n    x_D = np.zeros(N_D)\n    x_D[n0_D] = A_D\n    results.append(calculate_discrepancy(x_D))\n\n    # Case E: Ramp, centered\n    N_E = 32\n    n_E = np.arange(N_E)\n    x_E = n_E - (N_E - 1) / 2.0\n    results.append(calculate_discrepancy(x_E))\n\n    # Case F: All zeros, edge case\n    N_F = 10\n    x_F = np.zeros(N_F)\n    results.append(calculate_discrepancy(x_F))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "离散傅里叶变换的能力不仅限于一维信号，还可以扩展到更高维度，图像处理就是其一个主要应用。这个动手问题  将引导你使用二维离散傅里叶变换来实现一个理想的低通滤波器，这是像模糊和降噪等任务的基本工具。通过在频域中应用一个急剧的“砖墙”截止，你也将直接遇到并量化吉布斯现象（Gibbs phenomenon），从而学到关于理论滤波器设计的实际后果的重要一课。",
            "id": "3222771",
            "problem": "给定一项任务，要求设计并评估一个通过离散傅里叶变换 (DFT) 实现的理想二维低通滤波器。从二维离散傅里叶变换 (DFT) 及其逆变换的定义出发，并利用空间域和频率域之间的卷积-乘法对偶性，实现一个圆形的“砖墙”低通滤波器。然后，量化此滤波应用于具有单个锐利边缘的合成图像时所引入的振铃伪影（吉布斯现象）。\n\n请基于以下基本原理进行工作：\n- 一个大小为 $N \\times N$ 的数组 $x[n,m]$ 的二维离散傅里叶变换 (DFT) 定义为\n$$\nX[u,v] = \\sum_{n=0}^{N-1}\\sum_{m=0}^{N-1} x[n,m] \\, \\exp\\!\\left(-2\\pi i \\left(\\frac{un}{N} + \\frac{vm}{N}\\right)\\right),\n$$\n其二维离散傅里叶逆变换 (IDFT) 为\n$$\nx[n,m] = \\frac{1}{N^2}\\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} X[u,v] \\, \\exp\\!\\left(2\\pi i \\left(\\frac{un}{N} + \\frac{vm}{N}\\right)\\right).\n$$\n- 频率域中的乘法对应于空间域中的卷积，这意味着频率空间中的理想低通掩模对应于与一个非紧支撑的空间点扩散函数进行卷积。因此，截断或急剧切断频率内容会在空间域的不连续点附近引入振荡伪影（吉布斯现象）。\n\n请实现以下步骤：\n1. 构建一个合成的二值阶跃图像 $I \\in \\mathbb{R}^{N \\times N}$，其中心列处有一条垂直边缘。具体来说，对于每个行索引 $i \\in \\{0,\\dots,N-1\\}$ 和列索引 $j \\in \\{0,\\dots,N-1\\}$，\n$$\nI[i,j] = \\begin{cases}\n0,  j  \\frac{N}{2},\\\\\n1,  j \\ge \\frac{N}{2}.\n\\end{cases}\n$$\n2. 计算 $I$ 的二维 DFT 得到 $F$。设计一个由截止半径 $r_c$ 参数化的圆形砖墙低通掩模 $H$。该半径 $r_c$ 是在将零频分量居中（即进行频率移位使零频位于数组中心）后，以整数频率单元半径度量的。该掩模定义为\n$$\nH[u,v] = \\begin{cases}\n1,  \\sqrt{u^2 + v^2} \\le r_c,\\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n其中 $u,v \\in \\{-\\frac{N}{2}, -\\frac{N}{2}+1,\\dots,\\frac{N}{2}-1\\}$ 表示由移位产生的居中频率单元索引。\n3. 形成滤波后的频谱 $G = F \\cdot H$（逐点相乘），然后计算二维离散傅里叶逆变换以获得空间域中的重建图像 $\\widehat{I}$。保留 $\\widehat{I}$ 的实部。\n4. 使用中心行量化边缘附近的振铃。设 $c_0 = \\frac{N}{2}$ 为中心列索引，并设 $W$ 为一个小的正整数窗口半宽度。定义中心行剖面 $p[j] = \\widehat{I}\\!\\left[\\frac{N}{2}, j\\right]$，其中 $j \\in \\{0,\\dots,N-1\\}$。计算：\n   - 亮侧渐近线上方的峰值过冲，\n   $$\n   \\Delta^+ = \\max\\left(0, \\max_{j \\in \\{c_0,\\dots,\\min(N-1,c_0+W)\\}} \\big(p[j] - 1\\big)\\right).\n   $$\n   - 暗侧渐近线下方的峰值下冲，\n   $$\n   \\Delta^- = \\max\\left(0, \\max_{j \\in \\{\\max(0,c_0-W),\\dots,c_0-1\\}} \\big(0 - p[j]\\big)\\right).\n   $$\n   - 整个图像的均方误差 (MSE)，\n   $$\n   \\mathrm{MSE} = \\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\big(\\widehat{I}[i,j] - I[i,j]\\big)^2.\n   $$\n5. 对于每个测试用例，报告三元组 $\\left[\\Delta^+, \\Delta^-, \\mathrm{MSE}\\right]$，每个值四舍五入到 $6$ 位小数。\n\n测试套件：\n- 所有情况均使用 $N = 128$ 和 $W = 32$。评估截止半径（以居中频率单元为单位）$r_c \\in \\{0, 8, 16, 128\\}$ 时的滤波器。$r_c = 0$ 的情况只通过零频分量。$r_c = 128$ 的情况足够大，可以通过 $N = 128$ 的所有可用频率单元。\n- 此问题中不使用角度。没有物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个包含三个浮点数的列表，顺序为 $\\left[\\Delta^+, \\Delta^-, \\mathrm{MSE}\\right]$，四舍五入到 $6$ 位小数。例如，一个包含两个用例的有效格式为 $[[0.000000,0.000000,0.250000],[0.012345,0.012345,0.123456]]$。\n- 对于此问题中的四个测试用例，您的程序必须以精确的聚合列表格式输出单行结果：$[\\,[\\Delta^+_1,\\Delta^-_1,\\mathrm{MSE}_1],\\,[\\Delta^+_2,\\Delta^-_2,\\mathrm{MSE}_2],\\,[\\Delta^+_3,\\Delta^-_3,\\mathrm{MSE}_3],\\,[\\Delta^+_4,\\Delta^-_4,\\mathrm{MSE}_4]\\,]$，每个浮点数四舍五入到 $6$ 位小数。",
            "solution": "该问题要求使用离散傅里叶变换 (DFT) 设计并评估一个二维理想低通滤波器。先验验证确认该问题在科学上是合理的、适定的且客观的。它构成了数字信号处理中的一个标准练习，探讨了卷积定理的后果，特别是在频率域中应用“砖墙”滤波器时吉布斯现象（振铃伪影）的显现。我们将逐步进行实现和分析。\n\n核心原理是频率域中的乘法与空间域中的卷积之间的对偶性。用一个脉冲响应为 $h[n,m]$ 的滤波器对图像 $x[n,m]$ 进行滤波是一个卷积操作：$y[n,m] = (x * h)[n,m]$。根据卷积定理，这等效于它们各自 DFT 的逐点乘法：$Y[u,v] = X[u,v] \\cdot H[u,v]$，其中 $X = \\mathcal{F}\\{x\\}$ 和 $H = \\mathcal{F}\\{h\\}$。理想低通滤波器由频率域中的急剧截止定义，这对应于一个滤波器掩模 $H[u,v]$，它在某个频率半径内为1，在半径外为0。\n\n算法流程如下：\n\n**第 1 步：构建合成图像**\n构建一个合成测试图像 $I \\in \\mathbb{R}^{N \\times N}$，使其具有单个、锐利的垂直边缘。这提供了一个强烈的、局部化的不连续性，非常适合观察振铃伪影。根据规定，对于 $N=128$，图像定义为：\n$$\nI[i,j] = \\begin{cases}\n0,  \\text{对于 } 0 \\le j  64 \\\\\n1,  \\text{对于 } 64 \\le j  128\n\\end{cases}\n$$\n这对所有行 $i \\in \\{0, \\dots, 127\\}$ 都成立。图像的值在垂直方向上是恒定的。\n\n**第 2 步：变换到频率域和滤波器设计**\n首先，计算图像 $I[i,j]$ 的二维 DFT，以获得其频率域表示 $F[u,v] = \\mathcal{F}\\{I\\}$。\n$$\nF[u,v] = \\sum_{n=0}^{N-1}\\sum_{m=0}^{N-1} I[n,m] \\, \\exp\\!\\left(-2\\pi i \\left(\\frac{un}{N} + \\frac{vm}{N}\\right)\\right)\n$$\n接下来，构建一个圆形低通滤波器掩模 $H[u,v]$。该掩模在一个“移位”的频率空间中设计，其中零频分量 $(u=0, v=0)$ 位于 $N \\times N$ 网格的中心。居中的频率索引 $u,v$ 的范围是从 $-N/2$ 到 $N/2-1$。对于每个频率坐标 $(u,v)$，计算其到原点的欧几里得距离 $d = \\sqrt{u^2 + v^2}$。“砖墙”掩模 $H$ 随后基于截止半径 $r_c$ 定义：\n$$\nH[u,v] = \\begin{cases}\n1,  \\text{如果 } \\sqrt{u^2 + v^2} \\le r_c \\\\\n0,  \\text{如果 } \\sqrt{u^2 + v^2} > r_c\n\\end{cases}\n$$\n该掩模将应用于同样以这种居中配置排列的图像频谱。\n\n**第 3 步：滤波和逆变换**\n滤波操作是居中的图像频谱 $F_{\\text{shifted}}$ 与滤波器掩模 $H$ 的逐点相乘。\n$$\nG_{\\text{shifted}}[u,v] = F_{\\text{shifted}}[u,v] \\cdot H[u,v]\n$$\n为了正确计算逆 DFT，得到的滤波后频谱 $G_{\\text{shifted}}$ 必须被移位回标准的 DFT 布局，其中零频分量位于原点（索引 $(0,0)$）。设此为 $G$。空间域中的滤波后图像 $\\widehat{I}[i,j]$ 通过对 $G[u,v]$ 应用二维逆 DFT 获得。\n$$\n\\widehat{I}_{\\text{complex}}[i,j] = \\mathcal{F}^{-1}\\{G\\} = \\frac{1}{N^2}\\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} G[u,v] \\, \\exp\\!\\left(2\\pi i \\left(\\frac{ui}{N} + \\frac{vj}{N}\\right)\\right)\n$$\n由于原始图像 $I$ 是实值的，并且滤波器掩模 $H$ 具有共轭对称性（$H[u,v] = H[-u,-v]$），滤波后的频谱 $G$ 也将具有共轭对称性。因此，其逆 DFT $\\widehat{I}_{\\text{complex}}$ 应该是纯实数的，只存在数值精度误差。我们只保留实部：$\\widehat{I}[i,j] = \\text{real}(\\widehat{I}_{\\text{complex}}[i,j])$。\n\n**第 4 步：伪影量化**\n吉布斯现象表现为不连续点附近的振荡或“振铃”。我们量化图像中心行 $p[j] = \\widehat{I}[N/2, j]$ 上的这种效应，其中 $N=128$。边缘位于列索引 $c_0 = N/2 = 64$ 处。\n- 峰值过冲 $\\Delta^+$ 测量在边缘亮侧，半宽为 $W=32$ 的窗口内，剖面 $p[j]$ 高于高电平渐近线（即 $1$）的最大值。\n$$\n\\Delta^+ = \\max\\left(0, \\max_{j \\in \\{64,\\dots,96\\}} \\big(p[j] - 1\\big)\\right)\n$$\n- 峰值下冲 $\\Delta^-$ 测量在边缘暗侧，窗口内 $p[j]$ 低于低电平渐近线（即 $0$）的最大偏差。\n$$\n\\Delta^- = \\max\\left(0, \\max_{j \\in \\{32,\\dots,63\\}} \\big(0 - p[j]\\big)\\right)\n$$\n- 整体重建质量通过滤波后图像 $\\widehat{I}$ 与原始图像 $I$ 之间的均方误差 (MSE) 来衡量。\n$$\n\\mathrm{MSE} = \\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\big(\\widehat{I}[i,j] - I[i,j]\\big)^2\n$$\n\n**第 5 步：执行测试用例**\n对每个指定的截止半径 $r_c \\in \\{0, 8, 16, 128\\}$，以 $N=128$ 和 $W=32$ 执行上述过程。计算并格式化每个 $r_c$ 对应的三元组 $[\\Delta^+, \\Delta^-, \\mathrm{MSE}]$。\n\n- 对于 $r_c=0$，只有直流分量（$u=0,v=0$）被通过。重建的图像 $\\widehat{I}$ 是一个均匀图像，其值等于原始图像的平均强度，即 $0.5$。这导致 $\\Delta^+=0$，$\\Delta^-=0$ 和 $\\mathrm{MSE}=0.25$。\n- 对于 $r_c=128$，半径足够大，可以通过 $128 \\times 128$ 网格的所有频率分量。因此，$H$ 是一个全通滤波器，$\\widehat{I}$ 应与 $I$ 几乎相同，从而导致最小的伪影和误差。\n- 中间情况 $r_c=8$ 和 $r_c=16$ 将表现出典型的振铃伪影。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 2D ideal low-pass filter and quantifies ringing artifacts.\n    \"\"\"\n    # Define the parameters from the problem statement.\n    N = 128\n    W = 32\n    test_rcs = [0, 8, 16, 128]\n    c0 = N // 2\n\n    # Step 1: Construct the synthetic binary step image I.\n    I = np.zeros((N, N), dtype=float)\n    I[:, c0:] = 1.0\n\n    # Step 2: Compute the 2D DFT of I.\n    F = np.fft.fft2(I)\n    \n    # Pre-calculate frequency grid for mask generation.\n    # The grid is created in the \"shifted\" or centered representation.\n    freqs_1d = np.fft.fftshift(np.fft.fftfreq(N) * N)\n    u, v = np.meshgrid(freqs_1d, freqs_1d, indexing='ij')\n    radius_grid = np.sqrt(u**2 + v**2)\n    \n    # Store the shifted spectrum of the image.\n    F_shifted = np.fft.fftshift(F)\n\n    results_data = []\n    \n    for r_c in test_rcs:\n        # Step 2 (cont.): Design the circular brick-wall low-pass mask H.\n        H = (radius_grid = r_c).astype(float)\n\n        # Step 3: Form the filtered spectrum and compute the inverse DFT.\n        # Apply the mask via pointwise multiplication in the frequency domain.\n        G_shifted = F_shifted * H\n        \n        # Shift the filtered spectrum back to the standard DFT layout.\n        G = np.fft.ifftshift(G_shifted)\n        \n        # Compute the inverse 2D DFT.\n        I_hat_complex = np.fft.ifft2(G)\n        \n        # Retain the real part of the reconstructed image.\n        I_hat = np.real(I_hat_complex)\n\n        # Step 4: Quantify ringing artifacts and MSE.\n        # Extract the center-row profile.\n        p = I_hat[N // 2, :]\n\n        # Calculate peak overshoot (Delta+).\n        # Interval: j from c0 to c0+W. Slice is [c0:c0+W+1].\n        bright_region_slice = p[c0 : c0 + W + 1]\n        overshoot = np.max(bright_region_slice - 1.0)\n        delta_plus = max(0.0, overshoot)\n\n        # Calculate peak undershoot (Delta-).\n        # Interval: j from c0-W to c0-1. Slice is [c0-W:c0].\n        dark_region_slice = p[c0 - W : c0]\n        undershoot = np.max(0.0 - dark_region_slice)\n        delta_minus = max(0.0, undershoot)\n\n        # Calculate Mean-Squared Error (MSE).\n        mse = np.mean((I_hat - I)**2)\n        \n        # Store the triplet of results for this test case.\n        results_data.append([delta_plus, delta_minus, mse])\n\n    # Step 5: Format the final output string exactly as specified.\n    outer_parts = []\n    for res_triple in results_data:\n        inner_parts = [f\"{val:.6f}\" for val in res_triple]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output_string = f\"[{','.join(outer_parts)}]\"\n    \n    # The final print statement produces a single line in the required format.\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}