{
    "hands_on_practices": [
        {
            "introduction": "在投入编程实现之前，首先通过解析计算来巩固对降阶模型核心概念的理解至关重要。本练习  旨在引导你回归本源，将“恰当正交分解”(Proper Orthogonal Decomposition, POD)模态与其基本定义——时空关联算符的特征函数——直接联系起来。通过对一个简洁的解析函数进行推导，你将亲手揭示POD如何从复杂的时空数据中高效地提取出最优的空间结构模式，从而深化对该方法数学本质的认识。",
            "id": "3265890",
            "problem": "考虑空间域 $x \\in [0,1]$，其空间内积由 $\\langle f, g \\rangle = \\int_{0}^{1} f(x) g(x) \\, dx$ 给出，时间系综平均由长时间平均值 $\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} (\\cdot) \\, dt$ 定义。设时空场为\n$$\nu(x,t) = \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t),\n$$\n其中 $\\omega_{1} > 0$ 和 $\\omega_{2} > 0$ 是不同的实常数。使用本征正交分解（Proper Orthogonal Decomposition, POD）的基本定义，其中空间POD模态是空间相关算子\n$$\n\\mathcal{C}[\\phi](x) = \\int_{0}^{1} C(x,y) \\, \\phi(y) \\, dy,\n$$\n的本征函数，该算子由相关核\n$$\nC(x,y) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} u(x,t) \\, u(y,t) \\, dt,\n$$\n构造，推导与 $u(x,t)$ 相关的解析空间POD模态。将模态表示为 $L^{2}([0,1])$ 归一化函数。最终答案必须将两个归一化的空间POD模态列在一个单行矩阵中。不需要单位，也不需要四舍五入。",
            "solution": "该问题要求针对给定的时空场 $u(x,t)$ 推导其空间本征正交分解（POD）模态。根据定义，记作 $\\phi(x)$ 的空间POD模态是空间两点相关算子 $\\mathcal{C}$ 的本征函数，$\\mathcal{C}$ 是一个以 $C(x,y)$ 为核的积分算子。该本征问题由下式给出：\n$$\n\\mathcal{C}[\\phi](x) = \\int_{0}^{1} C(x,y) \\, \\phi(y) \\, dy = \\lambda \\phi(x)\n$$\n核 $C(x,y)$ 定义为场在两个空间位置 $x$ 和 $y$ 处乘积的时间平均值。\n$$\nC(x,y) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} u(x,t) \\, u(y,t) \\, dt\n$$\n第一步是为给定的场 $u(x,t) = \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t)$ 计算这个核。\n\n我们展开乘积 $u(x,t) \\, u(y,t)$：\n\\begin{align*}\nu(x,t) \\, u(y,t) =  \\left[ \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t) \\right] \\left[ \\sin(2\\pi y) \\cos(\\omega_{1} t) + \\sin(3\\pi y) \\cos(\\omega_{2} t) \\right] \\\\\n=  \\sin(2\\pi x) \\sin(2\\pi y) \\cos^2(\\omega_{1} t) \\\\\n + \\sin(3\\pi x) \\sin(3\\pi y) \\cos^2(\\omega_{2} t) \\\\\n + \\sin(2\\pi x) \\sin(3\\pi y) \\cos(\\omega_{1} t) \\cos(\\omega_{2} t) \\\\\n + \\sin(3\\pi x) \\sin(2\\pi y) \\cos(\\omega_{1} t) \\cos(\\omega_{2} t)\n\\end{align*}\n为了求得 $C(x,y)$，我们必须计算时间分量的长时间平均值。我们需要以下关于谐波函数的标准时间平均结果：\n1. 对于任意非零频率 $\\omega > 0$，\n$$\n\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega t) \\, dt = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\frac{1 + \\cos(2\\omega t)}{2} \\, dt = \\lim_{T \\to \\infty} \\frac{1}{T} \\left[ \\frac{t}{2} + \\frac{\\sin(2\\omega t)}{4\\omega} \\right]_{0}^{T} = \\frac{1}{2}\n$$\n2. 对于两个不同的正频率 $\\omega_1 \\neq \\omega_2$，\n$$\n\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos(\\omega_1 t) \\cos(\\omega_2 t) \\, dt = \\lim_{T \\to \\infty} \\frac{1}{2T} \\int_{0}^{T} \\left[ \\cos((\\omega_1 - \\omega_2)t) + \\cos((\\omega_1 + \\omega_2)t) \\right] dt = 0\n$$\n第二个结果成立，因为余弦函数在一个周期上的积分为零，其不定积分是一个有界的正弦函数。除以 $T \\to \\infty$ 使得平均值趋于 $0$。\n\n将这些时间平均值应用于展开的乘积，涉及 $\\cos(\\omega_{1} t) \\cos(\\omega_{2} t)$ 的交叉项的平均值为零。我们剩下：\n\\begin{align*}\nC(x,y) = \\sin(2\\pi x) \\sin(2\\pi y) \\left( \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega_{1} t) \\, dt \\right) + \\sin(3\\pi x) \\sin(3\\pi y) \\left( \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega_{2} t) \\, dt \\right) \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y)\n\\end{align*}\n这是一个秩为 $2$ 的可分离核。具有此类核的算子的本征函数必须位于构成该核的函数的生成空间中，即 $\\text{span}\\{\\sin(2\\pi x), \\sin(3\\pi x)\\}$。\n\n我们来检查基函数 $\\psi_1(x) = \\sin(2\\pi x)$ 和 $\\psi_2(x) = \\sin(3\\pi x)$ 在给定的内积 $\\langle f, g \\rangle = \\int_{0}^{1} f(x) g(x) \\, dx$ 下是否正交：\n$$\n\\langle \\psi_1, \\psi_2 \\rangle = \\int_{0}^{1} \\sin(2\\pi x) \\sin(3\\pi x) \\, dx = \\frac{1}{2} \\int_{0}^{1} \\left[ \\cos(\\pi x) - \\cos(5\\pi x) \\right] dx = \\frac{1}{2} \\left[ \\frac{\\sin(\\pi x)}{\\pi} - \\frac{\\sin(5\\pi x)}{5\\pi} \\right]_{0}^{1} = 0\n$$\n由于空间函数是正交的，它们确实是相关算子 $\\mathcal{C}$ 的本征函数。我们可以通过将它们代入本征问题来验证这一点。\n\n对于第一个候选本征函数 $\\phi(x) = \\psi_1(x) = \\sin(2\\pi x)$：\n\\begin{align*}\n\\mathcal{C}[\\psi_1](x) = \\int_{0}^{1} \\left[ \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y) \\right] \\sin(2\\pi y) \\, dy \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\int_{0}^{1} \\sin^2(2\\pi y) \\, dy + \\frac{1}{2} \\sin(3\\pi x) \\int_{0}^{1} \\sin(3\\pi y) \\sin(2\\pi y) \\, dy\n\\end{align*}\n第二个积分为零，这是由于正交性。第一个积分为：\n$$\n\\int_{0}^{1} \\sin^2(2\\pi y) \\, dy = \\int_{0}^{1} \\frac{1 - \\cos(4\\pi y)}{2} \\, dy = \\left[ \\frac{y}{2} - \\frac{\\sin(4\\pi y)}{8\\pi} \\right]_{0}^{1} = \\frac{1}{2}\n$$\n因此，$\\mathcal{C}[\\psi_1](x) = \\frac{1}{2} \\sin(2\\pi x) \\cdot \\frac{1}{2} = \\frac{1}{4} \\sin(2\\pi x)$。\n所以，$\\phi_1(x) = \\sin(2\\pi x)$ 是一个本征函数，其本征值为 $\\lambda_1 = \\frac{1}{4}$。\n\n对于第二个候选本征函数 $\\phi(x) = \\psi_2(x) = \\sin(3\\pi x)$：\n\\begin{align*}\n\\mathcal{C}[\\psi_2](x) = \\int_{0}^{1} \\left[ \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y) \\right] \\sin(3\\pi y) \\, dy \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\int_{0}^{1} \\sin(2\\pi y) \\sin(3\\pi y) \\, dy + \\frac{1}{2} \\sin(3\\pi x) \\int_{0}^{1} \\sin^2(3\\pi y) \\, dy\n\\end{align*}\n第一个积分为零。第二个积分为：\n$$\n\\int_{0}^{1} \\sin^2(3\\pi y) \\, dy = \\int_{0}^{1} \\frac{1 - \\cos(6\\pi y)}{2} \\, dy = \\left[ \\frac{y}{2} - \\frac{\\sin(6\\pi y)}{12\\pi} \\right]_{0}^{1} = \\frac{1}{2}\n$$\n因此，$\\mathcal{C}[\\psi_2](x) = \\frac{1}{2} \\sin(3\\pi x) \\cdot \\frac{1}{2} = \\frac{1}{4} \\sin(3\\pi x)$。\n所以，$\\phi_2(x) = \\sin(3\\pi x)$ 是一个本征函数，其本征值为 $\\lambda_2 = \\frac{1}{4}$。\n\n最后一步是将这些本征函数归一化，使其具有单位 $L^2$ 范数。本征函数 $\\phi$ 的范数平方为 $\\|\\phi\\|^2 = \\langle \\phi, \\phi \\rangle = \\int_{0}^{1} \\phi(x)^2 \\, dx$。\n对于第一个模态 $\\sin(2\\pi x)$：\n$$\n\\|\\sin(2\\pi x)\\|^2 = \\int_{0}^{1} \\sin^2(2\\pi x) \\, dx = \\frac{1}{2}\n$$\n归一化常数为 $1 / \\sqrt{1/2} = \\sqrt{2}$。第一个归一化的POD模态是 $\\hat{\\phi_1}(x) = \\sqrt{2} \\sin(2\\pi x)$。\n\n对于第二个模态 $\\sin(3\\pi x)$：\n$$\n\\|\\sin(3\\pi x)\\|^2 = \\int_{0}^{1} \\sin^2(3\\pi x) \\, dx = \\frac{1}{2}\n$$\n归一化常数也是 $\\sqrt{2}$。第二个归一化的POD模态是 $\\hat{\\phi_2}(x) = \\sqrt{2} \\sin(3\\pi x)$。\n\n因此，两个非平凡的空间POD模态是 $\\sqrt{2} \\sin(2\\pi x)$ 和 $\\sqrt{2} \\sin(3\\pi x)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\sqrt{2}\\sin(2\\pi x)  \\sqrt{2}\\sin(3\\pi x)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "掌握了理论基础后，我们将从纸笔推演转向实际的数值计算。本练习  将指导你使用“快照法”(method of snapshots)和“奇异值分解”(Singular Value Decomposition, SVD)这一业界标准流程来构建POD基。我们将此方法应用于一个经典的测试案例——平移的高斯脉冲，这个案例看似简单，却能深刻揭示标准POD方法的一个关键局限性，从而促使你辩证地思考这一强大工具的适用场景与边界。",
            "id": "3265968",
            "problem": "考虑一个平移高斯脉冲的快照函数族，其定义为 $u(x,t) = \\exp\\!\\left(-\\big(x - c t\\big)^{2}\\right)$，作用于空间区间 $x \\in [-L,L]$ 和离散时间点 $t \\in \\{t_{0}, t_{1}, \\dots, t_{m-1}\\}$。从第一性原理出发，本征正交分解（POD）是一种程序，对于给定的秩 $r$，它在空间中选择一个 $r$ 维标准正交基，以最小化快照集的总平方投影误差。等价地，它在所有网格点和时间上以欧几里得最小二乘意义生成快照数据的最佳秩-$r$ 近似。\n\n你的任务是实现一个程序，该程序：\n- 构建快照矩阵 $X \\in \\mathbb{R}^{N_x \\times m}$，其第 $k$ 列是在 $[-L,L]$ 上的 $N_x$ 个均匀间隔网格点上采样的快照 $u(x,t_k)$。这里给定速度 $c$、快照数量 $m$ 以及最终时间 $T$，其中 $t_k$ 在 $[0,T]$ 内均匀分布。\n- 对秩 $r \\in \\{1,2,5,10\\}$，计算最佳秩-$r$ 近似 $X_r$（由 POD 定义）及相应的相对重构误差\n$$E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F},$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。\n- 将每个测试用例的误差 $E_r$ 作为浮点数报告，四舍五入到六位小数。\n\n使用的基本原理：\n- 欧几里得内积和弗罗贝尼乌斯范数的定义。\n- 本征正交分解（POD）的定义性优化性质：在所有 $r$ 维标准正交基中，POD 最小化快照的总平方投影误差。这在最小二乘意义上产生了快照矩阵的最佳秩-$r$ 近似。\n\n测试套件：\n所有用例均使用 $L = 10$ 和 $N_x = 401$。四个测试用例是：\n1. 用例 A（静止脉冲）：$c = 0$, $T = 5$, $m = 50$。\n2. 用例 B（慢速平移）：$c = 0.5$, $T = 10$, $m = 100$。\n3. 用例 C（快速平移）：$c = 2.0$, $T = 4$, $m = 80$。\n4. 用例 D（少量快照）：$c = 0.5$, $T = 10$, $m = 5$。\n\n答案规格：\n- 对每个测试用例，输出一个包含四个浮点数的列表 $[E_{1},E_{2},E_{5},E_{10}]$，四舍五入到六位小数。\n- 你的程序应生成单行输出，其中包含结果。结果是一个用方括号括起来的逗号分隔列表，其中每个元素是对应一个测试用例（按 A、B、C、D 的顺序）的包含四个误差的方括号列表。例如，正确格式的输出应如下所示\n$[[e_{A,1},e_{A,2},e_{A,5},e_{A,10}],[e_{B,1},e_{B,2},e_{B,5},e_{B,10}],[e_{C,1},e_{C,2},e_{C,5},e_{C,10}],[e_{D,1},e_{D,2},e_{D,5},e_{D,10}]]$，\n该行中任何地方都没有空格。\n\n单位：\n- 此问题不要求任何物理单位。\n\n角度单位：\n- 不适用。\n\n百分比：\n- 不适用；所有量均以小数表示。\n\n你的实现必须是自包含的，不需要用户输入、外部文件或网络访问。它必须能在现代编程语言中运行，并在一行内生成上述确切的最终输出格式。",
            "solution": "问题需要进行验证。\n\n### 第 1 步：提取已知条件\n- **快照函数**：$u(x,t) = \\exp(-(x - c t)^2)$\n- **空间域**：$x \\in [-L,L]$\n- **时间域**：$t \\in \\{t_{0}, t_{1}, \\dots, t_{m-1}\\}$，即 $[0,T]$ 中的 $m$ 个等距点。\n- **空间离散化**：$[-L,L]$ 中的 $N_x$ 个均匀间隔的网格点。\n- **快照矩阵**：$X \\in \\mathbb{R}^{N_x \\times m}$，其中第 $k$ 列是采样快照 $u(x,t_k)$。\n- **任务**：使用本征正交分解（POD）对秩 $r \\in \\{1, 2, 5, 10\\}$ 计算最佳秩-$r$ 近似 $X_r$。\n- **误差度量**：相对重构误差 $E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F}$，其中 $\\lVert \\cdot \\rVert_F$ 是弗罗贝尼乌斯范数。\n- **常数**：$L = 10$, $N_x = 401$。\n- **测试用例**：\n    1. 用例 A：$c = 0$, $T = 5$, $m = 50$。\n    2. 用例 B：$c = 0.5$, $T = 10$, $m = 100$。\n    3. 用例 C：$c = 2.0$, $T = 4$, $m = 80$。\n    4. 用例 D：$c = 0.5$, $T = 10$, $m = 5$。\n- **输出规格**：单行逗号分隔的列表的列表，例如 `[[e_{A,1},...,e_{A,10}],[e_{B,1},...,e_{B,10}],...]`，数字四舍五入到六位小数且无空格。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题是本征正交分解（POD）的标准应用，POD 是科学计算中降阶建模的基石。其数学基础是奇异值分解（SVD），这是线性代数的一个主要结果。所涉及的物理是一个简单的平移高斯脉冲，这是一个常见且有效的测试用例。该问题在科学上是合理的。\n- **适定性**：为每个用例提供了所有必需的参数（$L, N_x, c, T, m$）。函数 $u(x,t)$、构建快照矩阵 $X$ 的过程以及误差度量 $E_r$ 都得到了明确的定义。SVD 为最佳秩-$r$ 近似提供了唯一的构造方法，确保了唯一解的存在。\n- **客观性**：该问题用精确的数学术语表述，没有任何主观性、模糊性或基于观点的陈述。\n\n### 第 3 步：结论与行动\n问题是有效的。这是一个在数值方法领域中定义良好、自包含且科学上合理的问题。将提供完整的解决方案。\n\n### 基于原理的解决方案\n目标是计算一组数据快照的秩-$r$ 近似的相对重构误差。其基本原理是，由弗罗贝尼乌斯范数定义的最小二乘意义下的最优秩-$r$ 近似可通过奇异值分解（SVD）获得。这一结果由 Eckart-Young-Mirsky 定理正式陈述。\n\n**1. 快照矩阵的构建**\n首先，我们对问题域进行离散化。空间域 $x \\in [-L, L]$ 在 $N_x$ 个均匀间隔的点上采样，形成网格 $\\{x_j\\}_{j=0}^{N_x-1}$。时间区间 $t \\in [0, T]$ 在 $m$ 个离散、等距的点上采样，形成 $\\{t_k\\}_{k=0}^{m-1}$。在每个时间点 $t_k$ 的快照数据是一个在 $\\mathbb{R}^{N_x}$ 中的向量，其分量由函数 $u(x_j, t_k)$ 给出。这些快照的集合构成了快照矩阵 $X \\in \\mathbb{R}^{N_x \\times m}$ 的列。该矩阵的一个元素 $X_{jk}$ 由下式给出：\n$$X_{jk} = u(x_j, t_k) = \\exp\\!\\left(-\\big(x_j - c t_k\\big)^{2}\\right)$$\n\n**2. 奇异值分解与最优近似**\n快照矩阵 $X$ 的 SVD 分解为：\n$$X = U \\Sigma V^T$$\n其中 $U \\in \\mathbb{R}^{N_x \\times N_x}$ 是一个正交矩阵，其列 $u_i$ 是左奇异向量（POD 模态），$V \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，其列 $v_i$ 是右奇异向量，$\\Sigma \\in \\mathbb{R}^{N_x \\times m}$ 是一个包含奇异值 $\\sigma_i$ 的矩形对角矩阵。奇异值是非负的，并按惯例排序：$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_k \\ge 0$，其中 $k = \\min(N_x, m)$ 是矩阵的秩。\n\nEckart-Young-Mirsky 定理指出，最小化差异的弗罗贝尼乌斯范数 $\\lVert X - X_r \\rVert_F$ 的 $X$ 的最佳秩-$r$ 近似是截断 SVD：\n$$X_r = \\sum_{i=1}^{r} \\sigma_i u_i v_i^T$$\n这种近似是使用前 $r$ 个奇异值及其对应的左右奇异向量构建的。\n\n**3. 误差计算**\n相对重构误差 $E_r$ 定义为误差矩阵 $(X - X_r)$ 的弗罗贝尼乌斯范数与原始矩阵 $X$ 的弗罗贝尼乌斯范数之比。弗罗贝尼乌斯范数与奇异值通过恒等式 $\\lVert A \\rVert_F^2 = \\sum_{i=1}^{\\text{rank}(A)} \\sigma_i(A)^2$ 相关联。\n应用此性质，原始矩阵的范数平方是其所有奇异值平方的和：\n$$\\lVert X \\rVert_F^2 = \\sum_{i=1}^{k} \\sigma_i^2$$\n误差矩阵为 $X - X_r = \\sum_{i=r+1}^{k} \\sigma_i u_i v_i^T$。由于奇异向量的正交性，误差矩阵的弗罗贝尼乌斯范数平方是被舍弃的奇异值平方的和：\n$$\\lVert X - X_r \\rVert_F^2 = \\sum_{i=r+1}^{k} \\sigma_i^2$$\n结合这些结果，相对重构误差由下式给出：\n$$E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F} = \\frac{\\sqrt{\\sum_{i=r+1}^{k} \\sigma_i^2}}{\\sqrt{\\sum_{i=1}^{k} \\sigma_i^2}}$$\n请注意，如果请求的秩 $r$ 大于或等于矩阵的实际秩 $k$，则分子中的和为空，其计算结果为 $0$，从而正确地得出误差 $E_r = 0$。\n\n**4. 计算步骤**\n对每个测试用例，算法按以下步骤进行：\n1.  定义参数 $c$、$T$ 和 $m$，以及固定常数 $L=10$ 和 $N_x=401$。\n2.  构建空间网格 $x$ 和时间网格 $t$。\n3.  使用给定的函数 $u(x,t)$ 组装 $N_x \\times m$ 的快照矩阵 $X$。\n4.  使用标准数值库的 SVD 函数计算 $X$ 的奇异值 $\\sigma_i$。最有效的方法是只计算奇异值，而不是完整的 $U$ 和 $V$ 矩阵。\n5.  计算总能量，由弗罗贝尼乌斯范数的平方表示，$S_{total} = \\sum_{i=1}^{k} \\sigma_i^2$。\n6.  对于每个所需的秩 $r \\in \\{1, 2, 5, 10\\}$，计算误差能量，$S_{error} = \\sum_{i=r+1}^{k} \\sigma_i^2$。\n7.  相对误差则为 $E_r = \\sqrt{S_{error} / S_{total}}$。\n8.  收集每个测试用例计算出的误差，并根据输出规格进行格式化。\n这个过程提供了一种直接且数值稳定的方法，用于根据线性代数的基本原理确定所需的重构误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Proper Orthogonal Decomposition problem for a translating Gaussian pulse.\n    \"\"\"\n    # Global parameters for all test cases\n    L = 10.0\n    Nx = 401\n    ranks_to_compute = [1, 2, 5, 10]\n\n    # Test suite: (c, T, m)\n    # c: speed, T: final time, m: number of snapshots\n    test_cases = [\n        (0.0, 5.0, 50),   # Case A: stationary pulse\n        (0.5, 10.0, 100), # Case B: slow translation\n        (2.0, 4.0, 80),   # Case C: fast translation\n        (0.5, 10.0, 5),   # Case D: few snapshots\n    ]\n\n    all_results = []\n\n    for c, T, m in test_cases:\n        # 1. Create spatial and temporal grids\n        x = np.linspace(-L, L, Nx)\n        t = np.linspace(0.0, T, m)\n\n        # 2. Construct the snapshot matrix X using broadcasting\n        # x_col has shape (Nx, 1) and t_row has shape (1, m)\n        # Broadcasting expands them to (Nx, m) for element-wise operations\n        x_col = x[:, np.newaxis]\n        t_row = t[np.newaxis, :]\n        X = np.exp(-((x_col - c * t_row) ** 2))\n\n        # 3. Compute the singular values of X\n        # We only need the singular values, so compute_uv=False is most efficient.\n        s = np.linalg.svd(X, compute_uv=False)\n        num_singular_values = s.shape[0]\n\n        # 4. Calculate the total energy (squared Frobenius norm of X)\n        # This is the sum of the squares of all singular values.\n        norm_X_sq = np.sum(s**2)\n\n        case_errors = []\n        for r in ranks_to_compute:\n            # 5. Calculate the reconstruction error for rank r\n            \n            # If norm_X_sq is zero, all errors are zero.\n            if norm_X_sq == 0.0:\n                 error = 0.0\n            # If rank r is >= number of singular values, the approximation is perfect.\n            elif r >= num_singular_values:\n                error = 0.0\n            else:\n                # The error norm is based on the truncated singular values (from r to end).\n                # s[r:] corresponds to sigma_{r+1}, sigma_{r+2}, ...\n                norm_err_sq = np.sum(s[r:]**2)\n                error = np.sqrt(norm_err_sq / norm_X_sq)\n            \n            case_errors.append(error)\n\n        all_results.append(case_errors)\n\n    # 6. Format the output string exactly as specified.\n    # e.g., [[err1,err2,...],[err1,err2,...]] with no spaces.\n    formatted_sublists = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places.\n        formatted_numbers = [f\"{err:.6f}\" for err in res_list]\n        # Join numbers with commas and enclose in brackets.\n        formatted_sublists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    # Join the sublists with commas and enclose in outer brackets.\n    final_output = f\"[{','.join(formatted_sublists)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "降阶建模的终极目标往往不只是数据压缩，更是为了构建能进行快速预测的动态系统。这个进阶练习  探讨了一个关键且微妙的陷阱：即使一个POD基能够完美重构用于训练的快照数据，通过它进行伽辽金投影(Galerkin projection)得到的降阶模型(ROM)却可能变得不稳定，甚至给出无意义的发散结果。本练习将清晰地展示数据重构精度与模型预测保真度之间的本质区别，这是每一位ROM实践者都必须掌握的重要一课。",
            "id": "2432128",
            "problem": "要求您实现一个完整的降阶建模数值实验，用以演示以下现象：对于一个稳定的全阶线性时不变系统，本征正交分解（POD）基在重构训练快照方面可能表现出色，但通过伽辽金投影得到的降阶模型（ROM）却可能产生不稳定的动态行为，并在时间积分时发生爆破。\n\n您的实现必须从以下全阶常微分方程开始\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b},\n$$\n其中 $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$ 和 $\\mathbf{b}\\in\\mathbb{R}^{n}$ 是常数，$\\mathbf{x}(t)\\in\\mathbb{R}^{n}$ 是状态。所有计算都在实数域上进行，并采用标准的欧几里得内积。在整个实验中，您将使用 $n=2$。\n\n基本定义和要求：\n- 本征正交分解（POD）基：给定一个快照矩阵\n$$\n\\mathbf{X} = \\begin{bmatrix}\\mathbf{x}(t_1)  \\mathbf{x}(t_2)  \\cdots  \\mathbf{x}(t_m)\\end{bmatrix}\\in\\mathbb{R}^{n\\times m},\n$$\n计算其奇异值分解（SVD）$\\mathbf{X}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的POD基 $\\mathbf{Q}\\in\\mathbb{R}^{n\\times r}$ 取为 $\\mathbf{U}$ 的前 $r$ 列。\n- 伽辽金投影：降阶算子和降阶强迫项为\n$$\n\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}\\in\\mathbb{R}^{r\\times r},\\qquad \\mathbf{b}_r=\\mathbf{Q}^\\top\\mathbf{b}\\in\\mathbb{R}^{r}.\n$$\n降阶状态 $\\mathbf{z}(t)\\in\\mathbb{R}^{r}$ 的演化遵循\n$$\n\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r \\mathbf{z} + \\mathbf{b}_r,\\qquad \\mathbf{x}_r(t)=\\mathbf{Q}\\mathbf{z}(t).\n$$\n- 时间积分：对全阶模型和降阶模型均使用经典的四阶龙格-库塔方法，并采用固定的时间步长 $h>0$。将初始条件设置为 $\\mathbf{x}(0)=\\mathbf{0}$ 和 $\\mathbf{z}(0)=\\mathbf{Q}^\\top\\mathbf{x}(0)=\\mathbf{0}$。\n- 快照收集：在训练时间域 $[0,T_{\\text{train}}]$上以恒定时间步长 $h$ 对全阶模型进行积分，在每一步对状态进行采样以构建 $\\mathbf{X}$。\n- 重构误差：将训练快照的相对POD重构误差度量为\n$$\n\\varepsilon_{\\text{rec}} = \\frac{\\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F}{\\lVert \\mathbf{X}\\rVert_F},\n$$\n其中 $\\lVert\\cdot\\rVert_F$ 表示弗罗贝尼乌斯范数。\n- 爆破检测：在测试时间域 $[0,T_{\\text{test}}]$ 上使用相同的 $h$ 对全阶模型和降阶模型进行演化。如果在任何时间步，当前状态的欧几里得范数超过阈值 $M$，或任何分量变为非数字（not-a-number）或无穷大，则声明解“已爆破”。使用阈值 $M=10^6$。\n\n为引发降阶模型不稳定性而构造的强迫项：\n- 对于每个测试，您必须按如下方式构造恒定强迫项 $\\mathbf{b}$。计算对称部分 $\\mathbf{S}=\\frac{1}{2}(\\mathbf{A}+\\mathbf{A}^\\top)$ 及其与 $\\mathbf{S}$ 的最大特征值相关的主单位特征向量 $\\mathbf{q}\\in\\mathbb{R}^{n}$（以任意但确定性的方式处理并列情况）。设置\n$$\n\\mathbf{b}=-\\mathbf{A}\\mathbf{q}.\n$$\n这种构造确保了全阶稳态为 $\\mathbf{x}_\\infty = -\\mathbf{A}^{-1}\\mathbf{b}=\\mathbf{q}$。当 $\\mathbf{A}$ 是高度非正规的且 $\\mathbf{S}$ 的最大特征值为正时，使用 $r=1$ 和 $\\mathbf{Q}=\\mathbf{q}$ 获得的标量降阶模型具有降阶动态 $\\frac{dz}{dt} = a_r z + b_r$，其中 $a_r=\\mathbf{q}^\\top\\mathbf{A}\\mathbf{q}>0$ 且 $b_r=-a_r$，该模型是不稳定的，并从 $z(0)=0$ 开始发散。\n\n所有测试通用的数值规格：\n- 使用 $n=2$。\n- 使用 $h=10^{-3}$。\n- 使用经典的四阶龙格-库塔方法。\n- 对所有向量范数使用欧几里得范数。\n- 使用 $\\mathbf{x}(0)=\\mathbf{0}$。\n\n测试套件：\n为以下参数集实现上述过程。在每种情况下，定义 $\\mathbf{A}$，按规定计算 $\\mathbf{q}$ 和 $\\mathbf{b}$，在 $[0,T_{\\text{train}}]$ 上收集快照以形成 $\\mathbf{Q}$，然后构建降阶模型并在 $[0,T_{\\text{test}}]$ 上运行两个模型。\n\n- 测试 $1$（高度非正规，秩为1的POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 $2$（高度非正规，秩为2的POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=2$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 $3$（对称负定，秩为1的POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-1.0  0.0 \\\\ 0.0  -2.0\\end{bmatrix}$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 $4$（更高度非正规，秩为1的POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=120.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n\n要求的输出：\n- 对每个测试，输出一个包含三个条目的列表：\n  - 标量 $\\varepsilon_{\\text{rec}}$（四舍五入到六位小数），\n  - 一个布尔值，指示降阶模型是否在 $[0,T_{\\text{test}}]$ 上发生爆破，\n  - 一个布尔值，指示全阶模型是否在 $[0,T_{\\text{test}}]$ 上发生爆破。\n- 将所有测试的结果聚合为单行，形式为用方括号括起来的逗号分隔列表，顺序与测试顺序相同。示例格式：\n$[\\,[\\varepsilon_{\\text{rec}}^{(1)},\\,\\text{ROM}^{(1)}\\_\\text{blowup},\\,\\text{FOM}^{(1)}\\_\\text{blowup}],\\,[\\varepsilon_{\\text{rec}}^{(2)},\\,\\text{ROM}^{(2)}\\_\\text{blowup},\\,\\text{FOM}^{(2)}\\_\\text{blowup}],\\,\\ldots\\,]$。",
            "solution": "用户提出了一个计算工程领域的问题，具体涉及基于本征正交分解（POD）和伽辽金投影的降阶模型（ROM）的稳定性。任务是通过数值实验来展示一种已知的失效模式，即尽管全阶模型（FOM）是稳定的，降阶模型却可能变得不稳定。这种现象是受高度非正规算子支配的系统的典型特征。\n\n问题陈述已经过验证，被认为是科学上合理、适定且完整的。所有定义、参数和程序都已明确指定，足以得出一个唯一且可验证的解。我们将着手进行分析和实现。\n\n问题的核心在于矩阵 $\\mathbf{A}$ 的谱与其数值范围（或值域）之间的区别，后者定义为 $W(\\mathbf{A}) = \\{\\mathbf{v}^\\dagger\\mathbf{A}\\mathbf{v} : \\mathbf{v} \\in \\mathbb{C}^n, \\lVert\\mathbf{v}\\rVert_2 = 1\\}$。对于一个线性时不变系统 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x}$，其稳定性由 $\\mathbf{A}$ 的特征值（谱，$\\sigma(\\mathbf{A})$）决定。如果所有特征值的实部均为负，则系统是稳定的，且当 $t\\to\\infty$ 时 $\\lVert\\mathbf{x}(t)\\rVert \\to 0$。然而，如果 $\\mathbf{A}$ 是非正规的（即 $\\mathbf{A}\\mathbf{A}^\\top \\neq \\mathbf{A}^\\top\\mathbf{A}$），则可能出现瞬态增长。数值范围为这种瞬态行为提供了洞察。数值范围的实部由矩阵的对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$ 控制，因为 $\\text{Re}(\\mathbf{v}^\\top\\mathbf{A}\\mathbf{v}) = \\mathbf{v}^\\top\\mathbf{S}\\mathbf{v}$。$\\mathbf{S}$ 的一个正特征值意味着 $\\mathbf{A}$ 的数值范围延伸到了右半平面，表明存在瞬态能量增长的可能性。\n\n使用秩为 $r$ 的POD基 $\\mathbf{Q}$ 进行伽辽金投影，将全阶模型 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 转换为降阶模型 $\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r\\mathbf{z} + \\mathbf{b}_r$，其中 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。降阶模型的稳定性由降阶矩阵 $\\mathbf{A}_r$ 的特征值决定。关键在于，$\\mathbf{A}_r$ 的特征值包含在 $\\mathbf{A}$ 的数值范围之内，但不一定在其谱的凸包之内。如果数值范围 $W(\\mathbf{A})$ 跨入右半平面，就有可能找到一个投影子空间（基 $\\mathbf{Q}$），使得 $\\mathbf{A}_r$ 具有正实部的特征值，从而导致降阶模型不稳定。\n\n该问题的构造旨在揭示这种病态情况。全阶模型是稳定的（$\\mathbf{A}$ 的特征值为 $\\{-0.1, -1.0\\}$）。强迫项 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$ 的选择使得全阶模型的稳态为 $\\mathbf{x}_{\\infty} = \\mathbf{q}$，其中 $\\mathbf{q}$ 是与 $\\mathbf{S}$ 最大特征值相对应的特征向量。这将系统动态推向最大瞬态增长的方向。由此产生的快照将由该方向主导，导致主POD模态（$\\mathbf{Q}$ 的第一列）与 $\\mathbf{q}$ 对齐。对于秩为1的降阶模型（$r=1$），降阶矩阵 $\\mathbf{A}_r$ 变为一个标量 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。如果 $\\mathbf{Q} \\approx \\mathbf{q}$，则 $a_r \\approx \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top\\mathbf{S}\\mathbf{q} = \\lambda_{\\max}(\\mathbf{S})$。对于测试1和4中的非正规矩阵，$\\lambda_{\\max}(\\mathbf{S}) > 0$，从而导致降阶模型不稳定。\n\n每个测试案例的计算流程如下：\n$1$。定义系统参数：矩阵 $\\mathbf{A}$、降阶模型秩 $r$、以及时间域 $T_{\\text{train}}$ 和 $T_{\\text{test}}$。维度为 $n=2$，时间步长为 $h=10^{-3}$。\n$2$。构造强迫项：计算对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$。求其特征值和特征向量。设 $\\mathbf{q}$ 为与最大特征值对应的归一化特征向量。设置 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$。\n$3$。生成训练数据：使用经典的四阶龙格-库塔方法，在时间区间 $[0, T_{\\text{train}}]$ 上对全阶模型 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 从 $\\mathbf{x}(0)=\\mathbf{0}$ 开始进行积分。每个时间步的状态被收集到快照矩阵 $\\mathbf{X}$ 中。\n$4$。计算POD基：对快照矩阵 $\\mathbf{X}$ 执行奇异值分解（SVD），$\\mathbf{X} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的POD基 $\\mathbf{Q}$ 由 $\\mathbf{U}$ 的前 $r$ 列构成。\n$5$。计算重构误差：相对弗罗贝尼乌斯范数误差计算为 $\\varepsilon_{\\text{rec}} = \\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F / \\lVert \\mathbf{X}\\rVert_F$。\n$6$。构建降阶模型：降阶系统矩阵为 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 和 $\\mathbf{b}_r = \\mathbf{Q}^\\top\\mathbf{b}$。\n$7$。进行测试的时间积分：全阶模型和降阶模型都从零初始条件（$\\mathbf{x}(0)=\\mathbf{0}$，$\\mathbf{z}(0)=\\mathbf{0}$）开始，在区间 $[0, T_{\\text{test}}]$ 上进行积分。在积分过程中，每一步都将状态向量的欧几里得范数与爆破阈值 $M=10^6$ 进行比较。\n$8$。记录结果：该测试的最终输出是计算出的 $\\varepsilon_{\\text{rec}}$、一个指示降阶模型是否爆破的布尔值，以及一个指示全阶模型是否爆破的布尔值。\n\n各测试的预期结果：\n- **测试1**：（$\\mathbf{A}$ 非正规， $r=1$）：$\\mathbf{A}$ 是稳定的。$\\mathbf{b}$ 的构造和 $r=1$ 的选择旨在产生一个不稳定的降阶模型。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，降阶模型发生爆破，而全阶模型不发生爆破。\n- **测试2**：（$\\mathbf{A}$ 非正规， $r=2$）：此处，$r=n=2$。POD基 $\\mathbf{Q}$ 将是 $\\mathbb{R}^2$ 的一个完备标准正交基。因此，$\\mathbf{Q}\\mathbf{Q}^\\top = \\mathbf{I}$，这意味着重构误差 $\\varepsilon_{\\text{rec}}$ 将为零（或在机器精度量级）。降阶模型在动力学上等价于全阶模型，只是在不同的基中表示。由于全阶模型是稳定的，降阶模型也将是稳定的。我们预期 $\\varepsilon_{\\text{rec}} \\approx 0$，降阶模型不发生爆破，全阶模型也不发生爆破。\n- **测试3**：（$\\mathbf{A}$ 对称， $r=1$）：$\\mathbf{A}$ 是一个正规矩阵。其数值范围是其特征值的凸包，即 $\\{-1.0, -2.0\\}$。因此，数值范围是实轴上的区间 $[-2.0, -1.0]$。降阶算子 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 必须为负。降阶模型将是稳定的。我们预期两个模型都不会发生爆破。\n- **测试4**：（$\\mathbf{A}$ 更高度非正规， $r=1$）：与测试1类似，但具有更大的非对角项 $\\alpha=120.0$。这增加了非正规性，导致 $\\mathbf{S}$ 有一个更大的正特征值。降阶模型的不稳定性应该更加显著。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，降阶模型发生爆破，而全阶模型不发生爆破。\n\n现在将实现上述逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to demonstrate ROM instability\n    for a stable FOM.\n    \"\"\"\n\n    def rk4_step(f, y, h, A, b):\n        \"\"\"A single step of the classical fourth-order Runge-Kutta method.\"\"\"\n        k1 = f(y, A, b)\n        k2 = f(y + h / 2 * k1, A, b)\n        k3 = f(y + h / 2 * k2, A, b)\n        k4 = f(y + h * k3, A, b)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def lti_rhs(y, A, b):\n        \"\"\"RHS of the LTI system dy/dt = Ay + b.\"\"\"\n        return A @ y + b\n\n    def simulate(A, b, y0, T, h, M):\n        \"\"\"\n        Simulates an LTI system and returns snapshots and blow-up status.\n        \"\"\"\n        num_steps = int(T / h)\n        y = y0.copy()\n        snapshots = [y0.copy()]\n        blew_up = False\n        \n        for _ in range(num_steps):\n            y = rk4_step(lti_rhs, y, h, A, b)\n            if not blew_up and (np.linalg.norm(y) > M or not np.all(np.isfinite(y))):\n                blew_up = True\n            snapshots.append(y.copy())\n            \n        return np.array(snapshots).T, blew_up\n\n    # General parameters\n    n = 2\n    h = 1e-3\n    M = 1e6\n    x0 = np.zeros(n)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (A_params, r, T_train, T_test)\n        ({\"alpha\": 50.0}, 1, 4.0, 1.0),\n        ({\"alpha\": 50.0}, 2, 4.0, 1.0),\n        ({\"alpha\": None}, 1, 4.0, 1.0), # Symmetric case\n        ({\"alpha\": 120.0}, 1, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for i, (params, r, T_train, T_test) in enumerate(test_cases):\n        # 1. Define A\n        if i == 2: # Test 3: Symmetric case\n            A = np.array([[-1.0, 0.0], [0.0, -2.0]])\n        else: # Tests 1, 2, 4: Non-normal case\n            alpha = params[\"alpha\"]\n            A = np.array([[-0.1, alpha], [0.0, -1.0]])\n\n        # 2. Construct b\n        S = 0.5 * (A + A.T)\n        eigvals, eigvecs = eigh(S)\n        q = eigvecs[:, -1] # Dominant eigenvector (eigh sorts eigenvalues)\n        b = -A @ q\n\n        # 3. Generate FOM snapshots for training\n        X, _ = simulate(A, b, x0, T_train, h, M)\n\n        # 4. Compute POD basis Q\n        U, s, _ = np.linalg.svd(X, full_matrices=False)\n        Q = U[:, :r]\n\n        # 5. Calculate reconstruction error\n        # eps_rec = norm(X - Q @ Q.T @ X) / norm(X)\n        # Using singular values is more direct: sqrt(sum(s_i^2 for i>r)) / sqrt(sum(s_i^2))\n        if X.shape[1] > 1:\n         norm_X_sq = np.sum(s**2)\n         if norm_X_sq > 0:\n            norm_err_sq = np.sum(s[r:]**2)\n            eps_rec = np.sqrt(norm_err_sq / norm_X_sq)\n         else:\n            eps_rec = 0.0\n        else:\n            eps_rec = 0.0\n\n\n        # 6. Form the ROM\n        Ar = Q.T @ A @ Q\n        br = Q.T @ b\n        z0 = np.zeros(r)\n\n        # 7. Simulate FOM and ROM for testing, check blow-up\n        _, fom_blew_up = simulate(A, b, x0, T_test, h, M)\n        _, rom_blew_up = simulate(Ar, br, z0, T_test, h, M)\n\n        # 8. Record results\n        results.append([round(eps_rec, 6), rom_blew_up, fom_blew_up])\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase 'true'/'false' for JS-like format\n    formatted_results = []\n    for res in results:\n        eps_str = f\"{res[0]:.6f}\"\n        rom_bool_str = str(res[1]).lower()\n        fom_bool_str = str(res[2]).lower()\n        formatted_results.append(f\"[{eps_str},{rom_bool_str},{fom_bool_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}