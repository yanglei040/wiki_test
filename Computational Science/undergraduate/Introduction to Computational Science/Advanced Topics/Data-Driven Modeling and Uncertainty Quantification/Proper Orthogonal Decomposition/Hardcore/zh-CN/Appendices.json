{
    "hands_on_practices": [
        {
            "introduction": "在深入研究数据矩阵和数值算法之前，理解POD在其原始的连续函数空间中的定义至关重要。本练习  要求您为一个简单的时空场函数解析地推导出其POD模态，将POD模态直接与空间相关算符的本征函数联系起来。这种“纸笔”练习将为您构建坚实的理论基础。",
            "id": "3265890",
            "problem": "考虑空间域 $x \\in [0,1]$，其空间内积由 $\\langle f, g \\rangle = \\int_{0}^{1} f(x) g(x) \\, dx$ 给出，时间系综平均由长时间均值 $\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} (\\cdot) \\, dt$ 定义。设时空场为\n$$\nu(x,t) = \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t),\n$$\n其中 $\\omega_{1} > 0$ 和 $\\omega_{2} > 0$ 是不同的实常数。使用本征正交分解（POD）的基本定义，其中空间POD模态是空间相关算子\n$$\n\\mathcal{C}[\\phi](x) = \\int_{0}^{1} C(x,y) \\, \\phi(y) \\, dy,\n$$\n的特征函数，该算子由相关核\n$$\nC(x,y) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} u(x,t) \\, u(y,t) \\, dt,\n$$\n构造，请推导与 $u(x,t)$ 相关的解析空间POD模态。将模态表示为 $L^{2}([0,1])$-归一化函数。您的最终答案必须将两个归一化的空间POD模态列在一个单行矩阵中。不需要单位，也无需四舍五入。",
            "solution": "该问题要求推导给定一特定时空场 $u(x,t)$ 的空间本征正交分解（POD）模态。根据定义，空间POD模态（记为 $\\phi(x)$）是空间两点相关算子 $\\mathcal{C}$ 的特征函数，该算子是一个以 $C(x,y)$ 为核的积分算子。特征问题由下式给出：\n$$\n\\mathcal{C}[\\phi](x) = \\int_{0}^{1} C(x,y) \\, \\phi(y) \\, dy = \\lambda \\phi(x)\n$$\n核 $C(x,y)$ 定义为场在两个空间位置 $x$ 和 $y$ 处乘积的时间平均值。\n$$\nC(x,y) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} u(x,t) \\, u(y,t) \\, dt\n$$\n第一步是计算给定场 $u(x,t) = \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t)$ 的核。\n\n我们展开乘积 $u(x,t) \\, u(y,t)$：\n\\begin{align*}\nu(x,t) \\, u(y,t) =  \\left[ \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t) \\right] \\left[ \\sin(2\\pi y) \\cos(\\omega_{1} t) + \\sin(3\\pi y) \\cos(\\omega_{2} t) \\right] \\\\\n=  \\sin(2\\pi x) \\sin(2\\pi y) \\cos^2(\\omega_{1} t) \\\\\n + \\sin(3\\pi x) \\sin(3\\pi y) \\cos^2(\\omega_{2} t) \\\\\n + \\sin(2\\pi x) \\sin(3\\pi y) \\cos(\\omega_{1} t) \\cos(\\omega_{2} t) \\\\\n + \\sin(3\\pi x) \\sin(2\\pi y) \\cos(\\omega_{1} t) \\cos(\\omega_{2} t)\n\\end{align*}\n为了求得 $C(x,y)$，我们必须计算时间分量的长时间平均值。我们需要以下关于谐波函数的标准时间平均结果：\n$1$. 对于任意非零频率 $\\omega > 0$，\n$$\n\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega t) \\, dt = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\frac{1 + \\cos(2\\omega t)}{2} \\, dt = \\lim_{T \\to \\infty} \\frac{1}{T} \\left[ \\frac{t}{2} + \\frac{\\sin(2\\omega t)}{4\\omega} \\right]_{0}^{T} = \\frac{1}{2}\n$$\n$2$. 对于两个不同的正频率 $\\omega_1 \\neq \\omega_2$，\n$$\n\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos(\\omega_1 t) \\cos(\\omega_2 t) \\, dt = \\lim_{T \\to \\infty} \\frac{1}{2T} \\int_{0}^{T} \\left[ \\cos((\\omega_1 - \\omega_2)t) + \\cos((\\omega_1 + \\omega_2)t) \\right] dt = 0\n$$\n第二个结果成立，因为余弦函数在一个周期内的积分为零，其不定积分是一个有界的正弦函数。除以 $T \\to \\infty$ 使得平均值趋于 $0$。\n\n将这些时间平均应用于展开的乘积，包含 $\\cos(\\omega_{1} t) \\cos(\\omega_{2} t)$ 的交叉项的平均值为零。我们剩下：\n\\begin{align*}\nC(x,y) = \\sin(2\\pi x) \\sin(2\\pi y) \\left( \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega_{1} t) \\, dt \\right) + \\sin(3\\pi x) \\sin(3\\pi y) \\left( \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega_{2} t) \\, dt \\right) \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y)\n\\end{align*}\n这是一个秩为2的可分核。具有此类核的算子的特征函数必须位于构成该核的函数所张成的空间中，即 $\\text{span}\\{\\sin(2\\pi x), \\sin(3\\pi x)\\}$。\n\n我们来检验基函数 $\\psi_1(x) = \\sin(2\\pi x)$ 和 $\\psi_2(x) = \\sin(3\\pi x)$ 在给定的内积 $\\langle f, g \\rangle = \\int_{0}^{1} f(x) g(x) \\, dx$ 下是否正交：\n$$\n\\langle \\psi_1, \\psi_2 \\rangle = \\int_{0}^{1} \\sin(2\\pi x) \\sin(3\\pi x) \\, dx = \\frac{1}{2} \\int_{0}^{1} \\left[ \\cos(\\pi x) - \\cos(5\\pi x) \\right] dx = \\frac{1}{2} \\left[ \\frac{\\sin(\\pi x)}{\\pi} - \\frac{\\sin(5\\pi x)}{5\\pi} \\right]_{0}^{1} = 0\n$$\n由于空间函数是正交的，它们确实是相关算子 $\\mathcal{C}$ 的特征函数。我们可以通过将它们代入特征问题来验证这一点。\n\n对于第一个候选特征函数 $\\phi(x) = \\psi_1(x) = \\sin(2\\pi x)$：\n\\begin{align*}\n\\mathcal{C}[\\psi_1](x) = \\int_{0}^{1} \\left[ \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y) \\right] \\sin(2\\pi y) \\, dy \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\int_{0}^{1} \\sin^2(2\\pi y) \\, dy + \\frac{1}{2} \\sin(3\\pi x) \\int_{0}^{1} \\sin(3\\pi y) \\sin(2\\pi y) \\, dy\n\\end{align*}\n由于正交性，第二个积分为零。第一个积分为：\n$$\n\\int_{0}^{1} \\sin^2(2\\pi y) \\, dy = \\int_{0}^{1} \\frac{1 - \\cos(4\\pi y)}{2} \\, dy = \\left[ \\frac{y}{2} - \\frac{\\sin(4\\pi y)}{8\\pi} \\right]_{0}^{1} = \\frac{1}{2}\n$$\n因此，$\\mathcal{C}[\\psi_1](x) = \\frac{1}{2} \\sin(2\\pi x) \\cdot \\frac{1}{2} = \\frac{1}{4} \\sin(2\\pi x)$。\n所以，$\\phi_1(x) = \\sin(2\\pi x)$ 是一个特征函数，其特征值为 $\\lambda_1 = \\frac{1}{4}$。\n\n对于第二个候选特征函数 $\\phi(x) = \\psi_2(x) = \\sin(3\\pi x)$：\n\\begin{align*}\n\\mathcal{C}[\\psi_2](x) = \\int_{0}^{1} \\left[ \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y) \\right] \\sin(3\\pi y) \\, dy \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\int_{0}^{1} \\sin(2\\pi y) \\sin(3\\pi y) \\, dy + \\frac{1}{2} \\sin(3\\pi x) \\int_{0}^{1} \\sin^2(3\\pi y) \\, dy\n\\end{align*}\n第一个积分为零。第二个积分为：\n$$\n\\int_{0}^{1} \\sin^2(3\\pi y) \\, dy = \\int_{0}^{1} \\frac{1 - \\cos(6\\pi y)}{2} \\, dy = \\left[ \\frac{y}{2} - \\frac{\\sin(6\\pi y)}{12\\pi} \\right]_{0}^{1} = \\frac{1}{2}\n$$\n因此，$\\mathcal{C}[\\psi_2](x) = \\frac{1}{2} \\sin(3\\pi x) \\cdot \\frac{1}{2} = \\frac{1}{4} \\sin(3\\pi x)$。\n所以，$\\phi_2(x) = \\sin(3\\pi x)$ 是一个特征函数，其特征值为 $\\lambda_2 = \\frac{1}{4}$。\n\n最后一步是将这些特征函数归一化，使其具有单位 $L^2$ 范数。特征函数 $\\phi$ 的范数平方为 $\\|\\phi\\|^2 = \\langle \\phi, \\phi \\rangle = \\int_{0}^{1} \\phi(x)^2 \\, dx$。\n对于第一个模态，$\\sin(2\\pi x)$：\n$$\n\\|\\sin(2\\pi x)\\|^2 = \\int_{0}^{1} \\sin^2(2\\pi x) \\, dx = \\frac{1}{2}\n$$\n归一化常数为 $1 / \\sqrt{1/2} = \\sqrt{2}$。第一个归一化的POD模态是 $\\hat{\\phi_1}(x) = \\sqrt{2} \\sin(2\\pi x)$。\n\n对于第二个模态，$\\sin(3\\pi x)$：\n$$\n\\|\\sin(3\\pi x)\\|^2 = \\int_{0}^{1} \\sin^2(3\\pi x) \\, dx = \\frac{1}{2}\n$$\n归一化常数也是 $\\sqrt{2}$。第二个归一化的POD模态是 $\\hat{\\phi_2}(x) = \\sqrt{2} \\sin(3\\pi x)$。\n\n因此，两个非平凡的空间POD模态是 $\\sqrt{2} \\sin(2\\pi x)$ 和 $\\sqrt{2} \\sin(3\\pi x)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\sqrt{2}\\sin(2\\pi x) & \\sqrt{2}\\sin(3\\pi x)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在实际应用中，POD通常是通过对快照矩阵进行奇异值分解（SVD）来实现的。本练习  是一个思想实验，旨在阐明矩阵的结构、秩以及POD所揭示的奇异值之间的根本关系。通过构建一个已知秩的矩阵，您将亲眼见证SVD如何精确地识别出数据内在的维度。",
            "id": "3265930",
            "problem": "考虑一个在通过本征正交分解（POD）进行降阶建模中使用的快照矩阵 $X \\in \\mathbb{R}^{100 \\times 50}$。通过选择三个标准正交空间向量 $u_1, u_2, u_3 \\in \\mathbb{R}^{100}$，三个标准正交时间向量 $v_1, v_2, v_3 \\in \\mathbb{R}^{50}$，以及三个正标量 $\\sigma_1, \\sigma_2, \\sigma_3$ 来构造 $X$。令空间向量为前三个标准基向量，$u_1 = e_1$, $u_2 = e_2$, $u_3 = e_3$，其中 $e_i \\in \\mathbb{R}^{100}$ 在第 $i$ 个位置为 1，其余位置为 0。令时间向量为前三个标准基向量，$v_1 = e_1$, $v_2 = e_2$, $v_3 = e_3$，其中 $e_i \\in \\mathbb{R}^{50}$ 在第 $i$ 个位置为 1，其余位置为 0。选择奇异值为 $\\sigma_1 = 6$，$\\sigma_2 = 3$ 和 $\\sigma_3 = 1$。将快照矩阵定义为秩为 3 的外积之和\n$$\nX \\;=\\; \\sigma_1 \\, u_1 v_1^{\\top} \\;+\\; \\sigma_2 \\, u_2 v_2^{\\top} \\;+\\; \\sigma_3 \\, u_3 v_3^{\\top}.\n$$\n仅使用奇异值分解和矩阵秩的基本定义，确定将本征正交分解（POD）应用于 $X$ 所恢复的非零奇异值的数量。将最终答案表示为单个整数。",
            "solution": "该问题要求确定给定矩阵 $X$ 的非零奇异值的数量，该矩阵的构造方式与本征正交分解（POD）相关。\n\n首先，让我们建立基本原理。对于任何实矩阵 $X \\in \\mathbb{R}^{m \\times n}$，奇异值分解（SVD）提供了一种形式为 $X = U \\Sigma V^{\\top}$ 的分解。这里，$U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，而 $\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵。$\\Sigma$ 的对角线元素，记为 $\\sigma_i$，是 $X$ 的奇异值。它们是非负的，并且通常按 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_p \\ge 0$ 的顺序排列，其中 $p = \\min(m, n)$。\n\nSVD 也可以表示为秩为 1 的外积之和：\n$$\nX = \\sum_{i=1}^{r} \\sigma_i u_i v_i^{\\top}\n$$\n其中 $r$ 是矩阵 $X$ 的秩。向量 $u_i \\in \\mathbb{R}^m$ 是 $U$ 的列（左奇异向量），并形成一个标准正交集，即 $u_i^{\\top} u_j = \\delta_{ij}$。向量 $v_i \\in \\mathbb{R}^n$ 是 $V$ 的列（右奇异向量），也形成一个标准正交集，即 $v_i^{\\top} v_j = \\delta_{ij}$。标量 $\\sigma_i > 0$（对于 $i=1, \\dots, r$）是 $X$ 的非零奇异值。根据定义，非零奇异值的数量就是矩阵的秩。\n\n问题陈述了将本征正交分解（POD）应用于快照矩阵 $X$。在数值线性代数的框架内，POD（特别是使用快照法）在数学上等同于快照矩阵的 SVD。这个过程恢复了左奇异向量 $u_i$（POD 模态）、右奇异向量 $v_i$（时间模态）和奇异值 $\\sigma_i$。因此，恢复的非零奇异值的数量就是 $X$ 的秩。\n\n快照矩阵 $X \\in \\mathbb{R}^{100 \\times 50}$ 定义为：\n$$\nX = \\sigma_1 u_1 v_1^{\\top} + \\sigma_2 u_2 v_2^{\\top} + \\sigma_3 u_3 v_3^{\\top}\n$$\n我们被给予了以下定义：\n1.  标量为 $\\sigma_1 = 6$，$\\sigma_2 = 3$ 和 $\\sigma_3 = 1$。这些都是正数。\n2.  空间向量为 $u_1 = e_1$, $u_2 = e_2$, $u_3 = e_3$，其中 $e_i \\in \\mathbb{R}^{100}$ 是标准基向量。集合 $\\{u_1, u_2, u_3\\}$ 是一个标准正交集，因为对于 $i, j \\in \\{1, 2, 3\\}$，$e_i^{\\top}e_j = \\delta_{ij}$。\n3.  时间向量为 $v_1 = e_1$, $v_2 = e_2$, $v_3 = e_3$，其中 $e_i \\in \\mathbb{R}^{50}$ 是标准基向量。集合 $\\{v_1, v_2, v_3\\}$ 也是一个标准正交集。\n\n给定的 $X$ 的表达式完全匹配 SVD 外积展开的结构。我们有一个三项之和。每一项都是一个正标量 $\\sigma_i$、一个单位向量 $u_i$ 和一个单位向量 $v_i$ 的转置的乘积。向量集合 $\\{u_1, u_2, u_3\\}$ 和 $\\{v_1, v_2, v_3\\}$ 都是标准正交的。\n\n这意味着所提供的表达式实际上就是 $X$ 的奇异值分解。$X$ 的非零奇异值正是给定的标量：$\\sigma_1 = 6$，$\\sigma_2 = 3$ 和 $\\sigma_3 = 1$。所有其他的奇异值，即对于 $i > 3$ 的 $\\sigma_i$，都为零。\n\n问题要求的是将 POD 应用于 $X$ 所恢复的非零奇异值的*数量*。根据我们的分析，恰好有三个正奇异值。因此，非零奇异值的数量是 $3$。这也是矩阵 $X$ 的秩。\n\n这个问题是对奇异值分解的基本定义及其与矩阵秩的关系的直接检验。矩阵 $X$ 的构造是通过其 SVD 展开刻意构造一个秩为 3 的矩阵。不需要进一步的计算。在给定标量非零且向量集为标准正交的情况下，和中的项数直接给出了答案。\n非零奇异值的数量是 $3$。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "对于空间分辨率很高的大规模科学计算问题，“快照法”（method of snapshots）是计算POD的标准高效算法。这个综合性的编程练习  将指导您实现该方法来分析合成数据集。您将处理诸如移除均值、计算模态能量、评估重构误差以及确定数据数值秩等实际任务。",
            "id": "3266011",
            "problem": "您的任务是使用快照法（method of snapshots）为在一系列网格上表示的空间场序列实现本征正交分解（Proper Orthogonal Decomposition, POD），此场景下网格点数远大于快照数。快照法的基本原理是，POD 在空间域中寻找一个标准正交基，该基在标准欧几里得内积下能够最小化快照集合的均方重构误差。数据被组织成一个矩阵，其列是不同时间的场快照。在构建分解之前，应移除快照间的样本平均场。该方法通过在快照空间中求解特征值问题来降低其维度。三角函数中使用的所有角度都必须是弧度。\n\n构建一个程序，用于建立以下合成数据集的测试套件，并使用快照法计算从 POD 导出的量。对于每个数据集，令 $X \\in \\mathbb{R}^{m \\times n}$ 表示数据矩阵，其列是在区间 $[0,1]$ 上的均匀网格 $x_i$ 上采样的快照 $x^{(j)} \\in \\mathbb{R}^{m}$。对于每个数据集，减去快照间的样本平均场，即对于每个空间坐标 $i$，从 $X_{i,j}$ 中减去在 $j$ 上的平均值，得到一个去均值矩阵 $X_c$。然后构建快照空间矩阵 $S = X_c^{\\top} X_c$。通过求解 $S$ 的对称特征值问题来实现 POD，将特征值从大到小排序，并形成相应的空间模态。所有计算必须是确定性的，并且只能使用指定的环境。以下数据集通过显式公式定义 $X$；所有三角函数参数均为弧度。\n\n- 测试用例 1（一般高瘦情况）：$m = 200$， $n = 5$。令 $x_i = \\frac{i}{m-1}$ 对于 $i \\in \\{0,1,\\dots,m-1\\}$，$t_j = j$ 对于 $j \\in \\{0,1,\\dots,n-1\\}$。定义空间模式 $\\phi_1(x) = \\sin(\\pi x)$ 和 $\\phi_2(x) = \\cos(2\\pi x)$。对于每个快照 $j$，设置\n$$\nx^{(j)}(x) = 3\\,\\phi_1(x)\\left(1 + 0.5\\cos(0.8 t_j)\\right) + 1.5\\,\\phi_2(x)\\left(0.5\\sin(1.2 t_j)\\right) + 0.05\\,\\sin(5\\pi x)\\cos(2.3 t_j).\n$$\n计算使累积捕获能量（$S$ 的前导特征值之和除以 $S$ 的所有特征值之和）至少为 $0.95$ 所需的最小 POD 模态数。以整数形式输出此数字。\n\n- 测试用例 2（主导的第一模态）：$m = 300$， $n = 3$。令 $x_i = \\frac{i}{m-1}$ 和 $t_j = j$。定义 $\\phi_d(x) = \\sin(\\pi x)$ 和 $\\phi_s(x) = \\cos(3\\pi x)$。对于每个 $j$，设置\n$$\nx^{(j)}(x) = 4\\,\\phi_d(x)\\left(1.1 + 0.9\\sin(0.5 t_j)\\right) + 0.6\\,\\phi_s(x)\\left(\\cos(0.8 t_j)\\right).\n$$\n计算第一个 POD 模态捕获的能量分数，定义为 $S$ 的最大特征值除以 $S$ 的所有特征值之和。以浮点数形式输出此值。\n\n- 测试用例 3（使用两个模态的重构误差）：$m = 50$， $n = 10$。令 $x_i = \\frac{i}{m-1}$ 和 $t_j = j$。定义 $\\phi_1(x) = \\sin(2\\pi x)$，$\\phi_2(x) = \\cos(\\pi x)$ 和 $\\phi_3(x) = \\sin(4\\pi x)$。对于每个 $j$，设置\n$$\nx^{(j)}(x) = 2\\,\\phi_1(x)\\sin(0.7 t_j) + 1.5\\,\\phi_2(x)\\cos(1.1 t_j) + 0.3\\,\\phi_3(x)\\sin(0.9 t_j).\n$$\n使用从 $S$ 计算出的前 2 个 POD 模态，通过将 $X_c$ 投影到前两个空间模态的张成空间上，形成去均值数据的秩-2 重构，并计算相对重构误差，定义为\n$$\n\\frac{\\lVert X_c - X_{c,2} \\rVert_F}{\\lVert X_c \\rVert_F},\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数，$X_{c,2}$ 是 $X_c$ 在前两个模态上的投影。以浮点数形式输出此值。\n\n- 测试用例 4（退化快照，秩测试）：$m = 400$， $n = 6$。令 $x_i = \\frac{i}{m-1}$。显式地将快照构造为列：\n$$\nx^{(0)}(x) = \\sin(\\pi x) + \\cos(2\\pi x), \\quad\nx^{(1)}(x) = 2\\sin(2\\pi x) - 0.5\\cos(3\\pi x), \\quad\nx^{(2)}(x) = x^{(1)}(x), \\\\\nx^{(3)}(x) = 0.7\\sin(3\\pi x) + 0.1\\cos(\\pi x), \\quad\nx^{(4)}(x) = x^{(0)}(x), \\quad\nx^{(5)}(x) = 1.3\\sin(4\\pi x) - 0.9\\cos(2\\pi x).\n$$\n在对快照进行均值移除后，通过计算 $S$ 的严格正特征值的数量来计算 $X_c$ 的数值秩，使用的相对容差定义为：如果一个特征值大于 $S$ 的最大特征值的 $10^{-10}$ 倍，则将其标记为非零。以整数形式输出此秩。\n\n您的程序应生成一行输出，其中包含四个测试用例的结果，形式为逗号分隔的列表，并用方括号括起来（例如，$[result_1,result_2,result_3,result_4]$）。这四个结果必须按顺序为：测试用例 1 的整数模态数，测试用例 2 中第一个模态的浮点数能量分数，测试用例 3 的浮点数相对重构误差，以及测试用例 4 的整数秩。",
            "solution": "该问题要求对几个合成数据集通过快照法实现本征正交分解（POD）。该方法的核心是分析一系列快照（不同时间实例的空间数据场），以找到一个能够最优地捕获数据方差的低维基。\n\n设数据组织在一个矩阵 $X \\in \\mathbb{R}^{m \\times n}$ 中，其中 $m$ 是空间网格点的数量，$n$ 是快照的数量。$X$ 的第 $j$ 列是在时间 $t_j$ 的快照向量 $x^{(j)} \\in \\mathbb{R}^{m}$。问题规定网格点数远大于快照数，即 $m \\gg n$。\n\n规定的 POD 过程如下：\n$1$. **数据中心化**：第一步是从快照中移除时间平均值。平均快照计算为 $\\bar{x} = \\frac{1}{n} \\sum_{j=0}^{n-1} x^{(j)}$。通过从 $X$ 的每一列中减去 $\\bar{x}$ 来形成一个去均值的数据矩阵 $X_c$。$X_c$ 的列是 $x_c^{(j)} = x^{(j)} - \\bar{x}$。\n$2$. **快照法**：直接的 POD 方法需要为 $m \\times m$ 的空间协方差矩阵 $C = X_c X_c^\\top$ 求解一个特征值问题。当 $m \\gg n$ 时，这在计算上是不可行的。快照法通过在较小的快照空间中求解一个特征值问题来规避此问题。我们构建 $n \\times n$ 的快照矩阵（或格拉姆矩阵）$S = X_c^\\top X_c$。\n$3$. **特征值问题**：我们求解 $S$ 的对称特征值问题：\n$$\nS v_k = \\lambda_k v_k, \\quad \\text{for } k = 1, \\dots, n.\n$$\n$S$ 的特征值 $\\lambda_k$ 是较大协方差矩阵 $C$ 的非零特征值。这些特征值按降序排列 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_n \\ge 0$，代表每个相应模态捕获的能量或方差。去均值数据的总能量（方差）由 $S$ 的迹给出，它等于其特征值之和：$\\sum_{k=1}^n \\lambda_k = \\text{tr}(S) = \\lVert X_c \\rVert_F^2$。\n$4$. **POD 模态**：空间 POD 模态 $\\Psi_k \\in \\mathbb{R}^m$ 可以通过关系式 $\\Psi_k = \\frac{1}{\\sqrt{\\lambda_k}} X_c v_k$ 从 $S$ 的特征向量 $v_k$ 构建。这些模态构成了空间数据的标准正交基。\n\n现在我们将此框架应用于所提供的四个测试用例。\n\n**测试用例 1：累积能量**\n数据集定义为 $m = 200$ 和 $n = 5$。快照在空间网格 $x_i = \\frac{i}{m-1}$（$i \\in \\{0, \\dots, 199\\}$）和时间 $t_j = j$（$j \\in \\{0, \\dots, 4\\}$）上生成。快照公式为：\n$$\nx^{(j)}(x) = 3 \\sin(\\pi x) \\left(1 + 0.5\\cos(0.8 t_j)\\right) + 0.75 \\cos(2\\pi x) \\sin(1.2 t_j) + 0.05 \\sin(5\\pi x)\\cos(2.3 t_j).\n$$\n在构建数据矩阵 $X$ 及其中心化版本 $X_c$ 后，我们计算快照矩阵 $S = X_c^\\top X_c$ 及其特征值 $\\lambda_1, \\dots, \\lambda_5$，并按降序排序。前 $k$ 个模态捕获的累积能量是特征值部分和与总和的比率：\n$$\nE_k = \\frac{\\sum_{i=1}^k \\lambda_i}{\\sum_{i=1}^5 \\lambda_i}.\n$$\n我们需要找到使 $E_k \\ge 0.95$ 的最小整数 $k$。这通过计算排序后特征值的累积和并对 $k = 1, 2, \\dots, 5$ 检查条件来完成。\n\n**测试用例 2：主导模态能量**\n数据集有 $m = 300$ 和 $n = 3$。快照在网格 $x_i = \\frac{i}{m-1}$ 和时间 $t_j=j$（$j \\in \\{0, 1, 2\\}$）上生成，使用公式：\n$$\nx^{(j)}(x) = 4 \\sin(\\pi x) \\left(1.1 + 0.9\\sin(0.5 t_j)\\right) + 0.6 \\cos(3\\pi x) \\cos(0.8 t_j).\n$$\n遵循 POD 过程，我们计算 $3 \\times 3$ 快照矩阵 $S$ 的特征值 $\\lambda_1, \\lambda_2, \\lambda_3$。第一个（最主导的）POD 模态捕获的能量分数由以下公式给出：\n$$\n\\frac{\\lambda_1}{\\sum_{i=1}^3 \\lambda_i}.\n$$\n该值将被计算并作为浮点数输出。\n\n**测试用例 3：重构误差**\n此用例使用 $m = 50$ 和 $n = 10$。在时间 $t_j=j$（$j \\in \\{0, \\dots, 9\\}$）的快照由以下公式给出：\n$$\nx^{(j)}(x) = 2 \\sin(2\\pi x) \\sin(0.7 t_j) + 1.5 \\cos(\\pi x) \\cos(1.1 t_j) + 0.3 \\sin(4\\pi x) \\sin(0.9 t_j).\n$$\n我们计算 $10 \\times 10$ 矩阵 $S$ 的特征值 $\\lambda_1, \\dots, \\lambda_{10}$。$X_c$ 的秩-$k$ POD 近似表示为 $X_{c,k}$。重构误差的弗罗贝尼乌斯范数平方是忽略的特征值之和：\n$$\n\\lVert X_c - X_{c,k} \\rVert_F^2 = \\sum_{i=k+1}^n \\lambda_i.\n$$\n总能量，或 $X_c$ 的弗罗贝尼乌斯范数平方是 $\\lVert X_c \\rVert_F^2 = \\sum_{i=1}^n \\lambda_i$。因此，秩-2 近似（$k=2$）的相对重构误差为：\n$$\n\\text{Error} = \\frac{\\lVert X_c - X_{c,2} \\rVert_F}{\\lVert X_c \\rVert_F} = \\sqrt{\\frac{\\sum_{i=3}^{10} \\lambda_i}{\\sum_{i=1}^{10} \\lambda_i}}.\n$$\n该值将被计算并作为浮点数输出。\n\n**测试用例 4：数值秩**\n此用例有 $m = 400$，$n = 6$。快照被明确定义，有两对相同的快照：$x^{(2)} = x^{(1)}$ 和 $x^{(4)} = x^{(0)}$。$X$ 列中的这些线性相关性降低了其秩。均值中心化操作保留了这些相关性：$x_c^{(2)} = x_c^{(1)}$ 和 $x_c^{(4)} = x_c^{(0)}$。此外，$X_c$ 的列总和为零向量，引入了另一个线性相关性。因此，$X_c$ 的秩最多为 $n-1-2 = 3$。$X_c$ 的秩等于 $S=X_c^\\top X_c$ 的秩，即其非零特征值的数量。我们计算 $S$ 的特征值 $\\lambda_1, \\dots, \\lambda_6$。数值秩是通过使用相对容差计算有多少个特征值是严格正的来确定的。如果特征值 $\\lambda_k > 10^{-10} \\lambda_1$（其中 $\\lambda_1$ 是最大特征值），则认为它是非零的。我们将计算满足此条件的特征值的数量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef perform_pod_analysis(X):\n    \"\"\"\n    Performs POD analysis on a snapshot matrix X.\n\n    Args:\n        X (np.ndarray): The data matrix of shape (m, n), where m is the number of\n                        spatial points and n is the number of snapshots.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The mean-centered data matrix X_c.\n            - np.ndarray: A 1D array of eigenvalues of the snapshot matrix S,\n                          sorted in descending order.\n    \"\"\"\n    # Step 1: Mean removal\n    mean_field = X.mean(axis=1, keepdims=True)\n    X_c = X - mean_field\n\n    # Step 2: Form the snapshot matrix S\n    S = X_c.T @ X_c\n\n    # Step 3: Solve the eigenvalue problem for S\n    # np.linalg.eigh is used for symmetric matrices and returns eigenvalues in ascending order\n    eigenvalues = np.linalg.eigh(S)[0]\n\n    # Sort eigenvalues in descending order\n    eigenvalues = np.sort(eigenvalues)[::-1]\n    \n    # Ensure eigenvalues are non-negative due to potential floating point inaccuracies\n    eigenvalues[eigenvalues < 0] = 0\n\n    return X_c, eigenvalues\n\ndef solve_case1():\n    \"\"\"Calculates the minimal number of POD modes for >= 95% energy.\"\"\"\n    m = 200\n    n = 5\n    x = np.linspace(0, 1, m)\n    t = np.arange(n)\n\n    phi1 = np.sin(np.pi * x)\n    phi2 = np.cos(2 * np.pi * x)\n    noise_phi = np.sin(5 * np.pi * x)\n\n    time_dep1 = 3 * (1 + 0.5 * np.cos(0.8 * t))\n    time_dep2 = 1.5 * (0.5 * np.sin(1.2 * t))\n    noise_time_dep = 0.05 * np.cos(2.3 * t)\n\n    X = (phi1[:, np.newaxis] * time_dep1[np.newaxis, :] +\n         phi2[:, np.newaxis] * time_dep2[np.newaxis, :] +\n         noise_phi[:, np.newaxis] * noise_time_dep[np.newaxis, :])\n    \n    _, eigenvalues = perform_pod_analysis(X)\n    \n    total_energy = np.sum(eigenvalues)\n    if total_energy == 0:\n        return n\n        \n    cumulative_energy = np.cumsum(eigenvalues) / total_energy\n    \n    num_modes = np.searchsorted(cumulative_energy, 0.95, side='left') + 1\n    return int(num_modes)\n\ndef solve_case2():\n    \"\"\"Calculates the energy fraction of the first POD mode.\"\"\"\n    m = 300\n    n = 3\n    x = np.linspace(0, 1, m)\n    t = np.arange(n)\n\n    phi_d = np.sin(np.pi * x)\n    phi_s = np.cos(3 * np.pi * x)\n\n    time_dep_d = 4 * (1.1 + 0.9 * np.sin(0.5 * t))\n    time_dep_s = 0.6 * np.cos(0.8 * t)\n\n    X = (phi_d[:, np.newaxis] * time_dep_d[np.newaxis, :] +\n         phi_s[:, np.newaxis] * time_dep_s[np.newaxis, :])\n    \n    _, eigenvalues = perform_pod_analysis(X)\n    \n    total_energy = np.sum(eigenvalues)\n    if total_energy == 0:\n        return 0.0\n\n    energy_fraction = eigenvalues[0] / total_energy\n    return float(energy_fraction)\n\ndef solve_case3():\n    \"\"\"Calculates the relative reconstruction error with 2 modes.\"\"\"\n    m = 50\n    n = 10\n    x = np.linspace(0, 1, m)\n    t = np.arange(n)\n\n    phi1 = np.sin(2 * np.pi * x)\n    phi2 = np.cos(np.pi * x)\n    phi3 = np.sin(4 * np.pi * x)\n\n    time_dep1 = 2 * np.sin(0.7 * t)\n    time_dep2 = 1.5 * np.cos(1.1 * t)\n    time_dep3 = 0.3 * np.sin(0.9 * t)\n\n    X = (phi1[:, np.newaxis] * time_dep1[np.newaxis, :] +\n         phi2[:, np.newaxis] * time_dep2[np.newaxis, :] +\n         phi3[:, np.newaxis] * time_dep3[np.newaxis, :])\n\n    _, eigenvalues = perform_pod_analysis(X)\n    \n    num_modes_for_reconstruction = 2\n    \n    total_energy = np.sum(eigenvalues)\n    if total_energy == 0:\n        return 0.0\n        \n    neglected_energy = np.sum(eigenvalues[num_modes_for_reconstruction:])\n    \n    relative_error = np.sqrt(neglected_energy / total_energy)\n    return float(relative_error)\n\ndef solve_case4():\n    \"\"\"Calculates the numerical rank of the mean-centered data.\"\"\"\n    m = 400\n    n = 6\n    x = np.linspace(0, 1, m)\n    X = np.zeros((m, n))\n\n    X[:, 0] = np.sin(np.pi * x) + np.cos(2 * np.pi * x)\n    X[:, 1] = 2 * np.sin(2 * np.pi * x) - 0.5 * np.cos(3 * np.pi * x)\n    X[:, 2] = X[:, 1]\n    X[:, 3] = 0.7 * np.sin(3 * np.pi * x) + 0.1 * np.cos(np.pi * x)\n    X[:, 4] = X[:, 0]\n    X[:, 5] = 1.3 * np.sin(4 * np.pi * x) - 0.9 * np.cos(2 * np.pi * x)\n    \n    _, eigenvalues = perform_pod_analysis(X)\n    \n    if len(eigenvalues) == 0 or eigenvalues[0] == 0:\n        return 0\n        \n    tolerance = 1e-10 * eigenvalues[0]\n    numerical_rank = np.sum(eigenvalues > tolerance)\n    \n    return int(numerical_rank)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    result1 = solve_case1()\n    result2 = solve_case2()\n    result3 = solve_case3()\n    result4 = solve_case4()\n\n    results = [result1, result2, result3, result4]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}