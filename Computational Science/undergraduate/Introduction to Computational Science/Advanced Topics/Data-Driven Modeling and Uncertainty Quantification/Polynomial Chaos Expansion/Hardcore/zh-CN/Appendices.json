{
    "hands_on_practices": [
        {
            "introduction": "多项式混沌展开 (PCE) 为计算模型输出的统计量提供了一种强大的方法。第一个练习  将揭示一个基本而深刻的见解：我们感兴趣的量的期望值（均值）被展开式中的第一个系数（零阶系数）直接捕捉。我们将通过解析推导来证明这一点，从而为理解PCE的统计属性奠定坚实的基础。",
            "id": "3174309",
            "problem": "考虑一个标量输入随机变量 $\\xi$，其概率密度函数在区间 $[0,1]$ 上为 $p_{\\xi}(x)=1$，在其他情况下为 $p_{\\xi}(x)=0$，因此 $\\xi$ 在 $[0,1]$ 上均匀分布。定义非线性变换 $f(\\xi)=\\sin(a\\,\\xi)$，其中 $a>0$ 是一个固定参数。使用多项式混沌展开（PCE）框架，基函数为在权重 $p_{\\xi}(x)=1$ 下，$[0,1]$ 上的正交归一化移位 Legendre 多项式 $\\{\\phi_{n}(x)\\}_{n\\geq 0}$，完成以下任务：\n\n1. 从PCE的定义和基 $\\{\\phi_{n}\\}$ 相对于由 $p_{\\xi}$ 导出的内积的正交性出发，推导展开 $f(\\xi)$ 时与零阶模（常数基函数）相关的系数的表达式。\n2. 使用此系数，通过在多项式阶数3处截断的PCE来近似期望 $\\mathbb{E}[\\sin(a\\,\\xi)]$。\n3. 独立地，从第一性原理出发，使用期望作为关于 $p_{\\xi}$ 的积分的定义，推导 $\\mathbb{E}[\\sin(a\\,\\xi)]$ 的精确解析表达式。\n4. 当 $a=\\pi$ 时，计算所得期望，并以纯小数形式提供最终数值。\n\n将最终数值答案四舍五入到四位有效数字。不涉及物理单位。",
            "solution": "问题陈述已经过验证，被认为是可靠、适定且具有科学依据的。我们可以开始求解。\n\n该问题要求分析函数 $f(\\xi) = \\sin(a\\,\\xi)$，其中 $\\xi$ 是在区间 $[0, 1]$ 上均匀分布的随机变量。因此，$\\xi$ 的概率密度函数（PDF）为，当 $x \\in [0, 1]$ 时 $p_{\\xi}(x) = 1$，否则 $p_{\\xi}(x) = 0$。我们使用多项式混沌展开（PCE），其基为在 $[0,1]$ 上的正交归一化移位 Legendre 多项式 $\\{\\phi_n(x)\\}_{n \\ge 0}$。\n\n关于权重函数 $w(x) = p_{\\xi}(x) = 1$ 的内积定义为：\n$$ \\langle g, h \\rangle = \\int_{0}^{1} g(x) h(x) w(x) \\,dx = \\int_{0}^{1} g(x) h(x) \\,dx $$\n基函数的正交归一性意味着 $\\langle \\phi_n, \\phi_m \\rangle = \\delta_{nm}$，其中 $\\delta_{nm}$ 是 Kronecker delta。\n\n函数 $f(\\xi)$ 的PCE由以下级数展开给出：\n$$ f(\\xi) = \\sum_{n=0}^{\\infty} c_n \\phi_n(\\xi) $$\n其中系数 $c_n$ 通过将函数 $f$ 投影到基函数上确定：\n$$ c_n = \\langle f, \\phi_n \\rangle = \\int_{0}^{1} f(x) \\phi_n(x) \\,dx $$\n\n**1. 零阶系数($c_0$)的推导**\n\n第一个任务是找到系数 $c_0$ 的表达式，它对应于零阶基函数 $\\phi_0(x)$。零阶移位 Legendre 多项式是一个常数，我们将其标准（非归一化）多项式表示为 $P_0^*(x) = 1$。为了找到正交归一化基函数 $\\phi_0(x)$，我们必须对 $P_0^*(x)$ 进行归一化。设 $\\phi_0(x) = k$，其中 $k$ 为某个常数。归一化条件是 $\\langle \\phi_0, \\phi_0 \\rangle = 1$。\n$$ \\int_{0}^{1} (k)^2 \\,dx = 1 $$\n$$ k^2 \\int_{0}^{1} 1 \\,dx = 1 $$\n$$ k^2 [x]_{0}^{1} = 1 \\implies k^2 (1 - 0) = 1 \\implies k^2 = 1 $$\n我们选择正根，所以 $k=1$。因此，零阶正交归一化基函数是 $\\phi_0(x) = 1$。\n\n现在，我们可以使用其定义计算系数 $c_0$：\n$$ c_0 = \\langle f, \\phi_0 \\rangle = \\int_{0}^{1} f(x) \\phi_0(x) \\,dx = \\int_{0}^{1} \\sin(a\\,x) \\cdot 1 \\,dx $$\n该积分的计算结果为：\n$$ c_0 = \\left[ -\\frac{1}{a} \\cos(a\\,x) \\right]_{0}^{1} = -\\frac{1}{a} (\\cos(a \\cdot 1) - \\cos(a \\cdot 0)) $$\n由于 $\\cos(0) = 1$，我们得到：\n$$ c_0 = -\\frac{1}{a} (\\cos(a) - 1) = \\frac{1 - \\cos(a)}{a} $$\n这就是零阶系数的表达式。\n\n**2. 期望 $\\mathbb{E}[\\sin(a\\,\\xi)]$ 的PCE近似**\n\n在多项式阶数 $P$ 处截断的PCE提供了函数 $f(\\xi)$ 的一个近似，表示为 $f_P(\\xi)$：\n$$ f_P(\\xi) = \\sum_{n=0}^{P} c_n \\phi_n(\\xi) $$\n这个近似的期望由下式给出：\n$$ \\mathbb{E}[f_P(\\xi)] = \\mathbb{E}\\left[\\sum_{n=0}^{P} c_n \\phi_n(\\xi)\\right] $$\n根据期望算子的线性性质：\n$$ \\mathbb{E}[f_P(\\xi)] = \\sum_{n=0}^{P} c_n \\mathbb{E}[\\phi_n(\\xi)] $$\n基函数 $\\phi_n(\\xi)$ 的期望是：\n$$ \\mathbb{E}[\\phi_n(\\xi)] = \\int_{-\\infty}^{\\infty} \\phi_n(x) p_{\\xi}(x) \\,dx = \\int_{0}^{1} \\phi_n(x) \\cdot 1 \\,dx $$\n回顾 $\\phi_0(x) = 1$，我们可以将此积分写成内积形式：\n$$ \\mathbb{E}[\\phi_n(\\xi)] = \\int_{0}^{1} \\phi_n(x) \\phi_0(x) \\,dx = \\langle \\phi_n, \\phi_0 \\rangle $$\n由于基的正交归一性，$\\langle \\phi_n, \\phi_0 \\rangle = \\delta_{n0}$。这意味着 $\\mathbb{E}[\\phi_0(\\xi)] = 1$ 且对于所有 $n > 0$ 都有 $\\mathbb{E}[\\phi_n(\\xi)] = 0$。\n\n将此结果代回到PCE期望的表达式中：\n$$ \\mathbb{E}[f_P(\\xi)] = c_0 \\cdot \\mathbb{E}[\\phi_0(\\xi)] + \\sum_{n=1}^{P} c_n \\cdot \\mathbb{E}[\\phi_n(\\xi)] = c_0 \\cdot 1 + \\sum_{n=1}^{P} c_n \\cdot 0 = c_0 $$\n这展示了PCE的一个基本性质：任何阶数 $P \\ge 0$ 的PCE近似的期望都精确等于零阶系数 $c_0$。因此，在多项式阶数3处截断的规定对于计算均值是无关紧要的。\n因此，期望的PCE近似为：\n$$ \\mathbb{E}[\\sin(a\\,\\xi)] \\approx c_0 = \\frac{1 - \\cos(a)}{a} $$\n\n**3. $\\mathbb{E}[\\sin(a\\,\\xi)]$ 的精确解析表达式**\n\n我们可以从第一性原理出发，使用连续随机变量函数的期望定义来推导精确期望：\n$$ \\mathbb{E}[g(\\xi)] = \\int_{-\\infty}^{\\infty} g(x) p_{\\xi}(x) \\,dx $$\n对于我们的问题，$g(\\xi) = \\sin(a\\,\\xi)$ 且在 $[0,1]$ 上 $p_{\\xi}(x) = 1$。\n$$ \\mathbb{E}[\\sin(a\\,\\xi)] = \\int_{0}^{1} \\sin(a\\,x) \\cdot 1 \\,dx $$\n这正是我们为 $c_0$ 计算的那个积分。\n$$ \\mathbb{E}[\\sin(a\\,\\xi)] = \\left[ -\\frac{1}{a} \\cos(a\\,x) \\right]_{0}^{1} = -\\frac{1}{a} (\\cos(a) - \\cos(0)) = \\frac{1 - \\cos(a)}{a} $$\n如第2部分所证，零阶PCE系数不是一个近似值，而是与随机量的精确均值完全相同。\n\n**4. 当 $a = \\pi$ 时的数值计算**\n\n最后，我们计算当 $a=\\pi$ 时推导出的期望表达式：\n$$ \\mathbb{E}[\\sin(\\pi\\,\\xi)] = \\frac{1 - \\cos(\\pi)}{\\pi} $$\n利用 $\\cos(\\pi) = -1$ 这一事实，我们有：\n$$ \\mathbb{E}[\\sin(\\pi\\,\\xi)] = \\frac{1 - (-1)}{\\pi} = \\frac{2}{\\pi} $$\n为了提供数值，我们计算这个量：\n$$ \\frac{2}{\\pi} \\approx 0.63661977... $$\n按要求四舍五入到四位有效数字，我们得到 $0.6366$。",
            "answer": "$$\\boxed{0.6366}$$"
        },
        {
            "introduction": "从理论走向实践，第二个练习  将指导你构建并验证一个PCE实现。通过为一个简单的二次函数构建代理模型——在这种情况下PCE是精确的——你可以验证你的系数提取和统计矩计算代码的正确性。这为你处理更复杂的非精确近似问题建立了坚实的编程基础。",
            "id": "3174279",
            "problem": "要求您为广义多项式混沌（gPC）构建并验证一个综合基准，该基准能够为二次响应函数得出精确的均值和方差。该基准的设计应使得总阶数为二的截断正交多项式混沌能够精确表示该响应。您将通过使用精确数值积分的正交投影法实现系数提取，并验证从gPC系数计算出的均值和方差与从分布矩推导出的解析值相匹配。\n\n基本基础和假设：考虑具有已知正交多项式族和精确积分法则的独立随机变量。对于概率密度函数为$\\phi(x)$的标准正态随机变量$X$和在$[-1,1]$上的均匀随机变量$U$，使用它们相关的正交多项式基和高斯积分法则。广义多项式混沌（gPC）基函数是适用于每个边际分布的单变量正交多项式的张量积。系数由关于底层概率测度的正交投影定义。\n\n您的任务：\n1. 构建单变量正交基：\n   - 对于$X \\sim \\mathcal{N}(0,1)$，使用标准正交的概率论者Hermite多项式 $\\{\\psi_n(x)\\}_{n \\ge 0}$，使得 $E[\\psi_m(X)\\psi_n(X)] = \\delta_{mn}$，其中 $\\delta_{mn}$ 是克罗内克δ。\n   - 对于$U \\sim \\text{Uniform}([-1,1])$，使用标准正交的Legendre多项式 $\\{\\ell_n(u)\\}_{n \\ge 0}$，使得 $E[\\ell_m(U)\\ell_n(U)] = \\delta_{mn}$。\n   - 在多维情况下，使用由总阶数最高为二的多重指标索引的单变量正交基的张量积。\n2. 通过正交投影提取gPC系数。对于响应$f(\\boldsymbol{\\xi})$和正交基函数$\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$，系数$c_{\\boldsymbol{\\alpha}}$是内积\n   $$c_{\\boldsymbol{\\alpha}} = E\\left[f(\\boldsymbol{\\xi}) \\, \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\right],$$\n   其中$E[\\cdot]$表示关于$\\boldsymbol{\\xi}$的联合分布的期望。\n3. 利用基的正交性，从提取的系数计算均值和方差。然后，使用经过充分检验的二次多项式分布矩公式计算精确的解析均值和方差，并对两者进行比较。\n4. 使用适用于相应测度和多项式阶数的精确数值积分法则：\n   - 对于$X \\sim \\mathcal{N}(0,1)$，使用三点Gauss-Hermite积分，并通过变量替换$x = \\sqrt{2}\\,t$来精确计算最高四阶多项式的期望。\n   - 对于$U \\sim \\text{Uniform}([-1,1])$，使用按概率密度缩放的三点Gauss-Legendre积分来精确计算最高四阶多项式的期望。\n5. 为一维和二维独立随机输入及二次响应实现以上步骤。对于二维情况，使用张量积积分以保持对适当阶数的二元多项式的精确性。\n\n响应函数及其参数定义如下。对于一维情况，令\n$$f(x) = a_0 + a_1 x + a_2 x^2,$$\n对于具有独立输入$(x,y)$的二维情况，令\n$$f(x,y) = c_0 + c_1 x + c_2 y + c_3 x^2 + c_4 y^2 + c_5 x y.$$\n\n使用以下参数值的测试套件：\n- 案例1（标准正态，一维）：$a_0 = 1.3$, $a_1 = -0.7$, $a_2 = 0.5$。\n- 案例2（$[-1,1]$上的均匀分布，一维）：$a_0 = 0.2$, $a_1 = 1.1$, $a_2 = -0.5$。\n- 案例3（标准正态，二维）：$c_0 = 0.9$, $c_1 = 0.2$, $c_2 = -0.4$, $c_3 = 0.3$, $c_4 = 0.1$, $c_5 = 0.25$。\n- 案例4（$[-1,1]$上的均匀分布，二维）：$c_0 = -0.5$, $c_1 = 0.6$, $c_2 = 0.1$, $c_3 = -0.2$, $c_4 = 0.7$, $c_5 = 0.3$。\n- 案例5（标准正态，一维，常数边界情况）：$a_0 = 2.0$, $a_1 = 0.0$, $a_2 = 0.0$。\n- 案例6（$[-1,1]$上的均匀分布，一维，线性边界情况）：$a_0 = 0.0$, $a_1 = 1.0$, $a_2 = 0.0$。\n\n使用的解析参考矩：\n- 对于 $X \\sim \\mathcal{N}(0,1)$: $E[X] = 0$, $E[X^2] = 1$, $E[X^4] = 3$。\n- 对于 $U \\sim \\text{Uniform}([-1,1])$: $E[U] = 0$, $E[U^2] = \\frac{1}{3}$, $E[U^4] = \\frac{1}{5}$。\n\n您的程序必须：\n- 为两种分布实现正交多项式求值。\n- 实现带有适当缩放的三点高斯积分法则，以精确计算所需多项式阶数的期望。\n- 提取总阶数为二的gPC系数。\n- 计算基于gPC的均值和方差，并将其与每个案例的解析结果进行比较。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的验证结果。对于每个案例，输出一个布尔值，指示均值和方差是否都在$10^{-12}$的绝对容差内与解析值匹配。\n\n最终输出格式必须严格如下：\n“您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，[True,False,True,False,True,True]）。”",
            "solution": "问题陈述经评估为有效。它在科学上基于广义多项式混沌（gPC）展开理论，这是不确定性量化中的一种标准方法。该问题是适定的，所有必要的参数、分布和响应函数都有明确定义。目标清晰且可证伪：验证数值实现相对于解析结果的正确性。其基本数学假设，如二次响应的2阶gPC展开的精确性以及3点高斯积分的充分性，都是正确的。\n\n解决方案按以下步骤进行。首先，我们为标准正态分布和均匀分布定义必要的正交多项式基。其次，我们推导二次响应函数的均值和方差的解析表达式。第三，我们在gPC基中表示响应函数，以找到理论系数及相应的均值和方差。结果表明，这些值与解析值完全相同。第四，我们描述通过正交投影提取gPC系数的数值过程，该过程通过精确数值积分进行评估。最后，我们为每个测试案例实施此过程，并验证数值计算得到的均值和方差在指定容差内与解析值相匹配。\n\n具有随机输入$\\boldsymbol{\\xi}$的响应函数$f(\\boldsymbol{\\xi})$的gPC展开由下式给出\n$$f(\\boldsymbol{\\xi}) = \\sum_{\\boldsymbol{\\alpha} \\in \\mathbb{N}_0^d} c_{\\boldsymbol{\\alpha}} \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$$\n其中$\\{\\Psi_{\\boldsymbol{\\alpha}}\\}$是关于$\\boldsymbol{\\xi}$的概率测度正交的多项式基，$c_{\\boldsymbol{\\alpha}}$是gPC系数。对于二次响应函数，当在总多项式阶数$P=2$处截断时，该展开是精确的。\n\n系数通过正交投影求得：\n$$c_{\\boldsymbol{\\alpha}} = E\\left[f(\\boldsymbol{\\xi}) \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\right]$$\n其中$E[\\cdot]$表示期望。由于正交性，有$E[\\Psi_{\\boldsymbol{\\alpha}}] = \\delta_{\\boldsymbol{\\alpha}\\mathbf{0}}$ 和 $E[\\Psi_{\\boldsymbol{\\alpha}}\\Psi_{\\boldsymbol{\\beta}}] = \\delta_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}}$。\n然后可以直接从系数计算$f$的均值和方差：\n$$\\mu_f = E[f] = E\\left[\\sum_{\\boldsymbol{\\alpha}} c_{\\boldsymbol{\\alpha}} \\Psi_{\\boldsymbol{\\alpha}}\\right] = \\sum_{\\boldsymbol{\\alpha}} c_{\\boldsymbol{\\alpha}} E[\\Psi_{\\boldsymbol{\\alpha}}] = c_{\\mathbf{0}}$$\n$$\\sigma_f^2 = E[(f - \\mu_f)^2] = E\\left[\\left(\\sum_{\\boldsymbol{\\alpha} \\ne \\mathbf{0}} c_{\\boldsymbol{\\alpha}} \\Psi_{\\boldsymbol{\\alpha}}\\right)^2\\right] = \\sum_{\\boldsymbol{\\alpha} \\ne \\mathbf{0}} \\sum_{\\boldsymbol{\\beta} \\ne \\mathbf{0}} c_{\\boldsymbol{\\alpha}}c_{\\boldsymbol{\\beta}} E[\\Psi_{\\boldsymbol{\\alpha}}\\Psi_{\\boldsymbol{\\beta}}] = \\sum_{\\boldsymbol{\\alpha} \\ne \\mathbf{0}} c_{\\boldsymbol{\\alpha}}^2$$\n\n总阶数最高为2的单变量正交多项式基为：\n1.  对于$X \\sim \\mathcal{N}(0,1)$：标准正交的概率论者Hermite多项式。\n    $$\\psi_0(x) = 1, \\quad \\psi_1(x) = x, \\quad \\psi_2(x) = \\frac{1}{\\sqrt{2}}(x^2 - 1)$$\n    反向关系为：$1 = \\psi_0(x)$， $x = \\psi_1(x)$，以及 $x^2 = \\sqrt{2}\\psi_2(x) + \\psi_0(x)$。\n\n2.  对于$U \\sim \\text{Uniform}([-1,1])$：标准正交的Legendre多项式。\n    $$\\ell_0(u) = 1, \\quad \\ell_1(u) = \\sqrt{3}u, \\quad \\ell_2(u) = \\frac{\\sqrt{5}}{2}(3u^2 - 1)$$\n    反向关系为：$1 = \\ell_0(u)$， $u = \\frac{1}{\\sqrt{3}}\\ell_1(u)$，以及 $u^2 = \\frac{2}{3\\sqrt{5}}\\ell_2(u) + \\frac{1}{3} = \\frac{2\\sqrt{5}}{15}\\ell_2(u) + \\frac{1}{3}\\ell_0(u)$。\n\n解析均值和方差从分布的矩推导得出。\n对于一维响应$f(z) = a_0 + a_1 z + a_2 z^2$，其中z是X或U：\n$$\\mu_f = E[f(z)] = a_0 + a_1 E[z] + a_2 E[z^2]$$\n由于$E[X]=0$和$E[U]=0$，这可以简化为 $\\mu_f = a_0 + a_2 E[z^2]$。\n$$\\sigma_f^2 = E[(f(z) - \\mu_f)^2] = E[(a_1 z + a_2 (z^2-E[z^2]))^2]$$\n由于奇数阶矩为零，交叉项消失：\n$$\\sigma_f^2 = a_1^2 E[z^2] + a_2^2 E[(z^2-E[z^2])^2] = a_1^2 E[z^2] + a_2^2 (E[z^4] - (E[z^2])^2)$$\n\n对于二维响应$f(x,y) = c_0 + c_1 x + c_2 y + c_3 x^2 + c_4 y^2 + c_5 xy$，其中x, y是独立变量：\n$$\\mu_f = E[f(x,y)] = c_0 + c_3 E[x^2] + c_4 E[y^2]$$\n$$\\sigma_f^2 = \\text{Var}(f(x,y)) = c_1^2 \\text{Var}(x) + c_2^2 \\text{Var}(y) + c_3^2 \\text{Var}(x^2) + c_4^2 \\text{Var}(y^2) + c_5^2 \\text{Var}(xy)$$\n对于零均值变量$z$，使用$\\text{Var}(z) = E[z^2]$，以及x, y的独立性，我们得到：\n$$\\sigma_f^2 = c_1^2 E[x^2] + c_2^2 E[y^2] + c_3^2(E[x^4] - (E[x^2])^2) + c_4^2(E[y^4] - (E[y^2])^2) + c_5^2 E[x^2]E[y^2]$$\n\n系数提取积分 $c_{\\boldsymbol{\\alpha}} = E[f(\\boldsymbol{\\xi}) \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})]$ 使用数值积分进行评估。由于当$P=2$时，被积函数 $f(\\boldsymbol{\\xi})\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$ 是一个最高阶数为$4=2+2$的多项式，一个对于最高$2 \\times 3 - 1 = 5$阶多项式都精确的3点高斯积分法则，能够得出精确的系数值。\n\n对于$X \\sim \\mathcal{N}(0,1)$，我们使用Gauss-Hermite积分。期望$E[g(X)]$计算如下：\n$$E[g(X)] = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} g(x) e^{-x^2/2} dx = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} g(\\sqrt{2}t) e^{-t^2} dt \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^{3} w_i g(\\sqrt{2}t_i)$$\n其中$(t_i, w_i)$是标准的三点Gauss-Hermite积分点和权重。\n\n对于$U \\sim \\text{Uniform}([-1,1])$，我们使用Gauss-Legendre积分。期望$E[g(U)]$计算如下：\n$$E[g(U)] = \\frac{1}{2} \\int_{-1}^{1} g(u) du \\approx \\frac{1}{2} \\sum_{i=1}^{3} w_i g(u_i)$$\n其中$(u_i, w_i)$是标准的三点Gauss-Legendre积分点和权重。\n\n在二维情况下，使用单变量积分法则的张量积来保持精确性。实现将计算每个案例的解析统计量和基于gPC的统计量，并验证它们的一致性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and validates a synthetic benchmark for generalized Polynomial Chaos (gPC)\n    for quadratic response functions. It verifies that mean and variance from gPC\n    coefficients (extracted via exact quadrature) match analytical values.\n    \"\"\"\n\n    TOLERANCE = 1e-12\n\n    # --- Orthonormal Polynomial Definitions ---\n    def hermite_psi(n, x):\n        \"\"\"Orthonormal probabilists' Hermite polynomials psi_n(x).\"\"\"\n        if n == 0:\n            return np.ones_like(x)\n        if n == 1:\n            return x\n        if n == 2:\n            return (x**2 - 1) / np.sqrt(2)\n        raise ValueError(\"Only degrees 0, 1, 2 are implemented.\")\n\n    def legendre_ell(n, u):\n        \"\"\"Orthonormal Legendre polynomials ell_n(u).\"\"\"\n        if n == 0:\n            return np.ones_like(u)\n        if n == 1:\n            return np.sqrt(3) * u\n        if n == 2:\n            return np.sqrt(5) / 2 * (3 * u**2 - 1)\n        raise ValueError(\"Only degrees 0, 1, 2 are implemented.\")\n\n    # --- Response Function Definitions ---\n    def response_1d(x, coeffs):\n        return coeffs['a0'] + coeffs['a1'] * x + coeffs['a2'] * x**2\n\n    def response_2d(xy, coeffs):\n        x, y = xy[..., 0], xy[..., 1]\n        return (coeffs['c0'] + coeffs['c1'] * x + coeffs['c2'] * y +\n                coeffs['c3'] * x**2 + coeffs['c4'] * y**2 + coeffs['c5'] * x * y)\n\n    # --- Analytical Statistics ---\n    def get_analytical_stats(case):\n        coeffs = case['coeffs']\n        dist_type = case['dist']\n        dim = case['dim']\n\n        # Moments\n        if dist_type == 'normal':\n            moments = {'E_z1': 0, 'E_z2': 1, 'E_z4': 3}\n        else: # uniform\n            moments = {'E_z1': 0, 'E_z2': 1/3, 'E_z4': 1/5}\n\n        if dim == 1:\n            mean = coeffs['a0'] + coeffs['a2'] * moments['E_z2']\n            var_z2 = moments['E_z4'] - moments['E_z2']**2\n            variance = coeffs['a1']**2 * moments['E_z2'] + coeffs['a2']**2 * var_z2\n        else: # dim == 2\n            mean = coeffs['c0'] + coeffs['c3'] * moments['E_z2'] + coeffs['c4'] * moments['E_z2']\n            var_z2 = moments['E_z4'] - moments['E_z2']**2\n            variance = (coeffs['c1']**2 * moments['E_z2'] +\n                        coeffs['c2']**2 * moments['E_z2'] +\n                        coeffs['c3']**2 * var_z2 +\n                        coeffs['c4']**2 * var_z2 +\n                        coeffs['c5']**2 * moments['E_z2'] * moments['E_z2'])\n        return mean, variance\n\n    # --- gPC Coefficient Extraction and Statistics ---\n    def get_gpc_stats(case):\n        dist_type = case['dist']\n        dim = case['dim']\n        coeffs = case['coeffs']\n\n        if dist_type == 'normal':\n            poly_func = hermite_psi\n            # 3-point Gauss-Hermite quadrature\n            gh_pts, gh_w = np.polynomial.hermite.hermgauss(3)\n            quad_pts = gh_pts * np.sqrt(2)\n            quad_w = gh_w / np.sqrt(np.pi)\n        else: # uniform\n            poly_func = legendre_ell\n            # 3-point Gauss-Legendre quadrature\n            gl_pts, gl_w = np.polynomial.legendre.leggauss(3)\n            quad_pts = gl_pts\n            quad_w = gl_w / 2.0\n\n        if dim == 1:\n            f_vals = response_1d(quad_pts, coeffs)\n            \n            multi_indices = [0, 1, 2]\n            pce_coeffs = []\n            for alpha in multi_indices:\n                psi_vals = poly_func(alpha, quad_pts)\n                integrand = f_vals * psi_vals\n                c_alpha = np.sum(integrand * quad_w)\n                pce_coeffs.append(c_alpha)\n            \n            mean_gpc = pce_coeffs[0]\n            var_gpc = np.sum(np.array(pce_coeffs[1:])**2)\n\n        else: # dim == 2\n            quad_pts_x, quad_pts_y = np.meshgrid(quad_pts, quad_pts)\n            quad_pts_2d = np.stack([quad_pts_x.ravel(), quad_pts_y.ravel()], axis=-1)\n            f_vals = response_2d(quad_pts_2d, coeffs)\n            \n            quad_w_x, quad_w_y = np.meshgrid(quad_w, quad_w)\n            quad_w_2d = (quad_w_x * quad_w_y).ravel()\n\n            multi_indices = [(0, 0), (1, 0), (0, 1), (2, 0), (0, 2), (1, 1)]\n            pce_coeffs = {}\n            for alpha in multi_indices:\n                psi_vals = poly_func(alpha[0], quad_pts_2d[:, 0]) * poly_func(alpha[1], quad_pts_2d[:, 1])\n                integrand = f_vals * psi_vals\n                c_alpha = np.sum(integrand * quad_w_2d)\n                pce_coeffs[alpha] = c_alpha\n\n            mean_gpc = pce_coeffs[(0, 0)]\n            var_gpc = sum(c**2 for k, c in pce_coeffs.items() if k != (0, 0))\n        \n        return mean_gpc, var_gpc\n\n    # --- Main Loop ---\n    test_cases = [\n        {'id': 1, 'dim': 1, 'dist': 'normal', 'coeffs': {'a0': 1.3, 'a1': -0.7, 'a2': 0.5}},\n        {'id': 2, 'dim': 1, 'dist': 'uniform', 'coeffs': {'a0': 0.2, 'a1': 1.1, 'a2': -0.5}},\n        {'id': 3, 'dim': 2, 'dist': 'normal', 'coeffs': {'c0': 0.9, 'c1': 0.2, 'c2': -0.4, 'c3': 0.3, 'c4': 0.1, 'c5': 0.25}},\n        {'id': 4, 'dim': 2, 'dist': 'uniform', 'coeffs': {'c0': -0.5, 'c1': 0.6, 'c2': 0.1, 'c3': -0.2, 'c4': 0.7, 'c5': 0.3}},\n        {'id': 5, 'dim': 1, 'dist': 'normal', 'coeffs': {'a0': 2.0, 'a1': 0.0, 'a2': 0.0}},\n        {'id': 6, 'dim': 1, 'dist': 'uniform', 'coeffs': {'a0': 0.0, 'a1': 1.0, 'a2': 0.0}},\n    ]\n\n    results = []\n    for case in test_cases:\n        mean_analytical, var_analytical = get_analytical_stats(case)\n        mean_gpc, var_gpc = get_gpc_stats(case)\n\n        mean_match = np.isclose(mean_analytical, mean_gpc, atol=TOLERANCE, rtol=0)\n        var_match = np.isclose(var_analytical, var_gpc, atol=TOLERANCE, rtol=0)\n        \n        results.append(mean_match and var_match)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "现实世界的模型很少是简单的多项式。这个练习  挑战你将PCE应用于一个非多项式函数 $\\exp(\\sigma\\xi)$，其输出遵循对数正态分布。你将探索即使是截断的PCE近似，在捕捉均值和方差之外，对偏度这类高阶统计量的表现如何，以及近似的精度如何随着展开阶数的增加而提高。",
            "id": "3174337",
            "problem": "给定一个标量随机输入 $\\,\\xi \\sim \\mathcal{N}(0,1)\\,$ 和一个由 $\\,u(\\xi) = \\exp(\\sigma \\,\\xi)\\,$ 定义的对数正态输出，其中 $\\,\\sigma > 0\\,$ 是一个固定参数。考虑使用概率论学家的 Hermite 多项式 $\\,\\mathrm{He}_n(\\xi)\\,$ 作为相对于标准正态权重的正交基进行多项式混沌展开 (PCE)，并定义标准正交基函数 $\\,\\psi_n(\\xi) = \\mathrm{He}_n(\\xi)/\\sqrt{n!}\\,$。在总阶数 $\\,p \\in \\mathbb{N}\\,$ 处截断的 PCE 为\n$$\nU_p(\\xi) \\;=\\; \\sum_{n=0}^{p} c_n \\, \\psi_n(\\xi)\n$$\n您的任务是：\n- 仅从核心定义和经过充分检验的事实出发，推导函数 $\\,u(\\xi)\\,$ 在此标准正交基中展开的系数 $\\,c_n\\,$ 的表达式。允许的出发点包括 $\\,\\mathrm{He}_n(\\xi)\\,$ 相对于高斯测度的正交性以及 $\\,\\mathrm{He}_n(\\xi)\\,$ 的生成函数表征。不要假定任何专门的 PCE 公式为已知。\n- 使用截断展开式 $\\,U_p(\\xi)\\,$，估计其偏度，定义为\n$$\n\\gamma(U_p) \\;=\\; \\frac{\\mathbb{E}\\!\\left[\\left(U_p - \\mathbb{E}[U_p]\\right)^3\\right]}{\\left(\\mathbb{V}\\mathrm{ar}[U_p]\\right)^{3/2}},\n$$\n其中 $\\,\\mathbb{E}[\\cdot]\\,$ 表示期望，$\\,\\mathbb{V}\\mathrm{ar}[\\cdot]\\,$ 表示方差。\n- 作为参考，具有参数 $\\,\\mu = 0\\,$ 和 $\\,\\sigma^2\\,$ 的真实对数正态输出 $\\,u(\\xi)\\,$ 的精确偏度需要从对数正态分布的第一性原理计算，不使用任何 PCE 特有的捷径。\n\n实现要求：\n- 为计算标准正态定律下的期望 $\\,\\mathbb{E}[f(\\xi)]\\,$，请使用具有足够节点的 Gauss-Hermite 求积法，以精确积分乘以高斯权重的多项式。您必须使用从适用于权重 $\\,\\exp(-x^2)\\,$ 的 Gauss-Hermite 节点和权重到标准正态期望的标准映射：\n$$\n\\mathbb{E}[f(\\xi)] \\;=\\; \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^{N} w_i \\, f\\!\\left(\\sqrt{2}\\,x_i\\right),\n$$\n其中 $\\,(x_i,w_i)\\,$ 是用于权重 $\\,\\exp(-x^2)\\,$ 的 $\\,N\\,$ 点 Gauss-Hermite 法则的节点和权重。选择足够大的 $\\,N\\,$，使得当 $\\,U_p(\\xi)\\,$ 是一个 $\\,p\\,$ 次多项式时，$\\,U_p(\\xi)\\,$ 的最高达 $\\,3\\,$ 阶的矩能够被精确积分。\n- 通过递推关系 $\\,\\mathrm{He}_0(\\xi)=1\\,$, $\\,\\mathrm{He}_1(\\xi)=\\xi\\,$, $\\,\\mathrm{He}_{n+1}(\\xi)=\\xi\\,\\mathrm{He}_n(\\xi)-n\\,\\mathrm{He}_{n-1}(\\xi)\\,$ 实现 $\\,\\mathrm{He}_n(\\xi)\\,$，然后构造 $\\,\\psi_n(\\xi) = \\mathrm{He}_n(\\xi)/\\sqrt{n!}\\,$。\n- 计算并报告截断 PCE 近似的偏度 $\\,\\gamma(U_p)\\,$ 与 $\\,u(\\xi)\\,$ 的精确偏度之间的绝对误差。\n\n测试套件：\n- 使用以下五个测试用例，每个用例由一对 $\\;(\\sigma,p)\\;$ 指定：\n  - 用例 $\\,1$: $\\;\\sigma = 0.5,\\; p = 1$\n  - 用例 $\\,2$: $\\;\\sigma = 0.5,\\; p = 3$\n  - 用例 $\\,3$: $\\;\\sigma = 1.0,\\; p = 3$\n  - 用例 $\\,4$: $\\;\\sigma = 1.0,\\; p = 7$\n  - 用例 $\\,5$: $\\;\\sigma = 0.25,\\; p = 1$\n- 对于每个用例，计算一个浮点数：绝对误差 $\\,\\left|\\gamma(U_p) - \\gamma\\!\\left(u(\\xi)\\right)\\right|\\,$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，包含五个测试用例的有序结果列表，格式为方括号内的逗号分隔列表，例如 $\\,\\big[\\text{结果}_1,\\text{结果}_2,\\text{结果}_3,\\text{结果}_4,\\text{结果}_5\\big]\\,$。\n- 每个结果必须四舍五入到恰好 $\\,8\\,$ 位小数。\n- 不得打印任何其他文本。此问题中没有物理单位，也不涉及角度；所有输出均为无量纲实数。",
            "solution": "该问题是有效的。它在科学上基于多项式混沌展开理论和数值分析，问题设定良好，目标明确，并为获得唯一且可验证的解提供了所有必要的定义、参数和约束。\n\n解答过程分为三个主要部分：1) 推导多项式混沌展开 (PCE) 系数的解析表达式，2) 推导对数正态分布精确偏度的解析表达式，以及 3) 规定用于计算截断 PCE 近似的偏度和最终绝对误差的数值算法。\n\n**1. PCE 系数的推导**\n\n模型输出为 $u(\\xi) = \\exp(\\sigma \\xi)$，其中 $\\xi \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。PCE 使用标准正交基 $\\psi_n(\\xi) = \\mathrm{He}_n(\\xi)/\\sqrt{n!}$ 进行，其中 $\\mathrm{He}_n(\\xi)$ 是概率论学家的 Hermite 多项式。截断展开式为 $U_p(\\xi) = \\sum_{n=0}^{p} c_n \\psi_n(\\xi)$。\n\n系数 $c_n$ 通过将函数 $u(\\xi)$ 投影到基函数 $\\psi_n(\\xi)$ 上来确定。内积是关于标准正态概率测度定义的，这对应于期望算子 $\\mathbb{E}[\\cdot]$。\n$$\nc_n = \\mathbb{E}[u(\\xi) \\psi_n(\\xi)] = \\mathbb{E}\\left[\\exp(\\sigma \\xi) \\frac{\\mathrm{He}_n(\\xi)}{\\sqrt{n!}}\\right] = \\frac{1}{\\sqrt{n!}} \\mathbb{E}[\\exp(\\sigma \\xi) \\mathrm{He}_n(\\xi)]\n$$\n为了计算该期望，我们使用概率论学家的 Hermite 多项式的生成函数：\n$$\nG(\\xi, t) = \\sum_{n=0}^{\\infty} \\frac{\\mathrm{He}_n(\\xi)}{n!} t^n = \\exp\\left(\\xi t - \\frac{t^2}{2}\\right)\n$$\n我们计算 $u(\\xi)$ 与生成函数的乘积的期望：\n$$\n\\mathbb{E}[u(\\xi) G(\\xi, t)] = \\mathbb{E}\\left[\\exp(\\sigma \\xi) \\sum_{n=0}^{\\infty} \\frac{\\mathrm{He}_n(\\xi)}{n!} t^n\\right] = \\sum_{n=0}^{\\infty} \\frac{\\mathbb{E}[\\exp(\\sigma \\xi) \\mathrm{He}_n(\\xi)]}{n!} t^n\n$$\n左侧可以直接计算：\n$$\n\\mathbb{E}[\\exp(\\sigma \\xi) G(\\xi, t)] = \\mathbb{E}\\left[\\exp(\\sigma \\xi) \\exp\\left(\\xi t - \\frac{t^2}{2}\\right)\\right] = \\exp\\left(-\\frac{t^2}{2}\\right) \\mathbb{E}\\left[\\exp((\\sigma+t)\\xi)\\right]\n$$\n期望项 $\\mathbb{E}[\\exp(s\\xi)]$ 是标准正态随机变量 $\\xi$ 的矩生成函数 (MGF)，即 $M_{\\xi}(s) = \\exp(s^2/2)$。令 $s = \\sigma+t$：\n$$\n\\mathbb{E}\\left[\\exp((\\sigma+t)\\xi)\\right] = M_{\\xi}(\\sigma+t) = \\exp\\left(\\frac{(\\sigma+t)^2}{2}\\right) = \\exp\\left(\\frac{\\sigma^2 + 2\\sigma t + t^2}{2}\\right)\n$$\n将此代回，我们得到：\n$$\n\\mathbb{E}[u(\\xi) G(\\xi, t)] = \\exp\\left(-\\frac{t^2}{2}\\right) \\exp\\left(\\frac{\\sigma^2}{2} + \\sigma t + \\frac{t^2}{2}\\right) = \\exp\\left(\\frac{\\sigma^2}{2} + \\sigma t\\right)\n$$\n我们将此结果展开为关于 $t$ 的泰勒级数：\n$$\n\\exp\\left(\\frac{\\sigma^2}{2}\\right) \\exp(\\sigma t) = \\exp\\left(\\frac{\\sigma^2}{2}\\right) \\sum_{n=0}^{\\infty} \\frac{(\\sigma t)^n}{n!} = \\sum_{n=0}^{\\infty} \\left(\\exp\\left(\\frac{\\sigma^2}{2}\\right) \\frac{\\sigma^n}{n!}\\right) t^n\n$$\n通过令 $\\mathbb{E}[u(\\xi) G(\\xi, t)]$ 的两个级数展开式中 $t^n$ 的系数相等，我们发现：\n$$\n\\frac{\\mathbb{E}[\\exp(\\sigma \\xi) \\mathrm{He}_n(\\xi)]}{n!} = \\exp\\left(\\frac{\\sigma^2}{2}\\right) \\frac{\\sigma^n}{n!} \\implies \\mathbb{E}[\\exp(\\sigma \\xi) \\mathrm{He}_n(\\xi)] = \\sigma^n \\exp\\left(\\frac{\\sigma^2}{2}\\right)\n$$\n最后，将此代入 $c_n$ 的公式中：\n$$\nc_n = \\frac{1}{\\sqrt{n!}} \\left(\\sigma^n \\exp\\left(\\frac{\\sigma^2}{2}\\right)\\right) = \\frac{\\sigma^n \\exp(\\sigma^2/2)}{\\sqrt{n!}}\n$$\n\n**2. 对数正态输出的精确偏度**\n\n输出 $u(\\xi) = \\exp(\\sigma \\xi)$ 服从对数正态分布，因为它是正态随机变量 $\\sigma\\xi \\sim \\mathcal{N}(0, \\sigma^2)$ 的指数。偏度由 $u$ 的前三阶矩计算得出。$u$ 的 $k$ 阶原点矩可以通过 $\\xi$ 的 MGF 求得：\n$$\nM_k = \\mathbb{E}[u^k] = \\mathbb{E}[\\exp(k\\sigma\\xi)] = M_{\\xi}(k\\sigma) = \\exp\\left(\\frac{(k\\sigma)^2}{2}\\right) = \\exp\\left(\\frac{k^2\\sigma^2}{2}\\right)\n$$\n前三阶原点矩为：\n- $M_1 = \\mathbb{E}[u] = \\exp(\\sigma^2/2)$\n- $M_2 = \\mathbb{E}[u^2] = \\exp(2\\sigma^2)$\n- $M_3 = \\mathbb{E}[u^3] = \\exp(9\\sigma^2/2)$\n\n均值、方差和三阶中心矩为：\n- 均值：$\\mathbb{E}[u] = M_1$\n- 方差：$\\mathbb{V}\\mathrm{ar}[u] = M_2 - M_1^2 = \\exp(2\\sigma^2) - (\\exp(\\sigma^2/2))^2 = \\exp(2\\sigma^2) - \\exp(\\sigma^2) = \\exp(\\sigma^2)(\\exp(\\sigma^2) - 1)$\n- 三阶中心矩：$\\mu_3(u) = M_3 - 3M_2M_1 + 2M_1^3 = \\exp(9\\sigma^2/2) - 3\\exp(2\\sigma^2)\\exp(\\sigma^2/2) + 2(\\exp(\\sigma^2/2))^3 = \\exp(9\\sigma^2/2) - 3\\exp(5\\sigma^2/2) + 2\\exp(3\\sigma^2/2)$。\n令 $K = \\exp(\\sigma^2)$ 对 $\\mu_3(u)$ 进行因式分解，得到：$K^{3/2}(K^3 - 3K + 2) = K^{3/2}(K-1)^2(K+2)$。\n\n精确偏度 $\\gamma(u)$ 为：\n$$\n\\gamma(u) = \\frac{\\mu_3(u)}{(\\mathbb{V}\\mathrm{ar}[u])^{3/2}} = \\frac{\\exp(3\\sigma^2/2)(\\exp(\\sigma^2)-1)^2(\\exp(\\sigma^2)+2)}{(\\exp(\\sigma^2)(\\exp(\\sigma^2)-1))^{3/2}} = (\\exp(\\sigma^2)+2)\\sqrt{\\exp(\\sigma^2)-1}\n$$\n\n**3. PCE 近似的偏度**\n\nPCE 近似的偏度 $\\gamma(U_p)$ 定义为：\n$$\n\\gamma(U_p) = \\frac{\\mathbb{E}[(U_p - \\mathbb{E}[U_p])^3]}{(\\mathbb{V}\\mathrm{ar}[U_p])^{3/2}}\n$$\n$U_p(\\xi)$ 的矩按照规定使用 Gauss-Hermite 求积法计算。函数 $f(\\xi)$ 的期望近似为：\n$$\n\\mathbb{E}[f(\\xi)] \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^{N} w_i f(\\sqrt{2}x_i)\n$$\n其中 $(x_i, w_i)$ 是权重函数 $\\exp(-x^2)$ 的节点和权重。一个 $N$ 点 Gauss-Hermite 法则可以精确积分最高达 $2N-1$ 次的多项式。为了计算 $U_p(\\xi)$ 的三阶中心矩，我们需要其前三阶原点矩，这涉及到对最高达 $3p$ 次的多项式进行积分。因此，我们需要 $2N-1 \\ge 3p$，这意味着选择 $N \\ge (3p+1)/2$。满足此条件的最小整数 $N$ 是 $N = \\lceil (3p+1)/2 \\rceil$。\n\n算法流程如下：\n1.  对于给定的数对 $(\\sigma, p)$，使用推导出的公式计算 $n = 0, \\ldots, p$ 的系数 $c_n$。\n2.  确定所需的求积点数 $N = \\lceil (3p+1)/2 \\rceil$。\n3.  获取 $N$ 个 Gauss-Hermite 节点 $x_i$ 和权重 $w_i$。\n4.  转换节点以对应于标准正态测度：$\\xi_i = \\sqrt{2}x_i$。求积权重按 $1/\\sqrt{\\pi}$进行缩放。\n5.  在每个节点 $\\xi_i$ 处，计算截断展开式 $U_p(\\xi_i) = \\sum_{n=0}^{p} c_n \\psi_n(\\xi_i)$。标准正交基函数 $\\psi_n(\\xi_i) = \\mathrm{He}_n(\\xi_i)/\\sqrt{n!}$ 通过首先使用递推关系：$\\mathrm{He}_0(\\xi)=1$, $\\mathrm{He}_1(\\xi)=\\xi$ 和 $\\mathrm{He}_{n+1}(\\xi)=\\xi\\,\\mathrm{He}_n(\\xi)-n\\,\\mathrm{He}_{n-1}(\\xi)$ 生成最高达 $p$ 阶的 Hermite 多项式 $\\mathrm{He}_n(\\xi_i)$ 来计算。\n6.  使用求积法则计算 $U_p$ 的前三阶原点矩：\n    - $M_{1,p} = \\mathbb{E}[U_p] = \\frac{1}{\\sqrt{\\pi}} \\sum_i w_i U_p(\\xi_i)$\n    - $M_{2,p} = \\mathbb{E}[U_p^2] = \\frac{1}{\\sqrt{\\pi}} \\sum_i w_i (U_p(\\xi_i))^2$\n    - $M_{3,p} = \\mathbb{E}[U_p^3] = \\frac{1}{\\sqrt{\\pi}} \\sum_i w_i (U_p(\\xi_i))^3$\n7.  计算 $U_p$ 的方差和三阶中心矩：\n    - $\\mathbb{V}\\mathrm{ar}[U_p] = M_{2,p} - M_{1,p}^2$\n    - $\\mu_3(U_p) = M_{3,p} - 3M_{2,p}M_{1,p} + 2M_{1,p}^3$\n8.  计算近似的偏度：$\\gamma(U_p) = \\mu_3(U_p) / (\\mathbb{V}\\mathrm{ar}[U_p])^{3/2}$。\n\n**4. 绝对误差**\n每个测试用例的最终结果是近似偏度与精确偏度之间的绝对误差：$|\\gamma(U_p) - \\gamma(u)|$。",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.hermite import hermgauss\nfrom math import factorial, sqrt, exp, ceil\n\ndef solve():\n    \"\"\"\n    Computes the absolute error between the exact skewness of a log-normal\n    variable and the skewness of its Polynomial Chaos Expansion (PCE) approximation.\n    \"\"\"\n    test_cases = [\n        (0.5, 1),\n        (0.5, 3),\n        (1.0, 3),\n        (1.0, 7),\n        (0.25, 1),\n    ]\n\n    results = []\n    for sigma, p in test_cases:\n        # 1. Compute the exact skewness of the log-normal distribution u(xi) = exp(sigma * xi)\n        # where xi ~ N(0,1). The underlying normal distribution for u has mean 0 and\n        # variance sigma^2.\n        exp_sigma_sq = exp(sigma**2)\n        exact_skewness = (exp_sigma_sq + 2.0) * sqrt(exp_sigma_sq - 1.0)\n        \n        # 2. Compute the skewness of the PCE approximation U_p(xi)\n        \n        # 2.1 Calculate PCE coefficients c_n = sigma^n * exp(sigma^2/2) / sqrt(n!)\n        coeffs = np.zeros(p + 1)\n        exp_sigma_sq_half = exp(sigma**2 / 2.0)\n        for n in range(p + 1):\n            coeffs[n] = (sigma**n * exp_sigma_sq_half) / sqrt(factorial(n))\n\n        # 2.2 Determine quadrature order and get nodes/weights.\n        # An N-point Gauss-Hermite rule is exact for polynomials up to degree 2N-1.\n        # To compute E[U_p^3], a polynomial of degree 3p, we need 2N-1 >= 3p.\n        # So, N >= (3p+1)/2.\n        N = ceil((3 * p + 1) / 2.0)\n        nodes_x, weights_w = hermgauss(N)\n\n        # 2.3 Map nodes/weights for standard normal expectation E[f(xi)].\n        # E[f(xi)] = (1/sqrt(pi)) * integral(f(sqrt(2)x) * exp(-x^2) dx)\n        nodes_xi = sqrt(2.0) * nodes_x\n        quad_weights = weights_w / sqrt(np.pi)\n\n        # 2.4 Evaluate U_p at each quadrature node.\n        # U_p(xi) = sum_{n=0 to p} c_n * psi_n(xi), where psi_n = He_n / sqrt(n!)\n        # We pre-compute Hermite polynomial values He_n(xi) for all nodes.\n        He_vals = []\n        He_vals.append(np.ones_like(nodes_xi)) # He_0(xi) = 1\n        if p > 0:\n            He_vals.append(np.copy(nodes_xi)) # He_1(xi) = xi\n        for n in range(1, p):\n            # Recurrence: He_{n+1}(xi) = xi * He_n(xi) - n * He_{n-1}(xi)\n            He_next = nodes_xi * He_vals[n] - n * He_vals[n-1]\n            He_vals.append(He_next)\n        \n        # Sum the series expansion to get U_p values at nodes\n        Up_values = np.zeros_like(nodes_xi)\n        for n in range(p + 1):\n            psi_n_vals = He_vals[n] / sqrt(factorial(n))\n            Up_values += coeffs[n] * psi_n_vals\n\n        # 2.5 Compute first three raw moments of U_p using quadrature\n        M1 = np.sum(quad_weights * Up_values)\n        M2 = np.sum(quad_weights * Up_values**2)\n        M3 = np.sum(quad_weights * Up_values**3)\n\n        # 2.6 Compute skewness from moments\n        var_Up = M2 - M1**2\n        \n        pce_skewness = 0.0\n        # Check for non-positive variance due to floating-point errors\n        if var_Up > 1e-15:\n            mu3_Up = M3 - 3.0 * M2 * M1 + 2.0 * M1**3\n            pce_skewness = mu3_Up / (var_Up**1.5)\n\n        # 3. Compute the absolute error\n        abs_error = abs(pce_skewness - exact_skewness)\n        results.append(abs_error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}