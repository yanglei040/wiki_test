{
    "hands_on_practices": [
        {
            "introduction": "理解了量子搜索的理论边界后，一个更实际的问题摆在我们面前：面对一个具体的计算难题，我们应该选择量子算法还是一个巧妙的经典算法？本练习将你置于算法设计师的角色，要求你基于一个实际的计算场景做出决策。\n\n你将为一个经典的NP难问题——背包问题的变体，进行一次定量的“纸面”性能评估。通过计算和比较格罗弗（Grover）算法、动态规划以及分支定界法在特定参数下的预期运行时间，你将亲身体会到，利用问题特殊结构（如伪多项式时间特性）的经典算法，在实践中可能远胜于通用的量子搜索。",
            "id": "3133884",
            "problem": "一个团队的任务是在一个 $0$-$1$ 背包式场景中，找到任何一个满足阈值可行性条件的物品子集。有 $n$ 个物品，每个物品都有整数重量和价值，背包容量为整数 $W$。目标是找到任何一个总重量不超过 $W$ 且总价值不低于给定阈值的子集。你需要基于一个预言机成本模型，在三种方法——Grover 算法、动态规划和分支定界法 (B&B)——之间做出选择，并从第一性原理出发证明你的选择。\n\n使用的基本原理：\n- 用于非结构化搜索的 Grover 算法执行振幅放大，对于一个大小为 $N$ 且有 $M$ 个标记解的搜索空间，需要对一个黑盒谓词预言机进行大约 $\\sqrt{N/M}$ 次查询。\n- 解决 $0$-$1$ 背包问题的标准动态规划方法会构建一个按物品和容量索引的表格，假设重量和容量是整数，大约有 $nW$ 次状态转移。\n- 分支定界法探索一个搜索树，其扩展节点的总数取决于定界质量；运行时间模型与扩展节点数乘以每个节点的定界/可行性成本成正比。\n\n场景参数：\n- 搜索空间是所有 $0$-$1$ 子集的集合，因此 $N = 2^{n}$。\n- 经验领域的知识表明，满足阈值的可行子集数量为 $M = 10^{6}$。\n- Grover 算法使用的非结构化谓词预言机（用于标记可行子集）每次查询运行时间为 $C_{\\text{oracle}} = 1.0 \\times 10^{-3}$ 秒，状态准备开销为 $C_{\\text{prep}} = 1.0 \\times 10^{-1}$ 秒。\n- 动态规划适用，因为物品重量和 $W$ 都是中等大小的整数，其中 $n = 50$ 且 $W = 500$。假设大约有 $nW$ 次表格状态转移，每次成本为 $C_{\\text{dp}} = 5.0 \\times 10^{-6}$ 秒。\n- 在此实例中，使用标准定界启发式方法的分支定界法预计平均扩展 $B = 10^{7}$ 个节点，每个节点的组合定界/可行性成本为 $C_{\\text{bb}} = 2.5 \\times 10^{-6}$ 秒。\n\n基于这些成本模型和参数，哪种方法产生的预期运行时间最低？\n\nA. Grover 算法，因为预言机调用次数的规模约为 $\\sqrt{N/M}$，并且给定的 $C_{\\text{oracle}}$ 使其比经典方法更快。\n\nB. 动态规划，因为在给定参数下，$nW$ 次状态转移和给定的 $C_{\\text{dp}}$ 产生的运行时间低于 Grover 算法和分支定界法。\n\nC. 分支定界法，因为预期节点数乘以 $C_{\\text{bb}}$ 的结果优于 Grover 算法的预言机复杂度和动态规划的状态转移。\n\nD. Grover 算法，因为它总是比任何经典方法提供指数级加速，而无论问题结构或参数值如何。",
            "solution": "用户要求对问题陈述进行严格验证，然后推导解决方案并评估所提供的选项。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **问题类型**：找到 $n$ 个物品的任一子集，每个物品都有整数重量和价值，使得总重量最多为容量 $W$，总价值至少为给定阈值。这是 $0$-$1$ 背包问题的可行性版本。\n- **算法**：Grover 算法、动态规划 (DP)、分支定界法 (B&B)。\n- **成本模型基础**：\n    - **Grover 算法**：对于一个大小为 $N$ 且有 $M$ 个解的搜索空间，需要对一个谓词预言机进行 $\\mathcal{O}(\\sqrt{N/M})$ 次查询。\n    - **动态规划 (DP)**：对于一个按物品和容量索引的表格，大约需要 $nW$ 次状态转移。\n    - **分支定界法 (B)**：运行时间与扩展节点数乘以每个节点的成本成正比。\n- **场景参数**：\n    - 物品数量, $n = 50$。\n    - 容量, $W = 500$。\n    - 搜索空间大小, $N = 2^{n} = 2^{50}$。\n    - 可行子集（解）的数量, $M = 10^{6}$。\n    - Grover 算法的预言机查询成本, $C_{\\text{oracle}} = 1.0 \\times 10^{-3}$ 秒。\n    - Grover 算法的状态准备开销, $C_{\\text{prep}} = 1.0 \\times 10^{-1}$ 秒。\n    - 动态规划的状态转移成本, $C_{\\text{dp}} = 5.0 \\times 10^{-6}$ 秒。\n    - 分支定界法扩展节点数, $B = 10^{7}$。\n    - 分支定界法每节点成本, $C_{\\text{bb}} = 2.5 \\times 10^{-6}$ 秒。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据有效性标准评估问题陈述。\n\n-   **科学基础**：该问题基于成熟的计算机科学和量子计算原理。背包问题是一个经典的 NP-难问题。动态规划（$\\mathcal{O}(nW)$，伪多项式）、Grover 算法（$\\mathcal{O}(\\sqrt{N/M})$ 用于非结构化搜索）和分支定界法的复杂度特征是标准的。使用成本模型来估算运行时间是算法分析中常用且有效的方法。\n-   **适定性**：该问题是适定的。它提供了所有必要的数值参数和一个清晰、客观的目标函数——最小化预期运行时间——以比较三种指定的算法。可以从提供的数据中推导出唯一、稳定且有意义的答案。\n-   **客观性**：该问题以精确、客观的语言陈述，没有主观或模糊的术语。\n\n该问题没有表现出任何列出的缺陷（科学上不健全、非形式化、设置不完整、不切实际、不适定、伪深刻或无法验证）。所有参数都已明确定义，并提供了用于计算运行时间的模型。\n\n**步骤 3：结论和行动**\n\n问题陈述是**有效的**。将根据提供的信息推导解决方案。\n\n### 解题推导\n\n任务是计算三种方法中每一种的预期运行时间，并找出最小值。\n\n**1. Grover 算法运行时间 ($T_{\\text{Grover}}$)**\n\n总运行时间是状态准备开销和执行预言机查询的成本之和。查询次数 $Q_{\\text{Grover}}$ 约为 $\\sqrt{N/M}$。我们将以此作为估算值。\n\n-   搜索空间大小：$N = 2^{n} = 2^{50}$。\n-   解的数量：$M = 10^{6}$。\n-   预言机查询次数：\n    $$Q_{\\text{Grover}} = \\sqrt{\\frac{N}{M}} = \\sqrt{\\frac{2^{50}}{10^{6}}} = \\frac{2^{25}}{10^{3}}$$\n    使用近似值 $2^{10} \\approx 10^{3}$：\n    $$2^{25} = 2^5 \\times 2^{20} = 32 \\times (2^{10})^2 \\approx 32 \\times (10^3)^2 = 3.2 \\times 10^7$$\n    一个更精确的值是 $2^{25} = 33,554,432$。\n    $$Q_{\\text{Grover}} = \\frac{33,554,432}{1000} \\approx 33,554.4$$\n-   查询总成本：\n    $$\\text{Cost}_{\\text{queries}} = Q_{\\text{Grover}} \\times C_{\\text{oracle}} \\approx 33,554.4 \\times (1.0 \\times 10^{-3} \\text{ s}) \\approx 33.55 \\text{ s}$$\n-   Grover 算法的总运行时间：\n    $$T_{\\text{Grover}} = C_{\\text{prep}} + \\text{Cost}_{\\text{queries}} = 0.1 \\text{ s} + 33.55 \\text{ s} = 33.65 \\text{ s}$$\n\n**2. 动态规划运行时间 ($T_{\\text{DP}}$)**\n\n运行时间是表格状态转移总数与每次转移成本的乘积。\n\n-   物品数量：$n = 50$。\n-   容量：$W = 500$。\n-   状态转移次数：\n    $$\\text{Transitions}_{\\text{DP}} = n \\times W = 50 \\times 500 = 25,000 = 2.5 \\times 10^4$$\n-   动态规划的总运行时间：\n    $$T_{\\text{DP}} = \\text{Transitions}_{\\text{DP}} \\times C_{\\text{dp}} = (2.5 \\times 10^4) \\times (5.0 \\times 10^{-6} \\text{ s})$$\n    $$T_{\\text{DP}} = 12.5 \\times 10^{-2} \\text{ s} = 0.125 \\text{ s}$$\n\n**3. 分支定界法运行时间 ($T_{\\text{B}}$)**\n\n运行时间是扩展节点数与每节点成本的乘积。\n\n-   扩展节点数：$B = 10^{7}$。\n-   每节点成本：$C_{\\text{bb}} = 2.5 \\times 10^{-6}$ s。\n-   分支定界法的总运行时间：\n    $$T_{\\text{B}} = B \\times C_{\\text{bb}} = 10^7 \\times (2.5 \\times 10^{-6} \\text{ s}) = 25 \\text{ s}$$\n\n**运行时间比较**\n\n-   $T_{\\text{Grover}} \\approx 33.65 \\text{ s}$\n-   $T_{\\text{DP}} = 0.125 \\text{ s}$\n-   $T_{\\text{B}} = 25.0 \\text{ s}$\n\n比较这些值，我们发现：\n$T_{\\text{DP}}  T_{\\text{B}}  T_{\\text{Grover}}$\n动态规划方法产生的预期运行时间最低。\n\n### 逐项分析\n\n**A. Grover 算法，因为预言机调用次数的规模约为 $\\sqrt{N/M}$，并且给定的 $C_{\\text{oracle}}$ 使其比经典方法更快。**\n预言机调用次数的规模约为 $\\sqrt{N/M}$ 的前提是正确的。然而，在给定参数下，这使其成为最快方法的结论是错误的。我们的计算表明 $T_{\\text{Grover}} \\approx 33.65 \\text{ s}$，这比动态规划（$0.125 \\text{ s}$）和分支定界法（$25.0 \\text{ s}$）都要慢。\n因此，此选项是**错误的**。\n\n**B. 动态规划，因为在给定参数下，$nW$ 次状态转移和给定的 $C_{\\text{dp}}$ 产生的运行时间低于 Grover 算法和分支定界法。**\n该推理基于使用所提供模型的直接计算。我们的计算表明 $T_{\\text{DP}} = 0.125 \\text{ s}$，这明显低于 $T_{\\text{Grover}} \\approx 33.65 \\text{ s}$ 和 $T_{\\text{B}} = 25.0 \\text{ s}$。该陈述得到了定量分析的充分支持。\n因此，此选项是**正确的**。\n\n**C. 分支定界法，因为预期节点数乘以 $C_{\\text{bb}}$ 的结果优于 Grover 算法的预言机复杂度和动态规划的状态转移。**\n该说法声称 BB 是三者中最快的。我们的计算显示 $T_{\\text{B}} = 25.0 \\text{ s}$。虽然这比 Grover 算法（$33.65 \\text{ s}$）快，但它比动态规划（$0.125 \\text{ s}$）慢得多。声称它“优于...动态规划的状态转移”是错误的。\n因此，此选项是**错误的**。\n\n**D. Grover 算法，因为它总是比任何经典方法提供指数级加速，而无论问题结构或参数值如何。**\n这个说法从根本上是错误的。Grover 算法相对于*非结构化*的经典搜索提供的是二次加速，而不是指数级加速。此外，这种加速是相对于暴力搜索而言的。利用问题结构的经典算法，例如解决背包问题的伪多项式动态规划方法，可能比将 Grover 算法应用于非结构化搜索空间要高效得多。本问题实例明确地展示了一个案例，其中一个经典的、利用了问题结构的算法（DP）的性能显著优于量子搜索算法。这种说法是对 Grover 算法能力的严重夸大，也是一种常见的误解。\n因此，此选项是**错误的**。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在理论探讨中，我们常将量子算法的操作抽象为对“神谕机”（Oracle）的调用。但要实现这样一个神谕机，究竟需要付出多少实际的物理代价？本练习将带你深入底层，探究量子算法的硬件资源成本。\n\n你的任务是为一个著名的NP完全问题（3-SAT）估算其格罗弗神谕机的实现成本。具体来说，你需要基于一套标准的容错量子计算门集（Clifford+$T$），推导出实现该神谕机所需的非Clifford门（$T$门）数量。这项练习让你从抽象的算法理论，迈向具体的量子电路资源评估，这对于理解量子计算的工程实现至关重要。",
            "id": "3133929",
            "problem": "考虑为合取范式（CNF）的布尔公式构建一个 Grover 神谕，该公式具有 $n$ 个输入比特和 $m$ 个子句，其中每个子句是恰好三个文字（literal）的析取（三元可满足性问题，也称 $3$-SAT）。该神谕应翻转满足所有子句的计算基态 $|x\\rangle$ 的相位。假设采用标准的可逆计算-相位-反计算模式，并且电路被编译到 Clifford 加 $T$ (Clifford+$T$) 门集。使用以下在容错资源估算中常见的建模假设：\n\n- 每个文字是变量 $x_{j}$ 或其否定 $\\neg x_{j}$，否定由 Pauli-$X$ 门实现，它们是 Clifford 门。\n- 双输入析取 $a \\lor b$ 通过德摩根定律可逆地实现为 $a \\lor b = \\neg(\\neg a \\land \\neg b)$，因此其非 Clifford 代价为一个双输入合取的代价。\n- 双输入合取通过使用干净的辅助量子比特的受控-受控-非门（Toffoli 门）实现。一个 Toffoli 门的非 Clifford 代价恰好为 $7$ 个 $T$ 门。\n- 三输入析取 $a \\lor b \\lor c$ 通过组合两个双输入析取来构建。\n- $m$ 个子句输出的全局合取由一个使用干净辅助量子比特的双输入合取二叉树构成。\n- 以最终合取为条件的相位翻转由一个 Clifford 门（例如，受控-$Z$ 门）实现，不产生 $T$ 门代价。\n- 在相位翻转后，所有中间值都会被反计算，以将所有辅助量子比特恢复到 $|0\\rangle$ 状态。\n\n在这些假设下，推导单次应用 Grover 神谕的总 $T$ 门数的封闭形式符号表达式，作为 $n$ 和 $m$ 的函数。将最终答案表示为单个解析表达式。无需四舍五入，不涉及单位。",
            "solution": "该问题是有效的，因为它在科学上基于量子计算和资源估算的原理，问题陈述清晰，目标明确，并有一套一致、可形式化的假设，没有任何不合格的缺陷。我现在将进行完整的解答。\n\n该问题要求为具有 $n$ 个变量和 $m$ 个子句的 $3$-SAT 问题推导单次 Grover 神谕应用的总 $T$ 门数的封闭形式表达式。该解是基于为编译到 Clifford+$T$ 门集的电路所提供的建模假设推导出来的。\n\n神谕的实现遵循标准的计算-相位-反计算模式。总 $T$ 门数，记为 $T_{\\text{total}}$，是这三个阶段的 $T$ 门数之和：\n$$T_{\\text{total}} = T_{\\text{compute}} + T_{\\text{phase}} + T_{\\text{uncompute}}$$\n\n我们来分析每个阶段的 $T$ 门数。\n\n1.  **相位阶段 ($T_{\\text{phase}}$):**\n    根据假设 $7$，应用于计算最终输出比特的条件相位翻转由一个 Clifford 门（例如受控-$Z$ 门）实现。根据定义，Clifford 门的 $T$ 门数为零。因此，\n    $$T_{\\text{phase}} = 0$$\n\n2.  **反计算阶段 ($T_{\\text{uncompute}}$):**\n    假设 $8$ 指出，所有中间值都会被反计算，以将辅助量子比特恢复到其初始 $|0\\rangle$ 状态。这是通过反向运行计算电路来实现的。由 Clifford 门和 $T$ 门组成的电路的逆电路与原始电路具有相同的 $T$ 门数。这是因为 $T$ 门的逆是 $T^{\\dagger}$，其实现成本通常与 $T$ 门相同，而其他关键门（如 Toffoli 门）是自身的逆。因此，反计算阶段的 $T$ 门数等于计算阶段的 $T$ 门数：\n    $$T_{\\text{uncompute}} = T_{\\text{compute}}$$\n\n3.  **总 $T$ 门数表达式：**\n    将这些代入初始方程，神谕的总 $T$ 门数为：\n    $$T_{\\text{total}} = T_{\\text{compute}} + 0 + T_{\\text{compute}} = 2 \\times T_{\\text{compute}}$$\n    我们的任务简化为求出计算阶段的 $T$ 门数，$T_{\\text{compute}}$。\n\n4.  **计算阶段 ($T_{\\text{compute}}$):**\n    计算阶段为给定的输入 $|x\\rangle$ 评估整个布尔公式。这个过程可以分为两个主要部分：\n    -   A部分：评估 $3$-SAT 公式的 $m$ 个子句中的每一个。\n    -   B部分：计算所有 $m$ 个子句结果的逻辑与（合取），得到一个最终比特，指示输入 $|x\\rangle$ 是否为满足性赋值。\n\n    我们来计算每个部分的 $T$ 门数。\n\n    **A部分：评估 $m$ 个子句的代价**\n    每个子句是三个文字的析取。设一个子句为 $l_1 \\lor l_2 \\lor l_3$。\n    -   根据假设 $5$，这通过组合两个双输入析取来实现，例如，$(l_1 \\lor l_2) \\lor l_3$。\n    -   根据假设 $2$，一个双输入析取（$a \\lor b$）的非 Clifford 代价为一个双输入合取的代价。\n    -   因此，一个三输入子句的非 Clifford 代价等同于两个双输入合取的代价。\n    -   根据假设 $3$，一个双输入合取使用一个 Toffoli 门实现。\n    -   因此，评估一个子句需要 $2$ 个 Toffoli 门。\n    -   根据假设 $4$，单个 Toffoli 门的代价是 $7$ 个 $T$ 门。\n    -   所以，评估单个子句的 $T$ 门数是 $T_{\\text{clause}} = 2 \\times 7 = 14$。\n    -   因为有 $m$ 个子句，并且它们的评估是独立执行的，所以A部分的总 $T$ 门数是每个子句代价的总和：\n        $$T_{\\text{Part A}} = m \\times T_{\\text{clause}} = 14m$$\n\n    **B部分：全局合取的代价**\n    这部分接收来自子句评估的 $m$ 个输出比特，并计算它们的逻辑与。\n    -   根据假设 $6$，这个全局合取由一个双输入合取的二叉树构成。\n    -   要计算 $m$ 个比特的合取，需要 $m-1$ 次双输入合取的应用。\n    -   每个双输入合取都是一个 Toffoli 门。\n    -   因此，这部分需要 $m-1$ 个 Toffoli 门。\n    -   每个 Toffoli 门的代价为 $7$ 个 $T$ 门，因此B部分的总 $T$ 门数为：\n        $$T_{\\text{Part B}} = (m-1) \\times 7 = 7m - 7$$\n\n    **总计算 $T$ 门数 ($T_{\\text{compute}}$)**\n    计算阶段的总 $T$ 门数是A部分和B部分门数的总和：\n    $$T_{\\text{compute}} = T_{\\text{Part A}} + T_{\\text{Part B}} = 14m + (7m - 7) = 21m - 7$$\n\n5.  **最终计算：**\n    最后，我们将 $T_{\\text{compute}}$ 的表达式代回到总神谕代价的方程中：\n    $$T_{\\text{total}} = 2 \\times T_{\\text{compute}} = 2 \\times (21m - 7)$$\n    $$T_{\\text{total}} = 42m - 14$$\n\n    结果只是 $m$ 的函数。输入变量的数量 $n$ 没有出现在最终表达式中。这与给定的代价模型一致，该模型关注的是公式的逻辑结构（$m$ 个大小为 $3$ 的子句），而不是变量空间的大小 $n$。表达式 $42m - 14$ 是一个关于 $n$ 和 $m$ 的有效函数，其中对 $n$ 的依赖是平凡的。",
            "answer": "$$\\boxed{42m - 14}$$"
        }
    ]
}