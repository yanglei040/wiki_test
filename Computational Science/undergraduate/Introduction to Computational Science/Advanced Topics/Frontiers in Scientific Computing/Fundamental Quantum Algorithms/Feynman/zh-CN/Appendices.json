{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你完成一个案例研究，比较Grover算法、动态规划和分支定界法在解决一个类$0$-$1$背包问题时的表现。你的目标是学习如何进行“信封背面”式的计算来估算运行时间，并据此做出明智的选择。这个练习将证明，量子算法并非解决所有问题的万能钥匙。",
            "id": "3133884",
            "problem": "一个团队的任务是在一个 $0$-$1$ 背包式问题中，找到满足阈值可行性条件的任何物品子集。有 $n$ 个物品，每个物品都有整数重量和价值，背包容量为整数 $W$。目标是找到任何一个总重量不超过 $W$ 且总价值不低于给定阈值的子集。要求您根据预言机成本模型，在三种方法——Grover 算法、动态规划和分支定界法 (B&B)——之间做出选择，并从第一性原理出发证明您的选择。\n\n使用的基本原理：\n- 用于无结构搜索的 Grover 算法执行振幅放大，对于一个大小为 $N$、有 $M$ 个标记解的搜索空间，需要向黑盒谓词预言机进行约 $\\sqrt{N/M}$ 次查询。\n- 解决 $0$-$1$ 背包问题的标准动态规划方法会创建一个按物品和容量索引的表格，其中包含约 $nW$ 次状态转移，前提是重量和容量都是整数。\n- 分支定界法探索一个搜索树，其扩展节点的总数取决于定界质量；其运行时模型与扩展节点数乘以每个节点的定界/可行性成本成正比。\n\n场景参数：\n- 搜索空间是所有 $0$-$1$ 子集的集合，因此 $N = 2^{n}$。\n- 根据经验领域的知识，满足阈值的可行子集数量为 $M = 10^{6}$。\n- Grover 算法使用的无结构谓词预言机（用于标记可行子集）每次查询运行时间为 $C_{\\text{oracle}} = 1.0 \\times 10^{-3}$ 秒，状态准备开销为 $C_{\\text{prep}} = 1.0 \\times 10^{-1}$ 秒。\n- 动态规划适用，因为物品重量和 $W$ 都是整数且大小适中，其中 $n = 50$ 且 $W = 500$。假设大约有 $nW$ 次表格转换，每次成本为 $C_{\\text{dp}} = 5.0 \\times 10^{-6}$ 秒。\n- 在本例中，使用标准定界启发式方法的分支定界法预计平均会扩展 $B = 10^{7}$ 个节点，每个节点的组合定界/可行性成本为 $C_{\\text{bb}} = 2.5 \\times 10^{-6}$ 秒。\n\n基于这些成本模型和参数，哪种方法能产生最低的预期运行时间？\nA. Grover 算法，因为预言机调用次数的规模约为 $\\sqrt{N/M}$，且给定的 $C_{\\text{oracle}}$ 使其比经典方法更快。\nB. 动态规划，因为在给定参数下，$nW$ 次转换和给定的 $C_{\\text{dp}}$ 产生的运行时间低于 Grover 算法和分支定界法。\nC. 分支定界法，因为预期节点数乘以 $C_{\\text{bb}}$ 的结果优于 Grover 算法的预言机复杂度和动态规划的转换次数。\nD. Grover 算法，因为它总能比任何经典方法提供指数级加速，无论问题结构或参数值如何。",
            "solution": "用户要求对问题陈述进行严格验证，然后推导解决方案并评估所提供的选项。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **问题类型**：找到 $n$ 个物品的任意一个子集，其中每个物品都有整数重量和价值，使得总重量最多为容量 $W$，总价值至少为一个给定的阈值。这是 $0$-$1$ 背包问题的可行性版本。\n- **算法**：Grover 算法、动态规划 (DP)、分支定界法 (B&B)。\n- **成本模型基础**：\n    - **Grover 算法**：对于一个大小为 $N$、有 $M$ 个解的搜索空间，需要对一个谓词预言机进行 $\\mathcal{O}(\\sqrt{N/M})$ 次查询。\n    - **DP**：对于一个按物品和容量索引的表格，需要大约 $nW$ 次状态转移。\n    - **B&B**：运行时间与扩展节点数乘以每个节点的成本成正比。\n- **场景参数**：\n    - 物品数量，$n = 50$。\n    - 容量，$W = 500$。\n    - 搜索空间大小，$N = 2^{n} = 2^{50}$。\n    - 可行子集（解）的数量，$M = 10^{6}$。\n    - Grover 算法的预言机查询成本，$C_{\\text{oracle}} = 1.0 \\times 10^{-3}$ 秒。\n    - Grover 算法的状态准备开销，$C_{\\text{prep}} = 1.0 \\times 10^{-1}$ 秒。\n    - DP 转换成本，$C_{\\text{dp}} = 5.0 \\times 10^{-6}$ 秒。\n    - B&B 扩展节点数，$B = 10^{7}$。\n    - B&B 每节点成本，$C_{\\text{bb}} = 2.5 \\times 10^{-6}$ 秒。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n根据有效性标准对问题陈述进行评估。\n\n-   **科学依据**：该问题基于已建立的计算机科学和量子计算原理。背包问题是一个经典的 NP-难问题。动态规划（$\\mathcal{O}(nW)$，伪多项式）、Grover 算法（$\\mathcal{O}(\\sqrt{N/M})$ 用于无结构搜索）和分支定界法的复杂性特征是标准的。使用成本模型来估算运行时间是算法分析中一种常用且有效的方法。\n-   **适定性**：该问题是适定的。它提供了所有必要的数值参数和一个清晰、客观的目标函数——最小化预期运行时间——以比较三种指定的算法。可以从所提供的数据中得出一个唯一、稳定且有意义的答案。\n-   **客观性**：问题以精确、客观的语言陈述，没有主观或含糊不清的术语。\n\n该问题没有表现出任何列出的缺陷（科学上不健全、非形式化、设置不完整、不切实际、不适定、伪深刻或无法验证）。所有参数都已明确定义，并提供了用于计算运行时间的模型。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。将根据所提供的信息推导出解决方案。\n\n### 解决方案推导\n\n任务是计算三种方法中每一种的预期运行时间，并找出最小值。\n\n**1. Grover 算法的运行时间 ($T_{\\text{Grover}}$)**\n\n总运行时间是状态准备开销和执行预言机查询的成本之和。查询次数 $Q_{\\text{Grover}}$ 约为 $\\sqrt{N/M}$。我们将使用这个值作为估算。\n\n-   搜索空间大小：$N = 2^{n} = 2^{50}$。\n-   解的数量：$M = 10^{6}$。\n-   预言机查询次数：\n    $$Q_{\\text{Grover}} = \\sqrt{\\frac{N}{M}} = \\sqrt{\\frac{2^{50}}{10^{6}}} = \\frac{2^{25}}{10^{3}}$$\n    使用近似值 $2^{10} \\approx 10^{3}$：\n    $$2^{25} = 2^5 \\times 2^{20} = 32 \\times (2^{10})^2 \\approx 32 \\times (10^3)^2 = 3.2 \\times 10^7$$\n    一个更精确的值是 $2^{25} = 33,554,432$。\n    $$Q_{\\text{Grover}} = \\frac{33,554,432}{1000} \\approx 33,554.4$$\n-   查询总成本：\n    $$\\text{Cost}_{\\text{queries}} = Q_{\\text{Grover}} \\times C_{\\text{oracle}} \\approx 33,554.4 \\times (1.0 \\times 10^{-3} \\text{ s}) \\approx 33.55 \\text{ s}$$\n-   Grover 算法的总运行时间：\n    $$T_{\\text{Grover}} = C_{\\text{prep}} + \\text{Cost}_{\\text{queries}} = 0.1 \\text{ s} + 33.55 \\text{ s} = 33.65 \\text{ s}$$\n\n**2. 动态规划的运行时间 ($T_{\\text{DP}}$)**\n\n运行时间是表格转换总数与每次转换成本的乘积。\n\n-   物品数量：$n = 50$。\n-   容量：$W = 500$。\n-   转换次数：\n    $$\\text{Transitions}_{\\text{DP}} = n \\times W = 50 \\times 500 = 25,000 = 2.5 \\times 10^4$$\n-   动态规划的总运行时间：\n    $$T_{\\text{DP}} = \\text{Transitions}_{\\text{DP}} \\times C_{\\text{dp}} = (2.5 \\times 10^4) \\times (5.0 \\times 10^{-6} \\text{ s})$$\n    $$T_{\\text{DP}} = 12.5 \\times 10^{-2} \\text{ s} = 0.125 \\text{ s}$$\n\n**3. 分支定界法的运行时间 ($T_{\\text{B&B}}$)**\n\n运行时间是扩展节点数与每节点成本的乘积。\n\n-   扩展节点数：$B = 10^{7}$。\n-   每节点成本：$C_{\\text{bb}} = 2.5 \\times 10^{-6}$ 秒。\n-   分支定界法的总运行时间：\n    $$T_{\\text{B&B}} = B \\times C_{\\text{bb}} = 10^7 \\times (2.5 \\times 10^{-6} \\text{ s}) = 25 \\text{ s}$$\n\n**运行时间比较**\n\n-   $T_{\\text{Grover}} \\approx 33.65 \\text{ s}$\n-   $T_{\\text{DP}} = 0.125 \\text{ s}$\n-   $T_{\\text{B&B}} = 25.0 \\text{ s}$\n\n比较这些值，我们发现：\n$T_{\\text{DP}}  T_{\\text{BB}}  T_{\\text{Grover}}$\n动态规划方法产生的预期运行时间最低。\n\n### 逐项选项分析\n\n**A. Grover 算法，因为预言机调用次数的规模约为 $\\sqrt{N/M}$，且给定的 $C_{\\text{oracle}}$ 使其比经典方法更快。**\n前提是预言机调用次数的规模约为 $\\sqrt{N/M}$，这是正确的。然而，结论认为在给定参数下这是最快的方法是错误的。我们的计算显示 $T_{\\text{Grover}} \\approx 33.65$ 秒，这比动态规划（$0.125$ 秒）和分支定界法（$25.0$ 秒）都要慢。\n因此，该选项**不正确**。\n\n**B. 动态规划，因为在给定参数下，$nW$ 次转换和给定的 $C_{\\text{dp}}$ 产生的运行时间低于 Grover 算法和分支定界法。**\n该推理基于使用所提供模型的直接计算。我们的计算显示 $T_{\\text{DP}} = 0.125$ 秒，远低于 $T_{\\text{Grover}} \\approx 33.65$ 秒和 $T_{\\text{BB}} = 25.0$ 秒。该陈述完全得到定量分析的支持。\n因此，该选项**正确**。\n\n**C. 分支定界法，因为预期节点数乘以 $C_{\\text{bb}}$ 的结果优于 Grover 算法的预言机复杂度和动态规划的转换次数。**\n该选项声称 BB 是三者中最快的。我们的计算显示 $T_{\\text{BB}} = 25.0$ 秒。虽然这比 Grover 算法（$33.65$ 秒）快，但它比动态规划（$0.125$ 秒）慢得多。关于它“优于...动态规划的转换次数”的说法是错误的。\n因此，该选项**不正确**。\n\n**D. Grover 算法，因为它总能比任何经典方法提供指数级加速，无论问题结构或参数值如何。**\n这种说法根本上是错误的。Grover 算法相对于*无结构*的经典搜索提供的是二次加速，而不是指数级加速。此外，这种加速是相对于暴力搜索而言的。利用问题结构的经典算法，例如解决背包问题的伪多项式动态规划方法，可能比将 Grover 算法应用于无结构搜索空间要高效得多。本问题实例明确地展示了一个案例，其中一个经典的、利用了结构的算法 (DP) 显著优于量子搜索算法。这种说法是极大的夸张，也是对 Grover 算法能力的一个常见误解。\n因此，该选项**不正确**。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在探讨了*何时*使用Grover算法之后，这最后一个练习将聚焦于*如何*实现它。你将通过将一个为$3$-SAT问题设计的Grover预言机（oracle）分解为Clifford+$T$门组合，来估算其实际实现成本。计算总$T$门数量是容错量子计算领域的一项关键技能。",
            "id": "3133929",
            "problem": "考虑为一个具有 $n$ 个输入比特和 $m$ 个子句的合取范式（CNF）布尔公式构建一个 Grover 谕示，其中每个子句都是恰好三个文字的析取（三可满足性，也称为 $3$-SAT）。该谕示应对满足所有子句的计算基态 $|x\\rangle$ 进行相位翻转。假设采用标准的可逆“计算-相位-反计算”模式，并且电路被编译到 Clifford 加 T (Clifford+$T$) 门集中。使用以下在容错资源估算中常见的建模假设：\n\n- 每个文字要么是一个变量 $x_{j}$，要么是其否定 $\\neg x_{j}$，否定由泡利-X 门实现，该门是 Clifford 门。\n- 一个双输入析取 $a \\lor b$ 通过德摩根定律可逆地实现为 $a \\lor b = \\neg(\\neg a \\land \\neg b)$，因此其非 Clifford 代价等于一个双输入合取的代价。\n- 一个双输入合取通过使用洁净辅助量子比特的受控-受控-非门（Toffoli 门）实现。一个 Toffoli 门的非 Clifford 代价恰好为 $7$ 个 $T$ 门。\n- 一个三输入析取 $a \\lor b \\lor c$ 是通过组合两个双输入析取来构建的。\n- $m$ 个子句输出的全局合取是通过使用洁净辅助量子比特的双输入合取构成的二叉树形成的。\n- 以最终合取为条件的相位翻转由一个 Clifford 门（例如，一个受控-Z 门）实现，不产生 $T$ 门代价。\n- 在相位翻转后，所有中间值都被反计算，以将所有辅助量子比特恢复到 $|0\\rangle$ 状态。\n\n在这些假设下，推导 Grover 谕示单次应用的总 T 门计数关于 $n$ 和 $m$ 的闭式符号表达式。将你的最终答案表示为单个解析表达式。不需要四舍五入，也不涉及单位。",
            "solution": "该问题是有效的，因为它在科学上基于量子计算和资源估算的原理，问题定义良好，具有明确的目标和一组一致、可形式化的假设，并且没有任何不合格的缺陷。我现在将进行完整解答。\n\n问题要求为一个具有 $n$ 个变量和 $m$ 个子句的 $3$-SAT 问题，推导单次 Grover 谕示应用的总 T 门计数的闭式表达式。解答是基于所提供的、针对编译到 Clifford+$T$ 门集的电路的建模假设推导出来的。\n\n谕示的实现遵循标准的“计算-相位-反计算”模式。总 T 门计数（记为 $T_{\\text{total}}$）是这三个阶段 T 门计数的总和：\n$$T_{\\text{total}} = T_{\\text{compute}} + T_{\\text{phase}} + T_{\\text{uncompute}}$$\n\n让我们分析每个阶段的 T 门计数。\n\n1.  **相位阶段 ($T_{\\text{phase}}$):**\n    根据假设 $7$，施加在计算最终输出比特上的条件相位翻转，是由一个 Clifford 门（如受控-$Z$ 门）实现的。根据定义，Clifford 门的 T 门计数为零。因此，\n    $$T_{\\text{phase}} = 0$$\n\n2.  **反计算阶段 ($T_{\\text{uncompute}}$):**\n    假设 $8$ 指出，所有中间值都将被反计算，以将辅助量子比特恢复到其初始 $|0\\rangle$ 状态。这是通过反向运行计算电路来实现的。由 Clifford 和 T 门组成的电路的逆电路与原电路具有相同的 T 门计数。这是因为 T 门的逆是 $T^{\\dagger}$，其实现成本通常与 T 门相同，而像 Toffoli 门这样的其他关键门是自身的逆。因此，反计算阶段的 T 门计数等于计算阶段的 T 门计数：\n    $$T_{\\text{uncompute}} = T_{\\text{compute}}$$\n\n3.  **总 T 门计数表达式:**\n    将这些代入初始方程，谕示的总 T 门计数为：\n    $$T_{\\text{total}} = T_{\\text{compute}} + 0 + T_{\\text{compute}} = 2 \\times T_{\\text{compute}}$$\n    我们的任务简化为求出计算阶段的 T 门计数 $T_{\\text{compute}}$。\n\n4.  **计算阶段 ($T_{\\text{compute}}$):**\n    计算阶段对给定输入 $|x\\rangle$ 评估整个布尔公式。这个过程可以分为两个主要部分：\n    -   A 部分：评估 $3$-SAT 公式的全部 $m$ 个子句。\n    -   B 部分：计算所有 $m$ 个子句结果的逻辑与（合取），以获得一个最终比特，指示输入 $|x\\rangle$ 是否为满足性赋值。\n\n    让我们计算每个部分的 T 门计数。\n\n    **A 部分：评估 $m$ 个子句的代价**\n    每个子句是三个文字的析取。设一个子句为 $l_1 \\lor l_2 \\lor l_3$。\n    -   根据假设 $5$，这通过组合两个双输入析取来实现，例如，$(l_1 \\lor l_2) \\lor l_3$。\n    -   根据假设 $2$，一个双输入析取 ($a \\lor b$) 的非 Clifford 代价等于一个双输入合取的代价。\n    -   因此，一个三输入子句的非 Clifford 代价等同于两个双输入合取的代价。\n    -   根据假设 $3$，一个双输入合取使用一个 Toffoli 门实现。\n    -   因此，评估一个子句需要 $2$ 个 Toffoli 门。\n    -   根据假设 $4$，单个 Toffoli 门的代价是 $7$ 个 $T$ 门。\n    -   所以，评估单个子句的 T 门计数为 $T_{\\text{clause}} = 2 \\times 7 = 14$。\n    -   因为有 $m$ 个子句，并且它们的评估是独立执行的，所以 A 部分的总 T 门计数是每个子句代价的总和：\n        $$T_{\\text{Part A}} = m \\times T_{\\text{clause}} = 14m$$\n\n    **B 部分：全局合取的代价**\n    这部分接收来自子句评估的 $m$ 个输出比特，并计算它们的逻辑与。\n    -   根据假设 $6$，这个全局合取是由双输入合取构成的二叉树形成的。\n    -   为计算 $m$ 个比特的合取，需要 $m-1$ 次双输入合取的应用。\n    -   每个双输入合取都是一个 Toffoli 门。\n    -   因此，这部分需要 $m-1$ 个 Toffoli 门。\n    -   每个 Toffoli 门花费 $7$ 个 $T$ 门，B 部分的总 T 门计数为：\n        $$T_{\\text{Part B}} = (m-1) \\times 7 = 7m - 7$$\n\n    **计算阶段总 T 门计数 ($T_{\\text{compute}}$)**\n    计算阶段的总 T 门计数是 A 部分和 B 部分计数的总和：\n    $$T_{\\text{compute}} = T_{\\text{Part A}} + T_{\\text{Part B}} = 14m + (7m - 7) = 21m - 7$$\n\n5.  **最终计算:**\n    最后，我们将 $T_{\\text{compute}}$ 的表达式代回到总谕示代价的方程中：\n    $$T_{\\text{total}} = 2 \\times T_{\\text{compute}} = 2 \\times (21m - 7)$$\n    $$T_{\\text{total}} = 42m - 14$$\n\n    结果仅是 $m$ 的函数。输入变量的数量 $n$ 没有出现在最终表达式中。这与给定的代价模型一致，该模型关注的是公式的逻辑结构（$m$ 个大小为 $3$ 的子句），而不是变量空间的大小 $n$。表达式 $42m - 14$ 是一个关于 $n$ 和 $m$ 的有效函数，其中对 $n$ 的依赖是平凡的。",
            "answer": "$$\\boxed{42m - 14}$$"
        }
    ]
}