{
    "hands_on_practices": [
        {
            "introduction": "数字量子模拟的核心思想之一是将连续的时间演化分解为一系列离散的量子门操作。Trotter-Suzuki 分解是实现这一目标的基本方法。通过这个练习 ，你将亲手实现这一核心技术，并探索在真实量子模拟中一个至关重要的问题：门操作的瑕疵如何影响量子态的幺正性和范数守恒，这有助于你深入理解模拟误差的来源和影响。",
            "id": "3181193",
            "problem": "考虑一个具有 $N$ 个格点和周期性边界条件的一维晶格。量子态由一个复向量 $\\psi \\in \\mathbb{C}^N$ 表示，其分量为 $\\psi(x,t)$，其中 $x \\in \\{0,1,\\dots,N-1\\}$ 是晶格格点的索引，$t$ 表示时间。演化由含时 Schrödinger 方程 $i \\frac{d}{dt} \\lvert \\psi(t) \\rangle = H \\lvert \\psi(t) \\rangle$ 控制，其中 $H = T + V$ 是一个由动能（跃迁）项 $T$ 和在位势 $V$ 组成的厄米哈密顿量。动能项为 $T = -J \\sum_{x=0}^{N-1} \\left( \\lvert x \\rangle \\langle x+1 \\rvert + \\lvert x+1 \\rangle \\langle x \\rvert \\right)$，其中加法是模 $N$ 运算；势能项为 $V = \\sum_{x=0}^{N-1} V_x \\lvert x \\rangle \\langle x \\rvert$，其中 $V_x = V_0 \\cos\\left( \\frac{2\\pi x}{N} \\right)$。时间演化通过一阶 Trotter 分解进行近似：一个时长为 $\\Delta t$ 的离散步长，先将 $U_V = e^{-i V \\Delta t}$ 作用于量子态，然后作用 $U_T = e^{-i T \\Delta t}$。在精确算术和完美门操作下，演化算符是幺正的，范数 $\\sum_x \\lvert \\psi(x,t) \\rvert^2$ 在每一步都守恒。\n\n为研究门不完美性的影响，我们通过一个均匀泄漏算符 $L(\\delta) = (1-\\delta) I$（其中 $0 \\le \\delta \\ll 1$）来模拟有限的门错误，该算符在每个门操作后立即作用。这种泄漏模拟了振幅损失到模拟的希尔伯特空间（计算子空间）之外的自由度，因此在模拟的子空间上是非幺正的。在每个 Trotter 步中，依次施加 $U_V$、 $L(\\delta)$、$U_T$ 和 $L(\\delta)$。\n\n从归一化的初始条件 $\\psi(x,0) = 1$（当 $x=0$）和 $\\psi(x,0) = 0$（当 $x \\neq 0$）开始，实现上述演化共 $M$ 个离散步。在每个 Trotter 步 $k$ 之后（即在序列 $U_V, L(\\delta), U_T, L(\\delta)$ 作用一次之后），计算范数 $n_k = \\sum_{x=0}^{N-1} \\lvert \\psi(x,t_k) \\rvert^2$，并在无错误情况下验证范数守恒性质。通过报告单一指标 $D = \\max_{1 \\le k \\le M} \\lvert 1 - n_k \\rvert$ 来量化由有限门错误引起的漂移，该指标是范数在所有步骤中与 1 的最大绝对偏差。\n\n所有量均使用无量纲单位。角度是无量纲的相位；无需进行角度单位转换。\n\n您的程序必须模拟此演化，并针对下方的参数集，输出每种情况下的漂移指标 $D$。将报告的每个 $D$ 四舍五入到六位小数。最终输出必须是单行，包含用方括号括起来的、以逗号分隔的结果列表。\n\n测试套件（每个元组为 $(N, J, V_0, \\Delta t, M, \\delta)$）：\n- 情况 1：$(8, 1.0, 0.0, 0.10, 100, 0.0)$。\n- 情况 2：$(8, 1.0, 0.5, 0.05, 200, 0.0)$。\n- 情况 3：$(8, 1.0, 0.5, 0.05, 200, 1.0 \\times 10^{-4})$。\n- 情况 4：$(8, 1.0, 0.5, 0.05, 10, 5.0 \\times 10^{-2})$。\n- 情况 5：$(8, 1.0, 1.0, 0.50, 20, 0.0)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[D_1,D_2,D_3,D_4,D_5]$），其中每个 $D_i$ 是情况 $i$ 的漂移指标，四舍五入到六位小数。",
            "solution": "该问题要求模拟一维晶格上的量子系统，并量化由模拟的门错误引起的范数偏差。该过程涉及构建哈密顿量，通过 Trotter 分解实现时间演化，并计算特定的误差指标。\n\n**1. 系统表示**\n\n系统的量子态是一个向量 $\\lvert \\psi \\rangle \\in \\mathbb{C}^N$，其中 $N$ 是晶格格点数。在计算实现中，这表示为一个大小为 $N$、数据类型为复数的 `numpy` 数组。初始条件为 $\\psi(x,0) = 1$（当 $x=0$）及其他情况为 $\\psi(x,0) = 0$，这对应于一个在第一个分量为 $1$、其余分量为 $0$ 的状态向量。这是一个归一化态，即 $\\langle \\psi(0) \\mid \\psi(0) \\rangle = \\sum_{x=0}^{N-1} \\lvert \\psi(x,0) \\rvert^2 = 1$。\n\n**2. 哈密顿量与演化算符**\n\n时间演化由 Schrödinger 方程 $i \\frac{d}{dt} \\lvert \\psi(t) \\rangle = H \\lvert \\psi(t) \\rangle$ 控制。对于一个微小时间步长 $\\Delta t$，演化算符近似为 $U(\\Delta t) \\approx e^{-i H \\Delta t}$。哈密顿量 $H$ 是动能项 $T$ 和势能项 $V$ 的和。\n\n- **势能算符 ($V$):** 势能是一个在位项 $V = \\sum_{x=0}^{N-1} V_x \\lvert x \\rangle \\langle x \\rvert$，其中 $V_x = V_0 \\cos(\\frac{2\\pi x}{N})$。此算符在位置基 $\\{\\lvert x \\rangle\\}$ 中是对角的。相应的演化算符 $U_V = e^{-i V \\Delta t}$ 也是对角的，其矩阵元为 $(U_V)_{xx} = e^{-i V_x \\Delta t}$。将其作用于状态向量 $\\psi$ 是一种高效的逐元素乘法：$(\\psi')_x = e^{-i V_x \\Delta t} \\psi_x$。\n\n- **动能算符 ($T$):** 动能项是一个跃迁项 $T = -J \\sum_{x=0}^{N-1} \\left( \\lvert x \\rangle \\langle x+1 \\rvert + \\lvert x+1 \\rangle \\langle x \\rvert \\right)$，其中加法是模 $N$ 运算。在位置基中，这是一个实的、对称的 $N \\times N$ 矩阵。对角元为 $0$，第一超对角线和次对角线上的元素为 $-J$。由于周期性边界条件，元素 $T_{0,N-1}$ 和 $T_{N-1,0}$ 也为 $-J$。动能部分的演化算符是 $U_T = e^{-i T \\Delta t}$。由于 $T$ 不是对角矩阵，其指数必须使用数值矩阵指数算法计算，例如 `scipy.linalg.expm` 提供的算法。算符 $T$ 和 $V$ 是厄米算符，因此 $U_T$ 和 $U_V$ 是幺正算符。\n\n**3. 带误差的 Trotter 演化**\n\n该问题指定使用一阶 Trotter-Suzuki 分解来近似完整的演化算符 $e^{-i(T+V)\\Delta t}$。理想演化的单步操作是先施加 $U_V$ 再施加 $U_T$，得到组合算符 $U_{\\text{Trotter}} = U_T U_V$。由于 $U_T$ 和 $U_V$ 是幺正的，它们的乘积 $U_{\\text{Trotter}}$ 也是幺正的，这保证了态范数的守恒：$\\lVert U_{\\text{Trotter}} \\psi \\rVert^2 = \\lVert \\psi \\rVert^2$。\n\n门错误由一个非幺正的泄漏算符 $L(\\delta) = (1-\\delta)I$ 建模，该算符在每个幺正门之后施加。状态向量从第 $k$ 步的 $\\psi_k$ 到第 $k+1$ 步的 $\\psi_{k+1}$ 的演化由下式给出：\n$$\n\\lvert \\psi_{k+1} \\rangle = L(\\delta) U_T L(\\delta) U_V \\lvert \\psi_k \\rangle\n$$\n当 $\\delta > 0$ 时，该算符不是幺正的。设 $n_k = \\lVert \\psi_k \\rVert^2$ 为第 $k$ 步的范数。范数演化如下：\n$$\nn_{k+1} = \\lVert L(\\delta) U_T L(\\delta) U_V \\psi_k \\rVert^2 = \\langle \\psi_k \\rvert U_V^\\dagger L(\\delta)^\\dagger U_T^\\dagger L(\\delta)^\\dagger L(\\delta) U_T L(\\delta) U_V \\lvert \\psi_k \\rangle\n$$\n由于 $L(\\delta)$ 是一个标量算符 $(1-\\delta)I$，且 $U_T, U_V$ 是幺正的，上式可简化为：\n$$\nn_{k+1} = (1-\\delta)^2 \\cdot (1-\\delta)^2 \\cdot \\langle \\psi_k \\rvert U_V^\\dagger U_T^\\dagger U_T U_V \\lvert \\psi_k \\rangle = (1-\\delta)^4 n_k\n$$\n从 $n_0=1$ 开始，经过 $k$ 步后的范数为 $n_k = ((1-\\delta)^4)^k = (1-\\delta)^{4k}$。\n\n**4. 模拟算法与指标计算**\n\n对于每组参数 $(N, J, V_0, \\Delta t, M, \\delta)$，模拟算法按以下步骤进行：\n\n1.  **初始化：** 创建初始状态向量 $\\psi$，其中 $\\psi_0=1$，而对于 $x>0$ 则 $\\psi_x=0$。\n2.  **算符构建：**\n    a. 构建势能值向量 $V_x$，并由此构建乘法相位因子向量 $e^{-i V_x \\Delta t}$。\n    b. 构建 $N \\times N$ 的动能矩阵 $T$。\n    c. 在时间步进循环开始前，计算一次动能演化矩阵 $U_T = e^{-i T \\Delta t}$。\n3.  **时间演化：** 对 $k$ 从 1 到 $M$ 进行循环：\n    a. 施加势能演化算符：$\\psi \\leftarrow U_V \\psi$（逐元素相乘）。\n    b. 施加第一个泄漏算符：$\\psi \\leftarrow (1-\\delta) \\psi$（标量相乘）。\n    c. 施加动能演化算符：$\\psi \\leftarrow U_T \\psi$（矩阵-向量相乘）。\n    d. 施加第二个泄漏算符：$\\psi \\leftarrow (1-\\delta) \\psi$（标量相乘）。\n    e. 在完成这完整一步后，计算范数的平方 $n_k = \\sum_{x=0}^{N-1} \\lvert \\psi_x \\rvert^2$。\n    f. 记录此步的偏差：$|1 - n_k|$。\n4.  **指标计算：** 最终的漂移指标 $D$ 是在所有 $M$ 步中记录的最大偏差：$D = \\max_{1 \\le k \\le M} |1 - n_k|$。\n\n对于 $\\delta=0$ 的情况，泄漏算符是单位算符 $L(0) = I$。演化是幺正的，范数在每一步都守恒。因此，在浮点算术精度范围内，偏差 $|1-n_k|$ 应为 $0$。对于 $\\delta>0$ 的情况，范数会衰减，偏差 $|1 - n_k| = 1 - (1-\\delta)^{4k}$ 随 $k$ 增加。因此，最大偏差将出现在最后一步，即 $k=M$，从而得到 $D = 1 - (1-\\delta)^{4M}$。\n\n所提供的 Python 代码实现了该算法。它遍历每个测试用例，执行模拟，计算 $D$，并按规定格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Simulates the quantum evolution on a 1D lattice and calculates the norm drift.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 1.0, 0.0, 0.10, 100, 0.0),            # Case 1\n        (8, 1.0, 0.5, 0.05, 200, 0.0),            # Case 2\n        (8, 1.0, 0.5, 0.05, 200, 1.0e-4),         # Case 3\n        (8, 1.0, 0.5, 0.05, 10, 5.0e-2),          # Case 4\n        (8, 1.0, 1.0, 0.50, 20, 0.0),             # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, J, V0, dt, M, delta = case\n\n        # 1. Initialization\n        # a. Initial state: psi(x,0) = 1 for x=0, 0 otherwise.\n        psi = np.zeros(N, dtype=np.complex128)\n        psi[0] = 1.0 + 0.0j\n\n        # 2. Operator Construction\n        # a. Potential evolution operator U_V (as element-wise multiplicative factors)\n        x_sites = np.arange(N)\n        V_diag = V0 * np.cos(2 * np.pi * x_sites / N)\n        U_V_factors = np.exp(-1j * V_diag * dt)\n\n        # b. Kinetic operator T\n        T = np.zeros((N, N), dtype=np.float64)\n        for i in range(N):\n            T[i, (i + 1) % N] = -J\n            T[i, (i - 1 + N) % N] = -J\n        \n        # c. Kinetic evolution operator U_T\n        U_T = expm(-1j * T * dt)\n\n        # d. Leakage factor\n        leakage_factor = 1.0 - delta\n\n        # 3. Time Evolution Loop\n        deviations = []\n        for _ in range(M):\n            # Apply U_V\n            psi = U_V_factors * psi\n            \n            # Apply first leakage L(delta)\n            psi = leakage_factor * psi\n            \n            # Apply U_T\n            psi = U_T @ psi\n            \n            # Apply second leakage L(delta)\n            psi = leakage_factor * psi\n\n            # Calculate and store the norm deviation for the current step\n            norm_k = np.sum(np.abs(psi)**2)\n            deviations.append(np.abs(1.0 - norm_k))\n\n        # 4. Metric Calculation\n        # The drift D is the maximum absolute deviation over all M steps.\n        if not deviations:\n            D = 0.0\n        else:\n            D = np.max(deviations)\n        \n        results.append(D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个可靠的模拟不仅要在数值上稳定，更必须尊重其所模拟系统的基本物理定律。哈密顿量的对称性会导致某些物理量的守恒。本练习  旨在探索在环境噪声存在的情况下，这些守恒定律的行为，我们将使用林德布拉德主方程（Lindblad master equation）来模拟这一过程。通过实现这个模拟，你将深入了解哈密顿量对称性、噪声模型以及开放量子系统中物理可观测量守恒性之间的关键联系。",
            "id": "3181239",
            "problem": "您的任务是使用马尔可夫开放系统模型，在一次量子模拟中验证一条守恒律。考虑一个由 $n$ 个量子比特组成的链，其泡利算符为 $X$、$Y$ 和 $Z$，哈密顿量定义为\n$$\nH = \\sum_{i=1}^{n-1} J Z_i Z_{i+1} + \\sum_{i=1}^{n} h_i Z_i,\n$$\n其中 $J$ 是一个实的最近邻耦合系数，$h_i$ 是实的在位场。设守恒的可观测量为 $z$ 基下的总磁化强度\n$$\nA = \\sum_{i=1}^{n} Z_i.\n$$\n对于这个哈密顿量 $H$，有 $[H, A] = 0$，因此在由 $H$ 生成的幺正演化下，可观测量 $A$ 是守恒的。\n\n为了引入噪声，我们使用密度矩阵 $\\rho(t)$ 的马尔可夫 Lindblad 主方程：\n$$\n\\frac{d\\rho}{dt} = -i[H, \\rho] + \\sum_k \\left(L_k \\rho L_k^\\dagger - \\frac{1}{2}\\{L_k^\\dagger L_k, \\rho\\}\\right),\n$$\n其中 $\\{X,Y\\} = XY + YX$ 表示反对易子，$L_k$ 是定义噪声通道的塌缩算符。必须考虑两种噪声通道：\n- $z$ 基下的纯退相干：对于每个格点 $k$，$L_k = \\sqrt{\\gamma} Z_k$，其中 $\\gamma \\ge 0$ 是退相干速率。\n- 比特翻转噪声：对于每个格点 $k$，$L_k = \\sqrt{\\gamma} X_k$，其中 $\\gamma \\ge 0$ 是翻转速率。\n\n$A$ 在时间 $t$ 的期望值为 $\\langle A \\rangle_t = \\operatorname{Tr}(A \\rho(t))$。您的程序必须：\n1. 根据给定参数构建 $H$ 和 $A$，并通过计算弗罗贝尼乌斯范数 $\\|[H, A]\\|_F$ 来数值验证 $[H, A] = 0$，确保其值低于一个小的容差。\n2. 使用超算符（刘维尔算符）表示，在 Lindblad 方程下从一个初始纯乘积态演化 $\\rho(t)$，并计算在多个时间点 $t \\in \\{0, T/4, T/2, 3T/4, T\\}$ 的 $\\langle A \\rangle_t$。\n3. 验证对于保持对称性的噪声（$L_k \\propto Z_k$），$\\langle A \\rangle_t$ 是否随时间保持恒定，并检测它何时不保持恒定（例如，在比特翻转噪声下）。使用 $10^{-7}$ 的绝对容差来判断恒定性，即如果 $\\max_t |\\langle A \\rangle_t - \\langle A \\rangle_0| \\le 10^{-7}$，则报告成功。\n\n时间是无量纲的（任意单位），所有速率的单位都与所选时间单位一致，为逆时间单位。\n\n实现以下参数值的测试套件：\n- 测试用例 1（正常路径，非零退相干）：$n = 3$，$J = 1.0$，$h = [0.3, -0.2, 0.5]$，噪声类型 $=$ 退相干，$\\gamma = 0.4$，$T = 2.0$，初始态 $|0\\rangle \\otimes |0\\rangle \\otimes |+\\rangle$，其中 $|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}$。\n- 测试用例 2（边界情况，零噪声）：$n = 3$，$J = 1.0$，$h = [0.3, -0.2, 0.5]$，噪声类型 $=$ 退相干，$\\gamma = 0.0$，$T = 1.5$，初始态 $|0\\rangle \\otimes |0\\rangle \\otimes |+\\rangle$。\n- 测试用例 3（边缘情况，较小系统上的更强退相干）：$n = 2$，$J = 0.7$，$h = [0.1, -0.05]$，噪声类型 $=$ 退相干，$\\gamma = 2.0$，$T = 3.0$，初始态 $|0\\rangle \\otimes |+\\rangle$。\n- 测试用例 4（对称性破缺噪声）：$n = 3$，$J = 1.0$，$h = [0.0, 0.0, 0.0]$，噪声类型 $=$ 比特翻转，$\\gamma = 0.2$，$T = 3.0$，初始态 $|0\\rangle \\otimes |0\\rangle \\otimes |+\\rangle$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），每个结果都是一个布尔值，指示在给定测试用例中，$\\langle A \\rangle_t$ 是否在指定容差内保持恒定。",
            "solution": "该问题是有效的。它在科学上基于开放量子系统的原理，问题陈述清晰，定义了所有必要的参数和条件，并且表述客观。它要求在两种不同的噪声模型下对一个量子系统进行数值模拟，以验证一条守恒律，这是计算量子物理学中一个标准且有意义的练习。\n\n解决方案如下：\n\n首先，我们建立量子系统的数学表示。一个由 $n$ 个量子比特组成的系统存在于维度为 $D = 2^n$ 的希尔伯特空间中。基态是单量子比特态的张量积。一个仅在第 $k$ 个量子比特上非平凡作用的算符 $O_k$ 在 $D \\times D$ 空间中由克罗内克积 $I^{\\otimes(k-1)} \\otimes O \\otimes I^{\\otimes(n-k)}$ 表示，其中 $I$ 是 $2 \\times 2$ 的单位矩阵。\n\n哈密顿量 $H = \\sum_{i=1}^{n-1} J Z_i Z_{i+1} + \\sum_{i=1}^{n} h_i Z_i$ 和可观测量 $A = \\sum_{i=1}^{n} Z_i$ 通过对其各项的矩阵表示求和，构建为 $D \\times D$ 的矩阵。我们通过数值计算对易子矩阵 $HA - AH$ 的弗罗贝尼乌斯范数来验证守恒条件 $[H, A] = 0$。从解析上看，这个对易子为零，因为所有涉及的算符（$Z_i$）都相互对易。在数值上，该范数应在机器精度范围内接近于零。\n\n系统密度矩阵 $\\rho(t)$ 的时间演化由 Lindblad 主方程控制：\n$$\n\\frac{d\\rho}{dt} = \\mathcal{L}(\\rho) = -i[H, \\rho] + \\sum_k \\left(L_k \\rho L_k^\\dagger - \\frac{1}{2}\\{L_k^\\dagger L_k, \\rho\\}\\right)\n$$\n这是一个关于密度矩阵 $\\rho$ 的线性一阶微分方程。为了数值求解，我们通过将 $D \\times D$ 的密度矩阵 $\\rho$ “向量化”为一个 $D^2 \\times 1$ 的列向量 $|\\rho\\rangle\\rangle$，将其转换为一个矩阵-向量方程。应用此变换后，Lindblad 方程变为 $\\frac{d|\\rho\\rangle\\rangle}{dt} = \\mathcal{L}_{\\text{matrix}} |\\rho\\rangle\\rangle$，其中 $\\mathcal{L}_{\\text{matrix}}$ 是一个 $D^2 \\times D^2$ 的矩阵，称为刘维尔超算符。\n\n对于按列向量化（将 $\\rho$ 的列堆叠起来），刘维尔超算符由以下公式给出：\n$$\n\\mathcal{L}_{\\text{matrix}} = -i(I_D \\otimes H - H^T \\otimes I_D) + \\sum_k \\left( L_k^* \\otimes L_k - \\frac{1}{2} I_D \\otimes L_k^\\dagger L_k - \\frac{1}{2} (L_k^\\dagger L_k)^T \\otimes I_D \\right)\n$$\n这里，$\\otimes$ 是克罗内克积，$I_D$ 是 $D \\times D$ 的单位矩阵，$*$ 表示复共轭，$T$ 表示转置。塌缩算符 $L_k$ 根据指定的噪声模型构建（退相干：$L_k = \\sqrt{\\gamma}Z_k$；比特翻转：$L_k = \\sqrt{\\gamma}X_k$）。\n\n向量化主方程的形式解为 $|\\rho(t)\\rangle\\rangle = e^{\\mathcal{L}_{\\text{matrix}} t} |\\rho(0)\\rangle\\rangle$。我们通过使用 `scipy.linalg.expm` 计算刘维尔算符的矩阵指数来计算演化过程。\n\n对于每个测试用例，我们首先从给定的纯乘积态 $|\\psi_0\\rangle$ 构建初始密度矩阵 $\\rho(0) = |\\psi_0\\rangle\\langle\\psi_0|$。然后我们将 $\\rho(0)$ 向量化得到 $|\\rho(0)\\rangle\\rangle$。在每个所需的时间 $t$，我们计算 $|\\rho(t)\\rangle\\rangle = e^{\\mathcal{L}_{\\text{matrix}} t} |\\rho(0)\\rangle\\rangle$，将其重塑为 $D \\times D$ 的矩阵 $\\rho(t)$，并计算期望值 $\\langle A \\rangle_t = \\operatorname{Tr}(A \\rho(t))$。\n\n最后，我们检查 $\\langle A \\rangle_t$ 的守恒性。我们在指定的时间点上计算最大绝对偏差 $\\max_t |\\langle A \\rangle_t - \\langle A \\rangle_0|$。如果此偏差小于或等于给定的 $10^{-7}$ 容差，则认为该可观测量是恒定的，结果为 `True`；否则为 `False`。\n\n预期结果是，对于退相干噪声（$L_k \\propto Z_k$），可观测量 $A = \\sum_j Z_j$ 是守恒的，因为对于所有的 $k$ 都有 $[A, L_k] = 0$。相反，对于比特翻转噪声（$L_k \\propto X_k$），$[A, L_k] \\neq 0$，因此期望值 $\\langle A \\rangle_t$ 预计不会保持恒定。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the quantum simulation problem by constructing the system,\n    evolving it under the Lindblad master equation, and checking for\n    the conservation of an observable.\n    \"\"\"\n    # Define single-qubit Pauli matrices and basis states\n    I_1 = np.array([[1, 0], [0, 1]], dtype=complex)\n    X_1 = np.array([[0, 1], [1, 0]], dtype=complex)\n    Z_1 = np.array([[1, 0], [0, -1]], dtype=complex)\n    s0 = np.array([[1], [0]], dtype=complex)  # |0>\n    s1 = np.array([[0], [1]], dtype=complex)  # |1>\n    s_plus = (s0 + s1) / np.sqrt(2)         # |+>\n\n    def get_operator(op, k, n):\n        \"\"\"\n        Constructs the n-qubit operator for a single-qubit operator `op`\n        acting on qubit `k` (0-indexed).\n        \"\"\"\n        op_list = [I_1] * n\n        op_list[k] = op\n        \n        full_op = op_list[0]\n        for i in range(1, n):\n            full_op = np.kron(full_op, op_list[i])\n        return full_op\n\n    test_cases = [\n        (3, 1.0, [0.3, -0.2, 0.5], 'dephasing', 0.4, 2.0, [s0, s0, s_plus]),\n        (3, 1.0, [0.3, -0.2, 0.5], 'dephasing', 0.0, 1.5, [s0, s0, s_plus]),\n        (2, 0.7, [0.1, -0.05], 'dephasing', 2.0, 3.0, [s0, s_plus]),\n        (3, 1.0, [0.0, 0.0, 0.0], 'bit-flip', 0.2, 3.0, [s0, s0, s_plus])\n    ]\n    \n    results = []\n    CONSTANCY_TOLERANCE = 1e-7\n\n    for n, J, h, noise_type, gamma, T, initial_state_kets in test_cases:\n        dim = 2**n\n        Id_dim = np.eye(dim, dtype=complex)\n        \n        # Construct Hamiltonian H\n        H = np.zeros((dim, dim), dtype=complex)\n        for i in range(n - 1):\n            H += J * (get_operator(Z_1, i, n) @ get_operator(Z_1, i + 1, n))\n        for i in range(n):\n            H += h[i] * get_operator(Z_1, i, n)\n            \n        # Construct observable A\n        A = np.zeros((dim, dim), dtype=complex)\n        for i in range(n):\n            A += get_operator(Z_1, i, n)\n\n        # Verification step: Check if [H, A] is numerically zero\n        comm_H_A = H @ A - A @ H\n        norm_comm = np.linalg.norm(comm_H_A, 'fro')\n        assert norm_comm  1e-9, f\"[H,A] should be zero, but norm is {norm_comm}\"\n\n        # Construct initial density matrix rho0\n        psi0 = initial_state_kets[0]\n        for i in range(1, n):\n            psi0 = np.kron(psi0, initial_state_kets[i])\n        rho0 = psi0 @ psi0.conj().T\n        \n        # Construct Liouvillian superoperator\n        # Unitary part: -i * (I kron H - H.T kron I)\n        L_unitary = -1j * (np.kron(Id_dim, H) - np.kron(H.T, Id_dim))\n        \n        # Dissipative part\n        L_dissipative = np.zeros((dim**2, dim**2), dtype=complex)\n        if gamma > 0:\n            if noise_type == 'dephasing':\n                L_op_base = Z_1\n            elif noise_type == 'bit-flip':\n                L_op_base = X_1\n            else:\n                raise ValueError(f\"Unknown noise type: {noise_type}\")\n            \n            for k in range(n):\n                Lk = np.sqrt(gamma) * get_operator(L_op_base, k, n)\n                Lk_dag_Lk = Lk.conj().T @ Lk\n                \n                # Dissipator for Lk based on column-vectorization convention\n                # Lk* kron Lk - 0.5 * I kron (Lk_dag Lk) - 0.5 * (Lk_dag Lk).T kron I\n                term1 = np.kron(Lk.conj(), Lk)\n                term2 = -0.5 * np.kron(Id_dim, Lk_dag_Lk)\n                term3 = -0.5 * np.kron(Lk_dag_Lk.T, Id_dim)\n                L_dissipative += term1 + term2 + term3\n        \n        Liouvillian = L_unitary + L_dissipative\n        \n        # Evolve state and compute expectation values\n        rho0_vec = rho0.flatten('F') # Column-vectorize\n        time_points = [0, T / 4.0, T / 2.0, 3.0 * T / 4.0, T]\n        exp_A_values = []\n        \n        for t in time_points:\n            # Evolve vectorized density matrix: |rho(t)>> = exp(L*t) |rho(0)>>\n            if t == 0:\n                rhot_vec = rho0_vec\n            else:\n                U_super = expm(Liouvillian * t)\n                rhot_vec = U_super @ rho0_vec\n            \n            # Reshape back to matrix form\n            rhot = rhot_vec.reshape((dim, dim), order='F')\n            \n            # Compute expectation value\n            exp_val = np.trace(A @ rhot).real\n            exp_A_values.append(exp_val)\n\n        # Check for conservation\n        exp_A_values = np.array(exp_A_values)\n        max_deviation = np.max(np.abs(exp_A_values - exp_A_values[0]))\n        \n        results.append(max_deviation = CONSTANCY_TOLERANCE)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了模拟已知系统，量子动力学的一个更强大应用是从实验数据中学习未知系统的特性。这个练习将通常的模拟过程反转过来：你将利用一个量子比特布洛赫矢量（Bloch vector）的时间演化数据（其中包含了模拟的测量噪声），来反向推断并重构出驱动其演化的底层哈密顿量。这个练习  将量子动力学模拟与线性回归等经典数据处理技术相结合，为你提供在量子系统表征这一前沿领域的动手实践经验。",
            "id": "3181125",
            "problem": "您将通过从可观测量带噪声的时间序列测量中重建一个未知的、不随时间变化的哈密顿量，并量化在有限测量次数和有限时间步长下的重建误差，来实现单量子比特的哈密顿量学习。在自然单位制下进行计算，并将约化普朗克常数设为 $1$，从而使所有量均为无量纲量。未知的哈密顿量形式为 $H = \\tfrac{1}{2}\\,\\mathbf{h}\\cdot\\boldsymbol{\\sigma}$，其中 $\\mathbf{h} \\in \\mathbb{R}^3$ 是一个未知向量，$\\boldsymbol{\\sigma} = (\\sigma_x,\\sigma_y,\\sigma_z)$ 是泡利算符。一个纯初始态由其布洛赫向量 $\\mathbf{r}(0) \\in \\mathbb{R}^3$ 表示，且 $\\|\\mathbf{r}(0)\\|=1$。其布洛赫向量 $\\mathbf{r}(t)$ 在由 $H$ 生成的动力学下随时间演化。\n\n基本和建模假设：\n- 海森堡运动方程指出，对于任意可观测量 $O$，有 $\\tfrac{d}{dt}\\langle O\\rangle = i \\langle [H,O]\\rangle$；泡利对易关系指出 $[\\sigma_a,\\sigma_b]=2i\\sum_{c}\\epsilon_{abc}\\sigma_c$，其中 $\\epsilon_{abc}$ 是列维-奇维塔符号。\n- 对于哈密顿量为 $H=\\tfrac{1}{2}\\,\\mathbf{h}\\cdot\\boldsymbol{\\sigma}$ 的单量子比特，布洛赫向量遵循 $\\tfrac{d}{dt}\\mathbf{r}(t)=\\mathbf{h}\\times \\mathbf{r}(t)$，其中 $\\times$ 表示向量叉积。\n- 在时间 $t$ 对 $\\sigma_k$ 进行投影测量，会得到 $\\{+1,-1\\}$ 中的一个结果，其概率分别为 $p_{+}(t)=\\tfrac{1+\\langle\\sigma_k\\rangle_t}{2}$ 和 $p_{-}(t)=\\tfrac{1-\\langle\\sigma_k\\rangle_t}{2}$，其中 $\\langle\\sigma_k\\rangle_t=r_k(t)$ 是 $\\mathbf{r}(t)$ 的第 $k$ 个分量。通过 $N$ 次独立测量（shots），样本均值是 $r_k(t)$ 的一个无偏估计量，其方差随 $1/N$ 减小。\n\n您的程序必须：\n1. 将真实的哈密顿量参数向量固定为 $\\mathbf{h}_{\\text{true}} = (0.9,-1.2,0.7)$，并将初始布洛赫向量固定为 $\\mathbf{r}(0) = \\dfrac{(0.3,0.8,0.5)}{\\|(0.3,0.8,0.5)\\|}$。\n2. 模拟由动力学方程 $\\tfrac{d}{dt}\\mathbf{r}(t)=\\mathbf{h}\\times \\mathbf{r}(t)$ 所隐含的布洛赫向量 $\\mathbf{r}(t)$ 的精确无噪声时间演化。您可以在离散时间点 $t_k = k\\,\\Delta t$（其中 $k=0,1,\\dots,N_t-1$）使用任何与所述定律一致的正确方法来计算 $\\mathbf{r}(t_k)$（例如，通过幺正演化传播状态，或使用布洛赫向量绕轴 $\\mathbf{h}$ 的旋转）。\n3. 对每个泡利可观测量 $\\sigma_x, \\sigma_y, \\sigma_z$，在每个时间点 $t_k$ 模拟有限次测量。具体方法为：根据精确期望值决定的概率，抽取 $N$ 个在 $\\{+1,-1\\}$ 中的结果，并计算每个分量的样本均值，从而得到一个带噪声的估计值 $\\widehat{\\mathbf{r}}(t_k)$。\n4. 使用中心有限差分法，根据带噪声的估计值来估计内部时间点的导数 $\\tfrac{d}{dt}\\mathbf{r}(t)$：对于 $k=1,\\dots,N_t-2$，设定 $\\widehat{\\dot{\\mathbf{r}}}(t_k) = \\dfrac{\\widehat{\\mathbf{r}}(t_{k+1}) - \\widehat{\\mathbf{r}}(t_{k-1})}{2\\,\\Delta t}$。\n5. 使用线性回归从关系式 $\\dot{\\mathbf{r}}(t) = \\mathbf{h}\\times \\mathbf{r}(t)$ 中估计 $\\mathbf{h}$。将其写成一个线性系统 $\\dot{\\mathbf{r}}(t_k)=C(\\mathbf{r}(t_k))\\,\\mathbf{h}$，其中 $C(\\mathbf{r})$ 是一个 $3\\times 3$ 矩阵\n$$\nC(\\mathbf{r})=\\begin{bmatrix}\n0  r_z  -r_y\\\\\n-r_z  0  r_x\\\\\nr_y  -r_x  0\n\\end{bmatrix}.\n$$\n通过将所有内部时间点的数据堆叠起来，构建一个超定系统：左侧为 $C(\\widehat{\\mathbf{r}}(t_k))$，右侧为 $\\widehat{\\dot{\\mathbf{r}}}(t_k)$。然后计算最小二乘估计值 $\\widehat{\\mathbf{h}}$，使其最小化残差平方和。在这里，您必须使用普通最小二乘法（OLS），即无加权、无额外正则化的最小二乘法。\n6. 对每个测试用例，将重建误差量化为欧几里得范数 $e=\\|\\widehat{\\mathbf{h}}-\\mathbf{h}_{\\text{true}}\\|_2$。\n\n对所有随机抽样使用固定的伪随机种子 $12345$，以确保结果的可复现性。\n\n测试套件：\n为以下五个测试用例运行您的程序，每个用例由三元组 $(N_t,\\Delta t,N)$ 指定：\n- 用例 1 (理想情况): $(101,\\,0.05,\\,20000)$。\n- 用例 2 (有限时间步长): $(7,\\,0.2,\\,20000)$。\n- 用例 3 (有限测量次数): $(101,\\,0.05,\\,200)$。\n- 用例 4 (有限时间步长和有限测量次数): $(7,\\,0.2,\\,200)$。\n- 用例 5 (多时间步长但极少测量次数): $(401,\\,0.01,\\,50)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的误差列表（按顺序排列），格式为用方括号括起来的逗号分隔列表。每个误差必须四舍五入到小数点后六位。例如：$[0.123456,0.000001,0.314159,0.271828,0.000000]$。不應打印任何其他文本。",
            "solution": "该问题被评估为有效，因为它科学上基于单量子比特量子动力学原理，在数学和算法上是适定的，并为一项可解决的计算任务提供了一套完整且一致的要求。\n\n目标是从带噪声的时间序列数据中重建单量子比特系统的哈密顿量向量 $\\mathbf{h}$，该系统由 $H = \\frac{1}{2}\\mathbf{h}\\cdot\\boldsymbol{\\sigma}$ 描述。该过程涉及模拟系统演化、建模测量噪声、从噪声数据中估计时间导数，以及应用线性回归来推断 $\\mathbf{h}$。\n\n**步骤 1：精确量子比特动力学模拟**\n由布洛赫向量 $\\mathbf{r}(t)$ 表示的量子比特状态的演化由微分方程 $\\frac{d}{dt}\\mathbf{r}(t) = \\mathbf{h} \\times \\mathbf{r}(t)$ 控制。此方程描述了向量 $\\mathbf{r}(t)$ 以角频率 $\\omega = \\|\\mathbf{h}\\|_2$ 绕恒定向量 $\\mathbf{h}$ 进动。给定初始状态 $\\mathbf{r}(0)$，$\\mathbf{r}(t)$ 的精确解析解由 Rodrigues' 旋转公式给出：\n$$\n\\mathbf{r}(t) = \\mathbf{r}(0)\\cos(\\omega t) + (\\hat{\\mathbf{h}} \\times \\mathbf{r}(0))\\sin(\\omega t) + \\hat{\\mathbf{h}}(\\hat{\\mathbf{h}} \\cdot \\mathbf{r}(0))(1 - \\cos(\\omega t))\n$$\n其中 $\\hat{\\mathbf{h}} = \\mathbf{h}/\\|\\mathbf{h}\\|_2$ 是沿哈密顿量轴的单位向量。我们使用此公式计算在离散时间点 $t_k = k\\Delta t$（其中 $k=0, 1, \\dots, N_t-1$）的精确、无噪声的布洛赫向量 $\\mathbf{r}(t_k)$。\n\n**步骤 2：测量噪声模拟**\n在实际实验中，期望值 $\\langle \\sigma_j \\rangle_t = r_j(t)$ 无法直接获得。它们是通过有限次数的投影测量来估计的。对于一个处于期望值为 $r_j(t)$ 状态的系统，测量泡利算符 $\\sigma_j$ 的结果为 $\\{+1, -1\\}$。获得结果 $+1$ 的概率由 $p_+(t) = \\frac{1 + r_j(t)}{2}$ 给出。\n为了模拟此过程，我们执行 $N$ 次独立试验（shots）。观测到结果 $+1$ 的次数 $n_+$ 服从二项分布，$n_+ \\sim \\text{Binomial}(N, p_+)$。期望值的经验估计值 $\\widehat{r}_j(t)$ 是结果的样本均值：\n$$\n\\widehat{r}_j(t) = \\frac{n_+ \\cdot (+1) + (N - n_+) \\cdot (-1)}{N} = \\frac{2n_+ - N}{N}\n$$\n此过程应用于每个时间点 $t_k$ 的每个分量 $\\{x, y, z\\}$，以生成带噪声的时间序列数据 $\\widehat{\\mathbf{r}}(t_k)$。\n\n**步骤 3：时间导数的数值估计**\n为了利用动力学方程 $\\dot{\\mathbf{r}} = \\mathbf{h} \\times \\mathbf{r}$，我们必须从带噪声的离散数据 $\\widehat{\\mathbf{r}}(t_k)$ 中估计布洛赫向量的时间导数。我们采用二阶中心有限差分格式，它在精度和噪声放大之间提供了良好的平衡。对于内部时间点 $t_k$（其中 $k \\in \\{1, \\dots, N_t-2\\}$），导数估计如下：\n$$\n\\widehat{\\dot{\\mathbf{r}}}(t_k) = \\frac{\\widehat{\\mathbf{r}}(t_{k+1}) - \\widehat{\\mathbf{r}}(t_{k-1})}{2\\Delta t}\n$$\n\n**步骤 4：通过线性回归进行哈密顿量估计**\n重建的核心是从动力学方程中求解 $\\mathbf{h}$。我们将叉积重写为矩阵向量乘法：$\\mathbf{h} \\times \\mathbf{r}(t) = C(\\mathbf{r}(t))\\mathbf{h}$，其中 $C(\\mathbf{r})$ 是斜对称矩阵：\n$$\nC(\\mathbf{r}) = \\begin{bmatrix}\n0  r_z  -r_y\\\\\n-r_z  0  r_x\\\\\nr_y  -r_x  0\n\\end{bmatrix}\n$$\n将我们对状态及其导数的噪声估计代入，我们为每个内部时间点 $t_k$ 得到一组近似线性方程：\n$$\n\\widehat{\\dot{\\mathbf{r}}}(t_k) \\approx C(\\widehat{\\mathbf{r}}(t_k))\\mathbf{h}\n$$\n通过将所有 $N_t-2$ 个内部时间点的这些三维向量方程堆叠起来，我们形成一个形式为 $A\\mathbf{h} \\approx \\mathbf{b}$ 的大型超定线性系统。设计矩阵 $A$ 是一个尺寸为 $(3(N_t-2)) \\times 3$ 的高矩阵，通过垂直堆叠各个 $C(\\widehat{\\mathbf{r}}(t_k))$ 矩阵构成。观测向量 $\\mathbf{b}$ 的尺寸为 $(3(N_t-2)) \\times 1$，由堆叠估计的导数向量 $\\widehat{\\dot{\\mathbf{r}}}(t_k)$ 形成。\n问题指定使用普通最小二乘法（OLS）来找到最小化残差平方和（即 $\\|\\mathbf{b} - A\\widehat{\\mathbf{h}}\\|_2^2$）的估计值 $\\widehat{\\mathbf{h}}$。该解的 formal 形式为 $\\widehat{\\mathbf{h}} = (A^T A)^{-1}A^T \\mathbf{b}$，尽管在计算时会使用更数值稳定的算法，如 QR 分解。\n\n**步骤 5：误差量化**\n最后，通过计算估计向量 $\\widehat{\\mathbf{h}}$ 与真实向量 $\\mathbf{h}_{\\text{true}}$ 之差的欧几里得范数来量化哈密顿量重建的准确性：\n$$\ne = \\|\\widehat{\\mathbf{h}} - \\mathbf{h}_{\\text{true}}\\|_2\n$$\n对每个指定的测试用例重复整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Implements Hamiltonian learning for a single qubit from noisy measurements.\n    \"\"\"\n    \n    # Define globally fixed parameters\n    h_true = np.array([0.9, -1.2, 0.7])\n    r0_unnormalized = np.array([0.3, 0.8, 0.5])\n    r0 = r0_unnormalized / np.linalg.norm(r0_unnormalized)\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (101, 0.05, 20000),  # Case 1: happy path\n        (7, 0.2, 20000),   # Case 2: limited timesteps\n        (101, 0.05, 200),    # Case 3: finite shots\n        (7, 0.2, 200),     # Case 4: limited timesteps and finite shots\n        (401, 0.01, 50),     # Case 5: many timesteps but very few shots\n    ]\n\n    results = []\n    \n    for Nt, dt, N in test_cases:\n        # Step 1: Simulate exact time evolution of the Bloch vector\n        # This uses Rodrigues' rotation formula.\n        omega = np.linalg.norm(h_true)\n        h_hat = h_true / omega\n        times = np.linspace(0, (Nt - 1) * dt, Nt)\n        \n        cos_omega_t = np.cos(omega * times)\n        sin_omega_t = np.sin(omega * times)\n        \n        r0_dot_h_hat = np.dot(r0, h_hat)\n        h_hat_cross_r0 = np.cross(h_hat, r0)\n        \n        # Broadcasting to calculate r(t) for all times at once\n        r_exact = (r0[:, np.newaxis] * cos_omega_t +\n                   h_hat_cross_r0[:, np.newaxis] * sin_omega_t +\n                   h_hat[:, np.newaxis] * r0_dot_h_hat * (1 - cos_omega_t)).T\n\n        # Step 2: Model finite-shot measurements to get noisy estimates\n        r_noisy = np.zeros_like(r_exact)\n        for k in range(Nt):\n            for j in range(3):\n                # Probability of measuring +1\n                p_plus = (1 + r_exact[k, j]) / 2\n                # Number of +1 outcomes in N shots\n                n_plus = rng.binomial(N, p_plus)\n                # Sample mean is the estimate for the expectation value\n                r_noisy[k, j] = (2 * n_plus - N) / N\n                \n        # Step 3: Estimate the time derivative using a central finite difference\n        # This applies to interior points k=1, ..., Nt-2\n        r_dot_noisy = (r_noisy[2:] - r_noisy[:-2]) / (2 * dt)\n        \n        # Step 4: Use linear regression to estimate h\n        # We solve A*h = b, where A is the design matrix and b is the observation vector.\n        num_interior_points = Nt - 2\n        \n        # We need r_noisy at the same interior points for constructing C(r)\n        r_noisy_interior = r_noisy[1:-1]\n        \n        # Construct the design matrix A by stacking C(r(t_k)) matrices\n        A = np.zeros((3 * num_interior_points, 3))\n        \n        rx, ry, rz = r_noisy_interior[:, 0], r_noisy_interior[:, 1], r_noisy_interior[:, 2]\n        \n        # A_ij is C(r_i)_j\n        # Populate A based on the structure of C(r)\n        A[0::3, 1] = rz\n        A[0::3, 2] = -ry\n        A[1::3, 0] = -rz\n        A[1::3, 2] = rx\n        A[2::3, 0] = ry\n        A[2::3, 1] = -rx\n        \n        # Construct the observation vector b by flattening the estimated derivatives\n        b = r_dot_noisy.flatten()\n        \n        # Solve the overdetermined system using Ordinary Least Squares\n        h_estimated, _, _, _ = linalg.lstsq(A, b)\n        \n        # Step 5: Quantify the reconstruction error\n        error = np.linalg.norm(h_estimated - h_true)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.6f}' for err in results)}]\")\n\nsolve()\n```"
        }
    ]
}