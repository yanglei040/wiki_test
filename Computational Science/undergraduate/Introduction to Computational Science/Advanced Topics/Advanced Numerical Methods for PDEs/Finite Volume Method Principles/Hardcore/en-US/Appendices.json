{
    "hands_on_practices": [
        {
            "introduction": "The most fundamental promise of the Finite Volume Method is its ability to enforce conservation laws exactly at the discrete level. This first hands-on practice puts that promise to the test by tasking you with implementing a solver for the diffusion equation. By working with non-uniform meshes and variable material properties, you will verify that the total 'mass' or quantity of the scalar field is conserved over time, a crucial property that makes FVM a robust tool for physical simulations .",
            "id": "3130123",
            "problem": "Consider the one-dimensional diffusion equation in conservation form on the domain $[0,1]$:\n$$\nu_t = (k(x)\\,u_x)_x,\n$$\nwhere $u(x,t)$ is the scalar field and $k(x) \\gt 0$ is a given, sufficiently smooth diffusivity field. Let a cell-centered Finite Volume Method (FVM) be used on a general nonuniform mesh with $N$ cells. Denote cell interfaces by $\\{x_{i-\\tfrac{1}{2}}\\}_{i=1}^{N+1}$ with $x_{\\tfrac{1}{2}} = 0$ and $x_{N+\\tfrac{1}{2}} = 1$, cell centers by $x_i = \\tfrac{1}{2}(x_{i-\\tfrac{1}{2}}+x_{i+\\tfrac{1}{2}})$, and cell widths by $\\Delta x_i = x_{i+\\tfrac{1}{2}}-x_{i-\\tfrac{1}{2}}$. Let the cell average be $\\bar{u}_i(t) = \\frac{1}{\\Delta x_i}\\int_{x_{i-\\tfrac{1}{2}}}^{x_{i+\\tfrac{1}{2}}} u(x,t)\\,dx$. Define the discrete total mass by\n$$\nM(t) = \\sum_{i=1}^N \\bar{u}_i(t)\\,\\Delta x_i.\n$$\n\nStarting only from the integral balance over each control volume and the Divergence (Gauss) theorem, derive a conservative semi-discrete FVM for the cells $\\{C_i\\}_{i=1}^N$ of the form\n$$\n\\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = F_{i-\\tfrac{1}{2}} - F_{i+\\tfrac{1}{2}},\n$$\nwhere $F_{i\\pm\\tfrac{1}{2}}$ are consistent numerical approximations to the physical diffusive fluxes at interfaces. Then discretize in time using the first-order Implicit (Backward) Euler method with time step $\\Delta t \\gt 0$ to obtain a linear system at each time step for $\\{\\bar{u}_i^{n+1}\\}_{i=1}^N$. Use a two-point flux approximation at each internal interface that depends only on adjacent cells and the distances from centers to the interface, and approximates the flux gradient over the distance between adjacent cell centers. For heterogeneous diffusivity, use a face coefficient that is consistent with series resistors in one dimension.\n\nImpose either homogeneous Neumann boundary conditions (zero flux at $x=0$ and $x=1$) or periodic boundary conditions (fluxes through $x=0$ and $x=1$ cancel through identification of the end cells). In all cases below where homogeneous Neumann is specified, require that the boundary fluxes be exactly zero in the discrete sense. For periodic boundary conditions, couple the first and last cells through the boundary.\n\nUse the following initial condition for all test cases, specified via exact cell averages:\n$$\nu(x,0) = 1 + \\sin(2\\pi x),\n$$\nso that for each cell $i$ with edges $a = x_{i-\\tfrac{1}{2}}$ and $b = x_{i+\\tfrac{1}{2}}$,\n$$\n\\bar{u}_i(0) = 1 + \\frac{1}{b-a}\\int_a^b \\sin(2\\pi x)\\,dx = 1 + \\frac{-\\cos(2\\pi b) + \\cos(2\\pi a)}{2\\pi (b-a)}.\n$$\nThe domain length is $1$, so the exact continuous mass at $t=0$ equals $1$. Compute the discrete mass $M(0)$ from the cell averages and widths.\n\nImplement the fully implicit FVM time stepping and test whether the discrete total mass $M(t)$ is conserved under Implicit Euler for the following test suite. For each test, advance the solution by $n_{\\text{steps}}$ steps of size $\\Delta t$ and compare $M(n_{\\text{steps}}\\Delta t)$ against $M(0)$.\n\n- Test $1$ (happy path): $N=50$, uniform mesh with $\\Delta x_i = 1/N$, homogeneous Neumann boundary conditions, constant diffusivity $k(x) \\equiv 1$, $\\Delta t = 0.1$, $n_{\\text{steps}} = 5$.\n- Test $2$ (nonuniform and heterogeneous): $N=37$, nonuniform mesh with widths proportional to $1 + 0.6\\sin(2\\pi \\tfrac{i-0.5}{N})$ for $i=1,\\dots,N$ and then normalized so that $\\sum_i \\Delta x_i = 1$, homogeneous Neumann boundary conditions, heterogeneous diffusivity $k(x) = 1 + 0.4 x$, $\\Delta t = 0.05$, $n_{\\text{steps}} = 10$.\n- Test $3$ (periodic, strongly graded mesh): $N=41$, nonuniform mesh with geometric progression $\\Delta x_i \\propto r^{i-1}$ for $i=1,\\dots,N$ with $r=1.3$, normalized so that $\\sum_i \\Delta x_i = 1$, periodic boundary conditions, heterogeneous diffusivity $k(x) = 2 + 0.5\\cos(2\\pi x)$, $\\Delta t = 0.05$, $n_{\\text{steps}} = 7$.\n\nYour program must:\n- Construct the meshes explicitly from the specified $\\Delta x_i$ so that $\\sum_i \\Delta x_i = 1$, assemble the conservative FVM linear system using the two-point flux across adjacent cell centers for internal interfaces, enforce the specified boundary conditions, and advance with Implicit Euler.\n- Compute the discrete total mass $M(0)$ and $M(n_{\\text{steps}}\\Delta t)$ for each test.\n- For each test, decide a boolean outcome: return $\\,\\text{True}\\,$ if $\\left|M(n_{\\text{steps}}\\Delta t) - M(0)\\right| \\le 10^{-12}$, and $\\,\\text{False}\\,$ otherwise.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of the three boolean outcomes enclosed in square brackets (e.g., $[\\,\\text{True},\\text{False},\\text{True}\\,]$). No additional text should be printed. No physical units are required because the problem is dimensionless. Angles do not appear. All numeric values in the program should be treated as dimensionless scalars.",
            "solution": "The problem requires the derivation and implementation of a cell-centered finite volume method (FVM) for the one-dimensional diffusion equation, followed by a test of its mass conservation property under different conditions.\n\n### 1. Finite Volume Formulation\nThe governing partial differential equation (PDE) is given in conservation form:\n$$ u_t = (k(x)\\,u_x)_x $$\nWe apply the finite volume method by integrating this equation over a control volume $C_i = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$:\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u_t \\,dx = \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} (k(x)\\,u_x)_x \\,dx $$\nThe left-hand side (LHS), using the definition of the cell average $\\bar{u}_i(t) = \\frac{1}{\\Delta x_i}\\int_{C_i} u(x,t)\\,dx$ and the Leibniz integral rule, becomes:\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u_t \\,dx = \\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t)\\,dx = \\frac{d}{dt}\\left(\\bar{u}_i(t) \\Delta x_i\\right) $$\nThe right-hand side (RHS) is integrated using the Fundamental Theorem of Calculus (the 1D version of the Divergence Theorem):\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} (k(x)\\,u_x)_x \\,dx = \\left[ k(x)u_x \\right]_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} = (k u_x)\\Big|_{x_{i+\\frac{1}{2}}} - (k u_x)\\Big|_{x_{i-\\frac{1}{2}}} $$\nLet $G(x,t) = k(x)u_x$ be the physical diffusive flux. The exact balance equation for cell $i$ is:\n$$ \\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = G(x_{i+\\frac{1}{2}}, t) - G(x_{i-\\frac{1}{2}}, t) $$\nThis equation is then semi-discretized by approximating the fluxes $G$ at the cell interfaces (faces) with numerical fluxes, denoted $G_{i\\pm\\frac{1}{2}}$, which are functions of the cell-average values $\\bar{u}_j$. This yields the semi-discrete FVM system:\n$$ \\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = G_{i+\\frac{1}{2}} - G_{i-\\frac{1}{2}} $$\nNote that the problem statement uses $F$ for numerical flux but defines it with a sign convention that differs from the direct result of the integration. To avoid ambiguity, we use $G$ as defined here. The key is the conservative \"flux-in minus flux-out\" structure which, after rearrangement to match the problem's form, yields the same underlying stencil.\n\n### 2. Numerical Flux Approximation\nThe flux $G_{i+\\frac{1}{2}}$ at the interface between cells $i$ and $i+1$ is approximated using a two-point stencil involving $\\bar{u}_i$ and $\\bar{u}_{i+1}$. The derivative $u_x$ at the interface is approximated by a finite difference between the cell centers $x_i$ and $x_{i+1}$:\n$$ G_{i+\\frac{1}{2}} \\approx k_{i+\\frac{1}{2}} \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{x_{i+1} - x_i} $$\nwhere $k_{i+\\frac{1}{2}}$ is an effective diffusivity at the interface. As specified, for heterogeneous media, this is chosen to be consistent with resistors in series. The \"resistance\" to diffusion over a segment of length $L$ with diffusivity $k$ is $L/k$. The total resistance between cell centers $x_i$ and $x_{i+1}$ is the sum of resistances from $x_i$ to $x_{i+\\frac{1}{2}}$ and from $x_{i+\\frac{1}{2}}$ to $x_{i+1}$. This leads to a harmonic average for the effective conductivity $k_{i+\\frac{1}{2}} / (x_{i+1}-x_i) $:\n$$ \\frac{1}{\\text{Total Resistance}} = \\frac{1}{\\frac{x_{i+1}-x_i}{k_{i+\\frac{1}{2}}}} = \\frac{1}{\\frac{x_{i+\\frac{1}{2}}-x_i}{k(x_i)} + \\frac{x_{i+1}-x_{i+\\frac{1}{2}}}{k(x_{i+1})}} $$\nWith $x_i = \\frac{1}{2}(x_{i-\\frac{1}{2}}+x_{i+\\frac{1}{2}})$ and $\\Delta x_i = x_{i+\\frac{1}{2}}-x_{i-\\frac{1}{2}}$, we have $x_{i+1}-x_i = \\frac{1}{2}(\\Delta x_i + \\Delta x_{i+1})$, $x_{i+\\frac{1}{2}}-x_i = \\frac{1}{2}\\Delta x_i$, and $x_{i+1}-x_{i+\\frac{1}{2}} = \\frac{1}{2}\\Delta x_{i+1}$. The flux coefficient for the term $(\\bar{u}_{i+1} - \\bar{u}_i)$ is then:\n$$ \\beta_{i+\\frac{1}{2}} = \\frac{k_{i+\\frac{1}{2}}}{x_{i+1} - x_i} = \\frac{1}{\\frac{\\frac{1}{2}\\Delta x_i}{k(x_i)} + \\frac{\\frac{1}{2}\\Delta x_{i+1}}{k(x_{i+1})}} = \\frac{2}{\\frac{\\Delta x_i}{k(x_i)} + \\frac{\\Delta x_{i+1}}{k(x_{i+1})}} $$\nThe numerical flux is $G_{i+\\frac{1}{2}} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1} - \\bar{u}_i)$. The semi-discrete equation for an internal cell $i$ is:\n$$ \\Delta x_i \\frac{d\\bar{u}_i}{dt} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1} - \\bar{u}_i) - \\beta_{i-\\frac{1}{2}}(\\bar{u}_i - \\bar{u}_{i-1}) $$\n\n### 3. Implicit Time Discretization\nUsing the first-order Implicit (Backward) Euler method, we approximate $\\frac{d\\bar{u}_i}{dt} \\approx \\frac{\\bar{u}_i^{n+1} - \\bar{u}_i^n}{\\Delta t}$ and evaluate the spatial terms at the new time level $n+1$:\n$$ \\Delta x_i \\frac{\\bar{u}_i^{n+1} - \\bar{u}_i^n}{\\Delta t} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1}^{n+1} - \\bar{u}_i^{n+1}) - \\beta_{i-\\frac{1}{2}}(\\bar{u}_i^{n+1} - \\bar{u}_{i-1}^{n+1}) $$\nRearranging the terms yields a linear system for the unknown vector $\\mathbf{u}^{n+1} = [\\bar{u}_1^{n+1}, \\dots, \\bar{u}_N^{n+1}]^T$:\n$$ -\\frac{\\Delta t}{\\Delta x_i}\\beta_{i-\\frac{1}{2}}\\bar{u}_{i-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_i}(\\beta_{i-\\frac{1}{2}} + \\beta_{i+\\frac{1}{2}})\\right)\\bar{u}_i^{n+1} - \\frac{\\Delta t}{\\Delta x_i}\\beta_{i+\\frac{1}{2}}\\bar{u}_{i+1}^{n+1} = \\bar{u}_i^n $$\nThis equation defines the $i$-th row of a linear system $A\\mathbf{u}^{n+1} = \\mathbf{u}^n$. The matrix $A$ is tridiagonal for internal cells.\n\n### 4. Boundary Conditions\n**Homogeneous Neumann**: The boundary fluxes are zero, $G_{\\frac{1}{2}} = G_{N+\\frac{1}{2}} = 0$.\nFor cell $i=1$: $\\Delta x_1 \\frac{d\\bar{u}_1}{dt} = G_{\\frac{3}{2}} - G_{\\frac{1}{2}} = G_{\\frac{3}{2}}$. The first row of the system becomes:\n$$ \\left(1 + \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\right)\\bar{u}_1^{n+1} - \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\bar{u}_2^{n+1} = \\bar{u}_1^n $$\nFor cell $i=N$: $\\Delta x_N \\frac{d\\bar{u}_N}{dt} = G_{N+\\frac{1}{2}} - G_{N-\\frac{1}{2}} = -G_{N-\\frac{1}{2}}$. The last row becomes:\n$$ -\\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\bar{u}_{N-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\right)\\bar{u}_N^{n+1} = \\bar{u}_N^n $$\nThe resulting system matrix $A$ is tridiagonal.\n\n**Periodic**: Cells $1$ and $N$ are adjacent. We identify $\\bar{u}_0 \\equiv \\bar{u}_N$ and $\\bar{u}_{N+1} \\equiv \\bar{u}_1$.\nFor cell $i=1$: $G_{\\frac{1}{2}} = \\beta_{\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N)$. The first row includes a term for $\\bar{u}_N$:\n$$ -\\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{1}{2}}\\bar{u}_N^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_1}(\\beta_{\\frac{1}{2}} + \\beta_{\\frac{3}{2}})\\right)\\bar{u}_1^{n+1} - \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\bar{u}_2^{n+1} = \\bar{u}_1^n $$\nFor cell $i=N$: $G_{N+\\frac{1}{2}} = \\beta_{N+\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N) = \\beta_{\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N)$. The last row includes a term for $\\bar{u}_1$:\n$$ -\\frac{\\Delta t}{\\Delta x_N}\\beta_{\\frac{1}{2}}\\bar{u}_1^{n+1} -\\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\bar{u}_{N-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_N}(\\beta_{N-\\frac{1}{2}} + \\beta_{\\frac{1}{2}})\\right)\\bar{u}_N^{n+1} = \\bar{u}_N^n $$\nThe matrix $A$ is cyclic tridiagonal.\n\n### 5. Mass Conservation\nThe discrete total mass is $M(t) = \\sum_{i=1}^N \\bar{u}_i(t)\\,\\Delta x_i$. Taking the time derivative of the semi-discrete system and summing over all cells:\n$$ \\frac{dM}{dt} = \\sum_{i=1}^N \\frac{d}{dt}(\\bar{u}_i \\Delta x_i) = \\sum_{i=1}^N (G_{i+\\frac{1}{2}} - G_{i-\\frac{1}{2}}) $$\nThis is a telescoping sum which evaluates to $G_{N+\\frac{1}{2}} - G_{\\frac{1}{2}}$, the net flux across the domain boundaries.\n- For homogeneous Neumann BCs, $G_{N+\\frac{1}{2}} = G_{\\frac{1}{2}} = 0$, so $\\frac{dM}{dt} = 0$.\n- For periodic BCs, the domain has no boundaries, and $G_{N+\\frac{1}{2}} = G_{\\frac{1}{2}}$ represents the same internal flux, so their difference is zero, and $\\frac{dM}{dt} = 0$.\n\nThis property of the semi-discretization carries over to the fully discrete Implicit Euler scheme. Summing the fully discrete equations over all $i$:\n$$ \\sum_{i=1}^N \\Delta x_i (\\bar{u}_i^{n+1} - \\bar{u}_i^n) = \\Delta t \\sum_{i=1}^N (G_{i+\\frac{1}{2}}^{n+1} - G_{i-\\frac{1}{2}}^{n+1}) $$\n$$ M^{n+1} - M^n = \\Delta t (G_{N+\\frac{1}{2}}^{n+1} - G_{\\frac{1}{2}}^{n+1}) $$\nFor both Neumann and periodic boundary conditions, the RHS is zero. Thus, $M^{n+1} = M^n$. The implemented scheme is exactly mass-conservative. Any deviation in the computed result will be solely due to floating-point arithmetic errors. Given the tolerance of $10^{-12}$, we expect the tests to pass.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the FVM simulation for all test cases.\n    \"\"\"\n\n    def run_one_case(N, mesh_type, bc_type, k_func, dt, n_steps):\n        \"\"\"\n        Sets up and runs a single test case for the FVM simulation.\n        \"\"\"\n        # 1. Mesh Generation\n        if mesh_type == 'uniform':\n            dx_unnormalized = np.ones(N)\n        elif mesh_type == 'proportional':\n            i_vals = np.arange(1, N + 1)\n            dx_unnormalized = 1.0 + 0.6 * np.sin(2.0 * np.pi * (i_vals - 0.5) / N)\n        elif mesh_type == 'geometric':\n            r = 1.3\n            i_vals = np.arange(N)\n            dx_unnormalized = r**i_vals\n        else:\n            raise ValueError(\"Unknown mesh type\")\n\n        # Normalize dx so that the domain length is 1\n        dx = dx_unnormalized / np.sum(dx_unnormalized)\n\n        # Calculate interface and center positions\n        x_interfaces = np.zeros(N + 1)\n        x_interfaces[1:] = np.cumsum(dx)\n        x_centers = 0.5 * (x_interfaces[:-1] + x_interfaces[1:])\n\n        # 2. Initial Condition\n        a = x_interfaces[:-1]\n        b = x_interfaces[1:]\n        # Use a small tolerance for the denominator to avoid division by zero\n        # This is not strictly necessary due to how the mesh is created, but is good practice.\n        den = 2.0 * np.pi * (b - a)\n        # For cases where a and b are very close, the fraction approaches 0\n        safe_den = np.where(np.abs(den)  1e-15, 1, den)\n        num = -np.cos(2.0 * np.pi * b) + np.cos(2.0 * np.pi * a)\n        frac = np.where(np.abs(den)  1e-15, 0, num / safe_den)\n        u_initial = 1.0 + frac\n\n        # 3. Initial Mass\n        mass_initial = np.dot(u_initial, dx)\n\n        # 4. Time Stepping\n        u_current = np.copy(u_initial)\n        k_vals = k_func(x_centers)\n\n        for _ in range(n_steps):\n            A = np.zeros((N, N))\n            b_rhs = u_current\n\n            # 5. Assemble matrix A\n            # Internal cells (i in 1..N-2)\n            for i in range(1, N - 1):\n                beta_left = 2.0 / (dx[i - 1] / k_vals[i - 1] + dx[i] / k_vals[i])\n                beta_right = 2.0 / (dx[i] / k_vals[i] + dx[i + 1] / k_vals[i + 1])\n                c_i = dt / dx[i]\n                A[i, i - 1] = -c_i * beta_left\n                A[i, i] = 1.0 + c_i * (beta_left + beta_right)\n                A[i, i + 1] = -c_i * beta_right\n\n            # Boundary Conditions\n            if bc_type == 'neumann':\n                # First row (i=0)\n                beta_right_0 = 2.0 / (dx[0] / k_vals[0] + dx[1] / k_vals[1])\n                c_0 = dt / dx[0]\n                A[0, 0] = 1.0 + c_0 * beta_right_0\n                A[0, 1] = -c_0 * beta_right_0\n                # Last row (i=N-1)\n                beta_left_N = 2.0 / (dx[N - 2] / k_vals[N - 2] + dx[N - 1] / k_vals[N - 1])\n                c_N = dt / dx[N - 1]\n                A[N - 1, N - 2] = -c_N * beta_left_N\n                A[N - 1, N - 1] = 1.0 + c_N * beta_left_N\n            elif bc_type == 'periodic':\n                beta_periodic = 2.0 / (dx[N - 1] / k_vals[N - 1] + dx[0] / k_vals[0])\n                # First row (i=0)\n                beta_right_0 = 2.0 / (dx[0] / k_vals[0] + dx[1] / k_vals[1])\n                c_0 = dt / dx[0]\n                A[0, 0] = 1.0 + c_0 * (beta_periodic + beta_right_0)\n                A[0, 1] = -c_0 * beta_right_0\n                A[0, N - 1] = -c_0 * beta_periodic\n                # Last row (i=N-1)\n                beta_left_N = 2.0 / (dx[N - 2] / k_vals[N - 2] + dx[N - 1] / k_vals[N - 1])\n                c_N = dt / dx[N - 1]\n                A[N - 1, N - 1] = 1.0 + c_N * (beta_left_N + beta_periodic)\n                A[N - 1, N - 2] = -c_N * beta_left_N\n                A[N - 1, 0] = -c_N * beta_periodic\n            \n            # 6. Solve the linear system\n            u_next = linalg.solve(A, b_rhs)\n            u_current = u_next\n\n        # 7. Final Mass and comparison\n        mass_final = np.dot(u_current, dx)\n\n        return np.abs(mass_final - mass_initial) = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        (50, 'uniform', 'neumann', lambda x: 1.0, 0.1, 5),\n        # Test 2\n        (37, 'proportional', 'neumann', lambda x: 1.0 + 0.4 * x, 0.05, 10),\n        # Test 3\n        (41, 'geometric', 'periodic', lambda x: 2.0 + 0.5 * np.cos(2.0 * np.pi * x), 0.05, 7),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, mesh_t, bc_t, k_f, dt, n_s = params\n        # The k_func needs to be vectorized if it's not already\n        k_func_vec = np.vectorize(k_f) if not isinstance(k_f(0.5), np.ndarray) else k_f\n        result = run_one_case(N, mesh_t, bc_t, k_func_vec, dt, n_s)\n        results.append(result)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from diffusive phenomena to advective transport brings new challenges, as information now travels in a distinct direction. This exercise explores the linear advection equation and provides a critical lesson in numerical stability. By implementing and comparing a simple central flux approximation against an upwind flux, you will discover firsthand why seemingly reasonable schemes can fail catastrophically and how the principle of 'upwinding' correctly captures the physics of information flow .",
            "id": "3130164",
            "problem": "You are asked to construct, verify, and programmatically demonstrate a counterexample in the context of the finite volume method for a linear conservation law. Consider the scalar linear advection equation $u_t + a u_x = 0$ on a one-dimensional periodic domain, with a uniform grid of $N$ cells. Let $\\bar{u}_i^n$ denote the cell average in cell $i$ at time $t^n$. The finite volume update for one explicit forward Euler time step with time step $\\Delta t$ and spatial mesh size $\\Delta x$ is derived by integrating the conservation law over each control volume and approximating the physical flux by a chosen numerical flux. Denote the numerical flux at the interface between cells $i$ and $i+1$ by $F_{i+\\frac{1}{2}}^n$. The update is\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\nwith periodic boundary conditions. Define the discrete entropy\n$$\nE^n = \\sum_{i=0}^{N-1} \\left|\\bar{u}_i^n\\right|.\n$$\nTwo numerical fluxes are to be considered:\n- The central flux: $F_{i+\\frac{1}{2}}^n = a \\,\\frac{\\bar{u}_i^n + \\bar{u}_{i+1}^n}{2}$.\n- The upwind flux: $F_{i+\\frac{1}{2}}^n = a\\,\\bar{u}_i^n$ if $a  0$, and $F_{i+\\frac{1}{2}}^n = a\\,\\bar{u}_{i+1}^n$ if $a  0$; if $a = 0$ then $F_{i+\\frac{1}{2}}^n = 0$.\n\nYour task is to implement a program that, for each test case in the suite below, performs a single forward Euler time step using both the central flux and the upwind flux with periodic boundary conditions, computes $E^n$ and $E^{n+1}$ for each flux, and reports two booleans per test case:\n- A boolean indicating whether the central flux violates discrete entropy monotonicity, defined as $E^{n+1}  E^n$ for the central flux.\n- A boolean indicating whether the upwind flux violates discrete entropy monotonicity, defined as $E^{n+1}  E^n$ for the upwind flux.\n\nThe Courant–Friedrichs–Lewy (CFL) number is $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$. Use the following test suite, each specified by $(N, a, \\Delta x, \\Delta t, \\text{initial data})$, where the initial data is the list of $\\bar{u}_i^0$ for $i = 0,1,\\ldots,N-1$:\n1. $N = 4$, $a = 1.0$, $\\Delta x = 1.0$, $\\Delta t = 0.9$, initial data $[1,0,0,0]$.\n2. $N = 4$, $a = 1.0$, $\\Delta x = 1.0$, $\\Delta t = 1.0$, initial data $[1,0,0,0]$.\n3. $N = 4$, $a = -1.0$, $\\Delta x = 1.0$, $\\Delta t = 0.7$, initial data $[0,0,0,1]$.\n4. $N = 4$, $a = 0.0$, $\\Delta x = 1.0$, $\\Delta t = 0.5$, initial data $[-2,1,0,3]$.\n5. $N = 5$, $a = 1.0$, $\\Delta x = 1.0$, $\\Delta t = 0.6$, initial data $[0,1,-1,0,0]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case yields a two-boolean list without spaces for that test case. For example, the final output should look like\n[[True,False],[True,False],[True,False],[False,False],[True,False]].",
            "solution": "The problem requires a computational verification of the discrete entropy monotonicity property for two different numerical flux functions within a finite volume framework for the scalar linear advection equation, $u_t + a u_x = 0$. The analysis is performed over a single time step on a one-dimensional periodic domain.\n\nThe finite volume method is based on the integral form of the conservation law. Integrating $u_t + f(u)_x=0$, where $f(u)=au$ is the flux, over a control volume $C_i = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ of width $\\Delta x$ and a time interval $[t^n, t^{n+1}]$ of duration $\\Delta t$ yields an exact relation for the cell average $\\bar{u}_i(t) = \\frac{1}{\\Delta x} \\int_{C_i} u(x,t) dx$:\n$$\n\\bar{u}_i(t^{n+1}) = \\bar{u}_i(t^n) - \\frac{1}{\\Delta x} \\int_{t^n}^{t^{n+1}} \\left( f(u(x_{i+\\frac{1}{2}},t)) - f(u(x_{i-\\frac{1}{2}},t)) \\right) dt\n$$\nApplying a first-order forward Euler time integration and approximating the exact flux $f(u)$ at the cell interfaces by a numerical flux function $F$, we arrive at the semi-discrete finite volume scheme provided in the problem statement:\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\nwhere $\\bar{u}_i^n \\approx \\bar{u}_i(t^n)$ and $F_{i\\pm\\frac{1}{2}}^n$ is the numerical flux, which depends on the cell average values in the vicinity of the interface. The Courant–Friedrichs–Lewy (CFL) number is defined as the dimensionless ratio $\\nu = \\frac{a \\Delta t}{\\Delta x}$. We investigate two definitions for the numerical flux, $F$.\n\nThe discrete entropy is defined as the discrete $L^1$-norm of the solution vector, $E^n = \\sum_{i=0}^{N-1} |\\bar{u}_i^n|$. The problem asks to check for entropy violation, defined as the condition $E^{n+1}  E^n$.\n\n**1. Central Flux Scheme**\n\nThe central flux at the interface $x_{i+\\frac{1}{2}}$ is defined as the arithmetic mean of the flux values corresponding to the states in the adjacent cells, $i$ and $i+1$:\n$$\nF_{i+\\frac{1}{2}}^n = a \\frac{\\bar{u}_i^n + \\bar{u}_{i+1}^n}{2}\n$$\nSubstituting this into the general finite volume update equation gives:\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( a \\frac{\\bar{u}_i^n + \\bar{u}_{i+1}^n}{2} - a \\frac{\\bar{u}_{i-1}^n + \\bar{u}_i^n}{2} \\right)\n$$\nThis expression simplifies to the update rule for the central scheme:\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{a \\Delta t}{2 \\Delta x} (\\bar{u}_{i+1}^n - \\bar{u}_{i-1}^n) = \\bar{u}_i^n - \\frac{\\nu}{2} (\\bar{u}_{i+1}^n - \\bar{u}_{i-1}^n)\n$$\nThis scheme is equivalent to the forward-time, centered-space (FTCS) finite difference method. It is a well-established result in numerical analysis that the FTCS scheme is unconditionally unstable for purely hyperbolic equations like the linear advection equation. This instability leads to the generation and amplification of spurious oscillations, which causes the discrete $L^1$-norm (our entropy $E^n$) to grow. We therefore anticipate that this scheme will violate the entropy monotonicity condition, i.e., $E^{n+1}  E^n$, for non-trivial initial data.\n\n**2. Upwind Flux Scheme**\n\nThe upwind flux is constructed based on the direction of information propagation, which is determined by the sign of the advection speed $a$.\n\n- If $a  0$, the wave propagates from left to right. The flux at interface $x_{i+\\frac{1}{2}}$ is determined by the \"upwind\" state in cell $i$:\n  $$\n  F_{i+\\frac{1}{2}}^n = a \\bar{u}_i^n\n  $$\n  The update rule becomes:\n  $$\n  \\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} (a \\bar{u}_i^n - a \\bar{u}_{i-1}^n) = (1-\\nu)\\bar{u}_i^n + \\nu\\bar{u}_{i-1}^n\n  $$\n\n- If $a  0$, the wave propagates from right to left. The flux at interface $x_{i+\\frac{1}{2}}$ is determined by the \"upwind\" state in cell $i+1$:\n  $$\n  F_{i+\\frac{1}{2}}^n = a \\bar{u}_{i+1}^n\n  $$\n  The update rule becomes:\n  $$\n  \\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} (a \\bar{u}_{i+1}^n - a \\bar{u}_i^n) = \\bar{u}_i^n - \\nu (\\bar{u}_{i+1}^n - \\bar{u}_i^n) = (1+\\nu)\\bar{u}_i^n - \\nu\\bar{u}_{i+1}^n\n  $$\n\n- If $a = 0$, the flux is zero, $F_{i+\\frac{1}{2}}^n = 0$, and the solution is stationary, $\\bar{u}_i^{n+1} = \\bar{u}_i^n$.\n\nThe first-order upwind scheme is conditionally stable. The stability condition is the CFL condition, $0 \\le |\\nu| \\le 1$. All test cases provided in the problem satisfy this condition. When $0 \\le \\nu \\le 1$ ($a0$) or $-1 \\le \\nu \\le 0$ ($a0$), the update for $\\bar{u}_i^{n+1}$ is a convex combination of the values $\\bar{u}_j^n$ from the previous time step. This is because the coefficients are non-negative and sum to $1$. A key result by Harten states that schemes which can be written as a convex combination are Total Variation Diminishing (TVD). TVD schemes have the property of being $L^1$-contractive, which implies that the discrete $L^1$-norm cannot increase: $E^{n+1} \\leq E^n$. Therefore, we expect the upwind scheme to satisfy discrete entropy monotonicity for all provided test cases.\n\n**Computational Implementation**\n\nThe programmatic solution implements these steps for each test case.\n1.  The initial cell averages $\\bar{u}^0$ are stored in a NumPy array.\n2.  The initial entropy $E^0 = \\sum_{i=0}^{N-1} |\\bar{u}_i^0|$ is computed.\n3.  The CFL number $\\nu$ is calculated.\n4.  For both schemes, the updated solution $\\bar{u}^1$ is computed using vectorized operations. Periodic boundary conditions are implemented using `numpy.roll` to access neighboring elements $\\bar{u}_{i-1}^0$ and $\\bar{u}_{i+1}^0$.\n5.  The final entropies, $E^1_{\\text{central}}$ and $E^1_{\\text{upwind}}$, are calculated by summing the absolute values of the elements in the updated solution arrays.\n6.  For each scheme, the final entropy is compared to the initial entropy to determine if the violation condition $E^{n+1}  E^n$ is met. The results are stored as a pair of booleans.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the finite volume problem for a series of test cases.\n\n    For each case, it performs a single forward Euler time step for the 1D\n    linear advection equation using both central and upwind numerical fluxes.\n    It then checks if the discrete L1-norm (entropy) has increased for\n    each scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, a, dx, dt, initial_data_list)\n        (4, 1.0, 1.0, 0.9, [1, 0, 0, 0]),\n        (4, 1.0, 1.0, 1.0, [1, 0, 0, 0]),\n        (4, -1.0, 1.0, 0.7, [0, 0, 0, 1]),\n        (4, 0.0, 1.0, 0.5, [-2, 1, 0, 3]),\n        (5, 1.0, 1.0, 0.6, [0, 1, -1, 0, 0]),\n    ]\n\n    final_results = []\n    TOL = 1e-12 # A small tolerance for floating point comparisons\n\n    for case in test_cases:\n        N, a, dx, dt, u0_list = case\n        u0 = np.array(u0_list, dtype=float)\n\n        # Calculate initial discrete entropy (L1-norm)\n        E0 = np.sum(np.abs(u0))\n\n        # Calculate the CFL number\n        nu = a * dt / dx\n\n        # --- Central Flux Scheme ---\n        # Update rule: u_i^{n+1} = u_i^n - (nu/2) * (u_{i+1}^n - u_{i-1}^n)\n        u_prev_c = np.roll(u0, 1)   # u_{i-1}\n        u_next_c = np.roll(u0, -1)  # u_{i+1}\n        u1_central = u0 - (nu / 2.0) * (u_next_c - u_prev_c)\n        \n        # Calculate final entropy for the central scheme\n        E1_central = np.sum(np.abs(u1_central))\n        \n        # Check for entropy violation\n        central_violates = (E1_central - E0) > TOL\n\n        # --- Upwind Flux Scheme ---\n        if a > 0:\n            # Update rule: u_i^{n+1} = (1-nu)*u_i^n + nu*u_{i-1}^n\n            u_prev_u = np.roll(u0, 1)  # u_{i-1}\n            u1_upwind = u0 - nu * (u0 - u_prev_u)\n        elif a  0:\n            # Update rule: u_i^{n+1} = (1+nu)*u_i^n - nu*u_{i+1}^n\n            u_next_u = np.roll(u0, -1)  # u_{i+1}\n            u1_upwind = u0 - nu * (u_next_u - u0)\n        else:  # a == 0\n            # Update rule: u_i^{n+1} = u_i^n\n            u1_upwind = np.copy(u0)\n            \n        # Calculate final entropy for the upwind scheme\n        E1_upwind = np.sum(np.abs(u1_upwind))\n        \n        # Check for entropy violation\n        upwind_violates = (E1_upwind - E0) > TOL\n        \n        final_results.append([central_violates, upwind_violates])\n\n    # Format the final output string as specified in the problem statement.\n    # e.g., [[True,False],[True,False],...]\n    case_results_str = [f\"[{res[0]},{res[1]}]\" for res in final_results]\n    print(f\"[{','.join(case_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world physical systems are often nonlinear, leading to complex behaviors like shock waves. This advanced practice introduces the powerful concept of the local Riemann problem, which forms the heart of modern finite volume schemes for such systems. By implementing solvers for the nonlinear Burgers' equation, you will compare how different fundamental approaches—Godunov, HLL, and Roe—resolve discontinuities and see why satisfying an additional physical constraint, the entropy condition, is essential for obtaining the correct solution .",
            "id": "3130154",
            "problem": "You are to implement a one-dimensional, first-order finite volume method for the scalar conservation law with nonlinear flux. Your goal is to formalize the local Riemann problem at each cell face, implement three different numerical fluxes based on distinct local Riemann solvers, and examine how the solver choice affects conservation and entropy behavior.\n\nStart from the fundamental conservation law in differential form\n$$\n\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0,\n$$\nwith the specific nonlinear flux\n$$\nf(u) = \\tfrac{1}{2} u^2.\n$$\nUse the finite volume method on a uniform grid with periodic boundary conditions on the domain $[0,1]$. Let $N$ be the number of cells, and define cell averages $U_i^n$ as approximations to the average of $u$ over cell $i$ at time level $n$ with grid spacing $\\Delta x$ and time step $\\Delta t$. The update must be in conservative flux-difference form based on solving a local Riemann problem at each face between states $(U_i^n, U_{i+1}^n)$.\n\nYou must implement three different numerical fluxes, each derived from a distinct Riemann solver applied locally at every face:\n- Godunov’s exact Riemann solver for the scalar flux $f(u)$.\n- Harten–Lax–van Leer (HLL) solver, using physically consistent estimates of left and right wave speeds.\n- Roe’s linearized solver without any entropy fix.\n\nYour implementation must:\n- Use a Courant–Friedrichs–Lewy (CFL) time stepping with a constant number $\\mathrm{CFL} = 0.5$ to select $\\Delta t$ dynamically at each step based on the maximum local characteristic speed, which for this flux equals $|f'(u)| = |u|$.\n- Use $N = 400$ uniformly spaced cells, periodic boundary conditions, and simulate until final time $t_{\\mathrm{final}} = 0.15$.\n- Initialize the three Riemann problems centered at the interface between cells $i = N/2 - 1$ and $i = N/2$ with piecewise constant initial data:\n  1. Test A (shock): $u_L = 2$, $u_R = 0$.\n  2. Test B (rarefaction): $u_L = 0$, $u_R = 2$.\n  3. Test C (transonic rarefaction): $u_L = -1$, $u_R = 1$.\n  Each test uses the same domain and grid. The left state $u_L$ fills cells $i = 0, \\dots, N/2 - 1$ and the right state $u_R$ fills cells $i = N/2, \\dots, N - 1$.\n\nFor each solver and each test, quantify:\n- Conservation: whether the total mass $M(t) = \\sum_i U_i(t) \\Delta x$ is conserved to within an absolute tolerance of $10^{-12}$, i.e., whether $|M(t_{\\mathrm{final}}) - M(0)| \\le 10^{-12}$.\n- Entropy: whether the discrete total entropy\n$$\nE(t) = \\sum_i \\tfrac{1}{2} U_i(t)^2 \\Delta x\n$$\nis nonincreasing, i.e., $E(t_{\\mathrm{final}}) \\le E(0) + 10^{-10}$.\n\nAdditionally, for Test C only, quantify an interface entropy-consistency indicator based on the entropy-satisfying sonic state at the interface. For the Burgers flux $f(u)=\\tfrac{1}{2}u^2$ and transonic data $u_L  0  u_R$, the entropy solution imposes the interfacial state $u_\\ast = 0$ at the initial time, hence the correct interfacial flux equals $f(0) = 0$. For each solver, evaluate the numerical interfacial flux at the initial time at the discontinuity location (the face between cells $i=N/2-1$ and $i=N/2$) and report whether it equals $0$ within an absolute tolerance of $10^{-12}$.\n\nImplementation details and constraints:\n- Use the explicit first-order finite volume update in conservative flux-difference form.\n- Use periodic boundary conditions at both ends of the domain.\n- Apply the local Riemann solver independently at each face for each time step.\n- All quantities are dimensionless; no physical units are required.\n\nTest Suite and output specification:\n- Implement the three tests A, B, C as defined above, and the three solvers in the fixed order: Godunov, HLL, Roe.\n- For each solver and each test, compute two booleans in the following order: mass conservation boolean, then entropy nonincrease boolean.\n- For Test C only, also compute one boolean per solver indicating whether the interfacial flux at the initial discontinuity equals $0$ within the specified tolerance.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be ordered as follows:\n- First, for each solver in the order [Godunov, HLL, Roe] and for each test in the order [A, B, C], append the two booleans [mass_conserved, entropy_nonincreasing], resulting in $18$ booleans.\n- Then, append the three booleans for the Test C interfacial flux entropy-consistency indicator in the same solver order [Godunov, HLL, Roe].\n- The final output thus contains $21$ booleans, for example: \"[True,True,False,True,...]\".",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It constitutes a standard exercise in computational fluid dynamics for evaluating the properties of fundamental numerical schemes for hyperbolic conservation laws. All parameters and conditions are sufficiently specified to permit a unique and verifiable solution.\n\nThe problem requires the implementation of a first-order finite volume method for the one-dimensional scalar conservation law given by\n$$\n\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0, \\quad x \\in [0,1], t > 0,\n$$\nwith the nonlinear Burgers' flux function $f(u) = \\frac{1}{2} u^2$. The spatial domain is discretized into $N=400$ uniform cells of width $\\Delta x = 1/N$. The solution within each cell $i$ is approximated by its cell average, $U_i(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$.\n\nThe semi-discrete finite volume formulation for the cell-average $U_i$ is\n$$\n\\frac{d U_i}{dt} = - \\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right),\n$$\nwhere $F_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. This flux is a function of the states in the adjacent cells, $F_{i+1/2} = F(U_i, U_{i+1})$. For time integration, a forward Euler scheme is used:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t^n}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right).\n$$\nThe time step $\\Delta t^n$ is chosen dynamically at each time level $n$ to satisfy the Courant-Friedrichs-Lewy (CFL) condition:\n$$\n\\Delta t^n = \\mathrm{CFL} \\frac{\\Delta x}{\\max_i | \\lambda(U_i^n) |},\n$$\nwhere the characteristic speed for Burgers' equation is $\\lambda(u) = f'(u) = u$, and the CFL number is fixed at $\\mathrm{CFL} = 0.5$. Periodic boundary conditions are imposed, meaning that for flux calculations, cell $N$ is identified with cell $0$ and cell $-1$ with cell $N-1$.\n\nThree distinct numerical flux functions are implemented, each corresponding to a different local Riemann solver.\n\n1.  **Godunov's Flux ($F_G$)**: This flux is derived from the exact solution to the local Riemann problem at the cell interface with states $(u_L, u_R)$. For the convex Burgers' flux, the state at the interface, $u_{int} = u(x/t=0; u_L, u_R)$, determines the flux $F_G = f(u_{int})$. The state $u_{int}$ depends on the wave structure:\n    - If $u_L  u_R$, a shock wave forms with speed $s = \\frac{f(u_R)-f(u_L)}{u_R-u_L} = \\frac{1}{2}(u_L+u_R)$. If $s  0$, the state at the interface is $u_L$. If $s \\le 0$, the state is $u_R$.\n    - If $u_L \\le u_R$, a rarefaction wave forms. If $u_L, u_R \\ge 0$, all characteristics move right, so $u_{int}=u_L$. If $u_L, u_R \\le 0$, all characteristics move left, so $u_{int}=u_R$. If $u_L  0  u_R$ (transonic rarefaction), a stationary sonic point exists, and $u_{int}=0$.\n    The resulting flux is given by:\n    $$\n    F_G(u_L, u_R) = \\begin{cases}\n    \\max(f(u_L), f(u_R))  \\text{if } u_L  u_R \\text{ and } s=0 \\\\\n    f(u_L)  \\text{if } u_L  u_R \\text{ and } s0 \\\\\n    f(u_R)  \\text{if } u_L  u_R \\text{ and } s0 \\\\\n    f(u_L)  \\text{if } u_L \\le u_R \\text{ and } u_L \\ge 0 \\\\\n    f(u_R)  \\text{if } u_L \\le u_R \\text{ and } u_R \\le 0 \\\\\n    f(0)  \\text{if } u_L  0  u_R\n    \\end{cases}\n    $$\n    This can be simplified for a convex flux like Burgers to $F_G(u_L, u_R) = \\max(f(\\min(u_L, u_{sonic})), f(\\max(u_R, u_{sonic})))$ if $u_L  u_R$ and $F_G(u_L, u_R) = \\min(f(u_L),f(u_R))$ if $u_Lu_R$ and $u_L u_R0$. A more direct implementation based on the cases above is used. For $s=0$ with $u_Lu_R$, $u_L=-u_R$ and $f(u_L)=f(u_R)$, so the max is just $f(u_L)$.\n\n2.  **Harten-Lax-van Leer (HLL) Flux ($F_{HLL}$)**: This is an approximate Riemann solver which assumes a two-wave structure with constant states in between. The flux is:\n    $$\n    F_{HLL}(u_L, u_R) = \\begin{cases}\n    f(u_L),  \\text{if } S_L \\ge 0 \\\\\n    f(u_R),  \\text{if } S_R \\le 0 \\\\\n    \\frac{S_R f(u_L) - S_L f(u_R) + S_L S_R (u_R - u_L)}{S_R - S_L},  \\text{if } S_L  0  S_R\n    \\end{cases}\n    $$\n    where $S_L$ and $S_R$ are estimates of the minimum and maximum signal velocities. A standard, physically consistent choice for a scalar problem is $S_L = \\min(\\lambda(u_L), \\lambda(u_R)) = \\min(u_L, u_R)$ and $S_R = \\max(\\lambda(u_L), \\lambda(u_R)) = \\max(u_L, u_R)$.\n\n3.  **Roe Flux ($F_R$)**: This flux is based on a linearized Riemann problem. It provides high resolution for shocks but requires an entropy fix for rarefactions, which is explicitly omitted here.\n    $$\n    F_R(u_L, u_R) = \\frac{1}{2}\\left( f(u_L) + f(u_R) \\right) - \\frac{1}{2} |\\hat{a}(u_L, u_R)| (u_R - u_L)\n    $$\n    The Roe-averaged wave speed $\\hat{a}$ must satisfy the property $f(u_R) - f(u_L) = \\hat{a}(u_R - u_L)$. For Burgers' equation, this yields $\\hat{a}(u_L, u_R) = \\frac{1}{2}(u_L + u_R)$.\n\nThe initial conditions for the three test cases (A: shock, B: rarefaction, C: transonic rarefaction) are piecewise constant, with a discontinuity at the interface between cells $i=N/2-1$ and $i=N/2$.\n\nThe behavior of each solver is evaluated based on three criteria:\n1.  **Mass Conservation**: The numerical scheme is in conservative form, so the total mass $M(t) = \\sum_{i=0}^{N-1} U_i(t) \\Delta x$ should be conserved up to floating-point precision. This is checked by verifying $|M(t_{\\mathrm{final}}) - M(0)| \\le 10^{-12}$.\n2.  **Entropy Condition**: For a physically valid solution, the total discrete entropy, defined here as $E(t) = \\sum_{i=0}^{N-1} \\frac{1}{2} U_i(t)^2 \\Delta x$, must be non-increasing. This is checked by verifying $E(t_{\\mathrm{final}}) \\le E(0) + 10^{-10}$. The small tolerance accounts for round-off errors.\n3.  **Interfacial Flux for Test C**: For the transonic rarefaction case (Test C), the entropy solution requires the state at the initial discontinuity to be $u_* = 0$, leading to a physical flux of $f(0) = 0$. The numerical flux $F(u_L=-1, u_R=1)$ computed by each solver at $t=0$ is checked against this value within a tolerance of $10^{-12}$. Godunov's solver is expected to match this exactly. HLL and Roe's solvers, due to their construction, are expected to fail this test, which is indicative of their known deficiencies (diffusivity for HLL, entropy violation for Roe) in such scenarios.\n\nThe implementation proceeds by looping through each solver and test case, running a simulation until $t_{\\mathrm{final}}=0.15$, and then calculating the specified booleans.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D finite volume solver for Burgers' equation and evaluates\n    three numerical fluxes: Godunov, HLL, and Roe.\n    \"\"\"\n    N = 400\n    T_FINAL = 0.15\n    CFL_NUMBER = 0.5\n    DOMAIN_LENGTH = 1.0\n    \n    DX = DOMAIN_LENGTH / N\n    X = np.linspace(DX / 2, DOMAIN_LENGTH - DX / 2, N)\n\n    # Nonlinear flux function and its derivative (characteristic speed)\n    def f(u):\n        return 0.5 * u**2\n\n    # --- Numerical Flux Implementations ---\n\n    def godunov_flux(uL, uR):\n        \"\"\"Vectorized Godunov flux for Burgers' equation.\"\"\"\n        fL = f(uL)\n        fR = f(uR)\n        s = 0.5 * (uL + uR)\n\n        # Shock case (uL > uR)\n        flux_shock = np.where(s > 0, fL, fR)\n        # Handle s=0 case, where fL=fR\n        flux_shock = np.where(s == 0, fL, flux_shock)\n\n        # Rarefaction case (uL = uR)\n        flux_raref = np.where(uL >= 0, fL, fR) # Both states non-negative or non-positive\n        flux_raref = np.where((uL  0)  (uR > 0), 0.0, flux_raref) # Transonic case\n\n        return np.where(uL > uR, flux_shock, flux_raref)\n\n    def hll_flux(uL, uR):\n        \"\"\"Vectorized HLL flux for Burgers' equation.\"\"\"\n        fL = f(uL)\n        fR = f(uR)\n\n        sL = np.minimum(uL, uR)\n        sR = np.maximum(uL, uR)\n        \n        flux = np.zeros_like(uL)\n        \n        # Case 1: sL >= 0\n        mask1 = sL >= 0\n        flux[mask1] = fL[mask1]\n        \n        # Case 2: sR = 0\n        mask2 = sR = 0\n        flux[mask2] = fR[mask2]\n        \n        # Case 3: sL  0  sR\n        mask3 = ~(mask1 | mask2)\n        sL_m3 = sL[mask3]\n        sR_m3 = sR[mask3]\n        s_diff = sR_m3 - sL_m3\n        \n        # Avoid division by zero when sL = sR (i.e. uL = uR)\n        # Although masks should prevent this, it's safer.\n        safe_s_diff = np.where(s_diff == 0, 1.0, s_diff) # if s_diff is 0, uL=uR, numerator is 0 anyway.\n\n        hll_val = (sR_m3 * fL[mask3] - sL_m3 * fR[mask3] + sL_m3 * sR_m3 * (uR[mask3] - uL[mask3])) / safe_s_diff\n        flux[mask3] = hll_val\n        \n        return flux\n\n    def roe_flux(uL, uR):\n        \"\"\"Vectorized Roe flux (no entropy fix) for Burgers' equation.\"\"\"\n        fL = f(uL)\n        fR = f(uR)\n        a_hat = 0.5 * (uL + uR)\n        return 0.5 * (fL + fR) - 0.5 * np.abs(a_hat) * (uR - uL)\n\n    solvers = {\n        \"Godunov\": godunov_flux,\n        \"HLL\": hll_flux,\n        \"Roe\": roe_flux\n    }\n    \n    test_cases = {\n        \"A\": (2.0, 0.0), # Shock\n        \"B\": (0.0, 2.0), # Rarefaction\n        \"C\": (-1.0, 1.0) # Transonic rarefaction\n    }\n\n    def run_simulation(flux_func, uL, uR):\n        \"\"\"Runs a single simulation and returns initial and final states.\"\"\"\n        U = np.zeros(N)\n        mid_point = N // 2\n        U[:mid_point] = uL\n        U[mid_point:] = uR\n        U_initial = U.copy()\n\n        t = 0.0\n        while t  T_FINAL:\n            max_abs_u = np.max(np.abs(U))\n            if max_abs_u  1e-15:\n                # Solution is zero, no change\n                dt = T_FINAL - t\n            else:\n                dt = CFL_NUMBER * DX / max_abs_u\n            \n            if t + dt > T_FINAL:\n                dt = T_FINAL - t\n\n            # Periodic boundary conditions for flux calculation\n            u_left = U\n            u_right = np.roll(U, -1)\n            \n            fluxes = flux_func(u_left, u_right)\n\n            fluxes_left_face = np.roll(fluxes, 1) # Fluxes at i-1/2\n            \n            U = U - (dt / DX) * (fluxes - fluxes_left_face)\n            t += dt\n            \n        return U_initial, U\n\n    results = []\n\n    # Part 1: Run simulations and check conservation/entropy\n    solver_order = [\"Godunov\", \"HLL\", \"Roe\"]\n    test_order = [\"A\", \"B\", \"C\"]\n\n    for solver_name in solver_order:\n        for test_name in test_order:\n            uL, uR = test_cases[test_name]\n            flux_function = solvers[solver_name]\n            \n            U0, U_final = run_simulation(flux_function, uL, uR)\n\n            # Mass conservation check\n            mass0 = np.sum(U0) * DX\n            mass_final = np.sum(U_final) * DX\n            mass_conserved = abs(mass_final - mass0) = 1e-12\n\n            # Entropy non-increase check\n            entropy0 = np.sum(0.5 * U0**2) * DX\n            entropy_final = np.sum(0.5 * U_final**2) * DX\n            entropy_nonincreasing = entropy_final = entropy0 + 1e-10\n\n            results.extend([mass_conserved, entropy_nonincreasing])\n\n    # Part 2: Interface entropy-consistency indicator for Test C\n    uL_C, uR_C = test_cases[\"C\"]\n    for solver_name in solver_order:\n        flux_function = solvers[solver_name]\n        # Calculate flux for a single interface\n        interfacial_flux = flux_function(np.array([uL_C]), np.array([uR_C]))[0]\n        flux_is_zero = abs(interfacial_flux - 0.0) = 1e-12\n        results.append(flux_is_zero)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}