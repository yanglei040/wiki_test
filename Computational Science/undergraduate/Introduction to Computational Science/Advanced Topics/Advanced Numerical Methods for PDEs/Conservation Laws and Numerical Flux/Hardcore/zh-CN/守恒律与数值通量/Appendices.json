{
    "hands_on_practices": [
        {
            "introduction": "守恒律中的“守恒”在有限体积法中有一个直接的数值对应物。这个实践是一个关键的健全性检查，用以验证我们的代码是否正确地实现了这一基本原则。通过确保从一个单元流出的通量精确地流入相邻单元，我们可以建立对数值方案无“数值泄漏”的信心 。",
            "id": "3111462",
            "problem": "您需要设计并实现一个完整的、可运行的程序，该程序通过对随机生成的控制体积周围的数值通量进行求和，并验证其相消至舍入误差，来测试二维有限体积离散化的局部守恒性质。其底层的数学模型是积分形式的标量守恒律，该定律指出，一个守恒量的变化率等于该量通过一个控制体积边界的净通量。\n\n使用的基本原理：\n- 控制体积 $\\Omega$ 上的积分守恒律：\n$$\n\\frac{d}{dt}\\int_{\\Omega} q(\\mathbf{x},t)\\,d\\mathbf{x} \\;+\\; \\int_{\\partial \\Omega} \\mathbf{F}(q)\\cdot \\mathbf{n}\\,ds \\;=\\; 0,\n$$\n其中 $q$ 是守恒标量，$\\mathbf{F}(q)$ 是物理通量矢量。\n- 有限体积法构建离散的面通量，使得共享的内表面对相邻单元的贡献大小相等、方向相反，从而确保局部守恒。\n\n待实现的离散化设置：\n- 在定义域 $[0,2\\pi]\\times[0,2\\pi]$ 上的一个 $N_x\\times N_y$ 单元的矩形周期性网格，其均匀间距为 $dx=2\\pi/N_x$ 和 $dy=2\\pi/N_y$。\n- 一个光滑的流函数 $\\psi(x,y)=\\sin(x)\\sin(y)$，通过它定义一个无散速度场：\n$$\nu^x(x,y)=\\frac{\\partial \\psi}{\\partial y}(x,y)=\\cos(y)\\sin(x), \\quad\nu^y(x,y)=-\\frac{\\partial \\psi}{\\partial x}(x,y)=-\\cos(x)\\sin(y).\n$$\n- 一个定义在单元中心 $(x_i,y_j)$ 的离散标量场 $q_{i,j}$，使用带有指定种子的伪随机数生成器确定性地生成。\n\n待构建的数值通量：\n- 使用 $x_{i+\\tfrac{1}{2}}=x_i+\\tfrac{dx}{2}$ 和 $y_j$ 在垂直面 $(i+\\tfrac{1}{2},j)$ 上定义面心速度，以及使用 $x_i$ 和 $y_{j+\\tfrac{1}{2}}=y_j+\\tfrac{dy}{2}$ 在水平面 $(i,j+\\tfrac{1}{2})$ 上定义面心速度。\n- 使用标量的中心平均法定义跨面的数值通量：\n$$\nF^x_{i+\\tfrac{1}{2},j}=u^x(x_{i+\\tfrac{1}{2}},y_j)\\cdot \\frac{q_{i,j}+q_{i+1\\ \\mathrm{mod}\\ N_x,j}}{2}, \\quad\nF^y_{i,j+\\tfrac{1}{2}}=u^y(x_i,y_{j+\\tfrac{1}{2}})\\cdot \\frac{q_{i,j}+q_{i,j+1\\ \\mathrm{mod}\\ N_y}}{2}.\n$$\n此处使用周期性索引，使得 $i+1\\ \\mathrm{mod}\\ N_x$ 和 $j+1\\ \\mathrm{mod}\\ N_y$ 在网格上回绕。\n\n待执行的局部守恒检查：\n- 对于单元的任意子集 $\\mathcal{S}$，通过对每个单元的外向通量贡献求和计算出的净外向通量\n$$\n\\sum_{(i,j)\\in\\mathcal{S}} \\left( F^x_{i+\\tfrac{1}{2},j}-F^x_{i-\\tfrac{1}{2},j}+F^y_{i,j+\\tfrac{1}{2}}-F^y_{i,j-\\tfrac{1}{2}} \\right)\n$$\n必须等于仅跨越 $\\mathcal{S}$ 边界且方向朝外的面的通量之和。内部共享面必须相消至舍入误差，因为它们表现为大小相等、方向相反的贡献。您的程序必须计算这两个量，并验证它们的差值相对于边界通量的大小在一个小容差范围内。\n\n程序要求：\n- 完全按照规定实现网格、速度场、标量场 $q_{i,j}$ 和数值通量。\n- 根据下方的测试套件，将控制体积 $\\mathcal{S}$ 生成为单元的子集。\n- 对于每个控制体积，用两种方法计算净外向通量：\n  1. 对 $\\mathcal{S}$ 中所有单元的每个单元的外向通量贡献求和。\n  2. 仅对分隔 $\\mathcal{S}$ 与其补集且方向朝外的面上的通量求和。\n- 定义误差度量 $E=|S_{\\text{cells}}-S_{\\text{boundary}}|$ 和尺度 $A=\\sum |\\text{boundary face fluxes}|$。如果 $E\\le \\tau\\cdot(1+A)$，则报告一个布尔结果为真，其中容差常数 $\\tau$ 设置为 $\\tau=10^{-12}$。\n\n测试套件：\n对于每个测试用例，元组指定 $(N_x,N_y,\\text{mode},\\text{param},\\text{seed})$，其中 $\\text{mode}$ 定义子集选择方法，$\\text{param}$ 是其参数。\n- 用例1（通用随机子集）：$(32,24,\\text{random\\_fraction},0.3,2024)$。\n- 用例2（中心单个单元）：$(16,16,\\text{single\\_cell},\\text{None},7)$；选择索引为 $(\\lfloor N_x/2\\rfloor,\\lfloor N_y/2\\rfloor)$ 的单个单元。\n- 用例3（完整网格）：$(20,30,\\text{full\\_grid},\\text{None},99)$；选择网格的所有单元。\n- 用例4（较大随机子集）：$(48,10,\\text{random\\_fraction},0.5,12345)$。\n- 用例5（棋盘格子集）：$(12,12,\\text{checkerboard},\\text{None},2025)$；选择 $(i+j)$ 为偶数的单元。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”），每个结果都是一个布尔值，按上面列出的顺序对应五个测试用例。不应打印任何其他文本。",
            "solution": "问题陈述经评估有效。它在科学上基于计算流体动力学的原理，特别是用于守恒律的有限体积法。该问题是适定的，所有必要的参数、方程和条件都已明确定义，从而为每个测试用例导出一个唯一的、可验证的解。该任务构成了一个标准的、具有指导意义的数值实验，用于验证局部守恒性质，而该性质是构建有限体积格式的基础。\n\n解决方案通过实现指定的数值离散化并对几个定义的控制体积执行守恒检查来展开。\n\n**1. 域和场的离散化**\n\n连续域 $[0, 2\\pi] \\times [0, 2\\pi]$ 被离散化为一个由 $N_x \\times N_y$ 个矩形单元（或控制体积）组成的均匀网格。每个单元的宽度和高度分别为 $\\Delta x = 2\\pi/N_x$ 和 $\\Delta y = 2\\pi/N_y$。一个单元由 $(i,j)$ 索引，其中 $i \\in \\{0, 1, \\dots, N_x-1\\}$ 且 $j \\in \\{0, 1, \\dots, N_y-1\\}$。\n\n标量 $q$ 由位于每个单元中心的离散场 $q_{i,j}$ 表示。单元中心 $(x_i, y_j)$ 的坐标由 $x_i = (i+0.5)\\Delta x$ 和 $y_j = (j+0.5)\\Delta y$ 给出。每个测试用例的 $q_{i,j}$ 值是使用带有指定种子的伪随机数生成器生成的，从而确保了确定性和可复现的结果。\n\n问题定义了一个从流函数 $\\psi(x,y) = \\sin(x)\\sin(y)$ 推导出的无散速度场 $\\mathbf{u} = (u^x, u^y)$：\n$$\nu^x(x,y) = \\frac{\\partial \\psi}{\\partial y} = \\cos(y)\\sin(x)\n$$\n$$\nu^y(x,y) = -\\frac{\\partial \\psi}{\\partial x} = -\\cos(x)\\sin(y)\n$$\n这个连续速度场在单元面的中心处进行求值以计算通量。单元 $(i,j)$ 和 $(i+1,j)$ 之间的垂直面位于坐标 $x_{i+\\frac{1}{2}} = (i+1)\\Delta x$ 处。单元 $(i,j)$ 和 $(i,j+1)$ 之间的水平面位于 $y_{j+\\frac{1}{2}} = (j+1)\\Delta y$ 处。\n\n**2. 数值通量构建**\n\n有限体积法近似了守恒律的积分形式。$q$ 跨越单元面的通量是使用一个数值通量函数计算的。问题指定了一个中心平均格式。\n\n跨越位于 $(x_{i+\\frac{1}{2}}, y_j)$ 处垂直面的数值通量为：\n$$\nF^x_{i+\\frac{1}{2},j} = u^x(x_{i+\\frac{1}{2}}, y_j) \\cdot \\frac{q_{i,j} + q_{i+1 \\pmod{N_x}, j}}{2}\n$$\n跨越位于 $(x_i, y_{j+\\frac{1}{2}})$ 处水平面的数值通量为：\n$$\nF^y_{i,j+\\frac{1}{2}} = u^y(x_i, y_{j+\\frac{1}{2}}) \\cdot \\frac{q_{i,j} + q_{i,j+1 \\pmod{N_y}}}{2}\n$$\n在索引中使用模运算，例如 $i+1 \\pmod{N_x}$，正确地实现了指定的周期性边界条件。\n\n**3. 局部守恒的验证**\n\n问题的核心是为任意单元子集 $\\mathcal{S}$ 验证局部守恒性质。该性质意味着从区域 $\\mathcal{S}$ 流出的净通量可以通过两种等效的方式计算，其结果必须在浮点精度范围内匹配。\n\n**方法1：单元散度之和 ($S_{\\text{cells}}$)**\n对 $\\mathcal{S}$ 中的每个单元 $(i,j)$，我们计算其离散散度，即流出其四个面的通量之和。整个子集 $\\mathcal{S}$ 的净通量是这些单个单元散度的总和：\n$$\nS_{\\text{cells}} = \\sum_{(i,j) \\in \\mathcal{S}} \\left( \\left( F^x_{i+\\frac{1}{2},j} - F^x_{i-\\frac{1}{2},j} \\right) + \\left( F^y_{i,j+\\frac{1}{2}} - F^y_{i,j-\\frac{1}{2}} \\right) \\right)\n$$\n此处，$F^x_{i-\\frac{1}{2},j}$ 表示单元 $(i,j)$ 左侧面的通量，且与 $F^x_{(i-1)+\\frac{1}{2},j}$ 相同。守恒离散化的一个关键特征是，对于任意两个相邻单元，离开一个单元的通量与进入另一个单元的通量相同。这确保了在对散度求和时，跨越 $\\mathcal{S}$ 所有内表面的通量会完全抵消。\n\n**方法2：边界表面上的总和 ($S_{\\text{boundary}}$)**\n该方法通过仅对构成子集 $\\mathcal{S}$ 边界（记为 $\\partial\\mathcal{S}$）的面上的通量求和来直接计算净通量。如果一个面分隔了 $\\mathcal{S}$ 内的一个单元和 $\\mathcal{S}$ 外的一个单元，则该面是 $\\partial\\mathcal{S}$ 的一部分。求和是相对于 $\\mathcal{S}$ 的外指向法线进行的：\n$$\nS_{\\text{boundary}} = \\int_{\\partial\\mathcal{S}} \\mathbf{F} \\cdot \\mathbf{n} \\, ds\n$$\n在离散形式下，这涉及到识别所有边界表面，确定它们的方向（向外或向内），并用适当的符号对相应的数值通量求和。\n\n根据构造，$S_{\\text{cells}}$ 和 $S_{\\text{boundary}}$ 是代数上恒等的表达式。我们的实现通过两种不同的算法来计算它们，以验证这个恒等式在实践中成立。\n\n**4. 误差分析**\n\n这两种计算之间的差值 $E = |S_{\\text{cells}} - S_{\\text{boundary}}|$ 应该在机器浮点精度的量级。为了提供一个尺度不变的度量，将此误差与穿过边界的所有通量的绝对大小之和 $A = \\sum_{\\text{face} \\in \\partial\\mathcal{S}} |F_{\\text{face}}|$ 进行比较。如果相对误差很小，根据以下判据，则认为守恒性质得到验证：\n$$\nE \\le \\tau \\cdot (1 + A)\n$$\n其中容差 $\\tau$ 设置为一个较小的值 $10^{-12}$，而 $(1+A)$ 中的 $1$ 是为了处理总边界通量 $A$ 可能为零的情况（例如，完整网格）。根据此条件为每个测试用例报告一个布尔结果。\n\n程序为五个指定的测试用例实现了这整个过程，这些测试用例包括将子集 $\\mathcal{S}$ 生成为单元的随机分数、单个单元、完整网格和棋盘格模式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a program to test the local conservation property\n    of a two-dimensional finite volume discretization.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 24, 'random_fraction', 0.3, 2024),\n        (16, 16, 'single_cell', None, 7),\n        (20, 30, 'full_grid', None, 99),\n        (48, 10, 'random_fraction', 0.5, 12345),\n        (12, 12, 'checkerboard', None, 2025),\n    ]\n\n    results = []\n    tau = 1e-12\n\n    for case in test_cases:\n        Nx, Ny, mode, param, seed = case\n        \n        # 1. Grid and Field Setup\n        dx = 2.0 * np.pi / Nx\n        dy = 2.0 * np.pi / Ny\n        \n        # Cell-center coordinates\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        \n        # Scalar field q from a seeded pseudo-random number generator\n        rng = np.random.default_rng(seed)\n        q = rng.random(size=(Nx, Ny))\n\n        # 2. Velocity and Numerical Flux Calculation\n        # Vertical face coordinates (i+1/2, j)\n        x_v_faces = (np.arange(Nx) + 1.0) * dx\n        xv_grid, yv_grid = np.meshgrid(x_v_faces, y_centers, indexing='ij')\n        \n        # Horizontal face coordinates (i, j+1/2)\n        y_h_faces = (np.arange(Ny) + 1.0) * dy\n        xh_grid, yh_grid = np.meshgrid(x_centers, y_h_faces, indexing='ij')\n\n        # Velocity at faces\n        u_x_at_faces = np.cos(yv_grid) * np.sin(xv_grid)\n        u_y_at_faces = -np.cos(xh_grid) * np.sin(yh_grid)\n\n        # Periodic shifts of q for averaging\n        q_ip1 = np.roll(q, -1, axis=0) # q at (i+1, j)\n        q_jp1 = np.roll(q, -1, axis=1) # q at (i, j+1)\n\n        # Numerical fluxes F_x at (i+1/2, j) and F_y at (i, j+1/2)\n        F_x = u_x_at_faces * (q + q_ip1) / 2.0\n        F_y = u_y_at_faces * (q + q_jp1) / 2.0\n\n        # 3. Control Volume (Subset S) Generation\n        S_mask = np.zeros((Nx, Ny), dtype=bool)\n        if mode == 'random_fraction':\n            S_mask = rng.choice([True, False], size=(Nx, Ny), p=[param, 1.0 - param])\n        elif mode == 'single_cell':\n            S_mask[Nx // 2, Ny // 2] = True\n        elif mode == 'full_grid':\n            S_mask[:, :] = True\n        elif mode == 'checkerboard':\n            I, J = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n            S_mask = (I + J) % 2 == 0\n        \n        # 4. Conservation Check\n        # Method 1: Sum of cell divergences\n        F_x_im1 = np.roll(F_x, 1, axis=0) # F_x at (i-1/2, j)\n        F_y_jm1 = np.roll(F_y, 1, axis=1) # F_y at (i, j-1/2)\n        cell_divergence = (F_x - F_x_im1) + (F_y - F_y_jm1)\n        S_cells = np.sum(cell_divergence[S_mask])\n\n        # Method 2: Sum over boundary faces\n        S_boundary = 0.0\n        A = 0.0\n        \n        # Iterate over all faces to identify boundary faces and sum fluxes\n        for i in range(Nx):\n            for j in range(Ny):\n                i_next = (i + 1) % Nx\n                j_next = (j + 1) % Ny\n\n                # Vertical face (i+1/2, j)\n                if S_mask[i, j] != S_mask[i_next, j]:\n                    flux = F_x[i, j]\n                    A += np.abs(flux)\n                    if S_mask[i, j]:  # Outward flux from S\n                        S_boundary += flux\n                    else:  # Inward flux to S (outward from neighbor)\n                        S_boundary -= flux\n\n                # Horizontal face (i, j+1/2)\n                if S_mask[i, j] != S_mask[i, j_next]:\n                    flux = F_y[i, j]\n                    A += np.abs(flux)\n                    if S_mask[i, j]:  # Outward flux from S\n                        S_boundary += flux\n                    else:  # Inward flux to S (outward from neighbor)\n                        S_boundary -= flux\n\n        # 5. Error Calculation and Result\n        E = np.abs(S_cells - S_boundary)\n        is_conserved = E = tau * (1.0 + A)\n        results.append(is_conserved)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确认我们的方案能够守恒之后，下一个问题是它是否稳定。本练习将探讨线性平流方程的两种最简单的数值通量——迎风格式和中心格式。我们将通过理论和模拟发现，为何看似更精确的中心通量是无条件不稳定的，而“有偏”的迎风通量却能提供稳定的解，从而引入数值稳定性的关键概念 。",
            "id": "3111406",
            "problem": "给定线性守恒律 $u_t + (f(u))_x = 0$，其中 $f(u) = c\\,u$，$c$ 为一个严格为正的常数。考虑一个长度为 $L$ 的周期性区域上的均匀网格，该网格有 $N$ 个单元。设 $U_i^n$ 表示在时间层 $n$ 时单元 $i$ 内的单元平均值，单元宽度为 $\\Delta x = L/N$，时间步长为 $\\Delta t$，库朗数为 $\\nu = c\\,\\Delta t/\\Delta x$。设 $\\mathcal{F}_{i+\\frac{1}{2}}$ 表示单元 $i$ 和 $i+1$ 之间界面上的一个相容的数值通量。显式前向欧拉有限体积更新公式如下：\n$$\nU_i^{n+1} \\;=\\; U_i^n \\;-\\;\\frac{\\Delta t}{\\Delta x}\\,\\Big(\\mathcal{F}_{i+\\frac{1}{2}} - \\mathcal{F}_{i-\\frac{1}{2}}\\Big), \n$$\n采用周期性边界条件。\n\n待比较的两种通量是：\n\n- 当 $c>0$ 时的迎风通量：$\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_i^n$。\n- 中心通量：$\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{ce}} = \\tfrac{1}{2}\\,c\\,(U_i^n + U_{i+1}^n)$。\n\n从离散守恒律的基本定义和这些通量选择出发，根据基本原理推导并建立以下性质。\n\n1) 离散稳态：离散稳态是任意一个网格函数 $U_i$，使得显式更新对所有 $i$ 都产生 $U_i^{n+1} = U_i^n$。请为给定的方程和通量确定其离散稳态，并判断常数状态 $U_i \\equiv U_0$ 在每种格式下是否保持不变。\n\n2) 关于稳态的线性稳定性：对于常数稳态附近的一个小扰动 $U_i^n = U_0 + \\varepsilon\\,\\phi_i^n$（其中 $0  \\varepsilon\\ll 1$），判断扰动振幅是否会随时间增长。使用库朗-弗里德里希-列维 (CFL) 数 $\\nu$ 作为无量纲控制参数。您的推理必须从离散更新和周期性网格上的容许傅里叶模态出发。\n\n3) 数值演示：实现两种有限体积格式，以说明：\n- 在迎风通量下，当 $0 \\le \\nu \\le 1$ 时，离散稳态得以保持，即小扰动不会增长；到稳态的距离是非增的。\n- 在中心通量下，对于临界的 CFL 选择，离散稳态会发生漂移，即任何非零的 $\\nu$ 都会导致非平凡扰动的增长。\n\n您必须通过测量最终时刻扰动范数与其初始值的比率来量化“保持”与“漂移”。\n\n实现要求：\n\n- 区域与参数：使用长度为 $L=1$ 的周期性区域，波速 $c=1$，单元数 $N=128$，单元中心位于 $x_i = (i+\\tfrac{1}{2})\\,\\Delta x$（其中 $\\Delta x = L/N$），时间步数 $M=200$。\n- 初始数据：$U_i^0 = U_0 + \\varepsilon \\sin(2\\pi k x_i)$，其中 $U_0 = 1$，波数 $k = 1$，扰动振幅 $\\varepsilon = 10^{-3}$。\n- 时间步长：对于每次测试，根据指定的 $\\nu$ 选择 $\\Delta t = \\nu\\,\\Delta x / c$。\n- 扰动范数：对于任意向量 $U$，定义相对于其空间平均值 $\\bar U = \\frac{1}{N}\\sum_i U_i$ 的扰动为 $\\delta U = U - \\bar U\\,\\mathbf{1}$，离散 $L^2$ 范数为 $\\|\\delta U\\|_2 = \\sqrt{\\sum_i (\\delta U_i)^2}$。对于每种格式和每次测试，计算比率 $R = \\|\\delta U^{M}\\|_2/\\|\\delta U^{0}\\|_2$。\n- 测试套件 (CFL 数)：对 $\\nu \\in \\{0.1,\\,0.5,\\,0.9\\}$ 进行测试。\n- 程序需检查的预期行为：对于迎风通量，$R \\le 1$；对于中心通量，$R > 1$。\n\n最终输出格式：\n\n- 您的程序应产生单行输出，其中包含六个比率，按以下顺序以逗号分隔的列表形式置于方括号内：\n$$\n[\\;R_{\\mathrm{up}}(\\nu{=}0.1),\\;R_{\\mathrm{ce}}(\\nu{=}0.1),\\;R_{\\mathrm{up}}(\\nu{=}0.5),\\;R_{\\mathrm{ce}}(\\nu{=}0.5),\\;R_{\\mathrm{up}}(\\nu{=}0.9),\\;R_{\\mathrm{ce}}(\\nu{=}0.9)\\;].\n$$\n每个比率以小数（无单位）形式表示，保留小数点后六位。不应打印任何其他文本。",
            "solution": "该问题要求对线性平流方程 $u_t + c u_x = 0$（其中 $c > 0$ 为常数）的两种有限体积格式进行基本原理分析。该方程是形式为 $u_t + (f(u))_x = 0$ 的守恒律，其通量函数为线性函数 $f(u) = c\\,u$。有限体积法近似该守恒律的积分形式。对于一个单元宽度为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格，在时间 $n$ 时单元 $i$ 内的单元平均值 $U_i^n$ 使用显式前向欧拉格式进行更新：\n$$\nU_i^{n+1} \\;=\\; U_i^n \\;-\\;\\frac{\\Delta t}{\\Delta x}\\,\\Big(\\mathcal{F}_{i+\\frac{1}{2}} - \\mathcal{F}_{i-\\frac{1}{2}}\\Big)\n$$\n其中 $\\mathcal{F}_{i+\\frac{1}{2}}$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。我们分析两种通量选择：迎风通量 $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_i^n$（因为 $c>0$）和中心通量 $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{ce}} = \\frac{1}{2}\\,c\\,(U_i^n + U_{i+1}^n)$。库朗数定义为 $\\nu = c\\,\\Delta t/\\Delta x$。\n\n1) 离散稳态。\n离散稳态是一个不随时间变化的网格函数 $U_i$，即对所有网格索引 $i$ 都有 $U_i^{n+1} = U_i^n$。将此条件代入更新方程可得：\n$$\n0 \\;=\\; -\\frac{\\Delta t}{\\Delta x}\\,\\Big(\\mathcal{F}_{i+\\frac{1}{2}} - \\mathcal{F}_{i-\\frac{1}{2}}\\Big)\n$$\n由于 $\\Delta t > 0$ 且 $\\Delta x > 0$，这意味着对所有 $i$ 都有 $\\mathcal{F}_{i+\\frac{1}{2}} = \\mathcal{F}_{i-\\frac{1}{2}}$。由于周期性边界条件，这意味着数值通量在所有单元界面上必须为常数：$\\mathcal{F}_{i+\\frac{1}{2}} = F_{const}$，其中 $F_{const}$ 是某个常数。\n\n对于迎风通量，$\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_i$。稳态条件变为 $c\\,U_i = F_{const}$。由于 $c$ 是一个严格为正的常数，这要求 $U_i = F_{const} / c$。因此，任何常数网格函数 $U_i = U_{const}$ 都是迎风格式的离散稳态。具体来说，常数状态 $U_i \\equiv U_0$ 是不变的。如果对所有 $i$ 都有 $U_i^n = U_0$，那么 $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_0$ 且 $\\mathcal{F}_{i-\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_0$，使得更新项为零。\n\n对于中心通量，$\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{ce}} = \\frac{1}{2}\\,c\\,(U_i + U_{i+1})$。稳态条件是 $\\frac{1}{2}\\,c\\,(U_i + U_{i+1}) = F_{const}$，即 $U_i + U_{i+1} = C_{const}$，其中 $C_{const} = 2F_{const}/c$。这个递推关系对于任何常数网格函数 $U_i = U_0$（此时 $C_{const} = 2U_0$）都成立，因此常数状态 $U_i \\equiv U_0$ 在中心格式下也是不变的。然而，这个条件也允许非恒定的解。例如，形式为 $U_i = A(-1)^i + B$（其中 $A$ 和 $B$ 是常数）的周期为2的波是一个稳态，因为 $U_i + U_{i+1} = (A(-1)^i + B) + (A(-1)^{i+1} + B) = 2B = C_{const}$。这些非恒定的解通常被称为伪稳态 (spurious steady states)。\n\n2) 关于稳态的线性稳定性。\n我们通过考虑一个小扰动 $U_i^n = U_0 + \\varepsilon\\,\\phi_i^n$（其中 $0  \\varepsilon \\ll 1$）的演化来分析常数稳态 $U_0$ 的稳定性。由于两种格式都是线性的，控制扰动 $\\phi_i^n$ 的方程与控制 $U_i^n$ 的方程相同。我们通过将扰动分解为周期性网格上的傅里叶模态来应用冯·诺伊曼稳定性分析。单个傅里叶模态的形式为 $\\phi_i^n = (g(\\xi))^n e^{\\mathrm{j} i \\xi}$，其中 $\\xi = k_g \\Delta x$ 是无量纲波数，$k_g$ 是物理波数，$\\mathrm{j} = \\sqrt{-1}$，$g(\\xi)$ 是复放大因子。如果对于所有容许的波数 $\\xi$ 都有 $|g(\\xi)| \\le 1$，则该格式是稳定的。\n\n对于迎风格式，更新方程可以写为：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}(c\\,U_i^n - c\\,U_{i-1}^n) = U_i^n - \\nu(U_i^n - U_{i-1}^n) = (1-\\nu)U_i^n + \\nu U_{i-1}^n\n$$\n将傅里叶模态 $\\phi_i^n = g^n e^{\\mathrm{j} i \\xi}$ 代入扰动方程，得到：\n$$\ng^{n+1}e^{\\mathrm{j} i \\xi} = (1-\\nu)g^n e^{\\mathrm{j} i \\xi} + \\nu g^n e^{\\mathrm{j} (i-1) \\xi}\n$$\n两边同除以 $g^n e^{\\mathrm{j} i \\xi}$ 得到放大因子：\n$$\ng(\\xi) = 1 - \\nu + \\nu e^{-\\mathrm{j}\\xi} = 1 - \\nu + \\nu(\\cos\\xi - \\mathrm{j}\\sin\\xi)\n$$\n其模长的平方为：\n$$\n|g(\\xi)|^2 = (1 - \\nu + \\nu\\cos\\xi)^2 + (-\\nu\\sin\\xi)^2 = 1 - 2\\nu(1-\\nu)(1-\\cos\\xi)\n$$\n为了保证稳定性，我们需要 $|g(\\xi)|^2 \\le 1$，这意味着 $2\\nu(1-\\nu)(1-\\cos\\xi) \\ge 0$。由于对于所有实数 $\\xi$ 都有 $1-\\cos\\xi \\ge 0$，该条件简化为 $\\nu(1-\\nu) \\ge 0$。这在 $0 \\le \\nu \\le 1$ 时成立。因此，迎风格式是条件稳定的。当 $\\nu$ 在此范围内时，扰动不会增长。此外，对于 $\\nu \\in (0, 1)$ 和 $\\xi \\ne 0$，我们有 $|g(\\xi)|  1$，这表明该格式是耗散的，会随时间衰减扰动。\n\n对于中心格式，更新方程为：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\frac{c}{2}(U_i^n+U_{i+1}^n) - \\frac{c}{2}(U_{i-1}^n+U_i^n)\\right) = U_i^n - \\frac{\\nu}{2}(U_{i+1}^n - U_{i-1}^n)\n$$\n代入傅里叶模态得到：\n$$\ng^{n+1}e^{\\mathrm{j} i \\xi} = g^n e^{\\mathrm{j} i \\xi} - \\frac{\\nu}{2}(g^n e^{\\mathrm{j} (i+1) \\xi} - g^n e^{\\mathrm{j} (i-1) \\xi})\n$$\n放大因子为：\n$$\ng(\\xi) = 1 - \\frac{\\nu}{2}(e^{\\mathrm{j}\\xi} - e^{-\\mathrm{j}\\xi}) = 1 - \\frac{\\nu}{2}(2\\mathrm{j}\\sin\\xi) = 1 - \\mathrm{j}\\nu\\sin\\xi\n$$\n其模长的平方为：\n$$\n|g(\\xi)|^2 = 1^2 + (-\\nu\\sin\\xi)^2 = 1 + \\nu^2\\sin^2\\xi\n$$\n稳定性条件 $|g(\\xi)|^2 \\le 1$ 要求 $1 + \\nu^2\\sin^2\\xi \\le 1$，这简化为 $\\nu^2\\sin^2\\xi \\le 0$。由于 $\\nu^2 \\ge 0$ 且 $\\sin^2\\xi \\ge 0$，此条件仅在 $\\nu=0$ 或 $\\sin\\xi=0$ 时满足。对于任何 $\\nu>0$ 和任何具有 $\\sin\\xi \\ne 0$ 的模态，我们都有 $|g(\\xi)| > 1$。因此，对于任何 $\\nu>0$，该格式都是无条件不稳定的。任何包含不稳定傅里叶分量的非平凡扰动都会随时间增长。\n\n3) 数值演示。\n数值实验说明了这些稳定性。扰动是相对于空间平均值定义的，即 $\\delta U = U - \\bar U \\mathbf{1}$。对于守恒格式，平均值 $\\bar U$ 随时间保持不变。分析 $\\|\\delta U\\|_2$ 等效于分析所有非零波数模态（$\\xi \\ne 0$）的演化。\n\n对于迎风格式，所测试的库朗数 $\\nu \\in \\{0.1, 0.5, 0.9\\}$ 都落在稳定范围 $[0, 1]$ 内，对于初始正弦扰动的所有非零波数分量，放大因子满足 $|g(\\xi)|  1$。因此，扰动的振幅预计会随时间减小。比率 $R = \\|\\delta U^M\\|_2 / \\|\\delta U^0\\|_2$ 应小于或等于 $1$，这证实了离散稳态得以保持，即扰动被衰减。\n\n对于中心格式，稳定性分析表明，对于任何非零 $\\nu$，都存在 $|g(\\xi)| > 1$ 的不稳定模态。初始正弦扰动包含此类模态。它们的振幅会随时间增长，导致扰动总范数的增加。因此，比率 $R$ 预计将大于 $1$，这表明常数稳态是不稳定的，并且由于任何小扰动的增长而“漂移”。程序将计算这些比率以验证这一理论预测。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using upwind and central finite volume schemes\n    to demonstrate stability properties.\n    \"\"\"\n    # Define parameters from the problem statement\n    L = 1.0\n    c = 1.0\n    N = 128\n    U0 = 1.0\n    epsilon = 1e-3\n    k_wave = 1\n    M = 200\n    \n    # Test cases are the different Courant numbers (nu)\n    test_cases_nu = [0.1, 0.5, 0.9]\n\n    # Set up the computational grid\n    dx = L / N\n    x = (np.arange(N, dtype=np.float64) + 0.5) * dx\n\n    # Define the initial condition\n    U_initial = U0 + epsilon * np.sin(2 * np.pi * k_wave * x)\n\n    # Calculate the norm of the initial perturbation\n    # The perturbation is defined relative to the spatial mean.\n    U_mean_initial = np.mean(U_initial)\n    delta_U_initial = U_initial - U_mean_initial\n    norm_delta_U_initial = np.linalg.norm(delta_U_initial)\n\n    results = []\n    # Loop over the specified Courant-Friedrichs-Lewy (CFL) numbers\n    for nu in test_cases_nu:\n        \n        # --- Upwind Scheme ---\n        U_up = np.copy(U_initial)\n        for _ in range(M):\n            # U_i^{n+1} = U_i^n - nu * (U_i^n - U_{i-1}^n)\n            # Periodic boundary conditions are handled by np.roll\n            U_up = U_up - nu * (U_up - np.roll(U_up, 1, axis=0))\n\n        # Calculate the ratio R for the upwind scheme\n        U_mean_final_up = np.mean(U_up)\n        delta_U_final_up = U_up - U_mean_final_up\n        norm_delta_U_final_up = np.linalg.norm(delta_U_final_up)\n        R_up = norm_delta_U_final_up / norm_delta_U_initial\n        results.append(R_up)\n\n        # --- Central Flux Scheme ---\n        U_ce = np.copy(U_initial)\n        for _ in range(M):\n            # U_i^{n+1} = U_i^n - (nu/2) * (U_{i+1}^n - U_{i-1}^n)\n            # Periodic boundary conditions are handled by np.roll\n            U_ce = U_ce - (nu / 2.0) * (np.roll(U_ce, -1, axis=0) - np.roll(U_ce, 1, axis=0))\n        \n        # Calculate the ratio R for the central scheme\n        U_mean_final_ce = np.mean(U_ce)\n        delta_U_final_ce = U_ce - U_mean_final_ce\n        norm_delta_U_final_ce = np.linalg.norm(delta_U_final_ce)\n        R_ce = norm_delta_U_final_ce / norm_delta_U_initial\n        results.append(R_ce)\n    \n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然一阶迎风格式是稳定的，但它的数值耗散也很大，会使尖锐的特征变得模糊。为了获得更清晰的结果，我们需要高阶格式，但这会引入新问题：在间断附近产生非物理的振荡（吉布斯现象）。本练习将实现一个带有斜率限制器的二阶MUSCL格式，并将其与中心格式进行比较，以量化和理解如何在不牺牲物理真实性的前提下实现高精度 。",
            "id": "3111412",
            "problem": "考虑一维标量守恒律 $u_t + f(u)_x = 0$，定义在周期性域 $x \\in [0,L]$ 上，其线性通量为 $f(u) = a\\,u$，其中 $a$ 是一个恒定的平流速度。初始数据是一个不连续的阶跃（黎曼型初值），形式如下：\n$$\nu(x,0) = \\begin{cases}\nu_L,  x  x_0,\\\\\nu_R,  x \\ge x_0,\n\\end{cases}\n$$\n该初始数据在一个具有 $N$ 个单元的均匀有限体积网格上进行解释，单元中心为 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$（其中 $i=0,\\dots,N-1$），$\\Delta x = L/N$，且边界为周期性边界。问题是推导并实现两种仅在数值通量函数上有所不同的二阶有限体积格式，然后量化平流间断附近的类吉布斯过冲和下冲。\n\n从第一性原理出发。您必须使用以下基本要素，然后推导您需要的其他所有内容。\n\n- 单元 $i$ 上的守恒（积分）形式：单元平均值的变化率等于通过其界面的净通量。\n- 在每个单元中使用带总变差递减（TVD）斜率限制器的分段线性重构。对斜率使用 minmod 限制器。\n- 对半离散的常微分方程组（线方法）使用二阶两步强稳定性保持（SSP）龙格-库塔时间积分器。\n\n您的任务是：\n\n1) 有限体积半离散化。从单元平均值的守恒出发，推导半离散更新公式\n$$\n\\frac{d \\bar u_i}{dt} = -\\frac{1}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}} - F_{i-\\tfrac{1}{2}}\\right),\n$$\n其中 $F_{i+\\tfrac{1}{2}}$ 是在界面 $x_{i+\\tfrac{1}{2}}$ 处，根据重构的左、右界面状态 $u_{i+\\tfrac{1}{2}}^{-}$ 和 $u_{i+\\tfrac{1}{2}}^{+}$ 计算出的一致性数值通量。\n\n2) 斜率限制的 MUSCL 重构。根据相邻单元的平均值 $\\bar u_{i-1},\\bar u_i,\\bar u_{i+1}$，构造一个分段线性重构，其斜率为\n$$\ns_i = \\operatorname{minmod}\\!\\left(\\bar u_i - \\bar u_{i-1},\\, \\bar u_{i+1} - \\bar u_i\\right),\n$$\n界面状态为\n$$\nu_{i+\\tfrac{1}{2}}^{-} = \\bar u_i + \\tfrac{1}{2} s_i,\\qquad\nu_{i+\\tfrac{1}{2}}^{+} = \\bar u_{i+1} - \\tfrac{1}{2} s_{i+1}.\n$$\n这里，如果 $\\alpha\\beta \\le 0$，$\\operatorname{minmod}(\\alpha,\\beta)$ 返回 $0$，否则返回 $\\operatorname{sign}(\\alpha)\\min(|\\alpha|,|\\beta|)$。周期性地处理索引。\n\n3) 使用相同重构的两种数值通量：\n- 线性平流的迎风-戈杜诺夫通量。对于 $a0$，精确黎曼求解器给出 $F_{i+\\tfrac{1}{2}}^{\\text{up}} = a\\,u_{i+\\tfrac{1}{2}}^{-}$。对于 $a0$，它给出 $F_{i+\\tfrac{1}{2}}^{\\text{up}} = a\\,u_{i+\\tfrac{1}{2}}^{+}$。\n- 线性平流的二阶中心拉克斯-温德罗夫通量。基于时间上的泰勒展开，并使用偏微分方程替换 $u_t$，推导界面处的单步二阶中心通量。证明对于左-右界面状态 $u_{i+\\tfrac{1}{2}}^{-}$ 和 $u_{i+\\tfrac{1}{2}}^{+}$ 以及库朗-弗里德里希斯-列维（CFL）数 $\\lambda = a\\,\\Delta t/\\Delta x$，一个一致的二阶中心数值通量可以写成\n$$\nF_{i+\\tfrac{1}{2}}^{\\text{LW}} = a\\left[\\tfrac{1}{2}\\left(u_{i+\\tfrac{1}{2}}^{-} + u_{i+\\tfrac{1}{2}}^{+}\\right) - \\tfrac{1}{2}\\lambda \\left(u_{i+\\tfrac{1}{2}}^{+} - u_{i+\\tfrac{1}{2}}^{-}\\right)\\right].\n$$\n\n4) 时间积分。使用二阶两步强稳定性保持（SSP）龙格-库塔方法对半离散常微分方程组进行时间积分，时间步长 $\\Delta t$ 遵循用户指定的 CFL 数 $0  \\text{CFL}\\le 1$，其中 $\\Delta t$ 选择为 $\\Delta t = \\text{CFL}\\,\\Delta x/|a|$，并可能在最后一步减小以精确达到最终时间 $T$。\n\n5) 量化过冲和下冲。令 $U_{\\min} = \\min(u_L,u_R)$ 和 $U_{\\max} = \\max(u_L,u_R)$。在最终时间 $T$，对每种格式计算：\n- 过冲幅度 $M_{\\text{over}} = \\max\\{0,\\, \\max_i \\bar u_i(T) - U_{\\max}\\}$。\n- 下冲幅度 $M_{\\text{under}} = \\max\\{0,\\, U_{\\min} - \\min_i \\bar u_i(T)\\}$。\n两者均为非负实数。\n\n6) 实现与输出。实现一个程序，对下面的每个测试用例，模拟两种格式（相同的网格、相同的重构、相同的时间步长规则），然后对每个测试用例输出列表\n$$\n\\big[ M_{\\text{over}}^{\\text{central}},\\; M_{\\text{under}}^{\\text{central}},\\; M_{\\text{over}}^{\\text{upwind}},\\; M_{\\text{under}}^{\\text{upwind}}\\big],\n$$\n四舍五入到小数点后六位。将所有测试用例的结果聚合成单行，形式为逗号分隔的列表之列表，不含空格，例如\n$$\n\\big[\\,[0.123456,0.000000,0.000000,0.000000],[\\dots]\\,\\big].\n$$\n您的程序必须以这种精确格式产生单行输出。\n\n使用以下测试套件，它涵盖了分辨率和稳定性的典型和边缘条件，所有数值均采用国际单位制（此处为无量纲）：\n- 测试 A（正常情况，中等分辨率）：$L=1.0$, $N=200$, $a=1.0$, $u_L=1.0$, $u_R=0.0$, $x_0=0.3$, $\\text{CFL}=0.45$, $T=0.20$。\n- 测试 B（粗网格）：$L=1.0$, $N=40$, $a=1.0$, $u_L=1.0$, $u_R=0.0$, $x_0=0.3$, $\\text{CFL}=0.45$, $T=0.20$。\n- 测试 C（CFL 接近稳定性极限）：$L=1.0$, $N=200$, $a=1.0$, $u_L=1.0$, $u_R=0.0$, $x_0=0.3$, $\\text{CFL}=0.95$, $T=0.20$。\n- 测试 D（小跳跃）：$L=1.0$, $N=200$, $a=1.0$, $u_L=0.6$, $u_R=0.4$, $x_0=0.3$, $\\text{CFL}=0.60$, $T=0.20$。\n\n不涉及角度单位。报告每个测试用例的全部四个数字，形式为小数，小数点后精确到六位。最终输出格式是一个包含列表之列表的单行字符串，不含空格：例如，$[\\,[0.000001,0.000000,0.000000,0.000000],[\\dots]\\,]$。",
            "solution": "该问题是有效的，因为它在双曲守恒律和数值方法的理论中有科学依据，其定义和参数完整一致，问题陈述客观。我们着手求解。\n\n该问题要求推导、实现和比较两种用于线性平流方程 $u_t + (au)_x = 0$ 的二阶有限体积格式。这两种格式仅在它们的数值通量函数上有所不同。\n\n### 1) 有限体积半离散化\n\n我们从一维标量守恒律的积分形式开始。对于一个宽度为 $\\Delta x = x_{i+\\frac{1}{2}} - x_{i-\\frac{1}{2}}$ 的“单元”或控制体 $C_i = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$，该定律指出，单元内守恒量 $u$ 的总量变化率等于穿过其边界的净通量：\n$$\n\\frac{d}{dt} \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t) \\, dx = f(u(x_{i-\\frac{1}{2}},t)) - f(u(x_{i+\\frac{1}{2}},t)).\n$$\n我们定义单元 $i$ 中 $u$ 的单元平均值为 $\\bar{u}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t) \\, dx$。将其代入积分形式得到：\n$$\n\\frac{d}{dt} (\\Delta x \\bar{u}_i) = \\Delta x \\frac{d\\bar{u}_i}{dt} = f(u(x_{i-\\frac{1}{2}},t)) - f(u(x_{i+\\frac{1}{2}},t)).\n$$\n在有限体积方法中，界面处通量 $f(u)$ 的精确点值是未知的。它们被一个数值通量函数 $F$ 所取代，该函数依赖于界面左右两侧的解的状态。令 $F_{i+\\frac{1}{2}}$ 表示界面 $x_{i+\\frac{1}{2}}$ 处的数值通量。单元平均值的演化方程变为：\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}} \\right).\n$$\n这就是线方法的半离散格式。右侧代表空间离散化，其结果是一个关于单元平均值 $\\bar{u}_i(t)$ 的常微分方程（ODEs）组。\n\n### 2) 斜率限制的 MUSCL 重构\n\n为达到二阶空间精度，数值通量 $F_{i+\\frac{1}{2}}$ 必须使用解在界面 $x_{i+\\frac{1}{2}}$ “左”侧和“右”侧的二阶精确估计来计算。这通过从单元平均值对解进行分段多项式重构来实现。MUSCL（Monotone Upstream-centered Schemes for Conservation Laws，守恒律的单调上游中心格式）方法在每个单元 $i$ 内使用分段线性重构：\n$$\nu_i(x) = \\bar{u}_i + s_i \\frac{x-x_i}{\\Delta x} \\quad \\text{for} \\quad x \\in C_i,\n$$\n其中 $x_i$ 是单元中心，$s_i$ 是一个受限的斜率。为了保持总变差递减（TVD）性质并避免引入新的振荡，斜率 $s_i$ 使用一个限制器来计算。问题指定了 `minmod` 限制器，它比较后向和前向差分：\n$$\ns_i = \\operatorname{minmod}(\\bar{u}_i - \\bar{u}_{i-1}, \\bar{u}_{i+1} - \\bar{u}_i).\n$$\n函数 $\\operatorname{minmod}(\\alpha, \\beta)$ 定义为：\n$$\n\\operatorname{minmod}(\\alpha, \\beta) = \\begin{cases} \\operatorname{sign}(\\alpha)\\min(|\\alpha|, |\\beta|)  \\text{if } \\alpha\\beta > 0 \\\\ 0  \\text{if } \\alpha\\beta \\le 0 \\end{cases}\n$$\n如果两个斜率符号相同，此限制器选择其中较小的一个；如果符号不同（即在极值点处），则返回零。\n\n在单元 $i$ 的右边界（$x=x_{i+\\frac{1}{2}}$）和单元 $i+1$ 的左边界（$x=x_{i+\\frac{1}{2}}$）处的重构值，为该界面处的黎曼问题提供了左、右状态：\n$$\nu_{i+\\frac{1}{2}}^{-} = u_i(x_{i+\\frac{1}{2}}) = \\bar{u}_i + s_i \\frac{(x_i + \\Delta x/2) - x_i}{\\Delta x} = \\bar{u}_i + \\frac{1}{2}s_i.\n$$\n$$\nu_{i+\\frac{1}{2}}^{+} = u_{i+1}(x_{i+\\frac{1}{2}}) = \\bar{u}_{i+1} + s_{i+1} \\frac{(x_{i+1} - \\Delta x/2) - x_{i+1}}{\\Delta x} = \\bar{u}_{i+1} - \\frac{1}{2}s_{i+1}.\n$$\n这些是提供给数值通量函数的界面状态。对于周期性边界，索引按模 $N$ 处理。\n\n### 3) 数值通量函数\n\n两种格式由其数值通量 $F_{i+\\frac{1}{2}} = F(u_{i+\\frac{1}{2}}^{-}, u_{i+\\frac{1}{2}}^{+})$ 区分。\n\n**a) 迎风-戈杜诺夫通量**\n戈杜诺夫通量基于界面处以 $u_{i+\\frac{1}{2}}^{-}$ 和 $u_{i+\\frac{1}{2}}^{+}$ 为初态的黎曼问题的精确解。对于线性平流方程 $u_t + a u_x = 0$，解是一个以速度 $a$ 传播的接触间断。因此，在界面位置 $x=x_{i+\\frac{1}{2}}$ 处的解的值是 $u_{i+\\frac{1}{2}}^{-}$（如果 $a > 0$，信息从左侧传播）或 $u_{i+\\frac{1}{2}}^{+}$（如果 $a  0$，信息从右侧传播）。物理通量为 $f(u) = au$。因此，戈杜诺夫数值通量是 $F_{i+\\frac{1}{2}}^{\\text{up}} = f(u_{\\text{Riemann}}(0,t))$，这给出：\n$$\nF_{i+\\frac{1}{2}}^{\\text{up}} = \\begin{cases} a\\,u_{i+\\frac{1}{2}}^{-}  \\text{if } a > 0 \\\\ a\\,u_{i+\\frac{1}{2}}^{+}  \\text{if } a  0 \\end{cases}\n$$\n这可以紧凑地写为 $F_{i+\\frac{1}{2}}^{\\text{up}} = \\frac{a}{2}(u_{i+\\frac{1}{2}}^{-} + u_{i+\\frac{1}{2}}^{+}) - \\frac{|a|}{2}(u_{i+\\frac{1}{2}}^{+} - u_{i+\\frac{1}{2}}^{-})$。\n\n**b) 二阶中心拉克斯-温德罗夫通量**\n对于 $u_t + f_x = 0$ 的经典单步拉克斯-温德罗夫格式可以写成守恒形式 $u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}})$，其中数值通量被确定为：\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left( f(u_i) + f(u_{i+1}) \\right) - \\frac{\\Delta t}{2\\Delta x} A_{i+\\frac{1}{2}}\\left( f(u_{i+1}) - f(u_i) \\right),\n$$\n其中 $A_{i+\\frac{1}{2}}$ 是通量雅可比矩阵 $f'(u)$ 的某种平均。对于线性平流方程，$f(u) = au$，雅可比矩阵就是常数 $a$。通量变为：\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left( au_i + au_{i+1} \\right) - \\frac{a\\Delta t}{2\\Delta x}\\left( au_{i+1} - au_i \\right) = a \\left[ \\frac{1}{2}(u_i + u_{i+1}) - \\frac{a\\Delta t}{2\\Delta x}(u_{i+1} - u_i) \\right].\n$$\n为了构造所要求的二阶中心格式，此通量形式不应用于单元平均值 $\\bar{u}_i, \\bar{u}_{i+1}$，而是应用于重构的界面状态 $u_{i+\\frac{1}{2}}^{-}, u_{i+\\frac{1}{2}}^{+}$。将它们分别替换 $u_i$ 和 $u_{i+1}$，并定义有符号的 CFL 数 $\\lambda = a \\Delta t / \\Delta x$，我们得到指定的通量：\n$$\nF_{i+\\frac{1}{2}}^{\\text{LW}} = a\\left[\\tfrac{1}{2}\\left(u_{i+\\tfrac{1}{2}}^{-} + u_{i+\\tfrac{1}{2}}^{+}\\right) - \\tfrac{1}{2}\\lambda \\left(u_{i+\\tfrac{1}{2}}^{+} - u_{i+\\tfrac{1}{2}}^{-}\\right)\\right].\n$$\n此通量是中心的，因为它对称地使用来自两侧的信息，但它包含一个与 $\\lambda$ 成正比的二阶修正项，该项近似了稳定性和精度所需的耗散。\n\n### 4) 时间积分\n\n半离散系统 $\\frac{d\\bar{\\mathbf{u}}}{dt} = \\mathcal{L}(\\bar{\\mathbf{u}})$，其中 $\\mathcal{L}_i(\\bar{\\mathbf{u}}) = -\\frac{1}{\\Delta x}(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}})$，使用二阶两步强稳定性保持（SSP）龙格-库塔方法（通常表示为 SSP(2,2)）进行时间推进。给定时间 $t_n$ 的解 $\\bar{\\mathbf{u}}^n$，在 $t_{n+1} = t_n + \\Delta t$ 的解通过以下方式找到：\n\\begin{align*}\n\\bar{\\mathbf{u}}^{(1)} = \\bar{\\mathbf{u}}^n + \\Delta t \\, \\mathcal{L}(\\bar{\\mathbf{u}}^n) \\\\\n\\bar{\\mathbf{u}}^{n+1} = \\frac{1}{2}\\bar{\\mathbf{u}}^n + \\frac{1}{2}\\left(\\bar{\\mathbf{u}}^{(1)} + \\Delta t \\, \\mathcal{L}(\\bar{\\mathbf{u}}^{(1)})\\right)\n\\end{align*}\nSSP 方法旨在当向前欧拉步在合适的 CFL 条件下满足 TVD 性质时，保持空间离散化的 TVD 性质。时间步长 $\\Delta t$ 基于用户指定的 CFL 数选择，$\\Delta t = \\text{CFL} \\frac{\\Delta x}{|a|}$。\n\n### 5) 量化过冲和下冲\n\n对于初值在 $U_{\\min} = \\min(u_L, u_R)$ 和 $U_{\\max} = \\max(u_L, u_R)$ 范围内的初值问题，TVD 格式保证在任何后续时间的解都将保持在这些界限内。非 TVD 格式可能会在间断附近产生伪振荡（类吉布斯现象），其中解会超过 $U_{\\max}$（过冲）或低于 $U_{\\min}$（下冲）。这些在最终时间 $T$ 被量化为：\n$$\nM_{\\text{over}} = \\max\\{0, \\max_i \\bar{u}_i(T) - U_{\\max}\\}\n$$\n$$\nM_{\\text{under}} = \\max\\{0, U_{\\min} - \\min_i \\bar{u}_i(T)\\}\n$$\n\n### 6) 算法实现\n\n实现过程如下：\n- 对每个测试用例，定义网格参数（$N$, $\\Delta x$, $x_i$）和模拟参数（$a$, $\\text{CFL}$, $T$）。\n- 通过在单元中心 $x_i$ 处评估给定的阶跃函数来创建初始条件向量 $\\bar{\\mathbf{u}}(0)$。\n- 一个时间步进循环将解从 $t=0$ 推进到 $t=T$。计算时间步长 $\\Delta t$，并可能在最后一步减小以精确到达 $T$。\n- 时间积分器的每一步都需要评估右侧项 $\\mathcal{L}(\\bar{\\mathbf{u}})$。这包括：\n    1. 计算所有单元的斜率 $s_i$，处理周期性边界。\n    2. 计算所有界面的左、右界面状态 $u_{i+\\frac{1}{2}}^{-}, u_{i+\\frac{1}{2}}^{+}$。\n    3. 使用迎风或中心拉克斯-温德罗夫公式计算数值通量向量 $F_{i+\\frac{1}{2}}$。\n    4. 对通量进行差分以得到 $\\mathcal{L}(\\bar{\\mathbf{u}})$。\n- 对迎风和中心通量格式都执行此过程。\n- 在最终时间 $T$，找到每种格式的解向量 $\\bar{\\mathbf{u}}(T)$ 的全局最小值和最大值，并计算和记录 $M_{\\text{over}}$ 和 $M_{\\text{under}}$。\n- 将所有测试用例的结果聚合成指定的列表之列表格式以供输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test A (happy path, moderate resolution)\n        {'L': 1.0, 'N': 200, 'a': 1.0, 'u_L': 1.0, 'u_R': 0.0, 'x_0': 0.3, 'CFL': 0.45, 'T': 0.20},\n        # Test B (coarse grid)\n        {'L': 1.0, 'N': 40, 'a': 1.0, 'u_L': 1.0, 'u_R': 0.0, 'x_0': 0.3, 'CFL': 0.45, 'T': 0.20},\n        # Test C (CFL near stability limit)\n        {'L': 1.0, 'N': 200, 'a': 1.0, 'u_L': 1.0, 'u_R': 0.0, 'x_0': 0.3, 'CFL': 0.95, 'T': 0.20},\n        # Test D (small jump)\n        {'L': 1.0, 'N': 200, 'a': 1.0, 'u_L': 0.6, 'u_R': 0.4, 'x_0': 0.3, 'CFL': 0.60, 'T': 0.20},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        case_results = []\n        \n        # Run for central Lax-Wendroff flux\n        u_final_lw = run_simulation(params, flux_type='central')\n        U_min = min(params['u_L'], params['u_R'])\n        U_max = max(params['u_L'], params['u_R'])\n        M_over_lw = max(0, np.max(u_final_lw) - U_max)\n        M_under_lw = max(0, U_min - np.min(u_final_lw))\n        case_results.extend([M_over_lw, M_under_lw])\n        \n        # Run for upwind Godunov flux\n        u_final_up = run_simulation(params, flux_type='upwind')\n        M_over_up = max(0, np.max(u_final_up) - U_max)\n        M_under_up = max(0, U_min - np.min(u_final_up))\n        case_results.extend([M_over_up, M_under_up])\n        \n        all_results.append([f\"{val:.6f}\" for val in case_results])\n\n    # Final print statement in the exact required format.\n    formatted_results = \",\".join([f\"[{','.join(res)}]\" for res in all_results])\n    print(f\"[{formatted_results}]\")\n\ndef minmod(alpha, beta):\n    \"\"\"Vectorized minmod function.\"\"\"\n    return np.where(alpha * beta = 0, 0, np.sign(alpha) * np.minimum(np.abs(alpha), np.abs(beta)))\n\ndef get_rhs(u, dx, a, dt, flux_type):\n    \"\"\"\n    Computes the right-hand side of the semi-discrete system du/dt = L(u).\n    This involves slope calculation, reconstruction, and flux evaluation.\n    \"\"\"\n    # 1. Compute slopes s_i with periodic boundaries\n    u_fwd = np.roll(u, -1) - u\n    u_bwd = u - np.roll(u, 1)\n    s = minmod(u_bwd, u_fwd)\n\n    # 2. Reconstruct interface states u_{i+1/2}^{-} and u_{i+1/2}^{+}\n    # u_minus corresponds to u_{i+1/2}^{-}\n    u_minus = u + 0.5 * s\n    # u_plus corresponds to u_{i+1/2}^{+}\n    # To get s_{i+1} for all i, we roll s by -1\n    u_plus = np.roll(u, -1) - 0.5 * np.roll(s, -1)\n\n    # 3. Calculate numerical fluxes F_{i+1/2}\n    if flux_type == 'upwind':\n        # Godunov flux for linear advection\n        if a > 0:\n            F = a * u_minus\n        else:\n            F = a * u_plus\n            \n    elif flux_type == 'central':\n        # Second-order central Lax-Wendroff type flux\n        # Note: lambda (CFL number) can be signed.\n        lamb = a * dt / dx\n        F = a * (0.5 * (u_minus + u_plus) - 0.5 * lamb * (u_plus - u_minus))\n    else:\n        raise ValueError(\"Invalid flux type specified.\")\n\n    # 4. Compute the flux divergence\n    # F_{i-1/2} is obtained by rolling F by 1\n    F_minus_half = np.roll(F, 1)\n    rhs = -(F - F_minus_half) / dx\n    \n    return rhs\n\ndef run_simulation(params, flux_type):\n    \"\"\"\n    Runs a single finite volume simulation.\n    \"\"\"\n    L = params['L']\n    N = params['N']\n    a = params['a']\n    u_L = params['u_L']\n    u_R = params['u_R']\n    x_0 = params['x_0']\n    CFL = params['CFL']\n    T = params['T']\n\n    # Grid setup\n    dx = L / N\n    x = np.linspace(dx/2, L - dx/2, N)\n\n    # Initial condition (cell-centered evaluation)\n    u0 = np.where(x  x_0, u_L, u_R)\n    \n    u = u0.copy()\n    t = 0.0\n    \n    # Time stepping\n    dt_nominal = CFL * dx / np.abs(a)\n    \n    while t  T:\n        dt = min(dt_nominal, T - t)\n        \n        # SSP(2,2) Runge-Kutta integrator\n        # Stage 1\n        L_u = get_rhs(u, dx, a, dt, flux_type)\n        u1 = u + dt * L_u\n        \n        # Stage 2\n        L_u1 = get_rhs(u1, dx, a, dt, flux_type)\n        u = 0.5 * u + 0.5 * (u1 + dt * L_u1)\n        \n        t += dt\n        \n    return u\n\nsolve()\n```"
        }
    ]
}