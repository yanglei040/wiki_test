{
    "hands_on_practices": [
        {
            "introduction": "To truly understand the Finite Element Method, it is essential to first master its most fundamental building block: the linear basis function. This exercise guides you through the process of deriving shape functions for a simple triangular element from first principles, demonstrating how their algebraic form is directly tied to their geometric properties. By calculating the element stiffness matrix, you will see how these functions form the bridge between the geometry of the mesh and the physics of the problem being solved .",
            "id": "2375619",
            "problem": "Consider a single triangular finite element in two spatial dimensions with vertices at $v_1 = (0,0)$, $v_2 = (2,0)$, and $v_3 = (0,1)$. In the Finite Element Method (FEM) for the Poisson equation with a scalar, constant diffusion coefficient $k$, the standard linear (first-order) basis functions on a triangle are the barycentric coordinates associated with the vertices. The barycentric coordinates are defined as affine functions that are equal to $1$ at their associated vertex, equal to $0$ at the other two vertices, and sum to $1$ at every point of the triangle. They admit a geometric interpretation as ratios of subtriangle areas formed by a point and the element edges. The element stiffness matrix entries for the scalar diffusion problem are given by the bilinear form integral $K_{ij} = \\int_{T} k \\, \\nabla N_i \\cdot \\nabla N_j \\, \\mathrm{d}A$, where $N_i$ denote the shape functions and $T$ is the triangular element domain.\n\nTasks:\n1) Starting only from the defining properties of barycentric coordinates on a triangle (affine, partition of unity, and Kronecker delta property at the vertices), derive explicit expressions for the three linear shape functions $N_1(x,y)$, $N_2(x,y)$, and $N_3(x,y)$ on the given triangle. Use the area interpretation to justify the geometric meaning of each $N_i$ as the (signed) ratio of the area of the subtriangle opposite vertex $v_i$ to the total area of $T$.\n2) Prove the partition of unity property $N_1 + N_2 + N_3 = 1$ and the nodal interpolation property $N_i(v_j) = \\delta_{ij}$ for $i,j \\in \\{1,2,3\\}$.\n3) Show that the gradients $\\nabla N_i$ are constant vectors on $T$, determine them explicitly, and explain their geometric interpretation in relation to the edges opposite the corresponding vertices.\n4) For the scalar diffusion problem with constant coefficient $k = 3$, compute the off-diagonal stiffness entry $K_{12} = \\int_{T} k \\, \\nabla N_1 \\cdot \\nabla N_2 \\, \\mathrm{d}A$ for this element. Express your final answer as a single exact real number. Do not round.",
            "solution": "The problem as stated is a standard, fundamental exercise in the theory of the Finite Element Method. It is scientifically grounded, well-posed, and free from any factual or logical inconsistencies. The definitions and tasks are clear and objective. Therefore, the problem is valid and we shall proceed to construct the solution with requisite rigor.\n\nThe triangular element $T$ is defined by vertices $v_1 = (0,0)$, $v_2 = (2,0)$, and $v_3 = (0,1)$. The area of this triangle, denoted by $A$, is given by $A = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 2 \\times 1 = 1$.\n\n**1) Derivation of Shape Functions**\n\nThe linear shape functions $N_i(x,y)$ are affine functions of the form $N_i(x,y) = a_i x + b_i y + c_i$. The coefficients for each function are determined by the Kronecker delta property at the vertices, $N_i(v_j) = \\delta_{ij}$.\n\nFor $N_1(x,y)$:\nWe impose the conditions $N_1(v_1)=1$, $N_1(v_2)=0$, and $N_1(v_3)=0$.\n$N_1(0,0) = a_1(0) + b_1(0) + c_1 = 1 \\implies c_1 = 1$.\n$N_1(2,0) = a_1(2) + b_1(0) + c_1 = 0 \\implies 2a_1 + 1 = 0 \\implies a_1 = -\\frac{1}{2}$.\n$N_1(0,1) = a_1(0) + b_1(1) + c_1 = 0 \\implies b_1 + 1 = 0 \\implies b_1 = -1$.\nThus, $N_1(x,y) = -\\frac{1}{2}x - y + 1$.\n\nFor $N_2(x,y)$:\nWe impose the conditions $N_2(v_1)=0$, $N_2(v_2)=1$, and $N_2(v_3)=0$.\n$N_2(0,0) = a_2(0) + b_2(0) + c_2 = 0 \\implies c_2 = 0$.\n$N_2(2,0) = a_2(2) + b_2(0) + c_2 = 1 \\implies 2a_2 = 1 \\implies a_2 = \\frac{1}{2}$.\n$N_2(0,1) = a_2(0) + b_2(1) + c_2 = 0 \\implies b_2 = 0$.\nThus, $N_2(x,y) = \\frac{1}{2}x$.\n\nFor $N_3(x,y)$:\nWe impose the conditions $N_3(v_1)=0$, $N_3(v_2)=0$, and $N_3(v_3)=1$.\n$N_3(0,0) = a_3(0) + b_3(0) + c_3 = 0 \\implies c_3 = 0$.\n$N_3(2,0) = a_3(2) + b_3(0) + c_3 = 0 \\implies 2a_3 = 0 \\implies a_3 = 0$.\n$N_3(0,1) = a_3(0) + b_3(1) + c_3 = 1 \\implies b_3 = 1$.\nThus, $N_3(x,y) = y$.\n\nThe geometric interpretation of $N_i$ is the ratio of the area of the subtriangle formed by an arbitrary point $P=(x,y)$ and the edge opposite vertex $v_i$, to the total area of the element $T$. Let us verify this for $N_1$. The subtriangle opposite $v_1$ has vertices $P(x,y)$, $v_2(2,0)$, and $v_3(0,1)$. Its area, $A_1$, can be calculated using the shoelace formula:\n$$ A_1 = \\frac{1}{2} | (x(0) + 2(1) + 0(y)) - (y(2) + 0(0) + 1(x)) | = \\frac{1}{2} | 2 - (2y+x) | $$\nFor any point $(x,y)$ inside the triangle $T$, we have $x > 0$, $y > 0$, and $\\frac{x}{2} + y  1$, which implies $x+2y  2$. The term inside the absolute value is positive. So, $A_1 = \\frac{1}{2}(2 - x - 2y) = 1 - \\frac{1}{2}x - y$.\nThe ratio is $N_1 = \\frac{A_1}{A} = \\frac{1 - \\frac{1}{2}x - y}{1} = 1 - \\frac{1}{2}x - y$. This matches our derived expression. Similar calculations for $N_2$ and $N_3$ confirm their geometric area-ratio definitions.\n\n**2) Proof of Properties**\n\nThe problem asks to prove properties that were already used in the derivation. We will verify that our derived expressions satisfy them.\n\nPartition of Unity: $N_1 + N_2 + N_3 = 1$.\n$$ (1 - \\frac{1}{2}x - y) + (\\frac{1}{2}x) + (y) = 1 - \\frac{1}{2}x + \\frac{1}{2}x - y + y = 1 $$\nThe property holds for all $(x,y)$.\n\nNodal Interpolation Property: $N_i(v_j) = \\delta_{ij}$.\nLet us verify this for the $9$ combinations.\n$N_1(v_1) = 1 - \\frac{1}{2}(0) - 0 = 1$. $N_1(v_2) = 1 - \\frac{1}{2}(2) - 0 = 0$. $N_1(v_3) = 1 - \\frac{1}{2}(0) - 1 = 0$.\n$N_2(v_1) = \\frac{1}{2}(0) = 0$. $N_2(v_2) = \\frac{1}{2}(2) = 1$. $N_2(v_3) = \\frac{1}{2}(0) = 0$.\n$N_3(v_1) = 0$. $N_3(v_2) = 0$. $N_3(v_3) = 1$.\nAll conditions are satisfied, confirming $N_i(v_j) = \\delta_{ij}$.\n\n**3) Gradients of Shape Functions**\n\nThe gradient of a scalar function $f(x,y)$ is $\\nabla f = (\\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y})$. Since the shape functions are affine, their partial derivatives are constants, and so are their gradients.\n$$ \\nabla N_1 = \\left( \\frac{\\partial}{\\partial x}(1 - \\frac{1}{2}x - y), \\frac{\\partial}{\\partial y}(1 - \\frac{1}{2}x - y) \\right) = \\left(-\\frac{1}{2}, -1\\right) $$\n$$ \\nabla N_2 = \\left( \\frac{\\partial}{\\partial x}(\\frac{1}{2}x), \\frac{\\partial}{\\partial y}(\\frac{1}{2}x) \\right) = \\left(\\frac{1}{2}, 0\\right) $$\n$$ \\nabla N_3 = \\left( \\frac{\\partial}{\\partial x}(y), \\frac{\\partial}{\\partial y}(y) \\right) = (0, 1) $$\nThe gradients are indeed constant vectors across the element $T$.\n\nGeometric Interpretation: The gradient $\\nabla N_i$ is a vector that is orthogonal to the level sets of $N_i$. The level sets are lines where $N_i$ is constant. The line where $N_i=0$ is precisely the edge of the triangle opposite to vertex $v_i$. Therefore, $\\nabla N_i$ is a vector normal to the edge opposite $v_i$, pointing from the edge (where $N_i=0$) towards $v_i$ (where $N_i=1$), which is the direction of steepest ascent.\n- Edge opposite $v_1$: connects $v_2(2,0)$ and $v_3(0,1)$. Direction vector is $(-2,1)$. A normal vector is $(1,2)$. $\\nabla N_1 = (-\\frac{1}{2}, -1) = -\\frac{1}{2}(1,2)$. This is indeed normal to the edge.\n- Edge opposite $v_2$: connects $v_1(0,0)$ and $v_3(0,1)$. Direction vector is $(0,1)$. A normal vector is $(1,0)$. $\\nabla N_2 = (\\frac{1}{2}, 0) = \\frac{1}{2}(1,0)$. This is normal to the edge.\n- Edge opposite $v_3$: connects $v_1(0,0)$ and $v_2(2,0)$. Direction vector is $(2,0)$. A normal vector is $(0,1)$. $\\nabla N_3 = (0,1)$, which is normal to the edge.\n\n**4) Computation of Stiffness Matrix Entry $K_{12}$**\n\nThe stiffness matrix entry $K_{12}$ is given by the formula $K_{12} = \\int_{T} k \\, \\nabla N_1 \\cdot \\nabla N_2 \\, \\mathrm{d}A$, with the diffusion coefficient $k=3$.\nFirst, calculate the dot product of the gradients:\n$$ \\nabla N_1 \\cdot \\nabla N_2 = \\left(-\\frac{1}{2}, -1\\right) \\cdot \\left(\\frac{1}{2}, 0\\right) = \\left(-\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + (-1)(0) = -\\frac{1}{4} $$\nThe integrand is $k \\, \\nabla N_1 \\cdot \\nabla N_2 = 3 \\times (-\\frac{1}{4}) = -\\frac{3}{4}$.\nSince the integrand is a constant, the integral is this constant multiplied by the area of the domain of integration, $A = 1$.\n$$ K_{12} = \\int_{T} \\left(-\\frac{3}{4}\\right) \\mathrm{d}A = -\\frac{3}{4} \\int_{T} \\mathrm{d}A = -\\frac{3}{4} \\times A = -\\frac{3}{4} \\times 1 = -\\frac{3}{4} $$\nThe value of the off-diagonal stiffness entry is $-\\frac{3}{4}$.",
            "answer": "$$\\boxed{-\\frac{3}{4}}$$"
        },
        {
            "introduction": "In practice, finite elements of various shapes and sizes are generated by mapping a single, perfect 'reference' element. This exercise explores the practical consequences of this mapping, specifically what happens when a node is misplaced, leading to a distorted or 'folded' element . By calculating the determinant of the Jacobian matrix, $J$, you will learn to use this crucial diagnostic tool to verify the geometric validity of your mesh, a critical step in any reliable simulation.",
            "id": "2375611",
            "problem": "Consider the isoparametric quadratic triangular element used in the Finite Element Method (FEM). Let the reference (parent) triangle be defined in the natural coordinates $(\\xi,\\eta)$ by $\\xi \\ge 0$, $\\eta \\ge 0$, and $\\xi + \\eta \\le 1$. Let the associated area (barycentric) coordinates be $L_1 = 1 - \\xi - \\eta$, $L_2 = \\xi$, and $L_3 = \\eta$. The physical element has vertex nodes at $(x_1,y_1) = (0,0)$, $(x_2,y_2) = (1,0)$, and $(x_3,y_3) = (0,1)$. The mid-side nodes are $(x_4,y_4) = \\left(\\frac{1}{2},0\\right)$ on edge $1$–$2$, $(x_6,y_6) = \\left(0,\\frac{1}{2}\\right)$ on edge $3$–$1$, and node $5$ (nominally on edge $2$–$3$) is deliberately moved to $(x_5,y_5) = \\left(0,\\frac{1}{5}\\right)$. Using the standard quadratic shape functions constructed from the area coordinates for a $6$-node quadratic triangle, form the isoparametric map $(x(\\xi,\\eta),y(\\xi,\\eta)) = \\sum_{i=1}^{6} N_i(\\xi,\\eta) (x_i,y_i)$, compute the Jacobian matrix $\\partial(x,y)/\\partial(\\xi,\\eta)$ at the centroid $(\\xi,\\eta) = \\left(\\frac{1}{3},\\frac{1}{3}\\right)$, and evaluate its determinant $J$ at that point. Report the exact value of $J$ (no rounding). Then, in a single sentence, state the physical meaning of the sign of $J$ for this element configuration. Your final numerical answer should be the value of $J$.",
            "solution": "The problem statement is critically examined and found to be valid. It is scientifically grounded in the principles of computational physics, specifically the Finite Element Method. It is well-posed, objective, self-contained, and all data provided is consistent. No flaws are detected. We proceed with the solution.\n\nThe problem requires the computation of the Jacobian determinant of an isoparametric mapping for a $6$-node quadratic triangular element at a specific point. The physical coordinates $(x,y)$ are mapped from the reference coordinates $(\\xi,\\eta)$ using the relation:\n$$\nx(\\xi,\\eta) = \\sum_{i=1}^{6} N_i(\\xi,\\eta) x_i\n$$\n$$\ny(\\xi,\\eta) = \\sum_{i=1}^{6} N_i(\\xi,\\eta) y_i\n$$\nwhere $(x_i, y_i)$ are the nodal coordinates in the physical domain and $N_i$ are the quadratic shape functions defined in the reference domain.\n\nThe shape functions for a $6$-node serendipity triangle are given in terms of the area coordinates $L_1$, $L_2$, and $L_3$. For the vertex nodes ($i=1,2,3$), the shape functions are:\n$$\nN_1 = L_1(2L_1 - 1)\n$$\n$$\nN_2 = L_2(2L_2 - 1)\n$$\n$$\nN_3 = L_3(2L_3 - 1)\n$$\nFor the mid-side nodes ($i=4,5,6$), located on edges $1$-$2$, $2$-$3$, and $3$-$1$ respectively, the shape functions are:\n$$\nN_4 = 4L_1L_2\n$$\n$$\nN_5 = 4L_2L_3\n$$\n$$\nN_6 = 4L_3L_1\n$$\nThe area coordinates are related to the natural coordinates $(\\xi, \\eta)$ by:\n$L_1 = 1 - \\xi - \\eta$, $L_2 = \\xi$, and $L_3 = \\eta$.\nSubstituting these into the expressions for the shape functions yields:\n$N_1 = (1 - \\xi - \\eta)(1 - 2\\xi - 2\\eta)$\n$N_2 = \\xi(2\\xi - 1)$\n$N_3 = \\eta(2\\eta - 1)$\n$N_4 = 4\\xi(1 - \\xi - \\eta)$\n$N_5 = 4\\xi\\eta$\n$N_6 = 4\\eta(1 - \\xi - \\eta)$\n\nThe given nodal coordinates in the physical domain are:\n$(x_1,y_1) = (0,0)$\n$(x_2,y_2) = (1,0)$\n$(x_3,y_3) = (0,1)$\n$(x_4,y_4) = (\\frac{1}{2},0)$\n$(x_5,y_5) = (0,\\frac{1}{5})$\n$(x_6,y_6) = (0,\\frac{1}{2})$\n\nWe construct the mapping for $x(\\xi,\\eta)$ by summing the products of the shape functions and the corresponding $x$-coordinates:\n$$\nx(\\xi,\\eta) = N_1(0) + N_2(1) + N_3(0) + N_4\\left(\\frac{1}{2}\\right) + N_5(0) + N_6(0)\n$$\n$$\nx(\\xi,\\eta) = N_2 + \\frac{1}{2}N_4 = \\xi(2\\xi - 1) + \\frac{1}{2} \\cdot 4\\xi(1 - \\xi - \\eta) = 2\\xi^2 - \\xi + 2\\xi(1 - \\xi - \\eta)\n$$\n$$\nx(\\xi,\\eta) = 2\\xi^2 - \\xi + 2\\xi - 2\\xi^2 - 2\\xi\\eta = \\xi - 2\\xi\\eta\n$$\nSimilarly, for $y(\\xi,\\eta)$:\n$$\ny(\\xi,\\eta) = N_1(0) + N_2(0) + N_3(1) + N_4(0) + N_5\\left(\\frac{1}{5}\\right) + N_6\\left(\\frac{1}{2}\\right)\n$$\n$$\ny(\\xi,\\eta) = N_3 + \\frac{1}{5}N_5 + \\frac{1}{2}N_6 = \\eta(2\\eta - 1) + \\frac{1}{5}(4\\xi\\eta) + \\frac{1}{2}(4\\eta(1 - \\xi - \\eta))\n$$\n$$\ny(\\xi,\\eta) = 2\\eta^2 - \\eta + \\frac{4}{5}\\xi\\eta + 2\\eta(1 - \\xi - \\eta) = 2\\eta^2 - \\eta + \\frac{4}{5}\\xi\\eta + 2\\eta - 2\\xi\\eta - 2\\eta^2\n$$\n$$\ny(\\xi,\\eta) = \\eta + \\left(\\frac{4}{5} - 2\\right)\\xi\\eta = \\eta - \\frac{6}{5}\\xi\\eta\n$$\nThe isoparametric mapping is thus:\n$x(\\xi,\\eta) = \\xi(1 - 2\\eta)$\n$y(\\xi,\\eta) = \\eta\\left(1 - \\frac{6}{5}\\xi\\right)$\n\nThe Jacobian matrix $\\mathbf{J}$ of the transformation is defined as:\n$$\n\\mathbf{J} = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\n$$\nWe compute the partial derivatives:\n$\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(\\xi - 2\\xi\\eta) = 1 - 2\\eta$\n$\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(\\xi - 2\\xi\\eta) = -2\\xi$\n$\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(\\eta - \\frac{6}{5}\\xi\\eta) = -\\frac{6}{5}\\eta$\n$\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(\\eta - \\frac{6}{5}\\xi\\eta) = 1 - \\frac{6}{5}\\xi$\nThe Jacobian matrix is:\n$$\n\\mathbf{J}(\\xi,\\eta) = \\begin{pmatrix} 1 - 2\\eta  -2\\xi \\\\ -\\frac{6}{5}\\eta  1 - \\frac{6}{5}\\xi \\end{pmatrix}\n$$\nWe must evaluate this matrix at the centroid of the reference triangle, which is at $(\\xi, \\eta) = (\\frac{1}{3}, \\frac{1}{3})$.\nSubstituting these values:\n$\\frac{\\partial x}{\\partial \\xi} \\bigg|_{(\\frac{1}{3},\\frac{1}{3})} = 1 - 2\\left(\\frac{1}{3}\\right) = \\frac{1}{3}$\n$\\frac{\\partial x}{\\partial \\eta} \\bigg|_{(\\frac{1}{3},\\frac{1}{3})} = -2\\left(\\frac{1}{3}\\right) = -\\frac{2}{3}$\n$\\frac{\\partial y}{\\partial \\xi} \\bigg|_{(\\frac{1}{3},\\frac{1}{3})} = -\\frac{6}{5}\\left(\\frac{1}{3}\\right) = -\\frac{2}{5}$\n$\\frac{\\partial y}{\\partial \\eta} \\bigg|_{(\\frac{1}{3},\\frac{1}{3})} = 1 - \\frac{6}{5}\\left(\\frac{1}{3}\\right) = 1 - \\frac{2}{5} = \\frac{3}{5}$\nThe Jacobian matrix at the centroid is:\n$$\n\\mathbf{J}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = \\begin{pmatrix} \\frac{1}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{5}  \\frac{3}{5} \\end{pmatrix}\n$$\nThe determinant $J$ of this matrix is:\n$$\nJ = \\det(\\mathbf{J}) = \\left(\\frac{1}{3}\\right)\\left(\\frac{3}{5}\\right) - \\left(-\\frac{2}{3}\\right)\\left(-\\frac{2}{5}\\right) = \\frac{3}{15} - \\frac{4}{15} = -\\frac{1}{15}\n$$\nThe value of the Jacobian determinant at the centroid is $-\\frac{1}{15}$.\n\nThe physical meaning of the sign of the Jacobian determinant $J$ relates to the local validity of the mapping; the negative sign of $J$ indicates that the isoparametric mapping from reference to physical coordinates is not one-to-one and has locally inverted the element geometry at that point.",
            "answer": "$$ \\boxed{-\\frac{1}{15}} $$"
        },
        {
            "introduction": "Once you have a valid mesh, the next question is how to achieve the desired accuracy efficiently. This hands-on coding challenge explores the two fundamental strategies for improving a finite element solution: using many simple elements (h-version) versus using fewer, more sophisticated elements (p-version) . By implementing a 1D solver and comparing these approaches, you will gain practical insight into their convergence behavior and the critical trade-offs between computational cost and accuracy.",
            "id": "2375591",
            "problem": "Write a complete, runnable program that, for the one-dimensional Poisson boundary value problem on the unit interval with a smooth exact solution, compares accuracy against a simple, size-based computational cost metric for different combinations of mesh refinement and polynomial degree in the finite element method.\n\nConsider the boundary value problem on the domain $[0,1]$:\n- Find $u: [0,1] \\rightarrow \\mathbb{R}$ such that\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in (0,1), \\quad u(0)=0, \\; u(1)=0,\n$$\nwith the exact solution specified as\n$$\nu(x) = \\sin(2\\pi x),\n$$\nso that\n$$\nf(x) = (2\\pi)^2 \\sin(2\\pi x).\n$$\n\nLet $N \\in \\mathbb{N}$ be the number of uniform elements partitioning $[0,1]$ and let $p \\in \\mathbb{N}$ be the local polynomial degree. Use a standard conforming finite element space consisting of continuous, piecewise-polynomial Lagrange basis (shape) functions of degree $p$ on each element, constructed from the reference element $[-1,1]$ via an affine map, with the $p+1$ local interpolation nodes taken to be equispaced points in the reference coordinate. Impose the homogeneous Dirichlet boundary conditions strongly at $x=0$ and $x=1$.\n\nFormulate and solve the Galerkin problem: find $u_h$ in the finite element space with $u_h(0)=0$ and $u_h(1)=0$ such that\n$$\n\\int_0^1 u_h'(x)\\, v_h'(x) \\, dx \\;=\\; \\int_0^1 f(x)\\, v_h(x) \\, dx \\quad \\text{for all admissible } v_h.\n$$\n\nDefine the computational cost metric for a given pair $(N,p)$ as the total number of free (non-Dirichlet) degrees of freedom,\n$$\n\\text{cost}(N,p) \\equiv \\text{ndof}(N,p) = Np - 1,\n$$\nwhich follows from the one-dimensional, continuous, degree-$p$ Lagrange finite element space on a uniform mesh with homogeneous Dirichlet boundary conditions at both endpoints. If $\\text{ndof}(N,p)=0$, interpret the discrete solution as the identically zero function.\n\nFor each specified test case $(N,p)$, compute:\n1. The integer $\\text{ndof}(N,p)$ as defined above.\n2. The $L^2$-norm of the error,\n$$\n\\lVert u - u_h \\rVert_{L^2(0,1)} \\;=\\; \\left( \\int_0^1 \\big(u(x)-u_h(x)\\big)^2 \\, dx \\right)^{1/2},\n$$\nevaluated to high numerical accuracy.\n\nTest Suite:\n- Case A (many low-order elements; $h$-version): $(N,p)=(64,1)$.\n- Case B (few high-order elements; $p$-version): $(N,p)=(4,8)$.\n- Case C (boundary-degenerate case): $(N,p)=(1,1)$.\n- Case D (intermediate): $(N,p)=(16,2)$.\n- Case E (extreme $p$-version on a single element): $(N,p)=(1,12)$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a two-element list $[\\text{ndof}, \\text{error}]$ where $\\text{ndof}$ is an integer and $\\text{error}$ is a floating-point number rounded to $10$ significant digits. For the test suite ordered as A, B, C, D, E, the output must have the form:\n$$\n\\big[[\\text{ndof}_A,\\text{error}_A],[\\text{ndof}_B,\\text{error}_B],[\\text{ndof}_C,\\text{error}_C],[\\text{ndof}_D,\\text{error}_D],[\\text{ndof}_E,\\text{error}_E]\\big].\n$$",
            "solution": "The problem statement has been subjected to rigorous validation and is determined to be valid. It is scientifically grounded, well-posed, objective, and complete. It describes a standard problem in the numerical analysis of partial differential equations, specifically the finite element method (FEM) for the one-dimensional Poisson equation. All parameters, equations, and definitions are mathematically and scientifically consistent. We may therefore proceed with the solution.\n\nThe problem requires a comparison of accuracy versus a computational cost metric for different finite element discretizations of the boundary value problem:\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in (0,1), \\quad u(0)=0, \\; u(1)=0\n$$\nwhere the exact solution is given as $u(x) = \\sin(2\\pi x)$, which implies the forcing function is $f(x) = (2\\pi)^2 \\sin(2\\pi x)$.\n\nThe solution will be constructed following the principles of the Galerkin finite element method.\n\n### 1. Weak Formulation\nThe starting point is the weak (or variational) formulation of the problem. We multiply the differential equation by a sufficiently smooth test function $v(x)$ that satisfies the homogeneous boundary conditions, i.e., $v(0)=v(1)=0$, and integrate over the domain $\\Omega = [0,1]$.\n$$\n-\\int_0^1 u''(x) v(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx\n$$\nApplying integration by parts to the left-hand side yields:\n$$\n\\int_0^1 u'(x) v'(x) \\, dx - \\left[ u'(x) v(x) \\right]_0^1 = \\int_0^1 f(x) v(x) \\, dx\n$$\nThe boundary term $[ u'(x) v(x) ]_0^1$ vanishes because the test function $v(x)$ is required to be zero at $x=0$ and $x=1$. We thus arrive at the weak formulation: find $u \\in H_0^1(0,1)$ such that\n$$\na(u,v) = L(v) \\quad \\forall v \\in H_0^1(0,1),\n$$\nwhere $a(u,v) = \\int_0^1 u'(x) v'(x) \\, dx$ is a bilinear form and $L(v) = \\int_0^1 f(x) v(x) \\, dx$ is a linear functional. $H_0^1(0,1)$ is the Sobolev space of functions with square-integrable first derivatives that vanish at the boundaries.\n\n### 2. Finite Element Discretization\nThe continuous problem is discretized by replacing the infinite-dimensional function space $H_0^1(0,1)$ with a finite-dimensional subspace $V_h \\subset H_0^1(0,1)$. The domain $[0,1]$ is partitioned into $N$ uniform elements $K_e = [x_e, x_{e+1}]$ of size $h=1/N$. On each element, the solution is approximated by a polynomial of degree $p$.\n\nThe finite element space $V_h$ consists of continuous, piecewise-polynomial functions of degree $p$. A basis for this space is constructed using global basis functions $\\phi_i(x)$, such that any function $u_h \\in V_h$ can be written as a linear combination:\n$$\nu_h(x) = \\sum_{i=1}^{\\text{ndof}} U_i \\phi_i(x)\n$$\nHere, $U_i$ are the unknown coefficients, which correspond to the values of $u_h$ at the interior nodes of the mesh, and $\\phi_i(x)$ are the basis functions associated with these nodes. The total number of degrees of freedom (DoFs) after enforcing the homogeneous Dirichlet boundary conditions is given as $\\text{ndof}(N,p) = Np-1$.\n\nThe Galerkin method seeks an approximate solution $u_h \\in V_h$ such that the weak form holds for all test functions $v_h \\in V_h$. By choosing the test functions to be the basis functions themselves, $v_h = \\phi_j(x)$, we obtain a system of linear equations:\n$$\n\\sum_{i=1}^{\\text{ndof}} \\left( \\int_0^1 \\phi_i'(x) \\phi_j'(x) \\, dx \\right) U_i = \\int_0^1 f(x) \\phi_j(x) \\, dx \\quad \\text{for } j=1, \\dots, \\text{ndof}\n$$\nThis is the linear system $\\mathbf{A}\\mathbf{U} = \\mathbf{b}$, where:\n-   The stiffness matrix $\\mathbf{A}$ has entries $A_{ji} = a(\\phi_i, \\phi_j) = \\int_0^1 \\phi_i'(x) \\phi_j'(x) \\, dx$.\n-   The load vector $\\mathbf{b}$ has entries $b_j = L(\\phi_j) = \\int_0^1 f(x) \\phi_j(x) \\, dx$.\n-   The solution vector $\\mathbf{U}$ contains the unknown coefficients $U_i$.\n\n### 3. System Assembly using a Reference Element\nThe integrals for $\\mathbf{A}$ and $\\mathbf{b}$ are computed by summing contributions from each element $K_e$. This process is standardized by mapping each physical element $K_e = [x_e, x_{e+1}]$ to a single reference element $\\hat{K} = [-1,1]$ via the affine transformation:\n$$\nx(\\xi) = x_e + \\frac{h}{2}(\\xi+1)\n$$\nThe differential element transforms as $dx = \\frac{h}{2}d\\xi$, and the derivative operator transforms as $\\frac{d}{dx} = \\frac{2}{h}\\frac{d}{d\\xi}$.\n\nThe basis functions on the reference element, $\\hat{\\phi}_j(\\xi)$, are degree-$p$ Lagrange polynomials defined by a set of $p+1$ equispaced nodes $\\xi_j = -1 + j\\frac{2}{p}$ for $j=0,\\dots,p$.\nThe element stiffness matrix and load vector for element $e$ are then computed on the reference element:\n$$\nA^e_{ij} = \\int_{-1}^1 \\left(\\frac{2}{h}\\frac{d\\hat{\\phi}_i}{d\\xi}\\right) \\left(\\frac{2}{h}\\frac{d\\hat{\\phi}_j}{d\\xi}\\right) \\frac{h}{2} d\\xi = \\frac{2}{h} \\int_{-1}^1 \\frac{d\\hat{\\phi}_i}{d\\xi} \\frac{d\\hat{\\phi}_j}{d\\xi} d\\xi\n$$\n$$\nb^e_i = \\int_{-1}^1 f(x(\\xi)) \\hat{\\phi}_i(\\xi) \\frac{h}{2} d\\xi\n$$\nThese integrals are evaluated numerically using Gauss-Legendre quadrature, which provides high accuracy. The local matrices $A^e$ and vectors $b^e$ are then assembled into the global system $\\mathbf{A}\\mathbf{U} = \\mathbf{b}$, respecting the mapping between local and global degrees of freedom and excluding the fixed boundary DoFs.\n\n### 4. Solution and Error Computation\nOnce assembled, the symmetric positive-definite linear system $\\mathbf{A}\\mathbf{U} = \\mathbf{b}$ is solved for the vector of coefficients $\\mathbf{U}$. This vector, augmented with the zero values at the boundaries, fully defines the approximate solution $u_h(x)$.\n\nThe accuracy of the solution is quantified by the $L^2$-norm of the error, defined as:\n$$\n\\lVert u - u_h \\rVert_{L^2(0,1)} = \\left( \\int_0^1 \\big(u(x)-u_h(x)\\big)^2 \\, dx \\right)^{1/2}\n$$\nThis integral is also computed element-wise using numerical quadrature on the reference element:\n$$\n\\lVert u - u_h \\rVert_{L^2(0,1)}^2 = \\sum_{e=0}^{N-1} \\int_{-1}^1 \\left( u(x(\\xi)) - \\sum_{j=0}^{p} U^e_j \\hat{\\phi}_j(\\xi) \\right)^2 \\frac{h}{2} d\\xi\n$$\nwhere $U^e_j$ are the computed coefficients of the solution corresponding to the nodes of element $e$.\n\nA special case arises for $(N,p)=(1,1)$, where $\\text{ndof}=0$. In this configuration, the only two nodes are the boundary nodes at $x=0$ and $x=1$. The strong imposition of $u_h(0)=0$ and $u_h(1)=0$ forces the linear interpolant to be identically zero, $u_h(x) \\equiv 0$. The error is then simply the $L^2$-norm of the exact solution, $\\lVert u \\rVert_{L^2} = (\\int_0^1 \\sin^2(2\\pi x) dx)^{1/2} = 1/\\sqrt{2}$.\n\nThe implementation will carry out these steps for each test case $(N, p)$ and report the computed $\\text{ndof}$ and error.",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef get_lagrange_basis_and_deriv(p, eval_points):\n    \"\"\"\n    Computes degree-p Lagrange basis functions and their derivatives on [-1, 1].\n    The basis is defined by p+1 equispaced nodes.\n\n    Args:\n        p (int): Polynomial degree.\n        eval_points (np.ndarray): Points in [-1, 1] to evaluate basis at.\n\n    Returns:\n        tuple: A tuple (phi, dphi) where:\n               - phi is a (num_eval_points, p+1) array of basis function values.\n               - dphi is a (num_eval_points, p+1) array of basis derivative values.\n    \"\"\"\n    nodes = np.linspace(-1, 1, p + 1)\n    num_eval_points = len(eval_points)\n    phi = np.zeros((num_eval_points, p + 1))\n    dphi = np.zeros((num_eval_points, p + 1))\n\n    for j in range(p + 1):  # For each basis function phi_j\n        # Denominator for phi_j\n        denom = np.prod([nodes[j] - nodes[k] for k in range(p + 1) if k != j])\n        \n        for i, xi in enumerate(eval_points):  # For each evaluation point\n            # Numerator for phi_j(xi)\n            num = np.prod([xi - nodes[k] for k in range(p + 1) if k != j])\n            phi[i, j] = num / denom\n\n            # Derivative dphi_j/dxi using the product rule\n            d_num = 0.0\n            if p > 0:\n                for m_idx in range(p + 1):\n                    if m_idx == j:\n                        continue\n                    # Product of all (xi - nodes[k]) except for k=j and k=m_idx\n                    term = np.prod([xi - nodes[k] for k in range(p + 1) if k != j and k != m_idx])\n                    d_num += term\n            dphi[i, j] = d_num / denom\n    return phi, dphi\n\ndef solve_fem(N, p):\n    \"\"\"\n    Solves the 1D Poisson problem using the Finite Element Method.\n\n    Args:\n        N (int): Number of elements.\n        p (int): Polynomial degree.\n\n    Returns:\n        tuple: A tuple (ndof, error) where:\n               - ndof is the number of free degrees of freedom.\n               - error is the L2 norm of the error.\n    \"\"\"\n    ndof = N * p - 1\n    \n    # Handle the boundary-degenerate case where no free DoFs exist\n    if ndof = 0:\n        # The solution is u_h=0. Error is ||u-0||_L2 = ||u||_L2.\n        # integral from 0 to 1 of sin^2(2*pi*x) dx is 1/2.\n        error = np.sqrt(0.5)\n        return max(0, ndof), error\n\n    h = 1.0 / N\n\n    # 1. Reference element calculations\n    # Use a high-order quadrature rule for accuracy\n    quad_order = p + 8\n    xi_q, w_q = leggauss(quad_order)\n\n    # Get basis functions and derivatives at quadrature points\n    phi, dphi = get_lagrange_basis_and_deriv(p, xi_q)\n\n    # Pre-compute reference stiffness matrix component\n    A_hat_integrand = np.einsum('qi,qj->ijq', dphi, dphi)\n    A_hat = np.einsum('ijq,q->ij', A_hat_integrand, w_q)\n    \n    # 2. System Assembly\n    A = np.zeros((ndof, ndof))\n    b = np.zeros(ndof)\n\n    for e in range(N):  # Loop over elements\n        # Element stiffness matrix\n        A_e = (2.0 / h) * A_hat\n        \n        # Element load vector\n        x_q = (e + 0.5) * h + 0.5 * h * xi_q  # Quadrature points in physical element\n        f_vals = (2 * np.pi)**2 * np.sin(2 * np.pi * x_q)\n        b_e = np.einsum('q,qi,q->i', f_vals, phi, w_q) * (h / 2.0)\n\n        # Map local to global DOFs and assemble\n        for i in range(p + 1):\n            I = e * p + i  # Global index before removing BCs\n            if I > 0 and I  N * p:  # Check if it is a free DoF\n                # Assemble load vector\n                b[I - 1] += b_e[i]\n                for j in range(p + 1):\n                    J = e * p + j\n                    if J > 0 and J  N * p:  # Check if it is a free DoF\n                        # Assemble stiffness matrix\n                        A[I - 1, J - 1] += A_e[i, j]\n\n    # 3. Solve system for free DoFs\n    U_free = np.linalg.solve(A, b)\n\n    # Create full solution vector including BCs\n    U_full = np.zeros(N * p + 1)\n    U_full[1:N * p] = U_free\n    \n    # 4. Error calculation\n    total_error_sq = 0.0\n    for e in range(N):\n        # Get nodal values for this element\n        U_e = U_full[e * p : (e + 1) * p + 1]\n        \n        # u_h at quadrature points\n        u_h_vals = np.dot(phi, U_e)\n        \n        # u_exact at quadrature points\n        x_q = (e + 0.5) * h + 0.5 * h * xi_q\n        u_exact_vals = np.sin(2 * np.pi * x_q)\n        \n        # Error on element\n        error_sq_e = np.sum((u_exact_vals - u_h_vals)**2 * w_q) * (h / 2.0)\n        total_error_sq += error_sq_e\n        \n    error = np.sqrt(total_error_sq)\n    \n    return ndof, error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (64, 1),  # Case A\n        (4, 8),   # Case B\n        (1, 1),   # Case C\n        (16, 2),  # Case D\n        (1, 12),  # Case E\n    ]\n\n    results = []\n    for N, p in test_cases:\n        ndof, error = solve_fem(N, p)\n        results.append((ndof, error))\n\n    # Format the output string exactly as requested\n    formatted_results = []\n    for ndof, error in results:\n        # Format error to 10 significant digits\n        formatted_error = f\"{error:.10g}\"\n        formatted_results.append(f\"[{ndof},{formatted_error}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}