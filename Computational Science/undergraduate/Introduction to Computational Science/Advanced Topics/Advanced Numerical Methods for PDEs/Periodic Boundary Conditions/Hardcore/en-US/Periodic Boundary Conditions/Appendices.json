{
    "hands_on_practices": [
        {
            "introduction": "Before we delve into complex computer simulations, it is essential to grasp how periodic boundary conditions (PBCs) fundamentally shape the mathematical description of physical systems. This first exercise examines a classic eigenvalue problem that governs wave-like phenomena, such as the vibrations of a string. By determining the allowed standing wave patterns on a continuous circular loop, you will see firsthand how the constraint of periodicity forces the solutions to adopt a discrete set of wavevectors, laying the groundwork for Fourier series analysis in periodic domains .",
            "id": "2124833",
            "problem": "The study of vibrations on a continuous medium often leads to eigenvalue problems. Consider a simplified model for the standing waves on a thin, uniform, circular wire loop. The spatial shape of these waves, denoted by a real-valued function $X(x)$, can be found by solving an ordinary differential equation.\n\nLet the position along the loop be parametrized by $x$, where the domain is the interval $[-\\pi, \\pi]$. The governing equation for the spatial part of a standing wave is given by the eigenvalue problem:\n$$-\\frac{d^2X}{dx^2} = \\lambda X(x)$$\nwhere $\\lambda$ is a constant representing the eigenvalue.\n\nSince the wire forms a continuous, unbroken loop, the displacement $X(x)$ and its slope $\\frac{dX}{dx}$ must be continuous and single-valued at every point. This physical requirement imposes periodic boundary conditions at the ends of the defined interval:\n1. $X(-\\pi) = X(\\pi)$\n2. $X'(-\\pi) = X'(\\pi)$\n\nYour task is to find all possible non-negative eigenvalues $\\lambda$ and their corresponding non-trivial, real-valued eigenfunctions $X(x)$ that satisfy these conditions. Which of the following options correctly describes the complete set of eigenvalues and eigenfunctions for this system?\n\nA. The eigenvalues are $\\lambda_n = n^2$ for integers $n \\ge 1$, and the corresponding eigenfunction for each $\\lambda_n$ is of the form $X_n(x) = C_n \\sin(nx)$, where $C_n$ is a non-zero constant.\n\nB. The eigenvalues are $\\lambda_n = \\left(n - \\frac{1}{2}\\right)^2$ for integers $n \\ge 1$, and the corresponding eigenfunction for each $\\lambda_n$ is of the form $X_n(x) = C_n \\cos\\left(\\left(n - \\frac{1}{2}\\right)x\\right)$, where $C_n$ is a non-zero constant.\n\nC. The eigenvalues are $\\lambda_n = n^2$ for integers $n \\ge 0$. For the eigenvalue $\\lambda_0 = 0$, the eigenfunction is any non-zero constant. For each eigenvalue $\\lambda_n = n^2$ with $n \\ge 1$, the eigenfunctions are any non-trivial linear combination of $\\cos(nx)$ and $\\sin(nx)$.\n\nD. The eigenvalues are $\\lambda_n = n^2$ for integers $n \\ge 0$, and the corresponding eigenfunction for each $\\lambda_n$ is of the form $X_n(x) = C_n \\cos(nx)$, where $C_n$ is a non-zero constant.\n\nE. The eigenvalues are $\\lambda_n = n^2$ for integers $n \\ge 1$. For each eigenvalue $\\lambda_n = n^2$, the eigenfunctions are any non-trivial linear combination of $\\exp(inx)$ and $\\exp(-inx)$.",
            "solution": "We solve the eigenvalue problem $-X''(x)=\\lambda X(x)$ on $[-\\pi,\\pi]$ with periodic boundary conditions $X(-\\pi)=X(\\pi)$ and $X'(-\\pi)=X'(\\pi)$. Consider three cases for $\\lambda$.\n\nCase 1: $\\lambda=0$. Then $X''(x)=0$, whose general solution is $X(x)=a x+b$ with constants $a,b$. The first boundary condition gives $a\\pi+b=-a\\pi+b$, hence $a=0$. The derivative is $X'(x)=a=0$, so the derivative condition is automatically satisfied. Thus, for $\\lambda=0$, the nontrivial eigenfunctions are the nonzero constants.\n\nCase 2: $\\lambda=\\alpha^{2}>0$ with $\\alpha>0$. The general solution is $X(x)=A\\cos(\\alpha x)+B\\sin(\\alpha x)$ with constants $A,B$. Evaluate the periodicity conditions:\n$$\nX(\\pi)=A\\cos(\\alpha\\pi)+B\\sin(\\alpha\\pi),\\quad X(-\\pi)=A\\cos(\\alpha\\pi)-B\\sin(\\alpha\\pi),\n$$\nso $X(\\pi)=X(-\\pi)$ implies $2B\\sin(\\alpha\\pi)=0$. Next,\n$$\nX'(x)=-A\\alpha\\sin(\\alpha x)+B\\alpha\\cos(\\alpha x),\n$$\nhence\n$$\nX'(\\pi)=-A\\alpha\\sin(\\alpha\\pi)+B\\alpha\\cos(\\alpha\\pi),\\quad X'(-\\pi)=A\\alpha\\sin(\\alpha\\pi)+B\\alpha\\cos(\\alpha\\pi),\n$$\nso $X'(\\pi)=X'(-\\pi)$ implies $-A\\alpha\\sin(\\alpha\\pi)=A\\alpha\\sin(\\alpha\\pi)$, i.e., $2A\\alpha\\sin(\\alpha\\pi)=0$. For a nontrivial solution, we cannot have $A=B=0$, so we must have $\\sin(\\alpha\\pi)=0$. Therefore $\\alpha\\pi=m\\pi$ for some $m\\in\\mathbb{Z}$, i.e., $\\alpha=m$. The corresponding eigenvalues are $\\lambda=m^{2}$. For $m\\ge 1$, both $A$ and $B$ are arbitrary (not both zero), yielding the real eigenfunctions as any nontrivial linear combination of $\\cos(mx)$ and $\\sin(mx)$. The case $m=0$ reduces to $\\lambda=0$, handled in Case 1.\n\nCase 3: $\\lambda=-\\mu^{2}<0$ with $\\mu>0$. The general solution is $X(x)=A\\cosh(\\mu x)+B\\sinh(\\mu x)$. Then\n$$\nX(\\pi)=A\\cosh(\\mu\\pi)+B\\sinh(\\mu\\pi),\\quad X(-\\pi)=A\\cosh(\\mu\\pi)-B\\sinh(\\mu\\pi),\n$$\nso $X(\\pi)=X(-\\pi)$ implies $B=0$. For the derivative,\n$$\nX'(x)=A\\mu\\sinh(\\mu x)+B\\mu\\cosh(\\mu x),\n$$\nand\n$$\nX'(\\pi)=A\\mu\\sinh(\\mu\\pi)+B\\mu\\cosh(\\mu\\pi),\\quad X'(-\\pi)=-A\\mu\\sinh(\\mu\\pi)+B\\mu\\cosh(\\mu\\pi),\n$$\nso $X'(\\pi)=X'(-\\pi)$ implies $A=0$. Hence only the trivial solution exists, so there are no negative eigenvalues.\n\nCollecting results: all nonnegative eigenvalues are $\\lambda_{0}=0$ with eigenfunctions equal to any nonzero constant, and $\\lambda_{n}=n^{2}$ for integers $n\\ge 1$ with real eigenfunctions given by any nontrivial linear combination of $\\cos(nx)$ and $\\sin(nx)$. This matches option C and no other option, since options A and D omit part of the eigenbasis and $\\lambda_{0}$, B imposes half-integer wave numbers violating periodicity, and E omits $\\lambda_{0}$ and uses complex exponentials rather than the required real-valued eigenfunctions.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "One of the primary applications of PBCs is to simulate a small, representative volume of a bulk material, from which we can extract macroscopic properties. This practice guides you through the calculation of the radial distribution function, $g(r)$, a vital statistical tool that describes the local structure of a simulated fluid or solid. You will implement the Minimum Image Convention (MIC) to correctly handle distances in a periodic box and learn to identify common finite-size artifacts that appear in the results .",
            "id": "2426533",
            "problem": "A cubic simulation box of side length $L$ with periodic boundary conditions (PBC) contains $N$ particles at positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ given in nanometers (nm). The number density is $\\rho = N / V$ with $V = L^3$. The radial distribution function (RDF) $g(r)$ is defined as the ratio of the measured pair-separation histogram to the ideal-gas reference histogram. Distances must be computed using the minimum-image convention (MIC) in the periodic cubic box: for each component $\\Delta x$, replace it by $\\Delta x - L \\,\\mathrm{round}(\\Delta x / L)$, and analogously for $\\Delta y$ and $\\Delta z$. Consider spherical shells of thickness $\\Delta r$ with inner radius $k \\,\\Delta r$ and outer radius $(k+1)\\,\\Delta r$ for integer $k \\ge 0$, and define the bin center as $r_k = \\left(k+\\tfrac{1}{2}\\right)\\Delta r$. Let $c_k$ be the count of unordered particle pairs $i<j$ with minimum-image distance $r_{ij}$ falling in the half-open interval $[k\\,\\Delta r,(k+1)\\,\\Delta r)$. For a uniform ideal gas under the same conditions, the expected number of unordered pairs in bin $k$ is\n$$\nc_k^{\\mathrm{ideal}} \\;=\\; \\frac{N(N-1)}{2}\\;\\frac{4\\pi r_k^2 \\,\\Delta r}{V}.\n$$\nDefine the RDF at $r_k$ by\n$$\ng(r_k) \\;=\\; \\frac{c_k}{c_k^{\\mathrm{ideal}}}.\n$$\nCompute $g(r)$ using the above definitions for the following test suite. For each case, distances are in nanometers (nm), and $g(r)$ is dimensionless. You must compute $g(r_k)$ for the specified evaluation radii $r_{\\mathrm{eval}}$, which are chosen to coincide exactly with bin centers $r_k = \\left\\lfloor \\frac{r_{\\mathrm{eval}}}{\\Delta r} \\right\\rfloor \\Delta r + \\tfrac{1}{2}\\Delta r$. Use unordered pairs $i<j$ only. The program must output the requested values rounded to $6$ decimal places. Note that for $r > L/2$, naive spherical-shell normalization produces unphysical artifacts due to incomplete shell sampling in a finite periodic cube.\n\nTest Suite:\n\n- Case A:\n  - $L = 2.0$ nm, $N = 10$, $\\Delta r = 0.10$ nm, $r_{\\max} = 1.50$ nm.\n  - Positions $\\mathbf{r}_i$ (nm):\n    - $\\mathbf{r}_1 = (0.10, 0.20, 0.30)$,\n    - $\\mathbf{r}_2 = (1.70, 0.50, 1.25)$,\n    - $\\mathbf{r}_3 = (0.90, 1.80, 0.40)$,\n    - $\\mathbf{r}_4 = (1.20, 1.10, 1.90)$,\n    - $\\mathbf{r}_5 = (0.30, 0.90, 1.50)$,\n    - $\\mathbf{r}_6 = (1.60, 1.60, 0.20)$,\n    - $\\mathbf{r}_7 = (0.50, 1.40, 1.10)$,\n    - $\\mathbf{r}_8 = (1.10, 0.30, 0.80)$,\n    - $\\mathbf{r}_9 = (0.80, 1.00, 0.10)$,\n    - $\\mathbf{r}_{10} = (1.90, 1.90, 1.50)$.\n  - Evaluation radii $[r_{\\mathrm{eval}}]$: $[0.05, 0.25, 0.55, 1.05]$ nm.\n\n- Case B:\n  - $L = 1.2$ nm, $N = 8$, $\\Delta r = 0.10$ nm, $r_{\\max} = 0.80$ nm.\n  - Positions $\\mathbf{r}_i$ (nm):\n    - $\\mathbf{r}_1 = (0.10, 0.20, 0.30)$,\n    - $\\mathbf{r}_2 = (0.95, 0.50, 0.10)$,\n    - $\\mathbf{r}_3 = (0.60, 1.10, 0.90)$,\n    - $\\mathbf{r}_4 = (0.25, 0.75, 0.45)$,\n    - $\\mathbf{r}_5 = (1.10, 0.95, 0.70)$,\n    - $\\mathbf{r}_6 = (0.40, 0.10, 1.05)$,\n    - $\\mathbf{r}_7 = (0.80, 0.35, 0.55)$,\n    - $\\mathbf{r}_8 = (0.55, 0.95, 0.15)$.\n  - Evaluation radii $[r_{\\mathrm{eval}}]$: $[0.05, 0.35, 0.55, 0.65]$ nm.\n\n- Case C:\n  - $L = 1.0$ nm, $N = 2$, $\\Delta r = 0.05$ nm, $r_{\\max} = 0.80$ nm.\n  - Positions $\\mathbf{r}_i$ (nm):\n    - $\\mathbf{r}_1 = (0.10, 0.10, 0.10)$,\n    - $\\mathbf{r}_2 = (0.90, 0.90, 0.90)$.\n  - Evaluation radii $[r_{\\mathrm{eval}}]$: $[0.025, 0.175, 0.325, 0.525]$ nm.\n\nRequired final output format: Your program should produce a single line of output containing a list of three lists, one per case, each inner list containing the four values of $g(r_{\\mathrm{eval}})$ in the order provided, all rounded to $6$ decimal places, with no spaces. For example: $[[g_{A,1},g_{A,2},g_{A,3},g_{A,4}],[g_{B,1},g_{B,2},g_{B,3},g_{B,4}],[g_{C,1},g_{C,2},g_{C,3},g_{C,4}]]$. All distances are in nanometers (nm), and $g(r)$ is dimensionless. Angles do not appear in this problem. Percentages are not used.\n\nState clearly in your solution why values of $g(r)$ for $r > L/2$ display unphysical artifacts under the given normalization in a finite periodic cubic box.",
            "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It presents a standard, unambiguous task in computational statistical mechanics: the calculation of the radial distribution function, $g(r)$, for a given set of particle coordinates under periodic boundary conditions. All necessary parameters and definitions are provided, and no contradictions or logical flaws are present. Therefore, the problem is valid, and a solution will be provided.\n\nThe core of the problem is to compute the pair correlation function, more commonly known as the radial distribution function, $g(r)$. This function provides a measure of the probability of finding a particle at a given distance $r$ from a reference particle, relative to the probability expected for an ideal gas of the same density. The procedure entails several distinct steps.\n\nFirst, one must compute the distances between all unique pairs of particles. Given $N$ particles with positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ in a cubic box of side length $L$, we consider all $\\frac{N(N-1)}{2}$ unordered pairs $(i, j)$ where $i<j$. For each pair, the displacement vector is $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$. Due to the periodic boundary conditions (PBC), the system is effectively infinite and tiled by periodic images of the central simulation box. The physically relevant distance is the shortest distance between particle $i$ and any periodic image of particle $j$. This is calculated using the minimum image convention (MIC). For each component of the displacement vector, for example $\\Delta x$, the MIC component $\\Delta x'$ is computed as $\\Delta x' = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$. The same is applied to the $\\Delta y$ and $\\Delta z$ components. The MIC distance is then the Euclidean norm of the resulting vector: $r_{ij} = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}$.\n\nSecond, these distances are compiled into a histogram. The domain of distances is partitioned into bins of width $\\Delta r$. The $k$-th bin, for integers $k \\ge 0$, corresponds to the half-open interval $[k\\Delta r, (k+1)\\Delta r)$. We compute a histogram, $\\{c_k\\}$, where each element $c_k$ is the integer count of particle pairs whose MIC distance $r_{ij}$ falls within the $k$-th bin.\n\nThird, the radial distribution function $g(r_k)$ is calculated at the center of each bin, $r_k = (k+\\frac{1}{2})\\Delta r$. It is defined as the ratio of the observed count $c_k$ to the expected count for an ideal gas, $c_k^{\\mathrm{ideal}}$:\n$$\ng(r_k) = \\frac{c_k}{c_k^{\\mathrm{ideal}}}\n$$\nThe ideal gas count represents the expected number of pairs in the same shell if the particles were distributed uniformly and randomly, with no correlations. This is derived from the volume of the spherical shell, $4\\pi r_k^2 \\Delta r$, relative to the total volume of the box, $V = L^3$, multiplied by the total number of pairs:\n$$\nc_k^{\\mathrm{ideal}} = \\frac{N(N-1)}{2} \\cdot \\frac{4\\pi r_k^2 \\Delta r}{V}\n$$\nThe calculation is performed for the specified evaluation radii, $r_{\\mathrm{eval}}$, which are designed to coincide exactly with bin centers. For a given $r_{\\mathrm{eval}}$, the corresponding bin index is $k = \\lfloor r_{\\mathrm{eval}} / \\Delta r \\rfloor$.\n\nFinally, the problem requires an explanation for the unphysical artifacts observed in $g(r)$ for distances $r > L/2$ when using the standard spherical shell normalization. The formula for $c_k^{\\mathrm{ideal}}$ assumes that the volume of a spherical shell of radius $r_k$ is $4\\pi r_k^2 \\Delta r$. This assumption is valid in an unbounded Euclidean space. However, in a finite cubic box with PBC, the geometry is that of a $3$-torus. The MIC effectively restricts our view to the Wigner-Seitz cell of the periodic lattice, which is a cube of side $L$ centered on the reference particle. The maximum possible separation between any two points within this cell is $\\sqrt{(L/2)^2 + (L/2)^2 + (L/2)^2} = \\frac{\\sqrt{3}}{2}L$. When the radius of a spherical shell $r_k$ exceeds $L/2$, the sphere from which the shell is derived is larger than the Wigner-Seitz cell. Consequently, parts of the spherical shell lie outside the cell and, due to periodicity, overlap with other parts of the same shell when projected back into the central cell. The true volume available to particle pairs at this separation is less than the free-space volume $4\\pi r_k^2 \\Delta r$. The formula for $c_k^{\\mathrm{ideal}}$, by using this larger, uncorrected volume, overestimates the expected count for an ideal gas. This artificially inflates the denominator of the $g(r_k)$ ratio, causing the calculated $g(r_k)$ to be spuriously suppressed and trend towards $0$. This is a well-known finite-size artifact, and accurate calculations of $g(r)$ beyond $L/2$ require geometric correction factors for the shell volume that account for the cubic periodicity.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_g_r(L, N, coords, dr, r_max, r_eval_list):\n    \"\"\"\n    Calculates the radial distribution function g(r) for a given particle configuration.\n\n    Args:\n        L (float): Side length of the cubic simulation box.\n        N (int): Number of particles.\n        coords (list of tuples): List of particle coordinates.\n        dr (float): Thickness of the histogram bins.\n        r_max (float): Maximum radius for the histogram.\n        r_eval_list (list of floats): Radii at which to evaluate g(r).\n\n    Returns:\n        list of floats: The calculated g(r) values.\n    \"\"\"\n    V = L**3\n    num_bins = int(np.ceil(r_max / dr))\n    hist = np.zeros(num_bins, dtype=int)\n    coords_arr = np.array(coords, dtype=float)\n\n    # Loop over all unique pairs of particles (i < j)\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate separation vector\n            rij_vec = coords_arr[j] - coords_arr[i]\n\n            # Apply minimum image convention (MIC)\n            rij_vec_mic = rij_vec - L * np.round(rij_vec / L)\n            \n            # Calculate MIC distance\n            dist = np.linalg.norm(rij_vec_mic)\n            \n            # Add distance to the histogram if within range\n            if dist < r_max:\n                k = int(np.floor(dist / dr))\n                # Ensure bin index is within histogram array bounds\n                if k < num_bins:\n                    hist[k] += 1\n    \n    g_values = []\n    num_pairs = N * (N - 1) / 2.0\n    \n    # Calculate g(r) for each evaluation radius\n    for r_eval in r_eval_list:\n        k = int(np.floor(r_eval / dr))\n        \n        # This condition should not be met given the problem's setup, but is good practice.\n        if k >= num_bins:\n            g_values.append(0.0)\n            continue\n            \n        c_k = hist[k]\n        \n        if c_k == 0:\n            g_r = 0.0\n        else:\n            # The problem statement guarantees r_eval is a bin center r_k.\n            r_k = r_eval\n            \n            # Volume of the spherical shell in an ideal gas\n            vol_shell = 4 * np.pi * r_k**2 * dr\n            \n            # Expected number of pairs in the shell for an ideal gas\n            c_ideal = num_pairs * vol_shell / V\n            \n            if c_ideal > 0:\n                g_r = c_k / c_ideal\n            else:\n                # Should not occur here as r_k > 0 and N > 1.\n                g_r = 0.0 \n                \n        g_values.append(g_r)\n\n    return g_values\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 2.0, \"N\": 10, \"dr\": 0.10, \"r_max\": 1.50,\n            \"coords\": [\n                (0.10, 0.20, 0.30), (1.70, 0.50, 1.25), (0.90, 1.80, 0.40),\n                (1.20, 1.10, 1.90), (0.30, 0.90, 1.50), (1.60, 1.60, 0.20),\n                (0.50, 1.40, 1.10), (1.10, 0.30, 0.80), (0.80, 1.00, 0.10),\n                (1.90, 1.90, 1.50)\n            ],\n            \"r_eval\": [0.05, 0.25, 0.55, 1.05]\n        },\n        {\n            \"L\": 1.2, \"N\": 8, \"dr\": 0.10, \"r_max\": 0.80,\n            \"coords\": [\n                (0.10, 0.20, 0.30), (0.95, 0.50, 0.10), (0.60, 1.10, 0.90),\n                (0.25, 0.75, 0.45), (1.10, 0.95, 0.70), (0.40, 0.10, 1.05),\n                (0.80, 0.35, 0.55), (0.55, 0.95, 0.15)\n            ],\n            \"r_eval\": [0.05, 0.35, 0.55, 0.65]\n        },\n        {\n            \"L\": 1.0, \"N\": 2, \"dr\": 0.05, \"r_max\": 0.80,\n            \"coords\": [\n                (0.10, 0.10, 0.10), (0.90, 0.90, 0.90)\n            ],\n            \"r_eval\": [0.025, 0.175, 0.325, 0.525]\n        }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        g_values = calculate_g_r(\n            case[\"L\"], case[\"N\"], case[\"coords\"], case[\"dr\"], \n            case[\"r_max\"], case[\"r_eval\"]\n        )\n        # Format the inner list of results to 6 decimal places\n        inner_str = \",\".join([f\"{val:.6f}\" for val in g_values])\n        all_results_str.append(f\"[{inner_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "When simulating large molecules such as polymers or extended networks like zeolites, a single connected structure may appear fragmented because it wraps across the periodic boundaries of the simulation cell. This final practice challenges you to develop an algorithm to identify all atoms belonging to a single, complete molecule, even when it is wrapped. By combining a generalized Minimum Image Convention (MIC) for non-orthogonal cells with a graph traversal search, you will build a powerful tool essential for the analysis of complex molecular systems in computational chemistry and materials science .",
            "id": "2460022",
            "problem": "You are given a three-dimensional periodic simulation cell described by a full-rank lattice matrix $\\mathbf{L} \\in \\mathbb{R}^{3 \\times 3}$ whose columns are the Cartesian components of the cell vectors $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, so that any Cartesian position vector $\\mathbf{r}$ corresponds to a fractional coordinate vector $\\mathbf{s}$ via $\\mathbf{r} = \\mathbf{L}\\mathbf{s}$ with $\\mathbf{s} \\in [0,1)^3$. A set of atom positions $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ is provided in Cartesian coordinates inside the primary cell, an interatomic connection threshold $r_{\\text{cut}} > 0$ is given in ångström (Å), and a seed atom index $s \\in \\{0,\\dots,N-1\\}$ (zero-based indexing) is specified. Two atoms $i$ and $j$ are considered adjacent (connected by an undirected edge) if and only if their minimum-image separation distance $d_{ij}$ in the periodic system satisfies $d_{ij} \\le r_{\\text{cut}}$. The minimum-image displacement $\\Delta \\mathbf{r}_{ij}$ from atom $i$ to atom $j$ is defined as follows: compute fractional coordinates $\\mathbf{s}_i = \\mathbf{L}^{-1}\\mathbf{r}_i$ and $\\mathbf{s}_j = \\mathbf{L}^{-1}\\mathbf{r}_j$, form $\\Delta \\mathbf{s}_{ij} = \\mathbf{s}_j - \\mathbf{s}_i$, then let $\\widehat{\\Delta \\mathbf{s}}_{ij}$ be obtained by adding an integer vector so that each component lies in the half-open interval $[-\\tfrac{1}{2}, \\tfrac{1}{2})$, and finally set $\\Delta \\mathbf{r}_{ij} = \\mathbf{L}\\widehat{\\Delta \\mathbf{s}}_{ij}$. The minimum-image distance is $d_{ij} = \\|\\Delta \\mathbf{r}_{ij}\\|_2$. Define a graph on vertices $\\{0,\\dots,N-1\\}$ with edges $\\{i,j\\}$ whenever $d_{ij} \\le r_{\\text{cut}}$. Your task is to determine the set of all atom indices belonging to the connected component that contains the seed atom index $s$, and to report these indices as a sorted list in ascending order.\n\nAll lengths (the entries of $\\mathbf{L}$, the components of $\\mathbf{r}_i$, and $r_{\\text{cut}}$) are specified in ångström (Å). Indices are unitless integers and must be reported using zero-based indexing. The condition for an edge must be interpreted as $d_{ij} \\le r_{\\text{cut}}$.\n\nTest suite. For each test case $t \\in \\{1,2,3\\}$, you are given $\\mathbf{L}^{(t)}$, the list of Cartesian positions $\\{\\mathbf{r}^{(t)}_i\\}$, the scalar $r^{(t)}_{\\text{cut}}$, and the seed $s^{(t)}$:\n\n- Test case $1$ (cubic cell with a chain wrapped across a face):\n  - $\\mathbf{L}^{(1)} = \\begin{bmatrix} 10.0 & 0.0 & 0.0 \\\\ 0.0 & 10.0 & 0.0 \\\\ 0.0 & 0.0 & 10.0 \\end{bmatrix}$.\n  - Positions $\\{\\mathbf{r}^{(1)}_i\\}_{i=0}^{5}$:\n    - $i = 0$: $(9.5,\\, 5.0,\\, 5.0)$,\n    - $i = 1$: $(0.5,\\, 5.0,\\, 5.0)$,\n    - $i = 2$: $(1.5,\\, 5.0,\\, 5.0)$,\n    - $i = 3$: $(8.0,\\, 5.0,\\, 5.0)$,\n    - $i = 4$: $(3.0,\\, 3.0,\\, 3.0)$,\n    - $i = 5$: $(3.9,\\, 3.0,\\, 3.0)$.\n  - $r^{(1)}_{\\text{cut}} = 1.2$.\n  - $s^{(1)} = 0$.\n\n- Test case $2$ (triclinic cell with a cluster spanning across boundaries):\n  - $\\mathbf{L}^{(2)} = \\begin{bmatrix} 8.0 & 2.0 & 1.0 \\\\ 0.0 & 7.0 & 1.5 \\\\ 0.0 & 0.0 & 6.5 \\end{bmatrix}$.\n  - Positions $\\{\\mathbf{r}^{(2)}_i\\}_{i=0}^{3}$:\n    - $i = 0$: $(10.45,\\, 8.075,\\, 6.175)$,\n    - $i = 1$: $(3.03,\\, 8.145,\\, 6.175)$,\n    - $i = 2$: $(1.33,\\, 1.635,\\, 6.175)$,\n    - $i = 3$: $(4.4,\\, 3.4,\\, 2.6)$.\n  - $r^{(2)}_{\\text{cut}} = 1.0$.\n  - $s^{(2)} = 0$.\n\n- Test case $3$ (orthorhombic cell with distances exactly at the threshold):\n  - $\\mathbf{L}^{(3)} = \\begin{bmatrix} 8.0 & 0.0 & 0.0 \\\\ 0.0 & 8.0 & 0.0 \\\\ 0.0 & 0.0 & 8.0 \\end{bmatrix}$.\n  - Positions $\\{\\mathbf{r}^{(3)}_i\\}_{i=0}^{3}$:\n    - $i = 0$: $(7.5,\\, 4.0,\\, 4.0)$,\n    - $i = 1$: $(0.5,\\, 4.0,\\, 4.0)$,\n    - $i = 2$: $(1.5,\\, 4.0,\\, 4.0)$,\n    - $i = 3$: $(4.0,\\, 4.0,\\, 4.0)$.\n  - $r^{(3)}_{\\text{cut}} = 1.0$.\n  - $s^{(3)} = 0$.\n\nRequired program behavior:\n- For each test case, determine the sorted list of indices of all atoms in the connected component containing the seed atom according to the adjacency rule $d_{ij} \\le r_{\\text{cut}}$ with the minimum image convention under periodic boundary conditions defined above.\n- Your program should produce a single line of output containing the results as a comma-separated list of lists with no spaces, enclosed in square brackets. For example, if the three results were lists $\\ell^{(1)}$, $\\ell^{(2)}$, and $\\ell^{(3)}$, the required output format is $[\\ell^{(1)},\\ell^{(2)},\\ell^{(3)}]$ where each list is rendered as $[i_0,i_1,\\dots]$ with zero-based indices and no whitespace.",
            "solution": "The problem presented is a well-defined exercise in computational geometry and graph theory, fundamental to the field of molecular simulation. It requires the identification of a cluster of atoms, represented as a connected component in a graph, under periodic boundary conditions (PBC). The problem is scientifically grounded, internally consistent, and contains all necessary information for a unique solution. Therefore, it is valid, and we shall proceed with a rigorous analytical and algorithmic solution.\n\nThe core of the problem lies in correctly applying the Minimum Image Convention (MIC) for a general triclinic cell to determine adjacency between atoms, and then using a graph traversal algorithm to find the connected component containing a specified seed atom.\n\nLet us dissect the procedure.\n\n1.  **System Representation**: The simulation cell is a parallelepiped defined by three lattice vectors $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, which form the columns of the lattice matrix $\\mathbf{L} = [\\mathbf{a} \\ \\mathbf{b} \\ \\mathbf{c}]$. Any Cartesian position vector $\\mathbf{r}$ within the cell can be uniquely mapped to a fractional coordinate vector $\\mathbf{s} \\in [0, 1)^3$ via the linear transformation $\\mathbf{r} = \\mathbf{L}\\mathbf{s}$. The inverse transformation is $\\mathbf{s} = \\mathbf{L}^{-1}\\mathbf{r}$. The existence of $\\mathbf{L}^{-1}$ is guaranteed as $\\mathbf{L}$ is stipulated to be full-rank.\n\n2.  **Minimum Image Convention (MIC)**: To calculate the distance between two atoms $i$ and $j$ at Cartesian positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$, we must account for the periodic nature of the system. The distance is not simply $\\|\\mathbf{r}_j - \\mathbf{r}_i\\|_2$, but the minimum distance between atom $j$ and all periodic images of atom $i$. The set of all images of atom $i$ is given by $\\{\\mathbf{r}_i + \\mathbf{L}\\mathbf{n} \\,|\\, \\mathbf{n} \\in \\mathbb{Z}^3\\}$. The squared distance is thus $d_{ij}^2 = \\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\|\\mathbf{r}_j - (\\mathbf{r}_i + \\mathbf{L}\\mathbf{n})\\|_2^2$.\n\n    The problem provides a direct and computationally efficient algorithm to find this minimum image displacement vector. This procedure avoids an explicit search over integer vectors $\\mathbf{n}$.\n    \n    a. First, we transform the problem into the space of fractional coordinates, where periodicity is simpler to handle. The displacement vector in Cartesian coordinates is $\\Delta\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$. In fractional coordinates, this becomes $\\Delta\\mathbf{s}_{ij} = \\mathbf{s}_j - \\mathbf{s}_i = \\mathbf{L}^{-1}(\\mathbf{r}_j - \\mathbf{r}_i)$. Since $\\mathbf{s}_i, \\mathbf{s}_j \\in [0,1)^3$, each component of $\\Delta\\mathbf{s}_{ij}$ lies in $(-1, 1)$.\n\n    b. The next step is to apply the MIC in fractional space. This means finding an integer vector $\\mathbf{n}$ such that the wrapped displacement $\\widehat{\\Delta\\mathbf{s}}_{ij} = \\Delta\\mathbf{s}_{ij} - \\mathbf{n}$ has each of its components in the interval $[-\\frac{1}{2}, \\frac{1}{2})$. This vector corresponds to the image of atom $j$ that is closest to atom $i$. For each component $v_k$ of a vector $\\mathbf{v}$, the wrapping operation that maps it to $[-\\frac{1}{2}, \\frac{1}{2})$ can be implemented as $v_k - \\lfloor v_k + \\frac{1}{2} \\rfloor$. In a computational setting using floating-point arithmetic, care must be taken with boundary cases. A robust implementation is `v_wrapped = (v + 0.5) % 1.0 - 0.5`, where `%` denotes the modulo operation that correctly handles negative numbers, as exemplified by Python's `%` operator or `numpy.mod`.\n\n    c. Once the wrapped fractional displacement $\\widehat{\\Delta\\mathbf{s}}_{ij}$ is found, we convert it back to Cartesian coordinates to obtain the minimum image displacement vector: $\\Delta\\mathbf{r}_{ij}^{\\text{min}} = \\mathbf{L} \\widehat{\\Delta\\mathbf{s}}_{ij}$.\n\n    d. The minimum image distance $d_{ij}$ is the Euclidean norm of this vector: $d_{ij} = \\|\\Delta\\mathbf{r}_{ij}^{\\text{min}}\\|_2$.\n\n3.  **Graph Construction**: An undirected graph $G = (V, E)$ is implicitly defined. The set of vertices $V$ is the set of atom indices $\\{0, 1, \\dots, N-1\\}$. An edge $(i, j)$ exists in $E$ if and only if the minimum image distance $d_{ij}$ is less than or equal to the given cutoff radius, $d_{ij} \\le r_{\\text{cut}}$. Due to the properties of the distance metric, $d_{ij} = d_{ji}$, so the graph is indeed undirected.\n\n4.  **Connected Component Search**: The final task is to find all vertices in the connected component containing the given seed atom index $s$. This is a standard graph traversal problem. We can employ a Breadth-First Search (BFS) or a Depth-First Search (DFS) algorithm, starting from the seed vertex $s$.\n\n    The algorithm proceeds as follows:\n    a. Build an adjacency list representation of the graph $G$. For each pair of atoms $(i, j)$ with $i < j$, compute $d_{ij}$. If $d_{ij} \\le r_{\\text{cut}}$, add $j$ to the adjacency list of $i$ and $i$ to the adjacency list of $j$.\n    b. Initialize a queue for BFS with the seed atom $s$ and a set `visited` also containing $s$.\n    c. While the queue is not empty, dequeue a vertex $u$. For each neighbor $v$ of $u$ in the adjacency list, if $v$ has not yet been visited, add it to the `visited` set and enqueue it.\n    d. The process terminates when the queue is empty. The `visited` set now contains all atom indices in the connected component of $s$.\n\n5.  **Final Result Formulation**: The resulting set of indices is converted to a list and sorted in ascending order as required. This procedure is repeated for each test case.\n\nThe implementation will use the `numpy` library for efficient linear algebra operations, such as matrix inversion, matrix-vector products, and vector norms.",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the connected components problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"L\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"positions\": np.array([\n                [9.5, 5.0, 5.0], [0.5, 5.0, 5.0], [1.5, 5.0, 5.0],\n                [8.0, 5.0, 5.0], [3.0, 3.0, 3.0], [3.9, 3.0, 3.0]\n            ]),\n            \"r_cut\": 1.2,\n            \"seed\": 0\n        },\n        {\n            \"L\": np.array([\n                [8.0, 2.0, 1.0],\n                [0.0, 7.0, 1.5],\n                [0.0, 0.0, 6.5]\n            ]),\n            \"positions\": np.array([\n                [10.45, 8.075, 6.175], [3.03, 8.145, 6.175],\n                [1.33, 1.635, 6.175], [4.4, 3.4, 2.6]\n            ]),\n            \"r_cut\": 1.0,\n            \"seed\": 0\n        },\n        {\n            \"L\": np.array([\n                [8.0, 0.0, 0.0],\n                [0.0, 8.0, 0.0],\n                [0.0, 0.0, 8.0]\n            ]),\n            \"positions\": np.array([\n                [7.5, 4.0, 4.0], [0.5, 4.0, 4.0],\n                [1.5, 4.0, 4.0], [4.0, 4.0, 4.0]\n            ]),\n            \"r_cut\": 1.0,\n            \"seed\": 0\n        }\n    ]\n\n    def find_connected_component(L, positions, r_cut, seed):\n        \"\"\"\n        Finds the connected component for a single test case.\n        \"\"\"\n        num_atoms = len(positions)\n        try:\n            L_inv = np.linalg.inv(L)\n        except np.linalg.LinAlgError:\n            # This should not happen for valid problems with a full-rank matrix L.\n            return []\n\n        # Convert all Cartesian positions to fractional coordinates at once.\n        # Here, positions are rows, so we transpose for matmul and transpose back.\n        # r = Ls -> s = L^-1 r. For r vectors as rows: S^T = (L^-1 R^T) -> S = (L^-1 R^T)^T = R (L^-1)^T\n        s_coords = positions @ L_inv.T\n        \n        # Build adjacency list\n        adj = {i: [] for i in range(num_atoms)}\n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                # Fractional displacement\n                delta_s = s_coords[j] - s_coords[i]\n                \n                # Apply minimum image convention to fractional displacement\n                # Wrap into [-0.5, 0.5)\n                # This is a robust way to handle the wrapping for both positive and negative values.\n                delta_s_wrapped = np.mod(delta_s + 0.5, 1.0) - 0.5\n                \n                # Convert back to Cartesian\n                delta_r = delta_s_wrapped @ L.T\n                \n                # Calculate distance\n                dist = np.linalg.norm(delta_r)\n                \n                # Check against cutoff and add edge if connected\n                if dist <= r_cut:\n                    adj[i].append(j)\n                    adj[j].append(i)\n\n        # Find connected component using Breadth-First Search (BFS)\n        if seed >= num_atoms:\n            return []\n\n        q = deque([seed])\n        visited = {seed}\n        \n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if v not in visited:\n                    visited.add(v)\n                    q.append(v)\n        \n        return sorted(list(visited))\n\n    results = []\n    for case in test_cases:\n        component = find_connected_component(case[\"L\"], case[\"positions\"], case[\"r_cut\"], case[\"seed\"])\n        results.append(component)\n        \n    # Format the final output string as per requirements.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}