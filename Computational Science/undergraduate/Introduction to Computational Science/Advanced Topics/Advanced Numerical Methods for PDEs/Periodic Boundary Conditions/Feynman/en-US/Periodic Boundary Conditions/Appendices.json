{
    "hands_on_practices": [
        {
            "introduction": "While periodic boundary conditions (PBCs) confine particles to a primary simulation cell, the system as a whole may possess a net momentum, causing its center of mass to drift through the periodic space. Understanding and correcting for this drift is a common task in molecular simulations to maintain a consistent frame of reference. This exercise  introduces the concept of \"unwrapped\" coordinates to track this drift and demonstrates how to computationally remove it, reinforcing the connection between total momentum and center-of-mass velocity.",
            "id": "2426601",
            "problem": "Consider an isolated, one-dimensional system of $N$ point particles of masses $\\{m_i\\}_{i=1}^N$ moving on a ring of circumference $L$ with Periodic Boundary Conditions (PBCs). The physical coordinate of particle $i$ at time $t$, denoted $x_i(t)$, is represented in the fundamental domain $[0,L)$ with the identification that $x \\equiv x + nL$ for any integer $n$. There are no external forces and no interparticle interactions; hence each particle has a constant velocity $v_i$ for all $t \\ge 0$. Define the unwrapped coordinate $x_i^{\\mathrm{u}}(t)$ by the initial condition $x_i^{\\mathrm{u}}(0)=x_i(0)$ and the evolution equation $\\frac{d}{dt}x_i^{\\mathrm{u}}(t)=v_i$, so that $x_i(t)$ is the unique representative of $x_i^{\\mathrm{u}}(t)$ modulo $L$ in $[0,L)$. The total mass is $M=\\sum_{i=1}^N m_i$. The unwrapped center of mass is defined by\n$$\nX_{\\mathrm{CM}}^{\\mathrm{u}}(t)=\\frac{1}{M}\\sum_{i=1}^N m_i\\,x_i^{\\mathrm{u}}(t).\n$$\nFor an isolated system with non-zero total momentum $P=\\sum_{i=1}^N m_i v_i$, the unwrapped center of mass $X_{\\mathrm{CM}}^{\\mathrm{u}}(t)$ must move uniformly in time. In many numerical simulations, it is desirable to remove this drift and keep the center of mass fixed. Define a drift-corrected unwrapped coordinate for each particle by\n$$\n\\tilde{x}_i^{\\mathrm{u}}(t)=x_i^{\\mathrm{u}}(t)-\\big(X_{\\mathrm{CM}}^{\\mathrm{u}}(t)-X_{\\mathrm{CM}}^{\\mathrm{u}}(0)\\big),\n$$\nand define the corresponding drift-corrected unwrapped center of mass\n$$\n\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(t)=\\frac{1}{M}\\sum_{i=1}^N m_i\\,\\tilde{x}_i^{\\mathrm{u}}(t).\n$$\nYou are given a discrete-time evolution with time step $\\Delta t>0$ and a number of steps $K \\in \\mathbb{N}$. All quantities are dimensionless. Starting from specified initial positions $\\{x_i(0)\\}$ in $[0,L)$ and constant velocities $\\{v_i\\}$, evolve the system for $K$ steps. Let the total physical time be $T=K\\,\\Delta t$. For each parameter set below, compute the following two scalar quantities:\n- $D_{\\text{uncorr}}=\\left|X_{\\mathrm{CM}}^{\\mathrm{u}}(T)-X_{\\mathrm{CM}}^{\\mathrm{u}}(0)\\right|$,\n- $D_{\\text{corr}}=\\left|\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(T)-\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(0)\\right|$.\n\nReport each scalar rounded to $9$ decimal places.\n\nTest suite (each test case is a tuple ($L$, $\\{m_i\\}$, $\\{x_i(0)\\}$, $\\{v_i\\}$, $\\Delta t$, $K$)):\n- Test 1: ($L=10.0$, $\\{m_i\\}=[1.0, 2.0, 1.0]$, $\\{x_i(0)\\}=[1.0, 3.0, 7.0]$, $\\{v_i\\}=[0.5, 0.0, -0.1]$, $\\Delta t=0.1$, $K=100$)\n- Test 2: ($L=5.0$, $\\{m_i\\}=[1.5, 0.5]$, $\\{x_i(0)\\}=[4.8, 0.2]$, $\\{v_i\\}=[3.1, -2.9]$, $\\Delta t=0.4$, $K=50$)\n- Test 3: ($L=12.0$, $\\{m_i\\}=[1.0, 1.0, 1.0, 1.0]$, $\\{x_i(0)\\}=[0.0, 3.0, 6.0, 9.0]$, $\\{v_i\\}=[1.0, -1.0, 2.0, -2.0]$, $\\Delta t=0.05$, $K=150$)\n- Test 4: ($L=8.0$, $\\{m_i\\}=[2.0]$, $\\{x_i(0)\\}=[2.5]$, $\\{v_i\\}=[-1.25]$, $\\Delta t=0.2$, $K=80$)\n- Test 5: ($L=9.0$, $\\{m_i\\}=[1.0, 2.0, 3.0, 4.0, 5.0]$, $\\{x_i(0)\\}=[0.1, 1.3, 2.7, 5.5, 8.9]$, $\\{v_i\\}=[0.2, -0.1, 0.05, -0.02, 0.07]$, $\\Delta t=0.3$, $K=100$)\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$[D_{\\text{uncorr}}^{(1)},D_{\\text{corr}}^{(1)},D_{\\text{uncorr}}^{(2)},D_{\\text{corr}}^{(2)},\\dots,D_{\\text{uncorr}}^{(5)},D_{\\text{corr}}^{(5)}],$$\nwith each scalar rounded to $9$ decimal places. For example, a valid output line has the form \"[0.123000000,0.000000000, ...]\".",
            "solution": "The problem has been validated and is deemed scientifically sound, well-posed, and unambiguous. It is a direct application of fundamental definitions from classical mechanics, specifically pertaining to the center of mass in an isolated system. We proceed with the solution.\n\nThe problem asks for the computation of two quantities, $D_{\\text{uncorr}}$ and $D_{\\text{corr}}$, related to the displacement of the center of mass in a one-dimensional system of $N$ non-interacting particles. The analysis relies on the concept of \"unwrapped\" coordinates, which track the total displacement of particles without the modulo arithmetic imposed by periodic boundary conditions.\n\nFirst, we establish the analytical expressions for the required quantities. The unwrapped coordinate of particle $i$ at time $t$, denoted $x_i^{\\mathrm{u}}(t)$, is determined by its constant velocity $v_i$ starting from an initial position $x_i(0)$. The evolution is given by the differential equation $\\frac{d}{dt}x_i^{\\mathrm{u}}(t)=v_i$ with the initial condition $x_i^{\\mathrm{u}}(0)=x_i(0)$. Integration yields the precise trajectory:\n$$\nx_i^{\\mathrm{u}}(t) = x_i(0) + v_i t\n$$\nThe unwrapped center of mass, $X_{\\mathrm{CM}}^{\\mathrm{u}}(t)$, is defined as the mass-weighted average of the unwrapped particle coordinates:\n$$\nX_{\\mathrm{CM}}^{\\mathrm{u}}(t) = \\frac{1}{M}\\sum_{i=1}^N m_i x_i^{\\mathrm{u}}(t)\n$$\nwhere $M = \\sum_{i=1}^N m_i$ is the total mass of the system.\n\nThe first quantity to compute is $D_{\\text{uncorr}} = |X_{\\mathrm{CM}}^{\\mathrm{u}}(T) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0)|$, which is the magnitude of the displacement of the unwrapped center of mass over the total time $T = K \\Delta t$. We can express this displacement as:\n$$\nX_{\\mathrm{CM}}^{\\mathrm{u}}(T) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0) = \\frac{1}{M}\\sum_{i=1}^N m_i x_i^{\\mathrm{u}}(T) - \\frac{1}{M}\\sum_{i=1}^N m_i x_i^{\\mathrm{u}}(0) = \\frac{1}{M}\\sum_{i=1}^N m_i \\left( x_i^{\\mathrm{u}}(T) - x_i^{\\mathrm{u}}(0) \\right)\n$$\nSubstituting $x_i^{\\mathrm{u}}(T) = x_i(0) + v_i T$, we find that the displacement of each particle is $x_i^{\\mathrm{u}}(T) - x_i^{\\mathrm{u}}(0) = v_i T$. The displacement of the center of mass is therefore:\n$$\nX_{\\mathrm{CM}}^{\\mathrm{u}}(T) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0) = \\frac{1}{M}\\sum_{i=1}^N m_i (v_i T) = \\frac{T}{M} \\sum_{i=1}^N m_i v_i\n$$\nThe sum $\\sum_{i=1}^N m_i v_i$ is the total momentum $P$ of the system. Thus, the displacement is $\\frac{P}{M} T$, and the quantity $D_{\\text{uncorr}}$ is:\n$$\nD_{\\text{uncorr}} = \\left| \\frac{P}{M} T \\right| = \\left| \\frac{T}{M} \\sum_{i=1}^N m_i v_i \\right| = \\left| \\frac{K \\Delta t}{\\sum_{i=1}^N m_i} \\sum_{i=1}^N m_i v_i \\right|\n$$\nNote that the calculation of $D_{\\text{uncorr}}$ does not depend on the initial positions $\\{x_i(0)\\}$ or the system size $L$.\n\nNext, we analyze the drift-corrected quantity $D_{\\text{corr}} = |\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(T) - \\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(0)|$. The drift-corrected unwrapped center of mass, $\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(t)$, is defined using the drift-corrected particle coordinates $\\tilde{x}_i^{\\mathrm{u}}(t) = x_i^{\\mathrm{u}}(t) - (X_{\\mathrm{CM}}^{\\mathrm{u}}(t) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0))$:\n$$\n\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(t) = \\frac{1}{M}\\sum_{i=1}^N m_i \\tilde{x}_i^{\\mathrm{u}}(t) = \\frac{1}{M}\\sum_{i=1}^N m_i \\left[ x_i^{\\mathrm{u}}(t) - \\left(X_{\\mathrm{CM}}^{\\mathrm{u}}(t) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0)\\right) \\right]\n$$\nWe can separate the summation:\n$$\n\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(t) = \\left( \\frac{1}{M}\\sum_{i=1}^N m_i x_i^{\\mathrm{u}}(t) \\right) - \\left( \\frac{1}{M}\\sum_{i=1}^N m_i \\left(X_{\\mathrm{CM}}^{\\mathrm{u}}(t) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0)\\right) \\right)\n$$\nThe first term is the definition of $X_{\\mathrm{CM}}^{\\mathrm{u}}(t)$. The term $(X_{\\mathrm{CM}}^{\\mathrm{u}}(t) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0))$ is a constant with respect to the summation index $i$. Therefore:\n$$\n\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(t) = X_{\\mathrm{CM}}^{\\mathrm{u}}(t) - \\left(X_{\\mathrm{CM}}^{\\mathrm{u}}(t) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0)\\right) \\left( \\frac{1}{M}\\sum_{i=1}^N m_i \\right)\n$$\nSince $\\sum_{i=1}^N m_i = M$, the expression simplifies to:\n$$\n\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(t) = X_{\\mathrm{CM}}^{\\mathrm{u}}(t) - \\left(X_{\\mathrm{CM}}^{\\mathrm{u}}(t) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0)\\right) = X_{\\mathrm{CM}}^{\\mathrm{u}}(0)\n$$\nThis result shows that the drift-corrected unwrapped center of mass is stationary for all time $t$, and is fixed at its initial value $X_{\\mathrm{CM}}^{\\mathrm{u}}(0)$. Consequently, its displacement over any time interval is identically zero.\nFor the specific quantity $D_{\\text{corr}}$, we have:\n$$\nD_{\\text{corr}} = \\left|\\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(T) - \\tilde{X}_{\\mathrm{CM}}^{\\mathrm{u}}(0)\\right| = \\left|X_{\\mathrm{CM}}^{\\mathrm{u}}(0) - X_{\\mathrm{CM}}^{\\mathrm{u}}(0)\\right| = 0\n$$\nThis holds for any valid set of parameters.\n\nThe computation for each test case is now straightforward. For each given set ($L$, $\\{m_i\\}$, $\\{x_i(0)\\}$, $\\{v_i\\}$, $\\Delta t$, $K$):\n1. Calculate the total mass $M = \\sum m_i$. All $m_i$ are positive, so $M>0$.\n2. Calculate the total momentum $P = \\sum m_i v_i$.\n3. Calculate the total time $T = K \\Delta t$.\n4. Compute $D_{\\text{uncorr}} = |\\frac{P}{M} T|$.\n5. The value of $D_{\\text{corr}}$ is always $0$.\n\nThe implementation will follow these steps.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational physics problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L, {m_i}, {x_i(0)}, {v_i}, delta_t, K)\n    test_cases = [\n        # Test 1\n        (10.0, [1.0, 2.0, 1.0], [1.0, 3.0, 7.0], [0.5, 0.0, -0.1], 0.1, 100),\n        # Test 2\n        (5.0, [1.5, 0.5], [4.8, 0.2], [3.1, -2.9], 0.4, 50),\n        # Test 3\n        (12.0, [1.0, 1.0, 1.0, 1.0], [0.0, 3.0, 6.0, 9.0], [1.0, -1.0, 2.0, -2.0], 0.05, 150),\n        # Test 4\n        (8.0, [2.0], [2.5], [-1.25], 0.2, 80),\n        # Test 5\n        (9.0, [1.0, 2.0, 3.0, 4.0, 5.0], [0.1, 1.3, 2.7, 5.5, 8.9], [0.2, -0.1, 0.05, -0.02, 0.07], 0.3, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case.\n        # L and initial positions x_i(0) are not needed for the calculation.\n        _L, m_i, _x_i_0, v_i, delta_t, K = case\n\n        # Convert lists to numpy arrays for vectorized operations.\n        masses = np.array(m_i)\n        velocities = np.array(v_i)\n\n        # 1. Calculate total mass M and total momentum P.\n        total_mass = np.sum(masses)\n        total_momentum = np.sum(masses * velocities)\n        \n        # 2. Calculate total time T.\n        total_time = K * delta_t\n\n        # 3. Calculate D_uncorr.\n        # D_uncorr = |(P/M) * T|\n        # This is the magnitude of the displacement of the unwrapped center of mass.\n        if total_mass == 0:\n            # This case is physically degenerate but we handle it to prevent division by zero.\n            # In this problem, all masses are positive, so this will not occur.\n            d_uncorr = 0.0\n        else:\n            v_cm = total_momentum / total_mass\n            d_uncorr = np.abs(v_cm * total_time)\n        \n        # 4. Calculate D_corr.\n        # As derived in the solution, the drift-corrected center of mass is stationary.\n        # Its displacement is therefore always zero.\n        d_corr = 0.0\n\n        results.append(d_uncorr)\n        results.append(d_corr)\n\n    # Format the results to 9 decimal places and join into a single string.\n    results_str = [f\"{r:.9f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A cornerstone of analyzing simulated liquids and solids is to characterize their structure, for which the radial distribution function, $g(r)$, is an indispensable tool. Calculating $g(r)$ requires correctly measuring distances in a periodic system using the minimum image convention (MIC). This practice  provides hands-on experience in implementing the MIC for a cubic cell and using it to compute $g(r)$ from a particle configuration, a fundamental skill in computational statistical mechanics.",
            "id": "2426533",
            "problem": "A cubic simulation box of side length $L$ with periodic boundary conditions (PBC) contains $N$ particles at positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ given in nanometers (nm). The number density is $\\rho = N / V$ with $V = L^3$. The radial distribution function (RDF) $g(r)$ is defined as the ratio of the measured pair-separation histogram to the ideal-gas reference histogram. Distances must be computed using the minimum-image convention (MIC) in the periodic cubic box: for each component $\\Delta x$, replace it by $\\Delta x - L \\,\\mathrm{round}(\\Delta x / L)$, and analogously for $\\Delta y$ and $\\Delta z$. Consider spherical shells of thickness $\\Delta r$ with inner radius $k \\,\\Delta r$ and outer radius $(k+1)\\,\\Delta r$ for integer $k \\ge 0$, and define the bin center as $r_k = \\left(k+\\tfrac{1}{2}\\right)\\Delta r$. Let $c_k$ be the count of unordered particle pairs $i<j$ with minimum-image distance $r_{ij}$ falling in the half-open interval $[k\\,\\Delta r,(k+1)\\,\\Delta r)$. For a uniform ideal gas under the same conditions, the expected number of unordered pairs in bin $k$ is\n$$\nc_k^{\\mathrm{ideal}} \\;=\\; \\frac{N(N-1)}{2}\\;\\frac{4\\pi r_k^2 \\,\\Delta r}{V}.\n$$\nDefine the RDF at $r_k$ by\n$$\ng(r_k) \\;=\\; \\frac{c_k}{c_k^{\\mathrm{ideal}}}.\n$$\nCompute $g(r)$ using the above definitions for the following test suite. For each case, distances are in nanometers (nm), and $g(r)$ is dimensionless. You must compute $g(r_k)$ for the specified evaluation radii $r_{\\text{eval}}$, which are chosen to coincide exactly with bin centers $r_k = \\left\\lfloor \\frac{r_{\\text{eval}}}{\\Delta r} \\right\\rfloor \\Delta r + \\tfrac{1}{2}\\Delta r$. Use unordered pairs $i<j$ only. The program must output the requested values rounded to $6$ decimal places. Note that for $r > L/2$, naive spherical-shell normalization produces unphysical artifacts due to incomplete shell sampling in a finite periodic cube.\n\nTest Suite:\n\n- Case A:\n  - $L = 2.0$ nm, $N = 10$, $\\Delta r = 0.10$ nm, $r_{\\text{max}} = 1.50$ nm.\n  - Positions $\\mathbf{r}_i$ (nm):\n    - $\\mathbf{r}_1 = (0.10, 0.20, 0.30)$,\n    - $\\mathbf{r}_2 = (1.70, 0.50, 1.25)$,\n    - $\\mathbf{r}_3 = (0.90, 1.80, 0.40)$,\n    - $\\mathbf{r}_4 = (1.20, 1.10, 1.90)$,\n    - $\\mathbf{r}_5 = (0.30, 0.90, 1.50)$,\n    - $\\mathbf{r}_6 = (1.60, 1.60, 0.20)$,\n    - $\\mathbf{r}_7 = (0.50, 1.40, 1.10)$,\n    - $\\mathbf{r}_8 = (1.10, 0.30, 0.80)$,\n    - $\\mathbf{r}_9 = (0.80, 1.00, 0.10)$,\n    - $\\mathbf{r}_{10} = (1.90, 1.90, 1.50)$.\n  - Evaluation radii $r_{\\text{eval}}$: $[0.05, 0.25, 0.55, 1.05]$ nm.\n\n- Case B:\n  - $L = 1.2$ nm, $N = 8$, $\\Delta r = 0.10$ nm, $r_{\\text{max}} = 0.80$ nm.\n  - Positions $\\mathbf{r}_i$ (nm):\n    - $\\mathbf{r}_1 = (0.10, 0.20, 0.30)$,\n    - $\\mathbf{r}_2 = (0.95, 0.50, 0.10)$,\n    - $\\mathbf{r}_3 = (0.60, 1.10, 0.90)$,\n    - $\\mathbf{r}_4 = (0.25, 0.75, 0.45)$,\n    - $\\mathbf{r}_5 = (1.10, 0.95, 0.70)$,\n    - $\\mathbf{r}_6 = (0.40, 0.10, 1.05)$,\n    - $\\mathbf{r}_7 = (0.80, 0.35, 0.55)$,\n    - $\\mathbf{r}_8 = (0.55, 0.95, 0.15)$.\n  - Evaluation radii $r_{\\text{eval}}$: $[0.05, 0.35, 0.55, 0.65]$ nm.\n\n- Case C:\n  - $L = 1.0$ nm, $N = 2$, $\\Delta r = 0.05$ nm, $r_{\\text{max}} = 0.80$ nm.\n  - Positions $\\mathbf{r}_i$ (nm):\n    - $\\mathbf{r}_1 = (0.10, 0.10, 0.10)$,\n    - $\\mathbf{r}_2 = (0.90, 0.90, 0.90)$.\n  - Evaluation radii $r_{\\text{eval}}$: $[0.025, 0.175, 0.325, 0.525]$ nm.\n\nRequired final output format: Your program should produce a single line of output containing a list of three lists, one per case, each inner list containing the four values of $g(r_{\\text{eval}})$ in the order provided, all rounded to $6$ decimal places, with no spaces. For example: $[[g_{A,1},g_{A,2},g_{A,3},g_{A,4}],[g_{B,1},g_{B,2},g_{B,3},g_{B,4}],[g_{C,1},g_{C,2},g_{C,3},g_{C,4}]]$. All distances are in nanometers (nm), and $g(r)$ is dimensionless. Angles do not appear in this problem. Percentages are not used.\n\nState clearly in your solution why values of $g(r)$ for $r > L/2$ display unphysical artifacts under the given normalization in a finite periodic cubic box.",
            "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It presents a standard, unambiguous task in computational statistical mechanics: the calculation of the radial distribution function, $g(r)$, for a given set of particle coordinates under periodic boundary conditions. All necessary parameters and definitions are provided, and no contradictions or logical flaws are present. Therefore, the problem is valid, and a solution will be provided.\n\nThe core of the problem is to compute the pair correlation function, more commonly known as the radial distribution function, $g(r)$. This function provides a measure of the probability of finding a particle at a given distance $r$ from a reference particle, relative to the probability expected for an ideal gas of the same density. The procedure entails several distinct steps.\n\nFirst, one must compute the distances between all unique pairs of particles. Given $N$ particles with positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ in a cubic box of side length $L$, we consider all $\\frac{N(N-1)}{2}$ unordered pairs $(i, j)$ where $i<j$. For each pair, the displacement vector is $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$. Due to the periodic boundary conditions (PBC), the system is effectively infinite and tiled by periodic images of the central simulation box. The physically relevant distance is the shortest distance between particle $i$ and any periodic image of particle $j$. This is calculated using the minimum image convention (MIC). For each component of the displacement vector, for example $\\Delta x$, the MIC component $\\Delta x'$ is computed as $\\Delta x' = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$. The same is applied to the $\\Delta y$ and $\\Delta z$ components. The MIC distance is then the Euclidean norm of the resulting vector: $r_{ij} = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}$.\n\nSecond, these distances are compiled into a histogram. The domain of distances is partitioned into bins of width $\\Delta r$. The $k$-th bin, for integers $k \\ge 0$, corresponds to the half-open interval $[k\\Delta r, (k+1)\\Delta r)$. We compute a histogram, $\\{c_k\\}$, where each element $c_k$ is the integer count of particle pairs whose MIC distance $r_{ij}$ falls within the $k$-th bin.\n\nThird, the radial distribution function $g(r_k)$ is calculated at the center of each bin, $r_k = (k+\\frac{1}{2})\\Delta r$. It is defined as the ratio of the observed count $c_k$ to the expected count for an ideal gas, $c_k^{\\mathrm{ideal}}$:\n$$\ng(r_k) = \\frac{c_k}{c_k^{\\mathrm{ideal}}}\n$$\nThe ideal gas count represents the expected number of pairs in the same shell if the particles were distributed uniformly and randomly, with no correlations. This is derived from the volume of the spherical shell, $4\\pi r_k^2 \\Delta r$, relative to the total volume of the box, $V = L^3$, multiplied by the total number of pairs:\n$$\nc_k^{\\mathrm{ideal}} = \\frac{N(N-1)}{2} \\cdot \\frac{4\\pi r_k^2 \\Delta r}{V}\n$$\nThe calculation is performed for the specified evaluation radii, $r_{\\text{eval}}$, which are designed to coincide exactly with bin centers. For a given $r_{\\text{eval}}$, the corresponding bin index is $k = \\lfloor r_{\\text{eval}} / \\Delta r \\rfloor$.\n\nFinally, the problem requires an explanation for the unphysical artifacts observed in $g(r)$ for distances $r > L/2$ when using the standard spherical shell normalization. The formula for $c_k^{\\mathrm{ideal}}$ assumes that the volume of a spherical shell of radius $r_k$ is $4\\pi r_k^2 \\Delta r$. This assumption is valid in an unbounded Euclidean space. However, in a finite cubic box with PBC, the geometry is that of a $3$-torus. The MIC effectively restricts our view to the Wigner-Seitz cell of the periodic lattice, which is a cube of side $L$ centered on the reference particle. The maximum possible separation between any two points within this cell is $\\sqrt{(L/2)^2 + (L/2)^2 + (L/2)^2} = \\frac{\\sqrt{3}}{2}L$. When the radius of a spherical shell $r_k$ exceeds $L/2$, the sphere from which the shell is derived is larger than the Wigner-Seitz cell. Consequently, parts of the spherical shell lie outside the cell and, due to periodicity, overlap with other parts of the same shell when projected back into the central cell. The true volume available to particle pairs at this separation is less than the free-space volume $4\\pi r_k^2 \\Delta r$. The formula for $c_k^{\\mathrm{ideal}}$, by using this larger, uncorrected volume, overestimates the expected count for an ideal gas. This artificially inflates the denominator of the $g(r_k)$ ratio, causing the calculated $g(r_k)$ to be spuriously suppressed and trend towards $0$. This is a well-known finite-size artifact, and accurate calculations of $g(r)$ beyond $L/2$ require geometric correction factors for the shell volume that account for the cubic periodicity.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_g_r(L, N, coords, dr, r_max, r_eval_list):\n    \"\"\"\n    Calculates the radial distribution function g(r) for a given particle configuration.\n\n    Args:\n        L (float): Side length of the cubic simulation box.\n        N (int): Number of particles.\n        coords (list of tuples): List of particle coordinates.\n        dr (float): Thickness of the histogram bins.\n        r_max (float): Maximum radius for the histogram.\n        r_eval_list (list of floats): Radii at which to evaluate g(r).\n\n    Returns:\n        list of floats: The calculated g(r) values.\n    \"\"\"\n    V = L**3\n    num_bins = int(np.ceil(r_max / dr))\n    hist = np.zeros(num_bins, dtype=int)\n    coords_arr = np.array(coords, dtype=float)\n\n    # Loop over all unique pairs of particles (i < j)\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate separation vector\n            rij_vec = coords_arr[j] - coords_arr[i]\n\n            # Apply minimum image convention (MIC)\n            rij_vec_mic = rij_vec - L * np.round(rij_vec / L)\n            \n            # Calculate MIC distance\n            dist = np.linalg.norm(rij_vec_mic)\n            \n            # Add distance to the histogram if within range\n            if dist < r_max:\n                k = int(np.floor(dist / dr))\n                # Ensure bin index is within histogram array bounds\n                if k < num_bins:\n                    hist[k] += 1\n    \n    g_values = []\n    num_pairs = N * (N - 1) / 2.0\n    \n    # Calculate g(r) for each evaluation radius\n    for r_eval in r_eval_list:\n        k = int(np.floor(r_eval / dr))\n        \n        # This condition should not be met given the problem's setup, but is good practice.\n        if k >= num_bins:\n            g_values.append(0.0)\n            continue\n            \n        c_k = hist[k]\n        \n        if c_k == 0:\n            g_r = 0.0\n        else:\n            # The problem statement guarantees r_eval is a bin center r_k.\n            r_k = r_eval\n            \n            # Volume of the spherical shell in an ideal gas\n            vol_shell = 4 * np.pi * r_k**2 * dr\n            \n            # Expected number of pairs in the shell for an ideal gas\n            c_ideal = num_pairs * vol_shell / V\n            \n            if c_ideal > 0:\n                g_r = c_k / c_ideal\n            else:\n                # Should not occur here as r_k > 0 and N > 1.\n                g_r = 0.0 \n                \n        g_values.append(g_r)\n\n    return g_values\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 2.0, \"N\": 10, \"dr\": 0.10, \"r_max\": 1.50,\n            \"coords\": [\n                (0.10, 0.20, 0.30), (1.70, 0.50, 1.25), (0.90, 1.80, 0.40),\n                (1.20, 1.10, 1.90), (0.30, 0.90, 1.50), (1.60, 1.60, 0.20),\n                (0.50, 1.40, 1.10), (1.10, 0.30, 0.80), (0.80, 1.00, 0.10),\n                (1.90, 1.90, 1.50)\n            ],\n            \"r_eval\": [0.05, 0.25, 0.55, 1.05]\n        },\n        {\n            \"L\": 1.2, \"N\": 8, \"dr\": 0.10, \"r_max\": 0.80,\n            \"coords\": [\n                (0.10, 0.20, 0.30), (0.95, 0.50, 0.10), (0.60, 1.10, 0.90),\n                (0.25, 0.75, 0.45), (1.10, 0.95, 0.70), (0.40, 0.10, 1.05),\n                (0.80, 0.35, 0.55), (0.55, 0.95, 0.15)\n            ],\n            \"r_eval\": [0.05, 0.35, 0.55, 0.65]\n        },\n        {\n            \"L\": 1.0, \"N\": 2, \"dr\": 0.05, \"r_max\": 0.80,\n            \"coords\": [\n                (0.10, 0.10, 0.10), (0.90, 0.90, 0.90)\n            ],\n            \"r_eval\": [0.025, 0.175, 0.325, 0.525]\n        }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        g_values = calculate_g_r(\n            case[\"L\"], case[\"N\"], case[\"coords\"], case[\"dr\"], \n            case[\"r_max\"], case[\"r_eval\"]\n        )\n        # Format the inner list of results to 6 decimal places\n        inner_str = \",\".join([f\"{val:.6f}\" for val in g_values])\n        all_results_str.append(f\"[{inner_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond simple structural metrics, a frequent challenge in molecular simulation is identifying whole molecules or clusters, which can appear \"broken\" or \"wrapped\" across periodic boundaries. This advanced exercise  tackles this problem for a general, non-orthogonal simulation cell, which is common in materials science simulations. It combines a more sophisticated application of the minimum image convention with graph traversal algorithms to correctly identify all atoms belonging to a single connected entity, showcasing a powerful technique for complex structural analysis.",
            "id": "2460022",
            "problem": "You are given a three-dimensional periodic simulation cell described by a full-rank lattice matrix $\\mathbf{L} \\in \\mathbb{R}^{3 \\times 3}$ whose columns are the Cartesian components of the cell vectors $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, so that any Cartesian position vector $\\mathbf{r}$ corresponds to a fractional coordinate vector $\\mathbf{s}$ via $\\mathbf{r} = \\mathbf{L}\\mathbf{s}$ with $\\mathbf{s} \\in [0,1)^3$. A set of atom positions $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ is provided in Cartesian coordinates inside the primary cell, an interatomic connection threshold $r_{\\text{cut}} > 0$ is given in ångström (Å), and a seed atom index $s \\in \\{0,\\dots,N-1\\}$ (zero-based indexing) is specified. Two atoms $i$ and $j$ are considered adjacent (connected by an undirected edge) if and only if their minimum-image separation distance $d_{ij}$ in the periodic system satisfies $d_{ij} \\le r_{\\text{cut}}$. The minimum-image displacement $\\Delta \\mathbf{r}_{ij}$ from atom $i$ to atom $j$ is defined as follows: compute fractional coordinates $\\mathbf{s}_i = \\mathbf{L}^{-1}\\mathbf{r}_i$ and $\\mathbf{s}_j = \\mathbf{L}^{-1}\\mathbf{r}_j$, form $\\Delta \\mathbf{s}_{ij} = \\mathbf{s}_j - \\mathbf{s}_i$, then let $\\widehat{\\Delta \\mathbf{s}}_{ij}$ be obtained by adding an integer vector so that each component lies in the half-open interval $[-\\tfrac{1}{2}, \\tfrac{1}{2})$, and finally set $\\Delta \\mathbf{r}_{ij} = \\mathbf{L}\\widehat{\\Delta \\mathbf{s}}_{ij}$. The minimum-image distance is $d_{ij} = \\|\\Delta \\mathbf{r}_{ij}\\|_2$. Define a graph on vertices $\\{0,\\dots,N-1\\}$ with edges $\\{i,j\\}$ whenever $d_{ij} \\le r_{\\text{cut}}$. Your task is to determine the set of all atom indices belonging to the connected component that contains the seed atom index $s$, and to report these indices as a sorted list in ascending order.\n\nAll lengths (the entries of $\\mathbf{L}$, the components of $\\mathbf{r}_i$, and $r_{\\text{cut}}$) are specified in ångström (Å). Indices are unitless integers and must be reported using zero-based indexing. The condition for an edge must be interpreted as $d_{ij} \\le r_{\\text{cut}}$.\n\nTest suite. For each test case $t \\in \\{1,2,3\\}$, you are given $\\mathbf{L}^{(t)}$, the list of Cartesian positions $\\{\\mathbf{r}^{(t)}_i\\}$, the scalar $r^{(t)}_{\\text{cut}}$, and the seed $s^{(t)}$:\n\n- Test case $1$ (cubic cell with a chain wrapped across a face):\n  - $\\mathbf{L}^{(1)} = \\begin{bmatrix} 10.0 & 0.0 & 0.0 \\\\ 0.0 & 10.0 & 0.0 \\\\ 0.0 & 0.0 & 10.0 \\end{bmatrix}$.\n  - Positions $\\{\\mathbf{r}^{(1)}_i\\}_{i=0}^{5}$:\n    - $i = 0$: $(9.5,\\, 5.0,\\, 5.0)$,\n    - $i = 1$: $(0.5,\\, 5.0,\\, 5.0)$,\n    - $i = 2$: $(1.5,\\, 5.0,\\, 5.0)$,\n    - $i = 3$: $(8.0,\\, 5.0,\\, 5.0)$,\n    - $i = 4$: $(3.0,\\, 3.0,\\, 3.0)$,\n    - $i = 5$: $(3.9,\\, 3.0,\\, 3.0)$.\n  - $r^{(1)}_{\\text{cut}} = 1.2$.\n  - $s^{(1)} = 0$.\n\n- Test case $2$ (triclinic cell with a cluster spanning across boundaries):\n  - $\\mathbf{L}^{(2)} = \\begin{bmatrix} 8.0 & 2.0 & 1.0 \\\\ 0.0 & 7.0 & 1.5 \\\\ 0.0 & 0.0 & 6.5 \\end{bmatrix}$, where the columns are $\\mathbf{a} = (8.0,\\,0.0,\\,0.0)$, $\\mathbf{b} = (2.0,\\,7.0,\\,0.0)$, $\\mathbf{c} = (1.0,\\,1.5,\\,6.5)$.\n  - Positions $\\{\\mathbf{r}^{(2)}_i\\}_{i=0}^{3}$:\n    - $i = 0$: $(10.45,\\, 8.075,\\, 6.175)$,\n    - $i = 1$: $(3.03,\\, 8.145,\\, 6.175)$,\n    - $i = 2$: $(1.33,\\, 1.635,\\, 6.175)$,\n    - $i = 3$: $(4.4,\\, 3.4,\\, 2.6)$.\n  - $r^{(2)}_{\\text{cut}} = 1.0$.\n  - $s^{(2)} = 0$.\n\n- Test case $3$ (orthorhombic cell with distances exactly at the threshold):\n  - $\\mathbf{L}^{(3)} = \\begin{bmatrix} 8.0 & 0.0 & 0.0 \\\\ 0.0 & 8.0 & 0.0 \\\\ 0.0 & 0.0 & 8.0 \\end{bmatrix}$.\n  - Positions $\\{\\mathbf{r}^{(3)}_i\\}_{i=0}^{3}$:\n    - $i = 0$: $(7.5,\\, 4.0,\\, 4.0)$,\n    - $i = 1$: $(0.5,\\, 4.0,\\, 4.0)$,\n    - $i = 2$: $(1.5,\\, 4.0,\\, 4.0)$,\n    - $i = 3$: $(4.0,\\, 4.0,\\, 4.0)$.\n  - $r^{(3)}_{\\text{cut}} = 1.0$.\n  - $s^{(3)} = 0$.\n\nRequired program behavior:\n- For each test case, determine the sorted list of indices of all atoms in the connected component containing the seed atom according to the adjacency rule $d_{ij} \\le r_{\\text{cut}}$ with the minimum image convention under periodic boundary conditions defined above.\n- Your program should produce a single line of output containing the results as a comma-separated list of lists with no spaces, enclosed in square brackets. For example, if the three results were lists $\\ell^{(1)}$, $\\ell^{(2)}$, and $\\ell^{(3)}$, the required output format is $[\\ell^{(1)},\\ell^{(2)},\\ell^{(3)}]$ where each list is rendered as $[i_0,i_1,\\dots]$ with zero-based indices and no whitespace.",
            "solution": "The problem presented is a well-defined exercise in computational geometry and graph theory, fundamental to the field of molecular simulation. It requires the identification of a cluster of atoms, represented as a connected component in a graph, under periodic boundary conditions (PBC). The problem is scientifically grounded, internally consistent, and contains all necessary information for a unique solution. Therefore, it is valid, and we shall proceed with a rigorous analytical and algorithmic solution.\n\nThe core of the problem lies in correctly applying the Minimum Image Convention (MIC) for a general triclinic cell to determine adjacency between atoms, and then using a graph traversal algorithm to find the connected component containing a specified seed atom.\n\nLet us dissect the procedure.\n\n1.  **System Representation**: The simulation cell is a parallelepiped defined by three lattice vectors $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, which form the columns of the lattice matrix $\\mathbf{L} = [\\mathbf{a} \\ \\mathbf{b} \\ \\mathbf{c}]$. Any Cartesian position vector $\\mathbf{r}$ within the cell can be uniquely mapped to a fractional coordinate vector $\\mathbf{s} \\in [0, 1)^3$ via the linear transformation $\\mathbf{r} = \\mathbf{L}\\mathbf{s}$. The inverse transformation is $\\mathbf{s} = \\mathbf{L}^{-1}\\mathbf{r}$. The existence of $\\mathbf{L}^{-1}$ is guaranteed as $\\mathbf{L}$ is stipulated to be full-rank.\n\n2.  **Minimum Image Convention (MIC)**: To calculate the distance between two atoms $i$ and $j$ at Cartesian positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$, we must account for the periodic nature of the system. The distance is not simply $\\|\\mathbf{r}_j - \\mathbf{r}_i\\|_2$, but the minimum distance between atom $j$ and all periodic images of atom $i$. The set of all images of atom $i$ is given by $\\{\\mathbf{r}_i + \\mathbf{L}\\mathbf{n} \\,|\\, \\mathbf{n} \\in \\mathbb{Z}^3\\}$. The squared distance is thus $d_{ij}^2 = \\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\|\\mathbf{r}_j - (\\mathbf{r}_i + \\mathbf{L}\\mathbf{n})\\|_2^2$.\n\n    The problem provides a direct and computationally efficient algorithm to find this minimum image displacement vector. This procedure avoids an explicit search over integer vectors $\\mathbf{n}$.\n    \n    a. First, we transform the problem into the space of fractional coordinates, where periodicity is simpler to handle. The displacement vector in Cartesian coordinates is $\\Delta\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$. In fractional coordinates, this becomes $\\Delta\\mathbf{s}_{ij} = \\mathbf{s}_j - \\mathbf{s}_i = \\mathbf{L}^{-1}(\\mathbf{r}_j - \\mathbf{r}_i)$. Since $\\mathbf{s}_i, \\mathbf{s}_j \\in [0,1)^3$, each component of $\\Delta\\mathbf{s}_{ij}$ lies in $(-1, 1)$.\n\n    b. The next step is to apply the MIC in fractional space. This means finding an integer vector $\\mathbf{n}$ such that the wrapped displacement $\\widehat{\\Delta\\mathbf{s}}_{ij} = \\Delta\\mathbf{s}_{ij} - \\mathbf{n}$ has each of its components in the interval $[-\\frac{1}{2}, \\frac{1}{2})$. This vector corresponds to the image of atom $j$ that is closest to atom $i$. For each component $v_k$ of a vector $\\mathbf{v}$, the wrapping operation that maps it to $[-\\frac{1}{2}, \\frac{1}{2})$ can be implemented as $v_k - \\lfloor v_k + \\frac{1}{2} \\rfloor$. In a computational setting using floating-point arithmetic, care must be taken with boundary cases. A robust implementation is `v_wrapped = (v + 0.5) % 1.0 - 0.5`, where `%` denotes the modulo operation that correctly handles negative numbers, as exemplified by Python's `%` operator or `numpy.mod`.\n\n    c. Once the wrapped fractional displacement $\\widehat{\\Delta\\mathbf{s}}_{ij}$ is found, we convert it back to Cartesian coordinates to obtain the minimum image displacement vector: $\\Delta\\mathbf{r}_{ij}^{\\text{min}} = \\mathbf{L} \\widehat{\\Delta\\mathbf{s}}_{ij}$.\n\n    d. The minimum image distance $d_{ij}$ is the Euclidean norm of this vector: $d_{ij} = \\|\\Delta\\mathbf{r}_{ij}^{\\text{min}}\\|_2$.\n\n3.  **Graph Construction**: An undirected graph $G = (V, E)$ is implicitly defined. The set of vertices $V$ is the set of atom indices $\\{0, 1, \\dots, N-1\\}$. An edge $(i, j)$ exists in $E$ if and only if the minimum image distance $d_{ij}$ is less than or equal to the given cutoff radius, $d_{ij} \\le r_{\\text{cut}}$. Due to the properties of the distance metric, $d_{ij} = d_{ji}$, so the graph is indeed undirected.\n\n4.  **Connected Component Search**: The final task is to find all vertices in the connected component containing the given seed atom index $s$. This is a standard graph traversal problem. We can employ a Breadth-First Search (BFS) or a Depth-First Search (DFS) algorithm, starting from the seed vertex $s$.\n\n    The algorithm proceeds as follows:\n    a. Build an adjacency list representation of the graph $G$. For each pair of atoms $(i, j)$ with $i < j$, compute $d_{ij}$. If $d_{ij} \\le r_{\\text{cut}}$, add $j$ to the adjacency list of $i$ and $i$ to the adjacency list of $j$.\n    b. Initialize a queue for BFS with the seed atom $s$ and a set `visited` also containing $s$.\n    c. While the queue is not empty, dequeue a vertex $u$. For each neighbor $v$ of $u$ in the adjacency list, if $v$ has not yet been visited, add it to the `visited` set and enqueue it.\n    d. The process terminates when the queue is empty. The `visited` set now contains all atom indices in the connected component of $s$.\n\n5.  **Final Result Formulation**: The resulting set of indices is converted to a list and sorted in ascending order as required. This procedure is repeated for each test case.\n\nThe implementation will use the `numpy` library for efficient linear algebra operations, such as matrix inversion, matrix-vector products, and vector norms.",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the connected components problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"L\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"positions\": np.array([\n                [9.5, 5.0, 5.0], [0.5, 5.0, 5.0], [1.5, 5.0, 5.0],\n                [8.0, 5.0, 5.0], [3.0, 3.0, 3.0], [3.9, 3.0, 3.0]\n            ]),\n            \"r_cut\": 1.2,\n            \"seed\": 0\n        },\n        {\n            \"L\": np.array([\n                [8.0, 2.0, 1.0],\n                [0.0, 7.0, 1.5],\n                [0.0, 0.0, 6.5]\n            ]),\n            \"positions\": np.array([\n                [10.45, 8.075, 6.175], [3.03, 8.145, 6.175],\n                [1.33, 1.635, 6.175], [4.4, 3.4, 2.6]\n            ]),\n            \"r_cut\": 1.0,\n            \"seed\": 0\n        },\n        {\n            \"L\": np.array([\n                [8.0, 0.0, 0.0],\n                [0.0, 8.0, 0.0],\n                [0.0, 0.0, 8.0]\n            ]),\n            \"positions\": np.array([\n                [7.5, 4.0, 4.0], [0.5, 4.0, 4.0],\n                [1.5, 4.0, 4.0], [4.0, 4.0, 4.0]\n            ]),\n            \"r_cut\": 1.0,\n            \"seed\": 0\n        }\n    ]\n\n    def find_connected_component(L, positions, r_cut, seed):\n        \"\"\"\n        Finds the connected component for a single test case.\n        \"\"\"\n        num_atoms = len(positions)\n        try:\n            L_inv = np.linalg.inv(L)\n        except np.linalg.LinAlgError:\n            # This should not happen for valid problems with a full-rank matrix L.\n            return []\n\n        # Convert all Cartesian positions to fractional coordinates at once.\n        # Here, positions are rows, so we transpose for matmul and transpose back.\n        # r = Ls -> s = L^-1 r. For r vectors as rows: S^T = (L^-1 R^T) -> S = (L^-1 R^T)^T = R (L^-1)^T\n        s_coords = positions @ L_inv.T\n        \n        # Build adjacency list\n        adj = {i: [] for i in range(num_atoms)}\n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                # Fractional displacement\n                delta_s = s_coords[j] - s_coords[i]\n                \n                # Apply minimum image convention to fractional displacement\n                # Wrap into [-0.5, 0.5)\n                # This is a robust way to handle the wrapping for both positive and negative values.\n                delta_s_wrapped = np.mod(delta_s + 0.5, 1.0) - 0.5\n                \n                # Convert back to Cartesian\n                delta_r = delta_s_wrapped @ L.T\n                \n                # Calculate distance\n                dist = np.linalg.norm(delta_r)\n                \n                # Check against cutoff and add edge if connected\n                if dist <= r_cut:\n                    adj[i].append(j)\n                    adj[j].append(i)\n\n        # Find connected component using Breadth-First Search (BFS)\n        if seed >= num_atoms:\n            return []\n\n        q = deque([seed])\n        visited = {seed}\n        \n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if v not in visited:\n                    visited.add(v)\n                    q.append(v)\n        \n        return sorted(list(visited))\n\n    results = []\n    for case in test_cases:\n        component = find_connected_component(case[\"L\"], case[\"positions\"], case[\"r_cut\"], case[\"seed\"])\n        results.append(component)\n        \n    # Format the final output string as per requirements.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}