{
    "hands_on_practices": [
        {
            "introduction": "理解总变差递减（TVD）格式价值的最好方法，是将其与非TVD格式进行直接对比。本练习将引导你比较三种经典方法——Lax-Wendroff、Godunov和MUSCL格式——在处理一个带有尖锐间断（方波）的挑战性测试时的表现。通过这个实践，你将能够直观地和定量地评估它们在抑制伪振荡方面的性能。",
            "id": "3200760",
            "problem": "考虑一维标量守恒律 $u_t + f(u)_x = 0$，定义在周期性区域 $x \\in [0,1)$ 上，其平流输运通量为常数 $f(u) = a\\,u$，其中 $a  0$ 为常数。设离散解定义在包含 $N_x$ 个单元的均匀网格上，采用周期性边界条件，并用 $u_i^n$ 表示在单元索引 $i$ 和时间层 $n$ 的单元平均近似值。在时间层 $n$ 的离散总变差定义为\n$$\nTV(u^n) = \\sum_{i=0}^{N_x-1} \\left| u_{i+1}^n - u_i^n \\right|,\n$$\n其中索引是周期性的，即 $u_{N_x}^n \\equiv u_0^n$。如果一个格式在合适的 Courant–Friedrichs–Lewy (CFL) 条件下，对所有 $n$ 都满足 $TV(u^{n+1}) \\le TV(u^n)$，则该格式称为总变差递减 (TVD) 格式。\n\n您的任务是针对 $a = 1$ 的特定情况，实现并比较三种有限体积时间推进格式：\n- Lax–Wendroff 格式，\n- 针对正速度标量平流的 Godunov 迎风格式，\n- 带 minmod 限制器的守恒律单调上游中心格式 (MUSCL)，该格式采用经典的通量限制器形式，当 Courant 数在 $[0,1]$ 范围内时，满足 Sweby 对标量平流问题的 TVD 约束。\n\n从守恒的基本形式出发，即更新由均匀网格上的守恒通量差分离散化给出，并将 Courant 数定义为 $\\nu = a\\,\\Delta t / \\Delta x$。在整个计算过程中使用周期性边界条件。\n\n初始数据：构造方波脉冲\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [0.3, 0.7),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n在单元中心进行采样。计算域为 $[0,1)$，包含 $N_x$ 个均匀单元，单元宽度 $\\Delta x = 1/N_x$，单元中心 $x_i = (i+1/2)\\Delta x$，时间步长 $\\Delta t = \\nu\\,\\Delta x / a$，其中 $a=1$。\n\n对于每种格式和下面的每个测试用例，使用固定的 $\\Delta t$ 在时间上推进数值解，执行足够多的完整时间步，以确保模拟时间至少达到指定的结束时间 $T_{\\text{end}}$。在每个时间层 $n$（包括 $n=0$），计算 $TV(u^n)$ 并评估总变差是否随时间非增，即对于所有执行的步骤 $n$，是否在数值容差 $\\varepsilon = 10^{-10}$（用于考虑浮点舍入误差）内满足 $TV(u^{n+1}) \\le TV(u^{n})$。\n\n测试套件（每个元组为 $(N_x,\\ \\nu,\\ T_{\\text{end}})$）：\n- 用例 A: $(200,\\ 0.5,\\ 0.25)$，\n- 用例 B: $(40,\\ 0.9,\\ 0.35)$，\n- 用例 C: $(160,\\ 0.2,\\ 0.50)$。\n\n预测要求：基于标量守恒律中单调性和总变差递减格式的原理，合理解释三种格式中哪些能保持数值解的单调性，因此在这些测试中应产生非增的 $TV(u^n)$，哪些不能。您实现的程序必须通过检查 $TV(u^n)$ 序列的单调性来数值验证这些预测。\n\n最终输出要求：您的程序必须生成单行输出，其中包含一个由九个布尔值组成的逗号分隔列表，并用方括号括起来，顺序如下\n$$\n[\\text{LW}_A,\\ \\text{GOD}_A,\\ \\text{MUSCL}_A,\\ \\text{LW}_B,\\ \\text{GOD}_B,\\ \\text{MUSCL}_B,\\ \\text{LW}_C,\\ \\text{GOD}_C,\\ \\text{MUSCL}_C],\n$$\n其中，如果对应格式和用例的 $TV(u^n)$ 是非增的（在容差 $\\varepsilon$ 内），则每个条目为 $True$，否则为 $False$。打印的列表中不允许有空格。所有量纲均为无量纲；不需要物理单位。此问题不涉及角度，因此不需要角度单位。要求的输出类型是布尔值列表。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于双曲守恒律数值方法的理论，定义和参数完整一致，问题设定良好，并以客观、正式的语言表达。任务是实现并分析三种标准的有限体积格式，这是计算科学中一项可行且有意义的练习。\n\n目标是求解在周期性区域 $x \\in [0,1)$ 上的一维线性平流方程 $u_t + a u_x = 0$（其中 $a=1$）。在时间层 $n$，单元 $i$ 中的单元平均量 $u_i^n$ 的更新由守恒型有限体积公式给出：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right)\n$$\n其中 $F_{i+1/2}^n$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量，$\\Delta x$ 是单元宽度，$\\Delta t$ 是时间步长。Courant 数定义为 $\\nu = a \\frac{\\Delta t}{\\Delta x}$。当 $a=1$ 时，这简化为 $\\nu = \\frac{\\Delta t}{\\Delta x}$。我们将分析总变差递减 (TVD) 特性，该特性要求总变差 $TV(u^n) = \\sum_{i=0}^{N_x-1} |u_{i+1}^n - u_i^n|$ 对所有时间步 $n$ 都是非增的。\n\n**格式行为预测**\n\n基于双曲守恒律有限体积方法的既定理论，我们可以预测每种格式关于 TVD 特性的行为。\n\n1.  **Lax–Wendroff 格式**：这是一种在时间和空间上均为二阶精度的格式。虽然其较高的精度对于光滑解是理想的，但它是一种线性格式，众所周知不具有保单调性。在间断或陡峭梯度附近，它会引入虚假、非物理的振荡（Gibbs 现象），这会在局部产生新的极值点。新极值点的产生必然会增加总变差。因此，Lax-Wendroff 格式不是 TVD 的。我们预测它在所有测试用例中都无法通过 TVD 检查。\n\n2.  **Godunov 迎风格式**：对于具有正速度 $a0$ 的线性平流方程，Godunov 方法简化为一阶迎风格式。Harten 的一个关键定理指出，任何单调格式都是 TVD 的。一阶迎风格式在 Courant–Friedrichs–Lewy (CFL) 条件 $0 \\le \\nu \\le 1$ 下是单调的。由于所有测试用例使用的 $\\nu$ 都在此范围内，我们预测 Godunov 格式在所有测试用例中都将是 TVD 的。\n\n3.  **带 Minmod 限制器的 MUSCL 格式**：守恒律单调上游中心格式 (MUSCL) 是一种高分辨率格式，旨在在光滑区域实现更高阶的精度，同时防止在间断处的振荡，从而满足 TVD 特性。这是通过使用非线性的“限制器”函数来实现的。minmod 限制器是保证格式为 TVD 的最基本限制器之一。只要满足 CFL 条件 $0 \\le \\nu \\le 1$，该格式就被证明是 TVD 的。因此，我们预测 MUSCL 实现在所有测试用例中都将通过 TVD 检查。\n\n**数值格式的数学表述**\n\n初始条件为方波脉冲：\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [0.3, 0.7) \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n单元平均近似值 $u_i^0$ 是通过在单元中心 $x_i = (i+1/2)\\Delta x$（其中 $i=0, 1, \\dots, N_x-1$）对该函数进行采样获得的。对于所有格式，都强制执行周期性边界条件，意味着索引被循环处理（例如，$u_{-1}^n = u_{N_x-1}^n$ 和 $u_{N_x}^n = u_0^n$）。对于 $a=1$ 的特定情况，通量为 $f(u)=u$。\n\n1.  **Lax–Wendroff 格式**：Lax-Wendroff 格式的数值通量由时间上的二阶泰勒级数展开导出。对于线性平流，这得到：\n    $$\n    F_{i+1/2}^{LW} = \\frac{1}{2}a\\left(u_i^n + u_{i+1}^n\\right) - \\frac{1}{2}\\frac{a^2 \\Delta t}{\\Delta x}\\left(u_{i+1}^n - u_i^n\\right) = \\frac{1}{2}a\\left(u_i^n + u_{i+1}^n\\right) - \\frac{1}{2}a\\nu\\left(u_{i+1}^n - u_i^n\\right)\n    $$\n\n2.  **Godunov 迎风格式**：对于正的平流速度 $a0$，界面 $x_{i+1/2}$ 处的特征信息来自“迎风”方向，即单元 $i$。界面处的 Riemann 问题的解为常数 $u_i^n$。因此，通量就是迎风状态的通量：\n    $$\n    F_{i+1/2}^{GOD} = f(u_i^n) = a u_i^n\n    $$\n\n3.  **带 Minmod 限制器的 MUSCL 格式**：该格式通过首先在每个单元中重构数据的分段线性表示，然后用它来求解界面上的状态，从而改进了 Godunov 方法。对于 $a0$ 的迎风格式， $x_{i+1/2}$ 处的通量取决于界面左侧的重构状态 $u_{L, i+1/2}$。这个状态是通过将单元 $i$ 内的重构线性廓线演化半个时间步得到的。其表述为：\n    $$\n    F_{i+1/2}^{MUSCL} = a \\, u_{L, i+1/2}^n\n    $$\n    其中界面状态由下式给出\n    $$\n    u_{L, i+1/2}^n = u_i^n + \\frac{1}{2}(1-\\nu) \\sigma_i^n\n    $$\n    项 $\\sigma_i^n$ 是单元 $i$ 内的受限斜率。对于 minmod 限制器，此斜率在后向和前向差分斜率中选择绝对值较小的那个，如果它们符号相反则为零：\n    $$\n    \\sigma_i^n = \\text{minmod}(u_i^n - u_{i-1}^n, u_{i+1}^n - u_i^n)\n    $$\n    minmod 函数定义为：\n    $$\n    \\text{minmod}(x, y) = \\begin{cases}\n    x  \\text{if } |x|  |y| \\text{ and } xy  0 \\\\\n    y  \\text{if } |y| \\le |x| \\text{ and } xy  0 \\\\\n    0  \\text{if } xy \\le 0\n    \\end{cases}\n    $$\n这种构造确保了不会产生新的局部极值点，这是格式成为 TVD 的条件。\n\n**数值验证**\n\n该实现将为三种格式中的每一种以及每个测试用例 $(N_x, \\nu, T_{\\text{end}})$ 模拟方波脉冲的平流过程。在每个时间步，包括 $n=0$ 的初始状态，计算总变差 $TV(u^n)$。然后检查 $TV$ 值的序列是否非增，即对于所有步骤 $n$ 是否满足 $TV(u^{n+1}) \\le TV(u^n) + \\varepsilon$，其中 $\\varepsilon = 10^{-10}$ 是用于浮点算术误差的容差。对于九种组合中的每一种，此检查的布尔结果将被报告。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Lax-Wendroff, Godunov, and MUSCL schemes for the 1D\n    linear advection equation, checking their Total Variation Diminishing (TVD) property.\n    \"\"\"\n    \n    # Define the test cases from the problem statement: (Nx, nu, T_end)\n    test_cases = [\n        (200, 0.5, 0.25),  # Case A\n        (40, 0.9, 0.35),   # Case B\n        (160, 0.2, 0.50),  # Case C\n    ]\n    \n    # Define problem constants\n    a = 1.0  # Advection speed\n    epsilon = 1e-10  # Numerical tolerance for TVD check\n\n    results = []\n\n    def initialize_u(Nx):\n        \"\"\"Constructs the initial square pulse on a grid of size Nx.\"\"\"\n        x = (np.arange(Nx) + 0.5) / Nx\n        u0 = np.where((x >= 0.3)  (x  0.7), 1.0, 0.0)\n        return u0\n\n    def compute_tv(u):\n        \"\"\"Computes the total variation of a periodic array u.\"\"\"\n        u_plus_1 = np.roll(u, -1)\n        return np.sum(np.abs(u_plus_1 - u))\n\n    def minmod(x, y):\n        \"\"\"Vectorized minmod limiter function.\"\"\"\n        return (np.sign(x) + np.sign(y)) / 2.0 * np.minimum(np.abs(x), np.abs(y))\n\n    def run_simulation(scheme, u0, Nx, nu, T_end):\n        \"\"\"\n        Runs a simulation for a given scheme and returns if it's TVD.\n        \n        Args:\n            scheme (str): 'lw', 'godunov', or 'muscl'\n            u0 (np.ndarray): Initial condition array.\n            Nx (int): Number of grid points.\n            nu (float): Courant number.\n            T_end (float): End time of the simulation.\n\n        Returns:\n            bool: True if the scheme is TVD for this run, False otherwise.\n        \"\"\"\n        dx = 1.0 / Nx\n        dt = nu * dx / a\n        num_steps = int(np.ceil(T_end / dt))\n        \n        u = u0.copy()\n        tv_history = [compute_tv(u)]\n\n        for _ in range(num_steps):\n            u_im1 = np.roll(u, 1)  # u_{i-1} for all i\n            u_ip1 = np.roll(u, -1) # u_{i+1} for all i\n            \n            if scheme == 'lw':\n                # Lax-Wendroff flux\n                flux = 0.5 * a * (u + u_ip1) - 0.5 * a * nu * (u_ip1 - u)\n            elif scheme == 'godunov':\n                # Godunov (upwind for a>0) flux\n                flux = a * u\n            elif scheme == 'muscl':\n                # MUSCL with minmod limiter\n                slope_bwd = u - u_im1\n                slope_fwd = u_ip1 - u\n                limited_slope = minmod(slope_bwd, slope_fwd)\n                u_L = u + 0.5 * (1.0 - nu) * limited_slope\n                flux = a * u_L\n            else:\n                raise ValueError(\"Unknown scheme\")\n\n            flux_im1 = np.roll(flux, 1)\n            u = u - (dt / dx) * (flux - flux_im1)\n            tv_history.append(compute_tv(u))\n\n        # Check if total variation is non-increasing\n        is_tvd = all(tv_history[i] >= tv_history[i+1] - epsilon for i in range(len(tv_history) - 1))\n        return is_tvd\n\n    for Nx, nu, T_end in test_cases:\n        u0 = initialize_u(Nx)\n        \n        # Run Lax-Wendroff\n        results.append(run_simulation('lw', u0, Nx, nu, T_end))\n        \n        # Run Godunov\n        results.append(run_simulation('godunov', u0, Nx, nu, T_end))\n        \n        # Run MUSCL\n        results.append(run_simulation('muscl', u0, Nx, nu, T_end))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在高分辨率TVD格式的背后，通量限制器（flux limiter）扮演着关键角色。本练习将深入探讨这一核心技术，比较两种不同的限制器（van Leer和superbee）在处理光滑解（正弦波）时的行为。这个实践突显了一个重要且微妙的权衡：限制器在努力抑制振荡的同时，有时会“削平”光滑解的峰值。",
            "id": "3200717",
            "problem": "考虑一维线性平流方程 $u_t + a\\,u_x = 0$，定义在周期性域 $x \\in [0,2\\pi)$ 上，其中平流速度 $a0$ 为常数，初始条件为 $u(x,0) = \\sin(x)$，$x$ 的单位为弧度。在总变差递减（Total Variation Diminishing, TVD）格式的背景下，可以通过保守有限体积离散化结合斜率限制函数 $\\phi(r)$ 来推导高分辨率通量限制方法，其中 $r$ 表示连续斜率的适当离散比率。两种常用的限制器函数是：\n- van Leer 限制器：$\\phi(r) = \\dfrac{r + |r|}{1 + |r|}$,\n- superbee 限制器：$\\phi(r) = \\max\\big(0, \\min(2r,1), \\min(r,2)\\big)$。\n\n您的任务是：\n1. 在均匀网格上，针对 $a0$ 的情况，使用依赖于基于 $u_i^n$ 局部差分的离散斜率比 $r$ 的限制器函数 $\\phi(r)$，推导一个用于 $u_i^n$ 的保守、二阶精确、通量限制的TVD更新格式。网格间距为 $\\Delta x$，并采用周期性边界条件。设 $\\nu = a\\,\\Delta t / \\Delta x$ 为 Courant–Friedrichs–Lewy (CFL) 数。推导必须从守恒律和有限体积解释开始，而不是从一个预先给定的更新公式开始。\n2. 在推导出的格式中实现 van Leer 和 superbee 限制器，并使用周期性边界条件，将解演化指定的步数 $n_{\\text{steps}}$。\n3. 计算离散总变差 $TV(u) = \\sum_{i=0}^{N-1} |u_{i+1} - u_i|$，根据周期性约定 $u_N \\equiv u_0$，计算初始时刻以及使用每种限制器演化后的总变差。\n4. 通过报告每种限制器演化后的最大绝对值 $\\max_i |u_i|$ 来量化极值平坦化。由于初始波的振幅为1，当该度量值小于1时，它直接反映了平坦化程度。\n5. 使用以下测试套件，其中指定了网格大小 $N$、Courant–Friedrichs–Lewy (CFL) 数 $\\nu$ 以及时间步数 $n_{\\text{steps}}$：\n   - 测试用例 1: $N=50$, $\\nu=0.2$, $n_{\\text{steps}}=50$。\n   - 测试用例 2: $N=50$, $\\nu=0.9$, $n_{\\text{steps}}=50$。\n   - 测试用例 3: $N=200$, $\\nu=0.5$, $n_{\\text{steps}}=200$。\n   - 测试用例 4: $N=200$, $\\nu=0.9$, $n_{\\text{steps}}=200$。\n假设 $a=1$ 且 $\\Delta x = \\dfrac{2\\pi}{N}$。为了在计算 $r$ 时保证数值稳定性，您可以在需要时通过在分母上添加一个小的正数 $\\varepsilon$ 来进行正则化。\n\n您的程序应生成单行输出，包含一个以逗号分隔的列表的列表形式的结果，其中每个内部列表按顺序对应一个测试用例，并包含五个按以下顺序排列的浮点数（保留六位小数）：$[TV(u^0), TV_{\\text{vanLeer}}(u^{n_{\\text{steps}}}), TV_{\\text{superbee}}(u^{n_{\\text{steps}}}), \\max|u^{n_{\\text{steps}}}|_{\\text{vanLeer}}, \\max|u^{n_{\\text{steps}}}|_{\\text{superbee}}]$。例如，输出格式应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，打印行中不含空格。",
            "solution": "用户提供的问题被评估为有效。这是一个适定、有科学依据的计算科学问题，没有问题验证部分概述的任何使其无效的缺陷。\n\n### 通量限制TVD格式的推导\n\n一维线性平流方程是形如 $u_t + f(u)_x = 0$ 的守恒律模型，其中 $u = u(x,t)$ 是守恒量，$f(u)$ 是其通量。对于给定的问题，通量为 $f(u) = au$，其中平流速度 $a$ 是一个正常数。方程为 $u_t + (au)_x = 0$。\n\n我们将使用有限体积法推导数值更新规则。考虑一个均匀网格，其空间单元为 $C_i = [x_{i-1/2}, x_{i+1/2}]$，宽度为 $\\Delta x = x_{i+1/2} - x_{i-1/2}$，离散时间层为 $t^n = n \\Delta t$。在时间 $t^n$ 时，单元 $C_i$ 中 $u$ 的单元平均值定义为：\n$$ u_i^n = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t^n) dx $$\n将守恒律在时空体积 $C_i \\times [t^n, t^{n+1}]$ 上积分，得到：\n$$ \\int_{t^n}^{t^{n+1}} \\int_{x_{i-1/2}}^{x_{i+1/2}} (u_t + (au)_x) dx dt = 0 $$\n应用散度定理，可以将其重写为：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} (u(x, t^{n+1}) - u(x, t^n)) dx + \\int_{t^n}^{t^{n+1}} (au(x_{i+1/2}, t) - au(x_{i-1/2}, t)) dt = 0 $$\n对积分进行近似，我们得到单元平均值的精确有限体积更新式：\n$$ \\Delta x (u_i^{n+1} - u_i^n) + \\Delta t (F_{i+1/2} - F_{i-1/2}) = 0 $$\n其中 $F_{i+1/2}$ 是在单元界面 $x_{i+1/2}$ 上的时间平均通量：\n$$ F_{i+1/2} = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} au(x_{i+1/2}, t) dt $$\n有限体积格式的核心是数值通量 $F_{i+1/2}$ 的定义，它近似于这个时间平均通量。重新整理更新公式可得：\n$$ u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) $$\n\n通过混合低分辨率（一阶，高耗散）通量和高分辨率（二阶，低耗散）通量，可以构建一个高分辨率总变差递减（TVD）格式。这是通过使用通量限制器实现的。数值通量 $F_{i+1/2}$ 表示为：\n$$ F_{i+1/2} = F_{i+1/2}^{\\text{low}} + \\Phi_{i+1/2} $$\n其中 $F_{i+1/2}^{\\text{low}}$ 是一阶TVD通量，$\\Phi_{i+1/2}$ 是一个受限的修正项，通常称为反扩散通量。\n\n对于 $a0$ 的线性平流方程，最简单的一阶TVD通量是迎风通量，它取自“迎风”单元（对于界面 $i+1/2$ 是单元 $i$）的值：\n$$ F_{i+1/2}^{\\text{low}} = a u_i^n $$\n高分辨率通量的一个常见选择是二阶Lax-Wendroff通量。对于常系数问题，其通量为：\n$$ F_{i+1/2}^{\\text{high}} = a \\frac{u_i^n + u_{i+1}^n}{2} - \\frac{a^2 \\Delta t}{2 \\Delta x} (u_{i+1}^n - u_i^n) = \\frac{a}{2}(u_i^n + u_{i+1}^n) - \\frac{a \\nu}{2}(u_{i+1}^n - u_i^n) $$\n其中 $\\nu = a \\Delta t / \\Delta x$ 是 Courant-Friedrichs-Lewy (CFL) 数。\n\n反扩散通量修正项 $\\Phi_{i+1/2}$ 是高阶通量和低阶通量之差：\n$$ \\Phi_{i+1/2} = F_{i+1/2}^{\\text{high}} - F_{i+1/2}^{\\text{low}} = \\left( \\frac{a}{2}(u_i^n + u_{i+1}^n) - \\frac{a \\nu}{2}(u_{i+1}^n - u_i^n) \\right) - a u_i^n $$\n$$ \\Phi_{i+1/2} = \\frac{a}{2}(u_{i+1}^n - u_i^n) - \\frac{a \\nu}{2}(u_{i+1}^n - u_i^n) = \\frac{a(1-\\nu)}{2}(u_{i+1}^n - u_i^n) $$\n于是，受限通量为：\n$$ F_{i+1/2} = F_{i+1/2}^{\\text{low}} + \\phi_{i+1/2} \\Phi_{i+1/2} = a u_i^n + \\phi(r_{i+1/2}) \\frac{a(1-\\nu)}{2}(u_{i+1}^n - u_i^n) $$\n限制器函数 $\\phi$ 依赖于连续解梯度的比率。对于 $a0$，信息从左向右传播。在界面 $x_{i+1/2}$ 处，斜率比的一个标准选择是迎风单元（$C_i$）梯度与顺风单元（$C_{i+1}$）梯度之比，或者更简单地，是迎风差分与局部差分之比：\n$$ r_{i+1/2} = \\frac{u_i^n - u_{i-1}^n}{u_{i+1}^n - u_i^n} $$\n当分母接近零时，我们添加一个小的正则化参数 $\\varepsilon$ 以避免除以零。\n\n将数值通量 $F$ 的完整表达式代入有限体积更新公式，得到最终的格式。为了便于实现，定义单位速度通量 $f_{i+1/2} = F_{i+1/2} / a$ 会很方便：\n$$ f_{i+1/2} = u_i^n + \\frac{1-\\nu}{2} \\phi(r_{i+1/2}) (u_{i+1}^n - u_i^n) $$\n更新方程则变为：\n$$ u_i^{n+1} = u_i^n - \\nu (f_{i+1/2} - f_{i-1/2}) $$\n在这里，$f_{i-1/2}$ 使用相同的公式计算，但所有索引都前移一位（减1）：\n$$ f_{i-1/2} = u_{i-1}^n + \\frac{1-\\nu}{2} \\phi(r_{i-1/2}) (u_i^n - u_{i-1}^n) $$\n及其对应的斜率比：\n$$ r_{i-1/2} = \\frac{u_{i-1}^n - u_{i-2}^n}{u_i^n - u_{i-1}^n} $$\n该格式由于写成通量差分形式，因此在构造上是保守的。在光滑解区域，限制器 $\\phi(r) \\approx r$，格式是二阶精确的；并且在条件 $0 \\le \\phi(r)/r \\le 2$ 和 $0 \\le \\phi(r) \\le 2$ 下是TVD的，对于 $0  \\nu \\le 1$，指定的限制器满足这些条件。\n\n两个特定的限制器函数是：\n1.  **van Leer 限制器：** $\\phi(r) = \\dfrac{r + |r|}{1 + |r|}$\n2.  **superbee 限制器：** $\\phi(r) = \\max\\big(0, \\min(2r,1), \\min(r,2)\\big)$\n\n这些将被实现在推导出的更新公式中，以演化解并进行所需的分析。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using flux-limited TVD schemes\n    for a suite of test cases and formats the output.\n    \"\"\"\n\n    test_cases = [\n        # (N, nu, n_steps)\n        (50, 0.2, 50),\n        (50, 0.9, 50),\n        (200, 0.5, 200),\n        (200, 0.9, 200),\n    ]\n\n    all_results = []\n    for N, nu, n_steps in test_cases:\n        result = run_simulation(N, nu, n_steps)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists with 6 decimal places.\n    output_parts = []\n    for case_res in all_results:\n        case_str = ','.join(f\"{v:.6f}\" for v in case_res)\n        output_parts.append(f\"[{case_str}]\")\n    final_output = f\"[{','.join(output_parts)}]\"\n\n    print(final_output)\n\ndef run_simulation(N, nu, n_steps):\n    \"\"\"\n    Performs a single simulation for a given set of parameters.\n\n    Args:\n        N (int): Number of grid points.\n        nu (float): Courant-Friedrichs-Lewy (CFL) number.\n        n_steps (int): Number of time steps to evolve.\n\n    Returns:\n        list: A list of 5 floats:\n              [TV(initial), TV(final, vanLeer), TV(final, superbee),\n               max|u|(final, vanLeer), max|u|(final, superbee)]\n    \"\"\"\n    a = 1.0\n    epsilon = 1e-12  # Regularization for division by zero\n\n    # Grid setup and initial condition\n    dx = 2.0 * np.pi / N\n    x = np.arange(N) * dx\n    u0 = np.sin(x)\n\n    # Initialize solutions for each limiter\n    u_vl = u0.copy()\n    u_sb = u0.copy()\n\n    # Limiter functions\n    def van_leer_limiter(r):\n        return (r + np.abs(r)) / (1.0 + np.abs(r) + epsilon)\n\n    def superbee_limiter(r):\n        # phi(r) = max(0, min(2r, 1), min(r, 2))\n        zero_arr = np.zeros_like(r)\n        min1 = np.minimum(2.0 * r, 1.0)\n        min2 = np.minimum(r, 2.0)\n        # Use np.amax on a stack of arrays for a clear 3-argument maximum\n        return np.amax(np.stack([zero_arr, min1, min2]), axis=0)\n\n    # Time-stepping loop\n    for _ in range(n_steps):\n        # Update using van Leer limiter\n        u = u_vl\n        u_p1 = np.roll(u, -1)  # u_{i+1}\n        u_m1 = np.roll(u, 1)   # u_{i-1}\n\n        # Difference terms needed for flux calculation\n        diff_forward = u_p1 - u  # u_{i+1} - u_i\n        diff_backward = u - u_m1 # u_i - u_{i-1}\n\n        # Slope ratio r_{i+1/2} = (u_i - u_{i-1}) / (u_{i+1} - u_i)\n        r = diff_backward / (diff_forward + epsilon)\n        \n        phi_vals = van_leer_limiter(r)\n        \n        # Numerical flux divided by 'a' at interface i+1/2\n        f_half = u + 0.5 * (1.0 - nu) * phi_vals * diff_forward\n        \n        # Conservative update\n        u_vl = u - nu * (f_half - np.roll(f_half, 1))\n\n        # Update using superbee limiter\n        u = u_sb\n        u_p1 = np.roll(u, -1)\n        u_m1 = np.roll(u, 1)\n\n        diff_forward = u_p1 - u\n        diff_backward = u - u_m1\n\n        r = diff_backward / (diff_forward + epsilon)\n        \n        phi_vals = superbee_limiter(r)\n        \n        f_half = u + 0.5 * (1.0 - nu) * phi_vals * diff_forward\n        \n        u_sb = u - nu * (f_half - np.roll(f_half, 1))\n\n    # Calculate total variation TV(u) = sum(|u_{i+1} - u_i|)\n    tv0 = np.sum(np.abs(np.roll(u0, -1) - u0))\n    tv_vl = np.sum(np.abs(np.roll(u_vl, -1) - u_vl))\n    tv_sb = np.sum(np.abs(np.roll(u_sb, -1) - u_sb))\n\n    # Calculate maximum absolute value (for extrema flattening)\n    max_abs_vl = np.max(np.abs(u_vl))\n    max_abs_sb = np.max(np.abs(u_sb))\n\n    return [tv0, tv_vl, tv_sb, max_abs_vl, max_abs_sb]\n\nsolve()\n```"
        }
    ]
}