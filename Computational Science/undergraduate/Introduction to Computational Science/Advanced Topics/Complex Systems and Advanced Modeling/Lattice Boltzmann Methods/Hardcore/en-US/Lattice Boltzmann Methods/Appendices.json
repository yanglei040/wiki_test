{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in developing any simulation is to verify that it correctly reproduces fundamental physical laws. This exercise provides a classic test for a diffusion solver: simulating the spread of a heat pulse and confirming that its variance grows linearly with time, as predicted by the macroscopic heat equation . Successfully completing this practice demonstrates that your implementation of the Lattice Boltzmann Method correctly links the microscopic collision and streaming rules to the emergent physics of passive scalar transport.",
            "id": "2501032",
            "problem": "You are asked to implement a two-dimensional lattice Boltzmann method (LBM) for thermal diffusion of a passive temperature field in a quiescent fluid using lattice units. The computational model shall be based on a single-relaxation-time Bhatnagar–Gross–Krook (BGK) collision operator on a discrete velocity set with five velocities in two dimensions (commonly called D2Q5). The domain is periodic in both directions. The initial condition is a Gaussian temperature pulse centered on the domain. Your goal is to demonstrate numerically that the variance of the temperature field along one Cartesian coordinate grows linearly in time with slope equal to twice the thermal diffusivity, and to quantify the absolute deviation of the measured slope from the theoretical value.\n\nFundamental base to use:\n- Heat equation for a passive scalar in a stationary medium: $\\partial_t T = \\alpha \\nabla^2 T$, where $T$ is temperature and $\\alpha$ is thermal diffusivity.\n- Discrete-velocity kinetic update with BGK collision for a passive scalar: streaming of discrete populations followed by relaxation toward a local equilibrium that depends on $T$ alone in a quiescent fluid.\n- Periodic boundary conditions in both directions.\n\nDiscretization and model requirements:\n- Use a D2Q5 lattice with velocities $\\mathbf{e}_0=(0,0)$, $\\mathbf{e}_1=(1,0)$, $\\mathbf{e}_2=(0,1)$, $\\mathbf{e}_3=(-1,0)$, $\\mathbf{e}_4=(0,-1)$, and the usual weights for an isothermal passive scalar model.\n- The macroscopic temperature is recovered from the populations via $T=\\sum_i g_i$, and the local equilibrium must depend only on $T$ in the absence of flow.\n- The domain is a square grid of size $N_x\\times N_y$, periodic in both directions, with lattice spacing $\\Delta x = 1$ and time step $\\Delta t=1$ (both in lattice units; dimensionless).\n- Initialize with a Gaussian temperature pulse\n$$\nT(x,y,0)=A\\exp\\!\\left(-\\frac{(x-x_0)^2+(y-y_0)^2}{2\\sigma_0^2}\\right),\n$$\ncentered at $(x_0,y_0)$ at the grid center, where $A$ is an arbitrary positive amplitude and $\\sigma_0$ is the initial standard deviation (both in lattice units).\n- Choose the LBM relaxation parameter(s) so that your simulation realizes the specified thermal diffusivity $\\alpha$ in lattice units.\n\nNumerical observable to measure:\n- At each time step $t$, compute the temperature-weighted mean position along $x$,\n$$\n\\mu_x(t)=\\frac{\\sum_{x,y} x\\,T(x,y,t)}{\\sum_{x,y} T(x,y,t)},\n$$\nand the corresponding variance along $x$,\n$$\n\\sigma_x^2(t)=\\frac{\\sum_{x,y} \\left(x-\\mu_x(t)\\right)^2\\,T(x,y,t)}{\\sum_{x,y} T(x,y,t)}.\n$$\n- Estimate the slope $s_{\\text{meas}}$ by ordinary least squares from the linear regression of $\\sigma_x^2(t)$ versus $t$ over the whole simulated time window (in lattice units). The theoretical prediction is $s_{\\text{theory}}=2\\alpha$. For each test, report the absolute error $|s_{\\text{meas}}-2\\alpha|$.\n\nPhysical and numerical units:\n- All quantities are in lattice units (dimensionless). Report slopes and errors in lattice-variance per lattice-time-step.\n\nGrid, runtime, and initial condition specifications:\n- Use $N_x=N_y=81$, $\\Delta x=\\Delta t=1$, a periodic domain, and place the Gaussian center at the grid center $(x_0,y_0)=\\left(\\frac{N_x-1}{2},\\frac{N_y-1}{2}\\right)$. Use amplitude $A=1$.\n- Use the local equilibrium consistent with a quiescent fluid (no advection).\n\nTest suite:\nRun the following three simulations and compute the requested error for each case:\n1. Case 1 (happy path): $\\alpha=0.10$, $\\sigma_0=3.0$, $N_t=500$ time steps.\n2. Case 2 (small diffusivity near the relaxation stability bound): $\\alpha=0.02$, $\\sigma_0=5.0$, $N_t=500$ time steps.\n3. Case 3 (larger diffusivity within stability limits): $\\alpha=0.15$, $\\sigma_0=4.0$, $N_t=500$ time steps.\n\nFinal output format:\n- Your program should produce a single line of output containing the three absolute errors as a comma-separated list enclosed in square brackets, in the order of the cases above. For example, the printed line must look like\n\"[e1,e2,e3]\"\nwhere each $e_k$ is a floating-point number in lattice-variance per lattice-time-step (dimensionless).",
            "solution": "The problem statement has been subjected to rigorous validation and is found to be scientifically sound, well-posed, and objective. It poses a standard verification test for a numerical method, providing all necessary physical and numerical parameters. We will proceed with the derivation and implementation of the solution.\n\nThe problem requires a numerical simulation of the two-dimensional heat equation for a passive scalar $T$ in a stationary medium, given by\n$$\n\\partial_t T = \\alpha \\nabla^2 T\n$$\nwhere $\\alpha$ is the thermal diffusivity. We will employ the lattice Boltzmann method (LBM) with a single-relaxation-time (BGK) collision operator.\n\nThe LBM models the evolution of a set of particle distribution functions, $g_i(\\mathbf{x}, t)$, on a discrete lattice. Each function $g_i$ represents the density of particles moving with a discrete velocity $\\mathbf{e}_i$. The evolution is governed by the discrete-velocity Boltzmann equation:\n$$\ng_i(\\mathbf{x}+\\mathbf{e}_i\\Delta t, t+\\Delta t) - g_i(\\mathbf{x}, t) = \\Omega_i(g)\n$$\nwhere $\\Omega_i$ is the collision operator and we use lattice units where the time step $\\Delta t = 1$ and lattice spacing $\\Delta x = 1$. For the BGK model, the collision operator describes relaxation towards a local equilibrium distribution $g_i^{eq}$:\n$$\n\\Omega_i(g) = -\\frac{1}{\\tau} \\left( g_i(\\mathbf{x}, t) - g_i^{eq}(\\mathbf{x}, t) \\right)\n$$\nwhere $\\tau$ is the dimensionless relaxation time.\n\nThe LBM algorithm consists of two steps executed at each time increment:\n1.  **Collision:** The post-collision distributions $g_i^*$ are computed at each lattice site $\\mathbf{x}$.\n    $$\n    g_i^*(\\mathbf{x}, t) = g_i(\\mathbf{x}, t) - \\frac{1}{\\tau} \\left( g_i(\\mathbf{x}, t) - g_i^{eq}(\\mathbf{x}, t) \\right)\n    $$\n2.  **Streaming:** The post-collision distributions are streamed to their neighboring lattice sites according to their velocities.\n    $$\n    g_i(\\mathbf{x}+\\mathbf{e}_i, t+1) = g_i^*(\\mathbf{x}, t)\n    $$\n\nFor this problem, we use the D2Q5 lattice, which has five discrete velocities in two dimensions:\n$\\mathbf{e}_0=(0,0)$, $\\mathbf{e}_1=(1,0)$, $\\mathbf{e}_2=(0,1)$, $\\mathbf{e}_3=(-1,0)$, and $\\mathbf{e}_4=(0,-1)$.\n\nThe macroscopic temperature $T$ is recovered from the sum of the distributions:\n$$\nT(\\mathbf{x}, t) = \\sum_{i=0}^{4} g_i(\\mathbf{x}, t)\n$$\nFor a quiescent fluid (zero velocity), the local equilibrium distribution $g_i^{eq}$ for a passive scalar depends only on the local temperature $T$:\n$$\ng_i^{eq} = w_i T\n$$\nwhere $w_i$ are a set of weights corresponding to the discrete velocities. For the D2Q5 model, the standard weights that ensure isotropy of the resulting diffusion equation are $w_0 = 1/3$ and $w_1 = w_2 = w_3 = w_4 = 1/6$. These weights satisfy $\\sum_i w_i = 1$ and $\\sum_i w_i e_{i\\alpha} e_{i\\beta} = c_s^2 \\delta_{\\alpha\\beta}$, where $c_s^2 = 1/3$ is the square of the lattice speed of sound.\n\nThrough a Chapman-Enskog multiscale expansion, one can demonstrate that this LBM scheme recovers the macroscopic heat equation with a thermal diffusivity $\\alpha$ given by:\n$$\n\\alpha = c_s^2 \\left(\\tau - \\frac{1}{2}\\right) = \\frac{1}{3} \\left(\\tau - \\frac{1}{2}\\right)\n$$\nFrom this relation, we determine the required relaxation time $\\tau$ for a given diffusivity $\\alpha$:\n$$\n\\tau = 3\\alpha + \\frac{1}{2}\n$$\nFor numerical stability, $\\tau$ must be greater than $0.5$, which implies $\\alpha > 0$. The test cases provided satisfy this condition.\n\nThe simulation domain is a periodic square grid of size $N_x \\times N_y = 81 \\times 81$. The initial condition is a Gaussian temperature profile centered at $(x_0, y_0) = (40, 40)$:\n$$\nT(x,y,0) = A\\exp\\!\\left(-\\frac{(x-x_0)^2+(y-y_0)^2}{2\\sigma_0^2}\\right)\n$$\nwith amplitude $A=1$. The initial distribution functions $g_i(x,y,0)$ are set to their equilibrium values based on this initial temperature field: $g_i(x,y,0) = w_i T(x,y,0)$.\n\nAt each time step $t$, from $t=0$ to $t=N_t$, we compute the variance of the temperature distribution along the $x$-coordinate, $\\sigma_x^2(t)$. This is defined as:\n$$\n\\sigma_x^2(t) = \\frac{\\sum_{x,y} \\left(x-\\mu_x(t)\\right)^2 T(x,y,t)}{\\sum_{x,y} T(x,y,t)}\n$$\nwhere $\\mu_x(t)$ is the mean $x$-position. Due to the symmetry of the initial condition and the periodic domain, $\\mu_x(t)$ will remain constant at $x_0$.\n\nThe analytical solution to the continuous heat equation for an initial Gaussian profile shows that the variance grows linearly with time: $\\sigma_x^2(t) = \\sigma_x^2(0) + 2\\alpha t$. The objective is to verify this relationship numerically. We will perform an ordinary least squares (OLS) linear regression on the computed data points $(\\sigma_x^2(t), t)$ for $t \\in [0, N_t]$ to find the measured slope, $s_{\\text{meas}}$. The theoretical slope is $s_{\\text{theory}} = 2\\alpha$. Finally, we report the absolute error, $|s_{\\text{meas}} - s_{\\text{theory}}|$, for each specified test case.\n\nThe implementation will utilize `numpy` for efficient array operations. The streaming step with periodic boundary conditions is naturally implemented using the `numpy.roll` function. The OLS regression will be performed using `scipy.stats.linregress`. The entire procedure is encapsulated in a function that iterates through the provided test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Implements a D2Q5 LBM simulation for thermal diffusion and validates\n    the linear growth of variance against theory.\n    \"\"\"\n    test_cases = [\n        # (alpha, sigma_0, N_t)\n        (0.10, 3.0, 500),\n        (0.02, 5.0, 500),\n        (0.15, 4.0, 500),\n    ]\n\n    results = []\n    for alpha, sigma_0, N_t in test_cases:\n        # 1. Setup and Initialization\n        Nx, Ny = 81, 81\n        A = 1.0\n\n        # D2Q5 Lattice Parameters\n        # e[i, 0] is x-component, e[i, 1] is y-component\n        e = np.array([[0, 0], [1, 0], [0, 1], [-1, 0], [0, -1]], dtype=int)\n        \n        # Standard weights for D2Q5 thermal model\n        w = np.array([1/3, 1/6, 1/6, 1/6, 1/6])\n\n        # Relation between diffusivity and relaxation time\n        # alpha = c_s^2 * (tau - 0.5) with c_s^2 = 1/3\n        tau = 3.0 * alpha + 0.5\n\n        # Create grid and initial temperature field\n        x = np.arange(Nx)\n        y = np.arange(Ny)\n        X, Y = np.meshgrid(x, y)\n        x0, y0 = (Nx - 1) / 2.0, (Ny - 1) / 2.0\n        \n        T_initial = A * np.exp(-((X - x0)**2 + (Y - y0)**2) / (2.0 * sigma_0**2))\n\n        # Initialize distribution functions at equilibrium\n        # g has shape (5, Ny, Nx)\n        g = w[:, np.newaxis, np.newaxis] * T_initial\n\n        # Arrays to store measurements\n        time_points = np.arange(N_t + 1)\n        variances_x = np.zeros(N_t + 1)\n\n        # 2. Main LBM Simulation Loop\n        for t in range(N_t + 1):\n            # a. Measurement\n            # Macroscopic temperature at current time t\n            T = np.sum(g, axis=0)\n\n            total_T = np.sum(T)\n            # Due to symmetry, mean should be constant. Recalculating for robustness.\n            mu_x = np.sum(X * T) / total_T\n            variances_x[t] = np.sum(((X - mu_x)**2) * T) / total_T\n            \n            # Stop after the last measurement is taken at t = N_t\n            if t == N_t:\n                break\n\n            # b. Collision\n            # T is already computed from g\n            g_eq = w[:, np.newaxis, np.newaxis] * T\n            g = g - (1.0 / tau) * (g - g_eq)\n\n            # c. Streaming\n            g_streamed = g.copy()\n            for i in range(1, 5): # Stream mobile populations (i=1 to 4)\n                # np.roll shift is (shift_axis_0, shift_axis_1)\n                # axis_0 is y, axis_1 is x\n                shift_vec = (e[i, 1], e[i, 0]) # (shift_y, shift_x)\n                g_streamed[i, :, :] = np.roll(g[i, :, :], shift=shift_vec, axis=(0, 1))\n            g = g_streamed\n\n        # 3. Analysis\n        # OLS regression of variance vs. time\n        regression = linregress(time_points, variances_x)\n        s_meas = regression.slope\n        s_theory = 2.0 * alpha\n\n        # Calculate absolute error\n        error = abs(s_meas - s_theory)\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond capturing the correct physical behavior, a robust numerical method must also exhibit predictable convergence towards the exact solution as the grid is refined. This practice introduces the essential skill of performing a grid refinement study to measure the method's order of accuracy . By comparing your numerical results against a known analytical solution for a diffusing pulse, you will quantitatively verify the theoretical second-order spatial accuracy of the LBM scheme.",
            "id": "2500947",
            "problem": "A one-dimensional diffusive heat pulse evolves according to the heat equation on a periodic domain. Consider the scalar temperature field $T(x,t)$ on a periodic interval of length $L$, governed by the equation $\\partial_t T = \\alpha \\,\\partial_{xx} T$, where $\\alpha$ is the constant thermal diffusivity. The lattice Boltzmann method (LBM) with the single-relaxation-time Bhatnagar–Gross–Krook (BGK) model in the one-dimensional, three-velocity stencil (D1Q3) will be used to approximate the evolution of this scalar field. The D1Q3 model employs discrete particle velocities $e_i \\in \\{-c, 0, +c\\}$ in physical units, quadrature weights $w_0 = 2/3$ and $w_{\\pm 1} = 1/6$, and a linear equilibrium distribution $f_i^{\\mathrm{eq}} = w_i \\, T$ for the scalar. The lattice sound speed satisfies $c_s^2 = c^2/3$. Under diffusive scaling consistent with the macroscopic heat equation, the thermal diffusivity is related to the lattice parameters by $\\alpha = c_s^2 \\, (\\tau - 1/2)\\,\\Delta t$, where $\\tau$ is the dimensionless relaxation time and $\\Delta t$ is the physical time step. With a uniform grid of $N_x$ nodes and grid spacing $\\Delta x = L/N_x$, streaming in D1Q3 is exact when $c = \\Delta x/\\Delta t$, which implies the coupling $\\Delta t = \\frac{\\Delta x^2}{3\\alpha}\\,(\\tau - 1/2)$ to keep $\\alpha$ fixed as the grid is refined.\n\nInitial condition and exact solution. Let the initial temperature be a periodic Gaussian pulse of amplitude $A$ and width parameter $\\sigma_0$, centered at $x_0 = L/2$. The $2J+1$-image periodic approximation is\n$$\nT(x,0) \\;=\\; A\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2}\\right).\n$$\nBy linear superposition and the fundamental solution of the heat equation, the corresponding periodic exact solution at time $t$ is\n$$\nT_{\\mathrm{exact}}(x,t) \\;=\\; A\\sqrt{\\frac{\\sigma_0^2}{\\sigma_0^2 + 4\\alpha t}} \\;\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2 + 4\\alpha t}\\right).\n$$\nAll quantities are nondimensional, so report any final numerical values as unitless numbers.\n\nDiscretization and error norm. Implement the scalar D1Q3 LBM with BGK collision and exact streaming on a periodic grid. The macroscopic temperature is the zeroth moment $T = \\sum_i f_i$. Initialize the populations by $f_i(x,0) = w_i \\, T(x,0)$. Evolve for $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ time steps to approximate the solution at $t^\\ast = N_t \\,\\Delta t$. Compare the numerical solution $T_{\\mathrm{num}}(x,t^\\ast)$ with the exact solution $T_{\\mathrm{exact}}(x,t^\\ast)$ using the discrete $L^2$ norm\n$$\nE \\;=\\; \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k,t^\\ast) - T_{\\mathrm{exact}}(x_k,t^\\ast)\\right]^2 \\right)^{1/2}.\n$$\n\nObserved orders of accuracy. Perform a grid refinement study with $N_x \\in \\{64,128,256,512\\}$ while keeping $\\alpha$ fixed via the diffusive scaling relation above. For each refinement, compute the error $E$, the grid spacing $\\Delta x$, and the time step $\\Delta t$. Estimate:\n- the observed spatial order $p_x$ as the slope of the least-squares linear fit of $\\log E$ versus $\\log \\Delta x$;\n- the observed temporal order $p_t$ as the slope of the least-squares linear fit of $\\log E$ versus $\\log \\Delta t$.\nBecause $\\Delta t \\propto \\Delta x^2$ under diffusive scaling, both fits must be performed on the same set of refinement data to separately characterize how errors scale with $\\Delta x$ and with $\\Delta t$.\n\nTest suite. Use the following three parameter sets, each with domain length $L=1$, center $x_0=L/2$, and image count $J=6$:\n- Case A (baseline): $\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$.\n- Case B (lower diffusivity): $\\alpha=0.005$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$.\n- Case C (sharper pulse): $\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.03$, $A=1.0$, $T_{\\mathrm{final}}=0.02$.\n\nProgram requirements. Write a complete program that:\n- Implements the D1Q3 scalar LBM described above for each case and for $N_x \\in \\{64,128,256,512\\}$.\n- For each case, computes the arrays $\\{E\\}$, $\\{\\Delta x\\}$, and $\\{\\Delta t\\}$ across refinements, then returns $(p_x, p_t)$ using least-squares fits.\n- Produces as its only output a single line containing the six floating-point values $[p_x^{(A)},p_t^{(A)},p_x^{(B)},p_t^{(B)},p_x^{(C)},p_t^{(C)}]$ in that order, each rounded to three decimal places, formatted as a comma-separated list enclosed in square brackets.\n\nAngle units and physical units. There are no angle quantities, and all variables are nondimensional. No physical units should be reported; all outputs are pure numbers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\").",
            "solution": "The problem statement is subjected to validation and is found to be scientifically sound, well-posed, and self-contained. It presents a standard numerical analysis task involving the application of the lattice Boltzmann method (LBM) to the one-dimensional heat equation. All parameters, equations, and procedures are specified with sufficient clarity and correctness to permit a unique solution. We therefore proceed with the derivation and implementation of the solution.\n\nThe problem requires the numerical solution of the scalar heat diffusion equation,\n$$\n\\partial_t T = \\alpha \\,\\partial_{xx} T\n$$\non a one-dimensional periodic domain of length $L$. The method specified is the D1Q3 lattice Boltzmann model with a Bhatnagar-Gross-Krook (BGK) collision operator.\n\nThe D1Q3 model discretizes velocity space into three directions, $i \\in \\{0, 1, 2\\}$, corresponding to microscopic particle velocities $e_0 = 0$, $e_1 = +c$, and $e_2 = -c$. The evolution of the particle distribution functions, $f_i(x,t)$, is governed by the lattice Boltzmann equation:\n$$\nf_i(x+e_i\\Delta t, t+\\Delta t) - f_i(x,t) = -\\frac{1}{\\tau} (f_i(x,t) - f_i^{\\mathrm{eq}}(x,t))\n$$\nwhere $\\tau$ is the dimensionless relaxation time, and $f_i^{\\mathrm{eq}}$ is the local equilibrium distribution. The left-hand side represents the streaming of particles to adjacent lattice sites, while the right-hand side represents the relaxation towards equilibrium due to collisions.\n\nFor a scalar diffusive process, the equilibrium distribution is a linear function of the macroscopic scalar field, in this case, the temperature $T$. It is given by $f_i^{\\mathrm{eq}} = w_i T$, where $w_i$ are the quadrature weights. For the D1Q3 stencil, these weights are $w_0 = 2/3$ and $w_{1,2} = 1/6$. The macroscopic temperature is recovered as the zeroth moment of the distribution functions:\n$$\nT(x,t) = \\sum_{i=0}^{2} f_i(x,t)\n$$\nIt can be verified that $\\sum_i f_i^{\\mathrm{eq}} = \\sum_i w_i T = T(\\sum_i w_i) = T(2/3 + 1/6 + 1/6) = T$, which ensures local conservation of the scalar quantity $T$ during collision.\n\nThe numerical algorithm proceeds in two steps at each time increment: collision and streaming.\n1.  **Collision Step**: The post-collision distribution functions, $f_i^{\\ast}$, are computed at each grid node $x_k$:\n    $$\n    f_i^{\\ast}(x_k, t) = f_i(x_k, t) - \\frac{1}{\\tau} (f_i(x_k, t) - f_i^{\\mathrm{eq}}(x_k, t))\n    $$\n    First, the macroscopic temperature $T(x_k,t) = \\sum_i f_i(x_k,t)$ is calculated from the current populations. Then, the equilibrium populations $f_i^{\\mathrm{eq}}(x_k,t) = w_i T(x_k,t)$ are determined, and finally the collision update is applied.\n\n2.  **Streaming Step**: The post-collision populations propagate to adjacent nodes according to their velocities. With the lattice speed set to $c = \\Delta x/\\Delta t$, where $\\Delta x$ is the grid spacing and $\\Delta t$ is the time step, particles move exactly from one node to its neighbor in one time step. For a periodic domain, this is implemented as a circular shift:\n    $$\n    f_0(x_k, t+\\Delta t) = f_0^{\\ast}(x_k, t) \\\\\n    f_1(x_k, t+\\Delta t) = f_1^{\\ast}(x_{k-1}, t) \\\\\n    f_2(x_k, t+\\Delta t) = f_2^{\\ast}(x_{k+1}, t)\n    $$\n    The indices $k-1$ and $k+1$ are handled with periodic wrap-around.\n\nThe simulation is initialized at time $t=0$. The initial temperature field $T(x,0)$ is given by a periodic sum of Gaussian functions. The initial particle distributions are set to be in local equilibrium with this field: $f_i(x_k, 0) = f_i^{\\mathrm{eq}}(x_k, 0) = w_i T(x_k, 0)$. The simulation then evolves for $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ time steps. The final numerical temperature profile $T_{\\mathrm{num}}(x_k, t^{\\ast})$ is computed at the actual final time $t^{\\ast} = N_t \\Delta t$.\n\nThe problem specifies a diffusive scaling relationship to keep the physical thermal diffusivity $\\alpha$ constant across grid refinements. The relation is:\n$$\n\\alpha = c_s^2 (\\tau - 1/2) \\Delta t\n$$\nwhere $c_s^2 = c^2/3 = (\\Delta x/\\Delta t)^2/3$ is the square of the lattice sound speed. Substituting $c_s^2$ into the expression for $\\alpha$ and solving for $\\Delta t$ yields the explicit coupling between the time step and grid spacing:\n$$\n\\Delta t = \\frac{\\Delta x^2}{3\\alpha} (\\tau - 1/2)\n$$\nThis relation implies that $\\Delta t \\propto \\Delta x^2$.\n\nA grid refinement study is performed using grid sizes $N_x \\in \\{64, 128, 256, 512\\}$. For each $N_x$, the grid spacing is $\\Delta x=L/N_x$, and the corresponding $\\Delta t$ is calculated. The simulation is run, and the error $E$ is computed using the discrete $L^2$ norm against the provided exact solution evaluated at $t^{\\ast}$:\n$$\nE = \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k, t^{\\ast}) - T_{\\mathrm{exact}}(x_k, t^{\\ast})\\right]^2 \\right)^{1/2}\n$$\nThe order of accuracy is determined from the assumption of an error scaling law $E \\approx C (\\Delta x)^{p_x}$ for some constant $C$ and spatial order $p_x$. Taking the logarithm gives $\\log E \\approx \\log C + p_x \\log \\Delta x$. The spatial order $p_x$ is therefore the slope of the least-squares linear fit of $\\log E$ versus $\\log \\Delta x$. Similarly, since $\\Delta t \\propto \\Delta x^2$, we have $\\log E \\approx \\log C' + p_t \\log \\Delta t$, where $p_t = p_x/2$. The temporal order $p_t$ is the slope of the fit of $\\log E$ versus $\\log \\Delta t$. These two slopes will be computed for each of the three test cases specified. The LBM-BGK scheme for diffusion is expected to be second-order accurate in space, so we anticipate $p_x \\approx 2.0$ and consequently $p_t \\approx 1.0$.\n\nThe implementation proceeds by first defining functions for the initial condition and the exact analytical solution. A main simulation function encapsulates the LBM algorithm for a given set of physical and numerical parameters. This function is called for each refinement level. The resulting errors and grid parameters are collected. Finally, a linear regression is performed on the log-transformed data to extract the observed orders of accuracy, which are then reported.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef setup_exact_solution_function(L, A, sigma0, alpha, J, x0):\n    \"\"\"\n    Creates a function that computes the exact solution for a given time t.\n    \"\"\"\n    def get_exact_solution(x_grid, t):\n        if t == 0:\n            var_term = sigma0**2\n            time_prefactor = A\n        else:\n            var_term = sigma0**2 + 4 * alpha * t\n            time_prefactor = A * np.sqrt(sigma0**2 / var_term)\n\n        if var_term == 0:\n            # Handle the case of a delta function, though not expected here.\n            T_exact = np.zeros_like(x_grid)\n            idx = np.abs(x_grid - x0).argmin()\n            T_exact[idx] = np.inf\n            return T_exact\n\n        T_exact = np.zeros_like(x_grid)\n        for j in range(-J, J + 1):\n            T_exact += np.exp(-((x_grid - x0 + j * L)**2) / var_term)\n        \n        return time_prefactor * T_exact\n\n    return get_exact_solution\n\n\ndef run_lbm_and_get_error(Nx, L, alpha, tau, T_final, A, sigma0, J, x0):\n    \"\"\"\n    Runs a single D1Q3 LBM simulation and computes the L2 error.\n    \"\"\"\n    # Grid and time parameters\n    dx = L / Nx\n    dt = (dx**2 / (3 * alpha)) * (tau - 0.5)\n    Nt = int(round(T_final / dt))\n    t_star = Nt * dt\n    x = np.linspace(0, L, Nx, endpoint=False) + dx / 2.0\n\n    # LBM parameters\n    w = np.array([2./3., 1./6., 1./6.]) # w0, w+, w-\n    omega = 1.0 / tau\n\n    # Initialization\n    exact_solution_func = setup_exact_solution_function(L, A, sigma0, alpha, J, x0)\n    T0 = exact_solution_func(x, 0)\n    \n    # Populations f0, f+, f-\n    f0 = w[0] * T0\n    f1 = w[1] * T0\n    f2 = w[2] * T0\n    \n    # Main time-stepping loop\n    for _ in range(Nt):\n        # Macroscopic temperature\n        T = f0 + f1 + f2\n        \n        # Collision\n        f0_eq = w[0] * T\n        f1_eq = w[1] * T\n        f2_eq = w[2] * T\n        \n        f0 = f0 - omega * (f0 - f0_eq)\n        f1 = f1 - omega * (f1 - f1_eq)\n        f2 = f2 - omega * (f2 - f2_eq)\n        \n        # Streaming\n        f1 = np.roll(f1, 1)  # moves right\n        f2 = np.roll(f2, -1) # moves left\n\n    # Final numerical temperature\n    T_num = f0 + f1 + f2\n    \n    # Exact solution at final time\n    T_exact = exact_solution_func(x, t_star)\n    \n    # L2 Error calculation\n    error = np.sqrt(dx * np.sum((T_num - T_exact)**2))\n    \n    return error, dx, dt\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute orders of accuracy.\n    \"\"\"\n    test_cases = [\n        # Case A (baseline)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case B (lower diffusivity)\n        {\"alpha\": 0.005, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case C (sharper pulse)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.03, \"A\": 1.0, \"T_final\": 0.02},\n    ]\n\n    # Shared parameters\n    L = 1.0\n    x0 = L / 2.0\n    J = 6\n    Nx_refinements = [64, 128, 256, 512]\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        errors = []\n        dxs = []\n        dts = []\n        \n        for Nx in Nx_refinements:\n            error, dx, dt = run_lbm_and_get_error(Nx, L, **case_params, J=J, x0=x0)\n            errors.append(error)\n            dxs.append(dx)\n            dts.append(dt)\n        \n        # Log-transform data for linear regression\n        log_errors = np.log(np.array(errors))\n        log_dxs = np.log(np.array(dxs))\n        log_dts = np.log(np.array(dts))\n        \n        # Perform linear regression to find slopes (orders of accuracy)\n        px_res = linregress(log_dxs, log_errors)\n        pt_res = linregress(log_dts, log_errors)\n        \n        px = px_res.slope\n        pt = pt_res.slope\n        \n        all_results.extend([px, pt])\n\n    # Format the final output string\n    # [px_A, pt_A, px_B, pt_B, px_C, pt_C] rounded to 3 decimal places\n    output_str = f\"[{','.join([f'{r:.3f}' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "One of the great strengths of the Lattice Boltzmann Method is its flexibility in modeling complex fluid physics beyond the ideal gas law. This advanced practice challenges you to modify the core of the LBM—the equilibrium distribution function—to simulate a fluid governed by a non-ideal van der Waals equation of state . This exercise moves from applying standard models to deriving and implementing custom LBM formulations, highlighting how the method's kinetic theory foundations allow for powerful and elegant extensions to complex systems.",
            "id": "2407099",
            "problem": "You are to construct a polynomial equilibrium distribution for the Lattice Boltzmann Method (LBM) on the two-dimensional nine-velocity lattice (D2Q9) that reproduces a prescribed non-ideal equation of state at second-order accuracy in the flow velocity. Work in lattice units so that all quantities are dimensionless, and assume the standard D2Q9 lattice with squared isothermal lattice sound speed equal to $c_s^2 = 1/3$. Your task is to proceed from the method-of-moments viewpoint: impose that the zeroth, first, and second velocity moments of the equilibrium distribution recover the density, momentum, and the non-ideal pressure tensor of a van der Waals fluid, respectively.\n\nFundamental base and constraints to use:\n- The D2Q9 discrete velocity set is given by the nine vectors $c_i \\in \\mathbb{R}^2$ for $i \\in \\{0,\\dots,8\\}$: $(0,0)$, $(1,0)$, $(0,1)$, $(-1,0)$, $(0,-1)$, $(1,1)$, $(-1,1)$, $(-1,-1)$, $(1,-1)$. The corresponding weights are $w_0 = 4/9$, $w_{1\\text{ to }4} = 1/9$, $w_{5\\text{ to }8} = 1/36$.\n- Let $\\rho$ be the density and $u \\in \\mathbb{R}^2$ be the macroscopic velocity. The equilibrium distribution $\\{ f_i^{eq} \\}_{i=0}^8$ must satisfy the moment constraints\n  1) $\\sum_{i=0}^8 f_i^{eq} = \\rho$,\n  2) $\\sum_{i=0}^8 f_i^{eq} c_i = \\rho u$,\n  3) $\\sum_{i=0}^8 f_i^{eq} c_i c_i = p(\\rho,T)\\, I + \\rho\\, u u$,\n  where $I$ is the identity tensor in two dimensions and products like $c_i c_i$ and $u u$ denote outer products.\n- The van der Waals equation of state is $p(\\rho,T) = \\dfrac{\\rho\\, R\\, T}{1 - b \\rho} - a \\rho^2$, with parameters $a > 0$, $b > 0$, and thermodynamic temperature $T > 0$. In this problem take the gas constant $R = 1$ in lattice units.\n- Use the standard isotropy identities of D2Q9 through fourth-order to construct a second-order polynomial ansatz in $u$ for $f_i^{eq}$ whose coefficients depend on $\\rho$ and $p(\\rho,T)$ and enforce the moment constraints above. Do not introduce external forcing; achieve the non-ideal pressure strictly by modifying the equilibrium moments.\n\nAlgorithmic requirements:\n- Implement the D2Q9 equilibrium you derive in a program that, for each test case, computes the residuals that quantify whether your $\\{ f_i^{eq} \\}$ meets the three moment constraints:\n  - Mass residual: $r_0 = \\left(\\sum_{i=0}^8 f_i^{eq}\\right) - \\rho$.\n  - Momentum residual norm: $r_1 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i\\right) - \\rho u \\right\\|_2$.\n  - Pressure-tensor residual Frobenius norm: $r_2 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i c_i\\right) - \\left(p(\\rho,T) I + \\rho u u\\right) \\right\\|_F$.\n- For numerical reporting, for each test case output the triple $[r_0, r_1, r_2]$ rounded to $12$ decimal places.\n\nTest suite:\n- Use the following five test cases, each defined by $(\\rho, u_x, u_y, a, b, T)$:\n  1) $(0.8, 0.12, -0.07, 0.5, 0.3, 0.9)$,\n  2) $(0.01, 0.0001, -0.0002, 0.2, 0.1, 1.0)$,\n  3) $(3.2, 0.0, 0.0, 0.1, 0.3, 1.2)$,\n  4) $(1.0, 0.3, 0.4, 1.0, 0.1, 0.6)$,\n  5) $(0.9, 0.0, 0.0, 0.0, 0.4, 1.5)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the list of the five result triples as a comma-separated list enclosed in square brackets, with no additional spaces. For example, your output must look like\n  \"[[r00,r01,r02],[r10,r11,r12],[r20,r21,r22],[r30,r31,r32],[r40,r41,r42]]\"\nwhere each $r_{jk}$ is a decimal number rounded to $12$ decimal places as specified above.",
            "solution": "The problem requires the construction of a second-order polynomial equilibrium distribution, $f_i^{eq}$, for the D2Q9 lattice that correctly recovers the macroscopic density $\\rho$, momentum $\\rho u$, and the non-ideal momentum flux tensor $\\Pi_{\\alpha\\beta} = p(\\rho,T)\\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta$ for a van der Waals fluid. The pressure $p(\\rho,T)$ is given by $p(\\rho,T) = \\dfrac{\\rho T}{1 - b \\rho} - a \\rho^2$ in lattice units where the gas constant $R=1$. The derivation will proceed via the method of moments.\n\nThe standard second-order polynomial equilibrium distribution for an ideal gas in the Lattice Boltzmann Method (LBM) is given by:\n$$\nf_i^{eq, ideal} = w_i \\rho \\left( 1 + \\frac{c_{i\\alpha}u_\\alpha}{c_s^2} + \\frac{(c_{i\\alpha}c_{i\\beta}-c_s^2\\delta_{\\alpha\\beta})u_\\alpha u_\\beta}{2c_s^4} \\right)\n$$\nHere, $w_i$ are the lattice weights, $c_{i\\alpha}$ are the components of the discrete velocities, $u_\\alpha$ are the components of the macroscopic fluid velocity, and $c_s^2 = 1/3$ is the squared lattice speed of sound. Greek indices $\\alpha, \\beta$ imply summation over the spatial dimensions $\\{x, y\\}$.\n\nThe moments of this distribution are:\n1.  $\\sum_{i=0}^8 f_i^{eq, ideal} = \\rho$\n2.  $\\sum_{i=0}^8 f_i^{eq, ideal} c_{i\\alpha} = \\rho u_\\alpha$\n3.  $\\sum_{i=0}^8 f_i^{eq, ideal} c_{i\\alpha}c_{i\\beta} = \\rho c_s^2 \\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta$\n\nThis recovers the momentum flux tensor for an ideal gas with pressure $p_{ideal} = \\rho c_s^2$. The problem demands the recovery of a non-ideal pressure $p(\\rho, T)$. The target momentum flux tensor is $\\Pi_{\\alpha\\beta} = p(\\rho,T)\\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta$.\n\nTo achieve this, we must modify the equilibrium distribution by adding a correction term, $\\Delta f_i^{eq}$, such that the total distribution $f_i^{eq} = f_i^{eq, ideal} + \\Delta f_i^{eq}$ satisfies the required moment constraints. The correction term must not alter the zeroth and first moments, and must adjust the second moment appropriately. The constraints on $\\Delta f_i^{eq}$ are therefore:\n1.  $\\sum_{i=0}^8 \\Delta f_i^{eq} = 0$\n2.  $\\sum_{i=0}^8 \\Delta f_i^{eq} c_{i\\alpha} = 0$\n3.  $\\sum_{i=0}^8 \\Delta f_i^{eq} c_{i\\alpha} c_{i\\beta} = \\Pi_{\\alpha\\beta} - (\\rho c_s^2 \\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta) = (p(\\rho,T) - \\rho c_s^2)\\delta_{\\alpha\\beta}$\n\nSince the required correction to the momentum flux tensor is independent of velocity $u$, a suitable ansatz for $\\Delta f_i^{eq}$ should also be independent of $u$ and constructed from low-order polynomials of the discrete velocities $c_i$. We propose an ansatz of the form:\n$$\n\\Delta f_i^{eq} = w_i K (c_i^2 - C)\n$$\nwhere $c_i^2 = c_{i\\alpha}c_{i\\alpha}$ is the squared magnitude of the discrete velocity vector $c_i$. The coefficients $K$ and $C$ are scalars that depend on $\\rho$ and $T$ but not on $i$.\n\nWe enforce the constraints on this ansatz using the D2Q9 isotropy relations: $\\sum_i w_i = 1$, $\\sum_i w_i c_{i\\alpha}=0$, $\\sum_i w_i c_{i\\alpha}c_{i\\beta} = c_s^2 \\delta_{\\alpha\\beta}$, and $\\sum_i w_i c_{i\\alpha}c_{i\\beta}c_{i\\gamma}c_{i\\delta} = c_s^4 (\\delta_{\\alpha\\beta}\\delta_{\\gamma\\delta} + \\delta_{\\alpha\\gamma}\\delta_{\\beta\\delta} + \\delta_{\\alpha\\delta}\\delta_{\\beta\\gamma})$. For $D=2$ dimensions, the trace of the second-order identity gives $\\sum_i w_i c_i^2 = \\sum_i w_i c_{i\\alpha}c_{i\\alpha} = \\sum_{\\alpha} c_s^2 \\delta_{\\alpha\\alpha} = D c_s^2 = 2 c_s^2$.\n\n1.  **Zeroth moment of $\\Delta f_i^{eq}$**:\n    $\\sum_i \\Delta f_i^{eq} = \\sum_i w_i K (c_i^2 - C) = K (\\sum_i w_i c_i^2 - C \\sum_i w_i) = K(2c_s^2 - C)$.\n    For this to be zero for a non-trivial $K$, we must have $C = 2c_s^2$.\n\n2.  **First moment of $\\Delta f_i^{eq}$**:\n    $\\sum_i \\Delta f_i^{eq} c_{i\\alpha} = \\sum_i w_i K (c_i^2 - 2c_s^2) c_{i\\alpha} = K (\\sum_i w_i c_i^2 c_{i\\alpha} - 2c_s^2 \\sum_i w_i c_{i\\alpha})$.\n    Both terms involve third-rank tensors which are zero due to lattice symmetry. Thus, this constraint is automatically satisfied.\n\n3.  **Second moment of $\\Delta f_i^{eq}$**:\n    $\\sum_i \\Delta f_i^{eq} c_{i\\alpha}c_{i\\beta} = K (\\sum_i w_i c_i^2 c_{i\\alpha}c_{i\\beta} - 2c_s^2 \\sum_i w_i c_{i\\alpha}c_{i\\beta})$.\n    The fourth-rank moment tensor is $\\sum_i w_i c_i^2 c_{i\\alpha}c_{i\\beta} = \\sum_{i, \\gamma} w_i c_{i\\gamma}c_{i\\gamma}c_{i\\alpha}c_{i\\beta} = c_s^4 \\sum_{\\gamma}(\\delta_{\\gamma\\gamma}\\delta_{\\alpha\\beta} + \\delta_{\\gamma\\alpha}\\delta_{\\gamma\\beta} + \\delta_{\\gamma\\beta}\\delta_{\\gamma\\alpha})$. This evaluates to $c_s^4 (D\\delta_{\\alpha\\beta} + \\delta_{\\alpha\\beta} + \\delta_{\\alpha\\beta}) = (D+2)c_s^4\\delta_{\\alpha\\beta} = 4c_s^4\\delta_{\\alpha\\beta}$ for $D=2$.\n    The second moment becomes: $K(4c_s^4\\delta_{\\alpha\\beta} - 2c_s^2(c_s^2\\delta_{\\alpha\\beta})) = 2Kc_s^4\\delta_{\\alpha\\beta}$.\n    Equating this with the target correction $(p(\\rho,T) - \\rho c_s^2)\\delta_{\\alpha\\beta}$ yields:\n    $2Kc_s^4 = p(\\rho,T) - \\rho c_s^2 \\implies K = \\frac{p(\\rho,T) - \\rho c_s^2}{2c_s^4}$.\n\nThe correction term is therefore:\n$$\n\\Delta f_i^{eq} = w_i \\frac{p(\\rho,T) - \\rho c_s^2}{2c_s^4} (c_i^2 - 2c_s^2)\n$$\nThe complete equilibrium distribution that satisfies all three moment constraints is:\n$$\nf_i^{eq} = w_i \\left( \\rho \\left( 1 + \\frac{c_{i\\alpha}u_\\alpha}{c_s^2} + \\frac{(c_{i\\alpha}c_{i\\beta}-c_s^2\\delta_{\\alpha\\beta})u_\\alpha u_\\beta}{2c_s^4}\\right) + \\frac{p(\\rho,T)-\\rho c_s^2}{2 c_s^4}(c_i^2-2c_s^2) \\right)\n$$\nSubstituting $c_s^2 = 1/3$:\n$$\nf_i^{eq} = w_i \\left( \\rho \\left( 1 + 3(c_i \\cdot u) + \\frac{9}{2}(c_i \\cdot u)^2 - \\frac{3}{2}u^2 \\right) + \\frac{9}{2}(p(\\rho,T)-\\rho/3)(c_i^2-2/3) \\right)\n$$\nwhere $c_i \\cdot u = c_{i\\alpha} u_\\alpha$, $u^2 = u_\\alpha u_\\alpha$, and $c_i^2 = c_{i\\alpha} c_{i\\alpha}$. This expression is a polynomial of second order in the velocity $u$ and satisfies all specified conditions.\n\nThe implementation calculates this $f_i^{eq}$ for each test case and computes the residuals $r_0, r_1, r_2$ by comparing the numerically computed moments of $\\{f_i^{eq}\\}$ against their exact target values. Due to the analytical correctness of the derivation, these residuals should be zero within machine floating-point precision.\n- Mass residual: $r_0 = \\left(\\sum_{i=0}^8 f_i^{eq}\\right) - \\rho$\n- Momentum residual: $r_1 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i\\right) - \\rho u \\right\\|_2$\n- Stress residual: $r_2 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i c_i\\right) - \\left(p(\\rho,T) I + \\rho u u\\right) \\right\\|_F$\nThe norms are Euclidean for vectors and Frobenius for tensors.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and verifies a D2Q9 LBM equilibrium distribution for a van der Waals fluid.\n    \"\"\"\n    # Define the D2Q9 lattice constants.\n    c = np.array([\n        [0, 0], [1, 0], [0, 1], [-1, 0], [0, -1],\n        [1, 1], [-1, 1], [-1, -1], [1, -1]\n    ], dtype=np.float64)\n    w = np.array([\n        4/9, 1/9, 1/9, 1/9, 1/9,\n        1/36, 1/36, 1/36, 1/36\n    ], dtype=np.float64)\n    cs2 = 1/3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.8, 0.12, -0.07, 0.5, 0.3, 0.9),\n        (0.01, 0.0001, -0.0002, 0.2, 0.1, 1.0),\n        (3.2, 0.0, 0.0, 0.1, 0.3, 1.2),\n        (1.0, 0.3, 0.4, 1.0, 0.1, 0.6),\n        (0.9, 0.0, 0.0, 0.0, 0.4, 1.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, ux, uy, a, b, T = case\n        u = np.array([ux, uy], dtype=np.float64)\n        R = 1.0\n\n        # Calculate the van der Waals pressure.\n        p = (rho * R * T) / (1 - b * rho) - a * rho**2\n\n        # Initialize the equilibrium distribution array.\n        feq = np.zeros(9, dtype=np.float64)\n\n        # Calculate the equilibrium distribution for each discrete velocity.\n        for i in range(9):\n            ci_dot_u = np.dot(c[i], u)\n            u_sq = np.dot(u, u)\n            ci_sq = np.dot(c[i], c[i])\n            \n            # The standard second-order ideal gas part:\n            # f_ideal = rho * (1 + (ci_dot_u / cs2) + (ci_dot_u**2 / (2 * cs2**2)) - (u_sq / (2 * cs2)))\n            # The non-ideal pressure correction part:\n            # f_corr = (p - rho * cs2) / (2 * cs2**2) * (ci_sq - 2 * cs2)\n            # feq[i] = w[i] * (f_ideal + f_corr)\n\n            # Combined and simplified expression from the derivation:\n            term1 = rho * (1 + 3 * ci_dot_u + 4.5 * ci_dot_u**2 - 1.5 * u_sq)\n            term2 = 4.5 * (p - rho / 3) * (ci_sq - 2/3)\n            feq[i] = w[i] * (term1 + term2)\n\n        # Numerically compute the moments from the calculated feq.\n        rho_num = np.sum(feq)\n        rho_u_num = np.einsum('i,ia-a', feq, c)\n        Pi_num = np.einsum('i,ia,ib-ab', feq, c, c)\n\n        # Define the target macroscopic quantities.\n        rho_target = rho\n        rho_u_target = rho * u\n        Pi_target = p * np.identity(2) + rho * np.outer(u, u)\n\n        # Calculate the residuals.\n        r0 = rho_num - rho_target\n        r1 = np.linalg.norm(rho_u_num - rho_u_target)\n        r2 = np.linalg.norm(Pi_num - Pi_target) # Frobenius norm is default for matrices\n\n        # Append the rounded results to the list.\n        results.append([round(r0, 12), round(r1, 12), round(r2, 12)])\n\n    # Final print statement in the exact required format.\n    # The string representation is crafted to avoid any spaces.\n    results_str = str(results).replace(\" \", \"\")\n    print(results_str)\n\nsolve()\n```"
        }
    ]
}