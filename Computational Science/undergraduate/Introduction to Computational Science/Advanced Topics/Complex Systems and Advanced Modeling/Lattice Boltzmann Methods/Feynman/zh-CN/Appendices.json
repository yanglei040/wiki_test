{
    "hands_on_practices": [
        {
            "introduction": "模拟热扩散是输运现象建模中的一个基本应用。本实践旨在展示格子玻尔兹曼方法（LBM）如何通过其简单的碰撞和迁移规则，准确地再现宏观热方程所描述的物理过程。通过实现一个D2Q5模型来模拟高斯热脉冲的扩散，你将获得核心LBM算法的实践经验，并验证模型弛豫参数与物理热扩散系数之间的直接关系 。",
            "id": "2501032",
            "problem": "题目要求您使用晶格单位，实现一个二维晶格玻尔兹曼方法（LBM），用于模拟静止流体中被动温度场的热扩散。该计算模型应基于在二维五速离散速度集（通常称为D2Q5）上的单弛豫时间Bhatnagar–Gross–Krook（BGK）碰撞算子。区域在两个方向上均是周期性的。初始条件是位于区域中心的高斯温度脉冲。您的目标是数值上证明温度场沿一个笛卡尔坐标的方差随时间线性增长，其斜率等于热扩散系数的两倍，并量化测量斜率与理论值之间的绝对偏差。\n\n使用的基本原理：\n- 静止介质中被动标量的热方程：$\\partial_t T = \\alpha \\nabla^2 T$，其中 $T$ 是温度，$\\alpha$ 是热扩散系数。\n- 被动标量的带有BGK碰撞的离散速度动力学更新：离散分布的迁移，随后向局部平衡态弛豫，在静止流体中，该平衡态仅取决于 $T$。\n- 两个方向上均采用周期性边界条件。\n\n离散化与模型要求：\n- 使用D2Q5晶格，其速度为 $\\mathbf{e}_0=(0,0)$, $\\mathbf{e}_1=(1,0)$, $\\mathbf{e}_2=(0,1)$, $\\mathbf{e}_3=(-1,0)$, $\\mathbf{e}_4=(0,-1)$，并使用等温被动标量模型的常用权重。\n- 宏观温度通过分布函数恢复：$T=\\sum_i g_i$，且在没有流动的情况下，局部平衡态必须仅依赖于 $T$。\n- 区域是一个大小为 $N_x\\times N_y$ 的方形网格，在两个方向上都是周期性的，晶格间距 $\\Delta x = 1$，时间步长 $\\Delta t=1$（均为晶格单位；无量纲）。\n- 使用高斯温度脉冲进行初始化\n$$\nT(x,y,0)=A\\exp\\!\\left(-\\frac{(x-x_0)^2+(y-y_0)^2}{2\\sigma_0^2}\\right),\n$$\n中心位于网格中心 $(x_0,y_0)$，其中 $A$ 是任意正振幅，$\\sigma_0$ 是初始标准差（均为晶格单位）。\n- 选择LBM弛豫参数，使您的模拟能够实现指定的晶格单位下的热扩散系数 $\\alpha$。\n\n需测量的数值可观测量：\n- 在每个时间步 $t$，计算沿 $x$ 轴的温度加权平均位置，\n$$\n\\mu_x(t)=\\frac{\\sum_{x,y} x\\,T(x,y,t)}{\\sum_{x,y} T(x,y,t)},\n$$\n以及对应的沿 $x$ 轴的方差，\n$$\n\\sigma_x^2(t)=\\frac{\\sum_{x,y} \\left(x-\\mu_x(t)\\right)^2\\,T(x,y,t)}{\\sum_{x,y} T(x,y,t)}.\n$$\n- 通过对整个模拟时间窗口（以晶格单位计）内 $\\sigma_x^2(t)$ 与 $t$ 的线性回归，使用普通最小二乘法估计斜率 $s_{\\text{meas}}$。理论预测值为 $s_{\\text{theory}}=2\\alpha$。对于每个测试，报告绝对误差 $|s_{\\text{meas}}-2\\alpha|$。\n\n物理和数值单位：\n- 所有量均以晶格单位表示（无量纲）。报告的斜率和误差单位为“晶格方差/晶格时间步”。\n\n网格、运行时间和初始条件规范：\n- 使用 $N_x=N_y=81$, $\\Delta x=\\Delta t=1$，周期性区域，并将高斯中心置于网格中心 $(x_0,y_0)=\\left(\\frac{N_x-1}{2},\\frac{N_y-1}{2}\\right)$。使用振幅 $A=1$。\n- 使用与静止流体（无对流）一致的局部平衡态。\n\n测试套件：\n运行以下三个模拟，并计算每种情况下的要求误差：\n1. 情况1（理想情况）：$\\alpha=0.10$，$\\sigma_0=3.0$，时间步数 $N_t=500$。\n2. 情况2（靠近弛豫稳定性边界的小扩散系数）：$\\alpha=0.02$，$\\sigma_0=5.0$，时间步数 $N_t=500$。\n3. 情况3（在稳定性限制内的较大扩散系数）：$\\alpha=0.15$，$\\sigma_0=4.0$，时间步数 $N_t=500$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个绝对误差，以逗号分隔的列表形式并用方括号括起来，顺序与上述情况一致。例如，打印的行必须如下所示\n\"[e1,e2,e3]\"\n其中每个 $e_k$ 是一个以“晶格方差/晶格时间步”（无量纲）为单位的浮点数。",
            "solution": "该问题陈述已经过严格验证，被认为是科学上可靠、适定且客观的。它为一个数值方法提出了一个标准的验证测试，提供了所有必要的物理和数值参数。我们将继续进行解的推导和实现。\n\n该问题要求对静止介质中被动标量 $T$ 的二维热方程进行数值模拟，方程为\n$$\n\\partial_t T = \\alpha \\nabla^2 T\n$$\n其中 $\\alpha$ 是热扩散系数。我们将采用带有单弛豫时间（BGK）碰撞算子的晶格玻尔兹曼方法（LBM）。\n\nLBM在一个离散的晶格上对一组粒子分布函数 $g_i(\\mathbf{x}, t)$ 的演化进行建模。每个函数 $g_i$ 代表以离散速度 $\\mathbf{e}_i$ 运动的粒子密度。其演化由离散速度玻尔兹曼方程控制：\n$$\ng_i(\\mathbf{x}+\\mathbf{e}_i\\Delta t, t+\\Delta t) - g_i(\\mathbf{x}, t) = \\Omega_i(g)\n$$\n其中 $\\Omega_i$ 是碰撞算子，我们使用晶格单位，即时间步长 $\\Delta t = 1$ 和晶格间距 $\\Delta x = 1$。对于BGK模型，碰撞算子描述了向局部平衡分布 $g_i^{eq}$ 的弛豫过程：\n$$\n\\Omega_i(g) = -\\frac{1}{\\tau} \\left( g_i(\\mathbf{x}, t) - g_i^{eq}(\\mathbf{x}, t) \\right)\n$$\n其中 $\\tau$ 是无量纲的弛豫时间。\n\nLBM算法在每个时间增量中包含两个执行步骤：\n1.  **碰撞：** 在每个晶格点 $\\mathbf{x}$ 计算碰撞后的分布函数 $g_i^*$。\n    $$\n    g_i^*(\\mathbf{x}, t) = g_i(\\mathbf{x}, t) - \\frac{1}{\\tau} \\left( g_i(\\mathbf{x}, t) - g_i^{eq}(\\mathbf{x}, t) \\right)\n    $$\n2.  **迁移：** 碰撞后的分布函数根据其速度迁移到相邻的晶格点。\n    $$\n    g_i(\\mathbf{x}+\\mathbf{e}_i, t+1) = g_i^*(\\mathbf{x}, t)\n    $$\n\n对于这个问题，我们使用D2Q5晶格，它在二维空间中有五个离散速度：\n$\\mathbf{e}_0=(0,0)$, $\\mathbf{e}_1=(1,0)$, $\\mathbf{e}_2=(0,1)$, $\\mathbf{e}_3=(-1,0)$, 和 $\\mathbf{e}_4=(0,-1)$。\n\n宏观温度 $T$ 通过分布函数的总和恢复：\n$$\nT(\\mathbf{x}, t) = \\sum_{i=0}^{4} g_i(\\mathbf{x}, t)\n$$\n对于静止流体（零速度），被动标量的局部平衡分布 $g_i^{eq}$ 仅取决于局部温度 $T$：\n$$\ng_i^{eq} = w_i T\n$$\n其中 $w_i$ 是一组与离散速度相对应的权重。对于D2Q5模型，确保最终扩散方程各向同性的标准权重为 $w_0 = 1/3$ 和 $w_1 = w_2 = w_3 = w_4 = 1/6$。这些权重满足 $\\sum_i w_i = 1$ 和 $\\sum_i w_i e_{i\\alpha} e_{i\\beta} = c_s^2 \\delta_{\\alpha\\beta}$，其中 $c_s^2 = 1/3$ 是晶格声速的平方。\n\n通过Chapman-Enskog多尺度展开，可以证明该LBM格式能够恢复宏观热方程，其热扩散系数 $\\alpha$ 由下式给出：\n$$\n\\alpha = c_s^2 \\left(\\tau - \\frac{1}{2}\\right) = \\frac{1}{3} \\left(\\tau - \\frac{1}{2}\\right)\n$$\n根据这个关系，我们可以确定给定扩散系数 $\\alpha$ 所需的弛豫时间 $\\tau$：\n$$\n\\tau = 3\\alpha + \\frac{1}{2}\n$$\n为了数值稳定性，$\\tau$ 必须大于 $0.5$，这意味着 $\\alpha  0$。所提供的测试案例满足此条件。\n\n模拟区域是一个大小为 $N_x \\times N_y = 81 \\times 81$ 的周期性方形网格。初始条件是中心位于 $(x_0, y_0) = (40, 40)$ 的高斯温度分布：\n$$\nT(x,y,0) = A\\exp\\!\\left(-\\frac{(x-x_0)^2+(y-y_0)^2}{2\\sigma_0^2}\\right)\n$$\n振幅 $A=1$。初始分布函数 $g_i(x,y,0)$ 根据此初始温度场设置为其平衡值：$g_i(x,y,0) = w_i T(x,y,0)$。\n\n在从 $t=0$到 $t=N_t$ 的每个时间步 $t$，我们计算温度分布沿 $x$ 坐标的方差 $\\sigma_x^2(t)$。其定义为：\n$$\n\\sigma_x^2(t) = \\frac{\\sum_{x,y} \\left(x-\\mu_x(t)\\right)^2 T(x,y,t)}{\\sum_{x,y} T(x,y,t)}\n$$\n其中 $\\mu_x(t)$ 是平均 $x$ 位置。由于初始条件的对称性和周期性区域，$\\mu_x(t)$ 将保持在 $x_0$ 不变。\n\n对于初始高斯分布，连续热方程的解析解表明方差随时间线性增长：$\\sigma_x^2(t) = \\sigma_x^2(0) + 2\\alpha t$。目标是数值验证这一关系。我们将对计算出的数据点 $(\\sigma_x^2(t), t)$（其中 $t \\in [0, N_t]$）进行普通最小二乘（OLS）线性回归，以找到测量斜率 $s_{\\text{meas}}$。理论斜率为 $s_{\\text{theory}} = 2\\alpha$。最后，我们报告每个指定测试案例的绝对误差 $|s_{\\text{meas}} - s_{\\text{theory}}|$。\n\n实现将利用 `numpy` 进行高效的数组操作。带有周期性边界条件的迁移步骤很自然地可以使用 `numpy.roll` 函数来实现。OLS回归将使用 `scipy.stats.linregress` 执行。整个过程被封装在一个函数中，该函数会遍历所提供的测试案例。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Implements a D2Q5 LBM simulation for thermal diffusion and validates\n    the linear growth of variance against theory.\n    \"\"\"\n    test_cases = [\n        # (alpha, sigma_0, N_t)\n        (0.10, 3.0, 500),\n        (0.02, 5.0, 500),\n        (0.15, 4.0, 500),\n    ]\n\n    results = []\n    for alpha, sigma_0, N_t in test_cases:\n        # 1. Setup and Initialization\n        Nx, Ny = 81, 81\n        A = 1.0\n\n        # D2Q5 Lattice Parameters\n        # e[i, 0] is x-component, e[i, 1] is y-component\n        e = np.array([[0, 0], [1, 0], [0, 1], [-1, 0], [0, -1]], dtype=int)\n        \n        # Standard weights for D2Q5 thermal model\n        w = np.array([1/3, 1/6, 1/6, 1/6, 1/6])\n\n        # Relation between diffusivity and relaxation time\n        # alpha = c_s^2 * (tau - 0.5) with c_s^2 = 1/3\n        tau = 3.0 * alpha + 0.5\n\n        # Create grid and initial temperature field\n        x = np.arange(Nx)\n        y = np.arange(Ny)\n        X, Y = np.meshgrid(x, y)\n        x0, y0 = (Nx - 1) / 2.0, (Ny - 1) / 2.0\n        \n        T_initial = A * np.exp(-((X - x0)**2 + (Y - y0)**2) / (2.0 * sigma_0**2))\n\n        # Initialize distribution functions at equilibrium\n        # g has shape (5, Ny, Nx)\n        g = w[:, np.newaxis, np.newaxis] * T_initial\n\n        # Arrays to store measurements\n        time_points = np.arange(N_t + 1)\n        variances_x = np.zeros(N_t + 1)\n\n        # 2. Main LBM Simulation Loop\n        for t in range(N_t + 1):\n            # a. Measurement\n            # Macroscopic temperature at current time t\n            T = np.sum(g, axis=0)\n\n            total_T = np.sum(T)\n            # Due to symmetry, mean should be constant. Recalculating for robustness.\n            mu_x = np.sum(X * T) / total_T\n            variances_x[t] = np.sum(((X - mu_x)**2) * T) / total_T\n            \n            # Stop after the last measurement is taken at t = N_t\n            if t == N_t:\n                break\n\n            # b. Collision\n            # T is already computed from g\n            g_eq = w[:, np.newaxis, np.newaxis] * T\n            g = g - (1.0 / tau) * (g - g_eq)\n\n            # c. Streaming\n            g_streamed = g.copy()\n            for i in range(1, 5): # Stream mobile populations (i=1 to 4)\n                # np.roll shift is (shift_axis_0, shift_axis_1)\n                # axis_0 is y, axis_1 is x\n                shift_vec = (e[i, 1], e[i, 0]) # (shift_y, shift_x)\n                g_streamed[i, :, :] = np.roll(g[i, :, :], shift=shift_vec, axis=(0, 1))\n            g = g_streamed\n\n        # 3. Analysis\n        # OLS regression of variance vs. time\n        regression = linregress(time_points, variances_x)\n        s_meas = regression.slope\n        s_theory = 2.0 * alpha\n\n        # Calculate absolute error\n        error = abs(s_meas - s_theory)\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算科学中，一项关键任务不仅仅是获得结果，更是要量化其准确性。本练习侧重于数值收敛性和格子玻尔兹曼方法格式的精度阶这一核心概念。你将进行一次网格加密研究，将你的1D模拟结果与已知的精确解进行比较，从而凭经验测量该方法的精度，这是验证任何数值求解器时都需具备的关键技能 。",
            "id": "2500947",
            "problem": "一个一维扩散热脉冲在周期性域上根据热方程演化。考虑一个长度为 $L$ 的周期性区间上的标量温度场 $T(x,t)$，该场由方程 $\\partial_t T = \\alpha \\,\\partial_{xx} T$ 控制，其中 $\\alpha$ 是恒定的热扩散系数。将使用一维三速（D1Q3）格式下的单弛豫时间 Bhatnagar–Gross–Krook (BGK) 模型的格子玻尔兹曼方法 (LBM) 来近似该标量场的演化。D1Q3 模型采用物理单位下的离散粒子速度 $e_i \\in \\{-c, 0, +c\\}$，求积权重 $w_0 = 2/3$ 和 $w_{\\pm 1} = 1/6$，以及标量的线性平衡分布函数 $f_i^{\\mathrm{eq}} = w_i \\, T$。格子声速满足 $c_s^2 = c^2/3$。在与宏观热方程一致的扩散标度下，热扩散系数与格子参数的关系为 $\\alpha = c_s^2 \\, (\\tau - 1/2)\\,\\Delta t$，其中 $\\tau$ 是无量纲弛豫时间，$\\Delta t$ 是物理时间步长。对于具有 $N_x$ 个节点和网格间距 $\\Delta x = L/N_x$ 的均匀网格，当 $c = \\Delta x/\\Delta t$ 时，D1Q3 中的迁移是精确的，这意味着在网格细化时，为保持 $\\alpha$ 不变，存在耦合关系 $\\Delta t = \\frac{\\Delta x^2}{3\\alpha}\\,(\\tau - 1/2)$。\n\n初始条件与精确解。设初始温度是一个周期性高斯脉冲，振幅为 $A$，宽度参数为 $\\sigma_0$，中心位于 $x_0 = L/2$。其 $2J+1$ 镜像周期近似为\n$$\nT(x,0) \\;=\\; A\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2}\\right).\n$$\n根据线性叠加原理和热方程的基本解，在时间 $t$ 对应的周期性精确解为\n$$\nT_{\\mathrm{exact}}(x,t) \\;=\\; A\\sqrt{\\frac{\\sigma_0^2}{\\sigma_0^2 + 4\\alpha t}} \\;\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2 + 4\\alpha t}\\right).\n$$\n所有量均为无量纲，因此报告任何最终数值时都应作为无单位的数字。\n\n离散化与误差范数。在周期性网格上实现带有 BGK 碰撞和精确迁移的标量 D1Q3 LBM。宏观温度是零阶矩 $T = \\sum_i f_i$。通过 $f_i(x,0) = w_i \\, T(x,0)$ 初始化粒子布居数。演化 $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ 个时间步，以近似在 $t^\\ast = N_t \\,\\Delta t$ 时的解。使用离散 $L^2$ 范数比较数值解 $T_{\\mathrm{num}}(x,t^\\ast)$ 与精确解 $T_{\\mathrm{exact}}(x,t^\\ast)$\n$$\nE \\;=\\; \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k,t^\\ast) - T_{\\mathrm{exact}}(x_k,t^\\ast)\\right]^2 \\right)^{1/2}.\n$$\n\n观测到的精度阶。使用 $N_x \\in \\{64,128,256,512\\}$ 进行网格细化研究，同时通过上述扩散标度关系保持 $\\alpha$ 不变。对于每次细化，计算误差 $E$、网格间距 $\\Delta x$ 和时间步长 $\\Delta t$。估计：\n- 观测到的空间阶 $p_x$ 作为 $\\log E$ 对 $\\log \\Delta x$ 的最小二乘线性拟合的斜率；\n- 观测到的时间阶 $p_t$ 作为 $\\log E$ 对 $\\log \\Delta t$ 的最小二乘线性拟合的斜率。\n因为在扩散标度下 $\\Delta t \\propto \\Delta x^2$，所以两个拟合必须在同一组细化数据上进行，以分别表征误差如何随 $\\Delta x$ 和 $\\Delta t$ 变化。\n\n测试套件。使用以下三组参数集，每组的域长度 $L=1$，中心 $x_0=L/2$，镜像数 $J=6$：\n- 情况 A (基准): $\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$。\n- 情况 B (较低扩散系数): $\\alpha=0.005$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$。\n- 情况 C (更尖锐的脉冲): $\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.03$, $A=1.0$, $T_{\\mathrm{final}}=0.02$。\n\n程序要求。编写一个完整的程序，该程序：\n- 为每种情况和 $N_x \\in \\{64,128,256,512\\}$ 实现上述 D1Q3 标量 LBM。\n- 对每种情况，计算不同细化程度下的数组 $\\{E\\}$, $\\{\\Delta x\\}$, 和 $\\{\\Delta t\\}$，然后使用最小二乘拟合返回 $(p_x, p_t)$。\n- 其唯一输出为一行，包含六个浮点数值 $[p_x^{(A)},p_t^{(A)},p_x^{(B)},p_t^{(B)},p_x^{(C)},p_t^{(C)}]$，按此顺序排列，每个值四舍五入到三位小数，格式为方括号内由逗号分隔的列表。\n\n角度单位与物理单位。不存在角度量，所有变量均为无量纲。不应报告任何物理单位；所有输出均为纯数字。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5,result6]”）。",
            "solution": "问题陈述经过验证，被认为是科学上合理、适定且自洽的。它提出了一个标准的数值分析任务，涉及将格子玻尔兹曼方法 (LBM) 应用于一维热方程。所有参数、方程和程序都已明确且正确地指定，足以得出一个唯一的解。因此，我们着手进行解的推导和实现。\n\n该问题要求数值求解标量热扩散方程，\n$$\n\\partial_t T = \\alpha \\,\\partial_{xx} T\n$$\n在一个长度为 $L$ 的一维周期性域上。指定的方法是带有 Bhatnagar-Gross-Krook (BGK) 碰撞算子的 D1Q3 格子玻尔兹曼模型。\n\nD1Q3 模型将速度空间离散为三个方向，$i \\in \\{0, 1, 2\\}$，对应于微观粒子速度 $e_0 = 0$, $e_1 = +c$, 和 $e_2 = -c$。粒子分布函数 $f_i(x,t)$ 的演化由格子玻尔兹曼方程控制：\n$$\nf_i(x+e_i\\Delta t, t+\\Delta t) - f_i(x,t) = -\\frac{1}{\\tau} (f_i(x,t) - f_i^{\\mathrm{eq}}(x,t))\n$$\n其中 $\\tau$ 是无量纲弛豫时间，$f_i^{\\mathrm{eq}}$ 是局部平衡分布函数。等式左边代表粒子向相邻格点的迁移，而右边代表因碰撞而向平衡态的弛豫。\n\n对于标量扩散过程，平衡分布函数是宏观标量场（在此情况下为温度 $T$）的线性函数。它由 $f_i^{\\mathrm{eq}} = w_i T$ 给出，其中 $w_i$ 是求积权重。对于 D1Q3 格式，这些权重为 $w_0 = 2/3$ 和 $w_{1,2} = 1/6$。宏观温度通过分布函数的零阶矩恢复：\n$$\nT(x,t) = \\sum_{i=0}^{2} f_i(x,t)\n$$\n可以验证 $\\sum_i f_i^{\\mathrm{eq}} = \\sum_i w_i T = T(\\sum_i w_i) = T(2/3 + 1/6 + 1/6) = T$，这确保了在碰撞过程中标量 $T$ 的局域守恒。\n\n数值算法在每个时间增量中分两步进行：碰撞和迁移。\n1.  **碰撞步**：在每个网格节点 $x_k$ 计算碰撞后的分布函数 $f_i^{\\ast}$：\n    $$\n    f_i^{\\ast}(x_k, t) = f_i(x_k, t) - \\frac{1}{\\tau} (f_i(x_k, t) - f_i^{\\mathrm{eq}}(x_k, t))\n    $$\n    首先，根据当前的粒子布居数计算宏观温度 $T(x_k,t) = \\sum_i f_i(x_k,t)$。然后，确定平衡布居数 $f_i^{\\mathrm{eq}}(x_k,t) = w_i T(x_k,t)$，最后应用碰撞更新。\n\n2.  **迁移步**：碰撞后的粒子布居数根据其速度传播到相邻节点。当格子速度设为 $c = \\Delta x/\\Delta t$（其中 $\\Delta x$ 是网格间距，$\\Delta t$ 是时间步长）时，粒子在一个时间步内精确地从一个节点移动到其邻居节点。对于周期性域，这通过循环移位实现：\n    $$\n    f_0(x_k, t+\\Delta t) = f_0^{\\ast}(x_k, t) \\\\\n    f_1(x_k, t+\\Delta t) = f_1^{\\ast}(x_{k-1}, t) \\\\\n    f_2(x_k, t+\\Delta t) = f_2^{\\ast}(x_{k+1}, t)\n    $$\n    索引 $k-1$ 和 $k+1$ 通过周期性环绕处理。\n\n模拟在时间 $t=0$ 初始化。初始温度场 $T(x,0)$ 由高斯函数的周期性总和给出。初始粒子分布被设置为与该场处于局部平衡：$f_i(x_k, 0) = f_i^{\\mathrm{eq}}(x_k, 0) = w_i T(x_k, 0)$。然后模拟演化 $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ 个时间步。最终的数值温度分布 $T_{\\mathrm{num}}(x_k, t^{\\ast})$ 在实际的最终时间 $t^{\\ast} = N_t \\Delta t$ 计算。\n\n问题指定了一个扩散标度关系，以在网格细化过程中保持物理热扩散系数 $\\alpha$ 不变。该关系为：\n$$\n\\alpha = c_s^2 (\\tau - 1/2) \\Delta t\n$$\n其中 $c_s^2 = c^2/3 = (\\Delta x/\\Delta t)^2/3$ 是格子声速的平方。将 $c_s^2$ 代入 $\\alpha$ 的表达式并解出 $\\Delta t$，得到时间步长和网格间距之间的显式耦合关系：\n$$\n\\Delta t = \\frac{\\Delta x^2}{3\\alpha} (\\tau - 1/2)\n$$\n这个关系意味着 $\\Delta t \\propto \\Delta x^2$。\n\n使用网格大小 $N_x \\in \\{64, 128, 256, 512\\}$ 进行网格细化研究。对于每个 $N_x$，网格间距为 $\\Delta x=L/N_x$，并计算相应的 $\\Delta t$。运行模拟，并使用离散 $L^2$ 范数与在 $t^{\\ast}$ 处求值的给定精确解比较，计算误差 $E$：\n$$\nE = \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k, t^{\\ast}) - T_{\\mathrm{exact}}(x_k, t^{\\ast})\\right]^2 \\right)^{1/2}\n$$\n精度阶由误差标度律 $E \\approx C (\\Delta x)^{p_x}$ 的假设确定，其中 $C$ 是某个常数，$p_x$ 是空间阶。取对数得到 $\\log E \\approx \\log C + p_x \\log \\Delta x$。因此，空间阶 $p_x$ 是 $\\log E$ 对 $\\log \\Delta x$ 的最小二乘线性拟合的斜率。类似地，由于 $\\Delta t \\propto \\Delta x^2$，我们有 $\\log E \\approx \\log C' + p_t \\log \\Delta t$，其中 $p_t = p_x/2$。时间阶 $p_t$ 是 $\\log E$ 对 $\\log \\Delta t$ 拟合的斜率。将为指定的三个测试案例中的每一个计算这两个斜率。用于扩散的 LBM-BGK 格式在空间上预期是二阶精度的，因此我们预计 $p_x \\approx 2.0$，从而 $p_t \\approx 1.0$。\n\n实现过程首先定义初始条件和精确解析解的函数。一个主模拟函数封装了针对给定物理和数值参数集的 LBM 算法。对每个细化级别调用此函数。收集得到的误差和网格参数。最后，对对数转换后的数据执行线性回归，以提取观测到的精度阶，然后报告这些精度阶。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef setup_exact_solution_function(L, A, sigma0, alpha, J, x0):\n    \"\"\"\n    Creates a function that computes the exact solution for a given time t.\n    \"\"\"\n    def get_exact_solution(x_grid, t):\n        if t == 0:\n            var_term = sigma0**2\n            time_prefactor = A\n        else:\n            var_term = sigma0**2 + 4 * alpha * t\n            time_prefactor = A * np.sqrt(sigma0**2 / var_term)\n\n        if var_term == 0:\n            # Handle the case of a delta function, though not expected here.\n            T_exact = np.zeros_like(x_grid)\n            idx = np.abs(x_grid - x0).argmin()\n            T_exact[idx] = np.inf\n            return T_exact\n\n        T_exact = np.zeros_like(x_grid)\n        for j in range(-J, J + 1):\n            T_exact += np.exp(-((x_grid - x0 + j * L)**2) / var_term)\n        \n        return time_prefactor * T_exact\n\n    return get_exact_solution\n\n\ndef run_lbm_and_get_error(Nx, L, alpha, tau, T_final, A, sigma0, J, x0):\n    \"\"\"\n    Runs a single D1Q3 LBM simulation and computes the L2 error.\n    \"\"\"\n    # Grid and time parameters\n    dx = L / Nx\n    dt = (dx**2 / (3 * alpha)) * (tau - 0.5)\n    Nt = int(round(T_final / dt))\n    t_star = Nt * dt\n    x = np.linspace(0, L, Nx, endpoint=False) + dx / 2.0\n\n    # LBM parameters\n    w = np.array([2./3., 1./6., 1./6.]) # w0, w+, w-\n    omega = 1.0 / tau\n\n    # Initialization\n    exact_solution_func = setup_exact_solution_function(L, A, sigma0, alpha, J, x0)\n    T0 = exact_solution_func(x, 0)\n    \n    # Populations f0, f+, f-\n    f0 = w[0] * T0\n    f1 = w[1] * T0\n    f2 = w[2] * T0\n    \n    # Main time-stepping loop\n    for _ in range(Nt):\n        # Macroscopic temperature\n        T = f0 + f1 + f2\n        \n        # Collision\n        f0_eq = w[0] * T\n        f1_eq = w[1] * T\n        f2_eq = w[2] * T\n        \n        f0 = f0 - omega * (f0 - f0_eq)\n        f1 = f1 - omega * (f1 - f1_eq)\n        f2 = f2 - omega * (f2 - f2_eq)\n        \n        # Streaming\n        f1 = np.roll(f1, 1)  # moves right\n        f2 = np.roll(f2, -1) # moves left\n\n    # Final numerical temperature\n    T_num = f0 + f1 + f2\n    \n    # Exact solution at final time\n    T_exact = exact_solution_func(x, t_star)\n    \n    # L2 Error calculation\n    error = np.sqrt(dx * np.sum((T_num - T_exact)**2))\n    \n    return error, dx, dt\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute orders of accuracy.\n    \"\"\"\n    test_cases = [\n        # Case A (baseline)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case B (lower diffusivity)\n        {\"alpha\": 0.005, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case C (sharper pulse)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.03, \"A\": 1.0, \"T_final\": 0.02},\n    ]\n\n    # Shared parameters\n    L = 1.0\n    x0 = L / 2.0\n    J = 6\n    Nx_refinements = [64, 128, 256, 512]\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        errors = []\n        dxs = []\n        dts = []\n        \n        for Nx in Nx_refinements:\n            error, dx, dt = run_lbm_and_get_error(Nx, L, **case_params, J=J, x0=x0)\n            errors.append(error)\n            dxs.append(dx)\n            dts.append(dt)\n        \n        # Log-transform data for linear regression\n        log_errors = np.log(np.array(errors))\n        log_dxs = np.log(np.array(dxs))\n        log_dts = np.log(np.array(dts))\n        \n        # Perform linear regression to find slopes (orders of accuracy)\n        px_res = linregress(log_dxs, log_errors)\n        pt_res = linregress(log_dts, log_errors)\n        \n        px = px_res.slope\n        pt = pt_res.slope\n        \n        all_results.extend([px, pt])\n\n    # Format the final output string\n    # [px_A, pt_A, px_B, pt_B, px_C, pt_C] rounded to 3 decimal places\n    output_str = f\"[{','.join([f'{r:.3f}' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "格子玻尔兹曼方法的真正威力在于其能够灵活地模拟超出理想气体定律的复杂流体行为。这项高级实践将带你探索矩匹配过程，它将微观粒子分布与期望的宏观物理（例如非理想气体的状态方程）联系起来。通过推导并验证范德华流体的平衡态分布函数，你将学会如何定制LBM框架以模拟复杂的多相系统，从而从LBM的使用者转变为开发者 。",
            "id": "2407099",
            "problem": "您需要为二维九速（D2Q9）晶格上的格子玻尔兹曼方法（LBM）构建一个多项式平衡分布函数，该函数能以流速的二阶精度再现一个给定的非理想状态方程。在格子单位下进行计算，以使所有量均为无量纲量，并假设使用标准的D2Q9晶格，其等温格子声速的平方等于 $c_s^2 = 1/3$。您的任务是从矩方法（method-of-moments）的角度出发：要求平衡分布函数的零阶、一阶和二阶速度矩分别恢复范德华流体的密度、动量和非理想压力张量。\n\n使用的基本原理和约束条件：\n- D2Q9离散速度集由九个矢量 $c_i \\in \\mathbb{R}^2$ 给出，其中 $i \\in \\{0,\\dots,8\\}$：$(0,0)$, $(1,0)$, $(0,1)$, $(-1,0)$, $(0,-1)$, $(1,1)$, $(-1,1)$, $(-1,-1)$, $(1,-1)$。对应的权重为 $w_0 = 4/9$， $w_{1\\text{至}4} = 1/9$， $w_{5\\text{至}8} = 1/36$。\n- 设 $\\rho$ 为密度，$u \\in \\mathbb{R}^2$ 为宏观速度。平衡分布函数 $\\{ f_i^{eq} \\}_{i=0}^8$ 必须满足以下矩约束条件\n  1) $\\sum_{i=0}^8 f_i^{eq} = \\rho$,\n  2) $\\sum_{i=0}^8 f_i^{eq} c_i = \\rho u$,\n  3) $\\sum_{i=0}^8 f_i^{eq} c_i c_i = p(\\rho,T)\\, I + \\rho\\, u u$,\n  其中 $I$ 是二维单位张量，像 $c_i c_i$ 和 $u u$ 这样的乘积表示外积。\n- 范德华状态方程为 $p(\\rho,T) = \\dfrac{\\rho\\, R\\, T}{1 - b \\rho} - a \\rho^2$，其中参数 $a  0$, $b  0$，热力学温度 $T  0$。在本问题中，取气体常数 $R = 1$（格子单位）。\n- 使用D2Q9直至四阶的标准各向同性恒等式，为 $f_i^{eq}$ 构建一个关于 $u$ 的二阶多项式拟设（ansatz），其系数依赖于 $\\rho$ 和 $p(\\rho,T)$，并强制执行上述矩约束。不要引入外力项；严格通过修改平衡矩来实现非理想压力。\n\n算法要求：\n- 在程序中实现您推导出的D2Q9平衡态，该程序对每个测试用例计算残差，以量化您的 $\\{ f_i^{eq} \\}$ 是否满足三个矩约束：\n  - 质量残差：$r_0 = \\left(\\sum_{i=0}^8 f_i^{eq}\\right) - \\rho$。\n  - 动量残差范数：$r_1 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i\\right) - \\rho u \\right\\|_2$。\n  - 压力张量残差弗罗贝尼乌斯范数：$r_2 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i c_i\\right) - \\left(p(\\rho,T) I + \\rho u u\\right) \\right\\|_F$。\n- 对于数值报告，每个测试用例输出三元组 $[r_0, r_1, r_2]$，并四舍五入到12位小数。\n\n测试套件：\n- 使用以下五个测试用例，每个用例由 $(\\rho, u_x, u_y, a, b, T)$ 定义：\n  1) $(0.8, 0.12, -0.07, 0.5, 0.3, 0.9)$,\n  2) $(0.01, 0.0001, -0.0002, 0.2, 0.1, 1.0)$,\n  3) $(3.2, 0.0, 0.0, 0.1, 0.3, 1.2)$,\n  4) $(1.0, 0.3, 0.4, 1.0, 0.1, 0.6)$,\n  5) $(0.9, 0.0, 0.0, 0.0, 0.4, 1.5)$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个结果三元组的列表，以逗号分隔，并用方括号括起来，不含额外空格。例如，您的输出必须类似于\n  \"[[r00,r01,r02],[r10,r11,r12],[r20,r21,r22],[r30,r31,r32],[r40,r41,r42]]\"\n其中每个 $r_{jk}$ 是按上述规定四舍五入到12位小数的十进制数。",
            "solution": "该问题要求为D2Q9晶格构建一个二阶多项式平衡分布函数 $f_i^{eq}$，该函数能正确地恢复范德华流体的宏观密度 $\\rho$、动量 $\\rho u$ 和非理想动量通量张量 $\\Pi_{\\alpha\\beta} = p(\\rho,T)\\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta$。在格子单位下，压力 $p(\\rho,T)$ 由 $p(\\rho,T) = \\dfrac{\\rho T}{1 - b \\rho} - a \\rho^2$ 给出，其中气体常数 $R=1$。推导将通过矩方法进行。\n\n在格子玻尔兹曼方法（LBM）中，理想气体的标准二阶多项式平衡分布函数由下式给出：\n$$\nf_i^{eq, ideal} = w_i \\rho \\left( 1 + \\frac{c_{i\\alpha}u_\\alpha}{c_s^2} + \\frac{(c_{i\\alpha}c_{i\\beta}-c_s^2\\delta_{\\alpha\\beta})u_\\alpha u_\\beta}{2c_s^4} \\right)\n$$\n此处，$w_i$ 是晶格权重，$c_{i\\alpha}$ 是离散速度的分量，$u_\\alpha$ 是宏观流体速度的分量，$c_s^2 = 1/3$ 是格子声速的平方。希腊字母索引 $\\alpha, \\beta$ 暗示对空间维度 $\\{x, y\\}$ 求和。\n\n该分布的矩为：\n1.  $\\sum_{i=0}^8 f_i^{eq, ideal} = \\rho$\n2.  $\\sum_{i=0}^8 f_i^{eq, ideal} c_{i\\alpha} = \\rho u_\\alpha$\n3.  $\\sum_{i=0}^8 f_i^{eq, ideal} c_{i\\alpha}c_{i\\beta} = \\rho c_s^2 \\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta$\n\n这恢复了压力为 $p_{ideal} = \\rho c_s^2$ 的理想气体的动量通量张量。本问题要求恢复非理想压力 $p(\\rho, T)$。目标动量通量张量为 $\\Pi_{\\alpha\\beta} = p(\\rho,T)\\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta$。\n\n为实现此目标，我们必须通过添加一个修正项 $\\Delta f_i^{eq}$ 来修改平衡分布函数，使得总分布 $f_i^{eq} = f_i^{eq, ideal} + \\Delta f_i^{eq}$ 满足所需的矩约束。该修正项不能改变零阶和一阶矩，并且必须适当地调整二阶矩。因此，对 $\\Delta f_i^{eq}$ 的约束为：\n1.  $\\sum_{i=0}^8 \\Delta f_i^{eq} = 0$\n2.  $\\sum_{i=0}^8 \\Delta f_i^{eq} c_{i\\alpha} = 0$\n3.  $\\sum_{i=0}^8 \\Delta f_i^{eq} c_{i\\alpha} c_{i\\beta} = \\Pi_{\\alpha\\beta} - (\\rho c_s^2 \\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta) = (p(\\rho,T) - \\rho c_s^2)\\delta_{\\alpha\\beta}$\n\n由于对动量通量张量所需的修正是独立于速度 $u$ 的，因此对 $\\Delta f_i^{eq}$ 的一个合适的拟设也应独立于 $u$，并由离散速度 $c_i$ 的低阶多项式构成。我们提出以下形式的拟设：\n$$\n\\Delta f_i^{eq} = w_i K (c_i^2 - C)\n$$\n其中 $c_i^2 = c_{i\\alpha}c_{i\\alpha}$ 是离散速度矢量 $c_i$ 的模的平方。系数 $K$ 和 $C$ 是依赖于 $\\rho$ 和 $T$ 但不依赖于 $i$ 的标量。\n\n我们利用D2Q9的各向同性关系式来对该拟设施加约束：$\\sum_i w_i = 1$，$\\sum_i w_i c_{i\\alpha}=0$，$\\sum_i w_i c_{i\\alpha}c_{i\\beta} = c_s^2 \\delta_{\\alpha\\beta}$，以及 $\\sum_i w_i c_{i\\alpha}c_{i\\beta}c_{i\\gamma}c_{i\\delta} = c_s^4 (\\delta_{\\alpha\\beta}\\delta_{\\gamma\\delta} + \\delta_{\\alpha\\gamma}\\delta_{\\beta\\delta} + \\delta_{\\alpha\\delta}\\delta_{\\beta\\gamma})$。对于 $D=2$ 维，二阶恒等式的迹给出 $\\sum_i w_i c_i^2 = \\sum_i w_i c_{i\\alpha}c_{i\\alpha} = \\sum_{\\alpha} c_s^2 \\delta_{\\alpha\\alpha} = D c_s^2 = 2 c_s^2$。\n\n1.  **$\\Delta f_i^{eq}$ 的零阶矩**：\n    $\\sum_i \\Delta f_i^{eq} = \\sum_i w_i K (c_i^2 - C) = K (\\sum_i w_i c_i^2 - C \\sum_i w_i) = K(2c_s^2 - C)$。\n    为使此项对于非平凡的 $K$ 为零，我们必须有 $C = 2c_s^2$。\n\n2.  **$\\Delta f_i^{eq}$ 的一阶矩**：\n    $\\sum_i \\Delta f_i^{eq} c_{i\\alpha} = \\sum_i w_i K (c_i^2 - 2c_s^2) c_{i\\alpha} = K (\\sum_i w_i c_i^2 c_{i\\alpha} - 2c_s^2 \\sum_i w_i c_{i\\alpha})$。\n    两项都涉及三阶张量，由于晶格对称性，它们都为零。因此，该约束自动满足。\n\n3.  **$\\Delta f_i^{eq}$ 的二阶矩**：\n    $\\sum_i \\Delta f_i^{eq} c_{i\\alpha}c_{i\\beta} = K (\\sum_i w_i c_i^2 c_{i\\alpha}c_{i\\beta} - 2c_s^2 \\sum_i w_i c_{i\\alpha}c_{i\\beta})$。\n    四阶矩张量为 $\\sum_i w_i c_i^2 c_{i\\alpha}c_{i\\beta} = \\sum_{i, \\gamma} w_i c_{i\\gamma}c_{i\\gamma}c_{i\\alpha}c_{i\\beta} = c_s^4 \\sum_{\\gamma}(\\delta_{\\gamma\\gamma}\\delta_{\\alpha\\beta} + \\delta_{\\gamma\\alpha}\\delta_{\\gamma\\beta} + \\delta_{\\gamma\\beta}\\delta_{\\gamma\\alpha})$。对于 $D=2$，其计算结果为 $c_s^4 (D\\delta_{\\alpha\\beta} + \\delta_{\\alpha\\beta} + \\delta_{\\alpha\\beta}) = (D+2)c_s^4\\delta_{\\alpha\\beta} = 4c_s^4\\delta_{\\alpha\\beta}$。\n    二阶矩变为：$K(4c_s^4\\delta_{\\alpha\\beta} - 2c_s^2(c_s^2\\delta_{\\alpha\\beta})) = 2Kc_s^4\\delta_{\\alpha\\beta}$。\n    将其与目标修正项 $(p(\\rho,T) - \\rho c_s^2)\\delta_{\\alpha\\beta}$ 相等，得到：\n    $2Kc_s^4 = p(\\rho,T) - \\rho c_s^2 \\implies K = \\frac{p(\\rho,T) - \\rho c_s^2}{2c_s^4}$。\n\n因此，修正项为：\n$$\n\\Delta f_i^{eq} = w_i \\frac{p(\\rho,T) - \\rho c_s^2}{2c_s^4} (c_i^2 - 2c_s^2)\n$$\n满足所有三个矩约束的完整平衡分布函数是：\n$$\nf_i^{eq} = w_i \\left( \\rho \\left( 1 + \\frac{c_{i\\alpha}u_\\alpha}{c_s^2} + \\frac{(c_{i\\alpha}c_{i\\beta}-c_s^2\\delta_{\\alpha\\beta})u_\\alpha u_\\beta}{2c_s^4}\\right) + \\frac{p(\\rho,T)-\\rho c_s^2}{2 c_s^4}(c_i^2-2c_s^2) \\right)\n$$\n代入 $c_s^2 = 1/3$：\n$$\nf_i^{eq} = w_i \\left( \\rho \\left( 1 + 3(c_i \\cdot u) + \\frac{9}{2}(c_i \\cdot u)^2 - \\frac{3}{2}u^2 \\right) + \\frac{9}{2}(p(\\rho,T)-\\rho/3)(c_i^2-2/3) \\right)\n$$\n其中 $c_i \\cdot u = c_{i\\alpha} u_\\alpha$, $u^2 = u_\\alpha u_\\alpha$ 以及 $c_i^2 = c_{i\\alpha} c_{i\\alpha}$。该表达式是关于速度 $u$ 的二阶多项式，并满足所有指定条件。\n\n该实现为每个测试用例计算此 $f_i^{eq}$，并通过将数值计算出的 $\\{f_i^{eq}\\}$ 的矩与它们的确切目标值进行比较来计算残差 $r_0, r_1, r_2$。由于推导的解析正确性，这些残差应在机器浮点精度范围内为零。\n- 质量残差：$r_0 = \\left(\\sum_{i=0}^8 f_i^{eq}\\right) - \\rho$\n- 动量残差：$r_1 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i\\right) - \\rho u \\right\\|_2$\n- 应力残差：$r_2 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i c_i\\right) - \\left(p(\\rho,T) I + \\rho u u\\right) \\right\\|_F$\n范数对于矢量是欧几里得范数，对于张量是弗罗贝尼乌斯范数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and verifies a D2Q9 LBM equilibrium distribution for a van der Waals fluid.\n    \"\"\"\n    # Define the D2Q9 lattice constants.\n    c = np.array([\n        [0, 0], [1, 0], [0, 1], [-1, 0], [0, -1],\n        [1, 1], [-1, 1], [-1, -1], [1, -1]\n    ], dtype=np.float64)\n    w = np.array([\n        4/9, 1/9, 1/9, 1/9, 1/9,\n        1/36, 1/36, 1/36, 1/36\n    ], dtype=np.float64)\n    cs2 = 1/3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.8, 0.12, -0.07, 0.5, 0.3, 0.9),\n        (0.01, 0.0001, -0.0002, 0.2, 0.1, 1.0),\n        (3.2, 0.0, 0.0, 0.1, 0.3, 1.2),\n        (1.0, 0.3, 0.4, 1.0, 0.1, 0.6),\n        (0.9, 0.0, 0.0, 0.0, 0.4, 1.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, ux, uy, a, b, T = case\n        u = np.array([ux, uy], dtype=np.float64)\n        R = 1.0\n\n        # Calculate the van der Waals pressure.\n        p = (rho * R * T) / (1 - b * rho) - a * rho**2\n\n        # Initialize the equilibrium distribution array.\n        feq = np.zeros(9, dtype=np.float64)\n\n        # Calculate the equilibrium distribution for each discrete velocity.\n        for i in range(9):\n            ci_dot_u = np.dot(c[i], u)\n            u_sq = np.dot(u, u)\n            ci_sq = np.dot(c[i], c[i])\n            \n            # The standard second-order ideal gas part:\n            # f_ideal = rho * (1 + (ci_dot_u / cs2) + (ci_dot_u**2 / (2 * cs2**2)) - (u_sq / (2 * cs2)))\n            # The non-ideal pressure correction part:\n            # f_corr = (p - rho * cs2) / (2 * cs2**2) * (ci_sq - 2 * cs2)\n            # feq[i] = w[i] * (f_ideal + f_corr)\n\n            # Combined and simplified expression from the derivation:\n            term1 = rho * (1 + 3 * ci_dot_u + 4.5 * ci_dot_u**2 - 1.5 * u_sq)\n            term2 = 4.5 * (p - rho / 3) * (ci_sq - 2/3)\n            feq[i] = w[i] * (term1 + term2)\n\n        # Numerically compute the moments from the calculated feq.\n        rho_num = np.sum(feq)\n        rho_u_num = np.einsum('i,ia-a', feq, c)\n        Pi_num = np.einsum('i,ia,ib-ab', feq, c, c)\n\n        # Define the target macroscopic quantities.\n        rho_target = rho\n        rho_u_target = rho * u\n        Pi_target = p * np.identity(2) + rho * np.outer(u, u)\n\n        # Calculate the residuals.\n        r0 = rho_num - rho_target\n        r1 = np.linalg.norm(rho_u_num - rho_u_target)\n        r2 = np.linalg.norm(Pi_num - Pi_target) # Frobenius norm is default for matrices\n\n        # Append the rounded results to the list.\n        results.append([round(r0, 12), round(r1, 12), round(r2, 12)])\n\n    # Final print statement in the exact required format.\n    # The string representation is crafted to avoid any spaces.\n    results_str = str(results).replace(\" \", \"\")\n    print(results_str)\n\nsolve()\n```"
        }
    ]
}