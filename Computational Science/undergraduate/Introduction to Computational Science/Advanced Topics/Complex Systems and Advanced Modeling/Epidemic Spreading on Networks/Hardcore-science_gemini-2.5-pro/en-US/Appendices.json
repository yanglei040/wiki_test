{
    "hands_on_practices": [
        {
            "introduction": "The initial phase of an epidemic often exhibits exponential growth, but what determines the rate of this explosion? This practice explores the fundamental link between the microscopic structure of a contact network and the macroscopic growth rate of the disease. You will investigate how the network's mathematical properties, specifically the largest eigenvalue of the Next-Generation Matrix, dictate the speed at which an epidemic takes off. By deriving this theoretical growth rate and comparing it to a rate estimated from a simulated time series, you will gain hands-on experience in validating a mathematical model against computational data, a core skill in computational science .",
            "id": "3124341",
            "problem": "You are asked to connect early exponential growth in an epidemic to the structure of the contact network via the Next-Generation Matrix (NGM), and to validate the prediction against a directly computed time series. Work within the following setting.\n\nFundamental base and definitions to be used:\n- In the early phase of a Susceptible-Infected-Recovered (SIR) process on a static, undirected contact network with adjacency matrix $A$, per-contact transmission rate $\\beta$ (in $\\text{day}^{-1}$), and recovery rate $\\gamma$ (in $\\text{day}^{-1}$), the expected infected state vector $i(t)$ evolves according to the linear Ordinary Differential Equation (ODE) $$\\frac{d}{dt} i(t) = \\left(\\beta A - \\gamma I\\right) i(t),$$ where $I$ is the identity matrix and $i(t)$ is the vector of expected infected counts per node. This is the standard linearization valid when the fraction infected is small.\n- The Next-Generation Matrix (NGM) $K$ is defined as the expected number of secondary infections along edges over the infectious lifetime in the early phase. In this network setting with exponential infectious periods, $K$ is given by $$K = \\frac{\\beta}{\\gamma} A.$$ The leading eigenvalue (spectral radius) of $K$ is denoted by $\\rho(K)$.\n- The total infected quantity is defined as $$I_{\\text{tot}}(t) = \\sum_{j} i_j(t).$$ In the early phase, one expects $$I_{\\text{tot}}(t) \\approx I_0 e^{r t},$$ where $r$ is the early exponential growth rate (in $\\text{day}^{-1}$) and $I_0$ is a constant.\n\nYour tasks:\n1. From first principles and the above base, derive a way to compute the early exponential growth rate $r$ from the leading eigenvalue of $K$.\n2. Independently estimate $r$ by generating a time series from the linear ODE. Use the following protocol so that results are reproducible and fully specified:\n   - Use the initial condition $$i(0) = \\frac{1}{N} \\mathbf{1},$$ where $N$ is the number of nodes and $\\mathbf{1}$ is the all-ones vector, so that $$I_{\\text{tot}}(0) = 1.$$\n   - Evolve the linear ODE solution exactly using matrix exponentials: $$i(t) = \\exp\\left[\\left(\\beta A - \\gamma I\\right) t\\right] i(0).$$\n   - Sample times uniformly from $t_{\\min}$ to $t_{\\max}$ with step $\\Delta t$, where $$t_{\\min} = 0.5\\ \\text{days},\\quad t_{\\max} = 8.0\\ \\text{days},\\quad \\Delta t = 0.05\\ \\text{days}.$$\n   - Form $$y(t) = \\ln I_{\\text{tot}}(t)$$ using the natural logarithm and estimate $r_{\\text{fit}}$ as the slope in an Ordinary Least Squares (OLS) linear regression of $y(t)$ versus $t$ over the sampled times.\n3. For each test case below, compute the absolute difference $$\\left|r_{\\text{fit}} - r_{\\text{theory}}\\right|,$$ where $r_{\\text{theory}}$ is the early growth rate computed from the leading eigenvalue of $K$ and $r_{\\text{fit}}$ is the regression-based estimate.\n\nTest suite (all rates are in $\\text{day}^{-1}$, time is in days):\n- Case $1$ (path graph of length $4$): $$A_1 = \\begin{bmatrix} 0 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \\end{bmatrix},\\quad \\beta_1 = 0.5,\\quad \\gamma_1 = 0.4.$$\n- Case $2$ (complete graph on $3$ nodes): $$A_2 = \\begin{bmatrix} 0 & 1 & 1 \\\\ 1 & 0 & 1 \\\\ 1 & 1 & 0 \\end{bmatrix},\\quad \\beta_2 = 0.3,\\quad \\gamma_2 = 0.6.$$\n- Case $3$ (star graph on $5$ nodes, node $0$ is the hub): $$A_3 = \\begin{bmatrix} 0 & 1 & 1 & 1 & 1 \\\\ 1 & 0 & 0 & 0 & 0 \\\\ 1 & 0 & 0 & 0 & 0 \\\\ 1 & 0 & 0 & 0 & 0 \\\\ 1 & 0 & 0 & 0 & 0 \\end{bmatrix},\\quad \\beta_3 = 0.2,\\quad \\gamma_3 = 0.5.$$\n\nRequired program behavior:\n- Implement the above computations for all three cases.\n- Your program must output a single line containing a comma-separated list of the three absolute differences, in the order of Cases $1,2,3$, enclosed in square brackets. Each number must be rounded to exactly $6$ decimal places. For example, the output format should be like `[0.000123,0.000000,0.000457]`.",
            "solution": "### Step 1: Theoretical Growth Rate ($r_{\\text{theory}}$) Derivation\n\nThe analysis begins with the provided linear Ordinary Differential Equation (ODE) system for the expected number of infected individuals at each node, $i(t)$:\n$$ \\frac{d}{dt} i(t) = (\\beta A - \\gamma I) i(t) $$\nwhere $A$ is the adjacency matrix, $\\beta$ is the transmission rate, $\\gamma$ is the recovery rate, and $I$ is the identity matrix. Let us define the matrix $M = \\beta A - \\gamma I$. The system is then $\\frac{d}{dt} i(t) = M i(t)$.\n\nThis is a system of linear, first-order, homogeneous ODEs with constant coefficients. The general solution can be expressed as a linear combination of its fundamental modes. If $\\{\\lambda_j\\}$ and $\\{v_j\\}$ are the set of eigenvalues and corresponding eigenvectors of $M$, the solution is given by:\n$$ i(t) = \\sum_j c_j v_j e^{\\lambda_j t} $$\nwhere the coefficients $c_j$ are determined by the initial condition $i(0)$.\n\nFor large $t$, the term corresponding to the largest eigenvalue, $\\lambda_{\\text{max}} = \\rho(M)$ (the spectral radius of $M$), will dominate the sum, provided its initial component $c_{\\text{max}}$ is non-zero.\n$$ i(t) \\approx c_{\\text{max}} v_{\\text{max}} e^{\\lambda_{\\text{max}} t} \\quad \\text{for } t \\to \\infty $$\nThe total number of infected individuals is $I_{\\text{tot}}(t) = \\mathbf{1}^T i(t)$, where $\\mathbf{1}$ is the all-ones vector. In the early phase, driven by the dominant mode, this becomes:\n$$ I_{\\text{tot}}(t) \\approx (c_{\\text{max}} \\mathbf{1}^T v_{\\text{max}}) e^{\\lambda_{\\text{max}} t} $$\nComparing this with the expected exponential growth form $I_{\\text{tot}}(t) \\approx I_0 e^{r t}$, we identify the early exponential growth rate $r$ with the leading eigenvalue of $M$:\n$$ r = \\lambda_{\\text{max}}(M) = \\rho(\\beta A - \\gamma I) $$\nThe eigenvalues of $M$ can be related to the eigenvalues of $A$. If $\\mu_j$ are the eigenvalues of $A$, then the eigenvalues of $\\beta A - \\gamma I$ are $\\beta \\mu_j - \\gamma$. Thus, the leading eigenvalue is:\n$$ r = \\beta \\mu_{\\text{max}} - \\gamma = \\beta \\rho(A) - \\gamma $$\nwhere $\\rho(A)$ is the spectral radius of the adjacency matrix $A$.\n\nThe Next-Generation Matrix is given as $K = \\frac{\\beta}{\\gamma} A$. The eigenvalues of $K$ are $\\frac{\\beta}{\\gamma} \\mu_j$. Its leading eigenvalue is $\\rho(K) = \\frac{\\beta}{\\gamma} \\rho(A)$. We can express $\\rho(A)$ in terms of $\\rho(K)$: $\\rho(A) = \\frac{\\gamma}{\\beta} \\rho(K)$.\n\nSubstituting this back into the expression for $r$, we obtain the desired relationship:\n$$ r_{\\text{theory}} = \\beta \\left(\\frac{\\gamma}{\\beta} \\rho(K)\\right) - \\gamma = \\gamma \\rho(K) - \\gamma $$\n$$ r_{\\text{theory}} = \\gamma (\\rho(K) - 1) $$\nThis equation connects the macroscopic growth rate $r$ to the microscopic parameters ($\\beta, \\gamma$) and the network topology (encapsulated in $\\rho(A)$, and thus $\\rho(K)$). An epidemic grows ($r_{\\text{theory}} > 0$) if and only if $\\rho(K) > 1$, which is the well-known threshold condition.\n\n### Step 2: Numerical Estimation of Growth Rate ($r_{\\text{fit}}$)\n\nAn independent estimate for $r$ is obtained by numerically simulating the dynamics and fitting the result.\n1.  **Solve the ODE**: The exact solution to $\\frac{d}{dt} i(t) = M i(t)$ with initial condition $i(0)$ is given by the matrix exponential:\n    $$ i(t) = \\exp(M t) i(0) $$\n    where $M = \\beta A - \\gamma I$. The initial condition is specified as $i(0) = \\frac{1}{N} \\mathbf{1}$, where $N$ is the number of nodes.\n\n2.  **Generate Time Series**: We compute $i(t)$ at discrete time points $t_k$ sampled uniformly from $t_{\\min} = 0.5$ to $t_{\\max} = 8.0$ with step $\\Delta t = 0.05$. For each $t_k$, we calculate the total infected population $I_{\\text{tot}}(t_k) = \\sum_j i_j(t_k)$.\n\n3.  **Perform Linear Regression**: The model $I_{\\text{tot}}(t) \\approx I_0 e^{rt}$ can be linearized by taking the natural logarithm:\n    $$ y(t) = \\ln I_{\\text{tot}}(t) \\approx \\ln(I_0) + r t $$\n    This is a linear equation of the form $y = c + r t$. We estimate the slope $r$ by performing an Ordinary Least Squares (OLS) linear regression on the data pairs $(t_k, y(t_k))$. The resulting slope is our estimate, $r_{\\text{fit}}$.\n\n### Step 3: Computation for Test Cases\n\nFor each of the three test cases, we perform the following calculations:\n1.  Define the adjacency matrix $A$ and parameters $\\beta, \\gamma$.\n2.  Compute $r_{\\text{theory}}$:\n    a. Construct the NGM, $K = (\\beta / \\gamma) A$.\n    b. Find its spectral radius, $\\rho(K) = \\max_j |\\lambda_j(K)|$.\n    c. Calculate $r_{\\text{theory}} = \\gamma (\\rho(K) - 1)$.\n3.  Compute $r_{\\text{fit}}$:\n    a. Construct the dynamics matrix, $M = \\beta A - \\gamma I$.\n    b. Generate the time vector $t$ from $t_{\\min}$ to $t_{\\max}$.\n    c. For each time point, calculate $i(t) = \\exp(Mt)i(0)$ and then $I_{\\text{tot}}(t) = \\sum_j i_j(t)$.\n    d. Form the vector $y(t) = \\ln I_{\\text{tot}}(t)$.\n    e. Find the slope of the best-fit line for $y(t)$ versus $t$, which gives $r_{\\text{fit}}$.\n4.  Calculate the absolute difference $|r_{\\text{fit}} - r_{\\text{theory}}|$.\n\nThe discrepancy between $r_{\\text{theory}}$ and $r_{\\text{fit}}$ arises because the time-series fit is performed over a finite interval where non-dominant eigenmodes may still have a non-negligible influence, causing $\\ln I_{\\text{tot}}(t)$ to deviate slightly from a perfect straight line. The theoretical rate $r_{\\text{theory}}$ represents the asymptotic growth rate as $t \\to \\infty$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the absolute difference between theoretical and fitted epidemic growth rates\n    for three network test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (path graph of length 4)\n        {\n            \"A\": np.array([\n                [0, 1, 0, 0],\n                [1, 0, 1, 0],\n                [0, 1, 0, 1],\n                [0, 0, 1, 0]\n            ]),\n            \"beta\": 0.5,\n            \"gamma\": 0.4\n        },\n        # Case 2 (complete graph on 3 nodes)\n        {\n            \"A\": np.array([\n                [0, 1, 1],\n                [1, 0, 1],\n                [1, 1, 0]\n            ]),\n            \"beta\": 0.3,\n            \"gamma\": 0.6\n        },\n        # Case 3 (star graph on 5 nodes)\n        {\n            \"A\": np.array([\n                [0, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0]\n            ]),\n            \"beta\": 0.2,\n            \"gamma\": 0.5\n        }\n    ]\n\n    results = []\n    \n    # Define time sampling parameters\n    t_min = 0.5\n    t_max = 8.0\n    dt = 0.05\n    # Use np.arange which handles floating point steps robustly\n    t_vals = np.arange(t_min, t_max + dt/2, dt)\n\n    for case in test_cases:\n        A = case[\"A\"]\n        beta = case[\"beta\"]\n        gamma = case[\"gamma\"]\n        N = A.shape[0]\n\n        # 1. Compute theoretical growth rate (r_theory)\n        # Construct the Next-Generation Matrix K\n        K = (beta / gamma) * A\n        \n        # Find the spectral radius of K (leading eigenvalue)\n        # For non-negative matrices (like A and K), the spectral radius is an eigenvalue\n        eigvals_K = np.linalg.eigvals(K)\n        rho_K = np.max(np.abs(eigvals_K))\n        \n        # Calculate r_theory\n        r_theory = gamma * (rho_K - 1)\n\n        # 2. Compute fitted growth rate (r_fit)\n        # Construct the dynamics matrix M\n        M = beta * A - gamma * np.identity(N)\n        \n        # Define initial condition\n        i0 = np.ones(N) / N\n        \n        I_tot_vals = []\n        for t in t_vals:\n            # Evolve the system using the matrix exponential\n            exp_Mt = expm(M * t)\n            i_t = exp_Mt @ i0\n            \n            # Calculate total infected\n            I_tot_t = np.sum(i_t)\n            I_tot_vals.append(I_tot_t)\n        \n        # Take natural log for linear regression\n        y_vals = np.log(np.array(I_tot_vals))\n        \n        # Perform Ordinary Least Squares regression to find the slope\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        coeffs = np.polyfit(t_vals, y_vals, 1)\n        r_fit = coeffs[0]\n\n        # 3. Compute the absolute difference\n        diff = np.abs(r_fit - r_theory)\n        results.append(diff)\n\n    # Final print statement in the exact required format.\n    # Each number is rounded to exactly 6 decimal places.\n    print(f\"[{','.join([f'{x:.6f}' for x in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In the face of an outbreak, public health resources like tests are almost always limited. This raises a critical question: how can we allocate these resources most effectively to detect as many cases as possible? This exercise challenges you to apply network science concepts to a practical public health problem. You will design and evaluate several testing strategies, including one that uses degree centrality—a measure of a node's connectedness—to prioritize individuals for testing. By mathematically comparing these policies, you will learn how abstract network theory can inform concrete, data-driven strategies for epidemic control .",
            "id": "3124329",
            "problem": "Consider a simple, undirected, unweighted network of $N$ nodes with adjacency matrix $A \\in \\{0,1\\}^{N \\times N}$, where $A_{ij} = 1$ indicates an edge between node $i$ and node $j$, and $A_{ii} = 0$. Let Degree Centrality (DC) for node $i$ be defined as $c_i = \\sum_{j=1}^{N} A_{ij}$. Suppose that each edge independently carries an exposure that leads to infection with probability $\\alpha \\in [0,1]$. Under the independence assumption across edges, the probability that node $i$ is infected at the snapshot time is $q_i$, which depends on $c_i$ and $\\alpha$. Assume perfect testing: a test always detects infection if present and has no false positives or false negatives.\n\nA testing budget of $B \\in \\mathbb{N}_0$ is available. Consider the following policies to choose which nodes to test:\n\n- Policy $\\mathcal{T}$ (targeted, with replacement): perform $B$ independent draws (with replacement). On each draw, select node $i$ with probability proportional to $c_i$. If $\\sum_{j=1}^{N} c_j = 0$, interpret selection probabilities as uniform over nodes. A node is considered \"tested\" if it appears at least once among the $B$ draws.\n- Policy $\\mathcal{U}$ (uniform, with replacement): perform $B$ independent draws (with replacement), each draw selecting a node uniformly at random from the $N$ nodes. A node is considered \"tested\" if it appears at least once among the $B$ draws.\n- Policy $\\mathcal{D}$ (deterministic top-$B$ without replacement): select up to $B$ distinct nodes with the largest $c_i$ values (ties broken by increasing node index), and test each exactly once. If $B \\ge N$, test all $N$ nodes.\n\nYour task is to compute, for each policy, the expected number of infected nodes that are detected by testing. The computation must begin from the independence of edge exposures and the definition of Degree Centrality, and must proceed via probability laws for repeated independent draws and set inclusion for detection. No shortcut formulas should be assumed in the problem statement; derive the quantities needed from first principles in your solution and program design.\n\nUse the following test suite. For each case, $A$ is specified, as well as $B$ and $\\alpha$. Nodes are indexed from $0$ to $N-1$.\n\n- Case $1$ (general connected network, moderate budget): $N = 6$, \n$$\nA^{(1)} = \\begin{bmatrix}\n0 & 1 & 1 & 0 & 0 & 0 \\\\\n1 & 0 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 1 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 0 & 1 & 0\n\\end{bmatrix},\\quad B^{(1)} = 3,\\quad \\alpha^{(1)} = 0.2.\n$$\n\n- Case $2$ (regular graph where centralities are equal): $N = 5$, \n$$\nA^{(2)} = \\begin{bmatrix}\n0 & 1 & 0 & 0 & 1 \\\\\n1 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 1 & 0 \\\\\n0 & 0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 & 0\n\\end{bmatrix},\\quad B^{(2)} = 4,\\quad \\alpha^{(2)} = 0.3.\n$$\n\n- Case $3$ (boundary budget): reuse $A^{(1)}$ with $B^{(3)} = 0$ and $\\alpha^{(3)} = 0.7$.\n\n- Case $4$ (star network, large budget): $N = 6$, \n$$\nA^{(4)} = \\begin{bmatrix}\n0 & 1 & 1 & 1 & 1 & 1 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0\n\\end{bmatrix},\\quad B^{(4)} = 20,\\quad \\alpha^{(4)} = 0.1.\n$$\n\nFor each case, compute three values: the expected number of detected infected nodes under $\\mathcal{T}$, under $\\mathcal{U}$, and under $\\mathcal{D}$. Your program should produce a single line of output containing the results for the four cases as a comma-separated list of lists, each inner list in the order $[\\mathcal{T}, \\mathcal{U}, \\mathcal{D}]$, and each numeric value printed with six decimal places, for example `[[r_1,T, r_1,U, r_1,D],[r_2,T, r_2,U, r_2,D],[r_3,T, r_3,U, r_3,D],[r_4,T, r_4,U, r_4,D]]`.\nNo physical units are involved. Express all results as real numbers (floats). The computation must be scientifically consistent with the independence assumptions described above.",
            "solution": "The objective is to compute the expected number of detected infected nodes, denoted by $E[X]$, for three different testing policies. Let $N$ be the number of nodes in the network. Let $I_i$ be an indicator random variable for the event that node $i$ is infected, and $T_i$ be an indicator random variable for the event that node $i$ is tested. The number of detected infected nodes is $X = \\sum_{i=0}^{N-1} I_i T_i$.\n\nBy the linearity of expectation, the expected number of detected infected nodes is:\n$$ E[X] = E\\left[\\sum_{i=0}^{N-1} I_i T_i\\right] = \\sum_{i=0}^{N-1} E[I_i T_i] $$\nThe expectation of an indicator variable is the probability of the event it indicates. Thus, $E[I_i T_i] = P(I_i=1 \\text{ and } T_i=1)$. The infection status of a node is determined by the properties of the network and the infection probability $\\alpha$, while the testing status is determined by the testing policy and budget $B$. These two processes are independent. Therefore, we can write:\n$$ P(I_i=1 \\text{ and } T_i=1) = P(I_i=1) \\cdot P(T_i=1) $$\nLet's denote $q_i = P(I_i=1)$ as the probability that node $i$ is infected, and $p_{\\text{test},i} = P(T_i=1)$ as the probability that node $i$ is tested. The expected number of detected infected nodes is then:\n$$ E[X] = \\sum_{i=0}^{N-1} q_i \\cdot p_{\\text{test},i} $$\nWe must now derive expressions for $q_i$ and $p_{\\text{test},i}$ for each policy from first principles.\n\n**1. Derivation of Infection Probability ($q_i$)**\nThe problem states that each edge independently carries an exposure that leads to infection with probability $\\alpha$. A node $i$ becomes infected if at least one of its neighbors transmits the infection. It is more straightforward to calculate the probability of the complementary event: node $i$ is *not* infected. This occurs if and only if *none* of its neighbors transmit the infection.\n\nLet $c_i$ be the Degree Centrality of node $i$, which is the number of its neighbors.\n$$ c_i = \\sum_{j=0}^{N-1} A_{ij} $$\nFor a single neighbor, the probability of *not* transmitting the infection is $(1-\\alpha)$. Since the exposures from all $c_i$ neighbors are independent events, the probability that none of them transmit the infection to node $i$ is the product of their individual probabilities of non-transmission:\n$$ P(I_i=0) = (1-\\alpha)^{c_i} $$\nThe probability $q_i$ that node $i$ is infected is the complement of this event:\n$$ q_i = P(I_i=1) = 1 - P(I_i=0) = 1 - (1-\\alpha)^{c_i} $$\n\n**2. Derivation of Testing Probability ($p_{\\text{test},i}$) for each Policy**\n\n**Policy $\\mathcal{T}$ (Targeted, with replacement):**\nIn this policy, $B$ independent tests are performed. For each test, a node $i$ is selected with a probability $p_i^{(\\mathcal{T})}$ proportional to its degree centrality $c_i$.\n$$ p_i^{(\\mathcal{T})} = \\frac{c_i}{\\sum_{j=0}^{N-1} c_j} $$\nIf the total degree sum $\\sum_{j=0}^{N-1} c_j = 0$ (a network with no edges), the selection probability is uniform: $p_i^{(\\mathcal{T})} = 1/N$. Let $C_{\\text{tot}} = \\sum_{j=0}^{N-1} c_j$.\nA node $i$ is considered tested if it is selected at least once in the $B$ draws. The probability that node $i$ is *not* selected in a single draw is $(1 - p_i^{(\\mathcal{T})})$. Since the $B$ draws are independent, the probability that node $i$ is *never* selected in $B$ draws is $(1 - p_i^{(\\mathcal{T})})^B$.\nThe probability $p_{\\text{test},i}^{(\\mathcal{T})}$ that node $i$ is tested is the complement:\n$$ p_{\\text{test},i}^{(\\mathcal{T})} = 1 - \\left(1 - \\frac{c_i}{C_{\\text{tot}}}\\right)^B $$\n(with the uniform case handled if $C_{\\text{tot}}=0$).\n\n**Policy $\\mathcal{U}$ (Uniform, with replacement):**\nThis is a simplification of the targeted policy where the selection probability for any node $i$ in a single draw is uniform: $p_i^{(\\mathcal{U})} = 1/N$. Following the same logic as for Policy $\\mathcal{T}$:\n$$ p_{\\text{test},i}^{(\\mathcal{U})} = 1 - \\left(1 - \\frac{1}{N}\\right)^B $$\nNote that this probability is the same for all nodes.\n\n**Policy $\\mathcal{D}$ (Deterministic Top-$B$, without replacement):**\nThis policy is deterministic. A fixed set of nodes $S_D$ is chosen for testing. The nodes are ranked in descending order of their degree centrality $c_i$. Ties are broken by choosing the node with the smaller index. The top $B$ nodes from this ranking are selected. If $B \\ge N$, all nodes are tested.\nFor a node $i$, the \"probability\" of being tested is either $1$ or $0$:\n$$ p_{\\text{test},i}^{(\\mathcal{D})} = \\begin{cases} 1 & \\text{if node } i \\in S_D \\\\ 0 & \\text{if node } i \\notin S_D \\end{cases} $$\nThe set $S_D$ contains the first $\\min(B, N)$ nodes from the ranked list.\n\n**3. Final Computation**\nFor each policy $\\mathcal{P} \\in \\{\\mathcal{T}, \\mathcal{U}, \\mathcal{D}\\}$, the expected number of detected infected nodes is calculated by summing the contributions from each node:\n$$ E[X]_{\\mathcal{P}} = \\sum_{i=0}^{N-1} q_i \\cdot p_{\\text{test},i}^{(\\mathcal{P})} = \\sum_{i=0}^{N-1} \\left(1 - (1-\\alpha)^{c_i}\\right) \\cdot p_{\\text{test},i}^{(\\mathcal{P})} $$\nThis formula, with the specific expressions for $p_{\\text{test},i}^{(\\mathcal{P})}$, is implemented for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected number of detected infected nodes for four test cases\n    under three different testing policies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [0, 1, 1, 0, 0, 0],\n        [1, 0, 1, 1, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 1, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0, 1],\n        [0, 0, 0, 0, 1, 0]\n    ])\n\n    A2 = np.array([\n        [0, 1, 0, 0, 1],\n        [1, 0, 1, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 0]\n    ])\n\n    A4 = np.array([\n        [0, 1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0]\n    ])\n\n    test_cases = [\n        (A1, 3, 0.2),  # Case 1\n        (A2, 4, 0.3),  # Case 2\n        (A1, 0, 0.7),  # Case 3\n        (A4, 20, 0.1)  # Case 4\n    ]\n\n    results = []\n    for A, B, alpha in test_cases:\n        case_results = _calculate_expected_detections(A, B, alpha)\n        results.append(case_results)\n    \n    # Format the final output string as specified.\n    outer_list = []\n    for inner_list in results:\n        formatted_inner = [f\"{v:.6f}\" for v in inner_list]\n        outer_list.append(f\"[{','.join(formatted_inner)}]\")\n    final_output = f\"[{','.join(outer_list)}]\"\n\n    print(final_output)\n\ndef _calculate_expected_detections(A, B, alpha):\n    \"\"\"\n    Calculates the expected detections for a single case (A, B, alpha).\n    Returns a list of three float values for policies T, U, and D.\n    \"\"\"\n    N = A.shape[0]\n    \n    # 1. Calculate degree centrality and infection probabilities\n    degrees = np.sum(A, axis=1)\n    q = 1 - (1 - alpha)**degrees\n    \n    # --- Policy T (Targeted, with replacement) ---\n    total_degree = np.sum(degrees)\n    if B == 0:\n        p_test_T = np.zeros(N)\n    elif total_degree == 0:\n        # Uniform selection if no edges exist\n        p_draw_T = np.full(N, 1/N)\n        p_test_T = 1 - (1 - p_draw_T)**B\n    else:\n        p_draw_T = degrees / total_degree\n        p_test_T = 1 - (1 - p_draw_T)**B\n    \n    exp_detected_T = np.sum(q * p_test_T)\n\n    # --- Policy U (Uniform, with replacement) ---\n    if B == 0:\n        p_test_U_scalar = 0.0\n    else:\n        p_test_U_scalar = 1 - (1 - 1/N)**B\n    \n    exp_detected_U = np.sum(q) * p_test_U_scalar\n\n    # --- Policy D (Deterministic top-B, without replacement) ---\n    exp_detected_D = 0.0\n    if B > 0:\n        # Sort nodes by degree (desc) and then index (asc)\n        node_indices = np.arange(N)\n        # We sort by (-degree, index)\n        ranked_nodes = sorted(node_indices, key=lambda i: (-degrees[i], i))\n        \n        # Select top min(B, N) nodes to test\n        nodes_to_test = ranked_nodes[:min(B, N)]\n        \n        # Sum infection probabilities for tested nodes\n        exp_detected_D = np.sum(q[nodes_to_test])\n        \n    return [exp_detected_T, exp_detected_U, exp_detected_D]\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world epidemic data is often incomplete. We might know the total number of infected individuals each day, but not who is infected or who has recovered. Can we still deduce the underlying nature of the disease from such aggregate data? For instance, can we determine if infection confers lifelong immunity (an SIR model) or not (an SI model)? This advanced practice introduces the powerful framework of Hidden Markov Models (HMMs) to tackle this challenge. By implementing a forward algorithm to compute a likelihood ratio, you will learn a fundamental technique for model selection, providing a window into how computational epidemiologists make sense of complex surveillance data .",
            "id": "3124380",
            "problem": "You are given an undirected simple network with adjacency matrix $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$, where $\\mathbf{A}$ has zeros on its diagonal and is symmetric. Consider two epidemic processes on the network: the Susceptible-Infected (SI) model and the Susceptible-Infected-Removed (SIR) model. Time is discrete, indexed by $t \\in \\{0,1,2,\\ldots,T\\}$. The state of each node at time $t$ is one of $S$ (susceptible), $I$ (infected), or $R$ (removed). The system evolves synchronously with the following dynamics, assumed independent across nodes given the current state at time $t$:\n\n1. Infection events: For any susceptible node $j$ at time $t$, let $m_j(t)$ be the number of infected neighbors of $j$ at time $t$. Each infected neighbor independently attempts transmission with per-edge probability $\\beta \\in [0,1]$ over the interval from $t$ to $t+1$. The probability that $j$ becomes infected by time $t+1$ is\n$$\np_{\\text{inf}}(j,t) \\;=\\; 1 - (1-\\beta)^{m_j(t)}.\n$$\n\n2. Recovery events: In the Susceptible-Infected-Removed (SIR) model, each infected node recovers over the same interval independently with probability $\\gamma \\in [0,1]$ and becomes removed by time $t+1$. In the Susceptible-Infected (SI) model, no recovery occurs, which is modeled by setting $\\gamma = 0$. Removed nodes, once created, remain removed forever.\n\nAssume the update is synchronous and transmission attempts emanate from nodes that are infected at time $t$, regardless of whether they recover by time $t+1$. Newly infected nodes at time $t+1$ cannot infect others until the subsequent step.\n\nObservation model and prior: You only observe the total number of infected nodes at each time, denoted $I(t)$, for $t \\in \\{0,1,\\ldots,T\\}$, but not the identities of the infected nodes. At time $t=0$, exactly one node is infected and all others are susceptible. The identity of the initially infected node is unknown and is assumed to be uniformly distributed over the $n$ nodes, independently of the network structure. Thus the prior over initial node-level states assigns probability $1/n$ to each configuration that has exactly one infected node and no removed nodes.\n\nTask: Design and implement a program that, given $\\mathbf{A}$, $\\beta$, $\\gamma$ (for the SIR model), and the observed series $I(0), I(1), \\ldots, I(T)$, computes the likelihood $L_{\\text{SI}} = \\Pr(I(0{:}T)\\mid \\text{SI}, \\mathbf{A}, \\beta)$ under the Susceptible-Infected (SI) model and the likelihood $L_{\\text{SIR}} = \\Pr(I(0{:}T)\\mid \\text{SIR}, \\mathbf{A}, \\beta, \\gamma)$ under the Susceptible-Infected-Removed (SIR) model. Use these to produce the likelihood ratio\n$$\n\\Lambda \\;=\\; \\frac{L_{\\text{SI}}}{L_{\\text{SIR}}}.\n$$\nCompute these likelihoods exactly by treating the node-level epidemic as a finite-state Markov chain over all node-level configurations and summing over all hidden paths consistent with the observation process using a forward dynamic programming approach. Do not approximate by simulations and do not assume factorization beyond the conditional independence implied by the model. The observation $I(t)$ is a deterministic function of the hidden state at time $t$, namely the count of nodes in state $I$.\n\nTest suite: Your program must compute $\\Lambda$ for each of the following $4$ test cases. In each case, the network $\\mathbf{A}$ is undirected and simple. The Susceptible-Infected (SI) model uses the given $\\beta$ and sets $\\gamma = 0$. The Susceptible-Infected-Removed (SIR) model uses the given $\\beta$ and $\\gamma$. The observed series $I(0{:}T)$ is specified for each case.\n\nCase $\\#1$:\n- $n = 4$ and\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0 & 1 & 0 & 0\\\\\n1 & 0 & 1 & 0\\\\\n0 & 1 & 0 & 1\\\\\n0 & 0 & 1 & 0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.4$, $\\gamma = 0.2$.\n- $I(0{:}3) = [\\,1,\\,2,\\,3,\\,4\\,]$.\n\nCase $\\#2$:\n- $n = 4$ and\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0 & 1 & 0 & 0\\\\\n1 & 0 & 1 & 0\\\\\n0 & 1 & 0 & 1\\\\\n0 & 0 & 1 & 0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.2$, $\\gamma = 0.5$.\n- $I(0{:}3) = [\\,1,\\,1,\\,1,\\,1\\,]$.\n\nCase $\\#3$:\n- $n = 5$ and\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0 & 1 & 1 & 1 & 1\\\\\n1 & 0 & 0 & 0 & 0\\\\\n1 & 0 & 0 & 0 & 0\\\\\n1 & 0 & 0 & 0 & 0\\\\\n1 & 0 & 0 & 0 & 0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.35$, $\\gamma = 0.3$.\n- $I(0{:}3) = [\\,1,\\,2,\\,1,\\,1\\,]$.\n\nCase $\\#4$:\n- $n = 3$ and\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0 & 0 & 0\\\\\n0 & 0 & 0\\\\\n0 & 0 & 0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.7$, $\\gamma = 0.4$.\n- $I(0{:}2) = [\\,1,\\,1,\\,1\\,]$.\n\nFinal output specification: Your program should produce a single line of output containing the likelihood ratios for Cases $\\#1$ through $\\#4$ in that order, as a comma-separated list enclosed in square brackets. Each finite result must be printed as a decimal rounded to exactly $6$ places after the decimal point. If $L_{\\text{SIR}} = 0$ and $L_{\\text{SI}} > 0$, print `inf`. If both $L_{\\text{SI}} = 0$ and $L_{\\text{SIR}} = 0$, print `nan`. For example, a valid output format is `[x_1, x_2, x_3, x_4]`, where each $x_k$ is a float with $6$ decimal places or one of `inf` or `nan` as specified. No physical units or angles are involved in this task.",
            "solution": "The problem requires the computation of a likelihood ratio $\\Lambda = L_{\\text{SI}} / L_{\\text{SIR}}$ for two epidemic models, Susceptible-Infected (SI) and Susceptible-Infected-Removed (SIR), given an observation series of the total number of infected individuals $I(0), \\ldots, I(T)$. The core of the task is to compute the likelihood of this observation sequence, $\\Pr(I(0{:}T))$, under each model. Since the specific identities of infected nodes are unknown, this is a problem of inference in a Hidden Markov Model (HMM). The solution is formulated using a forward dynamic programming algorithm to exactly compute the required likelihoods.\n\n### Hidden Markov Model Formulation\n\nThe system can be described as an HMM with the following components:\n\n1.  **Hidden States**: A hidden state at time $t$, denoted $C_t$, is the complete configuration of states for all $n$ nodes in the network. Each node can be in one of three states: Susceptible ($S$), Infected ($I$), or Removed ($R$). We can represent a configuration as a vector $C = (c_1, c_2, \\ldots, c_n)$, where $c_i \\in \\{S, I, R\\}$. The total number of hidden states is $3^n$. For computational purposes, we map each state $\\{S, I, R\\}$ to an integer $\\{0, 1, 2\\}$ and represent each configuration $C$ by a unique integer index in the range $[0, 3^n-1]$ via a base-$3$ encoding: $\\text{idx}(C) = \\sum_{i=1}^n c_i 3^{i-1}$.\n\n2.  **Observations**: The observation at time $t$ is $O_t = I(t)$, the total number of infected nodes. The observation is a deterministic function of the hidden state $C_t$. Let $N_I(C)$ be the number of infected nodes in configuration $C$.\n\n3.  **Initial State Probabilities**: The prior distribution over initial states $C_0$ at $t=0$ is given. There is exactly one infected node, and all others are susceptible. The identity of this initial node is chosen uniformly at random from the $n$ nodes. Thus, the probability of an initial configuration $C_0$ is:\n    $$\n    \\Pr(C_0) = \\begin{cases} 1/n & \\text{if } N_I(C_0)=1 \\text{ and } N_R(C_0)=0 \\\\ 0 & \\text{otherwise} \\end{cases}\n    $$\n    where $N_R(C_0)$ is the number of removed nodes in $C_0$.\n\n4.  **Transition Probabilities**: The transition probability $a_{C,C'} = \\Pr(C_{t+1}=C' \\mid C_t=C)$ quantifies the dynamics. Since node state changes are conditionally independent given the configuration $C_t$, this probability factorizes across all nodes:\n    $$\n    a_{C,C'} = \\prod_{j=1}^n \\Pr(c'_{j} \\mid C_t=C)\n    $$\n    where $c'_j$ is the state of node $j$ in $C'$. The individual node transition probabilities $\\Pr(c'_j \\mid C)$ are defined by the model dynamics:\n    -   If node $j$ is Susceptible ($c_j=S$): It becomes Infected ($c'_j=I$) with probability $p_{\\text{inf}}(j,C) = 1 - (1-\\beta)^{m_j(C)}$, where $m_j(C)$ is the number of infected neighbors of $j$ in configuration $C$. It remains Susceptible ($c'_j=S$) with probability $1-p_{\\text{inf}}(j,C)$.\n    -   If node $j$ is Infected ($c_j=I$): It becomes Removed ($c'_j=R$) with probability $\\gamma$. It remains Infected ($c'_j=I$) with probability $1-\\gamma$. For the SI model, $\\gamma=0$.\n    -   If node $j$ is Removed ($c_j=R$): It remains Removed ($c'_j=R$) with probability $1$.\n\n5.  **Emission Probabilities**: The emission probability $\\Pr(O_t \\mid C_t=C)$ is deterministic. It is $1$ if the number of infected nodes in state $C$ matches the observation $I(t)$, and $0$ otherwise.\n    $$\n    \\Pr(O_t=I(t) \\mid C_t=C) = \\mathbb{I}(N_I(C) = I(t))\n    $$\n    where $\\mathbb{I}(\\cdot)$ is the indicator function.\n\n### The Forward Algorithm\n\nTo compute the likelihood $L = \\Pr(I(0{:}T))$, we use the forward algorithm. Let $\\alpha_t(C) = \\Pr(I(0{:}t), C_t=C)$ be the joint probability of the observation sequence up to time $t$ and being in state $C$ at time $t$.\n\n**1. Initialization ($t=0$):**\nThe initial forward probability for each state $C$ is the probability of the state and the first observation being consistent.\n$$\n\\alpha_0(C) = \\Pr(I(0), C_0=C) = \\Pr(O_0=I(0) \\mid C_0=C) \\Pr(C_0) = \\mathbb{I}(N_I(C)=I(0)) \\Pr(C_0)\n$$\nGiven the problem's prior and $I(0)=1$, this simplifies to $\\alpha_0(C) = 1/n$ for any of the $n$ configurations with one infected and $n-1$ susceptible nodes, and $0$ for all other configurations.\n\n**2. Recursion ($t=0, \\ldots, T-1$):**\nThe forward probabilities for the next time step $t+1$ are computed from those at time $t$:\n$$\n\\alpha_{t+1}(C') = \\left( \\sum_{C} \\alpha_t(C) a_{C,C'} \\right) \\Pr(O_{t+1}=I(t+1) \\mid C_{t+1}=C')\n$$\nThe emission probability term acts as a filter: if $N_I(C') \\neq I(t+1)$, then $\\alpha_{t+1}(C') = 0$. Otherwise:\n$$\n\\alpha_{t+1}(C') = \\sum_{C} \\alpha_t(C) a_{C,C'}\n$$\n\n**3. Termination:**\nThe total likelihood of the observed sequence is the sum of the forward probabilities over all possible states at the final time $T$:\n$$\nL = \\Pr(I(0{:}T)) = \\sum_C \\alpha_T(C)\n$$\n\n### Implementation Strategy\n\nThe algorithm is implemented as follows:\n1.  **State Space Generation**: All $3^n$ states and their properties (number of infected nodes, number of infected neighbors for each node) are pre-calculated.\n2.  **Transition Matrix**: The state transition probability matrix $\\mathbf{P}$ with entries $P_{ij} = a_{C_i, C_j}$ is pre-computed. This is a $3^n \\times 3^n$ matrix.\n3.  **Forward Pass**: The vector of forward probabilities $\\boldsymbol{\\alpha}_t$ is initialized at $t=0$. Then, for each time step up to $T-1$, the next vector $\\boldsymbol{\\alpha}_{t+1}$ is computed by summing contributions from all states at time $t$, filtered by the observation $I(t+1)$. This is effectively a matrix-vector multiplication, $\\boldsymbol{\\alpha}_{t+1} \\gets \\boldsymbol{\\alpha}_{t} \\mathbf{P}$, followed by filtering.\n4.  **Likelihood Calculation**: The final likelihood is the sum of the elements in the final vector $\\boldsymbol{\\alpha}_T$.\n5.  **Ratio Computation**: The procedure is run twice: once for the SI model (with $\\gamma=0$) to get $L_{\\text{SI}}$, and once for the SIR model (with the given $\\gamma > 0$) to get $L_{\\text{SIR}}$. The ratio $\\Lambda=L_{\\text{SI}}/L_{\\text{SIR}}$ is then computed, handling cases where $L_{\\text{SIR}}=0$.\n\nThis approach provides an exact solution, as required, and is feasible for the small network sizes specified in the problem.",
            "answer": "```python\nimport numpy as np\n\ndef _compute_likelihood(A, beta, gamma, I_seq):\n    \"\"\"\n    Computes the likelihood of an observed sequence of infected counts\n    using a forward algorithm on the exact state-space Markov chain.\n\n    Args:\n        A (np.ndarray): Adjacency matrix of the network.\n        beta (float): Per-edge transmission probability.\n        gamma (float): Recovery probability.\n        I_seq (list): Sequence of observed infected counts.\n\n    Returns:\n        float: The likelihood of the observation sequence.\n    \"\"\"\n    n = A.shape[0]\n    T = len(I_seq) - 1\n    num_states = 3**n\n\n    # 1. Pre-computation of state properties\n    # Each state is an integer from 0 to 3^n - 1.\n    # We map state_idx -> {config, num_I, m_counts}\n    # config is a tuple of node states (0:S, 1:I, 2:R)\n    states_info = []\n    for i in range(num_states):\n        \n        # Convert index to base-3 configuration\n        config = []\n        temp_i = i\n        for _ in range(n):\n            state = temp_i % 3\n            config.append(state)\n            temp_i //= 3\n        config = tuple(config)\n        num_I = config.count(1)\n        \n        # For each susceptible node, count its infected neighbors\n        m_counts = []\n        for j in range(n):\n            m_j = 0\n            if config[j] == 0:\n                for k in range(n):\n                    if A[j, k] == 1 and config[k] == 1:\n                        m_j += 1\n            m_counts.append(m_j)\n        \n        states_info.append({\n            'num_I': num_I,\n            'm_counts': tuple(m_counts)\n        })\n\n    # 2. Pre-computation of the transition probability matrix P[C, C']\n    P = np.zeros((num_states, num_states), dtype=np.float64)\n    for idx_C in range(num_states):\n        C_m_counts = states_info[idx_C]['m_counts']\n        # Convert indices to configurations to calculate transitions\n        C_config_temp, C_idx_temp = [], idx_C\n        for _ in range(n):\n            C_config_temp.append(C_idx_temp % 3); C_idx_temp //= 3\n\n        for idx_C_prime in range(num_states):\n            C_prime_config_temp, C_prime_idx_temp = [], idx_C_prime\n            for _ in range(n):\n                C_prime_config_temp.append(C_prime_idx_temp % 3); C_prime_idx_temp //= 3\n            \n            prob = 1.0\n            possible = True\n            for j in range(n):\n                c_j, c_j_prime = C_config_temp[j], C_prime_config_temp[j]\n                \n                if c_j == 0:  # Susceptible\n                    m_j = C_m_counts[j]\n                    p_inf = 1.0 - (1.0 - beta)**m_j\n                    if c_j_prime == 1: prob *= p_inf\n                    elif c_j_prime == 0: prob *= (1.0 - p_inf)\n                    else: possible = False; break\n                elif c_j == 1:  # Infected\n                    if c_j_prime == 1: prob *= (1.0 - gamma)\n                    elif c_j_prime == 2: prob *= gamma\n                    else: possible = False; break\n                elif c_j == 2:  # Removed\n                    if c_j_prime != 2: possible = False; break\n            \n            if possible:\n                P[idx_C, idx_C_prime] = prob\n    \n    # 3. Forward Algorithm\n    # Initialization (t=0)\n    alpha = np.zeros(num_states, dtype=np.float64)\n    if I_seq[0] != 1: return 0.0\n        \n    for i in range(num_states):\n        info = states_info[i]\n        is_initial_config = (info['num_I'] == 1 and sum(1 for state in get_config_from_idx(i,n) if state == 0) == n - 1)\n        if is_initial_config:\n            alpha[i] = 1.0 / n\n\n    # Recursion (t = 0 to T-1)\n    for t in range(T):\n        alpha_next = np.zeros(num_states, dtype=np.float64)\n        I_t_plus_1 = I_seq[t + 1]\n        \n        # Effective matrix-vector product filtered by observation\n        alpha_next = alpha @ P\n        \n        # Filter based on observation I(t+1)\n        for i in range(num_states):\n            if states_info[i]['num_I'] != I_t_plus_1:\n                alpha_next[i] = 0.0\n        \n        alpha = alpha_next\n        if np.sum(alpha) == 0.0: return 0.0\n\n    # 4. Termination\n    return np.sum(alpha)\n    \ndef get_config_from_idx(idx, n):\n    \"\"\" Helper to convert index to config, used in alpha init \"\"\"\n    config = []\n    temp_i = idx\n    for _ in range(n):\n        config.append(temp_i % 3)\n        temp_i //= 3\n    return tuple(config)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], dtype=int),\n            \"beta\": 0.4, \"gamma\": 0.2, \"I_seq\": [1, 2, 3, 4]\n        },\n        {\n            \"A\": np.array([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], dtype=int),\n            \"beta\": 0.2, \"gamma\": 0.5, \"I_seq\": [1, 1, 1, 1]\n        },\n        {\n            \"A\": np.array([[0, 1, 1, 1, 1], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0]], dtype=int),\n            \"beta\": 0.35, \"gamma\": 0.3, \"I_seq\": [1, 2, 1, 1]\n        },\n        {\n            \"A\": np.array([[0, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=int),\n            \"beta\": 0.7, \"gamma\": 0.4, \"I_seq\": [1, 1, 1]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A, beta, gamma, I_seq = case[\"A\"], case[\"beta\"], case[\"gamma\"], case[\"I_seq\"]\n        \n        L_si = _compute_likelihood(A, beta, 0.0, I_seq)\n        L_sir = _compute_likelihood(A, beta, gamma, I_seq)\n\n        if L_sir == 0.0:\n            if L_si > 0.0:\n                ratio_str = 'inf'\n            else:  # Both L_si and L_sir are 0\n                ratio_str = 'nan'\n        else:\n            ratio = L_si / L_sir\n            ratio_str = f\"{ratio:.6f}\"\n        \n        results.append(ratio_str)\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}