{
    "hands_on_practices": [
        {
            "introduction": "流行病在爆发初期的指数增长是其最显著的特征之一。这个增长率并非凭空而来，而是由疾病本身的传播参数和人群接触网络的结构共同决定的。本练习将理论与实践相结合，要求您通过计算来验证一个核心概念：网络的谱半径（可以看作是网络结构的一个关键指标）如何决定了流行病的早期增长率 ()。通过这个动手实践，您将深刻理解下一代矩阵 (Next-Generation Matrix) 在连接微观参数与宏观动态中的桥梁作用。",
            "id": "3124341",
            "problem": "本题要求您通过下一代矩阵 (NGM) 将流行病早期的指数增长与接触网络的结构联系起来，并通过直接计算的时间序列来验证该预测。请在以下设定下进行操作。\n\n使用的基本原理和定义：\n- 在一个具有邻接矩阵 $A$、每次接触的传播率 $\\beta$ (单位 $\\text{day}^{-1}$) 和恢复率 $\\gamma$ (单位 $\\text{day}^{-1}$) 的静态、无向接触网络上，对于一个 SIR（易感-感染-恢复）过程的早期阶段，期望感染状态向量 $i(t)$ 的演化遵循以下线性常微分方程 (ODE)：$$\\frac{d}{dt} i(t) = \\left(\\beta A - \\gamma I\\right) i(t),$$ 其中 $I$ 是单位矩阵，$i(t)$ 是每个节点的期望感染数向量。这是在感染比例很小时有效的标准线性化方法。\n- 下一代矩阵 (NGM) $K$ 定义为在早期阶段，单个感染者在其整个传染期内沿边产生的期望二代感染数。在这种具有指数分布传染期的网络设定下，$K$ 由下式给出：$$K = \\frac{\\beta}{\\gamma} A.$$ $K$ 的主特征值（谱半径）记为 $\\rho(K)$。\n- 总感染量定义为 $$I_{\\text{tot}}(t) = \\sum_{j} i_j(t).$$ 在早期阶段，我们预期 $$I_{\\text{tot}}(t) \\approx I_0 e^{r t},$$ 其中 $r$ 是早期指数增长率 (单位 $\\text{day}^{-1}$)，$I_0$ 是一个常数。\n\n您的任务：\n1. 根据基本原理和上述基础，推导出一个从 $K$ 的主特征值计算早期指数增长率 $r$ 的方法。\n2. 通过从线性 ODE 生成时间序列来独立估计 $r$。请使用以下协议以确保结果可复现且完全指定：\n   - 使用初始条件 $$i(0) = \\frac{1}{N} \\mathbf{1},$$ 其中 $N$ 是节点数，$\\mathbf{1}$ 是全1向量，因此 $$I_{\\text{tot}}(0) = 1.$$\n   - 使用矩阵指数精确地演化线性 ODE 的解：$$i(t) = \\exp\\left[\\left(\\beta A - \\gamma I\\right) t\\right] i(0).$$\n   - 在 $t_{\\min}$ 到 $t_{\\max}$ 范围内以步长 $\\Delta t$ 均匀采样时间，其中 $$t_{\\min} = 0.5\\ \\text{天},\\quad t_{\\max} = 8.0\\ \\text{天},\\quad \\Delta t = 0.05\\ \\text{天}.$$\n   - 使用自然对数构建 $y(t) = \\ln I_{\\text{tot}}(t)$，并通过对采样时间点上的 $y(t)$ 与 $t$ 进行普通最小二乘法 (OLS) 线性回归，将斜率作为 $r_{\\text{fit}}$ 的估计值。\n3. 对于下方的每个测试用例，计算绝对差 $|\\r_{\\text{fit}} - r_{\\text{theory}}|$，其中 $r_{\\text{theory}}$ 是从 $K$ 的主特征值计算出的早期增长率，$r_{\\text{fit}}$ 是基于回归的估计值。\n\n测试套件（所有率的单位均为 $\\text{day}^{-1}$，时间单位为天）：\n- 用例 $1$（长度为 $4$ 的路径图）：$$A_1 = \\begin{bmatrix} 0  1  0  0 \\\\ 1  0  1  0 \\\\ 0  1  0  1 \\\\ 0  0  1  0 \\end{bmatrix},\\quad \\beta_1 = 0.5,\\quad \\gamma_1 = 0.4.$$\n- 用例 $2$（$3$ 个节点上的完全图）：$$A_2 = \\begin{bmatrix} 0  1  1 \\\\ 1  0  1 \\\\ 1  1  0 \\end{bmatrix},\\quad \\beta_2 = 0.3,\\quad \\gamma_2 = 0.6.$$\n- 用例 $3$（$5$ 个节点上的星形图，节点 $0$ 是中心节点）：$$A_3 = \\begin{bmatrix} 0  1  1  1  1 \\\\ 1  0  0  0  0 \\\\ 1  0  0  0  0 \\\\ 1  0  0  0  0 \\\\ 1  0  0  0  0 \\end{bmatrix},\\quad \\beta_3 = 0.2,\\quad \\gamma_3 = 0.5.$$\n\n程序要求行为：\n- 为所有三个用例实现上述计算。\n- 您的程序必须输出单行，其中包含一个用方括号括起来的、逗号分隔的三个绝对差列表，顺序为用例 1、2、3。每个数字必须精确到 $6$ 位小数。例如，输出格式应如下所示：`[0.000123,0.000000,0.000457]`",
            "solution": "用户的要求是验证网络上流行病早期指数增长率与下一代矩阵 (NGM) 谱性质之间的关系。这涉及两个主要任务：首先，从 NGM 的主特征值推导理论增长率 $r_{\\text{theory}}$；其次，通过拟合从线性化流行病动态生成的时间序列来估计增长率 $r_{\\text{fit}}$。最后，需要为三种特定的网络结构计算这两个量之间的绝对差。\n\n### 第1步：理论增长率 ($r_{\\text{theory}}$) 推导\n\n分析始于为每个节点的期望感染人数 $i(t)$ 提供的线性常微分方程 (ODE) 系统：\n$$ \\frac{d}{dt} i(t) = (\\beta A - \\gamma I) i(t) $$\n其中 $A$ 是邻接矩阵，$\\beta$ 是传播率，$\\gamma$ 是恢复率，$I$ 是单位矩阵。我们定义矩阵 $M = \\beta A - \\gamma I$。于是该系统为 $\\frac{d}{dt} i(t) = M i(t)$。\n\n这是一个线性、一阶、齐次、常系数的常微分方程组。其通解可以表示为其基本模式的线性组合。如果 $\\{\\lambda_j\\}$ 和 $\\{v_j\\}$ 是 $M$ 的特征值和对应特征向量的集合，则解由下式给出：\n$$ i(t) = \\sum_j c_j v_j e^{\\lambda_j t} $$\n其中系数 $c_j$ 由初始条件 $i(0)$ 决定。\n\n对于较大的 $t$，对应于最大特征值 $\\lambda_{\\text{max}} = \\rho(M)$（$M$ 的谱半径）的项将主导总和，前提是其初始分量 $c_{\\text{max}}$ 非零。\n$$ i(t) \\approx c_{\\text{max}} v_{\\text{max}} e^{\\lambda_{\\text{max}} t} \\quad \\text{for } t \\to \\infty $$\n总感染人数为 $I_{\\text{tot}}(t) = \\mathbf{1}^T i(t)$，其中 $\\mathbf{1}$ 是全1向量。在早期阶段，由主导模式驱动，此式变为：\n$$ I_{\\text{tot}}(t) \\approx (c_{\\text{max}} \\mathbf{1}^T v_{\\text{max}}) e^{\\lambda_{\\text{max}} t} $$\n将其与预期的指数增长形式 $I_{\\text{tot}}(t) \\approx I_0 e^{rt}$ 进行比较，我们将早期指数增长率 $r$ 与 $M$ 的主特征值等同起来：\n$$ r = \\lambda_{\\text{max}}(M) = \\rho(\\beta A - \\gamma I) $$\n$M$ 的特征值可以与 $A$ 的特征值相关联。如果 $\\mu_j$ 是 $A$ 的特征值，那么 $\\beta A - \\gamma I$ 的特征值是 $\\beta \\mu_j - \\gamma$。因此，主特征值为：\n$$ r = \\beta \\mu_{\\text{max}} - \\gamma = \\beta \\rho(A) - \\gamma $$\n其中 $\\rho(A)$ 是邻接矩阵 $A$ 的谱半径。\n\n下一代矩阵由 $K = \\frac{\\beta}{\\gamma} A$ 给出。$K$ 的特征值是 $\\frac{\\beta}{\\gamma} \\mu_j$。其主特征值为 $\\rho(K) = \\frac{\\beta}{\\gamma} \\rho(A)$。我们可以用 $\\rho(K)$ 来表示 $\\rho(A)$：$\\rho(A) = \\frac{\\gamma}{\\beta} \\rho(K)$。\n\n将此代入 $r$ 的表达式，我们得到所需的关系：\n$$ r_{\\text{theory}} = \\beta \\left(\\frac{\\gamma}{\\beta} \\rho(K)\\right) - \\gamma = \\gamma \\rho(K) - \\gamma $$\n$$ r_{\\text{theory}} = \\gamma (\\rho(K) - 1) $$\n这个方程将宏观增长率 $r$ 与微观参数 ($\\beta, \\gamma$) 和网络拓扑（体现在 $\\rho(A)$ 中，因此也体现在 $\\rho(K)$ 中）联系起来。当且仅当 $\\rho(K)  1$ 时，流行病会增长 ($r_{\\text{theory}}  0$)，这是众所周知的阈值条件。\n\n### 第2步：增长率的数值估计 ($r_{\\text{fit}}$)\n\n通过数值模拟动态过程并拟合结果，可以获得对 $r$ 的独立估计。\n1.  **求解 ODE**：对于初始条件为 $i(0)$ 的方程 $\\frac{d}{dt} i(t) = M i(t)$，其精确解由矩阵指数给出：\n    $$ i(t) = \\exp(M t) i(0) $$\n    其中 $M = \\beta A - \\gamma I$。初始条件指定为 $i(0) = \\frac{1}{N} \\mathbf{1}$，其中 $N$ 是节点数。\n\n2.  **生成时间序列**：我们在从 $t_{\\min} = 0.5$到 $t_{\\max} = 8.0$ 且步长为 $\\Delta t = 0.05$ 的离散时间点 $t_k$ 上计算 $i(t)$。对于每个 $t_k$，我们计算总感染人口 $I_{\\text{tot}}(t_k) = \\sum_j i_j(t_k)$。\n\n3.  **执行线性回归**：模型 $I_{\\text{tot}}(t) \\approx I_0 e^{rt}$ 可以通过取自然对数进行线性化：\n    $$ y(t) = \\ln I_{\\text{tot}}(t) \\approx \\ln(I_0) + r t $$\n    这是一个形如 $y = c + r t$ 的线性方程。我们通过对数据对 $(t_k, y(t_k))$ 执行普通最小二乘法 (OLS) 线性回归来估计斜率 $r$。所得斜率即为我们的估计值 $r_{\\text{fit}}$。\n\n### 第3步：测试用例计算\n\n对于三个测试用例中的每一个，我们执行以下计算：\n1.  定义邻接矩阵 $A$ 和参数 $\\beta, \\gamma$。\n2.  计算 $r_{\\text{theory}}$：\n    a. 构建 NGM，$K = (\\beta / \\gamma) A$。\n    b. 求其谱半径，$\\rho(K) = \\max_j |\\lambda_j(K)|$。\n    c. 计算 $r_{\\text{theory}} = \\gamma (\\rho(K) - 1)$。\n3.  计算 $r_{\\text{fit}}$：\n    a. 构建动力学矩阵，$M = \\beta A - \\gamma I$。\n    b. 从 $t_{\\min}$ 到 $t_{\\max}$ 生成时间向量 $t$。\n    c. 对每个时间点，计算 $i(t) = \\exp(Mt)i(0)$，然后计算 $I_{\\text{tot}}(t) = \\sum_j i_j(t)$。\n    d. 构建向量 $y(t) = \\ln I_{\\text{tot}}(t)$。\n    e. 求 $y(t)$ 相对于 $t$ 的最佳拟合线的斜率，即为 $r_{\\text{fit}}$。\n4.  计算绝对差 $|r_{\\text{fit}} - r_{\\text{theory}}|$。\n\n$r_{\\text{theory}}$ 和 $r_{\\text{fit}}$ 之间的差异之所以产生，是因为时间序列拟合是在一个有限区间上进行的，在这个区间内，非主导本征模可能仍具有不可忽略的影响，导致 $\\ln I_{\\text{tot}}(t)$ 与完美的直线略有偏差。理论增长率 $r_{\\text{theory}}$ 代表了当 $t \\to \\infty$ 时的渐近增长率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the absolute difference between theoretical and fitted epidemic growth rates\n    for three network test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (path graph of length 4)\n        {\n            \"A\": np.array([\n                [0, 1, 0, 0],\n                [1, 0, 1, 0],\n                [0, 1, 0, 1],\n                [0, 0, 1, 0]\n            ]),\n            \"beta\": 0.5,\n            \"gamma\": 0.4\n        },\n        # Case 2 (complete graph on 3 nodes)\n        {\n            \"A\": np.array([\n                [0, 1, 1],\n                [1, 0, 1],\n                [1, 1, 0]\n            ]),\n            \"beta\": 0.3,\n            \"gamma\": 0.6\n        },\n        # Case 3 (star graph on 5 nodes)\n        {\n            \"A\": np.array([\n                [0, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0]\n            ]),\n            \"beta\": 0.2,\n            \"gamma\": 0.5\n        }\n    ]\n\n    results = []\n    \n    # Define time sampling parameters\n    t_min = 0.5\n    t_max = 8.0\n    dt = 0.05\n    # Use np.arange which handles floating point steps robustly\n    t_vals = np.arange(t_min, t_max + dt/2, dt)\n\n    for case in test_cases:\n        A = case[\"A\"]\n        beta = case[\"beta\"]\n        gamma = case[\"gamma\"]\n        N = A.shape[0]\n\n        # 1. Compute theoretical growth rate (r_theory)\n        # Construct the Next-Generation Matrix K\n        K = (beta / gamma) * A\n        \n        # Find the spectral radius of K (leading eigenvalue)\n        # For non-negative matrices (like A and K), the spectral radius is an eigenvalue\n        eigvals_K = np.linalg.eigvals(K)\n        rho_K = np.max(np.abs(eigvals_K))\n        \n        # Calculate r_theory\n        r_theory = gamma * (rho_K - 1)\n\n        # 2. Compute fitted growth rate (r_fit)\n        # Construct the dynamics matrix M\n        M = beta * A - gamma * np.identity(N)\n        \n        # Define initial condition\n        i0 = np.ones(N) / N\n        \n        I_tot_vals = []\n        for t in t_vals:\n            # Evolve the system using the matrix exponential\n            exp_Mt = expm(M * t)\n            i_t = exp_Mt @ i0\n            \n            # Calculate total infected\n            I_tot_t = np.sum(i_t)\n            I_tot_vals.append(I_tot_t)\n        \n        # Take natural log for linear regression\n        y_vals = np.log(np.array(I_tot_vals))\n        \n        # Perform Ordinary Least Squares regression to find the slope\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        coeffs = np.polyfit(t_vals, y_vals, 1)\n        r_fit = coeffs[0]\n\n        # 3. Compute the absolute difference\n        diff = np.abs(r_fit - r_theory)\n        results.append(diff)\n\n    # Final print statement in the exact required format.\n    # Each number is rounded to exactly 6 decimal places.\n    print(f\"[{','.join([f'{x:.6f}' for x in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在应对公共卫生危机时，资源（如检测试剂）往往是有限的，如何高效地分配这些资源至关重要。网络科学为我们提供了强有力的工具来指导决策。本练习模拟了一个实际场景：您需要设计并评估不同的病毒检测策略，其中一种策略是基于网络中心性（具体来说是度中心性）进行“靶向”检测 ()。通过比较不同策略的效率，您将亲身体会到，理解网络中哪些节点是“关键”的，对于制定更智能、更有效的干预措施有多么重要。",
            "id": "3124329",
            "problem": "考虑一个由 $N$ 个节点组成的简单、无向、无权网络，其邻接矩阵为 $\\mathbf{A} \\in \\{0,1\\}^{N \\times N}$，其中 $\\mathbf{A}_{ii} = 0$。设节点 $i$ 的度中心性 (DC) 定义为 $c_i = \\sum_{j=1}^{N} \\mathbf{A}_{ij}$。假设每条边独立地携带一次暴露，导致感染的概率为 $\\alpha \\in [0,1]$。在各条边独立的假设下，节点 $i$ 在快照时间被感染的概率为 $q_i$，该概率取决于 $c_i$ 和 $\\alpha$。假设测试是完美的：如果存在感染，测试总能检测到，并且没有假阳性或假阴性。\n\n有一个测试预算 $B \\in \\mathbb{N}_0$ 可用。考虑以下选择要测试的节点的策略：\n\n- 策略 $\\mathcal{T}$ (目标性，有放回)：进行 $B$ 次独立抽取 (有放回)。每次抽取时，以与 $c_i$ 成正比的概率选择节点 $i$。如果 $\\sum_{j=1}^{N} c_j = 0$，则将选择概率解释为在所有节点上均匀分布。如果一个节点在 $B$ 次抽取中至少出现一次，则认为该节点被“测试”。\n- 策略 $\\mathcal{U}$ (均匀，有放回)：进行 $B$ 次独立抽取 (有放回)，每次抽取从 $N$ 个节点中均匀随机地选择一个节点。如果一个节点在 $B$ 次抽取中至少出现一次，则认为该节点被“测试”。\n- 策略 $\\mathcal{D}$ (确定性前 $B$ 个，无放回)：选择最多 $B$ 个具有最大 $c_i$ 值的不同节点 (平局则按节点索引递增的顺序打破)，并对每个节点进行恰好一次测试。如果 $B \\ge N$，则测试所有 $N$ 个节点。\n\n你的任务是计算对于每种策略，通过测试检测到的受感染节点的期望数量。计算必须从边暴露的独立性和度中心性的定义开始，并且必须通过重复独立抽样的概率法则和用于检测的集合包含关系进行。在问题陈述中不应假设任何快捷公式；在你的解答和程序设计中，从第一性原理推导出所需的量。\n\n使用以下测试套件。对于每种情况，都指定了 $\\mathbf{A}$ 以及 $B$ 和 $\\alpha$。节点索引从 $0$ 到 $N-1$。\n\n- 情况 1 (一般连通网络，中等预算)：$N = 6$，\n$$\n\\mathbf{A}^{(1)} = \\begin{bmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  1  0  0 \\\\\n1  1  0  1  0  0 \\\\\n0  1  1  0  1  0 \\\\\n0  0  0  1  0  1 \\\\\n0  0  0  0  1  0\n\\end{bmatrix},\\quad B^{(1)} = 3,\\quad \\alpha^{(1)} = 0.2.\n$$\n\n- 情况 2 (度中心性相等的正则图)：$N = 5$，\n$$\n\\mathbf{A}^{(2)} = \\begin{bmatrix}\n0  1  0  0  1 \\\\\n1  0  1  0  0 \\\\\n0  1  0  1  0 \\\\\n0  0  1  0  1 \\\\\n1  0  0  1  0\n\\end{bmatrix},\\quad B^{(2)} = 4,\\quad \\alpha^{(2)} = 0.3.\n$$\n\n- 情况 3 (边界预算)：重用 $\\mathbf{A}^{(1)}$，但 $B^{(3)} = 0$ 且 $\\alpha^{(3)} = 0.7$。\n\n- 情况 4 (星形网络，大预算)：$N = 6$，\n$$\n\\mathbf{A}^{(4)} = \\begin{bmatrix}\n0  1  1  1  1  1 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0\n\\end{bmatrix},\\quad B^{(4)} = 20,\\quad \\alpha^{(4)} = 0.1.\n$$\n\n对于每种情况，计算三个值：在策略 $\\mathcal{T}$、$\\mathcal{U}$ 和 $\\mathcal{D}$ 下检测到的受感染节点的期望数量。你的程序应该生成单行输出，其中包含四个案例的结果，格式为逗号分隔的列表的列表，每个内部列表的顺序为 $[r_{1,\\mathcal{T}},r_{1,\\mathcal{U}},r_{1,\\mathcal{D}}]$，并且每个数值都打印到小数点后六位，例如\n$[[r_{1,\\mathcal{T}},r_{1,\\mathcal{U}},r_{1,\\mathcal{D}}],[r_{2,\\mathcal{T}},r_{2,\\mathcal{U}},r_{2,\\mathcal{D}}],[r_{3,\\mathcal{T}},r_{3,\\mathcal{U}},r_{3,\\mathcal{D}}],[r_{4,\\mathcal{T}},r_{4,\\mathcal{U}},r_{4,\\mathcal{D}}]]$。\n不涉及物理单位。所有结果都以实数（浮点数）表示。计算必须与上述独立性假设在科学上保持一致。",
            "solution": "该问题被评估为有效，因为它在科学上基于概率论和网络科学，问题是适定的，并以客观、正式的语言表达。它是自洽的，提供了所有必要的数据和定义。因此，我们可以开始解答。\n\n目标是计算对于三种不同的测试策略，检测到的受感染节点的期望数量，记为 $E[X]$。设 $N$ 为网络中的节点数。设 $I_i$ 为指示随机变量，对应于节点 $i$ 被感染的事件；$T_i$ 为指示随机变量，对应于节点 $i$ 被测试的事件。检测到的受感染节点的数量是 $X = \\sum_{i=0}^{N-1} I_i T_i$。\n\n根据期望的线性性质，检测到的受感染节点的期望数量是：\n$$ E[X] = E\\left[\\sum_{i=0}^{N-1} I_i T_i\\right] = \\sum_{i=0}^{N-1} E[I_i T_i] $$\n指示变量的期望是它所指示事件的概率。因此，$E[I_i T_i] = P(I_i=1 \\text{ and } T_i=1)$。节点的感染状态由网络属性和感染概率 $\\alpha$ 决定，而测试状态由测试策略和预算 $B$ 决定。这两个过程是独立的。因此，我们可以写出：\n$$ P(I_i=1 \\text{ and } T_i=1) = P(I_i=1) \\cdot P(T_i=1) $$\n让我们将 $q_i = P(I_i=1)$ 记为节点 $i$ 被感染的概率，将 $p_{\\text{test},i} = P(T_i=1)$ 记为节点 $i$ 被测试的概率。那么检测到的受感染节点的期望数量为：\n$$ E[X] = \\sum_{i=0}^{N-1} q_i \\cdot p_{\\text{test},i} $$\n我们现在必须从第一性原理为每种策略推导 $q_i$ 和 $p_{\\text{test},i}$ 的表达式。\n\n**1. 感染概率 ($q_i$) 的推导**\n问题陈述中指出，每条边独立地携带一次暴露，导致感染的概率为 $\\alpha$。如果节点 $i$ 的至少一个邻居传播了感染，则该节点被感染。计算其互补事件的概率更直接：节点 $i$ *未*被感染。这种情况发生当且仅当其*所有*邻居都*没有*传播感染。\n\n设 $c_i$ 为节点 $i$ 的度中心性，即其邻居的数量。\n$$ c_i = \\sum_{j=0}^{N-1} A_{ij} $$\n对于单个邻居，*不*传播感染的概率是 $(1-\\alpha)$。由于来自所有 $c_i$ 个邻居的暴露是独立事件，它们中没有任何一个将感染传播给节点 $i$ 的概率是它们各自不传播概率的乘积：\n$$ P(I_i=0) = (1-\\alpha)^{c_i} $$\n节点 $i$ 被感染的概率 $q_i$ 是该事件的补集：\n$$ q_i = P(I_i=1) = 1 - P(I_i=0) = 1 - (1-\\alpha)^{c_i} $$\n\n**2. 每种策略的测试概率 ($p_{\\text{test},i}$) 的推导**\n\n**策略 $\\mathcal{T}$ (目标性，有放回):**\n在此策略中，进行 $B$ 次独立测试。对于每次测试，以与其度中心性 $c_i$ 成正比的概率 $p_i^{(\\mathcal{T})}$ 选择节点 $i$。\n$$ p_i^{(\\mathcal{T})} = \\frac{c_i}{\\sum_{j=0}^{N-1} c_j} $$\n如果总度数和 $\\sum_{j=0}^{N-1} c_j = 0$ (一个没有边的网络)，选择概率是均匀的：$p_i^{(\\mathcal{T})} = 1/N$。设 $C_{\\text{tot}} = \\sum_{j=0}^{N-1} c_j$。\n如果一个节点在 $B$ 次抽取中至少被选择一次，则认为该节点被测试。在单次抽取中节点 $i$ *未*被选择的概率是 $(1 - p_i^{(\\mathcal{T})})$。由于 $B$ 次抽取是独立的，节点 $i$ 在 $B$ 次抽取中*从未*被选择的概率是 $(1 - p_i^{(\\mathcal{T})})^B$。\n节点 $i$ 被测试的概率 $p_{\\text{test},i}^{(\\mathcal{T})}$ 是其补集：\n$$ p_{\\text{test},i}^{(\\mathcal{T})} = 1 - \\left(1 - \\frac{c_i}{C_{\\text{tot}}}\\right)^B $$\n(如果 $C_{\\text{tot}}=0$，则按均匀情况处理)。\n\n**策略 $\\mathcal{U}$ (均匀，有放回):**\n这是目标性策略的一个简化版，其中单次抽取中任何节点 $i$ 的选择概率是均匀的：$p_i^{(\\mathcal{U})} = 1/N$。遵循与策略 $\\mathcal{T}$ 相同的逻辑：\n$$ p_{\\text{test},i}^{(\\mathcal{U})} = 1 - \\left(1 - \\frac{1}{N}\\right)^B $$\n注意，这个概率对所有节点都是相同的。\n\n**策略 $\\mathcal{D}$ (确定性前 $B$ 个，无放回):**\n这个策略是确定性的。选择一个固定的节点集合 $S_D$ 进行测试。节点根据其度中心性 $c_i$ 降序排名。平局则通过选择索引较小的节点来打破。从这个排名中选择前 $B$ 个节点。如果 $B \\ge N$，则测试所有节点。\n对于节点 $i$，被测试的“概率”为 1 或 0：\n$$ p_{\\text{test},i}^{(\\mathcal{D})} = \\begin{cases} 1  \\text{if node } i \\in S_D \\\\ 0  \\text{if node } i \\notin S_D \\end{cases} $$\n集合 $S_D$ 包含排名列表中的前 $\\min(B, N)$ 个节点。\n\n**3. 最终计算**\n对于每种策略 $\\mathcal{P} \\in \\{\\mathcal{T}, \\mathcal{U}, \\mathcal{D}\\}$，检测到的受感染节点的期望数量通过对每个节点的贡献求和来计算：\n$$ E[X]_{\\mathcal{P}} = \\sum_{i=0}^{N-1} q_i \\cdot p_{\\text{test},i}^{(\\mathcal{P})} = \\sum_{i=0}^{N-1} \\left(1 - (1-\\alpha)^{c_i}\\right) \\cdot p_{\\text{test},i}^{(\\mathcal{P})} $$\n这个公式，以及 $p_{\\text{test},i}^{(\\mathcal{P})}$ 的具体表达式，被用于实现每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected number of detected infected nodes for four test cases\n    under three different testing policies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [0, 1, 1, 0, 0, 0],\n        [1, 0, 1, 1, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 1, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0, 1],\n        [0, 0, 0, 0, 1, 0]\n    ])\n\n    A2 = np.array([\n        [0, 1, 0, 0, 1],\n        [1, 0, 1, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 0]\n    ])\n\n    A4 = np.array([\n        [0, 1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0]\n    ])\n\n    test_cases = [\n        (A1, 3, 0.2),  # Case 1\n        (A2, 4, 0.3),  # Case 2\n        (A1, 0, 0.7),  # Case 3\n        (A4, 20, 0.1)  # Case 4\n    ]\n\n    results = []\n    for A, B, alpha in test_cases:\n        case_results = _calculate_expected_detections(A, B, alpha)\n        results.append(case_results)\n    \n    # Format the final output string as specified.\n    outer_list = []\n    for inner_list in results:\n        formatted_inner = [f\"{v:.6f}\" for v in inner_list]\n        outer_list.append(f\"[{','.join(formatted_inner)}]\")\n    final_output = f\"[{','.join(outer_list)}]\"\n\n    print(final_output)\n\ndef _calculate_expected_detections(A, B, alpha):\n    \"\"\"\n    Calculates the expected detections for a single case (A, B, alpha).\n    Returns a list of three float values for policies T, U, and D.\n    \"\"\"\n    N = A.shape[0]\n    \n    # 1. Calculate degree centrality and infection probabilities\n    degrees = np.sum(A, axis=1)\n    q = 1 - (1 - alpha)**degrees\n    \n    # --- Policy T (Targeted, with replacement) ---\n    total_degree = np.sum(degrees)\n    if B == 0:\n        p_test_T = np.zeros(N)\n    elif total_degree == 0:\n        # Uniform selection if no edges exist\n        p_draw_T = np.full(N, 1/N)\n        p_test_T = 1 - (1 - p_draw_T)**B\n    else:\n        p_draw_T = degrees / total_degree\n        p_test_T = 1 - (1 - p_draw_T)**B\n    \n    exp_detected_T = np.sum(q * p_test_T)\n\n    # --- Policy U (Uniform, with replacement) ---\n    if B == 0:\n        p_test_U_scalar = 0.0\n    else:\n        p_test_U_scalar = 1 - (1 - 1/N)**B\n    \n    exp_detected_U = np.sum(q) * p_test_U_scalar\n\n    # --- Policy D (Deterministic top-B, without replacement) ---\n    exp_detected_D = 0.0\n    if B > 0:\n        # Sort nodes by degree (desc) and then index (asc)\n        node_indices = np.arange(N)\n        # We sort by (-degree, index)\n        ranked_nodes = sorted(node_indices, key=lambda i: (-degrees[i], i))\n        \n        # Select top min(B, N) nodes to test\n        nodes_to_test = ranked_nodes[:min(B, N)]\n        \n        # Sum infection probabilities for tested nodes\n        exp_detected_D = np.sum(q[nodes_to_test])\n        \n    return [exp_detected_T, exp_detected_U, exp_detected_D]\n\nsolve()\n```"
        },
        {
            "introduction": "在现实世界中，我们观测到的流行病数据往往是不完整的，甚至连疾病的基本传播机制（例如，感染后是否会获得永久免疫）也可能是未知的。本练习将您置于一个计算流行病学家的角色，面对的正是这样的挑战：仅根据观察到的总感染人数时间序列，您能否区分两种不同的传播模型（$SI$ 模型与 $SIR$ 模型）？这个高级练习 () 将引导您使用隐马尔可夫模型 ($HMM$) 和前向算法等严谨的统计推断方法，来计算不同模型的“似然性”，从而为模型选择提供定量的证据。",
            "id": "3124380",
            "problem": "给定一个无向简单网络，其邻接矩阵为 $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$，其中 $\\mathbf{A}$ 的对角线元素为零且该矩阵是对称的。考虑网络上的两种流行病过程：易感-感染 (SI) 模型和易感-感染-移除 (SIR) 模型。时间是离散的，由 $t \\in \\{0,1,2,\\ldots,T\\}$ 索引。每个节点在时间 $t$ 的状态为 $S$ (易感)、$I$ (感染) 或 $R$ (移除) 之一。系统根据以下动态同步演化，假设在给定时间 $t$ 的当前状态下，各节点之间是独立的：\n\n1. 感染事件：对于任何在时间 $t$ 处于易感状态的节点 $j$，令 $m_j(t)$ 为其在时间 $t$ 的受感染邻居数量。在从 $t$ 到 $t+1$ 的时间间隔内，每个受感染的邻居以每条边 $\\beta \\in [0,1]$ 的概率独立地尝试传播。节点 $j$ 在时间 $t+1$ 前变为感染状态的概率为\n$$\np_{\\text{inf}}(j,t) \\;=\\; 1 - (1-\\beta)^{m_j(t)}.\n$$\n\n2. 恢复事件：在易感-感染-移除 (SIR) 模型中，每个受感染的节点在同一时间间隔内以概率 $\\gamma \\in [0,1]$ 独立恢复，并在时间 $t+1$ 前变为移除状态。在易感-感染 (SI) 模型中，不会发生恢复，这通过设置 $\\gamma = 0$ 来建模。移除状态的节点一旦产生，将永远保持移除状态。\n\n假设更新是同步的，传播尝试源于在时间 $t$ 处于感染状态的节点，无论它们是否在时间 $t+1$ 前恢复。在时间 $t+1$ 新感染的节点直到下一个步骤才能感染其他节点。\n\n观测模型与先验：您只能观察到每个时刻受感染节点的总数，记为 $I(t)$，其中 $t \\in \\{0,1,\\ldots,T\\}$，但无法观察到具体是哪些节点被感染。在时间 $t=0$ 时，恰好有一个节点被感染，所有其他节点均为易感状态。初始感染节点的身份是未知的，并假设在 $n$ 个节点上均匀分布，与网络结构无关。因此，初始节点级状态的先验为：对于任何恰好有一个感染节点且没有移除节点的配置，其概率为 $1/n$。\n\n任务：设计并实现一个程序，给定 $\\mathbf{A}$、$\\beta$、$\\gamma$ (用于 SIR 模型) 以及观测序列 $I(0), I(1), \\ldots, I(T)$，计算在易感-感染 (SI) 模型下的似然 $L_{\\text{SI}} = \\Pr(I(0{:}T)\\mid \\text{SI}, \\mathbf{A}, \\beta)$ 和在易感-感染-移除 (SIR) 模型下的似然 $L_{\\text{SIR}} = \\Pr(I(0{:}T)\\mid \\text{SIR}, \\mathbf{A}, \\beta, \\gamma)$。使用这些似然值计算似然比\n$$\n\\Lambda \\;=\\; \\frac{L_{\\text{SI}}}{L_{\\text{SIR}}}.\n$$\n通过将节点级流行病视为所有节点级配置上的有限状态马尔可夫链，并使用前向动态规划方法对所有与观测过程一致的隐藏路径求和，来精确计算这些似然。不要通过模拟进行近似，也不要假设超出模型所隐含的条件独立性之外的任何因子分解。观测值 $I(t)$ 是时间 $t$ 隐藏状态的一个确定性函数，即处于状态 $I$ 的节点数量。\n\n测试套件：您的程序必须为以下 $4$ 个测试案例中的每一个计算 $\\Lambda$。在每个案例中，网络 $\\mathbf{A}$ 都是无向且简单的。易感-感染 (SI) 模型使用给定的 $\\beta$ 并设置 $\\gamma = 0$。易感-感染-移除 (SIR) 模型使用给定的 $\\beta$ 和 $\\gamma$。每个案例都指定了观测序列 $I(0{:}T)$。\n\n案例 #1:\n- $n = 4$ 且\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0  1  0  0\\\\\n1  0  1  0\\\\\n0  1  0  1\\\\\n0  0  1  0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.4$, $\\gamma = 0.2$。\n- $I(0{:}3) = [\\,1,\\,2,\\,3,\\,4\\,]$。\n\n案例 #2:\n- $n = 4$ 且\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0  1  0  0\\\\\n1  0  1  0\\\\\n0  1  0  1\\\\\n0  0  1  0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.2$, $\\gamma = 0.5$。\n- $I(0{:}3) = [\\,1,\\,1,\\,1,\\,1\\,]$。\n\n案例 #3:\n- $n = 5$ 且\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0  1  1  1  1\\\\\n1  0  0  0  0\\\\\n1  0  0  0  0\\\\\n1  0  0  0  0\\\\\n1  0  0  0  0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.35$, $\\gamma = 0.3$。\n- $I(0{:}3) = [\\,1,\\,2,\\,1,\\,1\\,]$。\n\n案例 #4:\n- $n = 3$ 且\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0  0  0\\\\\n0  0  0\\\\\n0  0  0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.7$, $\\gamma = 0.4$。\n- $I(0{:}2) = [\\,1,\\,1,\\,1\\,]$。\n\n最终输出规范：您的程序应生成单行输出，其中包含案例 #1 到 #4 的似然比，按顺序排列，形式为用方括号括起来的逗号分隔列表。每个有限结果必须打印为四舍五入到小数点后恰好 $6$ 位的小数。如果 $L_{\\text{SIR}} = 0$ 且 $L_{\\text{SI}}  0$，则打印 $\\,\\text{inf}\\,$。如果 $L_{\\text{SI}} = 0$ 且 $L_{\\text{SIR}} = 0$，则打印 $\\,\\text{nan}\\,$。例如，一个有效的输出格式是\n$ [\\,x_1, x_2, x_3, x_4\\,] $，\n其中每个 $x_k$ 是一个具有 $6$ 位小数的浮点数，或者是指定的 $\\,\\text{inf}\\,$ 或 $\\,\\text{nan}\\,$。此任务不涉及任何物理单位或角度。",
            "solution": "该问题要求计算两种流行病模型——易感-感染 (SI) 和易感-感染-移除 (SIR)——的似然比 $\\Lambda = L_{\\text{SI}} / L_{\\text{SIR}}$，给定一个观测序列，该序列包含总感染人数 $I(0), \\ldots, I(T)$。任务的核心是计算在每种模型下此观测序列的似然 $\\Pr(I(0{:}T))$。由于具体被感染的节点身份是未知的，这是一个隐马尔可夫模型 (HMM) 中的推断问题。该解决方案使用前向动态规划算法来精确计算所需的似然。\n\n### 隐马尔可夫模型公式化\n\n该系统可描述为一个具有以下组件的隐马尔可夫模型：\n\n1.  **隐藏状态**：时间 $t$ 的一个隐藏状态，记为 $C_t$，是网络中所有 $n$ 个节点状态的完整配置。每个节点可以处于三种状态之一：易感 ($S$)、感染 ($I$) 或移除 ($R$)。我们可以将一个配置表示为一个向量 $C = (c_1, c_2, \\ldots, c_n)$，其中 $c_i \\in \\{S, I, R\\}$。隐藏状态的总数为 $3^n$。为了计算方便，我们将每个状态 $\\{S, I, R\\}$ 映射到一个整数 $\\{0, 1, 2\\}$，并通过三进制编码将每个配置 $C$ 表示为 $[0, 3^n-1]$ 范围内的唯一整数索引：$\\text{idx}(C) = \\sum_{i=1}^n c_i 3^{i-1}$。\n\n2.  **观测**：时间 $t$ 的观测是 $O_t = I(t)$，即总感染节点数。观测是隐藏状态 $C_t$ 的一个确定性函数。令 $N_I(C)$ 为配置 $C$ 中感染节点的数量。\n\n3.  **初始状态概率**：初始状态 $C_0$ 在 $t=0$ 时的先验分布是给定的。恰好有一个节点被感染，所有其他节点均为易感状态。这个初始节点的身份是从 $n$ 个节点中随机均匀选择的。因此，初始配置 $C_0$ 的概率为：\n    $$\n    \\Pr(C_0) = \\begin{cases} 1/n  \\text{若 } N_I(C_0)=1 \\text{ 且 } N_R(C_0)=0 \\\\ 0  \\text{否则} \\end{cases}\n    $$\n    其中 $N_R(C_0)$ 是 $C_0$ 中移除节点的数量。\n\n4.  **转移概率**：转移概率 $a_{C,C'} = \\Pr(C_{t+1}=C' \\mid C_t=C)$ 量化了系统的动态。由于在给定配置 $C_t$ 的条件下，节点状态的变化是条件独立的，此概率可在所有节点上因子分解：\n    $$\n    a_{C,C'} = \\prod_{j=1}^n \\Pr(c'_{j} \\mid C_t=C)\n    $$\n    其中 $c'_j$ 是 $C'$ 中节点 $j$ 的状态。单个节点的转移概率 $\\Pr(c'_j \\mid C)$ 由模型动态定义：\n    -   如果节点 $j$ 是易感状态 ($c_j=S$)：它以概率 $p_{\\text{inf}}(j,C) = 1 - (1-\\beta)^{m_j(C)}$ 变为感染状态 ($c'_j=I$)，其中 $m_j(C)$ 是配置 $C$ 中节点 $j$ 的受感染邻居数量。它以概率 $1-p_{\\text{inf}}(j,C)$ 保持易感状态 ($c'_j=S$)。\n    -   如果节点 $j$ 是感染状态 ($c_j=I$)：它以概率 $\\gamma$ 变为移除状态 ($c'_j=R$)。它以概率 $1-\\gamma$ 保持感染状态 ($c'_j=I$)。对于 SI 模型，$\\gamma=0$。\n    -   如果节点 $j$ 是移除状态 ($c_j=R$)：它以概率 $1$ 保持移除状态 ($c'_j=R$)。\n\n5.  **发射概率**：发射概率 $\\Pr(O_t \\mid C_t=C)$ 是确定性的。如果状态 $C$ 中的感染节点数与观测值 $I(t)$ 匹配，则为 $1$，否则为 $0$。\n    $$\n    \\Pr(O_t=I(t) \\mid C_t=C) = \\mathbb{I}(N_I(C) = I(t))\n    $$\n    其中 $\\mathbb{I}(\\cdot)$ 是指示函数。\n\n### 前向算法\n\n为了计算似然 $L = \\Pr(I(0{:}T))$，我们使用前向算法。令 $\\alpha_t(C) = \\Pr(I(0{:}t), C_t=C)$ 为截至时间 $t$ 的观测序列与在时间 $t$ 处于状态 $C$ 的联合概率。\n\n**1. 初始化 ($t=0$):**\n每个状态 $C$ 的初始前向概率是该状态与第一个观测一致的概率。\n$$\n\\alpha_0(C) = \\Pr(I(0), C_0=C) = \\Pr(O_0=I(0) \\mid C_0=C) \\Pr(C_0) = \\mathbb{I}(N_I(C)=I(0)) \\Pr(C_0)\n$$\n根据问题的先验和 $I(0)=1$，对于任何具有一个感染节点和 $n-1$ 个易感节点的 $n$ 种配置，这简化为 $\\alpha_0(C) = 1/n$，对于所有其他配置则为 $0$。\n\n**2. 递归 ($t=0, \\ldots, T-1$):**\n下一个时间步 $t+1$ 的前向概率是根据时间 $t$ 的概率计算得出的：\n$$\n\\alpha_{t+1}(C') = \\left( \\sum_{C} \\alpha_t(C) a_{C,C'} \\right) \\Pr(O_{t+1}=I(t+1) \\mid C_{t+1}=C')\n$$\n发射概率项起到筛选作用：如果 $N_I(C') \\neq I(t+1)$，则 $\\alpha_{t+1}(C') = 0$。否则：\n$$\n\\alpha_{t+1}(C') = \\sum_{C} \\alpha_t(C) a_{C,C'}\n$$\n\n**3. 终止:**\n观测序列的总似然是在最终时间 $T$ 时所有可能状态的前向概率之和：\n$$\nL = \\Pr(I(0{:}T)) = \\sum_C \\alpha_T(C)\n$$\n\n### 实现策略\n\n该算法实现如下：\n1.  **状态空间生成**：预先计算所有 $3^n$ 个状态及其属性（感染节点数、每个节点的感染邻居数）。\n2.  **转移矩阵**：预先计算状态转移概率矩阵 $\\mathbf{P}$，其元素为 $P_{ij} = a_{C_i, C_j}$。这是一个 $3^n \\times 3^n$ 的矩阵。\n3.  **前向传递**：在 $t=0$ 初始化前向概率向量 $\\boldsymbol{\\alpha}_t$。然后，对于直到 $T-1$ 的每个时间步，通过对时间 $t$ 所有状态的贡献求和，并由观测值 $I(t+1)$ 进行筛选，来计算下一个向量 $\\boldsymbol{\\alpha}_{t+1}$。这实际上是一个矩阵-向量乘法 $\\boldsymbol{\\alpha}_{t+1} \\gets \\boldsymbol{\\alpha}_{t} \\mathbf{P}$，然后进行筛选。\n4.  **似然计算**：最终的似然是最终向量 $\\boldsymbol{\\alpha}_T$ 中所有元素的和。\n5.  **比率计算**：该过程运行两次：一次用于 SI 模型（$\\gamma=0$）以获得 $L_{\\text{SI}}$，另一次用于 SIR 模型（使用给定的 $\\gamma > 0$）以获得 $L_{\\text{SIR}}$。然后计算比率 $\\Lambda=L_{\\text{SI}}/L_{\\text{SIR}}$，并处理 $L_{\\text{SIR}}=0$ 的情况。\n\n这种方法提供了所要求的精确解，并且对于问题中指定的小网络规模是可行的。",
            "answer": "```python\nimport numpy as np\n\ndef _compute_likelihood(A, beta, gamma, I_seq):\n    \"\"\"\n    Computes the likelihood of an observed sequence of infected counts\n    using a forward algorithm on the exact state-space Markov chain.\n\n    Args:\n        A (np.ndarray): Adjacency matrix of the network.\n        beta (float): Per-edge transmission probability.\n        gamma (float): Recovery probability.\n        I_seq (list): Sequence of observed infected counts.\n\n    Returns:\n        float: The likelihood of the observation sequence.\n    \"\"\"\n    n = A.shape[0]\n    T = len(I_seq) - 1\n    num_states = 3**n\n\n    # 1. Pre-computation of state properties\n    # Each state is an integer from 0 to 3^n - 1.\n    # We map state_idx - {config, num_I, m_counts}\n    # config is a tuple of node states (0:S, 1:I, 2:R)\n    states_info = []\n    for i in range(num_states):\n        \n        # Convert index to base-3 configuration\n        config = []\n        temp_i = i\n        for _ in range(n):\n            state = temp_i % 3\n            config.append(state)\n            temp_i //= 3\n        config = tuple(config)\n        num_I = config.count(1)\n        \n        # For each susceptible node, count its infected neighbors\n        m_counts = []\n        for j in range(n):\n            m_j = 0\n            if config[j] == 0:\n                for k in range(n):\n                    if A[j, k] == 1 and config[k] == 1:\n                        m_j += 1\n            m_counts.append(m_j)\n        \n        states_info.append({\n            'num_I': num_I,\n            'm_counts': tuple(m_counts)\n        })\n\n    # 2. Pre-computation of the transition probability matrix P[C, C']\n    P = np.zeros((num_states, num_states), dtype=np.float64)\n    for idx_C in range(num_states):\n        C_m_counts = states_info[idx_C]['m_counts']\n        # Convert indices to configurations to calculate transitions\n        C_config_temp, C_idx_temp = [], idx_C\n        for _ in range(n):\n            C_config_temp.append(C_idx_temp % 3); C_idx_temp //= 3\n\n        for idx_C_prime in range(num_states):\n            C_prime_config_temp, C_prime_idx_temp = [], idx_C_prime\n            for _ in range(n):\n                C_prime_config_temp.append(C_prime_idx_temp % 3); C_prime_idx_temp //= 3\n            \n            prob = 1.0\n            possible = True\n            for j in range(n):\n                c_j, c_j_prime = C_config_temp[j], C_prime_config_temp[j]\n                \n                if c_j == 0:  # Susceptible\n                    m_j = C_m_counts[j]\n                    p_inf = 1.0 - (1.0 - beta)**m_j\n                    if c_j_prime == 1: prob *= p_inf\n                    elif c_j_prime == 0: prob *= (1.0 - p_inf)\n                    else: possible = False; break\n                elif c_j == 1:  # Infected\n                    if c_j_prime == 1: prob *= (1.0 - gamma)\n                    elif c_j_prime == 2: prob *= gamma\n                    else: possible = False; break\n                elif c_j == 2:  # Removed\n                    if c_j_prime != 2: possible = False; break\n            \n            if possible:\n                P[idx_C, idx_C_prime] = prob\n    \n    # 3. Forward Algorithm\n    # Initialization (t=0)\n    alpha = np.zeros(num_states, dtype=np.float64)\n    if I_seq[0] != 1: return 0.0\n        \n    for i in range(num_states):\n        info = states_info[i]\n        is_initial_config = (info['num_I'] == 1 and sum(1 for state in get_config_from_idx(i,n) if state == 0) == n - 1)\n        if is_initial_config:\n            alpha[i] = 1.0 / n\n\n    # Recursion (t = 0 to T-1)\n    for t in range(T):\n        alpha_next = np.zeros(num_states, dtype=np.float64)\n        I_t_plus_1 = I_seq[t + 1]\n        \n        # Effective matrix-vector product filtered by observation\n        alpha_next = alpha @ P\n        \n        # Filter based on observation I(t+1)\n        for i in range(num_states):\n            if states_info[i]['num_I'] != I_t_plus_1:\n                alpha_next[i] = 0.0\n        \n        alpha = alpha_next\n        if np.sum(alpha) == 0.0: return 0.0\n\n    # 4. Termination\n    return np.sum(alpha)\n    \ndef get_config_from_idx(idx, n):\n    \"\"\" Helper to convert index to config, used in alpha init \"\"\"\n    config = []\n    temp_i = idx\n    for _ in range(n):\n        config.append(temp_i % 3)\n        temp_i //= 3\n    return tuple(config)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], dtype=int),\n            \"beta\": 0.4, \"gamma\": 0.2, \"I_seq\": [1, 2, 3, 4]\n        },\n        {\n            \"A\": np.array([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], dtype=int),\n            \"beta\": 0.2, \"gamma\": 0.5, \"I_seq\": [1, 1, 1, 1]\n        },\n        {\n            \"A\": np.array([[0, 1, 1, 1, 1], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0]], dtype=int),\n            \"beta\": 0.35, \"gamma\": 0.3, \"I_seq\": [1, 2, 1, 1]\n        },\n        {\n            \"A\": np.array([[0, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=int),\n            \"beta\": 0.7, \"gamma\": 0.4, \"I_seq\": [1, 1, 1]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A, beta, gamma, I_seq = case[\"A\"], case[\"beta\"], case[\"gamma\"], case[\"I_seq\"]\n        \n        L_si = _compute_likelihood(A, beta, 0.0, I_seq)\n        L_sir = _compute_likelihood(A, beta, gamma, I_seq)\n\n        if L_sir == 0.0:\n            if L_si > 0.0:\n                ratio_str = 'inf'\n            else:  # Both L_si and L_sir are 0\n                ratio_str = 'nan'\n        else:\n            ratio = L_si / L_sir\n            ratio_str = f\"{ratio:.6f}\"\n        \n        results.append(ratio_str)\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}