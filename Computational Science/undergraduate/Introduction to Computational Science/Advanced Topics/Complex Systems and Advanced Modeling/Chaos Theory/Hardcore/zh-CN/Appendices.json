{
    "hands_on_practices": [
        {
            "introduction": "混沌系统最著名的特性之一是“对初始条件的敏感依赖性”，通常被称为“蝴蝶效应”。这个练习将让你亲手验证这一概念：即使是计算机浮点数精度不同所造成的微小差异，在混沌系统中也会被指数级放大，最终导致轨迹的巨大分歧。通过对比单精度和双精度下的洛伦兹系统模拟，你将量化数值轨迹能够保持“可信”的时间——即“影子时间”（shadowing time）。",
            "id": "3105374",
            "problem": "考虑由常微分方程（ODE）系统定义的 Lorenz 初值问题\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad \\frac{dy}{dt} = x(\\rho - z) - y, \\quad \\frac{dz}{dt} = xy - \\beta z,\n$$\n其中 $x$、$y$ 和 $z$ 是状态变量，$\\sigma$、$\\rho$ 和 $\\beta$ 是固定的实数参数。该系统是一个经典的混沌动力学系统。在混沌系统中，状态或计算中的微小扰动会随时间增长，导致轨迹发散。数值积分中的浮点舍入和截断误差就扮演了此类扰动的角色。\n\n你的任务是编写一个完整、可运行的计算机程序，该程序：\n- 使用从第一性原理推导出的固定步长数值积分器，对 ODE 初值问题进行模拟，从而仿真 Lorenz 系统。使用与四阶 Runge–Kutta (RK) 方案一致的方法，在离散时间 $t_k = k \\,\\Delta t$（其中 $k = 0,1,\\dots,N$）处近似求解，时间步长为 $\\Delta t$，总时长为 $T_{\\text{total}} = N \\Delta t$。\n- 在相同的参数和初始条件下，并行运行两次仿真：一次使用单精度（IEEE $754$ binary$32$，下文记作 $\\text{float32}$），另一次使用双精度（IEEE $754$ binary$64$，下文记作 $\\text{float64}$）。确保每次运行中的所有算术运算都遵循各自的精度。\n- 在每一步 $k$ 计算差值的欧几里得范数，以测量两条轨迹之间的差异\n$$\ns_k = \\left\\| \\mathbf{x}^{(32)}_k - \\mathbf{x}^{(64)}_k \\right\\|_2,\n$$\n其中 $\\mathbf{x}^{(p)}_k$ 表示在精度 $p \\in \\{32, 64\\}$ 下计算得到的状态向量。\n- 对于给定的容差 $\\varepsilon$，将可跟踪时间 $T_{\\text{shadow}}$ 估算为满足 $s_k \\ge \\varepsilon$ 的最早离散时间 $t_k$。如果在 $T_{\\text{total}}$ 之前不存在这样的 $k$，则设 $T_{\\text{shadow}} = T_{\\text{total}}$。\n\n需要使用和遵循的基本原则：\n- 上述 Lorenz ODE 定义。\n- 初值问题的表述，以及通过评估瞬时变化率并将其聚合以近似流场，从而使用固定步长方法离散化时间的概念。\n- 浮点算术的概念，及其舍入误差在动力学过程中会累积和传播的特性。\n\n在所有仿真中使用以下固定参数：\n- $\\sigma = 10$，$\\rho = 28$，$\\beta = \\frac{8}{3}$。\n- 初始条件 $\\mathbf{x}_0 = (1, 1, 1)$。\n- 时间变量 $t$ 是无量纲的；报告时间时也使用相同的无量纲单位。不涉及物理单位。\n\n定义并应用由 3 个测试用例组成的测试套件，每个用例由 $(\\Delta t, T_{\\text{total}}, \\varepsilon)$ 指定：\n- 用例 1：$\\Delta t = 0.01$，$T_{\\text{total}} = 30$，$\\varepsilon = 10^{-3}$。\n- 用例 2：$\\Delta t = 0.02$，$T_{\\text{total}} = 30$，$\\varepsilon = 10^{-2}$。\n- 用例 3：$\\Delta t = 0.005$，$T_{\\text{total}} = 50$，$\\varepsilon = 10^{-5}$。\n\n覆盖范围说明：\n- 用例 1 是一个标准的“理想路径”，具有中等的步长和容差。\n- 用例 2 探讨了对较粗糙离散化的敏感性，这会放大数值误差并加速发散。\n- 用例 3 使用更精细的步长和非常小的容差来检验早期的指数分离和阈值穿越情况。\n\n对于每个用例，你的程序必须计算并返回两个量：\n- 如上定义的 $T_{\\text{shadow}}$。\n- 在 $t_N = T_{\\text{total}}$ 时的最终步长差异 $s_N$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有 3 个测试用例的结果。结果为一个逗号分隔的列表，并用方括号括起来，每个用例的结果本身是一个包含两个浮点数 $[T_{\\text{shadow}}, s_N]$ 的列表。例如，输出必须具有以下形式\n$$\n\\texttt{[[T_1,s_1],[T_2,s_2],[T_3,s_3]]}\n$$\n其中用数值替换 $T_i$ 和 $s_i$。不应打印任何额外文本。",
            "solution": "Lorenz 系统是一组耦合的常微分方程（ODE），它在 $\\mathbb{R}^3$ 上定义了一个确定性流 $\\Phi_t$。给定参数 $(\\sigma,\\rho,\\beta)$ 和初始条件 $\\mathbf{x}_0 = (x_0,y_0,z_0)$，初值问题旨在寻找满足以下条件的 $\\mathbf{x}(t)$\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}) \\quad \\text{其中} \\quad \\mathbf{x}(0) = \\mathbf{x}_0,\n$$\n此处\n$$\n\\mathbf{f}(\\mathbf{x}) = \\begin{bmatrix}\n\\sigma(y - x)\\\\\nx(\\rho - z) - y\\\\\nxy - \\beta z\n\\end{bmatrix}.\n$$\n计算近似解的一种标准方法是将时间离散化为大小为 $\\Delta t$ 的步长，并应用一种固定步长的显式方法，该方法通过组合由瞬时变化率计算出的局部更新来近似流。四阶 Runge–Kutta (RK$4$) 方法是通过将精确解的泰勒展开匹配到四阶而推导出来的。在从 $\\mathbf{x}_k$ 到 $\\mathbf{x}_{k+1}$ 的每一步中，RK$4$ 方法会计算分阶段的斜率评估值：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{x}_k),\\\\\n\\mathbf{k}_2 = \\mathbf{f}\\!\\left(\\mathbf{x}_k + \\frac{\\Delta t}{2}\\mathbf{k}_1\\right),\\\\\n\\mathbf{k}_3 = \\mathbf{f}\\!\\left(\\mathbf{x}_k + \\frac{\\Delta t}{2}\\mathbf{k}_2\\right),\\\\\n\\mathbf{k}_4 = \\mathbf{f}\\!\\left(\\mathbf{x}_k + \\Delta t\\,\\mathbf{k}_3\\right),\n\\end{aligned}\n$$\n并通过以下方式推进状态：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta t\\,\\frac{1}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).\n$$\n该构造源于在区间 $[t_k, t_{k+1}]$ 上对 ODE 进行积分，并使用满足局部截断误差阶数条件的求积公式来近似该积分。\n\n数字计算机上的浮点运算将实数表示为一个带有舍入的有限集合。在 IEEE $754$ binary$32$（单精度）中，机器 epsilon（从 $1$ 到下一个大于 $1$ 的可表示数之间的距离）约为 $2^{-23} \\approx 1.19\\times 10^{-7}$，而在 IEEE $754$ binary$64$（双精度）中，它约为 $2^{-52} \\approx 2.22\\times 10^{-16}$。在所选精度下，每次算术运算都会舍入到最接近的可表示数，从而引入一个微小的扰动。\n\n以正的最大 Lyapunov 指数为特征的混沌动力学，会在足够短的时间内指数级地放大微小扰动。如果 $\\lambda_{\\max} > 0$ 表示最大 Lyapunov 指数，那么对于足够小的初始间距 $s_0$ 并且在线性化范围内，两个邻近轨迹之间的间距遵循\n$$\ns(t) \\approx s_0\\,e^{\\lambda_{\\max} t}.\n$$\n因此，达到阈值 $\\varepsilon$ 的时间可按如下方式估算\n$$\nT_{\\text{shadow}} \\approx \\frac{1}{\\lambda_{\\max}} \\ln\\!\\left(\\frac{\\varepsilon}{s_0}\\right),\n$$\n这说明了其对初始间距 $s_0$（此处由单精度和双精度计算之间的舍入差异累积所隐含设定）和系统不稳定性率的依赖性。\n\n算法设计：\n- 使用相同的数值方法（RK$4$）、时间步长 $\\Delta t$、参数 $(\\sigma,\\rho,\\beta)$ 和初始条件 $\\mathbf{x}_0$，但采用不同的算术精度（一个为 $\\text{float32}$，另一个为 $\\text{float64}$），并行计算两条轨迹。确保在每次运行中，所有中间量和常数都被转换为各自的精度，以隔离浮点效应。\n- 在每个离散时间 $t_k = k\\,\\Delta t$，计算欧几里得间距\n$$\ns_k = \\left\\|\\mathbf{x}^{(32)}_k - \\mathbf{x}^{(64)}_k\\right\\|_2 = \\sqrt{(x^{(32)}_k - x^{(64)}_k)^2 + (y^{(32)}_k - y^{(64)}_k)^2 + (z^{(32)}_k - z^{(64)}_k)^2}.\n$$\n- 可跟踪时间确定为\n$$\nT_{\\text{shadow}} = \\min\\{t_k \\,:\\, s_k \\ge \\varepsilon\\},\n$$\n并约定如果在 $T_{\\text{total}}$ 之前该集合为空，则 $T_{\\text{shadow}} = T_{\\text{total}}$。\n- 同时记录在 $t_N = T_{\\text{total}}$ 时的最终步长差异 $s_N$，以量化仿真结束时的累积间距。\n\n测试套件：\n- 使用固定的参数 $\\sigma=10$、$\\rho=28$、$\\beta=8/3$，初始条件 $\\mathbf{x}_0=(1,1,1)$，以及指定的三个用例：\n  - 用例 1：$\\Delta t = 0.01$，$T_{\\text{total}} = 30$，$\\varepsilon=10^{-3}$。\n  - 用例 2：$\\Delta t = 0.02$，$T_{\\text{total}} = 30$，$\\varepsilon=10^{-2}$。\n  - 用例 3：$\\Delta t = 0.005$，$T_{\\text{total}} = 50$，$\\varepsilon=10^{-5}$。\n由于每个 $T_{\\text{total}}/\\Delta t$ 都是整数，离散网格与总时长精确对齐，避免了“差一”类的计算偏差。\n\n程序以所要求的单行格式计算并汇总结果：\n$$\n\\texttt{[[T_1,s_1],[T_2,s_2],[T_3,s_3]]}.\n$$\n该设计直接探讨了计算精度（$\\text{float32}$ 与 $\\text{float64}$）如何影响混沌系统中的发散，并为每种容差和步长选择提供了一个可跟踪时间的经验估计，其基础是 ODE 积分、浮点舍入和对初始条件的敏感性等原理。",
            "answer": "```python\nimport numpy as np\n\ndef lorenz_deriv(x, sigma, rho, beta, dtype):\n    # x is a vector [x, y, z] with given dtype\n    # Returns derivative dx/dt as the same dtype vector.\n    x0 = x[0]; y0 = x[1]; z0 = x[2]\n    # Cast parameters to dtype to keep arithmetic consistent.\n    sigma = dtype(sigma)\n    rho = dtype(rho)\n    beta = dtype(beta)\n    dx = sigma * (y0 - x0)\n    dy = x0 * (rho - z0) - y0\n    dz = x0 * y0 - beta * z0\n    return np.array([dx, dy, dz], dtype=dtype)\n\ndef rk4_step(x, dt, sigma, rho, beta, dtype):\n    # One RK4 step with all arithmetic in given dtype.\n    dt = dtype(dt)\n    k1 = lorenz_deriv(x, sigma, rho, beta, dtype)\n    k2 = lorenz_deriv(x + (dt / dtype(2)) * k1, sigma, rho, beta, dtype)\n    k3 = lorenz_deriv(x + (dt / dtype(2)) * k2, sigma, rho, beta, dtype)\n    k4 = lorenz_deriv(x + dt * k3, sigma, rho, beta, dtype)\n    x_next = x + dt * (dtype(1)/dtype(6)) * (k1 + dtype(2)*k2 + dtype(2)*k3 + k4)\n    return x_next\n\ndef shadowing_time_and_final_separation(x0, sigma, rho, beta, dt, T_total, epsilon):\n    \"\"\"\n    Integrate the Lorenz system in float32 and float64 in parallel using RK4.\n    Compute the shadowing time T_shadow as the earliest t_k where separation >= epsilon.\n    Also return the final separation at t_N = T_total.\n    \"\"\"\n    # Ensure integer number of steps\n    steps = int(round(T_total / dt))\n    # Initialize states in respective precisions\n    x32 = np.array(x0, dtype=np.float32)\n    x64 = np.array(x0, dtype=np.float64)\n\n    T_shadow = None\n    separation_final = None\n\n    # Time loop\n    for k in range(steps):\n        # Advance both states\n        x32 = rk4_step(x32, dt, sigma, rho, beta, np.float32)\n        x64 = rk4_step(x64, dt, sigma, rho, beta, np.float64)\n        # Compute separation using higher precision for the difference\n        diff = x32.astype(np.float64) - x64\n        sep = float(np.linalg.norm(diff, ord=2))\n        # Record earliest crossing of epsilon\n        if T_shadow is None and sep >= epsilon:\n            T_shadow = (k + 1) * dt  # time after completing this step\n        # Update final separation\n        separation_final = sep\n\n    if T_shadow is None:\n        T_shadow = T_total\n\n    return float(T_shadow), float(separation_final)\n\ndef solve():\n    # Fixed Lorenz parameters and initial condition\n    sigma = 10.0\n    rho = 28.0\n    beta = 8.0 / 3.0\n    x0 = (1.0, 1.0, 1.0)\n\n    # Test suite: (dt, T_total, epsilon)\n    test_cases = [\n        (0.01, 30.0, 1e-3),   # Case 1: happy path\n        (0.02, 30.0, 1e-2),   # Case 2: coarser step, larger tolerance\n        (0.005, 50.0, 1e-5),  # Case 3: finer step, very small tolerance\n    ]\n\n    results = []\n    for dt, T_total, epsilon in test_cases:\n        T_shadow, s_final = shadowing_time_and_final_separation(\n            x0=x0, sigma=sigma, rho=rho, beta=beta, dt=dt, T_total=T_total, epsilon=epsilon\n        )\n        results.append([T_shadow, s_final])\n\n    # Final print statement in the exact required format.\n    # Single line, list of lists with floats.\n    print(f\"[{','.join('[' + ','.join(map(str, r)) + ']' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在直观地感受了蝴蝶效应之后，下一步是学习如何量化它。李雅普诺夫指数（Lyapunov exponent）正是衡量混沌系统中相邻轨道指数级分离平均速率的关键指标。这个练习要求你为洛伦兹系统实现计算最大李雅普诺夫指数的标准算法，这是计算动力学中的一项核心技能，同时也能让你体会到选择合适的数值方法和参数对结果的重要性。",
            "id": "3105291",
            "problem": "考虑 Lorenz 常微分方程组 (ODE)，其状态向量 $\\mathbf{x}(t) = (x(t), y(t), z(t))$ 由以下方程定义\n$$\n\\dot{x} = \\sigma\\,(y - x), \\quad\n\\dot{y} = x\\,(\\rho - z) - y, \\quad\n\\dot{z} = x\\,y - \\beta\\,z,\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是正常数参数。最大 Lyapunov 指数 (LE) $\\lambda_{\\max}$ 衡量了流 $\\Phi^t$ 的邻近轨道分离的平均指数速率，可以从第一性原理定义为\n$$\n\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|},\n$$\n其中 $\\delta \\mathbf{x}(t)$ 根据围绕 $\\mathbf{x}(t)$ 的线性化（变分）动力学演化。该变分方程为\n$$\n\\frac{d}{dt}\\,\\delta \\mathbf{x} = J(\\mathbf{x}(t))\\,\\delta \\mathbf{x},\n$$\n其中 $J(\\mathbf{x})$ 是沿轨道 $\\mathbf{x}(t)$ 求值的向量场的 Jacobian 矩阵。对于 Lorenz 系统，\n$$\nJ(\\mathbf{x}) =\n\\begin{bmatrix}\n-\\sigma & \\sigma & 0 \\\\\n\\rho - z & -1 & -x \\\\\ny & x & -\\beta\n\\end{bmatrix}.\n$$\n\n任务：编写一个完整、可运行的程序，使用三种不同的时间步进方案，为 Lorenz 系统数值估计最大 Lyapunov 指数 $\\lambda_{\\max}$：\n- 显式二阶 Runge–Kutta (RK2，中点法)。\n- 显式经典四阶 Runge–Kutta (RK4)。\n- 具有自动步长控制的自适应嵌入式 Runge–Kutta (自适应 RK45)。\n\n您的程序必须：\n- 实现 $(\\mathbf{x}, \\delta \\mathbf{x})$ 的增广 ODE 系统，其动力学方程为\n$$\n\\frac{d}{dt} \\begin{bmatrix} \\mathbf{x} \\\\ \\delta \\mathbf{x} \\end{bmatrix}\n=\n\\begin{bmatrix}\n\\dot{\\mathbf{x}}(\\mathbf{x}) \\\\\nJ(\\mathbf{x})\\,\\delta \\mathbf{x}\n\\end{bmatrix}.\n$$\n- 随时间演化系统，每隔 $\\tau_R$ 时间单位周期性地将扰动向量 $\\delta \\mathbf{x}$ 重新归一化至一个固定的微小范数 $\\delta_0$，以避免 $\\delta \\mathbf{x}$ 的范数发生上溢或下溢。如果重新归一化前的扰动范数是 $\\|\\delta \\mathbf{x}\\|$，则累加 $\\ln\\left(\\|\\delta \\mathbf{x}\\|/\\delta_0\\right)$，然后设置 $\\delta \\mathbf{x} \\leftarrow \\delta_0\\, \\delta \\mathbf{x} / \\|\\delta \\mathbf{x}\\|$。从累加中舍弃时长为 $T_{\\mathrm{trans}}$ 的初始暂态区间。在总时间 $T_{\\mathrm{tot}}$ 积分后，估计\n$$\n\\hat{\\lambda}_{\\max} = \\frac{1}{T_{\\mathrm{tot}} - T_{\\mathrm{trans}}} \\sum_{k} \\ln\\left(\\frac{\\|\\delta \\mathbf{x}_k\\|}{\\delta_0}\\right),\n$$\n其中求和是在时间 $T_{\\mathrm{trans}}$ 之后发生的重新归一化时刻上进行的。\n\n使用以下科学上合理且广泛使用的参数值和设置：\n- Lorenz 参数：$\\sigma = 10$，$\\rho = 28$，$\\beta = 8/3$。\n- 状态初始条件：$\\mathbf{x}(0) = (1, 1, 1)$。\n- 初始扰动：$\\delta \\mathbf{x}(0)$ 与 $x$ 轴对齐，并归一化为 $\\|\\delta \\mathbf{x}(0)\\| = \\delta_0$，其中 $\\delta_0 = 10^{-8}$。\n- 总积分时间：$T_{\\mathrm{tot}} = 20$。\n- 暂态舍弃时间：$T_{\\mathrm{trans}} = 5$。\n- 重新归一化间隔：$\\tau_R = 0.1$。\n\n要实现的时间步进方案和参数：\n- RK2 (中点法)，固定步长为 $h$。\n- RK4 (经典法)，固定步长为 $h$。\n- 自适应 RK45，使用嵌入式误差控制，相对容差为 $\\mathrm{rtol}$，绝对容差为 $\\mathrm{atol}$。\n\n测试套件：\n- 情况 1：RK2，步长 $h = 0.02$。\n- 情况 2：RK2，步长 $h = 0.005$。\n- 情况 3：RK4，步长 $h = 0.02$。\n- 情况 4：RK4，步长 $h = 0.005$。\n- 情况 5：自适应 RK45，$\\mathrm{rtol} = 10^{-3}$ 且 $\\mathrm{atol} = 10^{-6}$。\n- 情况 6：自适应 RK45，$\\mathrm{rtol} = 10^{-6}$ 且 $\\mathrm{atol} = 10^{-9}$。\n\n要求：\n- 为增广系统 $(\\mathbf{x}, \\delta \\mathbf{x})$ 显式实现 RK2 和 RK4，并确保对于固定步长的情况，重新归一化间隔 $\\tau_R$ 是 $h$ 的整数倍。\n- 使用具有自动步长控制的嵌入式方法实现自适应 RK45（您可以使用标准的科学计算库例程），在每个长度为 $\\tau_R$ 的区间上分段积分，以确保重新归一化恰好在 $\\tau_R$ 的倍数时刻发生。\n- 按上述规定为每个测试用例估计 $\\hat{\\lambda}_{\\max}$，并将每个结果四舍五入到四位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试套件的顺序列出结果，例如 $[\\hat{\\lambda}_1,\\hat{\\lambda}_2,\\hat{\\lambda}_3,\\hat{\\lambda}_4,\\hat{\\lambda}_5,\\hat{\\lambda}_6]$，其中每个 $\\hat{\\lambda}_i$ 都四舍五入到四位小数。\n\n关于推导和设计所用基础的说明：\n- 使用 ODE 的定义、由 ODE 生成的流映射以及通过线性化动力学定义的 Lyapunov 指数作为基本依据。\n- 使用经过充分检验的误差阶数事实：对于足够光滑的问题，阶数为 $p$ 的固定步长显式 Runge-Kutta 方法的全局截断误差与 $h^p$ 成正比，而自适应嵌入式 Runge-Kutta 方案控制局部误差以满足指定的容差。不要引用或使用任何绕过从变分方程和重新归一化过程推导估计量的最终公式。\n\n最终输出格式：\n- 单行输出，包含一个由 6 个浮点数组成的列表，每个浮点数四舍五入到四位小数，格式严格为 $[\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float}]$，无空格。",
            "solution": "该问题要求对 Lorenz 系统的最大 Lyapunov 指数 $\\lambda_{\\max}$ 进行数值估计。指定的方法是标准算法，其基础是积分常微分方程组 (ODE) 及其相应的变分方程构成的增广系统，然后对扰动向量进行周期性重新归一化。\n\n首先，我们定义增广状态向量 $\\mathbf{Y}(t) \\in \\mathbb{R}^6$。该向量结合了原始状态向量 $\\mathbf{x}(t) = [x(t), y(t), z(t)]^T$ 和无穷小扰动向量 $\\delta\\mathbf{x}(t) = [\\delta x(t), \\delta y(t), \\delta z(t)]^T$。因此，$\\mathbf{Y}(t) = [\\mathbf{x}(t)^T, \\delta\\mathbf{x}(t)^T]^T$。此增广状态的时间演化由一个包含六个耦合一阶 ODE 的系统控制：\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y}(t)) =\n\\begin{bmatrix}\n\\dot{\\mathbf{x}}(\\mathbf{x}) \\\\\n\\frac{d}{dt}\\delta\\mathbf{x}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f}(\\mathbf{x}) \\\\\nJ(\\mathbf{x})\\,\\delta\\mathbf{x}\n\\end{bmatrix}\n$$\n其中 $\\mathbf{f}(\\mathbf{x})$ 是 Lorenz 系统的向量场，$J(\\mathbf{x})$ 是其 Jacobian 矩阵。\n\n$\\mathbf{f}(\\mathbf{x})$ 的分量由以下公式给出：\n$$\n\\dot{x} = \\sigma (y - x) \\\\\n\\dot{y} = x (\\rho - z) - y \\\\\n\\dot{z} = x y - \\beta z\n$$\nJacobian 矩阵 $J(\\mathbf{x}) = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}}$ 是：\n$$\nJ(\\mathbf{x}) =\n\\begin{bmatrix}\n-\\sigma & \\sigma & 0 \\\\\n\\rho - z & -1 & -x \\\\\ny & x & -\\beta\n\\end{bmatrix}\n$$\n参数指定为 $\\sigma = 10$，$\\rho = 28$ 和 $\\beta = 8/3$。\n\n最大 Lyapunov 指数由邻近轨道分离的长期平均指数速率定义：\n$$\n\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|}\n$$\n直接对变分方程进行数值积分会导致溢出，因为 $\\|\\delta \\mathbf{x}(t)\\|$ 会呈指数增长。为避免此问题，我们使用重新归一化程序。总积分时间 $T_{\\mathrm{tot}}$ 被划分为 $N = T_{\\mathrm{tot}} / \\tau_R$ 个长度为 $\\tau_R$ 的区间。\n\n算法流程如下：\n1.  初始化 $t=0$ 时的状态：$\\mathbf{x}(0) = (1, 1, 1)$ 和 $\\delta\\mathbf{x}(0) = (\\delta_0, 0, 0)$，其中 $\\delta_0 = 10^{-8}$。这设定了初始增广状态 $\\mathbf{Y}(0)$。\n2.  对每个区间 $k=1, \\dots, N$，在时间跨度 $[(k-1)\\tau_R, k\\tau_R]$ 上积分 6D 系统 $\\dot{\\mathbf{Y}} = \\mathbf{F}(\\mathbf{Y})$。\n3.  设区间结束时的扰动向量为 $\\delta\\mathbf{x}_k^{\\text{pre}}$。计算其范数 $d_k = \\|\\delta\\mathbf{x}_k^{\\text{pre}}\\|$。\n4.  如果当前时间 $t_k = k\\tau_R$ 大于暂态时间 $T_{\\mathrm{trans}}$，则将值 $\\ln(d_k / \\delta_0)$ 累加到一个运行总和中。项 $d_k/\\delta_0$ 表示在长度为 $\\tau_R$ 的区间上扰动的增长因子。\n5.  将扰动向量重新归一化至范数为 $\\delta_0$：$\\delta\\mathbf{x}_k^{\\text{post}} = (\\delta_0 / d_k) \\delta\\mathbf{x}_k^{\\text{pre}}$。这个新向量用作下一个积分区间中 $\\mathbf{Y}$ 的扰动部分的初始条件。状态部分 $\\mathbf{x}$ 的演化不受影响。\n6.  在总时间 $T_{\\mathrm{tot}}$ 积分后，最大 Lyapunov 指数的估计值计算为非暂态时期内累积的对数增长因子的时间平均值：\n$$\n\\hat{\\lambda}_{\\max} = \\frac{1}{T_{\\mathrm{tot}} - T_{\\mathrm{trans}}} \\sum_{k \\text{ s.t. } k\\tau_R > T_{\\mathrm{trans}}} \\ln\\left(\\frac{d_k}{\\delta_0}\\right)\n$$\n模拟参数为 $T_{\\mathrm{tot}} = 20$，$T_{\\mathrm{trans}} = 5$ 和 $\\tau_R = 0.1$。\n\n我们为此过程实现三种数值积分方案：\n\n**1. 固定步长 Runge-Kutta 方法 (RK2 and RK4):**\n对于 ODE 系统 $\\dot{\\mathbf{Y}} = \\mathbf{F}(t, \\mathbf{Y})$，从 $t_n$ 到 $t_{n+1} = t_n + h$ 的单步计算如下：\n- **RK2 (中点法):**\n  $$\n  \\mathbf{k}_1 = \\mathbf{F}(t_n, \\mathbf{Y}_n) \\\\\n  \\mathbf{k}_2 = \\mathbf{F}(t_n + h/2, \\mathbf{Y}_n + (h/2)\\mathbf{k}_1) \\\\\n  \\mathbf{Y}_{n+1} = \\mathbf{Y}_n + h \\mathbf{k}_2\n  $$\n- **RK4 (经典法):**\n  $$\n  \\mathbf{k}_1 = \\mathbf{F}(t_n, \\mathbf{Y}_n) \\\\\n  \\mathbf{k}_2 = \\mathbf{F}(t_n + h/2, \\mathbf{Y}_n + (h/2)\\mathbf{k}_1) \\\\\n  \\mathbf{k}_3 = \\mathbf{F}(t_n + h/2, \\mathbf{Y}_n + (h/2)\\mathbf{k}_2) \\\\\n  \\mathbf{k}_4 = \\mathbf{F}(t_n + h, \\mathbf{Y}_n + h\\mathbf{k}_3) \\\\\n  \\mathbf{Y}_{n+1} = \\mathbf{Y}_n + (h/6)(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n  $$\n对于每个持续时间为 $\\tau_R$ 的重新归一化区间，我们执行 $M = \\tau_R / h$ 步所选的固定步长积分器。\n\n**2. 自适应 Runge-Kutta 方法 (RK45):**\n该方法使用一对嵌入式的四阶和五阶 Runge-Kutta 公式来估计每一步的局部截断误差。步长会自动调整，以将此误差保持在用户指定的相对容差 $\\mathrm{rtol}$ 和绝对容差 $\\mathrm{atol}$ 之内。我们使用 `scipy.integrate.solve_ivp` 函数，并设置 `method='RK45'`。为确保重新归一化恰好在 $\\tau_R$ 的倍数时刻发生，我们对每个区间 $[(k-1)\\tau_R, k\\tau_R]$ 独立调用此求解器。\n\n程序为六个测试用例计算 $\\hat{\\lambda}_{\\max}$，改变积分方法及其参数（$h$、$\\mathrm{rtol}$、$\\mathrm{atol}$），并将每个结果四舍五入到四位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# --- Problem Parameters ---\n# Lorenz system parameters\nSIGMA = 10.0\nRHO = 28.0\nBETA = 8.0 / 3.0\n\n# Simulation parameters\nT_TOT = 20.0\nT_TRANS = 5.0\nTAU_R = 0.1\nDELTA_0 = 1e-8\n\ndef lorenz_augmented(t, Y):\n    \"\"\"\n    Defines the augmented ODE system for the Lorenz equations and their\n    variational dynamics.\n    \n    Args:\n        t (float): Current time (unused, for compatibility with solvers).\n        Y (np.ndarray): 6-element state vector [x, y, z, dx, dy, dz].\n\n    Returns:\n        np.ndarray: 6-element time derivative vector dY/dt.\n    \"\"\"\n    x, y, z = Y[0], Y[1], Y[2]\n    d_vec = Y[3:]\n\n    # Lorenz system dynamics\n    dxdt = SIGMA * (y - x)\n    dydt = x * (RHO - z) - y\n    dzdt = x * y - BETA * z\n    \n    # Jacobian matrix J(x)\n    J = np.array([\n        [-SIGMA, SIGMA, 0.0],\n        [RHO - z, -1.0, -x],\n        [y, x, -BETA]\n    ])\n\n    # Variational equation dynamics\n    d_delta_vec_dt = J @ d_vec\n    \n    return np.hstack(([dxdt, dydt, dzdt], d_delta_vec_dt))\n\ndef rk2_step(f, t, y, h):\n    \"\"\"Performs a single step of the RK2 (midpoint) method.\"\"\"\n    k1 = f(t, y)\n    k2 = f(t + h / 2.0, y + h / 2.0 * k1)\n    return y + h * k2\n\ndef rk4_step(f, t, y, h):\n    \"\"\"Performs a single step of the classical RK4 method.\"\"\"\n    k1 = f(t, y)\n    k2 = f(t + h / 2.0, y + h / 2.0 * k1)\n    k3 = f(t + h / 2.0, y + h / 2.0 * k2)\n    k4 = f(t + h, y + h * k3)\n    return y + h / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef calculate_lyapunov(method, h=None, rtol=None, atol=None):\n    \"\"\"\n    Calculates the largest Lyapunov exponent for the Lorenz system\n    using the specified numerical method and parameters.\n    \n    Args:\n        method (str): 'rk2', 'rk4', or 'rk45'.\n        h (float, optional): Fixed step size for RK2/RK4.\n        rtol (float, optional): Relative tolerance for RK45.\n        atol (float, optional): Absolute tolerance for RK45.\n        \n    Returns:\n        float: The estimated largest Lyapunov exponent.\n    \"\"\"\n    # Initial conditions\n    x0 = np.array([1.0, 1.0, 1.0])\n    dx0 = np.array([DELTA_0, 0.0, 0.0]) # Perturbation aligned with x-axis\n    Y = np.hstack((x0, dx0))\n    \n    t = 0.0\n    log_sum = 0.0\n    \n    num_renorm_intervals = int(round(T_TOT / TAU_R))\n    \n    for i in range(num_renorm_intervals):\n        t_start = i * TAU_R\n        t_end = (i + 1) * TAU_R\n        \n        # Integrate over one re-normalization interval\n        if method in ['rk2', 'rk4']:\n            num_steps = int(round(TAU_R / h))\n            solver_step = rk2_step if method == 'rk2' else rk4_step\n            Y_interval = Y.copy()\n            t_interval = t_start\n            for _ in range(num_steps):\n                Y_interval = solver_step(lorenz_augmented, t_interval, Y_interval, h)\n                t_interval += h\n            Y = Y_interval\n        elif method == 'rk45':\n            sol = solve_ivp(lorenz_augmented, (t_start, t_end), Y, \n                            method='RK45', rtol=rtol, atol=atol)\n            Y = sol.y[:, -1]\n\n        t = t_end\n        \n        # Extract perturbation vector and calculate its norm\n        delta_x = Y[3:]\n        norm_delta_x = np.linalg.norm(delta_x)\n        \n        # Accumulate log of growth factor after transient period\n        if t > T_TRANS:\n            # Avoid log(0) in case of underflow\n            if norm_delta_x > 0:\n                log_sum += np.log(norm_delta_x / DELTA_0)\n        \n        # Re-normalize perturbation vector\n        Y[3:] = (delta_x / norm_delta_x) * DELTA_0 if norm_delta_x > 0 else dx0\n    \n    # Calculate final Lyapunov exponent estimate\n    lambda_max = log_sum / (T_TOT - T_TRANS)\n    return lambda_max\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'method': 'rk2', 'h': 0.02},\n        {'method': 'rk2', 'h': 0.005},\n        {'method': 'rk4', 'h': 0.02},\n        {'method': 'rk4', 'h': 0.005},\n        {'method': 'rk45', 'rtol': 1e-3, 'atol': 1e-6},\n        {'method': 'rk45', 'rtol': 1e-6, 'atol': 1e-9},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_lyapunov(**case)\n        results.append(f\"{result:.4f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个常见的误解是认为混沌等同于完全无序的随机性。实际上，许多混沌系统内部蕴含着惊人的结构，例如著名的逻辑斯蒂映射（logistic map）在混沌参数区间内就隐藏着许多“稳定岛”或“周期窗口”。在这个练习中，你将编写一个算法来自动扫描和识别这些周期性行为，从而揭示隐藏在混沌表象之下的复杂而有序的自相似结构。",
            "id": "3105341",
            "problem": "您将编写一个完整的、可运行的程序，使用计算方法研究逻辑斯谛映射在混沌参数区域内的周期窗口。从离散动力系统的核心定义和基于极限的量开始，并基于这些基础推导出一个不使用快捷公式的算法。\n\n基本基础：\n- 考虑由迭代 $x_{n+1} = f_r(x_n)$ 定义的逻辑斯谛映射，其中 $f_r(x) = r x (1 - x)$，控制参数 $r \\in [0,4]$，状态 $x_n \\in [0,1]$。\n- 如果存在一个最小的 $p \\in \\mathbb{N}$，使得对于所有足够大的 $n$，都有 $x_{n+p} = x_n$，则轨道 $(x_n)$ 具有（最小）周期 $p$。如果不存在这样的有限 $p$，则轨道是非周期的。\n- 对于参数 $r$ 下沿轨道 $(x_n)$ 的李雅普诺夫指数 (LE) $\\lambda$ 定义为 $\\lambda = \\lim_{N \\to \\infty} \\frac{1}{N}\\sum_{n=0}^{N-1} \\ln |f_r'(x_n)|$，其中 $f_r'(x) = r (1 - 2x)$。负的李雅普诺夫指数表示轨道的指数稳定性，而正的李雅普诺夫指数表示邻近轨道的指数发散。\n- 在计算中，通过舍弃初始的暂态过程来减小对初始条件的敏感性，并用有限时间平均来近似李雅普诺夫指数。\n\n问题要求：\n- 实现一个算法，对于给定的参数 $r$，通过在小容差意义下测试回归条件 $x_{n+p} \\approx x_n$ 来检测暂态后的轨道是否具有某个周期 $p \\leq p_{\\max}$。使用最小周期准则（即不存在更小的正整数 $q < p$ 满足该条件），并检查不同的相是否在数值上坍缩（对于 $p > 1$，确保 $p$ 个相值之间由一个阈值分隔）。仅当有限时间李雅普诺夫指数为负时，才接受周期分类。\n- 在一个闭区间 $[r_{\\min}, r_{\\max}]$ 上实现参数扫描，使用步长为 $\\Delta r$ 的均匀网格。如果轨道具有最小周期 $p$ 且李雅普诺夫指数为负，则将每个网格点 $r$ 分类为属于一个指定的目标周期 $p$ 窗口。将窗口的测度计算为所有被分类网格点的黎曼和 $\\sum \\Delta r$。同时，计算在网格上检测到的连续窗口段的数量。\n\n测试套件和答案规范：\n- 使用如上定义的逻辑斯谛映射 $x_{n+1} = r x_n (1 - x_n)$。\n- 使用每个测试用例中指定的固定初始条件和迭代次数。不要引入随机性。\n- 对于所有角度（本问题中没有），如果出现，请使用弧度。对于本问题中的所有数值输出，不涉及物理单位。\n- 您的程序必须严格实现以下测试用例：\n\n1. 在一个已知存在周期3的区域进行周期检测：\n   - 参数：$r = 3.82842712$, $x_0 = 0.2$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1500$, $p_{\\max} = 10$，容差 $\\varepsilon = 10^{-7}$。\n   - 此用例的输出：检测到的最小周期 $p$，为一个在 $\\{0,1,2,\\dots,p_{\\max}\\}$ 中的整数。如果没有检测到周期 $\\leq p_{\\max}$，则使用 $p = 0$。\n\n2. 在一个混沌区域进行周期检测：\n   - 参数：$r = 3.57$, $x_0 = 0.5$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1500$, $p_{\\max} = 10$，容差 $\\varepsilon = 10^{-7}$。\n   - 此用例的输出：检测到的最小周期 $p$（如果没有，则使用 $p = 0$）。\n\n3. 在一个局部区间内周期3窗口的测度：\n   - 参数：$r_{\\min} = 3.82$, $r_{\\max} = 3.86$, $\\Delta r = 10^{-4}$，目标周期 $p = 3$, $x_0 = 0.5$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1000$, $p_{\\max} = 10$，容差 $\\varepsilon = 10^{-7}$。\n   - 此用例的输出：在此网格上检测到的周期3窗口的总测度，表示为一个四舍五入到6位小数的浮点数。\n\n4. 在同一局部区间内连续的周期3窗口段的数量：\n   - 使用与用例3相同的参数。\n   - 此用例的输出：连续段的数量，为一个整数。\n\n5. 在一个更宽的混沌区间内周期3窗口的测度：\n   - 参数：$r_{\\min} = 3.5$, $r_{\\max} = 4.0$, $\\Delta r = 10^{-3}$，目标周期 $p = 3$, $x_0 = 0.5$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1000$, $p_{\\max} = 10$，容差 $\\varepsilon = 10^{-7}$。\n   - 此用例的输出：总测度，表示为一个四舍五入到6位小数的浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述五个测试用例的顺序排列结果。例如，输出应类似于 $[p_1,p_2,m_3,c_4,m_5]$，其中 $p_1$ 和 $p_2$ 是整数，$m_3$ 和 $m_5$ 是四舍五入到6位小数的浮点数，$c_4$ 是整数。",
            "solution": "该问题是有效的。它提出了一个定义明确的计算任务，该任务基于混沌理论和离散动力系统的既定原则。逻辑斯谛映射、周期性和李雅普诺夫指数的定义都是标准的。该问题要求实现数值算法来近似这些量，这是计算科学中的标准方法。所有测试用例的参数都已明确提供。\n\n在关于不同相检查的要求“确保 $p$ 个相值由一个阈值分隔”中存在一个微小的歧义，因为没有给出该阈值的具体值。一个合理且一致的解释（此处将采用）是使用为回归检查指定的相同容差 $\\varepsilon$。也就是说，对于一个具有点 $\\{c_1, \\dots, c_p\\}$ 的候选周期 $p$ 循环，要求对于所有 $i \\neq j$ 都有 $|c_i - c_j| \\ge \\varepsilon$。这种解释使得问题完全明确且可解。\n\n该解决方案基于基本原理设计，从核心定义开始，逐步构建所需的算法。\n\n**1. 逻辑斯谛映射与轨道生成**\n\n所考虑的动力系统是逻辑斯谛映射，一个函数 $f_r: [0,1] \\to [0,1]$，由迭代公式定义：\n$$x_{n+1} = f_r(x_n) = r x_n (1 - x_n)$$\n在此，$x_n$ 是系统在步骤 $n$ 的状态，$r \\in [0,4]$ 是一个控制参数。轨道是从初始条件 $x_0$ 生成的状态序列 $(x_n)_{n \\ge 0}$。为了分析长期（渐近）行为，我们首先迭代映射 $N_{\\text{transient}}$ 步，让轨道稳定到其吸引子上。然后我们记录随后的 $N_{\\text{sample}}$ 个点进行分析。\n\n**2. 用于稳定性分析的李雅普诺夫指数**\n\n轨道的稳定性由李雅普诺夫指数 (LE) $\\lambda$ 来量化。对于给定的轨道 $(x_n)$，它被定义为无限接近的轨道指数发散的平均速率：\n$$\\lambda = \\lim_{N \\to \\infty} \\frac{1}{N}\\sum_{n=0}^{N-1} \\ln |f_r'(x_n)|$$\n逻辑斯谛映射的导数是 $f_r'(x) = r (1 - 2x)$。负的 LE ($\\lambda  0$) 表示邻近轨道收敛，这是稳定轨道（如不动点或周期循环）的特征。正的 LE ($\\lambda > 0$) 表示指数发散，这是混沌的标志。\n\n在我们的计算方法中，我们用轨道暂态后的 $N_{\\text{sample}}$ 个点的有限时间平均来近似 LE：\n$$\\hat{\\lambda} \\approx \\frac{1}{N_{\\text{sample}}} \\sum_{i=0}^{N_{\\text{sample}}-1} \\ln|f_r'(x_{N_{\\text{transient}}+i})|$$\n\n**3. 轨道分类算法**\n\n为了确定给定 $r$ 的轨道的性质，我们实现一个执行以下步骤的函数：\n\n1.  **生成轨道并计算 LE**：从 $x_0$ 开始，为 $N_{\\text{transient}} + N_{\\text{sample}}$ 次迭代生成轨道。存储最后的 $N_{\\text{sample}}$ 个点。同时，在采样阶段计算 LE 的总和 $\\sum \\ln|f_r'(x_n)|$，以找到 $\\hat{\\lambda}$。\n\n2.  **搜索最小周期**：我们搜索表征轨道的最小整数周期 $p$（其中 $1 \\le p \\le p_{\\max}$）。这是通过从 $1$ 到 $p_{\\max}$ 迭代 $p$ 来完成的。第一个满足以下条件的 $p$ 值被认为是最小周期 $p_{\\text{candidate}}$。\n    *   **回归条件**：轨道必须每 $p$ 步重复一次。在数值上，我们测试序列的最后 $p$ 个点是否与它们之前的 $p$ 个点在小容差 $\\varepsilon$ 内匹配。即，对于 $k \\in \\{0, 1, \\dots, p-1\\}$，我们检查是否 $|x_{N-1-k} - x_{N-1-k-p}|  \\varepsilon$，其中 $N = N_{\\text{transient}} + N_{\\text{sample}}$。\n    *   **不同相条件**：对于一个有效的周期 $p > 1$，其组成点必须在数值上是不同的。我们通过检查最后 $p$ 个点的循环中的任意两点 $c_i, c_j$，对于 $i \\neq j$ 是否有 $|c_i - c_j| \\ge \\varepsilon$ 来验证这一点。\n\n3.  **最终分类**：一个轨道仅当找到一个最小周期 $p_{\\text{candidate}} > 0$ **并且**其对应的有限时间李雅普诺夫指数为负 ($\\hat{\\lambda}  0$) 时，才被分类为稳定的周期 $p$ 循环。如果 $p_{\\text{candidate}}0$ 但 $\\hat{\\lambda} \\ge 0$，则轨道是周期性的但不稳定，因此根据问题的稳定性要求，我们将其分类为非周期的（周期 $0$）。如果没有找到周期 $p \\le p_{\\max}$，轨道也被分类为非周期的（周期 $0$）。\n\n**4. 参数扫描算法**\n\n为了分析参数 $r$ 在一个区间上的属性，我们采用扫描算法：\n1.  **离散化参数空间**：在区间 $[r_{\\min}, r_{\\max}]$ 上创建一个步长为 $\\Delta r$ 的均匀 $r$ 值网格。\n\n2.  **分类每个点**：对于网格上的每个 $r_i$，执行上述轨道分类算法以确定其周期。\n\n3.  **计算窗口测度**：目标周期 $p$ 窗口的测度（或总宽度）通过黎曼和来近似。我们对网格上每个被分类为具有目标周期 $p$ 的 $r_i$ 求和步长 $\\Delta r$：\n    $$M_p = \\sum_{r_i \\text{ 其中周期是 } p} \\Delta r$$\n\n4.  **统计连续段**：为了计算一个目标周期的独立连续段的数量，我们遍历每个 $r_i$ 的分类序列。仅当遇到一个具有目标周期的点，而其前一个点具有不同周期时，计数器才会增加，这标志着一个新段的开始。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_orbit(r, x0, N_transient, N_sample, p_max, tol):\n    \"\"\"\n    Analyzes the logistic map orbit for a given parameter r.\n    \n    Returns the detected least period p if the orbit is stable (LE  0),\n    otherwise returns 0.\n    \"\"\"\n    # Step 1: Generate orbit and compute Lyapunov exponent\n    x = x0\n    orbit_points = np.zeros(N_transient + N_sample)\n    \n    # Generate the full orbit\n    for i in range(N_transient + N_sample):\n        x = r * x * (1.0 - x)\n        orbit_points[i] = x\n\n    # Extract the post-transient part of the orbit\n    orbit_sample = orbit_points[N_transient:]\n    \n    le_sum = 0.0\n    for val in orbit_sample:\n        derivative_val = r * (1.0 - 2.0 * val)\n        # Prevent log(0) if x lands exactly on 0.5\n        if abs(derivative_val) > 1e-12:\n            le_sum += np.log(abs(derivative_val))\n    \n    le = le_sum / N_sample\n\n    # Step 2: Find minimal period p = p_max\n    p_candidate = 0\n    for p in range(1, p_max + 1):\n        # Ensure there are enough points in the orbit to check for period p\n        if N_sample  2 * p:\n            continue\n\n        # Check recurrence condition for the last p points of the sample\n        is_periodic = True\n        for k in range(p):\n            if abs(orbit_sample[-1 - k] - orbit_sample[-1 - k - p]) >= tol:\n                is_periodic = False\n                break\n        \n        if is_periodic:\n            # Minimal period found (due to loop order). Now check for distinct phases.\n            if p > 1:\n                last_cycle = orbit_sample[-p:]\n                phases_distinct = True\n                for i in range(p):\n                    for j in range(i + 1, p):\n                        if abs(last_cycle[i] - last_cycle[j])  tol:\n                            phases_distinct = False\n                            break\n                    if not phases_distinct:\n                        break\n                \n                if not phases_distinct:\n                    # Not a true p-cycle (numerically collapsed phases), try a larger p\n                    continue\n\n            # Found minimal period p with distinct phases.\n            p_candidate = p\n            break  # Exit the loop for p\n\n    # Step 3: Classify based on Lyapunov exponent\n    if p_candidate > 0 and le  0:\n        return p_candidate\n    else:\n        return 0\n\ndef solve():\n    \"\"\"\n    Solves all test cases as specified in the problem statement.\n    \"\"\"\n    results = []\n    \n    # Case 1: Period detection in period-3 window\n    params1 = {'r': 3.82842712, 'x0': 0.2, 'N_transient': 2000, 'N_sample': 1500, 'p_max': 10, 'tol': 1e-7}\n    p1 = analyze_orbit(**params1)\n    results.append(p1)\n\n    # Case 2: Period detection in chaotic region\n    params2 = {'r': 3.57, 'x0': 0.5, 'N_transient': 2000, 'N_sample': 1500, 'p_max': 10, 'tol': 1e-7}\n    p2 = analyze_orbit(**params2)\n    results.append(p2)\n\n    # Cases 3 and 4: Measure and segment count of period-3 window\n    r_min3, r_max3, dr3 = 3.82, 3.86, 1e-4\n    params3 = {'x0': 0.5, 'N_transient': 2000, 'N_sample': 1000, 'p_max': 10, 'tol': 1e-7}\n    target_p3 = 3\n    \n    num_points3 = int(round((r_max3 - r_min3) / dr3)) + 1\n    r_values3 = np.linspace(r_min3, r_max3, num_points3)\n    \n    measure3 = 0.0\n    segments4 = 0\n    in_segment = False\n    \n    for r_val in r_values3:\n        p = analyze_orbit(r_val, **params3)\n        if p == target_p3:\n            measure3 += dr3\n            if not in_segment:\n                segments4 += 1\n                in_segment = True\n        else:\n            in_segment = False\n            \n    m3 = round(measure3, 6)\n    c4 = segments4\n    results.append(f\"{m3:.6f}\")\n    results.append(c4)\n\n    # Case 5: Measure of period-3 windows over a wider interval\n    r_min5, r_max5, dr5 = 3.5, 4.0, 1e-3\n    params5 = {'x0': 0.5, 'N_transient': 2000, 'N_sample': 1000, 'p_max': 10, 'tol': 1e-7}\n    target_p5 = 3\n    \n    num_points5 = int(round((r_max5 - r_min5) / dr5)) + 1\n    r_values5 = np.linspace(r_min5, r_max5, num_points5)\n    \n    measure5 = 0.0\n    for r_val in r_values5:\n        p = analyze_orbit(r_val, **params5)\n        if p == target_p5:\n            measure5 += dr5\n\n    m5 = round(measure5, 6)\n    results.append(f\"{m5:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}