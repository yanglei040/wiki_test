{
    "hands_on_practices": [
        {
            "introduction": "理论的深刻理解是进行有效数值模拟的基石。在深入编写代码之前，我们首先通过一个解析练习来剖析PIC模拟中的一个关键数值效应——自洽力。这个练习将推导在一个离散网格系统中，单个粒子因其自身电荷与网格相互作用而受到的非物理作用力，这有助于我们从根本上理解数值加热和能量不守恒的来源。",
            "id": "296780",
            "problem": "在一维静电网格粒子（PIC）模拟中，若使用线性权重（也称为云中单元法或 CIC），带电粒子会与计算网格相互作用，从而产生一种非物理的“自作用力”。这种力的产生是由于粒子自身的电荷在分配到网格上时，会形成一个网格化的电场，该电场经过插值后又反作用于粒子本身。这种伪力是空间离散化的直接后果，它会导致数值加热和能量不守恒。\n\n对于一个电荷为 $q$ 的单个粒子，处在一个网格间距为 $\\Delta x$、真空介电常数为 $\\epsilon_0$ 的无限长一维系统中，可以证明其自身网格化电场的势能 $U_{self}$ 会随其在网格单元内的位置而变化。该势能以网格周期 $\\Delta x$ 呈周期性变化，在一个由网格节点 $x_j$ 和 $x_{j+1}$ 定义的给定单元内，其表达式为：\n$$\nU_{self}(x) = \\frac{q^2 \\Delta x}{2\\epsilon_0} u(1-u)\n$$\n其中 $u = \\frac{x - x_j}{\\Delta x}$ 是粒子在单元内的归一化位置，适用于 $x \\in [x_j, x_{j+1}]$。该能量在单元边界处（$u=0$ 和 $u=1$）为零，在单元中心处（$u=1/2$）达到最大值。\n\n与此自势能相关的保守力为 $F_{self}(x) = -\\frac{\\partial U_{self}}{\\partial x}$。当粒子在单元内移动时，这个力会发生变化，其在一个单元内的空间平均值为零。为量化该力的典型大小，计算其均方根（RMS）值是很有用的。\n\n对于在单个网格单元内均匀分布的粒子，请推导其自作用力的均方根值 $F_{RMS}$。",
            "solution": "相关的自势能和归一化位置：\n$$U_{self}(x)=\\frac{q^2\\Delta x}{2\\epsilon_0}\\,u(1-u),\\qquad u=\\frac{x-x_j}{\\Delta x}.$$  \n自作用力：\n$$F_{self}(x)=-\\frac{\\partial U_{self}}{\\partial x}\n=-\\frac{1}{\\Delta x}\\frac{\\partial}{\\partial u}\\Bigl(\\frac{q^2\\Delta x}{2\\epsilon_0}u(1-u)\\Bigr)$$  \n$$\\;=\\;-\\,\\frac{q^2}{2\\epsilon_0}(1-2u)\n=\\frac{q^2}{2\\epsilon_0}(2u-1).$$  \n\n对其平方并在 $u\\in[0,1]$ 上求平均：\n$$F_{self}^2=\\frac{q^4}{4\\epsilon_0^2}(2u-1)^2,$$  \n$$\\langle F^2\\rangle=\\int_0^1\\frac{q^4}{4\\epsilon_0^2}(2u-1)^2\\,du\n=\\frac{q^4}{4\\epsilon_0^2}\\int_0^1(4u^2-4u+1)\\,du\n=\\frac{q^4}{4\\epsilon_0^2}\\cdot\\frac{1}{3}.$$\n\n因此，均方根自作用力为\n$$F_{RMS}=\\sqrt{\\langle F^2\\rangle}\n=\\frac{q^2}{2\\epsilon_0}\\sqrt{\\frac{1}{3}}\n=\\frac{q^2}{2\\sqrt{3}\\,\\epsilon_0}.$$",
            "answer": "$$\\boxed{\\frac{q^2}{2\\sqrt{3}\\,\\epsilon_0}}$$"
        },
        {
            "introduction": "将理论付诸实践是计算科学的核心。基于前一个练习对自洽力的理论分析，我们现在将编写一个精简的1D PIC程序来实际测量这一数值误差。通过这个实践，你将学会实现电荷分配、谱方法求解电场以及场插值等PIC核心算法，并直观地看到粒子形状函数和网格分辨率等参数如何影响模拟的精度。",
            "id": "3171279",
            "problem": "您的任务是实现一个最小的一维（$1$D）真空粒子网格（PIC）模拟，以量化自作用力误差。在物理上正确的真空中，单个孤立的宏粒子应经历零加速度，因为没有外部场，并且在连续理论中，粒子不会对自己产生作用。然而，在离散的粒子网格（PIC）系统中，有限的网格间距和粒子形状会导致非零的虚假自作用力。您的任务是测量这种虚假加速度的大小，将其作为粒子形状阶数和网格间距的函数。\n\n从基本电磁定律开始。使用静电学中的高斯定律，该定律指出电场的散度等于电荷密度除以介电常数，即 $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$。在一维空间、周期性边界条件和时不变场的情况下，使用静电势 $\\phi$，使得 $\\mathbf{E} = -\\nabla \\phi$ 和 $\\partial^2 \\phi / \\partial x^2 = -\\rho / \\varepsilon_0$。在归一化单位制下工作，使得区域长度、粒子电荷、粒子质量和真空介电常数均为1，即 $L = 1$，$q = 1$，$m = 1$，和 $\\varepsilon_0 = 1$。在这些归一化单位下，加速度等于在粒子位置处计算的电场，即 $a = E(x)$。\n\n在程序中实现以下算法：\n\n- 区域和网格：使用长度为 $L = 1$ 的周期性区域。使用 $N$ 个均匀间隔的节点进行离散化，节点位置为 $x_i = i \\Delta x$，$i \\in \\{0, 1, \\dots, N-1\\}$，其中 $\\Delta x = L/N$。\n- 单个粒子：放置一个电荷为 $q = 1$、质量为 $m = 1$ 的宏粒子在位置 $x_0 \\in [0, L)$。\n- 电荷分配（沉积）：使用阶数为 $S_m \\in \\{0, 1, 2\\}$ 的B样条形状函数，将粒子电荷沉积到网格节点上，并进行周期性环绕处理。将归一化距离 $r = (x_0 - x_i)/\\Delta x$ 通过周期性约化到 $(-\\tfrac{1}{2}N, \\tfrac{1}{2}N)$，然后使用最小周期性镜像将其约化到局部单元中心区间。形状权重 $w_i$ 必须满足 $\\sum_i w_i = 1$。使用以下标准的一维形状函数：\n  - 阶数 $S_m = 0$ (最近网格点法, NGP): 若 $|r|  \\tfrac{1}{2}$ 则 $W_0(r) = 1$，否则为 $0$。\n  - 阶数 $S_m = 1$ (单元云法, CIC): 对于 $|r|  1$，$W_1(r) = 1 - |r|$，否则为 $0$。\n  - 阶数 $S_m = 2$ (三角形状云法, TSC): \n    - 对于 $|r| \\le \\tfrac{1}{2}$，$W_2(r) = \\tfrac{3}{4} - r^2$，\n    - 对于 $\\tfrac{1}{2}  |r|  \\tfrac{3}{2}$，$W_2(r) = \\tfrac{1}{2} \\left(\\tfrac{3}{2} - |r|\\right)^2$，\n    - 否则 $W_2(r) = 0$。\n  通过 $\\rho_i = q \\, w_i / \\Delta x$ 形成网格电荷密度。\n- 场求解（周期性边界条件下的静电学）：使用离散傅里叶变换求解离散的周期性泊松系统。设 $\\hat{\\rho}(k)$ 为 $\\rho_i$ 的离散傅里叶变换。对于每个非零角波数 $k$，设置 $\\hat{E}(k) = -\\mathrm{i} \\, \\hat{\\rho}(k) / k$。对于 $k = 0$，设置 $\\hat{E}(0) = 0$，以强制与周期性一致的零均值场。进行逆变换以获得网格节点上的实空间场 $E_i$。\n- 场到粒子的插值：使用相同的形状权重将电场插值回粒子位置，$E(x_0) = \\sum_i E_i \\, w_i$。\n- 虚假加速度：计算加速度 $a = q E(x_0)/m$，并报告其大小 $|a|$，作为一个无量纲数。\n\n使用指定的归一化单位（所有量均为无量纲），并将加速度报告为四舍五入到 $10$ 位小数的无量纲浮点数。\n\n测试套件。在以下参数集上运行您的程序，每个参数集由 $(N, S_m, x_0)$ 指定，其中 $L=1$：\n- 案例 1: $(16, 0, 0.13)$\n- 案例 2: $(16, 1, 0.13)$\n- 案例 3: $(16, 2, 0.13)$\n- 案例 4: $(64, 2, 0.13)$\n- 案例 5: $(64, 2, 0.5)$\n- 案例 6: $(32, 1, 1/(2 \\cdot 32))$ 即等于 $(32, 1, 0.015625)$\n\n最终输出格式。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果与测试套件的顺序相同，且每个值都四舍五入到 $10$ 位小数（例如，$[0.1230000000,0.0456000000,\\dots]$）。",
            "solution": "用户希望实现一个一维粒子网格（PIC）模拟，以计算周期性区域中单个粒子的虚假自作用力。\n\n### 步骤 1：问题验证\n\n**1.1. 提取的已知条件**\n- **物理模型：** 一维静电学，周期性边界条件。\n- **控制方程：** $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$，在一维情况下，当 $\\mathbf{E} = -\\nabla \\phi$ 时，变为 $\\partial^2 \\phi / \\partial x^2 = -\\rho / \\varepsilon_0$。\n- **归一化单位：** 区域长度 $L=1$，粒子电荷 $q=1$，粒子质量 $m=1$，真空介电常数 $\\varepsilon_0=1$。这意味着加速度 $a = E(x)$。\n- **离散化：**\n    - 将区域 $[0, L)$ 离散化为 $N$ 个大小为 $\\Delta x = L/N$ 的网格单元。\n    - 网格节点位于 $x_i = i \\Delta x$，$i \\in \\{0, \\dots, N-1\\}$。\n- **粒子：** 一个位于位置 $x_0$ 的单个粒子。\n- **算法：**\n    1.  **电荷沉积：** 使用权重 $w_i$ 将粒子电荷 $q$ 分配到网格节点 $i$ 上。权重由阶数为 $S_m \\in \\{0, 1, 2\\}$ 的 B 样条形状函数 $W_{S_m}(r)$ 导出，其中 $r = (x_0 - x_i)/\\Delta x$ 是使用最小周期性镜像计算的。网格电荷密度为 $\\rho_i = q w_i / \\Delta x$。\n        - 阶数 $S_m = 0$ (NGP)：若 $|r|  0.5$ 则 $W_0(r) = 1$，否则为 $0$。\n        - 阶数 $S_m = 1$ (CIC)：若 $|r|  1$ 则 $W_1(r) = 1 - |r|$，否则为 $0$。\n        - 阶数 $S_m = 2$ (TSC)：若 $|r| \\le 0.5$ 则 $W_2(r) = \\tfrac{3}{4} - r^2$；若 $0.5  |r|  1.5$ 则 $W_2(r) = \\tfrac{1}{2}(\\tfrac{3}{2} - |r|)^2$；否则为 $0$。\n    2.  **场求解：** 使用离散傅里叶变换（DFT）求解网格上的电场 $E_i$。\n        - 设 $\\hat{\\rho}(k)$ 为 $\\rho_i$ 的 DFT。\n        - 电场的 DFT 为 $\\hat{E}(k) = -\\mathrm{i} \\, \\hat{\\rho}(k) / k$，对于非零角波数 $k$。\n        - $\\hat{E}(k=0) = 0$。\n        - 通过对 $\\hat{E}(k)$ 进行逆 DFT 获得 $E_i$。\n    3.  **场插值：** 使用相同的权重将网格场插值到粒子位置：$E(x_0) = \\sum_i E_i w_i$。\n    4.  **加速度：** 计算加速度 $a = q E(x_0)/m$ 并报告 $|a|$。\n- **测试案例：**\n    - $(N, S_m, x_0) = (16, 0, 0.13)$\n    - $(N, S_m, x_0) = (16, 1, 0.13)$\n    - $(N, S_m, x_0) = (16, 2, 0.13)$\n    - $(N, S_m, x_0) = (64, 2, 0.13)$\n    - $(N, S_m, x_0) = (64, 2, 0.5)$\n    - $(N, S_m, x_0) = (32, 1, 0.015625)$\n- **输出格式：** 单行输出，包含一个用方括号括起来的逗号分隔列表，结果四舍五入到10位小数。\n\n**1.2. 验证**\n该问题具有科学依据，描述了计算等离子体物理学中的一个标准数值实验。物理和数学框架（一维静电学、泊松方程、周期性边界）是健全的。指定的算法是一种成熟的伪谱粒子网格方法。所有参数、定义和方程都已提供，使得问题自成体系且适定。措辞客观明确。测试案例选择得当，包括高对称性的情况（$x_0$ 在网格节点上，$x_0$ 在单元中心），其中自作用力预期为零，这提供了一个强有力的正确性检查。该问题没有违反任何无效性标准。\n\n**1.3. 结论**\n该问题是 **有效的**。\n\n### 步骤 2：解决方案设计\n\n实现将精确遵循指定的算法。一个主函数 `calculate_self_force(N, Sm, x0)` 将封装单个测试案例的逻辑。将为 B 样条形状函数定义辅助函数。总体流程如下：\n\n1.  **初始化：** 设置物理常数（$L, q, m$）并推导网格参数（$\\Delta x$）。\n2.  **权重计算：** 一个辅助函数 `get_weights` 将为给定的粒子位置 $x_0$、网格大小 $N$ 和形状阶数 $S_m$ 计算权重 $\\{w_i\\}$。这涉及为每个网格节点 $i$ 计算归一化的周期性距离 $r = (x_0 - x_i)/\\Delta x$，并应用相应的形状函数 $W_{S_m}(r)$。\n3.  **电荷沉积：** 网格电荷密度 $\\rho$ 计算为 $\\rho_i = q \\cdot w_i / \\Delta x$。由于 $q=1$，这简化为 $\\rho_i = w_i / \\Delta x$。\n4.  **傅里叶空间中的场计算：**\n    - 使用 `numpy.fft.fft` 函数计算 `rho_grid` 的 DFT，得到 `rho_hat`。\n    - 使用 `numpy.fft.fftfreq` 并通过 $2\\pi$ 和网格间距进行缩放，来获得相应的角波数 $k$。\n    - 使用提供的公式 $\\hat{E}(k) = -\\mathrm{i} \\, \\hat{\\rho}(k) / k$ 计算傅里叶空间中的电场 `E_hat`。需特别注意 $k=0$ 的模式，将其设置为零，以避免除以零并强制零均值场。\n5.  **实空间中的场：** 通过对 `E_hat` 应用逆 DFT（`numpy.fft.ifft`）并取实部，来恢复网格电场 $E_i$。\n6.  **力插值：** 通过使用相同的权重对网格场进行插值，计算粒子位置处的电场 $E(x_0)$：$E(x_0) = \\sum_i E_i w_i$。这是网格场向量和权重向量之间的点积。\n7.  **加速度计算：** 在归一化单位（$q=1, m=1$）下，加速度就等于插值得到的场，$a = E(x_0)$。其大小 $|a|$ 就是所需的结果。\n8.  **执行循环：** 一个主函数 `solve` 将遍历提供的测试套件，为每个案例调用 `calculate_self_force`，将结果格式化为10位小数，并按指定的列表格式打印它们。\n\n对于案例5（$x_0=0.5$ 在网格节点上）和案例6（$x_0=0.5 \\Delta x$ 在单元中心），由于对称性，力预期为零。任何非零结果都将在机器浮点精度的数量级上。",
            "answer": "```python\nimport numpy as np\n\ndef _get_shape_function(Sm):\n    \"\"\"Returns the appropriate B-spline shape function for a given order.\"\"\"\n    if Sm == 0:\n        # Order 0: Nearest Grid Point (NGP)\n        def W(r):\n            ar = np.abs(r)\n            if ar  0.5:\n                return 1.0\n            return 0.0\n    elif Sm == 1:\n        # Order 1: Cloud-In-Cell (CIC) or Linear\n        def W(r):\n            ar = np.abs(r)\n            if ar  1.0:\n                return 1.0 - ar\n            return 0.0\n    elif Sm == 2:\n        # Order 2: Triangular Shaped Cloud (TSC) or Quadratic\n        def W(r):\n            ar = np.abs(r)\n            if ar = 0.5:\n                return 0.75 - ar**2\n            elif ar  1.5:\n                return 0.5 * (1.5 - ar)**2\n            return 0.0\n    else:\n        raise ValueError(\"Shape function order Sm must be 0, 1, or 2.\")\n    return W\n\ndef get_weights(N, Sm, x0, delta_x, L):\n    \"\"\"\n    Calculates the charge weights on the grid for a single particle.\n    The weights are calculated based on the particle's position relative to grid nodes.\n    \"\"\"\n    weights = np.zeros(N)\n    shape_func = _get_shape_function(Sm)\n    \n    # Vectorized calculation for efficiency\n    grid_indices = np.arange(N)\n    grid_positions = grid_indices * delta_x\n    \n    # Calculate distance from particle to each grid node\n    d = x0 - grid_positions\n    \n    # Apply periodic boundary condition to find the minimum image distance\n    d_periodic = (d + L/2) % L - L/2\n    \n    # Normalize distance by grid spacing\n    r = d_periodic / delta_x\n    \n    # Apply the shape function to the normalized distances\n    # This is faster than a Python loop for large N.\n    v_shape_func = np.vectorize(shape_func)\n    weights = v_shape_func(r)\n    \n    # As a property of B-splines (partition of unity), the sum should be 1.\n    # A small tolerance is used to account for floating-point inaccuracies.\n    assert np.isclose(np.sum(weights), 1.0), \"Sum of weights is not 1.\"\n\n    return weights\n\ndef calculate_self_force(N, Sm, x0):\n    \"\"\"\n    Implements the 1D PIC algorithm to find the spurious self-force on a single particle.\n    \"\"\"\n    # 1. Domain and particle properties (normalized units)\n    L = 1.0\n    q = 1.0\n    m = 1.0\n    delta_x = L / N\n\n    # 2. Charge Assignment (Deposition)\n    # Get the weights for each grid node. These same weights will be used for interpolation.\n    weights = get_weights(N, Sm, x0, delta_x, L)\n\n    # Calculate charge density on the grid: rho_i = q * w_i / delta_x\n    rho_grid = (q / delta_x) * weights\n\n    # 3. Field Solve (using Discrete Fourier Transform)\n    # Perform DFT on the charge density\n    rho_hat = np.fft.fft(rho_grid)\n    \n    # Get the corresponding frequencies and angular wavenumbers\n    # The sample spacing 'd' for fftfreq is the grid spacing delta_x\n    freqs = np.fft.fftfreq(N, d=delta_x)\n    k = 2.0 * np.pi * freqs\n    \n    # Calculate the electric field in Fourier space\n    E_hat = np.zeros_like(rho_hat, dtype=complex)\n    \n    # Create a mask for non-zero wavenumbers to avoid division by zero\n    k_nonzero_mask = (k != 0)\n    \n    # E_hat(k) = -i * rho_hat(k) / k for k != 0\n    E_hat[k_nonzero_mask] = -1j * rho_hat[k_nonzero_mask] / k[k_nonzero_mask]\n    \n    # E_hat(k=0) must be 0, which is handled by the mask and np.zeros_like initialization.\n    \n    # Perform Inverse DFT to get the electric field on the grid\n    E_grid = np.real(np.fft.ifft(E_hat))\n\n    # 4. Field Interpolation to Particle\n    # Interpolate the electric field back to the particle's position using the same weights\n    # E(x0) = sum(E_i * w_i)\n    E_particle = np.dot(E_grid, weights)\n    \n    # 5. Spurious Acceleration\n    # a = q * E(x0) / m. With normalized units, a = E(x0)\n    acceleration = E_particle / m\n    \n    return np.abs(acceleration)\n\ndef solve():\n    \"\"\"\n    Runs the simulation for the specified test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        # (N, Sm, x0)\n        (16, 0, 0.13),\n        (16, 1, 0.13),\n        (16, 2, 0.13),\n        (64, 2, 0.13),\n        (64, 2, 0.5),\n        (32, 1, 1.0 / (2.0 * 32.0)), # which is 0.015625\n    ]\n\n    results = []\n    for N, Sm, x0 in test_cases:\n        accel_magnitude = calculate_self_force(N, Sm, x0)\n        results.append(f\"{accel_magnitude:.10f}\")\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "一个可靠的模拟程序必须遵守基本的物理守恒律。在最后的这项综合性实践中，我们将构建一个完整的动态1D PIC模拟，用于检验动量守恒。通过模拟经典的双流不稳定性问题，你将把之前学到的所有部件（电荷分配、场求解、力插值）与粒子推进器（蛙跳法）结合起来，并观察微小的自洽力误差如何随时间累积，最终影响整个系统的宏观守恒量。",
            "id": "3171208",
            "problem": "您必须编写一个完整、可运行的程序，该程序执行一维静电网格粒子 (Particle-In-Cell, PIC) 模拟，通过碰撞两个相等、反向流动的束流并测量质心随时间的漂移来验证动量守恒。该程序必须使用基本物理定律和核心数值定义来实现自洽场计算和粒子推进。所有量均以无量纲的归一化单位表示，其中粒子质量为 $m=1$，电子的粒子电荷为 $q=-1$，自由空间介电常数为 $\\epsilon_0=1$，域长度为 $L=1$，因此最终结果是无量纲的。在区间 $[0,L)$ 上使用周期性边界条件。\n\n从以下基本原理开始：\n- 牛顿第二定律：对于每个粒子索引 $i$，$m \\, \\frac{d v_i}{d t} = q \\, E(x_i)$。\n- 运动学：$\\frac{d x_i}{d t} = v_i$。\n- 包含确保中性的均匀离子背景的静电学：电势 $\\phi(x)$ 满足一维泊松方程 $\\frac{d^2 \\phi}{d x^2} = -\\frac{\\rho(x)}{\\epsilon_0}$，电场满足 $E(x) = -\\frac{d \\phi}{d x}$，其中 $\\rho(x)$ 是电荷密度。\n- 使用快速傅里叶变换 (FFT) 在傅里叶空间中进行离散场求解：对于波数 $k \\neq 0$，傅里叶系数满足 $\\phi_k = \\frac{\\rho_k}{\\epsilon_0 k^2}$ 和 $E_k = - i k \\phi_k$，并将 $k=0$ 模式设置为零以移除均匀背景分量。\n\n实现具有以下数值组件的网格粒子 (PIC) 方法 (Particle-In-Cell (PIC))：\n- 云中元 (CIC) 电荷分配和场插值 (Cloud-In-Cell (CIC))：将粒子电荷分配到网格上以获得 $\\rho(x)$，并使用相同的线性权重将 $E(x)$ 从网格插值到粒子位置。\n- 粒子的蛙跳法时间积分器：速度定义在半时间步上，位置定义在整数时间步上，具体为 $v_{i}^{n+\\frac{1}{2}} = v_{i}^{n-\\frac{1}{2}} + \\frac{q}{m} E(x_i^n) \\Delta t$ 和 $x_i^{n+1} = x_i^n + v_{i}^{n+\\frac{1}{2}} \\Delta t$，并进行周期性环绕 $x \\mapsto x \\bmod L$。\n\n初始化：\n- 在 $[0,L)$ 范围内均匀随机放置 $N$ 个电子。\n- 将一半电子赋予恒定速度 $+v_0$，另一半赋予 $-v_0$，以形成两个相等的反向流动束流。\n- 包含一个均匀的离子背景电荷密度，该密度恰好抵消了平均电子电荷密度，从而使系统整体呈电中性。\n\n测量目标：\n- 令 $P(t) = \\sum_{i=1}^{N} m \\, v_i(t)$ 表示总动量，令 $V_{\\mathrm{cm}}(t) = \\frac{P(t)}{N m}$ 表示质心速度。使用 $X_{\\mathrm{cm}}(t) - X_{\\mathrm{cm}}(0) = \\int_0^t V_{\\mathrm{cm}}(t') \\, dt'$，在模拟时间内对 $V_{\\mathrm{cm}}(t)$ 进行数值积分，以获得质心位移 $S(t)$。报告在整个模拟时间内质心位移的最大绝对值，并由域长度 $L$ 进行归一化，即 $D = \\max_t \\frac{|S(t)|}{L}$。\n\n您的程序必须：\n1. 实现上述具有周期性边界条件和使用 FFT 的谱方法泊松求解器的一维 PIC 算法。\n2. 一致地使用云中元 (CIC) 电荷分配和插值。\n3. 使用蛙跳法方案进行粒子更新，该方案通过初始场的半步加速来初始化 $v^{\\frac{1}{2}}$。\n4. 为保证可复现性，为每个测试用例使用一个固定的伪随机种子。\n\n测试套件：\n为以下参数集运行您的程序，每个用例返回一个结果：\n- 用例 1（一般情况）：$N=800$, $N_g=128$, $\\Delta t=0.01$, $T=400$ 步, $v_0=0.2$, $L=1$, 种子 $= 12345$。\n- 用例 2（更小时间步）：$N=800$, $N_g=128$, $\\Delta t=0.005$, $T=400$ 步, $v_0=0.2$, $L=1$, 种子 $= 12346$。\n- 用例 3（更粗糙的网格和更少的粒子）：$N=200$, $N_g=64$, $\\Delta t=0.01$, $T=400$ 步, $v_0=0.2$, $L=1$, 种子 $= 12347$。\n- 用例 4（更大时间步和更粗糙的网格）：$N=800$, $N_g=64$, $\\Delta t=0.015$, $T=400$ 步, $v_0=0.2$, $L=1$, 种子 $= 12348$。\n\n输出规格：\n- 对于每个用例，计算整个模拟过程中的 $D = \\max_t \\frac{|S(t)|}{L}$。\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号内以逗号分隔的列表，每个值四舍五入到六位小数，例如，\"[0.000001,0.000002,0.000100,0.000500]\"。\n- 所有返回的值都是无量纲浮点数。\n\n科学真实性和约束：\n- 仅使用给定的基本原理和数值构造。\n- 确保电荷分配和插值使用相同的线性权重。\n- 强制执行周期性边界条件。\n- 使用将 $k=0$ 模式设置为零的谱方法场求解，以避免奇点并移除均匀背景。\n\n不允许使用外部输入或文件。代码必须完全自包含且可执行。",
            "solution": "用户的问题陈述已经过分析，并被确定为**有效**的。它具有科学依据、自成体系且定义明确。任务是实现一个一维静电网格粒子 (PIC) 模拟，以量化双流不稳定性场景中动量守恒的数值误差。\n\n### 1. 网格粒子方法的原理\n\n网格粒子 (Particle-In-Cell, PIC) 方法是一种数值技术，用于模拟等离子体的动力学。等离子体由带电粒子组成，这些粒子通过自生产生的电磁场相互作用。该模拟通过将粒子运动（由洛伦兹力支配）与场演化（由麦克斯韦方程组支配）在一个自洽循环中耦合，来演化系统。在此问题中，我们考虑一个静电系统，将场方程简化为泊松方程。核心的 PIC 循环包括四个主要步骤：\n\n1.  **电荷分配**：将离散“宏粒子”的电荷分配到计算网格上，以计算连续的电荷密度场 $\\rho(x)$。\n2.  **场求解**：通过使用上一步得到的电荷密度求解泊松方程，在网格上计算电场 $E(x)$。\n3.  **力插值**：将电场从网格节点插值回连续的粒子位置。\n4.  **粒子推进**：通过对粒子的运动方程进行积分，并使用插值得到的力，来在时间上推进粒子。\n\n### 2. 数值实现细节\n\n该模拟按照规范实现，使用无量纲单位，其中粒子质量 $m=1$，粒子电荷 $q=-1$，自由空间介电常数 $\\epsilon_0=1$，以及域长度 $L=1$。\n\n#### 2.1. 电荷分配和力插值\n\n我们使用云中元 (Cloud-In-Cell, CIC) 方案，这是一种一阶（线性）权重方法。对于一个位于网格节点 $x_j=j\\Delta x$ 和 $x_{j+1}=(j+1)\\Delta x$ 之间的网格单元中的粒子（位置为 $x_p$），其中 $\\Delta x = L/N_g$ 是网格间距，其电荷被分配到这两个节点之间。令 $j = \\lfloor x_p/\\Delta x \\rfloor$ 为左侧网格节点的索引。到下一个节点的相对距离是 $h = (x_p/\\Delta x) - j$。然后，粒子的电荷 $q_p$ 被分配为：\n- $q_j = q_p (1-h)$ 到节点 $j$。\n- $q_{j+1} = q_p h$ 到节点 $j+1$。\n\n每个网格节点上的总电荷是所有粒子贡献的总和。电荷密度则为 $\\rho_j = Q_j / \\Delta x$，其中 $Q_j$ 是节点 $j$ 上的总电荷。\n对于力插值，使用相同的线性权重因子来计算粒子位置处的电场：\n$$\nE(x_p) = E_j(1-h) + E_{j+1}h\n$$\n其中 $E_j$ 和 $E_{j+1}$ 是节点 $j$ 和 $j+1$ 处的电场。\n\n#### 2.2. 谱方法场求解\n\n一维泊松方程 $\\frac{d^2\\phi}{dx^2} = -\\frac{\\rho}{\\epsilon_0}$ 在傅里叶空间中变成一个代数方程。进行傅里叶变换得到：\n$$\n(-k^2) \\phi_k = -\\frac{\\rho_k}{\\epsilon_0} \\implies \\phi_k = \\frac{\\rho_k}{\\epsilon_0 k^2}\n$$\n其中 $k$ 是波数。类似地，关系式 $E = -\\frac{d\\phi}{dx}$ 变为 $E_k = -i k \\phi_k$。算法如下：\n1.  在网格上计算 $\\rho_j$。\n2.  计算其离散傅里叶变换 $\\rho_k = \\text{FFT}(\\rho_j)$。\n3.  与网格对应的波数是 $k_m = \\frac{2\\pi m}{L}$，其中 $m$ 是整数模式。对于离散 FFT，这些波数通过 `fftfreq` 生成。\n4.  对于 $k \\neq 0$，计算 $\\phi_k = \\frac{\\rho_k}{\\epsilon_0 k^2}$。$k=0$ 模式（对应于平均电势）被设置为零（$\\phi_{k=0}=0$），这与系统整体电荷中性（电子加上均匀的离子背景）相一致。这避免了除零奇点。\n5.  计算电场变换 $E_k = -i k \\phi_k$。\n6.  计算傅里叶逆变换 $E_j = \\text{IFFT}(E_k)$ 以获得网格上的电场。\n\n#### 2.3. 粒子推进器：蛙跳法积分器\n\n蛙跳法是一种二阶精度的时间积分方案，对于哈密顿系统是正则的（保持相空间体积）。它将位置和速度在时间上交错：位置定义在整数时间步（$t^n = n\\Delta t$），而速度定义在半时间步（$t^{n \\pm 1/2} = (n \\pm 1/2)\\Delta t$）。更新方程为：\n$$\nv_i^{n+\\frac{1}{2}} = v_i^{n-\\frac{1}{2}} + \\frac{q}{m} E(x_i^n) \\Delta t\n$$\n$$\nx_i^{n+1} = x_i^n + v_i^{n+\\frac{1}{2}} \\Delta t\n$$\n对粒子位置应用周期性边界条件：$x_i \\rightarrow x_i \\pmod L$。\n\n为了初始化此方案，我们从 $t=0$ 时的位置 $x_i^0$ 和速度 $v_i^0$ 开始。主循环需要半时间步上的速度。我们需要 $v_i^{-1/2}$ 来开始第一步（$n=0$）。通过将初始速度中心化 $v_i^0 = \\frac{1}{2}(v_i^{-1/2} + v_i^{1/2})$ 并使用更新规则，我们可以推导出所需的起始速度表达式：\n$$\nv_i^{-1/2} = v_i^0 - \\frac{1}{2}\\frac{q}{m} E(x_i^0) \\Delta t\n$$\n这涉及使用从初始粒子位置计算的电场进行一个“后退”半步。\n\n### 3. 质心漂移的测量\n\n由于只存在内力，系统的总动量应该守恒。总动量的任何变化都是由数值误差引起的，例如离散系统中自作用力的不完全抵消。我们通过跟踪质心位移来测量这个误差。\n\n在每个整数时间步 $n$，需要速度 $v_i^n$。它通过平均半时间步速度来计算：\n$$\nv_i^n = \\frac{1}{2} (v_i^{n-\\frac{1}{2}} + v_i^{n+\\frac{1}{2}})\n$$\n质心速度则为 $V_{\\mathrm{cm}}^n = \\frac{\\sum_i m v_i^n}{N m}$。位移 $S(t)$ 是 $V_{\\mathrm{cm}}$ 的时间积分，我们将其数值近似为一个累积和：\n$$\nS^k = \\sum_{n=0}^{k-1} V_{\\mathrm{cm}}^n \\Delta t\n$$\n需要报告的度量指标是模拟过程中最大绝对位移，并由域长度归一化：$D = \\frac{1}{L} \\max_{k} |S^k|$。对于理想的模拟，$D=0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_pic_simulation(N, Ng, dt, T_steps, v0, L, seed):\n    \"\"\"\n    Performs a 1D electrostatic Particle-In-Cell (PIC) simulation.\n\n    Args:\n        N (int): Number of particles.\n        Ng (int): Number of grid points.\n        dt (float): Time step.\n        T_steps (int): Total number of time steps.\n        v0 (float): Initial beam speed.\n        L (float): Length of the periodic domain.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        float: The maximum absolute center-of-mass displacement normalized by L.\n    \"\"\"\n    # 1. Define constants and simulation parameters\n    m = 1.0  # Particle mass\n    q = -1.0  # Particle charge\n    eps0 = 1.0 # Permittivity of free space\n    dx = L / Ng   # Grid spacing\n\n    # 2. Grid and k-space setup\n    # Define wavenumbers for the spectral solver.\n    k_vec = 2 * np.pi / L * np.fft.fftfreq(Ng, d=dx)\n    k_squared = k_vec**2\n    # Pre-calculate indices of non-zero k modes to avoid division by zero.\n    non_zero_k_indices = k_squared != 0\n\n    # 3. Particle initialization\n    rng = np.random.default_rng(seed)\n    # Uniformly random positions in [0, L)\n    pos = rng.random(N, dtype=np.float64) * L\n    # Two counter-streaming beams\n    vel = np.full(N, v0, dtype=np.float64)\n    vel[N // 2:] = -v0\n\n    # 4. Leapfrog Initialization\n    # To start the leapfrog integrator, we need v^{-1/2}.\n    # We first compute the initial electric field E(x^0).\n    \n    # 4a. Initial charge deposition (CIC)\n    rho = np.zeros(Ng, dtype=np.float64)\n    j_indices = (pos / dx).astype(int)\n    h = (pos / dx) - j_indices\n    w_left = 1.0 - h\n    w_right = h\n    np.add.at(rho, j_indices, q * w_left)\n    np.add.at(rho, (j_indices + 1) % Ng, q * w_right)\n    rho /= dx  # Convert charge to charge density\n\n    # 4b. Initial field solve (spectral)\n    rho_k = np.fft.fft(rho)\n    phi_k = np.zeros_like(rho_k)\n    phi_k[non_zero_k_indices] = rho_k[non_zero_k_indices] / (eps0 * k_squared[non_zero_k_indices])\n    E_k = -1j * k_vec * phi_k\n    E_grid = np.fft.ifft(E_k).real\n\n    # 4c. Initial force interpolation and velocity kick-back\n    E_p = E_grid[j_indices] * w_left + E_grid[(j_indices + 1) % Ng] * w_right\n    a0 = (q / m) * E_p\n    vel_half = vel - 0.5 * a0 * dt  # This is v^{-1/2}\n\n    # 5. Measurement initialization\n    s_cm = 0.0\n    max_s_cm_abs = 0.0\n\n    # 6. Main PIC Loop\n    for _ in range(T_steps):\n        # At the start of step n, we have pos (x^n) and vel_half (v^{n-1/2})\n        \n        # 6a. Charge Deposition (CIC)\n        rho.fill(0)\n        j_indices = (pos / dx).astype(int)\n        h = (pos / dx) - j_indices\n        w_left = 1.0 - h\n        w_right = h\n        np.add.at(rho, j_indices, q * w_left)\n        np.add.at(rho, (j_indices + 1) % Ng, q * w_right)\n        rho /= dx\n        \n        # 6b. Field Solve (spectral)\n        rho_k = np.fft.fft(rho)\n        phi_k.fill(0)\n        phi_k[non_zero_k_indices] = rho_k[non_zero_k_indices] / (eps0 * k_squared[non_zero_k_indices])\n        E_k = -1j * k_vec * phi_k\n        E_grid = np.fft.ifft(E_k).real\n\n        # 6c. Force Interpolation (CIC)\n        E_p = E_grid[j_indices] * w_left + E_grid[(j_indices + 1) % Ng] * w_right\n        an = (q / m) * E_p # Acceleration a^n\n\n        # 6d. Particle Push (Leapfrog) - Velocity update\n        vel_next_half = vel_half + an * dt # This gives v^{n+1/2}\n\n        # 6e. Measurement\n        # Get velocity at integer time step n: v^n = 0.5 * (v^{n-1/2} + v^{n+1/2})\n        vel_full = 0.5 * (vel_half + vel_next_half)\n        total_momentum = np.sum(m * vel_full)\n        v_cm = total_momentum / (N * m)\n        s_cm += v_cm * dt\n        max_s_cm_abs = max(max_s_cm_abs, abs(s_cm))\n\n        # 6f. Particle Push (Leapfrog) - Position update\n        pos = (pos + vel_next_half * dt) % L # This gives x^{n+1}\n        \n        # Update velocity for the next iteration\n        vel_half = vel_next_half\n        \n    return max_s_cm_abs / L\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, Ng, dt, T_steps, v0, L, seed)\n        (800, 128, 0.01, 400, 0.2, 1, 12345),\n        (800, 128, 0.005, 400, 0.2, 1, 12346),\n        (200, 64, 0.01, 400, 0.2, 1, 12347),\n        (800, 64, 0.015, 400, 0.2, 1, 12348),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_pic_simulation(*params)\n        results.append(result)\n\n    # Format the output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}