{
    "hands_on_practices": [
        {
            "introduction": "分子模拟的核心是势能函数，即“力场”。计算化学家的一项关键技能，是理解力场参数的改变如何直接影响模拟的物理性质。本练习提供了一个直接的实践机会，通过计算一个简化的水模型中 Lennard-Jones 尺寸参数 $\\sigma$ 的微小扰动，来探索它如何改变水的氧-氧径向分布函数 $g_{OO}(r)$，从而建立微观参数与宏观结构之间的联系。",
            "id": "2467173",
            "problem": "考虑一个简化的液态水模型中的氧-氧相互作用，其中只有氧位点通过 Lennard–Jones 对势相互作用。设位点-位点对势为\n$$\nu(r) \\;=\\; 4\\,\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],\n$$\n其中 $r$ 是以 $\\mathrm{\\AA}$ 为单位的氧-氧间距，$\\varepsilon$ 是以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位的势阱深度，$\\sigma$ 是以 $\\mathrm{\\AA}$ 为单位的尺寸参数。设热力学温度为 $T$，单位为 $\\mathrm{K}$。使用摩尔气体常数 $R = 8.314462618\\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$。假设在密度趋于零的极限下（双粒子正则系综），氧-氧径向分布函数满足\n$$\ng_{OO}(r) \\;=\\; \\exp\\!\\left(-\\frac{u(r)}{R\\,T}\\right).\n$$\n现在考虑对水模型的一个微扰，其中 Lennard-Jones 尺寸参数增加 $10\\%$，即微扰后的尺寸参数为 $\\sigma' = 1.1\\,\\sigma$，而 $\\varepsilon$ 和 $T$ 保持不变。\n\n任务：对于下方的每个测试用例，使用微扰后的尺寸参数 $\\sigma'$ 计算在指定间距下的微扰氧-氧径向分布函数 $g_{OO}(r)$。距离 $r$ 必须以 $\\mathrm{\\AA}$ 处理，能量以 $\\mathrm{kJ\\,mol^{-1}}$ 处理，温度以 $\\mathrm{K}$ 处理。$g_{OO}(r)$ 的值为无量纲。将每个报告的 $g_{OO}(r)$ 值四舍五入到 $6$ 位小数。\n\n测试套件（每个测试用例是一个元组 $(\\varepsilon,\\sigma,T,\\{r_i\\})$）：\n- 用例 1：$\\varepsilon = 0.6502\\,\\mathrm{kJ\\,mol^{-1}}$，$\\sigma = 3.166\\,\\mathrm{\\AA}$， $T = 298.15\\,\\mathrm{K}$，$r \\in \\{2.5,\\,3.166,\\,3.556,\\,5.0,\\,8.0,\\,20.0\\}\\,\\mathrm{\\AA}$。\n- 用例 2：$\\varepsilon = 0.6502\\,\\mathrm{kJ\\,mol^{-1}}$，$\\sigma = 3.166\\,\\mathrm{\\AA}$， $T = 1000.0\\,\\mathrm{K}$，$r \\in \\{2.8,\\,3.166,\\,3.556,\\,4.5,\\,8.0,\\,20.0\\}\\,\\mathrm{\\AA}$。\n- 用例 3：$\\varepsilon = 0.6364\\,\\mathrm{kJ\\,mol^{-1}}$，$\\sigma = 3.15061\\,\\mathrm{\\AA}$， $T = 298.15\\,\\mathrm{K}$，$r \\in \\{2.5,\\,3.0,\\,3.533,\\,5.0,\\,8.0,\\,20.0\\}\\,\\mathrm{\\AA}$。\n\n最终输出格式：您的程序应生成单行输出，包含一个含有三个元素（每个测试用例一个）的列表。每个元素本身必须是一个包含四舍五入后的 $g_{OO}(r_i)$ 值的列表，其顺序与所提供的相应 $r_i$ 一致。输出必须是以下形式的单行：\n$$\n\\texttt{[[g\\_1(r\\_1),g\\_1(r\\_2),\\dots],[g\\_2(r\\_1),\\dots],[g\\_3(r\\_1),\\dots]]}\n$$\n其中每个 $g$ 值四舍五入到 $6$ 位小数，且无额外文本。",
            "solution": "该问题已根据科学和数学一致性的标准准则进行了审查，以验证其有效性。发现该问题具有科学依据、问题设定良好、客观且内容自洽。它描述了统计力学中的一个标准计算，应用于与计算化学相关的简化对相互作用模型。所指定的物理模型，即 Lennard-Jones 势，是分子模拟的基石。在低密度极限下，径向分布函数的表达式从根本上是正确的，其源于玻尔兹曼分布。所有参数、常数和变量都用一致的单位清晰定义。$\\varepsilon$ 和 $\\sigma$ 的数值与已建立的水力场模型相对应（具体来说，用例 1 和 2 对应 SPC/E 模型，用例 3 对应 TIP3P 模型），这为问题陈述增添了物理真实性。该任务是所提供公式的直接应用。因此，该问题被认为是有效的，下面将给出正式的解法。\n\n目标是计算在指定分离距离 $r$ 处的微扰氧-氧径向分布函数，记为 $g'_{OO}(r)$。该系统由氧原子之间的成对相互作用势定义，由 Lennard-Jones (LJ) 函数给出：\n$$\nu(r) \\;=\\; 4\\,\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\n在此，$r$ 是原子间距，$\\varepsilon$ 是势阱深度，$\\sigma$ 是粒子间势为零时的有限距离。\n\n该问题引入了对此模型的一个微扰，其中尺寸参数 $\\sigma$ 增加了 $10\\%$。因此，新的、微扰后的尺寸参数 $\\sigma'$ 定义为：\n$$\n\\sigma' = 1.1\\,\\sigma\n$$\n参数 $\\varepsilon$ 和温度 $T$ 保持不变。将 $\\sigma'$ 代入 Lennard-Jones 方程，得到微扰后的对势 $u'(r)$：\n$$\nu'(r) \\;=\\; 4\\,\\varepsilon\\left[\\left(\\frac{\\sigma'}{r}\\right)^{12} - \\left(\\frac{\\sigma'}{r}\\right)^{6}\\right]\n$$\n在密度趋于零的极限下，氧-氧径向分布函数 $g_{OO}(r)$ 由对势能的玻尔兹曼因子给出。因此，微扰后的径向分布函数 $g'_{OO}(r)$ 计算如下：\n$$\ng'_{OO}(r) \\;=\\; \\exp\\!\\left(-\\frac{u'(r)}{R\\,T}\\right)\n$$\n其中 $R$ 是摩尔气体常数，其值为 $R = 8.314462618\\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$，$T$ 是以开尔文为单位的热力学温度。单位是一致的：$\\varepsilon$ 的单位是 $\\mathrm{kJ\\,mol^{-1}}$，$T$ 的单位是 $\\mathrm{K}$，$R$ 的单位是 $\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$，这使得指数函数的参数 $-\\frac{u'(r)}{R\\,T}$ 成为无量纲。比值 $\\sigma'/r$ 也是无量纲的，因为两个距离的单位都是埃（$\\mathrm{\\AA}$）。\n\n每个测试用例的计算步骤如下：\n$1$. 对于给定参数为 $(\\varepsilon, \\sigma, T, \\{r_i\\})$ 的测试用例，首先计算微扰后的尺寸参数 $\\sigma' = 1.1\\,\\sigma$。\n$2$. 对于集合 $\\{r_i\\}$ 中的每个指定分离距离 $r_i$：\n    a. 计算比值 $\\frac{\\sigma'}{r_i}$。\n    b. 计算微扰后的势能 $u'(r_i) = 4\\,\\varepsilon\\left[\\left(\\frac{\\sigma'}{r_i}\\right)^{12} - \\left(\\frac{\\sigma'}{r_i}\\right)^{6}\\right]$。\n    c. 计算指数的值，$\\beta u' = -\\frac{u'(r_i)}{R\\,T}$。\n    d. 计算微扰后的径向分布函数 $g'_{OO}(r_i) = \\exp(-\\frac{u'(r_i)}{R\\,T})$。\n$3$. 将计算出的 $g'_{OO}(r_i)$ 值四舍五入到 $6$ 位小数。\n$4$. 将每个测试用例的所有 $r_i$ 的结果收集到有序列表中。\n\n该算法被系统地应用于所有提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the perturbed oxygen-oxygen radial distribution function g_OO(r)\n    for a set of test cases based on the Lennard-Jones potential.\n    \"\"\"\n    # Molar gas constant in kJ mol^-1 K^-1\n    R = 8.314462618e-3\n\n    # Test suite: (epsilon [kJ/mol], sigma [A], T [K], list of r values [A])\n    test_cases = [\n        (0.6502, 3.166, 298.15, [2.5, 3.166, 3.556, 5.0, 8.0, 20.0]),\n        (0.6502, 3.166, 1000.0, [2.8, 3.166, 3.556, 4.5, 8.0, 20.0]),\n        (0.6364, 3.15061, 298.15, [2.5, 3.0, 3.533, 5.0, 8.0, 20.0]),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        eps, sigma, T, r_values = case\n        \n        # The size parameter is increased by 10%\n        sigma_prime = 1.1 * sigma\n        \n        rt_product = R * T\n        \n        case_results = []\n        for r in r_values:\n            # Calculate the perturbed Lennard-Jones potential u'(r)\n            ratio = sigma_prime / r\n            ratio_6 = ratio**6\n            ratio_12 = ratio_6**2\n            u_prime = 4.0 * eps * (ratio_12 - ratio_6)\n            \n            # Calculate the perturbed radial distribution function g'_OO(r)\n            g_oo_prime = np.exp(-u_prime / rt_product)\n            \n            # Round the result to 6 decimal places\n            case_results.append(round(g_oo_prime, 6))\n            \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format: [[...],[...],[...]]\n    # str(list) adds spaces, which are removed to match the specified format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "面对众多的水模型，计算化学家的一项核心任务是为特定的研究问题选择最合适的模型。这通常需要将模型的预测结果与实验数据或高质量的参考数据进行定量比较。本练习将引导你完成这一过程中的一个关键环节：你将使用人工生成但物理上合理的径向分布函数，通过客观的统计指标来评估两种模型（一个简化的三点模型和一个五点模型）中，哪一个能更准确地再现水分子第二溶剂化壳层的结构。",
            "id": "2467149",
            "problem": "构建一个程序，通过使用氧-氧径向分布函数 $g(r)$，评估五位点刚性水模型是否比三位点刚性水模型更准确地再现了液态水的第二溶剂化壳层的结构。评估必须基于以下第一性原理数学定义和一个固定的、人工合成但物理上合理的测试套件。\n\n定义与设置：\n- 径向分布函数 $g(r)$ 定义为距离 $r$ 处的局部数密度与体相数密度之比；它是无量纲的。距离 $r$ 必须以埃（Å）为单位表示。\n- 第二溶剂化壳层区域定义为闭区间 $[r_{\\min}, r_{\\max}] = [3.3\\,\\text{Å}, 5.5\\,\\text{Å}]$。\n- 模型在第二壳层区域的准确性通过其与参考径向分布函数的均方偏差来量化：\n  $$ M = \\frac{1}{|I|} \\sum_{i \\in I} \\left(g_{\\text{model}}(r_i) - g_{\\text{ref}}(r_i)\\right)^2,$$\n  其中 $\\{r_i\\}$ 是在区间 $[2.0\\,\\text{Å}, 6.0\\,\\text{Å}]$ 上的一个均匀网格，间距为 $\\Delta r = 0.1\\,\\text{Å}$，且 $I = \\{ i \\mid r_i \\in [3.3\\,\\text{Å}, 5.5\\,\\text{Å}] \\}$。\n- 对任意 $g(r)$，第二壳层最大值（第二个峰）的位置定义为\n  $$ r_{\\text{peak}} = \\operatorname*{arg\\,max}_{r_i \\in [3.3\\,\\text{Å}, 5.5\\,\\text{Å}]} g(r_i), $$\n  并约定：如果有多个 $r_i$ 达到相同的最大值，则选择其中最小的 $r_i$。\n- 对于一个给定的测试用例，五位点模型被认为比三位点模型“更准确”的充要条件是 $M_{5}  M_{3}$。在 $|M_{5} - M_{3}| \\le \\varepsilon$（其中 $\\varepsilon = 10^{-12}$）的情况下，准确性由峰位绝对误差决定，此时五位点模型被认为“更准确”的充要条件是 $|r_{\\text{peak},5} - r_{\\text{peak},\\text{ref}}|  |r_{\\text{peak},3} - r_{\\text{peak},\\text{ref}}| - \\varepsilon$。如果两个条件都不满足，则五位点模型不被认为更准确。\n\n人工合成的参考及模型 $g(r)$ 的生成：\n- 使用均匀网格 $r_i = 2.0\\,\\text{Å} + i \\times 0.1\\,\\text{Å}$，其中 $i = 0,1,\\dots,40$。\n- 对于所有情况，所有函数中都同样包含第一壳层的峰，该峰由一个高斯项表示，其参数为 $A_1 = 2.5$，$\\mu_1 = 2.8\\,\\text{Å}$ 和 $\\sigma_1 = 0.08\\,\\text{Å}$：\n  $$ G_1(r) = A_1 \\exp\\!\\left(-\\frac{(r - \\mu_1)^2}{2 \\sigma_1^2}\\right). $$\n- 第二壳层的结构由第二个高斯函数表示：\n  $$ G_2(r; A_2,\\mu_2,\\sigma_2) = A_2 \\exp\\!\\left(-\\frac{(r - \\mu_2)^2}{2 \\sigma_2^2}\\right). $$\n- 对任意指定的三元组 $(A_2,\\mu_2,\\sigma_2)$，定义\n  $$ g(r) = 1 + G_1(r) + G_2(r; A_2,\\mu_2,\\sigma_2). $$\n\n测试套件：\n- 对于以下四个测试用例中的每一个，使用上述定义和特定于用例的第二壳层参数来构建 $g_{\\text{ref}}(r)$、$g_{3}(r)$（三位点模型）和 $g_{5}(r)$（五位点模型）。所有距离单位均为埃，所有振幅均为无量纲，所有标准差单位均为埃。\n\n用例 $1$ (典型的类环境结构):\n- 参考：$(A_2,\\mu_2,\\sigma_2) = (0.9, 4.5\\,\\text{Å}, 0.15\\,\\text{Å})$。\n- 三位点：$(A_2,\\mu_2,\\sigma_2) = (0.6, 4.3\\,\\text{Å}, 0.18\\,\\text{Å})$。\n- 五位点：$(A_2,\\mu_2,\\sigma_2) = (0.85, 4.48\\,\\text{Å}, 0.16\\,\\text{Å})$。\n\n用例 $2$ (三位点模型在第二壳层与参考匹配的边界情况):\n- 参考：$(0.9, 4.5\\,\\text{Å}, 0.15\\,\\text{Å})$。\n- 三位点：$(0.9, 4.5\\,\\text{Å}, 0.15\\,\\text{Å})$。\n- 五位点：$(0.88, 4.58\\,\\text{Å}, 0.16\\,\\text{Å})$。\n\n用例 $3$ (第二壳层偏移，中等偏差):\n- 参考：$(0.95, 4.7\\,\\text{Å}, 0.20\\,\\text{Å})$。\n- 三位点：$(0.80, 4.6\\,\\text{Å}, 0.22\\,\\text{Å})$。\n- 五位点：$(0.90, 4.66\\,\\text{Å}, 0.21\\,\\text{Å})$。\n\n用例 $4$ (三位点模型对第二壳层分辨不足的边缘情况):\n- 参考：$(0.9, 4.5\\,\\text{Å}, 0.15\\,\\text{Å})$。\n- 三位点：$(0.10, 4.0\\,\\text{Å}, 0.60\\,\\text{Å})$。\n- 五位点：$(0.85, 4.52\\,\\text{Å}, 0.16\\,\\text{Å})$。\n\n所需输出：\n- 对每个用例，如果根据上述决策规则，五位点模型更准确，则输出布尔值 $ \\text{true} $，否则输出 $ \\text{false} $。\n- 你的程序应产生单行输出，其中包含四个用例的结果，形式为一个由逗号分隔的小写布尔值列表，并用方括号括起来（例如：\"[true,false,true,true]\"）。",
            "solution": "所述问题具有科学依据、定义明确且客观。所有参数、函数和决策标准都经过了精确的数学定义。不存在任何会妨碍得出唯一且可验证解的矛盾或模糊之处。因此，我将提供完整的解决方案。\n\n任务是基于一组人工合成的氧-氧径向分布函数 $g(r)$，确定一个五位点水模型是否比一个三位点模型能更准确地描述液态水的第二溶剂化壳层。评估是定量的，并且遵循严格的、基于规则的程序。\n\n解决方案通过以下步骤实现：\n\n1.  **定义域离散化**：连续的径向分布函数 $g(r)$ 在一个离散的、均匀的点网格 $\\{r_i\\}$ 上进行求值。该网格定义在距离 $r$ 从 $2.0\\,\\text{Å}$ 到 $6.0\\,\\text{Å}$ 的范围内，间距为 $\\Delta r = 0.1\\,\\text{Å}$。这给出了网格点：\n    $$ r_i = 2.0 + i \\cdot (0.1) \\quad \\text{for} \\quad i = 0, 1, \\dots, 40. $$\n    这构成了 $41$ 个离散距离值的集合。\n\n2.  **生成径向分布函数**：对于每个测试用例，必须生成三个函数：一个参考函数 $g_{\\text{ref}}(r)$、一个三位点模型函数 $g_{3}(r)$ 和一个五位点模型函数 $g_{5}(r)$。每个函数都由一个恒定的基线密度（$1$）、一个表示第一溶剂化壳层的固定高斯函数，以及一个表示第二壳层的、特定于用例的高斯函数之和构成。\n    任意 $g(r_i)$ 的一般形式为：\n    $$ g(r_i) = 1 + G_1(r_i) + G_2(r_i; A_2, \\mu_2, \\sigma_2) $$\n    第一个高斯函数 $G_1(r)$ 在所有函数和模型中都是恒定的：\n    $$ G_1(r_i) = A_1 \\exp\\left(-\\frac{(r_i - \\mu_1)^2}{2 \\sigma_1^2}\\right) $$\n    其参数固定为 $A_1 = 2.5$，$\\mu_1 = 2.8\\,\\text{Å}$ 和 $\\sigma_1 = 0.08\\,\\text{Å}$。\n    第二个高斯函数 $G_2(r)$ 根据每个测试用例中为参考、三位点和五位点模型指定的参数而变化：\n    $$ G_2(r_i; A_2, \\mu_2, \\sigma_2) = A_2 \\exp\\left(-\\frac{(r_i - \\mu_2)^2}{2 \\sigma_2^2}\\right) $$\n\n3.  **定义分析区域**：比较仅限于第二溶剂化壳层，定义为闭区间 $[3.3\\,\\text{Å}, 5.5\\,\\text{Å}]$。我们确定落在此区域内的网格索引子集 $I$：\n    $$ I = \\{ i \\mid r_i \\in [3.3, 5.5] \\} $$\n    根据我们的网格定义，$r_i \\ge 3.3$ 意味着 $2.0 + 0.1 \\cdot i \\ge 3.3$，即 $i \\ge 13$。类似地，$r_i \\le 5.5$ 意味着 $2.0 + 0.1 \\cdot i \\le 5.5$，即 $i \\le 35$。因此，索引集为 $I = \\{13, 14, \\dots, 35\\}$。此区域中的点数为 $|I| = 35 - 13 + 1 = 23$。\n\n4.  **计算准确性度量**：每个模型（$g_{3}$ 和 $g_{5}$）的准确性通过其相对于参考函数 $g_{\\text{ref}}$ 在分析区域 $I$ 上的均方偏差 $M$ 来量化。\n    $$ M_{\\text{model}} = \\frac{1}{|I|} \\sum_{i \\in I} \\left(g_{\\text{model}}(r_i) - g_{\\text{ref}}(r_i)\\right)^2 = \\frac{1}{23} \\sum_{i=13}^{35} \\left(g_{\\text{model}}(r_i) - g_{\\text{ref}}(r_i)\\right)^2 $$\n    这个度量将对三位点模型（$M_{3}$）和五位点模型（$M_{5}$）都进行计算。\n\n5.  **确定第二峰位**：对于任意给定的 $g(r)$ 函数，第二峰的位置 $r_{\\text{peak}}$ 是指在分析区间 $[3.3\\,\\text{Å}, 5.5\\,\\text{Å}]$ 内使 $g(r_i)$ 达到最大值的距离 $r_i$。\n    $$ r_{\\text{peak}} = \\operatorname*{arg\\,max}_{r_i, i \\in I} g(r_i) $$\n    问题规定，如果最大值出现在多个网格点上，则选择对应于最小距离 $r_i$ 的那个点。这是数值计算中的 `argmax` 函数对有序数组的标准行为。\n\n6.  **应用决策规则**：一个双层决策规则用于确定五位点模型是否比三位点模型“更准确”。我们定义一个数值公差 $\\varepsilon = 10^{-12}$。\n\n    - **第一层（平局打破条件）**：首先，我们检查均方偏差 $M_5$ 和 $M_3$ 是否在数值上相近。如果 $|M_{5} - M_{3}| \\le \\varepsilon$，准确性由模型的第二峰位与参考峰位的接近程度决定。如果五位点模型的峰位误差比三位点模型的误差小，且差值超过 $\\varepsilon$，则五位点模型被认为更准确：\n      $$ |r_{\\text{peak},5} - r_{\\text{peak},\\text{ref}}|  |r_{\\text{peak},3} - r_{\\text{peak},\\text{ref}}| - \\varepsilon $$\n      如果满足此条件，则结果为 `true`；否则为 `false`。\n\n    - **第二层（主要条件）**：如果 $M$ 值不相近（即 $|M_{5} - M_{3}| > \\varepsilon$），则决策完全基于哪个模型的均方偏差更小。当且仅当 $M_{5}  M_{3}$ 时，五位点模型被认为更准确。\n\n然后将这个完整的算法应用于所提供的四个测试用例中的每一个。已经构建了一个程序来精确执行这些计算，并报告每个用例的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the water model comparison problem based on the provided specifications.\n    \"\"\"\n\n    # --- Definitions and Setup ---\n\n    # Grid parameters\n    R_GRID_MIN = 2.0\n    R_GRID_MAX = 6.0\n    DELTA_R = 0.1\n    \n    # Second solvation shell region\n    R_SHELL_MIN = 3.3\n    R_SHELL_MAX = 5.5\n\n    # Decision rule tolerance\n    EPSILON = 1e-12\n\n    # First-shell Gaussian parameters (fixed for all models)\n    A1 = 2.5\n    MU1 = 2.8\n    SIGMA1 = 0.08\n    \n    # Define the discrete radial distance grid\n    # np.arange is used to be explicit about the number of points\n    num_points = int(round((R_GRID_MAX - R_GRID_MIN) / DELTA_R)) + 1\n    r_grid = np.linspace(R_GRID_MIN, R_GRID_MAX, num_points)\n\n    # --- Test Suite Data ---\n    test_cases = [\n        # Case 1: Typical ambient-like structure\n        {\n            \"ref\":  (0.9, 4.5, 0.15),\n            \"site3\": (0.6, 4.3, 0.18),\n            \"site5\": (0.85, 4.48, 0.16),\n        },\n        # Case 2: Boundary where 3-site matches reference\n        {\n            \"ref\":  (0.9, 4.5, 0.15),\n            \"site3\": (0.9, 4.5, 0.15),\n            \"site5\": (0.88, 4.58, 0.16),\n        },\n        # Case 3: Shifted second shell, moderate deviations\n        {\n            \"ref\":  (0.95, 4.7, 0.20),\n            \"site3\": (0.80, 4.6, 0.22),\n            \"site5\": (0.90, 4.66, 0.21),\n        },\n        # Case 4: Edge case with under-resolved 3-site model\n        {\n            \"ref\":  (0.9, 4.5, 0.15),\n            \"site3\": (0.10, 4.0, 0.60),\n            \"site5\": (0.85, 4.52, 0.16),\n        },\n    ]\n\n    # --- Helper Functions ---\n\n    def generate_g_r(r_vals, A2, mu2, sigma2):\n        \"\"\"\n        Generates the radial distribution function g(r) for a given set of parameters.\n        \"\"\"\n        g1 = A1 * np.exp(-((r_vals - MU1)**2) / (2 * SIGMA1**2))\n        g2 = A2 * np.exp(-((r_vals - mu2)**2) / (2 * sigma2**2))\n        return 1.0 + g1 + g2\n\n    def get_shell_indices_mask(r_vals):\n        \"\"\"\n        Returns a boolean mask for indices within the second solvation shell.\n        \"\"\"\n        return (r_vals >= R_SHELL_MIN)  (r_vals = R_SHELL_MAX)\n\n    def calculate_M(g_model, g_ref, shell_mask):\n        \"\"\"\n        Calculates the mean squared deviation M over the second shell.\n        \"\"\"\n        deviation = g_model[shell_mask] - g_ref[shell_mask]\n        squared_deviation = deviation**2\n        return np.mean(squared_deviation)\n\n    def find_r_peak(g_vals, r_vals, shell_mask):\n        \"\"\"\n        Finds the position of the second-shell maximum, r_peak.\n        np.argmax returns the first index of the maximum, satisfying the tie-breaker rule.\n        \"\"\"\n        g_in_shell = g_vals[shell_mask]\n        r_in_shell = r_vals[shell_mask]\n        \n        peak_idx_in_shell = np.argmax(g_in_shell)\n        return r_in_shell[peak_idx_in_shell]\n\n    # --- Main Logic ---\n    \n    results = []\n    shell_mask = get_shell_indices_mask(r_grid)\n\n    for case in test_cases:\n        # Generate the three g(r) functions for the current case\n        g_ref = generate_g_r(r_grid, *case[\"ref\"])\n        g_3 = generate_g_r(r_grid, *case[\"site3\"])\n        g_5 = generate_g_r(r_grid, *case[\"site5\"])\n        \n        # Calculate the accuracy metric M for both models\n        M_3 = calculate_M(g_3, g_ref, shell_mask)\n        M_5 = calculate_M(g_5, g_ref, shell_mask)\n        \n        is_more_accurate = False\n        \n        # Apply the two-tiered decision rule\n        if np.abs(M_5 - M_3) = EPSILON:\n            # Tier 1: Tie-breaking based on peak position\n            r_peak_ref = find_r_peak(g_ref, r_grid, shell_mask)\n            r_peak_3 = find_r_peak(g_3, r_grid, shell_mask)\n            r_peak_5 = find_r_peak(g_5, r_grid, shell_mask)\n            \n            err_3 = np.abs(r_peak_3 - r_peak_ref)\n            err_5 = np.abs(r_peak_5 - r_peak_ref)\n            \n            if err_5  err_3 - EPSILON:\n                is_more_accurate = True\n            else:\n                is_more_accurate = False\n        else:\n            # Tier 2: Primary decision based on M value\n            if M_5  M_3:\n                is_more_accurate = True\n            else:\n                is_more_accurate = False\n                \n        results.append(str(is_more_accurate).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管径向分布函数等静态性质能提供宝贵的结构信息，但分子模拟的真正魅力在于揭示体系的动态行为。这项高级练习将向你介绍一种强大的数据科学技术——主成分分析 (PCA)，用于分析和区分不同水模型产生的集体运动。通过构建和分析理想化的运动轨迹，你将学习如何运用 PCA 将复杂的高维运动提炼为几个关键的组分，并定量地衡量两种动力学模型的可区分性。",
            "id": "2467197",
            "problem": "您将实现一个程序，为两种刚性水相互作用位点模型——3点可转移分子间势（TIP3P）和5点可转移分子间势（TIP5P）——构建确定性的、理想化的分子动力学轨迹，然后使用从第一性原理定义的主成分分析（PCA）来量化其主要集体运动的可分离性。目标是为每个指定的测试用例生成一个单一的标量分离分数，该分数衡量了这两个模型沿着从组合轨迹系综中导出的主导主成分的可区分程度。\n\n考虑一个由 $N$ 个水分子组成的系统，它们被限制在一个半径为 $R$ 的环上，在 $x$–$y$ 平面内运动。设分子 $i \\in \\{0,1,\\dots,N-1\\}$ 的极角为 $\\theta_i = 2\\pi i/N$，静态位置为 $\\mathbf{r}_{i,0} = R(\\cos\\theta_i,\\sin\\theta_i,0)$。定义径向单位向量 $\\mathbf{e}_{r,i}=(\\cos\\theta_i,\\sin\\theta_i,0)$ 和切向单位向量 $\\mathbf{e}_{\\theta,i}=(-\\sin\\theta_i,\\cos\\theta_i,0)$。对于帧索引 $k \\in \\{0,1,\\dots,T-1\\}$ 和无量纲时间 $t_k = k$，为每个分子定义两种时间周期的集体位移：一个振幅为 $a_r$、频率为 $f_r$（单位：周/帧）的共同径向“呼吸”模式，以及一个振幅为 $a_{\\mathrm{LP}}^{(m)}$、频率为 $f_{\\mathrm{LP}}$（单位：周/帧）的切向“孤对电子驱动”模式，其中 $m \\in \\{\\mathrm{TIP3P},\\mathrm{TIP5P}\\}$ 表示模型。模型 $m$ 在时间 $t_k$ 时分子 $i$ 的瞬时位置为\n$$\n\\mathbf{r}_{i}^{(m)}(t_k) \\;=\\; \\mathbf{r}_{i,0} \\;+\\; a_r \\sin\\!\\big(2\\pi f_r t_k\\big)\\,\\mathbf{e}_{r,i} \\;+\\; a_{\\mathrm{LP}}^{(m)} \\sin\\!\\big(2\\pi f_{\\mathrm{LP}} t_k\\big)\\,\\mathbf{e}_{\\theta,i}.\n$$\n使用 $a_{\\mathrm{LP}}^{(\\mathrm{TIP3P})}=0$ 和 $a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}0$ 来分别表示强的切向孤对电子诱导的摆动的不存在与存在。所有空间坐标以纳米为单位，时间以帧为单位（无量纲），所有三角函数参数均以弧度为单位。\n\n通过对每个 $k$，将级联的笛卡尔坐标 $\\big(\\mathbf{r}_{0}^{(m)}(t_k),\\dots,\\mathbf{r}_{N-1}^{(m)}(t_k)\\big)$ 堆叠成一个长度为 $3N$ 的行向量，来构建两个轨迹矩阵 $X^{(3\\mathrm{P})} \\in \\mathbb{R}^{T \\times 3N}$ 和 $X^{(5\\mathrm{P})} \\in \\mathbb{R}^{T \\times 3N}$。通过垂直级联 $X^{(3\\mathrm{P})}$ 和 $X^{(5\\mathrm{P})}$ 形成组合数据矩阵 $X \\in \\mathbb{R}^{2T \\times 3N}$，并通过减去列均值将其中心化以获得 $\\tilde{X}$。定义样本协方差矩阵\n$$\nC \\;=\\; \\frac{1}{2T-1}\\,\\tilde{X}^\\top \\tilde{X}.\n$$\n设 $\\mathbf{v}_1$ 是 $C$ 的与最大特征值相关联的单位范数特征向量（第一主成分）。对于每一帧，定义标量投影 $s=\\tilde{\\mathbf{x}}\\cdot\\mathbf{v}_1$，其中 $\\tilde{\\mathbf{x}}$ 是该帧的中心化坐标向量。设 $s_{3\\mathrm{P}}$ 是前 $T$ 个投影（来自 TIP3P 帧）的列表，$s_{5\\mathrm{P}}$ 是后 $T$ 个投影（来自 TIP5P 帧）的列表。计算分离分数\n$$\nS \\;=\\; \\frac{\\left|\\mu_{5\\mathrm{P}} - \\mu_{3\\mathrm{P}}\\right|}{s_p},\n$$\n其中 $\\mu_{3\\mathrm{P}}$ 和 $\\mu_{5\\mathrm{P}}$ 分别是 $s_{3\\mathrm{P}}$ 和 $s_{5\\mathrm{P}}$ 的算术平均值，$s_p$ 是合并标准差，\n$$\ns_p \\;=\\; \\sqrt{\\frac{(T-1)\\sigma_{3\\mathrm{P}}^2 + (T-1)\\sigma_{5\\mathrm{P}}^2}{2T-2}},\n$$\n其中 $\\sigma_{3\\mathrm{P}}^2$ 和 $\\sigma_{5\\mathrm{P}}^2$ 分别是 $s_{3\\mathrm{P}}$ 和 $s_{5\\mathrm{P}}$ 的无偏样本方差。分数 $S$ 是无量纲的。\n\n您的程序必须为以下每个测试用例计算 $S$，所有情况下均使用 $R=1$ 纳米：\n\n- 案例 A（一般情况，中等分离度）：$N=6$，$T=100$，$a_r=0.02$ 纳米，$a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0.04$ 纳米，$f_r=\\frac{1}{10}$ 周/帧，$f_{\\mathrm{LP}}=\\frac{1}{8}$ 周/帧。\n- 案例 B（无差异对照组）：$N=6$，$T=100$，$a_r=0.02$ 纳米，$a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0$ 纳米，$f_r=\\frac{1}{10}$ 周/帧，$f_{\\mathrm{LP}}=\\frac{1}{8}$ 周/帧。\n- 案例 C（单分子边缘情况）：$N=1$，$T=60$，$a_r=0.02$ 纳米，$a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0.03$ 纳米，$f_r=\\frac{1}{12}$ 周/帧，$f_{\\mathrm{LP}}=\\frac{1}{6}$ 周/帧。\n- 案例 D（少量帧边界情况）：$N=5$，$T=4$，$a_r=0.01$ 纳米，$a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0.02$ 纳米，$f_r=\\frac{1}{3}$ 周/帧，$f_{\\mathrm{LP}}=\\frac{1}{4}$ 周/帧。\n- 案例 E（主导的非判别性方差）：$N=8$，$T=120$，$a_r=0.10$ 纳米，$a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0.01$ 纳米，$f_r=\\frac{1}{5}$ 周/帧，$f_{\\mathrm{LP}}=\\frac{1}{30}$ 周/帧。\n\n所有三角函数中的角度单位必须是弧度。所有坐标单位为纳米，输出的分离分数为无量纲。对于每个案例，生成一个浮点数结果，四舍五入到六位小数。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC,resultD,resultE]”），结果按 A、B、C、D、E 的顺序排列，不含任何额外文本。每个测试用例的结果必须是如上定义的相应 $S$ 值。",
            "solution": "所提出的问题是在应用统计方法分析理想化分子动力学轨迹方面一个有效且定义明确的练习。它不是对水的真实模拟，而是一个精心构建的数学模型，旨在测试主成分分析（PCA）在区分不同动力学行为方面的功效。使用像“TIP3P”和“TIP5P”这样的术语仅仅是为了方便标记两个不同的参数集，其中一个体现了纯粹的径向振荡运动，而另一个则包含了一个额外的切向分量。该问题在科学上基于经典力学和统计学习的原理，在数学上是自洽的，并提供了一个清晰、客观的计算流程。我们将着手推导解决方案。\n\n问题的核心是量化由确定性规则生成的两个系统构型系综的可分离性。每个系综代表了环上 $N$ 个粒子随时间的演化。\n\n首先，我们必须为这两个模型生成轨迹。模型 $m$ 在离散时间步 $t_k = k$ 时，分子 $i \\in \\{0, 1, \\dots, N-1\\}$ 的位置由下式给出：\n$$\n\\mathbf{r}_{i}^{(m)}(t_k) \\;=\\; \\mathbf{r}_{i,0} \\;+\\; a_r \\sin(2\\pi f_r t_k)\\,\\mathbf{e}_{r,i} \\;+\\; a_{\\mathrm{LP}}^{(m)} \\sin(2\\pi f_{\\mathrm{LP}} t_k)\\,\\mathbf{e}_{\\theta,i}\n$$\n此处，$\\mathbf{r}_{i,0} = R(\\cos(2\\pi i/N), \\sin(2\\pi i/N), 0)$ 是静态平衡位置。运动由两个独立的正弦分量组成：一个振幅为 $a_r$、频率为 $f_r$ 的径向“呼吸”模式，这对两个模型是共同的；以及一个振幅为 $a_{\\mathrm{LP}}^{(m)}$、频率为 $f_{\\mathrm{LP}}$ 的切向“摆动”模式。关键区别在于，这种切向运动在“TIP3P”模型中不存在（$a_{\\mathrm{LP}}^{(\\mathrm{TIP3P})} = 0$），而在“TIP5P”模型中存在（$a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})} > 0$）。对两个模型中的每一个，都为所有 $N$ 个分子在 $T$ 个时间帧内计算这些位置。\n\n接下来，将生成的坐标数据组织成矩阵。对于每个模型 $m$，我们构建一个矩阵 $X^{(m)} \\in \\mathbb{R}^{T \\times 3N}$，其中每一行 $k$ 是系统在时间 $t_k$ 的一个“快照”，通过级联所有 $N$ 个分子的笛卡尔坐标向量 $(\\mathbf{r}_{0}^{(m)}(t_k), \\dots, \\mathbf{r}_{N-1}^{(m)}(t_k))$ 形成。然后将这两个矩阵 $X^{(3\\mathrm{P})}$ 和 $X^{(5\\mathrm{P})}$ 垂直级联，形成一个单一的数据矩阵 $X \\in \\mathbb{R}^{2T \\times 3N}$。\n\n然后通过减去每列的均值（即在整个 $2T$ 帧系综上的时间平均坐标）来对这个组合数据矩阵 $X$ 进行中心化。这会得到矩阵 $\\tilde{X}$，其行表示与平均构型的偏差。中心化是必不可少的，因为 PCA 关注的是方差，而不是平均位置。\n\n随后的步骤是分析的核心：主成分分析。我们计算构型空间坐标的样本协方差矩阵 $C$：\n$$\nC = \\frac{1}{2T-1} \\tilde{X}^\\top \\tilde{X}\n$$\n这个 $3N \\times 3N$ 的矩阵描述了所有坐标分量对之间的协方差。我们求解 $C$ 的特征值问题。$C$ 的特征向量是主成分（PCs），它们构成了坐标空间的一个标准正交基，并且相应的特征值表示数据沿着这些分量的方差。第一主成分 $\\mathbf{v}_1$ 是与最大特征值相关联的特征向量。它代表了数据中方差最大的方向——即组合系综中最主要的集体运动。\n\n假设是，如果“TIP5P”模型独有的切向运动对总方差有显著贡献，那么 $\\mathbf{v}_1$ 将会捕捉到这种运动。为了检验这一点，我们将每一帧的中心化数据投影到这个主成分上。单个帧 $\\tilde{\\mathbf{x}}$ 的投影是标量值 $s = \\tilde{\\mathbf{x}} \\cdot \\mathbf{v}_1$。这个过程将每帧的高维 $3N$ 坐标向量简化为单个标量值，产生两组投影：$s_{3\\mathrm{P}}$（用于前 $T$ 帧）和 $s_{5\\mathrm{P}}$（用于后 $T$ 帧）。\n\n最后，我们计算分离分数 $S$，它是一种标准化的均值差异，类似于科恩 $d$ 值（Cohen's $d$）。其定义为\n$$\nS \\;=\\; \\frac{\\left|\\mu_{5\\mathrm{P}} - \\mu_{3\\mathrm{P}}\\right|}{s_p}\n$$\n其中 $\\mu_{3\\mathrm{P}}$ 和 $\\mu_{5\\mathrm{P}}$ 是两组投影的均值，而 $s_p$ 是合并标准差，根据投影集的无偏样本方差（$\\sigma_{3\\mathrm{P}}^2$, $\\sigma_{5\\mathrm{P}}^2$）计算得出。\n$$\ns_p \\;=\\; \\sqrt{\\frac{(T-1)\\sigma_{3\\mathrm{P}}^2 + (T-1)\\sigma_{5\\mathrm{P}}^2}{2T-2}} = \\sqrt{\\frac{\\sigma_{3\\mathrm{P}}^2 + \\sigma_{5\\mathrm{P}}^2}{2}}\n$$\n较大的 $S$ 值表示两个模型沿着它们最主要的集体运动方向有更大的分离度，意味着它们的动力学行为更容易区分。\n\n将要实现的算法将对每个提供的测试用例精确地遵循这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_separation_score(N, T, R, a_r, a_LP_5P, f_r, f_LP):\n    \"\"\"\n    Computes the PCA-based separation score for two idealized water models.\n\n    Args:\n        N (int): Number of molecules.\n        T (int): Number of time frames.\n        R (float): Radius of the ring in nanometers.\n        a_r (float): Amplitude of radial motion in nanometers.\n        a_LP_5P (float): Amplitude of tangential motion for TIP5P model in nanometers.\n        f_r (float): Frequency of radial motion in cycles/frame.\n        f_LP (float): Frequency of tangential motion in cycles/frame.\n\n    Returns:\n        float: The dimensionless separation score S.\n    \"\"\"\n    # Define dimensionless time and molecular angles\n    t_k = np.arange(T)\n    theta_i = 2 * np.pi * np.arange(N) / N\n\n    # Define unit vectors using broadcasting for efficiency\n    # e_r and e_theta will be of shape (N, 3)\n    e_r = np.stack((np.cos(theta_i), np.sin(theta_i), np.zeros(N)), axis=1)\n    e_theta = np.stack((-np.sin(theta_i), np.cos(theta_i), np.zeros(N)), axis=1)\n    \n    # Static positions, shape (N, 3)\n    r_i_0 = R * e_r\n\n    # Time-dependent displacements\n    # Shapes will be (T,)\n    radial_disp_t = a_r * np.sin(2 * np.pi * f_r * t_k)\n    tangential_disp_t_3P = 0.0  # By definition\n    tangential_disp_t_5P = a_LP_5P * np.sin(2 * np.pi * f_LP * t_k)\n    \n    # Generate trajectories using broadcasting\n    # r_i_0[np.newaxis, :, :] broadcasts from (N, 3) to (1, N, 3)\n    # radial_disp_t[:, np.newaxis, np.newaxis] broadcasts from (T,) to (T, 1, 1)\n    # e_r[np.newaxis, :, :] broadcasts from (N, 3) to (1, N, 3)\n    # The result of the product is a (T, N, 3) tensor for the radial displacement over time.\n    \n    # TIP3P trajectory tensor (T, N, 3)\n    traj_3P_tensor = (r_i_0[np.newaxis, :, :] + \n                      radial_disp_t[:, np.newaxis, np.newaxis] * e_r[np.newaxis, :, :])\n                      # Tangential part is zero for TIP3P\n\n    # TIP5P trajectory tensor (T, N, 3)\n    traj_5P_tensor = (r_i_0[np.newaxis, :, :] + \n                      radial_disp_t[:, np.newaxis, np.newaxis] * e_r[np.newaxis, :, :] +\n                      tangential_disp_t_5P[:, np.newaxis, np.newaxis] * e_theta[np.newaxis, :, :])\n\n    # Reshape tensors into trajectory matrices (T, 3*N)\n    X_3P = traj_3P_tensor.reshape((T, 3 * N))\n    X_5P = traj_5P_tensor.reshape((T, 3 * N))\n\n    # Form the combined data matrix X of shape (2*T, 3*N)\n    X = np.vstack((X_3P, X_5P))\n\n    # Center the data by subtracting the column-wise mean\n    X_mean = X.mean(axis=0)\n    X_tilde = X - X_mean\n\n    # If all variation is zero (e.g., T=0), the score is ill-defined. Return 0.\n    if 2 * T = 1:\n        return 0.0\n\n    # Compute the sample covariance matrix C of shape (3*N, 3*N)\n    # Divisor is (2*T - 1) for unbiased estimate\n    C = (X_tilde.T @ X_tilde) / (2 * T - 1)\n\n    # Eigendecomposition of the covariance matrix\n    # eigh is used for symmetric matrices and returns sorted eigenvalues\n    eigenvalues, eigenvectors = np.linalg.eigh(C)\n\n    # The first principal component is the eigenvector with the largest eigenvalue\n    v_1 = eigenvectors[:, -1]\n\n    # Project the centered data onto the first principal component\n    s = X_tilde @ v_1\n    \n    s_3P = s[:T]\n    s_5P = s[T:]\n\n    # Compute means of the projected data\n    mu_3P = s_3P.mean()\n    mu_5P = s_5P.mean()\n\n    # If T = 1, variance is undefined. Pooled std dev will be 0.\n    if T = 1:\n        return 0.0 if np.isclose(mu_3P, mu_5P) else np.inf\n\n    # Compute unbiased sample variances (ddof=1)\n    var_3P = s_3P.var(ddof=1)\n    var_5P = s_5P.var(ddof=1)\n\n    # Compute the pooled standard deviation\n    # This simplifies from the formula in the prompt as sample sizes are equal.\n    s_p_squared = (var_3P + var_5P) / 2\n    \n    # Handle edge case where there is no variance in projections\n    if np.isclose(s_p_squared, 0):\n        return 0.0\n\n    s_p = np.sqrt(s_p_squared)\n    \n    # Compute the separation score S\n    S = np.abs(mu_5P - mu_3P) / s_p\n    \n    return S\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the separation score for each.\n    \"\"\"\n    R = 1.0  # nanometers, constant for all cases\n\n    # Tuple format: (N, T, a_r, a_LP^(TIP5P), f_r, f_LP)\n    test_cases = [\n        # Case A: general, moderate separation\n        (6, 100, 0.02, 0.04, 1/10, 1/8),\n        # Case B: no difference control\n        (6, 100, 0.02, 0.0, 1/10, 1/8),\n        # Case C: single-molecule edge\n        (1, 60, 0.02, 0.03, 1/12, 1/6),\n        # Case D: few frames boundary\n        (5, 4, 0.01, 0.02, 1/3, 1/4),\n        # Case E: dominant non-discriminative variance\n        (8, 120, 0.10, 0.01, 1/5, 1/30),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T, a_r, a_LP_5P, f_r, f_LP = case\n        S = compute_separation_score(N, T, R, a_r, a_LP_5P, f_r, f_LP)\n        results.append(f\"{S:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}