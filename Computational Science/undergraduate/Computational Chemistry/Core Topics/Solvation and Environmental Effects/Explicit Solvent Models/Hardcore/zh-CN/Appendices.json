{
    "hands_on_practices": [
        {
            "introduction": "力场并非“第一性原理”的完美理论，而是经过精心参数化的模型，其目标是再现实验数据。对于液体而言，一个关键的实验可观测量是其密度。本练习模拟了力场开发或验证中的一个常见情景：模拟产生了错误的密度，挑战你像模型开发者一样思考，决定如何调整基本的 Lennard-Jones 参数来修正模拟结果，从而让你对这些参数的物理意义建立起深刻的直观理解。",
            "id": "2455667",
            "problem": "您使用可转移三点分子间势（TIP3P）模型，在 $T=298\\,\\mathrm{K}$ 和 $p=1\\,\\mathrm{bar}$ 的条件下对液态水进行恒定数量、压力、温度（NPT）模拟。刚性几何构型和部分电荷与标准TIP3P模型完全相同，且氢原子不带Lennard-Jones (LJ) 项。然而，由于疑似输入错误，在这些环境条件下，模拟得到的平衡质量密度为 $1.20\\,\\mathrm{g\\,cm^{-3}}$。您只被允许改变氧原子位点上的两个Lennard-Jones非键参数之一，即尺寸参数 $\\sigma_{\\mathrm{O}}$ 或势阱深度参数 $\\epsilon_{\\mathrm{O}}$，同时保持其他所有设置不变。为了在 $T=298\\,\\mathrm{K}$ 和 $p=1\\,\\mathrm{bar}$ 条件下，使液体密度接近其环境值（约 $1.00\\,\\mathrm{g\\,cm^{-3}}$），您会首先修改哪个参数，朝哪个方向修改，以及为什么？\n\nA. 首先增加 $\\sigma_{\\mathrm{O}}$；由Lennard-Jones势决定的优选分子间距位置与 $\\sigma_{\\mathrm{O}}$ 成比例，因此增加 $\\sigma_{\\mathrm{O}}$ 会增大排除体积，并在固定的 $T$ 和 $p$ 下降低平衡密度。\n\nB. 首先减小 $\\epsilon_{\\mathrm{O}}$；减小 $\\epsilon_{\\mathrm{O}}$ 会使优选间距移向更大的距离，从而使液体膨胀并在固定的 $T$ 和 $p$ 下降低密度。\n\nC. 首先增加 $\\epsilon_{\\mathrm{O}}$；更深的吸引势阱会降低给定密度下的内压，因此在固定的外压 $p$ 下，系统会膨胀，密度会降低。\n\nD. 首先减小 $\\sigma_{\\mathrm{O}}$；更小的核心通过减弱排斥作用来减少过度堆积，这会在固定的 $T$ 和 $p$ 下降低平衡密度。\n\nE. 首先改变任一参数都同样合适；$\\sigma_{\\mathrm{O}}$ 和 $\\epsilon_{\\mathrm{O}}$ 都控制优选间距的位置，因此在固定的 $T$ 和 $p$ 下以相同的方式影响密度。",
            "solution": "对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 模拟系综：恒定数量、压力、温度（NPT）。\n- 系统：液态水。\n- 热力学状态：温度 $T=298\\,\\mathrm{K}$，压力 $p=1\\,\\mathrm{bar}$。\n- 力场：可转移三点分子间势（TIP3P）模型。\n- 力场细节：标准的刚性几何构型和部分电荷；氢原子没有Lennard-Jones (LJ) 项。\n- 观察结果：模拟得到的平衡质量密度为 $\\rho_{sim} = 1.20\\,\\mathrm{g\\,cm^{-3}}$。\n- 目标：修改模拟参数，使密度更接近于约 $\\rho_{exp} \\approx 1.00\\,\\mathrm{g\\,cm^{-3}}$ 的实验环境值。\n- 约束：只能改变氧原子位点上的两个Lennard-Jones参数之一，$\\sigma_{\\mathrm{O}}$ 或 $\\epsilon_{\\mathrm{O}}$。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学基础**：该问题植根于经典分子动力学和统计力学的原理。它涉及微观相互作用势（Lennard-Jones）与宏观热力学性质（密度）之间的关系。TIP3P模型和NPT系综是计算化学中的标准工具。参数化模型产生不正确密度的情景是力场开发中一个常见且现实的问题。该问题是科学合理的。\n- **适定性**：问题定义清晰。初始条件（密度过高的液体）、目标（降低密度）和约束（仅修改 $\\sigma_{\\mathrm{O}}$ 或 $\\epsilon_{\\mathrm{O}}$）都已明确说明。可以应用独特的物理推理来确定正确的行动方案。该问题是适定的。\n- **客观性**：所用语言精确且定量，没有歧义或主观陈述。\n\n### 步骤3：结论与行动\n问题陈述是有效的。它是科学合理的、适定的和客观的。将推导解决方案。\n\n问题的核心是理解在恒定压力和温度（NPT）模拟中，Lennard-Jones (LJ) 参数如何影响液体的平衡密度。模拟密度 $\\rho_{sim} = 1.20\\,\\mathrm{g\\,cm^{-3}}$ 显著高于目标实验密度 $\\rho_{exp} \\approx 1.00\\,\\mathrm{g\\,cm^{-3}}$。这意味着模拟的水分子堆积得过于紧密。为纠正这一点，必须增加系统的体积。\n\nTIP3P模型中的分子间相互作用包括部分电荷之间的静电相互作用和仅存在于氧原子之间的Lennard-Jones相互作用。两个相距为 $r$ 的氧原子之间的Lennard-Jones势 $U_{LJ}$ 由以下公式给出：\n$$ U_{LJ}(r) = 4\\epsilon_{\\mathrm{O}} \\left[ \\left( \\frac{\\sigma_{\\mathrm{O}}}{r} \\right)^{12} - \\left( \\frac{\\sigma_{\\mathrm{O}}}{r} \\right)^{6} \\right] $$\n此处，$\\sigma_{\\mathrm{O}}$ 是粒子间势为零时的有限距离，通常被视为有效直径或尺寸参数。$\\epsilon_{\\mathrm{O}}$ 是势阱的深度，代表对吸引相互作用的强度。该势的最小值，对应于孤立对在能量上最有利的间距，出现在 $r_{min} = 2^{1/6}\\sigma_{\\mathrm{O}}$ 处。\n\n我们的目标是降低密度，这需要增加系统的平均平衡体积。在NPT模拟中，体积会波动以维持一个平衡，即内压等于外压 $p$。我们必须修改势能以利于更大的分子间距。让我们分析改变每个参数的效果。\n\n1.  **修改尺寸参数 $\\sigma_{\\mathrm{O}}$**：\n    - 参数 $\\sigma_{\\mathrm{O}}$ 直接控制氧原子的有效尺寸。势能的排斥部分，即 $(\\sigma_{\\mathrm{O}}/r)^{12}$ 项，对 $\\sigma_{\\mathrm{O}}$ 高度敏感。\n    - 如果我们 **增加** $\\sigma_{\\mathrm{O}}$，势能的排斥壁会被推向更远的距离。这会增加每个分子的有效排除体积。在任何给定的分子间距下，排斥力都会变强。为了维持恒定的外压 $p$，系统必须膨胀，导致平均体积增加，从而使密度 **降低**。\n    - 相反，减小 $\\sigma_{\\mathrm{O}}$ 会缩小有效分子尺寸，允许更紧密的堆积，从而导致密度增加。\n    - 因此，为了降低密度，我们必须 **增加** $\\sigma_{\\mathrm{O}}$。\n\n2.  **修改势阱深度参数 $\\epsilon_{\\mathrm{O}}$**：\n    - 参数 $\\epsilon_{\\mathrm{O}}$ 控制分子间吸引相互作用的强度。\n    - 如果我们 **增加** $\\epsilon_{\\mathrm{O}}$，分子间的吸引力会变强。这种增强的“粘性”会把分子拉得更近。为了平衡恒定的外压 $p$，系统会收缩到一个更小的平均体积，导致密度 **增加**。\n    - 如果我们 **减小** $\\epsilon_{\\mathrm{O}}$，吸引力会减弱。分子的内聚力减小，热运动（$k_B T$）在将它们推开方面变得更有效。系统必须膨胀到更大的平均体积以满足压力约束，从而导致密度 **降低**。\n    - 因此，为了降低密度，我们必须 **减小** $\\epsilon_{\\mathrm{O}}$。\n\n基于此分析，有两种可能的操作来降低密度：增加 $\\sigma_{\\mathrm{O}}$ 或减小 $\\epsilon_{\\mathrm{O}}$。我们现在评估所提供的选项。\n\n**A. 首先增加 $\\sigma_{\\mathrm{O}}$；由Lennard-Jones势决定的优选分子间距位置与 $\\sigma_{\\mathrm{O}}$ 成比例，因此增加 $\\sigma_{\\mathrm{O}}$ 会增大排除体积，并在固定的 $T$ 和 $p$ 下降低平衡密度。**\n建议的操作是增加 $\\sigma_{\\mathrm{O}}$。正如所推导的，这是降低密度的正确操作。所提供的理由也是正确的。优选间距 $r_{min}$ 确实与 $\\sigma_{\\mathrm{O}}$ 成比例。增加 $\\sigma_{\\mathrm{O}}$ 会因强大的短程排斥作用而增加有效排除体积，迫使系统在恒定压力下膨胀。此陈述在物理上和数学上都是合理的。**正确**。\n\n**B. 首先减小 $\\epsilon_{\\mathrm{O}}$；减小 $\\epsilon_{\\mathrm{O}}$ 会使优选间距移向更大的距离，从而使液体膨胀并在固定的 $T$ 和 $p$ 下降低密度。**\n建议的操作，减小 $\\epsilon_{\\mathrm{O}}$，是降低密度的一种有效方法。然而，其理由是有缺陷的。优选间距的位置 $r_{min} = 2^{1/6}\\sigma_{\\mathrm{O}}$ 由 $\\sigma_{\\mathrm{O}}$ 决定，与 $\\epsilon_{\\mathrm{O}}$ 无关。改变 $\\epsilon_{\\mathrm{O}}$ 只改变势阱的深度，而不改变其位置。由于其理由根本上是错误的，整个选项是无效的。**错误**。\n\n**C. 首先增加 $\\epsilon_{\\mathrm{O}}$；更深的吸引势阱会降低给定密度下的内压，因此在固定的外压 $p$ 下，系统会膨胀，密度会降低。**\n建议的操作是增加 $\\epsilon_{\\mathrm{O}}$。这与所需的变化相反；它会增加密度。其结论的推理也是有缺陷的。虽然在固定体积下，增加 $\\epsilon_{\\mathrm{O}}$（更深的势阱）确实会导致对压力维里的贡献更负，从而降低内压，但系统在NPT系综中的响应是压缩，直到内压再次与外压匹配。恒定体积下较低的内压意味着系统必须收缩以重新建立压力平衡，从而增加密度。该选项的结论与正确的物理响应相反。**错误**。\n\n**D. 首先减小 $\\sigma_{\\mathrm{O}}$；更小的核心通过减弱排斥作用来减少过度堆积，这会在固定的 $T$ 和 $p$ 下降低平衡密度。**\n建议的操作是减小 $\\sigma_{\\mathrm{O}}$。这是不正确的；它会通过允许分子更紧密地堆积来增加密度。其理由也毫无意义。更小的核心并不会“减少过度堆积”，反而会促进它。其降低平衡密度的结论是错误的。**错误**。\n\n**E. 首先改变任一参数都同样合适；$\\sigma_{\\mathrm{O}}$ 和 $\\epsilon_{\\mathrm{O}}$ 都控制优选间距的位置，因此在固定的 $T$ 和 $p$ 下以相同的方式影响密度。**\n这个陈述包含多个谬误。首先，如对选项B所解释的，只有 $\\sigma_{\\mathrm{O}}$ 控制势能最小值的位置，而不是 $\\epsilon_{\\mathrm{O}}$。其次，这两个参数并非“以相同的方式”影响密度；要降低密度，必须增加 $\\sigma_{\\mathrm{O}}$ 但减小 $\\epsilon_{\\mathrm{O}}$。因此，在这两个参数需要相反调整的意义上，它们并非“同样适合作为首要改变”。**错误**。\n\n总之，选项A是唯一一个提出了正确操作并给出了正确物理原因的选项。增加有效原子尺寸（$\\sigma_{\\mathrm{O}}$）是在恒定压力下增加系统体积从而降低其密度的直接方法。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "模拟开始运行后，监控其物理真实性至关重要。本练习旨在解决一个常见的陷阱：模拟体系意外地发生了相变，例如水结成了冰。通过仅分析势能这一基本观测量，你将学习识别相变的独特热力学特征，并将其与正常的平衡涨落区分开来，这项实践可以磨练诊断模拟行为、确保结果可靠性的关键技能。",
            "id": "2455681",
            "problem": "您正在使用显式溶剂模型，在温度为 $T$ 的恒定粒子数、体积、温度 (NVT) 系综中对液态水进行分子动力学 (MD) 模拟。该系统由 $N$ 个刚性水分子组成，它们被限制在一个密度固定的周期性立方体盒子中，并通过温控器维持温度 $T$。您不能查看坐标或速度；您唯一可以实时监控的可观测量是系统的总势能 $U_{\\mathrm{pot}}(t)$。在正则系综中，具有势能 $U$ 的构型的抽样概率与 $\\exp(-\\beta U)$ 成正比，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。您怀疑由于积分或温控器参数设置不当，溶剂在模拟过程中意外地冻结成了类固态。仅根据 $U_{\\mathrm{pot}}(t)$，以下哪种观测到的 $U_{\\mathrm{pot}}(t)$ 时间轨迹是这种意外冻结最可靠的指标？\n\nA. 初始平衡后，$U_{\\mathrm{pot}}(t)$ 经历一次相对突然的下降，达到一个明显更低且持久的平台期，同时，其涨落显著变窄，成为振幅小、方差大幅减小的近简谐振动，并在多个振动周期内持续，而未恢复到之前的均值。\n\nB. 初始平衡后，$U_{\\mathrm{pot}}(t)$ 围绕一个平稳的均值波动，方差近似恒定，并且在很长一段时间内没有系统性漂移，偶尔出现较大的偏移，但均值或方差没有持久的变化。\n\nC. $U_{\\mathrm{pot}}(t)$ 以大致恒定的速率稳定地向零增加，反映了温控器的持续加热，并且这种单调上升标志着冻结的开始。\n\nD. $U_{\\mathrm{pot}}(t)$ 变成一条斜率为零的近乎完美的直线（随时间完全恒定），仅此一点就足以断定溶剂已经冻结。",
            "solution": "该问题要求仅根据总势能的时间序列 $U_{\\mathrm{pot}}(t)$，在液态水的分子动力学 (MD) 模拟中识别出意外冻结的最可靠特征。该模拟在正则 (NVT) 系综中进行。\n\n为了解决这个问题，我们必须分析液态到固态相变（冻结）的热力学和统计力学特征，以及它们如何在势能中表现出来。\n\n1.  **相与势能**：物质的相对应于系统高维构型空间中的一个区域。液相的特征是无序和高分子迁移率，使系统能够探索广阔范围的构型。这导致了相对较高的平均势能。固相（晶相）的特征是高度有序，分子被局限在晶格结构中。运动被限制在围绕这些平衡位置的小振幅振动。这种结构化的排列对应于势能面上的一个深势阱。因此，在相同温度下，固相的平均势能显著低于液相。\n\n2.  **相变能量学**：冻结是一级相变。它是一个放热过程，意味着当系统从高能量的液态转变为低能量的固态时，会释放潜热。在 NVT 模拟中，温控器的作用是维持恒定的平均动能（从而维持恒定的温度 $T$）。当系统冻结时，释放的势能转化为动能，温控器必须将这些能量从系统中移除以维持目标温度 $T$。在向更稳定构型转变的过程中，从整个系统中移除能量导致总势能 $U_{\\mathrm{pot}}$ 的净减少。这种减少将在 $U_{\\mathrm{pot}}(t)$ 的时间轨迹中表现为下降到一个新的、更低的平台期。\n\n3.  **势能的涨落**：可观测量涨落的幅度是系统状态的一个关键指标。\n    *   在**液态**中，分子可以自由平移和旋转，导致每个分子周围的局部环境不断重排。这种大尺度的结构探索导致总势能的显著涨落。\n    *   在**固态**中，分子被困在对应其晶格位置的深势阱中。它们的运动被限制在小范围的振动（声子）内。系统被限制在构型空间中一个更小的体积内。这种受限的动力学导致势能涨落幅度的急剧减小。与液相相比，固相中势能的方差 $\\sigma^2(U_{\\mathrm{pot}}) = \\langle (U_{\\mathrm{pot}} - \\langle U_{\\mathrm{pot}} \\rangle)^2 \\rangle$ 将会小得多。围绕深势阱最小值的振动通常可以很好地近似为简谐振动，从而在势能信号中产生“近简谐振动”。\n\n基于这些原理，$U_{\\mathrm{pot}}(t)$ 轨迹中意外冻结的特征必须包括两个关键点：\n1.  $U_{\\mathrm{pot}}(t)$ 的平均值出现明显且通常是突然的下降，达到一个新的、稳定的、更低的基线。\n2.  围绕这个新基线，$U_{\\mathrm{pot}}(t)$ 涨落的振幅（方差）同时显著减小。\n\n现在，我们基于这一理解来评估每个选项。\n\n**A. 初始平衡后，$U_{\\mathrm{pot}}(t)$ 经历一次相对突然的下降，达到一个明显更低且持久的平台期，同时，其涨落显著变窄，成为振幅小、方差大幅减小的近简谐振动，并在多个振动周期内持续，而未恢复到之前的均值。**\n\n这个陈述准确而全面地描述了预期的特征。\n*   `“突然的下降，达到一个明显更低且持久的平台期”`：这对应于系统稳定在能量更低的固态，并释放出潜热。\n*   `“涨落显著变窄，成为振幅小、方差大幅减小的近简谐振动”`：这正确地捕捉了动力学从扩散性液体运动到固态晶格中局域振动的变化。\n*   `“持续……而未恢复”`：这表明系统现在处于新的冻结状态下，是稳定（或亚稳）的。\n\n这个选项结合了均值的变化和涨落的变化，提供了一个完整而可靠的指标。\n结论：**正确**。\n\n**B. 初始平衡后，$U_{\\mathrm{pot}}(t)$ 围绕一个平稳的均值波动，方差近似恒定，并且在很长一段时间内没有系统性漂移，偶尔出现较大的偏移，但均值或方差没有持久的变化。**\n\n这个陈述描述了一个在单一稳定相（液相）内正确平衡的系统。围绕平稳均值的涨落是系统处于平衡状态的标志。没有迹象表明发生了相变。这是一个成功模拟的预期行为，其中*没有*发生相变。\n结论：**不正确**。\n\n**C. $U_{\\mathrm{pot}}(t)$ 以大致恒定的速率稳定地向零增加，反映了温控器的持续加热，并且这种单调上升标志着冻结的开始。**\n\n这个陈述是根本错误的。冻结是一个放热过程，伴随着形成更强、更有序的分子间键，势能会*降低*。势能的稳定增加表明系统正在向能量更高、更不稳定的状态移动，例如沸腾，或者仅仅是因为一个持续注入能量的故障温控器导致系统升温。对于分子系统，势能通常是负值（零点参考为无限远分离），因此“向零增加”意味着分子间相互作用减弱，这与冻结过程相反。\n结论：**不正确**。\n\n**D. $U_{\\mathrm{pot}}(t)$ 变成一条斜率为零的近乎完美的直线（随时间完全恒定），仅此一点就足以断定溶剂已经冻结。**\n\n对于在有限温度 $T  0$ 下的模拟，这个陈述在物理上是不正确的。在正则系综中，系统的构型在原子的热运动（非零动能）驱动下不断变化。随着原子位置的改变，势能也必须改变。因此，$U_{\\mathrm{pot}}(t)$ 必须有涨落。一个完全恒定的 $U_{\\mathrm{pot}}(t)$ 意味着所有粒子的位置都是固定的，这将意味着动能为零（或者模拟已经崩溃）。这与在 $T  0$ 条件下的 NVT 模拟不符。虽然固态的涨落比液态小得多，但它们并非为零。这个选项描述的是一个损坏的模拟所产生的非物理假象，而不是有限温度下物质的物理状态。此外，它忽略了平均势能的关键性下降，而这是该一级相变的主要热力学信号。\n结论：**不正确**。\n\n总而言之，选项 A 提供了唯一一个在物理上合理且完整的描述，说明了在势能时间序列中可以观察到的冻结特征。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "显式溶剂模型的选择范围很广，从简单快速的模型到复杂且计算量巨大的模型。最后的这项练习提供了一个定量框架来理解这种权衡。通过建立一个性能模型来比较一个简单的非极化模型 (TIP3P) 和一个先进的可极化模型 (AMOEBA)，你将从基本原理的角度理解为什么更精确的物理描述会带来高昂的计算成本，这对于在面对特定科学问题和可用资源时做出明智的模型选择至关重要。",
            "id": "2455716",
            "problem": "您的任务是建立一个简单的第一性原理性能模型，以定量比较对同一溶剂化蛋白质系统进行的两种显式溶剂分子动力学（MD）模拟的计算成本（以 CPU 小时/纳秒表示）：一种使用三点可转移分子间势（TIP3P）水模型，另一种使用生物分子应用原子多极优化能量学（AMOEBA）可极化水模型。该比较必须基于经典的 MD 方法（通过积分牛顿运动方程）以及关于主要工作组成部分的经过充分测试的算法事实：键合相互作用、截断半径内的实空间非键相互作用、通过质点网格埃瓦尔德（PME）方法处理的长程静电作用、完整约束（例如 SHAKE），以及针对 AMOEBA 的迭代自洽极化。您将使用下面规定的参数值和常数来计算每个时间步的总浮点运算次数，将其扩展为每纳秒的步数，最后假设单个 CPU 核心具有指定的持续浮点吞吐量，将其转换为 CPU 小时。\n\n使用的基本原理：\n- 经典 MD 通过使用有限时间步长 $\\,\\Delta t\\,$ 积分牛顿方程来推进位置，因此在时间间隔 $\\,T\\,$ 内的步数为 $\\,T/\\Delta t\\,$。\n- 实空间短程非键作用的计算量与截断半径 $\\,r_c\\,$ 内的相互作用对的数量成正比。在边长为 $\\,L\\,$、体积为 $\\,V=L^3\\,$ 的立方盒子中，原子数密度均匀为 $\\,\\rho_{\\text{atom}}\\,\\equiv\\,N/V\\,$ 的情况下，每个原子的平均邻居数为 $\\,\\frac{4}{3}\\pi r_c^3 \\rho_{\\text{atom}}\\,$，每步的总原子对数为 $\\,N_{\\text{pairs}}=\\tfrac{1}{2}N\\left(\\tfrac{4}{3}\\pi r_c^3 \\rho_{\\text{atom}}\\right)\\,$。\n- PME 的成本与网格点数 $\\,M\\,=\\,N_x N_y N_z\\,$ 成 $\\,\\mathcal{O}(M\\log_2 M)\\,$ 关系。对于立方系统，取 $\\,N_x=N_y=N_z=\\mathrm{round}(L/g)\\,$，其中 $\\,g\\,$ 是网格间距，且 $\\,M = N_x^3\\,$。使用以 2 为底的对数 $\\,\\log_2(\\cdot)\\,$。\n- 完整约束的成本与受约束的键的数量成正比，这里建模为总原子数的固定分数。\n- AMOEBA 引入了一个迭代自洽极化过程，每次迭代都会产生额外的成对电场评估开销。\n\n您必须采用以下成本模型（所有成本单位为每个时间步的浮点运算次数）和常数。下面的每个符号和数字都必须按原样使用，不得做任何修改：\n- 边长为 $\\,L\\,$（单位为埃）的立方盒子中的总原子数 $\\,N\\,$，因此 $\\,V=L^3\\,$ 且 $\\,\\rho_{\\text{atom}}=N/V\\,$。\n- 实空间截断半径 $\\,r_c\\,$（单位为埃）。\n- PME 网格间距 $\\,g\\,$（单位为埃），其中 $\\,N_x=\\mathrm{round}(L/g)\\,$ 且 $\\,M=N_x^3\\,$。\n- 受约束键的比例 $\\,f_c\\,$，每步约束迭代次数 $\\,i_{\\text{cons}}\\,$，以及每次迭代中每个受约束键的成本 $\\,k_{\\text{cons}}\\,$。\n- 时间步长：TIP3P 使用 $\\,\\Delta t_{\\mathrm{T}}\\,$（单位为飞秒），AMOEBA 使用 $\\,\\Delta t_{\\mathrm{A}}\\,$（单位为飞秒）。当 $\\,\\Delta t\\,$ 以飞秒为单位时，每纳秒的步数为 $\\,10^6/\\Delta t\\,$。\n- 各组成部分的浮点运算次数（常数）：\n  - 每个原子的键合相互作用：TIP3P $\\,k_{\\text{bond,T}}=200\\,$，AMOEBA $\\,k_{\\text{bond,A}}=300\\,$。\n  - 每对原子的实空间非键相互作用：TIP3P $\\,k_{\\text{nb,T}}=60\\,$，AMOEBA $\\,k_{\\text{nb,A}}=150\\,$。\n  - PME 运算：TIP3P $\\,K_{\\text{PME,T}}=50\\,$，AMOEBA $\\,K_{\\text{PME,A}}=120\\,$，用作每步 $\\,K_{\\text{PME}}\\,M\\,\\log_2 M\\,$。\n  - 每次迭代中每个受约束键的约束成本：$\\,k_{\\text{cons}}=500\\,$。\n  - AMOEBA 极化：每步迭代次数 $\\,I\\,$，每次迭代的成本为 $\\,k_{\\text{pol,pair}}\\,N_{\\text{pairs}} + k_{\\text{pol,upd}}\\,N\\,$，其中 $\\,k_{\\text{pol,pair}}=80\\,$ 且 $\\,k_{\\text{pol,upd}}=20\\,$。\n- 单个 CPU 核心的持续浮点吞吐量：$\\,F = 2.0\\times 10^{10}\\,$ 浮点运算/秒。通过除以 $\\,F\\,$ 再除以 $\\,3600\\,$，将每纳秒的总运算次数转换为 CPU 小时/纳秒。\n\n定义 TIP3P 的每步运算次数为\n$$\n\\mathrm{FLOPs}_{\\text{step,T}} \\;=\\; k_{\\text{bond,T}}\\,N \\;+\\; k_{\\text{nb,T}}\\,N_{\\text{pairs}} \\;+\\; K_{\\text{PME,T}}\\,M\\,\\log_2 M \\;+\\; k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}}\\,,\n$$\n以及 AMOEBA 的每步运算次数为\n$$\n\\mathrm{FLOPs}_{\\text{step,A}} \\;=\\; k_{\\text{bond,A}}\\,N \\;+\\; k_{\\text{nb,A}}\\,N_{\\text{pairs}} \\;+\\; K_{\\text{PME,A}}\\,M\\,\\log_2 M \\;+\\; k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}} \\;+\\; I\\left(k_{\\text{pol,pair}}\\,N_{\\text{pairs}}+k_{\\text{pol,upd}}\\,N\\right).\n$$\n然后计算\n$$\n\\mathrm{FLOPs/ns}_{\\mathrm{T}} \\;=\\; \\mathrm{FLOPs}_{\\text{step,T}} \\times \\frac{10^6}{\\Delta t_{\\mathrm{T}}}\\,,\n\\qquad\n\\mathrm{FLOPs/ns}_{\\mathrm{A}} \\;=\\; \\mathrm{FLOPs}_{\\text{step,A}} \\times \\frac{10^6}{\\Delta t_{\\mathrm{A}}}\\,,\n$$\n和\n$$\n\\mathrm{CPU\\,hours/ns} \\;=\\; \\frac{\\mathrm{FLOPs/ns}}{F\\times 3600}\\,.\n$$\n\n不使用角度单位。所有距离单位为埃，时间步长单位为飞秒，最终答案必须以 CPU 小时/纳秒表示，并四舍五入到三位小数。程序必须为每个测试用例计算三元组 $[\\mathrm{TIP3P\\_hours/ns},\\,\\mathrm{AMOEBA\\_hours/ns},\\,\\mathrm{AMOEBA}/\\mathrm{TIP3P}]$。\n\n测试套件。对于每个用例，使用元组 $(N, L, r_c, g, \\Delta t_{\\mathrm{T}}, \\Delta t_{\\mathrm{A}}, I, f_c, i_{\\text{cons}})$：\n- 用例 $\\,1\\,$ (基准大型溶剂化蛋白质):\n  - $N=80000$, $L=90$, $r_c=9$, $g=1.0$, $\\Delta t_{\\mathrm{T}}=2.0$, $\\Delta t_{\\mathrm{A}}=1.0$, $I=6$, $f_c=0.35$, $i_{\\text{cons}}=2$。\n- 用例 $\\,2\\,$ (较小系统):\n  - $N=12000$, $L=60$, $r_c=10$, $g=1.1$, $\\Delta t_{\\mathrm{T}}=2.0$, $\\Delta t_{\\mathrm{A}}=1.0$, $I=5$, $f_c=0.35$, $i_{\\text{cons}}=2$。\n- 用例 $\\,3\\,$ (较大截断半径):\n  - $N=80000$, $L=90$, $r_c=11$, $g=1.0$, $\\Delta t_{\\mathrm{T}}=2.0$, $\\Delta t_{\\mathrm{A}}=1.0$, $I=6$, $f_c=0.35$, $i_{\\text{cons}}=2$。\n- 用例 $\\,4\\,$ (较粗的 PME 网格和更严格的极化):\n  - $N=80000$, $L=90$, $r_c=9$, $g=1.6$, $\\Delta t_{\\mathrm{T}}=2.0$, $\\Delta t_{\\mathrm{A}}=0.5$, $I=7$, $f_c=0.35$, $i_{\\text{cons}}=2$。\n\n额外的建模细节和约束：\n- 使用 $\\,\\rho_{\\text{atom}}=N/L^3\\,$ 和均匀密度邻居估算。如果计算出的每个原子的邻居数超过 $\\,N-1\\,$，则将其上限设为 $\\,N-1\\,$。然后设置 $\\,N_{\\text{pairs}}=\\tfrac{1}{2}N \\times \\text{每个原子的邻居数}\\,$。\n- 计算 $\\,N_x=\\max\\{8,\\,\\mathrm{round}(L/g)\\}\\,$ 以避免过小的网格，然后 $\\,M=N_x^3\\,$。\n- PME 项使用以 2 为底的对数 $\\,\\log_2(\\cdot)\\,$。\n- 假设所有用例都使用一个吞吐量为 $\\,F=2.0\\times 10^{10}\\,$ 浮点运算/秒的 CPU 核心。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个按测试用例顺序排列的四个子列表的列表。每个子列表必须为 $[\\text{TIP3P\\_hours/ns},\\text{AMOEBA\\_hours/ns},\\text{AMOEBA}/\\text{TIP3P}]$ 格式，其中每个条目都是一个四舍五入到三位小数的浮点数。例如，一个有效的整体输出格式是：\n  - $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4]]$。",
            "solution": "问题陈述是在分子动力学（MD）模拟性能建模方面一个定义明确且具有科学依据的练习。它提供了一套完整的参数、常数和一致的算法成本模型，用以比较两种常见的显式溶剂模型：刚性的、不可极化的 TIP3P 模型和可极化的 AMOEBA 模型。关于力场计算中不同组成部分——键合相互作用、实空间非键相互作用、用于长程静电作用的质点网格埃瓦尔德（PME）方法，以及用于约束和极化的迭代过程——的计算工作量缩放假设是标准的，反映了计算化学中已确立的原则。该问题客观、无歧义，并包含获得唯一解所需的所有必要信息。因此，该问题被认为是有效的，并将提供完整的解答。\n\n目标是计算两种不同力场下模拟每纳秒的总计算成本，单位为 CPU 小时。该成本源自所需的总浮点运算（FLOPs）次数。每纳秒的总 FLOPs 是每个积分时间步的 FLOPs 与每纳秒的时间步数的乘积。\n\n让我们为每个模型详细分析每个时间步的总 FLOPs，即 $\\mathrm{FLOPs}_{\\text{step}}$。该成本是 MD 算法各个组成部分贡献的总和。\n\n1.  **系统相关参数**：对于任何由总原子数 $N$、立方盒子边长 $L$ 和实空间截断半径 $r_c$ 定义的给定系统，我们首先计算共享的几何和结构量。\n    - 均匀原子数密度为 $\\rho_{\\text{atom}} = N/L^3$。\n    - 对于任何给定原子，在截断球内的平均相互作用邻居数近似为 $N_{\\text{neighbors/atom}} = \\frac{4}{3}\\pi r_c^3 \\rho_{\\text{atom}}$。该值最大不超过 $N-1$，即其他原子的总数。\n    - 考虑到牛顿第三定律（作用力与反作用力对不重复计算），总相互作用对数为 $N_{\\text{pairs}} = \\frac{1}{2} N \\times N_{\\text{neighbors/atom}}$。\n    - 对于 PME 计算，一个方向上的网格维度为 $N_x = \\max\\{8, \\mathrm{round}(L/g)\\}$，其中 $g$ 是网格间距。最小值 $8$ 可防止网格过小。总网格点数则为 $M = N_x^3$。\n\n2.  **TIP3P 模型成本**：每步总成本 $\\mathrm{FLOPs}_{\\text{step,T}}$ 是以下各项的总和：\n    - **键合相互作用**：包括键、角和二面角项。该成本是局部的，并与原子数成线性关系，由 $k_{\\text{bond,T}}\\,N$ 给出。\n    - **实空间非键相互作用**：这包括截断半径 $r_c$ 内原子对之间的 Lennard-Jones 和短程库仑相互作用。成本与原子对数成正比，即 $k_{\\text{nb,T}}\\,N_{\\text{pairs}}$。\n    - **PME 倒易空间相互作用**：埃瓦尔德加和的倒易空间部分的成本，使用 PME 网格上的快速傅里叶变换（FFT）计算，其复杂度为 $\\mathcal{O}(M \\log M)$。该成本建模为 $K_{\\text{PME,T}}\\,M\\,\\log_2 M$。\n    - **完整约束**：用于约束键长（例如在水分子中）的迭代算法（如 SHAKE）的成本与受约束实体数量（$f_c N$）、迭代次数（$i_{\\text{cons}}$）以及每次迭代中每个实体的成本（$k_{\\text{cons}}$）成正比。总成本为 $k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}}$。\n    完整的表达式为：\n    $$\n    \\mathrm{FLOPs}_{\\text{step,T}} \\;=\\; k_{\\text{bond,T}}\\,N \\;+\\; k_{\\text{nb,T}}\\,N_{\\text{pairs}} \\;+\\; K_{\\text{PME,T}}\\,M\\,\\log_2 M \\;+\\; k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}}\n    $$\n    \n3.  **AMOEBA 模型成本**：AMOEBA 模型更为复杂，导致大多数组件的计算成本更高，并为感应极化增加了一个全新的、昂贵的项。\n    - **键合、非键和 PME**：这些项与 TIP3P 的类似，但具有更大的成本系数（$k_{\\text{bond,A}}$, $k_{\\text{nb,A}}$, $K_{\\text{PME,A}}$），反映了更复杂的函数形式（例如，多极相互作用与点电荷）。约束成本保持不变。\n    - **自洽极化**：这是一个主要的额外成本。在每个时间步，必须迭代计算感应偶极。在 $I$ 次迭代中，每次迭代都涉及计算每个原子位点上来自所有其他位点的电场（这是一个成对操作），并更新偶极。该成本建模为 $I\\left(k_{\\text{pol,pair}}\\,N_{\\text{pairs}}+k_{\\text{pol,upd}}\\,N\\right)$。\n    完整的表达式为：\n    $$\n    \\mathrm{FLOPs}_{\\text{step,A}} \\;=\\; k_{\\text{bond,A}}\\,N \\;+\\; k_{\\text{nb,A}}\\,N_{\\text{pairs}} \\;+\\; K_{\\text{PME,A}}\\,M\\,\\log_2 M \\;+\\; k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}} \\;+\\; I\\left(k_{\\text{pol,pair}}\\,N_{\\text{pairs}}+k_{\\text{pol,upd}}\\,N\\right)\n    $$\n    \n4.  **最终成本转换**：为了获得以 CPU 小时/纳秒为单位的最终成本，我们必须考虑时间步长和处理器速度。模拟 $1\\,\\mathrm{ns}$（$10^6\\,\\mathrm{fs}$）所需的步数是 $10^6 / \\Delta t$，其中 $\\Delta t$ 是以飞秒为单位的时间步长。请注意，TIP3P 的 $\\Delta t_{\\mathrm{T}}$ 通常大于 AMOEBA 的 $\\Delta t_{\\mathrm{A}}$，这是整体成本比较中的一个关键因素。每纳秒的总 FLOPs 随后为：\n    $$\n    \\mathrm{FLOPs/ns} \\;=\\; \\mathrm{FLOPs}_{\\text{step}} \\times \\frac{10^6}{\\Delta t}\n    $$\n    然后使用给定的单核吞吐量 $F = 2.0 \\times 10^{10}\\,\\mathrm{FLOPs/秒}$ 将此值转换为 CPU 小时：\n    $$\n    \\mathrm{CPU\\,hours/ns} \\;=\\; \\frac{\\mathrm{FLOPs/ns}}{F\\times 3600\\,\\mathrm{s/hr}}\n    $$\n    我们现在将把这个完整的过程应用于所提供的四个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates and compares the computational cost of TIP3P and AMOEBA\n    MD simulations based on a first-principles performance model.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (N, L, r_c, g, dt_T, dt_A, I, f_c, i_cons)\n    test_cases = [\n        (80000, 90, 9, 1.0, 2.0, 1.0, 6, 0.35, 2),   # Case 1\n        (12000, 60, 10, 1.1, 2.0, 1.0, 5, 0.35, 2),  # Case 2\n        (80000, 90, 11, 1.0, 2.0, 1.0, 6, 0.35, 2),  # Case 3\n        (80000, 90, 9, 1.6, 2.0, 0.5, 7, 0.35, 2),   # Case 4\n    ]\n\n    # Per-component floating-point operation counts (constants)\n    k_bond_T = 200.0\n    k_bond_A = 300.0\n    k_nb_T = 60.0\n    k_nb_A = 150.0\n    K_PME_T = 50.0\n    K_PME_A = 120.0\n    k_cons = 500.0\n    k_pol_pair = 80.0\n    k_pol_upd = 20.0\n    \n    # Sustained floating-point throughput of one CPU core (FLOPs/sec)\n    F = 2.0e10\n    \n    results = []\n    \n    for case in test_cases:\n        N, L, r_c, g, dt_T, dt_A, I, f_c, i_cons = case\n        \n        # --- Step 1: Calculate System-Dependent Intermediate Values ---\n        rho_atom = N / (L**3)\n        \n        neighbors_per_atom = (4.0 / 3.0) * np.pi * (r_c**3) * rho_atom\n        # Cap the average number of neighbors at N-1\n        neighbors_per_atom = min(neighbors_per_atom, N - 1)\n        \n        N_pairs = 0.5 * N * neighbors_per_atom\n        \n        Nx = max(8, int(np.round(L / g)))\n        M = float(Nx**3)\n        \n        # --- Step 2: Calculate Per-Step FLOPs for TIP3P ---\n        cost_bond_T = k_bond_T * N\n        cost_nb_T = k_nb_T * N_pairs\n        cost_PME_T = K_PME_T * M * np.log2(M) if M > 1 else 0\n        cost_cons = k_cons * (f_c * N) * i_cons\n        \n        flops_step_T = cost_bond_T + cost_nb_T + cost_PME_T + cost_cons\n        \n        # --- Step 3: Calculate Per-Step FLOPs for AMOEBA ---\n        cost_bond_A = k_bond_A * N\n        cost_nb_A = k_nb_A * N_pairs\n        cost_PME_A = K_PME_A * M * np.log2(M) if M > 1 else 0\n        \n        # Polarization cost\n        cost_pol = I * (k_pol_pair * N_pairs + k_pol_upd * N)\n        \n        flops_step_A = cost_bond_A + cost_nb_A + cost_PME_A + cost_cons + cost_pol\n        \n        # --- Step 4: Calculate Total FLOPs per Nanosecond ---\n        steps_per_ns_T = 1.0e6 / dt_T\n        steps_per_ns_A = 1.0e6 / dt_A\n        \n        flops_ns_T = flops_step_T * steps_per_ns_T\n        flops_ns_A = flops_step_A * steps_per_ns_A\n        \n        # --- Step 5: Convert to CPU Hours per Nanosecond ---\n        seconds_per_hour = 3600.0\n        cpu_hours_ns_T = flops_ns_T / (F * seconds_per_hour)\n        cpu_hours_ns_A = flops_ns_A / (F * seconds_per_hour)\n        \n        # --- Step 6: Calculate the Ratio ---\n        ratio = cpu_hours_ns_A / cpu_hours_ns_T if cpu_hours_ns_T > 0 else 0\n        \n        # --- Step 7: Format and store results ---\n        results.append([\n            round(cpu_hours_ns_T, 3),\n            round(cpu_hours_ns_A, 3),\n            round(ratio, 3),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}