{
    "hands_on_practices": [
        {
            "introduction": "This first practice is your entry into building a quantum chemistry program from scratch. We will implement the complete self-consistent field (SCF) cycle for the simple HeH$^+$ cation, a process that lies at the heart of molecular orbital theory . This exercise will solidify your understanding of the Roothaan-Hall equations by translating them into a working algorithm, from assembling the Fock matrix to iterating until a self-consistent solution is reached.",
            "id": "2465550",
            "problem": "Implement a program that computes the evolution of the molecular orbital coefficients for the diatomic cation helium hydride, denoted HeH$^+$, under a closed-shell restricted Hartree–Fock self-consistent field (SCF) procedure in a minimal basis of two atom-centered basis functions. The atomic orbital basis consists of two functions: index $0$ on helium and index $1$ on hydrogen. The molecular orbitals are expanded as column vectors of coefficients $\\mathbf{c}$ in this atomic orbital basis. All quantities are in atomic units.\n\nGiven the overlap matrix $\\mathbf{S}$, the one-electron core Hamiltonian matrix $\\mathbf{h}$, and the nonzero two-electron repulsion integrals $(\\mu \\nu \\lvert \\lambda \\sigma)$ listed below, the closed-shell Fock matrix $\\mathbf{F}$ for a density matrix $\\mathbf{P}$ is defined by\n$$\nF_{\\mu \\nu} \\;=\\; h_{\\mu \\nu} \\;+\\; \\sum_{\\lambda,\\sigma} P_{\\lambda \\sigma}\\,\\Big[\\,(\\mu \\nu \\lvert \\lambda \\sigma)\\;-\\;\\tfrac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\Big].\n$$\nThe occupied molecular orbital coefficient vector $\\mathbf{c}$ (for the lowest-energy orbital) solves the generalized eigenvalue problem\n$$\n\\mathbf{F}\\,\\mathbf{c} \\;=\\; \\epsilon\\,\\mathbf{S}\\,\\mathbf{c}, \\quad \\text{with normalization } \\mathbf{c}^{\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c} \\;=\\; 1,\n$$\nand the closed-shell density matrix is\n$$\n\\mathbf{P} \\;=\\; 2\\,\\mathbf{c}\\,\\mathbf{c}^{\\mathsf{T}}.\n$$\n\nUse the following data, which defines a consistent minimal-basis model for HeH$^+$:\n- Overlap matrix\n$$\n\\mathbf{S} \\;=\\; \\begin{bmatrix} 1  0.2 \\\\ 0.2  1 \\end{bmatrix}.\n$$\n- One-electron core Hamiltonian\n$$\n\\mathbf{h} \\;=\\; \\begin{bmatrix} -2.0  -0.2 \\\\ -0.2  -1.0 \\end{bmatrix}.\n$$\n- Nonzero two-electron repulsion integrals, using chemists’ notation $(\\mu \\nu \\lvert \\lambda \\sigma)$, are:\n$$\n(0\\,0 \\lvert 0\\,0) \\,=\\, 1.0,\\quad\n(1\\,1 \\lvert 1\\,1) \\,=\\, 0.7,\\quad\n(0\\,0 \\lvert 1\\,1) \\,=\\, (1\\,1 \\lvert 0\\,0) \\,=\\, 0.6,\\quad\n(0\\,1 \\lvert 0\\,1) \\,=\\, (0\\,1 \\lvert 1\\,0) \\,=\\, (1\\,0 \\lvert 0\\,1) \\,=\\, (1\\,0 \\lvert 1\\,0) \\,=\\, 0.2,\n$$\nand any integral not obtainable by permuting indices of the above is zero.\n\nFor a given initial occupied-orbital coefficient guess $\\mathbf{c}^{(0)}$ (not necessarily normalized), define the initial density as\n$$\n\\mathbf{P}^{(0)} \\;=\\; 2\\,\\tilde{\\mathbf{c}}^{(0)}\\,\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}},\n$$\nwhere $\\tilde{\\mathbf{c}}^{(0)}$ is $\\mathbf{c}^{(0)}$ normalized to satisfy $\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}} \\mathbf{S}\\,\\tilde{\\mathbf{c}}^{(0)} = 1$. At each subsequent SCF iteration $k \\to k+1$, obtain the new occupied-orbital $\\mathbf{c}^{(k+1)}$ as the normalized lowest-eigenvalue solution of the generalized eigenproblem for $\\mathbf{F}[\\mathbf{P}^{(k)}]$. Impose the phase convention\n$$\n\\tilde{\\mathbf{c}}^{(k+1)} \\;\\leftarrow\\; \\operatorname{sign}\\!\\big( \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)} \\big)\\,\\tilde{\\mathbf{c}}^{(k+1)},\n$$\nto ensure continuity of the coefficients, where $\\tilde{\\mathbf{c}}^{(k)}$ denotes the $\\mathbf{S}$-normalized occupied-orbital at iteration $k$. Form the raw updated density $\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)} \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$. Apply linear mixing with parameter $\\alpha \\in [0,1)$ to define\n$$\n\\mathbf{P}^{(k+1)} \\;=\\; (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} \\;+\\; \\alpha\\,\\mathbf{P}^{(k)}.\n$$\nConvergence is achieved when the elementwise infinity norm satisfies\n$$\n\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty} \\;\\; \\tau,\n$$\nwith threshold $\\tau = 10^{-10}$, or when a hard limit of $200$ iterations is reached.\n\nTask. For each test case below, starting from the given initial guess and mixing parameter, compute and record the sequence of the helium-basis coefficient values $c_0^{(k)}$ of the occupied molecular orbital at iteration $k$, including the initial normalized guess $c_0^{(0)}$ and one value per subsequent iteration until convergence (or until the cap of $200$ iterations is reached). Use the phase convention above at every step. Round each recorded $c_0^{(k)}$ to $6$ decimal places.\n\nTest Suite. Use the following four test cases, each specified by a mixing parameter $\\alpha$ and an initial guess vector $\\mathbf{c}^{(0)}$:\n- Case A (happy path): $\\alpha = 0.0$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$.\n- Case B (alternative start): $\\alpha = 0.0$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$.\n- Case C (damped mixing): $\\alpha = 0.5$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} 0.6 \\\\ 0.8 \\end{bmatrix}$.\n- Case D (edge case, heavy damping): $\\alpha = 0.9$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} -0.7 \\\\ 0.3 \\end{bmatrix}$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a bracketed comma-separated list of the rounded $c_0^{(k)}$ values for that test case, in order A, B, C, D. For example, an output with two hypothetical cases would look like $[[0.123456,0.234567],[0.345678,0.456789]]$. Your actual program must print the lists for all four cases exactly in this nested format.",
            "solution": "The problem statement submitted for analysis is a request to implement the closed-shell restricted Hartree-Fock (RHF) self-consistent field (SCF) procedure for the diatomic cation HeH$^+$. A validation of the problem is mandatory.\n\n### Step 1: Extraction of Givens\nThe problem provides the following quantities and definitions in atomic units:\n- Basis set: Minimal, with function $0$ on Helium and function $1$ on Hydrogen.\n- Overlap matrix: $\\mathbf{S} = \\begin{bmatrix} 1  0.2 \\\\ 0.2  1 \\end{bmatrix}$.\n- Core Hamiltonian matrix: $\\mathbf{h} = \\begin{bmatrix} -2.0  -0.2 \\\\ -0.2  -1.0 \\end{bmatrix}$.\n- Nonzero two-electron repulsion integrals (ERIs) in chemists' notation:\n  $(0\\,0 \\lvert 0\\,0) = 1.0$,\n  $(1\\,1 \\lvert 1\\,1) = 0.7$,\n  $(0\\,0 \\lvert 1\\,1) = (1\\,1 \\lvert 0\\,0) = 0.6$,\n  $(0\\,1 \\lvert 0\\,1) = (0\\,1 \\lvert 1\\,0) = (1\\,0 \\lvert 0\\,1) = (1\\,0 \\lvert 1\\,0) = 0.2$.\n- Fock matrix: $F_{\\mu \\nu} = h_{\\mu \\nu} + \\sum_{\\lambda,\\sigma} P_{\\lambda \\sigma}\\,\\Big[\\,(\\mu \\nu \\lvert \\lambda \\sigma)\\;-\\;\\tfrac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\Big]$.\n- Density matrix: $\\mathbf{P} = 2\\,\\mathbf{c}\\,\\mathbf{c}^{\\mathsf{T}}$ for a single occupied orbital.\n- Roothaan-Hall equations: $\\mathbf{F}\\,\\mathbf{c} = \\epsilon\\,\\mathbf{S}\\,\\mathbf{c}$, with normalization $\\mathbf{c}^{\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c} = 1$.\n- SCF iterative procedure:\n  1. Initial guess $\\mathbf{c}^{(0)}$ is $\\mathbf{S}$-normalized to $\\tilde{\\mathbf{c}}^{(0)}$ to form $\\mathbf{P}^{(0)} = 2\\,\\tilde{\\mathbf{c}}^{(0)}\\,\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}}$.\n  2. For $k \\ge 0$, solve for the lowest-energy eigenvector of $\\mathbf{F}[\\mathbf{P}^{(k)}]$, denoted $\\tilde{\\mathbf{c}}^{(k+1)}$.\n  3. Apply phase convention: $\\tilde{\\mathbf{c}}^{(k+1)} \\leftarrow \\operatorname{sign}(\\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)})\\,\\tilde{\\mathbf{c}}^{(k+1)}$.\n  4. Form raw density: $\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)} \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$.\n  5. Apply linear mixing: $\\mathbf{P}^{(k+1)} = (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} + \\alpha\\,\\mathbf{P}^{(k)}$.\n- Convergence criterion: $\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty}  \\tau = 10^{-10}$.\n- Iteration limit: $200$.\n- Test cases: Four pairs of $(\\alpha, \\mathbf{c}^{(0)})$ are provided.\n- Required output: A sequence of the coefficient $c_0$ for the occupied orbital at each iteration, rounded to $6$ decimal places.\n\n### Step 2: Validation of Givens\nThe problem is evaluated against the required criteria.\n1.  **Scientific Grounding**: The problem describes the standard RHF-SCF method, a cornerstone of computational quantum chemistry. The equations for the Fock matrix, density matrix, and the Roothaan-Hall system are correct representations of this theory for a closed-shell two-electron system.\n2.  **Well-Posedness**: The problem defines a complete iterative algorithm, including initial conditions, a precise update rule for each step, a clear phase convention to ensure uniqueness of eigenvectors, and a well-defined convergence criterion. The use of linear mixing (damping) is a standard technique for ensuring or accelerating convergence.\n3.  **Objectivity**: The problem is stated in precise mathematical and algorithmic terms, free from any subjectivity.\n4.  **Consistency**: All provided data and equations are self-contained and consistent. The definition of the Fock matrix, while using a slightly uncommon notation for the exchange term $(\\mu \\sigma \\lvert \\lambda \\nu)$, proves to be equivalent to the standard form $(\\mu \\lambda \\lvert \\nu \\sigma)$ for the given set of integrals and ensures the Fock matrix remains symmetric, which is a physical requirement. Thus, the formulation is internally consistent and physically sound.\n5.  **Completeness**: The problem provides all necessary numerical data ($\\mathbf{S}$, $\\mathbf{h}$, ERI values), algorithmic parameters ($\\alpha$, $\\tau$, iteration limit), and initial states to perform the calculation for all test cases.\n\n### Step 3: Verdict\nThe problem is **valid**. It is a well-defined, scientifically sound, and self-contained computational task. Proceeding with the solution is justified.\n\n### Solution\nThe objective is to solve the Roothaan-Hall equations for the HeH$^+$ cation within the specified minimal basis set using the self-consistent field method. HeH$^+$ is a two-electron system, so in a ground state, these two electrons occupy the molecular orbital (MO) with the lowest energy.\n\nThe molecular orbitals $\\psi_i$ are expressed as a linear combination of atomic orbitals (LCAO) $\\phi_\\mu$, $\\psi_i = \\sum_{\\mu} c_{\\mu i} \\phi_\\mu$. For our two-basis-function system ($\\mu \\in \\{0, 1\\}$), the occupied orbital coefficients form a vector $\\mathbf{c} = \\begin{bmatrix} c_0 \\\\ c_1 \\end{bmatrix}$. The SCF procedure iteratively refines these coefficients until the electronic field they produce is consistent with the field that generates them.\n\nThe algorithm proceeds as follows:\n\n**1. Initialization**\nFirst, we construct the four-dimensional tensor of two-electron repulsion integrals, $\\text{ERI}_{\\mu\\nu\\lambda\\sigma} = (\\mu \\nu \\lvert \\lambda \\sigma)$. This tensor is populated using the provided non-zero values and their inherent permutational symmetries: $(\\mu\\nu|\\lambda\\sigma) = (\\nu\\mu|\\lambda\\sigma) = (\\mu\\nu|\\sigma\\lambda) = (\\lambda\\sigma|\\mu\\nu)$. All other elements are zero.\n\nFor a given test case, starting with an initial guess vector $\\mathbf{c}^{(0)}$, we compute its $\\mathbf{S}$-norm: $N = \\sqrt{\\mathbf{c}^{(0)\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c}^{(0)}}$. The normalized initial coefficient vector is $\\tilde{\\mathbf{c}}^{(0)} = \\mathbf{c}^{(0)} / N$. The initial helium-basis coefficient, $c_0^{(0)} = \\tilde{c}_0^{(0)}$, is the first value recorded. From this, the initial density matrix is formed: $\\mathbf{P}^{(0)} = 2\\,\\tilde{\\mathbf{c}}^{(0)}\\,\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}}$. The factor of $2$ accounts for the two electrons in the single occupied spatial orbital.\n\n**2. SCF Iteration Cycle**\nThe iterative process begins, indexed by $k=0, 1, 2, \\dots$. At each iteration $k$, we have the density matrix $\\mathbf{P}^{(k)}$ and the coefficient vector from the previous step, $\\tilde{\\mathbf{c}}^{(k)}$.\n\n_a. Fock Matrix Construction_\nThe Fock matrix $\\mathbf{F}^{(k)}$ is constructed as the sum of the one-electron core Hamiltonian $\\mathbf{h}$ and the two-electron term $\\mathbf{G}^{(k)}$: $\\mathbf{F}^{(k)} = \\mathbf{h} + \\mathbf{G}^{(k)}$. The matrix $\\mathbf{G}^{(k)}$ accounts for the average electron-electron repulsion and is computed using the density matrix $\\mathbf{P}^{(k)}$ and the ERI tensor:\n$$\nG_{\\mu \\nu}^{(k)} \\;=\\; \\sum_{\\lambda,\\sigma} P^{(k)}_{\\lambda \\sigma}\\,\\Big[\\,(\\mu \\nu \\lvert \\lambda \\sigma)\\;-\\;\\tfrac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\Big]\n$$\nThis operation can be efficiently implemented using tensor contractions, for instance, with `numpy.einsum`.\n\n_b. Solving the Roothaan-Hall Equations_\nThe core of the SCF iteration is solving the generalized eigenvalue problem $\\mathbf{F}^{(k)}\\mathbf{c} = \\epsilon \\mathbf{S} \\mathbf{c}$. Since both $\\mathbf{F}^{(k)}$ and $\\mathbf{S}$ are symmetric matrices, and $\\mathbf{S}$ is positive-definite, this can be reliably solved using numerical libraries (e.g., `scipy.linalg.eigh`). The solution yields a set of eigenvalues (orbital energies) $\\epsilon_i$ and corresponding eigenvectors (MO coefficients) $\\mathbf{c}_i$. We select the eigenvector corresponding to the lowest eigenvalue, which represents the occupied molecular orbital. Let us call this eigenvector $\\mathbf{c}^{(k+1)}_{\\text{raw}}$. The `scipy.linalg.eigh` function conveniently returns eigenvectors that are already normalized such that $\\mathbf{c}^{\\mathsf{T}}\\mathbf{S}\\mathbf{c} = 1$.\n\n_c. Phase Correction_\nEigenvectors are unique only up to a sign. To ensure a continuous evolution of the coefficients, we enforce a consistent phase relative to the previous iteration's vector $\\tilde{\\mathbf{c}}^{(k)}$:\n$$\n\\tilde{\\mathbf{c}}^{(k+1)} = \\operatorname{sign}\\big( (\\mathbf{c}^{(k+1)}_{\\text{raw}})^{\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)} \\big)\\,\\mathbf{c}^{(k+1)}_{\\text{raw}}\n$$\nIf the overlap of the new vector with the old one (in the $\\mathbf{S}$ metric) is negative, the sign of the new vector is flipped. The helium-basis component of this phase-corrected vector, $c_0^{(k+1)} = \\tilde{c}_0^{(k+1)}$, is recorded.\n\n_d. Density Matrix Update and Mixing_\nA new \"raw\" density matrix is computed from the updated coefficients: $\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)}\\,\\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$. To improve convergence stability, this raw density is mixed with the density from the previous iteration using the mixing parameter $\\alpha$:\n$$\n\\mathbf{P}^{(k+1)} = (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} + \\alpha\\,\\mathbf{P}^{(k)}\n$$\n\n**3. Convergence Check**\nThe iteration is deemed converged if the maximum absolute element-wise difference between the new and old density matrices falls below a threshold $\\tau=10^{-10}$:\n$$\n\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty} = \\max_{i,j} |P_{ij}^{(k+1)} - P_{ij}^{(k)}|  \\tau\n$$\nIf this condition is met, the SCF loop terminates. Otherwise, the process repeats from step 2a with the new density matrix $\\mathbf{P}^{(k+1)}$. If convergence is not achieved within $200$ iterations, the process is halted.\n\nThis entire procedure is applied to each of the four test cases specified in the problem statement to generate the required sequences of the coefficient $c_0$.",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Implements the RHF-SCF procedure for HeH+ in a minimal basis\n    and computes the evolution of the MO coefficients for four test cases.\n    \"\"\"\n    \n    # --- Problem Data ---\n    S = np.array([[1.0, 0.2],\n                  [0.2, 1.0]], dtype=np.float64)\n    \n    h = np.array([[-2.0, -0.2],\n                  [-0.2, -1.0]], dtype=np.float64)\n\n    # Two-electron repulsion integral (ERI) tensor in chemists' notation\n    # ERI[mu, nu, lam, sig] = (mu nu | lam sig)\n    ERI = np.zeros((2, 2, 2, 2), dtype=np.float64)\n    ERI[0, 0, 0, 0] = 1.0\n    ERI[1, 1, 1, 1] = 0.7\n    ERI[0, 0, 1, 1] = 0.6\n    ERI[1, 1, 0, 0] = 0.6\n    # From (01|01) = (01|10) = (10|01) = (10|10) = 0.2\n    ERI[0, 1, 0, 1] = 0.2\n    ERI[1, 0, 0, 1] = 0.2\n    ERI[0, 1, 1, 0] = 0.2\n    ERI[1, 0, 1, 0] = 0.2\n    \n    # SCF parameters\n    convergence_threshold = 1e-10\n    max_iterations = 200\n\n    # Test suite\n    test_cases = [\n        {'alpha': 0.0, 'c_initial': np.array([1.0, 0.0])},  # Case A\n        {'alpha': 0.0, 'c_initial': np.array([0.0, 1.0])},  # Case B\n        {'alpha': 0.5, 'c_initial': np.array([0.6, 0.8])},  # Case C\n        {'alpha': 0.9, 'c_initial': np.array([-0.7, 0.3])}, # Case D\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha = case['alpha']\n        c_unnorm = case['c_initial']\n        c0_sequence = []\n\n        # --- Step 0: Initialization ---\n        # S-normalize the initial guess vector\n        norm_sq = c_unnorm.T @ S @ c_unnorm\n        c_k = c_unnorm / np.sqrt(norm_sq)\n        \n        # Record the initial c0 value (rounded)\n        c0_sequence.append(c_k[0])\n\n        # Form initial density matrix\n        P_k = 2.0 * np.outer(c_k, c_k)\n\n        # --- SCF Iteration Loop ---\n        for i in range(max_iterations):\n            # Store old density for convergence check and mixing\n            P_old = P_k\n\n            # --- Step 1: Build Fock Matrix ---\n            # G_munu = sum_ls P_ls * [(munu|ls) - 0.5 * (mus|ln)]\n            # J[mu,nu] = sum_ls P_ls * (munu|ls)\n            J = np.einsum('ls,mnls-mn', P_old, ERI)\n            # K[mu,nu] = sum_ls P_ls * (mus|ln)\n            K = np.einsum('ls,msln-mn', P_old, ERI)\n            \n            G = J - 0.5 * K\n            F = h + G\n\n            # --- Step 2: Solve Generalized Eigenvalue Problem ---\n            # F c = e S c\n            # eigh returns S-normalized eigenvectors sorted by eigenvalue\n            eigvals, eigvecs = scipy.linalg.eigh(F, S)\n            \n            # Select eigenvector for the lowest energy orbital\n            c_k_plus_1 = eigvecs[:, 0]\n\n            # --- Step 3: Phase Convention ---\n            # Enforce sign consistency with the previous iteration's coefficients\n            overlap = c_k_plus_1.T @ S @ c_k\n            if overlap  0.0:\n                c_k_plus_1 *= -1.0\n            \n            # Record new c0 value\n            c0_sequence.append(c_k_plus_1[0])\n\n            # Update orbital coefficients for next phase check\n            c_k = c_k_plus_1\n\n            # --- Step 4: Update Density Matrix with Mixing ---\n            P_raw = 2.0 * np.outer(c_k, c_k)\n            P_k = (1.0 - alpha) * P_raw + alpha * P_old\n\n            # --- Step 5: Check for Convergence ---\n            max_diff = np.max(np.abs(P_k - P_old))\n            if max_diff  convergence_threshold:\n                break\n        \n        # Round all collected coefficients to 6 decimal places for final output\n        all_results.append([round(val, 6) for val in c0_sequence])\n\n    # Format the final output string as specified\n    formatted_cases = []\n    for case_results in all_results:\n        # Format each number to 6 decimal places.\n        formatted_nums = [f\"{val:.6f}\" for val in case_results]\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    final_output = f\"[{','.join(formatted_cases)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "After mastering the mechanics of the SCF procedure, this practice connects the abstract mathematics to tangible chemical intuition. By applying the SCF method to a model of a linear four-atom hydrogen chain, you will analyze the structure of the resulting molecular orbitals by counting their nodes . This exercise powerfully illustrates how the converged eigenvectors correspond to molecular orbitals with shapes and nodal patterns reminiscent of simple quantum models like the particle-in-a-box.",
            "id": "2465579",
            "problem": "Consider a linear chain of four hydrogen atoms modeled in a minimal, orthonormal atomic orbital basis $\\{|\\chi_1\\rangle,|\\chi_2\\rangle,|\\chi_3\\rangle,|\\chi_4\\rangle\\}$, where $|\\chi_i\\rangle$ is centered on atom $i$ arranged in order along the chain. Assume one spatial orbital per site, two spin states per spatial orbital, and a total of $4$ electrons (closed-shell, spin-restricted). Use a one-band Hubbard-type electronic structure model with the following components:\n\n- One-electron terms given by site energies $\\varepsilon_i$ (diagonal) and nearest-neighbor hopping $t_{i,i+1}$ (off-diagonal between $i$ and $i+1$), with all energies expressed in electronvolts (eV).\n- On-site electron repulsion parameters $U_i$ (in eV).\n- The Self-Consistent Field (SCF) problem is defined by the restricted Hartree–Fock mean-field fixed point in this basis. Let $D$ denote the spin-summed one-particle density matrix in the site basis, and $F(D)$ the corresponding Fock matrix. In the restricted Hartree–Fock approximation for the on-site-interaction Hubbard model, the Fock matrix is tridiagonal with\n  - $F_{ii}(D)=\\varepsilon_i + U_i\\,\\frac{n_i}{2}$ where $n_i=D_{ii}$ is the total site population,\n  - $F_{i,i+1}=F_{i+1,i}=t_{i,i+1}$ for nearest neighbors,\n  - all other matrix elements equal to $0$.\nThe spin-summed density matrix at self-consistency is $D = 2\\sum_{p\\in\\text{occ}} \\mathbf{c}_p \\mathbf{c}_p^\\top$, where $\\mathbf{c}_p$ are the orthonormal eigenvectors of $F(D)$ associated with the $2$ lowest eigenvalues (each doubly occupied), and the superscript $\\top$ denotes transpose.\n\nAfter convergence, the four canonical molecular orbitals are the four real normalized eigenvectors $\\mathbf{c}_1,\\mathbf{c}_2,\\mathbf{c}_3,\\mathbf{c}_4$ of the converged $F$, ordered by increasing orbital energy. For each molecular orbital, define the node count as the number of sign changes between consecutive coefficients along the chain:\nGiven $\\mathbf{c}=(c_1,c_2,c_3,c_4)$, its node count is the number of indices $i\\in\\{1,2,3\\}$ such that $c_i c_{i+1} \\le 0$. The overall phase of $\\mathbf{c}$ is arbitrary and does not affect the node count.\n\nTask: For each of the parameter sets below, compute the converged restricted Hartree–Fock solution as defined above and report, for the four canonical molecular orbitals in order of increasing orbital energy, the list of their node counts.\n\nAll energies must be taken in electronvolts (eV). The required outputs are integers (node counts), which are unitless.\n\nTest suite (each case specifies $(\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4)$, $(t_{12},t_{23},t_{34})$, and $(U_1,U_2,U_3,U_4)$):\n- Case A (symmetric interacting chain): $(0,0,0,0)$, $(-1.0,-1.0,-1.0)$, $(2.0,2.0,2.0,2.0)$.\n- Case B (symmetric non-interacting chain): $(0,0,0,0)$, $(-1.0,-1.0,-1.0)$, $(0.0,0.0,0.0,0.0)$.\n- Case C (asymmetric site energy at one end): $(0.5,0,0,0)$, $(-1.0,-1.0,-1.0)$, $(2.0,2.0,2.0,2.0)$.\n- Case D (non-uniform bonding): $(0,0,0,0)$, $(-1.5,-0.5,-1.0)$, $(2.0,2.0,2.0,2.0)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is itself a list of four integers giving the node counts for the four converged canonical molecular orbitals in order of increasing orbital energy. For example, an output with two hypothetical cases would look like $[[0,1,2,3],[0,1,1,2]]$.",
            "solution": "The problem presented is a valid and well-posed application of the self-consistent field (SCF) method within the restricted Hartree-Fock (RHF) approximation. It concerns a simplified but scientifically sound model of a linear chain of four hydrogen atoms, described by a one-band Hubbard-type Hamiltonian. All parameters, definitions, and objectives are clearly and objectively defined, allowing for a direct numerical solution.\n\nThe task is to solve the RHF equations for a $4$-site system with $4$ electrons (a closed-shell case). This involves finding a self-consistent solution for the one-particle density matrix, $D$, and the corresponding Fock matrix, $F(D)$. The solution will be obtained by implementing an iterative SCF procedure.\n\nLet the orthonormal atomic orbital basis be $\\{|\\chi_1\\rangle, |\\chi_2\\rangle, |\\chi_3\\rangle, |\\chi_4\\rangle\\}$. In this basis, the Fock matrix, $F$, and the density matrix, $D$, are represented as $4 \\times 4$ matrices.\n\nThe Fock matrix, $F$, is defined by its elements:\n$$\nF_{ij} = H^{\\text{core}}_{ij} + G_{ij}(D)\n$$\nwhere $H^{\\text{core}}$ contains the one-electron terms (site energies and hopping) and $G(D)$ contains the two-electron terms (electron-electron repulsion) in a mean-field sense.\n\nAccording to the problem statement:\n- The diagonal elements of the Fock matrix are given by $F_{ii}(D) = \\varepsilon_i + U_i \\frac{n_i}{2}$, where $\\varepsilon_i$ is the site energy, $U_i$ is the on-site repulsion parameter, and $n_i = D_{ii}$ is the electron population on site $i$.\n- The off-diagonal elements for nearest neighbors are $F_{i,i+1} = F_{i+1,i} = t_{i,i+1}$, where $t_{i,i+1}$ is the hopping integral.\n- All other off-diagonal elements are zero.\n\nThis defines a tridiagonal Fock matrix:\n$$\nF(D) = \\begin{pmatrix}\n\\varepsilon_1 + \\frac{U_1}{2}D_{11}  t_{12}  0  0 \\\\\nt_{12}  \\varepsilon_2 + \\frac{U_2}{2}D_{22}  t_{23}  0 \\\\\n0  t_{23}  \\varepsilon_3 + \\frac{U_3}{2}D_{33}  t_{34} \\\\\n0  0  t_{34}  \\varepsilon_4 + \\frac{U_4}{2}D_{44}\n\\end{pmatrix}\n$$\n\nThe SCF procedure is an iterative process to find a density matrix $D$ such that it is consistent with the Fock matrix it generates. The steps are as follows:\n\n1.  **Initialization**: An initial guess for the density matrix $D^{(0)}$ is required. A common and effective choice is to start from the solution of the non-interacting problem, which is equivalent to using the core Hamiltonian $H^{\\text{core}}$ (the Fock matrix with all $U_i = 0$) as the initial Fock matrix, $F^{(0)}$.\n\n2.  **Iterative Cycle**: For each iteration $k = 0, 1, 2, \\dots$:\n    a.  **Solve the Roothaan-Hall Equations**: Solve the eigenvalue problem for the current Fock matrix $F^{(k)}$:\n        $$\n        F^{(k)} \\mathbf{c}_p = \\epsilon_p \\mathbf{c}_p\n        $$\n        Since the basis is orthonormal, this is a standard matrix diagonalization. This yields four real eigenvalues $\\epsilon_p$ (the orbital energies) and four corresponding orthonormal eigenvectors $\\mathbf{c}_p$ (the molecular orbital coefficients). The eigenvectors are sorted in order of increasing eigenvalue: $\\epsilon_1 \\le \\epsilon_2 \\le \\epsilon_3 \\le \\epsilon_4$.\n\n    b.  **Construct New Density Matrix**: With $4$ electrons, the two lowest-energy spatial orbitals, $\\mathbf{c}_1$ and $\\mathbf{c}_2$, are doubly occupied. The new spin-summed density matrix, $D^{(\\text{new})}$, is constructed from these occupied orbitals:\n        $$\n        D^{(\\text{new})} = 2 \\sum_{p=1}^{2} \\mathbf{c}_p \\mathbf{c}_p^\\top\n        $$\n        In matrix form, if $C_{\\text{occ}}$ is the $4 \\times 2$ matrix whose columns are $\\mathbf{c}_1$ and $\\mathbf{c}_2$, then $D^{(\\text{new})} = 2 C_{\\text{occ}} C_{\\text{occ}}^\\top$.\n\n    c.  **Check for Convergence**: The process is converged when the density matrix no longer changes significantly between iterations. A convergence criterion is applied, such as checking if the maximum absolute difference between elements of the new and old density matrices is below a small tolerance, $\\delta$:\n        $$\n        \\max_{i,j} |D^{(\\text{new})}_{ij} - D^{(k)}_{ij}|  \\delta\n        $$\n        If converged, the loop terminates.\n\n    d.  **Prepare for Next Iteration**: If not converged, a new density matrix $D^{(k+1)}$ is formed. To prevent oscillations and improve convergence, simple mixing is often employed:\n        $$\n        D^{(k+1)} = \\alpha D^{(\\text{new})} + (1-\\alpha) D^{(k)}\n        $$\n        where $\\alpha$ is a mixing parameter ($0  \\alpha \\le 1$). A new Fock matrix $F^{(k+1)}$ is then constructed using the diagonal elements of $D^{(k+1)}$:\n        $$\n        F^{(k+1)}_{ii} = \\varepsilon_i + \\frac{U_i}{2} D^{(k+1)}_{ii}\n        $$\n\n3.  **Post-SCF Calculation**: Once the SCF procedure has converged to a final density matrix $D_{\\text{conv}}$ and Fock matrix $F_{\\text{conv}}$, the final canonical molecular orbitals $\\mathbf{c}_1, \\mathbf{c}_2, \\mathbf{c}_3, \\mathbf{c}_4$ are the eigenvectors of $F_{\\text{conv}}$, ordered by their corresponding energy eigenvalues. For each eigenvector $\\mathbf{c}_p = (c_{1p}, c_{2p}, c_{3p}, c_{4p})^\\top$, the node count is calculated. The node count is the number of sign changes between consecutive coefficients, defined as the number of indices $i \\in \\{1, 2, 3\\}$ for which the condition $c_{ip} c_{i+1,p} \\le 0$ holds. This procedure is applied to each of the four test cases.\n\nFor the non-interacting case (Case B, where all $U_i=0$), the Fock matrix is simply the core Hamiltonian and does not depend on the density. The SCF procedure converges in a single step. For the interacting cases (A, C, D), multiple iterations are generally required to reach self-consistency. The following implementation carries out this algorithm for each specified parameter set.",
            "answer": "```python\nimport numpy as np\n\ndef compute_node_count(vector: np.ndarray) - int:\n    \"\"\"\n    Computes the node count of a vector representing a molecular orbital.\n    A node is a sign change between consecutive coefficients.\n    The condition c_i * c_{i+1} = 0 includes cases where a coefficient is zero.\n    \"\"\"\n    count = 0\n    for i in range(len(vector) - 1):\n        if vector[i] * vector[i + 1] = 0:\n            count += 1\n    return count\n\ndef run_scf_procedure(eps: np.ndarray, t: np.ndarray, U: np.ndarray) - list[int]:\n    \"\"\"\n    Performs the self-consistent field (SCF) calculation for a 4-site Hubbard model.\n\n    Args:\n        eps: Array of site energies (4 elements).\n        t: Array of nearest-neighbor hopping integrals (3 elements).\n        U: Array of on-site repulsion parameters (4 elements).\n\n    Returns:\n        A list of four integers representing the node counts of the converged\n        canonical molecular orbitals, ordered by increasing energy.\n    \"\"\"\n    num_sites = 4\n    num_electrons = 4\n    num_occupied_orbitals = num_electrons // 2\n    \n    # Convergence parameters\n    tolerance = 1e-9\n    max_iterations = 200\n    mixing_alpha = 0.7  # Damping factor to aid convergence\n\n    # 1. Initialization: Build the core Hamiltonian (U=0 Fock matrix)\n    fock_matrix = np.diag(eps)\n    for i in range(num_sites - 1):\n        fock_matrix[i, i + 1] = fock_matrix[i + 1, i] = t[i]\n    \n    density_matrix = np.zeros((num_sites, num_sites))\n\n    for i in range(max_iterations):\n        # 2a. Solve eigenvalue problem for the current Fock matrix\n        # np.linalg.eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        # as columns of the matrix.\n        orbital_energies, orbital_coeffs = np.linalg.eigh(fock_matrix)\n\n        # 2b. Construct new density matrix from occupied orbitals\n        occupied_coeffs = orbital_coeffs[:, :num_occupied_orbitals]\n        new_density_matrix = 2.0 * (occupied_coeffs @ occupied_coeffs.T)\n\n        # 2c. Check for convergence\n        error = np.max(np.abs(new_density_matrix - density_matrix))\n        if error  tolerance:\n            break\n\n        # 2d. Prepare for next iteration: mix density matrices\n        density_matrix = mixing_alpha * new_density_matrix + (1.0 - mixing_alpha) * density_matrix\n        \n        # Update Fock matrix with the new density\n        fock_diag = eps + (U * np.diag(density_matrix)) / 2.0\n        np.fill_diagonal(fock_matrix, fock_diag)\n    \n    # 3. Post-SCF: Calculate node counts from the converged orbitals\n    # Re-diagonalize the final Fock matrix to get final canonical orbitals\n    final_energies, final_orbitals = np.linalg.eigh(fock_matrix)\n\n    node_counts = []\n    for i in range(num_sites):\n        orbital_vector = final_orbitals[:, i]\n        nodes = compute_node_count(orbital_vector)\n        node_counts.append(nodes)\n        \n    return node_counts\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the solution for each, printing the final result.\n    \"\"\"\n    # Test cases: (eps_array, t_array, U_array)\n    test_cases = [\n        # Case A: symmetric interacting chain\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n        # Case B: symmetric non-interacting chain\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([0.0, 0.0, 0.0, 0.0])),\n        # Case C: asymmetric site energy at one end\n        (np.array([0.5, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n        # Case D: non-uniform bonding\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.5, -0.5, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        eps_vals, t_vals, U_vals = case_params\n        result = run_scf_procedure(eps_vals, t_vals, U_vals)\n        results.append(str(result))\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The self-consistent field method, being a mean-field approximation, can sometimes yield solutions that seem counter-intuitive. This practice delves into the fascinating phenomenon of spontaneous symmetry breaking using a minimalist two-site model . You will discover how an SCF calculation for a perfectly symmetric molecular system can become \"trapped\" in an asymmetric solution, a crucial lesson on the nuances and potential artifacts of Hartree-Fock theory.",
            "id": "2465549",
            "problem": "You are asked to implement a minimal, fully self-contained Self-Consistent Field (SCF) simulation that captures how a symmetry-broken mean-field solution can emerge and trap the iteration for a symmetric double-well model. The model is a two-site system in a minimal basis $\\{\\phi_L,\\phi_R\\}$ representing localized functions on the left and right wells. Consider two electrons in a closed-shell configuration (one doubly occupied spatial orbital). All quantities are dimensionless.\n\nStarting point and definitions:\n- The one-electron core Hamiltonian $H_{\\mathrm{core}}$ in the $\\{\\phi_L,\\phi_R\\}$ basis is\n$$\nH_{\\mathrm{core}} \\;=\\; \\begin{pmatrix}\n0  -t \\\\\n-t  0\n\\end{pmatrix}, \\quad t0.\n$$\n- The mean-field (Fock-like) matrix is\n$$\nF[P] \\;=\\; H_{\\mathrm{core}} + V[P],\n$$\nwith a feedback term\n$$\nV[P] \\;=\\; \\begin{pmatrix}\n- g m  0 \\\\\n0  + g m\n\\end{pmatrix}, \\quad m \\equiv P_{LL} - P_{RR},\n$$\nwhere $P$ is the one-particle density matrix in the atomic-orbital basis. The scalar $g \\ge 0$ is a coupling strength controlling the nonlinear feedback. The population imbalance $m$ quantifies left-right asymmetry.\n- In a closed-shell, two-electron, one-orbital model, the density matrix is\n$$\nP \\;=\\; 2\\, \\mathbf{c}\\,\\mathbf{c}^{\\top}, \\qquad \\mathbf{c} = \\begin{pmatrix} c_L \\\\ c_R \\end{pmatrix}, \\quad \\|\\mathbf{c}\\|_2=1,\n$$\nwith $\\mathbf{c}$ the coefficient vector of the occupied molecular orbital in the $\\{\\phi_L,\\phi_R\\}$ basis. Thus $P_{LL} = 2 c_L^2$ and $P_{RR} = 2 c_R^2$, and $m = 2(c_L^2 - c_R^2)$.\n\nSCF iteration to implement:\n1. Initialize the occupied orbital coefficients $\\mathbf{c}^{(0)}$ from an imbalance seed $\\varepsilon$ by\n$$\n\\mathbf{c}^{(0)} \\;\\propto\\; \\begin{pmatrix} \\sqrt{0.5 + \\varepsilon} \\\\ \\sqrt{0.5 - \\varepsilon} \\end{pmatrix}, \\quad \\|\\mathbf{c}^{(0)}\\|_2=1,\n$$\nthen set $P^{(0)} = 2\\,\\mathbf{c}^{(0)} \\mathbf{c}^{(0)\\top}$.\n2. At iteration $k$, compute $m^{(k)} = P_{LL}^{(k)} - P_{RR}^{(k)}$, assemble $F^{(k)} = H_{\\mathrm{core}} + V[P^{(k)}]$, and solve the $2\\times 2$ eigenproblem to obtain the lowest-energy normalized eigenvector $\\mathbf{v}^{(k)}$.\n3. Form the new density $P_{\\mathrm{new}}^{(k)} = 2\\,\\mathbf{v}^{(k)}\\mathbf{v}^{(k)\\top}$.\n4. Apply linear density mixing with parameter $\\alpha \\in (0,1]$:\n$$\nP^{(k+1)} \\;=\\; (1-\\alpha)\\,P^{(k)} + \\alpha\\,P_{\\mathrm{new}}^{(k)}.\n$$\n5. Convergence criterion: stop if the Frobenius norm satisfies $\\|P^{(k+1)} - P^{(k)}\\|_{F}  \\tau$, or if the maximum number of iterations $N_{\\max}$ is reached. Report the final imbalance $m^{(\\mathrm{final})} = P_{LL}^{(\\mathrm{final})} - P_{RR}^{(\\mathrm{final})}$.\n\nYour task:\n- Implement the SCF iteration above.\n- For each test case listed below, run the SCF and return the final imbalance $m^{(\\mathrm{final})}$, rounded to six decimal places.\n- The purpose is to demonstrate that, for sufficiently strong feedback coupling $g$, the SCF can converge to and become trapped in a symmetry-broken solution with $m^{(\\mathrm{final})} \\neq 0$ even though $H_{\\mathrm{core}}$ is symmetric.\n\nTest suite (all parameters are dimensionless):\n1. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;0.2,\\;0.5,\\; +0.01,\\; 200,\\; 10^{-12})$.\n2. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;1.0,\\;0.5,\\; +0.001,\\; 200,\\; 10^{-12})$.\n3. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;1.0,\\;0.5,\\; -0.001,\\; 200,\\; 10^{-12})$.\n4. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;1.0,\\;0.5,\\; 0.0,\\; 200,\\; 10^{-12})$.\n5. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;0.51,\\;0.5,\\; +0.001,\\; 200,\\; 10^{-12})$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, e.g.,\n$$\n[\\text{m\\_final\\_1},\\text{m\\_final\\_2},\\text{m\\_final\\_3},\\text{m\\_final\\_4},\\text{m\\_final\\_5}],\n$$\nwhere each $\\text{m\\_final\\_i}$ is the final imbalance rounded to six decimal places and expressed as a floating-point number without any units.",
            "solution": "The problem presented is a valid and well-posed exercise in computational quantum chemistry. It is a minimalist yet instructive model for demonstrating the phenomenon of spontaneous symmetry breaking within the Self-Consistent Field (SCF) framework, a concept of central importance in many-body physics and chemistry. The problem is scientifically sound, its parameters are complete and consistent, and the procedure is algorithmically unambiguous. We shall therefore proceed with a full solution.\n\nThe problem asks for the implementation of an SCF procedure for a two-electron, two-site system described by a minimal basis of localized atomic orbitals, $\\{\\phi_L, \\phi_R\\}$. The goal is to find a self-consistent solution for the one-particle density matrix, $P$.\n\nThe core of the problem lies in the structure of the Fock-like matrix, $F[P]$, which determines the effective one-particle Hamiltonian:\n$$\nF[P] \\;=\\; H_{\\mathrm{core}} + V[P] \\;=\\; \\begin{pmatrix}\n0  -t \\\\\n-t  0\n\\end{pmatrix} + \\begin{pmatrix}\n- g m  0 \\\\\n0  + g m\n\\end{pmatrix} \\;=\\; \\begin{pmatrix}\n- g m  -t \\\\\n-t  + g m\n\\end{pmatrix}\n$$\nHere, $t  0$ is the kinetic hopping parameter that allows electrons to tunnel between the left ($L$) and right ($R$) sites, favoring delocalization. The term $V[P]$ represents a simplified electron-electron interaction, where the coupling parameter $g \\ge 0$ controls the strength of a nonlinear feedback mechanism. This feedback depends on the population imbalance, $m = P_{LL} - P_{RR}$. A non-zero imbalance, $m \\neq 0$, creates an effective potential difference between the two sites, with one site becoming more attractive ($-gm$) and the other more repulsive ($+gm$). This feedback mechanism energetically favors localization.\n\nThe competition between the delocalizing effect of $t$ and the localizing effect of $g$ is what gives rise to the interesting physics. The SCF procedure is an iterative method to find a stationary state of this system, where the density matrix $P$ that generates the Fock matrix $F[P]$ is, in turn, produced by the ground state eigenvector of that same $F[P]$.\n\nThe self-consistency condition for the imbalance $m$ can be derived. Given a Fock matrix constructed with an input imbalance $m_{\\mathrm{in}}$, its lowest-energy normalized eigenvector $\\mathbf{c} = (c_L, c_R)^\\top$ yields an output imbalance $m_{\\mathrm{out}} = 2(c_L^2 - c_R^2)$. The eigenvalues of $F[P]$ are $\\lambda_{\\pm} = \\pm \\sqrt{t^2 + (gm_{\\mathrm{in}})^2}$. The components of the eigenvector for the lowest eigenvalue, $\\lambda_{-} = -\\sqrt{t^2 + (gm_{\\mathrm{in}})^2}$, can be shown to satisfy:\n$$\nc_L^2 = \\frac{1}{2}\\left(1 + \\frac{gm_{\\mathrm{in}}}{\\sqrt{t^2+(gm_{\\mathrm{in}})^2}}\\right), \\quad c_R^2 = \\frac{1}{2}\\left(1 - \\frac{gm_{\\mathrm{in}}}{\\sqrt{t^2+(gm_{\\mathrm{in}})^2}}\\right)\n$$\nThis leads to the output imbalance:\n$$\nm_{\\mathrm{out}} = 2(c_L^2 - c_R^2) = \\frac{2gm_{\\mathrm{in}}}{\\sqrt{t^2+(gm_{\\mathrm{in}})^2}}\n$$\nA self-consistent solution is a fixed point of this map, i.e., $m = m_{\\mathrm{in}} = m_{\\mathrm{out}}$. This gives the equation:\n$$\nm = \\frac{2gm}{\\sqrt{t^2+(gm)^2}}\n$$\nOne trivial solution is always $m=0$. This corresponds to the symmetric state where the electron density is equally distributed ($c_L^2 = c_R^2 = 0.5$). If $m \\neq 0$, we can divide by $m$ to find other solutions:\n$$\n1 = \\frac{2g}{\\sqrt{t^2+(gm)^2}} \\implies t^2+g^2m^2 = (2g)^2 \\implies m^2 = \\frac{4g^2-t^2}{g^2} = 4 - \\left(\\frac{t}{g}\\right)^2\n$$\nThese symmetry-broken solutions, $m = \\pm \\sqrt{4 - (t/g)^2}$, are real and non-zero only if $g  t/2$. For $t=1.0$, this critical point is $g_c = 0.5$.\n- If $g \\le g_c$, only the symmetric solution $m=0$ exists.\n- If $g  g_c$, three solutions exist: the symmetric solution $m=0$ (which becomes unstable) and two stable, degenerate, symmetry-broken solutions $m \\neq 0$.\n\nThe SCF algorithm specified in the problem is a numerical procedure to find one of these stable solutions.\n\n**Algorithmic Steps:**\n\n1.  **Initialization**: We start with an initial guess for the orbital coefficients, $\\mathbf{c}^{(0)}$, defined by a small symmetry-breaking seed $\\varepsilon$. A positive $\\varepsilon$ slightly increases the population on the left site, and a negative $\\varepsilon$ does the opposite.\n    $$\n    \\mathbf{c}^{(0)} = \\begin{pmatrix} \\sqrt{0.5 + \\varepsilon} \\\\ \\sqrt{0.5 - \\varepsilon} \\end{pmatrix}\n    $$\n    This vector is already normalized as $(\\sqrt{0.5+\\varepsilon})^2 + (\\sqrt{0.5-\\varepsilon})^2 = 1.0$. The initial density matrix is $P^{(0)} = 2 \\mathbf{c}^{(0)}{\\mathbf{c}^{(0)}}^\\top$. This yields an initial imbalance $m^{(0)} = 2((0.5+\\varepsilon) - (0.5-\\varepsilon)) = 4\\varepsilon$.\n\n2.  **Iteration ($k$)**: The process proceeds iteratively.\n    - The imbalance $m^{(k)} = P_{LL}^{(k)} - P_{RR}^{(k)}$ is calculated.\n    - The Fock matrix $F^{(k)}$ is constructed using $m^{(k)}$, $t$, and $g$.\n    - The eigensystem of the $2 \\times 2$ Hermitian matrix $F^{(k)}$ is solved. This yields two eigenvalues and their corresponding eigenvectors. We select the eigenvector $\\mathbf{v}^{(k)}$ corresponding to the lowest eigenvalue.\n    - A new density matrix is constructed from this eigenvector: $P_{\\mathrm{new}}^{(k)} = 2 \\mathbf{v}^{(k)}{\\mathbf{v}^{(k)}}^\\top$.\n\n3.  **Density Mixing**: To stabilize convergence, the density matrix for the next iteration, $P^{(k+1)}$, is formed by linear mixing of the old and new densities:\n    $$\n    P^{(k+1)} = (1-\\alpha)P^{(k)} + \\alpha P_{\\mathrm{new}}^{(k)}\n    $$\n    The parameter $\\alpha \\in (0, 1]$ damps oscillations that can occur during the iteration.\n\n4.  **Convergence**: The loop continues until the change in the density matrix between successive iterations is smaller than a threshold $\\tau$, measured by the Frobenius norm $\\|P^{(k+1)} - P^{(k)}\\|_F$. The process also stops if a maximum number of iterations, $N_{\\max}$, is reached.\n\nThe final reported value is the imbalance $m^{(\\mathrm{final})}$ from the converged density matrix. This procedure will be implemented to solve for the given test cases. The expectation, based on our analysis, is that for $g  g_c=0.5$, the final state will depend on the sign of the initial seed $\\varepsilon$, converging to one of the two stable symmetry-broken solutions. For $g \\le g_c$, it will converge to the symmetric state $m=0$. The special case $\\varepsilon=0$ starts exactly on the unstable fixed point (for $g  g_c$) and should, in the absence of numerical noise, remain there.",
            "answer": "```python\nimport numpy as np\n\ndef run_scf(t, g, alpha, epsilon, n_max, tau):\n    \"\"\"\n    Performs a Self-Consistent Field (SCF) iteration for a two-site model.\n\n    Args:\n        t (float): Hopping parameter.\n        g (float): Coupling strength for nonlinear feedback.\n        alpha (float): Linear mixing parameter for density matrix update.\n        epsilon (float): Initial imbalance seed.\n        n_max (int): Maximum number of iterations.\n        tau (float): Convergence threshold for the Frobenius norm of the density matrix change.\n\n    Returns:\n        float: The final converged population imbalance 'm'.\n    \"\"\"\n    # 1. Initialization\n    # The problem statement ensures that c0 is already normalized.\n    c0_L = np.sqrt(0.5 + epsilon)\n    c0_R = np.sqrt(0.5 - epsilon)\n    c0 = np.array([c0_L, c0_R])\n    \n    # P = 2 * c * c^T. np.outer(c, c) computes c * c^T.\n    p_k = 2 * np.outer(c0, c0)\n\n    # Define the core Hamiltonian\n    h_core = np.array([[0.0, -t], [-t, 0.0]])\n\n    # 2. SCF Iteration Loop\n    for _ in range(n_max):\n        # Calculate imbalance 'm' from the current density matrix P_k\n        m_k = p_k[0, 0] - p_k[1, 1]\n        \n        # Assemble the Fock-like matrix F[P] = H_core + V[P]\n        # V[P] is a diagonal matrix with elements [-g*m, +g*m]\n        v_p = np.array([[-g * m_k, 0.0], [0.0, g * m_k]])\n        f_k = h_core + v_p\n        \n        # Solve the 2x2 eigenproblem for F_k\n        # numpy.linalg.eigh is for Hermitian matrices and sorts eigenvalues in ascending order.\n        eigenvalues, eigenvectors = np.linalg.eigh(f_k)\n        \n        # The lowest-energy eigenvector is the first column of the eigenvectors matrix.\n        v_k = eigenvectors[:, 0]\n        \n        # Form the new density matrix P_new\n        p_new = 2 * np.outer(v_k, v_k)\n        \n        # Apply linear density mixing\n        p_k_plus_1 = (1 - alpha) * p_k + alpha * p_new\n        \n        # Check for convergence using the Frobenius norm of the difference matrix\n        diff_norm = np.linalg.norm(p_k_plus_1 - p_k, 'fro')\n        \n        # Update the density matrix for the next iteration\n        p_k = p_k_plus_1\n        \n        if diff_norm  tau:\n            break\n            \n    # After the loop, calculate the final imbalance from the converged density matrix\n    m_final = p_k[0, 0] - p_k[1, 1]\n    \n    return m_final\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (t, g, alpha, epsilon, n_max, tau)\n    test_cases = [\n        (1.0, 0.2, 0.5, +0.01, 200, 1e-12),\n        (1.0, 1.0, 0.5, +0.001, 200, 1e-12),\n        (1.0, 1.0, 0.5, -0.001, 200, 1e-12),\n        (1.0, 1.0, 0.5, 0.0, 200, 1e-12),\n        (1.0, 0.51, 0.5, +0.001, 200, 1e-12),\n    ]\n\n    results = []\n    for params in test_cases:\n        t, g, alpha, epsilon, n_max, tau = params\n        m_final = run_scf(t, g, alpha, epsilon, n_max, tau)\n        # Round the result to six decimal places as requested.\n        results.append(round(m_final, 6))\n\n    # Format the final output as a comma-separated list in square brackets.\n    # Using f-string formatting to ensure standard float representation.\n    results_str = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}