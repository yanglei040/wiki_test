{
    "hands_on_practices": [
        {
            "introduction": "分子绕单键旋转时的能量变化并非杂乱无章，而是遵循一种周期性规律。我们可以使用傅里叶级数这一强大的数学工具来精确描述这种势能曲线。通过这个练习 ，你将亲手构建一个简化的扭转势能模型，理解级数中不同周期项（$n=1, 2, 3...$）如何对应于物理对称性，以及它们如何共同决定了旋转能垒的高度。",
            "id": "2453297",
            "problem": "要求您在一个统一的纯数学扭转模型中，比较两种小分子中心键的旋转能垒。对每种分子，关于指定二面角 $\\phi$（单位为度）的扭转势能由截断傅里叶级数表示：\n$$\nE(\\phi) \\;=\\; \\sum_{k=1}^{K} V_{n_k} \\,\\bigl(1 - \\cos(n_k \\,\\phi)\\bigr),\n$$\n其中 $n_k$ 是正整数，$V_{n_k}$ 是非负实系数，单位为 $\\mathrm{kJ\\,mol^{-1}}$。对于给定的分子，旋转能垒 $\\Delta E$ 定义为：\n$$\n\\Delta E \\;=\\; \\max_{\\phi \\in [0^\\circ,\\,360^\\circ)} E(\\phi) \\;-\\; \\min_{\\phi \\in [0^\\circ,\\,360^\\circ)} E(\\phi),\n$$\n并且必须以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位表示。\n\n您将需要为每个测试用例计算差值：\n$$\n\\Delta \\;=\\; \\Delta E_{\\mathrm{DMDS}} \\;-\\; \\Delta E_{\\text{DMPO}},\n$$\n其中 $\\Delta E_{\\mathrm{DMDS}}$ 是二甲基二硫醚中 $\\,\\mathrm{C\\!-\\!S\\!-\\!S\\!-\\!C}\\,$ 扭转的旋转能垒，$\\Delta E_{\\text{DMPO}}$ 是过氧化二甲醚中 $\\,\\mathrm{C\\!-\\!O\\!-\\!O\\!-\\!C}\\,$ 扭转的旋转能垒，两者均由上述相同的函数形式 $E(\\phi)$ 及其分子特定的参数集建模。\n\n角度输入必须以度为单位，$\\phi \\in [0^\\circ,\\,360^\\circ)$，能量必须以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位。报告每个 $\\Delta$ 值，并四舍五入到3位小数。\n\n测试套件：\n对于每个测试用例，提供两组参数集：一组用于二甲基二硫醚 (DMDS)，另一组用于过氧化二甲醚。每组参数集是一个有限的数对 $(n, V)$ 列表，表示项 $V\\,(1-\\cos(n\\,\\phi))$ 对 $E(\\phi)$ 有贡献。\n\n- 测试用例1（一般比较）：\n  - DMDS 项：`[(1, 10.0)]`。\n  - 过氧化二甲醚 项：`[(1, 8.0)]`。\n\n- 测试用例2（相等情况）：\n  - DMDS 项：`[(1, 5.0)]`。\n  - 过氧化二甲醚 项：`[(1, 5.0)]`。\n\n- 测试用例3（零能垒与非零能垒的边界情况）：\n  - DMDS 项：`[]`（无项，表示对所有 $\\phi$ 都有 $E(\\phi) = 0$）。\n  - 过氧化二甲醚 项：`[(2, 3.0)]`。\n\n- 测试用例4（奇次谐波多项比较）：\n  - DMDS 项：`[(1, 6.0), (3, 2.0)]`。\n  - 过氧化二甲醚 项：`[(1, 4.0), (3, 1.0)]`。\n\n要求的最终输出格式：\n您的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是对应测试用例的标量 $\\Delta$ 值，四舍五入到3位小数，例如：\n$$\n[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4].\n$$",
            "solution": "我们使用截断傅里叶级数来模拟单键周围的扭转旋转：\n$$\nE(\\phi)\\;=\\;\\sum_{k=1}^{K} V_{n_k}\\,\\bigl(1-\\cos(n_k\\,\\phi)\\bigr),\n$$\n其中 $\\phi$ 的单位是度，$V_{n_k}$ 的单位是 $\\mathrm{kJ\\,mol^{-1}}$。这种函数形式源于二面角旋转的对称性和周期性，其中整次谐波 $n_k$ 编码了空间位阻和电子相互作用的周期性。根据定义，旋转能垒 $\\Delta E$ 为：\n$$\n\\Delta E \\;=\\; \\max_{\\phi\\in[0^\\circ,360^\\circ)} E(\\phi) \\;-\\; \\min_{\\phi\\in[0^\\circ,360^\\circ)}E(\\phi),\n$$\n它捕捉了沿完整 $360^\\circ$ 旋转路径上最高过渡态相对于全局最小值的能量高度。\n\n所选形式的关键性质：\n- 对任意整数 $n_k$ 和非负系数 $V_{n_k}$，项 $V_{n_k}(1-\\cos(n_k\\phi))$ 始终大于等于零。在 $\\phi=0^\\circ$ 时，每个 $\\cos(n_k\\phi)=1$，因此 $E(0^\\circ)=0$。这表明总能量 $E(\\phi)$ 的全局最小值 $E_{\\min}$ 就是 $0$。\n- 单个项 $V_{n_k}(1-\\cos(n_k\\phi))$ 的最大值为 $2V_{n_k}$，出现在 $\\cos(n_k\\phi)=-1$ 时。当势能由多个项加和而成时，其最大值等于各项最大值之和（即 $E_{\\max}=2\\sum_k V_{n_k}$）的条件是：存在一个角度 $\\phi$ 能同时使所有项达到最大值。\n- **仅含奇次谐波**：如果所有 $n_k$ 均为奇数，在 $\\phi=180^\\circ$ 时，所有项都同时达到最大值，因为对任何奇数 $n_k$，$\\cos(n_k \\cdot 180^\\circ)=-1$。此时能垒为 $\\Delta E = E_{\\max} - E_{\\min} = 2 \\sum_{\\text{奇数 } n_k} V_{n_k}$。\n- **仅含单一偶次谐波**：如果只有一个偶次谐波项（例如 $n_k=2$），其最大值 $2V_{n_k}$ 会在 $\\cos(n_k\\phi)=-1$ 时出现（例如 $n_k=2$ 时在 $\\phi=90^\\circ$）。此时能垒为 $\\Delta E = 2V_{n_k}$。\n- 当混合了不同类型的谐波时，找到最大值通常需要进行数值搜索。本测试套件中的用例都经过精心设计，属于上述可以通过解析推理求解的简单情况。\n\n我们现在评估每个测试用例。\n\n- 测试用例1：\n  - DMDS：项 `[(1, 10.0)]`。只有 $n=1$ 的奇次谐波有贡献，所以\n    $$\n    \\Delta E_{\\mathrm{DMDS}} \\;=\\; 2\\,V_1 \\;=\\; 2\\times 10.0 \\;=\\; 20.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n  - 过氧化二甲醚：项 `[(1, 8.0)]`，只有 $n=1$ 的奇次谐波，因此\n    $$\n    \\Delta E_{\\text{DMPO}} \\;=\\; 2\\,V_1 \\;=\\; 2\\times 8.0 \\;=\\; 16.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n  - 差值：\n    $$\n    \\Delta \\;=\\; 20.0 - 16.0 \\;=\\; 4.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n\n- 测试用例2：\n  - DMDS：项 `[(1, 5.0)]`，仅奇次谐波，所以 $\\Delta E_{\\mathrm{DMDS}} = 2\\times 5.0 = 10.0\\;\\mathrm{kJ\\,mol^{-1}}$。\n  - 过氧化二甲醚：项 `[(1, 5.0)]`，仅奇次谐波，所以 $\\Delta E_{\\text{DMPO}} = 2\\times 5.0 = 10.0\\;\\mathrm{kJ\\,mol^{-1}}$。\n  - 差值：\n    $$\n    \\Delta \\;=\\; 10.0 - 10.0 \\;=\\; 0.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n\n- 测试用例3：\n  - DMDS：无项，$E(\\phi)=0$ 对所有 $\\phi$ 成立，所以 $\\Delta E_{\\mathrm{DMDS}}=0.0\\;\\mathrm{kJ\\,mol^{-1}}$。\n  - 过氧化二甲醚：项 `[(2, 3.0)]`，仅单一偶次谐波，所以 $\\Delta E_{\\text{DMPO}} = 2\\times 3.0 = 6.0\\;\\mathrm{kJ\\,mol^{-1}}$。\n  - 差值：\n    $$\n    \\Delta \\;=\\; 0.0 - 6.0 \\;=\\; -6.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n\n- 测试用例4：\n  - DMDS：项 `[(1, 6.0), (3, 2.0)]`，两者均为奇次谐波，所以\n    $$\n    \\Delta E_{\\mathrm{DMDS}} \\;=\\; 2\\,(6.0 + 2.0) \\;=\\; 16.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n  - 过氧化二甲醚：项 `[(1, 4.0), (3, 1.0)]`，两者均为奇次谐波，所以\n    $$\n    \\Delta E_{\\text{DMPO}} \\;=\\; 2\\,(4.0 + 1.0) \\;=\\; 10.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n  - 差值：\n    $$\n    \\Delta \\;=\\; 16.0 - 10.0 \\;=\\; 6.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n\n将四舍五入到3位小数的差值按要求格式收集起来，得到：\n$$\n[4.000,0.000,-6.000,6.000].\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef torsion_energy(phi_deg: np.ndarray, terms):\n    \"\"\"\n    Compute E(phi) = sum V_n * (1 - cos(n * phi))\n    phi_deg: numpy array of angles in degrees\n    terms: list of (n, V) pairs, with n integer, V in kJ/mol\n    Returns: numpy array E(phi) in kJ/mol\n    \"\"\"\n    if not terms:\n        return np.zeros_like(phi_deg, dtype=float)\n    phi_rad = np.deg2rad(phi_deg)\n    E = np.zeros_like(phi_rad, dtype=float)\n    for n, V in terms:\n        E += V * (1.0 - np.cos(n * phi_rad))\n    return E\n\ndef rotational_barrier(terms):\n    \"\"\"\n    Rotational barrier Delta E = max_phi E(phi) - min_phi E(phi)\n    with phi in [0, 360) degrees.\n    \"\"\"\n    # Dense grid to capture maxima/minima reliably\n    phi_grid = np.linspace(0.0, 360.0, 36001, endpoint=False)  # 0.01-degree resolution\n    E = torsion_energy(phi_grid, terms)\n    return float(E.max() - E.min())\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (terms_DMDS, terms_DMPO)\n    # terms is a list of (n, V_kJmol) pairs.\n    test_cases = [\n        ([(1, 10.0)], [(1, 8.0)]),                  # Test 1\n        ([(1, 5.0)], [(1, 5.0)]),                   # Test 2\n        ([], [(2, 3.0)]),                           # Test 3\n        ([(1, 6.0), (3, 2.0)], [(1, 4.0), (3, 1.0)])# Test 4\n    ]\n\n    results = []\n    for terms_dmds, terms_dmpo in test_cases:\n        barrier_dmds = rotational_barrier(terms_dmds)\n        barrier_dmpo = rotational_barrier(terms_dmpo)\n        delta = barrier_dmds - barrier_dmpo\n        results.append(f\"{delta:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "分子的稳定构象通常是多种相互竞争作用力之间“权衡”的结果。这个实践将带你探索一个经典的权衡案例：电子效应与空间位阻的博弈。通过构建一个联苯类分子的简化模型 ，你将直观地看到改变中心键长（如 C-C 键与 Si-Si 键的对比）如何打破这种平衡，从而决定分子的最终扭转角度。",
            "id": "2453243",
            "problem": "要求您模拟用硅-硅键取代联苯中的中心碳-碳键，如何影响两个环之间的扭转势和优选扭转角。考虑一个粗粒化分子内能量模型，该模型解析了围绕中心键的二面角 $\\phi$ 以及两个相对的邻-邻位空间位阻位点（每个环上各一个），这些位点在以键轴为中心的共轴圆上移动。总势能作为二面角 $\\phi$（单位为弧度）的函数定义为\n$$\nV_{\\text{tot}}(\\phi) \\;=\\; V_{\\text{tors}}(\\phi) \\;+\\; N \\, V_{\\text{rep}}(d(\\phi)) \\, ,\n$$\n其中 $N$ 是相同空间位阻相互作用对的数量，$V_{\\text{tors}}(\\phi)$ 是捕捉共轭偏好的扭转项，$V_{\\text{rep}}(d)$ 是作为位点间距离 $d$ 的函数的纯排斥非键项，而 $d(\\phi)$ 是当环旋转时两个空间位阻位点之间的几何距离。\n\n使用以下形式和定义。\n\n1) 扭转项：\n$$\nV_{\\text{tors}}(\\phi) \\;=\\; k_2 \\,\\bigl(1 - \\cos(2\\phi)\\bigr) \\, ,\n$$\n其中 $k_2$ 的单位为千焦耳/摩尔 (kJ/mol)。\n\n2) 空间位阻位点的几何结构：设每个空间位阻位点位于半径为 $a$（单位为埃斯特朗，Å）的圆上，该圆围绕键轴，两个环由轴向距离 $h$（单位为 Å）分隔。位点间距离作为 $\\phi$ 的函数为\n$$\nd(\\phi) \\;=\\; \\sqrt{\\, h^2 + 2 a^2 \\bigl(1 - \\cos \\phi \\bigr) \\,} \\, .\n$$\n\n3) 排斥性非键相互作用：使用从 Lennard–Jones $12$–$6$ 势推导出的 Weeks–Chandler–Andersen (WCA) 排斥形式，其参数为 $\\varepsilon$（单位为 kJ/mol）和 $\\sigma$（单位为 Å）：\n$$\nV_{\\text{WCA}}(d) \\;=\\; \n\\begin{cases}\n4\\varepsilon \\left[ \\left(\\dfrac{\\sigma}{d}\\right)^{12} - \\left(\\dfrac{\\sigma}{d}\\right)^{6} \\right] + \\varepsilon \\,, & d \\le d_c \\\\\n0 \\,, & d > d_c\n\\end{cases}\n\\quad \\text{with} \\quad d_c \\;=\\; 2^{1/6} \\sigma \\, .\n$$\n设 $V_{\\text{rep}}(d) = V_{\\text{WCA}}(d)$。\n\n对于下面指定的每个参数集，确定在 $\\phi \\in [0,\\pi]$ 范围内使 $V_{\\text{tot}}(\\phi)$ 最小化的优选扭转角 $\\phi^\\star$，以及定义为如下的扭转势垒高度 $\\Delta V$\n$$\n\\Delta V \\;=\\; \\max_{\\phi \\in [0,\\pi]} V_{\\text{tot}}(\\phi) \\;-\\; \\min_{\\phi \\in [0,\\pi]} V_{\\text{tot}}(\\phi) \\, .\n$$\n\n角度单位要求：以度为单位报告 $\\phi^\\star$。能量单位要求：以千焦耳/摩尔为单位报告 $\\Delta V$。\n\n舍入要求：报告的 $\\phi^\\star$ 四舍五入到一位小数，$\\Delta V$ 四舍五-入到三位小数。\n\n测试套件（每个案例为 $(k_2,\\varepsilon,\\sigma,a,h,N)$，长度单位为 Å，能量单位为 kJ/mol）：\n- 案例 A（类联苯，中心 C–C 键）：$(2.5,\\, 0.15,\\, 2.4,\\, 2.1,\\, 1.47,\\, 2)$。\n- 案例 B（类二苯基乙硅烷，中心 Si–Si 键）：$(0.5,\\, 0.15,\\, 2.4,\\, 2.3,\\, 2.34,\\, 2)$。\n- 案例 C（无空间位阻排斥）：$(1.2,\\, 0.0,\\, 2.4,\\, 2.0,\\, 1.47,\\, 2)$。\n- 案例 D（强空间位阻拥挤）：$(0.5,\\, 0.3,\\, 2.4,\\, 2.5,\\, 1.2,\\, 2)$。\n\n您的程序必须为每个案例计算对 $(\\phi^\\star,\\Delta V)$，根据上述定义，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序汇总所有案例的结果，格式为 $[\\phi^\\star_{\\text{A}},\\Delta V_{\\text{A}},\\phi^\\star_{\\text{B}},\\Delta V_{\\text{B}},\\phi^\\star_{\\text{C}},\\Delta V_{\\text{C}},\\phi^\\star_{\\text{D}},\\Delta V_{\\text{D}}]$。角度必须以度为单位（四舍五入到一位小数），能量必须以千焦耳/摩尔为单位（四舍五入到三位小数）。不应打印任何其他文本。",
            "solution": "该问题要求对于给定的分子内势能函数 $V_{\\text{tot}}(\\phi)$，确定优选扭转角 $\\phi^\\star$ 和扭转势垒高度 $\\Delta V$。必须对四个不同的参数集进行分析。\n\n总势能由一个扭转项和一个空间位阻排斥项之和给出：\n$$\nV_{\\text{tot}}(\\phi) = V_{\\text{tors}}(\\phi) + N V_{\\text{rep}}(d(\\phi))\n$$\n分析将在二面角的指定域 $\\phi \\in [0, \\pi]$ 弧度上进行。\n\n分量函数定义如下：\n1.  **扭转势：** $V_{\\text{tors}}(\\phi) = k_2 (1 - \\cos(2\\phi))$。该项模拟了对平面性的电子偏好。对于 $k_2 > 0$，它在 $\\phi=0$ 和 $\\phi=\\pi$（对应共平面构象）处有最小值，在 $\\phi=\\pi/2$（垂直构象）处有最大值。\n\n2.  **位点间距离：** $d(\\phi) = \\sqrt{h^2 + 2a^2(1 - \\cos\\phi)}$。该函数给出了两个相对的空间位阻位点之间的距离。距离在 $\\phi=0$ 时最小（$d(0)=h$），在 $\\phi=\\pi$ 时最大（$d(\\pi)=\\sqrt{h^2+4a^2}$）。\n\n3.  **排斥势：** Weeks–Chandler–Andersen (WCA) 势，$V_{\\text{rep}}(d) = V_{\\text{WCA}}(d)$，定义为：\n    $$\n    V_{\\text{WCA}}(d) = \n    \\begin{cases}\n    4\\varepsilon \\left[ \\left(\\dfrac{\\sigma}{d}\\right)^{12} - \\left(\\dfrac{\\sigma}{d}\\right)^{6} \\right] + \\varepsilon \\,, & d \\le d_c \\\\\n    0 \\,, & d > d_c\n    \\end{cases}\n    $$\n    其中 $d_c = 2^{1/6}\\sigma$。WCA 势是 Lennard-Jones 势的排斥部分，并经过移位以使对于所有 $d$ 都有 $V_{\\text{WCA}}(d) \\ge 0$。因此，总势能 $V_{\\text{tot}}(\\phi)$ 也是非负的，因为 $V_{\\text{tors}}(\\phi) \\ge 0$。\n\n需要确定的量是：\n-   优选扭转角 $\\phi^\\star$，即在 $[0, \\pi]$ 范围内使 $V_{\\text{tot}}(\\phi)$ 最小化的 $\\phi$ 值。\n-   扭转势垒高度 $\\Delta V = \\max_{\\phi \\in [0,\\pi]} V_{\\text{tot}}(\\phi) - \\min_{\\phi \\in [0,\\pi]} V_{\\text{tot}}(\\phi)$。\n\n求解策略是在紧区间 $[0, \\pi]$ 上对 $V_{\\text{tot}}(\\phi)$ 的最小值和最大值进行数值搜索。这将通过将区间离散化为一个精细的点网格并在每个点上对函数求值来完成。对于一维问题，这种直接搜索方法是稳健的。\n\n对于存在空间位阻排斥的情况（$\\varepsilon > 0$），可以得出一个重要的解析观察。在 $\\phi=\\pi$ 处：\n-   $V_{\\text{tors}}(\\pi) = k_2(1 - \\cos(2\\pi)) = 0$。\n-   位点间距离为 $d(\\pi) = \\sqrt{h^2 + 4a^2}$。对于所有提供的参数集（A、B、D），直接计算表明 $d(\\pi) > d_c = 2^{1/6}\\sigma$。\n-   由于 $d(\\pi) > d_c$，排斥势 $V_{\\text{rep}}(d(\\pi))$ 为零。\n-   因此，$V_{\\text{tot}}(\\pi) = 0$。\n\n由于已确定对于所有 $\\phi$ 都有 $V_{\\text{tot}}(\\phi) \\ge 0$，因此值 $V_{\\text{tot}}(\\pi) = 0$ 代表一个全局最小值。因此，对于案例 A、B 和 D，优选角明确为 $\\phi^\\star = \\pi$ 弧度，即 $180.0$ 度。\n\n对于案例 C，$\\varepsilon=0$，所以对于所有 $d$，都有 $V_{\\text{rep}}(d) = 0$。势是纯扭转的：$V_{\\text{tot}}(\\phi) = k_2 (1 - \\cos(2\\phi))$。该函数在 $\\phi=0$ 和 $\\phi=\\pi$ 处有最小值，此时 $V_{\\text{tot}}=0$。按照惯例，我们选择最小的非负角，所以 $\\phi^\\star=0.0$ 度。\n\n计算过程如下：\n\n**案例 A：类联苯 (C–C)**\n参数：$(k_2, \\varepsilon, \\sigma, a, h, N) = (2.5, 0.15, 2.4, 2.1, 1.47, 2)$。\n-   $\\phi^\\star = 180.0^\\circ$。\n-   $V_{\\text{min}} = V_{\\text{tot}}(\\pi) = 0$ kJ/mol。\n-   由于严重的位阻碰撞（$h=1.47\\,\\text{Å} < d_c \\approx 2.694\\,\\text{Å}$），势的最大值出现在 $\\phi=0$ 处。\n    $V_{\\text{max}} = V_{\\text{tot}}(0) = 2 \\times V_{\\text{WCA}}(1.47)$。\n    $V_{\\text{WCA}}(1.47) = 4(0.15)\\left[ \\left(\\frac{2.4}{1.47}\\right)^{12} - \\left(\\frac{2.4}{1.47}\\right)^{6} \\right] + 0.15 \\approx 215.694$ kJ/mol。\n    $V_{\\text{max}} \\approx 2 \\times 215.694 = 431.389$ kJ/mol。\n-   $\\Delta V = V_{\\text{max}} - V_{\\text{min}} = 431.389$ kJ/mol。\n\n**案例 B：类二苯基乙硅烷 (Si–Si)**\n参数：$(k_2, \\varepsilon, \\sigma, a, h, N) = (0.5, 0.15, 2.4, 2.3, 2.34, 2)$。\n-   $\\phi^\\star = 180.0^\\circ$。\n-   $V_{\\text{min}} = V_{\\text{tot}}(\\pi) = 0$ kJ/mol。\n-   在 $\\phi=0$ 处的势为 $V_{\\text{tot}}(0) \\approx 0.524$ kJ/mol。扭转势的最大值在 $\\phi=\\pi/2$ 处，值为 $V_{\\text{tors}}(\\pi/2) = 2k_2 = 1.0$ kJ/mol。在此角度，$d(\\pi/2) \\approx 4.007\\,\\text{Å} > d_c$，所以 $V_{\\text{rep}}=0$。因此全局最大值为 $V_{\\text{max}} = V_{\\text{tot}}(\\pi/2) = 1.0$ kJ/mol。\n-   $\\Delta V = V_{\\text{max}} - V_{\\text{min}} = 1.000$ kJ/mol。\n\n**案例 C：无空间位阻排斥**\n参数：$(k_2, \\varepsilon, \\sigma, a, h, N) = (1.2, 0.0, 2.4, 2.0, 1.47, 2)$。\n-   $V_{\\text{tot}}(\\phi) = 1.2(1 - \\cos(2\\phi))$。\n-   最小值在 $\\phi=0$ 和 $\\phi=\\pi$。我们选择 $\\phi^\\star = 0.0^\\circ$。\n-   $V_{\\text{min}} = 0$ kJ/mol。\n-   最大值在 $\\phi=\\pi/2$，此时 $V_{\\text{max}} = 1.2(1 - (-1)) = 2.4$ kJ/mol。\n-   $\\Delta V = V_{\\text{max}} - V_{\\text{min}} = 2.400$ kJ/mol。\n\n**案例 D：强空间位阻拥挤**\n参数：$(k_2, \\varepsilon, \\sigma, a, h, N) = (0.5, 0.3, 2.4, 2.5, 1.2, 2)$。\n-   $\\phi^\\star = 180.0^\\circ$。\n-   $V_{\\text{min}} = V_{\\text{tot}}(\\pi) = 0$ kJ/mol。\n-   由于极端的位阻排斥（$h=1.2\\,\\text{Å} \\ll d_c$），最大值出现在 $\\phi=0$ 处。\n    $V_{\\text{max}} = V_{\\text{tot}}(0) = 2 \\times V_{\\text{WCA}}(1.2)$。\n    $V_{\\text{WCA}}(1.2) = 4(0.3)\\left[ \\left(\\frac{2.4}{1.2}\\right)^{12} - \\left(\\frac{2.4}{1.2}\\right)^{6} \\right] + 0.3 = 1.2(2^{12} - 2^6)+0.3 = 4838.7$ kJ/mol。\n    $V_{\\text{max}} = 2 \\times 4838.7 = 9677.4$ kJ/mol。\n-   $\\Delta V = V_{\\text{max}} - V_{\\text{min}} = 9677.400$ kJ/mol。\n\n这些结果是通过数值计算得出的，以确保符合问题规范的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Solves the conformational analysis problem for four test cases.\n    \"\"\"\n    \n    # Test cases are given as tuples of (k2, epsilon, sigma, a, h, N)\n    # Units are kJ/mol for energies and Angstroms for lengths.\n    test_cases = [\n        # Case A (biphenyl-like, C-C)\n        (2.5, 0.15, 2.4, 2.1, 1.47, 2),\n        # Case B (diphenyl-disilane-like, Si-Si)\n        (0.5, 0.15, 2.4, 2.3, 2.34, 2),\n        # Case C (no steric repulsion)\n        (1.2, 0.0, 2.4, 2.0, 1.47, 2),\n        # Case D (strong steric crowding)\n        (0.5, 0.3, 2.4, 2.5, 1.2, 2)\n    ]\n\n    results = []\n    for params in test_cases:\n        phi_star_deg, delta_v = calculate_potential_properties(params)\n        results.extend([phi_star_deg, delta_v])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_potential_properties(params):\n    \"\"\"\n    Calculates the preferred twist angle (phi_star) and torsional barrier (delta_v)\n    for a given set of potential parameters.\n\n    Args:\n        params (tuple): A tuple containing (k2, eps, sigma, a, h, N).\n\n    Returns:\n        tuple: A tuple containing (phi_star_deg, delta_v) rounded as required.\n    \"\"\"\n    k2, eps, sigma, a, h, N = params\n    \n    # The cutoff distance for the WCA potential\n    d_c = 2**(1/6) * sigma\n\n    # Create a fine grid for the dihedral angle phi from 0 to pi.\n    # A high number of points ensures accuracy for finding optima.\n    phi_rad = np.linspace(0, np.pi, 20001)\n\n    # Calculate the torsional potential term V_tors(phi)\n    v_tors = k2 * (1 - np.cos(2 * phi_rad))\n\n    # Calculate the inter-site distance d(phi)\n    d = np.sqrt(h**2 + 2 * a**2 * (1 - np.cos(phi_rad)))\n\n    # Calculate the WCA repulsive potential V_rep(d)\n    # Initialize v_rep array with zeros.\n    v_rep = np.zeros_like(d)\n    \n    # Create a boolean mask for distances within the WCA cutoff\n    mask = d <= d_c\n    \n    # Only calculate potential for distances where it's non-zero\n    # to avoid unnecessary computation and potential warnings.\n    d_sub = d[mask]\n    if d_sub.size > 0:\n        # Ratio sigma/d for the relevant points\n        ratio = sigma / d_sub\n        v_rep[mask] = 4 * eps * (ratio**12 - ratio**6) + eps\n\n    # Calculate the total potential energy V_tot(phi)\n    v_total = v_tors + N * v_rep\n\n    # Find the minimum and maximum of the total potential energy\n    v_min = np.min(v_total)\n    v_max = np.max(v_total)\n\n    # Find the index of the minimum to get the corresponding angle phi_star\n    min_idx = np.argmin(v_total)\n    phi_star_rad = phi_rad[min_idx]\n    \n    # Convert phi_star to degrees\n    phi_star_deg = np.rad2deg(phi_star_rad)\n\n    # Calculate the torsional barrier height\n    delta_v = v_max - v_min\n\n    # Round the results to the specified number of decimal places\n    phi_star_deg_rounded = round(phi_star_deg, 1)\n    delta_v_rounded = round(delta_v, 3)\n\n    return phi_star_deg_rounded, delta_v_rounded\n\n# Run the solver\nsolve()\n```"
        },
        {
            "introduction": "对于拥有许多可旋转化学键的复杂分子，其可能构象的数量会达到天文数字，这便是所谓的“维度灾难”。这使得寻找能量最低的全局最优构象成为一项巨大的挑战。本练习  将让你比较两种核心的搜索算法——系统性的“蛮力”网格搜索和更高效的蒙特卡洛随机搜索，从而揭示为何对于像环癸烷这样的复杂分子，随机采样是探索其广阔构象空间的必要手段。",
            "id": "2453295",
            "problem": "您必须实现并比较两种构象搜索策略，用于环癸烷模型：其一是在离散的二面角网格上显式计算一个简化的势能，其二是在同一网格上进行随机（蒙特卡洛）搜索。比较指标是在离散网格上识别全局最小值所需的能量评估次数，以及随机搜索是否在给定的预算内找到了该最小值。在测试套件中指定的角度必须以度为单位处理，并根据需要进行内部转换；所有三角函数运算都必须应用于以弧度为单位的角度。能量必须以千卡/摩尔（kcal/mol）为单位进行计算和解释，但您的程序必须仅输出不带单位符号的原始数值。\n\n使用的基本依据和定义：\n- 碳-碳单键的分子力学扭转能通常通过截断的余弦级数来建模。对于本问题，请使用一个三重项\n$$\nV_{\\text{torsion}}(\\varphi) = A\\left[1 - \\cos\\left(3\\varphi\\right)\\right],\n$$\n其中 $A$ 是一个正常数，$\\varphi$ 是以弧度为单位的二面角。对于一系列二面角 $\\{\\varphi_i\\}_{i=1}^{m}$，总扭转能为\n$$\nE_{\\text{tors}}(\\{\\varphi_i\\}) = \\sum_{i=1}^{m} A\\left[1 - \\cos\\left(3\\varphi_i\\right)\\right].\n$$\n- 环的闭合通过对相应开链的端到端距离施加谐波罚项来近似，该开链是使用内坐标（一种标准的Z-矩阵构造）由固定的键长和键角构建的。设 $n$ 为环原子数，$b$ 为固定键长（单位为埃），$\\theta$ 为固定键角（单位为弧度）。给定由 $\\{\\varphi_i\\}_{i=1}^{n-3}$ 构建的开链的位置 $\\{\\mathbf{r}_k\\}_{k=0}^{n-1}$，环闭合罚项为\n$$\nE_{\\text{closure}} = k_{\\text{clo}} \\left\\lVert \\mathbf{r}_{n-1} - \\mathbf{r}_0 \\right\\rVert^2,\n$$\n其中 $k_{\\text{clo}}$ 的单位是 $\\text{kcal mol}^{-1}\\,\\text{\\AA}^{-2}$，$\\lVert\\cdot\\rVert$ 表示欧几里得范数。\n- 总能量为\n$$\nE_{\\text{total}}(\\{\\varphi_i\\}) = E_{\\text{tors}}(\\{\\varphi_i\\}) + E_{\\text{closure}}.\n$$\n\n从内坐标构建开链的几何结构：\n- 在每个内部顶点处使用固定的键长 $b$ 和键角 $\\theta$。按如下方式放置前三个原子：$\\mathbf{r}_0 = (0,0,0)$，$\\mathbf{r}_1 = (b,0,0)$，以及 $\\mathbf{r}_2 = \\mathbf{r}_1 + b\\left(\\cos(\\pi - \\theta), \\sin(\\pi - \\theta), 0\\right)$。对于 $i \\ge 3$，使用由键方向及其叉积构建的正交单位向量，根据前三个原子 $\\mathbf{r}_{i-3}, \\mathbf{r}_{i-2}, \\mathbf{r}_{i-1}$ 和二面角 $\\varphi_{i-2}$ 来构造 $\\mathbf{r}_i$；局部键方向为\n$$\n\\mathbf{v}_i = -\\cos\\theta\\,\\hat{\\mathbf{e}}_2 + \\sin\\theta\\cos\\varphi_{i-2}\\,\\hat{\\mathbf{n}}_2 + \\sin\\theta\\sin\\varphi_{i-2}\\,\\hat{\\mathbf{n}}_1,\n$$\n其中 $\\hat{\\mathbf{e}}_2$ 是沿 $\\mathbf{r}_{i-1}-\\mathbf{r}_{i-2}$ 的单位向量，$\\hat{\\mathbf{n}}_1$ 是由 $\\mathbf{r}_{i-3},\\mathbf{r}_{i-2},\\mathbf{r}_{i-1}$ 定义的平面的单位法向量，而 $\\hat{\\mathbf{n}}_2 = \\hat{\\mathbf{n}}_1 \\times \\hat{\\mathbf{e}}_2$。然后设置\n$$\n\\mathbf{r}_i = \\mathbf{r}_{i-1} + b\\,\\mathbf{v}_i.\n$$\n\n要实现的搜索策略：\n- 系统（网格）搜索：对于一个有 $n$ 个原子的环，枚举从指定网格 $G$（以度为单位）中选择的 $m = n - 3$ 个离散二面角值的所有组合。在计算能量之前将角度从度转换为弧度。为每种组合评估 $E_{\\text{total}}$，并记录此网格上的精确全局最小能量 $E_{\\min}$。此搜索中的能量评估次数等于 $\\lvert G \\rvert^{m}$。\n- 随机（蒙特卡洛）搜索：使用指定的伪随机种子，在指定的试验次数 $M$ 内，从同一网格 $G$ 中均匀随机地抽样独立的二面角组合。追踪遇到的最佳能量 $E_{\\text{best}}$，以及首次遇到能量小于或等于 $E_{\\min} + \\varepsilon$ 时的试验索引，其中 $\\varepsilon$ 是指定的绝对容差。报告是否在预算 $M$ 内找到了全局最小值，如果找到，报告截至第一次命中（从1开始计数）需要多少次能量评估。\n\n角度单位和物理单位：\n- 所有二面角网格值都以度为单位指定，并且必须转换为弧度以用于三角函数。固定键角参数 $\\theta$ 以度为单位指定，也必须转换为弧度。根据给定的参数，能量必须以 $\\text{kcal mol}^{-1}$ 为单位计算，但只应打印不带单位符号的原始数值。\n\n您的程序必须实现上述模型并执行以下测试套件。每个测试用例是一个参数元组 $(n, G, A, b, \\theta, k_{\\text{clo}}, M, s, \\varepsilon)$，其中：\n- $n$ 是环原子数（一个整数）。\n- $G$ 是以度为单位的二面角网格（一个整数列表）。\n- $A$ 是以 $\\text{kcal mol}^{-1}$ 为单位的扭转能垒参数（一个浮点数）。\n- $b$ 是以埃为单位的键长（一个浮点数）。\n- $\\theta$ 是以度为单位的键角（一个浮点数）。\n- $k_{\\text{clo}}$ 是以 $\\text{kcal mol}^{-1}\\,\\text{\\AA}^{-2}$ 为单位的环闭合罚项系数（一个浮点数）。\n- $M$ 是蒙特卡洛预算（一个整数）。\n- $s$ 是蒙特卡洛随机种子（一个整数）。\n- $\\varepsilon$ 是用于宣告命中全局最小值的绝对能量容差（一个浮点数）。\n\n使用以下测试套件：\n- 案例1（环癸烷，理想情况）：$(n = 10,\\; G = [-60, 60, 180],\\; A = 0.5,\\; b = 1.54,\\; \\theta = 112,\\; k_{\\text{clo}} = 10.0,\\; M = 5000,\\; s = 12345,\\; \\varepsilon = 10^{-9})$。\n- 案例2（环癸烷，更紧的预算）：$(n = 10,\\; G = [-60, 60, 180],\\; A = 0.5,\\; b = 1.54,\\; \\theta = 112,\\; k_{\\text{clo}} = 10.0,\\; M = 500,\\; s = 42,\\; \\varepsilon = 10^{-9})$。\n- 案例3（八元环，对比）：$(n = 8,\\; G = [-60, 60, 180],\\; A = 0.5,\\; b = 1.54,\\; \\theta = 112,\\; k_{\\text{clo}} = 10.0,\\; M = 500,\\; s = 2023,\\; \\varepsilon = 10^{-9})$。\n\n对于每个测试用例，您的程序必须：\n- 通过对网格 $G$ 的 $m = n-3$ 次幂进行穷举，计算 $E_{\\min}$。\n- 将系统评估的次数记录为 $\\lvert G \\rvert^{m}$。\n- 使用种子 $s$ 从 $G^{m}$ 中运行 $M$ 个独立样本的蒙特卡洛搜索，确定是否找到了能量 $\\le E_{\\min} + \\varepsilon$ 的样本，记录首次命中时的评估次数（如果未找到则为 $M$），并记录在蒙特卡洛运行中观察到的 $E_{\\text{best}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身又是以下形式的列表\n`[E_min, N_sys, found, N_MC, E_best]`，\n其中 $E_{\\min}$ 和 $E_{\\text{best}}$ 是浮点数，$N_{\\text{sys}}$ 和 $N_{\\text{MC}}$ 是整数，$\\text{found}$ 是布尔值。例如：“[[0.0,2187,True,57,0.0],[...],[...]]”。",
            "solution": "该问题陈述具有科学依据，定义明确，客观且自成体系。它提出了一个用于构象分析的标准（尽管是简化的）计算化学问题。所有参数、方程和程序都经过了足够严格的定义，从而能够得出一个唯一且可验证的解。因此，该问题是成立的。\n\n核心任务是实现两种搜索策略——系统网格搜索和随机蒙特卡洛（MC）搜索——以找到一个模型环状分子的最低能量构象。总势能 $E_{\\text{total}}$ 定义为扭转项 $E_{\\text{tors}}$ 和环闭合罚项 $E_{\\text{closure}}$ 的总和。\n\n对于一个包含 $m$ 个二面角的序列 $\\{\\varphi_i\\}_{i=1}^{m}$，总扭转能由各个三重势的总和给出：\n$$\nE_{\\text{tors}}(\\{\\varphi_i\\}) = \\sum_{i=1}^{m} A\\left[1 - \\cos\\left(3\\varphi_i\\right)\\right]\n$$\n这里，$A$ 是以 $\\text{kcal mol}^{-1}$ 为单位的扭转能垒高度，计算时每个二面角 $\\varphi_i$ 必须以弧度为单位。\n\n环闭合罚项确保了以开链形式构建的分子能够形成一个闭合的环。它是一个谐波势，依赖于第一个原子 $\\mathbf{r}_0$ 和最后一个原子 $\\mathbf{r}_{n-1}$ 之间欧几里得距离的平方：\n$$\nE_{\\text{closure}} = k_{\\text{clo}} \\left\\lVert \\mathbf{r}_{n-1} - \\mathbf{r}_0 \\right\\rVert^2\n$$\n常数 $k_{\\text{clo}}$ 的单位为 $\\text{kcal mol}^{-1}\\,\\text{\\AA}^{-2}$。总能量是二者之和：$E_{\\text{total}} = E_{\\text{tors}} + E_{\\text{closure}}$。\n\n问题的核心在于从一组内坐标几何构建原子坐标 $\\{\\mathbf{r}_k\\}_{k=0}^{n-1}$。对于一个有 $n$ 个原子的环，我们使用固定的键长 $b$、固定的键角 $\\theta$ 和一组 $m = n-3$ 个可变二面角 $\\{\\varphi_i\\}_{i=1}^{m}$。\n前三个原子在 $xy$ 平面上被初始化，以建立一个参考坐标系：\n$$ \\mathbf{r}_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{r}_1 = \\begin{pmatrix} b \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{r}_2 = \\mathbf{r}_1 + b \\begin{pmatrix} \\cos(\\pi - \\theta) \\\\ \\sin(\\pi - \\theta) \\\\ 0 \\end{pmatrix} $$\n对于后续的原子 $\\mathbf{r}_i$ （其中 $i \\ge 3$），其位置是相对于前三个原子 $\\mathbf{r}_{i-3}, \\mathbf{r}_{i-2}, \\mathbf{r}_{i-1}$ 和相应的二面角 $\\varphi_{i-2}$ 来确定的。一个局域正交单位基 $\\{\\hat{\\mathbf{e}}_2, \\hat{\\mathbf{n}}_1, \\hat{\\mathbf{n}}_2\\}$ 被构建出来。向量 $\\hat{\\mathbf{e}}_2$ 是从 $\\mathbf{r}_{i-2}$ 到 $\\mathbf{r}_{i-1}$ 的键的单位向量。向量 $\\hat{\\mathbf{n}}_1$ 是由原子 $\\mathbf{r}_{i-3}, \\mathbf{r}_{i-2}, \\mathbf{r}_{i-1}$ 定义的平面的单位法向量。第三个基向量是 $\\hat{\\mathbf{n}}_2 = \\hat{\\mathbf{n}}_1 \\times \\hat{\\mathbf{e}}_2$。新原子的位置则为 $\\mathbf{r}_i = \\mathbf{r}_{i-1} + b\\mathbf{v}_i$，其中新的键方向向量 $\\mathbf{v}_i$ 由下式给出：\n$$ \\mathbf{v}_i = -\\cos\\theta\\,\\hat{\\mathbf{e}}_2 + \\sin\\theta\\cos\\varphi_{i-2}\\,\\hat{\\mathbf{n}}_2 + \\sin\\theta\\sin\\varphi_{i-2}\\,\\hat{\\mathbf{n}}_1 $$\n所有以度为单位指定的角度 $\\theta$ 和 $\\varphi_i$ 在用于任何三角函数之前，都必须通过公式 $\\alpha_{\\text{rad}} = \\alpha_{\\text{deg}} \\cdot (\\pi / 180)$ 转换为弧度。\n\n该解法按如下算法步骤进行：\n1. **系统搜索**：可能构象的空间是一个离散网格，由笛卡尔积 $G^m$ 定义，其中 $G$ 是允许的二面角集合，$m = n-3$。我们枚举所有可能的二面角组合，构建相应的分子几何结构，计算其总能量，并在此网格上识别出全局最小能量 $E_{\\min}$。总能量评估次数为 $N_{\\text{sys}} = \\lvert G \\rvert^m$。\n\n2. **随机搜索**：通过抽样 $M$ 个构象来进行蒙特卡洛模拟。对于每次试验，通过从网格 $G$ 中均匀独立地抽样，选择一组 $m$ 个二面角。随机数生成器使用一个特定的整数 $s$ 作为种子，以确保可复现性。对每个抽样的构象计算其能量。我们记录在所有 $M$ 次试验中找到的最低能量 $E_{\\text{best}}$。我们还确定是否有任何试验产生的能量 $E \\le E_{\\min} + \\varepsilon$，其中 $\\varepsilon$ 是一个很小的容差。如果找到了这样的构象，我们将首次出现的试验次数记录为 $N_{\\text{MC}}$；否则，$N_{\\text{MC}}$ 被设置为总预算 $M$。布尔标志 `found` 表示是否在容差范围内成功找到了全局最小值。\n\n整个过程在一个 Python 脚本中实现。用于几何构建和能量计算的辅助函数将代码模块化。主函数遍历提供的测试用例，为每个用例执行两种搜索策略，并将得到的五个值——$E_{\\min}$、$N_{\\text{sys}}$、`found`、$N_{\\text{MC}}$、$E_{\\text{best}}$——格式化为指定的输出字符串格式。向量和矩阵运算使用 `numpy` 库高效处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for conformational search comparison.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (cyclodecane, happy path)\n        (10, [-60, 60, 180], 0.5, 1.54, 112, 10.0, 5000, 12345, 1e-9),\n        # Case 2 (cyclodecane, tighter budget)\n        (10, [-60, 60, 180], 0.5, 1.54, 112, 10.0, 500, 42, 1e-9),\n        # Case 3 (eight-membered ring, contrast)\n        (8, [-60, 60, 180], 0.5, 1.54, 112, 10.0, 500, 2023, 1e-9),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, G_deg, A, b, theta_deg, k_clo, M, s, eps = case\n        \n        # Convert angles to radians\n        theta_rad = np.deg2rad(theta_deg)\n        G_rad = [np.deg2rad(angle) for angle in G_deg]\n        \n        # Perform systematic search to find the exact minimum on the grid\n        E_min, N_sys = _systematic_search(n, G_rad, A, b, theta_rad, k_clo)\n        \n        # Perform stochastic search\n        found, N_MC, E_best = _stochastic_search(n, G_rad, E_min, A, b, theta_rad, k_clo, M, s, eps)\n        \n        results.append([E_min, N_sys, found, N_MC, E_best])\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for r in results:\n        # Format floats to have a consistent representation\n        r[0] = f\"{r[0]:.10f}\"\n        r[4] = f\"{r[4]:.10f}\"\n        result_strings.append(f\"[{','.join(map(str, r))}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef _build_chain(dihedrals_rad, n, b, theta_rad):\n    \"\"\"\n    Constructs the Cartesian coordinates of an n-atom open chain.\n    \"\"\"\n    coords = [np.zeros(3)] * n\n    coords[0] = np.array([0.0, 0.0, 0.0])\n    if n > 1:\n        coords[1] = np.array([b, 0.0, 0.0])\n    if n > 2:\n        r2_vec = np.array([b * np.cos(np.pi - theta_rad), b * np.sin(np.pi - theta_rad), 0.0])\n        coords[2] = coords[1] + r2_vec\n\n    for i in range(3, n):\n        r_im1, r_im2, r_im3 = coords[i-1], coords[i-2], coords[i-3]\n        \n        u1 = r_im2 - r_im3\n        u2 = r_im1 - r_im2\n        \n        e2_hat = u2 / np.linalg.norm(u2)\n        \n        cross_prod = np.cross(u1, u2)\n        norm_cross_prod = np.linalg.norm(cross_prod)\n        if norm_cross_prod < 1e-12: # Handles collinearity, though not expected here\n            # This case shouldn't be reached with theta != 180 deg\n            # A default perpendicular vector can be chosen if needed\n            # For this problem, we can assume non-collinear\n            # Based on the fixed bond angle.\n            temp_vec = np.array([0.0, 0.0, 1.0])\n            if np.abs(np.dot(temp_vec, e2_hat)) > 0.99:\n                temp_vec = np.array([0.0, 1.0, 0.0])\n            cross_prod = np.cross(e2_hat, temp_vec)\n            norm_cross_prod = np.linalg.norm(cross_prod)\n\n        n1_hat = cross_prod / norm_cross_prod\n        n2_hat = np.cross(n1_hat, e2_hat)\n        \n        phi = dihedrals_rad[i-3]\n        \n        cos_theta = np.cos(theta_rad)\n        sin_theta = np.sin(theta_rad)\n        cos_phi = np.cos(phi)\n        sin_phi = np.sin(phi)\n        \n        v_i = -cos_theta * e2_hat + sin_theta * cos_phi * n2_hat + sin_theta * sin_phi * n1_hat\n        coords[i] = r_im1 + b * v_i\n        \n    return coords\n\ndef _calculate_energy(dihedrals_rad, coords, A, k_clo):\n    \"\"\"\n    Calculates the total potential energy of a conformation.\n    \"\"\"\n    n = len(coords)\n    E_tors = np.sum([A * (1.0 - np.cos(3.0 * phi)) for phi in dihedrals_rad])\n    \n    dist_sq = np.sum((coords[n-1] - coords[0])**2)\n    E_closure = k_clo * dist_sq\n    \n    return E_tors + E_closure\n\ndef _systematic_search(n, G_rad, A, b, theta_rad, k_clo):\n    \"\"\"\n    Performs an exhaustive grid search to find the global minimum energy.\n    \"\"\"\n    m = n - 3\n    if m <= 0: # for n<=3 rings, no dihedrals\n        coords = _build_chain([], n, b, theta_rad)\n        energy = _calculate_energy([], coords, A, k_clo)\n        return energy, 1\n\n    num_evals = len(G_rad)**m\n    min_energy = float('inf')\n    \n    for dihedrals_tuple in itertools.product(G_rad, repeat=m):\n        dihedrals_rad = list(dihedrals_tuple)\n        coords = _build_chain(dihedrals_rad, n, b, theta_rad)\n        energy = _calculate_energy(dihedrals_rad, coords, A, k_clo)\n        if energy < min_energy:\n            min_energy = energy\n            \n    return min_energy, num_evals\n\ndef _stochastic_search(n, G_rad, E_min, A, b, theta_rad, k_clo, M, s, eps):\n    \"\"\"\n    Performs a Monte Carlo search for the minimum energy conformation.\n    \"\"\"\n    rng = np.random.default_rng(s)\n    m = n - 3\n    if m <= 0:\n        coords = _build_chain([], n, b, theta_rad)\n        energy = _calculate_energy([], coords, A, k_clo)\n        found = energy <= E_min + eps\n        return found, 1, energy\n        \n    best_energy = float('inf')\n    found = False\n    first_hit_trial = M\n    \n    for trial in range(1, M + 1):\n        indices = rng.integers(0, len(G_rad), size=m)\n        dihedrals_rad = [G_rad[i] for i in indices]\n        \n        coords = _build_chain(dihedrals_rad, n, b, theta_rad)\n        energy = _calculate_energy(dihedrals_rad, coords, A, k_clo)\n        \n        if energy < best_energy:\n            best_energy = energy\n            \n        if not found and energy <= E_min + eps:\n            found = True\n            first_hit_trial = trial\n            \n    return found, first_hit_trial, best_energy\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}