{
    "hands_on_practices": [
        {
            "introduction": "在学习 Ewald 求和这样复杂的长程相互作用处理方法之前，深刻理解为什么简单的截断法会失效是至关重要的。本练习将通过一个简单的一维双粒子系统，直观地展示在周期性边界条件下，对库仑力使用硬截断会如何导致力的不连续性。通过亲手计算这个在截断边界上发生的力的“跳变”，你将体会到这种方法为何会破坏能量守恒，并理解为何我们需要更复杂的算法来确保分子模拟的准确性和稳定性。",
            "id": "2457367",
            "problem": "考虑两个点电荷，它们在一个空间维度上通过库仑势相互作用，并处于周期性边界条件（PBC）下。箱体长度为 $L$，单位为约化（无量纲）单位。电荷分别为 $q_1 = +1$ 和 $q_2 = +1$，分别位于位置 $x_1 = 0$ 和 $x_2$ 处。使用最小镜像约定：定义位移 $\\Delta x = x_2 - x_1$，然后通过将 $\\Delta x$ 替换为 $\\Delta x' = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x/L)$，将其映射到区间 $[-L/2,\\,L/2)$ 上，其中 $\\mathrm{round}(\\cdot)$ 返回最近的整数。令 $r = |\\Delta x'|$ 表示此约定下的标量间距。\n\n在间距 $r_c$ 处使用一个简单的球形截断：粒子1对粒子2的力的x分量定义为\n$$\nF_x =\n\\begin{cases}\n\\dfrac{q_1 q_2 \\, \\Delta x'}{r^3},  \\text{若 } r  r_c, \\\\\n0,  \\text{若 } r \\ge r_c,\n\\end{cases}\n$$\n其中所有量均为无量纲。此定义等效于在 $r = r_c$ 处对库仑力进行突兀截断，不进行任何平移或平滑处理。\n\n您的任务是通过计算每个测试用例中的跳变\n$$\nJ = F_x(x_a) - F_x(x_b),\n$$\n来论证当 $x_2$ 穿过截断边界时 $F_x$ 的不连续性，其中 $x_a$ 和 $x_b$ 是粒子2的两个指定位置，它们位于截断边界的两侧（或按明确给出的那样位于边界上）。对于所有情况，原点 $x_1 = 0$ 都是固定的。在上述定义中，将 $r = r_c$ 的情况视为属于 $r \\ge r_c$ 分支。\n\n所有答案都应表示为无量纲实数。\n\n测试套件（每个用例都是独立的；请使用给定参数）：\n- 用例 1：$L = 10$, $r_c = 3$, $x_a = 2.999999$, $x_b = 3.000001$。\n- 用例 2：$L = 10$, $r_c = 3$, $x_a = 7.000001$, $x_b = 6.999999$。\n- 用例 3（边界情况）：$L = 10$, $r_c = 3$, $x_a = 2.999999999$, $x_b = 3.0$。\n- 用例 4：$L = 12$, $r_c = 4$, $x_a = 3.9999$, $x_b = 4.0001$。\n\n对于每个用例，计算如上定义的标量跳变 $J$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4]”），结果顺序为用例1到用例4。",
            "solution": "该问题陈述在科学上是合理且定义明确的。它提出了一个计算物理学中的标准练习，旨在展示截断势的病态行为，即力在截断半径处的不连续性。这是一个已知的人为效应，它在分子动力学模拟中会破坏能量守恒，对其进行分析具有启发意义。该问题为获得唯一解提供了所有必要的参数和定义。\n\n我们的任务是为跨越力截断边界的两个相邻点 $x_a$ 和 $x_b$ 计算力的跳变 $J = F_x(x_a) - F_x(x_b)$。位于位置 $x_2$ 的粒子2受到位于 $x_1=0$ 的粒子1的作用力 $F_x$，其由一个涉及最小镜像约定的特定函数形式给出。\n\n对于给定的位置 $x_2$，计算过程分为以下几步：\n1. 计算原始位移：$\\Delta x = x_2 - x_1$。由于 $x_1=0$，这简化为 $\\Delta x = x_2$。\n2. 应用最小镜像约定以找到最短周期距离。映射后的位移 $\\Delta x'$ 计算如下：\n    $$ \\Delta x' = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L) $$\n    此操作将 $\\Delta x$ 映射到区间 $[-L/2, L/2)$ 中。\n3. 计算标量间距 $r$，即映射后位移的大小：\n    $$ r = |\\Delta x'| $$\n4. 应用截断条件以确定力。力 $F_x$ 定义为：\n    $$\n    F_x(x_2) =\n    \\begin{cases}\n    \\dfrac{q_1 q_2 \\, \\Delta x'}{r^3},  \\text{若 } r  r_c, \\\\\n    0,  \\text{若 } r \\ge r_c.\n    \\end{cases}\n    $$\n    给定 $q_1=+1$ 和 $q_2=+1$，并注意到 $r^3 = |\\Delta x'|^3$，当 $r  r_c$ 时，这简化为 $F_x = \\Delta x' / |\\Delta x'|^3$。\n\n我们现在将此过程应用于每个测试用例。\n\n**用例 1：** $L = 10$, $r_c = 3$, $q_1=1$, $q_2=1$。\n- 对于 $x_2 = x_a = 2.999999$：\n  - $\\Delta x = 2.999999$。\n  - $\\Delta x / L = 0.2999999$，所以 $\\mathrm{round}(\\Delta x / L) = 0$。\n  - $\\Delta x' = 2.999999 - 10 \\cdot 0 = 2.999999$。\n  - $r = |\\Delta x'| = 2.999999$。\n  - 由于 $r  r_c$ ($2.999999  3$)，力不为零：\n    $$ F_x(x_a) = \\frac{(1)(1)(2.999999)}{(2.999999)^3} = \\frac{1}{(2.999999)^2} $$\n- 对于 $x_2 = x_b = 3.000001$：\n  - $\\Delta x = 3.000001$。\n  - $\\Delta x / L = 0.3000001$，所以 $\\mathrm{round}(\\Delta x / L) = 0$。\n  - $\\Delta x' = 3.000001 - 10 \\cdot 0 = 3.000001$。\n  - $r = |\\Delta x'| = 3.000001$。\n  - 由于 $r > r_c$ ($3.000001 > 3$)，力为零：$F_x(x_b) = 0$。\n- 跳变为 $J_1 = F_x(x_a) - F_x(x_b) = 1 / (2.999999)^2 \\approx 0.1111111975$。\n\n**用例 2：** $L = 10$, $r_c = 3$, $q_1=1$, $q_2=1$。\n- 对于 $x_2 = x_a = 7.000001$：\n  - $\\Delta x = 7.000001$。\n  - $\\Delta x / L = 0.7000001$，所以 $\\mathrm{round}(\\Delta x / L) = 1$。\n  - $\\Delta x' = 7.000001 - 10 \\cdot 1 = -2.999999$。\n  - $r = |\\Delta x'| = 2.999999$。\n  - 由于 $r  r_c$ ($2.999999  3$)，力不为零：\n    $$ F_x(x_a) = \\frac{(1)(1)(-2.999999)}{(2.999999)^3} = -\\frac{1}{(2.999999)^2} $$\n- 对于 $x_2 = x_b = 6.999999$：\n  - $\\Delta x = 6.999999$。\n  - $\\Delta x / L = 0.6999999$，所以 $\\mathrm{round}(\\Delta x / L) = 1$。\n  - $\\Delta x' = 6.999999 - 10 \\cdot 1 = -3.000001$。\n  - $r = |\\Delta x'| = 3.000001$。\n  - 由于 $r > r_c$ ($3.000001 > 3$)，力为零：$F_x(x_b) = 0$。\n- 跳变为 $J_2 = F_x(x_a) - F_x(x_b) = -1 / (2.999999)^2 \\approx -0.1111111975$。\n\n**用例 3：** $L = 10$, $r_c = 3$, $q_1=1$, $q_2=1$。\n- 对于 $x_2 = x_a = 2.999999999$：\n  - $\\Delta x = 2.999999999$，所以 $\\Delta x' = 2.999999999$ 且 $r = 2.999999999$。\n  - 由于 $r  r_c$，力为：\n    $$ F_x(x_a) = \\frac{1}{(2.999999999)^2} $$\n- 对于 $x_2 = x_b = 3.0$：\n  - $\\Delta x = 3.0$，所以 $\\Delta x' = 3.0$ 且 $r = 3.0$。\n  - 根据问题定义，$r = r_c$ 属于 $r \\ge r_c$ 分支。因此，$F_x(x_b) = 0$。\n- 跳变为 $J_3 = F_x(x_a) - F_x(x_b) = 1 / (2.999999999)^2 \\approx 0.111111111$。\n\n**用例 4：** $L = 12$, $r_c = 4$, $q_1=1$, $q_2=1$。\n- 对于 $x_2 = x_a = 3.9999$：\n  - $\\Delta x = 3.9999$。\n  - $\\Delta x / L = 3.9999 / 12 = 0.333325$，所以 $\\mathrm{round}(\\Delta x / L) = 0$。\n  - $\\Delta x' = 3.9999 - 12 \\cdot 0 = 3.9999$。\n  - $r = |\\Delta x'| = 3.9999$。\n  - 由于 $r  r_c$ ($3.9999  4$)，力不为零：\n    $$ F_x(x_a) = \\frac{1}{(3.9999)^2} $$\n- 对于 $x_2 = x_b = 4.0001$：\n  - $\\Delta x = 4.0001$。\n  - $\\Delta x / L = 4.0001 / 12 \\approx 0.333341$，所以 $\\mathrm{round}(\\Delta x / L) = 0$。\n  - $\\Delta x' = 4.0001 - 12 \\cdot 0 = 4.0001$。\n  - $r = |\\Delta x'| = 4.0001$。\n  - 由于 $r > r_c$ ($4.0001 > 4$)，力为零：$F_x(x_b) = 0$。\n- 跳变为 $J_4 = F_x(x_a) - F_x(x_b) = 1 / (3.9999)^2 \\approx 0.062503125$。\n\n在截断点 $r_c$ 处，力跳变的大小趋近于极限 $\\frac{q_1 q_2}{r_c^2}$。跳变的正负号由最小镜像位移 $\\Delta x'$ 的正负号决定。最终的数值答案通过编程计算以保持精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_force(x2, L, rc, q1, q2, x1=0.0):\n    \"\"\"\n    Computes the x-component of the force on particle 2 due to particle 1\n    according to the problem specification.\n    \"\"\"\n    # Step 1: Calculate the raw displacement.\n    delta_x = x2 - x1\n\n    # Step 2: Apply the minimum image convention.\n    # The problem specifies round(x/L), which corresponds to numpy.round().\n    delta_x_prime = delta_x - L * np.round(delta_x / L)\n\n    # Step 3: Calculate the scalar separation.\n    r = np.abs(delta_x_prime)\n\n    # Step 4: Apply the cutoff condition to determine the force.\n    # The problem states that r = rc belongs to the r >= rc branch,\n    # resulting in zero force.\n    if r >= rc:\n        force_x = 0.0\n    else:\n        # The case r=0 is not encountered in the test suite but is handled\n        # for completeness (force would be singular). Force is defined\n        # piecewise, so the else branch assumes r > 0.\n        force_x = (q1 * q2 * delta_x_prime) / (r**3)\n\n    return force_x\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the results.\n    \"\"\"\n    # Define the constants given in the problem.\n    q1 = 1.0\n    q2 = 1.0\n    x1 = 0.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'L': 10.0, 'rc': 3.0, 'xa': 2.999999, 'xb': 3.000001},      # Case 1\n        {'L': 10.0, 'rc': 3.0, 'xa': 7.000001, 'xb': 6.999999},      # Case 2\n        {'L': 10.0, 'rc': 3.0, 'xa': 2.999999999, 'xb': 3.0},       # Case 3\n        {'L': 12.0, 'rc': 4.0, 'xa': 3.9999, 'xb': 4.0001},         # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case['L']\n        rc = case['rc']\n        xa = case['xa']\n        xb = case['xb']\n\n        # Calculate the force at positions xa and xb.\n        force_a = compute_force(xa, L, rc, q1, q2, x1)\n        force_b = compute_force(xb, L, rc, q1, q2, x1)\n\n        # Calculate the jump J = F_x(xa) - F_x(xb).\n        jump = force_a - force_b\n        results.append(jump)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了简单截断法的局限性后，我们转向 Ewald 求和这一标准解决方案。本练习将带你超越简单的能量计算，深入 Ewald 方法的核心应用：计算体系的压力。你将学习如何通过 Ewald 方法计算得到的粒子间作用力来求解维里 $W = \\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{F}_i$，并最终得到系统的压强，这是热力学性质的关键。这个实践还将让你直观地看到 Ewald 参数（如 $\\alpha$、$r_{cut}$ 和 $k_{cut}$）的选择如何影响计算结果，帮助你理解在实际模拟中平衡计算效率与精度的艺术。",
            "id": "2457343",
            "problem": "给定一个三维电中性点电荷体系，该体系处于边长为 $L$、体积为 $V=L^3$ 的立方模拟晶胞中，并采用周期性边界条件 (PBC)。静电相互作用将通过 Ewald 求和方法处理，该方法使用高斯屏蔽参数 $\\alpha$（实正标量）、实空间截断半径 $r_{cut}$（非负标量）以及倒易空间截断半径 $k_{cut}$（非负标量）。假设在无穷远处采用导电（锡箔）边界条件，以使表面项为零。计算在约化单位制下进行，其中 $4\\pi \\epsilon_0=1$，玻尔兹曼常数 $k_B=1$。温度固定为 $T0$。\n\n组态维里 $W$ 由 Clausius 关系式定义为 $W=\\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{F}_i$，其中 $\\mathbf{r}_i$ 是模拟晶胞中粒子的笛卡尔坐标位置矢量，$\\mathbf{F}_i$ 是由指定的 Ewald 求和参数 $(\\alpha,r_{cut},k_{cut})$ 计算出的、源于静电相互作用的粒子 $i$ 所受的总作用力，$N$ 是粒子数。压力则由以下力学表达式给出\n$$\nP=\\frac{N T}{V}+\\frac{1}{3V} W,\n$$\n其中 $P$ 以能量/体积的约化单位表示。\n\n考虑以下固定的体系数据：\n- 粒子数 $N=2$。\n- 立方盒子边长 $L=10.0$，因此体积 $V=1000.0$。\n- 温度 $T=1.0$。\n- 电荷 $\\{q_i\\}_{i=1}^2$，其中 $q_1=+1.0$，$q_2=-1.0$。\n- 位置（在主晶胞内，笛卡尔坐标，长度单位与 $L$ 相同）：\n  - $\\mathbf{r}_1=(2.3,3.7,1.1)$,\n  - $\\mathbf{r}_2=(7.6,9.1,8.2)$。\n\n使用 Ewald 分解法计算总作用力 $\\mathbf{F}_i$，该方法将力分解为一个在 $r_{cut}$ 处截断的短程实空间求和，以及一个对满足 $\\lVert \\mathbf{k} \\rVert \\le k_{cut}$ 的波矢 $\\mathbf{k}$ 进行截断的倒易空间求和。自相互作用对力没有贡献。实空间求和必须包括以每对粒子间的分离矢量为中心、半径为 $r_{cut}$ 的球内的所有周期性镜像；倒易空间求和必须包括半径为 $k_{cut}$ 的球内的所有非零倒易格矢。使用立方晶胞的原胞倒易晶格，即倒易格矢为 $\\mathbf{k} = \\frac{2\\pi}{L}(n_x,n_y,n_z)$，其中 $n_x,n_y,n_z$ 为整数，且不包括 $\\mathbf{k}=\\mathbf{0}$。\n\n你的任务是编写一个完整的、可运行的程序，针对上述固定体系，为以下 Ewald 参数集 $(\\alpha,r_{cut},k_{cut})$ 测试集计算以约化单位表示的压力 $P$：\n1. $(\\alpha,r_{cut},k_{cut})=(0.25,6.0,10.0)$,\n2. $(\\alpha,r_{cut},k_{cut})=(0.10,6.0,10.0)$,\n3. $(\\alpha,r_{cut},k_{cut})=(0.25,3.0,12.0)$,\n4. $(\\alpha,r_{cut},k_{cut})=(0.25,6.0,6.0)$。\n\n对于每个参数集，基于上述定义从第一性原理计算 $P$。将最终的压力值以约化单位的普通实数（浮点数）形式表示。\n\n最终输出格式要求：\n你的程序应生成单行输出，其中包含四个结果，按测试集的顺序排列，形式为方括号括起来的逗号分隔列表，例如：“[p1,p2,p3,p4]”。不得有多余的空白或文本。所有角度（如有）均以弧度为单位；所有量均为无量纲或以指定的约化单位表示。输出必须是单行。",
            "solution": "所提出的问题是计算统计力学中的一个标准练习，具体而言，是通过 Ewald 求和方法计算周期性体系中的压力。在进行求解之前，需要进行严谨的验证。\n\n**问题验证**\n\n问题为物理体系和计算任务提供了完整且独立的描述。\n已知条件：\n-   体系类型：三维电中性体系，包含位于立方晶胞中的 $N=2$ 个点电荷 ($q_1=+1.0, q_2=-1.0$) 。\n-   周期性边界条件 (PBC)，晶胞边长 $L=10.0$，体积 $V=L^3=1000.0$。\n-   粒子位置：$\\mathbf{r}_1=(2.3,3.7,1.1)$ 和 $\\mathbf{r}_2=(7.6,9.1,8.2)$。\n-   温度 $T=1.0$（约化单位，其中 $k_B=1$）。\n-   静电方法：Ewald 求和，参数为 $(\\alpha, r_{cut}, k_{cut})$，并采用导电边界条件。\n-   约化单位：$4\\pi \\epsilon_0=1$。\n-   压力定义：$P=\\frac{N T}{V}+\\frac{1}{3V} W$，其中 $W=\\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{F}_i$ 是组态维里。\n-   任务：为四个指定的参数集计算 $P$。\n\n该问题具有科学依据，依赖于静电学和统计力学的基本原理。Ewald 求和方法是分子模拟的基石。所有术语均有明确无歧义的定义，并且提供了所有必需的数据。不存在内部矛盾、逻辑缺陷或伪科学元素。该问题是适定且客观的。\n\n结论：问题有效。我们继续进行求解。\n\n**理论阐述**\n\n粒子 $i$ 所受的总作用力 $\\mathbf{F}_i$ 分解为实空间贡献 $\\mathbf{F}_{i, \\text{real}}$ 和倒易空间贡献 $\\mathbf{F}_{i, \\text{recip}}$。总组态维里也同样被分解：$W = W_{\\text{real}} + W_{\\text{recip}}$。\n\n1.  **实空间贡献**\n\n粒子 $i$ 所受的实空间作用力是通过对所有其他粒子 $j$ 及其在截断半径 $r_{cut}$ 内的周期性镜像 $\\mathbf{n}$ 的相互作用求和来计算的。在分离矢量为 $\\mathbf{r}'$ 时，粒子 $j$ 对粒子 $i$ 施加的力由下式给出：\n$$\n\\mathbf{F}(\\mathbf{r}') = -q_i q_j \\nabla_{\\mathbf{r}'} \\frac{\\text{erfc}(\\alpha r')}{r'} = q_i q_j \\left[ \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 r'^2}}{r'} + \\frac{\\text{erfc}(\\alpha r')}{r'^2} \\right] \\frac{\\mathbf{r}'}{r'}\n$$\n其中 $r' = |\\mathbf{r}'|$。粒子 $i$ 所受的总实空间作用力是对所有 $j \\neq i$ 和所有格矢 $\\mathbf{n}=(n_x L, n_y L, n_z L)$ 的求和，条件是距离矢量 $\\mathbf{r}_{ij\\mathbf{n}} = \\mathbf{r}_i - (\\mathbf{r}_j + \\mathbf{n}L)$ 满足 $|\\mathbf{r}_{ij\\mathbf{n}}| \\le r_{cut}$。\n\n对于给定的仅含两个粒子的体系，我们只需考虑粒子 1 和粒子 2 之间的分离。主晶胞中的分离矢量为 $\\mathbf{r}_{12} = \\mathbf{r}_1 - \\mathbf{r}_2 = (2.3-7.6, 3.7-9.1, 1.1-8.2) = (-5.3, -5.4, -7.1)$。所有相关分离矢量的集合是 $\\mathbf{r}_{12,\\mathbf{n}} = \\mathbf{r}_{12} - \\mathbf{n}L$。我们必须找到粒子 1 的任意镜像与粒子 2 之间的最小距离。这对应于在所有整数矢量 $\\mathbf{n}=(n_x, n_y, n_z)$ 上 $|\\mathbf{r}_{12,\\mathbf{n}}|$ 的最小值。这可以通过最小镜像约定来实现。最小镜像分离矢量为：\n$$\n\\mathbf{r}_{12, \\text{mic}} = \\mathbf{r}_{12} - L \\cdot \\text{round}(\\mathbf{r}_{12} / L)\n$$\n当 $L=10.0$ 时，我们有 $\\mathbf{r}_{12}/L = (-0.53, -0.54, -0.71)$。四舍五入到最近的整数得到矢量 $(-1, -1, -1)$。\n因此，$\\mathbf{r}_{12, \\text{mic}} = (-5.3, -5.4, -7.1) - 10.0(-1, -1, -1) = (4.7, 4.6, 2.9)$。\n最小距离是 $r_{\\text{min}} = |\\mathbf{r}_{12, \\text{mic}}| = \\sqrt{4.7^2 + 4.6^2 + 2.9^2} = \\sqrt{22.09 + 21.16 + 8.41} = \\sqrt{51.66} \\approx 7.187$。\n\n测试集指定的实空间截断半径为 $r_{cut} = 6.0$ 和 $r_{cut} = 3.0$。由于粒子 1 的任意镜像与粒子 2 的任意镜像之间的最小距离为 $r_{\\text{min}} \\approx 7.187$，而所有指定的 $r_{cut}$ 值都小于这个最小距离，因此在实空间截断半径内不存在任何粒子对（包括镜像）。\n因此，对于所有四个测试用例，实空间求和为空。\n$$\n\\mathbf{F}_{i, \\text{real}} = \\mathbf{0} \\quad \\text{and} \\quad W_{\\text{real}} = 0\n$$\n\n2.  **倒易空间贡献**\n\n因此，计算简化为倒易空间的贡献。粒子 $i$ 所受的力由倒易空间能量 $U_{\\text{recip}}$ 导出：\n$$\n\\mathbf{F}_{i, \\text{recip}} = -\\nabla_{\\mathbf{r}_i} U_{\\text{recip}} = -\\nabla_{\\mathbf{r}_i} \\left( \\frac{2\\pi}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}, |\\mathbf{k}|\\le k_{cut}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} |S(\\mathbf{k})|^2 \\right)\n$$\n其中 $\\mathbf{k} = \\frac{2\\pi}{L}(n_x,n_y,n_z)$ 是对应整数 $(n_x, n_y, n_z)$ 的倒易格矢，$S(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{i\\mathbf{k}\\cdot\\mathbf{r}_j}$ 是结构因子。\n结构因子平方的梯度是 $\\nabla_{\\mathbf{r}_i} |S(\\mathbf{k})|^2 = -2 q_i \\mathbf{k} \\sum_j q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{ij})$，其中 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。\n这给出了粒子 $i$ 所受的力：\n$$\n\\mathbf{F}_{i, \\text{recip}} = \\frac{4\\pi q_i}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}, |\\mathbf{k}|\\le k_{cut}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\sum_{j=1}^N q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{ij})\n$$\n粒子 $i$ 所受的总作用力为 $\\mathbf{F}_i = \\mathbf{F}_{i, \\text{recip}}$。总维里为 $W = W_{\\text{recip}} = \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_{i, \\text{recip}}$。\n对于一个双粒子体系 $(i,j \\in \\{1,2\\})$，这可以简化。维里为 $W = \\mathbf{r}_1 \\cdot \\mathbf{F}_1 + \\mathbf{r}_2 \\cdot \\mathbf{F}_2$。根据牛顿第三定律，$\\mathbf{F}_2 = -\\mathbf{F}_1$，因此 $W = (\\mathbf{r}_1 - \\mathbf{r}_2) \\cdot \\mathbf{F}_1 = \\mathbf{r}_{12} \\cdot \\mathbf{F}_1$。\n粒子 1 所受的力为：\n$$\n\\mathbf{F}_1 = \\frac{4\\pi q_1}{V} \\sum_{\\mathbf{k}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\left( q_1 \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{11}) + q_2 \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{12}) \\right) = \\frac{4\\pi q_1 q_2}{V} \\sum_{\\mathbf{k}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{12})\n$$\n因此，维里为：\n$$\nW = \\frac{4\\pi q_1 q_2}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}, |\\mathbf{k}|\\le k_{cut}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} (\\mathbf{k} \\cdot \\mathbf{r}_{12}) \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{12})\n$$\n\n3.  **最终压力计算**\n\n总压力使用所提供的公式，并代入 $W=W_{\\text{recip}}$ 进行计算：\n$$\nP = \\frac{NT}{V} + \\frac{W}{3V} = \\frac{NT}{V} + \\frac{4\\pi q_1 q_2}{3V^2} \\sum_{\\mathbf{k} \\ne \\mathbf{0}, |\\mathbf{k}|\\le k_{cut}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} (\\mathbf{k} \\cdot \\mathbf{r}_{12}) \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{12})\n$$\n计算流程包括在由 $k_{cut}$ 决定的范围内遍历所有整数矢量 $(n_x, n_y, n_z)$，构建相应的 $\\mathbf{k}$ 矢量，并为维里累加求和。每个整数分量 $n_i$ 的范围受限于 $|n_i| \\le \\lfloor k_{cut} L / (2\\pi) \\rfloor$。在循环内部，还会应用一个额外的球形检查 $k^2 \\le k_{cut}^2$。",
            "answer": "```python\nimport numpy as np\n# The problem statement allows for scipy, but it is not strictly needed for the final algorithm.\n# from scipy.special import erfc could be used if the real-space term were non-zero.\n\ndef solve():\n    \"\"\"\n    Computes the pressure of a two-particle system with periodic boundary\n    conditions using the Ewald summation method for specified parameters.\n    \"\"\"\n    # Fixed system parameters in reduced units\n    N = 2.0\n    L = 10.0\n    V = L**3\n    T = 1.0\n\n    # Particle data\n    q1 = 1.0\n    q2 = -1.0\n    r1 = np.array([2.3, 3.7, 1.1])\n    r2 = np.array([7.6, 9.1, 8.2])\n    \n    # Separation vector in the primary cell\n    r12 = r1 - r2\n\n    # Test suite of Ewald parameters (alpha, r_cut, k_cut)\n    test_cases = [\n        (0.25, 6.0, 10.0),\n        (0.10, 6.0, 10.0),\n        (0.25, 3.0, 12.0),\n        (0.25, 6.0, 6.0),\n    ]\n\n    results = []\n    \n    for alpha, r_cut, k_cut in test_cases:\n        # --- Real-space contribution ---\n        # The minimum distance between any image of particle 1 and 2 is calculated\n        # via the minimum image convention:\n        # r12_mic = r12 - L * np.round(r12 / L)\n        # r12_mic = [-5.3, -5.4, -7.1] - 10.0 * [-1., -1., -1.] = [4.7, 4.6, 2.9]\n        # min_dist = np.linalg.norm(r12_mic) = sqrt(51.66) approx 7.187\n        # Since r_cut for all test cases (6.0, 3.0) is less than min_dist,\n        # the real-space sum is empty. The real-space force and virial are zero.\n        W_real = 0.0\n\n        # --- Reciprocal-space contribution ---\n        W_recip = 0.0\n        k_cut_sq = k_cut**2\n        k_sq_factor = (2.0 * np.pi / L)**2\n\n        # Determine the search space for reciprocal lattice vectors n\n        n_max = int(np.floor(k_cut * L / (2.0 * np.pi)))\n        \n        for nx in range(-n_max, n_max + 1):\n            for ny in range(-n_max, n_max + 1):\n                for nz in range(-n_max, n_max + 1):\n                    if nx == 0 and ny == 0 and nz == 0:\n                        continue\n\n                    n_vec = np.array([float(nx), float(ny), float(nz)])\n                    n_sq = np.dot(n_vec, n_vec)\n                    k_sq = k_sq_factor * n_sq\n\n                    if k_sq > k_cut_sq:\n                        continue\n\n                    k_vec = (2.0 * np.pi / L) * n_vec\n                    \n                    k_dot_r12 = np.dot(k_vec, r12)\n                    \n                    term = (np.exp(-k_sq / (4.0 * alpha**2)) / k_sq) * k_dot_r12 * np.sin(k_dot_r12)\n                    W_recip += term\n\n        W_recip *= 4.0 * np.pi * q1 * q2 / V\n        \n        # --- Total virial and pressure ---\n        W = W_real + W_recip\n        P = (N * T / V) + W / (3.0 * V)\n        results.append(P)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{p:.10f}' for p in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了 Ewald 求和的基本原理和应用后，是时候探索一些更深入和微妙的方面了。强大的粒子网格 Ewald (PME) 方法并非一个完美的“黑箱”，了解其内在的局限性是成为一名严谨的模拟研究者的必经之路。本练习旨在揭示 PME 方法中一个重要的伪影：由于倒易空间求和格点的各向异性，可能会对模拟盒子中的分子引入人为的取向偏好。通过量化这种伪影，你将更深刻地理解数值算法如何与物理体系相互作用，并学会在模拟各向异性体系（如液晶或膜蛋白）时进行批判性思考。",
            "id": "2457400",
            "problem": "给定一个边长为 $L$ 的周期性三维立方模拟单胞，其具有周期性边界条件（PBC）。考虑一个由三个点电荷表示的电中性、各向异性分子，其电荷 $q_1=+1$、$q_2=-2$、$q_3=+1$ 分别位于位置 $\\mathbf{r}_1=-d\\,\\hat{\\mathbf{u}}$、$\\mathbf{r}_2=\\mathbf{0}$ 和 $\\mathbf{r}_3=+d\\,\\hat{\\mathbf{u}}$，其中 $d0$ 是一个标量距离，$\\hat{\\mathbf{u}}$ 是定义分子轴的单位矢量。使用约化静电单位制，其中库仑常数为 $1$，并且能量以无量纲数报告。\n\n在埃瓦尔德求和中，立方盒子中点电荷的库仑能量的倒易空间贡献定义为\n$$\nE_{\\mathrm{rec}} = \\frac{2\\pi}{V}\\sum_{\\mathbf{k}\\neq \\mathbf{0}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2}\\,\\left|S(\\mathbf{k})\\right|^2,\n$$\n其中 $V=L^3$ 是单胞的体积，$\\alpha0$ 是埃瓦尔德分裂参数，$\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$（其中 $\\mathbf{n}=(n_x,n_y,n_z)\\in\\mathbb{Z}^3$），$k=\\|\\mathbf{k}\\|$，以及 $S(\\mathbf{k})=\\sum_{j=1}^{3} q_j\\,e^{i\\,\\mathbf{k}\\cdot \\mathbf{r}_j}$ 是结构因子。\n\n令 $E_{\\mathrm{rec}}^{\\mathrm{rect}}$ 表示将倒易和限制于一个矩形倒易格矢集合上而计算出的能量，该集合中的整数索引满足 $|n_x|\\le K_x$、 $|n_y|\\le K_y$、 $|n_z|\\le K_z$，且不含 $\\mathbf{n}=\\mathbf{0}$。令 $E_{\\mathrm{rec}}^{\\mathrm{sph}}$ 表示将倒易和限制于一个球形倒易格矢集合上而计算出的能量，该集合满足 $n_x^2+n_y^2+n_z^2\\le K_{\\mathrm{sph}}^2$，且不含 $\\mathbf{n}=\\mathbf{0}$。这两种限制都是对完整无穷级数的近似。\n\n为该分子定义两种取向：\n- 取向 $\\mathcal{A}$：$\\hat{\\mathbf{u}}_{\\mathcal{A}}=(1,0,0)$（与 $x$ 轴对齐）。\n- 取向 $\\mathcal{B}$：$\\hat{\\mathbf{u}}_{\\mathcal{B}}=\\frac{1}{\\sqrt{3}}(1,1,1)$（与空间对角线对齐）。\n\n对于给定的参数集，定义取向能量差\n$$\n\\Delta E_{\\mathrm{rect}} = E_{\\mathrm{rec}}^{\\mathrm{rect}}(\\hat{\\mathbf{u}}_{\\mathcal{A}}) - E_{\\mathrm{rec}}^{\\mathrm{rect}}(\\hat{\\mathbf{u}}_{\\mathcal{B}}),\\qquad\n\\Delta E_{\\mathrm{sph}} = E_{\\mathrm{rec}}^{\\mathrm{sph}}(\\hat{\\mathbf{u}}_{\\mathcal{A}}) - E_{\\mathrm{rec}}^{\\mathrm{sph}}(\\hat{\\mathbf{u}}_{\\mathcal{B}}).\n$$\n粒子网格埃瓦尔德（PME）方法在一个有限网格上近似倒易和，其行为可能类似于倒易空间中的矩形限制。为了量化矩形限制相比球形限制可能引入的额外取向依赖相关性，定义相关性度量\n$$\n\\mathcal{D} = \\Delta E_{\\mathrm{rect}} - \\Delta E_{\\mathrm{sph}}.\n$$\n\n仅使用上述倒易空间定义，为以下每个参数集（测试集）计算 $\\mathcal{D}$。在每种情况下，使用提供的 $L$、$d$、$K_x$、$K_y$、$K_z$、$K_{\\mathrm{sph}}$，并设置 $\\alpha=\\frac{5}{L}$。\n\n- 测试用例 1（各向异性网格，较小盒子）：\n  - $L=4.0$，$d=0.45$，$(K_x,K_y,K_z)=(16,8,8)$，$K_{\\mathrm{sph}}=12$。\n- 测试用例 2（各向同性网格，相同盒子与分子）：\n  - $L=4.0$，$d=0.45$，$(K_x,K_y,K_z)=(12,12,12)$，$K_{\\mathrm{sph}}=12$。\n- 测试用例 3（各向异性网格，较大盒子）：\n  - $L=8.0$，$d=0.45$，$(K_x,K_y,K_z)=(16,8,8)$，$K_{\\mathrm{sph}}=12$。\n\n你的程序必须：\n- 完全按照上述定义实现倒易空间能量 $E_{\\mathrm{rec}}$，对 $E_{\\mathrm{rec}}^{\\mathrm{rect}}$ 和 $E_{\\mathrm{rec}}^{\\mathrm{sph}}$ 使用指定的受限集合。\n- 对每个测试用例，计算指定约化单位下的 $\\mathcal{D}$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`\"[$r_1,r_2,r_3$]\"`），其中 $r_1$、$r_2$ 和 $r_3$ 分别是测试用例 1、2 和 3 的 $\\mathcal{D}$ 值，表示为无量纲实数。",
            "solution": "所提出的问题是一个有效的计算物理问题，其基于周期性系统中的静电相互作用原理，特别是使用了埃瓦尔德求和方法。任务是计算一个特定度量 $\\mathcal{D}$，它量化了在倒易空间中使用矩形求和网格相对于球形网格所引入的人为取向各向异性。\n\n基本量是埃瓦尔德能量的倒易空间贡献，由下式给出\n$$\nE_{\\mathrm{rec}} = \\frac{2\\pi}{V}\\sum_{\\mathbf{k}\\neq \\mathbf{0}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2}\\,\\left|S(\\mathbf{k})\\right|^2\n$$\n在这里，求和遍及所有倒易格矢 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$，其中 $\\mathbf{n}=(n_x,n_y,n_z)$ 为非零整数矢量。$V=L^3$ 是立方单胞的体积，$\\alpha$ 是埃瓦尔德分裂参数，它将计算分配到实空间和倒易空间。函数 $S(\\mathbf{k})$ 是结构因子，它依赖于模拟单胞内的电荷分布。\n\n第一步是推导指定三电荷分子的结构因子 $S(\\mathbf{k})$。电荷分别为 $q_1=+1$、$q_2=-2$、$q_3=+1$，位于位置 $\\mathbf{r}_1=-d\\,\\hat{\\mathbf{u}}$、$\\mathbf{r}_2=\\mathbf{0}$ 和 $\\mathbf{r}_3=+d\\,\\hat{\\mathbf{u}}$。分子的总电荷为 $q_1+q_2+q_3=0$，其偶极矩为 $\\sum_j q_j\\mathbf{r}_j = (+1)(-d\\hat{\\mathbf{u}}) + (-2)(\\mathbf{0}) + (+1)(+d\\hat{\\mathbf{u}}) = \\mathbf{0}$。第一个非零多极矩是四极矩，能量计算反映了该分子四极矩与其周期性镜像之间的相互作用。\n\n结构因子定义为 $S(\\mathbf{k})=\\sum_{j=1}^{3} q_j\\,e^{i\\,\\mathbf{k}\\cdot \\mathbf{r}_j}$。代入给定的电荷和位置：\n$$\nS(\\mathbf{k}) = (+1)e^{i\\,\\mathbf{k}\\cdot (-d\\,\\hat{\\mathbf{u}})} + (-2)e^{i\\,\\mathbf{k}\\cdot \\mathbf{0}} + (+1)e^{i\\,\\mathbf{k}\\cdot (d\\,\\hat{\\mathbf{u}})}\n$$\n$$\nS(\\mathbf{k}) = e^{-i\\,d(\\mathbf{k}\\cdot \\hat{\\mathbf{u}})} - 2 + e^{i\\,d(\\mathbf{k}\\cdot \\hat{\\mathbf{u}})}\n$$\n使用欧拉恒等式 $e^{ix}+e^{-ix}=2\\cos(x)$，上式简化为：\n$$\nS(\\mathbf{k}) = 2\\cos(d\\,\\mathbf{k}\\cdot \\hat{\\mathbf{u}}) - 2\n$$\n因为 $\\mathbf{k}$、$\\hat{\\mathbf{u}}$ 和 $d$ 都是实数，所以 $S(\\mathbf{k})$ 是一个实值函数。因此，其模的平方就是它的平方：\n$$\n|S(\\mathbf{k})|^2 = \\left(2\\cos(d\\,\\mathbf{k}\\cdot \\hat{\\mathbf{u}}) - 2\\right)^2 = 4\\left(\\cos(d\\,\\mathbf{k}\\cdot \\hat{\\mathbf{u}}) - 1\\right)^2\n$$\n\n将埃瓦尔德参数设为 $\\alpha=5/L$，指数项的参数得以简化。$k^2/(4\\alpha^2)$ 项变为：\n$$\n\\frac{k^2}{4\\alpha^2} = \\frac{\\|\\frac{2\\pi}{L}\\mathbf{n}\\|^2}{4(5/L)^2} = \\frac{(4\\pi^2/L^2)\\|\\mathbf{n}\\|^2}{100/L^2} = \\frac{\\pi^2\\|\\mathbf{n}\\|^2}{25}\n$$\n通过代入 $V=L^3$、$k^2 = (4\\pi^2/L^2)\\|\\mathbf{n}\\|^2$ 和简化的指数参数，能量表达式可以重写为：\n$$\nE_{\\mathrm{rec}} = \\frac{2\\pi}{L^3}\\sum_{\\mathbf{n}\\neq \\mathbf{0}} \\frac{e^{-\\pi^2\\|\\mathbf{n}\\|^2/25}}{ (4\\pi^2/L^2)\\|\\mathbf{n}\\|^2} |S(\\mathbf{k})|^2 = \\frac{1}{2\\pi L}\\sum_{\\mathbf{n}\\neq \\mathbf{0}} \\frac{e^{-\\pi^2\\|\\mathbf{n}\\|^2/25}}{\\|\\mathbf{n}\\|^2} |S(\\mathbf{k})|^2\n$$\n其中 $\\|\\mathbf{n}\\|^2 = n_x^2+n_y^2+n_z^2$。这种简化的形式在计算上是有利的，因为指数项与盒子长度 $L$ 无关。\n\n问题要求针对两种不同的求和方案计算该能量：\n1.  矩形方案 ($E_{\\mathrm{rec}}^{\\mathrm{rect}}$)，其中求和包含所有满足 $|n_x|\\le K_x$、 $|n_y|\\le K_y$、 $|n_z|\\le K_z$ 的整数矢量 $\\mathbf{n}$（不包括 $\\mathbf{n}=\\mathbf{0}$）。\n2.  球形方案 ($E_{\\mathrm{rec}}^{\\mathrm{sph}}$)，其中求和包含所有满足 $\\|\\mathbf{n}\\|^2 \\le K_{\\mathrm{sph}}^2$ 的 $\\mathbf{n}$（不包括 $\\mathbf{n}=\\mathbf{0}$）。\n\n然后计算相关性度量 $\\mathcal{D} = (E_{\\mathrm{rec}}^{\\mathrm{rect}}(\\mathcal{A}) - E_{\\mathrm{rec}}^{\\mathrm{rect}}(\\mathcal{B})) - (E_{\\mathrm{rec}}^{\\mathrm{sph}}(\\mathcal{A}) - E_{\\mathrm{rec}}^{\\mathrm{sph}}(\\mathcal{B}))$。该度量分离出了由求和网格几何形状引起的人为取向能量各向异性部分。\n\n计算方法是实现一个函数来计算给定参数集的 $E_{\\mathrm{rec}}$。该函数将使用 `numpy` 的矢量化操作以提高效率。\n1.  使用 `numpy.meshgrid` 生成整数索引 $(n_x, n_y, n_z)$ 的三维网格。\n2.  根据指定的求和方案（矩形或球形）构建一个布尔掩码来选择索引 $\\mathbf{n}$，并排除 $\\mathbf{n}=\\mathbf{0}$ 项。\n3.  对于所有选定的矢量 $\\mathbf{n}$，计算 $\\|\\mathbf{n}\\|^2$ 和点积 $\\mathbf{n}\\cdot\\hat{\\mathbf{u}}$。\n4.  计算余弦项的参数 $d\\,\\mathbf{k}\\cdot \\hat{\\mathbf{u}} = d \\frac{2\\pi}{L}(\\mathbf{n}\\cdot\\hat{\\mathbf{u}})$。\n5.  为每个 $\\mathbf{n}$ 计算 $|S(\\mathbf{k})|^2$ 的值。\n6.  为每个 $\\mathbf{n}$ 组合出完整的项 $\\frac{e^{-\\pi^2\\|\\mathbf{n}\\|^2/25}}{\\|\\mathbf{n}\\|^2} |S(\\mathbf{k})|^2$。\n7.  将所有项相加，并乘以最终的前置因子 $\\frac{1}{2\\pi L}$，得到总的倒易空间能量。\n\n对每种取向（$\\mathcal{A}$ 和 $\\mathcal{B}$）和每种求和方案（矩形和球形）重复此过程，以获得计算每个测试用例的 $\\mathcal{D}$ 所需的四个能量值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_reciprocal_energy(L, d, u_vec, K_params, summation_type):\n    \"\"\"\n    Calculates the reciprocal-space Ewald energy for a given set of parameters.\n\n    Args:\n        L (float): Side length of the cubic simulation cell.\n        d (float): Separation distance in the molecular model.\n        u_vec (np.ndarray): Unit vector defining the molecular orientation.\n        K_params (tuple): Cutoff parameters. For 'rect', (Kx, Ky, Kz). For 'sph', (K_sph,).\n        summation_type (str): Type of summation, 'rect' or 'sph'.\n\n    Returns:\n        float: The calculated reciprocal-space energy.\n    \"\"\"\n    # The Ewald parameter alpha is fixed by the problem statement as 5/L.\n    # This leads to a simplified exponential term exp(-pi^2 * n^2 / 25).\n    # The overall energy expression is:\n    # E_rec = (1 / (2*pi*L)) * sum_{n!=0} [ exp(-pi^2*|n|^2/25) / |n|^2 ] * |S(k)|^2\n    \n    if summation_type == 'rect':\n        Kx, Ky, Kz = K_params\n        nx_range = np.arange(-Kx, Kx + 1)\n        ny_range = np.arange(-Ky, Ky + 1)\n        nz_range = np.arange(-Kz, Kz + 1)\n        NX, NY, NZ = np.meshgrid(nx_range, ny_range, nz_range, indexing='ij')\n        N_squared = NX**2 + NY**2 + NZ**2\n        mask = N_squared > 0\n\n    elif summation_type == 'sph':\n        K_sph = K_params[0]\n        K_max = int(np.floor(K_sph))\n        n_range = np.arange(-K_max, K_max + 1)\n        NX, NY, NZ = np.meshgrid(n_range, n_range, n_range, indexing='ij')\n        N_squared = NX**2 + NY**2 + NZ**2\n        mask = (N_squared > 0)  (N_squared = K_sph**2)\n    \n    else:\n        raise ValueError(\"summation_type must be 'rect' or 'sph'\")\n\n    # Apply the mask to get flattened arrays of valid indices\n    nx = NX[mask]\n    ny = NY[mask]\n    nz = NZ[mask]\n    n_squared = N_squared[mask]\n\n    # Calculate |S(k)|^2 term for all valid k vectors\n    # S(k) = 2 * (cos(d * k.u) - 1)\n    # k.u = (2*pi/L) * (n.u)\n    n_dot_u = nx * u_vec[0] + ny * u_vec[1] + nz * u_vec[2]\n    cos_arg = d * (2.0 * np.pi / L) * n_dot_u\n    S_k = 2.0 * (np.cos(cos_arg) - 1.0)\n    S_k_squared = S_k**2\n\n    # Calculate the summand for each n\n    # The exponential term simplifies because alpha = 5/L\n    exp_term = np.exp(- (np.pi**2) * n_squared / 25.0)\n    \n    summand = (exp_term / n_squared) * S_k_squared\n\n    # Sum all terms and multiply by the final prefactor\n    total_energy = (1.0 / (2.0 * np.pi * L)) * np.sum(summand)\n    \n    return total_energy\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: L=4.0, d=0.45, (Kx,Ky,Kz)=(16,8,8), Ksph=12\n        {'L': 4.0, 'd': 0.45, 'K_rect': (16, 8, 8), 'K_sph': 12.0},\n        # Case 2: L=4.0, d=0.45, (Kx,Ky,Kz)=(12,12,12), Ksph=12\n        {'L': 4.0, 'd': 0.45, 'K_rect': (12, 12, 12), 'K_sph': 12.0},\n        # Case 3: L=8.0, d=0.45, (Kx,Ky,Kz)=(16,8,8), Ksph=12\n        {'L': 8.0, 'd': 0.45, 'K_rect': (16, 8, 8), 'K_sph': 12.0},\n    ]\n\n    # Define molecular orientations\n    u_A = np.array([1.0, 0.0, 0.0])\n    u_B = np.array([1.0, 1.0, 1.0]) / np.sqrt(3.0)\n    \n    results = []\n    \n    for case in test_cases:\n        L = case['L']\n        d = case['d']\n        K_rect = case['K_rect']\n        K_sph = case['K_sph']\n\n        # Calculate energies for rectangular cutoff\n        E_rect_A = calculate_reciprocal_energy(L, d, u_A, K_rect, 'rect')\n        E_rect_B = calculate_reciprocal_energy(L, d, u_B, K_rect, 'rect')\n        \n        # Calculate energies for spherical cutoff\n        E_sph_A = calculate_reciprocal_energy(L, d, u_A, (K_sph,), 'sph')\n        E_sph_B = calculate_reciprocal_energy(L, d, u_B, (K_sph,), 'sph')\n        \n        # Calculate energy differences\n        Delta_E_rect = E_rect_A - E_rect_B\n        Delta_E_sph = E_sph_A - E_sph_B\n        \n        # Calculate the correlation metric D\n        D_metric = Delta_E_rect - Delta_E_sph\n        results.append(D_metric)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}