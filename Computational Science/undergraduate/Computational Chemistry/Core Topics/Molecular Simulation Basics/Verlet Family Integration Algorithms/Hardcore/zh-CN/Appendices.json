{
    "hands_on_practices": [
        {
            "introduction": "速度Verlet算法特有的“kick-drift-kick”结构并非随意的设计，它对于保证长期能量稳定性至关重要。本练习旨在挑战你分析一个看似合理但存在缺陷的积分方案。通过此练习，你将深入理解为何破坏算法的对称性会导致非物理性的能量漂移，从而体会到Verlet算法设计的精妙之处。",
            "id": "2466845",
            "problem": "考虑一个质量为 $m$ 的一维粒子，在光滑的保守势 $V(x)$ 中运动，其受力为 $F(x)=-\\frac{dV}{dx}$。总能量为 $H(x,v)=\\frac{1}{2} m v^{2}+V(x)$。在时间步长为 $\\Delta t$ 的标准速度Verlet积分器中，更新是按照一个半步速度更新、一个全步位置更新和第二个半步速度更新的对称序列进行的，所有更新都使用与相应位置处相同势能评估相一致的力。\n\n假设您实现了以下方案，其中用于位置和速度更新的力没有以对称、一致的方式使用：\n- 使用步初的力更新位置：\n$$x_{n+1}=x_{n}+\\Delta t\\, v_{n}+\\frac{\\Delta t^{2}}{2 m}\\,F(x_{n}).$$\n- 仅使用步末的力更新速度（没有半步分裂）：\n$$v_{n+1}=v_{n}+\\frac{\\Delta t}{m}\\,F(x_{n+1}).$$\n\n假设 $V(x)$ 是光滑的，并且选择的步长 $\\Delta t$ 足够小，以至于对于所研究的系统，该方案在许多步长后仍是数值稳定的。与标准速度Verlet方法（该方法在长时间内能保持能量近似恒定且振荡有界）相比，下列哪项陈述最能描述在上述不一致力更新下总能量 $H(x,v)$ 的长时间行为？\n\nA. 总能量在任意长的模拟时间内保持近似恒定，并伴有 $O(\\Delta t^{2})$ 阶的有界小幅振荡，如同在辛、时间可逆的方案中一样。\n\nB. 总能量在长时间内表现出长期漂移，通常平均而言是单调的（增加或减少取决于系统和 $\\Delta t$），因为该方案既不是辛的也不是时间可逆的。\n\nC. 只要力 $F(x)$ 是保守的，总能量在任何 $\\Delta t$ 下都是逐步精确守恒的，因为力源于一个势。\n\nD. 总能量围绕精确值进行无偏随机游走，没有系统性漂移；其均值保持恒定，而其方差仅因时间离散化噪声而以 $O(t)$ 的形式增长。",
            "solution": "在尝试解答之前，必须验证问题陈述。\n\n### 步骤 1：提取已知条件\n- 一个质量为 $m$ 的一维粒子在光滑的保守势 $V(x)$ 中运动。\n- 力：$F(x) = -\\frac{dV}{dx}$。\n- 总能量：$H(x,v)=\\frac{1}{2} m v^{2}+V(x)$。\n- 一个提出的数值积分方案，时间步长为 $\\Delta t$：\n  1. 位置更新：$x_{n+1}=x_{n}+\\Delta t\\, v_{n}+\\frac{\\Delta t^{2}}{2 m}\\,F(x_{n})$。\n  2. 速度更新：$v_{n+1}=v_{n}+\\frac{\\Delta t}{m}\\,F(x_{n+1})$。\n- 假设：$V(x)$ 是光滑的，且 $\\Delta t$ 小到足以保证数值稳定性。\n- 问题：描述在此方案下总能量 $H(x,v)$ 的长时间行为。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题设置在经典力学和数值积分方法（特别是分子动力学）的背景下，这是计算物理和化学中的一个标准课题。方程定义明确。该问题在科学上是合理的。\n- **适定性：** 积分方案被明确定义。问题要求一个特定量（能量）的长期行为，这可以使用微分方程数值方法理论进行分析。该问题是适定的。\n- **客观性：** 问题使用精确的数学语言陈述，没有主观性或模糊性。\n\n### 步骤 3：结论与行动\n问题陈述在科学上是合理的、适定的和客观的。它是 **有效的**。将推导解答。\n\n问题的核心是确定给定数值方案的长期能量守恒特性。像标准速度Verlet算法这类方法出色的长期能量稳定性源于其几何特性，即 **辛性** 和 **时间可逆性**。我们必须研究提出的方案是否具备这些特性。\n\n从时间 $t_n$ 的状态 $(x_n, v_n)$ 到时间 $t_{n+1}$ 的状态 $(x_{n+1}, v_{n+1})$ 的映射由以下公式给出：\n$$x_{n+1} = x_n + \\Delta t \\, v_n + \\frac{\\Delta t^2}{2m} F(x_n)$$\n$$v_{n+1} = v_n + \\frac{\\Delta t}{m} F(x_{n+1})$$\n\n**1. 时间可逆性分析**\n一个方案是时间可逆的，如果从 $(x_{n+1}, v_{n+1})$ 开始，以步长 $-\\Delta t$ 向后演化，我们能恢复 $(x_n, v_n)$。后向步长方程将是：\n$$x'_{n} = x_{n+1} - \\Delta t\\, v_{n+1} + \\frac{(-\\Delta t)^2}{2m} F(x_{n+1}) = x_{n+1} - \\Delta t\\, v_{n+1} + \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$v'_{n} = v_{n+1} + \\frac{-\\Delta t}{m} F(x'_{n})$$\n我们检查 $x'_n = x_n$ 是否成立。代入 $v_{n+1}$ 的前向表达式：\n$$x'_{n} = x_{n+1} - \\Delta t \\left( v_n + \\frac{\\Delta t}{m} F(x_{n+1}) \\right) + \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$x'_{n} = x_{n+1} - \\Delta t v_n - \\frac{\\Delta t^2}{m} F(x_{n+1}) + \\frac{\\Delta t^2}{2m} F(x_{n+1}) = x_{n+1} - \\Delta t v_n - \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n现在代入 $x_{n+1}$ 的前向表达式：\n$$x'_{n} = \\left( x_n + \\Delta t v_n + \\frac{\\Delta t^2}{2m} F(x_n) \\right) - \\Delta t v_n - \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$x'_{n} = x_n + \\frac{\\Delta t^2}{2m} \\left( F(x_n) - F(x_{n+1}) \\right)$$\n因为通常情况下 $F(x_n) \\neq F(x_{n+1})$，所以我们有 $x'_n \\neq x_n$。该方案 **不是时间可逆的**。\n\n**2. 辛性分析**\n对于一个哈密顿系统，如果映射 $(x_n, v_n) \\to (x_{n+1}, v_{n+1})$ 的雅可比矩阵的行列式恰好为 $1$，则该单步数值方法是辛的。雅可比矩阵是 $J = \\begin{pmatrix} \\frac{\\partial x_{n+1}}{\\partial x_n} & \\frac{\\partial x_{n+1}}{\\partial v_n} \\\\ \\frac{\\partial v_{n+1}}{\\partial x_n} & \\frac{\\partial v_{n+1}}{\\partial v_n} \\end{pmatrix}$。设 $F'(x) = dF/dx$。\n偏导数是：\n$$\\frac{\\partial x_{n+1}}{\\partial x_n} = 1 + \\frac{\\Delta t^2}{2m} F'(x_n)$$\n$$\\frac{\\partial x_{n+1}}{\\partial v_n} = \\Delta t$$\n对于 $v_{n+1}$ 的导数，我们必须使用链式法则，因为 $v_{n+1}$ 依赖于 $x_{n+1}$，而 $x_{n+1}$ 又依赖于 $(x_n, v_n)$。\n$$\\frac{\\partial v_{n+1}}{\\partial x_n} = \\frac{\\partial v_{n+1}}{\\partial x_{n+1}} \\frac{\\partial x_{n+1}}{\\partial x_n} = \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right)$$\n$$\\frac{\\partial v_{n+1}}{\\partial v_n} = 1 + \\frac{\\partial v_{n+1}}{\\partial x_{n+1}} \\frac{\\partial x_{n+1}}{\\partial v_n} = 1 + \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) (\\Delta t) = 1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})$$\n行列式是：\n$$\\det(J) = \\left(\\frac{\\partial x_{n+1}}{\\partial x_n}\\right)\\left(\\frac{\\partial v_{n+1}}{\\partial v_n}\\right) - \\left(\\frac{\\partial x_{n+1}}{\\partial v_n}\\right)\\left(\\frac{\\partial v_{n+1}}{\\partial x_n}\\right)$$\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right)\\left(1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})\\right) - (\\Delta t) \\left[ \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) \\right]$$\n提取公因式 $(1 + \\frac{\\Delta t^2}{2m} F'(x_n))$:\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) \\left[ \\left(1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})\\right) - \\frac{\\Delta t^2}{m} F'(x_{n+1}) \\right]$$\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) [1] = 1 + \\frac{\\Delta t^2}{2m} F'(x_n)$$\n为了使方案是辛的，$\\det(J)$ 必须恒等于 $1$。这仅在 $F'(x_n)=0$（例如，恒力）或 $\\Delta t=0$ 时成立，而这两种情况通常都不成立。因此，该方案 **不是辛的**。\n\n**3. 对能量守恒的影响**\n像速度Verlet这样的辛、时间可逆积分器会守恒一个与真实哈密顿量非常接近的“影子哈密顿量”。这个特性确保了总能量误差在任意长的模拟时间内保持有界，表现为小幅振荡。\n非辛积分器，如此处给出的积分器，不守恒一个邻近的影子哈密顿量。$\\det(J) \\neq 1$ 这个事实意味着该算法不保持相空间体积。这种对哈密顿动力学几何结构的违反导致了总能量中系统性的、累积的误差。这种长期的、非振荡的趋势被称为 **长期漂移**。能量通常会单调地偏离其初始值。漂移的方向（增加或减少）取决于项 $\\frac{\\Delta t^2}{2m}F'(x)$ 的符号，而这又取决于势能。例如，在简谐振子中，$V(x) = \\frac{1}{2}kx^2$，所以 $F(x) = -kx$ 且 $F'(x) = -k  0$。在这种情况下，$\\det(J)  1$，导致能量系统性地减少。\n\n结论是，所提出的方案既不是辛的也不是时间可逆的，将表现出以长期漂移为特征的较差的长期能量守恒性。\n\n### 逐项分析\n\n**A. 总能量在任意长的模拟时间内保持近似恒定，并伴有 $O(\\Delta t^{2})$ 阶的有界小幅振荡，如同在辛、时间可逆的方案中一样。**\n这描述了像速度Verlet这样的辛积分器的行为。如上所示，给定的方案不是辛的或时间可逆的。因此，它不会表现出这种有利的能量行为。\n结论：**不正确**。\n\n**B. 总能量在长时间内表现出长期漂移，通常平均而言是单调的（增加或减少取决于系统和 $\\Delta t$），因为该方案既不是辛的也不是时间可逆的。**\n这个陈述准确地描述了将一个缺乏辛性和时间可逆性的数值积分器应用于保守系统时的后果。我们的分析已经证实该方案缺乏这些特性。因此，能量的长期漂移是预期的行为。\n结论：**正确**。\n\n**C. 只要力 $F(x)$ 是保守的，总能量在任何 $\\Delta t$ 下都是逐步精确守恒的，因为力源于一个势。**\n这在根本上是错误的。力的保守性质保证了*连续*物理系统的能量守恒，而不是其离散数值近似的能量守恒。大多数数值积分器，包括这一个，在每一步都会引入离散化误差，导致数值能量发生变化。对单步能量变化 $\\Delta H = H_{n+1} - H_n$ 的显式计算表明它非零，并且是 $O(\\Delta t^2)$ 阶的。\n结论：**不正确**。\n\n**D. 总能量围绕精确值进行无偏随机游走，没有系统性漂移；其均值保持恒定，而其方差仅因时间离散化噪声而以 $O(t)$ 的形式增长。**\n这是不正确的。每一步引入的误差不是随机的，而是系统性的。对于一个典型的轨迹，每步的能量变化 $\\Delta H_n$ 有一个非零的平均值。这些系统性的、单向的误差的累积导致了长期漂移，而不是无偏随机游走。能量误差的均值不会保持恒定，而是会随时间漂移。\n结论：**不正确**。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "真实世界的模拟常常包含非平滑的事件，例如碰撞或突然的外部冲击。本练习探讨如何正确地修改Verlet算法以处理瞬时冲量。这不仅能让你掌握处理不连续性的关键技巧，即在不连续点处分割时间步长，还能加深你对维持物理解释精确性的理解。",
            "id": "2466805",
            "problem": "在分子动力学 (MD) 模拟中，考虑一个质量为 $m$ 的单个粒子，在一个光滑保守力 $\\mathbf{F}_c(\\mathbf{r})=-\\nabla U(\\mathbf{r})$ 的作用下运动，并且在一个时间步内的已知时间 $t_k$ 受到一个已知的冲力。使用的积分器是速度 Verlet 算法，时间步长固定为 $\\Delta t$。在时间 $t_n$ 的状态已知为 $(\\mathbf{r}_n,\\mathbf{v}_n)$，相应的加速度为 $\\mathbf{a}_n=\\mathbf{F}_c(\\mathbf{r}_n)/m$。在长度为 $\\Delta t$ 的区间 $[t_n,t_{n+1})$ 内，于时间 $t_k \\in (t_n,t_{n+1})$ 发生一个单一的冲量事件，给予粒子一个总冲量 $\\mathbf{J}$。令 $\\theta=(t_k-t_n)/\\Delta t \\in (0,1)$，并定义 $\\Delta t_1=\\theta \\,\\Delta t$ 和 $\\Delta t_2=(1-\\theta)\\,\\Delta t$。\n\n对速度 Verlet 更新的哪种修正能够正确处理冲力（在 $\\Delta t$ 的主导阶上），与冲量-动量定理一致，并且在 $t_k$ 时刻施加正确的动量跳变的同时保持位置的连续性？\n\nA. 在 $t_k$ 处分割时间步，在 $[t_n,t_k)$ 和 $[t_k,t_{n+1})$ 上使用速度 Verlet 算法对光滑动力学进行积分，并在 $t_k$ 时刻施加一个瞬时速度更新：\n- 时长为 $\\Delta t_1$ 的第一个子步：\n$\\mathbf{r}_k^-=\\mathbf{r}_n+\\mathbf{v}_n \\Delta t_1+\\tfrac{1}{2}\\mathbf{a}_n \\Delta t_1^2$，然后 $\\mathbf{a}_k^-=\\mathbf{F}_c(\\mathbf{r}_k^-)/m$，以及 $\\mathbf{v}_k^-=\\mathbf{v}_n+\\tfrac{1}{2}(\\mathbf{a}_n+\\mathbf{a}_k^-)\\Delta t_1$。\n- 在 $t_k$ 时刻的冲量： $\\mathbf{r}_k^+=\\mathbf{r}_k^-$，$\\mathbf{v}_k^+=\\mathbf{v}_k^-+\\mathbf{J}/m$，以及 $\\mathbf{a}_k^+=\\mathbf{F}_c(\\mathbf{r}_k^+)/m$。\n- 时长为 $\\Delta t_2$ 的第二个子步：\n$\\mathbf{r}_{n+1}=\\mathbf{r}_k^+ + \\mathbf{v}_k^+ \\Delta t_2 + \\tfrac{1}{2}\\mathbf{a}_k^+ \\Delta t_2^2$，然后 $\\mathbf{a}_{n+1}=\\mathbf{F}_c(\\mathbf{r}_{n+1})/m$，以及 $\\mathbf{v}_{n+1}=\\mathbf{v}_k^+ + \\tfrac{1}{2}(\\mathbf{a}_k^+ + \\mathbf{a}_{n+1})\\Delta t_2$。\n\nB. 不分割时间步；在更新过程中，通过使用有效加速度 $\\mathbf{a}(t)\\mapsto \\mathbf{a}(t)+\\mathbf{J}/(m\\Delta t)$，将冲量视为在整个时间步上的一个均匀附加加速度：\n$\\mathbf{r}_{n+1}=\\mathbf{r}_n+\\mathbf{v}_n \\Delta t + \\tfrac{1}{2}\\mathbf{a}_n \\Delta t^2 + \\tfrac{1}{2}(\\mathbf{J}/m)\\Delta t$，然后 $\\mathbf{a}_{n+1}=\\mathbf{F}_c(\\mathbf{r}_{n+1})/m$，以及 $\\mathbf{v}_{n+1}=\\mathbf{v}_n+\\tfrac{1}{2}(\\mathbf{a}_n+\\mathbf{a}_{n+1})\\Delta t + \\mathbf{J}/m$。\n\nC. 在 $t_k$ 处分割时间步，但在冲量作用时强制一个瞬时位置跳变而保持速度连续：在 $t_k$ 时刻，设 $\\mathbf{r}_k^+=\\mathbf{r}_k^-+\\mathbf{J}/m$ 和 $\\mathbf{v}_k^+=\\mathbf{v}_k^-$，并在冲量前后使用标准的速度 Verlet 算法。\n\nD. 不修改位置更新且不分割时间步；在 $\\Delta t$ 上执行一个标准的速度 Verlet 步骤以获得 $(\\mathbf{r}_{n+1},\\mathbf{v}_{n+1})$，然后仅在最后通过设置 $\\mathbf{v}_{n+1}\\leftarrow \\mathbf{v}_{n+1}+\\mathbf{J}/m$ 来施加冲量。",
            "solution": "必须首先严格验证问题陈述的科学性和逻辑完整性。\n\n### 第1步：提取已知条件\n- 系统：一个质量为 $m$ 的单个粒子。\n- 积分器：速度 Verlet 算法，固定时间步长为 $\\Delta t$。\n- 在时间 $t_n$ 的状态：位置 $\\mathbf{r}_n$，速度 $\\mathbf{v}_n$。\n- 在 $t_n$ 时的力和加速度：一个光滑保守力 $\\mathbf{F}_c(\\mathbf{r})=-\\nabla U(\\mathbf{r})$，产生加速度 $\\mathbf{a}_n=\\mathbf{F}_c(\\mathbf{r}_n)/m$。\n- 冲量事件：在已知时间 $t_k \\in (t_n, t_{n+1})$，一个单一的冲量事件给予粒子一个总冲量 $\\mathbf{J}$。\n- 时间定义：\n    - 完整的时间步从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$。\n    - 冲量时间为 $t_k$，其中 $t_n  t_k  t_{n+1}$。\n    - 冲量的分数时间为 $\\theta=(t_k-t_n)/\\Delta t \\in (0,1)$。\n    - 第一个子步的时长为 $\\Delta t_1 = \\theta \\Delta t = t_k - t_n$。\n    - 第二个子步的时长为 $\\Delta t_2 = (1-\\theta)\\Delta t = t_{n+1} - t_k$。\n- 问题：确定速度 Verlet 算法的正确修正，该修正能在 $\\Delta t$ 的主导阶上处理冲量，与冲量-动量定理一致，并在 $t_k$ 时刻施加正确的动量跳变的同时保持位置连续性。\n\n### 第2步：使用提取的已知条件进行验证\n根据有效性标准对问题陈述进行分析。\n\n- **科学基础**：该问题设置在经典力学和数值分析的框架内。它涉及标准概念：牛顿运动方程、保守力、冲力、冲量-动量定理以及速度 Verlet 积分算法。所有这些概念在物理学和计算科学中都已成熟。该问题在科学上是合理的。\n- **适定性**：该问题提供了所有必要信息：系统、动力学（光滑的和冲量的）、数值方法以及给定步骤的初始状态。问题是具体的，要求一个满足明确陈述的物理和数值约束的算法。可以从第一性原理推导出唯一正确的解法。该问题是适定的。\n- **客观性**：语言是技术性的、精确的，并且没有歧义或主观性。所有量都经过了正式定义。\n\n### 第3步：结论与行动\n问题陈述在科学上是合理的、适定的、客观的和自洽的。因此它是**有效的**。我将继续推导解决方案并评估所提供的选项。\n\n### 正确算法的推导\n这个问题的基础在于冲力的物理学原理。冲量 $\\mathbf{J}$ 是一个非常大的力 $\\mathbf{F}_{\\text{imp}}$ 在一个无穷小的时间段内作用的结果。冲量-动量定理指出：\n$$ \\mathbf{J} = \\int \\mathbf{F}_{\\text{imp}}(t) dt = \\Delta\\mathbf{p} $$\n其中 $\\mathbf{p}=m\\mathbf{v}$ 是动量。该定理规定了系统状态变量在 $t_k$ 时刻冲量瞬间的行为。\n\n1.  **对速度的影响**：动量的变化是瞬时的，导致速度出现一个有限的不连续性（一个跳变）：\n    $$ \\mathbf{p}(t_k^+) - \\mathbf{p}(t_k^-) = \\mathbf{J} \\implies m\\mathbf{v}(t_k^+) - m\\mathbf{v}(t_k^-) = \\mathbf{J} $$\n    $$ \\mathbf{v}(t_k^+) = \\mathbf{v}(t_k^-) + \\frac{\\mathbf{J}}{m} $$\n    这里，$t_k^-$ 和 $t_k^+$ 分别表示冲量作用前后的瞬间。\n\n2.  **对位置的影响**：位置是速度的时间积分，$\\mathbf{r}(t) = \\mathbf{r}(t_0) + \\int_{t_0}^t \\mathbf{v}(\\tau)d\\tau$。被积函数 $\\mathbf{v}(t)$ 在单一点 $t_k$ 处的有限跳变不连续性不会改变跨越该点的积分值。因此，位置必须是连续的：\n    $$ \\mathbf{r}(t_k^+) = \\mathbf{r}(t_k^-) $$\n    位置的瞬时跳变意味着无穷大的速度，这在物理上是无意义的。\n\n速度 Verlet 算法是为具有平滑变化力的系统设计的。δ函数形式的冲力的存在违反了这一假设。在数值积分中处理这种已知不连续性的标准且正确的程序是在不连续点处分割积分区间。\n\n总时间步 $[t_n, t_{n+1}]$ 必须被分割成两个子步：$[t_n, t_k]$ 和 $[t_k, t_{n+1}]$。\n\n**子步1：从 $t_n$ 到 $t_k$ 的积分**\n在这个时长为 $\\Delta t_1 = \\theta \\Delta t$ 的区间内，粒子只受到光滑保守力 $\\mathbf{F}_c$ 的作用。我们应用时间步长为 $\\Delta t_1$ 的标准速度 Verlet 算法：\n- 首先，将位置更新到 $t_k$：\n  $$ \\mathbf{r}_k^- = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t_1 + \\frac{1}{2}\\mathbf{a}_n \\Delta t_1^2 $$\n- 在这个新位置上计算加速度：\n  $$ \\mathbf{a}_k^- = \\frac{\\mathbf{F}_c(\\mathbf{r}_k^-)}{m} $$\n- 将速度更新到 $t_k$：\n  $$ \\mathbf{v}_k^- = \\mathbf{v}_n + \\frac{1}{2}(\\mathbf{a}_n + \\mathbf{a}_k^-) \\Delta t_1 $$\n这给出了冲量作用前的状态 $(\\mathbf{r}_k^-, \\mathbf{v}_k^-)$。\n\n**在 $t_k$ 时刻施加冲量**\n我们现在应用冲量的物理条件：\n- 位置是连续的：\n  $$ \\mathbf{r}_k^+ = \\mathbf{r}_k^- $$\n- 速度根据冲量-动量定理发生跳变：\n  $$ \\mathbf{v}_k^+ = \\mathbf{v}_k^- + \\frac{\\mathbf{J}}{m} $$\n- 光滑力 $\\mathbf{F}_c$ 只依赖于位置。由于位置是连续的，由该力引起的加速度也是连续的：\n  $$ \\mathbf{a}_k^+ = \\frac{\\mathbf{F}_c(\\mathbf{r}_k^+)}{m} = \\frac{\\mathbf{F}_c(\\mathbf{r}_k^-)}{m} = \\mathbf{a}_k^- $$\n\n**子步2：从 $t_k$ 到 $t_{n+1}$ 的积分**\n我们现在在时间 $t_k$ 有了新的初始状态 $(\\mathbf{r}_k^+, \\mathbf{v}_k^+)$ 和初始加速度 $\\mathbf{a}_k^+$。我们再次使用速度 Verlet 算法，在时长为 $\\Delta t_2 = (1-\\theta)\\Delta t$ 的剩余时间区间上向前积分：\n- 将位置更新到 $t_{n+1}$：\n  $$ \\mathbf{r}_{n+1} = \\mathbf{r}_k^+ + \\mathbf{v}_k^+ \\Delta t_2 + \\frac{1}{2}\\mathbf{a}_k^+ \\Delta t_2^2 $$\n- 计算最终加速度：\n  $$ \\mathbf{a}_{n+1} = \\frac{\\mathbf{F}_c(\\mathbf{r}_{n+1})}{m} $$\n- 更新最终速度：\n  $$ \\mathbf{v}_{n+1} = \\mathbf{v}_k^+ + \\frac{1}{2}(\\mathbf{a}_k^+ + \\mathbf{a}_{n+1}) \\Delta t_2 $$\n这个过程正确且精确地将冲量事件整合到动力学中，既尊重了其物理基础，也尊重了数值积分器的结构。\n\n### 选项评估\n\n**A. 在 $t_k$ 处分割时间步，在 $[t_n,t_k)$ 和 $[t_k,t_{n+1})$ 上使用速度 Verlet 算法对光滑动力学进行积分，并在 $t_k$ 时刻施加一个瞬时速度更新： ...**\n此选项中描述的操作顺序是：\n1.  一个从 $t_n$ 到 $t_k$、步长为 $\\Delta t_1$ 的速度 Verlet 步。\n2.  在 $t_k$ 时刻施加一个冲量，此时 $\\mathbf{r}$ 是连续的，而 $\\mathbf{v}$ 跳变 $\\mathbf{J}/m$。\n3.  第二个从 $t_k$ 到 $t_{n+1}$、步长为 $\\Delta t_2$ 的速度 Verlet 步。\n这与从第一性原理推导出的过程完全匹配。它在不连续点处正确地分割了时间步，恰当地应用了冲量规则（位置连续性，速度跳变），并在光滑部分正确地使用了积分器。\n结论：**正确**。\n\n**B. 不分割时间步；在更新过程中，通过使用有效加速度 $\\mathbf{a}(t)\\mapsto \\mathbf{a}(t)+\\mathbf{J}/(m\\Delta t)$，将冲量视为在整个时间步上的一个均匀附加加速度： ...**\n这个方法建议通过定义一个恒定的背景力 $\\mathbf{F}_{\\text{eff}} = \\mathbf{J}/\\Delta t$ 来将瞬时冲量“涂抹”到整个时间步 $\\Delta t$ 上。这是一个物理上不正确的表示。冲量发生在特定的时间 $t_k$，而不是在 $[t_n, t_{n+1}]$ 上均匀发生。这种近似没能在正确的时间 $t_k$ 施加动量跳变，而是在整个时间步上产生了一个连续的、线性的速度变化（在由 $\\mathbf{F}_c$ 引起的变化之上）。这会给轨迹带来误差，因为涂抹后的力的效应甚至在冲量物理上发生之前（在区间 $[t_n, t_k)$ 内）就被施加了。这违反了问题的一个关键要求。\n结论：**不正确**。\n\n**C. 在 $t_k$ 处分割时间步，但在冲量作用时强制一个瞬时位置跳变而保持速度连续：在 $t_k$ 时刻，设 $\\mathbf{r}_k^+=\\mathbf{r}_k^-+\\mathbf{J}/m$ 和 $\\mathbf{v}_k^+=\\mathbf{v}_k^-$，并在冲量前后使用标准的速度 Verlet 算法。**\n这个选项从根本上误解了冲量的物理原理。如前所推导，冲力导致动量（因此是速度）的不连续，而不是位置。声称位置发生瞬时跳变，$\\mathbf{r}_k^+ \\neq \\mathbf{r}_k^-$，意味着在 $t_k$ 时刻速度为无穷大，这在物理上是不可能的。这个选项直接与问题本身陈述的位置连续性要求以及基本力学原理相矛盾。\n结论：**不正确**。\n\n**D. 不修改位置更新且不分割时间步；在 $\\Delta t$ 上执行一个标准的速度 Verlet 步骤以获得 $(\\mathbf{r}_{n+1},\\mathbf{v}_{n+1})$，然后仅在最后通过设置 $\\mathbf{v}_{n+1}\\leftarrow \\mathbf{v}_{n+1}+\\mathbf{J}/m$ 来施加冲量。**\n这个方法实际上将冲量从其发生的实际时间 $t_k$ 时间平移到了时间步的末尾 $t_{n+1}$。位置 $\\mathbf{r}_{n+1}$ 是在假设冲量从未发生的情况下通过对 $[t_n, t_{n+1}]$ 积分计算出来的。然而，真实的轨迹受到从时间 $t_k$ 开始的速度跳变 $\\mathbf{J}/m$ 的影响。这个速度变化本应在时长为 $\\Delta t_2=(1-\\theta)\\Delta t$ 的时间区间内影响位置。忽略这一点，计算出的 $\\mathbf{r}_{n+1}$ 将会是错误的。产生的位置误差为 $\\Delta \\mathbf{r} \\approx (\\mathbf{J}/m)\\Delta t_2 = (\\mathbf{J}/m)(1-\\theta)\\Delta t$，这是一个主导阶为 $\\mathcal{O}(\\Delta t)$ 的误差。这违反了在主导阶上正确处理冲量的要求。\n结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "最后的这项练习是一个综合性的编程挑战，将理论应用于实践。它将你的视野从简单的质点扩展到刚体的旋转动力学，这是分子动力学中的一个常见任务。你将使用四元数来表示物体朝向，并调整速度Verlet算法来积分欧拉运动方程，从而对该方法的强大功能和通用性获得深刻而实用的理解。",
            "id": "2466818",
            "problem": "实现一个程序，使用 Verlet 族的辛方法来演化一个模拟为线性刚性转子的刚性双原子分子的取向，其中取向由单位四元数表示。该双原子分子被模拟为两个点质量，其键轴在体坐标系中固定于物体的第三主轴上。设键的体坐标系单位矢量为 $\\mathbf{e}_3 = (0,0,1)$，并设体坐标系到空间坐标系的取向由单位四元数 $q = (q_0,q_1,q_2,q_3)$ 表示，采用标量优先约定。体坐标系角速度为 $\\boldsymbol{\\omega}_{\\mathrm{b}} = (\\omega_1,\\omega_2,\\omega_3)$，并始终受约束以满足 $\\omega_3 = 0$（无绕键轴的自旋）。空间坐标系中的键方向为 $\\mathbf{n}(t) = \\mathcal{R}(q(t))\\,\\mathbf{e}_3$，其中 $\\mathcal{R}(q)$ 是对应于 $q$ 的旋转。所有量都必须用国际单位制 (SI) 表示。\n\n该双原子分子由两个点质量 $m_1$ 和 $m_2$ 组成，它们之间由固定的键长 $L$ 分开。折合质量为 $\\mu = \\dfrac{m_1 m_2}{m_1 + m_2}$，非零主转动惯量相等，且对于任何垂直于键轴的轴，其值为 $I_\\perp = \\mu L^2$。绕键轴的主转动惯量为零；因此，允许的角速度必须始终保持垂直于键轴，即对于所有时间 $\\omega_3 = 0$。转动动能为\n$$\nK(t) = \\tfrac{1}{2} I_\\perp \\left(\\omega_1(t)^2 + \\omega_2(t)^2\\right).\n$$\n\n在存在均匀静电场 $\\mathbf{E}$ 的情况下，假设分子具有大小为 $p$ 的永久电偶极子，该偶极子与键轴刚性对齐，因此空间坐标系中的偶极子矢量为 $\\mathbf{p}(t) = p\\,\\mathbf{n}(t)$。则空间坐标系中的力矩为\n$$\n\\boldsymbol{\\tau}_{\\mathrm{s}}(t) = \\mathbf{p}(t) \\times \\mathbf{E} = p\\,\\mathbf{n}(t)\\times \\mathbf{E}.\n$$\n相应的体坐标系力矩为 $\\boldsymbol{\\tau}_{\\mathrm{b}}(t) = \\mathcal{R}(q(t))^\\top \\boldsymbol{\\tau}_{\\mathrm{s}}(t)$。体坐标系中的转动运动方程是 Euler 方程\n$$\n\\mathbf{I}\\,\\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}} = \\boldsymbol{\\tau}_{\\mathrm{b}} - \\boldsymbol{\\omega}_{\\mathrm{b}} \\times (\\mathbf{I}\\,\\boldsymbol{\\omega}_{\\mathrm{b}}),\n$$\n其中 $\\mathbf{I} = \\mathrm{diag}(I_\\perp, I_\\perp, 0)$。在 $\\omega_3 = 0$ 的约束下，并且当力矩在体坐标系中表示时没有沿键轴的分量时，角加速度的第三个分量为零，前两个分量满足\n$$\n\\dot{\\omega}_1 = \\dfrac{\\tau_{\\mathrm{b},1}}{I_\\perp},\\quad \\dot{\\omega}_2 = \\dfrac{\\tau_{\\mathrm{b},2}}{I_\\perp},\\quad \\dot{\\omega}_3 = 0.\n$$\n\n四元数运动学由下式给出\n$$\n\\dot{q} = \\tfrac{1}{2} \\, q \\otimes \\omega^\\flat,\n$$\n其中 $\\otimes$ 表示四元数乘法，$\\omega^\\flat = (0,\\omega_1,\\omega_2,\\omega_3)$ 是与体坐标系角速度相关联的纯虚四元数。取向四元数必须始终保持归一化。\n\n您的程序必须：\n1. 使用四元数实现一个 Verlet 族的时间积分器，用于转动动力学，以固定的时间步长 $\\Delta t$ 在指定的步数 $N$ 上推进 $(q,\\boldsymbol{\\omega}_{\\mathrm{b}})$。角速度必须始终满足 $\\omega_3=0$。每次更新后，四元数必须重新归一化为单位长度。力矩必须根据当前取向使用上述表达式计算。\n2. 对于 $\\mathbf{E} \\neq \\mathbf{0}$ 和 $p \\neq 0$ 的情况，将势能视为 $U(t) = -\\mathbf{p}(t)\\cdot\\mathbf{E} = -p\\,\\mathbf{n}(t)\\cdot \\mathbf{E}$。\n3. 计算下面每个测试用例所要求的定量输出。\n\n使用以下三个参数集的测试套件。对于每个用例，按指定初始化取向和角速度，以给定的步数和时间步长进行积分，并计算所要求的单个标量结果。\n\n测试用例 A（无力矩，能量守恒的“理想情况”）：\n- 参数：$m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$，$L = 1.0\\times 10^{-10}\\ \\mathrm{m}$，$\\mathbf{E} = (0,0,0)\\ \\mathrm{V/m}$，$p = 0\\ \\mathrm{C\\cdot m}$，$\\Delta t = 1.0\\times 10^{-15}\\ \\mathrm{s}$，$N = 2000$。\n- 初始条件：$q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$（因此 $\\mathbf{n}(0)$ 沿空间坐标系 $x$ 轴），以及 $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,1.0\\times 10^{12},\\,0)\\ \\mathrm{rad/s}$。\n- 要求输出：最终时刻的相对动能误差，\n$$\n\\varepsilon_K = \\dfrac{K(N\\Delta t) - K(0)}{K(0)},\n$$\n以无量纲浮点数形式表示。\n\n测试用例 B（电场下的取向，一般行为）：\n- 参数：$m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$，$L = 1.0\\times 10^{-10}\\ \\mathrm{m}$，$\\mathbf{E} = (0,0,1.0\\times 10^{7})\\ \\mathrm{V/m}$，$p = 3.33564\\times 10^{-30}\\ \\mathrm{C\\cdot m}$，$\\Delta t = 1.0\\times 10^{-15}\\ \\mathrm{s}$，$N = 10000$。\n- 初始条件：$q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ 以及 $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,0,\\,0)\\ \\mathrm{rad/s}$。\n- 要求输出：键方向与空间坐标系 $z$ 轴之间的最终极角（以弧度为单位），\n$$\n\\theta_{\\mathrm{f}} = \\arccos\\!\\big(n_z(N\\Delta t)\\big),\n$$\n以浮点数形式表示，单位为弧度。\n\n测试用例 C（边界条件：较大时间步长，无力矩，较粗分辨率下的能量守恒）：\n- 参数：$m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$，$L = 1.0\\times 10^{-10}\\ \\mathrm{m}$，$\\mathbf{E} = (0,0,0)\\ \\mathrm{V/m}$，$p = 0\\ \\mathrm{C\\cdot m}$，$\\Delta t = 5.0\\times 10^{-15}\\ \\mathrm{s}$，$N = 400$。\n- 初始条件：$q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ 以及 $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,1.0\\times 10^{12},\\,0)\\ \\mathrm{rad/s}$。\n- 要求输出：如上定义的相对动能误差 $\\varepsilon_K$。\n\n最终输出格式：您的程序应生成单行输出，其中包含按测试用例 A、测试用例 B、测试用例 C 顺序排列的三个结果，形式为方括号内以逗号分隔的列表。每个浮点数必须以包含 $10$ 位有效数字的科学记数法表示。例如，一个带有占位符的输出看起来会像\n$[a\\_1,a\\_2,a\\_3]$,\n其中每个 $a_i$ 的格式类似于 $x.xxxxxxxxx\\times 10^{y}$（例如，$1.2345678900\\mathrm{e}{-03}$）。不应打印任何其他文本。",
            "solution": "问题陈述已经过严谨分析，被认为是有效的。它构成了一个经典转动动力学中的适定初值问题，具有科学合理性，并为获得唯一解提供了所有必要的数据和约束。所有参数在物理上都是一致的。\n\n任务是使用 Verlet 族中的一种时间可逆、辛积分器来模拟线性刚性转子的转动动力学。系统的状态由其取向（由单位四元数 $q(t)$ 表示）和其在体坐标系中的角速度 $\\boldsymbol{\\omega}_{\\mathrm{b}}(t)$ 描述。我们将实现一个适用于转动运动的“速度 Verlet”算法。这类算法以其出色的长期能量守恒性而闻名，这是分子模拟中的一个关键特性。\n\n在离散时间步 $t_n = n\\Delta t$ 上的状态变量是四元数 $q_n = q(t_n)$ 和体坐标系角速度 $\\boldsymbol{\\omega}_{\\mathrm{b},n} = \\boldsymbol{\\omega}_{\\mathrm{b}}(t_n)$。体坐标系角加速度为 $\\boldsymbol{\\alpha}_{\\mathrm{b},n} = \\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}}(t_n)$。\n\n运动方程如下：\n1. 转动动力学（Euler 方程，为线性转子简化）：\n$$\n\\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}} = \\mathbf{I}^{-1} \\boldsymbol{\\tau}_{\\mathrm{b}}(q) \\equiv \\boldsymbol{\\alpha}_{\\mathrm{b}}(q)\n$$\n其中 $\\mathbf{I} = \\mathrm{diag}(I_\\perp, I_\\perp, 0)$ 是体坐标系中的对角惯性张量，体坐标系力矩 $\\boldsymbol{\\tau}_{\\mathrm{b}}$ 取决于取向 $q$。具体来说，对于垂直于键轴的分量，我们有 $\\dot{\\omega}_1 = \\tau_{\\mathrm{b},1}/I_\\perp$ 和 $\\dot{\\omega}_2 = \\tau_{\\mathrm{b},2}/I_\\perp$。我们强制约束 $\\omega_3 = 0$ 在所有时间都成立。\n\n2. 取向运动学：\n$$\n\\dot{q} = \\frac{1}{2} q \\otimes \\omega^\\flat_{\\mathrm{b}}\n$$\n其中 $\\otimes$ 表示四元数乘法，$\\omega^\\flat_{\\mathrm{b}} = (0, \\omega_1, \\omega_2, \\omega_3)$ 是角速度矢量 $\\boldsymbol{\\omega}_{\\mathrm{b}}$ 的纯四元数表示。\n\n速度 Verlet 算法按以下步骤将状态从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$：\n\n步骤 1：角速度的半步更新。\n使用当前的角加速度，将角速度推进半个时间步。\n$$\n\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} = \\boldsymbol{\\omega}_{\\mathrm{b}, n} + \\boldsymbol{\\alpha}_{\\mathrm{b}, n} \\frac{\\Delta t}{2}\n$$\n\n步骤 2：取向的全步更新。\n使用半步角速度 $\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}$ 将取向四元数更新一个完整的时间步 $\\Delta t$。对于一个恒定的角速度 $\\boldsymbol{\\omega}$，运动学方程的解是 $q(t) = q(0) \\otimes \\exp(\\frac{t}{2}\\omega^\\flat)$。我们通过假设在 $t_n$ 到 $t_{n+1}$ 的演化过程中角速度恒为 $\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}$ 来进行近似。更新通过与一个增量旋转四元数 $\\Delta q_n$ 相乘来执行：\n$$\nq_{n+1} = q_n \\otimes \\Delta q_n\n$$\n增量四元数 $\\Delta q_n$ 对应于绕轴 $\\hat{\\mathbf{u}} = \\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} / ||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}||$ 旋转角度 $\\theta = ||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}|| \\Delta t$。它由以下公式给出：\n$$\n\\Delta q_n = \\left(\\cos\\left(\\frac{\\theta}{2}\\right), \\sin\\left(\\frac{\\theta}{2}\\right)\\hat{\\mathbf{u}}\\right)\n$$\n如果 $||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}||$ 接近于零，则使用其泰勒展开来代替此表达式，以避免数值不稳定性。更新后，$q_{n+1}$ 被重新归一化为单位长度，$q_{n+1} \\leftarrow q_{n+1} / ||q_{n+1}||$，以抵消浮点误差累积。\n\n步骤 3：计算新的力矩和加速度。\n利用新的取向 $q_{n+1}$，我们计算新的物理状态。\n首先，空间坐标系中的键向矢量 $\\mathbf{n}_{n+1}$：\n$$\n\\mathbf{n}_{n+1} = \\mathcal{R}(q_{n+1}) \\mathbf{e}_3\n$$\n其中 $\\mathbf{e}_3 = (0,0,1)$，$\\mathcal{R}(q)$ 是对应于 $q=(q_0, q_1, q_2, q_3)$ 的旋转矩阵：\n$$\n\\mathcal{R}(q) = \\begin{pmatrix}\n1 - 2(q_2^2 + q_3^2)  2(q_1 q_2 - q_0 q_3)  2(q_1 q_3 + q_0 q_2) \\\\\n2(q_1 q_2 + q_0 q_3)  1 - 2(q_1^2 + q_3^2)  2(q_2 q_3 - q_0 q_1) \\\\\n2(q_1 q_3 - q_0 q_2)  2(q_2 q_3 + q_0 q_1)  1 - 2(q_1^2 + q_2^2)\n\\end{pmatrix}\n$$\n接下来，空间坐标系力矩 $\\boldsymbol{\\tau}_{\\mathrm{s}, n+1}$：\n$$\n\\boldsymbol{\\tau}_{\\mathrm{s}, n+1} = p \\, \\mathbf{n}_{n+1} \\times \\mathbf{E}\n$$\n这被转换到体坐标系：\n$$\n\\boldsymbol{\\tau}_{\\mathrm{b}, n+1} = \\mathcal{R}(q_{n+1})^\\top \\boldsymbol{\\tau}_{\\mathrm{s}, n+1}\n$$\n最后，新的体坐标系角加速度 $\\boldsymbol{\\alpha}_{\\mathrm{b}, n+1}$：\n$$\n\\alpha_{\\mathrm{b},1,n+1} = \\frac{\\tau_{\\mathrm{b},1,n+1}}{I_\\perp}, \\quad \\alpha_{\\mathrm{b},2,n+1} = \\frac{\\tau_{\\mathrm{b},2,n+1}}{I_\\perp}, \\quad \\alpha_{\\mathrm{b},3,n+1} = 0\n$$\n\n步骤 4：角速度的第二个半步更新。\n使用新的加速度更新角速度剩下的半步，完成从 $t_n$到 $t_{n+1}$ 的步骤：\n$$\n\\boldsymbol{\\omega}_{\\mathrm{b}, n+1} = \\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} + \\boldsymbol{\\alpha}_{\\mathrm{b}, n+1} \\frac{\\Delta t}{2}\n$$\n在每一步都强制执行约束 $\\omega_3 = 0$。\n\n该算法将为每个测试用例实现。\n对于用例 A 和 C（无力矩），$\\mathbf{E} = \\mathbf{0}$，这意味着力矩 $\\boldsymbol{\\tau}$ 和角加速度 $\\boldsymbol{\\alpha}_{\\mathrm{b}}$ 始终为零。该算法正确预测 $\\boldsymbol{\\omega}_{\\mathrm{b}}$ 保持恒定，从而实现完美的动能守恒，任何偏差仅由浮点算术限制引起。因此，相对能量误差 $\\varepsilon_K$ 预计接近机器精度。\n\n对于用例 B，非零电场 $\\mathbf{E}$ 和偶极矩 $p$ 会产生一个使分子重新取向的力矩。模拟会跟踪这一运动，最终的极角 $\\theta_{\\mathrm{f}}$ 是根据最终键矢量 $\\mathbf{n}(N\\Delta t)$ 的 $z$ 分量计算得出的，该分量由 $n_z = 1 - 2(q_1^2 + q_2^2)$ 给出。要求的输出是 $\\theta_{\\mathrm{f}} = \\arccos(n_z)$。\n实现将遵循这些步骤来生成指定的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Verlet integrator for rigid diatomic molecule rotation\n    and calculates results for the specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case A\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 0.0]), \"p\": 0.0,\n            \"dt\": 1.0e-15, \"N\": 2000,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 1.0e12, 0.0]),\n            \"output_type\": \"energy_error\"\n        },\n        # Test case B\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 1.0e7]), \"p\": 3.33564e-30,\n            \"dt\": 1.0e-15, \"N\": 10000,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 0.0, 0.0]),\n            \"output_type\": \"final_angle\"\n        },\n        # Test case C\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 0.0]), \"p\": 0.0,\n            \"dt\": 5.0e-15, \"N\": 400,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 1.0e12, 0.0]),\n            \"output_type\": \"energy_error\"\n        }\n    ]\n\n    results = []\n    \n    # Helper functions\n    def q_mult(q1, q2):\n        \"\"\"Quaternion multiplication q1*q2, scalar-first.\"\"\"\n        w1, x1, y1, z1 = q1\n        w2, x2, y2, z2 = q2\n        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n        y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2\n        z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2\n        return np.array([w, x, y, z])\n\n    def q_to_rot_matrix(q):\n        \"\"\"Rotation matrix from scalar-first quaternion.\"\"\"\n        q0, q1, q2, q3 = q\n        # Explicit form to match the one in the explanation\n        R = np.array([\n            [1 - 2*(q2**2 + q3**2), 2*(q1*q2 - q0*q3), 2*(q1*q3 + q0*q2)],\n            [2*(q1*q2 + q0*q3), 1 - 2*(q1**2 + q3**2), 2*(q2*q3 - q0*q1)],\n            [2*(q1*q3 - q0*q2), 2*(q2*q3 + q0*q1), 1 - 2*(q1**2 + q2**2)]\n        ])\n        return R\n\n    for case in test_cases:\n        # Unpack parameters\n        m1, m2, L = case[\"m1\"], case[\"m2\"], case[\"L\"]\n        E, p = case[\"E\"], case[\"p\"]\n        dt, N = case[\"dt\"], case[\"N\"]\n        \n        # Calculate derived constants\n        mu = (m1 * m2) / (m1 + m2)\n        I_perp = mu * L**2\n        inv_I_perp = 1.0 / I_perp if I_perp != 0 else 0.0\n\n        # Initialize state variables\n        q = np.copy(case[\"q0\"])\n        omega_b = np.copy(case[\"omega_b0\"])\n\n        def compute_accel(current_q):\n            if p == 0.0:\n                return np.array([0.0, 0.0, 0.0])\n            \n            # Rotation matrix from quaternion\n            R = q_to_rot_matrix(current_q)\n            \n            # Space-frame bond vector n (third column of R)\n            n_s = R[:, 2]\n            \n            # Space-frame torque\n            tau_s = p * np.cross(n_s, E)\n            \n            # Body-frame torque\n            tau_b = R.T @ tau_s\n            \n            # Body-frame angular acceleration\n            alpha_b = np.zeros(3)\n            alpha_b[0] = tau_b[0] * inv_I_perp\n            alpha_b[1] = tau_b[1] * inv_I_perp\n            return alpha_b\n\n        # Initial kinetic energy for energy error calculation\n        if case[\"output_type\"] == \"energy_error\":\n            K0 = 0.5 * I_perp * (omega_b[0]**2 + omega_b[1]**2)\n\n        # Initial acceleration\n        alpha_b = compute_accel(q)\n\n        # Main integration loop (Velocity Verlet)\n        for _ in range(N):\n            # 1. Half-step velocity update\n            omega_b_half = omega_b + 0.5 * dt * alpha_b\n\n            # 2. Full-step position (orientation) update\n            omega_norm = np.linalg.norm(omega_b_half)\n            if omega_norm > 1e-16: # Avoid division by zero\n                theta = omega_norm * dt\n                axis = omega_b_half / omega_norm\n                \n                delta_q_w = np.cos(theta / 2.0)\n                delta_q_v = np.sin(theta / 2.0) * axis\n                \n                delta_q = np.array([delta_q_w, delta_q_v[0], delta_q_v[1], delta_q_v[2]])\n            else: # Small angle approximation\n                delta_q_v = 0.5 * dt * omega_b_half\n                delta_q_w = np.sqrt(1.0 - np.dot(delta_q_v, delta_q_v))\n                delta_q = np.array([delta_q_w, delta_q_v[0], delta_q_v[1], delta_q_v[2]])\n\n            q = q_mult(q, delta_q)\n            q /= np.linalg.norm(q) # Renormalize\n\n            # 3. Compute new acceleration\n            alpha_b_new = compute_accel(q)\n            \n            # 4. Second half-step velocity update\n            omega_b = omega_b_half + 0.5 * dt * alpha_b_new\n            \n            # Update acceleration for next iteration\n            alpha_b = alpha_b_new\n\n        # Compute required output\n        if case[\"output_type\"] == \"energy_error\":\n            Kf = 0.5 * I_perp * (omega_b[0]**2 + omega_b[1]**2)\n            if K0 == 0.0:\n                result = 0.0 if Kf == 0.0 else np.inf\n            else:\n                result = (Kf - K0) / K0\n        elif case[\"output_type\"] == \"final_angle\":\n            # n_z = 1 - 2*(q1^2 + q2^2)\n            n_z = 1.0 - 2.0 * (q[1]**2 + q[2]**2)\n            # Clip to handle potential floating point errors outside [-1, 1]\n            n_z = np.clip(n_z, -1.0, 1.0)\n            result = np.arccos(n_z)\n            \n        results.append(result)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.10e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}