{
    "hands_on_practices": [
        {
            "introduction": "在分子模拟中，理解分子周围的局部结构至关重要，例如溶剂分子如何排列或氢键网络如何形成。径向分布函数（RDF）是量化这种局部结构的主要工具。本练习将指导您计算配位数——一个从RDF派生的具体量，用于统计特定截断距离内的平均邻居数，从而为您提供分析分子动力学轨迹中局部环境的第一手实践。",
            "id": "2449053",
            "problem": "给定一个来自液态甲酰胺分子动力学 (MD) 模拟的有限轨迹帧集合。在每一帧中，都有两种被标记的物种：羰基氧原子（受体）和酰胺氢原子（供体）。系统被封闭在一个边长为 $L$（以纳米表示）的立方周期性模拟盒子中。对于物种 $A$（受体）和 $B$（供体）对，交叉径向分布函数 (RDF) $g_{AB}(r)$ 由以下关系定义：在物种 $A$ 的一个粒子周围，半径为 $r$、厚度为 $\\mathrm{d}r$ 的球壳中找到物种 $B$ 的粒子的概率密度为 $\\rho_B \\, g_{AB}(r)$，其中 $\\rho_B$ 是物种 $B$ 的数密度。在离散和有限的设定下，$g_{AB}(r)$ 通过计算壳层中的跨物种对间距，并用理想气体期望值进行归一化来估算：\n$$\ng_{AB}(r_j) \\approx \\frac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\frac{1}{F} \\sum_{k=1}^{F} \\frac{1}{N_A^{(k)} N_B^{(k)}} \\, C_j^{(k)},\n$$\n其中 $V=L^3$ 是盒子体积，$F$ 是帧数，$N_A^{(k)}$ 和 $N_B^{(k)}$ 是第 $k$ 帧中 $A$ 和 $B$ 粒子的数量，$\\Delta r$ 是箱宽，$r_j$ 是第 $j$ 个箱的中心，$C_j^{(k)}$ 是第 $k$ 帧中最小镜像间距位于第 $j$ 个箱内的 $A$–$B$ 对的计数。对周期性边界条件使用最小镜像约定：对于位移分量 $\\Delta x$，在计算欧几里得范数之前，使用 $\\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$。\n\n从 $g_{AB}(r)$ 得到的一个氢键定量度量是截至截断半径 $r_c$ 的配位数，定义为\n$$\nn_{AB}(r_c) = \\rho_B \\int_0^{r_c} 4\\pi r^2 g_{AB}(r)\\, \\mathrm{d}r.\n$$\n在离散形式下，箱中心为 $r_j$ 且宽度为 $\\Delta r$ 时，该式变为\n$$\nn_{AB}(r_c) \\approx \\frac{1}{F} \\sum_{k=1}^{F} \\left[ \\rho_B^{(k)} \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\, g_{AB}^{(k)}(r_j) \\right],\n$$\n其中 $\\rho_B^{(k)} = N_B^{(k)}/V$ 且 $g_{AB}^{(k)}(r_j) = \\dfrac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\dfrac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}}$。该表达式等于每个 $A$ 粒子在 $r_c$ 范围内 $B$ 邻居的（对所有帧）平均数量。\n\n所有距离必须以纳米为单位计算和报告。配位数是无量纲的。\n\n您的任务是为以下每个测试用例计算 $n_{AB}(r_c)$。对于每个用例，使用箱宽 $\\Delta r = 0.01\\,\\mathrm{nm}$，并考虑 $r$ 的范围从 $0$ 到 $L/2$（不包括 $L/2$）。距离必须在立方周期性边界条件下使用最小镜像约定来计算。对于每个用例，轨迹帧的集合都已明确指定；在每一帧 $k$ 中，受体 $A$ 和供体 $B$ 的位置都以纳米为单位列出。本问题不涉及角度。最终输出必须是浮点数。\n\n测试套件：\n\n- 用例 1：\n  - $L = 2.00\\,\\mathrm{nm}$，$F = 1$ 帧。\n  - 帧 1：受体 $A^{(1)} = [ (0.50, 0.50, 0.50) ]\\,\\mathrm{nm}$；供体 $B^{(1)} = [ (0.68, 0.50, 0.50) ]\\,\\mathrm{nm}$。\n  - 截断半径 $r_c = 0.30\\,\\mathrm{nm}$。\n\n- 用例 2：\n  - $L = 2.00\\,\\mathrm{nm}$，$F = 1$ 帧。\n  - 帧 1：受体 $A^{(1)} = [ (0.20, 0.20, 0.20), (1.80, 1.80, 1.80) ]\\,\\mathrm{nm}$；供体 $B^{(1)} = [ (1.00, 1.00, 1.00), (1.00, 0.90, 1.00) ]\\,\\mathrm{nm}$。\n  - 截断半径 $r_c = 0.25\\,\\mathrm{nm}$。\n\n- 用例 3：\n  - $L = 2.00\\,\\mathrm{nm}$，$F = 2$ 帧。\n  - 帧 1：受体 $A^{(1)} = [ (1.95, 1.00, 1.00) ]\\,\\mathrm{nm}$；供体 $B^{(1)} = [ (0.05, 1.00, 1.00) ]\\,\\mathrm{nm}$。\n  - 帧 2：受体 $A^{(2)} = [ (1.95, 1.00, 1.00) ]\\,\\mathrm{nm}$；供体 $B^{(2)} = [ (0.60, 1.00, 1.00) ]\\,\\mathrm{nm}$。\n  - 截断半径 $r_c = 0.30\\,\\mathrm{nm}$。\n\n- 用例 4：\n  - $L = 2.50\\,\\mathrm{nm}$，$F = 2$ 帧。\n  - 帧 1：受体 $A^{(1)} = [ (1.25, 1.25, 1.25), (0.30, 0.30, 0.30) ]\\,\\mathrm{nm}$；供体 $B^{(1)} = [ (1.40, 1.25, 1.25), (1.10, 1.25, 1.25), (2.40, 2.40, 2.40), (0.45, 0.30, 0.30), (0.10, 0.10, 0.10) ]\\,\\mathrm{nm}$。\n  - 帧 2：受体 $A^{(2)} = [ (1.25, 1.25, 1.25), (0.30, 0.30, 0.30) ]\\,\\mathrm{nm}$；供体 $B^{(2)} = [ (1.40, 1.25, 1.25), (2.00, 2.00, 2.00), (0.45, 0.30, 0.30), (0.30, 0.50, 0.30) ]\\,\\mathrm{nm}$。\n  - 截断半径 $r_c = 0.30\\,\\mathrm{nm}$。\n\n您的程序必须为每个用例计算如上定义的配位数 $n_{AB}(r_c)$，并将所有用例的结果聚合到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是用例 $i$ 的浮点数结果，不带单位。",
            "solution": "所提出的问题是计算统计力学中一个定义明确的练习，特别是关于分子动力学模拟轨迹的分析。它具有科学依据、内部一致，并包含了获得唯一解所需的所有信息。径向分布函数、配位数和最小镜像约定的定义是该领域的标准。因此，该问题是有效的，我们将着手进行严谨的求解。\n\n核心任务是为几个测试用例计算配位数 $n_{AB}(r_c)$。问题提供了 $n_{AB}(r_c)$ 的定义，它是一个积分表达式的离散近似：\n$$\nn_{AB}(r_c) \\approx \\frac{1}{F} \\sum_{k=1}^{F} \\left[ \\rho_B^{(k)} \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\, g_{AB}^{(k)}(r_j) \\right]\n$$\n这里，$F$ 是帧数。对帧求和的内部项可以解释为单帧 $k$ 的配位数。让我们分析这一项，$n_{AB}^{(k)}(r_c)$。问题给出了物种 $B$ 的每帧数密度 $\\rho_B^{(k)}$ 和每帧径向分布函数 $g_{AB}^{(k)}(r_j)$ 的定义：\n$$\n\\rho_B^{(k)} = \\frac{N_B^{(k)}}{V}\n$$\n$$\ng_{AB}^{(k)}(r_j) = \\frac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\frac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}}\n$$\n其中 $V=L^3$ 是模拟盒子的体积，$N_A^{(k)}$ 和 $N_B^{(k)}$ 是第 $k$ 帧中物种 $A$ 和 $B$ 的粒子数，$\\Delta r$ 是直方图箱宽，$r_j$ 是第 $j$ 个箱的中心，$C_j^{(k)}$ 是第 $k$ 帧中间距落在第 $j$ 个箱内的 $A-B$ 对的数量。\n\n将这些定义代入单帧配位数的表达式中，我们得到了一个显著的简化：\n$$\nn_{AB}^{(k)}(r_c) = \\rho_B^{(k)} \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\, g_{AB}^{(k)}(r_j)\n$$\n$$\nn_{AB}^{(k)}(r_c) = \\left( \\frac{N_B^{(k)}}{V} \\right) \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\left( \\frac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\frac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}} \\right)\n$$\n项 $V$、$4\\pi r_j^2$ 和 $\\Delta r$ 会消去，得到：\n$$\nn_{AB}^{(k)}(r_c) = \\frac{N_B^{(k)}}{V} \\sum_{j: r_j \\le r_c} V \\frac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}} = \\frac{1}{N_A^{(k)}} \\sum_{j: r_j \\le r_c} C_j^{(k)}\n$$\n求和 $\\sum_{j: r_j \\le r_c} C_j^{(k)}$ 表示在第 $k$ 帧中间距 $r$ 小于或等于截断半径 $r_c$ 的所有对的总数。让我们将这个总数表示为 $N_{\\text{pairs}}^{(k)}(r \\le r_c)$。因此，单帧配位数的表达式变为：\n$$\nn_{AB}^{(k)}(r_c) = \\frac{N_{\\text{pairs}}^{(k)}(r \\le r_c)}{N_A^{(k)}}\n$$\n这个结果有一个直接的物理解释：它是在第 $k$ 帧中，一个受体粒子 ($A$) 的 $r_c$ 距离范围内找到的供体粒子 ($B$) 的平均数量。至关重要的是，这个简化公式不依赖于箱宽 $\\Delta r$，这就不再需要进行显式的直方图统计。\n\n最终的配位数 $n_{AB}(r_c)$ 是这些单帧值在所有 $F$ 帧上的平均值：\n$$\nn_{AB}(r_c) = \\frac{1}{F} \\sum_{k=1}^{F} n_{AB}^{(k)}(r_c) = \\frac{1}{F} \\sum_{k=1}^{F} \\frac{N_{\\text{pairs}}^{(k)}(r \\le r_c)}{N_A^{(k)}}\n$$\n因此，计算算法如下：\n1. 初始化一个列表来存储每帧的配位数。\n2. 对于从 1 到 $F$ 的每一帧 $k$：\n    a. 确定受体粒子的数量 $N_A^{(k)}$。如果 $N_A^{(k)} = 0$，则配位数显然为 $0$。\n    b. 初始化一个计数器，用于统计截断半径内的对数，$N_{\\text{pairs}}^{(k)}(r \\le r_c) = 0$。\n    c. 对于每个受体粒子位置 $\\vec{r}_i \\in A^{(k)}$ 和每个供体粒子位置 $\\vec{r}_j \\in B^{(k)}$：\n        i. 计算位移向量 $\\Delta\\vec{r} = \\vec{r}_j - \\vec{r}_i$。\n        ii. 对位移向量的每个分量 $\\Delta x_m$ 使用最小镜像约定来处理周期性边界条件：\n             $$\n             \\Delta x'_m = \\Delta x_m - L \\cdot \\mathrm{round}(\\Delta x_m / L)\n             $$\n             其中 $L$ 是立方盒子的边长。\n        iii. 计算欧几里得距离 $d = \\sqrt{(\\Delta x'_1)^2 + (\\Delta x'_2)^2 + (\\Delta x'_3)^2}$。\n        iv. 如果 $d \\le r_c$，则将对计数器 $N_{\\text{pairs}}^{(k)}(r \\le r_c)$ 加一。\n    d. 计算每帧的配位数 $n_{AB}^{(k)}(r_c) = N_{\\text{pairs}}^{(k)}(r \\le r_c) / N_A^{(k)}$。\n    e. 将此值添加到每帧结果的列表中。\n3. 该测试用例的最终结果是所有存储的每帧配位数的算术平均值。\n\n此过程将应用于所提供的四个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the coordination number for several molecular dynamics trajectory test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 2.00,\n            \"rc\": 0.30,\n            \"frames\": [\n                {\n                    \"A\": np.array([[0.50, 0.50, 0.50]]),\n                    \"B\": np.array([[0.68, 0.50, 0.50]])\n                }\n            ]\n        },\n        # Case 2\n        {\n            \"L\": 2.00,\n            \"rc\": 0.25,\n            \"frames\": [\n                {\n                    \"A\": np.array([[0.20, 0.20, 0.20], [1.80, 1.80, 1.80]]),\n                    \"B\": np.array([[1.00, 1.00, 1.00], [1.00, 0.90, 1.00]])\n                }\n            ]\n        },\n        # Case 3\n        {\n            \"L\": 2.00,\n            \"rc\": 0.30,\n            \"frames\": [\n                {\n                    \"A\": np.array([[1.95, 1.00, 1.00]]),\n                    \"B\": np.array([[0.05, 1.00, 1.00]])\n                },\n                {\n                    \"A\": np.array([[1.95, 1.00, 1.00]]),\n                    \"B\": np.array([[0.60, 1.00, 1.00]])\n                }\n            ]\n        },\n        # Case 4\n        {\n            \"L\": 2.50,\n            \"rc\": 0.30,\n            \"frames\": [\n                {\n                    \"A\": np.array([[1.25, 1.25, 1.25], [0.30, 0.30, 0.30]]),\n                    \"B\": np.array([\n                        [1.40, 1.25, 1.25], [1.10, 1.25, 1.25],\n                        [2.40, 2.40, 2.40], [0.45, 0.30, 0.30],\n                        [0.10, 0.10, 0.10]\n                    ])\n                },\n                {\n                    \"A\": np.array([[1.25, 1.25, 1.25], [0.30, 0.30, 0.30]]),\n                    \"B\": np.array([\n                        [1.40, 1.25, 1.25], [2.00, 2.00, 2.00],\n                        [0.45, 0.30, 0.30], [0.30, 0.50, 0.30]\n                    ])\n                }\n            ]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        rc = case[\"rc\"]\n        frames = case[\"frames\"]\n        \n        frame_coordination_numbers = []\n\n        for frame in frames:\n            acceptor_coords = frame[\"A\"]\n            donor_coords = frame[\"B\"]\n            \n            num_acceptors = acceptor_coords.shape[0]\n            \n            if num_acceptors == 0:\n                frame_coordination_numbers.append(0.0)\n                continue\n\n            pair_count = 0\n            for r_a in acceptor_coords:\n                for r_b in donor_coords:\n                    # Calculate displacement vector\n                    delta_r = r_b - r_a\n                    \n                    # Apply minimum image convention\n                    delta_r_mic = delta_r - L * np.round(delta_r / L)\n                    \n                    # Calculate distance\n                    distance = np.linalg.norm(delta_r_mic)\n                    \n                    # Check if within cutoff\n                    if distance = rc:\n                        pair_count += 1\n            \n            # Calculate coordination number for the frame\n            cn_frame = pair_count / num_acceptors\n            frame_coordination_numbers.append(cn_frame)\n\n        # Average coordination number over all frames for the case\n        mean_cn = np.mean(frame_coordination_numbers)\n        results.append(mean_cn)\n\n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了分析局部环境，比较整个分子结构的相似性或差异性也是轨迹分析的核心任务。均方根偏差（RMSD）是量化两种构象之间结构差异的标准度量。该练习将引导您完成计算成对RMSD的关键步骤，包括通过最佳刚体叠合（Kabsch算法）消除平移和旋转差异，最终构建一个构象差异矩阵，这是分析构象系综的基础。",
            "id": "2449039",
            "problem": "给定几组三维原子坐标，代表从分子动力学（MD）轨迹中采样的代表性结构。您的任务是在最优叠合后，使用结构之间的均方根偏差（RMSD）计算成对相异性矩阵，然后将该矩阵转换为可用于热图的归一化矩阵。您必须将解决方案实现为一个完整的、可运行的程序。\n\n基本原理与约束：\n- 将一个结构视为三维欧几里得空间中 $N$ 个点的集合，表示为一个 $N \\times 3$ 的实数数组，单位为埃 (Ångström)。必须使用 $\\mathbb{R}^3$ 中的欧几里得范数和内积。两点 $\\mathbf{x}$ 和 $\\mathbf{y}$ 之间的距离为 $\\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2$。\n- 对于具有相同原子顺序的两个结构，其均方根偏差（RMSD）必须在消除刚体平移和旋转差异后计算。具体来说，您必须通过最小化原子间距离平方和的正常旋转（即行列式为 $+1$ 的旋转矩阵）将一个结构与另一个结构对齐，并通过将两个结构以其质心为中心来消除平移。不允许反射。最优对齐后，RMSD是对应原子之间距离平方的均值的平方根。\n- 对于一组 $M$ 个结构，相异性矩阵 $\\mathbf{D}$ 定义为 $D_{ij}$ 是结构 $i$ 和结构 $j$ 之间的RMSD（单位为埃），且对所有 $i$ 都有 $D_{ii} = 0$。\n- 为从 $\\mathbf{D}$ 获得可用于热图的矩阵 $\\mathbf{H}$，需对非对角线元素进行最小-最大归一化：设 $d_{\\min}$ 为 $\\{ D_{ij} : i \\neq j \\}$ 的最小值，$d_{\\max}$ 为其最大值。对于 $i \\neq j$，设置 $H_{ij} = (D_{ij} - d_{\\min}) / (d_{\\max} - d_{\\min})$，并设置 $H_{ii} = 0$。如果没有非对角线元素（即 $M = 1$），或 $d_{\\max} = d_{\\min}$，则将所有非对角线 $H_{ij}$ 定义为 $0$，以避免除以零。矩阵 $\\mathbf{H}$ 是无量纲的。\n- 用于构建变换的角度必须以度为单位。所有坐标单位均为埃，所有RMSD值也必须以埃报告。\n\n需要实现和评估的测试套件：\n- 情况1（正常路径，测试旋转/平移不变性和非零相异性）：使用 $M = 3$ 个结构，每个结构包含 $N = 4$ 个原子。\n  - 定义参考四面体结构\n    - $\\mathbf{S}_0$ 的行向量为：$(1,1,1)$, $(-1,-1,1)$, $(-1,1,-1)$, $(1,-1,-1)$。\n  - 通过将 $\\mathbf{S}_0$ 绕 $z$ 轴旋转 $90$ 度（角度单位：度），然后平移 $(2.0,-3.0,0.5)$ 埃来定义 $\\mathbf{S}_1$。\n  - 通过将以下确定性位移（单位为埃）按顺序加到 $\\mathbf{S}_0$ 的各行来定义 $\\mathbf{S}_2$：\n    - $(0.08,-0.02,0.03)$, $(-0.05,0.07,-0.04)$, $(0.02,-0.06,0.05)$, $(-0.03,0.04,-0.07)$。\n- 情况2（边界情况，测试手性/无反射约束）：使用 $M = 3$ 个结构，每个结构包含 $N = 4$ 个原子。\n  - 定义 $\\mathbf{A}_0$ 的行向量为：$(0.0,0.0,0.0)$, $(1.0,0.2,-0.1)$, $(0.3,1.1,0.4)$, $(-0.2,0.5,1.2)$。\n  - 将 $\\mathbf{A}_1$ 定义为 $\\mathbf{A}_0$ 关于平面 $x=0$ 的镜像（即，将 $(x,y,z)$ 映射到 $(-x,y,z)$），该镜像不能通过任何正常旋转与之叠合。\n  - 定义 $\\mathbf{A}_2 = \\mathbf{A}_0$（一个完全相同的副本），以确保集合中存在一对接近于零的RMSD值。\n- 情况3（边缘情况，测试 $M=1$）：使用 $M = 1$ 个结构，包含 $N = 3$ 个原子：\n  - 定义 $\\mathbf{B}_0$ 的行向量为：$(0.0,0.0,0.0)$, $(1.0,0.0,0.0)$, $(0.0,1.0,0.0)$。\n\n程序要求：\n- 对于每种情况，使用成对最优叠合和RMSD计算相异性矩阵 $\\mathbf{D}$。然后按所述方法计算归一化热图矩阵 $\\mathbf{H}$。\n- 对于每种情况，按行主序提取 $\\mathbf{D}$ 的上三角元素（严格满足 $i  j$）作为一个浮点数列表，并以相同顺序提取 $\\mathbf{H}$ 的上三角元素。\n- 将所有RMSD值（单位为埃）四舍五入到恰好三位小数，并将所有归一化热图值（无量纲）四舍五入到恰好三位小数。\n- 最终输出格式：您的程序应生成单行输出，包含一个有六个元素的列表，顺序如下：\n  - 情况1的RMSD上三角列表，\n  - 情况1的热图上三角列表，\n  - 情况2的RMSD上三角列表，\n  - 情况2的热图上三角列表，\n  - 情况3的RMSD上三角列表，\n  - 情况3的热图上三角列表。\n- 输出不得包含空格，每个浮点数必须在小数点后有恰好三位数字。例如，带有占位符的语法模板是：\n  - \"[[r1_1,r1_2,...],[h1_1,h1_2,...],[r2_1,...],[h2_1,...],[r3_1,...],[h3_1,...]]\"\n  其中每个 \"r\" 是一个以埃为单位的RMSD值，每个 \"h\" 是一个无量纲的归一化热图值，均按规定四舍五入到三位小数。\n\n您的实现必须完全自包含。不要读取任何输入。仅使用指定的库。\n\n答案类型和单位：\n- 列表包含浮点数。RMSD条目必须以埃为单位，四舍五入到三位小数。归一化热图条目是无量纲的，四舍五入到三位小数。\n\n物理和数值假设对于轨迹结构分析中的刚体对齐是标准且现实的。请确保对齐使用正常旋转（行列式为 $+1$），并通过中心化移除平移。\n\n您的程序将根据所描述的三种情况进行精确测试。输出必须遵循上述确切的单行格式。",
            "solution": "该问题是有效的。它提出了一个清晰、自包含且科学上合理的计算任务，这在结构生物学和计算化学中是标准问题。我将提供一个完整的解决方案。\n\n问题的核心是在最优刚体叠合后，计算成对原子结构之间的均方根偏差（RMSD）。这需要消除平移和旋转的差异。问题指定只允许正常旋转（行列式为 $+1$），禁止反射。这是一个关键的物理约束，因为对映异构体（镜像分子）不能通过旋转相互转换。\n\n假设两个结构 $\\mathbf{A}$ 和 $\\mathbf{B}$ 由 $N \\times 3$ 的原子坐标矩阵表示，其中 $N$ 是原子数。矩阵的行向量 $\\mathbf{a}_i$ 和 $\\mathbf{b}_i$（$i=1, \\dots, N$）是每个对应原子的三维坐标向量。\n\nRMSD 定义为：\n$$ \\text{RMSD}(\\mathbf{A}, \\mathbf{B}) = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\lVert (\\mathbf{T} + \\mathbf{a}_i \\mathbf{R}^T) - \\mathbf{b}_i \\rVert^2} $$\n其中我们必须找到最优的平移向量 $\\mathbf{T}$ 和旋转矩阵 $\\mathbf{R}$ 来最小化这个值。\n\n这个求解过程通常被称为 Kabsch 算法，包括以下步骤：\n\n1.  **消除平移差异**：通过将每个结构的质心移动到原点来消除最优平移。结构 $\\mathbf{A}$ 的质心是 $\\mathbf{c}_A = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{a}_i$。我们定义中心化后的坐标矩阵为 $\\mathbf{A}' = \\mathbf{A} - \\mathbf{1}\\mathbf{c}_A^T$ 和 $\\mathbf{B}' = \\mathbf{B} - \\mathbf{1}\\mathbf{c}_B^T$，其中 $\\mathbf{1}$ 是一个 $N \\times 1$ 的全一列向量。\n\n2.  **寻找最优旋转**：中心化后，问题简化为寻找旋转矩阵 $\\mathbf{R}$ 以最小化距离平方和 $\\sum_{i=1}^N \\lVert \\mathbf{a}'_i \\mathbf{R}^T - \\mathbf{b}'_i \\rVert^2$。这等同于最大化涉及协方差矩阵的矩阵乘积的迹。协方差矩阵 $\\mathbf{C}$ 计算如下：\n    $$ \\mathbf{C} = (\\mathbf{A}')^T \\mathbf{B}' $$\n    这是一个 $3 \\times 3$ 矩阵。\n\n3.  **奇异值分解（SVD）**：最优旋转是通过对协方差矩阵 $\\mathbf{C}$ 进行奇异值分解得到的：\n    $$ \\mathbf{C} = \\mathbf{U} \\mathbf{\\Sigma} \\mathbf{V}^T $$\n    其中 $\\mathbf{U}$ 和 $\\mathbf{V}$ 是 $3 \\times 3$ 的正交矩阵，$\\mathbf{\\Sigma}$ 是一个 $3 \\times 3$ 的奇异值对角矩阵。最优旋转矩阵 $\\mathbf{R}$ 由下式给出：\n    $$ \\mathbf{R} = \\mathbf{V} \\mathbf{U}^T $$\n\n4.  **强制正常旋转**：上面计算出的矩阵 $\\mathbf{R}$ 可能是一个正常旋转（$\\det(\\mathbf{R})=+1$）或一个非正常旋转（一个反射，$\\det(\\mathbf{R})=-1$）。问题要求的是正常旋转。如果 $\\det(\\mathbf{R}) = -1$，这表明在最优对齐状态下，一个结构是另一个的镜像。为了获得最佳的*正常*旋转，我们必须“撤销”这个反射。这可以通过沿对应于最小奇异值的轴反射坐标系来实现。一个实际的实现方法是检查 $\\det(\\mathbf{V}\\mathbf{U}^T)$ 的符号。如果为负，我们在计算 $\\mathbf{R}$ 之前，通过翻转 $\\mathbf{V}$ 的第三列（或等效地，$\\mathbf{V}^T$ 的第三行）的符号来修改 $\\mathbf{V}$：\n    $$ \\text{If } \\det(\\mathbf{V}\\mathbf{U}^T)  0, \\text{ then } \\mathbf{R} = \\mathbf{V} \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  -1 \\end{pmatrix} \\mathbf{U}^T $$\n    这保证了 $\\det(\\mathbf{R}) = +1$。\n\n5.  **计算最终RMSD**：利用最优正常旋转 $\\mathbf{R}$，我们旋转结构 $\\mathbf{A}'$ 并计算相对于 $\\mathbf{B}'$ 的 RMSD。距离平方和 $E$ 为：\n    $$ E = \\sum_{i=1}^N \\lVert \\mathbf{a}'_i \\mathbf{R}^T - \\mathbf{b}'_i \\rVert^2 $$\n    RMSD 则为：\n    $$ \\text{RMSD} = \\sqrt{\\frac{E}{N}} $$\n\n一旦计算出一组 $M$ 个结构的成对RMSD值，它们将被排列成一个 $M \\times M$ 的相异性矩阵 $\\mathbf{D}$，其中 $D_{ij}$ 是结构 $i$ 和结构 $j$ 之间的RMSD。根据定义，$D_{ii}=0$ 并且 $\\mathbf{D}$ 是对称的（$D_{ij} = D_{ji}$）。\n\n最后，这个矩阵 $\\mathbf{D}$ 被归一化以生成一个可用于热图的矩阵 $\\mathbf{H}$。非对角线元素使用最小-最大缩放进行归一化：\n$$ H_{ij} = \\frac{D_{ij} - d_{\\min}}{d_{\\max} - d_{\\min}} \\quad \\text{for } i \\neq j $$\n其中 $d_{\\min}$ 和 $d_{\\max}$ 是非对角线元素 $\\{D_{ij} | i \\neq j\\}$ 的最小值和最大值。对角线元素 $H_{ii}$ 被设置为 $0$。对于 $M=1$（没有非对角线元素）或 $d_{\\max} = d_{\\min}$ 的情况需要特殊处理，在这些情况下，所有非对角线 $H_{ij}$ 都定义为 $0$。\n\n提供的测试用例将通过实现这一完整过程来解决。对于每个用例，将提取、四舍五入并按规定格式化 $\\mathbf{D}$ 和 $\\mathbf{H}$ 的上三角元素。情况1测试标准叠合。情况2通过包含一个镜像结构来专门测试手性约束。情况3测试单个结构的边缘情况。",
            "answer": "```python\nimport numpy as np\n\ndef compute_rmsd(coords1: np.ndarray, coords2: np.ndarray) - float:\n    \"\"\"\n    Computes the RMSD between two structures after optimal superposition.\n    This implementation uses the Kabsch algorithm.\n    It ensures that the rotation is a proper rotation (determinant +1).\n\n    Args:\n        coords1: An N x 3 numpy array of atomic coordinates.\n        coords2: An N x 3 numpy array of atomic coordinates.\n\n    Returns:\n        The RMSD value in the same units as the input coordinates.\n    \"\"\"\n    if coords1.shape[0] != coords2.shape[0]:\n        raise ValueError(\"Input structures must have the same number of atoms.\")\n    \n    num_atoms = coords1.shape[0]\n    \n    # 1. Center the structures\n    centroid1 = coords1.mean(axis=0)\n    centroid2 = coords2.mean(axis=0)\n    centered1 = coords1 - centroid1\n    centered2 = coords2 - centroid2\n    \n    # 2. Compute the covariance matrix\n    cov_matrix = centered1.T @ centered2\n\n    # 3. Singular Value Decomposition\n    try:\n        U, S, Vt = np.linalg.svd(cov_matrix)\n    except np.linalg.LinAlgError:\n        return np.sqrt(np.sum((centered1 - centered2)**2) / num_atoms)\n\n    # 4. Check for and correct reflection (improper rotation)\n    if np.linalg.det(Vt.T @ U.T)  0:\n        Vt[2, :] *= -1\n    \n    # 5. Compute the optimal rotation matrix\n    rotation_matrix = Vt.T @ U.T\n    \n    # 6. Apply rotation to the second structure and calculate RMSD\n    rotated_centered2 = centered2 @ rotation_matrix.T\n    \n    diff = centered1 - rotated_centered2\n    rmsd = np.sqrt(np.sum(diff * diff) / num_atoms)\n    \n    return rmsd\n\ndef process_structures(structures: list[np.ndarray]) - tuple[list[float], list[float]]:\n    \"\"\"\n    For a list of M structures, computes the dissimilarity (D) and heatmap (H) matrices.\n\n    Args:\n        structures: A list of M numpy arrays, each N x 3.\n\n    Returns:\n        A tuple containing two lists:\n        1. The upper-triangular elements of D (RMSD values).\n        2. The upper-triangular elements of H (normalized values).\n    \"\"\"\n    M = len(structures)\n    \n    if M = 1:\n        return [], []\n\n    D = np.zeros((M, M))\n    off_diagonal_d = []\n    \n    # Calculate pairwise RMSD matrix D\n    for i in range(M):\n        for j in range(i + 1, M):\n            rmsd = compute_rmsd(structures[i], structures[j])\n            D[i, j] = D[j, i] = rmsd\n            off_diagonal_d.append(rmsd)\n            \n    rmsd_upper_tri = [D[i, j] for i in range(M) for j in range(i + 1, M)]\n\n    if not off_diagonal_d:\n        return rmsd_upper_tri, [0.0] * len(rmsd_upper_tri)\n\n    d_min = min(off_diagonal_d)\n    d_max = max(off_diagonal_d)\n    \n    # Calculate heatmap matrix H\n    H = np.zeros((M, M))\n    heatmap_upper_tri = []\n\n    if abs(d_max - d_min)  1e-9: # Handle d_max == d_min case\n        heatmap_upper_tri = [0.0] * len(rmsd_upper_tri)\n    else:\n        for i in range(M):\n            for j in range(i + 1, M):\n                h_val = (D[i, j] - d_min) / (d_max - d_min)\n                H[i, j] = H[j, i] = h_val\n        heatmap_upper_tri = [H[i, j] for i in range(M) for j in range(i + 1, M)]\n        \n    return rmsd_upper_tri, heatmap_upper_tri\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run computations, and print the final result.\n    \"\"\"\n    # --- Case 1 ---\n    S0 = np.array([\n        [1.0, 1.0, 1.0],\n        [-1.0, -1.0, 1.0],\n        [-1.0, 1.0, -1.0],\n        [1.0, -1.0, -1.0]\n    ])\n    angle_rad = np.deg2rad(90)\n    c, s = np.cos(angle_rad), np.sin(angle_rad)\n    Rz = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    S1_rotated = S0 @ Rz.T\n    S1 = S1_rotated + np.array([2.0, -3.0, 0.5])\n    \n    displacements = np.array([\n        [0.08, -0.02, 0.03],\n        [-0.05, 0.07, -0.04],\n        [0.02, -0.06, 0.05],\n        [-0.03, 0.04, -0.07]\n    ])\n    S2 = S0 + displacements\n    \n    case1_structures = [S0, S1, S2]\n    \n    # --- Case 2 ---\n    A0 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.2, -0.1],\n        [0.3, 1.1, 0.4],\n        [-0.2, 0.5, 1.2]\n    ])\n    A1 = A0.copy()\n    A1[:, 0] *= -1  # Mirror image across x=0 plane\n    A2 = A0.copy()   # Identical structure\n    \n    case2_structures = [A0, A1, A2]\n\n    # --- Case 3 ---\n    B0 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0]\n    ])\n    case3_structures = [B0]\n\n    all_cases = [case1_structures, case2_structures, case3_structures]\n    all_results = []\n    \n    for structures in all_cases:\n        rmsd_list, heatmap_list = process_structures(structures)\n        all_results.append(rmsd_list)\n        all_results.append(heatmap_list)\n        \n    # Format the final output string\n    # E.g., [[val1,val2],[val3,val4],[],[]]\n    output_parts = []\n    for res_list in all_results:\n        formatted_nums = \",\".join([f\"{num:.3f}\" for num in res_list])\n        output_parts.append(f\"[{formatted_nums}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "一旦我们掌握了计算RMSD和回转半径（$R_g$）等结构度量的方法，我们就可以将它们提升到更高层次的分析。这些度量可以被视为定义“构象空间”的坐标。这个高级实践将向您展示如何将这些结构度量与聚类算法相结合，以自动识别和分组分子轨迹中的不同构象状态，从而将原始坐标数据转化为富有洞察力的结构动力学信息。",
            "id": "2449058",
            "problem": "您将得到一份概念性规范，用于通过在由均方根偏差 (RMSD) 和回转半径 (Rg) 定义的二维特征空间中对帧进行聚类，从分子动力学 (MD) 轨迹中识别不同的构象状态。每个轨迹帧由 $N$ 个等质量质点的三维笛卡尔坐标（单位为埃，Ångström）组成。目标是设计并实现一个基于第一性原理的算法，该算法从第一性原理计算结构度量，并使用基于密度的聚类将帧分组为构象状态。\n\n从以下基本概念出发：\n\n- 三维刚体几何学和欧几里得距离。\n- 均方根偏差 (RMSD) 的定义：在最佳刚性对齐后，对应原子之间欧几里得距离平方的平均值的平方根。\n- 回转半径 (Rg) 的定义：原子到其质心距离平方的平均值的平方根。\n- 度量空间中的密度连通性概念：如果两个点位于彼此规定的度量半径之内，则认为它们是直接密度可达的；如果一个点在该半径内至少有指定的最少邻居数，则该点是核心点。\n\n任务要求：\n\n1) 对于坐标为 $P \\in \\mathbb{R}^{N \\times 3}$ 的参考结构和坐标为 $Q \\in \\mathbb{R}^{N \\times 3}$ 的轨迹帧，将 RMSD 定义为在最佳刚体叠加（平移和旋转）后最小化的平均平方位移。形式上，确定旋转矩阵 $R \\in \\mathbb{R}^{3 \\times 3}$ 和平移向量 $t \\in \\mathbb{R}^{3}$，以最小化相应原子之间的距离平方和，并使用由此产生的叠加计算 $Q$ 相对于 $P$ 的 RMSD。RMSD 以埃（Ångström）表示。\n\n2) 对于每个帧 $Q$，计算其回转半径 $R_g$，即其原子到其质心距离的平方的平均值的平方根。$R_g$ 以埃（Ångström）表示。\n\n3) 将每个帧映射到坐标为 $(\\text{RMSD}, R_g)$ 的二维特征空间中的一个点。在此平面中，使用标准的欧几里得度量。实现一个基于密度的聚类算法，该算法：\n   - 使用邻域半径参数 $\\varepsilon$（单位为埃，Ångström）和整数最小邻居数 $m$。\n   - 将一个点的邻域定义为在 $(\\text{RMSD}, R_g)$ 平面中，其欧几里得距离小于或等于 $\\varepsilon$ 的所有点。\n   - 如果一个点的邻域大小（包括其自身）至少为 $m$，则将其分类为核心点。\n   - 将与至少一个核心点密度相连的所有点的并集形成一个聚类，其中密度连通性是直接密度可达的传递闭包。\n   - 未分配到任何聚类的点被标记为噪声，不计入聚类数量。\n\n为可复现的测试平台生成轨迹：\n\n- 使用 $N = 12$ 个等质量的原子。\n- 通过从原点开始的固定步长为 $1.5$ Å 的三维随机游走构建参考结构 $P$，然后平移以将其质心移动到原点。为所有随机元素使用固定的随机种子 $42$，以确保可复现性。\n- 生成 $60$ 个帧，划分如下：\n  - $24$ 个“紧凑”帧：对于每个帧，对 $P$ 应用任意旋转，然后为每个原子的每个笛卡尔坐标添加均值为零、标准差为 $0.05$ Å 的独立同分布高斯噪声。\n  - $24$ 个“伸展”帧：对于每个帧，首先将 $P$ 按 $1.6$ 的因子进行各向同性缩放，然后应用任意旋转，最后为每个原子的每个笛卡尔坐标添加均值为零、标准差为 $0.05$ Å 的独立同分布高斯噪声。\n  - $12$ 个“噪声”帧：生成 $N$ 个原子的独立随机游走结构，步长为 $1.5$ Å，然后为每个原子的每个笛卡尔坐标添加均值为零、标准差为 $0.2$ Å 的独立同分布高斯噪声。在计算度量之前，不要相对于 $P$ 对这些结构进行缩放。\n- 对于每个帧，使用最佳叠加计算相对于 $P$ 的 RMSD，并计算该帧的 $R_g$。\n\n聚类度量和单位：\n\n- 在 $(\\text{RMSD}, R_g)$ 平面中，使用欧几里得距离。参数 $\\varepsilon$ 必须以埃（Ångström）为单位，而 $R_g$ 和 RMSD 必须以埃（Ångström）计算。您在内部使用的任何旋转的角度都必须以弧度为单位。\n\n测试套件：\n\n在相同的 $(\\text{RMSD}, R_g)$ 数据集上，使用以下三个参数对 $(\\varepsilon, m)$ 运行聚类算法：\n\n- 情况 A（理想情况，两个明确分离的状态）：$\\varepsilon = 0.8$ Å, $m = 3$。\n- 情况 B（大邻域半径合并状态）：$\\varepsilon = 5.0$ Å, $m = 3$。\n- 情况 C（严格的核心点定义导致无聚类）：$\\varepsilon = 0.5$ Å, $m = 30$。\n\n要求的程序输出：\n\n- 您的程序必须生成单行，其中包含为三种情况（按 A、B、C 的顺序）找到的聚类数（不包括噪声），格式为用方括号括起来的逗号分隔列表。例如，格式必须与 $[\\text{result}_A,\\text{result}_B,\\text{result}_C]$ 完全一样，其中为整数。不允许有任何其他输出。",
            "solution": "问题陈述经过严格验证，被认为是**有效的**。它具有科学依据，定义明确，客观，并为分子动力学分析领域的计算任务提供了完整、自洽的规范。所有必需的参数、算法和数据生成过程都定义得足够严格，以确保一个唯一且可复现的解。\n\n该任务是实现一个完整的流程，用于从人工生成的分子轨迹中识别构象亚状态。这涉及三个主要阶段：首先，为轨迹中的每个帧计算两个关键的结构度量，即回转半径 ($R_g$) 和均方根偏差 (RMSD)；其次，将每个帧映射到由这些度量定义的二维特征空间中的一个点；第三，应用基于密度的聚类算法对这些点进行分组，从而识别底层的构象状态。\n\n**第一部分：结构度量的计算**\n\n**回转半径 ($R_g$)：**\n回转半径是衡量一组粒子空间广度的指标。对于一个具有 $N$ 个等质量原子、每个原子坐标为 $Q_i \\in \\mathbb{R}^3$（$i=1, \\dots, N$）的分子，其质心 $C_Q$ 是几何中心：\n$$\nC_Q = \\frac{1}{N} \\sum_{i=1}^{N} Q_i\n$$\n回转半径 $R_g$ 定义为原子到其质心距离的均方根：\n$$\nR_g = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\lVert Q_i - C_Q \\rVert^2}\n$$\n较小的 $R_g$ 值表示结构更紧凑，而较大的值则表示构象更伸展或未折叠。\n\n**均方根偏差 (RMSD)：**\nRMSD 是衡量两个分子结构原子之间平均距离的指标，用于量化它们的相似性。为计算轨迹帧 $Q$ 和参考结构 $P$ 之间有意义的 RMSD，必须首先找到最佳的刚体变换（平移和旋转），以最小化相应原子之间的距离。通过平移两个结构，使其各自的质心位于原点，来消除平移分量。令中心化后的坐标为 $P'$ 和 $Q'$。剩下的问题是找到旋转矩阵 $R \\in SO(3)$，以最小化距离的平方和：\n$$\n\\sum_{i=1}^{N} \\lVert R Q'_i - P'_i \\rVert^2\n$$\n这个最小化问题的解是众所周知的，由 Kabsch 算法提供。该算法流程如下：\n1.  计算两组中心化坐标之间的 $3 \\times 3$ 协方差矩阵 $H$：\n    $$\n    H = (P')^T Q' = \\sum_{i=1}^{N} P'_i (Q'_i)^T\n    $$\n2.  对协方差矩阵 $H$ 进行奇异值分解 (SVD)：\n    $$\n    H = U S V^T\n    $$\n    其中 $U$ 和 $V$ 是 $3 \\times 3$ 正交矩阵。\n3.  最佳旋转矩阵 $R$ 计算为 $R = V U^T$。需要进行校正以确保 $R$ 是纯旋转而不是反射，即 $\\det(R) = +1$。如果 $\\det(R) = -1$，则该矩阵表示一个非正常旋转（一个反射）。这通过反转 $V$ 中对应于最小奇异值的列的符号来校正。一个稳健的方法是计算 $R = V \\text{diag}(1, 1, \\det(V U^T)) U^T$。\n4.  一旦找到最佳旋转 $R$，RMSD 就计算为最佳叠加后结构原子之间欧几里得距离平方的平均值的平方根：\n    $$\n    \\text{RMSD}(P, Q) = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\lVert R Q'_i - P'_i \\rVert^2}\n    $$\n    该值将以埃（Å）表示。\n\n**第二部分：人工轨迹和特征空间的生成**\n\n为了创建一个可复现的测试平台，基于参考结构 $P$ 生成了一个人工轨迹。\n1.  **参考结构 $P$**：通过从原点开始的步长为 $1.5$ Å 的 3D 随机游走生成一个包含 $N=12$ 个原子的链。然后将生成的结构中心化于原点。固定的随机种子 $42$ 确保了可复现性。\n2.  **轨迹帧**：总共生成 $60$ 个帧，分为三组以模拟不同的构象行为：\n    -   **$24$ 个紧凑帧**：通过对参考结构 $P$ 应用随机旋转并向每个坐标添加少量高斯噪声（标准差 $\\sigma = 0.05$ Å）来生成。这些帧在结构上与 $P$ 非常相似，预期具有较低的 $R_g$ 和 RMSD 值。\n    -   **$24$ 个伸展帧**：通过首先将 $P$ 按 $1.6$ 的因子缩放，然后应用随机旋转并添加高斯噪声（$\\sigma = 0.05$ Å）来创建。缩放确保这些帧不如 $P$ 紧凑，导致较高的 $R_g$ 值。由于 RMSD 计算不考虑缩放，它们相对于 $P$ 也会有显著的 RMSD。\n    -   **$12$ 个噪声帧**：这些帧在结构上与 $P$ 无关。每个都是一个新的、独立的随机游走结构，并添加了更大量的噪声（$\\sigma = 0.2$ Å）。预期这些帧具有高且分散的 RMSD 和 $R_g$ 值。\n\n然后，这 $60$ 个帧中的每一个都被转换为一个二维数据点 $(\\text{RMSD}, R_g)$，构成了用于聚类的特征空间。\n\n**第三部分：基于密度的聚类**\n\n目标是识别构象相似的结构组，这些结构组在 $(\\text{RMSD}, R_g)$ 平面中应表现为密集的聚类。问题指定了一个基于密度的聚类算法，功能上等同于 DBSCAN（基于密度的噪声应用空间聚类）。该算法基于两个参数运行：半径 $\\varepsilon$ 和最小邻居数 $m$。\n1.  **核心点**：如果一个点的邻域（由特征空间欧几里得度量中的半径 $\\varepsilon$ 定义）包含至少 $m$ 个点（包括其自身），则该点被分类为核心点。\n2.  **密度可达性**：如果点 $q$ 在点 $p$ 的 $\\varepsilon$-邻域内，并且 $p$ 是一个核心点，则称 $q$ 是从 $p$ 直接密度可达的。密度连通性是此关系的传递闭包。\n3.  **聚类形成**：一个聚类是一组点，其中每个点都与至少一个核心点密度相连。该算法从一个任意未访问的点开始，检查它是否是核心点，如果是，则通过找到所有从它密度可达的点来扩展一个新的聚类。\n4.  **噪声**：非核心点且不从任何核心点密度可达的点被分类为噪声。这些点不属于任何聚类。\n\n找到的聚类数（不包括噪声）是最终输出。该算法针对三个具有不同 $(\\varepsilon, m)$ 参数的测试用例运行，以探测其敏感性：\n-   **情况 A**：$(\\varepsilon, m) = (0.8, 3)$。这预计是“理想情况”，能正确识别两个主要聚类（紧凑和伸展）。\n-   **情况 B**：$(\\varepsilon, m) = (5.0, 3)$。大的 $\\varepsilon$ 预计会将两个聚类合并为一个。\n-   **情况 C**：$(\\varepsilon, m) = (0.5, 30)$。对 $m$ 的高要求非常严格，以至于没有点能符合核心点的资格，从而导致零个聚类。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the entire process: data generation,\n    metric calculation, clustering, and final output.\n    \"\"\"\n    \n    # ------------------ Global Parameters ------------------\n    N_ATOMS = 12\n    STEP_LENGTH = 1.5  # Angstrom\n    RANDOM_SEED = 42\n    \n    N_COMPACT = 24\n    N_EXTENDED = 24\n    N_NOISE = 12\n    \n    COMPACT_NOISE_STD = 0.05\n    EXTENDED_NOISE_STD = 0.05\n    EXTENDED_SCALE_FACTOR = 1.6\n    RANDOM_FRAMES_NOISE_STD = 0.2\n    \n    TEST_CASES = [\n        # (epsilon, min_points)\n        (0.8, 3),  # Case A: Happy path\n        (5.0, 3),  # Case B: Merge states\n        (0.5, 30), # Case C: No clusters\n    ]\n\n    # Initialize the random number generator for reproducibility\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    # ------------------ Helper Functions ------------------\n\n    def generate_random_walk(n_atoms, step_length):\n        \"\"\"Generates a 3D random walk structure.\"\"\"\n        coords = np.zeros((n_atoms, 3))\n        for i in range(1, n_atoms):\n            # Generate a random unit vector\n            vec = rng.standard_normal(3)\n            vec /= np.linalg.norm(vec)\n            coords[i] = coords[i-1] + step_length * vec\n        return coords\n\n    def get_centered_coords(coords):\n        \"\"\"Translates coordinates to have their center of mass at the origin.\"\"\"\n        com = np.mean(coords, axis=0)\n        return coords - com\n\n    def compute_rg(coords):\n        \"\"\"Computes the Radius of Gyration.\"\"\"\n        centered_coords = get_centered_coords(coords)\n        squared_dists = np.sum(centered_coords**2, axis=1)\n        return np.sqrt(np.mean(squared_dists))\n\n    def compute_rmsd(ref_coords, coords):\n        \"\"\"Computes the RMSD using the Kabsch algorithm.\"\"\"\n        ref_centered = get_centered_coords(ref_coords)\n        coords_centered = get_centered_coords(coords)\n        \n        # Covariance matrix\n        H = ref_centered.T @ coords_centered\n        \n        # SVD\n        U, _, Vt = np.linalg.svd(H)\n        \n        # Calculate rotation matrix with reflection correction\n        d = np.linalg.det(Vt.T @ U.T)\n        D = np.diag([1, 1, d])\n        R = Vt.T @ D @ U.T\n        \n        # Apply rotation\n        rotated_coords = coords_centered @ R.T\n        \n        # Calculate RMSD\n        diff = ref_centered - rotated_coords\n        return np.sqrt(np.sum(diff**2) / len(coords))\n\n    def dbscan_cluster(features, eps, min_pts):\n        \"\"\"\n        Performs density-based clustering based on problem specification.\n        Labels: 0 (unvisited), -1 (noise), >0 (cluster ID)\n        \"\"\"\n        n_points = features.shape[0]\n        labels = np.zeros(n_points, dtype=int)\n        cluster_id = 0\n        \n        # Pre-compute distance matrix for efficiency\n        dist_matrix = np.linalg.norm(features[:, np.newaxis, :] - features[np.newaxis, :, :], axis=2)\n\n        for i in range(n_points):\n            if labels[i] != 0:  # Already visited\n                continue\n            \n            # Find neighbors\n            neighbors_mask = dist_matrix[i] = eps\n            neighbor_indices = np.where(neighbors_mask)[0]\n\n            if len(neighbor_indices)  min_pts:\n                labels[i] = -1  # Mark as noise\n                continue\n                \n            # Core point found, start a new cluster\n            cluster_id += 1\n            labels[i] = cluster_id\n            \n            # Expand cluster\n            queue = deque(neighbor_indices)\n            while queue:\n                q_idx = queue.popleft()\n                \n                # if point was noise, it's now a border point of this cluster\n                if labels[q_idx] == -1:\n                    labels[q_idx] = cluster_id\n                \n                # if already processed, skip\n                if labels[q_idx] != 0:\n                    continue\n\n                labels[q_idx] = cluster_id\n                \n                # find neighbors of the new point\n                q_neighbors_mask = dist_matrix[q_idx] = eps\n                q_neighbor_indices = np.where(q_neighbors_mask)[0]\n\n                # if it's also a core point, add its neighbors to the queue\n                if len(q_neighbor_indices) >= min_pts:\n                    for nq_idx in q_neighbor_indices:\n                        if labels[nq_idx] == 0 or labels[nq_idx] == -1:\n                             if nq_idx not in queue:\n                                queue.append(nq_idx)\n\n        # Number of clusters is the count of unique positive cluster IDs\n        return len(np.unique(labels[labels > 0]))\n\n    # ------------------ Main Logic ------------------\n\n    # 1. Generate reference structure P\n    ref_structure = generate_random_walk(N_ATOMS, STEP_LENGTH)\n    ref_structure = get_centered_coords(ref_structure)\n\n    # 2. Generate trajectory frames\n    trajectory = []\n    # Compact frames\n    for _ in range(N_COMPACT):\n        rot = Rotation.random(random_state=rng).as_matrix()\n        frame = ref_structure @ rot.T\n        noise = rng.normal(0, COMPACT_NOISE_STD, size=frame.shape)\n        trajectory.append(frame + noise)\n        \n    # Extended frames\n    for _ in range(N_EXTENDED):\n        scaled_frame = ref_structure * EXTENDED_SCALE_FACTOR\n        rot = Rotation.random(random_state=rng).as_matrix()\n        frame = scaled_frame @ rot.T\n        noise = rng.normal(0, EXTENDED_NOISE_STD, size=frame.shape)\n        trajectory.append(frame + noise)\n        \n    # Noise frames\n    for _ in range(N_NOISE):\n        frame = generate_random_walk(N_ATOMS, STEP_LENGTH)\n        noise = rng.normal(0, RANDOM_FRAMES_NOISE_STD, size=frame.shape)\n        trajectory.append(frame + noise)\n\n    # 3. Compute features (RMSD, Rg) for each frame\n    feature_points = []\n    for frame in trajectory:\n        rmsd_val = compute_rmsd(ref_structure, frame)\n        rg_val = compute_rg(frame)\n        feature_points.append([rmsd_val, rg_val])\n    feature_points = np.array(feature_points)\n    \n    # 4. Run clustering for each test case\n    results = []\n    for eps, min_pts in TEST_CASES:\n        num_clusters = dbscan_cluster(feature_points, eps, min_pts)\n        results.append(num_clusters)\n        \n    # 5. Print final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}