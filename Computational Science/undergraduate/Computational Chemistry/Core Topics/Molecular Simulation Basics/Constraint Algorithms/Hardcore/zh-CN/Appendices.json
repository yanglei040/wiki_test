{
    "hands_on_practices": [
        {
            "introduction": "本节将通过一系列动手实践，帮助你巩固对约束算法（特别是 SHAKE）的理解。这些练习涵盖了从算法实现到实际应用和问题排查的各个方面。\n\n第一个练习将引导你完成 SHAKE 算法的核心实现。通过为一个简单的三原子体系编写约束求解器，你将直接体验迭代校正过程的机制。分析迭代次数如何随时间步长 $\\Delta t$ 变化，将揭示积分器的无约束步长与约束求解器所需工作量之间的关键关系 ，这是理解算法性能的基础。",
            "id": "2453574",
            "problem": "考虑一个由三个点质量（标记为 $0$、$1$ 和 $2$）构成的刚性三原子系统，该系统位于三维欧几里得空间中。位置是向量 $\\mathbf{r}_i \\in \\mathbb{R}^3$，速度是向量 $\\mathbf{v}_i \\in \\mathbb{R}^3$，其中 $i \\in \\{0,1,2\\}$。该系统受到两个完整约束（holonomic constraints），这两个约束固定了原子 $0$ 和原子 $1$ 之间以及原子 $0$ 和原子 $2$ 之间的距离。所有量均为无量纲量。\n\n初始数据：\n- 质量：$m_0 = 16$，$m_1 = 1$，$m_2 = 1$。\n- 距离约束：$d_{01} = 1$，$d_{02} = 1$。\n- 初始位置：$\\mathbf{r}_0 = (0,0,0)$，$\\mathbf{r}_1 = (1,0,0)$，$\\mathbf{r}_2 = (-1,0,0)$。\n- 初始速度：$\\mathbf{v}_0 = (0,0,0)$，$\\mathbf{v}_1 = (0.5,0.2,0)$，$\\mathbf{v}_2 = (-0.5,0.2,0)$。\n\n对于给定的时间步长 $\\Delta t  0$，通过前向欧拉运动学更新定义无约束的试验位置\n$$\n\\mathbf{r}_i^{(0)} = \\mathbf{r}_i + \\Delta t\\, \\mathbf{v}_i \\quad \\text{对于每个 } i \\in \\{0,1,2\\}。\n$$\n对于一个构型 $\\mathbf{r} = (\\mathbf{r}_0,\\mathbf{r}_1,\\mathbf{r}_2)$，定义两个约束函数如下\n$$\ng_{01}(\\mathbf{r}) = \\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - d_{01}^2, \\quad g_{02}(\\mathbf{r}) = \\|\\mathbf{r}_0 - \\mathbf{r}_2\\|^2 - d_{02}^2.\n$$\n从 $\\mathbf{r}^{(0)}$ 开始，通过对两个约束按 $(0,1)$ 然后 $(0,2)$ 的固定顺序依次应用重复的线性化投影，来迭代地施加约束。一次外层迭代包括按此顺序对两个约束进行一次完整扫描，并将以下更新规则应用于当前持有的位置。\n\n对于原子 $i$ 和 $j$ 之间具有目标距离 $d_{ij}$ 的单个约束，定义\n$$\n\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j, \\quad S = \\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}, \\quad g = S - d_{ij}^2.\n$$\n令\n$$\n\\alpha = \\frac{g}{2\\, S \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)}.\n$$\n通过以下方式更新两个原子的位置\n$$\n\\mathbf{r}_i \\leftarrow \\mathbf{r}_i - \\frac{\\alpha}{m_i}\\, \\mathbf{r}_{ij}, \\qquad\n\\mathbf{r}_j \\leftarrow \\mathbf{r}_j + \\frac{\\alpha}{m_j}\\, \\mathbf{r}_{ij}.\n$$\n\n将任意构型 $\\mathbf{r}$ 下的约束违反度量定义为\n$$\n\\varepsilon(\\mathbf{r}) = \\max\\left( \\left| g_{01}(\\mathbf{r}) \\right|, \\left| g_{02}(\\mathbf{r}) \\right| \\right).\n$$\n给定一个容差 $\\tau  0$，当 $\\varepsilon(\\mathbf{r}) \\le \\tau$ 时，称迭代收敛。迭代次数定义为达到收敛所需的外层迭代（对两个约束的完整扫描）次数，约定如果 $\\varepsilon(\\mathbf{r}^{(0)}) \\le \\tau$，则迭代次数为 $0$。如果在最多 $N_{\\max} = 10000$ 次外层迭代内未达到收斂，则报告迭代次数为 $-1$。\n\n任务：\n- 对于下面测试套件中的每一对 $(\\Delta t, \\tau)$，从给定的初始数据出发，构造 $\\mathbf{r}^{(0)}$ 并执行所定义的迭代强制过程。计算并返回迭代次数。\n\n测试套件包含以下几对 $(\\Delta t, \\tau)$：\n- $(0, 10^{-12})$，\n- $(5 \\times 10^{-3}, 10^{-12})$，\n- $(2 \\times 10^{-2}, 10^{-12})$，\n- $(10^{-1}, 10^{-12})$，\n- $(10^{-1}, 10^{-30})$。\n\n所有量均为无量纲量。您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的整数列表，列表内无空格，其顺序与测试套件中的顺序相同。",
            "solution": "经严格审查，问题陈述有效。其科学依据充分、提法恰当、客观且内容完整。该问题描述了一个简化的 SHAKE 算法的应用，这是一种计算分子动力学中用于满足完整约束的标准迭代方法。所有必要的数据、初始条件和算法规则都已明确无误地给出，没有歧义或矛盾。因此，我们可以着手构建解决方案。\n\n任务是确定一个顺序约束投影算法在一个三原子系统上收敛所需的迭代次数。该系统由三个质量 $m_0$、$m_1$ 和 $m_2$ 组成，在原子对 $(0,1)$ 和 $(0,2)$ 之间有固定的距离约束。\n\n该过程始于使用前向欧拉积分方案，在一个时间步长 $\\Delta t$ 内对原子位置进行无约束更新。给定初始位置 $\\mathbf{r}_i$ 和速度 $\\mathbf{v}_i$，试验位置（我们记为 $\\mathbf{r}^{(k)}$，其中 $k=0$）计算如下：\n$$\n\\mathbf{r}_i^{(0)} = \\mathbf{r}_i + \\Delta t\\, \\mathbf{v}_i \\quad \\text{for } i \\in \\{0, 1, 2\\}\n$$\n这些试验位置 $\\mathbf{r}^{(0)} = (\\mathbf{r}_0^{(0)}, \\mathbf{r}_1^{(0)}, \\mathbf{r}_2^{(0)})$ 通常不满足距离约束。约束以距离平方的形式给出：\n$$\ng_{01}(\\mathbf{r}) = \\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - d_{01}^2 = 0\n$$\n$$\ng_{02}(\\mathbf{r}) = \\|\\mathbf{r}_0 - \\mathbf{r}_2\\|^2 - d_{02}^2 = 0\n$$\n问题的核心是修正试验位置的迭代过程，直到这两个约束方程在给定容差 $\\tau$ 内得到满足。收敛性由最大绝对违反量来衡量：\n$$\n\\varepsilon(\\mathbf{r}) = \\max\\left( \\left| g_{01}(\\mathbf{r}) \\right|, \\left| g_{02}(\\mathbf{r}) \\right| \\right)\n$$\n当 $\\varepsilon(\\mathbf{r}) \\le \\tau$ 时，迭代停止。\n\n算法的一次外层迭代包括依次对每个约束施加一次校正。这是一种 Gauss-Seidel 型迭代，其中一个约束满足步骤的更新会立即用于下一步。\n\n对于原子 $i$ 和 $j$ 之间的一般约束，该算法会校正位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$。校正量由约束方程的线性化近似推导得出。设当前位置为 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$。建议的更新如下：\n$$\n\\mathbf{r}_i^{\\text{new}} = \\mathbf{r}_i - \\frac{\\alpha}{m_i} (\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n$$\n\\mathbf{r}_j^{\\text{new}} = \\mathbf{r}_j + \\frac{\\alpha}{m_j} (\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n相对位置向量变换如下：\n$$\n\\mathbf{r}_{ij}^{\\text{new}} = \\mathbf{r}_i^{\\text{new}} - \\mathbf{r}_j^{\\text{new}} = (\\mathbf{r}_i - \\mathbf{r}_j) - \\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)(\\mathbf{r}_i - \\mathbf{r}_j) = \\left(1 - \\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right) \\mathbf{r}_{ij}\n$$\n其长度平方为 $\\|\\mathbf{r}_{ij}^{\\text{new}}\\|^2 = \\left(1 - \\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right)^2 \\|\\mathbf{r}_{ij}\\|^2$。\n指定算法的关键步骤是对此关系式相对于 $\\alpha$ 进行线性化，假设 $\\alpha$ 很小：\n$$\n\\|\\mathbf{r}_{ij}^{\\text{new}}\\|^2 \\approx \\left(1 - 2\\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right) \\|\\mathbf{r}_{ij}\\|^2\n$$\n我们希望新的距离平方为 $d_{ij}^2$。令 $\\|\\mathbf{r}_{ij}^{\\text{new}}\\|^2 = d_{ij}^2$ 可得：\n$$\nd_{ij}^2 \\approx \\|\\mathbf{r}_{ij}\\|^2 - 2\\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) \\|\\mathbf{r}_{ij}\\|^2\n$$\n重新整理以求解 $\\alpha$ 得：\n$$\n2\\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) \\|\\mathbf{r}_{ij}\\|^2 \\approx \\|\\mathbf{r}_{ij}\\|^2 - d_{ij}^2\n$$\n使用 $S = \\|\\mathbf{r}_{ij}\\|^2 = \\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}$ 和 $g = S - d_{ij}^2$，我们得到问题中给出的 $\\alpha$ 表达式：\n$$\n\\alpha = \\frac{g}{2 S \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)}\n$$\n这证实了所规定更新规则的科学有效性。\n\n针对每个测试用例 $(\\Delta t, \\tau)$ 的总体算法实现如下：\n1.  初始化系统质量 ($m_0=16, m_1=1, m_2=1$)、初始位置 ($\\mathbf{r}_0=(0,0,0), \\mathbf{r}_1=(1,0,0), \\mathbf{r}_2=(-1,0,0)$)、初始速度 ($\\mathbf{v}_0=(0,0,0), \\mathbf{v}_1=(0.5,0.2,0), \\mathbf{v}_2=(-0.5,0.2,0)$) 和距离平方 ($d_{01}^2=1, d_{02}^2=1$)。\n2.  使用给定的 $\\Delta t$ 通过前向欧拉步长计算试验位置 $\\mathbf{r}^{(0)}$。\n3.  计算初始约束违反度 $\\varepsilon(\\mathbf{r}^{(0)})$。如果它小于或等于 $\\tau$，则迭代次数为 $0$。这处理了 $\\Delta t = 0$ 的平凡情况。\n4.  如果初始违反度超过 $\\tau$，则进入一个最多运行 $N_{\\max} = 10000$ 次外层迭代的循环。\n5.  在每次外层迭代 $k = 1, 2, \\ldots, N_{\\max}$ 中：\n    a. 对原子 $0$ 和 $1$ 之间的约束应用更新规则，更新它们的位置 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$。\n    b. 使用新更新的 $\\mathbf{r}_0$ 位置，对原子 $0$ 和 $2$ 之间的约束应用更新规则，更新位置 $\\mathbf{r}_0$ 和 $\\mathbf{r}_2$。\n    c. 用完全更新后的位置重新计算约束违反度 $\\varepsilon$。\n    d. 如果 $\\varepsilon \\le \\tau$，则达到收敛。迭代次数为 $k$。循环终止。\n6.  如果循环完成而未达到收敛，则报告迭代次数为 $-1$。\n\n该过程使用 Python 的 `numpy` 库实现，以进行高效的向量和矩阵运算。该实现为五个测试用例中的每一个都仔细处理了顺序更新和终止条件。将得到的迭代次数收集起来并按规定格式化。对于容差极小（$\\tau = 10^{-30}$）的情况，收敛受限于标准双精度浮点运算的机器精度（约为 $10^{-16}$）。如果误差无法减小到此限制以下，算法将无法收敛到指定的容差并将超时，导致迭代次数为 $-1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        (0.0, 1e-12),\n        (5e-3, 1e-12),\n        (2e-2, 1e-12),\n        (1e-1, 1e-12),\n        (1e-1, 1e-30),\n    ]\n\n    results = []\n    for dt, tau in test_cases:\n        count = calculate_iterations(dt, tau)\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_iterations(dt, tau):\n    \"\"\"\n    Calculates the number of SHAKE iterations for a given time step and tolerance.\n    \"\"\"\n    # Initial data\n    masses = np.array([16.0, 1.0, 1.0])\n    d_sq = np.array([1.0, 1.0])  # d_01^2, d_02^2\n    r_initial = np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [-1.0, 0.0, 0.0]])\n    v_initial = np.array([[0.0, 0.0, 0.0], [0.5, 0.2, 0.0], [-0.5, 0.2, 0.0]])\n    N_max = 10000\n\n    # Unconstrained trial positions\n    r = r_initial + dt * v_initial\n    \n    # Check initial violation\n    g01 = np.sum((r[0] - r[1])**2) - d_sq[0]\n    g02 = np.sum((r[0] - r[2])**2) - d_sq[1]\n    error = max(abs(g01), abs(g02))\n    \n    if error = tau:\n        return 0\n\n    # Iterative enforcement loop\n    for k in range(1, N_max + 1):\n        # Apply constraint (0, 1)\n        r_ij = r[0] - r[1]\n        S = np.dot(r_ij, r_ij)\n        if S == 0.0: return -1 # Atom collision, invalid state\n        g = S - d_sq[0]\n        inv_mass_sum = 1.0/masses[0] + 1.0/masses[1]\n        alpha = g / (2.0 * S * inv_mass_sum)\n        \n        delta_r0 = - (alpha / masses[0]) * r_ij\n        delta_r1 = + (alpha / masses[1]) * r_ij\n        \n        r[0] += delta_r0\n        r[1] += delta_r1\n\n        # Apply constraint (0, 2)\n        r_ij = r[0] - r[2]\n        S = np.dot(r_ij, r_ij)\n        if S == 0.0: return -1 # Atom collision, invalid state\n        g = S - d_sq[1]\n        inv_mass_sum = 1.0/masses[0] + 1.0/masses[2]\n        alpha = g / (2.0 * S * inv_mass_sum)\n\n        delta_r0 = - (alpha / masses[0]) * r_ij\n        delta_r2 = + (alpha / masses[2]) * r_ij\n        \n        r[0] += delta_r0\n        r[2] += delta_r2\n\n        # Check for convergence\n        g01 = np.sum((r[0] - r[1])**2) - d_sq[0]\n        g02 = np.sum((r[0] - r[2])**2) - d_sq[1]\n        error = max(abs(g01), abs(g02))\n\n        if error = tau:\n            return k\n            \n    return -1 # Not converged within N_max iterations\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了 SHAKE 的基本实现后，我们需要考虑如何在更真实的模拟环境中应用它。分子动力学模拟几乎总是在周期性边界条件（Periodic Boundary Conditions, PBC）下进行，这给约束处理带来了新的挑战。当一个被约束的键跨越盒子边界时，我们必须采用正确的物理原则来计算它们之间的相互作用 。这个练习旨在检验你对最小镜像约定（Minimum Image Convention, MIC）的理解，这是在周期性体系中正确处理所有相互作用和约束的根本原则。",
            "id": "2453492",
            "problem": "您正在周期性边界条件（PBC）下的分子动力学（MD）中使用SHAKE约束算法模拟一个键长固定的双原子分子。该系统是一个边长为 $L_x$、$L_y$ 和 $L_z$ 的正交周期性盒子。在一个未约束的积分步骤结束时，原子 $i$ 的位置为 $\\mathbf{r}_i^{\\ast}$，原子 $j$ 的位置为 $\\mathbf{r}_j^{\\ast}$。$i$ 和 $j$ 之间的键被约束在目标距离 $d_{0}$，但在此步骤中，这两个原子恰好位于周期性边界的两侧，因此原始的差分向量 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$ 指向盒子的另一端。您现在需要应用SHAKE来对这对原子实施键长约束。\n\n哪种程序最能确保在与PBC一致的情况下正确实施约束，同时在SHAKE校正的层面上保持线性动量守恒？\n\nA. 使用周期性成像计算相对向量，使其成为最小镜像分离向量 $\\mathbf{r}_{ij}^{\\text{min}}$，沿着 $\\mathbf{r}_{ij}^{\\text{min}}$ 求解SHAKE校正，并对原子 $i$ 和 $j$ 进行质量加权的大小相等、方向相反的位移，更新位置，然后将校正后的位置重新包裹回主模拟盒子中。\n\nB. 通过将原子 $i$ 和 $j$ 的坐标展开到同一个镜像中来暂时禁用此键的PBC，在绝对坐标中无需任何镜像映射即可实施SHAKE，并在此后保留展开后的位置以避免未来的跨界。\n\nC. 使用跨越边界的原始坐标差 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$ 来计算和应用SHAKE校正，因为SHAKE实施的是标量距离 $d_{0}$，而不管校正向量的方向和大小。\n\nD. 将两个原子沿同一向量平移，使它们位于同一个盒子镜像中，使用盒子内的差分应用SHAKE，并保留共同的平移，以便其他相互作用不受约束更新的影响。",
            "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n### 步骤 1：提取给定信息\n- **系统**：一个由原子 $i$ 和 $j$ 组成的双原子分子。\n- **算法**：用于分子动力学（MD）的SHAKE约束算法。\n- **边界条件**：正交盒子中的周期性边界条件（PBC）。\n- **盒子尺寸**：边长 $L_x$、$L_y$ 和 $L_z$。\n- **约束**：原子 $i$ 和 $j$ 之间的键长固定为目标距离 $d_{0}$。\n- **初始状态（未约束）**：一个积分步骤后，原子位置为 $\\mathbf{r}_i^{\\ast}$ 和 $\\mathbf{r}_j^{\\ast}$。\n- **特定条件**：原子 $i$ 和 $j$ 位于周期性边界的两侧，意味着原始差分向量 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$ 跨越了模拟盒子。\n- **目标**：确定正确的程序来实施键长约束，该程序需与PBC一致，并为SHAKE校正保持线性动量守恒。\n\n### 步骤 2：使用提取的给定信息进行验证\n该问题描述了在分子模拟中，在周期性边界条件下实施约束算法时的一个标准的、根本性的挑战。\n- **科学基础**：该问题基于计算化学和物理学的既定原理。SHAKE算法和周期性边界条件是分子动力学中的基石技术。键跨越周期性边界的情景是模拟软件必须正确处理的常见情况。\n- **适定性**：问题陈述清晰，并要求在一组选项中选择正确的程序。存在唯一、正确的方法，并且在分子模拟的文献中有详细记载。\n- **客观性**：语言技术性强、精确，且不含主观内容。\n\n问题陈述在科学上是合理的、适定的、客观的，并且不包含评估所提出程序所必需的内部矛盾或缺失信息。它没有违反任何指定的无效性标准。\n\n### 步骤 3：结论和行动\n该问题是**有效的**。将推导解决方案并评估选项。\n\n### 正确程序的推导\n\n在具有周期性边界条件（PBC）的分子动力学模拟中，模拟盒子在概念上在空间中无限复制。任意两个粒子（例如 $i$ 和 $j$）之间的物理相互作用必须基于它们之间最短的可能距离，这需要考虑粒子 $j$ 相对于粒子 $i$ 的所有周期性镜像（反之亦然）。这个原则被称为**最小镜像约定（Minimum Image Convention, MIC）**。\n\n让一个时间步结束时的未约束位置为 $\\mathbf{r}_i^{\\ast}$ 和 $\\mathbf{r}_j^{\\ast}$。原始向量差为 $\\mathbf{d} = \\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$。为了应用MIC，我们通过盒子向量（$\\mathbf{L} = (L_x, L_y, L_z)$）的整数倍来调整该向量，以找到具有最小幅值的向量。对于正交盒子，这是按分量进行的。例如，对于 $x$ 分量：\n$d_x^{\\text{min}} = d_x - L_x \\cdot \\text{round}(d_x / L_x)$。\n得到的向量 $\\mathbf{r}_{ij}^{\\text{min}}$，其分量为 $(d_x^{\\text{min}}, d_y^{\\text{min}}, d_z^{\\text{min}})$，代表了两个成键原子之间真实的物理分离。\n\nSHAKE算法旨在校正位置以满足几何约束。对于距离约束 $\\sigma = |\\mathbf{r}_{ij}|^2 - d_0^2 = 0$，位置更新如下：\n$$ \\mathbf{r}_k = \\mathbf{r}_k^{\\ast} + \\delta \\mathbf{r}_k $$\n校正量 $\\delta \\mathbf{r}_k$ 沿着约束函数的梯度方向。对于原子 $i$ 和 $j$ 之间的键，约束力是该原子对的内力，并沿着连接它们的向量作用。为了保持该原子对的线性动量，动量校正的总和必须为零：$m_i \\delta \\mathbf{r}_i + m_j \\delta \\mathbf{r}_j = \\mathbf{0}$。这通过将位置校正设置为与键向量 $\\mathbf{r}_{ij}$ 平行并与质量成反比来实现：\n$$ \\delta \\mathbf{r}_i = -\\frac{\\lambda}{m_i} \\mathbf{r}_{ij} $$\n$$ \\delta \\mathbf{r}_j = +\\frac{\\lambda}{m_j} \\mathbf{r}_{ij} $$\n其中 $\\lambda$ 是通过求解约束方程 $|\\mathbf{r}_j - \\mathbf{r}_i|^2 = d_0^2$ 确定的拉格朗日乘子。\n\n至关重要的是，这些方程中使用的向量 $\\mathbf{r}_{ij}$ 必须是具有物理意义的分离向量，在PBC下即为最小镜像向量 $\\mathbf{r}_{ij}^{\\text{min}}$。使用跨越盒子的原始“未展开”向量将对应于一个巨大的、非物理的距离，导致灾难性的大且不正确的校正力。\n\n因此，正确的操作顺序是：\n1.  对于约束对 $(i, j)$，计算差分向量 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$。\n2.  对该向量应用最小镜像约定，以获得物理上正确的分离向量 $\\mathbf{r}_{ij}^{\\text{min}}$。\n3.  使用 $\\mathbf{r}_{ij}^{\\text{min}}$ 求解SHAKE方程，得到质量加权的、动量守恒的位置校正 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$。\n4.  应用这些校正以获得最终的、受约束的位置：$\\mathbf{r}_i = \\mathbf{r}_i^{\\ast} + \\delta \\mathbf{r}_i$ 和 $\\mathbf{r}_j = \\mathbf{r}_j^{\\ast} + \\delta \\mathbf{r}_j$。\n5.  在所有原子的所有约束都得到满足后（这可能需要几个迭代的SHAKE循环），最终位置可以被重新包裹回主模拟盒子中（例如，将所有坐标映射到 $[0, L_x)$ 等）。这种重新包裹是用于记录管理的修饰步骤，不影响系统的物理性质。\n\n### 选项评估\n\n**A. 使用周期性成像计算相对向量，使其成为最小镜像分离向量 $\\mathbf{r}_{ij}^{\\text{min}}$，沿着 $\\mathbf{r}_{ij}^{\\text{min}}$ 求解SHAKE校正，并对原子 $i$ 和 $j$ 进行质量加权的大小相等、方向相反的位移，更新位置，然后将校正后的位置重新包裹回主模拟盒子中。**\n这个程序与推导出的正确方法完全匹配。\n- 它正确地优先使用MIC来找到物理分离向量 $\\mathbf{r}_{ij}^{\\text{min}}$。\n- 它正确地沿着这个向量应用SHAKE校正。\n- “质量加权的大小相等、方向相反的位移”是对动量守恒更新的一种略微不精确但常见的描述，其中 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$ 方向相反，并按其各自质量的倒数进行缩放。\n- 它正确地将重新包裹识别为最终的、更新后的步骤。\n**结论：正确。**\n\n**B. 通过将原子 $i$ 和 $j$ 的坐标展开到同一个镜像中来暂时禁用此键的PBC，在绝对坐标中无需任何镜像映射即可实施SHAKE，并在此后保留展开后的位置以避免未来的跨界。**\n这个程序开始时是正确的，即“展开”，这等同于找到最小镜像分离。然而，“在此后保留展开后的位置”的指令是一个致命错误。这破坏了整个系统的PBC框架。如果允许一个原子的坐标漂移到远离主盒子的地方，它与系统中所有其他粒子的相互作用计算将变得不正确，因为它们将不再受最小镜像约定的约束。这会破坏周期性系统的模拟。\n**结论：不正确。**\n\n**C. 使用跨越边界的原始坐标差 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$ 来计算和应用SHAKE校正，因为SHAKE实施的是标量距离 $d_{0}$，而不管校正向量的方向和大小。**\n这在根本上是错误的。原始坐标差是一个非物理向量，其大小由盒子尺寸决定，而不是键长。在SHAKE算法中使用它会产生巨大的、非物理的力，试图将原子拉过整个盒子，从而完全破坏模拟。所提供的理由也是错误的；SHAKE校正的大小和方向直接依赖于当前的原子间向量。该程序违反了最小镜像约定，这是PBC中力和约束计算的强制性原则。\n**结论：不正确。**\n\n**D. 将两个原子沿同一向量平移，使它们位于同一个盒子镜像中，使用盒子内的差分应用SHAKE，并保留共同的平移，以便其他相互作用不受约束更新的影响。**\n这个选项在逻辑上是有缺陷的。如果你将**两个**原子沿**相同**的向量 $\\mathbf{V}$ 平移，它们的相对向量 $(\\mathbf{r}_j+\\mathbf{V}) - (\\mathbf{r}_i+\\mathbf{V}) = \\mathbf{r}_j - \\mathbf{r}_i$ 保持不变。这并不能解决键跨越边界的问题。所提议行动的前提是荒谬的。此外，“保留共同的平移”构成了该原子对质心的移动，这违反了线性动量守恒。这个程序定义不清，物理上也是不正确的。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "任何计算科学家的关键技能之一是验证和调试自己的代码和模拟。在微正则系综（NVE）模拟中，总能量守恒是衡量模拟是否正确和稳定的首要指标。然而，由于数值误差，能量漂移是一个常见问题。这个练习  提出了一个真实的能量漂移场景，并要求你设计最佳的诊断测试来区分误差来源——是源于积分器本身，还是源于约束算法。这能训练你排查模拟问题时的批判性思维过程。",
            "id": "2453550",
            "problem": "您已经实现了一个 SHAKE 约束算法（通常简称为 SHAKE），用于在一个使用 Velocity Verlet (VV) 积分器的分子动力学 (MD) 代码中，强制执行形式为 $g_k(\\mathbf{r}) = \\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert^2 - \\ell_{ij}^2 = 0$ 的全息键长约束。位置通过求解拉格朗日乘子 $\\boldsymbol{\\lambda}$ 并应用质量加权位移 $\\delta \\mathbf{r} = \\mathbf{M}^{-1} \\mathbf{G}^\\top \\boldsymbol{\\lambda}$ 进行迭代校正，直到最大绝对约束残差低于容差 $\\varepsilon$ 或达到最大迭代次数 $N_{\\mathrm{max}}$。速度在步末进行一致性校正。您正在对一个刚性水模型进行恒定粒子数、体积、能量 (NVE) 系综的模拟，其中受约束的键不随时间变化，时间步长为 $\\Delta t = 1\\,\\mathrm{fs}$，容差为 $\\varepsilon = 10^{-6}$（内部单位），且 $N_{\\mathrm{max}} = 100$。在 $10^5$ 步之后，总能量表现出约 $1\\,\\%$ 的近乎线性的漂移。您已验证非键力是使用约束后的位置计算的。\n\n以下哪项是确定所观察到的能量漂移主要是由约束求解器还是由基础积分器设置引起的最合适的首要诊断性测试？\n\nA. 将时间步长减半至 $\\Delta t = 0.5\\,\\mathrm{fs}$，同时保持 $\\varepsilon$ 和 $N_{\\mathrm{max}}$ 不变，并比较单位时间的能量漂移；将 $\\Delta t$ 减半后漂移大幅减少表明是时间步长或积分器误差，而变化很小则表明是约束求解器误差。\n\nB. 完全禁用约束，并以相同的 $\\Delta t$ 重新运行模拟；如果无约束系统能量守恒，则断定 SHAKE 算法是根本原因。\n\nC. 将所有算术运算从双精度切换到单精度，以减少迭代求解器中的相消误差，并评估漂移是否有所改善。\n\nD. 将 SHAKE 的最大迭代次数减少到 $N_{\\mathrm{max}} = 1$，以避免过度校正约束，从而防止数值能量注入。\n\nE. 通过在 $600\\,\\mathrm{K}$ 应用温控器来提高目标温度，以掩盖漂移并检查平均能量是否变得平稳。",
            "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n### 步骤 1：提取已知条件\n- **系综：** 恒定粒子数、体积、能量 (NVE)。\n- **积分器：** Velocity Verlet (VV)。\n- **约束算法：** SHAKE。\n- **系统：** 具有不随时间变化的全息键长约束的刚性水模型。\n- **约束形式：** $g_k(\\mathbf{r}) = \\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert^2 - \\ell_{ij}^2 = 0$。\n- **SHAKE 更新：** 位置通过 $\\delta \\mathbf{r} = \\mathbf{M}^{-1} \\mathbf{G}^\\top \\boldsymbol{\\lambda}$ 进行迭代校正。\n- **模拟参数：**\n    - 时间步长：$\\Delta t = 1\\,\\mathrm{fs}$。\n    - SHAKE 容差：$\\varepsilon = 10^{-6}$（内部单位）。\n    - SHAKE 最大迭代次数：$N_{\\mathrm{max}} = 100$。\n- **观察：** 在 $10^5$ 步之后，总能量表现出约 $1\\,\\%$ 的近乎线性的漂移。\n- **验证：** 非键力是使用约束后的位置计算的。\n- **目标：** 确定最合适的首要诊断性测试，以区分由约束求解器引起的能量漂移和由基础积分器引起的能量漂移。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了分子动力学 (MD) 模拟中的一个标准场景。将 Velocity Verlet 积分器与 SHAKE 算法相结合，用于在 NVE 系综中模拟刚性分子。能量守恒是对此类模拟正确性的关键测试。\n\n- **科学依据：** 该设置完全是标准的。VV 积分器、SHAKE 算法、约束方程的形式、使用 NVE 系综检查能量守恒以及模拟水的参数都与计算化学和物理学中的既定实践相符。观察到的能量漂移是一种需要诊断的常见人为现象。该陈述在科学上是合理的。\n- **提问方式恰当：** 该问题要求选择一种方法论——一种诊断性测试——来区分两种潜在的误差来源。在给定背景下，这是科学计算和模拟验证领域中一个提问方式恰当的问题。\n- **客观性：** 问题以精确、技术性的术语陈述，不含主观性。\n- **完整性和一致性：** 所提供的信息足以评估建议的诊断性测试。没有内部矛盾。例如，它正确地指出非键力是用*约束后的*位置计算的，这是正确实现的必要条件。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。它在科学上是合理的，提问方式恰当，并为对所提出的选项进行严格分析提供了足够的背景。我将继续进行解答。\n\n### 推导与选项分析\n\n系统的总能量为 $E_{\\text{tot}} = E_{\\text{kin}}(\\mathbf{v}) + V(\\mathbf{r})$。在一个理想的哈密顿系统的 NVE 模拟中，$\\frac{dE_{\\text{tot}}}{dt} = 0$。在数值模拟中，由于多种误差来源，我们观察到漂移 $\\Delta E_{\\text{tot}} \\neq 0$。挑战在于识别主导误差来源。\n\nVelocity Verlet 算法在应用于无约束系统时是保辛的。这意味着它会保守一个接近真实哈密顿量的“影子”哈密顿量，从而实现出色的长期能量守恒，其特征是围绕一个常数的有界涨落，且系统性漂移极小或没有。这些涨落的幅度按 $O(\\Delta t^2)$ 比例缩放。\n\n通过像 SHAKE 这样的迭代算法引入全息约束（在无约束的 VV 步*之后*应用），破坏了积分器的保辛性。整个算法，即 VV-SHAKE，不再是保辛的。这种非保辛性是系统性能量漂移的一个主要来源。VV-SHAKE 模拟中的总误差来自两个主要部分：\n1.  **积分器离散化误差：** 此误差是 Velocity Verlet 算法本身固有的，并且是时间步长 $\\Delta t$ 的函数。局部误差为 $O(\\Delta t^4)$，能量的全局漂移预计对 $\\Delta t$ 表现出强烈的依赖性，通常按某个幂次如 $O(\\Delta t^p)$（其中 $p \\ge 2$）缩放。\n2.  **约束求解器误差：** 此误差源于 SHAKE 算法以迭代方式并将约束方程求解到有限容差 $\\varepsilon$ 的事实。如果算法未能在 $N_{\\mathrm{max}}$ 次迭代内收敛，或者如果容差 $\\varepsilon$太大，约束 $g_k(\\mathbf{r}) = 0$ 就没有被完美满足。这意味着约束力所做的功不完全为零，导致在每一步中向系统净注入或移除能量。此误差取决于 $\\varepsilon$、$N_{\\mathrm{max}}$ 和系统属性，但也取决于 $\\Delta t$，因为更小的时间步长导致更小的无约束位移，使 SHAKE 更容易收敛。\n\n目标是设计一个测试，能够区分组件（1）的失败与组件（2）的失败。\n\n**选项 A：将时间步长减半至 $\\Delta t = 0.5\\,\\mathrm{fs}$，同时保持 $\\varepsilon$ 和 $N_{\\mathrm{max}}$ 不变，并比较单位时间的能量漂移；将 $\\Delta t$ 减半后漂移大幅减少表明是时间步长或积分器误差，而变化很小则表明是约束求解器误差。**\n\n这是诊断与时间步长相关误差的标准且严谨的方法。来自 VV 积分器的误差贡献对 $\\Delta t$ 高度敏感。如果观察到的 $1\\,\\%$ 的漂移主要是由于时间步长对于势能面来说过大，那么将 $\\Delta t$ 从 $1\\,\\mathrm{fs}$ 减半到 $0.5\\,\\mathrm{fs}$ 应该会大幅减少能量漂移率。例如，如果漂移率按 $O(\\Delta t^2)$ 缩放，它应该会减少 4 倍。相反，如果问题根本在于 SHAKE 求解器（例如，实现中的一个错误，或一个特别刚性的构型导致无论 $\\Delta t$ 是否合理都存在收敛问题），则漂移可能对 $\\Delta t$ 的变化不那么敏感。虽然较小的 $\\Delta t$ 有助于 SHAKE 收敛，但一个持续存在且仅略微减少的大漂移将指向约束求解器是主要罪魁祸首。此方法有效地隔离了时间步长的影响，而时间步长是基础积分器准确性的决定性参数。\n\n**结论：正确。**\n\n**选项 B：完全禁用约束，并以相同的 $\\Delta t$ 重新运行模拟；如果无约束系统能量守恒，则断定 SHAKE 算法是根本原因。**\n\n这是一个无效的诊断程序。该系统是一个刚性水模型。“刚性”是由约束强制执行的。如果禁用约束，模型将变为柔性。柔性水模型中的分子内键伸缩和角弯曲振动具有非常高的频率。要使用 Velocity Verlet 算法稳定地积分这些运动，需要小得多的时间步长，通常在 $0.1\\,\\mathrm{fs}$到 $0.2\\,\\mathrm{fs}$ 的量级。尝试用 $\\Delta t = 1\\,\\mathrm{fs}$ 模拟柔性水模型将导致共振和即时的数值不稳定性，使能量爆炸。模拟将不会能量守恒；它会灾难性地失败。因此，所提议的比较在物理上和数值上都是无意义的。通过将其与一个不稳定的模拟进行比较，无法了解任何关于 SHAKE 性能的信息。\n\n**结论：不正确。**\n\n**选项 C：将所有算术运算从双精度切换到单精度，以减少迭代求解器中的相消误差，并评估漂移是否有所改善。**\n\n这个建议是违反直觉且不正确的。双精度使用大约 64 位来表示一个浮点数，提供约 15-17 个十进制位的精度。单精度使用 32 位，提供约 7 个十进制位的精度。SHAKE 中耦合非线性方程组的迭代求解对数值精度很敏感。切换到单精度会增加舍入误差，而不是减少它们。相消误差，即在减去几乎相等的数时发生，是舍入误差的一种形式，在精度较低时会变得更严重。因此，这一改变几乎肯定会恶化约束的满足程度，并导致更大而非更小的能量漂移。\n\n**结论：不正确。**\n\n**选项 D：将 SHAKE 的最大迭代次数减少到 $N_{\\mathrm{max}} = 1$，以避免过度校正约束，从而防止数值能量注入。**\n\n这表明了对迭代求解器的误解。SHAKE 校正位置以满足约束。对于像水这样的系统，通常每个时间步需要多次迭代（例如，3-8 次）才能收敛到一个严格的容差。将其限制为 $N_{\\mathrm{max}} = 1$ 可确保算法过早终止，远未达到正确解。在步末，约束将被严重违反。这种未能正确执行几何结构是能量漂移的直接原因。“过度校正”的概念在这里不适用；问题是由于迭代不足导致的“校正不足”。此操作将增加而非减少能量漂移。\n\n**结论：不正确。**\n\n**选项 E：通过在 $600\\,\\mathrm{K}$ 应用温控器来提高目标温度，以掩盖漂移并检查平均能量是否变得平稳。**\n\n这种方法使得诊断的前提完全失效。问题是在 NVE 系综中观察到的，其中总能量是关注的守恒量。应用温控器将系综更改为 NVT。温控器的功能是增加或移除能量以维持目标温度，从而通过设计破坏能量守恒。来自积分器或约束算法的任何内在漂移都将被温控器施加的大得多的能量涨落完全掩盖。检查“平均能量是否变得平稳”对于 NVT 模拟不是一个有意义的诊断，在 NVT 模拟中，能量预计会围绕由温度决定的平均值波动。这个程序不能诊断问题；它是在隐藏问题。\n\n**结论：不正确。**\n\n总之，在这些选项中，唯一科学上合理且标准的诊断程序是测试系统对积分时间步长的敏感性，如选项 A 所述。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}