{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握 Metropolis 准则，第一步是能够在一个具体的物理模型中计算接受概率。这个练习将带你进入一个二维格点气体的世界，这是一种在凝聚态物理中广泛使用的模型。通过计算一个粒子移动前后系统能量的变化量 $\\Delta E$，你将直接应用 Metropolis 公式，这是实现任何蒙特卡洛模拟最核心的计算步骤 。",
            "id": "857503",
            "problem": "一个二维晶格气体定义在一方形晶格上。系统的状态由一组占据数 $\\{n_i\\}$ 给出，其中如果格点 $i$ 被粒子占据，则 $n_i=1$，如果格点为空，则 $n_i=0$。粒子总数是恒定的。粒子与其最近邻相互作用。相互作用是各向异性的：与水平最近邻对相关的能量为 $-J_h$，与垂直最近邻对相关的能量为 $-J_v$。参数 $J_h$ 和 $J_v$ 是正常数，代表吸引力。系统的总能量（哈密顿量）为：\n$$H = -J_h \\sum_{\\langle i,j \\rangle_h} n_i n_j - J_v \\sum_{\\langle k,l \\rangle_v} n_k n_l$$\n其中，求和分别遍及所有水平和垂直的最近邻对。\n\n系统与逆温度为 $\\beta = 1/(k_B T)$ 的热浴处于热平衡状态。系统的动力学使用 Metropolis 算法进行模拟。一次尝试移动包括选择一个粒子和一个空的最近邻格点，并提议将该粒子移动到该空格点。从状态 $x$ 移动到状态 $x'$ 的接受概率 $A$ 由下式给出：\n$$A(x \\to x') = \\min\\left(1, \\exp(-\\beta \\Delta E)\\right)$$\n其中 $\\Delta E = E(x') - E(x)$ 是系统能量的变化。\n\n考虑一个特定的局部构型，其中一个粒子 `P` 位于格点 $s = (r, c)$（第 $r$ 行，第 $c$ 列）。格点 $s' = (r, c+1)$ 是空的。其他相邻格点的占据情况如下：\n- 格点 $s$ 的邻居：\n    - 格点 $(r-1, c)$ 和 $(r+1, c)$ 被占据。\n    - 格点 $(r, c-1)$ 是空的。\n- 目标格点 $s'$ 的邻居：\n    - 格点 $(r, c+2)$ 被占据。\n    - 格点 $(r-1, c+1)$ 和 $(r+1, c+1)$ 是空的。\n\n提议一次尝试移动，将粒子 `P` 从格点 $s$ 移动到格点 $s'$。推导此移动的 Metropolis 接受概率 $A$ 作为 $\\beta$、$J_h$ 和 $J_v$ 的函数。",
            "solution": "我们使用 Metropolis 法则\n$$A=\\min\\bigl(1,\\exp(-\\beta\\Delta E)\\bigr),\\qquad \\Delta E=E_{\\rm f}-E_{\\rm i}.$$\n初始局部能量：位于 $s=(r,c)$ 的粒子有两个被占据的垂直邻居，每个贡献 $-J_v$，因此\n$$E_{\\rm i}=-2J_v.$$\n最终局部能量：位于 $s'=(r,c+1)$ 的粒子在 $(r,c+2)$ 处有一个被占据的水平邻居，贡献 $-J_h$，因此\n$$E_{\\rm f}=-J_h.$$\n因此\n$$\\Delta E=E_{\\rm f}-E_{\\rm i}=-J_h-(-2J_v)=2J_v-J_h$$\n且\n$$A=\\min\\bigl(1,\\exp\\bigl(-\\beta(2J_v-J_h)\\bigr)\\bigr).$$",
            "answer": "$$\\boxed{\\min\\!\\bigl(1,\\exp\\bigl(-\\beta\\,(2J_v - J_h)\\bigr)\\bigr)}$$"
        },
        {
            "introduction": "在掌握了基本计算之后，让我们通过一个思想实验来检验我们对 Metropolis 算法背后原理的理解。在计算化学中，我们使用的势能函数往往包含一个任意的能量零点偏移。这个练习探讨了这种系统性的能量偏移是否会影响模拟的最终结果 。它揭示了一个深刻而关键的事实：Metropolis 算法的有效性完全依赖于能量的*差异*，而非其绝对值，这正是该算法设计的基石。",
            "id": "2465263",
            "problem": "在温度为$T$的正则系综Metropolis蒙特卡罗模拟中，使用势能函数$E_{\\mathrm{calc}}(\\mathbf{x})$来评估尝试移动，其中$\\mathbf{x}$表示构型。假设由于一个系统性的建模选择，计算得到的能量相对于真实势能$E_{\\mathrm{true}}(\\mathbf{x})$偏移了一个恒定的偏移量$C$，使得对于所有$\\mathbf{x}$都有$E_{\\mathrm{calc}}(\\mathbf{x}) = E_{\\mathrm{true}}(\\mathbf{x}) + C$。提议机制是对称的，并且采用了基于玻尔兹曼权重的标准Metropolis接受准则。下列哪个陈述是正确的？选择所有适用项。\n\nA. 与使用$E_{\\mathrm{true}}(\\mathbf{x})$相比，接受决策概率和构型的平衡分布保持不变；只有报告的势能的绝对值被移动了$C$。\n\nB. 对于任何提议的移动，其接受概率都乘以$\\exp(-\\beta C)$，从而在$C \\neq 0$时改变接受率。\n\nC. 模拟采样得到的是正确的正则系综，但处于一个有效温度$T' = T + C/k_{\\mathrm{B}}$。\n\nD. 除非在每次接受检验前减去偏移量$C$，否则相对于玻尔兹曼分布的细致平衡条件将被违反。\n\nE. 在绝对尺度上，亥姆霍兹自由能相对于真实的绝对自由能移动了$+C$，但共享相同恒定偏移量的状态之间的自由能差保持不变。",
            "solution": "Metropolis蒙特卡罗模拟的核心是接受准则，它确保模拟从目标概率分布中对构型进行采样。对于温度为$T$的正则系综，构型$\\mathbf{x}$的概率由玻尔兹曼分布给出：\n$$ \\pi(\\mathbf{x}) \\propto e^{-\\beta E(\\mathbf{x})} $$\n其中$\\beta = 1/(k_{\\mathrm{B}}T)$，$k_{\\mathrm{B}}$是玻尔兹曼常数，$E(\\mathbf{x})$是构型的能量。\n\n从旧构型$\\mathbf{x}_{\\text{old}}$到新构型$\\mathbf{x}_{\\text{new}}$的尝试移动的标准Metropolis接受概率为：\n$$ p_{\\text{acc}}(\\mathbf{x}_{\\text{old}} \\to \\mathbf{x}_{\\text{new}}) = \\min\\left(1, \\frac{\\pi(\\mathbf{x}_{\\text{new}})}{\\pi(\\mathbf{x}_{\\text{old}})}\\right) $$\n概率之比为：\n$$ \\frac{\\pi(\\mathbf{x}_{\\text{new}})}{\\pi(\\mathbf{x}_{\\text{old}})} = \\frac{e^{-\\beta E(\\mathbf{x}_{\\text{new}})}}{e^{-\\beta E(\\mathbf{x}_{\\text{old}})}} = e^{-\\beta (E(\\mathbf{x}_{\\text{new}}) - E(\\mathbf{x}_{\\text{old}}))} = e^{-\\beta \\Delta E} $$\n在本问题中，模拟使用计算能量$E_{\\mathrm{calc}}(\\mathbf{x}) = E_{\\mathrm{true}}(\\mathbf{x}) + C$。让我们计算一次移动的能量差$\\Delta E_{\\mathrm{calc}}$：\n$$ \\Delta E_{\\mathrm{calc}} = E_{\\mathrm{calc}}(\\mathbf{x}_{\\text{new}}) - E_{\\mathrm{calc}}(\\mathbf{x}_{\\text{old}}) $$\n$$ \\Delta E_{\\mathrm{calc}} = (E_{\\mathrm{true}}(\\mathbf{x}_{\\text{new}}) + C) - (E_{\\mathrm{true}}(\\mathbf{x}_{\\text{old}}) + C) $$\n$$ \\Delta E_{\\mathrm{calc}} = E_{\\mathrm{true}}(\\mathbf{x}_{\\text{new}}) - E_{\\mathrm{true}}(\\mathbf{x}_{\\text{old}}) = \\Delta E_{\\mathrm{true}} $$\n能量差与恒定偏移量$C$无关。因此，接受检验中使用的玻尔兹曼权重之比也保持不变：\n$$ \\frac{\\pi_{\\text{calc}}(\\mathbf{x}_{\\text{new}})}{\\pi_{\\text{calc}}(\\mathbf{x}_{\\text{old}})} = e^{-\\beta \\Delta E_{\\mathrm{calc}}} = e^{-\\beta \\Delta E_{\\mathrm{true}}} = \\frac{\\pi_{\\text{true}}(\\mathbf{x}_{\\text{new}})}{\\pi_{\\text{true}}(\\mathbf{x}_{\\text{old}})} $$\n这个基本结果决定了大多数选项的答案。\n\n**逐项分析**\n\n**A. 与使用$E_{\\mathrm{true}}(\\mathbf{x})$相比，接受决策概率和构型的平衡分布保持不变；只有报告的势能的绝对值被移动了$C$。**\n如上所述，无论使用$E_{\\mathrm{calc}}$还是$E_{\\mathrm{true}}$，玻尔兹曼权重的比值都是相同的。因此，对于任何提议的移动，接受概率$p_{\\text{acc}} = \\min(1, e^{-\\beta \\Delta E_{\\text{calc}}})$都绝对不变。由于马尔可夫链的转移概率不变，它收敛到的稳态（平衡）分布也不变。这个平衡分布是构型的相对布居，它只取决于能量差。报告的能量绝对值基于$E_{\\mathrm{calc}}(\\mathbf{x})$，根据定义，它相对于$E_{\\mathrm{true}}(\\mathbf{x})$移动了$C$。这个陈述是对情况的精确和完整描述。\n**结论：正确**\n\n**B. 对于任何提议的移动，其接受概率都乘以$\\exp(-\\beta C)$，从而在$C \\neq 0$时改变接受率。**\n这是不正确的。如一般推导所示，能量变化$\\Delta E_{\\mathrm{calc}}$等于$\\Delta E_{\\mathrm{true}}$。常数$C$在差值中被抵消。接受概率取决于$\\Delta E$，而不是绝对能量。因此，接受概率没有乘以任何因子，保持不变。\n**结论：不正确**\n\n**C. 模拟采样得到的是正确的正则系综，但处于一个有效温度$T' = T + C/k_{\\mathrm{B}}$。**\n模拟采样得到的分布与$e^{-\\beta E_{\\mathrm{calc}}(\\mathbf{x})}$成正比。\n$$ e^{-\\beta E_{\\mathrm{calc}}(\\mathbf{x})} = e^{- (E_{\\mathrm{true}}(\\mathbf{x}) + C) / (k_{\\mathrm{B}}T)} = e^{-C/(k_{\\mathrm{B}}T)} e^{-E_{\\mathrm{true}}(\\mathbf{x}) / (k_{\\mathrm{B}}T)} $$\n由于$e^{-C/(k_{\\mathrm{B}}T)}$是一个常数因子，采样得到的分布与$e^{-E_{\\mathrm{true}}(\\mathbf{x}) / (k_{\\mathrm{B}}T)}$成正比。这是真实能量$E_{\\mathrm{true}}$在原始温度$T$下的玻尔兹曼分布。模拟不是在一个有效温度$T'$下进行采样；它是在正确的温度$T$下对正确的系综进行采样。\n**结论：不正确**\n\n**D. 除非在每次接受检验前减去偏移量$C$，否则相对于玻尔兹曼分布的细致平衡条件将被违反。**\nMetropolis-Hastings算法的构建旨在满足相对于目标分布$\\pi(\\mathbf{x})$的细致平衡条件。对于对称提议机制，该条件为$\\pi(\\mathbf{x}_{\\text{old}}) p_{\\text{acc}}(\\mathbf{x}_{\\text{old}} \\to \\mathbf{x}_{\\text{new}}) = \\pi(\\mathbf{x}_{\\text{new}}) p_{\\text{acc}}(\\mathbf{x}_{\\text{new}} \\to \\mathbf{x}_{\\text{old}})$。\n模拟使用目标分布$\\pi_{\\text{calc}}(\\mathbf{x}) \\propto e^{-\\beta E_{\\mathrm{calc}}(\\mathbf{x})}$。根据构造，对于此分布，细致平衡是满足的。如选项C的分析所示，$\\pi_{\\text{calc}}(\\mathbf{x})$与$\\pi_{\\text{true}}(\\mathbf{x}) \\propto e^{-\\beta E_{\\mathrm{true}}(\\mathbf{x})}$成正比。所以，$\\pi_{\\text{calc}}(\\mathbf{x}) = (\\text{常数}) \\times \\pi_{\\text{true}}(\\mathbf{x})$。由于这两个分布在归一化常数之外是相同的，满足其中一个的细致平衡意味着也满足另一个。相对于正确的物理玻尔兹曼分布（基于$E_{\\text{true}}$）的细致平衡得以维持。无需进行任何修改。\n**结论：不正确**\n\n**E. 在绝对尺度上，亥姆霍兹自由能相对于真实的绝对自由能移动了$+C$，但共享相同恒定偏移量的状态之间的自由能差保持不变。**\n亥姆霍兹自由能$F$通过正则配分函数$Z$定义为$F = -k_{\\mathrm{B}}T \\ln Z$。配分函数是所有构型的玻尔兹曼因子的总和：$Z = \\int e^{-\\beta E(\\mathbf{x})} d\\mathbf{x}$。\n\n“真实”配分函数是$Z_{\\text{true}} = \\int e^{-\\beta E_{\\text{true}}(\\mathbf{x})} d\\mathbf{x}$，得到自由能$F_{\\text{true}} = -k_{\\mathrm{B}}T \\ln Z_{\\text{true}}$。\n\n与计算能量$E_{\\mathrm{calc}}$相对应的配分函数是：\n$$ Z_{\\text{calc}} = \\int e^{-\\beta E_{\\mathrm{calc}}(\\mathbf{x})} d\\mathbf{x} = \\int e^{-\\beta (E_{\\mathrm{true}}(\\mathbf{x}) + C)} d\\mathbf{x} $$\n$$ Z_{\\text{calc}} = \\int e^{-\\beta E_{\\text{true}}(\\mathbf{x})} e^{-\\beta C} d\\mathbf{x} = e^{-\\beta C} \\int e^{-\\beta E_{\\text{true}}(\\mathbf{x})} d\\mathbf{x} = e^{-\\beta C} Z_{\\text{true}} $$\n因此，计算得到的自由能是：\n$$ F_{\\text{calc}} = -k_{\\mathrm{B}}T \\ln Z_{\\text{calc}} = -k_{\\mathrm{B}}T \\ln(e^{-\\beta C} Z_{\\text{true}}) $$\n$$ F_{\\text{calc}} = -k_{\\mathrm{B}}T (\\ln(e^{-\\beta C}) + \\ln Z_{\\text{true}}) = -k_{\\mathrm{B}}T (-\\beta C + \\ln Z_{\\text{true}}) $$\n$$ F_{\\text{calc}} = (-k_{\\mathrm{B}}T)(-\\frac{C}{k_{\\mathrm{B}}T}) + (-k_{\\mathrm{B}}T \\ln Z_{\\text{true}}) = C + F_{\\text{true}} $$\n这表明绝对自由能移动了$+C$。\n\n现在，考虑两个系统（或热力学状态）之间的自由能差$\\Delta F$，比如说系统1和系统2，它们都应用了相同的能量偏移$C$。\n$$ \\Delta F_{\\text{calc}} = F_{\\text{calc},2} - F_{\\text{calc},1} = (F_{\\text{true},2} + C) - (F_{\\text{true},1} + C) = F_{\\text{true},2} - F_{\\text{true},1} = \\Delta F_{\\text{true}} $$\n自由能差保持不变。该陈述的两个部分在数学上都是正确的。\n**结论：正确**",
            "answer": "$$\\boxed{AE}$$"
        },
        {
            "introduction": "现在，是时候将理论付诸实践了。本练习将指导你编写一个简单的 Metropolis 蒙特卡洛模拟程序，这是从理论计算到实际应用的飞跃。你将模拟一个粒子在吸引势场中的运动，并通过编程实现 Metropolis 接受准则来决定其每一步的命运 。通过在不同温度和步长下运行模拟，你将亲眼见证宏观行为（如接受率）是如何从这个简单的微观规则的反复应用中涌现出来的。",
            "id": "2465276",
            "problem": "考虑一个简化的无量纲单位下的单粒子径向模型，其势能由 $U(r)=-\\dfrac{1}{r}$ 给出，其中 $r0$。设绝对温度为 $T0$，玻尔兹曼常数设为 $k_{\\mathrm{B}}=1$，因此 $\\beta=\\dfrac{1}{T}$。根据 Metropolis 接受准则，从当前半径 $r$ 移动到新半径 $r^{\\prime}$ 的提议被接受的概率为\n$$\nA\\left(r\\to r^{\\prime}\\right)=\\min\\left(1,\\exp\\left[-\\beta\\left(U(r^{\\prime})-U(r)\\right)\\right]\\right).\n$$\n您将通过仅尝试向外的提议来生成一个半径序列。在每次尝试中，从 $[0,\\Delta]$ 上的均匀分布中抽取一个独立的位移 $s$，并将提议设为 $r^{\\prime}=r+s$。如果提议被接受，则更新 $r\\leftarrow r^{\\prime}$；否则保持 $r$ 不变。从初始半径 $r_{0}0$ 开始，执行恰好 $N$ 次提议尝试，并报告接受率，该接受率定义为接受的提议总数除以 $N$。所有量都是无量纲的，不需要物理单位。\n\n请为以下参数元组 $(T,\\Delta,r_{0},N,\\text{seed})$ 的测试套件实现此协议，其中“seed”指定了伪随机数生成器的整数种子以确保可复现性。对于每个元组，以浮点数形式返回接受率。\n\n- 测试 $1$：$(T,\\Delta,r_{0},N,\\text{seed})=\\left(0.5,\\,0.2,\\,0.5,\\,100000,\\,12345\\right)$。\n- 测试 $2$：$(T,\\Delta,r_{0},N,\\text{seed})=\\left(2.0,\\,0.5,\\,1.0,\\,100000,\\,54321\\right)$。\n- 测试 $3$：$(T,\\Delta,r_{0},N,\\text{seed})=\\left(0.05,\\,0.2,\\,1.0,\\,100000,\\,202311\\right)$。\n- 测试 $4$：$(T,\\Delta,r_{0},N,\\text{seed})=\\left(0.5,\\,0.05,\\,10.0,\\,100000,\\,8080\\right)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_{1},x_{2},x_{3},x_{4}]$），其中每个 $x_{i}$ 是测试 $i$ 的接受率，四舍五入到恰好六位小数。",
            "solution": "任务是计算特定 Metropolis 蒙特卡洛模拟协议的接受率。这是对所描述算法的直接应用。该模拟为给定势场中的粒子生成一系列状态（半径），形成一个马尔可夫链。\n\n该算法的核心是 Metropolis 接受准则。从半径为 $r$ 的构型移动到半径为 $r^{\\prime}$ 的提议构型，会引起势能变化 $\\Delta U = U(r^{\\prime}) - U(r)$。该移动以概率 $A(r \\to r^{\\prime})$ 被接受。\n\n每个测试用例的算法步骤如下：\n$1$. 初始化系统。设置当前半径 $r_{current} \\leftarrow r_0$，接受的移动次数 $N_{accept} \\leftarrow 0$，以及逆温度 $\\beta \\leftarrow 1/T$。用给定的整数种子为伪随机数生成器播种。\n\n$2$. 执行一个 $N$ 次迭代的循环，代表提议尝试的总次数。在从 $1$ 到 $N$ 的每次迭代 $i$ 中：\n    a. **提议新状态：** 从均匀分布 $U(0, \\Delta)$ 中生成一个随机位移 $s$。计算提议的新半径 $r_{proposal} = r_{current} + s$。由于 $s \\ge 0$，这始终是一个向外的移动，因此 $r_{proposal} \\ge r_{current}$。\n    \n    b. **计算能量变化：** 势能的变化为 $\\Delta U = U(r_{proposal}) - U(r_{current})$。代入给定的势能函数 $U(r) = -1/r$，我们得到：\n    $$\n    \\Delta U = \\left(-\\frac{1}{r_{proposal}}\\right) - \\left(-\\frac{1}{r_{current}}\\right) = \\frac{1}{r_{current}} - \\frac{1}{r_{proposal}}\n    $$\n    由于 $r_{proposal} \\ge r_{current}  0$，因此有 $1/r_{current} \\ge 1/r_{proposal}$，这确保了 $\\Delta U \\ge 0$。\n\n    c. **计算接受概率：** 概率由 Metropolis 函数给出：\n    $$\n    A = \\min\\left(1, \\exp(-\\beta \\Delta U)\\right)\n    $$\n    因为 $\\beta = 1/T  0$，并且我们已经确定对于这种特定的提议方案 $\\Delta U \\ge 0$，所以指数的参数 $-\\beta \\Delta U$ 总是非正的。因此，$\\exp(-\\beta \\Delta U)$ 的值总是在 $(0, 1]$ 范围内，接受概率可以简化为 $A = \\exp(-\\beta \\Delta U)$。然而，为了通用性和严格遵守问题中的公式，在实现中将保留 `min` 函数。\n\n    d. **接受或拒绝移动：** 从均匀分布 $U(0, 1)$ 中生成一个随机数 $u$。如果 $u  A$，则接受移动。在这种情况下，通过设置 $r_{current} \\leftarrow r_{proposal}$ 来更新系统状态，并增加接受计数器 $N_{accept} \\leftarrow N_{accept} + 1$。如果 $u \\ge A$，则拒绝移动，系统状态 $r_{current}$ 保持不变。\n\n$3$. 在 $N$ 次迭代完成后，最终的接受率计算为接受的移动总数与尝试总数的比率：\n$$\n\\text{Acceptance Rate} = \\frac{N_{accept}}{N}\n$$\n\n对于给定的参数集 $(T, \\Delta, r_0, N, \\text{seed})$，此过程是确定性的。它将为四个指定的测试用例中的每一个实现，以产生所需的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the Metropolis acceptance rate for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (T, Delta, r_0, N, seed).\n    test_cases = [\n        (0.5, 0.2, 0.5, 100000, 12345),\n        (2.0, 0.5, 1.0, 100000, 54321),\n        (0.05, 0.2, 1.0, 100000, 202311),\n        (0.5, 0.05, 10.0, 100000, 8080),\n    ]\n\n    results = []\n    \n    # The potential energy function U(r) = -1/r\n    def U(r):\n        return -1.0 / r\n\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        T, Delta, r0, N, seed = case\n        \n        # Initialize simulation variables\n        beta = 1.0 / T\n        r_current = float(r0)\n        accepted_count = 0\n        \n        # Initialize the random number generator with the specified seed for reproducibility\n        rng = np.random.default_rng(seed)\n        \n        # Perform N proposal attempts\n        for _ in range(N):\n            # 1. Propose a new state (outward-only move)\n            s = rng.uniform(0.0, Delta)\n            r_proposal = r_current + s\n            \n            # 2. Calculate the change in potential energy\n            delta_U = U(r_proposal) - U(r_current)\n            \n            # 3. Calculate the acceptance probability according to the Metropolis criterion.\n            # Since delta_U is always >= 0 for this proposal scheme, exp(-beta * delta_U) is always = 1.\n            # The min(1, ...) is technically redundant but included for strict adherence to the formula.\n            acceptance_prob = min(1.0, np.exp(-beta * delta_U))\n            \n            # 4. Accept or reject the move\n            if rng.random()  acceptance_prob:\n                # Accept the move\n                r_current = r_proposal\n                accepted_count += 1\n            # Else, reject the move (r_current remains unchanged)\n            \n        # Calculate the final acceptance rate for this test case\n        acceptance_rate = accepted_count / N\n        results.append(acceptance_rate)\n\n    # Format the results as a comma-separated list of numbers rounded to 6 decimal places,\n    # enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}