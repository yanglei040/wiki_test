{
    "hands_on_practices": [
        {
            "introduction": "计算材料科学的许多预测都建立在精确的量子力学能量计算之上。然而，在实际计算中，有限基组等近似会引入被称为“基组重叠误差”（Basis Set Superposition Error, BSSE）的人为误差，尤其是在研究弱相互作用体系时。本练习将指导你亲手实践如何量化和校正这种误差，这是确保范德华晶体或分子复合物相互作用能计算准确性的关键一步 。",
            "id": "2452947",
            "problem": "您的任务是使用对位法 (Counterpoise, CP) 计算面心立方氙晶体中每个原子的晶格能的基组重叠误差 (BSSE) 校正。BSSE 是量子化学中因使用不完备的单电子基组而产生的后果，当分子片段从彼此的基函数中受益时，会导致对结合能的高估。对于一个被视为周期性或团簇体系的晶体，每个原子的 BSSE 可以通过比较一个在其自身基组中计算的孤立原子的能量与同一个原子在模拟局部晶体环境的鬼基函数存在下计算的能量来定义。将每个原子的晶格能定义为 $U_{\\mathrm{latt}} = E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} - E_{\\mathrm{atom}}^{(\\mathrm{mono})}$，其中 $E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})}$ 是计算出的晶体中每个原子的总能量，而 $E_{\\mathrm{atom}}^{(\\mathrm{mono})}$ 是在相同单体基组中孤立原子的能量。将每个原子的 BSSE 定义为 $\\Delta_{\\mathrm{BSSE}} = E_{\\mathrm{atom}}^{(\\mathrm{mono})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})}$，其中 $E_{\\mathrm{atom}}^{(\\mathrm{ghost})}$ 是在邻近原子位置放置鬼基函数的情况下计算的孤立原子的能量。经对位法校正的每个原子的晶格能为 $U_{\\mathrm{CP}} = U_{\\mathrm{latt}} + \\Delta_{\\mathrm{BSSE}} = E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})}$。所有能量都按每个原子处理。\n\n对于下面的每个测试用例，计算每个原子的 BSSE $\\Delta_{\\mathrm{BSSE}}$ 和经对位法校正的每个原子的晶格能 $U_{\\mathrm{CP}}$。所有答案以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位，并四舍五入到三位小数。\n\n测试套件（所有值均为每个原子的值，单位为 $\\mathrm{kJ\\,mol^{-1}}$）：\n- 案例 A (粗糙基组)：$E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} = -15.0$, $E_{\\mathrm{atom}}^{(\\mathrm{mono})} = 0.0$, $E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = -2.5$。\n- 案例 B (改进基组)：$E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} = -13.2$, $E_{\\mathrm{atom}}^{(\\mathrm{mono})} = 0.0$, $E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = -0.6$。\n- 案例 C (近完备基组)：$E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} = -12.8$, $E_{\\mathrm{atom}}^{(\\mathrm{mono})} = 0.0$, $E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = 0.0$。\n- 案例 D (数值边界情况)：$E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} = -12.0$, $E_{\\mathrm{atom}}^{(\\mathrm{mono})} = 0.0$, $E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = 0.05$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的数对列表形式的结果，每个数对的格式为 $[\\Delta_{\\mathrm{BSSE}},U_{\\mathrm{CP}}]$，并且整个列表用方括号括起来。例如，输出格式必须类似于 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$，其中每个 $x_i$ 和 $y_i$ 均以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位并四舍五入到三位小数，输出中不出现单位或其他附加文本。",
            "solution": "所提出的问题是基组重叠误差 (BSSE) 的对位法 (CP) 校正方法的一个直接应用，这是计算量子化学中一个定义明确的标准程序。问题的前提是合理的，并且所有必需的数据都已提供。我们将着手进行分析。\n\n目标是在不同的计算条件（基组）下，计算氙晶体中每个原子的 BSSE（表示为 $\\Delta_{\\mathrm{BSSE}}$）和经对位法校正的每个原子的晶格能 $U_{\\mathrm{CP}}$。\n\n提供的基本定义如下：\n未校正的每个原子的晶格能 $U_{\\mathrm{latt}}$ 定义为为周期性晶体计算的每个原子的总能量 $E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})}$ 与在其自身基组中计算的孤立原子的能量（单体计算） $E_{\\mathrm{atom}}^{(\\mathrm{mono})}$ 之间的差值。\n$$U_{\\mathrm{latt}} = E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} - E_{\\mathrm{atom}}^{(\\mathrm{mono})}$$\n按照惯例，孤立单体的能量通常被设定为参考能量，因此 $E_{\\mathrm{atom}}^{(\\mathrm{mono})} = 0$。\n\nBSSE 源于使用不完备（有限）的单电子基组。在晶体或二聚体计算中，一个原子可以从邻近原子那里“借用”基函数来降低其后验能量，这是一种人为现象，会产生非物理的人为稳定性。这种效应导致对结合能的高估。此误差的大小就是 BSSE。\n\n每个原子的 BSSE，$\\Delta_{\\mathrm{BSSE}}$，通过计算单个原子在“鬼”基函数存在下的能量来量化——即，基函数位于邻近原子的位置上，但没有相应的原子核或电子。该能量表示为 $E_{\\mathrm{atom}}^{(\\mathrm{ghost})}$。BSSE 是能量差：\n$$\\Delta_{\\mathrm{BSSE}} = E_{\\mathrm{atom}}^{(\\mathrm{mono})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})}$$\n由于鬼原子计算提供了更大的变分灵活性，通常有 $E_{\\mathrm{atom}}^{(\\mathrm{ghost})} \\le E_{\\mathrm{atom}}^{(\\mathrm{mono})}$，这使得 $\\Delta_{\\mathrm{BSSE}} \\ge 0$。正值表示人为稳定化的程度。$\\Delta_{\\mathrm{BSSE}} \\approx 0$ 的值表示基组接近完备，误差可以忽略不计。负的 $\\Delta_{\\mathrm{BSSE}}$ 是非物理的，但可能由数值噪声或计算方案中的不一致性引起。\n\n经对位法校正的晶格能 $U_{\\mathrm{CP}}$ 是通过将 BSSE 加到未校正的晶格能上得到的：\n$$U_{\\mathrm{CP}} = U_{\\mathrm{latt}} + \\Delta_{\\mathrm{BSSE}}$$\n代入 $U_{\\mathrm{latt}}$ 和 $\\Delta_{\\mathrm{BSSE}}$ 的定义可以得到一个更直接的公式：\n$$U_{\\mathrm{CP}} = (E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} - E_{\\mathrm{atom}}^{(\\mathrm{mono})}) + (E_{\\mathrm{atom}}^{(\\mathrm{mono})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})}) = E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})}$$\n这个校正后的能量通过抵消晶体计算和鬼原子计算中都存在的人为稳定性，代表了更具物理意义的晶格能。\n\n我们现在将这些公式应用于所提供的四个案例。所有能量的单位都是 $\\mathrm{kJ\\,mol^{-1}}$。\n\n**案例 A (粗糙基组)：**\n给定：$E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} = -15.0$, $E_{\\mathrm{atom}}^{(\\mathrm{mono})} = 0.0$, $E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = -2.5$。\n1. 计算 $\\Delta_{\\mathrm{BSSE}}$：\n$$\\Delta_{\\mathrm{BSSE}} = E_{\\mathrm{atom}}^{(\\mathrm{mono})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = 0.0 - (-2.5) = 2.5 \\, \\mathrm{kJ\\,mol^{-1}}$$\n2. 计算 $U_{\\mathrm{CP}}$：\n$$U_{\\mathrm{CP}} = E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = -15.0 - (-2.5) = -12.5 \\, \\mathrm{kJ\\,mol^{-1}}$$\n结果对为 $[2.500, -12.500]$。\n\n**案例 B (改进基组)：**\n给定：$E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} = -13.2$, $E_{\\mathrm{atom}}^{(\\mathrm{mono})} = 0.0$, $E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = -0.6$。\n1. 计算 $\\Delta_{\\mathrm{BSSE}}$：\n$$\\Delta_{\\mathrm{BSSE}} = E_{\\mathrm{atom}}^{(\\mathrm{mono})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = 0.0 - (-0.6) = 0.6 \\, \\mathrm{kJ\\,mol^{-1}}$$\n2. 计算 $U_{\\mathrm{CP}}$：\n$$U_{\\mathrm{CP}} = E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = -13.2 - (-0.6) = -12.6 \\, \\mathrm{kJ\\,mol^{-1}}$$\n结果对为 $[0.600, -12.600]$。\n\n**案例 C (近完备基组)：**\n给定：$E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} = -12.8$, $E_{\\mathrm{atom}}^{(\\mathrm{mono})} = 0.0$, $E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = 0.0$。\n1. 计算 $\\Delta_{\\mathrm{BSSE}}$：\n$$\\Delta_{\\mathrm{BSSE}} = E_{\\mathrm{atom}}^{(\\mathrm{mono})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = 0.0 - 0.0 = 0.0 \\, \\mathrm{kJ\\,mol^{-1}}$$\n2. 计算 $U_{\\mathrm{CP}}$：\n$$U_{\\mathrm{CP}} = E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = -12.8 - 0.0 = -12.8 \\, \\mathrm{kJ\\,mol^{-1}}$$\n结果对为 $[0.000, -12.800]$。\n\n**案例 D (数值边界情况)：**\n给定：$E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} = -12.0$, $E_{\\mathrm{atom}}^{(\\mathrm{mono})} = 0.0$, $E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = 0.05$。\n1. 计算 $\\Delta_{\\mathrm{BSSE}}$：\n$$\\Delta_{\\mathrm{BSSE}} = E_{\\mathrm{atom}}^{(\\mathrm{mono})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = 0.0 - 0.05 = -0.05 \\, \\mathrm{kJ\\,mol^{-1}}$$\n2. 计算 $U_{\\mathrm{CP}}$：\n$$U_{\\mathrm{CP}} = E_{\\mathrm{cryst}}^{(\\mathrm{per\\,atom})} - E_{\\mathrm{atom}}^{(\\mathrm{ghost})} = -12.0 - 0.05 = -12.05 \\, \\mathrm{kJ\\,mol^{-1}}$$\n结果对为 $[-0.050, -12.050]$。\n\n计算完成。结果显示了预期的趋势：随着基组质量从粗糙（案例 A）提高到近完备（案例 C），BSSE 的量级显著减小，校正后的晶格能也随之收敛。案例 D 代表了一种情景，其中数值噪声或计算设置中的轻微不一致导致鬼原子计算出现一个小的、非物理的正能量，从而产生负的 BSSE。这是在实际计算中可能遇到的现象。以下程序将把此分析编写成代码。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Basis Set Superposition Error (BSSE) per atom and the\n    Counterpoise-corrected lattice energy per atom for given test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains (E_cryst_per_atom, E_atom_mono, E_atom_ghost) in kJ/mol.\n    test_cases = [\n        # Case A (coarse basis)\n        (-15.0, 0.0, -2.5),\n        # Case B (improved basis)\n        (-13.2, 0.0, -0.6),\n        # Case C (near-complete basis)\n        (-12.8, 0.0, 0.0),\n        # Case D (numerical edge)\n        (-12.0, 0.0, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        e_cryst_per_atom, e_atom_mono, e_atom_ghost = case\n\n        # Calculate BSSE per atom (delta_BSSE).\n        # delta_BSSE = E_atom^(mono) - E_atom^(ghost)\n        delta_bsse = e_atom_mono - e_atom_ghost\n\n        # Calculate Counterpoise-corrected lattice energy per atom (U_CP).\n        # U_CP = E_cryst^(per atom) - E_atom^(ghost)\n        u_cp = e_cryst_per_atom - e_atom_ghost\n\n        # Round results to three decimal places.\n        # Note: The problem requires a specific string format for the final output, not a list of floats.\n        # Storing the pair of floats for later formatting.\n        results.append((delta_bsse, u_cp))\n\n    # Format the final output string as required: [[x1,y1],[x2,y2],...]\n    # Each number must be formatted to three decimal places.\n    output_pairs = []\n    for delta, u in results:\n        # Format each pair as a string \"[delta_val,u_val]\"\n        pair_str = f\"[{delta:.3f},{u:.3f}]\"\n        output_pairs.append(pair_str)\n\n    # Join the pairs with commas and enclose in brackets.\n    final_output_str = f\"[{','.join(output_pairs)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "从确保量子计算的准确性出发，我们现在转向一个更具应用性的挑战：预测晶体多型现象。一种材料的不同晶型（多型体）可能具有截然不同的物理性质，因此预测最稳定的晶型至关重要。本练习利用经典的力场模型——一种计算上更高效的方法——来探讨溶剂环境如何影响甘氨酸多型体的稳定性排序，这是一个在药物设计等领域具有重要实际意义的典型问题 。",
            "id": "2452959",
            "problem": "您将使用一个简单的、对加性的分子间势来模拟显式水分子壳层如何改变相对于气相计算所预测的甘氨酸稳定多晶型。目标是确定在一小组测试条件下，当包含一个显式的、固定的水分子壳层时，哪种甘氨酸多晶型被预测为最稳定。您的程序必须计算每种多晶型的每个甘氨酸分子的总能量，该总能量是给定的气相晶格能与显式溶剂相互作用能之和，然后选择总能量最低的多晶型。\n\n假设和物理模型：\n- 从对相互作用的叠加原理和两种经过充分检验的对势出发：\n  1. 用于部分电荷的库仑定律：在相对介电常数为 $\\varepsilon_r$ 的介质中，电荷为 $q_i$ 和 $q_j$ 的两个位点之间相距 $r$ 时的对能量为\n  $$E_{\\mathrm{C}}(r) = k_{\\mathrm{e}} \\frac{q_i q_j}{\\varepsilon_r r},$$\n  其中 $k_{\\mathrm{e}} = 138.935456$，单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,e^{-2}$，电荷单位为元电荷 $e$，距离单位为 $\\mathrm{nm}$。\n  2. 用于甘氨酸位点和水氧位点之间范德华相互作用的 Lennard-Jones (LJ) $12$-$6$ 势：\n  $$E_{\\mathrm{LJ}}(r) = 4 \\varepsilon_{ij} \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right],$$\n  采用 Lorentz–Berthelot 混合规则 $\\sigma_{ij} = \\frac{\\sigma_i + \\sigma_j}{2}$ 和 $\\varepsilon_{ij} = \\sqrt{\\varepsilon_i \\varepsilon_j}$。仅包含甘氨酸与水氧之间的 LJ 相互作用；氢原子不携带 Lennard-Jones 参数。\n\n- 每个甘氨酸分子由三个相互作用位点表示：铵基 ($\\mathrm{NH_3^+}$)、亚甲基 ($\\mathrm{CH_2}$) 和羧酸根 ($\\mathrm{COO^-}$)。甘氨酸位点的部分电荷和 Lennard-Jones 参数如下：\n  - 电荷：$q_{\\mathrm{NH3}} = +0.4$，$q_{\\mathrm{CH2}} = 0.0$，$q_{\\mathrm{COO}} = -0.4$（单位为 $e$）。\n  - Lennard-Jones 参数（按位点）：$\\sigma_{\\mathrm{NH3}} = 0.325$，$\\sigma_{\\mathrm{CH2}} = 0.340$，$\\sigma_{\\mathrm{COO}} = 0.300$（单位均为 $\\mathrm{nm}$），以及 $\\varepsilon_{\\mathrm{NH3}} = 0.1$，$\\varepsilon_{\\mathrm{CH2}} = 0.1$，$\\varepsilon_{\\mathrm{COO}} = 0.1$（单位均为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$）。\n\n- 水分子被建模为刚性的三位点粒子，氧原子和两个氢原子上带有部分电荷。使用以下水分子位点参数：\n  - 电荷：$q_{\\mathrm{O}} = -0.834$，$q_{\\mathrm{H}} = +0.417$（单位为 $e$）。\n  - 仅用于氧原子的 Lennard-Jones 参数：$\\sigma_{\\mathrm{O}} = 0.315075$ 和 $\\varepsilon_{\\mathrm{O}} = 0.636386$（单位为 $\\mathrm{nm}$ 和 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$）。氢原子不携带 Lennard-Jones 参数。\n  - 对所有甘氨酸-水位点对（甘氨酸位点与水氧和氢原子）均包含库仑相互作用。仅对甘氨酸位点与水氧之间包含 Lennard-Jones 相互作用。\n\n- 多晶型 $P$ 中每个甘氨酸分子的总能量为\n  $$E_{\\mathrm{tot}}^{(P)} = E_{\\mathrm{latt}}^{(P)} + \\sum_{w=1}^{N_{\\mathrm{w}}}\\left[\\sum_{i \\in \\{\\mathrm{NH3, CH2, COO}\\}} \\left(E_{\\mathrm{C}}(r_{i,\\mathrm{O}}^{(P,w)}) + E_{\\mathrm{LJ}}(r_{i,\\mathrm{O}}^{(P,w)}) + E_{\\mathrm{C}}(r_{i,\\mathrm{H1}}^{(P,w)}) + E_{\\mathrm{C}}(r_{i,\\mathrm{H2}}^{(P,w)})\\right)\\right],$$\n  其中 $E_{\\mathrm{latt}}^{(P)}$ 是为多晶型 $P$ 提供的每个分子的气相晶格能，$N_{\\mathrm{w}}$ 是水分子的数量，$r_{i,s}^{(P,w)}$ 是为多晶型 $P$ 中的水分子 $w$ 提供的从甘氨酸位点 $i$ 到水位点 $s \\in \\{\\mathrm{O}, \\mathrm{H1}, \\mathrm{H2}\\}$ 的固定距离（单位为 $\\mathrm{nm}$）。角度不会出现，也不需要。所有能量均以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 表示。\n\n提供的数据：\n- 多晶型标签及其到索引的映射：$\\mathrm{alpha} \\rightarrow 0$，$\\mathrm{beta} \\rightarrow 1$，$\\mathrm{gamma} \\rightarrow 2$。\n\n- 每个甘氨酸分子的气相晶格能：\n  - $E_{\\mathrm{latt}}^{(\\mathrm{alpha})} = -95.0$,\n  - $E_{\\mathrm{latt}}^{(\\mathrm{beta})} = -92.0$,\n  - $E_{\\mathrm{latt}}^{(\\mathrm{gamma})} = -97.0$（单位均为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$）。\n\n- 每种多晶型中从甘氨酸位点到水位点的距离。距离是针对单个水分子给出的，并且对于壳层中的每个水分子都相同。距离按 $[\\mathrm{NH3}, \\mathrm{CH2}, \\mathrm{COO}]$ 的顺序排列。\n  - 对于 $\\mathrm{alpha}$：\n    - $r_{\\mathrm{O}}^{(\\mathrm{alpha})} = [0.30, 0.45, 0.50]$,\n    - $r_{\\mathrm{H1}}^{(\\mathrm{alpha})} = [0.60, 0.60, 0.31]$,\n    - $r_{\\mathrm{H2}}^{(\\mathrm{alpha})} = [0.60, 0.60, 0.33]$.\n  - 对于 $\\mathrm{beta}$：\n    - $r_{\\mathrm{O}}^{(\\mathrm{beta})} = [0.34, 0.45, 0.50]$,\n    - $r_{\\mathrm{H1}}^{(\\mathrm{beta})} = [0.60, 0.60, 0.36]$,\n    - $r_{\\mathrm{H2}}^{(\\mathrm{beta})} = [0.60, 0.60, 0.38]$.\n  - 对于 $\\mathrm{gamma}$：\n    - $r_{\\mathrm{O}}^{(\\mathrm{gamma})} = [0.33, 0.45, 0.50]$,\n    - $r_{\\mathrm{H1}}^{(\\mathrm{gamma})} = [0.60, 0.60, 0.35]$,\n    - $r_{\\mathrm{H2}}^{(\\mathrm{gamma})} = [0.60, 0.60, 0.37]$.\n\n- 相对介电常数 $\\varepsilon_r$ 是一个用于统一缩放库仑相互作用以测试屏蔽效应的参数。Lennard-Jones 相互作用不受 $\\varepsilon_r$ 缩放。\n\n任务：\n- 针对下方的每个测试用例，实现一个程序，使用上述定义计算 $P \\in \\{\\mathrm{alpha}, \\mathrm{beta}, \\mathrm{gamma}\\}$ 的 $E_{\\mathrm{tot}}^{(P)}$，然后返回能量最低的多晶型的索引。\n\n测试套件：\n- 用例 1：$N_{\\mathrm{w}} = 0$，$\\varepsilon_r = 1.0$。\n- 用例 2：$N_{\\mathrm{w}} = 2$，$\\varepsilon_r = 20.0$。\n- 用例 3：$N_{\\mathrm{w}} = 4$，$\\varepsilon_r = 20.0$。\n- 用例 4：$N_{\\mathrm{w}} = 4$，$\\varepsilon_r = 80.0$。\n\n答案规范：\n- 最终输出必须为单行，按顺序包含用例 1 到 4 的预测稳定多晶型索引，使用映射 $\\mathrm{alpha} \\rightarrow 0$、$\\mathrm{beta} \\rightarrow 1$、$\\mathrm{gamma} \\rightarrow 2$ 编码为整数。\n- 最终输出格式：一个单行，包含一个用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 都是一个整数。\n- 不得打印任何其他文本。\n\n所有距离必须以 $\\mathrm{nm}$ 为单位处理，所有能量以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位，不使用角度。程序必须是自包含的，并且不得读取任何输入。",
            "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件。\n- **物理模型**：由库仑项和 Lennard-Jones (LJ) 项组成的对加性势能。\n- **库仑定律**：$E_{\\mathrm{C}}(r) = k_{\\mathrm{e}} \\frac{q_i q_j}{\\varepsilon_r r}$，其中 $k_{\\mathrm{e}} = 138.935456 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,e^{-2}$。\n- **Lennard-Jones 势**：$E_{\\mathrm{LJ}}(r) = 4 \\varepsilon_{ij} \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right]$。\n- **混合规则**：Lorentz-Berthelot，$\\sigma_{ij} = \\frac{\\sigma_i + \\sigma_j}{2}$ 和 $\\varepsilon_{ij} = \\sqrt{\\varepsilon_i \\varepsilon_j}$。\n- **甘氨酸模型**：三个位点：铵基 ($\\mathrm{NH_3^+}$)、亚甲基 ($\\mathrm{CH_2}$)、羧酸根 ($\\mathrm{COO^-}$)。\n- **甘氨酸参数**：\n  - 电荷：$q_{\\mathrm{NH3}} = +0.4 \\, e$，$q_{\\mathrm{CH2}} = 0.0 \\, e$，$q_{\\mathrm{COO}} = -0.4 \\, e$。\n  - LJ $\\sigma$：$\\sigma_{\\mathrm{NH3}} = 0.325 \\, \\mathrm{nm}$，$\\sigma_{\\mathrm{CH2}} = 0.340 \\, \\mathrm{nm}$，$\\sigma_{\\mathrm{COO}} = 0.300 \\, \\mathrm{nm}$。\n  - LJ $\\varepsilon$：$\\varepsilon_{\\mathrm{NH3}} = 0.1 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，$\\varepsilon_{\\mathrm{CH2}} = 0.1 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，$\\varepsilon_{\\mathrm{COO}} = 0.1 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- **水模型**：刚性三位点分子 (O, H1, H2)。\n- **水参数**：\n  - 电荷：$q_{\\mathrm{O}} = -0.834 \\, e$，$q_{\\mathrm{H}} = +0.417 \\, e$。\n  - LJ（仅限氧原子）：$\\sigma_{\\mathrm{O}} = 0.315075 \\, \\mathrm{nm}$，$\\varepsilon_{\\mathrm{O}} = 0.636386 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- **总能量公式**：$E_{\\mathrm{tot}}^{(P)} = E_{\\mathrm{latt}}^{(P)} + \\sum_{w=1}^{N_{\\mathrm{w}}}\\left[\\sum_{i \\in \\{\\mathrm{NH3, CH2, COO}\\}} \\left(E_{\\mathrm{C}}(r_{i,\\mathrm{O}}^{(P,w)}) + E_{\\mathrm{LJ}}(r_{i,\\mathrm{O}}^{(P,w)}) + E_{\\mathrm{C}}(r_{i,\\mathrm{H1}}^{(P,w)}) + E_{\\mathrm{C}}(r_{i,\\mathrm{H2}}^{(P,w)})\\right)\\right]$。\n- **多晶型索引**：$\\mathrm{alpha} \\rightarrow 0$，$\\mathrm{beta} \\rightarrow 1$，$\\mathrm{gamma} \\rightarrow 2$。\n- **晶格能**：\n  - $E_{\\mathrm{latt}}^{(\\mathrm{alpha})} = -95.0 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - $E_{\\mathrm{latt}}^{(\\mathrm{beta})} = -92.0 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - $E_{\\mathrm{latt}}^{(\\mathrm{gamma})} = -97.0 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- **距离（$r$ 单位为 nm）**：\n  - Alpha：$r_{\\mathrm{O}} = [0.30, 0.45, 0.50]$，$r_{\\mathrm{H1}} = [0.60, 0.60, 0.31]$，$r_{\\mathrm{H2}} = [0.60, 0.60, 0.33]$。\n  - Beta：$r_{\\mathrm{O}} = [0.34, 0.45, 0.50]$，$r_{\\mathrm{H1}} = [0.60, 0.60, 0.36]$，$r_{\\mathrm{H2}} = [0.60, 0.60, 0.38]$。\n  - Gamma：$r_{\\mathrm{O}} = [0.33, 0.45, 0.50]$，$r_{\\mathrm{H1}} = [0.60, 0.60, 0.35]$，$r_{\\mathrm{H2}} = [0.60, 0.60, 0.37]$。\n  （距离按甘氨酸位点 $[\\mathrm{NH3}, \\mathrm{CH2}, \\mathrm{COO}]$ 排序）。\n- **测试套件**：\n  - 用例 1：$N_{\\mathrm{w}} = 0$，$\\varepsilon_r = 1.0$。\n  - 用例 2：$N_{\\mathrm{w}} = 2$，$\\varepsilon_r = 20.0$。\n  - 用例 3：$N_{\\mathrm{w}} = 4$，$\\varepsilon_r = 20.0$。\n  - 用例 4：$N_{\\mathrm{w}} = 4$，$\\varepsilon_r = 80.0$。\n- **输出规范**：每个用例中最稳定多晶型的整数索引的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$。\n\n步骤 2：使用提取的已知条件进行验证。\n根据验证标准评估问题。\n- **科学依据**：该问题利用了基本且被广泛接受的势能函数（库仑、Lennard-Jones），这些是经典分子模拟和力场的基础。多晶型稳定性排序和显式溶剂壳层效应的概念是计算化学和材料科学中的标准课题。该模型是一个简化模型，但没有违反任何科学原理。\n- **良态的**：该问题要求在四个测试用例中，分别为一组三个能量值找到最小值。计算所需的所有参数和函数都已明确定义。计算是确定性的，确保存在唯一、稳定且有意义的解。结构清晰，能够导出一个具体、可计算的结果。\n- **客观性**：该问题使用精确的数学公式、数值数据和明确的指令进行规定。没有主观或基于观点的陈述。\n\n该问题是自包含的、一致的，并通过了所有有效性检查。不存在科学上不健全、不完整或模棱两可等缺陷。\n\n步骤 3：结论和行动。\n该问题有效。将提供一个合理的解决方案。\n\n目标是通过找出哪种多晶型 $P \\in \\{\\mathrm{alpha}, \\mathrm{beta}, \\mathrm{gamma}\\}$ 具有最低的单分子总能量 $E_{\\mathrm{tot}}^{(P)}$，来确定在特定条件下最稳定的甘氨酸多晶型。该总能量定义为气相晶格能 $E_{\\mathrm{latt}}^{(P)}$ 和显式溶剂相互作用能之和。\n\n多晶型 $P$ 的总能量由下式给出：\n$$E_{\\mathrm{tot}}^{(P)} = E_{\\mathrm{latt}}^{(P)} + E_{\\mathrm{solv}}^{(P)}$$\n其中 $E_{\\mathrm{solv}}^{(P)}$ 是一个甘氨酸分子与周围显式溶剂壳层之间相互作用的总能量。问题陈述说明溶剂壳层由 $N_{\\mathrm{w}}$ 个水分子组成，且每个水分子的相互作用几何构型都相同。因此，总溶剂化能就是 $N_{\\mathrm{w}}$ 乘以与单个水分子的相互作用能 $E_{\\mathrm{int},1w}^{(P)}$。\n$$E_{\\mathrm{solv}}^{(P)} = N_{\\mathrm{w}} \\times E_{\\mathrm{int},1w}^{(P)}$$\n如果 $N_{\\mathrm{w}}=0$，则溶剂化能为 $0$。\n\n与单个水分子的相互作用能 $E_{\\mathrm{int},1w}^{(P)}$ 是甘氨酸分子的三个位点（$i \\in \\{\\mathrm{NH_3^+, CH_2, COO^-}\\}$）与水分子的三个位点（$s \\in \\{\\mathrm{O, H1, H2}\\}$）之间所有对相互作用的总和。任何一对位点之间的相互作用都是库仑项和 Lennard-Jones 项的和。\n$$E_{\\mathrm{int},1w}^{(P)} = \\sum_{i \\in \\text{gly sites}} \\left[ \\left( E_{\\mathrm{C}}(r_{i,\\mathrm{O}}^{(P)}) + E_{\\mathrm{LJ}}(r_{i,\\mathrm{O}}^{(P)}) \\right) + E_{\\mathrm{C}}(r_{i,\\mathrm{H1}}^{(P)}) + E_{\\mathrm{C}}(r_{i,\\mathrm{H2}}^{(P)}) \\right]$$\n注意，Lennard-Jones 相互作用仅在甘氨酸位点和水氧位点之间考虑。\n\n两种势能函数是：\n1.  **库仑能量**：这描述了在相对介电常数为 $\\varepsilon_r$ 的介质中，两个相距为 $r$ 的点电荷 $q_i$ 和 $q_j$ 之间的静电相互作用。\n    $$E_{\\mathrm{C}}(r) = k_{\\mathrm{e}} \\frac{q_i q_j}{\\varepsilon_r r}$$\n    常数 $k_{\\mathrm{e}}$ 给定为 $138.935456 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,e^{-2}$。$\\varepsilon_r$ 作为静电相互作用的屏蔽因子。\n\n2.  **Lennard-Jones 能量**：这模拟了范德华力，包括一个短程排斥项 $(r^{-12})$ 和一个长程吸引项 $(r^{-6})$。\n    $$E_{\\mathrm{LJ}}(r) = 4 \\varepsilon_{ij} \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right]$$\n    混合相互作用（甘氨酸位点 $i$，水位点 $j$）的参数 $\\sigma_{ij}$ 和 $\\varepsilon_{ij}$ 是通过 Lorentz-Berthelot 组合规则从单位点参数获得的：\n    $$\\sigma_{ij} = \\frac{\\sigma_i + \\sigma_j}{2}$$\n    $$\\varepsilon_{ij} = \\sqrt{\\varepsilon_i \\varepsilon_j}$$\n\n算法流程如下：\n对于每个测试用例 ($N_{\\mathrm{w}}, \\varepsilon_r$)：\n1.  初始化一个列表用于存储三种多晶型的总能量，`energies = []`。\n2.  对于每种多晶型 $P \\in \\{\\mathrm{alpha}, \\mathrm{beta}, \\mathrm{gamma}\\}$：\n    a. 计算每个甘氨酸位点 $i$ 与水氧相互作用的混合 Lennard-Jones 参数 $(\\sigma_{i,\\mathrm{O}}, \\varepsilon_{i,\\mathrm{O}})$。\n    b. 计算单水相互作用能 $E_{\\mathrm{int},1w}^{(P)}$。这涉及对 $3 \\times 3 = 9$ 个库仑项和 $3$ 个 Lennard-Jones 项求和，使用特定于多晶型的距离 $r_{i,s}^{(P)}$。\n    c. 计算总能量 $E_{\\mathrm{tot}}^{(P)} = E_{\\mathrm{latt}}^{(P)} + N_{\\mathrm{w}} \\times E_{\\mathrm{int},1w}^{(P)}$。\n    d. 将 $E_{\\mathrm{tot}}^{(P)}$ 附加到 `energies` 列表中。\n3.  在 `energies` 列表中找到最小值的索引。该索引对应于当前测试用例中最稳定的多晶型。\n4.  存储此索引。\n\n在处理完所有四个测试用例后，将结果索引汇编成一个最终列表。\n\n对于测试用例 1，当 $N_{\\mathrm{w}}=0$ 时，总能量就是晶格能，$E_{\\mathrm{tot}}^{(P)} = E_{\\mathrm{latt}}^{(P)}$。稳定性顺序通过比较 $E_{\\mathrm{latt}}^{(\\mathrm{alpha})} = -95.0$，$E_{\\mathrm{latt}}^{(\\mathrm{beta})} = -92.0$ 和 $E_{\\mathrm{latt}}^{(\\mathrm{gamma})} = -97.0$ 来确定。最低的能量是 $-97.0 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，对应于 gamma 多晶型（索引 2）。\n\n对于其他情况（$N_{\\mathrm{w}} > 0$），溶剂化能项会改变这种气相稳定性顺序。溶剂化能的大小和符号取决于甘氨酸周围水分子的特定几何排列（由每种多晶型的距离矩阵捕获），以及由 $\\varepsilon_r$ 控制的介电屏蔽。程序必须精确地按照规定实现这些计算，以确定相对稳定性的变化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the stable polymorph of glycine under different solvation conditions.\n    \"\"\"\n\n    # --- Givens from the problem statement ---\n\n    # Physical constants\n    K_E = 138.935456  # kJ/mol * nm / e^2\n\n    # Glycine parameters\n    GLYCINE_SITES = ['NH3', 'CH2', 'COO']\n    GLYCINE_CHARGES = {'NH3': 0.4, 'CH2': 0.0, 'COO': -0.4}  # in e\n    GLYCINE_SIGMA = {'NH3': 0.325, 'CH2': 0.340, 'COO': 0.300} # in nm\n    GLYCINE_EPSILON = {'NH3': 0.1, 'CH2': 0.1, 'COO': 0.1}   # in kJ/mol\n\n    # Water parameters\n    WATER_SITES = ['O', 'H1', 'H2']\n    WATER_CHARGES = {'O': -0.834, 'H1': 0.417, 'H2': 0.417} # in e\n    WATER_SIGMA = {'O': 0.315075}   # in nm\n    WATER_EPSILON = {'O': 0.636386} # in kJ/mol\n\n    # Polymorph-specific data\n    POLYMORPHS = ['alpha', 'beta', 'gamma']\n    POLYMORPH_INDICES = {name: i for i, name in enumerate(POLYMORPHS)}\n    \n    LATTICE_ENERGIES = { # in kJ/mol\n        'alpha': -95.0,\n        'beta': -92.0,\n        'gamma': -97.0,\n    }\n\n    DISTANCES = { # in nm\n        'alpha': {\n            'O':  np.array([0.30, 0.45, 0.50]), # NH3, CH2, COO\n            'H1': np.array([0.60, 0.60, 0.31]),\n            'H2': np.array([0.60, 0.60, 0.33]),\n        },\n        'beta': {\n            'O':  np.array([0.34, 0.45, 0.50]),\n            'H1': np.array([0.60, 0.60, 0.36]),\n            'H2': np.array([0.60, 0.60, 0.38]),\n        },\n        'gamma': {\n            'O':  np.array([0.33, 0.45, 0.50]),\n            'H1': np.array([0.60, 0.60, 0.35]),\n            'H2': np.array([0.60, 0.60, 0.37]),\n        },\n    }\n\n    # Test suite\n    test_cases = [\n        (0, 1.0),   # Case 1: N_w, epsilon_r\n        (2, 20.0),  # Case 2\n        (4, 20.0),  # Case 3\n        (4, 80.0),  # Case 4\n    ]\n\n    # --- Energy calculation functions ---\n\n    def coulomb_energy(q_i, q_j, r, epsilon_r):\n        return K_E * q_i * q_j / (epsilon_r * r)\n\n    def lj_energy(sigma_ij, epsilon_ij, r):\n        if r == 0:\n            return np.inf\n        s_over_r = sigma_ij / r\n        s_over_r_6 = s_over_r ** 6\n        s_over_r_12 = s_over_r_6 ** 2\n        return 4 * epsilon_ij * (s_over_r_12 - s_over_r_6)\n\n    # --- Pre-calculate mixed LJ parameters ---\n    \n    mixed_lj_params = {}\n    for gly_site in GLYCINE_SITES:\n        sigma_i = GLYCINE_SIGMA[gly_site]\n        epsilon_i = GLYCINE_EPSILON[gly_site]\n        \n        sigma_j = WATER_SIGMA['O']\n        epsilon_j = WATER_EPSILON['O']\n\n        # Lorentz-Berthelot mixing rules\n        sigma_ij = (sigma_i + sigma_j) / 2\n        epsilon_ij = np.sqrt(epsilon_i * epsilon_j)\n        \n        mixed_lj_params[gly_site] = {'sigma': sigma_ij, 'epsilon': epsilon_ij}\n\n    # --- Main calculation loop ---\n\n    results = []\n    for n_w, epsilon_r in test_cases:\n        total_energies = []\n        for poly in POLYMORPHS:\n            \n            # Start with gas-phase lattice energy\n            e_total = LATTICE_ENERGIES[poly]\n            \n            if n_w > 0:\n                e_solv_1w = 0.0 # Interaction energy for one water molecule\n                \n                # Iterate over 3 glycine sites\n                for i, gly_site in enumerate(GLYCINE_SITES):\n                    q_gly = GLYCINE_CHARGES[gly_site]\n                    \n                    # Interaction with water Oxygen\n                    r_o = DISTANCES[poly]['O'][i]\n                    e_solv_1w += coulomb_energy(q_gly, WATER_CHARGES['O'], r_o, epsilon_r)\n                    lj_params = mixed_lj_params[gly_site]\n                    e_solv_1w += lj_energy(lj_params['sigma'], lj_params['epsilon'], r_o)\n                    \n                    # Interaction with water H1\n                    r_h1 = DISTANCES[poly]['H1'][i]\n                    e_solv_1w += coulomb_energy(q_gly, WATER_CHARGES['H1'], r_h1, epsilon_r)\n                    \n                    # Interaction with water H2\n                    r_h2 = DISTANCES[poly]['H2'][i]\n                    e_solv_1w += coulomb_energy(q_gly, WATER_CHARGES['H2'], r_h2, epsilon_r)\n\n                # Total energy is lattice + N_w * single water interaction\n                e_total += n_w * e_solv_1w\n            \n            total_energies.append(e_total)\n            \n        # Find the index of the polymorph with the lowest energy\n        stable_polymorph_index = np.argmin(total_energies)\n        results.append(stable_polymorph_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "为了模拟更大尺度的现象，如高分子结晶，我们常常需要超越原子级别的描述。本练习引入了“粗粒化”的概念，将原子团视为单个单元，以研究高分子链如何自发折叠成有序的晶体结构。你将构建一个能量模型，并通过最小化总能量来探索稳定结构是如何在有利的内聚能和不利的表面/弯曲惩罚能之间的竞争中产生的，这是理解软物质和生物系统结构形成的核心原理 。",
            "id": "2452953",
            "problem": "给定一个单条聚乙烯链的粗粒化二维晶格模型，该链通过形成来回折叠的等长链段而折叠成片晶，但最后一个链段可能较短。该链共有 $N$ 个单体链段。片晶构型由一个整数链段长度 $T$ 参数化，其中 $1 \\le T \\le N$。链条排列成 $S(T)$ 个并排的链段，其中 $S(T) = \\lceil N/T \\rceil$。对于给定的 $T$，定义链段长度列表 $\\{L_i\\}_{i=1}^{S}$ 如下：对于 $i = 1, \\dots, S-1$，$L_i = T$；如果 $N$ 不能被 $T$ 整除，则 $L_S = N - T \\lfloor N/T \\rfloor$；否则 $L_S = T$。该构型的能量学分解为四个贡献项，均以 Boltzmann 常数乘以温度的单位 $k_{\\mathrm{B}} T$ 表示：\n\n1. 由相邻链段之间的侧向接触产生的内聚能：\n$$\nE_{\\mathrm{coh}}(T) = - \\varepsilon_{\\mathrm{c}} \\sum_{i=1}^{S-1} \\min(L_i, L_{i+1}),\n$$\n其中 $\\varepsilon_{\\mathrm{c}} > 0$ 是每个侧向接触的内聚能大小，而每一项 $\\min(L_i, L_{i+1})$ 计算了链段 $i$ 和 $i+1$ 之间界面上接触的单体对数量。\n\n2. 由片晶两个外侧产生的侧向自由表面能：\n$$\nE_{\\mathrm{lat}}(T) = \\gamma_{\\mathrm{lat}} \\times \\begin{cases}\n2 L_1,  \\text{if } S=1, \\\\\nL_1 + L_S,  \\text{if } S \\ge 2,\n\\end{cases}\n$$\n其中 $\\gamma_{\\mathrm{lat}} > 0$ 是单位长度侧向自由表面的能量，$L_1$ 是最左侧链段的长度，$L_S$ 是最右侧链段的长度。\n\n3. 晶体折叠面的链折叠表面能：\n$$\nE_{\\mathrm{fold}}(T) = \\gamma_{\\mathrm{fold}} \\times F(T),\n$$\n其中 $\\gamma_{\\mathrm{fold}} > 0$ 是每个折叠面的能量，$F(T) = S(T) - 1$ 是折叠数。\n\n4. 每个紧密发夹型折叠的弯曲罚能：\n$$\nE_{\\mathrm{bend}}(T) = e_{\\mathrm{b}} \\times F(T),\n$$\n其中 $e_{\\mathrm{b}} > 0$ 是每个折叠的弯曲能。\n\n总能量为\n$$\nE_{\\mathrm{tot}}(T) = E_{\\mathrm{coh}}(T) + E_{\\mathrm{lat}}(T) + E_{\\mathrm{fold}}(T) + E_{\\mathrm{bend}}(T).\n$$\n\n对于给定的参数集 $(N, \\varepsilon_{\\mathrm{c}}, \\gamma_{\\mathrm{lat}}, \\gamma_{\\mathrm{fold}}, e_{\\mathrm{b}})$，确定在 $1 \\le T \\le N$ 范围内的所有整数 $T$ 中使 $E_{\\mathrm{tot}}(T)$ 最小化的链段长度 $T_{\\star}$。如果存在多个使 $E_{\\mathrm{tot}}(T)$ 最小的 $T$ 值，则选择其中最大的 $T$。对于该最优构型，还需计算归因于链折叠表面的正罚能部分所占的比例，\n$$\nR_{\\mathrm{fold}} = \\frac{E_{\\mathrm{fold}}(T_{\\star})}{E_{\\mathrm{fold}}(T_{\\star}) + E_{\\mathrm{lat}}(T_{\\star}) + E_{\\mathrm{bend}}(T_{\\star})}.\n$$\n\n所有能量必须以 $k_{\\mathrm{B}} T$ 为单位表示，$R_{\\mathrm{fold}}$ 是无量纲的。将 $E_{\\mathrm{tot}}(T_{\\star})$ 和 $R_{\\mathrm{fold}}$ 报告为浮点数。\n\n使用以下参数集测试套件：\n- 测试用例 1: $(N, \\varepsilon_{\\mathrm{c}}, \\gamma_{\\mathrm{lat}}, \\gamma_{\\mathrm{fold}}, e_{\\mathrm{b}}) = (100, 0.8, 0.2, 2.0, 1.0)$。\n- 测试用例 2: $(N, \\varepsilon_{\\mathrm{c}}, \\gamma_{\\mathrm{lat}}, \\gamma_{\\mathrm{fold}}, e_{\\mathrm{b}}) = (120, 1.2, 0.1, 0.5, 0.5)$。\n- 测试用例 3: $(N, \\varepsilon_{\\mathrm{c}}, \\gamma_{\\mathrm{lat}}, \\gamma_{\\mathrm{fold}}, e_{\\mathrm{b}}) = (30, 0.5, 0.4, 5.0, 2.0)$。\n- 测试用例 4: $(N, \\varepsilon_{\\mathrm{c}}, \\gamma_{\\mathrm{lat}}, \\gamma_{\\mathrm{fold}}, e_{\\mathrm{b}}) = (37, 0.9, 0.15, 1.5, 0.2)$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个形式为 $[T_{\\star}, E_{\\mathrm{tot}}(T_{\\star}), R_{\\mathrm{fold}}]$ 的三元列表。浮点值必须四舍五入到六位小数。例如，总体输出必须类似于 `[[T1,E1,R1],[T2,E2,R2],[T3,E3,R3],[T4,E4,R4]]`，除了分隔列表元素的空格外没有其他空格，并且每个 $E_i$ 和 $R_i$ 都四舍五入到六位小数。所有能量都必须以 $k_{\\mathrm{B}} T$ 为单位。",
            "solution": "该问题要求为一个折叠聚合物链的粗粒化模型确定一个最优链段长度 $T_{\\star}$，该长度使得系统的总能量最小化。总能量是链段长度 $T$ 的函数。一旦找到 $T_{\\star}$，必须计算两个量：最小总能量 $E_{\\mathrm{tot}}(T_{\\star})$ 和归因于链折叠的正罚能比例 $R_{\\mathrm{fold}}$。\n\n### 步骤 1：问题验证\n\n首先，对问题陈述进行关键性验证。\n\n**已知条件：**\n- 单体链段总数：$N$。\n- 链段长度参数：一个整数 $T$，其中 $1 \\le T \\le N$。\n- 链段数：$S(T) = \\lceil N/T \\rceil$。\n- 链段长度列表 $\\{L_i\\}_{i=1}^{S}$：对于 $i \\in \\{1, \\dots, S-1\\}$，$L_i = T$；如果 $N \\pmod T \\neq 0$，则 $L_S = N - T \\lfloor N/T \\rfloor$，否则 $L_S = T$。\n- 每个接触的内聚能大小：$\\varepsilon_{\\mathrm{c}}  0$。\n- 单位长度的侧向自由表面能：$\\gamma_{\\mathrm{lat}}  0$。\n- 每个折叠的链折叠表面能：$\\gamma_{\\mathrm{fold}}  0$。\n- 每个折叠的弯曲能：$e_{\\mathrm{b}}  0$。\n- 能量贡献项：\n  - 内聚能：$E_{\\mathrm{coh}}(T) = - \\varepsilon_{\\mathrm{c}} \\sum_{i=1}^{S-1} \\min(L_i, L_{i+1})$。\n  - 侧向表面能：如果 $S=1$，$E_{\\mathrm{lat}}(T) = \\gamma_{\\mathrm{lat}} \\times (2 L_1)$；如果 $S \\ge 2$，$E_{\\mathrm{lat}}(T) = \\gamma_{\\mathrm{lat}} \\times (L_1 + L_S)$。\n  - 折叠表面能：$E_{\\mathrm{fold}}(T) = \\gamma_{\\mathrm{fold}} \\times F(T)$，其中 $F(T) = S(T) - 1$。\n  - 弯曲能：$E_{\\mathrm{bend}}(T) = e_{\\mathrm{b}} \\times F(T)$。\n- 总能量：$E_{\\mathrm{tot}}(T) = E_{\\mathrm{coh}}(T) + E_{\\mathrm{lat}}(T) + E_{\\mathrm{fold}}(T) + E_{\\mathrm{bend}}(T)$。\n- 优化目标：找到 $T_{\\star} = \\arg\\max_{T \\in \\mathcal{T}} T$，其中 $\\mathcal{T} = \\{T \\in [1, N] \\cap \\mathbb{Z} \\mid E_{\\mathrm{tot}}(T) = \\min_{T' \\in [1, N] \\cap \\mathbb{Z}} E_{\\mathrm{tot}}(T') \\}$。\n- 输出指标：$T_{\\star}$，$E_{\\mathrm{tot}}(T_{\\star})$ 和 $R_{\\mathrm{fold}} = \\frac{E_{\\mathrm{fold}}(T_{\\star})}{E_{\\mathrm{fold}}(T_{\\star}) + E_{\\mathrm{lat}}(T_{\\star}) + E_{\\mathrm{bend}}(T_{\\star})}$。\n\n**验证结论：**\n该问题具有科学依据，描述了一个在高分子物理和计算材料科学中用于研究聚合物结晶的简化但标准的粗粒化模型。各能量项具有明确的物理意义。该问题在数学上是适定的；它要求在一个有限离散域上找到一个函数的最小值点。平局打破规则确保了解 $T_{\\star}$ 的唯一性。所有术语都得到了精确定义，并且参数已给定。问题是客观的，没有歧义。这是一个可形式化且可解的计算问题。因此，该问题是 **有效的**。\n\n### 步骤 2：算法设计与解法推导\n\n问题的核心是在范围 $[1, N]$ 内找到使函数 $E_{\\mathrm{tot}}(T)$ 最小化的整数 $T$。由于 $T$ 的定义域是离散且有限的，直接搜索算法是合适的。该算法将遍历从 $1$ 到 $N$ 的每个可能的整数值 $T$，为每个值计算总能量 $E_{\\mathrm{tot}}(T)$，并确定导致最小能量的值 $T_{\\star}$。\n\n对于给定的参数集 $(N, \\varepsilon_{\\mathrm{c}}, \\gamma_{\\mathrm{lat}}, \\gamma_{\\mathrm{fold}}, e_{\\mathrm{b}})$ 和一个候选链段长度 $T \\in [1, N]$，计算过程如下：\n\n1.  **计算几何性质**：\n    - 链段数为 $S = \\lceil N/T \\rceil$。\n    - 折叠数为 $F = S - 1$。注意，如果 $S \\le 1$，$F$ 为零。\n    - 第一个链段的长度为 $L_1 = T$。这对任何 $T  N$ 都成立。如果 $T=N$，则 $S=1$，单个链段的长度为 $L_1=N$。\n    - 最后一个链段的长度 $L_S$ 需要仔细定义。如果 $N$ 是 $T$ 的倍数，所有 $S$ 个链段的长度都为 $T$，所以 $L_S = T$。如果 $N$ 不是 $T$ 的倍数，最后一个链段较短，长度为 $L_S = N \\pmod T$。一个统一的表达式是 $L_S = (N-1) \\pmod T + 1$，或者更直接地，如果 $N \\pmod T = 0$，则 $L_S = T$，否则 $L_S = N \\pmod T$。这是针对 $S \\ge 2$ 的情况。如果 $S=1$（即 $T=N$），则只有一个长度为 $L_1=N$ 的链段。\n\n2.  **计算能量分量**：\n    -   **$E_{\\mathrm{fold}}(T)$ 和 $E_{\\mathrm{bend}}(T)$**：这些能量仅取决于折叠数 $F$。\n        $$E_{\\mathrm{fold}}(T) = \\gamma_{\\mathrm{fold}} \\times (S - 1)$$\n        $$E_{\\mathrm{bend}}(T) = e_{\\mathrm{b}} \\times (S - 1)$$\n        它们可以合并为 $E_{\\text{fold+bend}}(T) = (\\gamma_{\\mathrm{fold}} + e_{\\mathrm{b}}) \\times (S - 1)$。如果 $S \\le 1$，这些项为零。\n\n    -   **$E_{\\mathrm{lat}}(T)$**：侧向表面能取决于链段数。\n        -   如果 $S=1$（仅当 $T=N$ 时发生），片晶是一个长度为 $N$ 的单链段。两侧都暴露在外。$L_1=N$。\n            $$E_{\\mathrm{lat}}(T) = \\gamma_{\\mathrm{lat}} \\times 2N$$\n        -   如果 $S \\ge 2$，片晶由多个链段构成。两个外部链段 $L_1$ 和 $L_S$ 贡献了表面。$L_1=T$。\n            $$E_{\\mathrm{lat}}(T) = \\gamma_{\\mathrm{lat}} \\times (T + L_S)$$\n\n    -   **$E_{\\mathrm{coh}}(T)$**：内聚能来自相邻链段之间的接触。\n        -   如果 $S \\le 1$，没有相邻链段，所以求和为空，$E_{\\mathrm{coh}}(T) = 0$。\n        -   如果 $S \\ge 2$，必须计算求和 $\\sum_{i=1}^{S-1} \\min(L_i, L_{i+1})$。求和的前 $S-2$ 项是 $\\min(L_i, L_{i+1}) = \\min(T, T) = T$。最后一项是 $\\min(L_{S-1}, L_S) = \\min(T, L_S) = L_S$（因为 $L_S \\le T$）。因此，总接触数为 $(S-2)T + L_S$。\n            $$E_{\\mathrm{coh}}(T) = -\\varepsilon_{\\mathrm{c}} \\left( (S-2)T + L_S \\right)$$\n\n3.  **计算总能量**：\n    总能量 $E_{\\mathrm{tot}}(T)$ 是这四个分量的和。高效的实现方式会对于给定的 $T$ 预先计算 $S$、$F$ 和 $L_S$，然后计算每个能量项。\n\n4.  **最小化过程**：\n    初始化一个用于存储最小能量的变量 $E_{\\min}$，其值大于任何可能的能量（例如，无穷大），并将最优链段长度 $T_{\\star}$ 初始化为 $0$。从 $1$ 到 $N$ 遍历 $T$。在每次迭代中，计算 $E_{\\mathrm{tot}}(T)$。如果 $E_{\\mathrm{tot}}(T) \\le E_{\\min}$，则更新 $E_{\\min} = E_{\\mathrm{tot}}(T)$ 和 $T_{\\star} = T$。使用 $\\le$ 正确地实现了选择最大 $T$ 的平局打破规则。\n\n5.  **$R_{\\mathrm{fold}}$ 的最终计算**：\n    循环结束后，最优链段长度 $T_{\\star}$ 和最小能量 $E_{\\mathrm{tot}}(T_{\\star})$ 就已知了。必须重新计算或存储此最优构型的能量分量 $E_{\\mathrm{fold}}(T_{\\star})$、$E_{\\mathrm{lat}}(T_{\\star})$ 和 $E_{\\mathrm{bend}}(T_{\\star})$。然后，比率 $R_{\\mathrm{fold}}$ 按以下公式计算：\n    $$R_{\\mathrm{fold}} = \\frac{E_{\\mathrm{fold}}(T_{\\star})}{E_{\\mathrm{fold}}(T_{\\star}) + E_{\\mathrm{lat}}(T_{\\star}) + E_{\\mathrm{bend}}(T_{\\star})}$$\n    正如在验证阶段所确立的，给定正的能量参数，对于 $N \\ge 1$，分母是严格为正的。\n\n对每个提供的测试用例实施此系统性步骤，以获得所需的结果。计算出的 $E_{\\mathrm{tot}}(T_{\\star})$ 和 $R_{\\mathrm{fold}}$ 的浮点值随后按照要求四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polymer folding problem for a given set of test cases.\n    \"\"\"\n    \n    # Test cases: (N, eps_c, gamma_lat, gamma_fold, e_b)\n    test_cases = [\n        (100, 0.8, 0.2, 2.0, 1.0),\n        (120, 1.2, 0.1, 0.5, 0.5),\n        (30, 0.5, 0.4, 5.0, 2.0),\n        (37, 0.9, 0.15, 1.5, 0.2),\n    ]\n\n    results_list = []\n\n    for N, eps_c, gamma_lat, gamma_fold, e_b in test_cases:\n        min_total_energy = float('inf')\n        optimal_T = 0\n        \n        # Store components for optimal T to calculate R_fold later\n        optimal_energies = {'fold': 0, 'lat': 0, 'bend': 0}\n\n        # Iterate through all possible integer stem lengths T from 1 to N\n        for T in range(1, N + 1):\n            # 1. Calculate geometric properties\n            S = int(np.ceil(N / T)) # Number of stems\n            F = S - 1                 # Number of folds\n\n            # 2. Calculate energy components\n            e_coh = 0.0\n            e_lat = 0.0\n            \n            # Combined fold and bend penalty\n            e_fold = gamma_fold * F\n            e_bend = e_b * F\n\n            if S == 1: # Case where the chain is one single unfolded stem\n                # T must be equal to N for S to be 1\n                e_coh = 0.0\n                e_lat = gamma_lat * 2.0 * N\n            else: # Case with folds (S >= 2)\n                # Calculate length of the last stem, L_S\n                l_s_rem = N % T\n                L_S = T if l_s_rem == 0 else l_s_rem\n                \n                # Cohesive energy\n                # Number of contacts is (S-2)*T + L_S\n                num_contacts = (S - 2) * T + L_S\n                e_coh = -eps_c * num_contacts\n                \n                # Lateral surface energy\n                # L_1 is always T in this case\n                e_lat = gamma_lat * (T + L_S)\n\n            # 3. Calculate total energy\n            e_total = e_coh + e_lat + e_fold + e_bend\n\n            # 4. Minimization and tie-breaking\n            # If current energy is lower, or equal (for larger T), update optimum\n            if e_total = min_total_energy:\n                min_total_energy = e_total\n                optimal_T = T\n                optimal_energies['fold'] = e_fold\n                optimal_energies['lat'] = e_lat\n                optimal_energies['bend'] = e_bend\n        \n        # 5. Final calculation of R_fold\n        penalty_energy_sum = optimal_energies['fold'] + optimal_energies['lat'] + optimal_energies['bend']\n        \n        if penalty_energy_sum == 0:\n            # This case should not occur for N>=1 and positive penalties\n            r_fold = 0.0 \n        else:\n            r_fold = optimal_energies['fold'] / penalty_energy_sum\n\n        # Format results as specified\n        formatted_result = f\"[{optimal_T},{min_total_energy:.6f},{r_fold:.6f}]\"\n        results_list.append(formatted_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n\n```"
        }
    ]
}