{
    "hands_on_practices": [
        {
            "introduction": "机器学习势的核心在于如何将原子坐标（一个有序列表）转化为一个尊重物理对称性（平移、旋转和置换不变性）的能量预测。第一步是构建原子环境的数学描述符。本练习  将指导你从基本原理出发，亲手实现一个Behler-Parrinello类型的径向对称函数，它是高维神经网络势的基石，让你深入理解如何将抽象的对称性要求转化为具体的计算代码。",
            "id": "2457438",
            "problem": "实现一个程序，用于推导和计算氩 (Ar) 原子的基本双体 Behler–Parrinello 型对称函数，并在一个小型几何结构测试集上对其进行评估。其目的是将机器学习原子间势的不变性要求与一个具体的描述符联系起来，并展示在不同参数选择下的数值行为。总体背景是，一个系统的总势能面可以近似为原子贡献的总和，每个贡献都取决于其邻域环境的一个局域化、对称不变的表示，正如在高维神经网络势 (HDNNP) 中所述。您的任务是从不变性原理出发，推导出一个双体径向对称函数并予以实现。\n\n从以下基本原则出发：\n- 标量势能的平移和旋转不变性意味着，一个原子的局域描述符必须由内部坐标（如原子间距离）构建。\n- 对于有限范围的相互作用和学习映射中的局域性，在一个有限半径处施加一个平滑的截断，这样超出截断半径的远距离原子就不会产生贡献，并且力能保持良好的行为。\n- 为了解析原子周围的径向分布，使用一个具有可调宽度和中心参数的径向基，以便该表示能够区分不同长度尺度下的环境。\n\n从这些原则出发，推导并实现一个针对选定中心原子 $i$ 的双体径向对称函数 $G^2$，其形式为：\n- 对邻近原子 $j \\neq i$ 的求和，\n- 一个平滑的、有限范围的截断函数，该函数是 $C^1$ 连续的，并在截断半径处等于零，\n- 以及一个可以在选定距离周围移动和锐化的局域径向权重。\n\n在您的推导和实现中，具体指定并使用以下形式：\n- 使用余弦截断函数\n$$\nf_c(r; R_c) = \n\\begin{cases}\n\\dfrac{1}{2}\\left[\\cos\\!\\left(\\dfrac{\\pi r}{R_c}\\right) + 1\\right],  r \\le R_c,\\\\\n0,  r > R_c,\n\\end{cases}\n$$\n其中余弦函数的参数以弧度为单位。\n- 使用类高斯径向基\n$$\n\\exp\\!\\left[-\\eta\\,(r - R_s)^2\\right],\n$$\n其中 $\\eta$ 为宽度参数，$R_s$ 为位移参数。\n- 将它们组合成双体对称函数\n$$\nG_i^{2}(\\eta, R_s, R_c) = \\sum_{j \\ne i} \\exp\\!\\left[-\\eta\\,(r_{ij} - R_s)^2\\right]\\, f_c(r_{ij}; R_c),\n$$\n其中 $r_{ij}$ 是原子 $i$ 和 $j$ 之间的欧几里得距离。\n\n所有原子都是氩 (Ar) 原子，被视为单一化学物种，因此不需要与物种相关的加权。距离 $r_{ij}$、截断半径 $R_c$ 和位移 $R_s$ 必须以埃 (Ångström) 为单位，$\\eta$ 的单位为 $\\text{Å}^{-2}$。余弦函数必须以弧度作为其参数。\n\n程序要求：\n- 实现一个函数，该函数接收一组笛卡尔坐标（单位为埃）、中心原子的索引 $i$ 和参数 $(\\eta, R_s, R_c)$，并使用上述公式计算 $G_i^{2}(\\eta, R_s, R_c)$。\n- 使用标准的三维欧几里得距离。不要应用周期性边界条件。\n- 数值稳定性：排除自身相互作用 ($j = i$)。距离 $r_{ij}$ 严格非负；除了排除自身相互作用外，无需对 $r_{ij} = 0$ 进行特殊处理。\n\n测试集：\n对以下五个案例，分别评估 $G_i^{2}$。每个案例指定了 $(\\text{positions}, i, R_c, \\eta, R_s)$，所有距离单位为埃，$\\eta$ 的单位为 $\\text{Å}^{-2}$：\n- 案例 A:\n  - positions: $\\big[(0,0,0),(2.0,0,0),(0,3.0,0),(0,0,4.0)\\big]$\n  - $i = 0$\n  - $R_c = 5.0$\n  - $\\eta = 0.5$\n  - $R_s = 0.0$\n- 案例 B:\n  - positions: $\\big[(0,0,0)\\big]$\n  - $i = 0$\n  - $R_c = 3.0$\n  - $\\eta = 1.0$\n  - $R_s = 0.0$\n- 案例 C:\n  - positions: $\\big[(0,0,0),(5.0,0,0),(-5.0,0,0)\\big]$\n  - $i = 0$\n  - $R_c = 5.0$\n  - $\\eta = 1.0$\n  - $R_s = 0.0$\n- 案例 D:\n  - positions: $\\big[(0,0,0),(2.0,0,0),(0,3.0,0),(0,0,4.0)\\big]$\n  - $i = 0$\n  - $R_c = 5.0$\n  - $\\eta = 2.0$\n  - $R_s = 2.5$\n- 案例 E:\n  - positions: $\\big[(0,0,0),(2.0,0,0),(0,3.0,0),(0,0,4.0)\\big]$\n  - $i = 1$\n  - $R_c = 5.0$\n  - $\\eta = 0.5$\n  - $R_s = 0.0$\n\n输出规范：\n- 对于每个案例，计算一个浮点数值 $G_i^{2}$。\n- 使用标准四舍五入将每个结果保留到恰好 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含按 A、B、C、D、E 顺序排列的结果，形式为用方括号括起来的逗号分隔列表。例如，使用通用占位符的输出应如下所示：\"[0.123456,0.000000,0.000000,1.234567,0.654321]\"。",
            "solution": "所提出的问题是有效、科学合理且定义明确的。它要求推导和实现一个双体径向对称函数，这是诸如高维神经网络势 (HDNNP) 等现代机器学习原子间势的一个基本组成部分。我们将首先从第一性原理出发推导出该函数的形式，然后详细说明其计算算法。\n\n原子体系的势能 $E$ 是一个标量。为了使其具有物理意义，它必须在整个体系的平移和旋转，以及相同原子的置换下保持不变。在 HDNNP 方案中，总能量被分解为原子能量贡献 $E_i$，其中 $E = \\sum_i E_i$。每个原子能量 $E_i$ 是原子 $i$ 局域环境的函数，该环境由一组描述符或“对称函数” $\\{G_i\\}$ 来表征。因此，这些对称函数本身必须对上述变换保持不变。\n\n1.  **平移和旋转不变性**：这些对称性要求原子 $i$ 的描述符必须仅依赖于其局域环境的内部坐标，而不是全局坐标系中原子的绝对笛卡尔坐标。最简单的内部坐标集由中心原子 $i$ 与其邻居原子 $j$ 之间的标量距离 $r_{ij}$ 组成。任何关于这些距离的函数 $G_i = F(\\{r_{ij}\\}_{j \\neq i})$，对于原子集合的刚性平移和旋转都是自动不变的。\n\n2.  **置换不变性**：原子 $i$ 的能量贡献不能依赖于其相同邻居原子的任意标记方式。如果原子 $j$ 和 $k$ 是同一物种，交换它们不能改变描述符的值。满足此条件的最简单的数学结构是对所有邻居原子求和。因此，我们提出一个形式为 $G_i = \\sum_{j \\neq i} g(r_{ij})$ 的描述符，其中 $g$ 是原子间距离的某个函数。这种形式是双体对称函数的基础。\n\n3.  **局域性和平滑性**：物理相互作用本质上是局域的；非常遥远的原子的影响可以忽略不计。为了对此建模，我们引入一个平滑的截断函数 $f_c(r_{ij}; R_c)$，它乘以每个邻居原子的贡献。该函数在小距离处必须等于 $1$，并随着距离 $r_{ij}$ 接近截断半径 $R_c$ 而平滑地趋于 $0$。对于距离 $r_{ij} > R_c$，其贡献恰好为零。对平滑性的要求，特别是 $C^1$ 连续性（一阶导数连续），至关重要。原子受力计算为势能的负梯度，$\\mathbf{F}_k = -\\nabla_{\\mathbf{r}_k} E$。能量一阶导数的不连续性将导致不符合物理的、无穷大的力。提供的余弦截断函数是：\n    $$\n    f_c(r; R_c) = \n    \\begin{cases}\n    \\frac{1}{2}\\left[\\cos\\left(\\frac{\\pi r}{R_c}\\right) + 1\\right],  r \\le R_c,\\\\\n    0,  r > R_c.\n    \\end{cases}\n    $$\n    在截断半径 $r = R_c$ 处，函数值为 $f_c(R_c; R_c) = \\frac{1}{2}[\\cos(\\pi) + 1] = \\frac{1}{2}[-1 + 1] = 0$，确保了连续性。其导数为 $f'_c(r; R_c) = -\\frac{\\pi}{2R_c}\\sin(\\frac{\\pi r}{R_c})$。在 $r = R_c$ 处，导数为 $f'_c(R_c; R_c) = -\\frac{\\pi}{2R_c}\\sin(\\pi) = 0$，这与 $r > R_c$ 时零函数的导数相匹配。因此，该函数按要求是 $C^1$ 连续的。\n\n4.  **径向分辨率**：一个简单的截断函数求和只能提供截断球内邻居原子的加权计数。为了创建一个能够区分不同径向结构的描述符，我们引入一个径向基函数。指定的高斯形式 $\\exp[-\\eta(r_{ij} - R_s)^2]$ 即为此目的服务。该函数以距离 $R_s$ 为中心，其特征宽度由参数 $\\eta$ 控制。更大的 $\\eta$ 对应更窄、更尖锐的高斯峰。通过使用一组具有不同参数 $(\\eta, R_s)$ 的此类函数，可以解析中心原子 $i$ 周围邻居的径向分布。\n\n结合这四个原则——使用距离带来的不变性、求和带来的置换对称性、平滑截断带来的局域性、以及径向基带来的分辨率——我们得到了指定的双体径向对称函数，记为 $G_i^2$：\n$$\nG_i^{2}(\\eta, R_s, R_c) = \\sum_{j \\ne i} \\exp\\!\\left[-\\eta\\,(r_{ij} - R_s)^2\\right]\\, f_c(r_{ij}; R_c)\n$$\n求和遍历体系中除中心原子 $i$ 之外的所有原子 $j$。对于每个邻居原子 $j$，我们仅在其与原子 $i$ 的距离 $r_{ij}$ 小于或等于截断半径 $R_c$ 时才计算其贡献。\n\n计算步骤如下：\n给定 $N$ 个原子的笛卡尔坐标集 $\\{\\mathbf{r}_k\\}_{k=0,..,N-1}$、一个中心原子索引 $i$ 和参数 $\\eta$、$R_s$ 和 $R_c$：\n1.  初始化对称函数值 $G_i^2$ 为 $0$。\n2.  确定中心原子的坐标向量 $\\mathbf{r}_i$。\n3.  遍历所有其他原子 $j$，其中 $j \\in \\{0, 1, ..., N-1\\}$ 且 $j \\neq i$。\n4.  对于每个邻居原子 $j$，计算欧几里得距离 $r_{ij} = ||\\mathbf{r}_j - \\mathbf{r}_i|| = \\sqrt{(x_j-x_i)^2 + (y_j-y_i)^2 + (z_j-z_i)^2}$。\n5.  检查是否 $r_{ij} \\le R_c$。如果不是，原子 $j$ 的贡献为 $0$，我们继续处理下一个邻居原子。\n6.  如果 $r_{ij} \\le R_c$，计算该项的两个分量：\n    -   径向基项：$T_{\\text{rad}} = \\exp[-\\eta(r_{ij} - R_s)^2]$。\n    -   截断函数项：$T_{\\text{cut}} = \\frac{1}{2}[\\cos(\\frac{\\pi r_{ij}}{R_c}) + 1]$。\n7.  将这些项的乘积 $T_{\\text{rad}} \\times T_{\\text{cut}}$ 加到 $G_i^2$ 的运行总和中。\n8.  遍历所有邻居原子 $j$ 后，最终的总和即为原子 $i$ 的对称函数值。\n\n现在将实现此过程，并将其应用于五个指定的测试案例。所有单位必须一致；距离（$r_{ij}$、$R_s$、$R_c$）以埃（$\\text{Å}$）为单位，参数 $\\eta$ 以 $\\text{Å}^{-2}$ 为单位，以确保指数的参数是无量纲的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the Behler-Parrinello G2 symmetry function\n    for a series of test cases.\n    \"\"\"\n\n    def compute_g2(positions, i, R_c, eta, R_s):\n        \"\"\"\n        Computes the G2 symmetry function for a central atom i.\n        \n        Args:\n            positions (np.ndarray): Array of shape (N, 3) with Cartesian coordinates.\n            i (int): Index of the central atom.\n            R_c (float): Cutoff radius in Angstrom.\n            eta (float): Width parameter in Angstrom^-2.\n            R_s (float): Shift parameter in Angstrom.\n        \n        Returns:\n            float: The computed value of the G2 symmetry function.\n        \"\"\"\n        if positions.shape[0] == 1:\n            return 0.0\n\n        central_atom_pos = positions[i]\n        g2_value = 0.0\n\n        for j in range(positions.shape[0]):\n            if i == j:\n                continue\n\n            neighbor_pos = positions[j]\n            # Calculate Euclidean distance\n            r_ij = np.linalg.norm(central_atom_pos - neighbor_pos)\n\n            # Apply the cutoff condition\n            if r_ij = R_c:\n                # Cosine cutoff function\n                fc = 0.5 * (np.cos(np.pi * r_ij / R_c) + 1.0)\n                \n                # Gaussian-like radial basis function\n                radial_term = np.exp(-eta * (r_ij - R_s)**2)\n                \n                # Add contribution to the sum\n                g2_value += radial_term * fc\n        \n        return g2_value\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'positions': np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 3.0, 0.0], [0.0, 0.0, 4.0]]),\n         'i': 0, 'R_c': 5.0, 'eta': 0.5, 'R_s': 0.0},\n        # Case B\n        {'positions': np.array([[0.0, 0.0, 0.0]]),\n         'i': 0, 'R_c': 3.0, 'eta': 1.0, 'R_s': 0.0},\n        # Case C\n        {'positions': np.array([[0.0, 0.0, 0.0], [5.0, 0.0, 0.0], [-5.0, 0.0, 0.0]]),\n         'i': 0, 'R_c': 5.0, 'eta': 1.0, 'R_s': 0.0},\n        # Case D\n        {'positions': np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 3.0, 0.0], [0.0, 0.0, 4.0]]),\n         'i': 0, 'R_c': 5.0, 'eta': 2.0, 'R_s': 2.5},\n        # Case E\n        {'positions': np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 3.0, 0.0], [0.0, 0.0, 4.0]]),\n         'i': 1, 'R_c': 5.0, 'eta': 0.5, 'R_s': 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_g2(\n            positions=case['positions'],\n            i=case['i'],\n            R_c=case['R_c'],\n            eta=case['eta'],\n            R_s=case['R_s']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format string \"{:.6f}\" handles rounding to 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个机器学习势的准确性高度依赖于训练它的数据。在某个物理化学环境（例如，液态水）中训练出的模型，当被用于一个截然不同的环境（例如，真空中孤立的水分子二聚体）时，其预测能力可能会完全失效。这个练习  通过一个简明扼要的数值实验，让你亲身体验这种“分布外”应用的失败，深刻理解模型可移植性这一关键挑战。",
            "id": "2457471",
            "problem": "您将实现一个完整、可运行的程序，该程序构建一个简单的一维机器学习势，该势在合成的“周期性体相水”数据上进行训练，然后评估其预测水二聚体在真空中势能曲线（作为氧-氧间距的函数）的能力。目标是通过显式的数值评估，展示一个在周期性体相数据上训练的模型，在应用于域外的真空二聚体势能曲线时，可能会如何失效。\n\n基本出发点：使用一个物理上合理的对相互作用表示来描述真空二聚体的势能，该表示能够捕捉短程泡利排斥和长程色散吸引之间的竞争。使用核岭回归模型和高斯核来表示一维机器学习势。程序必须完全自包含。\n\n定义与规范：\n\n1) 真空水二聚体势能模型。对于以埃（ångström）为单位的氧-氧间距 $R$，将真空参考能量 $E_{\\mathrm{vac}}(R)$ 定义为\n$$\nE_{\\mathrm{vac}}(R) \\equiv A_{\\mathrm{rep}} \\, e^{-b_{\\mathrm{rep}} R} \\;-\\; \\frac{C_6}{R^6},\n$$\n参数如下\n- $A_{\\mathrm{rep}} = 295400$，单位 $\\mathrm{kJ/mol}$，\n- $b_{\\mathrm{rep}} = 3.2$，单位 $\\mathrm{\\AA^{-1}}$，\n- $C_6 = 25000$，单位 $\\mathrm{kJ \\, \\AA^6/mol}$。\n所有能量必须以 $\\mathrm{kJ/mol}$ 表示，所有距离 $R$ 必须以 $\\mathrm{\\AA}$ 表示。\n\n2) 模拟周期性体相训练数据。为了模拟训练数据来源于周期性体相水（因此包含真空中所没有的多体环境稳定化效应），定义一个环境稳定项\n$$\n\\Delta_{\\mathrm{env}}(R) \\equiv -A_{\\mathrm{env}} \\exp\\!\\left(-\\frac{(R - R_{\\mathrm{env}})^2}{2 s_{\\mathrm{env}}^2}\\right),\n$$\n其中\n- $A_{\\mathrm{env}} = 8.0$，单位 $\\mathrm{kJ/mol}$，\n- $R_{\\mathrm{env}} = 2.75$，单位 $\\mathrm{\\AA}$，\n- $s_{\\mathrm{env}} = 0.15$，单位 $\\mathrm{\\AA}$。\n“体相标记”的训练能量为\n$$\nE_{\\mathrm{bulk}}(R) \\equiv E_{\\mathrm{vac}}(R) + \\Delta_{\\mathrm{env}}(R).\n$$\n\n3) 训练集构建。通过在区间 $[R_{\\min}, R_{\\max}]$ 内均匀采样 $N$ 个点来构建训练集 $\\{(R_i, y_i)\\}_{i=1}^{N}$，其中\n- $R_{\\min} = 2.5$，单位 $\\mathrm{\\AA}$，\n- $R_{\\max} = 3.0$，单位 $\\mathrm{\\AA}$，\n- $N = 40$，\n并设置 $y_i \\equiv E_{\\mathrm{bulk}}(R_i)$。\n\n4) 机器学习势（核岭回归）。使用带高斯核的核岭回归，获得一个在上述数据上训练的模型 $\\widehat{E}(R)$。具体来说，定义核函数\n$$\nK(R, R') \\equiv \\exp\\!\\left(-\\frac{(R - R')^2}{2 \\ell^2}\\right),\n$$\n其长度尺度为\n- $\\ell = 0.25$，单位 $\\mathrm{\\AA}$，\n岭正则化参数为\n- $\\lambda = 10^{-6}$ (无量纲)。\n令 $\\mathbf{K} \\in \\mathbb{R}^{N \\times N}$ 为 Gram 矩阵，其元素为 $K_{ij} \\equiv K(R_i, R_j)$。系数向量 $\\boldsymbol{\\alpha} \\in \\mathbb{R}^{N}$ 的核岭回归解为\n$$\n\\boldsymbol{\\alpha} = \\left(\\mathbf{K} + \\lambda \\mathbf{I}\\right)^{-1} \\mathbf{y},\n$$\n其中 $\\mathbf{y} = (y_1, \\dots, y_N)^\\top$。模型在新间距 $R$ 处的预测值为\n$$\n\\widehat{E}(R) = \\sum_{j=1}^{N} \\alpha_j \\, K(R, R_j).\n$$\n\n5) 对照真空参考进行评估。将模型 $\\widehat{E}(R)$ 与真空参考 $E_{\\mathrm{vac}}(R)$ 在一组指定的测试间距上进行比较评估，并通过比较网格上的最小值点位置来进行评估。所有能量必须以 $\\mathrm{kJ/mol}$ 报告，所有距离以 $\\mathrm{\\AA}$ 报告。\n\n测试套件：\n\n- 在氧-氧间距上的逐点测试\n$$\nR_{\\mathrm{test}} \\in \\{ 2.4, \\; 2.85, \\; 3.4, \\; 5.0 \\} \\; \\mathrm{\\AA}.\n$$\n对于集合中的每个 $R$，计算绝对能量误差\n$$\n\\varepsilon(R) \\equiv \\left| \\widehat{E}(R) - E_{\\mathrm{vac}}(R) \\right|\n$$\n单位为 $\\mathrm{kJ/mol}$。\n\n- 网格上的最小值点位置测试。在一个均匀网格\n$$\nR \\in [2.2, \\; 5.0] \\; \\mathrm{\\AA}\n$$\n上网格间距为\n$$\n\\Delta R = 0.001 \\; \\mathrm{\\AA},\n$$\n计算\n$$\nR_{\\min}^{\\mathrm{vac}} \\equiv \\operatorname*{arg\\,min}_{R} E_{\\mathrm{vac}}(R), \\quad\nR_{\\min}^{\\mathrm{ml}} \\equiv \\operatorname*{arg\\,min}_{R} \\widehat{E}(R),\n$$\n并报告有符号偏差\n$$\n\\Delta R_{\\min} \\equiv R_{\\min}^{\\mathrm{ml}} - R_{\\min}^{\\mathrm{vac}}\n$$\n单位为 $\\mathrm{\\AA}$。\n\n要求的最终输出格式：\n\n- 您的程序必须生成单行输出，包含一个有5个条目的列表：\n  1) $\\varepsilon(2.4)$,\n  2) $\\varepsilon(2.85)$,\n  3) $\\varepsilon(3.4)$,\n  4) $\\varepsilon(5.0)$,\n  5) $\\Delta R_{\\min}$.\n- 前四个条目必须是浮点数，单位为 $\\mathrm{kJ/mol}$，精确到3位小数。最后一个条目必须是浮点数，单位为 $\\mathrm{\\AA}$，精确到3位小数。\n- 输出必须是用逗号分隔的列表，并用方括号括起来，例如\n$$\n[\\varepsilon(2.4),\\varepsilon(2.85),\\varepsilon(3.4),\\varepsilon(5.0),\\Delta R_{\\min}]\n$$\n所有五个数字都显示为小数，小数点后恰好有三位数字。\n\n约束和说明：\n\n- 程序必须严格实现上述定义，不使用任何外部数据。\n- 所有能量必须以 $\\mathrm{kJ/mol}$ 表示，所有距离以 $\\mathrm{\\AA}$ 表示。\n- 不需要随机数。\n- 在这个简化的一维模型中不使用角度；所有角度量都是无关的。\n- 您的代码必须是独立的，并且不得读取任何输入。",
            "solution": "问题经过验证。\n\n**步骤1：提取已知信息**\n\n问题提供了以下定义、参数和条件：\n\n1.  **真空水二聚体势能模型**：\n    势能为 $E_{\\mathrm{vac}}(R) \\equiv A_{\\mathrm{rep}} \\, e^{-b_{\\mathrm{rep}} R} - \\frac{C_6}{R^6}$，其中 $R$ 是氧-氧间距。\n    参数：\n    $A_{\\mathrm{rep}} = 295400 \\, \\mathrm{kJ/mol}$\n    $b_{\\mathrm{rep}} = 3.2 \\, \\mathrm{\\AA^{-1}}$\n    $C_6 = 25000 \\, \\mathrm{kJ \\, \\AA^6/mol}$\n\n2.  **环境稳定项**：\n    该项定义为 $\\Delta_{\\mathrm{env}}(R) \\equiv -A_{\\mathrm{env}} \\exp\\!\\left(-\\frac{(R - R_{\\mathrm{env}})^2}{2 s_{\\mathrm{env}}^2}\\right)$。\n    参数：\n    $A_{\\mathrm{env}} = 8.0 \\, \\mathrm{kJ/mol}$\n    $R_{\\mathrm{env}} = 2.75 \\, \\mathrm{\\AA}$\n    $s_{\\mathrm{env}} = 0.15 \\, \\mathrm{\\AA}$\n\n3.  **体相标记的训练能量**：\n    能量为 $E_{\\mathrm{bulk}}(R) \\equiv E_{\\mathrm{vac}}(R) + \\Delta_{\\mathrm{env}}(R)$。\n\n4.  **训练集**：\n    一个包含 $N=40$ 个点的集合 $\\{(R_i, y_i)\\}_{i=1}^{N}$。\n    采样区间：$R_i \\in [R_{\\min}, R_{\\max}]$，其中 $R_{\\min} = 2.5 \\, \\mathrm{\\AA}$，$R_{\\max} = 3.0 \\, \\mathrm{\\AA}$。\n    采样方法：均匀采样。\n    训练目标：$y_i \\equiv E_{\\mathrm{bulk}}(R_i)$。\n\n5.  **机器学习势（核岭回归）**：\n    核函数：$K(R, R') \\equiv \\exp\\!\\left(-\\frac{(R - R')^2}{2 \\ell^2}\\right)$。\n    核长度尺度：$\\ell = 0.25 \\, \\mathrm{\\AA}$。\n    正则化参数：$\\lambda = 10^{-6}$。\n    系数向量解：$\\boldsymbol{\\alpha} = (\\mathbf{K} + \\lambda \\mathbf{I})^{-1} \\mathbf{y}$。\n    预测函数：$\\widehat{E}(R) = \\sum_{j=1}^{N} \\alpha_j \\, K(R, R_j)$。\n\n6.  **评估任务**：\n    逐点测试：对于 $R_{\\mathrm{test}} \\in \\{ 2.4, 2.85, 3.4, 5.0 \\} \\, \\mathrm{\\AA}$，计算绝对误差 $\\varepsilon(R) \\equiv | \\widehat{E}(R) - E_{\\mathrm{vac}}(R) |$。\n    最小值点位置测试：在网格 $R \\in [2.2, 5.0] \\, \\mathrm{\\AA}$ 上（间距为 $\\Delta R = 0.001 \\, \\mathrm{\\AA}$），找到 $R_{\\min}^{\\mathrm{vac}} \\equiv \\operatorname*{arg\\,min}_{R} E_{\\mathrm{vac}}(R)$ 和 $R_{\\min}^{\\mathrm{ml}} \\equiv \\operatorname*{arg\\,min}_{R} \\widehat{E}(R)$，并计算偏差 $\\Delta R_{\\min} \\equiv R_{\\min}^{\\mathrm{ml}} - R_{\\min}^{\\mathrm{vac}}$。\n\n7.  **输出格式**：\n    单行列表 `[val1, val2, val3, val4, val5]`，结果四舍五入到3位小数。\n\n**步骤2：使用提取的已知信息进行验证**\n\n根据验证标准对问题进行评估。\n\n-   **科学上合理**：该问题是合理的。$E_{\\mathrm{vac}}(R)$ 的形式是分子间相互作用（泡利排斥和色散）的一个简化但标准的表示。用于区分体相和真空环境的环境稳定项 $\\Delta_{\\mathrm{env}}(R)$ 的概念具有物理动机。核岭回归是一种标准的非参数回归技术。整体设置正确地形式化了物理科学机器学习中的一个常见挑战：*分布偏移*或*域不匹配*问题，即模型在一个物理体系（周期性体相）的数据上进行训练，而在另一个物理体系（真空二聚体）上进行评估。\n\n-   **良构的**：该问题是良构的。核岭回归模型有唯一解。Gram 矩阵 $\\mathbf{K}$ 是半正定的。对于 $\\lambda = 10^{-6}  0$，正则化项 $\\lambda \\mathbf{I}$ 是正定的。因此，它们的和 $\\mathbf{K} + \\lambda \\mathbf{I}$ 是正定且可逆的，这保证了系数向量 $\\boldsymbol{\\alpha}$ 的唯一解。所有后续计算都是确定性的。\n\n-   **客观的**：问题陈述完全客观。所有术语都由精确的数学公式定义，所有参数都以具体的数值给出。没有歧义或主观性语言。\n\n问题陈述没有表现出任何列出的缺陷（例如，科学上不合理、不完整、矛盾、不可行或结构不良）。\n\n**步骤3：结论与行动**\n\n问题是**有效的**。将提供一个解决方案。\n\n**解题步骤**\n\n目标是构建一个一维机器学习势 $\\widehat{E}(R)$，该势在合成的“体相”数据上进行训练，并评估其对“真空”势能曲线 $E_{\\mathrm{vac}}(R)$ 的预测准确性。问题的核心在于训练数据分布（包含环境稳定项 $\\Delta_{\\mathrm{env}}(R)$）与目标测试分布（不包含该项）之间的差异。\n\n1.  **定义势能函数**：首先，我们实现势的解析形式。真空势 $E_{\\mathrm{vac}}(R)$ 定义为\n    $$\n    E_{\\mathrm{vac}}(R) = A_{\\mathrm{rep}} \\, e^{-b_{\\mathrm{rep}} R} - \\frac{C_6}{R^6}\n    $$\n    使用给定的参数 $A_{\\mathrm{rep}} = 295400 \\, \\mathrm{kJ/mol}$，$b_{\\mathrm{rep}} = 3.2 \\, \\mathrm{\\AA^{-1}}$ 和 $C_6 = 25000 \\, \\mathrm{kJ \\, \\AA^6/mol}$。\n    代表凝聚相环境效应的环境稳定项为\n    $$\n    \\Delta_{\\mathrm{env}}(R) = -A_{\\mathrm{env}} \\exp\\!\\left(-\\frac{(R - R_{\\mathrm{env}})^2}{2 s_{\\mathrm{env}}^2}\\right)\n    $$\n    其参数为 $A_{\\mathrm{env}} = 8.0 \\, \\mathrm{kJ/mol}$，$R_{\\mathrm{env}} = 2.75 \\, \\mathrm{\\AA}$ 和 $s_{\\mathrm{env}} = 0.15 \\, \\mathrm{\\AA}$。\n    训练数据是使用“体相”势生成的，它是这两个分量的和：\n    $$\n    E_{\\mathrm{bulk}}(R) = E_{\\mathrm{vac}}(R) + \\Delta_{\\mathrm{env}}(R)\n    $$\n    这个项 $\\Delta_{\\mathrm{env}}(R)$ 引入了一个以 $R = 2.75 \\, \\mathrm{\\AA}$ 为中心的稳定化效应（一个负能量贡献），这在物理上是液态水中氧-氧径向分布函数的第一个峰值的正确位置。机器学习模型将从训练数据中学习到这一特征。\n\n2.  **构建训练集**：生成一个训练集 $\\{ (R_i, y_i) \\}_{i=1}^{N}$。输入点 $R_i$ 是在区间 $[R_{\\min}, R_{\\max}] = [2.5, 3.0] \\, \\mathrm{\\AA}$ 内均匀分布的 $N=40$ 个间距。目标值是相应的“体相”能量，$y_i = E_{\\mathrm{bulk}}(R_i)$。这个训练区域 $[2.5, 3.0] \\, \\mathrm{\\AA}$ 很窄，并以环境稳定化最小值点 $R=2.75 \\, \\mathrm{\\AA}$ 为中心。\n\n3.  **训练核岭回归模型**：我们采用带有高斯核的核岭回归（KRR）来模拟势能面。高斯核由下式给出\n    $$\n    K(R, R') = \\exp\\!\\left(-\\frac{(R - R')^2}{2 \\ell^2}\\right)\n    $$\n    其长度尺度为 $\\ell = 0.25 \\, \\mathrm{\\AA}$。KRR模型将新点 $R$ 处的能量预测为以训练点 $R_j$ 为中心的核函数的线性组合：\n    $$\n    \\widehat{E}(R) = \\sum_{j=1}^{N} \\alpha_j K(R, R_j)\n    $$\n    系数 $\\boldsymbol{\\alpha} = (\\alpha_1, \\dots, \\alpha_N)^\\top$ 通过求解正则化线性系统得到：\n    $$\n    (\\mathbf{K} + \\lambda \\mathbf{I}) \\boldsymbol{\\alpha} = \\mathbf{y}\n    $$\n    这里，$\\mathbf{K}$ 是 $N \\times N$ 的 Gram 矩阵，其元素为 $K_{ij} = K(R_i, R_j)$，$\\mathbf{y} = (y_1, \\dots, y_N)^\\top$ 是训练目标的向量，$\\mathbf{I}$ 是单位矩阵，$\\lambda = 10^{-6}$ 是吉洪诺夫（Tikhonov）正则化参数。这个线性系统通过数值方法求解。\n\n4.  **评估模型**：训练好的模型 $\\widehat{E}(R)$ 现在将与真实的真空势 $E_{\\mathrm{vac}}(R)$ 进行比较评估，而不是它所训练的体相势。这测试了它在其训练分布之外的泛化能力。\n\n    a.  **逐点误差**：在四个指定的测试点 $R_{\\mathrm{test}} \\in \\{ 2.4, 2.85, 3.4, 5.0 \\} \\, \\mathrm{\\AA}$ 上计算绝对误差 $\\varepsilon(R) = | \\widehat{E}(R) - E_{\\mathrm{vac}}(R) |$。像 $R=2.4 \\, \\mathrm{\\AA}$ 和 $R=3.4 \\, \\mathrm{\\AA}$ 这样的点在训练区间 $[2.5, 3.0] \\, \\mathrm{\\AA}$ 之外，用于测试外推能力。点 $R=2.85 \\, \\mathrm{\\AA}$ 在区间内，用于测试内插能力。点 $R=5.0 \\, \\mathrm{\\AA}$ 用于测试长程行为。我们预计会出现显著误差，因为模型 $\\widehat{E}(R)$ 从 $\\Delta_{\\mathrm{env}}(R)$ 中学习到了稳定化特征，而这个特征在目标函数 $E_{\\mathrm{vac}}(R)$ 中是不存在的。\n\n    b.  **最小值点位置误差**：为了评估模型预测结构性质的能力，我们比较势能最小值的位置。我们定义一个从 $2.2 \\, \\mathrm{\\AA}$ 到 $5.0 \\, \\mathrm{\\AA}$ 的精细 $R$ 值网格，步长为 $\\Delta R = 0.001 \\, \\mathrm{\\AA}$。我们在这个网格上评估 $E_{\\mathrm{vac}}(R)$ 和 $\\widehat{E}(R)$，并找到它们各自的最小值点 $R_{\\min}^{\\mathrm{vac}}$ 和 $R_{\\min}^{\\mathrm{ml}}$。计算偏差 $\\Delta R_{\\min} = R_{\\min}^{\\mathrm{ml}} - R_{\\min}^{\\mathrm{vac}}$。由于训练数据包含一个以 $R = 2.75 \\, \\mathrm{\\AA}$ 为中心的人为稳定化效应，与 $E_{\\mathrm{vac}}(R)$ 的真实真空最小值相比，学习到的势 $\\widehat{E}(R)$ 的最小值会向这个值偏移，导致一个非零的 $\\Delta R_{\\min}$。\n\n最终的实现将通过数值方式执行这些步骤，并按要求格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and evaluates a 1D machine learning potential for a water dimer.\n    The model is trained on synthetic \"bulk\" data and tested against the \"vacuum\" potential,\n    demonstrating the effect of distributional shift.\n    \"\"\"\n\n    # --- 1. Definitions and Parameters ---\n\n    # Parameters for the vacuum potential E_vac(R)\n    A_rep = 295400.0  # kJ/mol\n    b_rep = 3.2      # A^-1\n    C6 = 25000.0     # kJ * A^6 / mol\n\n    # Parameters for the environmental stabilization term Delta_env(R)\n    A_env = 8.0      # kJ/mol\n    R_env = 2.75     # A\n    s_env = 0.15     # A\n\n    # Training set parameters\n    N = 40\n    R_min = 2.5      # A\n    R_max = 3.0      # A\n\n    # Kernel Ridge Regression parameters\n    length_scale = 0.25  # A\n    lambda_reg = 1e-6    # dimensionless\n\n    # --- 2. Potential Energy Functions ---\n\n    def E_vac(R):\n        \"\"\"Calculates the vacuum reference energy E_vac(R).\"\"\"\n        return A_rep * np.exp(-b_rep * R) - C6 / (R**6)\n\n    def Delta_env(R):\n        \"\"\"Calculates the environmental stabilization term Delta_env(R).\"\"\"\n        return -A_env * np.exp(-((R - R_env)**2) / (2 * s_env**2))\n\n    def E_bulk(R):\n        \"\"\"Calculates the 'bulk-labeled' training energy E_bulk(R).\"\"\"\n        return E_vac(R) + Delta_env(R)\n\n    # --- 3. Training Set Construction ---\n\n    R_train = np.linspace(R_min, R_max, N)\n    y_train = E_bulk(R_train)\n\n    # --- 4. Machine Learning Potential (Kernel Ridge Regression) ---\n\n    def gaussian_kernel(R1, R2, l):\n        \"\"\"\n        Computes the Gaussian kernel between two sets of points.\n        Handles broadcasting for vector-matrix operations.\n        \"\"\"\n        # Ensure R1 and R2 are numpy arrays for broadcasting\n        R1 = np.asarray(R1)\n        R2 = np.asarray(R2)\n        \n        # If R1 is a vector and R2 is a vector, we want a matrix of distances\n        if R1.ndim == 1 and R2.ndim == 1:\n            R1 = R1[:, np.newaxis] # Makes R1 a column vector\n        \n        dist_sq = (R1 - R2)**2\n        return np.exp(-dist_sq / (2 * l**2))\n\n    # Construct the Gram matrix K\n    K_matrix = gaussian_kernel(R_train, R_train, length_scale)\n\n    # Solve for the KRR coefficients alpha\n    # (K + lambda*I) * alpha = y  =>  alpha = solve(K + lambda*I, y)\n    A = K_matrix + lambda_reg * np.eye(N)\n    alpha = np.linalg.solve(A, y_train)\n\n    def E_hat(R):\n        \"\"\"\n        Predicts the energy using the trained KRR model.\n        R can be a single value or a numpy array.\n        \"\"\"\n        kernel_vec = gaussian_kernel(R, R_train, length_scale)\n        return kernel_vec @ alpha\n\n    # --- 5. Evaluation against Vacuum Reference ---\n\n    # a) Pointwise tests\n    R_test = np.array([2.4, 2.85, 3.4, 5.0])\n    E_hat_test = E_hat(R_test)\n    E_vac_test = E_vac(R_test)\n    errors = np.abs(E_hat_test - E_vac_test)\n    \n    # b) Minima-location test\n    R_grid_step = 0.001\n    R_grid = np.arange(2.2, 5.0 + R_grid_step, R_grid_step)\n\n    # Evaluate both potentials on the grid\n    E_vac_grid = E_vac(R_grid)\n    E_hat_grid = E_hat(R_grid)\n\n    # Find the arguments of the minima\n    idx_min_vac = np.argmin(E_vac_grid)\n    R_min_vac = R_grid[idx_min_vac]\n\n    idx_min_ml = np.argmin(E_hat_grid)\n    R_min_ml = R_grid[idx_min_ml]\n\n    # Calculate the signed deviation\n    delta_R_min = R_min_ml - R_min_vac\n\n    # --- 6. Final Output Formatting ---\n    results = [\n        errors[0],      # epsilon(2.4)\n        errors[1],      # epsilon(2.85)\n        errors[2],      # epsilon(3.4)\n        errors[3],      # epsilon(5.0)\n        delta_R_min     # Delta_R_min\n    ]\n\n    # Format output according to the problem specification\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "如何构建一个既准确又高效的训练集是开发机器学习势的核心难题。主动学习是一种强大的自动化策略，它允许在分子动力学模拟过程中“按需”生成新的训练数据，只在模型不确定时才调用昂贵的量子化学计算。这个高级练习  将指导你实现一个完整的“在线”学习循环，让你体验从不确定性评估到模型再训练的整个工作流程，这是构建稳健机器学习势的前沿方法。",
            "id": "2457458",
            "problem": "实现一个完整、可运行的程序，该程序模拟一个针对双原子分子的一维、约化单位分子动力学系统，同时为机器学习势 (MLP) 执行一个“在线”(on-the-fly) 主动学习循环。MLP 被训练用于近似一个参考量子力学 (QM) 势及其对应的力。当不确定性度量超过一个阈值时，模拟必须暂停，触发一次 QM 查询以获得精确的能量和力，更新训练集，重新训练 MLP，然后恢复动力学模拟。\n\n该系统是一个单一内坐标键长 $r(t)$，在约化单位下，其约化质量为 $\\mu = 1$。参考的量子力学势能是 Morse 势\n$$\nV_{\\mathrm{QM}}(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2,\n$$\n在约化单位下，常数为 $D_e = 0.20$、$a = 1.5$ 和 $r_e = 1.0$。相应的力是\n$$\nF_{\\mathrm{QM}}(r) = - \\frac{d V_{\\mathrm{QM}}}{dr}.\n$$\n\nMLP 必须是基于一个 4 次多项式基的线性模型。定义基\n$$\n\\phi(r) = \\begin{bmatrix} 1 \\\\ r \\\\ r^2 \\\\ r^3 \\\\ r^4 \\end{bmatrix}, \\quad \\phi'(r) = \\frac{d\\phi}{dr} = \\begin{bmatrix} 0 \\\\ 1 \\\\ 2 r \\\\ 3 r^2 \\\\ 4 r^3 \\end{bmatrix}.\n$$\n设模型参数向量为 $w \\in \\mathbb{R}^5$。预测的能量和力为\n$$\n\\hat{E}(r) = w^\\top \\phi(r), \\quad \\hat{F}(r) = - w^\\top \\phi'(r).\n$$\n训练数据由三元组 $(r_i, E_i, F_i)$ 组成，其中 $E_i = V_{\\mathrm{QM}}(r_i)$ 且 $F_i = F_{\\mathrm{QM}}(r_i)$。通过线性最小二乘法拟合 $w$，以最小化能量和力的残差平方和（两者权重相等），并使用强度为 $\\lambda = 10^{-8}$ 的 Tikhonov (ridge) 正则化。也就是说，构建一个线性系统，其中行由目标为 $E_i$ 的 $\\phi(r_i)$ 和目标为 $F_i$ 的 $-\\phi'(r_i)$ 组成，求解\n$$\n\\min_w \\left\\|A w - y\\right\\|_2^2 + \\lambda \\left\\|w\\right\\|_2^2.\n$$\n\n为进行不确定性估计，定义一个由两个模型组成的委员会。设 $w^{(A)}$ 使用当前训练集中的偶数索引成员进行训练（使用从零开始的索引），而 $w^{(B)}$ 使用奇数索引成员进行训练。在坐标 $r$ 处的不确定性度量是\n$$\nU(r) = \\left| \\hat{F}^{(A)}(r) - \\hat{F}^{(B)}(r) \\right|.\n$$\n此外，定义一个在当前完整訓練集上訓練的“生产”模型 $w^{(P)}$；这个模型用于在分子动力学积分过程中生成力。\n\n用位于 $r = r_e$ 和 $r = r_e + 0.20$ 的两个 QM 点初始化训练集。然后使用 velocity-Verlet 方案对质量为 $\\mu = 1$ 的位置 $r$ 和速度 $v$ 执行 $N$ 步的分子动力学模拟，时间步长为 $\\Delta t$：\n$$\nv_{n+\\frac{1}{2}} = v_n + \\frac{\\Delta t}{2} \\, a(r_n), \\quad r_{n+1} = r_n + \\Delta t \\, v_{n+\\frac{1}{2}}, \\quad v_{n+1} = v_{n+\\frac{1}{2}} + \\frac{\\Delta t}{2} \\, a(r_{n+1}),\n$$\n其中 $a(r) = \\hat{F}^{(P)}(r) / \\mu$ 是根据当前生产模型计算出的加速度。在每一步中，在计算用于积分的力之前，评估 $U(r_n)$。如果 $U(r_n)  \\tau$ 且到目前为止的 QM 查询次数严格小于预算 $B$，则在 $r_n$ 处执行一次 QM 查询，方法是将 $(r_n, V_{\\mathrm{QM}}(r_n), F_{\\mathrm{QM}}(r_n))$ 添加到训练集中，重新训练委员会模型和生产模型，并将 QM 查询计数器加一。然后使用更新后的生产模型继续进行积分。\n\n在 $N$ 步之后，使用最终的生产模型，沿着访问过的轨迹位置 $\\{r_1, r_2, \\dots, r_N\\}$ 评估平均绝对力误差：\n$$\n\\mathrm{MAE} = \\frac{1}{N} \\sum_{k=1}^{N} \\left| \\hat{F}^{(P)}(r_k) - F_{\\mathrm{QM}}(r_k) \\right|.\n$$\n\n所有量都采用约化单位。以约化力单位（能量单位/长度单位）表示平均绝对误差。QM 查询计数是无量纲的。\n\n您的程序必须精确实现上述规范，并运行以下测试套件。每个测试用例都是一个元组 $(N, \\Delta t, \\tau, B, r_0, v_0)$：\n\n- 测试 $1$：$N = 200$，$\\Delta t = 0.01$，$\\tau = 0.05$，$B = 10$，$r_0 = 1.30$，$v_0 = 0.00$。\n- 测试 $2$：$N = 200$，$\\Delta t = 0.01$，$\\tau = 1.00$，$B = 10$，$r_0 = 1.30$，$v_0 = 0.00$。\n- 测试 $3$：$N = 200$，$\\Delta t = 0.01$，$\\tau = 0.005$，$B = 3$，$r_0 = 1.30$，$v_0 = 0.00$。\n- 测试 $4$：$N = 100$，$\\Delta t = 0.01$，$\\tau = 0.02$，$B = 10$，$r_0 = 2.00$，$v_0 = 0.00$。\n\n对于每个测试用例，计算两个值：触发的 QM 查询总数 $Q$（不包括两个初始种子点）和上面定义的平均绝对力误差 $\\mathrm{MAE}$。您的程序应生成单行输出，其中包含按顺序排列的四个测试的这些结果的扁平列表：\n$$\n\\left[Q_1, \\mathrm{MAE}_1, Q_2, \\mathrm{MAE}_2, Q_3, \\mathrm{MAE}_3, Q_4, \\mathrm{MAE}_4\\right].\n$$\n以所示格式精确打印一行，值之间用逗号分隔，并用方括号括起来。不涉及角度或百分比；除了此处说明的约化单位外，不需要进行其他单位转换。",
            "solution": "问题陈述具有科学依据、提法恰当且客观。它为分子动力学的机器学习势领域中的一个计算任务提供了完整的规范。所有必需的参数、初始条件、算法和评估指标都得到了明确的定义。因此，该问题被认为是有效的。\n\n解决方案要求实现一个一维分子动力学 (MD) 模拟，该模拟包含一个用于机器学习势 (MLP) 的“在线”主动学习程序。该系统由一个约化质量为 $\\mu = 1$ 的单个粒子沿坐标 $r$ 运动组成。MLP 被训练用于再现一个参考量子力学 (QM) 勢能面。\n\n实现的核心组件如下：\n\n1.  **参考 QM 模型**：真实的势能由 Morse 勢给出，$V_{\\mathrm{QM}}(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2$。在约化单位下，参数为 $D_e = 0.20$，$a = 1.5$ 和 $r_e = 1.0$。相应的解析力是势的负梯度，即 $F_{\\mathrm{QM}}(r) = - \\frac{d V_{\\mathrm{QM}}}{dr} = -2 a D_e (1 - e^{-a (r - r_e)}) e^{-a(r-r_e)}$。这些函数作为训练 MLP 和评估其准确性的基准真相。\n\n2.  **机器学习势 (MLP)**：MLP 是一个由 4 次多项式基构建的线性模型。在给定位置 $r$ 处的基向量是 $\\phi(r) = \\begin{bmatrix} 1  r  r^2  r^3  r^4 \\end{bmatrix}^\\top$。MLP 将能量预测为这些基函数的线性组合：$\\hat{E}(r) = w^\\top \\phi(r)$，其中 $w \\in \\mathbb{R}^5$ 是模型权重的向量。此类势的一个关键特征是解析可微性，这允许直接计算力，即所谓的力匹配 (force-matching)。预测的力为 $\\hat{F}(r) = - \\frac{d\\hat{E}}{dr} = - w^\\top \\phi'(r)$，其中 $\\phi'(r) = \\frac{d\\phi}{dr} = \\begin{bmatrix} 0  1  2r  3r^2  4r^3 \\end{bmatrix}^\\top$。\n\n3.  **MLP 训练**：通过最小化一个包含一组训练点 $\\{(r_i, E_i, F_i)\\}$ 的能量和力误差的损失函数来优化权重向量 $w$，其中 $E_i = V_{\\mathrm{QM}}(r_i)$ 且 $F_i = F_{\\mathrm{QM}}(r_i)$。该优化问题是一个带 Tikhonov (ridge) 正则化的线性最小二乘拟合，表述为：\n    $$\n    \\min_w \\left\\|A w - y\\right\\|_2^2 + \\lambda \\left\\|w\\right\\|_2^2\n    $$\n    在这里，矩阵 $A$ 和向量 $y$是通过堆叠每个训练点的贡献来构建的。对于一组 $M$ 个训练点，$A$ 是一个 $2M \\times 5$ 的矩阵，其中前 $M$ 行是 $\\phi(r_i)^\\top$，后 $M$ 行是 $-\\phi'(r_i)^\\top$。向量 $y$ 是一个 $2M$ 维向量，包含目标能量 $E_i$ 和其后的目标力 $F_i$。正则化强度给定为 $\\lambda = 10^{-8}$。这是一个标准的 ridge 回归问题，其解析解为 $w = (A^\\top A + \\lambda I)^{-1} A^\\top y$，其中 $I$ 是 $5 \\times 5$ 的单位矩阵。这个线性系统通过数值方法求解。\n\n4.  **主动学习和不确定性量化**：模拟采用主动学习策略，通过仅在模型不确定的区域添加新的训练点来有效提高 MLP 的准确性。不确定性通过一个由两个模型组成的委员会来估计，其权重分别为 $w^{(A)}$ 和 $w^{(B)}$。模型 $w^{(A)}$ 在偶数索引的训练数据子集上进行训练（使用从零开始的索引），而模型 $w^{(B)}$ 在奇数索引的子集上进行训练。在位置 $r$ 处的不确定性度量定义为两个委员会模型预测的力之间的差异大小：$U(r) = \\left| \\hat{F}^{(A)}(r) - \\hat{F}^{(B)}(r) \\right|$。第三个“生产”模型，其权重为 $w^{(P)}$，在整个训练集上进行训练，并用于传播动力学。\n\n5.  **分子动力学模拟**：系统的轨迹使用 velocity-Verlet 算法进行积分。给定时间步 $n$ 的位置 $r_n$ 和速度 $v_n$，第 $n+1$ 步的状态计算如下：\n    $$\n    \\begin{aligned}\n    v_{n+\\frac{1}{2}} = v_n + \\frac{\\Delta t}{2} \\frac{\\hat{F}^{(P)}(r_n)}{\\mu} \\\\\n    r_{n+1} = r_n + \\Delta t \\, v_{n+\\frac{1}{2}} \\\\\n    v_{n+1} = v_{n+\\frac{1}{2}} + \\frac{\\Delta t}{2} \\frac{\\hat{F}^{(P)}(r_{n+1})}{\\mu}\n    \\end{aligned}\n    $$\n    其中 $\\Delta t$ 是时间步长，加速度由生产模型的力 $\\hat{F}^{(P)}$ 推導得出。\n\n完整的模拟过程如下：\n- 训练集用位于 $r=r_e=1.0$ 和 $r=r_e+0.20=1.2$ 的两个 QM 数据点进行初始化。三个模型（$w^{(A)}$、$w^{(B)}$、$w^{(P)}$）在此初始集上进行训练。\n- 从 $(r_0, v_0)$ 开始的 MD 模拟运行 $N$ 步。\n- 在每一步 $n$ 开始时，当系统处于位置 $r_n$ 时，计算不确定性 $U(r_n)$。\n- 如果 $U(r_n)$ 大于阈值 $\\tau$ 且触发的 QM 查询次数小于预算 $B$，则在 $r_n$ 处生成一个新的 QM 数据点并添加到训练集中。然后使用更新后的集合重新训练所有三个模型。触发的查询计数 $Q$ 会增加。\n- 然后, velocity-Verlet 算法使用来自（可能已更新的）生产模型 $\\hat{F}^{(P)}$ 的力将系统传播到下一个状态。新的位置 $r_{n+1}$ 被存储下来。\n- 在 $N$ 步之后，模拟结束。计算生成轨迹 $\\{r_1, r_2, \\dots, r_N\\}$ 上的力的平均绝对误差 (MAE)。这是通过将每个存储位置 $r_k$ 的*最终*生产模型力 $\\hat{F}^{(P)}(r_k)$ 与真实 QM 力 $F_{\\mathrm{QM}}(r_k)$ 进行比较来完成的。\n- 每个测试用例的两个输出是触发的 QM 查询总数 $Q$ 和最终的 MAE。\n\n提供的 Python 程序实现了这整个过程，遍历指定的测试用例并生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the active learning MD simulation for all test cases.\n    \"\"\"\n    \n    # --- Global Constants in Reduced Units ---\n    D_e = 0.20\n    a_morse = 1.5  # Renamed to avoid conflict with acceleration 'a'\n    r_e = 1.0\n    mu = 1.0\n    lambda_reg = 1e-8\n    \n    # --- Quantum Mechanical (QM) Ground Truth ---\n    def V_QM(r):\n        \"\"\"Calculates the Morse potential energy.\"\"\"\n        return D_e * (1.0 - np.exp(-a_morse * (r - r_e)))**2\n\n    def F_QM(r):\n        \"\"\"Calculates the analytical force from the Morse potential.\"\"\"\n        exp_term = np.exp(-a_morse * (r - r_e))\n        return -2.0 * a_morse * D_e * (1.0 - exp_term) * exp_term\n\n    # --- Machine Learning Potential (MLP) Module ---\n    def get_phi(r):\n        \"\"\"Returns the polynomial basis vector.\"\"\"\n        return np.array([1.0, r, r**2, r**3, r**4])\n\n    def get_phi_prime(r):\n        \"\"\"Returns the derivative of the polynomial basis vector.\"\"\"\n        return np.array([0.0, 1.0, 2.0*r, 3.0*r**2, 4.0*r**3])\n\n    def train(r_train, lam_reg):\n        \"\"\"\n        Trains the linear MLP model using ridge regression on both energy and forces.\n        \"\"\"\n        num_points = len(r_train)\n        if num_points == 0:\n            return np.zeros(5)\n\n        A = np.zeros((2 * num_points, 5))\n        y = np.zeros(2 * num_points)\n\n        for i, r_i in enumerate(r_train):\n            E_i = V_QM(r_i)\n            F_i = F_QM(r_i)\n            \n            A[i, :] = get_phi(r_i)\n            A[num_points + i, :] = -get_phi_prime(r_i)\n            \n            y[i] = E_i\n            y[num_points + i] = F_i\n\n        AtA = A.T @ A\n        AtA_reg = AtA + lam_reg * np.identity(5)\n        Aty = A.T @ y\n        \n        # Solve the linear system (A^T A + lambda I) w = A^T y\n        w = linalg.solve(AtA_reg, Aty, assume_a='sym')\n        return w\n\n    def predict_F(r, w):\n        \"\"\"Predicts the force using the trained MLP model.\"\"\"\n        return -w.T @ get_phi_prime(r)\n\n    def run_simulation(N, dt, tau, B, r0, v0):\n        \"\"\"\n        Runs a single active learning MD simulation for a given set of parameters.\n        \"\"\"\n        # 1. Initialize training set and query counter\n        training_set_r = [r_e, r_e + 0.20]\n        qm_queries_triggered = 0\n\n        # 2. Initial model training\n        w_P = train(training_set_r, lambda_reg)\n        w_A = train(training_set_r[0::2], lambda_reg)\n        w_B = train(training_set_r[1::2], lambda_reg)\n\n        r_current = r0\n        v_current = v0\n        r_trajectory = []\n\n        # 3. Main MD loop\n        for _ in range(N):\n            r_n = r_current\n\n            # 3a. Active Learning: Check uncertainty and retrain if needed\n            F_A = predict_F(r_n, w_A)\n            F_B = predict_F(r_n, w_B)\n            uncertainty = abs(F_A - F_B)\n\n            if uncertainty > tau and qm_queries_triggered  B:\n                training_set_r.append(r_n)\n                qm_queries_triggered += 1\n                \n                # Retrain all three models with the new data point\n                w_P = train(training_set_r, lambda_reg)\n                w_A = train(training_set_r[0::2], lambda_reg)\n                w_B = train(training_set_r[1::2], lambda_reg)\n\n            # 3b. Velocity-Verlet Integration\n            # First half-step for velocity\n            force_n = predict_F(r_n, w_P)\n            a_n = force_n / mu\n            v_half = v_current + 0.5 * dt * a_n\n\n            # Full-step for position\n            r_next = r_current + dt * v_half\n            r_trajectory.append(r_next)\n            \n            # Second half-step for velocity\n            force_next = predict_F(r_next, w_P)\n            a_next = force_next / mu\n            v_next = v_half + 0.5 * dt * a_next\n            \n            # Update state for the next iteration\n            r_current = r_next\n            v_current = v_next\n        \n        # 4. Final Evaluation: Calculate Mean Absolute Error (MAE)\n        total_abs_error = 0.0\n        for r_k in r_trajectory:\n            f_pred = predict_F(r_k, w_P) # Use final production model\n            f_true = F_QM(r_k)\n            total_abs_error += abs(f_pred - f_true)\n            \n        mae = total_abs_error / N\n        \n        return qm_queries_triggered, mae\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200, 0.01, 0.05, 10, 1.30, 0.00),\n        (200, 0.01, 1.00, 10, 1.30, 0.00),\n        (200, 0.01, 0.005, 3, 1.30, 0.00),\n        (100, 0.01, 0.02, 10, 2.00, 0.00),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dt, tau, B, r0, v0 = case\n        q, mae = run_simulation(N, dt, tau, B, r0, v0)\n        results.extend([q, mae])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}