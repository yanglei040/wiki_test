{
    "hands_on_practices": [
        {
            "introduction": "理论知识只有通过实践才能真正内化。本节的动手实践将带你亲手构建、分析和解读反应路径。第一个练习旨在揭示内禀反应坐标（IRC）定义的核心——质量加权。通过这个练习 ，你将看到，在势能面上沿着最陡峭的方向下降并不足以正确描述化学反应。你将通过编程实现一个正确的（质量加权）和一个错误的（非质量加权）路径追踪算法，并亲眼见证忽略原子质量如何导致计算走向完全错误的化学产物，从而深刻理解为何IRC必须在质量加权坐标系中定义。",
            "id": "2461314",
            "problem": "给定一个定义在坐标 $\\mathbf{r}=(x,y)$ 上的二维势能面 (PES)，它由以下标量场定义：\n$$\nV(x,y) \\;=\\; A\\,x^4 \\;-\\; B\\,x^2 \\;+\\; C\\,y^2 \\;+\\; D\\,x\\,y,\n$$\n其中 $A>0$，$B>0$，$C>0$ 为正参数，$D$ 为实数耦合参数。考虑一个具有两个自由度的系统，其质量矩阵为对角矩阵 $\\mathbf{M}=\\mathrm{diag}(m_1,m_2)$，其中 $m_1>0$ 且 $m_2>0$。\n\n对于内禀反应坐标 (IRC)，使用其第一性原理定义：正确的 IRC 是 $V$ 在质量加权坐标 $\\mathbf{R}=\\mathbf{M}^{1/2}\\mathbf{r}$ 中的最速下降流，即：\n$$\n\\frac{d\\mathbf{R}}{ds} \\;=\\; - \\nabla_{\\mathbf{R}} V(\\mathbf{R}),\n$$\n其中 $s$ 是一个类弧长路径参数。等价地，在笛卡尔坐标中，该流为：\n$$\n\\frac{d\\mathbf{r}}{ds} \\;=\\; - \\mathbf{M}^{-1}\\,\\nabla_{\\mathbf{r}} V(\\mathbf{r}).\n$$\n一个有缺陷的算法忽略了质量加权，而是遵循非质量加权的笛卡尔最速下降流：\n$$\n\\frac{d\\mathbf{r}}{ds} \\;=\\; - \\nabla_{\\mathbf{r}} V(\\mathbf{r}).\n$$\n\n在鞍点 $(x,y)=(0,0)$ 处，定义笛卡尔坐标下的Hessian矩阵 $\\mathbf{H}=\\nabla^2_{\\mathbf{r}} V\\big|_{(0,0)}$ 和质量加权的Hessian矩阵 $\\mathbf{H}_{\\mathrm{mw}}=\\mathbf{M}^{-1/2}\\,\\mathbf{H}\\,\\mathbf{M}^{-1/2}$。对于初始条件，从 $(0,0)$ 点沿相应Hessian矩阵的不稳定简正模式（与唯一负特征值相关联的特征向量）位移一个微小量 $\\varepsilon>0$，并遵循以下取向约定：\n- 对于正确的 IRC 流，对质量加权的不稳定模式进行定向，使其在笛卡尔坐标中的 $x$ 分量为正。\n- 对于有缺陷的流，对非加权的不稳定模式进行定向，使其 $y$ 分量为正。\n\n让轨迹在每种流下从各自的初始条件出发，向其终点吸引子（稳定临界点）演化。根据终点吸引子所接近的解析极小值点对其进行分类。给定PES的两个对称相关的极小值点位于：\n$$\nx_{\\min}^\\star \\;=\\; \\pm \\sqrt{\\frac{2B + \\frac{D^2}{2C}}{4A}}, \n\\qquad\ny_{\\min}^\\star \\;=\\; -\\frac{D}{2C}\\,x_{\\min}^\\star,\n$$\n条件是 $2B + \\frac{D^2}{2C} > 0$（下面的测试参数保证了此条件成立）。将终点吸引子的标签定义为：如果它（在欧几里得距离上）更接近 $x_{\\min}^\\star>0$ 的极小值点，则为 $+1$；如果更接近 $x_{\\min}^\\star<0$ 的极小值点，则为 $-1$。\n\n对于下方的每个测试用例，判断有缺陷的流是否与正确的 IRC 流连接到具有相同标签的极小值点。对于每个测试用例，如果该有缺陷的流未能连接到与正确的 IRC 流具有相同标签的极小值点，则输出布尔值 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n使用以下参数集测试套件 $(A,B,C,D,m_1,m_2)$：\n- 测试 1： $(A,B,C,D,m_1,m_2) = (1.0, 1.0, 1.0, 0.5, 1.0, 1.0)$。\n- 测试 2： $(A,B,C,D,m_1,m_2) = (1.0, 1.0, 0.5, -1.0, 1.0, 50.0)$。\n- 测试 3： $(A,B,C,D,m_1,m_2) = (1.0, 1.0, 2.0, 0.2, 5.0, 0.5)$。\n\n约定和要求：\n- 对两种流使用相同的微小位移大小 $\\varepsilon=10^{-3}$。\n- 每种流的初始点为 $(x,y)=\\varepsilon\\,\\mathbf{v}$，其中 $\\mathbf{v}$ 是以笛卡尔坐标表示、经过适当定向的不稳定模式，在用 $\\varepsilon$ 缩放之前已归一化为单位长度。\n- 整个程序的输出应为单行，其中包含一个按测试顺序排列的、含有三个布尔值的列表，格式化为不含空格的Python风格列表，例如：“[False,True,False]”。\n\n您的程序应精确地产生一行输出，其中包含所有测试用例的结果，形式为按给定顺序排列的、用方括号括起来的逗号分隔列表：$[\\mathrm{result\\_1},\\mathrm{result\\_2},\\mathrm{result\\_3}]$。",
            "solution": "该问题要求在二维势能面 (PES) $V(x,y)$ 上比较两条动力学路径。第一条路径是真实的内禀反应坐标 (IRC)，定义为在质量加权坐标中的最速下降路径。第二条是一个有缺陷的近似，它遵循非质量加权的笛卡尔坐标中的最速下降路径。我们必须判断这两条从鞍点 $(0,0)$ 附近出发的路径，是否终止于同一个对称相关的势能极小值点。\n\n势能面由下式给出：\n$$ V(x,y) = A\\,x^4 - B\\,x^2 + C\\,y^2 + D\\,x\\,y $$\n其中 $A, B, C$ 为正参数。该系统具有两个自由度，坐标为 $\\mathbf{r} = (x,y)$，质量矩阵为对角矩阵 $\\mathbf{M} = \\mathrm{diag}(m_1, m_2)$。\n\n首先，我们建立这两种流的运动方程。势在笛卡尔坐标中的梯度为：\n$$ \\nabla_{\\mathbf{r}} V(\\mathbf{r}) = \\begin{pmatrix} \\frac{\\partial V}{\\partial x} \\\\ \\frac{\\partial V}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 4Ax^3 - 2Bx + Dy \\\\ 2Cy + Dx \\end{pmatrix}. $$\n正确的 IRC 流由以下微分方程控制：\n$$ \\frac{d\\mathbf{r}}{ds} = - \\mathbf{M}^{-1} \\nabla_{\\mathbf{r}} V(\\mathbf{r}), $$\n其中 $s$ 是一个路径参数，且 $\\mathbf{M}^{-1} = \\mathrm{diag}(1/m_1, 1/m_2)$。\n有缺陷的流遵循更简单的方程：\n$$ \\frac{d\\mathbf{r}}{ds} = - \\nabla_{\\mathbf{r}} V(\\mathbf{r}). $$\n\n这些流的初始条件由从鞍点 $\\mathbf{r}_0 = (0,0)$ 沿相关Hessian矩阵的不稳定简正模式的无穷小位移定义。\n\n鞍点处的笛卡尔Hessian矩阵 $\\mathbf{H}$ 为：\n$$ \\mathbf{H} = \\nabla^2_{\\mathbf{r}} V\\big|_{(0,0)} = \\begin{pmatrix} \\frac{\\partial^2 V}{\\partial x^2}  \\frac{\\partial^2 V}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 V}{\\partial y \\partial x}  \\frac{\\partial^2 V}{\\partial y^2} \\end{pmatrix}_{\\mathbf{r}=(0,0)} = \\begin{pmatrix} -2B  D \\\\ D  2C \\end{pmatrix}. $$\n$\\mathbf{H}$ 的行列式为 $-4BC - D^2$，对于 $B, C > 0$ 该值严格为负。这保证了一个负特征值和一个正特征值，分别对应一个不稳定模式和一个稳定模式。有缺陷流的初始条件由 $\\mathbf{H}$ 对应其负特征值的特征向量决定。设该特征向量为 $\\mathbf{v}_{\\mathrm{faulty}}$。它被归一化为单位长度，并定向使其 $y$ 分量为正，再用 $\\varepsilon = 10^{-3}$ 缩放得到初始位置 $\\mathbf{r}_{0, \\mathrm{faulty}} = \\varepsilon \\mathbf{v}_{\\mathrm{faulty}}$。\n\n质量加权的Hessian矩阵 $\\mathbf{H}_{\\mathrm{mw}}$ 定义为：\n$$ \\mathbf{H}_{\\mathrm{mw}} = \\mathbf{M}^{-1/2} \\mathbf{H} \\mathbf{M}^{-1/2} = \\begin{pmatrix} \\frac{-2B}{m_1}  \\frac{D}{\\sqrt{m_1 m_2}} \\\\ \\frac{D}{\\sqrt{m_1 m_2}}  \\frac{2C}{m_2} \\end{pmatrix}, $$\n其中 $\\mathbf{M}^{-1/2} = \\mathrm{diag}(1/\\sqrt{m_1}, 1/\\sqrt{m_2})$。$\\mathbf{H}_{\\mathrm{mw}}$ 的行列式为 $(-4BC - D^2)/(m_1 m_2)$，该值也总是负的，保证了存在一个唯一的不稳定模式。正确流的初始条件由 $\\mathbf{H}_{\\mathrm{mw}}$ 对应其负特征值的特征向量决定。设该特征向量（在质量加权坐标中）为 $\\mathbf{u}_{\\mathrm{correct}}$。它必须通过 $\\mathbf{v}_{\\mathrm{correct}} = \\mathbf{M}^{-1/2} \\mathbf{u}_{\\mathrm{correct}}$ 转换回笛卡尔坐标。这个笛卡尔向量随后被归一化，并定向使其 $x$ 分量为正，再用 $\\varepsilon$ 缩放得到初始位置 $\\mathbf{r}_{0, \\mathrm{correct}} = \\varepsilon \\mathbf{v}_{\\mathrm{correct}}$。\n\n在微分方程（ODEs）和初始条件定义好之后，我们沿着路径参数 $s$ 对两个系统进行数值积分，直到它们收敛到PES的一个稳定临界点，即 $\\nabla_{\\mathbf{r}} V = \\mathbf{0}$ 的点。这些点就是势能极小值点。对于此任务，我们使用一个鲁棒的数值ODE求解器 `scipy.integrate.solve_ivp`。\n\n势 $V(x,y)$ 有两个极小值点，位于 $(\\pm x_{\\min}^\\star, y_{\\min, \\pm}^\\star)$，其中：\n$$ x_{\\min}^\\star = \\sqrt{\\frac{2B + D^2/(2C)}{4A}}, \\quad y_{\\min}^\\star = -\\frac{D}{2C} x_{\\min}^\\star. $$\n我们将 $x$ 坐标为正的极小值点记为 $\\mathbf{r}_{\\min, +1}$，将 $x$ 坐标为负的极小值点记为 $\\mathbf{r}_{\\min, -1}$。每条流的终点 $\\mathbf{r}_{\\mathrm{final}}$ 通过分配标签来进行分类：如果它在欧几里得距离上更接近 $\\mathbf{r}_{\\min, +1}$，则标签为 $+1$；如果更接近 $\\mathbf{r}_{\\min, -1}$，则标签为 $-1$。\n\n对于每组参数 $(A, B, C, D, m_1, m_2)$，我们执行以下步骤：\n1.  计算 $\\mathbf{H}$ 和 $\\mathbf{H}_{\\mathrm{mw}}$。\n2.  在笛卡尔坐标中找到不稳定特征向量 $\\mathbf{v}_{\\mathrm{faulty}}$ 和 $\\mathbf{v}_{\\mathrm{correct}}$，并应用指定的取向规则。\n3.  确定初始位置 $\\mathbf{r}_{0, \\mathrm{faulty}}$ 和 $\\mathbf{r}_{0, \\mathrm{correct}}$。\n4.  对两种流的ODE进行数值求解，以找到终点 $\\mathbf{r}_{\\mathrm{final, faulty}}$ 和 $\\mathbf{r}_{\\mathrm{final, correct}}$。\n5.  计算两个极小值点的位置 $\\mathbf{r}_{\\min, +1}$ 和 $\\mathbf{r}_{\\min, -1}$。\n6.  通过比较终点到两个极小值点的距离来分配标签 $L_{\\mathrm{faulty}}$ 和 $L_{\\mathrm{correct}}$。\n7.  该测试用例的结果是表达式 $L_{\\mathrm{faulty}} \\neq L_{\\mathrm{correct}}$ 的布尔值。\n\n这整个逻辑在一个Python脚本中实现，该脚本遍历所提供的测试用例，并生成最终的布尔值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (A,   B,   C,   D,   m1,  m2)\n        (1.0, 1.0, 1.0,  0.5, 1.0,  1.0),\n        (1.0, 1.0, 0.5, -1.0, 1.0, 50.0),\n        (1.0, 1.0, 2.0,  0.2, 5.0,  0.5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_case(params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_case(params):\n    \"\"\"\n    Solves a single test case.\n    \n    For each test case, determines whether the faulty flow fails to connect to the\n    same labeled minimum as the correct IRC flow. Returns True if they fail\n    (connect to different minima), False otherwise.\n    \"\"\"\n    A, B, C, D, m1, m2 = params\n    epsilon = 1e-3\n\n    # =========================================================================\n    # Step 1: Define PES, gradient, and analytical minima locations\n    # =========================================================================\n    def grad_V(r):\n        x, y = r\n        gx = 4 * A * x**3 - 2 * B * x + D * y\n        gy = 2 * C * y + D * x\n        return np.array([gx, gy])\n\n    x_min_sq_val = (2 * B + D**2 / (2 * C)) / (4 * A)\n    x_min_pos = np.sqrt(x_min_sq_val)\n    y_min_pos = -D / (2 * C) * x_min_pos\n    min_p1 = np.array([x_min_pos, y_min_pos])\n    min_m1 = -min_p1\n\n    # =========================================================================\n    # Step 2: Determine initial conditions for both flows\n    # =========================================================================\n    H = np.array([[-2 * B, D], [D, 2 * C]])\n    \n    # --- Faulty (unweighted) flow initial condition ---\n    eigvals_faulty, eigvecs_faulty = np.linalg.eig(H)\n    unstable_idx_faulty = np.argmin(eigvals_faulty)\n    v_faulty = eigvecs_faulty[:, unstable_idx_faulty].real\n\n    v_faulty /= np.linalg.norm(v_faulty)\n    if v_faulty[1]  0:\n        v_faulty = -v_faulty\n    \n    r0_faulty = epsilon * v_faulty\n\n    # --- Correct (mass-weighted) IRC flow initial condition ---\n    M_inv_sqrt = np.diag([1/np.sqrt(m1), 1/np.sqrt(m2)])\n    H_mw = M_inv_sqrt @ H @ M_inv_sqrt\n    \n    eigvals_mw, eigvecs_mw = np.linalg.eig(H_mw)\n    unstable_idx_mw = np.argmin(eigvals_mw)\n    u_correct = eigvecs_mw[:, unstable_idx_mw].real # Eigenvector in mass-weighted coords\n\n    v_correct = M_inv_sqrt @ u_correct # Convert to Cartesian coords\n    \n    v_correct /= np.linalg.norm(v_correct)\n    if v_correct[0]  0:\n        v_correct = -v_correct\n    \n    r0_correct = epsilon * v_correct\n\n    # =========================================================================\n    # Step 3: Simulate the flows using an ODE solver\n    # =========================================================================\n    def ode_faulty(t, r):\n        return -grad_V(r)\n    \n    M_inv = np.diag([1/m1, 1/m2])\n    def ode_correct(t, r):\n        return -M_inv @ grad_V(r)\n    \n    t_span = [0, 500]\n    t_eval = [t_span[1]]\n    \n    # We only care about the final state, so we evaluate only there.\n    # High tolerance is used for accuracy near the minimum.\n    sol_faulty = solve_ivp(ode_faulty, t_span, r0_faulty, method='RK45', \n                           t_eval=t_eval, atol=1e-9, rtol=1e-9)\n    r_final_faulty = sol_faulty.y[:, -1]\n\n    sol_correct = solve_ivp(ode_correct, t_span, r0_correct, method='RK45', \n                            t_eval=t_eval, atol=1e-9, rtol=1e-9)\n    r_final_correct = sol_correct.y[:, -1]\n\n    # =========================================================================\n    # Step 4: Classify the terminal attractors\n    # =========================================================================\n    def get_label(r_final):\n        \"\"\"Assigns label +1 or -1 based on proximity to analytical minima.\"\"\"\n        dist_to_p1 = np.linalg.norm(r_final - min_p1)\n        dist_to_m1 = np.linalg.norm(r_final - min_m1)\n        return 1 if dist_to_p1  dist_to_m1 else -1\n\n    label_faulty = get_label(r_final_faulty)\n    label_correct = get_label(r_final_correct)\n\n    # =========================================================================\n    # Step 5: Compare labels and return the boolean result\n    # =========================================================================\n    return label_faulty != label_correct\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "理解了质量加权的重要性之后，我们来亲手构建一个真正的内禀反应坐标。这个练习  将指导你为一个著名的化学过程——氨分子的伞形翻转——实现一个IRC追踪算法。你将使用一个简化的模型势能面，通过数值积分方法追踪从过渡态出发的最陡下降路径，并分析所得路径的一个关键几何性质：曲率。这个过程将巩固你对追踪反应路径所涉及的实际步骤的理解。",
            "id": "2461292",
            "problem": "您将实现一个程序，使用简化的双模模型计算氨的伞形反转的内禀反应坐标 (IRC) 的近似值，并以质量加权坐标对 IRC 是直的还是弯曲的进行分类。IRC 被定义为在质量加权笛卡尔坐标中表示时，势能面上的最速下降路径。您的实现必须基于下文指定的第一性原理和经过充分检验的定义，并生成单行输出来总结一个小测试套件的分类结果。\n\n使用的基本原理和定义：\n- 在简化模型中，使用两个广义坐标：$x$ 表示反转（伞形）坐标，$y$ 表示耦合的全对称伸缩坐标。势能面被指定为\n$$\nV(x,y) = A\\,(x^2 - x_0^2)^2 + \\tfrac{1}{2}k\\,y^2 + \\alpha\\,x^2\\,y,\n$$\n其中 $A$，$x_0$，$k$ 和 $\\alpha$ 是实常数。\n- 设质量矩阵为对角矩阵，其对角元分别为对应于 $x$ 和 $y$ 的 $m_x$ 和 $m_y$。定义质量加权坐标 $\\mathbf{Q} = (Q_x,Q_y)$ 为 $Q_x = \\sqrt{m_x}\\,x$ 和 $Q_y = \\sqrt{m_y}\\,y$。\n- 根据链式法则，质量加权梯度定义为 $\\nabla_{\\mathbf{Q}} V = \\left(\\frac{\\partial V}{\\partial Q_x}, \\frac{\\partial V}{\\partial Q_y}\\right) = \\left(\\frac{1}{\\sqrt{m_x}}\\frac{\\partial V}{\\partial x}, \\frac{1}{\\sqrt{m_y}}\\frac{\\partial V}{\\partial y}\\right)$。\n- IRC 是在 $\\mathbf{Q}$ 空间中的最速下降路径，由质量加权弧长 $s$ 参数化，并满足单位速率下降：\n$$\n\\frac{d\\mathbf{Q}}{ds} = -\\frac{\\nabla_{\\mathbf{Q}} V(\\mathbf{Q})}{\\lVert \\nabla_{\\mathbf{Q}} V(\\mathbf{Q})\\rVert}.\n$$\n- 此模型的过渡态 (TS) 位于 $(x,y)=(0,0)$。初始 IRC 方向由过渡态处质量加权 Hessian 矩阵的负特征值对应的特征向量给出。质量加权 Hessian 矩阵为 $H_{\\mathbf{Q}} = M^{-1/2}\\,H\\,M^{-1/2}$，其中 $H$ 是关于 $(x,y)$ 的 Hessian 矩阵，且 $M=\\mathrm{diag}(m_x,m_y)$。\n- 单位速率曲线 $\\mathbf{Q}(s)$ 的曲率 $\\kappa(s)$ 是单位切向量 $\\mathbf{T}(s)$ 对弧长的导数的范数：\n$$\n\\kappa(s) = \\left\\lVert \\frac{d\\mathbf{T}}{ds}\\right\\rVert,\\quad \\text{其中 } \\mathbf{T}(s) = \\frac{d\\mathbf{Q}}{ds}.\n$$\n在数值上，使用离散步长 $\\Delta s$，您可以在第 $n$ 步通过 $\\kappa_n \\approx \\lVert \\mathbf{T}_{n+1}-\\mathbf{T}_n\\rVert / \\Delta s$ 来近似 $\\kappa$。\n\n计算任务：\n- 对于测试套件中的每一组参数，从 $\\mathbf{Q}_0=(0,0)$ 开始，沿 $\\pm \\hat{\\mathbf{v}}_{\\mathrm{TS}}$ 方向（其中 $\\hat{\\mathbf{v}}_{\\mathrm{TS}}$ 是过渡态处 $H_{\\mathbf{Q}}$ 的单位不稳定特征向量）取一个长度为 $\\Delta s$ 的初始位移，从而构建过渡态两侧的 IRC 分支。然后根据单位速率最速下降方向进行迭代步进，直到质量加权梯度的范数降至指定的阈值 $\\varepsilon$ 以下或达到最大步数。\n- 沿着每个分支，计算离散曲率序列，并取该分支上观察到的最大曲率 $\\kappa_{\\max}$。通过取两个分支上的总最大曲率来合并这两个分支。\n- 如果 $\\kappa_{\\max} \\le \\tau$，则将该参数集的 IRC 分类为“直的”，如果 $\\kappa_{\\max}  \\tau$，则分类为“弯曲的”，其中 $\\tau$ 是给定的曲率容差。\n- 您必须严格按照上述定义实现所有量。不允许使用外部数据文件。\n\n数值细节：\n- 使用 Ångström ($\\mathrm{\\AA}$) 作为 $x$ 和 $y$ 的单位，原子质量单位 (amu) 作为 $m_x$ 和 $m_y$ 的单位，以及一致的任意单位作为能量单位。曲率阈值 $\\tau$ 的单位是质量加权长度的倒数，即 $\\mathrm{\\AA}^{-1}\\,\\mathrm{amu}^{-1/2}$。程序的最终答案是布尔值，因此不带单位。\n\n测试套件：\n对于所有情况，使用步长 $\\Delta s = 0.002$，梯度范数阈值 $\\varepsilon = 10^{-8}$，以及最大步数 $N_{\\max} = 5000$。参数 $(A,x_0,k,\\alpha,m_x,m_y)$ 如下：\n- 情况 1：$A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=0.0$, $m_x=1.0$, $m_y=1.0$, 曲率阈值 $\\tau=10^{-3}$。\n- 情况 2：$A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=0.5$, $m_x=1.0$, $m_y=1.0$, 曲率阈值 $\\tau=10^{-3}$。\n- 情况 3：$A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=0.5$, $m_x=1.0$, $m_y=9.0$, 曲率阈值 $\\tau=10^{-3}$。\n- 情况 4：$A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=2.0$, $m_x=1.0$, $m_y=1.0$, 曲率阈值 $\\tau=10^{-3}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含四个情况的分类结果，形式为方括号内以逗号分隔的布尔值列表（例如，$[ \\text{False}, \\text{True}, \\dots ]$），但无空格，其确切格式为 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$，其中每个 $\\text{result}$ 是 $True$ 或 $False$。\n\n程序不应读取任何用户输入。程序必须是完全确定性和自包含的。最终打印的行必须严格匹配指定的格式。",
            "solution": "所提出的问题是有效的。这是一个在计算化学领域中关于内禀反应坐标 (IRC) 及其几何性质计算的、定义明确且具有科学依据的练习。所有必要的参数、定义和算法步骤均已提供，从而可以得到唯一且可验证的解。我们将继续进行推导和实现。\n\n目标是为一个二维模型势能面 (PES) 计算 IRC 的近似值，并根据其在质量加权坐标中的最大曲率将其路径分类为直的或弯曲的。\n\nPES 由函数 $V(x,y)$ 给出：\n$$\nV(x,y) = A(x^2 - x_0^2)^2 + \\frac{1}{2}ky^2 + \\alpha x^2 y\n$$\n其中 $x$ 和 $y$ 是广义坐标。为了追踪作为最速下降路径的 IRC，我们需要势的梯度。梯度 $\\nabla V = \\left(\\frac{\\partial V}{\\partial x}, \\frac{\\partial V}{\\partial y}\\right)$ 的分量为：\n$$\n\\frac{\\partial V}{\\partial x} = 4A(x^2 - x_0^2)(2x) + 2\\alpha xy = 4A(x^3 - x_0^2 x) + 2\\alpha xy\n$$\n$$\n\\frac{\\partial V}{\\partial y} = ky + \\alpha x^2\n$$\nIRC 在质量加权坐标 $\\mathbf{Q} = (Q_x, Q_y)$ 中定义，其中 $Q_x = \\sqrt{m_x} x$ 且 $Q_y = \\sqrt{m_y} y$。质量矩阵为 $M = \\text{diag}(m_x, m_y)$。在这些坐标中的梯度 $\\nabla_{\\mathbf{Q}} V$ 通过链式法则获得：\n$$\n\\nabla_{\\mathbf{Q}} V = \\left(\\frac{\\partial V}{\\partial Q_x}, \\frac{\\partial V}{\\partial Q_y}\\right) = \\left(\\frac{1}{\\sqrt{m_x}}\\frac{\\partial V}{\\partial x}, \\frac{1}{\\sqrt{m_y}}\\frac{\\partial V}{\\partial y}\\right)\n$$\n由质量加权弧长 $s$ 参数化的 IRC 路径 $\\mathbf{Q}(s)$ 受单位速率最速下降的微分方程控制：\n$$\n\\frac{d\\mathbf{Q}}{ds} = -\\frac{\\nabla_{\\mathbf{Q}} V(\\mathbf{Q})}{\\lVert \\nabla_{\\mathbf{Q}} V(\\mathbf{Q})\\rVert} \\equiv \\mathbf{T}(\\mathbf{Q})\n$$\n其中 $\\mathbf{T}(\\mathbf{Q})$ 是路径的单位切向量。\n\n路径始于过渡态 (TS)，即势能面上的一个一阶鞍点。问题指出过渡态位于 $(x,y)=(0,0)$。在此点，梯度分量为 $\\frac{\\partial V}{\\partial x}|_{(0,0)} = 0$ 和 $\\frac{\\partial V}{\\partial y}|_{(0,0)} = 0$，证实了它是一个驻点。\n\n为了确定这个驻点的性质和 IRC 的初始方向，我们必须分析二阶导数的 Hessian 矩阵。在 $(x,y)$ 坐标系中的 Hessian 矩阵是：\n$$\nH = \\begin{pmatrix} \\frac{\\partial^2 V}{\\partial x^2}  \\frac{\\partial^2 V}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 V}{\\partial y \\partial x}  \\frac{\\partial^2 V}{\\partial y^2} \\end{pmatrix} = \\begin{pmatrix} 12Ax^2 - 4Ax_0^2 + 2\\alpha y  2\\alpha x \\\\ 2\\alpha x  k \\end{pmatrix}\n$$\n在过渡态 $(x,y)=(0,0)$ 处，Hessian 矩阵简化为：\n$$\nH(0,0) = \\begin{pmatrix} -4Ax_0^2  0 \\\\ 0  k \\end{pmatrix}\n$$\n相应的质量加权 Hessian 矩阵为 $H_{\\mathbf{Q}} = M^{-1/2}HM^{-1/2}$。在过渡态处，此矩阵为：\n$$\nH_{\\mathbf{Q}}(0,0) = \\begin{pmatrix} 1/\\sqrt{m_x}  0 \\\\ 0  1/\\sqrt{m_y} \\end{pmatrix} \\begin{pmatrix} -4Ax_0^2  0 \\\\ 0  k \\end{pmatrix} \\begin{pmatrix} 1/\\sqrt{m_x}  0 \\\\ 0  1/\\sqrt{m_y} \\end{pmatrix} = \\begin{pmatrix} -4Ax_0^2/m_x  0 \\\\ 0  k/m_y \\end{pmatrix}\n$$\n对于给定的参数，$A  0$ 且 $k  0$，因此 $H_{\\mathbf{Q}}(0,0)$ 有一个负特征值 $\\lambda_1 = -4Ax_0^2/m_x$ 和一个正特征值 $\\lambda_2 = k/m_y$。这证实了该过渡态是一个一阶鞍点。与负特征值对应的特征向量（即不稳定模式）定义了 IRC 的初始方向。对于这个对角化的 Hessian 矩阵，归一化特征向量就是 $\\hat{\\mathbf{v}}_{\\mathrm{TS}} = (1, 0)^T$。\n\nIRC 是使用前向欧拉积分方案进行数值追踪的。从过渡态沿 $\\pm \\hat{\\mathbf{v}}_{\\mathrm{TS}}$ 方向产生一个大小为 $\\Delta s$ 的初始位移，从而生成两个分支。两个分支上的第一个点是 $\\mathbf{Q}_1^{\\pm} = (0,0) \\pm \\Delta s \\cdot \\hat{\\mathbf{v}}_{\\mathrm{TS}} = (\\pm \\Delta s, 0)^T$。从这些起始点中的每一个点开始，路径被迭代传播：\n$$\n\\mathbf{Q}_{n+1} = \\mathbf{Q}_n + \\Delta s \\cdot \\mathbf{T}(\\mathbf{Q}_n)\n$$\n迭代持续进行，直到质量加权梯度 $\\lVert \\nabla_{\\mathbf{Q}} V(\\mathbf{Q}_n)\\rVert$ 的范数降至阈值 $\\varepsilon$ 以下，或达到最大步数 $N_{\\max}$。\n\n路径的曲率 $\\kappa$ 衡量其偏离直线的程度。它被定义为单位切向量对弧长变化率的大小：$\\kappa(s) = \\lVert d\\mathbf{T}/ds \\rVert$。在数值上，对于在每一步计算的切向量序列 $\\mathbf{T}_n$，曲率使用有限差分进行近似：\n$$\n\\kappa_n \\approx \\frac{\\lVert \\mathbf{T}_{n+1} - \\mathbf{T}_n \\rVert}{\\Delta s}\n$$\n其中 $\\mathbf{T}_n$ 是点 $\\mathbf{Q}_n$ 处的切向量。最大曲率 $\\kappa_{\\max}$ 是通过取整个路径（包括两个分支）上 $\\kappa_n$ 的最大值来找到的。\n\n最后，如果 $\\kappa_{\\max}  \\tau$，IRC 被分类为“弯曲的”；如果 $\\kappa_{\\max} \\le \\tau$，则被分类为“直的”，其中 $\\tau$ 是给定的容差。对于耦合常数 $\\alpha = 0$ 的特殊情况，势能在 $x$ 和 $y$ 上是可分的。初始位移沿着 $Q_x$ 轴，并且由于如果 $y=0$，沿 $Q_y$ 的梯度分量将始终为零，因此路径保持在 $Q_x$ 轴上。切向量方向不变，导致曲率为零。对于 $\\alpha \\neq 0$ 的情况，$x$ 和 $y$ 的运动是耦合的。在 $y=0$ 但 $x \\neq 0$ 的点，梯度有一个非零的 $y$ 分量，导致路径向 $Q_y$ 维度弯曲。这种弯曲的程度取决于参数 $\\alpha$、$m_x$ 和 $m_y$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes an approximation of the Intrinsic Reaction Coordinate (IRC) for a\n    model system, calculates its maximum curvature, and classifies it as\n    'straight' or 'curved' based on a threshold.\n    \"\"\"\n\n    # Test suite: (A, x0, k, alpha, mx, my, tau)\n    test_cases = [\n        (10.0, 0.5, 5.0, 0.0, 1.0, 1.0, 1e-3),\n        (10.0, 0.5, 5.0, 0.5, 1.0, 1.0, 1e-3),\n        (10.0, 0.5, 5.0, 0.5, 1.0, 9.0, 1e-3),\n        (10.0, 0.5, 5.0, 2.0, 1.0, 1.0, 1e-3),\n    ]\n\n    # Numerical parameters\n    delta_s = 0.002\n    epsilon = 1e-8\n    N_max = 5000\n\n    results = []\n\n    for A, x0, k, alpha, mx, my, tau in test_cases:\n        \n        sqrt_mx = np.sqrt(mx)\n        sqrt_my = np.sqrt(my)\n\n        def to_xy(Q):\n            \"\"\"Converts mass-weighted coordinates Q to standard coordinates (x, y).\"\"\"\n            return Q[0] / sqrt_mx, Q[1] / sqrt_my\n\n        def grad_V(x, y):\n            \"\"\"Computes the gradient of V(x, y) in standard coordinates.\"\"\"\n            dv_dx = 4.0 * A * (x**3 - x0**2 * x) + 2.0 * alpha * x * y\n            dv_dy = k * y + alpha * x**2\n            return np.array([dv_dx, dv_dy])\n\n        def mass_weighted_grad_V(Q):\n            \"\"\"Computes the gradient of V in mass-weighted coordinates.\"\"\"\n            x, y = to_xy(Q)\n            grad_xy = grad_V(x, y)\n            return np.array([grad_xy[0] / sqrt_mx, grad_xy[1] / sqrt_my])\n\n        def get_max_kappa_for_branch(initial_direction):\n            \"\"\"\n            Follows one branch of the IRC and computes its maximum curvature.\n            initial_direction is +1.0 for the forward branch, -1.0 for backward.\n            \"\"\"\n            # Initial point displaced from TS along the unstable mode\n            q = np.array([initial_direction * delta_s, 0.0])\n            \n            tangents = []\n            \n            for _ in range(N_max):\n                grad_q = mass_weighted_grad_V(q)\n                grad_norm = np.linalg.norm(grad_q)\n\n                # Check for convergence to a minimum\n                if grad_norm  epsilon:\n                    break\n                \n                # Calculate unit tangent vector\n                t = -grad_q / grad_norm\n                tangents.append(t)\n                \n                # Take Euler step\n                q = q + delta_s * t\n\n            # If the path is too short to compute curvature, curvature is 0\n            if len(tangents)  2:\n                return 0.0\n            \n            # Compute discrete curvature along the path\n            kappas = []\n            for i in range(len(tangents) - 1):\n                # kappa_n = ||T_{n+1} - T_n|| / delta_s\n                kappa = np.linalg.norm(tangents[i+1] - tangents[i]) / delta_s\n                kappas.append(kappa)\n\n            return max(kappas) if kappas else 0.0\n\n        # Compute max curvature for both branches\n        kappa_max_fwd = get_max_kappa_for_branch(1.0)\n        kappa_max_bwd = get_max_kappa_for_branch(-1.0)\n        \n        # The overall maximum curvature is the max of the two branches\n        kappa_max = max(kappa_max_fwd, kappa_max_bwd)\n        \n        # Classify based on the threshold tau\n        # True for curved, False for straight\n        is_curved = kappa_max > tau\n        results.append(is_curved)\n\n    # Final print statement in the exact required format.\n    # e.g., [True,False,False,True]\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算出IRC路径只是工作的一半，最终目标是获得化学洞察力。最后一个练习  聚焦于反应坐标本身的分析与解读。对于HCN到HNC的异构化反应，你将学习如何通过将IRC切向量投影到特定的内坐标运动（如键的伸缩）上，来量化不同内坐标对整个转变过程的贡献。这项技能能够将抽象的数学向量转化为具体、生动的化学变化故事。",
            "id": "2461347",
            "problem": "考虑氰化氢（HCN）异构化为异氰化氢（HNC）的反应，该反应在具有一阶鞍点（过渡态）的势能面上进行。在过渡态处的内禀反应坐标（IRC）切向被定义为与质量加权Hessian矩阵的唯一负特征值相关联的归一化特征向量。设分子由氢（H）、碳（C）和氮（N）三个原子组成，按此顺序标记。对于任意笛卡尔位移向量 $x \\in \\mathbb{R}^{9}$（顺序为 $[x_{\\mathrm{H}x},x_{\\mathrm{H}y},x_{\\mathrm{H}z},x_{\\mathrm{C}x},x_{\\mathrm{C}y},x_{\\mathrm{C}z},x_{\\mathrm{N}x},x_{\\mathrm{N}y},x_{\\mathrm{N}z}]$），定义质量加权坐标 $q$ 为 $q = M^{1/2} x$，其中 $M^{1/2}$ 是一个对角矩阵，其对角元为 $\\sqrt{m_i}$，对于原子 $i$ 的三个笛卡尔分量中的每一个都重复出现，而 $m_i$ 是原子质量。所有长度必须以埃（angstrom）表示，所有质量必须以统一原子质量单位表示。\n\n设过渡态处三个原子的笛卡尔坐标（单位为埃）固定如下：\n- $R_{\\mathrm{H}} = (-0.200, 0.000, 0.900)$,\n- $R_{\\mathrm{C}} = (0.000, 0.000, 0.000)$,\n- $R_{\\mathrm{N}} = (1.160, 0.000, 0.000)$.\n原子质量（单位为统一原子质量单位）如下：\n- $m_{\\mathrm{H}} = 1.008$,\n- $m_{\\mathrm{C}} = 12.000$,\n- $m_{\\mathrm{N}} = 14.000$.\n\n定义沿碳-氮（C–N）键的单位向量为\n$$\n\\hat{u}_{\\mathrm{CN}} = \\frac{R_{\\mathrm{N}} - R_{\\mathrm{C}}}{\\lVert R_{\\mathrm{N}} - R_{\\mathrm{C}} \\rVert}.\n$$\n定义C–N键的归一化笛卡尔键伸缩位移方向为一个9维向量\n$$\n\\hat{d} = \\frac{1}{\\sqrt{2}}\\left(0,0,0,\\,-\\hat{u}_{\\mathrm{CN},x},-\\hat{u}_{\\mathrm{CN},y},-\\hat{u}_{\\mathrm{CN},z},\\,\\hat{u}_{\\mathrm{CN},x},\\hat{u}_{\\mathrm{CN},y},\\hat{u}_{\\mathrm{CN},z}\\right),\n$$\n这对应于在笛卡尔空间中，氢原子固定时的纯单位范数C–N伸缩。\n\n对于一个给定的、在质量加权坐标中表示为单位向量的IRC切向 $v^{(\\mathrm{mw})} \\in \\mathbb{R}^{9}$（其中 $\\lVert v^{(\\mathrm{mw})} \\rVert = 1$），通过以下方式定义其对应的归一化笛卡尔位移方向 $\\hat{u}_x$\n$$\nu_x = M^{-1/2} v^{(\\mathrm{mw})}, \\quad \\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert}.\n$$\n通过投影的平方来量化C–N键长对IRC向量的分数贡献\n$$\nf = \\left(\\hat{d} \\cdot \\hat{u}_x \\right)^2,\n$$\n这是一个在 $[0,1]$ 区间内的无量纲数。对于给定的阈值 $\\tau$，如果 $f \\ge \\tau$，则判定C–N键长是IRC向量的一个重要组分。\n\n你的任务是编写一个程序，对下面的每个测试用例，计算 $f$ 并使用阈值 $\\tau = 0.5$ 返回一个指示其重要性的布尔值。\n\n测试套件。每个测试用例提供一个笛卡尔位移模式 $v^{(\\mathrm{cart})}$；相应的质量加权IRC切向是归一化的质量加权向量\n$$\nv^{(\\mathrm{mw})} = \\frac{M^{1/2} v^{(\\mathrm{cart})}}{\\lVert M^{1/2} v^{(\\mathrm{cart})} \\rVert}.\n$$\n所有用例均使用上述固定的几何结构和质量。\n\n- 案例1（主要为C–N伸缩）：\n  $v^{(\\mathrm{cart})}$ 的分量为\n  $$\n  v^{(\\mathrm{cart})}_{\\mathrm{H}} = (0,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{C}} = (-1,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{N}} = (+1,0,0).\n  $$\n\n- 案例2（类氢转移，C–N伸缩极小）：\n  $v^{(\\mathrm{cart})}$ 的分量为\n  $$\n  v^{(\\mathrm{cart})}_{\\mathrm{H}} = (1,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{C}} = (0.2,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{N}} = (0.2,0,0).\n  $$\n\n- 案例3（混合C–N伸缩和平面内弯曲，边界情况）：\n  令 $\\hat{e}_x = (1,0,0)$ 和 $\\hat{e}_y = (0,1,0)$。对于给定的几何结构，有 $\\hat{u}_{\\mathrm{CN}} = \\hat{e}_x$，定义\n  $$\n  v^{(\\mathrm{cart})}_{\\mathrm{H}} = (0,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{C}} = \\left(-\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}},\\,0\\right),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{N}} = \\left(+\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}},\\,0\\right).\n  $$\n\n最终输出格式。你的程序应生成单行输出，其中包含三个用例的布尔结果，按顺序排列，形式为用方括号括起来的逗号分隔列表，无空格，例如“[True,False,True]”。不应打印任何其他文本。",
            "solution": "该问题要求针对一个特定的内坐标，即碳-氮键伸缩，来验证一个给定的化学反应坐标。这是计算化学中分析振动简正模式性质或（如本例中）内禀反应坐标（IRC）性质的标准程序。过渡态处的IRC描述了从势能面上的一阶鞍点到反应物和产物的最陡下降路径。其切向量指明了穿过过渡态势垒所涉及的主要原子运动。我们的任务是计算在给定的三个案例中，C-N键伸缩对该切向量的分数贡献。\n\n该问题在科学上和计算上都是适定的。所有必要数据，包括原子质量、过渡态几何的笛卡尔坐标，以及所有相关向量和度量的定义，都已明确提供。其基本原理——坐标的质量加权、向量归一化和投影——是经典力学和线性代数中的基本概念，并被正确地应用于化学物理背景中。因此，该问题是有效的。\n\n我们将对每个测试用例进行系统、分步的计算。\n\n首先，我们根据所提供的几何结构和质量，确定恒定的参数和向量。\n给定的原子质量为 $m_{\\mathrm{H}} = 1.008$ u，$m_{\\mathrm{C}} = 12.000$ u 和 $m_{\\mathrm{N}} = 14.000$ u。这些质量用于构建对角质量加权矩阵 $M^{1/2}$ 及其逆矩阵 $M^{-1/2}$。对于一个9维笛卡尔位移向量 $x \\in \\mathbb{R}^{9}$，相应的质量加权向量为 $q = M^{1/2} x$。$M^{1/2}$ 的对角元素为 $(\\sqrt{m_{\\mathrm{H}}}, \\sqrt{m_{\\mathrm{H}}}, \\sqrt{m_{\\mathrm{H}}}, \\sqrt{m_{\\mathrm{C}}}, \\sqrt{m_{\\mathrm{C}}}, \\sqrt{m_{\\mathrm{C}}}, \\sqrt{m_{\\mathrm{N}}}, \\sqrt{m_{\\mathrm{N}}}, \\sqrt{m_{\\mathrm{N}}})$。\n\n过渡态坐标为 $R_{\\mathrm{H}} = (-0.200, 0.000, 0.900)$ Å，$R_{\\mathrm{C}} = (0.000, 0.000, 0.000)$ Å 以及 $R_{\\mathrm{N}} = (1.160, 0.000, 0.000)$ Å。\n\n沿碳-氮键的单位向量 $\\hat{u}_{\\mathrm{CN}}$ 计算如下：\n$$\nR_{\\mathrm{N}} - R_{\\mathrm{C}} = (1.160, 0.000, 0.000) - (0.000, 0.000, 0.000) = (1.160, 0.000, 0.000)\n$$\n$$\n\\lVert R_{\\mathrm{N}} - R_{\\mathrm{C}} \\rVert = \\sqrt{1.160^2 + 0^2 + 0^2} = 1.160\n$$\n$$\n\\hat{u}_{\\mathrm{CN}} = \\frac{(1.160, 0.000, 0.000)}{1.160} = (1, 0, 0)\n$$\n该向量 $\\hat{u}_{\\mathrm{CN}}$ 用于定义归一化的笛卡尔C–N键伸缩位移方向 $\\hat{d}$，它作为我们C-N伸缩运动的参考向量。\n$$\n\\hat{d} = \\frac{1}{\\sqrt{2}}\\left(0,0,0,\\,-\\hat{u}_{\\mathrm{CN},x},-\\hat{u}_{\\mathrm{CN},y},-\\hat{u}_{\\mathrm{CN},z},\\,\\hat{u}_{\\mathrm{CN},x},\\hat{u}_{\\mathrm{CN},y},\\hat{u}_{\\mathrm{CN},z}\\right)\n$$\n代入 $\\hat{u}_{\\mathrm{CN}} = (1, 0, 0)$，我们得到：\n$$\n\\hat{d} = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1, 0, 0, 1, 0, 0)\n$$\n该向量在笛卡尔空间中是归一化的，即 $\\lVert \\hat{d} \\rVert = 1$。\n\n对于每个测试用例，我们给定一个笛卡尔位移模式 $v^{(\\mathrm{cart})}$，并且必须执行以下操作序列：\n1. 计算质量加权向量 $v' = M^{1/2} v^{(\\mathrm{cart})}$。\n2. 将其归一化以获得质量加权坐标中的IRC切向：$v^{(\\mathrm{mw})} = v' / \\lVert v' \\rVert$。\n3. 将 $v^{(\\mathrm{mw})}$ 转换回笛卡尔位移向量：$u_x = M^{-1/2} v^{(\\mathrm{mw})}$。\n4. 归一化此笛卡尔向量以获得单位方向：$\\hat{u}_x = u_x / \\lVert u_x \\rVert$。\n5. 计算C-N伸缩的分数贡献，即投影的平方：$f = (\\hat{d} \\cdot \\hat{u}_x)^2$。\n6. 将 $f$ 与阈值 $\\tau = 0.5$ 进行比较以确定其重要性。\n\n现在我们将此程序应用于每个案例。\n\n案例1：主要为C–N伸缩\n$v^{(\\mathrm{cart})} = (0, 0, 0, -1, 0, 0, 1, 0, 0)$。\n1. 质量加权：$v' = (0, 0, 0, -1\\sqrt{m_{\\mathrm{C}}}, 0, 0, 1\\sqrt{m_{\\mathrm{N}}}, 0, 0) = (0, 0, 0, -\\sqrt{12.000}, 0, 0, \\sqrt{14.000}, 0, 0)$。\n2. 归一化：$\\lVert v' \\rVert = \\sqrt{(-\\sqrt{12.000})^2 + (\\sqrt{14.000})^2} = \\sqrt{12.000 + 14.000} = \\sqrt{26.000}$。\n$v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -\\sqrt{12.000}, 0, 0, \\sqrt{14.000}, 0, 0)$。\n3. 转换回笛卡尔坐标：$u_x = M^{-1/2} v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -1, 0, 0, 1, 0, 0)$。\n4. 归一化：$\\lVert u_x \\rVert = \\frac{1}{\\sqrt{26.000}}\\sqrt{(-1)^2 + 1^2} = \\frac{\\sqrt{2}}{\\sqrt{26.000}} = \\frac{1}{\\sqrt{13.000}}$。\n$\\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert} = \\sqrt{13.000} \\cdot \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -1, 0, 0, 1, 0, 0) = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1, 0, 0, 1, 0, 0)$。\n5. 投影：我们观察到 $\\hat{u}_x = \\hat{d}$。因此，$\\hat{d} \\cdot \\hat{u}_x = \\hat{d} \\cdot \\hat{d} = \\lVert \\hat{d} \\rVert^2 = 1$。\n$f = 1^2 = 1$。\n6. 重要性：$f = 1 \\ge 0.5$。结果为True。\n\n案例2：类氢转移\n$v^{(\\mathrm{cart})} = (1, 0, 0, 0.2, 0, 0, 0.2, 0, 0)$。\n1. 质量加权：$v' = (1\\sqrt{m_{\\mathrm{H}}}, 0, 0, 0.2\\sqrt{m_{\\mathrm{C}}}, 0, 0, 0.2\\sqrt{m_{\\mathrm{N}}}, 0, 0) = (\\sqrt{1.008}, 0, 0, 0.2\\sqrt{12.000}, 0, 0, 0.2\\sqrt{14.000}, 0, 0)$。\n2. 归一化：$\\lVert v' \\rVert^2 = 1.008 + (0.2)^2(12.000) + (0.2)^2(14.000) = 1.008 + 0.04(12.000) + 0.04(14.000) = 1.008 + 0.480 + 0.560 = 2.048$。\n$\\lVert v' \\rVert = \\sqrt{2.048}$。\n$v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{2.048}}(\\sqrt{1.008}, 0, 0, 0.2\\sqrt{12.000}, 0, 0, 0.2\\sqrt{14.000}, 0, 0)$。\n3. 转换回笛卡尔坐标：$u_x = M^{-1/2} v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{2.048}}(1, 0, 0, 0.2, 0, 0, 0.2, 0, 0)$。\n4. 归一化：$\\lVert u_x \\rVert^2 = \\frac{1}{2.048}(1^2 + 0.2^2 + 0.2^2) = \\frac{1.08}{2.048}$。\n$\\lVert u_x \\rVert = \\sqrt{\\frac{1.08}{2.048}}$。\n$\\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert} = \\frac{1}{\\sqrt{1.08}}(1, 0, 0, 0.2, 0, 0, 0.2, 0, 0)$。\n5. 投影：$\\hat{d} \\cdot \\hat{u}_x = \\frac{1}{\\sqrt{2}} \\cdot \\frac{1}{\\sqrt{1.08}} \\left[ (-1)(0.2) + (1)(0.2) \\right] = 0$。\n$f = 0^2 = 0$。\n6. 重要性：$f = 0  0.5$。结果为False。\n\n案例3：混合伸缩和弯曲\n$v^{(\\mathrm{cart})} = (0, 0, 0, -1/\\sqrt{2}, 1/\\sqrt{2}, 0, 1/\\sqrt{2}, 1/\\sqrt{2}, 0)$。\n1. 质量加权：$v'_C = (-\\frac{\\sqrt{m_{\\mathrm{C}}}}{\\sqrt{2}}, \\frac{\\sqrt{m_{\\mathrm{C}}}}{\\sqrt{2}}, 0)$，$v'_N = (\\frac{\\sqrt{m_{\\mathrm{N}}}}{\\sqrt{2}}, \\frac{\\sqrt{m_{\\mathrm{N}}}}{\\sqrt{2}}, 0)$。\n2. 归一化：$\\lVert v' \\rVert^2 = \\frac{1}{2}(m_{\\mathrm{C}} + m_{\\mathrm{C}} + m_{\\mathrm{N}} + m_{\\mathrm{N}}) = m_{\\mathrm{C}} + m_{\\mathrm{N}} = 12.000 + 14.000 = 26.000$。\n$\\lVert v' \\rVert = \\sqrt{26.000}$。\n$v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -\\frac{\\sqrt{12}}{\\sqrt{2}}, \\frac{\\sqrt{12}}{\\sqrt{2}}, 0, \\frac{\\sqrt{14}}{\\sqrt{2}}, \\frac{\\sqrt{14}}{\\sqrt{2}}, 0)$。\n3. 转换回笛卡尔坐标：$u_x = M^{-1/2} v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -1/\\sqrt{2}, 1/\\sqrt{2}, 0, 1/\\sqrt{2}, 1/\\sqrt{2}, 0)$。\n4. 归一化：$\\lVert u_x \\rVert^2 = \\frac{1}{26.000} \\left( (-\\frac{1}{\\sqrt{2}})^2 + (\\frac{1}{\\sqrt{2}})^2 + (\\frac{1}{\\sqrt{2}})^2 + (\\frac{1}{\\sqrt{2}})^2 \\right) = \\frac{1}{26.000}(\\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2}) = \\frac{2}{26.000} = \\frac{1}{13.000}$。\n$\\lVert u_x \\rVert = \\frac{1}{\\sqrt{13.000}}$。\n$\\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert} = \\sqrt{13.000} \\cdot \\frac{v^{(\\mathrm{cart})}}{\\sqrt{26.000}} = \\frac{1}{\\sqrt{2}} v^{(\\mathrm{cart})}$。\n$\\hat{u}_x = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1/\\sqrt{2}, 1/\\sqrt{2}, 0, 1/\\sqrt{2}, 1/\\sqrt{2}, 0)$。\n5. 投影：$\\hat{d} = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1, 0, 0, 1, 0, 0)$。\n$\\hat{d} \\cdot \\hat{u}_x = \\frac{1}{\\sqrt{2}} \\cdot \\frac{1}{\\sqrt{2}} \\left[ (-1)(-\\frac{1}{\\sqrt{2}}) + (1)(\\frac{1}{\\sqrt{2}}) \\right] = \\frac{1}{2}\\left[\\frac{1}{\\sqrt{2}} + \\frac{1}{\\sqrt{2}}\\right] = \\frac{1}{2}\\left[\\frac{2}{\\sqrt{2}}\\right] = \\frac{1}{\\sqrt{2}}$。\n$f = (\\frac{1}{\\sqrt{2}})^2 = \\frac{1}{2} = 0.5$。\n6. 重要性：$f = 0.5 \\ge 0.5$。结果为True。\n\n三个案例的最终布尔结果是 [True, False, True]。以下程序实现了这一逻辑以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining the significance of the C-N bond stretch\n    in a given reaction coordinate for the isomerization of HCN to HNC.\n    \"\"\"\n    \n    # Define constants and fixed geometry from the problem statement.\n    # Atomic masses in unified atomic mass units (u).\n    masses = {\n        'H': 1.008,\n        'C': 12.000,\n        'N': 14.000\n    }\n    \n    # Transition state coordinates in angstroms.\n    # Not explicitly needed for the calculation of d_hat as u_cn is simple.\n    # R_H = np.array([-0.200, 0.000, 0.900])\n    # R_C = np.array([0.000, 0.000, 0.000])\n    # R_N = np.array([1.160, 0.000, 0.000])\n\n    # Threshold for significance.\n    tau = 0.5\n\n    # Define the normalized C-N bond-stretch displacement direction, d_hat.\n    # From the problem, R_N - R_C is along the x-axis.\n    # So, u_cn = [1, 0, 0].\n    u_cn = np.array([1.0, 0.0, 0.0])\n    \n    # d_hat is a 9-vector in Cartesian space.\n    # [H_x, H_y, H_z, C_x, C_y, C_z, N_x, N_y, N_z]\n    d_hat = np.zeros(9)\n    d_hat[3:6] = -u_cn  # Displacement for Carbon atom\n    d_hat[6:9] = u_cn   # Displacement for Nitrogen atom\n    d_hat /= np.linalg.norm(d_hat) # Normalize to unit length\n\n    # Define the test cases.\n    v_cart_cases = [\n        # Case 1: dominant C-N stretch\n        np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0]),\n\n        # Case 2: hydrogen transfer-like, minimal C-N stretch\n        np.array([1.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.2, 0.0, 0.0]),\n\n        # Case 3: mixed C-N stretch and in-plane bend\n        np.array([0.0, 0.0, 0.0, -1.0/np.sqrt(2), 1.0/np.sqrt(2), 0.0, 1.0/np.sqrt(2), 1.0/np.sqrt(2), 0.0])\n    ]\n\n    # Create the 9D mass vector for mass-weighting operations.\n    # Order: [m_H, m_H, m_H, m_C, m_C, m_C, m_N, m_N, m_N]\n    mass_vec_9d = np.repeat([masses['H'], masses['C'], masses['N']], 3)\n    \n    M_sqrt_diag = np.sqrt(mass_vec_9d)\n    M_inv_sqrt_diag = 1.0 / M_sqrt_diag\n\n    results = []\n    for v_cart in v_cart_cases:\n        # Step 1: Compute the mass-weighted vector v_prime.\n        v_prime = v_cart * M_sqrt_diag\n        \n        # Step 2: Normalize to get the IRC tangent in mass-weighted coordinates (v_mw).\n        v_prime_norm = np.linalg.norm(v_prime)\n        if v_prime_norm == 0:\n            # Handle the case of a zero vector, though not expected here.\n            results.append(False)\n            continue\n        v_mw = v_prime / v_prime_norm\n        \n        # Step 3: Transform v_mw back to a Cartesian displacement vector (u_x).\n        u_x = v_mw * M_inv_sqrt_diag\n        \n        # Step 4: Normalize this Cartesian vector to get the unit direction (u_x_hat).\n        u_x_norm = np.linalg.norm(u_x)\n        if u_x_norm == 0:\n            results.append(False)\n            continue\n        u_x_hat = u_x / u_x_norm\n        \n        # Step 5: Calculate the fractional contribution f.\n        f = (np.dot(d_hat, u_x_hat))**2\n        \n        # Step 6: Compare f with the threshold tau.\n        is_significant = f >= tau\n        results.append(is_significant)\n\n    # Format and print the final output as specified.\n    # Example: [True,False,True]\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}