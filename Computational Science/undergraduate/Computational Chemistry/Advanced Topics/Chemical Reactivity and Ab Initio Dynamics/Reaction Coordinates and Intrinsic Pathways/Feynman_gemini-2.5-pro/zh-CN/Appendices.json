{
    "hands_on_practices": [
        {
            "introduction": "理论是基础，但真正的理解来自于实践。这个练习将指导你从零开始，为一个经典的化学过程——氨的伞形翻转——编写一个程序来计算其内禀反应坐标（IRC）。通过亲手实现基于质量加权坐标的陡峭下降算法，你将具体地掌握IRC的定义，并探索反应路径的几何特性，比如路径是直线还是曲线。",
            "id": "2461292",
            "problem": "你将实现一个程序，使用简化的双模模型计算氨伞形反转的内禀反应坐标（IRC）的近似值，并分类该IRC在质量加权坐标中是直的还是弯曲的。IRC被定义为在质量加权笛卡尔坐标下，势能面上的最速下降路径。你的实现必须基于如下所述的第一性原理和经过充分检验的定义，并生成单行输出，以总结一个小型测试套件的分类结果。\n\n使用的基本原理和定义：\n- 在简化模型中，使用两个广义坐标：$x$ 表示反转（伞形）坐标，$y$ 表示耦合的全对称伸缩坐标。势能面指定为\n$$\nV(x,y) = A\\,(x^2 - x_0^2)^2 + \\tfrac{1}{2}k\\,y^2 + \\alpha\\,x^2\\,y,\n$$\n其中 $A$、$x_0$、$k$ 和 $\\alpha$ 是实数常数。\n- 设质量矩阵为对角矩阵，其对角元分别为对应于 $x$ 和 $y$ 的 $m_x$ 和 $m_y$。定义质量加权坐标 $\\mathbf{Q} = (Q_x,Q_y)$ 为 $Q_x = \\sqrt{m_x}\\,x$ 和 $Q_y = \\sqrt{m_y}\\,y$。\n- 质量加权梯度通过链式法则定义为 $\\nabla_{\\mathbf{Q}} V = \\left(\\frac{\\partial V}{\\partial Q_x}, \\frac{\\partial V}{\\partial Q_y}\\right) = \\left(\\frac{1}{\\sqrt{m_x}}\\frac{\\partial V}{\\partial x}, \\frac{1}{\\sqrt{m_y}}\\frac{\\partial V}{\\partial y}\\right)$。\n- IRC是$\\mathbf{Q}$空间中由质量加权弧长 $s$ 参数化的最速下降路径，满足单位速率下降条件：\n$$\n\\frac{d\\mathbf{Q}}{ds} = -\\frac{\\nabla_{\\mathbf{Q}} V(\\mathbf{Q})}{\\lVert \\nabla_{\\mathbf{Q}} V(\\mathbf{Q})\\rVert}.\n$$\n- 此模型的过渡态（TS）位于 $(x,y)=(0,0)$。初始IRC方向由过渡态处质量加权Hessian矩阵的负特征值对应的特征向量给出。质量加权Hessian矩阵为 $H_{\\mathbf{Q}} = M^{-1/2}\\,H\\,M^{-1/2}$，其中 $H$ 是关于 $(x,y)$ 的Hessian矩阵，$M=\\mathrm{diag}(m_x,m_y)$。\n- 单位速率曲线 $\\mathbf{Q}(s)$ 的曲率 $\\kappa(s)$ 是单位切向量 $\\mathbf{T}(s)$ 对弧长的导数的范数：\n$$\n\\kappa(s) = \\left\\lVert \\frac{d\\mathbf{T}}{ds}\\right\\rVert,\\quad \\text{其中 } \\mathbf{T}(s) = \\frac{d\\mathbf{Q}}{ds}.\n$$\n在数值上，对于一个离散步长 $\\Delta s$，你可以在第 $n$ 步通过 $\\kappa_n \\approx \\lVert \\mathbf{T}_{n+1}-\\mathbf{T}_n\\rVert / \\Delta s$ 来近似 $\\kappa$。\n\n计算任务：\n- 对于测试套件中的每一组参数，从 $\\mathbf{Q}_0=(0,0)$ 开始，沿 $\\pm \\hat{\\mathbf{v}}_{\\mathrm{TS}}$ 方向（其中 $\\hat{\\mathbf{v}}_{\\mathrm{TS}}$ 是过渡态处 $H_{\\mathbf{Q}}$ 的单位不稳定特征向量）取一个长度为 $\\Delta s$ 的初始位移，以构建过渡态两侧的IRC分支。然后根据单位速率最速下降方向进行迭代步进，直到质量加权梯度范数低于指定阈值 $\\varepsilon$ 或达到最大步数。\n- 沿着每个分支，计算离散曲率序列，并取该分支上观察到的最大曲率 $\\kappa_{\\max}$。通过取两个分支上的总最大曲率来合并两个分支。\n- 对于该参数集，如果 $\\kappa_{\\max} \\le \\tau$，则将IRC分类为直的；如果 $\\kappa_{\\max} > \\tau$，则分类为弯曲的。其中 $\\tau$ 是给定的曲率容差。\n- 你必须严格按照上述定义实现所有量。不允许使用外部数据文件。\n\n数值细节：\n- $x$ 和 $y$ 的单位使用埃（$\\mathrm{\\AA}$），$m_x$ 和 $m_y$ 的单位使用原子质量单位（amu），能量使用一致的任意单位。曲率阈值 $\\tau$ 的单位是质量加权长度的倒数，即 $\\mathrm{\\AA}^{-1}\\,\\mathrm{amu}^{-1/2}$。程序的最终答案是布尔值，因此不带单位。\n\n测试套件：\n对于所有情况，使用步长 $\\Delta s = 0.002$，梯度范数阈值 $\\varepsilon = 10^{-8}$，以及最大步数 $N_{\\max} = 5000$。参数 $(A,x_0,k,\\alpha,m_x,m_y)$ 如下：\n- 情况1：$A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=0.0$, $m_x=1.0$, $m_y=1.0$，曲率阈值 $\\tau=10^{-3}$。\n- 情况2：$A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=0.5$, $m_x=1.0$, $m_y=1.0$，曲率阈值 $\\tau=10^{-3}$。\n- 情况3：$A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=0.5$, $m_x=1.0$, $m_y=9.0$，曲率阈值 $\\tau=10^{-3}$。\n- 情况4：$A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=2.0$, $m_x=1.0$, $m_y=1.0$，曲率阈值 $\\tau=10^{-3}$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含四个情况的分类结果，形式为方括号内由逗号分隔的布尔值列表（例如，$[ \\text{False}, \\text{True}, \\dots ]$），但无空格，其确切格式为 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$，其中每个 $\\text{result}$ 是 $True$ 或 $False$。\n\n程序不应读取任何用户输入。程序必须是完全确定性的和自包含的。最终打印的行必须严格匹配指定的格式。",
            "solution": "所提出的问题是有效的。这是一个适定且有科学依据的计算化学练习，涉及内禀反应坐标（IRC）及其几何性质的计算。所有必要的参数、定义和算法步骤均已提供，从而可以得到一个唯一且可验证的解。我们将继续进行推导和实现。\n\n目标是计算一个二维模型势能面（PES）的IRC近似值，并根据其在质量加权坐标中的最大曲率，将其路径分类为直的或弯曲的。\n\nPES由函数 $V(x,y)$ 给出：\n$$\nV(x,y) = A(x^2 - x_0^2)^2 + \\frac{1}{2}ky^2 + \\alpha x^2 y\n$$\n其中 $x$ 和 $y$ 是广义坐标。为了追踪作为最速下降路径的IRC，我们需要势的梯度。梯度 $\\nabla V = \\left(\\frac{\\partial V}{\\partial x}, \\frac{\\partial V}{\\partial y}\\right)$ 的分量是：\n$$\n\\frac{\\partial V}{\\partial x} = 4A(x^2 - x_0^2)(2x) + 2\\alpha xy = 4A(x^3 - x_0^2 x) + 2\\alpha xy\n$$\n$$\n\\frac{\\partial V}{\\partial y} = ky + \\alpha x^2\n$$\nIRC在质量加权坐标 $\\mathbf{Q} = (Q_x, Q_y)$ 中定义，其中 $Q_x = \\sqrt{m_x} x$ 且 $Q_y = \\sqrt{m_y} y$。质量矩阵为 $M = \\text{diag}(m_x, m_y)$。在这些坐标中的梯度 $\\nabla_{\\mathbf{Q}} V$ 可通过链式法则得到：\n$$\n\\nabla_{\\mathbf{Q}} V = \\left(\\frac{\\partial V}{\\partial Q_x}, \\frac{\\partial V}{\\partial Q_y}\\right) = \\left(\\frac{1}{\\sqrt{m_x}}\\frac{\\partial V}{\\partial x}, \\frac{1}{\\sqrt{m_y}}\\frac{\\partial V}{\\partial y}\\right)\n$$\nIRC路径 $\\mathbf{Q}(s)$ 由质量加权弧长 $s$ 参数化，并由单位速率最速下降的微分方程控制：\n$$\n\\frac{d\\mathbf{Q}}{ds} = -\\frac{\\nabla_{\\mathbf{Q}} V(\\mathbf{Q})}{\\lVert \\nabla_{\\mathbf{Q}} V(\\mathbf{Q})\\rVert} \\equiv \\mathbf{T}(\\mathbf{Q})\n$$\n其中 $\\mathbf{T}(\\mathbf{Q})$ 是路径的单位切向量。\n\n路径始于过渡态（TS），它是PES上的一阶鞍点。问题陈述过渡态位于 $(x,y)=(0,0)$。在该点，梯度分量为 $\\frac{\\partial V}{\\partial x}|_{(0,0)} = 0$ 和 $\\frac{\\partial V}{\\partial y}|_{(0,0)} = 0$，证实了它是一个驻点。\n\n为了确定此驻点的性质以及IRC的初始方向，我们必须分析二阶导数的Hessian矩阵。在 $(x,y)$ 坐标系中的Hessian矩阵是：\n$$\nH = \\begin{pmatrix} \\frac{\\partial^2 V}{\\partial x^2} & \\frac{\\partial^2 V}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 V}{\\partial y \\partial x} & \\frac{\\partial^2 V}{\\partial y^2} \\end{pmatrix} = \\begin{pmatrix} 12Ax^2 - 4Ax_0^2 + 2\\alpha y & 2\\alpha x \\\\ 2\\alpha x & k \\end{pmatrix}\n$$\n在过渡态 $(x,y)=(0,0)$ 处，Hessian矩阵简化为：\n$$\nH(0,0) = \\begin{pmatrix} -4Ax_0^2 & 0 \\\\ 0 & k \\end{pmatrix}\n$$\n相应的质量加权Hessian矩阵为 $H_{\\mathbf{Q}} = M^{-1/2}HM^{-1/2}$。在过渡态处，它为：\n$$\nH_{\\mathbf{Q}}(0,0) = \\begin{pmatrix} 1/\\sqrt{m_x} & 0 \\\\ 0 & 1/\\sqrt{m_y} \\end{pmatrix} \\begin{pmatrix} -4Ax_0^2 & 0 \\\\ 0 & k \\end{pmatrix} \\begin{pmatrix} 1/\\sqrt{m_x} & 0 \\\\ 0 & 1/\\sqrt{m_y} \\end{pmatrix} = \\begin{pmatrix} -4Ax_0^2/m_x & 0 \\\\ 0 & k/m_y \\end{pmatrix}\n$$\n对于给定的参数 $A > 0$ 和 $k > 0$，因此 $H_{\\mathbf{Q}}(0,0)$ 有一个负特征值 $\\lambda_1 = -4Ax_0^2/m_x$ 和一个正特征值 $\\lambda_2 = k/m_y$。这证实了过渡态是一阶鞍点。对应于负特征值的特征向量，即不稳定模式，定义了IRC的初始方向。对于这个对角Hessian矩阵，归一化特征向量就是 $\\hat{\\mathbf{v}}_{\\mathrm{TS}} = (1, 0)^T$。\n\nIRC使用前向欧拉积分方案进行数值追踪。从过渡态沿方向 $\\pm \\hat{\\mathbf{v}}_{\\mathrm{TS}}$ 产生一个 $\\Delta s$ 的初始位移，以生成两个分支。两个分支上的第一个点是 $\\mathbf{Q}_1^{\\pm} = (0,0) \\pm \\Delta s \\cdot \\hat{\\mathbf{v}}_{\\mathrm{TS}} = (\\pm \\Delta s, 0)^T$。从这些起始点中的每一个，路径被迭代传播：\n$$\n\\mathbf{Q}_{n+1} = \\mathbf{Q}_n + \\Delta s \\cdot \\mathbf{T}(\\mathbf{Q}_n)\n$$\n迭代持续进行，直到质量加权梯度的范数 $\\lVert \\nabla_{\\mathbf{Q}} V(\\mathbf{Q}_n)\\rVert$ 降至阈值 $\\varepsilon$ 以下，或者达到最大步数 $N_{\\max}$。\n\n路径的曲率 $\\kappa$ 衡量其偏离直线的程度。它被定义为单位切向量相对于弧长变化率的大小：$\\kappa(s) = \\lVert d\\mathbf{T}/ds \\rVert$。在数值上，对于在每一步计算出的切向量序列 $\\mathbf{T}_n$，曲率使用有限差分近似：\n$$\n\\kappa_n \\approx \\frac{\\lVert \\mathbf{T}_{n+1} - \\mathbf{T}_n \\rVert}{\\Delta s}\n$$\n其中 $\\mathbf{T}_n$ 是在点 $\\mathbf{Q}_n$ 处的切向量。最大曲率 $\\kappa_{\\max}$ 是通过取包含两个分支的整个路径上 $\\kappa_n$ 的最大值来找到的。\n\n最后，如果 $\\kappa_{\\max} > \\tau$，IRC被分类为“弯曲的”；如果 $\\kappa_{\\max} \\le \\tau$，则分类为“直的”，其中 $\\tau$ 是给定的容差。对于耦合常数 $\\alpha=0$ 的特殊情况，势能在 $x$ 和 $y$ 中是可分离的。初始位移是沿着 $Q_x$ 轴，并且由于如果 $y=0$，沿 $Q_y$ 的梯度分量将始终为零，因此路径保持在 $Q_x$ 轴上。切向量不改变方向，导致曲率为零。对于 $\\alpha \\neq 0$ 的情况，$x$ 和 $y$ 的运动是耦合的。在 $y=0$ 但 $x \\neq 0$ 的点上，梯度有一个非零的 $y$ 分量，导致路径弯曲进入 $Q_y$ 维度。这种曲率的程度取决于参数 $\\alpha$、$m_x$ 和 $m_y$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes an approximation of the Intrinsic Reaction Coordinate (IRC) for a\n    model system, calculates its maximum curvature, and classifies it as\n    'straight' or 'curved' based on a threshold.\n    \"\"\"\n\n    # Test suite: (A, x0, k, alpha, mx, my, tau)\n    test_cases = [\n        (10.0, 0.5, 5.0, 0.0, 1.0, 1.0, 1e-3),\n        (10.0, 0.5, 5.0, 0.5, 1.0, 1.0, 1e-3),\n        (10.0, 0.5, 5.0, 0.5, 1.0, 9.0, 1e-3),\n        (10.0, 0.5, 5.0, 2.0, 1.0, 1.0, 1e-3),\n    ]\n\n    # Numerical parameters\n    delta_s = 0.002\n    epsilon = 1e-8\n    N_max = 5000\n\n    results = []\n\n    for A, x0, k, alpha, mx, my, tau in test_cases:\n        \n        sqrt_mx = np.sqrt(mx)\n        sqrt_my = np.sqrt(my)\n\n        def to_xy(Q):\n            \"\"\"Converts mass-weighted coordinates Q to standard coordinates (x, y).\"\"\"\n            return Q[0] / sqrt_mx, Q[1] / sqrt_my\n\n        def grad_V(x, y):\n            \"\"\"Computes the gradient of V(x, y) in standard coordinates.\"\"\"\n            dv_dx = 4.0 * A * (x**3 - x0**2 * x) + 2.0 * alpha * x * y\n            dv_dy = k * y + alpha * x**2\n            return np.array([dv_dx, dv_dy])\n\n        def mass_weighted_grad_V(Q):\n            \"\"\"Computes the gradient of V in mass-weighted coordinates.\"\"\"\n            x, y = to_xy(Q)\n            grad_xy = grad_V(x, y)\n            return np.array([grad_xy[0] / sqrt_mx, grad_xy[1] / sqrt_my])\n\n        def get_max_kappa_for_branch(initial_direction):\n            \"\"\"\n            Follows one branch of the IRC and computes its maximum curvature.\n            initial_direction is +1.0 for the forward branch, -1.0 for backward.\n            \"\"\"\n            # Initial point displaced from TS along the unstable mode\n            q = np.array([initial_direction * delta_s, 0.0])\n            \n            tangents = []\n            \n            for _ in range(N_max):\n                grad_q = mass_weighted_grad_V(q)\n                grad_norm = np.linalg.norm(grad_q)\n\n                # Check for convergence to a minimum\n                if grad_norm < epsilon:\n                    break\n                \n                # Calculate unit tangent vector\n                t = -grad_q / grad_norm\n                tangents.append(t)\n                \n                # Take Euler step\n                q = q + delta_s * t\n\n            # If the path is too short to compute curvature, curvature is 0\n            if len(tangents) < 2:\n                return 0.0\n            \n            # Compute discrete curvature along the path\n            kappas = []\n            for i in range(len(tangents) - 1):\n                # kappa_n = ||T_{n+1} - T_n|| / delta_s\n                kappa = np.linalg.norm(tangents[i+1] - tangents[i]) / delta_s\n                kappas.append(kappa)\n\n            return max(kappas) if kappas else 0.0\n\n        # Compute max curvature for both branches\n        kappa_max_fwd = get_max_kappa_for_branch(1.0)\n        kappa_max_bwd = get_max_kappa_for_branch(-1.0)\n        \n        # The overall maximum curvature is the max of the two branches\n        kappa_max = max(kappa_max_fwd, kappa_max_bwd)\n        \n        # Classify based on the threshold tau\n        # True for curved, False for straight\n        is_curved = kappa_max > tau\n        results.append(is_curved)\n\n    # Final print statement in the exact required format.\n    # e.g., [True,False,False,True]\n    result_str = \",\".join(str(r) for r in results)\n    print(f\"[{result_str.replace('True', 'True').replace('False', 'False')}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在定义IRC时，为什么要强调“质量加权”坐标？这个练习通过一个巧妙的对比来回答这个问题。你将设计一个正确的、基于质量加权的IRC算法，同时设计一个忽略质量的“错误”算法，并观察它们在特定势能面上产生的路径差异。这个实践将深刻揭示原子质量在决定真实反应路径中的关键作用，让你直观地理解为什么简单的、未加权的陡峭下降路径不足以描述化学反应。",
            "id": "2461314",
            "problem": "给定一个二维势能面 (PES)，由标量场定义在坐标 $\\mathbf{r}=(x,y)$ 上\n$$\nV(x,y) \\;=\\; A\\,x^4 \\;-\\; B\\,x^2 \\;+\\; C\\,y^2 \\;+\\; D\\,x\\,y,\n$$\n其参数 $A>0$，$B>0$，$C>0$ 均为正值，耦合参数 $D$ 为实数。考虑一个具有两个自由度的系统，其质量矩阵为对角矩阵 $\\mathbf{M}=\\mathrm{diag}(m_1,m_2)$，其中 $m_1>0$ 且 $m_2>0$。\n\n对于内禀反应坐标 (IRC)，使用第一性原理定义：正确的 IRC 是 $V$ 在质量加权坐标 $\\mathbf{R}=\\mathbf{M}^{1/2}\\mathbf{r}$ 中的最速下降流，即，\n$$\n\\frac{d\\mathbf{R}}{ds} \\;=\\; - \\nabla_{\\mathbf{R}} V(\\mathbf{R}),\n$$\n其中 $s$ 是一个类弧长的路径参数。等效地，在笛卡尔坐标中，此流为\n$$\n\\frac{d\\mathbf{r}}{ds} \\;=\\; - \\mathbf{M}^{-1}\\,\\nabla_{\\mathbf{r}} V(\\mathbf{r}).\n$$\n一个有缺陷的算法忽略了质量加权，而是遵循非质量加权的笛卡尔最速下降流\n$$\n\\frac{d\\mathbf{r}}{ds} \\;=\\; - \\nabla_{\\mathbf{r}} V(\\mathbf{r}).\n$$\n\n在鞍点 $(x,y)=(0,0)$ 处，定义笛卡尔坐标中的 Hessian 矩阵 $\\mathbf{H}=\\nabla^2_{\\mathbf{r}} V\\big|_{(0,0)}$ 和质量加权的 Hessian 矩阵 $\\mathbf{H}_{\\mathrm{mw}}=\\mathbf{M}^{-1/2}\\,\\mathbf{H}\\,\\mathbf{M}^{-1/2}$。对于初始条件，沿着相应 Hessian 矩阵的非稳定简正模（与唯一的负特征值相关联的特征向量），从 $(0,0)$ 点位移一个微小量 $\\varepsilon>0$，并使用以下方向约定：\n- 对于正确的 IRC 流，定向质量加权的非稳定模，使其在笛卡尔坐标中的 $x$ 分量为正。\n- 对于有缺陷的流，定向未加权的非稳定模，使其 $y$ 分量为正。\n\n让轨迹在各自的流下从其相应的初始条件演化至其终点吸引子（稳定临界点）。根据其趋近的解析极小值点对终点吸引子进行分类。对于给定的 PES，两个对称相关的极小值点位于\n$$\nx_{\\min}^\\star \\;=\\; \\pm \\sqrt{\\frac{2B + \\frac{D^2}{2C}}{4A}}, \n\\qquad\ny_{\\min}^\\star \\;=\\; -\\frac{D}{2C}\\,x_{\\min}^\\star,\n$$\n前提是 $2B + \\frac{D^2}{2C} > 0$（下面的测试参数保证了这一点）。定义极小值点的标签：如果它（在欧几里得距离上）更接近 $x_{\\min}^\\star>0$ 的极小值点，则标签为 $+1$；如果更接近 $x_{\\min}^\\star<0$ 的极小值点，则标签为 $-1$。\n\n对于下方的每个测试用例，确定有缺陷的流是否连接到与正确 IRC 流相同的带标签的极小值点。对于每个测试用例，如果错误的流未能连接到与正确 IRC 流相同的带标签的极小值点，则输出布尔值 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n使用以下参数集测试套件 $(A,B,C,D,m_1,m_2)$：\n- 测试 $1$：$(A,B,C,D,m_1,m_2) = (1.0, 1.0, 1.0, 0.5, 1.0, 1.0)$。\n- 测试 $2$：$(A,B,C,D,m_1,m_2) = (1.0, 1.0, 0.5, -1.0, 1.0, 50.0)$。\n- 测试 $3$：$(A,B,C,D,m_1,m_2) = (1.0, 1.0, 2.0, 0.2, 5.0, 0.5)$。\n\n约定和要求：\n- 对两种流使用相同的微小位移量值 $\\varepsilon=10^{-3}$。\n- 每种流的初始点为 $(x,y)=\\varepsilon\\,\\mathbf{v}$，其中 $\\mathbf{v}$ 是在笛卡尔坐标中表示的、经过适当定向的非稳定模，在按 $\\varepsilon$ 缩放前已归一化为单位长度。\n- 整个程序的输出应为单行，包含按测试顺序列出的三个布尔值的列表，格式化为不带空格的 Python 风格列表，例如：\"[False,True,False]\"。\n\n您的程序应精确地生成一行输出，其中包含所有测试用例的结果，结果为逗号分隔的列表，用方括号括起，并按给定顺序排列：$[result_1,result_2,result_3]$。",
            "solution": "该问题要求在一个二维势能面 (PES) $V(x,y)$ 上比较两条动力学路径。第一条路径是真实的内禀反应坐标 (IRC)，定义为质量加权坐标中的最速下降路径。第二条是一种有缺陷的近似，它遵循非质量加权的笛卡尔坐标中的最速下降路径。我们必须确定这两条从 $(0,0)$ 鞍点附近出发的路径，是否终止于同一个对称相关的势能极小值点。\n\n势能面由下式给出\n$$ V(x,y) = A\\,x^4 - B\\,x^2 + C\\,y^2 + D\\,x\\,y $$\n其中参数 $A, B, C$ 为正值。该系统有两个自由度，坐标为 $\\mathbf{r} = (x,y)$，质量矩阵为对角矩阵 $\\mathbf{M} = \\mathrm{diag}(m_1, m_2)$。\n\n首先，我们为这两种流建立运动方程。势在笛卡尔坐标中的梯度是\n$$ \\nabla_{\\mathbf{r}} V(\\mathbf{r}) = \\begin{pmatrix} \\frac{\\partial V}{\\partial x} \\\\ \\frac{\\partial V}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 4Ax^3 - 2Bx + Dy \\\\ 2Cy + Dx \\end{pmatrix}. $$\n正确的 IRC 流由以下微分方程控制\n$$ \\frac{d\\mathbf{r}}{ds} = - \\mathbf{M}^{-1} \\nabla_{\\mathbf{r}} V(\\mathbf{r}), $$\n其中 $s$ 是一个路径参数，且 $\\mathbf{M}^{-1} = \\mathrm{diag}(1/m_1, 1/m_2)$。\n有缺陷的流遵循更简单的方程\n$$ \\frac{d\\mathbf{r}}{ds} = - \\nabla_{\\mathbf{r}} V(\\mathbf{r}). $$\n\n这些流的初始条件定义为从鞍点 $\\mathbf{r}_0 = (0,0)$ 沿相应 Hessian 矩阵的非稳定简正模的无穷小位移。\n\n鞍点处的笛卡尔 Hessian 矩阵 $\\mathbf{H}$ 是\n$$ \\mathbf{H} = \\nabla^2_{\\mathbf{r}} V\\big|_{(0,0)} = \\begin{pmatrix} \\frac{\\partial^2 V}{\\partial x^2} & \\frac{\\partial^2 V}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 V}{\\partial y \\partial x} & \\frac{\\partial^2 V}{\\partial y^2} \\end{pmatrix}_{\\mathbf{r}=(0,0)} = \\begin{pmatrix} -2B & D \\\\ D & 2C \\end{pmatrix}. $$\n$\\mathbf{H}$ 的行列式为 $-4BC - D^2$，对于 $B, C > 0$ 恒为负。这保证了一个负特征值和一个正特征值，分别对应一个非稳定模和一个稳定模。有缺陷流的初始条件由 $\\mathbf{H}$ 对应其负特征值的特征向量确定。设该特征向量为 $\\mathbf{v}_{\\mathrm{faulty}}$。它被归一化为单位长度，定向使其 $y$ 分量为正，并按 $\\varepsilon = 10^{-3}$ 缩放，得到初始位置 $\\mathbf{r}_{0, \\mathrm{faulty}} = \\varepsilon \\mathbf{v}_{\\mathrm{faulty}}$。\n\n质量加权的 Hessian 矩阵 $\\mathbf{H}_{\\mathrm{mw}}$ 定义为\n$$ \\mathbf{H}_{\\mathrm{mw}} = \\mathbf{M}^{-1/2} \\mathbf{H} \\mathbf{M}^{-1/2} = \\begin{pmatrix} \\frac{-2B}{m_1} & \\frac{D}{\\sqrt{m_1 m_2}} \\\\ \\frac{D}{\\sqrt{m_1 m_2}} & \\frac{2C}{m_2} \\end{pmatrix}, $$\n其中 $\\mathbf{M}^{-1/2} = \\mathrm{diag}(1/\\sqrt{m_1}, 1/\\sqrt{m_2})$。$\\mathbf{H}_{\\mathrm{mw}}$ 的行列式为 $(-4BC - D^2)/(m_1 m_2)$，该值也恒为负，保证了唯一的非稳定模。正确流的初始条件由 $\\mathbf{H}_{\\mathrm{mw}}$ 对应其负特征值的特征向量确定。设该特征向量（在质量加权坐标中）为 $\\mathbf{u}_{\\mathrm{correct}}$。必须通过 $\\mathbf{v}_{\\mathrm{correct}} = \\mathbf{M}^{-1/2} \\mathbf{u}_{\\mathrm{correct}}$ 将其转换回笛卡尔坐标。然后将这个笛卡尔向量归一化，定向使其 $x$ 分量为正，并按 $\\varepsilon$ 缩放，得到初始位置 $\\mathbf{r}_{0, \\mathrm{correct}} = \\varepsilon \\mathbf{v}_{\\mathrm{correct}}$。\n\n定义了常微分方程 (ODE) 和初始条件后，我们在路径参数 $s$ 上对两个系统进行正向数值积分，直到它们收敛到 PES 的一个稳定临界点，即 $\\nabla_{\\mathbf{r}} V = \\mathbf{0}$ 的点。这些点就是势能极小值点。为完成此任务，我们采用了一个鲁棒的数值 ODE 求解器 `scipy.integrate.solve_ivp`。\n\n势 $V(x,y)$ 有两个极小值点，位于 $(\\pm x_{\\min}^\\star, y_{\\min, \\pm}^\\star)$，其中\n$$ x_{\\min}^\\star = \\sqrt{\\frac{2B + D^2/(2C)}{4A}}, \\quad y_{\\min}^\\star = -\\frac{D}{2C} x_{\\min}^\\star. $$\n我们将 $x$ 坐标为正的极小值点记为 $\\mathbf{r}_{\\min, +1}$，将 $x$ 坐标为负的极小值点记为 $\\mathbf{r}_{\\min, -1}$。每个流的终点 $\\mathbf{r}_{\\mathrm{final}}$ 通过分配标签进行分类：若其在欧几里得距离上更接近 $\\mathbf{r}_{\\min, +1}$，则标签为 $+1$；若更接近 $\\mathbf{r}_{\\min, -1}$，则标签为 $-1$。\n\n对于每组参数 $(A, B, C, D, m_1, m_2)$，我们执行以下步骤：\n1.  计算 $\\mathbf{H}$ 和 $\\mathbf{H}_{\\mathrm{mw}}$。\n2.  在笛卡尔坐标中找出非稳定特征向量 $\\mathbf{v}_{\\mathrm{faulty}}$ 和 $\\mathbf{v}_{\\mathrm{correct}}$，并应用指定的方向规则。\n3.  确定初始位置 $\\mathbf{r}_{0, \\mathrm{faulty}}$ 和 $\\mathbf{r}_{0, \\mathrm{correct}}$。\n4.  对两种流的 ODE 进行数值求解，以找到终点 $\\mathbf{r}_{\\mathrm{final, faulty}}$ 和 $\\mathbf{r}_{\\mathrm{final, correct}}$。\n5.  计算两个极小值点的位置 $\\mathbf{r}_{\\min, +1}$ 和 $\\mathbf{r}_{\\min, -1}$。\n6.  通过比较终点到两个极小值点的距离来分配标签 $L_{\\mathrm{faulty}}$ 和 $L_{\\mathrm{correct}}$。\n7.  该测试用例的结果是表达式 $L_{\\mathrm{faulty}} \\neq L_{\\mathrm{correct}}$ 的布尔值。\n\n整个逻辑在一个 Python 脚本中实现，该脚本会遍历所提供的测试用例并生成最终的布尔值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (A,   B,   C,   D,   m1,  m2)\n        (1.0, 1.0, 1.0,  0.5, 1.0,  1.0),\n        (1.0, 1.0, 0.5, -1.0, 1.0, 50.0),\n        (1.0, 1.0, 2.0,  0.2, 5.0,  0.5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_case(params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_case(params):\n    \"\"\"\n    Solves a single test case.\n    \n    For each test case, determines whether the faulty flow fails to connect to the\n    same labeled minimum as the correct IRC flow. Returns True if they fail\n    (connect to different minima), False otherwise.\n    \"\"\"\n    A, B, C, D, m1, m2 = params\n    epsilon = 1e-3\n\n    # =========================================================================\n    # Step 1: Define PES, gradient, and analytical minima locations\n    # =========================================================================\n    def grad_V(r):\n        x, y = r\n        gx = 4 * A * x**3 - 2 * B * x + D * y\n        gy = 2 * C * y + D * x\n        return np.array([gx, gy])\n\n    x_min_sq_val = (2 * B + D**2 / (2 * C)) / (4 * A)\n    x_min_pos = np.sqrt(x_min_sq_val)\n    y_min_pos = -D / (2 * C) * x_min_pos\n    min_p1 = np.array([x_min_pos, y_min_pos])\n    min_m1 = -min_p1\n\n    # =========================================================================\n    # Step 2: Determine initial conditions for both flows\n    # =========================================================================\n    H = np.array([[-2 * B, D], [D, 2 * C]])\n    \n    # --- Faulty (unweighted) flow initial condition ---\n    eigvals_faulty, eigvecs_faulty = np.linalg.eig(H)\n    unstable_idx_faulty = np.argmin(eigvals_faulty)\n    v_faulty = eigvecs_faulty[:, unstable_idx_faulty].real\n\n    v_faulty /= np.linalg.norm(v_faulty)\n    if v_faulty[1] < 0:\n        v_faulty = -v_faulty\n    \n    r0_faulty = epsilon * v_faulty\n\n    # --- Correct (mass-weighted) IRC flow initial condition ---\n    M_inv_sqrt = np.diag([1/np.sqrt(m1), 1/np.sqrt(m2)])\n    H_mw = M_inv_sqrt @ H @ M_inv_sqrt\n    \n    eigvals_mw, eigvecs_mw = np.linalg.eig(H_mw)\n    unstable_idx_mw = np.argmin(eigvals_mw)\n    u_correct = eigvecs_mw[:, unstable_idx_mw].real # Eigenvector in mass-weighted coords\n\n    v_correct = M_inv_sqrt @ u_correct # Convert to Cartesian coords\n    \n    v_correct /= np.linalg.norm(v_correct)\n    if v_correct[0] < 0:\n        v_correct = -v_correct\n    \n    r0_correct = epsilon * v_correct\n\n    # =========================================================================\n    # Step 3: Simulate the flows using an ODE solver\n    # =========================================================================\n    def ode_faulty(t, r):\n        return -grad_V(r)\n    \n    M_inv = np.diag([1/m1, 1/m2])\n    def ode_correct(t, r):\n        return -M_inv @ grad_V(r)\n    \n    t_span = [0, 500]\n    t_eval = [t_span[1]]\n    \n    # We only care about the final state, so we evaluate only there.\n    # High tolerance is used for accuracy near the minimum.\n    sol_faulty = solve_ivp(ode_faulty, t_span, r0_faulty, method='RK45', \n                           t_eval=t_eval, atol=1e-9, rtol=1e-9)\n    r_final_faulty = sol_faulty.y[:, -1]\n\n    sol_correct = solve_ivp(ode_correct, t_span, r0_correct, method='RK45', \n                            t_eval=t_eval, atol=1e-9, rtol=1e-9)\n    r_final_correct = sol_correct.y[:, -1]\n\n    # =========================================================================\n    # Step 4: Classify the terminal attractors\n    # =========================================================================\n    def get_label(r_final):\n        \"\"\"Assigns label +1 or -1 based on proximity to analytical minima.\"\"\"\n        dist_to_p1 = np.linalg.norm(r_final - min_p1)\n        dist_to_m1 = np.linalg.norm(r_final - min_m1)\n        return 1 if dist_to_p1 < dist_to_m1 else -1\n\n    label_faulty = get_label(r_final_faulty)\n    label_correct = get_label(r_final_correct)\n\n    # =========================================================================\n    # Step 5: Compare labels and return the boolean result\n    # =========================================================================\n    return label_faulty != label_correct\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "计算出内禀反应坐标（IRC）后，我们如何将其与化学家的直觉联系起来？这个练习将教你如何解读IRC向量的物理意义。你将分析HCN异构化为HNC的过渡态，并量化IRC向量中特定化学键（C-N键）伸缩运动的贡献。这个练习是连接抽象数学描述与具体化学图像的关键一步，帮助你理解反应坐标是如何由原子级别的协同运动构成的。",
            "id": "2461347",
            "problem": "请考虑氰化氢 (HCN) 异构化为异氰化氢 (HNC) 的反应，该反应发生在一个具有一阶鞍点（过渡态）的势能面上。在过渡态处的内禀反应坐标 (IRC) 切线被定义为与质量加权Hessian矩阵的单一负特征值相关联的归一化特征向量。设该分子由氢 (H)、碳 (C) 和氮 (N) 三个原子按此顺序组成。对于任意笛卡尔位移向量 $x \\in \\mathbb{R}^{9}$ (其分量顺序为 $[x_{\\mathrm{H}x},x_{\\mathrm{H}y},x_{\\mathrm{H}z},x_{\\mathrm{C}x},x_{\\mathrm{C}y},x_{\\mathrm{C}z},x_{\\mathrm{N}x},x_{\\mathrm{N}y},x_{\\mathrm{N}z}]$)，定义质量加权坐标 $q$ 为 $q = M^{1/2} x$，其中 $M^{1/2}$ 是一个对角矩阵，其对角线元素为 $\\sqrt{m_i}$，并对原子 $i$ 的三个笛卡尔分量重复，而 $m_i$ 是原子质量。所有长度必须以埃（angstrom）为单位，所有质量必须以统一原子质量单位为单位。\n\n设过渡态下三个原子的笛卡尔坐标（单位为埃）固定如下：\n- $R_{\\mathrm{H}} = (-0.200, 0.000, 0.900)$,\n- $R_{\\mathrm{C}} = (0.000, 0.000, 0.000)$,\n- $R_{\\mathrm{N}} = (1.160, 0.000, 0.000)$.\n原子质量（单位为统一原子质量单位）如下：\n- $m_{\\mathrm{H}} = 1.008$,\n- $m_{\\mathrm{C}} = 12.000$,\n- $m_{\\mathrm{N}} = 14.000$.\n\n定义沿碳-氮 (C-N) 键的单位向量为\n$$\n\\hat{u}_{\\mathrm{CN}} = \\frac{R_{\\mathrm{N}} - R_{\\mathrm{C}}}{\\lVert R_{\\mathrm{N}} - R_{\\mathrm{C}} \\rVert}.\n$$\n将C-N键的归一化笛卡尔键伸缩位移方向定义为一个9维向量\n$$\n\\hat{d} = \\frac{1}{\\sqrt{2}}\\left(0,0,0,\\,-\\hat{u}_{\\mathrm{CN},x},-\\hat{u}_{\\mathrm{CN},y},-\\hat{u}_{\\mathrm{CN},z},\\,\\hat{u}_{\\mathrm{CN},x},\\hat{u}_{\\mathrm{CN},y},\\hat{u}_{\\mathrm{CN},z}\\right),\n$$\n该向量对应于在笛卡尔空间中，当氢原子固定时，一个纯粹的、单位范数的C-N伸缩运动。\n\n对于一个给定的IRC切线，它在质量加权坐标中表示为单位向量 $v^{(\\mathrm{mw})} \\in \\mathbb{R}^{9}$ 且 $\\lVert v^{(\\mathrm{mw})} \\rVert = 1$，定义其对应的归一化笛卡尔位移方向 $\\hat{u}_x$ 为\n$$\nu_x = M^{-1/2} v^{(\\mathrm{mw})}, \\quad \\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert}.\n$$\n通过投影的平方来量化C-N键长对IRC向量的分数贡献\n$$\nf = \\left(\\hat{d} \\cdot \\hat{u}_x \\right)^2,\n$$\n这是一个在 $[0,1]$ 区间内的无量纲数。对于给定的阈值 $\\tau$，如果 $f \\ge \\tau$，则判定C-N键长是IRC向量的一个重要组分。\n\n您的任务是编写一个程序，对下面的每个测试用例计算 $f$ 的值，并使用阈值 $\\tau = 0.5$ 返回一个指示其重要性的布尔值。\n\n测试套件。每个测试用例提供一个笛卡尔位移模式 $v^{(\\mathrm{cart})}$；相应的质量加权IRC切线是归一化的质量加权向量\n$$\nv^{(\\mathrm{mw})} = \\frac{M^{1/2} v^{(\\mathrm{cart})}}{\\lVert M^{1/2} v^{(\\mathrm{cart})} \\rVert}.\n$$\n所有情况均使用上述固定的几何结构和质量。\n\n- 情况 1 (主要为C-N伸缩):\n  $v^{(\\mathrm{cart})}$ 的分量为\n  $$\n  v^{(\\mathrm{cart})}_{\\mathrm{H}} = (0,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{C}} = (-1,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{N}} = (+1,0,0).\n  $$\n\n- 情况 2 (类似氢转移，C-N伸缩最小):\n  $v^{(\\mathrm{cart})}$ 的分量为\n  $$\n  v^{(\\mathrm{cart})}_{\\mathrm{H}} = (1,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{C}} = (0.2,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{N}} = (0.2,0,0).\n  $$\n\n- 情况 3 (混合C-N伸缩和平面内弯曲，边界情况):\n  令 $\\hat{e}_x = (1,0,0)$ 且 $\\hat{e}_y = (0,1,0)$。对于给定的几何结构，有 $\\hat{u}_{\\mathrm{CN}} = \\hat{e}_x$，定义\n  $$\n  v^{(\\mathrm{cart})}_{\\mathrm{H}} = (0,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{C}} = \\left(-\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}},\\,0\\right),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{N}} = \\left(+\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}},\\,0\\right).\n  $$\n\n最终输出格式。您的程序应生成单行输出，其中包含三个用例的布尔结果，按顺序排列，以逗号分隔并用方括号括起，无空格，例如：\"[True,False,True]\"。不应打印任何其他文本。",
            "solution": "该问题要求将一个给定的化学反应坐标与一个特定的内坐标（即碳-氮键伸缩）进行验证。这是计算化学中分析振动简正模式性质或（如此例中）内禀反应坐标（IRC）性质的标准程序。过渡态处的IRC描述了从势能面上的一阶鞍点下降至反应物和产物的最速下降路径。其切向量指明了穿过过渡态能垒所涉及的主要原子运动。我们的任务是为给定的三种情况计算C-N键伸缩对此切向量的分数贡献。\n\n该问题在科学上和计算上都是良定的。所有必要数据，包括原子质量、过渡态几何结构的笛卡尔坐标以及所有相关向量和度量的定义，都已明确给出。其基本原理——坐标的质量加权、向量归一化和投影——是经典力学和线性代数中的基本概念，并被正确地应用于化学物理背景中。因此，该问题是有效的。\n\n我们将对每个测试用例进行系统、分步的计算。\n\n首先，我们根据所提供的几何结构和质量，确定常数参数和向量。\n原子质量给定为 $m_{\\mathrm{H}} = 1.008$ u, $m_{\\mathrm{C}} = 12.000$ u, 和 $m_{\\mathrm{N}} = 14.000$ u。这些值用于构建对角质量加权矩阵 $M^{1/2}$ 及其逆矩阵 $M^{-1/2}$。对于一个9维笛卡尔位移向量 $x \\in \\mathbb{R}^{9}$，相应的质量加权向量为 $q = M^{1/2} x$。$M^{1/2}$ 的对角元素为 $(\\sqrt{m_{\\mathrm{H}}}, \\sqrt{m_{\\mathrm{H}}}, \\sqrt{m_{\\mathrm{H}}}, \\sqrt{m_{\\mathrm{C}}}, \\sqrt{m_{\\mathrm{C}}}, \\sqrt{m_{\\mathrm{C}}}, \\sqrt{m_{\\mathrm{N}}}, \\sqrt{m_{\\mathrm{N}}}, \\sqrt{m_{\\mathrm{N}}})$。\n\n过渡态坐标为 $R_{\\mathrm{H}} = (-0.200, 0.000, 0.900)$ Å, $R_{\\mathrm{C}} = (0.000, 0.000, 0.000)$ Å, 和 $R_{\\mathrm{N}} = (1.160, 0.000, 0.000)$ Å。\n\n沿碳-氮键的单位向量 $\\hat{u}_{\\mathrm{CN}}$ 计算如下：\n$$\nR_{\\mathrm{N}} - R_{\\mathrm{C}} = (1.160, 0.000, 0.000) - (0.000, 0.000, 0.000) = (1.160, 0.000, 0.000)\n$$\n$$\n\\lVert R_{\\mathrm{N}} - R_{\\mathrm{C}} \\rVert = \\sqrt{1.160^2 + 0^2 + 0^2} = 1.160\n$$\n$$\n\\hat{u}_{\\mathrm{CN}} = \\frac{(1.160, 0.000, 0.000)}{1.160} = (1, 0, 0)\n$$\n这个向量 $\\hat{u}_{\\mathrm{CN}}$ 用于定义归一化的笛卡尔C-N键伸缩位移方向 $\\hat{d}$，它作为我们C-N伸缩运动的参考向量。\n$$\n\\hat{d} = \\frac{1}{\\sqrt{2}}\\left(0,0,0,\\,-\\hat{u}_{\\mathrm{CN},x},-\\hat{u}_{\\mathrm{CN},y},-\\hat{u}_{\\mathrm{CN},z},\\,\\hat{u}_{\\mathrm{CN},x},\\hat{u}_{\\mathrm{CN},y},\\hat{u}_{\\mathrm{CN},z}\\right)\n$$\n代入 $\\hat{u}_{\\mathrm{CN}} = (1, 0, 0)$，我们得到：\n$$\n\\hat{d} = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1, 0, 0, 1, 0, 0)\n$$\n该向量在笛卡尔空间中是归一化的，即 $\\lVert \\hat{d} \\rVert = 1$。\n\n对于每个测试用例，我们给定一个笛卡尔位移模式 $v^{(\\mathrm{cart})}$，并且必须执行以下一系列操作：\n$1$. 计算质量加权向量 $v' = M^{1/2} v^{(\\mathrm{cart})}$。\n$2$. 将其归一化，以获得质量加权坐标中的IRC切线：$v^{(\\mathrm{mw})} = v' / \\lVert v' \\rVert$。\n$3$. 将 $v^{(\\mathrm{mw})}$ 转换回笛卡尔位移向量： $u_x = M^{-1/2} v^{(\\mathrm{mw})}$。\n$4$. 将此笛卡尔向量归一化，以获得单位方向：$\\hat{u}_x = u_x / \\lVert u_x \\rVert$。\n$5$. 以投影的平方计算C-N伸缩的分数贡献：$f = (\\hat{d} \\cdot \\hat{u}_x)^2$。\n$6$. 将 $f$ 与阈值 $\\tau = 0.5$ 比较，以确定其重要性。\n\n现在，我们将此程序应用于每种情况。\n\n情况 1：主要为C-N伸缩\n$v^{(\\mathrm{cart})} = (0, 0, 0, -1, 0, 0, 1, 0, 0)$。\n$1$. 质量加权: $v' = (0, 0, 0, -1\\sqrt{m_{\\mathrm{C}}}, 0, 0, 1\\sqrt{m_{\\mathrm{N}}}, 0, 0) = (0, 0, 0, -\\sqrt{12.000}, 0, 0, \\sqrt{14.000}, 0, 0)$。\n$2$. 归一化: $\\lVert v' \\rVert = \\sqrt{(-\\sqrt{12.000})^2 + (\\sqrt{14.000})^2} = \\sqrt{12.000 + 14.000} = \\sqrt{26.000}$。\n$v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -\\sqrt{12.000}, 0, 0, \\sqrt{14.000}, 0, 0)$。\n$3$. 转换为笛卡尔坐标: $u_x = M^{-1/2} v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -1, 0, 0, 1, 0, 0)$。\n$4$. 归一化: $\\lVert u_x \\rVert = \\frac{1}{\\sqrt{26.000}}\\sqrt{(-1)^2 + 1^2} = \\frac{\\sqrt{2}}{\\sqrt{26.000}} = \\frac{1}{\\sqrt{13.000}}$。\n$\\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert} = \\sqrt{13.000} \\cdot \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -1, 0, 0, 1, 0, 0) = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1, 0, 0, 1, 0, 0)$。\n$5$. 投影: 我们观察到 $\\hat{u}_x = \\hat{d}$。因此, $\\hat{d} \\cdot \\hat{u}_x = \\hat{d} \\cdot \\hat{d} = \\lVert \\hat{d} \\rVert^2 = 1$。\n$f = 1^2 = 1$。\n$6$. 重要性： $f = 1 \\ge 0.5$。结果为 True。\n\n情况 2: 类似氢转移\n$v^{(\\mathrm{cart})} = (1, 0, 0, 0.2, 0, 0, 0.2, 0, 0)$。\n$1$. 质量加权: $v' = (1\\sqrt{m_{\\mathrm{H}}}, 0, 0, 0.2\\sqrt{m_{\\mathrm{C}}}, 0, 0, 0.2\\sqrt{m_{\\mathrm{N}}}, 0, 0) = (\\sqrt{1.008}, 0, 0, 0.2\\sqrt{12.000}, 0, 0, 0.2\\sqrt{14.000}, 0, 0)$。\n$2$. 归一化: $\\lVert v' \\rVert^2 = 1.008 + (0.2)^2(12.000) + (0.2)^2(14.000) = 1.008 + 0.04(12.000) + 0.04(14.000) = 1.008 + 0.480 + 0.560 = 2.048$。\n$\\lVert v' \\rVert = \\sqrt{2.048}$。\n$v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{2.048}}(\\sqrt{1.008}, 0, 0, 0.2\\sqrt{12.000}, 0, 0, 0.2\\sqrt{14.000}, 0, 0)$。\n$3$. 转换为笛卡尔坐标: $u_x = M^{-1/2} v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{2.048}}(1, 0, 0, 0.2, 0, 0, 0.2, 0, 0)$。\n$4$. 归一化: $\\lVert u_x \\rVert^2 = \\frac{1}{2.048}(1^2 + 0.2^2 + 0.2^2) = \\frac{1.08}{2.048}$。\n$\\lVert u_x \\rVert = \\sqrt{\\frac{1.08}{2.048}}$。\n$\\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert} = \\frac{1}{\\sqrt{1.08}}(1, 0, 0, 0.2, 0, 0, 0.2, 0, 0)$。\n$5$. 投影: $\\hat{d} \\cdot \\hat{u}_x = \\frac{1}{\\sqrt{2}} \\cdot \\frac{1}{\\sqrt{1.08}} \\left[ (-1)(0.2) + (1)(0.2) \\right] = 0$。\n$f = 0^2 = 0$。\n$6$. 重要性: $f = 0 < 0.5$。结果为 False。\n\n情况 3: 混合伸缩和弯曲\n$v^{(\\mathrm{cart})} = (0, 0, 0, -1/\\sqrt{2}, 1/\\sqrt{2}, 0, 1/\\sqrt{2}, 1/\\sqrt{2}, 0)$。\n$1$. 质量加权: $v'_C = (-\\frac{\\sqrt{m_{\\mathrm{C}}}}{\\sqrt{2}}, \\frac{\\sqrt{m_{\\mathrm{C}}}}{\\sqrt{2}}, 0)$, $v'_N = (\\frac{\\sqrt{m_{\\mathrm{N}}}}{\\sqrt{2}}, \\frac{\\sqrt{m_{\\mathrm{N}}}}{\\sqrt{2}}, 0)$。\n$2$. 归一化: $\\lVert v' \\rVert^2 = \\frac{1}{2}(m_{\\mathrm{C}} + m_{\\mathrm{C}} + m_{\\mathrm{N}} + m_{\\mathrm{N}}) = m_{\\mathrm{C}} + m_{\\mathrm{N}} = 12.000 + 14.000 = 26.000$。\n$\\lVert v' \\rVert = \\sqrt{26.000}$。\n$v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -\\frac{\\sqrt{12}}{\\sqrt{2}}, \\frac{\\sqrt{12}}{\\sqrt{2}}, 0, \\frac{\\sqrt{14}}{\\sqrt{2}}, \\frac{\\sqrt{14}}{\\sqrt{2}}, 0)$。\n$3$. 转换为笛卡尔坐标: $u_x = M^{-1/2} v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -1/\\sqrt{2}, 1/\\sqrt{2}, 0, 1/\\sqrt{2}, 1/\\sqrt{2}, 0)$。\n$4$. 归一化: $\\lVert u_x \\rVert^2 = \\frac{1}{26.000} \\left( (-\\frac{1}{\\sqrt{2}})^2 + (\\frac{1}{\\sqrt{2}})^2 + (\\frac{1}{\\sqrt{2}})^2 + (\\frac{1}{\\sqrt{2}})^2 \\right) = \\frac{1}{26.000}(\\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2}) = \\frac{2}{26.000} = \\frac{1}{13.000}$。\n$\\lVert u_x \\rVert = \\frac{1}{\\sqrt{13.000}}$。\n$\\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert} = \\sqrt{13.000} \\cdot \\frac{v^{(\\mathrm{cart})}}{\\sqrt{26.000}} = \\frac{1}{\\sqrt{2}} v^{(\\mathrm{cart})}$。\n$\\hat{u}_x = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1/\\sqrt{2}, 1/\\sqrt{2}, 0, 1/\\sqrt{2}, 1/\\sqrt{2}, 0)$。\n$5$. 投影: $\\hat{d} = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1, 0, 0, 1, 0, 0)$。\n$\\hat{d} \\cdot \\hat{u}_x = \\frac{1}{\\sqrt{2}} \\cdot \\frac{1}{\\sqrt{2}} \\left[ (-1)(-\\frac{1}{\\sqrt{2}}) + (1)(\\frac{1}{\\sqrt{2}}) \\right] = \\frac{1}{2}\\left[\\frac{1}{\\sqrt{2}} + \\frac{1}{\\sqrt{2}}\\right] = \\frac{1}{2}\\left[\\frac{2}{\\sqrt{2}}\\right] = \\frac{1}{\\sqrt{2}}$。\n$f = (\\frac{1}{\\sqrt{2}})^2 = \\frac{1}{2} = 0.5$。\n$6$. 重要性: $f = 0.5 \\ge 0.5$。结果为 True。\n\n三种情况的最终布尔结果是 [True, False, True]。以下程序实现了这一逻辑以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining the significance of the C-N bond stretch\n    in a given reaction coordinate for the isomerization of HCN to HNC.\n    \"\"\"\n    \n    # Define constants and fixed geometry from the problem statement.\n    # Atomic masses in unified atomic mass units (u).\n    masses = {\n        'H': 1.008,\n        'C': 12.000,\n        'N': 14.000\n    }\n    \n    # Transition state coordinates in angstroms.\n    # Not explicitly needed for the calculation of d_hat as u_cn is simple.\n    # R_H = np.array([-0.200, 0.000, 0.900])\n    # R_C = np.array([0.000, 0.000, 0.000])\n    # R_N = np.array([1.160, 0.000, 0.000])\n\n    # Threshold for significance.\n    tau = 0.5\n\n    # Define the normalized C-N bond-stretch displacement direction, d_hat.\n    # From the problem, R_N - R_C is along the x-axis.\n    # So, u_cn = [1, 0, 0].\n    u_cn = np.array([1.0, 0.0, 0.0])\n    \n    # d_hat is a 9-vector in Cartesian space.\n    # [H_x, H_y, H_z, C_x, C_y, C_z, N_x, N_y, N_z]\n    d_hat = np.zeros(9)\n    d_hat[3:6] = -u_cn  # Displacement for Carbon atom\n    d_hat[6:9] = u_cn   # Displacement for Nitrogen atom\n    d_hat /= np.linalg.norm(d_hat) # Normalize to unit length\n\n    # Define the test cases.\n    v_cart_cases = [\n        # Case 1: dominant C-N stretch\n        np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0]),\n\n        # Case 2: hydrogen transfer-like, minimal C-N stretch\n        np.array([1.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.2, 0.0, 0.0]),\n\n        # Case 3: mixed C-N stretch and in-plane bend\n        np.array([0.0, 0.0, 0.0, -1.0/np.sqrt(2), 1.0/np.sqrt(2), 0.0, 1.0/np.sqrt(2), 1.0/np.sqrt(2), 0.0])\n    ]\n\n    # Create the 9D mass vector for mass-weighting operations.\n    # Order: [m_H, m_H, m_H, m_C, m_C, m_C, m_N, m_N, m_N]\n    mass_vec_9d = np.repeat([masses['H'], masses['C'], masses['N']], 3)\n    \n    M_sqrt_diag = np.sqrt(mass_vec_9d)\n    M_inv_sqrt_diag = 1.0 / M_sqrt_diag\n\n    results = []\n    for v_cart in v_cart_cases:\n        # Step 1: Compute the mass-weighted vector v_prime.\n        v_prime = v_cart * M_sqrt_diag\n        \n        # Step 2: Normalize to get the IRC tangent in mass-weighted coordinates (v_mw).\n        v_prime_norm = np.linalg.norm(v_prime)\n        if v_prime_norm == 0:\n            # Handle the case of a zero vector, though not expected here.\n            results.append(False)\n            continue\n        v_mw = v_prime / v_prime_norm\n        \n        # Step 3: Transform v_mw back to a Cartesian displacement vector (u_x).\n        u_x = v_mw * M_inv_sqrt_diag\n        \n        # Step 4: Normalize this Cartesian vector to get the unit direction (u_x_hat).\n        u_x_norm = np.linalg.norm(u_x)\n        if u_x_norm == 0:\n            results.append(False)\n            continue\n        u_x_hat = u_x / u_x_norm\n        \n        # Step 5: Calculate the fractional contribution f.\n        f = (np.dot(d_hat, u_x_hat))**2\n        \n        # Step 6: Compare f with the threshold tau.\n        is_significant = f >= tau\n        results.append(is_significant)\n\n    # Format and print the final output as specified.\n    # Example: [True,False,True]\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}