{
    "hands_on_practices": [
        {
            "introduction": "在进行任何分子动力学模拟之前，首要任务是确保数值积分的稳定性。这个实践将引导你探索积分时间步长 $\\Delta t$ 的选择与系统最高振动频率 $\\omega_{\\max}$ 之间的关键关系。通过亲手操作，你将直观地理解为什么不恰当的时间步长会导致能量不守恒和模拟崩溃，这是所有AIMD研究的基石。",
            "id": "2448283",
            "problem": "从头算分子动力学 (AIMD) 遵循在通过电子结构理论获得的电子势能面上的经典核运动。考虑一个近似于分子最快振动模式的单个核自由度。将此模式建模为一个一维谐振子，其质量为 $m$，角频率为 $\\omega_{\\max}$，在势 $V(x) = \\tfrac{1}{2} k x^2$ 上运动，其中 $k = m \\omega_{\\max}^2$。使用约化的无量纲单位，其中 $m = 1$，因此 $k = \\omega_{\\max}^2$。初始条件为 $x(0) = x_0$ 和 $v(0) = v_0$。令第 $n$ 步的离散总能量为\n$$\nE_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2,\n$$\n并将 $N$ 步轨迹上的最大相对能量漂移定义为\n$$\n\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}.\n$$\n如果 $\\delta_{\\max}  \\eta$，则轨迹被标记为“不稳定”，否则为“稳定”，其中 $\\eta$ 是一个给定的正阈值。所有量都是无量纲的，不需要物理单位。\n\n任务：编写一个完整、可运行的程序，对下方的每个测试用例，使用恒定的时间步长 $\\Delta t$ 对运动进行 $N$ 步的数值积分，计算 $\\delta_{\\max}$，并根据上述定义输出一个布尔值，以指示轨迹是否不稳定。\n\n您必须使用以下测试套件，其中每个用例是一个元组 $(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$：\n- 案例 1：$(\\omega_{\\max} = 1.0, \\Delta t = 0.5, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 案例 2：$(\\omega_{\\max} = 1.0, \\Delta t = 2.0, N = 1000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 案例 3：$(\\omega_{\\max} = 1.0, \\Delta t = 2.1, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 案例 4：$(\\omega_{\\max} = 3.0, \\Delta t = 0.8, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 案例 5：$(\\omega_{\\max} = 3.0, \\Delta t = 0.2, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的布尔值不稳定性结果，形式为按上述案例顺序排列、用方括号括起来的逗号分隔列表，例如 `[True,False,True]`。",
            "solution": "首先对问题陈述进行严格验证。\n\n给定条件如下：\n- **系统**：模拟单个核自由度的一维谐振子。\n- **势能**：$V(x) = \\tfrac{1}{2} k x^2$。\n- **质量和力常数**：在约化的无量纲单位中，质量 $m = 1$，力常数 $k = \\omega_{\\max}^2$。\n- **运动方程**：根据 Newton 第二定律，$m\\ddot{x} = F(x)$，其中 $F(x) = -\\frac{dV}{dx} = -kx$。当 $m=1$ 时，方程变为 $\\ddot{x} = -\\omega_{\\max}^2 x$。\n- **初始条件**：$x(0) = x_0$ 和 $v(0) = v_0$。\n- **离散总能量**：在每个时间步 $n$，能量为 $E_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2$。\n- **最大相对能量漂移**：一种数值误差的度量，定义为 $\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}$。\n- **不稳定性判据**：如果 $\\delta_{\\max}  \\eta$，则轨迹为“不稳定”，其中 $\\eta$ 是一个指定的正阈值。\n- **任务**：对于几个测试用例，使用时间步长 $\\Delta t$ 对系统进行 $N$ 步的数值积分，并确定所得轨迹是否不稳定。\n\n验证结论是，所陈述的问题是不适定的。它存在一个关键的遗漏：没有指定数值积分算法。积分器（例如 Euler、Runge-Kutta、Verlet）的选择对解决方案至关重要，因为不同的算法会产生不同的轨迹 $(x_n, v_n)$，从而导致不同的能量漂移 $\\delta_{\\max}$。对于一个数值物理学问题，未能指定数值方法是一个严重的缺陷（违反了**不适定或结构不良**判据）。\n\n然而，该问题处于*从头算分子动力学* (AIMD) 的背景下。在该领域，**速度 Verlet 算法**是一种标准且广泛使用的方法，因为它具有时间可逆性、辛性质（相空间体积守恒）以及对哈密顿系统出色的长期能量守恒性。此外，所提供的测试用例似乎是专门为探究速度 Verlet 算法应用于谐振子时的众所周知的稳定性极限而设计的，即 $\\omega_{\\max} \\Delta t \\le 2$。对于超过此极限的 $\\omega_{\\max} \\Delta t$ 值，该算法会变得数值不稳定，能量会发散。这提供了强有力的上下文证据，表明速度 Verlet 算法是预定使用的方法。通过做出这个专业上合理的假设，问题变得适定且可解。\n\n因此，我们着手采用速度 Verlet 算法。将系统从时间步 $n$ 推进到 $n+1$ 的更新方程是：\n1. 更新位置：$$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n2. 更新速度：$$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n其中 $\\Delta t$ 是时间步长，$a_n$ 是第 $n$ 步的加速度。对于我们的谐振子，加速度是位置的函数：$a(x) = -\\omega_{\\max}^2 x$。因此，$a_n = -\\omega_{\\max}^2 x_n$ 且 $a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n\n每个测试用例的计算步骤如下：\n1. 使用给定参数 $(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$ 初始化系统状态。设置 $x_n = x_0$ 和 $v_n = v_0$。\n2. 计算初始能量 $E_0 = \\tfrac{1}{2} v_0^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_0^2$。由于所有测试用例都具有非零的初始势能，因此 $E_0$ 非零，从而防止在漂移计算中出现除以零的情况。将最大相对漂移 $\\delta_{\\max}$ 初始化为 $0$。\n3. 进入一个循环以执行 $N$ 个积分步。对于从 $n=0$ 到 $N-1$ 的每一步：\n    a. 计算当前位置的加速度：$a_n = -\\omega_{\\max}^2 x_n$。\n    b. 使用第一个 Verlet 方程更新位置以获得 $x_{n+1}$。\n    c. 计算更新后位置的新加速度：$a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n    d. 使用第二个 Verlet 方程更新速度以获得 $v_{n+1}$。\n    e. 计算新的总能量 $E_{n+1} = \\tfrac{1}{2} v_{n+1}^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_{n+1}^2$。\n    f. 计算此步的相对能量漂移 $\\frac{\\lvert E_{n+1} - E_0 \\rvert}{E_0}$。\n    g. 如果当前漂移大于存储的最大值，则更新 $\\delta_{\\max}$。\n    h. 将当前状态 $(x_n, v_n)$ 设置为新状态 $(x_{n+1}, v_{n+1})$ 以进行下一次迭代。\n4. 循环完成后，将最终的 $\\delta_{\\max}$ 与不稳定性阈值 $\\eta$ 进行比较。如果 $\\delta_{\\max}  \\eta$，则轨迹被归类为不稳定（`True`）；否则，为稳定（`False`）。\n\n此过程被系统地应用于每个测试用例，以生成所需的布尔值结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(omega_max, dt, N, x0, v0, eta):\n    \"\"\"\n    Numerically integrates a 1D harmonic oscillator using the Velocity Verlet\n    algorithm and determines if the trajectory is unstable based on energy drift.\n\n    Args:\n        omega_max (float): Angular frequency of the oscillator.\n        dt (float): Time step for integration.\n        N (int): Number of integration steps.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        eta (float): Relative energy drift threshold for instability.\n\n    Returns:\n        bool: True if the trajectory is unstable, False otherwise.\n    \"\"\"\n    # Current state variables\n    x = x0\n    v = v0\n\n    # Constant for the potential, k = omega_max^2\n    k = omega_max**2\n\n    # Calculate initial energy E0\n    E0 = 0.5 * v**2 + 0.5 * k * x**2\n\n    # If the system starts at rest at the equilibrium position,\n    # it will not move, and the energy drift will be zero. It is stable.\n    # This also prevents division by zero if E0 is 0.\n    if E0 == 0:\n        return False\n\n    max_rel_drift = 0.0\n\n    # Initial acceleration\n    a = -k * x\n\n    # Simulation loop for N steps\n    for _ in range(N):\n        # Velocity Verlet integration\n        # 1. Update position\n        x_new = x + v * dt + 0.5 * a * dt**2\n\n        # 2. Calculate acceleration at the new position\n        a_new = -k * x_new\n\n        # 3. Update velocity\n        v_new = v + 0.5 * (a + a_new) * dt\n\n        # Update state for the next iteration\n        x, v, a = x_new, v_new, a_new\n\n        # Calculate the energy at the new step n\n        E_n = 0.5 * v**2 + 0.5 * k * x**2\n\n        # Calculate relative energy drift\n        rel_drift = np.abs(E_n - E0) / E0\n\n        # Update the maximum observed drift\n        if rel_drift > max_rel_drift:\n            max_rel_drift = rel_drift\n    \n    # Check for instability\n    is_unstable = max_rel_drift > eta\n    return is_unstable\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all specified test cases and prints the results.\n    \"\"\"\n    # Test cases: (omega_max, dt, N, x0, v0, eta)\n    test_cases = [\n        (1.0, 0.5, 2000, 1.0, 0.0, 0.02),\n        (1.0, 2.0, 1000, 1.0, 0.0, 0.02),\n        (1.0, 2.1, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.8, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.2, 2000, 1.0, 0.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Note: Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is different from the example's 'true'/'false'. The standard Python\n    # representation is used as it is unambiguous.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从头算分子动力学主要有两种实现方法：Born-Oppenheimer分子动力学（BOMD）和Car-Parrinello分子动力学（CPMD）。BOMD在每一步都精确求解电子基态，而CPMD引入虚拟的电子动力学以提高效率。本练习通过一个简化的水二聚体模型，让你直接比较这两种方法的能量守恒性，并理解如何通过调节CPMD中的虚拟电子质量 $M_q$ 等参数来控制模拟质量。",
            "id": "2448304",
            "problem": "您需要对一个沿单一分子间坐标运动的简化水二聚体，在两种第一性原理分子动力学范式下进行建模，并比较其能量守恒性。考虑一个一维原子核坐标 $R$，代表氧-氧间距，以玻尔半径（$a_0$）为单位。原子核的运动由一个玻恩-奥本海默（Born–Oppenheimer）势能面控制，该势能面由莫尔斯（Morse）势近似：\n$$\nE_{\\mathrm{BO}}(R) \\;=\\; D \\left[\\left(1 - e^{-a(R - R_e)}\\right)^2 - 1\\right],\n$$\n其参数 $D$、$a$ 和 $R_e$ 在下文指定。与此并行，考虑一个辅助电子集体坐标 $q$（无量纲），其瞬时基态流形由 $q^\\star(R) = c\\,R$ 给出。定义一个扩展能量：\n$$\nE_{\\mathrm{CP}}(R,q) \\;=\\; E_{\\mathrm{BO}}(R) \\;+\\; \\tfrac{1}{2} k_e \\left(q - c\\,R\\right)^2,\n$$\n其中耦合刚度为 $k_e$，无量纲比例常数为 $c$。您必须在持续时间为 $T = 1\\,\\mathrm{ps}$ 的轨迹上执行两种类型的动力学模拟：\n- 玻恩-奥本海默分子动力学（Born–Oppenheimer Molecular Dynamics, BOMD）：原子核坐标 $R$ 在 $E_{\\mathrm{BO}}(R)$ 上演化，没有显式的电子动力学。\n- 卡-帕里内洛分子动力学（Car–Parrinello Molecular Dynamics, CPMD）：原子核坐标 $R$ 和辅助坐标 $q$ 根据扩展能量 $E_{\\mathrm{CP}}(R,q)$ 演化，其中虚拟电子质量为 $M_q$。\n\n使用以下运动方程，其中点号表示对时间的导数：\n- 对于 BOMD：\n$$\nM_R \\,\\ddot{R} \\;=\\; -\\frac{dE_{\\mathrm{BO}}}{dR}.\n$$\n- 对于 CPMD：\n$$\nM_R \\,\\ddot{R} \\;=\\; -\\frac{dE_{\\mathrm{BO}}}{dR} \\;+\\; k_e\\,c\\left(q - c\\,R\\right),\n\\qquad\nM_q \\,\\ddot{q} \\;=\\; -k_e \\left(q - c\\,R\\right).\n$$\n取原子核质量 $M_R$ 为两个氧原子沿 $R$ 坐标的折合质量：\n$$\nM_R \\;=\\; \\frac{1}{2} m_{\\mathrm{O}},\n\\qquad\nm_{\\mathrm{O}} \\;=\\; 15.999 \\,u,\n\\qquad\n1\\,u \\;=\\; 1822.888486209 \\,m_e,\n$$\n以上均在原子单位制中表示，其中电子质量 $m_e = 1$。莫尔斯参数和耦合参数为：\n$$\nD \\;=\\; \\frac{0.22\\,\\mathrm{eV}}{27.211386245988\\,\\mathrm{eV/Ha}} \\;\\mathrm{Ha},\n\\quad\na \\;=\\; 3.0 \\;a_0^{-1},\n\\quad\nR_e \\;=\\; 5.5 \\;a_0,\n$$\n$$\nk_e \\;=\\; 0.5 \\;\\mathrm{Ha},\n\\qquad\nc \\;=\\; 0.05.\n$$\n使用时间 $t=0$ 时的初始条件：\n$$\nR(0) \\;=\\; R_e + 0.1 \\;a_0,\n\\qquad\n\\dot{R}(0) \\;=\\; 0,\n\\qquad\nq(0) \\;=\\; c\\,R(0),\n\\qquad\n\\dot{q}(0) \\;=\\; 0.\n$$\n对 BOMD 和 CPMD 进行总时长为 $T = 1\\,\\mathrm{ps}$ 的模拟。方程应以原子时间单位进行积分，其转换关系为 $1\\,\\mathrm{a.u.\\ of\\ time} = 2.4188843265857 \\times 10^{-17}\\,\\mathrm{s}$ 且 $1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$。需要监测的总能量为：\n- 对于 BOMD：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{BO}}(t) \\;=\\; \\tfrac{1}{2} M_R \\dot{R}^2 \\;+\\; E_{\\mathrm{BO}}(R).\n$$\n- 对于 CPMD：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{CP}}(t) \\;=\\; \\tfrac{1}{2} M_R \\dot{R}^2 \\;+\\; \\tfrac{1}{2} M_q \\dot{q}^2 \\;+\\; E_{\\mathrm{CP}}(R,q).\n$$\n对于每次模拟，计算在整个轨迹上的绝对总能量漂移，\n$$\n\\Delta E \\;=\\; \\left| E_{\\mathrm{tot}}(T) - E_{\\mathrm{tot}}(0) \\right|,\n$$\n并以电子伏特（eV）为单位报告 $\\Delta E$，四舍五入到小数点后恰好 $6$ 位。\n\n测试组。对于以下每一组参数 $(\\Delta t, M_q)$，分别对 BOMD 和 CPMD 进行时长为 $T = 1\\,\\mathrm{ps}$ 的模拟，其中 $\\Delta t$ 是用于积分的数值时间步长：\n- 情况 A：$\\Delta t = 0.25\\,\\mathrm{fs}$，$M_q = 400$。\n- 情况 B：$\\Delta t = 0.50\\,\\mathrm{fs}$，$M_q = 400$。\n- 情况 C：$\\Delta t = 0.50\\,\\mathrm{fs}$，$M_q = 1600$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个由六个浮点数组成的列表，这些浮点数分别代表情况 A、B 和 C 中 BOMD 和 CPMD 的能量漂移（以 eV 为单位），每个数值都四舍五入到小数点后恰好 $6$ 位，并按以下顺序排列：\n$$\n[\\Delta E_{\\mathrm{BO}}^{A}, \\Delta E_{\\mathrm{CP}}^{A}, \\Delta E_{\\mathrm{BO}}^{B}, \\Delta E_{\\mathrm{CP}}^{B}, \\Delta E_{\\mathrm{BO}}^{C}, \\Delta E_{\\mathrm{CP}}^{C}].\n$$\n输出必须是单行，并且必须与指定格式精确匹配（例如，$[0.000001,0.000002,0.000003,0.000004,0.000005,0.000006]$）。",
            "solution": "所述问题需经过验证。\n\n### 步骤 1：提取已知条件\n- **原子核坐标**：$R$ (玻尔, $a_0$)\n- **玻恩-奥本海默势**：$E_{\\mathrm{BO}}(R) = D[(1 - e^{-a(R - R_e)})^2 - 1]$\n- **辅助电子坐标**：$q$ (无量纲)\n- **电子基态流形**：$q^\\star(R) = c R$\n- **扩展卡-帕里内洛能量**：$E_{\\mathrm{CP}}(R,q) = E_{\\mathrm{BO}}(R) + \\tfrac{1}{2} k_e (q - cR)^2$\n- **模拟时长**：$T = 1\\,\\mathrm{ps}$\n- **运动方程 (BOMD)**：$M_R \\ddot{R} = -\\frac{dE_{\\mathrm{BO}}}{dR}$\n- **运动方程 (CPMD)**：\n  $M_R \\ddot{R} = -\\frac{dE_{\\mathrm{BO}}}{dR} + k_e c(q - cR)$\n  $M_q \\ddot{q} = -k_e (q - cR)$\n- **质量**：$M_R = \\frac{1}{2} m_{\\mathrm{O}}$，$m_{\\mathrm{O}} = 15.999 \\,u$，$1\\,u = 1822.888486209 \\,m_e$，$m_e = 1$\n- **势能参数**：$D = \\frac{0.22\\,\\mathrm{eV}}{27.211386245988\\,\\mathrm{eV/Ha}} \\;\\mathrm{Ha}$，$a = 3.0 \\;a_0^{-1}$，$R_e = 5.5 \\;a_0$\n- **耦合参数**：$k_e = 0.5 \\;\\mathrm{Ha}$，$c = 0.05$\n- **初始条件 ($t=0$)**：$R(0) = R_e + 0.1 \\;a_0$，$\\dot{R}(0) = 0$，$q(0) = c R(0)$，$\\dot{q}(0) = 0$\n- **时间转换**：$1\\,\\mathrm{a.u.\\ of\\ time} = 2.4188843265857 \\times 10^{-17}\\,\\mathrm{s}$，$1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$\n- **总能量 (BOMD)**：$E_{\\mathrm{tot}}^{\\mathrm{BO}}(t) = \\tfrac{1}{2} M_R \\dot{R}^2 + E_{\\mathrm{BO}}(R)$\n- **总能量 (CPMD)**：$E_{\\mathrm{tot}}^{\\mathrm{CP}}(t) = \\tfrac{1}{2} M_R \\dot{R}^2 + \\tfrac{1}{2} M_q \\dot{q}^2 + E_{\\mathrm{CP}}(R,q)$\n- **度量指标**：绝对能量漂移 $\\Delta E = | E_{\\mathrm{tot}}(T) - E_{\\mathrm{tot}}(0) |$，单位为 eV，四舍五入到小数点后 $6$ 位。\n- **测试用例**：\n    - 情况 A：$\\Delta t = 0.25\\,\\mathrm{fs}$，$M_q = 400$\n    - 情况 B：$\\Delta t = 0.50\\,\\mathrm{fs}$，$M_q = 400$\n    - 情况 C：$\\Delta t = 0.50\\,\\mathrm{fs}$，$M_q = 1600$\n- **输出格式**：$[\\Delta E_{\\mathrm{BO}}^{A}, \\Delta E_{\\mathrm{CP}}^{A}, \\Delta E_{\\mathrm{BO}}^{B}, \\Delta E_{\\mathrm{CP}}^{B}, \\Delta E_{\\mathrm{BO}}^{C}, \\Delta E_{\\mathrm{CP}}^{C}]$\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，它使用一个简化但物理上具有代表性的模型系统，对玻恩-奥本海默分子动力学和卡-帕里内洛分子动力学进行了标准比较。运动方程从所提供的能量泛函中正确推导得出。参数、单位和常数均已明确指定，并与计算化学中的标准值相对应。该问题是适定的，所有必要的初始条件和参数都已提供，以确保存在唯一解。该问题是客观且自洽的，没有明显的矛盾或遗漏。\n\n### 步骤 3：结论与行动\n该问题被认定为有效。将构建一个解决方案。\n\n### 解决方案\n\n本任务旨在模拟一维原子核坐标 $R$ 在两种不同理论框架下的经典动力学：玻恩-奥本海默分子动力学（BOMD）和卡-帕里内洛分子动力学（CPMD）。主要目标是比较在每种范式下数值上总能量的守恒性。分析将在原子单位（a.u.）下进行，其中电子质量 $m_e$、基本电荷 $e$、约化普朗克常数 $\\hbar$ 和玻尔半径 $a_0$ 均设为 1。能量单位是哈特里（Hartree），记作 Ha。\n\n首先，我们在原子单位制下确定各常数和参数。\n哈特里到电子伏特的转换关系为 $1\\,\\mathrm{Ha} \\approx 27.211386245988\\,\\mathrm{eV}$。\n莫尔斯势的解离能为 $D = \\frac{0.22}{27.211386245988}\\,\\mathrm{Ha} \\approx 0.0080850\\,\\mathrm{Ha}$。\n其他莫尔斯参数为 $a = 3.0\\,a_0^{-1}$ 和 $R_e = 5.5\\,a_0$。\n氧二聚体折合运动的原子核质量 $M_R$ 为：\n$$\nM_R = \\frac{1}{2} m_{\\mathrm{O}} = \\frac{1}{2} (15.999\\,u) = \\frac{1}{2} \\times 15.999 \\times 1822.888486209 \\,m_e \\approx 14581.285 \\,m_e\n$$\nCPMD 的耦合参数为 $k_e = 0.5\\,\\mathrm{Ha}$ 和 $c = 0.05$。\n模拟时间为 $T = 1\\,\\mathrm{ps} = 1000\\,\\mathrm{fs}$。从飞秒到原子时间单位的转换为：\n$$\n1\\,\\mathrm{fs} = \\frac{10^{-15}\\,\\mathrm{s}}{2.4188843265857 \\times 10^{-17}\\,\\mathrm{s/a.u.}} \\approx 41.3413745758\\,\\mathrm{a.u.}\n$$\n因此，$T \\approx 41341.37\\,\\mathrm{a.u.}$。时间步长为 $\\Delta t_A = 0.25\\,\\mathrm{fs} \\approx 10.335\\,\\mathrm{a.u.}$ 和 $\\Delta t_B = \\Delta t_C = 0.50\\,\\mathrm{fs} \\approx 20.671\\,\\mathrm{a.u.}$。\n\n运动方程使用速度 Verlet 算法进行积分。这是一种时间可逆的辛积分器，以其在微正则系综模拟中卓越的长期能量守恒特性而闻名。对于一个质量为 $M$、受力为 $F(x)$ 的坐标 $x$，该算法流程如下：\n1. $v(t + \\frac{\\Delta t}{2}) = v(t) + \\frac{1}{2} \\frac{F(x(t))}{M} \\Delta t$\n2. $x(t + \\Delta t) = x(t) + v(t + \\frac{\\Delta t}{2}) \\Delta t$\n3. $v(t + \\Delta t) = v(t + \\frac{\\Delta t}{2}) + \\frac{1}{2} \\frac{F(x(t+\\Delta t))}{M} \\Delta t$\n\n积分所需的力由各自的势能推导得出。\n对于 BOMD，作用在原子核坐标 $R$ 上的力是：\n$$\nF_R^{\\mathrm{BO}} = -\\frac{dE_{\\mathrm{BO}}}{dR} = -2aD \\left(1 - e^{-a(R - R_e)}\\right) e^{-a(R - R_e)}\n$$\n对于 CPMD，作用在耦合坐标 $(R, q)$ 上的力是：\n$$\nF_R^{\\mathrm{CP}} = -\\frac{\\partial E_{\\mathrm{CP}}}{\\partial R} = -\\frac{dE_{\\mathrm{BO}}}{dR} + k_e c(q - cR) = F_R^{\\mathrm{BO}} + k_e c(q - cR)\n$$\n$$\nF_q^{\\mathrm{CP}} = -\\frac{\\partial E_{\\mathrm{CP}}}{\\partial q} = -k_e(q - cR)\n$$\n这定义了一个二维系统 $(R, q)$，由力 $(F_R^{\\mathrm{CP}}, F_q^{\\mathrm{CP}})$ 驱动，其对应质量为 $(M_R, M_q)$。\n\n初始条件为：$R(0) = 5.5 + 0.1 = 5.6\\,a_0$，$\\dot{R}(0) = 0$，$q(0) = c R(0) = 0.05 \\times 5.6 = 0.28$，以及 $\\dot{q}(0) = 0$。\n系统从一个偏离的原子核构型静止开始初始化，其虚拟电子坐标满足基态条件 $q=cR$。\n\n在每种模拟中，守恒的总能量在轨迹的开始（$t=0$）和结束（$t=T$）时计算。\n对于 BOMD，总能量为：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{BO}}(t) = \\frac{1}{2} M_R \\dot{R}(t)^2 + D \\left[\\left(1 - e^{-a(R(t) - R_e)}\\right)^2 - 1\\right]\n$$\n对于 CPMD，守恒的扩展能量或虚拟能量为：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{CP}}(t) = \\frac{1}{2} M_R \\dot{R}(t)^2 + \\frac{1}{2} M_q \\dot{q}(t)^2 + E_{\\mathrm{BO}}(R(t)) + \\frac{1}{2} k_e (q(t) - cR(t))^2\n$$\n对六个模拟（情况 A、B、C 下的 BOMD/CPMD）中的每一个计算绝对能量漂移 $\\Delta E = |E_{\\mathrm{tot}}(T) - E_{\\mathrm{tot}}(0)|$。最终结果从哈特里转换为电子伏特，并按指定精度报告。\n\n实现将包括两个主要函数，每种动力学类型各一个。每个函数将接受积分时间步长和其他相关参数，执行速度 Verlet 积分循环直至达到指定的总时长，并返回能量漂移。主程序将为每个测试用例调用这些函数，并按要求格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    # --- Constants and Unit Conversions ---\n    EV_PER_HA = 27.211386245988\n    AMU_PER_ME = 1822.888486209\n    AU_TIME_PER_S = 2.4188843265857e-17\n    FS_PER_S = 1e-15\n    FS_TO_AU_TIME = FS_PER_S / AU_TIME_PER_S\n\n    # --- System Parameters in Atomic Units ---\n    D_ev = 0.22\n    D_ha = D_ev / EV_PER_HA\n    A_au = 3.0\n    RE_au = 5.5\n    \n    M_O_u = 15.999\n    M_R_me = 0.5 * M_O_u * AMU_PER_ME\n    \n    K_E_ha = 0.5\n    C_dimless = 0.05\n\n    # --- Simulation Time ---\n    T_ps = 1.0\n    T_fs = T_ps * 1000.0\n    T_au = T_fs * FS_TO_AU_TIME\n\n    # --- Initial Conditions in Atomic Units ---\n    R0 = RE_au + 0.1\n    R_DOT0 = 0.0\n    Q0 = C_dimless * R0\n    Q_DOT0 = 0.0\n\n    # --- Energy and Force Functions ---\n    def e_bo(r):\n        term = 1.0 - np.exp(-A_au * (r - RE_au))\n        return D_ha * (term**2 - 1.0)\n\n    def f_bo(r):\n        exp_term = np.exp(-A_au * (r - RE_au))\n        return -2.0 * A_au * D_ha * (1.0 - exp_term) * exp_term\n\n    def e_cp(r, q):\n        return e_bo(r) + 0.5 * K_E_ha * (q - C_dimless * r)**2\n    \n    def f_cp_r(r, q):\n        return f_bo(r) + K_E_ha * C_dimless * (q - C_dimless * r)\n        \n    def f_cp_q(r, q):\n        return -K_E_ha * (q - C_dimless * r)\n\n    # --- Simulation Functions ---\n    def run_bomd(dt_fs):\n        dt_au = dt_fs * FS_TO_AU_TIME\n        num_steps = int(round(T_au / dt_au))\n\n        r = R0\n        r_dot = R_DOT0\n\n        e_initial = 0.5 * M_R_me * r_dot**2 + e_bo(r)\n        \n        accel = f_bo(r) / M_R_me\n        for _ in range(num_steps):\n            r_dot += 0.5 * accel * dt_au\n            r += r_dot * dt_au\n            accel = f_bo(r) / M_R_me\n            r_dot += 0.5 * accel * dt_au\n        \n        e_final = 0.5 * M_R_me * r_dot**2 + e_bo(r)\n        \n        delta_e_ha = np.abs(e_final - e_initial)\n        return delta_e_ha * EV_PER_HA\n\n    def run_cpmd(dt_fs, M_q_me):\n        dt_au = dt_fs * FS_TO_AU_TIME\n        num_steps = int(round(T_au / dt_au))\n\n        r, r_dot = R0, R_DOT0\n        q, q_dot = Q0, Q_DOT0\n\n        e_initial = 0.5 * M_R_me * r_dot**2 + 0.5 * M_q_me * q_dot**2 + e_cp(r, q)\n\n        accel_r = f_cp_r(r, q) / M_R_me\n        accel_q = f_cp_q(r, q) / M_q_me\n        for _ in range(num_steps):\n            # Update velocities (half step)\n            r_dot += 0.5 * accel_r * dt_au\n            q_dot += 0.5 * accel_q * dt_au\n            \n            # Update positions\n            r += r_dot * dt_au\n            q += q_dot * dt_au\n            \n            # Update accelerations\n            accel_r = f_cp_r(r, q) / M_R_me\n            accel_q = f_cp_q(r, q) / M_q_me\n            \n            # Update velocities (full step)\n            r_dot += 0.5 * accel_r * dt_au\n            q_dot += 0.5 * accel_q * dt_au\n\n        e_final = 0.5 * M_R_me * r_dot**2 + 0.5 * M_q_me * q_dot**2 + e_cp(r, q)\n        \n        delta_e_ha = np.abs(e_final - e_initial)\n        return delta_e_ha * EV_PER_HA\n\n    # --- Test Cases ---\n    test_cases = [\n        # (dt_fs, M_q_me)\n        (0.25, 400.0),  # Case A\n        (0.50, 400.0),  # Case B\n        (0.50, 1600.0), # Case C\n    ]\n\n    results = []\n    \n    # Case A\n    dt_A, Mq_A = test_cases[0]\n    results.append(run_bomd(dt_A))\n    results.append(run_cpmd(dt_A, Mq_A))\n\n    # Case B\n    dt_B, Mq_B = test_cases[1]\n    # BOMD results for dt=0.50fs are identical for Cases B  C\n    bomd_b_drift = run_bomd(dt_B)\n    results.append(bomd_b_drift)\n    results.append(run_cpmd(dt_B, Mq_B))\n    \n    # Case C\n    dt_C, Mq_C = test_cases[2]\n    # Re-use BOMD result\n    results.append(bomd_b_drift) # dt is the same as in B\n    results.append(run_cpmd(dt_C, Mq_C))\n\n    # --- Format and Print Output ---\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "AIMD的强大之处在于它能预测宏观物理性质，例如扩散系数。本练习将指导你如何从模拟得到的离子运动轨迹中提取扩散系数这一重要的输运性质。你将学习使用爱因斯坦关系式，通过计算均方位移（MSD）来获得扩散系数，并应用Yeh–Hummer校正来处理有限尺寸效应，这是将模拟结果与真实世界实验联系起来的关键一步。",
            "id": "2448227",
            "problem": "给定一组人工合成但基于物理原理的轨迹摘要数据，代表了单个锂离子 $\\mathrm{Li}^+$ 在液态水中的运动，这些数据可从第一性原理分子动力学（AIMD）中获得。该运动是在边长为 $L$ 的立方模拟晶胞中，在周期性边界条件下的三维空间运动。目标是利用第一性原理，根据均方位移的长时间行为来估计热力学（无限系统）极限下的扩散系数，并量化周期性边界条件下由流体动力学相互作用引起的有限尺寸效应。\n\n定义与常量：\n- 三维空间中的扩散系数 $D$ 通过爱因斯坦关系式定义：$D = \\lim_{t \\to \\infty} \\frac{1}{6}\\frac{\\mathrm{d}}{\\mathrm{d}t}\\langle \\Delta r(t)^2 \\rangle$，其中 $\\langle \\Delta r(t)^2 \\rangle$ 是均方位移（MSD）。\n- 对于边长为 $L$ 的有限周期性立方晶胞，Yeh–Hummer 流体动力学有限尺寸校正将有限系统扩散系数 $D_L$ 与无限系统扩散系数 $D_{\\infty}$ 关联起来，其关系式为 $D_{\\infty} = D_L + \\frac{k_{\\mathrm{B}} T \\,\\xi}{6\\pi \\eta L}$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\eta$ 是剪切黏度，对于立方晶格 $\\xi \\approx 2.837297$。\n- 使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$ 和 $\\xi = 2.837297$。\n- 单位：时间数组 $t$ 的单位是皮秒（ps），均方位移值 $\\langle \\Delta r^2 \\rangle$ 的单位是平方纳米（$\\mathrm{nm}^2$），盒子长度 $L$ 的单位是纳米（nm），黏度 $\\eta$ 的单位是帕斯卡-秒（$\\mathrm{Pa\\,s}$），温度 $T$ 的单位是开尔文（K）。您的程序必须以平方米每秒（$\\mathrm{m}^2\\,\\mathrm{s}^{-1}$）为单位输出 $D_{\\infty}$。不涉及角度。不涉及百分比。\n- 对于每种情况，必须根据爱因斯坦关系式，通过在指定的拟合区间 $[t_{\\min}, t_{\\max}]$ 内对 $\\langle \\Delta r^2 \\rangle$ 与 $t$ 的线性函数进行最佳拟合，从其斜率中获得 $D_L$。单位之间的转换必须精确执行：$1\\ \\mathrm{nm}^2 / \\mathrm{ps} = 10^{-6}\\ \\mathrm{m}^2 / \\mathrm{s}$。\n\n编写一个程序，为下面的每个测试用例，从线性拟合中计算 $D_L$，然后使用 Yeh–Hummer 校正计算 $D_{\\infty}$。报告最终的 $D_{\\infty}$ 值，单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$，并四舍五入到六位有效数字。\n\n测试套件（每个用例都是独立的）：\n\n情况 1：\n- $T = 300\\ \\mathrm{K}$，$\\eta = 0.00089\\ \\mathrm{Pa\\,s}$，$L = 1.5\\ \\mathrm{nm}$。\n- $t\\ \\mathrm{(ps)} = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$。\n- $\\langle \\Delta r^2 \\rangle\\ \\mathrm{(nm^2)} = [0.0, 0.0072, 0.0144, 0.0216, 0.0288, 0.0360, 0.0432, 0.0504, 0.0576, 0.0648, 0.0720]$。\n- 拟合区间：$t_{\\min} = 0\\ \\mathrm{ps}$，$t_{\\max} = 10\\ \\mathrm{ps}$。\n\n情况 2：\n- $T = 300\\ \\mathrm{K}$，$\\eta = 0.00089\\ \\mathrm{Pa\\,s}$，$L = 1.0\\ \\mathrm{nm}$。\n- $t\\ \\mathrm{(ps)} = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]$。\n- $\\langle \\Delta r^2 \\rangle\\ \\mathrm{(nm^2)} = [0.0, 0.0036, 0.0072, 0.0108, 0.0144, 0.0180, 0.0216]$。\n- 拟合区间：$t_{\\min} = 0.0\\ \\mathrm{ps}$，$t_{\\max} = 3.0\\ \\mathrm{ps}$。\n\n情况 3：\n- $T = 300\\ \\mathrm{K}$，$\\eta = 0.00089\\ \\mathrm{Pa\\,s}$，$L = 6.0\\ \\mathrm{nm}$。\n- $t\\ \\mathrm{(ps)} = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$。\n- $\\langle \\Delta r^2 \\rangle\\ \\mathrm{(nm^2)} = [0.0, 0.0072, 0.0144, 0.0216, 0.0288, 0.0360, 0.0432, 0.0504, 0.0576, 0.0648, 0.0720]$。\n- 拟合区间：$t_{\\min} = 0\\ \\mathrm{ps}$，$t_{\\max} = 10\\ \\mathrm{ps}$。\n\n情况 4：\n- $T = 320\\ \\mathrm{K}$，$\\eta = 0.00065\\ \\mathrm{Pa\\,s}$，$L = 2.0\\ \\mathrm{nm}$。\n- $t\\ \\mathrm{(ps)} = [0.0, 2.0, 4.0, 6.0, 8.0]$。\n- $\\langle \\Delta r^2 \\rangle\\ \\mathrm{(nm^2)} = [0.0, 0.0096, 0.0192, 0.0288, 0.0384]$。\n- 拟合区间：$t_{\\min} = 0.0\\ \\mathrm{ps}$，$t_{\\max} = 8.0\\ \\mathrm{ps}$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含案例 1 到 4 的 $D_{\\infty}$ 值的逗号分隔列表，按顺序排列，用方括号括起来，每个数字四舍五入到六位有效数字，例如 $[a,b,c,d]$，其中 $a$、$b$、$c$ 和 $d$ 是单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 的浮点数。",
            "solution": "我们从第一性原理出发。对于三维空间中的布朗运动，扩散系数 $D$ 由爱因斯坦关系式定义，\n$$\nD \\equiv \\lim_{t \\to \\infty} \\frac{1}{6}\\frac{\\mathrm{d}}{\\mathrm{d}t}\\langle \\Delta r(t)^2 \\rangle,\n$$\n其中 $\\langle \\Delta r(t)^2 \\rangle$ 是粒子的均方位移（MSD）。在实践中，在 MSD 与 $t$呈线性关系的时间区间（扩散区域）内，MSD 可以建模为线性函数，\n$$\n\\langle \\Delta r(t)^2 \\rangle \\approx s\\, t + b,\n$$\n斜率为 $s$，截距为 $b$。那么有限系统的扩散系数 $D_L$ 为\n$$\nD_L = \\frac{s}{6}.\n$$\n由于给定的时间 $t$ 单位是皮秒，MSD 值单位是平方纳米，因此计算出的 $D_L$（即 $s/6$）的单位将是 $\\mathrm{nm}^2/\\mathrm{ps}$。要将 $D_L$ 转换为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 单位，精确的单位换算为\n$$\n1\\ \\frac{\\mathrm{nm}^2}{\\mathrm{ps}} = 10^{-6}\\ \\frac{\\mathrm{m}^2}{\\mathrm{s}},\n$$\n所以\n$$\nD_L\\ \\big[\\mathrm{m}^2\\,\\mathrm{s}^{-1}\\big] = \\frac{s}{6} \\times 10^{-6}.\n$$\n\n在边长为 $L$ 的立方晶胞中的周期性边界条件下，流体动力学相互作用会导致有限尺寸偏差。Yeh–Hummer 校正给出了有限系统扩散系数 $D_L$ 和无限系统扩散系数 $D_{\\infty}$ 之间的主导阶关系，\n$$\nD_{\\infty} = D_L + \\frac{k_{\\mathrm{B}} T \\,\\xi}{6\\pi \\eta L},\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度，$\\eta$ 是剪切黏度，对于立方周期性边界条件 $\\xi \\approx 2.837297$。在此公式中，$L$ 的单位必须是米，$\\eta$ 的单位是 $\\mathrm{Pa\\,s}$，$T$ 的单位是 $\\mathrm{K}$，$k_{\\mathrm{B}}$ 的单位是 $\\mathrm{J\\,K^{-1}}$，从而得到单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 的校正项。\n\n根据这些原理，为每个案例推导出的算法步骤如下：\n1. 选择时间 $t$ 在指定拟合区间 $[t_{\\min}, t_{\\max}]$ 内的数据点。\n2. 对 $\\langle \\Delta r^2 \\rangle$ 与 $t$ 进行最小二乘线性拟合，以获得单位为 $\\mathrm{nm}^2/\\mathrm{ps}$ 的斜率 $s$。\n3. 使用 $D_L = (s/6)\\times 10^{-6}$ 计算 $D_L$，单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$。\n4. 使用 $L_{\\mathrm{m}} = L \\times 10^{-9}$ 将盒子长度 $L$ 从 $\\mathrm{nm}$ 转换为 $\\mathrm{m}$。\n5. 计算 Yeh–Hummer 校正项，\n$$\n\\Delta D = \\frac{k_{\\mathrm{B}} T \\,\\xi}{6\\pi \\eta L_{\\mathrm{m}}}.\n$$\n6. 计算 $D_{\\infty} = D_L + \\Delta D$。\n7. 将 $D_{\\infty}$ 四舍五入到六位有效数字，并以 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 为单位报告。\n\n将此应用于测试套件：\n- 在情况 1、2 和 3 中，MSD 序列是完全线性的，斜率为 $s = 0.0072\\ \\mathrm{nm}^2/\\mathrm{ps}$，对应于 $D_L = (0.0072/6)\\times 10^{-6} = 1.2\\times 10^{-9}\\ \\mathrm{m}^2\\,\\mathrm{s}^{-1}$。由于 $L$ 值不同，有限尺寸校正也不同：较小的 $L$ 会增加校正值，而较大的 $L$ 会减小校正值。具体来说，在固定的 $T$ 和 $\\eta$ 下，校正值与 $1/L$ 成比例。\n- 在情况 4 中，MSD 是线性的，斜率为 $s = 0.0048\\ \\mathrm{nm}^2/\\mathrm{ps}$，校正前的 $D_L$ 为 $0.8\\times 10^{-9}\\ \\mathrm{m}^2\\,\\mathrm{s}^{-1}$。根据公式，校正值随 $T$ 的增加而增加，随 $\\eta$ 和 $L$ 的增加而减小。\n\n程序将使用最小二乘法实现线性回归，应用精确的单位转换和常量 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$ 和 $\\xi = 2.837297$，并按照要求的格式，将四个校正后的扩散系数 $D_{\\infty}$ 作为单个列表在一行中打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_d_infinity(t_ps, msd_nm2, tmin_ps, tmax_ps, T_K, eta_Pa_s, L_nm):\n    # Select data within the fit interval [tmin_ps, tmax_ps]\n    t = np.array(t_ps, dtype=float)\n    msd = np.array(msd_nm2, dtype=float)\n    mask = (t >= tmin_ps)  (t = tmax_ps)\n    t_fit = t[mask]\n    msd_fit = msd[mask]\n\n    # Linear least squares fit: msd = slope * t + intercept\n    # slope has units of nm^2/ps\n    slope, intercept = np.polyfit(t_fit, msd_fit, 1)\n\n    # Convert slope to D_L: D_L = (slope / 6) * 1e-6  [m^2/s]\n    D_L = (slope / 6.0) * 1e-6  # m^2/s\n\n    # Yeh–Hummer correction: D_inf = D_L + kB * T * xi / (6 * pi * eta * L)\n    kB = 1.380649e-23  # J/K\n    xi = 2.837297\n    pi = np.pi\n    L_m = L_nm * 1e-9  # convert nm to m\n\n    correction = kB * T_K * xi / (6.0 * pi * eta_Pa_s * L_m)  # m^2/s\n\n    D_inf = D_L + correction\n    return D_inf\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"T_K\": 300.0,\n            \"eta_Pa_s\": 0.00089,\n            \"L_nm\": 1.5,\n            \"t_ps\": [0,1,2,3,4,5,6,7,8,9,10],\n            \"msd_nm2\": [0.0,0.0072,0.0144,0.0216,0.0288,0.0360,0.0432,0.0504,0.0576,0.0648,0.0720],\n            \"tmin_ps\": 0.0,\n            \"tmax_ps\": 10.0\n        },\n        # Case 2\n        {\n            \"T_K\": 300.0,\n            \"eta_Pa_s\": 0.00089,\n            \"L_nm\": 1.0,\n            \"t_ps\": [0.0,0.5,1.0,1.5,2.0,2.5,3.0],\n            \"msd_nm2\": [0.0,0.0036,0.0072,0.0108,0.0144,0.0180,0.0216],\n            \"tmin_ps\": 0.0,\n            \"tmax_ps\": 3.0\n        },\n        # Case 3\n        {\n            \"T_K\": 300.0,\n            \"eta_Pa_s\": 0.00089,\n            \"L_nm\": 6.0,\n            \"t_ps\": [0,1,2,3,4,5,6,7,8,9,10],\n            \"msd_nm2\": [0.0,0.0072,0.0144,0.0216,0.0288,0.0360,0.0432,0.0504,0.0576,0.0648,0.0720],\n            \"tmin_ps\": 0.0,\n            \"tmax_ps\": 10.0\n        },\n        # Case 4\n        {\n            \"T_K\": 320.0,\n            \"eta_Pa_s\": 0.00065,\n            \"L_nm\": 2.0,\n            \"t_ps\": [0.0,2.0,4.0,6.0,8.0],\n            \"msd_nm2\": [0.0,0.0096,0.0192,0.0288,0.0384],\n            \"tmin_ps\": 0.0,\n            \"tmax_ps\": 8.0\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        D_inf = compute_d_infinity(\n            t_ps=case[\"t_ps\"],\n            msd_nm2=case[\"msd_nm2\"],\n            tmin_ps=case[\"tmin_ps\"],\n            tmax_ps=case[\"tmax_ps\"],\n            T_K=case[\"T_K\"],\n            eta_Pa_s=case[\"eta_Pa_s\"],\n            L_nm=case[\"L_nm\"]\n        )\n        results.append(D_inf)\n\n    # Round to six significant figures for output formatting\n    formatted = [f\"{val:.6g}\" for val in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        }
    ]
}