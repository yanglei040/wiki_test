{
    "hands_on_practices": [
        {
            "introduction": "Moving from the theoretical equations to a working simulation requires careful implementation and verification. A fundamental property of Ehrenfest dynamics is the conservation of the total energy, which is the sum of the classical kinetic energy and the quantum electronic energy expectation value. This exercise  guides you through building a simulation with a time-reversible integrator to numerically demonstrate that a correctly implemented Ehrenfest model conserves total energy to within machine precision, providing a crucial sanity check for your code.",
            "id": "2454724",
            "problem": "Design and implement a program that numerically tests conservation of the total energy in Ehrenfest dynamics for a minimal coupled quantum/classical model in atomic units. Begin from the following fundamental laws and definitions: the time-dependent Schrödinger equation (TDSE) for the electronic wavefunction $|\\psi(t)\\rangle$ with Hamiltonian $\\hat{H}_{\\mathrm{e}}(R)$ depending on the classical coordinate $R(t)$, given by $\\mathrm{i}\\,\\frac{d}{dt}|\\psi(t)\\rangle=\\hat{H}_{\\mathrm{e}}(R(t))|\\psi(t)\\rangle$, and Newton’s second law for the classical coordinate of mass $M$, given by $M\\,\\frac{d^{2}R}{dt^{2}}=-\\langle\\psi(t)|\\frac{\\partial \\hat{H}_{\\mathrm{e}}(R)}{\\partial R}|\\psi(t)\\rangle$. The total energy is the sum of classical and quantum contributions, $E_{\\mathrm{tot}}(t)=\\frac{P(t)^{2}}{2M}+\\langle\\psi(t)|\\hat{H}_{\\mathrm{e}}(R(t))|\\psi(t)\\rangle$, where $P(t)=M\\,\\frac{dR}{dt}$ is the classical momentum. Use atomic units so that $\\hbar=1$.\n\nThe model to be used is a one-dimensional classical coordinate $R(t)$ coupled to a two-level quantum system with the electronic Hamiltonian\n$$\n\\hat{H}_{\\mathrm{e}}(R)=\n\\begin{pmatrix}\n\\frac{\\Delta}{2}+\\kappa R & V \\\\\nV & -\\frac{\\Delta}{2}-\\kappa R\n\\end{pmatrix},\n$$\nand its coordinate derivative\n$$\n\\frac{\\partial \\hat{H}_{\\mathrm{e}}}{\\partial R}=\n\\begin{pmatrix}\n\\kappa & 0\\\\\n0 & -\\kappa\n\\end{pmatrix}.\n$$\nLet the electronic state be parameterized by a normalized two-component complex vector $C(t)=\\begin{pmatrix}c_{1}(t)\\\\ c_{2}(t)\\end{pmatrix}$ so that $\\langle\\psi|\\cdot|\\psi\\rangle=C^{\\dagger}(\\cdot)C$. Then the classical force is $F(R,C)=-\\langle\\psi|\\frac{\\partial \\hat{H}_{\\mathrm{e}}}{\\partial R}|\\psi\\rangle=-\\kappa\\left(|c_{1}|^{2}-|c_{2}|^{2}\\right)$.\n\nYour task is to implement a time-reversible implicit midpoint (Crank–Nicolson form for the TDSE) integrator for the coupled Ehrenfest equations that advances one time step $\\Delta t$ from $(R_{n},P_{n},C_{n})$ to $(R_{n+1},P_{n+1},C_{n+1})$ using midpoint averages $R_{\\mathrm{avg}}=\\frac{R_{n}+R_{n+1}}{2}$, $P_{\\mathrm{avg}}=\\frac{P_{n}+P_{n+1}}{2}$, and $C_{\\mathrm{avg}}=\\frac{C_{n}+C_{n+1}}{2}$. The discrete equations to be solved self-consistently at each step are:\n- $R_{n+1}=R_{n}+\\Delta t\\,\\frac{P_{\\mathrm{avg}}}{M}$,\n- $P_{n+1}=P_{n}+\\Delta t\\,F\\!\\left(R_{\\mathrm{avg}},C_{\\mathrm{avg}}\\right)$,\n- $\\left(\\mathbb{I}+\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})\\right)C_{n+1}=\\left(\\mathbb{I}-\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})\\right)C_{n}$,\nwith $C$ renormalized to unit norm after convergence of the fixed-point iteration to machine tolerance. This scheme should, for sufficiently small $\\Delta t$ and tight self-consistency tolerance, numerically demonstrate conservation of $E_{\\mathrm{tot}}(t)$ up to machine precision over a finite simulation time.\n\nImplement the simulation for the following test suite of parameter sets, all in atomic units, with initial conditions and integrator settings as specified. For each case, run for a total time $T=N_{\\mathrm{steps}}\\times\\Delta t$ and return the maximum absolute relative drift of the total energy,\n$$\n\\max_{0\\le n\\le N_{\\mathrm{steps}}}\\frac{\\left|E_{\\mathrm{tot}}(t_{n})-E_{\\mathrm{tot}}(t_{0})\\right|}{\\left|E_{\\mathrm{tot}}(t_{0})\\right|},\n$$\nas a floating-point number.\n\nTest suite (each tuple gives $(M,\\Delta,V,\\kappa,R_{0},P_{0},C_{0},\\Delta t,N_{\\mathrm{steps}})$):\n- Case A (general coupled motion): $(M=\\;1836.0,\\;\\Delta=\\;0.5,\\;V=\\;0.1,\\;\\kappa=\\;0.05,\\;R_{0}=\\;0.0,\\;P_{0}=\\;1.0,\\;C_{0}=(1+0\\mathrm{i},\\;0+0\\mathrm{i}),\\;\\Delta t=\\;0.05,\\;N_{\\mathrm{steps}}=\\;1000)$.\n- Case B (heavy classical particle): $(M=\\;20000.0,\\;\\Delta=\\;1.0,\\;V=\\;0.2,\\;\\kappa=\\;0.1,\\;R_{0}=\\;-1.0,\\;P_{0}=\\;0.5,\\;C_{0}=\\frac{1}{\\sqrt{2}}(1+0\\mathrm{i},\\;\\mathrm{i}),\\;\\Delta t=\\;0.05,\\;N_{\\mathrm{steps}}=\\;1000)$.\n- Case C (decoupled limit): $(M=\\;1000.0,\\;\\Delta=\\;2.0,\\;V=\\;0.3,\\;\\kappa=\\;0.0,\\;R_{0}=\\;0.2,\\;P_{0}=\\;-0.3,\\;C_{0}=\\text{normalized }(0.8,\\;0.6\\mathrm{i}),\\;\\Delta t=\\;0.05,\\;N_{\\mathrm{steps}}=\\;1000)$.\n\nRequirements:\n- Use only atomic units; there are no physical unit conversions to perform. Report the final numbers as dimensionless floating-point values.\n- Implement a fixed-point iteration at each time step to enforce the midpoint self-consistency to a tight tolerance so that numerical energy drift is limited by floating-point roundoff.\n- For each case, compute the maximum absolute relative drift of $E_{\\mathrm{tot}}$ over the trajectory.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[x_{A},x_{B},x_{C}]$), where $x_{A}$, $x_{B}$, and $x_{C}$ are the computed floats for Cases A, B, and C respectively, in that order.",
            "solution": "The problem requires the design and implementation of a numerical simulation to test the conservation of total energy within the framework of Ehrenfest dynamics. This is a fundamental check on the quality of a numerical integrator for mixed quantum-classical systems. The problem is well-posed, scientifically sound, and provides all necessary information to proceed with a solution.\n\nThe core of the problem lies in the coupled evolution of a classical degree of freedom, the coordinate $R(t)$ with mass $M$ and momentum $P(t)$, and a quantum two-level system described by a state vector $|\\psi(t)\\rangle$. The dynamics are governed by Newton's second law for the classical particle and the time-dependent Schrödinger equation (TDSE) for the quantum system. In atomic units ($\\hbar=1$), these are:\n$$\nM\\,\\frac{d^{2}R}{dt^{2}} = -\\left\\langle\\psi(t)\\left|\\frac{\\partial \\hat{H}_{\\mathrm{e}}(R)}{\\partial R}\\right|\\psi(t)\\right\\rangle\n$$\n$$\n\\mathrm{i}\\,\\frac{d}{dt}|\\psi(t)\\rangle = \\hat{H}_{\\mathrm{e}}(R(t))|\\psi(t)\\rangle\n$$\nThe total energy of the combined system, which should be a conserved quantity, is the sum of the classical kinetic energy and the quantum expectation value of the electronic Hamiltonian:\n$$\nE_{\\mathrm{tot}}(t) = \\frac{P(t)^{2}}{2M} + \\langle\\psi(t)|\\hat{H}_{\\mathrm{e}}(R(t))|\\psi(t)\\rangle\n$$\nThe electronic state is represented by a normalized two-component complex vector, $C(t) = \\begin{pmatrix} c_1(t) \\\\ c_2(t) \\end{pmatrix}$, such that $C^\\dagger C = 1$. The electronic Hamiltonian $\\hat{H}_{\\mathrm{e}}(R)$ and its derivative with respect to $R$ are given as:\n$$\n\\hat{H}_{\\mathrm{e}}(R) = \\begin{pmatrix} \\frac{\\Delta}{2}+\\kappa R & V \\\\ V & -\\frac{\\Delta}{2}-\\kappa R \\end{pmatrix}, \\quad \\frac{\\partial \\hat{H}_{\\mathrm{e}}}{\\partial R} = \\begin{pmatrix} \\kappa & 0 \\\\ 0 & -\\kappa \\end{pmatrix}\n$$\nThe classical force is therefore $F = -\\langle\\psi|\\frac{\\partial \\hat{H}_{\\mathrm{e}}}{\\partial R}|\\psi\\rangle = -C^{\\dagger} \\begin{pmatrix} \\kappa & 0 \\\\ 0 & -\\kappa \\end{pmatrix} C = -\\kappa(|c_1|^2 - |c_2|^2)$.\n\nTo propagate the system in time, we must employ the specified implicit midpoint integrator. This method is time-reversible and symplectic, properties which are highly desirable for demonstrating energy conservation over long simulations. For a time step $\\Delta t$, we advance the state from $(R_n, P_n, C_n)$ at time $t_n$ to $(R_{n+1}, P_{n+1}, C_{n+1})$ at time $t_{n+1} = t_n + \\Delta t$. The discrete update equations are defined using midpoint averages of the state variables:\n- $R_{\\mathrm{avg}} = \\frac{R_n + R_{n+1}}{2}$\n- $P_{\\mathrm{avg}} = \\frac{P_n + P_{n+1}}{2}$\n- $C_{\\mathrm{avg}} = \\frac{C_n + C_{n+1}}{2}$\n\nThe system of equations to be solved is:\n1. $R_{n+1} = R_n + \\Delta t\\,\\frac{P_{\\mathrm{avg}}}{M} = R_n + \\frac{\\Delta t}{2M}(P_n + P_{n+1})$\n2. $P_{n+1} = P_n + \\Delta t\\,F(R_{\\mathrm{avg}}, C_{\\mathrm{avg}})$\n3. $(\\mathbb{I}+\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}}))C_{n+1} = (\\mathbb{I}-\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}}))C_n$\n\nThese equations are implicitly coupled: $R_{n+1}$ depends on $P_{n+1}$, which depends on $C_{n+1}$ and $R_{n+1}$ through the midpoint average arguments of the force $F$, and $C_{n+1}$ itself depends on $R_{n+1}$ through $R_{\\mathrm{avg}}$. This circular dependency necessitates a self-consistent field (SCF) or fixed-point iteration procedure at each time step.\n\nThe algorithmic procedure for one time step is as follows:\n1.  **Initialize Guess**: Start with an initial guess for the state at $t_{n+1}$. A simple and effective choice is to use the state at $t_n$: $R_{n+1}^{(0)} = R_n$, $P_{n+1}^{(0)} = P_n$.\n2.  **SCF Iteration**: Iterate until the state variables converge to a self-consistent solution. In iteration $k$:\n    a. Compute the average position based on the current guess $R_{n+1}^{(k)}$: $R_{\\mathrm{avg}} = (R_n + R_{n+1}^{(k)})/2$.\n    b. Construct the midpoint Hamiltonian $\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})$.\n    c. Solve the linear system (the Crank-Nicolson step) for an updated quantum state vector $C_{n+1}^{(k+1)}$:\n       $$\n       C_{n+1}^{(k+1)} = \\left(\\mathbb{I}+\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})\\right)^{-1} \\left(\\mathbb{I}-\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})\\right)C_n\n       $$\n       The Crank-Nicolson propagator is unitary, so if $C_n$ is normalized, $C_{n+1}^{(k+1)}$ will be as well, up to numerical precision.\n    d. Compute the average quantum state vector $C_{\\mathrm{avg}} = (C_n + C_{n+1}^{(k+1)})/2$. Note that this average vector is not normalized to unity.\n    e. Calculate the average force using this $C_{\\mathrm{avg}}$: $F_{\\mathrm{avg}} = -\\kappa(|c_{1,\\mathrm{avg}}|^2-|c_{2,\\mathrm{avg}}|^2)$.\n    f. Update the classical momentum and position to obtain the next guess:\n       $$\n       P_{n+1}^{(k+1)} = P_n + \\Delta t\\,F_{\\mathrm{avg}}\n       $$\n       $$\n       R_{n+1}^{(k+1)} = R_n + \\frac{\\Delta t}{2M}(P_n + P_{n+1}^{(k+1)})\n       $$\n    g. Check for convergence by comparing the change in a variable, for instance $|R_{n+1}^{(k+1)} - R_{n+1}^{(k)}|$, against a small tolerance.\n3.  **Finalize Step**: Once convergence is achieved, the final iterated values become the state $(R_{n+1}, P_{n+1}, C_{n+1})$. As a final step to counteract any accumulated numerical error, the vector $C_{n+1}$ is explicitly renormalized to unit norm before proceeding to the next time step.\n\nThe simulation starts from the initial conditions $(R_0, P_0, C_0)$ at $t_0=0$. The initial energy $E_{\\mathrm{tot}}(t_0)$ is computed. The system is propagated for $N_{\\mathrm{steps}}$, and the total energy $E_{\\mathrm{tot}}(t_n)$ is calculated at each step. Finally, the maximum absolute relative energy drift is computed using the specified formula:\n$$\n\\text{Drift} = \\max_{0\\le n\\le N_{\\mathrm{steps}}}\\frac{\\left|E_{\\mathrm{tot}}(t_{n})-E_{\\mathrm{tot}}(t_{0})\\right|}{\\left|E_{\\mathrm{tot}}(t_{0})\\right|}\n$$\nThis protocol is implemented for each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Ehrenfest dynamics problem for three test cases and prints the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (M, Delta, V, kappa, R0, P0, C0, dt, N_steps)\n        (1836.0, 0.5, 0.1, 0.05, 0.0, 1.0, np.array([1.0 + 0.0j, 0.0 + 0.0j]), 0.05, 1000),\n        # Case B\n        (20000.0, 1.0, 0.2, 0.1, -1.0, 0.5, np.array([1.0/np.sqrt(2) + 0.0j, 0.0 + 1.0j/np.sqrt(2)]), 0.05, 1000),\n        # Case C\n        (1000.0, 2.0, 0.3, 0.0, 0.2, -0.3, np.array([0.8 + 0.0j, 0.0 + 0.6j]), 0.05, 1000),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, Delta, V, kappa, R0, P0, C0, dt, N_steps = case\n        \n        # SCF convergence settings\n        scf_tol = 1e-15\n        scf_max_iter = 100\n\n        def get_H(R_val, delta_param, v_param, kappa_param):\n            \"\"\"Constructs the electronic Hamiltonian matrix for a given R.\"\"\"\n            return np.array([\n                [delta_param/2 + kappa_param * R_val, v_param],\n                [v_param, -delta_param/2 - kappa_param * R_val]\n            ], dtype=np.complex128)\n\n        def get_F(C_val, kappa_param):\n            \"\"\"Calculates the classical force from the electronic state.\"\"\"\n            # F(R,C) = -kappa * (|c1|^2 - |c2|^2)\n            return -kappa_param * (np.abs(C_val[0])**2 - np.abs(C_val[1])**2)\n\n        def get_E_tot(R_val, P_val, C_val, m_param, delta_param, v_param, kappa_param):\n            \"\"\"Calculates the total energy of the system.\"\"\"\n            E_kin = P_val**2 / (2 * m_param)\n            H = get_H(R_val, delta_param, v_param, kappa_param)\n            # C must be a column vector for matrix multiplication\n            C_col = C_val.reshape(2, 1)\n            # E_pot must be real\n            E_pot = (C_col.conj().T @ H @ C_col).item().real\n            return E_kin + E_pot\n\n        # Initialize simulation variables\n        R_n, P_n, C_n = R0, P0, C0\n        \n        energies = []\n        \n        E_initial = get_E_tot(R_n, P_n, C_n, M, Delta, V, kappa)\n        energies.append(E_initial)\n        \n        # Main time-stepping loop\n        for _ in range(N_steps):\n            # --- Self-Consistent Field (SCF) Iteration ---\n            # Initial guess for the next step's state variables\n            R_next = R_n\n            \n            for i in range(scf_max_iter):\n                R_prev_scf = R_next\n                \n                # 1. Compute midpoint values based on the current guess\n                R_avg = (R_n + R_next) / 2.0\n                \n                # 2. Update electronic state C using Crank-Nicolson\n                H_avg = get_H(R_avg, Delta, V, kappa)\n                Id = np.identity(2, dtype=np.complex128)\n                \n                # Propagator matrices\n                A_mat = Id + 0.5j * dt * H_avg\n                B_mat = Id - 0.5j * dt * H_avg\n                \n                # Solve the linear system for the new C\n                C_next = np.linalg.solve(A_mat, B_mat @ C_n)\n                \n                # 3. Update classical P and R\n                C_avg = (C_n + C_next) / 2.0\n                F_avg = get_F(C_avg, kappa)\n                \n                P_next = P_n + dt * F_avg\n                R_next = R_n + (dt / (2.0 * M)) * (P_n + P_next)\n                \n                # 4. Check for convergence\n                if np.abs(R_next - R_prev_scf) < scf_tol:\n                    break\n            else:\n                # This block runs if the loop finishes without `break`,\n                # indicating non-convergence. For this problem, we assume it converges.\n                pass\n            \n            # --- Update state for the next time step ---\n            R_n = R_next\n            P_n = P_next\n            \n            # Renormalize C to correct for any numerical drift\n            norm_C = np.linalg.norm(C_next)\n            C_n = C_next / norm_C if norm_C > 0 else C_next\n            \n            # Calculate and store the total energy for this step\n            energies.append(get_E_tot(R_n, P_n, C_n, M, Delta, V, kappa))\n            \n        # --- Calculate final metric ---\n        energies = np.array(energies)\n        # Denominator should be absolute value\n        E0_abs = np.abs(E_initial)\n        # Avoid division by zero, though unlikely for these cases\n        if E0_abs < 1e-12:\n            E0_abs = 1.0\n\n        max_rel_drift = np.max(np.abs(energies - E_initial) / E0_abs)\n        results.append(max_rel_drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While powerful, the mean-field nature of Ehrenfest dynamics is also its greatest weakness, leading to well-known artifacts in certain situations. One of the most famous failures occurs when a nuclear wavepacket should split into multiple channels, whereas the single Ehrenfest trajectory can become unphysically trapped. This practice  has you construct a classic model system to simulate this 'mean-field trapping' on a symmetric potential barrier, offering a direct, hands-on understanding of the method's limitations.",
            "id": "2454685",
            "problem": "You must write a complete, runnable program that constructs a one-dimensional, two-state potential energy surface in atomic units and simulates Ehrenfest dynamics to demonstrate a case where the mean-field prediction traps the nuclear trajectory at the top of a barrier between two product channels. Use the following diabatic Hamiltonian definition for the electronic subsystem:\n$$\n\\hat{H}(x) \\;=\\; \\begin{pmatrix}\nV_{11}(x) & V_{12}(x) \\\\\nV_{12}(x) & V_{22}(x)\n\\end{pmatrix},\n$$\nwith\n$$\nV_{11}(x) \\;=\\; \\tfrac{1}{2}\\,k\\,(x-d)^2,\\quad\nV_{22}(x) \\;=\\; \\tfrac{1}{2}\\,k\\,(x+d)^2,\\quad\nV_{12}(x) \\;=\\; \\Delta,\n$$\nand adopt atomic units so that the reduced Planck constant is $1$ and the electron mass is $1$. The derivative of the Hamiltonian with respect to position is\n$$\n\\frac{\\partial \\hat{H}}{\\partial x}(x) \\;=\\; \\begin{pmatrix}\nk\\,(x-d) & 0 \\\\\n0 & k\\,(x+d)\n\\end{pmatrix}.\n$$\nThe Ehrenfest equations of motion are\n$$\n\\mathrm{i}\\,\\frac{d}{dt}\\,\\mathbf{c}(t) \\;=\\; \\hat{H}\\big(x(t)\\big)\\,\\mathbf{c}(t),\n$$\n$$\nm\\,\\frac{d^2 x}{dt^2} \\;=\\; -\\,\\left\\langle \\mathbf{c}(t) \\left| \\frac{\\partial \\hat{H}}{\\partial x}\\big(x(t)\\big) \\right| \\mathbf{c}(t) \\right\\rangle,\n$$\nwith the normalization constraint\n$$\n\\langle \\mathbf{c}(t) | \\mathbf{c}(t) \\rangle \\;=\\; 1.\n$$\nHere, $\\mathbf{c}(t)$ is the two-component complex electronic state vector, $x(t)$ is the classical nuclear coordinate, and $m$ is the nuclear mass. Adopt the following fixed parameters for the potential and mass:\n$$\nk \\;=\\; 0.2,\\quad d \\;=\\; 2.0,\\quad \\Delta \\;=\\; 0.1,\\quad m \\;=\\; 1836.\n$$\nThese choices ensure that the lower adiabatic surface has two minima near $x \\approx -d$ and $x \\approx +d$ separated by a barrier near $x \\approx 0$, with barrier height\n$$\nE_{\\text{barrier}} \\;=\\; \\tfrac{1}{2}\\,k\\,d^2 - \\Delta \\;=\\; 0.5 \\cdot 0.2 \\cdot (2.0)^2 - 0.1 \\;=\\; 0.3.\n$$\nYou must simulate the coupled Ehrenfest dynamics for the following test suite of three cases, each specified by an initial position $x(0)$, initial velocity $v(0)$ (with $v \\equiv dx/dt$), and an initial normalized electronic state $\\mathbf{c}(0)$:\n- Case $1$: $x(0)=0.0$, $v(0)=0.0$, $\\mathbf{c}(0)=\\frac{1}{\\sqrt{2}}(1,\\,1)$, total simulation time $T=50.0$, time step $\\Delta t=0.01$.\n- Case $2$: $x(0)=0.0$, $v(0)=0.0$, $\\mathbf{c}(0)=(\\sqrt{0.8},\\,\\sqrt{0.2})$, total simulation time $T=200.0$, time step $\\Delta t=0.01$.\n- Case $3$: $x(0)=0.0$, $v(0)=0.02$, $\\mathbf{c}(0)=\\frac{1}{\\sqrt{2}}(1,\\,1)$, total simulation time $T=150.0$, time step $\\Delta t=0.01$.\n\nUse atomic units throughout. Angles are not used. For classification of outcomes, define the product regions as $x \\le -x_{\\text{prod}}$ (left product) and $x \\ge +x_{\\text{prod}}$ (right product), with\n$$\nx_{\\text{prod}} \\;=\\; 1.0.\n$$\nDefine the barrier-top trapping region by\n$$\n|x(T)| \\;<\\; x_{\\text{trap}} \\quad \\text{and} \\quad |v(T)| \\;<\\; v_{\\text{trap}},\n$$\nwith thresholds\n$$\nx_{\\text{trap}} \\;=\\; 0.05, \\qquad v_{\\text{trap}} \\;=\\; 10^{-3}.\n$$\nFor each case, integrate up to the specified final time $T$ and output a classification integer according to:\n- Output $-1$ if $x(T) \\le -x_{\\text{prod}}$.\n- Output $+1$ if $x(T) \\ge +x_{\\text{prod}}$.\n- Output $0$ if $|x(T)| < x_{\\text{trap}}$ and $|v(T)| < v_{\\text{trap}}$.\n- If none of the above criteria are met, output $0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of the three classification integers enclosed in square brackets, for example $[a,b,c]$. The output must be unitless and contain no additional text or spaces.",
            "solution": "The problem presented is a valid exercise in computational physics, specifically in the domain of non-adiabatic molecular dynamics. It requires the implementation of the Ehrenfest mean-field method for a canonical two-state, one-dimensional model system. The objective is to simulate the coupled quantum-classical dynamics and demonstrate a known artifact of the Ehrenfest approximation: the trapping of a nuclear trajectory on a potential energy barrier where a correct quantum treatment would predict bifurcation. All parameters and conditions are well-defined, and the problem is scientifically sound.\n\nThe core of the problem lies in the numerical integration of the coupled Ehrenfest equations of motion. For a system with a classical nuclear coordinate $x(t)$ and a quantum electronic state vector $\\mathbf{c}(t)$, these equations are:\n$$\n\\mathrm{i}\\,\\hbar\\,\\frac{d}{dt}\\,\\mathbf{c}(t) \\;=\\; \\hat{H}\\big(x(t)\\big)\\,\\mathbf{c}(t)\n$$\n$$\nm\\,\\frac{d^2 x}{dt^2} \\;=\\; -\\,\\left\\langle \\mathbf{c}(t) \\left| \\frac{\\partial \\hat{H}}{\\partial x}\\big(x(t)\\big) \\right| \\mathbf{c}(t) \\right\\rangle\n$$\nIn atomic units, the reduced Planck constant $\\hbar$ is set to $1$. The first equation is the time-dependent Schrödinger equation for the electronic subsystem, governed by the electronic Hamiltonian $\\hat{H}(x)$ which depends parametrically on the nuclear position. The second is Newton's second law for the nucleus, where the force is the expectation value of the negative gradient of the Hamiltonian operator. This force is known as the Ehrenfest or mean-field force.\n\nFor the specified diabatic Hamiltonian,\n$$\n\\hat{H}(x) \\;=\\; \\begin{pmatrix}\n\\tfrac{1}{2}\\,k\\,(x-d)^2 & \\Delta \\\\\n\\Delta & \\tfrac{1}{2}\\,k\\,(x+d)^2\n\\end{pmatrix}\n$$\nand its derivative with respect to position,\n$$\n\\frac{\\partial \\hat{H}}{\\partial x}(x) \\;=\\; \\begin{pmatrix}\nk\\,(x-d) & 0 \\\\\n0 & k\\,(x+d)\n\\end{pmatrix}\n$$\nthe Ehrenfest force on the nucleus, with $\\mathbf{c}(t) = (c_1(t), c_2(t))^T$, is explicitly calculated as:\n$$\nF_{\\text{Ehrenfest}} = -\\left( c_1^*, c_2^* \\right) \\begin{pmatrix} k(x-d) & 0 \\\\ 0 & k(x+d) \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = - \\left( |c_1|^2 k(x-d) + |c_2|^2 k(x+d) \\right)\n$$\nThis force is a weighted average of the forces corresponding to the two diabatic potential surfaces, $V_{11}(x)$ and $V_{22}(x)$, with the weights being the electronic populations, $|c_1|^2$ and $|c_2|^2$.\n\nTo propagate the system in time, we employ a robust numerical integration scheme. A synchronized Velocity Verlet algorithm is chosen for the classical degree of freedom, praised for its time-reversibility and energy conservation properties. The quantum propagation of the electronic state vector $\\mathbf{c}(t)$ is handled with a symmetric split-operator technique to ensure accuracy and unitarity.\n\nThe algorithm for a single time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$ is as follows:\n$1$. Update the nuclear position:\n$$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\nwhere $a_n = F(x_n, \\mathbf{c}_n) / m$ is the acceleration at the beginning of the step.\n\n$2$. Propagate the electronic state vector. To maintain second-order accuracy, a symmetric splitting is used: the state is propagated for a half-step using the Hamiltonian at $x_n$, and for another half-step using the Hamiltonian at $x_{n+1}$:\n$$ \\mathbf{c}' = \\exp\\left(-\\mathrm{i}\\,\\hat{H}(x_n)\\,\\frac{\\Delta t}{2}\\right) \\mathbf{c}_n $$\n$$ \\mathbf{c}_{n+1} = \\exp\\left(-\\mathrm{i}\\,\\hat{H}(x_{n+1})\\,\\frac{\\Delta t}{2}\\right) \\mathbf{c}' $$\n\n$3$. Calculate the new acceleration. The force at the end of the step, $F_{n+1}$, is computed using the updated position $x_{n+1}$ and the updated state vector $\\mathbf{c}_{n+1}$:\n$$a_{n+1} = \\frac{F(x_{n+1}, \\mathbf{c}_{n+1})}{m}$$\n\n$4$. Update the nuclear velocity:\n$$v_{n+1} = v_n + \\frac{1}{2}(a_n + a_{n+1})\\Delta t$$\nThe quantities $(x_{n+1}, v_{n+1}, \\mathbf{c}_{n+1}, a_{n+1})$ then serve as the initial values for the next time step.\n\nThe quantum propagator, $\\exp(-\\mathrm{i} \\hat{H} \\tau)$, where $\\tau$ is the time interval, is computed analytically. For the given $2 \\times 2$ Hamiltonian $\\hat{H} = \\begin{pmatrix} A & C \\\\ C & B \\end{pmatrix}$, we can write it as $\\hat{H} = \\bar{E}I + H_0$, where $\\bar{E} = (A+B)/2$ is the average diagonal energy, $I$ is the identity matrix, and $H_0 = \\begin{pmatrix} \\delta & C \\\\ C & -\\delta \\end{pmatrix}$ with $\\delta = (A-B)/2$. The propagator is then:\n$$\n\\exp(-\\mathrm{i} \\hat{H} \\tau) = e^{-\\mathrm{i}\\bar{E}\\tau} \\left( \\cos(\\Omega \\tau)I - \\mathrm{i}\\frac{\\sin(\\Omega \\tau)}{\\Omega} H_0 \\right)\n$$\nwhere $\\Omega = \\sqrt{\\delta^2 + C^2}$ is the generalized Rabi frequency. This analytical formula is numerically stable and exact.\n\nThe three test cases explore the behavior of this system under different initial conditions:\n- **Case 1**: Starts at $x(0)=0$ with $v(0)=0$ in a symmetric superposition $\\mathbf{c}(0)=\\frac{1}{\\sqrt{2}}(1,1)$, which is the upper adiabatic eigenstate at $x=0$. The initial Ehrenfest force is exactly zero. Due to symmetry, the particle remains stationary at the top of the barrier, demonstrating trapping. The outcome is expected to be $0$.\n- **Case 2**: Starts at $x(0)=0$ with $v(0)=0$ but with an asymmetric superposition $\\mathbf{c}(0)=(\\sqrt{0.8}, \\sqrt{0.2})$. This asymmetry creates a non-zero initial force, $F(0) = -[0.8 k(-d) + 0.2 k(d)] = 0.6kd > 0$. The particle is pushed toward the right-hand product channel, corresponding to an outcome of $+1$.\n- **Case 3**: Same as Case 1, but with a small initial velocity $v(0)=0.02$. This kick displaces the particle from the unstable equilibrium point. The mean-field potential for the upper adiabatic state has a maximum at $x=0$. However, the Ehrenfest force, determined by the evolving populations, acts as a restoring force, pulling the nucleus back towards the origin. This leads to oscillations around $x=0$ and eventual trapping, a classic example of the failure of the mean-field approximation to describe bond-breaking or reaction branching. The outcome is expected to be $0$.\n\nThe provided program implements this complete algorithm to simulate the specified cases and determine the final classification for each.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Ehrenfest dynamics problem for the three specified test cases.\n    \"\"\"\n\n    # Fixed parameters in atomic units\n    K_CONST = 0.2\n    D_CONST = 2.0\n    DELTA_CONST = 0.1\n    MASS = 1836.0\n\n    # Classification thresholds\n    X_PROD = 1.0\n    X_TRAP = 0.05\n    V_TRAP = 1e-3\n\n    test_cases = [\n        # Case 1: x(0)=0.0, v(0)=0.0, c(0)=(1,1)/sqrt(2), T=50.0, dt=0.01\n        (0.0, 0.0, np.array([1.0, 1.0], dtype=np.complex128) / np.sqrt(2.0), 50.0, 0.01),\n        # Case 2: x(0)=0.0, v(0)=0.0, c(0)=(sqrt(0.8), sqrt(0.2)), T=200.0, dt=0.01\n        (0.0, 0.0, np.array([np.sqrt(0.8), np.sqrt(0.2)], dtype=np.complex128), 200.0, 0.01),\n        # Case 3: x(0)=0.0, v(0)=0.02, c(0)=(1,1)/sqrt(2), T=150.0, dt=0.01\n        (0.0, 0.02, np.array([1.0, 1.0], dtype=np.complex128) / np.sqrt(2.0), 150.0, 0.01),\n    ]\n\n    results = []\n\n    def get_hamiltonian(x, k, d, delta_):\n        \"\"\"Constructs the 2x2 diabatic Hamiltonian matrix.\"\"\"\n        v11 = 0.5 * k * (x - d)**2\n        v22 = 0.5 * k * (x + d)**2\n        v12 = delta_\n        return np.array([[v11, v12], [v12, v22]], dtype=np.complex128)\n\n    def get_hamiltonian_derivative(x, k, d):\n        \"\"\"Constructs the derivative of the Hamiltonian w.r.t. position x.\"\"\"\n        dv11_dx = k * (x - d)\n        dv22_dx = k * (x + d)\n        return np.array([[dv11_dx, 0.0], [0.0, dv22_dx]], dtype=np.complex128)\n\n    def calculate_force(x, c, k, d):\n        \"\"\"Calculates the Ehrenfest force on the nucleus.\"\"\"\n        dH_dx = get_hamiltonian_derivative(x, k, d)\n        # F = -<c|dH/dx|c>\n        force = -np.real(np.vdot(c, dH_dx @ c))\n        return force\n\n    def propagate_c(c_in, H, dt):\n        \"\"\"Propagates the electronic state vector c by time dt under Hamiltonian H.\"\"\"\n        A = H[0, 0]\n        B = H[1, 1]\n        C = H[0, 1]\n        \n        E_bar = (A + B) / 2.0\n        delta = (A - B) / 2.0\n        \n        omega = np.sqrt(delta**2 + C**2)\n        \n        # Handle the case omega = 0 to avoid division by zero, though unlikely here\n        if np.abs(omega) < 1e-15:\n            sin_omega_dt_over_omega = dt\n        else:\n            sin_omega_dt_over_omega = np.sin(omega * dt) / omega\n\n        cos_omega_dt = np.cos(omega * dt)\n        \n        # H0 = H - E_bar * I\n        H0 = np.array([[delta, C], [C, -delta]], dtype=np.complex128)\n        \n        # Propagator: U = e^(-i*E_bar*dt) * (cos(omega*dt)*I - i*sin(omega*dt)/omega * H0)\n        propagator = np.exp(-1j * E_bar * dt) * (\n            cos_omega_dt * np.identity(2) - 1j * sin_omega_dt_over_omega * H0\n        )\n        \n        c_out = propagator @ c_in\n        return c_out\n\n    for case in test_cases:\n        x, v, c, T, dt = case\n        num_steps = int(T / dt)\n        \n        # Initial force and acceleration\n        force = calculate_force(x, c, K_CONST, D_CONST)\n        accel = force / MASS\n\n        for _ in range(num_steps):\n            # Synchronized Velocity Verlet integration scheme\n            # 1. Update position\n            x_new = x + v * dt + 0.5 * accel * dt**2\n\n            # 2. Propagate electronic state (symmetric splitting)\n            H_old = get_hamiltonian(x, K_CONST, D_CONST, DELTA_CONST)\n            c_half = propagate_c(c, H_old, dt / 2.0)\n            \n            H_new = get_hamiltonian(x_new, K_CONST, D_CONST, DELTA_CONST)\n            c_new = propagate_c(c_half, H_new, dt / 2.0)\n            \n            # 3. Calculate new force and acceleration\n            force_new = calculate_force(x_new, c_new, K_CONST, D_CONST)\n            accel_new = force_new / MASS\n\n            # 4. Update velocity\n            v_new = v + 0.5 * (accel + accel_new) * dt\n\n            # 5. Update state for the next step\n            x, v, c, accel = x_new, v_new, c_new, accel_new\n\n        # Classify the outcome\n        final_x = x\n        final_v = v\n        \n        if final_x <= -X_PROD:\n            results.append(-1)\n        elif final_x >= X_PROD:\n            results.append(1)\n        elif abs(final_x) < X_TRAP and abs(final_v) < V_TRAP:\n            results.append(0)\n        else:\n            results.append(0) # Default case as per problem description\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Despite its limitations with branching dynamics, Ehrenfest theory remains a valuable tool for modeling non-adiabatic transitions and estimating state-to-state probabilities. This exercise  applies the method to a common scenario: a nuclear trajectory passing through a region of strong electronic coupling, modeled by diabatic potentials that cross. By simulating the dynamics under different conditions, you will observe phenomena like population inversion and explore how the outcome of the non-adiabatic event depends critically on parameters like nuclear velocity and coupling strength.",
            "id": "2454734",
            "problem": "You are asked to build and analyze a minimal model of Ehrenfest dynamics in one spatial dimension with two coupled electronic states. The model must be designed to exhibit population inversion for at least one parameter set, meaning that the final population on the second electronic state exceeds $0.5$ after the nuclear coordinate passes through the coupling region.\n\nStart from the following fundamental base:\n- The time-dependent Schrödinger equation (TDSE) for the electronic state amplitudes: $i \\hbar \\, \\frac{d}{dt} \\lvert \\psi_e(t) \\rangle = \\hat{H}_e(x(t)) \\lvert \\psi_e(t) \\rangle$, where $x(t)$ is the classical nuclear coordinate.\n- Newton’s second law for the nuclear degree of freedom with mass $m$: $m \\, \\frac{d^2 x}{dt^2} = F(x, \\lvert \\psi_e \\rangle)$.\n- The Ehrenfest force is the negative spatial gradient of the electronic energy expectation: $F(x, \\lvert \\psi_e \\rangle) = - \\frac{\\partial}{\\partial x} \\langle \\psi_e \\rvert \\hat{H}_e(x) \\lvert \\psi_e \\rangle$.\n- Use atomic units (a.u.) so that $\\hbar = 1$. All quantities should be treated in atomic units. The outputs required are dimensionless populations.\n\nDesign a two-state diabatic electronic Hamiltonian $\\hat{H}_e(x)$ with one-dimensional nuclear coordinate $x$ given by a $2 \\times 2$ matrix with elements depending on $x$:\n- Two diabatic potentials that linearly cross, and a localized coupling:\n  - $V_{11}(x) = a \\, x$,\n  - $V_{22}(x) = -a \\, x$,\n  - $V_{12}(x) = V_{c} \\, \\exp\\!\\left( - \\frac{x^2}{b^2} \\right)$,\n  - $\\hat{H}_e(x) = \\begin{pmatrix} V_{11}(x) & V_{12}(x) \\\\ V_{12}(x) & V_{22}(x) \\end{pmatrix}$.\n- The electronic wavefunction is a two-component column vector $\\lvert \\psi_e \\rangle = (c_1, c_2)^\\top$ with $c_1, c_2 \\in \\mathbb{C}$.\n- The nuclear force is to be computed from the Ehrenfest expectation value and its spatial derivative using the above fundamental principle, with mass $m$.\n\nDefine initial conditions:\n- Nuclear initial position $x(0) = x_0$ and initial momentum $p_0$, so that the initial velocity is $v(0) = p_0 / m$.\n- Electronic initial state fully on diabatic state $1$: $c_1(0) = 1$, $c_2(0) = 0$.\n\nNumerically integrate the coupled equations of motion:\n- Electronic amplitudes $c_1(t), c_2(t)$ evolve according to the TDSE with $\\hat{H}_e(x(t))$.\n- Nuclear position $x(t)$ and velocity $v(t)$ evolve according to Newton’s second law with the Ehrenfest mean-field force.\n- Use a fixed time step integrator with sufficiently small step to resolve the dynamics. You may use a standard explicit Runge–Kutta method. You must renormalize the electronic state after each step to unit norm to control numerical drift.\n\nCompute the final diabatic population on state $2$ at final time $T$ as $P_2(T) = \\lvert c_2(T) \\rvert^2$. This $P_2(T)$ is dimensionless.\n\nYour program must implement the model and compute $P_2(T)$ for each test case below. Use the given parameters exactly. All quantities are in atomic units. The outputs for each test case are the final populations $P_2(T)$ as floating-point numbers.\n\nTest suite (each tuple is $(m, a, V_c, b, x_0, p_0, T, \\Delta t)$):\n- Case A (strong coupling, moderate speed; should exhibit population inversion): $(2000.0, 0.01, 0.05, 1.0, -6.0, 40.0, 600.0, 0.05)$.\n- Case B (weak coupling, same speed; should not invert): $(2000.0, 0.01, 0.005, 1.0, -6.0, 40.0, 600.0, 0.05)$.\n- Case C (strong coupling, very fast transit; likely no inversion): $(2000.0, 0.01, 0.05, 1.0, -6.0, 800.0, 80.0, 0.01)$.\n- Case D (strong but narrow coupling; reduced effective interaction; may not invert): $(2000.0, 0.01, 0.05, 0.3, -6.0, 40.0, 600.0, 0.02)$.\n\nImplementation requirements:\n- Use atomic units throughout, and report the final populations as unitless floating-point values.\n- For each test case, initialize $x(0) = x_0$, $v(0) = p_0 / m$, $c_1(0) = 1$, $c_2(0) = 0$, then integrate up to $t = T$ with fixed step $\\Delta t$.\n- Use the above-defined Hamiltonian and fundamental laws. Do not use any pre-derived nonadiabatic transition formulas.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\left[ r_1, r_2, r_3, r_4 \\right]$, where each $r_k$ is $P_2(T)$ for the $k$-th test case formatted as a decimal number.\n\nThe final outputs are the list of $P_2(T)$ values for Cases A–D, in that order, formatted on one line as a Python list literal. Since populations are dimensionless, no unit conversion is required, but you must ensure that all intermediate quantities are propagated in atomic units.",
            "solution": "The problem is valid as it presents a well-defined, scientifically grounded task in computational chemistry. It requires the implementation of Ehrenfest dynamics for a two-state model system, which is a standard method for simulating nonadiabatic processes. All required equations, parameters, and initial conditions are provided, making the problem self-contained and numerically solvable.\n\nThe solution involves numerically integrating a system of coupled first-order ordinary differential equations (ODEs). The state of the system at any time $t$ is fully described by a vector $Y(t) = (x(t), v(t), c_1(t), c_2(t))^\\top$, where $x(t)$ is the nuclear position, $v(t)$ is the nuclear velocity, and $c_1(t)$ and $c_2(t)$ are the complex amplitudes of the two diabatic electronic states.\n\nThe evolution of the nuclear degrees of freedom is governed by Newton's second law, expressed as two first-order ODEs:\n$$ \\frac{dx}{dt} = v $$\n$$ \\frac{dv}{dt} = \\frac{F(x, \\lvert \\psi_e \\rangle)}{m} $$\nwhere $m$ is the nuclear mass and $F$ is the Ehrenfest force. The force is derived from the expectation value of the electronic energy, $E_e = \\langle \\psi_e \\rvert \\hat{H}_e(x) \\lvert \\psi_e \\rangle$. The standard Ehrenfest force is the negative expectation value of the gradient of the electronic Hamiltonian operator, $F = -\\left\\langle \\psi_e \\left| \\frac{\\partial \\hat{H}_e(x)}{\\partial x} \\right| \\psi_e \\right\\rangle$.\n\nThe specified diabatic electronic Hamiltonian $\\hat{H}_e(x)$ is a $2 \\times 2$ matrix:\n$$ \\hat{H}_e(x) = \\begin{pmatrix} V_{11}(x) & V_{12}(x) \\\\ V_{12}(x) & V_{22}(x) \\end{pmatrix} = \\begin{pmatrix} a x & V_c \\exp(-x^2/b^2) \\\\ V_c \\exp(-x^2/b^2) & -a x \\end{pmatrix} $$\nTo compute the force, we first determine the spatial derivative of the Hamiltonian matrix:\n$$ \\frac{\\partial \\hat{H}_e(x)}{\\partial x} = \\begin{pmatrix} \\frac{\\partial V_{11}}{\\partial x} & \\frac{\\partial V_{12}}{\\partial x} \\\\ \\frac{\\partial V_{12}}{\\partial x} & \\frac{\\partial V_{22}}{\\partial x} \\end{pmatrix} = \\begin{pmatrix} a & - \\frac{2x}{b^2} V_c e^{-x^2/b^2} \\\\ - \\frac{2x}{b^2} V_c e^{-x^2/b^2} & -a \\end{pmatrix} $$\nThe force is then the negative of the expectation value of this operator with respect to the electronic state $\\lvert \\psi_e \\rangle = (c_1, c_2)^\\top$:\n$$ F(x, t) = -\\left( |c_1|^2 a + |c_2|^2 (-a) + 2 \\text{Re}(c_1^* c_2) \\left(- \\frac{2x}{b^2} V_c e^{-x^2/b^2}\\right) \\right) $$\n$$ F(x, t) = -a(|c_1|^2 - |c_2|^2) + \\frac{4x}{b^2} \\text{Re}(c_1^* c_2) V_c e^{-x^2/b^2} $$\nHere, $|c_1|^2$ and $|c_2|^2$ are the populations on the respective diabatic states.\n\nThe evolution of the electronic amplitudes $c_1(t)$ and $c_2(t)$ is described by the time-dependent Schrödinger equation (TDSE), using atomic units where $\\hbar = 1$:\n$$ i \\frac{d}{dt} \\lvert \\psi_e(t) \\rangle = \\hat{H}_e(x(t)) \\lvert \\psi_e(t) \\rangle $$\nThis matrix equation translates into a set of two coupled first-order ODEs for the complex amplitudes:\n$$ \\frac{dc_1}{dt} = -i \\left( V_{11}(x(t)) c_1 + V_{12}(x(t)) c_2 \\right) $$\n$$ \\frac{dc_2}{dt} = -i \\left( V_{12}(x(t)) c_1 + V_{22}(x(t)) c_2 \\right) $$\n\nThis complete system of ODEs for $x$, $v$, $c_1$, and $c_2$ is solved numerically. We implement the fourth-order Runge-Kutta (RK4) algorithm with a fixed time step $\\Delta t$, as suggested. For each time step from an initial time $t_n$ to $t_{n+1} = t_n + \\Delta t$, the state vector $Y_n = (x_n, v_n, c_{1,n}, c_{2,n})^\\top$ is updated as follows:\n$$ k_1 = \\Delta t \\cdot f(t_n, Y_n) $$\n$$ k_2 = \\Delta t \\cdot f(t_n + \\Delta t/2, Y_n + k_1/2) $$\n$$ k_3 = \\Delta t \\cdot f(t_n + \\Delta t/2, Y_n + k_2/2) $$\n$$ k_4 = \\Delta t \\cdot f(t_n + \\Delta t, Y_n + k_3) $$\n$$ Y_{n+1} = Y_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4) $$\nwhere $f(t, Y)$ is the vector function of derivatives defined by the equations of motion.\n\nAfter each integration step, the electronic state vector $(c_1, c_2)^\\top$ is renormalized to have a unit norm, i.e., $|c_1|^2 + |c_2|^2 = 1$. This procedure is essential to counteract numerical drift that can violate the conservation of probability over long simulations.\n\nThe simulation starts from the initial conditions $x(0) = x_0$, $p(0)=p_0$ (so $v(0) = p_0/m$), $c_1(0) = 1$, and $c_2(0)=0$. The system is propagated until the final time $T$. The required output for each test case is the final population on the second diabatic state, $P_2(T) = \\lvert c_2(T) \\rvert^2$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the Ehrenfest dynamics problem for all test cases.\n    \"\"\"\n    # Test suite: (m, a, Vc, b, x0, p0, T, dt) in atomic units\n    test_cases = [\n        (2000.0, 0.01, 0.05, 1.0, -6.0, 40.0, 600.0, 0.05),   # Case A\n        (2000.0, 0.01, 0.005, 1.0, -6.0, 40.0, 600.0, 0.05),  # Case B\n        (2000.0, 0.01, 0.05, 1.0, -6.0, 800.0, 80.0, 0.01),   # Case C\n        (2000.0, 0.01, 0.05, 0.3, -6.0, 40.0, 600.0, 0.02),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, Vc, b, x0, p0, T, dt = case\n        final_pop_2 = run_ehrenfest_dynamics(m, a, Vc, b, x0, p0, T, dt)\n        results.append(final_pop_2)\n\n    # Format the output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_derivatives(t, Y, m, a, Vc, b):\n    \"\"\"\n    Computes the time derivative of the state vector Y = [x, v, c1, c2].\n    \n    Args:\n        t (float): Current time (not used but standard for ODE solvers).\n        Y (np.ndarray): State vector [x, v, c1, c2] as a complex array.\n        m, a, Vc, b (float): System parameters.\n\n    Returns:\n        np.ndarray: Derivative vector dY/dt.\n    \"\"\"\n    # Unpack state vector. x and v are real.\n    x, v, c1, c2 = Y[0].real, Y[1].real, Y[2], Y[3]\n\n    # Hamiltonian matrix elements at position x\n    V11 = a * x\n    V22 = -a * x\n    exp_term = np.exp(-x**2 / b**2)\n    V12 = Vc * exp_term\n\n    # Electronic derivatives from TDSE: d/dt |psi> = -i * H |psi>\n    dc1_dt = -1j * (V11 * c1 + V12 * c2)\n    dc2_dt = -1j * (V12 * c1 + V22 * c2)\n\n    # Ehrenfest force: F = -<psi| dH/dx |psi>\n    # dV11/dx = a\n    # dV22/dx = -a\n    # dV12/dx = V12 * (-2x / b^2)\n    P1 = np.abs(c1)**2\n    P2 = np.abs(c2)**2\n    # <psi|dH/dx|psi> = P1*a + P2*(-a) + 2*Re(c1*c2)*dV12/dx\n    force = -( (P1 - P2) * a + 2 * np.real(np.conj(c1) * c2) * V12 * (-2 * x / b**2) )\n\n    # Nuclear derivatives from Newton's laws\n    dv_dt = force / m\n    dx_dt = v\n\n    return np.array([dx_dt, dv_dt, dc1_dt, dc2_dt], dtype=np.complex128)\n\ndef run_ehrenfest_dynamics(m, a, Vc, b, x0, p0, T, dt):\n    \"\"\"\n    Performs a single Ehrenfest dynamics simulation using RK4 integrator.\n\n    Args:\n        m, a, Vc, b (float): Model parameters.\n        x0, p0 (float): Initial nuclear position and momentum.\n        T, dt (float): Total simulation time and time step.\n\n    Returns:\n        float: Final population on the second diabatic state, |c2(T)|^2.\n    \"\"\"\n    # Initial conditions\n    v0 = p0 / m\n    c1_0 = 1.0 + 0.0j\n    c2_0 = 0.0 + 0.0j\n\n    # State vector Y = [x, v, c1, c2]\n    Y = np.array([x0, v0, c1_0, c2_0], dtype=np.complex128)\n\n    num_steps = int(T / dt)\n    current_time = 0.0\n\n    for _ in range(num_steps):\n        # 4th-order Runge-Kutta step\n        k1 = dt * compute_derivatives(current_time, Y, m, a, Vc, b)\n        k2 = dt * compute_derivatives(current_time + 0.5 * dt, Y + 0.5 * k1, m, a, Vc, b)\n        k3 = dt * compute_derivatives(current_time + 0.5 * dt, Y + 0.5 * k2, m, a, Vc, b)\n        k4 = dt * compute_derivatives(current_time + dt, Y + k3, m, a, Vc, b)\n        \n        Y = Y + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n        \n        # Renormalize electronic coefficients to preserve norm\n        c1, c2 = Y[2], Y[3]\n        norm = np.sqrt(np.abs(c1)**2 + np.abs(c2)**2)\n        Y[2] = c1 / norm\n        Y[3] = c2 / norm\n        \n        current_time += dt\n\n    # Final population on state 2\n    final_c2 = Y[3]\n    final_pop_2 = np.abs(final_c2)**2\n\n    return final_pop_2\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}