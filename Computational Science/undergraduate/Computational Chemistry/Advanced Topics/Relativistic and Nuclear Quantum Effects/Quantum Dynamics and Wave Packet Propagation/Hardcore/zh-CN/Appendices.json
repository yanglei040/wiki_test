{
    "hands_on_practices": [
        {
            "introduction": "量子隧穿是量子力学的一个标志性现象，它揭示了粒子能够穿透经典物理学认为无法逾越的势垒。通过直接模拟一个高斯波包与势垒的相互作用，我们可以超越静态的、不含时间的模型，从而直观地理解这一过程。 这个练习将帮助你掌握搭建和运行量子动力学模拟的基本技能，包括如何通过对概率流密度进行时间积分来计算透射概率这一关键的可观测量。",
            "id": "2460912",
            "problem": "一个一维量子粒子在原子单位（其中 $\\hbar = 1$ 且 $m = 1$）下，其演化遵循含时薛定谔方程。一个初始局域在位置 $x_0$、空间宽度为 $\\sigma$、平均波数为 $k_0$ 的归一化高斯波包，从左侧入射到一个中心位于 $x_B=0$、高度为 $V_0$、宽度为 $a$ 的矩形势垒上。穿过势垒的隧穿（透射）概率可根据概率守恒定义为：在位于势垒右侧的固定探测位置 $x_\\text{probe}$ 处，对穿过该位置的总概率流进行全时间积分。实现一个数值求解器来传播波包，计算探测点处的瞬时概率流密度，并对透射流进行积分，以获得每个测试用例的透射概率。\n\n使用的基本原理和定义：\n- 含时薛定谔方程为\n$$\n\\mathrm{i}\\,\\frac{\\partial}{\\partial t}\\,\\psi(x,t) \\;=\\; \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V(x)\\right]\\psi(x,t).\n$$\n- 概率密度为 $\\rho(x,t) = |\\psi(x,t)|^2$。连续性方程为\n$$\n\\frac{\\partial \\rho(x,t)}{\\partial t} + \\frac{\\partial J(x,t)}{\\partial x} = 0,\n$$\n其中概率流密度为\n$$\nJ(x,t) \\;=\\; \\Im\\!\\left(\\psi^*(x,t)\\,\\frac{\\partial \\psi(x,t)}{\\partial x}\\right).\n$$\n- 矩形势垒为\n$$\nV(x) \\;=\\; \\begin{cases}\nV_0,  |x - x_B| \\le \\dfrac{a}{2},\\\\\n0,  \\text{其他}.\n\\end{cases}\n$$\n- 初始高斯波包为\n$$\n\\psi(x,0) \\;=\\; \\left(\\frac{1}{2\\pi \\sigma^2}\\right)^{1/4}\\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\sigma^2}\\right)\\exp(\\mathrm{i}k_0 x),\n$$\n必须在所选网格上对其进行数值归一化，以确保 $\\int |\\psi(x,0)|^2 \\,\\mathrm{d}x = 1$。\n\n数值要求：\n- 使用与含时薛定谔方程一致的稳定算法，在有限空间域中传播 $\\psi(x,t)$；例如，基于快速傅里叶变换 (FFT, Fast Fourier Transform) 的时间分裂谱方法是可接受的，但任何遵循上述方程并能达到相当精度的其他方法也均被允许。\n- 为防止来自模拟边界的非物理反射，请使用以复吸收层形式实现的吸收边界。一个便捷的选择是在左右边缘附近向势能中添加一个纯虚数项 $-\\,\\mathrm{i}\\,W(x)$，其中 $W(x) \\ge 0$ 是一个平滑函数，且在内部区域为零。\n- 在每个时间步计算固定探测位置 $x_\\text{probe}$ 处的瞬时概率流密度。为近似 $\\partial \\psi/\\partial x$，可使用空间步长为 $\\Delta x$ 的中心有限差分。\n- 将探测点处的透射流定义为正向贡献 $J_+(x_\\text{probe},t) = \\max(J(x_\\text{probe},t),0)$，并通过时间积分来近似透射概率\n$$\nT \\;\\approx\\; \\int_{0}^{T_\\text{end}} J_+(x_\\text{probe},t)\\,\\mathrm{d}t,\n$$\n其中 $T_\\text{end}$ 需足够大，以确保透射波包已完全通过探测点，且残余贡献可以忽略不计。\n\n所有测试用例共用的模拟参数：\n- 空间域 $[x_\\text{min},x_\\text{max}] = [-100,100]$。\n- 网格点数 $N = 2048$（均匀间距）。\n- 时间步长 $\\Delta t = 0.05$。\n- 总传播时间 $T_\\text{end} = 160$。\n- 在两个区域边缘附近的吸收层宽度 $x_\\text{cap} = 20$，强度参数 $\\eta = 0.02$，采用二次函数剖面 $W(x)$；即，在吸收区域内 $W(x) = \\eta\\,s(x)^2$，其中 $s(x)$ 在宽度 $x_\\text{cap}$ 上从 $0$ 递增到 $1$。\n- 势垒中心 $x_B = 0$，探测位置 $x_\\text{probe} = a/2 + 10$（相对于势垒宽度固定），初始波包中心 $x_0 = -60$，波包宽度 $\\sigma = 1.5$。\n\n测试套件：\n- 情况1：$k_0 = 1.5$，$V_0 = 2.0$，$a = 4.0$。\n- 情况2：$k_0 = 0.8$，$V_0 = 2.5$，$a = 6.0$。\n- 情况3：$k_0 = 2.5$，$V_0 = 1.0$，$a = 4.0$。\n\n答案规格：\n- 对于每种情况，使用上述概率流积分方案计算透射概率 $T$。每个 $T$ 都是无量纲的，在数值误差范围内必须位于 $[0,1]$ 区间。报告的每个结果都需四舍五入到六位小数。\n- 您的程序必须产生单行输出，其中包含三个结果，形式为方括号括起来的逗号分隔列表，例如 $[0.123456,0.000789,0.876543]$。\n- 无需外部输入，所有量均使用原子单位。请确保报告的值按规定四舍五入到六位小数。",
            "solution": "问题陈述已经过验证，被认为是科学上合理、良定且完整的。它描述了一个基于量子力学基本原理的计算量子动力学标准练习。数值求解所需的所有参数均已提供，且定义一致。我们可以继续进行求解。\n\n问题的核心是求解给定初始状态和势的一维含时薛定谔方程 (TDSE)。在原子单位（$\\hbar=1$, $m=1$）下，TDSE 为：\n$$ \\mathrm{i}\\,\\frac{\\partial}{\\partial t}\\,\\psi(x,t) \\;=\\; \\hat{H}\\psi(x,t) \\;=\\; \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V_{\\text{eff}}(x)\\right]\\psi(x,t) $$\n$t=0$ 时的初始状态是一个归一化高斯波包。有效势 $V_{\\text{eff}}(x)$ 包括实矩形势垒 $V(x)$ 和位于网格边界处用于防止非物理反射的虚复吸收势 (CAP) $- \\mathrm{i}W(x)$。\n\n为了在时间上传播波函数 $\\psi(x,t)$，我们采用时间分裂谱方法。该方法非常适合此问题，因为它精确、稳定且计算高效。在一个小时间步长 $\\Delta t$ 上的形式解涉及时间演化算符 $\\hat{U}(\\Delta t) = \\exp(-\\mathrm{i}\\hat{H}\\Delta t)$。由于动能算符 $\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}$ 和势能算符 $\\hat{V}_{\\text{eff}} = V_{\\text{eff}}(x)$ 不对易，我们使用二阶 Strang 分裂分解来近似演化算符：\n$$ \\hat{U}(\\Delta t) \\approx e^{-\\mathrm{i}\\hat{V}_{\\text{eff}}\\Delta t/2} e^{-\\mathrm{i}\\hat{T}\\Delta t} e^{-\\mathrm{i}\\hat{V}_{\\text{eff}}\\Delta t/2} $$\n这个近似的误差阶数为 $\\mathcal{O}(\\Delta t^3)$，为指定的参数提供了足够的精度。从时间 $t$ 到 $t+\\Delta t$ 的传播分三步执行：\n1. 在势能算符 $\\hat{V}_{\\text{eff}}$ 作用下的半步演化。在位置表象中，这是一个简单的乘法：$\\psi'(x) = e^{-\\mathrm{i}V_{\\text{eff}}(x)\\Delta t/2} \\psi(x,t)$。\n2. 在动能算符 $\\hat{T}$ 作用下的整步演化。此操作在位置空间中计算复杂，但在动量空间中则很简单，因为在动量空间中 $\\hat{T}$ 是一个简单的乘法算符 $\\hat{T}_k = k^2/2$。我们使用快速傅里叶变换 (FFT) 在不同表象之间切换。波函数被变换到动量空间 ($\\tilde{\\psi}'(k) = \\mathcal{F}[\\psi'(x)]$)，乘以动能演化因子 ($e^{-\\mathrm{i}k^2\\Delta t/2}$)，然后变换回位置空间 ($\\psi''(x) = \\mathcal{F}^{-1}[e^{-\\mathrm{i}k^2\\Delta t/2}\\tilde{\\psi}'(k)]$)。\n3. 在势能算符作用下的第二个半步演化：$\\psi(x, t+\\Delta t) = e^{-\\mathrm{i}V_{\\text{eff}}(x)\\Delta t/2} \\psi''(x)$。\n\n这个三步循环从 $t=0$ 重复到 $t=T_{\\text{end}}$。\n\n模拟域在区间 $[x_{\\text{min}}, x_{\\text{max}}] = [-100, 100]$ 上被离散化为一个包含 $N=2048$ 个点的均匀空间网格，间距为 $\\Delta x = (x_{\\text{max}}-x_{\\text{min}})/N$。相应的动量空间（波数）网格 $k$ 是使用与 FFT 算法一致的 `fftfreq` 工具构建的。\n\n初始波包由下式给出：\n$$ \\psi(x,0) \\;=\\; C \\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\sigma^2}\\right)\\exp(\\mathrm{i}k_0 x) $$\n其中 $C = (2\\pi \\sigma^2)^{-1/4}$。关键在于，对于离散网格上的数值计算，必须对此函数进行重新归一化，以确保由求和 $\\sum_j |\\psi(x_j,0)|^2 \\Delta x$ 近似的总概率 $\\int |\\psi(x,0)|^2 dx$ 恰好为 1。\n\n总有效势为 $V_{\\text{eff}}(x) = V(x) - \\mathrm{i}W(x)$。\n矩形势垒为：\n$$ V(x) \\;=\\; \\begin{cases} V_0,   |x| \\le a/2 \\\\ 0,   \\text{其他} \\end{cases} $$\n复吸收势 $W(x)$ 的构造使其仅在边界附近宽度为 $x_{\\text{cap}}=20$ 的区域内非零。如所指定，$W(x) = \\eta s(x)^2$，其中 $\\eta=0.02$，而 $s(x)$ 是一个从吸收区域起点处的 0 线性递增到网格边界处的 1 的函数。例如，在右边界 $x \\in [x_{\\text{max}}-x_{\\text{cap}}, x_{\\text{max}}]$ 上，$s(x) = \\frac{x-(x_{\\text{max}}-x_{\\text{cap}})}{x_{\\text{cap}}}$。这个虚势能平滑地吸收出射波函数，从而防止虚假反射。\n\n透射概率 $T$ 是通过对经过探测点的概率流密度的通量进行积分来确定的。概率流密度为：\n$$ J(x,t) \\;=\\; \\Im\\!\\left(\\psi^*(x,t)\\,\\frac{\\partial \\psi(x,t)}{\\partial x}\\right) $$\n在数值上，探测位置 $x_{\\text{probe}}$ 处的空间导数使用网格上的中心有限差分进行近似：\n$$ \\frac{\\partial \\psi(x_j,t)}{\\partial x} \\approx \\frac{\\psi(x_{j+1},t) - \\psi(x_{j-1},t)}{2\\Delta x} $$\n其中 $x_j$ 是最接近 $x_{\\text{probe}}$ 的网格点。透射概率 $T$ 是在探测位置 $x_{\\text{probe}} = a/2 + 10$ 处正向流的时间积分：\n$$ T \\;\\approx\\; \\sum_{n=0}^{N_t-1} \\max(J(x_{\\text{probe}}, t_n), 0) \\cdot \\Delta t $$\n其中 $t_n = n\\Delta t$ 且 $N_t = T_{\\text{end}}/\\Delta t$。此求和在整个模拟时间内进行。\n\n该算法的流程如下：首先初始化网格、势和归一化的波包。然后，时间演化循环将波函数在时间上向前传播。在每一步中，计算探测点处的流密度，并将其正贡献累加到积分透射概率中。对指定的三个测试用例中的每一个都重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef run_simulation(k0, V0, a):\n    \"\"\"\n    Runs a single quantum wave packet simulation for a given set of parameters.\n\n    Args:\n        k0 (float): Initial mean wavenumber of the wave packet.\n        V0 (float): Height of the potential barrier.\n        a (float): Width of the potential barrier.\n\n    Returns:\n        float: The computed transmission probability.\n    \"\"\"\n    # 1. Simulation parameters common to all cases\n    x_min, x_max = -100.0, 100.0\n    N = 2048\n    dt = 0.05\n    t_end = 160.0\n    num_steps = int(t_end / dt)\n    x_cap = 20.0\n    eta = 0.02\n    x0 = -60.0\n    sigma = 1.5\n    \n    # 2. Setup spatial and momentum grids\n    x = np.linspace(x_min, x_max, N, endpoint=False)\n    dx = x[1] - x[0]\n    \n    k_freq = fftfreq(N, d=dx)\n    k = 2 * np.pi * k_freq\n    \n    # 3. Initial wave packet\n    psi0_unnorm = (1 / (2 * np.pi * sigma**2))**(1/4) * \\\n                  np.exp(-(x - x0)**2 / (4 * sigma**2)) * \\\n                  np.exp(1j * k0 * x)\n    \n    # Numerical normalization on the discrete grid\n    norm_const = np.sqrt(np.sum(np.abs(psi0_unnorm)**2) * dx)\n    psi = psi0_unnorm / norm_const\n    \n    # 4. Define the potential\n    # Real part: Rectangular barrier\n    x_B = 0.0\n    V_real = np.zeros_like(x)\n    V_real[np.abs(x - x_B) = a / 2] = V0\n    \n    # Imaginary part: Complex Absorbing Potential (CAP)\n    W = np.zeros_like(x)\n    \n    # Right boundary absorber\n    mask_right = x = (x_max - x_cap)\n    if np.any(mask_right):\n        s_right = (x[mask_right] - (x_max - x_cap)) / x_cap\n        W[mask_right] = eta * s_right**2\n        \n    # Left boundary absorber\n    mask_left = x = (x_min + x_cap)\n    if np.any(mask_left):\n        s_left = ((x_min + x_cap) - x[mask_left]) / x_cap\n        W[mask_left] = eta * s_left**2\n    \n    V_eff = V_real - 1j * W\n    \n    # 5. Define time-evolution operators for split-step method\n    exp_V = np.exp(-0.5j * V_eff * dt)\n    exp_T = np.exp(-0.5j * k**2 * dt)\n    \n    # 6. Setup probe for transmission calculation\n    x_probe = a / 2 + 10.0\n    probe_idx = np.argmin(np.abs(x - x_probe))\n    \n    total_transmission = 0.0\n    \n    # 7. Time-evolution loop\n    for _ in range(num_steps):\n        # Strang splitting propagation step\n        psi = exp_V * psi\n        psi_k = fft(psi)\n        psi_k = exp_T * psi_k\n        psi = ifft(psi_k)\n        psi = exp_V * psi\n        \n        # Calculate probability current density at the probe location\n        # Using a centered finite difference for the derivative\n        dpsi_dx_probe = (psi[probe_idx + 1] - psi[probe_idx - 1]) / (2 * dx)\n        current_density_probe = np.imag(np.conj(psi[probe_idx]) * dpsi_dx_probe)\n        \n        # Integrate the positive-directed flux over time\n        total_transmission += max(0, current_density_probe) * dt\n        \n    return total_transmission\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.5, 2.0, 4.0),  # Case 1\n        (0.8, 2.5, 6.0),  # Case 2\n        (2.5, 1.0, 4.0),  # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        k0, V0, a = case\n        transmission = run_simulation(k0=k0, V0=V0, a=a)\n        results.append(f\"{transmission:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多真实的量子系统，例如与激光脉冲相互作用的分子，其所处的环境（即哈密顿量）是随时间变化的。 这个练习将探讨在这种含时哈密顿量下波包的演化，并引出绝热（缓慢变化）与非绝热（或称“猝变”，即快速变化）过程这两个核心物理概念。通过模拟一个谐振子势阱频率的平滑变化，你将亲手验证系统的最终状态如何依赖于势能面变化的速度，从而加深对量子系统如何响应外界扰动的理解。",
            "id": "2460889",
            "problem": "编写一个完整、可运行的程序，在谐振子含时薛定谔方程下传播一个一维量子波包，其中谐振子的弹簧系数随时间平滑增加。其哈密顿量为\n$$\n\\hat{H}(t) \\;=\\; -\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} \\;+\\; \\frac{1}{2}k(t)\\,x^2,\n$$\n其中 $m$ 为质量，$\\hbar$ 为约化普朗克常数，$x$ 为位置，$k(t)$ 为含时弹簧系数。在 $m=\\hbar=1$ 的无量纲单位制下进行计算，因此所有量均为无量纲。弹簧系数的规定如下\n$$\nk(t) \\;=\\; k_0 \\;+\\; \\big(k_1 - k_0\\big)\\, s\\!\\left(\\frac{t}{T}\\right),\n$$\n其中斜坡函数 $s(u)$ 是一个 $C^1$ 光滑多项式\n$$\ns(u) = \\begin{cases} 0,  u \\le 0 \\\\ 3u^2 - 2u^3,  0  u  1 \\\\ 1,  u \\ge 1 \\end{cases}\n$$\n而 $T$ 是总传播时间。在 $t=0$ 时的初始态是频率为 $\\omega_0=\\sqrt{k_0/m}=\\sqrt{k_0}$ 的谐振子的归一化基态，\n$$\n\\psi(x,0) \\;=\\; \\phi_0(x;\\omega_0) \\;=\\; \\left(\\frac{\\omega_0}{\\pi}\\right)^{1/4}\\exp\\!\\left(-\\frac{\\omega_0 x^2}{2}\\right).\n$$\n在哈密顿量 $\\hat{H}(t)$ 的作用下，将 $\\psi(x,t)$ 从 $t=0$ 传播到 $t=T$，并在时间 $t=T$ 计算保真度\n$$\nF \\;=\\; \\left|\\int_{-\\infty}^{+\\infty} \\phi_0(x;\\omega_1)^{\\ast}\\,\\psi(x,T)\\,dx\\right|^2,\n$$\n其中 $\\omega_1=\\sqrt{k_1}$，$\\phi_0(x;\\omega_1)$ 是对应于 $k_1$ 的归一化基态，\n$$\n\\phi_0(x;\\omega_1) \\;=\\; \\left(\\frac{\\omega_1}{\\pi}\\right)^{1/4}\\exp\\!\\left(-\\frac{\\omega_1 x^2}{2}\\right).\n$$\n使用一个包含 $N$ 个点的有限均匀空间网格 $x\\in[-X_{\\max},X_{\\max}]$ 来近似实轴，并确保在整个传播过程中波函数在边界处小到可以忽略不计。对所有测试用例使用以下数值规范：\n- 空间半宽度 $X_{\\max}=10$，\n- 网格点数 $N=1024$，\n- 时间步长 $\\Delta t=0.002$，\n- 传播从 $t=0$ 到 $t=T$（含端点）进行，使用均匀时间步长；如果 $T/\\Delta t$ 不是整数，则调整最后一步的步长，以确保最后一步正好落在 $t=T$。\n\n您的程序必须实现上述物理过程，并针对以下每个测试用例，使用指定的相同网格和时间步长，计算出保真度 $F$：\n\n- 情况 1（类绝热斜坡）：$(k_0,k_1,T)=(1.0,4.0,8.0)$。\n- 情况 2（类突变斜坡）：$(k_0,k_1,T)=(1.0,4.0,0.1)$。\n- 情况 3（无变化）：$(k_0,k_1,T)=(1.0,1.0,5.0)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个保真度精确到小数点后 $6$ 位，并按上述情况的顺序排列。例如，您的输出必须采用以下格式\n$$\n[\\;F_1,F_2,F_3\\;],\n$$\n其中每个 $F_j$ 是一个小数点后恰有 $6$ 位数字的十进制字符串。由于问题是完全无量纲化的，输出中不需要也不允许使用任何物理单位。",
            "solution": "所述问题是计算量子动力学中的一个标准练习。该问题被判断为有效，因为它在科学上是合理的，问题提法是适定的，并为数值求解提供了一套完整的参数。因此，我们将着手构建解决方案。\n\n控制一维量子系统演化的基本方程是含时薛定谔方程（TDSE）：\n$$\ni\\hbar \\frac{\\partial}{\\partial t}\\psi(x,t) = \\hat{H}(t) \\psi(x,t)\n$$\n在给定的无量纲单位制中，质量 $m=1$ 且约化普朗克常数 $\\hbar=1$，TDSE 简化为：\n$$\ni \\frac{\\partial}{\\partial t}\\psi(x,t) = \\left( -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + \\frac{1}{2}k(t)x^2 \\right) \\psi(x,t)\n$$\n这里，哈密顿量 $\\hat{H}(t) = \\hat{T} + \\hat{V}(x,t)$ 由一个不含时的动能算符 $\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}$ 和一个含时的势能算符 $\\hat{V}(x,t) = \\frac{1}{2}k(t)x^2$ 组成。\n\n为了数值求解这个偏微分方程，时间演化被离散化为时长为 $\\Delta t$ 的小步长。从 $t$ 到 $t+\\Delta t$ 的一个时间步长的形式解由 $\\psi(t+\\Delta t) = \\hat{U}(t+\\Delta t, t)\\psi(t)$ 给出，其中涉及到时间演化算符 $\\hat{U}$。对于足够小的 $\\Delta t$，我们可以近似认为哈密顿量在该区间内是恒定的，具体为 $\\hat{H}(t) \\approx \\hat{H}(t_{mid})$，其中 $t_{mid} = t + \\Delta t/2$。传播子则简化为 $\\hat{U} \\approx \\exp(-i\\hat{H}(t_{mid})\\Delta t)$。\n\n直接计算这个指数算符是不可行的，因为其构成算符 $\\hat{T}$ 和 $\\hat{V}$ 不对易，即 $[\\hat{T}, \\hat{V}] \\neq 0$。处理此类问题的标准且最有效的方法是对称分裂算符傅里叶变换法。该方法基于演化算符的二阶 Trotter-Suzuki 分解：\n$$\n\\exp\\big(-i(\\hat{T} + \\hat{V})\\Delta t\\big) = \\exp\\big(-i\\hat{V}\\frac{\\Delta t}{2}\\big)\\exp(-i\\hat{T}\\Delta t)\\exp\\big(-i\\hat{V}\\frac{\\Delta t}{2}\\big) + O(\\Delta t^3)\n$$\n这种对称分裂确保了数值演化是幺正的，从而守恒总概率（波函数的模方），并且模拟的全局误差为 $O(\\Delta t^2)$ 阶。\n\n将波函数 $\\psi(x)$ 推进一个时间步长 $\\Delta t$ 的算法分三个阶段进行：\n\n$1$。半个势能步：在势能算符 $\\hat{V}(x, t_{mid})$ 下将波函数传播半个时间步长。由于 $\\hat{V}$ 在位置表象中是一个乘法算符，此步骤是一个简单的乘法运算：\n$$\n\\psi'(x) = \\exp\\left(-i V(x, t_{mid}) \\frac{\\Delta t}{2}\\right) \\psi(x) = \\exp\\left(-i \\frac{k(t_{mid})x^2}{4} \\Delta t\\right) \\psi(x)\n$$\n\n$2$。完整动能步：在动能算符 $\\hat{T}$ 下传播一个完整的时间步长。动能算符在动量（$p$）表象中是对角的。因此，这一步在动量空间中执行效率最高。我们使用快速傅里叶变换（FFT）在不同表象间切换：\n    a. 将波函数变换到动量空间：$\\tilde{\\psi}'(p) = \\mathcal{F}[\\psi'(x)]$。\n    b. 应用在 $p$ 空间中对角的动能传播子：\n    $$\n    \\tilde{\\psi}''(p) = \\exp\\left(-i \\frac{p^2}{2} \\Delta t\\right) \\tilde{\\psi}'(p)\n    $$\n    c. 将结果变换回位置空间：$\\psi''(x) = \\mathcal{F}^{-1}[\\tilde{\\psi}''(p)]$。\n\n$3$。第二个半势能步：在相同的势能算符下传播最后半个时间步长：\n$$\n\\psi(x, t+\\Delta t) = \\exp\\left(-i V(x, t_{mid}) \\frac{\\Delta t}{2}\\right) \\psi''(x)\n$$\n\n这个三阶段序列在整个传播时间 $T$ 内重复进行。该实现需要一个离散的空间网格。区域 $x \\in [-X_{\\max}, X_{\\max}]$ 被离散化为 $N$ 个点。为了优化 FFT 的使用，我们定义了一个间距为 $\\Delta x = 2X_{\\max}/N$ 的周期性网格。位置网格点为 $x_j = -X_{\\max} + j\\cdot\\Delta x$，其中 $j=0, \\ldots, N-1$。相应的动量网格 $p_k$ 由 FFT 算法的离散频率 $f_k$ 导出，$p_k = 2\\pi f_k$，其中 $f_k$ 可通过 `scipy.fft.fftfreq(N, d=\\Delta x)` 等函数获得。\n\n在 $t=0$ 时的初始态 $\\psi(x,0)$ 是频率为 $\\omega_0 = \\sqrt{k_0}$ 的谐振子的基态。在离散网格上构建此高斯函数后，必须对其进行数值归一化：$\\psi_{norm}(x_j) = \\psi(x_j) / \\sqrt{\\Delta x \\sum_k |\\psi(x_k)|^2}$。\n\n时间传播从 $t=0$ 执行到 $t=T$。按照规定，这包括一系列大小为 $\\Delta t$ 的步长，以及最后可能更小的一步，以确保传播精确地在 $t=T$ 终止。\n\n时间演化完成后，末态为 $\\psi(x,T)$。然后通过计算与目标态 $\\phi_0(x;\\omega_1)$ 的交叠来计算保真度 $F$，该目标态是末态哈密顿量（频率为 $\\omega_1=\\sqrt{k_1}$）的基态。这个目标态也必须在网格上构建并进行数值归一化。保真度是此交叠积分的模方，近似为一个离散和：\n$$\nF = \\left| \\int_{-\\infty}^{\\infty} \\phi_0^*(x;\\omega_1) \\psi(x,T) dx \\right|^2 \\approx \\left| \\Delta x \\sum_j \\phi_0^*(x_j;\\omega_1) \\psi(x_j,T) \\right|^2\n$$\n\n所提供的测试用例正确地探究了预期的物理行为。情况 1（$T=8.0$）代表一个缓慢的、近绝热的斜坡，我们预期 $F \\approx 1$。情况 2（$T=0.1$）是一个快速的、非绝热的斜坡，其保真度较低，由初态和末态基态的交叠决定。情况 3（$k_0=k_1$）是数值准确性的一个关键测试；因为初始态是不含时哈密顿量的本征态，所以保真度必须恰好为 $1$，任何偏差都可归因于数值误差。",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Solves the time-dependent Schrödinger equation for a harmonic oscillator\n    with a time-varying spring constant and calculates the fidelity.\n    \"\"\"\n    \n    # Numerical specifications from the problem statement\n    X_max = 10.0\n    N = 1024\n    dt = 0.002\n    \n    # Setup spatial and momentum grids\n    dx = 2 * X_max / N\n    x = np.linspace(-X_max, X_max, N, endpoint=False)\n    p = 2 * np.pi * fft.fftfreq(N, d=dx)\n\n    test_cases = [\n        (1.0, 4.0, 8.0),  # Case 1: adiabatic-like ramp\n        (1.0, 4.0, 0.1),  # Case 2: sudden-like ramp\n        (1.0, 1.0, 5.0),  # Case 3: no change\n    ]\n\n    results = []\n\n    def s_ramp(u):\n        \"\"\" The C^1 smooth polynomial ramp function s(u). \"\"\"\n        if u = 0.0:\n            return 0.0\n        elif u = 1.0:\n            return 1.0\n        else:\n            return 3 * u**2 - 2 * u**3\n\n    def get_k_t(t, k0, k1, T):\n        \"\"\" Calculates the time-dependent spring constant k(t). \"\"\"\n        if T == 0.0: # Handle instantaneous change\n            return k1\n        return k0 + (k1 - k0) * s_ramp(t / T)\n\n    def ground_state(x_grid, omega):\n        \"\"\" Constructs the normalized ground state wavefunction. \"\"\"\n        psi = (omega / np.pi)**(1/4) * np.exp(-omega * x_grid**2 / 2)\n        # Numerical normalization\n        norm = np.sqrt(np.sum(np.abs(psi)**2) * dx)\n        return psi / norm\n\n    for k0, k1, T in test_cases:\n        # Initial state preparation\n        omega0 = np.sqrt(k0)\n        psi = ground_state(x, omega0)\n\n        # Time propagation setup\n        if T  0:\n            num_steps = int(round(T / dt, 10)) # Use rounding for float precision\n            effective_T = num_steps * dt\n            last_dt = T - effective_T\n            \n            # Handle cases where T is multiple of dt\n            if abs(last_dt / dt)  1e-9:\n                last_dt = 0.0\n            elif last_dt  0: # If T was slightly less than a multiple of dt\n                num_steps -=1\n                last_dt = T - num_steps*dt\n        else: # T=0 case\n            num_steps = 0\n            last_dt = 0.0\n\n        # --- Time Propagation Loop ---\n        # Main loop with fixed time step dt\n        T_prop_full = np.exp(-1j * 0.5 * p**2 * dt)\n        for i in range(num_steps):\n            t_mid = (i + 0.5) * dt\n            kt_mid = get_k_t(t_mid, k0, k1, T)\n            V_prop_half = np.exp(-1j * 0.5 * kt_mid * x**2 * dt / 2)\n            \n            # Split-operator steps\n            psi = V_prop_half * psi\n            psi = fft.ifft(T_prop_full * fft.fft(psi))\n            psi = V_prop_half * psi\n\n        # Final step with adjusted size last_dt\n        if last_dt  1e-9:\n            t_mid = num_steps * dt + 0.5 * last_dt\n            kt_mid = get_k_t(t_mid, k0, k1, T)\n            V_prop_half_last = np.exp(-1j * 0.5 * kt_mid * x**2 * last_dt / 2)\n            T_prop_last = np.exp(-1j * 0.5 * p**2 * last_dt)\n\n            psi = V_prop_half_last * psi\n            psi = fft.ifft(T_prop_last * fft.fft(psi))\n            psi = V_prop_half_last * psi\n            \n        # Fidelity calculation\n        omega1 = np.sqrt(k1)\n        target_psi = ground_state(x, omega1)\n        \n        overlap = np.sum(np.conj(target_psi) * psi) * dx\n        fidelity = np.abs(overlap)**2\n\n        results.append(f\"{fidelity:.6f}\")\n\n    print(f\"[{', '.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在量子力学中，测量扮演着一个深刻且非经典的角色。 这个练习旨在模拟奇特的“量子芝诺效应”，即频繁地观测一个量子系统可以“冻结”其状态，阻止其自然演化。通过在一个双势阱中对波包进行周期性的投影测量，你将学习如何在动力学模拟中引入非幺正的测量过程，并直观地看到观测行为是如何从根本上改变量子系统演化轨迹的。",
            "id": "2460919",
            "problem": "通过求解原子单位制下的含时薛定谔方程，模拟对称双势阱中粒子的一维量子芝诺效应，该模型包含重复的理想投影测量，将粒子限制在初始的（左侧）势阱中。整个计算在原子单位制下进行，其中约化普朗克常数 $\\hbar = 1$，粒子质量 $m = 1$，长度单位为玻尔（Bohr），能量单位为哈特里（Hartree），时间单位为原子时间单位。\n\n一个质量为 $m=1$ 的粒子在一维势场中运动\n$$\nV(x) = V_0 \\left(x^2 - b^2\\right)^2,\n$$\n其中 $V_0 = 0.2$ 且 $b = 1.0$。在时间 $t=0$ 时的初始波函数是一个归一化的高斯波包，中心位于左侧势阱，\n$$\n\\psi(x,0) = \\left(\\pi \\sigma^2\\right)^{-1/4} \\exp\\!\\left(-\\frac{(x - x_0)^2}{2 \\sigma^2}\\right),\n$$\n其中 $x_0 = -b$ 且 $\\sigma = 0.5$。时间演化由含时薛定谔方程决定\n$$\n\\mathrm{i}\\,\\frac{\\partial}{\\partial t}\\,\\psi(x,t) = \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V(x)\\right]\\psi(x,t).\n$$\n\n定义向左侧区域（初始势阱）的投影算符 $P_L$ 如下：\n$$\n(P_L \\psi)(x) = \\begin{cases}\n\\psi(x),  x  0,\\\\\n0,  x \\ge 0.\n\\end{cases}\n$$\n考虑在时间 $t_k = k\\,\\tau$ （$k \\ge 1$ 为整数）进行理想的瞬时测量，其中 $\\tau$ 是测量间隔。在每次测量之前的时间 $t_k^{-}$，计算左阱概率\n$$\np_k = \\langle \\psi(t_k^-)|P_L|\\psi(t_k^-)\\rangle = \\int_{-\\infty}^{0} |\\psi(x,t_k^-)|^2 \\,\\mathrm{d}x.\n$$\n在时间 $t_k^{+}$ 进行测量后，波函数被投影并重新归一化到左侧势阱中：\n$$\n\\psi(x,t_k^+) = \\frac{(P_L \\psi)(x,t_k^-)}{\\sqrt{p_k}},\n$$\n前提是 $p_k  0$。对于给定的测量间隔 $\\tau$，在总时间 $T$ 内的量子芝诺存活概率定义为\n$$\nS(\\tau,T) = \\prod_{k=1}^{\\left\\lfloor T/\\tau \\right\\rfloor} p_k.\n$$\n\n作为基准比较，定义最终时间 $T$ 时无测量的左阱概率（即没有任何投影的演化）为\n$$\nP_{\\text{left}}(T) = \\int_{-\\infty}^{0} |\\psi(x,T)|^2 \\,\\mathrm{d}x.\n$$\n\n所有测试用例使用的空间和时间离散化方案：\n- 空间域：$x \\in [-L, L]$，其中 $L = 8.0$。\n- 空间格点数：$N = 1024$（均匀网格）。\n- 时间步长：$\\Delta t = 0.005$。\n- 总模拟时间：$T = 12.0$。\n\n测试套件规范（所有量均为原子单位）：\n- 情况1（频繁测量）：$\\tau = 0.05$。\n- 情况2（中等频率测量）：$\\tau = 0.20$。\n- 情况3（稀疏测量）：$\\tau = 1.00$。\n- 情况4（基准，无测量）：演化到时间 $T$，不进行任何投影，并报告 $P_{\\text{left}}(T)$。\n\n你的程序必须：\n- 在给定的哈密顿量和离散化条件下，将 $\\psi(x,t)$ 从 $t=0$ 数值传播到 $t=T$。\n- 对于情况1-3，按定义应用理想测量序列，计算 $S(\\tau,T)$ 并报告。\n- 对于情况4，不应用任何测量，并报告 $P_{\\text{left}}(T)$。\n\n所有答案均为无量纲的概率。你的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 [情况1, 情况2, 情况3, 情况4]。将每个数字四舍五入至六位小数，例如，\"[0.999000,0.990000,0.800000,0.650000]\"。",
            "solution": "所提出的问题是计算量子力学中一个明确定义的练习，旨在具体展示量子芝诺效应。它在科学上基于量子动力学原理，在数学上是一致的，并且其参数的指定足够精确，可以得到唯一的数值解。因此，该问题被认为是有效的，我们将着手解决它。\n\n核心任务是求解一维含时薛定谔方程（TDSE），用于描述一个在双势阱中并受到一系列投影测量影响的粒子。在原子单位制（$\\hbar=1$, $m=1$）下，TDSE 表示为：\n$$\n\\mathrm{i}\\,\\frac{\\partial}{\\partial t}\\,\\psi(x,t) = \\hat{H}\\psi(x,t) = \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V(x)\\right]\\psi(x,t)\n$$\n在一个小的时间间隔 $\\Delta t$ 内，其形式解为 $\\psi(x, t+\\Delta t) = \\exp(-\\mathrm{i}\\hat{H}\\Delta t)\\psi(x,t)$。我们将采用分裂算符傅里叶变换方法来近似时间演化算符 $\\hat{U}(\\Delta t) = \\exp(-\\mathrm{i}\\hat{H}\\Delta t)$。哈密顿算符 $\\hat{H}$ 由动能算符 $\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}$ 和势能算符 $\\hat{V} = V(x) = V_0(x^2 - b^2)^2$ 组成。由于 $\\hat{T}$ 和 $\\hat{V}$ 不对易，我们使用二阶对称 Suzuki-Trotter（或 Strang）分裂：\n$$\n\\hat{U}(\\Delta t) = \\exp(-\\mathrm{i}(\\hat{T}+\\hat{V})\\Delta t) \\approx \\exp(-\\mathrm{i}\\hat{V}\\frac{\\Delta t}{2}) \\exp(-\\mathrm{i}\\hat{T}\\Delta t) \\exp(-\\mathrm{i}\\hat{V}\\frac{\\Delta t}{2})\n$$\n该方案是幺正的，并且精度达到 $(\\Delta t)^3$ 阶。传播过程按以下步骤执行：\n1.  在势能算符 $\\hat{V}$ 下演化半步。这在位置空间中很简单，因为 $\\hat{V}$ 是一个乘法算符：$\\psi(x) \\rightarrow \\exp(-\\mathrm{i}V(x)\\frac{\\Delta t}{2})\\psi(x)$。\n2.  在动能算符 $\\hat{T}$ 下演化一整步。动能算符在动量（或 $k$）空间中是对角化的。我们使用快速傅里叶变换（FFT）从位置基矢切换到动量基矢。令 $\\mathcal{F}$ 表示 FFT。在动量空间中，算符 $\\frac{\\partial^2}{\\partial x^2}$ 对应于乘以 $-k^2$，其中 $k$ 是波数。动能算符变为乘以 $T(k) = \\frac{k^2}{2}$。演化过程为 $\\tilde{\\psi}(k) \\rightarrow \\exp(-\\mathrm{i}T(k)\\Delta t)\\tilde{\\psi}(k)$，其中 $\\tilde{\\psi}(k) = \\mathcal{F}[\\psi(x)]$。此步之后，我们使用逆 FFT（$\\mathcal{F}^{-1}$）变换回位置空间。\n3.  最后，在势能算符 $\\hat{V}$ 下再演化半步。\n\n这三个步骤的序列将波函数传播一个时间步长 $\\Delta t$。\n\n数值模拟在一个空间网格 $x \\in [-L, L]$ 上进行，该网格包含 $N=1024$ 个点，且 $L=8.0$。网格间距为 $\\Delta x = 2L/N$。FFT 对应的动量网格也相应地构建。初始状态是一个归一化的高斯波包，中心位于左侧势阱（$x_0 = -b = -1.0$）。\n\n对于芝诺效应的情况（情况1-3），时间演化与间隔为 $\\tau$ 的测量交替进行。对于测量间隔为 $\\tau$ 的模拟过程如下：\n1.  初始化波函数 $\\psi(x,t=0)$ 和存活概率 $S=1.0$。\n2.  对 $k=1, 2, ..., \\lfloor T/\\tau \\rfloor$进行迭代。在每次迭代中：\n    a. 使用 $M = \\tau/\\Delta t$ 个分裂算符算法步骤，将波函数传播一个时长 $\\tau$。这得到 $\\psi(x, t_k^-)$。\n    b. 计算在左侧势阱（$x0$）中找到粒子的概率：\n       $$\n       p_k = \\int_{-\\infty}^{0} |\\psi(x,t_k^-)|^2 \\,\\mathrm{d}x\n       $$\n       该积分通过对所有格点 $x_i  0$ 上的 $|\\psi(x_i)|^2 \\Delta x$ 求和来进行数值计算。\n    c. 更新总存活概率：$S \\leftarrow S \\times p_k$。\n    d. 将波函数投影到左侧势阱。这通过对所有 $x_i \\ge 0$ 设置 $\\psi(x_i, t_k^-) = 0$ 来完成。\n    e. 重新归一化新状态：$\\psi(x,t_k^+) = \\frac{(P_L \\psi)(x,t_k^-)}{\\sqrt{p_k}}$。该状态作为下一个演化周期的初始条件。\n\n对于基准情况（情况4），不执行任何测量。波函数从 $t=0$ 连续演化到 $t=T=12.0$。然后计算最终的左阱概率 $P_{\\text{left}}(T) = \\int_{-\\infty}^{0} |\\psi(x,T)|^2 \\,\\mathrm{d}x$。\n\n为四个指定的情况分别实现该算法，并报告所得概率。预期的结果是，更频繁的测量（较小的 $\\tau$）将抑制从左阱到右阱的隧穿效应，从而导致更高的存活概率 $S$，这正是量子芝诺效应的一种表现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the time-dependent Schrödinger equation for a particle in a double-well\n    potential to model the quantum Zeno effect, as per the problem statement.\n    \"\"\"\n    # Define physical and numerical parameters in atomic units\n    V0 = 0.2\n    b = 1.0\n    x0 = -b\n    sigma = 0.5\n    L = 8.0\n    N = 1024\n    dt = 0.005\n    T_total = 12.0\n\n    # Test cases from the problem statement\n    # A tau of 0.0 means the no-measurement case in this implementation.\n    test_cases_tau = [0.05, 0.20, 1.00, 0.0]\n\n    # --- Grid and Operator Setup ---\n    # Spatial grid (endpoint=False is better for FFT)\n    x = np.linspace(-L, L, N, endpoint=False)\n    dx = x[1] - x[0]\n\n    # Momentum grid. np.fft.fftfreq gives frequencies for which p = 2*pi*hbar*k_freq.\n    # With hbar=1, p = 2*pi*k_freq.\n    k_freq = np.fft.fftfreq(N, d=dx)\n    # Kinetic energy operator diagonal term T_k = p^2/(2m). With m=1, T_k = (2*pi*k_freq)^2/2.\n    T_op_diag = 2.0 * (np.pi**2) * (k_freq**2)\n\n    # Potential energy operator V(x)\n    V_op = V0 * (x**2 - b**2)**2\n\n    # --- Propagators for Split-Operator Method ---\n    # Propagator for a half time-step in potential\n    V_propagator_half = np.exp(-0.5j * V_op * dt)\n    # Propagator for a full time-step in kinetic energy\n    T_propagator_full = np.exp(-1.0j * T_op_diag * dt)\n\n    # --- Projector onto the left well (x  0) ---\n    # For our grid x=np.linspace(-L, L, N, endpoint=False), the first N//2 points are  0.\n    proj_mask = np.zeros(N, dtype=float)\n    proj_mask[:N//2] = 1.0\n\n    # --- Main Loop over Test Cases ---\n    results = []\n    for tau in test_cases_tau:\n        # --- Initial State ---\n        # Unnormalized Gaussian wave packet\n        psi_0 = (np.pi * sigma**2)**(-0.25) * np.exp(-(x - x0)**2 / (2.0 * sigma**2))\n        psi_0 = psi_0.astype(np.complex128)\n        # Numerical normalization on the grid\n        norm = np.sqrt(np.sum(np.abs(psi_0)**2) * dx)\n        psi = psi_0 / norm\n\n        is_zeno_case = (tau  0.0)\n\n        if is_zeno_case:\n            survival_prob = 1.0\n            num_measurements = int(np.floor(T_total / tau))\n            steps_per_measurement = int(round(tau / dt))\n\n            for _ in range(num_measurements):\n                # Evolve for time tau\n                for _ in range(steps_per_measurement):\n                    # Split-operator step\n                    psi = V_propagator_half * psi         # Half potential step\n                    psi_k = np.fft.fft(psi)               # To momentum space\n                    psi_k = T_propagator_full * psi_k     # Full kinetic step\n                    psi = np.fft.ifft(psi_k)              # Back to position space\n                    psi = V_propagator_half * psi         # Final half potential step\n                \n                # --- Measurement and Projection ---\n                # Probability density in the left well\n                prob_density_left = np.abs(psi[proj_mask == 1.0])**2\n                p_k = np.sum(prob_density_left) * dx\n\n                # If probability is numerically zero, survival is impossible\n                if p_k  1e-15:\n                    survival_prob = 0.0\n                    break\n                \n                survival_prob *= p_k\n                \n                # Project and renormalize\n                psi = proj_mask * psi\n                psi /= np.sqrt(p_k)\n            \n            results.append(survival_prob)\n\n        else: # Baseline case (no measurements)\n            num_total_steps = int(round(T_total / dt))\n            for _ in range(num_total_steps):\n                # Split-operator step\n                psi = V_propagator_half * psi\n                psi_k = np.fft.fft(psi)\n                psi_k = T_propagator_full * psi_k\n                psi = np.fft.ifft(psi_k)\n                psi = V_propagator_half * psi\n            \n            # Calculate final left-well probability\n            prob_density_left = np.abs(psi[proj_mask == 1.0])**2\n            p_final = np.sum(prob_density_left) * dx\n            results.append(p_final)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}