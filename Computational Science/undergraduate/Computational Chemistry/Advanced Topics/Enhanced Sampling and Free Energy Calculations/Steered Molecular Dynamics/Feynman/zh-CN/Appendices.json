{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你通过一个简化的“玩具模型”，亲手模拟牵引分子动力学过程。你将探索拉伸速度 $v$ 如何影响测得的最大拉力，即“破裂力” $F_{\\max}$。通过这个实践，你会直观地理解为何在高速拉伸下，破裂力可能与分子的真实结合能失去关联，这对于正确设计和解读SMD实验至关重要 。",
            "id": "2463081",
            "problem": "单一集体坐标 $x(t)$ 描述了配体沿拉伸轴与受体分离的过程。配体受到一个内在的结合势 $U(x)$ 和一个随时间变化的外界约束，该约束来自一个谐振子弹簧，其锚点以恒定速度 $v$ 移动。在零温朗之万动力学的过阻尼极限（确定性极限）下，$x(t)$ 的演化由力平衡决定\n$$\n\\gamma \\,\\frac{dx}{dt} \\;=\\; -\\,\\frac{dU}{dx}(x) \\;-\\; k_s\\bigl(x - x_s(t)\\bigr),\n$$\n其中 $\\gamma$ 是摩擦系数，$k_s$ 是弹簧常数，$x_s(t) = v\\,t$ 是拉伸平台的位置。测得的力是弹簧力\n$$\nF_{\\text{spring}}(t) \\;=\\; k_s\\,\\bigl(x(t) - x_s(t)\\bigr),\n$$\n其大小 $\\lvert F_{\\text{spring}}(t)\\rvert$ 在拉伸过程中通常会显示一个峰值（“断裂力”）。\n\n您将使用深度为 $\\varepsilon$、范围参数为 $a$ 的莫尔斯势阱来模拟结合势，\n$$\nU(x) \\;=\\; \\varepsilon\\left[\\left(1 - e^{-a x}\\right)^2 - 1\\right],\n$$\n其在 $x = 0$ 处有最小值 $U(0) = -\\varepsilon$，且当 $x\\to +\\infty$ 时 $U(x)\\to 0$。根据此定义，结合态最小值与未结合态基线之间的平衡结合自由能差为 $\\Delta F = \\varepsilon$。\n\n从过阻尼力平衡和弹簧力的定义出发，推导一个适用于零温过阻尼状态下稳定时间步长的数值方案，并实现一个程序来完成以下任务。\n\n1) 使用以下物理上一致的参数和单位：\n- 长度单位为纳米（nm），时间单位为皮秒（ps），力单位为皮牛（pN），能量单位为 pN·nm。\n- 温度固定在 $0$ K（确定性极限）。\n- 摩擦系数 $\\gamma = 5000$ pN·ps/nm。\n- 弹簧常数 $k_s = 100$ pN/nm。\n- 莫尔斯范围参数 $a = 6$ nm$^{-1}$。\n- 结合深度 $\\varepsilon \\in \\{\\varepsilon_i\\}_{i=1}^{4}$，其值为 $\\varepsilon_1 = 10$ pN·nm, $\\varepsilon_2 = 20$ pN·nm, $\\varepsilon_3 = 30$ pN·nm, $\\varepsilon_4 = 40$ pN·nm。\n- 初始条件 $x(0) = 0$ nm 和 $x_s(0) = 0$ nm。\n- 时间步长 $\\Delta t = 0.001$ ps，总模拟时间 $T = 50$ ps。\n\n2) 对于每个深度 $\\varepsilon_i$，对运动方程进行积分以获得 $x(t)$，并计算轨迹上弹簧力的最大值，\n$$\nF_{\\max}(v;\\varepsilon_i) \\;=\\; \\max_{t\\in[0,T]} \\lvert F_{\\text{spring}}(t)\\rvert.\n$$\n\n3) 考虑包含三种拉伸速度 $v$ 的测试套件：\n- 一个准绝热情况 $v_1 = 0.01$ nm/ps（慢速），\n- 一个非平衡情况 $v_2 = 0.05$ nm/ps（中速），\n- 一个强非平衡情况 $v_3 = 0.50$ nm/ps（快速）。\n\n对于每个 $v_j$，评估平衡结合自由能列表 $\\bigl[\\Delta F_i\\bigr]_{i=1}^{4} = \\bigl[\\varepsilon_i\\bigr]_{i=1}^{4}$ 与相应的断裂力列表 $\\bigl[F_{\\max}(v_j;\\varepsilon_i)\\bigr]_{i=1}^{4}$ 之间的皮尔逊线性相关系数。\n\n4) 您的程序必须输出单行结果，其中包含 $v_1$、$v_2$ 和 $v_3$ 的三个相关系数（按此顺序），形式为用方括号括起来的逗号分隔列表。例如，打印的行应类似于“[c1,c2,c3]”，其中每个 $c_j$ 都是一个浮点数。不应有额外的空格或文本。\n\n科学真实性要求：\n- 将您的推导基于过阻尼极限下的牛顿力学和弹簧的胡克定律。莫尔斯势是描述具有单一最小值的短程结合的标准选择。所选参数与计算化学中使用的纳米–皮秒–皮牛单位系统一致。\n- 数值积分必须根据控制方程进行论证，并且在量纲上保持一致。\n- 将最终的相关系数表示为无量纲的浮点数。\n\n测试套件覆盖率要求：\n- 慢速情况 $v_1$ 作为“理想路径”，更接近可逆拉伸，其中 $\\lvert F_{\\max}\\rvert$ 应受 $\\Delta F$ 的影响。\n- 中速情况 $v_2$ 探索一个过渡区域。\n- 快速情况 $v_3$ 是一个边缘案例，旨在展示“断裂力伪影”，其中 $\\lvert F_{\\max}\\rvert$ 可能由粘性项主导，并失去与 $\\Delta F$ 的相关性。\n\n程序应生成单行输出，其中包含三个相关系数，格式为方括号括起来的逗号分隔列表。不使用角度。输出中不应出现百分比；相关系数是无单位的纯数。",
            "solution": "问题陈述已经过验证，被认为是科学上合理、提法恰当且完整的。它描述了在确定性、过阻尼极限下力探针分子动力学的典型模型。我们现在将推导数值解。\n\n该问题要求对一个集体坐标 $x(t)$ 的运动方程进行数值积分，该坐标受到内在势 $U(x)$ 和随时间变化的外部谐波约束的影响。控制方程由零温下过阻尼状态的力平衡给出：\n$$\n\\gamma \\frac{dx}{dt} = F_{\\text{intrinsic}}(x) + F_{\\text{external}}(x, t)\n$$\n其中 $\\gamma$ 是摩擦系数。力的分量包括：\n1.  源自莫尔斯势的内禀力，$F_{\\text{intrinsic}}(x) = -\\frac{dU}{dx}(x)$。\n2.  来自移动弹簧的外力，$F_{\\text{external}}(x, t) = -k_s(x - x_s(t))$。\n\n莫尔斯势由 $U(x) = \\varepsilon\\left[\\left(1 - e^{-a x}\\right)^2 - 1\\right]$ 给出。它对 $x$ 的导数是：\n$$\n\\frac{dU}{dx}(x) = \\varepsilon \\cdot 2(1 - e^{-ax}) \\cdot \\frac{d}{dx}(1 - e^{-ax}) = 2\\varepsilon(1 - e^{-ax})(a e^{-ax}) = 2a\\varepsilon(e^{-ax} - e^{-2ax})\n$$\n外部弹簧的锚点以恒定速度 $v$ 移动，因此其位置为 $x_s(t) = v t$。将这些表达式代入运动方程可得：\n$$\n\\gamma \\frac{dx}{dt} = -2a\\varepsilon(e^{-ax} - e^{-2ax}) - k_s(x - vt)\n$$\n为了便于数值积分，我们将这个一阶常微分方程重排为标准形式 $\\frac{dx}{dt} = f(x, t)$：\n$$\n\\frac{dx}{dt} = \\frac{1}{\\gamma} \\left[ -2a\\varepsilon(e^{-ax} - e^{-2ax}) - k_s(x - vt) \\right]\n$$\n我们将使用前向欧拉法求解此方程，这是一种简单而显式的时间步进方案。对于一个时间步长 $\\Delta t$，时间 $t + \\Delta t$ 处的位置可根据时间 $t$ 处的位置和速度近似得出：\n$$\nx(t + \\Delta t) \\approx x(t) + \\Delta t \\cdot \\frac{dx}{dt}\\bigg|_t\n$$\n令 $x_i = x(t_i)$，其中 $t_i = i\\Delta t$。更新规则为：\n$$\nx_{i+1} = x_i + \\frac{\\Delta t}{\\gamma} \\left[ -2a\\varepsilon(e^{-ax_i} - e^{-2ax_i}) - k_s(x_i - v t_i) \\right]\n$$\n此方案的稳定性取决于 $\\Delta t$ 相对于系统特征弛豫时间的大小。总势 $U_{\\text{tot}}(x, t) = U(x) + \\frac{1}{2}k_s(x-vt)^2$ 的有效刚度为 $k_{\\text{eff}} = \\frac{d^2 U}{dx^2} + k_s$。莫尔斯势的刚度 $\\frac{d^2 U}{dx^2} = 2a^2\\varepsilon(2e^{-2ax} - e^{-ax})$ 在 $x=0$ 处取得最大值，为 $k_{\\text{morse,max}} = 2a^2\\varepsilon$。对于 $\\varepsilon$ 的最大值 $40$ pN·nm 和 $a = 6$ nm$^{-1}$，该值为 $k_{\\text{morse,max}} = 2 \\cdot (6)^2 \\cdot 40 = 2880$ pN/nm。总刚度约为 $k_{\\text{eff,max}} \\approx 2880 + k_s = 2880 + 100 = 2980$ pN/nm。因此，系统中最快的弛豫时间为 $\\tau_{\\text{min}} = \\gamma / k_{\\text{eff,max}} \\approx 5000 / 2980 \\approx 1.68$ ps。指定的时间步长 $\\Delta t = 0.001$ ps 比这个最快的时间尺度小三个数量级以上（$\\Delta t \\ll \\tau_{\\text{min}}$）。因此，可以保证前向欧拉法对于此问题是稳定且准确的。\n\n模拟协议如下。对于每个拉伸速度 $v \\in \\{0.01, 0.05, 0.50\\}$ nm/ps，我们执行一系列模拟，每个结合能 $\\varepsilon \\in \\{10, 20, 30, 40\\}$ pN·nm 对应一次模拟。\n对于每个 $(v, \\varepsilon)$ 对：\n1.  在 $t=0$ 时初始化系统，设 $x(0)=0$。\n2.  从 $t=0$ 迭代到 $T=50$ ps，时间步长为 $\\Delta t = 0.001$ ps。在每个步骤 $i$ 中：\n    a. 计算当前时间 $t_i = i \\Delta t$。\n    b. 使用上面推导的欧拉公式将粒子位置从 $x_i$ 更新到 $x_{i+1}$。\n    c. 计算在新位置和时间的弹簧力：$F_{\\text{spring}}(t_{i+1}) = k_s(x_{i+1} - v t_{i+1})$。\n3.  生成轨迹后，确定弹簧力的最大值：$F_{\\max}(v; \\varepsilon) = \\max_{t \\in [0, T]} |F_{\\text{spring}}(t)|$。\n\n在获得给定速度 $v$ 下的断裂力列表 $[F_{\\max}(v; \\varepsilon_1), F_{\\max}(v; \\varepsilon_2), F_{\\max}(v; \\varepsilon_3), F_{\\max}(v; \\varepsilon_4)]$ 后，我们计算此列表与相应结合自由能列表 $[\\Delta F_i] = [\\varepsilon_i]$ 之间的皮尔逊线性相关系数 $\\rho$。具有 $N$ 个样本的两个变量 $X$ 和 $Y$ 之间的皮尔逊相关系数定义为：\n$$\n\\rho_{X,Y} = \\frac{\\sum_{i=1}^N (X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sqrt{\\sum_{i=1}^N (X_i - \\bar{X})^2} \\sqrt{\\sum_{i=1}^N (Y_i - \\bar{Y})^2}}\n$$\n其中 $\\bar{X}$ 和 $\\bar{Y}$ 是样本均值。对三种拉伸速度中的每一种重复此过程，得出三个相关系数。此完整过程的实现代码在下一节中提供。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the steered molecular dynamics problem to find the correlation\n    between binding energy and rupture force at different pulling speeds.\n    \"\"\"\n    \n    # 1) Define physically consistent parameters and units\n    # Length in nm, time in ps, force in pN, energy in pN·nm\n    gamma = 5000.0  # Friction coefficient (pN·ps/nm)\n    k_s = 100.0     # Spring constant (pN/nm)\n    a = 6.0         # Morse range parameter (nm⁻¹)\n    \n    # Binding depths epsilon (pN·nm)\n    epsilons = np.array([10.0, 20.0, 30.0, 40.0])\n    \n    # Time parameters\n    dt = 0.001      # Time step (ps)\n    T = 50.0        # Total simulation time (ps)\n    \n    # Initial conditions\n    x0 = 0.0        # Initial position (nm)\n    \n    # 3) Test suite of pulling speeds\n    velocities = [0.01, 0.05, 0.50]  # Pulling speeds (nm/ps)\n\n    # List to store the correlation coefficients\n    correlation_results = []\n    \n    # Calculate number of steps\n    num_steps = int(T / dt)\n    \n    # Main simulation loop\n    for v in velocities:\n        max_forces = []\n        \n        for epsilon in epsilons:\n            # Initialize arrays for position and time\n            x = np.zeros(num_steps + 1)\n            t = np.linspace(0, T, num_steps + 1)\n            \n            x[0] = x0\n            \n            # Array to store spring force magnitude\n            spring_force_magnitudes = np.zeros(num_steps + 1)\n            # Initial spring force is zero\n            spring_force_magnitudes[0] = 0.0\n            \n            # 2) Integrate the equation of motion\n            for i in range(num_steps):\n                # Force from Morse potential\n                force_morse = -2.0 * a * epsilon * (np.exp(-a * x[i]) - np.exp(-2.0 * a * x[i]))\n                \n                # Position of the spring anchor\n                x_s = v * t[i]\n                \n                # Force from the spring on the particle\n                force_spring_on_particle = -k_s * (x[i] - x_s)\n                \n                # Total force on the particle\n                total_force = force_morse + force_spring_on_particle\n                \n                # Update position using Forward Euler method\n                x[i+1] = x[i] + (total_force / gamma) * dt\n                \n                # Calculate the measured spring force F_spring(t) = k_s * (x(t) - x_s(t))\n                # Note: t[i+1] corresponds to the time for x[i+1]\n                x_s_next = v * t[i+1]\n                f_spring = k_s * (x[i+1] - x_s_next)\n                \n                # Store its magnitude\n                spring_force_magnitudes[i+1] = np.abs(f_spring)\n\n            # Find the maximum magnitude of the spring force (rupture force)\n            F_max = np.max(spring_force_magnitudes)\n            max_forces.append(F_max)\n        \n        # 3) Evaluate the Pearson linear correlation coefficient\n        # Note: binding free energy Delta_F is equal to epsilon\n        correlation_matrix = np.corrcoef(epsilons, max_forces)\n        correlation = correlation_matrix[0, 1]\n        correlation_results.append(correlation)\n        \n    # 4) Output the results in the specified format\n    # Example format: \"[c1,c2,c3]\"\n    print(f\"[{','.join(map(str, correlation_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在上一个练习的基础上，我们现在将模型升级为一个多珠子聚合物链，以更接近地模拟蛋白质的去折叠。这个练习引入了内部约束的概念，它可以强制系统沿着特定的、非天然的路径展开。你的任务是模拟这个受约束系统的动力学，并计算在整个拉伸过程中对系统所做的总功 $W$，从而掌握处理更复杂耦合系统的方法 。",
            "id": "2463127",
            "problem": "您的任务是使用引导分子动力学 (Steered Molecular Dynamics, SMD) 来模拟一个代表蛋白质结构域的一维粗粒化聚合物的解折叠过程。该系统由$N$个点状粒子（“珠子”）组成，它们沿$x$轴排列，相邻珠子之间通过谐振键连接。最左端的珠子固定在原点。一个谐振拉伸弹簧连接在最右端的珠子上，并由一个以恒定速度移动的外部指定锚点位置驱动。此外，在两个内部珠子之间施加了一个强的距离约束（作为谐振限制），以模拟由非天然疏水核心接触强制执行的非天然解折叠路径。\n\n总势能为\n$$\nU(x,t) \\;=\\; \\frac{k_{\\mathrm{b}}}{2}\\sum_{i=1}^{N-1}\\big(x_{i+1}-x_i-b_0\\big)^2 \\;+\\; \\frac{k_{\\mathrm{p}}}{2}\\big(x_N - R(t)\\big)^2 \\;+\\; \\frac{k_{\\mathrm{c}}}{2}\\big(x_{j_{\\mathrm{c}}} - x_{i_{\\mathrm{c}}} - d_0\\big)^2,\n$$\n其中，$x=(x_1,\\dots,x_N)$是珠子沿$x$轴的位置，$k_{\\mathrm{b}}$是键的弹簧常数，$b_0$是键的静息长度，$k_{\\mathrm{p}}$是拉伸弹簧的常数，$R(t)=R_0+vt$是锚点位置，其速度$v$为常数，初始位置为$R_0$，最后一项是索引为$i_{\\mathrm{c}}$和$j_{\\mathrm{c}}$的珠子之间的距离约束，其刚度为$k_{\\mathrm{c}}$，目标间距为$d_0$。最左端的珠子是固定的：对于所有$t$，$x_1(t)=0$。初始条件为：对于$i=1,\\dots,N$，$x_i(0)=(i-1)b_0$，以及$R_0=x_N(0)$。\n\n假设在零温度下为过阻尼确定性动力学，迁移率为$\\mu \\gt 0$：\n$$\n\\frac{dx_i}{dt} \\;=\\; -\\mu\\,\\frac{\\partial U}{\\partial x_i},\\quad \\text{for } i=2,\\dots,N,\\quad\\text{and}\\quad x_1(t)\\equiv 0.\n$$\n定义从时间$t=0$到$t=T$驱动拉伸锚点对系统所做的热力学功为\n$$\nW \\;=\\; \\int_{0}^{T} \\frac{\\partial U}{\\partial R}(x(t),t)\\,\\frac{dR}{dt}\\,dt\n\\;=\\; \\int_{0}^{T} \\Big(-k_{\\mathrm{p}}\\big(x_N(t)-R(t)\\big)\\Big)\\,v\\,dt,\n$$\n其结果必须以千焦耳/摩尔为单位报告。\n\n您的任务是为以下每一组参数计算$W$。所有长度单位必须是纳米，时间单位是皮秒，弹簧常数单位是千焦耳/摩尔/平方纳米，迁移率单位是平方纳米/千焦耳/摩尔/皮秒，功$W$必须以千焦耳/摩尔表示。使用给定的初始条件$x_i(0)=(i-1)b_0$和$R_0=x_N(0)$。\n\n所有测试用例都指定了统一的时间步长$\\Delta t$和总时间$T$。每个测试用例的答案必须是一个等于上述定义的$W$值的浮点数。您的程序必须按顺序将所有测试用例的结果汇总到一行输出中，格式为用方括号括起来的逗号分隔列表，不含空格。\n\n测试套件：\n- 情况 A（基线，无约束）：$N=8$, $k_{\\mathrm{b}}=2000$, $b_0=0.38$, $k_{\\mathrm{p}}=1000$, $v=0.005$, $T=50$, $\\Delta t=0.002$, $\\mu=0.02$, $k_{\\mathrm{c}}=0$, $i_{\\mathrm{c}}=3$, $j_{\\mathrm{c}}=6$, $d_0=0.30$。\n- 情况 B（非天然约束激活）：$N=8$, $k_{\\mathrm{b}}=2000$, $b_0=0.38$, $k_{\\mathrm{p}}=1000$, $v=0.005$, $T=50$, $\\Delta t=0.002$, $\\mu=0.02$, $k_{\\mathrm{c}}=8000$, $i_{\\mathrm{c}}=3$, $j_{\\mathrm{c}}=6$, $d_0=0.30$。\n- 情况 C（零拉伸速度边界）：$N=8$, $k_{\\mathrm{b}}=2000$, $b_0=0.38$, $k_{\\mathrm{p}}=1000$, $v=0$, $T=50$, $\\Delta t=0.002$, $\\mu=0.02$, $k_{\\mathrm{c}}=8000$, $i_{\\mathrm{c}}=3$, $j_{\\mathrm{c}}=6$, $d_0=0.30$。\n- 情况 D（链较短且核心约束紧密）：$N=4$, $k_{\\mathrm{b}}=2000$, $b_0=0.38$, $k_{\\mathrm{p}}=1000$, $v=0.010$, $T=50$, $\\Delta t=0.002$, $\\mu=0.02$, $k_{\\mathrm{c}}=8000$, $i_{\\mathrm{c}}=2$, $j_{\\mathrm{c}}=3$, $d_0=0.20$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中$r_k$是按上述顺序列出的第$k$个测试用例的$W$值。每个$r_k$都以千焦耳/摩尔表示。",
            "solution": "所提出的问题具有科学依据，定义明确且完整。它描述了一个在蛋白质生物物理学中使用粗粒化模型的标准计算实验。其物理基础是过阻尼动力学，目标是进行一个明确定义的数值计算。因此，该问题是有效的，并将提供解决方案。\n\n任务是计算在引导分子动力学 (SMD) 模拟过程中，对一维聚合物链所做的热力学功$W$。这涉及两个主要部分：首先，通过对运动方程进行数值积分来模拟珠子位置的时间演化；其次，对功$W$的积分进行数值评估。\n\n该系统由$N$个珠子组成，其位置为$x_1, \\dots, x_N$。珠子$x_1$固定在原点，$x_1(t)=0$。可移动珠子（$i=2, \\dots, N$）的动力学由零温度下的过阻尼运动方程控制：\n$$\n\\frac{dx_i}{dt} = -\\mu \\frac{\\partial U}{\\partial x_i}\n$$\n其中$\\mu$是迁移率，$U(x,t)$是系统的总势能：\n$$\nU(x,t) \\;=\\; \\underbrace{\\frac{k_{\\mathrm{b}}}{2}\\sum_{i=1}^{N-1}\\big(x_{i+1}-x_i-b_0\\big)^2}_{U_{\\mathrm{b}}(x)} \\;+\\; \\underbrace{\\frac{k_{\\mathrm{p}}}{2}\\big(x_N - R(t)\\big)^2}_{U_{\\mathrm{p}}(x,t)} \\;+\\; \\underbrace{\\frac{k_{\\mathrm{c}}}{2}\\big(x_{j_{\\mathrm{c}}} - x_{i_{\\mathrm{c}}} - d_0\\big)^2}_{U_{\\mathrm{c}}(x)}\n$$\n拉伸弹簧的锚点位置根据$R(t) = R_0 + vt$移动。\n\n首先，我们必须推导出力项$-\\frac{\\partial U}{\\partial x_i}$的显式表达式。这需要计算势能相对于每个可移动珠子$x_k$（其中$k \\in \\{2, \\dots, N\\}$）位置的偏导数。\n\n1.  **键势梯度 ($U_{\\mathrm{b}}$)**：该求和项涉及相邻珠子之间的键。对于一个珠子$x_k$（其中$k \\in \\{2, \\dots, N-1\\}$），它与$x_{k-1}$和$x_{k+1}$相连。\n    $$\n    \\frac{\\partial U_{\\mathrm{b}}}{\\partial x_k} = \\frac{\\partial}{\\partial x_k}\\left[ \\frac{k_{\\mathrm{b}}}{2}(x_k - x_{k-1} - b_0)^2 + \\frac{k_{\\mathrm{b}}}{2}(x_{k+1} - x_k - b_0)^2 \\right] = k_{\\mathrm{b}}(x_k - x_{k-1} - b_0) - k_{\\mathrm{b}}(x_{k+1} - x_k - b_0)\n    $$\n    对于最后一个珠子$x_N$，只有与$x_{N-1}$的键有贡献：\n    $$\n    \\frac{\\partial U_{\\mathrm{b}}}{\\partial x_N} = \\frac{\\partial}{\\partial x_N}\\left[ \\frac{k_{\\mathrm{b}}}{2}(x_N - x_{N-1} - b_0)^2 \\right] = k_{\\mathrm{b}}(x_N - x_{N-1} - b_0)\n    $$\n\n2.  **拉伸势梯度 ($U_{\\mathrm{p}}$)**：该势能仅取决于最后一个珠子$x_N$的位置。\n    $$\n    \\frac{\\partial U_{\\mathrm{p}}}{\\partial x_k} = \\begin{cases} k_{\\mathrm{p}}(x_N - R(t)) & \\text{if } k=N \\\\ 0 & \\text{if } k<N \\end{cases}\n    $$\n\n3.  **约束势梯度 ($U_{\\mathrm{c}}$)**：该势能涉及珠子$x_{i_{\\mathrm{c}}}$和$x_{j_{\\mathrm{c}}}$。只有当$k=i_{\\mathrm{c}}$或$k=j_{\\mathrm{c}}}$时，其贡献才非零。\n    $$\n    \\frac{\\partial U_{\\mathrm{c}}}{\\partial x_k} = \\begin{cases} -k_{\\mathrm{c}}(x_{j_{\\mathrm{c}}} - x_{i_{\\mathrm{c}}} - d_0) & \\text{if } k=i_{\\mathrm{c}} \\\\ k_{\\mathrm{c}}(x_{j_{\\mathrm{c}}} - x_{i_{\\mathrm{c}}} - d_0) & \\text{if } k=j_{\\mathrm{c}} \\\\ 0 & \\text{otherwise} \\end{cases}\n    $$\n    请注意，如果$k_{\\mathrm{c}}=0$，则此项完全消失。\n\n总梯度分量是各项之和：$\\frac{\\partial U}{\\partial x_k} = \\frac{\\partial U_{\\mathrm{b}}}{\\partial x_k} + \\frac{\\partial U_{\\mathrm{p}}}{\\partial x_k} + \\frac{\\partial U_{\\mathrm{c}}}{\\partial x_k}$。\n\n问题提供了一个固定的时间步长$\\Delta t$，这表明可以对常微分方程（ODEs）系统使用一个简单的数值积分方案。我们将使用前向欧拉法。对于从$t$到$t+\\Delta t$的时间步长，每个可移动珠子$x_k$的位置更新如下：\n$$\nx_k(t+\\Delta t) \\approx x_k(t) + \\Delta t \\cdot \\frac{dx_k}{dt}(t) = x_k(t) - \\mu \\Delta t \\frac{\\partial U}{\\partial x_k}(x(t), t)\n$$\n在每个时间步长，此更新规则被迭代地应用于$k=2, \\dots, N$。初始条件给定为：对于$i=1,\\dots,N$，$x_i(0)=(i-1)b_0$；以及$R_0 = x_N(0) = (N-1)b_0$。\n\n问题的第二部分是计算功$W$：\n$$\nW = \\int_{0}^{T} \\Big(-k_{\\mathrm{p}}\\big(x_N(t)-R(t)\\big)\\Big)\\,v\\,dt\n$$\n我们将使用梯形法则对该积分进行数值评估，该方法比简单的矩形法则提供更好的精度。给定在离散时间点$t_n = n \\Delta t$（其中$n \\in \\{0, 1, \\dots, M\\}$且$T=M\\Delta t$）的被积函数值$g(t_n)$，该积分近似为：\n$$\nW \\approx \\sum_{n=0}^{M-1} \\frac{g(t_n) + g(t_{n+1})}{2} \\Delta t = \\Delta t \\left( \\frac{g(t_0) + g(t_M)}{2} + \\sum_{n=1}^{M-1} g(t_n) \\right)\n$$\n被积函数$g(t_n)$所需的$x_N(t_n)$值是通过欧拉法模拟的轨迹获得的。\n\n总算法如下：\n1.  从具体的测试用例中初始化所有参数。\n2.  设置积分步数$M = \\text{int}(T/\\Delta t)$。\n3.  根据$x_i(0) = (i-1)b_0$初始化位置数组$x$。位置存储在一个一维数组中，索引从$0$到$N-1$。\n4.  初始化锚点位置$R_0 = x_{N-1}(0)$。\n5.  创建一个列表，用于存储从$t=0$到$t=T$每个时间步长的被积函数值。\n6.  开始主模拟循环，从步骤$n=0$迭代到$M$。\n    a. 计算当前时间$t = n \\Delta t$和锚点位置$R(t) = R_0 + vt$。\n    b. 使用当前的$x_N$位置评估被积函数$g(t) = -v k_{\\mathrm{p}}(x_N(t) - R(t))$，并将其添加到列表中。\n    c. 如果$n < M$，则继续计算下一个状态。否则，模拟结束。\n    d. 在当前状态$x(t)$下计算梯度向量$\\nabla U$。对于$k=2, \\dots, N$的分量$\\frac{\\partial U}{\\partial x_k}$使用上面推导的公式计算。\n    e. 使用前向欧拉法则更新可移动珠子（$x_2, \\dots, x_N$）的位置：$x_k \\leftarrow x_k - \\mu \\Delta t \\frac{\\partial U}{\\partial x_k}$。\n7.  循环完成后，使用存储的被积函数值列表，通过梯形法则计算总功$W$。\n8.  对所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n\n    def run_simulation(N, k_b, b_0, k_p, v, T, dt, mu, k_c, i_c, j_c, d_0):\n        \"\"\"\n        Runs a single Steered Molecular Dynamics simulation for a given set of parameters.\n\n        Args:\n            N (int): Number of beads.\n            k_b (float): Bond spring constant.\n            b_0 (float): Bond rest length.\n            k_p (float): Pulling spring constant.\n            v (float): Pulling speed.\n            T (float): Total simulation time.\n            dt (float): Time step for integration.\n            mu (float): Mobility.\n            k_c (float): Constraint spring constant.\n            i_c (int): Index of the first constrained bead (1-based).\n            j_c (int): Index of the second constrained bead (1-based).\n            d_0 (float): Target separation for the constraint.\n\n        Returns:\n            float: The calculated work W in kJ/mol.\n        \"\"\"\n        # Determine the number of steps for the simulation\n        num_steps = int(round(T / dt))\n\n        # Initial positions: x_i(0) = (i-1)*b_0, using 0-based indexing for array.\n        # x_pos[i] corresponds to bead i+1.\n        x_pos = np.arange(N, dtype=np.float64) * b_0\n\n        # Initial anchor position R_0 = x_N(0)\n        R0 = (N - 1) * b_0\n\n        # List to store integrand values for work calculation\n        integrand_values = []\n\n        # Simulation loop from t=0 to t=T\n        for n in range(num_steps + 1):\n            t = n * dt\n            \n            # Current anchor position\n            R_curr = R0 + v * t\n\n            # Calculate and store the integrand for work: -k_p * (x_N - R(t)) * v\n            # x_pos[N-1] is the position of the N-th bead.\n            integrand = -k_p * (x_pos[N - 1] - R_curr) * v\n            integrand_values.append(integrand)\n\n            # Do not update positions after the final time step\n            if n == num_steps:\n                break\n\n            # Calculate the gradient of the potential energy, dU/dx\n            gradU = np.zeros(N, dtype=np.float64)\n\n            # 1. Bond terms\n            for i in range(N - 1):\n                delta_x = x_pos[i + 1] - x_pos[i] - b_0\n                term = k_b * delta_x\n                gradU[i + 1] += term\n                gradU[i] -= term\n\n            # 2. Pulling term\n            gradU[N - 1] += k_p * (x_pos[N - 1] - R_curr)\n\n            # 3. Constraint term\n            if k_c > 0:\n                # Convert 1-based indices to 0-based\n                ic_idx, jc_idx = i_c - 1, j_c - 1\n                delta_c = x_pos[jc_idx] - x_pos[ic_idx] - d_0\n                term = k_c * delta_c\n                gradU[jc_idx] += term\n                gradU[ic_idx] -= term\n\n            # Update positions of movable beads (2 to N) using Forward Euler method\n            # In 0-based indexing, these are indices 1 to N-1. x_pos[0] is fixed at 0.\n            x_pos[1:] -= mu * gradU[1:] * dt\n\n        # Calculate work W using the trapezoidal rule for numerical integration\n        work = np.trapz(integrand_values, dx=dt)\n        \n        return work\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: baseline, no constraint\n        {'N': 8, 'k_b': 2000, 'b_0': 0.38, 'k_p': 1000, 'v': 0.005, 'T': 50, 'dt': 0.002, 'mu': 0.02, 'k_c': 0, 'i_c': 3, 'j_c': 6, 'd_0': 0.30},\n        # Case B: non-native constraint active\n        {'N': 8, 'k_b': 2000, 'b_0': 0.38, 'k_p': 1000, 'v': 0.005, 'T': 50, 'dt': 0.002, 'mu': 0.02, 'k_c': 8000, 'i_c': 3, 'j_c': 6, 'd_0': 0.30},\n        # Case C: zero pulling speed boundary\n        {'N': 8, 'k_b': 2000, 'b_0': 0.38, 'k_p': 1000, 'v': 0, 'T': 50, 'dt': 0.002, 'mu': 0.02, 'k_c': 8000, 'i_c': 3, 'j_c': 6, 'd_0': 0.30},\n        # Case D: shorter chain with tight core restraint\n        {'N': 4, 'k_b': 2000, 'b_0': 0.38, 'k_p': 1000, 'v': 0.010, 'T': 50, 'dt': 0.002, 'mu': 0.02, 'k_c': 8000, 'i_c': 2, 'j_c': 3, 'd_0': 0.20},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_simulation(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "牵引分子动力学模拟产生的是非平衡功 $W$，而非直接得到平衡态的自由能 $\\Delta G$。然而，这两者之间存在着深刻的联系。本练习将向你展示如何应用统计力学中的一个基石——Jarzynski恒等式，从一系列非平衡功的测量值中精确地计算出平衡自由能差，这是连接非平衡模拟与平衡热力学的关键一步 。",
            "id": "2455770",
            "problem": "给定一组定向分子动力学拉伸功值，用于估算蛋白质的可逆去折叠自由能变。假设这些测量值代表在绝对温度 $T$ 下，蛋白质去折叠过程中的每摩尔可逆功，其作为随机功（以 $W$ 表示）的独立实现。令可逆自由能差为 $\\Delta G$。对于每摩尔能量，连接非平衡功与平衡自由能的基本关系是由摩尔气体常数 $R$ 书写的 Jarzynski 等式：\n$$\ne^{-\\Delta G/(R\\,T)} \\;=\\; \\left\\langle e^{-W/(R\\,T)} \\right\\rangle,\n$$\n其中 $\\langle \\cdot \\rangle$ 表示对 $W$ 的所有实现的算术平均值。在此问题中，所有功值 $W$ 均以千焦每摩尔（$\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$）为单位，温度 $T$ 以开尔文（$\\mathrm{K}$）为单位。使用摩尔气体常数 $R = 8.31446261815324\\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n\n根据基本原理，使用上述定义计算每种情况下的 $\\Delta G$。将每个 $\\Delta G$ 以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位表示，并四舍五入到恰好六位小数。\n\n测试集（每一项是一个数对 $(T,\\{W_i\\})$）：\n- 情况 $1$：$T = 300\\,\\mathrm{K}$，$\\{W_i\\} = [\\,7.6,\\,8.1,\\,8.0,\\,7.9,\\,8.2,\\,7.8,\\,8.0,\\,8.1,\\,7.7,\\,8.0\\,]$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 情况 $2$：$T = 300\\,\\mathrm{K}$，$\\{W_i\\} = [\\,18.0,\\,15.5,\\,16.2,\\,17.1,\\,14.8,\\,19.3,\\,13.9,\\,21.0,\\,12.5,\\,20.2,\\,11.0,\\,22.5\\,]$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 情况 $3$：$T = 310\\,\\mathrm{K}$，$\\{W_i\\} = [\\,5.5\\,]$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 情况 $4$：$T = 150\\,\\mathrm{K}$，$\\{W_i\\} = [\\,2.0,\\,2.5,\\,3.0,\\,2.2,\\,2.8\\,]$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 情况 $5$：$T = 350\\,\\mathrm{K}$，$\\{W_i\\} = [\\,7.2,\\,7.2,\\,7.2,\\,7.2,\\,7.2,\\,7.2,\\,7.2,\\,7.2\\,]$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含上述五个情况的 $\\Delta G$ 值，每个值都格式化为恰好保留六位小数的小数（例如，“[1.234000,2.000000,3.141593,4.000000,5.500000]”）。",
            "solution": "所给问题是 Jarzynski 等式的一个标准应用，该等式是非平衡统计力学中的一个基本结果。该问题在科学上是合理的，提法明确，并包含了求解所需的所有信息。我将继续进行推导和求解。\n\n该问题要求从一组非平衡功测量值 $W$ 中计算出平衡自由能差 $\\Delta G$。其主导原理是 Jarzynski 等式：\n$$\ne^{-\\Delta G/(R\\,T)} = \\left\\langle e^{-W/(R\\,T)} \\right\\rangle\n$$\n此处，$T$ 是绝对温度，$R$ 是摩尔气体常数。项 $\\langle \\cdot \\rangle$ 表示对非平衡过程所有可能实现的理论系综平均。在实际应用中，如此问题所提供的，该系综平均通过对包含 $N$ 个独立功测量值 $\\{W_1, W_2, \\ldots, W_N\\}$ 的有限样本计算算术平均值来估算。因此，该等式的运算形式为：\n$$\ne^{-\\Delta G/(R\\,T)} \\approx \\frac{1}{N} \\sum_{i=1}^{N} e^{-W_i/(R\\,T)}\n$$\n为了求得 $\\Delta G$，我们必须解此方程。推导过程很简单。首先，我们对等式两边取自然对数：\n$$\n\\ln\\left(e^{-\\Delta G/(R\\,T)}\\right) = \\ln\\left( \\frac{1}{N} \\sum_{i=1}^{N} e^{-W_i/(R\\,T)} \\right)\n$$\n简化后得到：\n$$\n-\\frac{\\Delta G}{R\\,T} = \\ln\\left( \\frac{1}{N} \\sum_{i=1}^{N} e^{-W_i/(R\\,T)} \\right)\n$$\n最后，两边乘以 $-RT$ 以分离出 $\\Delta G$：\n$$\n\\Delta G = -R\\,T \\ln\\left( \\frac{1}{N} \\sum_{i=1}^{N} e^{-W_i/(R\\,T)} \\right)\n$$\n这就是计算自由能差的工作方程。\n\n值得注意的是 $\\Delta G$ 与平均功 $\\langle W \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} W_i$ 之间的关系。因为指数函数 $f(x) = e^x$ 是凸函数，根据 Jensen 不等式，有 $\\langle e^x \\rangle \\ge e^{\\langle x \\rangle}$。将此应用于我们的情景，令 $x = -W/(RT)$，我们得到 $\\left\\langle e^{-W/(RT)} \\right\\rangle \\ge e^{\\langle -W/(RT) \\rangle} = e^{-\\langle W \\rangle/(RT)}$。将此代入 Jarzynski 等式，得到 $e^{-\\Delta G/(RT)} \\ge e^{-\\langle W \\rangle/(RT)}$，这意味着 $\\Delta G \\le \\langle W \\rangle$。自由能变总是小于或等于所做的平均功。等式 $\\Delta G = \\langle W \\rangle$ 仅在可逆过程的极限情况下成立，此时所有功值 $W_i$ 均相同。在情况 3 和情况 5 中可以观察到这一点。在所有其他情况下，过程是耗散的，且 $\\Delta G \\lt \\langle W \\rangle$。\n\n每个测试用例的计算步骤如下：\n$1$. 给定温度 $T$ 和一组功值 $\\{W_i\\}$。摩尔气体常数的值固定为 $R = 8.31446261815324\\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n$2$. 计算热能乘积 $RT$。\n$3$. 对集合中的每个功值 $W_i$，计算项 $e^{-W_i/(R\\,T)}$。\n$4$. 计算这些指数项的算术平均值。\n$5$. 计算该平均值的自然对数。\n$6$. 将结果乘以 $-RT$ 以得到单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 的 $\\Delta G$。\n$7$. 最终数值必须按要求四舍五入到六位小数。\n\n现在将实施此程序，以求解所提供的五个情况中各自的 $\\Delta G$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the reversible free energy change Delta G using the Jarzynski equality\n    for a given set of test cases.\n    \"\"\"\n    # Define the molar gas constant in kJ/(mol*K) as specified.\n    R_GAS_CONSTANT = 8.31446261815324e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: T in K, list of W_i in kJ/mol\n        (300.0, [7.6, 8.1, 8.0, 7.9, 8.2, 7.8, 8.0, 8.1, 7.7, 8.0]),\n        # Case 2\n        (300.0, [18.0, 15.5, 16.2, 17.1, 14.8, 19.3, 13.9, 21.0, 12.5, 20.2, 11.0, 22.5]),\n        # Case 3\n        (310.0, [5.5]),\n        # Case 4\n        (150.0, [2.0, 2.5, 3.0, 2.2, 2.8]),\n        # Case 5\n        (350.0, [7.2, 7.2, 7.2, 7.2, 7.2, 7.2, 7.2, 7.2]),\n    ]\n\n    results = []\n    for T, W_values in test_cases:\n        # Convert work values to a NumPy array for vectorized operations.\n        W_array = np.array(W_values, dtype=np.float64)\n        \n        # Calculate the thermal energy product RT.\n        RT = R_GAS_CONSTANT * T\n        \n        # Jarzynski equality states: exp(-DeltaG / RT) = <exp(-W / RT)>\n        # We solve for DeltaG: DeltaG = -RT * ln(<exp(-W / RT)>)\n        \n        # Calculate the exponential terms exp(-W_i / RT) for each work value.\n        exp_terms = np.exp(-W_array / RT)\n        \n        # Calculate the arithmetic mean of the exponential terms.\n        mean_of_exponentials = np.mean(exp_terms)\n        \n        # Calculate Delta G.\n        delta_G = -RT * np.log(mean_of_exponentials)\n        \n        results.append(delta_G)\n\n    # Format the results to exactly six decimal places and create the final output string.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}