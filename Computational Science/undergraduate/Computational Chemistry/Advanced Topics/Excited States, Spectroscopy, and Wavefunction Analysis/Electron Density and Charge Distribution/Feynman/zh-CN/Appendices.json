{
    "hands_on_practices": [
        {
            "introduction": "在分子模拟中，准确地为原子分配部分电荷是理解和预测其化学行为的关键第一步。本实践将指导您使用电荷均衡（Charge Equilibration, QEq）模型——一种基于第一性原理的强大方法——来计算磷酸根离子在逐步质子化过程中的电荷分布。通过最小化一个包含原子电负性和化学硬度等基本化学概念的能量函数，您将亲手揭示电荷如何响应分子结构的变化，从而加深对电荷分布物理本质的理解。",
            "id": "2454820",
            "problem": "您将编写一个完整的程序，模拟一个磷酸盐物种从磷酸根 ($\\mathrm{PO_4^{3-}}$) 逐步质子化到磷酸 ($\\mathrm{H_3PO_4}$) 的过程中，其部分原子电荷和静电势 (ESP) 的变化。计算必须在一个最简单的、自洽的、基于物理的模型中进行。该模型通过最小化一个能量泛函，将电荷分布与静电学联系起来，该泛函根据原子特异性参数对电荷转移进行惩罚，并包含对库仑相互作用。所有计算都必须在原子单位下进行，其中基本电荷 $e = 1$，约化普朗克常数 $\\hbar = 1$，电子质量 $m_e = 1$，玻尔半径 $a_0 = 1$，库仑常数 $1 / (4 \\pi \\varepsilon_0) = 1$。在该单位制中，静电势以哈特里/基本电荷为单位。\n\n模型假设和定义如下。\n\n- 位置和几何构型：\n  - 将一个磷原子置于原点，位置为 $\\mathbf{R}_{\\mathrm{P}} = (0,0,0)$。\n  - 将四个氧原子放置在磷周围一个正四面体的顶点上，磷氧距离为 $d_{\\mathrm{PO}} = 2.90\\,a_0$。从磷指向氧的四个单位向量是\n    - $\\mathbf{u}_1 = \\frac{1}{\\sqrt{3}}(1,1,1)$，\n    - $\\mathbf{u}_2 = \\frac{1}{\\sqrt{3}}(1,-1,-1)$，\n    - $\\mathbf{u}_3 = \\frac{1}{\\sqrt{3}}(-1,1,-1)$，\n    - $\\mathbf{u}_4 = \\frac{1}{\\sqrt{3}}(-1,-1,1)$。\n    氧原子的位置是 $\\mathbf{R}_{\\mathrm{O}k} = d_{\\mathrm{PO}} \\,\\mathbf{u}_k$，其中 $k \\in \\{1,2,3,4\\}$。\n  - 质子（如果存在）沿着 $\\mathrm{P}\\!-\\!\\mathrm{O}$ 键的方向与氧结合，氧氢距离为 $d_{\\mathrm{OH}} = 1.84\\,a_0$。对于位于 $\\mathbf{R}_{\\mathrm{O}k}$、键方向为 $\\mathbf{u}_k$ 的氧原子，其氢原子位于 $\\mathbf{R}_{\\mathrm{H}k} = \\mathbf{R}_{\\mathrm{O}k} + d_{\\mathrm{OH}}\\,\\mathbf{u}_k$。\n\n- 逐步质子化状态和总净电荷 $Q_{\\text{tot}}$：\n  - 状态 $s = 0$：$\\mathrm{PO_4^{3-}}$，无氢原子；$Q_{\\text{tot}} = -3$。\n  - 状态 $s = 1$：$\\mathrm{HPO_4^{2-}}$，一个氢原子在 $\\mathrm{O}1$ 上；$Q_{\\text{tot}} = -2$。\n  - 状态 $s = 2$：$\\mathrm{H_2PO_4^{-}}$，氢原子在 $\\mathrm{O}1$ 和 $\\mathrm{O}2$ 上；$Q_{\\text{tot}} = -1$。\n  - 状态 $s = 3$：$\\mathrm{H_3PO_4}$，氢原子在 $\\mathrm{O}1$、$\\mathrm{O}2$ 和 $\\mathrm{O}3$ 上；$Q_{\\text{tot}} = 0$。\n\n- 电荷分布模型：\n  - 为每个原子 $i$（磷、氧和任何存在的氢）分配一个部分电荷 $q_i$。\n  - 总电荷受约束于 $\\sum_i q_i = Q_{\\text{tot}}$。\n  - 需要相对于 $\\{q_i\\}$ 最小化的能量泛函是\n    $$E(\\{q_i\\}) = \\sum_i \\left( \\chi_i \\, q_i + \\tfrac{1}{2}\\,\\eta_i\\, q_i^2 \\right) + \\tfrac{1}{2} \\sum_{i \\neq j} \\frac{q_i\\,q_j}{\\lVert \\mathbf{R}_i - \\mathbf{R}_j \\rVert},$$\n    其中 $\\chi_i$ 是元素特异性的类电负性参数（单位为哈特里），$\\eta_i$ 是元素特异性的硬度参数（单位为哈特里），距离单位为 $a_0$。\n  - 对每种元素使用以下参数：\n    - 磷 (P)：$\\chi_{\\mathrm{P}} = 0.202$，$\\eta_{\\mathrm{P}} = 0.50$。\n    - 氧 (O)：$\\chi_{\\mathrm{O}} = 0.273$，$\\eta_{\\mathrm{O}} = 0.80$。\n    - 氢 (H)：$\\chi_{\\mathrm{H}} = 0.265$，$\\eta_{\\mathrm{H}} = 1.10$。\n  - 某点 $\\mathbf{r}$ 处的静电势 (ESP) 定义为\n    $$V(\\mathbf{r}) = \\sum_i \\frac{q_i}{\\lVert \\mathbf{r} - \\mathbf{R}_i \\rVert}。$$\n\n您的任务是：\n- 对于每个质子化状态 $s \\in \\{0,1,2,3\\}$，构建相应的几何构型，在电荷约束下最小化 $E(\\{q_i\\})$ 以获得部分电荷 $\\{q_i\\}$，然后计算指定探针点的 ESP。\n\n为每个状态评估 $V(\\mathbf{r})$ 的探针点：\n- $\\mathbf{r}_{\\text{far}} = (0,0,100)\\,a_0$，\n- $\\mathbf{r}_{u_1} = 3.5\\,\\mathbf{u}_1\\,a_0$，\n- $\\mathbf{r}_{x} = (3.5,0,0)\\,a_0$。\n\n每个状态 $s$ 所需的输出：\n- 磷上的部分电荷 $q_{\\mathrm{P}}$，以基本电荷 $e$ 为单位。\n- 未质子化氧原子上的平均部分电荷（即，在该状态下没有连接氢原子的 $\\mathrm{O}k$ 的平均值）。对于状态 $s = 0$，这是所有四个氧原子的平均值；对于状态 $s = 3$，这仅指 $\\mathrm{O}4$。\n- ESP $V(\\mathbf{r}_{\\text{far}})$、 $V(\\mathbf{r}_{u_1})$ 和 $V(\\mathbf{r}_{x})$，以原子单位（哈特里每 $e$）计。\n\n所有量都必须以原子单位计算和表示。答案必须四舍五入到 $6$ 位小数。\n\n测试套件：\n- 程序必须为每个状态 $s \\in \\{0,1,2,3\\}$ 按以下顺序列出上述五个输出：\n  - 对于 $s = 0$（无氢原子，$Q_{\\text{tot}} = -3$）：$q_{\\mathrm{P}}$、在 $\\{\\mathrm{O}1,\\mathrm{O}2,\\mathrm{O}3,\\mathrm{O}4\\}$ 上的平均氧电荷、$V(\\mathbf{r}_{\\text{far}})$、$V(\\mathbf{r}_{u_1})$、$V(\\mathbf{r}_{x})$。\n  - 对于 $s = 1$（H 在 $\\mathrm{O}1$ 上，$Q_{\\text{tot}} = -2$）：$q_{\\mathrm{P}}$、在 $\\{\\mathrm{O}2,\\mathrm{O}3,\\mathrm{O}4\\}$ 上的平均氧电荷、$V(\\mathbf{r}_{\\text{far}})$、$V(\\mathbf{r}_{u_1})$、$V(\\mathbf{r}_{x})$。\n  - 对于 $s = 2$（H 在 $\\mathrm{O}1$ 和 $\\mathrm{O}2$ 上，$Q_{\\text{tot}} = -1$）：$q_{\\mathrm{P}}$、在 $\\{\\mathrm{O}3,\\mathrm{O}4\\}$ 上的平均氧电荷、$V(\\mathbf{r}_{\\text{far}})$、$V(\\mathbf{r}_{u_1})$、$V(\\mathbf{r}_{x})$。\n  - 对于 $s = 3$（H 在 $\\mathrm{O}1$、$\\mathrm{O}2$ 和 $\\mathrm{O}3$ 上，$Q_{\\text{tot}} = 0$）：$q_{\\mathrm{P}}$、在 $\\{\\mathrm{O}4\\}$ 上的平均氧电荷、$V(\\mathbf{r}_{\\text{far}})$、$V(\\mathbf{r}_{u_1})$、$V(\\mathbf{r}_{x})$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含所有 $20$ 个数字（每个状态五个），格式为逗号分隔的列表，并用方括号括起来，顺序与上述完全一致；例如，$[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{20}]$。",
            "solution": "问题陈述已经过严格评估，被认为是有效的。它是科学上合理的、适定的、客观的且自洽的，提出了一个基于电负性均衡成熟原理的可解的计算化学问题。因此，我们将着手提供一个完整的、逻辑清晰的解决方案。\n\n问题的核心是通过最小化一个特定的能量泛函 $E(\\{q_i\\})$ 来确定分子的平衡部分原子电荷 $\\{q_i\\}$，同时满足总电荷 $Q_{\\text{tot}}$ 的约束。这是一种被称为电荷均衡 (Charge Equilibration, QEq) 的方法中的标准途径。能量泛函给出如下：\n$$E(\\{q_i\\}) = \\sum_i \\left( \\chi_i \\, q_i + \\tfrac{1}{2}\\,\\eta_i\\, q_i^2 \\right) + \\tfrac{1}{2} \\sum_{i \\neq j} \\frac{q_i\\,q_j}{\\lVert \\mathbf{R}_i - \\mathbf{R}_j \\rVert}$$\n这里，$q_i$ 是位于位置 $\\mathbf{R}_i$ 上的原子 $i$ 的部分电荷。参数 $\\chi_i$ 和 $\\eta_i$ 分别是原子 $i$ 的电负性和化学硬度，它们量化了偏离中性电荷状态的能量代价。最后一项表示所有原子点电荷对之间的经典库仑势能。所有量均按规定以原子单位表示。\n\n$E(\\{q_i\\})$ 的最小化受到总电荷守恒的约束：\n$$ \\sum_i q_i = Q_{\\text{tot}} $$\n这个约束优化问题可以用拉格朗日乘数法巧妙地解决。我们定义一个拉格朗日函数 $\\mathcal{L}(\\{q_i\\}, \\lambda)$:\n$$ \\mathcal{L}(\\{q_i\\}, \\lambda) = E(\\{q_i\\}) - \\lambda \\left( \\sum_i q_i - Q_{\\text{tot}} \\right) $$\n其中 $\\lambda$ 是拉格朗日乘数。在最小值处，$\\mathcal{L}$ 对所有变量 $\\{q_i\\}$ 和 $\\lambda$ 的偏导数必须为零。对 $\\lambda$ 的导数只是恢复了约束方程。对特定电荷 $q_k$ 的导数是：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial q_k} = \\frac{\\partial E}{\\partial q_k} - \\lambda = 0 $$\n能量 $E$ 对 $q_k$ 的偏导数是原子 $k$ 在分子内的化学势，可以识别为其有效电负性：\n$$ \\frac{\\partial E}{\\partial q_k} = \\chi_k + \\eta_k q_k + \\sum_{j \\neq k} \\frac{q_j}{\\lVert \\mathbf{R}_k - \\mathbf{R}_j \\rVert} $$\n对所有原子 $k$ 将此式设为等于拉格朗日乘数 $\\lambda$，得出了电负性均衡原理：分子中每个原子的有效电负性都变得等于一个公共值 $\\lambda$。这为 $N$ 个原子提供了一个包含 $N$ 个线性方程的方程组：\n$$ \\chi_k + \\eta_k q_k + \\sum_{j \\neq k} \\frac{q_j}{R_{kj}} = \\lambda, \\quad \\text{for } k=1, \\dots, N $$\n其中 $R_{kj} = \\lVert \\mathbf{R}_k - \\mathbf{R}_j \\rVert$。\n\n这 $N$ 个方程，连同单个约束方程，构成了一个关于 $N+1$ 个未知数（即 $N$ 个电荷 $\\{q_k\\}$ 和乘数 $\\lambda$）的完整的 $N+1$ 元线性方程组。我们可以将此系统表示为矩阵形式：\n$$\n\\begin{pmatrix}\n\\eta_1  1/R_{12}  \\cdots  1/R_{1N}  -1 \\\\\n1/R_{21}  \\eta_2  \\cdots  1/R_{2N}  -1 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n1/R_{N1}  1/R_{N2}  \\cdots  \\eta_N  -1 \\\\\n1  1  \\cdots  1  0\n\\end{pmatrix}\n\\begin{pmatrix}\nq_1 \\\\\nq_2 \\\\\n\\vdots \\\\\nq_N \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\chi_1 \\\\\n-\\chi_2 \\\\\n\\vdots \\\\\n-\\chi_N \\\\\nQ_{\\text{tot}}\n\\end{pmatrix}\n$$\n这是一个标准线性系统 $M\\mathbf{x} = \\mathbf{b}$，可以很容易地进行数值求解。\n\n对每个指定的质子化状态 $s \\in \\{0, 1, 2, 3\\}$ 的计算流程如下：\n1.  **系统构建**：对于给定的状态 $s$，确定构成该分子的原子集合（$\\mathrm{PO_4^{3-}}$、$\\mathrm{HPO_4^{2-}}$、$\\mathrm{H_2PO_4^{-}}$ 或 $\\mathrm{H_3PO_4}$）。相应地确定原子总数 $N$ 和总电荷 $Q_{\\text{tot}}$。根据提供的四面体几何构型和键长 $d_{\\mathrm{PO}}=2.90\\,a_0$ 和 $d_{\\mathrm{OH}}=1.84\\,a_0$ 计算每个原子 $i$ 的笛卡尔坐标 $\\mathbf{R}_i$。为每个原子分配相应的参数 $\\chi_i$ 和 $\\eta_i$。\n\n2.  **矩阵构建**：构建 $(N+1) \\times (N+1)$ 矩阵 $M$ 和 $(N+1)$ 维向量 $\\mathbf{b}$。如上述矩阵方程所示，用硬度值 $\\eta_i$、原子间距离的倒数 $1/R_{ij}$ 和 1 填充 $M$ 的元素。用负电负性参数 $-\\chi_i$ 和总电荷 $Q_{\\text{tot}}$ 填充向量 $\\mathbf{b}$。\n\n3.  **求解电荷**：求解线性系统 $M\\mathbf{x} = \\mathbf{b}$ 以得到向量 $\\mathbf{x}$，其前 $N$ 个分量是平衡部分电荷 $\\{q_i\\}$。\n\n4.  **计算可观测量**：一旦知晓电荷 $\\{q_i\\}$，即可计算所需的输出：\n    *   磷原子上的部分电荷 $q_{\\mathrm{P}}$。\n    *   未与氢原子成键的氧原子的平均部分电荷。\n    *   在三个指定的探针点（$\\mathbf{r}_{\\text{far}}$、$\\mathbf{r}_{u_1}$、$\\mathbf{r}_{x}$）处的静电势 (ESP) $V(\\mathbf{r})$，使用其定义：\n        $$ V(\\mathbf{r}) = \\sum_i \\frac{q_i}{\\lVert \\mathbf{r} - \\mathbf{R}_i \\rVert} $$\n对四个质子化状态中的每一个重复此过程，以生成全部二十个所需的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding partial charges and ESP for the phosphate species\n    at different protonation states using a charge equilibration model.\n    \"\"\"\n\n    # --- Define constants and parameters in atomic units ---\n    D_PO = 2.90  # a_0\n    D_OH = 1.84  # a_0\n\n    PARAMS = {\n        'P': {'chi': 0.202, 'eta': 0.50},\n        'O': {'chi': 0.273, 'eta': 0.80},\n        'H': {'chi': 0.265, 'eta': 1.10},\n    }\n\n    # --- Define geometry ---\n    U = {\n        1: np.array([1, 1, 1]) / np.sqrt(3),\n        2: np.array([1, -1, -1]) / np.sqrt(3),\n        3: np.array([-1, 1, -1]) / np.sqrt(3),\n        4: np.array([-1, -1, 1]) / np.sqrt(3),\n    }\n\n    R_P = np.array([0.0, 0.0, 0.0])\n    R_O = {k: D_PO * u for k, u in U.items()}\n\n    # --- Define probe points ---\n    PROBE_POINTS = {\n        'far': np.array([0.0, 0.0, 100.0]),\n        'u1': 3.5 * U[1],\n        'x': np.array([3.5, 0.0, 0.0]),\n    }\n\n    all_results = []\n\n    # --- Loop over each protonation state s = 0, 1, 2, 3 ---\n    for s in range(4):\n        q_tot = -3.0 + s\n        \n        # 1. Construct atom list for the current state\n        atoms = []\n        # Phosphorus atom\n        atoms.append({'label': 'P', 'pos': R_P})\n        # Oxygen atoms\n        for k in range(1, 5):\n            atoms.append({'label': f'O{k}', 'pos': R_O[k]})\n        # Hydrogen atoms\n        for k in range(1, s + 1):\n            r_hk = R_O[k] + D_OH * U[k]\n            atoms.append({'label': f'H{k}', 'pos': r_hk})\n\n        num_atoms = len(atoms)\n\n        # 2. Build parameter vectors and distance matrix\n        chi_vec = np.array([PARAMS[atom['label'][0]]['chi'] for atom in atoms])\n        eta_vec = np.array([PARAMS[atom['label'][0]]['eta'] for atom in atoms])\n        \n        dist_matrix = np.zeros((num_atoms, num_atoms))\n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                dist = np.linalg.norm(atoms[i]['pos'] - atoms[j]['pos'])\n                dist_matrix[i, j] = dist\n                dist_matrix[j, i] = dist\n\n        # 3. Construct the linear system M*x = b\n        M = np.zeros((num_atoms + 1, num_atoms + 1))\n        b = np.zeros(num_atoms + 1)\n        \n        # Populate A matrix part (interaction matrix)\n        for i in range(num_atoms):\n            M[i, i] = eta_vec[i]\n            for j in range(num_atoms):\n                if i != j:\n                    M[i, j] = 1.0 / dist_matrix[i, j]\n\n        # Populate other parts of M\n        M[:num_atoms, num_atoms] = -1.0  # -1 column for lambda\n        M[num_atoms, :num_atoms] = 1.0   # 1 row for sum(q_i) constraint\n        \n        # Populate b vector\n        b[:num_atoms] = -chi_vec\n        b[num_atoms] = q_tot\n        \n        # 4. Solve for charges\n        solution = np.linalg.solve(M, b)\n        charges = solution[:num_atoms]\n        \n        atom_charges = {atoms[i]['label']: charges[i] for i in range(num_atoms)}\n\n        # 5. Calculate required outputs\n        \n        # q_P\n        q_p = atom_charges['P']\n\n        # Average charge of unprotonated oxygens\n        unprot_o_labels = [f'O{k}' for k in range(s + 1, 5)]\n        if not unprot_o_labels: # s=4 case not in this problem, but good practice\n            # for s=3, the unprotonated list is ['O4']\n            if s==3:\n                unprot_o_labels = ['O4']\n            else:\n                 avg_q_o = 0.0 # Or handle as error\n        \n        # Correctly handle unprotonated oxygens for all states\n        unprot_o_indices = []\n        if s == 0: unprot_o_indices = [1, 2, 3, 4] # O1, O2, O3, O4\n        if s == 1: unprot_o_indices = [2, 3, 4] # O2, O3, O4\n        if s == 2: unprot_o_indices = [3, 4] # O3, O4\n        if s == 3: unprot_o_indices = [4] # O4\n\n        unprot_o_charges = [atom_charges[f'O{k}'] for k in unprot_o_indices]\n        avg_q_o = np.mean(unprot_o_charges) if unprot_o_charges else 0.0\n        \n        # ESP at probe points\n        esp_values = []\n        positions = np.array([atom['pos'] for atom in atoms])\n        for probe_name in ['far', 'u1', 'x']:\n            probe_pos = PROBE_POINTS[probe_name]\n            # dists shape: (num_atoms,)\n            dists = np.linalg.norm(positions - probe_pos, axis=1)\n            # ESP calculation\n            esp = np.sum(charges / dists)\n            esp_values.append(esp)\n        v_far, v_u1, v_x = esp_values\n\n        all_results.extend([q_p, avg_q_o, v_far, v_u1, v_x])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in all_results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "化学键不仅仅是连接原子的线，它是在电子密度 $\\rho(\\mathbf{r})$ 这一物理可观测量中可以被精确定义的拓扑特征。本练习将带您进入量子化学中一个深刻的领域——分子中的原子理论（Quantum Theory of Atoms in Molecules, QTAIM），通过分析两个弱相互作用的氦原子间的电子密度，您将学习如何通过数学方法（计算梯度和Hessian矩阵）来定位和识别“键临界点”（Bond Critical Point）。这个实践将揭示化学键的物理本质，并展示如何从电子密度景观中解读出分子结构。",
            "id": "2454845",
            "problem": "您将对一个同核双原子氦范德华对的电子密度及其拓扑结构进行建模。两个氦原子相距为 $R$（原子单位，即玻尔）。在玻恩-奥本海默近似下，使用有效核电荷为 $Z_{\\mathrm{eff}}$ 的类氢1s轨道来近似每个氦原子，并采用前分子近似，其中总电子密度 $\\rho(\\mathbf{r})$ 是以两个固定原子核为中心的球形原子密度之和。使用标准类氢1s轨道 $\\psi_{1s}^{Z}(\\mathbf{r})$ 和针对双电子氦1s壳层的定义 $\\rho(\\mathbf{r}) = 2 \\lvert \\psi_{1s}^{Z}(\\mathbf{r}) \\rvert^2$。将原子核置于$x$轴上的 $\\mathbf{R}_A = (-R/2, 0, 0)$ 和 $\\mathbf{R}_B = (R/2, 0, 0)$ 位置，使得中点位于 $\\mathbf{r}_m = (0,0,0)$。所有计算完全采用原子单位，其中玻尔半径 $a_0 = 1$。\n\n根据分子中原子量子理论（QTAIM），键临界点是指满足梯度 $\\nabla \\rho(\\mathbf{r}_c) = \\mathbf{0}$ 且二阶导数的Hessian矩阵 $H(\\mathbf{r}_c)$ 恰好有两个负特征值和一个正特征值（一个 $(3,-1)$ 临界点）的点 $\\mathbf{r}_c$。拉普拉斯量为 $\\nabla^2 \\rho(\\mathbf{r}) = \\mathrm{tr}\\, H(\\mathbf{r})$。\n\n您的任务是编写一个完整的程序，针对下方的每个测试用例，使用第一性原理和核心定义完成以下所有操作：\n\n- 使用有效电荷为 $Z_{\\mathrm{eff}}$ 的类氢1s形式，为两个氦原子构建前分子电子密度 $\\rho(\\mathbf{r})$。\n- 利用对称性和严格的微积分定义，通过计算 $\\nabla \\rho(\\mathbf{r}_m)$ 并检查其是否在严格的数值容差内为零，来评估中点 $\\mathbf{r}_m$ 是否为临界点。\n- 计算Hessian矩阵 $H(\\mathbf{r}_m)$ 及其特征值，并通过验证恰好有两个负特征值和一个正特征值，来确定该中点是否为键临界点。\n- 报告电子密度 $\\rho(\\mathbf{r}_m)$（单位 $\\mathrm{bohr}^{-3}$）、拉普拉斯量 $\\nabla^2 \\rho(\\mathbf{r}_m)$（单位 $\\mathrm{bohr}^{-5}$）、一个指示中点是否为键临界点的布尔值，以及一个符号整数 $s$。$s$ 定义为三个特征值符号的总和，其约定为：对于一个小的正容差 $\\tau$，如果 $x > \\tau$，则 $\\mathrm{sign}(x) = +1$；如果 $x  -\\tau$，则 $\\mathrm{sign}(x) = -1$；否则 $\\mathrm{sign}(x) = 0$。\n\n您的推理和代码中所有的数学符号和数字都应与上述定义保持一致。计算不涉及角度。所有长度以玻尔（bohr）表示，电子密度以 $\\mathrm{bohr}^{-3}$ 表示，拉普拉斯量以 $\\mathrm{bohr}^{-5}$ 表示。\n\n测试套件。对于下方的每对 $(Z_{\\mathrm{eff}}, R)$，请按要求计算中点 $\\mathbf{r}_m$ 处的值：\n\n- 情况1：$Z_{\\mathrm{eff}} = 1.6875$, $R = 3.0$。\n- 情况2：$Z_{\\mathrm{eff}} = 1.6875$, $R = 1.0$。\n- 情况3：$Z_{\\mathrm{eff}} = 1.0$, $R = 2.1$。\n- 情况4：$Z_{\\mathrm{eff}} = 2.0$, $R = 0.9$。\n- 情况5：$Z_{\\mathrm{eff}} = 1.6875$, $R = 20.0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含五个测试用例的结果。结果是一个用方括号括起来的逗号分隔列表，每个用例的结果本身是一个包含四项的列表，顺序为 $[\\rho(\\mathbf{r}_m), \\nabla^2 \\rho(\\mathbf{r}_m), \\text{is\\_BCP}, s]$。对于数值，请使用科学记数法打印，并保留六位有效数字。例如，一个有效的最终输出行可能如下所示：\n\"[[1.234000e-02,5.678000e-04,True,-1],[...],[...],[...],[...]]\"。",
            "solution": "所呈现的问题陈述是一项在计算化学领域，特别是在分子中原子量子理论（QTAIM）框架下的一个提法恰当且具有科学依据的练习。它要求对一个简单模型系统的电子密度拓扑结构进行分析。该问题是自洽的，其前提在事实上是可靠的，并且没有会妨碍得出唯一解的歧义。因此，我将进行严格的推导和求解。\n\n该问题要求分析相距为 $R$ 的两个氦原子的前分子电子密度 $\\rho(\\mathbf{r})$。原子核位于原子单位下的 $\\mathbf{R}_A = (-R/2, 0, 0)$ 和 $\\mathbf{R}_B = (R/2, 0, 0)$。总密度是各个原子密度的叠加：\n$$\n\\rho(\\mathbf{r}) = \\rho_A(\\mathbf{r}) + \\rho_B(\\mathbf{r})\n$$\n每个氦原子由一个有效核电荷为 $Z_{\\mathrm{eff}}$（我们将其表示为 $Z$）的类氢1s轨道建模。以原点为中心的归一化类氢1s轨道为：\n$$\n\\psi_{1s}^{Z}(\\mathbf{r}) = \\frac{Z^{3/2}}{\\sqrt{\\pi}} e^{-Z|\\mathbf{r}|}\n$$\n因此，对于一个在1s壳层中有两个电子的单个氦原子，其电子密度为：\n$$\n\\rho_{\\text{atom}}(\\mathbf{r}) = 2 |\\psi_{1s}^{Z}(\\mathbf{r})|^2 = 2 \\left( \\frac{Z^{3/2}}{\\sqrt{\\pi}} e^{-Z|\\mathbf{r}|} \\right)^2 = \\frac{2Z^3}{\\pi} e^{-2Z|\\mathbf{r}|}\n$$\n对于我们系统中的两个原子，从一点 $\\mathbf{r}=(x,y,z)$ 到原子核的距离分别为 $r_A = |\\mathbf{r} - \\mathbf{R}_A|$ 和 $r_B = |\\mathbf{r} - \\mathbf{R}_B|$。总前分子密度为：\n$$\n\\rho(\\mathbf{r}) = \\frac{2Z^3}{\\pi} \\left( e^{-2Zr_A} + e^{-2Zr_B} \\right)\n$$\n我们的任务是分析原子核连线中点 $\\mathbf{r}_m = (0,0,0)$ 处该密度的性质。\n\n步骤1：中点处的电子密度 $\\rho(\\mathbf{r}_m)$\n在中点 $\\mathbf{r}_m=(0,0,0)$ 处，到两个原子核的距离相等：\n$$\nr_A(\\mathbf{r}_m) = |\\mathbf{r}_m - \\mathbf{R}_A| = |(0,0,0) - (-R/2, 0, 0)| = R/2\n$$\n$$\nr_B(\\mathbf{r}_m) = |\\mathbf{r}_m - \\mathbf{R}_B| = |(0,0,0) - (R/2, 0, 0)| = R/2\n$$\n将这些距离代入密度表达式中：\n$$\n\\rho(\\mathbf{r}_m) = \\frac{2Z^3}{\\pi} \\left( e^{-2Z(R/2)} + e^{-2Z(R/2)} \\right) = \\frac{2Z^3}{\\pi} \\left( 2 e^{-ZR} \\right)\n$$\n$$\n\\rho(\\mathbf{r}_m) = \\frac{4Z^3}{\\pi} e^{-ZR}\n$$\n单位为 $\\mathrm{bohr}^{-3}$，符合要求。\n\n步骤2：中点处的密度梯度 $\\nabla \\rho(\\mathbf{r}_m)$\n临界点 $\\mathbf{r}_c$ 由条件 $\\nabla \\rho(\\mathbf{r}_c) = \\mathbf{0}$ 定义。我们必须计算 $\\rho(\\mathbf{r})$ 的梯度，并在 $\\mathbf{r}_m$ 处对其求值。\n令 $C = 2Z^3 / \\pi$。梯度为：\n$$\n\\nabla \\rho(\\mathbf{r}) = C \\nabla \\left( e^{-2Zr_A} + e^{-2Zr_B} \\right) = -2ZC \\left( e^{-2Zr_A} \\nabla r_A + e^{-2Zr_B} \\nabla r_B \\right)\n$$\n使用 $\\nabla r_A = \\frac{\\mathbf{r} - \\mathbf{R}_A}{r_A}$ 和 $\\nabla r_B = \\frac{\\mathbf{r} - \\mathbf{R}_B}{r_B}$：\n$$\n\\nabla \\rho(\\mathbf{r}) = -2ZC \\left( e^{-2Zr_A} \\frac{\\mathbf{r} - \\mathbf{R}_A}{r_A} + e^{-2Zr_B} \\frac{\\mathbf{r} - \\mathbf{R}_B}{r_B} \\right)\n$$\n在中点 $\\mathbf{r}_m = (0,0,0)$ 处，我们有 $r_A = r_B = R/2$。同时，$\\mathbf{r}_m - \\mathbf{R}_A = (R/2, 0, 0)$ 且 $\\mathbf{r}_m - \\mathbf{R}_B = (-R/2, 0, 0)$。\n$$\n\\nabla \\rho(\\mathbf{r}_m) = -2ZC e^{-ZR} \\left( \\frac{(R/2, 0, 0)}{R/2} + \\frac{(-R/2, 0, 0)}{R/2} \\right)\n$$\n$$\n\\nabla \\rho(\\mathbf{r}_m) = -2ZC e^{-ZR} \\left( (1,0,0) + (-1,0,0) \\right) = -2ZC e^{-ZR} (0,0,0) = \\mathbf{0}\n$$\n由于系统的对称性，梯度在中点处解析上为零。因此，对于任何 $Z0$ 和 $R0$，$\\mathbf{r}_m$ 都是一个临界点。\n\n步骤3：Hessian矩阵、特征值和BCP分类\n为了对临界点进行分类，我们必须计算Hessian矩阵 $H_{ij}(\\mathbf{r}_m) = \\frac{\\partial^2 \\rho}{\\partial x_i \\partial x_j}|_{\\mathbf{r}_m}$ 并求出其特征值。Hessian矩阵是可加的：$H(\\rho) = H(\\rho_A) + H(\\rho_B)$。\n对于单个球对称密度贡献 $f(r) = \\frac{2Z^3}{\\pi}e^{-2Zr}$，在相对于其中心的点 $\\mathbf{v}$ 处的Hessian矩阵元素由下式给出：\n$$\nH_{ij}(f) = \\left(\\frac{f'' - f'/r}{r^2}\\right) v_i v_j + \\frac{f'}{r} \\delta_{ij}\n$$\n其中 $f'(r) = -2Z f(r)$ 且 $f''(r) = 4Z^2 f(r)$。\n对于原子A，求值点为 $\\mathbf{v}_A = \\mathbf{r}_m - \\mathbf{R}_A = (R/2, 0, 0)$，因此 $r_A = R/2$。由于沿 $x$ 轴排列，原子A在 $\\mathbf{r}_m$ 处的Hessian矩阵将是对角的。纵向曲率（沿 $x$ 轴）是 $f''(r_A)$，两个横向曲率（沿 $y, z$ 轴）是 $f'(r_A)/r_A$。\n$$\n\\frac{\\partial^2 \\rho_A}{\\partial x^2}\\bigg|_{\\mathbf{r}_m} = f''(R/2) = 4Z^2 \\left( \\frac{2Z^3}{\\pi} e^{-ZR} \\right) = \\frac{8Z^5}{\\pi} e^{-ZR}\n$$\n$$\n\\frac{\\partial^2 \\rho_A}{\\partial y^2}\\bigg|_{\\mathbf{r}_m} = \\frac{\\partial^2 \\rho_A}{\\partial z^2}\\bigg|_{\\mathbf{r}_m} = \\frac{f'(R/2)}{R/2} = \\frac{-2Z f(R/2)}{R/2} = - \\frac{4Z}{R} \\left( \\frac{2Z^3}{\\pi} e^{-ZR} \\right) = - \\frac{8Z^4}{\\pi R} e^{-ZR}\n$$\n根据对称性，原子B在 $\\mathbf{r}_m$ 处的Hessian矩阵是相同的。总Hessian矩阵 $H(\\mathbf{r}_m)$ 是单个原子Hessian矩阵的两倍：\n$$\nH(\\mathbf{r}_m) = H(\\rho_A)|_{\\mathbf{r}_m} + H(\\rho_B)|_{\\mathbf{r}_m} = 2 H(\\rho_A)|_{\\mathbf{r}_m}\n$$\n特征值即为对角元素：\n$$\n\\lambda_1 = \\frac{\\partial^2 \\rho}{\\partial x^2}\\bigg|_{\\mathbf{r}_m} = 2 \\frac{\\partial^2 \\rho_A}{\\partial x^2}\\bigg|_{\\mathbf{r}_m} = \\frac{16Z^5}{\\pi} e^{-ZR}\n$$\n$$\n\\lambda_2 = \\frac{\\partial^2 \\rho}{\\partial y^2}\\bigg|_{\\mathbf{r}_m} = 2 \\frac{\\partial^2 \\rho_A}{\\partial y^2}\\bigg|_{\\mathbf{r}_m} = -\\frac{16Z^4}{\\pi R} e^{-ZR}\n$$\n$$\n\\lambda_3 = \\frac{\\partial^2 \\rho}{\\partial z^2}\\bigg|_{\\mathbf{r}_m} = \\lambda_2\n$$\n对于任何正的 $Z$ 和 $R$，都有 $\\lambda_1  0$ 且 $\\lambda_2 = \\lambda_3  0$。Hessian矩阵有一个正特征值和两个负特征值。这对应于一个 $(3, -1)$ 临界点，根据定义，它是一个键临界点（BCP）。因此，对于所有测试用例，中点都是一个BCP。变量 `is_BCP` 始终为 `True`。\n\n符号整数 $s$ 是特征值符号的总和。使用一个小的正容差 $\\tau  0$，我们有 $\\mathrm{sign}(\\lambda_1)=+1$ 和 $\\mathrm{sign}(\\lambda_2)=\\mathrm{sign}(\\lambda_3)=-1$。\n$$\ns = (+1) + (-1) + (-1) = -1\n$$\n对于所有测试用例，这都是一个常数。\n\n步骤4：密度的拉普拉斯量 $\\nabla^2 \\rho(\\mathbf{r}_m)$\n拉普拉斯量是Hessian矩阵的迹，$\\nabla^2 \\rho(\\mathbf{r}_m) = \\mathrm{tr}(H(\\mathbf{r}_m)) = \\lambda_1 + \\lambda_2 + \\lambda_3$。\n$$\n\\nabla^2 \\rho(\\mathbf{r}_m) = \\frac{16Z^5}{\\pi} e^{-ZR} - \\frac{16Z^4}{\\pi R} e^{-ZR} - \\frac{16Z^4}{\\pi R} e^{-ZR}\n$$\n$$\n\\nabla^2 \\rho(\\mathbf{r}_m) = \\frac{16Z^4}{\\pi} e^{-ZR} \\left( Z - \\frac{2}{R} \\right)\n$$\n单位为 $\\mathrm{bohr}^{-5}$，符合要求。\n\n用于实现的公式总结：\n- 电子密度：$\\rho(\\mathbf{r}_m) = \\frac{4Z^3}{\\pi} e^{-ZR}$\n- 拉普拉斯量：$\\nabla^2 \\rho(\\mathbf{r}_m) = \\frac{16Z^4}{\\pi} e^{-ZR} \\left( Z - \\frac{2}{R} \\right)$\n- BCP状态：始终为 `True`。\n- 符号整数 $s$：始终为 $-1$。\n\n这些公式将被用于计算每个测试用例所需的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes electron density properties at the midpoint between two helium atoms.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (Z_eff, R).\n    test_cases = [\n        (1.6875, 3.0),\n        (1.6875, 1.0),\n        (1.0, 2.1),\n        (2.0, 0.9),\n        (1.6875, 20.0),\n    ]\n\n    results = []\n    for Z_eff, R in test_cases:\n        # Based on the analytical derivation presented in the solution, for the\n        # promolecular model of two 1s orbitals, the midpoint is always a\n        # Bond Critical Point (BCP). This is because the Hessian matrix has\n        # one positive and two negative eigenvalues for any Z_eff  0 and R  0.\n        # The eigenvalues are:\n        # lambda_1 = (16 * Z_eff^5 / pi) * exp(-Z_eff * R)  0\n        # lambda_2 = lambda_3 = -(16 * Z_eff^4 / (pi * R)) * exp(-Z_eff * R)  0\n        #\n        # Therefore, 'is_BCP' is always True.\n        # The signature integer s is the sum of the signs of the eigenvalues:\n        # s = sign(lambda_1) + sign(lambda_2) + sign(lambda_3) = 1 + (-1) + (-1) = -1.\n        is_bcp = True\n        s = -1\n\n        # Calculate the electron density rho at the midpoint r_m.\n        # Formula: rho(r_m) = (4 * Z_eff^3 / pi) * exp(-Z_eff * R)\n        rho_midpoint = (4 * Z_eff**3 / np.pi) * np.exp(-Z_eff * R)\n\n        # Calculate the Laplacian of the electron density at the midpoint.\n        # Formula: laplacian(r_m) = (16 * Z_eff^4 / pi) * exp(-Z_eff * R) * (Z_eff - 2/R)\n        laplacian_midpoint = (16 * Z_eff**4 / np.pi) * np.exp(-Z_eff * R) * (Z_eff - 2.0 / R)\n\n        # Format the results for the current test case.\n        # The format string {:.6e} provides scientific notation with 1 digit\n        # before the decimal point and 6 digits after, as shown in the problem's example output.\n        case_result = (\n            f\"[{rho_midpoint:.6e},\"\n            f\"{laplacian_midpoint:.6e},\"\n            f\"{is_bcp},\"\n            f\"{s}]\"\n        )\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The output is a single line: a list of lists.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "共价键和离子键是化学中描述成键的两个基本模型，但许多化学键的性质介于两者之间。本实践将通过一个经典的双态量子力学模型，模拟锂（Li）和氟（F）原子在不同距离下共价态和离子态之间的相互作用。您将通过求解一个 $2 \\times 2$ 的哈密顿矩阵来计算体系的基态，并量化其“离子特性”，最终确定从共价键主导到离子键主导转变的临界距离。这项练习将抽象的量子力学概念（如绝热态、非绝热态和避免交叉）与化学键本质这一基本化学问题直接联系起来。",
            "id": "2454877",
            "problem": "考虑一个由锂原子和氟原子组成的双原子体系，该体系使用一个包含共价性和离子性的双态透热表象进行建模。设透热共价态表示为 $\\lvert \\mathrm{cov} \\rangle$，透热离子态表示为 $\\lvert \\mathrm{ion} \\rangle$。在分离距离为 $R$（单位为 $\\text{\\AA}$）时，基矢为 $\\{\\lvert \\mathrm{cov} \\rangle,\\lvert \\mathrm{ion} \\rangle\\}$ 的透热哈密顿量为\n$$\nH(R) \\;=\\; \\begin{pmatrix}\nE_{\\mathrm{cov}}(R)  V(R) \\\\\nV(R)  E_{\\mathrm{ion}}(R)\n\\end{pmatrix},\n$$\n其中 $E_{\\mathrm{cov}}(R)$ 取为参考零点，$E_{\\mathrm{ion}}(R)$ 定义为\n$$\nE_{\\mathrm{ion}}(R) \\;=\\; \\Delta_{\\infty} \\;-\\; \\dfrac{k_e}{\\varepsilon_r\\, R}.\n$$\n此处，$\\Delta_{\\infty}$（单位为 $\\mathrm{eV}$）是无穷远分离时离子和共价透热态之间的渐近能量差，$\\varepsilon_r$ 是相对介电常数（无量纲），$k_e$ 是用混合单位表示的库仑常数，\n$$\nk_e \\;=\\; 14.3996454784255\\,\\mathrm{eV}\\cdot\\text{\\AA}.\n$$\n透热耦合建模为\n$$\nV(R) \\;=\\; V_0 \\,\\exp\\!\\big(-\\alpha\\,(R - R_0)\\big),\n$$\n$V_0$ 的单位为 $\\mathrm{eV}$，$\\alpha$ 的单位为 $\\text{\\AA}^{-1}$，$R_0$ 的单位为 $\\text{\\AA}$。\n\n定义在距离 $R$ 处的离子性为 $\\lvert \\mathrm{ion} \\rangle$ 在 $H(R)$ 的归一化基态（最低能量）绝热本征态中的概率权重。设该量表示为 $p_{\\mathrm{ion}}(R)$，其为无量纲。定义转换距离 $R^\\ast$ 为使 $p_{\\mathrm{ion}}(R) = 0.5$ 成立的最小正值 $R$（单位为 $\\text{\\AA}$）。\n\n使用以上定义，编写一个程序，为下面测试套件中的每组参数计算 $p_{\\mathrm{ion}}(R)$ 和 $R^\\ast$。所有能量必须以 $\\mathrm{eV}$ 为单位处理，所有距离必须以 $\\text{\\AA}$ 为单位处理。您的程序必须在最终输出中将 $p_{\\mathrm{ion}}(R)$ 和 $R^\\ast$ 四舍五入到六位小数。\n\n测试套件（每个项目是一个元组 $(\\varepsilon_r,\\Delta_{\\infty},V_0,\\alpha,R_0,R)$，其中 $\\varepsilon_r$ 无量纲，$\\Delta_{\\infty}$ 和 $V_0$ 的单位为 $\\mathrm{eV}$，$\\alpha$ 的单位为 $\\text{\\AA}^{-1}$，$R_0$ 和 $R$ 的单位为 $\\text{\\AA}$）：\n- $\\big(1.0,\\,1.99,\\,2.0,\\,1.2,\\,2.0,\\,3.0\\big)$\n- $\\big(1.0,\\,1.99,\\,2.0,\\,1.2,\\,2.0,\\,1.5\\big)$\n- $\\big(1.0,\\,1.99,\\,2.0,\\,1.2,\\,2.0,\\,20.0\\big)$\n- $\\big(10.0,\\,1.99,\\,2.0,\\,1.2,\\,2.0,\\,3.0\\big)$\n\n最终输出格式：您的程序应生成单行结果，形式为方括号内以逗号分隔的列表，对于每个测试用例 $i$（从第一个到最后一个），其顺序为：$p_{\\mathrm{ion}}(R_i)$（无量纲，四舍五入到六位小数），后跟 $R^\\ast_i$（单位为 $\\text{\\AA}$，四舍五入到六位小数）。因此，最终输出总共包含8个数字，例如 $\\big[\\dots\\big]$。",
            "solution": "问题陈述经过验证，被认为是科学上合理、良态且自洽的。它提出了一个物理化学中用于描述共价和离子电子态之间相互作用的标准双能级量子力学模型。所有参数、常数和函数形式都有明确的定义和物理动机。因此，该问题被视为 **有效**，并将提供解答。\n\n该体系由一个在基矢 $\\{\\lvert \\mathrm{cov} \\rangle, \\lvert \\mathrm{ion} \\rangle\\}$ 下的透热哈密顿矩阵描述，如下所示：\n$$\nH(R) = \\begin{pmatrix}\nE_{\\mathrm{cov}}(R)  V(R) \\\\\nV(R)  E_{\\mathrm{ion}}(R)\n\\end{pmatrix}\n$$\n根据所给定义，$E_{\\mathrm{cov}}(R) = 0$，$E_{\\mathrm{ion}}(R) = \\Delta_{\\infty} - k_e/(\\varepsilon_r R)$，以及 $V(R) = V_0 \\exp(-\\alpha(R - R_0))$。因此，哈密顿量为：\n$$\nH(R) = \\begin{pmatrix}\n0  V(R) \\\\\nV(R)  E_{\\mathrm{ion}}(R)\n\\end{pmatrix}\n$$\n为了找到基态的离子性，我们必须首先求出该哈密顿量的本征值和相应的基态本征向量。本征值 $\\lambda$ 是特征方程 $\\det(H(R) - \\lambda I) = 0$ 的根：\n$$\n\\det \\begin{pmatrix}\n-\\lambda  V(R) \\\\\nV(R)  E_{\\mathrm{ion}}(R) - \\lambda\n\\end{pmatrix} = (-\\lambda)(E_{\\mathrm{ion}}(R) - \\lambda) - V(R)^2 = 0\n$$\n$$\n\\lambda^2 - E_{\\mathrm{ion}}(R)\\lambda - V(R)^2 = 0\n$$\n两个本征值，代表了绝热态的能量，为：\n$$\n\\lambda_{\\pm}(R) = \\frac{E_{\\mathrm{ion}}(R) \\pm \\sqrt{E_{\\mathrm{ion}}(R)^2 + 4V(R)^2}}{2}\n$$\n基态是能量较低的状态，对应于负号。基态绝热能量为：\n$$\nE_g(R) = \\lambda_{-}(R) = \\frac{E_{\\mathrm{ion}}(R) - \\sqrt{E_{\\mathrm{ion}}(R)^2 + 4V(R)^2}}{2}\n$$\n设基态本征向量表示为 $\\lvert \\psi_g(R) \\rangle = c_{\\mathrm{cov}}(R) \\lvert \\mathrm{cov} \\rangle + c_{\\mathrm{ion}}(R) \\lvert \\mathrm{ion} \\rangle$。离子性 $p_{\\mathrm{ion}}(R)$ 定义为离子组分的概率权重，即 $|c_{\\mathrm{ion}}(R)|^2$。对于一个具有透热能量 $E_1$ 和 $E_2$ 以及耦合 $V$ 的通用双能级系统，其中基态对应于能量较低的透热态，根据标准的微扰理论和矩阵对角化结果，基态绝热态中第二个透热态的概率由下式给出。系数取决于透热能量的顺序。一个用于计算基态绝热态中 $\\lvert \\mathrm{ion} \\rangle$ 态（我们在此标记为态2，能量为 $E_2 = E_{\\mathrm{ion}}$）布居数的稳健公式是：\n$$\np_{\\mathrm{ion}}(R) = |c_{\\mathrm{ion}}(R)|^2 = \\frac{1}{2} \\left( 1 - \\frac{E_{\\mathrm{ion}}(R) - E_{\\mathrm{cov}}(R)}{\\sqrt{(E_{\\mathrm{ion}}(R) - E_{\\mathrm{cov}}(R))^2 + 4V(R)^2}} \\right)\n$$\n代入 $E_{\\mathrm{cov}}(R) = 0$：\n$$\np_{\\mathrm{ion}}(R) = \\frac{1}{2} \\left( 1 - \\frac{E_{\\mathrm{ion}}(R)}{\\sqrt{E_{\\mathrm{ion}}(R)^2 + 4V(R)^2}} \\right)\n$$\n这个表达式在物理上是正确的。在大的分离距离 $R \\to \\infty$ 时，$V(R) \\to 0$ 且 $E_{\\mathrm{ion}}(R) \\to \\Delta_{\\infty}  0$。基态应为纯共价态。该公式得出 $p_{\\mathrm{ion}}(R) \\to \\frac{1}{2}(1 - \\frac{\\Delta_\\infty}{|\\Delta_\\infty|}) = \\frac{1}{2}(1-1) = 0$。在非常小的分离距离 $R$ 时，库仑项占主导地位，$E_{\\mathrm{ion}}(R) \\to -\\infty$，基态应为纯离子态。该公式得出 $p_{\\mathrm{ion}}(R) \\to \\frac{1}{2}(1 - \\frac{E_{\\mathrm{ion}}(R)}{|E_{\\mathrm{ion}}(R)|}) = \\frac{1}{2}(1 - (-1)) = 1$。该公式是一致的。\n\n接下来，我们必须确定转换距离 $R^\\ast$，它被定义为使 $p_{\\mathrm{ion}}(R) = 0.5$ 的最小正值 $R$。我们将 $p_{\\mathrm{ion}}(R)$ 的表达式设为 $0.5$：\n$$\n\\frac{1}{2} \\left( 1 - \\frac{E_{\\mathrm{ion}}(R^\\ast)}{\\sqrt{E_{\\mathrm{ion}}(R^\\ast)^2 + 4V(R^\\ast)^2}} \\right) = 0.5\n$$\n$$\n1 - \\frac{E_{\\mathrm{ion}}(R^\\ast)}{\\sqrt{E_{\\mathrm{ion}}(R^\\ast)^2 + 4V(R^\\ast)^2}} = 1\n$$\n$$\n\\frac{E_{\\mathrm{ion}}(R^\\ast)}{\\sqrt{E_{\\mathrm{ion}}(R^\\ast)^2 + 4V(R^\\ast)^2}} = 0\n$$\n这个条件成立的充分必要条件是分子为零，因为对于任何有限的 $R$，分母都严格为正（因为 $V(R)$ 是一个非零的指数函数）。因此，转换距离的条件非常简单：\n$$\nE_{\\mathrm{ion}}(R^\\ast) = 0\n$$\n这对应于透热势能曲线的交叉点。我们求解 $R^\\ast$：\n$$\n\\Delta_{\\infty} - \\frac{k_e}{\\varepsilon_r R^\\ast} = 0\n$$\n$$\n\\Delta_{\\infty} = \\frac{k_e}{\\varepsilon_r R^\\ast}\n$$\n求解 $R^\\ast$ 得到唯一的正解：\n$$\nR^\\ast = \\frac{k_e}{\\varepsilon_r \\Delta_{\\infty}}\n$$\n对于每个测试用例 $(\\varepsilon_r, \\Delta_{\\infty}, V_0, \\alpha, R_0, R)$ 的计算步骤如下：\n1. 计算 $E_{\\mathrm{ion}}(R) = \\Delta_{\\infty} - \\frac{k_e}{\\varepsilon_r R}$。\n2. 计算 $V(R) = V_0 \\exp(-\\alpha(R - R_0))$。\n3. 计算 $p_{\\mathrm{ion}}(R) = \\frac{1}{2} \\left( 1 - E_{\\mathrm{ion}}(R) / \\sqrt{E_{\\mathrm{ion}}(R)^2 + 4V(R)^2} \\right)$。\n4. 计算 $R^\\ast = k_e / (\\varepsilon_r \\Delta_{\\infty})$。\n5. 将 $p_{\\mathrm{ion}}(R)$ 和 $R^\\ast$ 四舍五入到六位小数。\n\n这些步骤将以编程方式实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-state diatomic system problem for a given set of test cases.\n    \"\"\"\n    \n    # Coulomb constant in eV * Angstrom.\n    k_e = 14.3996454784255\n\n    # Test suite: (epsilon_r, Delta_inf, V_0, alpha, R_0, R)\n    test_cases = [\n        (1.0, 1.99, 2.0, 1.2, 2.0, 3.0),\n        (1.0, 1.99, 2.0, 1.2, 2.0, 1.5),\n        (1.0, 1.99, 2.0, 1.2, 2.0, 20.0),\n        (10.0, 1.99, 2.0, 1.2, 2.0, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_r, delta_inf, v0, alpha, r0, r = case\n\n        # Calculate p_ion(R)\n        # 1. Calculate the energy of the ionic diabatic state E_ion(R)\n        e_ion_r = delta_inf - k_e / (eps_r * r)\n\n        # 2. Calculate the diabatic coupling V(R)\n        v_r = v0 * np.exp(-alpha * (r - r0))\n\n        # 3. Calculate the ionic character p_ion(R)\n        # The formula used is p_ion = 0.5 * (1 - E_ion / sqrt(E_ion^2 + 4*V^2))\n        # This correctly handles the limits for R - 0 and R - infinity.\n        denominator = np.sqrt(e_ion_r**2 + 4 * v_r**2)\n        if denominator == 0:\n            # This case only happens if E_ion = 0 and V = 0.\n            # V is never zero for finite R. If for some numerical reason\n            # it becomes zero, we handle it. At E_ion=0, p_ion is 0.5\n            p_ion = 0.5\n        else:\n            p_ion = 0.5 * (1 - e_ion_r / denominator)\n\n        # Calculate the switching distance R*\n        # This is the distance R where E_ion(R) = 0.\n        # R* = k_e / (epsilon_r * Delta_inf)\n        r_star = k_e / (eps_r * delta_inf)\n\n        # Round the results to six decimal places\n        p_ion_rounded = round(p_ion, 6)\n        r_star_rounded = round(r_star, 6)\n\n        results.append(p_ion_rounded)\n        results.append(r_star_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}