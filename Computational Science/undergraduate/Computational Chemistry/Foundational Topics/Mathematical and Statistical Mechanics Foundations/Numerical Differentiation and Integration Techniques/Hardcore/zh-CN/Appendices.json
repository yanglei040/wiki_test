{
    "hands_on_practices": [
        {
            "introduction": "我们动手实践的第一步是掌握一种最基本且广泛应用的数值积分技术：梯形法则。这个练习将指导你应用梯形法则来计算误差函数（$erf(z)$），这是一个在统计学和高斯轨道积分等计算化学领域频繁出现的函数。通过亲手实现算法，并将其结果与精确值及理论误差界限进行比较，你不仅能学会如何进行数值积分，更能深刻理解数值方法中准确性和误差分析的核心重要性。",
            "id": "2459587",
            "problem": "考虑为实数 $z$ 定义的误差函数 $\\text{erf}(z)$：\n$$\n\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{z} e^{-t^{2}} \\, dt.\n$$\n这个特殊函数广泛出现在计算化学中，例如在高斯轨道积分和涉及正态分布的扩散模型中。令 $N$ 表示一个正整数，指定用于划分积分区间的相等子区间的数量。\n\n任务：编写一个完整的程序，对于下面列出的每个测试用例 $(z,N)$，使用复合梯形法则对上述积分定义计算近似值 $\\widehat{\\text{erf}}(z;N)$，然后：\n1. 计算绝对误差\n$$\nE_{\\text{abs}}(z,N) = \\left| \\text{erf}(z) - \\widehat{\\text{erf}}(z;N) \\right|.\n$$\n2. 计算从此问题的被积函数的二阶导数导出的严格复合梯形误差界，即\n$$\nB(z,N) = \\frac{2}{\\sqrt{\\pi}} \\cdot \\frac{|z|}{12} \\left(\\frac{|z|}{N}\\right)^{2} \\cdot \\max_{t \\in [\\min(0,z), \\max(0,z)]} \\left| \\frac{d^{2}}{dt^{2}} e^{-t^{2}} \\right|.\n$$\n您的程序必须使用该最大值的精确解析值。测试用例集为：\n- $(z,N) = (0, 1)$，\n- $(z,N) = (0.5, 10)$，\n- $(z,N) = (1.0, 2)$，\n- $(z,N) = (1.0, 50)$，\n- $(z,N) = (2.0, 200)$，\n- $(z,N) = (-1.0, 50)$，\n- $(z,N) = (3.0, 400)$。\n\n不涉及角度单位。不涉及物理单位。输出中使用的所有实数都必须以包含 $12$ 位有效数字的科学记数法书写。\n\n最终输出格式：您的程序应生成单行输出，包含一个列表，其中每个元素按上面列出的相同顺序对应一个测试用例，且每个元素是一个双元素列表 $[E_{\\text{abs}}(z,N), B(z,N)]$。外层列表和每个内层列表都必须在没有任何空白字符的情况下书写，并使用逗号作为分隔符。例如，所需结构的形式为 $[[x_{1},y_{1}],[x_{2},y_{2}],\\ldots]$，其中每个 $x_{k}$ 和 $y_{k}$ 是一个具有 $12$ 位有效数字的科学记数法表示的浮点数。",
            "solution": "该问题是有效的。它提出了一个数值分析中清晰、适定 (well-posed) 的任务，该任务具有科学依据并与计算化学相关。所需的公式要么已提供，要么是标准公式，且所要求的计算是可行的。我现在将提供解决方案。\n\n任务要求为几个测试用例 $(z,N)$ 计算两个量：误差函数 $\\text{erf}(z)$ 的数值近似的绝对误差 $E_{\\text{abs}}(z,N)$，以及相应的理论误差界 $B(z,N)$。\n\n误差函数的定义如下：\n$$\n\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{z} e^{-t^{2}} \\, dt\n$$\n这是一个奇函数，意味着 $\\text{erf}(-z) = -\\text{erf}(z)$。此性质将很有用。\n\n首先，我们使用复合梯形法则设计数值近似 $\\widehat{\\text{erf}}(z;N)$。该法则使用 $N$ 个宽度为 $h=(b-a)/N$ 的相等子区间来近似积分 $\\int_{a}^{b} f(t) \\, dt$，如下所示：\n$$\n\\int_{a}^{b} f(t) \\, dt \\approx \\frac{h}{2} \\left( f(t_0) + 2\\sum_{k=1}^{N-1} f(t_k) + f(t_N) \\right)\n$$\n其中 $t_k = a+kh$。对于我们的问题，被积函数是 $f(t) = e^{-t^2}$。\n\n对于一个给定的测试用例 $(z,N)$：\n如果 $z=0$，积分为 $0$，因此 $\\text{erf}(0) = 0$。近似值也显然为 $0$，使得误差 $E_{\\text{abs}}(0,N)=0$。\n如果 $z0$，我们设 $a=0$ 和 $b=z$。步长为 $h=z/N$。积分 $I(z) = \\int_{0}^{z} e^{-t^2} dt$ 的近似值为：\n$$\n\\widehat{I}(z;N) = \\frac{z}{N} \\left( \\frac{e^{-0^2} + e^{-z^2}}{2} + \\sum_{k=1}^{N-1} e^{-(kz/N)^2} \\right)\n$$\n误差函数的近似值则为 $\\widehat{\\text{erf}}(z;N) = \\frac{2}{\\sqrt{\\pi}} \\widehat{I}(z;N)$。\n如果 $z0$，我们使用奇对称性。我们计算正值 $|z|$ 的近似值，然后取其相反数：\n$$\n\\widehat{\\text{erf}}(z;N) = -\\widehat{\\text{erf}}(|z|;N)\n$$\n这简化了实现，因为梯形法则总是应用于非负区间 $[0, |z|]$。\n\n其次，我们计算绝对误差 $E_{\\text{abs}}(z,N)$。其定义如下：\n$$\nE_{\\text{abs}}(z,N) = \\left| \\text{erf}(z) - \\widehat{\\text{erf}}(z;N) \\right|\n$$\n“真实”值 $\\text{erf}(z)$ 是使用 `scipy.special` 库中的高精度实现获得的。\n\n第三，我们评估严格误差界 $B(z,N)$。问题提供了以下公式：\n$$\nB(z,N) = \\frac{2}{\\sqrt{\\pi}} \\cdot \\frac{|z|}{12} \\left(\\frac{|z|}{N}\\right)^{2} \\cdot \\max_{t \\in [\\min(0,z), \\max(0,z)]} \\left| \\frac{d^{2}}{dt^{2}} e^{-t^{2}} \\right|\n$$\n这可以重写为 $B(z,N) = \\frac{2|z|^3}{12\\sqrt{\\pi}N^2} M_2$，其中 $M_2$ 是被积函数 $f(t) = e^{-t^2}$ 的二阶导数绝对值在积分区间上的最大值。问题要求使用该最大值的精确解析值。让我们来求它。\n一阶导数为 $f'(t) = -2t e^{-t^2}$。\n二阶导数为：\n$$\nf''(t) = \\frac{d}{dt}\\left(-2t e^{-t^2}\\right) = -2e^{-t^2} + (-2t)(-2t e^{-t^2}) = (4t^2 - 2)e^{-t^2}\n$$\n我们必须在区间 $[\\min(0,z), \\max(0,z)]$ 上找到 $|f''(t)| = |(4t^2 - 2)e^{-t^2}|$ 的最大值。由于 $|f''(t)|$ 是一个偶函数，这等价于在 $[0, |z|]$ 上找到其最大值。\n一个函数在闭区间上的最大值出现在区间的端点或其内部的临界点。让我们分析 $t \\ge 0$ 时的 $|f''(t)|$。\n端点是 $t=0$ 和 $t=|z|$。\n在 $t=0$ 时，我们有 $|f''(0)| = |(0-2)e^0| = 2$。\n为了找到临界点，我们考察三阶导数 $f'''(t)$。\n$$\nf'''(t) = \\frac{d}{dt}\\left((4t^2 - 2)e^{-t^2}\\right) = (8t)e^{-t^2} + (4t^2 - 2)(-2t e^{-t^2}) = (8t - 8t^3 + 4t)e^{-t^2} = (12t - 8t^3)e^{-t^2} = 4t(3-2t^2)e^{-t^2}\n$$\n$f'''(t)=0$ 的临界点是 $t=0$ 和 $t=\\pm\\sqrt{3/2}$。\n函数 $|f''(t)|$ 在 $t=\\sqrt{3/2}\\approx 1.225$ 处有一个局部最大值，其值为 $|f''(\\sqrt{3/2})| = |(4(3/2)-2)e^{-3/2}| = 4e^{-3/2} \\approx 0.892$。它在 $f''(t)=0$ 的地方有一个局部最小值（值为 $0$），即 $t=\\sqrt{1/2} \\approx 0.707$。\n函数 $|f''(t)|$ 在 $t=0$ 处的值为 $2$，在 $t=\\sqrt{1/2}$ 处减小到 $0$，在 $t=\\sqrt{3/2}$ 处增加到一个局部最大值 $\\approx 0.892$，然后随着 $t \\to \\infty$ 单调递减趋向于 $0$。\n对于所有 $t \\ge 0$，$|f''(t)|$ 的全局最大值出现在 $t=0$ 处，其值为 $2$。\n由于对于任何 $z$，积分区间 $[\\min(0,z), \\max(0,z)]$ 总是包含点 $t=0$，因此 $|f''(t)|$ 在此区间上的最大值总是 $M_2 = 2$。\n将这个精确的解析值代入误差界公式：\n$$\nB(z,N) = \\frac{2|z|^3}{12\\sqrt{\\pi}N^2} \\cdot 2 = \\frac{4|z|^3}{12\\sqrt{\\pi}N^2} = \\frac{|z|^3}{3\\sqrt{\\pi}N^2}\n$$\n对于 $z=0$，这正确地得出 $B=0$。\n\n实现将循环遍历测试用例，应用这些公式，并按指定格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.special\n\ndef solve():\n    \"\"\"\n    Computes the absolute error and theoretical error bound for a composite\n    trapezoidal approximation of the error function erf(z).\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1),\n        (0.5, 10),\n        (1.0, 2),\n        (1.0, 50),\n        (2.0, 200),\n        (-1.0, 50),\n        (3.0, 400),\n    ]\n\n    # This will hold lists of [E_abs, B] for each test case\n    results_data = []\n\n    for z, N in test_cases:\n        # Trivial case z=0. The integral, approximation, error, and bound are all 0.\n        if z == 0.0:\n            e_abs = 0.0\n            bound = 0.0\n            results_data.append([e_abs, bound])\n            continue\n\n        # Use the property erf(-z) = -erf(z).\n        # The trapezoidal rule is always applied on the positive interval [0, |z|].\n        z_abs = abs(z)\n        \n        # 1. Compute the approximation using the composite trapezoidal rule.\n        #    numpy.trapz provides a concise and efficient implementation.\n        #    The integration nodes are from 0 to |z| with N subintervals.\n        t_nodes = np.linspace(0, z_abs, N + 1)\n        integrand_values = np.exp(-t_nodes**2)\n        integral_approx = np.trapz(integrand_values, t_nodes)\n        \n        # Apply the pre-factor and sign for the final erf approximation.\n        erf_approx = np.sign(z) * (2.0 / np.sqrt(np.pi)) * integral_approx\n\n        # 2. Compute the absolute error against the high-precision library function.\n        erf_true = scipy.special.erf(z)\n        e_abs = abs(erf_true - erf_approx)\n\n        # 3. Compute the rigorous error bound.\n        #    The generic formula is B = (2/sqrt(pi)) * (|z|/12) * (|z|/N)^2 * M2,\n        #    where M2 = max|f''(t)|.\n        #    The analytic maximum M2 for f(t)=exp(-t^2) is 2.\n        #    This simplifies the formula to B = |z|^3 / (3 * N^2 * sqrt(pi)).\n        bound = (z_abs**3) / (3.0 * np.sqrt(np.pi) * N**2)\n        \n        results_data.append([e_abs, bound])\n\n    # Format the final output string exactly as required by the problem statement:\n    # A list of lists, with no whitespace, and numbers in scientific notation\n    # with 12 significant digits.\n    formatted_pairs = []\n    for e, b in results_data:\n        e_str = f\"{e:.12e}\"\n        b_str = f\"{b:.12e}\"\n        formatted_pairs.append(f\"[{e_str},{b_str}]\")\n    \n    final_output_string = f\"[{','.join(formatted_pairs)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了基础之后，让我们将数值方法应用于一个真实的生物物理化学问题：从结合能数据中估算蛋白质的$pK_a$值。在药物设计和酶学研究中，理解配体与蛋白质的结合如何随$pH$变化至关重要，而$pK_a$是表征这一变化的关键参数。此练习将引导你使用数值微分来定位结合能曲线的拐点以确定$pK_a$，并结合数值积分来验证总能量变化，这充分展示了如何从离散的模拟或实验数据中提取有价值的物理化学洞见。",
            "id": "2459600",
            "problem": "在计算化学中，pH依赖性结合源于蛋白质中可滴定基团的质子化平衡。考虑一个配体，其与蛋白质的结合自由能（记为 $E(pH)$，单位为千焦/摩尔）会随着 $pH$ 平滑变化。这种变化是由一个单一的酸碱转换引起的，该转换由酸解离常数 $pK_a$（以pH单位表示）来表征。根据热力学和酸碱原理，当单个位点主导该转换时，$E(pH)$ 是一个平滑的、单调的S形函数。这种单调S形曲线的拐点出现在其对应的 $pK_a$ 附近，因此斜率的绝对值 $\\left|\\dfrac{dE}{dpH}\\right|$ 通常在 $pH \\approx pK_a$ 附近达到最大值。导数和积分根据第一性原理分别定义为差商和黎曼和的极限。复合梯形法是一种标准的、经过充分检验的数值积分方法，它通过对曲线下的梯形面积求和来近似定积分。这些思想使得我们能够采用一种完全数值化的策略，从离散的 $E(pH)$ 数据中估算 $pK_a$，即使是在非均匀的 $pH$ 网格上。\n\n任务。编写一个完整的程序，给定几个离散数据集 $\\{(pH_i, E_i)\\}_{i=0}^{N-1}$，对每个数据集执行以下操作，不使用任何封闭形式的模型拟合：\n- 使用一种基于局部二次插值的二阶精度有限差分格式，在给定的网格点上数值近似导数 $\\dfrac{dE}{dpH}$。该格式适用于非均匀网格。在端点处使用单侧、二阶精度的三点公式，在内部点处使用三点公式。\n- 将蛋白质的 $pK_a$ 估计为在所提供网格上 $\\left|\\dfrac{dE}{dpH}\\right|$ 达到最大值时的 $pH$ 值。\n- 使用复合梯形法在给定网格上对所提供的 $pH$ 范围内的 $\\dfrac{dE}{dpH}$ 进行数值积分，以估算整个范围内的结合自由能净变化。以千焦/摩尔为单位报告此估算的变化量。\n\n单位和四舍五入。结合自由能 $E$ 的单位是千焦/摩尔。报告的 $pK_a$ 以 pH 单位表示，并四舍五入到两位小数。报告的积分能量变化以千焦/摩尔为单位，并四舍五入到两位小数。\n\n角度单位。如果在内部使用了任何三角函数（例如在下面的测试数据中用于生成确定性噪声），请将角度解释为弧度。\n\n本问题的输入格式。没有外部输入。您的程序必须在内部构建并使用下面指定的测试套件数据集。\n\n测试套件。为使任务自成体系且可测试，请使用以下三个合成但物理上合理的数据集。在每种情况下，“测量”的结合能按如下方式构建：\n$$\nE(pH) \\;=\\; E_{\\mathrm{acid}} \\;+\\; \\left(E_{\\mathrm{base}} - E_{\\mathrm{acid}}\\right)\\,\\alpha(pH)\\;+\\; \\eta(pH),\n$$\n其中\n$$\n\\alpha(pH) \\;=\\; \\dfrac{1}{1 + 10^{\\,pK_a - pH}}\n$$\n是单质子位点的去质子化分数，而 $\\eta(pH)$ 是一个小的、与基线相关的确定性项，用于模拟实验噪声。没有随机性；$\\eta(pH)$ 是明确指定的。使用以下三种情况：\n\n- 情况A（均匀网格，细间距，低噪声）：$E_{\\mathrm{acid}} = -30.00$ 千焦/摩尔，$E_{\\mathrm{base}} = -10.00$ 千焦/摩尔，$pK_a = 6.50$，$pH$ 网格从 $2.00$ 到 $12.00$（含），步长为 $0.25$（均匀），以及 $\\eta(pH) = 0.05 \\,\\sin(0.90\\, pH)$。\n- 情况B（非均匀网格，中等噪声）：$E_{\\mathrm{acid}} = -25.00$ 千焦/摩尔，$E_{\\mathrm{base}} = -15.00$ 千焦/摩尔，$pK_a = 4.20$，$pH$ 网格由列表 $[2.00,\\; 2.50,\\; 3.00,\\; 3.50,\\; 4.00,\\; 4.30,\\; 4.60,\\; 5.30,\\; 6.20,\\; 7.50,\\; 9.00,\\; 12.00]$ 明确给出，以及 $\\eta(pH) = 0.08 \\,\\cos(1.30\\, pH)$。\n- 情况C（均匀网格，粗间距，极低噪声）：$E_{\\mathrm{acid}} = -32.00$ 千焦/摩尔，$E_{\\mathrm{base}} = -8.00$ 千焦/摩尔，$pK_a = 9.00$，$pH$ 网格从 $6.00$ 到 $12.00$（含），步长为 $1.00$（均匀），以及 $\\eta(pH) = 0.03 \\,\\sin(1.10\\, pH + 0.30)$。\n\n每种情况需要计算什么：\n- 估算的 $pK_a$ 值，以 pH 单位表示，四舍五入到两位小数，通过在给定网格上找到 $\\left|\\dfrac{dE}{dpH}\\right|$ 最大值的位置的 $pH$ 获得。\n- 在提供的 $pH$ 范围内的积分结合能变化，通过在给定网格上使用复合梯形法计算 $\\displaystyle \\int_{pH_{\\min}}^{pH_{\\max}} \\dfrac{dE}{dpH}\\, dpH$ 得出，以千焦/摩尔表示，并四舍五入到两位小数。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个案例的结果，格式为列表的列表。每个内部列表包含两个浮点数，顺序为 $[pK_a^{\\mathrm{est}}, \\Delta E^{\\mathrm{int}}]$，其中 $pK_a^{\\mathrm{est}}$ 是估算的 $pK_a$ 值，$\\Delta E^{\\mathrm{int}}$ 是积分能量变化。整个输出必须打印为形如 $[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$ 的单行，不含空格，其中每个 $a_i$ 和 $b_i$ 都是按上述规定四舍五入的小数。例如，像 $[[6.50,19.95],[4.30,10.02],[9.00,24.01]]$ 这样的输出字符串遵循所需格式。",
            "solution": "该问题已经过严格验证，并被确定为有效。它具有科学依据、提法明确且客观。问题陈述描述了生物物理化学中的一个标准情景，即配体结合亲和力受 $pH$ 调节。其基础模型基于单一位点的酸碱平衡，是对热力学原理的正确应用。通过导数绝对值 $\\left|\\frac{dE}{dpH}\\right|$ 的最大值来估算 $pK_a$ 的任务是分析S形滴定曲线的一种行之有效的方法。指定的数值技术——用于非均匀网格的二阶有限差分法和复合梯形法——是标准且适用于该任务的。所有必需的参数和数据均已提供，使得问题自成体系且易于处理。因此，我们可以着手推导和构建解决方案。\n\n该解决方案是基于一系列既定原则构建的，从物理模型开始，然后到所需的数值算法。\n\n1.  **物理模型与数据生成**\n    结合自由能 $E(pH)$ 被给出为 $pH$ 的函数。对于单个可滴定基团，这种依赖关系由以下方程建模：\n    $$\n    E(pH) = E_{\\mathrm{acid}} + \\left(E_{\\mathrm{base}} - E_{\\mathrm{acid}}\\right)\\,\\alpha(pH) + \\eta(pH)\n    $$\n    此处，$E_{\\mathrm{acid}}$ 和 $E_{\\mathrm{base}}$ 分别是可滴定基团完全质子化和去质子化时的结合自由能。$\\eta(pH)$ 项代表小的实验噪声或基线伪影。函数 $\\alpha(pH)$ 是处于去质子化（碱基）形式的位点分数，由标准的 Henderson-Hasselbalch 导出的S形函数给出：\n    $$\n    \\alpha(pH) = \\dfrac{1}{1 + 10^{\\,pK_a - pH}}\n    $$\n    对于每个测试用例，此模型用于生成离散数据集 $\\{ (pH_i, E_i) \\}_{i=0}^{N-1}$，作为后续数值分析的输入。\n\n2.  **数值微分**\n    $pK_a$ 估算的核心在于从离散数据计算导数 $\\frac{dE}{dpH}$。问题指定了一种二阶精度的有限差分格式，该格式对非均匀网格有效，这在实验数据中很常见。此类格式是通过将二次多项式 $P(x)$ 局部拟合到三个相邻数据点，然后对该多项式进行解析微分得出的。设数据点为 $(x_i, f_i)$，代表 $(pH_i, E_i)$，并设 $h_i = x_{i+1} - x_i$ 为步长，其可以随 $i$ 变化。导数 $f'(x_i)$ 的公式如下：\n\n    -   **内部点 ($i = 1, \\dots, N-2$)：** 使用中心差分公式，基于点 $(x_{i-1}, f_{i-1})$、$(x_i, f_i)$ 和 $(x_{i+1}, f_{i+1})$。设 $h_{i-1} = x_i - x_{i-1}$ 和 $h_i = x_{i+1} - x_i$，导数为：\n        $$\n        f'(x_i) \\approx f_{i-1} \\frac{-h_i}{h_{i-1}(h_{i-1}+h_i)} + f_i \\frac{h_i-h_{i-1}}{h_{i-1}h_i} + f_{i+1} \\frac{h_{i-1}}{h_i(h_{i-1}+h_i)}\n        $$\n\n    -   **左端点 ($i=0$)：** 使用单侧前向差分公式，基于点 $(x_0, f_0)$、$(x_1, f_1)$ 和 $(x_2, f_2)$。设 $h_0 = x_1 - x_0$ 和 $h_1 = x_2 - x_1$，导数为：\n        $$\n        f'(x_0) \\approx f_0 \\frac{-(2h_0+h_1)}{h_0(h_0+h_1)} + f_1 \\frac{h_0+h_1}{h_0 h_1} - f_2 \\frac{h_0}{h_1(h_0+h_1)}\n        $$\n\n    -   **右端点 ($i=N-1$)：** 使用单侧后向差分公式，基于点 $(x_{N-3}, f_{N-3})$、$(x_{N-2}, f_{N-2})$ 和 $(x_{N-1}, f_{N-1})$。设 $h_{N-3} = x_{N-2} - x_{N-3}$ 和 $h_{N-2} = x_{N-1} - x_{N-2}$，导数为：\n        $$\n        f'(x_{N-1}) \\approx f_{N-3}\\frac{h_{N-2}}{h_{N-3}(h_{N-3}+h_{N-2})} - f_{N-2}\\frac{h_{N-3}+h_{N-2}}{h_{N-3}h_{N-2}} + f_{N-1}\\frac{h_{N-3}+2h_{N-2}}{h_{N-2}(h_{N-3}+h_{N-2})}\n        $$\n    这些公式为整个网格提供了一个完整的导数值向量 $(\\frac{dE}{dpH})_i$。\n\n3.  **$pK_a$ 的估算**\n    可滴定基团的 $pK_a$ 对应于S形 $E(pH)$ 曲线的拐点。在此点，曲线的陡峭程度最大。因此，估算的 $pK_a$ 被确定为网格上数值计算导数的绝对值 $\\left|\\frac{dE}{dpH}\\right|$ 达到最大值时的 $pH$ 值。\n    $$\n    pK_a^{\\mathrm{est}} = pH_k \\quad \\text{where} \\quad k = \\underset{i \\in \\{0, \\dots, N-1\\}}{\\arg\\max} \\left| \\left( \\frac{dE}{dpH} \\right)_i \\right|\n    $$\n\n4.  **数值积分**\n    在测量的 $pH$ 范围内的结合自由能净变化 $\\Delta E^{\\mathrm{int}}$ 是通过对数值导数 $\\frac{dE}{dpH}$ 积分来计算的。问题要求使用复合梯形法。对于在点 $(x_i, g_i)$ 处采样的函数 $g(x)$，该法则通过对相邻点形成的梯形面积求和来近似定积分：\n    $$\n    \\int_{x_0}^{x_{N-1}} g(x) \\, dx \\approx \\sum_{i=0}^{N-2} \\frac{g_i + g_{i+1}}{2} (x_{i+1} - x_i)\n    $$\n    将此方法应用于我们计算出的导数值 $(pH_i, (\\frac{dE}{dpH})_i)$，即可得到所需的积分能量变化。根据微积分基本定理，该积分值应近似于函数的总变化量 $E(pH_{N-1}) - E(pH_0)$，其中的差异源于微分和积分步骤中的数值误差。\n\n最终程序为三个指定的测试用例实现了这一系列操作，并遵循了要求的四舍五入和输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerical_derivative(x, y):\n    \"\"\"\n    Computes the derivative of y with respect to x on a potentially\n    non-uniform grid using second-order accurate finite differences.\n    \"\"\"\n    n = len(x)\n    if n  3:\n        raise ValueError(\"At least 3 points are required for second-order differences.\")\n    \n    dydx = np.zeros(n)\n\n    # First point: second-order forward difference\n    h0 = x[1] - x[0]\n    h1 = x[2] - x[1]\n    if h0 == 0 or h1 == 0:\n        raise ValueError(\"Grid points must be strictly increasing.\")\n    \n    c0 = -(2 * h0 + h1) / (h0 * (h0 + h1))\n    c1 = (h0 + h1) / (h0 * h1)\n    c2 = -h0 / (h1 * (h0 + h1))\n    dydx[0] = c0 * y[0] + c1 * y[1] + c2 * y[2]\n\n    # Interior points: second-order central difference\n    for i in range(1, n - 1):\n        h_prev = x[i] - x[i-1]\n        h_next = x[i+1] - x[i]\n        if h_prev == 0 or h_next == 0:\n            raise ValueError(\"Grid points must be strictly increasing.\")\n        \n        c_prev = -h_next / (h_prev * (h_prev + h_next))\n        c_curr = (h_next - h_prev) / (h_prev * h_next)\n        c_next = h_prev / (h_next * (h_prev + h_next))\n        dydx[i] = c_prev * y[i-1] + c_curr * y[i] + c_next * y[i+1]\n\n    # Last point: second-order backward difference\n    h_n_minus_3 = x[n-2] - x[n-3]\n    h_n_minus_2 = x[n-1] - x[n-2]\n    if h_n_minus_3 == 0 or h_n_minus_2 == 0:\n        raise ValueError(\"Grid points must be strictly increasing.\")\n    \n    c_n_minus_3 = h_n_minus_2 / (h_n_minus_3 * (h_n_minus_3 + h_n_minus_2))\n    c_n_minus_2 = -(h_n_minus_3 + h_n_minus_2) / (h_n_minus_3 * h_n_minus_2)\n    c_n_minus_1 = (h_n_minus_3 + 2 * h_n_minus_2) / (h_n_minus_2 * (h_n_minus_3 + h_n_minus_2))\n    dydx[n-1] = c_n_minus_3 * y[n-3] + c_n_minus_2 * y[n-2] + c_n_minus_1 * y[n-1]\n\n    return dydx\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            'E_acid': -30.00, 'E_base': -10.00, 'pKa': 6.50,\n            'pH_grid': np.arange(2.00, 12.00 + 1e-9, 0.25),\n            'eta': lambda ph: 0.05 * np.sin(0.90 * ph)\n        },\n        # Case B\n        {\n            'E_acid': -25.00, 'E_base': -15.00, 'pKa': 4.20,\n            'pH_grid': np.array([2.00, 2.50, 3.00, 3.50, 4.00, 4.30, 4.60, 5.30, 6.20, 7.50, 9.00, 12.00]),\n            'eta': lambda ph: 0.08 * np.cos(1.30 * ph)\n        },\n        # Case C\n        {\n            'E_acid': -32.00, 'E_base': -8.00, 'pKa': 9.00,\n            'pH_grid': np.arange(6.00, 12.00 + 1e-9, 1.00),\n            'eta': lambda ph: 0.03 * np.sin(1.10 * ph + 0.30)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Generate the discrete E(pH) data set\n        E_acid, E_base, pKa_true = case['E_acid'], case['E_base'], case['pKa']\n        pH_grid = case['pH_grid']\n        eta_func = case['eta']\n\n        alpha = 1.0 / (1.0 + 10**(pKa_true - pH_grid))\n        E_values = E_acid + (E_base - E_acid) * alpha + eta_func(pH_grid)\n\n        # Step 2: Numerically approximate the derivative dE/dpH\n        dEdpH = numerical_derivative(pH_grid, E_values)\n\n        # Step 3: Estimate pKa from the maximum of |dE/dpH|\n        abs_dEdpH = np.abs(dEdpH)\n        max_idx = np.argmax(abs_dEdpH)\n        pKa_est = pH_grid[max_idx]\n\n        # Step 4: Numerically integrate dE/dpH using trapezoidal rule\n        delta_E_int = np.trapz(dEdpH, pH_grid)\n        \n        # Step 5: Store the rounded results\n        results.append([pKa_est, delta_E_int])\n\n    # Final print statement in the exact required format.\n    # Format each result [pKa, dE] with 2 decimal places.\n    inner_parts = [f\"[{res[0]:.2f},{res[1]:.2f}]\" for res in results]\n    final_output_string = f\"[{','.join(inner_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "简单的数值方法有时会隐藏着惊人的威力，梯形法则在处理周期性函数时便是一个绝佳例子。当对一个光滑的周期函数在其整个周期上进行积分时，梯形法则的收敛速度会出人意料地快，远超通常的预期，这种现象被称为“谱精度”或“超收敛”。本练习将通过一系列解析函数，让你亲身体验并量化这一现象，这对于理解和高效处理计算化学中常见的周期性边界条件问题（例如晶体或溶剂化体系的模拟）具有非常重要的意义。",
            "id": "2459586",
            "problem": "考虑在计算化学中使用周期性边界条件的模拟中出现的 $2\\pi$-周期函数的积分求值问题。当应用于整个周期且节点等距时，标准的复合梯形法则会变得出人意料地精确，在某些情况下甚至是精确的。您的任务是从第一性原理出发，推导并实现周期性复合梯形法则，然后在一组解析选择的周期函数上测试并量化其收敛性。\n\n出发点和要求：\n- 从区间上的黎曼积分定义和周期性下端点的识别开始。利用这一点来论证如何在一个完整周期上积分时，通过在均匀间隔的角度上对 $2\\pi$-周期函数 $f(x)$ 进行采样，来构造一个没有端点重复的一致性复合梯形近似。\n- 始终采用弧度作为角度单位。$x$ 的每次求值都以弧度为单位。\n- 使用以下 $2\\pi$-周期测试函数：\n  1. $f_1(x) = \\sin(x) + \\dfrac{1}{2}\\cos(3x)$,\n  2. $f_2(x) = \\exp(\\sin x)$,\n  3. $f_3(x) = \\lvert \\sin x \\rvert$,\n  4. $f_4(x) = \\dfrac{1}{2 - \\cos x}$。\n- 对于每个 $N \\in \\mathbb{N}$，定义均匀步长 $h = \\dfrac{2\\pi}{N}$ 和节点 $x_j = jh$，其中 $j = 0, 1, \\ldots, N-1$。使用这些节点构造函数 $f$ 在一个周期 $[0, 2\\pi]$ 上积分的周期性复合梯形近似。\n\n精确积分或参考积分：\n- 为了验证，需要每个测试函数在 $[0, 2\\pi]$ 上的精确积分。您可以通过使用分析学中已确立的结果进行解析求解，或者通过一种独立的、其误差在本任务尺度上可忽略不计的高精度数值方法来获得这些值。所有量纲均为无量纲。\n- 使用这些精确值来计算周期性梯形法则的绝对误差。\n\n测试套件和覆盖范围：\n- 在以下情况下评估周期性梯形法则的绝对误差：\n  - 三角多项式的边缘混叠检查：\n    - $f_1$，$N = 1$ 和 $N = 8$。\n  - 解析非多项式函数（预期误差随 $N$ 快速、近指数衰减）：\n    - $f_2$，$N \\in \\{8, 16, 32, 64, 128\\}$。\n  - 非解析但连续的函数（预期误差随 $N$ 较慢的代数衰减）：\n    - $f_3$，$N \\in \\{8, 16, 32, 64, 128\\}$。\n  - 无实奇点的解析有理函数（预期误差随 $N$ 快速衰减）：\n    - $f_4$，$N \\in \\{8, 16, 32, 64, 128\\}$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含按以下指定确切顺序排列的绝对误差，格式为用方括号括起来的逗号分隔列表，每个数字均采用小数点后有 $12$ 位有效数字的科学记数法格式：\n  - 条目顺序：\n    - $f_1$：$N = 1$，然后 $N = 8$，\n    - $f_2$：$N = 8$, $16$, $32$, $64$, $128$，\n    - $f_3$：$N = 8$, $16$, $32$, $64$, $128$，\n    - $f_4$：$N = 8$, $16$, $32$, $64$, $128$。\n- 为清晰起见，输出应类似于 $[a_1,a_2,\\ldots,a_{17}]$，其中每个 $a_k$ 都是一个小数点后有 $12$ 位数字的科学记数法浮点数。\n\n您的实现必须是一个完整、可运行的程序，无需用户输入或外部文件，并且必须对所有角度使用弧度。列表中的最终答案必须是无量纲实数。",
            "solution": "所述问题已经过验证，被认为是科学上合理的、适定的和客观的。它提出了一个数值分析中的标准练习，具体涉及周期函数的求积法则的性质，这是一个在计算物理和计算化学中具有重要意义的课题。该问题没有矛盾或含糊之处，并提供了所有必要的数据。因此，我们可以进行正式求解。\n\n该任务要求推导和实现周期性复合梯形法则。我们从其形式推导开始。\n\n设 $f(x)$ 是在区间 $[a, b]$ 上的连续函数。定积分 $I = \\int_a^b f(x) \\,dx$ 可以使用复合梯形法则来近似。我们将区间 $[a, b]$ 划分为 $N$ 个等宽的子区间，宽度为 $h = (b-a)/N$。节点定义为 $x_j = a + jh$，其中 $j = 0, 1, \\ldots, N$。每个子区间 $[x_{j-1}, x_j]$ 上的积分近似为梯形的面积：\n$$ \\int_{x_{j-1}}^{x_j} f(x) \\,dx \\approx \\frac{h}{2} [f(x_{j-1}) + f(x_j)] $$\n将这 $N$ 个子区间上的近似值相加，得到复合梯形法则，记为 $T_N(f)$：\n$$ T_N(f) = \\sum_{j=1}^{N} \\frac{h}{2} [f(x_{j-1}) + f(x_j)] $$\n通过展开求和并合并各项，我们得到标准形式：\n$$ T_N(f) = h \\left( \\frac{1}{2}f(x_0) + \\sum_{j=1}^{N-1} f(x_j) + \\frac{1}{2}f(x_N) \\right) $$\n现在，我们将此公式推广到问题中提出的情况。函数 $f(x)$ 是 $2\\pi$ 周期的，即对于任意 $x \\in \\mathbb{R}$ 都有 $f(x+2\\pi)=f(x)$。积分区间是 $[0, 2\\pi]$。因此，我们有 $a=0$ 和 $b=2\\pi$。步长变为 $h = (2\\pi - 0)/N = 2\\pi/N$，节点为 $x_j = j(2\\pi/N)$，其中 $j = 0, 1, \\ldots, N$。\n\n关键的观察来自于 $f(x)$ 的周期性。函数在最后一个节点 $x_N$ 的值与它在第一个节点 $x_0$ 的值相关：\n$$ f(x_N) = f(N \\cdot \\frac{2\\pi}{N}) = f(2\\pi) = f(0+2\\pi) = f(0) = f(x_0) $$\n将 $f(x_N) = f(x_0)$ 代入 $T_N(f)$ 的通用公式：\n$$ T_N(f) = \\frac{2\\pi}{N} \\left( \\frac{1}{2}f(x_0) + \\sum_{j=1}^{N-1} f(x_j) + \\frac{1}{2}f(x_0) \\right) $$\n两个半权重端点项合并：\n$$ T_N(f) = \\frac{2\\pi}{N} \\left( f(x_0) + \\sum_{j=1}^{N-1} f(x_j) \\right) $$\n问题将节点定义为 $x_j = jh$，其中 $j=0, 1, \\ldots, N-1$。使用这组 $N$ 个节点，求和可以更紧凑地写出，从而得到周期性复合梯形法则：\n$$ T_N(f) = h \\sum_{j=0}^{N-1} f(x_j) = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} f\\left(j \\frac{2\\pi}{N}\\right) $$\n这个公式非常简单：它是在 $N$ 个等距点上函数值的算术平均值，再乘以周期长度 $2\\pi$。\n\n接下来，我们确定给定测试函数在 $[0, 2\\pi]$ 上的积分精确值，这是误差分析所必需的。\n\n1.  对于 $f_1(x) = \\sin(x) + \\frac{1}{2}\\cos(3x)$：\n    $$ I_1 = \\int_0^{2\\pi} \\left( \\sin(x) + \\frac{1}{2}\\cos(3x) \\right) \\,dx = \\left[ -\\cos(x) + \\frac{1}{6}\\sin(3x) \\right]_0^{2\\pi} $$\n    $$ I_1 = \\left( -1 + 0 \\right) - \\left( -1 + 0 \\right) = 0 $$\n\n2.  对于 $f_2(x) = \\exp(\\sin x)$：\n    积分 $I_2 = \\int_0^{2\\pi} e^{\\sin x} \\,dx$ 可与第一类修正 Bessel 函数 $I_n(z)$ 相关联，其定义为 $I_n(z) = \\frac{1}{\\pi} \\int_0^\\pi e^{z \\cos\\theta} \\cos(n\\theta) \\,d\\theta$。使用恒等式 $\\int_0^{2\\pi} g(\\sin x) \\,dx = \\int_0^{2\\pi} g(\\cos x) \\,dx$ 和对称性，我们发现：\n    $$ I_2 = \\int_0^{2\\pi} e^{\\cos x} \\,dx = 2 \\int_0^\\pi e^{\\cos x} \\,dx = 2\\pi \\left( \\frac{1}{\\pi} \\int_0^\\pi e^{1 \\cdot \\cos x} \\cos(0 \\cdot x) \\,dx \\right) = 2\\pi I_0(1) $$\n\n3.  对于 $f_3(x) = \\lvert \\sin x \\rvert$：\n    函数 $\\sin x$ 在 $[0, \\pi]$ 上非负，在 $[\\pi, 2\\pi]$ 上非正。\n    $$ I_3 = \\int_0^{2\\pi} \\lvert \\sin x \\rvert \\,dx = \\int_0^\\pi \\sin x \\,dx + \\int_\\pi^{2\\pi} (-\\sin x) \\,dx $$\n    $$ I_3 = [-\\cos x]_0^\\pi + [\\cos x]_\\pi^{2\\pi} = (-\\cos\\pi - (-\\cos 0)) + (\\cos(2\\pi) - \\cos\\pi) = (1 - (-1)) + (1 - (-1)) = 2 + 2 = 4 $$\n\n4.  对于 $f_4(x) = \\frac{1}{2 - \\cos x}$：\n    该积分是可通过围线积分或 Weierstrass 代换求值的标准形式。对于此类积分，一个已知的结果是当 $a > |b|$ 时，$\\int_0^{2\\pi} \\frac{d\\theta}{a+b\\cos\\theta} = \\frac{2\\pi}{\\sqrt{a^2-b^2}}$。这里，$a=2$ 且 $b=-1$，因此条件满足。\n    $$ I_4 = \\int_0^{2\\pi} \\frac{1}{2 - \\cos x} \\,dx = \\frac{2\\pi}{\\sqrt{2^2 - (-1)^2}} = \\frac{2\\pi}{\\sqrt{3}} $$\n\n数值实现将包含一个函数，该函数为给定的函数 $f$ 和点数 $N$ 计算周期性梯形法则的和。然后，对每个指定情况计算绝对误差 $|T_N(f) - I_{\\text{exact}}|$。对于解析函数 $f_1, f_2,$ 和 $f_4$，我们期望观察到所谓的“谱精度”——即误差衰减速度比 $1/N$ 的任何多项式都快。对于三角多项式 $f_1$，当 $N$ 大于最高频率的两倍时，该法则是精确的。对于在 $x=k\\pi$ 处连续但不可导的 $f_3$，其收敛速度受其平滑度的限制，预计为代数收敛，具体为 $O(N^{-2})$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests the periodic composite trapezoidal rule.\n    \"\"\"\n\n    # === 1. Define Test Functions ===\n    def f1(x: np.ndarray) - np.ndarray:\n        \"\"\"Trigonometric polynomial.\"\"\"\n        return np.sin(x) + 0.5 * np.cos(3 * x)\n\n    def f2(x: np.ndarray) - np.ndarray:\n        \"\"\"Analytic non-polynomial function.\"\"\"\n        return np.exp(np.sin(x))\n\n    def f3(x: np.ndarray) - np.ndarray:\n        \"\"\"Continuous, non-analytic function.\"\"\"\n        return np.abs(np.sin(x))\n\n    def f4(x: np.ndarray) - np.ndarray:\n        \"\"\"Analytic rational function.\"\"\"\n        return 1.0 / (2.0 - np.cos(x))\n\n    # === 2. Define Exact Integrals ===\n    I1_exact = 0.0\n    # The integral of f2 is 2*pi*I_0(1), where I_0 is the modified Bessel function of the first kind.\n    I2_exact = 2.0 * np.pi * i0(1.0)\n    I3_exact = 4.0\n    I4_exact = 2.0 * np.pi / np.sqrt(3.0)\n\n    # === 3. Numerical Integration Rule ===\n    def periodic_composite_trapezoidal(f, N: int) - float:\n        \"\"\"\n        Computes the integral of a 2*pi-periodic function f over [0, 2*pi]\n        using the periodic composite trapezoidal rule with N points.\n        \"\"\"\n        h = 2.0 * np.pi / N\n        # The nodes are x_j = j*h for j = 0, ..., N-1.\n        # np.linspace with endpoint=False generates these nodes correctly.\n        x_nodes = np.linspace(0.0, 2.0 * np.pi, N, endpoint=False)\n        function_values = f(x_nodes)\n        integral_approx = h * np.sum(function_values)\n        return integral_approx\n\n    # === 4. Define and Execute Test Cases ===\n    # The test cases are ordered as specified in the problem statement.\n    # Each tuple contains: (function, exact_integral_value, number_of_points_N)\n    test_cases = [\n        # f1: sin(x) + 0.5*cos(3x)\n        (f1, I1_exact, 1),\n        (f1, I1_exact, 8),\n        # f2: exp(sin(x))\n        (f2, I2_exact, 8),\n        (f2, I2_exact, 16),\n        (f2, I2_exact, 32),\n        (f2, I2_exact, 64),\n        (f2, I2_exact, 128),\n        # f3: |sin(x)|\n        (f3, I3_exact, 8),\n        (f3, I3_exact, 16),\n        (f3, I3_exact, 32),\n        (f3, I3_exact, 64),\n        (f3, I3_exact, 128),\n        # f4: 1 / (2 - cos(x))\n        (f4, I4_exact, 8),\n        (f4, I4_exact, 16),\n        (f4, I4_exact, 32),\n        (f4, I4_exact, 64),\n        (f4, I4_exact, 128),\n    ]\n\n    results = []\n    for func, exact_val, N in test_cases:\n        # Calculate the numerical integral\n        numerical_val = periodic_composite_trapezoidal(func, N)\n        # Compute the absolute error\n        error = np.abs(numerical_val - exact_val)\n        results.append(error)\n\n    # === 5. Format and Print Output ===\n    # Format each result in scientific notation with 12 digits after the decimal point\n    formatted_results = [f\"{res:.12e}\" for res in results]\n    \n    # Print the final output in the required single-line format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}