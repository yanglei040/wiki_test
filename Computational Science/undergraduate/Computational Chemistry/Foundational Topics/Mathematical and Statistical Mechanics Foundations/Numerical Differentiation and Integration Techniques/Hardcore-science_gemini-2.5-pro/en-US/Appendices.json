{
    "hands_on_practices": [
        {
            "introduction": "Understanding the accuracy of our numerical methods is as important as implementing them. This first exercise provides foundational practice in applying the composite trapezoidal rule, a cornerstone of numerical integration. By calculating the well-known error function, $\\text{erf}(z)$, and comparing our results to both the true value and a theoretical error bound, we can directly observe how the accuracy of an integral depends on the number of steps taken.",
            "id": "2459587",
            "problem": "Consider the error function $\\text{erf}(z)$ defined for real $z$ by\n$$\n\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{z} e^{-t^{2}} \\, dt.\n$$\nThis special function appears widely in computational chemistry, for example in Gaussian orbital integrals and diffusion models involving normal distributions. Let $N$ denote a positive integer specifying the number of equal subintervals used to partition the integration interval.\n\nTask: Write a complete program that, for each test case $(z,N)$ listed below, computes an approximation $\\widehat{\\text{erf}}(z;N)$ using the composite trapezoidal rule applied to the integral definition above, and then:\n1. Computes the absolute error\n$$\nE_{\\text{abs}}(z,N) = \\left| \\text{erf}(z) - \\widehat{\\text{erf}}(z;N) \\right|.\n$$\n2. Computes the rigorous composite-trapezoidal error bound for this problem derived from the second derivative of the integrand, namely\n$$\nB(z,N) = \\frac{2}{\\sqrt{\\pi}} \\cdot \\frac{|z|}{12} \\left(\\frac{|z|}{N}\\right)^{2} \\cdot \\max_{t \\in [\\min(0,z), \\max(0,z)]} \\left| \\frac{d^{2}}{dt^{2}} e^{-t^{2}} \\right|.\n$$\nYour program must use the exact analytic value of the maximum. The test suite is:\n- $(z,N) = (0, 1)$,\n- $(z,N) = (0.5, 10)$,\n- $(z,N) = (1.0, 2)$,\n- $(z,N) = (1.0, 50)$,\n- $(z,N) = (2.0, 200)$,\n- $(z,N) = (-1.0, 50)$,\n- $(z,N) = (3.0, 400)$.\n\nAngle units do not apply. No physical units are involved. All real numbers used in the output must be written in scientific notation with $12$ significant digits.\n\nFinal output format: Your program should produce a single line of output consisting of a single list where each element corresponds to one test case in the same order as listed above, and each element is a two-element list $[E_{\\text{abs}}(z,N), B(z,N)]$. The outer list and each inner list must be written without any whitespace and using commas as separators. For example, the required structure is of the form $[[x_{1},y_{1}],[x_{2},y_{2}],\\ldots]$ where each $x_{k}$ and $y_{k}$ is a float in scientific notation with $12$ significant digits.",
            "solution": "The problem is valid. It presents a clear, well-posed task in numerical analysis that is scientifically grounded and relevant to computational chemistry. The necessary formulas are either provided or are standard, and the required calculations are feasible. I will now provide the solution.\n\nThe task requires the computation of two quantities for several test cases $(z,N)$: the absolute error $E_{\\text{abs}}(z,N)$ of a numerical approximation to the error function $\\text{erf}(z)$, and the corresponding theoretical error bound $B(z,N)$.\n\nThe error function is defined as:\n$$\n\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{z} e^{-t^{2}} \\, dt\n$$\nThis is an odd function, meaning $\\text{erf}(-z) = -\\text{erf}(z)$. This property will be useful.\n\nFirst, we design the numerical approximation $\\widehat{\\text{erf}}(z;N)$ using the composite trapezoidal rule. The rule approximates an integral $\\int_{a}^{b} f(t) \\, dt$ using $N$ equal subintervals of width $h=(b-a)/N$ as:\n$$\n\\int_{a}^{b} f(t) \\, dt \\approx \\frac{h}{2} \\left( f(t_0) + 2\\sum_{k=1}^{N-1} f(t_k) + f(t_N) \\right)\n$$\nwhere $t_k = a+kh$. For our problem, the integrand is $f(t) = e^{-t^2}$.\n\nFor a given test case $(z,N)$:\nIf $z=0$, the integral is $0$, so $\\text{erf}(0) = 0$. The approximation is also trivially $0$, making the error $E_{\\text{abs}}(0,N)=0$.\nIf $z>0$, we set $a=0$ and $b=z$. The step size is $h=z/N$. The approximation of the integral $I(z) = \\int_{0}^{z} e^{-t^2} dt$ is:\n$$\n\\widehat{I}(z;N) = \\frac{z}{N} \\left( \\frac{e^{-0^2} + e^{-z^2}}{2} + \\sum_{k=1}^{N-1} e^{-(kz/N)^2} \\right)\n$$\nThe approximation for the error function is then $\\widehat{\\text{erf}}(z;N) = \\frac{2}{\\sqrt{\\pi}} \\widehat{I}(z;N)$.\nIf $z<0$, we use the odd symmetry. We calculate the approximation for the positive value $|z|$, and then negate the result:\n$$\n\\widehat{\\text{erf}}(z;N) = -\\widehat{\\text{erf}}(|z|;N)\n$$\nThis simplifies the implementation, as the trapezoidal rule is always applied over a non-negative interval $[0, |z|]$.\n\nSecond, we calculate the absolute error $E_{\\text{abs}}(z,N)$. This is defined as:\n$$\nE_{\\text{abs}}(z,N) = \\left| \\text{erf}(z) - \\widehat{\\text{erf}}(z;N) \\right|\n$$\nThe \"true\" value $\\text{erf}(z)$ is obtained using a high-precision implementation from the `scipy.special` library.\n\nThird, we evaluate the rigorous error bound $B(z,N)$. The problem provides the formula:\n$$\nB(z,N) = \\frac{2}{\\sqrt{\\pi}} \\cdot \\frac{|z|}{12} \\left(\\frac{|z|}{N}\\right)^{2} \\cdot \\max_{t \\in [\\min(0,z), \\max(0,z)]} \\left| \\frac{d^{2}}{dt^{2}} e^{-t^{2}} \\right|\n$$\nThis can be rewritten as $B(z,N) = \\frac{2|z|^3}{12\\sqrt{\\pi}N^2} M_2$, where $M_2$ is the maximum of the absolute value of the second derivative of the integrand, $f(t) = e^{-t^2}$, over the integration interval. The problem requires using the exact analytic value of this maximum. Let's find it.\nThe first derivative is $f'(t) = -2t e^{-t^2}$.\nThe second derivative is:\n$$\nf''(t) = \\frac{d}{dt}\\left(-2t e^{-t^2}\\right) = -2e^{-t^2} + (-2t)(-2t e^{-t^2}) = (4t^2 - 2)e^{-t^2}\n$$\nWe must find the maximum of $|f''(t)| = |(4t^2 - 2)e^{-t^2}|$ on the interval $[\\min(0,z), \\max(0,z)]$. Since $|f''(t)|$ is an even function, this is equivalent to finding its maximum on $[0, |z|]$.\nThe maximum of a function on a closed interval occurs at the interval's endpoints or at its internal critical points. Let us analyze $|f''(t)|$ for $t \\ge 0$.\nThe endpoints are $t=0$ and $t=|z|$.\nAt $t=0$, we have $|f''(0)| = |(0-2)e^0| = 2$.\nTo find critical points, we examine the third derivative, $f'''(t)$.\n$$\nf'''(t) = \\frac{d}{dt}\\left((4t^2 - 2)e^{-t^2}\\right) = (8t)e^{-t^2} + (4t^2 - 2)(-2t e^{-t^2}) = (8t - 8t^3 + 4t)e^{-t^2} = (12t - 8t^3)e^{-t^2} = 4t(3-2t^2)e^{-t^2}\n$$\nThe critical points where $f'''(t)=0$ are $t=0$ and $t=\\pm\\sqrt{3/2}$.\nThe function $|f''(t)|$ has a local maximum at $t=\\sqrt{3/2}\\approx 1.225$, with value $|f''(\\sqrt{3/2})| = |(4(3/2)-2)e^{-3/2}| = 4e^{-3/2} \\approx 0.892$. It has a local minimum (value $0$) where $f''(t)=0$, which is at $t=\\sqrt{1/2} \\approx 0.707$.\nThe function $|f''(t)|$ starts at a value of $2$ at $t=0$, decreases to $0$ at $t=\\sqrt{1/2}$, increases to a local maximum of $\\approx 0.892$ at $t=\\sqrt{3/2}$, and then monotonically decreases towards $0$ as $t \\to \\infty$.\nThe global maximum of $|f''(t)|$ for all $t \\ge 0$ occurs at $t=0$, and its value is $2$.\nSince the integration interval $[\\min(0,z), \\max(0,z)]$ for any $z$ always includes the point $t=0$, the maximum value of $|f''(t)|$ over this interval is always $M_2 = 2$.\nSubstituting this exact analytic value into the bound formula:\n$$\nB(z,N) = \\frac{2|z|^3}{12\\sqrt{\\pi}N^2} \\cdot 2 = \\frac{4|z|^3}{12\\sqrt{\\pi}N^2} = \\frac{|z|^3}{3\\sqrt{\\pi}N^2}\n$$\nFor $z=0$, this correctly gives $B=0$.\n\nThe implementation will loop through the test cases, apply these formulas, and format the results as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.special\n\ndef solve():\n    \"\"\"\n    Computes the absolute error and theoretical error bound for a composite\n    trapezoidal approximation of the error function erf(z).\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1),\n        (0.5, 10),\n        (1.0, 2),\n        (1.0, 50),\n        (2.0, 200),\n        (-1.0, 50),\n        (3.0, 400),\n    ]\n\n    # This will hold lists of [E_abs, B] for each test case\n    results_data = []\n\n    for z, N in test_cases:\n        # Trivial case z=0. The integral, approximation, error, and bound are all 0.\n        if z == 0.0:\n            e_abs = 0.0\n            bound = 0.0\n            results_data.append([e_abs, bound])\n            continue\n\n        # Use the property erf(-z) = -erf(z).\n        # The trapezoidal rule is always applied on the positive interval [0, |z|].\n        z_abs = abs(z)\n        \n        # 1. Compute the approximation using the composite trapezoidal rule.\n        #    numpy.trapz provides a concise and efficient implementation.\n        #    The integration nodes are from 0 to |z| with N subintervals.\n        t_nodes = np.linspace(0, z_abs, N + 1)\n        integrand_values = np.exp(-t_nodes**2)\n        integral_approx = np.trapz(integrand_values, t_nodes)\n        \n        # Apply the pre-factor and sign for the final erf approximation.\n        erf_approx = np.sign(z) * (2.0 / np.sqrt(np.pi)) * integral_approx\n\n        # 2. Compute the absolute error against the high-precision library function.\n        erf_true = scipy.special.erf(z)\n        e_abs = abs(erf_true - erf_approx)\n\n        # 3. Compute the rigorous error bound.\n        #    The generic formula is B = (2/sqrt(pi)) * (|z|/12) * (|z|/N)^2 * M2,\n        #    where M2 = max|f''(t)|.\n        #    The analytic maximum M2 for f(t)=exp(-t^2) is 2.\n        #    This simplifies the formula to B = |z|^3 / (3 * N^2 * sqrt(pi)).\n        bound = (z_abs**3) / (3.0 * np.sqrt(np.pi) * N**2)\n        \n        results_data.append([e_abs, bound])\n\n    # Format the final output string exactly as required by the problem statement:\n    # A list of lists, with no whitespace, and numbers in scientific notation\n    # with 12 significant digits.\n    formatted_pairs = []\n    for e, b in results_data:\n        e_str = f\"{e:.12e}\"\n        b_str = f\"{b:.12e}\"\n        formatted_pairs.append(f\"[{e_str},{b_str}]\")\n    \n    final_output_string = f\"[{','.join(formatted_pairs)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Numerical integration is not just for functions written on a page; it is a powerful tool for solving problems in the physical sciences. This practice demonstrates how to transform a problem from classical dynamics—the motion of an oscillator—into a definite integral that yields a key physical property, its period $T$. By numerically evaluating this integral for both harmonic and anharmonic potentials, we can explore fundamental concepts of physics, such as how the period's dependence on amplitude reveals the nature of the underlying forces.",
            "id": "2459635",
            "problem": "Consider a one-dimensional conservative oscillator of a point mass with unit mass $m=1$, moving in a potential energy function $U(x)$. The motion is governed by Newton’s second law $m\\,\\ddot{x}(t) = -\\dfrac{\\mathrm{d}U}{\\mathrm{d}x}(x(t))$. For any amplitude $A>0$, define the initial condition $x(0)=A$ and $\\dot{x}(0)=0$. The oscillation period $T(A)$ is the smallest positive time $T>0$ such that $x(T)=x(0)$ and $\\dot{x}(T)=\\dot{x}(0)$ with $x(t)<A$ for all $t \\in (0,T)$. All quantities in this problem are to be treated in reduced, dimensionless units; report all times in these units.\n\nYour task is to determine $T(A)$ numerically from first principles for the following family of potentials relevant to computational chemistry models of bonded vibrations:\n$$\nU(x) = \\tfrac{1}{2}\\,k\\,x^2 + \\lambda\\,x^4,\n$$\nwhere $k \\ge 0$ and $\\lambda \\ge 0$ are constants. You must not rely on closed-form solutions that may exist for special cases; instead, compute $T(A)$ by evaluating the appropriate definite integral implied by the conservation of energy and the definition of $T(A)$.\n\nTest Suite and required outputs (all results must be rounded to $8$ decimal places):\n\n1. Simple harmonic oscillator baseline variation. Let $k=1$ and $\\lambda=0$. For amplitudes $\\mathcal{A}=\\{\\,0.2,\\,1.0,\\,2.0\\,\\}$, compute $T(A)$ for each $A \\in \\mathcal{A}$. Report the single value\n$$\n\\max_{A \\in \\mathcal{A}} \\frac{\\lvert T(A)-T(0.2)\\rvert}{T(0.2)}.\n$$\n\n2. Simple harmonic oscillator absolute period. With $k=1$ and $\\lambda=0$, report $T(0.2)$.\n\n3. Anharmonic hardening (quartic perturbation). Let $k=1$ and $\\lambda=0.1$. Report the ratio\n$$\n\\frac{T(2.0)}{T(0.5)}.\n$$\n\n4. Weak anharmonic limit. Compare $k=1,\\lambda=0.001$ to the pure harmonic case $k=1,\\lambda=0$. Report the absolute relative difference at amplitude $A=0.5$:\n$$\n\\frac{\\lvert T(0.5;\\,k=1,\\lambda=0.001)-T(0.5;\\,k=1,\\lambda=0)\\rvert}{T(0.5;\\,k=1,\\lambda=0)}.\n$$\n\n5. Pure quartic oscillator scaling. Let $k=0$ and $\\lambda=1$. Report the ratio\n$$\n\\frac{T(2.0)}{T(1.0)}.\n$$\n\nFinal output format: Your program should produce a single line of output containing the results of items $1$ through $5$ in order, as a comma-separated list enclosed in square brackets, with each value rounded to $8$ decimal places, for example, [a,b,c,d,e].",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of classical mechanics, self-contained, and presents a well-posed set of numerical tasks. We shall proceed with the derivation of the required integral and its numerical evaluation.\n\nThe motion of a particle with mass $m$ in a one-dimensional conservative potential $U(x)$ is governed by the conservation of total mechanical energy $E$.\n$$\nE = K + U(x) = \\frac{1}{2}m\\dot{x}^2 + U(x)\n$$\nwhere $\\dot{x} = \\frac{\\mathrm{d}x}{\\mathrm{d}t}$. For the given problem, the mass is $m=1$. The initial conditions are specified as $x(0)=A$ and $\\dot{x}(0)=0$, where $A > 0$ is the amplitude of oscillation. The total energy $E$ is determined by these initial conditions:\n$$\nE = \\frac{1}{2}(1)(0)^2 + U(A) = U(A)\n$$\nThe potential energy function is given by $U(x) = \\frac{1}{2}kx^2 + \\lambda x^4$. Thus, the total energy is:\n$$\nE = \\frac{1}{2}kA^2 + \\lambda A^4\n$$\nFrom the conservation of energy, we can express the velocity $\\dot{x}$ as a function of position $x$:\n$$\n\\frac{1}{2}\\dot{x}^2 = E - U(x) \\implies \\dot{x} = \\frac{\\mathrm{d}x}{\\mathrm{d}t} = \\pm \\sqrt{2(E - U(x))}\n$$\nTo find the period $T(A)$, we can integrate over a quarter of the oscillation, from the turning point $x=A$ to the equilibrium position $x=0$. During this phase, the velocity is negative, so we choose the negative root. The time for this traversal is $T/4$.\n$$\n\\mathrm{d}t = -\\frac{\\mathrm{d}x}{\\sqrt{2(E - U(x))}}\n$$\n$$\n\\frac{T(A)}{4} = \\int_{A}^{0} \\frac{-\\mathrm{d}x}{\\sqrt{2(E - U(x))}} = \\int_{0}^{A} \\frac{\\mathrm{d}x}{\\sqrt{2(E - U(x))}}\n$$\nThe period $T(A)$ is four times this value:\n$$\nT(A) = 4 \\int_{0}^{A} \\frac{\\mathrm{d}x}{\\sqrt{2(U(A) - U(x))}}\n$$\nSubstituting the expressions for $U(A)$ and $U(x)$:\n$$\nU(A) - U(x) = \\left(\\frac{1}{2}kA^2 + \\lambda A^4\\right) - \\left(\\frac{1}{2}kx^2 + \\lambda x^4\\right) = \\frac{k}{2}(A^2 - x^2) + \\lambda(A^4 - x^4)\n$$\nFactoring the term $(A^2 - x^2)$, we get:\n$$\nU(A) - U(x) = (A^2 - x^2)\\left[\\frac{k}{2} + \\lambda(A^2 + x^2)\\right]\n$$\nThe integral for the period becomes:\n$$\nT(A) = 4 \\int_{0}^{A} \\frac{\\mathrm{d}x}{\\sqrt{2(A^2 - x^2)\\left[\\frac{k}{2} + \\lambda(A^2 + x^2)\\right]}} = 4 \\int_{0}^{A} \\frac{\\mathrm{d}x}{\\sqrt{(A^2 - x^2)(k + 2\\lambda(A^2 + x^2))}}\n$$\nThis is an improper integral due to the singularity at the upper limit $x=A$, where the denominator becomes zero. To facilitate numerical evaluation, we perform a change of variables. Let $x = A\\sin\\theta$. Then $\\mathrm{d}x = A\\cos\\theta\\,\\mathrm{d}\\theta$. The integration limits change from $x \\in [0, A]$ to $\\theta \\in [0, \\pi/2]$. The terms in the denominator transform as follows:\n$$\nA^2 - x^2 = A^2 - A^2\\sin^2\\theta = A^2\\cos^2\\theta\n$$\n$$\nk + 2\\lambda(A^2 + x^2) = k + 2\\lambda(A^2 + A^2\\sin^2\\theta) = k + 2\\lambda A^2(1 + \\sin^2\\theta)\n$$\nSubstituting these into the integral for $T(A)$:\n$$\nT(A) = 4 \\int_{0}^{\\pi/2} \\frac{A\\cos\\theta\\,\\mathrm{d}\\theta}{\\sqrt{A^2\\cos^2\\theta \\left[k + 2\\lambda A^2(1 + \\sin^2\\theta)\\right]}}\n$$\n$$\nT(A) = 4 \\int_{0}^{\\pi/2} \\frac{A\\cos\\theta\\,\\mathrm{d}\\theta}{A\\cos\\theta \\sqrt{k + 2\\lambda A^2(1 + \\sin^2\\theta)}}\n$$\nThis simplifies to a well-behaved definite integral which is suitable for standard numerical quadrature methods:\n$$\nT(A) = 4 \\int_{0}^{\\pi/2} \\frac{\\mathrm{d}\\theta}{\\sqrt{k + 2\\lambda A^2(1 + \\sin^2\\theta)}}\n$$\nWe will use this final expression to compute the required values.\n\nAnalysis of the test cases:\n1.  For the simple harmonic oscillator, $k=1$ and $\\lambda=0$. The integrand becomes $1/\\sqrt{1+0} = 1$. The integral evaluates to $\\int_{0}^{\\pi/2} 1\\,\\mathrm{d}\\theta = \\pi/2$. The period is $T(A) = 4(\\pi/2) = 2\\pi$, which is independent of amplitude $A$. Therefore, for any $A \\in \\mathcal{A}$, $T(A) = T(0.2)$, and the quantity $\\max_{A \\in \\mathcal{A}} \\frac{\\lvert T(A)-T(0.2)\\rvert}{T(0.2)}$ is identically zero. Numerical computation should yield a value very close to $0$.\n\n2.  For $k=1, \\lambda=0$, $T(0.2) = 2\\pi \\approx 6.28318531$.\n\n3.  For the anharmonic oscillator with $k=1, \\lambda=0.1$, the period depends on amplitude. The positive $\\lambda$ term in the denominator means the integrand's value decreases as $A$ increases, shortening the period. This is a hardening potential. We expect $T(2.0) < T(0.5)$.\n\n4.  For a weak anharmonic perturbation ($\\lambda=0.001$), the period will be slightly shorter than the harmonic period $2\\pi$. The relative difference will be a small positive number.\n\n5.  For the pure quartic oscillator, $k=0$ and $\\lambda=1$. The period expression becomes:\n    $$\n    T(A) = 4 \\int_{0}^{\\pi/2} \\frac{\\mathrm{d}\\theta}{\\sqrt{2A^2(1 + \\sin^2\\theta)}} = \\frac{4}{A\\sqrt{2}} \\int_{0}^{\\pi/2} \\frac{\\mathrm{d}\\theta}{\\sqrt{1 + \\sin^2\\theta}}\n    $$\n    The period $T(A)$ is inversely proportional to the amplitude $A$, i.e., $T(A) \\propto 1/A$. The integral is a constant. Therefore, the ratio $\\frac{T(2.0)}{T(1.0)} = \\frac{1/2.0}{1/1.0} = 0.5$.\n\nThese theoretical considerations will be confirmed by the numerical implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the five numerical tasks related to the period of an anharmonic oscillator.\n    \"\"\"\n\n    def calculate_T(A, k, lam):\n        \"\"\"\n        Calculates the period T of an oscillator for a given amplitude A and\n        potential parameters k and lambda.\n\n        The calculation is based on the definite integral derived from energy conservation:\n        T(A) = 4 * integral from 0 to pi/2 of d(theta) / sqrt(k + 2*lam*A^2*(1+sin(theta)^2)).\n        \"\"\"\n        # A check for the non-physical case of zero potential.\n        if k == 0 and lam == 0:\n            return np.inf\n\n        # Define the integrand function f(theta).\n        # This form is regular and suitable for numerical quadrature.\n        integrand = lambda theta: 1.0 / np.sqrt(k + 2 * lam * A**2 * (1 + np.sin(theta)**2))\n\n        # Use scipy.integrate.quad to compute the definite integral.\n        integral_val, _ = quad(integrand, 0, np.pi / 2, epsabs=1e-12, epsrel=1e-12)\n\n        # The full period is 4 times the quarter-period integral.\n        return 4 * integral_val\n\n    # --- Test Case 1: Simple harmonic oscillator baseline variation ---\n    k1, lam1 = 1.0, 0.0\n    A_set_1 = [0.2, 1.0, 2.0]\n    T_vals_case1 = [calculate_T(A, k1, lam1) for A in A_set_1]\n    T_base = T_vals_case1[0]\n    max_rel_diff = max(abs(T - T_base) / T_base for T in T_vals_case1)\n    result1 = max_rel_diff\n\n    # --- Test Case 2: Simple harmonic oscillator absolute period ---\n    # This value was already calculated as the base period for Case 1.\n    result2 = T_base\n\n    # --- Test Case 3: Anharmonic hardening (quartic perturbation) ---\n    k3, lam3 = 1.0, 0.1\n    T_2_0_case3 = calculate_T(2.0, k3, lam3)\n    T_0_5_case3 = calculate_T(0.5, k3, lam3)\n    result3 = T_2_0_case3 / T_0_5_case3\n\n    # --- Test Case 4: Weak anharmonic limit ---\n    k4_anharm, lam4_anharm = 1.0, 0.001\n    k4_harm, lam4_harm = 1.0, 0.0\n    A4 = 0.5\n    T_anharm_case4 = calculate_T(A4, k4_anharm, lam4_anharm)\n    T_harm_case4 = calculate_T(A4, k4_harm, lam4_harm)  # This is analytically 2*pi\n    result4 = abs(T_anharm_case4 - T_harm_case4) / T_harm_case4\n\n    # --- Test Case 5: Pure quartic oscillator scaling ---\n    k5, lam5 = 0.0, 1.0\n    T_2_0_case5 = calculate_T(2.0, k5, lam5)\n    T_1_0_case5 = calculate_T(1.0, k5, lam5)\n    result5 = T_2_0_case5 / T_1_0_case5\n\n    # --- Aggregate and Format Final Output ---\n    results = [result1, result2, result3, result4, result5]\n\n    # Format the results to 8 decimal places and join into a single string.\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function to produce the final output.\nsolve()\n```"
        },
        {
            "introduction": "Computational chemistry often involves extracting key physical parameters from discrete data sets, whether from simulation or experiment. This exercise simulates a common task in biophysical chemistry: determining a protein's $pK_a$ value from pH-dependent binding energy data. You will use numerical differentiation to locate the point of maximum change and numerical integration to verify the total energy change, providing a complete workflow for data-driven analysis on potentially non-uniform grids.",
            "id": "2459600",
            "problem": "In computational chemistry, pH-dependent binding arises from protonation equilibria of titratable sites in a protein. Consider a ligand whose binding free energy to a protein, denoted by $E(pH)$ and measured in kilojoules per mole, varies smoothly with $pH$ due to a single acid-base transition characterized by an acid dissociation constant with $pK_a$ in pH units. By thermodynamic and acid-base principles, $E(pH)$ is a smooth, monotonic sigmoid-like function when a single site dominates the transition. The inflection point of such a monotonic sigmoid occurs near the underlying $pK_a$, so the magnitude of the slope $\\left|\\dfrac{dE}{dpH}\\right|$ typically reaches a maximum near $pH \\approx pK_a$. The derivative and integral are defined from first principles as limits of difference quotients and Riemann sums, respectively. The composite trapezoidal rule is a standard, well-tested numerical quadrature that approximates the definite integral by summing areas of trapezoids under the curve. These ideas enable a fully numerical strategy to estimate $pK_a$ from discrete $E(pH)$ data, even on a nonuniform $pH$ grid.\n\nTask. Write a complete program that, given several discrete data sets $\\{(pH_i, E_i)\\}_{i=0}^{N-1}$, performs the following for each data set without using any closed-form model fitting:\n- Numerically approximate the derivative $\\dfrac{dE}{dpH}$ at the given grid points using a second-order-accurate finite-difference scheme based on local quadratic interpolation that works on nonuniform grids. Use one-sided, second-order-accurate, three-point formulas at the endpoints and a three-point formula at interior points.\n- Estimate the protein’s $pK_a$ as the $pH$ value at which $\\left|\\dfrac{dE}{dpH}\\right|$ attains its maximum over the provided grid.\n- Numerically integrate $\\dfrac{dE}{dpH}$ over the provided $pH$ range using the composite trapezoidal rule on the given grid to estimate the net change in binding free energy across the range. Report this estimated change in kilojoules per mole.\n\nUnits and rounding. Binding free energies $E$ are in kilojoules per mole. Report the $pK_a$ in pH units, rounded to two decimal places. Report the integrated energy change in kilojoules per mole, rounded to two decimal places.\n\nAngle unit. If any trigonometric functions are used internally (for deterministic noise generation in the test data below), interpret angles in radians.\n\nInput format for this problem. There is no external input. Your program must internally construct and use the test-suite data sets specified below.\n\nTest suite. To make the task self-contained and testable, use the following three synthetic but physically plausible data sets. In each case, the “measured” binding energy is constructed as\n$$\nE(pH) \\;=\\; E_{\\mathrm{acid}} \\;+\\; \\left(E_{\\mathrm{base}} - E_{\\mathrm{acid}}\\right)\\,\\alpha(pH)\\;+\\; \\eta(pH),\n$$\nwhere\n$$\n\\alpha(pH) \\;=\\; \\dfrac{1}{1 + 10^{\\,pK_a - pH}}\n$$\nis the deprotonated fraction of a monoprotic site, and $\\eta(pH)$ is a small, deterministic baseline-correlated term that mimics experimental noise. There is no randomness; $\\eta(pH)$ is specified explicitly. Use the following three cases:\n\n- Case A (uniform grid, fine spacing, low noise): $E_{\\mathrm{acid}} = -30.00$ kilojoules per mole, $E_{\\mathrm{base}} = -10.00$ kilojoules per mole, $pK_a = 6.50$, $pH$ grid from $2.00$ to $12.00$ inclusive with step $0.25$ (uniform), and $\\eta(pH) = 0.05 \\,\\sin(0.90\\, pH)$.\n- Case B (nonuniform grid, moderate noise): $E_{\\mathrm{acid}} = -25.00$ kilojoules per mole, $E_{\\mathrm{base}} = -15.00$ kilojoules per mole, $pK_a = 4.20$, $pH$ grid given explicitly by the list $[2.00,\\; 2.50,\\; 3.00,\\; 3.50,\\; 4.00,\\; 4.30,\\; 4.60,\\; 5.30,\\; 6.20,\\; 7.50,\\; 9.00,\\; 12.00]$, and $\\eta(pH) = 0.08 \\,\\cos(1.30\\, pH)$.\n- Case C (uniform grid, coarse spacing, very low noise): $E_{\\mathrm{acid}} = -32.00$ kilojoules per mole, $E_{\\mathrm{base}} = -8.00$ kilojoules per mole, $pK_a = 9.00$, $pH$ grid from $6.00$ to $12.00$ inclusive with step $1.00$ (uniform), and $\\eta(pH) = 0.03 \\,\\sin(1.10\\, pH + 0.30)$.\n\nWhat to compute for each case:\n- The estimated $pK_a$ value in pH units, rounded to two decimal places, obtained by the $pH$ location of the maximum of $\\left|\\dfrac{dE}{dpH}\\right|$ on the provided grid.\n- The integrated binding-energy change over the provided $pH$ range, computed as $\\displaystyle \\int_{pH_{\\min}}^{pH_{\\max}} \\dfrac{dE}{dpH}\\, dpH$ by the composite trapezoidal rule on the given grid, expressed in kilojoules per mole and rounded to two decimal places.\n\nFinal output format. Your program should produce a single line of output containing the results for the three cases as a list of lists. Each inner list contains two floats in the order $[pK_a^{\\mathrm{est}}, \\Delta E^{\\mathrm{int}}]$, where $pK_a^{\\mathrm{est}}$ is the estimated $pK_a$ and $\\Delta E^{\\mathrm{int}}$ is the integrated energy change. The entire output must be printed as a single line of the form\n$[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$\nwith no spaces, where each $a_i$ and $b_i$ are decimal numbers rounded as specified above. For example, an output string like $[[6.50,19.95],[4.30,10.02],[9.00,24.01]]$ follows the required format.",
            "solution": "The solution is constructed based on a sequence of established principles, beginning with the physical model and proceeding to the required numerical algorithms.\n\n1.  **Physical Model and Data Generation**\n    The binding free energy, $E(pH)$, is given as a function of $pH$. For a single titratable site, this dependency is modeled by the equation:\n    $$\n    E(pH) = E_{\\mathrm{acid}} + \\left(E_{\\mathrm{base}} - E_{\\mathrm{acid}}\\right)\\,\\alpha(pH) + \\eta(pH)\n    $$\n    Here, $E_{\\mathrm{acid}}$ and $E_{\\mathrm{base}}$ are the binding free energies when the titratable site is fully protonated and deprotonated, respectively. The term $\\eta(pH)$ represents a small experimental noise or baseline artifact. The function $\\alpha(pH)$ is the fraction of the site in the deprotonated (base) form, given by the standard Henderson-Hasselbalch-derived sigmoid:\n    $$\n    \\alpha(pH) = \\dfrac{1}{1 + 10^{\\,pK_a - pH}}\n    $$\n    For each test case, this model is used to generate a discrete data set $\\{ (pH_i, E_i) \\}_{i=0}^{N-1}$, which serves as the input for the subsequent numerical analysis.\n\n2.  **Numerical Differentiation**\n    The core of the $pK_a$ estimation lies in computing the derivative, $\\frac{dE}{dpH}$, from the discrete data. The problem specifies a second-order accurate finite-difference scheme that is valid for non-uniform grids, as is common with experimental data. Such schemes are derived by locally fitting a quadratic polynomial, $P(x)$, to three adjacent data points and then analytically differentiating the polynomial. Let the data points be $(x_i, f_i)$, representing $(pH_i, E_i)$, and let $h_i = x_{i+1} - x_i$ be the step size, which may vary with $i$. The formulas for the derivative $f'(x_i)$ are as follows:\n\n    -   **Interior Points ($i = 1, \\dots, N-2$):** A central-difference formula is used, based on the points $(x_{i-1}, f_{i-1})$, $(x_i, f_i)$, and $(x_{i+1}, f_{i+1})$. With $h_{i-1} = x_i - x_{i-1}$ and $h_i = x_{i+1} - x_i$, the derivative is:\n        $$\n        f'(x_i) \\approx f_{i-1} \\frac{-h_i}{h_{i-1}(h_{i-1}+h_i)} + f_i \\frac{h_i-h_{i-1}}{h_{i-1}h_i} + f_{i+1} \\frac{h_{i-1}}{h_i(h_{i-1}+h_i)}\n        $$\n\n    -   **Left Endpoint ($i=0$):** A one-sided, forward-difference formula is used, based on the points $(x_0, f_0)$, $(x_1, f_1)$, and $(x_2, f_2)$. With $h_0 = x_1 - x_0$ and $h_1 = x_2 - x_1$, the derivative is:\n        $$\n        f'(x_0) \\approx f_0 \\frac{-(2h_0+h_1)}{h_0(h_0+h_1)} + f_1 \\frac{h_0+h_1}{h_0 h_1} - f_2 \\frac{h_0}{h_1(h_0+h_1)}\n        $$\n\n    -   **Right Endpoint ($i=N-1$):** A one-sided, backward-difference formula is used, based on the points $(x_{N-3}, f_{N-3})$, $(x_{N-2}, f_{N-2})$, and $(x_{N-1}, f_{N-1})$. With $h_{N-3} = x_{N-2} - x_{N-3}$ and $h_{N-2} = x_{N-1} - x_{N-2}$, the derivative is:\n        $$\n        f'(x_{N-1}) \\approx f_{N-3}\\frac{h_{N-2}}{h_{N-3}(h_{N-3}+h_{N-2})} - f_{N-2}\\frac{h_{N-3}+h_{N-2}}{h_{N-3}h_{N-2}} + f_{N-1}\\frac{h_{N-3}+2h_{N-2}}{h_{N-2}(h_{N-3}+h_{N-2})}\n        $$\n    These formulas provide a complete vector of derivative values, $(\\frac{dE}{dpH})_i$, for the entire grid.\n\n3.  **Estimation of $pK_a$**\n    The $pK_a$ of the titratable group corresponds to the inflection point of the sigmoid $E(pH)$ curve. At this point, the steepness of the curve is maximal. Therefore, the estimated $pK_a$ is identified as the $pH$ value on the grid where the magnitude of the numerically computed derivative, $\\left|\\frac{dE}{dpH}\\right|$, reaches its maximum.\n    $$\n    pK_a^{\\mathrm{est}} = pH_k \\quad \\text{where} \\quad k = \\underset{i \\in \\{0, \\dots, N-1\\}}{\\arg\\max} \\left| \\left( \\frac{dE}{dpH} \\right)_i \\right|\n    $$\n\n4.  **Numerical Integration**\n    The net change in binding free energy across the measured $pH$ range, $\\Delta E^{\\mathrm{int}}$, is computed by integrating the numerical derivative $\\frac{dE}{dpH}$. The problem mandates the use of the composite trapezoidal rule. For a function $g(x)$ sampled at points $(x_i, g_i)$, this rule approximates the definite integral by summing the areas of the trapezoids formed by adjacent points:\n    $$\n    \\int_{x_0}^{x_{N-1}} g(x) \\, dx \\approx \\sum_{i=0}^{N-2} \\frac{g_i + g_{i+1}}{2} (x_{i+1} - x_i)\n    $$\n    By the Fundamental Theorem of Calculus, this integrated value should approximate the total change in the function, $E(pH_{N-1}) - E(pH_0)$, with discrepancies arising from the numerical errors in both the differentiation and integration steps.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerical_derivative(x, y):\n    \"\"\"\n    Computes the derivative of y with respect to x on a potentially\n    non-uniform grid using second-order accurate finite differences.\n    \"\"\"\n    n = len(x)\n    if n < 3:\n        raise ValueError(\"At least 3 points are required for second-order differences.\")\n    \n    dydx = np.zeros(n)\n\n    # First point: second-order forward difference\n    h0 = x[1] - x[0]\n    h1 = x[2] - x[1]\n    if h0 <= 0 or h1 <= 0:\n        raise ValueError(\"Grid points must be strictly increasing.\")\n    \n    c0 = -(2 * h0 + h1) / (h0 * (h0 + h1))\n    c1 = (h0 + h1) / (h0 * h1)\n    c2 = -h0 / (h1 * (h0 + h1))\n    dydx[0] = c0 * y[0] + c1 * y[1] + c2 * y[2]\n\n    # Interior points: second-order central difference\n    for i in range(1, n - 1):\n        h_prev = x[i] - x[i-1]\n        h_next = x[i+1] - x[i]\n        if h_prev <= 0 or h_next <= 0:\n            raise ValueError(\"Grid points must be strictly increasing.\")\n        \n        c_prev = -h_next / (h_prev * (h_prev + h_next))\n        c_curr = (h_next - h_prev) / (h_prev * h_next)\n        c_next = h_prev / (h_next * (h_prev + h_next))\n        dydx[i] = c_prev * y[i-1] + c_curr * y[i] + c_next * y[i+1]\n\n    # Last point: second-order backward difference\n    h_n_minus_3 = x[n-2] - x[n-3]\n    h_n_minus_2 = x[n-1] - x[n-2]\n    if h_n_minus_3 <= 0 or h_n_minus_2 <= 0:\n        raise ValueError(\"Grid points must be strictly increasing.\")\n    \n    c_n_minus_3 = h_n_minus_2 / (h_n_minus_3 * (h_n_minus_3 + h_n_minus_2))\n    c_n_minus_2 = -(h_n_minus_3 + h_n_minus_2) / (h_n_minus_3 * h_n_minus_2)\n    c_n_minus_1 = (h_n_minus_3 + 2 * h_n_minus_2) / (h_n_minus_2 * (h_n_minus_3 + h_n_minus_2))\n    dydx[n-1] = c_n_minus_3 * y[n-3] + c_n_minus_2 * y[n-2] + c_n_minus_1 * y[n-1]\n\n    return dydx\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            'E_acid': -30.00, 'E_base': -10.00, 'pKa': 6.50,\n            'pH_grid': np.arange(2.00, 12.00 + 1e-9, 0.25),\n            'eta': lambda ph: 0.05 * np.sin(0.90 * ph)\n        },\n        # Case B\n        {\n            'E_acid': -25.00, 'E_base': -15.00, 'pKa': 4.20,\n            'pH_grid': np.array([2.00, 2.50, 3.00, 3.50, 4.00, 4.30, 4.60, 5.30, 6.20, 7.50, 9.00, 12.00]),\n            'eta': lambda ph: 0.08 * np.cos(1.30 * ph)\n        },\n        # Case C\n        {\n            'E_acid': -32.00, 'E_base': -8.00, 'pKa': 9.00,\n            'pH_grid': np.arange(6.00, 12.00 + 1e-9, 1.00),\n            'eta': lambda ph: 0.03 * np.sin(1.10 * ph + 0.30)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Generate the discrete E(pH) data set\n        E_acid, E_base, pKa_true = case['E_acid'], case['E_base'], case['pKa']\n        pH_grid = case['pH_grid']\n        eta_func = case['eta']\n\n        alpha = 1.0 / (1.0 + 10**(pKa_true - pH_grid))\n        E_values = E_acid + (E_base - E_acid) * alpha + eta_func(pH_grid)\n\n        # Step 2: Numerically approximate the derivative dE/dpH\n        dEdpH = numerical_derivative(pH_grid, E_values)\n\n        # Step 3: Estimate pKa from the maximum of |dE/dpH|\n        abs_dEdpH = np.abs(dEdpH)\n        max_idx = np.argmax(abs_dEdpH)\n        pKa_est = pH_grid[max_idx]\n\n        # Step 4: Numerically integrate dE/dpH using trapezoidal rule\n        delta_E_int = np.trapz(dEdpH, pH_grid)\n        \n        # Step 5: Store the rounded results\n        results.append([pKa_est, delta_E_int])\n\n    # Final print statement in the exact required format.\n    # Format each result [pKa, dE] with 2 decimal places.\n    inner_parts = [f\"[{res[0]:.2f},{res[1]:.2f}]\" for res in results]\n    final_output_string = f\"[{','.join(inner_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}