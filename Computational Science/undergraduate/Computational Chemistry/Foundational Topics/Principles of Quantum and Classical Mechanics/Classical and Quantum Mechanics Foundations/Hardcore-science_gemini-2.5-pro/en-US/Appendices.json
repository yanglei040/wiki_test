{
    "hands_on_practices": [
        {
            "introduction": "In molecular dynamics, we simulate the evolution of a system by integrating Newton's equations of motion step by step. The choice of integration algorithm is critical, as seemingly small errors can accumulate into large, unphysical deviations over long timescales. This exercise () provides a vivid demonstration of this principle by comparing a simple but flawed integrator with a more robust, \"symplectic\" method, revealing why the latter is essential for reliable simulations of physical systems.",
            "id": "2452284",
            "problem": "Consider the planar Keplerian two-body problem in dimensionless units with gravitational parameter $\\mu$ and particle mass $m$ both set to $1$. Let the position be $\\mathbf{r}(t) \\in \\mathbb{R}^2$ and the velocity be $\\mathbf{v}(t) \\in \\mathbb{R}^2$. The force is central and given by $\\mathbf{F}(\\mathbf{r}) = -\\mu \\, \\mathbf{r}/\\lVert \\mathbf{r} \\rVert^{3}$, so that the acceleration is $\\mathbf{a}(\\mathbf{r}) = \\mathbf{F}(\\mathbf{r}) / m = - \\mathbf{r}/\\lVert \\mathbf{r} \\rVert^{3}$. The Hamiltonian (total energy) is\n$$\nH(\\mathbf{r},\\mathbf{v}) \\;=\\; \\frac{1}{2}\\,\\lVert \\mathbf{v} \\rVert^2 \\;-\\; \\frac{1}{\\lVert \\mathbf{r} \\rVert}.\n$$\nYou will compare the long-time energy behavior of two discrete-time update maps applied to this system:\n\n- Method A (Forward Euler, a non-symplectic map):\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n,\\qquad\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\Delta t \\,\\mathbf{a}(\\mathbf{r}_n).\n$$\n\n- Method B (Velocity Verlet, a symplectic map):\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t^2\\,\\mathbf{a}(\\mathbf{r}_n),\\qquad\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t \\,\\big(\\mathbf{a}(\\mathbf{r}_n)+\\mathbf{a}(\\mathbf{r}_{n+1})\\big).\n$$\n\nInitialize each test by selecting an ellipse with semi-major axis $a=1$ and eccentricity $e \\in (0,1)$. Place the particle at periapsis on the $x$-axis with\n$$\n\\mathbf{r}_0 \\;=\\; \\big(a(1-e),\\,0\\big),\\qquad\n\\mathbf{v}_0 \\;=\\; \\big(0,\\,\\sqrt{\\mu\\,\\tfrac{1+e}{a(1-e)}}\\big),\n$$\nand take $\\mu=1$ and $a=1$. The exact orbital period is $T = 2\\pi$. For a given time step $\\Delta t$, evolve the system for $N = \\left\\lfloor \\dfrac{M\\,T}{\\Delta t} \\right\\rfloor$ steps, where $M$ is the prescribed number of orbital periods to simulate. At each step $n$, compute the energy\n$$\nE_n \\;=\\; \\frac{1}{2}\\,\\lVert \\mathbf{v}_n \\rVert^2 \\;-\\; \\frac{1}{\\lVert \\mathbf{r}_n \\rVert},\n$$\nand define the maximum relative energy deviation over the simulation as\n$$\n\\delta_{\\max} \\;=\\; \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{\\lvert E_0 \\rvert}.\n$$\nReport $\\delta_{\\max}$ separately for Method A and Method B. The quantity $\\delta_{\\max}$ is dimensionless and must be reported as a floating-point number.\n\nTest Suite:\n- Case $1$: $e = 0.2$, $\\Delta t = 0.02$, $M = 200$.\n- Case $2$: $e = 0.6$, $\\Delta t = 0.02$, $M = 200$.\n- Case $3$: $e = 0.2$, $\\Delta t = 0.05$, $M = 100$.\n\nYour program must compute, for each case, the pair $\\big(\\delta_{\\max}^{\\mathrm{A}}, \\delta_{\\max}^{\\mathrm{B}}\\big)$ corresponding to Method A and Method B, respectively. The final output format must be a single line containing a comma-separated list with all six floating-point results in the strict order\n$$\n\\big[\\delta_{\\max}^{\\mathrm{A}}(1),\\;\\delta_{\\max}^{\\mathrm{B}}(1),\\;\\delta_{\\max}^{\\mathrm{A}}(2),\\;\\delta_{\\max}^{\\mathrm{B}}(2),\\;\\delta_{\\max}^{\\mathrm{A}}(3),\\;\\delta_{\\max}^{\\mathrm{B}}(3)\\big].\n$$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $\\big[0.1,0.2,0.3,0.4,0.5,0.6\\big]$). All quantities are dimensionless, and no angles need to be reported. The answers for each test case must be floating-point numbers. Do not read any input; use exactly the test suite specified above inside your program.",
            "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to proceed with a solution. The problem concerns a fundamental topic in computational physics: the numerical integration of ordinary differential equations for a Hamiltonian system, specifically the Kepler problem. The goal is to compare the long-term energy conservation of a non-symplectic integrator (Forward Euler) against a symplectic integrator (Velocity Verlet).\n\nThe system under consideration is the planar two-body problem governed by the Hamiltonian\n$$\nH(\\mathbf{r},\\mathbf{v}) \\;=\\; \\frac{1}{2}\\,m\\lVert \\mathbf{v} \\rVert^2 \\;-\\; \\frac{\\mu}{\\lVert \\mathbf{r} \\rVert}.\n$$\nWith the given dimensionless units, the gravitational parameter $\\mu$ and mass $m$ are both set to $1$. The equations of motion are\n$$\n\\dot{\\mathbf{r}} = \\mathbf{v}, \\qquad \\dot{\\mathbf{v}} = \\mathbf{a}(\\mathbf{r}) = -\\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}.\n$$\nThis is a conservative system, meaning the total energy $E = H(\\mathbf{r}, \\mathbf{v})$ is a constant of motion for the exact, continuous-time solution. Any deviation in energy observed in a numerical simulation is an artifact of the integration algorithm. The quantity $\\delta_{\\max}$ is a measure of the integrator's quality with respect to energy conservation.\n\nThe initial conditions are set for an elliptical orbit with semi-major axis $a=1$. The theoretical energy for such an orbit is constant and given by $E = -\\frac{\\mu}{2a}$. With $\\mu=1$ and $a=1$, the initial energy must be $E_0 = -0.5$. The problem provides initial conditions at periapsis, which correctly correspond to this energy value.\n\nWe will now analyze the two numerical methods.\n\nMethod A: Forward Euler\nThe update rules are:\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n \\\\\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\Delta t \\,\\mathbf{a}(\\mathbf{r}_n)\n$$\nThis is an explicit, first-order method. It is not symplectic. For a Hamiltonian system, non-symplectic methods generally fail to conserve energy, even approximately, over long time scales. For oscillatory systems like the Kepler problem, the Forward Euler method typically introduces a systematic drift in energy. The numerical energy $E_n$ will secularly increase, causing the simulated orbit to deviate from the true elliptical path and spiral outwards. The maximum energy deviation $\\delta_{\\max}^{\\mathrm{A}}$ is therefore expected to grow with the total number of integration steps $N$, and can become substantial.\n\nMethod B: Velocity Verlet\nThe update rules are:\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t^2\\,\\mathbf{a}(\\mathbf{r}_n) \\\\\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t \\,\\big(\\mathbf{a}(\\mathbf{r}_n)+\\mathbf{a}(\\mathbf{r}_{n+1})\\big)\n$$\nThis is a second-order, time-reversible, and symplectic integrator. Symplectic integrators have a crucial property when applied to Hamiltonian systems: they do not conserve the exact Hamiltonian $H$, but they do exactly conserve a nearby \"shadow\" Hamiltonian, $H_{\\Delta t}$, which differs from $H$ by terms of order $\\Delta t^2$ (for a second-order method). As a consequence, the computed energy $E_n$ will not drift secularly but will instead exhibit bounded oscillations around its initial value $E_0$. The amplitude of these oscillations depends on $\\Delta t$, but the error does not accumulate over time. Therefore, we expect the maximum energy deviation $\\delta_{\\max}^{\\mathrm{B}}$ to be significantly smaller than $\\delta_{\\max}^{\\mathrm{A}}$ and to remain stable over long simulation times.\n\nThe algorithm to solve the problem is as follows:\n$1$. For each test case, specified by eccentricity $e$, time step $\\Delta t$, and number of orbits $M$:\n$2$. Calculate the initial conditions. The position is $\\mathbf{r}_0 = (1-e, 0)$ and velocity is $\\mathbf{v}_0 = (0, \\sqrt{(1+e)/(1-e)})$.\n$3$. Calculate the initial energy $E_0 = \\frac{1}{2}\\lVert \\mathbf{v}_0 \\rVert^2 - 1/\\lVert \\mathbf{r}_0 \\rVert$, which should be exactly $-0.5$.\n$4$. Calculate the total number of steps, $N = \\lfloor 2\\pi M / \\Delta t \\rfloor$.\n$5$. For each method (A and B), perform a loop from $n=0$ to $N-1$:\n    a. At each step, update the position $\\mathbf{r}_n$ and velocity $\\mathbf{v}_n$ to $\\mathbf{r}_{n+1}$ and $\\mathbf{v}_{n+1}$ using the respective integration formulas. The acceleration is $\\mathbf{a}(\\mathbf{r}) = -\\mathbf{r} / \\lVert \\mathbf{r} \\rVert^3$.\n    b. Compute the energy $E_{n+1}$ using the new state vectors.\n    c. Compute the relative energy deviation $|E_{n+1} - E_0|/|E_0|$.\n    d. Keep track of the maximum relative deviation found throughout the simulation.\n$6$. After the loop completes, the final maximum relative deviation $\\delta_{\\max}$ is the result for that method and test case.\n$7$. Collect the $6$ results and format them as required.\n\nThis procedure will be implemented in Python using the `numpy` library for efficient vector operations. The expected outcome is a clear demonstration of the superiority of the symplectic Velocity Verlet integrator for long-term simulations of Hamiltonian systems.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Kepler problem for given test cases using Forward Euler and Velocity Verlet methods,\n    and computes the maximum relative energy deviation for each.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (e, dt, M)\n        (0.2, 0.02, 200),\n        (0.6, 0.02, 200),\n        (0.2, 0.05, 100),\n    ]\n\n    results = []\n    for e, dt, M in test_cases:\n        # Run simulation for Method A (Forward Euler)\n        delta_max_A = run_simulation(e, dt, M, method='euler')\n        results.append(delta_max_A)\n\n        # Run simulation for Method B (Velocity Verlet)\n        delta_max_B = run_simulation(e, dt, M, method='verlet')\n        results.append(delta_max_B)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(e, dt, M, method):\n    \"\"\"\n    Performs a single simulation run for a given method and parameters.\n\n    Args:\n        e (float): Eccentricity of the orbit.\n        dt (float): Time step for the integration.\n        M (int): Number of orbital periods to simulate.\n        method (str): Integration method, either 'euler' or 'verlet'.\n\n    Returns:\n        float: The maximum relative energy deviation over the simulation.\n    \"\"\"\n    # System parameters (dimensionless)\n    mu = 1.0\n    a = 1.0\n    \n    # Initial conditions at periapsis\n    r = np.array([a * (1.0 - e), 0.0])\n    v = np.array([0.0, np.sqrt(mu * (1.0 + e) / (a * (1.0 - e)))])\n\n    def acceleration(pos):\n        \"\"\"Computes acceleration a(r) = -mu * r / ||r||^3.\"\"\"\n        norm_r = np.linalg.norm(pos)\n        if norm_r == 0:\n            # This should not happen in a Kepler orbit\n            return np.array([0.0, 0.0])\n        return -mu * pos / norm_r**3\n\n    def energy(pos, vel):\n        \"\"\"Computes total energy E = 0.5*||v||^2 - mu/||r||.\"\"\"\n        return 0.5 * np.dot(vel, vel) - mu / np.linalg.norm(pos)\n\n    # Initial energy\n    E0 = energy(r, v)\n    if abs(E0) == 0:\n        # Avoid division by zero, though E0 = -0.5 for these orbits\n        # so this case is not expected to be triggered.\n        return 0.0\n\n    # Simulation time and number of steps\n    T = 2.0 * np.pi * np.sqrt(a**3 / mu)\n    N = int(np.floor(M * T / dt))\n    \n    max_rel_error = 0.0\n\n    if method == 'euler':\n        for _ in range(N):\n            acc = acceleration(r)\n            r = r + dt * v\n            v = v + dt * acc\n            \n            E_n = energy(r, v)\n            rel_error = abs(E_n - E0) / abs(E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n                \n    elif method == 'verlet':\n        acc = acceleration(r)\n        for _ in range(N):\n            r_new = r + dt * v + 0.5 * dt**2 * acc\n            acc_new = acceleration(r_new)\n            v_new = v + 0.5 * dt * (acc + acc_new)\n            \n            r, v, acc = r_new, v_new, acc_new\n            \n            E_n = energy(r, v)\n            rel_error = abs(E_n - E0) / abs(E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n    else:\n        raise ValueError(\"Invalid method specified. Choose 'euler' or 'verlet'.\")\n\n    return max_rel_error\n    \nsolve()\n```"
        },
        {
            "introduction": "While molecular dynamics follows the deterministic trajectory of a system, an alternative approach is to explore its possible configurations stochastically. This practice () introduces the foundational Metropolis Monte Carlo algorithm, a powerful method for sampling from a system's Boltzmann distribution to calculate equilibrium properties like the average potential energy. By simulating a simple Lennard-Jones dimer, you will build from scratch a core engine of computational statistical mechanics.",
            "id": "2452273",
            "problem": "Implement a complete program that estimates the equilibrium average potential energy of a one-dimensional Lennard–Jones (LJ) dimer using the Metropolis Monte Carlo algorithm in the canonical ensemble. The system consists of two point particles constrained to a one-dimensional line. The state of the system is fully specified by the scalar separation distance $r \\in (0,\\infty)$. The pair interaction is the Lennard–Jones potential\n$$\nU(r;\\epsilon,\\sigma) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\nwhere $\\epsilon$ sets the energy scale and $\\sigma$ sets the characteristic length. Work in reduced Lennard–Jones units in which lengths are measured in units of $\\sigma$ and energies are measured in units of $\\epsilon$. In these reduced units, denote $r^\\star = r/\\sigma$, $U^\\star(r^\\star) = U(r)/\\epsilon$, and temperature $T^\\star = T/\\epsilon$ with the Boltzmann constant taken as $k_{\\mathrm{B}} = 1$ by definition of the reduced units.\n\nYour program must:\n- Represent the microstate by the single scalar $r^\\star \\in (0,\\infty)$.\n- Use a symmetric proposal kernel in reduced units that attempts a uniform displacement $r^\\star \\to r^{\\star\\prime}$ by sampling a step $\\xi$ from a uniform distribution on $[-\\Delta^\\star, \\Delta^\\star]$ and then applying a reflection at the hard boundary $r^\\star = 0$ so that the proposal always remains in $(0,\\infty)$.\n- Enforce detailed balance with respect to the canonical (Boltzmann) equilibrium distribution for $r^\\star$, which is proportional to $\\exp\\!\\left(-U^\\star(r^\\star)/T^\\star\\right)$ at fixed reduced temperature $T^\\star$.\n- Use a burn-in phase of a specified number of steps (discarded from averaging) followed by a production phase during which you accumulate the sample average of $U^\\star(r^\\star)$.\n- Initialize the chain at $r^\\star_0 = 1.5$.\n- Ensure numerical stability by never evaluating the potential exactly at $r^\\star = 0$; if a proposed value would yield $r^\\star \\le 0$, reflect it into $(0,\\infty)$ and, if needed, clamp to a small positive lower bound for safe evaluation.\n\nReport the final average potential energy in reduced units, that is, as a dimensionless number equal to $\\langle U \\rangle / \\epsilon = \\langle U^\\star \\rangle$. No physical units are to be reported, only reduced units. Angles are not used in this problem. All random number generation must be reproducible by using the provided seeds.\n\nStarting point for derivation and design: use the canonical ensemble for classical statistical mechanics in which the probability density of a configuration with potential energy $U$ at temperature $T$ is proportional to $\\exp(-U/(k_{\\mathrm{B}}T))$, and impose detailed balance for the Monte Carlo transition probabilities with a symmetric proposal distribution.\n\nTest suite:\nImplement your program to run the following four test cases, each specified by the tuple $(T^\\star, \\Delta^\\star, N_{\\mathrm{steps}}, N_{\\mathrm{burn}}, \\text{seed})$ where $T^\\star$ is the reduced temperature, $\\Delta^\\star$ is the reduced proposal half-width, $N_{\\mathrm{steps}}$ is the total number of Metropolis steps, $N_{\\mathrm{burn}}$ is the number of initial steps to discard as burn-in, and $\\text{seed}$ initializes the pseudorandom number generator. Use the same Lennard–Jones parameters for all cases, namely $\\epsilon = 1$ and $\\sigma = 1$ in reduced units.\n\n- Case $1$: $(T^\\star = 1.0,\\ \\Delta^\\star = 0.3,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 12345)$\n- Case $2$: $(T^\\star = 0.2,\\ \\Delta^\\star = 0.05,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 54321)$\n- Case $3$: $(T^\\star = 5.0,\\ \\Delta^\\star = 0.5,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 2023)$\n- Case $4$: $(T^\\star = 0.05,\\ \\Delta^\\star = 0.02,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 98765)$\n\nProgram output specification:\n- For each test case, compute the sample average of $U^\\star$ over the production phase only.\n- The final program output must be a single line containing a Python-like list literal with the four averages in order, formatted as decimal numbers with exactly six digits after the decimal point, and separated by commas, for example, $[a,b,c,d]$ where $a$, $b$, $c$, and $d$ are the four averages corresponding to the four cases.\n\nDesign for coverage:\n- Case $1$ is a typical scenario at moderate $T^\\star$.\n- Case $2$ probes low $T^\\star$ near the potential minimum where harmonic behavior dominates.\n- Case $3$ tests high $T^\\star$ where the chain explores a broader range.\n- Case $4$ is an extreme low $T^\\star$ edge case with very small step size to maintain reasonable acceptance.\n\nYour program must be self-contained, require no input, and adhere strictly to the specified output format.",
            "solution": "The problem statement has been scrutinized and is determined to be valid. It is scientifically grounded in the principles of classical statistical mechanics, well-posed with a complete and consistent set of parameters, and presented in an objective, formal language. The task is a standard exercise in computational statistical physics: the estimation of a thermodynamic observable for a simple model system using the Metropolis Monte Carlo method. We shall now proceed with the derivation and implementation.\n\nThe objective is to compute the average potential energy $\\langle U^\\star \\rangle$ for a one-dimensional Lennard-Jones (LJ) dimer in the canonical ensemble. The state of the system is defined by the particle separation $r^\\star = r/\\sigma$, where all quantities are expressed in reduced LJ units ($\\epsilon=1$, $\\sigma=1$, $k_{\\mathrm{B}}=1$). The reduced potential energy is given by:\n$$\nU^\\star(r^\\star) = 4\\left[ (r^\\star)^{-12} - (r^\\star)^{-6} \\right]\n$$\nIn the canonical ensemble at a fixed reduced temperature $T^\\star$, the equilibrium probability distribution for the microstate $r^\\star$ is the Boltzmann distribution:\n$$\np(r^\\star) \\propto \\exp\\left(-\\frac{U^\\star(r^\\star)}{T^\\star}\\right)\n$$\nThe expectation value of any observable $A(r^\\star)$ is given by the integral $\\langle A \\rangle = \\int_0^\\infty A(r^\\star) p(r^\\star) dr^\\star / \\int_0^\\infty p(r^\\star) dr^\\star$. We will estimate this average by sampling from $p(r^\\star)$ using the Metropolis Monte Carlo algorithm.\n\nThe Metropolis algorithm generates a Markov chain of states $\\{r^\\star_0, r^\\star_1, r^\\star_2, \\ldots\\}$ such that the stationary distribution of the chain is the target distribution $p(r^\\star)$. This is achieved by constructing transition probabilities $P(r^\\star \\to r^{\\star\\prime})$ that satisfy the detailed balance condition:\n$$\np(r^\\star) P(r^\\star \\to r^{\\star\\prime}) = p(r^{\\star\\prime}) P(r^{\\star\\prime} \\to r^\\star)\n$$\nThe transition probability is factored into a proposal probability $T(r^{\\star\\prime}|r^\\star)$ and an acceptance probability $A(r^{\\star\\prime}|r^\\star)$. The detailed balance equation then reads:\n$$\np(r^\\star) T(r^{\\star\\prime}|r^\\star) A(r^{\\star\\prime}|r^\\star) = p(r^{\\star\\prime}) T(r^\\star|r^{\\star\\prime}) A(r^\\star|r^{\\star\\prime})\n$$\nThe standard choice for the acceptance probability is the Metropolis-Hastings form:\n$$\nA(r^{\\star\\prime}|r^\\star) = \\min\\left(1, \\frac{p(r^{\\star\\prime}) T(r^\\star|r^{\\star\\prime})}{p(r^\\star) T(r^{\\star\\prime}|r^\\star)}\\right)\n$$\nThe problem specifies a symmetric proposal kernel. A new state $r^{\\star\\prime}$ is proposed from the current state $r^\\star_{curr}$ by generating a random displacement $\\xi$ from a uniform distribution on $[-\\Delta^\\star, \\Delta^\\star]$ and handling the hard-wall boundary at $r^\\star=0$ by reflection. The proposed state is $r^{\\star}_{prop} = |r^\\star_{curr} + \\xi|$. This proposal mechanism is symmetric, i.e., $T(r^{\\star\\prime}|r^\\star) = T(r^\\star|r^{\\star\\prime})$, because the probability of proposing $r^{\\star\\prime}$ from $r^\\star$ depends on $|r^{\\star\\prime}-r^\\star|$ and $|r^{\\star\\prime}+r^\\star|$, which are symmetric with respect to swapping $r^\\star$ and $r^{\\star\\prime}$.\n\nFor a symmetric proposal kernel, the acceptance probability simplifies to the Metropolis form:\n$$\nA(r^{\\star\\prime}|r^\\star) = \\min\\left(1, \\frac{p(r^{\\star\\prime})}{p(r^\\star)}\\right) = \\min\\left(1, \\exp\\left[-\\frac{U^\\star(r^{\\star\\prime}) - U^\\star(r^\\star)}{T^\\star}\\right]\\right) = \\min\\left(1, \\exp\\left[-\\frac{\\Delta U^\\star}{T^\\star}\\right]\\right)\n$$\nwhere $\\Delta U^\\star = U^\\star(r^{\\star\\prime}) - U^\\star(r^\\star)$.\n\nThe simulation algorithm is as follows:\n1.  Initialize the system at state $r^\\star_0 = 1.5$.\n2.  Iterate for a total of $N_{\\mathrm{steps}}$ steps, indexed by $i = 0, 1, \\ldots, N_{\\mathrm{steps}}-1$. For each step:\n    a.  Let the current state be $r^\\star_{curr}$.\n    b.  Propose a new state $r^{\\star}_{prop}$. First, generate a random number $\\xi$ uniformly from $[-\\Delta^\\star, \\Delta^\\star]$. Then compute the raw proposal $r^\\star_{raw} = r^\\star_{curr} + \\xi$. The final proposal is obtained by reflection at the origin: $r^{\\star}_{prop} = |r^\\star_{raw}|$. This ensures $r^{\\star}_{prop} \\in (0, \\infty)$.\n    c.  Calculate the change in potential energy, $\\Delta U^\\star = U^\\star(r^{\\star}_{prop}) - U^\\star(r^\\star_{curr})$.\n    d.  Calculate the acceptance probability $P_{\\mathrm{acc}} = \\min(1, \\exp(-\\Delta U^\\star / T^\\star))$.\n    e.  Generate a random number $u$ uniformly from $[0, 1]$.\n    f.  If $u < P_{\\mathrm{acc}}$, accept the move: the next state is $r^\\star_{next} = r^{\\star}_{prop}$. Otherwise, reject the move: the next state is $r^\\star_{next} = r^\\star_{curr}$.\n3.  The first $N_{\\mathrm{burn}}$ steps constitute the equilibration or \"burn-in\" phase, and the configurations generated are discarded.\n4.  For steps $i$ from $N_{\\mathrm{burn}}$ to $N_{\\mathrm{steps}}-1$ (the production phase), accumulate the value of the potential energy $U^\\star(r^\\star_{i+1})$.\n5.  The estimate for the average potential energy is the arithmetic mean over the production phase:\n$$\n\\langle U^\\star \\rangle \\approx \\frac{1}{N_{\\mathrm{steps}} - N_{\\mathrm{burn}}} \\sum_{i=N_{\\mathrm{burn}}}^{N_{\\mathrm{steps}}-1} U^\\star(r^\\star_{i+1})\n$$\n\nThis procedure will be implemented for each of the four specified test cases. The implementation will use `numpy` for numerical calculations and its `random` submodule, seeded for reproducibility. To compute the potential energy efficiently, the term $(r^\\star)^{-6}$ will be calculated once and then squared to obtain $(r^\\star)^{-12}$. The final results will be formatted as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Monte Carlo simulations for the given test cases\n    and print the results in the specified format.\n    \"\"\"\n    \n    test_cases = [\n        # (T_star, delta_star, N_steps, N_burn, seed)\n        (1.0, 0.3, 300000, 50000, 12345),\n        (0.2, 0.05, 300000, 50000, 54321),\n        (5.0, 0.5, 300000, 50000, 2023),\n        (0.05, 0.02, 300000, 50000, 98765),\n    ]\n\n    results = []\n    for case in test_cases:\n        T_star, delta_star, N_steps, N_burn, seed = case\n        avg_potential = run_simulation(T_star, delta_star, N_steps, N_burn, seed)\n        results.append(f\"{avg_potential:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef lennard_jones_potential_reduced(r_star: float) -> float:\n    \"\"\"\n    Calculates the Lennard-Jones potential in reduced units.\n    \n    Args:\n        r_star: The separation distance in reduced units (r/sigma).\n\n    Returns:\n        The potential energy in reduced units (U/epsilon).\n    \"\"\"\n    # Defensive check for safety, though the algorithm should prevent r_star = 0.\n    if r_star = 0:\n        return np.inf\n\n    r_inv = 1.0 / r_star\n    r_inv6 = r_inv**6\n    r_inv12 = r_inv6**2\n    return 4.0 * (r_inv12 - r_inv6)\n\ndef run_simulation(T_star: float, delta_star: float, N_steps: int, N_burn: int, seed: int) -> float:\n    \"\"\"\n    Performs a Metropolis Monte Carlo simulation for a 1D LJ dimer.\n\n    Args:\n        T_star: Reduced temperature (T/epsilon).\n        delta_star: Half-width of the uniform proposal distribution.\n        N_steps: Total number of MC steps.\n        N_burn: Number of burn-in steps to discard.\n        seed: Seed for the random number generator.\n\n    Returns:\n        The average potential energy over the production phase.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Initialize the system state\n    r_star = 1.5\n    \n    potential_sum = 0.0\n    production_steps_count = 0\n    \n    # Pre-calculate current potential to avoid re-computation in the loop\n    current_potential = lennard_jones_potential_reduced(r_star)\n\n    for i in range(N_steps):\n        # Propose a move\n        xi = rng.uniform(-delta_star, delta_star)\n        r_star_proposed = r_star + xi\n        \n        # Apply reflection at the hard boundary r_star = 0\n        if r_star_proposed = 0:\n            r_star_proposed = -r_star_proposed\n            \n        # Calculate potential for the proposed state\n        proposed_potential = lennard_jones_potential_reduced(r_star_proposed)\n        \n        # Calculate change in energy\n        delta_U_star = proposed_potential - current_potential\n        \n        # Metropolis acceptance criterion\n        accept = False\n        if delta_U_star  0:\n            accept = True\n        else:\n            acceptance_prob = np.exp(-delta_U_star / T_star)\n            if rng.random()  acceptance_prob:\n                accept = True\n        \n        if accept:\n            r_star = r_star_proposed\n            current_potential = proposed_potential\n            \n        # Accumulate data after burn-in phase\n        if i >= N_burn:\n            potential_sum += current_potential\n            production_steps_count += 1\n            \n    # Calculate the average potential energy\n    if production_steps_count > 0:\n        average_potential = potential_sum / production_steps_count\n    else:\n        # Should not happen with valid N_steps > N_burn\n        average_potential = 0.0\n\n    return average_potential\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "The exact solution to the Schrödinger equation is intractable for all but the simplest systems, forcing us to use approximations. In quantum chemistry, a cornerstone approximation is to represent molecular orbitals as linear combinations of simpler, atom-centered functions known as a basis set. This exercise () demystifies this concept by guiding you to compare a minimal basis set with a more flexible one, showing firsthand how the quality of this basis directly impacts the accuracy of the calculated energy and wavefunction.",
            "id": "2452274",
            "problem": "Consider the Born–Oppenheimer treatment of the diatomic hydrogen molecule in one spatial dimension, where the two protons are fixed at positions $x = -R/2$ and $x = +R/2$ on the $x$-axis, with internuclear separation $R$ in atomic units. Model the electron as moving in the soft-Coulomb potential\n$$\nV(x;R,a) \\;=\\; -\\dfrac{1}{\\sqrt{(x - R/2)^2 + a^2}} \\;-\\; \\dfrac{1}{\\sqrt{(x + R/2)^2 + a^2}},\n$$\nwhere $a$ is a softening parameter in bohr. Work entirely in Hartree atomic units. The one-electron Hamiltonian is\n$$\n\\hat{H} \\;=\\; -\\dfrac{1}{2}\\dfrac{d^2}{dx^2} \\;+\\; V(x;R,a).\n$$\n\nYour task is to implement two independent approximations to the ground-state molecular orbital and energy for this single-electron problem and to quantify how the choice of basis affects the accuracy with respect to a numerical grid reference. This mirrors the effect of different Gaussian basis sets such as Slater-Type-Orbital with three Gaussians (STO-3G) versus correlation-consistent polarized valence triple-zeta (cc-pVTZ), adapted here to a one-dimensional surrogate for pedagogical purposes.\n\n1) Reference solution on a grid (truth proxy):\n   - Discretize the time-independent Schrödinger equation on a uniform grid $x \\in [-L, +L]$ with spacing $h$, using central finite differences for the kinetic energy and Dirichlet boundary conditions $\\psi(-L) = \\psi(+L) = 0$.\n   - In matrix form, for interior grid points, this produces a real symmetric tridiagonal Hamiltonian with main diagonal entries $d_i = \\dfrac{1}{h^2} + V(x_i;R,a)$ and off-diagonals $e_i = -\\dfrac{1}{2h^2}$.\n   - Compute the lowest eigenvalue $E_{\\text{ref}}(R)$ and the corresponding normalized eigenvector $\\psi_{\\text{ref}}(x;R)$ as the reference energy and orbital. Normalize using the trapezoidal rule on the full grid.\n\n2) Rayleigh–Ritz variational approximation in finite Gaussian bases:\n   - Use the variational principle with a finite set of one-dimensional Gaussian basis functions $\\{\\phi_\\mu(x)\\}$ to solve the generalized eigenproblem\n     $$\n     \\sum_\\nu H_{\\mu\\nu} c_\\nu \\;=\\; E \\sum_\\nu S_{\\mu\\nu} c_\\nu,\n     $$\n     where\n     $$\n     S_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\phi_\\nu(x)\\,dx, \\qquad\n     H_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\hat{H}\\,\\phi_\\nu(x)\\,dx.\n     $$\n   - Evaluate integrals numerically on the same grid using the trapezoidal rule. For the kinetic energy, use the symmetric gradient form derived by integration by parts,\n     $$\n     T_{\\mu\\nu} \\;=\\; \\dfrac{1}{2} \\int \\left(\\dfrac{d\\phi_\\mu}{dx}\\right)\\left(\\dfrac{d\\phi_\\nu}{dx}\\right) dx,\n     $$\n     so that $H_{\\mu\\nu} = T_{\\mu\\nu} + \\int \\phi_\\mu(x)\\,V(x;R,a)\\,\\phi_\\nu(x)\\,dx$.\n\n   - Define the following normalized one-dimensional Gaussian primitives centered at $x_0$:\n     - $s$-type: $\\;g_s(x;x_0,\\alpha) = \\mathcal{N}_s(\\alpha)\\,\\exp\\!\\big(-\\alpha (x - x_0)^2\\big)$ with $\\mathcal{N}_s(\\alpha) = \\left(\\dfrac{2\\alpha}{\\pi}\\right)^{1/4}$,\n     - $p$-type (polarization): $\\;g_p(x;x_0,\\alpha) = \\mathcal{N}_p(\\alpha)\\,(x - x_0)\\,\\exp\\!\\big(-\\alpha (x - x_0)^2\\big)$ with $\\mathcal{N}_p(\\alpha) = \\dfrac{2^{5/4}\\,\\alpha^{3/4}}{\\pi^{1/4}}$.\n     Their $x$-derivatives are to be used for the kinetic energy matrix:\n     $$\n     \\dfrac{d}{dx}g_s(x;x_0,\\alpha) \\;=\\; -2\\alpha(x - x_0)\\,g_s(x;x_0,\\alpha), \\quad\n     \\dfrac{d}{dx}g_p(x;x_0,\\alpha) \\;=\\; \\mathcal{N}_p(\\alpha)\\,e^{-\\alpha (x - x_0)^2}\\,\\big(1 - 2\\alpha(x - x_0)^2\\big).\n     $$\n\n   - Two basis choices on each hydrogen center at $x = \\pm R/2$:\n     a) STO-3G-like contracted $s$ on each center (two basis functions total):\n        - Use three $s$-type primitives with exponents and contraction coefficients\n          $$\n          \\boldsymbol{\\alpha}^{\\text{STO}} = [\\,3.42525091,\\;0.62391373,\\;0.16885540\\,], \\qquad\n          \\mathbf{c}^{\\text{STO}} = [\\,0.15432897,\\;0.53532814,\\;0.44463454\\,].\n          $$\n        - The contracted function at center $x_0$ is $\\phi_{s}^{\\text{STO}}(x;x_0) = \\sum_{i=1}^{3} c^{\\text{STO}}_i\\,g_s(x;x_0,\\alpha^{\\text{STO}}_i)$. Build one such contracted function at $x_0 = -R/2$ and one at $x_0 = +R/2$.\n\n     b) cc-pVTZ-like uncontracted $s$ plus one $p$ polarization on each center (eight basis functions total):\n        - $s$-type primitives per center with exponents\n          $$\n          \\boldsymbol{\\alpha}^{\\text{cc-s}} = [\\,13.010701,\\;1.9622572,\\;0.44453796\\,],\n          $$\n          treated as separate basis functions (uncontracted).\n        - One $p$-type primitive per center with exponent\n          $$\n          \\alpha^{\\text{cc-p}} = 0.730.\n          $$\n        - On each center $x_0 = \\pm R/2$, include the three $s$-type $g_s(x;x_0,\\alpha)$ for all $\\alpha \\in \\boldsymbol{\\alpha}^{\\text{cc-s}}$ and the $p$-type $g_p(x;x_0,\\alpha^{\\text{cc-p}})$.\n\n   - For each basis, solve the generalized eigenproblem and extract the lowest eigenvalue $E_{\\text{STO}}(R)$ or $E_{\\text{cc}}(R)$ and the corresponding normalized eigenvector, which defines the variational orbital $\\psi_{\\text{STO}}(x;R)$ or $\\psi_{\\text{cc}}(x;R)$. Normalize using the trapezoidal rule on the full grid.\n\n3) Metrics to report per test case:\n   - Absolute energy error in Hartree: $|E_{\\text{STO}}(R) - E_{\\text{ref}}(R)|$ and $|E_{\\text{cc}}(R) - E_{\\text{ref}}(R)|$.\n   - One-minus-overlap to quantify orbital agreement (unitless): $1 - \\big|\\int \\psi_{\\text{STO}}(x;R)\\,\\psi_{\\text{ref}}(x;R)\\,dx \\big|$ and $1 - \\big|\\int \\psi_{\\text{cc}}(x;R)\\,\\psi_{\\text{ref}}(x;R)\\,dx \\big|$, all integrals by the trapezoidal rule on the full grid.\n\nUse the following fixed numerical parameters for all test cases:\n- Grid half-extent $L = 15.0$ bohr, spacing $h = 0.01$ bohr.\n- Soft-Coulomb parameter $a = 0.6$ bohr.\n\nTest suite (three internuclear distances in bohr):\n- Case 1: $R = 1.40$.\n- Case 2: $R = 0.70$.\n- Case 3: $R = 5.00$.\n\nProgram requirements and output:\n- Implement the full pipeline described above without any external data files.\n- For each test case, compute the four floats in the order: absolute energy error for STO-3G-like (Hartree), absolute energy error for cc-pVTZ-like (Hartree), one-minus-overlap for STO-3G-like (unitless), one-minus-overlap for cc-pVTZ-like (unitless).\n- Round each reported float to exactly six decimal places. Energies must be in Hartree. Overlaps must be decimals without a percentage sign.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by test case from Case $1$ to Case $3$, and, within each case, in the order specified above. For example: \"[v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12]\".",
            "solution": "The problem presented is a well-defined exercise in computational quantum mechanics, specifically focusing on the application of the Born-Oppenheimer approximation and the variational principle for a one-dimensional model of the hydrogen molecule ion, $H_2^+$. The problem is scientifically grounded, self-contained, and algorithmically specified. It is therefore deemed valid and a solution will be provided.\n\nThe objective is to compare two common approximation schemes, based on finite basis sets of Gaussian functions, against a numerically exact reference solution obtained on a dense grid. This serves to illustrate the trade-off between computational cost and accuracy that is central to quantum chemistry. All calculations are performed in Hartree atomic units.\n\nThe system is described by the one-electron Hamiltonian:\n$$\n\\hat{H} \\;=\\; \\hat{T} + \\hat{V} \\;=\\; -\\dfrac{1}{2}\\dfrac{d^2}{dx^2} \\;-\\; \\dfrac{1}{\\sqrt{(x - R/2)^2 + a^2}} \\;-\\; \\dfrac{1}{\\sqrt{(x + R/2)^2 + a^2}}\n$$\nwhere $R$ is the internuclear distance and $a$ is a softening parameter for the Coulomb potential. We must find the ground-state (lowest) eigenvalue $E$ and corresponding eigenfunction $\\psi(x)$ of the time-independent Schrödinger equation (TISE), $\\hat{H}\\psi(x) = E\\psi(x)$.\n\n**1. Reference Solution: Finite Difference Method**\n\nTo establish a benchmark for accuracy, the TISE is solved on a uniform spatial grid defined on the interval $[-L, +L]$ with spacing $h$. The grid points are $x_i = -L + i \\cdot h$ for $i=0, 1, \\dots, N-1$, where $N$ is the total number of points. The wavefunction $\\psi(x)$ is represented by its values at these points, $\\psi_i = \\psi(x_i)$.\n\nThe kinetic energy operator $\\hat{T} = -\\frac{1}{2}\\frac{d^2}{dx^2}$ is approximated using a three-point central finite difference formula for the second derivative:\n$$\n\\dfrac{d^2\\psi}{dx^2}\\bigg|_{x_i} \\;\\approx\\; \\dfrac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}\n$$\nApplying this to the TISE at an interior grid point $x_i$ (where $i=1, \\dots, N-2$) gives:\n$$\n-\\dfrac{1}{2h^2}(\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}) + V(x_i; R, a)\\psi_i \\;=\\; E\\psi_i\n$$\nRearranging this equation yields:\n$$\n-\\dfrac{1}{2h^2}\\psi_{i-1} + \\left(\\dfrac{1}{h^2} + V(x_i; R, a)\\right)\\psi_i - \\dfrac{1}{2h^2}\\psi_{i+1} \\;=\\; E\\psi_i\n$$\nThe problem specifies Dirichlet boundary conditions, $\\psi(-L) = \\psi_0 = 0$ and $\\psi(+L) = \\psi_{N-1} = 0$. These conditions allow us to write the equations for all interior points as a matrix eigenvalue problem, $\\mathbf{H}_{\\text{grid}}\\boldsymbol{\\psi} = E\\boldsymbol{\\psi}$. The matrix $\\mathbf{H}_{\\text{grid}}$ is a real symmetric tridiagonal matrix of size $(N-2) \\times (N-2)$, with diagonal elements $d_i = \\frac{1}{h^2} + V(x_i; R, a)$ and off-diagonal elements $e_i = -\\frac{1}{2h^2}$.\n\nSolving this yields a set of eigenvalues and eigenvectors. The lowest eigenvalue is the reference ground-state energy, $E_{\\text{ref}}$. The corresponding eigenvector contains the values of the wavefunction $\\psi_{\\text{ref}}$ at the interior grid points, which is then extended by the boundary zeros and normalized using the trapezoidal rule such that $\\int |\\psi_{\\text{ref}}(x)|^2 dx \\approx \\sum_{i=0}^{N-2} \\frac{(\\psi_i^2 + \\psi_{i+1}^2)}{2}h = 1$.\n\n**2. Variational Solution: Rayleigh-Ritz Method in a Gaussian Basis**\n\nThe variational principle states that for any normalized trial wavefunction $\\Psi$, the expectation value of the Hamiltonian provides an upper bound to the true ground-state energy $E_0$:\n$$\nE[\\Psi] \\;=\\; \\dfrac{\\langle\\Psi|\\hat{H}|\\Psi\\rangle}{\\langle\\Psi|\\Psi\\rangle} \\;\\ge\\; E_0\n$$\nWe construct a trial wavefunction as a linear combination of $N_{bf}$ known basis functions $\\{\\phi_\\nu(x)\\}$:\n$$\n\\Psi(x) \\;=\\; \\sum_{\\nu=1}^{N_{bf}} c_\\nu \\phi_\\nu(x)\n$$\nSubstituting this into the energy functional and minimizing with respect to the coefficients $\\{c_\\mu\\}$ leads to the Roothaan-Hall equations, which is a generalized eigenvalue problem:\n$$\n\\sum_\\nu H_{\\mu\\nu} c_\\nu \\;=\\; E \\sum_\\nu S_{\\mu\\nu} c_\\nu \\quad \\text{or, in matrix form,} \\quad \\mathbf{H}\\mathbf{c} = E\\mathbf{S}\\mathbf{c}\n$$\nThe matrices $\\mathbf{H}$ and $\\mathbf{S}$ are the Hamiltonian and overlap matrices, respectively, with elements:\n$$\nS_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\phi_\\nu(x)\\,dx\n$$\n$$\nH_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\hat{H}\\,\\phi_\\nu(x)\\,dx \\;=\\; T_{\\mu\\nu} + V_{\\mu\\nu}\n$$\nUsing integration by parts, the kinetic energy matrix element $T_{\\mu\\nu}$ is computed in its symmetric form:\n$$\nT_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\left(-\\dfrac{1}{2}\\dfrac{d^2}{dx^2}\\right)\\phi_\\nu(x)\\,dx \\;=\\; \\dfrac{1}{2} \\int \\left(\\dfrac{d\\phi_\\mu}{dx}\\right)\\left(\\dfrac{d\\phi_\\nu}{dx}\\right) dx\n$$\nThe potential energy matrix element is:\n$$\nV_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,V(x;R,a)\\,\\phi_\\nu(x)\\,dx\n$$\nAll matrix elements are computed by numerical integration over the same grid using the trapezoidal rule.\n\nTwo basis sets are investigated:\na) A minimal, contracted basis (\"STO-3G-like\") consisting of two functions. Each function is a fixed linear combination of three primitive $s$-type Gaussians, centered at one of the protons ($x = \\pm R/2$). This basis has a total of $N_{bf}=2$ functions.\nb) A larger, uncontracted basis (\"cc-pVTZ-like\") comprising eight functions. For each proton, we use three distinct $s$-type Gaussian primitives and one $p$-type polarization function as independent basis functions. This gives $2 \\times (3 + 1) = 8$ basis functions in total, so $N_{bf}=8$.\n\nFor each basis, solving the generalized eigenvalue problem yields a set of energy eigenvalues and corresponding coefficient vectors. The lowest eigenvalue is the variational approximation to the ground state energy, $E_{\\text{approx}}$. The associated eigenvector $\\mathbf{c}$ is used to construct the approximate wavefunction $\\psi_{\\text{approx}}(x) = \\sum_\\nu c_\\nu \\phi_\\nu(x)$. This wavefunction is then normalized on the grid, again using the trapezoidal rule.\n\n**3. Comparison Metrics**\n\nThe quality of each basis set approximation is quantified by two metrics for each given internuclear separation $R$:\n- **Absolute Energy Error**: $|E_{\\text{approx}}(R) - E_{\\text{ref}}(R)|$. According to the variational principle, this error must be non-negative. A smaller value indicates a better approximation of the energy.\n- **Orbital \"One-Minus-Overlap\"**: $1 - \\left|\\int \\psi_{\\text{approx}}(x;R)\\,\\psi_{\\text{ref}}(x;R)\\,dx \\right|$. This measures the deviation of the approximate wavefunction from the reference. A value closer to zero signifies a better description of the electron's spatial distribution.\n\nThe algorithm will be implemented in Python, utilizing the `numpy` library for numerical operations and `scipy.linalg` for solving the eigenvalue problems. The calculations will be performed for the three specified values of $R$, and the results compiled into the required output format.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh, eigh_tridiagonal\n\n# Constants given in the problem\nL_BOHR = 15.0\nH_BOHR = 0.01\nA_BOHR = 0.6\n\n# Basis set parameters\nALPHA_STO = np.array([3.42525091, 0.62391373, 0.16885540])\nC_STO = np.array([0.15432897, 0.53532814, 0.44463454])\nALPHA_CC_S = np.array([13.010701, 1.9622572, 0.44453796])\nALPHA_CC_P = 0.730\n\ndef potential_func(x, R, a):\n    \"\"\"Computes the 1D soft-Coulomb potential.\"\"\"\n    return -1.0 / np.sqrt((x - R / 2.0)**2 + a**2) - 1.0 / np.sqrt((x + R / 2.0)**2 + a**2)\n\ndef solve_grid_reference(R, L, h, a):\n    \"\"\"Solves the TISE on a grid using finite differences.\"\"\"\n    x_full = np.arange(-L, L + h, h)\n    x_interior = x_full[1:-1]\n    \n    V_interior = potential_func(x_interior, R, a)\n    \n    # Construct the tridiagonal Hamiltonian for interior points\n    diag = 1.0 / h**2 + V_interior\n    off_diag = -1.0 / (2.0 * h**2) * np.ones(len(x_interior) - 1)\n    \n    # Solve the eigenvalue problem\n    eigvals, eigvecs = eigh_tridiagonal(diag, off_diag)\n    \n    # Ground state is the lowest eigenvalue and corresponding eigenvector\n    E_ref = eigvals[0]\n    psi_interior = eigvecs[:, 0]\n    \n    # Reconstruct full wavefunction with boundary conditions\n    psi_ref_unnormalized = np.zeros_like(x_full)\n    psi_ref_unnormalized[1:-1] = psi_interior\n    \n    # Normalize using the trapezoidal rule\n    norm_sq = np.trapz(psi_ref_unnormalized**2, x_full)\n    psi_ref = psi_ref_unnormalized / np.sqrt(norm_sq)\n    \n    return E_ref, psi_ref, x_full\n\ndef g_s_primitive(x, x0, alpha):\n    \"\"\"Normalized s-type Gaussian primitive.\"\"\"\n    norm = (2 * alpha / np.pi)**0.25\n    return norm * np.exp(-alpha * (x - x0)**2)\n\ndef dg_s_primitive_dx(x, x0, alpha):\n    \"\"\"Derivative of a normalized s-type Gaussian primitive.\"\"\"\n    return -2.0 * alpha * (x - x0) * g_s_primitive(x, x0, alpha)\n\ndef g_p_primitive(x, x0, alpha):\n    \"\"\"Normalized p-type Gaussian primitive.\"\"\"\n    norm = (2**2.5 * alpha**1.5 / np.pi**0.5)**0.5\n    return norm * (x - x0) * np.exp(-alpha * (x - x0)**2)\n\ndef dg_p_primitive_dx(x, x0, alpha):\n    \"\"\"Derivative of a normalized p-type Gaussian primitive.\"\"\"\n    norm = (2**2.5 * alpha**1.5 / np.pi**0.5)**0.5\n    return norm * np.exp(-alpha * (x - x0)**2) * (1 - 2 * alpha * (x - x0)**2)\n\ndef get_basis_functions(basis_type, R, x):\n    \"\"\"Generates basis functions and their derivatives on the grid.\"\"\"\n    centers = [-R / 2.0, R / 2.0]\n    functions = []\n    derivatives = []\n\n    if basis_type == 'STO':\n        for x0 in centers:\n            phi = np.zeros_like(x)\n            dphi_dx = np.zeros_like(x)\n            for i in range(len(ALPHA_STO)):\n                alpha = ALPHA_STO[i]\n                c = C_STO[i]\n                phi += c * g_s_primitive(x, x0, alpha)\n                dphi_dx += c * dg_s_primitive_dx(x, x0, alpha)\n            functions.append(phi)\n            derivatives.append(dphi_dx)\n    elif basis_type == 'CC':\n        for x0 in centers:\n            # s-type functions\n            for alpha_s in ALPHA_CC_S:\n                functions.append(g_s_primitive(x, x0, alpha_s))\n                derivatives.append(dg_s_primitive_dx(x, x0, alpha_s))\n            # p-type function\n            functions.append(g_p_primitive(x, x0, ALPHA_CC_P))\n            derivatives.append(dg_p_primitive_dx(x, x0, ALPHA_CC_P))\n    \n    return functions, derivatives\n\ndef solve_variational(R, a, x_grid, basis_type):\n    \"\"\"Solves the TISE using the Rayleigh-Ritz variational method.\"\"\"\n    basis_funcs, basis_derivs = get_basis_functions(basis_type, R, x_grid)\n    n_basis = len(basis_funcs)\n    \n    S = np.zeros((n_basis, n_basis))\n    H = np.zeros((n_basis, n_basis))\n    \n    V_grid = potential_func(x_grid, R, a)\n\n    for i in range(n_basis):\n        for j in range(n_basis):\n            # Overlap matrix element\n            integrand_S = basis_funcs[i] * basis_funcs[j]\n            S[i, j] = np.trapz(integrand_S, x_grid)\n            \n            # Kinetic energy matrix element\n            integrand_T = basis_derivs[i] * basis_derivs[j]\n            T_ij = 0.5 * np.trapz(integrand_T, x_grid)\n            \n            # Potential energy matrix element\n            integrand_V = basis_funcs[i] * V_grid * basis_funcs[j]\n            V_ij = np.trapz(integrand_V, x_grid)\n            \n            H[i, j] = T_ij + V_ij\n\n    # Solve the generalized eigenvalue problem\n    eigvals, eigvecs = eigh(H, S)\n    \n    # Ground state is the lowest eigenvalue and corresponding eigenvector\n    E_basis = eigvals[0]\n    coeffs = eigvecs[:, 0]\n    \n    # Construct the wavefunction from the basis functions and coefficients\n    psi_unnormalized = np.zeros_like(x_grid)\n    for i in range(n_basis):\n        psi_unnormalized += coeffs[i] * basis_funcs[i]\n        \n    # Normalize the final wavefunction\n    norm_sq = np.trapz(psi_unnormalized**2, x_grid)\n    psi_basis = psi_unnormalized / np.sqrt(norm_sq)\n    \n    return E_basis, psi_basis\n\ndef solve():\n    test_cases = [1.40, 0.70, 5.00]\n    all_results = []\n    \n    for R_val in test_cases:\n        # 1. Compute reference solution\n        E_ref, psi_ref, x = solve_grid_reference(R_val, L_BOHR, H_BOHR, A_BOHR)\n\n        # 2. Compute STO-3G-like solution\n        E_sto, psi_sto = solve_variational(R_val, A_BOHR, x, 'STO')\n        \n        # 3. Compute cc-pVTZ-like solution\n        E_cc, psi_cc = solve_variational(R_val, A_BOHR, x, 'CC')\n        \n        # 4. Calculate metrics\n        err_E_sto = abs(E_sto - E_ref)\n        err_E_cc = abs(E_cc - E_ref)\n        \n        overlap_sto = np.trapz(psi_sto * psi_ref, x)\n        err_psi_sto = 1.0 - abs(overlap_sto)\n        \n        overlap_cc = np.trapz(psi_cc * psi_ref, x)\n        err_psi_cc = 1.0 - abs(overlap_cc)\n        \n        all_results.extend([err_E_sto, err_E_cc, err_psi_sto, err_psi_cc])\n\n    # Format the final output string\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}