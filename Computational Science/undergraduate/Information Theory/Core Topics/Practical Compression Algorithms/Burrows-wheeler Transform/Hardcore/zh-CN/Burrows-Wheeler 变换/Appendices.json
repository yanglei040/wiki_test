{
    "hands_on_practices": [
        {
            "introduction": "理解任何新算法的第一步是亲手实践。这个练习将引导你完成 Burrows-Wheeler 变换 (BWT) 的基本流程，从为输入字符串添加结束标记、生成所有循环移位，到对它们进行字典序排序并提取最终的变换结果。通过这个练习，你将对 BWT 如何重排一个字符串建立起具体而扎实的理解，这是掌握其后续应用的基础 ()。",
            "id": "1606440",
            "problem": "Burrows-Wheeler变换（BWT）是一种对字符串字符的可逆置换，广泛应用于数据压缩算法中。变换过程如下：\n\n1.  给定一个长度为 `n` 的输入字符串 `S`，在其末尾附加一个特殊的字符串结束标记，记为 `$`。此标记不在原始字符串中，并且在字典序上被定义为小于字符串中的任何其他字符。设新字符串为 `T`。\n2.  生成字符串 `T` 的所有 `n+1` 个循环移位（或旋转）。\n3.  按字典序（字母顺序）对这些循环移位进行排序。\n4.  BWT的输出，记为 `L`，是由每个排序后的循环移位的最后一个字符连接而成的字符串。\n\n给定二进制输入字符串 `S = 101101`，确定其Burrows-Wheeler变换 `L`。\n\n以下哪个选项表示正确的BWT输出 `L`？\n\nA. `11101$0`\n\nB. `$001111`\n\nC. `1101$01`\n\nD. `0$10111`\n\nE. `101101$`",
            "solution": "我们从输入字符串 $S=\\text{101101}$ 开始，并附加特殊的字符串结束标记，该标记在字典序上被定义为小于任何其他字符。这产生 $T=\\text{101101\\$}$。\n\n生成 $T$ 的所有循环移位：\n- $\\text{r}_{0}=\\text{101101\\$}$\n- $\\text{r}_{1}=\\text{01101\\$1}$\n- $\\text{r}_{2}=\\text{1101\\$10}$\n- $\\text{r}_{3}=\\text{101\\$101}$\n- $\\text{r}_{4}=\\text{01\\$1011}$\n- $\\text{r}_{5}=\\text{1\\$10110}$\n- $\\text{r}_{6}=\\text{\\$101101}$\n\n使用顺序 $\\$\\lt 0 \\lt 1$ 按字典序对这些循环移位进行排序：\n- $\\text{r}_{6}=\\text{\\$101101}$\n- $\\text{r}_{4}=\\text{01\\$1011}$\n- $\\text{r}_{1}=\\text{01101\\$1}$\n- $\\text{r}_{5}=\\text{1\\$10110}$\n- $\\text{r}_{3}=\\text{101\\$101}$\n- $\\text{r}_{0}=\\text{101101\\$}$\n- $\\text{r}_{2}=\\text{1101\\$10}$\n\n按顺序取每个排序行的最后一个字符来构成 $L$。这些最后的字符分别是：$1,1,1,0,1,\\$,0$。将它们连接起来得到 `11101$0`，这与选项A匹配。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Burrows-Wheeler 变换的一个关键特性是其完美的可逆性，这也是它在无损压缩中如此有用的原因。本练习聚焦于其逆变换过程，你将利用其核心的“末列到首列”（Last-to-First, LF）映射特性，从变换后的 `L` 列和主索引 `I` 开始，逐步重建原始字符串。完成这个练习 () 将帮助你巩固 BWT 作为一种无损变换的核心逻辑。",
            "id": "1606417",
            "problem": "Burrows-Wheeler变换（BWT）是一种用于数据压缩算法的可逆文本变换。它将一个字符串重新排列成由相似字符组成的序列，这种序列通常更易于压缩。输入字符串的变换过程如下：首先，创建该字符串所有循环移位构成的概念矩阵；然后，对这些移位进行字典序排序；最后，提取该排序矩阵的最后一列。\n\nBWT的输出包含两个部分：\n1.  变换后的字符串 `L`，即循环移位排序矩阵的最后一列。\n2.  一个主索引 `I`，即原始字符串在排序矩阵中的行索引（从0开始计数）。\n\n为了确保原始字符串在排序后的移位列表中有唯一的表示，并标记其结尾，变换前会在输入字符串的末尾附加一个特殊的字符串结束符，记为 `$`。该字符在字典序上被定义为小于字母表中的任何其他字符。\n\n给定最后一列 `L = 'bb$aa'` 和主索引 `I = 2`，请确定原始输入字符串。你的最终答案应该是重建后*不包含* `$` 字符的字符串。",
            "solution": "我们使用LF映射来逆转Burrows-Wheeler变换。设 $L$ 为最后一列，长度为 $n$。定义第一列 $F$ 为 $L$ 中字符按字典序排序的结果，其中字符串结束符 $\\$$ 排在任何其他字符之前。定义函数 $C(c)$ 为 $L$ 中严格小于 $c$ 的字符数量，并对 $L$ 中的每个位置 $j$ 定义秩 $r(j)$ 为 $L[j]$ 在 $L[0..j]$ 中出现的次数。LF映射由下式给出\n$$\n\\operatorname{LF}(j)=C(L[j]) + r(j) - 1.\n$$\n从主索引 $I$（即原始字符串在排序矩阵中的行索引）开始，通过迭代重建带有结束符的原始字符串（记为 $S'）$\n$$\ns[k] = L[j], \\quad j \\leftarrow \\operatorname{LF}(j)\n$$\n其中 $k$ 从 $n-1$ 递减到 $0$，初始 $j=I$。\n\n对于给定的数据，$L$ 的长度 $n=5$，其位置和字符为\n$$\n(0,b),\\ (1,b),\\ (2,\\$),\\ (3,a),\\ (4,a).\n$$\n对字符进行排序得到\n$$\nF = [\\$, a, a, b, b].\n$$\n计算字母表 $\\{\\$,a,b\\}$ 的 $C(c)$：\n$$\nC(\\$)=0,\\quad C(a)=1,\\quad C(b)=3.\n$$\n从左到右扫描 $L$ 来计算秩 $r(j)$：\n$$\nr(0)=1\\ \\text{for}\\ b,\\quad r(1)=2\\ \\text{for}\\ b,\\quad r(2)=1\\ \\text{for}\\ \\$,\\quad r(3)=1\\ \\text{for}\\ a,\\quad r(4)=2\\ \\text{for}\\ a.\n$$\n应用LF映射：\n$$\n\\operatorname{LF}(0)=3,\\ \\operatorname{LF}(1)=4,\\ \\operatorname{LF}(2)=0,\\ \\operatorname{LF}(3)=1,\\ \\operatorname{LF}(4)=2.\n$$\n从 $j=I=2$ 开始重建：\n$$\nk=4:\\ s[4]=L[2]=\\$, \\ j\\leftarrow \\operatorname{LF}(2)=0;\n$$\n$$\nk=3:\\ s[3]=L[0]=b, \\ j\\leftarrow \\operatorname{LF}(0)=3;\n$$\n$$\nk=2:\\ s[2]=L[3]=a, \\ j\\leftarrow \\operatorname{LF}(3)=1;\n$$\n$$\nk=1:\\ s[1]=L[1]=b, \\ j\\leftarrow \\operatorname{LF}(1)=4;\n$$\n$$\nk=0:\\ s[0]=L[4]=a, \\ j\\leftarrow \\operatorname{LF}(4)=2.\n$$\n因此，重建后带有结束符的字符串是\n$$\nS' = \\text{abab}\\$,\n$$\n所以，原始输入字符串（不含 `$` 字符）是 `abab`。",
            "answer": "$$\\boxed{abab}$$"
        },
        {
            "introduction": "BWT 的真正威力体现在它的高级应用中，尤其是在生物信息学等需要高效文本索引的领域。这个进阶练习将挑战你利用 BWT 及其辅助结构（如 $\\Psi$ 数组或 LF 映射）的性质，在不完全重构原始字符串的情况下，直接从中检索特定位置的字符。掌握这项技术 ()，你将能深刻理解 BWT 如何支撑像 FM-index 这样强大的高效序列搜索工具。",
            "id": "1606387",
            "problem": "在生物信息学中，Burrows-Wheeler变换（BWT）是用于高效DNA序列搜索算法（如FM索引）的关键组成部分。BWT将字符串重排为由相似字符组成的连续序列，使其更易于压缩。BWT的一个关键特性是它允许在不解压或完全重建原始字符串的情况下进行搜索和字符检索。\n\n从BWT派生出的一个基本数据结构是`Psi`数组（也称为`Next`数组）。对于长度为`N`的字符串`T`，`Psi`数组是`0, 1, ..., N-1`的一个排列，由性质`SA[Psi[i]] = (SA[i] + 1) mod N`定义，其中`SA`是`T`的后缀数组。这个性质意味着，如果BWT矩阵的第`i`行对应于从索引`k`开始的后缀，那么第`Psi[i]`行就对应于从索引`k+1`开始的后缀。这使得我们能够沿着原始字符串的后缀“向前步进”。\n\n考虑一个由字母表`{A, C, G, T}`中字符组成的未知DNA序列`S`。对字符串`S$`（即原始字符串`S`后附加一个特殊的字符串结束符`$`，该符号被定义为在字典序上小于DNA字母表中的任何字符）应用了BWT。得到的BWT矩阵的最后一列`L`为：\n\n`L = \"T$GAC\"`\n\n你的任务是确定原始字符串`S`中索引为2的字符（即找到`S[2]`，使用从0开始的索引）。你必须利用BWT及其辅助数据结构的性质来完成此任务，而不能完全重建字符串`S`。",
            "solution": "令 $T = S\\$$，其中 $\\$$ 在字典序上最小。BWT的最后一列是 $L = \\text{\"T\\$GAC\"}$，索引为 $0,\\dots,4$：\n- $L[0] = \\text{T}$, $L[1] = \\$$, $L[2] = \\text{G}$, $L[3] = \\text{A}$, $L[4] = \\text{C}$。\n\n第一列 $F$ 是 $L$ 中字符排序后的多重集：\n$$F = \\text{\"\\$ACGT\"},$$\n所以 $F[0] = \\$$, $F[1] = \\text{A}$, $F[2] = \\text{C}$, $F[3] = \\text{G}$, $F[4] = \\text{T}$。\n\n定义 $C[c]$ 为在排序 $\\$ < \\text{A} < \\text{C} < \\text{G} < \\text{T}$ 下，字符串 $T$ 中严格小于字符 $c$ 的字符数量。从 $L$ 我们得到\n$$C[\\$] = 0,\\quad C[\\text{A}] = 1,\\quad C[\\text{C}] = 2,\\quad C[\\text{G}] = 3,\\quad C[\\text{T}] = 4.$$\n我们使用LF映射公式：$\\operatorname{LF}(i) = C[L[i]] + \\operatorname{rank}(L[i], i) - 1$，其中 $\\operatorname{rank}(c, i)$ 是字符 $c$ 在 $L$ 的前缀 $L[0..i]$ 中出现的次数（从1开始计数）。\n\n为每个 $i$ 计算 $\\operatorname{rank}$ 和 $\\operatorname{LF}$：\n- $i=0$: $L[0]=\\text{T}$，$\\operatorname{rank}(\\text{T},0)=1$，所以 $\\operatorname{LF}(0)=C[\\text{T}] + 1 - 1=4$。\n- $i=1$: $L[1]=\\$$，$\\operatorname{rank}(\\$,1)=1$，所以 $\\operatorname{LF}(1)=C[\\$] + 1 - 1=0$。\n- $i=2$: $L[2]=\\text{G}$，$\\operatorname{rank}(\\text{G},2)=1$，所以 $\\operatorname{LF}(2)=C[\\text{G}] + 1 - 1=3$。\n- $i=3$: $L[3]=\\text{A}$，$\\operatorname{rank}(\\text{A},3)=1$，所以 $\\operatorname{LF}(3)=C[\\text{A}] + 1 - 1=1$。\n- $i=4$: $L[4]=\\text{C}$，$\\operatorname{rank}(\\text{C},4)=1$，所以 $\\operatorname{LF}(4)=C[\\text{C}] + 1 - 1=2$。\n\n因此\n$$\\operatorname{LF}: 0\\mapsto 4,\\;1\\mapsto 0,\\;2\\mapsto 3,\\;3\\mapsto 1,\\;4\\mapsto 2.$$\n\n$\\Psi$ 映射是 $\\operatorname{LF}$ 的逆，由 $SA[\\Psi[i]] = (SA[i] + 1) \\bmod N$ 定义，等价地有 $\\operatorname{LF}(\\Psi(i)) = i$。对上面的映射求逆可得，\n$$\\Psi(0)=1,\\quad \\Psi(1)=3,\\quad \\Psi(2)=4,\\quad \\Psi(3)=2,\\quad \\Psi(4)=0.$$\n\n根据BWT的定义，对于每个行索引 $i$，\n$$L[i] = T[(SA[i] - 1) \\bmod N].$$\n因此，我们想要找的字符 $T[k]$ 等于 $L[j]$，其中 $j$ 是满足 $SA[j] = (k+1) \\bmod N$ 的行索引。\n\n题目要求我们找出 $S[2] = T[2]$。因此我们需要找到满足 $SA[i] = 2+1=3$ 的行索引 $i$。设 $r$ 是满足 $SA[r] = N-1$ 的行，这是第一列条目为 $\\$$ 的唯一行，即 $F[r]=\\$$。从 $F$ 中我们可以看到 $r=0$。\n\n使用性质 $SA[\\Psi[i]] = (SA[i] + 1) \\bmod N$，从 $i_{0}=r=0$ 开始（此时 $SA[i_{0}]=4$），我们进行迭代：\n$$i_{1}=\\Psi(i_{0})=\\Psi(0)=1\\Rightarrow SA[i_{1}]=(4+1) \\bmod 5 = 0,$$\n$$i_{2}=\\Psi(i_{1})=\\Psi(1)=3\\Rightarrow SA[i_{2}]=(0+1) \\bmod 5 = 1,$$\n$$i_{3}=\\Psi(i_{2})=\\Psi(3)=2\\Rightarrow SA[i_{3}]=(1+1) \\bmod 5 = 2,$$\n$$i_{4}=\\Psi(i_{3})=\\Psi(2)=4\\Rightarrow SA[i_{4}]=(2+1) \\bmod 5 = 3.$$\n因此，满足 $SA[i]=3$ 的行是 $i=i_{4}=4$。所以\n$$S[2] = T[2] = L[i_4] = L[4] = \\text{C}。$$",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}