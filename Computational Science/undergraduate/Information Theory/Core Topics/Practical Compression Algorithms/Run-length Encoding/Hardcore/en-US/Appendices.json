{
    "hands_on_practices": [
        {
            "introduction": "This first practice explores the fundamental mechanics of Run-Length Encoding (RLE) and its performance. By analyzing a checkerboard pattern—a sequence with high-frequency changes—you will discover a critical limitation of basic RLE, where the \"compressed\" data can actually be larger than the original. This exercise is key to understanding not just how RLE works, but also when it is, and is not, an effective compression strategy .",
            "id": "1655653",
            "problem": "Run-Length Encoding (RLE) is a simple form of lossless data compression where sequences of the same data value occurring in a row are stored as a single data value and count, rather than as the original run.\n\nConsider a monochrome digital image represented by a grid of pixels. Each pixel is represented by a single bit: '0' for a white pixel and '1' for a black pixel. For this image, an RLE scheme is used where a run of `n` identical pixels (of value `s`) is encoded as a pair. The run count `n` is stored as a 5-bit unsigned integer, and the pixel value `s` is stored as a 1-bit value.\n\nThe image is a $16 \\times 16$ pixel checkerboard. The pixel at the top-left corner (row 0, column 0) is white. We are interested in compressing the first horizontal scanline of this image (row 0).\n\nThe compression ratio is defined as the ratio of the original data size (in bits) to the compressed data size (in bits).\n\nCalculate the compression ratio for the first scanline of this checkerboard image. Express your answer as a decimal, rounded to three significant figures.",
            "solution": "A $16 \\times 16$ checkerboard with the top-left pixel white alternates pixel values along each row. For the first scanline (row 0), the pixel pattern is $0,1,0,1,\\ldots$ with no two adjacent pixels equal.\n\nOriginal data size in bits for the scanline:\n$$\nB_{o} = 16 \\times 1 = 16.\n$$\nSince every pixel alternates, each run has length $n=1$, and there are $R=16$ runs. Each run is encoded using $5$ bits for the count and $1$ bit for the pixel value, totaling $6$ bits per run. Thus the compressed size is\n$$\nB_{c} = R \\times 6 = 16 \\times 6 = 96.\n$$\nThe compression ratio (original size divided by compressed size) is\n$$\nC = \\frac{B_{o}}{B_{c}} = \\frac{16}{96} = \\frac{1}{6}.\n$$\nAs a decimal rounded to three significant figures:\n$$\nC \\approx 0.167.\n$$",
            "answer": "$$\\boxed{0.167}$$"
        },
        {
            "introduction": "Having seen how basic RLE can fail on certain data, we now explore a common practical improvement: Selective Run-Length Encoding (SRLE). This modified algorithm introduces a simple but powerful idea of only compressing runs that are long enough to provide a net benefit, while leaving short runs uncompressed. This exercise demonstrates how simple thresholds can make compression algorithms more robust and efficient in real-world scenarios .",
            "id": "1655629",
            "problem": "A new lossless data compression algorithm, called Selective Run-Length Encoding (SRLE), has been designed to compress binary data streams. The algorithm operates by segmenting the input stream into runs of consecutive identical bits and encoding each run based on its length.\n\nThe rules for SRLE are as follows:\n1.  A run of length $L  3$ is classified as a \"short run\". Short runs are considered incompressible and are written to the output stream verbatim, without any modification.\n2.  A run of length $L \\ge 3$ is classified as a \"long run\". Long runs are compressed into a fixed-length 8-bit code word. This code word is constructed by concatenating three parts:\n    *   A 3-bit marker sequence `111`.\n    *   A single bit representing the digit of the run (`0` for a run of zeros, `1` for a run of ones).\n    *   A 4-bit unsigned binary integer representing the length $L$ of the run. This format can represent lengths from 0 to 15.\n\nYou are given the following 21-bit binary sequence $S$:\n$$S = 110000010011111111110$$\n\nCalculate the total length, in bits, of the compressed binary sequence generated by applying this SRLE scheme to the sequence $S$.",
            "solution": "The problem requires us to apply the Selective Run-Length Encoding (SRLE) algorithm to a given binary sequence $S$ and determine the total length of the resulting compressed sequence. We must first parse the input sequence into runs of identical bits and then apply the appropriate rule for each run.\n\nThe input sequence is $S = 110000010011111111110$.\n\nFirst, we segment $S$ into consecutive runs of identical bits:\n*   Run 1: `11` (A run of '1's, length 2)\n*   Run 2: `00000` (A run of '0's, length 5)\n*   Run 3: `1` (A run of '1's, length 1)\n*   Run 4: `00` (A run of '0's, length 2)\n*   Run 5: `1111111111` (A run of '1's, length 10)\n*   Run 6: `0` (A run of '0's, length 1)\n\nNext, we process each run according to the SRLE rules and calculate the length of its compressed representation.\n\n**Run 1:** `11`\nThe length of this run is $L=2$. According to the rules, since $L  3$, this is a \"short run\". It is written to the output verbatim.\nThe compressed representation is `11`.\nThe length of this compressed part is 2 bits.\n\n**Run 2:** `00000`\nThe length of this run is $L=5$. Since $L \\ge 3$, this is a \"long run\" and must be encoded. The encoding consists of:\n1.  The 3-bit marker: `111`.\n2.  The bit for the digit: `0`.\n3.  The 4-bit binary representation of the length $L=5$: `0101`.\nThe full encoded representation is `11100101`.\nThe length of this compressed part is $3 + 1 + 4 = 8$ bits.\n\n**Run 3:** `1`\nThe length of this run is $L=1$. Since $L  3$, this is a \"short run\". It is written verbatim.\nThe compressed representation is `1`.\nThe length of this compressed part is 1 bit.\n\n**Run 4:** `00`\nThe length of this run is $L=2$. Since $L  3$, this is a \"short run\". It is written verbatim.\nThe compressed representation is `00`.\nThe length of this compressed part is 2 bits.\n\n**Run 5:** `1111111111`\nThe length of this run is $L=10$. Since $L \\ge 3$, this is a \"long run\" and must be encoded. The encoding consists of:\n1.  The 3-bit marker: `111`.\n2.  The bit for the digit: `1`.\n3.  The 4-bit binary representation of the length $L=10$: `1010`.\nThe full encoded representation is `11111010`.\nThe length of this compressed part is $3 + 1 + 4 = 8$ bits.\n\n**Run 6:** `0`\nThe length of this run is $L=1$. Since $L  3$, this is a \"short run\". It is written verbatim.\nThe compressed representation is `0`.\nThe length of this compressed part is 1 bit.\n\nFinally, to find the total length of the compressed sequence, we sum the lengths of all the individual compressed parts.\nTotal Length = (Length from Run 1) + (Length from Run 2) + (Length from Run 3) + (Length from Run 4) + (Length from Run 5) + (Length from Run 6)\nTotal Length = $2 + 8 + 1 + 2 + 8 + 1 = 22$ bits.\n\nThe original sequence was 21 bits long, and the compressed sequence is 22 bits long. In this case, the \"compression\" algorithm actually increased the data size, which is possible for certain input sequences with lossless algorithms.",
            "answer": "$$\\boxed{22}$$"
        },
        {
            "introduction": "This final challenge takes our understanding of RLE into the domain of optimization and lossy pre-processing. Here, we consider a scenario where a small number of errors (bit-flips) are permissible to achieve a much higher compression rate by merging adjacent runs. This problem requires you to think algorithmically about how to best use a limited \"budget\" of flips to minimize the final number of runs, highlighting the trade-offs between data fidelity and compression efficiency .",
            "id": "1655600",
            "problem": "In digital communications and data storage, Run-Length Encoding (RLE) is a simple form of lossless data compression. The basic principle is to replace consecutive sequences of identical symbols, known as \"runs,\" with a pair consisting of the symbol and the length of the run. For instance, the binary sequence `000011100` would be encoded as three runs: `(0, 4)`, `(1, 3)`, and `(0, 2)`.\n\nTo further enhance compression, one might consider introducing a limited number of bit-flips into a binary data stream. This is particularly relevant in applications where the data can tolerate minor errors, such as in image or sensor data processing. By strategically flipping a small number of bits, it may be possible to merge adjacent runs of the same symbol, thereby reducing the total number of runs required to represent the data. For example, the sequence `111011` consists of three runs. By flipping the single `0` to a `1` (at the cost of one flip), the sequence becomes `111111`, which is a single run.\n\nYou are given a binary data sequence $S$ of length $N$ and an integer $D$ representing the maximum number of bit-flips you are allowed to perform. Your task is to calculate the absolute minimum number of runs that the sequence can be represented by, using no more than $D$ flips.\n\nFor the specific binary sequence $S = \\text{\"0110100011\"}$ and a maximum flip budget of $D=2$, what is the minimum number of runs achievable?",
            "solution": "Let the binary string be $S = 0110100011$ of length $N=10$. First count the initial runs by grouping consecutive equal bits:\n$$0^{1},\\ 1^{2},\\ 0^{1},\\ 1^{1},\\ 0^{3},\\ 1^{2}$$\nso the initial number of runs is $R_{0}=6$.\n\nA run boundary is a transition between adjacent bits. The number of runs equals the number of transitions plus $1$. Flipping a single bit can affect at most the two adjacent transitions, hence one flip can reduce the number of runs by at most $2$ (this maximum happens only when flipping the middle bit of a pattern $a\\,b\\,a$ with $a \\neq b$ and both neighbors equal). Therefore, with $D=2$ flips, a theoretical lower bound is\n$$R \\geq R_{0} - 2D = 6 - 4 = 2.$$\nWe now determine whether $R=2$ is achievable.\n\nA binary string with exactly $2$ runs must be of the form $0^{k}1^{N-k}$ or $1^{k}0^{N-k}$ for some cut index $k \\in \\{0,1,\\dots,N\\}$. The minimum flips needed to transform $S$ into $0^{k}1^{N-k}$ is\n$$F(k) = \\underbrace{O[k]}_{\\text{ones in first }k\\text{ turned to }0} + \\underbrace{\\big((N-k) - (O[N]-O[k])\\big)}_{\\text{zeros in last }N-k\\text{ turned to }1} = (N/2) - k + 2O[k],$$\nwhere $O[k]$ is the number of ones in the prefix of length $k$, and here $N=10$ and $O[N]=5$, so\n$$F(k) = 5 - k + 2O[k].$$\nSimilarly, the minimum flips to transform $S$ into $1^{k}0^{N-k}$ is\n$$G(k) = \\underbrace{(k - O[k])}_{\\text{zeros in first }k\\text{ turned to }1} + \\underbrace{(O[N]-O[k])}_{\\text{ones in last }N-k\\text{ turned to }0} = k + 5 - 2O[k].$$\n\nCompute the prefix-one counts $O[k]$ from $S=0,1,1,0,1,0,0,0,1,1$:\n$$O[0]=0,\\ O[1]=0,\\ O[2]=1,\\ O[3]=2,\\ O[4]=2,\\ O[5]=3,\\ O[6]=3,\\ O[7]=3,\\ O[8]=3,\\ O[9]=4,\\ O[10]=5.$$\nThus\n$$F(k) = 5 - k + 2O[k] \\text{ takes values } (5,4,5,6,5,6,5,4,3,4,5),$$\n$$G(k) = k + 5 - 2O[k] \\text{ takes values } (5,6,5,4,5,4,5,6,7,6,5),$$\nfor $k=0,1,\\dots,10$, respectively. The minima are $\\min_{k} F(k)=3$ and $\\min_{k} G(k)=4$. Therefore, achieving $2$ runs would require at least $3$ flips, which exceeds the budget $D=2$. Hence $R=2$ is impossible.\n\nIt remains to show that $R=3$ is achievable with $2$ flips. For example, flip the bit at index 0 from `0` to `1`, obtaining `1110100011`, whose runs are $1^{3},0^{1},1^{1},0^{3},1^{2}$ (that is 5 runs). Then flip the bit at index 3 from `0` to `1`, yielding `1111100011`, which has runs $1^{5},0^{3},1^{2}$, hence exactly 3 runs. Therefore, with $D=2$ flips, the absolute minimum number of runs is $3$.",
            "answer": "$$\\boxed{3}$$"
        }
    ]
}