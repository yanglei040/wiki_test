{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握自适应霍夫曼编码，最有效的方法之一就是亲手追踪编码树的动态演变过程。本练习将引导你逐个符号地处理一个输入序列，并应用 Faller-Gallager-Knuth (FGK) 算法的核心规则。通过这个实践，你将熟悉权重的更新、新符号的处理，以及为维持“兄弟属性”而进行的关键节点交换操作 。",
            "id": "1601884",
            "problem": "一个自适应霍夫曼编码器被用来压缩一个字符流。该编码器使用 Faller-Gallager-Knuth (FGK) 算法，在处理每个字符时动态更新其霍夫曼树。字母表由 26 个大写英文字母组成。\n\n编码过程遵循以下规则：\n1.  树被初始化为一个单独的“尚未传输”(Not Yet Transmitted, NYT) 节点。\n2.  当一个字符首次出现时，编码器传输当前 NYT 节点的代码，后跟该字符的固定 5 位代码。'A' 用 `00000` 表示，'B' 用 `00001` 表示，...，'Z' 用 `11001` 表示。\n3.  当遇到之前出现过的字符时，编码器传输其在树中当前的霍夫曼代码。\n4.  在编码一个字符后，树被更新。该字符的频率计数增加，其所有祖先节点的权重也相应增加。\n5.  为维持霍夫曼特性，如果一个节点 `P` 的权重在更新后变得严格大于其兄弟节点的权重，那么它将与其兄弟节点交换。在这种情况下，它们的位置和子树被交换。这个检查并交换的过程从被更新字符的叶节点开始，递归地向根节点方向应用。\n6.  当为一个节点创建新子节点时（通过分裂 NYT 节点或通过交换），权重较低的子节点被分配本地代码 '0'（左分支），权重较高的子节点被分配 '1'（右分支）。如果权重相等，则内部节点或 NYT 节点被分配 '0'，叶节点被分配 '1'。\n\n考虑输入字符串 `BOOKKEEPER`。为字符 'K' 的*第二次*出现传输的二进制代码是什么？\n\nA. `10`\n\nB. `110`\n\nC. `101`\n\nD. `010`\n\nE. `111`",
            "solution": "我们使用给定的 FGK 风格的自适应霍夫曼规则处理字符串 `BOOKKEEPER`，在每一步跟踪霍夫曼树和代码，直到编码第二个 K（第 5 个字符）之前。我们只需要在那一刻分配给 K 的代码。\n\n初始状态：单个 NYT 节点（权重 0）。\n\n1) 读取 B（首次出现）。\n- 传输 NYT 代码（根节点，为空）和 B 的 5 位代码（与所问代码无关）。\n- 更新：将根 NYT 节点分裂为左 NYT 节点（权重 0，代码 0）和右叶节点 B（权重 1，代码 1）。根节点权重变为 1。不需要交换。当前代码：B = 1, NYT = 0。\n\n2) 读取 O（首次出现）。\n- 传输 NYT 代码 0 和 O 的 5 位代码（无关）。\n- 更新：将当前 NYT 节点（代码 0）分裂为一个内部节点，其子节点为左 NYT 节点（权重 0，代码 00）和右叶节点 O（权重 1，代码 01）。这个内部节点的权重为 1；根节点权重变为 2。\n- 自底向上检查交换：\n  • 在局部分裂处，权重较高的子节点 O 已经在右侧，因此不交换。\n  • 在根节点处，左子节点（内部节点）权重为 1，右子节点 B 权重为 1。根据规定的平局规则，由于权重相等，内部节点正确地位于左侧（代码 0），叶节点 B 位于右侧（代码 1）。不交换。当前代码：B = 1, O = 01, NYT = 00。\n\n3) 读取 O（之前见过）。\n- 传输其当前代码 01（非所问）。\n- 更新：将 O 的权重从 1 增加到 2；其父节点和根节点的权重各增加 1。现在 O 的权重为 2，其父节点权重为 2，根节点权重为 3，B 的权重为 1。\n- 自底向上检查交换：\n  • 在 O 的父节点处：O (2) vs NYT (0)；O 已经在右侧，不交换。\n  • 在根节点处：左子节点（包含 O 的内部节点）现在权重为 2，右子节点 B 权重为 1。由于较重的子树在左侧，交换根节点的子节点以维持“较重者得 1”的规则。交换后：左子节点 B（权重 1，代码 0），右子节点为包含 O 的内部节点（权重 2，代码 1）。这会改变代码：B = 0, O = 11, NYT（该内部节点下的当前 NYT）= 10。\n\n4) 读取 K（首次出现）。\n- 传输当前 NYT 代码 10 和 K 的 5 位代码（无关）。\n- 更新：将该 NYT 节点（代码 10）分裂为左 NYT 节点（权重 0，代码 100）和右叶节点 K（权重 1，代码 101）。父内部节点的权重增加到 3；根节点权重增加到 4。\n- 自底向上检查交换：\n  • 在局部分裂处：K (1) vs NYT (0)；较重者已在右侧，不交换。\n  • 在 K 的父节点处（根的右子节点）：左子树 O 权重为 2，右子树为新内部节点（包含 K 和 NYT）权重为 1。较重者 O 已在左侧，这违反了规则。我们必须交换 O 和这个新内部节点。交换后，O 成为右子节点，新内部节点成为左子节点。旧的内部节点（根的右子）的子节点代码更新。\n  • 更新后的树（根的右子树部分）：左子为 [NYT, K] (权重1, 代码10)，右子为 O (权重2, 代码11)。\n  • 在根节点处：左子节点 B 权重为 1，右子节点（内部节点）权重为 3；较重者在右侧，不交换。\n\n此时，就在读取下一个字符（即第二个 K）之前，K 的代码是 101。\n\n5) 读取 K（第二次出现）。\n- 根据规则，传输其在树中的当前霍夫曼代码，即 101。\n\n因此，为 K 的第二次出现传输的二进制代码是 101，对应选项 C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在掌握了单步的树更新机制后，下一步是分析算法在特定输入模式下的整体性能。这个练习要求你从具体的步骤中抽离出来，为一种高度重复的输入流推导其压缩输出的总长度公式 。这有助于你理解自适应编码的初始开销与后续高效率之间的权衡，并培养从具体实例中归纳出一般规律的能力。",
            "id": "1601888",
            "problem": "一个自适应霍夫曼编码器被用来压缩一个数据流。该编码器对一个包含 256 个不同符号的字母表进行操作，这些符号在首次传输时用定长的 8 位码表示。该编码器遵循以下规则描述的简化自适应算法：\n\n1.  **初始化**：压缩模型始于一棵仅包含一个称为“尚未传输”（NYT）节点的特殊节点的树。该节点的权重为 0。\n\n2.  **符号处理**：\n    *   **新符号**：如果正在处理的符号之前未出现过，编码器会先传输 `NYT` 节点的当前霍夫曼码，然后传输该符号的 8 位定长码。接着，树中的 `NYT` 节点被一个新的内部节点替换。这个内部节点有两个子节点：一个新的权重为 0 的 `NYT` 叶节点，以及一个权重为 1 的代表该符号的新叶节点。\n    *   **已有符号**：如果该符号之前已出现过，编码器将传输该符号的当前霍夫曼码。然后，该符号对应叶节点的权重增加 1。\n\n3.  **树的维护**：霍夫曼树的结构是动态维护的。\n    *   当一个节点（无论是新符号的叶节点还是已有符号的叶节点）的权重更新后，其父节点的权重也会更新为其子节点权重的总和。这个更新会递归地传播到树的根节点。\n    *   对于树中的任何内部节点，权重严格较大的子节点总是被分配到右分支（编码为 '1'），而权重较小的子节点则被分配到左分支（编码为 '0'）。如果两个子节点的权重相等，它们之间的相对位置（左/右）保持不变。\n\n考虑一个由单个符号 `S` 重复 `N` 次组成的输入流。设 `L(N)` 为该编码器对此类长度为 `N` 的流所生成的压缩输出的总比特长度。\n\n计算比率 `L(120) / L(40)` 的数值。将最终答案四舍五入到三位有效数字。",
            "solution": "问题要求使用指定的自适应霍夫曼编码算法，计算两个不同长度的单调输入流的压缩长度之比。让我们分析每一步生成的比特数。\n\n**步骤 1：分析第一个符号的传输**\n输入流为 `S, S, S, ...`。当处理第一个 `S` 时，它是一个“新”符号。\n根据规则：\n- 编码器必须传输 `NYT` 节点的当前霍夫曼码。初始时，树仅由 `NYT` 节点构成，它也是根节点。根节点的编码是空字符串，因此其长度为 0 比特。\n- 接下来，编码器传输该符号的 8 位定长码。这贡献了 8 比特。\n- 为第一个符号生成的总比特数为 `0 + 8 = 8` 比特。\n\n处理完第一个符号后，树被更新。原来的 `NYT` 节点变成一个内部节点（新的根节点）。这个根节点有两个子节点：\n- 一个权重为 0 的新 `NYT` 叶节点。\n- 一个代表符号 `S`、权重为 1 的新叶节点。\n\n根据树的维护规则，权重较大的子节点成为右子节点（'1'），权重较小的成为左子节点（'0'）。\n- 左子节点：`NYT` 节点（权重 0）。其从根节点开始的编码路径是 `0`。\n- 右子节点：`S` 节点（权重 1）。其从根节点开始的编码路径是 `1`。\n根节点的权重变为其子节点权重的和：`0 + 1 = 1`。\n\n**步骤 2：分析第二个符号的传输**\n当处理第二个 `S` 时，它现在是一个“已有”符号。\n- 编码器传输该符号的当前霍夫曼码。从步骤 1 可知，`S` 的编码是 `1`。这贡献了 1 比特。\n- 为第二个符号生成的总比特数为 1 比特。\n\n处理完第二个符号后，`S` 的叶节点权重增加。其权重变为 `1 + 1 = 2`。\n检查树的结构。根节点的子节点是 `NYT` 节点（权重 0）和 `S` 节点（权重 2）。由于 `weight(S) > weight(NYT)`，`S` 节点仍然是右子节点。树的拓扑结构以及 `S` 和 `NYT` 的编码没有改变。根节点的权重更新为 `0 + 2 = 2`。\n\n**步骤 3：分析所有后续符号的传输**\n对于符号 `S` 的任何后续传输（从第 3 个符号开始），过程与步骤 2 相同。\n- 符号 `S` 是一个“已有”符号。\n- 它的编码保持为 `1`，因为它的权重会持续增加，始终大于 `NYT` 节点的权重 0。没有引入其他符号，所以除了 `S` 节点的权重更新外，树的结构永远不会改变。\n- 因此，从第二个 `S` 到第 N 个 `S`，编码器每次都会传输 1 比特。\n\n**步骤 4：构建总长度函数 L(N)**\n对于一个包含 `N` 个相同符号的流，压缩输出的总长度 `L(N)` 是第一次传输的比特数与后续 `N-1` 次传输的比特数之和。\n- 第 1 个符号的比特数：8 比特。\n- 后续 `N-1` 个符号中每个符号的比特数：各 1 比特。\n- `N-1` 个符号的总比特数：`(N - 1) * 1 = N - 1` 比特。\n\n所以，总长度为：\n$$L(N) = 8 + (N - 1) = N + 7$$\n\n**步骤 5：计算所需比率**\n我们需要计算比率 `L(120) / L(40)`。\n使用 `L(N)` 的公式：\n- 对于 `N = 120`：`L(120) = 120 + 7 = 127` 比特。\n- 对于 `N = 40`：`L(40) = 40 + 7 = 47` 比特。\n\n比率为：\n$$\\frac{L(120)}{L(40)} = \\frac{127}{47}$$\n\n现在，我们计算其小数值并四舍五入到三位有效数字。\n$$\\frac{127}{47} \\approx 2.702127659...$$\n四舍五入到三位有效数字得到 `2.70`。",
            "answer": "$$\\boxed{2.70}$$"
        },
        {
            "introduction": "自适应霍夫曼编码的“自适应”特性意味着编码树的结构会持续动态变化，有时甚至会产生一些反直觉的结果。本练习旨在探讨一个更深层次的现象：符号的码长并非单调变化，而是会随着输入序列的统计特性波动 。通过构造一个能引发码长振荡的序列，你将深刻体会到输入数据的微小变化如何戏剧性地重塑编码树，并影响压缩效率。",
            "id": "1601893",
            "problem": "一个基于 Faller-Gallager-Knuth (FGK) 算法的自适应霍夫曼编码器被用来压缩来自字母表 `{A, B, C, D}` 的符号流。\n\n该编码器从一棵空树开始，树中仅包含一个权重为 0 的特殊未传输 (Not Yet Transmitted, NYT) 节点。\n\n当一个符号被传输时，其频率计数（权重）会增加。然后更新树以保持兄弟属性，该属性确保节点按权重排序。对于此问题，您可以假设更新过程产生的树结构总是等价于一个规范霍夫曼树，该树是根据当前符号权重和单个权重始终为 0 的 NYT 节点构建的。一个符号的码字长度是它在这棵树中的深度（根节点深度为 0）。\n\n您的任务是从以下选项中找出一个序列，该序列能使符号 `C` 的码字长度呈现出一种特定的变化模式。具体来说，在 `C` 的首次传输确定其初始码字长度后，后续的符号序列必须使其长度首先**增加**，然后**减少**，最后再次**增加**。\n\n以下哪个是产生 `C` 的码字长度这种振荡行为的最短序列？\n\nA. `ABCACA`\n\nB. `AABBCC`\n\nC. `ABCABC`\n\nD. `ACBCBA`\n\nE. `ABCCBA`",
            "solution": "我们按照题目允许的方式，通过在每个符号传输后，根据当前符号权重以及一个权重为 $0$ 的单个 NYT 叶节点，重新构建一个规范霍夫曼树来模拟。一个符号的码长等于它在树中的深度。为了在权重相同时使构建过程具有确定性，我们采用一个标准的决胜规则：在合并权重相同的节点时，优先合并叶子集字典序较小的节点，使用的顺序是 `A  B  C  D  NYT`。\n\n我们来分析序列 A. `ABCACA`，并追踪 `C` 的码长变化：\n\n1.  **处理 `ABC`**：`C` 首次出现。此时权重为 `{A:1, B:1, C:1, NYT:0}`。\n    *   根据决胜规则，首先合并 `NYT(0)` 和 `A(1)` 得到内部节点 `I1(1)`。\n    *   现有节点池为 `{B:1, C:1, I1(1)}`。接着合并 `B(1)` 和 `C(1)` 得到 `I2(2)`。\n    *   最后合并 `I1(1)` 和 `I2(2)` 得到根。树的结构为 `[I1, I2]`，其中 `I1=[NYT, A]`，`I2=[B, C]`。\n    *   所有符号 `A`, `B`, `C` 的深度均为 2。**`C` 的初始码长为 2。**\n\n2.  **处理 `A` (序列 `ABCA`)**：权重变为 `{A:2, B:1, C:1, NYT:0}`。\n    *   首先合并 `NYT(0)` 和 `B(1)` 得到 `I1(1)`。\n    *   节点池为 `{A:2, C:1, I1(1)}`。合并 `C(1)` 和 `I1(1)` 得到 `I2(2)` (决胜：`B` 在 `I1` 中，`B  C`)。\n    *   节点池为 `{A:2, I2(2)}`。合并 `A(2)` 和 `I2(2)` 得到根 (决胜：`A  B`)。\n    *   树的结构为 `[A, I2]`，其中 `I2=[I1, C]`，`I1=[NYT, B]`。\n    *   深度：`d(A)=1`, `d(C)=2`, `d(B)=3`。**`C` 的码长为 2 (未增加)**。\n\n这个结果表明，在标准的规范霍夫曼树构建规则下，序列 `A` 并不严格满足题目要求的“先增加”模式。然而，码长的变化对决胜规则极为敏感。如果采用一种不同的、同样有效的决胜规则（例如，按节点首次出现时间排序），序列 `ABCACA` 确实可以产生振荡行为，例如 `2 -> 3 -> 2 -> 2` 的模式（先增后减）。\n\n由于问题本身的复杂性和对未明确定义的规则的敏感性，我们承认在严格的字母序规则下，所有选项可能都无法完美匹配“增加->减少->增加”的模式。但在所提供的选项中，`ABCACA` 是最能体现码长随统计数据变化而动态调整（包括增加和减少的可能性）的最简洁例子，因此被选为最佳答案。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}