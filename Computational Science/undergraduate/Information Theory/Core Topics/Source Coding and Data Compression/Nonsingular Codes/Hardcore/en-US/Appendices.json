{
    "hands_on_practices": [
        {
            "introduction": "Our journey into the practical side of coding theory begins with the most fundamental requirement: nonsingularity. This exercise challenges you to repair a flawed code, forcing a direct engagement with the core principle that every unique symbol must map to a unique codeword. By making a minimal change to achieve nonsingularity, you'll gain a concrete understanding of this essential first step in code design. ",
            "id": "1643885",
            "problem": "In the design of a simple data compression scheme, a source alphabet $S = \\{s_1, s_2, s_3, s_4\\}$ is to be encoded using a binary code alphabet $X = \\{0, 1\\}$. An initial design proposes the following codebook $C$:\n- $C(s_1) = 101$\n- $C(s_2) = 00$\n- $C(s_3) = 110$\n- $C(s_4) = 101$\n\nA code is defined as **nonsingular** if every unique source symbol is mapped to a unique codeword. It is clear that the proposed code $C$ is not nonsingular. To fix this, a junior engineer suggests modifying *only* the codeword for the source symbol $s_4$.\n\nFrom the list of possible new codewords for $s_4$ below, identify all options that would make the resulting code nonsingular.\n\nA) `00`\n\nB) `10`\n\nC) `110`\n\nD) `001`\n\nE) `1010`",
            "solution": "A code $C:S\\to X^{*}$ is nonsingular if it is injective, i.e., for all $i\\neq j$, $C(s_{i})\\neq C(s_{j})$. The current code assigns $C(s_{1})=`101`$, $C(s_{2})=`00`$, $C(s_{3})=`110`$, and we must modify only $C(s_{4})$ so that $C(s_{4})\\notin\\{\\text{`101`}, \\text{`00`}, \\text{`110`}\\}$.\n\nCheck each option for $C(s_{4})$:\n- A) `00`: equals $C(s_2)$, violates injectivity; reject.\n- B) `10`: distinct from `101`, `00`, `110`; accept.\n- C) `110`: equals $C(s_3)$, violates injectivity; reject.\n- D) `001`: distinct from `101`, `00`, `110`; accept.\n- E) `1010`: distinct from `101`, `00`, `110`; accept.\n\nTherefore, the options that make the code nonsingular are B, D, and E.",
            "answer": "$$\\boxed{BDE}$$"
        },
        {
            "introduction": "Having established the importance of unique codewords, we now explore a more subtle pitfall: ambiguity in sequences. A code can be nonsingular—with every symbol having a distinct codeword—yet still produce messages that can be interpreted in multiple ways. This practice asks you to identify such a code and pinpoint the ambiguous string, demonstrating the crucial difference between a nonsingular code and a truly uniquely decodable one. ",
            "id": "1610386",
            "problem": "In digital communications, source symbols from an alphabet are converted into sequences of binary digits (bits) using a code. Consider a source with an alphabet $\\mathcal{S} = \\{A, B, C\\}$. We wish to encode messages from this source using a binary code, where each symbol is mapped to a variable-length string of bits from the set $\\{0, 1\\}$.\n\nFor a code to be useful, it must satisfy certain properties. Let's define two important classifications:\n1.  A code is **non-singular** if every symbol in the source alphabet maps to a different, unique codeword.\n2.  A code is **uniquely decodable** if any finite sequence of concatenated codewords can be resolved into only one possible sequence of source symbols. Note that all uniquely decodable codes must be non-singular, but the converse is not always true.\n\nYour task is to identify which of the following options correctly provides a binary code for the source alphabet $\\mathcal{S}$ that is **non-singular** but **not uniquely decodable**, along with a specific encoded string that demonstrates this lack of unique decodability. In each option, the code mapping is assumed to be $A \\to c_1$, $B \\to c_2$, and $C \\to c_3$.\n\nA. Code: {`0`, `01`, `10`}. Ambiguous String: `010`\nB. Code: {`0`, `1`, `0`}. Ambiguous String: `010`\nC. Code: {`0`, `10`, `11`}. Ambiguous String: `100`\nD. Code: {`1`, `10`, `100`}. Ambiguous String: `101`\nE. Code: {`0`, `01`, `10`}. Ambiguous String: `0110`",
            "solution": "We use the definitions:\n- A code is non-singular if all codewords are distinct.\n- A code is uniquely decodable if any concatenation of codewords has exactly one parsing into source symbols. A sufficient condition for unique decodability is the prefix condition (no codeword is a prefix of another). More generally, the Sardinas–Patterson test detects unique decodability by iteratively building difference sets; if the empty string ever appears, the code is not uniquely decodable; if the process ends without producing the empty string, the code is uniquely decodable.\n\nCheck each option.\n\nA. Code {`0`, `01`, `10`} with $A \\mapsto `0`$, $B \\mapsto `01`$, $C \\mapsto `10`$.\n- Non-singular: `0`, `01`, and `10` are distinct, so the code is non-singular.\n- Not uniquely decodable: The string `010` has two parsings:\n  - `0` | `10` corresponds to $A C$.\n  - `01` | `0` corresponds to $B A$.\n  Therefore the code is not uniquely decodable, and the given ambiguous string correctly demonstrates it.\n\nB. Code {`0`, `1`, `0`} with $A \\mapsto `0`$, $B \\mapsto `1`$, $C \\mapsto `0`$.\n- Not non-singular: $A$ and $C$ share the same codeword `0`. Hence this option fails the non-singularity requirement and is invalid regardless of any string.\n\nC. Code {`0`, `10`, `11`} with $A \\mapsto `0`$, $B \\mapsto `10`$, $C \\mapsto `11`$.\n- Non-singular: codewords are distinct.\n- Prefix-free: no codeword is a prefix of another (neither `10` nor `11` starts with `0`, and `0` is not a prefix of them since they start with `1`). Hence the code is uniquely decodable.\n- The proposed string `100` parses as `10` | `0` (i.e., $B A$), and there is no alternative parsing, confirming unique decodability. Thus this option does not meet the “not uniquely decodable” requirement.\n\nD. Code {`1`, `10`, `100`} with $A \\mapsto `1`$, $B \\mapsto `10`$, $C \\mapsto `100`$.\n- Non-singular: codewords are distinct.\n- Not prefix-free (since `1` is a prefix of `10` and `100`), so we apply the Sardinas–Patterson test:\n  - $D_{1} = \\{\\text{`0`}, \\text{`00`}\\}$ from the relations `1` prefix of `10` (suffix `0`) and `1` prefix of `100` (suffix `00`), and `10` prefix of `100` (suffix `0`).\n  - Compute $D_{2}$ from overlaps of $D_{1}$ with the code and vice versa. No codeword starts with `0`, and no element of $D_{1}$ starts with `1`, so no new non-empty suffixes are produced; thus $D_{2} = \\varnothing$.\n  - Since the empty string never appears and the process terminates, the code is uniquely decodable.\n- The proposed string `101` has the unique parsing `10` | `1` (i.e., $B A$). Therefore this option does not meet the “not uniquely decodable” requirement.\n\nE. Code {`0`, `01`, `10`} (same as A) with ambiguous string `0110`.\n- The code itself is non-singular and not uniquely decodable (as shown in A), but the specific string `0110` is not ambiguous: it parses as `01` | `10` (i.e., $B C$), and no alternative parsing exists because trying to begin with `0` leaves `110`, which cannot be segmented into valid codewords. Hence this option fails to provide a correct demonstrating string.\n\nTherefore, only option A both provides a non-singular code that is not uniquely decodable and supplies a correct ambiguous string that demonstrates the lack of unique decodability.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "This final practice integrates the concepts of nonsingularity and unique decodability into the broader hierarchy of code properties, including prefix codes. You will act as a code reviewer, systematically analyzing several proposed codes to identify one with a specific set of properties: nonsingular but not uniquely decodable. This task requires a keen eye for detail and reinforces the progressive strength of these classifications, from basic uniqueness to instantaneous decodability. ",
            "id": "1643890",
            "problem": "In information theory, a code is a mapping from a source alphabet to a set of codewords. Consider a source with five distinct symbols, $\\mathcal{X} = \\{s_1, s_2, s_3, s_4, s_5\\}$, which are encoded using a binary alphabet $\\mathcal{D} = \\{0, 1\\}$.\n\nThe quality of a code is often judged by the following properties, which are progressively stronger:\n1.  **Nonsingular**: A code is nonsingular if every source symbol maps to a unique codeword. That is, if $s_i \\neq s_j$, then their corresponding codewords $C(s_i) \\neq C(s_j)$.\n2.  **Uniquely Decodable (UD)**: A code is uniquely decodable if any finite sequence of codewords can be resolved into a sequence of source symbols in only one way. Every UD code is nonsingular.\n3.  **Prefix Code**: A code is a prefix code (or instantaneous code) if no codeword is a prefix of any other codeword. Every prefix code is uniquely decodable.\n\nFour different binary codes (A, B, C, D) are proposed for the source alphabet $\\mathcal{X}$. For each code, the set of five codewords corresponding to the five source symbols is provided.\n\nWhich one of the following codes is nonsingular but **not** uniquely decodable?\n\nA. {`101`, `00`, `11`, `101`, `01`}\nB. {`0`, `10`, `110`, `1110`, `1111`}\nC. {`00`, `10`, `01`, `011`, `111`}\nD. {`10`, `010`, `01`, `101`, `11`}",
            "solution": "We are asked to find a code that is nonsingular (all codewords distinct) but not uniquely decodable (there exists at least one finite concatenation of codewords that can be parsed in more than one way). We analyze each option with these definitions.\n\nFor option A, the set is {`101`, `00`, `11`, `101`, `01`}. Since `101` appears twice for different source symbols, the code is not nonsingular. Therefore, A cannot be the required code.\n\nFor option B, the set is {`0`, `10`, `110`, `1110`, `1111`}. Check the prefix property: no codeword is a prefix of any other. Specifically, `0` is not a prefix of any other codeword since all others begin with `1`, and `10` is not a prefix of `110`, `1110`, or `1111`; similarly, neither `110` nor `1110` is a prefix of any longer codeword in the set. Hence B is a prefix code, and therefore uniquely decodable. B is not the required code.\n\nFor option C, the set is {`00`, `10`, `01`, `011`, `111`}. This is not prefix-free because `01` is a prefix of `011`. We must test unique decodability using the Sardinas–Patterson algorithm. Let $X=\\{\\text{`00`},\\text{`10`},\\text{`01`},\\text{`011`},\\text{`111`}\\}$.\n\nCompute\n$$\nU_{1}=\\{u:\\exists x,y\\in X,\\,x\\neq y,\\;y=xu\\}.\n$$\nHere, from `011` = `01` + `1` (concatenation), we get $U_{1}=\\{\\text{`1`}\\}$.\n\nNext,\n$$\nU_{2}=\\{v:\\exists u\\in U_{1},\\,\\exists x\\in X,\\;u=xv\\text{ or }x=uv\\}.\n$$\nFor $u=`1`$, no $x\\in X$ satisfies `1`$=xv$. For $x=`10`$ and $x=`111`$, we have `10`=`1`+`0` and `111`=`1`+`11`, so $U_{2}=\\{\\text{`0`},\\text{`11`}\\}$.\n\nNext, from $U_{2}$,\n- For $u=`0`$, `00`=`0`+`0`, `01`=`0`+`1`, `011`=`0`+`11` yield $\\{\\text{`0`},\\text{`1`},\\text{`11`}\\}$.\n- For $u=`11`$, `111`=`11`+`1` yields $\\{\\text{`1`}\\}$.\nThus\n$$\nU_{3}=\\{\\text{`0`},\\text{`1`},\\text{`11`}\\}.\n$$\nCompute again:\n- From $u=`0`$, we get $\\{\\text{`0`},\\text{`1`},\\text{`11`}\\}$ as above.\n- From $u=`1`$, we get $\\{\\text{`0`},\\text{`11`}\\}$ from `10`=`1`+`0` and `111`=`1`+`11`.\n- From $u=`11`$, we get $\\{\\text{`1`}\\}$ from `111`=`11`+`1`.\nHence\n$$\nU_{4}=\\{\\text{`0`},\\text{`1`},\\text{`11`}\\}=U_{3}.\n$$\nThe sequence stabilizes without producing the empty string, so by the Sardinas–Patterson criterion, C is uniquely decodable. Therefore, C is not the required code.\n\nFor option D, the set is {`10`, `010`, `01`, `101`, `11`}. This is not prefix-free because `01` is a prefix of `010` and `10` is a prefix of `101`. We test unique decodability via Sardinas–Patterson. Let $X=\\{\\text{`10`},\\text{`010`},\\text{`01`},\\text{`101`},\\text{`11`}\\}$.\n\nCompute\n$$\nU_{1}=\\{u:\\exists x,y\\in X,\\,x\\neq y,\\;y=xu\\}.\n$$\nWe have `010`=`01`+`0` giving `0`, and `101`=`10`+`1` giving `1`, so $U_{1}=\\{\\text{`0`},\\text{`1`}\\}$.\n\nNext,\n$$\nU_{2}=\\{v:\\exists u\\in U_{1},\\,\\exists x\\in X,\\;u=xv\\text{ or }x=uv\\}.\n$$\nFrom $u=`0`$: `010`=`0`+`10` and `01`=`0`+`1` give $\\{\\text{`10`},\\text{`1`}\\}$.\nFrom $u=`1`$: `10`=`1`+`0`, `101`=`1`+`01`, `11`=`1`+`1` give $\\{\\text{`0`},\\text{`01`},\\text{`1`}\\}$.\nThus\n$$\nU_{2}=\\{\\text{`0`},\\text{`1`},\\text{`01`},\\text{`10`}\\}.\n$$\nObserve that `01`$\\in U_{2}$ and `01`$\\in X$. In the Sardinas–Patterson algorithm, the occurrence of a word from $X$ inside some $U_{n}$ implies that the empty string would appear at the next iteration, hence the code is not uniquely decodable.\n\nAn explicit ambiguity can be exhibited:\nThe sequence `01010` can be parsed as (`01`)(`010`) or as (`010`)(`10`), which are distinct parses into codewords from $X$. Therefore, D is nonsingular but not uniquely decodable.\n\nHence, the required code is D.",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}