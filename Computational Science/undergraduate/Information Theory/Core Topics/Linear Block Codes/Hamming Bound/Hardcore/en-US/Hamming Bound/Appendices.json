{
    "hands_on_practices": [
        {
            "introduction": "Let's begin with a fundamental application of the Hamming bound. This exercise challenges you to calculate the maximum number of unique messages a system can support while guaranteeing the correction of single-bit errors. By working through this classic scenario , you'll gain direct practice in applying the sphere-packing concept to a real-world design constraint.",
            "id": "1627660",
            "problem": "A deep-space probe, the *ExoScout*, is designed to analyze the atmospheric composition of exoplanets. It communicates its findings back to Earth using a fixed-length binary code. Each distinct atmospheric profile it can identify is assigned a unique 12-bit codeword. The communication channel is noisy, and it is known that during transmission, at most one bit in any given codeword can be flipped. To ensure reliable communication, the set of chosen codewords must be designed such that any received 12-bit word can be unambiguously decoded back to the correct original codeword, even with a single bit error. What is the maximum number of distinct atmospheric profiles that the *ExoScout* can be designed to report?",
            "solution": "We have a binary block code of length $n=12$ that must correct up to one bit flip per codeword. To ensure unambiguous decoding whenever at most one bit error occurs, the minimum Hamming distance between distinct codewords must satisfy $d_{\\min} \\geq 3$, which is equivalent to requiring that the Hamming spheres of radius $t=1$ around distinct codewords are disjoint.\n\nLet $M$ denote the number of codewords. The Hamming (sphere-packing) bound states that\n$$\nM \\sum_{i=0}^{t} \\binom{n}{i} \\leq 2^{n}.\n$$\nHere, $n=12$ and $t=1$, so\n$$\n\\sum_{i=0}^{1} \\binom{12}{i} = \\binom{12}{0} + \\binom{12}{1} = 1 + 12 = 13,\n$$\nand thus\n$$\nM \\cdot 13 \\leq 2^{12}.\n$$\nTherefore,\n$$\nM \\leq \\left\\lfloor \\frac{2^{12}}{13} \\right\\rfloor = \\left\\lfloor \\frac{4096}{13} \\right\\rfloor = 315.\n$$\nHence, the maximum number of distinct atmospheric profiles equals $315$.",
            "answer": "$$\\boxed{315}$$"
        },
        {
            "introduction": "The Hamming bound provides an upper limit, but what does it mean when a code doesn't meet this limit? This practice  flips the perspective by giving you a specific code and asking you to calculate how much of the total message space is left 'uncovered' by its error-correcting spheres. This provides a tangible understanding of code efficiency and why the Hamming bound is an inequality for most codes.",
            "id": "1627587",
            "problem": "An experimental communication system is designed to transmit data packets as binary strings of length $n=6$. The set of valid messages, known as the codebook, consists of $M=8$ unique binary strings, which we will call codewords.\n\nThe system incorporates a simple error-correction mechanism. When a binary string of length 6 is received, the receiver decodes it to the nearest codeword, as measured by Hamming distance. The Hamming distance between two binary strings of the same length is the number of positions at which their corresponding symbols are different. The system is designed to correctly decode any received string that has resulted from at most one single-bit flip error. This means any received string with a Hamming distance of $t=1$ or less from a unique codeword can be successfully corrected.\n\nGiven this setup, not all possible $2^6$ binary strings of length 6 are classifiable as being within a Hamming distance of 1 from one of the $M=8$ codewords. Calculate the total number of binary strings of length 6 that are *not* within a Hamming distance of 1 of any of the 8 codewords in the codebook.",
            "solution": "The problem asks for the number of binary vectors in the space of all possible vectors of length 6 that are not 'covered' by the error-correction capability of a given code.\n\nFirst, let's determine the size of the total space of possible received vectors. The vectors are binary strings of length $n=6$. Each of the 6 positions in a string can be either a 0 or a 1. Therefore, the total number of distinct binary strings is $2^n = 2^6$.\n$$|\\text{Total Space}| = 2^6 = 64$$\n\nNext, let's consider the set of vectors that *can* be corrected to a single, specific codeword. The problem states that the system can correct a received string if its Hamming distance from a unique codeword is at most $t=1$. For a single codeword $c$, the set of vectors that can be decoded to it includes the codeword itself (Hamming distance 0) and all vectors that differ from $c$ in exactly one position (Hamming distance 1).\n\nLet us calculate the size of this set for one codeword. The number of vectors at a Hamming distance of $k$ from a given vector of length $n$ is given by the binomial coefficient $\\binom{n}{k}$.\n- The number of vectors at a Hamming distance of 0 from the codeword is $\\binom{n}{0} = \\binom{6}{0} = 1$. This corresponds to the codeword itself, received without any errors.\n- The number of vectors at a Hamming distance of 1 from the codeword is $\\binom{n}{1} = \\binom{6}{1} = 6$. These correspond to all possible single-bit flip errors of the codeword.\n\nSo, the total number of vectors that are at a distance of at most 1 from a single codeword is the sum of these two quantities:\n$$|\\text{Vectors per codeword}| = \\binom{6}{0} + \\binom{6}{1} = 1 + 6 = 7$$\n\nThe codebook contains $M=8$ distinct codewords. For the system to be able to uniquely correct any single-bit error, the sets of vectors associated with each codeword (as calculated above) must be disjoint. If these sets were to overlap, a vector in the overlapping region would have a Hamming distance of 1 or 0 from two or more codewords, making the decoding process ambiguous. The problem statement guarantees unique decodability for these vectors, so we must assume these sets are disjoint.\n\nThe total number of vectors covered by the error-correction scheme for the entire codebook is the sum of the sizes of these $M=8$ disjoint sets.\n$$|\\text{Total Covered Vectors}| = M \\times |\\text{Vectors per codeword}| = 8 \\times 7 = 56$$\n\nFinally, the question asks for the number of binary strings that are *not* covered by this scheme. We can find this by subtracting the total number of covered vectors from the total number of vectors in the space.\n$$|\\text{Uncovered Vectors}| = |\\text{Total Space}| - |\\text{Total Covered Vectors}|$$\n$$|\\text{Uncovered Vectors}| = 64 - 56 = 8$$\n\nThus, there are 8 binary strings of length 6 that are not within a Hamming distance of 1 of any of the 8 codewords.",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "Now, let's explore the boundaries of code design by moving beyond binary systems. This problem  introduces the idea of 'perfect codes'—exceptionally efficient codes that meet the Hamming bound exactly—and extends the concept to general alphabets. Your task is to use the generalized Hamming bound to determine the conditions necessary for such an ideal code to exist, pushing your understanding into more abstract and powerful territory.",
            "id": "1627654",
            "problem": "In the design of a novel information storage system, data is encoded into sequences of symbols drawn from an alphabet of size $q$. Each sequence, called a codeword, has a fixed length of $n$. The system is designed to be robust against single-symbol errors that may occur during storage or retrieval.\n\nAn error-correcting code is a specific subset of all possible $q^n$ sequences. The error-correcting capability of a code is determined by the minimum number of symbol changes required to transform one codeword into another. A code that can correct any single error ($t=1$) must have its codewords sufficiently spaced out.\n\nA code is called a \"perfect code\" if the set of all possible sequences of length $n$ is completely and without overlap partitioned into spheres of radius $t$ around each codeword. A sphere of radius $t$ around a codeword consists of the codeword itself and all sequences that can be obtained by changing $t$ or fewer of its symbols. For such a perfect code, the Hamming bound is met with equality.\n\nConsider a hypothetical system with a codeword length of $n=6$ that is required to be a perfect single-error-correcting code ($t=1$). Determine the smallest possible integer value for the alphabet size $q$, where $q \\ge 2$.",
            "solution": "A $q$-ary code of length $n$ that corrects $t=1$ error is perfect if and only if the Hamming bound holds with equality:\n$$\nM \\sum_{i=0}^{1} \\binom{n}{i} (q-1)^{i} \\;=\\; q^{n},\n$$\nwhere $M$ is the number of codewords and the sphere volume is\n$$\nV_{q}(n,1) \\;=\\; \\sum_{i=0}^{1} \\binom{n}{i} (q-1)^{i} \\;=\\; 1 + n(q-1).\n$$\nFor $n=6$,\n$$\nM \\bigl(1 + 6(q-1)\\bigr) \\;=\\; q^{6},\n$$\nso a necessary condition is that $1 + 6(q-1) = 6q - 5$ divides $q^{6}$. We test the smallest integers $q \\ge 2$:\n- For $q=2$: $6q - 5 = 7$ and $q^{6} = 64$; $7 \\nmid 64$.\n- For $q=3$: $6q - 5 = 13$ and $q^{6} = 729$; $13 \\nmid 729$ since $13 \\cdot 56 = 728$.\n- For $q=4$: $6q - 5 = 19$ and $q^{6} = 4096$; $19 \\nmid 4096$ since $19 \\cdot 215 = 4085$.\n- For $q=5$: $6q - 5 = 25$ and $q^{6} = 15625$; $25 \\mid 15625$ with $M = \\frac{15625}{25} = 625$.\n\nThus $q=5$ is the smallest alphabet size for which the Hamming bound can hold with equality. To ensure existence (not just divisibility), recall the standard $q$-ary Hamming code construction: for any prime power $q$ and integer $r \\ge 2$, there exists a perfect single-error-correcting code with length\n$$\nn \\;=\\; \\frac{q^{r} - 1}{q - 1}.\n$$\nWith $q=5$ and $r=2$,\n$$\nn \\;=\\; \\frac{5^{2} - 1}{5 - 1} \\;=\\; \\frac{24}{4} \\;=\\; 6,\n$$\nwhich matches the required length. Therefore, a perfect single-error-correcting code of length $6$ exists for $q=5$, and no smaller $q \\ge 2$ satisfies the necessary divisibility condition.",
            "answer": "$$\\boxed{5}$$"
        }
    ]
}