{
    "hands_on_practices": [
        {
            "introduction": "At the heart of error correction lies a simple, powerful idea: when a message is corrupted by noise, the original was most likely the valid message that is \"closest\" to what was received. This exercise  challenges you to apply this principle, known as minimum distance decoding. You will calculate the Hamming distance—the number of positions at which two binary vectors differ—to determine the most probable intended message from a set of possibilities.",
            "id": "1622472",
            "problem": "A deep-space probe uses a simple error-correcting block code to transmit scientific data back to Earth. Due to cosmic ray interference, the channel is noisy, meaning the received binary vectors may contain errors. The system employs a minimum distance decoder. This decoder operates on the principle of choosing the valid codeword that is \"closest\" to the received vector. The measure of distance used is the Hamming distance, which is defined as the number of bit positions in which two binary vectors of the same length differ.\n\nSuppose the codebook of valid codewords consists of the following three 5-bit vectors:\n$c_1 = (1, 0, 0, 0, 1)$\n$c_2 = (0, 1, 0, 1, 1)$\n$c_3 = (1, 1, 1, 1, 0)$\n\nA vector $r = (1, 1, 0, 0, 1)$ is received at the ground station. Based on the minimum distance decoding rule, which codeword will be chosen as the most likely transmitted message, and what is the Hamming distance between the received vector and this chosen codeword?\n\nA. Codeword $c_1$, with a distance of 1.\n\nB. Codeword $c_2$, with a distance of 1.\n\nC. Codeword $c_1$, with a distance of 2.\n\nD. Codeword $c_2$, with a distance of 2.\n\nE. Codeword $c_3$, with a distance of 3.",
            "solution": "The minimum distance decoder selects the codeword that minimizes the Hamming distance to the received vector. The Hamming distance between two binary vectors $x$ and $y$ of length $n$ is defined as\n$$\nd_{H}(x,y)=\\left|\\{i\\in\\{1,\\dots,n\\}: x_{i}\\neq y_{i}\\}\\right|\\,,\n$$\nwhich equals the Hamming weight (number of ones) of the bitwise XOR: $d_{H}(x,y)=w_{H}(x\\oplus y)$.\n\nLet $r=(1,1,0,0,1)$.\n\nCompute distances:\n- With $c_{1}=(1,0,0,0,1)$:\n$$\nr\\oplus c_{1}=(0,1,0,0,0)\\,,\\quad d_{H}(r,c_{1})=1.\n$$\n- With $c_{2}=(0,1,0,1,1)$:\n$$\nr\\oplus c_{2}=(1,0,0,1,0)\\,,\\quad d_{H}(r,c_{2})=2.\n$$\n- With $c_{3}=(1,1,1,1,0)$:\n$$\nr\\oplus c_{3}=(0,0,1,1,1)\\,,\\quad d_{H}(r,c_{3})=3.\n$$\n\nThe minimum distance is $1$, achieved by $c_{1}$. Therefore, the decoder chooses $c_{1}$ with distance $1$, corresponding to option A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Knowing how to decode based on distance, the next logical step is to design codes where valid messages are intentionally separated, maximizing the chance of correct decoding. The repetition code is the most intuitive way to achieve this separation. This practice  invites you to analyze the error-correction capability of such a code, connecting its simple structure to its power to overcome a specific number of transmission errors.",
            "id": "1622492",
            "problem": "A deep-space probe, the 'Helios V', is exploring the outer solar system and sending back scientific data to Earth. Due to the vast distances and cosmic radiation, the communication channel is noisy, which can introduce random bit flips in the transmitted binary data.\n\nTo ensure data integrity, the probe's engineers have implemented a simple error correction scheme. Each single bit of original data (either a '0' or a '1') is encoded into a block of $N$ bits by simply repeating the original bit $N$ times. For this system, $N$ is always an odd integer. This is known as an $N$-bit repetition code. For example, with $N=5$, an original data bit '0' is encoded and transmitted as the block '00000', and a '1' is transmitted as '11111'.\n\nThe receiver on Earth decodes each received $N$-bit block using a majority-voting rule. It counts the number of '0's and '1's in the received block. If there are more '1's than '0's, it decodes the block as a '1'. If there are more '0's than '1's, it decodes the block as a '0'. Since $N$ is odd, a tie is not possible.\n\nThe 'Helios V' currently uses a 7-bit repetition code (i.e., $N=7$). What is the maximum number of bit errors that can occur within a single 7-bit transmitted block such that the receiver on Earth is *guaranteed* to decode the original bit correctly?",
            "solution": "In an $N$-bit repetition code with majority decoding, the receiver is guaranteed to decode correctly if the number of flipped bits, denoted $e$, is strictly less than the number of unflipped bits. The number of unflipped bits is $N - e$. The correctness condition is therefore\n$$\nN - e > e.\n$$\nSolving this inequality gives\n$$\nN > 2e \\quad \\Rightarrow \\quad e < \\frac{N}{2}.\n$$\nSince $N$ is odd, the maximum integer $e$ satisfying this is\n$$\ne_{\\max} = \\frac{N - 1}{2}.\n$$\nFor $N = 7$, this yields\n$$\ne_{\\max} = \\frac{7 - 1}{2} = 3.\n$$\nThus, up to $3$ bit errors within a $7$-bit block are guaranteed to be corrected by majority decoding; with $4$ errors, the majority can flip to the wrong value.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "An important distinction in coding theory is the difference between error detection and error correction. A code might be able to signal that an error occurred but fail to provide enough information to fix it. This final practice  explores this critical limitation using a single parity-check code, a common method for error detection. By working through this scenario, you will discover why merely identifying the presence of an error is not always sufficient for its correction.",
            "id": "1622506",
            "problem": "A simple digital communication system transmits binary datawords of length $k=7$. To allow for error detection, an even-parity check code is used. A single parity bit is appended to each 7-bit dataword to form an 8-bit codeword. The parity bit is set such that the total number of '1's in the 8-bit codeword is always even.\n\nDuring transmission, a codeword is corrupted by a single-bit error, meaning exactly one of the eight bits is flipped. The receiver correctly detects that an error has occurred because the received 8-bit word has an odd number of '1's.\n\nTo attempt error correction, the receiver's strategy is to identify all possible valid 8-bit codewords (i.e., those with an even number of '1's) that could have been the originally transmitted codeword. A codeword is considered a \"possible valid original\" if it can be obtained by flipping exactly one bit of the received corrupted word.\n\nHow many distinct, possible valid original codewords can the receiver generate using this strategy?\n\nA. 1\nB. 2\nC. 7\nD. 8\nE. 16",
            "solution": "Let the original transmitted 8-bit codeword be a vector $x \\in \\{0,1\\}^{8}$ with even parity, meaning the weight (number of ones) $w(x)$ satisfies $w(x) \\equiv 0 \\pmod{2}$. During transmission, exactly one bit is flipped, so the received word is $r = x + e_{j}$, where $e_{j}$ is the 8-dimensional unit vector with a $1$ in position $j$ and zeros elsewhere, and addition is modulo $2$. Because a single bit is flipped, the parity of $r$ is odd: $w(r) \\equiv 1 \\pmod{2}$.\n\nDefine the parity function $P(v) \\equiv w(v) \\bmod 2$. Flipping any single bit of a vector toggles its parity because the weight changes by $\\pm 1$. Formally, for any index $i \\in \\{1,\\dots,8\\}$, if we define $r^{(i)} = r + e_{i}$, then\n$$\nP\\!\\left(r^{(i)}\\right) \\equiv P(r) + 1 \\pmod{2}.\n$$\nSince $P(r) \\equiv 1 \\pmod{2}$, it follows that $P\\!\\left(r^{(i)}\\right) \\equiv 0 \\pmod{2}$ for every $i$. Therefore, each of the $8$ words obtained by flipping exactly one bit of $r$ has even parity and is thus a valid codeword under the even-parity scheme.\n\nTo count distinct possibilities, note that flipping different positions $i$ yields distinct vectors $r^{(i)}$, because $r^{(i)} \\neq r^{(j)}$ for $i \\neq j$; hence there are exactly $8$ distinct candidates. Consequently, the receiver can generate exactly $8$ distinct valid codewords as possible originals.",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}