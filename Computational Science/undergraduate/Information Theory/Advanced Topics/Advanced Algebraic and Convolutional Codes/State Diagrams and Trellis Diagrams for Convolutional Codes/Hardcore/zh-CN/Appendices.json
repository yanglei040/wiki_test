{
    "hands_on_practices": [
        {
            "introduction": "理解卷积码的第一步是掌握其核心的编码机制。这个练习将带你亲手实践一个单步编码过程，即根据编码器的当前状态和新的输入比特，利用生成序列来计算输出比特。这是构建和分析状态图与网格图的基础，也是理解卷积码如何将信息序列转化为具有纠错能力的码字的关键所在。",
            "id": "1660255",
            "problem": "考虑一个码率 $R=1/2$ 的卷积编码器。该编码器的约束长度为 $K=3$，由两个生成序列 $g_1 = [1, 1, 0]$ 和 $g_2 = [1, 0, 1]$ 定义。在任意时刻 $k$，编码器的状态由当前输入比特之前的两个最近的输入比特决定，即状态为 $s_k = (u_{k-1}, u_{k-2})$，其中 $u$ 是输入比特序列。对于每个输入比特 $u_k$，编码器的输出包含两个比特 $(v_k^{(1)}, v_k^{(2)})$。计算使用模2算术进行。\n\n假设编码器处于由二进制字符串 '10' 表示的状态（即 $u_{k-1}=1$ 且 $u_{k-2}=0$）。如果下一个输入比特为 $u_k = 1$，生成的相应双比特输出序列 $(v_k^{(1)}, v_k^{(2)})$ 是什么？\n\nA. 00\n\nB. 01\n\nC. 10\n\nD. 11",
            "solution": "一个码率 $R=\\frac{1}{2}$、约束长度 $K=3$、生成序列为 $g_{1}=[1,1,0]$ 和 $g_{2}=[1,0,1]$ 的卷积编码器，对于每个输入比特 $u_{k}$，产生两个输出比特。这两个输出比特由当前及前两个输入比特的模2线性组合定义：\n$$\nv_{k}^{(1)}=u_{k}\\cdot g_{1,0}\\oplus u_{k-1}\\cdot g_{1,1}\\oplus u_{k-2}\\cdot g_{1,2},\\qquad\nv_{k}^{(2)}=u_{k}\\cdot g_{2,0}\\oplus u_{k-1}\\cdot g_{2,1}\\oplus u_{k-2}\\cdot g_{2,2},\n$$\n其中 $\\oplus$ 表示模2加法，$g_{i,j}$ 是 $g_{i}$ 的第 $j$ 个元素，分别对应于 $u_{k},u_{k-1},u_{k-2}$ 上的抽头。\n\n给定状态 $s_{k}=(u_{k-1},u_{k-2})=(1,0)$ 和输入 $u_{k}=1$，我们代入表达式中：\n$$\nv_{k}^{(1)}=1\\cdot 1\\oplus 1\\cdot 1\\oplus 0\\cdot 0=1\\oplus 1\\oplus 0=0,\n$$\n$$\nv_{k}^{(2)}=1\\cdot 1\\oplus 1\\cdot 0\\oplus 0\\cdot 1=1\\oplus 0\\oplus 0=1.\n$$\n因此，双比特输出为 $(v_{k}^{(1)},v_{k}^{(2)})=(0,1)$，这对应于选项B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在掌握了单步编码后，下一个自然而然的步骤是理解编码器如何处理一个连续的输入序列。本练习要求你追踪编码器在接收一个比特序列时的完整动态过程，包括状态的连续更新和相应输出的生成。通过这个练习，你将更深刻地体会到编码器的“记忆”是如何影响其行为的，并且通过一个非零的初始状态，你会发现这个原理的普适性。",
            "id": "1660233",
            "problem": "一个码率 $R=1/2$ 的卷积编码器由一个包含两个存储单元（D触发器）的移位寄存器构成。在任意时刻 $k$，编码器的状态可以用存储在这两个寄存器中的有序比特对表示，即 $S_k = (M_{1,k}, M_{2,k})$。在每个时间步，单个输入比特 $u_k$ 进入编码器。根据当前输入和当前状态，生成两个输出比特 $v_k^{(1)}$ 和 $v_k^{(2)}$。输出生成的逻辑由以下方程定义，其中所有加法均为模2加法（异或运算）：\n\n$$v_k^{(1)} = u_k + M_{1,k} + M_{2,k}$$\n$$v_k^{(2)} = u_k + M_{2,k}$$\n\n在计算出输出后，寄存器的状态会更新以用于下一个时间步 $k+1$。新的比特 $u_k$ 被移入第一个寄存器，而第一个寄存器中的比特被移入第二个寄存器。也就是说，下一个状态是 $S_{k+1} = (u_k, M_{1,k})$。\n\n假设编码器不处于常规的全零初始状态。而是在时刻 $k=1$ 时的初始状态为 $S_1 = (0, 1)$。然后，向编码器输入两位输入序列 '10'（即 $u_1 = 1$ 和 $u_2 = 0$）。\n\n将第一个输出块 $(v_1^{(1)}, v_1^{(2)})$ 和第二个输出块 $(v_2^{(1)}, v_2^{(2)})$ 连接起来，得到的4比特输出序列是什么？\n\n从以下选项中选择正确的序列。\n\nA. 0010\n\nB. 1110\n\nC. 0101\n\nD. 0001\n\nE. 1111",
            "solution": "给定一个码率为 $R=\\frac{1}{2}$ 的卷积编码器，其状态为 $S_{k}=(M_{1,k},M_{2,k})$，输出为\n$$v_{k}^{(1)}=u_{k}+M_{1,k}+M_{2,k},\\quad v_{k}^{(2)}=u_{k}+M_{2,k},$$\n其中所有加法均为模2加法，状态更新为\n$$S_{k+1}=(u_{k},M_{1,k}).$$\n初始状态为 $S_{1}=(0,1)$，输入为 $u_{1}=1$，$u_{2}=0$。\n\n在 $k=1$ 时的步骤：\n给定 $S_{1}=(M_{1,1},M_{2,1})=(0,1)$ 和 $u_{1}=1$，\n$$v_{1}^{(1)}=u_{1}+M_{1,1}+M_{2,1}=1+0+1=0,$$\n$$v_{1}^{(2)}=u_{1}+M_{2,1}=1+1=0.$$\n更新状态：\n$$S_{2}=(u_{1},M_{1,1})=(1,0).$$\n\n在 $k=2$ 时的步骤：\n给定 $S_{2}=(M_{1,2},M_{2,2})=(1,0)$ 和 $u_{2}=0$，\n$$v_{2}^{(1)}=u_{2}+M_{1,2}+M_{2,2}=0+1+0=1,$$\n$$v_{2}^{(2)}=u_{2}+M_{2,2}=0+0=0.$$\n\n将 $(v_{1}^{(1)},v_{1}^{(2)})=(0,0)$ 和 $(v_{2}^{(1)},v_{2}^{(2)})=(1,0)$ 连接起来，得到4比特序列 $0010$，这对应于选项A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "现在，让我们将所学知识应用于一个更具实际意义的场景。在许多通信系统中，我们需要在数据块传输结束后将编码器“复位”到全零状态，以确保下一个数据块能从一个已知的、干净的状态开始。这个问题挑战你逆向思考：不再是根据给定的输入计算输出，而是要找到一个特定的输入序列（称为“终止序列”），以引导编码器从一个非零状态回到全零状态。解决这个问题标志着你对编码器状态转移的理解已从被动追踪提升到了主动控制的层次。",
            "id": "1660254",
            "problem": "在现代数字通信系统中，递归卷积码因其优异的性能特点而常被使用。一项关键操作是通过将编码器的存储器驱动回全零状态来终止一个数据块。这确保了后续的数据块从一个已知的、干净的状态开始。\n\n考虑一个码率为 $R=1/1$、具有三个存储单元的特定递归卷积编码器。编码器在任意时刻的状态由一个三元二进制数组 $S = (s_2, s_1, s_0)$ 表示。编码器在每个时间步处理单个输入比特 $u$，以产生一个新的状态。状态更新机制如下：\n1. 根据输入 $u$ 和当前状态比特 $s_2$ 和 $s_0$ 计算一个临时反馈比特 $a$。其关系由 $a = u \\oplus s_2 \\oplus s_0$ 给出，其中 $\\oplus$ 表示模2加法（异或运算）。\n2. 编码器的下一个状态 $S' = (s'_2, s'_1, s'_0)$ 通过将反馈比特 $a$ 移入寄存器来确定：$s'_2 = a$，$s'_1 = s_2$，$s'_0 = s_1$。\n\n假设在编码一个长数据序列后，编码器处于状态 $S_{initial} = (1, 1, 1)$。为了准备下一次传输，必须发送一个特殊的终止输入比特序列，以将编码器驱动到全零状态 $S_{final} = (0, 0, 0)$。\n\n将编码器从状态 $(1, 1, 1)$ 转换到状态 $(0, 0, 0)$ 的最短输入比特序列是什么？\n\nA. 110\n\nB. 011\n\nC. 101\n\nD. 001\n\nE. 111",
            "solution": "设初始状态为 $S_{0}=(s_{2}^{(0)},s_{1}^{(0)},s_{0}^{(0)})=(1,1,1)$。对于在连续时间点施加的输入 $u_{0},u_{1},u_{2}$，在时间 $t$ 的反馈为 $a_{t}=u_{t}\\oplus s_{2}^{(t)}\\oplus s_{0}^{(t)}$，下一个状态由 $s_{2}^{(t+1)}=a_{t}$，$s_{1}^{(t+1)}=s_{2}^{(t)}$，$s_{0}^{(t+1)}=s_{1}^{(t)}$ 给出。\n\n步骤 $t=0$，输入为 $u_{0}$：\n$$\na_{0}=u_{0}\\oplus 1\\oplus 1=u_{0},\\quad S_{1}=(s_{2}^{(1)},s_{1}^{(1)},s_{0}^{(1)})=(u_{0},1,1).\n$$\n\n步骤 $t=1$，输入为 $u_{1}$：\n$$\na_{1}=u_{1}\\oplus s_{2}^{(1)}\\oplus s_{0}^{(1)}=u_{1}\\oplus u_{0}\\oplus 1,\n$$\n$$\nS_{2}=(s_{2}^{(2)},s_{1}^{(2)},s_{0}^{(2)})=(u_{1}\\oplus u_{0}\\oplus 1,\\;u_{0},\\;1).\n$$\n\n步骤 $t=2$，输入为 $u_{2}$：\n$$\na_{2}=u_{2}\\oplus s_{2}^{(2)}\\oplus s_{0}^{(2)}=u_{2}\\oplus(u_{1}\\oplus u_{0}\\oplus 1)\\oplus 1=u_{2}\\oplus u_{1}\\oplus u_{0},\n$$\n$$\nS_{3}=(s_{2}^{(3)},s_{1}^{(3)},s_{0}^{(3)})=(u_{2}\\oplus u_{1}\\oplus u_{0},\\;u_{1}\\oplus u_{0}\\oplus 1,\\;u_{0}).\n$$\n\n为了达到 $S_{3}=(0,0,0)$，在模2算术下求解以下方程组：\n$$\nu_{2}\\oplus u_{1}\\oplus u_{0}=0,\\quad u_{1}\\oplus u_{0}\\oplus 1=0,\\quad u_{0}=0.\n$$\n由 $u_{0}=0$，第二个方程给出 $u_{1}\\oplus 1=0$，因此 $u_{1}=1$。然后第一个方程给出 $u_{2}\\oplus 1=0$，因此 $u_{2}=1$。所以，唯一的3比特序列是 $(u_{0},u_{1},u_{2})=(0,1,1)$，即 011。\n\n在少于3个步骤内终止是不可能的：经过两步后，$S_{2}=(u_{1}\\oplus u_{0}\\oplus 1,\\;u_{0},\\;1)$ 始终有 $s_{0}^{(2)}=1\\neq 0$，所以 $S_{2}\\neq(0,0,0)$。因此，最短序列是 011，这对应于选项 B。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}