{
    "hands_on_practices": [
        {
            "introduction": "要掌握卷积码，第一步是亲手操作其编码过程。这个练习提供了一个具体的场景：一个输入消息序列是如何根据编码器的生成规则和记忆状态，一步步被转换成编码后的输出比特流 。掌握这项基本技能是进行后续所有分析，包括解码和性能评估的基石。",
            "id": "1614381",
            "problem": "一艘深空探测器利用一个简单的前向纠错（FEC）系统来保护其遥测数据。该系统采用一个码率为 $R = 1/2$、记忆深度为 $\\nu=2$ 的卷积编码器。这意味着对于输入消息的每一位，编码器会产生两位输出，并且其计算依赖于当前输入位和前两位输入位。\n\n编码器的操作由两个生成连接定义。设时间步 $k$ 的输入消息位为 $m_k$。前两个消息位 $m_{k-1}$ 和 $m_{k-2}$ 存储在编码器的存储寄存器中。在时间步 $k$ 的两个输出位，记作 $c_k^{(1)}$ 和 $c_k^{(2)}$，由以下规则生成，其中所有加法均为模2加法：\n$$\n\\begin{cases}\nc_k^{(1)} = m_k + m_{k-1} + m_{k-2} \\\\\nc_k^{(2)} = m_k + m_{k-2}\n\\end{cases}\n$$\n假设编码器初始处于全零状态，意味着在处理第一个消息位之前，对应于 $m_{k-1}$ 和 $m_{k-2}$ 的存储寄存器均为零。编码器的任务是编码输入消息序列 $m = (1, 1, 0, 1)$。最终输出是通过交织两个输出序列形成的单个比特流，即 $c = (c_1^{(1)}, c_1^{(2)}, c_2^{(1)}, c_2^{(2)}, c_3^{(1)}, c_3^{(2)}, \\dots)$。\n\n编码输出序列的前8位是什么？\n\nA. 11101000\n\nB. 11000101\n\nC. 11010100\n\nD. 11100001\n\nE. 01100110",
            "solution": "所有加法均为模2加法。编码器有两位先前比特的记忆，初始状态为 $m_{0}=0$ 和 $m_{-1}=0$。生成规则为\n$$\n\\begin{cases}\nc_{k}^{(1)}=m_{k}+m_{k-1}+m_{k-2},\\\\\nc_{k}^{(2)}=m_{k}+m_{k-2}.\n\\end{cases}\n$$\n给定 $m=(m_{1},m_{2},m_{3},m_{4})=(1,1,0,1)$，对每个 $k$ 进行计算：\n\n对于 $k=1$：$m_{1}=1$, $m_{0}=0$, $m_{-1}=0$,\n$$\nc_{1}^{(1)}=1+0+0=1,\\quad c_{1}^{(2)}=1+0=1.\n$$\n\n对于 $k=2$：$m_{2}=1$, $m_{1}=1$, $m_{0}=0$,\n$$\nc_{2}^{(1)}=1+1+0=0,\\quad c_{2}^{(2)}=1+0=1.\n$$\n\n对于 $k=3$：$m_{3}=0$, $m_{2}=1$, $m_{1}=1$,\n$$\nc_{3}^{(1)}=0+1+1=0,\\quad c_{3}^{(2)}=0+1=1.\n$$\n\n对于 $k=4$：$m_{4}=1$, $m_{3}=0$, $m_{2}=1$,\n$$\nc_{4}^{(1)}=1+0+1=0,\\quad c_{4}^{(2)}=1+1=0.\n$$\n\n交织后得到\n$$\nc=(c_{1}^{(1)},c_{1}^{(2)},c_{2}^{(1)},c_{2}^{(2)},c_{3}^{(1)},c_{3}^{(2)},c_{4}^{(1)},c_{4}^{(2)})=(1,1,0,1,0,1,0,0),\n$$\n这对应于 $11010100$，即选项C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "并非所有编码器在纠正错误方面都同样有效，其性能优劣需要量化指标来衡量。“自由距离” ($d_{\\text{free}}$) 是衡量卷积码纠错能力的关键参数，更大的自由距离通常意味着更强的纠错性能。本练习将引导你超越简单的编码计算，通过分析两个不同编码器的结构特性来计算它们的自由距离，从而判断哪一个设计更为优越 。",
            "id": "1614368",
            "problem": "在设计数字通信系统时，两位工程师提出了用于前向纠错的不同卷积编码器。两种编码器的码率均为 $R=1/2$，记忆深度均为 $\\nu=2$。所有运算都在二元域 $\\mathrm{GF}(2)$ 上进行。\n\n编码器在时间 $t$ 的状态由前两个消息比特决定，即 $s_t=(m_{t-1}, m_{t-2})$。在时间 $t$ 的输出，即一对比特 $(c_t^{(1)}, c_t^{(2)})$，是通过将输入消息序列 $m = (m_0, m_1, m_2, \\dots)$ 与编码器的生成向量进行卷积生成的。\n\n提出的两种设计如下：\n\n**编码器A：**\n- 第一个输出比特的生成向量：$g_A^{(1)} = (1, 1, 1)$\n- 第二个输出比特的生成向量：$g_A^{(2)} = (1, 0, 1)$\n- 输出比特计算如下：$c_t^{(1)} = m_t + m_{t-1} + m_{t-2}$ 和 $c_t^{(2)} = m_t + m_{t-2}$。\n\n**编码器B：**\n- 第一个输出比特的生成向量：$g_B^{(1)} = (1, 1, 0)$\n- 第二个输出比特的生成向量：$g_B^{(2)} = (1, 1, 1)$\n- 输出比特计算如下：$c_t^{(1)} = m_t + m_{t-1}$ 和 $c_t^{(2)} = m_t + m_{t-1} + m_{t-2}$。\n\n卷积码的纠错能力主要由其自由距离 $d_{\\text{free}}$ 决定，自由距离定义为任意非零码字的最小汉明重量。更大的自由距离表示码的纠错能力更强。\n\n你的任务是评估这两种设计。计算每个编码器的自由距离 $d_{\\text{free, A}}$ 和 $d_{\\text{free, B}}$，并确定哪种设计更优。从以下选项中选择正确的陈述。\n\nA. $d_{\\text{free, A}} = 4$，$d_{\\text{free, B}} = 5$；编码器B更优。\n\nB. $d_{\\text{free, A}} = 5$，$d_{\\text{free, B}} = 4$；编码器A更优。\n\nC. $d_{\\text{free, A}} = 5$，$d_{\\text{free, B}} = 5$；两种编码器的性能相当。\n\nD. $d_{\\text{free, A}} = 6$，$d_{\\text{free, B}} = 5$；编码器A更优。\n\nE. $d_{\\text{free, A}} = 5$，$d_{\\text{free, B}} = 6$；编码器B更优。",
            "solution": "我们在 $\\mathrm{GF}(2)$ 上进行运算，所以所有加法都是模2加法。自由距离 $d_{\\text{free}}$ 是任意非零码字的最小汉明重量。对于一个码率为 $\\frac{1}{2}$、记忆深度为 $\\nu=2$ 的编码器，其网格图状态为 $s_{t}=(m_{t-1},m_{t-2})$。为了找到 $d_{\\text{free}}$，我们考虑从全零状态开始，在第一个非零输入处（不失一般性，设在 $t=0$ 时 $m_{0}=1$）发散，并尽快重新汇合到全零状态的路径（因为 $\\nu=2$，这需要两个尾随的零）。然后我们最小化这条发散-汇合路径上的总输出汉明重量。\n\n编码器A的生成向量为 $g_{A}^{(1)}=(1,1,1)$ 和 $g_{A}^{(2)}=(1,0,1)$，所以\n$$\nc_{t}^{(1)}=m_{t}+m_{t-1}+m_{t-2},\\qquad c_{t}^{(2)}=m_{t}+m_{t-2}.\n$$\n从状态 $(0,0)$ 开始，并令 $m_{0}=1$。已知 $m_{-1}=m_{-2}=0$：\n- 在 $t=0$ 时：$c_{0}^{(1)}=1$, $c_{0}^{(2)}=1$，所以分支重量为 $2$。\n- 在 $t=1$ 时，对于一个通用的 $m_{1}\\in\\{0,1\\}$ 且 $(m_{0},m_{-1})=(1,0)$：\n$$\nc_{1}^{(1)}=m_{1}+1+0=m_{1}+1,\\qquad c_{1}^{(2)}=m_{1}+0=m_{1}.\n$$\n如果 $c_{1}^{(1)}=0$ 和 $c_{1}^{(2)}=0$ 同时成立，那么 $m_{1}+1=0$ 且 $m_{1}=0$，这是不可能的。因此，在 $t=1$ 时的分支重量至少为 $1$。当 $m_{1}=0$ 时达到最小值，此时 $(c_{1}^{(1)},c_{1}^{(2)})=(1,0)$，重量为 $1$。\n- 为了在最早的时间 $t=3$ 重新汇合到 $(0,0)$，我们必须设置 $(m_{2},m_{1})=(0,0)$。那么在 $t=2$ 时，对于 $(m_{2},m_{1},m_{0})=(0,0,1)$，我们得到\n$$\nc_{2}^{(1)}=0+0+1=1,\\qquad c_{2}^{(2)}=0+1=1,\n$$\n所以分支重量为 $2$。\n\n因此，沿最早汇合路径的最小总重量为 $2+1+2=5$，通过输入 $(m_{0},m_{1},m_{2})=(1,0,0)$ 实现。因此 $d_{\\text{free,A}}=5$。\n\n编码器B的生成向量为 $g_{B}^{(1)}=(1,1,0)$ 和 $g_{B}^{(2)}=(1,1,1)$，所以\n$$\nc_{t}^{(1)}=m_{t}+m_{t-1},\\qquad c_{t}^{(2)}=m_{t}+m_{t-1}+m_{t-2}.\n$$\n从状态 $(0,0)$ 开始并令 $m_{0}=1$：\n- 在 $t=0$ 时：$c_{0}^{(1)}=1$, $c_{0}^{(2)}=1$，分支重量为 $2$。\n- 在 $t=1$ 时，对于通用的 $m_{1}$ 且 $(m_{0},m_{-1})=(1,0)$：\n$$\nc_{1}^{(1)}=m_{1}+1,\\qquad c_{1}^{(2)}=m_{1}+1+0=m_{1}+1.\n$$\n选择 $m_{1}=1$ 使得 $(c_{1}^{(1)},c_{1}^{(2)})=(0,0)$，即分支重量为 $0$，状态为 $(m_{1},m_{0})=(1,1)$。\n- 为了在最早的时间 $t=4$ 重新汇合，设置 $m_{2}=0$ 和 $m_{3}=0$。那么\n在 $t=2$ 时，对于 $(m_{2},m_{1},m_{0})=(0,1,1)$：\n$$\nc_{2}^{(1)}=0+1=1,\\qquad c_{2}^{(2)}=0+1+1=0,\n$$\n分支重量为 $1$；\n在 $t=3$ 时，对于 $(m_{3},m_{2},m_{1})=(0,0,1)$：\n$$\nc_{3}^{(1)}=0+0=0,\\qquad c_{3}^{(2)}=0+0+1=1,\n$$\n分支重量为 $1$。\n\n因此，沿这条最早汇合路径的总重量为 $2+0+1+1=4$，通过输入 $(m_{0},m_{1},m_{2},m_{3})=(1,1,0,0)$ 实现。不可能将总和减少到 $4$ 以下：第一个分支的重量为 $2$，通过选择 $m_{1}=1$ 第二个分支可以是 $0$，并且（在状态 $(1,1)$ 下）为了重新汇合所必需的两个后续分支不能同时为 $0$。因此 $d_{\\text{free,B}}=4$。\n\n比较可知，$d_{\\text{free,A}}=5$ 且 $d_{\\text{free,B}}=4$，所以编码器A更优。正确选项是 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "一个好的编码设计不仅需要有足够大的自由距离，还必须避免某些结构上的缺陷，否则可能导致灾难性的译码错误。这个练习探讨了“灾难性编码器”这一重要概念，在这种编码器中，信道中有限数量的错误可能导致维特比译码器产生无限的译码错误 。通过这个思想实验，你将理解为什么在实际应用中选择非灾难性的生成多项式至关重要。",
            "id": "1614420",
            "problem": "一个信息论系统采用一个速率为 $R=1/2$ 的卷积编码器来保护在噪声信道上传输的数据。该编码器是一个线性时不变系统，它处理输入信息序列 $u = (u_1, u_2, u_3, \\dots)$ 以生成编码序列 $c = (c_1, c_2, c_3, \\dots)$，其中每个 $c_k = (c_k^{(1)}, c_k^{(2)})$ 是一对输出比特。该编码器由其在延迟域中的生成多项式定义，$g^{(1)}(D) = 1+D$ 和 $g^{(2)}(D) = 1+D^2$。\n\n输入序列变换 $u(D) = \\sum_{k=1}^{\\infty} u_k D^{k-1}$ 与输出序列变换 $c^{(j)}(D) = \\sum_{k=1}^{\\infty} c_k^{(j)} D^{k-1}$ 之间的关系由 $c^{(j)}(D) = u(D)g^{(j)}(D)$ 给出。这对应于时域关系 $c_k^{(1)} = u_k + u_{k-1}$ 和 $c_k^{(2)} = u_k + u_{k-2}$，其中所有加法都是模2加法。假设编码器从全零状态开始，即对于所有 $k \\le 0$，$u_k = 0$。\n\n假设发送的信息序列是全零序列，即对于所有 $k \\ge 1$，$u_k = 0$。由于信道噪声，引入了有限数量的错误，接收到的序列为 $r = (11, 01, 00, 00, 00, \\dots)$。接收端使用维特比译码器来估计原始信息序列，我们将其表示为 $\\hat{u} = (\\hat{u}_1, \\hat{u}_2, \\hat{u}_3, \\dots)$。维特比算法寻找通过编码器状态网格图的路径，该路径与接收序列 $r$ 的总汉明距离最小。\n\n假设译码器的回溯深度足够大，以下哪个陈述正确描述了对于时间索引 $k \\ge 3$ 的最终译码信息序列 $\\{\\hat{u}_k\\}$？\n\nA. 对于所有 $k \\ge 3$，$\\hat{u}_k = 0$。\n\nB. 对于所有 $k \\ge 3$，$\\hat{u}_k = 1$。\n\nC. 该序列是交替的，对于奇数 $k \\ge 3$，$\\hat{u}_k = 1$；对于偶数 $k \\ge 3$，$\\hat{u}_k = 0$。\n\nD. 译码器出现一个错误但已恢复，$\\hat{u}_3=1$ 且对于所有 $k \\ge 4$，$\\hat{u}_k=0$。\n\nE. 译码器的输出是周期为 3 的周期序列，对于 $k \\ge 3$ 形如 $(\\dots, 1, 1, 0, 1, 1, 0, \\dots)$。",
            "solution": "编码器的存储器深度为 $m=2$，在时间 $k$ 的状态由 $(u_{k-1},u_{k-2})$ 给出。在状态 $(a,b)=(u_{k-1},u_{k-2})$ 时，输入为 $u_{k}\\in\\{0,1\\}$，输出为\n$$\nc_{k}^{(1)}=u_{k}+a,\\qquad c_{k}^{(2)}=u_{k}+b,\n$$\n且下一状态为 $(u_{k},a)$。接收到的序列为 $r_{1}=(1,1)$，$r_{2}=(0,1)$，并且对于所有 $k\\ge 3$，$r_{k}=(0,0)$。维特比译码器选择与 $\\{r_{k}\\}$ 的总汉明距离最小的路径。\n\n首先，观察到对于所有 $k\\ge 1$，信息序列 $u_{k}=1$ 会产生\n$$\nc_{1}=(u_{1}+u_{0},u_{1}+u_{-1})=(1,1),\n$$\n$$\nc_{2}=(u_{2}+u_{1},u_{2}+u_{0})=(0,1),\n$$\n$$\nc_{3}=(u_{3}+u_{2},u_{3}+u_{1})=(0,0),\n$$\n并且对于所有 $k\\ge 4$，$c_{k}=(u_{k}+u_{k-1},u_{k}+u_{k-2})=(0,0)$。因此，该码字与 $r$ 完全匹配，总汉明距离为 $0$。相比之下，全零输入产生的 $c_{1}=(0,0)$ 和 $c_{2}=(0,0)$ 与 $r_{1}$ 和 $r_{2}$ 不同，总汉明距离为 $3$，而对于 $k\\ge 3$ 与 $r_{k}$ 匹配。\n\n为了通过网格图度量来确认，从 $k=0$ 时的全零状态 $(0,0)$ 开始：\n- 在 $k=1$ 时，从 $(0,0)$ 出发：\n  - 输入 $0$ 产生输出 $(0,0)$，与 $r_{1}=(1,1)$ 的汉明距离为 $2$，下一状态为 $(0,0)$。\n  - 输入 $1$ 产生输出 $(1,1)$，距离为 $0$，下一状态为 $(1,0)$。\n  幸存路径：在 $(1,0)$ 状态的度量为 $0$，在 $(0,0)$ 状态的度量为 $2$。\n- 在 $k=2$ 时，使用 $r_{2}=(0,1)$：\n  - 从 $(1,0)$ 出发，输入为 $1$：输出为 $(0,1)$，距离为 $0$，下一状态为 $(1,1)$，度量为 $0$。\n  - 其他转移在其他状态产生的度量为 $2$ 或 $3$。\n  幸存路径：在 $(1,1)$ 状态的度量 $0$ 是严格最优的。\n- 在 $k=3$ 时，使用 $r_{3}=(0,0)$：\n  - 从 $(1,1)$ 出发，输入为 $1$：输出为 $(0,0)$，距离为 $0$，下一状态为 $(1,1)$，度量保持为 $0$。\n  - 所有其他幸存路径都有严格更大的度量。\n因此，从 $k=2$ 开始，最优路径停留在状态 $(1,1)$，度量为 $0$。并且，由于对于所有 $k\\ge 3$，$r_{k}=(0,0)$，该路径会继续以输入 $u_{k}=1$（这会保持输出 $(0,0)$ 和状态 $(1,1)$）进行，而不会累积任何额外的距离。因此，在足够大的回溯深度下，译码出的序列与全1路径一致，这意味着\n$$\n\\hat{u}_{k}=1\\quad\\text{对于所有 }k\\ge 3.\n$$\n这对应于选项B。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}