## 引言
在数字通信的世界里，如何确保信息在充满噪声和干扰的信道中准确无误地传输，是一个永恒的挑战。从手机通话到深空探测，数据的可靠性是所有信息系统的基石。卷积码作为一种强大而高效的前向[纠错](@entry_id:273762)（FEC）技术，正是为应对这一挑战而生。与一次性处理整个[数据块](@entry_id:748187)的分组码不同，卷积码以连续、带有“记忆”的方式进行编码，使其特别适用于处理连续的[数据流](@entry_id:748201)，并在性能和复杂度之间提供了灵活的平衡。

本文将带领您系统地探索卷积码的世界。您将学习到：

在 **“原理与机制”** 一章中，我们将深入剖析卷积码的内部构造，理解其如何通过移位寄存器和[生成多项式](@entry_id:265173)工作，并掌握[状态图](@entry_id:176069)和[网格图](@entry_id:261673)等关键分析工具。

随后的 **“应用与[交叉](@entry_id:147634)学科联系”** 一章，将理论付诸实践。我们将探讨维特比译码的实现细节、性能分析方法，并展示卷积码如何通过删余、交织等技术集成到现代[通信系统](@entry_id:265921)中，甚至启发了Turbo码和[量子编码](@entry_id:141173)等前沿领域。

最后，在 **“动手实践”** 部分，您将通过解决一系列精心设计的问题，亲手操作编码过程、评估码的性能并识别设计缺陷，从而将理论知识转化为牢固的实践技能。

现在，让我们从卷积码最基本的原理开始，揭开其高效纠错能力背后的秘密。

## 原理与机制

与分组码将信息块独立编码不同，卷积码在编码过程中引入了记忆。编码器在任何给定时刻的输出不仅取决于当前的输入比特，还取决于先前的一些输入比特。这种记忆特性使得卷积码成为一种功能强大的纠错码，特别适用于连续的[数据流](@entry_id:748201)传输。本章将深入探讨卷积码的基本原理、结构表示、关键特性以及设计中的核心权衡。

### 卷积码的结构与参数

从结构上看，一个二进制卷积编码器可以被视为一个由[移位寄存器](@entry_id:754780)、模2加法器（[异或门](@entry_id:162892)）和多路复用器组成的[线性时不变](@entry_id:276287)（LTI）系统。信息比特流顺序进入[移位寄存器](@entry_id:754780)，编码器的输出是通过对寄存器中的比特（包括当前输入比特）进行线性组合（[异或](@entry_id:172120)运算）来生成的。

为了精确描述一个卷积编码器，我们需要定义几个核心参数。

#### 码率、记忆阶数与约束长度

一个卷积编码器的最基本参数是其 **[码率](@entry_id:176461) (Code Rate)**，记为 $R$。码率定义为输入比特数 $k$ 与对应输出比特数 $n$ 的比值，即 $R = k/n$。例如，一个每次接收1个输入比特并产生3个输出比特的编码器，其[码率](@entry_id:176461)就是 $R = 1/3$ 。同样，若输入1比特，输出2比特，则[码率](@entry_id:176461) $R = 1/2$ 。在实际应用中，低[码率](@entry_id:176461)（如 $1/3$ 或 $1/4$）通常意味着更高的冗余度，从而提供更强的[纠错](@entry_id:273762)能力。

编码器的“记忆”是其核心特征。**记忆阶数 (Memory Order)**，通常表示为 $m$ 或 $\nu$，定义了当前输出所依赖的先前输入比特的最大数量。换言之，它等于编码器中用于存储先前输入比特的寄存器单元的数量（对于 $k=1$ 的情况）。

另一个密切相关的参数是 **约束长度 (Constraint Length)**，记为 $K$。它衡量了单个输入比特能够影响的连续输出比特的总跨度。对于 $k=1$ 的编码器，约束长度与记忆阶数的关系通常定义为 $K = m + 1$。这里的“+1”代表当前输入的比特。因此，约束长度 $K$ 表示生成任何一个输出比特所依赖的输入比特总数（当前比特加上 $m$ 个先前比特）。

#### 生成序列与[生成多项式](@entry_id:265173)

为了完整地描述编码器的运算，我们需要指定[移位寄存器](@entry_id:754780)上的抽头位置，即哪些比特参与了每个输出的异或运算。这可以通过两种等价的方式来表示：生成序列和[生成多项式](@entry_id:265173)。

**生成序列 (Generator Sequences)** 是一组向量，每个向量对应一个输出。例如，对于一个 $R=1/2$、记忆阶数 $m=4$ 的编码器，我们可能有两个生成序列 $g^{(1)} = (1, 1, 0, 1, 1)$ 和 $g^{(2)} = (1, 0, 1, 1, 0)$ 。每个序列的长度为 $m+1=5$。$g^{(1)}$ 的第一个元素 '1' 表示第一个输出比特依赖于当前输入比特，第二个 '1' 表示它依赖于前一个输入比特，第三个 '0' 表示不依赖于前两个的输入比特，以此类推。

一种更紧凑且在代数上更方便的表示方法是 **[生成多项式](@entry_id:265173) (Generator Polynomials)**。这是一种在延迟算子 $D$ 下的多项式，其中 $D^i$ 表示延迟 $i$ 个时间单位。上述生成序列可以等价地写成[生成多项式](@entry_id:265173)：
$g^{(1)}(D) = 1 + D + D^3 + D^4$
$g^{(2)}(D) = 1 + D^2 + D^3$

编码器的记忆阶数 $m$ 就是所有[生成多项式](@entry_id:265173)中的最高次数。在上述例子中，$\deg(g^{(1)}(D)) = 4$ 且 $\deg(g^{(2)}(D)) = 3$，因此 $m = \max(4, 3) = 4$ 。如果给定一个编码器的所有[生成多项式](@entry_id:265173)，例如 $g^{(1)}(D) = 1 + D^2 + D^4$, $g^{(2)}(D) = 1 + D + D^3$, $g^{(3)}(D) = 1 + D + D^2 + D^4$，我们可以立刻确定其记忆阶数为 $m = \max(4, 3, 4) = 4$，约束长度为 $K=m+1=5$ 。

#### 编码过程：卷积运算

“卷积”之名源于其编码过程。如果我们将输入[比特流](@entry_id:164631)表示为一个多项式 $U(D) = u_0 + u_1D + u_2D^2 + \dots$，那么第 $i$ 个输出流的码字多项式 $V^{(i)}(D)$ 就是输入多项式 $U(D)$ 与第 $i$ 个[生成多项式](@entry_id:265173) $g^{(i)}(D)$ 的乘积（在GF(2)上）：
$V^{(i)}(D) = U(D) g^{(i)}(D)$
这个多项式乘法在时域上等价于输入序列与生成序列的[离散卷积](@entry_id:160939)。

让我们通过一个具体的例子来演示编码过程 。考虑一个[码率](@entry_id:176461)为 $R=1/3$、约束长度 $K=3$（即记忆阶数 $m=2$）的编码器。其[生成多项式](@entry_id:265173)由八[进制](@entry_id:634389)表示 $g^{(1)}=(7)_8$, $g^{(2)}=(5)_8$, $g^{(3)}=(6)_8$ 给出。转换为二[进制](@entry_id:634389)（长度为 $K=3$），我们得到：
$g^{(1)} = (111)_2 \implies g^{(1)}(D) = 1 + D + D^2$
$g^{(2)} = (101)_2 \implies g^{(2)}(D) = 1 + D^2$
$g^{(3)} = (110)_2 \implies g^{(3)}(D) = 1 + D$

假设输入信息序列为 $u=(1,0,1)$。为了让编码器在信息序列结束后返回到全零状态，我们需要在信息序列后补加 $m=2$ 个零，这个过程称为 **冲洗 (flushing)**。因此，总的输入序列为 $(1, 0, 1, 0, 0)$。

在时刻 $k$，三个输出比特 $(v_k^{(1)}, v_k^{(2)}, v_k^{(3)})$ 由以下[卷积和](@entry_id:263238)（模2加）计算得出：
$v_k^{(1)} = u_k \oplus u_{k-1} \oplus u_{k-2}$
$v_k^{(2)} = u_k \oplus u_{k-2}$
$v_k^{(3)} = u_k \oplus u_{k-1}$

我们按时间步骤计算输出：
- **$k=1$**: 输入 $u_1=1$。状态 $(u_0, u_{-1})=(0,0)$。输出：$(1\oplus0\oplus0, 1\oplus0, 1\oplus0) = (1,1,1)$。
- **$k=2$**: 输入 $u_2=0$。状态 $(u_1, u_0)=(1,0)$。输出：$(0\oplus1\oplus0, 0\oplus0, 0\oplus1) = (1,0,1)$。
- **$k=3$**: 输入 $u_3=1$。状态 $(u_2, u_1)=(0,1)$。输出：$(1\oplus0\oplus1, 1\oplus1, 1\oplus0) = (0,0,1)$。
- **$k=4$**: 输入 $u_4=0$（冲洗比特）。状态 $(u_3, u_2)=(1,0)$。输出：$(0\oplus1\oplus0, 0\oplus0, 0\oplus1) = (1,0,1)$。
- **$k=5$**: 输入 $u_5=0$（冲洗比特）。状态 $(u_4, u_3)=(0,1)$。输出：$(0\oplus0\oplus1, 0\oplus1, 0\oplus0) = (1,1,0)$。

将这些输出三元组[串联](@entry_id:141009)起来，得到最终的码字序列 $v = 111101001101110$。

### 卷积码的状态描述

将编码器视为一个[有限状态机 (FSM)](@entry_id:176747) 为我们提供了另一种强大的视角，这对于理解解码算法（如[维特比算法](@entry_id:269328)）至关重要。

#### 状态与状态数量

编码器的 **状态 (State)** 由其内部存储单元的内容定义。对于一个 $k=1$、记忆阶数为 $m$ 的编码器，其状态就是在任一时刻[移位寄存器](@entry_id:754780)中存储的 $m$ 个比特 $(u_{k-1}, u_{k-2}, \dots, u_{k-m})$。由于每个寄存器可以取0或1，总共有 $2^m$ 个可能的状态。

例如，一个为卫星通信设计的编码器，其记忆阶数为 $\nu=5$ 。这意味着它的状态由最近5个输入比特决定。因此，描述这个编码器运行所需的总状态数为 $N = 2^\nu = 2^5 = 32$ 个。状态数量是衡量编码器复杂性的一个关键指标。

#### [状态转移图](@entry_id:175938)

**[状态转移图](@entry_id:175938) (State-Transition Diagram)** 是编码器作为[有限状态机](@entry_id:174162)的图形化表示。图中的每个节点代表编码器的一个状态。节点之间的有向边代表状态之间的转移。对于一个 $k=1$ 的编码器，每个状态节点都会有两条出边，分别对应输入为0和1的情况。每条边上都标注着 `输入/输出`。

让我们为一个 $R=1/2$、记忆阶数 $\nu=2$ 的编码器构建[状态转移图](@entry_id:175938) 。其生成序列为 $g^{(1)} = (1, 1, 1)$ 和 $g^{(2)} = (1, 0, 1)$。
状态由 $(u_{k-1}, u_{k-2})$ 决定，共有 $2^2=4$ 个状态：
$S_A = (0,0)$, $S_B = (0,1)$, $S_C = (1,0)$, $S_D = (1,1)$。

输出比特由以下公式生成：
$c_k^{(1)} = u_k \oplus u_{k-1} \oplus u_{k-2}$
$c_k^{(2)} = u_k \oplus u_{k-2}$

新状态则为 $(u_k, u_{k-1})$。我们可以逐一分析每个状态的转移：
- **当前状态 $S_A=(0,0)$**: $(u_{k-1}, u_{k-2}) = (0,0)$
  - 输入 $u_k=0$：下一状态为 $(0,0)=S_A$。输出为 $(0\oplus0\oplus0, 0\oplus0)=(0,0)$。转移：$(S_A, 0) \to (S_A, (0,0))$。
  - 输入 $u_k=1$：下一状态为 $(1,0)=S_C$。输出为 $(1\oplus0\oplus0, 1\oplus0)=(1,1)$。转移：$(S_A, 1) \to (S_C, (1,1))$。
- **当前状态 $S_B=(0,1)$**: $(u_{k-1}, u_{k-2}) = (0,1)$
  - 输入 $u_k=0$：下一状态为 $(0,0)=S_A$。输出为 $(0\oplus0\oplus1, 0\oplus1)=(1,1)$。转移：$(S_B, 0) \to (S_A, (1,1))$。
  - 输入 $u_k=1$：下一状态为 $(1,0)=S_C$。输出为 $(1\oplus0\oplus1, 1\oplus1)=(0,0)$。转移：$(S_B, 1) \to (S_C, (0,0))$。
- **当前状态 $S_C=(1,0)$**: $(u_{k-1}, u_{k-2}) = (1,0)$
  - 输入 $u_k=0$：下一状态为 $(0,1)=S_B$。输出为 $(0\oplus1\oplus0, 0\oplus0)=(1,0)$。转移：$(S_C, 0) \to (S_B, (1,0))$。
  - 输入 $u_k=1$：下一状态为 $(1,1)=S_D$。输出为 $(1\oplus1\oplus0, 1\oplus0)=(0,1)$。转移：$(S_C, 1) \to (S_D, (0,1))$。
- **当前状态 $S_D=(1,1)$**: $(u_{k-1}, u_{k-2}) = (1,1)$
  - 输入 $u_k=0$：下一状态为 $(0,1)=S_B$。输出为 $(0\oplus1\oplus1, 0\oplus1)=(0,1)$。转移：$(S_D, 0) \to (S_B, (0,1))$。
  - 输入 $u_k=1$：下一状态为 $(1,1)=S_D$。输出为 $(1\oplus1\oplus1, 1\oplus1)=(1,0)$。转移：$(S_D, 1) \to (S_D, (1,0))$。

这组规则完整地描述了编码器的动态行为。

#### [网格图](@entry_id:261673)

虽然[状态图](@entry_id:176069)清晰地展示了所有可能的转移，但它没有包含时间维度。**[网格图](@entry_id:261673) (Trellis Diagram)** 通过将[状态图](@entry_id:176069)沿时间轴展开，为我们提供了编码器状态随时间演变的完整视图。

[网格图](@entry_id:261673)由一系列按时间[排列](@entry_id:136432)的节点（状态）和连接它们的边（转移）组成。一个 **单一网格节 (single trellis section)** 展示了从时刻 $t$ 到 $t+1$ 的所有可能转移。它包含两列节点，分别代表时刻 $t$ 和 $t+1$ 的所有状态。从时刻 $t$ 的每个状态出发，都有 $2^k$ 条边连接到时刻 $t+1$ 的相应状态，每条边上都标注着该转移产生的输出码字。

例如，对于一个具有 S0, S1, S2, S3 四个状态的编码器，一个网格节将精确地描绘出状态转移规则 。若规则为：
- S0: 输入0到S0(输出00)，输入1到S2(输出11)
- S1: 输入0到S0(输出11)，输入1到S2(输出00)
- S2: 输入0到S1(输出10)，输入1到S3(输出01)
- S3: 输入0到S1(输出01)，输入1到S3(输出10)

那么在[网格图](@entry_id:261673)中，从时刻 $t$ 的S0节点会引出两条边：一条指向时刻 $t+1$ 的S0节点（标记为00），另一条指向时刻 $t+1$ 的S2节点（标记为11）。对所有四个起始状态重复此过程，就构成了完整的网格节。[网格图](@entry_id:261673)是[维特比解码](@entry_id:264278)算法的基础，因为它将所有可能的编码路径都以结构化的方式展现出来。

### 卷积码的关键特性

除了结构参数，卷积码还有一些决定其实用性和性能的关键特性。

#### 系统码

一个卷积码被称为 **系统码 (Systematic Code)**，如果它的其中一个输出流是输入信息流的未经修改的副本。这个未经修改的输出流被称为 **信息流 (information stream)**，而其他的输出流则被称为 **校验流 (parity streams)**。

系统码的一个主要优点是接收方可以直接从对应的输出流中提取信息比特，无需进行解码，这在某些应用中非常方便。判断一个编码器是否为系统码非常直接：只需检查它的[生成多项式](@entry_id:265173)。如果至少有一个[生成多项式](@entry_id:265173)为 $g^{(i)}(D) = 1$，那么该编码器就是系统码。

例如，考虑一个 $R=1/2$ 的编码器，其[生成多项式](@entry_id:265173)为 $g^{(1)}(D) = 1$ 和 $g^{(2)}(D) = 1 + D^2$ 。
第一个输出流为 $c^{(1)}(D) = u(D) g^{(1)}(D) = u(D) \cdot 1 = u(D)$。由于 $c^{(1)}(D)$ 与输入 $u(D)$ 完全相同，所以该编码器是系统码。$c^{(1)}$ 是信息流。
第二个输出流为 $c^{(2)}(D) = u(D) g^{(2)}(D) = u(D)(1+D^2) = u(D) + u(D)D^2$。这个流包含了输入信息和其延迟版本（校验信息），因此是校验流。

#### [灾难性码](@entry_id:138599)

一个理想的[纠错码](@entry_id:153794)应该能在信道出现少量错误时，将其纠正，且解码错误不应被不成比例地放大。然而，存在一类被称为 **[灾难性码](@entry_id:138599) (Catastrophic Codes)** 的病态卷积码。对于这类码，一个包含有限数量错误的接收序列可能导致解码器输出一个包含无限（或非常多）错误的解码信息序列。这是一种灾难性的错误传播。

这种现象的代数根源在于[生成多项式](@entry_id:265173)。一个卷积码是灾难性的，当且仅当其所有[生成多项式](@entry_id:265173)拥有一个不是 $D^L$ 形式的公因子（其中 $L$ 是非负整数）。换句话说，如果[生成多项式](@entry_id:265173)的[最大公约数 (GCD)](@entry_id:149942) 是一个形如 $1+D, 1+D+D^2$ 等的多项式，那么该码就是灾难性的。

为了避免灾难性错误，设计编码器时必须确保其[生成多项式](@entry_id:265173)是互素的，或者其公因子仅为 $D$ 的幂次。例如，让我们检查一个 $R=1/2$ 编码器，其[生成多项式](@entry_id:265173)为 $g^{(1)}(D) = 1 + D^2$ 和 $g^{(2)}(D) = 1 + D + D^2 + D^3$ 。

我们需在GF(2)上分解这两个多项式来求其[最大公约数](@entry_id:142947)：
$g^{(1)}(D) = 1 + D^2 = (1+D)^2$
$g^{(2)}(D) = (1+D) + D^2(1+D) = (1+D)(1+D^2) = (1+D)(1+D)^2 = (1+D)^3$

显而易见，$\gcd(g^{(1)}(D), g^{(2)}(D)) = (1+D)^2 = 1+D^2$。由于这个公因子不是 $D^L$ 的形式，该编码器是灾难性的。这意味着存在某个非零的输入序列（例如，输入多项式为 $1/(1+D)$ 的无限长序列），它能产生一个权重有限的码字。在解码时，如果一个权重有限的错误序列恰好将全零码字变成了这个权重有限的码字，解码器可能会错误地输出那个无限权重的输入序列，导致灾难性错误。

#### [自由距离](@entry_id:147242)

对于卷积码，最重要的性能指标是其 **[自由距离](@entry_id:147242) (Free Distance)**，记为 $d_{free}$。它定义为任意两个不同码字序列之间（或等价地，任意非零码字序列与全零码字序列之间）的[最小汉明距离](@entry_id:272322)。在[网格图](@entry_id:261673)的语境下，[自由距离](@entry_id:147242)等于从全零状态出发，经过一条不全为零的路径，最终首次返回全零状态的所有路径中，累积[汉明权重](@entry_id:265886)最小的那条路径的权重。

[自由距离](@entry_id:147242) $d_{free}$ 决定了卷积码的[纠错](@entry_id:273762)能力。一个卷积码能够可靠地纠正多达 $t$ 个错误，其中 $t = \lfloor (d_{free}-1)/2 \rfloor$。因此，在设计卷积码时，一个主要目标就是在给定的[码率](@entry_id:176461)和约束长度下，最大化[自由距离](@entry_id:147242)。

让我们计算一个 $R=1/2$、记忆阶数 $m=2$ 的编码器的[自由距离](@entry_id:147242)，其[生成多项式](@entry_id:265173)为 $g^{(1)}(D) = 1+D+D^2$ 和 $g^{(2)}(D) = 1+D^2$ 。

我们从全零状态 $(0,0)$ 开始，寻找一条回到 $(0,0)$ 的最小权重路径。
1.  **分岔**: 要离开全零状态，输入必须为 $u=1$。当前状态为 $(0,0)$，输入 $u_0=1$。
    输出为 $(v_0^{(1)}, v_0^{(2)}) = (1\oplus0\oplus0, 1\oplus0)=(1,1)$。该分支的[汉明权重](@entry_id:265886)为2。
    下一状态为 $(u_0, u_{-1})=(1,0)$。
2.  **演进**: 现在我们处于状态 $(1,0)$。我们寻找一条路径最终能回到 $(0,0)$。
    - 从状态 $(1,0)$，输入 $u_1=0$。
      输出为 $(0\oplus1\oplus0, 0\oplus0)=(1,0)$。权重为1。
      下一状态为 $(u_1, u_0)=(0,1)$。
3.  **重合**: 现在我们处于状态 $(0,1)$。我们希望回到 $(0,0)$。
    - 从状态 $(0,1)$，输入 $u_2=0$。
      输出为 $(0\oplus0\oplus1, 0\oplus1)=(1,1)$。权重为2。
      下一状态为 $(u_2, u_1)=(0,0)$。路径在此重合。

这条路径 $(0,0) \xrightarrow{1/11} (1,0) \xrightarrow{0/10} (0,1) \xrightarrow{0/11} (0,0)$ 的总权重为 $2+1+2=5$。这条路径对应的输入序列是 $(1,0,0)$。通过检查其他更短或更长的路径（例如，从状态 $(1,0)$ 输入 $u_1=1$），可以确认没有其他路径能以更小的权重返回全零状态。因此，该编码器的[自由距离](@entry_id:147242) $d_{free} = 5$。

### 设计考量：性能与复杂度的权衡

在卷积码的设计中，工程师面临一个经典的核心权衡：**性能与复杂度之间的取舍**。

通常情况下，对于给定的码率，增加编码器的记忆阶数 $m$ 会使得找到具有更大[自由距离](@entry_id:147242) $d_{free}$ 的编码方案成为可能。更大的 $d_{free}$ 意味着更强的[纠错](@entry_id:273762)能力，从而在给定的信噪比下获得更低的[误码率](@entry_id:267618)。

然而，这种性能提升并非没有代价。如前所述，编码器的状态数量为 $N_s = 2^m$。这意味着记忆阶数 $m$ 每增加1，状态数量就翻倍。解码器的复杂度，尤其是广泛使用的[维特比算法](@entry_id:269328)，其计算复杂度与状态数量成正比。因此，记忆阶数的[线性增长](@entry_id:157553)会导致解码复杂度的指数级增长。

让我们通过一个实例来量化这一权衡 。假设我们在一个 $R=1/2$ 的系统中比较两个编码方案：
- **码 C1**: $\nu_1 = 1$, $g^{(1)}(D) = 1+D$, $g^{(2)}(D) = 1$。
- **码 C2**: $\nu_2 = 3$, $g^{(1)}(D) = 1+D+D^2+D^3$, $g^{(2)}(D) = 1+D+D^3$。

首先，我们计算它们的复杂度和性能指标：
- **状态数量**:
  - C1: $N_{s,1} = 2^{\nu_1} = 2^1 = 2$
  - C2: $N_{s,2} = 2^{\nu_2} = 2^3 = 8$
  从 C1 到 C2，状态数量增加了 $8-2=6$ 个。

- **[自由距离](@entry_id:147242)**:
  - C1: 这是一个简单的系统码，其[自由距离](@entry_id:147242)可以计算为 $d_{free,1} = 3$。
  - C2: 这是一个已知的最优码，其[自由距离](@entry_id:147242)为 $d_{free,2} = 6$。
  从 C1 到 C2，[自由距离](@entry_id:147242)增加了 $6-3=3$。

现在，我们可以定义一个“复杂度-性能增益”比率 $\rho = \frac{\Delta N_s}{\Delta d_{free}}$，它表示每获得一个单位的[自由距离](@entry_id:147242)增益，需要付出多少状态数量增加的代价。
$\rho = \frac{N_{s,2} - N_{s,1}}{d_{free,2} - d_{free,1}} = \frac{8 - 2}{6 - 3} = \frac{6}{3} = 2$。

这个比值 $\rho=2$ 意味着，在这个特定的设计升级中，每使[自由距离](@entry_id:147242)增加1，编码器的状态数量（复杂度的代表）就要增加2。这个例子清晰地揭示了，虽然增加记忆阶数可以有效提升[纠错](@entry_id:273762)性能，但设计者必须仔细考量由此带来的解码器实现成本的急剧上升。在资源受限的系统（如移动设备或深空探测器）中，选择一个具有适中约束长度的卷积码，以在可接受的复杂度和期望的性能之间取得平衡，是至关重要的工程决策。