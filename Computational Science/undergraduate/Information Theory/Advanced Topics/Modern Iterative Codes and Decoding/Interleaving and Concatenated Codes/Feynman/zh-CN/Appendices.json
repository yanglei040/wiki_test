{
    "hands_on_practices": [
        {
            "introduction": "构建强大的纠错系统的一种巧妙方法是将两个（或更多）较简单的码串联起来，形成一个级联码。在评估这种方案的性能时，一个首要问题是：我们为这种增强的保护付出了多大的开销？本练习将带您计算一个级联码的整体码率，从而让您掌握衡量其传输效率的基本技能。",
            "id": "1633140",
            "problem": "为了确保卫星数据传输的可靠性，使用了一种级联编码方案。该方案分两个阶段工作：先通过一个外码，然后通过一个内码。\n\n该过程始于原始信息消息，这些信息被分成 $K=24$ 个数据块。每个数据块的大小为 $k=5$ 比特。外码编码器是一个表示为 $C_{out}$ 的分组码，它接收这 $K$ 个块并添加冗余，从而产生 $N=32$ 个块的输出。\n\n然后，这 $N=32$ 个块（每个块的大小仍为 $k=5$ 比特）中的每一个都由内码编码器处理，内码编码器是一个表示为 $C_{in}$ 的分组码。内码将每个 $5$ 比特块编码成一个 $n=8$ 比特的码字用于传输。\n\n计算这整个过程的总码率 $R$。码率定义为原始信息比特总数与最终传输的总比特数之比。请用小数表示你的答案。",
            "solution": "原始信息比特总数是信息块的数量乘以每个块的比特数：\n$$\nB_{\\text{info}} = K \\cdot k.\n$$\n经过外码编码后，有 $N$ 个块（每个块仍为 $k$ 比特）被送入内码编码器。内码将每个 $k$ 比特块映射到一个 $n$ 比特码字，因此传输的总比特数是：\n$$\nB_{\\text{tx}} = N \\cdot n.\n$$\n因此，总码率是以下比率：\n$$\nR = \\frac{B_{\\text{info}}}{B_{\\text{tx}}} = \\frac{K \\cdot k}{N \\cdot n}.\n$$\n这等价于外码码率和内码码率的乘积：\n$$\nR = \\left(\\frac{K}{N}\\right)\\left(\\frac{k}{n}\\right).\n$$\n代入 $K=24$，$N=32$，$k=5$ 和 $n=8$：\n$$\nR = \\frac{24}{32} \\cdot \\frac{5}{8} = \\frac{3}{4} \\cdot \\frac{5}{8} = \\frac{15}{32} = 0.46875.\n$$",
            "answer": "$$\\boxed{0.46875}$$"
        },
        {
            "introduction": "现实世界中的信道常常会产生突发错误，即连续的比特发生错误，这种情况会使许多强大的纠错码失效。交织是一种经典而有效的对抗策略。本练习将让您亲手模拟一个块交织器如何重排数据，展示它如何将集中的突发错误分散成单个、独立的错误，从而使解码器更容易处理。",
            "id": "1633148",
            "problem": "一个数字通信系统被设计用来抵抗突发错误，即在传输过程中连续码元上发生的错误。为此，该系统在传输前采用一种数据重排技术，并在接收后采用一种相应的解扰技术。\n\n考虑一个由12个码元组成的码块，其索引从1到12。在传输之前，这些码元被重新排列。过程如下：原始码元序列被逐列写入一个 $3 \\times 4$ 矩阵（3行4列），从左到右，从上到下。然后，从该矩阵中逐行读出码元，从上到下，从左到右，以形成传输序列。\n\n接收端则执行相反的过程。接收到的12个码元序列被逐行写入一个新的 $3 \\times 4$ 矩阵。然后通过从这个第二个矩阵中逐列读出码元来获得最终的重构序列。\n\n假设在通过噪声信道传输期间，一个长度为4的突发错误破坏了12个码元的*传输*序列中位置为5、6、7和8的码元。在接收器执行解扰过程后，这些错误会出现在最终重构序列中的哪些位置（从1开始索引）？\n\nA. 2, 5, 8, 11\nB. 5, 6, 7, 8\nC. 3, 6, 7, 10\nD. 3, 6, 9, 12\nE. 4, 5, 6, 7",
            "solution": "用索引 $k\\in\\{1,\\dots,12\\}$ 标记原始码元。它们被逐列写入一个 $3\\times 4$ 矩阵，因此索引 $k$ 占据的矩阵坐标 $(r,c)$ 满足\n$$\nk=(c-1)\\cdot 3 + r,\\quad r\\in\\{1,2,3\\},\\ c\\in\\{1,2,3,4\\}.\n$$\n逐行读取形成传输索引 $t$，其公式为\n$$\nt=(r-1)\\cdot 4 + c.\n$$\n在接收端，执行相反的操作：传输序列被逐行写入一个 $3\\times 4$ 矩阵，因此一个传输位置 $t$ 映射到坐标\n$$\nr=\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor+1,\\qquad c=((t-1)\\bmod 4)+1.\n$$\n逐列读取得到重构索引\n$$\ns=(c-1)\\cdot 3 + r.\n$$\n因此，从传输位置 $t$ 到其在最终重构序列中的位置 $s$ 的复合映射为\n$$\ns=3\\,((t-1)\\bmod 4)+\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor+1.\n$$\n对突发错误位置 $t=5,6,7,8$ 计算该表达式：\n- 对于 $t=5$：$t-1=4$，所以 $((t-1)\\bmod 4)=0$ 且 $\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor=1$，因此 $s=3\\cdot 0+1+1=2$。\n- 对于 $t=6$：$t-1=5$，所以 $((t-1)\\bmod 4)=1$ 且 $\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor=1$，因此 $s=3\\cdot 1+1+1=5$。\n- 对于 $t=7$：$t-1=6$，所以 $((t-1)\\bmod 4)=2$ 且 $\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor=1$，因此 $s=3\\cdot 2+1+1=8$。\n- 对于 $t=8$：$t-1=7$，所以 $((t-1)\\bmod 4)=3$ 且 $\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor=1$，因此 $s=3\\cdot 3+1+1=11$。\n因此，错误出现在重构序列的位置 $2,5,8,11$ 处，这与选项A相符。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "乘积码是级联码的一个经典例子，它天然地适用于一种强大的解码策略：迭代解码。通过在行和列上反复进行解码，我们可以修正单次解码可能无法解决的错误模式。本练习将引导您在一个接收到的数据块上追踪这种“乒乓式”的解码过程，揭示码结构与解码算法之间奇妙的协同作用，这也是现代通信系统的核心思想之一。",
            "id": "1633093",
            "problem": "一个乘积码由两个相同的系统（7,4）汉明码构成。一个原始的 $4 \\times 4$ 信息位块首先被逐行编码，形成一个 $4 \\times 7$ 的矩阵。然后，这个新矩阵的7个列中的每一列再被编码，以产生最终的 $7 \\times 7$ 码字矩阵。\n\n其分量（7,4）汉明码将一个4比特数据向量 $(d_1, d_2, d_3, d_4)$ 编码成一个7比特码字 $(c_1, c_2, c_3, c_4, c_5, c_6, c_7)$，其中比特排列为 $(d_1, d_2, d_3, d_4, p_1, p_2, p_3)$。校验位 $p_1, p_2, p_3$ 使用模2运算计算得出。该码由其校验矩阵 $H$ 定义：\n$$ H = \\begin{pmatrix} 1 & 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 1 & 0 & 0 & 1 \\end{pmatrix} $$\n对于任何有效码字 $c$，其伴随式 $s = Hc^T$ 是零向量 $(0,0,0)^T$。对于一个在位置 $i$（从1开始索引）上包含单个错误的接收向量 $r$，其伴随式 $s = Hr^T$ 将等于 $H$ 的第 $i$ 列。伴随式到错误位置的映射如下：\n- (1,0,0) -> 位置 5\n- (0,1,0) -> 位置 6\n- (0,0,1) -> 位置 7\n- (1,1,0) -> 位置 1\n- (1,0,1) -> 位置 2\n- (0,1,1) -> 位置 3\n- (1,1,1) -> 位置 4\n\n一个 $7 \\times 7$ 的矩阵 $R$ 从一个噪声信道接收。对 $R$ 应用迭代译码。过程如下：\n1.  **行译码：** 对于7行中的每一行，计算其伴随式。如果伴随式指示一个单比特错误，则翻转该行中对应的比特。如果伴随式为零或指示一个多比特错误（即，对应于一个可纠正的单比特错误），则对该行进行相应地修改。一个多比特错误可能会被误识别为单比特错误，并且译码器将继续进行相应的比特翻转。\n2.  **列译码：** 在所有行都处理完毕后，对修改后矩阵的7个列中的每一列执行相同的译码过程。\n3.  **迭代：** 重复行译码和列译码的完整循环，直到一个完整的循环（一次行遍和一次列遍）不再产生任何比特翻转。\n\n接收到的矩阵 $R$ 是：\n$$ R = \\begin{pmatrix}\n1 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 0 \\\\\n1 & 1 & 0 & 1 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\\n0 & 1 & 0 & 0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 0 & 1 & 1 & 0\n\\end{pmatrix} $$\n在迭代译码过程收敛后，确定矩阵最终修正后的第二行。请将你的答案以该7比特二进制向量的整数值的形式给出，其中最左边的比特为最高有效位。",
            "solution": "将给定校验矩阵 $H$ 的列定义为 $v_{i}$，其中位置 $i=1,\\dots,7$：\n$$\nv_{1}=(1,1,0),\\quad v_{2}=(1,0,1),\\quad v_{3}=(0,1,1),\\quad v_{4}=(1,1,1),\\quad v_{5}=(1,0,0),\\quad v_{6}=(0,1,0),\\quad v_{7}=(0,0,1).\n$$\n对于任意长度为7的二进制向量 $x=(x_{1},\\dots,x_{7})$，其伴随式为 $s=\\sum_{i:x_{i}=1} v_{i}$（模2）。如果 $s\\neq 0$，则翻转由映射 $s\\mapsto i$（其中 $v_{i}=s$）指示的位置上的比特。\n\n从接收到的矩阵 $R$ 开始（第1行到第7行）：\n$$\n\\begin{pmatrix}\n1 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 0 \\\\\n1 & 1 & 0 & 1 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\\n0 & 1 & 0 & 0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 0 & 1 & 1 & 0\n\\end{pmatrix}.\n$$\n\n行译码，第1遍：\n- 第1行：1的位置在 $\\{1,3,5,7\\}$，$s=v_{1}+v_{3}+v_{5}+v_{7}=(1,1,0)+(0,1,1)+(1,0,0)+(0,0,1)=(0,0,0)$，不翻转。\n- 第2行：1的位置在 $\\{2,6\\}$，$s=v_{2}+v_{6}=(1,0,1)+(0,1,0)=(1,1,1)\\mapsto 4$，翻转位置4：该行变为 $(0,1,0,1,0,1,0)$。\n- 第3行：1的位置在 $\\{1,2,4,5\\}$，$s=v_{1}+v_{2}+v_{4}+v_{5}=(1,1,0)+(1,0,1)+(1,1,1)+(1,0,0)=(0,0,0)$，不翻转。\n- 第4行：1的位置在 $\\{4,5\\}$，$s=v_{4}+v_{5}=(1,1,1)+(1,0,0)=(0,1,1)\\mapsto 3$，翻转位置3：该行变为 $(0,0,1,1,1,0,0)$。\n- 第5行：1的位置在 $\\{1,2,3,4,5,6,7\\}$，$s=v_{1}+v_{2}+v_{3}+v_{4}+v_{5}+v_{6}+v_{7}=(0,0,0)$，不翻转。\n- 第6行：1的位置在 $\\{2,5,7\\}$，$s=v_{2}+v_{5}+v_{7}=(1,0,1)+(1,0,0)+(0,0,1)=(0,0,0)$，不翻转。\n- 第7行：1的位置在 $\\{1,5,6\\}$，$s=v_{1}+v_{5}+v_{6}=(1,1,0)+(1,0,0)+(0,1,0)=(0,0,0)$，不翻转。\n\n经过第1遍行译码后，矩阵为\n$$\n\\begin{pmatrix}\n1 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n1 & 1 & 0 & 1 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\\n0 & 1 & 0 & 0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 0 & 1 & 1 & 0\n\\end{pmatrix}.\n$$\n\n列译码，第1遍（沿每一列计算伴随式；现在位置指的是行索引）：\n- 第1列（1的位置在 $\\{1,3,5,7\\}$）：$s=v_{1}+v_{3}+v_{5}+v_{7}=(0,0,0)$，不翻转。\n- 第2列（1的位置在 $\\{2,3,5,6\\}$）：$s=v_{2}+v_{3}+v_{5}+v_{6}=(0,0,0)$，不翻转。\n- 第3列（1的位置在 $\\{1,4,5\\}$）：$s=v_{1}+v_{4}+v_{5}=(1,0,1)\\mapsto 2$，翻转第2行：元素 $(2,3)$ 从 $0\\to 1$。\n- 第4列（1的位置在 $\\{2,3,4,5\\}$）：$s=v_{2}+v_{3}+v_{4}+v_{5}=(1,0,1)\\mapsto 2$，翻转第2行：元素 $(2,4)$ 从 $1\\to 0$。\n- 第5列（1的位置在 $\\{1,3,4,5,6,7\\}$）：$s=v_{1}+v_{3}+v_{4}+v_{5}+v_{6}+v_{7}=(1,0,1)\\mapsto 2$，翻转第2行：元素 $(2,5)$ 从 $0\\to 1$。\n- 第6列（1的位置在 $\\{2,5,7\\}$）：$s=v_{2}+v_{5}+v_{7}=(0,0,0)$，不翻转。\n- 第7列（1的位置在 $\\{1,5,6\\}$）：$s=v_{1}+v_{5}+v_{6}=(0,0,0)$，不翻转。\n\n经过第1遍列译码后，只有第2行发生改变，现在为 $(0,1,1,0,1,1,0)$。\n\n行译码，第2遍：\n- 第1行：$s=(0,0,0)$，不翻转（与之前的计算相同）。\n- 第2行：1的位置在 $\\{2,3,5,6\\}$，$s=v_{2}+v_{3}+v_{5}+v_{6}=(0,0,0)$，不翻转。\n- 第3行：$s=(0,0,0)$，不翻转。\n- 第4行：1的位置在 $\\{3,4,5\\}$，$s=v_{3}+v_{4}+v_{5}=(0,0,0)$，不翻转。\n- 第5行：$s=(0,0,0)$，不翻转。\n- 第6行：$s=(0,0,0)$，不翻转。\n- 第7行：$s=(0,0,0)$，不翻转。\n\n列译码，第2遍：\n所有列的伴随式都保持为零（与第1遍列译码后的组合相同），因此不会发生比特翻转。\n\n因此，迭代译码收敛。最终修正后的第二行是二进制向量 $0110110$。将其解释为最左边比特为最高有效位，其整数值为\n$$\n0\\cdot 2^{6}+1\\cdot 2^{5}+1\\cdot 2^{4}+0\\cdot 2^{3}+1\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}=32+16+4+2=54.\n$$",
            "answer": "$$\\boxed{54}$$"
        }
    ]
}