{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握通用源编码算法，最好的方法莫过于亲自动手实践。第一个练习将带你逐步完成 Lempel-Ziv-Welch (LZW) 算法的编码过程。通过手动追踪一个简单字符串的压缩，你将清晰地看到算法是如何动态构建字典并生成相应代码的，从而将抽象的理论转化为具体的操作步骤。",
            "id": "1636836",
            "problem": "Lempel-Ziv-Welch (LZW) 算法是一种通用的无损数据压缩算法。其操作依赖于在压缩过程中遇到的字符串构建一个字典。压缩过程如下：\n\n1.  用一组预定义的字符串及其对应的编码来初始化字典。\n2.  从一个空的“当前字符串”`S`开始。\n3.  从输入流中读取下一个字符`C`。\n4.  考虑新字符串`S + C`（当前字符串后附加新字符）。\n5.  如果`S + C`已在字典中，则更新当前字符串：`S = S + C`。\n6.  如果`S + C`不在字典中：\n    a) 将`S + C`以及下一个可用的整数编码添加到字典中。\n    b) 输出当前字符串`S`的编码。\n    c) 将当前字符串重置为字符`C`，即`S = C`。\n7.  从第3步开始重复，直到到达输入流的末尾。\n8.  循环终止后，输出最终“当前字符串”`S`的编码。\n\n考虑一个LZW压缩器，其初始字典仅包含两个条目：`A`的编码为`0`，`B`的编码为`1`。新字典条目的编码从`2`开始顺序分配。\n\n确定该LZW压缩器对输入字符串`BBAABABB`生成的输出编码序列。请将您的答案表示为一个整数序列。",
            "solution": "初始化字典，D('A')=0 和 D('B')=1。设下一个可用编码为 $n=2$。从空的当前字符串 S 开始。\n\n读取第一个字符 C='B'。由于 S 为空，连接后的字符串 S+C='B' 在字典中，因此更新 S='B'。\n\n读取第二个字符 C='B'。此时 S+C='BB' 不在字典中。将其加入字典：D('BB')=2，并更新 $n \\to 3$。输出当前字符串 S 的编码，即 D('B')=1。重置 S=C='B'。\n\n读取第三个字符 C='A'。此时 S+C='BA' 不在字典中。将其加入字典：D('BA')=3，并更新 $n \\to 4$。输出 D('B')=1。重置 S=C='A'。\n\n读取第四个字符 C='A'。此时 S+C='AA' 不在字典中。将其加入字典：D('AA')=4，并更新 $n \\to 5$。输出 D('A')=0。重置 S=C='A'。\n\n读取第五个字符 C='B'。此时 S+C='AB' 不在字典中。将其加入字典：D('AB')=5，并更新 $n \\to 6$。输出 D('A')=0。重置 S=C='B'。\n\n读取第六个字符 C='A'。此时 S+C='BA' 在字典中（编码为 3），因此更新 S='BA'。\n\n读取第七个字符 C='B'。此时 S+C='BAB' 不在字典中。将其加入字典：D('BAB')=6，并更新 $n \\to 7$。输出 D('BA')=3。重置 S=C='B'。\n\n读取第八个字符 C='B'。此时 S+C='BB' 在字典中（编码为 2），因此更新 S='BB'。\n\n输入结束：输出最终当前字符串 S 的编码，即 D('BB')=2。\n\n按顺序收集输出，得到序列 1, 1, 0, 0, 3, 2。",
            "answer": "$$\\boxed{\\begin{pmatrix}1  1  0  0  3  2\\end{pmatrix}}$$"
        },
        {
            "introduction": "在学会如何编码之后，我们自然要探究其逆过程——解码。这个练习将向你展示解压器如何利用接收到的代码序列，同步地重建与压缩器完全相同的字典，从而完美恢复原始数据。更重要的是，本题包含了一个著名的特殊情况，揭示了 LZW 算法如何巧妙地处理“边构建边使用”这一挑战，让你领略其设计的精妙之处。",
            "id": "1636893",
            "problem": "Lempel-Ziv-Welch (LZW) 是一种通用的无损数据压缩算法。解压缩器通过读取一串代码序列，并用它们重建由压缩器创建的字典，从而恢复原始数据。\n\n假设 LZW 解压缩器在初始化时，其字典包含所有 256 个单字符字符串，对应于标准的 8 位 ASCII 字符集，其中字符的字典代码为其 ASCII 值。新的字典条目从代码 256 开始顺序添加。\n\n给定 LZW 压缩的输出代码序列 `[67, 65, 256, 258, 257]`，请重建原始文本。",
            "solution": "使用标准的 LZW 解压缩过程。用代码 $0$ 到 $255$ 初始化字典，使其映射到相应的单个 ASCII 字符。令 w 表示前一个已解码的字符串。读取第一个代码，输出其对应的条目，并将 w 设置为该条目。对于每个后续代码 k，按如下方式确定当前条目：如果 k 已经在字典中，则令 entry=dict[k]；如果 k 等于下一个要分配的代码（即它尚不在字典中），则使用特殊情况 entry = w + first_char(w)。然后输出 entry，将新字典条目 w + first_char(entry) 与下一个可用代码一起添加到字典中，并设置 w=entry。\n\n逐步处理给定的代码序列 $[67,65,256,258,257]$：\n\n1) 第一个代码 $67$ 在初始字典中，对应字符 'C'。输出 'C' 并设置 w='C'。下一个可用代码是 $256$。\n\n2) 下一个代码 $65$ 在初始字典中，对应字符 'A'。输出 'A'。添加代码为 $256$ 的新字典条目：w + first_char('A')='C'+'A'='CA'。将下一个代码增加到 $257$。设置 w='A'。目前输出：'CA'。\n\n3) 下一个代码 $256$ 在字典中，为 'CA'。输出 'CA'。添加代码为 $257$ 的新字典条目：w + first_char('CA')='A'+'C'='AC'。将下一个代码增加到 $258$。设置 w='CA'。目前输出：'CACA'。\n\n4) 下一个代码 $258$ 尚不在字典中。使用特殊情况：entry = w + first_char(w) = 'CA' + 'C' = 'CAC'。输出 'CAC'。添加代码为 $258$ 的新字典条目：w + first_char('CAC') = 'CA' + 'C' = 'CAC'。将下一个代码增加到 $259$。设置 w='CAC'。目前输出：'CACACAC'。\n\n5) 下一个代码 $257$ 在字典中，为 'AC'。输出 'AC'。添加代码为 $259$ 的新字典条目：w + first_char('AC') = 'CAC' + 'A' = 'CACA'。将下一个代码增加到 $260$。设置 w='AC'。最终输出：'CACACACAC'。\n\n因此，重建的原始文本是 CACACACAC。",
            "answer": "$$\\boxed{\\text{CACACACAC}}$$"
        },
        {
            "introduction": "接下来，我们将目光转向 Lempel-Ziv 家族的另一位重要成员——LZ77 算法，它采用滑动窗口而非显式字典来进行压缩。本练习的设计超越了简单的算法追踪，它通过一个假设的“系统故障”场景，探讨了实际应用中参数配置错误可能导致的后果。通过分析一个配置错误的解码器所产生的输出，你将能更深刻地理解滑动窗口、偏移量和匹配长度这些核心概念是如何协同工作的，以及参数同步的至关重要性。",
            "id": "1666833",
            "problem": "一个解码器接收到一个由 Lempel-Ziv 77 (LZ77) 压缩算法生成的元组序列。每个元组的形式为 `(offset, length, next_symbol)`，其中 `offset` 是从当前位置回溯到匹配序列起始位置的距离，`length` 是匹配的长度，`next_symbol` 是在复制操作后附加的字面字符。偏移量和长度都为零的元组 `(0, 0, char)` 表示一个在搜索缓冲区中未找到的单个字面字符。\n\n接收到的元组序列 $T$ 为：\n$T = [(0, 0, 'A'), (0, 0, 'B'), (0, 0, 'C'), (0, 0, 'D'), (0, 0, 'E'), (0, 0, 'F'), (6, 3, 'X'), (0, 0, 'Y'), (0, 0, 'Z')]$\n\n这个元组序列是由一个编码器从原始字符串 $S$ 生成的：\n$S = \\text{`ABCDEFABCXYZ`}$\n\n负责解压的解码器配置错误，其使用的搜索缓冲区大小为 $W_d = 4$。解码器按顺序处理 $T$ 中的元组以重构字符串 $S'$。其操作定义如下：\n- 对于一个元组 $(o, l, c)$，如果 $o = 0$，它将字面值 $c$ 附加到其输出字符串中。\n- 如果 $o > 0$ 且偏移量 $o$ 在其搜索缓冲区大小范围内（即 $o \\le W_d$），它会按预期执行复制操作：它在 `current_length - o` 处找到匹配的起始位置，从该点复制 $l$ 个字符，并将它们附加到输出字符串。然后它附加字面值 $c$。\n- 如果 $o > 0$ 且偏移量 $o$ 超出其搜索缓冲区大小（即 $o > W_d$），则会发生故障。在这种情况下，解码器将匹配长度 $l$ 视为零（不复制任何内容），并仅附加字面值 $c$。\n\n计算原始字符串 $S$ 和由配置错误的解码器重构的字符串 $S'$ 之间的汉明距离。在本题中，两个不等长字符串之间的汉明距离定义为：对应位置上字符不同的数量，加上较长字符串超出较短字符串末尾的字符数量。",
            "solution": "解码器使用大小为 $W_{d}=4$ 的搜索缓冲区按顺序处理元组。对于一个元组 $(o,l,c)$：\n- 如果 $o=0$，它附加字面值 $c$。\n- 如果 $o>0$ 且 $o\\leq W_{d}$，它从后方偏移量为 $o$ 的位置复制 $l$ 个字符，然后附加 $c$。\n- 如果 $o>0$ 且 $o>W_{d}$，它不进行复制（将 $l$ 视为 $0$）并仅附加 $c$。\n\n处理给定的序列 $T=[(0,0,\\text{'A'}),(0,0,\\text{'B'}),(0,0,\\text{'C'}),(0,0,\\text{'D'}),(0,0,\\text{'E'}),(0,0,\\text{'F'}),(6,3,\\text{'X'}),(0,0,\\text{'Y'}),(0,0,\\text{'Z'})]$：\n- 元组 $(0,0,\\text{'A'})$ 到 $(0,0,\\text{'F'})$ 附加字面值，得到 $S'=\\text{ABCDEF}$。\n- 元组 $(6,3,\\text{'X'})$ 的 $o=6>W_{d}=4$，因此发生故障；不执行复制，仅附加 $\\text{'X'}$，得到 $S'=\\text{ABCDEFX}$。\n- 元组 $(0,0,\\text{'Y'})$ 附加 $\\text{'Y'}$，得到 $S'=\\text{ABCDEFXY}$。\n- 元组 $(0,0,\\text{'Z'})$ 附加 $\\text{'Z'}$，得到 $S'=\\text{ABCDEFXYZ}$。\n\n因此，重构的字符串是 $S'=\\text{ABCDEFXYZ}$，而原始字符串是 $S=\\text{ABCDEFABCXYZ}$。\n\n设不等长字符串的汉明距离为\n$$\nd_{H}(S,S')=\\left|\\left\\{\\,i\\in\\{1,\\ldots,\\min(|S|,|S'|)\\}:\\ S[i]\\neq S'[i]\\,\\right\\}\\right|+\\left||S|-|S'|\\right|.\n$$\n这里 $|S|=12$，$|S'|=9$，所以 $\\min(|S|,|S'|)=9$。比较位置 $1$ 到 $9$：\n- 位置 $1$–$6$ 匹配：$\\text{A,B,C,D,E,F}$。\n- 位置 $7$–$9$ 不匹配：$S[7..9]=\\text{A,B,C}$ 对比 $S'[7..9]=\\text{X,Y,Z}$，产生 $3$ 个不匹配。\n\n长度差异贡献了 $|12-9|=3$。因此，\n$$\nd_{H}(S,S')=3+3=6.\n$$",
            "answer": "$$\\boxed{6}$$"
        }
    ]
}