{
    "hands_on_practices": [
        {
            "introduction": "要真正理解是什么让一个字符串具有算法随机性（即高复杂度），最有效的方法之一是首先审视其对立面：结构性和简单性（即低复杂度）。这个练习引导我们像一个寻求效率的程序员那样思考，去构建一个长度随 $n$ 平方增长、但其描述性复杂度仅以对数方式增长的字符串家族。通过这个过程，我们将深刻体会到一个物体的实际大小与其内在信息内容之间的本质区别。",
            "id": "1630683",
            "problem": "在算法信息论中，一个对象（例如一个二进制串）的柯尔莫哥洛夫复杂度是衡量指定它所需的计算资源的一种度量。形式上，二进制串 $s$ 的柯尔莫哥洛夫复杂度 $K(s)$ 是指，用一种固定的通用编程语言编写的、能够输出 $s$ 然后停机的最短计算机程序的长度。如果一个串的复杂度远小于其长度，则该串被认为是简单的；如果其复杂度接近其长度，则被认为是算法随机的。\n\n考虑一个二进制串族 $\\{s_n\\}_{n=2}^{\\infty}$。对于每个整数 $n \\ge 2$，串 $s_n$ 的长度为 $n^2$。这个串可以通过将其比特排列成一个 $n \\times n$ 的网格来可视化，该串由从上到下连接网格的各行而形成。\n\n这个网格上的图案定义如下：一个边长为 $k = \\lfloor \\log_2 n \\rfloor$、由'1'填充的正方形被放置在网格的左上角。这意味着对于所有 $1 \\le i \\le k$ 和 $1 \\le j \\le k$，网格项 $(i, j)$ 均为'1'。网格中所有其他项，即 $i  k$ 或 $j  k$ 的位置，均为'0'。\n\n当 $n \\to \\infty$ 时，柯尔莫哥洛夫复杂度 $K(s_n)$ 的渐进增长率是多少？\n\nA. $O(1)$\n\nB. $O(\\log n)$\n\nC. $O(n)$\n\nD. $O(n^2)$\n\nE. $O((\\log n)^2)$",
            "solution": "固定一个参考通用图灵机，并在全文中使用朴素柯尔莫哥洛夫复杂度，它在相差一个加性常数的意义下具有不变性。\n\n上界：\n- 存在一个单一的、固定的程序模式，该程序在其源代码中硬编码一个整数参数 $n$，然后计算 $k=\\lfloor \\log_{2} n \\rfloor$，并逐行输出一个 $n \\times n$ 的网格，当且仅当 $1 \\le i \\le k$ 且 $1 \\le j \\le k$ 时打印1，否则打印0。\n- 该程序的长度等于 $n$ 的自限定编码的长度加上一个常数（固定的程序模式）。\n- 因此 $K(s_{n}) \\le K(n) + O(1)$。另外，一个整数 $n$ 可以通过在程序中写入其二进制展开来指定，所以 $K(n) \\le \\lceil \\log_{2} n \\rceil + O(1)$。\n- 结合起来，我们得到\n$$\nK(s_{n}) \\le \\lceil \\log_{2} n \\rceil + O(1),\n$$\n所以 $K(s_{n}) \\in O(\\log n)$。\n\n下界，用于排除 $O(1)$：\n- 映射 $n \\mapsto s_{n}$ 是单射的，因为 $|s_{n}| = n^{2}$，因此 $n = \\sqrt{|s_{n}|}$ 可以通过一个固定的可计算过程从 $s_{n}$ 中恢复出来。\n- 因此，\n$$\nK(n) \\le K(s_{n}) + O(1).\n$$\n- 对于任意固定的常数 $C$，只有有限多个对象的柯尔莫哥洛夫复杂度最多为 $C$。因此，$K(s_{n})$ 不可能对所有 $n$ 都受一个全局常数的限制；特别地，$K(s_{n}) \\notin O(1)$。\n\n结论：\n- 我们有一个明确的上界 $K(s_{n}) \\in O(\\log n)$，并且排除了 $O(1)$。在给定的选项中，正确的渐进增长率是 $O(\\log n)$。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在我们对“简单”字符串有了直观感受之后，下一步是探索复杂度在基本数据操作下的行为。本练习提出了一个看似简单的问题：如果我们将一个字符串自身重复一次构成一个新的字符串 $xx$，其柯尔莫哥洛夫复杂度 $K(xx)$ 会如何变化？这个问题的答案揭示了算法信息论中关于信息冗余的一个核心原则，加深了我们对 $K(x)$ 究竟衡量什么的理解。",
            "id": "1602422",
            "problem": "在算法信息论领域，一个有限二进制字符串 $x$ 的柯尔莫哥洛夫复杂度（或算法复杂度），记作 $K(x)$，是指能够生成 $x$ 作为其输出然后停机的最短计算机程序的长度。这个概念提供了一种衡量字符串内在随机性或不可压缩性的方法。该程序被假定在一个固定的通用图灵机上运行。\n\n想象一个简单的数据存储协议，其中为了冗余，数据字符串 $x$ 有时会与其自身的相同副本背靠背地存储，形成拼接字符串 $xx$。我们对这个新的、更长的字符串的复杂度感兴趣。\n\n对于任意二进制字符串 $x$，以下哪个陈述最能描述原始字符串的算法复杂度 $K(x)$ 与重复字符串的复杂度 $K(xx)$ 之间的一般关系？符号 $O(1)$ 表示一个由常数界定的项，它不随 $x$ 的长度或复杂度增长。\n\nA. $K(xx) = 2K(x) + O(1)$\n\nB. $K(xx) = K(x) + O(1)$\n\nC. $K(xx) = K(x) + \\log_{2}(|x|) + O(1)$，其中 $|x|$ 是字符串 $x$ 的长度。\n\nD. 这种关系取决于 $x$ 的内容：对于算法随机字符串，$K(xx) \\approx 2K(x)$，而对于高度结构化的字符串，$K(xx) \\approx K(x)$。\n\nE. $K(xx) = (K(x))^{2} + O(1)$",
            "solution": "设 $K(\\cdot)$ 表示在固定通用图灵机上的前缀柯尔莫哥洛夫复杂度（自定界程序），根据不变性定理，加法常数被吸收到 $O(1)$ 中。\n\n上界 $K(xx) \\leq K(x) + O(1)$：\n取一个输出 $x$ 并停机的最短程序 $p$，则 $|p| = K(x)$。构建一个固定的包装程序 $W$，该程序在其代码中嵌入自定界代码 $p$ 后，执行以下可计算过程：模拟 $p$ 生成 $x$，然后再次模拟 $p$ 生成第二次 $x$。因为 $p$ 是自定界的，所以 $W$ 可以解析并重用 $p$，除了一个常数大小的例程外，不需要任何额外的分隔符。组合程序的总长度是 $|W| + |p| = K(x) + O(1)$，它输出 $xx$，因此\n$$\nK(xx) \\leq K(x) + O(1).\n$$\n\n下界 $K(xx) \\geq K(x) - O(1)$：\n存在一个固定的可计算函数 $f$，它通过将输入字符串分成相等的两半并返回前半部分，将 $xx$ 映射到 $x$。根据柯尔莫哥洛夫复杂度在可计算变换下的基本单调性，对于任何字符串 $z$，\n$$\nK(f(z)) \\leq K(z) + O(1).\n$$\n将此应用于 $z = xx$ 和 $f(z) = x$ 可得\n$$\nK(x) \\leq K(xx) + O(1),\n$$\n整理后得到\n$$\nK(xx) \\geq K(x) - O(1).\n$$\n\n结合上界和下界可得\n$$\nK(xx) = K(x) + O(1).\n$$\n\n因此，正确选项是 B。（作为比较，如果使用普通的、非前缀的复杂度 $C(\\cdot)$，由于定界开销，通常有 $C(xx) = C(x) + O(\\log|x|)$；而使用前缀复杂度 $K(\\cdot)$，开销是 $O(1)$。）",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "算法复杂度和随机性的概念并非纯粹的理论抽象，它们在现实世界中有着重要的应用。这个最终的实践练习将理论与计算实践联系起来，带领我们探索混沌理论与算法信息之间的深刻关联。通过从著名的逻辑斯蒂映射生成序列，并使用一个标准的压缩算法来衡量其可压缩性，我们将亲眼见证一个完全确定的数学系统是如何产生出实际上不可压缩、近乎随机的序列的。",
            "id": "2409515",
            "problem": "在计算物理学的背景下，您需要研究由逻辑斯谛映射生成的符号序列的可压缩性。逻辑斯谛映射定义在单位区间上，其确定性递推关系为 $$x_{n+1} = r\\,x_n\\,(1 - x_n),$$ 其中 $x_n \\in (0,1)$ 且 $r \\in (0,4]$ 是一个控制参数。目标是使用标准的 Lempel–Ziv 族压缩器，量化从该映射导出的阈值化符号序列的可压缩性如何随 $r$ 变化。\n\n从逻辑斯谛映射的基本定义和确定性迭代过程开始，对每个指定的 $r$ 值执行以下步骤：\n\n1. 通过迭代逻辑斯谛映射生成一个实值轨迹。使用固定的初始条件 $x_0 = 0.123456789$。应用 $B$ 次迭代的瞬态移除，以减少对初始条件的依赖。在丢弃瞬态部分后，继续迭代以产生额外的 $L$ 个值。因此，映射求值的总次数为 $B + L$。使用 $B = 1000$ 和 $L = 32768$。\n\n2. 通过在 $1/2$ 处对瞬态后的迭代值进行阈值化，生成一个二进制符号序列：对每个瞬态后的迭代值 $x_n$，定义一个比特 $s_n$\n$$\ns_n = \\begin{cases}\n1,  \\text{if } x_n  1/2 \\\\\n0,  \\text{if } x_n \\le 1/2\n\\end{cases}\n$$\n这将产生一个长度为 $L$ 的比特序列。\n\n3. 将 $L$ 个比特按每个字节内大端比特序的方式打包成字节，按照 $s_n$ 的时间顺序从左到右对比特进行分组。如果 $L$ 不是 $8$ 的倍数，则在最后一个字节的右侧（最低有效位）用零填充，使得总比特数是 $8$ 的倍数。这将产生一个长度为 $L_{\\mathrm{bytes}}$ 字节的原始数据数组，其中 $L_{\\mathrm{bytes}} = \\lceil L/8 \\rceil$。\n\n4. 使用 Deflate 族中的标准 Lempel–Ziv 压缩器，以固定的压缩级别压缩生成的字节序列。为了具体性和可复现性，使用由 zlib 格式实现的 Deflate 算法，压缩级别为 $9$。令 $C_{\\mathrm{bytes}}$ 表示压缩后输出的长度（以字节为单位）。\n\n5. 计算压缩比\n$$\n\\mathcal{R} = \\frac{C_{\\mathrm{bytes}}}{L_{\\mathrm{bytes}}},\n$$\n结果为一个浮点数。\n\n测试套件与覆盖范围：\n对以下跨越不同定性动力学区域的控制参数值评估上述流程：\n- 不动点区域：$r = 2.9$。\n- 周期-2 区域：$r = 3.2$。\n- 超出倍周期分岔的周期区域：$r = 3.5$。\n- 混沌初现（Feigenbaum 点，近似值）：$r = 3.56995$。\n- 混沌区域：$r = 3.8$。\n- 完全发展的混沌：$r = 4.0$。\n\n答案规格：\n- 对于每个指定的 $r$，结果是一个浮点值 $\\mathcal{R}$。\n- 您的程序应生成单行输出，其中包含按上述顺序列出的六个结果，四舍五入到 $6$ 位小数，形式为用方括号括起来的逗号分隔列表，例如：“[0.123456,0.234567,0.345678,0.456789,0.567890,0.678901]”。\n- 不应打印额外的文本或行。\n\n角度单位不适用。不涉及物理单位。本问题中所有数值量必须视为无量纲标量。确保所有计算都使用确定性的双精度浮点运算，并使用指定的精确常数 $B = 1000$、$L = 32768$ 和 $x_0 = 0.123456789$。压缩器必须是应用于所描述的打包字节的 Deflate (zlib)，压缩级别为 $9$。",
            "solution": "所提出的问题是计算物理学中的一个有效练习，特别是在非线性动力学和混沌理论的研究中。它具有科学依据、问题明确，并且所有参数和过程都规定得足够清晰和精确，以允许一个唯一、可复现的计算解。因此，我将继续提供详细的解决方案。\n\n该问题要求分析由逻辑斯谛映射 $x_{n+1} = r\\,x_n(1-x_n)$ 生成的符号序列的复杂度，作为控制参数 $r$ 的函数。复杂度通过序列的可压缩性来量化，使用标准的 Lempel-Ziv 压缩算法进行测量。低的压缩比 $\\mathcal{R}$ 表示一个高度有序、可预测的序列（例如，周期性序列），而接近 $1$ 的高压缩比则表示一个复杂的、类随机的序列，这是混沌的特征。此分析将针对代表逻辑斯谛映射不同动力学区域的几个 $r$ 值进行。\n\n解决方案是通过对每个给定的 $r$ 值遵循问题陈述中规定的五个步骤来实现的。\n\n**第1步：轨迹生成**\n\n系统的核心是逻辑斯谛映射，一个由以下递推关系给出的系统：\n$$x_{n+1} = r \\cdot x_n \\cdot (1 - x_n)$$\n其中 $x_n \\in [0, 1]$ 表示系统在第 $n$ 次迭代时的状态，而 $r \\in [0, 4]$ 是控制动力学定性行为的分岔参数。\n\n我们从指定的初始条件 $x_0 = 0.123456789$ 开始迭代该映射。前 $B=1000$ 次迭代构成一个瞬态阶段。我们丢弃这些值，以确保后续轨迹能准确表示系统的吸引子，从而最大限度地减少对任意选择的 $x_0$ 的依赖。在移除瞬态部分后，我们继续迭代该映射额外的 $L=32768$ 步，记录从 $n=1001$ 到 $1000+32768$ 的每个 $x_n$ 值。这将生成一个包含 $L$ 个实数的时间序列，代表了在吸引子上的稳定动力学。所有计算均使用双精度浮点运算。\n\n**第2步：符号序列生成**\n\n为了分析轨迹的结构，我们将连续值的时序 $\\{x_n\\}$ 转换为离散的二进制符号序列 $\\{s_n\\}$。这个过程是一种粗粒化，通过在中间点 $x=1/2$ 处划分相空间（区间 $[0, 1]$）来实现。这个特定的阈值在动力学上具有重要意义，因为它对应于映射的临界点，在该点函数 $f(x) = r x(1-x)$ 达到其最大值。符号动力学由以下规则定义：\n$$\ns_n = \\begin{cases}\n1,  \\text{if } x_n  1/2 \\\\\n0,  \\text{if } x_n \\le 1/2\n\\end{cases}\n$$\n这将生成一个长度为 $L=32768$ 的二进制序列，其中每个比特指示在该时间步长轨迹是位于区间的右半部分 ($x_n  1/2$) 还是左半部分 ($x_n \\le 1/2$)。\n\n**第3步：比特打包**\n\n标准的压缩算法，例如 `zlib` 库中的算法，作用于字节序列，而不是单个比特。因此，生成的长度为 $L = 32768$ 的二进制序列 $\\{s_n\\}$ 必须被打包到一个字节数组中。由于 $L=32768$ 是 $8$ 的整数倍 ($32768 = 8 \\times 4096$)，该序列恰好由 $L_{\\mathrm{bytes}} = 4096$ 组 $8$ 比特组成。\n\n打包遵循大端约定。序列的前八个比特 $s_0, s_1, \\ldots, s_7$ 构成第一个字节。比特 $s_0$ 成为最高有效位 (MSB)，而 $s_7$ 成为最低有效位 (LSB)。因此，第一个字节的整数值为 $\\sum_{i=0}^{7} s_i 2^{7-i}$。对所有后续的 $8$ 比特组重复此过程，最终得到一个长度为 $L_{\\mathrm{bytes}}=4096$ 的字节数组。问题陈述中包含了当 $L$ 不是 $8$ 的倍数时进行填充的规则，但对于指定的 $L$ 值，此规则不会被调用。\n\n**第4步：压缩**\n\n生成的字节数组使用 DEFLATE 算法进行压缩，该算法在 `zlib` 库中实现，是数据压缩的一个标准。DEFLATE 结合了 LZ77 算法和 Huffman 编码。LZ77 通过查找和替换重复的字节序列为反向引用来实现压缩。这种方法在检测规则模式方面异常有效。一个高度周期的符号序列（例如，来自周期-2 轨道的 `010101...`）将包含大量重复，因此具有高可压缩性。相反，一个混沌序列，它是非周期性和类随机的，将几乎没有重复模式，因此基本上是不可压缩的。\n我们使用最高的压缩级别，即级别 $9$，以确保算法投入最大的计算量来寻找冗余。压缩的输出是另一个字节数组，其长度我们表示为 $C_{\\mathrm{bytes}}$。\n\n**第5步：压缩比计算**\n\n最后，我们将压缩比 $\\mathcal{R}$ 计算为压缩数据大小与原始数据大小之比：\n$$\n\\mathcal{R} = \\frac{C_{\\mathrm{bytes}}}{L_{\\mathrm{bytes}}}\n$$\n这个无量纲量提供了一个对符号序列复杂度的归一化度量。接近 $0$ 的 $\\mathcal{R}$ 值意味着高规律性和低复杂度，而接近 $1$ 的 $\\mathcal{R}$ 值则意味着高复杂度，接近算法随机性。对每个指定的参数 $r$ 值重复此过程，从而可以对不同动力学区域的复杂度进行定量比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport zlib\n\ndef solve():\n    \"\"\"\n    Computes the compression ratio of symbolic sequences from the logistic map\n    for a given set of control parameters `r`.\n    \"\"\"\n    # Define the problem parameters directly as specified.\n    x0 = 0.123456789\n    B = 1000  # Transient iterations\n    L = 32768  # Post-transient sequence length\n\n    # Define the test cases from the problem statement.\n    test_cases_r = [\n        2.9,        # Fixed-point regime\n        3.2,        # Period-2 regime\n        3.5,        # Periodic regime beyond period-doubling\n        3.56995,    # Onset of chaos (Feigenbaum point, approximate)\n        3.8,        # Chaotic regime\n        4.0         # Fully developed chaos\n    ]\n\n    results = []\n    for r in test_cases_r:\n        # Step 1: Generate a real-valued trajectory\n        x = x0\n        \n        # Discard B transient iterations\n        for _ in range(B):\n            x = r * x * (1.0 - x)\n            \n        # Generate L post-transient values\n        trajectory = np.zeros(L, dtype=np.float64)\n        for i in range(L):\n            x = r * x * (1.0 - x)\n            trajectory[i] = x\n\n        # Step 2: Produce a binary symbolic sequence\n        # s_n = 1 if x_n > 0.5, else 0\n        symbolic_sequence = (trajectory > 0.5).astype(np.uint8)\n\n        # Step 3: Pack the L bits into bytes\n        # L = 32768 is a multiple of 8, so no padding is necessary.\n        # np.packbits packs an array of booleans or integers (0 or 1) into bytes.\n        # 'big' bitorder means the first element in each 8-bit chunk is the MSB.\n        original_bytes = np.packbits(symbolic_sequence, bitorder='big').tobytes()\n        L_bytes = len(original_bytes)\n\n        # Step 4: Compress the byte sequence\n        # Use zlib (DEFLATE) with the highest compression level.\n        compressed_bytes = zlib.compress(original_bytes, level=9)\n        C_bytes = len(compressed_bytes)\n\n        # Step 5: Compute the compression ratio\n        compression_ratio = C_bytes / L_bytes\n        results.append(compression_ratio)\n\n    # Format the results as specified: rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}