{
    "hands_on_practices": [
        {
            "introduction": "Before we can measure the information content of an individual string, we must first understand the fundamental constraints governing the programs that describe them. This exercise  delves into Kraft's inequality, a cornerstone of information theory for prefix-free codes. By working through this problem, you will gain hands-on experience applying this principle to determine the limits of what a set of compressed programs can represent, revealing the crucial trade-off between program length and descriptive power.",
            "id": "1647522",
            "problem": "In the theory of computation, a universal computer can be modeled as a device that accepts a binary string, known as a program, and produces an output string. A set of such programs is called *prefix-free* if no program in the set is a prefix of any other program. For instance, the set `{00, 01, 1}` is prefix-free, whereas `{1, 101, 0}` is not, because `1` is a prefix of `101`.\n\nImagine we have a collection of distinct binary strings, where each string has a length of exactly 100 bits. Each of these strings is generated by a unique program from a single prefix-free set of programs. A further constraint is that every program in this set must have a length of 90 bits or less.\n\nWhat is the maximum possible number of distinct binary strings of length 100 that can be generated under these conditions?",
            "solution": "Let $N$ be the maximum number of distinct binary strings we want to find. Let these output strings be $x_1, x_2, \\dots, x_N$. Let the corresponding programs that generate them be $p_1, p_2, \\dots, p_N$. We are given several constraints that we must satisfy simultaneously.\n\nFirst, let's consider the constraint on the output strings. The problem states that the output strings must be distinct and each must have a length of 100 bits. The total number of unique binary strings of length 100 is $2^{100}$. Therefore, the number of generated strings, $N$, cannot exceed this value. This gives us our first upper bound:\n$$ N \\le 2^{100} $$\n\nSecond, let's consider the constraints on the programs. The set of programs $\\{p_1, p_2, \\dots, p_N\\}$ must be prefix-free. The lengths of the strings in any prefix-free set are governed by Kraft's inequality, which states:\n$$ \\sum_{i=1}^{N} 2^{-|p_i|} \\le 1 $$\nwhere $|p_i|$ is the length of the $i$-th program in bits.\n\nThe problem also states that the length of every program must be 90 bits or less. That is, for all $i$:\n$$ |p_i| \\le 90 $$\n\nTo find the maximum possible value for $N$, we need to analyze Kraft's inequality. In the sum $\\sum 2^{-|p_i|}$, each term $2^{-|p_i|}$ represents the \"cost\" of including the program $p_i$ in our prefix-free set. To maximize the number of programs, $N$, for a fixed budget (the sum must be $\\le 1$), we should make the cost of each program as small as possible. The cost $2^{-l}$ is a decreasing function of the length $l$. Therefore, to minimize the cost, we should use programs that are as long as possible.\n\nThe constraint $|p_i| \\le 90$ means the maximum allowed length for any program is 90. This implies that the smallest possible \"cost\" for any program in our set is $2^{-90}$. Therefore, for every program $p_i$, we have:\n$$ 2^{-|p_i|} \\ge 2^{-90} $$\n\nNow, we can substitute this lower bound into the left-hand side of Kraft's inequality:\n$$ \\sum_{i=1}^{N} 2^{-90} \\le \\sum_{i=1}^{N} 2^{-|p_i|} \\le 1 $$\n\nThe leftmost sum simplifies to $N$ identical terms:\n$$ N \\cdot 2^{-90} \\le 1 $$\n\nSolving for $N$, we find our second upper bound:\n$$ N \\le 2^{90} $$\n\nWe now have two upper bounds for $N$: $N \\le 2^{100}$ from the output space and $N \\le 2^{90}$ from the program space constraints. To satisfy both conditions, $N$ must be less than or equal to the smaller of these two bounds:\n$$ N \\le \\min(2^{100}, 2^{90}) $$\n$$ N \\le 2^{90} $$\n\nThis shows that the maximum possible number of strings is at most $2^{90}$. To confirm this is the actual maximum, we must show that it is achievable. We can construct a set of programs consisting of all possible binary strings of length exactly 90. This set contains $2^{90}$ strings. It is inherently prefix-free because no string of a given length can be a prefix of another distinct string of the same length. For this set of programs, Kraft's inequality is satisfied with equality:\n$$ \\sum_{i=1}^{2^{90}} 2^{-90} = 2^{90} \\cdot 2^{-90} = 1 $$\nSo, this is a valid prefix-free set of programs. Since we have $2^{90}$ valid programs, and the number of possible unique output strings of length 100 is $2^{100}$ (which is larger than $2^{90}$), we can certainly assign a unique output string to each of our $2^{90}$ programs.\n\nThus, the maximum number of distinct strings that can be generated is $2^{90}$.",
            "answer": "$$\\boxed{2^{90}}$$"
        },
        {
            "introduction": "Kolmogorov complexity's true power lies in its ability to formally quantify our intuitive notion of 'simplicity.' This practice  provides a direct and tangible example of this by asking you to calculate the complexity of a highly repetitive string. By summing the information content of a simple pattern and the instruction for repeating it, you will see how algorithmic compression captures the low information content of structured data.",
            "id": "1647532",
            "problem": "In theoretical computer science, the prefix-free Kolmogorov complexity of a binary string $x$, denoted $K(x)$, represents the length in bits of the shortest self-delimiting computer program that can generate $x$ and then halt. It serves as a measure of the ultimate compressibility of that specific string.\n\nConsider a long binary string $X$ that is constructed by repeating a shorter binary string $s$ a total of $n$ times. That is, $X = s^n$, meaning the string $s$ is concatenated with itself $n$ times.\n\nThe specific parameters for this construction are as follows:\n- The base string $s$ has a length of $L_s = 1000$ bits.\n- The number of repetitions is $n = 256$.\n\nThe following models are provided for the complexity of the components:\n1.  The base string $s$ is known to be algorithmically random, or incompressible. Its prefix-free complexity is accurately modeled by the relation $K(s) = L_s + c$, where $c=12$ bits is a small overhead constant related to the program's structure.\n2.  To generate the full string $X$, a program needs to know both the base string $s$ and the number of repetitions $n$. The information content of the integer $n$ is given by its own prefix-free complexity, $K(n)$. For an integer $m > 1$, a good approximation for its complexity is given by the formula $K(m) = \\log_{2}(m) + 2\\log_{2}(\\log_{2}(m))$.\n3.  The total complexity of generating the string $X$ is estimated by summing the complexities of its independent components. You can assume this relationship is exact for this problem: $K(X) = K(s) + K(n)$.\n\nBased on this model, calculate the total prefix-free Kolmogorov complexity, $K(X)$, of the string $X$. Provide your answer as a single integer, representing the complexity in bits.",
            "solution": "We are given a string $X = s^{n}$ where $s$ has length $L_{s}=1000$ bits and $n=256$. The total prefix-free Kolmogorov complexity is modeled as\n$$\nK(X) = K(s) + K(n).\n$$\nBy assumption, $s$ is algorithmically random with\n$$\nK(s) = L_{s} + c = 1000 + 12 = 1012 \\text{ bits}.\n$$\nFor the integer $n$, we use the provided approximation (taken as the model here) for $m>1$:\n$$\nK(m) = \\log_{2}(m) + 2\\log_{2}(\\log_{2}(m)).\n$$\nSubstituting $n=256$, we compute\n$$\n\\log_{2}(256) = 8, \\quad \\log_{2}(\\log_{2}(256)) = \\log_{2}(8) = 3,\n$$\nso\n$$\nK(n) = 8 + 2 \\cdot 3 = 14 \\text{ bits}.\n$$\nTherefore, the total complexity is\n$$\nK(X) = 1012 + 14 = 1026 \\text{ bits}.\n$$",
            "answer": "$$\\boxed{1026}$$"
        },
        {
            "introduction": "For recursively defined structures, finding the shortest program directly can be intractable, requiring more sophisticated analytical tools. This advanced problem  introduces the powerful technique of establishing upper and lower bounds on complexity to characterize a string's information content. You will demonstrate that the complexity of a Cantor-like set, despite its exponential growth in length, is fundamentally tied only to the complexity of the integer $n$ defining its construction stage, an outcome expressed as $K(S_n) = K(n) + O(1)$.",
            "id": "1647488",
            "problem": "A family of binary strings $\\{S_n\\}_{n \\geq 0}$ is constructed based on a recursive rule inspired by the generation of the middle-thirds Cantor set. The base case is the string $S_0 = \\text{'1'}$. For any integer $n \\geq 1$, the string $S_n$ is formed by concatenating the string $S_{n-1}$, a block of $3^{n-1}$ zeros, and a second copy of $S_{n-1}$. For instance, this rule yields $S_1 = \\text{'101'}$ and $S_2 = \\text{'101000101'}$.\n\nLet $K(x)$ denote the prefix-free Kolmogorov complexity of a finite binary string $x$, which is the length of the shortest self-delimiting program that outputs $x$ on a universal Turing machine. Determine the complexity $K(S_n)$ in terms of $K(n)$, the complexity of the integer $n$. Your answer should be an expression that is accurate up to an additive constant, which can be represented using big O notation as $O(1)$.",
            "solution": "The problem asks for the prefix-free Kolmogorov complexity $K(S_n)$ of a recursively defined binary string $S_n$. We will determine this by finding both an upper bound and a lower bound for $K(S_n)$ in terms of $K(n)$.\n\n**1. Deriving the Upper Bound**\n\nThe prefix-free Kolmogorov complexity $K(x)$ of a string $x$ is bounded above by the length of any self-delimiting description of $x$. We can construct a program that generates $S_n$ given the integer $n$. The length of this program's description will serve as an upper bound for $K(S_n)$.\n\nLet's design a description for $S_n$. This description will consist of two parts:\na) A fixed program, let's call it $P_{gen}$, that implements the recursive rule $S_n = S_{n-1} \\cdot 0^{3^{n-1}} \\cdot S_{n-1}$.\nb) The input data for this program, which is the integer $n$.\n\nThe program $P_{gen}$ can be described as follows:\n- It is a recursive function, say `generate_S(k)`.\n- If the input `k` is 0, it returns the string '1'.\n- If `k` is greater than 0, it calls `generate_S(k-1)` to get the string $S_{k-1}$, computes the length of the zero block as $3^{k-1}$, creates a string of that many zeros, and concatenates the three parts: $S_{k-1}$, the zero string, and $S_{k-1}$.\nThe code for this program $P_{gen}$ is fixed and does not depend on $n$. Therefore, its length in bits is a constant, which we can denote as $c_1$.\n\nTo generate a specific string $S_n$, this program $P_{gen}$ needs the integer $n$ as input. To make the entire description self-delimiting, we must provide $n$ in a prefix-free format. The length of the shortest prefix-free description of the integer $n$ is, by definition, $K(n)$.\n\nA complete, self-delimiting description of $S_n$ is thus the concatenation of the program description for $P_{gen}$ and the prefix-free description of $n$. A universal Turing machine would first read the description of $P_{gen}$, understand how to execute it, and then read the subsequent data, $n$, in its prefix-free format. The total length of this description is $|P_{gen}| + K(n) = c_1 + K(n)$.\n\nSince $K(S_n)$ is the length of the *shortest* such description, we have the upper bound:\n$$K(S_n) \\le c_1 + K(n)$$\nUsing big O notation, this is expressed as:\n$$K(S_n) \\le K(n) + O(1)$$\n\n**2. Deriving the Lower Bound**\n\nTo find a lower bound, we will show that the integer $n$ can be effectively recovered from the string $S_n$. If we can describe a program that takes $S_n$ as input and produces $n$ as output, we can establish a relationship between their complexities.\n\nFirst, let's determine the length of the string $S_n$, which we'll denote as $L_n$.\n$L_0 = |S_0| = 1 = 3^0$.\n$L_n = |S_n| = |S_{n-1}| + 3^{n-1} + |S_{n-1}| = 2 L_{n-1} + 3^{n-1}$.\nLet's solve this recurrence. Divide by $3^n$:\n$\\frac{L_n}{3^n} = \\frac{2}{3} \\frac{L_{n-1}}{3^{n-1}} + \\frac{1}{3}$.\nLet $a_n = L_n / 3^n$. The recurrence is $a_n = \\frac{2}{3} a_{n-1} + \\frac{1}{3}$.\nThe fixed point is $a = \\frac{2}{3}a + \\frac{1}{3} \\implies \\frac{1}{3}a = \\frac{1}{3} \\implies a=1$.\nSo, $a_n - 1 = \\frac{2}{3} (a_{n-1} - 1)$. This gives $a_n - 1 = (\\frac{2}{3})^n (a_0 - 1)$.\nSince $a_0 = L_0/3^0 = 1$, we have $a_0 - 1 = 0$. Therefore, $a_n - 1 = 0$, which means $a_n = 1$ for all $n$.\nThus, $L_n = 3^n$.\n\nNow, consider a program $P_{rec}$ that takes a string $x$ as input and performs the following steps:\n- Measure the length of the input string, $L = |x|$.\n- Calculate the value $k = \\log_3(L)$.\n- Output the integer $k$.\n\nIf we run this program with the input $x = S_n$, its length is $L_n = 3^n$. The program will compute $k = \\log_3(3^n) = n$ and output $n$.\nThis program $P_{rec}$ allows us to recover $n$ from $S_n$. The program itself has a fixed description of constant length, say $c_2$.\nThis implies that the conditional complexity of $n$ given $S_n$ is bounded by a constant:\n$$K(n|S_n) \\le c_2 = O(1)$$\n\nOne of the fundamental properties (a chain rule) of Kolmogorov complexity states that, up to an additive constant, $K(n) \\le K(S_n) + K(n|S_n)$.\nSubstituting our finding for the conditional complexity:\n$$K(n) \\le K(S_n) + O(1)$$\nRearranging this inequality gives us a lower bound for $K(S_n)$:\n$$K(S_n) \\ge K(n) - O(1)$$\n\n**3. Combining the Bounds**\n\nWe have established a pair of inequalities:\n1. Upper bound: $K(S_n) \\le K(n) + O(1)$\n2. Lower bound: $K(S_n) \\ge K(n) - O(1)$\n\nThese two bounds together constrain the value of $K(S_n)$. They imply that $K(S_n)$ and $K(n)$ differ by at most an additive constant. This relationship is expressed as:\n$$K(S_n) = K(n) + O(1)$$\nThis result shows that the complexity of this highly structured, exponentially long string is essentially the same as the complexity of the integer that defines its iteration number.",
            "answer": "$$\\boxed{K(n) + O(1)}$$"
        }
    ]
}