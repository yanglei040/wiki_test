{
    "hands_on_practices": [
        {
            "introduction": "在对整个程序进行数据流分析之前，我们必须首先理解每个基本块内部发生了什么。此练习  专注于计算“向上暴露变量”($\\mathrm{UEVAR}$ 或 $\\mathrm{USE}$)和“变量杀死”($\\mathrm{VARKILL}$ 或 $\\mathrm{DEF}$)集合，它们是全局数据流分析算法的基本输入。通过将变量映射到比特位，我们还将实践一种在编译器中常见且高效的实现技术——位向量。",
            "id": "3651457",
            "problem": "给定一个程序，其结构为控制流图 (CFG)，其中每个节点都是一个基本块 (BB)。程序变量的集合是 $$V = \\{a, b, c, d, e, f, g, h, x\\}$$，这些变量按顺序分别映射到位位置 $$0, 1, 2, 3, 4, 5, 6, 7, 8$$。集合 $$V$$ 上的一个位向量被解释为一个非负整数掩码，当且仅当位置 $$i$$ 上的变量在该集合中时，该掩码的位 $$i$$ 被设置，其位权为 $$2^{i}$$。\n\n基本块和语句如下：\n- $$B_{1}: \\quad x := a + b; \\quad c := x + d; \\quad e := c; \\quad \\mathrm{goto}\\ B_{2}.$$\n- $$B_{2}: \\quad \\mathrm{if}\\ e > f\\ \\mathrm{goto}\\ B_{3}\\ \\mathrm{else}\\ \\mathrm{goto}\\ B_{4}.$$\n- $$B_{3}: \\quad d := e + g; \\quad a := d + 2; \\quad \\mathrm{goto}\\ B_{5}.$$\n- $$B_{4}: \\quad b := h + 1; \\quad g := b + e; \\quad \\mathrm{goto}\\ B_{5}.$$\n- $$B_{5}: \\quad f := a + g; \\quad \\mathrm{return}\\ f.$$\n\n使用活跃变量分析的基本原理定义，为每个基本块计算向上暴露变量 (UEVAR) 集合和变量扼杀 (VARKILL) 集合。在此，如果一个变量在同一基本块内，其使用先于对该变量的任何定义，则称该变量在该块中是向上暴露的。如果一个变量在一个基本块内被定义（赋值），则称该变量在该块中被扼杀。\n\n设 $$M_{\\mathrm{UE}}(B_{i})$$ 是 $$UEVAR(B_{i})$$ 的整数掩码，$$M_{\\mathrm{VK}}(B_{i})$$ 是 $$VARKILL(B_{i})$$ 在给定 位映射下的整数掩码。计算值\n$$N = \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) \\;+\\; 2 \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}).$$\n\n提供单个整数 $$N$$作为您的最终答案。无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是合理的。这是一个编译原理领域（特别是数据流分析）中的良构问题。所有必要的定义和数据都已提供，没有内部矛盾或歧义。我们可以开始求解。\n\n该问题要求我们为给定控制流图 (CFG) 中的每个基本块 ($$B_i$$) 计算两个集合：向上暴露变量 ($$UEVAR$$) 和变量扼杀 ($$VARKILL$$) 集合。根据这些集合，我们必须计算它们对应的整数掩码 $$M_{\\mathrm{UE}}(B_{i})$$ 和 $$M_{\\mathrm{VK}}(B_{i})$$，并用它们来计算最终值 $$N$$。\n\n变量集合为 $$V = \\{a, b, c, d, e, f, g, h, x\\}$$。从变量到位位置 $$i$$（因此到位权 $$2^i$$）的映射如下：\n- $$a \\to 0 \\quad (2^0 = 1)$$\n- $$b \\to 1 \\quad (2^1 = 2)$$\n- $$c \\to 2 \\quad (2^2 = 4)$$\n- $$d \\to 3 \\quad (2^3 = 8)$$\n- $$e \\to 4 \\quad (2^4 = 16)$$\n- $$f \\to 5 \\quad (2^5 = 32)$$\n- $$g \\to 6 \\quad (2^6 = 64)$$\n- $$h \\to 7 \\quad (2^7 = 128)$$\n- $$x \\to 8 \\quad (2^8 = 256)$$\n\n我们将按顺序分析每个基本块。\n\n**$$B_1$$ 块的分析**\n$$B_1$$ 中的语句是：$$x := a + b; \\quad c := x + d; \\quad e := c;$$\n- 为了找到 $$UEVAR(B_1)$$，我们识别出在该块内定义之前就被使用的变量。\n  - 在 $$x := a + b$$ 中，变量 $$a$$ 和 $$b$$ 被使用。在 $$B_1$$ 中，此语句之前它们都未被定义。\n  - 在 $$c := x + d$$ 中，变量 $$x$$ 和 $$d$$ 被使用。变量 $$x$$ 在前一条语句中被定义。变量 $$d$$ 尚未被定义。\n  - 在 $$e := c$$ 中，变量 $$c$$ 被使用。它在前一条语句中被定义。\n  - 因此，向上暴露变量的集合是 $$UEVAR(B_1) = \\{a, b, d\\}$$。\n- 为了找到 $$VARKILL(B_1)$$，我们识别出在该块中被赋值（定义）的所有变量。\n  - 被定义的变量是 $$x, c, e$$。\n  - 因此，扼杀集合是 $$VARKILL(B_1) = \\{x, c, e\\}$$。\n\n**$$B_2$$ 块的分析**\n$$B_2$$ 中的语句是：$$\\mathrm{if}\\ e > f\\ \\mathrm{goto}\\ B_{3}\\ \\mathrm{else}\\ \\mathrm{goto}\\ B_{4}.$$\n- 为了找到 $$UEVAR(B_2)$$，我们识别出在条件表达式中使用的变量。\n  - 变量 $$e$$ 和 $$f$$ 被使用。\n  - 此块中没有变量被定义。\n  - 因此，$$UEVAR(B_2) = \\{e, f\\}$$。\n- 为了找到 $$VARKILL(B_2)$$，我们识别出被定义的变量。没有。\n  - 因此，$$VARKILL(B_2) = \\emptyset$$。\n\n**$$B_3$$ 块的分析**\n$$B_3$$ 中的语句是：$$d := e + g; \\quad a := d + 2;$$\n- 为了找到 $$UEVAR(B_3)$$：\n  - 在 $$d := e + g$$ 中，变量 $$e$$ 和 $$g$$ 被使用。在 $$B_3$$ 中，它们在此使用之前都未被定义。\n  - 在 $$a := d + 2$$ 中，变量 $$d$$ 被使用，但它在同一个块内的前一条语句中被定义。\n  - 因此，$$UEVAR(B_3) = \\{e, g\\}$$。\n- 为了找到 $$VARKILL(B_3)$$：\n  - 被定义的变量是 $$d$$ 和 $$a$$。\n  - 因此，$$VARKILL(B_3) = \\{a, d\\}$$。\n\n**$$B_4$$ 块的分析**\n$$B_4$$ 中的语句是：$$b := h + 1; \\quad g := b + e;$$\n- 为了找到 $$UEVAR(B_4)$$：\n  - 在 $$b := h + 1$$ 中，变量 $$h$$ 被使用，且在 $$B_4$$ 中之前未被定义。\n  - 在 $$g := b + e$$ 中，变量 $$b$$ 和 $$e$$ 被使用。$$b$$ 在前一条语句中被定义。$$e$$ 在 $$B_4$$ 中尚未被定义。\n  - 因此，$$UEVAR(B_4) = \\{h, e\\}$$。\n- 为了找到 $$VARKILL(B_4)$$：\n  - 被定义的变量是 $$b$$ 和 $$g$$。\n  - 因此，$$VARKILL(B_4) = \\{b, g\\}$$。\n\n**$$B_5$$ 块的分析**\n$$B_5$$ 中的语句是：$$f := a + g; \\quad \\mathrm{return}\\ f;$$\n- 为了找到 $$UEVAR(B_5)$$：\n  - 在 $$f := a + g$$ 中，变量 $$a$$ 和 $$g$$ 被使用。在 $$B_5$$ 中，它们都未被定义。\n  - 在 $$\\mathrm{return}\\ f$$ 中，变量 $$f$$ 被使用，但它刚刚被定义。\n  - 因此，$$UEVAR(B_5) = \\{a, g\\}$$。\n- 为了找到 $$VARKILL(B_5)$$：\n  - 被定义的变量是 $$f$$。\n  - 因此，$$VARKILL(B_5) = \\{f\\}$$。\n\n现在，我们为每个集合计算整数掩码。\n$$M_{\\mathrm{UE}}(B_1) \\text{ 对于 } \\{a,b,d\\}: 2^0+2^1+2^3 = 1+2+8 = 11$$\n$$M_{\\mathrm{VK}}(B_1) \\text{ 对于 } \\{x,c,e\\}: 2^8+2^2+2^4 = 256+4+16 = 276$$\n\n$$M_{\\mathrm{UE}}(B_2) \\text{ 对于 } \\{e,f\\}: 2^4+2^5 = 16+32 = 48$$\n$$M_{\\mathrm{VK}}(B_2) \\text{ 对于 } \\emptyset: 0$$\n\n$$M_{\\mathrm{UE}}(B_3) \\text{ 对于 } \\{e,g\\}: 2^4+2^6 = 16+64 = 80$$\n$$M_{\\mathrm{VK}}(B_3) \\text{ 对于 } \\{a,d\\}: 2^0+2^3 = 1+8 = 9$$\n\n$$M_{\\mathrm{UE}}(B_4) \\text{ 对于 } \\{h,e\\}: 2^7+2^4 = 128+16 = 144$$\n$$M_{\\mathrm{VK}}(B_4) \\text{ 对于 } \\{b,g\\}: 2^1+2^6 = 2+64 = 66$$\n\n$$M_{\\mathrm{UE}}(B_5) \\text{ 对于 } \\{a,g\\}: 2^0+2^6 = 1+64 = 65$$\n$$M_{\\mathrm{VK}}(B_5) \\text{ 对于 } \\{f\\}: 2^5 = 32$$\n\n接下来，我们计算最终值 $$N$$ 所需的两个总和。\n首先，是 $$M_{\\mathrm{UE}}$$ 掩码的总和：\n$$ \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) = 11 + 48 + 80 + 144 + 65 $$\n$$ \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) = 59 + 80 + 144 + 65 = 139 + 144 + 65 = 283 + 65 = 348 $$\n\n其次，是 $$M_{\\mathrm{VK}}$$ 掩码的总和：\n$$ \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) = 276 + 0 + 9 + 66 + 32 $$\n$$ \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) = 276 + 9 + 66 + 32 = 285 + 66 + 32 = 351 + 32 = 383 $$\n\n最后，我们使用给定的公式计算 $$N$$：\n$$ N = \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) \\;+\\; 2 \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) $$\n$$ N = 348 + 2 \\times 383 $$\n$$ N = 348 + 766 $$\n$$ N = 1114 $$",
            "answer": "$$\\boxed{1114}$$"
        },
        {
            "introduction": "掌握了单个基本块的分析方法后，我们现在可以解决全局问题。此练习  演示了如何应用迭代式向后数据流方程，在整个控制流图上传播活跃度信息，即使图中包含 `switch` 语句等复杂结构。解决这个问题将揭示活跃度信息是如何从变量的使用点“流”回到其定义点的。",
            "id": "3651499",
            "problem": "考虑一个过程的以下控制流图 (Control Flow Graph, CFG)，它由带标签的基本块组成。我们仅对变量 $x$ 进行活跃变量分析 (Live Variable Analysis, LVA)。\n\n基本块如下：\n- $B_1$：$x := u + v$；goto $B_S$。\n- $B_S$：基于 $t$ 的稀疏目标 switch 语句：case $0 \\to B_2$，case $5 \\to B_3$，case $9 \\to B_4$，default $\\to B_5$。\n- $B_2$：$y := x + 1$；goto $B_6$。\n- $B_3$：if $p$ then goto $B_7$ else goto $B_8$。\n- $B_7$：$z := x$；goto $B_6$。\n- $B_8$：$z := 0$；goto $B_6$。\n- $B_4$：$y := 2$；goto $B_6$。\n- $B_5$：$w := 4$；goto $B_6$。\n- $B_6$：$x := y + z$；goto $B_9$。\n- $B_9$：return $x$。\n\n假设采用常规语义：$B_S$ 中的 switch 语句根据 $t$ 的值将控制权转移到其目标块之一；$B_3$ 中的测试根据 $p$ 的值分支到 $B_7$ 或 $B_8$；$B_9$ 是出口块。不发生其他副作用。只需分析 $x$ 的活跃性；其他变量（$u$、$v$、$y$、$z$、$w$、$t$、$p$）仅在它们出现在语句中时才需要考虑。\n\n使用数据流分析的基本原理，计算每个基本块 $B$ 关于 $x$ 的 $IN[B]$ 和 $OUT[B]$ 集合。然后，确定其入口集合 $IN[B]$ 包含 $x$ 的基本块的总数。\n\n你的最终答案必须是一个实数，等于入口处 $x$ 活跃的基本块的数量。无需四舍五入。最终答案应表示为不带单位的纯数字。",
            "solution": "我们从控制流图 (CFG) 上的活跃变量分析 (LVA) 的基本定义开始。对于每个基本块 $B$，定义：\n- $USE[B]$：在 $B$ 中任何重新定义之前被读取的变量集合。\n- $DEF[B]$：在 $B$ 中定义的变量集合。\n\nLVA 的经典后向数据流方程为：\n$$\nIN[B] = USE[B] \\cup \\left(OUT[B] \\setminus DEF[B]\\right),\n$$\n$$\nOUT[B] = \\bigcup_{S \\in succ(B)} IN[S],\n$$\n其中 $succ(B)$ 是 $B$ 的后继块集合。在过程的出口处，我们将 $OUT$ 集合视为空集。\n\n我们只分析变量 $x$，所以每个 $USE[B]$、$DEF[B]$、$IN[B]$ 和 $OUT[B]$ 要么是 $\\emptyset$，要么是 $\\{x\\}$。\n\n首先，列出后继块：\n- $succ(B_1) = \\{B_S\\}$。\n- $succ(B_S) = \\{B_2, B_3, B_4, B_5\\}$。\n- $succ(B_2) = \\{B_6\\}$。\n- $succ(B_3) = \\{B_7, B_8\\}$。\n- $succ(B_7) = \\{B_6\\}$。\n- $succ(B_8) = \\{B_6\\}$。\n- $succ(B_4) = \\{B_6\\}$。\n- $succ(B_5) = \\{B_6\\}$。\n- $succ(B_6) = \\{B_9\\}$。\n- $succ(B_9) = \\emptyset$。\n\n接下来，计算关于 $x$ 的 $USE[B]$ 和 $DEF[B]$：\n- $B_1$：通过 $x := u + v$ 定义了 $x$，所以 $DEF[B_1] = \\{x\\}$，$USE[B_1] = \\emptyset$。\n- $B_S$：没有提及 $x$，所以 $DEF[B_S] = \\emptyset$，$USE[B_S] = \\emptyset$。\n- $B_2$：在 $y := x + 1$ 中使用了 $x$，所以 $USE[B_2] = \\{x\\}$，$DEF[B_2] = \\emptyset$。\n- $B_3$：没有提及 $x$，所以 $USE[B_3] = \\emptyset$，$DEF[B_3] = \\emptyset$。\n- $B_7$：在 $z := x$ 中使用了 $x$，所以 $USE[B_7] = \\{x\\}$，$DEF[B_7] = \\emptyset$。\n- $B_8$：没有提及 $x$，所以 $USE[B_8] = \\emptyset$，$DEF[B_8] = \\emptyset$。\n- $B_4$：没有提及 $x$，所以 $USE[B_4] = \\emptyset$，$DEF[B_4] = \\emptyset$。\n- $B_5$：没有提及 $x$，所以 $USE[B_5] = \\emptyset$，$DEF[B_5] = \\emptyset$。\n- $B_6$：通过 $x := y + z$ 定义了 $x$，并且在右侧没有读取 $x$，所以 $DEF[B_6] = \\{x\\}$，$USE[B_6] = \\emptyset$。\n- $B_9$：在 return $x$ 中使用了 $x$，所以 $USE[B_9] = \\{x\\}$，$DEF[B_9] = \\emptyset$。\n\n我们现在从出口开始，从后向前求解方程：\n- 对于 $B_9$，$OUT[B_9] = \\emptyset$ (出口)。那么\n  $$\n  IN[B_9] = USE[B_9] \\cup (OUT[B_9] \\setminus DEF[B_9]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}。\n  $$\n\n- 对于 $B_6$，$OUT[B_6] = IN[B_9] = \\{x\\}$。那么\n  $$\n  IN[B_6] = USE[B_6] \\cup (OUT[B_6] \\setminus DEF[B_6]) = \\emptyset \\cup (\\{x\\} \\setminus \\{x\\}) = \\emptyset。\n  $$\n\n- 对于 $B_2$，$OUT[B_2] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_2] = USE[B_2] \\cup (OUT[B_2] \\setminus DEF[B_2]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}。\n  $$\n\n- 对于 $B_7$，$OUT[B_7] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_7] = USE[B_7] \\cup (OUT[B_7] \\setminus DEF[B_7]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}。\n  $$\n\n- 对于 $B_8$，$OUT[B_8] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_8] = USE[B_8] \\cup (OUT[B_8] \\setminus DEF[B_8]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset。\n  $$\n\n- 对于 $B_4$，$OUT[B_4] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_4] = USE[B_4] \\cup (OUT[B_4] \\setminus DEF[B_4]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset。\n  $$\n\n- 对于 $B_5$，$OUT[B_5] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_5] = USE[B_5] \\cup (OUT[B_5] \\setminus DEF[B_5]) = \\emptyset。\n  $$\n\n- 对于 $B_3$，$OUT[B_3] = IN[B_7] \\cup IN[B_8] = \\{x\\} \\cup \\emptyset = \\{x\\}$。那么\n  $$\n  IN[B_3] = USE[B_3] \\cup (OUT[B_3] \\setminus DEF[B_3]) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}。\n  $$\n\n- 对于 $B_S$，$OUT[B_S] = IN[B_2] \\cup IN[B_3] \\cup IN[B_4] \\cup IN[B_5] = \\{x\\} \\cup \\{x\\} \\cup \\emptyset \\cup \\emptyset = \\{x\\}$。那么\n  $$\n  IN[B_S] = USE[B_S] \\cup (OUT[B_S] \\setminus DEF[B_S]) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}。\n  $$\n\n- 对于 $B_1$，$OUT[B_1] = IN[B_S] = \\{x\\}$。那么\n  $$\n  IN[B_1] = USE[B_1] \\cup (OUT[B_1] \\setminus DEF[B_1]) = \\emptyset \\cup (\\{x\\} \\setminus \\{x\\}) = \\emptyset。\n  $$\n\n收集 $IN$ 集合：\n- $IN[B_1] = \\emptyset$，\n- $IN[B_S] = \\{x\\}$，\n- $IN[B_2] = \\{x\\}$，\n- $IN[B_3] = \\{x\\}$，\n- $IN[B_4] = \\emptyset$，\n- $IN[B_5] = \\emptyset$，\n- $IN[B_6] = \\emptyset$，\n- $IN[B_7] = \\{x\\}$，\n- $IN[B_8] = \\emptyset$，\n- $IN[B_9] = \\{x\\}$。\n\n因此，其入口集合包含 $x$ 的基本块的总数是 $IN[B] = \\{x\\}$ 的块的数量，即 5 个（也就是 $B_S$、$B_2$、$B_3$、$B_7$ 和 $B_9$）。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "我们为什么要进行活跃变量分析？这个最终的练习  揭示了其最重要的应用之一：寄存器分配。通过确定哪些变量在程序的某个点上同时活跃，我们可以构建一个冲突图 (interference graph)。这个图是图着色寄存器分配算法的基石，这是一种经典而强大的编译器优化技术，此练习将抽象的分析与具体的编译器任务联系起来。",
            "id": "3651500",
            "problem": "考虑以下用三地址风格编写的伪程序。其控制流图 (CFG) 由四个基本块组成，边为 $B_{1} \\rightarrow B_{2}$、$B_{1} \\rightarrow B_{3}$、$B_{2} \\rightarrow B_{4}$ 和 $B_{3} \\rightarrow B_{4}$。只有变量 $x$、$y$ 和 $z$ 是寄存器分配的候选对象；所有其他符号表示常驻内存的值，不属于该寄存器分配问题的一部分。\n\n块 $B_{1}$:\n- $x := a + 1$\n- $y := b + 1$\n- if $p$ goto $B_{2}$ else goto $B_{3}$\n\n块 $B_{2}$:\n- $z := x + y$\n- $y := z + c$\n- goto $B_{4}$\n\n块 $B_{3}$:\n- $z := y + d$\n- $x := z + e$\n- goto $B_{4}$\n\n块 $B_{4}$:\n- $r := x + y + z$\n- return $r$\n\n使用标准的用于活跃变量分析的前向流和后向流数据流框架，以及经典方程\n- $\\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s)$,\n- $\\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup \\left( \\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n) \\right)$,\n其中 $\\mathrm{Use}(n)$ 和 $\\mathrm{Def}(n)$ 是相对于集合 $\\{x,y,z\\}$ 计算的，请执行以下操作：\n\n- 推导每个基本块 $B_{1}$、$B_{2}$、$B_{3}$ 和 $B_{4}$ 的 $\\mathrm{Use}$ 和 $\\mathrm{Def}$ 集合。\n- 求解数据流方程，以获得每个基本块的 $\\mathrm{LiveIn}$ 和 $\\mathrm{LiveOut}$ 集合。\n- 根据活跃性信息，构建干涉图，其顶点为 $\\{x,y,z\\}$，其中两个变量之间的边表示它们在某个程序点上同时活跃。\n- 在寄存器分配模型中，分配 $k$ 个寄存器对应于用 $k$ 种颜色对干涉图进行正常着色。请确定一个关于 $k$ 的闭式解析表达式，表示该程序对 $\\{x,y,z\\}$ 进行有效的 $k$ 寄存器分配的数量。\n\n将您的最终答案表示为关于 $k$ 的单个解析表达式。不需要四舍五入。最终答案中不要包含任何单位。",
            "solution": "用户希望我解决一个编译器优化问题。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n-   **程序结构**：一个三地址风格的伪程序。\n-   **控制流图 (CFG)**：\n    -   基本块：$B_{1}$、$B_{2}$、$B_{3}$、$B_{4}$。\n    -   边：$B_{1} \\rightarrow B_{2}$、$B_{1} \\rightarrow B_{3}$、$B_{2} \\rightarrow B_{4}$、$B_{3} \\rightarrow B_{4}$。\n    -   后继节点：$\\mathrm{succ}(B_1) = \\{B_2, B_3\\}$、$\\mathrm{succ}(B_2) = \\{B_4\\}$、$\\mathrm{succ}(B_3) = \\{B_4\\}$、$\\mathrm{succ}(B_4) = \\emptyset$。\n-   **用于寄存器分配的变量**：$\\{x, y, z\\}$。其他符号（$a, b, c, d, e, p, r$）是常驻内存的。\n-   **基本块代码**：\n    -   块 $B_{1}$：\n        -   $x := a + 1$\n        -   $y := b + 1$\n        -   if $p$ goto $B_{2}$ else goto $B_{3}$\n    -   块 $B_{2}$：\n        -   $z := x + y$\n        -   $y := z + c$\n        -   goto $B_{4}$\n    -   块 $B_{3}$：\n        -   $z := y + d$\n        -   $x := z + e$\n        -   goto $B_{4}$\n    -   块 $B_{4}$：\n        -   $r := x + y + z$\n        -   return $r$\n-   **活跃变量分析框架**：\n    -   类型：后向流数据流分析。\n    -   方程：\n        -   $\\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s)$\n        -   $\\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup \\left( \\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n) \\right)$\n    -   集合 $\\mathrm{Use}(n)$ 和 $\\mathrm{Def}(n)$ 是相对于变量 $\\{x, y, z\\}$ 计算的。\n-   **任务**：\n    1.  推导每个基本块的 $\\mathrm{Use}$ 和 $\\mathrm{Def}$ 集合。\n    2.  求解数据流方程以获得 $\\mathrm{LiveIn}$ 和 $\\mathrm{LiveOut}$ 集合。\n    3.  为 $\\{x, y, z\\}$ 构建干涉图。\n    4.  确定一个关于 $k$ 的闭式解析表达式，表示有效的 $k$ 寄存器分配的数量。\n\n**步骤2：使用提取的给定信息进行验证**\n\n-   **科学上成立**：该问题是编译器设计中的一个标准练习，具体涉及寄存器分配。活跃变量分析、干涉图和图着色是该领域中基础且成熟的概念。该问题在科学上是合理的。\n-   **适定的**：问题陈述清晰，提供了所有必要信息。任务是顺序的，并导向一个唯一可确定的答案。\n-   **客观的**：问题使用精确、无歧义的技术语言描述。它没有任何主观或基于意见的陈述。\n-   **完整性**：所有必需的定义、代码和数据流方程都已提供。该问题是自包含的。\n-   **一致性**：CFG结构和代码中的`goto`语句是一致的。问题设置中没有矛盾。\n-   **可行性**：该问题是一个小型的教科书式示例，因此完全可以通过手动计算解决。\n\n**步骤3：结论和行动**\n\n问题是有效的。这是一个适定的、编译器原理中的标准学术问题。我将继续进行解答。\n\n### 解题过程\n\n解题过程按要求分为四个步骤：计算 `Use/Def` 集合，求解活跃性数据流方程，构建干涉图，以及为该图寻找色多项式。\n\n**1. $\\mathrm{Use}$ 和 $\\mathrm{Def}$ 集合的推导**\n\n集合 $\\mathrm{Use}(n)$ 包含在块 $n$ 中定义之前被使用的变量（来自 $\\{x, y, z\\}$）。集合 $\\mathrm{Def}(n)$ 包含在块 $n$ 中被定义（赋值）的变量（来自 $\\{x, y, z\\}$）。\n\n-   **块 $B_{1}$**：\n    -   `x := a + 1`：定义 $x$。\n    -   `y := b + 1`：定义 $y$。\n    -   没有来自 $\\{x, y, z\\}$ 的变量在被定义前使用。\n    -   $\\mathrm{Use}(B_{1}) = \\emptyset$\n    -   $\\mathrm{Def}(B_{1}) = \\{x, y\\}$\n\n-   **块 $B_{2}$**：\n    -   `z := x + y`：使用 $x$ 和 $y$，定义 $z$。\n    -   `y := z + c`：使用 $z$，定义 $y$。变量 $z$ 被使用，但它是在同一个块内的前一条语句中定义的，所以它不在 $\\mathrm{Use}(B_2)$ 中。\n    -   $\\mathrm{Use}(B_{2}) = \\{x, y\\}$\n    -   $\\mathrm{Def}(B_{2}) = \\{y, z\\}$\n\n-   **块 $B_{3}$**：\n    -   `z := y + d`：使用 $y$，定义 $z$。\n    -   `x := z + e`：使用 $z$，定义 $x$。变量 $z$ 被使用，但它是在块内早些时候定义的。\n    -   $\\mathrm{Use}(B_{3}) = \\{y\\}$\n    -   $\\mathrm{Def}(B_{3}) = \\{x, z\\}$\n\n-   **块 $B_{4}$**：\n    -   `r := x + y + z`：使用 $x$、$y$ 和 $z$。\n    -   没有来自 $\\{x, y, z\\}$ 的变量被定义。\n    -   $\\mathrm{Use}(B_{4}) = \\{x, y, z\\}$\n    -   $\\mathrm{Def}(B_{4}) = \\emptyset$\n\n**2. 活跃变量分析**\n\n我们迭代求解数据流方程，直到达到不动点。我们将所有 $\\mathrm{LiveIn}$ 和 $\\mathrm{LiveOut}$ 集合初始化为 $\\emptyset$。分析从程序的出口开始，向后进行。\n\n方程为：\n$\\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s)$\n$\\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup (\\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n))$\n\n`Use`/`Def` 集合总结：\n-   $B_{1}$：$\\mathrm{Use} = \\emptyset$, $\\mathrm{Def} = \\{x, y\\}$\n-   $B_{2}$：$\\mathrm{Use} = \\{x, y\\}$, $\\mathrm{Def} = \\{y, z\\}$\n-   $B_{3}$：$\\mathrm{Use} = \\{y\\}$, $\\mathrm{Def} = \\{x, z\\}$\n-   $B_{4}$：$\\mathrm{Use} = \\{x, y, z\\}$, $\\mathrm{Def} = \\emptyset$\n\n**迭代 1：**\n-   **块 $B_{4}$**：\n    -   $\\mathrm{LiveOut}(B_{4}) = \\bigcup_{s \\in \\emptyset} \\mathrm{LiveIn}(s) = \\emptyset$\n    -   $\\mathrm{LiveIn}(B_{4}) = \\mathrm{Use}(B_{4}) \\cup (\\mathrm{LiveOut}(B_{4}) \\setminus \\mathrm{Def}(B_{4})) = \\{x, y, z\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x, y, z\\}$\n-   **块 $B_{3}$**：\n    -   $\\mathrm{LiveOut}(B_{3}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$\n    -   $\\mathrm{LiveIn}(B_{3}) = \\mathrm{Use}(B_{3}) \\cup (\\mathrm{LiveOut}(B_{3}) \\setminus \\mathrm{Def}(B_{3})) = \\{y\\} \\cup (\\{x, y, z\\} \\setminus \\{x, z\\}) = \\{y\\} \\cup \\{y\\} = \\{y\\}$\n-   **块 $B_{2}$**：\n    -   $\\mathrm{LiveOut}(B_{2}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$\n    -   $\\mathrm{LiveIn}(B_{2}) = \\mathrm{Use}(B_{2}) \\cup (\\mathrm{LiveOut}(B_{2}) \\setminus \\mathrm{Def}(B_{2})) = \\{x, y\\} \\cup (\\{x, y, z\\} \\setminus \\{y, z\\}) = \\{x, y\\} \\cup \\{x\\} = \\{x, y\\}$\n-   **块 $B_{1}$**：\n    -   $\\mathrm{LiveOut}(B_{1}) = \\mathrm{LiveIn}(B_{2}) \\cup \\mathrm{LiveIn}(B_{3}) = \\{x, y\\} \\cup \\{y\\} = \\{x, y\\}$\n    -   $\\mathrm{LiveIn}(B_{1}) = \\mathrm{Use}(B_{1}) \\cup (\\mathrm{LiveOut}(B_{1}) \\setminus \\mathrm{Def}(B_{1})) = \\emptyset \\cup (\\{x, y\\} \\setminus \\{x, y\\}) = \\emptyset$\n\n**迭代 2：** 我们重新计算集合以检查是否收敛。\n-   $\\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$。无变化。\n-   $\\mathrm{LiveOut}(B_{3}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$。无变化。\n-   $\\mathrm{LiveIn}(B_{3}) = \\{y\\}$。无变化。\n-   $\\mathrm{LiveOut}(B_{2}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$。无变化。\n-   $\\mathrm{LiveIn}(B_{2}) = \\{x, y\\}$。无变化。\n-   $\\mathrm{LiveOut}(B_{1}) = \\mathrm{LiveIn}(B_{2}) \\cup \\mathrm{LiveIn}(B_{3}) = \\{x, y\\}$。无变化。\n-   $\\mathrm{LiveIn}(B_{1}) = \\emptyset$。无变化。\n\n已达到不动点。最终的活跃性集合是：\n-   $\\mathrm{LiveIn}(B_{1}) = \\emptyset$, $\\mathrm{LiveOut}(B_{1}) = \\{x, y\\}$\n-   $\\mathrm{LiveIn}(B_{2}) = \\{x, y\\}$, $\\mathrm{LiveOut}(B_{2}) = \\{x, y, z\\}$\n-   $\\mathrm{LiveIn}(B_{3}) = \\{y\\}$, $\\mathrm{LiveOut}(B_{3}) = \\{x, y, z\\}$\n-   $\\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$, $\\mathrm{LiveOut}(B_{4}) = \\emptyset$\n\n**3. 干涉图构建**\n\n如果在任何程序点上两个变量同时活跃，则它们相互干涉。我们可以通过检查活跃集来找到干涉。一组变量之间存在干涉的充分条件是它们同时出现在任何 $\\mathrm{LiveIn}$ 或 $\\mathrm{LiveOut}$ 集合中，或在一个基本块内任何点的活跃集中。\n\n-   在块 $B_{4}$ 的入口处，活跃集是 $\\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$。这意味着变量 $x$、$y$ 和 $z$ 同时都是活跃的。\n-   因此，它们彼此之间都相互干涉。这意味着存在以下干涉边：\n    -   $(x, y)$\n    -   $(x, z)$\n    -   $(y, z)$\n-   这三条边在顶点集 $\\{x, y, z\\}$ 上构成一个完全图 $K_{3}$。由于这是三个顶点的最大可能边数，我们已经完全确定了干涉图。\n-   确认：集合 $\\mathrm{LiveOut}(B_{2}) = \\{x, y, z\\}$ 和 $\\mathrm{LiveOut}(B_{3}) = \\{x, y, z\\}$ 也表明所有三个变量在块 $B_2$ 和 $B_3$ 的出口处同时活跃。\n\n干涉图是连接顶点 $x$、$y$ 和 $z$ 的一个三角形。\n\n**4. 有效的 k-寄存器分配数量**\n\n一次有效的 $k$ 寄存器分配对应于用 $k$ 种颜色对干涉图进行一次正常着色。实现这一目的的方法数量由该图的色多项式在 $k$ 处的值给出。\n\n干涉图是一个有3个顶点的完全图，记作 $K_{3}$。一个完全图 $K_{n}$ 的色多项式由以下公式给出：\n$$P(K_{n}, k) = k(k-1)(k-2)\\dots(k-n+1)$$\n这也称为降阶乘 $k^{(n)}$ 或排列数 $P(k,n)$。\n\n对于我们的图，$n=3$，因此有效的 $k$ 着色（寄存器分配）的数量是：\n$$P(K_{3}, k) = k(k-1)(k-2)$$\n\n这个表达式给出了为变量 $x$、$y$ 和 $z$ 分配颜色（寄存器）的方法数，使得没有两个相互干涉的变量共享相同的颜色。\n-   对于变量 $x$，有 $k$ 种颜色选择。\n-   对于与 $x$ 干涉的变量 $y$，剩下 $k-1$ 种选择。\n-   对于与 $x$ 和 $y$ 都干涉的变量 $z$（$x$ 和 $y$ 必须有不同的颜色），剩下 $k-2$ 种选择。\n\n有效的分配总数是乘积 $k(k-1)(k-2)$。这就是所要求的闭式解析表达式。",
            "answer": "$$\n\\boxed{k(k-1)(k-2)}\n$$"
        }
    ]
}