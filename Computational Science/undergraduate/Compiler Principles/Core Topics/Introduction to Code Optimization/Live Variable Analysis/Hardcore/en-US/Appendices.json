{
    "hands_on_practices": [
        {
            "introduction": "To understand the flow of data across an entire program, we must first characterize the behavior of individual basic blocks. This practice focuses on computing two fundamental sets: upward exposed variables ($UEVAR$, or $USE$) and variable kills ($VARKILL$, or $DEF$). These sets capture which variables are read before being written within a block and which variables are written to, respectively, forming the essential local information for any global liveness analysis. Mastering this initial step is crucial for setting up the data-flow equations correctly .",
            "id": "3651457",
            "problem": "You are given a program organized as a Control Flow Graph (CFG), where each node is a Basic Block (BB). The set of program variables is $V = \\{a, b, c, d, e, f, g, h, x\\}$ and these variables are mapped to bit positions $0, 1, 2, 3, 4, 5, 6, 7, 8$ respectively in that order. A bit-vector over $V$ is interpreted as a nonnegative integer mask in which bit $i$ is set if and only if the variable at position $i$ is in the set, with place-value $2^i$.\n\nThe blocks and statements are:\n- $B_1: \\quad x := a + b; \\quad c := x + d; \\quad e := c; \\quad \\mathrm{goto}\\ B_2.$\n- $B_2: \\quad \\mathrm{if}\\ e > f\\ \\mathrm{goto}\\ B_3\\ \\mathrm{else}\\ \\mathrm{goto}\\ B_4.$\n- $B_3: \\quad d := e + g; \\quad a := d + 2; \\quad \\mathrm{goto}\\ B_5.$\n- $B_4: \\quad b := h + 1; \\quad g := b + e; \\quad \\mathrm{goto}\\ B_5.$\n- $B_5: \\quad f := a + g; \\quad \\mathrm{return}\\ f.$\n\nUsing first-principles definitions from live variable analysis, compute for each block the Upward Exposed Variables (UEVAR) and Variable Kill (VARKILL) sets. Here, a variable is upward exposed in a block if it is used before any definition of that variable within the same block. A variable is killed in a block if it is defined (assigned) within that block.\n\nLet $M_{\\mathrm{UE}}(B_i)$ be the integer mask of $UEVAR(B_i)$ and $M_{\\mathrm{VK}}(B_i)$ be the integer mask of $VARKILL(B_i)$ under the given bit mapping. Compute the value\n$$N = \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) \\;+\\; 2 \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}).$$\n\nProvide the single integer $N$ as your final answer. No rounding is required.",
            "solution": "The problem statement has been validated and is deemed sound. It is a well-posed problem within the domain of compiler theory, specifically data-flow analysis. All necessary definitions and data are provided, and there are no internal contradictions or ambiguities. We may proceed with the solution.\n\nThe problem requires us to compute two sets for each basic block ($B_i$) in the given Control Flow Graph (CFG): the Upward Exposed Variables ($UEVAR$) and the Variable Kill ($VARKILL$) sets. From these sets, we must calculate their corresponding integer masks, $M_{\\mathrm{UE}}(B_i)$ and $M_{\\mathrm{VK}}(B_i)$, and use them to compute a final value $N$.\n\nThe set of variables is $V = \\{a, b, c, d, e, f, g, h, x\\}$. The mapping from variable to bit position $i$ (and thus to place-value $2^i$) is as follows:\n- $a \\to 0 \\quad (2^0 = 1)$\n- $b \\to 1 \\quad (2^1 = 2)$\n- $c \\to 2 \\quad (2^2 = 4)$\n- $d \\to 3 \\quad (2^3 = 8)$\n- $e \\to 4 \\quad (2^4 = 16)$\n- $f \\to 5 \\quad (2^5 = 32)$\n- $g \\to 6 \\quad (2^6 = 64)$\n- $h \\to 7 \\quad (2^7 = 128)$\n- $x \\to 8 \\quad (2^8 = 256)$\n\nWe will analyze each basic block sequentially.\n\n**Analysis of Block $B_1$**\nThe statements in $B_1$ are: $x := a + b; \\quad c := x + d; \\quad e := c;$.\n- To find $UEVAR(B_1)$, we identify variables used before they are defined within the block.\n  - In $x := a + b$, variables $a$ and $b$ are used. Neither has been defined in $B_1$ prior to this statement.\n  - In $c := x + d$, variables $x$ and $d$ are used. The variable $x$ was defined in the previous statement. The variable $d$ has not been defined.\n  - In $e := c$, the variable $c$ is used. It was defined in the preceding statement.\n  - Therefore, the set of upward exposed variables is $UEVAR(B_1) = \\{a, b, d\\}$.\n- To find $VARKILL(B_1)$, we identify all variables that are assigned a value (defined) in the block.\n  - The variables defined are $x, c, e$.\n  - Therefore, the kill set is $VARKILL(B_1) = \\{x, c, e\\}$.\n\n**Analysis of Block $B_2$**\nThe statement in $B_2$ is: $\\mathrm{if}\\ e > f\\ \\mathrm{goto}\\ B_3\\ \\mathrm{else}\\ \\mathrm{goto}\\ B_4.$\n- To find $UEVAR(B_2)$, we identify variables used in the conditional expression.\n  - The variables $e$ and $f$ are used.\n  - No variables are defined in this block.\n  - Therefore, $UEVAR(B_2) = \\{e, f\\}$.\n- To find $VARKILL(B_2)$, we identify defined variables. There are none.\n  - Therefore, $VARKILL(B_2) = \\emptyset$.\n\n**Analysis of Block $B_3$**\nThe statements in $B_3$ are: $d := e + g; \\quad a := d + 2;$.\n- To find $UEVAR(B_3)$:\n  - In $d := e + g$, variables $e$ and $g$ are used. Neither is defined in $B_3$ before this use.\n  - In $a := d + 2$, variable $d$ is used, but it was defined in the previous statement within this same block.\n  - Therefore, $UEVAR(B_3) = \\{e, g\\}$.\n- To find $VARKILL(B_3)$:\n  - The variables defined are $d$ and $a$.\n  - Therefore, $VARKILL(B_3) = \\{a, d\\}$.\n\n**Analysis of Block $B_4$**\nThe statements in $B_4$ are: $b := h + 1; \\quad g := b + e;$.\n- To find $UEVAR(B_4)$:\n  - In $b := h + 1$, variable $h$ is used and is not previously defined in $B_4$.\n  - In $g := b + e$, variables $b$ and $e$ are used. $b$ was defined in the previous statement. $e$ has not been defined in $B_4$.\n  - Therefore, $UEVAR(B_4) = \\{h, e\\}$.\n- To find $VARKILL(B_4)$:\n  - The variables defined are $b$ and $g$.\n  - Therefore, $VARKILL(B_4) = \\{b, g\\}$.\n\n**Analysis of Block $B_5$**\nThe statements in $B_5$ are: $f := a + g; \\quad \\mathrm{return}\\ f;$.\n- To find $UEVAR(B_5)$:\n  - In $f := a + g$, variables $a$ and $g$ are used. Neither has been defined in $B_5$.\n  - In $\\mathrm{return}\\ f$, variable $f$ is used, but it was just defined.\n  - Therefore, $UEVAR(B_5) = \\{a, g\\}$.\n- To find $VARKILL(B_5)$:\n  - The variable defined is $f$.\n  - Therefore, $VARKILL(B_5) = \\{f\\}$.\n\nNow, we compute the integer masks for each set.\n$M_{\\mathrm{UE}}(B_1)$ for $\\{a,b,d\\}$: $2^0+2^1+2^3 = 1+2+8 = 11$.\n$M_{\\mathrm{VK}}(B_1)$ for $\\{x,c,e\\}$: $2^8+2^2+2^4 = 256+4+16 = 276$.\n\n$M_{\\mathrm{UE}}(B_2)$ for $\\{e,f\\}$: $2^4+2^5 = 16+32 = 48$.\n$M_{\\mathrm{VK}}(B_2)$ for $\\emptyset$: $0$.\n\n$M_{\\mathrm{UE}}(B_3)$ for $\\{e,g\\}$: $2^4+2^6 = 16+64 = 80$.\n$M_{\\mathrm{VK}}(B_3)$ for $\\{a,d\\}$: $2^0+2^3 = 1+8 = 9$.\n\n$M_{\\mathrm{UE}}(B_4)$ for $\\{h,e\\}$: $2^7+2^4 = 128+16 = 144$.\n$M_{\\mathrm{VK}}(B_4)$ for $\\{b,g\\}$: $2^1+2^6 = 2+64 = 66$.\n\n$M_{\\mathrm{UE}}(B_5)$ for $\\{a,g\\}$: $2^0+2^6 = 1+64 = 65$.\n$M_{\\mathrm{VK}}(B_5)$ for $\\{f\\}$: $2^5 = 32$.\n\nNext, we compute the two sums required for the final calculation of $N$.\nFirst, the sum of the $M_{\\mathrm{UE}}$ masks:\n$$ \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) = 11 + 48 + 80 + 144 + 65 $$\n$$ \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) = 59 + 80 + 144 + 65 = 139 + 144 + 65 = 283 + 65 = 348 $$\n\nSecond, the sum of the $M_{\\mathrm{VK}}$ masks:\n$$ \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) = 276 + 0 + 9 + 66 + 32 $$\n$$ \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) = 276 + 9 + 66 + 32 = 285 + 66 + 32 = 351 + 32 = 383 $$\n\nFinally, we compute $N$ using the given formula:\n$$ N = \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) \\;+\\; 2 \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) $$\n$$ N = 348 + 2 \\times 383 $$\n$$ N = 348 + 766 $$\n$$ N = 1114 $$",
            "answer": "$$\\boxed{1114}$$"
        },
        {
            "introduction": "With local block properties established, we can now tackle the global problem of determining where variables are live across the entire procedure. This exercise involves applying the classic backward data-flow algorithm to compute the $IN$ and $OUT$ sets for each basic block in a control-flow graph that includes a switch statement. By iteratively propagating liveness information from uses backward to definitions, you will gain hands-on experience with the core mechanics of data-flow analysis .",
            "id": "3651499",
            "problem": "Consider the following control flow graph (Control Flow Graph (CFG)) of a procedure, written as labeled basic blocks. We perform Live Variable Analysis (LVA) on the variable $x$ only.\n\nThe basic blocks are:\n- $B_1$: $x := u + v$; goto $B_S$.\n- $B_S$: switch on $t$ with sparse targets: case $0 \\to B_2$, case $5 \\to B_3$, case $9 \\to B_4$, default $\\to B_5$.\n- $B_2$: $y := x + 1$; goto $B_6$.\n- $B_3$: if $p$ then goto $B_7$ else goto $B_8$.\n- $B_7$: $z := x$; goto $B_6$.\n- $B_8$: $z := 0$; goto $B_6$.\n- $B_4$: $y := 2$; goto $B_6$.\n- $B_5$: $w := 4$; goto $B_6$.\n- $B_6$: $x := y + z$; goto $B_9$.\n- $B_9$: return $x$.\n\nAssume the usual semantics: the switch in $B_S$ transfers control to exactly one of its target blocks based on the value of $t$; the test in $B_3$ branches to $B_7$ or $B_8$ based on $p$; and $B_9$ is the exit block. No other side effects occur. Only the liveness of $x$ is to be analyzed; other variables ($u$, $v$, $y$, $z$, $w$, $t$, $p$) matter only insofar as they appear in statements.\n\nUsing first principles for data-flow analysis, compute the $IN[B]$ and $OUT[B]$ sets for each basic block $B$ with respect to $x$. Then, determine the total number of basic blocks whose entry set $IN[B]$ contains $x$.\n\nYour final answer must be a single real-valued number equal to the count of basic blocks where $x$ is live on entry. No rounding is required. Express the final answer as a plain number without units.",
            "solution": "We start from the foundational definitions of Live Variable Analysis (LVA) over a Control Flow Graph (CFG). For each basic block $B$, define:\n- $USE[B]$: the set of variables read in $B$ before any redefinition in $B$.\n- $DEF[B]$: the set of variables defined in $B$.\n\nThe classical backward data-flow equations for LVA are:\n$$\nIN[B] = USE[B] \\cup \\left(OUT[B] \\setminus DEF[B]\\right)\n$$\n$$\nOUT[B] = \\bigcup_{S \\in succ(B)} IN[S]\n$$\nwhere $succ(B)$ is the set of successor blocks of $B$. At the exit of the procedure, we take the $OUT$ set to be the empty set.\n\nWe analyze only the variable $x$, so each $USE[B]$, $DEF[B]$, $IN[B]$, and $OUT[B]$ is either $\\emptyset$ or $\\{x\\}$.\n\nFirst, enumerate successors:\n- $succ(B_1) = \\{B_S\\}$.\n- $succ(B_S) = \\{B_2, B_3, B_4, B_5\\}$.\n- $succ(B_2) = \\{B_6\\}$.\n- $succ(B_3) = \\{B_7, B_8\\}$.\n- $succ(B_7) = \\{B_6\\}$.\n- $succ(B_8) = \\{B_6\\}$.\n- $succ(B_4) = \\{B_6\\}$.\n- $succ(B_5) = \\{B_6\\}$.\n- $succ(B_6) = \\{B_9\\}$.\n- $succ(B_9) = \\emptyset$.\n\nNext, compute $USE[B]$ and $DEF[B]$ for $x$:\n- $B_1$: defines $x$ by $x := u + v$, so $DEF[B_1] = \\{x\\}$, $USE[B_1] = \\emptyset$.\n- $B_S$: no mention of $x$, so $DEF[B_S] = \\emptyset$, $USE[B_S] = \\emptyset$.\n- $B_2$: uses $x$ in $y := x + 1$, so $USE[B_2] = \\{x\\}$, $DEF[B_2] = \\emptyset$.\n- $B_3$: no mention of $x$, so $USE[B_3] = \\emptyset$, $DEF[B_3] = \\emptyset$.\n- $B_7$: uses $x$ in $z := x$, so $USE[B_7] = \\{x\\}$, $DEF[B_7] = \\emptyset$.\n- $B_8$: no mention of $x$, so $USE[B_8] = \\emptyset$, $DEF[B_8] = \\emptyset$.\n- $B_4$: no mention of $x$, so $USE[B_4] = \\emptyset$, $DEF[B_4] = \\emptyset$.\n- $B_5$: no mention of $x$, so $USE[B_5] = \\emptyset$, $DEF[B_5] = \\emptyset$.\n- $B_6$: defines $x$ by $x := y + z$ and does not read $x$ on the right-hand side, so $DEF[B_6] = \\{x\\}$, $USE[B_6] = \\emptyset$.\n- $B_9$: uses $x$ in return $x$, so $USE[B_9] = \\{x\\}$, $DEF[B_9] = \\emptyset$.\n\nWe now solve the equations backward, starting from the exit:\n- For $B_9$, $OUT[B_9] = \\emptyset$ (exit). Then\n  $$\n  IN[B_9] = USE[B_9] \\cup (OUT[B_9] \\setminus DEF[B_9]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_6$, $OUT[B_6] = IN[B_9] = \\{x\\}$. Then\n  $$\n  IN[B_6] = USE[B_6] \\cup (OUT[B_6] \\setminus DEF[B_6]) = \\emptyset \\cup (\\{x\\} \\setminus \\{x\\}) = \\emptyset.\n  $$\n\n- For $B_2$, $OUT[B_2] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_2] = USE[B_2] \\cup (OUT[B_2] \\setminus DEF[B_2]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_7$, $OUT[B_7] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_7] = USE[B_7] \\cup (OUT[B_7] \\setminus DEF[B_7]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_8$, $OUT[B_8] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_8] = USE[B_8] \\cup (OUT[B_8] \\setminus DEF[B_8]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset.\n  $$\n\n- For $B_4$, $OUT[B_4] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_4] = USE[B_4] \\cup (OUT[B_4] \\setminus DEF[B_4]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset.\n  $$\n\n- For $B_5$, $OUT[B_5] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_5] = USE[B_5] \\cup (OUT[B_5] \\setminus DEF[B_5]) = \\emptyset.\n  $$\n\n- For $B_3$, $OUT[B_3] = IN[B_7] \\cup IN[B_8] = \\{x\\} \\cup \\emptyset = \\{x\\}$. Then\n  $$\n  IN[B_3] = USE[B_3] \\cup (OUT[B_3] \\setminus DEF[B_3]) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_S$, $OUT[B_S] = IN[B_2] \\cup IN[B_3] \\cup IN[B_4] \\cup IN[B_5] = \\{x\\} \\cup \\{x\\} \\cup \\emptyset \\cup \\emptyset = \\{x\\}$. Then\n  $$\n  IN[B_S] = USE[B_S] \\cup (OUT[B_S] \\setminus DEF[B_S]) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_1$, $OUT[B_1] = IN[B_S] = \\{x\\}$. Then\n  $$\n  IN[B_1] = USE[B_1] \\cup (OUT[B_1] \\setminus DEF[B_1]) = \\emptyset \\cup (\\{x\\} \\setminus \\{x\\}) = \\emptyset.\n  $$\n\nCollecting the $IN$ sets:\n- $IN[B_1] = \\emptyset$,\n- $IN[B_S] = \\{x\\}$,\n- $IN[B_2] = \\{x\\}$,\n- $IN[B_3] = \\{x\\}$,\n- $IN[B_4] = \\emptyset$,\n- $IN[B_5] = \\emptyset$,\n- $IN[B_6] = \\emptyset$,\n- $IN[B_7] = \\{x\\}$,\n- $IN[B_8] = \\emptyset$,\n- $IN[B_9] = \\{x\\}$.\n\nTherefore, the total number of basic blocks whose entry set contains $x$ is the count of blocks with $IN[B] = \\{x\\}$, which is $5$ (namely $B_S$, $B_2$, $B_3$, $B_7$, $B_9$).",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "Live variable analysis is not just a theoretical exercise; it is a cornerstone of modern compiler optimization, particularly for register allocation. This final practice bridges theory and application by tasking you with using liveness information to build an interference graph, which models conflicts between variables competing for registers. By determining which variables are simultaneously live, you will see how liveness analysis directly informs the graph-coloring approach to efficiently assigning scarce processor registers .",
            "id": "3651500",
            "problem": "Consider the following pseudo-program written in three-address style. The Control Flow Graph (CFG) consists of four basic blocks with edges $B_{1} \\rightarrow B_{2}$, $B_{1} \\rightarrow B_{3}$, $B_{2} \\rightarrow B_{4}$, and $B_{3} \\rightarrow B_{4}$. Only the variables $x$, $y$, and $z$ are candidates for register allocation; all other symbols denote memory-resident values that are not part of the register allocation problem.\n\nBlock $B_{1}$:\n- $x := a + 1$\n- $y := b + 1$\n- if $p$ goto $B_{2}$ else goto $B_{3}$\n\nBlock $B_{2}$:\n- $z := x + y$\n- $y := z + c$\n- goto $B_{4}$\n\nBlock $B_{3}$:\n- $z := y + d$\n- $x := z + e$\n- goto $B_{4}$\n\nBlock $B_{4}$:\n- $r := x + y + z$\n- return $r$\n\nUsing the standard forward-flow and backward-flow data-flow framework for live variable analysis, with the classical equations\n- $\\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s)$,\n- $\\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup \\left( \\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n) \\right)$,\nwhere $\\mathrm{Use}(n)$ and $\\mathrm{Def}(n)$ are computed with respect to the set $\\{x,y,z\\}$, perform the following:\n\n- Derive $\\mathrm{Use}$ and $\\mathrm{Def}$ for each basic block $B_{1}$, $B_{2}$, $B_{3}$, and $B_{4}$.\n- Solve the data-flow equations to obtain $\\mathrm{LiveIn}$ and $\\mathrm{LiveOut}$ for each basic block.\n- From the liveness information, construct the interference graph whose vertices are $\\{x,y,z\\}$ and where an edge between two variables indicates that they are simultaneously live at some program point.\n- Under the register allocation model in which assigning $k$ registers corresponds to a proper coloring of the interference graph with $k$ colors, determine a closed-form analytic expression in $k$ for the number of valid $k$-register allocations of $\\{x,y,z\\}$ for this program.\n\nExpress your final answer as a single analytic expression in $k$. No rounding is required. Do not include any units in your final answer.",
            "solution": "The problem requires us to perform live variable analysis on a given program, construct the corresponding interference graph for variables $\\{x, y, z\\}$, and then derive the chromatic polynomial for that graph, which represents the number of valid $k$-register allocations. The solution proceeds in four main steps.\n\n**1. Derivation of Use and Def Sets**\n\nFirst, we determine the `Use` and `Def` sets for each basic block with respect to the variables $\\{x, y, z\\}$. A variable is in `Use(B)` if it is read in block $B$ before any definition within $B$. A variable is in `Def(B)` if it is written to in block $B$.\n\n- **Block $B_1$**: Defines $x$ and $y$. No variables are used before definition.\n    - $\\mathrm{Use}(B_1) = \\emptyset$\n    - $\\mathrm{Def}(B_1) = \\{x, y\\}$\n- **Block $B_2$**: Uses $x$ and $y$ in the first statement, then defines $z$ and later redefines $y$.\n    - $\\mathrm{Use}(B_2) = \\{x, y\\}$\n    - $\\mathrm{Def}(B_2) = \\{y, z\\}$\n- **Block $B_3$**: Uses $y$ in the first statement, then defines $z$ and later defines $x$.\n    - $\\mathrm{Use}(B_3) = \\{y\\}$\n    - $\\mathrm{Def}(B_3) = \\{x, z\\}$\n- **Block $B_4$**: Uses $x$, $y$, and $z$. No variables are defined.\n    - $\\mathrm{Use}(B_4) = \\{x, y, z\\}$\n    - $\\mathrm{Def}(B_4) = \\emptyset$\n\n**2. Live Variable Analysis**\n\nNext, we solve the backward data-flow equations iteratively until a fixed point is reached. We initialize all $\\mathrm{LiveIn}$ and $\\mathrm{LiveOut}$ sets to $\\emptyset$.\n\n$$ \\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s) $$\n$$ \\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup (\\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n)) $$\n\nThe analysis proceeds backward from the exit block $B_4$:\n\n- **Block $B_4$**:\n    - $\\mathrm{LiveOut}(B_4) = \\emptyset$ (exit block)\n    - $\\mathrm{LiveIn}(B_4) = \\mathrm{Use}(B_4) \\cup (\\emptyset \\setminus \\emptyset) = \\{x, y, z\\}$\n- **Block $B_3$**:\n    - $\\mathrm{LiveOut}(B_3) = \\mathrm{LiveIn}(B_4) = \\{x, y, z\\}$\n    - $\\mathrm{LiveIn}(B_3) = \\mathrm{Use}(B_3) \\cup (\\{x, y, z\\} \\setminus \\mathrm{Def}(B_3)) = \\{y\\} \\cup (\\{x, y, z\\} \\setminus \\{x, z\\}) = \\{y\\}$\n- **Block $B_2$**:\n    - $\\mathrm{LiveOut}(B_2) = \\mathrm{LiveIn}(B_4) = \\{x, y, z\\}$\n    - $\\mathrm{LiveIn}(B_2) = \\mathrm{Use}(B_2) \\cup (\\{x, y, z\\} \\setminus \\mathrm{Def}(B_2)) = \\{x, y\\} \\cup (\\{x, y, z\\} \\setminus \\{y, z\\}) = \\{x, y\\}$\n- **Block $B_1$**:\n    - $\\mathrm{LiveOut}(B_1) = \\mathrm{LiveIn}(B_2) \\cup \\mathrm{LiveIn}(B_3) = \\{x, y\\} \\cup \\{y\\} = \\{x, y\\}$\n    - $\\mathrm{LiveIn}(B_1) = \\mathrm{Use}(B_1) \\cup (\\{x, y\\} \\setminus \\mathrm{Def}(B_1)) = \\emptyset \\cup (\\{x, y\\} \\setminus \\{x, y\\}) = \\emptyset$\n\nA second iteration confirms these sets are stable, so we have reached a fixed point.\n\n**3. Interference Graph Construction**\n\nTwo variables interfere if they are simultaneously live at any program point. We can construct the interference graph by adding an edge between any two variables that appear together in a live set.\n\n- The set $\\mathrm{LiveIn}(B_4) = \\{x, y, z\\}$ shows that all three variables are live at the same time upon entry to block $B_4$.\n- This implies that all variables interfere with each other, creating a \"clique\".\n- The interference edges are $(x, y)$, $(x, z)$, and $(y, z)$.\n- The resulting interference graph is a complete graph on 3 vertices, $K_3$ (a triangle).\n\n**4. Number of Valid $k$-Register Allocations**\n\nA valid allocation of $k$ registers corresponds to a proper coloring of the interference graph with $k$ colors. The number of ways to do this is given by the graph's chromatic polynomial, evaluated at $k$. The chromatic polynomial of a complete graph $K_n$ is $P(K_n, k) = k(k-1)\\dots(k-n+1)$.\n\nFor our interference graph, which is $K_3$, the chromatic polynomial is:\n$$ P(K_3, k) = k(k-1)(k-2) $$\nThis expression gives the number of ways to assign $k$ distinct registers to $x$, $y$, and $z$ without conflict.",
            "answer": "$$\n\\boxed{k(k-1)(k-2)}\n$$"
        }
    ]
}