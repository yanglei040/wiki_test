{
    "hands_on_practices": [
        {
            "introduction": "Before tackling liveness across an entire procedure, we must first understand how to analyze the individual building blocks of a program: the basic blocks. This exercise focuses on computing two fundamental sets for each basic block: the Upwardly Exposed Variables ($UEVAR$), which are variables used before any definition within the block, and the Variable Kill ($VARKILL$) set, which are variables defined within the block. Mastering this local analysis is the essential first step, as these sets provide the inputs for the global data-flow algorithm that determines liveness across the entire program .",
            "id": "3651457",
            "problem": "You are given a program organized as a Control Flow Graph (CFG), where each node is a Basic Block (BB). The set of program variables is $$V = \\{a, b, c, d, e, f, g, h, x\\}$$ and these variables are mapped to bit positions $$0, 1, 2, 3, 4, 5, 6, 7, 8$$ respectively in that order. A bit-vector over $$V$$ is interpreted as a nonnegative integer mask in which bit $$i$$ is set if and only if the variable at position $$i$$ is in the set, with place-value $$2^{i}$$.\n\nThe blocks and statements are:\n- $$B_{1}: \\quad x := a + b; \\quad c := x + d; \\quad e := c; \\quad \\mathrm{goto}\\ B_{2}.$$\n- $$B_{2}: \\quad \\mathrm{if}\\ e  f\\ \\mathrm{goto}\\ B_{3}\\ \\mathrm{else}\\ \\mathrm{goto}\\ B_{4}.$$\n- $$B_{3}: \\quad d := e + g; \\quad a := d + 2; \\quad \\mathrm{goto}\\ B_{5}.$$\n- $$B_{4}: \\quad b := h + 1; \\quad g := b + e; \\quad \\mathrm{goto}\\ B_{5}.$$\n- $$B_{5}: \\quad f := a + g; \\quad \\mathrm{return}\\ f.$$\n\nUsing first-principles definitions from live variable analysis, compute for each block the Upward Exposed Variables (UEVAR) and Variable Kill (VARKILL) sets. Here, a variable is upward exposed in a block if it is used before any definition of that variable within the same block. A variable is killed in a block if it is defined (assigned) within that block.\n\nLet $$M_{\\mathrm{UE}}(B_{i})$$ be the integer mask of $$UEVAR(B_{i})$$ and $$M_{\\mathrm{VK}}(B_{i})$$ be the integer mask of $$VARKILL(B_{i})$$ under the given bit mapping. Compute the value\n$$N = \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) \\;+\\; 2 \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}).$$\n\nProvide the single integer $$N$$ as your final answer. No rounding is required.",
            "solution": "The problem statement has been validated and is deemed sound. It is a well-posed problem within the domain of compiler theory, specifically data-flow analysis. All necessary definitions and data are provided, and there are no internal contradictions or ambiguities. We may proceed with the solution.\n\nThe problem requires us to compute two sets for each basic block ($$B_i$$) in the given Control Flow Graph (CFG): the Upward Exposed Variables ($$UEVAR$$) and the Variable Kill ($$VARKILL$$) sets. From these sets, we must calculate their corresponding integer masks, $$M_{\\mathrm{UE}}(B_{i})$$ and $$M_{\\mathrm{VK}}(B_{i})$$, and use them to compute a final value $$N$$.\n\nThe set of variables is $$V = \\{a, b, c, d, e, f, g, h, x\\}$$. The mapping from variable to bit position $$i$$ (and thus to place-value $$2^i$$) is as follows:\n- $$a \\to 0 \\quad (2^0 = 1)$$\n- $$b \\to 1 \\quad (2^1 = 2)$$\n- $$c \\to 2 \\quad (2^2 = 4)$$\n- $$d \\to 3 \\quad (2^3 = 8)$$\n- $$e \\to 4 \\quad (2^4 = 16)$$\n- $$f \\to 5 \\quad (2^5 = 32)$$\n- $$g \\to 6 \\quad (2^6 = 64)$$\n- $$h \\to 7 \\quad (2^7 = 128)$$\n- $$x \\to 8 \\quad (2^8 = 256)$$\n\nWe will analyze each basic block sequentially.\n\n**Analysis of Block $$B_1$$**\nThe statements in $$B_1$$ are: $$x := a + b; \\quad c := x + d; \\quad e := c;$$\n- To find $$UEVAR(B_1)$$, we identify variables used before they are defined within the block.\n  - In $$x := a + b$$, variables $$a$$ and $$b$$ are used. Neither has been defined in $$B_1$$ prior to this statement.\n  - In $$c := x + d$$, variables $$x$$ and $$d$$ are used. The variable $$x$$ was defined in the previous statement. The variable $$d$$ has not been defined.\n  - In $$e := c$$, the variable $$c$$ is used. It was defined in the preceding statement.\n  - Therefore, the set of upward exposed variables is $$UEVAR(B_1) = \\{a, b, d\\}$$.\n- To find $$VARKILL(B_1)$$, we identify all variables that are assigned a value (defined) in the block.\n  - The variables defined are $$x, c, e$$.\n  - Therefore, the kill set is $$VARKILL(B_1) = \\{x, c, e\\}$$.\n\n**Analysis of Block $$B_2$$**\nThe statement in $$B_2$$ is: $$\\mathrm{if}\\ e  f\\ \\mathrm{goto}\\ B_{3}\\ \\mathrm{else}\\ \\mathrm{goto}\\ B_{4}.$$\n- To find $$UEVAR(B_2)$$, we identify variables used in the conditional expression.\n  - The variables $$e$$ and $$f$$ are used.\n  - No variables are defined in this block.\n  - Therefore, $$UEVAR(B_2) = \\{e, f\\}$$.\n- To find $$VARKILL(B_2)$$, we identify defined variables. There are none.\n  - Therefore, $$VARKILL(B_2) = \\emptyset$$.\n\n**Analysis of Block $$B_3$$**\nThe statements in $$B_3$$ are: $$d := e + g; \\quad a := d + 2;$$\n- To find $$UEVAR(B_3)$$:\n  - In $$d := e + g$$, variables $$e$$ and $$g$$ are used. Neither is defined in $$B_3$$ before this use.\n  - In $$a := d + 2$$, variable $$d$$ is used, but it was defined in the previous statement within this same block.\n  - Therefore, $$UEVAR(B_3) = \\{e, g\\}$$.\n- To find $$VARKILL(B_3)$$:\n  - The variables defined are $$d$$ and $$a$$.\n  - Therefore, $$VARKILL(B_3) = \\{a, d\\}$$.\n\n**Analysis of Block $$B_4$$**\nThe statements in $$B_4$$ are: $$b := h + 1; \\quad g := b + e;$$\n- To find $$UEVAR(B_4)$$:\n  - In $$b := h + 1$$, variable $$h$$ is used and is not previously defined in $$B_4$$.\n  - In $$g := b + e$$, variables $$b$$ and $$e$$ are used. $$b$$ was defined in the previous statement. $$e$$ has not been defined in $$B_4$$.\n  - Therefore, $$UEVAR(B_4) = \\{h, e\\}$$.\n- To find $$VARKILL(B_4)$$:\n  - The variables defined are $$b$$ and $$g$$.\n  - Therefore, $$VARKILL(B_4) = \\{b, g\\}$$.\n\n**Analysis of Block $$B_5$$**\nThe statements in $$B_5$$ are: $$f := a + g; \\quad \\mathrm{return}\\ f;$$\n- To find $$UEVAR(B_5)$$:\n  - In $$f := a + g$$, variables $$a$$ and $$g$$ are used. Neither has been defined in $$B_5$$.\n  - In $$\\mathrm{return}\\ f$$, variable $$f$$ is used, but it was just defined.\n  - Therefore, $$UEVAR(B_5) = \\{a, g\\}$$.\n- To find $$VARKILL(B_5)$$:\n  - The variable defined is $$f$$.\n  - Therefore, $$VARKILL(B_5) = \\{f\\}$$.\n\nNow, we compute the integer masks for each set.\n$$M_{\\mathrm{UE}}(B_1) \\text{ for } \\{a,b,d\\}: 2^0+2^1+2^3 = 1+2+8 = 11$$\n$$M_{\\mathrm{VK}}(B_1) \\text{ for } \\{x,c,e\\}: 2^8+2^2+2^4 = 256+4+16 = 276$$\n\n$$M_{\\mathrm{UE}}(B_2) \\text{ for } \\{e,f\\}: 2^4+2^5 = 16+32 = 48$$\n$$M_{\\mathrm{VK}}(B_2) \\text{ for } \\emptyset: 0$$\n\n$$M_{\\mathrm{UE}}(B_3) \\text{ for } \\{e,g\\}: 2^4+2^6 = 16+64 = 80$$\n$$M_{\\mathrm{VK}}(B_3) \\text{ for } \\{a,d\\}: 2^0+2^3 = 1+8 = 9$$\n\n$$M_{\\mathrm{UE}}(B_4) \\text{ for } \\{h,e\\}: 2^7+2^4 = 128+16 = 144$$\n$$M_{\\mathrm{VK}}(B_4) \\text{ for } \\{b,g\\}: 2^1+2^6 = 2+64 = 66$$\n\n$$M_{\\mathrm{UE}}(B_5) \\text{ for } \\{a,g\\}: 2^0+2^6 = 1+64 = 65$$\n$$M_{\\mathrm{VK}}(B_5) \\text{ for } \\{f\\}: 2^5 = 32$$\n\nNext, we compute the two sums required for the final calculation of $$N$$.\nFirst, the sum of the $$M_{\\mathrm{UE}}$$ masks:\n$$ \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) = 11 + 48 + 80 + 144 + 65 $$\n$$ \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) = 59 + 80 + 144 + 65 = 139 + 144 + 65 = 283 + 65 = 348 $$\n\nSecond, the sum of the $$M_{\\mathrm{VK}}$$ masks:\n$$ \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) = 276 + 0 + 9 + 66 + 32 $$\n$$ \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) = 276 + 9 + 66 + 32 = 285 + 66 + 32 = 351 + 32 = 383 $$\n\nFinally, we compute $$N$$ using the given formula:\n$$ N = \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) \\;+\\; 2 \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) $$\n$$ N = 348 + 2 \\times 383 $$\n$$ N = 348 + 766 $$\n$$ N = 1114 $$",
            "answer": "$$\\boxed{1114}$$"
        },
        {
            "introduction": "With the ability to analyze individual basic blocks, we can now move to a global analysis of the entire procedure. Live variable analysis is a classic backward data-flow problem, where information propagates from the uses of variables backward to their definitions. This practice asks you to apply the iterative data-flow algorithm, using the standard equations for $IN$ and $OUT$ sets, to determine where a variable $x$ is live across a control-flow graph that includes a `switch` statement . This will reinforce your understanding of how liveness information is aggregated at join points in the control flow.",
            "id": "3651499",
            "problem": "Consider the following control flow graph (CFG) of a procedure, written as labeled basic blocks. We perform Live Variable Analysis (LVA) on the variable $x$ only.\n\nThe basic blocks are:\n- $B_1$: $x := u + v$; goto $B_S$.\n- $B_S$: switch on $t$ with sparse targets: case $0 \\to B_2$, case $5 \\to B_3$, case $9 \\to B_4$, default $\\to B_5$.\n- $B_2$: $y := x + 1$; goto $B_6$.\n- $B_3$: if $p$ then goto $B_7$ else goto $B_8$.\n- $B_7$: $z := x$; goto $B_6$.\n- $B_8$: $z := 0$; goto $B_6$.\n- $B_4$: $y := 2$; goto $B_6$.\n- $B_5$: $w := 4$; goto $B_6$.\n- $B_6$: $x := y + z$; goto $B_9$.\n- $B_9$: return $x$.\n\nAssume the usual semantics: the switch in $B_S$ transfers control to exactly one of its target blocks based on the value of $t$; the test in $B_3$ branches to $B_7$ or $B_8$ based on $p$; and $B_9$ is the exit block. No other side effects occur. Only the liveness of $x$ is to be analyzed; other variables ($u$, $v$, $y$, $z$, $w$, $t$, $p$) matter only insofar as they appear in statements.\n\nUsing first principles for data-flow analysis, compute the $IN[B]$ and $OUT[B]$ sets for each basic block $B$ with respect to $x$. Then, determine the total number of basic blocks whose entry set $IN[B]$ contains $x$.\n\nYour final answer must be a single real-valued number equal to the count of basic blocks where $x$ is live on entry. No rounding is required. Express the final answer as a plain number without units.",
            "solution": "We start from the foundational definitions of Live Variable Analysis (LVA) over a Control Flow Graph (CFG). For each basic block $B$, define:\n- $USE[B]$: the set of variables read in $B$ before any redefinition in $B$.\n- $DEF[B]$: the set of variables defined in $B$.\n\nThe classical backward data-flow equations for LVA are:\n$$\nIN[B] = USE[B] \\cup \\left(OUT[B] \\setminus DEF[B]\\right),\n$$\n$$\nOUT[B] = \\bigcup_{S \\in succ(B)} IN[S],\n$$\nwhere $succ(B)$ is the set of successor blocks of $B$. At the exit of the procedure, we take the $OUT$ set to be the empty set.\n\nWe analyze only the variable $x$, so each $USE[B]$, $DEF[B]$, $IN[B]$, and $OUT[B]$ is either $\\emptyset$ or $\\{x\\}$.\n\nFirst, enumerate successors:\n- $succ(B_1) = \\{B_S\\}$.\n- $succ(B_S) = \\{B_2, B_3, B_4, B_5\\}$.\n- $succ(B_2) = \\{B_6\\}$.\n- $succ(B_3) = \\{B_7, B_8\\}$.\n- $succ(B_7) = \\{B_6\\}$.\n- $succ(B_8) = \\{B_6\\}$.\n- $succ(B_4) = \\{B_6\\}$.\n- $succ(B_5) = \\{B_6\\}$.\n- $succ(B_6) = \\{B_9\\}$.\n- $succ(B_9) = \\emptyset$.\n\nNext, compute $USE[B]$ and $DEF[B]$ for $x$:\n- $B_1$: defines $x$ by $x := u + v$, so $DEF[B_1] = \\{x\\}$, $USE[B_1] = \\emptyset$.\n- $B_S$: no mention of $x$, so $DEF[B_S] = \\emptyset$, $USE[B_S] = \\emptyset$.\n- $B_2$: uses $x$ in $y := x + 1$, so $USE[B_2] = \\{x\\}$, $DEF[B_2] = \\emptyset$.\n- $B_3$: no mention of $x$, so $USE[B_3] = \\emptyset$, $DEF[B_3] = \\emptyset$.\n- $B_7$: uses $x$ in $z := x$, so $USE[B_7] = \\{x\\}$, $DEF[B_7] = \\emptyset$.\n- $B_8$: no mention of $x$, so $USE[B_8] = \\emptyset$, $DEF[B_8] = \\emptyset$.\n- $B_4$: no mention of $x$, so $USE[B_4] = \\emptyset$, $DEF[B_4] = \\emptyset$.\n- $B_5$: no mention of $x$, so $USE[B_5] = \\emptyset$, $DEF[B_5] = \\emptyset$.\n- $B_6$: defines $x$ by $x := y + z$ and does not read $x$ on the right-hand side, so $DEF[B_6] = \\{x\\}$, $USE[B_6] = \\emptyset$.\n- $B_9$: uses $x$ in return $x$, so $USE[B_9] = \\{x\\}$, $DEF[B_9] = \\emptyset$.\n\nWe now solve the equations backward, starting from the exit:\n- For $B_9$, $OUT[B_9] = \\emptyset$ (exit). Then\n  $$\n  IN[B_9] = USE[B_9] \\cup (OUT[B_9] \\setminus DEF[B_9]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_6$, $OUT[B_6] = IN[B_9] = \\{x\\}$. Then\n  $$\n  IN[B_6] = USE[B_6] \\cup (OUT[B_6] \\setminus DEF[B_6]) = \\emptyset \\cup (\\{x\\} \\setminus \\{x\\}) = \\emptyset.\n  $$\n\n- For $B_2$, $OUT[B_2] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_2] = USE[B_2] \\cup (OUT[B_2] \\setminus DEF[B_2]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_7$, $OUT[B_7] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_7] = USE[B_7] \\cup (OUT[B_7] \\setminus DEF[B_7]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_8$, $OUT[B_8] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_8] = USE[B_8] \\cup (OUT[B_8] \\setminus DEF[B_8]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset.\n  $$\n\n- For $B_4$, $OUT[B_4] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_4] = USE[B_4] \\cup (OUT[B_4] \\setminus DEF[B_4]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset.\n  $$\n\n- For $B_5$, $OUT[B_5] = IN[B_6] = \\emptyset$. Then\n  $$\n  IN[B_5] = USE[B_5] \\cup (OUT[B_5] \\setminus DEF[B_5]) = \\emptyset.\n  $$\n\n- For $B_3$, $OUT[B_3] = IN[B_7] \\cup IN[B_8] = \\{x\\} \\cup \\emptyset = \\{x\\}$. Then\n  $$\n  IN[B_3] = USE[B_3] \\cup (OUT[B_3] \\setminus DEF[B_3]) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_S$, $OUT[B_S] = IN[B_2] \\cup IN[B_3] \\cup IN[B_4] \\cup IN[B_5] = \\{x\\} \\cup \\{x\\} \\cup \\emptyset \\cup \\emptyset = \\{x\\}$. Then\n  $$\n  IN[B_S] = USE[B_S] \\cup (OUT[B_S] \\setminus DEF[B_S]) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- For $B_1$, $OUT[B_1] = IN[B_S] = \\{x\\}$. Then\n  $$\n  IN[B_1] = USE[B_1] \\cup (OUT[B_1] \\setminus DEF[B_1]) = \\emptyset \\cup (\\{x\\} \\setminus \\{x\\}) = \\emptyset.\n  $$\n\nCollecting the $IN$ sets:\n- $IN[B_1] = \\emptyset$,\n- $IN[B_S] = \\{x\\}$,\n- $IN[B_2] = \\{x\\}$,\n- $IN[B_3] = \\{x\\}$,\n- $IN[B_4] = \\emptyset$,\n- $IN[B_5] = \\emptyset$,\n- $IN[B_6] = \\emptyset$,\n- $IN[B_7] = \\{x\\}$,\n- $IN[B_8] = \\emptyset$,\n- $IN[B_9] = \\{x\\}$.\n\nTherefore, the total number of basic blocks whose entry set contains $x$ is the count of blocks with $IN[B] = \\{x\\}$, which is $5$ (namely $B_S$, $B_2$, $B_3$, $B_7$, $B_9$).",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "Live variable analysis is not just a theoretical exercise; it is a cornerstone of modern compiler optimization, with its most critical application being register allocation. This capstone practice demonstrates the full workflow, from analysis to application. You will first perform live variable analysis on a small program to determine the \"live range\" of each variable, then use this information to construct an interference graph, where an edge connects any two variables that are live at the same time . The final step—determining the number of valid register assignments—reveals the direct connection between liveness analysis and the classic graph coloring problem, beautifully illustrating why this analysis is so fundamental to generating efficient machine code.",
            "id": "3651500",
            "problem": "Consider the following pseudo-program written in three-address style. The Control Flow Graph (CFG) consists of four basic blocks with edges $B_{1} \\rightarrow B_{2}$, $B_{1} \\rightarrow B_{3}$, $B_{2} \\rightarrow B_{4}$, and $B_{3} \\rightarrow B_{4}$. Only the variables $x$, $y$, and $z$ are candidates for register allocation; all other symbols denote memory-resident values that are not part of the register allocation problem.\n\nBlock $B_{1}$:\n- $x := a + 1$\n- $y := b + 1$\n- if $p$ goto $B_{2}$ else goto $B_{3}$\n\nBlock $B_{2}$:\n- $z := x + y$\n- $y := z + c$\n- goto $B_{4}$\n\nBlock $B_{3}$:\n- $z := y + d$\n- $x := z + e$\n- goto $B_{4}$\n\nBlock $B_{4}$:\n- $r := x + y + z$\n- return $r$\n\nUsing the standard backward-flow data-flow framework for live variable analysis, with the classical equations\n- $\\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s)$,\n- $\\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup \\left( \\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n) \\right)$,\nwhere $\\mathrm{Use}(n)$ and $\\mathrm{Def}(n)$ are computed with respect to the set $\\{x,y,z\\}$, perform the following:\n\n- Derive $\\mathrm{Use}$ and $\\mathrm{Def}$ for each basic block $B_{1}$, $B_{2}$, $B_{3}$, and $B_{4}$.\n- Solve the data-flow equations to obtain $\\mathrm{LiveIn}$ and $\\mathrm{LiveOut}$ for each basic block.\n- From the liveness information, construct the interference graph whose vertices are $\\{x,y,z\\}$ and where an edge between two variables indicates that they are simultaneously live at some program point.\n- Under the register allocation model in which assigning $k$ registers corresponds to a proper coloring of the interference graph with $k$ colors, determine a closed-form analytic expression in $k$ for the number of valid $k$-register allocations of $\\{x,y,z\\}$ for this program.\n\nExpress your final answer as a single analytic expression in $k$. No rounding is required. Do not include any units in your final answer.",
            "solution": "The solution proceeds in four steps as requested: calculating `Use`/`Def` sets, solving the liveness data-flow equations, constructing the interference graph, and finding the chromatic polynomial for the graph.\n\n**1. Derivation of `Use` and `Def` Sets**\n\nThe sets $\\mathrm{Use}(n)$ contain variables from $\\{x, y, z\\}$ that are used in block $n$ before they are defined in $n$. The sets $\\mathrm{Def}(n)$ contain variables from $\\{x, y, z\\}$ that are defined (assigned a value) in block $n$.\n\n-   **Block $B_{1}$**:\n    -   `x := a + 1`: Defines $x$.\n    -   `y := b + 1`: Defines $y$.\n    -   No variables from $\\{x, y, z\\}$ are used before being defined.\n    -   $\\mathrm{Use}(B_{1}) = \\emptyset$\n    -   $\\mathrm{Def}(B_{1}) = \\{x, y\\}$\n\n-   **Block $B_{2}$**:\n    -   `z := x + y`: Uses $x$ and $y$, defines $z$.\n    -   `y := z + c`: Uses $z$, defines $y$. The variable $z$ is used, but it was defined by the preceding statement within the same block, so it is not in $\\mathrm{Use}(B_2)$.\n    -   $\\mathrm{Use}(B_{2}) = \\{x, y\\}$\n    -   $\\mathrm{Def}(B_{2}) = \\{y, z\\}$\n\n-   **Block $B_{3}$**:\n    -   `z := y + d`: Uses $y$, defines $z$.\n    -   `x := z + e`: Uses $z$, defines $x$. The variable $z$ is used, but defined earlier in the block.\n    -   $\\mathrm{Use}(B_{3}) = \\{y\\}$\n    -   $\\mathrm{Def}(B_{3}) = \\{x, z\\}$\n\n-   **Block $B_{4}$**:\n    -   `r := x + y + z`: Uses $x$, $y$, and $z$.\n    -   No variables from $\\{x, y, z\\}$ are defined.\n    -   $\\mathrm{Use}(B_{4}) = \\{x, y, z\\}$\n    -   $\\mathrm{Def}(B_{4}) = \\emptyset$\n\n**2. Live Variable Analysis**\n\nWe solve the data-flow equations iteratively until a fixed point is reached. We initialize all $\\mathrm{LiveIn}$ and $\\mathrm{LiveOut}$ sets to $\\emptyset$. The analysis is performed backward, from the exit of the program.\n\nThe equations are:\n$\\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s)$\n$\\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup (\\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n))$\n\nSummary of `Use`/`Def` sets:\n-   $B_{1}$: $\\mathrm{Use} = \\emptyset$, $\\mathrm{Def} = \\{x, y\\}$\n-   $B_{2}$: $\\mathrm{Use} = \\{x, y\\}$, $\\mathrm{Def} = \\{y, z\\}$\n-   $B_{3}$: $\\mathrm{Use} = \\{y\\}$, $\\mathrm{Def} = \\{x, z\\}$\n-   $B_{4}$: $\\mathrm{Use} = \\{x, y, z\\}$, $\\mathrm{Def} = \\emptyset$\n\n**Iteration 1:**\n-   **Block $B_{4}$**:\n    -   $\\mathrm{LiveOut}(B_{4}) = \\bigcup_{s \\in \\emptyset} \\mathrm{LiveIn}(s) = \\emptyset$\n    -   $\\mathrm{LiveIn}(B_{4}) = \\mathrm{Use}(B_{4}) \\cup (\\mathrm{LiveOut}(B_{4}) \\setminus \\mathrm{Def}(B_{4})) = \\{x, y, z\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x, y, z\\}$\n-   **Block $B_{3}$**:\n    -   $\\mathrm{LiveOut}(B_{3}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$\n    -   $\\mathrm{LiveIn}(B_{3}) = \\mathrm{Use}(B_{3}) \\cup (\\mathrm{LiveOut}(B_{3}) \\setminus \\mathrm{Def}(B_{3})) = \\{y\\} \\cup (\\{x, y, z\\} \\setminus \\{x, z\\}) = \\{y\\} \\cup \\{y\\} = \\{y\\}$\n-   **Block $B_{2}$**:\n    -   $\\mathrm{LiveOut}(B_{2}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$\n    -   $\\mathrm{LiveIn}(B_{2}) = \\mathrm{Use}(B_{2}) \\cup (\\mathrm{LiveOut}(B_{2}) \\setminus \\mathrm{Def}(B_{2})) = \\{x, y\\} \\cup (\\{x, y, z\\} \\setminus \\{y, z\\}) = \\{x, y\\} \\cup \\{x\\} = \\{x, y\\}$\n-   **Block $B_{1}$**:\n    -   $\\mathrm{LiveOut}(B_{1}) = \\mathrm{LiveIn}(B_{2}) \\cup \\mathrm{LiveIn}(B_{3}) = \\{x, y\\} \\cup \\{y\\} = \\{x, y\\}$\n    -   $\\mathrm{LiveIn}(B_{1}) = \\mathrm{Use}(B_{1}) \\cup (\\mathrm{LiveOut}(B_{1}) \\setminus \\mathrm{Def}(B_{1})) = \\emptyset \\cup (\\{x, y\\} \\setminus \\{x, y\\}) = \\emptyset$\n\n**Iteration 2:** We recompute the sets to check for convergence.\n-   $\\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$. No change.\n-   $\\mathrm{LiveOut}(B_{3}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$. No change.\n-   $\\mathrm{LiveIn}(B_{3}) = \\{y\\}$. No change.\n-   $\\mathrm{LiveOut}(B_{2}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$. No change.\n-   $\\mathrm{LiveIn}(B_{2}) = \\{x, y\\}$. No change.\n-   $\\mathrm{LiveOut}(B_{1}) = \\mathrm{LiveIn}(B_{2}) \\cup \\mathrm{LiveIn}(B_{3}) = \\{x, y\\}$. No change.\n-   $\\mathrm{LiveIn}(B_{1}) = \\emptyset$. No change.\n\nA fixed point has been reached. The final liveness sets are:\n-   $\\mathrm{LiveIn}(B_{1}) = \\emptyset$, $\\mathrm{LiveOut}(B_{1}) = \\{x, y\\}$\n-   $\\mathrm{LiveIn}(B_{2}) = \\{x, y\\}$, $\\mathrm{LiveOut}(B_{2}) = \\{x, y, z\\}$\n-   $\\mathrm{LiveIn}(B_{3}) = \\{y\\}$, $\\mathrm{LiveOut}(B_{3}) = \\{x, y, z\\}$\n-   $\\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$, $\\mathrm{LiveOut}(B_{4}) = \\emptyset$\n\n**3. Interference Graph Construction**\n\nTwo variables interfere if they are simultaneously live at any program point. We can find interferences by examining the live sets. A sufficient condition for interference between a set of variables is their simultaneous presence in any $\\mathrm{LiveIn}$ or $\\mathrm{LiveOut}$ set, or in the live set at any point within a basic block.\n\n-   At the entry to block $B_{4}$, the live set is $\\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$. This means that variables $x$, $y$, and $z$ are all live at the same time.\n-   Therefore, they all interfere with each other. This implies the existence of the following interference edges:\n    -   $(x, y)$\n    -   $(x, z)$\n    -   $(y, z)$\n-   These three edges form a complete graph $K_{3}$ on the set of vertices $\\{x, y, z\\}$. Since this is the maximal possible number of edges for three vertices, we have fully determined the interference graph.\n-   Confirmation: The set $\\mathrm{LiveOut}(B_{2}) = \\{x, y, z\\}$ and $\\mathrm{LiveOut}(B_{3}) = \\{x, y, z\\}$ also show that all three variables are simultaneously live at the exits of blocks $B_{2}$ and $B_{3}$.\n\nThe interference graph is a triangle connecting vertices $x$, $y$, and $z$.\n\n**4. Number of Valid $k$-Register Allocations**\n\nA valid allocation of $k$ registers corresponds to a proper coloring of the interference graph with $k$ colors. The number of ways to do this is given by the chromatic polynomial of the graph, evaluated at $k$.\n\nThe interference graph is a complete graph on $3$ vertices, denoted as $K_{3}$. The chromatic polynomial of a complete graph $K_{n}$ is given by the formula:\n$$P(K_{n}, k) = k(k-1)(k-2)\\dots(k-n+1)$$\nThis is also known as the falling factorial $k^{(n)}$ or permutation number $P(k,n)$.\n\nFor our graph, $n=3$, so the number of valid $k$-colorings (register allocations) is:\n$$P(K_{3}, k) = k(k-1)(k-2)$$\n\nThis expression gives the number of ways to assign colors (registers) to the variables $x$, $y$, and $z$ such that no two interfering variables share the same color.\n-   For variable $x$, there are $k$ choices of color.\n-   For variable $y$, which interferes with $x$, there are $k-1$ remaining choices.\n-   For variable $z$, which interferes with both $x$ and $y$ (which must have different colors), there are $k-2$ remaining choices.\n\nThe total number of valid allocations is the product $k(k-1)(k-2)$. This is the required closed-form analytic expression.",
            "answer": "$$\n\\boxed{k(k-1)(k-2)}\n$$"
        }
    ]
}