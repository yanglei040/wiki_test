{
    "hands_on_practices": [
        {
            "introduction": "到达定值分析是数据流分析的基石，它帮助编译器理解变量值如何在程序中传播。第一个练习  聚焦于一个关键的初始步骤：如何根据单个基本块内的一系列指令，正确地计算其 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集合。通过细致地应用“最后写入者获胜”原则，你将理解块内的重定义是如何被处理的，这是构建任何数据流分析问题的基础技能。",
            "id": "3665951",
            "problem": "考虑以下针对三个变量 $x$、$y$ 和 $z$ 的线性代码片段的控制流图 (CFG)。每个赋值都是一个唯一的定义，标记为 $d_i$，其中 $i \\in \\{1,2,3,4,5,6,7\\}$。唯一不是定义的操作是条件分支。CFG 节点（基本块）及其内容如下：\n- 块 $B_1$：\n  - $d_1$: `` `x := 0` ``\n  - $d_2$: `` `y := 0` ``\n  - 无条件分支到 $B_2$。\n- 块 $B_2$：\n  - $d_3$: `` `x := 1` ``\n  - $d_4$: `` `y := 2` ``\n  - $d_5$: `` `x := 3` ``\n  - 基于 $c$ 的条件分支，若为真则到 $B_3$，若为假则到 $B_4$。\n- 块 $B_3$：\n  - $d_6$: `` `y := 4` ``\n  - 无条件分支到 $B_5$。\n- 块 $B_4$：\n  - $d_7$: `` `x := 5` ``\n  - 无条件分支到 $B_5$。\n- 块 $B_5$：\n  - 在计算 `` `z := x + y` `` 中使用了 $x$ 和 $y$（此使用本身在进入 $B_5$ 之前不会引入新的到达定义）。\n\n你需要使用经典的数据流框架，根据以下规范，执行一次标准的前向、可能到达定义 (Reaching Definitions, RD) 分析：\n- 方向：前向。\n- 交汇运算符：集合并集。\n- 每个块 $B$ 的传递函数：基于块内的“最后写入者获胜”原则，通过 $\\mathrm{GEN}[B]$ 和 $\\mathrm{KILL}[B]$ 计算。\n- 定义全集为 $D = \\{d_1,d_2,d_3,d_4,d_5,d_6,d_7\\}$。\n- 边界条件：$\\mathrm{IN}[B_1] = \\varnothing$。\n- 对于 $\\mathrm{KILL}$ 集，一个定义 $d \\in D$ 会被任何后续对同一变量的定义所杀死；在一个块内，只有对给定变量的最后一次定义属于 $\\mathrm{GEN}$，而该块中对同一变量的更早的定义不属于 $\\mathrm{GEN}$，并被认为在该块内被杀死。\n\n这个 CFG 是故意设计得既简约又足以证伪一个朴素的 RD 假设，即认为在条件分支之前的块内定义可能只能到达其中一个后继节点。在一个基本块中，单一的 $\\mathrm{OUT}[B]$ 会流向所有后继节点，而块内的重定义必须通过“最后写入者获胜”的规则来处理。\n\n设 $\\mathrm{IN}[B_5]$ 为在不动点处到达 $B_5$ 入口的 $D$ 中定义的集合。定义标量 $S$\n$$\nS \\;=\\; \\sum \\{\\, i \\mid d_i \\in \\mathrm{IN}[B_5] \\text{ and } d_i \\text{ is a definition of } x \\text{ or } y \\,\\}.\n$$\n计算 $S$。你的最终答案必须是一个实数值，无需四舍五入。",
            "solution": "该问题是良定义的，并基于编译原理，特别是数据流分析。我们将通过应用标准的到达定义迭代算法来解决它。\n\n定义全集为 $D = \\{d_1, d_2, d_3, d_4, d_5, d_6, d_7\\}$。\n这些定义涉及变量 $x$ 和 $y$。设 $D_x$ 为 $x$ 的定义集，$D_y$ 为 $y$ 的定义集。\n$D_x = \\{d_1, d_3, d_5, d_7\\}$\n$D_y = \\{d_2, d_4, d_6\\}$\n\n首先，我们计算每个基本块 $B$ 的 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集。$\\mathrm{GEN}[B]$ 是在 $B$ 内部且能到达 $B$ 末尾的定义集合。根据“最后写入者获胜”规则，这是 $B$ 中为每个被赋值变量的最后一次定义的集合。$\\mathrm{KILL}[B]$ 是程序中所有被 $B$ 中定义所杀死的定义的集合。如果块 $B$ 也包含对变量 $v$ 的定义，那么它会杀死任何其他对变量 $v$ 的定义。\n\n块 $B_1$：包含 $d_1: x := 0$ 和 $d_2: y := 0$。\n$\\mathrm{GEN}[B_1] = \\{d_1, d_2\\}$。\n$B_1$ 定义了 $x$ 和 $y$。它会杀死所有其他对 $x$ 和 $y$ 的定义。\n$\\mathrm{KILL}[B_1] = (D_x \\setminus \\{d_1\\}) \\cup (D_y \\setminus \\{d_2\\}) = \\{d_3, d_5, d_7\\} \\cup \\{d_4, d_6\\} = \\{d_3, d_4, d_5, d_6, d_7\\}$。\n\n块 $B_2$：包含 $d_3: x := 1$、$d_4: y := 2$ 和 $d_5: x := 3$。\n$x$ 的最后一次定义是 $d_5$。$y$ 的最后一次定义是 $d_4$。定义 $d_3$ 在块内被杀死。\n$\\mathrm{GEN}[B_2] = \\{d_4, d_5\\}$。\n$B_2$ 定义了 $x$ 和 $y$。它会杀死所有其他对 $x$ 和 $y$ 的定义。\n$\\mathrm{KILL}[B_2] = (D_x \\setminus \\{d_5\\}) \\cup (D_y \\setminus \\{d_4\\}) = \\{d_1, d_3, d_7\\} \\cup \\{d_2, d_6\\} = \\{d_1, d_2, d_3, d_6, d_7\\}$。\n\n块 $B_3$：包含 $d_6: y := 4$。\n$\\mathrm{GEN}[B_3] = \\{d_6\\}$。\n$B_3$ 定义了 $y$。它会杀死所有其他对 $y$ 的定义。\n$\\mathrm{KILL}[B_3] = D_y \\setminus \\{d_6\\} = \\{d_2, d_4\\}$。\n\n块 $B_4$：包含 $d_7: x := 5$。\n$\\mathrm{GEN}[B_4] = \\{d_7\\}$。\n$B_4$ 定义了 $x$。它会杀死所有其他对 $x$ 的定义。\n$\\mathrm{KILL}[B_4] = D_x \\setminus \\{d_7\\} = \\{d_1, d_3, d_5\\}$。\n\n块 $B_5$：包含一个使用，但没有定义。\n$\\mathrm{GEN}[B_5] = \\varnothing$。\n$\\mathrm{KILL}[B_5] = \\varnothing$。\n\n交汇运算符为并集的前向分析的数据流方程为：\n$$\n\\mathrm{OUT}[B] = \\mathrm{GEN}[B] \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}[B])\n$$\n$$\n\\mathrm{IN}[B] = \\bigcup_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P]\n$$\n给定 CFG 的具体方程为：\n$\\mathrm{IN}[B_1] = \\varnothing$ (边界条件)\n$\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_1]$\n$\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_2]$\n$\\mathrm{IN}[B_4] = \\mathrm{OUT}[B_2]$\n$\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_3] \\cup \\mathrm{OUT}[B_4]$\n\n我们迭代求解这些方程，将所有的 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集初始化为 $\\varnothing$。\n\n迭代 0：所有集合均为 $\\varnothing$。\n\n迭代 1：\n$\\mathrm{IN}[B_1] = \\varnothing$\n$\\mathrm{OUT}[B_1] = \\mathrm{GEN}[B_1] \\cup (\\mathrm{IN}[B_1] \\setminus \\mathrm{KILL}[B_1]) = \\{d_1, d_2\\} \\cup (\\varnothing \\setminus \\dots) = \\{d_1, d_2\\}$\n$\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_1] = \\{d_1, d_2\\}$\n$\\mathrm{OUT}[B_2] = \\mathrm{GEN}[B_2] \\cup (\\mathrm{IN}[B_2] \\setminus \\mathrm{KILL}[B_2]) = \\{d_4, d_5\\} \\cup (\\{d_1, d_2\\} \\setminus \\{d_1, d_2, d_3, d_6, d_7\\}) = \\{d_4, d_5\\} \\cup \\varnothing = \\{d_4, d_5\\}$\n$\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_2] = \\{d_4, d_5\\}$\n$\\mathrm{OUT}[B_3] = \\mathrm{GEN}[B_3] \\cup (\\mathrm{IN}[B_3] \\setminus \\mathrm{KILL}[B_3]) = \\{d_6\\} \\cup (\\{d_4, d_5\\} \\setminus \\{d_2, d_4\\}) = \\{d_6\\} \\cup \\{d_5\\} = \\{d_5, d_6\\}$\n$\\mathrm{IN}[B_4] = \\mathrm{OUT}[B_2] = \\{d_4, d_5\\}$\n$\\mathrm{OUT}[B_4] = \\mathrm{GEN}[B_4] \\cup (\\mathrm{IN}[B_4] \\setminus \\mathrm{KILL}[B_4]) = \\{d_7\\} \\cup (\\{d_4, d_5\\} \\setminus \\{d_1, d_3, d_5\\}) = \\{d_7\\} \\cup \\{d_4\\} = \\{d_4, d_7\\}$\n$\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_3] \\cup \\mathrm{OUT}[B_4] = \\{d_5, d_6\\} \\cup \\{d_4, d_7\\} = \\{d_4, d_5, d_6, d_7\\}$\n\n迭代 2：我们使用迭代 1 的值重新计算所有集合。\n$\\mathrm{IN}[B_1] = \\varnothing$（无变化）\n$\\mathrm{OUT}[B_1] = \\{d_1, d_2\\}$（无变化）\n$\\mathrm{IN}[B_2] = \\{d_1, d_2\\}$（无变化）\n$\\mathrm{OUT}[B_2] = \\{d_4, d_5\\}$（无变化）\n$\\mathrm{IN}[B_3] = \\{d_4, d_5\\}$（无变化）\n$\\mathrm{OUT}[B_3] = \\{d_5, d_6\\}$（无变化）\n$\\mathrm{IN}[B_4] = \\{d_4, d_5\\}$（无变化）\n$\\mathrm{OUT}[B_4] = \\{d_4, d_7\\}$（无变化）\n$\\mathrm{IN}[B_5] = \\{d_4, d_5, d_6, d_7\\}$（无变化）\n\n由于在迭代 2 中没有集合的值发生变化，算法已达到不动点。到达块 $B_5$ 入口的定义集是 $\\mathrm{IN}[B_5] = \\{d_4, d_5, d_6, d_7\\}$。\n\n问题要求计算索引 $i$ 的和 $S$，其中 $d_i \\in \\mathrm{IN}[B_5]$ 且 $d_i$ 是对 $x$ 或 $y$ 的定义。我们检查 $\\mathrm{IN}[B_5]$ 的元素：\n- $d_4$: $y := 2$。这是对 $y$ 的一个定义。其索引为 $4$。\n- $d_5$: $x := 3$。这是对 $x$ 的一个定义。其索引为 $5$。\n- $d_6$: $y := 4$。这是对 $y$ 的一个定义。其索引为 $6$。\n- $d_7$: $x := 5$。这是对 $x$ 的一个定义。其索引为 $7$。\n\n$\\mathrm{IN}[B_5]$ 中的所有定义都是对 $x$ 或 $y$ 的。要求和的索引集是 $\\{4,5,6,7\\}$。\n和 $S$ 计算如下：\n$$\nS = 4 + 5 + 6 + 7 = 22\n$$",
            "answer": "$$\n\\boxed{22}\n$$"
        },
        {
            "introduction": "到达定值分析追踪值的来源，而可用表达式分析则确定哪些表达式已被计算且其值可被复用，这是一种“必达”(must)分析。本练习  将阐明数据流分析如何与代数化简等其他编译器优化相互作用。你将对比有无此预优化两种情况下分析过程的差异，从而发现它对不动点求解收敛速度的直接影响。",
            "id": "3635615",
            "problem": "考虑对以下三地址代码程序的控制流图（CFG）进行可用表达式的前向必须分析。该CFG包含从 $B_1$ 到 $B_5$ 的基本块和一个 $Entry$ 节点。边包括 $Entry \\rightarrow B_1$、$B_1 \\rightarrow B_2$、$B_2 \\rightarrow B_3$、$B_2 \\rightarrow B_4$、$B_3 \\rightarrow B_5$、$B_4 \\rightarrow B_5$ 和 $B_5 \\rightarrow B_2$。语句如下：\n\n- $B_1$: `` `y := d - d` ``; goto $B_2$.\n- $B_2$: `` `if p goto B3 else goto B4` ``.\n- $B_3$: `` `d := x + y` ``; goto $B_5$.\n- $B_4$: `` `t := d - d` ``; goto $B_5$.\n- $B_5$: `` `if q goto B2 else exit` ``.\n\n假设使用标准的可用表达式数据流框架：\n- 方向：前向。\n- 汇合运算符：集合交集。\n- 每个块 $b$ 的传递函数：$OUT[b] = GEN[b] \\cup (IN[b] \\setminus KILL[b])$，以及 $IN[b] = \\bigcap_{p \\in \\mathrm{pred}(b)} OUT[p]$。\n- 表达式全集 $E$ 是程序中出现的所有形式为 $u \\oplus v$ 的不同非平凡二元算术表达式的集合，其中 $\\oplus \\in \\{+, -, \\times\\}$。\n\n比较两种场景：\n- 朴素场景：不进行代数化简；将 $E_{\\mathrm{naive}}$ 作为代码中出现的所有语法上的二元表达式，并根据语句以常规方式计算块局部的 $GEN$/$KILL$ 集合。\n- 剪枝场景：在使用恒等式 $x + 0 \\rightarrow x$、$0 + x \\rightarrow x$、$x - 0 \\rightarrow x$、$x \\times 1 \\rightarrow x$ 和 $x - x \\rightarrow 0$（常数）进行代数化简后，再形成 $E$ 和 $GEN$/$KILL$。特别地，任何出现的 $d - d$ 都会化简为一个常数，并且不会为 $E_{\\mathrm{pruned}}$ 或任何 $GEN$ 集合贡献表达式。\n\n初始化和求解器调度：\n- 初始化 $OUT[Entry] = \\varnothing$。\n- 对于所有其他块 $b \\in \\{B_1,B_2,B_3,B_4,B_5\\}$，将 $OUT[b]$ 初始化为 $E$（即，根据不同场景为 $E_{\\mathrm{naive}}$ 或 $E_{\\mathrm{pruned}}$）。\n- 一次全局迭代（扫描）按固定顺序 $[B_1,B_2,B_3,B_4,B_5]$ 访问这些块。在每次扫描中，对于此顺序中的每个块 $b$，根据当前前驱节点的 $OUT$ 值重新计算 $IN[b]$，然后通过传递函数重新计算 $OUT[b]$。求解器在完成一次没有任何 $b$ 的 $OUT[b]$ 发生变化的扫描后终止。\n- 将 $I_{\\mathrm{naive}}$ 和 $I_{\\mathrm{pruned}}$ 分别定义为朴素场景和剪枝场景下直到终止所需的全局扫描次数。\n\n任务：\n- 根据上述数据流框架的基本原理，推导出两种场景下的 $E_{\\mathrm{naive}}$ 和 $E_{\\mathrm{pruned}}$，以及每个块对应的 $GEN$/$KILL$ 集合，并明确说明代数化简如何改变 $GEN$ 和 $KILL$。\n- 仅使用给定的定义，在两种场景下执行轮询求解器直至达到不动点，展示 $IN$ 和 $OUT$ 集合逐次扫描的演变过程，并确定 $I_{\\mathrm{naive}}$ 和 $I_{\\mathrm{pruned}}$。\n- 你的最终答案必须是单个实数值 $I_{\\mathrm{naive}} - I_{\\mathrm{pruned}}$。无需四舍五入。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **控制流图 (CFG)**:\n    - 基本块：$B_1$、$B_2$、$B_3$、$B_4$、$B_5$ 和一个 $Entry$ 节点。\n    - 边：$Entry \\rightarrow B_1$、$B_1 \\rightarrow B_2$、$B_2 \\rightarrow B_3$、$B_2 \\rightarrow B_4$、$B_3 \\rightarrow B_5$、$B_4 \\rightarrow B_5$ 和 $B_5 \\rightarrow B_2$。\n- **程序语句（三地址代码）**:\n    - $B_1$: $y := d - d$; goto $B_2$.\n    - $B_2$: if $p$ goto $B_3$ else goto $B_4$.\n    - $B_3$: $d := x + y$; goto $B_5$.\n    - $B_4$: $t := d - d$; goto $B_5$.\n    - $B_5$: if $q$ goto $B_2$ else exit.\n- **数据流框架（可用表达式）**:\n    - 方向：前向。\n    - 汇合运算符：集合交集 ($\\cap$)。\n    - 块 $b$ 的传递函数：$OUT[b] = GEN[b] \\cup (IN[b] \\setminus KILL[b])$。\n    - 块 $b$ 的输入集合：$IN[b] = \\bigcap_{p \\in \\mathrm{pred}(b)} OUT[p]$。\n- **表达式全集 ($E$)**: 程序中出现的所有形式为 $u \\oplus v$ 的不同非平凡二元算术表达式的集合，其中 $\\oplus \\in \\{+, -, \\times\\}$。\n- **场景**:\n    - **朴素场景**：无代数化简。$E_{\\mathrm{naive}}$ 包括所有语法上的二元表达式。\n    - **剪枝场景**：应用代数化简（$x + 0 \\rightarrow x$、$0 + x \\rightarrow x$、$x - 0 \\rightarrow x$、$x \\times 1 \\rightarrow x$、$x - x \\rightarrow 0$）。表达式 $d-d$ 化简为常数，并从 $E_{\\mathrm{pruned}}$ 和任何 $GEN$ 集合中排除。\n- **求解器算法**:\n    - 初始化：$OUT[Entry] = \\varnothing$。对于所有其他块 $b$，$OUT[b] = E$。\n    - 迭代调度：每次扫描按固定顺序 $[B_1, B_2, B_3, B_4, B_5]$。\n    - 终止：在完成一次没有任何 $OUT[b]$ 集合发生变化的完整扫描后。\n    - 目标：确定每种场景下达到终止所需的扫描次数 $I_{\\mathrm{naive}}$ 和 $I_{\\mathrm{pruned}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在编译器构造和数据流分析的标准理论框架内定义明确。所有概念，包括CFG、可用表达式、GEN/KILL集合和迭代求解器，都是标准的。问题提供了一套完整的规则、初始条件和确定性算法。CFG结构是明确的，包括一个循环（$B_2 \\rightarrow ... \\rightarrow B_5 \\rightarrow B_2$），这使得分析不那么简单。两种场景（朴素与剪枝）有清晰的区分。该问题具有科学依据、内容自洽、客观且定义良好。它没有违反任何无效标准。\n\n### 步骤 3：结论与行动\n问题有效。将提供详细的解决方案。\n\n### 解题推导\n我们将依次分析这两种场景，从朴素场景开始。对于每种场景，我们定义表达式全集、$GEN$ 和 $KILL$ 集合，然后追踪迭代求解器的过程。\n\n#### 朴素场景\n在这种场景下，表达式按其书面形式处理，不进行代数化简。\n\n**1. 表达式全集 $E_{\\mathrm{naive}}$**\n代码中出现的非平凡二元算术表达式是 $d-d$（在 $B_1$ 和 $B_4$ 中）和 $x+y$（在 $B_3$ 中）。\n令 $e_1 = d-d$，$e_2 = x+y$。\n表达式全集为 $E_{\\mathrm{naive}} = \\{e_1, e_2\\}$。\n\n**2. $GEN$ 和 $KILL$ 集合**\n- $B_1: y := d - d$\n    - $GEN[B_1] = \\{e_1\\}$，因为它计算了 $d-d$。\n    - $KILL[B_1] = \\{e_2\\}$，因为对 $y$ 的赋值会扼杀任何以 $y$ 为操作数的表达式（$x+y$）。\n- $B_2:$ if $p \\dots$\n    - $GEN[B_2] = \\varnothing$。\n    - $KILL[B_2] = \\varnothing$。\n- $B_3: d := x + y$\n    - $GEN[B_3] = \\{e_2\\}$，因为它计算了 $x+y$。\n    - $KILL[B_3] = \\{e_1\\}$，因为对 $d$ 的赋值会扼杀任何以 $d$ 为操作数的表达式（$d-d$）。\n- $B_4: t := d - d$\n    - $GEN[B_4] = \\{e_1\\}$，因为它计算了 $d-d$。\n    - $KILL[B_4] = \\varnothing$，因为对 $t$ 的赋值不会扼杀 $E_{\\mathrm{naive}}$ 中的任何表达式。\n- $B_5:$ if $q \\dots$\n    - $GEN[B_5] = \\varnothing$。\n    - $KILL[B_5] = \\varnothing$。\n\n**3. 迭代求解器执行过程（朴素场景）**\n前驱节点为：$\\mathrm{pred}(B_1)=\\{Entry\\}$, $\\mathrm{pred}(B_2)=\\{B_1, B_5\\}$, $\\mathrm{pred}(B_3)=\\{B_2\\}$, $\\mathrm{pred}(B_4)=\\{B_2\\}$, $\\mathrm{pred}(B_5)=\\{B_3, B_4\\}$。\n\n**初始化 (扫描 0):**\n- $OUT[Entry] = \\varnothing$\n- $OUT[B_1] = OUT[B_2] = OUT[B_3] = OUT[B_4] = OUT[B_5] = \\{e_1, e_2\\}$。\n\n**扫描 1:**\n- **$B_1$**: $IN[B_1] = OUT[Entry] = \\varnothing$。\n  $OUT[B_1] = \\{e_1\\} \\cup (\\varnothing \\setminus \\{e_2\\}) = \\{e_1\\}$。(已更改)\n- **$B_2$**: $IN[B_2] = OUT[B_1] \\cap OUT[B_5] = \\{e_1\\} \\cap \\{e_1, e_2\\} = \\{e_1\\}$。\n  $OUT[B_2] = \\varnothing \\cup (\\{e_1\\} \\setminus \\varnothing) = \\{e_1\\}$。(已更改)\n- **$B_3$**: $IN[B_3] = OUT[B_2] = \\{e_1\\}$。\n  $OUT[B_3] = \\{e_2\\} \\cup (\\{e_1\\} \\setminus \\{e_1\\}) = \\{e_2\\}$。(已更改)\n- **$B_4$**: $IN[B_4] = OUT[B_2] = \\{e_1\\}$。\n  $OUT[B_4] = \\{e_1\\} \\cup (\\{e_1\\} \\setminus \\varnothing) = \\{e_1\\}$。(已更改)\n- **$B_5$**: $IN[B_5] = OUT[B_3] \\cap OUT[B_4] = \\{e_2\\} \\cap \\{e_1\\} = \\varnothing$。\n  $OUT[B_5] = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$。(已更改)\n在扫描 1 结束时，发生了变化。新状态为：$OUT[B_1]=\\{e_1\\}, OUT[B_2]=\\{e_1\\}, OUT[B_3]=\\{e_2\\}, OUT[B_4]=\\{e_1\\}, OUT[B_5]=\\varnothing$。\n\n**扫描 2:**\n- **$B_1$**: $IN[B_1] = \\varnothing$。$OUT[B_1] = \\{e_1\\}$。(无变化)\n- **$B_2$**: $IN[B_2] = OUT[B_1] \\cap OUT[B_5] = \\{e_1\\} \\cap \\varnothing = \\varnothing$。\n  $OUT[B_2] = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$。(从 $\\{e_1\\}$ 更改)\n- **$B_3$**: $IN[B_3] = OUT[B_2] = \\varnothing$。\n  $OUT[B_3] = \\{e_2\\} \\cup (\\varnothing \\setminus \\{e_1\\}) = \\{e_2\\}$。(无变化)\n- **$B_4$**: $IN[B_4] = OUT[B_2] = \\varnothing$。\n  $OUT[B_4] = \\{e_1\\} \\cup (\\varnothing \\setminus \\varnothing) = \\{e_1\\}$。(无变化)\n- **$B_5$**: $IN[B_5] = OUT[B_3] \\cap OUT[B_4] = \\{e_2\\} \\cap \\{e_1\\} = \\varnothing$。\n  $OUT[B_5] = \\varnothing$。(无变化)\n在扫描 2 结束时，发生了变化 ($OUT[B_2]$)。新状态为：$OUT[B_1]=\\{e_1\\}, OUT[B_2]=\\varnothing, OUT[B_3]=\\{e_2\\}, OUT[B_4]=\\{e_1\\}, OUT[B_5]=\\varnothing$。\n\n**扫描 3:**\n- **$B_1$**: $IN[B_1] = \\varnothing$。$OUT[B_1] = \\{e_1\\}$。(无变化)\n- **$B_2$**: $IN[B_2] = OUT[B_1] \\cap OUT[B_5] = \\{e_1\\} \\cap \\varnothing = \\varnothing$。\n  $OUT[B_2] = \\varnothing$。(无变化)\n- **$B_3$**: $IN[B_3] = OUT[B_2] = \\varnothing$。\n  $OUT[B_3] = \\{e_2\\}$。(无变化)\n- **$B_4$**: $IN[B_4] = OUT[B_2] = \\varnothing$。\n  $OUT[B_4] = \\{e_1\\}$。(无变化)\n- **$B_5$**: $IN[B_5] = OUT[B_3] \\cap OUT[B_4] = \\{e_2\\} \\cap \\{e_1\\} = \\varnothing$。\n  $OUT[B_5] = \\varnothing$。(无变化)\n在扫描 3 期间，没有 $OUT$ 集合发生变化。算法在此次扫描后终止。总扫描次数为 3。\n因此，$I_{\\mathrm{naive}} = 3$。\n\n#### 剪枝场景\n在这种场景下，表达式 $d-d$ 被化简为常数 $0$，不被视为非平凡表达式。\n\n**1. 表达式全集 $E_{\\mathrm{pruned}}$**\n- 语句 $y := d-d$ 变为 $y:=0$。\n- 语句 $d := x+y$ 保持不变，给出表达式 $x+y$。\n- 语句 $t := d-d$ 变为 $t:=0$。\n唯一的非平凡二元算术表达式是 $x+y$。我们称之为 $e'$。\n表达式全集为 $E_{\\mathrm{pruned}} = \\{x+y\\} = \\{e'\\}$。\n\n**2. $GEN$ 和 $KILL$ 集合**\n- $B_1: y := 0$ (来自 $y := d - d$)\n    - $GEN[B_1] = \\varnothing$，因为 $d-d$ 被化简掉，不生成表达式。\n    - $KILL[B_1] = \\{e'\\}$，因为对 $y$ 的赋值会扼杀表达式 $x+y$。\n- $B_2:$ if $p \\dots$\n    - $GEN[B_2] = \\varnothing$。\n    - $KILL[B_2] = \\varnothing$。\n- $B_3: d := x + y$\n    - $GEN[B_3] = \\{e'\\}$。\n    - $KILL[B_3] = \\varnothing$，因为对 $d$ 的赋值不会扼杀 $E_{\\mathrm{pruned}}$ 中的任何表达式。\n- $B_4: t := 0$ (来自 $t := d - d$)\n    - $GEN[B_4] = \\varnothing$。\n    - $KILL[B_4] = \\varnothing$。\n- $B_5:$ if $q \\dots$\n    - $GEN[B_5] = \\varnothing$。\n    - $KILL[B_5] = \\varnothing$。\n\n**3. 迭代求解器执行过程（剪枝场景）**\n\n**初始化 (扫描 0):**\n- $OUT[Entry] = \\varnothing$\n- $OUT[B_1] = OUT[B_2] = OUT[B_3] = OUT[B_4] = OUT[B_5] = \\{e'\\}$。\n\n**扫描 1:**\n- **$B_1$**: $IN[B_1] = OUT[Entry] = \\varnothing$。\n  $OUT[B_1] = \\varnothing \\cup (\\varnothing \\setminus \\{e'\\}) = \\varnothing$。(已更改)\n- **$B_2$**: $IN[B_2] = OUT[B_1] \\cap OUT[B_5] = \\varnothing \\cap \\{e'\\} = \\varnothing$。\n  $OUT[B_2] = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$。(已更改)\n- **$B_3$**: $IN[B_3] = OUT[B_2] = \\varnothing$。\n  $OUT[B_3] = \\{e'\\} \\cup (\\varnothing \\setminus \\varnothing) = \\{e'\\}$。(无变化)\n- **$B_4$**: $IN[B_4] = OUT[B_2] = \\varnothing$。\n  $OUT[B_4] = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$。(已更改)\n- **$B_5$**: $IN[B_5] = OUT[B_3] \\cap OUT[B_4] = \\{e'\\} \\cap \\varnothing = \\varnothing$。\n  $OUT[B_5] = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$。(已更改)\n在扫描 1 结束时，发生了变化。新状态为：$OUT[B_1]=\\varnothing, OUT[B_2]=\\varnothing, OUT[B_3]=\\{e'\\}, OUT[B_4]=\\varnothing, OUT[B_5]=\\varnothing$。\n\n**扫描 2:**\n- **$B_1$**: $IN[B_1] = \\varnothing$。$OUT[B_1] = \\varnothing$。(无变化)\n- **$B_2$**: $IN[B_2] = OUT[B_1] \\cap OUT[B_5] = \\varnothing \\cap \\varnothing = \\varnothing$。\n  $OUT[B_2] = \\varnothing$。(无变化)\n- **$B_3$**: $IN[B_3] = OUT[B_2] = \\varnothing$。\n  $OUT[B_3] = \\{e'\\}$。(无变化)\n- **$B_4$**: $IN[B_4] = OUT[B_2] = \\varnothing$。\n  $OUT[B_4] = \\varnothing$。(无变化)\n- **$B_5$**: $IN[B_5] = OUT[B_3] \\cap OUT[B_4] = \\{e'\\} \\cap \\varnothing = \\varnothing$。\n  $OUT[B_5] = \\varnothing$。(无变化)\n在扫描 2 期间，没有 $OUT$ 集合发生变化。算法在此次扫描后终止。总扫描次数为 2。\n因此，$I_{\\mathrm{pruned}} = 2$。\n\n### 最终计算\n问题要求计算 $I_{\\mathrm{naive}} - I_{\\mathrm{pruned}}$ 的值。\n根据我们的分析：\n$I_{\\mathrm{naive}} = 3$\n$I_{\\mathrm{pruned}} = 2$\n$I_{\\mathrm{naive}} - I_{\\mathrm{pruned}} = 3 - 2 = 1$。\n收敛速度的差异是由于剪枝场景中表达式集合更小以及 $GEN$/$KILL$ 集合不同，这使得数据流值能更快地稳定下来。具体来说，在剪枝情况下，$OUT[B_2]$ 在一次扫描中就稳定了，而在朴素情况下则需要两次扫描。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "与之前的正向分析不同，活跃变量分析是一种反向分析，用于确定哪些变量的值在未来可能被使用。这个动手实践  要求你为包含 `break` 和 `continue` 等结构化语句的代码构建正确的控制流图，这些语句会产生非线性的跳转路径。通过对比精确的控制流图与简化的线性模型，你将深刻体会到，底层图模型的准确性对于保证分析结果的正确性是何等重要。",
            "id": "3635622",
            "problem": "给定一个结构化语言中的单过程片段，其中包含标量整型变量 $a$、$b$、$c$ 和 $x$。该片段由一个单一循环组成，其循环体同时包含 $break$ 和 $continue$ 语句。循环及其语句以下面编号的程序点序列给出。每个语句标签 $P_i$ 标识了执行相应语句之前的程序点。控制流遵循 $while$、$if$、$break$ 和 $continue$ 的常规结构化语义。\n\n- $P_1$: 循环头，条件为 `a  b`。\n- $P_2$: 赋值语句 `x := a + c`。\n- $P_3$: 条件语句 `if (x > b)` 则跳转到 $P_4$，否则跳转到 $P_5$。\n- $P_4$: 赋值语句 `c := c + 1`，然后是条件语句 `if (c > a)` 则 `break` 循环，否则顺序执行到 $P_5$。\n- $P_5$: 条件语句 `if (x  c)` 则跳转到 $P_6$，否则跳转到 $P_7$。\n- $P_6$: 赋值语句 `a := a + 1`，然后 `continue` 循环（即，跳转到 $P_1$ 处的循环头）。\n- $P_7$: 赋值语句 `b := b - x`，然后顺序执行到循环体末尾并跳转到 $P_1$ 处的循环头。\n- $P_8$: 循环之后，是一个带有表达式 `a + c` 的 `return` 语句。\n\n基本基础和建模要求：\n- 使用活性的基本定义：如果从某个程序点存在一条路径，在该路径上一个变量被使用前没有被重新定义，则该变量在该程序点是活跃的。\n- 使用控制流图（Control Flow Graph (CFG)）对程序进行建模，其中节点是与上述程序点 $P_1$ 到 $P_8$ 对齐的基本块，边反映实际的控制转移，包括由 $break$ 和 $continue$ 引起的转移。\n- 将 $P_8$ 处的 `return` 视为对其表达式中变量的使用。没有其他副作用或外部使用；没有函数调用。\n\n任务：\n1) 通过列出由结构化语义产生的每个 $P_i$ 的后继节点来构建最小正确CFG，特别注意 $P_4$ 处的 `break` 和 $P_6$ 处的 `continue`。指出如果不建模 `break` 和 `continue` 而对代码进行朴素线性化，哪些为保持正确性所必需的控制流边将会缺失。\n2) 使用标准的活跃变量后向数据流分析，根据每个 $P_i$ 处的语句计算块级的 $USE$ 和 $DEF$ 集合，在正确的CFG上计算所有 $i \\in \\{1,2,3,4,5,6,7,8\\}$ 的 live-in 和 live-out 集合 $IN[P_i]$ 和 $OUT[P_i]$，从出口 $P_8$ 之后没有活跃变量开始。\n3) 考虑一个忽略 $break$ 和 $continue$ 的非局部控制转移的朴素线性化模型：在这个朴素模型中，控制流从 $P_4$ 处的 `break` 顺序执行到 $P_5$，如同它是一个空操作；控制流从 $P_6$ 处的 `continue` 顺序执行到 $P_7$，如同它是一个空操作；所有其他控制转移保持与结构化代码中相同。在此朴素模型下，重新计算程序点 $P_6$（紧接在赋值语句 `a := a + 1` 之前）的 $IN[P_6]$。\n4) 设 $\\Delta$ 为朴素线性化模型与正确CFG在 $P_6$ 处的 live-in 集合大小之差，定义为 $\\Delta = |IN_{\\text{naive}}[P_6]| - |IN_{\\text{correct}}[P_6]|$。计算 $\\Delta$ 的精确整数值。无需四舍五入。将最终答案表示为一个没有任何单位的纯数字。",
            "solution": "首先对问题进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n- **变量**：标量整数 $a$、$b$、$c$ 和 $x$。\n- **程序点和语义**：\n    - $P_1$: 循环头，条件为 `a  b`。\n    - $P_2$: 赋值语句 `x := a + c`。\n    - $P_3$: 条件语句 `if (x > b)` 则跳转到 $P_4$，否则跳转到 $P_5$。\n    - $P_4$: 赋值语句 `c := c + 1`，然后 `if (c > a)` 则 `break`，否则顺序执行到 $P_5$。\n    - $P_5$: 条件语句 `if (x  c)` 则跳转到 $P_6$，否则跳转到 $P_7$。\n    - $P_6$: 赋值语句 `a := a + 1`，然后 `continue`。\n    - $P_7$: 赋值语句 `b := b - x`，然后循环回到 $P_1$。\n    - $P_8$: 循环后执行 `return a + c`。\n- **活性定义**：如果从某个程序点存在一条路径，在该路径上一个变量被使用前没有被该变量的重定义所拦截，则该变量在该程序点是活跃的。\n- **建模**：一个控制流图（CFG），节点为 $P_1, \\dots, P_8$。$P_8$ 处的语句 `return a + c` 构成了对变量 $a$ 和 $c$ 的一次使用。\n- **朴素模型定义**：一个修改后的CFG，其中 $P_4$ 处的 `break` 被视为顺序执行到 $P_5$，$P_6$ 处的 `continue` 被视为顺序执行到 $P_7$。\n- **目标**：计算 $\\Delta = |IN_{\\text{naive}}[P_6]| - |IN_{\\text{correct}}[P_6]|$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在编译器理论原理，特别是静态程序分析和数据流分析方面有充分的依据。CFG、活性、`break` 和 `continue` 的概念在计算机科学中是标准的且有正式定义。\n- **适定性**：该问题是自包含的，提供了构建CFG和执行分析所需的所有必要信息。任务是具体的，并导向一个唯一的数值结果。\n- **客观性**：语言精确且技术性强，没有主观性。\n\n### 步骤 3：结论与行动\n该问题被判定为 **有效**。这是一个标准的、定义明确的程序分析问题。现在开始求解过程。\n\n### 任务 1：构建正确的控制流图 (CFG)\n\nCFG 是一个有向图 $G = (N, E)$，其中节点 $N = \\{P_1, P_2, \\dots, P_8\\}$ 是程序点（被视作基本块），边 $E$ 代表控制流。每个节点的后继节点由程序语义确定。\n\n- $P_1$ (`while (a  b)`)：如果条件为真，控制转移到 $P_2$ 处的循环体。如果为假，循环终止，控制转移到循环后的语句 $P_8$。\n  - $Succ(P_1) = \\{P_2, P_8\\}$\n- $P_2$ (`x := a + c`)：无条件顺序执行到 $P_3$。\n  - $Succ(P_2) = \\{P_3\\}$\n- $P_3$ (`if (x > b)`)：条件分支到 $P_4$ 或 $P_5$。\n  - $Succ(P_3) = \\{P_4, P_5\\}$\n- $P_4$ (`c := c + 1; if (c > a) break;`)：如果条件 `c > a` 为真，`break` 语句将控制转移到 $P_8$。否则，顺序执行到 $P_5$。\n  - $Succ(P_4) = \\{P_5, P_8\\}$\n- $P_5$ (`if (x  c)`)：条件分支到 $P_6$ 或 $P_7$。\n  - $Succ(P_5) = \\{P_6, P_7\\}$\n- $P_6$ (`a := a + 1; continue;`)：`continue` 语句将控制转移到 $P_1$ 处的循环头。\n  - $Succ(P_6) = \\{P_1\\}$\n- $P_7$ (`b := b - x`)：顺序执行到循环体末尾，这会隐式地将控制转移回 $P_1$ 处的循环头。\n  - $Succ(P_7) = \\{P_1\\}$\n- $P_8$ (`return a + c`)：这是过程的出口块。它没有后继节点。\n  - $Succ(P_8) = \\emptyset$\n\n在朴素线性化中会缺失的控制流边是那些非局部转移：\n1.  由于 `break` 语句产生的边 $P_4 \\rightarrow P_8$。朴素模型会错误地假设从 $P_4$ 顺序执行到 $P_5$。\n2.  由于 `continue` 语句产生的边 $P_6 \\rightarrow P_1$。朴素模型会错误地假设从 $P_6$ 顺序执行到 $P_7$。\n\n### 任务 2：在正确的 CFG 上进行活跃变量分析\n\n活性是一个后向数据流分析问题。对于一个基本块 $B$，相关方程如下：\n$$OUT[B] = \\bigcup_{S \\in Succ(B)} IN[S]$$\n$$IN[B] = USE[B] \\cup (OUT[B] \\setminus DEF[B])$$\n\n首先，我们根据每个块 $P_i$ 中读取和写入的变量来定义 $USE$ 和 $DEF$ 集合。\n- $USE[P_1] = \\{a, b\\}, DEF[P_1] = \\emptyset$\n- $USE[P_2] = \\{a, c\\}, DEF[P_2] = \\{x\\}$\n- $USE[P_3] = \\{x, b\\}, DEF[P_3] = \\emptyset$\n- $USE[P_4] = \\{a, c\\}, DEF[P_4] = \\{c\\}$ (在 $c+1$ 中对 $c$ 的读取发生在写入之前)\n- $USE[P_5] = \\{x, c\\}, DEF[P_5] = \\emptyset$\n- $USE[P_6] = \\{a\\}, DEF[P_6] = \\{a\\}$\n- $USE[P_7] = \\{b, x\\}, DEF[P_7] = \\{b\\}$\n- $USE[P_8] = \\{a, c\\}, DEF[P_8] = \\emptyset$\n\n我们初始化所有 $i \\in \\{1, \\dots, 8\\}$ 的 $IN[P_i] = \\emptyset$，并迭代直到达到不动点。$OUT[P_8]$ 始终为 $\\emptyset$。\n\n**迭代 1：**\n- $IN[P_8] = USE[P_8] \\cup (OUT[P_8] \\setminus DEF[P_8]) = \\{a, c\\}$\n- $OUT[P_7] = IN[P_1] = \\emptyset$\n- $IN[P_7] = USE[P_7] \\cup (OUT[P_7] \\setminus DEF[P_7]) = \\{b, x\\} \\cup (\\emptyset \\setminus \\{b\\}) = \\{x\\}$\n- $OUT[P_6] = IN[P_1] = \\emptyset$\n- $IN[P_6] = USE[P_6] \\cup (OUT[P_6] \\setminus DEF[P_6]) = \\{a\\} \\cup (\\emptyset \\setminus \\{a\\}) = \\emptyset$\n- $OUT[P_5] = IN[P_6] \\cup IN[P_7] = \\emptyset \\cup \\{x\\} = \\{x\\}$\n- $IN[P_5] = USE[P_5] \\cup (OUT[P_5] \\setminus DEF[P_5]) = \\{x, c\\} \\cup (\\{x\\} \\setminus \\emptyset) = \\{x, c\\}$\n- $OUT[P_4] = IN[P_5] \\cup IN[P_8] = \\{x, c\\} \\cup \\{a, c\\} = \\{a, c, x\\}$\n- $IN[P_4] = USE[P_4] \\cup (OUT[P_4] \\setminus DEF[P_4]) = \\{a, c\\} \\cup (\\{a, c, x\\} \\setminus \\{c\\}) = \\{a, c, x\\}$\n- $OUT[P_3] = IN[P_4] \\cup IN[P_5] = \\{a, c, x\\} \\cup \\{x, c\\} = \\{a, c, x\\}$\n- $IN[P_3] = USE[P_3] \\cup (OUT[P_3] \\setminus DEF[P_3]) = \\{x, b\\} \\cup (\\{a, c, x\\} \\setminus \\emptyset) = \\{a, b, c, x\\}$\n- $OUT[P_2] = IN[P_3] = \\{a, b, c, x\\}$\n- $IN[P_2] = USE[P_2] \\cup (OUT[P_2] \\setminus DEF[P_2]) = \\{a, c\\} \\cup (\\{a, b, c, x\\} \\setminus \\{x\\}) = \\{a, b, c\\}$\n- $OUT[P_1] = IN[P_2] \\cup IN[P_8] = \\{a, b, c\\} \\cup \\{a, c\\} = \\{a, b, c\\}$\n- $IN[P_1] = USE[P_1] \\cup (OUT[P_1] \\setminus DEF[P_1]) = \\{a, b\\} \\cup (\\{a, b, c\\} \\setminus \\emptyset) = \\{a, b, c\\}$\n\n**迭代 2：**\n- $IN[P_1]$ 从 $\\emptyset$ 变为 $\\{a, b, c\\}$。这将向后传播。\n- $OUT[P_7] = IN[P_1] = \\{a, b, c\\}$\n- $IN[P_7] = \\{b, x\\} \\cup (\\{a, b, c\\} \\setminus \\{b\\}) = \\{b, x\\} \\cup \\{a, c\\} = \\{a, b, c, x\\}$\n- $OUT[P_6] = IN[P_1] = \\{a, b, c\\}$\n- $IN[P_6] = \\{a\\} \\cup (\\{a, b, c\\} \\setminus \\{a\\}) = \\{a\\} \\cup \\{b, c\\} = \\{a, b, c\\}$\n- 其余集合也会更新，但我们已经找到了正确CFG所需的值。我们来验证一下收敛性。\n- $OUT[P_5] = IN[P_6] \\cup IN[P_7] = \\{a, b, c\\} \\cup \\{a, b, c, x\\} = \\{a, b, c, x\\}$\n- $IN[P_5] = \\{x, c\\} \\cup (\\{a, b, c, x\\} \\setminus \\emptyset) = \\{a, b, c, x\\}$\n- $OUT[P_4] = IN[P_5] \\cup IN[P_8] = \\{a, b, c, x\\} \\cup \\{a, c\\} = \\{a, b, c, x\\}$\n- $IN[P_4] = \\{a, c\\} \\cup (\\{a, b, c, x\\} \\setminus \\{c\\}) = \\{a, b, c, x\\}$\n- $OUT[P_3] = IN[P_4] \\cup IN[P_5] = \\{a, b, c, x\\}$\n- $IN[P_3] = \\{x, b\\} \\cup (\\{a, b, c, x\\} \\setminus \\emptyset) = \\{a, b, c, x\\}$\n- $OUT[P_2] = IN[P_3] = \\{a, b, c, x\\}$\n- $IN[P_2] = \\{a, c\\} \\cup (\\{a, b, c, x\\} \\setminus \\{x\\}) = \\{a, b, c\\}$\n- $OUT[P_1] = IN[P_2] \\cup IN[P_8] = \\{a, b, c\\} \\cup \\{a, c\\} = \\{a, b, c\\}$\n- $IN[P_1] = \\{a, b\\} \\cup (\\{a, b, c\\} \\setminus \\emptyset) = \\{a, b, c\\}$\n\n第三次迭代没有显示任何变化。过程已经收敛。对于正确的CFG，我们有：\n$$IN_{\\text{correct}}[P_6] = \\{a, b, c\\}$$\n$$|IN_{\\text{correct}}[P_6]| = 3$$\n\n### 任务 3：在朴素线性化模型上进行活跃变量分析\n\n在朴素模型中，`break` 和 `continue` 被忽略，导致顺序执行的控制流。后继节点列表发生变化：\n- $Succ_{\\text{naive}}(P_4) = \\{P_5\\}$ (到 $P_8$ 的边被移除)\n- $Succ_{\\text{naive}}(P_6) = \\{P_7\\}$ (到 $P_1$ 的边被替换为到 $P_7$ 的边)\n所有其他后继节点列表保持不变。$USE$ 和 $DEF$ 集合不变。\n\n我们重新计算活性集合。我们关心的是 $IN_{\\text{naive}}[P_6]$。\n\n**迭代 1 (朴素模型)：**\n- $IN[P_8] = \\{a, c\\}$\n- $OUT[P_7] = IN[P_1] = \\emptyset$\n- $IN[P_7] = \\{x\\}$\n- $OUT[P_6] = IN[P_7] = \\{x\\}$ (后继节点是 $P_7$)\n- $IN[P_6] = \\{a\\} \\cup (\\{x\\} \\setminus \\{a\\}) = \\{a, x\\}$\n- $OUT[P_5] = IN[P_6] \\cup IN[P_7] = \\{a, x\\} \\cup \\{x\\} = \\{a, x\\}$\n- $IN[P_5] = \\{x, c\\} \\cup (\\{a, x\\} \\setminus \\emptyset) = \\{a, c, x\\}$\n- $OUT[P_4] = IN[P_5] = \\{a, c, x\\}$ (后继节点只有 $P_5$)\n- $IN[P_4] = \\{a, c\\} \\cup (\\{a, c, x\\} \\setminus \\{c\\}) = \\{a, c, x\\}$\n- $OUT[P_3] = IN[P_4] \\cup IN[P_5] = \\{a, c, x\\}$\n- $IN[P_3] = \\{a, b, c, x\\}$\n- $OUT[P_2] = IN[P_3] = \\{a, b, c, x\\}$\n- $IN[P_2] = \\{a, b, c\\}$\n- $OUT[P_1] = IN[P_2] \\cup IN[P_8] = \\{a, b, c\\}$\n- $IN[P_1] = \\{a, b, c\\}$\n\n**迭代 2 (朴素模型)：**\n- $IN[P_1]$ 已经改变，所以我们传播新的信息。\n- $OUT[P_7] = IN[P_1] = \\{a, b, c\\}$\n- $IN[P_7] = \\{b, x\\} \\cup (\\{a, b, c\\} \\setminus \\{b\\}) = \\{a, b, c, x\\}$\n- $OUT[P_6] = IN[P_7] = \\{a, b, c, x\\}$ (这是与正确模型相比的关键变化)\n- $IN[P_6] = \\{a\\} \\cup (\\{a, b, c, x\\} \\setminus \\{a\\}) = \\{a\\} \\cup \\{b, c, x\\} = \\{a, b, c, x\\}$\n\n随后的迭代显示，随着其余集合的稳定，分析收敛。因此，对于朴素CFG：\n$$IN_{\\text{naive}}[P_6] = \\{a, b, c, x\\}$$\n$$|IN_{\\text{naive}}[P_6]| = 4$$\n\n$IN_{\\text{naive}}[P_6]$ 中额外的活跃变量 $x$ 是因为分析错误地假设存在一条从 $P_6$ 到 $P_7$ 的路径，其中 $x$ 被使用。这条路径在正确的CFG中不存在。\n\n### 任务 4：计算差值 $\\Delta$\n\n我们需要计算 $\\Delta = |IN_{\\text{naive}}[P_6]| - |IN_{\\text{correct}}[P_6]|$。\n使用前面任务的结果：\n$|IN_{\\text{naive}}[P_6]| = 4$\n$|IN_{\\text{correct}}[P_6]| = 3$\n\n因此，差值为：\n$$\\Delta = 4 - 3 = 1$$",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}