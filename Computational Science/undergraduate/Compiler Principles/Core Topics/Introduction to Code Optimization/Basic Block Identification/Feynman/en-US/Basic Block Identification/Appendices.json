{
    "hands_on_practices": [
        {
            "introduction": "Mastering basic block identification begins with the fundamentals. This first practice exercise provides a clear, sequential piece of three-address-like code, allowing you to focus on meticulously applying the three core rules for identifying leaders . By partitioning this simple sequence of conditional branches, you will build a solid foundation for analyzing more complex control flow structures.",
            "id": "3624020",
            "problem": "Consider the following straight-line, three-address-like program fragment with two adjacent conditional branches whose fall-through flows converge to the same computation. Labels indicate potential jump targets, and the program counter advances sequentially unless redirected by a jump. Each line number is shown explicitly:\n$1$: if a goto T1\n$2$: if b goto T2\n$3$: Lf: t := t + 1\n$4$: goto End\n$5$: T1: u := u * 2\n$6$: goto End\n$7$: T2: v := v - 3\n$8$: goto End\n$9$: End: return\nUsing only the foundational definitions in compiler theory that a Basic Block (BB) is a maximal sequence of instructions with a single entry and single exit, and that leaders of basic blocks are determined as follows:\n- The first instruction of the program is a leader.\n- Any instruction that is the target of a conditional or unconditional jump is a leader.\n- Any instruction that immediately follows a conditional or unconditional jump is a leader.\nPartition the program into a minimal set of basic blocks and then construct the corresponding Control Flow Graph (CFG) conceptually, where nodes are basic blocks and edges represent possible control transfers. Let $V$ denote the number of nodes in this CFG. What is the value of $V$? Provide the exact integer value; no rounding is needed and no units are required.",
            "solution": "The problem requires partitioning a given program fragment into basic blocks and determining the number of nodes, denoted by $V$, in the corresponding Control Flow Graph (CFG). The process is governed by the provided definitions of a basic block and the rules for identifying leaders.\n\nFirst, let us restate the program fragment with each instruction numbered:\n$1$: `if a goto T1`\n$2$: `if b goto T2`\n$3$: `Lf: t := t + 1`\n$4$: `goto End`\n$5$: `T1: u := u * 2`\n$6$: `goto End`\n$7$: `T2: v := v - 3`\n$8$: `goto End`\n$9$: `End: return`\n\nThe core of the task is to identify the \"leaders\" of the basic blocks using the three specified rules. A basic block begins with a leader and includes all instructions up to, but not including, the next leader.\n\nRule 1: The first instruction of the program is a leader.\nApplying this rule, instruction $1$ (`if a goto T1`) is a leader.\n\nRule 2: Any instruction that is the target of a conditional or unconditional jump is a leader.\nWe examine the jump instructions in the program:\n- Instruction $1$ (`if a goto T1`): The target is the instruction at label $T1$, which is instruction $5$. Therefore, instruction $5$ (`u := u * 2`) is a leader.\n- Instruction $2$ (`if b goto T2`): The target is the instruction at label $T2$, which is instruction $7$. Therefore, instruction $7$ (`v := v - 3`) is a leader.\n- Instructions $4$, $6$, and $8$ (`goto End`): The target is the instruction at label $End$, which is instruction $9$. Therefore, instruction $9$ (`return`) is a leader.\n\nRule 3: Any instruction that immediately follows a conditional or unconditional jump is a leader.\nWe examine the instructions immediately following each jump:\n- Instruction $1$ is a conditional jump. The instruction that immediately follows it is instruction $2$ (`if b goto T2`). Therefore, instruction $2$ is a leader.\n- Instruction $2$ is a conditional jump. The instruction that immediately follows it is instruction $3$ (`t := t + 1`). Therefore, instruction $3$ is a leader.\n- Instruction $4$ is an unconditional jump. The instruction that immediately follows it is instruction $5$. Instruction $5$ has already been identified as a leader.\n- Instruction $6$ is an unconditional jump. The instruction that immediately follows it is instruction $7$. Instruction $7$ has already been identified as a leader.\n- Instruction $8$ is an unconditional jump. The instruction that immediately follows it is instruction $9$. Instruction $9$ has already been identified as a leader.\n\nConsolidating our findings, the set of leader instructions is {instruction $1$, instruction $2$, instruction $3$, instruction $5$, instruction $7$, instruction $9$}.\n\nNow, we partition the program into basic blocks. Each basic block starts at a leader and extends to the instruction just before the next leader, or to the end of a block (which is typically a jump instruction).\n\n- **Basic Block 1 (BB1)**: Starts at leader $1$. Instruction $1$ is a conditional jump, which must be the last instruction in its basic block. The next instruction, $2$, is also a leader. Thus, BB1 contains only instruction $1$.\n  - BB1: {$1$: `if a goto T1`}\n\n- **Basic Block 2 (BB2)**: Starts at leader $2$. Instruction $2$ is a conditional jump. The next instruction, $3$, is also a leader. Thus, BB2 contains only instruction $2$.\n  - BB2: {$2$: `if b goto T2`}\n\n- **Basic Block 3 (BB3)**: Starts at leader $3$. The block includes instruction $3$ (`t := t + 1`) and continues until the next leader (instruction $5$) or a jump. Instruction $4$ (`goto End`) is a jump. Thus, the block consists of instructions $3$ and $4$.\n  - BB3: {$3$: `t := t + 1`, $4$: `goto End`}\n\n- **Basic Block 4 (BB4)**: Starts at leader $5$. The block includes instruction $5$ (`u := u * 2`) and continues. Instruction $6$ (`goto End`) is a jump. The instruction following it, $7$, is a leader. Thus, the block consists of instructions $5$ and $6$.\n  - BB4: {$5$: `u := u * 2`, $6$: `goto End`}\n\n- **Basic Block 5 (BB5)**: Starts at leader $7$. The block includes instruction $7$ (`v := v - 3`) and continues. Instruction $8$ (`goto End`) is a jump. The instruction following it, $9$, is a leader. Thus, the block consists of instructions $7$ and $8$.\n  - BB5: {$7$: `v := v - 3`, $8$: `goto End`}\n\n- **Basic Block 6 (BB6)**: Starts at leader $9$. This block contains only instruction $9$ (`return`), as it is the last instruction in the program fragment.\n  - BB6: {$9$: `return`}\n\nBy partitioning the program according to the rules, we have identified $6$ distinct basic blocks. In a Control Flow Graph (CFG), each basic block corresponds to a single node. Therefore, the number of nodes $V$ in the CFG is equal to the number of basic blocks.\n\nThe number of basic blocks is $6$.\nHence, the value of $V$ is $6$.",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "Moving beyond raw instructions, this exercise connects basic block partitioning to the semantics of high-level programming languages. You will explore how a seemingly minor choice—using a bitwise AND (`&`) versus a logical AND (`&&`)—creates a profoundly different Control Flow Graph (CFG) due to short-circuit evaluation . This practice is key to understanding how language features are translated by a compiler and how those translations open up different opportunities for optimization.",
            "id": "3624102",
            "problem": "Consider a C-like language that follows the conventional semantics for logical and bitwise operators. The program fragment below is written in two variants, identical except for the operator used in the conditional. The functions $f()$, $g()$, and $h(x)$ return integers; they may have side effects but do not themselves branch or throw exceptions. Assume a standard construction of a Control Flow Graph (CFG), where nodes are Basic Blocks (BB). A Basic Block (BB) is a maximal sequence of instructions with a single entry and a single exit, and control can only enter at the beginning and leave at the end; branching and jumping occur only at the end of a basic block. The Control Flow Graph (CFG) has directed edges representing possible control transfers between basic blocks. The conditional in the statement uses either logical AND $a \\,\\&\\&\\, b$ (which short-circuits) or bitwise AND $a \\,\\&\\, b$ (which evaluates both operands without short-circuiting). The fragment is:\n\n- Initialize $x := 0$.\n- If $\\Phi$ then assign $x := 1$, else assign $x := 2$.\n- Assign $y := h(x)$ and then terminate (no further statements).\n\nVariant 1 uses $\\Phi \\equiv (f() \\,\\&\\&\\, g())$. Variant 2 uses $\\Phi \\equiv (f() \\,\\&\\, g())$.\n\nStarting from the definitions above and the conventional semantics of `&&` and `&` in C-like languages, determine the number of Basic Blocks (BB) in the Control Flow Graph (CFG) for each variant, under the standard leader-based partitioning: the first statement is a leader, any target of a branch is a leader, and any statement immediately following a branch is a leader. Ignore exceptional control flow such as interrupts or asynchronous signals, and treat function calls $f()$, $g()$, and $h(x)$ as single instructions that do not branch.\n\nWhich option correctly gives the pair $(\\text{BB count for } (f() \\,\\&\\, g()), \\text{ BB count for } (f() \\,\\&\\&\\, g()))$?\n\nA. $(4, 5)$\nB. $(5, 4)$\nC. $(4, 4)$\nD. $(5, 5)$",
            "solution": "The problem requires us to determine the number of Basic Blocks (BBs) for two code variants: one using a bitwise AND (`&`) and one using a logical AND (`&&`). We apply the standard rules for identifying leaders to a conceptual instruction sequence for each variant.\n\n**Variant with Bitwise AND (`f() & g()`)**\n\nThe bitwise AND operator `&` does not short-circuit, so both `f()` and `g()` are always evaluated. The conceptual instruction sequence is:\n1. `x := 0`\n2. `t1 := f()`\n3. `t2 := g()`\n4. `t3 := t1 & t2`\n5. `if t3 == 0 goto L_ELSE` (Branch)\n6. `x := 1`\n7. `goto L_END` (Branch)\n8. `L_ELSE: x := 2`\n9. `L_END: y := h(x)`\n\nLeaders are identified as follows:\n- Instruction 1 (first instruction).\n- Instruction 6 (follows branch at 5).\n- Instruction 8 (target of branch at 5).\n- Instruction 9 (target of branch at 7).\n\nThis gives four leaders ({1, 6, 8, 9}), which define **4 basic blocks**:\n- BB1: {1, 2, 3, 4, 5}\n- BB2: {6, 7}\n- BB3: {8}\n- BB4: {9}\n\n**Variant with Logical AND (`f() && g()`)**\n\nThe logical AND operator `&&` short-circuits. If `f()` is false, `g()` is not evaluated. This introduces an extra branch.\n1. `x := 0`\n2. `t1 := f()`\n3. `if t1 == 0 goto L_ELSE` (Short-circuit branch)\n4. `t2 := g()`\n5. `if t2 == 0 goto L_ELSE` (Second part of condition)\n6. `x := 1`\n7. `goto L_END` (Branch)\n8. `L_ELSE: x := 2`\n9. `L_END: y := h(x)`\n\nLeaders are identified as follows:\n- Instruction 1 (first instruction).\n- Instruction 4 (follows branch at 3).\n- Instruction 6 (follows branch at 5).\n- Instruction 8 (target of branches at 3 and 5).\n- Instruction 9 (target of branch at 7).\n\nThis gives five leaders ({1, 4, 6, 8, 9}), which define **5 basic blocks**:\n- BB1: {1, 2, 3}\n- BB2: {4, 5}\n- BB3: {6, 7}\n- BB4: {8}\n- BB5: {9}\n\nThe question asks for the pair `(BB count for (f() & g()), BB count for (f() && g()))`. Based on our analysis, this pair is (4, 5). This corresponds to option A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Now, let's tackle a more complex and realistic control flow structure: the `switch` statement. This exercise challenges you to apply your knowledge to a scenario involving fall-through cases, `break` statements, a `default` path, and even a `goto` that jumps out of the switch entirely . Deconstructing this intricate example will solidify your understanding of how to identify leaders and basic blocks in even the most convoluted code.",
            "id": "3624092",
            "problem": "Consider the following C-like function that uses a switch statement with fall-through cases, a default, and a case that jumps to a label outside the switch. Your task is to identify basic blocks and compute how many basic blocks the resulting control flow graph contains.\n\nUse the following fundamental base:\n- A basic block is a maximal sequence of instructions with a single entry and a single exit, with no possibility of branching into or out of the middle of the sequence.\n- Leaders are determined by the standard rules: the first instruction in the program is a leader; any instruction that is the target of a jump (including each case and default label of a switch, and any explicit label such as a goto target) is a leader; any instruction immediately following a jump (such as a goto, break, return, or a switch dispatch) is a leader.\n- For a switch, treat each case and the default as possible targets of the multiway branch. Adjacent labels that precede the same first instruction denote multiple entries into the same basic block. A break inside a switch transfers control to the first instruction following the switch, which is therefore a leader.\n\nAnalyze the following function:\n\n```c\nvoid f(int x, int *p) {\n  int y = 0;\n  switch (x) {\n    case 0:\n      y = y + 1;\n      /* fall-through */\n    case 1:\n      *p = y;\n      goto Lout;\n    case 2:\n      y = y + 2;\n      break;\n    case 3:\n    case 4:\n      y = y + x;\n      /* fall-through to default */\n    default:\n      y = -y;\n      if (x > 0) break;\n      y = y + 1;\n      /* no break: falls out of switch */\n  }\n  y = y * 2;\nLout:\n  y = y - 1;\n}\n```\n\nInstructions:\n- Apply the definitions above to identify leaders and form basic blocks.\n- Pay close attention to fall-through behavior, both between cases and from the default to after the switch, and to the jump to $\\mathrm{Lout}$ outside the switch.\n- Then compute the total number of basic blocks in the resulting Control Flow Graph (CFG). Express your final answer as a single integer. No rounding is required and no units are needed.",
            "solution": "The problem requires us to determine the number of basic blocks in the control flow graph (CFG) for a given C-like function. The process involves two main steps: identifying leader instructions and then partitioning the instruction sequence into basic blocks based on these leaders. A basic block begins with a leader and includes all subsequent instructions up to, but not including, the next leader, or up to the end of a jump instruction.\n\nThe rules for identifying leaders are as follows:\n1.  The first instruction in the function is a leader.\n2.  Any instruction that is the target of a jump is a leader.\n3.  Any instruction that immediately follows a jump instruction is a leader.\n\nLet us analyze the provided function and identify all leaders by systematically applying these rules. For clarity, we can think of the function's instructions as a linearized sequence.\n\n1.  **`int y = 0;` is a leader.**\n    This is the first instruction of the function (Rule 1).\n\n2.  **`y = y + 1;` (following `case 0:`) is a leader.**\n    This instruction is the target of the `switch` statement for `case 0`. `case` labels mark the targets of the multi-way `switch` jump (Rule 2).\n\n3.  **`*p = y;` (following `case 1:`) is a leader.**\n    This is the target for `case 1` of the `switch` statement (Rule 2).\n\n4.  **`y = y + 2;` (following `case 2:`) is a leader.**\n    This is the target for `case 2` of the `switch` statement (Rule 2).\n\n5.  **`y = y + x;` (following `case 3:` and `case 4:`) is a leader.**\n    This is the target for both `case 3` and `case 4` of the `switch` statement (Rule 2).\n\n6.  **`y = -y;` (following `default:`) is a leader.**\n    This is the target for the `default` case of the `switch` statement (Rule 2).\n\n7.  **`y = y * 2;` is a leader.**\n    This instruction is the target of the `break;` statements (from `case 2` and from the conditional `if`). A `break` inside a `switch` jumps to the instruction immediately following the `switch` block. Therefore, this instruction is a jump target (Rule 2).\n\n8.  **`y = y - 1;` (at label `Lout:`) is a leader.**\n    This instruction is the target of the `goto Lout;` statement (Rule 2).\n\n9.  **`y = y + 1;` (following `if (x > 0) break;`) is a leader.**\n    This instruction immediately follows the conditional jump `if (x > 0) break;`. According to Rule 3, the instruction following a jump is a leader.\n\nHaving identified all the leaders, we can now partition the code into basic blocks. Each block starts at a leader and ends just before the next leader or at a jump instruction.\n\n*   **Block 1**: Starts at `int y = 0;`. Contains this instruction and the `switch (x)` dispatch. It ends with the multi-way jump `switch`.\n\n*   **Block 2**: Starts at `y = y + 1;`. It contains only this instruction and falls through to the next block.\n\n*   **Block 3**: Starts at `*p = y;`. It contains this instruction and `goto Lout;`. It ends with the unconditional jump `goto`.\n\n*   **Block 4**: Starts at `y = y + 2;`. It contains this instruction and `break;`. It ends with the unconditional jump `break`.\n\n*   **Block 5**: Starts at `y = y + x;`. It contains only this instruction and falls through to the default block.\n\n*   **Block 6**: Starts at `y = -y;`. It contains this instruction and `if (x > 0) break;`. It ends with the conditional jump `if`.\n\n*   **Block 7**: Starts at `y = y + 1;`. It contains only this instruction and falls out of the switch to the next block.\n\n*   **Block 8**: Starts at `y = y * 2;`. It contains only this instruction and falls through to the next block.\n\n*   **Block 9**: Starts at `y = y - 1;`. It contains this instruction and ends with the implicit function return.\n\nBy counting the distinct leaders, which correspond to the start of each basic block, we find there are 9 leaders. This means the instruction sequence is partitioned into 9 basic blocks. Therefore, the total number of basic blocks is 9.",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}