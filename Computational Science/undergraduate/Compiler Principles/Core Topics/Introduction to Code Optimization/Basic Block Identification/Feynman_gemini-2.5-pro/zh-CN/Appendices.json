{
    "hands_on_practices": [
        {
            "introduction": "掌握基本块划分的第一步是熟练应用首领（leader）的识别规则。这个练习提供了一段简单的三地址码，包含几个直接的条件和无条件跳转。通过这个练习 ()，你将实践如何系统地应用首领识别的三条核心规则，将线性指令序列转化为结构化的基本块集合，这是构建控制流图（CFG）的基础。",
            "id": "3624020",
            "problem": "考虑以下直线式、类三地址程序片段，其中包含两个相邻的条件分支，其顺序执行流（fall-through flows）会汇合到同一个计算。标签指示了潜在的跳转目标，程序计数器会顺序前进，除非被跳转指令重定向。每行的行号已明确标出：\n1: if a goto T1\n2: if b goto T2\n3: Lf: t := t + 1\n4: goto End\n5: T1: u := u * 2\n6: goto End\n7: T2: v := v - 3\n8: goto End\n9: End: return\n仅使用编译器理论中的基本定义，即基本块（BB）是具有单一入口和单一出口的最大指令序列，并且基本块的首指令（leader）按以下方式确定：\n- 程序的第一条指令是首指令。\n- 任何作为条件或无条件跳转目标的指令是首指令。\n- 任何紧跟在条件或无条件跳转之后的指令是首指令。\n将该程序划分为一个最小的基本块集合，然后从概念上构建相应的控制流图（CFG），其中节点是基本块，边代表可能的控制转移。令 $V$ 表示此CFG中的节点数。$V$ 的值是多少？提供精确的整数值；无需四舍五入，也无需单位。",
            "solution": "该问题要求将给定的程序片段划分为基本块，并确定相应控制流图（CFG）中的节点数，用 $V$ 表示。这个过程遵循所提供的基本块定义和用于识别首指令的规则。\n\n首先，让我们重申带有编号的程序片段：\n1: `if a goto T1`\n2: `if b goto T2`\n3: `Lf: t := t + 1`\n4: `goto End`\n5: `T1: u := u * 2`\n6: `goto End`\n7: `T2: v := v - 3`\n8: `goto End`\n9: `End: return`\n\n任务的核心是使用三个指定规则来识别基本块的“首指令”。一个基本块从一个首指令开始，并包含直到（但不包括）下一个首指令之前的所有指令。\n\n规则1：程序的第一条指令是首指令。\n应用此规则，指令 $1$ (`if a goto T1`) 是一个首指令。\n\n规则2：任何作为条件或无条件跳转目标的指令是首指令。\n我们检查程序中的跳转指令：\n- 指令 $1$ (`if a goto T1`)：目标是标签 `T1` 处的指令，即指令 $5$。因此，指令 $5$ (`u := u * 2`) 是一个首指令。\n- 指令 $2$ (`if b goto T2`)：目标是标签 `T2` 处的指令，即指令 $7$。因此，指令 $7$ (`v := v - 3`) 是一个首指令。\n- 指令 $4$、 $6$ 和 $8$ (`goto End`)：目标是标签 `End` 处的指令，即指令 $9$。因此，指令 $9$ (`return`) 是一个首指令。\n\n规则3：任何紧跟在条件或无条件跳转之后的指令是首指令。\n我们检查紧跟在每个跳转指令之后的指令：\n- 指令 $1$ 是一个条件跳转。紧随其后的指令是指令 $2$ (`if b goto T2`)。因此，指令 $2$ 是一个首指令。\n- 指令 $2$ 是一个条件跳转。紧随其后的指令是指令 $3$ (`t := t + 1`)。因此，指令 $3$ 是一个首指令。\n- 指令 $4$ 是一个无条件跳转。紧随其后的指令是指令 $5$。指令 $5$ 已被识别为首指令。\n- 指令 $6$ 是一个无条件跳转。紧随其后的指令是指令 $7$。指令 $7$ 已被识别为首指令。\n- 指令 $8$ 是一个无条件跳转。紧随其后的指令是指令 $9$。指令 $9$ 已被识别为首指令。\n\n综合我们的发现，首指令的集合是 {指令 $1$, 指令 $2$, 指令 $3$, 指令 $5$, 指令 $7$, 指令 $9$}。\n\n现在，我们将程序划分为基本块。每个基本块从一个首指令开始，并延伸到下一个首指令之前的指令，或者延伸到一个块的末尾（通常是一个跳转指令）。\n\n- **基本块1 (BB1)**：从首指令 $1$ 开始。指令 $1$ 是一个条件跳转，它必须是其基本块中的最后一条指令。下一条指令 $2$ 也是一个首指令。因此，BB1 只包含指令 $1$。\n  - BB1: {1: `if a goto T1`}\n\n- **基本块2 (BB2)**：从首指令 $2$ 开始。指令 $2$ 是一个条件跳转。下一条指令 $3$ 也是一个首指令。因此，BB2 只包含指令 $2$。\n  - BB2: {2: `if b goto T2`}\n\n- **基本块3 (BB3)**：从首指令 $3$ 开始。该块包含指令 $3$ (`t := t + 1`) 并继续，直到遇到下一个首指令（指令 $5$）或一个跳转。指令 $4$ (`goto End`) 是一个跳转。因此，该块由指令 $3$ 和 $4$ 组成。\n  - BB3: {3: `t := t + 1`, 4: `goto End`}\n\n- **基本块4 (BB4)**：从首指令 $5$ 开始。该块包含指令 $5$ (`u := u * 2`) 并继续。指令 $6$ (`goto End`) 是一个跳转。其后的指令 $7$ 是一个首指令。因此，该块由指令 $5$ 和 $6$ 组成。\n  - BB4: {5: `u := u * 2`, 6: `goto End`}\n\n- **基本块5 (BB5)**：从首指令 $7$ 开始。该块包含指令 $7$ (`v := v - 3`) 并继续。指令 $8$ (`goto End`) 是一个跳转。其后的指令 $9$ 是一个首指令。因此，该块由指令 $7$ 和 $8$ 组成。\n  - BB5: {7: `v := v - 3`, 8: `goto End`}\n\n- **基本块6 (BB6)**：从首指令 $9$ 开始。此块仅包含指令 $9$ (`return`)，因为它是程序片段中的最后一条指令。\n  - BB6: {9: `return`}\n\n通过根据规则划分程序，我们确定了 $6$ 个不同的基本块。在控制流图（CFG）中，每个基本块对应一个节点。因此，CFG 中的节点数 $V$ 等于基本块的数量。\n\n基本块的数量是 $6$。\n因此，$V$ 的值是 $6$。",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "编译器的任务不仅是处理指令，还要精确地反映源语言的语义。本练习通过对比C语言中的位与运算符 `` 和逻辑与运算符 ``，揭示了短路求值（short-circuit evaluation）如何从根本上改变程序的控制流。这个思想实验 () 将帮助你理解，一个高级语言中的细微差别如何在底层表示中产生不同的基本块结构。",
            "id": "3624102",
            "problem": "考虑一种遵循逻辑和位运算符常规语义的类C语言。下面的程序片段有两个变体，除了条件语句中使用的运算符不同外，其他部分完全相同。函数 `f()`、`g()` 和 `h(x)` 返回整数；它们可能有副作用，但本身不会产生分支或抛出异常。假设采用标准的控制流图 (CFG) 构建方法，其中节点为基本块 (BB)。基本块 (BB) 是一个指令的最大序列，具有单一入口和单一出口，控制流只能从开头进入并从末尾离开；分支和跳转仅在基本块的末尾发生。控制流图 (CFG) 具有有向边，表示基本块之间可能的控制转移。该语句中的条件使用逻辑与 `a  b`（会短路）或位与 `a  b`（不会短路，对两个操作数都进行求值）。该片段是：\n\n- 初始化 `x := 0`。\n- 如果 $\\Phi$ 为真，则赋值 `x := 1`，否则赋值 `x := 2`。\n- 赋值 `y := h(x)`，然后终止（没有后续语句）。\n\n变体1使用位与 ``: $\\Phi_1 \\equiv (f() \\ \\ \\ g())$。变体2使用逻辑与 ``: $\\Phi_2 \\equiv (f() \\ \\\\ \\ g())$。\n\n从以上定义和类C语言中 `` 与 `` 的常规语义出发，在标准的基于首指令的划分方法下，确定每个变体的控制流图(CFG)中的基本块(BB)数量：第一条语句是首指令，任何分支的目标是首指令，以及任何紧跟在分支指令后的语句是首指令。忽略例如中断或异步信号之类的异常控制流，并将函数调用 `f()`、`g()` 和 `h(x)` 视为不产生分支的单条指令。\n\n哪个选项正确地给出了数对 $(\\text{`f()  g()` 的 BB 数量}, \\text{`f()  g()` 的 BB 数量})$？\n\nA. (4, 5)\n\nB. (5, 4)\n\nC. (4, 4)\n\nD. (5, 5)",
            "solution": "题干经验证是自洽的，其科学基础在于编译原理，并且问题定义明确。所用术语均为标准术语，目标清晰。我们可以开始推导。\n\n问题的核心在于将高级代码结构转换为基础指令序列（类似于三地址码），并应用给定的规则来识别“首指令”，这些首指令标记了新基本块(BB)的开始。基本块是顺序执行代码的最大序列。\n\n识别首指令的规则如下：\n1. 程序中的第一条语句是首指令。\n2. 作为分支指令目标的任何语句是首指令。\n3. 紧跟在分支指令后的任何语句是首指令。\n\n让我们分析表达式 $\\Phi$ 的两个变体。\n\n**情况1: `(f()  g())` (位与)**\n\n在类C语言中，位与运算符 `` 不具有短路行为。两个操作数 `f()` 和 `g()` 总是会被求值。控制流可以由以下指令序列表示：\n\n1. `x := 0`\n2. `t_1 := f()`\n3. `t_2 := g()`\n4. `t_3 := t_1  t_2`\n5. `if t_3 == 0 goto L_ELSE` (条件分支)\n6. `x := 1`\n7. `goto L_END` (无条件分支)\n8. `L_ELSE: x := 2`\n9. `L_END: y := h(x)`\n\n现在，我们应用首指令识别规则：\n- 指令 $1$ 根据规则 $1$ 是首指令。\n- 指令 $8$ (标签为 `L_ELSE`) 根据规则 $2$ 是首指令，因为它是指令 $5$ 处分支的目标。\n- 指令 $9$ (标签为 `L_END`) 根据规则 $2$ 是首指令，因为它是指令 $7$ 处分支的目标。\n- 指令 $6$ 根据规则 $3$ 是首指令，因为它紧跟在指令 $5$ 的条件分支之后。\n\n因此，首指令的集合是指令 {1, 6, 8, 9}。一个基本块从一个首指令开始，延伸到下一个首指令之前的指令，或者到一个分支指令的末尾。\n\n- **BB1**: 从首指令 $1$ 开始。它包含指令 $1, 2, 3, 4, 5$。它以一个条件分支结束。\n- **BB2**: 从首指令 $6$ 开始。它包含指令 $6, 7$。它以一个无条件分支结束。\n- **BB3**: 从首指令 $8$ 开始。它只包含指令 $8$。下一条指令 $9$ 是一个首指令，所以这个块在这里结束，控制流顺序执行到下一个块。\n- **BB4**: 从首指令 $9$ 开始。它只包含指令 $9$。程序片段在此结束。\n\n因此，对于表达式 `(f()  g())`，总共有 $4$ 个基本块。\n\n**情况2: `(f()  g())` (逻辑与)**\n\n逻辑与运算符 `` 表现出短路行为。如果 `f()` 求值为假（值为 $0$），则第二个操作数 `g()` 不会被求值，控制流直接跳转到条件语句的 `else` 部分。与位与的情况相比，这引入了一个额外的分支。\n\n控制流可以表示为：\n\n1. `x := 0`\n2. `t_1 := f()`\n3. `if t_1 == 0 goto L_ELSE` (短路条件分支)\n4. `t_2 := g()`\n5. `if t_2 == 0 goto L_ELSE` (条件的第二部分)\n6. `x := 1`\n7. `goto L_END` (无条件分支)\n8. `L_ELSE: x := 2`\n9. `L_END: y := h(x)`\n\n应用首指令识别规则：\n- 指令 $1$ 根据规则 $1$ 是首指令。\n- 指令 $8$ (标签为 `L_ELSE`) 根据规则 $2$ 是首指令，因为它是指令 $3$ 和 $5$ 处分支的目标。\n- 指令 $9$ (标签为 `L_END`) 根据规则 $2$ 是首指令，因为它是指令 $7$ 处分支的目标。\n- 指令 $4$ 根据规则 $3$ 是首指令，因为它紧跟在指令 $3$ 的条件分支之后。\n- 指令 $6$ 根据规则 $3$ 是首指令，因为它紧跟在指令 $5$ 的条件分支之后。\n\n首指令的集合是 {1, 4, 6, 8, 9}。\n\n- **BB1**: 从首指令 $1$ 开始。它包含指令 $1, 2, 3$。它以一个条件分支结束。\n- **BB2**: 从首指令 $4$ 开始。它包含指令 $4, 5$。它以一个条件分支结束。\n- **BB3**: 从首指令 $6$ 开始。它包含指令 $6, 7$。它以一个无条件分支结束。\n- **BB4**: 从首指令 $8$ 开始。它只包含指令 $8$。\n- **BB5**: 从首指令 $9$ 开始。它只包含指令 $9$。\n\n因此，对于表达式 `(f()  g())`，总共有 $5$ 个基本块。短路求值引入了一个额外的分支，它将初始的求值块分割成了两个独立的基本块。\n\n问题要求的是数对 $(\\text{`f()  g()` 的 BB 数量}, \\text{`f()  g()` 的 BB 数量})$。根据我们的分析，这个数对是 $(4, 5)$。\n\n我们现在评估给定的选项：\n\nA. (4, 5): 这与我们推导出的结果相符。位与 `` 情况下的基本块数量为 $4$，逻辑与 `` 情况下的基本块数量为 $5$。**正确**。\n\nB. (5, 4): 这颠倒了两种情况的正确计数。**不正确**。\n\nC. (4, 4): 这个选项正确地识别了位与情况下的计数，但未能考虑到逻辑与的短路逻辑所创建的额外基本块。**不正确**。\n\nD. (5, 5): 这个选项正确地识别了逻辑与情况下的计数，但错误地高估了非短路位与情况下的块数。**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "真实世界的程序充满了复杂的控制结构，`switch` 语句就是其中一个典型的例子。这个练习将挑战你分析一个带有 `case` 穿透（fall-through）、`break`、`goto` 和 `default` 分支的 `switch` 语句。通过解决这个问题 ()，你将学会如何将识别首领的规则应用于多路跳转和各种出口点，从而掌握分析复杂代码流的技能。",
            "id": "3624092",
            "problem": "考虑以下这个类C函数，它使用了一个带有贯穿（fall-through）情形、一个 default 分支以及一个跳转到 switch 外部标签的 case 的 switch 语句。您的任务是识别基本块，并计算生成的控制流图包含多少个基本块。\n\n请使用以下基本原则：\n- 一个基本块是具有单一入口和单一出口的最大指令序列，序列中间不可能有分支转入或转出。\n- 首指令（Leaders）由标准规则确定：程序的第一条指令是首指令；任何作为跳转目标的指令（包括 switch 的每个 case 和 default 标签，以及任何显式标签如 goto 目标）是首指令；任何紧跟在跳转指令（例如 goto、break、return 或 switch 分派）之后的指令是首指令。\n- 对于 switch 语句，将每个 case 和 default 视为多路分支的可能目标。在同一条首指令之前的相邻标签表示进入同一个基本块的多个入口。switch 内部的 break 会将控制权转移到 switch 之后的第一条指令，因此该指令是一个首指令。\n\n分析以下函数：\n\n```c\nvoid f(int x, int *p) {\n  int y = 0;\n  switch (x) {\n    case 0:\n      y = y + 1;\n      /* fall-through */\n    case 1:\n      *p = y;\n      goto Lout;\n    case 2:\n      y = y + 2;\n      break;\n    case 3:\n    case 4:\n      y = y + x;\n      /* fall-through to default */\n    default:\n      y = -y;\n      if (x > 0) break;\n      y = y + 1;\n      /* no break: falls out of switch */\n  }\n  y = y * 2;\nLout:\n  y = y - 1;\n}\n```\n\n要求：\n- 应用上述定义来识别首指令并构成基本块。\n- 密切注意贯穿行为，包括 case 之间的贯穿、从 default 到 switch 之后的贯穿，以及跳转到 switch 外部的 `Lout` 的行为。\n- 然后计算生成的控制流图（CFG）中的基本块总数。将最终答案表示为单个整数。无需四舍五入，也无需单位。",
            "solution": "问题要求我们确定一个给定的类C函数在其控制流图（CFG）中的基本块数量。这个过程包含两个主要步骤：识别首指令，然后基于这些首指令将指令序列划分为基本块。一个基本块以一个首指令开始，并包含其后的所有指令，直到（但不包括）下一个首指令，或者直到一个跳转指令的末尾。\n\n识别首指令的规则如下：\n1.  函数中的第一条指令是首指令。\n2.  任何作为跳转目标的指令是首指令。\n3.  任何紧跟在跳转指令之后的指令是首指令。\n\n让我们通过系统地应用这些规则来分析所提供的函数并识别所有首指令。为清晰起见，我们将以线性序列的形式表示该函数的指令。\n\n函数代码如下：\n```c\nvoid f(int x, int *p) {\n  1: int y = 0;\n  2: switch (x) {\n     // case 0:\n  3:   y = y + 1;\n     // case 1:\n  4:   *p = y;\n  5:   goto Lout;\n     // case 2:\n  6:   y = y + 2;\n  7:   break;\n     // case 3:\n     // case 4:\n  8:   y = y + x;\n     // default:\n  9:   y = -y;\n 10:   if (x > 0) break;\n 11:   y = y + 1;\n 12: }\n 13: y = y * 2;\n     // Lout:\n 14: y = y - 1;\n 15: }\n```\n(注：为了分析，我们将指令概念性地编号，这与源代码行号不完全对应。)\n\n我们按如下方式识别首指令：\n\n1.  **指令 `int y = 0;` 是一个首指令。**\n    因为它是在函数的第一条指令（规则1）。这标志着第一个基本块的开始。\n\n2.  **指令 `y = y + 1;` （在 `case 0:` 之后）是一个首指令。**\n    该指令是 `switch` 语句中 `case 0` 的目标。`switch` 是一个多路跳转，`case` 标签标记了此跳转的目标（规则2）。\n\n3.  **指令 `*p = y;` （在 `case 1:` 之后）是一个首指令。**\n    这是 `switch` 语句中 `case 1` 的目标（规则2）。\n\n4.  **指令 `y = y + 2;` （在 `case 2:` 之后）是一个首指令。**\n    这是 `switch` 语句中 `case 2` 的目标（规则2）。\n\n5.  **指令 `y = y + x;` （在 `case 3:` 和 `case 4:` 之后）是一个首指令。**\n    这是 `switch` 语句中 `case 3` 和 `case 4` 共同的目标（规则2）。\n\n6.  **指令 `y = -y;` （在 `default:` 之后）是一个首指令。**\n    这是 `switch` 语句中 `default` 分支的目标（规则2）。\n\n7.  **指令 `y = y * 2;` 是一个首指令。**\n    该指令是 `break;` 语句（来自 `case 2` 和条件 `if`）的目标。`switch` 内部的 `break` 会跳转到紧跟在 `switch` 块之后的指令。因此，该指令是一个跳转目标（规则2）。\n\n8.  **指令 `y = y - 1;` （在标签 `Lout:` 处）是一个首指令。**\n    该指令是 `goto Lout;` 语句的目标（规则2）。\n\n9.  **指令 `y = y + 1;` （在 `if (x > 0) break;` 之后）是一个首指令。**\n    该指令紧跟在条件跳转 `if (x > 0) break;` 之后。根据规则3，跳转指令之后的指令是首指令。\n\n识别了所有首指令后，我们现在可以将代码划分为基本块。每个块从一个首指令开始，并在下一个首指令之前或在一个跳转指令处结束。\n\n*   **块 1**:\n    从 `int y = 0;` 开始。\n    包含: `int y = 0;`, `switch (x)`。\n    以多路跳转 `switch (x)` 结束。\n\n*   **块 2**:\n    从 `y = y + 1;` 开始。\n    包含: `y = y + 1;`。\n    通过贯穿到下一条指令结束，该指令是另一个首指令。\n\n*   **块 3**:\n    从 `*p = y;` 开始。\n    包含: `*p = y;`, `goto Lout;`。\n    以无条件跳转 `goto` 结束。\n\n*   **块 4**:\n    从 `y = y + 2;` 开始。\n    包含: `y = y + 2;`, `break;`。\n    以无条件跳转 `break` 结束。\n\n*   **块 5**:\n    从 `y = y + x;` 开始。\n    包含: `y = y + x;`。\n    通过贯穿到 `default` 分支结束，其第一条指令是另一个首指令。\n\n*   **块 6**:\n    从 `y = -y;` 开始。\n    包含: `y = -y;`, `if (x > 0) break;`。\n    以条件跳转 `if` 结束。\n\n*   **块 7**:\n    从 `y = y + 1;` （在 `if` 之后）开始。\n    包含: `y = y + 1;`。\n    通过贯穿出 `switch` 语句到下一条指令结束，该指令是另一个首指令。\n\n*   **块 8**:\n    从 `y = y * 2;` 开始。\n    包含: `y = y * 2;`。\n    通过贯穿到标签 `Lout` 处的指令结束，该指令是另一个首指令。\n\n*   **块 9**:\n    从 `y = y - 1;` 开始。\n    包含: `y = y - 1;`。\n    以函数末尾的隐式返回结束。\n\n通过计算不同的首指令，我们发现有 9 个首指令。这意味着指令序列被划分为 9 个基本块。\n这些首指令是：\n1. `int y = 0;`\n2. `y = y + 1;`\n3. `*p = y;`\n4. `y = y + 2;`\n5. `y = y + x;`\n6. `y = -y;`\n7. `y = y * 2;`\n8. `y = y - 1;`\n9. `y = y + 1;` (在 `if` 之后的那条)\n\n所有这些首指令都开始一个新的基本块。因此，基本块的总数为 9。",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}