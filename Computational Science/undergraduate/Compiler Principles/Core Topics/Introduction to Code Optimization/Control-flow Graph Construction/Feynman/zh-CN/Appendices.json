{
    "hands_on_practices": [
        {
            "introduction": "让我们从一个基本但至关重要的练习开始。这个练习将指导你为一个包含 `while` 循环和 `break` 语句的函数构建控制流图（CFG），这是编译器设计中的一项基本技能。通过这个过程，你不仅能掌握识别基本块和绘制控制流的方法，还能学会如何应用图论度量（如圈复杂度）来分析程序的复杂性。",
            "id": "3633677",
            "problem": "给定以下命令式程序片段，它计算一个类似阶乘的值，并在乘法将要溢出时提前中止循环。您必须显式地对控制流进行建模，并遵守以下约定。\n\n程序：\n输入：一个机器整数 $n$。\nif $n  0$ then\n    return $-1$\nfi\n$i := 1$\n$r := 1$\nwhile $i \\le n$ do\n    if $\\mathrm{Overflow}(r,i)$ then\n        break\n    fi\n    $r := r \\times i$\n    $i := i + 1$\nod\nreturn $r$\n\n构建控制流图（CFG）的约定：\n- 控制流图（CFG）是一个有向图，其节点是基本块，其边代表从一个块的末尾到另一个块的开头的可能控制转移。\n- 基本块是具有单一入口和单一出口的最大的直线式语句序列；它在任何分支、循环测试或跳转目标之前和之后结束。\n- 将所有返回（return）规范化到一个唯一的、特殊的出口块。任何提前返回必须首先赋予指定的返回值，然后分支到该唯一的出口块，由该出口块执行函数的返回操作。除了这种规范化之外，不要引入任何额外的控制结构。\n- 将谓词 $\\mathrm{Overflow}(r,i)$ 视为一个原子的布尔测试。break 语句将控制权转移到 while 循环紧接着的后面；在返回规范化的情况下，控制流接着会流向返回正确值的唯一出口块。\n- 条件语句恰好有两条出边，分别对应于真和假的结果。除了上面明确写出的内容外，不存在短路求值。\n\n任务：\n- 为给定程序构建满足上述约定的最小基本块 CFG。\n- 令 $N$ 表示 CFG 中的节点（基本块）数量，$E$ 表示有向边的数量，$P$ 表示 CFG 的底层无向图版本中的连通分量数量。\n- 仅使用这些图的量，确定 CFG 的圈复杂度 $M$。\n\n最终答案仅提供 $M$ 的数值。无需四舍五入。",
            "solution": "题目要求计算给定程序片段的控制流图（CFG）的圈复杂度 $M$。圈复杂度将使用公式 $M = E - N + 2P$ 进行计算，其中 $N$ 是节点（基本块）的数量，$E$ 是有向边的数量，$P$ 是图中连通分量的数量。\n\n首先，我们必须根据所提供的约定，通过将程序划分为基本块来构建 CFG。基本块是具有单一入口和单一出口的最大直线代码序列。一个新的基本块始于程序的开头、跳转或分支的目标处，或在分支指令之后。给定的约定要求将所有返回语句规范化到一个唯一的出口块。\n\n让我们为给定程序识别基本块：\n\n程序：\n```\n输入：一个机器整数 $n$。\nif $n  0$ then\n    return $-1$\nfi\n$i := 1$\n$r := 1$\nwhile $i \\le n$ do\n    if $\\mathrm{Overflow}(r,i)$ then\n        break\n    fi\n    $r := r \\times i$\n    $i := i + 1$\nod\nreturn $r$\n```\n\n1.  **块 B1**: 第一条指令是一个条件分支 `if $n  0$`，它本身构成了第一个基本块。这是 CFG 的入口点。\n    -   `B1: if $n  0$`\n\n2.  **块 B2**: 如果 `B1` 中的条件为真，程序应 `return $-1$`。根据返回规范化规则，这变成对一个返回值持有者（我们称之为 `ret_val`）的赋值，后跟一个到出口块的无条件跳转。赋值 `ret_val := -1` 构成了它自己的基本块。\n    -   `B2: ret_val := -1`\n\n3.  **块 B3**: 如果 `B1` 中的条件为假，控制流会转到初始化代码 `i := 1` 和 `r := 1`。这两个顺序赋值构成一个单一的基本块。\n    -   `B3: i := 1; r := 1`\n\n4.  **块 B4**: 初始化之后，控制流到达 `while` 循环。循环的条件 `while $i \\le n$` 作为一个条件分支，并形成一个新的基本块。它是循环体末尾的跳转目标，这加强了它作为块入口的状态。\n    -   `B4: if $i \\le n$`\n\n5.  **块 B5**: 如果 `B4` 中的循环条件为真，控制流进入循环体。第一条语句是另一个条件 `if $\\mathrm{Overflow}(r,i)$`，它形成一个新的基本块。\n    -   `B5: if $\\mathrm{Overflow}(r,i)$`\n\n6.  **块 B6**: 如果 `B5` 中的溢出条件为假，则执行语句 `r := r \\times i` 和 `i := i + 1`。这段顺序代码构成一个单一的基本块。在此块之后，控制流返回到 `B4` 中的循环条件检查。\n    -   `B6: r := r \\times i; i := i + 1`\n\n7.  **块 B7**: 循环终止后会到达此块。（来自 `B5` 的）`break` 语句和（来自 `B4` 的）循环条件失败都会将控制权转移到这里。指令是 `return $r$`，它规范化为赋值 `ret_val := r`。因为这个块是多个跳转的目标，所以它必须是一个独立的基本块。\n    -   `B7: ret_val := r`\n\n8.  **块 B8**: 这是约定所要求的唯一出口块。它是所有终止函数路径的跳转目标。在这个程序中，块 `B2` 和 `B7` 跳转到这个块。\n    -   `B8: return ret_val`\n\n我们已经识别出 $N = 8$ 个基本块。\n\n接下来，我们识别表示这些块之间控制流的有向边 ($E$)：\n-   `B1` 有两个后继：`B2`（如果 `$n  0$` 为真）和 `B3`（如果为假）。（2条边）\n-   `B2` 有一个后继：`B8`（无条件跳转到出口）。（1条边）\n-   `B3` 有一个后继：`B4`（无条件流向循环测试）。（1条边）\n-   `B4` 有两个后继：`B5`（如果 `$i \\le n$` 为真，进入循环）和 `B7`（如果为假，退出循环）。（2条边）\n-   `B5` 有两个后继：`B7`（如果 `$\\mathrm{Overflow}(r,i)$` 为真，`break` 到循环之后）和 `B6`（如果为假，继续循环体）。（2条边）\n-   `B6` 有一个后继：`B4`（无条件跳转到循环测试的开始处）。（1条边）\n-   `B7` 有一个后继：`B8`（无条件跳转到出口）。（1条边）\n-   `B8` 是终止块，没有后继。（0条边）\n\n将边的数量相加：$E = 2 + 1 + 1 + 2 + 2 + 1 + 1 = 10$。\n\n现在，我们确定连通分量的数量 $P$。单个非空过程的 CFG 是一个连通图，因为每个块都可以从入口块到达。在我们的构建中，`B1` 是入口块，所有其他块（`B2` 到 `B8`）都可以从 `B1` 到达。因此，该图有 $P = 1$ 个连通分量。\n\n最后，我们应用圈复杂度的公式：\n$M = E - N + 2P$\n代入我们找到的值：$N = 8$，$E = 10$，以及 $P = 1$。\n$M = 10 - 8 + 2(1) = 2 + 2 = 4$。\n\nCFG 的圈复杂度为 $4$。这个结果可以通过更简单的公式 $M = D + 1$ 进行交叉验证，其中 $D$ 是决策点的数量。该程序有 $3$ 个决策点：`if $n  0$`、`while $i \\le n$` 和 `if $\\mathrm{Overflow}(r,i)$`。这得出 $M = 3 + 1 = 4$，证实了我们基于图的计算。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "在掌握了基础知识之后，我们将处理更复杂的逻辑。这个练习的核心是为一个带有短路求值（`` 和 `||`）的复杂循环条件构建CFG，这要求你将一个逻辑表达式分解为一系列单独的分支。此外，本练习还清晰地对比了 `continue` 和 `break` 语句对控制流的不同影响，加深你对循环控制的理解。",
            "id": "3633637",
            "problem": "考虑以下用高级伪代码编写的函数，其中每个谓词调用都返回一个布尔值，并且除了读取其参数外没有其他副作用。逻辑运算符使用短路求值语义。\n\n函数 $\\mathrm{F}(x,y,z)$:\n1. 初始化 $s := 0$ 和 $i := 0$。\n2. 当 $f(x) \\land (g(y) \\lor h(z))$ 时循环：\n   a. 执行 $s := s + i$。\n   b. 如果 $p(i)$ 则：\n      i. 执行 $i := i + 1$。\n      ii. 继续下一次循环迭代（跳过循环体中任何剩余的语句）。\n   否则：\n      i. 执行 $i := i + 2$。\n   c. 如果 $q(s)$ 则：\n      i. 跳出循环。\n3. 返回 $s$。\n\n通过应用以下转换规则来构建控制流图（CFG），以保留短路语义和基本块结构：\n- 将循环守卫 $f(x) \\land (g(y) \\lor h(z))$ 视为在不同基本块中带短路控制的一系列独立谓词求值：首先求值 $f(x)$，仅当其为真时才求值 $g(y)$；如果 $g(y)$ 为假，则求值 $h(z)$；当且仅当 $f(x)$ 为真且 $g(y)$ 或 $h(z)$ 至少有一个为真时，才进入循环体；否则，控制流转到循环之后的点。\n- 将每个谓词求值 $f(x)$, $g(y)$, $h(z)$, $p(i)$ 和 $q(s)$ 放置在各自的基本块中，每个基本块都有两条出边，分别对应布尔结果 $T$（真）或 $F$（假）。\n- 将每个赋值语句（$s := s + i$, $i := i + 1$, $i := i + 2$）放置在各自的基本块中，每个基本块都只有一条出边。\n- 将 $\\mathrm{continue}$ 语句建模为从相应赋值基本块（$i := i + 1$）到下一次迭代的循环守卫的第一个谓词求值块的一条边。\n- 将 $\\mathrm{break}$ 语句建模为从 $q(s)$ 谓词块到循环紧随其后的点的一条边，从该点控制流转到函数的返回语句。\n- 函数具有单个入口点和单个返回语句。\n\n使用上述规则所隐含的CFG，确定该函数CFG的圈复杂度，结果为一个整数。提供该值的精确数字。不需要四舍五入。你的最终答案必须是一个单一的整数。",
            "solution": "图 $G$ 的圈复杂度，记为 $V(G)$，衡量了程序控制流图中线性无关路径的数量。对于具有单一入口和出口点的连通图，可以使用以下两个常用公式之一进行计算：\n1. $V(G) = E - N + 2$，其中 $E$ 是图中边的数量，$N$ 是图中节点的数量。\n2. $V(G) = D + 1$，其中 $D$ 是决策节点（具有多于一条出边的节点）的数量。\n\n我们将按照规定构建CFG，然后应用这些公式。CFG的基本块（节点）由所提供的规则确定。\n\nCFG的节点 $N$ 如下：\n-   $B_{init}$: 入口块，执行初始化操作 $s := 0$ 和 $i := 0$。\n-   $B_{f}$: 谓词 $f(x)$ 的决策块。\n-   $B_{g}$: 谓词 $g(y)$ 的决策块。\n-   $B_{h}$: 谓词 $h(z)$ 的决策块。\n-   $B_{add}$: 赋值语句 $s := s + i$ 的处理块。\n-   $B_{p}$: 谓词 $p(i)$ 的决策块。\n-   $B_{inc1}$: 赋值语句 $i := i + 1$ 的处理块。\n-   $B_{inc2}$: 赋值语句 $i := i + 2$ 的处理块。\n-   $B_{q}$: 谓词 $q(s)$ 的决策块。\n-   $B_{ret}$: 出口块，对应于 `Return s` 语句。\n\n这样，CFG中总共有 $N=10$ 个节点。\n\n连接这些节点的边 $E$ 由控制流确定：\n1. $B_{init} \\to B_{f}$: 初始化后，控制流转到循环条件的开始处。\n2. $B_{f} \\to B_{g}$: 如果 $f(x)$ 为真（`T`），由于短路求值，控制流继续求值 $g(y)$。\n3. $B_{f} \\to B_{ret}$: 如果 $f(x)$ 为假（`F`），循环条件为假，控制流退出循环到返回块。\n4. $B_{g} \\to B_{add}$: 如果 $g(y)$ 为真（`T`），“或”表达式 $(g(y) \\lor h(z))$ 为真，因此整个循环条件满足。控制流进入循环体，从 $B_{add}$ 开始。\n5. $B_{g} \\to B_{h}$: 如果 $g(y)$ 为假（`F`），控制流继续求值 $h(z)$。\n6. $B_{h} \\to B_{add}$: 如果 $h(z)$ 为真（`T`），整个循环条件满足，控制流进入循环体，到达 $B_{add}$。\n7. $B_{h} \\to B_{ret}$: 如果 $h(z)$ 为假（`F`），循环条件为假，控制流退出循环。\n8. $B_{add} \\to B_{p}$: 循环体中第一条语句执行后，控制流转到 `if` 语句。\n9. $B_{p} \\to B_{inc1}$: 如果 $p(i)$ 为真（`T`），控制流进入 `then` 分支。\n10. $B_{p} \\to B_{inc2}$: 如果 $p(i)$ 为假（`F`），控制流进入 `else` 分支。\n11. $B_{inc1} \\to B_{f}$: 执行 $i := i + 1$ 后，`continue` 语句将控制流引向下次循环迭代的开始，即在 $B_f$ 处求值 $f(x)$。\n12. $B_{inc2} \\to B_{q}$: `else` 分支按顺序执行到循环中的下一条语句，即在 $B_q$ 处的 `if q(s)` 条件语句。\n13. $B_{q} \\to B_{ret}$: 如果 $q(s)$ 为真（`T`），`break` 语句引导控制流退出循环，流向返回块 $B_{ret}$。\n14. $B_{q} \\to B_{f}$: 如果 $q(s)$ 为假（`F`），到达循环体末尾，控制流返回到循环条件的开始处 $B_f$ 进行下一次迭代。\n\n计算这些边，我们得到总共有 $E=14$ 条边。\n\n现在我们可以使用第一个公式 $V(G) = E - N + 2$ 计算圈复杂度。由于此CFG代表单个函数，它是一个单一的连通分量，所以我们使用 $P=1$。\n$$V(G) = E - N + 2 = 14 - 10 + 2 = 6$$\n\n为了验证这个结果，我们使用第二个公式 $V(G) = D + 1$。我们必须计算决策节点 $D$ 的数量。这些是具有多于一条出边的节点。根据我们的块列表，决策节点是：\n-   $B_{f}$：2条出边（到 $B_{g}$ 和 $B_{ret}$）。\n-   $B_{g}$：2条出边（到 $B_{add}$ 和 $B_{h}$）。\n-   $B_{h}$：2条出边（到 $B_{add}$ 和 $B_{ret}$）。\n-   $B_{p}$：2条出边（到 $B_{inc1}$ 和 $B_{inc2}$）。\n-   $B_{q}$：2条出边（到 $B_{ret}$ 和 $B_{f}$）。\n\n共有 $D=5$ 个决策节点。\n$$V(G) = D + 1 = 5 + 1 = 6$$\n两种方法都得到相同的结果。因此，该函数CFG的圈复杂度是 $6$。",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "最后，我们来挑战一个高级主题：异常处理。现代编程语言广泛使用 `try-catch` 结构，它引入了一套与常规流程并行的“异常”控制流。这个练习将向你展示如何为包含异常和继承的复杂代码建模，并揭示了CFG如何支持像后置支配这样的高级分析，这对于编译器的代码优化至关重要。",
            "id": "3633641",
            "problem": "一款用于结构化语言的编译器，使用以下经过充分测试的规则和定义作为其基础，来为过程构建控制流图（CFG）：CFG 包含代表基本块的节点和代表可能控制转移的有向边；基本块是具有单一入口和单一出口的最大的直线语句序列；如果从节点 $u$ 到唯一出口节点的所有路径都经过节点 $v$，则节点 $v$ 后支配节点 $u$；严格后支配者不包括节点本身。该语言提供异常机制，异常类型之间存在单继承关系，处理程序具有以下语义：如果类型 $T$ 等于类型 $U$ 或者 $T$ 继承自 $U$，则类型为 $T$ 的异常与为类型 $U$ 声明的处理程序匹配；一个 try 块可以有多个 catch 块，最内层的、动态包围的且带有匹配 catch 的 try 块会被选中；catch 块通常在整个 try-catch 结构之后继续执行，但一个特殊的 \"rethrow\" 语句会重新引发当前异常，由下一个动态包围的匹配 catch 来处理。\n\n考虑一个具有异常类型层次结构和嵌套 try-catch 块的过程。设 $E$ 为基类异常类型， $F$ 和 $G$ 为不同的派生类型，其中 $F \\to E$ 和 $G \\to E$ 表示单继承。设 $p$ 为一个运行时布尔值，其求值结果可导向任一分支。该过程的基本块标记为 $b_{0}, b_{1}, \\dots, b_{12}$，并具有以下直线内容和语法布局，其中 throw 和 rethrow 会终止其所在的块：\n\n- 外部 try 在 $b_{0}$ 之前开始，在 $b_{10}$ 之后结束。\n- 内部 try 在 $b_{1}$ 之前开始，在 $b_{5}$ 之后结束。\n- $b_{0}$：赋值 $x \\leftarrow 1$。\n- $b_{1}$：赋值 $y \\leftarrow 2$。\n- $b_{2}$：对分支条件 $p$ 求值。\n- $b_{3}$：如果控制流从 $b_{2}$ 到达且 $p$ 为真，执行 $\\mathrm{throw}\\ F$。\n- $b_{4}$：如果控制流从 $b_{2}$ 到达且 $p$ 为假，执行 $\\mathrm{throw}\\ G$。\n- $b_{5}$：计算 $z \\leftarrow y + 1$（文本上位于内部 try 中分支之后）。\n- $\\mathrm{catch}(F)$ 的入口是 $b_{6}$：执行处理程序体 $h_{F}$。\n- $b_{7}$：在 $h_{F}$ 之后立即执行 $\\mathrm{rethrow}$。\n- $\\mathrm{catch}(G)$ 的入口是 $b_{8}$：执行处理程序体 $h_{G}$。\n- $b_{9}$：在 $h_{G}$ 之后立即执行 $\\mathrm{rethrow}$。\n- $b_{10}$：计算 $w \\leftarrow x + y$（文本上位于内部 try 之后、外部 try 之内）。\n- 外部 $\\mathrm{catch}(E)$ 的入口是 $b_{11}$：执行处理程序体 $h_{E}$。\n- $b_{12}$：在外部 try-catch 之后执行 $done()$。\n- 唯一的出口节点在 $b_{12}$ 之后。\n\n使用以下基本规则构建 CFG：\n- 顺序边连接直线区域内的连续块，除非遇到终止符（throw 或 rethrow）；$b_{2}$ 有两个分支后继，$b_{3}$ 和 $b_{4}$。\n- 异常边从每个 $\\mathrm{throw}$ 添加到最近的、动态包围的、匹配的 $\\mathrm{catch}$ 的入口，基于类型层次结构：$b_{3} \\rightarrow b_{6}$ 和 $b_{4} \\rightarrow b_{8}$。\n- 每个 $\\mathrm{rethrow}$ 将控制权转移到当前 try 外部的、最近的、动态包围的、匹配的 $\\mathrm{catch}$ 的入口：$b_{7} \\rightarrow b_{11}$ 和 $b_{9} \\rightarrow b_{11}$。\n- 在 $b_{11}$ 处的外部 $\\mathrm{catch}(E)$ 体执行完毕后，控制流在 $b_{12}$ 处恢复，然后到达出口。\n\n假设从过程入口开始进行标准的可达性分析，并从后支配者分析中排除不可达节点。根据“如果从节点 $u$ 到出口的所有路径都包含节点 $v$ 且 $u \\neq v$，则节点 $v$ 严格后支配节点 $u$”的精确定义，确定被外部基类 catch 入口 $b_{11}$ 严格后支配的可达基本块的数量。\n\n将你的最终答案表示为单个整数。无需四舍五入。",
            "solution": "我们首先枚举 CFG 的节点和边，然后确定可达性，最后应用后支配关系。\n\n节点是基本块 $b_{0}, b_{1}, \\dots, b_{12}$ 以及一个我们表示为 $exit$ 的出口节点。外部 try 在 $b_{0}$ 之前开始，在 $b_{10}$ 之后结束。内部 try 在 $b_{1}$ 之前开始，在 $b_{5}$ 之后结束。Throw 和 rethrow 会终止其所在的块，因此只有异常后继。\n\n顺序边：\n- $b_{0} \\rightarrow b_{1}$ 和 $b_{1} \\rightarrow b_{2}$，因为它们在任何分支或终止符之前是直线执行的。\n- $b_{2}$ 是一个条件分支，有两个后继：真分支（$p$ 为真）为 $b_{2} \\rightarrow b_{3}$，假分支（$p$ 为假）为 $b_{2} \\rightarrow b_{4}$。\n- 从 $b_{3}$ 或 $b_{4}$ 到 $b_{5}$ 没有顺序边，因为 $b_{3}$ 和 $b_{4}$ 都以 $\\mathrm{throw}$ 终止。\n- 在每个 catch 块内部，$b_{6} \\rightarrow b_{7}$ 和 $b_{8} \\rightarrow b_{9}$ 是处理程序体内的顺序边。\n- 从 $b_{7}$ 或 $b_{9}$ 到 $b_{10}$ 没有顺序边，因为它们都是执行 $\\mathrm{rethrow}$ 的终止符。\n- 在外部 catch $b_{11}$ 之后，我们有 $b_{11} \\rightarrow b_{12}$，然后是 $b_{12} \\rightarrow exit$，作为到过程出口的正常控制流。\n\n来自 throw 和 rethrow 的异常边：\n- 从 $b_{3}$（$\\mathrm{throw}\\ F$）到最近的匹配 $F$ 的内部 catch：$b_{3} \\rightarrow b_{6}$。\n- 从 $b_{4}$（$\\mathrm{throw}\\ G$）到最近的匹配 $G$ 的内部 catch：$b_{4} \\rightarrow b_{8}$。\n- 从 $b_{7}$（在 $\\mathrm{catch}(F)$ 后的 $\\mathrm{rethrow}$）到最近的包围的、匹配 $E$ 的外部 catch：$b_{7} \\rightarrow b_{11}$，因为在类型层次结构中 $F \\to E$，并且在 rethrow 之后，内部 try 不再是包围块。\n- 从 $b_{9}$（在 $\\mathrm{catch}(G)$ 后的 $\\mathrm{rethrow}$）到最近的包围的、匹配 $E$ 的外部 catch：$b_{9} \\rightarrow b_{11}$，因为 $G \\to E$。\n\n从入口开始的可达性分析过程如下：\n- 从 $b_{0}$ 开始，我们到达 $b_{1}$，然后是 $b_{2}$。\n- 从 $b_{2}$ 出发，$b_{3}$ 和 $b_{4}$ 都可能到达，这取决于 $p$ 的运行时值；在 CFG 术语中，两个后继都包括在内。\n- 从 $b_{3}$ 出发，唯一的后继是通过异常边到达的 $b_{6}$；从 $b_{4}$ 出发，唯一的后继是通过异常边到达的 $b_{8}$。\n- 从 $b_{6}$，我们到达 $b_{7}$；然后从 $b_{7}$，唯一的后继是通过异常边到达的 $b_{11}$（外部 $\\mathrm{catch}(E)$）。类似地，从 $b_{8}$ 我们到达 $b_{9}$；从 $b_{9}$ 我们通过异常边到达 $b_{11}$。\n- 从 $b_{11}$，我们到达 $b_{12}$，然后是 $exit$。\n\n因为从 $b_{2}$ 出发的两个分支都立即抛出异常，并且两个内部 catch 块都立即重新抛出异常，所以没有可达路径到达 $b_{5}$ 或 $b_{10}$；因此 $b_{5}$ 和 $b_{10}$ 是不可达的，并从后支配者分析中排除。因此，可达节点集为\n$$\nR = \\{ b_{0}, b_{1}, b_{2}, b_{3}, b_{4}, b_{6}, b_{7}, b_{8}, b_{9}, b_{11}, b_{12}, exit \\}.\n$$\n\n我们现在应用关于 $b_{11}$ 的严格后支配定义。如果从一个节点 $u \\in R$ 到 $exit$ 的每条路径都包含 $b_{11}$ 且 $u \\neq b_{11}$，则该节点被 $b_{11}$ 严格后支配。我们按类别考虑：\n\n- 内部 throw 之前的块和分支块 $b_{0}, b_{1}, b_{2}$：从这些块出发，所有路径都通向 $b_{3}$ 或 $b_{4}$，然后进入相应的内部 catch（$b_{6}$ 或 $b_{8}$），接着 rethrow（$b_{7}$ 或 $b_{9}$），然后到 $b_{11}$，再到 $b_{12}$，最后到 $exit$。不存在绕过 $b_{11}$ 的替代路径，因为两个内部处理程序都重新抛出异常，并且在内部 try 之后没有正常的控制流可以继续到 $b_{10}$。因此，$b_{11}$ 后支配 $b_{0}, b_{1}, b_{2}$。\n\n- Throw 块 $b_{3}$ 和 $b_{4}$：每个块都立即转移到相应的内部 catch，然后重新抛出到 $b_{11}$。因此，从 $b_{3}$ 和 $b_{4}$ 到 $exit$ 的所有路径都包含 $b_{11}$。因此，$b_{11}$ 后支配 $b_{3}$ 和 $b_{4}$。\n\n- 内部 catch 体和 rethrow 块 $b_{6}, b_{7}, b_{8}, b_{9}$：从 $b_{6}$ 出发，唯一的路径是到 $b_{7}$ 然后到 $b_{11}$；从 $b_{7}$ 出发，唯一的路径是直接到 $b_{11}$。对于 $b_{8}$ 和 $b_{9}$ 也是类似的。因此，从这些节点出发的所有路径都包含 $b_{11}$，所以 $b_{11}$ 后支配 $b_{6}, b_{7}, b_{8}, b_{9}$。\n\n- 外部 catch $b_{11}$ 本身因严格性（$u \\neq b_{11}$）而被排除。\n\n- Catch 后的延续块 $b_{12}$：从 $b_{12}$ 出发的路径直接到 $exit$；它们不包含 $b_{11}$，因为 $b_{11}$ 在 $b_{12}$ 之前。因此，$b_{11}$ 不后支配 $b_{12}$。\n\n因此，被 $b_{11}$ 严格后支配的可达节点集是\n$$\nS = \\{ b_{0}, b_{1}, b_{2}, b_{3}, b_{4}, b_{6}, b_{7}, b_{8}, b_{9} \\}.\n$$\n其基数为\n$$\n|S| = 9.\n$$\n\n这个计数证明了这样一个性质：外部基类 catch $b_{11}$ 后支配了特化的处理程序路径（以及所有必然通向这些路径的更早节点），因为内部处理程序会重新抛出异常，而从这些路径到达 $exit$ 的唯一方式就是通过外部基类 catch。因此，被 $b_{11}$ 严格后支配的可达基本块所需数量是 $9$。",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}