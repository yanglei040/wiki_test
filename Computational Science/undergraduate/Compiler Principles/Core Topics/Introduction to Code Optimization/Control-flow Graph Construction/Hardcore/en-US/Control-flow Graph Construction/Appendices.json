{
    "hands_on_practices": [
        {
            "introduction": "This problem provides an excellent starting point for translating imperative code into a Control-Flow Graph (CFG). By analyzing a simple factorial function that includes a `while` loop, conditional logic, and a `break` statement, you will practice the fundamental skill of partitioning code into basic blocks. This exercise  also introduces cyclomatic complexity, a key software metric derived directly from the CFG, which helps quantify the complexity of a program's control flow.",
            "id": "3633677",
            "problem": "You are given the following straight-line imperative program fragment that computes a factorial-like value, aborting the loop early if multiplying would overflow. You must model control explicitly and adhere to the conventions that follow.\n\nProgram:\nInput: a machine integer $n$.\nif $n  0$ then\n    return $-1$\nfi\n$i := 1$\n$r := 1$\nwhile $i \\le n$ do\n    if $\\mathrm{Overflow}(r,i)$ then\n        break\n    fi\n    $r := r \\times i$\n    $i := i + 1$\nod\nreturn $r$\n\nConventions for constructing the Control-Flow Graph (CFG):\n- A Control-Flow Graph (CFG) is a directed graph whose nodes are basic blocks and whose edges represent the possible transfer of control from the end of one block to the beginning of another.\n- A basic block is a maximal straight-line sequence of statements with a single entry and a single exit; it ends before and after any branch, loop test, or jump target.\n- Normalize all returns to a single distinguished exit block. Any early return must first assign the intended return value and then branch to the unique exit block, which performs the function’s return. Do not introduce any additional control constructs beyond this normalization.\n- Treat the predicate $\\mathrm{Overflow}(r,i)$ as an atomic boolean test. The break statement transfers control to immediately after the while-loop; with return normalization, this then flows to the unique exit block that returns the correct value.\n- Conditionals have exactly two outgoing edges corresponding to the true and false outcomes. There is no short-circuiting beyond what is explicitly written above.\n\nTask:\n- Construct the minimal basic-block CFG that satisfies the conventions above for the given program.\n- Let $N$ denote the number of nodes (basic blocks) in the CFG, $E$ denote the number of directed edges, and $P$ denote the number of connected components in the underlying undirected version of the CFG.\n- Using only these graph quantities, determine the cyclomatic complexity $M$ of the CFG.\n\nProvide only the numerical value of $M$ as your final answer. No rounding is required.",
            "solution": "The problem requires the calculation of the cyclomatic complexity, $M$, of a Control-Flow Graph (CFG) for a given program fragment. The cyclomatic complexity is to be calculated using the formula $M = E - N + 2P$, where $N$ is the number of nodes (basic blocks), $E$ is the number of directed edges, and $P$ is the number of connected components in the graph.\n\nFirst, we must construct the CFG by partitioning the program into basic blocks according to the provided conventions. A basic block is a maximal sequence of straight-line code with one entry and one exit. A new basic block starts at the beginning of the program, at the target of a jump or branch, or after a branch instruction. The given conventions mandate normalizing all return statements into a single unique exit block.\n\nLet's identify the basic blocks for the given program:\n\nProgram:\n```\nInput: a machine integer $n$.\nif $n  0$ then\n    return $-1$\nfi\n$i := 1$\n$r := 1$\nwhile $i \\le n$ do\n    if $\\mathrm{Overflow}(r,i)$ then\n        break\n    fi\n    $r := r \\times i$\n    $i := i + 1$\nod\nreturn $r$\n```\n\n1.  **Block B1**: The first instruction is a conditional branch, `if $n  0$`, which itself forms the first basic block. This is the entry point of the CFG.\n    -   `B1: if $n  0$`\n\n2.  **Block B2**: If the condition in `B1` is true, the program should `return $-1$`. Due to the return normalization rule, this becomes an assignment to a return value holder (let's call it `ret_val`) followed by an unconditional jump to the exit block. The assignment `ret_val := $-1$` forms its own basic block.\n    -   `B2: ret_val := -1`\n\n3.  **Block B3**: If the condition in `B1` is false, control flows to the initialization code `i := 1` and `r := 1`. These two sequential assignments form a single basic block.\n    -   `B3: i := 1; r := 1`\n\n4.  **Block B4**: After initialization, control reaches the `while` loop. The loop's condition, `while $i \\le n$`, acts as a conditional branch and forms a new basic block. It is a jump target for the end of the loop body, reinforcing its status as a block entry.\n    -   `B4: if $i \\le n$`\n\n5.  **Block B5**: If the loop condition in `B4` is true, control enters the loop body. The first statement is another conditional, `if $\\mathrm{Overflow}(r,i)$`, which forms a new basic block.\n    -   `B5: if $\\mathrm{Overflow}(r,i)$`\n\n6.  **Block B6**: If the overflow condition in `B5` is false, the statements `r := r \\times i` and `i := i + 1` are executed. This sequential code forms a single basic block. After this block, control returns to the loop condition check in `B4`.\n    -   `B6: r := r \\times i; i := i + 1`\n\n7.  **Block B7**: This block is reached after the loop terminates. The `break` statement (from `B5`) and the loop condition failing (from `B4`) both transfer control here. The instruction is `return $r$`, which normalizes to an assignment `ret_val := r`. Because this block is a target of multiple jumps, it must be a distinct basic block.\n    -   `B7: ret_val := r`\n\n8.  **Block B8**: This is the unique exit block, as required by the conventions. It is the target of jumps from all paths that terminate the function. In this program, blocks `B2` and `B7` jump to this block.\n    -   `B8: return ret_val`\n\nWe have identified $N = 8$ basic blocks.\n\nNext, we identify the directed edges ($E$) representing the flow of control between these blocks:\n-   `B1` has two successors: `B2` (if `$n  0$` is true) and `B3` (if false). (2 edges)\n-   `B2` has one successor: `B8` (unconditional jump to exit). (1 edge)\n-   `B3` has one successor: `B4` (unconditional flow to loop test). (1 edge)\n-   `B4` has two successors: `B5` (if `$i \\le n$` is true, enter loop) and `B7` (if false, exit loop). (2 edges)\n-   `B5` has two successors: `B7` (if `$\\mathrm{Overflow}(r,i)$` is true, `break` to after the loop) and `B6` (if false, continue loop body). (2 edges)\n-   `B6` has one successor: `B4` (unconditional jump to the start of the loop test). (1 edge)\n-   `B7` has one successor: `B8` (unconditional jump to exit). (1 edge)\n-   `B8` is the terminal block and has no successors. (0 edges)\n\nSumming the number of edges: $E = 2 + 1 + 1 + 2 + 2 + 1 + 1 = 10$.\n\nNow, we determine the number of connected components, $P$. A CFG for a single, non-empty procedure is a connected graph because every block is reachable from the entry block. In our construction, `B1` is the entry block, and all other blocks (`B2` through `B8`) are reachable from `B1`. Therefore, the graph has $P = 1$ connected component.\n\nFinally, we apply the formula for cyclomatic complexity:\n$M = E - N + 2P$\nSubstituting the values we found: $N = 8$, $E = 10$, and $P = 1$.\n$M = 10 - 8 + 2(1) = 2 + 2 = 4$.\n\nThe cyclomatic complexity of the CFG is $4$. This result can be cross-verified by the simpler formula $M = D + 1$, where $D$ is the number of decision points. The program has $3$ decision points: `if $n  0$`, `while $i \\le n$`, and `if $\\mathrm{Overflow}(r,i)$`. This gives $M = 3 + 1 = 4$, which confirms our graph-based calculation.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "Building on the fundamentals, this next practice challenges you to model more intricate control flow constructs. You will construct a CFG for a loop whose condition involves short-circuiting logical operators (`AND`/`OR`), a common feature in modern programming languages that requires careful representation. This exercise  also integrates `break` and `continue` statements, allowing you to see how different jump-like instructions create distinct edge patterns within the graph.",
            "id": "3633637",
            "problem": "Consider the following function written in high-level pseudocode, where each predicate call returns a Boolean and has no side effects other than reading its arguments. The logical operators use short-circuit evaluation semantics.\n\nFunction $\\mathrm{F}(x,y,z)$:\n1. Initialize $s := 0$ and $i := 0$.\n2. While $f(x) \\land (g(y) \\lor h(z))$:\n   a. Execute $s := s + i$.\n   b. If $p(i)$ then:\n      i. Execute $i := i + 1$.\n      ii. Continue to the next loop iteration (skip any remaining statements in the loop body).\n      Else:\n      i. Execute $i := i + 2$.\n   c. If $q(s)$ then:\n      i. Break out of the loop.\n3. Return $s$.\n\nConstruct the Control-Flow Graph (CFG) by applying the following translation discipline to preserve short-circuit semantics and basic block structure:\n- Treat the loop guard $f(x) \\land (g(y) \\lor h(z))$ as a sequence of separate predicate evaluations in distinct basic blocks with short-circuit control: first evaluate $f(x)$, and only if it is true evaluate $g(y)$; if $g(y)$ is false, then evaluate $h(z)$; the loop body is entered if and only if $f(x)$ is true and at least one of $g(y)$ or $h(z)$ is true; otherwise, control flows to the point after the loop.\n- Place each predicate evaluation $f(x)$, $g(y)$, $h(z)$, $p(i)$, and $q(s)$ in its own basic block, each with exactly two outgoing edges corresponding to the Boolean outcomes $T$ (true) or $F$ (false).\n- Place each assignment statement ($s := s + i$, $i := i + 1$, $i := i + 2$) in its own basic block with exactly one outgoing edge.\n- Model the $\\mathrm{continue}$ statement as an edge from the corresponding assignment basic block ($i := i + 1$) to the loop guard’s first predicate evaluation block for the next iteration.\n- Model the $\\mathrm{break}$ statement as an edge from the $q(s)$ predicate block to the point immediately after the loop, from which control flows to the function’s return statement.\n- The function has a single entry point and a single return statement.\n\nUsing the CFG implied by the above rules, determine the cyclomatic complexity of the function’s CFG as a single integer. Provide the value as an exact number. No rounding is required. Your final answer must be a single real-valued number.",
            "solution": "The problem statement is valid. It is a well-posed problem within the domain of computer science, specifically compiler theory and software metrics. The instructions for constructing the Control-Flow Graph (CFG) are explicit, self-contained, and logically consistent, allowing for the unambiguous construction of the graph and the subsequent calculation of its cyclomatic complexity.\n\nThe cyclomatic complexity of a graph $G$, denoted $V(G)$, measures the number of linearly independent paths through the program's control-flow graph. For a connected graph with a single entry and exit point, it can be calculated using one of two common formulas:\n$1$. $V(G) = E - N + 2$, where $E$ is the number of edges and $N$ is the number of nodes in the graph.\n$2$. $V(G) = D + 1$, where $D$ is the number of decision nodes (nodes with more than one outgoing edge).\n\nWe will construct the CFG as specified and then apply these formulas. The basic blocks (nodes) of the CFG are determined by the rules provided.\n\nThe nodes, $N$, of the CFG are as follows:\n-   $B_{s\\_init}$: A processing block for `s := 0`.\n-   $B_{i\\_init}$: A processing block for `i := 0`.\n-   $B_{f}$: A decision block for the predicate $f(x)$.\n-   $B_{g}$: A decision block for the predicate $g(y)$.\n-   $B_{h}$: A decision block for the predicate $h(z)$.\n-   $B_{add}$: A processing block for the assignment $s := s + i$.\n-   $B_{p}$: A decision block for the predicate $p(i)$.\n-   $B_{inc1}$: A processing block for the assignment $i := i + 1$.\n-   $B_{inc2}$: A processing block for the assignment $i := i + 2$.\n-   $B_{q}$: A decision block for the predicate $q(s)$.\n-   $B_{ret}$: The exit block, corresponding to the `Return s` statement.\n\nThis gives a total of $N=11$ nodes in the CFG.\n\nThe edges, $E$, connecting these nodes are determined by the control flow:\n-   $B_{s\\_init} \\to B_{i\\_init}$: After the first initialization.\n-   $B_{i\\_init} \\to B_{f}$: After initialization, control flows to the start of the loop condition.\n-   $B_{f} \\to B_{g}$: If $f(x)$ is true (`T`), control proceeds to evaluate $g(y)$ due to short-circuiting.\n-   $B_{f} \\to B_{ret}$: If $f(x)$ is false (`F`), the loop condition is false, and control exits the loop to the return block.\n-   $B_{g} \\to B_{add}$: If $g(y)$ is true (`T`), the 'or' expression $(g(y) \\lor h(z))$ is true, so the full loop condition is met. Control enters the loop body, starting with $B_{add}$.\n-   $B_{g} \\to B_{h}$: If $g(y)$ is false (`F`), control proceeds to evaluate $h(z)$.\n-   $B_{h} \\to B_{add}$: If $h(z)$ is true (`T`), the full loop condition is met, and control enters the loop body at $B_{add}$.\n-   $B_{h} \\to B_{ret}$: If $h(z)$ is false (`F`), the loop condition is false, and control exits the loop.\n-   $B_{add} \\to B_{p}$: After the first statement in the loop body, control flows to the `if` statement.\n-   $B_{p} \\to B_{inc1}$: If $p(i)$ is true (`T`), control enters the `then` branch.\n-   $B_{p} \\to B_{inc2}$: If $p(i)$ is false (`F`), control enters the `else` branch.\n-   $B_{inc1} \\to B_{f}$: After executing $i := i + 1$, the `continue` statement directs control to the beginning of the next loop iteration, which is the evaluation of $f(x)$ at $B_f$.\n-   $B_{inc2} \\to B_{q}$: The `else` branch falls through to the next statement in the loop, which is the `if q(s)` conditional at $B_q$.\n-   $B_{q} \\to B_{ret}$: If $q(s)$ is true (`T`), the `break` statement directs control to exit the loop, flowing to the return block $B_{ret}$.\n-   $B_{q} \\to B_{f}$: If $q(s)$ is false (`F`), the end of the loop body is reached, and control flows back to the start of the loop condition at $B_f$ for the next iteration.\n\nCounting these edges, we find a total of $E=15$ edges.\n\nNow we can calculate the cyclomatic complexity using the first formula, $V(G) = E - N + 2$. Since this CFG represents a single function, it is a single connected component, so we use $P=1$.\n$$V(G) = E - N + 2 = 15 - 11 + 2 = 6$$\n\nTo verify this result, we use the second formula, $V(G) = D + 1$. We must count the number of decision nodes, $D$. These are the nodes with more than one outgoing edge. From our list of blocks, the decision nodes are:\n-   $B_{f}$: $2$ outgoing edges (to $B_{g}$ and $B_{ret}$).\n-   $B_{g}$: $2$ outgoing edges (to $B_{add}$ and $B_{h}$).\n-   $B_{h}$: $2$ outgoing edges (to $B_{add}$ and $B_{ret}$).\n-   $B_{p}$: $2$ outgoing edges (to $B_{inc1}$ and $B_{inc2}$).\n-   $B_{q}$: $2$ outgoing edges (to $B_{ret}$ and $B_{f}$).\n\nThere are $D=5$ decision nodes.\n$$V(G) = D + 1 = 5 + 1 = 6$$\nBoth methods yield the same result. Therefore, the cyclomatic complexity of the function's CFG is $6$.",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "This final practice explores the construction of CFGs in the presence of non-local control flow, specifically structured exception handling. You will analyze a program with nested `try-catch` blocks, an exception type hierarchy, and `rethrow` statements, learning how to model these complex transfers of control. The exercise  shifts the focus from graph construction to graph analysis by asking you to apply the concept of post-dominance, a critical prerequisite for many advanced compiler optimizations and program analyses.",
            "id": "3633641",
            "problem": "A compiler for a structured language constructs a Control-Flow Graph (CFG) for procedures using the following well-tested rules and definitions as its foundational base: a CFG has nodes for basic blocks and directed edges for possible control transfers; a basic block is a maximal straight-line sequence of statements with a single entry and a single exit; a node $v$ post-dominates a node $u$ if every path from $u$ to the unique exit node passes through $v$; a strict post-dominator excludes the node itself. The language provides exceptions with single inheritance among exception types and handlers with the following semantics: an exception of type $T$ matches a handler declared for a type $U$ if $T$ equals $U$ or if $T$ inherits from $U$; a try block may have multiple catch blocks, and the innermost dynamically enclosing try with a matching catch is chosen; a catch block normally continues control after the entire try-catch, but a special statement \"rethrow\" re-raises the current exception to be handled by the next dynamically enclosing matching catch.\n\nConsider this procedure with an exception type hierarchy and nested try-catch blocks. Let $E$ be a base exception type, and let $F$ and $G$ be distinct derived types with $F \\rightarrow E$ and $G \\rightarrow E$ denoting single inheritance. Let $p$ be a runtime Boolean value that may evaluate to either branch. The procedure’s basic blocks are labeled $b_{0}, b_{1}, \\dots, b_{12}$ and have the following straight-line contents and syntactic layout, where throws and rethrows terminate their blocks:\n\n- Outer try begins before $b_{0}$ and ends after $b_{10}$.\n- Inner try begins before $b_{1}$ and ends after $b_{5}$.\n- $b_{0}$: assign $x \\leftarrow 1$.\n- $b_{1}$: assign $y \\leftarrow 2$.\n- $b_{2}$: evaluate the branch condition $p$.\n- $b_{3}$: if control arrives from $b_{2}$ and $p$ is true, execute $\\mathrm{throw}\\ F$.\n- $b_{4}$: if control arrives from $b_{2}$ and $p$ is false, execute $\\mathrm{throw}\\ G$.\n- $b_{5}$: compute $z \\leftarrow y + 1$ (textually inside the inner try after the branch).\n- $\\mathrm{catch}(F)$ entry is $b_{6}$: execute handler body $h_{F}$.\n- $b_{7}$: execute $\\mathrm{rethrow}$ immediately after $h_{F}$.\n- $\\mathrm{catch}(G)$ entry is $b_{8}$: execute handler body $h_{G}$.\n- $b_{9}$: execute $\\mathrm{rethrow}$ immediately after $h_{G}$.\n- $b_{10}$: compute $w \\leftarrow x + y$ (textually after the inner try inside the outer try).\n- Outer $\\mathrm{catch}(E)$ entry is $b_{11}$: execute handler body $h_{E}$.\n- $b_{12}$: execute $done()$ after the outer try-catch.\n- The unique exit node is after $b_{12}$.\n\nConstruct the CFG using these foundational rules:\n- Sequential edges connect consecutive blocks within a straight-line region unless a terminator (throw or rethrow) is encountered; $b_{2}$ has two branch successors, $b_{3}$ and $b_{4}$.\n- Exceptional edges are added from each $\\mathrm{throw}$ to the entry of the nearest dynamically enclosing matching $\\mathrm{catch}$, based on the type hierarchy: $b_{3} \\rightarrow b_{6}$ and $b_{4} \\rightarrow b_{8}$.\n- Each $\\mathrm{rethrow}$ transfers control to the entry of the nearest dynamically enclosing matching $\\mathrm{catch}$ outside the current try: $b_{7} \\rightarrow b_{11}$ and $b_{9} \\rightarrow b_{11}$.\n- After the outer $\\mathrm{catch}(E)$ body at $b_{11}$ finishes, control resumes at $b_{12}$ and then the exit.\n\nAssume standard reachability analysis starting from procedure entry and exclude unreachable nodes from post-dominator analysis. Under the precise definition that a node $v$ strictly post-dominates a node $u$ if every path from $u$ to the exit includes $v$ and $u \\neq v$, determine the number of reachable basic blocks that are strictly post-dominated by the outer base-class catch entry $b_{11}$.\n\nExpress your final answer as a single integer. No rounding is required.",
            "solution": "The starting point is the foundational definition of a Control-Flow Graph (CFG) and post-dominance: for nodes $u$ and $v$, node $v$ post-dominates $u$ if every path from $u$ to the unique exit passes through $v$. Strict post-dominance further requires $u \\neq v$. We also use the standard, well-tested semantics for exceptions in structured languages: a $\\mathrm{throw}$ of type $T$ targets the nearest dynamically enclosing $\\mathrm{catch}$ whose declared type $U$ matches $T$ or a base of $T$, and a $\\mathrm{rethrow}$ propagates the current exception to be handled by the next enclosing matching $\\mathrm{catch}$.\n\nWe first enumerate the CFG nodes and edges, then determine reachability, and finally apply post-dominance.\n\nNodes are the basic blocks $b_{0}, b_{1}, \\dots, b_{12}$ and an exit node we denote by $exit$. The outer try begins before $b_{0}$ and ends after $b_{10}$. The inner try begins before $b_{1}$ and ends after $b_{5}$. Throws and rethrows terminate their blocks and therefore have only exceptional successors.\n\nSequential edges:\n- $b_{0} \\rightarrow b_{1}$ and $b_{1} \\rightarrow b_{2}$ because they are straight-line before any branch or terminator.\n- $b_{2}$ is a conditional with two successors: $b_{2} \\rightarrow b_{3}$ on the true branch ($p$ is true) and $b_{2} \\rightarrow b_{4}$ on the false branch ($p$ is false).\n- There is no sequential edge from $b_{3}$ or $b_{4}$ to $b_{5}$ because both $b_{3}$ and $b_{4}$ terminate with $\\mathrm{throw}$.\n- Within each catch, $b_{6} \\rightarrow b_{7}$ and $b_{8} \\rightarrow b_{9}$ are sequential edges inside the handler bodies.\n- There is no sequential edge from $b_{7}$ or $b_{9}$ to $b_{10}$ because both are terminators that $\\mathrm{rethrow}$.\n- After the outer catch $b_{11}$, we have $b_{11} \\rightarrow b_{12}$ and then $b_{12} \\rightarrow exit$ as normal fallthrough to the procedure exit.\n\nExceptional edges from throws and rethrows:\n- From $b_{3}$ ($\\mathrm{throw}\\ F$) to the nearest matching inner catch for $F$: $b_{3} \\rightarrow b_{6}$.\n- From $b_{4}$ ($\\mathrm{throw}\\ G$) to the nearest matching inner catch for $G$: $b_{4} \\rightarrow b_{8}$.\n- From $b_{7}$ ($\\mathrm{rethrow}$ after $\\mathrm{catch}(F)$) to the nearest enclosing matching outer catch for $E$: $b_{7} \\rightarrow b_{11}$, since $F \\rightarrow E$ in the type hierarchy and the inner try is no longer enclosing after the rethrow.\n- From $b_{9}$ ($\\mathrm{rethrow}$ after $\\mathrm{catch}(G)$) to the nearest enclosing matching outer catch for $E$: $b_{9} \\rightarrow b_{11}$, since $G \\rightarrow E$.\n\nReachability analysis from entry proceeds as follows:\n- Starting at $b_{0}$, we reach $b_{1}$, then $b_{2}$.\n- From $b_{2}$, both $b_{3}$ and $b_{4}$ are potentially reachable depending on the runtime value of $p$; in CFG terms, both successors are included.\n- From $b_{3}$, the only successor is $b_{6}$ via the exceptional edge; from $b_{4}$, the only successor is $b_{8}$ via the exceptional edge.\n- From $b_{6}$, we reach $b_{7}$; then from $b_{7}$, the only successor is $b_{11}$ via exceptional edge (outer $\\mathrm{catch}(E)$). Similarly, from $b_{8}$ we reach $b_{9}$; from $b_{9}$ we reach $b_{11}$ via exceptional edge.\n- From $b_{11}$, we reach $b_{12}$ and then $exit$.\n\nBecause both branches out of $b_{2}$ immediately throw and both inner catches immediately rethrow, there is no reachable path to $b_{5}$ or $b_{10}$; thus $b_{5}$ and $b_{10}$ are unreachable and excluded from post-dominator analysis. The reachable node set is therefore\n$$\nR = \\{ b_{0}, b_{1}, b_{2}, b_{3}, b_{4}, b_{6}, b_{7}, b_{8}, b_{9}, b_{11}, b_{12}, exit \\}.\n$$\n\nWe now apply the definition of strict post-dominance with respect to $b_{11}$. A node $u \\in R$ is strictly post-dominated by $b_{11}$ if every path from $u$ to $exit$ includes $b_{11}$ and $u \\neq b_{11}$. We consider each category:\n\n- Pre-inner-throw and branch blocks $b_{0}, b_{1}, b_{2}$: From each of these, all paths go to either $b_{3}$ or $b_{4}$, then into the corresponding inner catch ($b_{6}$ or $b_{8}$), then rethrow ($b_{7}$ or $b_{9}$), then to $b_{11}$, then $b_{12}$, then $exit$. There are no alternative paths that bypass $b_{11}$ because both inner handlers rethrow and there is no normal continuation to $b_{10}$ after the inner try. Therefore, $b_{11}$ post-dominates $b_{0}, b_{1}, b_{2}$.\n\n- Throw blocks $b_{3}$ and $b_{4}$: Each immediately transfers to the corresponding inner catch, then rethrows to $b_{11}$. Hence, all paths from $b_{3}$ and $b_{4}$ to $exit$ include $b_{11}$. Therefore, $b_{11}$ post-dominates $b_{3}$ and $b_{4}$.\n\n- Inner catch bodies and rethrows $b_{6}, b_{7}, b_{8}, b_{9}$: From $b_{6}$, the only path goes to $b_{7}$ and then to $b_{11}$; from $b_{7}$, the only path goes directly to $b_{11}$. Analogously for $b_{8}$ and $b_{9}$. Thus, all paths from these nodes include $b_{11}$, so $b_{11}$ post-dominates $b_{6}, b_{7}, b_{8}, b_{9}$.\n\n- The outer catch $b_{11}$ itself is excluded by strictness ($u \\neq b_{11}$).\n\n- After-catch continuation $b_{12}$: Paths from $b_{12}$ go directly to $exit$; they do not include $b_{11}$ because $b_{11}$ precedes $b_{12}$. Hence, $b_{11}$ does not post-dominate $b_{12}$.\n\nThus, the set of reachable nodes strictly post-dominated by $b_{11}$ is\n$$\nS = \\{ b_{0}, b_{1}, b_{2}, b_{3}, b_{4}, b_{6}, b_{7}, b_{8}, b_{9} \\}.\n$$\nThe cardinality is\n$$\n|S| = 9.\n$$\n\nThis count demonstrates the property that the outer base-class catch $b_{11}$ post-dominates the specialized handler paths (and all earlier points that necessarily lead into them) because the inner handlers rethrow and the only way to reach $exit$ from those paths is through the outer base-class catch. Therefore, the required number of reachable basic blocks strictly post-dominated by $b_{11}$ is $9$.",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}