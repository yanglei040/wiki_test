{
    "hands_on_practices": [
        {
            "introduction": "To begin, we must master the fundamental skill of identifying which parts of a loop are truly invariant. This exercise () challenges you to analyze a series of computations within a nested loop and determine their eligibility for being moved out of the loop. A computation is a candidate for motion only if all its inputs are defined outside the loop or by other invariant computations, and the operation itself is free of side effects that would be altered by the move.",
            "id": "3654682",
            "problem": "Consider the following nested loops, where $M$ and $N$ are positive integers set before the loops begin, arrays $A$ and $B$ are allocated and initialized before the loops, and all indices are within bounds. The outer loop index is $i$ and the inner loop index is $j$. The outer loop runs $i$ from $0$ to $M-1$ inclusive, and the inner loop runs $j$ from $0$ to $N-1$ inclusive. Within the inner loop, the following assignments are executed in the given order:\n- $u_1 \\gets M \\cdot N$\n- $u_2 \\gets N - 1$\n- $u_3 \\gets i \\cdot N$\n- $u_4 \\gets f(M)$, where $f$ is a pure function (no side effects, no exceptions) that depends only on its argument value\n- $u_5 \\gets h()$, where $h$ reads and increments a global counter $G$ (so $h$ has side effects and its return value depends on $G$)\n- $u_6 \\gets A[0]$\n- $u_7 \\gets B[j]$\n- $A[i] \\gets u_7 + u_3$\n- $G \\gets G + 1$\n\nAssume that:\n- $M$ and $N$ are not modified anywhere inside either loop.\n- Array $B$ is not modified anywhere in the program inside the loops.\n- Array $A$ is modified inside the loops only at index $i$ as shown above.\n- The global counter $G$ is modified only by $h$ and the explicit increment shown.\n- There are no aliasing relationships between $A$ and $B$ or between those arrays and $G$.\n\nUsing the foundational definition that a computation is loop-invariant with respect to a loop if the values of all its operands remain unchanged across all iterations of that loop, and that a transformation such as hoisting must preserve program semantics (including the absence of new side effects and unchanged exception behavior), determine which of the listed computations can be safely hoisted out of the inner loop and placed in the preheader of the outer loop (that is, executed once before the outer loop begins) without changing the program’s observable behavior.\n\nChoose the best option.\n\nA. $u_1$, $u_2$, and $u_4$ can be hoisted to the outer loop preheader; the others cannot.\n\nB. $u_1$, $u_2$, $u_3$, and $u_4$ can be hoisted to the outer loop preheader; the others cannot.\n\nC. $u_1$, $u_2$, $u_4$, and $u_6$ can be hoisted to the outer loop preheader; the others cannot.\n\nD. All seven computations $u_1$ through $u_7$ can be hoisted to the outer loop preheader because none writes memory directly.",
            "solution": "### Solution Derivation\n\nTo be hoisted to the preheader of the outer loop, a computation must be invariant with respect to *both* the outer loop (indexed by $i$) and the inner loop (indexed by $j$). Additionally, the transformation must be safe, meaning it cannot alter the program's observable behavior, such as side effects or potential exceptions. We will analyze each computation individually.\n\n- **$u_1 \\gets M \\cdot N$**\n    - The operands are $M$ and $N$.\n    - According to the problem statement, $M$ and $N$ are set before the loops begin and are not modified within either loop.\n    - Therefore, their values are constant throughout all iterations of both the inner and outer loops.\n    - The computation $M \\cdot N$ is consequently loop-invariant with respect to both loops.\n    - The computation has no side effects. Hoisting it does not change program semantics.\n    - **Conclusion:** $u_1$ can be hoisted to the outer loop preheader.\n\n- **$u_2 \\gets N - 1$**\n    - The operands are $N$ and the constant $1$.\n    - As established, $N$ is invariant with respect to both loops.\n    - The computation $N - 1$ is therefore loop-invariant with respect to both loops.\n    - This operation has no side effects.\n    - **Conclusion:** $u_2$ can be hoisted to the outer loop preheader.\n\n- **$u_3 \\gets i \\cdot N$**\n    - The operands are $i$ and $N$.\n    - $N$ is loop-invariant.\n    - $i$ is the index of the outer loop. Its value changes with each iteration of the outer loop (from $0$ to $M-1$).\n    - Since an operand ($i$) changes value across iterations of the outer loop, the computation $i \\cdot N$ is *not* invariant with respect to the outer loop.\n    - Therefore, it cannot be hoisted to the preheader of the outer loop. (It is, however, invariant with respect to the inner loop and could be hoisted into the body of the outer loop, but that is not the question asked).\n    - **Conclusion:** $u_3$ cannot be hoisted to the outer loop preheader.\n\n- **$u_4 \\gets f(M)$**\n    - The operand is $M$.\n    - $M$ is invariant with respect to both loops.\n    - The function $f$ is specified to be *pure*, meaning its return value depends only on its argument and it has no side effects.\n    - Since the argument $M$ is invariant, the result of $f(M)$ is also invariant with respect to both loops.\n    - Hoisting this computation is safe because $f$ has no side effects and the problem implies no new exceptions will be introduced.\n    - **Conclusion:** $u_4$ can be hoisted to the outer loop preheader.\n\n- **$u_5 \\gets h()$**\n    - The function $h()$ has no explicit arguments but depends on the state of the global counter $G$. The problem states that $h$ \"reads and increments\" $G$.\n    - This constitutes a side effect (modifying $G$). In the original program, this side effect occurs $M \\cdot N$ times. Hoisting the call to the outer loop preheader would cause the side effect to occur only once. This would alter the program's semantics.\n    - Furthermore, the value of $G$ is modified in every inner loop iteration by both $h()$ and the explicit `G \\gets G + 1`. This means the value of $G$ at the time of each call to $h()$ is different, so the return value of $h()$ is not constant. The computation is not loop-invariant.\n    - **Conclusion:** $u_5$ cannot be hoisted due to both lack of invariance and change in side-effect behavior.\n\n- **$u_6 \\gets A[0]$**\n    - The computation is a memory read from address $A[0]$. Its value depends on the contents of the array $A$ at index $0$.\n    - We must check if $A[0]$ is modified within the loops. The only modification to array $A$ is the statement $A[i] \\gets u_7 + u_3$.\n    - The outer loop index $i$ ranges from $0$ to $M-1$. Since $M$ is a positive integer, the loop executes for $i=0$.\n    - When $i=0$, the assignment becomes $A[0] \\gets u_7 + u_3$. This statement is executed for every iteration of the inner loop (i.e., for $j=0, \\dots, N-1$).\n    - Thus, the value at $A[0]$ is modified repeatedly within the loops.\n    - The value read by $u_6 \\gets A[0]$ is not constant across all iterations. The computation is not loop-invariant.\n    - **Conclusion:** $u_6$ cannot be hoisted.\n\n- **$u_7 \\gets B[j]$**\n    - The computation is a memory read from address $B[j]$. Its value depends on the index $j$ and the contents of array $B$.\n    - The problem states that array $B$ is not modified within the loops, so its contents are invariant.\n    - However, the index $j$ is the induction variable of the inner loop. Its value changes with each iteration of the inner loop.\n    - Since an operand ($j$) changes, the computation $B[j]$ is not invariant with respect to the inner loop, and thus cannot be invariant with respect to the nested loop structure as a whole.\n    - **Conclusion:** $u_7$ cannot be hoisted.\n\n**Summary of Analysis:**\n- $u_1$: Hoistable.\n- $u_2$: Hoistable.\n- $u_3$: Not hoistable (depends on outer loop index $i$).\n- $u_4$: Hoistable.\n- $u_5$: Not hoistable (side effects, not invariant).\n- $u_6$: Not hoistable (operand $A[0]$ is modified in the loop).\n- $u_7$: Not hoistable (depends on inner loop index $j$).\n\nThe computations that can be safely hoisted to the outer loop preheader are $u_1$, $u_2$, and $u_4$.\n\n### Option-by-Option Analysis\n\n- **A. $u_1$, $u_2$, and $u_4$ can be hoisted to the outer loop preheader; the others cannot.**\n  - This statement aligns perfectly with our detailed analysis. Each of $u_1$, $u_2$, and $u_4$ are invariant with respect to both loops and their hoisting is safe. Each of $u_3$, $u_5$, $u_6$, and $u_7$ are not hoistable for the reasons derived above.\n  - Verdict: **Correct**.\n\n- **B. $u_1$, $u_2$, $u_3$, and $u_4$ can be hoisted to the outer loop preheader; the others cannot.**\n  - This option incorrectly includes $u_3$. The computation $u_3 \\gets i \\cdot N$ depends on the outer loop index $i$, so it is not invariant with respect to the outer loop and cannot be moved to its preheader.\n  - Verdict: **Incorrect**.\n\n- **C. $u_1$, $u_2$, $u_4$, and $u_6$ can be hoisted to the outer loop preheader; the others cannot.**\n  - This option incorrectly includes $u_6$. The computation $u_6 \\gets A[0]$ is not loop-invariant because the value at $A[0]$ is modified within the loop when $i=0$.\n  - Verdict: **Incorrect**.\n\n- **D. All seven computations $u_1$ through $u_7$ can be hoisted to the outer loop preheader because none writes memory directly.**\n  - This option is incorrect for two reasons. First, the premise \"because none writes memory directly\" is not the correct criterion for hoisting; the criteria are loop-invariance and safety. Second, the conclusion is false; we have demonstrated that $u_3$, $u_5$, $u_6$, and $u_7$ cannot be hoisted.\n  - Verdict: **Incorrect**.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "A computation being loop-invariant is necessary, but not sufficient, for safe code motion. This problem () explores the critical role of control flow, demonstrating how constructs like `break` statements can prevent a seemingly valid optimization. The core principle is that hoisting is illegal if it causes a statement with side effects to execute under conditions where it would not have in the original program, thus altering the program's observable behavior.",
            "id": "3654712",
            "problem": "Consider the following loop in a conventional imperative language with a sequential consistency memory model and the usual call-by-value procedure call semantics. A transformation is semantics-preserving if, for every input, the sequence of externally observable events (for example, input/output, volatile writes, raised exceptions, and nontermination versus termination) is unchanged. A statement is loop-invariant with respect to a loop if all the values it reads are defined outside the loop or by computations whose values do not change across iterations, and the statement itself does not depend on the loop’s iteration index except through such invariant values. Loop-invariant code motion seeks to move such statements from the loop body to a preheader, provided doing so does not change the set or order of externally observable events.\n\nAssume the code:\nint i = 0;\nwhile (i  n) {\n    if (i == t) break;\n    if (i == 0) compute(t);\n    use(i);\n    i = i + 1;\n}\nHere, $i$, $n$, and $t$ are integers, and $compute(t)$ is a call that may perform side effects. The phrase “side effects observable only if the loop enters” means that any externally observable event performed by $compute(t)$ in the original program can only occur on executions where the loop body executes at least once. You may assume that $t$ is not modified in the loop and that $use(i)$ has no side effects that interfere with $compute(t)$.\n\nA compiler considers hoisting $compute(t)$ to the loop preheader. Analyze the legality of this transformation with respect to the definition of semantics preservation above, taking into account the early $break$ on the condition $i==t$ and the conditional execution of $compute(t)$ on the first iteration only.\n\nWhich of the following statements are correct?\n\nA. Unconditionally hoisting $compute(t)$ before the loop is not semantics-preserving because when $t=0$ the original program executes $break$ before $compute(t)$ on the first iteration and thus performs no side effects from $compute(t)$. A semantics-preserving transformation is to hoist with a guard that matches the original execution condition, for example, execute $compute(t)$ before the loop only if $(n>0) \\land (t \\neq 0)$.\n\nB. Unconditionally hoisting $compute(t)$ before the loop is semantics-preserving because the side effects are observable only if the loop enters, and moving $compute(t)$ earlier does not affect whether the loop enters.\n\nC. It is sufficient for legality that $t$ be loop-invariant; the $break$ condition $i==t$ does not affect the correctness of hoisting.\n\nD. Unconditionally hoisting is semantics-preserving if $compute$ is free of side effects and exceptions; otherwise, it is not semantics-preserving.",
            "solution": "### Solution Derivation\n\nThe core of the problem is to determine if moving the statement `compute(t)` from inside the loop to before the loop preserves the program's semantics. A transformation is semantics-preserving if the set and order of observable events are identical between the original and transformed programs for all possible inputs `n` and `t`. The primary observable event here is the potential side effect of `compute(t)`.\n\n**1. Analysis of the Original Program**\n\nIn the original code, the call to `compute(t)` is executed if and only if a specific set of conditions is met:\n1.  The loop body must be entered. The loop condition is `i  n`. Initially, `i` is $0$, so the loop is entered if and only if $0  n$.\n2.  The `break` statement must not be executed before the call to `compute(t)`. The call is on the first iteration where `i` is $0$. The `break` condition `i == t` is checked before the call. Therefore, for `compute(t)` to be reached, the condition `i == t` must be false when `i` is $0$. This means $t \\neq 0$.\n3.  The statement `if (i == 0) compute(t);` must be executed. This happens only on the first iteration when `i` is indeed $0$.\n\nCombining these conditions, `compute(t)` is executed in the original program if and only if:\n$$(n > 0) \\land (t \\neq 0)$$\n\n**2. Analysis of the Transformed Program**\n\nThe proposed transformation is to unconditionally hoist `compute(t)` to the loop's preheader. The transformed code would be:\n```\nint i = 0;\ncompute(t); // Hoisted call\nwhile (i  n) {\n    if (i == t) break;\n    // Original call at i=0 is removed\n    use(i);\n    i = i + 1;\n}\n```\nIn this transformed program, `compute(t)` is executed unconditionally, for all inputs `n` and `t`, before the loop is evaluated.\n\n**3. Comparison and Legality**\n\n-   **Original Program**: `compute(t)` executes if and only if $(n > 0) \\land (t \\neq 0)$.\n-   **Transformed Program**: `compute(t)` executes always.\n\nThe execution conditions are different. Let's identify counterexamples where the semantics diverge. Since `compute(t)` may have side effects, any execution in the transformed program that does not occur in the original violates semantic preservation.\n\n-   **Counterexample 1**: Let $n = 0$.\n    -   Original: The loop condition `0  0` is false. The loop body is never entered. `compute(t)` is not called. No side effect occurs.\n    -   Transformed: `compute(t)` is called. A side effect occurs.\n    -   The semantics are not preserved.\n\n-   **Counterexample 2**: Let $n > 0$ and $t = 0$.\n    -   Original: The loop is entered. In the first iteration, `i` is $0$. The condition `if (i == t)` becomes `if (0 == 0)`, which is true. The `break` statement is executed, and the loop terminates immediately. The line `if (i == 0) compute(t);` is never reached. No side effect occurs.\n    -   Transformed: `compute(t)` is called before the loop. A side effect occurs.\n    -   The semantics are not preserved.\n\nTherefore, unconditionally hoisting `compute(t)` is **not a semantics-preserving** transformation because it may introduce side effects that were not present in the original program. The statement `compute(t)` itself is loop-invariant (as `t` is invariant), but moving it is illegal due to the change in the program's control flow.\n\n### Option-by-Option Analysis\n\n**A. Unconditionally hoisting `compute(t)` before the loop is not semantics-preserving because when `t=0` the original program executes `break` before `compute(t)` on the first iteration and thus performs no side effects from `compute(t)`. A semantics-preserving transformation is to hoist with a guard that matches the original execution condition, for example, execute `compute(t)` before the loop only if $(n>0) \\land (t \\neq 0)$.**\n\nThis statement makes two claims.\n1.  It claims unconditional hoisting is not semantics-preserving and provides the reason that for `t=0`, the `break` is taken, preventing the execution of `compute(t)`. As shown in Counterexample 2 above, this reasoning is correct.\n2.  It proposes an alternative, guarded transformation: `if ((n > 0)  (t != 0)) compute(t);` placed before the loop. The condition $(n > 0) \\land (t \\neq 0)$ is precisely the condition we derived for the execution of `compute(t)` in the original program. This guarded hoist would execute `compute(t)` under the exact same circumstances as the original, thus being semantics-preserving (assuming the original call is removed from the loop).\nBoth parts of the statement are accurate.\n**Verdict: Correct**\n\n**B. Unconditionally hoisting `compute(t)` before the loop is semantics-preserving because the side effects are observable only if the loop enters, and moving `compute(t)` earlier does not affect whether the loop enters.**\n\nThis reasoning is flawed. While moving the code doesn't change the loop entry condition `i  n`, it ignores the two critical scenarios where the transformation fails:\n1.  When the loop does not enter at all (e.g., $n \\le 0$). The original program has no side effect, but the transformed one does.\n2.  When the loop enters but exits before the call (e.g., $t=0$). The original has no side effect, but the transformed one does.\nThe argument is a non-sequitur.\n**Verdict: Incorrect**\n\n**C. It is sufficient for legality that `t` be loop-invariant; the `break` condition `i==t` does not affect the correctness of hoisting.**\n\nThis statement is fundamentally incorrect. The fact that a computation is loop-invariant is a necessary, but not sufficient, condition for safe code motion. The control flow path to the statement is equally important. As demonstrated with the `t=0` counterexample, the `break` statement is a crucial part of the control flow that determines whether `compute(t)` is executed. Ignoring it leads to an incorrect analysis.\n**Verdict: Incorrect**\n\n**D. Unconditionally hoisting is semantics-preserving if `compute` is free of side effects and exceptions; otherwise, it is not semantics-preserving.**\n\nThis statement presents a dichotomy. Let's analyze both parts.\n1.  \"...if `compute` is free of side effects and exceptions...\": If `compute(t)` has no externally observable events (no I/O, no volatile writes, no exceptions, and it terminates), then calling it is semantically equivalent to a no-op. In this case, adding an extra call before the loop has no observable effect, making the transformation semantics-preserving. This part is correct.\n2.  \"...otherwise, it is not semantics-preserving.\": This means if `compute(t)` *does* have side effects or can raise an exception, the transformation is not semantics-preserving. Our main analysis above confirms this. For inputs like $n \\le 0$ or $t=0$, the hoisted version introduces side effects that did not exist in the original program. This part is also correct.\nThe statement provides a complete and correct rule for the legality of this specific transformation under all possible properties of `compute`.\n**Verdict: Correct**\n\nSince both options A and D are correct statements, both should be selected.",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "We now tackle one of the most challenging aspects of compiler optimization: pointer aliasing. This exercise () uses the common C function `strlen` to illustrate how memory writes through pointers can invalidate the invariance of a computation. To safely hoist a call like `strlen(s)`, a compiler must perform alias analysis to prove that no writes within the loop can modify the memory region read by the function, which includes the string's characters and its terminating null byte.",
            "id": "3654728",
            "problem": "You are optimizing a loop in the C programming language by performing loop-invariant code motion on the call $\\mathrm{strlen}(s)$. Consider a function that, in each iteration, performs one or more stores through pointers that may be related to $s$ and accumulates $\\mathrm{strlen}(s)$ into a loop-carried variable. Assume the standard C abstract machine semantics: $\\mathrm{strlen}(s)$ reads successive bytes at addresses $s, s + 1, s + 2, \\dots$ until it finds a byte equal to $0$, and returns the number of nonzero bytes encountered before the first $0$. Also assume that the only effects relevant to the observable behavior are the values computed and the memory writes performed by the loop.\n\nLet the loop body perform stores whose set of possible destination addresses is $W$ during the loop execution. Let $L$ denote the index of the first $0$ byte in the sequence beginning at $s$ at loop entry, so $\\mathrm{strlen}(s)$ at loop entry equals $L$. Define the read-footprint of $\\mathrm{strlen}(s)$ at loop entry as the set\n$$\nR_s \\;=\\; \\{\\, s + k \\mid 0 \\le k \\le L \\,\\}.\n$$\nA necessary and sufficient high-level condition for safely hoisting $\\mathrm{strlen}(s)$ out of the loop is that the value returned by $\\mathrm{strlen}(s)$ is identical in every iteration, and moving the call out does not change the set and values of memory writes or other observable effects.\n\nWhich of the following sets of conditions are sufficient for a compiler to soundly hoist the call to $\\mathrm{strlen}(s)$ out of the loop, under the C abstract machine, even when $s$ may alias other pointers used for writes in the loop?\n\nA. Prove that $s$ is not reassigned within the loop, that the lifetime of the object containing $s$ covers the loop, and that for all store addresses $a \\in W$ we have $a \\notin R_s$. No further assumptions are made about the values written. Under these conditions, the address set read by $\\mathrm{strlen}(s)$ and the bytes it observes are invariant across iterations.\n\nB. Prove that the loop never writes the value $0$ to memory and that $s$ is not reassigned within the loop. Aliasing between $s$ and the store addresses in $W$ is otherwise unrestricted.\n\nC. Prove that the object to which $s$ points at loop entry is disjoint from every object that the loop may write (for example, by establishing that all stores in $W$ target objects proven non-overlapping with the object denoted by $s$, such as via the C $\\mathtt{restrict}$ qualifier or precise object-based alias analysis), that $s$ is not reassigned within the loop, and that the lifetime of the object pointed to by $s$ covers the loop.\n\nD. Prove only that the loop never writes through the expression $*s$ (no assignments directly via $s$), but allow writes through other pointers that may equal $s + k$ for some $k \\ge 0$. Assume $s$ is not reassigned within the loop.\n\nE. Prove that for all store addresses $a \\in W$, either $a  s$ or $a  s + L$, and allow writes to $s + L$ provided the value written is nonzero. Assume $s$ is not reassigned within the loop and that $L$ is the value of $\\mathrm{strlen}(s)$ at loop entry.\n\nSelect all options that are sufficient. Justify your choice by appealing to the definitions of loop-invariant code motion, the semantics of $\\mathrm{strlen}$, and aliasing in C, without relying on unproven heuristics. Your reasoning should make clear what must hold about $W$, $R_s$, $s$, and the bytes that determine the value of $\\mathrm{strlen}(s)$ for hoisting to be semantics-preserving.",
            "solution": "The core of the problem is to identify sufficient conditions for safely hoisting a call to `$\\mathrm{strlen}(s)$` out of a loop. For this optimization to be valid, two main properties must hold:\n1.  **Invariance**: The value returned by `$\\mathrm{strlen}(s)$` must be the same in every iteration of the loop.\n2.  **Safety**: Moving the call must not change the observable behavior of the program, which includes the set and values of memory writes.\n\nThe value of `$\\mathrm{strlen}(s)$` is determined by two factors: the address contained in the pointer `s`, and the sequence of byte values in memory starting at that address, up to the first null byte (a byte with value $0$). Let $L$ be the value of `$\\mathrm{strlen}(s)$` at loop entry. This means the bytes at addresses $s, s+1, \\dots, s+L-1$ are non-zero, and the byte at address $s+L$ is $0$. The set of memory locations read by this initial call is defined as $R_s = \\{s + k \\mid 0 \\le k \\le L\\}$.\n\nFor `$\\mathrm{strlen}(s)$` to be loop-invariant, its value must not change. This requires:\n- The pointer `s` itself must not be reassigned within the loop. All options correctly presuppose this.\n- The memory contents within $R_s$ must not be modified by the loop's writes ($W$) in a way that changes the string's length. Specifically:\n    - No write should change a non-zero byte at an address $s+k$ (where $0 \\le k  L$) to a zero byte, as this would shorten the string.\n    - No write should change the zero byte at address $s+L$ to a non-zero byte, as this would lengthen the string.\n\nWe will now evaluate each option against these requirements.\n\n**A. Prove that $s$ is not reassigned within the loop, that the lifetime of the object containing $s$ covers the loop, and that for all store addresses $a \\in W$ we have $a \\notin R_s$. No further assumptions are made about the values written. Under these conditions, the address set read by $\\mathrm{strlen}(s)$ and the bytes it observes are invariant across iterations.**\n\n- **Analysis**: This option provides three conditions:\n    1. $s$ is not reassigned. This ensures the pointer itself is invariant.\n    2. The object's lifetime covers the loop. This ensures $s$ does not become a dangling pointer, so reads from $R_s$ are valid.\n    3. For all store addresses $a \\in W$, $a \\notin R_s$. The set of store destinations $W$ is disjoint from the read-footprint $R_s = \\{s+k \\mid 0 \\le k \\le L\\}$. This means no write inside the loop can modify any byte from the beginning of the string up to and including its original null terminator.\n    \n    Since no byte in $R_s$ is modified, the bytes at $s, \\dots, s+L-1$ remain non-zero, and the byte at $s+L$ remains zero. Consequently, `$\\mathrm{strlen}(s)$` will evaluate to $L$ in every single iteration. The call is therefore loop-invariant. Hoisting the call is safe because the set of memory writes $W$ is unaffected, and the reads performed by the hoisted call are from a memory region ($R_s$) that is not written to by the loop, so the timing of the reads does not matter.\n- **Verdict**: **Correct**. This is a classic and direct sufficient condition for hoisting.\n\n**B. Prove that the loop never writes the value $0$ to memory and that $s$ is not reassigned within the loop. Aliasing between $s$ and the store addresses in $W$ is otherwise unrestricted.**\n\n- **Analysis**: This option prevents the string from being shortened by a write, because no non-zero byte within the string can be changed to $0$. However, it does not prevent the string from being lengthened. Aliasing is unrestricted, so a write could occur at the address $s+L$, which contains the null terminator. The condition states only that the value written cannot be $0$. If a non-zero value is written to $s+L$, the null terminator is overwritten. The `$\\mathrm{strlen}$` function will then continue scanning past $s+L$ to find the next null byte, resulting in a length greater than $L$. Since the value of `$\\mathrm{strlen}(s)$` can change, it is not loop-invariant.\n- **Verdict**: **Incorrect**.\n\n**C. Prove that the object to which $s$ points at loop entry is disjoint from every object that the loop may write (for example, by establishing that all stores in $W$ target objects proven non-overlapping with the object denoted by $s$, such as via the C $\\mathtt{restrict}$ qualifier or precise object-based alias analysis), that $s$ is not reassigned within the loop, and that the lifetime of the object pointed to by $s$ covers the loop.**\n\n- **Analysis**: This condition leverages the C memory model's concept of \"objects\". An object is a region of storage. If the compiler can prove that the object containing the string (let's call it $O_s$) is disjoint from any object written to by the loop, it means that no write within the loop can modify any byte of $O_s$. The read-footprint $R_s = \\{s+k \\mid 0 \\le k \\le L\\}$ is necessarily a subset of the addresses comprising the object $O_s$. Since the set of written addresses $W$ is disjoint from all addresses in $O_s$, it must also be disjoint from $R_s$. This means $W \\cap R_s = \\emptyset$. This condition is therefore a more abstract but stronger version of the condition in Option A. Since the condition in A is sufficient, this one must also be sufficient.\n- **Verdict**: **Correct**.\n\n**D. Prove only that the loop never writes through the expression $*s$ (no assignments directly via $s$), but allow writes through other pointers that may equal $s + k$ for some $k \\ge 0$. Assume $s$ is not reassigned within the loop.**\n\n- **Analysis**: This condition is based on the syntactic form of an expression, not its semantic meaning. It only prohibits writes of the form `$*s = \\dots$` or `$s[0] = \\dots$`. It explicitly allows writes through other pointers that may be aliases for locations within the string. For example, if a pointer $p$ is initialized to $s$ before the loop, a write like `$*p = '\\0';$` inside the loop would be permitted. This would shorten the string's length to $0$. Similarly, if $q = s+L$, a write `$*q = 'X';$` would lengthen the string. An optimizing compiler must be sound with respect to all possible aliasing, so this purely syntactic restriction is insufficient.\n- **Verdict**: **Incorrect**.\n\n**E. Prove that for all store addresses $a \\in W$, either $a  s$ or $a  s + L$, and allow writes to $s + L$ provided the value written is nonzero. Assume $s$ is not reassigned within the loop and that $L$ is the value of $\\mathrm{strlen}(s)$ at loop entry.**\n\n- **Analysis**: This option is logically contradictory. The first clause, \"for all store addresses $a \\in W$, either $a  s$ or $a > s + L$,\" states that no writes occur in the memory range $[s, s+L]$. This means, in particular, that no write can occur at address $s+L$. The next clause, \"allow writes to $s+L$...\", directly contradicts the first. A set of conditions that is internally inconsistent cannot be a valid basis for any logical deduction, and thus cannot be a sufficient condition.\nEven if we attempt a charitable reinterpretation where the first clause applies to the range $[s, s+L-1]$ and the second clause is a special rule for $s+L$, the condition is still insufficient. Allowing non-zero writes to $s+L$ means allowing the null terminator to be overwritten, which can lengthen the string, as explained in the analysis of option B.\n- **Verdict**: **Incorrect**.",
            "answer": "$$\\boxed{AC}$$"
        }
    ]
}