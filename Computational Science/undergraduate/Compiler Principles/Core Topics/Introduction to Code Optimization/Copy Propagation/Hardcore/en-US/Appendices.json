{
    "hands_on_practices": [
        {
            "introduction": "Copy propagation seems simple, but its safety hinges on proving that two variables hold the same value at a given program point. This proof can be invalidated by assignments, especially subtle ones hidden within function calls that operate on pointers or references. This exercise  tests your ability to perform this safety analysis, challenging you to trace a copy relationship across a function call that may modify one of the variables, a critical skill for building correct optimizers.",
            "id": "3634027",
            "problem": "Consider a straight-line snippet in an Intermediate Representation (IR), a three-address-code-like form, inside a single-threaded procedure $F$ with local scalar variables $x$, $y$, $w$, $v$ and a call to a procedure $h$ that takes the address of a local variable. The symbol $\\$ denotes the address-of operator, and argument passing is by reference in the sense that $h$ may write through the passed pointer. Assume a standard intraprocedural Control Flow Graph (CFG), which is the directed graph of basic blocks connected by control flow, that is linear and evaluation is strictly in program order. The snippet is:\n\n- Statement 1: $x := y$\n- Statement 2: $h(\\y)$\n- Statement 3: $w := y + 1$\n- Statement 4: $y := x$\n- Statement 5: $v := y + 2$\n- Statement 6: $\\mathrm{return}\\; w + v$\n\nAssumptions about $h$:\n- $h$ may write to the memory location designated by its parameter, i.e., $h(\\y)$ may assign to $y$.\n- $h$ does not access any memory through the address of $x$; no other aliases to $x$ or $y$ exist except the explicit $\\y$ in Statement 2.\n- $h$ has no hidden side effects on $x$ and does not perform concurrency, and there are no asynchronous effects.\n\nA compiler attempts flow-sensitive copy propagation, whose goal is to replace uses of a variable with another variable when it is provably equal, based on the following fundamental bases:\n\n- Semantics of assignment: At Statement 1, $x := y$ sets $x$ to the current value stored in $y$.\n- Semantics of call-by-reference: At Statement 2, $h(\\y)$ may mutate $y$; this is equivalent to some write to $y$ occurring during Statement 2, but $x$ is not written by $h$.\n- Data-flow safety condition for copy propagation: Replacing a use of $y$ with $x$ is sound only if along all paths from the definition establishing $x = y$ to that use, there is no intervening write to either $x$ or $y$ (including indirect writes via aliasing).\n\nUnder these assumptions, which of the following replacements of $y$ by $x$ are guaranteed semantics-preserving?\n\nA. Replace $y$ by $x$ in Statements 3 and 5.\n\nB. Replace $y$ by $x$ only in Statement 5.\n\nC. Replace $y$ by $x$ only in Statement 3.\n\nD. No replacement of $y$ by $x$ is sound in Statements 3 and 5.\n\nSelect the single best choice.",
            "solution": "The problem asks us to determine where a use of variable $y$ can be safely replaced by variable $x$. We must perform a flow-sensitive analysis to track the validity of the copy fact $x=y$ throughout the program snippet.\n\n1.  **After Statement 1 ($x := y$):** This assignment *generates* the copy fact $x=y$. This equality holds immediately after this statement.\n\n2.  **During Statement 2 ($h(\\y)$):** The function $h$ is called with the address of $y$ and is permitted to write to $y$. For a sound optimization, the compiler must assume a worst-case scenario: that $h$ does, in fact, modify $y$. This potential modification of $y$ *kills* the copy fact $x=y$, because the value of $y$ is no longer guaranteed to be the same as the value of $x$.\n\n3.  **At Statement 3 ($w := y + 1$):** To propagate $x$ for $y$ here, the equality $x=y$ must be guaranteed on all paths leading to this point from the original copy statement. The path from Statement 1 to Statement 3 includes the call to $h$ in Statement 2. Since this call kills the copy fact, we cannot guarantee $x=y$ at this point. Therefore, replacing $y$ with $x$ in Statement 3 is **unsafe**.\n\n4.  **After Statement 4 ($y := x$):** This new assignment *re-generates* the copy fact $x=y$. At the program point immediately following this statement, it is guaranteed that $x$ and $y$ hold the same value.\n\n5.  **At Statement 5 ($v := y + 2$):** The path from the new copy statement (Statement 4) to this use of $y$ contains no intervening writes to either $x$ or $y$. Therefore, the equality $x=y$ still holds. Replacing $y$ with $x$ in Statement 5 is **safe**.\n\n**Conclusion:** The replacement is unsafe at Statement 3 but safe at Statement 5. This corresponds to option B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "A compiler's view of a program is a graph of control flow paths. When these paths diverge and then rejoin, an optimizer must correctly merge information from all possible execution histories. This problem  contrasts how a traditional dataflow analysis and a modern SSA-based analysis handle copy propagation at a control flow join, illustrating the elegance and power that Static Single Assignment (SSA) form and its $\\phi$-functions bring to this task.",
            "id": "3633986",
            "problem": "Consider a Control Flow Graph (CFG) consisting of four basic blocks $B_0$, $B_1$, $B_2$, and $B_3$. The block $B_0$ contains a conditional based on a predicate $c$ and branches to $B_1$ if $c$ is true, otherwise to $B_2$. The blocks $B_1$ and $B_2$ join at $B_3$. The program fragment is as follows, where the symbol $:=$ denotes assignment:\n\n- In $B_1$: $x := y$.\n- In $B_2$: $x := z$.\n- In $B_3$: $w := x$.\n\nAssume $y$ and $z$ are defined prior to $B_0$ and neither $y$ nor $z$ is modified in $B_1$ or $B_2$. Also assume $x$ is defined only by the assignments shown in $B_1$ and $B_2$. There are no side effects or aliasing that affect $x$, $y$, $z$, or $w$.\n\nYou are to reason from foundational definitions in compiler principles:\n\n- A Control Flow Graph (CFG) is a directed graph whose nodes are basic blocks and whose edges represent possible control flow transfers. At a join node, multiple predecessors converge and a subsequent statement executes regardless of which predecessor was taken.\n- Static Single Assignment (SSA) form is a representation in which each variable is assigned exactly once; at join points, special $\\phi$-functions merge the values coming from different predecessors. The semantics of a $\\phi$-function $u := \\phi(u_1, u_2)$ at a join with predecessors $P_1$ and $P_2$ is: if control comes from $P_1$, then $u$ takes $u_1$, otherwise $u$ takes $u_2$.\n- Classical copy propagation (without SSA) is a forward dataflow optimization that replaces the use of a variable $u$ with a source variable $v$ when the assignment $u := v$ is the unique reaching copy along all paths to the use, and when $v$ is not redefined along those paths. A reaching copy is a copy assignment not killed by a redefinition of its left-hand side on the path to the use.\n\nTransform the program to SSA and then analyze how SSA-based copy propagation interacts with $\\phi$-functions at the join compared to classical dataflow copy propagation at the same join. Which of the following statements are correct under the given assumptions?\n\nA. In the classical non-SSA representation, at $B_3$ the statement $w := x$ cannot be transformed into either $w := y$ or $w := z$ by copy propagation, because distinct copies $x := y$ and $x := z$ reach the use of $x$ along different paths.\n\nB. In SSA form, the fragment becomes $x_1 := y$ in $B_1$, $x_2 := z$ in $B_2$, and at $B_3$ the statements $x_3 := \\phi(x_1, x_2)$ and $w_1 := x_3$. SSA-based copy propagation can replace the $\\phi$-arguments with their sources to obtain $x_3 := \\phi(y, z)$, and then eliminate the copy $w_1 := x_3$ by substituting all uses of $w_1$ with $x_3$.\n\nC. In SSA form, because both predecessor assignments are copies, the $\\phi$-function $x_3 := \\phi(x_1, x_2)$ can be simplified to $x_3 := y$ at the join, making $w_1 := x_3$ further reducible to $w_1 := y$.\n\nD. In the classical non-SSA representation, introducing $w := \\phi(y, z)$ at $B_3$ to replace $w := x$ is a valid copy propagation step, because it accurately merges the reaching copies into a single expression at the join.\n\nE. A classical copy propagation pass may legally transform the join into a conditional expression $w := c ? y : z$ to eliminate $x$, because this maintains the same semantics as the original CFG.\n\nSelect all correct options.",
            "solution": "The problem requires comparing classical dataflow analysis with SSA-based analysis for copy propagation at a control-flow join.\n\n**A. Analysis with Classical (non-SSA) Copy Propagation**\nThe goal is to optimize the statement $w := x$ in block $B_3$. According to the definition of classical copy propagation, a replacement is only possible if a *unique* copy statement involving $x$ reaches this point along *all* paths.\n- On the path through $B_1$, the reaching copy is $x := y$.\n- On the path through $B_2$, the reaching copy is $x := z$.\nSince two different copy definitions for $x$ reach the join point $B_3$, the uniqueness condition is not met. The compiler cannot choose to propagate either $y$ or $z$, as doing so would be incorrect for the other path. Thus, classical copy propagation is blocked. **Statement A is correct.**\n\n**B. Analysis with SSA-based Copy Propagation**\nFirst, the fragment is converted to SSA form. Each assignment to $x$ gets a unique name, and a $\\phi$-function merges the values at the join point.\n- In $B_1$: $x_1 := y$\n- In $B_2$: $x_2 := z$\n- In $B_3$: $x_3 := \\phi(x_1, x_2)$, followed by $w_1 := x_3$.\n\nIn SSA, copy propagation can be applied to the arguments of the $\\phi$-function. The use of $x_1$ is replaced by $y$, and the use of $x_2$ is replaced by $z$. This transforms the $\\phi$-function into $x_3 := \\phi(y, z)$. Following this, the statement $w_1 := x_3$ is a copy. A subsequent pass can propagate $x_3$ to all uses of $w_1$, effectively eliminating the copy. **Statement B is correct.**\n\n**C. Invalid Simplification**\nThis statement suggests simplifying $x_3 := \\phi(x_1, x_2)$ to $x_3 := y$. This is incorrect. The $\\phi$-function correctly states that the value of $x_3$ depends on the path taken ($y$ from path 1, $z$ from path 2). Simplifying it to $x_3 := y$ would discard the value from the other path, altering the program's semantics unless it is known that $y=z$. **Statement C is incorrect.**\n\n**D. Invalid Concept**\nThe $\\phi$-function is a construct specific to the SSA intermediate representation. It is not part of a \"classical non-SSA representation,\" nor is inserting one a \"copy propagation step.\" This confuses two different compilation paradigms. **Statement D is incorrect.**\n\n**E. Incorrect Optimization Name**\nWhile the transformation $w := c ? y : z$ is semantically equivalent to the original control flow, it is known as **if-conversion** or **predication**, not copy propagation. This is a much more complex transformation. **Statement E is incorrect.**",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "Optimizing compilers frequently encounter long chains of copy assignments, often resulting from code generation patterns like inlining. Propagating these copies one-by-one can be slow. This practice problem  guides you through a powerful algorithmic technique using the Union-Find data structure to identify and collapse entire chains of equivalent variables in a much more efficient manner, demonstrating a practical approach to implementing this optimization.",
            "id": "3633963",
            "problem": "A compiler is optimizing a straight-line intermediate representation (IR) sequence derived from inlined object constructors that introduce redundant wrapper temporaries. The optimization under consideration is copy propagation, which replaces uses of a temporary by its source when it is safe to do so, and then removes dead copy assignments. The program is in Static Single Assignment (SSA) form, so every assignment gives a new versioned name. All wrappers are immutable, their inlined constructors are pure forwarders of the underlying reference, and the IR has no side-effecting operations except for arithmetic on scalars. In particular, a pure call that only reads its argument is present but does not modify any variable.\n\nUse the core definitions below as the fundamental base:\n- Copy propagation is defined on direct copies of the form $a := b$ where both $a$ and $b$ are scalar temporaries. Its safety is determined by value equality: if $a := b$ occurs and $b$ is not subsequently redefined in a way that affects the value reaching the uses of $a$, then any use of $a$ can be replaced by $b$ without changing program semantics.\n- Equality induced by copy statements on temporaries is an equivalence relation, yielding disjoint sets of names that denote the same value. A standard way to maintain these sets is the disjoint-set union (also known as union-find) data structure defined by operations $\\mathrm{find}$ to obtain a set representative and $\\mathrm{union}$ to merge two sets when a copy $a := b$ is observed.\n\nConsider the following SSA IR sequence in a single basic block, where inlined wrapper constructors yield chained copies. The instruction order is top-to-bottom, and SSA version subscripts indicate distinct definitions:\n1. $v_{1} := \\mathrm{load}(A)$\n2. $w_{1} := v_{1}$\n3. $x_{1} := w_{1}$\n4. $y_{1} := x_{1}$\n5. $\\mathrm{call\\_pure}(y_{1})$\n6. $v_{2} := v_{1} + 1$\n7. $w_{2} := v_{2}$\n8. $t_{1} := w_{2}$\n9. $u_{1} := t_{1}$\n10. $z_{1} := y_{1}$\n\nAssume:\n- $\\mathrm{load}(A)$ produces a fresh scalar value and does not alias any other variable.\n- $\\mathrm{call\\_pure}(y_{1})$ is a pure function that only reads its input; it does not write to memory or reassign any temporaries.\n- The arithmetic $v_{2} := v_{1} + 1$ defines a new SSA name $v_{2}$ with a value different from $v_{1}$; it does not modify $v_{1}$.\n\nApply a union-find based copy propagation that:\n- Performs $\\mathrm{union}(a,b)$ for each direct copy $a := b$ to construct equivalence classes of SSA names that denote the same value.\n- Chooses, for each equivalence class, the representative returned by $\\mathrm{find}$ to be the earliest SSA name in program order in that class.\n- Rewrites all uses of non-representative names to the class representative where it is semantics-preserving under the SSA and purity assumptions above.\n- Removes dead copy assignments that define a name which has no remaining distinct uses after rewriting.\n\nUnder these rules, determine the exact count of assignments of the form $a := b$ in the sequence above that are eliminated by this optimization. Express your final answer as a single integer. No rounding is required, and no physical units are involved.",
            "solution": "The problem asks for the number of copy assignments eliminated by a union-find based copy propagation algorithm on an SSA-form code sequence. The process involves building equivalence classes, rewriting uses, and then identifying dead assignments.\n\n**1. Construct Equivalence Classes**\nWe process the copy assignments to group variables that hold the same value. The representative for each group is the earliest variable in program order.\n- Instructions 2-4 ($w_1 := v_1$, $x_1 := w_1$, $y_1 := x_1$) and Instruction 10 ($z_1 := y_1$) create a chain of copies. This results in the equivalence class $C_1 = \\{v_1, w_1, x_1, y_1, z_1\\}$. The representative is $v_1$, as it is defined first.\n- Instructions 7-9 ($w_2 := v_2$, $t_1 := w_2$, $u_1 := t_1$) create another chain. This results in the equivalence class $C_2 = \\{v_2, w_2, t_1, u_1\\}$. The representative is $v_2$.\n\n**2. Rewrite Uses**\nNext, all uses of variables are replaced by their class representative.\n- $\\mathrm{call\\_pure}(y_{1})$ becomes $\\mathrm{find}(y_1)$ which is $\\mathrm{call\\_pure}(v_{1})$.\n- The right-hand side of every copy assignment is also replaced:\n  - $x_1 := w_1$ becomes $x_1 := v_1$.\n  - $y_1 := x_1$ becomes $y_1 := v_1$.\n  - $t_1 := w_2$ becomes $t_1 := v_2$.\n  - $u_1 := t_1$ becomes $u_1 := v_2$.\n  - $z_1 := y_1$ becomes $z_1 := v_1$.\n\n**3. Identify and Count Dead Assignments**\nA copy assignment is dead if the variable it defines is no longer used after the rewrite phase. We examine the seven original copy assignments:\n1.  $w_{1} := v_{1}$: The defined variable $w_1$ is no longer used (its only use in $x_{1} := w_{1}$ was updated). **Eliminated.**\n2.  $x_{1} := w_{1}$: The defined variable $x_1$ is no longer used. **Eliminated.**\n3.  $y_{1} := x_{1}$: The defined variable $y_1$ is no longer used (its uses in `call_pure` and $z_{1} := y_{1}$ were updated). **Eliminated.**\n4.  $w_{2} := v_{2}$: The defined variable $w_2$ is no longer used. **Eliminated.**\n5.  $t_{1} := w_{2}$: The defined variable $t_1$ is no longer used. **Eliminated.**\n6.  $u_{1} := t_{1}$: The defined variable $u_1$ had no uses to begin with. **Eliminated.**\n7.  $z_{1} := y_{1}$: The defined variable $z_1$ had no uses. **Eliminated.**\n\nAll seven of the original copy assignments are found to be dead code after propagation. Therefore, the total count of eliminated assignments is 7.",
            "answer": "$$\\boxed{7}$$"
        }
    ]
}