{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过动手实践来巩固。第一个练习将带你深入副本传播的核心算法。我们将模拟编译器如何处理一连串由内联构造函数产生的冗余临时变量，通过使用并查集（union-find）数据结构来识别和合并持有相同值的变量，最终清除无用的副本赋值，从而让你掌握这一优化的具体实现机制。",
            "id": "3633963",
            "problem": "一个编译器正在优化一个线性中间表示 (IR) 序列，该序列源自内联的对象构造函数，这些构造函数引入了冗余的包装器临时变量。所考虑的优化是复写传播，它在安全的情况下将临时变量的使用替换为其来源，然后移除死复写赋值。该程序采用静态单赋值 (SSA) 形式，因此每个赋值都会产生一个新的版本化名称。所有包装器都是不可变的，其内联构造函数是底层引用的纯转发器，并且除了标量上的算术运算外，该 IR 中没有副作用操作。特别地，存在一个只读取其参数的纯调用，它不修改任何变量。\n\n使用以下核心定义作为基本依据：\n- 复写传播定义在形式为 $a := b$ 的直接复写上，其中 $a$ 和 $b$ 都是标量临时变量。其安全性由值相等性确定：如果发生 $a := b$ 并且 $b$ 后续没有以影响到达 $a$ 的使用的值的方式被重新定义，则任何对 $a$ 的使用都可以被 $b$ 替换，而不会改变程序语义。\n- 由临时变量上的复写语句引起的相等性是一种等价关系，产生表示相同值的名称的不相交集合。维护这些集合的一种标准方法是不相交集并（也称为 union-find）数据结构，它由操作 $\\mathrm{find}$（用于获取集合代表元）和在观察到复写 $a := b$ 时用操作 $\\mathrm{union}$（用于合并两个集合）定义。\n\n考虑单个基本块中的以下 SSA IR 序列，其中内联的包装器构造函数产生链式复写。指令顺序是自上而下，SSA 版本下标表示不同的定义：\n1. $v_{1} := \\mathrm{load}(A)$\n2. $w_{1} := v_{1}$\n3. $x_{1} := w_{1}$\n4. $y_{1} := x_{1}$\n5. $\\mathrm{call\\_pure}(y_{1})$\n6. $v_{2} := v_{1} + 1$\n7. $w_{2} := v_{2}$\n8. $t_{1} := w_{2}$\n9. $u_{1} := t_{1}$\n10. $z_{1} := y_{1}$\n\n假设：\n- $\\mathrm{load}(A)$ 产生一个新的标量值，并且不与任何其他变量别名。\n- $\\mathrm{call\\_pure}(y_{1})$ 是一个只读取其输入的纯函数；它不写入内存或重新赋值任何临时变量。\n- 算术运算 $v_{2} := v_{1} + 1$ 定义了一个新的 SSA 名称 $v_{2}$，其值与 $v_{1}$ 不同；它不修改 $v_{1}$。\n\n应用一个基于 union-find 的复写传播，该传播：\n- 对每个直接复写 $a := b$ 执行 $\\mathrm{union}(a,b)$，以构造表示相同值的 SSA 名称的等价类。\n- 对每个等价类，选择由 $\\mathrm{find}$ 返回的代表元作为该类中按程序顺序最早的 SSA 名称。\n- 在上述 SSA 和纯度假设下，将所有非代表元名称的使用重写为该类的代表元，前提是这样做能保持语义。\n- 移除那些所定义的名称在重写后不再有任何不同使用的死复写赋值。\n\n根据这些规则，确定在上述序列中被此优化消除的形式为 $a := b$ 的赋值的确切数量。将最终答案表示为单个整数。不需要四舍五入，也不涉及物理单位。",
            "solution": "用户提供了一个编译器优化领域的问题，具体关注静态单赋值 (SSA) 中间表示 (IR) 指令序列中的复写传播。任务是确定通过一个基于 union-find 数据结构的特定算法所消除的复写赋值的数量。\n\n该问题是有效的，因为它在科学上基于已建立的编译器理论，问题定义良好，具有清晰和确定性的算法，并使用客观、形式化的语言。它是自洽且无矛盾的。我现在将进行解答。\n\n解答过程需要应用问题陈述中定义的三个阶段：\n1.  使用 union-find 数据结构，为持有相同值的变量构造等价类。\n2.  通过将所有临时变量的使用替换为其等价类的代表元来重写 IR。\n3.  识别并计数在重写阶段后变为死的（即，定义的变量不再被使用）复写赋值。\n\n初始 IR 序列如下：\n1.  $v_{1} := \\mathrm{load}(A)$\n2.  $w_{1} := v_{1}$\n3.  $x_{1} := w_{1}$\n4.  $y_{1} := x_{1}$\n5.  $\\mathrm{call\\_pure}(y_{1})$\n6.  $v_{2} := v_{1} + 1$\n7.  $w_{2} := v_{2}$\n8.  $t_{1} := w_{2}$\n9.  $u_{1} := t_{1}$\n10. $z_{1} := y_{1}$\n\n形式为 $a := b$ 的复写赋值是指令 $2$, $3$, $4$, $7$, $8$, $9$ 和 $10$。\n\n**阶段 1：构造等价类**\n\n我们将按程序顺序处理每个复写赋值以构建等价类。每个类的代表元被定义为该类中按程序顺序最早的 SSA 名称。\n\n- 最初，每个变量都在其自己的集合中：$\\{v_{1}\\}, \\{w_{1}\\}, \\{x_{1}\\}, \\{y_{1}\\}, \\{v_{2}\\}, \\{w_{2}\\}, \\{t_{1}\\}, \\{u_{1}\\}, \\{z_{1}\\}$。\n\n- 指令 2: $w_{1} := v_{1}$。我们执行 $\\mathrm{union}(w_{1}, v_{1})$。由于 $v_{1}$ 在 $w_{1}$ 之前定义，所以 $v_{1}$ 成为代表元。集合为 $\\{v_{1}, w_{1}\\}$。\n\n- 指令 3: $x_{1} := w_{1}$。我们执行 $\\mathrm{union}(x_{1}, w_{1})$。$w_{1}$ 所在集合的代表元是 $v_{1}$。由于 $v_{1}$ 在 $x_{1}$ 之前定义，所以 $v_{1}$ 仍然是代表元。集合变为 $\\{v_{1}, w_{1}, x_{1}\\}$。\n\n- 指令 4: $y_{1} := x_{1}$。我们执行 $\\mathrm{union}(y_{1}, x_{1})$。$x_{1}$ 所在集合的代表元是 $v_{1}$。由于 $v_{1}$ 在 $y_{1}$ 之前定义，所以 $v_{1}$ 仍然是代表元。集合变为 $\\{v_{1}, w_{1}, x_{1}, y_{1}\\}$。\n\n- 指令 7: $w_{2} := v_{2}$。我们执行 $\\mathrm{union}(w_{2}, v_{2})$。$v_{2}$ 在 $w_{2}$ 之前定义，所以 $v_{2}$ 是代表元。这形成了一个新的等价类 $\\{v_{2}, w_{2}\\}$。\n\n- 指令 8: $t_{1} := w_{2}$。我们执行 $\\mathrm{union}(t_{1}, w_{2})$。$w_{2}$ 所在集合的代表元是 $v_{2}$。由于 $v_{2}$ 在 $t_{1}$ 之前定义，所以 $v_{2}$ 仍然是代表元。集合变为 $\\{v_{2}, w_{2}, t_{1}\\}$。\n\n- 指令 9: $u_{1} := t_{1}$。我们执行 $\\mathrm{union}(u_{1}, t_{1})$。$t_{1}$ 所在集合的代表元是 $v_{2}$。由于 $v_{2}$ 在 $u_{1}$ 之前定义，所以 $v_{2}$ 仍然是代表元。集合变为 $\\{v_{2}, w_{2}, t_{1}, u_{1}\\}$。\n\n- 指令 10: $z_{1} := y_{1}$。我们执行 $\\mathrm{union}(z_{1}, y_{1})$。$y_{1}$ 所在集合的代表元是 $v_{1}$。由于 $v_{1}$ 在 $z_{1}$ 之前定义，所以 $v_{1}$ 仍然是代表元。第一个集合变为 $\\{v_{1}, w_{1}, x_{1}, y_{1}, z_{1}\\}$。\n\n处理完所有复写指令后，我们得到两个不相交的等价类：\n1.  $C_{1} = \\{v_{1}, w_{1}, x_{1}, y_{1}, z_{1}\\}$，对于任何 $s \\in C_{1}$，其代表元为 $\\mathrm{find}(s) = v_{1}$。\n2.  $C_{2} = \\{v_{2}, w_{2}, t_{1}, u_{1}\\}$，对于任何 $s \\in C_{2}$，其代表元为 $\\mathrm{find}(s) = v_{2}$。\n\n**阶段 2：重写 IR 使用**\n\n现在我们将每个变量的使用替换为其等价类的代表元。\n\n1.  $v_{1} := \\mathrm{load}(A)$\n2.  $w_{1} := v_{1}$ (右侧 $v_{1}$ 是代表元，无变化)\n3.  $x_{1} := w_{1} \\implies x_{1} := \\mathrm{find}(w_{1}) \\implies x_{1} := v_{1}$\n4.  $y_{1} := x_{1} \\implies y_{1} := \\mathrm{find}(x_{1}) \\implies y_{1} := v_{1}$\n5.  $\\mathrm{call\\_pure}(y_{1}) \\implies \\mathrm{call\\_pure}(\\mathrm{find}(y_{1})) \\implies \\mathrm{call\\_pure}(v_{1})$\n6.  $v_{2} := v_{1} + 1$ (右侧 $v_{1}$ 是代表元，无变化)\n7.  $w_{2} := v_{2}$ (右侧 $v_{2}$ 是代表元，无变化)\n8.  $t_{1} := w_{2} \\implies t_{1} := \\mathrm{find}(w_{2}) \\implies t_{1} := v_{2}$\n9.  $u_{1} := t_{1} \\implies u_{1} := \\mathrm{find}(t_{1}) \\implies u_{1} := v_{2}$\n10. $z_{1} := y_{1} \\implies z_{1} := \\mathrm{find}(y_{1}) \\implies z_{1} := v_{1}$\n\n重写后的 IR（在死代码消除之前）如下：\n1.  $v_{1} := \\mathrm{load}(A)$\n2.  $w_{1} := v_{1}$\n3.  $x_{1} := v_{1}$\n4.  $y_{1} := v_{1}$\n5.  $\\mathrm{call\\_pure}(v_{1})$\n6.  $v_{2} := v_{1} + 1$\n7.  $w_{2} := v_{2}$\n8.  $t_{1} := v_{2}$\n9.  $u_{1} := v_{2}$\n10. $z_{1} := v_{1}$\n\n**阶段 3：计数被消除的（死的）复写赋值**\n\n如果一个复写赋值所定义的变量在重写阶段后没有任何使用，则该赋值是死的。我们检查每一个原始的复写赋值。\n\n-   指令 2: $w_{1} := v_{1}$。定义的变量是 $w_{1}$。其唯一的原始使用是在指令 $3$ 中，该指令现在是 $x_{1} := v_{1}$。因此，$w_{1}$ 没有剩余的使用。该赋值是死的，被消除。\n-   指令 3: $x_{1} := w_{1}$。定义的变量是 $x_{1}$。其唯一的原始使用是在指令 $4$ 中，该指令现在是 $y_{1} := v_{1}$。因此，$x_{1}$ 没有剩余的使用。该赋值是死的，被消除。\n-   指令 4: $y_{1} := x_{1}$。定义的变量是 $y_{1}$。其原始使用是在指令 $5$ 和 $10$ 中，这两个指令现在是 $\\mathrm{call\\_pure}(v_{1})$ 和 $z_{1} := v_{1}$。因此，$y_{1}$ 没有剩余的使用。该赋值是死的，被消除。\n-   指令 7: $w_{2} := v_{2}$。定义的变量是 $w_{2}$。其唯一的原始使用是在指令 $8$ 中，该指令现在是 $t_{1} := v_{2}$。因此，$w_{2}$ 没有剩余的使用。该赋值是死的，被消除。\n-   指令 8: $t_{1} := w_{2}$。定义的变量是 $t_{1}$。其唯一的原始使用是在指令 $9$ 中，该指令现在是 $u_{1} := v_{2}$。因此，$t_{1}$ 没有剩余的使用。该赋值是死的，被消除。\n-   指令 9: $u_{1} := t_{1}$。定义的变量是 $u_{1}$。在给定的代码块中它没有原始的使用。它没有剩余的使用。该赋值是死的，被消除。\n-   指令 10: $z_{1} := y_{1}$。定义的变量是 $z_{1}$。在给定的代码块中它没有原始的使用。它没有剩余的使用。该赋值是死的，被消除。\n\n所有七个复写赋值都被消除了。最终优化后的代码将是：\n1. $v_{1} := \\mathrm{load}(A)$\n2. $\\mathrm{call\\_pure}(v_{1})$\n3. $v_{2} := v_{1} + 1$\n\n被消除的复写赋值的数量是 $7$。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "真实程序充满了分支和合并，这给编译器优化带来了挑战。本练习将探讨在控制流连接点（join point）进行副本传播的复杂性。通过对比传统的（非SSA）数据流分析与基于静态单赋值（SSA）形式的分析，你将深刻理解为什么SSA及其$\\phi$函数是现代编译器中解决数据流汇合问题的关键技术。",
            "id": "3633986",
            "problem": "考虑一个由四个基本块 $B_0$、$B_1$、$B_2$ 和 $B_3$ 组成的控制流图 (CFG)。基本块 $B_0$ 包含一个基于谓词 $c$ 的条件判断，如果 $c$ 为真，则分支到 $B_1$，否则分支到 $B_2$。基本块 $B_1$ 和 $B_2$ 在 $B_3$ 处汇合。该程序片段如下，其中符号 $:=$ 表示赋值：\n\n- 在 $B_1$ 中: $x := y$。\n- 在 $B_2$ 中: $x := z$。\n- 在 $B_3$ 中: $w := x$。\n\n假设 $y$ 和 $z$ 在 $B_0$ 之前已定义，并且在 $B_1$ 或 $B_2$ 中都未被修改。同时假设 $x$ 仅由 $B_1$ 和 $B_2$ 中所示的赋值语句定义。不存在影响 $x$、$y$、$z$ 或 $w$ 的副作用或别名。\n\n你需要根据编译器原理中的基本定义进行推理：\n\n- 控制流图 (CFG) 是一个有向图，其节点是基本块，边代表可能的控制流转移。在汇合节点处，多个前驱块汇合，后续语句的执行与具体来自哪个前驱块无关。\n- 静态单赋值 (SSA) 形式是一种每个变量只被赋值一次的表示形式；在汇合点，特殊的 $\\phi$-函数会合并来自不同前驱的值。在具有前驱 $P_1$ 和 $P_2$ 的汇合点，$\\phi$-函数 $u := \\phi(u_1, u_2)$ 的语义是：如果控制流来自 $P_1$，则 $u$ 取 $u_1$ 的值，否则 $u$ 取 $u_2$ 的值。\n- 经典副本传播（非 SSA）是一种前向数据流优化，当赋值语句 $u := v$ 是到达变量 $u$ 使用点的所有路径上的唯一到达副本，并且在这些路径上 $v$ 没有被重新定义时，它会将 $u$ 的使用替换为源变量 $v$。到达副本指的是一个副本赋值，在其到达使用点的路径上，其左侧变量未被重新定义所“杀死”（kill）。\n\n将该程序转换为 SSA 形式，然后分析基于 SSA 的副本传播在汇合点如何与 $\\phi$-函数交互，并与在同一汇合点的经典数据流副本传播进行比较。在给定假设下，以下哪些陈述是正确的？\n\nA. 在经典的非 SSA 表示中，位于 $B_3$ 的语句 $w := x$ 不能通过副本传播转换为 $w := y$ 或 $w := z$，因为不同的副本 $x := y$ 和 $x := z$ 沿着不同的路径到达 $x$ 的使用点。\n\nB. 在 SSA 形式中，该片段变为 $B_1$ 中的 $x_1 := y$，$B_2$ 中的 $x_2 := z$，以及在 $B_3$ 的语句 $x_3 := \\phi(x_1, x_2)$ 和 $w_1 := x_3$。基于 SSA 的副本传播可以将 $\\phi$-函数的参数替换为其来源，得到 $x_3 := \\phi(y, z)$，然后通过将 $w_1$ 的所有使用替换为 $x_3$ 来消除副本 $w_1 := x_3$。\n\nC. 在 SSA 形式中，因为两个前驱赋值都是副本，$\\phi$-函数 $x_3 := \\phi(x_1, x_2)$ 可以在汇合点简化为 $x_3 := y$，从而使 $w_1 := x_3$ 可以进一步化简为 $w_1 := y$。\n\nD. 在经典的非 SSA 表示中，在 $B_3$ 引入 $w := \\phi(y, z)$ 来替换 $w := x$ 是一个有效的副本传播步骤，因为它在汇合点准确地将到达的副本合并为一个表达式。\n\nE. 一个经典的副本传播过程可以合法地将汇合点转换为条件表达式 $w := c ? y : z$ 以消除 $x$，因为这保持了与原始 CFG 相同的语义。\n\n选择所有正确的选项。",
            "solution": "首先验证问题陈述，以确保其科学上合理、问题定义清晰且客观。\n\n**步骤 1：提取已知条件**\n- 一个控制流图 (CFG) 有四个基本块：$B_0$, $B_1$, $B_2$, $B_3$。\n- 控制流：$B_0$ 在谓词 $c$ 为真时分支到 $B_1$，在 $c$ 为假时分支到 $B_2$。$B_1$ 和 $B_2$ 都流向 $B_3$（一个汇合点）。\n- 赋值：\n    - 在 $B_1$ 中：$x := y$。\n    - 在 $B_2$ 中：$x := z$。\n    - 在 $B_3$ 中：$w := x$。\n- 假设：\n    - $y$ 和 $z$ 在 $B_0$ 之前已定义。\n    - $y$ 和 $z$ 在 $B_1$ 或 $B_2$ 中均未被修改。\n    - $x$ 仅由 $B_1$ 和 $B_2$ 中的赋值定义。\n    - 没有副作用或别名影响 $x, y, z, w$。\n- 提供的定义：\n    - CFG，汇合节点。\n    - 静态单赋值 (SSA) 形式，$\\phi$-函数。\n    - 经典副本传播（要求在所有路径上存在唯一的到达副本）。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在编译器理论领域具有科学依据。CFG、SSA 和副本传播的概念都是标准概念。问题定义清晰，提供了具体的代码结构和明确的定义。所给假设消除了潜在的歧义（例如，$x$ 的其他定义、别名），使问题自洽且可解。语言精确客观。该问题不违反任何无效性标准。\n\n**步骤 3：结论与行动**\n问题陈述有效。将基于所提供的定义推导出解决方案。\n\n**推导与分析**\n\n问题的核心是比较两种不同的程序表示形式——经典的非 SSA 形式和 SSA 形式——如何影响副本传播在控制流汇合点的适用性。\n\n**1. 经典（非 SSA）表示法下的分析**\n\n我们分析基本块 $B_3$ 中的语句 $w := x$。根据所提供的定义，经典副本传播只有在“$x := v$ 是到达该使用点的**所有路径上的唯一到达副本**”时，才能将 $x$ 的使用替换为副本赋值 $x := v$ 的右侧。\n\n- 从程序入口到 $B_3$ 的路径必须经过 $B_1$ 或 $B_2$。\n- **路径 1（通过 $B_1$）：** 控制流为 $B_0 \\rightarrow B_1 \\rightarrow B_3$。在这条路径上，到达 $B_3$ 中 $x$ 的使用点的副本赋值是来自块 $B_1$ 的 $x := y$。\n- **路径 2（通过 $B_2$）：** 控制流为 $B_0 \\rightarrow B_2 \\rightarrow B_3$。在这条路径上，到达 $B_3$ 中 $x$ 的使用点的副本赋值是来自块 $B_2$ 的 $x := z$。\n\n在块 $B_3$ 中 $w := x$ 语句对 $x$ 的使用点，存在两个不同的到达副本定义：$x := y$ 和 $x := z$。“唯一到达副本”的条件未被满足。因此，经典的副本传播过程不能将 $x$ 替换为 $y$ 或 $z$。这样做是错误的，因为它会忽略沿另一条路径传播的值。例如，对于任何谓词 $c$ 为假的执行情况，将 $w := x$ 替换为 $w := y$ 都是不正确的。\n\n**2. 静态单赋值 (SSA) 表示法下的分析**\n\n我们首先将程序片段转换为 SSA 形式。在 SSA 中，每个变量只被赋值一次。当一个变量的多个定义到达一个汇合点时，会插入一个 $\\phi$-函数来创建一个新的、唯一的定义。\n\n- $B_1$ 中的赋值 $x := y$ 定义了 $x$ 的一个新版本，记为 $x_1$。该语句变为 $x_1 := y$。\n- $B_2$ 中的赋值 $x := z$ 定义了 $x$ 的另一个新版本，记为 $x_2$。该语句变为 $x_2 := z$。\n- 在汇合点 $B_3$，两个定义 $x_1$ 和 $x_2$ 交汇。引入一个 $\\phi$-函数将它们合并成一个单一的新版本 $x_3$。该语句为 $x_3 := \\phi(x_1, x_2)$，其中参数分别对应前驱 $B_1$ 和 $B_2$。\n- 在 $B_3$ 中，$w := x$ 对 $x$ 的使用现在必须引用支配它的唯一 $x$ 的定义，即 $x_3$。对 $w$ 的赋值也被重命名，例如为 $w_1$。该语句变为 $w_1 := x_3$。\n\n相关基本块的 SSA 形式为：\n- 在 $B_1$ 中: $x_1 := y$。\n- 在 $B_2$ 中: $x_2 := z$。\n- 在 $B_3$ 中：\n    - $x_3 := \\phi(x_1, x_2)$\n    - $w_1 := x_3$\n\n现在，我们分析在这种 SSA 形式下的副本传播。在 SSA 中，传播更简单，因为每个变量名都指向一个唯一的定义。\n- 我们有副本 $x_1 := y$。$\\phi$-函数中对 $x_1$ 的使用可以被 $y$ 替换。\n- 我们有副本 $x_2 := z$。$\\phi$-函数中对 $x_2$ 的使用可以被 $z$ 替换。\n- 在此步骤之后，$\\phi$-函数变为：$x_3 := \\phi(y, z)$。这是一个有效的 SSA 优化，通常被称为“SSA 副本传播”，或者是更通用的“稀疏条件常量传播”(SCCP) 算法的一部分。\n- 现在我们有语句 $w_1 := x_3$。这是一个副本赋值。任何后续对 $w_1$ 的使用都可以被 $x_3$ 替换。这是一个标准的副本消除/传播步骤。\n\n**逐项评估**\n\n**A. 在经典的非 SSA 表示中，位于 $B_3$ 的语句 $w := x$ 不能通过副本传播转换为 $w := y$ 或 $w := z$，因为不同的副本 $x := y$ 和 $x := z$ 沿着不同的路径到达 $x$ 的使用点。**\n这个陈述是我们对经典非 SSA 情况分析的直接结果。在 $B_3$ 的入口处，数据流事实是 $x$ 有两个到达副本定义。根据所提供的经典副本传播的定义，该定义要求唯一的到达副本，因此该优化被阻止。\n**结论：正确。**\n\n**B. 在 SSA 形式中，该片段变为 $B_1$ 中的 $x_1 := y$，$B_2$ 中的 $x_2 := z$，以及在 $B_3$ 的语句 $x_3 := \\phi(x_1, x_2)$ 和 $w_1 := x_3$。基于 SSA 的副本传播可以将 $\\phi$-函数的参数替换为其来源，得到 $x_3 := \\phi(y, z)$，然后通过将 $w_1$ 的所有使用替换为 $x_3$ 来消除副本 $w_1 := x_3$。**\n这个陈述准确地描述了转换为 SSA 并执行优化的过程。向 SSA 的转换是正确的。随后将 $y$ 和 $z$ 传播到 $\\phi$-函数中是标准的 SSA 优化。消除副本 $w_1 := x_3$ 也是一个标准的副本传播步骤。\n**结论：正确。**\n\n**C. 在 SSA 形式中，因为两个前驱赋值都是副本，$\\phi$-函数 $x_3 := \\phi(x_1, x_2)$ 可以在汇合点简化为 $x_3 := y$，从而使 $w_1 := x_3$ 可以进一步化简为 $w_1 := y$。**\n这个陈述提出了一个无效的简化。将副本传播到 $\\phi$-函数后，我们得到 $x_3 := \\phi(y, z)$。其语义是，如果控制流来自 $B_1$，$x_3$ 接收 $y$ 的值；如果控制流来自 $B_2$，$x_3$ 接收 $z$ 的值。只有在能保证 $y$ 和 $z$ 相等的情况下，将其简化为 $x_3 := y$ 才是有效的，而我们不能做出这个假设。这会改变程序的语义。\n**结论：不正确。**\n\n**D. 在经典的非 SSA 表示中，在 $B_3$ 引入 $w := \\phi(y, z)$ 来替换 $w := x$ 是一个有效的副本传播步骤，因为它在汇合点准确地将到达的副本合并为一个表达式。**\n这个陈述混淆了不同的概念。$\\phi$-函数是 SSA 中间表示特有的一种抽象。它不是“经典非 SSA 表示”中的一条指令。所描述的转换不是经典定义的副本传播（那是一种简单的替换）。这种转换合成了一条新的、复杂的指令，语义上代表了 SSA 的汇合操作。\n**结论：不正确。**\n\n**E. 一个经典的副本传播过程可以合法地将汇合点转换为条件表达式 $w := c ? y : z$ 以消除 $x$，因为这保持了与原始 CFG 相同的语义。**\n虽然转换 $w := c ? y : z$ 在语义上等同于原始的控制流，但它并不是“副本传播”。这是一种更高级的优化，称为*if-conversion*或*谓词化*。它涉及分析控制依赖（$B_1$ 和 $B_2$ 中的赋值对谓词 $c$ 的依赖），并将其转换为数据依赖。一个简单的、如定义所述的副本传播过程不会执行如此复杂的结构转换。\n**结论：不正确。**",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "编译优化的首要原则是绝不能改变程序的原始语义。本练习聚焦于确保副本传播安全性的一个核心挑战：别名（aliasing）。当一个函数通过指针或引用接收一个变量时，我们必须保守地假设该变量可能被修改。你需要根据这一“安全第一”的原则，判断在存在潜在副作用的情况下，哪些优化是允许的，哪些是必须禁止的。",
            "id": "3634027",
            "problem": "考虑一个单线程过程 $F$ 中的一段中间表示（IR）的直线型代码片段（中间表示是一种类似三地址码的形式），该过程包含局部标量变量 $x$、$y$、$w$、$v$ 以及一个对过程 $h$ 的调用，该调用接受一个局部变量的地址。符号 `$` 表示取地址运算符，参数传递采用引用传递，即 $h$ 可以通过传入的指针进行写操作。假设存在一个标准的过程内控制流图（CFG）（控制流图是基本块通过控制流连接而成的有向图），该图是线性的，并且严格按程序顺序进行求值。该代码片段如下：\n\n- 语句 $1$：$x := y$\n- 语句 $2$：$h(\\$y)$\n- 语句 $3$：$w := y + 1$\n- 语句 $4$：$y := x$\n- 语句 $5$：$v := y + 2$\n- 语句 $6$：$\\mathrm{return}\\; w + v$\n\n关于 $h$ 的假设：\n- $h$ 可以写入其参数指定的内存位置，即 $h(\\$y)$ 可能会对 $y$ 进行赋值。\n- $h$ 不通过 $x$ 的地址访问任何内存；除了语句 $2$ 中显式的 `$` 外，不存在对 $x$ 或 $y$ 的其他别名。\n- $h$ 对 $x$ 没有隐藏的副作用，不执行并发操作，也没有异步效应。\n\n一个编译器尝试进行流敏感的复制传播，其目标是当一个变量可被证明与另一个变量相等时，用另一个变量替换其使用。这基于以下基本原则：\n\n- 赋值的语义：在语句 $1$，$x := y$ 将 $x$ 设置为存储在 $y$ 中的当前值。\n- 引用调用的语义：在语句 $2$，$h(\\$y)$ 可能会改变 $y$；这等同于在语句 $2$ 执行期间对 $y$ 进行了某种写操作，但 $h$ 不会写入 $x$。\n- 复制传播的数据流安全条件：仅当从建立 $x = y$ 的定义点到该使用点的所有路径上，都没有对 $x$ 或 $y$ 的中间写操作（包括通过别名的间接写操作）时，用 $x$ 替换 $y$ 的使用才是安全的。\n\n在这些假设下，以下哪些用 $x$ 替换 $y$ 的操作能保证语义不变？\n\nA. 在语句 $3$ 和 $5$ 中用 $x$ 替换 $y$。\n\nB. 仅在语句 $5$ 中用 $x$ 替换 $y$。\n\nC. 仅在语句 $3$ 中用 $x$ 替换 $y$。\n\nD. 在语句 $3$ 和 $5$ 中用 $x$ 替换 $y$ 均不安全。\n\n选择唯一最佳选项。",
            "solution": "对用户提供的问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **代码片段：** 一段包含六个语句的中间表示（IR）序列。\n  - 语句 $1$：$x := y$\n  - 语句 $2$：$h(\\$y)$\n  - 语句 $3$：$w := y + 1$\n  - 语句 $4$：$y := x$\n  - 语句 $5$：$v := y + 2$\n  - 语句 $6$：$\\mathrm{return}\\; w + v$\n- **上下文：** 该代码片段位于一个单线程过程 $F$ 中。控制流是线性的，语句按程序顺序执行。\n- **变量：** 局部标量变量为 $x$、$y$、$w$ 和 $v$。\n- **函数调用 `h`：**\n  - `h` 接受一个指向变量的指针。在语句 $2$ 中，它以 $y$ 的地址（`$y`）被调用。\n  - 参数传递是引用传递，意味着 $h$ 可以写入其参数的内存位置。\n  - 假设 $h(\\$y)$ 可能会给 $y$ 赋一个新值。\n- **假设：**\n  - $h$ 不访问或修改 $x$。\n  - 除了在调用 $h$ 时由 `$` 创建的别名外，不存在对 $x$ 或 $y$ 的其他别名。\n  - $h$ 没有其他隐藏的副作用，也不存在并发或异步事件。\n- **优化任务：** 执行流敏感的复制传播。\n- **数据流安全条件：** “仅当从建立 $x = y$ 的定义点到该使用点的所有路径上，都没有对 $x$ 或 $y$ 的中间写操作（包括通过别名的间接写操作）时，用 $x$ 替换 $y$ 的使用才是安全的。”\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题陈述。\n- **科学性：** 该问题设置在编译器设计这一计算机科学的成熟子领域中。所有概念，包括中间表示（IR）、复制传播、数据流分析、别名和引用调用，都是标准的且有严格定义。该问题在科学上是合理的。\n- **良构性：** 问题提供了一个特定的代码序列，定义了操作的语义，并为转换陈述了一个清晰明确的安全条件。它要求基于这些规则得出一个明确的结论。可以推导出一个唯一的正确答案。\n- **客观性：** 问题以精确、正式的语言陈述，没有主观性或模糊性。\n- **完整性与一致性：** 问题是自洽的。提供的关于函数 $h$ 的假设是关键且充分的，足以解决数据流分析问题。设置中没有矛盾之处。\n- **现实性：** 该场景是编译器优化中的一个经典且现实的问题。分析函数调用的影响，特别是涉及指针或引用的调用，是编译器为确保正确性而必须保守处理的一个基本挑战。\n\n### 步骤 3：结论与行动\n问题陈述内部一致、科学合理且良构。因此，它是 **有效的**。现在将进行求解过程。\n\n### 解题推导\n\n任务是确定在语句 3 和 5 中，变量 $y$ 的使用可以在何处被安全地替换为变量 $x$。这需要进行一次流敏感的数据流分析来跟踪一个“复制事实”，我们可以将其表示为属性 $x=y$。分析逐条语句进行。一个语句可以 *生成* (generate) 一个复制事实（例如，像 $x:=y$ 这样的赋值），或者 *杀死* (kill) 一个复制事实（例如，对复制对中任一变量的赋值）。\n\n**程序片段分析：**\n\n1.  **语句 $1$ 之后：$x := y$**\n    - 这个赋值语句 *生成* 了复制事实 $x=y$。在语句 $1$ 之后的程序点，可用的复制集包括 $x=y$。\n\n2.  **在语句 $2$ 处：$h(\\$y)$**\n    - 问题陈述指出，函数 $h$ 以 $y$ 的地址（`$y`）被调用，并且 $h$ “可以写入其参数指定的内存位置”。\n    - 为了保证语义保持，编译器必须做出保守的假设。因为 $h$ *可能* 写入 $y$，所以分析必须假设它 *确实* 写入了 $y$。\n    - 对 $y$ 的写操作是对 $y$ 的重新定义。根据安全条件，对复制对中变量的任何重新定义都会使该复制事实无效（或 *杀死*）。\n    - 在这里，对 $y$ 的潜在写操作杀死了由语句 $1$ 生成的复制事实 $x=y$。根据假设，$x$ 的值保持不变，但 $y$ 的值现在是未知的，因此不再能保证 $x=y$。\n    - 在语句 $2$ 之后的程序点，可用的复制集为空。\n\n3.  **在语句 $3$ 处：$w := y + 1$**\n    - 我们必须确定此语句中 $y$ 的使用是否可以被 $x$ 替换。\n    - 我们应用数据流安全条件：从建立 $x=y$ 的定义点到此使用点的所有路径上，是否都没有对 $x$ 或 $y$ 的中间写操作？\n    - 建立 $x=y$ 的相关定义是语句 $1$。\n    - 从语句 $1$ 到语句 $3$ 的路径是 $1 \\rightarrow 2 \\rightarrow 3$。\n    - 这条路径包含语句 $2$，$h(\\$y)$，它扮演了一个对 $y$ 的中间写操作（一个 *kill* 操作）的角色。\n    - 因此，安全条件被违反。在语句 $3$ 中用 $x$ 替换 $y$ 是 **不安全的**，也不能保持语义。\n\n4.  **语句 $4$ 之后：$y := x$**\n    - 这是一个新的赋值语句。它是一个复制赋值，*生成* 了复制事实 $y=x$（这等价于 $x=y$）。\n    - 任何先前涉及 $y$ 的复制事实都已被杀死，但此语句明确地重新建立了 $x$ 和 $y$ 的相等性。\n    - 在语句 $4$ 之后的程序点，可用的复制集现在包括 $x=y$。\n\n5.  **在语句 $5$ 处：$v := y + 2$**\n    - 我们必须确定此语句中 $y$ 的使用是否可以被 $x$ 替换。\n    - 我们再次应用数据流安全条件。现在，建立 $x=y$ 的相关定义是语句 $4$。\n    - 从语句 $4$ 到语句 $5$ 中 $y$ 的使用点的路径是直接的控制流边 $4 \\rightarrow 5$。\n    - 这条路径是否包含任何对 $x$ 或 $y$ 的中间写操作？不。在语句 $4$ 完成和在语句 $5$ 中使用 $y$ 之间，没有执行其他语句，因此没有对 $x$ 或 $y$ 的修改发生。\n    - 安全条件得到满足。在语句 $5$ 中用 $x$ 替换 $y$ 是 **安全的**，并且能保持语义。\n\n**分析结论：**\n- 在语句 $3$ 中用 $x$ 替换 $y$ 是 **不安全的**。\n- 在语句 $5$ 中用 $x$ 替换 $y$ 是 **安全的**。\n\n### 逐项分析\n\n**A. 在语句 $3$ 和 $5$ 中用 $x$ 替换 $y$。**\n- **分析：** 此选项声称两个替换都是安全的。我们的分析表明，由于调用 $h(\\$y)$ 可能修改 $y$，语句 $3$ 中的替换是不安全的。\n- **结论：** 不正确。\n\n**B. 仅在语句 $5$ 中用 $x$ 替换 $y$。**\n- **分析：** 此选项声称在语句 $5$ 中的替换是安全的，但在其他地方则不是（隐含地，在语句 $3$ 中不是）。我们的分析证实，语句 $5$ 中的替换是安全的，因为复制事实 $x=y$ 在语句 $4$ 处生成，并且在语句 $5$ 使用前未被杀死。这也正确地暗示了语句 $3$ 中的替换是不安全的。\n- **结论：** 正确。\n\n**C. 仅在语句 $3$ 中用 $x$ 替换 $y$。**\n- **分析：** 此选项声称在语句 $3$ 中的替换是安全的，但在语句 $5$ 中不是。这与我们的发现相反。语句 $3$ 中的替换是不安全的。\n- **结论：** 不正确。\n\n**D. 在语句 $3$ 和 $5$ 中用 $x$ 替换 $y$ 均不安全。**\n- **分析：** 此选项声称两个替换都是不安全的。我们的分析表明，语句 $5$ 中的替换是安全的。\n- **结论：** 不正确。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}