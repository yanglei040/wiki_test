{
    "hands_on_practices": [
        {
            "introduction": "Before a compiler can eliminate a \"common\" subexpression, it must first define precisely what it means for two expressions to be equivalent. This exercise challenges you to explore how different algebraic rules impact this definition. By comparing a normalization policy based only on commutativity with a more powerful one that also considers associativity, you will see how the scope of optimization expands and gain a deeper understanding of congruence classes in value numbering.",
            "id": "3644049",
            "problem": "Consider a straight-line fragment of a program in a three-address Intermediate Representation (IR) with a Control-Flow Graph (CFG), where variables $a$, $b$, $c$, and $d$ are parameters defined at procedure entry and never reassigned. The CFG consists of four basic blocks $B_0$, $B_1$, $B_2$, and $B_3$, connected as follows: $B_0$ is the unique entry and branches to both $B_1$ and $B_2$; both $B_1$ and $B_2$ flow into $B_3$. All computations are pure, and operator $+$ is integer addition. The IR statements are:\n\nIn $B_1$:\n- $e_1 \\leftarrow a + (b + c)$\n- $e_2 \\leftarrow (a + b) + c$\n\nIn $B_2$:\n- $e_3 \\leftarrow (b + c) + a$\n- $e_4 \\leftarrow (c + a) + b$\n\nIn $B_3$:\n- $e_5 \\leftarrow a + (c + b)$\n- $e_6 \\leftarrow (a + c) + b$\n- $e_7 \\leftarrow a + (b + d)$\n- $e_8 \\leftarrow (a + b) + c$\n- $e_9 \\leftarrow a + (b + c)$\n\nAssume Global Common Subexpression Elimination (GCSE) is performed using global value numbering across the CFG, and that the language semantics permit algebraic normalization of addition according to the chosen policy. You will compare two normalization policies used by the value numbering:\n\n- Policy $\\mathcal{C}$: Canonicalize only commutativity of each binary $+$ node independently (for any $x$ and $y$, $x + y$ is canonically represented as a sorted pair of operands), without using associativity across different $+$ nodes.\n- Policy $\\mathcal{AC}$: Canonicalize both associativity and commutativity of $+$ by first flattening nested additions into a multiset of operands and then sorting that multiset.\n\nStarting from the foundational definitions that (i) a congruence class groups IR expressions that are provably equal under the chosen normalization and program semantics, and (ii) global value numbering must assign the same value number to all members of a congruence class regardless of their basic blocks, determine, for the set of all nine right-hand-side expressions $E = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d), (a + b) + c, a + (b + c)\\}$ appearing in $B_1$, $B_2$, and $B_3$:\n\n- $K_{\\mathcal{C}}$: the number of distinct congruence classes under policy $\\mathcal{C}$,\n- $K_{\\mathcal{AC}}$: the number of distinct congruence classes under policy $\\mathcal{AC}}$.\n\nCompute the single quantity $K_{\\mathcal{C}} - K_{\\mathcal{AC}}$. Provide your final answer as an exact integer. No rounding is required.",
            "solution": "The problem requires us to determine the number of distinct congruence classes for a given set of nine expressions under two different normalization policies, $\\mathcal{C}$ and $\\mathcal{AC}$. A congruence class groups expressions that are proven to be equivalent. We first identify the set $S$ of syntactically distinct expressions from the given list $E$:\n$S = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d)\\}$.\nWe will partition this set $S$ according to each policy.\n\n**Analysis under Policy $\\mathcal{C}$ (Commutativity Only)**\n\nPolicy $\\mathcal{C}$ canonicalizes based on commutativity of the binary operator $+$ at each node, but not associativity. We assume an alphabetical ordering for variables ($a  b  c  d$).\n1.  $a + (b + c)$: Inner $b+c$ is canonical. Outer is $a + (\\text{result})$. Canonical form: $a + (b+c)$.\n2.  $(a + b) + c$: Inner $a+b$ is canonical. Outer is $(\\text{result}) + c$. Canonical form: $(a+b)+c$.\n3.  $(b + c) + a$: Inner $b+c$ is canonical. Outer is $(\\text{result}) + a$. Canonicalizes to $a + (b+c)$.\n4.  $(c + a) + b$: Inner $c+a$ canonicalizes to $a+c$. Outer is $(\\text{result}) + b$. Canonical form: $(a+c)+b$.\n5.  $a + (c + b)$: Inner $c+b$ canonicalizes to $b+c$. Outer is $a + (\\text{result})$. Canonical form: $a + (b+c)$.\n6.  $(a + c) + b$: Inner $a+c$ is canonical. Outer is $(\\text{result}) + b$. Canonical form: $(a+c)+b$.\n7.  $a + (b + d)$: Inner $b+d$ is canonical. Outer is $a + (\\text{result})$. Canonical form: $a+(b+d)$.\n\nWe have identified the following distinct canonical forms under Policy $\\mathcal{C}$:\n- Class 1: $a + (b+c)$ representing $\\{a + (b + c), (b + c) + a, a + (c + b)\\}$.\n- Class 2: $(a+b)+c$ representing $\\{(a + b) + c\\}$.\n- Class 3: $(a+c)+b$ representing $\\{(c + a) + b, (a + c) + b\\}$.\n- Class 4: $a+(b+d)$ representing $\\{a + (b + d)\\}$.\n\nThere are $4$ distinct congruence classes. Therefore, $K_{\\mathcal{C}} = 4$.\n\n**Analysis under Policy $\\mathcal{AC}$ (Associativity and Commutativity)**\n\nPolicy $\\mathcal{AC}$ flattens nested additions into a multiset of operands and sorts them.\n1.  $a + (b + c)$: Flattening yields $\\{a, b, c\\}$. The sorted list is $(a, b, c)$.\n2.  $(a + b) + c$: Flattening yields $\\{a, b, c\\}$. The sorted list is $(a, b, c)$.\n3.  $(b + c) + a$: Flattening yields $\\{b, c, a\\}$. The sorted list is $(a, b, c)$.\n4.  $(c + a) + b$: Flattening yields $\\{c, a, b\\}$. The sorted list is $(a, b, c)$.\n5.  $a + (c + b)$: Flattening yields $\\{a, c, b\\}$. The sorted list is $(a, b, c)$.\n6.  $(a + c) + b$: Flattening yields $\\{a, c, b\\}$. The sorted list is $(a, b, c)$.\nAll six expressions above reduce to the same canonical form represented by the sorted operand list $(a, b, c)$.\n\n7.  For $a + (b + d)$: Flattening yields the multiset $\\{a, b, d\\}$. The sorted list is $(a, b, d)$. This is a distinct canonical form.\n\nUnder Policy $\\mathcal{AC}$, we have identified two distinct canonical forms:\n- Class 1: Represented by $(a, b, c)$.\n- Class 2: Represented by $(a, b, d)$.\n\nThere are $2$ distinct congruence classes. Therefore, $K_{\\mathcal{AC}} = 2$.\n\n**Final Calculation**\n\nThe problem asks for the value of $K_{\\mathcal{C}} - K_{\\mathcal{AC}}$.\n$K_{\\mathcal{C}} - K_{\\mathcal{AC}} = 4 - 2 = 2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Once we can identify equivalent expressions, the next challenge is tracking their values across the control-flow graph of an entire function. This practice demonstrates how the combination of Static Single Assignment (SSA) form and hash-based Global Value Numbering (GVN) creates a powerful framework for this task. By tracing the flow of value numbers through basic blocks and $\\phi$-functions, you will perform the optimization yourself and see how redundant computations are systematically eliminated.",
            "id": "3643965",
            "problem": "A program fragment in Static Single Assignment form (SSA) is given. Static Single Assignment form (SSA) requires each variable to be assigned exactly once and uses $\\phi$-functions at control-flow joins to merge values flowing from distinct predecessors. Assume a loop-free control-flow graph, pure arithmetic (no side effects, no aliasing), and standard dominator semantics: a definition $d$ dominates a point $p$ if every path to $p$ passes through $d$. Under hash-based global value numbering, a value number is assigned to each pure computation; two computations are congruent if and only if they have the same operator and their operands have the same value numbers. A $\\phi$-function whose incoming operands have the same value number is considered to produce that same value number. Global common subexpression elimination removes a computation at a program point if a congruent value is available due to dominance or $\\phi$-equivalence at that point.\n\nConsider inputs $a$, $b$, $c$, $d$ as real numbers, and the control-flow graph with blocks $B_{0}$, $B_{1}$, $B_{2}$, and $B_{3}$:\n\n- In block $B_{0}$:\n  - $t_{1} \\leftarrow a + b$\n  - $t_{2} \\leftarrow c - d$\n  - if predicate $p$ then branch to $B_{1}$ else branch to $B_{2}$\n\n- In block $B_{1}$:\n  - $u_{1} \\leftarrow t_{1} \\times t_{2}$\n  - $t_{4} \\leftarrow a + b$\n  - $u_{3} \\leftarrow t_{4} \\times t_{2}$\n  - branch to $B_{3}$\n\n- In block $B_{2}$:\n  - $t_{5} \\leftarrow a + b$\n  - $v_{2} \\leftarrow t_{5} \\times t_{2}$\n  - $t_{6} \\leftarrow c - d$\n  - branch to $B_{3}$\n\n- In block $B_{3}$:\n  - $w_{1} \\leftarrow \\phi(u_{3}, v_{2})$\n  - $t_{7} \\leftarrow a + b$\n  - $w_{3} \\leftarrow t_{7} \\times t_{2}$\n  - $w_{4} \\leftarrow w_{1} + w_{3}$\n  - return $w_{4}$\n\nStarting from the above core definitions and facts (SSA semantics, dominators, pure computations, and congruence via hash-based value numbering), apply global common subexpression elimination that spans block boundaries. Determine the exact analytic expression, in terms of $a$, $b$, $c$, and $d$, that the program returns after the elimination and substitution of redundant computations. Provide your final answer as a single closed-form expression. No rounding is required and no physical units apply.",
            "solution": "We apply global value numbering (GVN) to trace values and identify redundant computations across the control-flow graph. Let $\\text{VN}(e)$ denote the value number assigned to an expression or variable $e$.\n\n1.  **Process Block $B_0$**:\n    - Assign value numbers to inputs: $\\text{VN}(a) = \\#a$, $\\text{VN}(b) = \\#b$, $\\text{VN}(c) = \\#c$, $\\text{VN}(d) = \\#d$.\n    - $t_1 \\leftarrow a + b$: This computation gets a new value number, say $\\#1$. So, $\\text{VN}(t_1) = \\#1$.\n    - $t_2 \\leftarrow c - d$: This computation gets another new value number, say $\\#2$. So, $\\text{VN}(t_2) = \\#2$.\n    - The values in $t_1$ and $t_2$ are available to all blocks dominated by $B_0$, which are $B_1$, $B_2$, and $B_3$.\n\n2.  **Process Block $B_1$**:\n    - $u_1 \\leftarrow t_1 \\times t_2$: The operands have value numbers $\\#1$ and $\\#2$. The computation gets a new value number, say $\\#3$. So, $\\text{VN}(u_1) = \\#3$.\n    - $t_4 \\leftarrow a + b$: The operands have value numbers $\\#a$ and $\\#b$. The GVN algorithm recognizes this computation as being congruent to $t_1 \\leftarrow a + b$. Thus, it assigns the same value number: $\\text{VN}(t_4) = \\#1$. This computation is redundant; the value is already in $t_1$.\n    - $u_3 \\leftarrow t_4 \\times t_2$: The operands have value numbers $\\text{VN}(t_4) = \\#1$ and $\\text{VN}(t_2) = \\#2$. This is congruent to $u_1 \\leftarrow t_1 \\times t_2$. Thus, $\\text{VN}(u_3) = \\#3$. This computation is also redundant; its value is already in $u_1$. After optimization, $u_3$ holds the same value as $u_1$.\n\n3.  **Process Block $B_2$**:\n    - $t_5 \\leftarrow a + b$: This is congruent to $t_1 \\leftarrow a + b$. $\\text{VN}(t_5) = \\#1$. Redundant.\n    - $v_2 \\leftarrow t_5 \\times t_2$: The operands have value numbers $\\text{VN}(t_5) = \\#1$ and $\\text{VN}(t_2) = \\#2$. This is congruent to $u_1 \\leftarrow t_1 \\times t_2$. Thus, $\\text{VN}(v_2) = \\#3$. Redundant.\n    - $t_6 \\leftarrow c - d$: This is congruent to $t_2 \\leftarrow c - d$. $\\text{VN}(t_6) = \\#2$. Redundant.\n\n4.  **Process Block $B_3$**:\n    - $w_1 \\leftarrow \\phi(u_3, v_2)$: The incoming values from $B_1$ and $B_2$ are $u_3$ and $v_2$. We found that $\\text{VN}(u_3) = \\#3$ and $\\text{VN}(v_2) = \\#3$. Since all incoming operands to the $\\phi$-function have the same value number, the result also gets that value number: $\\text{VN}(w_1) = \\#3$. The value of $w_1$ is therefore $(a+b)(c-d)$.\n    - $t_7 \\leftarrow a + b$: Congruent to $t_1 \\leftarrow a+b$. $\\text{VN}(t_7) = \\#1$. Redundant.\n    - $w_3 \\leftarrow t_7 \\times t_2$: The operands have value numbers $\\text{VN}(t_7)=\\#1$ and $\\text{VN}(t_2)=\\#2$. This computation is congruent to others with value number $\\#3$. Therefore, $\\text{VN}(w_3) = \\#3$. This computation is redundant because the value is already available in $w_1$. The assignment can be replaced by $w_3 \\leftarrow w_1$.\n    - $w_4 \\leftarrow w_1 + w_3$: After substituting the redundant computation, this becomes $w_4 \\leftarrow w_1 + w_1$.\n\n5.  **Final Expression**:\n    - The program returns $w_4$. The value of $w_4$ is $w_1 + w_1 = 2 \\times w_1$.\n    - The value of $w_1$ corresponds to value number $\\#3$, which was originally computed as $t_1 \\times t_2$.\n    - Substituting the original expressions: $w_1 = (a+b) \\times (c-d)$.\n    - Therefore, the final returned expression is $2 \\times (a+b)(c-d)$.",
            "answer": "$$\n\\boxed{2(a+b)(c-d)}\n$$"
        },
        {
            "introduction": "In practice, a promising optimization is often blocked by the program's structure or by semantic constraints like preventing speculative execution. This exercise presents a classic scenario where a \"critical edge\" in the control-flow graph prevents a straightforward elimination of a common subexpression. You will analyze the problem and identify the correct code transformation—edge splitting—that safely enables Global Common Subexpression Elimination, illustrating how optimizers must sometimes restructure code to create opportunities.",
            "id": "3644037",
            "problem": "Consider a function in three-address code form, represented by a Control Flow Graph (CFG). A Control Flow Graph (CFG) is a directed graph whose nodes are basic blocks and edges represent possible control transfers between blocks. A node $B_x$ is said to dominate a node $B_y$ if every path from the entry to $B_y$ goes through $B_x$. An edge $(B_p,B_s)$ is a critical edge if $B_p$ has two or more successors and $B_s$ has two or more predecessors. In Static Single Assignment (SSA) form, each variable is assigned exactly once, and join points use $\\phi$-functions to merge values from different predecessors.\n\nYou are given the following CFG structure with basic blocks and statements, where $+$ denotes integer addition that may raise an overflow exception under the source language semantics. Therefore, speculative execution of $+$ on paths where it did not originally execute is not permitted. Assume that $a$ and $b$ are defined in a unique dominating entry block $B_0$, neither $a$ nor $b$ is redefined in any of the blocks $B_1$, $B_2$, $B_3$, $B_5$, and $B_4$, and both $a$ and $b$ reach all uses. All variables are in SSA form except where $\\phi$-functions are introduced in this transformation.\n\nCFG skeleton:\n- $B_0$: defines $a$ and $b$, then branches to $B_1$.\n- $B_1$: evaluates a predicate $cond$ and branches to $B_2$ on true and to $B_3$ on false.\n- $B_2$: computes $t_1 := a + b$, then unconditionally branches to $B_4$.\n- $B_3$: does not redefine $a$ or $b$, evaluates a predicate $cond_2$, and branches to $B_4$ on true and to $B_5$ on false.\n- $B_5$: does not redefine $a$ or $b$, then unconditionally branches to $B_4$.\n- $B_4$: computes $t_2 := a + b$, then uses $t_2$.\n\nObserve that $t_2 := a + b$ in $B_4$ duplicates the computation performed in $B_2$, but that computation is only available along the path through $B_2$. Because $+$ may trap, you must not move $a + b$ to a block where it did not execute originally. You are to enable Global Common Subexpression Elimination (GCSE) of $t_2 := a + b$ at $B_4$ without changing the program’s observable behavior, by making $a + b$ available along all paths to $B_4$ via legal insertions. Insertions on edges require edge splitting if the edge is critical.\n\nWhich of the following transformations is the minimal semantics-preserving change that enables eliminating the recomputation $t_2 := a + b$ in $B_4$ via a $\\phi$-merged value, under the constraints above?\n\nA. Split the critical edge $(B_3,B_4)$ by creating a new block $S_{34}$ placed on that edge. In $S_{34}$, insert $t_3 := a + b$ and branch to $B_4$. Also insert $t_4 := a + b$ at the end of $B_5$ (before branching to $B_4$). In $B_4$, replace $t_2 := a + b$ with $t := \\phi(B_2 \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ B_5 \\mapsto t_4)$ and use $t$.\n\nB. Split only the edge $(B_2,B_4)$ by creating a new block $S_{24}$ on that edge and moving $t_1 := a + b$ from $B_2$ into $S_{24}$. Leave $(B_3,B_4)$ and $(B_5,B_4)$ unchanged. In $B_4$, replace $t_2 := a + b$ with $t := \\phi(S_{24} \\mapsto t_1,\\ B_3 \\mapsto \\bot,\\ B_5 \\mapsto \\bot)$ and use $t$, where $\\bot$ denotes no available value.\n\nC. Without splitting any edges, hoist $a + b$ from $B_2$ to $B_1$ by inserting $t_h := a + b$ at the end of $B_1$. Remove $t_1 := a + b$ from $B_2$ and replace $t_2 := a + b$ in $B_4$ with the already computed $t_h$.\n\nD. Split both $(B_3,B_4)$ and $(B_5,B_4)$ by creating new blocks $S_{34}$ and $S_{54}$ on those edges. Insert $t_3 := a + b$ in $S_{34}$ and $t_4 := a + b$ in $S_{54}$. Also move $t_1 := a + b$ from $B_2$ into a new split block $S_{24}$ on $(B_2,B_4)$. In $B_4$, replace $t_2 := a + b$ with $t := \\phi(S_{24} \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ S_{54} \\mapsto t_4)$ and use $t$.\n\nChoose the best option.",
            "solution": "The objective is to eliminate the redundant computation $t_2 := a + b$ in basic block $B_4$ by ensuring the value of $a+b$ is available upon entry to $B_4$ from all predecessor paths, while respecting semantic constraints.\n\nFirst, we analyze the Control Flow Graph (CFG) and the paths to $B_4$. The predecessors of $B_4$ are $\\{B_2, B_3, B_5\\}$.\n1.  Path $... \\to B_2 \\to B_4$: The expression $a+b$ is computed as $t_1$ in $B_2$. The value is available.\n2.  Path $... \\to B_3 \\to B_4$: The expression $a+b$ is not computed. To enable GCSE, we must insert a computation on this path.\n3.  Path $... \\to B_5 \\to B_4$: The expression $a+b$ is not computed. We must also insert a computation on this path.\n\nNext, we consider the constraints on code placement.\n-   **No speculative execution**: The operation $+$ may trap. We cannot move the computation to a block where it would execute on a path that did not originally contain it. Hoisting to $B_1$ is illegal because it would speculatively execute on the path to $B_3$.\n-   **Critical edges**: Code cannot be inserted into a predecessor block if that block has other successors, as it would affect other paths. The only safe place is on the edge itself. An edge $(B_p, B_s)$ is critical if $B_p$ has $\\ge 2$ successors and $B_s$ has $\\ge 2$ predecessors. Code insertion on a critical edge requires *edge splitting*.\n\nLet's identify the critical edges into $B_4$:\n-   The predecessors of $B_4$ are $\\{B_2, B_3, B_5\\}$ (3 predecessors).\n-   The successors of $B_2$ are $\\{B_4\\}$ (1 successor). The edge $(B_2, B_4)$ is **not** critical.\n-   The successors of $B_3$ are $\\{B_4, B_5\\}$ (2 successors). The edge $(B_3, B_4)$ is **critical**.\n-   The successors of $B_5$ are $\\{B_4\\}$ (1 successor). The edge $(B_5, B_4)$ is **not** critical.\n\nBased on this analysis, the required insertions are:\n-   To cover the path from $B_3$: We must insert the computation on the edge $(B_3, B_4)$. As this edge is critical, it must be split. A new block, say $S_{34}$, is created on this edge, and the computation $t_3 := a+b$ is placed in $S_{34}$.\n-   To cover the path from $B_5$: We must insert the computation on the edge $(B_5, B_4)$. As this edge is not critical, we can safely add the computation $t_4 := a+b$ to the end of block $B_5$.\n\nAfter these transformations, the expression $a+b$ is available on all paths to $B_4$. The predecessors of $B_4$ become $\\{B_2, S_{34}, B_5\\}$. The redundant computation can be replaced by a $\\phi$-function: $t := \\phi(B_2 \\mapsto t_1, S_{34} \\mapsto t_3, B_5 \\mapsto t_4)$.\n\nNow, we evaluate the given options:\n\n**A.** This option perfectly matches our derived minimal and correct transformation. It splits the critical edge $(B_3, B_4)$, inserts code into the new block $S_{34}$, and correctly adds code to the end of $B_5$. The resulting $\\phi$-function is correct.\n**Verdict: Correct and minimal.**\n\n**B.** This transformation is flawed. It fails to make the expression available on the paths from $B_3$ and $B_5$. The use of $\\bot$ (undefined) in the $\\phi$-function indicates the value is not available, so GCSE is not enabled.\n**Verdict: Incorrect.**\n\n**C.** This transformation violates the no-speculation constraint. Hoisting the computation to $B_1$ would cause it to execute on the path $B_1 \\to B_3$, which is not permissible as the operation might trap.\n**Verdict: Incorrect.**\n\n**D.** This transformation is semantics-preserving and enables GCSE, but it is not minimal. It unnecessarily splits the non-critical edges $(B_2, B_4)$ and $(B_5, B_4)$, creating more blocks than necessary.\n**Verdict: Incorrect (not minimal).**\n\nTherefore, option A is the only choice that describes a transformation that is correct, semantics-preserving, and minimal.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}