{
    "hands_on_practices": [
        {
            "introduction": "许多编译器优化都涉及在不同指标之间进行权衡。循环展开是一个经典的例子，它可以通过减少循环控制开销和隐藏内存延迟来提升性能，但代价是代码体积的增加。本练习将引导你为这一权衡建立数学模型，并在严格的代码体积预算下，求解最优的循环展开因子。通过这个过程，你将理解编译器如何在主要目标（速度）和硬性约束（体积）之间做出决策。",
            "id": "3628478",
            "problem": "考虑一个对归纳变量 $i$ 进行简单计数的循环，其步长为 $s$，精确执行 $N$ 次迭代。每次迭代中，循环体执行计算并以地址步长 $s$ 访问内存。假设在单核中央处理器 (CPU) 上，成本模型如下，以时钟周期为单位表示：\n- 循环体的数据处理部分（不包括循环控制和停顿）每次原始迭代的成本为 $b$ 个时钟周期。\n- 如果不进行展开，循环控制（$i$ 增加 $s$，与边界值比较以及分支）每次原始迭代的成本为 $h$ 个时钟周期。\n- 当迭代严格串行执行时，内存延迟和流水线冒险会带来每次原始迭代 $d(s)$ 个时钟周期的额外停顿成本。假设迭代是独立的，因此当 $u$ 个循环体副本被展开并交错执行时，这些停顿可以在 $u$ 个副本之间完全重叠（即，迭代间的重叠可以分摊延迟）。\n- 以因子 $u$ 进行展开会复制循环体 $u$ 次，按比例减少循环控制的执行次数，并保持每次原始迭代的数据处理工作量 $b$ 不变。\n\n设单个循环体副本的代码大小为 $S$ 字节，并假设存在一个硬性预算 $M$ 字节，使得生成的循环必须满足 $u\\cdot S \\leq M$。假设 $M \\geq S$，以确保至少未经展开的循环体能够容纳，并且 $u$ 必须是不超过 $N$ 的正整数。\n\n仅使用以下基本定义：总执行时间（以时钟周期为单位）是动态工作量与单位成本的乘积；循环展开将动态循环控制执行次数减少因子 $u$；完全可重叠的停顿可以在独立工作之间均匀分摊。请推导执行时间 $T(u)$（以时钟周期为单位）作为 $u$ 的函数，然后确定在满足约束条件 $u \\cdot S \\leq M$ 和 $1 \\leq u \\leq N$ 的情况下，使 $T(u)$ 最小化的整数展开因子 $u^{\\star}$。请将您的最终答案表示为关于 $M$、$S$ 和 $N$ 的 $u^{\\star}$ 的单个闭式符号表达式。",
            "solution": "问题陈述被评估为有效。它提出了一个定义明确的优化问题，其基础是编译原理和计算机体系结构。所提供的成本模型是循环展开性能影响的一个标准（尽管简化了）的表示，适用于解析处理。目标和约束条件的陈述足够精确，可以形式化地推导出一个唯一的解。\n\n短语“按比例减少循环控制的执行次数”以及要求仅用 $M$、$S$ 和 $N$ 表示的闭式解，强烈表明题意是使用一个简化的连续模型来表示循环执行次数，即 $\\frac{N}{u}$。该模型在高级性能分析中很常见，并假设总迭代次数 $N$ 足够大，以至于潜在的余数循环（当 $N$ 不是 $u$ 的整数倍时）的影响可以忽略不计。接下来的推导将在这个标准且符合上下文的假设下进行。\n\n总执行时间 $T(u)$ 是其各组成部分成本的总和：数据处理、循环控制和停顿。我们推导在 $N$ 次原始迭代中，每个部分的总成本作为展开因子 $u$ 的函数。\n\n$1$. 数据处理成本 ($C_{proc}$): 问题陈述指出，数据处理工作每次原始迭代的成本为 $b$ 个时钟周期，并且不受展开影响。因此，总数据处理成本是恒定的。\n$$C_{proc} = N \\cdot b$$\n\n$2$. 循环控制成本 ($C_{ctrl}$): 对于未展开的循环，控制开销会产生 $N$ 次。当循环以因子 $u$ 展开时，循环体被复制 $u$ 次，新循环运行 $\\frac{N}{u}$ 次迭代。成本为 $h$ 个时钟周期的循环控制逻辑（增量、比较、分支）在新循环的每次迭代中执行一次。因此，总循环控制成本为：\n$$C_{ctrl}(u) = \\frac{N}{u} \\cdot h$$\n\n$3$. 停顿成本 ($C_{stall}$): 在串行情况下，每次迭代产生 $d(s)$ 个时钟周期的停顿。当 $u$ 次迭代被展开时，停顿是“完全可重叠的”。这意味着对于每组 $u$ 次原始迭代，总停顿成本为 $d(s)$，而不是 $u \\cdot d(s)$。由于总共有 $\\frac{N}{u}$ 个这样的组，总停顿成本为：\n$$C_{stall}(u) = \\frac{N}{u} \\cdot d(s)$$\n\n总执行时间 $T(u)$ 是这些组成部分的总和。\n$$T(u) = C_{proc} + C_{ctrl}(u) + C_{stall}(u) = N \\cdot b + \\frac{N}{u} \\cdot h + \\frac{N}{u} \\cdot d(s)$$\n我们可以分解这个表达式，以分离出依赖于 $u$ 的项：\n$$T(u) = N \\left( b + \\frac{h + d(s)}{u} \\right)$$\n\n接下来，我们必须找到在给定约束条件下使 $T(u)$ 最小化的整数展开因子 $u^{\\star}$。\n$u$ 的约束条件是：\n- $u$ 必须是正整数：$u \\in \\{1, 2, 3, \\dots\\}$。\n- 展开后循环体的代码大小不能超过预算 $M$：$u \\cdot S \\leq M$。由于 $u$ 必须是整数，这等价于 $u \\leq \\left\\lfloor \\frac{M}{S} \\right\\rfloor$。\n- 展开因子不能大于迭代次数：$u \\leq N$。\n\n结合这些约束条件，$u$ 的可行整数值集合由 $1 \\leq u \\leq \\min\\left(N, \\left\\lfloor \\frac{M}{S} \\right\\rfloor\\right)$ 给出。问题陈述 $M \\geq S$，这确保了 $\\left\\lfloor \\frac{M}{S} \\right\\rfloor \\geq 1$，因此这个范围永远不为空。\n\n为了最小化 $T(u) = N \\left( b + \\frac{h + d(s)}{u} \\right)$，我们分析它对 $u$ 的依赖关系。对于给定的循环，参数 $N$、$b$、$h$ 和 $d(s)$ 是非负常数。我们假设 $h + d(s) > 0$，否则 $T(u)$ 将与 $u$ 无关，优化问题将变得微不足道。在 $h + d(s) > 0$ 的情况下，对于 $u > 0$，项 $\\frac{h+d(s)}{u}$ 是关于 $u$ 的严格递减函数。因此，整个 $T(u)$ 表达式是关于 $u$ 的严格递减函数。\n\n为了在一个整数闭区间上最小化一个严格递减函数，必须选择该区间内最大的整数值。$u$ 的最大允许整数值是可行集的上界。\n$$u_{max} = \\min\\left(N, \\left\\lfloor \\frac{M}{S} \\right\\rfloor\\right)$$\n因此，最优展开因子 $u^{\\star}$ 就是这个最大允许值。\n$$u^{\\star} = \\min\\left(N, \\left\\lfloor \\frac{M}{S} \\right\\rfloor\\right)$$\n这个表达式给出了在给定模型和约束条件下，使执行时间最小化的整数展开因子。",
            "answer": "$$\\boxed{\\min\\left(N, \\left\\lfloor \\frac{M}{S} \\right\\rfloor\\right)}$$"
        },
        {
            "introduction": "编译器的优化目标通常不是单一指标，而是多个相互竞争因素的组合。本练习将探讨一个更复杂的场景，它同时涉及寄存器压力和执行时间。当寄存器压力过高时，将变量溢出到内存会严重影响性能。此练习引入了一个字典序目标——当寄存器压力超过阈值时，优先降低寄存器压力，否则才去优化执行时间。你需要决定是否应用“重物质化”这一技术，它通过增加计算来换取寄存器占用的减少。",
            "id": "3628550",
            "problem": "考虑一个包含十二条指令的单一基本块，以及一个简单的机器成本模型，其中每条指令都有一个整数周期开销。主要优化目标按字典序定义如下：当寄存器压力 $R$ 超过阈值 $\\rho$ 时，首先最小化 $R$；否则，最小化执行时间 $T$。假设只允许对从常量计算出的值进行重物质化，并且重物质化在每个使用点重新计算该值，而不是在整个块中保持其活跃。\n\n使用以下基本定义作为推理的基础。寄存器压力 $R$ 是所有程序点上同时活跃的变量数量的最大值。如果一个变量的值将在块中的某个后续指令中使用，那么它在该程序点上是活跃的。执行时间 $T$ 建模为块中所有指令的周期开销之和。重物质化是一种变换，它移除一个可重算值的定义，并在其每个使用点之前立即插入一个等效的定义；这种变换缩短了该值的活跃范围，但通过增加指令来增加 $T$。重点严格在于塑造优化目标和范围：仅当 $R > \\rho$ 时，为了满足主要目标，才会做出重物质化的决策。\n\n该块是：\n$$(I_1):\\ x \\leftarrow \\mathrm{load}(M_1)\\ (\\text{cost }4)$$\n$$(I_2):\\ y \\leftarrow \\mathrm{load}(M_2)\\ (\\text{cost }4)$$\n$$(I_3):\\ v \\leftarrow d + e\\ (\\text{cost }1)$$\n$$(I_4):\\ t_1 \\leftarrow x + y\\ (\\text{cost }1)$$\n$$(I_5):\\ t_2 \\leftarrow t_1 \\times c\\ (\\text{cost }2)$$\n$$(I_6):\\ t_3 \\leftarrow x - y\\ (\\text{cost }1)$$\n$$(I_7):\\ t_4 \\leftarrow t_3 + t_2\\ (\\text{cost }1)$$\n$$(I_8):\\ r_2 \\leftarrow t_3 + 1\\ (\\text{cost }1)$$\n$$(I_9):\\ r_3 \\leftarrow t_2 + 1\\ (\\text{cost }1)$$\n$$(I_{10}):\\ r_1 \\leftarrow t_1 + v\\ (\\text{cost }1)$$\n$$(I_{11}):\\ r_4 \\leftarrow t_4 + 1\\ (\\text{cost }1)$$\n$$(I_{12}):\\ r_5 \\leftarrow v + 1\\ (\\text{cost }1)$$\n\n假设 $d$、$e$ 和 $c$ 是常量，因此 $v$ 是可重物质化的。使用情况如下：\n- $x$ 在 $(I_4)$ 和 $(I_6)$，\n- $y$ 在 $(I_4)$ 和 $(I_6)$，\n- $v$ 在 $(I_{10})$ 和 $(I_{12})$，\n- $t_1$ 在 $(I_5)$ 和 $(I_{10})$，\n- $t_2$ 在 $(I_7)$ 和 $(I_9)$，\n- $t_3$ 在 $(I_7)$ 和 $(I_8)$，\n- $t_4$ 在 $(I_{11})$。\n\n设阈值为 $\\rho = 4$。在给定的目标和成本模型下，决定是否应对 $v$ 应用重物质化，并计算满足该目标所需的最小额外执行时间（以周期为单位）。将您的最终数值答案表示为单个数字。无需四舍五入。",
            "solution": "该问题要求评估是否对给定基本块中的变量 $v$ 应用重物质化优化。该决策由一个字典序优化目标决定：首先，如果寄存器压力 $R$ 超过阈值 $\\rho$，则最小化 $R$；其次，最小化执行时间 $T$。\n\n首先，我们分析没有任何变换的基本块的初始状态。\n\n总执行时间 $T_{orig}$ 是这 12 条指令的开销之和：\n$$T_{orig} = 4 + 4 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 19 \\text{ cycles}$$\n\n接下来，我们必须确定寄存器压力 $R_{orig}$。寄存器压力是任何程序点上同时活跃的变量的最大数量。如果一个变量的值被后续指令使用，那么它在该点是活跃的。我们确定每条指令执行后紧邻的程序点上的活跃变量集合。\n\n临时变量的活跃范围如下：\n- $x$：在 $I_1$ 定义，最后在 $I_6$ 使用。\n- $y$：在 $I_2$ 定义，最后在 $I_6$ 使用。\n- $v$：在 $I_3$ 定义，最后在 $I_{12}$ 使用。\n- $t_1$：在 $I_4$ 定义，最后在 $I_{10}$ 使用。\n- $t_2$：在 $I_5$ 定义，最后在 $I_9$ 使用。\n- $t_3$：在 $I_6$ 定义，最后在 $I_8$ 使用。\n- $t_4$：在 $I_7$ 定义，最后在 $I_{11}$ 使用。\n\n让我们确定在关键点的活跃变量集的大小：\n- 在 $I_1$ 之后：$\\{x\\}$，大小为 $1$。\n- 在 $I_2$ 之后：$\\{x, y\\}$，大小为 $2$。\n- 在 $I_3$ 之后：$\\{x, y, v\\}$，大小为 $3$。\n- 在 $I_4$ 之后：$\\{x, y, v, t_1\\}$，大小为 $4$。\n- 在 $I_5$ 之后：变量 $x$（在 $I_6$ 使用）、$y$（在 $I_6$ 使用）、$v$（在 $I_{10}, I_{12}$ 使用）、$t_1$（在 $I_{10}$ 使用）和 $t_2$（在 $I_7, I_9$ 使用）都是活跃的。活跃集为 $\\{x, y, v, t_1, t_2\\}$，其大小为 $5$。\n- 在 $I_6$ 之后：$x$ 和 $y$ 不再活跃。$t_3$ 变为活跃。活跃集为 $\\{v, t_1, t_2, t_3\\}$，大小为 $4$。\n- 在 $I_7$ 之后：$t_2$（在 $I_9$ 使用）和 $t_3$（在 $I_8$ 使用）仍然活跃。$t_4$ 变为活跃。活跃集为 $\\{v, t_1, t_2, t_3, t_4\\}$，大小为 $5$。\n\n同时活跃变量的最大数量为 $5$。因此，初始寄存器压力为 $R_{orig} = 5$。\n问题陈述了寄存器压力阈值为 $\\rho = 4$。由于 $R_{orig} = 5 > \\rho = 4$，主要优化目标是最小化寄存器压力。我们必须评估重物质化是否能实现这一目标。\n\n其次，我们分析对 $v$ 进行重物质化之后的基本块的状态。\n变量 $v$ 是从常量（$d$ 和 $e$）计算得出的，因此是可重物质化的。该变换包括移除指令 $I_3$ 处 $v$ 的原始定义，并在其每个使用点 $I_{10}$ 和 $I_{12}$ 之前立即插入一个新的定义。\n\n指令 $I_3$（开销为 $1$）被移除。两条新指令，每条都是 $I_3$ 的副本且开销为 $1$，被插入到块中。\n指令总数变为 $12 - 1 + 2 = 13$。\n新的执行时间 $T_{remat}$ 为：\n$$T_{remat} = T_{orig} - \\text{cost}(I_3) + 2 \\times \\text{cost}(\\text{remat_op}) = 19 - 1 + 2 \\times 1 = 20 \\text{ cycles}$$\n\n现在，我们计算新的寄存器压力 $R_{remat}$。重物质化 $v$ 的关键影响是消除了其从 $I_3$ 之后延伸到 $I_{12}$ 之后的长活跃范围。$v$ 的新的重物质化实例具有极短的活跃范围，仅存在于其新定义和其唯一的相应使用之间。\n我们在相同的关键程序点重新评估活跃集的大小，注意到变量 $v$ 已不再存在：\n- 在 $I_5$ 之后：活跃集现在是 $\\{x, y, t_1, t_2\\}$。其大小为 $4$。\n- 在 $I_7$ 之后：活跃集现在是 $\\{t_1, t_2, t_3, t_4\\}$。其大小为 $4$。\n\n在块的主体部分，任何一点的活跃变量最大数量现在是 $4$。插入新定义不会产生新的最大值。例如，在 $I_{10}$ 之前对 $v$ 进行重物质化之后，活跃集是 $\\{t_1, t_4, v\\}$，其大小为 $3$。因此，新的寄存器压力是 $R_{remat} = 4$。\n\n最后，我们应用决策逻辑。\n初始状态下 $R_{orig} = 5$，这违反了条件 $R \\le \\rho$。主要目标是最小化 $R$。\n重物质化变换将寄存器压力从 $R_{orig} = 5$ 降低到 $R_{remat} = 4$。由于 $R_{remat}  R_{orig}$，该变换是有益的，并且根据给定的目标，是强制性的。通过应用重物质化，新的寄存器压力 $R_{remat} = 4$ 满足了条件 $R \\le \\rho$。\n\n问题要求为满足目标所需的最小额外执行时间。该变换对于满足主要目标是必要的，并且此变换增加了执行时间。\n额外执行时间是新的执行时间与原始执行时间之差：\n$$\\Delta T = T_{remat} - T_{orig} = 20 - 19 = 1$$\n\n因此，应应用对 $v$ 的重物质化，并且满足优化目标所需的最小额外执行时间为 $1$ 个周期。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "优化的“作用域”对其正确性至关重要，尤其是在现代多核系统中。一个在单线程环境中看似安全的优化，在并发环境下可能变得不再正确，甚至引入难以察觉的严重错误。本练习展示了一个经典场景：将数组边界检查从循环中提取的优化，与一个并发执行的线程发生交互，从而可能导致内存安全漏洞。这个思想实验强调了编译器在定义转换规则时，必须将并发在内的整个程序执行模型都纳入考量范围。",
            "id": "3628541",
            "problem": "考虑一个采用简单命令式语言编写的共享内存程序，该程序有两个线程，一个容量为 $N$ 的共享数组 $A$，以及一个表示 $A$ 当前逻辑长度的共享整数 $n$，满足 $0 \\leq n \\leq N$。内存模型是顺序一致性（Sequential Consistency, SC），意味着所有线程的所有操作可以被看作是交错在一个单一的总序中，该总序尊重每个线程的程序顺序。编译器必须在该 SC 模型下保留可观察行为，其中可观察行为包括内存安全（没有越界访问）、读写到共享位置的值，以及依赖于共享数据的控制流决策。\n\n线程 $T_1$ 执行一个循环，聚合 $A$ 的元素，每次迭代都使用 $n$ 的当前值进行边界检查：\n- 对于从 $0$ 开始递增 $1$ 直到并包括 $N-1$ 的每个整数 $i$，循环体读取 $n$ 并执行：如果 $i  n$，则读取 $A[i]$ 并将其加到一个局部累加器 $s$ 中。累加是局部计算，不写入共享内存。形式上，在第 $i$ 次迭代时，$T_1$ 使用在该次迭代读取的 $n$ 的值来评估谓词 $i  n$，并且当且仅当该谓词为真时才访问 $A[i]$。\n\n线程 $T_2$ 可以在 $T_1$ 执行期间并发地减小 $n$ 的值，以反映逻辑数组的缩小。此外，当 $T_2$ 将 $n$ 减小到某个值 $n'$ 时，它可能会立即重用或使所有满足 $n' \\leq j \\leq N-1$ 的整数 $j$ 的位置 $A[j]$ 失效（例如，通过将这些位置转移到另一个池或将它们标记为不可访问）。假设对 $n$ 和 $A[\\cdot]$ 的所有读写在 SC 意义上都是原子的，但没有同步在 $T_1$ 和 $T_2$ 之间建立 happens-before 关系。\n\n编译器考虑对 $T_1$ 进行以下优化：不是在每次迭代中读取 $n$ 并检查 $i  n$，而是在循环前获取 $n$ 的单个快照 $n_0$，并将受保护的循环替换为一个无保护的循环，该循环使 $i$ 从 $0$ 运行到 $n_0 - 1$，并在每次迭代中访问 $A[i]$。换句话说，它将每次迭代的检查 $i  n$ 转换为一个固定的边界 $n_0$，假设 $n$ 在循环期间是不变的。\n\n基于上述场景和 SC 模型，关于此优化正确性的以下哪些陈述是正确的？\n\nA. 在顺序一致性下，如果 $T_2$ 可以在 $T_1$ 的循环期间减小 $n$ 并在减小的那一刻立即使 $j \\geq n$ 的 $A[j]$ 失效，那么用单个循环前快照 $n_0$ 替换每次迭代的检查 $i  n$ 不是保留语义的，因为优化后的循环可能会访问索引为 $i$ 的 $A[i]$，而此时 $i \\geq n$，这违反了内存安全。\n\nB. 仅将 $n$ 声明为原子变量就足以使优化变得可靠，因为原子性确保了并发写入的可见性，因此单个快照 $n_0$ 是重复检查的可接受替代品。\n\nC. 如果优化范围被限制在有证据（例如，通过全程序分析或语言级保证）证明在循环的动态范围内除了 $T_1$ 没有其他线程写入 $n$ 的情况，那么该优化是可靠的，这样 $n$ 在循环运行时实际上是不变的。\n\nD. 该优化是可靠的，无论是否存在并发，因为 $i$ 单调递增，并且在循环入口处 $i  n$ 意味着对于所有后续迭代 $i  n$ 也成立。\n\nE. 如果编译器的范围被定义为忽略其他线程对共享变量的并发写入的线程内语义，那么该优化是可靠的，因为正确性可以仅通过 $T_1$ 的行为来判断。\n\n选择所有适用的选项。使用 SC 模型和所述的可观察行为概念来证明你的选择。你的证明应明确使用顺序一致性、可观察行为的定义，以及每次迭代检查 $i  n$ 与循环前快照 $n_0$ 在决定访问哪些 $A[i]$ 方面的作用。",
            "solution": "优化的正确性取决于优化后程序的所有可观察行为是否也是原始程序在顺序一致性（SC）模型下的合法行为。可观察行为明确包括内存安全。\n\n**分析优化**：优化将每次迭代的检查 $i  n$ 替换为循环前的快照 $n_0$。循环变为 `for i from 0 to n_0 - 1`，并无条件访问 $A[i]$。\n\n**考虑一个具体的交错执行场景**：\n1.  初始状态：共享变量 $n = 10$。\n2.  线程 $T_1$ 执行循环前的代码，读取 $n$ 并设置其局部快照 $n_0 = 10$。\n3.  线程 $T_2$ 获得执行机会。它将 $n$ 的值减小到 $5$，并立即使 $A[5]$ 到 $A[9]$ 的内存位置失效。\n4.  线程 $T_1$ 恢复执行，开始其优化后的循环，该循环打算从 $i=0$ 运行到 $9$。\n5.  当 $i$ 到达 $5$ 时，$T_1$ 将尝试访问 $A[5]$。然而，此时 $n$ 的实际值是 $5$，并且 $A[5]$ 的内存已经失效。\n\n**结论**：这次访问 $A[5]$ 是一个越界或非法内存访问，违反了内存安全。在原始程序中，$T_1$ 在访问 $A[5]$ 之前会再次读取 $n$（其值为5），发现 $5  5$ 为假，因此不会访问 $A[5]$。由于优化后的程序引入了原始程序中不可能发生的行为（内存不安全），因此该优化在并发环境下是不正确的。\n\n**评估选项**：\n*   **A**: 正确。如上所示，优化后的循环可能访问已被并发线程 $T_2$ 判为无效的内存，导致内存安全违规。\n*   **B**: 错误。将变量声明为`atomic`仅保证对 $n$ 的读写是不可分的，但不能阻止 $T_1$ 在读取 $n$ 和使用该值之间发生 $n$ 的值改变。这是一个典型的“检查时-使用时”（Time-of-Check-to-Time-of-Use, TOCTOU）竞争条件。\n*   **C**: 正确。如果编译器能证明 $n$ 在循环执行期间不被其他线程修改（即 $n$ 是循环不变量），那么快照 $n_0$ 将始终等于 $n$ 的实时值，优化就是安全的。这是正确定义优化作用域的关键。\n*   **D**: 错误。该论点仅在 $n$ 不变时成立。在并发环境中，这个前提不成立。\n*   **E**: 错误。编译器的正确性必须在语言规范定义的完整内存模型（此处为SC）下得到保证，这包括与其他线程的交互。忽略并发写入等同于在一个错误的模型下进行推理。",
            "answer": "$$\\boxed{AC}$$"
        }
    ]
}