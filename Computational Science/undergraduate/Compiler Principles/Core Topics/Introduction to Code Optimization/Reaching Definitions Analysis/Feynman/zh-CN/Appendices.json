{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个练习聚焦于数据流分析中最基础的概念：生成集（$GEN$）和杀死集（$KILL$）。一个看似无用的自赋值语句，如 $x = x$，在到达定值分析中有着精确的形式化含义。这个练习将挑战你对“定值”和“杀死”的严格定义，确保你从根本上理解这些集合是如何构建的。",
            "id": "3665861",
            "problem": "在经典的、用于无指针或别名的命令式程序的可达定义（reaching definitions）前向位向量数据流问题中，一个定义（definition）是对变量的任何赋值。考虑以下带有标记赋值位置的程序片段，其中每个标记表示一个唯一定义位置：\n- $d_{1}$: $x = 1$\n- $d_{2}$: $y = x$\n- $d_{3}$: $x = y$\n- $d_{4}$: $z = 0$\n- $d_{5}$: $x = x$\n- $d_{6}$: $x = z$\n- $d_{7}$: $w = x$\n- $d_{8}$: $x = 3$\n\n设 $B$ 是一个基本块，它仅包含单条语句 $d_{5}$（即自赋值语句 $x = x$）。使用在按变量名“杀死”（kill-by-variable-name）语义下（无别名且无间接引用）可达定义的生成集 $\\mathrm{GEN}[B]$ 和“杀死”集 $\\mathrm{KILL}[B]$ 的标准定义，确定自赋值 $x = x$ 是否“杀死”了先前对 $x$ 的定义，以及它是否为 $x$ 生成了一个新的定义位置。然后，计算基数的值\n$$\\left|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]\\right|.$$\n\n请以单个整数形式提供最终答案。无需四舍五入，不涉及物理单位。",
            "solution": "此问题是在编译器理论中数据流分析的既定形式框架内的一个适定问题，要求我们为一个特定的基本块 $B$ 计算其生成集 $\\mathrm{GEN}[B]$ 和杀死集 $\\mathrm{KILL}[B]$。\n\n首先，我们形式化这些集合的标准定义：\n- **生成集 $\\mathrm{GEN}[B]$**：在块 $B$ 中创建的、并且能够到达 $B$ 末尾的定义的集合。\n- **杀死集 $\\mathrm{KILL}[B]$**：程序中被块 $B$ 内的定义所“杀死”（即覆盖）的所有定义的集合。根据标准定义，如果一个块 $B$ 定义了变量 $v$，那么 $B$ 的 $KILL$ 集就包含程序中所有对变量 $v$ 的定义（包括 $B$ 内部的定义）。\n\n程序中给出了8个唯一定义位置：\n$D = \\{d_{1}, d_{2}, d_{3}, d_{4}, d_{5}, d_{6}, d_{7}, d_{8}\\}$\n其中对变量 $x$ 的定义有：\n- $d_{1}: x = 1$\n- $d_{3}: x = y$\n- $d_{5}: x = x$\n- $d_{6}: x = z$\n- $d_{8}: x = 3$\n所有对 $x$ 的定义的集合是 $D_x = \\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\}$。\n\n基本块 $B$ 由单条语句 $d_{5}: x = x$ 组成。\n\n1.  **计算 $\\mathrm{GEN}[B]$**:\n    块 $B$ 中唯一的语句是定义 $d_5$。由于块内没有后续语句来覆盖它，该定义到达块的末尾。因此，自赋值语句 $x=x$ 确实为 $x$ 生成了一个新的定义位置 $d_5$。\n    $$ \\mathrm{GEN}[B] = \\{d_{5}\\} $$\n\n2.  **计算 $\\mathrm{KILL}[B]$**:\n    块 $B$ 中的定义 $d_5$ 是对变量 $x$ 的一次赋值。根据“按变量名杀死”的语义，这个定义会“杀死”程序中所有对变量 $x$ 的定义。因此，$\\mathrm{KILL}[B]$ 就是程序中所有对变量 $x$ 的定义的集合。\n    $$ \\mathrm{KILL}[B] = D_x = \\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\} $$\n    这证实了赋值 $d_5: x=x$ 确实“杀死”了先前对 $x$ 的定义（$d_1, d_3, d_6, d_8$），并且在形式上，它也杀死了自己（$d_5$）。\n\n3.  **计算并集及其基数**:\n    问题要求计算 $|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]|$。\n    我们有：\n    - $\\mathrm{GEN}[B] = \\{d_{5}\\}$\n    - $\\mathrm{KILL}[B] = \\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\}$\n\n    这两个集合的并集是：\n    $$ \\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B] = \\{d_{5}\\} \\cup \\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\} $$\n    $$ \\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B] = \\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\} $$\n    这个并集就是 $\\mathrm{KILL}[B]$ 本身，因为 $\\mathrm{GEN}[B]$ 是 $\\mathrm{KILL}[B]$ 的一个子集。\n\n    集合的基数是其元素的数量：\n    $$ \\left|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]\\right| = \\left|\\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\}\\right| = 5 $$\n\n最终值为 $5$。",
            "answer": "$$\n\\boxed{5}\n$$"
        },
        {
            "introduction": "掌握了基础之后，我们来处理一个更复杂的控制流结构。这个练习模拟了一个带有“贯穿”（fallthrough）行为的`switch-case`语句，这在C/C++等语言中很常见。你需要仔细追踪所有可能的执行路径，并在控制流的汇合点正确地使用并集操作，以确定在`switch`结构之后哪些定值是可达的。",
            "id": "3665852",
            "problem": "给定一个类C语言的代码片段，其中包含一个多路分支，该分支在标记的块之间存在隐式直通（fallthrough）。所有变量均为整型。只考虑单个变量 $x$ 的定义（赋值）。代码如下：\n\n```c\nint x = -1; /* D_1 */\nswitch (s) {\n  case 0:\n    if (u) { x = 0; } /* D_2 */\n    /* fallthrough */\n  case 1:\n    y = x + 1;\n    break;\n  case 2:\n    x = 20; /* D_3 */\n    /* fallthrough */\n  case 3:\n    a = 3;\n    /* fallthrough */\n  case 4:\n    x = 40; /* D_4 */\n    break;\n  default:\n    if (v) { x = 50; } /* D_5 */\n    /* else: no definition of x */\n    /* no break: falls out of the switch */\n}\nw = x;\n```\n\n假设使用标准的类C语言的 $switch$ 语义：控制流转移到第一个匹配的标签，在没有 $break$ 的情况下，会顺序继续执行后续的标记块（如果后面有 $default$ 块，也包括在内），而 $break$ 会退出 $switch$。谓词 $u$ 和 $v$ 是不确定的布尔值，分析必须保守地考虑在这些语义下所有可行的路径。在 $switch$ 语句之后（即赋值语句 $w = x$ 之前）的程序点上，对单个变量 $x$ 执行经典的前向“可能到达”定义分析 (forward may-reaching-definitions analysis)。\n\n将 $x$ 的五个不同定义按其在程序文本中出现的顺序标识为 $D_1, D_2, D_3, D_4, D_5$，如上面的注释所示。将 $switch$ 出口处 $x$ 的到达定义集合编码为一个长度为 $5$ 的位向量，其中第 $i$ 位对应于 $D_i$，$D_1$ 映射到最低有效位（权重为 $2^{0}$），$D_5$ 映射到最高有效位（权重为 $2^{4}$）。将此位向量解释为一个以 $2$ 为底的非负整数。\n\n这个整数是多少？请提供一个精确的整数。无需四舍五入。",
            "solution": "该问题是有效的，因为它是经典数据流分析中的一个明确定义的练习，而数据流分析是编译器理论的核心主题。该问题具有科学依据，是客观的，并包含了得出唯一解所需的所有信息。\n\n目标是为变量 $x$ 执行前向“可能”到达定义分析。如果存在至少一条从定义 $D$ 之后的位置到程序点 $P$ 的控制流路径，并且在这条路径上变量 $x$ 没有被重新定义，那么我们说变量 $x$ 的定义 $D$ 到达了程序点 $P$。我们关心的是所有到达 `switch` 语句之后程序点的定义的集合。\n\n设 $x$ 的所有定义的集合为 $\\mathcal{D} = \\{D_1, D_2, D_3, D_4, D_5\\}$。分析通过跟踪程序控制流图中的到达定义集合 $RD$ 来进行。\n\n1.  **初始状态**：在 `switch` 语句之前，出现了第一个定义 $D_1: x = -1$。因此，在 `switch` 语句入口处的到达定义集合是 $RD_{entry} = \\{D_1\\}$。\n\n2.  **通过 `switch` 的路径分析**：我们必须考虑所有可能的路径，这些路径由 `switch` 变量 $s$ 的值和不确定的谓词 $u$ 和 $v$ 决定。\n\n    *   **$s=0$ 的路径**：\n        控制流转移到 `case 0`。传入的 $RD$ 集合为 $\\{D_1\\}$。\n        程序遇到 `if (u) { x = 0; }`，即定义 $D_2$。\n        - 如果 $u$ 为真，$D_2$ 被执行。$D_2$ 杀死 $D_1$（以及 $x$ 的所有其他定义）。$RD$ 集合变为 $\\{D_2\\}$。\n        - 如果 $u$ 为假，`if` 块被跳过，$RD$ 集合保持为 $\\{D_1\\}$。\n        由于这是“可能”分析，我们取两个分支结果的并集。在 `if` 语句之后的点，$RD = \\{D_1\\} \\cup \\{D_2\\} = \\{D_1, D_2\\}$。\n        然后控制流直通到 `case 1`。语句 `y = x + 1;` 使用了 $x$ 但没有重新定义它，所以 $RD$ 集合不变。\n        `break` 语句被执行，控制流退出 `switch`。\n        因此，通过此路径到达出口的定义集合是 $\\{D_1, D_2\\}$。\n\n    *   **$s=1$ 的路径**：\n        控制流转移到 `case 1`。传入的 $RD$ 集合为 $\\{D_1\\}$。\n        语句 `y = x + 1;` 没有重新定义 $x$。\n        `break` 语句退出 `switch`。\n        因此，通过此路径到达出口的定义集合是 $\\{D_1\\}$。\n\n    *   **$s=2$ 的路径**：\n        控制流转移到 `case 2`。传入的 $RD$ 集合为 $\\{D_1\\}$。\n        定义 $D_3: x = 20$ 被执行，杀死了 $D_1$。$RD$ 集合变为 $\\{D_3\\}$。\n        控制流直通到 `case 3`。语句 `a = 3;` 不影响 $x$，所以 $RD$ 集合仍然是 $\\{D_3\\}$。\n        控制流直通到 `case 4`。定义 $D_4: x = 40$ 被执行，杀死了 $D_3$。$RD$ 集合变为 $\\{D_4\\}$。\n        `break` 语句退出 `switch`。\n        因此，通过此路径到达出口的定义集合是 $\\{D_4\\}$。\n\n    *   **$s=3$ 的路径**：\n        控制流转移到 `case 3`。传入的 $RD$ 集合为 $\\{D_1\\}$。\n        语句 `a = 3;` 不影响 $x$。\n        控制流直通到 `case 4`。定义 $D_4: x = 40$ 被执行，杀死了 $D_1$。$RD$ 集合变为 $\\{D_4\\}$。\n        `break` 语句退出 `switch`。\n        因此，通过此路径到达出口的定义集合是 $\\{D_4\\}$。\n\n    *   **$s=4$ 的路径**：\n        控制流转移到 `case 4`。传入的 $RD$ 集合为 $\\{D_1\\}$。\n        定义 $D_4: x = 40$ 被执行，杀死了 $D_1$。$RD$ 集合变为 $\\{D_4\\}$。\n        `break` 语句退出 `switch`。\n        因此，通过此路径到达出口的定义集合是 $\\{D_4\\}$。\n\n    *   **`default` 的路径**：\n        对于 $s$ 的任何其他值，控制流转移到 `default` 块。传入的 $RD$ 集合为 $\\{D_1\\}$。\n        程序遇到 `if (v) { x = 50; }`，即定义 $D_5$。\n        - 如果 $v$ 为真，$D_5$ 被执行，杀死了 $D_1$。$RD$ 集合变为 $\\{D_5\\}$。\n        - 如果 $v$ 为假，`if` 块被跳过，$RD$ 集合保持为 $\\{D_1\\}$。\n        在 `if` 之后的合并点，并集为 $RD = \\{D_1\\} \\cup \\{D_5\\} = \\{D_1, D_5\\}$。\n        没有 `break`，因此控制流从 `switch` 中掉出。\n        因此，通过此路径到达出口的定义集合是 $\\{D_1, D_5\\}$。\n\n3.  **最终的到达定义集合**：所有“可能”到达 `switch` 之后程序点的定义的集合是来自所有可能进入 `switch` 语句的路径的集合的并集。\n    $RD_{exit} = \\underbrace{\\{D_1, D_2\\}}_{s=0} \\cup \\underbrace{\\{D_1\\}}_{s=1} \\cup \\underbrace{\\{D_4\\}}_{s=2} \\cup \\underbrace{\\{D_4\\}}_{s=3} \\cup \\underbrace{\\{D_4\\}}_{s=4} \\cup \\underbrace{\\{D_1, D_5\\}}_{\\text{default}}$\n    $RD_{exit} = \\{D_1, D_2, D_4, D_5\\}$。\n    注意，定义 $D_3$ 不会到达出口。任何执行 $D_3$ 的路径都必须直通到 `case 4`，在那里 $D_4$ 被执行，因此在路径退出 `switch` 之前杀死了 $D_3$。\n\n4.  **位向量编码**：问题要求将此集合编码为一个整数。位向量有 $5$ 位，其中第 $i$ 位（从1开始索引）对应于定义 $D_i$。$D_1$ 是最低有效位（LSB，位置 $0$，权重 $2^0$），$D_5$ 是最高有效位（MSB，位置 $4$，权重 $2^4$）。\n位向量是 $(b_4, b_3, b_2, b_1, b_0)$，其中如果 $D_i \\in RD_{exit}$ 则 $b_{i-1}=1$，否则 $b_{i-1}=0$。\n- $D_1 \\in RD_{exit} \\implies b_0 = 1$\n- $D_2 \\in RD_{exit} \\implies b_1 = 1$\n- $D_3 \\notin RD_{exit} \\implies b_2 = 0$\n- $D_4 \\in RD_{exit} \\implies b_3 = 1$\n- $D_5 \\in RD_{exit} \\implies b_4 = 1$\n得到的二进制数是 $11011_2$。\n\n5.  **整数转换**：我们将二进制数转换为其十进制整数表示。\n    值 $= 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$\n    值 $= 16 + 8 + 0 + 2 + 1 = 27$。",
            "answer": "$$\n\\boxed{27}\n$$"
        },
        {
            "introduction": "最后一个练习将所有关键概念——迭代、不动点和控制流变化——融合在一起。通过分析一个包含循环的控制流图（CFG），你将实践使用迭代算法直至到达“不动点”，这正是数据流分析的核心。此外，该问题还通过一个小的改动引入了不可达代码，让你观察分析结果如何随之改变，从而揭示了到达定值分析在死代码消除等优化中的应用潜力。",
            "id": "3665885",
            "problem": "考虑以下用于一个操作单个变量 $x$ 的单过程程序的微型控制流图 (CFG)。变量 $x$ 在循环头中用于控制迭代。块的标签为 $B_0$ 到 $B_6$，边被明确列出。对 $x$ 的所有赋值都是不同的定义。每个基本块的伪代码如下：\n- $B_0$: 入口；无条件跳转到 $B_1$。\n- $B_1$: if $c_1$ then goto $B_2$ else goto $B_5$.\n- $B_2$: $x := 10$; goto $B_3$.\n- $B_3$: while $(x < n)$ goto $B_4$ else goto $B_6$；这是使用 $x$ 的循环头。\n- $B_4$: $x := x + 1$; goto $B_3$.\n- $B_5$: $x := 20$; goto $B_3$.\n- $B_6$: 出口。\n\n设 $x$ 的三个不同定义分别表示为 $B_2$ 处的 $d_2$、$B_4$ 处的 $d_4$ 和 $B_5$ 处的 $d_5$。假设在此控制流图上进行标准的“前向、may（集合并）”到达定值分析，通常的解释是：如果存在一条从定义到某个程序点的路径，并且在该路径上该变量没有被重新定义，则该定义到达该程序点。使用常规的块局部集合 $GEN[b]$ 和 $KILL[b]$ 以及标准的到达定值数据流方程，并假设对于 $x$ 的一个定义，其 $KILL$ 集合包含程序中所有其他对 $x$ 的定义（无论可达性如何）。假设 $IN[B_0] = \\varnothing$。\n\n任务：\n- 首先，分析上述原始控制流图，并确定在稳态（不动点）下，$d_2$、$d_4$ 和 $d_5$ 中有哪些到达循环头 $B_3$。\n- 接下来，通过删除从 $B_1$ 到 $B_5$ 的边（使得 $B_1$ 现在只有到 $B_2$ 的边），使 $B_5$ 变得不可达，并保持所有其他块和边不变。重新进行到达定值分析，并确定在这个修改后的控制流图中，稳态下 $d_2$、$d_4$ 和 $d_5$ 中有哪些到达循环头 $B_3$。\n- 令 $\\kappa$ 表示修改后控制流图中集合 $IN[B_3]$ 的基数（在 $B_5$ 变得不可达之后）。将 $\\kappa$ 作为最终答案报告。无需四舍五入。将答案表示为一个精确的整数。",
            "solution": "该问题要求对给定的控制流图（CFG）以及其修改版本执行到达定值分析。这是编译器理论中一个标准的前向“may”分析问题。目标是确定对于一个给定的程序点，可能到达该点的定义集合。\n\n到达定值的数据流方程是：\n$$IN[b] = \\bigcup_{p \\in pred(b)} OUT[p]$$\n$$OUT[b] = GEN[b] \\cup (IN[b] \\setminus KILL[b])$$\n其中 $IN[b]$ 是到达基本块 $b$ 入口的定义集合，$OUT[b]$ 是到达 $b$ 出口的定义集合，$pred(b)$ 是 $b$ 的前驱集合，$GEN[b]$ 是在 $b$ 内部生成的定义集合，$KILL[b]$ 是程序中被 $b$ 内定义所“杀死”的定义集合。分析过程通过迭代应用这些方程直到达到不动点（即 $IN$ 和 $OUT$ 集合不再变化）。\n\n程序中所有定义的集合是 $D = \\{d_2, d_4, d_5\\}$，分别对应于块 $B_2$、$B_4$ 和 $B_5$ 中对变量 $x$ 的赋值。\n\n首先，我们为每个基本块建立 $GEN$ 和 $KILL$ 集合。一个包含 $x$ 定义的块 $b$ 会生成该定义。这一定义会杀死程序中所有其他对 $x$ 的定义。\n- $B_0$: 无定义。$GEN[B_0] = \\varnothing$，$KILL[B_0] = \\varnothing$。\n- $B_1$: 无定义。$GEN[B_1] = \\varnothing$，$KILL[B_1] = \\varnothing$。\n- $B_2$: 包含定义 $d_2$ ($x := 10$)。$GEN[B_2] = \\{d_2\\}$，$KILL[B_2] = D \\setminus \\{d_2\\} = \\{d_4, d_5\\}$。\n- $B_3$: 无定义（仅使用）。$GEN[B_3] = \\varnothing$，$KILL[B_3] = \\varnothing$。\n- $B_4$: 包含定义 $d_4$ ($x := x + 1$)。$GEN[B_4] = \\{d_4\\}$，$KILL[B_4] = D \\setminus \\{d_4\\} = \\{d_2, d_5\\}$。\n- $B_5$: 包含定义 $d_5$ ($x := 20$)。$GEN[B_5] = \\{d_5\\}$，$KILL[B_5] = D \\setminus \\{d_5\\} = \\{d_2, d_4\\}$。\n- $B_6$: 无定义。$GEN[B_6] = \\varnothing$，$KILL[B_6] = \\varnothing$。\n\n**原始控制流图分析**\n\n在原始CFG中，循环头 $B_3$ 有三个前驱：$B_2$、$B_4$ 和 $B_5$。因此，$IN[B_3] = OUT[B_2] \\cup OUT[B_4] \\cup OUT[B_5]$。我们寻求该集合的稳态值。\n\n1.  存在路径 $B_0 \\to B_1 \\to B_2 \\to B_3$。定义 $d_2$ 在 $B_2$ 中生成，并且在边 $B_2 \\to B_3$ 上没有被杀死。因此，$d_2$ 到达 $B_3$ 的入口。在稳态下，$\\{d_2\\} \\subseteq OUT[B_2]$。\n2.  存在路径 $B_0 \\to B_1 \\to B_5 \\to B_3$。定义 $d_5$ 在 $B_5$ 中生成，并且在边 $B_5 \\to B_3$ 上没有被杀死。因此，$d_5$ 到达 $B_3$ 的入口。在稳态下，$\\{d_5\\} \\subseteq OUT[B_5]$。\n3.  循环创建了路径 $B_3 \\to B_4 \\to B_3$。任何到达 $B_3$ 入口的定义（即在 $IN[B_3]$ 中）都会通过到其出口（因为 $KILL[B_3] = \\varnothing$），从而到达 $B_4$ 的入口。在 $B_4$ 中，生成定义 $d_4$，所有其他定义（$d_2, d_5$）被杀死。因此，$OUT[B_4]$ 将包含 $d_4$。这个定义会沿着边 $B_4 \\to B_3$ 流回到 $B_3$ 的入口。\n\n综合这些，到达 $B_3$ 入口的定义集合是来自其所有前驱的定义的并集。在不动点处，我们有：\n- $OUT[B_2]$ 包含 $d_2$。\n- $OUT[B_5]$ 包含 $d_5$。\n- $OUT[B_4]$ 包含 $d_4$。\n因此，对于原始CFG，$IN[B_3] = \\{d_2, d_4, d_5\\}$。\n\n**修改后控制流图的分析**\n\n通过删除从 $B_1$ 到 $B_5$ 的边来修改CFG。我们必须重新评估循环头 $B_3$ 的到达定值。\n\n此修改的关键后果是块 $B_5$ 变得不可达。不再有从入口块 $B_0$ 到 $B_5$ 的任何路径。到达定值的基本定义是“如果存在一条从定义到某个程序点的路径，则该定义到达该程序点”。这意味着定义本身必须位于从程序入口开始的可执行路径上。由于 $B_5$ 是不可达的，其包含的定义 $d_5$ 在程序执行期间永远不会被创建。因此，$d_5$ 无法到达程序中的任何点。\n\n虽然盲目地将数据流方程应用于图结构可能会暗示 $d_5$ 从孤立的 $B_5$ 块传播出来，但这将是一种误解。分析必须反映程序执行的语义。因此，我们可以有效地从分析中剪除不可达的块 $B_5$ 及其出边 $B_5 \\to B_3$。\n\n在修改并剪枝后的CFG中，$B_3$ 的前驱现在是 $pred(B_3) = \\{B_2, B_4\\}$。活跃定义的集合减少到 $\\{d_2, d_4\\}$。分析过程如下：\n- 路径 $B_0 \\to B_1 \\to B_2 \\to B_3$ 不受影响。来自 $B_2$ 的定义 $d_2$ 到达 $B_3$ 的入口。\n- 循环路径 $B_3 \\to B_4 \\to B_3$ 也不受影响。来自 $B_4$ 的定义 $d_4$ 到达 $B_3$ 的入口。\n- 来自 $B_5$ 的路径不再存在。\n\n因此，到达 $B_3$ 入口的定义集合是来自可达前驱 $B_2$ 和 $B_4$ 的定义的并集。\n$$IN[B_3] = OUT[B_2] \\cup OUT[B_4]$$\n在不动点处，这解析为：\n$$IN[B_3] = \\{d_2\\} \\cup \\{d_4\\} = \\{d_2, d_4\\}$$\n\n**最终计算**\n\n问题要求计算 $\\kappa$ 的值，$\\kappa$ 定义为修改后控制流图中集合 $IN[B_3]$ 的基数。\n$$\\kappa = |IN[B_3]| = |\\{d_2, d_4\\}|$$\n$$\\kappa = 2$$",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}