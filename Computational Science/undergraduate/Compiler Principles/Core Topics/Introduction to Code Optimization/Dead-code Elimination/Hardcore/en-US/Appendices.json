{
    "hands_on_practices": [
        {
            "introduction": "To master dead-code elimination, you must first understand its mechanical foundation: liveness analysis. This exercise  provides a concrete Control Flow Graph (CFG) and requires a step-by-step application of the liveness equations to determine which variables hold values that are no longer needed. By meticulously tracking which variables are live at each program point, you will be able to definitively identify and eliminate assignments whose results are never used.",
            "id": "3636224",
            "problem": "You are given a straight-line program with branches organized as a Control Flow Graph (CFG). All arithmetic assignments are pure (no side effects), and the only control operations that must always be preserved are conditional branches and the final return. The CFG has four basic blocks $B_1, B_2, B_3, B_4$ with directed edges $B_1 \\to B_2$, $B_1 \\to B_3$, $B_2 \\to B_4$, $B_3 \\to B_4$. Within each block, instructions are numbered in program order as follows.\n\nBlock $B_1$:\n- $1$: $a \\leftarrow 1$\n- $2$: $b \\leftarrow a + 2$\n- $3$: $c \\leftarrow b \\times 3$\n- $4$: \\text{if } $c  10$ \\text{ goto } $B_2$ \\text{ else goto } $B_3$\n\nBlock $B_2$:\n- $5$: $d \\leftarrow c - 4$\n- $6$: $e \\leftarrow d + b$\n- $7$: $t \\leftarrow d - d$\n- $8$: $a \\leftarrow e \\times 2$\n- $9$: \\text{goto } $B_4$\n\nBlock $B_3$:\n- $10$: $d \\leftarrow a + 5$\n- $11$: $b \\leftarrow 7$\n- $12$: $f \\leftarrow b + d$\n- $13$: $u \\leftarrow b - b$\n- $14$: \\text{goto } $B_4$\n\nBlock $B_4$:\n- $15$: $g \\leftarrow a + 1$\n- $16$: $h \\leftarrow g + d$\n- $17$: \\text{return } $h$\n\nUsing the fundamental definition that a variable is live at a program point if and only if along some path from that point there is a use of the variable before any redefinition, perform backward live-variable analysis on this CFG to a fixed point, and then perform dead-code elimination of arithmetic assignments as follows: within each basic block $B$, scan the instructions in reverse order, maintaining a live set initially equal to the liveness set immediately after the block; an arithmetic assignment $x \\leftarrow \\text{expr}$ is dead if $x$ is not in the current live set, in which case it can be removed and its uses are not added to the live set. If the instruction is not dead, update the live set by removing the defined variable and adding its used variables.\n\nAfter completing this process in all blocks, how many arithmetic assignment instructions are eliminated in total? Provide your final answer as a single integer. No rounding is needed, and no units are required.",
            "solution": "The problem requires us to perform live-variable analysis on a given Control Flow Graph (CFG) and then use the results to perform dead-code elimination. The final answer is the total number of arithmetic assignment instructions eliminated.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens:**\n- **CFG Structure:** Four basic blocks $B_1, B_2, B_3, B_4$.\n- **Edges:** $B_1 \\to B_2$, $B_1 \\to B_3$, $B_2 \\to B_4$, $B_3 \\to B_4$.\n- **Block $B_1$ Instructions:**\n  - $1$: $a \\leftarrow 1$\n  - $2$: $b \\leftarrow a + 2$\n  - $3$: $c \\leftarrow b \\times 3$\n  - $4$: if $c  10$ goto $B_2$ else goto $B_3$\n- **Block $B_2$ Instructions:**\n  - $5$: $d \\leftarrow c - 4$\n  - $6$: $e \\leftarrow d + b$\n  - $7$: $t \\leftarrow d - d$\n  - $8$: $a \\leftarrow e \\times 2$\n  - $9$: goto $B_4$\n- **Block $B_3$ Instructions:**\n  - $10$: $d \\leftarrow a + 5$\n  - $11$: $b \\leftarrow 7$\n  - $12$: $f \\leftarrow b + d$\n  - $13$: $u \\leftarrow b - b$\n  - $14$: goto $B_4$\n- **Block $B_4$ Instructions:**\n  - $15$: $g \\leftarrow a + 1$\n  - $16$: $h \\leftarrow g + d$\n  - $17$: return $h$\n- **Liveness Definition:** A variable is live at a program point if there is a path from that point where the variable is used before it is redefined.\n- **Dead-Code Elimination Algorithm:** For each block $B$, scan instructions in reverse. An assignment $x \\leftarrow \\text{expr}$ is dead if $x$ is not in the current live set. If dead, remove it and do not add its uses to the live set. If live, update the live set by removing $x$ and adding the variables used in $\\text{expr}$.\n\n**1.2. Validate Using Extracted Givens:**\nThe problem is a standard exercise in compiler optimization theory. It is self-contained, with all necessary data and algorithms provided. The CFG, instructions, and procedures are well-defined. The problem is scientifically grounded, objective, and well-posed. There are no contradictions, ambiguities, or factual unsoundness. Thus, the problem is valid.\n\n### Step 2: Live-Variable Analysis\n\nWe perform a backward data-flow analysis to find the set of live variables at the entry ($\\text{In}[B]$) and exit ($\\text{Out}[B]$) of each basic block $B$.\n\nFirst, we determine the $\\text{Use}[B]$ and $\\text{Def}[B]$ sets for each block.\n- $\\text{Use}[B]$: Variables used in $B$ before being defined in $B$.\n- $\\text{Def}[B]$: Variables defined (assigned to) in $B$.\n\n- **Block $B_1$:**\n  - Uses: $a$ in instr $2$, $b$ in instr $3$, $c$ in instr $4$. All are defined within the block before use.\n  - $\\text{Use}[B_1] = \\emptyset$\n  - $\\text{Def}[B_1] = \\{a, b, c\\}$\n- **Block $B_2$:**\n  - Uses: $c$ in instr $5$, $b$ in instr $6$. These are not defined in $B_2$ before their use.\n  - $\\text{Use}[B_2] = \\{b, c\\}$\n  - $\\text{Def}[B_2] = \\{d, e, t, a\\}$\n- **Block $B_3$:**\n  - Uses: $a$ in instr $10$. This is not defined in $B_3$ before its use.\n  - $\\text{Use}[B_3] = \\{a\\}$\n  - $\\text{Def}[B_3] = \\{b, d, f, u\\}$\n- **Block $B_4$:**\n  - Uses: $a$ in instr $15$, $d$ in instr $16$. These are not defined in $B_4$ before their use. The use of $h$ in `return h` occurs after its definition.\n  - $\\text{Use}[B_4] = \\{a, d\\}$\n  - $\\text{Def}[B_4] = \\{g, h\\}$\n\nThe data-flow equations are:\n$$ \\text{Out}[B] = \\bigcup_{S \\in \\text{Successors}(B)} \\text{In}[S] $$\n$$ \\text{In}[B] = \\text{Use}[B] \\cup (\\text{Out}[B] - \\text{Def}[B]) $$\nWe initialize $\\text{In}[B] = \\emptyset$ for all $B$ and iterate until a fixed point is reached.\n\n**Iteration 0:**\n$$ \\text{In}[B_1] = \\emptyset, \\quad \\text{In}[B_2] = \\emptyset, \\quad \\text{In}[B_3] = \\emptyset, \\quad \\text{In}[B_4] = \\emptyset $$\n\n**Iteration 1 (processing in reverse topological order: $B_4, B_3, B_2, B_1$):**\n- **Block $B_4$:** $\\text{Successors}(B_4) = \\emptyset$, so $\\text{Out}[B_4] = \\emptyset$.\n  $$ \\text{In}[B_4] = \\text{Use}[B_4] \\cup (\\text{Out}[B_4] - \\text{Def}[B_4]) = \\{a, d\\} \\cup (\\emptyset - \\{g, h\\}) = \\{a, d\\} $$\n- **Block $B_3$:** $\\text{Successors}(B_3) = \\{B_4\\}$.\n  $$ \\text{Out}[B_3] = \\text{In}[B_4] = \\{a, d\\} $$\n  $$ \\text{In}[B_3] = \\text{Use}[B_3] \\cup (\\text{Out}[B_3] - \\text{Def}[B_3]) = \\{a\\} \\cup (\\{a, d\\} - \\{b, d, f, u\\}) = \\{a\\} \\cup \\{a\\} = \\{a\\} $$\n- **Block $B_2$:** $\\text{Successors}(B_2) = \\{B_4\\}$.\n  $$ \\text{Out}[B_2] = \\text{In}[B_4] = \\{a, d\\} $$\n  $$ \\text{In}[B_2] = \\text{Use}[B_2] \\cup (\\text{Out}[B_2] - \\text{Def}[B_2]) = \\{b, c\\} \\cup (\\{a, d\\} - \\{d, e, t, a\\}) = \\{b, c\\} \\cup \\emptyset = \\{b, c\\} $$\n- **Block $B_1$:** $\\text{Successors}(B_1) = \\{B_2, B_3\\}$.\n  $$ \\text{Out}[B_1] = \\text{In}[B_2] \\cup \\text{In}[B_3] = \\{b, c\\} \\cup \\{a\\} = \\{a, b, c\\} $$\n  $$ \\text{In}[B_1] = \\text{Use}[B_1] \\cup (\\text{Out}[B_1] - \\text{Def}[B_1]) = \\emptyset \\cup (\\{a, b, c\\} - \\{a, b, c\\}) = \\emptyset $$\n\n**Iteration 2:**\nWe recompute the sets. $\\text{In}[B_4]$ depends only on constant sets, so it is unchanged. This implies $\\text{Out}[B_2]$ and $\\text{Out}[B_3]$ are unchanged. Recomputing $\\text{In}[B_2]$ and $\\text{In}[B_3]$ yields the same results. This propagates to $\\text{Out}[B_1]$ and $\\text{In}[B_1]$. The system has reached a fixed point.\n\n**Final Liveness Sets:**\n- $\\text{In}[B_1] = \\emptyset$, $\\text{Out}[B_1] = \\{a, b, c\\}$\n- $\\text{In}[B_2] = \\{b, c\\}$, $\\text{Out}[B_2] = \\{a, d\\}$\n- $\\text{In}[B_3] = \\{a\\}$, $\\text{Out}[B_3] = \\{a, d\\}$\n- $\\text{In}[B_4] = \\{a, d\\}$, $\\text{Out}[B_4] = \\emptyset$\n\n### Step 3: Dead-Code Elimination\n\nWe now apply the specified algorithm to each basic block, scanning instructions in reverse order.\n\n**Block $B_4$:**\n- Initial live set: $L = \\text{Out}[B_4] = \\emptyset$.\n- `17: return h`: This is a use of $h$ and must be preserved. The live set before this instruction is $L = \\{h\\}$.\n- `16: h ← g + d`: The defined variable $h$ is in $L = \\{h\\}$. This instruction is **live**. Update $L = (L - \\{h\\}) \\cup \\{g, d\\} = \\{g, d\\}$.\n- `15: g ← a + 1`: The defined variable $g$ is in $L = \\{g, d\\}$. This instruction is **live**. Update $L = (L - \\{g\\}) \\cup \\{a\\} = \\{d, a\\}$.\n- Eliminated instructions in $B_4$: $0$.\n\n**Block $B_3$:**\n- Initial live set: $L = \\text{Out}[B_3] = \\{a, d\\}$.\n- `14: goto B_4`: Preserved control flow.\n- `13: u ← b - b`: The defined variable $u$ is not in $L = \\{a, d\\}$. This instruction is **dead**. It is eliminated. $L$ remains $\\{a, d\\}$.\n- `12: f ← b + d`: The defined variable $f$ is not in $L = \\{a, d\\}$. This instruction is **dead**. It is eliminated. $L$ remains $\\{a, d\\}$.\n- `11: b ← 7`: The defined variable $b$ is not in $L = \\{a, d\\}$. This instruction is **dead**. It is eliminated. $L$ remains $\\{a, d\\}$.\n- `10: d ← a + 5`: The defined variable $d$ is in $L = \\{a, d\\}$. This instruction is **live**. Update $L = (L - \\{d\\}) \\cup \\{a\\} = \\{a\\}$.\n- Eliminated instructions in $B_3$: $3$.\n\n**Block $B_2$:**\n- Initial live set: $L = \\text{Out}[B_2] = \\{a, d\\}$.\n- `9: goto B_4`: Preserved control flow.\n- `8: a ← e × 2`: The defined variable $a$ is in $L = \\{a, d\\}$. This instruction is **live**. Update $L = (L - \\{a\\}) \\cup \\{e\\} = \\{d, e\\}$.\n- `7: t ← d - d`: The defined variable $t$ is not in $L = \\{d, e\\}$. This instruction is **dead**. It is eliminated. $L$ remains $\\{d, e\\}$.\n- `6: e ← d + b`: The defined variable $e$ is in $L = \\{d, e\\}$. This instruction is **live**. Update $L = (L - \\{e\\}) \\cup \\{d, b\\} = \\{d, b\\}$.\n- `5: d ← c - 4`: The defined variable $d$ is in $L = \\{d, b\\}$. This instruction is **live**. Update $L = (L - \\{d\\}) \\cup \\{c\\} = \\{b, c\\}$.\n- Eliminated instructions in $B_2$: $1$.\n\n**Block $B_1$:**\n- Initial live set: $L = \\text{Out}[B_1] = \\{a, b, c\\}$.\n- `4: if c > 10 ...`: Preserved control flow. This is a use of $c$. The live set before this must contain $c$.\n- `3: c ← b × 3`: The defined variable $c$ is in $L = \\{a, b, c\\}$. This instruction is **live**. Update $L = (L - \\{c\\}) \\cup \\{b\\} = \\{a, b\\}$.\n- `2: b ← a + 2`: The defined variable $b$ is in $L = \\{a, b\\}$. This instruction is **live**. Update $L = (L - \\{b\\}) \\cup \\{a\\} = \\{a\\}$.\n- `1: a ← 1`: The defined variable $a$ is in $L = \\{a\\}$. This instruction is **live**. Update $L = (L - \\{a\\}) \\cup \\emptyset = \\emptyset$.\n- Eliminated instructions in $B_1$: $0$.\n\n**Total Eliminated Instructions:**\nThe total number of eliminated arithmetic assignment instructions is the sum of eliminations from each block:\nTotal = (eliminated in $B_1$) + (eliminated in $B_2$) + (eliminated in $B_3$) + (eliminated in $B_4$)\nTotal = $0 + 1 + 3 + 0 = 4$.\nThe eliminated instructions are:\n1. `t ← d - d` (in $B_2$)\n2. `u ← b - b` (in $B_3$)\n3. `f ← b + d` (in $B_3$)\n4. `b ← 7` (in $B_3$)",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "Compiler optimizations rarely work in isolation; their effectiveness often depends on their neighbors in the optimization pipeline. This problem  explores the crucial \"phase-ordering problem\" by examining the interaction between Dead-Code Elimination and Copy Propagation. You will see firsthand how running these passes in different orders can lead to different final code, revealing the synergistic nature of compiler transformations.",
            "id": "3636242",
            "problem": "Consider an Intermediate Representation (IR) program in simple three-address code with temporaries and explicit side-effecting operations. Intermediate Representation (IR) here refers to a low-level, language-neutral code used internally by compilers. The IR fragment is straight-line code with no control flow joins, and is given with line numbers as follows, where variables $t_1$, $t_2$, and $a$ denote temporaries and an input value, respectively, and $\\text{g}()$ and $\\text{print}(\\cdot)$ are observable operations:\n\n- Line $1$: $t_1 := a$\n- Line $2$: $t_2 := t_1$\n- Line $3$: $\\text{g}()$   (has side effects and may perform input or output)\n- Line $4$: $\\text{print}(t_2)$  (produces observable output)\n\nAssumptions:\n- The variable $a$ is not modified by any operation and has no aliases; there is no intervening redefinition of $a$ between its uses.\n- The call $\\text{g}()$ may read or write memory or perform input or output, so it is observable and must be treated as having side effects.\n- The operation $\\text{print}(t_2)$ is observable and has side effects.\n- Each pass described below runs exactly once; there is no iterative fixed-point scheduling.\n\nTwo IR optimization pass pipelines are considered:\n- Pipeline $\\mathcal{P}_1$: Copy Propagation followed by Dead-Code Elimination.\n- Pipeline $\\mathcal{P}_2$: Dead-Code Elimination followed by Copy Propagation.\n\nFoundational definitions to use:\n- Dead-Code Elimination (DCE) removes statements whose computed values do not reach any observable use and that themselves have no side effects. Formally, an assignment $x := e$ is removable if the variable $x$ is not live after the assignment and the evaluation of $e$ has no side effects.\n- Copy Propagation replaces uses of a variable $x$ with another variable $y$ when the reaching definition is a pure copy $x := y$ and $y$ is not modified along the path to the use. Copy Propagation does not itself delete statements; it performs substitutions on uses.\n\nQuestion: Under these definitions and assumptions, which of the following options correctly describes the final IR for each pipeline and the reason the outcomes differ?\n\nA. Pipeline $\\mathcal{P}_1$ rewrites line $2$ to $t_2 := a$ via Copy Propagation, making line $1$ dead; then Dead-Code Elimination removes line $1$. The final code has lines $2$–$4$, with line $2$ as $t_2 := a$. Pipeline $\\mathcal{P}_2$ runs Dead-Code Elimination first and retains line $1$ because $t_1$ is used at line $2$; then Copy Propagation rewrites line $2$ to $t_2 := a$, but line $1$ remains since no subsequent Dead-Code Elimination runs. Thus $\\mathcal{P}_1$ yields one fewer instruction than $\\mathcal{P}_2$.\n\nB. Both pipelines produce identical final code by removing line $1$ and retaining lines $2$–$4$, because Dead-Code Elimination can see through copies without assistance from Copy Propagation.\n\nC. Pipeline $\\mathcal{P}_2$ also removes line $1$ after its Copy Propagation step because Copy Propagation deletes any dead definitions it exposes, so both pipelines end with lines $2$–$4$.\n\nD. Dead-Code Elimination removes line $4$ because $t_2$ is not used after printing, so line $4$ is dead; therefore neither pipeline retains line $4$ in the final code.",
            "solution": "The user wants me to act as a meticulous STEM professor and solve a compiler optimization problem.\n\nI will begin by validating the problem statement as per the instructions.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides the following information:\n\n-   **Intermediate Representation (IR) Fragment:** A straight-line code block.\n    -   Line $1$: $t_1 := a$\n    -   Line $2$: $t_2 := t_1$\n    -   Line $3$: $\\text{g}()$\n    -   Line $4$: $\\text{print}(t_2)$\n-   **Variables and Operations:**\n    -   $t_1$, $t_2$: Temporaries.\n    -   $a$: Input value.\n    -   $\\text{g}()$: Observable operation with side effects (may perform input or output).\n    -   $\\text{print}(\\cdot)$: Observable operation with side effects (produces output).\n-   **Assumptions:**\n    -   The variable $a$ is not modified and has no aliases.\n    -   The call $\\text{g}()$ is observable and has side effects.\n    -   The operation $\\text{print}(t_2)$ is observable and has side effects.\n    -   Each optimization pass runs exactly once; there is no iterative fixed-point scheduling.\n-   **Optimization Pipelines:**\n    -   Pipeline $\\mathcal{P}_1$: Copy Propagation followed by Dead-Code Elimination.\n    -   Pipeline $\\mathcal{P}_2$: Dead-Code Elimination followed by Copy Propagation.\n-   **Foundational Definitions:**\n    -   **Dead-Code Elimination (DCE):** Removes a statement $x := e$ if the variable $x$ is not live after the assignment and the evaluation of expression $e$ has no side effects.\n    -   **Copy Propagation (CP):** Replaces uses of a variable $x$ with another variable $y$ when the reaching definition is a pure copy $x := y$ and $y$ is not modified. CP does not delete statements.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientifically Grounded:** The problem is firmly rooted in the principles of compiler design, a well-established discipline within computer science. The concepts of Intermediate Representation, three-address code, copy propagation, and dead-code elimination are standard. The definitions provided, while specific to the problem, are consistent with general compiler theory.\n-   **Well-Posed:** The problem is clearly structured. It provides an initial state (the IR code), a set of transformation rules (the optimization definitions), and two distinct sequences of transformations (the pipelines). The assumptions (e.g., single pass, no control flow joins) remove ambiguity and ensure a deterministic outcome for each pipeline. A unique solution can be derived by applying the given rules.\n-   **Objective:** The problem is stated in precise, formal language. The definitions are objective and do not rely on subjective interpretation.\n\n**Flaw Checklist:**\n1.  **Scientific or Factual Unsoundness:** None. The problem is consistent with established compiler theory.\n2.  **Non-Formalizable or Irrelevant:** None. The problem is a formal exercise in applying compiler optimization rules.\n3.  **Incomplete or Contradictory Setup:** None. The definitions and assumptions are sufficient and consistent. For instance, the constraint that CP does not delete statements is crucial and clearly stated.\n4.  **Unrealistic or Infeasible:** None. This is a simplified but realistic example of a phase-ordering problem in compilers.\n5.  **Ill-Posed or Poorly Structured:** None. The problem structure leads to a unique and derivable solution.\n6.  **Pseudo-Profound, Trivial, or Tautological:** None. The problem requires careful step-by-step reasoning and highlights the important concept that the order of optimization passes matters.\n7.  **Outside Scientific Verifiability:** None. The outcome is verifiable by direct application of the provided rules.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. I will proceed with the detailed derivation and analysis.\n\n### Derivation of Solution\n\nI will analyze the effect of each pipeline on the initial IR code.\n\n**Initial IR Code:**\n-   Line $1$: $t_1 := a$\n-   Line $2$: $t_2 := t_1$\n-   Line $3$: $\\text{g}()$\n-   Line $4$: $\\text{print}(t_2)$\n\n#### Analysis of Pipeline $\\mathcal{P}_1$: Copy Propagation followed by Dead-Code Elimination\n\n**Pass 1: Copy Propagation (CP)**\n\nThe CP pass analyzes the code for opportunities to replace variables with their values from copy statements.\n1.  The statement at Line $1$, $t_1 := a$, is a copy instruction.\n2.  The statement at Line $2$ uses $t_1$. The reaching definition for this use of $t_1$ is the copy at Line $1$. Since $a$ is not modified, the use of $t_1$ can be replaced with $a$.\n3.  As CP is a single pass, it transforms Line $2$ to $t_2 := a$. Note that according to the problem definition, CP does not remove Line $1$.\n4.  The pass proceeds. There are no other uses of variables defined by pure copies to propagate. For instance, while Line $2$ ($t_2 := t_1$) is a copy, a simple, single-pass implementation would not necessarily propagate $t_1$ to the use of $t_2$ in Line $4$ after having already transformed Line $2$. The most direct transformation is the one from Line $1$ to Line $2$.\n\nThe code after the CP pass is:\n-   Line $1$: $t_1 := a$\n-   Line $2$: $t_2 := a$ (Modified)\n-   Line $3$: $\\text{g}()$\n-   Line $4$: $\\text{print}(t_2)$\n\n**Pass 2: Dead-Code Elimination (DCE)**\n\nDCE is applied to the code resulting from the CP pass. We determine which statements are dead. A statement $x := e$ is dead if $x$ is not live after the statement and $e$ has no side effects.\n1.  **Liveness Analysis (backward scan):**\n    -   After Line $4$, no variables are live.\n    -   Before Line $4$ ($\\text{print}(t_2)$), the variable $t_2$ is used, so it is live. Live set: {$t_2$}.\n    -   Before Line $3$ ($\\text{g}()$), $t_2$ is still live as its value will be used at Line $4$. Live set: {$t_2$}.\n    -   Before Line $2$ ($t_2 := a$), the live-out set is {$t_2$}. The statement defines $t_2$ and uses $a$. The live-in set is $(\\text{live-out} - \\{t_2\\}) \\cup \\{a\\} = (\\{t_2\\} - \\{t_2\\}) \\cup \\{a\\} = \\{a\\}$.\n    -   Before Line $1$ ($t_1 := a$), the live-out set is the live-in set of Line $2$, which is {$a$}.\n2.  **Applying DCE Rule:**\n    -   Line $4$, $\\text{print}(t_2)$, has side effects and is observable. It is not dead.\n    -   Line $3$, $\\text{g}()$, has side effects and is observable. It is not dead.\n    -   Line $2$, $t_2 := a$: The variable $t_2$ is live after this statement (live-out is {$t_2$}). Therefore, this statement is **not** dead.\n    -   Line $1$, $t_1 := a$: Is $t_1$ live after this statement? The set of live variables after Line $1$ is {$a$}. $t_1$ is not in this set. The expression $a$ has no side effects. Therefore, the statement $t_1 := a$ is **dead**. It is removed.\n\n**Final Code for $\\mathcal{P}_1$:**\n-   Line $2$: $t_2 := a$\n-   Line $3$: $\\text{g}()$\n-   Line $4$: $\\text{print}(t_2)$\n\nThis pipeline results in a code block with $3$ instructions.\n\n#### Analysis of Pipeline $\\mathcal{P}_2$: Dead-Code Elimination followed by Copy Propagation\n\n**Pass 1: Dead-Code Elimination (DCE)**\n\nDCE is applied to the original IR code.\n1.  **Liveness Analysis (backward scan of original code):**\n    -   After Line $4$, no variables are live.\n    -   Before Line $4$ ($\\text{print}(t_2)$), $t_2$ is live. Live set: {$t_2$}.\n    -   Before Line $3$ ($\\text{g}()$), $t_2$ is live. Live set: {$t_2$}.\n    -   Before Line $2$ ($t_2 := t_1$), live-out is {$t_2$}. The statement defines $t_2$ and uses $t_1$. Live-in is $(\\{t_2\\} - \\{t_2\\}) \\cup \\{t_1\\} = \\{t_1\\}$.\n    -   Before Line $1$ ($t_1 := a$), live-out is {$t_1$}. The statement defines $t_1$ and uses $a$. Live-in is $(\\{t_1\\} - \\{t_1\\}) \\cup \\{a\\} = \\{a\\}$.\n2.  **Applying DCE Rule:**\n    -   Line $4$, $\\text{print}(t_2)$: Has side effects. Not dead.\n    -   Line $3$, $\\text{g}()$: Has side effects. Not dead.\n    -   Line $2$, $t_2 := t_1$: The variable $t_2$ is live after this assignment. Not dead.\n    -   Line $1$, $t_1 := a$: The variable $t_1$ is live after this assignment. Not dead.\n\nThe DCE pass removes no instructions. The code remains unchanged.\n\n**Pass 2: Copy Propagation (CP)**\n\nCP is applied to the code resulting from the DCE pass (which is the original code).\n1.  The statement at Line $1$, $t_1 := a$, is a copy.\n2.  The use of $t_1$ at Line $2$ is replaced by $a$. Line $2$ becomes $t_2 := a$.\n3.  The problem states that CP does not delete statements. Therefore, Line $1$ remains in the code.\n4.  There is no subsequent DCE pass to clean up the now-dead Line $1$.\n\n**Final Code for $\\mathcal{P}_2$:**\n-   Line $1$: $t_1 := a$\n-   Line $2$: $t_2 := a$ (Modified)\n-   Line $3$: $\\text{g}()$\n-   Line $4$: $\\text{print}(t_2)$\n\nThis pipeline results in a code block with $4$ instructions.\n\n### Option-by-Option Analysis\n\n**A. Pipeline $\\mathcal{P}_1$ rewrites line $2$ to $t_2 := a$ via Copy Propagation, making line $1$ dead; then Dead-Code Elimination removes line $1$. The final code has lines $2$–$4$, with line $2$ as $t_2 := a$. Pipeline $\\mathcal{P}_2$ runs Dead-Code Elimination first and retains line $1$ because $t_1$ is used at line $2$; then Copy Propagation rewrites line $2$ to $t_2 := a$, but line $1$ remains since no subsequent Dead-Code Elimination runs. Thus $\\mathcal{P}_1$ yields one fewer instruction than $\\mathcal{P}_2$.**\n-   The analysis for $\\mathcal{P}_1$ is completely consistent with my derivation. CP makes Line $1$ dead, and DCE removes it. The final code is exactly as described.\n-   The analysis for $\\mathcal{P}_2$ is also completely consistent with my derivation. DCE does nothing initially because $t_1$ is live. CP then runs, but there's no following DCE pass to remove the now-dead Line $1$.\n-   The conclusion that $\\mathcal{P}_1$ yields one fewer instruction ($3$) than $\\mathcal{P}_2$ ($4$) is correct.\n-   **Verdict: Correct.**\n\n**B. Both pipelines produce identical final code by removing line $1$ and retaining lines $2$–$4$, because Dead-Code Elimination can see through copies without assistance from Copy Propagation.**\n-   This is incorrect. As shown in the analysis of $\\mathcal{P}_2$, the initial DCE pass does not remove Line $1$ because $t_1$ is live due to its use in Line $2$. The DCE definition provided does not allow it to \"see through\" copies; it relies strictly on liveness, which is determined by direct usage. The pipelines produce different results.\n-   **Verdict: Incorrect.**\n\n**C. Pipeline $\\mathcal{P}_2$ also removes line $1$ after its Copy Propagation step because Copy Propagation deletes any dead definitions it exposes, so both pipelines end with lines $2$–$4$.**\n-   This is incorrect. It explicitly contradicts the problem's definition: \"Copy Propagation does not itself delete statements\". In pipeline $\\mathcal{P}_2$, after CP runs, the pipeline terminates. There is no subsequent pass to remove the definition at Line $1$, which has become dead.\n-   **Verdict: Incorrect.**\n\n**D. Dead-Code Elimination removes line $4$ because $t_2$ is not used after printing, so line $4$ is dead; therefore neither pipeline retains line $4$ in the final code.**\n-   This is incorrect. It misinterprets the definition of dead code. The definition requires two conditions: the result is not used AND the statement has no side effects. The problem explicitly states that $\\text{print}(t_2)$ \"is observable and has side effects\". Therefore, it can never be removed by the given DCE pass.\n-   **Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Dead-code elimination becomes far more complex when dealing with memory and pointers instead of simple scalar variables. This thought experiment  challenges you to think like a compiler, which must operate conservatively in the face of uncertainty. You will analyze how a compiler's ability to eliminate a dead store depends critically on its knowledge of pointer aliasing—the difference between knowing two pointers *might* point to the same location (`may-alias`) versus knowing they *must* (`must-alias`).",
            "id": "3636231",
            "problem": "Consider a single-threaded program in a strictly sequential memory model with no calls to external functions, no input or output effects, and no volatile memory. Let pointers $p$ and $q$ range over a non-escaping, non-aliased memory region except as specified by alias analysis facts. The following straight-line code executes within one basic block:\n1. $S_1$: $*p \\leftarrow 0$\n2. $S_2$: $*q \\leftarrow 1$\n3. $S_3$: $t \\leftarrow *p$\n4. return $t$\nAssume Dead Store Elimination (DSE) is defined from first principles as follows: a store to a memory location $L$ that writes a value $v$ is dead if, along all feasible execution paths and for all memory disambiguations consistent with the available static information, the value $v$ is never read before a subsequent store to the same location $L$ occurs or the program reaches an observation point that could make $v$ externally visible. The program is single-threaded and has no observation points other than reads from the memory region addressed by $p$ and $q$.\n\nDefine $L(p)$ to be the memory location addressed by $p$ on a given execution, and analogously $L(q)$. Consider two alias analysis results:\n- must-alias: $L(p) = L(q)$ on all executions through the block;\n- may-alias: there exist executions such that $L(p) = L(q)$ and executions such that $L(p) \\neq L(q)$.\n\nBased only on the above foundational definitions and facts (sequential load-store semantics and the definitions of must-alias and may-alias), which statement is correct about which stores are dead under each aliasing assumption for the given code?\n\nA. Under must-alias of $p$ and $q$, $S_1$ is dead and $S_2$ is not; under may-alias, neither $S_1$ nor $S_2$ is provably dead.\nB. Under must-alias of $p$ and $q$, $S_2$ is dead and $S_1$ is not; under may-alias, $S_1$ is dead.\nC. Under must-alias of $p$ and $q$, both $S_1$ and $S_2$ are dead; under may-alias, $S_2$ is dead.\nD. Under may-alias of $p$ and $q$, $S_2$ is not dead but $S_1$ is; under must-alias, neither $S_1$ nor $S_2$ is dead.",
            "solution": "The problem statement will first be validated for scientific soundness, clarity, and completeness.\n\n### Step 1: Extract Givens\nThe problem provides the following information:\n- **Program Model**: A single-threaded program in a strictly sequential memory model.\n- **Scope**: No calls to external functions, no input or output effects, and no volatile memory.\n- **Pointers**: $p$ and $q$ range over a non-escaping, non-aliased memory region, except where aliasing is specified.\n- **Code**: A single basic block with the following straight-line code:\n  1. $S_1$: $*p \\leftarrow 0$\n  2. $S_2$: $*q \\leftarrow 1$\n  3. $S_3$: $t \\leftarrow *p$\n  4. return $t$\n- **Definition of Dead Store Elimination (DSE)**: A store to a memory location $L$ that writes a value $v$ is dead if, along all feasible execution paths and for all memory disambiguations consistent with the available static information, the value $v$ is never read before a subsequent store to the same location $L$ occurs or the program reaches an observation point that could make $v$ externally visible.\n- **Observation Points**: The only observation points are reads from the memory region addressed by $p$ and $q$. The read $*p$ in statement $S_3$ is the only such point in this code fragment.\n- **Notation**: $L(p)$ is the memory location addressed by $p$, and $L(q)$ is the memory location addressed by $q$.\n- **Alias Analysis Results**:\n  - **must-alias**: $L(p) = L(q)$ on all executions through the block.\n  - **may-alias**: There exist executions such that $L(p) = L(q)$ and executions such that $L(p) \\neq L(q)$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is set within the formal domain of compiler theory, a subfield of computer science. The concepts of alias analysis, dead store elimination, memory models, and basic blocks are standard, well-defined topics. The definitions provided, while specific to the problem, are consistent with foundational principles. The problem is scientifically sound.\n2.  **Well-Posed**: The problem is well-posed. It provides all necessary definitions and a concrete code example. The question asks for a logical deduction based *only* on the provided information, which leads to a unique, derivable solution.\n3.  **Objective**: The problem uses precise, formal language common in computer science. Terms are defined explicitly (e.g., DSE, must-alias, may-alias), leaving no room for subjective interpretation.\n4.  **Flaw Checklist**: The problem does not violate any of the criteria for invalidity. It is a well-formed, self-contained problem in compiler analysis.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full derivation and solution will now be presented.\n\n### Derivation of the Correct Answer\n\nThe core task is to determine which of the stores, $S_1$ or $S_2$, are dead under the `must-alias` and `may-alias` assumptions. A store is dead if its value is guaranteed to be overwritten before it is read, across all execution possibilities allowed by the static analysis information.\n\n**Case 1: `must-alias` of $p$ and $q$**\n\nUnder the `must-alias` assumption, the compiler knows with certainty that $L(p) = L(q)$ for every execution. Let this single memory location be denoted $L_{common}$. The code sequence can be analyzed as follows:\n1.  $S_1$: $*L_{common} \\leftarrow 0$\n2.  $S_2$: $*L_{common} \\leftarrow 1$\n3.  $S_3$: $t \\leftarrow *L_{common}$\n\nLet's analyze each store:\n- **Analysis of $S_1$ (store of $0$):** The value $0$ is written to $L_{common}$. Immediately following this, statement $S_2$ writes the value $1$ to the *exact same location* $L_{common}$. This overwrite occurs before any read from $L_{common}$. The subsequent read at $S_3$ will retrieve the value $1$, not $0$. According to the definition, since the value from $S_1$ is never read before a subsequent store to the same location, the store at **$S_1$ is dead**.\n- **Analysis of $S_2$ (store of $1$):** The value $1$ is written to $L_{common}$. The next operation involving this location is the read at $S_3$, $t \\leftarrow *L_{common}$. This read retrieves the value $1$ stored by $S_2$. Since the value stored by $S_2$ is read, the store at **$S_2$ is not dead**.\n\n**Conclusion for `must-alias`:** $S_1$ is dead, and $S_2$ is not dead.\n\n**Case 2: `may-alias` of $p$ and $q$**\n\nUnder the `may-alias` assumption, the compiler must be conservative. The DSE definition requires the condition to hold \"for all memory disambiguations consistent with the available static information.\" This means a store can only be declared dead if it is dead in both possible scenarios:\n- Scenario (i): $L(p) = L(q)$ (the aliased case)\n- Scenario (ii): $L(p) \\neq L(q)$ (the non-aliased case)\n\nLet's analyze each store under this conservative requirement:\n- **Analysis of $S_1$ (store of $0$ to $L(p)$):**\n  - In Scenario (i) ($L(p) = L(q)$): As determined in the `must-alias` case, $S_1$ is dead because its value is overwritten by $S_2$.\n  - In Scenario (ii) ($L(p) \\neq L(q)$): The store at $S_2$ ($*q \\leftarrow 1$) writes to a different location than $L(p)$. Therefore, the value $0$ stored in $L(p)$ by $S_1$ is not overwritten. It is subsequently read by $S_3$ ($t \\leftarrow *p$). In this scenario, $S_1$ is not dead.\n  - **Conclusion for $S_1$:** Since $S_1$ is not dead in all possible disambiguations (it is live in Scenario (ii)), it cannot be proven to be dead by a conservative static analysis. Therefore, **$S_1$ is not provably dead**.\n\n- **Analysis of $S_2$ (store of $1$ to $L(q)$):**\n  - In Scenario (i) ($L(p) = L(q)$): As determined in the `must-alias` case, $S_2$ is not dead because its value is read by $S_3$.\n  - In Scenario (ii) ($L(p) \\neq L(q)$): The value $1$ is stored into $L(q)$. No subsequent instruction reads from $L(q)$; the only read is from $L(p)$. Therefore, the value stored by $S_2$ is never read. In this scenario, $S_2$ is dead.\n  - **Conclusion for $S_2$:** Since $S_2$ is not dead in all possible disambiguations (it is live in Scenario (i)), it cannot be proven to be dead by a conservative static analysis. Therefore, **$S_2$ is not provably dead**.\n\n**Conclusion for `may-alias`:** Neither $S_1$ nor $S_2$ is provably dead.\n\n**Summary of Conclusions:**\n- Under `must-alias`: $S_1$ is dead, $S_2$ is not dead.\n- Under `may-alias`: Neither $S_1$ nor $S_2$ is provably dead.\n\n### Option-by-Option Analysis\n\n- **A. Under must-alias of $p$ and $q$, $S_1$ is dead and $S_2$ is not; under may-alias, neither $S_1$ nor $S_2$ is provably dead.**\n  - This statement perfectly matches the results of our derivation for both the `must-alias` and `may-alias` cases.\n  - **Verdict:** Correct.\n\n- **B. Under must-alias of $p$ and $q$, $S_2$ is dead and $S_1$ is not; under may-alias, $S_1$ is dead.**\n  - The `must-alias` part is incorrect; it reverses the roles of $S_1$ and $S_2$.\n  - The `may-alias` part is incorrect; $S_1$ is not provably dead.\n  - **Verdict:** Incorrect.\n\n- **C. Under must-alias of $p$ and $q$, both $S_1$ and $S_2$ are dead; under may-alias, $S_2$ is dead.**\n  - The `must-alias` part is incorrect; $S_2$ is not dead.\n  - The `may-alias` part is incorrect; $S_2$ is not provably dead.\n  - **Verdict:** Incorrect.\n\n- **D. Under may-alias of $p$ and $q$, $S_2$ is not dead but $S_1$ is; under must-alias, neither $S_1$ nor $S_2$ is dead.**\n  - The `may-alias` part is incorrect; $S_1$ is not provably dead.\n  - The `must-alias` part is incorrect; $S_1$ is dead.\n  - **Verdict:** Incorrect.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}