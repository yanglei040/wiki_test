{
    "hands_on_practices": [
        {
            "introduction": "无用代码消除（Dead-Code Elimination, DCE）的核心在于精确判断哪些代码的计算结果从未被使用。活性分析（Liveness Analysis）是实现这一目标的基础技术，它能够确定在程序的每个点上哪些变量是“活”的（即其值未来可能被使用）。这个练习 () 将指导你动手实践，在一个给定的控制流图（CFG）上应用活性分析的数据流方程，从而系统性地识别并移除那些计算结果无用的算术指令。",
            "id": "3636224",
            "problem": "给定一个以控制流图（CFG）形式组织的、带有分支的直线型程序。所有算术赋值都是纯粹的（无副作用），唯一必须始终保留的控制操作是条件分支和最终的返回。该CFG有四个基本块 $B_1, B_2, B_3, B_4$，以及有向边 $B_1 \\to B_2$、$B_1 \\to B_3$、$B_2 \\to B_4$、$B_3 \\to B_4$。在每个块内，指令按程序顺序编号如下。\n\n基本块 $B_1$：\n- $1$: $a \\leftarrow 1$\n- $2$: $b \\leftarrow a + 2$\n- $3$: $c \\leftarrow b \\times 3$\n- $4$: 如果 $c > 10$ 跳转至 $B_2$ 否则跳转至 $B_3$\n\n基本块 $B_2$：\n- $5$: $d \\leftarrow c - 4$\n- $6$: $e \\leftarrow d + b$\n- $7$: $t \\leftarrow d - d$\n- $8$: $a \\leftarrow e \\times 2$\n- $9$: 跳转至 $B_4$\n\n基本块 $B_3$：\n- $10$: $d \\leftarrow a + 5$\n- $11$: $b \\leftarrow 7$\n- $12$: $f \\leftarrow b + d$\n- $13$: $u \\leftarrow b - b$\n- $14$: 跳转至 $B_4$\n\n基本块 $B_4$：\n- $15$: $g \\leftarrow a + 1$\n- $16$: $h \\leftarrow g + d$\n- $17$: 返回 $h$\n\n使用“一个变量在某个程序点是活跃的，当且仅当从该点出发的某条路径上，在该变量被重新定义之前有对它的使用”这一定义，对此CFG执行向后活跃变量分析，直至达到不动点，然后按如下方式执行算术赋值的死代码消除：在每个基本块 $B$ 中，按逆序扫描指令，维护一个初始等于该块之后活跃集合的活跃集；如果 $x$ 不在当前的活跃集中，则算术赋值 $x \\leftarrow \\text{expr}$ 是死的，在这种情况下，可以移除该赋值，并且其使用的变量不会被添加到活跃集中。如果指令不是死的，则通过移除定义的变量并添加其使用的变量来更新活跃集。\n\n在所有块中完成此过程后，总共消除了多少条算术赋值指令？以单个整数形式提供最终答案。无需四舍五入，也无需单位。",
            "solution": "问题要求我们对给定的控制流图（CFG）进行活跃变量分析，然后利用分析结果进行死代码消除。最终答案是消除的算术赋值指令的总数。\n\n### 步骤1：问题验证\n\n**1.1. 提取给定信息：**\n- **CFG结构：** 四个基本块 $B_1, B_2, B_3, B_4$。\n- **边：** $B_1 \\to B_2$, $B_1 \\to B_3$, $B_2 \\to B_4$, $B_3 \\to B_4$。\n- **基本块 $B_1$ 的指令：**\n  - $1$: $a \\leftarrow 1$\n  - $2$: $b \\leftarrow a + 2$\n  - $3$: $c \\leftarrow b \\times 3$\n  - $4$: 如果 $c > 10$ 跳转至 $B_2$ 否则跳转至 $B_3$\n- **基本块 $B_2$ 的指令：**\n  - $5$: $d \\leftarrow c - 4$\n  - $6$: $e \\leftarrow d + b$\n  - $7$: $t \\leftarrow d - d$\n  - $8$: $a \\leftarrow e \\times 2$\n  - $9$: 跳转至 $B_4$\n- **基本块 $B_3$ 的指令：**\n  - $10$: $d \\leftarrow a + 5$\n  - $11$: $b \\leftarrow 7$\n  - $12$: $f \\leftarrow b + d$\n  - $13$: $u \\leftarrow b - b$\n  - $14$: 跳转至 $B_4$\n- **基本块 $B_4$ 的指令：**\n  - $15$: $g \\leftarrow a + 1$\n  - $16$: $h \\leftarrow g + d$\n  - $17$: 返回 $h$\n- **活跃性定义：** 一个变量在某个程序点是活跃的，如果存在一条从该点开始的路径，在该路径上变量在被重新定义之前被使用。\n- **死代码消除算法：** 对于每个块 $B$，逆序扫描指令。如果 $x$ 不在当前活跃集中，则赋值 $x \\leftarrow \\text{expr}$ 是死的。如果指令是死的，则移除它，并且不将其使用的变量添加到活跃集中。如果指令是活跃的，则通过移除 $x$ 并添加在 $\\text{expr}$ 中使用的变量来更新活跃集。\n\n**1.2. 使用提取的信息进行验证：**\n这是一个编译器优化理论中的标准练习题。它是自包含的，提供了所有必要的数据和算法。CFG、指令和流程都定义明确。该问题具有科学依据、客观且定义良好。没有矛盾、歧义或事实错误。因此，该问题是有效的。\n\n### 步骤2：活跃变量分析\n\n我们执行向后数据流分析，以找出每个基本块 $B$ 入口处（$\\text{In}[B]$）和出口处（$\\text{Out}[B]$）的活跃变量集。\n\n首先，我们确定每个块的 $\\text{Use}[B]$ 和 $\\text{Def}[B]$ 集合。\n- $\\text{Use}[B]$：在块 $B$ 中，先于定义被使用的变量。\n- $\\text{Def}[B]$：在块 $B$ 中被定义（赋值）的变量。\n\n- **基本块 $B_1$：**\n  - 用到的变量：指令2中的 $a$，指令3中的 $b$，指令4中的 $c$。所有这些变量都在块内使用前被定义。\n  - $\\text{Use}[B_1] = \\emptyset$\n  - $\\text{Def}[B_1] = \\{a, b, c\\}$\n- **基本块 $B_2$：**\n  - 用到的变量：指令5中的 $c$，指令6中的 $b$。这些变量在 $B_2$ 中使用前未被定义。\n  - $\\text{Use}[B_2] = \\{b, c\\}$\n  - $\\text{Def}[B_2] = \\{d, e, t, a\\}$\n- **基本块 $B_3$：**\n  - 用到的变量：指令10中的 $a$。此变量在 $B_3$ 中使用前未被定义。\n  - $\\text{Use}[B_3] = \\{a\\}$\n  - $\\text{Def}[B_3] = \\{b, d, f, u\\}$\n- **基本块 $B_4$：**\n  - 用到的变量：指令15中的 $a$，指令16中的 $d$。这些变量在 $B_4$ 中使用前未被定义。在 `return h` 中对 $h$ 的使用发生在其定义之后。\n  - $\\text{Use}[B_4] = \\{a, d\\}$\n  - $\\text{Def}[B_4] = \\{g, h\\}$\n\n数据流方程为：\n$$ \\text{Out}[B] = \\bigcup_{S \\in \\text{Successors}(B)} \\text{In}[S] $$\n$$ \\text{In}[B] = \\text{Use}[B] \\cup (\\text{Out}[B] - \\text{Def}[B]) $$\n我们将所有 $B$ 的 $\\text{In}[B]$ 初始化为 $\\emptyset$，然后迭代直到达到不动点。\n\n**迭代 0：**\n$$ \\text{In}[B_1] = \\emptyset, \\quad \\text{In}[B_2] = \\emptyset, \\quad \\text{In}[B_3] = \\emptyset, \\quad \\text{In}[B_4] = \\emptyset $$\n\n**迭代 1（按逆拓扑顺序处理：$B_4, B_3, B_2, B_1$）：**\n- **基本块 $B_4$：** $\\text{Successors}(B_4) = \\emptyset$，所以 $\\text{Out}[B_4] = \\emptyset$。\n  $$ \\text{In}[B_4] = \\text{Use}[B_4] \\cup (\\text{Out}[B_4] - \\text{Def}[B_4]) = \\{a, d\\} \\cup (\\emptyset - \\{g, h\\}) = \\{a, d\\} $$\n- **基本块 $B_3$：** $\\text{Successors}(B_3) = \\{B_4\\}$。\n  $$ \\text{Out}[B_3] = \\text{In}[B_4] = \\{a, d\\} $$\n  $$ \\text{In}[B_3] = \\text{Use}[B_3] \\cup (\\text{Out}[B_3] - \\text{Def}[B_3]) = \\{a\\} \\cup (\\{a, d\\} - \\{b, d, f, u\\}) = \\{a\\} \\cup \\{a\\} = \\{a\\} $$\n- **基本块 $B_2$：** $\\text{Successors}(B_2) = \\{B_4\\}$。\n  $$ \\text{Out}[B_2] = \\text{In}[B_4] = \\{a, d\\} $$\n  $$ \\text{In}[B_2] = \\text{Use}[B_2] \\cup (\\text{Out}[B_2] - \\text{Def}[B_2]) = \\{b, c\\} \\cup (\\{a, d\\} - \\{d, e, t, a\\}) = \\{b, c\\} \\cup \\emptyset = \\{b, c\\} $$\n- **基本块 $B_1$：** $\\text{Successors}(B_1) = \\{B_2, B_3\\}$。\n  $$ \\text{Out}[B_1] = \\text{In}[B_2] \\cup \\text{In}[B_3] = \\{b, c\\} \\cup \\{a\\} = \\{a, b, c\\} $$\n  $$ \\text{In}[B_1] = \\text{Use}[B_1] \\cup (\\text{Out}[B_1] - \\text{Def}[B_1]) = \\emptyset \\cup (\\{a, b, c\\} - \\{a, b, c\\}) = \\emptyset $$\n\n**迭代 2：**\n我们重新计算集合。$\\text{In}[B_4]$ 仅依赖于常量集，因此它保持不变。这意味着 $\\text{Out}[B_2]$ 和 $\\text{Out}[B_3]$ 也保持不变。重新计算 $\\text{In}[B_2]$ 和 $\\text{In}[B_3]$ 会得到相同的结果。这会传播到 $\\text{Out}[B_1]$ 和 $\\text{In}[B_1]$。系统已达到不动点。\n\n**最终的活跃集合：**\n- $\\text{In}[B_1] = \\emptyset$, $\\text{Out}[B_1] = \\{a, b, c\\}$\n- $\\text{In}[B_2] = \\{b, c\\}$, $\\text{Out}[B_2] = \\{a, d\\}$\n- $\\text{In}[B_3] = \\{a\\}$, $\\text{Out}[B_3] = \\{a, d\\}$\n- $\\text{In}[B_4] = \\{a, d\\}$, $\\text{Out}[B_4] = \\emptyset$\n\n### 步骤3：死代码消除\n\n现在我们将指定的算法应用于每个基本块，按逆序扫描指令。\n\n**基本块 $B_4$：**\n- 初始活跃集：$L = \\text{Out}[B_4] = \\emptyset$。\n- `17: return h`: 这是对 $h$ 的一次使用，必须保留。此指令前的活跃集是 $L = \\{h\\}$。\n- `16: h ← g + d`: 定义的变量 $h$ 在 $L = \\{h\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{h\\}) \\cup \\{g, d\\} = \\{g, d\\}$。\n- `15: g ← a + 1`: 定义的变量 $g$ 在 $L = \\{g, d\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{g\\}) \\cup \\{a\\} = \\{d, a\\}$。\n- $B_4$ 中消除的指令数：$0$。\n\n**基本块 $B_3$：**\n- 初始活跃集：$L = \\text{Out}[B_3] = \\{a, d\\}$。\n- `14: goto B_4`: 保留的控制流。\n- `13: u ← b - b`: 定义的变量 $u$ 不在 $L = \\{a, d\\}$ 中。该指令是**死的**。它被消除了。$L$ 保持为 $\\{a, d\\}$。\n- `12: f ← b + d`: 定义的变量 $f$ 不在 $L = \\{a, d\\}$ 中。该指令是**死的**。它被消除了。$L$ 保持为 $\\{a, d\\}$。\n- `11: b ← 7`: 定义的变量 $b$ 不在 $L = \\{a, d\\}$ 中。该指令是**死的**。它被消除了。$L$ 保持为 $\\{a, d\\}$。\n- `10: d ← a + 5`: 定义的变量 $d$ 在 $L = \\{a, d\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{d\\}) \\cup \\{a\\} = \\{a\\}$。\n- $B_3$ 中消除的指令数：$3$。\n\n**基本块 $B_2$：**\n- 初始活跃集：$L = \\text{Out}[B_2] = \\{a, d\\}$。\n- `9: goto B_4`: 保留的控制流。\n- `8: a ← e × 2`: 定义的变量 $a$ 在 $L = \\{a, d\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{a\\}) \\cup \\{e\\} = \\{d, e\\}$。\n- `7: t ← d - d`: 定义的变量 $t$ 不在 $L = \\{d, e\\}$ 中。该指令是**死的**。它被消除了。$L$ 保持为 $\\{d, e\\}$。\n- `6: e ← d + b`: 定义的变量 $e$ 在 $L = \\{d, e\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{e\\}) \\cup \\{d, b\\} = \\{d, b\\}$。\n- `5: d ← c - 4`: 定义的变量 $d$ 在 $L = \\{d, b\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{d\\}) \\cup \\{c\\} = \\{b, c\\}$。\n- $B_2$ 中消除的指令数：$1$。\n\n**基本块 $B_1$：**\n- 初始活跃集：$L = \\text{Out}[B_1] = \\{a, b, c\\}$。\n- `4: if c > 10 ...`: 保留的控制流。这是对 $c$ 的一次使用。此指令前的活跃集必须包含 $c$。\n- `3: c ← b × 3`: 定义的变量 $c$ 在 $L = \\{a, b, c\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{c\\}) \\cup \\{b\\} = \\{a, b\\}$。\n- `2: b ← a + 2`: 定义的变量 $b$ 在 $L = \\{a, b\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{b\\}) \\cup \\{a\\} = \\{a\\}$。\n- `1: a ← 1`: 定义的变量 $a$ 在 $L = \\{a\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{a\\}) \\cup \\emptyset = \\emptyset$。\n- $B_1$ 中消除的指令数：$0$。\n\n**消除的指令总数：**\n消除的算术赋值指令总数是每个块中消除数量的总和：\n总数 = ($B_1$ 中消除的数量) + ($B_2$ 中消除的数量) + ($B_3$ 中消除的数量) + ($B_4$ 中消除的数量)\n总数 = $0 + 1 + 3 + 0 = 4$。\n被消除的指令是：\n1. `t ← d - d` (在 $B_2$ 中)\n2. `u ← b - b` (在 $B_3$ 中)\n3. `f ← b + d` (在 $B_3$ 中)\n4. `b ← 7` (在 $B_3$ 中)",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "掌握了基础算法后，理解其局限性同样重要，尤其是在处理具有副作用（side effects）的代码时。编译器优化必须严格保持程序的原始语义，这意味着任何可观测的行为都不能被改变。这个练习 () 挑战你对“可观测行为”的理解，特别是当一个函数调用可能抛出异常时，即使其返回值未被使用，该调用本身也可能因为潜在的控制流改变而不能被安全地移除。",
            "id": "3636191",
            "problem": "考虑一个一阶、基于语句的中间表示 (IR)，它具有以下明确定义的操作语义和可观察性模型。顺序执行是从左到右的，写作 $s_1; s_2$。一个函数调用 $h()$ 要么正常返回并产生一个值，要么抛出一个异常 $E$。在 $s_1; s_2$ 中，如果 $s_1$ 正常终止，则 $s_2$ 执行；如果 $s_1$ 抛出异常 $E$，控制权会立即转移到最近的封闭处理程序；在没有处理程序的情况下，程序会因一个可观察的异常而中止。该语言有赋值语句 $x := e$，其中 $x$ 是一个变量， $e$ 是一个表达式；赋一个返回的值除了绑定 $x$ 之外没有其他可观察效果，并且除非另有说明，变量可以被视为局部变量。如果一个函数的求值过程不改变内存、不执行输入/输出或不改变全局状态，则称该函数是无副作用的；抛出异常 $E$ 被视为一个可观察的控制转移事件。如果两个程序在所有上下文中都产生相同的外部可见行为序列（输入/输出轨迹）和相同的终止模式（正常返回或特定异常 $E$），那么它们是可观察等价的。\n\n给定代码片段 $x := f();\\ g();$，假设：\n- $f$ 是无副作用的，但在被调用时可能抛出异常 $E_f$。\n- $g$ 可能产生副作用（例如，输入/输出），但不会抛出异常。\n- 变量 $x$ 在该片段之后是死变量，即赋给 $x$ 的值后续不会被使用。\n\n死代码消除旨在移除在上述语义下不影响可观察行为的代码。\n\n在给定的假设下，以下哪些声明或转换是语义保持的？\n\n- A. 无条件地将 $x := f();\\ g();$ 替换为 $g();$，因为 $f$ 没有副作用。\n\n- B. 消除整个语句 $x := f()$ 不是语义保持的，除非静态分析证明 $f$ 在任何到达此点的执行路径上都不会抛出异常。\n\n- C. 消除 $x := f()$ 是安全的，条件是 $g$ 没有副作用且不抛出异常。\n\n- D. 将 $x := f();\\ g();$ 重写为 $f();\\ g();$（即，仅丢弃对 $x$ 的死存储），而不移除对 $f$ 的调用。\n\n- E. 重排序为 $g();\\ x := f();$，然后消除 $x := f();$（得到 $g();$），因为 $f$ 没有副作用。\n\n选择所有适用的选项。",
            "solution": "首先验证问题陈述，以确保其自洽、一致且有科学依据。\n\n### 步骤 1：提取已知条件\n- **语言语义**：该中间表示 (IR) 是一阶且基于语句的。\n- **顺序执行**：对于序列 $s_1; s_2$，如果 $s_1$ 正常终止，则 $s_2$ 执行。如果 $s_1$ 抛出异常 $E$，控制权立即转移， $s_2$ 不会执行。\n- **异常**：函数调用 $h()$ 可以正常返回或抛出异常 $E$。抛出异常是一个可观察的控制转移事件。一个未捕获的异常会导致程序中止，这是可观察的。\n- **可观察等价性**：如果两个程序在所有上下文中都产生相同的外部可见行为序列（例如，输入/输出）并具有相同的终止模式（正常返回或特定异常 $E$），则它们是等价的。\n- **无副作用**：如果一个函数的求值不改变内存、不执行输入/输出或不改变全局状态，则该函数是无副作用的。\n- **赋值**：语句 $x := e$ 将表达式 $e$ 的值绑定到变量 $x$。赋值本身除了此绑定之外没有可观察的效果。\n- **代码片段**：被分析的片段是 $x := f();\\ g();$。\n- **函数 `f`**：函数 $f()$ 是无副作用的，但它可能抛出异常 $E_f$。\n- **函数 `g`**：函数 $g()$ 可能有副作用（例如，输入/输出），但保证不会抛出异常。\n- **变量 `x`**：变量 $x$ 在赋值后是死变量，意味着它的值再也不会被使用。\n- **目标**：识别哪些关于死代码消除的转换或声明是语义保持的。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在编译器理论和形式语义学领域内定义良好。可观察等价性、副作用和异常的定义清晰、标准且不相互矛盾。关于函数 $f()$ 和 $g()$ 的假设是具体的，并允许进行严谨的分析。该问题基于程序设计语言语义学的原理，具有科学依据。这是一个适定的问题，因为可以根据提供的规则对每个选项进行明确的分析。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将推导解决方案。\n\n### 推导与选项分析\n\n首先必须确定原始片段 $x := f();\\ g();$ 的可观察行为。根据 $f()$ 的行为，该片段有两种可能的执行路径：\n\n1.  **情况 1：$f()$ 抛出异常 $E_f$。** 根据顺序执行语义，控制权立即转移出该片段。语句 $g();$ 不会执行。可观察的结果是程序因异常 $E_f$ 而终止或转移控制权。\n2.  **情况 2：$f()$ 正常返回。** 返回值被赋给 $x$。由于 $x$ 是一个死变量，这个赋值没有后续的可观察效果。执行继续到 $g();$。可观察的结果包括由 $g()$ 产生的副作用。\n\n因此，原始片段的可能可观察行为集合是 {可观察事件 $E_f$} $\\cup$ {$g()$ 的副作用}。一个语义保持的转换必须产生一个具有完全相同的可能可观察行为集合的程序。\n\n现在，我们评估每个选项。\n\n**A. 无条件地将 $x := f();\\ g();$ 替换为 $g();$，因为 $f$ 没有副作用。**\n\n转换后的片段是 $g();$。此片段的可观察行为完全由 $g()$ 的执行决定。由于 $g()$ 不抛出异常，它将总是运行到完成，并且其副作用将被观察到。抛出异常 $E_f$ 的可能性被消除了。\n\n- **原始行为**：{事件 $E_f$} 或 {$g()$ 的副作用}。\n- **转换后行为**：{$g()$ 的副作用}。\n\n可能的行为集合没有被保持。该转换移除了一个潜在的可观察事件 ($E_f$)，因此它不是语义保持的。所提供的理由，“因为 $f$ 没有副作用”，是有缺陷的，因为它忽略了潜在异常的关键的、可观察的控制流效果，而异常被明确定义为一个可观察事件。\n\n对 A 的结论：**不正确**。\n\n**B. 消除整个语句 $x := f()$ 不是语义保持的，除非静态分析证明 $f$ 在任何到达此点的执行路径上都不会抛出异常。**\n\n这是一个关于有效转换条件的声明。“消除整个语句 $x := f()$” 意味着将 $x := f();\\ g();$ 转换为 $g();$，这正是选项 A 中的转换。正如对选项 A 的分析，这个转换是无效的，正因为它消除了潜在的可观察事件 $E_f$。该声明指出，只有在能够证明 $f()$ 不会抛出异常的情况下，这种消除才是语义保持的。我们来分析这个条件。如果静态分析证明 $f()$ 不会抛出异常，那么情况 1（$f()$ 抛出 $E_f$）就不可能发生。原始片段唯一可能的行为是情况 2：$f()$ 返回，值存储在死变量 $x$ 中，然后 $g()$ 执行。唯一可观察的效果是 $g()$ 的效果。在这种情况下，转换后的片段 $g();$ 具有完全相同的可观察行为。因此，该声明是正确的：只有排除了其可观察异常的可能性，消除对 $f()$ 的调用才是安全的。\n\n对 B 的结论：**正确**。\n\n**C. 消除 $x := f()$ 是安全的，条件是 $g$ 没有副作用且不抛出异常。**\n\n这个选项提出，$g()$ 的属性可以使消除 $x := f()$ 变得安全。提议的转换仍然是 $x := f();\\ g(); \\rightarrow g();$。我们假设条件成立：$g()$ 没有副作用且不抛出异常。\n- **原始行为**：{事件 $E_f$} 或 {没有可观察行为，因为 $g()$ 没有副作用}。\n- **转换后行为**（对于 $g();$）：{没有可观察行为}。\n转换后的程序永远不能产生可观察事件 $E_f$，而原始程序可以。这改变了语义。$g()$ 的属性与 $f()$ 的可观察行为无关。\n\n对 C 的结论：**不正确**。\n\n**D. 将 $x := f();\\ g();$ 重写为 $f();\\ g();$（即，仅丢弃对 $x$ 的死存储），而不移除对 $f$ 的调用。**\n\n转换后的片段是 $f();\\ g();$。我们来分析其行为。\n1.  **情况 1：$f()$ 抛出异常 $E_f$。** 控制权立即转移。$g();$ 不会执行。可观察的结果是事件 $E_f$。\n2.  **情况 2：$f()$ 正常返回。** 返回值被丢弃。执行继续到 $g();$。可观察的结果是 $g()$ 的副作用。\n可能的可观察行为集合是 {可观察事件 $E_f$} $\\cup$ {$g()$ 的副作用}。这与原始片段 $x := f();\\ g();$ 的行为集合完全相同。唯一的区别是赋值给变量 $x$，而 $x$ 是死变量。问题陈述指明“赋一个返回的值除了绑定 $x$ 之外没有其他可观察效果。” 由于 $x$ 从未被使用，这个绑定没有任何后果。因此，仅移除赋值是一个语义保持的转换。这是死存储消除的一个经典例子。\n\n对 D 的结论：**正确**。\n\n**E. 重排序为 $g();\\ x := f();$，然后消除 $x := f();$（得到 $g();$），因为 $f$ 没有副作用。**\n\n这是一个多步转换。我们来分析第一步：将 $x := f();\\ g();$ 重排序为 $g();\\ x := f();$。要成为一个有效的重排序，可观察行为必须被保持。\n- **原始顺序，$f()$ 抛出异常**：对 $f()$ 的调用首先发生。它抛出 $E_f$。$g()$ 从不执行。可观察行为：{事件 $E_f$}。\n- **重排序后，$f()$ 抛出异常**：对 $g()$ 的调用首先发生。其副作用被产生。然后，调用 $f()$ 并抛出 $E_f$。可观察行为：{$g()$ 的副作用，然后是事件 $E_f$}。\n可观察事件的序列是不同的。在原始程序中，如果 $f()$ 抛出异常，$g()$ 的副作用不会发生。在重排序后的程序中，它们会发生。这违反了可观察等价性。因此，重排序步骤是无效的。由于提议的转换的第一步是无效的，整个转换也是无效的。\n\n对 E 的结论：**不正确**。",
            "answer": "$$\\boxed{BD}$$"
        },
        {
            "introduction": "在真实的编译器中，优化不是孤立进行的，而是由一系列相互作用的优化遍（pass）组成。一个优化的效果往往会受到其前后其他优化的影响，这就是所谓的“遍序问题”（phase-ordering problem）。本练习 () 聚焦于无用代码消除与复制传播（Copy Propagation）之间的协同作用，通过对比两种不同的优化顺序，你将清楚地看到，一个精心设计的顺序如何能创造出更多的优化机会，从而产生更高效的代码。",
            "id": "3636242",
            "problem": "考虑一个简单的三地址码中间表示（IR）程序，其中包含临时变量和显式的副作用操作。此处的中间表示（IR）指编译器内部使用的一种低级的、与语言无关的代码。该IR片段是直线代码，没有控制流汇合点，并按行号给出如下，其中变量 $t_1$、$t_2$ 和 $a$ 分别表示临时变量和一个输入值，而 $\\text{g}()$ 和 $\\text{print}(\\cdot)$ 是可观察的操作：\n\n- 第 $1$ 行：$t_1 := a$\n- 第 $2$ 行：$t_2 := t_1$\n- 第 $3$ 行：$\\text{g}()$   （具有副作用，可能执行输入或输出）\n- 第 $4$ 行：$\\text{print}(t_2)$  （产生可观察的输出）\n\n假设：\n- 变量 $a$ 不被任何操作修改，也没有别名；在其使用之间没有对 $a$ 的中间重定义。\n- 调用 $\\text{g}()$ 可能会读或写内存，或执行输入或输出，因此它是可观察的，必须被视为具有副作用。\n- 操作 $\\text{print}(t_2)$ 是可观察的，并具有副作用。\n- 下述的每个优化遍仅运行一次；不存在迭代的不动点调度。\n\n考虑两个IR优化遍管道：\n- 管道 $\\mathcal{P}_1$：副本传播，然后是死代码消除。\n- 管道 $\\mathcal{P}_2$：死代码消除，然后是副本传播。\n\n使用的基本定义：\n- 死代码消除（DCE）移除那些其计算值未到达任何可观察用途且其本身没有副作用的语句。形式上，如果变量 $x$ 在赋值后不是活跃的，并且表达式 $e$ 的求值没有副作用，则赋值语句 $x := e$ 是可移除的。\n- 副本传播在到达定值是纯副本 $x := y$ 且 $y$ 在到达该使用的路径上未被修改的情况下，将变量 $x$ 的使用替换为另一个变量 $y$。副本传播本身不删除语句；它对使用进行替换。\n\n问题：根据这些定义和假设，以下哪个选项正确描述了每个管道的最终IR以及结果不同的原因？\n\nA. 管道 $\\mathcal{P}_1$ 通过副本传播将第 $2$ 行重写为 $t_2 := a$，这使得第 $1$ 行成为死代码；然后死代码消除移除第 $1$ 行。最终代码包含第 $2$–$4$ 行，其中第 $2$ 行为 $t_2 := a$。管道 $\\mathcal{P}_2$ 首先运行死代码消除，并保留第 $1$ 行，因为 $t_1$ 在第 $2$ 行被使用；然后副本传播将第 $2$ 行重写为 $t_2 := a$，但第 $1$ 行仍然存在，因为没有后续的死代码消除遍运行。因此 $\\mathcal{P}_1$ 比 $\\mathcal{P}_2$ 少产生一条指令。\n\nB. 两个管道都通过移除第 $1$ 行并保留第 $2$–$4$ 行来产生相同的最终代码，因为死代码消除无需副本传播的辅助就能看透副本。\n\nC. 管道 $\\mathcal{P}_2$ 在其副本传播步骤之后也移除了第 $1$ 行，因为副本传播会删除它所暴露的任何死定义，所以两个管道最终都只剩下第 $2$–$4$ 行。\n\nD. 死代码消除移除了第 $4$ 行，因为 $t_2$ 在打印后未被使用，所以第 $4$ 行是死代码；因此两个管道的最终代码中都不会保留第 $4$ 行。",
            "solution": "用户希望我扮演一位严谨的STEM教授，解决一个编译器优化问题。\n\n我将按照指示开始验证问题陈述。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n问题提供了以下信息：\n\n-   **中间表示（IR）片段：** 一个直线代码块。\n    -   第 $1$ 行：$t_1 := a$\n    -   第 $2$ 行：$t_2 := t_1$\n    -   第 $3$ 行：$\\text{g}()$\n    -   第 $4$ 行：$\\text{print}(t_2)$\n-   **变量和操作：**\n    -   $t_1$, $t_2$：临时变量。\n    -   $a$：输入值。\n    -   $\\text{g}()$：具有副作用的可观察操作（可能执行输入或输出）。\n    -   $\\text{print}(\\cdot)$：具有副作用的可观察操作（产生输出）。\n-   **假设：**\n    -   变量 $a$ 未被修改且没有别名。\n    -   调用 $\\text{g}()$ 是可观察的且具有副作用。\n    -   操作 $\\text{print}(t_2)$ 是可观察的且具有副作用。\n    -   每个优化遍只运行一次；没有迭代的不动点调度。\n-   **优化管道：**\n    -   管道 $\\mathcal{P}_1$：副本传播，然后是死代码消除。\n    -   管道 $\\mathcal{P}_2$：死代码消除，然后是副本传播。\n-   **基本定义：**\n    -   **死代码消除（DCE）：** 如果变量 $x$ 在赋值后不是活跃的，并且表达式 $e$ 的求值没有副作用，则移除语句 $x := e$。\n    -   **副本传播（CP）：** 当到达定值是纯副本 $x := y$ 且 $y$ 未被修改时，将变量 $x$ 的使用替换为另一个变量 $y$。CP不删除语句。\n\n**步骤2：使用提取的已知条件进行验证**\n\n-   **科学基础：** 该问题牢固地植根于编译器设计的原理，这是计算机科学中一个成熟的学科。中间表示、三地址码、副本传播和死代码消除等概念都是标准内容。所提供的定义虽然特定于本问题，但与通用编译器理论一致。\n-   **良构性：** 问题结构清晰。它提供了一个初始状态（IR代码）、一组转换规则（优化定义）和两个不同的转换序列（管道）。假设（例如，单遍、无控制流汇合点）消除了歧义，并确保每个管道都有确定的结果。通过应用给定的规则可以推导出唯一的解决方案。\n-   **客观性：** 问题以精确、形式化的语言陈述。定义是客观的，不依赖于主观解释。\n\n**缺陷检查清单：**\n1.  **科学或事实不健全：** 无。问题与已建立的编译器理论一致。\n2.  **不可形式化或不相关：** 无。问题是应用编译器优化规则的形式化练习。\n3.  **不完整或矛盾的设置：** 无。定义和假设是充分且一致的。例如，CP不删除语句的约束是至关重要且明确说明的。\n4.  **不切实际或不可行：** 无。这是一个简化但现实的编译器中阶段排序问题的例子。\n5.  **病态或结构不良：** 无。问题结构导致一个唯一且可推导的解决方案。\n6.  **伪深刻、琐碎或同义反复：** 无。问题需要仔细的逐步推理，并突出了优化遍顺序重要性这一重要概念。\n7.  **超出科学可验证性：** 无。结果可通过直接应用所提供的规则来验证。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。我将进行详细的推导和分析。\n\n### 解决方案推导\n\n我将分析每个管道对初始IR代码的影响。\n\n**初始IR代码：**\n-   第 $1$ 行：$t_1 := a$\n-   第 $2$ 行：$t_2 := t_1$\n-   第 $3$ 行：$\\text{g}()$\n-   第 $4$ 行：$\\text{print}(t_2)$\n\n#### 管道 $\\mathcal{P}_1$ 分析：副本传播后进行死代码消除\n\n**第一遍：副本传播（CP）**\n\nCP遍分析代码，寻找用副本语句中的值替换变量的机会。\n1.  第 $1$ 行的语句 $t_1 := a$ 是一条副本指令。\n2.  第 $2$ 行的语句使用了 $t_1$。这个 $t_1$ 用途的到达定值是第 $1$ 行的副本。由于 $a$ 未被修改，因此 $t_1$ 的使用可以被替换为 $a$。\n3.  由于CP是单遍的，它将第 $2$ 行转换为 $t_2 := a$。请注意，根据问题定义，CP不移除第 $1$ 行。\n4.  该遍继续进行。没有其他由纯副本定义的变量用途可以传播。例如，虽然第 $2$ 行（$t_2 := t_1$）是一个副本，但一个简单的单遍实现不一定会在已经转换了第 $2$ 行之后，将 $t_1$ 传播到第 $4$ 行中 $t_2$ 的使用处。最直接的转换是从第 $1$ 行到第 $2$ 行的转换。\n\nCP遍后的代码是：\n-   第 $1$ 行：$t_1 := a$\n-   第 $2$ 行：$t_2 := a$ (已修改)\n-   第 $3$ 行：$\\text{g}()$\n-   第 $4$ 行：$\\text{print}(t_2)$\n\n**第二遍：死代码消除（DCE）**\n\nDCE应用于CP遍产生的代码。我们确定哪些语句是死的。如果 $x$ 在语句之后不是活跃的，并且 $e$ 没有副作用，则语句 $x := e$ 是死的。\n1.  **活跃性分析（反向扫描）：**\n    -   第 $4$ 行之后，没有变量是活跃的。\n    -   第 $4$ 行（$\\text{print}(t_2)$）之前，变量 $t_2$ 被使用，所以它是活跃的。活跃集：{$t_2$}。\n    -   第 $3$ 行（$\\text{g}()$）之前，$t_2$ 仍然是活跃的，因为它的值将在第 $4$ 行使用。活跃集：{$t_2$}。\n    -   第 $2$ 行（$t_2 := a$）之前，出口活跃集是 {$t_2$}。该语句定义了 $t_2$ 并使用了 $a$。入口活跃集是 $(\\text{出口活跃集} - \\{t_2\\}) \\cup \\{a\\} = (\\{t_2\\} - \\{t_2\\}) \\cup \\{a\\} = \\{a\\}$。\n    -   第 $1$ 行（$t_1 := a$）之前，出口活跃集是第 $2$ 行的入口活跃集，即 {$a$}。\n2.  **应用DCE规则：**\n    -   第 $4$ 行，$\\text{print}(t_2)$，具有副作用并且是可观察的。它不是死代码。\n    -   第 $3$ 行，$\\text{g}()$，具有副作用并且是可观察的。它不是死代码。\n    -   第 $2$ 行，$t_2 := a$：变量 $t_2$ 在此语句后是活跃的（出口活跃集是 {$t_2$}）。因此，此语句**不是**死代码。\n    -   第 $1$ 行，$t_1 := a$：$t_1$ 在此语句后是否活跃？第 $1$ 行后的活跃变量集是 {$a$}。$t_1$ 不在该集合中。表达式 $a$ 没有副作用。因此，语句 $t_1 := a$ 是**死代码**。它被移除。\n\n**$\\mathcal{P}_1$ 的最终代码：**\n-   第 $2$ 行：$t_2 := a$\n-   第 $3$ 行：$\\text{g}()$\n-   第 $4$ 行：$\\text{print}(t_2)$\n\n此管道产生一个包含 $3$ 条指令的代码块。\n\n#### 管道 $\\mathcal{P}_2$ 分析：死代码消除后进行副本传播\n\n**第一遍：死代码消除（DCE）**\n\nDCE应用于原始IR代码。\n1.  **活跃性分析（对原始代码进行反向扫描）：**\n    -   第 $4$ 行之后，没有变量是活跃的。\n    -   第 $4$ 行（$\\text{print}(t_2)$）之前，$t_2$ 是活跃的。活跃集：{$t_2$}。\n    -   第 $3$ 行（$\\text{g}()$）之前，$t_2$ 是活跃的。活跃集：{$t_2$}。\n    -   第 $2$ 行（$t_2 := t_1$）之前，出口活跃集是 {$t_2$}。该语句定义了 $t_2$ 并使用了 $t_1$。入口活跃集是 $(\\{t_2\\} - \\{t_2\\}) \\cup \\{t_1\\} = \\{t_1\\}$。\n    -   第 $1$ 行（$t_1 := a$）之前，出口活跃集是 {$t_1$}。该语句定义了 $t_1$ 并使用了 $a$。入口活跃集是 $(\\{t_1\\} - \\{t_1\\}) \\cup \\{a\\} = \\{a\\}$。\n2.  **应用DCE规则：**\n    -   第 $4$ 行，$\\text{print}(t_2)$：有副作用。不是死代码。\n    -   第 $3$ 行，$\\text{g}()$：有副作用。不是死代码。\n    -   第 $2$ 行，$t_2 := t_1$：变量 $t_2$ 在此赋值后是活跃的。不是死代码。\n    -   第 $1$ 行，$t_1 := a$：变量 $t_1$ 在此赋值后是活跃的。不是死代码。\n\nDCE遍没有移除任何指令。代码保持不变。\n\n**第二遍：副本传播（CP）**\n\nCP应用于DCE遍产生的代码（即原始代码）。\n1.  第 $1$ 行的语句 $t_1 := a$ 是一个副本。\n2.  第 $2$ 行中 $t_1$ 的使用被 $a$ 替换。第 $2$ 行变为 $t_2 := a$。\n3.  问题规定CP不删除语句。因此，第 $1$ 行保留在代码中。\n4.  没有后续的DCE遍来清理现在已死的第 $1$ 行。\n\n**$\\mathcal{P}_2$ 的最终代码：**\n-   第 $1$ 行：$t_1 := a$\n-   第 $2$ 行：$t_2 := a$ (已修改)\n-   第 $3$ 行：$\\text{g}()$\n-   第 $4$ 行：$\\text{print}(t_2)$\n\n此管道产生一个包含 $4$ 条指令的代码块。\n\n### 逐项分析选项\n\n**A. 管道 $\\mathcal{P}_1$ 通过副本传播将第 $2$ 行重写为 $t_2 := a$，这使得第 $1$ 行成为死代码；然后死代码消除移除第 $1$ 行。最终代码包含第 $2$–$4$ 行，其中第 $2$ 行为 $t_2 := a$。管道 $\\mathcal{P}_2$ 首先运行死代码消除，并保留第 $1$ 行，因为 $t_1$ 在第 $2$ 行被使用；然后副本传播将第 $2$ 行重写为 $t_2 := a$，但第 $1$ 行仍然存在，因为没有后续的死代码消除遍运行。因此 $\\mathcal{P}_1$ 比 $\\mathcal{P}_2$ 少产生一条指令。**\n-   对 $\\mathcal{P}_1$ 的分析与我的推导完全一致。CP使第 $1$ 行成为死代码，DCE将其移除。最终代码与描述完全相符。\n-   对 $\\mathcal{P}_2$ 的分析也与我的推导完全一致。初始的DCE什么也不做，因为 $t_1$ 是活跃的。然后CP运行，但没有后续的DCE遍来移除现在已死的第 $1$ 行。\n-   $\\mathcal{P}_1$（$3$条指令）比 $\\mathcal{P}_2$（$4$条指令）少产生一条指令的结论是正确的。\n-   **判定：正确。**\n\n**B. 两个管道都通过移除第 $1$ 行并保留第 $2$–$4$ 行来产生相同的最终代码，因为死代码消除无需副本传播的辅助就能看透副本。**\n-   这是不正确的。如对 $\\mathcal{P}_2$ 的分析所示，初始的DCE遍不会移除第 $1$ 行，因为 $t_1$ 因在第 $2$ 行被使用而活跃。所提供的DCE定义不允许它“看透”副本；它严格依赖于由直接使用决定的活跃性。两个管道产生不同的结果。\n-   **判定：不正确。**\n\n**C. 管道 $\\mathcal{P}_2$ 在其副本传播步骤之后也移除了第 $1$ 行，因为副本传播会删除它所暴露的任何死定义，所以两个管道最终都只剩下第 $2$–$4$ 行。**\n-   这是不正确的。它明确地与问题的定义相矛盾：“副本传播本身不删除语句”。在管道 $\\mathcal{P}_2$ 中，CP运行后，管道终止。没有后续的遍来移除已成为死定义的第 $1$ 行。\n-   **判定：不正确。**\n\n**D. 死代码消除移除了第 $4$ 行，因为 $t_2$ 在打印后未被使用，所以第 $4$ 行是死代码；因此两个管道的最终代码中都不会保留第 $4$ 行。**\n-   这是不正确的。它误解了死代码的定义。该定义要求两个条件：结果未被使用 且 语句没有副作用。问题明确指出 $\\text{print}(t_2)$ “是可观察的，并具有副作用”。因此，给定的DCE遍永远不会移除它。\n-   **判定：不正确。**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}