{
    "hands_on_practices": [
        {
            "introduction": "在底层优化中，许多算术运算可以通过巧妙的位运算技巧进行转换，从而提升性能。本练习探讨一个经典的位运算恒等式，将减法和位与操作的组合替换为位非和位与的组合。通过这个练习，你将深入理解二进制补码算术与布尔代数之间的深刻联系，并学会量化这种窥孔优化在具体硬件上带来的性能增益。",
            "id": "3662231",
            "problem": "考虑一个编译器窥孔优化（Peephole Optimization, PO），其目标是定宽二进制补码（Two’s Complement, TC）整数。设 $a$ 和 $b$ 为固定的 $w$ 位整数，其中 $w \\geq 1$。优化器建议将表达式 $a - (a \\ b)$ 替换为 $a \\ (\\sim b)$，其中 $\\$ 表示按位与（bitwise AND），$\\sim$ 表示按位非（bitwise NOT），$-$ 表示在 TC 语义下的整数减法（模 $2^{w}$）。请仅使用按位运算和 TC 减法的核心定义，推导 $a - (a \\ b)$ 和 $a \\ (\\sim b)$ 的等价性，并论证该转换在按位解释（逐比特的布尔代数）和算术解释（对于无符号视图，值为 $\\{0,1,\\dots,2^{w}-1\\}$；对于有符号视图，值为 $\\{-2^{w-1},\\dots,2^{w-1}-1\\}$）下均有效，同时注意 TC 有符号和无符号解释共享相同的位模式。然后，评估此窥孔模式在目标中央处理器（CPU）上的性能影响。该 CPU 在一个简单的无重叠串行执行模型下具有以下指令延迟：按位与消耗 $1$ 个周期，按位非消耗 $1$ 个周期，减法消耗 $2$ 个周期。原始表达式 $a - (a \\ b)$ 的执行序列是一个按位与操作后跟一个减法操作；优化后表达式 $a \\ (\\sim b)$ 的执行序列是一个按位非操作后跟一个按位与操作。如果此优化应用于一个热路径，其中该模式出现 $N = 7.5 \\times 10^{7}$ 次，请计算通过执行此转换所节省的总周期数。将你的答案四舍五入到四位有效数字。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n- 设 $a$ 和 $b$ 为 $w$ 位二进制补码（TC）格式的整数，其中 $w \\geq 1$。\n- 提议的优化是将表达式 $a - (a \\ b)$ 替换为 $a \\ (\\sim b)$。\n- 运算符 $\\$ 表示按位与。\n- 运算符 $\\sim$ 表示按位非。\n- 运算符 $-$ 表示在 TC 语义下的整数减法（模 $2^{w}$）。\n- 任务要求推导两个表达式的等价性，并在按位和算术两种解释下论证转换的有效性。\n- 给出了简单串行执行模型下的 CPU 指令延迟：\n  - 按位与：$1$ 个周期。\n  - 按位非：$1$ 个周期。\n  - 减法：$2$ 个周期。\n- 原始表达式 $a - (a \\ b)$ 的指令序列是一个按位与操作后跟一个减法操作。\n- 优化后表达式 $a \\ (\\sim b)$ 的指令序列是一个按位非操作后跟一个按位与操作。\n- 该模式在热路径中出现 $N = 7.5 \\times 10^{7}$ 次。\n- 最终任务是计算节省的总周期数，并将答案四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据（关键）**：该问题基于计算机算术的基本原理，特别是二进制补码表示法、按位逻辑和指令周期计数。这些是计算机科学与工程中标准且成熟的概念。\n- **适定性**：该问题是适定的。它要求证明一个已知的恒等式，并基于所提供的参数进行后续计算。存在唯一且有意义的解。\n- **客观性（关键）**：问题以精确、客观的语言陈述，没有歧义或主观论断。\n- **完整性与一致性**：问题是自洽的。所有必要的变量（$a$、$b$、$w$、$N$）、操作定义（按位与、非、TC 减法）和常量（指令延迟）都已提供。没有内部矛盾。\n\n### 步骤 3：结论与行动\n该问题具有科学合理性、适定性，并提供了所有必要信息。因此，该问题是 **有效的**。我们可以继续进行求解。\n\n### 第一部分：等价性推导\n我们必须证明，对于任何 $w$ 位二进制补码整数 $a$ 和 $b$，表达式 $a - (a \\ b)$ 等价于 $a \\ (\\sim b)$。我们将从按位和算术两个角度来证明这个等价性。\n\n#### 按位证明\n设 $a_i$ 和 $b_i$ 分别是整数 $a$ 和 $b$ 的第 $i$ 位，其中 $i \\in \\{0, 1, \\dots, w-1\\}$。\n\n首先，考虑目标表达式：$a \\ (\\sim b)$。其结果的第 $i$ 位（我们称之为 $r_i$）由布尔表达式 $r_i = a_i \\wedge (\\neg b_i)$ 给出，其中 $\\wedge$ 表示逻辑与，$\\neg$ 表示逻辑非。我们可以根据 $b_i$ 的值来评估这个表达式：\n- 如果 $b_i = 0$，那么 $\\neg b_i = 1$，所以 $r_i = a_i \\wedge 1 = a_i$。\n- 如果 $b_i = 1$，那么 $\\neg b_i = 0$，所以 $r_i = a_i \\wedge 0 = 0$。\n\n接下来，考虑原始表达式：$a - (a \\ b)$。令 $c = a \\ b$。$c$ 的第 $i$ 位 $c_i$ 是 $a_i \\wedge b_i$。一个关键的观察是，对于任何位 $i$，$c_i$ 只有在 $a_i$ 也为 $1$ 时才能为 $1$。这意味着对于所有的 $i$，$a_i \\geq c_i$。\n当我们计算二进制减法 $a - c$ 时，因为位 $a_i$ 总是大于或等于位 $c_i$，所以从位 $i$ 到位 $i+1$ 永远不会产生借位。因此，减法可以逐位独立进行。\n因此，结果的第 $i$ 位（我们称之为 $s_i$）就是 $s_i = a_i - c_i = a_i - (a_i \\wedge b_i)$。我们根据 $b_i$ 的值来评估这个表达式：\n- 如果 $b_i = 0$，那么 $c_i = a_i \\wedge 0 = 0$。结果是 $s_i = a_i - 0 = a_i$。\n- 如果 $b_i = 1$，那么 $c_i = a_i \\wedge 1 = a_i$。结果是 $s_i = a_i - a_i = 0$。\n\n比较结果，我们发现在所有情况下都有 $r_i = s_i$。由于对于每个位置 $i \\in \\{0, 1, \\dots, w-1\\}$，结果位都是相同的，因此 $a - (a \\ b)$ 和 $a \\ (\\sim b)$ 的位模式是相同的。由于 TC 有符号和无符号解释共享相同的位模式和操作，此证明对两者均成立。\n\n#### 算术证明\n算术证明依赖于加法和按位运算的性质。对于任意两个数 $X$ 和 $Y$，按位恒等式 $(X \\ Y) | (X \\ (\\sim Y)) = X$ 成立，其中 $|$ 是按位或。左边的两项，$(X \\ Y)$ 和 $(X \\ (\\sim Y))$，是按位不相交的，这意味着不存在任何位 $i$ 使得这两项在该位上都为 1。\n当两个数按位不相交时，它们的算术和等于它们的按位或。因此，对于以定宽格式（如 TC 或无符号数）表示的数，我们有以下算术等式：\n$$\na = (a \\ b) + (a \\ (\\sim b))\n$$\n这个等式在模 $2^w$ 的意义下成立。通过重新整理各项，我们直接得到需要证明的恒等式：\n$$\na - (a \\ b) = a \\ (\\sim b)\n$$\n减法是在模 $2^w$ 下执行的，这与问题中 TC 减法的定义一致。这完成了算术证明，并确认了转换的有效性。\n\n### 第二部分：性能影响计算\n题目要求我们计算应用此优化 $N = 7.5 \\times 10^{7}$ 次所节省的总周期数。\n\n设延迟如下：\n- $L_{\\text{AND}} = 1$ 周期\n- $L_{\\text{NOT}} = 1$ 周期\n- $L_{\\text{SUB}} = 2$ 周期\n\n原始表达式 $a - (a \\ b)$ 的成本是一个按位与操作和一个减法操作的延迟之和，两者串行执行。\n$$\nC_{\\text{original}} = L_{\\text{AND}} + L_{\\text{SUB}} = 1 + 2 = 3 \\text{ cycles}\n$$\n\n优化后表达式 $a \\ (\\sim b)$ 的成本是一个按位非操作和一个按位与操作的延迟之和，两者串行执行。\n$$\nC_{\\text{optimized}} = L_{\\text{NOT}} + L_{\\text{AND}} = 1 + 1 = 2 \\text{ cycles}\n$$\n\n每次应用优化所节省的周期数是原始成本与优化后成本之差。\n$$\n\\Delta C = C_{\\text{original}} - C_{\\text{optimized}} = 3 - 2 = 1 \\text{ cycle}\n$$\n\n在 $N$ 次出现中节省的总周期数是每次节省的周期数与出现次数的乘积。\n$$\nS_{\\text{total}} = N \\times \\Delta C\n$$\n代入给定的值 $N = 7.5 \\times 10^{7}$：\n$$\nS_{\\text{total}} = (7.5 \\times 10^{7}) \\times 1 = 7.5 \\times 10^{7}\n$$\n\n问题要求答案四舍五入到四位有效数字。计算出的值是精确的。为了用四位有效数字表示 $7.5 \\times 10^7$，我们将其写作 $7.500 \\times 10^7$。",
            "answer": "$$\\boxed{7.500 \\times 10^7}$$"
        },
        {
            "introduction": "强度削减，例如用更快的移位操作代替慢速的除法操作，是编译器优化中的常见模式。然而，这种替换并非总是安全的，因为高级语言的算术语义与底层硬件指令的行为可能存在细微差别。本练习将引导你探究有符号整数除法和算术右移之间的语义差异，特别是在处理负数时，并设计一个“带守卫”的优化模式，以确保转换的正确性。",
            "id": "3662235",
            "problem": "一个窥孔优化器考虑将定长（字长 $w \\ge 2$）有符号二进制补码整数的二除法运算 $x / 2$ 替换为算术右移一位运算 $x \\gg 1$。目标机器将算术右移定义为符号位扩展：将一个有符号整数 $x$ 右移一位，会丢弃最低有效位，并在最高有效位处复制符号位，从而得到一个新值。源语言将有符号整数的二除法定义为向零截断：对于任意有符号整数 $x$，表达式 $x / 2$ 计算出唯一的整数 $\\mathrm{trunc}(x/2)$，其绝对值为 $\\lfloor |x/2| \\rfloor$ 的向下取整，其符号与 $x$ 的符号相同。假设 $x$ 的定义域是所有 $w$ 位有符号二进制补码整数，即 $x \\in \\{-2^{w-1}, -2^{w-1}+1, \\dots, 2^{w-1}-1\\}$，并且机器对该定义域中的所有值都能正确实现算术右移。\n\n根据这些定义，完成以下任务：\n\n1. 推导出一个关于 $x$ 的精确条件，在该条件下 $x / 2$ 和 $x \\gg 1$ 的语义一致，并推导出其互补条件，即语义不一致的条件。用至少一个明确的 $x$ 反例值来证明这种不一致性。\n\n2. 提出一种带守卫的窥孔重写模式，仅当指令流中的局部证明确定在使用点处 $x \\ge 0$ 时，才应用替换 $x / 2 \\mapsto x \\gg 1$。用一个对窥孔优化器而言语法上可用的支配性比较来描述这个守卫（不需要全局数据流分析），并解释为什么这个守卫能保持语义。\n\n3. 假设 $x$ 在所有 $w$ 位有符号整数上均匀分布。计算在所有 $x$ 的值中，无守卫的替换 $x / 2 \\mapsto x \\gg 1$ 会改变程序结果的精确比例（以最简分数表示）。最终分数不要使用百分号表示。\n\n你的最终答案必须是一个实数或一个闭式解析表达式。不需要四舍五入。",
            "solution": "本问题要求分析对于有符号二进制补码整数，整数二除法与算术右移一位之间的语义等价性。我们必须首先验证问题陈述的有效性。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   操作1：整数二除法，表示为 `$x / 2$`。其语义定义为向零截断，即 `$\\mathrm{trunc}(x/2)$`。对于任意有符号整数 `$x$`，这会产生一个唯一的整数，其绝对值为 `$\\lfloor |x/2| \\rfloor$`，其符号与 `$x$` 的符号相同。\n-   操作2：算术右移一位，表示为 `$x \\gg 1$`。其语义定义为丢弃最低有效位并在最高有效位处复制符号位。\n-   整数表示：字长为 `$w \\ge 2$` 的有符号二进制补码整数。\n-   `$x$` 的定义域：所有 `$w$` 位有符号整数的集合，即 `$\\{ -2^{w-1}, -2^{w-1}+1, \\dots, 2^{w-1}-1 \\}$`。\n-   假设：目标机器对指定定义域中的所有值都能正确实现算术右移。\n-   任务1：推导 `$x / 2$` 和 `$x \\gg 1$` 语义一致与不一致的条件，并为不一致的情况提供一个反例。\n-   任务2：提出一种带守卫的窥孔优化，使用局部可用的支配性比较来确保 `$x \\ge 0$`。\n-   任务3：对于在定义域上均匀分布的 `$x$`，计算无守卫的替换 `$x / 2 \\mapsto x \\gg 1$` 会导致错误的精确值比例。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是编译器构造和计算机体系结构中的一个标准课题。所提供的关于二进制补码运算、整数除法语义（向零截断）和算术右移的定义都是标准且明确的。问题是自包含的，提供了所有必要信息。约束条件（`$w \\ge 2$`）是合理的。问题是客观且适定的，能够导出一个唯一且可验证的解。没有矛盾、事实错误或无法验证的说法。\n\n**步骤3：结论与行动**\n此问题是**有效的**。将提供完整解答。\n\n### 解答推导\n\n首先，我们必须精确地形式化这两种操作的数学行为。在二进制补码整数 `$x$` 上进行算术右移一位的标准定义是计算 `$x$` 除以 `$2$` 的向下取整。也就是说，`$x \\gg 1 \\equiv \\lfloor x/2 \\rfloor$`。编程语言的除法 `$x / 2$` 定义为向零截断，可以分段表示为：\n$$\n\\mathrm{trunc}(v) =\n\\begin{cases}\n    \\lfloor v \\rfloor   \\text{if } v \\ge 0 \\\\\n    \\lceil v \\rceil   \\text{if } v  0\n\\end{cases}\n$$\n因此，`$x / 2 \\equiv \\mathrm{trunc}(x/2)$`。\n\n**1. 一致与不一致的条件**\n\n我们寻求 `$x$` 满足的条件，使得 `$x \\gg 1$` 和 `$x / 2$` 等价。这意味着要找出何时 `$\\lfloor x/2 \\rfloor = \\mathrm{trunc}(x/2)$`。\n\n情况1：`$x \\ge 0$`\n对于任何非负数 `$x$`，`$x/2 \\ge 0$`。`$\\mathrm{trunc}$` 对于非负值的定义是 `$\\mathrm{trunc}(v) = \\lfloor v \\rfloor$`。因此，对于 `$x \\ge 0$`，我们有 `$\\mathrm{trunc}(x/2) = \\lfloor x/2 \\rfloor$`。在这种情况下，`$x / 2$` 和 `$x \\gg 1$` 的语义总是一致。\n\n情况2：`$x  0$`\n对于任何负数 `$x$`，`$x/2  0$`。`$\\mathrm{trunc}$` 对于负值的定义是 `$\\mathrm{trunc}(v) = \\lceil v \\rceil$`。等价条件变为 `$\\lfloor x/2 \\rfloor = \\lceil x/2 \\rceil$`。一个数的向下取整和向上取整相等，当且仅当这个数是整数。因此，仅当 `$x/2$` 是整数时，这两个操作才一致。这又当且仅当 `$x$` 是偶数时成立。如果 `$\\lfloor x/2 \\rfloor \\neq \\lceil x/2 \\rceil$`，则操作不一致，这发生在 `$x/2$` 不是整数时。这又当且仅当 `$x$` 是奇数时成立。\n\n条件总结：\n-   **一致**：如果 `$x \\ge 0$`，或者 `$x$` 是负偶数，`$x/2$` 和 `$x \\gg 1$` 的语义一致。\n-   **不一致**：如果 `$x$` 是负奇数，语义不一致。\n\n为了证明不一致性，我们提供一个反例。设 `$x = -3$`。\n-   语言定义的除法：`$x / 2 = \\mathrm{trunc}(-3/2) = \\mathrm{trunc}(-1.5) = -1$`。\n-   算术右移：`$x \\gg 1 = \\lfloor -3/2 \\rfloor = \\lfloor -1.5 \\rfloor = -2$`。\n显然，`$-1 \\neq -2$`，这证明了语义上的差异。\n\n**2. 带守卫的窥孔重写模式**\n\n根据以上分析，如果可以证明 `$x \\ge 0$`，则替换 `$x / 2 \\mapsto x \\gg 1$` 是保持语义的。窥孔优化器可以使用守卫来强制执行此条件。在编译后的代码中，一个常见的场景是测试变量符号的 `if` 语句。这会生成一条比较指令，后跟一条条件分支指令。\n\n考虑与 `if (x >= 0) { y = x / 2; }` 对应的机器指令序列。它可能被编译为：\n`CMP x, #0`  (Compare register `x` with the immediate value `$0$`)\n`JL is_negative` (Jump if Less to a different code block)\n`...`\n`DIV x, #2` (Integer division, result in `x`)\n`...`\n`is_negative:`\n`...`\n\n检查 `DIV` 指令的窥孔优化器可以向后查看指令流。如果它找到一个在前的 `CMP x, #0` 指令，并确定只有在满足“大于或等于”条件时（即 `JL` 分支未被采用）当前基本块才可达，那么它就获得了在除法点 `$x \\ge 0$` 的局部证明。\n\n**带守卫的窥孔重写模式**如下：\n-   **模式**：识别一个除以 `$2$` 的除法 (`DIV reg, #2`)。\n-   **守卫**：在窥孔窗口内向后扫描，寻找一个 `CMP reg, #0` 指令，且该指令未被任何修改 `reg` 的中间指令所失效。验证通向 `DIV` 指令的控制流保证了在比较时条件 `$reg \\ge 0$` 已经满足。\n-   **替换**：如果守卫条件满足，将 `DIV reg, #2` 指令替换为更快的 `SAR reg, #1`（算术右移 `$1$` 位）指令。\n\n这个守卫能够保持语义，因为正如第一部分所证明的，对于所有 `$x \\ge 0$`，都有 `$\\mathrm{trunc}(x/2) = \\lfloor x/2 \\rfloor$`。该守卫确保了等价条件得到满足，从而使优化是安全的。\n\n**3. 不一致值的比例**\n\n我们需要计算在 `$w$` 位有符号整数中，无守卫替换会导致错误结果的比例。这对应于 `$x/2 \\neq x \\gg 1$` 的值集合，我们已确定该集合为负奇数集。\n\n一个 `$w$` 位整数的不同值的总数是 `$2^w$`。有符号二进制补码整数的定义域是 `$\\{ -2^{w-1}, \\dots, -1, 0, 1, \\dots, 2^{w-1}-1 \\}$`。\n-   非负整数（`$0$` 到 `$2^{w-1}-1$`）的数量是 `$2^{w-1}$`。\n-   负整数（`$-2^{w-1}$` 到 `$-1$`）的数量是 `$-1 - (-2^{w-1}) + 1 = 2^{w-1}$`。\n\n我们需要计算在这 `$2^{w-1}$` 个负整数中有多少是奇数。一个整数是奇数当且仅当其最低有效位（`LSB`）是 `$1$`。一个整数是偶数当且仅当其 `LSB` 是 `$0$`。在任意 `$N$` 个连续整数的范围内，如果 `$N$` 是偶数，则恰好有 `$N/2$` 个奇数和 `$N/2$` 个偶数。\n从 `$-2^{w-1}$` 到 `$-1$` 的负整数范围包含 `$2^{w-1}$` 个连续整数。由于问题指定 `$w \\ge 2$`，负整数的数量 `$2^{w-1}$` 是一个偶数（因为 `$2^{2-1}=2$`，`$2^{3-1}=4$` 等）。因此，负奇数的数量恰好是负整数总数的一半。\n\n负奇数的数量 = `$\\frac{1}{2} \\times (\\text{负整数数量}) = \\frac{1}{2} \\times 2^{w-1} = 2^{w-2}$`。\n\n替换不正确的数值所占的比例，是语义不一致的数值数量与总数值数量的比值。\n$$\n\\text{比例} = \\frac{\\text{负奇数数量}}{\\text{整数总数}} = \\frac{2^{w-2}}{2^w} = 2^{w-2-w} = 2^{-2} = \\frac{1}{4}\n$$\n这个比例 `$\\frac{1}{4}$` 与字长 `$w$` 无关（只要 `$w \\ge 2$`）。因此，对于一个均匀分布的 `$w$` 位有符号整数，无守卫地将二除法替换为算术右移有 `$25\\%$` 的概率会产生不正确的结果。",
            "answer": "$$\n\\boxed{\\frac{1}{4}}\n$$"
        },
        {
            "introduction": "与整数算术不同，浮点算术的世界充满了微妙的陷阱，常规的代数直觉在这里可能失效。一个看似无害的优化，如将表达式 $x-x$ 替换为 $0.0$，可能会因未能保留“带符号的零”而改变程序的最终结果。本练习通过一个具体的例子，揭示了在 IEEE 754 浮点标准下，这种代数简化如何导致错误，并强调了在进行浮点优化时必须保持高度警惕。",
            "id": "3662197",
            "problem": "一个编译器执行一项窥孔优化，该优化根据一个标准的代数恒等式重写相同的减法模式：当编译器可以证明两个操作数的值相同且表达式没有副作用时，它会将 $x - x$ 的中间表示替换为浮点字面量 $0.0$。目标架构实现了带有符号零的电气和电子工程师协会 (IEEE) 754 binary64 算术，并且当前活动的舍入模式是“朝负无穷方向舍入”。假设语言规定字面量 $0.0$ 表示 $+0.0$。\n\n考虑以下两个计算\n$$f(x) = \\frac{1.0}{x - x} \\quad \\text{和} \\quad g(x) = \\frac{1.0}{0.0},$$\n其中 $g$ 是对 $f$ 应用窥孔重写优化后的结果。令 $x$ 为有限值 $x = 1.0$。定义符号映射 $\\operatorname{sgn}_{\\infty}(y)$：当 $y$ 的求值为 $+\\infty$ 时为 $+1$，当 $y$ 的求值为 $-\\infty$ 时为 $-1$，其他情况下为 $0$。在所述的舍入模式以及 IEEE 754 关于带符号的零和除以零的规则下，计算单一数值量\n$$\\operatorname{sgn}_{\\infty}\\!\\big(f(1.0)\\big) - \\operatorname{sgn}_{\\infty}\\!\\big(g(1.0)\\big).$$\n精确算术之外不需要进行舍入，且不涉及任何物理单位。请将最终答案表示为单个实数。",
            "solution": "问题要求计算数量 $\\operatorname{sgn}_{\\infty}\\!\\big(f(1.0)\\big) - \\operatorname{sgn}_{\\infty}\\!\\big(g(1.0)\\big)$，其中函数 $f(x)$ 和 $g(x)$ 定义为\n$$f(x) = \\frac{1.0}{x - x}$$\n$$g(x) = \\frac{1.0}{0.0}$$\n函数 $g(x)$ 代表了对 $f(x)$ 应用编译器窥孔优化的结果。计算是在电气和电子工程师协会 (IEEE) 754 binary64 算术规则下执行的，舍入模式设置为“朝负无穷方向舍入”。\n\n首先，我们必须计算 $f(1.0)$ 的值。\n$$f(1.0) = \\frac{1.0}{1.0 - 1.0}$$\n这个求值的关键部分是分母 $1.0 - 1.0$。在 IEEE 754 算术中，减法 $a - b$ 定义为加法 $a + (-b)$。在这里，我们计算的是 $1.0 + (-1.0)$。两个操作数 $1.0$ 和 $-1.0$ 符号相反，它们的数学和恰好为零。\n\nIEEE 754 标准规定了当结果恰好为零时的符号。根据 IEEE 754-2008 标准的第 6.3 节，当两个符号相反的操作数之和恰好为零时，在所有舍入模式下，和的符号都为正 ($+0.0$)，*除了*“朝负无穷方向舍入”模式。在“朝负无穷方向舍入”的舍入模式下（也称为 `FE_DOWNWARD`），精确为零的和的符号为负 ($-0.0$)。\n\n鉴于题目明确指出当前活动的舍入模式是“朝负无穷方向舍入”，表达式 $1.0 - 1.0$ 的求值为 $-0.0$。\n因此，$f(1.0)$ 的求值过程如下：\n$$f(1.0) = \\frac{1.0}{-0.0}$$\nIEEE 754 标准定义了除以零的运算。一个有限非零数除以一个带符号的零，结果是带符号的无穷大。具体来说，一个正数（如 $1.0$）除以负零 ($-0.0$) 会得到负无穷 ($-\\infty$)。\n因此，$f(1.0) = -\\infty$。\n\n接下来，我们计算 $g(1.0)$ 的值。\n函数 $g(x)$ 是编译器窥孔优化的结果，该优化将表达式 $x - x$ 替换为浮点字面量 $0.0$。题目说明规定语言将字面量 $0.0$ 视为正零 ($+0.0$)。\n所以，表达式的分母被替换，得到：\n$$g(1.0) = \\frac{1.0}{0.0} = \\frac{1.0}{+0.0}$$\n根据 IEEE 754 关于除以零的规则，一个正数 ($1.0$) 除以正零 ($+0.0$) 会得到正无穷 ($+\\infty$)。\n因此，$g(1.0) = +\\infty$。\n\n现在我们可以应用符号映射函数 $\\operatorname{sgn}_{\\infty}(y)$，其定义如下：\n$$ \\operatorname{sgn}_{\\infty}(y) = \\begin{cases} +1   \\text{if } y = +\\infty \\\\ -1   \\text{if } y = -\\infty \\\\ 0   \\text{otherwise} \\end{cases} $$\n将此函数应用于我们的结果：\n对于 $f(1.0) = -\\infty$，我们有 $\\operatorname{sgn}_{\\infty}\\!\\big(f(1.0)\\big) = \\operatorname{sgn}_{\\infty}(-\\infty) = -1$。\n对于 $g(1.0) = +\\infty$，我们有 $\\operatorname{sgn}_{\\infty}\\!\\big(g(1.0)\\big) = \\operatorname{sgn}_{\\infty}(+\\infty) = +1$。\n\n最后，我们计算所需的差值：\n$$ \\operatorname{sgn}_{\\infty}\\!\\big(f(1.0)\\big) - \\operatorname{sgn}_{\\infty}\\!\\big(g(1.0)\\big) = (-1) - (+1) = -1 - 1 = -2 $$\n这个结果凸显了编译器设计中的一个关键问题：一个看似正确的代数优化 ($x-x=0$) 在所有浮点舍入模式下与原始表达式并非语义等价，从而导致程序行为的改变。该优化未能保留零的符号，这在后续的除法等运算中会产生可观察到的后果。",
            "answer": "$$\n\\boxed{-2}\n$$"
        }
    ]
}