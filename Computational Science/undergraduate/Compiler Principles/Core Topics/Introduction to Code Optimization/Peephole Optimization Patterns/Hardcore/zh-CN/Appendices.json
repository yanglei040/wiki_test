{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基本的位运算优化开始。这个练习  要求你使用位逻辑和算术属性，证明两个表达式 $a - (a \\ \\ \\ b)$ 和 $a \\ \\ \\ (\\sim b)$ 的等价性。理解这一转换有助于巩固你对二进制补码运算的掌握，并展示一个简单的重写如何通过用更快的位运算代替较慢的减法运算，带来显著的性能提升。",
            "id": "3662231",
            "problem": "考虑一个针对定宽二进制补码 (TC) 整数的编译器窥孔优化 (PO)。设 $a$ 和 $b$ 为固定的 $w \\geq 1$ 位的整数。优化器建议将表达式 $a - (a \\ \\ \\ b)$ 替换为 $a \\ \\ \\ (\\sim b)$，其中  表示按位与，$\\sim$ 表示按位非，$-$ 表示在 TC 语义下的整数减法，模 $2^{w}$。仅使用按位运算和 TC 减法的核心定义，推导 $a - (a \\ \\ \\ b)$ 和 $a \\ \\ \\ (\\sim b)$ 的等价性，并证明该变换在按位解释（逐比特的布尔代数）和算术解释（无符号视图下的值在 $\\{0,1,\\dots,2^{w}-1\\}$ 或有符号视图下的值在 $\\{-2^{w-1},\\dots,2^{w-1}-1\\}$）下均有效，注意 TC 的有符号和无符号解释共享相同的位模式。然后，评估此窥孔模式在目标中央处理器 (CPU) 上的性能影响。该 CPU 在一个简单的无重叠串行执行模型下具有以下指令延迟：按位与消耗 $1$ 个周期，按位非消耗 $1$ 个周期，减法消耗 $2$ 个周期。$a - (a \\ \\ \\ b)$ 的原始序列使用一个按位与后跟一个减法；$a \\ \\ \\ (\\sim b)$ 的优化序列使用一个按位非后跟一个按位与。如果此优化应用于一个热路径，其中该模式出现 $N = 7.5 \\times 10^{7}$ 次，计算执行该变换所节省的总周期数。将您的答案四舍五入到四位有效数字。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知信息\n- 设 $a$ 和 $b$ 为 $w$ 位二进制补码 (TC) 格式的整数，其中 $w \\geq 1$。\n- 提议的优化是将表达式 $a - (a \\ \\ \\ b)$ 替换为 $a \\ \\ \\ (\\sim b)$。\n- 运算符  表示按位与。\n- 运算符 $\\sim$ 表示按位非。\n- 运算符 $-$ 表示在 TC 语义下模 $2^{w}$ 的整数减法。\n- 任务要求推导两个表达式的等价性，并从按位和算术两种解释下证明该变换的有效性。\n- 给出了一个简单串行执行模型的 CPU 指令延迟：\n  - 按位与：$1$ 个周期。\n  - 按位非：$1$ 个周期。\n  - 减法：$2$ 个周期。\n- $a - (a \\ \\ \\ b)$ 的原始指令序列是一个按位与操作后跟一个减法操作。\n- $a \\ \\ \\ (\\sim b)$ 的优化指令序列是一个按位非操作后跟一个按位与操作。\n- 该模式在一条热路径中出现 $N = 7.5 \\times 10^{7}$ 次。\n- 最终任务是计算节省的总周期数，并将答案四舍五入到四位有效数字。\n\n### 第 2 步：使用提取的已知信息进行验证\n- **科学基础（关键）**：该问题基于计算机算术的基本原理，特别是二进制补码表示法、按位逻辑和指令周期计数。这些是计算机科学与工程中标准且成熟的概念。\n- **适定性**：该问题是适定的。它要求证明一个已知的恒等式，并根据提供的参数进行后续计算。存在唯一且有意义的解。\n- **客观性（关键）**：问题以精确、客观的语言陈述，没有歧义或主观断言。\n- **完整性与一致性**：该问题是自包含的。所有必要的变量（$a$, $b$, $w$, $N$）、操作定义（按位与、按位非、TC 减法）和常量（指令延迟）都已提供。没有内部矛盾。\n\n### 第 3 步：结论与行动\n该问题科学上合理，适定，且提供了所有必要信息。因此，该问题是**有效的**。我们可以继续进行求解。\n\n### 第 1 部分：等价性推导\n我们必须证明，对于任意 $w$ 位 TC 整数 $a$ 和 $b$，表达式 $a - (a \\ \\ \\ b)$ 等价于 $a \\ \\ \\ (\\sim b)$。我们将从按位和算术两个角度来证明这个等价性。\n\n#### 按位证明\n设 $a_i$ 和 $b_i$ 分别是整数 $a$ 和 $b$ 的第 $i$ 位，其中 $i \\in \\{0, 1, \\dots, w-1\\}$。\n\n首先，考虑目标表达式：$a \\ \\ \\ (\\sim b)$。结果的第 $i$ 位，我们称之为 $r_i$，由布尔表达式 $r_i = a_i \\wedge (\\neg b_i)$ 给出，其中 $\\wedge$ 表示逻辑与，$\\neg$ 表示逻辑非。我们可以根据 $b_i$ 的值来计算：\n- 如果 $b_i = 0$，那么 $\\neg b_i = 1$，所以 $r_i = a_i \\wedge 1 = a_i$。\n- 如果 $b_i = 1$，那么 $\\neg b_i = 0$，所以 $r_i = a_i \\wedge 0 = 0$。\n\n接下来，考虑原始表达式：$a - (a \\ \\ \\ b)$。设 $c = a \\ \\ \\ b$。$c$ 的第 $i$ 位 $c_i$ 是 $a_i \\wedge b_i$。一个关键的观察是，对于任意位 $i$，$c_i$ 只有在 $a_i$ 也为 $1$ 时才能为 $1$。这意味着对于所有的 $i$ 都有 $a_i \\geq c_i$。\n当我们计算二进制减法 $a - c$ 时，因为位 $a_i$ 总是大于或等于位 $c_i$，所以从位 $i$ 到位 $i+1$ 永远不会产生借位。因此，减法可以逐位独立进行。\n因此，结果的第 $i$ 位，我们称之为 $s_i$，就是 $s_i = a_i - c_i = a_i - (a_i \\wedge b_i)$。我们根据 $b_i$ 的值来计算：\n- 如果 $b_i = 0$，那么 $c_i = a_i \\wedge 0 = 0$。结果是 $s_i = a_i - 0 = a_i$。\n- 如果 $b_i = 1$，那么 $c_i = a_i \\wedge 1 = a_i$。结果是 $s_i = a_i - a_i = 0$。\n\n比较结果，我们看到在所有情况下 $r_i = s_i$。由于对于每个位置 $i \\in \\{0, 1, \\dots, w-1\\}$，结果位都是相同的，所以 $a - (a \\ \\ \\ b)$ 和 $a \\ \\ \\ (\\sim b)$ 的位模式是相同的。由于 TC 的有符号和无符号解释共享相同的位模式和操作，此证明对两者都成立。\n\n#### 算术证明\n算术证明依赖于加法和按位运算的性质。对于任意两个数 $X$ 和 $Y$，按位恒等式 $(X \\ \\ \\ Y) | (X \\ \\ \\ (\\sim Y)) = X$ 成立，其中 $|$ 是按位或。左边的两项，$(X \\ \\ \\ Y)$ 和 $(X \\ \\ \\ (\\sim Y))$，是按位不相交的，意味着不存在任何位 $i$ 上这两项都为 $1$。\n当两个数按位不相交时，它们的算术和等于它们的按位或。因此，对于以定宽格式（如 TC 或无符号）表示的数，我们有算术等式：\n$$\na = (a \\ \\ \\ b) + (a \\ \\ \\ (\\sim b))\n$$\n这个等式在模 $2^w$ 意义下成立。通过重新排列各项，我们直接得到我们想要证明的恒等式：\n$$\na - (a \\ \\ \\ b) = a \\ \\ \\ (\\sim b)\n$$\n减法是在模 $2^w$ 下执行的，这与问题中 TC 减法的定义一致。这完成了算术证明，并确认了变换的有效性。\n\n### 第 2 部分：性能影响计算\n我们被要求计算应用此优化 $N = 7.5 \\times 10^{7}$ 次所节省的总周期数。\n\n设延迟如下：\n- $L_{\\text{AND}} = 1$ 周期\n- $L_{\\text{NOT}} = 1$ 周期\n- $L_{\\text{SUB}} = 2$ 周期\n\n原始表达式 $a - (a \\ \\ \\ b)$ 的成本是一个按位与操作和一个减法操作的延迟之和，两者串行执行。\n$$\nC_{\\text{original}} = L_{\\text{AND}} + L_{\\text{SUB}} = 1 + 2 = 3 \\text{ 个周期}\n$$\n\n优化后表达式 $a \\ \\ \\ (\\sim b)$ 的成本是一个按位非操作和一个按位与操作的延迟之和，两者串行执行。\n$$\nC_{\\text{optimized}} = L_{\\text{NOT}} + L_{\\text{AND}} = 1 + 1 = 2 \\text{ 个周期}\n$$\n\n每次应用优化所节省的周期数是原始成本与优化成本之差。\n$$\n\\Delta C = C_{\\text{original}} - C_{\\text{optimized}} = 3 - 2 = 1 \\text{ 个周期}\n$$\n\n在 $N$ 次出现中节省的总周期数是每次节省的周期数与出现次数的乘积。\n$$\nS_{\\text{total}} = N \\times \\Delta C\n$$\n代入给定值 $N = 7.5 \\times 10^{7}$：\n$$\nS_{\\text{total}} = (7.5 \\times 10^{7}) \\times 1 = 7.5 \\times 10^{7}\n$$\n\n问题要求答案四舍五入到四位有效数字。计算出的值是精确的。为了用四位有效数字表示 $7.5 \\times 10^7$，我们将其写为 $7.500 \\times 10^7$。",
            "answer": "$$\\boxed{7.500 \\times 10^7}$$"
        },
        {
            "introduction": "并非所有看似等价的变换都是普适安全的。这个实践  探讨了一个经典的陷阱：用算术右移代替有符号整数除以二。你将发现这种优化在哪些特定输入下会失败，并学习如何设计一种“受保护的”模式，仅在语义正确时才应用该优化，这是编写健壮编译器的一项关键技能。",
            "id": "3662235",
            "problem": "一个窥孔优化器考虑在固定的字宽 $w \\ge 2$ 的有符号二进制补码整数上，用算术右移一位（$x \\gg 1$）来替换整数除以二（$x / 2$）。目标机器将算术右移定义为符号传播：将一个有符号整数 $x$ 右移一位，会丢弃最低有效位，并将符号位复制到最高有效位，从而得到一个新值。源语言将有符号整数除以二定义为向零截断：对于任何有符号整数 $x$，表达式 $x / 2$ 计算出唯一的整数 $\\mathrm{trunc}(x/2)$，其绝对值为 $\\lfloor |x/2| \\rfloor$ 的向下取整，其符号与 $x$ 的符号相同。假设 $x$ 的定义域是所有 $w$ 位有符号二进制补码整数，即 $x \\in \\{-2^{w-1}, -2^{w-1}+1, \\dots, 2^{w-1}-1\\}$，并且机器对该定义域中的所有值都能正确实现算术右移。\n\n根据这些定义，完成以下任务：\n\n1. 推导一个关于 $x$ 的精确条件，在该条件下 $x / 2$ 和 $x \\gg 1$ 的语义一致，并推导一个互补条件，在该条件下它们的语义不一致。用至少一个明确的 $x$ 的反例值来证明这种不一致性。\n\n2. 提出一个带守卫的窥孔重写模式，仅当指令流中的一个局部证明在使用点确定 $x \\ge 0$ 时，才应用替换 $x / 2 \\mapsto x \\gg 1$。用一个对于窥孔优化器而言语法上可用的支配性比较来描述这个守卫（不需要全局数据流），并解释为什么这个守卫能保持语义。\n\n3. 假设 $x$ 在所有 $w$ 位有符号整数上均匀分布。计算在所有 $x$ 的值中，无守卫的替换 $x / 2 \\mapsto x \\gg 1$ 会改变程序结果的精确比例，表示为一个最简有理数。在你的最终分数中不要使用百分号。\n\n你的最终答案必须是一个实数或一个闭式解析表达式。无需进行四舍五入。",
            "solution": "该问题要求分析有符号二进制补码整数中，整数除以二与算术右移一位之间的语义等价性。我们必须首先验证问题陈述。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   操作1：整数除以二，记为 $x / 2$。其语义定义为向零截断，即 $\\mathrm{trunc}(x/2)$。对于任何有符号整数 $x$，这会产生一个唯一的整数，其绝对值为 $\\lfloor |x/2| \\rfloor$，其符号与 $x$ 的符号相同。\n-   操作2：算术右移一位，记为 $x \\gg 1$。其语义定义为丢弃最低有效位，并将符号位复制到最高有效位位置。\n-   整数表示：固定字宽 $w \\ge 2$ 的有符号二进制补码整数。\n-   $x$ 的定义域：所有 $w$ 位有符号整数的集合，即 $\\{ -2^{w-1}, -2^{w-1}+1, \\dots, 2^{w-1}-1 \\}$。\n-   假设：目标机器对指定定义域中的所有值都能正确实现算术右移。\n-   任务1：推导 $x / 2$ 和 $x \\gg 1$ 语义一致与不一致的条件，并为不一致的情况提供一个反例。\n-   任务2：提出一个使用局部可用的支配性比较来确保 $x \\ge 0$ 的带守卫的窥孔优化。\n-   任务3：对于在定义域上均匀分布的 $x$，计算无守卫的替换 $x / 2 \\mapsto x \\gg 1$ 会导致错误的精确比例。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是编译器构造和计算机体系结构中的一个标准主题。所提供的关于二进制补码算术、整数除法语义（向零截断）和算术右移的定义是标准且明确的。问题是自包含的，提供了所有必要的信息。约束条件（$w \\ge 2$）是合理的。问题是客观且适定的，能够导出一个唯一且可验证的解。没有矛盾、事实错误或无法验证的主张。\n\n**步骤3：结论与行动**\n该问题是**有效的**。将提供完整的解答。\n\n### 解答推导\n\n首先，我们必须精确地形式化这两种操作的数学行为。在二进制补码整数 $x$ 上进行算术右移一位的标准定义是，它计算 $x$ 除以 $2$ 的向下取整。即 $x \\gg 1 \\equiv \\lfloor x/2 \\rfloor$。编程语言的除法 $x / 2$ 定义为向零截断，可以分段表示为：\n$$\n\\mathrm{trunc}(v) =\n\\begin{cases}\n    \\lfloor v \\rfloor  \\text{if } v \\ge 0 \\\\\n    \\lceil v \\rceil  \\text{if } v  0\n\\end{cases}\n$$\n因此，$x / 2 \\equiv \\mathrm{trunc}(x/2)$。\n\n**1. 一致与不一致的条件**\n\n我们寻求 $x \\gg 1$ 和 $x / 2$ 等价时 $x$ 所需满足的条件。这意味着要找出何时 $\\lfloor x/2 \\rfloor = \\mathrm{trunc}(x/2)$。\n\n情况1：$x \\ge 0$\n对于任何非负数 $x$，$x/2 \\ge 0$。对于非负值，$\\mathrm{trunc}$ 的定义是 $\\mathrm{trunc}(v) = \\lfloor v \\rfloor$。\n因此，对于 $x \\ge 0$，我们有 $\\mathrm{trunc}(x/2) = \\lfloor x/2 \\rfloor$。\n在这种情况下，$x / 2$ 和 $x \\gg 1$ 的语义总是一致的。\n\n情况2：$x  0$\n对于任何负数 $x$，$x/2  0$。对于负值，$\\mathrm{trunc}$ 的定义是 $\\mathrm{trunc}(v) = \\lceil v \\rceil$。\n等价条件变为 $\\lfloor x/2 \\rfloor = \\lceil x/2 \\rceil$。\n一个数的向下取整和向上取整相等，当且仅当这个数是整数。因此，当且仅当 $x/2$ 是一个整数时，这两个操作的结果一致。这又当且仅当 $x$ 是一个偶数时成立。\n当 $\\lfloor x/2 \\rfloor \\neq \\lceil x/2 \\rceil$ 时，操作结果不一致，这发生于当且仅当 $x/2$ 不是一个整数时。这又当且仅当 $x$ 是一个奇数时成立。\n\n条件总结：\n-   **一致**：如果 $x \\ge 0$，或者 $x$ 是一个负偶数，$x/2$ 和 $x \\gg 1$ 的语义一致。\n-   **不一致**：如果 $x$ 是一个负奇数，则语义不一致。\n\n为了展示不一致的情况，我们提供一个反例。设 $x = -3$。\n-   语言定义的除法：$x / 2 = \\mathrm{trunc}(-3/2) = \\mathrm{trunc}(-1.5) = -1$。\n-   算术右移：$x \\gg 1 = \\lfloor -3/2 \\rfloor = \\lfloor -1.5 \\rfloor = -2$。\n显然，$-1 \\neq -2$，这展示了语义上的差异。\n\n**2. 带守卫的窥孔重写模式**\n\n基于以上分析，如果可以证明 $x \\ge 0$，则替换 $x / 2 \\mapsto x \\gg 1$ 是保持语义的。窥孔优化器可以使用一个守卫来强制执行此条件。在编译后的代码中，一个常见的场景是测试变量符号的 `if` 语句。这会生成一条比较指令，后跟一条条件分支指令。\n\n考虑与 `if (x >= 0) { y = x / 2; }` 对应的机器指令序列。它可能被编译为：\n`CMP x, #0`  (将寄存器 `x` 与立即数 $0$ 进行比较)\n`JL is_negative` (如果小于则跳转到另一个代码块)\n`...`\n`DIV x, #2` (整数除法，结果存入 `x`)\n`...`\n`is_negative:`\n`...`\n\n审查 `DIV` 指令的窥孔优化器可以向后查看指令流。如果它找到一个在前的 `CMP x, #0` 指令，并确定当前基本块只有在满足“大于或等于”条件时（即 `JL` 分支未被执行）才可达，那么它就得到了在除法执行点 $x \\ge 0$ 的局部证明。\n\n**带守卫的窥孔重写模式**如下：\n-   **模式**：识别一个除以 $2$ 的除法（`DIV reg, #2`）。\n-   **守卫**：在窥孔窗口内向后扫描，寻找一个 `CMP reg, #0` 指令，且该指令未被任何修改 `reg` 的中间指令所无效化。验证通往 `DIV` 指令的控制流保证了在比较时 $reg \\ge 0$ 的条件已满足。\n-   **替换**：如果守卫条件满足，则将 `DIV reg, #2` 指令替换为更快的 `SAR reg, #1`（算术右移 $1$ 位）指令。\n\n这个守卫保持了语义，因为如第一部分所证明，对于所有 $x \\ge 0$，$\\mathrm{trunc}(x/2) = \\lfloor x/2 \\rfloor$。守卫确保了等价条件得到满足，从而使该优化是安全的。\n\n**3. 不一致值的比例**\n\n我们需要计算对于 $w$ 位有符号整数，无守卫替换会导致错误结果的比例。这对应于 $x/2 \\neq x \\gg 1$ 的值的集合，我们已确定其为负奇数集合。\n\n$w$ 位整数的不同值的总数是 $2^w$。\n有符号二进制补码整数的定义域是 $\\{ -2^{w-1}, \\dots, -1, 0, 1, \\dots, 2^{w-1}-1 \\}$。\n-   非负整数（从 $0$ 到 $2^{w-1}-1$）的数量是 $2^{w-1}$。\n-   负整数（从 $-2^{w-1}$ 到 $-1$）的数量是 $-1 - (-2^{w-1}) + 1 = 2^{w-1}$。\n\n我们需要计算在这 $2^{w-1}$ 个负整数中有多少是奇数。一个整数是奇数当且仅当其最低有效位（`LSB`）是 $1$。一个整数是偶数当且仅当其 `LSB` 是 $0$。在任何 $N$ 个连续整数的范围内，如果 $N$ 是偶数，则恰好有 $N/2$ 个奇数和 $N/2$ 个偶数。\n从 $-2^{w-1}$ 到 $-1$ 的负整数范围包含 $2^{w-1}$ 个连续整数。由于问题指定 $w \\ge 2$，负整数的数量 $2^{w-1}$ 是一个偶数（因为 $2^{2-1}=2$, $2^{3-1}=4$ 等）。\n因此，负奇数的数量恰好是负整数总数的一半。\n\n负奇数的数量 = $\\frac{1}{2} \\times (\\text{负整数的数量}) = \\frac{1}{2} \\times 2^{w-1} = 2^{w-2}$。\n\n替换不正确的值所占的比例，是结果不一致的值的数量与总值的数量之比。\n$$\n\\text{比例} = \\frac{\\text{负奇数的数量}}{\\text{整数总数}} = \\frac{2^{w-2}}{2^w} = 2^{w-2-w} = 2^{-2} = \\frac{1}{4}\n$$\n这个分数 $\\frac{1}{4}$ 与字宽 $w$ 无关（只要 $w \\ge 2$）。\n因此，对于一个均匀分布的 $w$ 位有符号整数，将除以二的操作无守卫地替换为算术右移，有 $25\\%$ 的概率会产生不正确的结果。",
            "answer": "$$\n\\boxed{\\frac{1}{4}}\n$$"
        },
        {
            "introduction": "适用于实数的代数恒等式在计算机算术的世界里可能会失效。这最后一个练习  深入探讨了 IEEE 754 浮点数的微妙之处，特别是带符号零的概念如何让简单的代数规则 `x - x = 0` 失效。通过分析这个看似无害的优化所带来的后果，你将更深刻地体会到在优化浮点代码时所需的审慎。",
            "id": "3662197",
            "problem": "一个编译器执行窥孔优化，根据一个标准的代数恒等式重写相同的减法模式：当它能证明两个操作数是相同的值且表达式没有副作用时，它会将 $x - x$ 的中间表示替换为浮点字面量 $0.0$。目标架构实现了带有符号零的电气和电子工程师协会 (IEEE) 754 binary64 算术，并且活动的舍入模式是“朝负无穷大舍入”。假设语言规定字面量 $0.0$ 表示 $+0.0$。\n\n考虑以下两个计算\n$$f(x) = \\frac{1.0}{x - x} \\quad \\text{和} \\quad g(x) = \\frac{1.0}{0.0},$$\n其中 $g$ 是对 $f$ 应用窥孔优化的结果。设 $x$ 是有限值 $x = 1.0$。定义符号映射 $\\operatorname{sgn}_{\\infty}(y)$：当 $y$ 的求值结果为 $+\\infty$ 时为 $+1$，当 $y$ 的求值结果为 $-\\infty$ 时为 $-1$，其他情况下为 $0$。在所述的舍入模式以及 IEEE 754 关于带符号零和除以零的规则下，计算单一数值\n$$\\operatorname{sgn}_{\\infty}\\!\\big(f(1.0)\\big) - \\operatorname{sgn}_{\\infty}\\!\\big(g(1.0)\\big).$$\n除了精确算术外，不需要进行其他舍入，也不涉及任何物理单位。请将最终答案表示为单个实数。",
            "solution": "题目要求计算数值 $\\operatorname{sgn}_{\\infty}\\!\\big(f(1.0)\\big) - \\operatorname{sgn}_{\\infty}\\!\\big(g(1.0)\\big)$，其中函数 $f(x)$ 和 $g(x)$ 定义如下\n$$f(x) = \\frac{1.0}{x - x}$$\n$$g(x) = \\frac{1.0}{0.0}$$\n函数 $g(x)$ 表示对 $f(x)$ 应用编译器窥孔优化的结果。计算是在电气和电子工程师协会 (IEEE) 754 binary64 算术规则下进行的，舍入模式设置为“朝负无穷大舍入”。\n\n首先，我们必须对 $f(1.0)$ 求值。\n$$f(1.0) = \\frac{1.0}{1.0 - 1.0}$$\n此次求值的关键部分是分母 $1.0 - 1.0$。在 IEEE 754 算术中，减法 $a - b$ 定义为加法 $a + (-b)$。这里，我们计算的是 $1.0 + (-1.0)$。两个操作数 $1.0$ 和 $-1.0$ 符号相反，它们的数学和恰好为零。\n\nIEEE 754 标准规定了结果恰好为零时的符号。根据 IEEE 754-2008 标准的第 6.3 节，当两个符号相反的操作数之和恰好为零时，在所有舍入模式下，和的符号都是正的 ($+0.0$)，*除了*“朝负无穷大舍入”模式。在“朝负无穷大舍入”模式（也称为 `FE_DOWNWARD`）下，精确零和的符号是负的 ($-0.0$)。\n\n鉴于题目明确指出活动的舍入模式是“朝负无穷大舍入”，表达式 $1.0 - 1.0$ 的求值结果为 $-0.0$。\n因此，$f(1.0)$ 的求值过程如下：\n$$f(1.0) = \\frac{1.0}{-0.0}$$\nIEEE 754 标准定义了除以零的运算。一个有限非零数除以一个带符号的零，结果是一个带符号的无穷大。具体来说，一个正数（如 $1.0$）除以负零 ($-0.0$) 会得到负无穷大 ($-\\infty$)。\n因此，$f(1.0) = -\\infty$。\n\n接下来，我们对 $g(1.0)$ 求值。\n函数 $g(x)$ 是编译器窥孔优化的结果，该优化将表达式 $x - x$ 替换为浮点字面量 $0.0$。题目说明中规定，该语言将字面量 $0.0$ 视为正零 ($+0.0$)。\n因此，表达式的分母被替换，得到：\n$$g(1.0) = \\frac{1.0}{0.0} = \\frac{1.0}{+0.0}$$\n根据 IEEE 754 关于除以零的规则，一个正数 ($1.0$) 除以正零 ($+0.0$) 会得到正无穷大 ($+\\infty$)。\n因此，$g(1.0) = +\\infty$。\n\n现在我们可以应用符号映射函数 $\\operatorname{sgn}_{\\infty}(y)$，其定义如下：\n$$ \\operatorname{sgn}_{\\infty}(y) = \\begin{cases} +1  \\text{if } y = +\\infty \\\\ -1  \\text{if } y = -\\infty \\\\ 0  \\text{otherwise} \\end{cases} $$\n将此函数应用于我们的结果：\n对于 $f(1.0) = -\\infty$，我们有 $\\operatorname{sgn}_{\\infty}\\!\\big(f(1.0)\\big) = \\operatorname{sgn}_{\\infty}(-\\infty) = -1$。\n对于 $g(1.0) = +\\infty$，我们有 $\\operatorname{sgn}_{\\infty}\\!\\big(g(1.0)\\big) = \\operatorname{sgn}_{\\infty}(+\\infty) = +1$。\n\n最后，我们计算所要求的差值：\n$$ \\operatorname{sgn}_{\\infty}\\!\\big(f(1.0)\\big) - \\operatorname{sgn}_{\\infty}\\!\\big(g(1.0)\\big) = (-1) - (+1) = -1 - 1 = -2 $$\n这个结果凸显了编译器设计中的一个关键问题：一个看似正确的代数优化 ($x-x=0$) 在所有浮点舍入模式下并非与原始表达式语义等价，从而导致程序行为的改变。该优化未能保留零的符号，这在后续的除法等运算中会产生可观察到的后果。",
            "answer": "$$\n\\boxed{-2}\n$$"
        }
    ]
}