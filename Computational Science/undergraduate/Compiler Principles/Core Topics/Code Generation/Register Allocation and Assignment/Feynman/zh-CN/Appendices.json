{
    "hands_on_practices": [
        {
            "introduction": "寄存器分配可以优雅地建模为图着色问题，但当颜色（寄存器）数量不足时会发生什么？这种情况迫使编译器将一些变量“溢出”到内存中，这是一个代价高昂的操作。此练习  将让你深入这一关键决策过程，展示不同的溢出启发式策略——一种基于成本，另一种基于图结构——如何显著影响生成代码的效率。\n\n通过这个练习，你将亲手体验在资源受限的情况下，算法决策如何直接影响最终的性能，从而更深刻地理解编译器优化的复杂性。",
            "id": "3666504",
            "problem": "考虑通过干涉图着色进行寄存器分配，可用机器寄存器数量为 $K=3$ 个。干涉图通过标准存活分析构建，其顶点代表存活范围 $v_a, v_b, v_c, v_d, v_e, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}$ 和 $v_{y_3}$。邻接关系定义如下：\n\n- 由 $\\{v_a, v_b, v_c, v_d\\}$ 导出的子图是一个完全图 $K_4$，即 $v_a, v_b, v_c$ 和 $v_d$ 中的每一个都与另外三个干涉。\n- 顶点 $v_e$ 与 $v_a, v_b, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}$ 和 $v_{y_3}$ 干涉。\n- 顶点集 $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ 和 $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ 构成一个完全二分子图 $K_{3,3}$：对于所有 $i \\in \\{1,2,3\\}$ 和 $j \\in \\{1,2,3\\}$，$v_{x_i}$ 与 $v_{y_j}$ 干涉。除上述说明外，没有其他干涉。\n\n假设没有预着色顶点，不进行合并操作，也不进行存活范围分裂。一次溢出产生一个标量代价 $c(v)$，该代价线性地累加到总溢出代价中。各顶点的溢出代价为：\n$c(v_a)=7$, $c(v_b)=6$, $c(v_c)=5$, $c(v_d)=1$, $c(v_e)=9$, 以及 $c(v_{x_1})=c(v_{x_2})=c(v_{x_3})=c(v_{y_1})=c(v_{y_2})=c(v_{y_3})=3$。\n\n当没有顶点的度严格小于 $K$ 时，使用以下两种确定性启发式算法来选择溢出候选：\n\n- 启发式算法 $\\mathcal{H}_{\\text{cost}}$：选择溢出代价 $c(v)$ 最小的顶点。若存在多个，则按顶点名称的字母顺序选择。\n- 启发式算法 $\\mathcal{H}_{\\text{degree}}$：选择当前干涉图中度最大的顶点。若存在多个，则按顶点名称的字母顺序选择。\n\n在每一步，如果任何顶点的度严格小于 $K$，则该顶点可以被简化（压入栈中）而不是被溢出；否则，根据启发式算法溢出一个顶点，将其从图中移除，然后重复此过程。当剩余的图变为 $K$-可着色时，分配过程继续进行，不再发生更多溢出。忽略除 $c(v)$ 之外的任何运行时成本，并假设每个溢出的顶点恰好将其代价 $c(v)$ 加到总代价中一次。\n\n对于所描述的图和代价，计算在 $\\mathcal{H}_{\\text{degree}}$ 下得到的总溢出代价与在 $\\mathcal{H}_{\\text{cost}}$ 下得到的总溢出代价之间的差值 $\\Delta$，其中\n$$\n\\Delta = \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) - \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}}).\n$$\n请以单个实数值形式提供最终答案。无需四舍五入。",
            "solution": "为了解决这个问题，我们首先需要计算干涉图中每个顶点的初始度数。可用寄存器数量为 $K=3$。\n\n**第 1 步：计算初始度数**\n- $\\text{deg}(v_a)$: 与 $\\{v_b, v_c, v_d\\}$ (来自 $K_4$) 和 $v_e$ 相邻。所以，$\\text{deg}(v_a) = 4$。\n- $\\text{deg}(v_b)$: 与 $\\{v_a, v_c, v_d\\}$ (来自 $K_4$) 和 $v_e$ 相邻。所以，$\\text{deg}(v_b) = 4$。\n- $\\text{deg}(v_c)$: 与 $\\{v_a, v_b, v_d\\}$ (来自 $K_4$) 相邻。所以，$\\text{deg}(v_c) = 3$。\n- $\\text{deg}(v_d)$: 与 $\\{v_a, v_b, v_c\\}$ (来自 $K_4$) 相邻。所以，$\\text{deg}(v_d) = 3$。\n- $\\text{deg}(v_e)$: 与 $\\{v_a, v_b, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$ 相邻。所以，$\\text{deg}(v_e) = 8$。\n- 对于 $i \\in \\{1,2,3\\}$，$\\text{deg}(v_{x_i})$: 与 $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ (来自 $K_{3,3}$) 和 $v_e$ 相邻。所以，$\\text{deg}(v_{x_i}) = 4$。\n- 对于 $j \\in \\{1,2,3\\}$，$\\text{deg}(v_{y_j})$: 与 $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ (来自 $K_{3,3}$) 和 $v_e$ 相邻。所以，$\\text{deg}(v_{y_j}) = 4$。\n\n**第 2 步：使用启发式算法 $\\mathcal{H}_{\\text{cost}}$ 进行分析**\n\n1.  **初始状态**：所有顶点的度都 $\\ge K=3$。因此，没有顶点可以被简化。初始图 $G_0$ 本身包含一个 $K_4$ 子图（在 $\\{v_a, v_b, v_c, v_d\\}$ 上），因此它不是 3-可着色的。我们必须溢出一个顶点。\n2.  **选择溢出顶点**：$\\mathcal{H}_{\\text{cost}}$ 选择溢出代价最小的顶点。在所有顶点中，$c(v_d)=1$ 是最低的。因此，我们溢出 $v_d$。\n    - **总溢出代价**: $1$。\n3.  **更新图并简化**：移除 $v_d$ 后，我们得到新图 $G_1$。$v_d$ 的邻居（$v_a, v_b, v_c$）的度数各减 1。\n    - $\\text{deg}_{G_1}(v_a)=3$, $\\text{deg}_{G_1}(v_b)=3$, $\\text{deg}_{G_1}(v_c)=2$。\n    - 由于 $\\text{deg}_{G_1}(v_c) = 2  3$，我们可以简化 $v_c$。\n    - 简化 $v_c$ 后，其邻居（$v_a, v_b$）的度数再减 1，变为 $\\text{deg}(v_a)=2$ 和 $\\text{deg}(v_b)=2$。\n    - 现在 $v_a$ 和 $v_b$ 都可以被简化。\n4.  **检查剩余图**：在简化 $v_c, v_a, v_b$ 之后，剩余的图由顶点 $\\{v_e, v_{x_1}, \\dots, v_{y_3}\\}$ 组成。这个子图的结构是 $v_e$ 连接到一个 $K_{3,3}$ 图的所有顶点。这个图是 3-可着色的：为 $v_e$ 分配颜色 1，为 $K_{3,3}$ 的一个划分（例如 $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$）分配颜色 2，为另一个划分（$\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$）分配颜色 3。\n5.  **结论**：由于剩余的图是 3-可着色的，我们停止溢出。$\\mathcal{H}_{\\text{cost}}$ 的总溢出代价是 $c(v_d) = 1$。\n\n**第 3 步：使用启发式算法 $\\mathcal{H}_{\\text{degree}}$ 进行分析**\n\n1.  **初始状态**：和之前一样，没有顶点可以被简化，且图不是 3-可着色的。我们必须溢出一个顶点。\n2.  **选择溢出顶点**：$\\mathcal{H}_{\\text{degree}}$ 选择度最大的顶点。$\\text{deg}(v_e)=8$ 是唯一的最大值。因此，我们溢出 $v_e$。\n    - **总溢出代价**: $c(v_e) = 9$。\n3.  **更新图**：移除 $v_e$ 后，我们得到新图 $G_1$。$v_e$ 的所有邻居的度数各减 1。\n    - $\\text{deg}_{G_1}(v_a)=3$, $\\text{deg}_{G_1}(v_b)=3$, $\\text{deg}_{G_1}(v_c)=3$, $\\text{deg}_{G_1}(v_d)=3$。\n    - $\\text{deg}_{G_1}(v_{x_i})=3$, $\\text{deg}_{G_1}(v_{y_j})=3$。\n    - 在 $G_1$ 中，所有顶点的度数都是 3。没有顶点可以被简化。\n4.  **检查可着色性并再次溢出**：$G_1$ 仍然包含 $K_4$ 子图，因此不是 3-可着色的。我们必须再次溢出。由于所有顶点的度都是 3，我们根据字母顺序打破平局。第一个顶点是 $v_a$。我们溢出 $v_a$。\n    - **总溢出代价**: $c(v_e) + c(v_a) = 9 + 7 = 16$。\n5.  **更新图并简化**：移除 $v_a$ 后，得到 $G_2$。$v_a$ 的邻居（$v_b, v_c, v_d$）的度数减 1，变为 2。现在它们都可以被简化。\n6.  **检查剩余图**：在简化 $v_b, v_c, v_d$ 之后，剩余的图是 $K_{3,3}$，它是一个二分图，因此是 2-可着色的（也是 3-可着色的）。\n7.  **结论**：我们停止溢出。$\\mathcal{H}_{\\text{degree}}$ 的总溢出代价是 $16$。\n\n**第 4 步：计算差值**\n\n$$ \\Delta = \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) - \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}}) = 16 - 1 = 15 $$",
            "answer": "$$\n\\boxed{15}\n$$"
        },
        {
            "introduction": "一个理想的编译器不仅要分配寄存器，还要通过称为“合并”的过程来消除不必要的指令，例如多余的 `move` 指令。然而，优化决策很少是简单的。此练习  探讨了一种引人入胜的权衡：有策略地溢出某个变量虽然本身有代价，但却可能简化冲突图，从而通过指令合并获得更大的收益。\n\n这个场景要求你进行仔细的成本效益分析，揭示了编译器优化中局部与全局考量的微妙之处。",
            "id": "3666563",
            "problem": "考虑一个编译器寄存器分配阶段中的单一直线型基本块，该基本块使用冲突图进行抽象。你有 $k = 3$ 个可分配的通用寄存器。该基本块有临时变量 $a, b, c, d, s$。冲突图 $G$ 的顶点集为 $\\{a,b,c,d,s\\}$，其无向边为\n$$(a,c),\\ (a,d),\\ (a,s),\\ (b,c),\\ (b,d),\\ (b,s),\\ (c,s),\\ (d,s)。$$\n恰好有 $2$ 条符合合并条件的复制（传送）指令：一条是 $a \\rightarrow b$，另一条是 $c \\rightarrow d$。根据构造，$a$ 和 $b$ 之间没有冲突边，$c$ 和 $d$ 之间也没有冲突边。\n\n该分配器使用 Briggs 提出的、经过充分测试的保守复制合并规则：一条传送指令 $x \\rightarrow y$ 可以被合并，当且仅当 $x$ 和 $y$ 不冲突，并且在假设合并 $x$ 和 $y$ 之后，它们所有邻居中在图 $G$ 里度数不小于 $k$ 的节点的并集，其基数严格小于 $k$。如果测试失败，则该传送指令不能被合并。\n\n假设选择溢出一个临时变量，会在运行合并之前从冲突图中移除其节点和所有关联的边。你只被允许考虑两种方案：\n- 方案 $A$：不溢出任何临时变量；在保守规则下尝试合并传送指令。\n- 方案 $B$：溢出临时变量 $s$；然后在保守规则下尝试合并传送指令。\n\n在此基本块中溢出 $s$ 会产生如下的归一化溢出延迟：$s$ 有 $1$ 个定义必须被存储（store），以及 $2$ 个使用点必须被重载（reload），每次内存操作的成本为 $1$（单位与计算剩余传送指令数量的单位相同）。因此，溢出延迟为 $spill\\_lat = 3$。如果不执行溢出操作，则 $spill\\_lat = 0$。\n\n定义目标函数为\n$$\\text{cost} \\;=\\; spill\\_lat \\;+\\; moves,$$\n其中 $moves$ 是在所选方案下应用保守合并后剩余的传送指令数量，$spill\\_lat$ 如上文规定。计算这两个方案中可实现的最小成本，并将其报告为一个实数值。不需要四舍五-入，也不使用物理单位。",
            "solution": "为了找到最小成本，我们分别计算方案A和方案B的成本。成本函数为 $\\text{cost} = spill\\_lat + moves$，其中 $k=3$。\n\n#### 方案 A 分析：不溢出\n\n在此方案中，我们使用初始冲突图 $G$。溢出延迟 $spill\\_lat_A = 0$。\n\n**1. 计算初始度数**\n- $\\text{deg}(a) = |\\{c, d, s\\}| = 3$\n- $\\text{deg}(b) = |\\{c, d, s\\}| = 3$\n- $\\text{deg}(c) = |\\{a, b, s\\}| = 3$\n- $\\text{deg}(d) = |\\{a, b, s\\}| = 3$\n- $\\text{deg}(s) = |\\{a, b, c, d\\}| = 4$\n\n度数不小于 $k=3$ 的节点集合为 $\\{a, b, c, d, s\\}$。\n\n**2. 应用保守合并规则**\n\n- **考虑传送指令 $a \\rightarrow b$：**\n  - $a$ 和 $b$ 的邻居并集为 $N(a) \\cup N(b) = \\{c, d, s\\}$。\n  - 在这个邻居并集中，度数不小于 $k=3$ 的节点有 $c$ ($\\text{deg}=3$), $d$ ($\\text{deg}=3$), 和 $s$ ($\\text{deg}=4$)。\n  - 这些节点的数量为 3。\n  - Briggs 规则要求这个数量严格小于 $k$。我们检查 $3  3$，此条件不成立。\n  - 因此，传送指令 $a \\rightarrow b$ **不能**被合并。\n\n- **考虑传送指令 $c \\rightarrow d$：**\n  - $c$ 和 $d$ 的邻居并集为 $N(c) \\cup N(d) = \\{a, b, s\\}$。\n  - 在这个邻居并集中，度数不小于 $k=3$ 的节点有 $a$ ($\\text{deg}=3$), $b$ ($\\text{deg}=3$), 和 $s$ ($\\text{deg}=4$)。\n  - 这些节点的数量为 3。\n  - 我们检查 $3  3$，此条件不成立。\n  - 因此，传送指令 $c \\rightarrow d$ **不能**被合并。\n\n**3. 计算方案 A 成本**\n- 剩余传送指令数量 $moves_A = 2$。\n- 方案 A 的总成本：$\\text{cost}_A = spill\\_lat_A + moves_A = 0 + 2 = 2$。\n\n#### 方案 B 分析：溢出临时变量 $s$\n\n在此方案中，我们首先溢出 $s$，产生溢出成本 $spill\\_lat_B = 3$。这会从图中移除节点 $s$ 及其所有边。\n\n**1. 计算新图 $G'$ 的度数**\n- 新图 $G'$ 的顶点集为 $\\{a, b, c, d\\}$。\n- 与 $s$ 相关的边被移除后，每个剩余顶点的度数都减少了 1。\n- $\\text{deg}_{G'}(a) = 2$\n- $\\text{deg}_{G'}(b) = 2$\n- $\\text{deg}_{G'}(c) = 2$\n- $\\text{deg}_{G'}(d) = 2$\n- 现在，图中没有度数不小于 $k=3$ 的节点。\n\n**2. 应用保守合并规则**\n\n- **考虑传送指令 $a \\rightarrow b$：**\n  - 在 $G'$ 中，$a$ 和 $b$ 的邻居并集为 $N_{G'}(a) \\cup N_{G'}(b) = \\{c, d\\}$。\n  - 在这个邻居并集中，度数不小于 $k=3$ 的节点数量为 0。\n  - 我们检查 $0  3$，此条件成立。\n  - 因此，传送指令 $a \\rightarrow b$ **可以**被合并。\n\n- **考虑传送指令 $c \\rightarrow d$：**\n  - 在 $G'$ 中，$c$ 和 $d$ 的邻居并集为 $N_{G'}(c) \\cup N_{G'}(d) = \\{a, b\\}$。\n  - 在这个邻居并集中，度数不小于 $k=3$ 的节点数量为 0。\n  - 我们检查 $0  3$，此条件成立。\n  - 因此，传送指令 $c \\rightarrow d$ **可以**被合并。\n\n**3. 计算方案 B 成本**\n- 两个传送指令都被消除了，所以剩余传送指令数量 $moves_B = 0$。\n- 方案 B 的总成本：$\\text{cost}_B = spill\\_lat_B + moves_B = 3 + 0 = 3$。\n\n#### 结论\n\n比较两种方案的成本：\n- $\\text{cost}_A = 2$\n- $\\text{cost}_B = 3$\n\n可实现的最小成本是 $\\min(\\text{cost}_A, \\text{cost}_B) = \\min(2, 3) = 2$。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "在寄存器分配的最后阶段，编译器常常面临同时执行多个赋值操作的挑战，例如 $r_1 := r_2$ 和 $r_2 := r_1$。这种“并行复制”问题无法通过简单的顺序执行机器指令来天真地解决。此练习  将引导你学习解决此任务的标准且最优的算法，该算法将赋值操作视为一个置换，并使用临时寄存器来解决循环依赖。\n\n掌握这种技术对于理解现代编译器如何将高级别的分配决策转化为正确高效的机器代码至关重要。",
            "id": "3661148",
            "problem": "编译器后端必须解决在静态单赋值（SSA）形式的寄存器分配过程中出现的并行复制问题。并行复制的语义是所有赋值同时发生：对于集合中的每一个赋值 $d := s$，目标寄存器 $d$ 在复制后的值必须等于任何赋值执行前源寄存器 $s$ 中的值。机器只提供 $x := y$ 形式的简单移动指令，而没有交换或循环移位指令。在解决过程中，允许使用一个临时寄存器来保留值。\n\n考虑机器寄存器 $r_1, r_2, \\dots, r_{10}$ 和以下并行复制，它被指定为一组目标-源赋值：\n- $r_1 := r_4$\n- $r_4 := r_1$\n- $r_2 := r_5$\n- $r_5 := r_7$\n- $r_7 := r_2$\n- $r_3 := r_9$\n- $r_9 := r_6$\n- $r_6 := r_3$\n- $r_8 := r_8$\n- $r_{10} := r_{10}$\n\n任务：\n1. 从并行复制语义的基本原理出发，论证为何这组赋值定义了寄存器上的一个带有若干不动点的排列，并将该排列分解为不相交的循环和不動點。\n2. 对每个长度大于 $1$ 的非平凡循环，设计一个最优的顺序移动序列，该序列对该循环只使用一个临时寄存器，并保留并行复制的语义。从基本推理出发，证明每个循环的移动次数是最优的。\n3. 计算你的最优方案为实现整个并行复制所产生的移动指令的最小总数。你最终提交的答案必须是这个单一整数，不带单位，也不进行四舍五入。",
            "solution": "要解决此问题，我们首先将并行复制操作建模为一个排列，然后将其分解为不相交的循环。接着，我们计算实现每个循环所需的最小移动次数，最后将它们相加得到总数。\n\n**第 1 步：将赋值分解为不相交循环**\n\n并行复制 $d_i := s_i$ 可以看作一个排列 $\\pi$，其中 $\\pi(s_i) = d_i$。我们通过追踪值的流动来找到循环：\n- 从 $r_1$ 开始：值从 $r_1$ 移到 $r_4$ ($\\pi(r_1) = r_4$)，值从 $r_4$ 移到 $r_1$ ($\\pi(r_4) = r_1$)。这构成了一个长度为 2 的循环：$(r_1, r_4)$。\n- 从 $r_2$ 开始：值从 $r_2$ 移到 $r_7$ ($\\pi(r_2) = r_7$)，值从 $r_7$ 移到 $r_5$ ($\\pi(r_7) = r_5$)，值从 $r_5$ 移到 $r_2$ ($\\pi(r_5) = r_2$)。这构成了一个长度为 3 的循环：$(r_2, r_7, r_5)$。\n- 从 $r_3$ 开始：值从 $r_3$ 移到 $r_6$ ($\\pi(r_3) = r_6$)，值从 $r_6$ 移到 $r_9$ ($\\pi(r_6) = r_9$)，值从 $r_9$ 移到 $r_3$ ($\\pi(r_9) = r_3$)。这构成了一个长度为 3 的循环：$(r_3, r_6, r_9)$。\n- 对于 $r_8$：值从 $r_8$ 移到 $r_8$ ($\\pi(r_8)=r_8$)。这是一个长度为 1 的循环，即不动点：$(r_8)$。\n- 对于 $r_{10}$：值从 $r_{10}$ 移到 $r_{10}$ ($\\pi(r_{10})=r_{10}$)。这也是一个不动点：$(r_{10})$。\n\n排列被分解为不相交循环：$(r_1, r_4)$、$(r_2, r_7, r_5)$、$(r_3, r_6, r_9)$、$(r_8)$ 和 $(r_{10})$。\n\n**第 2 步：计算每个循环的最优移动次数**\n\n- **不动点（长度 $k=1$）**：对于 $r := r$ 这样的赋值，寄存器的值没有改变，因此不需要任何移动指令。移动次数为 0。\n\n- **非平凡循环（长度 $k > 1$）**：一个长度为 $k$ 的循环，例如 $(x_1, x_2, \\dots, x_k)$，表示值从 $x_1 \\to x_2 \\to \\dots \\to x_k \\to x_1$。直接使用顺序移动指令（如 $x_2 := x_1$）会覆盖 $x_2$ 中尚未使用的值。为了打破这种依赖，必须使用一个临时寄存器 $t$。\n  \n  最优策略如下：\n  1.  将循环中一个寄存器的值保存到临时寄存器中（例如, $t := x_1$）。（1 次移动）\n  2.  现在 $x_1$ 是空闲的，我们可以按相反的顺序进行一系列移动来填补空位：$x_1 := x_k, x_k := x_{k-1}, \\dots, x_3 := x_2$。（$k-1$ 次移动）\n  3.  最后，将保存在 $t$ 中的原始值移动到其最终目的地（$x_2$）。（$t$ 里的值是 $x_1$ 的旧值，它需要被移动到 $x_2$）。这一步其实是在步骤2的链式移动的最后。更简单的序列是：\n      1. $t := x_k$ (1 move)\n      2. $x_k := x_{k-1}$, $x_{k-1} := x_{k-2}$, ..., $x_2 := x_1$ (k-1 moves)\n      3. $x_1 := t$ (1 move)\n  \n  总移动次数为 $1 + (k-1) + 1 = k+1$ 次。这个方案是最优的，因为需要 $k$ 次移动来更新 $k$ 个寄存器，并且由于循环依赖，至少需要一次额外的移动（使用临时寄存器）来打破循环。\n\n**第 3 步：计算总移动次数**\n\n我们将每个循环的移动次数相加：\n- 循环 $(r_1, r_4)$（长度 $k=2$）：需要 $2+1 = 3$ 次移动。\n- 循环 $(r_2, r_7, r_5)$（长度 $k=3$）：需要 $3+1 = 4$ 次移动。\n- 循环 $(r_3, r_6, r_9)$（长度 $k=3$）：需要 $3+1 = 4$ 次移动。\n- 不动点 $(r_8)$（长度 $k=1$）：需要 $0$ 次移动。\n- 不动点 $(r_{10})$（长度 $k=1$）：需要 $0$ 次移动。\n\n最小总移动指令数是：\n$$ \\text{Total Moves} = 3 + 4 + 4 + 0 + 0 = 11 $$",
            "answer": "$$ \\boxed{11} $$"
        }
    ]
}