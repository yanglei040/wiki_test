{
    "hands_on_practices": [
        {
            "introduction": "图着色寄存器分配的核心是简化-溢出循环。当干预图无法进一步简化时，编译器必须选择一个临时变量进行溢出。这个选择并非任意，而是一个启发式决策，不同的启发式策略会极大地影响最终性能。 这项练习将让你亲身体验，对于同一个程序，基于溢出成本的启发式（$\\mathcal{H}_{\\text{cost}}$）与基于图论属性（度）的启发式（$\\mathcal{H}_{\\text{degree}}$）是如何导致总溢出成本产生巨大差异的，从而凸显启发式设计在编译器优化中的重要性。",
            "id": "3666504",
            "problem": "考虑通过干涉图着色进行寄存器分配，其中有 $K$ 个可用的机器寄存器，且 $K=3$。干涉图由标准存活分析构建，其顶点表示活跃范围 $v_a$、$v_b$、$v_c$、$v_d$、$v_e$、$v_{x_1}$、$v_{x_2}$、$v_{x_3}$、$v_{y_1}$、$v_{y_2}$ 和 $v_{y_3}$。邻接关系定义如下：\n\n- 由 $\\{v_a, v_b, v_c, v_d\\}$ 导出的子图是一个完全图 $K_4$，即 $v_a$、$v_b$、$v_c$ 和 $v_d$ 中的每一个都与另外三个干涉。\n- 顶点 $v_e$ 与 $v_a$、$v_b$、$v_{x_1}$、$v_{x_2}$、$v_{x_3}$、$v_{y_1}$、$v_{y_2}$ 和 $v_{y_3}$ 干涉。\n- 顶点集 $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ 和 $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ 形成一个完全二分图 $K_{3,3}$：对于所有 $i \\in \\{1,2,3\\}$ 和 $j \\in \\{1,2,3\\}$，$v_{x_i}$ 与 $v_{y_j}$ 干涉。除上述之外没有其他干涉。\n\n假设没有预着色顶点，没有合并，也没有活跃范围分裂。一次溢出会产生一个标量代价 $c(v)$，该代价线性地加到总溢出代价中。每个顶点的溢出代价如下：\n$c(v_a)=7$，$c(v_b)=6$，$c(v_c)=5$，$c(v_d)=1$，$c(v_e)=9$，以及 $c(v_{x_1})=c(v_{x_2})=c(v_{x_3})=c(v_{y_1})=c(v_{y_2})=c(v_{y_3})=3$。\n\n当没有顶点的度数严格小于 $K$ 时，使用以下两种确定性启发式算法来选择溢出候选：\n\n- 启发式算法 $\\mathcal{H}_{\\text{cost}}$：选择溢出代价 $c(v)$ 最小的顶点。若代价相同，则按顶点名称的字母顺序选择。\n- 启发式算法 $\\mathcal{H}_{\\text{degree}}$：选择当前干涉图中度数最大的顶点。若度数相同，则按顶点名称的字母顺序选择。\n\n在每一步中，如果任何顶点的度数严格小于 $K$，则该顶点可以被简化（压入栈中）而不是被溢出；否则，根据启发式算法溢出一个顶点，将其从图中移除，然后重复此过程。当剩余的图变为 $K$-可着色时，分配过程继续进行，不再有更多溢出。忽略除 $c(v)$ 之外的任何运行时代价，并假设每个溢出的顶点恰好贡献其 $c(v)$ 一次给总代价。\n\n对于所述的图和代价，计算在 $\\mathcal{H}_{\\text{degree}}$ 下得到的总溢出代价与在 $\\mathcal{H}_{\\text{cost}}$ 下得到的总溢出代价之间的差值 $\\Delta$，其中\n$$\n\\Delta = \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) - \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}}).\n$$\n请提供一个实数值作为您的最终答案。无需四舍五入。",
            "solution": "用户希望我解决一个寄存器分配问题。\n\n### 第一步：提取已知条件\n- **寄存器数量**：$K=3$。\n- **顶点**：活跃范围集合为 $V = \\{v_a, v_b, v_c, v_d, v_e, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$。\n- **干涉图结构（边）**：\n    1. 由 $\\{v_a, v_b, v_c, v_d\\}$ 导出的子图是一个完全图 $K_4$。\n    2. $v_e$ 与 $v_a, v_b, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}$ 干涉（邻接）。\n    3. 在 $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ 和 $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ 上的子图是一个完全二分图 $K_{3,3}$。\n    4. 除此之外没有其他干涉。\n- **溢出代价**：\n    -   $c(v_a)=7$\n    -   $c(v_b)=6$\n    -   $c(v_c)=5$\n    -   $c(v_d)=1$\n    -   $c(v_e)=9$\n    -   $c(v_{x_1})=c(v_{x_2})=c(v_{x_3})=3$\n    -   $c(v_{y_1})=c(v_{y_2})=c(v_{y_3})=3$\n- **寄存器分配算法**：\n    1. 如果任何顶点的度数严格小于 $K$，则将其简化（压入栈中进行着色）。\n    2. 如果没有顶点可以被简化，则选择一个顶点作为溢出候选并从图中移除。选择基于两种启发式算法之一。\n    3. 重复此过程。\n    4. 当“剩余的图变为 K-可着色时”，该过程停止。\n    5. 溢出的顶点将其代价 $c(v)$ 贡献给总溢出代价。\n- **溢出启发式算法**：\n    - $\\mathcal{H}_{\\text{cost}}$：选择溢出代价 $c(v)$ 最小的顶点。若代价相同，则按字母顺序选择。\n    - $\\mathcal{H}_{\\text{degree}}$：选择度数最大的顶点。若度数相同，则按字母顺序选择。\n- **目标**：计算差值 $\\Delta = \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) - \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}})$。\n\n### 第二步：使用提取的已知条件进行验证\n这个问题有科学依据，植根于编译器中寄存器分配的标准理论。它定义良好，具有完全指定的干涉图、确定性的启发式算法（由于有平局打破规则）和明确的目标。语言客观而精确。所有必要的数据都已提供，没有矛盾。问题是有效的。\n\n### 第三步：进行求解\n\n首先，我们必须确定干涉图的初始状态，特别是每个顶点的度。可用寄存器的总数是 $K=3$。\n- $\\text{deg}(v_a)$：邻居是 $\\{v_b, v_c, v_d\\}$ (来自 $K_4$) 和 $v_e$。所以 $\\text{deg}(v_a) = 4$。\n- $\\text{deg}(v_b)$：邻居是 $\\{v_a, v_c, v_d\\}$ (来自 $K_4$) 和 $v_e$。所以 $\\text{deg}(v_b) = 4$。\n- $\\text{deg}(v_c)$：邻居是 $\\{v_a, v_b, v_d\\}$ (来自 $K_4$)。所以 $\\text{deg}(v_c) = 3$。\n- $\\text{deg}(v_d)$：邻居是 $\\{v_a, v_b, v_c\\}$ (来自 $K_4$)。所以 $\\text{deg}(v_d) = 3$。\n- $\\text{deg}(v_e)$：邻居是 $\\{v_a, v_b, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$。所以 $\\text{deg}(v_e) = 8$。\n- $\\text{deg}(v_{x_i})$ 对于 $i \\in \\{1,2,3\\}$：邻居是 $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ (来自 $K_{3,3}$) 和 $v_e$。所以 $\\text{deg}(v_{x_i}) = 4$。\n- $\\text{deg}(v_{y_j})$ 对于 $j \\in \\{1,2,3\\}$：邻居是 $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ (来自 $K_{3,3}$) 和 $v_e$。所以 $\\text{deg}(v_{y_j}) = 4$。\n\n问题陈述溢出停止的条件是“当剩余的图变为 K-可着色时”。这意味着一个迭代简化的过程，如果我们卡住了（图的“核心”中所有顶点的度数都 $\\ge K$），我们就检查这个核心是否是 K-可着色的。如果是，我们就停止。如果不是，我们就从核心中溢出一个节点，并在新的、更小的图上重复这个过程。\n\n**使用启发式算法 $\\mathcal{H}_{\\text{cost}}$ 进行分析**\n\n1.  **初始图 $G_0$**：所有顶点的度数都 $\\ge K=3$。因此，没有顶点可以被简化。核心就是整个图 $G_0$。\n2.  **可着色性检查**：$G_0$ 是 3-可着色的吗？不是，它包含一个在 $\\{v_a, v_b, v_c, v_d\\}$ 上的 $K_4$ 子图，这至少需要 4 种颜色。\n3.  **溢出**：我们必须从 $G_0$ 中溢出一个顶点。使用 $\\mathcal{H}_{\\text{cost}}$，我们选择溢出代价最小的顶点。\n    - 代价：$c(v_a)=7, c(v_b)=6, c(v_c)=5, c(v_d)=1, c(v_e)=9$，以及 $c(v_x, v_y)=3$。\n    - 最小代价是 $c(v_d)=1$。我们溢出 $v_d$。\n    - **到目前为止的总溢出代价：$1$。**\n4.  **新图 $G_1 = G_0 \\setminus \\{v_d\\}$**：我们在 $G_1$ 上重复此过程。\n    - **简化**：$v_d$ 的邻居（$v_a, v_b, v_c$）的度数减少 1。\n        - $\\text{deg}_{G_1}(v_a)=3$，$\\text{deg}_{G_1}(v_b)=3$，$\\text{deg}_{G_1}(v_c)=2$。\n        - 因为 $\\text{deg}_{G_1}(v_c) = 2  3$，我们简化 $v_c$。移除它和它的边。\n        - 在新图 $G_1 \\setminus \\{v_c\\}$ 中，$v_c$ 的邻居（$v_a, v_b$）的度数减少 1。现在 $\\text{deg}(v_a)=2$ 且 $\\text{deg}(v_b)=2$。\n        - 我们可以简化 $v_a$ 和 $v_b$。我们先简化 $v_a$（按字母顺序）。\n        - 在剩下的图中，$\\text{deg}(v_b)$ 变为 1。我们简化 $v_b$。\n    - **核心**：简化 $v_c, v_a, v_b$ 之后，剩余的图（核心）由顶点 $\\{v_e, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$ 组成。我们将这个核心称为 $G'_{1}$。$G'_{1}$ 中的所有顶点度数都 $\\ge 3$。\n    - **可着色性检查**：$G'_{1}$ 是 3-可着色的吗？\n        - 在 $G'_{1}$ 中，$v_e$ 与所有其他 6 个顶点相连。这 6 个顶点构成一个 $K_{3,3}$。\n        - 要对 $G'_{1}$ 进行 3-着色，我们可以给 $v_e$ 分配一种颜色 $C_1$。然后它的所有邻居必须用剩下的两种颜色 $C_2$ 和 $C_3$ 来着色。\n        - 这当且仅当其邻居导出的子图是 2-可着色（二分图）时才可能。\n        - 由 $\\{v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$ 导出的子图是一个 $K_{3,3}$，它是二分图。我们可以用 $C_2$ 对 $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ 进行着色，用 $C_3$ 对 $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ 进行着色。\n        - 因此，$G'_{1}$ 是 3-可着色的。\n5.  **停止**：因为剩下的核心是 3-可着色的，所以我们停止溢出。\n$\\mathcal{H}_{\\text{cost}}$ 的总溢出代价是单个溢出顶点 $v_d$ 的代价。\n$$ \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}}) = c(v_d) = 1 $$\n\n**使用启发式算法 $\\mathcal{H}_{\\text{degree}}$ 进行分析**\n\n1.  **初始图 $G_0$**：和之前一样，没有顶点可以被简化。核心是 $G_0$。\n2.  **可着色性检查**：和之前一样，$G_0$ 不是 3-可着色的。\n3.  **溢出**：我们必须从 $G_0$ 中溢出一个顶点。使用 $\\mathcal{H}_{\\text{degree}}$，我们选择度数最大的顶点。\n    - 度数：$\\text{deg}(v_e)=8$ 是唯一的最大值。我们溢出 $v_e$。\n    - **到目前为止的总溢出代价：$9$。**\n4.  **新图 $G_1 = G_0 \\setminus \\{v_e\\}$**：重复此过程。\n    - **简化**：$v_e$ 的邻居的度数减少 1。\n        - $\\text{deg}_{G_1}(v_a)=3$，$\\text{deg}_{G_1}(v_b)=3$，$\\text{deg}_{G_1}(v_{x_i})=3$，$\\text{deg}_{G_1}(v_{y_j})=3$。\n        - $v_c$ 和 $v_d$ 的度数不变：$\\text{deg}_{G_1}(v_c)=3$，$\\text{deg}_{G_1}(v_d)=3$。\n        - $G_1$ 中的所有顶点度数都为 3。没有顶点可以被简化。核心是 $G_1$。\n    - **可着色性检查**：$G_1$ 是 3-可着色的吗？不是，它仍然包含在 $\\{v_a, v_b, v_c, v_d\\}$ 上的 $K_4$ 子图。\n    - **溢出**：我们必须从 $G_1$ 中溢出一个顶点。使用 $\\mathcal{H}_{\\text{degree}}$，所有顶点的度数都是 3。我们按字母顺序打破平局。候选者是 $\\{v_a, v_b, v_c, v_d, v_{x_1}, \\dots\\}$。按字母顺序排在最前面的是 $v_a$。我们溢出 $v_a$。\n    - **到目前为止的总溢出代价：$c(v_e) + c(v_a) = 9 + 7 = 16$。**\n5.  **新图 $G_2 = G_1 \\setminus \\{v_a\\}$**：重复此过程。\n    - **简化**：移除 $v_a$ 后，它在 $G_1$ 中的邻居（$v_b, v_c, v_d$）的度数减少。\n        - 在 $G_2$ 中，我们现在有 $\\text{deg}(v_b)=2, \\text{deg}(v_c)=2, \\text{deg}(v_d)=2$。所有这些都可以被简化。\n        - 对 $\\{v_b, v_c, v_d\\}$ 的简化不影响 $\\{v_x, v_y\\}$ 顶点的度数，它们仍然是 3。\n    - **核心**：简化 $v_b, v_c, v_d$ 后，剩下的核心是在 $\\{v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$ 上的子图，即一个 $K_{3,3}$。\n    - **可着色性检查**：这个核心（$K_{3,3}$）是 3-可着色的吗？是的，它是 2-可着色的，因此也是 3-可着色的。\n6.  **停止**：因为剩下的核心是 3-可着色的，所以我们停止溢出。\n$\\mathcal{H}_{\\text{degree}}$ 的总溢出代价是溢出顶点 $v_e$ 和 $v_a$ 的代价之和。\n$$ \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) = c(v_e) + c(v_a) = 9 + 7 = 16 $$\n\n**最终计算**\n\n我们被要求计算差值 $\\Delta$。\n$$ \\Delta = \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) - \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}}) $$\n$$ \\Delta = 16 - 1 = 15 $$\n总溢出代价的差值为 $15$。",
            "answer": "$$\n\\boxed{15}\n$$"
        },
        {
            "introduction": "寄存器分配充满了权衡。变量溢出到内存的代价很高，但冗余的 $\\text{MOVE}$ 指令同样会降低程序性能。有时，主动溢出一个临时变量可以简化干预图，从而使拷贝合并（copy coalescing）等其他优化得以成功，最终获得净收益。 通过解决这个问题，你将应用经典的Briggs保守合并规则，并定量地评估何时一次溢出操作可以成为一个“合算的买卖”，这是构建高级寄存器分配器的关键洞察。",
            "id": "3666563",
            "problem": "考虑编译器寄存器分配阶段中的一个直线型基本块，该基本块使用冲突图进行抽象。你有 $k = 3$ 个可分配的通用寄存器。该基本块有临时变量 $a$、 $b$、 $c$、 $d$ 和 $s$。冲突图 $G$ 的顶点集为 $\\{a,b,c,d,s\\}$，无向边为\n$$(a,c),\\ (a,d),\\ (a,s),\\ (b,c),\\ (b,d),\\ (b,s),\\ (c,s),\\ (d,s)。$$\n恰好有 $2$ 条符合合并条件的复制（传送）指令：一条传送 $a \\rightarrow b$ 和一条传送 $c \\rightarrow d$。根据构造， $a$ 和 $b$ 之间没有冲突边， $c$ 和 $d$ 之间也没有冲突边。\n\n分配器使用以下由 Briggs 提出的经过充分测试的保守复制合并规则：一条传送指令 $x \\rightarrow y$ 可以被合并，当且仅当 $x$ 和 $y$ 不冲突，并且在假设合并 $x$ 和 $y$ 之后，它们的在 $G$ 中度数至少为 $k$ 的邻居的并集的基数严格小于 $k$。如果测试失败，则该传送指令不能被合并。\n\n假设选择溢出某个临时变量会在运行合并之前，从冲突图中移除该临时变量的节点及其所有关联的边。你只被允许考虑两种方案：\n- 方案 $A$：不溢出任何临时变量；尝试根据保守规则合并传送指令。\n- 方案 $B$：溢出临时变量 $s$；然后尝试根据保守规则合并传送指令。\n\n在此基本块中溢出 $s$ 会产生如下的归一化溢出延迟：$s$ 有 $1$ 个必须被存储的定义和 $2$ 个必须被重载的使用，每次内存操作的成本为 $1$（单位与计算剩余传送指令所用的归一化单位相同）。因此，溢出延迟为 $spill\\_lat = 3$。如果不执行溢出，则 $spill\\_lat = 0$。\n\n将目标函数定义为\n$$\\text{cost} \\;=\\; spill\\_lat \\;+\\; moves,$$\n其中 $moves$ 是在所选方案下应用保守合并后剩余的传送指令数量，而 $spill\\_lat$ 如上所述。计算这两种方案可实现的最小成本，并以单个实数值的形式报告。无需四舍五入，也不使用物理单位。",
            "solution": "用户希望我解决一个关于寄存器分配的问题。\n\n### 步骤 1：提取已知条件\n*   **寄存器数量, `k`**: $k = 3$。\n*   **临时变量（图中的节点）**: $V = \\{a,b,c,d,s\\}$。\n*   **冲突图的边, `E`**:\n    *   $(a,c)$, $(a,d)$, $(a,s)$\n    *   $(b,c)$, $(b,d)$, $(b,s)$\n    *   $(c,s)$\n    *   $(d,s)$\n*   **复制（传送）指令**: $a \\rightarrow b$ 和 $c \\rightarrow d$。\n*   **因传送指令而没有冲突边**: $(a,b) \\notin E$ 且 $(c,d) \\notin E$。\n*   **保守合并规则 (Briggs)**: 一条传送 $x \\rightarrow y$ 被合并，如果：\n    1.  $(x,y) \\notin E$。（对于我们的传送指令，此项已给出）。\n    2.  令 $N(v)$ 为顶点 $v$ 的邻居集合，$\\text{deg}(v)$ 为其度。\n    3.  条件是 $|\\{v \\in N(x) \\cup N(y) \\mid \\text{deg}(v) \\ge k\\}|  k$。\n*   **方案 A**: 不溢出。尝试合并。\n*   **方案 B**: 溢出临时变量 $s$。尝试合并。\n*   **溢出延迟**:\n    *   对于方案 A: $spill\\_lat_A = 0$。\n    *   对于方案 B（溢出 $s$）: $spill\\_lat_B = 1 \\text{ (存储)} + 2 \\text{ (加载)} = 3$。\n*   **成本函数**: $\\text{cost} = spill\\_lat + moves$，其中 `moves` 是剩余的传送指令数量。\n*   **目标**: 找出方案 A 和方案 B 之间的最小成本。\n\n### 步骤 2：使用提取的已知条件进行验证\n*   **科学依据**: 该问题在编译器理论中有充分的依据，特别是在使用冲突图和 Briggs 的保守合并启发式算法进行寄存器分配方面。\n*   **定义明确**: 该问题有明确定义的图、规则和目标函数，可以得出一个唯一的可解答案。\n*   **目标**: 语言正式且无歧义。\n*   **不完整或矛盾的设置**: 设置是完整且一致的。我们可以构建图并计算度数：\n    *   $\\text{deg}(a) = |\\{c, d, s\\}| = 3$\n    *   $\\text{deg}(b) = |\\{c, d, s\\}| = 3$\n    *   $\\text{deg}(c) = |\\{a, b, s\\}| = 3$\n    *   $\\deg(d) = |\\{a, b, s\\}| = 3$\n    *   $\\text{deg}(s) = |\\{a, b, c, d\\}| = 4$\n    已知条件内部一致。\n*   **其他缺陷**: 该问题是一个已知算法的标准、非平凡的应用，没有其他列出的缺陷。\n\n### 步骤 3：结论和行动\n问题有效。将提供解决方案。\n\n### 解题推导\n\n目标是通过比较两种策略来计算最小成本：方案 A（不溢出）和方案 B（溢出临时变量 $s$）。成本定义为 $\\text{cost} = spill\\_lat + moves$，其中 $moves$ 是尝试合并后剩余的传送指令数量。\n\n#### 方案 A 分析：不溢出\n\n在此方案中，我们使用初始冲突图 $G$，其顶点集为 $V = \\{a,b,c,d,s\\}$ 及指定的边。可分配寄存器的数量为 $k = 3$。此方案的溢出延迟为 $spill\\_lat_A = 0$。\n\n首先，我们计算 $G$ 中每个顶点的度数：\n*   $\\text{deg}(a) = 3$\n*   $\\text{deg}(b) = 3$\n*   $\\text{deg}(c) = 3$\n*   $\\text{deg}(d) = 3$\n*   $\\text{deg}(s) = 4$\n\n如果一个节点的度数至少为 $k$，则认为它具有“显著度”。当 $k=3$ 时，所有顶点 $\\{a, b, c, d, s\\}$ 都具有显著度。\n\n现在我们将保守合并规则应用于这两条传送指令。\n\n**1. 考虑传送 $a \\rightarrow b$：**\n令 $x=a$ 和 $y=b$。规则要求我们检查 $x$ 和 $y$ 的邻居。\n*   $a$ 的邻居：$N(a) = \\{c, d, s\\}$。\n*   $b$ 的邻居：$N(b) = \\{c, d, s\\}$。\n*   邻居的并集是 $N(a) \\cup N(b) = \\{c, d, s\\}$。\n\n接下来，我们找出这些邻居中度数至少为 $k=3$ 的子集：\n*   $\\text{deg}(c) = 3 \\ge 3$。\n*   $\\text{deg}(d) = 3 \\ge 3$。\n*   $\\text{deg}(s) = 4 \\ge 3$。\n并集中的所有邻居都具有显著度。这样的邻居集合是 $\\{c, d, s\\}$。该集合的基数为 $3$。\n合并条件是该基数必须严格小于 $k$。这里，我们检查 $3  3$ 是否成立。这是错误的。\n因此，传送 $a \\rightarrow b$ 不能被合并。\n\n**2. 考虑传送 $c \\rightarrow d$：**\n令 $x=c$ 和 $y=d$。\n*   $c$ 的邻居：$N(c) = \\{a, b, s\\}$。\n*   $d$ 的邻居：$N(d) = \\{a, b, s\\}$。\n*   邻居的并集是 $N(c) \\cup N(d) = \\{a, b, s\\}$。\n\n接下来，我们找出这些邻居中度数至少为 $k=3$ 的子集：\n*   $\\text{deg}(a) = 3 \\ge 3$。\n*   $\\text{deg}(b) = 3 \\ge 3$。\n*   $\\text{deg}(s) = 4 \\ge 3$。\n具有显著度的邻居集合是 $\\{a, b, s\\}$。该集合的基数为 $3$。\n合并条件是 $3  3$，这是错误的。\n因此，传送 $c \\rightarrow d$ 不能被合并。\n\n在方案 A 下，两条传送指令都无法被消除。\n*   剩余传送指令数量：$moves_A = 2$。\n*   溢出延迟：$spill\\_lat_A = 0$。\n*   方案 A 的总成本：$\\text{cost}_A = spill\\_lat_A + moves_A = 0 + 2 = 2$。\n\n#### 方案 B 分析：溢出临时变量 `s`\n\n在此方案中，我们首先溢出临时变量 $s$。这会产生 $spill\\_lat_B = 3$ 的溢出成本。溢出一个临时变量意味着从冲突图中移除其节点和所有关联的边。新图 $G'$ 的顶点集为 $V' = \\{a, b, c, d\\}$。\n\n与 $s$ 关联的边，即 $(a,s), (b,s), (c,s), (d,s)$，被移除。$G'$ 中剩余的边是 $E' = \\{(a,c), (a,d), (b,c), (b,d)\\}$。\n\n我们计算这个新图 $G'$ 中顶点的度数：\n*   $\\text{deg}_{G'}(a) = 2$\n*   $\\text{deg}_{G'}(b) = 2$\n*   $\\text{deg}_{G'}(c) = 2$\n*   $\\text{deg}_{G'}(d) = 2$\n\n当 $k=3$ 时，$G'$ 中没有顶点具有显著度，因为所有度数都小于 $3$。\n\n现在我们在图 $G'$ 的背景下应用合并规则。\n\n**1. 考虑传送 $a \\rightarrow b$：**\n令 $x=a$ 和 $y=b$。\n*   $G'$ 中的邻居：$N_{G'}(a) = \\{c, d\\}$ 和 $N_{G'}(b) = \\{c, d\\}$。\n*   邻居的并集：$N_{G'}(a) \\cup N_{G'}(b) = \\{c, d\\}$。\n\n我们找到这些邻居中度数 $\\ge k=3$ 的子集。\n*   $\\text{deg}_{G'}(c) = 2  3$。\n*   $\\text{deg}_{G'}(d) = 2  3$。\n具有显著度的邻居集合是空集 $\\emptyset$。其基数为 $0$。\n合并条件是 $0  3$，这是正确的。\n因此，传送 $a \\rightarrow b$ 可以被合并。\n\n**2. 考虑传送 $c \\rightarrow d$：**\n令 $x=c$ 和 $y=d$。\n*   $G'$ 中的邻居：$N_{G'}(c) = \\{a, b\\}$ 和 $N_{G'}(d) = \\{a,b\\}$。\n*   邻居的并集：$N_{G'}(c) \\cup N_{G'}(d) = \\{a, b\\}$。\n\n我们找到这些邻居中度数 $\\ge k=3$ 的子集。\n*   $\\text{deg}_{G'}(a) = 2  3$。\n*   $\\text{deg}_{G'}(b) = 2  3$。\n具有显著度的邻居集合是空集 $\\emptyset$。其基数为 $0$。\n合并条件是 $0  3$，这是正确的。\n因此，传送 $c \\rightarrow d$ 可以被合并。\n\n在方案 B 下，两条传送指令都成功地被合并和消除了。合并的顺序无关紧要，因为这两条传送指令涉及不相交的临时变量集。\n*   剩余传送指令数量：$moves_B = 0$。\n*   溢出延迟：$spill\\_lat_B = 3$。\n*   方案 B 的总成本：$\\text{cost}_B = spill\\_lat_B + moves_B = 3 + 0 = 3$。\n\n#### 结论\n\n我们比较两种方案的成本以找到最小值。\n*   $\\text{cost}_A = 2$\n*   $\\text{cost}_B = 3$\n\n可实现的最小成本是 $\\min(\\text{cost}_A, \\text{cost}_B) = \\min(2, 3) = 2$。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "在寄存器分配器为每个临时变量指定物理寄存器后，编译器必须生成代码来实现这些分配。在基于静态单赋值（SSA）的编译器中，这一步通常会产生一系列“并行复制”指令。我们可以将一组并行复制操作建模为寄存器集合上的一个置换。 这项练习将指导你如何将一个置换分解为不相交的循环，并使用一个临时寄存器来推导出实现该置换的最优 $\\text{MOVE}$ 指令序列，这是现代编译器后端的一项基本技术。",
            "id": "3661148",
            "problem": "编译器后端在静态单赋值 (SSA) 形式的寄存器分配过程中，必须解决一个并行复制问题。并行复制的语义是所有赋值同时发生：对于集合中的每个赋值 $d := s$，目标寄存器 $d$ 中复制后的值必须等于任何赋值执行前源寄存器 $s$ 中的复制前的值。机器只提供形式为 $x := y$ 的简单移动指令，而没有交换或循环移位指令。在解决过程中，你可以使用一个临时寄存器来保留值。\n\n考虑机器寄存器 $r_1, r_2, \\dots, r_{10}$以及以下并行复制，以一组目标-源赋值的形式指定：\n- $r_1 := r_4$\n- $r_4 := r_1$\n- $r_2 := r_5$\n- $r_5 := r_7$\n- $r_7 := r_2$\n- $r_3 := r_9$\n- $r_9 := r_6$\n- $r_6 := r_3$\n- $r_8 := r_8$\n- $r_{10} := r_{10}$\n\n任务：\n1. 从并行复制语义的基本原理出发，论证为什么这组赋值在寄存器上定义了一个带有某些不动点的置换，并将该置换分解为不相交的循环和不动点。\n2. 对于每个非平凡循环（长度大于1），设计一个最优的顺序移动序列，该序列对该循环只使用一个临时寄存器，并保持并行复制的语义。从基本推理出发，证明每个循环所用移动次数的最优性。\n3. 计算你的最优方案为实现整个并行复制所产生的移动指令的最小总数。你最终提交的答案必须是这个单一整数，不带单位，也不进行四舍五入。",
            "solution": "该问题被认为是有效的，因为它在编译器理论中有科学依据，问题阐述清晰，客观且内部一致。\n\n该问题要求分析一个并行复制操作，将其分解为一个置换，为其组成的循环设计一个最优移动序列，并计算所需的总移动次数。\n\n**1. 置换的定义与分解**\n\n并行复制是一组概念上同时执行的赋值 $\\{d_i := s_i\\}$。这意味着对于每个赋值 $d_i := s_i$，从源寄存器 $s_i$ 读取的值是任何赋值发生*之前*它的值。\n\n这组赋值可以被建模为寄存器集合 $R = \\{r_1, r_2, \\dots, r_{10}\\}$ 上的一个函数 $\\pi$。对于每个赋值 $d := s$，该函数将源寄存器 $s$ 映射到目标寄存器 $d$，表示值从 $s$ 移动到 $d$。因此，我们定义 $\\pi(s) = d$。\n\n要使 $\\pi$ 成为一个置换，它必须是集合 $R$ 上的一个双射（即单射和满射）。在给定问题中，目标寄存器集合是 $\\{r_1, r_4, r_2, r_5, r_7, r_3, r_9, r_6, r_8, r_{10}\\}$，这恰好是集合 $R$。由于 $R$ 中的每个寄存器都只作为目标出现一次，因此函数 $\\pi$ 是有限集 $R$ 上的一个双射，所以它是一个置换。\n\n给定的赋值是：\n- $r_1 := r_4 \\implies \\pi(r_4) = r_1$\n- $r_4 := r_1 \\implies \\pi(r_1) = r_4$\n- $r_2 := r_5 \\implies \\pi(r_5) = r_2$\n- $r_5 := r_7 \\implies \\pi(r_7) = r_5$\n- $r_7 := r_2 \\implies \\pi(r_2) = r_7$\n- $r_3 := r_9 \\implies \\pi(r_9) = r_3$\n- $r_9 := r_6 \\implies \\pi(r_6) = r_9$\n- $r_6 := r_3 \\implies \\pi(r_3) = r_6$\n- $r_8 := r_8 \\implies \\pi(r_8) = r_8$\n- $r_{10} := r_{10} \\implies \\pi(r_{10}) = r_{10}$\n\n任何有限集上的置换都可以唯一地分解为一组不相交的循环。我们可以通过从一个任意元素开始，并重复应用置换 $\\pi$，直到回到起始元素，来找到这些循环。\n\n- 从 $r_1$ 开始：$\\pi(r_1) = r_4$，且 $\\pi(r_4) = r_1$。这构成了循环 $(r_1, r_4)$。\n- 从 $r_2$（不在前一个循环中）开始：$\\pi(r_2) = r_7$，$\\pi(r_7) = r_5$，且 $\\pi(r_5) = r_2$。这构成了循环 $(r_2, r_7, r_5)$。\n- 从 $r_3$ 开始：$\\pi(r_3) = r_6$，$\\pi(r_6) = r_9$，且 $\\pi(r_9) = r_3$。这构成了循环 $(r_3, r_6, r_9)$。\n- 对于 $r_8$：$\\pi(r_8) = r_8$。这是一个长度为1的循环，也称为不动点：$(r_8)$。\n- 对于 $r_{10}$：$\\pi(r_{10}) = r_{10}$。这也是一个不动点：$(r_{10})$。\n\n该置换分解为不相交循环和不动点的完整结果是：$(r_1, r_4)$、$(r_2, r_7, r_5)$、$(r_3, r_6, r_9)$、$(r_8)$、$(r_{10})$。\n\n**2. 循环的最优移动序列**\n\n长度为 $k=1$ 的循环（不动点）对应于形式为 $r := r$ 的赋值。这是一个恒等操作，需要 0 次移动来执行，因为寄存器的值没有改变。\n\n一个长度 $k > 1$ 的非平凡循环，例如 $(x_1, x_2, \\dots, x_k)$，对应于并行赋值集合：\n$x_2 := x_1$\n$x_3 := x_2$\n...\n$x_1 := x_k$\n\n要仅使用形式为 $d := s$ 的简单移动来顺序执行这些赋值，我们会面临一个循环依赖问题。循环中的每个寄存器既是源又是目标。对于我们可能执行的任何移动 $x_{i+1} := x_i$，我们都会覆盖 $x_{i+1}$ 中的值，而这个值是后续赋值 $x_{i+2} := x_{i+1}$ 所需要的。在没有 `swap` 指令的情况下，不可能仅用 $k$ 次移动来解决这个循环，因为没有任何一个“安全”的初始移动不会破坏所需的值。\n\n为了打破这种循环依赖，我们必须使用可用的临时寄存器，我们称之为 $t$。我们可以将其中一个寄存器的值保存在 $t$ 中，这样就释放了该寄存器，使其可以被覆盖。这使我们能够以链式方式解决其余的赋值，并最终从 $t$ 中恢复保存的值。\n\n对于一个循环 $(x_1, x_2, \\dots, x_k)$，一个最优的移动序列如下：\n1. 将其中一个寄存器（例如 $x_k$）的值保存到临时寄存器中。这是一次移动：$t := x_k$。\n2. 现在，$x_k$ 可以被安全地覆盖。我们按照循环数据流的相反顺序执行移动链：\n   - $x_k := x_{k-1}$\n   - $x_{k-1} := x_{k-2}$\n   - ...\n   - $x_2 := x_1$\n   这个序列包含 $k-1$ 次移动。\n3. 最后，必须将 $x_k$ 的值（最初在 $t$ 中）移动到 $x_1$。这是一次移动：$x_1 := t$。\n\n总移动次数为 $1 + (k-1) + 1 = k+1$。\n这个方案是最优的。我们需要至少 $k$ 次移动来改变 $k$ 个寄存器的值。然而，如前所述，由于循环依赖， $k$ 次移动是不够的。至少需要一次额外的移动来通过保存一个值来打破循环。因此，对于长度 $k > 1$ 的循环， $k+1$ 是最小移动次数。\n\n对于给定的非平凡循环：\n- 循环 $(r_1, r_4)$：长度 $k=2$。需要 $k+1 = 2+1 = 3$ 次移动。（例如，$t := r_1$; $r_1 := r_4$; $r_4 := t$）\n- 循环 $(r_2, r_7, r_5)$：长度 $k=3$。需要 $k+1 = 3+1 = 4$ 次移动。（例如，$t := r_2$; $r_2 := r_5$; $r_5 := r_7$; $r_7 := t$）\n- 循环 $(r_3, r_6, r_9)$：长度 $k=3$。需要 $k+1 = 3+1 = 4$ 次移动。（例如，$t := r_3$; $r_3 := r_9$; $r_9 := r_6$; $r_6 := t$）\n\n**3. 最小总移动次数**\n\n实现整个并行复制的总移动次数是每个不相交循环所需移动次数的总和。一个循环的解决不影响另一个循环中的寄存器，因此我们可以简单地将成本相加。\n\n- 循环 $(r_1, r_4)$（长度 $k=2$）的移动次数：$3$\n- 循环 $(r_2, r_7, r_5)$（长度 $k=3$）的移动次数：$4$\n- 循环 $(r_3, r_6, r_9)$（长度 $k=3$）的移动次数：$4$\n- 不动点 $(r_8)$（长度 $k=1$）的移动次数：$0$\n- 不动点 $(r_{10})$（长度 $k=1$）的移动次数：$0$\n\n最小总移动指令数是其总和：\n$$ \\text{总移动次数} = 3 + 4 + 4 + 0 + 0 = 11 $$",
            "answer": "$$ \\boxed{11} $$"
        }
    ]
}