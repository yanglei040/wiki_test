{
    "hands_on_practices": [
        {
            "introduction": "本练习将带你深入代码生成的第一个关键决策：指令选择。我们将以一个常见的 $64$ 位旋转操作为例，探索在不同硬件支持下，如何选择最优的指令序列。你将扮演编译器的角色，通过计算和比较不同“降级”策略的执行时间，亲身体验指令选择与调度如何协同工作以压榨硬件性能。",
            "id": "3628158",
            "problem": "一个编译器的代码生成器必须将一个高级的、$64$ 位值 $x$ 按编译期常量 $k$ 进行的 $64$ 位右循环移位操作，降解为目标机器的操作。考虑一个目标指令集架构（ISA），它将一个 $64$ 位值表示为一个有序的 $32$ 位寄存器对 $(x_{\\mathrm{lo}}, x_{\\mathrm{hi}})$，并支持以下指令和机器资源：\n\n- 一个移位单元 $S$，执行 $64$ 位逻辑左移或右移。每次 $64$ 位移位操作的延迟为 $\\ell_{S} = 2$ 个周期。该单元是完全流水线化的，启动间隔为 $1$，并且只有一个这样的单元。\n- 一个布尔单元 $B$，执行 $64$ 位按位 $\\mathrm{OR}$（或）运算。每次 $64$ 位 $\\mathrm{OR}$ 运算的延迟为 $\\ell_{B} = 1$ 个周期。该单元是完全流水线化的，启动间隔为 $1$，并且只有一个这样的单元。\n- 一个漏斗移位单元 $F$，执行形式为 $\\mathrm{FSR32}(a,b,s)$ 的 $32$ 位漏斗右移。该操作在概念上通过将 $a$ 放在低半部分、$b$ 放在高半部分来构成 $64$ 位值 $(b:a)$，将其逻辑右移 $s$ 位（其中 $0 \\le s \\le 31$），并返回低 $32$ 位。每次 $\\mathrm{FSR32}$ 操作的延迟为 $\\ell_{F} = 1$ 个周期。该单元是完全流水线化的，启动间隔为 $1$，并且只有一个这样的单元。\n\n代码生成器可以为按常量 $k$ 的右循环移位选择以下两种合法降解方法之一：\n\n- 移位-或降解：生成一条将结果右移 $k$ 位的 $64$ 位逻辑移位指令，一条将结果左移 $(64 - k)$ 位的 $64$ 位逻辑移位指令，以及一条对两个移位结果进行 $64$ 位按位 $\\mathrm{OR}$ 运算的指令。\n- 漏斗移位降解：当 $0 \\le k  32$ 时，使用 $(x_{\\mathrm{lo}}, x_{\\mathrm{hi}})$ 作为输入；当 $32 \\le k  64$ 时，交换输入顺序并使用位移量 $(k - 32)$，生成两条 $\\mathrm{FSR32}$ 指令来产生循环移位后值的新低半部分和高半部分。假设这两条 $\\mathrm{FSR32}$ 指令将其结果写入两个新的 $32$ 位目标寄存器中，因此不需要额外的移动操作，并且这两个目标寄存器的有序对就是最终结果。\n\n假设输入对 $(x_{\\mathrm{lo}}, x_{\\mathrm{hi}})$ 在周期 $0$ 可用，常量 $k$ 嵌入在指令中，没有缓存或取指效应，并且调度仅受数据依赖和上述单实例功能单元的约束。使用基本块调度中的标准概念，即一条指令的结果在其发射后恰好 $\\ell$ 个周期变为可用，其中 $\\ell$ 是该指令的延迟。\n\n对于特定的常量 $k = 37$，当代码生成器选择最佳可用降解方法，并且调度器在资源和依赖约束下尽可能早地发射指令时，计算旋转后的 $64$ 位结果所需的最小可能完成时间（以周期为单位）。将你的最终答案表示为一个整数周期数（在最终的方框答案中不带单位）。",
            "solution": "用户要求计算一个 $64$ 位值按常量 $k=37$ 进行右循环移位操作的最小完成时间。解决方案需要在一个具有指定功能单元和延迟的目标架构上，分析两种不同的实现策略或“降解”方法，然后选择两者中较快的一个。分析将通过为每种降解方法构建一个调度来进行，该调度遵循数据依赖和资源约束。“尽早调度”策略被应用，并且所有功能单元都是完全流水线化的，启动间隔为 $1$。\n\n输入的 $64$ 位值 $x$ 由一对 $32$ 位寄存器 $(x_{\\mathrm{lo}}, x_{\\mathrm{hi}})$ 表示，我们将其解释为值 $x = (x_{\\mathrm{hi}} \\ll 32) | x_{\\mathrm{lo}}$，其中 `|` 表示按位或，`` 表示逻辑左移。输入在周期 $0$ 可用。\n\n### 策略1：移位-或降解\n\n该策略使用其定义来实现 $64$ 位右循环移位操作 $\\mathrm{ROTR}(x, k)$：\n$$ \\mathrm{ROTR}(x, k) = (x \\gg k) | (x \\ll (64 - k)) $$\n其中 `>>` 是逻辑右移。对于 $k=37$，操作如下：\n1.  `Op1`: $t_1 = x \\gg 37$。这是一个 $64$ 位逻辑右移。\n2.  `Op2`: $t_2 = x \\ll (64 - 37) = x \\ll 27$。这是一个 $64$ 位逻辑左移。\n3.  `Op3`: $y = t_1 | t_2$。这是一个 $64$ 位按位 $\\mathrm{OR}$ 运算。\n\n我们根据这些操作的依赖关系和资源需求来调度它们。\n- **依赖关系**：`Op1` 和 `Op2` 依赖于输入 $x$（在周期 $0$ 可用）。`Op3` 依赖于 `Op1` 和 `Op2` 的结果。\n- **资源**：`Op1` 和 `Op2` 都需要移位单元 $S$。`Op3` 需要布尔单元 $B$。\n- **延迟**：移位单元的延迟为 $\\ell_S = 2$ 个周期。布尔单元的延迟为 $\\ell_B = 1$ 个周期。\n- **流水线**：所有单元的启动间隔都为 $1$，意味着每个周期都可以向一个单元发射一条新指令。\n\n调度过程如下：\n- **周期 0**：输入 $x$ 可用。`Op1` 和 `Op2` 都已就绪。我们可以将其中一个发射到移位单元 $S$。我们发射 `Op1`。\n  - 在周期 $0$ 发射 `Op1` ($x \\gg 37$)。它使用单元 $S$。\n  - 结果 $t_1$ 将在周期 $0 + \\ell_S = 2$ 可用。\n- **周期 1**：`Op2` 已就绪。由于其启动间隔为 $1$，移位单元 $S$ 可用于一条新指令。\n  - 在周期 $1$ 发射 `Op2` ($x \\ll 27$)。它使用单元 $S$。\n  - 结果 $t_2$ 将在周期 $1 + \\ell_S = 3$ 可用。\n- **周期 2**：结果 $t_1$ 变为可用。`Op3` 尚未就绪，因为它仍在等待 $t_2$。\n- **周期 3**：结果 $t_2$ 变为可用。现在 `Op3` 的两个输入（$t_1$ 和 $t_2$）都已就绪。布尔单元 $B$ 可用。\n  - 在周期 $3$ 发射 `Op3` ($t_1 | t_2$)。它使用单元 $B$。\n  - 最终结果 $y$ 将在周期 $3 + \\ell_B = 4$ 可用。\n\n移位-或降解的完成时间为 $4$ 个周期。\n\n### 策略2：漏斗移位降解\n\n该策略使用两条专门的 $32$ 位漏斗移位指令 $\\mathrm{FSR32}(a, b, s)$，该指令计算 $64$ 位值 $(b:a)$ 在逻辑右移 $s$ 位后得到的低 $32$ 位。该操作等效于 $(b \\ll (32-s)) | (a \\gg s)$。\n问题陈述，对于 $32 \\le k  64$ 的情况，输入顺序被交换，位移量为 $s = k - 32$。在我们的特定情况下，$k=37$，所以位移量为 $s = 37 - 32 = 5$。这两条 $\\mathrm{FSR32}$ 指令必须计算循环移位结果的新低半部分和高半部分，我们称之为 $y_{\\mathrm{lo}}$ 和 $y_{\\mathrm{hi}}$。\n\n让我们推导由 $\\mathrm{ROTR}(x, 37)$ 产生的 $y_{\\mathrm{lo}}$ 和 $y_{\\mathrm{hi}}$ 的表达式：\n新的低半部分 $y_{\\mathrm{lo}}$ 由 $(x \\gg 37)$ 和 $(x \\ll 27)$ 的低 $32$ 位组成。\n$$ y_{\\mathrm{lo}} = (x_{\\mathrm{lo}} \\ll 27) | (x_{\\mathrm{hi}} \\gg 5) $$\n新的高半部分 $y_{\\mathrm{hi}}$ 由相同表达式的高 $32$ 位组成。\n$$ y_{\\mathrm{hi}} = (x_{\\mathrm{hi}} \\ll 27) | (x_{\\mathrm{lo}} \\gg 5) $$\n我们必须将这些表达式与 $\\mathrm{FSR32}$ 指令相匹配。当 $s=5$ 时：\n- 为计算 $y_{\\mathrm{lo}} = (x_{\\mathrm{lo}} \\ll 27) | (x_{\\mathrm{hi}} \\gg 5)$：我们设置 $a = x_{\\mathrm{hi}}$ 和 $b = x_{\\mathrm{lo}}$。\n  - `OpA`: $y_{\\mathrm{lo}} = \\mathrm{FSR32}(x_{\\mathrm{hi}}, x_{\\mathrm{lo}}, 5)$。\n- 为计算 $y_{\\mathrm{hi}} = (x_{\\mathrm{hi}} \\ll 27) | (x_{\\mathrm{lo}} \\gg 5)$：我们设置 $a = x_{\\mathrm{lo}}$ 和 $b = x_{\\mathrm{hi}}$。\n  - `OpB`: $y_{\\mathrm{hi}} = \\mathrm{FSR32}(x_{\\mathrm{lo}}, x_{\\mathrm{hi}}, 5)$。\n\n现在，我们来调度 `OpA` 和 `OpB`。\n- **依赖关系**：`OpA` 和 `OpB` 都依赖于输入 $x_{\\mathrm{lo}}$ 和 $x_{\\mathrm{hi}}$，它们在周期 $0$ 可用。这两个操作相互独立。\n- **资源**：`OpA` 和 `OpB` 都需要漏斗移位单元 $F$。\n- **延迟**：漏斗移位单元的延迟为 $\\ell_F = 1$ 个周期。\n- **流水线**：该单元的启动间隔为 $1$。\n\n调度过程如下：\n- **周期 0**：输入可用。`OpA` 和 `OpB` 都已就绪。我们将其中一个发射到漏斗移位单元 $F$。我们发射 `OpA`。\n  - 在周期 $0$ 发射 `OpA` ($\\mathrm{FSR32}(x_{\\mathrm{hi}}, x_{\\mathrm{lo}}, 5)$)。它使用单元 $F$。\n  - 结果 $y_{\\mathrm{lo}}$ 将在周期 $0 + \\ell_F = 1$ 可用。\n- **周期 1**：`OpB` 已就绪。单元 $F$ 可用于一条新指令。\n  - 在周期 $1$ 发射 `OpB` ($\\mathrm{FSR32}(x_{\\mathrm{lo}}, x_{\\mathrm{hi}}, 5)$)。它使用单元 $F$。\n  - 结果 $y_{\\mathrm{hi}}$ 将在周期 $1 + \\ell_F = 2$ 可用。\n\n完整的 $64$ 位结果 $(y_{\\mathrm{lo}}, y_{\\mathrm{hi}})$ 只有在两个半部分都计算完毕后才可用。第一半 $y_{\\mathrm{lo}}$ 在周期 $1$ 就绪。第二半 $y_{\\mathrm{hi}}$ 在周期 $2$ 就绪。因此，总完成时间是这两个就绪时间的最大值。\n完成时间 = $\\max(1, 2) = 2$ 个周期。\n\n### 结论\n\n比较这两种策略：\n- 移位-或降解完成时间：$4$ 个周期。\n- 漏斗移位降解完成时间：$2$ 个周期。\n\n代码生成器选择最佳（最快）的可用降解方法。在这种情况下，漏斗移位降解更优。最小可能完成时间是 $2$ 个周期。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "指令选定之后，我们面临下一个难题：有限的寄存器资源。本练习模拟了这一经典场景，要求你在只有两个可用寄存器的情况下，为一组活跃的临时变量制定分配策略。你必须通过分析变量的生命周期，决定何时将哪些变量“溢出”到栈上，并巧妙地重用栈空间以最小化内存开销，从而掌握寄存器分配与溢出代码优化的核心技巧。",
            "id": "3628173",
            "problem": "一个用于简单命令式语言的代码生成器，其目标机器恰好有 $2$ 个物理寄存器可用于存放临时变量。一个线性基本块的中间表示 (IR) 由程序点 $\\{1,2,\\dots,16\\}$ 索引。五个临时变量 $t_1, t_2, t_3, t_4, t_5$ 具有以下活跃段（表示法 $[a,b]$ 意味着该临时变量在满足 $a \\leq p \\leq b$ 的每个整数程序点 $p$ 都是活跃的，而 $\\cup$ 表示因生命周期空洞而产生的不相交活跃段），并且每个临时变量在溢出时都有一个关联的存储宽度（以字节为单位）：\n\n- $t_1$：在 $[1,5] \\cup [9,11]$ 活跃，宽度为 $8$ 字节。\n- $t_2$：在 $[3,7]$ 活跃，宽度为 $4$ 字节。\n- $t_3$：在 $[4,5] \\cup [9,10]$ 活跃，宽度为 $4$ 字节。\n- $t_4$：在 $[2,4] \\cup [10,12]$ 活跃，宽度为 $16$ 字节。\n- $t_5$：在 $[8,15]$ 活跃，宽度为 $4$ 字节。\n\n在任何程序点 $p$，最多只能有 $2$ 个活跃的临时变量占用寄存器。在点 $p$，每个未占用寄存器的活跃临时变量都被视为在该点溢出，并且必须占用一个大小至少为其宽度的栈槽。代码生成器可以随时间改变哪些临时变量存放在寄存器中，并且只要不同溢出临时变量的溢出活跃段在时间上不重叠，就可以为它们复用同一个栈槽。一个栈槽的大小固定为曾经占用它的所有临时变量中的最大宽度。假设槽之间没有填充，并且由溢出槽贡献的栈帧大小是其所有槽大小的总和。目标是在所有程序点上选择哪些临时变量占用寄存器，并将溢出的段“着色”到最小的一组栈槽上，从而使因溢出槽产生的总栈帧大小最小化。\n\n基于以上信息，计算最小的总栈帧大小（以字节为单位）。请以字节为单位表示最终答案，无需四舍五入。",
            "solution": "为了解决这个问题，我们首先需要确定在每个程序点 $p$ 哪些临时变量是活跃的，然后找出寄存器压力超过可用寄存器数量（2个）的冲突点。目标是制定一个溢出策略，以最小化因此产生的栈帧大小。\n\n1. **活跃性分析**\n根据问题中给出的活跃区间，我们可以列出每个程序点的活跃集 $L(p)$：\n- $L(1) = \\{t_1\\}$\n- $L(2) = \\{t_1, t_4\\}$\n- $L(3) = \\{t_1, t_2, t_4\\}$\n- $L(4) = \\{t_1, t_2, t_3, t_4\\}$\n- $L(5) = \\{t_1, t_2, t_3\\}$\n- $L(6) = \\{t_2\\}$\n- $L(7) = \\{t_2\\}$\n- $L(8) = \\{t_5\\}$\n- $L(9) = \\{t_1, t_3, t_5\\}$\n- $L(10) = \\{t_1, t_3, t_4, t_5\\}$\n- $L(11) = \\{t_1, t_4, t_5\\}$\n- $L(12) = \\{t_4, t_5\\}$\n- $L(13) = \\{t_5\\}$\n- $L(14) = \\{t_5\\}$\n- $L(15) = \\{t_5\\}$\n- $L(16) = \\emptyset$\n\n2. **识别冲突点与溢出策略**\n冲突点是活跃变量数量 $|L(p)|$ 超过2的点。这些点需要溢出 $|L(p)| - 2$ 个变量。为了最小化栈帧大小，我们采用一个启发式策略：优先溢出宽度最小的变量。各变量宽度为：$|t_4|=16$ 字节, $|t_1|=8$ 字节, $|t_2|=|t_3|=|t_5|=4$ 字节。\n\n- **$p=3$**：$L(3)=\\{t_1(8), t_2(4), t_4(16)\\}$。$|L|=3$，需溢出1个。保留最宽的 $t_4$ 和 $t_1$，溢出 $t_2$ (4字节)。\n- **$p=4$**：$L(4)=\\{t_1(8), t_2(4), t_3(4), t_4(16)\\}$。$|L|=4$，需溢出2个。保留 $t_4$ 和 $t_1$，溢出 $t_2$ 和 $t_3$ (均为4字节)。\n- **$p=5$**：$L(5)=\\{t_1(8), t_2(4), t_3(4)\\}$。$|L|=3$，需溢出1个。保留 $t_1$ 和 $t_2$ (或 $t_3$)，溢出 $t_3$ (或 $t_2$) (4字节)。\n- **$p=9$**：$L(9)=\\{t_1(8), t_3(4), t_5(4)\\}$。$|L|=3$，需溢出1个。保留 $t_1$ 和 $t_5$ (或 $t_3$)，溢出 $t_3$ (或 $t_5$) (4字节)。\n- **$p=10$**：$L(10)=\\{t_1(8), t_3(4), t_4(16), t_5(4)\\}$。$|L|=4$，需溢出2个。保留 $t_4$ 和 $t_1$，溢出 $t_3$ 和 $t_5$ (均为4字节)。\n- **$p=11$**：$L(11)=\\{t_1(8), t_4(16), t_5(4)\\}$。$|L|=3$，需溢出1个。保留 $t_4$ 和 $t_1$，溢出 $t_5$ (4字节)。\n\n在所有其他点，$|L(p)| \\le 2$，无需溢出。\n\n3. **计算最小栈帧大小**\n此策略从不溢出最宽的变量 $t_1$ 和 $t_4$，因此避免了创建 8 字节或 16 字节的栈槽。所有溢出的变量（$t_2, t_3, t_5$）都是 4 字节宽。\n\n现在我们需要确定所需的最小槽数。这等于在任何单个程序点上同时溢出的变量的最大数量。\n- 在 $p=4$，我们同时溢出 $t_2$ 和 $t_3$。需要2个槽。\n- 在 $p=10$，我们同时溢出 $t_3$ 和 $t_5$。需要2个槽。\n- 在其他冲突点，我们最多溢出1个变量。\n\n因此，最大并发溢出数为 2。这意味着我们至少需要 2 个栈槽。\n由于所有被溢出的变量都是 4 字节宽，我们可以使用两个大小均为 4 字节的槽来满足所有溢出需求。例如，槽1可用于 $t_2$ 的溢出，槽2可用于 $t_3$ 和 $t_5$ 的溢出（它们的溢出区间不重叠）。\n\n总栈帧大小是所有必需槽的大小之和。\n$$ \\text{最小栈帧大小} = (\\text{槽1大小}) + (\\text{槽2大小}) = 4 \\text{ 字节} + 4 \\text{ 字节} = 8 \\text{ 字节}。 $$\n这是最优解，因为在点 $p=4$ 和 $p=10$ 必须溢出两个变量，所以少于两个槽是不可能的。并且通过只溢出最窄的变量，我们保证了槽的宽度是最小的。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "优秀的编译器不止于逐条翻译，更能识别代码中的“惯用模式”并施以宏观优化。本练习将聚焦于一个典型的例子：使用 SIMD 指令优化标准库函数 `memcmp`。你的任务是评估这种高级优化的真实性能影响，需要精确计算处理数据对齐、向量化主循环及剩余部分清理所需的周期数。通过这个实践，你将理解编译器如何利用现代处理器的并行计算能力来实现数量级的性能提升。",
            "id": "3628165",
            "problem": "编译器的代码生成器正在将对标准内存比较函数 `memcmp` 的一个高级调用降级为一个控制流结构。该结构在可能的情况下使用对齐的向量加载进行提前退出比较，并对尾部数据进行标量清理。\n\n内存比较的语义如下：给定两个等长为 $L$ 的字节数组 $A$ 和 $B$，操作在发现第一个索引 $i$ 处 $A[i] \\neq B[i]$ 时立即返回，此时已比较过所有先前的字节 $0, 1, \\ldots, i-1$ 且均相等。\n\n代码生成器采用以下降级策略，在对齐允许时依赖单指令多数据（SIMD）向量加载：\n\n1. 序言（头部对齐）：如果 $A$ 和 $B$ 的起始地址模SIMD宽度 $w$ 的余数相同，生成器会发出标量字节比较指令，直到两个指针都前进到下一个 $w$ 字节边界。这个头部的长度为 $h = (w - (p \\bmod w)) \\bmod w$，其中 $p$ 是 $A$ 的起始地址，且两个地址模 $w$ 的余数相同。如果在此头部发现不匹配，操作将提前返回。\n2. 主循环（对齐向量）：当剩余字节数不少于 $w$ 时，生成器从 $A$ 和 $B$ 发出 $w$ 字节的对齐SIMD加载指令并进行比较。如果加载的向量相等，循环继续；否则，操作将在该 $w$ 字节块内执行标量搜索，以定位第一个不同的字节并返回。如果所有完整向量都相等，则控制流转到尾部处理。\n3. 结语（尾部）：任何剩余的 $t$ 个字节（少于 $w$ 个）都将逐字节进行比较。在尾部检测到第一个不匹配时，操作将立即返回。\n\n假设存在以下具体的、科学上合理的条件，这些条件由代码生成器在编译时确定或在运行时验证：\n\n- 总长度为 $L = 313$ 字节。\n- SIMD向量宽度为 $w = 16$ 字节。\n- $A$ 和 $B$ 的起始地址模 $w$ 的余数相同，即 $p \\bmod w = q \\bmod w = 12$。因此，头部长度为 $h = (w - (p \\bmod w)) \\bmod w$。\n- 在全局索引 $m = 310$（从 $A$ 和 $B$ 的起始处零基计数）处出现单个不匹配之前，所有字节都相等，即对于所有 $i  m$，$A[i] = B[i]$，而 $A[m] \\neq B[m]$。\n- 动态周期的微架构成本模型如下：\n  - 每个标量字节比较花费 $1$ 个周期。\n  - 对一个相等的 $w$ 字节块进行的每次对齐向量比较包括两次对齐SIMD加载和一次向量相等操作，每次SIMD加载成本为 $4$ 个周期，向量比较成本为 $1$ 个周期。\n  - 没有分支预测错误惩罚，也没有缓存未命中；忽略地址生成成本。如果在向量块中发现不匹配，块内标量搜索将对每个检查的字节花费一次标量比较的成本，但在本特定场景中，不匹配不在任何完整的向量块内。\n- 代码生成器保证不会访问越界内存；对齐的向量加载仅针对由 $L$ 界定的范围内完全覆盖的 $w$ 字节块发出。\n\n在这些条件下，计算直到操作在第一个不匹配处返回时所花费的中央处理器（CPU）总周期数。请用一个精确的整数表示你的最终答案（单位为周期），无需四舍五入。",
            "solution": "该问题要求计算内存比较操作 `memcmp` 的一个特定实现在找到第一个不匹配项并返回之前所消耗的CPU总周期数。解决方案是通过系统地分析该操作的三个阶段（序言、主循环和结语）推导出来的。\n\n首先，我们使用符号表示法来定义给定的参数：\n-   数组总长度：$L = 313$ 字节。\n-   SIMD向量宽度：$w = 16$ 字节。\n-   数组 $A$ 和 $B$ 的起始地址（分别表示为 $p$ 和 $q$）模 $w$ 的余数相同：$p \\bmod w = q \\bmod w = 12$。\n-   第一个不匹配项的索引：$m = 310$（从零开始计数）。对于所有索引 $i  m$，有 $A[i] = B[i]$，而在索引 $m$ 处，有 $A[m] \\neq B[m]$。\n-   单个标量字节比较的成本：$C_{scalar} = 1$ 周期。\n-   比较两个相等的 $w$ 字节对齐向量的成本：这包括两次SIMD加载（每次 $4$ 个周期）和一次向量相等性测试（$1$ 个周期）。因此，$C_{vector} = 2 \\times 4 + 1 = 9$ 周期。\n\n总周期数 $C_{total}$ 将是直到检测到索引 $m$ 处的不匹配为止，操作所执行的每个阶段的周期数之和。\n\n**1. 序言（头部对齐）**\n\n序言执行标量字节比较，以将内存指针与下一个 $w$ 字节边界对齐。此头部部分比较的字节数 $h$ 由以下公式给出：\n$$h = (w - (p \\bmod w)) \\bmod w$$\n代入给定值：\n$$h = (16 - 12) \\bmod 16 = 4 \\bmod 16 = 4$$\n头部由前 $4$ 个字节组成，对应于索引 $0, 1, 2,$ 和 $3$。由于第一个不匹配发生在索引 $m=310$ 处，头部中的所有字节都相等。因此，执行了 $4$ 次标量比较。\n\n序言的成本 $C_{head}$ 为：\n$$C_{head} = h \\times C_{scalar} = 4 \\times 1 = 4 \\text{ 周期}$$\n序言结束后，已处理了 $4$ 个字节。待比较的剩余长度为 $L - h = 313 - 4 = 309$ 字节。此时指针已与一个 $16$ 字节的边界对齐。\n\n**2. 主循环（对齐向量比较）**\n\n主循环使用SIMD指令比较完整的 $w$ 字节块。只要待比较的字节数不少于 $w$，该循环就会继续。在剩余的 $309$ 字节中，完整向量块的数量 $N_{vector}$ 为：\n$$N_{vector} = \\left\\lfloor \\frac{L - h}{w} \\right\\rfloor = \\left\\lfloor \\frac{309}{16} \\right\\rfloor = \\lfloor 19.3125 \\rfloor = 19$$\n这 $19$ 个向量块总共覆盖 $19 \\times w = 19 \\times 16 = 304$ 字节。这些字节对应的全局索引范围从 $h=4$ 到 $h + (N_{vector} \\times w) - 1 = 4 + 304 - 1 = 307$。\n\n不匹配发生在索引 $m=310$ 处，这在主循环覆盖的索引范围 $[4, 307]$ 之外。这证实了问题的假设，即不匹配不会发生在完整的向量块内。因此，所有 $19$ 个向量块都被判为相等。\n\n主循环的成本 $C_{loop}$ 是向量块的数量乘以每个块的成本：\n$$C_{loop} = N_{vector} \\times C_{vector} = 19 \\times 9 = 171 \\text{ 周期}$$\n\n**3. 结语（尾部比较）**\n\n主循环结束后，剩余的字节构成尾部，这些字节将使用标量字节比较进行处理。\n在尾部之前处理的字节数为 $h + (N_{vector} \\times w) = 4 + 304 = 308$ 字节。\n尾部的字节数 $t$ 为：\n$$t = L - (h + N_{vector} \\times w) = 313 - 308 = 5$$\n尾部覆盖了从 $308$ 到 $312$ 的全局索引。比较过程如下：\n-   索引 $308$：比较 $A[308]$ 和 $B[308]$。它们相等（$308  m$）。这花费 $1$ 个周期。\n-   索引 $309$：比较 $A[309]$ 和 $B[309]$。它们相等（$309  m$）。这花费 $1$ 个周期。\n-   索引 $310$：比较 $A[310]$ 和 $B[310]$。发现不匹配（$310 = m$）。这花费 $1$ 个周期，`memcmp` 操作终止并返回。\n\n索引 $311$ 和 $312$ 的比较不会被执行。总的来说，在结语部分执行了 $3$ 次标量比较。比较的次数是 $(m - \\text{尾部起始索引}) + 1 = (310 - 308) + 1 = 3$。\n\n结语的成本 $C_{tail}$ 为：\n$$C_{tail} = 3 \\times C_{scalar} = 3 \\times 1 = 3 \\text{ 周期}$$\n\n**4. CPU总周期数**\n\nCPU总周期数是所有三个阶段的周期数之和：\n$$C_{total} = C_{head} + C_{loop} + C_{tail}$$\n$$C_{total} = 4 + 171 + 3 = 178$$\n\n直到操作在第一个不匹配处返回时所花费的CPU总周期数为 $178$。",
            "answer": "$$\\boxed{178}$$"
        }
    ]
}