{
    "hands_on_practices": [
        {
            "introduction": "Compilers often replace expensive operations with sequences of cheaper ones, a technique known as strength reduction. This practice challenges you to implement one of the most classic examples: replacing division by a constant with multiplication and bit shifts. By deriving the \"magic number\" from first principles , you will gain insight into how compilers use fixed-point arithmetic to perform integer operations efficiently and correctly.",
            "id": "3674285",
            "problem": "A compiler back end is being designed for an unsigned fixed-width target machine to eliminate divisions by invariant constants. The target machine model is as follows: the machine has word size $w = 32$; unsigned integer arithmetic is modulo $2^{w}$; an unsigned multiplication of two $w$-bit operands produces the full $2w$-bit product; the instruction $\\mathrm{mulhi}(x,y)$ returns the upper $w$ bits of the $2w$-bit product of $x$ and $y$; and a logical right shift by $k$ bits computes $\\left\\lfloor x / 2^{k} \\right\\rfloor$ for any nonnegative integer $k$.\n\nYou are to replace the unsigned division by a positive invariant constant $d$ with a sequence that uses a single multiplication by a precomputed integer “magic number” followed by a right shift. Specifically, for all unsigned $n \\in \\{0,1,\\dots,2^{w}-1\\}$, compute\n$$\nq(n) \\;=\\; \\left\\lfloor \\frac{n \\cdot m}{2^{w+s}} \\right\\rfloor \\,,\n$$\nusing the machine’s $\\mathrm{mulhi}$ and shift so that $q(n) = \\left\\lfloor \\frac{n}{d} \\right\\rfloor$ holds for every $n$.\n\nWork from first principles of integer division and fixed-point approximation to derive a sufficient condition under which such integers $m$ and $s$ exist and yield exact quotients for all $n$. Then, for the specific divisor $d = 10$ and $w = 32$, determine the smallest nonnegative shift $s$ for which such an $m$ exists, compute the corresponding integer $m$, and justify that your choice satisfies the derived condition for all $n \\in [0,2^{w}-1]$.\n\nYour final answer must be the ordered pair $\\big(m,s\\big)$. No approximation is required, and no units are involved. Express the pair as a single row in the order $\\big(m,s\\big)$.",
            "solution": "The problem requires us to replace unsigned integer division by a constant divisor $d$ with a multiplication by a \"magic number\" $m$ and a right shift. Specifically, we want to find integers $m$ and $s$ such that for a given word size $w$ and for all unsigned integers $n$ in the range $0 \\le n < 2^w$, the following equality holds:\n$$ \\left\\lfloor \\frac{n}{d} \\right\\rfloor = \\left\\lfloor \\frac{n \\cdot m}{2^{w+s}} \\right\\rfloor $$\nThe expression on the right is to be computed on a target machine where `mulhi(n, m)` calculates $\\lfloor (n \\cdot m) / 2^w \\rfloor$ and a right shift `>> s` calculates $\\lfloor x / 2^s \\rfloor$. The expression $\\lfloor \\frac{n \\cdot m}{2^{w+s}} \\rfloor$ can be computed as `(mulhi(n, m)) >> s`, which is $\\lfloor \\lfloor (n \\cdot m) / 2^w \\rfloor / 2^s \\rfloor$, and is equivalent to the desired expression due to the property of integer floors $\\lfloor \\lfloor x/a \\rfloor / b \\rfloor = \\lfloor x/(ab) \\rfloor$.\n\nFirst, we derive a sufficient condition for $m$ and $s$ to exist.\nLet the quotient be $q = \\lfloor n/d \\rfloor$ and the remainder be $r_n = n \\pmod d$, such that $n = qd + r_n$ where $0 \\le r_n < d$.\nThe equality we want to hold is $q = \\lfloor nm/2^{w+s} \\rfloor$. This equality is equivalent to the pair of inequalities:\n$$ q \\le \\frac{n \\cdot m}{2^{w+s}} < q+1 $$\nLet's choose our approximation $m/2^{w+s}$ to be slightly larger than $1/d$. This ensures the left-hand inequality is satisfied:\n$$ \\frac{m}{2^{w+s}} > \\frac{1}{d} \\implies \\frac{nm}{2^{w+s}} > \\frac{n}{d} $$\nSince $n/d \\ge \\lfloor n/d \\rfloor = q$, we have $\\frac{nm}{2^{w+s}} > q$. As the floor function is monotonic, $\\lfloor \\frac{nm}{2^{w+s}} \\rfloor \\ge q$. So, if we can guarantee that the quotient is never $q+1$ or greater, we are done.\n\nThe critical part is the right-hand inequality:\n$$ \\frac{n \\cdot m}{2^{w+s}} < q+1 $$\nLet us define the error of our approximation $\\epsilon = \\frac{m}{2^{w+s}} - \\frac{1}{d}$, where we have chosen $\\epsilon > 0$.\nSubstituting $m/2^{w+s}$ in the inequality gives:\n$$ n \\left( \\frac{1}{d} + \\epsilon \\right) < q+1 $$\n$$ \\frac{n}{d} + n\\epsilon < q+1 $$\nSubstituting $n=qd+r_n$:\n$$ \\frac{qd+r_n}{d} + n\\epsilon < q+1 $$\n$$ q + \\frac{r_n}{d} + n\\epsilon < q+1 $$\n$$ \\frac{r_n}{d} + n\\epsilon < 1 $$\nThis inequality must hold for all $n \\in \\{0, 1, \\dots, 2^w - 1\\}$.\nThe term $n\\epsilon$ is maximized for the largest value of $n$, which is $2^w-1$. The term $r_n/d = (n \\pmod d)/d$ can be as large as $(d-1)/d$. The worst case for the inequality is when $n\\epsilon$ is large and $r_n/d$ is large.\nA strict requirement that covers all cases is:\n$$ n\\epsilon < 1 - \\frac{n \\pmod d}{d} = \\frac{d - (n \\pmod d)}{d} $$\nThe left side is maximized when $n$ is maximal ($n=2^w-1$). The right side is minimized when $n \\pmod d$ is maximal ($n \\pmod d = d-1$). So, a sufficient condition to satisfy the inequality for all $n$ is to satisfy it for a combination of worst-case parameters:\n$$ (2^w-1)\\epsilon < \\frac{d-(d-1)}{d} = \\frac{1}{d} $$\nSubstituting back $\\epsilon = \\frac{m}{2^{w+s}} - \\frac{1}{d}$:\n$$ (2^w-1) \\left( \\frac{m}{2^{w+s}} - \\frac{1}{d} \\right) < \\frac{1}{d} $$\n$$ (2^w-1) \\left( \\frac{md - 2^{w+s}}{d \\cdot 2^{w+s}} \\right) < \\frac{1}{d} $$\n$$ (2^w-1)(md - 2^{w+s}) < 2^{w+s} $$\nWe now must choose $m$. A good choice for $m$ that satisfies $m/2^{w+s} > 1/d$ is $m = \\lfloor 2^{w+s}/d \\rfloor + 1$.\nLet $r_s = 2^{w+s} \\pmod d$. Then $2^{w+s} = d \\cdot \\lfloor 2^{w+s}/d \\rfloor + r_s$.\nOur choice of $m$ becomes $m = \\frac{2^{w+s}-r_s}{d} + 1$.\nFrom this, we can express $md-2^{w+s}$:\n$$ md - 2^{w+s} = (2^{w+s} - r_s + d) - 2^{w+s} = d - r_s $$\nSubstituting this into our sufficient condition:\n$$ (2^w-1)(d - r_s) < 2^{w+s} $$\nThis is a sufficient condition on $s$. We seek the smallest non-negative integer $s$ that satisfies it.\nA slightly stronger, but simpler, condition can be derived. Since $d-r_s > 0$ (for $d$ not a power of $2$), we can write:\n$2^w(d-r_s) - (d-r_s) < 2^{w+s}$.\nIf we satisfy $2^w(d-r_s) \\le 2^{w+s}$, the previous inequality will also hold, since $d-r_s \\ge 1$ (as $r_s \\le d-1$).\nThe simpler condition is $2^w(d-r_s) \\le 2^{w+s}$, which simplifies to:\n$$ d - (2^{w+s} \\pmod d) \\le 2^s $$\nThis is a sufficient condition to find a suitable shift $s$. If such an $s$ exists, $m$ is determined by $m = \\lfloor 2^{w+s}/d \\rfloor + 1$.\n\nNow, we apply this to the specific problem with $d=10$ and $w=32$. We need to find the smallest non-negative integer $s$ that satisfies:\n$$ 10 - (2^{32+s} \\pmod{10}) \\le 2^s $$\nLet's analyze the term $r_s = 2^{32+s} \\pmod{10}$. The powers of $2$ modulo $10$ cycle with a period of $4$: $(2, 4, 8, 6)$.\nFor an exponent $E \\ge 1$, $2^E \\pmod{10}$ depends on $E \\pmod 4$.\nThe exponent is $32+s$. Since $32$ is a multiple of $4$, $2^{32} \\pmod{10} = 6$.\nSo for $s=0, 1, 2, 3, \\dots$, the sequence $r_s = 2^{32+s} \\pmod{10}$ is $6, 2, 4, 8, 6, \\dots$.\nWe test values of $s$ beginning with $s=0$:\n\\begin{itemize}\n    \\item For $s=0$: $r_0 = 6$. The condition is $10 - 6 \\le 2^0 \\implies 4 \\le 1$, which is false.\n    \\item For $s=1$: $r_1 = 2$. The condition is $10 - 2 \\le 2^1 \\implies 8 \\le 2$, which is false.\n    \\item For $s=2$: $r_2 = 4$. The condition is $10 - 4 \\le 2^2 \\implies 6 \\le 4$, which is false.\n    \\item For $s=3$: $r_3 = 8$. The condition is $10 - 8 \\le 2^3 \\implies 2 \\le 8$, which is true.\n\\end{itemize}\nThe smallest non-negative integer shift is $s=3$.\n\nNow we compute the corresponding magic number $m$ for $s=3$:\n$$ m = \\left\\lfloor \\frac{2^{32+3}}{10} \\right\\rfloor + 1 = \\left\\lfloor \\frac{2^{35}}{10} \\right\\rfloor + 1 $$\nWe calculate $2^{35}$:\n$2^{10} = 1024$.\n$2^{32} = 2^2 \\cdot (2^{10})^3 = 4 \\cdot (1024)^3 = 4 \\cdot 1073741824 = 4294967296$.\n$2^{35} = 2^3 \\cdot 2^{32} = 8 \\cdot 4294967296 = 34359738368$.\nNow, we compute $m$:\n$$ m = \\left\\lfloor \\frac{34359738368}{10} \\right\\rfloor + 1 = \\lfloor 3435973836.8 \\rfloor + 1 = 3435973836 + 1 = 3435973837 $$\nThe value of $m$ must fit into a $w$-bit unsigned integer, i.e., $m < 2^w = 2^{32}$.\n$m = 3435973837$.\n$2^{32} - 1 = 4294967295$.\nSince $3435973837 < 4294967295$, the magic number $m$ fits within the machine's word size.\n\nOur derived sufficient condition is satisfied for $s=3$. By construction, the pair $(m, s) = (3435973837, 3)$ guarantees that the computation $\\lfloor (n \\cdot m) / 2^{w+s} \\rfloor$ correctly yields $\\lfloor n/d \\rfloor$ for all unsigned $32$-bit integers $n$.\n\nThe final answer is the ordered pair $(m, s)$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 3435973837 & 3 \\end{pmatrix} } $$"
        },
        {
            "introduction": "The physical layout of code in memory can significantly impact performance, primarily due to branch prediction. In this exercise, you will model a simple processor's static branch predictor and misprediction penalty to optimize the ordering of basic blocks. This task demonstrates how compilers use probabilistic models of program behavior to make layout decisions that minimize expected execution time .",
            "id": "3674228",
            "problem": "You are modeling a simple target machine to guide basic block ordering. The machine model has the following properties:\n- The processor executes a conditional branch with a fixed base cost of $b$ cycles, independent of the outcome. A conditional branch is statically predicted to follow the fall-through path, which is the basic block that is laid out immediately after the branch. If the actual next block at runtime is not the fall-through, an additional misprediction penalty of $M$ cycles is incurred for that dynamic branch.\n- There is no cost for an unconditional fall-through; there are no other penalties in this model beyond those stated.\n- The expected execution time is the expected value of the sum of the cycles of all executed blocks and branch overheads.\n\nConsider a function with the following control-flow graph (CFG). Let $E$ denote the entry block. Block $E$ ends with a conditional branch that goes to block $A$ with probability $p$ and to block $B$ with probability $1-p$. Block $A$ ends with a conditional branch that goes to a join block $J$ with probability $q_A$ and to a return block $R_A$ with probability $1-q_A$. Similarly, block $B$ ends with a conditional branch that goes to $J$ with probability $q_B$ and to a return block $R_B$ with probability $1-q_B$. Blocks $J$, $R_A$, and $R_B$ return and have no outgoing edges.\n\nThe compile-time layout is a single linear order of basic blocks. For a conditional branch, whichever successor block is placed immediately next in the order is its fall-through and hence is predicted by the hardware. The other successor is reached by taking the branch (still costing $b$ to execute the branch itself), and a misprediction penalty $M$ is paid exactly when the actual successor is not the fall-through. You may invert branch conditions freely at no extra cost. The join block $J$ can be placed immediately after at most one of $A$ or $B$ (because the layout is linear), but it need not be immediately after either.\n\nMachine and program parameters are:\n- Per-block compute costs (excluding any branch overhead): $c_E = 5$, $c_A = 8$, $c_B = 6$, $c_J = 4$, $c_{R_A} = 1$, $c_{R_B} = 1$ (all in cycles).\n- Base conditional-branch cost: $b = 1$ (cycles).\n- Probabilities: $p = 0.6$, $q_A = 0.8$, $q_B = 0.7$.\n\nTask: Using first principles (linearity of expectation and the definition of the misprediction event under a static fall-through predictor), determine the basic block order (i.e., choose the fall-through successors for the branches in $E$, $A$, and $B$ subject to the linear layout constraints) that minimizes the expected cycles per function execution. Then, express the minimal expected cycles per function execution as a closed-form function of $M$. Do not introduce any additional costs beyond those stated. Provide your final answer as a single analytic expression in terms of $M$. No units are required. Do not round; give the exact expression.",
            "solution": "The problem asks for the minimal expected execution time of a function, expressed as a function of the misprediction penalty $M$. The optimization is to be achieved by choosing an optimal linear layout of the basic blocks, which in turn determines the statically predicted fall-through path for each conditional branch.\n\nFirst, we establish the objective function, which is the total expected execution time, $E[T]$. By the linearity of expectation, we can express this as the sum of the expected costs of executing the basic blocks and the expected overhead costs from the branches.\n$$E[T] = E[C_{\\text{blocks}}] + E[C_{\\text{branch}}]$$\n\nLet us calculate the expected cost from basic block computations, $E[C_{\\text{blocks}}]$. This cost is independent of the block layout.\nA block $X$ with computation cost $c_X$ is executed with some probability $P(X)$. The expected cost is $\\sum_X P(X) c_X$.\nThe probabilities of executing each block are:\n- $P(E) = 1$\n- $P(A) = p$\n- $P(B) = 1-p$\n- $P(J) = P(E \\to A \\to J) + P(E \\to B \\to J) = p q_A + (1-p) q_B$\n- $P(R_A) = P(E \\to A \\to R_A) = p(1-q_A)$\n- $P(R_B) = P(E \\to B \\to R_B) = (1-p)(1-q_B)$\n\nSubstituting the given values $p=0.6$, $q_A=0.8$, $q_B=0.7$, and the block costs $c_E=5$, $c_A=8$, $c_B=6$, $c_J=4$, $c_{R_A}=1$, $c_{R_B}=1$:\n- $P(A) = 0.6$\n- $P(B) = 0.4$\n- $P(J) = (0.6)(0.8) + (0.4)(0.7) = 0.48 + 0.28 = 0.76$\n- $P(R_A) = (0.6)(1-0.8) = 0.12$\n- $P(R_B) = (0.4)(1-0.7) = 0.12$\n\nThe expected block computation cost is:\n$$E[C_{\\text{blocks}}] = P(E)c_E + P(A)c_A + P(B)c_B + P(J)c_J + P(R_A)c_{R_A} + P(R_B)c_{R_B}$$\n$$E[C_{\\text{blocks}}] = 1(5) + (0.6)(8) + (0.4)(6) + (0.76)(4) + (0.12)(1) + (0.12)(1)$$\n$$E[C_{\\text{blocks}}] = 5 + 4.8 + 2.4 + 3.04 + 0.12 + 0.12 = 15.48$$\n\nNext, we analyze the expected branch overhead, $E[C_{\\text{branch}}]$. The model states that each executed conditional branch has a base cost of $b$ cycles and an additional misprediction penalty of $M$ cycles if the taken path is not the statically predicted fall-through path. The problem states we can invert branch conditions freely, which means for any branch, we can choose which of its two successors becomes the fall-through path by arranging the layout, and the goal is to choose the fall-through to minimize the expected misprediction penalty.\n\nThe total expected branch cost is the sum of costs from the branches at $E$, $A$, and $B$, weighted by their execution probabilities.\n$$E[C_{\\text{branch}}] = E[C_{\\text{branch},E}] + E[C_{\\text{branch},A}] + E[C_{\\text{branch},B}]$$\nThe branch at $E$ is always executed. The branch at $A$ is executed with probability $p$. The branch at $B$ is executed with probability $1-p$.\nThe overhead for a single branch consists of the base cost $b$ and a potential misprediction penalty $M$.\nThe total expected base cost is $1 \\cdot b + p \\cdot b + (1-p) \\cdot b = 2b = 2(1) = 2$.\nThe total expected misprediction penalty, $E[C_{\\text{penalty}}]$, is what we need to minimize through layout choices.\n$$E[C_{\\text{penalty}}] = M \\left( P(\\text{mispredict at E}) + p \\cdot P(\\text{mispredict at A}) + (1-p) \\cdot P(\\text{mispredict at B}) \\right)$$\nTo minimize the penalty for a single branch, we must choose the more probable successor as the fall-through.\n- **Branch from E:** Successors are $A$ (prob $p=0.6$) and $B$ (prob $1-p=0.4$). To minimize penalty, $A$ should be the fall-through. This is always possible. The misprediction probability is $1-p=0.4$.\n- **Branch from A:** Successors are $J$ (prob $q_A=0.8$) and $R_A$ (prob $1-q_A=0.2$). To minimize penalty, $J$ should be the fall-through. This requires the layout `...; A; J; ...`.\n- **Branch from B:** Successors are $J$ (prob $q_B=0.7$) and $R_B$ (prob $1-q_B=0.3$). To minimize penalty, $J$ should be the fall-through. This requires the layout `...; B; J; ...`.\n\nThe core constraint is that the layout is linear. A block can have only one immediate successor. Therefore, block $J$ cannot be the fall-through successor for both block $A$ and block $B$. This means we cannot simultaneously satisfy the optimal fall-through choices for the branches at $A$ and $B$. We must make a suboptimal choice for one of them.\n\nWe must compare two main strategies, assuming we always make the optimal choice for the branch at $E$ (fall-through to $A$), which is unconstrained.\n**Strategy 1:** Prioritize the branch at $A$. Set the fall-through for $A$ to be $J$. This forces the fall-through for $B$ to be $R_B$ (the less likely path).\nThe layout choices are:\n- Branch E: Fall-through is $A$ (optimal). Misprediction prob: $1-p=0.4$.\n- Branch A: Fall-through is $J$ (optimal). Misprediction prob: $1-q_A=0.2$.\n- Branch B: Fall-through is $R_B$ (suboptimal). Misprediction prob: $q_B=0.7$.\nThe total expected number of mispredictions, $N_1$, is:\n$$N_1 = (1-p) + p(1-q_A) + (1-p)q_B$$\n$$N_1 = 0.4 + (0.6)(0.2) + (0.4)(0.7) = 0.4 + 0.12 + 0.28 = 0.80$$\n\n**Strategy 2:** Prioritize the branch at $B$. Set the fall-through for $B$ to be $J$. This forces the fall-through for $A$ to be $R_A$ (the less likely path).\nThe layout choices are:\n- Branch E: Fall-through is $A$ (optimal). Misprediction prob: $1-p=0.4$.\n- Branch A: Fall-through is $R_A$ (suboptimal). Misprediction prob: $q_A=0.8$.\n- Branch B: Fall-through is $J$ (optimal). Misprediction prob: $1-q_B=0.3$.\nThe total expected number of mispredictions, $N_2$, is:\n$$N_2 = (1-p) + p(q_A) + (1-p)(1-q_B)$$\n$$N_2 = 0.4 + (0.6)(0.8) + (0.4)(0.3) = 0.4 + 0.48 + 0.12 = 1.00$$\n\nComparing the two strategies, $N_1 = 0.80$ is less than $N_2 = 1.00$. Therefore, Strategy 1 yields the minimal expected misprediction penalty. This penalty is $E[C_{\\text{penalty}}]_{\\text{min}} = N_1 M = 0.8M$.\n\nThe minimal total expected execution time is the sum of the constant costs and this minimal penalty.\n$$E[T]_{\\text{min}} = E[C_{\\text{blocks}}] + E[C_{\\text{base branch}}] + E[C_{\\text{penalty}}]_{\\text{min}}$$\n$$E[T]_{\\text{min}} = 15.48 + 2b + 0.8M$$\nWith $b=1$:\n$$E[T]_{\\text{min}} = 15.48 + 2 + 0.8M$$\n$$E[T]_{\\text{min}} = 17.48 + 0.8M$$\nTo express this with exact fractions:\n$17.48 = \\frac{1748}{100} = \\frac{437}{25}$.\n$0.8 = \\frac{8}{10} = \\frac{4}{5}$.\nSo, the minimal expected cycles per execution is $\\frac{437}{25} + \\frac{4}{5}M$. The decimal form is equally exact.",
            "answer": "$$\\boxed{17.48 + 0.8M}$$"
        },
        {
            "introduction": "On a Very Long Instruction Word (VLIW) machine, the compiler is fully responsible for scheduling parallel operations, a task that requires a precise resource model. This problem abstracts the machine's capabilities and each operation's needs into resource vectors, transforming the scheduling task into a constrained packing problem. By finding the optimal packing , you will practice reasoning about resource-constrained scheduling, a core task in compiling for parallel hardware.",
            "id": "3674283",
            "problem": "A Very Long Instruction Word (VLIW) target machine is modeled by a bundle feasibility constraint on discrete resources. Each cycle issues a bundle that occupies a set of issue slots and consumes functional unit capacity. Let the per-bundle capacity vector be\n$$\n\\mathbf{c} = \\begin{pmatrix} 2 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix},\n$$\nwhose coordinates correspond respectively to Integer Arithmetic Logic Units ($I$), Floating-Point units ($F$), Memory ports ($M$), and issue slots $s_1$, $s_2$, $s_3$, $s_4$. An operation $i$ is described by a nonnegative integer resource-usage vector $r_i \\in \\mathbb{N}^7$ with the same coordinate ordering, and a bundle is feasible if, for every resource dimension, the sum of demands of the operations assigned to that bundle does not exceed the corresponding capacity in $\\mathbf{c}$.\n\nConsider the following set of operations $\\{o_1,o_2,\\dots,o_{10}\\}$, with resource-usage vectors\n$$\nr_1 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix},\\quad\nr_2 = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix},\\quad\nr_3 = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix},\\quad\nr_4 = \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix},\n$$\n$$\nr_5 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix},\\quad\nr_6 = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix},\\quad\nr_7 = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix},\\quad\nr_8 = \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix},\n$$\n$$\nr_9 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix},\\quad\nr_{10} = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix}.\n$$\nEach operation occupies exactly one issue slot as indicated by the $s_j$ coordinates and may consume one of the functional unit capacities $I$, $F$, or $M$.\n\nPack these operations into the minimum number of feasible bundles under the above model. Report the minimal number of bundles as a single real-valued number. If you use any approximation in intermediate reasoning, ensure that the final reported number is exact. No units are required in the final answer.",
            "solution": "The problem is to schedule a set of 10 operations into the minimum number of bundles on a Very Long Instruction Word (VLIW) machine, subject to resource constraints. This is an instance of a multi-dimensional bin packing problem.\n\nFirst, we categorize the operations by their resource usage:\n-   **Type A:** 3 operations, $\\{o_1, o_5, o_9\\}$, each consuming 1 Integer unit and 1 $s_1$ slot. $r_A = (1,0,0,1,0,0,0)^T$.\n-   **Type B:** 3 operations, $\\{o_2, o_6, o_{10}\\}$, each consuming 1 Integer unit and 1 $s_2$ slot. $r_B = (1,0,0,0,1,0,0)^T$.\n-   **Type C:** 2 operations, $\\{o_3, o_7\\}$, each consuming 1 Floating-Point unit and 1 $s_3$ slot. $r_C = (0,1,0,0,0,1,0)^T$.\n-   **Type D:** 2 operations, $\\{o_4, o_8\\}$, each consuming 1 Memory port and 1 $s_4$ slot. $r_D = (0,0,1,0,0,0,1)^T$.\n\nThe per-bundle resource capacity vector is $\\mathbf{c} = (2, 1, 1, 1, 1, 1, 1)^T$, corresponding to resources $(I, F, M, s_1, s_2, s_3, s_4)$.\n\nTo find the minimum number of bundles, we first establish a lower bound. The number of bundles must be at least the total demand for any single resource divided by the per-bundle capacity for that resource, rounded up.\n\nLet's calculate the total demand for each resource:\n-   **Total I demand:** $3 \\times 1 + 3 \\times 1 = 6$.\n-   **Total F demand:** $2 \\times 1 = 2$.\n-   **Total M demand:** $2 \\times 1 = 2$.\n-   **Total $s_1$ demand:** $3 \\times 1 = 3$.\n-   **Total $s_2$ demand:** $3 \\times 1 = 3$.\n-   **Total $s_3$ demand:** $2 \\times 1 = 2$.\n-   **Total $s_4$ demand:** $2 \\times 1 = 2$.\n\nNow, we calculate the lower bound based on each resource constraint:\n-   Bundles for $I$ units: $\\lceil 6 / 2 \\rceil = 3$.\n-   Bundles for $F$ units: $\\lceil 2 / 1 \\rceil = 2$.\n-   Bundles for $M$ ports: $\\lceil 2 / 1 \\rceil = 2$.\n-   Bundles for $s_1$ slots: $\\lceil 3 / 1 \\rceil = 3$.\n-   Bundles for $s_2$ slots: $\\lceil 3 / 1 \\rceil = 3$.\n-   Bundles for $s_3$ slots: $\\lceil 2 / 1 \\rceil = 2$.\n-   Bundles for $s_4$ slots: $\\lceil 2 / 1 \\rceil = 2$.\n\nThe overall lower bound is the maximum of these individual bounds:\n$$ \\text{Minimum bundles} \\ge \\max(3, 2, 2, 3, 3, 2, 2) = 3 $$\nSo, we need at least 3 bundles. The next step is to see if a feasible schedule with 3 bundles can be constructed.\n\nLet's attempt a greedy packing strategy.\n**Bundle 1:**\nLet's try to pack one of each type of operation: one Type A ($o_1$), one Type B ($o_2$), one Type C ($o_3$), and one Type D ($o_4$).\nThe combined resource vector is $r_1 + r_2 + r_3 + r_4$:\n$$ \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}2\\\\1\\\\1\\\\1\\\\1\\\\1\\\\1\\end{pmatrix} $$\nThis vector is equal to the capacity vector $\\mathbf{c}$, so this bundle is feasible.\n*Operations remaining:* 2 Type A, 2 Type B, 1 Type C, 1 Type D.\n\n**Bundle 2:**\nWe repeat the same strategy with the remaining operations. Let's pack $\\{o_5, o_6, o_7, o_8\\}$.\nThe combined resource vector is $r_5 + r_6 + r_7 + r_8$, which is identical in structure to the first bundle.\n$$ \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}2\\\\1\\\\1\\\\1\\\\1\\\\1\\\\1\\end{pmatrix} $$\nThis bundle is also feasible.\n*Operations remaining:* 1 Type A ($o_9$), 1 Type B ($o_{10}$), 0 Type C, 0 Type D.\n\n**Bundle 3:**\nThe remaining operations are $\\{o_9, o_{10}\\}$. Let's check their feasibility.\nThe combined resource vector is $r_9 + r_{10}$:\n$$ \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix} = \\begin{pmatrix}2\\\\0\\\\0\\\\1\\\\1\\\\0\\\\0\\end{pmatrix} $$\nComparing this to the capacity vector $\\mathbf{c} = (2, 1, 1, 1, 1, 1, 1)^T$:\n- $I$: $2 \\le 2$ (OK)\n- $F$: $0 \\le 1$ (OK)\n- $M$: $0 \\le 1$ (OK)\n- $s_1$: $1 \\le 1$ (OK)\n- $s_2$: $1 \\le 1$ (OK)\n- $s_3$: $0 \\le 1$ (OK)\n- $s_4$: $0 \\le 1$ (OK)\nAll resource usages are within capacity. This bundle is feasible.\n\nWe have successfully scheduled all 10 operations into 3 feasible bundles. Since our theoretical lower bound was 3, this is the optimal solution.\n- **Bundle 1:** $\\{o_1, o_2, o_3, o_4\\}$\n- **Bundle 2:** $\\{o_5, o_6, o_7, o_8\\}$\n- **Bundle 3:** $\\{o_9, o_{10}\\}$\n\nThe minimum number of bundles required is 3.",
            "answer": "$$\\boxed{3}$$"
        }
    ]
}