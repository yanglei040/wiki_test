{
    "hands_on_practices": [
        {
            "introduction": "优秀的编译器不仅仅是高级语言的直译器，更是代码的优化大师。一个经典的优化技术是“强度削减”，即将高开销的运算（如整数除法）替换为目标机器上更高效的指令序列（如乘法和移位）。本练习  将带你亲手实践这一过程，通过对目标机器整数运算的精确建模，为常量除法推导出对应的“魔数”和移位量，让你深入理解编译器如何利用硬件特性将理论转化为实际的性能提升。",
            "id": "3674285",
            "problem": "我们正在为一台无符号定宽目标机设计编译器后端，以消除对不变常量的除法运算。该目标机模型如下：机器字长为 $w = 32$；无符号整数运算以 $2^{w}$ 为模；两个 $w$ 位操作数的无符号乘法产生完整的 $2w$ 位乘积；指令 $\\mathrm{mulhi}(x,y)$ 返回 $x$ 和 $y$ 的 $2w$ 位乘积的高 $w$ 位；逻辑右移 $k$ 位计算 $\\left\\lfloor x / 2^{k} \\right\\rfloor$，其中 $k$ 为任意非负整数。\n\n你的任务是将一个正不变常量 $d$ 的无符号除法替换为一个序列，该序列使用一次与预计算的整数“魔数”的乘法，然后进行一次右移。具体来说，对所有无符号整数 $n \\in \\{0,1,\\dots,2^{w}-1\\}$，计算\n$$\nq(n) \\;=\\; \\left\\lfloor \\frac{n \\cdot m}{2^{w+s}} \\right\\rfloor \\,,\n$$\n使用机器的 $\\mathrm{mulhi}$ 和移位指令，使得 $q(n) = \\left\\lfloor \\frac{n}{d} \\right\\rfloor$ 对每个 $n$ 都成立。\n\n请从整数除法和定点近似的第一性原理出发，推导出一个充分条件，在该条件下，这样的整数 $m$ 和 $s$ 存在，并且对所有的 $n$ 都能产生精确的商。然后，对于特定的除数 $d = 10$ 和 $w = 32$，确定最小的非负移位数 $s$ 使得存在这样的 $m$，计算相应的整数 $m$，并证明你的选择对所有 $n \\in [0,2^{w}-1]$ 都满足所推导的条件。\n\n你的最终答案必须是有序对 $\\big(m,s\\big)$。不需要近似，也不涉及单位。将该数对表示为单行，顺序为 $\\big(m,s\\big)$。",
            "solution": "问题要求我们将一个常量除数 $d$ 的无符号整数除法替换为一个与“魔数” $m$ 的乘法和一次右移。具体来说，我们要寻找整数 $m$ 和 $s$，使得对于给定的字长 $w$ 和所有范围在 $0 \\le n  2^w$ 内的无符号整数 $n$，以下等式成立：\n$$ \\left\\lfloor \\frac{n}{d} \\right\\rfloor = \\left\\lfloor \\frac{n \\cdot m}{2^{w+s}} \\right\\rfloor $$\n右侧的表达式将在目标机上计算，其中 `mulhi(n, m)` 计算 $\\lfloor (n \\cdot m) / 2^w \\rfloor$，而右移 `>> s` 计算 $\\lfloor x / 2^s \\rfloor$。表达式 $\\lfloor \\frac{n \\cdot m}{2^{w+s}} \\rfloor$ 可以计算为 `(mulhi(n, m)) >> s`，也就是 $\\lfloor \\lfloor (n \\cdot m) / 2^w \\rfloor / 2^s \\rfloor$，根据整数向下取整的性质 $\\lfloor \\lfloor x/a \\rfloor / b \\rfloor = \\lfloor x/(ab) \\rfloor$，这等价于我们想要的表达式。\n\n首先，我们推导 $m$ 和 $s$ 存在的充分条件。\n设商为 $q = \\lfloor n/d \\rfloor$，余数为 $r_n = n \\pmod d$，因此 $n = qd + r_n$ 且 $0 \\le r_n  d$。\n我们希望成立的等式是 $q = \\lfloor nm/2^{w+s} \\rfloor$。这个等式等价于以下不等式对：\n$$ q \\le \\frac{n \\cdot m}{2^{w+s}}  q+1 $$\n我们选择的近似值 $m/2^{w+s}$ 略大于 $1/d$。这能确保左侧的不等式成立：\n$$ \\frac{m}{2^{w+s}} > \\frac{1}{d} \\implies \\frac{nm}{2^{w+s}} > \\frac{n}{d} $$\n由于 $n/d \\ge \\lfloor n/d \\rfloor = q$，我们有 $\\frac{nm}{2^{w+s}} > q$。由于向下取整函数是单调的，$\\lfloor \\frac{nm}{2^{w+s}} \\rfloor \\ge q$。因此，如果我们能保证商永远不会是 $q+1$ 或更大，那么问题就解决了。\n\n关键部分是右侧的不等式：\n$$ \\frac{n \\cdot m}{2^{w+s}}  q+1 $$\n我们定义近似的误差为 $\\epsilon = \\frac{m}{2^{w+s}} - \\frac{1}{d}$，其中我们选择了 $\\epsilon > 0$。\n将 $m/2^{w+s}$ 代入不等式得到：\n$$ n \\left( \\frac{1}{d} + \\epsilon \\right)  q+1 $$\n$$ \\frac{n}{d} + n\\epsilon  q+1 $$\n代入 $n=qd+r_n$：\n$$ \\frac{qd+r_n}{d} + n\\epsilon  q+1 $$\n$$ q + \\frac{r_n}{d} + n\\epsilon  q+1 $$\n$$ \\frac{r_n}{d} + n\\epsilon  1 $$\n这个不等式必须对所有 $n \\in \\{0, 1, \\dots, 2^w - 1\\}$ 成立。\n项 $n\\epsilon$ 在 $n$ 取最大值 $2^w-1$ 时最大。项 $r_n/d = (n \\pmod d)/d$ 最大可达 $(d-1)/d$。不等式的最坏情况是当 $n\\epsilon$ 很大且 $r_n/d$ 也很大时。\n一个覆盖所有情况的严格要求是：\n$$ n\\epsilon  1 - \\frac{n \\pmod d}{d} = \\frac{d - (n \\pmod d)}{d} $$\n左边在 $n$ 最大时（$n=2^w-1$）取最大值。右边在 $n \\pmod d$ 最大时（$n \\pmod d = d-1$）取最小值。因此，要使不等式对所有 $n$ 成立，一个充分条件是它对最坏情况参数的组合成立：\n$$ (2^w-1)\\epsilon  \\frac{d-(d-1)}{d} = \\frac{1}{d} $$\n将 $\\epsilon = \\frac{m}{2^{w+s}} - \\frac{1}{d}$ 代回：\n$$ (2^w-1) \\left( \\frac{m}{2^{w+s}} - \\frac{1}{d} \\right)  \\frac{1}{d} $$\n$$ (2^w-1) \\left( \\frac{md - 2^{w+s}}{d \\cdot 2^{w+s}} \\right)  \\frac{1}{d} $$\n$$ (2^w-1)(md - 2^{w+s})  2^{w+s} $$\n现在我们必须选择 $m$。一个满足 $m/2^{w+s} > 1/d$ 的好的选择是 $m = \\lfloor 2^{w+s}/d \\rfloor + 1$。\n设 $r_s = 2^{w+s} \\pmod d$。那么 $2^{w+s} = d \\cdot \\lfloor 2^{w+s}/d \\rfloor + r_s$。\n我们对 $m$ 的选择变为 $m = \\frac{2^{w+s}-r_s}{d} + 1$。\n由此，我们可以表示 $md-2^{w+s}$：\n$$ md - 2^{w+s} = (2^{w+s} - r_s + d) - 2^{w+s} = d - r_s $$\n将此代入我们的充分条件：\n$$ (2^w-1)(d - r_s)  2^{w+s} $$\n这是一个关于 $s$ 的充分条件。我们寻找满足它的最小非负整数 $s$。\n可以推导出一个稍强但更简单的条件。由于 $d-r_s > 0$（对于非2的幂的$d$），我们可以写成：\n$2^w(d-r_s) - (d-r_s)  2^{w+s}$。\n如果我们满足 $2^w(d-r_s) \\le 2^{w+s}$，那么前一个不等式也将成立，因为 $d-r_s \\ge 1$（由于 $r_s \\le d-1$）。\n更简单的条件是 $2^w(d-r_s) \\le 2^{w+s}$，可简化为：\n$$ d - (2^{w+s} \\pmod d) \\le 2^s $$\n这是一个寻找合适移位数 $s$ 的充分条件。如果存在这样的 $s$，$m$ 就由 $m = \\lfloor 2^{w+s}/d \\rfloor + 1$ 确定。\n\n现在，我们将此应用于 $d=10$ 和 $w=32$ 的具体问题。我们需要找到满足以下条件的最小非负整数 $s$：\n$$ 10 - (2^{32+s} \\pmod{10}) \\le 2^s $$\n我们来分析 $r_s = 2^{32+s} \\pmod{10}$ 这一项。$2$ 的幂对 $10$ 取模的周期为 $4$：$(2, 4, 8, 6)$。\n对于指数 $E \\ge 1$，$2^E \\pmod{10}$ 取决于 $E \\pmod 4$。\n指数是 $32+s$。由于 $32$ 是 $4$ 的倍数，所以对于 $k \\ge 1$，$2^{4k} \\pmod{10} = 6$。\n$2^{32} = (2^4)^8 \\implies 2^{32} \\pmod{10} = 6^8 \\pmod{10} = 6$。\n所以对于 $s=0, 1, 2, 3, \\dots$，序列 $r_s = 2^{32+s} \\pmod{10}$ 是 $6, 2, 4, 8, 6, \\dots$。\n我们从 $s=0$ 开始测试 $s$ 的值：\n\\begin{itemize}\n    \\item 对于 $s=0$：$r_0 = 6$。条件是 $10 - 6 \\le 2^0 \\implies 4 \\le 1$，不成立。\n    \\item 对于 $s=1$：$r_1 = 2$。条件是 $10 - 2 \\le 2^1 \\implies 8 \\le 2$，不成立。\n    \\item 对于 $s=2$：$r_2 = 4$。条件是 $10 - 4 \\le 2^2 \\implies 6 \\le 4$，不成立。\n    \\item 对于 $s=3$：$r_3 = 8$。条件是 $10 - 8 \\le 2^3 \\implies 2 \\le 8$，成立。\n\\end{itemize}\n最小的非负整数移位数是 $s=3$。\n\n现在我们为 $s=3$ 计算对应的魔数 $m$：\n$$ m = \\left\\lfloor \\frac{2^{32+3}}{10} \\right\\rfloor + 1 = \\left\\lfloor \\frac{2^{35}}{10} \\right\\rfloor + 1 $$\n我们计算 $2^{35}$：\n$2^{10} = 1024$。\n$2^{32} = 2^2 \\cdot (2^{10})^3 = 4 \\cdot (1024)^3 = 4 \\cdot 1073741824 = 4294967296$。\n$2^{35} = 2^3 \\cdot 2^{32} = 8 \\cdot 4294967296 = 34359738368$。\n现在，我们计算 $m$：\n$$ m = \\left\\lfloor \\frac{34359738368}{10} \\right\\rfloor + 1 = \\lfloor 3435973836.8 \\rfloor + 1 = 3435973836 + 1 = 3435973837 $$\n$m$ 的值必须能放入一个 $w$ 位的无符号整数中，即 $m  2^w = 2^{32}$。\n$m = 3435973837$。\n$2^{32} - 1 = 4294967295$。\n由于 $3435973837  4294967295$，魔数 $m$ 在机器的字长范围内。\n\n我们推导的充分条件对于 $s=3$ 是满足的。根据构造，数对 $(m, s) = (3435973837, 3)$ 保证了对于所有无符号 $32$ 位整数 $n$，计算 $\\lfloor (n \\cdot m) / 2^{w+s} \\rfloor$ 都能正确地得到 $\\lfloor n/d \\rfloor$。\n\n最终答案是有序对 $(m, s)$。",
            "answer": "$$ \\boxed{ (3435973837, 3) } $$"
        },
        {
            "introduction": "现代处理器通常具备同时执行多条指令的能力，即指令级并行（ILP）。为了充分挖掘这种并行性，编译器必须扮演一个智能的“打包工”，将无依赖的指令合理地捆绑在一起执行。本练习  引入了一种形式化的目标机模型——资源向量，它精确描述了超长指令字（VLIW）架构中每个指令对功能单元和发射槽的占用情况。通过解决这个“箱子打包”问题，你将学会如何在资源受限的条件下，为一组给定的操作找到最紧凑的调度方案。",
            "id": "3674283",
            "problem": "一个超长指令字 (VLIW) 目标机器通过对离散资源的指令束可行性约束进行建模。每个周期发出一个指令束，该指令束占据一组发射槽并消耗功能单元的容量。设每个指令束的容量向量为\n$$\n\\mathbf{c} = \\begin{pmatrix} 2 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix},\n$$\n其坐标分别对应整数算术逻辑单元 ($I$)、浮点单元 ($F$)、内存端口 ($M$) 以及发射槽 $s_1$、$s_2$、$s_3$、$s_4$。一个操作 $i$ 由一个具有相同坐标顺序的非负整数资源使用向量 $r_i \\in \\mathbb{N}^7$ 描述。如果对于每个资源维度，分配给某个指令束的操作的需求总和不超过 $\\mathbf{c}$ 中相应的容量，则该指令束是可行的。\n\n考虑以下操作集合 $\\{o_1,o_2,\\dots,o_{10}\\}$，其资源使用向量为\n$$\nr_1 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix},\\quad\nr_2 = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix},\\quad\nr_3 = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix},\\quad\nr_4 = \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix},\n$$\n$$\nr_5 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix},\\quad\nr_6 = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix},\\quad\nr_7 = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix},\\quad\nr_8 = \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix},\n$$\n$$\nr_9 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix},\\quad\nr_{10} = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix}.\n$$\n如 $s_j$ 坐标所示，每个操作恰好占据一个发射槽，并可能消耗 $I$、$F$ 或 $M$ 中的一个功能单元容量。\n\n在上述模型下，将这些操作打包到最少数量的可行指令束中。将指令束的最小数量报告为单个实数值。如果在中间推理中使用了任何近似方法，请确保最终报告的数字是精确的。最终答案中不需要单位。",
            "solution": "问题是在资源约束下，将一组 $10$ 个操作调度到一台超长指令字 (VLIW) 机器上的最少数量的指令束中。这是一个多维装箱问题的实例。\n\n首先，我将验证问题陈述。\n\n### 步骤 1：提取已知条件\n-   每个指令束的资源容量向量为 $\\mathbf{c} = \\begin{pmatrix} 2 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。\n-   向量的坐标对应于资源：整数单元 ($I$)、浮点单元 ($F$)、内存端口 ($M$) 以及发射槽 $s_1$、$s_2$、$s_3$、$s_4$。\n-   有一组 $10$ 个操作，$\\{o_1, o_2, \\dots, o_{10}\\}$。\n-   每个操作 $o_i$ 的资源使用向量 $r_i$ 如下：\n    $r_1 = r_5 = r_9 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix}$\n    $r_2 = r_6 = r_{10} = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix}$\n    $r_3 = r_7 = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix}$\n    $r_4 = r_8 = \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix}$\n-   如果指令束 $B$ 中操作的资源使用向量之和不超过容量向量 $\\mathbf{c}$，即 $\\sum_{i \\in B} r_i \\le \\mathbf{c}$（分量不等式），则该指令束 $B$ 是可行的。\n-   目标是找到调度所有 $10$ 个操作所需的可行指令束的最小数量。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题描述了一个资源受限的调度问题，这是编译器理论和计算机体系结构中的一个基本概念，尤其适用于 VLIW 处理器。该模型是现实世界问题的简化但有效的抽象。它在科学上是合理的。\n-   **适定性：** 该问题要求在一组明确的约束下找到一个最小值。目标定义明确，约束以数学方式指定。存在一个关于指令束数量的唯一最优解。\n-   **客观性：** 该问题使用精确、客观的数学语言进行表述。\n-   **完整性和一致性：** 该问题提供了所有必要信息：机器的容量、操作的数量和类型，以及每个操作消耗的资源。没有矛盾之处。\n\n### 步骤 3：结论与行动\n该问题是有效的，因为它是自洽的、有科学依据的且适定的。我将继续进行求解。\n\n问题是将这 $10$ 个操作的集合划分为最少数量的子集（指令束），其中每个子集都满足资源约束。\n\n让我们根据资源使用情况对操作进行分类：\n-   A 型：消耗 $1$ 个 $I$ 单元和 $1$ 个 $s_1$ 槽的操作。这些是 $\\{o_1, o_5, o_9\\}$。共有 $3$ 个此类操作。($r_i = (1,0,0,1,0,0,0)^T$)\n-   B 型：消耗 $1$ 个 $I$ 单元和 $1$ 个 $s_2$ 槽的操作。这些是 $\\{o_2, o_6, o_{10}\\}$。共有 $3$ 个此类操作。($r_i = (1,0,0,0,1,0,0)^T$)\n-   C 型：消耗 $1$ 个 $F$ 单元和 $1$ 个 $s_3$ 槽的操作。这些是 $\\{o_3, o_7\\}$。共有 $2$ 个此类操作。($r_i = (0,1,0,0,0,1,0)^T$)\n-   D 型：消耗 $1$ 个 $M$ 单元和 $1$ 个 $s_4$ 槽的操作。这些是 $\\{o_4, o_8\\}$。共有 $2$ 个此类操作。($r_i = (0,0,1,0,0,0,1)^T$)\n\n容量向量为 $\\mathbf{c} = (2, 1, 1, 1, 1, 1, 1)^T$，对应于资源 $(I, F, M, s_1, s_2, s_3, s_4)$。\n\n为了找到指令束的最小数量，我们首先建立一个下界。指令束的数量必须至少是任何单一资源的总需求除以该资源的每个指令束容量，然后向上取整。\n\n让我们通过对所有 $r_i$ 向量求和来计算总资源需求：\n-   $I$ 单元的总需求：$3$ (来自 A 型) $+ 3$ (来自 B 型) $= 6$。\n-   $F$ 单元的总需求：$2$ (来自 C 型) $= 2$。\n-   $M$ 单元的总需求：$2$ (来自 D 型) $= 2$。\n-   $s_1$ 槽的总需求：$3$ (来自 A 型) $= 3$。\n-   $s_2$ 槽的总需求：$3$ (来自 B 型) $= 3$。\n-   $s_3$ 槽的总需求：$2$ (来自 C 型) $= 2$。\n-   $s_4$ 槽的总需求：$2$ (来自 D 型) $= 2$。\n\n现在，我们计算每种资源的下界：\n-   $I$ 单元：$\\lceil \\frac{6}{2} \\rceil = 3$ 个指令束。\n-   $F$ 单元：$\\lceil \\frac{2}{1} \\rceil = 2$ 个指令束。\n-   $M$ 单元：$\\lceil \\frac{2}{1} \\rceil = 2$ 个指令束。\n-   $s_1$ 槽：$\\lceil \\frac{3}{1} \\rceil = 3$ 个指令束。\n-   $s_2$ 槽：$\\lceil \\frac{3}{1} \\rceil = 3$ 个指令束。\n-   $s_3$ 槽：$\\lceil \\frac{2}{1} \\rceil = 2$ 个指令束。\n-   $s_4$ 槽：$\\lceil \\frac{2}{1} \\rceil = 2$ 个指令束。\n\n总下界是这些单个下界中的最大值：\n$$\n\\text{最小指令束数量} \\ge \\max(3, 2, 2, 3, 3, 2, 2) = 3\n$$\n所以，我们至少需要 $3$ 个指令束。现在，我们必须确定将所有操作装入 $3$ 个指令束是否可行。\n\n让我们尝试构建一个包含 $3$ 个指令束的调度方案。\n我们有 $3$ 个 A 型、$3$ 个 B 型、$2$ 个 C 型和 $2$ 个 D 型操作。\n\n指令束 1：让我们尝试将每种类型的操作各打包一个。\n我们选择 $\\{o_1, o_2, o_3, o_4\\}$。\n它们的资源向量之和为：\n$r_1 + r_2 + r_3 + r_4 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}2\\\\1\\\\1\\\\1\\\\1\\\\1\\\\1\\end{pmatrix}$\n这个和恰好等于容量向量 $\\mathbf{c}$。因此，该指令束是可行的。\n剩余操作：\n-   A 型：$\\{o_5, o_9\\}$ (剩余 $2$ 个)\n-   B 型：$\\{o_6, o_{10}\\}$ (剩余 $2$ 个)\n-   C 型：$\\{o_7\\}$ (剩余 $1$ 个)\n-   D 型：$\\{o_8\\}$ (剩余 $1$ 个)\n\n指令束 2：我们可以再次尝试用剩余的操作组成一个类似的指令束。\n我们选择 $\\{o_5, o_6, o_7, o_8\\}$。\n它们的资源向量之和为：\n$r_5 + r_6 + r_7 + r_8 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}2\\\\1\\\\1\\\\1\\\\1\\\\1\\\\1\\end{pmatrix}$\n这个指令束也是可行的。\n剩余操作：\n-   A 型：$\\{o_9\\}$ (剩余 $1$ 个)\n-   B 型：$\\{o_{10}\\}$ (剩余 $1$ 个)\n-   C 型：(剩余 $0$ 个)\n-   D 型：(剩余 $0$ 个)\n\n指令束 3：剩余的操作是 $\\{o_9, o_{10}\\}$。\n让我们检查它们是否可以打包到单个指令束中。\n它们的资源向量之和为：\n$r_9 + r_{10} = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix} = \\begin{pmatrix}2\\\\0\\\\0\\\\1\\\\1\\\\0\\\\0\\end{pmatrix}$\n我们将此与容量向量 $\\mathbf{c} = (2, 1, 1, 1, 1, 1, 1)^T$ 进行比较。\n-   $I$: $2 \\le 2$ (满足)\n-   $F$: $0 \\le 1$ (满足)\n-   $M$: $0 \\le 1$ (满足)\n-   $s_1$: $1 \\le 1$ (满足)\n-   $s_2$: $1 \\le 1$ (满足)\n-   $s_3$: $0 \\le 1$ (满足)\n-   $s_4$: $0 \\le 1$ (满足)\n资源使用在容量限制之内。因此，该指令束是可行的。\n\n我们已成功将所有 $10$ 个操作调度到 $3$ 个可行的指令束中：\n-   指令束 1：$\\{o_1, o_2, o_3, o_4\\}$\n-   指令束 2：$\\{o_5, o_6, o_7, o_8\\}$\n-   指令束 3：$\\{o_9, o_{10}\\}$\n\n由于理论下界是 $3$ 个指令束，而我们构建了一个包含 $3$ 个指令束的有效调度方案，因此最小指令束数量恰好是 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "程序的执行效率不仅取决于单个指令的快慢，还严重受到控制流，特别是分支指令的影响。当处理器“猜错”了分支的走向时，会引发代价高昂的流水线冲刷。本练习  让你扮演编译器后端角色，为一个采用静态分支预测（总是预测顺序执行的路径）的处理器建模。通过分析程序在不同路径上的执行概率，你将学习如何策略性地布局基本块，从而最小化分支误预测的期望代价，优化整体执行时间。",
            "id": "3674228",
            "problem": "您正在为一个简单的目标机器建模，以指导基本块排序。该机器模型具有以下属性：\n- 处理器执行一个条件分支，其固定基本成本为 $b$ 个周期，与分支结果无关。一个条件分支被静态预测为遵循直通路径 (fall-through path)，即紧随该分支之后布局的基本块。如果在运行时实际的下一个块不是直通块，则该动态分支会产生 $M$ 个周期的额外误预测惩罚。\n- 无条件直通没有成本；除上述说明外，该模型没有其他惩罚。\n- 预期执行时间是所有已执行块的周期和分支开销之和的期望值。\n\n考虑一个具有以下控制流图（CFG）的函数。设 $E$ 表示入口块。块 $E$ 以一个条件分支结束，该分支以概率 $p$ 跳转到块 $A$，以概率 $1-p$ 跳转到块 $B$。块 $A$ 以一个条件分支结束，该分支以概率 $q_A$ 跳转到汇合块 $J$，以概率 $1-q_A$ 跳转到返回块 $R_A$。类似地，块 $B$ 以一个条件分支结束，该分支以概率 $q_B$ 跳转到 $J$，以概率 $1-q_B$ 跳转到返回块 $R_B$。块 $J$、$R_A$ 和 $R_B$ 返回，并且没有出边。\n\n编译时布局是基本块的单一线性顺序。对于一个条件分支，其后继块中任何一个被紧接着放置在顺序中的块，就是它的直通块，并因此被硬件预测。另一个后继块通过采用分支来到达（执行分支本身仍然花费 $b$），而当实际的后继块不是直通块时，就需要支付误预测惩罚 $M$。您可以自由地反转分支条件，无需额外成本。汇合块 $J$ 最多只能紧跟在 $A$ 或 $B$ 中的一个之后（因为布局是线性的），但它不必紧跟在任何一个之后。\n\n机器和程序参数如下：\n- 每个块的计算成本（不包括任何分支开销）：$c_E = 5$, $c_A = 8$, $c_B = 6$, $c_J = 4$, $c_{R_A} = 1$, $c_{R_B} = 1$（单位均为周期）。\n- 条件分支基本成本：$b = 1$（周期）。\n- 概率：$p = 0.6$, $q_A = 0.8$, $q_B = 0.7$。\n\n任务：使用第一性原理（期望的线性性质和静态直通预测器下误预测事件的定义），确定基本块的顺序（即，在满足线性布局约束的条件下，为 $E$、$A$ 和 $B$ 中的分支选择直通后继块），以最小化每次函数执行的预期周期数。然后，将最小预期执行周期数表示为关于 $M$ 的封闭形式函数。除已说明的成本外，不要引入任何额外成本。以包含 $M$ 的单一解析表达式的形式提供您的最终答案。无需单位。不要四舍五入；给出精确表达式。",
            "solution": "问题要求解一个函数的最小预期执行时间，并表示为误预测惩罚 $M$ 的函数。该优化通过选择基本块的最优线性布局来实现，而布局又决定了每个条件分支的静态预测直通路径。\n\n首先，我们建立目标函数，即总预期执行时间 $E[T]$。根据期望的线性性质，我们可以将其表示为执行基本块的预期成本与分支的预期开销成本之和。\n$$E[T] = E[C_{\\text{blocks}}] + E[C_{\\text{branch}}]$$\n\n我们来计算基本块计算的预期成本 $E[C_{\\text{blocks}}]$。此成本与块布局无关。\n一个计算成本为 $c_X$ 的块 $X$ 以某个概率 $P(X)$ 执行。预期成本为 $\\sum_X P(X) c_X$。\n执行每个块的概率如下：\n- $P(E) = 1$\n- $P(A) = p$\n- $P(B) = 1-p$\n- $P(J) = P(E \\to A \\to J) + P(E \\to B \\to J) = p q_A + (1-p) q_B$\n- $P(R_A) = P(E \\to A \\to R_A) = p(1-q_A)$\n- $P(R_B) = P(E \\to B \\to R_B) = (1-p)(1-q_B)$\n\n代入给定值 $p=0.6$, $q_A=0.8$, $q_B=0.7$ 和块成本 $c_E=5$, $c_A=8$, $c_B=6$, $c_J=4$, $c_{R_A}=1$, $c_{R_B}=1$：\n- $P(A) = 0.6$\n- $P(B) = 0.4$\n- $P(J) = (0.6)(0.8) + (0.4)(0.7) = 0.48 + 0.28 = 0.76$\n- $P(R_A) = (0.6)(1-0.8) = 0.12$\n- $P(R_B) = (0.4)(1-0.7) = 0.12$\n\n预期的块计算成本为：\n$$E[C_{\\text{blocks}}] = P(E)c_E + P(A)c_A + P(B)c_B + P(J)c_J + P(R_A)c_{R_A} + P(R_B)c_{R_B}$$\n$$E[C_{\\text{blocks}}] = 1(5) + (0.6)(8) + (0.4)(6) + (0.76)(4) + (0.12)(1) + (0.12)(1)$$\n$$E[C_{\\text{blocks}}] = 5 + 4.8 + 2.4 + 3.04 + 0.12 + 0.12 = 15.48$$\n\n接下来，我们分析预期的分支开销 $E[C_{\\text{branch}}]$。模型指出，每个执行的条件分支都有 $b$ 个周期的基本成本，如果采用的路径不是静态预测的直通路径，则会产生 $M$ 个周期的额外误预测惩罚。问题说明我们可以自由地反转分支条件，这意味着对于任何分支，我们可以通过安排布局来选择其两个后继块中的哪一个成为直通路径，目标是选择能使预期误预测惩罚最小化的直通路径。\n\n总预期分支成本是在 $E$、$A$ 和 $B$ 处的分支成本之和，按其执行概率加权。\n$$E[C_{\\text{branch}}] = E[C_{\\text{branch},E}] + E[C_{\\text{branch},A}] + E[C_{\\text{branch},B}]$$\n$E$ 处的分支总是被执行。$A$ 处的分支以概率 $p$ 执行。$B$ 处的分支以概率 $1-p$ 执行。\n单个分支的开销包括基本成本 $b$ 和一个潜在的误预测惩罚 $M$。\n总预期基本成本是 $1 \\cdot b + p \\cdot b + (1-p) \\cdot b = 2b = 2(1) = 2$。\n总预期误预测惩罚 $E[C_{\\text{penalty}}]$ 是我们需要通过布局选择来最小化的部分。\n$$E[C_{\\text{penalty}}] = M \\left( P(\\text{mispredict at E}) + p \\cdot P(\\text{mispredict at A}) + (1-p) \\cdot P(\\text{mispredict at B}) \\right)$$\n为了最小化单个分支的惩罚，我们必须选择概率较大的后继块作为直通块。\n- **从 E 出发的分支：** 后继块是 $A$（概率 $p=0.6$）和 $B$（概率 $1-p=0.4$）。为了最小化惩罚，$A$ 应该是直通块。这总是可能的。误预测概率是 $1-p=0.4$。\n- **从 A 出发的分支：** 后继块是 $J$（概率 $q_A=0.8$）和 $R_A$（概率 $1-q_A=0.2$）。为了最小化惩罚，$J$ 应该是直通块。这需要布局为 `...; A; J; ...`。\n- **从 B 出发的分支：** 后继块是 $J$（概率 $q_B=0.7$）和 $R_B$（概率 $1-q_B=0.3$）。为了最小化惩罚，$J$ 应该是直通块。这需要布局为 `...; B; J; ...`。\n\n核心约束是布局是线性的。一个块只能有一个直接后继。因此，块 $J$ 不能同时是块 $A$ 和块 $B$ 的直通后继块。这意味着我们无法同时满足 $A$ 和 $B$ 处分支的最优直通选择。我们必须为其中一个做出次优选择。\n\n我们必须比较两种主要策略，假设我们总是为 $E$ 处的分支做出最优选择（直通到 $A$），因为这是无约束的。\n**策略1：** 优先考虑 $A$ 处的分支。将 $A$ 的直通块设置为 $J$。这迫使 $B$ 的直通块为 $R_B$（概率较小的路径）。\n布局选择如下：\n- E 分支：直通块为 $A$（最优）。误预测概率：$1-p=0.4$。\n- A 分支：直通块为 $J$（最优）。误预测概率：$1-q_A=0.2$。\n- B 分支：直通块为 $R_B$（次优）。误预测概率：$q_B=0.7$。\n总的预期误预测次数 $N_1$ 是：\n$$N_1 = (1-p) + p(1-q_A) + (1-p)q_B$$\n$$N_1 = 0.4 + (0.6)(0.2) + (0.4)(0.7) = 0.4 + 0.12 + 0.28 = 0.80$$\n\n**策略2：** 优先考虑 $B$ 处的分支。将 $B$ 的直通块设置为 $J$。这迫使 $A$ 的直通块为 $R_A$（概率较小的路径）。\n布局选择如下：\n- E 分支：直通块为 $A$（最优）。误预测概率：$1-p=0.4$。\n- A 分支：直通块为 $R_A$（次优）。误预测概率：$q_A=0.8$。\n- B 分支：直通块为 $J$（最优）。误预测概率：$1-q_B=0.3$。\n总的预期误预测次数 $N_2$ 是：\n$$N_2 = (1-p) + p(q_A) + (1-p)(1-q_B)$$\n$$N_2 = 0.4 + (0.6)(0.8) + (0.4)(0.3) = 0.4 + 0.48 + 0.12 = 1.00$$\n\n比较两种策略，$N_1 = 0.80$ 小于 $N_2 = 1.00$。因此，策略1产生最小的预期误预测惩罚。这个惩罚是 $E[C_{\\text{penalty}}]_{\\text{min}} = N_1 M = 0.8M$。\n\n最小总预期执行时间是常数成本与这个最小惩罚之和。\n$$E[T]_{\\text{min}} = E[C_{\\text{blocks}}] + E[C_{\\text{base branch}}] + E[C_{\\text{penalty}}]_{\\text{min}}$$\n$$E[T]_{\\text{min}} = 15.48 + 2b + 0.8M$$\n当 $b=1$ 时：\n$$E[T]_{\\text{min}} = 15.48 + 2 + 0.8M$$\n$$E[T]_{\\text{min}} = 17.48 + 0.8M$$\n为了用精确分数表示：\n$17.48 = \\frac{1748}{100} = \\frac{437}{25}$。\n$0.8 = \\frac{8}{10} = \\frac{4}{5}$。\n所以，每次执行的最小预期周期数为 $\\frac{437}{25} + \\frac{4}{5}M$。小数形式同样精确。",
            "answer": "$$\\boxed{17.48 + 0.8M}$$"
        }
    ]
}