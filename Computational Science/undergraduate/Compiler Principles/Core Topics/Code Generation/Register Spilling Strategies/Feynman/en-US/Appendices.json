{
    "hands_on_practices": [
        {
            "introduction": "When a compiler runs out of registers, it must choose a variable to \"spill\" to memory, but not all choices are equal. This exercise demonstrates how to use execution frequency data from profile-guided optimization (PGO) to make an informed decision. By calculating the expected number of memory operations for each potential spill, you can develop a heuristic that minimizes the performance impact on the most common execution paths, a core technique in building high-performance compilers. ",
            "id": "3667851",
            "problem": "A compiler for a target with $R$ architectural registers uses global register allocation over a Control Flow Graph (CFG). At a particular program point, the live set size is $L = R + 1$, so exactly one live range must be spilled. The program structure is a single dynamically frequent multiway branch (such as a switch) that creates $3$ disjoint, acyclic paths that reconverge. Profile-guided path probabilities for a single invocation of the function are $p_1 = \\frac{4}{5}$, $p_2 = \\frac{3}{20}$, and $p_3 = \\frac{1}{20}$, which satisfy $p_1 + p_2 + p_3 = 1$ by construction. Three candidate live ranges, denoted $v_A$, $v_B$, and $v_C$, have been identified by liveness analysis as equally spillable from a correctness perspective. However, their dynamic memory-operation counts (the sum of loads and stores caused by the spill and subsequent reloads along a path) differ by path due to differing use densities. Let $c_i(v)$ denote the number of memory operations executed on path $i \\in \\{1,2,3\\}$ if live range $v \\in \\{v_A, v_B, v_C\\}$ is spilled. The measured counts are:\n$$\nc_1(v_A) = 30,\\quad c_2(v_A) = 2,\\quad c_3(v_A) = 1,\n$$\n$$\nc_1(v_B) = 18,\\quad c_2(v_B) = 6,\\quad c_3(v_B) = 6,\n$$\n$$\nc_1(v_C) = 10,\\quad c_2(v_C) = 12,\\quad c_3(v_C) = 12.\n$$\nAssume a single function invocation selects exactly one path $i$ with probability $p_i$, and along that path the chosen spill incurs $c_i(v)$ memory operations deterministically. A path-probability-weighted spill heuristic prefers spilling live ranges whose spill-induced memory operations are biased toward colder paths. Using the definition of expectation for a discrete random variable, derive the expected number of memory operations for each candidate spill and select the candidate that minimizes the expectation under the path-probability-weighted heuristic. For comparison, a naive path-unaware heuristic ignores the profile and uses a uniform average over the $3$ paths to choose the spill.\n\nCompute the ratio of the naive heuristic’s expected number of memory operations to the path-probability-weighted heuristic’s expected number of memory operations, after each heuristic makes its choice. Express the final ratio as a single real number. No rounding is required.",
            "solution": "The problem has been validated and is deemed a valid, well-posed problem in the domain of compiler optimization.\n\n**Givens:**\n- Number of architectural registers: $R$.\n- Live set size: $L = R + 1$.\n- Number of required spills: $1$.\n- Number of disjoint paths: $3$.\n- Path probabilities: $p_1 = \\frac{4}{5}$, $p_2 = \\frac{3}{20}$, $p_3 = \\frac{1}{20}$.\n- Candidate live ranges for spilling: $v_A$, $v_B$, $v_C$.\n- Dynamic memory-operation counts $c_i(v)$ for spill candidate $v$ on path $i$:\n  - $c_1(v_A) = 30$, $c_2(v_A) = 2$, $c_3(v_A) = 1$.\n  - $c_1(v_B) = 18$, $c_2(v_B) = 6$, $c_3(v_B) = 6$.\n  - $c_1(v_C) = 10$, $c_2(v_C) = 12$, $c_3(v_C) = 12$.\n\n**Problem Statement:**\nThe objective is to compute the ratio of the expected memory operations resulting from the choice made by a naive, path-unaware heuristic to that resulting from the choice made by an optimal, path-probability-weighted heuristic.\n\n**1. Analysis of the Path-Probability-Weighted Heuristic**\n\nThis heuristic chooses the spill candidate that minimizes the expected number of memory operations. The expected number of memory operations for spilling a live range $v$, denoted $E[C(v)]$, is calculated as the sum of the costs on each path weighted by the probability of taking that path. The formula is:\n$$E[C(v)] = \\sum_{i=1}^{3} p_i \\cdot c_i(v)$$\n\nWe compute the expected cost for each candidate live range ($v_A$, $v_B$, $v_C$). For easier computation, we note that $p_1 = \\frac{4}{5} = \\frac{16}{20}$.\n\nFor candidate $v_A$:\n$$E[C(v_A)] = p_1 c_1(v_A) + p_2 c_2(v_A) + p_3 c_3(v_A) = \\left(\\frac{16}{20}\\right)(30) + \\left(\\frac{3}{20}\\right)(2) + \\left(\\frac{1}{20}\\right)(1)$$\n$$E[C(v_A)] = \\frac{480 + 6 + 1}{20} = \\frac{487}{20} = 24.35$$\n\nFor candidate $v_B$:\n$$E[C(v_B)] = p_1 c_1(v_B) + p_2 c_2(v_B) + p_3 c_3(v_B) = \\left(\\frac{16}{20}\\right)(18) + \\left(\\frac{3}{20}\\right)(6) + \\left(\\frac{1}{20}\\right)(6)$$\n$$E[C(v_B)] = \\frac{288 + 18 + 6}{20} = \\frac{312}{20} = 15.6$$\n\nFor candidate $v_C$:\n$$E[C(v_C)] = p_1 c_1(v_C) + p_2 c_2(v_C) + p_3 c_3(v_C) = \\left(\\frac{16}{20}\\right)(10) + \\left(\\frac{3}{20}\\right)(12) + \\left(\\frac{1}{20}\\right)(12)$$\n$$E[C(v_C)] = \\frac{160 + 36 + 12}{20} = \\frac{208}{20} = 10.4$$\n\nComparing the expected costs: $E[C(v_C)] = 10.4 < E[C(v_B)] = 15.6 < E[C(v_A)] = 24.35$.\nThe path-probability-weighted heuristic selects the candidate with the minimum expected cost, which is $v_C$. The expected number of memory operations for this optimal choice is $E_{opt} = E[C(v_C)] = 10.4$.\n\n**2. Analysis of the Naive Path-Unaware Heuristic**\n\nThis heuristic ignores the given path probabilities and instead uses a uniform average over the $3$ paths. This is equivalent to assuming a uniform probability distribution where $p'_1 = p'_2 = p'_3 = \\frac{1}{3}$. The heuristic calculates the average cost, $Avg(v)$, for each candidate:\n$$Avg(v) = \\frac{1}{3} \\sum_{i=1}^{3} c_i(v) = \\frac{c_1(v) + c_2(v) + c_3(v)}{3}$$\n\nFor candidate $v_A$:\n$$Avg(v_A) = \\frac{30 + 2 + 1}{3} = \\frac{33}{3} = 11$$\n\nFor candidate $v_B$:\n$$Avg(v_B) = \\frac{18 + 6 + 6}{3} = \\frac{30}{3} = 10$$\n\nFor candidate $v_C$:\n$$Avg(v_C) = \\frac{10 + 12 + 12}{3} = \\frac{34}{3} \\approx 11.33$$\n\nComparing the average costs: $Avg(v_B) = 10 < Avg(v_A) = 11 < Avg(v_C) \\approx 11.33$.\nThe naive heuristic selects the candidate with the minimum average cost, which is $v_B$.\n\nThe problem asks for the *actual* expected number of memory operations resulting from the naive heuristic's choice. To find this, we must evaluate the true expected cost of spilling $v_B$, using the actual path probabilities ($p_1, p_2, p_3$). This value was already computed in the first section.\nThe expected cost for the naive heuristic's choice is $E_{naive\\_choice} = E[C(v_B)] = 15.6$.\n\n**3. Computation of the Ratio**\n\nThe final step is to compute the ratio of the naive heuristic's expected cost to the path-probability-weighted heuristic's expected cost.\n$$Ratio = \\frac{E_{naive\\_choice}}{E_{opt}}$$\n$$Ratio = \\frac{15.6}{10.4}$$\n\nTo compute this exactly, we use the fractional forms derived earlier:\n$$E_{naive\\_choice} = E[C(v_B)] = \\frac{312}{20}$$\n$$E_{opt} = E[C(v_C)] = \\frac{208}{20}$$\n$$Ratio = \\frac{312/20}{208/20} = \\frac{312}{208}$$\nWe can simplify this fraction:\n$$\\frac{312}{208} = \\frac{156}{104} = \\frac{78}{52} = \\frac{39}{26} = \\frac{3}{2}$$\nAs a real number, the ratio is $1.5$. This indicates that the choice made by the naive heuristic is expected to incur $50\\%$ more memory operations than the choice made by the optimal, profile-guided heuristic.",
            "answer": "$$ \\boxed{1.5} $$"
        },
        {
            "introduction": "Sometimes, register pressure becomes intense only in a small region of code, for example due to a specific instruction's requirements. Instead of spilling a variable for its entire lifetime, we can use a more precise technique called live-range splitting. This practice challenges you to analyze a scenario where a simple spill is suboptimal and to see how splitting a variable's live-range—storing it to memory only across the high-pressure region—can resolve the conflict more efficiently. ",
            "id": "3667850",
            "problem": "Consider a hypothetical Reduced Instruction Set Computer (RISC) architecture with $4$ integer registers $\\{r0, r1, r2, r3\\}$. The Application Binary Interface (ABI) reserves $r0$ for certain fixed roles: it is clobbered by calls and, critically, some instructions require operands and results in $r0$. In particular, the unsigned multiply-high instruction $\\mathrm{mulhi}(x, y)$ requires its first operand in $r0$ and writes its result to $r0$.\n\nA compiler is performing global register allocation on the following straight-line basic block inside a loop. The block has instructions $I_1$ through $I_{10}$ and uses temporaries $\\{p, q, r, w, s, m, t, u, d, g, v\\}$, with data dependencies and uses given by:\n- $I_1$: $p \\leftarrow \\mathrm{load}(P)$\n- $I_2$: $q \\leftarrow \\mathrm{load}(Q)$\n- $I_3$: $r \\leftarrow p + q$\n- $I_4$: $w \\leftarrow r + q$\n- $I_5$: $s \\leftarrow w + p$\n- $I_6$: $t \\leftarrow \\mathrm{mulhi}(s, m)$ with the hardware constraint that at $I_6$ the operand $s$ must be in $r0$, and the result $t$ is produced in $r0$; the second operand $m$ must be in some register (no memory operands for $\\mathrm{mulhi}$).\n- $I_7$: $u \\leftarrow t + s$\n- $I_8$: $v \\leftarrow u + r$\n- $I_9$: $v \\leftarrow v + d$\n- $I_{10}$: $v \\leftarrow v + g$\n\nAssume $m$ is loaded earlier and only used at $I_6$, and both $d$ and $g$ are defined before $I_6$ and each used after $I_6$ as shown. There are no calls in the block, and no other special instructions. Assume the allocator performs Chaitin-style graph coloring: it builds an interference graph from liveness and tries to color with the available registers; if coloring fails due to register pressure, it spills by inserting stores and loads.\n\nAt $I_6$, the set of values simultaneously live is $\\{s, r, d, g, m\\}$ because $s$ is used at $I_6$ and again at $I_7$, $r$ is used later at $I_8$, $d$ at $I_9$, $g$ at $I_{10}$, and $m$ is used at $I_6$. Due to the pre-coloring at $I_6$, $s$ must be in $r0$, making $r0$ unavailable for any other live value. This leaves only $\\{r1, r2, r3\\}$ for the remaining $4$ live values $\\{r, d, g, m\\}$, guaranteeing at least $1$ spill across $I_6$.\n\nThe compiler must choose a strategy that satisfies the pre-coloring constraint while minimizing extra spill traffic. Consider the following candidate strategies:\n\nA. Spill $r$ globally across its entire live range in the block, i.e., after its definition at $I_3$ insert a store to memory, and insert loads at each of its uses ($I_4$ and $I_8$), keeping $r$ mostly in memory rather than a register.\n\nB. Perform live-range splitting of $r$ around $I_6$: keep $r$ in a register up to just before $I_6$, insert a store of $r$ immediately before $I_6$ to relieve the pressure peak, and insert a single reload of $r$ immediately before $I_8$; elsewhere $r$ remains in a register.\n\nC. Assign $m$ to $r2$ and use a memory operand for $m$ in $\\mathrm{mulhi}$ to avoid occupying a register at $I_6$.\n\nD. Split $s$ around $I_6$ by keeping $s$ in $r2$ before $I_6$, moving $s$ into $r0$ just before $I_6$, and moving it back out after $I_6$, with no spills of other values.\n\nWhich strategy yields a valid allocation that respects the pre-coloring constraint and minimizes additional spill traffic (measured in inserted loads and stores per loop iteration) while keeping semantics unchanged?\n\nChoose one option.\n\nA. Global spill of $r$ over the whole block.\n\nB. Live-range split of $r$ only across $I_6$.\n\nC. Use a memory operand for $m$ in $\\mathrm{mulhi}$.\n\nD. Copy $s$ into $r0$ only at $I_6$, without spilling others.",
            "solution": "The core of the problem is a register allocation conflict at instruction $I_6$. At this point, there are $5$ simultaneously live variables $\\{s, r, d, g, m\\}$, but only $4$ available registers $\\{r0, r1, r2, r3\\}$. An interference graph for these variables would contain a $5$-clique ($K_5$), which cannot be colored with $4$ colors. Therefore, at least one variable must be spilled (i.e., stored in memory).\n\nThe problem specifies constraints that guide the choice of a spill candidate:\n1.  **Pre-coloring**: The variable $s$ must be in register $r0$ for the `mulhi` instruction. This pre-colors the node for $s$ with the color $r0$.\n2.  **Operand constraint**: The variable $m$ must be in a register for `mulhi`. This means $m$ cannot be the spilled variable.\n\nWith $s$ assigned to $r0$, the remaining $4$ live variables $\\{r, d, g, m\\}$ must be allocated from the remaining $3$ registers $\\{r1, r2, r3\\}$. Since $m$ must be in a register, it will occupy one of $\\{r1, r2, r3\\}$. This leaves only $2$ registers for the $3$ variables $\\{r, d, g\\}$. Consequently, one variable from the set $\\{r, d, g\\}$ must be spilled across the instruction $I_6$.\n\nThe question asks for the best strategy to handle this spill, focusing on minimizing spill traffic (the number of `load` and `store` instructions added). We will now evaluate each option.\n\n**A. Global spill of $r$ over the whole block.**\nThis strategy proposes to keep the variable $r$ in memory for its entire live range.\n-   The variable $r$ is defined at $I_3: r \\leftarrow p + q$. A `store` instruction would be inserted immediately after $I_3$.\n-   The variable $r$ is used at $I_4: w \\leftarrow r + q$. A `load` instruction would be inserted before $I_4$.\n-   The variable $r$ is used again at $I_8: v \\leftarrow u + r$. A `load` instruction would be inserted before $I_8$.\n-   **Spill Traffic**: This strategy introduces $1$ `store` and $2$ `load` instructions, for a total of $3$ memory operations per loop iteration.\n-   **Validity**: This strategy successfully resolves the register pressure at $I_6$ by removing $r$ from the set of variables requiring a register. The remaining variables $\\{s, d, g, m\\}$ can be allocated to the $4$ available registers. The strategy is valid.\n\n**B. Live-range split of $r$ only across $I_6$.**\nThis strategy involves a more precise spill, keeping $r$ in a register except for the specific region of high register pressure around $I_6$.\n-   $r$ is defined at $I_3$ and used at $I_4$. It can be held in a register during this time.\n-   To relieve pressure at $I_6$, a `store` instruction for $r$ is inserted just before $I_6$.\n-   After $I_6$, $r$ is no longer needed until its use at $I_8$. A `load` instruction is inserted just before $I_8$ to bring its value back into a register.\n-   **Spill Traffic**: This strategy introduces $1$ `store` and $1$ `load` instruction, for a total of $2$ memory operations per loop iteration.\n-   **Validity**: This strategy is also valid. It removes $r$ from consideration by the register allocator at the critical point $I_6$, resolving the conflict. It is a more efficient solution.\n\n**C. Use a memory operand for $m$ in `mulhi`.**\nThis strategy suggests modifying the `mulhi` instruction to fetch its second operand directly from memory.\n-   **Validity**: The problem statement explicitly gives a hardware constraint: \"the second operand $m$ must be in some register (no memory operands for $\\mathrm{mulhi}$)\". This strategy directly violates this given constraint.\n-   **Verdict**: Invalid.\n\n**D. Copy $s$ into $r0$ only at $I_6$, without spilling others.**\nThis option claims it's possible to resolve the issue without spilling any of the other live variables $\\{r, d, g, m\\}$.\n-   **Validity**: This claim is logically impossible. As established, at instruction $I_6$, there are $5$ simultaneously live variables: $\\{s, r, d, g, m\\}$. The principle of register allocation states that if $k$ variables are simultaneously live, at least $k$ registers are required to hold them all without spilling. Here, $k=5$, but the number of available registers is $4$. It is impossible to hold all $5$ values in registers. The statement \"without spilling others\" is a contradiction of the fundamental problem constraints.\n-   **Verdict**: Invalid.\n\n**Conclusion**\nComparing the valid options, Option A results in $3$ memory operations, while Option B results in $2$. Option B minimizes spill traffic. Options C and D are invalid. Therefore, the best strategy among the choices is the live-range splitting of $r$.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "A compiler's decisions about register spilling do not happen in isolation; they must integrate with other optimizations and constraints, such as those imposed by inline assembly. This exercise explores such a scenario, where an `asm` block clobbers key registers inside a loop. You will learn to weigh the costs of different strategies, combining loop-invariant code motion with register moves and spills to find the most performant solution, highlighting how local decisions must align with a global optimization strategy. ",
            "id": "3667822",
            "problem": "You are implementing a local register-allocation decision around an inline assembly (asm) block in a loop in a compiler backend. The target machine has allocatable integer registers $\\{r_0,r_1,r_2,r_3,r_4,r_5\\}$. The inline assembly block lists a clobber set $\\{r_0,r_1\\}$, meaning that after the asm executes, the values in $r_0$ and $r_1$ are undefined and must be treated as destroyed by the compiler. Assume the clobber applies to the entire duration of the asm, and the compiler cannot inspect the asm body. At the program point immediately before the asm inside a loop of $N$ iterations, the allocator has assigned:\n- variable $x$ in $r_0$, and $x$ is used immediately after the asm in each iteration (inside the loop);\n- variable $y$ in $r_2$, and $y$ is live across the asm in every iteration and is used multiple times inside the loop, so keeping $y$ in a register across the asm is desirable;\n- variable $z$ in $r_1$, and $z$ is loop-invariant, live across the entire loop, and is used only once after the loop exits (no uses inside the loop body);\n- registers $r_3$ and $r_4$ hold other temporaries that are live across the asm inside the loop, and thus are not available;\n- register $r_5$ is the only non-clobbered free register at the asm boundary.\n\nAssume a simple and consistent cost model:\n- storing a register to its spill slot (a spill store) has cost $c_s = 3$;\n- loading a value from its spill slot (a reload) has cost $c_l = 3$;\n- moving a value between registers (a register-to-register move) has cost $c_m = 1$.\n\nThe compiler must ensure semantic correctness with respect to liveness and asm clobbers, and minimize the expected total cost across the loop. You may assume that code motion across the asm is restricted only by the clobber set and usual data dependencies; there are no aliasing or memory-barrier constraints beyond those implied by the clobbers listed.\n\nWhich strategy is correct and minimizes total expected cost across the $N$ iterations?\n\nA. Spill both $x$ and $z$ immediately before each asm and reload both immediately after each asm.\n\nB. Before entering the loop, spill $z$ once and defer its reload until its single use after the loop; in each iteration, move $x$ from $r_0$ to the free non-clobbered $r_5$ just before the asm so it survives the asm without spilling.\n\nC. Before entering the loop, move $z$ from $r_1$ to the free non-clobbered $r_5$ and keep it there across the loop; in each iteration, spill $x$ before the asm and reload it immediately after.\n\nD. In each iteration, spill $y$ before the asm to free $r_2$ and then move both $x$ and $z$ to non-clobbered registers before the asm; reload $y$ immediately after the asm in each iteration.\n\nYour answer should be based on the foundational definitions that (i) a variable is live at a program point if it may be used along some path before being redefined, (ii) an asm clobber on a register means its value must not be relied upon after the asm unless saved elsewhere, and (iii) spilling stores a live value to memory and reloading brings it back, extending or shrinking live ranges accordingly. Use these to reason about correctness and total cost. Assume $N \\ge 1$ is a known positive integer at compile-time for this cost analysis, but do not assume any special values of $N$.",
            "solution": "The problem asks for the most cost-effective strategy to preserve live variables across an `asm` block that clobbers registers $r_0$ and $r_1$. The live variables in clobbered registers are $x$ (in $r_0$) and $z$ (in $r_1$). We have one free, non-clobbered register, $r_5$. The costs are $c_s = 3$ (spill), $c_l = 3$ (reload), and $c_m = 1$ (move).\n\nA key principle is to handle loop-invariant variables outside the loop. Variable $z$ is loop-invariant. Operations to save and restore it should ideally be performed once before and after the loop, rather than $N$ times inside it.\n\nLet's analyze the total cost of each strategy over $N$ iterations.\n\n**A. Spill both $x$ and $z$ before each `asm` and reload both after.**\nThis is a correct but inefficient strategy that does not exploit the loop-invariant nature of $z$.\n*   Cost per iteration: (spill $x$) + (reload $x$) + (spill $z$) + (reload $z$) = $c_s + c_l + c_s + c_l = 3 + 3 + 3 + 3 = 12$.\n*   Total cost: $12N$.\n\n**B. Spill $z$ once before the loop, reload after the loop. In each iteration, move $x$ to the free register $r_5$.**\nThis strategy correctly hoists the handling of the loop-invariant variable $z$ out of the loop. Inside the loop, it uses the cheapest operation (a register move) to save $x$.\n*   Pre-loop cost: Spill $z$ to memory: $c_s = 3$.\n*   Cost per iteration: Move $x$ from $r_0$ to $r_5$: $c_m = 1$.\n*   Post-loop cost: Reload $z$ from memory: $c_l = 3$.\n*   Total cost: $c_s + (N \\times c_m) + c_l = 3 + N \\times 1 + 3 = N + 6$.\n\n**C. Move $z$ to $r_5$ before the loop. In each iteration, spill and reload $x$.**\nThis strategy also hoists the handling of $z$, using a cheap move to place it in the safe register $r_5$. However, this occupies $r_5$ for the entire loop, leaving no free registers to save $x$. Thus, $x$ must be spilled to memory in each iteration.\n*   Pre-loop cost: Move $z$ from $r_1$ to $r_5$: $c_m = 1$.\n*   Cost per iteration: Spill $x$ + Reload $x$ = $c_s + c_l = 3 + 3 = 6$.\n*   Total cost: $c_m + N \\times (c_s + c_l) = 1 + N \\times 6 = 6N + 1$.\n\n**D. Spill $y$ to free $r_2$, then move $x$ and $z$ to free registers.**\nThis strategy is incorrect in its premise. Variable $y$ is in $r_2$, a non-clobbered register, and needs no special handling. Spilling a \"safe\" variable is suboptimal.\n*   Cost per iteration: (spill $y$) + (move $x$) + (move $z$) + (reload $y$) = $c_s + c_m + c_m + c_l = 3 + 1 + 1 + 3 = 8$.\n*   Total cost: $8N$.\n\n**Cost Comparison:**\nWe compare the total costs for $N \\ge 1$:\n*   A: $12N$\n*   B: $N + 6$\n*   C: $6N + 1$\n*   D: $8N$\n\nFor any $N \\ge 1$, $N+6$ is significantly less than $12N$ and $8N$.\nComparing B and C:\n*   For $N=1$, Cost(B) = $1+6=7$ and Cost(C) = $6+1=7$. The costs are equal.\n*   For $N>1$, $N+6  6N+1$ because $5  5N$.\nStrategy B is never more expensive than C and is strictly cheaper for any loop that runs more than once. It is the optimal strategy.",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}