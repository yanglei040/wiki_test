{
    "hands_on_practices": [
        {
            "introduction": "将指令序列视为依赖图的拓扑排序是理解其基础的第一步，但这还远远不够。一个简单的、只遵循依赖关系的“天真”调度器可能会导致严重的性能损失，因为它忽略了指令延迟。本练习通过对比一个简单的拓扑排序调度器和一个具备延迟感知能力的列表调度器，让您亲手量化一个更智能的调度算法能够带来多大的性能提升 。",
            "id": "3647127",
            "problem": "一个编译器后端在单发射流水线上调度指令，遵循以有向无环图（DAG）表示的真数据依赖。拓扑序是 DAG 的任意一种遵循其偏序关系的线性化序列。每条指令的发射时间恰好为 $1$ 个周期，其结果在发射后 $\\ell$ 个周期变为可用，其中 $\\ell$ 是指令的延迟。一条指令只有在其所有前驱指令的结果都可用时才能被发射。如果调度器预先确定了一个固定的拓扑序，而列表中的下一条指令尚未就绪，则必须发出一个占用 $1$ 个周期的空操作（NOP）指令。\n\n考虑以下基本块 DAG，其节点为 $I_{1},\\dots,I_{8}$，边为 $I_{1}\\rightarrow I_{3}\\rightarrow I_{5}\\rightarrow I_{7}$。其他节点 $I_{2}, I_{4}, I_{6}, I_{8}$ 没有入边或出边。各指令延迟如下：\n- $I_{1}$ 是一条加载指令，延迟为 $L_{\\text{ld}}=4$。\n- $I_{3}$ 是一条算术运算指令，延迟为 $L_{\\text{alu}}=1$。\n- $I_{5}$ 是一条乘法指令，延迟为 $L_{\\text{mul}}=3$。\n- $I_{7}$ 是一条算术运算指令，延迟为 $L_{\\text{alu}}=1$。\n- $I_{2}, I_{4}, I_{6}, I_{8}$ 各是一条独立的算术运算指令，延迟为 $L_{\\text{alu}}=1$。\n\n假设时间从周期 $0$ 开始。定义完成时间 $T$ 为所有指令的“发射时间 + 延迟”的最大值。\n\n考虑两种调度器：\n- 朴素拓扑序调度器：它首先从 $I_{1}$ 开始进行深度优先遍历，总是先访问后继节点再探索无关节点，从而生成一个唯一的拓扑序列 $\\langle I_{1}, I_{3}, I_{5}, I_{7}, I_{2}, I_{4}, I_{6}, I_{8}\\rangle$。然后，它按此固定列表发射指令；如果下一条指令尚未就绪，则发出一个 NOP 并在下一个周期重试。\n- 延迟隐藏列表调度器：在每个周期，如果存在任何就绪的指令，它会发射一条（每周期一条）以最小化完成时间，同时遵循依赖关系。\n\n将指令排序问题建模为：生成一个拓扑序，然后根据上述延迟就绪约束将指令放置在不同周期上。计算量 $\\Delta T = T_{\\text{naive}} - T_{\\text{opt}}$，其中 $T_{\\text{naive}}$ 是朴素调度器下的完成时间，$T_{\\text{opt}}$ 是延迟隐藏列表调度器下可实现的最小完成时间。你的最终答案必须是给出 $\\Delta T$ 值的单个整数。无需四舍五入。",
            "solution": "用户要求我按照指定的说明解决问题。\n\n### 步骤 1：问题验证\n\n我必须首先验证问题陈述。\n\n#### 步骤 1.1：提取已知条件\n- **机器模型：** 单发射流水线。\n- **指令调度：** 基于表示真数据依赖的有向无环图（DAG）。\n- **计时：**\n  - 每条指令在 $1$ 个周期内发射。\n  - 延迟为 $\\ell$ 的指令的结果在其发射后 $\\ell$ 个周期变为可用。\n  - 时间从周期 $0$ 开始。\n- **就绪条件：** 一条指令只有在周期 $C$ 满足 $C \\ge \\text{IssueTime}(P) + \\text{Latency}(P)$ 时才能被发射，其中 $P$ 为其所有前驱指令。\n- **NOP：** 如果调度器遵循固定顺序且下一条指令未就绪，则发出一个占用 $1$ 个周期的空操作（NOP）。\n- **DAG 结构：**\n  - 节点：$I_{1}, I_{2}, I_{3}, I_{4}, I_{5}, I_{6}, I_{7}, I_{8}$。\n  - 边（依赖链）：$I_{1}\\rightarrow I_{3}\\rightarrow I_{5}\\rightarrow I_{7}$。\n  - 独立节点（无入边或出边）：$I_{2}, I_{4}, I_{6}, I_{8}$。\n- **延迟 ($\\ell$):**\n  - $I_{1}$ (加载): $L_{\\text{ld}}=4$。\n  - $I_{3}$ (ALU): $L_{\\text{alu}}=1$。\n  - $I_{5}$ (乘法): $L_{\\text{mul}}=3$。\n  - $I_{7}$ (ALU): $L_{\\text{alu}}=1$。\n  - $I_{2}, I_{4}, I_{6}, I_{8}$ (独立 ALU): $L_{\\text{alu}}=1$。\n- **完成时间 ($T$):** $T = \\max_{i} (\\text{IssueTime}(I_i) + \\text{Latency}(I_i))$。\n- **调度器：**\n  - **朴素调度器：** 使用固定的拓扑序 $\\langle I_{1}, I_{3}, I_{5}, I_{7}, I_{2}, I_{4}, I_{6}, I_{8}\\rangle$。如果下一条指令未就绪，则插入 NOP。\n  - **最优调度器（延迟隐藏列表调度器）：** 在每个周期，发射任何就绪的指令以实现最小完成时间。\n- **目标：** 计算 $\\Delta T = T_{\\text{naive}} - T_{\\text{opt}}$。\n\n#### 步骤 1.2：使用提取的已知条件进行验证\n1.  **科学或事实上的不健全性：** 问题是健全的。它描述了一个简单处理器流水线的经典指令调度场景，这是计算机体系结构和编译器设计中的一个基本主题。所有概念（DAG、延迟、列表调度）都是标准的。\n2.  **不可形式化或不相关：** 问题是高度可形式化的，并且与编译器原理直接相关。\n3.  **不完整或矛盾的设置：** 问题是自洽的。它提供了图、延迟、机器模型和调度算法。没有矛盾之处。\n4.  **不切实际或不可行：** 该模型是一个简化但标准且合理的顺序执行处理器流水线表示。延迟值是合理的。\n5.  **不适定或结构不良：** 问题是适定的。每种调度器的规则都定义得很清楚，目标是一个特定的定量结果。存在唯一的解。\n6.  **伪深刻、琐碎或同义反复：** 问题并非琐碎。它需要对两种不同的调度策略进行逐步模拟和比较，展示了编译器优化的核心权衡。\n7.  **超出科学可验证性范围：** 结果可以通过应用所述的模拟规则进行验证。\n\n#### 步骤 1.3：结论与行动\n问题有效。我将继续进行求解。\n\n### 步骤 2：求解\n\n问题要求我们计算两种不同调度策略的完成时间并找出它们的差值。我们定义指令 $I$ 的发射时间为 $t_{issue}(I)$，其结果可用时间为 $t_{ready}(I) = t_{issue}(I) + \\ell(I)$，其中 $\\ell(I)$ 是 $I$ 的延迟。总完成时间为 $T = \\max_{i} (t_{ready}(I_i))$。一条指令 $I$ 在周期 $C$ 就绪可发射，当且仅当 $C \\ge \\max_{P \\in \\text{preds}(I)} (t_{ready}(P))$。如果 $I$ 没有前驱指令，它在周期 $0$ 就绪。\n\n#### 朴素调度器分析\n朴素调度器按固定顺序 $\\langle I_{1}, I_{3}, I_{5}, I_{7}, I_{2}, I_{4}, I_{6}, I_{8}\\rangle$ 处理指令。它每次前进一个周期，如果列表中的下一条指令就绪，则发射该指令，否则发射一个 NOP。\n\n- **周期 $0$**：调度器考虑 $I_{1}$。$I_{1}$ 没有前驱指令，因此就绪。\n  - 发射 $I_{1}$。$t_{issue}(I_{1}) = 0$。\n  - $t_{ready}(I_{1}) = t_{issue}(I_{1}) + L_{\\text{ld}} = 0 + 4 = 4$。\n\n- **周期 $1$**：调度器考虑 $I_{3}$。其前驱是 $I_{1}$。$I_{3}$ 在周期 $C$ 就绪，当且仅当 $C \\ge t_{ready}(I_1) = 4$。由于当前周期是 $1$，$I_{3}$ 未就绪。\n  - 发射 NOP。\n\n- **周期 $2$**：调度器再次考虑 $I_{3}$。就绪条件要求周期 $\\ge 4$。当前周期是 $2$。\n  - 发射 NOP。\n\n- **周期 $3$**：调度器再次考虑 $I_{3}$。就绪条件要求周期 $\\ge 4$。当前周期是 $3$。\n  - 发射 NOP。\n\n- **周期 $4$**：调度器考虑 $I_{3}$。当前周期是 $4$，因此它已就绪。\n  - 发射 $I_{3}$。$t_{issue}(I_{3}) = 4$。\n  - $t_{ready}(I_{3}) = t_{issue}(I_{3}) + L_{\\text{alu}} = 4 + 1 = 5$。\n\n- **周期 $5$**：调度器考虑 $I_{5}$。其前驱是 $I_{3}$。就绪条件要求周期 $\\ge t_{ready}(I_3) = 5$。当前周期是 $5$，因此它已就绪。\n  - 发射 $I_{5}$。$t_{issue}(I_{5}) = 5$。\n  - $t_{ready}(I_{5}) = t_{issue}(I_{5}) + L_{\\text{mul}} = 5 + 3 = 8$。\n\n- **周期 $6$**：调度器考虑 $I_{7}$。其前驱是 $I_{5}$。就绪条件要求周期 $\\ge t_{ready}(I_5) = 8$。当前周期是 $6$。\n  - 发射 NOP。\n\n- **周期 $7$**：调度器再次考虑 $I_{7}$。就绪条件要求周期 $\\ge 8$。当前周期是 $7$。\n  - 发射 NOP。\n\n- **周期 $8$**：调度器考虑 $I_{7}$。当前周期是 $8$，因此它已就绪。\n  - 发射 $I_{7}$。$t_{issue}(I_{7}) = 8$。\n  - $t_{ready}(I_{7}) = t_{issue}(I_{7}) + L_{\\text{alu}} = 8 + 1 = 9$。\n\n- **周期 $9$**：调度器考虑 $I_{2}$。它没有前驱指令，因此就绪。\n  - 发射 $I_{2}$。$t_{issue}(I_{2}) = 9$。\n  - $t_{ready}(I_{2}) = t_{issue}(I_{2}) + L_{\\text{alu}} = 9 + 1 = 10$。\n\n- **周期 $10$**：调度器考虑 $I_{4}$。它已就绪。\n  - 发射 $I_{4}$。$t_{issue}(I_{4}) = 10$。\n  - $t_{ready}(I_{4}) = t_{issue}(I_{4}) + L_{\\text{alu}} = 10 + 1 = 11$。\n\n- **周期 $11$**：调度器考虑 $I_{6}$。它已就绪。\n  - 发射 $I_{6}$。$t_{issue}(I_{6}) = 11$。\n  - $t_{ready}(I_{6}) = t_{issue}(I_{6}) + L_{\\text{alu}} = 11 + 1 = 12$。\n\n- **周期 $12$**：调度器考虑 $I_{8}$。它已就绪。\n  - 发射 $I_{8}$。$t_{issue}(I_{8}) = 12$。\n  - $t_{ready}(I_{8}) = t_{issue}(I_{8}) + L_{\\text{alu}} = 12 + 1 = 13$。\n\n朴素调度器的完成时间 $T_{\\text{naive}}$ 是所有结果可用时间的最大值：\n$$T_{\\text{naive}} = \\max(4, 5, 8, 9, 10, 11, 12, 13) = 13$$\n\n#### 最优调度器分析\n最优调度器的目标是最小化完成时间。它可以在每个周期选择任何就绪的指令。生成最优调度的一个良好启发式策略是优先处理关键路径上的指令，并使用独立指令来填充停顿周期。\n\n最小完成时间有一个下界，即考虑了延迟的 DAG 的关键路径长度。关键路径是依赖链 $I_{1}\\rightarrow I_{3}\\rightarrow I_{5}\\rightarrow I_{7}$。\n- $I_{1}$ 可以在周期 $0$ 发射。其结果在 $t_{ready}(I_1) = 0 + 4 = 4$ 时可用。\n- $I_{3}$ 最早可以在周期 $4$ 发射。如果在周期 $4$ 发射，其结果在 $t_{ready}(I_3) = 4 + 1 = 5$ 时可用。\n- $I_{5}$ 最早可以在周期 $5$ 发射。如果在周期 $5$ 发射，其结果在 $t_{ready}(I_5) = 5 + 3 = 8$ 时可用。\n- $I_{7}$ 最早可以在周期 $8$ 发射。如果在周期 $8$ 发射，其结果在 $t_{ready}(I_7) = 8 + 1 = 9$ 时可用。\n关键路径长度为 $9$ 个周期。因此，$T_{\\text{opt}} \\ge 9$。我们来构造一个试图达到此下界的调度。\n\n- **周期 $0$**：就绪指令集：$\\{I_{1}, I_{2}, I_{4}, I_{6}, I_{8}\\}$。调度器发射 $I_{1}$ 以启动关键路径。\n  - 发射 $I_{1}$。$t_{issue}(I_{1}) = 0$, $t_{ready}(I_{1}) = 4$。\n\n- **周期 $1$**, **$2$**, **$3$**：在这些周期中，$I_{3}$ 尚未就绪。调度器可以发射独立指令来隐藏 $I_{1}$ 的延迟。\n  - 周期 $1$：就绪指令集 $\\{I_{2}, I_{4}, I_{6}, I_{8}\\}$。发射 $I_{2}$。$t_{issue}(I_{2}) = 1$, $t_{ready}(I_{2}) = 1+1=2$。\n  - 周期 $2$：就绪指令集 $\\{I_{4}, I_{6}, I_{8}\\}$。发射 $I_{4}$。$t_{issue}(I_{4}) = 2$, $t_{ready}(I_{4}) = 2+1=3$。\n  - 周期 $3$：就绪指令集 $\\{I_{6}, I_{8}\\}$。发射 $I_{6}$。$t_{issue}(I_{6}) = 3$, $t_{ready}(I_{6}) = 3+1=4$。\n\n- **周期 $4$**：在此周期开始时，$t_{ready}(I_1)=4$ 条件满足，因此 $I_{3}$ 变为就绪。\n  - 就绪指令集：$\\{I_{3}, I_{8}\\}$。调度器优先发射 $I_{3}$（关键路径）。\n  - 发射 $I_{3}$。$t_{issue}(I_{3}) = 4$, $t_{ready}(I_{3}) = 4+1=5$。\n\n- **周期 $5$**：$t_{ready}(I_3)=5$ 条件满足，因此 $I_{5}$ 变为就绪。\n  - 就绪指令集：$\\{I_{5}, I_{8}\\}$。调度器优先发射 $I_{5}$（关键路径）。\n  - 发射 $I_{5}$。$t_{issue}(I_{5}) = 5$, $t_{ready}(I_{5}) = 5+3=8$。\n\n- **周期 $6$**：$I_{7}$ 尚未就绪（要求周期 $\\ge 8$）。\n  - 就绪指令集：$\\{I_{8}\\}$。\n  - 发射 $I_{8}$。$t_{issue}(I_{8}) = 6$, $t_{ready}(I_{8}) = 6+1=7$。\n\n- **周期 $7$**：所有独立指令都已发射。唯一剩下的指令是 $I_{7}$，它要到周期 $8$ 才就绪。\n  - 就绪指令集：$\\emptyset$。\n  - 发射 NOP。\n\n- **周期 $8$**：$t_{ready}(I_5)=8$ 条件满足，因此 $I_{7}$ 变为就绪。\n  - 就绪指令集：$\\{I_{7}\\}$。\n  - 发射 $I_{7}$。$t_{issue}(I_{7}) = 8$, $t_{ready}(I_{7}) = 8+1=9$。\n\n此调度的结果可用时间为：$t_{ready}(I_{1})=4$, $t_{ready}(I_{2})=2$, $t_{ready}(I_{4})=3$, $t_{ready}(I_{6})=4$, $t_{ready}(I_{3})=5$, $t_{ready}(I_{5})=8$, $t_{ready}(I_{8})=7$, $t_{ready}(I_{7})=9$。\n\n最优调度器的完成时间 $T_{\\text{opt}}$ 是这些结果可用时间的最大值：\n$$T_{\\text{opt}} = \\max(4, 2, 3, 4, 5, 8, 7, 9) = 9$$\n这个调度达到了 $9$ 个周期的下界，因此是最优的。\n\n#### 最终计算\n需要计算的量是 $\\Delta T = T_{\\text{naive}} - T_{\\text{opt}}$。\n$$ \\Delta T = 13 - 9 = 4 $$\n与朴素调度器相比，延迟隐藏调度器将完成时间缩短了 $4$ 个周期。",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "上一节练习揭示了“延迟感知”的重要性，而“延迟隐藏”正是实现这一目标的核心技术。像除法或内存加载这样的长延迟操作是流水线停顿的主要来源，但通过在此期间执行不相关的独立指令，我们可以有效“隐藏”这些延迟。本练习将通过一个具体的场景，让您精确计算通过指令重排来填充延迟“空隙”可以节省多少个时钟周期，从而深化您对延迟隐藏策略的理解 。",
            "id": "3647160",
            "problem": "一个编译器面向一个顺序、单发射流水线，该流水线具有以下基于标准流水线语义中相关性和延迟的特性。该机器每个周期最多能发射 $1$ 条指令。一条使用先前指令结果的指令，只有当其所有源操作数都可用时才能发射。每条指令都有一个固定的生产者-消费者延迟，该延迟等于生产者指令的发射周期与相关的消费者指令可以在零停顿下发射的最早周期之间的周期数。整数算术逻辑单元 (ALU) 操作的延迟为 $1$ 个周期。整数除法操作的延迟为 $L_{\\text{div}}$ 个周期。假设不存在结构性冒险，且当操作数准备好时，功能单元总是可用的。\n\n考虑一个循环体，在未经调度的朴素形式下，每次迭代执行以下序列：\n- 使用延迟为 $L_{\\text{div}}$ 的整数除法计算 $t \\leftarrow a / b$。\n- 立即在一个相关的整数 ALU 操作 $u \\leftarrow t + c$ 中使用 $t$。\n- 执行 $M$ 个整数 ALU 操作，这些操作与除法结果 $t$ 及其消费者 $u$ 均无关。这 $M$ 个操作可以在除法指令及其消费者指令之间自由重排，只要它们相互之间的程序顺序得以保留，并且所有这些操作的延迟均为 $1$ 个周期。\n\n编译器执行局部指令调度，通过将 $M$ 个无关整数 ALU 操作中的一部分交错插入到产生 $t$ 的除法指令和使用 $t$ 的消费者指令之间，以尽可能多地隐藏除法延迟。假设没有其他约束阻止这种移动，并且机器仍必须按顺序发射。\n\n给定 $L_{\\text{div}} = 19$ 和 $M = 12$，从第一性原理出发，推导与消费者 $t$ 紧跟在除法指令之后的朴素顺序相比，该调度方法每次迭代节省的周期数。以每次迭代节省的周期数的整数形式表示你的答案。不要四舍五入；以周期为单位表示最终答案。",
            "solution": "此问题要求在一个简单的顺序、单发射处理器中，分析由数据相关引起的流水线停顿。我们必须确定通过重排指令以隐藏除法操作的长延迟所节省的周期数。一次迭代的总周期数定义为从第一条指令的发射到最后一条指令的发射（含）之间的周期数。在单发射机器上，这等同于该序列所需的总发射槽数（包括忙碌或停顿的）。\n\n我们首先分析未经调度的朴素指令序列每次迭代的总周期数。该序列是：\n$1$. `div`: $t \\leftarrow a / b$\n$2$. `add`: $u \\leftarrow t + c$\n$3$. $M$ 个无关的 ALU 操作。\n\n该机器是顺序、单发射的。设 `div` 指令在周期 $C_0$ 发射。`add` 指令与 `div` 指令存在数据相关，后者的延迟为 $L_{\\text{div}}$ 个周期。根据定义，这意味着相关的指令最早只能在 `div` 指令发射后 $L_{\\text{div}}$ 个周期才能发射。因此，`add` 指令不能在周期 $C_0 + L_{\\text{div}}$ 之前发射。\n\n在朴素序列中，`add` 指令紧跟在 `div` 指令之后。流水线将尝试在周期 $C_0 + 1$ 发射 `add` 指令。然而，由于操作数 $t$ 尚未准备好，流水线必须停顿。停顿将占据从周期 $C_0 + 1$ 到周期 $C_0 + L_{\\text{div}}$（不含）的发射槽。停顿周期数为 $(C_0 + L_{\\text{div}} - 1) - (C_0 + 1) + 1 = L_{\\text{div}} - 1$。\n\n总周期数 $T_{\\text{naive}}$ 是发射每条指令所需的周期和任何插入的停顿周期的总和：\n- `div` 指令发射占用 $1$ 个周期。\n- $L_{\\text{div}} - 1$ 个周期的流水线停顿。\n- 相关的 `add` 指令发射占用 $1$ 个周期。\n- $M$ 个无关的 ALU 操作顺序发射占用 $M$ 个周期。\n\n将这些相加，朴素序列的总周期数为：\n$$T_{\\text{naive}} = 1 + (L_{\\text{div}} - 1) + 1 + M = L_{\\text{div}} + M + 1$$\n\n接下来，我们分析经过优化的、调度后的指令序列的总周期数。编译器将 $M$ 个无关操作移动到 `div` 和相关的 `add` 之间以隐藏除法延迟。调度后的序列是：\n$1$. `div`: $t \\leftarrow a / b$\n$2$. $M$ 个无关的 ALU 操作。\n$3$. `add`: $u \\leftarrow t + c$\n\n设 `div` 指令在周期 $C_0$ 发射。由于接下来的 $M$ 个 ALU 操作是无关的，它们可以在随后的周期中发射，每个周期一个。\n- `div` 指令在周期 $C_0$ 发射。\n- $M$ 个无关操作在周期 $C_0+1, C_0+2, \\dots, C_0+M$ 发射。\n\n在最后一个无关操作于周期 $C_0+M$ 发射后，流水线准备好在周期 $C_0+M+1$ 发射 `add` 指令。然而，`add` 仍然与 `div` 有数据相关。结果 $t$ 在周期 $C_0 + L_{\\text{div}}$ 可用。因此，`add` 指令只能在这两个时间中的较晚者发射：即它在指令流中变得可用的时间，以及其数据相关被解决的时间。\n`add` 的发射周期是 $C_{\\text{issue,add}} = \\max(C_0+M+1, C_0+L_{\\text{div}})$。\n我们通过设置 $C_0 = 0$ 来进行归一化。`add` 指令在周期 $\\max(M+1, L_{\\text{div}})$ 发射。\n\n调度后序列的总周期数 $T_{\\text{scheduled}}$ 可以通过对发射槽求和来计算。\n- `div` 指令占用 $1$ 个周期。\n- $M$ 个无关操作占用 $M$ 个周期。\n- 在 `add` 指令可以发射之前可能存在一个停顿期。\n- `add` 指令占用 $1$ 个周期。\n\n`div` 和 $M$ 个操作背靠背发射，占用 $M+1$ 个周期。经过的时间是 $M+1$ 个周期。从 `div` 发射到 `add` 准备好发射（结构上）之间经过的周期数是 $M+1$。所需的时间间隔是 $L_{\\text{div}}$。如果 $M+1  L_{\\text{div}}$，我们需要停顿 $L_{\\text{div}} - (M+1)$ 个周期。\n总周期数为：\n$T_{\\text{scheduled}} = (\\text{div周期}) + (\\text{M个操作的周期}) + (\\text{停顿周期}) + (\\text{add周期})$\n$T_{\\text{scheduled}} = 1 + M + \\max(0, L_{\\text{div}} - (M+1)) + 1 = M+2 + \\max(0, L_{\\text{div}}-M-1)$。\n如果 $M+1 \\ge L_{\\text{div}}$，则 $T_{\\text{scheduled}} = M+2$。\n如果 $M+1  L_{\\text{div}}$，则 $T_{\\text{scheduled}} = M+2 + L_{\\text{div}}-M-1 = L_{\\text{div}}+1$。\n这可以表示为 $T_{\\text{scheduled}} = \\max(M+2, L_{\\text{div}}+1)$。这似乎是正确的。\n\n节省的周期数 $\\Delta T$ 是朴素执行时间和调度后执行时间之差：\n$\\Delta T = T_{\\text{naive}} - T_{\\text{scheduled}}$\n$\\Delta T = (L_{\\text{div}} + M + 1) - \\max(M+2, L_{\\text{div}}+1)$\n\n我们根据 $M$ 和 $L_{\\text{div}}$ 之间的关系来评估这个表达式。\n情况1：$M+1 \\ge L_{\\text{div}}$ (或 $M \\ge L_{\\text{div}}-1$)。这意味着有足够多的无关指令来完全隐藏除法延迟。\n在这种情况下，$\\max(M+2, L_{\\text{div}}+1) = M+2$。\n$\\Delta T = (L_{\\text{div}} + M + 1) - (M+2) = L_{\\text{div}} - 1$。\n节省的周期数等于朴素调度中的停顿周期数，即 $L_{\\text{div}}-1$。\n\n情况2：$M+1  L_{\\text{div}}$ (或 $M  L_{\\text{div}}-1$)。没有足够多的无关指令来完全隐藏延迟。\n在这种情况下，$\\max(M+2, L_{\\text{div}}+1) = L_{\\text{div}}+1$。\n$\\Delta T = (L_{\\text{div}} + M + 1) - (L_{\\text{div}}+1) = M$。\n节省的周期数等于可用于填充停顿槽的无关指令数量 $M$。\n\n结合这两种情况，节省的周期数是可被现有 $M$ 个无关指令填充的停顿槽（$L_{\\text{div}}-1$）的数量。这由以下公式给出：\n$$\\Delta T = \\min(M, L_{\\text{div}}-1)$$\n\n我们已知数值 $L_{\\text{div}} = 19$ 和 $M=12$。\n我们计算潜在的停顿周期数：\n$L_{\\text{div}}-1 = 19-1 = 18$。\n我们有 $M=12$ 条无关指令。\n由于 $M  L_{\\text{div}}-1$ ($12  18$)，我们处于第二种情况。我们只能填充 $18$ 个停顿槽中的 $12$ 个。\n节省的周期数为：\n$$\\Delta T = \\min(12, 18) = 12$$\n\n每次迭代节省的周期数是 $12$。",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "在掌握了数据依赖和延迟隐藏的基本原则后，是时候面对真实处理器所带来的额外挑战了：有限的硬件资源。现代超标量处理器虽然可以并行执行多条指令，但其功能单元（如加法器、乘法器）和发射端口的数量是有限的。本练习将要求您在一个模拟的、具有明确资源限制的处理器上进行指令调度，这不仅需要您尊重由数据依赖关系决定的“关键路径”，还必须遵守硬件的资源约束，这代表了编译器为现代 CPU 进行性能优化时所面临的综合性挑战 。",
            "id": "3647154",
            "problem": "考虑一个包含 $n=8$ 条指令的基本块，该基本块需要在一个具有多个功能单元和明确资源限制的单发射核上进行调度。目标是计算该依赖结构的关键路径，并构建一个合法的调度方案，如果可能的话，使其达到关键路径长度。指令集和机器模型如下。\n\n机器模型：\n- 每个周期最多可以发射 $2$ 条指令。\n- 有 $2$ 个 load/store 单元（每个单元每个周期最多能接受 $1$ 个内存操作；内存系统是双端口的，因此最多可以在同一周期内发射 $2$ 个内存操作）。\n- 有 $1$ 个整数加法单元，用于加法和减法。\n- 有 $1$ 个乘法单元。\n- 所有功能单元都是完全流水线化的。\n- 操作延迟（从发射到结果可用的周期数）如下：load $=$ $2$，add $=$ $1$，multiply $=$ $3$，store $=$ $1$。\n- 一条指令只有在其所有操作数都可用时才能发射。如果指令 $u$ 的延迟为 $\\ell(u)$，并在周期 $s(u)$ 发射，那么其结果在周期 $r(u)=s(u)+\\ell(u)$ 可用。\n- 存储指令要求其值操作数在发射时可用，并占用一个 load/store 单元 $1$ 个周期。\n\n基本块（寄存器 $r_i$ 和内存位置 $M[\\cdot]$ 是体系结构级别的）：\n- $I_1$: $r_1 \\leftarrow M[a]$ (load)\n- $I_2$: $r_2 \\leftarrow M[b]$ (load)\n- $I_3$: $r_3 \\leftarrow r_1 \\times r_2$ (multiply)\n- $I_4$: $r_4 \\leftarrow r_3 + r_5$ (add)，其中 $r_5$ 在周期 $0$ 时已可用\n- $I_5$: $r_6 \\leftarrow r_4 + r_7$ (add)，其中 $r_7$ 在周期 $0$ 时已可用\n- $I_6$: $M[c] \\leftarrow r_6$ (store)\n- $I_7$: $r_8 \\leftarrow r_2 + r_9$ (add)，其中 $r_9$ 在周期 $0$ 时已可用\n- $I_8$: $r_{10} \\leftarrow r_8 + r_{11}$ (add)，其中 $r_{11}$ 在周期 $0$ 时已可用\n\n数据依赖：\n- $I_3$ 依赖于 $I_1$ 和 $I_2$。\n- $I_4$ 依赖于 $I_3$。\n- $I_5$ 依赖于 $I_4$。\n- $I_6$ 依赖于 $I_5$。\n- $I_7$ 依赖于 $I_2$。\n- $I_8$ 依赖于 $I_7$。\n- 除非由上述关系推导得出，否则所有其他指令对都是独立的。\n\n任务：\n- 根据数据依赖和指令延迟的定义，确定此基本块依赖结构中关键路径的长度（以周期为单位），忽略资源冲突但需考虑数据就绪情况。\n- 然后，在上述资源限制条件下，提出一个逐周期的合法调度方案，如果可能的话，使其达到此关键路径界限。\n- 报告在此模型下该基本块的最小完成时间（makespan），单位为周期。你的最终答案必须是一个整数周期数，无需四舍五入。",
            "solution": "用户要求我解决一个指令调度问题，该问题属于编译器原理和计算机体系结构的范畴。\n\n### 步骤1：提取给定信息\n- 指令数量：$n=8$。\n- 机器模型：\n  - 发射宽度：每个周期最多 $2$ 条指令。\n  - 功能单元：$2$ 个 load/store 单元， $1$ 个整数 add 单元， $1$ 个 multiply 单元。所有单元都是完全流水线化的。\n- 操作延迟 ($\\ell$):\n  - $\\ell(\\text{load}) = 2$ 周期。\n  - $\\ell(\\text{add}) = 1$ 周期。\n  - $\\ell(\\text{multiply}) = 3$ 周期。\n  - $\\ell(\\text{store}) = 1$ 周期。\n- 时序模型：一条指令 $u$ 在周期 $s(u)$ 发射，其结果在周期 $r(u) = s(u) + \\ell(u)$ 可用。依赖指令可以在其操作数结果可用的周期或之后发射。\n- 指令：\n  - $I_1$: $r_1 \\leftarrow M[a]$ (load)\n  - $I_2$: $r_2 \\leftarrow M[b]$ (load)\n  - $I_3$: $r_3 \\leftarrow r_1 \\times r_2$ (multiply)\n  - $I_4$: $r_4 \\leftarrow r_3 + r_5$ (add)\n  - $I_5$: $r_6 \\leftarrow r_4 + r_7$ (add)\n  - $I_6$: $M[c] \\leftarrow r_6$ (store)\n  - $I_7$: $r_8 \\leftarrow r_2 + r_9$ (add)\n  - $I_8$: $r_{10} \\leftarrow r_8 + r_{11}$ (add)\n- 外部输入：寄存器 $r_5, r_7, r_9, r_{11}$ 在周期 $0$ 时可用。\n- 数据依赖：\n  - $I_3$ 依赖于 $I_1$ 和 $I_2$。($I_1 \\to I_3, I_2 \\to I_3$)\n  - $I_4$ 依赖于 $I_3$。($I_3 \\to I_4$)\n  - $I_5$ 依赖于 $I_4$。($I_4 \\to I_5$)\n  - $I_6$ 依赖于 $I_5$。($I_5 \\to I_6$)\n  - $I_7$ 依赖于 $I_2$。($I_2 \\to I_7$)\n  - $I_8$ 依赖于 $I_7$。($I_7 \\to I_8$)\n\n### 步骤2：使用提取的信息进行验证\n该问题在计算机体系结构和编译器理论中具有科学依据。这是一个明确定义的指令调度问题，具有清晰的约束、依赖关系和目标。所提供的数据是自洽、一致且足以推导出解决方案的。该模型虽然经过简化，却是超标量处理器流水线调度挑战的标准表示。没有事实错误、逻辑矛盾或主观因素。\n\n### 步骤3：结论和行动\n问题有效。将构建一个解决方案。\n\n### 解决方案推导\n\n主要目标是找到给定基本块的最小完成时间（makespan）。这是一个两步过程：首先，通过计算数据依赖图（DDG）中关键路径的长度来确定 makespan 的下限，此步骤忽略资源约束。其次，尝试构建一个满足此下限并遵守所有资源约束的调度方案。\n\n#### 第一部分：关键路径分析\n关键路径是数据依赖图（DDG）中的最长路径，路径的长度是在该路径上执行指令序列所需的最短时间。长度由延迟之和决定。设 $s(I)$ 为指令 $I$ 的发射周期，$r(I)$ 为其结果可用的周期，且 $r(I) = s(I) + \\ell(I)$。对于一个依赖关系 $I_A \\to I_B$，$I_B$ 的最早发射时间为 $s(I_B) \\geq r(I_A)$。我们假设执行从周期 $1$ 开始。\n\n依赖关系在 DDG 中形成两条主路径：\n1.  路径 A：$I_1 \\to I_3 \\to I_4 \\to I_5 \\to I_6$（以及从 $I_2$ 开始的并行路径）\n2.  路径 B：$I_2 \\to I_7 \\to I_8$\n\n我们来计算每条路径的长度，它表示如果只有该路径存在时的最早完成时间。\n\n**路径 A 的计算（$I_1 \\to I_3 \\to I_4 \\to I_5 \\to I_6$）：**\n- $I_1$ (load, $\\ell=2$) 在基本块内没有依赖。它可以在周期 $1$ 发射。\n  - 最早发射时间 $s(I_1) = 1$。\n  - 结果在 $r(I_1) = s(I_1) + \\ell(I_1) = 1 + 2 = 3$ 时可用。\n- $I_2$ (load, $\\ell=2$) 也可以在周期 $1$ 发射。其结果也在 $r(I_2) = 1 + 2 = 3$ 时可用。\n- $I_3$ (multiply, $\\ell=3$) 依赖于 $I_1$ 和 $I_2$。它可以在两个结果都就绪时发射。\n  - 最早发射时间 $s(I_3) = \\max(r(I_1), r(I_2)) = \\max(3, 3) = 3$。\n  - 结果在 $r(I_3) = s(I_3) + \\ell(I_3) = 3 + 3 = 6$ 时可用。\n- $I_4$ (add, $\\ell=1$) 依赖于 $I_3$。\n  - 最早发射时间 $s(I_4) = r(I_3) = 6$。\n  - 结果在 $r(I_4) = s(I_4) + \\ell(I_4) = 6 + 1 = 7$ 时可用。\n- $I_5$ (add, $\\ell=1$) 依赖于 $I_4$。\n  - 最早发射时间 $s(I_5) = r(I_4) = 7$。\n  - 结果在 $r(I_5) = s(I_5) + \\ell(I_5) = 7 + 1 = 8$ 时可用。\n- $I_6$ (store, $\\ell=1$) 依赖于 $I_5$。\n  - 最早发射时间 $s(I_6) = r(I_5) = 8$。\n  - 该指令在周期 $8$ 执行，并在周期 $8$ 结束时完成。\n该路径的总时间是 $8$ 个周期。\n\n**路径 B 的计算（$I_2 \\to I_7 \\to I_8$）：**\n- $I_2$ (load, $\\ell=2$) 可以在周期 $1$ 发射。\n  - 最早发射时间 $s(I_2) = 1$。\n  - 结果在 $r(I_2) = 1+2 = 3$ 时可用。\n- $I_7$ (add, $\\ell=1$) 依赖于 $I_2$。\n  - 最早发射时间 $s(I_7) = r(I_2) = 3$。\n  - 结果在 $r(I_7) = 3+1 = 4$ 时可用。\n- $I_8$ (add, $\\ell=1$) 依赖于 $I_7$。\n  - 最早发射时间 $s(I_8) = r(I_7) = 4$。\n  - 结果在 $r(I_8) = 4+1 = 5$ 时可用。\n该路径上的最后一条指令在周期 $5$ 结束时完成。\n\n关键路径是最长的路径，即路径 A。因此，由数据依赖决定的此基本块的最小可能 makespan 为 $8$ 个周期。\n\n#### 第二部分：资源受限的调度\n现在，我们必须构建一个遵守资源限制的调度方案：每个周期 $2$ 个发射槽、$2$ 个 load/store 单元、$1$ 个 add 单元和 $1$ 个 multiply 单元。目标是实现 $8$ 个周期的 makespan。\n\n我们可以逐周期构建调度方案：\n\n- **周期 1：**\n  - 就绪指令：$I_1, I_2$。\n  - 调度：发射 $I_1$ (load) 和 $I_2$ (load)。\n  - 使用的资源：$2$ 个发射槽，$2$ 个 load/store 单元。这是有效的。\n  - 结果可用时间：$r(I_1) = 1+2=3$，$r(I_2) = 1+2=3$。\n\n- **周期 2：**\n  - 就绪指令：无。我们正在等待 $I_1$ 和 $I_2$ 完成。\n  - 调度：停顿。\n  - 使用的资源：无。\n\n- **周期 3：**\n  - 就绪指令：在周期 $3$ 开始时，$I_1$ 和 $I_2$ 的结果可用。这使得 $I_3$（依赖于 $I_1, I_2$）和 $I_7$（依赖于 $I_2$）就绪。\n  - 调度：发射 $I_3$ (multiply) 和 $I_7$ (add)。\n  - 使用的资源：$2$ 个发射槽，$1$ 个 multiply 单元，$1$ 个 add 单元。这是有效的。\n  - 结果可用时间：$r(I_3) = 3+3=6$，$r(I_7) = 3+1=4$。\n\n- **周期 4：**\n  - 就绪指令：在周期 $4$ 开始时，$I_7$ 的结果可用。这使得 $I_8$（依赖于 $I_7$）就绪。\n  - 调度：发射 $I_8$ (add)。\n  - 使用的资源：$1$ 个发射槽，$1$ 个 add 单元。这是有效的。\n  - 结果可用时间：$r(I_8) = 4+1=5$。\n\n- **周期 5：**\n  - 就绪指令：无。关键路径上的下一条指令 $I_4$ 正在等待 $I_3$，其结果直到周期 $6$ 才可用。旁路（$I_8$）已完成。\n  - 调度：停顿。\n  - 使用的资源：无。\n\n- **周期 6：**\n  - 就绪指令：在周期 $6$ 开始时，$I_3$ 的结果可用。这使得 $I_4$（依赖于 $I_3$）就绪。\n  - 调度：发射 $I_4$ (add)。\n  - 使用的资源：$1$ 个发射槽，$1$ 个 add 单元。这是有效的。\n  - 结果可用时间：$r(I_4) = 6+1=7$。\n\n- **周期 7：**\n  - 就绪指令：在周期 $7$ 开始时，$I_4$ 的结果可用。这使得 $I_5$（依赖于 $I_4$）就绪。\n  - 调度：发射 $I_5$ (add)。\n  - 使用的资源：$1$ 个发射槽，$1$ 个 add 单元。这是有效的。\n  - 结果可用时间：$r(I_5) = 7+1=8$。\n\n- **周期 8：**\n  - 就绪指令：在周期 $8$ 开始时，$I_5$ 的结果可用。这使得 $I_6$（依赖于 $I_5$）就绪。\n  - 调度：发射 $I_6$ (store)。\n  - 使用的资源：$1$ 个发射槽，$1$ 个 load/store 单元。这是有效的。\n  - 该指令在周期 $8$ 执行，并在周期 $8$ 结束时完成。\n\n构建的调度方案是合法的，因为它在每个周期都遵守了所有数据依赖和资源约束。最后一条指令 $I_6$ 在周期 $8$ 结束时完成其执行。\n\n### 结论\n由数据依赖关系决定的关键路径长度为此 makespan 建立了 $8$ 个周期的下限。我们构建了一个合法的调度方案，达到了这个 makespan。因此，该基本块的最小完成时间是 $8$ 个周期。",
            "answer": "$$\\boxed{8}$$"
        }
    ]
}