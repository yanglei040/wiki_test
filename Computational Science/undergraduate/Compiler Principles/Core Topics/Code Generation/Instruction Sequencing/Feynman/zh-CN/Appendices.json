{
    "hands_on_practices": [
        {
            "introduction": "指令排序的核心目标是提升性能，但这并非意味着任何满足依赖关系的顺序都是等效的。本练习将通过对比一个固定的、朴素的拓扑排序与一个能够利用指令级并行性的优化调度器，来揭示为何智能调度至关重要。通过这个实践 ，你将亲手量化一个次优序列所带来的性能损失，从而深刻理解延迟隐藏（latency hiding）这一基本概念的价值。",
            "id": "3647127",
            "problem": "一个编译器后端在一个单发射流水线上调度指令，遵循以有向无环图 (DAG) 表示的真数据依赖。拓扑序是遵循该偏序关系的任意一种 DAG 线性化。每条指令在 $1$ 个周期内发射，其结果在其发射 $\\ell$ 个周期后可用，其中 $\\ell$ 是指令的延迟。只有当一条指令的所有前驱指令的结果都可用时，该指令才能被发射。如果一个调度器预先确定了一个固定的拓扑序，而该列表中的下一条指令尚未就绪，它必须发射一个空操作 (NOP)，该操作占用 $1$ 个周期。\n\n考虑以下基本块 DAG，其节点为 $I_{1},\\dots,I_{8}$，边为 $I_{1}\\rightarrow I_{3}\\rightarrow I_{5}\\rightarrow I_{7}$。其他节点 $I_{2}, I_{4}, I_{6}, I_{8}$ 没有入边或出边。延迟如下：\n- $I_{1}$ 是一条加载指令，延迟为 $L_{\\text{ld}}=4$。\n- $I_{3}$ 是一次算术运算，延迟为 $L_{\\text{alu}}=1$。\n- $I_{5}$ 是一次乘法运算，延迟为 $L_{\\text{mul}}=3$。\n- $I_{7}$ 是一次算术运算，延迟为 $L_{\\text{alu}}=1$。\n- $I_{2}, I_{4}, I_{6}, I_{8}$ 中的每一条都是独立的算术运算，延迟为 $L_{\\text{alu}}=1$。\n\n假设时间从周期 $0$ 开始。定义完成时间 $T$ 为所有指令的发射时间加上其延迟的最大值。\n\n考虑两种调度器：\n- 朴素拓扑序调度器：它首先通过从 $I_{1}$ 开始进行深度优先遍历来生成一个单一的拓扑排序，并且在探索不相关节点之前总是跟随其后继节点，从而得到列表 $\\langle I_{1}, I_{3}, I_{5}, I_{7}, I_{2}, I_{4}, I_{6}, I_{8}\\rangle$。然后它通过遍历这个固定列表来发射指令；如果下一条指令尚未就绪，它会发射一个 NOP，并在下一个周期重试。\n- 延迟隐藏列表调度器：在每个周期，它会发射任何就绪的指令（每个周期一条），如果存在的话，以最小化完成时间，同时遵循依赖关系。\n\n将指令排序建模为这样一个问题：生成一个拓扑序，然后根据上述的延迟就绪约束将指令放置在各个周期上。计算量 $\\Delta T = T_{\\text{naive}} - T_{\\text{opt}}$，其中 $T_{\\text{naive}}$ 是朴素调度器下的完成时间，而 $T_{\\text{opt}}$ 是延迟隐藏列表调度器下可实现的最小完成时间。你的最终答案必须是给出 $\\Delta T$ 的单个整数。不需要四舍五入。",
            "solution": "用户希望我按照指定的说明来解决问题。\n\n### 第 1 步：问题验证\n\n我必须首先验证问题陈述。\n\n#### 第 1.1 步：提取已知条件\n- **机器模型：** 单发射流水线。\n- **指令调度：** 基于表示真数据依赖的有向无环图 (DAG)。\n- **时序：**\n  - 每条指令在 $1$ 个周期内发射。\n  - 延迟为 $\\ell$ 的指令，其结果在其发射 $\\ell$ 个周期后可用。\n  - 时间从周期 $0$ 开始。\n- **就绪条件：** 一条指令可以在周期 $C$ 发射，当且仅当对于其所有前驱 $P$，$C \\ge \\text{IssueTime}(P) + \\text{Latency}(P)$。\n- **NOPs：** 如果调度器确定了固定的顺序，而下一条指令未就绪，则发射一个空操作 (NOP)，占用 $1$ 个周期。\n- **DAG 结构：**\n  - 节点：$I_{1}, I_{2}, I_{3}, I_{4}, I_{5}, I_{6}, I_{7}, I_{8}$。\n  - 边（依赖链）：$I_{1}\\rightarrow I_{3}\\rightarrow I_{5}\\rightarrow I_{7}$。\n  - 独立节点（无入边或出边）：$I_{2}, I_{4}, I_{6}, I_{8}$。\n- **延迟 ($\\ell$)：**\n  - $I_{1}$ (加载)：$L_{\\text{ld}}=4$。\n  - $I_{3}$ (ALU)：$L_{\\text{alu}}=1$。\n  - $I_{5}$ (乘法)：$L_{\\text{mul}}=3$。\n  - $I_{7}$ (ALU)：$L_{\\text{alu}}=1$。\n  - $I_{2}, I_{4}, I_{6}, I_{8}$ (独立 ALU)：$L_{\\text{alu}}=1$。\n- **完成时间 ($T$)：** $T = \\max_{i} (\\text{IssueTime}(I_i) + \\text{Latency}(I_i))$。\n- **调度器：**\n  - **朴素调度器：** 使用固定的拓扑序：$\\langle I_{1}, I_{3}, I_{5}, I_{7}, I_{2}, I_{4}, I_{6}, I_{8}\\rangle$。如果下一条指令未就绪，则插入 NOP。\n  - **最优调度器（延迟隐藏列表调度器）：** 在每个周期，发射任何就绪的指令以实现最小完成时间。\n- **目标：** 计算 $\\Delta T = T_{\\text{naive}} - T_{\\text{opt}}$。\n\n#### 第 1.2 步：使用提取的已知条件进行验证\n1.  **科学或事实不健全性：** 问题是健全的。它描述了一个简单处理器流水线的经典指令调度场景，这是计算机体系结构和编译器设计中的一个基本主题。所有概念（DAG、延迟、列表调度）都是标准的。\n2.  **不可形式化或不相关：** 问题是高度可形式化的，并且与编译器原理直接相关。\n3.  **不完整或矛盾的设置：** 问题是自洽的。它提供了图、延迟、机器模型和调度算法。没有矛盾之处。\n4.  **不切实际或不可行：** 该模型是一个简化但标准且合理的顺序处理器流水线表示。延迟值是合理的。\n5.  **不适定或结构不良：** 问题是适定的。每个调度器的规则都定义得很清楚，目标是一个具体的量化结果。存在唯一解。\n6.  **伪深刻、琐碎或同义反复：** 问题并非琐碎。它需要对两种不同的调度策略进行逐步模拟和比较，说明了编译器优化的一个核心权衡。\n7.  **超出科学可验证性：** 结果可以通过应用所述的模拟规则来验证。\n\n#### 第 1.3 步：结论与行动\n问题是 **有效的**。我将继续进行解答。\n\n### 第 2 步：解答\n\n该问题要求我们计算两种不同调度策略的完成时间，并找出它们的差值。我们将指令 $I$ 的发射时间定义为 $t_{issue}(I)$，其结果就绪时间为 $t_{ready}(I) = t_{issue}(I) + \\ell(I)$，其中 $\\ell(I)$ 是 $I$ 的延迟。总完成时间为 $T = \\max_{i} (t_{ready}(I_i))$。一条指令 $I$ 在周期 $C$ 就绪可发射的条件是 $C \\ge \\max_{P \\in \\text{preds}(I)} (t_{ready}(P))$。如果 $I$ 没有前驱，它在周期 $0$ 就绪。\n\n#### 朴素调度器分析\n朴素调度器按固定顺序 $\\langle I_{1}, I_{3}, I_{5}, I_{7}, I_{2}, I_{4}, I_{6}, I_{8}\\rangle$ 处理指令。它一次前进一个周期，如果列表中的下一条指令就绪，则发射该指令，否则发射一个 NOP。\n\n- **周期 $0$**：调度器考虑 $I_{1}$。$I_{1}$ 没有前驱，因此就绪。\n  - 发射 $I_{1}$。$t_{issue}(I_{1}) = 0$。\n  - $t_{ready}(I_{1}) = t_{issue}(I_{1}) + L_{\\text{ld}} = 0 + 4 = 4$。\n\n- **周期 $1$**：调度器考虑 $I_{3}$。其前驱是 $I_{1}$。$I_{3}$ 在周期 $C$ 就绪的条件是 $C \\ge t_{ready}(I_1) = 4$。由于当前周期是 $1$，$I_{3}$ 尚未就绪。\n  - 发射 NOP。\n\n- **周期 $2$**：再次考虑 $I_{3}$。就绪条件要求周期 $\\ge 4$。当前周期是 $2$。\n  - 发射 NOP。\n\n- **周期 $3$**：再次考虑 $I_{3}$。就绪条件要求周期 $\\ge 4$。当前周期是 $3$。\n  - 发射 NOP。\n\n- **周期 $4$**：调度器考虑 $I_{3}$。当前周期是 $4$，因此就绪。\n  - 发射 $I_{3}$。$t_{issue}(I_{3}) = 4$。\n  - $t_{ready}(I_{3}) = t_{issue}(I_{3}) + L_{\\text{alu}} = 4 + 1 = 5$。\n\n- **周期 $5$**：调度器考虑 $I_{5}$。其前驱是 $I_{3}$。就绪条件要求周期 $\\ge t_{ready}(I_3) = 5$。当前周期是 $5$，因此就绪。\n  - 发射 $I_{5}$。$t_{issue}(I_{5}) = 5$。\n  - $t_{ready}(I_{5}) = t_{issue}(I_{5}) + L_{\\text{mul}} = 5 + 3 = 8$。\n\n- **周期 $6$**：调度器考虑 $I_{7}$。其前驱是 $I_{5}$。就绪条件要求周期 $\\ge t_{ready}(I_5) = 8$。当前周期是 $6$。\n  - 发射 NOP。\n\n- **周期 $7$**：再次考虑 $I_{7}$。就绪条件要求周期 $\\ge 8$。当前周期是 $7$。\n  - 发射 NOP。\n\n- **周期 $8$**：调度器考虑 $I_{7}$。当前周期是 $8$，因此就绪。\n  - 发射 $I_{7}$。$t_{issue}(I_{7}) = 8$。\n  - $t_{ready}(I_{7}) = t_{issue}(I_{7}) + L_{\\text{alu}} = 8 + 1 = 9$。\n\n- **周期 $9$**：调度器考虑 $I_{2}$。它没有前驱，因此就绪。\n  - 发射 $I_{2}$。$t_{issue}(I_{2}) = 9$。\n  - $t_{ready}(I_{2}) = t_{issue}(I_{2}) + L_{\\text{alu}} = 9 + 1 = 10$。\n\n- **周期 $10$**：调度器考虑 $I_{4}$。它已就绪。\n  - 发射 $I_{4}$。$t_{issue}(I_{4}) = 10$。\n  - $t_{ready}(I_{4}) = t_{issue}(I_{4}) + L_{\\text{alu}} = 10 + 1 = 11$。\n\n- **周期 $11$**：调度器考虑 $I_{6}$。它已就绪。\n  - 发射 $I_{6}$。$t_{issue}(I_{6}) = 11$。\n  - $t_{ready}(I_{6}) = t_{issue}(I_{6}) + L_{\\text{alu}} = 11 + 1 = 12$。\n\n- **周期 $12$**：调度器考虑 $I_{8}$。它已就绪。\n  - 发射 $I_{8}$。$t_{issue}(I_{8}) = 12$。\n  - $t_{ready}(I_{8}) = t_{issue}(I_{8}) + L_{\\text{alu}} = 12 + 1 = 13$。\n\n朴素调度器的完成时间 $T_{\\text{naive}}$ 是所有就绪时间的最大值：\n$$T_{\\text{naive}} = \\max(4, 5, 8, 9, 10, 11, 12, 13) = 13$$\n\n#### 最优调度器分析\n最优调度器的目标是最小化完成时间。它可以在每个周期选择任何就绪的指令。生成最优调度的一个好启发式方法是优先处理关键路径上的指令，并使用独立指令来填充停顿。\n\n最小完成时间受限于考虑了延迟的 DAG 的关键路径长度。关键路径是链 $I_{1}\\rightarrow I_{3}\\rightarrow I_{5}\\rightarrow I_{7}$。\n- $I_{1}$ 可以在周期 $0$ 发射。其结果在 $t_{ready}(I_1) = 0 + 4 = 4$ 就绪。\n- $I_{3}$ 不早于周期 $4$ 发射。如果在周期 $4$ 发射，其结果在 $t_{ready}(I_3) = 4 + 1 = 5$ 就绪。\n- $I_{5}$ 不早于周期 $5$ 发射。如果在周期 $5$ 发射，其结果在 $t_{ready}(I_5) = 5 + 3 = 8$ 就绪。\n- $I_{7}$ 不早于周期 $8$ 发射。如果在周期 $8$ 发射，其结果在 $t_{ready}(I_7) = 8 + 1 = 9$ 就绪。\n关键路径长度为 $9$ 个周期。因此，$T_{\\text{opt}} \\ge 9$。让我们构建一个试图达到此下限的调度。\n\n- **周期 $0$**：就绪指令集：$\\{I_{1}, I_{2}, I_{4}, I_{6}, I_{8}\\}$。调度器发射 $I_{1}$ 以启动关键路径。\n  - 发射 $I_{1}$。$t_{issue}(I_{1}) = 0$, $t_{ready}(I_{1}) = 4$。\n\n- **周期 $1$、$2$、$3$**：在这些周期中，$I_{3}$ 尚未就绪。调度器可以发射独立指令以隐藏 $I_{1}$ 的延迟。\n  - 周期 $1$：就绪集 $\\{I_{2}, I_{4}, I_{6}, I_{8}\\}$。发射 $I_{2}$。$t_{issue}(I_{2}) = 1$, $t_{ready}(I_{2}) = 1+1=2$。\n  - 周期 $2$：就绪集 $\\{I_{4}, I_{6}, I_{8}\\}$。发射 $I_{4}$。$t_{issue}(I_{4}) = 2$, $t_{ready}(I_{4}) = 2+1=3$。\n  - 周期 $3$：就绪集 $\\{I_{6}, I_{8}\\}$。发射 $I_{6}$。$t_{issue}(I_{6}) = 3$, $t_{ready}(I_{6}) = 3+1=4$。\n\n- **周期 $4$**：在此周期开始时，$t_{ready}(I_1)=4$ 的条件得到满足，因此 $I_{3}$ 变为就绪。\n  - 就绪集：$\\{I_{3}, I_{8}\\}$。调度器优先处理 $I_{3}$（关键路径）。\n  - 发射 $I_{3}$。$t_{issue}(I_{3}) = 4$, $t_{ready}(I_{3}) = 4+1=5$。\n\n- **周期 $5$**：$t_{ready}(I_3)=5$ 的条件得到满足，因此 $I_{5}$ 变为就绪。\n  - 就绪集：$\\{I_{5}, I_{8}\\}$。调度器优先处理 $I_{5}$（关键路径）。\n  - 发射 $I_{5}$。$t_{issue}(I_{5}) = 5$, $t_{ready}(I_{5}) = 5+3=8$。\n\n- **周期 $6$**：$I_{7}$ 尚未就绪（要求周期 $\\ge 8$）。\n  - 就绪集：$\\{I_{8}\\}$。\n  - 发射 $I_{8}$。$t_{issue}(I_{8}) = 6$, $t_{ready}(I_{8}) = 6+1=7$。\n\n- **周期 $7$**：所有独立指令都已发射。唯一剩下的指令是 $I_{7}$，它要到周期 $8$ 才就绪。\n  - 就绪集：$\\emptyset$。\n  - 发射 NOP。\n\n- **周期 $8$**：$t_{ready}(I_5)=8$ 的条件得到满足，因此 $I_{7}$ 变为就绪。\n  - 就绪集：$\\{I_{7}\\}$。\n  - 发射 $I_{7}$。$t_{issue}(I_{7}) = 8$, $t_{ready}(I_{7}) = 8+1=9$。\n\n此调度的就绪时间为：$t_{ready}(I_{1})=4$, $t_{ready}(I_{2})=2$, $t_{ready}(I_{4})=3$, $t_{ready}(I_{6})=4$, $t_{ready}(I_{3})=5$, $t_{ready}(I_{5})=8$, $t_{ready}(I_{8})=7$, $t_{ready}(I_{7})=9$。\n\n最优调度器的完成时间 $T_{\\text{opt}}$ 是这些就绪时间的最大值：\n$$T_{\\text{opt}} = \\max(4, 2, 3, 4, 5, 8, 7, 9) = 9$$\n这个调度达到了 $9$ 个周期的下限，因此它是最优的。\n\n#### 最终计算\n需要计算的量是 $\\Delta T = T_{\\text{naive}} - T_{\\text{opt}}$。\n$$ \\Delta T = 13 - 9 = 4 $$\n与朴素调度器相比，延迟隐藏调度器将完成时间缩短了 $4$ 个周期。",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "在理解了智能调度的重要性之后，下一个关键步骤是掌握其核心技术：延迟隐藏。本练习  聚焦于一个经典的场景，即如何利用独立的短延迟指令来填充由长延迟指令（如除法）所造成的流水线停顿。通过精确计算指令重排所带来的性能提升，你将学会量化分析延迟隐藏的效果，并将其作为优化代码性能的有力工具。",
            "id": "3647160",
            "problem": "一个编译器针对一个顺序执行的单发射流水线，该流水线具有以下基于标准流水线相关性和延迟语义的特性。该机器每个周期最多能发射 $1$ 条指令。一条使用先前指令结果的指令，只有在其所有源操作数都可用时才能发射。每条指令都有一个固定的“生产者-消费者”延迟，等于生产者指令发射的周期与相关的消费者指令可以在零停顿下发射的最早周期之间的周期数。整数算术逻辑单元（ALU）操作的延迟为 $1$ 个周期。整数除法操作的延迟为 $L_{\\text{div}}$ 个周期。假设不存在结构冒险，并且当操作数就绪时，功能单元总是可用的。\n\n考虑一个循环体，在未经调度的朴素形式下，每次迭代执行以下序列：\n- 使用延迟为 $L_{\\text{div}}$ 的整数除法计算 $t \\leftarrow a / b$。\n- 立即在一个相关的整数ALU操作 $u \\leftarrow t + c$ 中使用 $t$。\n- 执行 $M$ 个整数ALU操作，这些操作独立于除法结果 $t$ 及其消费者 $u$。只要这些 $M$ 个操作之间的相互程序顺序得以保持，它们就可以相对于除法指令及其消费者指令自由地重排序，且所有这些操作的延迟均为 $1$ 个周期。\n\n编译器执行局部指令调度，通过将 $M$ 个独立整数ALU操作中的一些交错安排在生成 $t$ 的除法指令和使用 $t$ 的消费者指令之间，以尽可能多地隐藏除法延迟。假设没有其他限制阻止这种移动，并且机器仍必须按顺序发射指令。\n\n给定 $L_{\\text{div}} = 19$ 和 $M = 12$，请从基本原理推导，与 $t$ 的消费者紧跟在除法指令之后的朴素顺序相比，这种调度每次迭代节省的周期数。请以每次迭代节省的整数周期数表示你的答案。不要四舍五入；以周期为单位表示最终答案。",
            "solution": "这个问题要求在一个简单的顺序执行、单发射处理器中，分析由数据相关引起的流水线停顿。我们必须确定通过重排序指令来隐藏除法操作的长延迟所节省的周期数。一次迭代的总周期数定义为从第一条指令发射到最后一条指令发射的周期数（含首尾）。在单发射机器上，这等价于该序列所需的总发射槽数（包括忙碌或停顿的）。\n\n让我们首先分析朴素的、未调度的指令序列每次迭代的总周期数。该序列是：\n$1$. `div`: $t \\leftarrow a / b$\n$2$. `add`: $u \\leftarrow t + c$\n$3$. $M$ 个独立的ALU操作。\n\n机器是顺序执行且单发射的。假设 `div` 指令在周期 $C_0$ 发射。`add` 指令与 `div` 指令存在数据相关，`div` 指令的延迟为 $L_{\\text{div}}$ 个周期。根据定义，这意味着相关指令的发射时间不能早于 `div` 指令发射后 $L_{\\text{div}}$ 个周期。因此，`add` 指令不能在周期 $C_0 + L_{\\text{div}}$ 之前发射。\n\n在朴素序列中，`add` 指令紧跟在 `div` 指令之后。流水线将尝试在周期 $C_0 + 1$ 发射 `add` 指令。然而，由于操作数 $t$ 尚未就绪，流水线必须停顿。停顿将占据从周期 $C_0 + 1$ 到周期 $C_0 + L_{\\text{div}}$（不含）的发射槽。停顿的周期数为 $(C_0 + L_{\\text{div}} - 1) - (C_0 + 1) + 1 = L_{\\text{div}} - 1$。\n\n总周期数 $T_{\\text{naive}}$ 是发射每条指令的周期数与任何插入的停顿周期数之和：\n- 发射 `div` 指令需要 $1$ 个周期。\n- 流水线停顿需要 $L_{\\text{div}} - 1$ 个周期。\n- 发射相关的 `add` 指令需要 $1$ 个周期。\n- 顺序发射 $M$ 个独立的 ALU 操作需要 $M$ 个周期。\n\n将这些相加，朴素序列的总周期数为：\n$$T_{\\text{naive}} = 1 + (L_{\\text{div}} - 1) + 1 + M = L_{\\text{div}} + M + 1$$\n\n接下来，我们分析优化过的、经过调度的指令序列的总周期数。编译器将 $M$ 个独立操作移动到 `div` 指令和相关的 `add` 指令之间，以隐藏除法延迟。调度后的序列是：\n$1$. `div`: $t \\leftarrow a / b$\n$2$. $M$ 个独立的ALU操作。\n$3$. `add`: $u \\leftarrow t + c$\n\n假设 `div` 指令在周期 $C_0$ 发射。由于接下来的 $M$ 个 ALU 操作是独立的，它们可以在随后的周期中发射，每个周期一条。\n- `div` 指令在周期 $C_0$ 发射。\n- $M$ 个独立操作在周期 $C_0+1, C_0+2, \\dots, C_0+M$ 发射。\n\n在 $M$ 个独立操作中的最后一个于周期 $C_0+M$ 发射后，流水线准备好在周期 $C_0+M+1$ 发射 `add` 指令。然而，`add` 指令仍然与 `div` 指令存在数据相关。结果 $t$ 在周期 $C_0 + L_{\\text{div}}$ 可用。因此，`add` 指令只能在这两个时间中较晚的那个时刻发射：它在指令流中变得可用的时间和其数据相关得到解决的时间。\n`add` 指令的发射周期为 $C_{\\text{issue,add}} = \\max(C_0+M+1, C_0+L_{\\text{div}})$。\n让我们通过设置 $C_0 = 0$ 来进行归一化。`add` 指令在周期 $\\max(M+1, L_{\\text{div}})$ 发射。\n\n调度后序列的总周期数 $T_{\\text{scheduled}}$ 可以通过对发射槽求和来计算。\n- `div` 指令占用 $1$ 个周期。\n- $M$ 个独立操作占用 $M$ 个周期。\n- 在 `add` 指令可以发射之前可能存在一个停顿期。\n- `add` 指令占用 $1$ 个周期。\n\n`div` 指令和 $M$ 个操作连续发射，占用 $M+1$ 个周期。此时，是周期 $M+1$（假设我们从周期 $1$ 开始）。`add` 指令准备好发射。来自 `div` 的数据在周期 $L_{\\text{div}}+1$ 就绪。不对，延迟的定义是消费者可以在周期 $C_p + L$ 发射。如果生产者在周期 $1$ 发射，消费者可以在周期 $1+L$ 发射。\n让我们使用一个从周期 $1$ 开始的周期计数框架。\n- 周期 $1$：`div` 发射。\n- 周期 $2$：`op_1` 发射。\n- ...\n- 周期 $M+1$：`op_M` 发射。\n- 在周期 $M+2$，`add` 指令准备好被发射。\n- 来自 `div` 的数据相关在周期 $1+L_{\\text{div}}$ 解决。\n- 因此，`add` 指令在周期 $\\max(M+2, 1+L_{\\text{div}})$ 发射。\n这便是最后一条发射指令的周期号。该序列的总周期数就是这个值。\n$T_{\\text{scheduled}} = \\max(M+2, L_{\\text{div}}+1)$。\n\n让我们通过计算槽位来重新推导。`div` 和 $M$ 个操作占用的槽位是 $M+1$。经过的时间是 $M+1$ 个周期。在 `div` 发射和 `add` （结构上）准备好发射之间经过的周期数是 $M+1$。所需的时间间隔是 $L_{\\text{div}}$。如果 $M+1  L_{\\text{div}}$，我们需要停顿 $L_{\\text{div}} - (M+1)$ 个周期。\n总周期数为：\n$T_{\\text{scheduled}} = (\\text{div 指令的周期}) + (M \\text{个操作的周期}) + (\\text{停顿周期}) + (\\text{add 指令的周期})$\n$T_{\\text{scheduled}} = 1 + M + \\max(0, L_{\\text{div}} - (M+1)) + 1 = M+2 + \\max(0, L_{\\text{div}}-M-1)$。\n如果 $M+1 \\ge L_{\\text{div}}$，则 $T_{\\text{scheduled}} = M+2$。\n如果 $M+1  L_{\\text{div}}$，则 $T_{\\text{scheduled}} = M+2 + L_{\\text{div}}-M-1 = L_{\\text{div}}+1$。\n这可以表示为 $T_{\\text{scheduled}} = \\max(M+2, L_{\\text{div}}+1)$。这似乎是正确的。\n\n节省的周期数 $\\Delta T$ 是朴素执行时间和调度后执行时间之差：\n$\\Delta T = T_{\\text{naive}} - T_{\\text{scheduled}}$\n$\\Delta T = (L_{\\text{div}} + M + 1) - \\max(M+2, L_{\\text{div}}+1)$\n\n让我们根据 $M$ 和 $L_{\\text{div}}$ 之间的关系来评估这个表达式。\n情况1：$M+1 \\ge L_{\\text{div}}$ (或 $M \\ge L_{\\text{div}}-1$) 。这意味着有足够的独立指令来完全隐藏除法延迟。\n在这种情况下，$\\max(M+2, L_{\\text{div}}+1) = M+2$。\n$\\Delta T = (L_{\\text{div}} + M + 1) - (M+2) = L_{\\text{div}} - 1$。\n节省的周期数等于朴素调度中的停顿周期数，即 $L_{\\text{div}}-1$。\n\n情况2：$M+1  L_{\\text{div}}$ (或 $M  L_{\\text{div}}-1$) 。没有足够的独立指令来完全隐藏延迟。\n在这种情况下，$\\max(M+2, L_{\\text{div}}+1) = L_{\\text{div}}+1$。\n$\\Delta T = (L_{\\text{div}} + M + 1) - (L_{\\text{div}}+1) = M$。\n节省的周期数等于可用于填补停顿槽的独立指令数 $M$。\n\n综合这两种情况，节省的周期数是可被现有 $M$ 条独立指令填补的停顿槽（$L_{\\text{div}}-1$个）的数量。这由下式给出：\n$$\\Delta T = \\min(M, L_{\\text{div}}-1)$$\n\n我们已知给定的值为 $L_{\\text{div}} = 19$ 和 $M=12$。\n我们计算潜在的停顿周期数：\n$L_{\\text{div}}-1 = 19-1 = 18$。\n我们有 $M=12$ 条独立指令。\n由于 $M  L_{\\text{div}}-1$ ($12  18$)，我们属于第二种情况。我们只能填补18个停顿槽中的12个。\n节省的周期数为：\n$$\\Delta T = \\min(12, 18) = 12$$\n\n每次迭代节省的周期数是 $12$。",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "前面的练习建立了指令调度的基本原则，现在是时候将这些原则应用于更接近现实的硬件模型了。本综合练习  不仅要求你处理数据依赖和指令延迟，还引入了资源约束——有限的功能单元和指令发射宽度。你需要像一个真正的编译器调度器一样，在多重约束下权衡，找出一个能够达到关键路径长度的最优调度方案，从而将理论知识应用于解决复杂的实际问题。",
            "id": "3647154",
            "problem": "考虑一个基本块，其中有 $n=8$ 条指令，需要在一个具有多个功能单元和显式资源限制的单发射核上进行调度。目标是计算依赖结构的关键路径，并构建一个合法的调度方案，如果可能的话，使其达到关键路径的长度。指令集和机器模型如下。\n\n机器模型：\n- 每个周期最多可发射 $2$ 条指令。\n- 有 $2$ 个加载/存储单元（每个单元每个周期最多能接受 $1$ 个内存操作；内存系统是双端口的，因此最多可以在同一周期发射 $2$ 个内存操作）。\n- 有 $1$ 个整数加法单元，用于加法和减法。\n- 有 $1$ 个乘法单元。\n- 所有功能单元都是完全流水化的。\n- 操作延迟（从发射到结果可用的周期数）为：加载 $=$ $2$ 个周期，加法 $=$ $1$ 个周期，乘法 $=$ $3$ 个周期，存储 $=$ $1$ 个周期。\n- 一条指令只有在其所有操作数都可用时才能发射。如果指令 $u$ 的延迟为 $\\ell(u)$，并在周期 $s(u)$ 发射，那么其结果在周期 $r(u)=s(u)+\\ell(u)$ 可用。\n- 一条存储指令要求其值操作数在发射时可用，并占用一个加载/存储单元 $1$ 个周期。\n\n基本块（寄存器 $r_i$ 和内存位置 $M[\\cdot]$ 是体系结构的）：\n- $I_1$: $r_1 \\leftarrow M[a]$ (加载)\n- $I_2$: $r_2 \\leftarrow M[b]$ (加载)\n- $I_3$: $r_3 \\leftarrow r_1 \\times r_2$ (乘法)\n- $I_4$: $r_4 \\leftarrow r_3 + r_5$ (加法)，其中 $r_5$ 在周期 $0$ 时已可用\n- $I_5$: $r_6 \\leftarrow r_4 + r_7$ (加法)，其中 $r_7$ 在周期 $0$ 时已可用\n- $I_6$: $M[c] \\leftarrow r_6$ (存储)\n- $I_7$: $r_8 \\leftarrow r_2 + r_9$ (加法)，其中 $r_9$ 在周期 $0$ 时已可用\n- $I_8$: $r_{10} \\leftarrow r_8 + r_{11}$ (加法)，其中 $r_{11}$ 在周期 $0$ 时已可用\n\n数据依赖：\n- $I_3$ 依赖于 $I_1$ 和 $I_2$。\n- $I_4$ 依赖于 $I_3$。\n- $I_5$ 依赖于 $I_4$。\n- $I_6$ 依赖于 $I_5$。\n- $I_7$ 依赖于 $I_2$。\n- $I_8$ 依赖于 $I_7$。\n- 除非由上述关系推断，所有其他指令对都是独立的。\n\n任务：\n- 使用数据依赖和指令延迟的定义，确定此基本块依赖结构中关键路径的长度（以周期为单位），忽略资源争用但尊重数据就绪。\n- 然后，在上述资源限制条件下，提出一个逐周期的合法调度方案，如果可实现，该方案应达到此关键路径界限。\n- 报告在此模型下该基本块的最小完成时间（制造期），单位为周期。你的最终答案必须是一个表示周期的整数。无需四舍五入。",
            "solution": "用户希望我解决一个指令调度问题，这属于编译器原理和计算机体系结构的范畴。\n\n### 步骤1：提取给定条件\n- 指令数量：$n=8$。\n- 机器模型：\n  - 发射宽度：每个周期最多 $2$ 条指令。\n  - 功能单元：$2$ 个加载/存储单元，$1$ 个整数加法单元，$1$ 个乘法单元。全部完全流水化。\n- 操作延迟（$\\ell$）：\n  - $\\ell(\\text{加载}) = 2$ 周期。\n  - $\\ell(\\text{加法}) = 1$ 周期。\n  - $\\ell(\\text{乘法}) = 3$ 周期。\n  - $\\ell(\\text{存储}) = 1$ 周期。\n- 时序模型：一条指令 $u$ 在周期 $s(u)$ 发射，其结果在周期 $r(u) = s(u) + \\ell(u)$ 可用。依赖指令可以在其操作数结果可用或之后发射。\n- 指令：\n  - $I_1$: $r_1 \\leftarrow M[a]$ (加载)\n  - $I_2$: $r_2 \\leftarrow M[b]$ (加载)\n  - $I_3$: $r_3 \\leftarrow r_1 \\times r_2$ (乘法)\n  - $I_4$: $r_4 \\leftarrow r_3 + r_5$ (加法)\n  - $I_5$: $r_6 \\leftarrow r_4 + r_7$ (加法)\n  - $I_6$: $M[c] \\leftarrow r_6$ (存储)\n  - $I_7$: $r_8 \\leftarrow r_2 + r_9$ (加法)\n  - $I_8$: $r_{10} \\leftarrow r_8 + r_{11}$ (加法)\n- 外部输入：寄存器 $r_5, r_7, r_9, r_{11}$ 在周期 $0$ 时可用。\n- 数据依赖：\n  - $I_3$ 依赖于 $I_1$ 和 $I_2$。($I_1 \\to I_3, I_2 \\to I_3$)\n  - $I_4$ 依赖于 $I_3$。($I_3 \\to I_4$)\n  - $I_5$ 依赖于 $I_4$。($I_4 \\to I_5$)\n  - $I_6$ 依赖于 $I_5$。($I_5 \\to I_6$)\n  - $I_7$ 依赖于 $I_2$。($I_2 \\to I_7$)\n  - $I_8$ 依赖于 $I_7$。($I_7 \\to I_8$)\n\n### 步骤2：使用提取的给定条件进行验证\n该问题在计算机体系结构和编译器理论领域具有科学依据。这是一个定义明确的指令调度问题，具有清晰的约束、依赖关系和目标。所提供的数据是自洽、一致且足以推导出解决方案的。该模型虽然简化，但是超标量处理器流水线调度挑战的标准表示。没有事实错误、逻辑矛盾或主观因素。\n\n### 步骤3：判断和行动\n问题有效。将构建一个解决方案。\n\n### 求解过程\n\n主要目标是找到给定基本块的最小完成时间（制造期）。这是一个两步过程：首先，通过计算数据依赖图（DDG）中关键路径的长度，来确定制造期的下界，此步骤忽略资源约束。其次，尝试构建一个满足此下界并遵守所有资源约束的调度。\n\n#### 第1部分：关键路径分析\n关键路径是数据依赖图中的最长路径，路径的长度是执行该路径上指令序列所需的最短时间。长度由延迟之和决定。设 $s(I)$ 为指令 $I$ 的发射周期，$r(I)$ 为其结果可用的周期，且 $r(I) = s(I) + \\ell(I)$。对于依赖关系 $I_A \\to I_B$，$I_B$ 的最早发射时间为 $s(I_B) \\geq r(I_A)$。我们假设执行从周期 $1$ 开始。\n\n依赖关系在数据依赖图中形成两条主要路径：\n1.  路径A：$I_1 \\to I_3 \\to I_4 \\to I_5 \\to I_6$（以及从 $I_2$ 开始的并行路径）\n2.  路径B：$I_2 \\to I_7 \\to I_8$\n\n让我们计算每条路径的长度，它代表了如果只存在该路径时的最早完成时间。\n\n**路径A ($I_1 \\to I_3 \\to I_4 \\to I_5 \\to I_6$) 的计算：**\n- $I_1$ (加载, $\\ell=2$) 在该基本块中没有依赖。它可以在周期 $1$ 发射。\n  - 最早发射时间 $s(I_1) = 1$。\n  - 结果在 $r(I_1) = s(I_1) + \\ell(I_1) = 1 + 2 = 3$ 时可用。\n- $I_2$ (加载, $\\ell=2$) 也可以在周期 $1$ 发射。其结果也在 $r(I_2) = 1 + 2 = 3$ 时可用。\n- $I_3$ (乘法, $\\ell=3$) 依赖于 $I_1$ 和 $I_2$。它可以在两个结果都就绪时发射。\n  - 最早发射时间 $s(I_3) = \\max(r(I_1), r(I_2)) = \\max(3, 3) = 3$。\n  - 结果在 $r(I_3) = s(I_3) + \\ell(I_3) = 3 + 3 = 6$ 时可用。\n- $I_4$ (加法, $\\ell=1$) 依赖于 $I_3$。\n  - 最早发射时间 $s(I_4) = r(I_3) = 6$。\n  - 结果在 $r(I_4) = s(I_4) + \\ell(I_4) = 6 + 1 = 7$ 时可用。\n- $I_5$ (加法, $\\ell=1$) 依赖于 $I_4$。\n  - 最早发射时间 $s(I_5) = r(I_4) = 7$。\n  - 结果在 $r(I_5) = s(I_5) + \\ell(I_5) = 7 + 1 = 8$ 时可用。\n- $I_6$ (存储, $\\ell=1$) 依赖于 $I_5$。\n  - 最早发射时间 $s(I_6) = r(I_5) = 8$。\n  - 该指令在周期 $8$ 执行，并在周期 $8$ 结束时完成。\n该路径的总时间是 $8$ 个周期。\n\n**路径B ($I_2 \\to I_7 \\to I_8$) 的计算：**\n- $I_2$ (加载, $\\ell=2$) 可以在周期 $1$ 发射。\n  - 最早发射时间 $s(I_2) = 1$。\n  - 结果在 $r(I_2) = 1+2 = 3$ 时可用。\n- $I_7$ (加法, $\\ell=1$) 依赖于 $I_2$。\n  - 最早发射时间 $s(I_7) = r(I_2) = 3$。\n  - 结果在 $r(I_7) = 3+1 = 4$ 时可用。\n- $I_8$ (加法, $\\ell=1$) 依赖于 $I_7$。\n  - 最早发射时间 $s(I_8) = r(I_7) = 4$。\n  - 结果在 $r(I_8) = 4+1 = 5$ 时可用。\n该路径上的最后一条指令在周期 $5$ 结束时完成。\n\n关键路径是最长的路径，即路径A。因此，由数据依赖决定的该基本块的最小可能制造期是 $8$ 个周期。\n\n#### 第2部分：资源受限的调度\n现在，我们必须构建一个遵守资源限制的调度：每个周期 $2$ 个发射槽、$2$ 个加载/存储单元、$1$ 个加法单元和 $1$ 个乘法单元。目标是实现 $8$ 个周期的制造期。\n\n我们可以逐周期构建调度：\n\n- **周期 1:**\n  - 就绪指令: $I_1, I_2$。\n  - 调度: 发射 $I_1$ (加载) 和 $I_2$ (加载)。\n  - 使用资源: $2$ 个发射槽，$2$ 个加载/存储单元。这是合法的。\n  - 结果可用: $r(I_1) = 1+2=3$, $r(I_2) = 1+2=3$。\n\n- **周期 2:**\n  - 就绪指令: 无。我们正在等待 $I_1$ 和 $I_2$ 完成。\n  - 调度: 停顿。\n  - 使用资源: 无。\n\n- **周期 3:**\n  - 就绪指令: 在周期 $3$ 开始时，$I_1$ 和 $I_2$ 的结果可用。这使得 $I_3$ (依赖于 $I_1, I_2$) 和 $I_7$ (依赖于 $I_2$) 就绪。\n  - 调度: 发射 $I_3$ (乘法) 和 $I_7$ (加法)。\n  - 使用资源: $2$ 个发射槽，$1$ 个乘法单元，$1$ 个加法单元。这是合法的。\n  - 结果可用: $r(I_3) = 3+3=6$, $r(I_7) = 3+1=4$。\n\n- **周期 4:**\n  - 就绪指令: 在周期 $4$ 开始时，$I_7$ 的结果可用。这使得 $I_8$ (依赖于 $I_7$) 就绪。\n  - 调度: 发射 $I_8$ (加法)。\n  - 使用资源: $1$ 个发射槽，$1$ 个加法单元。这是合法的。\n  - 结果可用: $r(I_8) = 4+1=5$。\n\n- **周期 5:**\n  - 就绪指令: 无。关键路径上的下一条指令 $I_4$ 正在等待 $I_3$，其结果直到周期 $6$ 才可用。旁路 ($I_8$) 已完成。\n  - 调度: 停顿。\n  - 使用资源: 无。\n\n- **周期 6:**\n  - 就绪指令: 在周期 $6$ 开始时，$I_3$ 的结果可用。这使得 $I_4$ (依赖于 $I_3$) 就绪。\n  - 调度: 发射 $I_4$ (加法)。\n  - 使用资源: $1$ 个发射槽，$1$ 个加法单元。这是合法的。\n  - 结果可用: $r(I_4) = 6+1=7$。\n\n- **周期 7:**\n  - 就绪指令: 在周期 $7$ 开始时，$I_4$ 的结果可用。这使得 $I_5$ (依赖于 $I_4$) 就绪。\n  - 调度: 发射 $I_5$ (加法)。\n  - 使用资源: $1$ 个发射槽，$1$ 个加法单元。这是合法的。\n  - 结果可用: $r(I_5) = 7+1=8$。\n\n- **周期 8:**\n  - 就绪指令: 在周期 $8$ 开始时，$I_5$ 的结果可用。这使得 $I_6$ (依赖于 $I_5$) 就绪。\n  - 调度: 发射 $I_6$ (存储)。\n  - 使用资源: $1$ 个发射槽，$1$ 个加载/存储单元。这是合法的。\n  - 该指令在周期 $8$ 执行，并在周期 $8$ 结束时完成。\n\n所构建的调度是合法的，因为它在每个周期都遵守了所有的数据依赖和资源约束。最后一条指令 $I_6$ 在周期 $8$ 结束时完成其执行。\n\n### 结论\n由数据依赖关系决定的关键路径长度确定了制造期的下界为 $8$ 个周期。我们已经构建了一个合法的调度，实现了这个制造期。因此，该基本块的最小完成时间是 $8$ 个周期。",
            "answer": "$$\\boxed{8}$$"
        }
    ]
}