{
    "hands_on_practices": [
        {
            "introduction": "寄存器是CPU中速度最快的存储单元，但将变量从内存加载到寄存器并最终存回内存本身也需要成本。这个练习  将引导你通过一个量化的成本效益分析，来确定一个变量被频繁使用多少次才值得将其提升到寄存器中。这种分析是编译器进行局部优化的核心，它帮助我们做出明智的决策，以平衡内存访问开销和寄存器操作的优势。",
            "id": "3667165",
            "problem": "一个编译器后端维护一个地址描述符（AD），用于记录持有变量当前值的内存位置（例如栈槽），以及一个寄存器描述符（RD），用于记录哪些机器寄存器持有该值。考虑一个标量临时变量 $t$，它在一个线性基本块的开头被定义，然后在 $u$ 次算术运算（例如，重复加法）序列中被更新，期间没有函数调用，并且 $t$ 在该块的末尾是出口活跃的。编译器总是为 $t$ 分配一个栈槽，并要求在基本块出口处，该栈槽包含当前值。请比较以下两种策略：\n\n- 策略 S（驻留栈中）：仅将 $t$ 保存在其栈槽中（由 AD 跟踪）。每次更新 $t$ 时，编译器从栈槽加载，执行算术运算，然后将更新后的值存回栈槽，以保持 AD 的一致性。\n\n- 策略 R（寄存器提升）：在该基本块的持续时间内，将 $t$ 提升到一个寄存器中（由 RD 跟踪）。编译器执行一次性加载，将 $t$ 载入寄存器，在寄存器中执行所有 $u$ 次更新，并在块退出前执行一次性存储，以更新栈槽，从而保持 AD 的一致性。在 $u$ 次更新过程中将 $t$ 保存在寄存器中，会引入每次更新的预期寄存器干扰开销。\n\n假设使用以下被广泛接受的成本模型，所有成本均以周期为单位计量：\n- 从内存加载到寄存器的成本为 $c_{\\mathrm{ld}} = 6$。\n- 从寄存器存储到内存的成本为 $c_{\\mathrm{st}} = 8$。\n- 每次更新的算术运算本身的成本为 $c_{\\mathrm{alu}}$，在两种策略下相同。\n- 将 $t$ 提升到寄存器并更新描述符会产生一次性开销 $c_{\\mathrm{prom}} = 3$。\n- 当 $t$ 保存在寄存器中时，每次更新的预期寄存器干扰开销为 $c_{\\mathrm{int}} = 1$。\n\n根据以上定义，推导出比较策略 R 与策略 S 的总预期周期成本的盈亏平衡不等式，对使用次数 $u$ 进行符号求解，然后计算使策略 R 的预期周期成本严格低于策略 S 的最小整数 $u$。请将您的最终答案以单个整数形式给出。无需四舍五入。",
            "solution": "本题要求比较两种在基本块内管理临时变量 $t$ 的编译器策略。为了确定策略 R（寄存器提升）何时比策略 S（驻留栈中）更具成本效益，我们必须首先将每种策略的总周期成本表示为更新次数 $u$ 的函数。\n\n设 $C_S(u)$ 为策略 S 的总周期成本，$C_R(u)$ 为策略 R 的总预期周期成本。变量 $u$ 表示对临时变量 $t$ 的算术更新次数。\n\n首先，我们定义策略 S（驻留栈中）的成本。在此策略中，$u$ 次更新中的每一次都涉及从其栈槽加载 $t$ 的值，执行算术运算，并将新值存回栈槽。成本如下：\n- 一次加载操作的成本：$c_{\\mathrm{ld}}$。\n- 一次算术运算的成本：$c_{\\mathrm{alu}}$。\n- 一次存储操作的成本：$c_{\\mathrm{st}}$。\n\n对于 $u$ 次更新中的每一次，总成本是这三个部分的总和。因此，策略 S 的总成本为：\n$$C_S(u) = u \\cdot (c_{\\mathrm{ld}} + c_{\\mathrm{alu}} + c_{\\mathrm{st}})$$\n\n接下来，我们定义策略 R（寄存器提升）的成本。此策略涉及几个部分：\n- 将 $t$ 提升到寄存器的一次性开销，成本为 $c_{\\mathrm{prom}}$。\n- 一次性加载，将 $t$ 的初始值从内存读入指定寄存器，成本为 $c_{\\mathrm{ld}}$。\n- 在寄存器上直接执行的 $u$ 次更新序列。每次更新都包含成本为 $c_{\\mathrm{alu}}$ 的算术运算本身，以及成本为 $c_{\\mathrm{int}}$ 的预期寄存器干扰开销。因此，每次更新的成本为 $(c_{\\mathrm{alu}} + c_{\\mathrm{int}})$。\n- 最后一次性存储，将 $t$ 的最终值从寄存器写回其栈槽，成本为 $c_{\\mathrm{st}}$。这是必需的，因为题目要求在块出口处栈槽必须是正确的。\n\n将这些部分相加，策略 R 的总预期成本为：\n$$C_R(u) = c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + u \\cdot (c_{\\mathrm{alu}} + c_{\\mathrm{int}}) + c_{\\mathrm{st}}$$\n\n我们需要找到使策略 R 的预期周期成本严格低于策略 S 的最小整数 $u$。这对应于不等式：\n$$C_R(u)  C_S(u)$$\n\n代入 $C_R(u)$ 和 $C_S(u)$ 的表达式：\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}} + u \\cdot (c_{\\mathrm{alu}} + c_{\\mathrm{int}})  u \\cdot (c_{\\mathrm{ld}} + c_{\\mathrm{alu}} + c_{\\mathrm{st}})$$\n\n我们可以展开包含 $u$ 的项：\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}} + u \\cdot c_{\\mathrm{alu}} + u \\cdot c_{\\mathrm{int}}  u \\cdot c_{\\mathrm{ld}} + u \\cdot c_{\\mathrm{alu}} + u \\cdot c_{\\mathrm{st}}$$\n\n项 $u \\cdot c_{\\mathrm{alu}}$ 出现在不等式两侧，可以消去。这是合乎逻辑的，因为两种策略的核心算术工作是相同的。\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}} + u \\cdot c_{\\mathrm{int}}  u \\cdot c_{\\mathrm{ld}} + u \\cdot c_{\\mathrm{st}}$$\n\n现在，我们通过将所有包含 $u$ 的项移到不等式的一侧来求解 $u$。\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}}  u \\cdot c_{\\mathrm{ld}} + u \\cdot c_{\\mathrm{st}} - u \\cdot c_{\\mathrm{int}}$$\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}}  u \\cdot (c_{\\mathrm{ld}} + c_{\\mathrm{st}} - c_{\\mathrm{int}})$$\n\n为了分离出 $u$，我们除以因子 $(c_{\\mathrm{ld}} + c_{\\mathrm{st}} - c_{\\mathrm{int}})$。我们必须首先确保该因子为正。使用给定值，$c_{\\mathrm{ld}} + c_{\\mathrm{st}} - c_{\\mathrm{int}} = 6 + 8 - 1 = 13 > 0$，因此不等式的方向保持不变。\n$$u > \\frac{c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}}}{c_{\\mathrm{ld}} + c_{\\mathrm{st}} - c_{\\mathrm{int}}}$$\n这就是针对 $u$ 求解的符号形式的盈亏平衡不等式。\n\n现在，我们将给定的数值成本代入此表达式：\n- $c_{\\mathrm{ld}} = 6$\n- $c_{\\mathrm{st}} = 8$\n- $c_{\\mathrm{prom}} = 3$\n- $c_{\\mathrm{int}} = 1$\n\n$$u > \\frac{3 + 6 + 8}{6 + 8 - 1}$$\n$$u > \\frac{17}{13}$$\n\n为了找到满足此严格不等式的最小整数 $u$ 值，我们计算该分数：\n$$\\frac{17}{13} \\approx 1.30769...$$\n不等式为 $u > 1.30769...$。由于 $u$ 必须是整数（表示操作次数），严格大于 $1.30769...$ 的最小整数是 $2$。\n\n因此，使策略 R 严格比策略 S 更高效的最小整数更新次数是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "当所有寄存器都已被占用，而编译器又需要一个寄存器来存放新的临时变量时，就必须做出选择：将哪个已在寄存器中的变量“溢出”回内存？这个练习  模拟了这一决策过程，要求你根据一个成本模型选出最优的溢出候选项。这个决策的优劣直接影响生成代码的效率，是寄存器分配中的一个关键挑战。",
            "id": "3667154",
            "problem": "在程序点 $P$处，一个编译器后端必须释放一个寄存器来存放一个新的临时变量 $t$。该机器提供 $3$ 个通用寄存器，记为 $R_1$、$R_2$ 和 $R_3$，在 $P$ 点它们当前分别存放变量 $a$、$b$ 和 $c$。编译器维护一个寄存器描述符 (RD) 和一个地址描述符 (AD)。寄存器描述符 (RD) 将每个寄存器映射到其当前值存放在该寄存器中的一个或多个变量的名称。地址描述符 (AD) 将每个变量映射到其最新值所在的位置集合，该集合可能包含一个或多个寄存器以及可能该变量的内存位置。如果一个变量的地址描述符 (AD) 中包含了其内存位置，则表示内存中已存有该变量的当前值；否则，该变量的内存值是过时的。\n\n在 $P$ 点，地址描述符 (AD) 的状态如下：\n- 对于 $a$：$AD(a) = \\{R_1\\}$ 且 $a$ 的内存值是过时的（即，最新值不在内存中）。\n- 对于 $b$：$AD(b) = \\{R_2, M\\}$，其中 $M$ 表示 $b$ 的内存位置是及时的。\n- 对于 $c$：$AD(c) = \\{R_3\\}$ 且 $c$ 的内存值是过时的。\n\n紧接着 $P$ 点之后，控制流将分支到基本块 $B_1$ 或 $B_2$。一次性能剖析运行报告称，在经过 $P$ 点的条件下，在 $P$ 点总共 $N = 5000$ 次执行中，到 $B_1$ 的分支被执行了 $N_1 = 3000$ 次，到 $B_2$ 的分支被执行了 $N_2 = 2000$ 次。在每个后继块中，各变量的使用和可能的重定义情况如下，只计算在同一变量下一次重定义之前发生的使用次数：\n- 在 $B_1$ 中：变量 $a$ 被使用 $2$ 次然后被重定义；变量 $b$ 被使用 $1$ 次且在 $B_1$ 中未被重定义；变量 $c$ 在任何使用之前被重定义（即，重定义前的使用次数为 $0$）。\n- 在 $B_2$ 中：变量 $a$ 被立即重定义（即，使用次数为 $0$）；变量 $b$ 被使用 $2$ 次且在 $B_2$ 中未被重定义；变量 $c$ 被使用 $1$ 次且在 $B_2$ 中未被重定义。\n\n假设在 $P$ 点进行溢出的代价模型如下：\n- 如果在 $P$ 点选择溢出变量 $x \\in \\{a,b,c\\}$，那么当且仅当根据其地址描述符 (AD)，$x$ 的内存值不是及时的，才需要进行一次溢出存储。将此记为 $\\text{spill}(x) \\in \\{0,1\\}$，其中如果在 $P$ 点需要存储，则 $\\text{spill}(x) = 1$，否则 $\\text{spill}(x) = 0$。\n- 对于在 $P$ 点被溢出的变量 $x$，其未来的每次使用都会在该次使用前产生恰好一次重载，并且重载后的寄存器值在不同的使用之间不被保留（即，不同的使用之间没有复用）。令 $\\text{reload}(x)$ 表示从 $P$ 点开始的一次动态执行中，直到 $x$ 的下一次重定义（如果存在）为止，此类重载的期望次数，该值使用从 $N_1$、$N_2$ 和 $N$ 导出的经验分支频率计算。\n\n定义选择溢出 $x$ 的总代价为\n$$\n\\text{cost}(x) = \\alpha \\cdot \\text{spill}(x) + \\beta \\cdot \\text{reload}(x),\n$$\n权重为 $\\alpha = 3$ 和 $\\beta = 2$。\n\n仅使用以上信息以及寄存器描述符 (RD) 和地址描述符 (AD) 的定义，计算在所有选择 $x \\in \\{a,b,c\\}$ 中，对于 $P$ 点的单次执行所产生的最小化期望总代价。将你的最终答案表示为一个代表指令代价单位的精确有理数。不要进行四舍五入。",
            "solution": "该问题要求我们确定在程序点 $P$ 处要溢出的最优寄存器，以为一个新的临时变量腾出空间。该决策将基于一个代价模型，此模型考虑了将变量值存储到内存的直接代价（一次“溢出”）以及为后续使用而从内存重载该值的未来代价。最优选择是使这个总期望代价最小化的那一个。该机器有三个寄存器，$R_1$、$R_2$ 和 $R_3$，分别存放变量 $a$、$b$ 和 $c$。\n\n溢出一个变量 $x$ 的总代价由以下函数给出：\n$$\n\\text{cost}(x) = \\alpha \\cdot \\text{spill}(x) + \\beta \\cdot \\text{reload}(x)\n$$\n其中 $\\alpha = 3$ 且 $\\beta = 2$。我们必须为三个候选变量 $a$、$b$ 和 $c$ 中的每一个计算这个代价，然后找出其中的最小值。\n\n首先，我们计算从 $P$ 点出发的两条可能控制流路径的概率。程序可以分支到基本块 $B_1$ 或 $B_2$。给出的频率为：到 $B_1$ 的分支为 $N_1 = 3000$ 次，到 $B_2$ 的分支为 $N_2 = 2000$ 次，总执行次数为 $N = N_1 + N_2 = 5000$。\n概率为：\n$$\nP(B_1) = \\frac{N_1}{N} = \\frac{3000}{5000} = \\frac{3}{5}\n$$\n$$\nP(B_2) = \\frac{N_2}{N} = \\frac{2000}{5000} = \\frac{2}{5}\n$$\n\n接下来，我们为每个变量 $x \\in \\{a, b, c\\}$ 评估代价函数的两个组成部分，即 $\\text{spill}(x)$ 和 $\\text{reload}(x)$。\n\n项 $\\text{spill}(x)$ 代表在 $P$ 点的存储操作代价。当且仅当寄存器中变量的当前值尚未存在于其内存位置中（即，内存是“过时的”），才需要进行存储操作。如果需要存储，则 $\\text{spill}(x) = 1$，否则 $\\text{spill}(x) = 0$。\n根据给定的地址描述符 (AD) 状态：\n- 对于 $a$：$AD(a) = \\{R_1\\}$，内存是过时的。因此，需要一次存储操作。$\\text{spill}(a) = 1$。\n- 对于 $b$：$AD(b) = \\{R_2, M\\}$，内存是及时的。因此，不需要存储操作。$\\text{spill}(b) = 0$。\n- 对于 $c$：$AD(c) = \\{R_3\\}$，内存是过时的。因此，需要一次存储操作。$\\text{spill}(c) = 1$。\n\n项 $\\text{reload}(x)$ 代表如果变量 $x$ 被溢出，其未来所需重载的期望次数。被溢出变量在其下一次重定义之前的每次使用都会引起一次重载。我们通过将每个分支中的使用次数按分支概率加权求和，来计算期望使用次数。令 $U_1(x)$ 和 $U_2(x)$ 分别为在基本块 $B_1$ 和 $B_2$ 中，$x$ 在被重定义之前的使用次数。\n$$\n\\text{reload}(x) = U_1(x) \\cdot P(B_1) + U_2(x) \\cdot P(B_2)\n$$\n根据问题描述：\n- 对于变量 $a$：$U_1(a) = 2$（在 $B_1$ 中使用两次）且 $U_2(a) = 0$（在 $B_2$ 中立即被重定义）。\n$$\n\\text{reload}(a) = 2 \\cdot \\frac{3}{5} + 0 \\cdot \\frac{2}{5} = \\frac{6}{5}\n$$\n- 对于变量 $b$：$U_1(b) = 1$（在 $B_1$ 中使用一次）且 $U_2(b) = 2$（在 $B_2$ 中使用两次）。\n$$\n\\text{reload}(b) = 1 \\cdot \\frac{3}{5} + 2 \\cdot \\frac{2}{5} = \\frac{3}{5} + \\frac{4}{5} = \\frac{7}{5}\n$$\n- 对于变量 $c$：$U_1(c) = 0$（在 $B_1$ 中使用前被重定义）且 $U_2(c) = 1$（在 $B_2$ 中使用一次）。\n$$\n\\text{reload}(c) = 0 \\cdot \\frac{3}{5} + 1 \\cdot \\frac{2}{5} = \\frac{2}{5}\n$$\n\n现在我们可以使用权重 $\\alpha = 3$ 和 $\\beta = 2$ 来计算溢出每个变量的总代价。\n\n溢出变量 $a$ 的代价：\n$$\n\\text{cost}(a) = \\alpha \\cdot \\text{spill}(a) + \\beta \\cdot \\text{reload}(a) = 3 \\cdot 1 + 2 \\cdot \\frac{6}{5} = 3 + \\frac{12}{5} = \\frac{15}{5} + \\frac{12}{5} = \\frac{27}{5}\n$$\n\n溢出变量 $b$ 的代价：\n$$\n\\text{cost}(b) = \\alpha \\cdot \\text{spill}(b) + \\beta \\cdot \\text{reload}(b) = 3 \\cdot 0 + 2 \\cdot \\frac{7}{5} = 0 + \\frac{14}{5} = \\frac{14}{5}\n$$\n\n溢出变量 $c$ 的代价：\n$$\n\\text{cost}(c) = \\alpha \\cdot \\text{spill}(c) + \\beta \\cdot \\text{reload}(c) = 3 \\cdot 1 + 2 \\cdot \\frac{2}{5} = 3 + \\frac{4}{5} = \\frac{15}{5} + \\frac{4}{5} = \\frac{19}{5}\n$$\n\n最后，我们比较这三个代价以找出最小值。\n$$\n\\text{cost}(a) = \\frac{27}{5} = 5.4\n$$\n$$\n\\text{cost}(b) = \\frac{14}{5} = 2.8\n$$\n$$\n\\text{cost}(c) = \\frac{19}{5} = 3.8\n$$\n最小代价是 $\\frac{14}{5}$。这对应于溢出变量 $b$。问题要求的是最小化的期望总代价。\n\n最小化的代价是 $\\min(\\text{cost}(a), \\text{cost}(b), \\text{cost}(c)) = \\min(\\frac{27}{5}, \\frac{14}{5}, \\frac{19}{5}) = \\frac{14}{5}$。",
            "answer": "$$\\boxed{\\frac{14}{5}}$$"
        },
        {
            "introduction": "在使用静态单赋值（SSA）形式的现代编译器中，`φ`函数用于合并来自不同控制流路径的变量值。在将代码从SSA形式转换回可执行代码时，必须用具体的移动指令（move instruction）替换这些`φ`函数。这个练习  将展示寄存器和地址描述符如何帮助我们高效地完成这一任务，从而最大限度地减少代码的额外开销。",
            "id": "3667221",
            "problem": "考虑一个编译器后端中的静态单赋值（SSA）形式的控制流连接，该后端所面向的机器有 $3$ 个通用寄存器 $r_1$、$r_2$ 和 $r_3$。该连接块 $J$ 有两个前驱块 $B_a$ 和 $B_b$。在每个前驱块的末尾，寄存器描述符（RD）和地址描述符（AD）反映了变量值的当前位置。使用标准定义：寄存器描述符 $RD$ 将每个寄存器映射到一组变量，这些变量的当前值在该程序点驻留在该寄存器中；地址描述符 $AD(v)$ 将每个变量 $v$ 映射到一组位置（寄存器和可能的内存），这些位置存放着 $v$ 的当前值。\n\n假设在 $B_a$ 块的末尾有以下描述符：\n- $RD_{a}(r_1) = \\{a, c\\}$，$RD_{a}(r_2) = \\{b\\}$，$RD_{a}(r_3) = \\emptyset$。\n- $AD_{a}(a) = \\{r_1, M\\}$，$AD_{a}(b) = \\{r_2\\}$。\n\n假设在 $B_b$ 块的末尾有以下描述符：\n- $RD_{b}(r_1) = \\{b\\}$，$RD_{b}(r_2) = \\{a, b\\}$，$RD_{b}(r_3) = \\{f\\}$。\n- $AD_{b}(a) = \\{r_2\\}$，$AD_{b}(b) = \\{r_1, r_2, M\\}$。\n\n在 $J$ 块的开始处，有一个 $\\phi$ 函数 $x = \\phi(a, b)$，它在来自 $B_a$ 的路径上选择 $a$，在来自 $B_b$ 的路径上选择 $b$。通过仅在前驱块 $B_a$ 和 $B_b$ 中插入拷贝操作来消除该 $\\phi$ 函数，使得在进入 $J$ 块时，$x$ 的值位于单个目标寄存器 $r_t$ 中。目标寄存器 $r_t$ 必须从 $\\{r_1, r_2\\}$ 中选择，因为在 $B_b$ 的末尾，$r_3$ 中存放着 $f$，并且 $f$ 在进入 $J$ 时是活跃的。用于消除 $\\phi$ 函数的允许操作是寄存器到寄存器的移动和从内存加载到寄存器；每个这样的操作计为一次移动。此时不插入到内存的存储操作，并且除了选择 $r_t$ 之外，不允许进行额外的合并。\n\n从 SSA $\\phi$ 函数消除的标准语义以及寄存器和地址描述符的定义出发，确定能够最小化在 $B_a$ 和 $B_b$ 中插入的总移动次数的 $r_t$ 选择，并计算该最小总次数。在你的推理中，分析进入 $J$ 时得到的地址描述符 $AD(x)$，但最终答案只需报告最小总移动次数，形式为单个整数，不带单位。无需四舍五入。",
            "solution": "问题要求我们确定在控制流连接点消除一个 $\\phi$ 函数 $x = \\phi(a, b)$ 所需的最小移动操作次数。新变量 $x$ 的值在进入连接块 $J$ 时必须驻留在单个目标寄存器 $r_t$ 中。目标寄存器 $r_t$ 必须从集合 $\\{r_1, r_2\\}$ 中选择。成本是在前驱块 $B_a$ 和 $B_b$ 的末尾插入的寄存器到寄存器移动或内存到寄存器加载的总次数。\n\n令 $C(B_{pred}, v_{pred}, r_t)$ 表示确保前驱变量 $v_{pred}$ 的值在前驱块 $B_{pred}$ 末尾存在于目标寄存器 $r_t$ 中所需的成本（以移动次数计）。对于给定的 $r_t$ 选择，总成本是每个前驱路径成本的总和：\n$$\n\\text{Total Cost}(r_t) = C(B_a, a, r_t) + C(B_b, b, r_t)\n$$\n我们的目标是找到 $\\min_{r_t \\in \\{r_1, r_2\\}} \\text{Total Cost}(r_t)$。\n\n成本 $C(B_{pred}, v_{pred}, r_t)$ 是通过检查块 $B_{pred}$ 末尾的地址描述符 $AD_{pred}(v_{pred})$ 来确定的。\n- 如果 $v_{pred}$ 的值已经在 $r_t$ 中（即 $r_t \\in AD_{pred}(v_{pred})$），则不需要任何操作，成本为 $0$。\n- 如果 $v_{pred}$ 的值不在 $r_t$ 中（即 $r_t \\notin AD_{pred}(v_{pred})$），但存在于另一个寄存器或内存中（即 $AD_{pred}(v_{pred}) \\neq \\emptyset$），则需要一条移动或加载指令。成本为 $1$。\n\n我们分析目标寄存器 $r_t$ 的两种可能选择。\n\n**情况1：目标寄存器为 $r_t = r_1$。**\n\n1.  **来自 $B_a$ 的路径**：我们需要确保变量 $a$ 的值在寄存器 $r_1$ 中。我们已知在 $B_a$ 末尾的地址描述符为 $AD_{a}(a) = \\{r_1, M\\}$。由于 $r_1$ 在 $a$ 的位置集合中，因此 $a$ 的值已经存在于目标寄存器 $r_1$ 中。\n    因此，该路径的成本为 $C(B_a, a, r_1) = 0$。\n\n2.  **来自 $B_b$ 的路径**：我们需要确保变量 $b$ 的值在寄存器 $r_1$ 中。我们已知在 $B_b$ 末尾的地址描述符为 $AD_{b}(b) = \\{r_1, r_2, M\\}$。由于 $r_1$ 在 $b$ 的位置集合中，因此 $b$ 的值已经存在于目标寄存器 $r_1$ 中。\n    因此，该路径的成本为 $C(B_b, b, r_1) = 0$。\n\n选择 $r_t = r_1$ 的总成本为：\n$$\n\\text{Total Cost}(r_1) = C(B_a, a, r_1) + C(B_b, b, r_1) = 0 + 0 = 0\n$$\n\n**情况2：目标寄存器为 $r_t = r_2$。**\n\n1.  **来自 $B_a$ 的路径**：我们需要确保变量 $a$ 的值在寄存器 $r_2$ 中。给定的地址描述符是 $AD_{a}(a) = \\{r_1, M\\}$。寄存器 $r_2$ 不在该集合中。因此，我们必须在 $B_a$ 的末尾插入一条指令，将 $a$ 的值移动到 $r_2$ 中。这可以是从 $r_1$ 的寄存器到寄存器移动（`move r2, r1`）或从内存加载。这两种操作的成本都为 $1$。问题陈述 $RD_a(r_2) = \\{b\\}$，但由于来自 $B_a$ 路径的 $b$ 的值不是正在解决的 $\\phi$ 函数的输入，并且我们没有得到关于 $b$ 的任何其他活跃性信息，因此我们可以假设 $r_2$ 可以被覆盖。\n    因此，该路径的成本为 $C(B_a, a, r_2) = 1$。\n\n2.  **来自 $B_b$ 的路径**：我们需要确保变量 $b$ 的值在寄存器 $r_2$ 中。给定的地址描述符是 $AD_{b}(b) = \\{r_1, r_2, M\\}$。由于 $r_2$ 在 $b$ 的位置集合中，因此 $b$ 的值已经存在于目标寄存器 $r_2$ 中。\n    因此，该路径的成本为 $C(B_b, b, r_2) = 0$。\n\n选择 $r_t = r_2$ 的总成本为：\n$$\n\\text{Total Cost}(r_2) = C(B_a, a, r_2) + C(B_b, b, r_2) = 1 + 0 = 1\n$$\n\n**结论**\n\n比较两种可能的目标寄存器的总成本：\n- 使用 $r_t = r_1$ 的总成本为 $0$。\n- 使用 $r_t = r_2$ 的总成本为 $1$。\n\n最小总移动次数为 $0$，通过选择 $r_t = r_1$ 实现。\n\n为了完整起见，我们分析在最优选择 $r_t=r_1$ 下，进入 $J$ 时 $x$ 的结果地址描述符。在进入 $J$ 时，现在可以保证 $x$ 的值在 $r_1$ 中。为了确定该值是否也在内存中，我们检查两个前驱路径。沿着来自 $B_a$ 的路径，值来自 $a$，且 $AD_a(a) = \\{r_1, M\\}$，所以该值在内存中。沿着来自 $B_b$ 的路径，值来自 $b$，且 $AD_b(b) = \\{r_1, r_2, M\\}$，所以该值也在内存中。由于没有插入任何会使内存副本失效的操作，因此在连接点 $x$ 的值也在内存中。因此，结果地址描述符为 $AD_J(x) = \\{r_1, M\\}$。\n\n问题要求的是最小总移动次数，即 $0$。",
            "answer": "$$\\boxed{0}$$"
        }
    ]
}