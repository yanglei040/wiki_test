{
    "hands_on_practices": [
        {
            "introduction": "LR自动机构建的核心在于 `CLOSURE` 闭包操作，这是一个基础不动点计算过程。第一个练习  将通过两种不同的方法——工作列表队列和递归展开——来揭示这一过程的奥秘。通过比较这些方法，你将对 LR(0) 项目集的形成获得更深刻的算法层面理解，并对其计算复杂性建立直观认识。",
            "id": "3655060",
            "problem": "给定一个上下文无关文法 $G$，其终结符集为 $\\{a,b\\}$，非终结符集为 $\\{S,A\\}$，产生式为 $S \\to aA$ 和 $A \\to aA \\mid b$。在从左到右 (LR) 分析中，一个 $\\text{LR}(0)$ 项目是一个产生式，其中有一个用点表示的特殊位置。对项目集 $I$ 的 $\\operatorname{CLOSURE}$ 操作被定义为：对于集合中的每个项目 $[X \\to \\alpha . Y \\beta]$ 以及每个产生式 $Y \\to \\gamma$，重复添加项目 $[Y \\to . \\gamma]$，直到无法再添加为止，这个过程的最小不动点。考虑从初始集合 $I_0 = \\{[S \\to a . A]\\}$ 开始的两种数学上等价的 $\\operatorname{CLOSURE}$ 实现：\n- 一种工作列表-队列实现，它维护一个累积项目集 $C$ 和一个先进先出队列 $W$。$W$ 中包含当前点在非终结符之前的项目。初始时，$C := I_0$ 且 $W := I_0$。当 $W$ 非空时，它从队列中取出一个项目，如果该项目形如 $[X \\to \\alpha . Y \\beta]$，那么对于每个产生式 $Y \\to \\gamma$，如果 $[Y \\to . \\gamma] \\notin C$，它就将 $[Y \\to . \\gamma]$ 同时添加到 $C$ 和 $W$ 中。队列按照产生式在文法中书写的顺序将新项目入队。\n- 一种递归展开实现，它维护一个累积项目集 $C$，当遇到一个项目 $[X \\to \\alpha . Y \\beta]$ 时，它会递归地处理每个产生式 $Y \\to \\gamma$：如果 $[Y \\to . \\gamma]$ 尚不在 $C$ 中，则添加它，并且当所添加项目中的点在非终结符之前时，进行递归调用。递归按照产生式在文法中书写的顺序访问它们。\n\n任务：\n1. 仅使用上述定义，计算文法 $G$ 的闭包 $C = \\operatorname{CLOSURE}(I_0)$，并确定其基数 $c = |C|$。\n2. 对于所述的工作列表-队列实现，确定在 $G$ 上从 $I_0$ 开始执行期间观察到的最大队列长度 $Q_{\\max}$，假设没有重复的项目入队。\n3. 对于所述的递归展开实现，确定在 $G$ 上从 $I_0$ 开始执行的最大递归深度 $R_{\\max}$（以在任何时刻，除最外层 $\\operatorname{CLOSURE}$ 调用之外的活跃嵌套递归调用的最大数量来衡量）。\n4. 现在推广到一系列文法 $G_n$，其非终结符集为 $\\{S,A_1,\\dots,A_n\\}$，产生式为 $S \\to a A_1$，$A_i \\to a A_i \\mid A_{i+1}$（对于 $i = 1,\\dots,n-1$），以及 $A_n \\to a A_n \\mid b$。考虑 $I_0^{(n)} = \\{[S \\to a . A_1]\\}$。使用相同的两种实现和相同的产生式排序约定，以闭式形式推导出以下三个关于 $n$ 的函数：闭包基数 $c(n) = |\\operatorname{CLOSURE}(I_0^{(n)})|$、最大工作列表-队列长度 $Q_{\\max}(n)$ 和最大递归深度 $R_{\\max}(n)$。\n5. 最后，报告组合复杂度统计量的单个闭式解析表达式\n$$\nF(n) \\;=\\; c(n) \\;+\\; Q_{\\max}(n) \\;+\\; R_{\\max}(n).\n$$\n你的最终答案必须是这个 $F(n)$，以其最简闭式形式表示。不需要数值计算或四舍五入。",
            "solution": "该问题要求分析 LR 分析中的 $\\operatorname{CLOSURE}$ 操作，首先应用于特定文法 $G$，然后推广到一系列文法 $G_n$。我们将首先计算特定文法 $G$ 所需的量，然后推广结果以推导出 $F(n)$ 的闭式表达式。\n\n文法 $G$ 由终结符 $\\{a,b\\}$、非终结符 $\\{S,A\\}$ 和以下产生式定义：\n1. $S \\to aA$\n2. $A \\to aA$\n3. $A \\to b$\n\n初始项目集为 $I_0 = \\{[S \\to a . A]\\}$。\n\n**第1部分：文法 $G$ 的闭包**\n\n我们计算 $C = \\operatorname{CLOSURE}(I_0) = \\operatorname{CLOSURE}(\\{[S \\to a . A]\\})$。\n1.  从初始集合开始：$C_0 = \\{[S \\to a . A]\\}$。\n2.  项目 $[S \\to a . A]$ 的点在非终结符 $A$ 之前。根据 $\\operatorname{CLOSURE}$ 的定义，我们必须为所有产生式 $A \\to \\gamma$ 添加形如 $[A \\to . \\gamma]$ 的项目。\n3.  $A$ 的产生式是 $A \\to aA$ 和 $A \\to b$。这需要添加项目 $[A \\to . aA]$ 和 $[A \\to . b]$。\n4.  令新集合为 $C_1 = C_0 \\cup \\{[A \\to . aA], [A \\to . b]\\} = \\{[S \\to a . A], [A \\to . aA], [A \\to . b]\\}$。\n5.  现在我们必须检查新添加的项目是否需要进一步添加。新项目是 $[A \\to . aA]$ 和 $[A \\to . b]$。在这两种情况下，点都在终结符（$a$ 或 $b$）之前，而不是非终结符。因此，不能再添加更多项目。\n6.  过程终止，最终的闭包集是 $C = \\{[S \\to a . A], [A \\to . aA], [A \\to . b]\\}$。\n\n该集合的基数为 $c = |C| = 3$。\n\n**第2部分：文法 $G$ 的工作列表-队列实现**\n\n我们跟踪算法的执行过程，初始状态为 $C := I_0$ 和 $W := I_0$，其中 $W$ 是一个先进先出队列。\n-   **初始状态：** $C = \\{[S \\to a . A]\\}$，$W = ([S \\to a . A])$。队列长度为 $|W|=1$。到目前为止观察到的最大长度是 $Q_{\\max} = 1$。\n-   **第1步：** 将 $[S \\to a . A]$ 出队。点在非终结符 $A$ 之前。我们处理 $A$ 的产生式：$A \\to aA$ 和 $A \\to b$。\n    -   对于 $A \\to aA$：项目 $[A \\to . aA]$ 不在 $C$ 中。将其添加到 $C$ 并入队到 $W$。\n        $C = \\{[S \\to a . A], [A \\to . aA]\\}$。\n        $W = ([A \\to . aA])$。现在 $|W|=1$。\n    -   对于 $A \\to b$：项目 $[A \\to . b]$ 不在 $C$ 中。将其添加到 $C$ 并入队到 $W$。\n        $C = \\{[S \\to a . A], [A \\to . aA], [A \\to . b]\\}$。\n        $W = ([A \\to . aA], [A \\to . b])$。现在 $|W|=2$。\n    -   现在观察到的最大队列长度是 $Q_{\\max} = 2$。\n-   **第2步：** 将 $[A \\to . aA]$ 出队。点在终结符 $a$ 之前，因此不执行任何操作。队列现在是 $W = ([A \\to . b])$，$|W|=1$。\n-   **第3步：** 将 $[A \\to . b]$ 出队。点在终结符 $b$ 之前，因此不执行任何操作。队列现在为空，$W = ()$，$|W|=0$。\n-   队列为空，算法终止。\n\n在此过程中观察到的最大队列长度是 $Q_{\\max} = 2$。\n\n**第3部分：文法 $G$ 的递归展开**\n\n该过程从 $C = I_0 = \\{[S \\to a . A]\\}$ 开始，并对 $I_0$ 中的项目进行递归函数的初始调用。我们衡量的是此初始调用之外的深度。\n-   **初始调用：** 一个函数，我们称之为 $\\operatorname{Expand}$，被调用处理 $[S \\to a . A]$。这是递归深度 1。\n-   在 $\\operatorname{Expand}([S \\to a . A])$ 内部：\n    -   点在非终结符 $A$ 之前。我们按顺序处理 $A$ 的产生式：$A \\to aA$，然后是 $A \\to b$。\n    -   对于 $A \\to aA$：项目是 $[A \\to . aA]$。它不在 $C$ 中，所以被添加。这个新项目中的点在终结符 ($a$) 之前，所以不进行递归调用。\n    -   对于 $A \\to b$：项目是 $[A \\to . b]$。它不在 $C$ 中，所以被添加。这个新项目中的点在终结符 ($b$) 之前，所以不进行递归调用。\n-   函数 $\\operatorname{Expand}([S \\to a . A])$ 完成，没有进行任何嵌套调用。\n任何时刻活跃的嵌套递归调用的最大数量是 1。因此，$R_{\\max} = 1$。\n\n**第4部分：对文法 $G_n$ 的推广**\n\n文法 $G_n$ 有非终结符 $\\{S, A_1, \\dots, A_n\\}$ 和以下产生式：\n-   $S \\to a A_1$\n-   $A_i \\to a A_i \\mid A_{i+1}$ 对于 $i=1, \\dots, n-1$\n-   $A_n \\to a A_n \\mid b$\n\n初始集合为 $I_0^{(n)} = \\{[S \\to a . A_1]\\}$。\n\n**闭包基数 $c(n)$：**\n闭包计算从 $[S \\to a . A_1]$ 开始。\n-   $A_1$ 之前的点导致添加 $A_1$ 产生式对应的项目：$[A_1 \\to . a A_1]$ 和 $[A_1 \\to . A_2]$。\n-   项目 $[A_1 \\to . A_2]$ 的点在 $A_2$ 之前，这导致添加 $A_2$ 产生式对应的项目：$[A_2 \\to . a A_2]$ 和 $[A_2 \\to . A_3]$。\n-   这会产生连锁反应。对于从 $1$ 到 $n-1$ 的每个 $i$，都会创建项目 $[A_i \\to . A_{i+1}]$，从而触发添加 $A_{i+1}$ 对应的项目。\n-   这最终导致项目 $[A_{n-1} \\to . A_n]$ 的产生，从而触发添加 $A_n$ 的产生式对应的项目：$[A_n \\to . a A_n]$ 和 $[A_n \\to . b]$。\n-   过程在此终止，因为所有新生成的项目的点都在终结符之前。\n\n$\\operatorname{CLOSURE}(I_0^{(n)})$ 中完整的项目集是：\n1.  初始项目：$[S \\to a . A_1]$ (1个项目)。\n2.  对于每个 $i \\in \\{1, \\dots, n-1\\}$，生成两个项目：$[A_i \\to . a A_i]$ 和 $[A_i \\to . A_{i+1}]$。这总共有 $2(n-1)$ 个项目。\n3.  对于 $A_n$，生成两个项目：$[A_n \\to . a A_n]$ 和 $[A_n \\to . b]$。这总共有 $2$ 个项目。\n\n总基数为 $c(n) = 1 + 2(n-1) + 2 = 1 + 2n - 2 + 2 = 2n + 1$。\n所以，$c(n) = 2n + 1$。\n\n**最大工作列表-队列长度 $Q_{\\max}(n)$：**\n我们跟踪 $G_n$ 的队列状态。\n-   **初始：** $W = ([S \\to a . A_1])$。$|W|=1$。\n-   **第1步：** 将 $[S \\to a . A_1]$ 出队。将 $[A_1 \\to . a A_1]$ 入队，然后将 $[A_1 \\to . A_2]$ 入队。队列变为 $W = ([A_1 \\to . a A_1], [A_1 \\to . A_2])$。长度为 $|W|=2$。这是一个潜在的最大值。\n-   **第2步：** 将 $[A_1 \\to . a A_1]$ 出队。无操作。$|W|=1$。\n-   **第3步：** 将 $[A_1 \\to . A_2]$ 出队。这是一个点在非终结符 ($A_2$) 之前的项目。我们将 $A_2$ 产生式对应的项目入队：$[A_2 \\to . a A_2]$ 和 $[A_2 \\to . A_3]$。队列变为 $W = ([A_2 \\to . a A_2], [A_2 \\to . A_3])$。长度再次为 $|W|=2$。\n这种模式重复出现。在每个阶段 $i=1, \\dots, n$，我们处理一个形如 $[A_{i-1} \\to . A_i]$ 的项目（对于 $i=1$ 则是 $[S \\to a . A_1]$）。这导致两个新项目入队，使队列大小为 $2$。其中一个被处理后无效果，使大小减为 $1$。另一个继续这个链条。队列中的项目数在任何时候都不会超过两个。\n因此，对于任何 $n \\ge 1$，最大队列长度为 $Q_{\\max}(n) = 2$。\n\n**最大递归深度 $R_{\\max}(n)$：**\n递归算法的调用栈反映了文法中的依赖链。\n-   对 $[S \\to a . A_1]$ 的初始调用（深度1）处理 $A_1$ 的产生式。\n-   产生式 $A_1 \\to a A_1$ 导致添加 $[A_1 \\to . a A_1]$，这不会引起递归调用。\n-   产生式 $A_1 \\to A_2$ 导致添加 $[A_1 \\to . A_2]$，其点在非终结符 $A_2$ 之前，导致对这个新项目进行递归调用。此调用处于深度2。\n-   这种模式创建了一个递归调用链：\n    -   调用 $[S \\to a . A_1]$ (深度1)\n    -   ... 调用 $[A_1 \\to . A_2]$ (深度2)\n    -   ... 调用 $[A_2 \\to . A_3]$ (深度3)\n    -   ...\n    -   ... 调用 $[A_{n-1} \\to . A_n]$ (深度 $n$)\n-   深度为 $n$ 的调用是针对 $[A_{n-1} \\to . A_n]$ 的。在此调用内部，我们处理 $A_n$ 的产生式，即 $A_n \\to a A_n$ 和 $A_n \\to b$。生成的项目 $[A_n \\to . a A_n]$ 和 $[A_n \\to . b]$ 的点都在终结符之前，所以不会有进一步的递归调用。\n然后调用栈开始展开。嵌套调用的最大深度为 $n$。\n因此，$R_{\\max}(n) = n$。\n\n**第5部分：组合复杂度统计量 $F(n)$**\n\n我们需要计算组合统计量 $F(n) = c(n) + Q_{\\max}(n) + R_{\\max}(n)$。\n代入推导出的表达式：\n$c(n) = 2n + 1$\n$Q_{\\max}(n) = 2$\n$R_{\\max}(n) = n$\n\n$$\nF(n) = (2n + 1) + 2 + n = 3n + 3\n$$\n$F(n)$ 的最简闭式表达式是 $3n + 3$。",
            "answer": "$$\\boxed{3n+3}$$"
        },
        {
            "introduction": "理解了单个状态是如何形成的之后，下一步是观察整体文法结构如何影响整个自动机。这个练习  对比了描述同一语言的两种文法——一个左递归，一个右递归——揭示了它们对 LR(0) 自动机的规模和复杂性产生的截然不同的影响。这种对比突显了一个关键的设计原则：文法的选择直接决定了最终解析器的效率和结构。",
            "id": "3655045",
            "problem": "考虑字母表 $\\{a,b\\}$ 上的语言，该语言由所有非空字符串组成，记为 $L = \\{a,b\\}^{+}$。为 $L$ 构建两个上下文无关文法：一个左递归文法 $G_{L}$ 和一个右递归文法 $G_{R}$，每个文法都用一个新的起始符号 $S'$ 和产生式 $S' \\to S$ 进行增广。使用以下明确的产生式：\n- 左递归文法 $G_{L}$：$S' \\to S$, $S \\to S a$, $S \\to S b$, $S \\to a$, $S \\to b$。\n- 右递归文法 $G_{R}$：$S' \\to S$, $S \\to a S$, $S \\to b S$, $S \\to a$, $S \\to b$。\n\n对于每个文法，使用标准的 $LR(0)$ 定义，从规范的初始项目集 $I_{0} = \\operatorname{closure}(\\{[S' \\to \\cdot S]\\})$ 开始，构建 $LR(0)$ 自动机状态：\n- 一个 $LR(0)$ 项目的形式为 $[A \\to \\alpha \\cdot \\beta]$。\n- 闭包操作 $\\operatorname{closure}(I)$ 对每个形如 $[A \\to \\alpha \\cdot B \\beta]$（其中非终结符 $B$ 紧跟在点后）的项目，添加 $B$ 的所有产生式对应的项目 $[B \\to \\cdot \\gamma]$，重复此过程直到达到不动点。\n- 对于文法符号 $X$，转移 $\\operatorname{goto}(I,X)$ 在 $I$ 中所有 $X$ 紧跟在点后的项目中将点移过 $X$，然后对结果集求闭包。\n\n通过广度优先搜索（BFS）遍历自动机，其中 BFS 代表广度优先搜索。定义一个状态的深度为在 BFS 树中从 $I_{0}$ 到该状态的最短路径长度（边的数量）。定义一个状态的广度为该状态中 $LR(0)$ 项目的数量（其项目集的基数）。BFS 队列规则如下：\n- 从深度为 $0$ 的 $I_{0}$ 开始。\n- 展开一个状态时，按固定的顺序 $a$, $b$, $S$ 为文法符号生成出边转移。\n- 只将新发现的状态入队（如果一个等价的项目集已经被发现，则不要将其入队）。\n- “前五个状态”指的是此 BFS 发现的前 $5$ 个不同状态，包括 $I_{0}$。\n\n对于每个文法 $G_{L}$ 和 $G_{R}$，令 $M$ 为前 $5$ 个发现的状态的 $\\text{depth(state)} \\times \\text{breadth(state)}$ 之和。计算差值\n$$\\Delta \\;=\\; M(G_{R}) \\;-\\; M(G_{L}).$$\n以单个精确整数形式提供 $\\Delta$。无需四舍五入，最终答案中不应包含单位。",
            "solution": "该问题要求为两种描述同一语言（所有非空 $a,b$ 字符串）的文法——一个左递归 ($G_L$)，一个右递归 ($G_R$)——构建 $LR(0)$ 自动机的前五个状态。我们需要遵循指定的广度优先搜索（BFS）策略，计算每个状态的深度和广度，然后计算一个度量 $M$，最后求出两个文法对应度量的差值 $\\Delta$。\n\n**第一部分：左递归文法 $G_{L}$ 的分析**\n\n增广的左递归文法 $G_L$ 的产生式为：\n$S' \\to S$\n$S \\to S a$\n$S \\to S b$\n$S \\to a$\n$S \\to b$\n\n我们通过构建初始状态 $I_0$ 开始 BFS。\n- **状态 $I_0$**: 此状态是初始项目 $\\{[S' \\to \\cdot S]\\}$ 的闭包。闭包操作会添加所有 $S$ 的产生式项目。\n  $I_0 = \\operatorname{closure}(\\{[S' \\to \\cdot S]\\}) = \\{[S' \\to \\cdot S], [S \\to \\cdot S a], [S \\to \\cdot S b], [S \\to \\cdot a], [S \\to \\cdot b]\\}$。\n  $\\operatorname{depth}(I_0) = 0$, $\\operatorname{breadth}(I_0) = 5$。对 $M(G_L)$ 的贡献为 $0 \\times 5 = 0$。\n  我们已发现1个状态。BFS队列为 $[I_0]$。\n\n接下来，我们扩展 $I_0$，按 $a, b, S$ 的顺序生成转移。\n- **$\\operatorname{goto}(I_0, a) \\to I_1$**: 从项目 $[S \\to \\cdot a]$ 开始，得到核心 $\\{[S \\to a \\cdot]\\}$。\n  $I_1 = \\operatorname{closure}(\\{[S \\to a \\cdot]\\}) = \\{[S \\to a \\cdot]\\}$。这是一个新状态。\n  $\\operatorname{depth}(I_1) = 1$, $\\operatorname{breadth}(I_1) = 1$。贡献为 $1 \\times 1 = 1$。\n  我们已发现2个状态。将 $I_1$ 入队。\n\n- **$\\operatorname{goto}(I_0, b) \\to I_2$**: 从项目 $[S \\to \\cdot b]$ 开始，得到核心 $\\{[S \\to b \\cdot]\\}$。\n  $I_2 = \\operatorname{closure}(\\{[S \\to b \\cdot]\\}) = \\{[S \\to b \\cdot]\\}$。这是一个新状态。\n  $\\operatorname{depth}(I_2) = 1$, $\\operatorname{breadth}(I_2) = 1$。贡献为 $1 \\times 1 = 1$。\n  我们已发现3个状态。将 $I_2$ 入队。\n\n- **$\\operatorname{goto}(I_0, S) \\to I_3$**: 从项目 $[S' \\to \\cdot S], [S \\to \\cdot S a], [S \\to \\cdot S b]$ 开始，得到核心 $\\{[S' \\to S \\cdot], [S \\to S \\cdot a], [S \\to S \\cdot b]\\}$。\n  $I_3 = \\operatorname{closure}(\\dots) = \\{[S' \\to S \\cdot], [S \\to S \\cdot a], [S \\to S \\cdot b]\\}$。这是一个新状态。\n  $\\operatorname{depth}(I_3) = 1$, $\\operatorname{breadth}(I_3) = 3$。贡献为 $1 \\times 3 = 3$。\n  我们已发现4个状态。将 $I_3$ 入队。\n\n现在BFS队列为 $[I_1, I_2, I_3]$。我们需要第5个状态。我们从队列头部取出状态进行扩展。$I_1$ 和 $I_2$ 是归约状态，没有出边。我们扩展 $I_3$。\n- **扩展 $I_3$**:\n  **$\\operatorname{goto}(I_3, a) \\to I_4$**: 从项目 $[S \\to S \\cdot a]$ 开始，得到核心 $\\{[S \\to S a \\cdot]\\}$。\n  $I_4 = \\operatorname{closure}(\\{[S \\to S a \\cdot]\\}) = \\{[S \\to S a \\cdot]\\}$。这是一个新状态。\n  $\\operatorname{depth}(I_4) = \\operatorname{depth}(I_3) + 1 = 2$, $\\operatorname{breadth}(I_4) = 1$。贡献为 $2 \\times 1 = 2$。\n  我们已发现5个状态。\n\n我们找到了前5个状态 $I_0, I_1, I_2, I_3, I_4$。计算 $M(G_L)$：\n$M(G_L) = (0 \\times 5) + (1 \\times 1) + (1 \\times 1) + (1 \\times 3) + (2 \\times 1) = 0 + 1 + 1 + 3 + 2 = 7$。\n\n**第二部分：右递归文法 $G_{R}$ 的分析**\n\n增广的右递归文法 $G_R$ 的产生式为：\n$S' \\to S$\n$S \\to a S$\n$S \\to b S$\n$S \\to a$\n$S \\to b$\n\n- **状态 $I_0$**: 与 $G_L$ 相同，是 $\\{S' \\to \\cdot S\\}$ 的闭包，但产生式不同。\n  $I_0 = \\operatorname{closure}(\\{[S' \\to \\cdot S]\\}) = \\{[S' \\to \\cdot S], [S \\to \\cdot a S], [S \\to \\cdot b S], [S \\to \\cdot a], [S \\to \\cdot b]\\}$。\n  $\\operatorname{depth}(I_0) = 0$, $\\operatorname{breadth}(I_0) = 5$。贡献为 $0 \\times 5 = 0$。\n  已发现1个状态。队列为 $[I_0]$。\n\n扩展 $I_0$：\n- **$\\operatorname{goto}(I_0, a) \\to I_1$**: 从项目 $[S \\to \\cdot a S]$ 和 $[S \\to \\cdot a]$ 开始，得到核心 $\\{[S \\to a \\cdot S], [S \\to a \\cdot]\\}$。由于项目 $[S \\to a \\cdot S]$ 的点后是 $S$，我们需要计算闭包。\n  $I_1 = \\operatorname{closure}(\\{[S \\to a \\cdot S], [S \\to a \\cdot]\\}) = \\{[S \\to a \\cdot S], [S \\to a \\cdot], [S \\to \\cdot a S], [S \\to \\cdot b S], [S \\to \\cdot a], [S \\to \\cdot b]\\}$。\n  $\\operatorname{depth}(I_1) = 1$, $\\operatorname{breadth}(I_1) = 6$。贡献为 $1 \\times 6 = 6$。\n  已发现2个状态。将 $I_1$ 入队。\n\n- **$\\operatorname{goto}(I_0, b) \\to I_2$**: 类似地，从 $[S \\to \\cdot b S]$ 和 $[S \\to \\cdot b]$ 开始。\n  $I_2 = \\operatorname{closure}(\\{[S \\to b \\cdot S], [S \\to b \\cdot]\\}) = \\{[S \\to b \\cdot S], [S \\to b \\cdot], [S \\to \\cdot a S], [S \\to \\cdot b S], [S \\to \\cdot a], [S \\to \\cdot b]\\}$。\n  $\\operatorname{depth}(I_2) = 1$, $\\operatorname{breadth}(I_2) = 6$。贡献为 $1 \\times 6 = 6$。\n  已发现3个状态。将 $I_2$ 入队。\n\n- **$\\operatorname{goto}(I_0, S) \\to I_3$**: 从 $[S' \\to \\cdot S]$ 开始，得到核心 $\\{[S' \\to S \\cdot]\\}$。\n  $I_3 = \\operatorname{closure}(\\{[S' \\to S \\cdot]\\}) = \\{[S' \\to S \\cdot]\\}$。\n  $\\operatorname{depth}(I_3) = 1$, $\\operatorname{breadth}(I_3) = 1$。贡献为 $1 \\times 1 = 1$。\n  已发现4个状态。将 $I_3$ 入队。\n\n现在BFS队列为 $[I_1, I_2, I_3]$。我们需要第5个状态。我们扩展 $I_1$。\n- **扩展 $I_1$**:\n  - $\\operatorname{goto}(I_1, a)$ 从 $[S \\to \\cdot a S], [S \\to \\cdot a]$ 得到的核心与 $I_1$ 的核心相同，因此转移回到 $I_1$。\n  - $\\operatorname{goto}(I_1, b)$ 从 $[S \\to \\cdot b S], [S \\to \\cdot b]$ 得到的核心与 $I_2$ 的核心相同，因此转移到 $I_2$。\n  - **$\\operatorname{goto}(I_1, S) \\to I_4$**: 从项目 $[S \\to a \\cdot S]$ 开始，得到核心 $\\{[S \\to a S \\cdot]\\}$。\n    $I_4 = \\operatorname{closure}(\\{[S \\to a S \\cdot]\\}) = \\{[S \\to a S \\cdot]\\}$。这是一个新状态。\n    $\\operatorname{depth}(I_4) = \\operatorname{depth}(I_1) + 1 = 2$, $\\operatorname{breadth}(I_4) = 1$。贡献为 $2 \\times 1 = 2$。\n    已发现5个状态。\n\n我们找到了 $G_R$ 的前5个状态 $I_0, I_1, I_2, I_3, I_4$。计算 $M(G_R)$：\n$M(G_R) = (0 \\times 5) + (1 \\times 6) + (1 \\times 6) + (1 \\times 1) + (2 \\times 1) = 0 + 6 + 6 + 1 + 2 = 15$。\n\n**第三部分：最终计算**\n\n我们计算差值 $\\Delta = M(G_R) - M(G_L)$。\n$M(G_L) = 7$\n$M(G_R) = 15$\n$\\Delta = 15 - 7 = 8$。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "构建 LR 自动机的最终目标是创建一个无冲突的分析表。最后一个练习  将这一目标置于首位，它展示了一个含有经典移入-归约冲突的状态。你将扮演文法工程师的角色，找出冲突在文法产生式中的根源，并提出一个最小化的修改来解决它，从而将自动机构建的理论与解析器设计的实践艺术联系起来。",
            "id": "3655022",
            "problem": "正在使用规范的“从左到右、最右推导、零前瞻”（LR(0)）方法构建一个上下文无关文法的分析器。考虑增广文法，其起始符号为 $S'$，产生式如下：\n$$\nS' \\to S,\\quad S \\to A \\mid a A b,\\quad A \\to B \\mid a b,\\quad B \\to \\epsilon,\n$$\n其中 $\\epsilon$ 表示空字符串。使用 LR(0) 项目、闭包操作和 goto 操作的基本定义，可以构建 LR(0) 项目集的规范族。通过对初始项目 $[S' \\to \\cdot S]$ 应用闭包操作，一个特定的 LR(0) 状态（初始状态）同时包含了项目 $[A \\to \\cdot a b]$ 和 $[B \\to \\cdot]$，这符合抽象模式 $[A \\to \\alpha \\cdot a \\beta]$ 与 $[B \\to \\gamma \\cdot]$ 共存的情况。\n\n仅基于 LR(0) 自动机构建的第一性原理和 LR(0) 分析表中冲突的定义，确定一个最小的文法修改，该修改限于以下操作之一：添加产生式、删除产生式或重构产生式，以消除该特定状态中潜在的移入-归约冲突。你的修改必须通过证明来说明：在修改后的文法下，有问题的状态不再同时包含一个终结符移入项目和一个已完成项目。令 $N$ 为消除该状态冲突所需更改（添加、删除或重构）的最少产生式数量。计算 $N$。\n\n请以单个整数形式提供最终答案，不带单位。无需四舍五入。",
            "solution": "该问题要求识别并解决给定上下文无关文法的 LR(0) 自动机初始状态中的一个移入-归约冲突。该解决方案必须通过最少数量的产生式修改来实现。\n\n提供的增广文法由以下产生式定义：\n$$\nS' \\to S \\\\\nS \\to A \\mid a A b \\\\\nA \\to B \\mid a b \\\\\nB \\to \\epsilon\n$$\n其中 $S'$ 是增广起始符号，$S, A, B$ 是非终结符，$a, b$ 是终结符，$\\epsilon$ 代表空字符串。\n\n首先，我们必须构造规范 LR(0) 自动机的初始状态，记为 $I_0$。该状态定义为包含初始项目 $\\{[S' \\to \\cdot S]\\}$ 的集合的闭包。闭包操作根据文法产生式系统地添加新项目。对于形如 $[X \\to \\alpha \\cdot Y \\beta]$（其中 $Y$ 是非终结符）的项目，会为每个产生式 $Y \\to \\gamma$ 添加所有项目 $[Y \\to \\cdot \\gamma]$。\n\n构造 $I_0$ 的过程如下：\n1.  初始集合为 $\\{[S' \\to \\cdot S]\\}$。\n2.  项目 $[S' \\to \\cdot S]$ 的点号后面是非终结符 $S$。因此，我们添加所有对应于 $S$ 的产生式的项目，点号位于开头。$S$ 的产生式是 $S \\to A$ 和 $S \\to a A b$。这会产生项目 $[S \\to \\cdot A]$ 和 $[S \\to \\cdot a A b]$。集合变为 $\\{[S' \\to \\cdot S], [S \\to \\cdot A], [S \\to \\cdot a A b]\\}$。\n3.  新添加的项目 $[S \\to \\cdot A]$ 的点号后面是非终结符 $A$。我们为 $A$ 的所有产生式添加项目，即 $A \\to B$ 和 $A \\to a b$。这引入了项目 $[A \\to \\cdot B]$ 和 $[A \\to \\cdot a b]$。集合现在是 $\\{[S' \\to \\cdot S], [S \\to \\cdot A], [S \\to \\cdot a A b], [A \\to \\cdot B], [A \\to \\cdot a b]\\}$。\n4.  项目 $[A \\to \\cdot B]$ 的点号后面是非终结符 $B$。我们为 $B$ 的唯一产生式 $B \\to \\epsilon$ 添加项目。这会添加项目 $[B \\to \\cdot \\epsilon]$，通常写作 $[B \\to \\cdot]$。\n5.  此时，状态 $I_0$ 的项目集为 $\\{[S' \\to \\cdot S], [S \\to \\cdot A], [S \\to \\cdot a A b], [A \\to \\cdot B], [A \\to \\cdot a b], [B \\to \\cdot]\\}$。无法再添加更多项目，因此闭包计算完成。\n\n正如问题中所正确指出的，状态 $I_0$ 同时包含项目 $[A \\to \\cdot a b]$ 和项目 $[B \\to \\cdot]$。\n-   项目 $[A \\to \\cdot a b]$ 是一个 *移入项目*。当看到下一个输入符号是终结符 $a$ 时，它指示分析器执行移入操作。\n-   项目 $[B \\to \\cdot]$ 是一个 *归约项目*。它表示产生式 $B \\to \\epsilon$ 的右侧已被识别。LR(0) 分析器此时必须执行归约操作，而不管前瞻符号是什么。\n\n在同一状态中同时存在移入项目和归约项目会产生 *移入-归约冲突*。分析器无法确定性地选择是移入还是归约。\n\n为了消除这个冲突，我们必须修改文法，使得这两种类型的项目不会同时出现在初始状态中。冲突的产生是因为非终结符 $A$ 既可以推导出以终结符开头的字符串 ($A \\Rightarrow ab$)，也可以推导出空字符串 ($A \\Rightarrow B \\Rightarrow \\epsilon$)。这两种可能性都是通过产生式 $S \\to A$ 引入到初始状态的闭包中的。\n\n题目要求我们进行最小的修改，限于单个产生式的添加、删除或重构。让我们分析删除产生式 $A \\to B$ 的效果。这个操作代表了一次修改。\n\n修改后的文法，我们称之为 $G_{mod}$，具有以下产生式：\n$$\nS' \\to S \\\\\nS \\to A \\mid a A b \\\\\nA \\to a b \\\\\nB \\to \\epsilon\n$$\n在 $G_{mod}$ 中，非终结符 $B$ 不再能从起始符号 $S$ 到达。修改仅仅是删除了产生式 $A \\to B$。\n\n现在，让我们为修改后的文法 $G_{mod}$ 重新计算初始状态 $I'_0$，方法是取 $\\{[S' \\to \\cdot S]\\}$ 的闭包。\n1.  初始集合为 $\\{[S' \\to \\cdot S]\\}$。\n2.  从 $[S' \\to \\cdot S]$，我们为 $S$ 的产生式添加项目：$[S \\to \\cdot A]$ 和 $[S \\to \\cdot a A b]$。集合变为 $\\{[S' \\to \\cdot S], [S \\to \\cdot A], [S \\to \\cdot a A b]\\}$。\n3.  从项目 $[S \\to \\cdot A]$，我们必须为 $A$ 的产生式添加项目。在 $G_{mod}$ 中，$A$ 的唯一产生式是 $A \\to a b$。我们添加项目 $[A \\to \\cdot a b]$。\n4.  状态 $I'_0$ 的项目集现在是 $\\{[S' \\to \\cdot S], [S \\to \\cdot A], [S \\to \\cdot a A b], [A \\to \\cdot a b]\\}$。闭包现在已经完成，因为在新添加的任何项目中，点号后面都没有非终结符。\n\n新的初始状态 $I'_0$ 不包含任何归约项目（即点号在产生式规则右侧末尾的项目，如 $[X \\to \\gamma \\cdot]$）。因此，初始状态中的移入-归约冲突已经解决。\n\n由于删除单个产生式就足以消除冲突，因此必须更改的最少产生式数量 $N$ 最多为 $1$。鉴于原始文法确实存在冲突，修改是必要的，所以 $N > 0$。因此，所需的最少修改次数恰好是 $1$。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}