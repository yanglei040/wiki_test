{
    "hands_on_practices": [
        {
            "introduction": "要构建一个LR分析器，我们首先必须构造出它的大脑：一个由LR(0)项目集构成的有限自动机。本练习将通过让你从一个初始项目集计算一个新状态，来巩固构建这个自动机的两个基本操作，即项目集闭包($\\operatorname{closure}$)和状态转换($\\operatorname{goto}$)函数 。这个过程会特别关注如何处理含空产生式（$\\epsilon$-production）的文法，这是编译器构造中的一个常见且重要的场景。",
            "id": "3655618",
            "problem": "考虑上下文无关文法，其产生式为 $S \\to AB$、$A \\to a \\mid \\epsilon$ 和 $B \\to b$。在从左到右、逆向最右推导（LR）分析的框架下，使用 $LR(0)$ 项目进行分析。令 $I$ 为初始包含项目 $[S \\to \\cdot AB]$ 的单元素集的闭包。仅使用 $LR(0)$ 项目、项目闭包和 $\\operatorname{goto}$ 函数的核心定义，通过首先在 $I$ 的项目中将点（dot）移过 $A$ 得到所有项目，然后求其闭包来构造 $\\operatorname{goto}(I, A)$。令 $n$ 表示基数 $|\\operatorname{goto}(I, A)|$。请对 $\\operatorname{goto}(I, A)$ 中包含的项目给出一个简洁的解释，说明产生式右侧的哪一部分已被识别，以及接下来期望出现哪些符号，然后报告 $n$ 的确切值。你的最终答案应该是 $n$ 的单个整数值。",
            "solution": "问题要求计算给定上下文无关文法的 $LR(0)$ 项目集 $\\operatorname{goto}(I, A)$ 的基数。该文法的产生式为 $S \\to AB$、$A \\to a \\mid \\epsilon$ 和 $B \\to b$。集合 $I$ 被定义为初始项目集 $\\{[S \\to \\cdot AB]\\}$ 的闭包。\n\n设给定的上下文无关文法为 $G$。非终结符集为 $V = \\{S, A, B\\}$，终结符集为 $\\Sigma = \\{a, b\\}$，产生式集 $P$ 为：\n1. $S \\to AB$\n2. $A \\to a$\n3. $A \\to \\epsilon$\n4. $B \\to b$\n\n一个 $LR(0)$ 项目是一个在产生式右侧（RHS）某个位置带有点（$\\cdot$）的产生式。问题需要进行两个主要计算：首先，构造项目集 $I$；其次，构造项目集 $\\operatorname{goto}(I, A)$。\n\n首先，我们通过对初始集 $\\{[S \\to \\cdot AB]\\}$ 应用闭包运算来计算集合 $I$。\n一个项目集 $J$ 的闭包，记为 $\\operatorname{closure}(J)$，计算如下：\n1. 最初，$\\operatorname{closure}(J)$ 中包含 $J$ 中的每个项目。\n2. 如果项目 $[X \\to \\alpha \\cdot Y \\beta]$ 在 $\\operatorname{closure}(J)$ 中，并且 $Y \\to \\gamma$ 是一个产生式，则将项目 $[Y \\to \\cdot \\gamma]$ 添加到 $\\operatorname{closure}(J)$ 中（如果它尚不存在）。\n3. 重复步骤2，直到没有新项目可以添加到 $\\operatorname{closure}(J)$ 中为止。\n\n我们来计算 $I = \\operatorname{closure}(\\{[S \\to \\cdot AB]\\})$。\n1. 我们从初始项目集 $\\{[S \\to \\cdot AB]\\}$ 开始。\n2. 项目 $[S \\to \\cdot AB]$ 的点右侧紧邻非终结符 $A$。因此，我们必须添加所有对应于 $A$ 的产生式的项目。$A$ 的产生式是 $A \\to a$ 和 $A \\to \\epsilon$。这给了我们新项目 $[A \\to \\cdot a]$ 和 $[A \\to \\cdot]$（对应于 $A \\to \\epsilon$）。\n3. 我们当前的项目集是 $\\{[S \\to \\cdot AB], [A \\to \\cdot a], [A \\to \\cdot]\\}$。\n4. 现在我们检查新添加的项目。\n   - 对于 $[A \\to \\cdot a]$，点右侧的符号是终结符 $a$。这不会导致添加任何新项目。\n   - 对于 $[A \\to \\cdot]$，点右侧没有符号。这是一个规约项目，也不会导致添加任何新项目。\n5. 由于没有新项目可以添加，闭包运算完成。得到的项目集是：\n$$I = \\{[S \\to \\cdot AB], [A \\to \\cdot a], [A \\to \\cdot]\\}$$\n\n接下来，我们计算集合 $\\operatorname{goto}(I, A)$。$\\operatorname{goto}$ 函数定义如下：对于一个项目集 $J$ 和一个文法符号 $X$，$\\operatorname{goto}(J, X)$ 是所有满足 $[P \\to \\alpha \\cdot X \\beta]$ 在 $J$ 中的项目 $[P \\to \\alpha X \\cdot \\beta]$ 构成的集合的闭包。\n\n为了计算 $\\operatorname{goto}(I, A)$，我们首先确定新集合的“核心”（kernel）。这个核心由 $I$ 中所有满足非终结符 $A$ 在点右侧的项目组成，并将点移过 $A$。\n查看集合 $I = \\{[S \\to \\cdot AB], [A \\to \\cdot a], [A \\to \\cdot]\\}$，只有项目 $[S \\to \\cdot AB]$ 是 $[P \\to \\alpha \\cdot A \\beta]$ 的形式。这里，$P=S$，$\\alpha=\\epsilon$，$\\beta=B$。\n将点移过 $A$，我们得到项目 $[S \\to A \\cdot B]$。\n因此，$\\operatorname{goto}$ 集的核心是 $\\{[S \\to A \\cdot B]\\}$。\n\n现在，我们必须计算这个核心集的闭包：$\\operatorname{goto}(I, A) = \\operatorname{closure}(\\{[S \\to A \\cdot B]\\})$。\n1. 我们从集合 $\\{[S \\to A \\cdot B]\\}$ 开始。\n2. 项目 $[S \\to A \\cdot B]$ 的点右侧紧邻非终结符 $B$。因此，我们必须添加所有 $B$ 的产生式对应的项目。$B$ 唯一的产生式是 $B \\to b$。这给了我们新项目 $[B \\to \\cdot b]$。\n3. 我们当前的项目集是 $\\{[S \\to A \\cdot B], [B \\to \\cdot b]\\}$。\n4. 我们检查新添加的项目 $[B \\to \\cdot b]$。点右侧的符号是终结符 $b$，所以没有新项目被添加。\n5. 闭包运算完成。得到的项目集是：\n$$\\operatorname{goto}(I, A) = \\{[S \\to A \\cdot B], [B \\to \\cdot b]\\}$$\n\n该集合中项目的解释如下。集合 $\\operatorname{goto}(I, A)$ 表示 LR 自动机在识别了可以规约为非终结符 $A$ 的输入终结符序列后达到的一个状态。\n- 核心项目 $[S \\to A \\cdot B]$ 表示对应于非终结符 $A$ 的一部分输入已被成功解析，分析器现在期望看到一个可以规约为非终结符 $B$ 的终结符序列，以完成产生式 $S \\to AB$。\n- 闭包项目 $[B \\to \\cdot b]$ 指示了分析器如何开始识别期望的 $B$：通过看到终结符 $b$。\n\n最后，问题要求 $n$ 的值，即集合 $\\operatorname{goto}(I, A)$ 的基数。\n$$n = |\\operatorname{goto}(I, A)| = |\\{[S \\to A \\cdot B], [B \\to \\cdot b]\\}|$$\n该集合包含两个不同的项目。因此，基数为 2。\n$n = 2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "构造项目集只是第一步，我们还必须分析它们是否存在冲突，这些冲突会妨碍特定方法成功解析一个文法。本练习  展示了一个经典情景：同一个项目集内既包含“移入”（shift）一个符号的指令，又包含“规约”（reduce）一条规则的指令。通过识别这种“移入/规约冲突”，你将理解LR(0)分析技术的一个根本局限性，并学会如何诊断分析过程中的问题。",
            "id": "3655684",
            "problem": "考虑一个上下文无关文法，其开始符号为 $S$，产生式为 $S \\to aS \\mid Sb \\mid \\epsilon$。通过引入一个新的开始符号 $S'$ 和产生式 $S' \\to S$ 来增广该文法。仅使用 $LR(0)$ 项目、项目闭包和 $goto$ 函数的标准定义，构造初始 $LR(0)$ 项目集 $I_0 = \\operatorname{closure}(\\{[S' \\to \\cdot S]\\})$。从第一性原理出发，在 $I_0$ 中识别一个项目集，该项目集同时包含已完成项目 $[S \\to \\epsilon \\cdot]$ 和至少一个点号位于终结符 $a$ 或 $b$ 之前的项目，从而使得在该终结符上可以进行移入操作。解释为什么这种情况在 $LR(0)$ 分析框架中构成了移入/归约冲突。最后，计算该项目集中存在的不同 $LR(0)$ 移入/归约冲突的总数。将你的最终答案表示为一个没有单位的整数。无需四舍五入。",
            "solution": "该问题要求我们分析一个给定的上下文无关文法，构造其初始 $LR(0)$ 项目集 $I_0$，并确定该项目集内的移入/归约冲突数量。\n\n文法 $G$ 的开始符号为 $S$，其产生式如下：\n1. $S \\to aS$\n2. $S \\to Sb$\n3. $S \\to \\epsilon$\n\n首先，我们通过引入一个新的开始符号 $S'$ 和一个新的产生式 $S' \\to S$ 来增广该文法。增广后的文法 $G'$ 为：\n0. $S' \\to S$\n1. $S \\to aS$\n2. $S \\to Sb$\n3. $S \\to \\epsilon$\n\n下一步是构造初始 $LR(0)$ 项目集，记为 $I_0$。该集合被定义为从增广产生式派生出的初始项目的闭包，即 $I_0 = \\operatorname{closure}(\\{[S' \\to \\cdot S]\\})$。\n\n$\\operatorname{closure}$ 操作定义如下：\n如果一个项目 $[A \\to \\alpha \\cdot B \\beta]$ 存在于一个项目集中，并且 $B \\to \\gamma$ 是文法中的一个产生式，那么项目 $[B \\to \\cdot \\gamma]$ 也必须在该集合的闭包中。重复此过程，直到没有新项目可以添加为止。\n\n我们来计算 $I_0$：\n1. 我们从只包含增广产生式项目的初始项目集开始：$\\{[S' \\to \\cdot S]\\}$。\n\n2. 在 $[S' \\to \\cdot S]$ 中，点号位于非终结符 $S$ 之前。因此，我们必须添加所有对应于 $S$ 的产生式的项目，且点号位于产生式右部的开头。$S$ 的产生式为 $S \\to aS$、$S \\to Sb$ 和 $S \\to \\epsilon$。添加相应的项目后，我们的集合变为：\n$\\{[S' \\to \\cdot S], [S \\to \\cdot aS], [S \\to \\cdot Sb], [S \\to \\epsilon \\cdot]\\}$\n请注意，产生式 $S \\to \\epsilon$ 产生项目 $[S \\to \\cdot]$，为清晰起见，根据问题的表示法，我们将其写为 $[S \\to \\epsilon \\cdot]$。\n\n3. 现在我们检查对新添加的项目应用闭包规则是否可以添加任何新项目：\n- 对于 $[S \\to \\cdot aS]$，点号位于终结符（$a$）之前，因此不添加新项目。\n- 对于 $[S \\to \\cdot Sb]$，点号位于非终结符 $S$ 之前。我们必须添加 $S$ 的产生式对应的项目。然而，项目 $[S \\to \\cdot aS]$、$[S \\to \\cdot Sb]$ 和 $[S \\to \\epsilon \\cdot]$ 已经存在于我们的集合中。因此，没有新项目被添加。\n- 对于 $[S \\to \\epsilon \\cdot]$，点号在末尾（这是一个已完成或归约项目），因此不添加新项目。\n\n闭包过程完成。初始 $LR(0)$ 项目集是：\n$$ I_0 = \\{[S' \\to \\cdot S], [S \\to \\cdot aS], [S \\to \\cdot Sb], [S \\to \\epsilon \\cdot]\\} $$\n\n问题要求我们在 $I_0$ 中识别一个构成移入/归约冲突的情况。如果一个项目集同时包含以下两种情况，则会发生 $LR(0)$ 移入/归约冲突：\n- 一个*移入*项目，其形式为 $[A \\to \\alpha \\cdot t \\beta]$，其中 $t$ 是一个终结符。这表示分析器可以将输入中的终结符 $t$ 移入到栈中。\n- 一个*归约*项目，它是一个形式为 $[B \\to \\gamma \\cdot]$ 的已完成项目。在 $LR(0)$ 框架中，这表示分析器可以使用产生式 $B \\to \\gamma$ 执行归约操作，而不管下一个输入符号是什么。\n\n让我们在这种情况下分析项目集 $I_0$。该文法的终结符是 $a$ 和 $b$。\n\n- **对终结符 $a$ 的分析：**\n  - 项目 $[S \\to \\cdot aS]$ 存在于 $I_0$ 中。点号位于终结符 $a$ 之前。这对应于在输入为 $a$ 时的**移入**操作。\n  - 项目 $[S \\to \\epsilon \\cdot]$ 也存在于 $I_0$ 中。这是一个已完成项目。在 $LR(0)$ 分析器中，该项目指令对任何向前看终结符都执行**归约**操作（通过产生式 $S \\to \\epsilon$）。因此，它为输入 $a$ 指定了一个归约操作。\n  - 由于集合 $I_0$ 指示分析器在输入终结符 $a$ 上既要 `移入` 又要 `归约`，因此对于终结符 $a$ 存在**移入/归约冲突**。\n\n- **对终结符 $b$ 的分析：**\n  - $I_0$ 中是否存在形式为 $[A \\to \\alpha \\cdot b \\beta]$ 的项目？不存在。项目 $[S \\to \\cdot Sb]$ 的点号位于非终结符 $S$ 之前，而不是终结符 $b$ 之前。因此，对于输入 $b$ 没有移入操作。\n  - 项目 $[S \\to \\epsilon \\cdot]$ 存在于 $I_0$ 中，它指令在输入为 $b$ 时执行**归约**操作。\n  - 对于终结符 $b$，只有一个定义的操作：`归约`。没有冲突。\n\n一个独立的移入/归约冲突是为每个发生冲突的（状态，终结符）对定义的。在我们的例子中，状态是 $I_0$。\n- 对于对 $(I_0, a)$，存在移入/归约冲突。\n- 对于对 $(I_0, b)$，不存在冲突。\n\n因此，在项目集 $I_0$ 中恰好存在一个独立的移入/归约冲突。\n\n最后的任务是计算项目集 $I_0$ 中存在的不同 $LR(0)$ 移入/归约冲突的总数。根据以上分析，这个数字是 $1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "对一个概念的真正检验，不仅仅在于应用规则，更在于理解其失效的条件。这个高级练习  要求你超越分析，进行设计：你将创建一个简单的文法，它会故意为LR(0)分析器制造一个移入/规约冲突。通过完成这一挑战，你将对冲突产生的原因以及像SLR(1)这样更强大的分析技术如何解决这些冲突，建立起更深刻的直觉。",
            "id": "3655655",
            "problem": "你将完全从第一性原理出发：LR(0)项目的定义、项目闭包操作、goto函数，以及为增广文法构建规范LR(0)项目集族。这里，LR代表从左到右扫描输入、逆向最右推导（Left-to-right input scan, Rightmost derivation in reverse），而LR(0)表示使用$0$个前瞻符号的LR分析；使用一个前瞻符号的简单LR（SLR(1)）则利用FOLLOW集来限制规约。\n\n设计一个上下文无关文法$G$，使其同时满足以下所有约束条件：\n- 终结符字母表为$\\{a\\}$。\n- 只有一个非终结符，即开始符号$S$。\n- 恰好有$2$个产生式。\n- 由$G$生成的语言是$\\{\\epsilon, a\\}$。\n- 增广文法$G'$（通过添加一个新开始符号$S'$和产生式$S' \\to S$得到）的规范LR(0)项目集族表现出一种移入/规约冲突，这种冲突纯粹由LR(0)的局限性引起，意味着当使用FOLLOW集为同一文法构建SLR(1)分析表时，该冲突会消失。\n\n仅使用LR(0)项目、项目闭包和goto的核心定义，按以下步骤进行：\n1. 给出满足约束条件的文法$G$。\n2. 用新的开始产生式$S' \\to S$将其增广为$G'$。\n3. 构建初始LR(0)项目集$I_{0} = \\operatorname{closure}(\\{S' \\to \\cdot S\\})$，并在规范LR(0)项目集族中找出产生移入/规约冲突的特定项目集$I_{c}$。\n4. 直接根据定义，证明为何所识别的冲突在LR(0)下是移入/规约冲突，并借助FOLLOW集解释为何它在SLR(1)下会消失。\n5. 令$k$为冲突项目集$I_{c}$的基数。报告$k$作为你的最终答案。\n\n你的最终答案必须是单个整数值$k$。不需要单位，也无需四舍五入。",
            "solution": "该问题要求设计一个具有特定属性的上下文无关文法$G$，然后使用LR($0$)和SLR($1$)分析的正式定义对其进行分析，以识别一个移入/规约冲突，并确定该冲突所在项目集的基数。\n\n**1. 文法规范**\n\n文法$G$的约束条件是：\n- 终结符字母表为$\\{a\\}$。\n- 只有一个非终结符，即开始符号$S$。\n- 恰好有$2$个产生式。\n- 生成的语言是$L(G) = \\{\\epsilon, a\\}$，其中$\\epsilon$表示空字符串。\n\n一个满足所有这些约束条件的文法是：\n$$\n\\begin{aligned}\nS  \\to a \\\\\nS  \\to \\epsilon\n\\end{aligned}\n$$\n该文法有一个非终结符$S$，一个终结符$a$，以及两个产生式。它显然生成仅包含字符串$a$和$\\epsilon$的语言。\n\n**2. 增广文法**\n\n为了构建一个LR分析器，我们首先将文法$G$增广为$G'$。引入一个新的开始符号$S'$，以及一个新的产生式$S' \\to S$。为了便于后续在规约动作中引用，我们对$G'$的产生式进行编号：\n1. $S' \\to S$\n2. $S \\to a$\n3. $S \\to \\epsilon$\n\n**3. 规范LR(0)项目集族与冲突识别**\n\n我们构建LR($0$)项目的规范集族。一个LR($0$)项目是一个在右侧某处带有一个点（$\\cdot$）的产生式。该过程从项目集$I_{0}$开始，它是初始项目$\\{[S' \\to \\cdot S]\\}$的闭包。\n\n对一个项目集$I$的$\\operatorname{closure}$操作计算如下：\n- 最初，$\\operatorname{closure}(I)$中包含$I$中的每个项目。\n- 如果一个项目$[A \\to \\alpha \\cdot B \\beta]$在$\\operatorname{closure}(I)$中，其中$B$是一个非终结符，那么对于每个产生式$B \\to \\gamma$，项目$[B \\to \\cdot \\gamma]$被添加到$\\operatorname{closure}(I)$中。\n- 重复此过程，直到没有新项目可以添加到$\\operatorname{closure}(I)$中。\n\n让我们计算$I_{0} = \\operatorname{closure}(\\{[S' \\to \\cdot S]\\})$：\n- 初始集包含项目$[S' \\to \\cdot S]$。\n- 点在非终结符$S$之前。因此，我们必须添加所有对应于$S$的产生式的项目，且点在最开始。$S$的产生式是$S \\to a$和$S \\to \\epsilon$。\n- 这会添加项目$[S \\to \\cdot a]$和$[S \\to \\epsilon \\cdot]$。\n- 项目$[S \\to \\epsilon \\cdot]$的点在产生式右侧的末尾，它不会再添加任何新项目。闭包过程终止。\n\n初始项目集为：\n$$ I_{0} = \\{[S' \\to \\cdot S], [S \\to \\cdot a], [S \\to \\epsilon \\cdot]\\} $$\n这个项目集$I_{0}$代表了LR($0$)自动机的初始状态。我们必须分析这个状态是否存在冲突。如果一个项目集同时包含一个移入项目（$[A \\to \\alpha \\cdot t \\beta]$，其中$t$是终结符）和一个规约项目（$[B \\to \\gamma \\cdot]$），则该项目集存在移入/规约冲突。\n\n在$I_{0}$中，我们有：\n- 项目$[S \\to \\cdot a]$：这是一个移入项目。它规定如果分析器处于对应于$I_{0}$的状态，并且下一个输入符号是$a$，分析器应执行移入（SHIFT）动作。\n- 项目$[S \\to \\epsilon \\cdot]$：这是一个规约项目，表示产生式的右侧已被完全识别。在LR($0$)分析中，包含此类项目的状态要求对*任何*前瞻符号都执行规约（REDUCE）动作。\n\n由于对于前瞻符号$a$，项目集$I_{0}$既建议执行移入动作（来自$[S \\to \\cdot a]$），又建议执行规约动作（来自$[S \\to \\epsilon \\cdot]$），因此该状态存在移入/规约冲突。所以该文法不是LR($0$)。冲突项目集为$I_{c} = I_{0}$。\n\n**4. 在SLR(1)下的冲突解决**\n\nSLR($1$)分析通过使规约动作更具选择性来解决此类冲突。对于一个产生式$B \\to \\gamma$的规约动作，仅当下一个前瞻符号在集合$\\operatorname{FOLLOW}(B)$中时才执行。我们必须计算非终结符$S$的FOLLOW集。\n\nFOLLOW集基于文法$G'$计算。\n1.  对于增广产生式$S' \\to S$，非终结符$S$之后是产生式的末尾。因此，$\\operatorname{FOLLOW}(S')$中的所有符号都在$\\operatorname{FOLLOW}(S)$中。根据定义，$\\operatorname{FOLLOW}(S')$包含输入结束标记，我们表示为$\\$$。所以，$\\$ \\in \\operatorname{FOLLOW}(S)$。\n2.  我们在产生式的右侧寻找$S$的其他出现。没有其他这样的出现。\n\n因此，$S$的FOLLOW集是$\\operatorname{FOLLOW}(S) = \\{ \\$\\}$。\n\n现在我们根据SLR($1$)规则重新考虑状态$I_{0}$中的动作：\n- **移入动作**：项目$[S \\to \\cdot a]$仍然表示在前瞻符号为$a$时，分析器应该移入。\n- **规约动作**：项目$[S \\to \\epsilon \\cdot]$对应于按产生式$S \\to \\epsilon$进行规约。这个动作现在仅当下一个前瞻符号在$\\operatorname{FOLLOW}(S)$中时才有效。由于$\\operatorname{FOLLOW}(S) = \\{ \\$\\}$，规约动作仅在前瞻符号为$\\$$时执行。\n\n状态$I_{0}$的分析动作变为：\n- 如果前瞻符号是$a$：执行移入。\n- 如果前瞻符号是$\\$$：执行按$S \\to \\epsilon$规约。\n\n移入和规约动作的前瞻符号集（$\\{a\\}$和$\\{ \\$\\}$）是不相交的。因此，移入/规约冲突得到解决。该文法是SLR($1$)。\n\n**5. 冲突集的基数**\n\n问题要求$k$，即冲突项目集$I_{c}$的基数。我们已确定该集合为$I_{0}$。\n$$ I_{c} = I_{0} = \\{[S' \\to \\cdot S], [S \\to \\cdot a], [S \\to \\epsilon \\cdot]\\} $$\n该集合包含$3$个不同的LR($0$)项目。因此，基数为$k = 3$。",
            "answer": "$$\\boxed{3}$$"
        }
    ]
}