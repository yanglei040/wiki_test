{
    "hands_on_practices": [
        {
            "introduction": "A common task in compiler construction is transforming a grammar, for instance, to eliminate left recursion for use with a predictive parser. This practice explores how such a fundamental change to the grammar's structure directly impacts the strategy for attribute evaluation. By comparing the evaluation schedules for a left-recursive grammar and its right-recursive equivalent , you will see firsthand why the simple, bottom-up approach of S-attributed definitions is insufficient after the transformation, necessitating the introduction of inherited attributes in an L-attributed scheme to preserve the original meaning.",
            "id": "3641106",
            "problem": "Consider two syntax-directed definitions (SDDs) for expression evaluation over addition that differ only in whether the expression grammar uses left recursion or its non-left-recursive equivalent. You will compare the evaluation order of attributes before and after left recursion elimination on the same input and determine which proposed schedules are valid.\n\nFundamental starting points:\n- A syntax-directed definition (SDD) associates attributes and semantic rules with a context-free grammar. An attribute instance can be evaluated only when all attributes on which it depends have already been computed. Any correct evaluation order is a topological order of the attribute-dependency graph for the given parse tree.\n- A synthesized attribute of a node is computed from attributes of its children. An inherited attribute of a node is computed from attributes of its parent and/or siblings.\n- Eliminating left recursion from a grammar transforms a left-recursive rule into an equivalent right-recursive or iterative form, which often requires converting a purely synthesized SDD into an L-attributed SDD with inherited attributes to preserve left-to-right evaluation.\n\nGrammars and SDDs:\n1) Left-recursive grammar and S-attributed SDD:\n- Grammar $G_1$:\n  - $E \\to E + T \\mid T$\n  - $T \\to n$ where $n$ is a number token with lexical value $n.lexval$.\n- Attributes and rules:\n  - For $E \\to E_1 + T$: $E.val = E_1.val + T.val$.\n  - For $E \\to T$: $E.val = T.val$.\n  - For $T \\to n$: $T.val = n.lexval$.\n  All attributes are synthesized.\n\n2) Non-left-recursive grammar and L-attributed SDD:\n- Grammar $G_2$ (after left recursion elimination):\n  - $E \\to T \\; E'$\n  - $E' \\to + \\; T \\; E' \\mid \\varepsilon$\n  - $T \\to n$\n- Attributes and rules:\n  - For $E \\to T \\; E'$: $E'.inh = T.val$, $E.val = E'.syn$.\n  - For $E' \\to + \\; T \\; E'_1$: $E'_1.inh = E'.inh + T.val$, $E'.syn = E'_1.syn$.\n  - For $E' \\to \\varepsilon$: $E'.syn = E'.inh$.\n  - For $T \\to n$: $T.val = n.lexval$.\n  Here $E'.inh$ is an inherited attribute carrying the running sum, and $E'.syn$ is synthesized back to $E$.\n\nInput and parse-shape conventions:\n- Consider the input $n_1 + n_2 + n_3$. For $G_1$, the leftmost derivation yields the parse tree $E_3 \\Rightarrow E_2 + T_3 \\Rightarrow (E_1 + T_2) + T_3 \\Rightarrow (T_1 + T_2) + T_3$. Name the three $T$-nodes from left to right $T_1, T_2, T_3$, and the three $E$-nodes from bottom to top $E_1$ (for $E \\to T$), $E_2$ (for the first $+$), and $E_3$ (root).\n- For $G_2$, the parse unfolds as $E \\to T_1 \\; E'_0$, then $E'_0 \\to + \\; T_2 \\; E'_1$, then $E'_1 \\to + \\; T_3 \\; E'_2$, then $E'_2 \\to \\varepsilon$. Name the $E'$-chain nodes $E'_0, E'_1, E'_2$.\n\nGoal:\n- Using only the SDD rules above and the principle that a valid schedule must be a topological order of the dependency graph, determine which option lists a valid evaluation order for both $G_1$ and $G_2$ on the input $n_1 + n_2 + n_3$. In all sequences below, each item names a single attribute instance to be computed at that point. Assume that reading $n_i.lexval$ is part of computing $T_i.val$.\n\nOptions:\nA) \n- For $G_1$: $T_1.val,\\; E_1.val,\\; T_2.val,\\; E_2.val,\\; T_3.val,\\; E_3.val$.\n- For $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$.\n\nB)\n- For $G_1$: $T_1.val,\\; E_1.val,\\; E_2.val,\\; T_2.val,\\; T_3.val,\\; E_3.val$.\n- For $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$.\n\nC)\n- For $G_1$: $T_1.val,\\; T_2.val,\\; E_2.val,\\; E_1.val,\\; T_3.val,\\; E_3.val$.\n- For $G_2$: $E'_0.inh,\\; T_1.val,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$.\n\nD)\n- For $G_1$: $T_1.val,\\; E_1.val,\\; T_2.val,\\; T_3.val,\\; E_2.val,\\; E_3.val$.\n- For $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; E.val,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn$.\n\nChoose the option that is correct. There is at least one correct option. Only select an option if both schedules it lists are valid topological orders for the corresponding SDDs.",
            "solution": "We start from the governing principles for attribute evaluation order:\n- For any syntax-directed definition (SDD), the attributes and equations at each node of a parse tree induce a directed acyclic graph of attribute dependencies. An attribute instance can be evaluated only after all attributes it depends on are available. Thus any valid evaluation order is a topological sort of that dependency graph.\n- For synthesized attributes, a node’s attribute depends on its children’s attributes. For inherited attributes, a node’s attribute depends on attributes of its parent and/or siblings located to its left in the derivation.\n- Eliminating left recursion from $E \\to E + T \\mid T$ yields $E \\to T E'$, $E' \\to + T E' \\mid \\varepsilon$. To preserve left-associative evaluation under an L-attributed SDD, we use an inherited attribute $E'.inh$ to carry the running total and a synthesized attribute $E'.syn$ to propagate the final value back to $E$.\n\nWe now make the dependencies explicit for the given input $n_1 + n_2 + n_3$.\n\nFor $G_1$ with S-attributed rules:\n- Tree shape: $E_3 \\to E_2 + T_3$, $E_2 \\to E_1 + T_2$, $E_1 \\to T_1$, and $T_i \\to n_i$ for $i \\in \\{1,2,3\\}$.\n- Attribute equations:\n  - $T_i.val = n_i.lexval$.\n  - $E_1.val = T_1.val$.\n  - $E_2.val = E_1.val + T_2.val$.\n  - $E_3.val = E_2.val + T_3.val$.\n- Dependencies:\n  - $E_1.val$ depends on $T_1.val$.\n  - $E_2.val$ depends on $E_1.val$ and $T_2.val$.\n  - $E_3.val$ depends on $E_2.val$ and $T_3.val$.\n  - Each $T_i.val$ depends only on $n_i.lexval$, which we treat as available when computing $T_i.val$.\n- Any valid schedule must respect these dependencies: $T_1.val$ before $E_1.val$; both $E_1.val$ and $T_2.val$ before $E_2.val$; both $E_2.val$ and $T_3.val$ before $E_3.val$.\n\nFor $G_2$ with L-attributed rules:\n- Derivation: $E \\to T_1 \\; E'_0$, $E'_0 \\to + \\; T_2 \\; E'_1$, $E'_1 \\to + \\; T_3 \\; E'_2$, $E'_2 \\to \\varepsilon$.\n- Attribute equations instantiated along the chain:\n  - $T_i.val = n_i.lexval$ for $i \\in \\{1,2,3\\}$.\n  - From $E \\to T_1 \\; E'_0$: $E'_0.inh = T_1.val$, $E.val = E'_0.syn$.\n  - From $E'_0 \\to + \\; T_2 \\; E'_1$: $E'_1.inh = E'_0.inh + T_2.val$, $E'_0.syn = E'_1.syn$.\n  - From $E'_1 \\to + \\; T_3 \\; E'_2$: $E'_2.inh = E'_1.inh + T_3.val$, $E'_1.syn = E'_2.syn$.\n  - From $E'_2 \\to \\varepsilon$: $E'_2.syn = E'_2.inh$.\n- Dependencies:\n  - $E'_0.inh$ depends on $T_1.val$.\n  - $E'_1.inh$ depends on $E'_0.inh$ and $T_2.val$.\n  - $E'_2.inh$ depends on $E'_1.inh$ and $T_3.val$.\n  - $E'_2.syn$ depends on $E'_2.inh$.\n  - $E'_1.syn$ depends on $E'_2.syn$.\n  - $E'_0.syn$ depends on $E'_1.syn$.\n  - $E.val$ depends on $E'_0.syn$.\n- Any valid schedule must compute inherited attributes when their prerequisites are available and must defer synthesized attributes until their dependencies are satisfied.\n\nWe now evaluate each option against these dependency constraints.\n\nOption A:\n- $G_1$: $T_1.val,\\; E_1.val,\\; T_2.val,\\; E_2.val,\\; T_3.val,\\; E_3.val$.\n  - Check: $T_1.val$ before $E_1.val$ — satisfied. $E_2.val$ is scheduled after both $E_1.val$ and $T_2.val$ — satisfied. $E_3.val$ is after $E_2.val$ and $T_3.val$ — satisfied. This is a valid topological order.\n- $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$.\n  - Check: $E'_0.inh$ after $T_1.val$ — satisfied. $E'_1.inh$ after $E'_0.inh$ and $T_2.val$ — satisfied. $E'_2.inh$ after $E'_1.inh$ and $T_3.val$ — satisfied. Then synthesized chain $E'_2.syn \\to E'_1.syn \\to E'_0.syn \\to E.val$ is in order. This is a valid topological order.\nVerdict: Correct.\n\nOption B:\n- $G_1$: $T_1.val,\\; E_1.val,\\; E_2.val,\\; T_2.val,\\; T_3.val,\\; E_3.val$.\n  - Check: $E_2.val$ appears before $T_2.val$, but $E_2.val$ depends on $T_2.val$. This violates the dependency $T_2.val \\to E_2.val$. Invalid.\n- $G_2$: The $G_2$ schedule shown matches that of Option A and is valid, but the option requires both schedules to be valid.\nVerdict: Incorrect because the $G_1$ schedule violates dependencies.\n\nOption C:\n- $G_1$: $T_1.val,\\; T_2.val,\\; E_2.val,\\; E_1.val,\\; T_3.val,\\; E_3.val$.\n  - Check: $E_2.val$ is scheduled before $E_1.val$, but $E_2.val$ depends on $E_1.val$. This violates the dependency $E_1.val \\to E_2.val$. Invalid.\n- $G_2$: $E'_0.inh$ is scheduled before $T_1.val$, but $E'_0.inh$ depends on $T_1.val$. This violates the dependency $T_1.val \\to E'_0.inh$. Invalid.\nVerdict: Incorrect.\n\nOption D:\n- $G_1$: $T_1.val,\\; E_1.val,\\; T_2.val,\\; T_3.val,\\; E_2.val,\\; E_3.val$.\n  - Check: $E_2.val$ is after both $E_1.val$ and $T_2.val$ — satisfied. $E_3.val$ is after $E_2.val$ and $T_3.val$ — satisfied. The $G_1$ schedule is valid.\n- $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; E.val,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn$.\n  - Check: $E.val$ is scheduled before $E'_0.syn$, but $E.val$ depends on $E'_0.syn$. This violates the dependency $E'_0.syn \\to E.val$. Additionally, the synthesized chain $E'_2.syn \\to E'_1.syn \\to E'_0.syn$ is placed after $E.val$, further violating dependencies. Invalid.\nVerdict: Incorrect.\n\nConclusion: Only Option A provides valid topological orders for both SDDs. It also illustrates the structural change in evaluation after left recursion elimination: the S-attributed $G_1$ schedule is purely bottom-up over synthesized attributes on a left-recursive tree, while the L-attributed $G_2$ schedule interleaves immediate computation of $T_i.val$ with propagation of inherited attributes $E'_i.inh$, then collapses synthesized results back up via $E'_i.syn$. This difference arises directly from the introduction of inherited attributes to carry the running sum in the non-left-recursive grammar.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Once we understand that attribute dependencies form a directed acyclic graph (DAG), the question becomes: how do we systematically find a valid evaluation sequence? This exercise makes the abstract concept of topological sorting concrete by guiding you through a manual execution of Kahn's algorithm on a specific attribute-dependency graph . You will translate the semantic rules of a syntax-directed definition into a formal dependency graph and then apply the algorithm to determine the precise, step-by-step order of computations, reinforcing the direct link between declarative rules and the imperative procedure a compiler follows.",
            "id": "3641188",
            "problem": "You are studying evaluation orders for Syntax-Directed Definitions (SDD) in compiler principles. The evaluation order of attribute occurrences for a well-defined SDD is any topological order of its attribute-dependency graph, which is a Directed Acyclic Graph (DAG) under the assumption of no circular dependencies. A standard algorithm for topological sorting is Kahn’s algorithm, which repeatedly removes a node of in-degree zero and deletes its outgoing edges, adding newly freed nodes to a ready set.\n\nConsider the following SDD over a list grammar. The grammar is:\n- $L \\to L , E$\n- $L \\to E$\n- $E \\to \\mathrm{id}$\n\nAttributes:\n- Nonterminal $L$ has an inherited attribute $L.n$ and a synthesized attribute $L.\\mathrm{len}$.\n- Nonterminal $E$ has an inherited attribute $E.n$ and a synthesized attribute $E.\\mathrm{pos}$.\n\nSemantic equations:\n- For production $L \\to L_{1} , E_{r}$:\n  - $L_{1}.n = L.n$\n  - $E_{r}.n = L_{1}.n + L_{1}.\\mathrm{len}$\n  - $L.\\mathrm{len} = L_{1}.\\mathrm{len} + 1$\n- For production $L \\to E_{x}$:\n  - $E_{x}.n = L.n$\n  - $L.\\mathrm{len} = 1$\n- For production $E \\to \\mathrm{id}$:\n  - $E.\\mathrm{pos} = E.n$\n\nParse tree for the input $\\mathrm{id} , \\mathrm{id} , \\mathrm{id}$:\n- The root is $L_{0}$ with production $L \\to L , E$, having left child $L_{1}$ and right child $E_{2}$.\n- Node $L_{1}$ uses production $L \\to L , E$, having left child $L_{2}$ and right child $E_{1}$.\n- Node $L_{2}$ uses production $L \\to E$ with child $E_{0}$.\n- Each $E_{i}$ derives $\\mathrm{id}$.\n\nAssume the inherited attribute of the root is fixed: $L_{0}.n = 1$. Also, for production $L \\to E$ we have $L.\\mathrm{len} = 1$, so $L_{2}.\\mathrm{len} = 1$.\n\nDefine the attribute occurrences and their numeric identifiers as follows:\n- $1$: $L_{0}.n$\n- $2$: $L_{0}.\\mathrm{len}$\n- $3$: $L_{1}.n$\n- $4$: $L_{1}.\\mathrm{len}$\n- $5$: $L_{2}.n$\n- $6$: $L_{2}.\\mathrm{len}$\n- $7$: $E_{0}.n$\n- $8$: $E_{0}.\\mathrm{pos}$\n- $9$: $E_{1}.n$\n- $10$: $E_{1}.\\mathrm{pos}$\n- $11$: $E_{2}.n$\n- $12$: $E_{2}.\\mathrm{pos}$\n\nTask:\n- Construct the attribute-dependency edges induced by the semantic equations instantiated on this parse tree. Each edge is from a source occurrence to a target occurrence that depends on it. The resulting graph is a DAG.\n- Run Kahn’s algorithm on this DAG to obtain a topological evaluation order of the $12$ attribute occurrences. Use the following tie-breaking rule: whenever there are multiple occurrences with in-degree zero in the ready set, choose the one with the smallest numeric identifier.\n- Let $(v_{1}, v_{2}, \\ldots, v_{12})$ be the resulting ordered sequence of occurrences, and let $\\mathrm{id}(v_{i})$ denote the numeric identifier of $v_{i}$ given above. Compute the value\n$$\nS \\;=\\; \\sum_{i=1}^{12} i \\cdot \\mathrm{id}(v_{i}).\n$$\n\nYour final answer must be the exact value of $S$ as a single number. No rounding is required.",
            "solution": "### Step 1: Constructing the Attribute-Dependency Graph\nWe instantiate the semantic rules on the given parse tree to determine the dependencies between the attribute occurrences, which are identified by numbers $1$ through $12$. An edge $u \\to v$ means that computing attribute $v$ requires the value of attribute $u$.\n\nThe dependencies derived from the semantic rules applied to the parse tree are:\n- **At node $L_0$ ($L_0 \\to L_1, E_2$):**\n  - $L_1.n = L_0.n \\implies 1 \\to 3$\n  - $E_2.n = L_1.n + L_1.\\mathrm{len} \\implies 3 \\to 11$ and $4 \\to 11$\n  - $L_0.\\mathrm{len} = L_1.\\mathrm{len} + 1 \\implies 4 \\to 2$\n- **At node $L_1$ ($L_1 \\to L_2, E_1$):**\n  - $L_2.n = L_1.n \\implies 3 \\to 5$\n  - $E_1.n = L_2.n + L_2.\\mathrm{len} \\implies 5 \\to 9$ and $6 \\to 9$\n  - $L_1.\\mathrm{len} = L_2.\\mathrm{len} + 1 \\implies 6 \\to 4$\n- **At node $L_2$ ($L_2 \\to E_0$):**\n  - $E_0.n = L_2.n \\implies 5 \\to 7$\n  - $L_2.\\mathrm{len} = 1$ implies that attribute $6$ has no dependencies.\n- **At nodes $E_0, E_1, E_2$ ($E \\to \\mathrm{id}$):**\n  - $E_0.\\mathrm{pos} = E_0.n \\implies 7 \\to 8$\n  - $E_1.\\mathrm{pos} = E_1.n \\implies 9 \\to 10$\n  - $E_2.\\mathrm{pos} = E_2.n \\implies 11 \\to 12$\n\nThe initial condition $L_0.n = 1$ implies that attribute $1$ also has no dependencies.\n\n### Step 2: Topological Sort using Kahn's Algorithm\nWe compute the initial in-degree of each node and use Kahn's algorithm. Let $R$ be the ready set of nodes with in-degree $0$, and $T$ be the topological order.\n- **Initial in-degrees**: In-degree($1$)=0, In-degree($6$)=0. All other nodes have in-degrees $> 0$.\n- **Execution Trace**:\n1.  **Initial**: $R = \\{1, 6\\}$. $T = ()$.\n2.  **Select $v_1$**: Choose $1$ from $R$ (smallest ID). $T = (1)$. Add $3$ to $R$. $R = \\{3, 6\\}$.\n3.  **Select $v_2$**: Choose $3$ from $R$. $T = (1, 3)$. Add $5$ to $R$. $R = \\{5, 6\\}$.\n4.  **Select $v_3$**: Choose $5$ from $R$. $T = (1, 3, 5)$. Add $7$ to $R$. $R = \\{6, 7\\}$.\n5.  **Select $v_4$**: Choose $6$ from $R$. $T = (1, 3, 5, 6)$. Add $4$ and $9$ to $R$. $R = \\{4, 7, 9\\}$.\n6.  **Select $v_5$**: Choose $4$ from $R$. $T = (1, 3, 5, 6, 4)$. Add $2$ and $11$ to $R$. $R = \\{2, 7, 9, 11\\}$.\n7.  **Select $v_6$**: Choose $2$ from $R$. $T = (1, 3, 5, 6, 4, 2)$. $R = \\{7, 9, 11\\}$.\n8.  **Select $v_7$**: Choose $7$ from $R$. $T = (1, 3, 5, 6, 4, 2, 7)$. Add $8$ to $R$. $R = \\{8, 9, 11\\}$.\n9.  **Select $v_8$**: Choose $8$ from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8)$. $R = \\{9, 11\\}$.\n10. **Select $v_9$**: Choose $9$ from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8, 9)$. Add $10$ to $R$. $R = \\{10, 11\\}$.\n11. **Select $v_{10}$**: Choose $10$ from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8, 9, 10)$. $R = \\{11\\}$.\n12. **Select $v_{11}$**: Choose $11$ from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8, 9, 10, 11)$. Add $12$ to $R$. $R = \\{12\\}$.\n13. **Select $v_{12}$**: Choose $12$ from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8, 9, 10, 11, 12)$.\n\nThe final topologically sorted sequence of attribute identifiers, $\\mathrm{id}(v_i)$, is:\n$$(1, 3, 5, 6, 4, 2, 7, 8, 9, 10, 11, 12)$$\n\n### Step 3: Compute the Sum S\nThe value $S$ is calculated as $S = \\sum_{i=1}^{12} i \\cdot \\mathrm{id}(v_{i})$.\n$$\n\\begin{align*}\nS &= (1 \\cdot 1) + (2 \\cdot 3) + (3 \\cdot 5) + (4 \\cdot 6) + (5 \\cdot 4) + (6 \\cdot 2) \\\\\n  &\\quad + (7 \\cdot 7) + (8 \\cdot 8) + (9 \\cdot 9) + (10 \\cdot 10) + (11 \\cdot 11) + (12 \\cdot 12) \\\\\n&= 1 + 6 + 15 + 24 + 20 + 12 + 49 + 64 + 81 + 100 + 121 + 144 \\\\\n&= 637\n\\end{align*}\n$$\nThe value of $S$ is $637$.",
            "answer": "$$\\boxed{637}$$"
        },
        {
            "introduction": "Syntax-directed definitions are powerful tools for more than just calculating expression values; they can model complex computational processes. This problem challenges you to design and apply an SDD that simulates the behavior of a stack during the evaluation of a postfix expression, tracking not only the final result but also the stack's height throughout the process . This advanced practice demonstrates the expressive power of combining inherited and synthesized attributes to manage and pass state information across a parse tree, integrating design, dependency analysis, and evaluation tracing to solve a non-trivial modeling problem.",
            "id": "3641102",
            "problem": "Consider postfix expressions over binary operators generated by the context-free grammar\n$$E \\to E\\;E\\;op \\quad\\mid\\quad num,$$\n$$op \\to + \\;\\mid\\; - \\;\\mid\\; * \\;\\mid\\; /.$$\nDesign a Syntax-Directed Definition (SDD) for this grammar that models evaluation by a single conceptual stack. Your SDD must include one inherited attribute $H_{in}$ (the stack height on entry to evaluating a subtree) and two synthesized attributes $H_{out}$ (the stack height on exit) and $H_{max}$ (the maximum stack height encountered during evaluation of a subtree). The semantic intention is that encountering a terminal $num$ causes one push, and encountering a terminal $op$ causes two pops followed by one push of the resulting value. Construct the attribute equations so that the resulting dependency graph is acyclic and the natural evaluation schedule is a topological order that mirrors the stack discipline: evaluate the left operand subtree, then the right operand subtree, then apply the operator.\n\nUsing the schedule implied by your SDD and the induced dependency graph, evaluate the following concrete postfix input (tokens are space-separated):\n$$3\\;\\;14\\;\\;+\\;\\;2\\;\\;7\\;\\;*\\;\\;9\\;\\;+\\;\\;1\\;\\;-\\;\\;5\\;\\;4\\;\\;+\\;\\;*\\;\\;6\\;\\;8\\;\\;+\\;\\;/\\;\\;*.$$\nInitialize the inherited attribute at the start with $H_{in}=0$. Under the topologically ordered schedule that respects attribute dependencies, determine the single number equal to the maximum stack height encountered during the complete evaluation of the input. Provide only this number as your final answer, with no units and no rounding required.",
            "solution": "### Step 1: Syntax-Directed Definition (SDD) Design\nBased on the problem description, we formulate the semantic rules for the attributes for each production in the grammar. The goal is to track stack height during a postfix evaluation.\n\n**For production $E \\to num$:**\nThis rule corresponds to pushing a number onto the stack. The stack height increases by one.\n- $E.H_{out} = E.H_{in} + 1$\n- $E.H_{max} = E.H_{in} + 1$\n\n**For production $E \\to E_1 E_2 op$:**\nThis rule corresponds to evaluating a left subexpression ($E_1$), then a right subexpression ($E_2$), and finally applying an operator which performs two pops and one push (a net change of $-1$ in stack height).\n- $E_1.H_{in} = E.H_{in}$ (The stack height for $E_1$ is the entry height for $E$.)\n- $E_2.H_{in} = E_1.H_{out}$ (The evaluation of $E_2$ starts after $E_1$ completes.)\n- $E.H_{out} = E_2.H_{out} - 1$ (After $E_2$ completes, the operator is applied.)\n- $E.H_{max} = \\max(E_1.H_{max}, E_2.H_{max})$ (The operator application reduces height, so the maximum height must have been reached during the evaluation of one of the children.)\n\n### Step 2: Evaluation of the Input Expression\nWe apply the SDD to the parse tree for the input expression. The evaluation proceeds as a single depth-first traversal of the tree, starting with $H_{in}=0$ at the root. We can determine the final result by simulating the stack operations, which directly corresponds to the attribute evaluation process.\n\n- Initial state: Stack `[]`, height $0$. Max height so far: $0$.\n- `3`: push, stack height becomes $1$. Max height: $1$.\n- `14`: push, stack height becomes $2$. Max height: $2$.\n- `+`: pop, pop, push. Stack height becomes $1$.\n- `2`: push, stack height becomes $2$.\n- `7`: push, stack height becomes $3$. Max height: $3$.\n- `*`: pop, pop, push. Stack height becomes $2$.\n- `9`: push, stack height becomes $3$.\n- `+`: pop, pop, push. Stack height becomes $2$.\n- `1`: push, stack height becomes $3$.\n- `-`: pop, pop, push. Stack height becomes $2$.\n- `5`: push, stack height becomes $3$.\n- `4`: push, stack height becomes $4$. Max height: $4$.\n- `+`: pop, pop, push. Stack height becomes $3$.\n- `*`: pop, pop, push. Stack height becomes $2$.\n- `6`: push, stack height becomes $3$.\n- `8`: push, stack height becomes $4$. (The max height of $4$ is reached again but not exceeded).\n- `+`: pop, pop, push. Stack height becomes $3$.\n- `/`: pop, pop, push. Stack height becomes $2$.\n- `*`: pop, pop, push. Stack height becomes $1$.\n\nThe highest stack height encountered during this process is the maximum of all intermediate maximums. The trace shows that the stack height reaches a peak of $4$. In the context of the SDD, this means the $H_{max}$ attribute for the root of the entire expression's parse tree would be computed as $4$.",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}