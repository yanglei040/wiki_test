{
    "hands_on_practices": [
        {
            "introduction": "编译器如何知道一个变量在使用前是否已被初始化？这是一项基本的静态分析检查。本练习将指导你设计一个 L-属性定义，在处理一系列语句时跟踪已初始化变量的集合。你将使用一个继承属性将此信息从一条语句传递到下一条语句，从而展示一种强大的数据流分析技术。",
            "id": "3669020",
            "problem": "给定以下包含表达式的语句序列语法：\n- $S \\to \\mathrm{id} = E ; S \\mid \\mathrm{print}(E) ; S \\mid \\epsilon$\n- $E \\to E + T \\mid T$\n- $T \\to T \\times F \\mid F$\n- $F \\to \\mathrm{id} \\mid \\mathrm{num} \\mid (E)$\n\n从属性语法的基础定义出发：一个 $L$-属性定义是指，对于每个产生式，右侧符号的每个继承属性仅依赖于产生式头部的继承属性以及其右侧左边符号的属性。利用此原则设计一个 $L$-属性定义，以强制执行“每个变量的使用必须在其从左到右的语句顺序中被初始化”这一静态语义属性。这通过将一个已初始化标识符的继承集合沿着语法分析树向下传递，并综合一个未初始化使用次数的整数计数来实现。\n\n设计约束：\n- 在 $S$、$E$、$T$ 和 $F$ 上引入一个继承属性 $\\,\\mathrm{InSet}\\,$，表示进入该构造时已知的已初始化标识符集合。\n- 在 $S$、$E$、$T$ 和 $F$ 上引入一个综合属性 $\\,\\mathrm{OutSet}\\,$，表示退出该构造时已知的已初始化标识符集合。\n- 在 $S$、$E$、$T$ 和 $F$ 上引入一个综合属性 $\\,\\mathrm{Err}\\,$，表示在该构造内检测到的未初始化标识符使用次数的计数。\n- 确保任何右侧符号的 $\\,\\mathrm{InSet}\\,$ 仅依赖于产生式头部的继承属性和左兄弟的属性，从而使您的定义是 $L$-属性的。\n\n假设在顶层开始符号处，初始的已初始化标识符集合为空，即 $\\,\\mathrm{InSet}(S_{\\mathrm{start}}) = \\varnothing$。\n\n现在考虑以下具体的语句序列（它与上述语法匹配）：\n$\\;a = b + 1 \\ ; \\ \\mathrm{print}( \\, a + c \\, ) \\ ; \\ b = a + 2 \\ ; \\ \\mathrm{print}( \\, b + d \\, ) \\ ; \\ \\mathrm{print}( \\, ( e ) + ( f + 3 ) \\, ) \\ ; \\ g = 0 \\ ; \\ \\mathrm{print}( \\, g + a \\, ) \\ ;$\n\n使用您的 $L$-属性定义，评估此序列语法分析树根节点的综合属性 $\\,\\mathrm{Err}\\,$，即计算在这些规则下检测到的未初始化标识符使用的总数。请用一个整数表示您的最终答案。不需要四舍五入，也不涉及单位。",
            "solution": "该问题是有效的，因为它科学地基于编译器理论的原理，问题陈述清晰，并且客观地进行了阐述。它提出了一个语法指导翻译中的标准任务：设计并应用属性语法来执行静态分析。所有必要的组成部分——上下文无关语法、具体的语义约束、所需的属性以及初始条件——都已提供，并且它们内部是一致的。该问题是可形式化的，并要求严格应用既定的计算机科学原理。\n\n我们将首先按照规定构造 L-属性定义，为语法中的每个产生式定义用于计算属性 $\\mathrm{InSet}$、$\\mathrm{OutSet}$ 和 $\\mathrm{Err}$ 的语义规则。然后，我们将这些规则应用于给定的代码序列，以确定未初始化变量使用的总数。\n\n### L-属性定义设计\n\n语法由以下给出：\n- $S \\to \\mathrm{id} = E ; S \\mid \\mathrm{print}(E) ; S \\mid \\epsilon$\n- $E \\to E + T \\mid T$\n- $T \\to T \\times F \\mid F$\n- $F \\to \\mathrm{id} \\mid \\mathrm{num} \\mid (E)$\n\n我们为每个产生式定义语义规则。请注意，属性赋值由 `:=` 表示。\n\n**1. 产生式: $S_0 \\to \\mathrm{id} = E ; S_1$**\n该产生式模拟变量赋值。表达式 $E$ 在 $S_0$ 继承的上下文中求值。随后的语句序列 $S_1$ 在一个将 $\\mathrm{id}$ 视为已初始化的上下文中求值。\n- $E.\\mathrm{InSet} := S_0.\\mathrm{InSet}$\n- $S_1.\\mathrm{InSet} := E.\\mathrm{OutSet} \\cup \\{\\mathrm{id.name}\\}$\n- $S_0.\\mathrm{Err} := E.\\mathrm{Err} + S_1.\\mathrm{Err}$\n- $S_0.\\mathrm{OutSet} := S_1.\\mathrm{OutSet}$\n\n**2. 产生式: $S_0 \\to \\mathrm{print}(E) ; S_1$**\n该产生式打印一个表达式的值。它不初始化任何变量。\n- $E.\\mathrm{InSet} := S_0.\\mathrm{InSet}$\n- $S_1.\\mathrm{InSet} := E.\\mathrm{OutSet}$\n- $S_0.\\mathrm{Err} := E.\\mathrm{Err} + S_1.\\mathrm{Err}$\n- $S_0.\\mathrm{OutSet} := S_1.\\mathrm{OutSet}$\n\n**3. 产生式: $S \\to \\epsilon$**\n这是语句序列的终止。它不产生任何错误，并将其继承的已初始化变量集合作为其输出集合传递出去。\n- $S.\\mathrm{Err} := 0$\n- $S.\\mathrm{OutSet} := S.\\mathrm{InSet}$\n\n**4. 产生式: $E_0 \\to E_1 + T$**\n操作数从左到右求值。右操作数 $T$ 的上下文包含了左操作数 $E_1$ 的上下文。\n- $E_1.\\mathrm{InSet} := E_0.\\mathrm{InSet}$\n- $T.\\mathrm{InSet} := E_1.\\mathrm{OutSet}$\n- $E_0.\\mathrm{Err} := E_1.\\mathrm{Err} + T.\\mathrm{Err}$\n- $E_0.\\mathrm{OutSet} := T.\\mathrm{OutSet}$\n\n**5. 产生式: $E \\to T$**\n属性被直接传递。\n- $T.\\mathrm{InSet} := E.\\mathrm{InSet}$\n- $E.\\mathrm{Err} := T.\\mathrm{Err}$\n- $E.\\mathrm{OutSet} := T.\\mathrm{OutSet}$\n\n**6. 产生式: $T_0 \\to T_1 \\times F$**\n与加法类似，操作数从左到右求值。\n- $T_1.\\mathrm{InSet} := T_0.\\mathrm{InSet}$\n- $F.\\mathrm{InSet} := T_1.\\mathrm{OutSet}$\n- $T_0.\\mathrm{Err} := T_1.\\mathrm{Err} + F.\\mathrm{Err}$\n- $T_0.\\mathrm{OutSet} := F.\\mathrm{OutSet}$\n\n**7. 产生式: $T \\to F$**\n属性被直接传递。\n- $F.\\mathrm{InSet} := T.\\mathrm{InSet}$\n- $T.\\mathrm{Err} := F.\\mathrm{Err}$\n- $T.\\mathrm{OutSet} := F.\\mathrm{OutSet}$\n\n**8. 产生式: $F \\to \\mathrm{id}$**\n这是一个变量的使用。我们检查标识符的名称是否在已初始化变量的集合中。\n- $F.\\mathrm{Err} := \\begin{cases} 1  \\text{如果 } \\mathrm{id.name} \\notin F.\\mathrm{InSet} \\\\ 0  \\text{如果 } \\mathrm{id.name} \\in F.\\mathrm{InSet} \\end{cases}$\n- $F.\\mathrm{OutSet} := F.\\mathrm{InSet}$\n\n**9. 产生式: $F \\to \\mathrm{num}$**\n数字字面量总是有效的，不涉及变量。\n- $F.\\mathrm{Err} := 0$\n- $F.\\mathrm{OutSet} := F.\\mathrm{InSet}$\n\n**10. 产生式: $F \\to (E)$**\n括号只影响解析顺序；属性被传递过去。\n- $E.\\mathrm{InSet} := F.\\mathrm{InSet}$\n- $F.\\mathrm{Err} := E.\\mathrm{Err}$\n- $F.\\mathrm{OutSet} := E.\\mathrm{OutSet}$\n\n对于给定的表达式语法（$E, T, F$），此定义的一个重要属性是，没有表达式非终结符会初始化变量。因此，对于任何产生式，若 $X, Y \\in \\{E, T, F\\}$，则 $Y.\\mathrm{OutSet} = Y.\\mathrm{InSet}$。这意味着对于任何表达式非终结符 $X$，$X.\\mathrm{OutSet} = X.\\mathrm{InSet}$。这简化了 $\\mathrm{InSet}$ 属性的传播。例如，在 $S_0 \\to \\mathrm{print}(E); S_1$ 中，规则 $S_1.\\mathrm{InSet} := E.\\mathrm{OutSet}$ 简化为 $S_1.\\mathrm{InSet} := E.\\mathrm{InSet}$，而这又等于 $S_1.\\mathrm{InSet} := S_0.\\mathrm{InSet}$。\n\n### 输入序列的求值\n\n我们从 $\\mathrm{InSet} = \\varnothing$ 和总错误计数为 $0$ 开始，追踪给定序列的综合属性 $\\mathrm{Err}$ 的求值过程。\n\n**初始状态：**\n- $\\mathrm{InSet} = \\varnothing$\n- 总 $\\mathrm{Err} = 0$\n\n**1. 语句：`a = b + 1 ;`**\n- 表达式 `b + 1` 在 $\\mathrm{InSet} = \\varnothing$ 的情况下求值。\n- 检查标识符 $b$ 的使用：$b \\notin \\varnothing$。这是一个错误。\n- 数字 $1$ 的使用不会导致错误。\n- 此语句的 $\\mathrm{Err}$ 为：$1$。\n- 下一条语句的新状态：\n  - $\\mathrm{InSet} := \\varnothing \\cup \\{a\\} = \\{a\\}$\n  - 总 $\\mathrm{Err} := 0 + 1 = 1$\n\n**2. 语句：`print( a + c ) ;`**\n- 表达式 `a + c` 在 $\\mathrm{InSet} = \\{a\\}$ 的情况下求值。\n- $a$ 的使用：$a \\in \\{a\\}$。没有错误。\n- $c$ 的使用：$c \\notin \\{a\\}$。这是一个错误。\n- 此语句的 $\\mathrm{Err}$ 为：$1$。\n- 下一条语句的新状态：\n  - $\\mathrm{InSet}$ 保持为 $\\{a\\}$。\n  - 总 $\\mathrm{Err} := 1 + 1 = 2$\n\n**3. 语句：`b = a + 2 ;`**\n- 表达式 `a + 2` 在 $\\mathrm{InSet} = \\{a\\}$ 的情况下求值。\n- $a$ 的使用：$a \\in \\{a\\}$。没有错误。\n- 数字 $2$ 的使用：没有错误。\n- 此语句的 $\\mathrm{Err}$ 为：$0$。\n- 下一条语句的新状态：\n  - $\\mathrm{InSet} := \\{a\\} \\cup \\{b\\} = \\{a, b\\}$\n  - 总 $\\mathrm{Err} := 2 + 0 = 2$\n\n**4. 语句：`print( b + d ) ;`**\n- 表达式 `b + d` 在 $\\mathrm{InSet} = \\{a, b\\}$ 的情况下求值。\n- $b$ 的使用：$b \\in \\{a, b\\}$。没有错误。\n- $d$ 的使用：$d \\notin \\{a, b\\}$。这是一个错误。\n- 此语句的 $\\mathrm{Err}$ 为：$1$。\n- 下一条语句的新状态：\n  - $\\mathrm{InSet}$ 保持为 $\\{a, b\\}$。\n  - 总 $\\mathrm{Err} := 2 + 1 = 3$\n\n**5. 语句：`print( ( e ) + ( f + 3 ) ) ;`**\n- 表达式 `( e ) + ( f + 3 )` 在 $\\mathrm{InSet} = \\{a, b\\}$ 的情况下求值。\n- 在子表达式 `( e )` 中，$e$ 的使用：$e \\notin \\{a, b\\}$。这是一个错误。\n- 在子表达式 `( f + 3 )` 中，$f$ 的使用：$f \\notin \\{a, b\\}$。这是一个错误。\n- 此语句的 $\\mathrm{Err}$ 为：$1 + 1 = 2$。\n- 下一条语句的新状态：\n  - $\\mathrm{InSet}$ 保持为 $\\{a, b\\}$。\n  - 总 $\\mathrm{Err} := 3 + 2 = 5$\n\n**6. 语句：`g = 0 ;`**\n- 表达式 `0` 在 $\\mathrm{InSet} = \\{a, b\\}$ 的情况下求值。\n- 数字 `0` 的使用：没有错误。\n- 此语句的 $\\mathrm{Err}$ 为：$0$。\n- 下一条语句的新状态：\n  - $\\mathrm{InSet} := \\{a, b\\} \\cup \\{g\\} = \\{a, b, g\\}$\n  - 总 $\\mathrm{Err} := 5 + 0 = 5$\n\n**7. 语句：`print( g + a ) ;`**\n- 表达式 `g + a` 在 $\\mathrm{InSet} = \\{a, b, g\\}$ 的情况下求值。\n- $g$ 的使用：$g \\in \\{a, b, g\\}$。没有错误。\n- $a$ 的使用：$a \\in \\{a, b, g\\}$。没有错误。\n- 此语句的 $\\mathrm{Err}$ 为：$0$。\n- 下一条语句的新状态：\n  - $\\mathrm{InSet}$ 保持为 $\\{a, b, g\\}$。\n  - 总 $\\mathrm{Err} := 5 + 0 = 5$\n\n序列结束。语法分析树根节点的最终综合错误计数是所有语句的错误之和。\n\n检测到的未初始化使用有：$b$（语句1）、$c$（语句2）、$d$（语句4）、$e$（语句5）和 $f$（语句5）。\n\n未初始化标识符使用的总数为 $5$。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "编译器负责在内存中布局数据。本练习探讨如何为一系列数组声明计算内存地址。你将设计一个 L-属性定义，使用继承属性来传递“下一个可用内存地址”，并使用综合属性来计算每个声明数组的大小，完美地展示了这两种类型的属性如何协同工作以管理资源。",
            "id": "3669005",
            "problem": "考虑以下用于类 C 语言中静态大小数组的简化声明语法，该语言采用行主序、连续布局：\n- $S \\to L$\n- $L \\to L ; A \\mid A$\n- $A \\to \\text{id} \\; B$\n- $B \\to [N] B \\mid \\epsilon$\n\n此处，$\\text{id}$ 是一个标识符词法单元，$N$ 是一个整数字面量，给出数组一个维度的范围。在此片段中声明的所有数组都具有固定宽度为 $w$ 字节的基本元素类型。内存模型是一个单一的平坦地址空间，$L$ 中的声明按从左到右的顺序连续分配内存，没有间隙，并遵循行主序数组布局。\n\n你需要设计一个使用 L-属性文法 (AG) 的语法导向定义 (SDD)，以计算：\n- 对于每个 $A$，一个综合属性 $A.\\text{size}$，给出所声明数组占用的总字节数。\n- 对于每个 $A$，一个继承属性 $A.\\text{base}$，给出数组布局的起始字节地址。\n\n你的 SDD 必须满足 L-属性性质：产生式中任一符号的每个继承属性仅依赖于产生式头的属性以及其左侧符号的属性。你可以根据需要在 $S$、$L$ 和 $B$ 上引入属性，但你的规则必须保持 L-属性。\n\n仅使用继承和综合属性的核心定义、L-属性 SDD 的定义，以及行主序、连续数组布局将元素存储在单个内存块中的事实，通过在以下带有具体参数的输入上评估你的属性规则，来计算特定声明序列的具体基地址：\n- 元素宽度 $w = 8$ 字节。\n- 顶层的起始基地址为 $S.\\text{base} = 4096$ 字节。\n- 声明列表（带有隐式元素类型）是：\n  $$\n  \\text{id} = a \\; \\; \\text{with} \\; B = [3][5][4] \\; ; \\; \\text{id} = b \\; \\; \\text{with} \\; B = [7] \\; ; \\; \\text{id} = c \\; \\; \\text{with} \\; B = [2][2][2][2].\n  $$\n假设方括号中的每个 $N$ 都是所示的字面整数，元素寻址采用从零开始的索引语义（后一个事实对于计算大小不是必需的，但与布局模型一致）。将最终答案表示为按顺序分配声明后 $c.\\text{base}$ 的数值（以字节为单位）。最终地址以字节表示。不要在你的最终方框答案中包含任何单位。",
            "solution": "用户提供的问题已经过验证，并被确定为编译器设计领域中一个有效、良构的问题。它具有科学依据、内容自洽且客观。它提出了一个设计和应用语法导向定义（SDD）进行属性计算的标准任务。\n\n目标是为给定文法设计一个 L-属性 SDD，以计算所声明数组的大小和基地址，然后使用此 SDD 在给定的声明序列中找到特定数组 `c` 的基地址。\n\n### 第 1 部分：语法导向定义 (SDD) 设计\n\n文法如下：\n$S \\to L$\n$L \\to L ; A \\mid A$\n$A \\to \\text{id} \\; B$\n$B \\to [N] B \\mid \\epsilon$\n\n元素类型宽度是一个常量 $w$。我们需要计算一个综合属性 $A.\\text{size}$ 和一个继承属性 $A.\\text{base}$。该 SDD 必须是 L-属性的。\n\n首先，我们设计属性和规则来计算数组的大小。数组的大小是其各维度范围的乘积再乘以基本元素宽度 $w$。这表明需要为非终结符 $B$ 设计一个综合属性，用于计算维度范围的乘积。\n\n设 $N.\\text{val}$ 为词法单元 $N$ 的综合属性，表示其整数值。\n设 $B$ 有一个综合属性 $B.\\text{numelems}$，表示由 $B$ 定义的数组结构中基本元素的总数。\n\n计算 $B.\\text{numelems}$ 的规则如下：\n- 对于产生式 $B \\to \\epsilon$，它终止了维度列表，此时我们处于单个元素的层面。\n  - $B.\\text{numelems} \\leftarrow 1$\n- 对于产生式 $B \\to [N] \\; B_1$，元素数量是当前维度的范围乘以剩余维度中的元素数量。\n  - $B.\\text{numelems} \\leftarrow N.\\text{val} \\times B_1.\\text{numelems}$\n\n计算出 $B.\\text{numelems}$ 后，就可以计算由 $A$ 声明的数组的总大小。\n设 $A$ 有一个综合属性 $A.\\text{size}$。\n- 对于产生式 $A \\to \\text{id} \\; B$：\n  - $A.\\text{size} \\leftarrow B.\\text{numelems} \\times w$\n\n接下来，我们设计属性和规则来管理基地址。地址从左到右连续分配。这需要将下一个可用地址从一个声明传递到下一个声明，这是 L-属性定义中继承属性的经典用例。\n\n设 $S$、$L$、$A$ 有一个继承属性，表示为 `base`。\n设 $L$ 还有一个综合属性 `size`，表示其列表中声明所占用的总内存。\n\n完整的 L-属性 SDD 如下：\n\n1.  **产生式：$S \\to L$**\n    此产生式初始化整个过程。整个声明列表 $L$ 的起始基地址由顶层符号 $S$ 提供。\n    - $L.\\text{base} \\leftarrow S.\\text{base}$\n\n2.  **产生式：$L \\to L_1 ; A$**\n    这是声明列表的递归规则。文法是左递归的，因此分析树将是左深的。\n    - $L_1.\\text{base} \\leftarrow L.\\text{base}$\n      （子列表 $L_1$ 与完整列表 $L$ 在相同的地址开始。）\n    - $A.\\text{base} \\leftarrow L_1.\\text{base} + L_1.\\text{size}$\n      （声明 $A$ 紧跟在为子列表 $L_1$ 分配的内存块之后开始。这是 L-属性的，因为 $A.\\text{base}$ 依赖于其左侧符号 $L_1$ 的属性。）\n    - $L.\\text{size} \\leftarrow L_1.\\text{size} + A.\\text{size}$\n      （列表 $L$ 的总大小是其各部分大小之和。）\n\n3.  **产生式：$L \\to A$**\n    这是声明列表的基本情况。\n    - $A.\\text{base} \\leftarrow L.\\text{base}$\n      （单个声明 $A$ 获得传递给列表 $L$ 的基地址。）\n    - $L.\\text{size} \\leftarrow A.\\text{size}$\n      （列表的总大小就是单个声明的大小。）\n\n4.  **产生式：$A \\to \\text{id} \\; B$**\n    - $A.\\text{size} \\leftarrow B.\\text{numelems} \\times w$\n      （如前定义。注意 $A.\\text{base}$ 是继承的，但在右侧的任何规则中都没有使用；它是此子树的终结属性，表示此特定标识符的最终计算地址。）\n\n5.  **产生式：$B \\to [N] \\; B_1$**\n    - $B.\\text{numelems} \\leftarrow N.\\text{val} \\times B_1.\\text{numelems}$\n\n6.  **产生式：$B \\to \\epsilon$**\n    - $B.\\text{numelems} \\leftarrow 1$\n\n此 SDD 是 L-属性的，因为在唯一涉及“横向”依赖的规则（$A.\\text{base} \\leftarrow L_1.\\text{base} + L_1.\\text{size}$）中，一个符号（$A$）的继承属性仅依赖于其左侧符号（$L_1$）的属性。所有其他继承属性仅依赖于父节点的继承属性。\n\n### 第 2 部分：针对特定输入的求值\n\n我们已知：\n- 元素宽度 $w = 8$ 字节。\n- 起始基地址 $S.\\text{base} = 4096$ 字节。\n- 声明列表：`a[3][5][4] ; b[7] ; c[2][2][2][2]`\n\n左递归文法 $L \\to L ; A$ 意味着该列表被解析为 `( (a[3][5][4]) ; b[7] ) ; c[2][2][2][2]`。我们将通过遍历相应的分析树来评估属性。\n\n**步骤 1：计算每个声明 `a`、`b` 和 `c` 的大小。**\n\n- **对于 `a[3][5][4]`：** 设此为声明 $A_a$。\n  - `a` 的非终结符 $B$ 展开为 `[3][5][4]`。\n  - $B_a.\\text{numelems} = 3 \\times 5 \\times 4 \\times 1 = 60$。\n  - $A_a.\\text{size} = B_a.\\text{numelems} \\times w = 60 \\times 8 = 480$。\n\n- **对于 `b[7]`：** 设此为声明 $A_b$。\n  - `b` 的非终结符 $B$ 展开为 `[7]`。\n  - $B_b.\\text{numelems} = 7 \\times 1 = 7$。\n  - $A_b.\\text{size} = B_b.\\text{numelems} \\times w = 7 \\times 8 = 56$。\n\n- **对于 `c[2][2][2][2]`：** 设此为声明 $A_c$。\n  - `c` 的非终结符 $B$ 展开为 `[2][2][2][2]`。\n  - $B_c.\\text{numelems} = 2 \\times 2 \\times 2 \\times 2 \\times 1 = 16$。\n  - $A_c.\\text{size} = B_c.\\text{numelems} \\times w = 16 \\times 8 = 128$。\n\n**步骤 2：使用 SDD 规则计算基地址。**\n\n分析树结构为 $L^{(0)} \\to L^{(1)} ; A_c$，其中 $L^{(1)} \\to L^{(2)} ; A_b$，且 $L^{(2)} \\to A_a$。\n\n1.  **对继承属性进行自顶向下遍历：**\n    - 在根节点，$S \\to L^{(0)}$，规则 $L^{(0)}.\\text{base} \\leftarrow S.\\text{base}$ 给出 $L^{(0)}.\\text{base} = 4096$。\n    - 在节点 $L^{(0)} \\to L^{(1)} ; A_c$，规则 $L_1.\\text{base} \\leftarrow L.\\text{base}$ 给出 $L^{(1)}.\\text{base} \\leftarrow L^{(0)}.\\text{base}$，因此 $L^{(1)}.\\text{base} = 4096$。\n    - 在节点 $L^{(1)} \\to L^{(2)} ; A_b$，规则 $L_2.\\text{base} \\leftarrow L_1.\\text{base}$ 给出 $L^{(2)}.\\text{base} \\leftarrow L^{(1)}.\\text{base}$，因此 $L^{(2)}.\\text{base} = 4096$。\n\n2.  **自底向上和从左到右的综合/继承属性求值：**\n    - 在节点 $L^{(2)} \\to A_a$，我们为第一个声明 `a` 求值属性。\n      - $A_a.\\text{base} \\leftarrow L^{(2)}.\\text{base}$，因此 $A_a.\\text{base} = 4096$。\n      - $L^{(2)}.\\text{size} \\leftarrow A_a.\\text{size}$，因此 $L^{(2)}.\\text{size} = 480$。\n    - 现在我们向上/向右移动到节点 $L^{(1)} \\to L^{(2)} ; A_b$。我们已经计算了 $L^{(2)}$ 的属性。现在我们可以计算 $A_b$ 的属性。\n      - $A_b.\\text{base} \\leftarrow L^{(2)}.\\text{base} + L^{(2)}.\\text{size} = 4096 + 480 = 4576$。\n      - $L^{(1)}.\\text{size} \\leftarrow L^{(2)}.\\text{size} + A_b.\\text{size} = 480 + 56 = 536$。\n    - 最后，我们向上/向右移动到节点 $L^{(0)} \\to L^{(1)} ; A_c$。我们已经计算了 $L^{(1)}$ 的属性。现在我们可以计算 $A_c$ 所需的属性。\n      - $A_c.\\text{base} \\leftarrow L^{(1)}.\\text{base} + L^{(1)}.\\text{size} = 4096 + 536 = 4632$。\n\n数组 `c` 的基地址，在问题中表示为 $c.\\text{base}$，但在我们的推导中对应于 $A_c.\\text{base}$，是 $4632$。\n\n这个结果可以通过直观的方式验证：\n- `a` 的分配从地址 $4096$ 开始。它占用 $480$ 字节。下一个可用地址是 $4096 + 480 = 4576$。\n- `b` 的分配从地址 $4576$ 开始。它占用 $56$ 字节。下一个可用地址是 $4576 + 56 = 4632$。\n- `c` 的分配从地址 $4632$ 开始。这与形式化 SDD 评估的结果相符。",
            "answer": "$$\\boxed{4632}$$"
        },
        {
            "introduction": "类型检查通常依赖于上下文。例如，数组索引必须是整数类型。本实践侧重于使用继承属性来强制执行此类上下文约束。你将定义规则，其中语法分析树中的父节点将“期望类型”向下传递给子节点，以确保用作数组索引的表达式具有正确的类型。这展示了 L-属性定义如何处理 S-属性定义无法处理的上下文相关检查。",
            "id": "3668987",
            "problem": "考虑上下文无关文法 $E \\to \\text{id}\\,[E] \\mid \\text{id}$，其中输入中每次出现的 $\\text{id}$ 都是一个特定的标识符，其声明类型从符号表中获取。使用语法制导定义 (SDD) 和 L-属性定义的框架：如果一个节点的所有继承属性都可以根据其父节点的属性和其左侧兄弟节点的属性来计算，那么该 SDD 就是 L-属性的，这确保了沿着每个产生式右侧进行单次从左到右的遍历就足以计算继承属性。\n\n你需要设计一些属性，使用单个继承属性 $E.\\text{expect}$ 来检查数组索引的类型。当 $E$ 作为索引时，该属性必须设置为 $\\text{int}$。这些属性是：\n- 一个继承属性 $E.\\text{expect}$，其取值范围为 $\\{\\text{int}\\}$ 或特殊值 $\\bot$，表示“无约束”。\n- 一个综合属性 $E.\\text{type}$，其取值范围为 $\\{\\text{int}, \\text{float}, \\text{array}(\\text{int}), \\text{array}(\\text{float}), \\text{err}\\}$，其中 $\\text{err}$ 表示为方便起见而传播的类型错误。\n- 一个综合属性 $E.\\text{errors}$，一个非负整数，用于统计类型冲突的数量。\n\n预期的属性规则（将被证明是 L-属性的）如下：\n\n对于产生式 $E \\to \\text{id}$：\n- $E.\\text{type} := \\text{decl}(\\text{id})$，\n- $E.\\text{errors} := 0$，\n- 如果 $E.\\text{expect} = \\text{int}$ 且 $E.\\text{type} \\neq \\text{int}$，则在需要此期望的使用点记录一次冲突（见下文）；此规则不在此处记录。\n\n对于产生式 $E \\to \\text{id}\\,[E_1]$：\n- 在分析 $E_1$ 之前，设置 $E_1.\\text{expect} := \\text{int}$。\n- 在 $E_1$ 被分析后，定义两个局部检查：\n  - 如果 $\\text{decl}(\\text{id})$ 不具有 $\\text{array}(\\tau)$ 的形式（其中 $\\tau \\in \\{\\text{int}, \\text{float}\\}$），则 $\\text{errNonArray} := 1$；否则 $\\text{errNonArray} := 0$。\n  - 如果 $E_1.\\text{type} \\neq \\text{int}$，则 $\\text{errBadIndex} := 1$；否则 $\\text{errBadIndex} := 0$。\n- 如果 $\\text{decl}(\\text{id}) = \\text{array}(\\tau)$（其中 $\\tau \\in \\{\\text{int}, \\text{float}\\}$），则设置 $E.\\text{type} := \\tau$；否则 $E.\\text{type} := \\text{err}$。\n- 设置 $E.\\text{errors} := E_1.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex}$。\n\n每当使用产生式 $E \\to \\text{id}\\,[E_1]$ 时，这些规则会检查两个独立的约束：左侧的 $\\text{id}$ 必须是一个数组，其右侧的索引表达式类型必须为 $\\text{int}$。继承属性 $E_1.\\text{expect}$ 以从左到右的方式强制执行该期望，并确保该设计是 L-属性的。\n\n现在考虑输入字符串 $A\\,[\\,B\\,[\\,C\\,[\\,D\\,]\\,]\\,]$，它属于该文法的语言，其 $\\text{id}$ 词素和声明类型由以下符号表给出\n- $\\text{decl}(A) = \\text{array}(\\text{float})$，\n- $\\text{decl}(B) = \\text{array}(\\text{int})$，\n- $\\text{decl}(C) = \\text{float}$，\n- $\\text{decl}(D) = \\text{array}(\\text{float})$。\n\n假设最外层的 $E$（整个输入）以 $E.\\text{expect} := \\bot$ 开始。仅使用上述属性方案和规则，在由文法导出的唯一分析树上计算所有属性，并计算树根处的类型冲突总数 $E.\\text{errors}$。\n\n请以单个整数形式给出最终答案。无需四舍五入，也无单位适用。所有符号、变量和数字都必须用 LaTeX 书写。",
            "solution": "用户希望我解决这个问题。我将首先验证问题陈述。\n\n### 第一步：提取已知信息\n- **文法**：$E \\to \\text{id}\\,[E] \\mid \\text{id}$\n- **符号表**：\n  - $\\text{decl}(A) = \\text{array}(\\text{float})$\n  - $\\text{decl}(B) = \\text{array}(\\text{int})$\n  - $\\text{decl}(C) = \\text{float}$\n  - $\\text{decl}(D) = \\text{array}(\\text{float})$\n- **输入字符串**：$A\\,[\\,B\\,[\\,C\\,[\\,D\\,]\\,]\\,]$\n- **属性**：\n  - 继承属性：$E.\\text{expect} \\in \\{\\text{int}, \\bot\\}$\n  - 综合属性：$E.\\text{type} \\in \\{\\text{int}, \\text{float}, \\text{array}(\\text{int}), \\text{array}(\\text{float}), \\text{err}\\}$\n  - 综合属性：$E.\\text{errors}$ (非负整数)\n- **初始条件**：对于分析树的根节点，$E.\\text{expect} := \\bot$。\n- **$E \\to \\text{id}$ 的属性规则**：\n  - $E.\\text{type} := \\text{decl}(\\text{id})$\n  - $E.\\text{errors} := 0$\n  - 注意到了对 $E.\\text{expect}$ 的条件检查，但错误由父产生式记录。\n- **$E \\to \\text{id}\\,[E_1]$ 的属性规则**：\n  1. $E_1.\\text{expect} := \\text{int}$\n  2. 如果 $\\text{decl}(\\text{id})$ 不具有 $\\text{array}(\\tau)$ 的形式，则 $\\text{errNonArray} := 1$；否则 $\\text{errNonArray} := 0$。\n  3. 如果 $E_1.\\text{type} \\neq \\text{int}$，则 $\\text{errBadIndex} := 1$；否则 $\\text{errBadIndex} := 0$。\n  4. 如果 $\\text{decl}(\\text{id}) = \\text{array}(\\tau)$，则 $E.\\text{type} := \\tau$；否则 $E.\\text{type} := \\text{err}$。\n  5. $E.\\text{errors} := E_1.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex}$。\n\n### 第二步：使用提取的已知信息进行验证\n- **科学依据**：该问题基于编译器设计的公认原则，特别是语法制导翻译、属性文法和类型检查。L-属性定义、继承属性和综合属性等概念是该领域的标准。\n- **适定性**：该问题提供了上下文无关文法、特定的输入字符串、完整的符号表和一整套属性求值规则。任务是通过应用这些规则计算一个特定值（总错误数）。对于给定的输入，该文法是无歧义的，从而产生唯一的分析树。规则是确定性的。因此，存在一个唯一且有意义的解。\n- **客观性**：该问题使用计算机科学和编译器理论中常见的形式化、精确的语言陈述。它没有歧义和主观断言。\n- **完整性和一致性**：提供了所有必要的信息。规则内部一致，互不矛盾。该框架确为 L-属性的，因为唯一的继承属性（$E_1.\\text{expect}$）是从父节点计算的，并且不依赖于其右侧的兄弟节点。\n\n### 第三步：结论与行动\n问题是有效的。将提供详细的解决方案。\n\n该问题要求在输入字符串 $A\\,[\\,B\\,[\\,C\\,[\\,D\\,]\\,]\\,]$ 的分析树上计算属性值。求值过程遵循 L-属性语法制导定义的原则，可以在对分析树进行深度优先遍历期间执行。\n\n首先，我们为输入字符串构建分析树。为清晰起见，我们标记非终结符节点：\n- $E_0 \\to \\text{id}_A\\,[\\,E_1\\,]$（树的根节点）\n- $E_1 \\to \\text{id}_B\\,[\\,E_2\\,]$\n- $E_2 \\to \\text{id}_C\\,[\\,E_3\\,]$\n- $E_3 \\to \\text{id}_D$\n\n属性求值通过深度优先遍历进行。继承属性沿树向下传递，综合属性在回溯时计算。\n\n**第一步：遍历到叶节点 $E_3$**\n- 遍历从根节点 $E_0$ 开始。初始条件是 $E_0.\\text{expect} := \\bot$。\n- 在节点 $E_0$（产生式 $E_0 \\to \\text{id}_A\\,[\\,E_1\\,]$），应用规则 $E_1.\\text{expect} := \\text{int}$。我们向下进入 $E_1$。\n- 在节点 $E_1$（产生式 $E_1 \\to \\text{id}_B\\,[\\,E_2\\,]$），$E_1.\\text{expect}$ 是 $\\text{int}$。应用规则 $E_2.\\text{expect} := \\text{int}$。我们向下进入 $E_2$。\n- 在节点 $E_2$（产生式 $E_2 \\to \\text{id}_C\\,[\\,E_3\\,]$），$E_2.\\text{expect}$ 是 $\\text{int}$。应用规则 $E_3.\\text{expect} := \\text{int}$。我们向下进入 $E_3$。\n\n**第二步：节点 $E_3$ 的属性求值（最内层表达式 `D`）**\n- 节点 $E_3$ 对应产生式 $E_3 \\to \\text{id}_D$。\n- 其继承属性为 $E_3.\\text{expect} = \\text{int}$。\n- 我们应用 $E \\to \\text{id}$ 的规则：\n  - $E_3.\\text{type} := \\text{decl}(\\text{id}_D) = \\text{array}(\\text{float})$。\n  - $E_3.\\text{errors} := 0$。对期望类型的检查由父节点处理。\n- $E_3$ 的综合属性为：$E_3.\\text{type} = \\text{array}(\\text{float})$ 和 $E_3.\\text{errors} = 0$。\n\n**第三步：节点 $E_2$ 的属性求值（表达式 `C[D]`）**\n- 节点 $E_2$ 对应产生式 $E_2 \\to \\text{id}_C\\,[\\,E_3\\,]$。我们已经得到了其子节点 $E_3$ 的综合属性。\n- 我们应用 $E \\to \\text{id}\\,[E_1]$ 的规则（其中 $E_2$ 作为 $E$，$E_3$ 作为 $E_1$）：\n  - 检查 $\\text{errNonArray}$：$\\text{decl}(\\text{id}_C) = \\text{float}$。这不具有 $\\text{array}(\\tau)$ 的形式。因此，$\\text{errNonArray} := 1$。\n  - 检查 $\\text{errBadIndex}$：$E_3.\\text{type} = \\text{array}(\\text{float})$，不等于 $\\text{int}$。因此，$\\text{errBadIndex} := 1$。\n  - 计算 $E_2.\\text{type}$：由于 $\\text{decl}(\\text{id}_C)$ 不是数组，所以 $E_2.\\text{type} := \\text{err}$。\n  - 计算 $E_2.\\text{errors}$：$E_2.\\text{errors} := E_3.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex} = 0 + 1 + 1 = 2$。\n- $E_2$ 的综合属性为：$E_2.\\text{type} = \\text{err}$ 和 $E_2.\\text{errors} = 2$。\n\n**第四步：节点 $E_1$ 的属性求值（表达式 `B[C[D]]`）**\n- 节点 $E_1$ 对应产生式 $E_1 \\to \\text{id}_B\\,[\\,E_2\\,]$。我们已经得到了其子节点 $E_2$ 的综合属性。\n- 我们应用 $E \\to \\text{id}\\,[E_1]$ 的规则（其中 $E_1$ 作为 $E$，$E_2$ 作为 $E_1$）：\n  - 检查 $\\text{errNonArray}$：$\\text{decl}(\\text{id}_B) = \\text{array}(\\text{int})$。这具有 $\\text{array}(\\tau)$ 的形式，其中 $\\tau = \\text{int}$。因此，$\\text{errNonArray} := 0$。\n  - 检查 $\\text{errBadIndex}$：$E_2.\\text{type} = \\text{err}$，不等于 $\\text{int}$。因此，$\\text{errBadIndex} := 1$。\n  - 计算 $E_1.\\text{type}$：由于 $\\text{decl}(\\text{id}_B) = \\text{array}(\\text{int})$，我们有 $\\tau = \\text{int}$。因此，$E_1.\\text{type} := \\text{int}$。\n  - 计算 $E_1.\\text{errors}$：$E_1.\\text{errors} := E_2.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex} = 2 + 0 + 1 = 3$。\n- $E_1$ 的综合属性为：$E_1.\\text{type} = \\text{int}$ 和 $E_1.\\text{errors} = 3$。\n\n**第五步：节点 $E_0$ 的属性求值（根表达式 `A[B[C[D]]]`）**\n- 节点 $E_0$ 对应产生式 $E_0 \\to \\text{id}_A\\,[\\,E_1\\,]$。我们已经得到了其子节点 $E_1$ 的综合属性。\n- 我们应用 $E \\to \\text{id}\\,[E_1]$ 的规则（其中 $E_0$ 作为 $E$，$E_1$ 作为 $E_1$）：\n  - 检查 $\\text{errNonArray}$：$\\text{decl}(\\text{id}_A) = \\text{array}(\\text{float})$。这具有 $\\text{array}(\\tau)$ 的形式，其中 $\\tau = \\text{float}$。因此，$\\text{errNonArray} := 0$。\n  - 检查 $\\text{errBadIndex}$：$E_1.\\text{type} = \\text{int}$。这等于 $\\text{int}$。因此，$\\text{errBadIndex} := 0$。\n  - 计算 $E_0.\\text{type}$：由于 $\\text{decl}(\\text{id}_A) = \\text{array}(\\text{float})$，我们有 $\\tau = \\text{float}$。因此，$E_0.\\text{type} := \\text{float}$。\n  - 计算 $E_0.\\text{errors}$：$E_0.\\text{errors} := E_1.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex} = 3 + 0 + 0 = 3$。\n- 根节点 $E_0$ 的最终综合属性为：$E_0.\\text{type} = \\text{float}$ 和 $E_0.\\text{errors} = 3$。\n\n类型冲突的总数是分析树根节点处 $E.\\text{errors}$ 属性的值，即 $3$。检测到的错误是：\n$1$。在 $C[D]$ 处，$C$ 不是数组（$\\text{errNonArray}=1$）。\n$2$。在 $C[D]$ 处，索引表达式 $D$ 的类型不是 $\\text{int}$（$\\text{errBadIndex}=1$）。\n$3$。在 $B[C[D]]$ 处，索引表达式 $C[D]$ 的类型不是 $\\text{int}$（$\\text{errBadIndex}=1$）。\n\n总错误数 = $0$（来自 $E_3$） $+ 2$（来自 $E_2$） $+ 1$（在 $E_1$ 处增加） $+ 0$（在 $E_0$ 处增加） = $3$。注意，错误是沿树向上累积的。根节点的值是总和。\n$E_2.\\text{errors} = E_3.\\text{errors} + 2 = 0+2=2$。\n$E_1.\\text{errors} = E_2.\\text{errors} + 1 = 2+1=3$。\n$E_0.\\text{errors} = E_1.\\text{errors} + 0 = 3+0=3$。\n\n类型冲突的总数是 $3$。",
            "answer": "$$\\boxed{3}$$"
        }
    ]
}