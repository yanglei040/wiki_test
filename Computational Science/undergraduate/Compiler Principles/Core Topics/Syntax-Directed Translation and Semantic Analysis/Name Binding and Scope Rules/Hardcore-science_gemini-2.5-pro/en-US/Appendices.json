{
    "hands_on_practices": [
        {
            "introduction": "This first practice bridges the gap between the abstract theory of static scope and its concrete runtime implementation. By analyzing a program with nested functions, you will trace how a compiler translates lexical nesting into a system of activation records, frame pointers, and static links to correctly access variables. This exercise  is fundamental to understanding how high-level scope rules are ultimately enforced at the machine level.",
            "id": "3658801",
            "problem": "Consider a statically scoped programming language with lexically nested functions and block-structured symbol tables. Assume the following well-tested compiler organization facts as the starting point: in static (lexical) scoping, a reference to an identifier resolves to the nearest lexically enclosing declaration; compilers maintain a symbol table per scope that maps identifiers to attributes; and code generation for nested scopes can use static links to access non-local variables residing in activation records. An Activation Record (AR) is a runtime stack frame for a procedure call; a Frame Pointer (FP) is a register holding the base address of the current AR; a Static Link (SL) is a pointer in an AR to the AR of the lexically enclosing scope; and a Dynamic Link (DL) is a pointer in an AR to the caller’s AR on the call chain.\n\nYou are given the following nested procedure structure, where identifiers have the types suggested by their uses. Numbers and offsets are provided for concreteness, and the language forbids implicit variable capture via dynamic scope:\n\n- Procedure $f$ is top-level (lexical level $0$). Inside $f$, a local variable $x$ is declared and initialized as $x := 0$.\n- Inside $f$, a nested procedure $g$ (lexical level $1$) is defined. Inside $g$, a new local variable $x$ is declared (this redeclares the name $x$ in $g$’s scope, shadowing $f$’s $x$) and initialized as $x := 7$. Inside $g$, another nested procedure $h$ (lexical level $2$) is defined.\n- Inside $h$, the body evaluates the expression $x + 1$ and returns it. No variable named $x$ is declared in $h$.\n\nAssume the following activation record layout conventions, used uniformly by the compiler:\n- The frame pointer for a procedure $p$ is denoted $FP_p$.\n- At offset $+0$ from $FP_p$ resides the Static Link (SL) pointer for $p$.\n- At offset $+8$ from $FP_p$ resides the Dynamic Link (DL) pointer for $p$.\n- Local variables of $p$ are allocated at fixed negative offsets from $FP_p$. In particular, inside $g$, the local variable $x$ is located at offset $-24$ from $FP_g$.\n\nAt a specific program point, suppose $f$ has called $g$, which in turn has called $h$. The following concrete runtime values hold:\n- $FP_f = 3000$,\n- $FP_g = 2000$,\n- $FP_h = 1000$,\n- The Static Link in $h$’s frame, located at address $FP_h + 0$, contains the value $FP_g$.\n\nTasks:\n1. Using only the fundamental definitions above (lexical scoping, symbol tables, and static links), determine which declaration of $x$ is referenced by each textual occurrence of $x$ in the bodies of $f$, $g$, and $h$.\n2. Construct the symbol table view at compile time across the three lexical levels, listing for each scope the binding for the identifier $x$ and its lexical level.\n3. Explain how the compiler, under static scoping, resolves the reference to $x$ inside $h$ and determines the number of static link traversals needed from $h$ to reach the defining scope of that $x$.\n4. Finally, using the activation record layout and the concrete runtime values provided, compute the exact runtime address that the compiled code for $h$ will use to load the correct $x$ for evaluating $x + 1$. Report this final address as a single integer. No rounding is required.\n\nYour final answer must be this single integer.",
            "solution": "The problem statement is valid. It is a well-posed problem grounded in the fundamental principles of compiler design, specifically concerning lexical scoping, symbol tables, and runtime memory management via activation records. All provided data and definitions are standard, self-contained, and consistent. We will proceed with a step-by-step solution.\n\nThe problem requires us to determine the runtime memory address of a variable `$x$` accessed from within a nested procedure `$h$`. This involves applying the rules of static (lexical) scoping at compile time to resolve the reference, and then simulating the runtime access mechanism using static links and frame pointers.\n\nLet the lexical nesting levels of the procedures `$f$`, `$g$`, and `$h$` be denoted by `$L_f = 0$`, `$L_g = 1$`, and `$L_h = 2$`, respectively.\n\n**Task 1: Identifier Resolution**\nThe language employs static scoping, where an identifier `$x$` resolves to the declaration found in the nearest lexically enclosing scope, searching outwards from the point of reference.\n-   A reference to `$x$` within the body of procedure `$f$` (level `$0$`) resolves to the local variable `$x$` declared in `$f$`.\n-   A reference to `$x$` within the body of procedure `$g$` (level `$1$`) resolves to the local variable `$x$` declared in `$g$`. This declaration shadows the `$x$` from the enclosing scope of `$f$`.\n-   A reference to `$x$` within the body of procedure `$h$` (level `$2$`) initiates a search. Scope `$h$` contains no declaration for `$x$`. The search proceeds to the immediate enclosing lexical scope, which is `$g$` (level `$1$`). Scope `$g$` contains a declaration for `$x$`. This is the nearest declaration, so the reference to `$x$` in `$h$` resolves to the variable `$x$` that is local to `$g$`.\n\n**Task 2: Compile-Time Symbol Table View**\nThe compiler constructs a symbol table for each lexical scope. The view across the nested structure is as follows:\n-   **Scope of `$f$` (Lexical Level `$0$`)**: Contains bindings for `$x$` (variable, declared at level `$0$`) and `$g$` (procedure, declared at level `$0$`).\n-   **Scope of `$g$` (Lexical Level `$1$`)**: Contains bindings for `$x$` (variable, declared at level `$1$`, shadowing `$f.x$`) and `$h$` (procedure, declared at level `$1$`).\n-   **Scope of `$h$` (Lexical Level `$2$`)**: Contains no local declaration for `$x$`.\n\n**Task 3: Compiler Resolution and Static Link Traversal**\nWhen the compiler encounters the expression `$x + 1$` within procedure `$h$`, it resolves the identifier `$x$` as described in Task 1. It determines that the `$x$` being used is the one declared in the scope of `$g$`.\n\nTo generate the code for accessing this non-local variable, the compiler calculates the difference in lexical nesting depths between the scope of use and the scope of declaration:\n$$\n\\text{Lexical Distance} = L_{\\text{use}} - L_{\\text{declaration}} = L_h - L_g = 2 - 1 = 1\n$$\nThis lexical distance of `$1$` informs the compiler that at runtime, the machine code must traverse exactly one static link to move from the activation record (AR) of the current procedure (`$h$`) to the AR of the procedure where `$x$` is defined (`$g$`). The compiler also associates the identifier `$x$` with its known offset, `$-24$`, within its defining frame (`$g$`'s frame).\n\n**Task 4: Runtime Address Computation**\nWe now compute the final memory address of `$x$` using the provided runtime values. The program is executing inside `$h$`, so the current frame pointer is `$FP_h = 1000$`.\n\n1.  **Identify the starting point**: The access begins from the current activation record, whose base address is given by the current frame pointer, `$FP_h = 1000$`.\n\n2.  **Traverse the static link chain**: Based on the compile-time analysis (Task 3), we must traverse `$1$` static link. The static link for the current frame (`$h$`'s frame) points to the frame of its lexical parent (`$g$`'s frame). The location of this static link pointer within `$h$`'s AR is given by `$FP_h + \\text{offset}_{\\text{SL}}$`. The problem specifies the offset of the Static Link (SL) is `$0$`.\n$$\n\\text{Address of SL in } h\\text{'s frame} = FP_h + 0 = 1000 + 0 = 1000\n$$\nThe value stored at this address is the static link itself, which is the frame pointer of the enclosing scope, `$FP_g$`. The problem states this value is `$FP_g = 2000$`. So, by loading the value from address `$1000$`, we obtain `$FP_g = 2000$`. This completes the traversal.\n\n3.  **Calculate the final address**: We have now reached the frame pointer of the scope where `$x$` is defined, `$FP_g = 2000$`. The variable `$x$` is stored at a fixed offset relative to this frame pointer. The problem specifies this offset is `$-24$`.\nThe final address of `$x$` is therefore:\n$$\n\\text{Address of } x = FP_g + \\text{offset}_x = 2000 + (-24) = 2000 - 24 = 1976\n$$\nThus, the compiled code for `$h$` will access memory address `$1976$` to load the value of `$x$`.",
            "answer": "$$\n\\boxed{1976}\n$$"
        },
        {
            "introduction": "Theory is best solidified by putting it into practice, and this exercise challenges you to build a core component of a compiler's front end. You will implement the lexical addressing algorithm, which translates symbolic variable names into numerical $(\\ell, o)$ pairs representing scope depth and offset. This hands-on coding task  demystifies name resolution by requiring you to construct the very data structures and logic that a real compiler uses to enforce static scoping.",
            "id": "3658713",
            "problem": "You are asked to implement lexical addressing for identifiers in a statically scoped language model, focusing on name binding and scope rules. Under lexical scoping, the binding of an identifier is determined by the nearest enclosing declaration in the program’s textual structure, independent of runtime call paths. The lexical address of a variable occurrence is the pair $(\\ell, o)$ where $\\ell$ is the number of static link traversals from the current lexical environment to the environment containing the declaration, and $o$ is the offset of the identifier within that environment recorded in order of declarations. The offset count begins at $0$ for the first declaration in a given lexical environment and increments by $1$ for each subsequent declaration in that same environment.\n\nFundamental base for this task:\n- Static scoping associates each identifier use with the closest lexically enclosing declaration, forming a compile-time environment stack of frames. Each frame maintains the ordered sequence of its declarations and is pushed on entering a new block and popped on exiting that block.\n- A declaration introduces a new binding in the current frame. A use of identifier $x$ searches frames from the top (most recent) towards the bottom (least recent) to find the frame containing the declaration of $x$. If found, the address $(\\ell, o)$ is formed with $\\ell$ equal to the number of frame steps from the current frame to that found frame and $o$ equal to the declaration’s offset in that found frame. If not found, the use is unbound and is represented by the sentinel $(-1,-1)$.\n\nYou must write a complete, runnable program that constructs lexical addresses by replacing each use of the identifier $x$ with $(\\ell, o)$ pairs. Frames are manipulated by a sequence of events defined as follows:\n- “begin” (`B`): push a new empty frame onto the environment stack.\n- “end” (`E`): pop the top frame from the environment stack.\n- “declare” (`D(v)`): declare identifier $v$ in the current frame, assigning it the next available offset in that frame. Within a single frame, all declared names must be distinct.\n- “use” (`U(v)`): perform a lookup for identifier $v$. For this task, correctness is verified only for $v = x$, but declarations may include other names.\n\nDefinitions and constraints:\n- The lexical environment is a stack of frames. Let the current depth be the number of frames currently on the stack. The maximum nested scope depth $d$ for a sequence is the maximum value of the current depth encountered during processing the sequence.\n- The lexical address of a use of $x$ is $(\\ell, o)$ as defined above. An unbound use yields $(-1,-1)$.\n- All declarations in a single frame must be unique. Redeclaration of the same name within a single frame is disallowed.\n- The search for a binding on `U(x)` proceeds from the current frame to older frames in order.\n\nTest suite:\nFor each test case, you are provided a sequence of events and the expected maximum nested scope depth $d$. Your program should compute the sequence of $(\\ell, o)$ pairs for all occurrences of `U(x)` in that sequence and verify that they match the expected pairs for that test case. Additionally, your program should verify that the computed maximum depth equals the provided $d$. For each test case, produce a boolean result: $1$ if both the sequence of pairs and the maximum depth match, and $0$ otherwise.\n\nTest Case $1$ (happy path with overshadowing and multiple nested scopes):\n- Sequence: [`B`, `D(a)`, `U(x)`, `B`, `D(x)`, `U(x)`, `B`, `D(b)`, `U(x)`, `E`, `U(x)`, `E`, `U(x)`, `E`]\n- Expected maximum depth $d$: $3$\n- Expected $(\\ell, o)$ pairs for `U(x)`: $[(-1,-1), (0,0), (1,0), (0,0), (-1,-1)]$\n\nTest Case $2$ (top-level declaration with inner overshadowing and non-zero offset):\n- Sequence: [`B`, `D(a)`, `D(x)`, `D(y)`, `U(x)`, `B`, `D(x)`, `U(x)`, `E`, `U(x)`, `E`]\n- Expected maximum depth $d$: $2$\n- Expected $(\\ell, o)$ pairs for `U(x)`: $[(0,1), (0,0), (0,1)]$\n\nTest Case $3$ (deep nesting without any declaration of $x$):\n- Sequence: [`B`, `B`, `D(a)`, `B`, `D(b)`, `B`, `U(x)`, `E`, `U(x)`, `E`, `U(x)`, `E`, `E`]\n- Expected maximum depth $d$: $4$\n- Expected $(\\ell, o)$ pairs for `U(x)`: $[(-1,-1), (-1,-1), (-1,-1)]$\n\nTest Case $4$ (outer declaration of $x$, inner overshadowing, and repeated lookups across scope boundaries):\n- Sequence: [`B`, `D(x)`, `B`, `D(a)`, `U(x)`, `B`, `D(x)`, `U(x)`, `E`, `U(x)`, `E`, `U(x)`, `E`]\n- Expected maximum depth $d$: $3$\n- Expected $(\\ell, o)$ pairs for `U(x)`: $[(1,0), (0,0), (1,0), (0,0)]$\n\nFinal output format:\nYour program should produce a single line of output containing the $4$ boolean results, in order for Test Cases $1$ through $4$, as a comma-separated list enclosed in square brackets (for example, $[1,0,1,1]$). No other text should be printed.\n\nYour implementation must be purely algorithmic and rely only on the formal definitions above. There are no physical units or angle units involved in this problem. All computations must be expressed in terms of the lexical environment and identifier binding rules as defined. The correctness criterion is universal across programming languages that implement static lexical scoping and environment stacks; your implementation must not rely on language-specific calling conventions or runtime behavior, as the task is fully compile-time reasoning.",
            "solution": "The problem requires the implementation and verification of a lexical addressing algorithm for a statically scoped language model. The core of the task is to process a sequence of events—scope entry (`B`), scope exit (`E`), declaration (`D(v)`), and use (`U(v)`)—and for each use of a specific identifier, $x$, compute its lexical address $(\\ell, o)$.\n\nThe lexical environment can be modeled as a stack of frames, where each frame corresponds to a lexical scope.\n- A **Frame** is a data structure that records the identifiers declared within its scope. Since the order of declarations determines the offset $o$, a simple ordered list or dynamic array is a suitable representation for the declarations within a frame.\n- The **Environment** is a stack of these frames. When a `begin` event occurs, a new, empty frame is pushed onto the stack. When an `end` event occurs, the top frame is popped.\n- The **Lexical Address** $(\\ell, o)$ is determined upon a `use` event for an identifier, say $x$.\n    - The lexical level, $\\ell$, is the number of scope levels one must traverse outwards from the current scope to find the scope where $x$ is declared. The current scope is at level $\\ell=0$, its immediate parent is at level $\\ell=1$, and so on. This corresponds to searching the frame stack from top to bottom. If the current frame is at index $i_{current}$ on the stack and the declaration is found in a frame at index $i_{found}$, then $\\ell = i_{current} - i_{found}$.\n    - The offset, $o$, is the zero-indexed position of the identifier's declaration within the list of declarations for its containing frame.\n\nThe algorithm proceeds as follows for each test case:\n1.  Initialize an empty environment stack.\n2.  Initialize a variable `max_depth` to $0$, which will track the maximum size the stack reaches.\n3.  Initialize a list to store the computed lexical addresses for each `U(x)` event.\n4.  Iterate through the given sequence of events:\n    a.  **`begin` (`B`)**: Push a new, empty frame onto the environment stack. The current depth is the new size of the stack. Update `max_depth = max(max_depth, current_depth)`.\n    b.  **`end` (`E`)**: Pop the top frame from the environment stack. All declarations within that frame are now out of scope.\n    c.  **`declare `D(v)``**: Add the identifier $v$ to the list of declarations in the current (topmost) frame. The offset $o$ assigned to this declaration is the number of declarations that were already in the frame.\n    d.  **`use `U(v)``**: If the identifier $v$ is the target identifier $x$, perform a lookup.\n        i.  Start with the current frame (top of the stack) at lexical level $\\ell = 0$.\n        ii. Search the declarations in this frame for $x$. If found at an offset $o$, the lexical address is $(\\ell, o)$. Record this pair and stop the search.\n        iii. If not found, move to the next frame down the stack (the parent scope), increment $\\ell$, and repeat the search.\n        iv. If the search reaches the bottom of the stack without finding a declaration for $x$, the identifier is unbound. Record the sentinel address $(-1, -1)$.\n5.  After processing all events, the test case is validated. The computed sequence of lexical addresses must exactly match the expected sequence, and the computed `max_depth` must equal the expected maximum depth $d$. If both conditions are met, the test case passes (result is $1$); otherwise, it fails (result is $0$).\n\nThis algorithm correctly formalizes the rules of static scoping and provides a deterministic method for computing lexical addresses. We will implement this a C program, managing the stack and frame data structures carefully.\n\nLet's trace Test Case 2 as an example:\n- Sequence: [`B`, `D(a)`, `D(x)`, `D(y)`, `U(x)`, `B`, `D(x)`, `U(x)`, `E`, `U(x)`, `E`]\n- Expected depth $d$: $2$\n- Expected pairs for `U(x)`: $[(0,1), (0,0), (0,1)]$\n\n1.  **Initial**: Stack: `[]`, Depth: $0$, `max_depth`: $0$, Pairs: `[]`\n2.  `B`: Push `F0`. Stack: `[F0{}]`. Depth: $1$. `max_depth`: $1$.\n3.  `D(a)`: Add 'a' to `F0`. `F0` becomes `{'a' @ 0}`.\n4.  `D(x)`: Add 'x' to `F0`. `F0` becomes `{'a' @ 0, 'x' @ 1}`.\n5.  `D(y)`: Add 'y' to `F0`. `F0` becomes `{'a' @ 0, 'x' @ 1, 'y' @ 2}`.\n6.  `U(x)`:\n    - Search `F0` ($\\ell=0$). Found 'x' at offset $o=1$.\n    - Add `(0, 1)` to pairs. Pairs: `[(0,1)]`.\n7.  `B`: Push `F1`. Stack: `[F0{...}, F1{}]`. Depth: $2$. `max_depth`: $2$.\n8.  `D(x)`: Add 'x' to `F1`. `F1` becomes `{'x' @ 0}`. (This is an overshadowing declaration).\n9.  `U(x)`:\n    - Search `F1` ($\\ell=0$). Found 'x' at offset $o=0$.\n    - Add `(0, 0)` to pairs. Pairs: `[(0,1), (0,0)]`.\n10. `E`: Pop `F1`. Stack: `[F0{...}]`. Depth: $1$.\n11. `U(x)`:\n    - Search `F0` ($\\ell=0$). Found 'x' at offset $o=1$.\n    - Add `(0, 1)` to pairs. Pairs: `[(0,1), (0,0), (0,1)]`.\n12. `E`: Pop `F0`. Stack: `[]`. Depth: $0$.\n\n**Final Check**:\n- Computed `max_depth`: $2$. Expected $d$: $2$. Match.\n- Computed Pairs: `[(0,1), (0,0), (0,1)]$. Expected Pairs: `[(0,1), (0,0), (0,1)]`. Match.\n- Result for Test Case 2: $1$.\n\nThis detailed procedure will be encapsulated in the C program.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n// Note: <complex.h>, <threads.h>, <stdatomic.h> are not needed for this problem.\n\n// Represents an event in the sequence.\ntypedef enum {\n    EV_BEGIN,\n    EV_END,\n    EV_DECLARE,\n    EV_USE\n} EventType;\n\ntypedef struct {\n    EventType type;\n    const char* id; // Identifier name for DECLARE and USE events.\n} Event;\n\n// Represents a lexical address pair (l, o).\ntypedef struct {\n    int l;\n    int o;\n} LexAddress;\n\n// Represents a single frame in the environment stack.\ntypedef struct {\n    char** declarations;\n    int count;\n    int capacity;\n} Frame;\n\n// Represents the environment stack.\ntypedef struct {\n    Frame* frames;\n    int top; // Index of the top frame, -1 if empty.\n    int capacity;\n} EnvironmentStack;\n\n// Represents a complete test case.\ntypedef struct {\n    const Event* sequence;\n    int seq_len;\n    int expected_max_depth;\n    const LexAddress* expected_pairs;\n    int pairs_len;\n} TestCase;\n\n// Initializes a new frame.\nvoid init_frame(Frame* frame) {\n    frame->capacity = 4; // Initial capacity for declarations.\n    frame->declarations = malloc(frame->capacity * sizeof(char*));\n    if (!frame->declarations) {\n        perror(\"Failed to allocate frame declarations\");\n        exit(EXIT_FAILURE);\n    }\n    frame->count = 0;\n}\n\n// Frees the memory used by a frame's declarations.\nvoid free_frame_declarations(Frame* frame) {\n    for (int i = 0; i < frame->count; ++i) {\n        free(frame->declarations[i]);\n    }\n    free(frame->declarations);\n    frame->declarations = NULL;\n    frame->count = 0;\n    frame->capacity = 0;\n}\n\n// Adds a declaration to a frame.\nvoid add_declaration(Frame* frame, const char* id) {\n    if (frame->count >= frame->capacity) {\n        frame->capacity *= 2;\n        char** new_decls = realloc(frame->declarations, frame->capacity * sizeof(char*));\n        if (!new_decls) {\n            perror(\"Failed to reallocate frame declarations\");\n            exit(EXIT_FAILURE);\n        }\n        frame->declarations = new_decls;\n    }\n    // strdup is used to store a mutable copy.\n    frame->declarations[frame->count++] = strdup(id);\n}\n\n// Initializes an environment stack.\nvoid init_stack(EnvironmentStack* stack) {\n    stack->capacity = 4; // Initial capacity for frames.\n    stack->frames = malloc(stack->capacity * sizeof(Frame));\n    if (!stack->frames) {\n        perror(\"Failed to allocate environment stack\");\n        exit(EXIT_FAILURE);\n    }\n    stack->top = -1;\n}\n\n// Frees all memory used by an environment stack.\nvoid free_stack(EnvironmentStack* stack) {\n    while (stack->top >= 0) {\n        free_frame_declarations(&stack->frames[stack->top--]);\n    }\n    free(stack->frames);\n    stack->frames = NULL;\n    stack->capacity = 0;\n}\n\n// Pushes a new frame onto the stack.\nvoid push_frame(EnvironmentStack* stack) {\n    stack->top++;\n    if (stack->top >= stack->capacity) {\n        stack->capacity *= 2;\n        Frame* new_frames = realloc(stack->frames, stack->capacity * sizeof(Frame));\n        if (!new_frames) {\n            perror(\"Failed to reallocate environment stack\");\n            exit(EXIT_FAILURE);\n        }\n        stack->frames = new_frames;\n    }\n    init_frame(&stack->frames[stack->top]);\n}\n\n// Pops a frame from the stack.\nvoid pop_frame(EnvironmentStack* stack) {\n    if (stack->top < 0) return;\n    free_frame_declarations(&stack->frames[stack->top]);\n    stack->top--;\n}\n\n// Performs a lookup for an identifier and returns its lexical address.\nLexAddress find_identifier(EnvironmentStack* stack, const char* id) {\n    for (int i = stack->top; i >= 0; --i) {\n        Frame* current_frame = &stack->frames[i];\n        for (int j = 0; j < current_frame->count; ++j) {\n            if (strcmp(current_frame->declarations[j], id) == 0) {\n                return (LexAddress){.l = stack->top - i, .o = j};\n            }\n        }\n    }\n    return (LexAddress){.l = -1, .o = -1};\n}\n\n// Runs a single test case and returns 1 if it passes, 0 otherwise.\nint run_test_case(const TestCase* test) {\n    EnvironmentStack stack;\n    init_stack(&stack);\n\n    LexAddress* computed_pairs = malloc(test->pairs_len * sizeof(LexAddress));\n    if (!computed_pairs) {\n        perror(\"Failed to allocate computed pairs array\");\n        exit(EXIT_FAILURE);\n    }\n\n    int computed_max_depth = 0;\n    int pairs_count = 0;\n    const char* target_id = \"x\";\n\n    for (int i = 0; i < test->seq_len; ++i) {\n        const Event* event = &test->sequence[i];\n        switch (event->type) {\n            case EV_BEGIN:\n                push_frame(&stack);\n                int current_depth = stack.top + 1;\n                if (current_depth > computed_max_depth) {\n                    computed_max_depth = current_depth;\n                }\n                break;\n            case EV_END:\n                pop_frame(&stack);\n                break;\n            case EV_DECLARE:\n                if (stack.top >= 0) {\n                    add_declaration(&stack.frames[stack.top], event->id);\n                }\n                break;\n            case EV_USE:\n                if (strcmp(event->id, target_id) == 0) {\n                    if (pairs_count < test->pairs_len) {\n                        computed_pairs[pairs_count++] = find_identifier(&stack, target_id);\n                    }\n                }\n                break;\n        }\n    }\n\n    int is_match = 1;\n    if (computed_max_depth != test->expected_max_depth) {\n        is_match = 0;\n    }\n    if (pairs_count != test->pairs_len) {\n        is_match = 0;\n    }\n    for (int i = 0; i < test->pairs_len && is_match; ++i) {\n        if (computed_pairs[i].l != test->expected_pairs[i].l || computed_pairs[i].o != test->expected_pairs[i].o) {\n            is_match = 0;\n        }\n    }\n\n    free(computed_pairs);\n    free_stack(&stack);\n    return is_match;\n}\n\nint main(void) {\n    // Test Case 1 Data\n    const Event seq1[] = {\n        {EV_BEGIN}, {EV_DECLARE, \"a\"}, {EV_USE, \"x\"}, {EV_BEGIN}, {EV_DECLARE, \"x\"}, {EV_USE, \"x\"},\n        {EV_BEGIN}, {EV_DECLARE, \"b\"}, {EV_USE, \"x\"}, {EV_END}, {EV_USE, \"x\"}, {EV_END}, {EV_USE, \"x\"}, {EV_END}\n    };\n    const LexAddress pairs1[] = { {-1,-1}, {0,0}, {1,0}, {0,0}, {-1,-1} };\n\n    // Test Case 2 Data\n    const Event seq2[] = {\n        {EV_BEGIN}, {EV_DECLARE, \"a\"}, {EV_DECLARE, \"x\"}, {EV_DECLARE, \"y\"}, {EV_USE, \"x\"}, {EV_BEGIN},\n        {EV_DECLARE, \"x\"}, {EV_USE, \"x\"}, {EV_END}, {EV_USE, \"x\"}, {EV_END}\n    };\n    const LexAddress pairs2[] = { {0,1}, {0,0}, {0,1} };\n\n    // Test Case 3 Data\n    const Event seq3[] = {\n        {EV_BEGIN}, {EV_BEGIN}, {EV_DECLARE, \"a\"}, {EV_BEGIN}, {EV_DECLARE, \"b\"}, {EV_BEGIN},\n        {EV_USE, \"x\"}, {EV_END}, {EV_USE, \"x\"}, {EV_END}, {EV_USE, \"x\"}, {EV_END}, {EV_END}\n    };\n    const LexAddress pairs3[] = { {-1,-1}, {-1,-1}, {-1,-1} };\n\n    // Test Case 4 Data\n    const Event seq4[] = {\n        {EV_BEGIN}, {EV_DECLARE, \"x\"}, {EV_BEGIN}, {EV_DECLARE, \"a\"}, {EV_USE, \"x\"}, {EV_BEGIN},\n        {EV_DECLARE, \"x\"}, {EV_USE, \"x\"}, {EV_END}, {EV_USE, \"x\"}, {EV_END}, {EV_USE, \"x\"}, {EV_END}\n    };\n    const LexAddress pairs4[] = { {1,0}, {0,0}, {1,0}, {0,0} };\n\n    TestCase test_cases[] = {\n        {seq1, sizeof(seq1)/sizeof(seq1[0]), 3, pairs1, sizeof(pairs1)/sizeof(pairs1[0])},\n        {seq2, sizeof(seq2)/sizeof(seq2[0]), 2, pairs2, sizeof(pairs2)/sizeof(pairs2[0])},\n        {seq3, sizeof(seq3)/sizeof(seq3[0]), 4, pairs3, sizeof(pairs3)/sizeof(pairs3[0])},\n        {seq4, sizeof(seq4)/sizeof(seq4[0]), 3, pairs4, sizeof(pairs4)/sizeof(pairs4[0])}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    for (int i = 0; i < num_cases; ++i) {\n        results[i] = run_test_case(&test_cases[i]);\n    }\n\n    printf(\"[%d,%d,%d,%d]\", results[0], results[1], results[2], results[3]);\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Modern languages rely heavily on anonymous functions, or 'lambdas', but the way they 'capture' variables from surrounding scopes can be a source of subtle bugs. This problem explores the classic 'closure in a loop' scenario, contrasting two distinct strategies for binding a loop variable. By predicting the program's output under each strategy , you will develop a crucial intuition for how binding semantics affect program behavior, particularly in asynchronous or functional code.",
            "id": "3658807",
            "problem": "Consider a pseudo-language with lexical scoping, nested blocks, and anonymous functions (lambdas). The following program enqueues lambdas for asynchronous execution after both loops complete. The program uses the same identifier for both loop indices:\nInitialize $N := 2$ and $M := 3$. Let $Q$ be an initially empty queue of tasks. Execute:\nfor ($i := 0$; $i < N$; $i := i + 1$) {\n    for ($i := 0$; $i < M$; $i := i + 1$) {\n        $Q.enqueue(\\lambda().\\, \\text{print}(i))$\n    }\n}\nAfter the loops terminate, drain $Q$ by executing all enqueued lambdas asynchronously in an unspecified order. Assume the runtime guarantees that any storage locations captured by a lambda remain valid at the time of execution.\n\nTwo distinct name-binding strategies are possible for the loop index declared as $i$:\n\n- Strategy $\\mathcal{B}_1$ (single-binding per loop): Each $for$ loop creates exactly one storage cell for its index identifier $i$, reused across all iterations of that loop. A lambda captures by reference the storage cell of the nearest lexically enclosing $i$ at the point of lambda creation.\n\n- Strategy $\\mathcal{B}_2$ (fresh-binding per iteration): Each $for$ loop creates a fresh storage cell for $i$ on every iteration (a per-iteration binding). A lambda captures by reference the storage cell of the nearest lexically enclosing $i$ created for that specific iteration.\n\nAssume lexical name resolution: inside the inner loop body, the unqualified identifier $i$ resolves to the inner loop’s $i$; the outer loop’s $i$ is shadowed. The asynchronous scheduler may execute tasks in any order, so only the multiset of observed printed values matters, not their order.\n\nWhich option correctly characterizes the multiset of values printed by the lambdas under both strategies $\\mathcal{B}_1$ and $\\mathcal{B}_2$ for the given $N$ and $M$?",
            "solution": "The problem requires analyzing the output of a program involving nested loops and closures under two different variable binding strategies for the loop index.\n\n**Analysis of Strategy $\\mathcal{B}_1$ (single-binding per loop):**\n1.  **Scope and Shadowing**: The program has nested `for` loops, both using the index variable `i`. Due to lexical scoping, the identifier `i` in the lambda's body, `print(i)`, resolves to the nearest enclosing declaration, which is the index variable of the inner loop. The outer loop's `i` is shadowed.\n2.  **Binding Mechanism**: Under Strategy $\\mathcal{B}_1$, the inner `for` loop declaration creates exactly one storage cell for its index `i`. This single cell is updated on each iteration of the inner loop. The lambda captures a *reference* to this storage cell.\n3.  **Execution Trace**:\n    *   The outer loop runs $N=2$ times. For each pass, the inner loop runs $M=3$ times.\n    *   A total of $N \\times M = 6$ lambdas are created and enqueued.\n    *   Crucially, all 6 lambdas capture a reference to the *same* single storage cell: the one belonging to the inner loop's `i`.\n    *   The lambdas are executed only after all loops have completed.\n    *   Consider the state of the inner loop's `i` cell. It is initialized to $0$, incremented to $1$, then to $2$. After the iteration where $i=2$, the loop update `$i := i + 1$` sets the value of the cell to $3$. The loop condition `$i  M$` (i.e., `$3  3$`) then fails, terminating the inner loop. This process repeats for each pass of the outer loop, always leaving the inner loop's `i` cell with the final value of $M=3$.\n4.  **Output**: Since all 6 enqueued lambdas hold a reference to this same cell, when they are finally executed, they all read its final value, which is $3$. Therefore, under $\\mathcal{B}_1$, every lambda prints the value $M$.\n\n**Analysis of Strategy $\\mathcal{B}_2$ (fresh-binding per iteration):**\n1.  **Scope and Shadowing**: The resolution of `i` is the same as above; the lambda captures the inner loop's `i`.\n2.  **Binding Mechanism**: Under Strategy $\\mathcal{B}_2$, each iteration of the inner `for` loop creates a *new, fresh* storage cell for `i`, initialized to the value for that iteration. The lambda created in that iteration captures a reference to this new, unique cell.\n3.  **Execution Trace**:\n    *   **Outer loop ($i=0$):**\n        *   Inner loop (iteration `i=0`): A fresh cell for `i` with value $0$ is created. The first lambda captures this cell.\n        *   Inner loop (iteration `i=1`): A new, different cell for `i` is created with value $1$. The second lambda captures this cell.\n        *   Inner loop (iteration `i=2`): A third distinct cell for `i` is created with value $2$. The third lambda captures this cell.\n    *   **Outer loop ($i=1$):**\n        *   The process repeats. Another fresh cell for inner `i` is created with value $0$ and captured. Then a cell with $1$ is created and captured. Finally, a cell with $2$ is created and captured.\n4.  **Output**: When the 6 lambdas are executed, they read from the distinct cells they captured.\n    *   Two lambdas (one from each outer loop pass) will read from a cell containing $0$.\n    *   Two lambdas will read from a cell containing $1$.\n    *   Two lambdas will read from a cell containing $2$.\n    *   The resulting multiset of printed values is $\\{0, 0, 1, 1, 2, 2\\}$. This is equivalent to $N=2$ copies of the set $\\{0, 1, 2\\}$, which is $\\{0, 1, \\dots, M-1\\}$.\n\n**Conclusion:**\n-   Strategy $\\mathcal{B}_1$ results in all lambdas printing the single value $M$.\n-   Strategy $\\mathcal{B}_2$ results in a multiset of values corresponding to $N$ copies of $\\{0, 1, \\dots, M-1\\}$.\n-   Option A correctly describes both outcomes.",
            "answer": "$$\n\\boxed{A}\n$$"
        }
    ]
}