{
    "hands_on_practices": [
        {
            "introduction": "对于算术表达式，一个模糊的语法是很常见的。通过在解析树节点上标注优先级 (`prec`) 和结合性 (`assoc`) 属性，我们可以精确地解决这种模糊性。本练习将指导你使用这些属性来确定表达式的唯一正确解析结构，并在此基础上，通过另一个综合属性 `val` 计算表达式的最终值，从而巩固语法导向翻译的核心思想。",
            "id": "3621665",
            "problem": "考虑一个歧义表达式文法 $G$，它只有一个非终结符 $E$，产生式为 $E \\rightarrow E \\,\\text{^}\\, E \\mid E * E \\mid E + E \\mid \\text{num}$，其中 $\\text{num}$ 表示一个正整数字面量。在注解分析树和属性文法的框架下，每个由二元运算符标记的内部节点都将用两个属性进行注解：一个数值优先级属性 `prec` 和一个结合性属性 `assoc`。这些属性应编码常规的算术意图，即幂运算比乘法结合更紧密，乘法比加法结合更紧密，并且幂运算是右结合的，而乘法和加法是左结合的。你需要纯粹使用这些属性来消除分析的歧义，方法是强制高优先级运算符在树形结构中支配低优先级运算符，并且同一优先级水平上的冲突根据结合性来解决。\n\n设预期的属性值为 $prec(\\text{^})=3$、$prec(*)=2$、$prec(+)=1$，以及 $assoc(\\text{^})=\\text{right}$、$assoc(*)=\\text{left}$、$assoc(+)=\\text{left}$。此外，在每个 $E$-节点上定义一个综合属性 `val`，该属性根据以下语义基础给出该节点处子表达式的数值：如果 $E \\rightarrow \\text{num}$，则 `val` 是该字面量的整数值；如果 $E \\rightarrow E_1 + E_2$，则 $val = E_1.val + E_2.val$；如果 $E \\rightarrow E_1 * E_2$，则 $val = E_1.val \\times E_2.val$；如果 $E \\rightarrow E_1 \\,\\text{^}\\, E_2$，则 $val = E_1.val^{E_2.val}$。\n\n从上下文无关文法的分析树和属性文法的注解分析树的基本定义出发，确定由给定的 `prec` 和 `assoc` 属性对输入字符串 $s = 2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2 + 4 * 5 + 6$ 强制执行的唯一括号化方案。然后，使用上述 `val` 的语义基础，计算 $s$ 的消歧分析树中根节点的 `val` 的数值。将最终值表示为精确整数。不需要四舍五入。",
            "solution": "该问题是有效的，因为它是编译原理中一个定义明确、具有科学依据的练习。它提供了一套完整且一致的规则（一个属性文法），用于消除由一个歧义上下文无关文法生成的表达式的歧义，并计算其值。所有必要的数据都已提供，任务是将这些形式化规则应用于一个特定的输入字符串。\n\n该问题需要一个两步过程：首先，使用提供的优先级和结合性属性，确定输入字符串 $s = 2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2 + 4 * 5 + 6$ 的唯一分析树的结构；其次，使用给定的语义规则，计算该树根节点的综合属性 `val`。\n\n文法由产生式 $E \\rightarrow E \\,\\text{^}\\, E \\mid E * E \\mid E + E \\mid \\text{num}$ 给出。\n运算符的属性为：\n优先级：$prec(\\text{^})=3$（最高），$prec(*)=2$，$prec(+)=1$（最低）。\n结合性：$assoc(\\text{^})=\\text{right}$，$assoc(*)=\\text{left}$，$assoc(+)=\\text{left}$。\n\n**第一步：确定唯一的分析树结构（括号化）**\n\n分析树的结构由运算符的优先级和结合性决定。优先级较高的运算符在优先级较低的运算符之前应用，这意味着它将出现在分析树中较低的层次。对于优先级相同的运算符，结合性决定了分组方式：左结合意味着从左到右分组（例如，$a+b+c$ 是 $(a+b)+c$），右结合意味着从右到左分组（例如，$a\\,\\text{^}\\,b\\,\\text{^}\\,c$ 是 $a\\,\\text{^}\\,(b\\,\\text{^}\\,c)$）。\n\n我们来分析输入字符串 $s = 2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2 + 4 * 5 + 6$。\n出现的运算符有 $\\text{^}$、$\\text{^}$、+、*、+。\n\n1.  **最高优先级：** 幂运算符 $\\text{^}$ 具有最高优先级（$prec=3$）。字符串中涉及幂运算的运算符构成了子串 $2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2$。由于有两个这样优先级相同的运算符，我们使用结合性。其属性为 $assoc(\\text{^})=\\text{right}$，这意味着该表达式从右到左进行分组。因此，其结构为 $2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)$。这个子表达式必须在任何周围的加法或乘法之前求值。在分析树中，第一个 $\\text{^}$ 将是代表 $3\\,\\text{^}\\,2$ 的节点的父节点。\n\n2.  **次高优先级：** 乘法运算符 $*$ 具有次高优先级（$prec=2$）。涉及乘法的子串是 $4 * 5$。由于只有一个这样的运算符，其分组很简单，就是 $(4 * 5)$。这必须在所有幂运算之后、所有加法之前求值。\n\n3.  **最低优先级：** 加法运算符 $+$ 具有最低优先级（$prec=1$）。原始字符串包含两个加法运算符。在将高优先级运算分组后，表达式字符串可以看作具有结构 $(2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)) + (4 * 5) + 6$。两个加法运算符具有相同的优先级，因此我们使用它们的结合性，即 $assoc(+)=\\text{left}$。这意味着从左到右分组。因此，表达式被分组为 $((2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)) + (4 * 5)) + 6$。\n\n最终的、完全括号化的表达式唯一地指定了消歧分析树的结构，即：\n$$((2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)) + (4 * 5)) + 6$$\n该表达式的分析树的根节点对应于最后执行的操作，即第二个加法。\n\n**第二步：计算综合属性 `val`**\n\n现在，我们根据上面推导出的括号化方案和 `val` 属性的语义规则来计算表达式的数值。这个过程等同于对注解分析树进行后序遍历，其中父节点的 `val` 属性是根据其子节点的 `val` 属性计算得出的。\n\n1.  计算最内层括号内的表达式 $(3 \\,\\text{^}\\, 2)$。语义规则是 $E.val = (E_1.val)^{E_2.val}$。\n    $$3^2 = 9$$\n    表达式变为 $((2 \\,\\text{^}\\, 9) + (4 * 5)) + 6$。\n\n2.  计算下一个最内层的表达式 $(2 \\,\\text{^}\\, 9)$。\n    $$2^9 = 512$$\n    表达式变为 $((512) + (4 * 5)) + 6$。\n\n3.  计算此层级另一个括号内的表达式 $(4 * 5)$。语义规则是 $E.val = E_1.val \\times E_2.val$。\n    $$4 \\times 5 = 20$$\n    表达式变为 $(512 + 20) + 6$。\n\n4.  计算剩余括号内的和 $(512 + 20)$。语义规则是 $E.val = E_1.val + E_2.val$。\n    $$512 + 20 = 532$$\n    表达式变为 $532 + 6$。\n\n5.  最后，执行最后的加法。\n    $$532 + 6 = 538$$\n\n这个最终结果 $538$ 是输入字符串 $s$ 的消歧分析树根节点处综合属性 `val` 的值。",
            "answer": "$$\\boxed{538}$$"
        },
        {
            "introduction": "注解解析树不仅可以用于计算具体值，还能执行更高级的静态分析任务，在程序运行前发现潜在错误。本练习引入了区间分析技术，通过追踪表达式可能取值的范围，来检测诸如除以零之类的确定性未定义行为。这个实践展示了如何利用属性来同时处理具体计算和抽象性质，突显了属性文法在保障软件可靠性方面的强大能力。",
            "id": "3621702",
            "problem": "考虑一个只有一个非终结符 $E$ 和产生式 $E \\to E \\;\\% \\; E \\mid \\text{num}$ 的上下文无关文法。你将设计并使用一个属性文法来标注一个特定的分析树，以便 (i) 计算每个 $E$ 处的综合整数值属性 `val`，以及 (ii) 使用源自区间分析的布尔属性 `must_zero` 来检测当右操作数必须为零时模运算符的确定的未定义行为。所有值都是非负整数，模运算符是欧几里得余数：对于 $a \\in \\mathbb{Z}_{\\ge 0}$ 和 $b \\in \\mathbb{Z}_{\\ge 1}$，$a \\bmod b \\in \\{0,1,\\dots,b-1\\}$。\n\n你的构建应仅基于属性文法的核心定义和可靠的区间分析规则：\n- 属性文法为每个节点分配从其子节点计算得出的综合属性和由其父节点提供的继承属性；在这里，你将只使用综合属性。\n- 区间分析通过一个满足 $0 \\le l \\le h$ 的区间 $[l,h]$ 来抽象表达式的可能整数值集合，并使用可靠的过近似规则来组合区间。\n\n为每个标记为 $E$ 的节点定义以下综合属性：\n- $val(E)$：在给定的具体输入下，由 $E$ 表示的表达式的整数值。\n- $I(E) = [l(E),h(E)]$：一个过近似区间，表示 $E$ 根据下面提供的静态信息可能取的所有值。\n- $must\\_zero(E)$：一个布尔值，当且仅当 $I(E) = [0,0]$ 时为真。\n\n定义属性计算规则如下：\n- 对于一个叶节点 $E \\Rightarrow \\text{num}$，其具体的整数字素值为 $v$，由分析提供的静态已知区间为 $[L,H]$，则设置 $val(E) = v$，$I(E) = [L,H]$，并且 $must\\_zero(E)$ 为真当且仅当 $L = 0$ 且 $H = 0$。\n- 对于一个内部节点 $E \\Rightarrow E_1 \\;\\% \\; E_2$：\n  - 如果 $must\\_zero(E_2)$ 为真，则该操作具有确定的未定义行为（右操作数确定为零）。你仍必须为分析计算 $I(E)$，但决不能在任何进一步的程序行为计算中使用 $val(E)$。对于 $I(E)$，使用可靠的过近似规则\n    $$I(E) = \\left[\\,0,\\; \\min\\!\\left(h(E_1),\\; \\max\\!\\left(h(E_2) - 1,\\; 0\\right)\\right)\\right]\\,.$$\n  - 如果 $must\\_zero(E_2)$ 为假，则设置\n    $$val(E) = val(E_1) \\bmod val(E_2),$$\n    并设置\n    $$I(E) = \\left[\\,0,\\; \\min\\!\\left(h(E_1),\\; \\max\\!\\left(h(E_2) - 1,\\; 0\\right)\\right)\\right],$$\n    且 $must\\_zero(E)$ 为真当且仅当 $I(E) = [0,0]$。\n\n现在考虑完全括号化的表达式，其分析树为\n$$E \\;\\Rightarrow\\; \\big(\\,\\big(\\,(n_1 \\;\\% \\; n_2)\\; \\% \\; (n_3 \\;\\% \\; n_4)\\,\\big)\\; \\% \\; n_5\\,\\big),$$\n其中 $n_i$ 是形式为 $\\text{num}$ 的终结符，具有以下具体的字素值和静态已知的区间：\n- $n_1$：具体值 $v_1 = 47$，区间 $[L_1,H_1] = [40,60]$，\n- $n_2$：具体值 $v_2 = 13$，区间 $[L_2,H_2] = [10,15]$，\n- $n_3$：具体值 $v_3 = 9$，区间 $[L_3,H_3] = [0,12]$，\n- $n_4$：具体值 $v_4 = 4$，区间 $[L_4,H_4] = [2,5]$，\n- $n_5$：具体值 $v_5 = 6$，区间 $[L_5,H_5] = [5,9]$。\n\n任务：\n- 仅使用上述规则，自底向上地标注分析树，以计算每个内部节点的 $I(E)$ 和 $must\\_zero(E)$，并检测是否有任何内部节点 $E \\Rightarrow E_1 \\;\\% \\; E_2$ 因为 $must\\_zero(E_2)$ 为真而具有确定的未定义行为。\n- 假设没有检测到确定的未定义行为，计算根节点处的精确整数值 $val$。\n\n以精确整数形式给出你的答案。如果根据这些规则检测到表达式具有确定的未定义行为，则不要计算 $val$；然而，所提供的数据是一致且自洽的，你应该根据你的分析相应地进行处理。",
            "solution": "该问题定义明确、内部一致，并且在编译器设计原理（特别是属性文法和通过区间算术进行的静态分析）方面有科学依据。所有必要的规则和数据都已提供。因此我们可以着手求解。\n\n该问题要求对表达式 `(((n1 % n2) % (n3 % n4)) % n5)` 的分析树上的属性进行求值。提供的文法是 $E \\to E \\;\\% \\; E \\mid \\text{num}$。表达式的括号化决定了唯一的抽象语法树 (AST)。我们将对这棵树执行自底向上求值（后序遍历），以计算每个节点的综合属性。\n\n让我们将 AST 的节点表示如下：\n- 叶节点 $E_{n1}, E_{n2}, E_{n3}, E_{n4}, E_{n5}$ 对应于终结符 $n_1, n_2, n_3, n_4, n_5$。\n- 内部节点 $E_B$ 是操作 $E_{n1} \\;\\% \\; E_{n2}$ 的父节点。\n- 内部节点 $E_C$ 是操作 $E_{n3} \\;\\% \\; E_{n4}$ 的父节点。\n- 内部节点 $E_A$ 是操作 $E_B \\;\\% \\; E_C$ 的父节点。\n- 根节点 $E_R$ 是操作 $E_A \\;\\% \\; E_{n5}$ 的父节点。\n\n求值按以下阶段进行：\n\n**1. 叶节点的属性**\n根据问题陈述，对于一个具有具体值 $v$ 和静态区间 $[L,H]$ 的叶节点 $E \\Rightarrow \\text{num}$，其属性设置如下：$val(E) = v$，$I(E) = [L,H]$，且 $must\\_zero(E)$ 为真当且仅当 $L=0$ 且 $H=0$。\n\n使用所提供的数据：\n- 对于 $E_{n1}$：$v_1 = 47$，$I(E_{n1}) = [40, 60]$。因为该区间不是 $[0,0]$，所以 $must\\_zero(E_{n1}) = \\text{false}$。\n- 对于 $E_{n2}$：$v_2 = 13$，$I(E_{n2}) = [10, 15]$。因为该区间不是 $[0,0]$，所以 $must\\_zero(E_{n2}) = \\text{false}$。\n- 对于 $E_{n3}$：$v_3 = 9$，$I(E_{n3}) = [0, 12]$。因为该区间不是 $[0,0]$，所以 $must\\_zero(E_{n3}) = \\text{false}$。\n- 对于 $E_{n4}$：$v_4 = 4$，$I(E_{n4}) = [2, 5]$。因为该区间不是 $[0,0]$，所以 $must\\_zero(E_{n4}) = \\text{false}$。\n- 对于 $E_{n5}$：$v_5 = 6$，$I(E_{n5}) = [5, 9]$。因为该区间不是 $[0,0]$，所以 $must\\_zero(E_{n5}) = \\text{false}$。\n\n**2. 节点 $E_B \\to E_{n1} \\;\\% \\; E_{n2}$ 的求值**\n首先，我们检查未定义行为的条件。右操作数是 $E_{n2}$，且 $must\\_zero(E_{n2})$ 为假。因此，在此节点未检测到确定的未定义行为，我们可以计算 $val(E_B)$。\n\n- 计算 $val(E_B)$：\n  $val(E_B) = val(E_{n1}) \\bmod val(E_{n2}) = 47 \\bmod 13 = 8$。\n\n- 计算 $I(E_B)$：\n  $I(E_B) = [0, \\min(h(E_{n1}), \\max(h(E_{n2}) - 1, 0))] = [0, \\min(60, \\max(15 - 1, 0))] = [0, \\min(60, 14)] = [0, 14]$。\n\n- 计算 $must\\_zero(E_B)$：\n  因为 $I(E_B) = [0, 14]$ 不是 $[0,0]$，所以 $must\\_zero(E_B) = \\text{false}$。\n\n**3. 节点 $E_C \\to E_{n3} \\;\\% \\; E_{n4}$ 的求值**\n右操作数是 $E_{n4}$，且 $must\\_zero(E_{n4})$ 为假。未检测到确定的未定义行为。\n\n- 计算 $val(E_C)$：\n  $val(E_C) = val(E_{n3}) \\bmod val(E_{n4}) = 9 \\bmod 4 = 1$。\n\n- 计算 $I(E_C)$：\n  $I(E_C) = [0, \\min(h(E_{n3}), \\max(h(E_{n4}) - 1, 0))] = [0, \\min(12, \\max(5 - 1, 0))] = [0, \\min(12, 4)] = [0, 4]$。\n\n- 计算 $must\\_zero(E_C)$：\n  因为 $I(E_C) = [0, 4]$ 不是 $[0,0]$，所以 $must\\_zero(E_C) = \\text{false}$。\n\n**4. 节点 $E_A \\to E_B \\;\\% \\; E_C$ 的求值**\n右操作数是 $E_C$，我们已计算出 $must\\_zero(E_C) = \\text{false}$。未检测到确定的未定义行为。\n\n- 计算 $val(E_A)$：\n  $val(E_A) = val(E_B) \\bmod val(E_C) = 8 \\bmod 1 = 0$。\n\n- 计算 $I(E_A)$：\n  $I(E_A) = [0, \\min(h(E_B), \\max(h(E_C) - 1, 0))] = [0, \\min(14, \\max(4 - 1, 0))] = [0, \\min(14, 3)] = [0, 3]$。\n\n- 计算 $must\\_zero(E_A)$：\n  因为 $I(E_A) = [0, 3]$ 不是 $[0,0]$，所以 $must\\_zero(E_A) = \\text{false}$。\n\n**5. 根节点 $E_R \\to E_A \\;\\% \\; E_{n5}$ 的求值**\n右操作数是 $E_{n5}$，且 $must\\_zero(E_{n5})$ 为假。未检测到确定的未定义行为。\n\n- 计算 $val(E_R)$：\n  $val(E_R) = val(E_A) \\bmod val(E_{n5}) = 0 \\bmod 6 = 0$。\n\n- 计算 $I(E_R)$：\n  $I(E_R) = [0, \\min(h(E_A), \\max(h(E_{n5}) - 1, 0))] = [0, \\min(3, \\max(9 - 1, 0))] = [0, \\min(3, 8)] = [0, 3]$。\n\n- 计算 $must\\_zero(E_R)$：\n  因为 $I(E_R) = [0, 3]$ 不是 $[0,0]$，所以 $must\\_zero(E_R) = \\text{false}$。\n\n**结论**\n属性文法的自底向上求值已完成。在计算内部节点 $E \\to E_1 \\;\\% \\; E_2$ 的过程中，从未发现条件 $must\\_zero(E_2)$ 为真。因此，根据指定规则进行的静态分析，在给定表达式中未检测到确定的未定义行为（除以零）。\n\n由于未检测到未定义行为，因此 `val` 属性的计算在整个树中都是有效的。表达式的最终整数值是根节点处 `val` 属性的值，$val(E_R)$。\n\n在根节点计算出的值是 $val(E_R) = 0$。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "在编译器理解了程序的结构（即解析树）之后，它常常需要将这个结构转换回文本形式，例如在“美化打印”(pretty-printing)或代码重构中。本练习挑战你推导出一套规则，用于将表达式树“反解析”为一个字符串，并使用最少数量的括号来保持其原始的运算结构。这个过程能让你深入理解树形结构和其文本表示之间的相互作用，这是代码生成器和格式化工具设计的关键。",
            "id": "3621753",
            "problem": "考虑一个中缀表达式语言，它包含二元运算符 $+$, $-$, $*$, $/$, 和 $^{\\wedge}$ (幂运算)，以及作为叶子节点的标识符。该语言使用上下文无关文法进行解析，并通过运算符优先级和结合性来消除歧义。解析树的每个内部节点都用两个综合属性进行标注：`prec`，即该节点运算符的优先级，以及 `assoc`，即该运算符的结合性。标识符是叶子节点，没有运算符；为了便于比较，我们将叶子节点的 `prec` 视为 $+\\infty$。优先级和结合性如下：\n- $+$ 和 $-$: $\\operatorname{prec} = 1$, $\\operatorname{assoc} = \\mathrm{left}$ (左结合)。\n- $*$ 和 $/$: $\\operatorname{prec} = 2$, $\\operatorname{assoc} = \\mathrm{left}$ (左结合)。\n- $^{\\wedge}$: $\\operatorname{prec} = 3$, $\\operatorname{assoc} = \\mathrm{right}$ (右结合)。\n\n反解析器 (unparser) 必须根据给定的解析树生成中缀表达式字符串，并插入最少数量的括号，以保证当使用相同的优先级和结合性规则重新解析该字符串时，能够精确地得到原始的解析树。\n\n请从“优先级是决定结合强度的顺序”和“结合性是在优先级相同时决定分组方式的决胜规则”这两个基本定义出发，推导一个基于属性的决策规则。对于每个具有运算符优先级 $\\operatorname{prec}_{p}$ 和结合性 $\\operatorname{assoc}_{p}$ 的父节点，该规则仅根据其子树根节点的运算符优先级 $\\operatorname{prec}_{c}$ 以及该子节点是左子节点还是右子节点，来决定是否需要为该子树添加括号。然后，将你推导出的规则应用于如下定义的具体解析树 $T$：\n- $T$ 的根节点是运算符 $-$，其左子节点为 $A$，右子节点为 $B$。\n- 子树 $A$ 的根节点为 $/$，其左子节点为 $A_{1}$，右子节点为 $A_{2}$。\n- 子树 $A_{1}$ 的根节点为 $+$，其叶子节点为 $a$ 和 $b$。\n- 子树 $A_{2}$ 的根节点为 $*$，其左叶子节点为 $c$，右子节点为 $A_{2b}$。\n- 子树 $A_{2b}$ 的根节点为 $^{\\wedge}$，其叶子节点为 $d$ 和 $e$。\n- 子树 $B$ 的根节点为 $^{\\wedge}$，其左子节点为 $B_{1}$，右子节点为 $B_{2}$。\n- 子树 $B_{1}$ 的根节点为 $^{\\wedge}$，其叶子节点为 $f$ 和 $g$。\n- 子树 $B_{2}$ 的根节点为 $+$，其叶子节点为 $h$ 和 $i$。\n\n计算在为 $T$ 生成中缀表达式字符串时，最少括号反解析器需要插入的括号对的总数。请用一个整数表示你的最终答案。",
            "solution": "该问题要求我们推导一个用于从带标注的解析树中反解析表达式的最小括号化规则，然后将此规则应用于一个特定的树 $T$ 来计算括号对的数量。其目标是确保重新解析反解析出的字符串能够得到原始的树结构。文法的歧义消除是基于运算符优先级和结合性的。\n\n首先，我们推导通用的决策规则。设解析树中的一个父节点表示一个运算，其运算符为 $op_p$，优先级为 $\\operatorname{prec}_{p}$，结合性为 $\\operatorname{assoc}_{p}$。设其一个子节点是一棵子树，其根节点表示一个运算，运算符为 $op_c$，优先级为 $\\operatorname{prec}_{c}$，结合性为 $\\operatorname{assoc}_{c}$。反解析出的字符串会将与子节点对应的子表达式放置在父节点运算符的旁边。当且仅当默认的优先级和结合性规则会导致父运算符 $op_p$ 与子运算符 $op_c$ 的某个操作数结合，从而在重新解析时改变树的结构时，才需要在子表达式周围加上括号。\n\n我们基于 $\\operatorname{prec}_{p}$ 和 $\\operatorname{prec}_{c}$ 之间的关系来分析需要加括号的条件。\n\n1.  **情况 1：$\\operatorname{prec}_{c} > \\operatorname{prec}_{p}$**\n    子运算符 $op_c$ 的优先级高于父运算符 $op_p$。根据优先级的定义，$op_c$ 会比 $op_p$ 更紧密地结合其操作数。例如，在表达式 $a - b * c$ 中，'*' 的优先级高于 '-'。该字符串自然地被解析为 $a - (b * c)$，这对应于一棵 '*' 是 '-' 的子节点的树。因此，不加括号也能保留原始结构。不需要括号。\n\n2.  **情况 2：$\\operatorname{prec}_{c}  \\operatorname{prec}_{p}$**\n    子运算符 $op_c$ 的优先级低于父运算符 $op_p$。如果不加括号，优先级更高的父运算符 $op_p$ 将会“窃取”$op_c$ 的一个操作数。例如，如果树结构是 $a * (b + c)$，父运算符是 '*'，子运算符是 '+'。不加括号的反解析结果是 $a * b + c$，它将被重新解析为 $(a * b) + c$，从而改变了结构。为了强制保持原始的分组，必须加括号：$a * (b + c)$。总是需要括号。\n\n3.  **情况 3：$\\operatorname{prec}_{c} = \\operatorname{prec}_{p}$**\n    运算符具有相同的优先级。此时，结合性规则作为决胜规则。\n    - **子情况 3a：子节点是父节点的左子节点。** 表达式形式为 $(E_c) \\ op_p \\ E_{other}$。不加括号的反解析字符串将是 $... op_c ... op_p ...$。\n        - 如果 $\\operatorname{assoc}_{p}$ 是**左结合**，运算符会从左到右分组。解析器会形成 $(... op_c ...) \\ op_p ...$ 的结构，这与原始树结构相匹配。不需要括号。\n        - 如果 $\\operatorname{assoc}_{p}$ 是**右结合**，运算符会从右到左分组。解析器会形成 $... op_c (... op_p ...)$ 的结构，这与原始树结构相矛盾。为了强制实现树所期望的从左到右的分组，需要在左子节点的表达式周围加上括号。\n    - **子情况 3b：子节点是父节点的右子节点。** 表达式形式为 $E_{other} \\ op_p \\ (E_c)$。不加括号的反解析字符串将是 $... op_p ... op_c ...$。\n        - 如果 $\\operatorname{assoc}_{p}$ 是**左结合**，运算符会从左到右分组。解析器会形成 $(... op_p ...) \\ op_c ...$ 的结构，这与原始树结构相矛盾。需要在右子节点的表达式周围加上括号，以强制实现相对于 $op_p$ 所期望的右到左的分组。\n        - 如果 $\\operatorname{assoc}_{p}$ 是**右结合**，运算符会从右到左分组。解析器会形成 $... op_p (... op_c ...)$ 的结构，这与原始树结构相匹配。不需要括号。\n\n**括号化规则总结：**\n如果一个子表达式的根运算符是 $op_c$，其父运算符是 $op_p$，并且满足以下任一条件，则该子表达式必须加上括号：\n1.  $\\operatorname{prec}_{c}  \\operatorname{prec}_{p}$。\n2.  $\\operatorname{prec}_{c} = \\operatorname{prec}_{p}$，且该子节点是**左**子节点，并且 $\\operatorname{assoc}_{p}$ 是**右结合**。\n3.  $\\operatorname{prec}_{c} = \\operatorname{prec}_{p}$，且该子节点是**右**子节点，并且 $\\operatorname{assoc}_{p}$ 是**左结合**。\n\n叶子节点（标识符）的 $\\operatorname{prec}$ 被赋予 $+\\infty$。由于标识符的优先级永远不会低于或等于任何运算符的优先级，根据此规则，它永远不会被加上括号。\n\n现在，我们将此规则应用于给定的树 $T$。运算符属性如下：\n-   $+$ 和 $-$: $\\operatorname{prec} = 1$, $\\operatorname{assoc} = \\mathrm{left}$ (左结合)。\n-   $*$ 和 $/$: $\\operatorname{prec} = 2$, $\\operatorname{assoc} = \\mathrm{left}$ (左结合)。\n-   $^{\\wedge}$: $\\operatorname{prec} = 3$, $\\operatorname{assoc} = \\mathrm{right}$ (右结合)。\n\n我们遍历这棵树，并对每个子节点不是叶子节点的父-子对检查条件。\n\n-   **父节点: $-$ ($T$ 的根节点)** ($\\operatorname{prec}_{p}=1, \\operatorname{assoc}_{p}=\\mathrm{left}$)\n    -   左子节点: 子树 $A$，根为 $/$ ($\\operatorname{prec}_{c}=2$)。\n        -   条件检查: $\\operatorname{prec}_{c} = 2 > \\operatorname{prec}_{p} = 1$。无需括号。\n    -   右子节点: 子树 $B$，根为 $^{\\wedge}$ ($\\operatorname{prec}_{c}=3$)。\n        -   条件检查: $\\operatorname{prec}_{c} = 3 > \\operatorname{prec}_{p} = 1$。无需括号。\n\n-   **父节点: $/$ ($A$ 的根节点)** ($\\operatorname{prec}_{p}=2, \\operatorname{assoc}_{p}=\\mathrm{left}$)\n    -   左子节点: 子树 $A_1$，根为 $+$ ($\\operatorname{prec}_{c}=1$)。\n        -   条件检查: $\\operatorname{prec}_{c} = 1  \\operatorname{prec}_{p} = 2$。规则 1 适用。**加括号 (1)**。\n    -   右子节点: 子树 $A_2$，根为 $*$ ($\\operatorname{prec}_{c}=2$)。\n        -   条件检查: $\\operatorname{prec}_{c} = 2 = \\operatorname{prec}_{p} = 2$。这是右子节点，且 $\\operatorname{assoc}_{p}$ 是左结合。规则 3 适用。**加括号 (2)**。\n\n-   **父节点: $*$ (在子树 $A_2$ 中)** ($\\operatorname{prec}_{p}=2, \\operatorname{assoc}_{p}=\\mathrm{left}$)\n    -   右子节点: 子树 $A_{2b}$，根为 $^{\\wedge}$ ($\\operatorname{prec}_{c}=3$)。\n        -   条件检查: $\\operatorname{prec}_{c} = 3 > \\operatorname{prec}_{p} = 2$。无需括号。\n\n-   **父节点: $^{\\wedge}$ ($B$ 的根节点)** ($\\operatorname{prec}_{p}=3, \\operatorname{assoc}_{p}=\\mathrm{right}$)\n    -   左子节点: 子树 $B_1$，根为 $^{\\wedge}$ ($\\operatorname{prec}_{c}=3$)。\n        -   条件检查: $\\operatorname{prec}_{c} = 3 = \\operatorname{prec}_{p} = 3$。这是左子节点，且 $\\operatorname{assoc}_{p}$ 是右结合。规则 2 适用。**加括号 (3)**。\n    -   右子节点: 子树 $B_2$，根为 $+$ ($\\operatorname{prec}_{c}=1$)。\n        -   条件检查: $\\operatorname{prec}_{c} = 1  \\operatorname{prec}_{p} = 3$。规则 1 适用。**加括号 (4)**。\n\n所有其他非叶子节点都只有叶子节点作为其子节点。如前所述，叶子节点（$\\operatorname{prec}=+\\infty$ 的标识符）永远不会被加上括号。\n\n分析得出总共有 $4$ 种情况需要加括号：\n1.  子树 $A_1$ ($a+b$) 周围，因为其父节点是 $/$ ($\\operatorname{prec}=2$)，而其根节点是 $+$ ($\\operatorname{prec}=1$)。\n2.  子树 $A_2$ ($c*(d \\text{^} e)$) 周围，因为其父节点是 $/$ ($\\operatorname{prec}=2$，左结合)，其根节点是 $*$ ($\\operatorname{prec}=2$)，并且它是右子节点。\n3.  子树 $B_1$ ($f \\text{^} g$) 周围，因为其父节点是 $^{\\wedge}$ ($\\operatorname{prec}=3$，右结合)，其根节点是 $^{\\wedge}$ ($\\operatorname{prec}=3$)，并且它是左子节点。\n4.  子树 $B_2$ ($h+i$) 周围，因为其父节点是 $^{\\wedge}$ ($\\operatorname{prec}=3$)，而其根节点是 $+$ ($\\operatorname{prec}=1$)。\n\n所需括号对的总数为 $4$。\n生成的字符串将是：$((a+b) / (c * (d \\text{^} e))) - ((f \\text{^} g) \\text{^} (h+i))$。\n\n插入的括号对总数为 $4$。",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}