{
    "hands_on_practices": [
        {
            "introduction": "Understanding garbage collection begins with its most fundamental algorithm: mark-and-sweep. This hands-on exercise challenges you to implement a collector from first principles, building on the core concept of object reachability (). By translating the theory of graph traversal into a working program, you will gain a concrete understanding of how a collector identifies and reclaims unused memory.",
            "id": "3229801",
            "problem": "You are given a finite heap of objects, each object representing a node of a doubly linked list with two fields: a \"next\" pointer and a \"prev\" pointer. Formally, let the heap be a finite set of nodes indexed by unique integer identifiers, which we model as a finite set of triples $H = \\{(i, n_i, p_i)\\}$, where for each node identifier $i$ there are two pointer values $n_i$ (the \"next\" pointer) and $p_i$ (the \"prev\" pointer). Each pointer value is either an existing node identifier in the heap or the null sentinel, which shall be represented as the integer $-1$. Let the directed graph $G = (V, E)$ induced by $H$ have vertex set $V = \\{ i \\mid (i, n_i, p_i) \\in H \\}$ and directed edges $E = \\{ (i, n_i) \\mid n_i \\in V \\} \\cup \\{ (i, p_i) \\mid p_i \\in V \\}$. You are also given a root set $R$ of pointers (node identifiers) that may include duplicates, the null sentinel, or identifiers that do not exist in $V$. A node $v \\in V$ is said to be reachable from $R$ if there exists a finite path in $G$ starting at some $r \\in R \\cap V$ and ending at $v$. Define the marked set $M \\subseteq V$ to be the set of all nodes reachable from $R$. A mark-and-sweep garbage collector is specified as follows:\n- Mark phase: compute the least fixed point $M$ that contains $R \\cap V$ and is closed under following both the \"next\" and \"prev\" pointers along edges in $E$.\n- Sweep phase: remove all nodes in $V \\setminus M$ from the heap. After removal, for each surviving node $(i, n_i, p_i)$ with $i \\in M$, rewrite any pointer that does not point to some element of $M$ to the null sentinel (represented as $-1$).\n\nFrom first principles, you must implement this mark-and-sweep garbage collector with the following precise behavior:\n- Only pointers equal to existing identifiers are traversed during marking; the null sentinel $-1$ and any non-existent identifier (an integer not in $V$) are ignored.\n- The root set $R$ may contain the null sentinel $-1$ or identifiers not present in $V$; these are ignored during marking.\n- The mark phase must treat both the \"next\" and the \"prev\" pointers as outgoing edges and follow both.\n- The sweep phase removes all unmarked nodes and rewrites any pointer in the survivors that does not refer to a survivor as the null sentinel $-1$.\n\nFundamental base you may use:\n- The graph-theoretic definition of reachability: given a directed graph $G = (V, E)$ and a set $R \\subseteq V$, the reachable set $M$ is the least set with $R \\subseteq M$ and whenever $(u, v) \\in E$ and $u \\in M$ then $v \\in M$.\n- Basic properties of set difference, union, and intersection.\n- The semantics of the null sentinel as indicating \"no pointer,\" which is not followed during graph traversal.\n\nTest suite. Each heap is given as a list of triples $(\\text{id}, \\text{next}, \\text{prev})$ with integers, and each root set is a list of integers. The integer $-1$ denotes the null sentinel.\n\n- Test case $1$ (simple finite chain): \n  - Heap $H_1 = \\{ (1, 2, -1), (2, 3, 1), (3, -1, 2) \\}$.\n  - Roots $R_1 = [2]$.\n- Test case $2$ (two components, one isolated): \n  - Heap $H_2 = \\{ (10, 11, -1), (11, -1, 10), (20, -1, -1) \\}$.\n  - Roots $R_2 = [10]$.\n- Test case $3$ (circular doubly linked list with duplicate roots): \n  - Heap $H_3 = \\{ (30, 31, 32), (31, 32, 30), (32, 30, 31) \\}$.\n  - Roots $R_3 = [31, 31]$.\n- Test case $4$ (broken pointer to non-existent node): \n  - Heap $H_4 = \\{ (40, 999, -1), (41, 40, -1) \\}$ where $999 \\notin V$.\n  - Roots $R_4 = [41]$.\n- Test case $5$ (empty roots): \n  - Heap $H_5 = \\{ (50, 51, -1), (51, -1, 50) \\}$.\n  - Roots $R_5 = []$.\n- Test case $6$ (self-looping node and a null root entry): \n  - Heap $H_6 = \\{ (60, 60, 60) \\}$.\n  - Roots $R_6 = [60, -1]$.\n\nRequired final output format:\n- Your program must produce a single line containing a Python-style list with no spaces. The list has $6$ elements, one per test case in the given order. Each element is itself a list (also with no spaces) of the surviving node identifiers in strictly increasing order for that test case. For instance, if for some test case the survivors are the identifiers $1$, $2$, and $3$, then its element must be written as \"[1,2,3]\" with no spaces. The overall line concatenates these six per-test-case lists inside a single outer pair of square brackets with commas and no spaces.",
            "solution": "The problem requires the implementation of a mark-and-sweep garbage collector for a memory heap composed of nodes in a doubly linked list structure. The state of the heap and the garbage collection process are formally defined, and the task is to determine the set of surviving nodes for several test cases.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   A heap is a finite set of triples $H = \\{(i, n_i, p_i)\\}$, where $i$ is a unique integer node identifier, $n_i$ is the `next` pointer, and $p_i$ is the `prev` pointer.\n-   Pointer values can be an existing node identifier or the null sentinel, represented by the integer $-1$.\n-   The heap induces a directed graph $G = (V, E)$ where $V = \\{ i \\mid (i, n_i, p_i) \\in H \\}$ and $E = \\{ (i, n_i) \\mid n_i \\in V \\} \\cup \\{ (i, p_i) \\mid p_i \\in V \\}$.\n-   A root set $R$ is provided, which may contain node identifiers, duplicates, the null sentinel ($-1$), or identifiers not in $V$.\n-   The marked set, $M \\subseteq V$, consists of all nodes reachable from the valid roots $R \\cap V$ by traversing any number of `next` or `prev` pointers.\n-   The mark-and-sweep process is defined in two phases:\n    1.  **Mark**: Compute the reachable set $M$.\n    2.  **Sweep**: Remove nodes in $V \\setminus M$. Pointers in surviving nodes that point to removed nodes are rewritten to $-1$.\n-   The required output is the sorted list of identifiers of the surviving nodes, which is the set $M$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is evaluated against the specified criteria:\n-   **Scientifically Grounded**: The problem is based on the well-established computer science principles of garbage collection, graph theory, and data structures. The mark-and-sweep algorithm and the concept of reachability are fundamental and mathematically sound.\n-   **Well-Posed**: The problem is well-posed. The marked set $M$ is defined as the least fixed point of a closure operation, which guarantees its existence and uniqueness. The algorithm for finding this set (graph traversal) is standard and deterministic.\n-   **Objective**: The language is formal and precise, using mathematical definitions that are unambiguous. It avoids subjective claims.\n-   The problem is **self-contained**, providing all necessary definitions, constraints, and test data. It is internally **consistent**; the rules for handling pointers (including null and non-existent ones) are clearly specified and do not contradict each other. While the description of the sweep phase's pointer rewriting is not strictly necessary for the requested output (the set of survivors), it correctly describes the full garbage collection process and does not create any contradiction.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. It is a well-defined and formally sound problem within the domain of algorithms and data structures. A complete solution will be provided.\n\n### Principle-Based Solution\n\n**1. Formal Problem Representation**\n\nThe core of the problem is to identify a specific subset of nodes in a graph. The heap $H$ is a representation of a directed graph $G=(V, E)$. The set of vertices $V$ is the set of all node identifiers present in the heap. The edges $E$ are defined by the `next` and `prev` pointers. Specifically, for each node $i \\in V$ with pointers $(n_i, p_i)$, there are potential directed edges $(i, n_i)$ and $(i, p_i)$, provided that $n_i \\in V$ and $p_i \\in V$, respectively.\n\nThe task is to compute the set of \"live\" or \"reachable\" nodes, which we denote as $M$. This set is defined by graph reachability from a given root set $R$. A node $v \\in V$ is in $M$ if and only if there exists a path in $G$ from some starting node $r \\in R \\cap V$ to $v$. The starting set of nodes for the traversal is $R \\cap V$, which includes only the roots that are valid node identifiers in the heap.\n\n**2. Algorithmic Principle: Graph Reachability**\n\nThe computation of the marked set $M$ is a classic graph reachability problem. Given a directed graph $G=(V,E)$ and a set of start vertices $S \\subseteq V$, the goal is to find all vertices reachable from any vertex in $S$. Since the problem specifies that both `next` and `prev` pointers should be followed, we are effectively finding all nodes in the connected components (in the sense of the underlying undirected graph) that contain at least one root node.\n\nA standard and efficient algorithm for this task is Breadth-First Search (BFS). BFS systematically explores a graph level by level, starting from the given root nodes. It is guaranteed to find all reachable nodes.\n\n**3. Algorithm Design**\n\nThe garbage collection process can be implemented by following the formal definitions precisely.\n\n**Data Structures:**\n-   **Heap Representation**: The heap $H$ is best stored in a hash map (a dictionary in Python), mapping each node identifier $i$ to a tuple of its pointers $(n_i, p_i)$. This provides average $O(1)$ time complexity for accessing a node's pointers. The set of valid node identifiers, $V$, can be efficiently obtained from the keys of this dictionary.\n-   **Marked Set**: A hash set (a `set` in Python) is used to store the marked set $M$. This allows for $O(1)$ average time complexity for insertion and for checking if a node has already been marked.\n-   **Traversal Queue**: A queue data structure is required for the BFS algorithm. Python's `collections.deque` is highly efficient for this purpose, providing $O(1)$ time complexity for append and pop-from-left operations.\n\n**Mark Phase Implementation (BFS):**\n1.  **Initialization**:\n    -   Create the heap dictionary from the input list of triples. Let $V$ be the set of its keys.\n    -   Initialize an empty set `marked` for $M$.\n    -   Initialize an empty queue `to_visit`.\n    -   Iterate through the given root set $R$. For each root $r \\in R$, if $r \\in V$ and $r$ has not yet been marked (a check for uniqueness in case of duplicate roots), add $r$ to both the `marked` set and the `to_visit` queue.\n\n2.  **Traversal Loop**:\n    -   While the `to_visit` queue is not empty, perform the following steps:\n        -   Dequeue a node identifier, let's call it $u$.\n        -   Retrieve its pointers, $(n_u, p_u)$, from the heap dictionary.\n        -   For each pointer value $v \\in \\{n_u, p_u\\}$:\n            -   Check if the pointer is valid: $v \\in V$. The conditions $v \\neq -1$ and $v$ being a key in the heap dictionary ensure this.\n            -   If $v$ is valid and $v \\notin \\text{marked}$, it is a newly discovered live node. Add $v$ to the `marked` set and enqueue it into the `to_visit` queue.\n    -   This process terminates when the queue is empty, at which point the `marked` set contains all nodes reachable from the initial roots.\n\n**Sweep Phase and Output Generation:**\n-   The problem states that the \"sweep\" phase removes unmarked nodes. The set of surviving nodes is therefore precisely the `marked` set $M$.\n-   The required output is a sorted list of the identifiers in $M$. The final step is to convert the `marked` set to a list and sort it in increasing order.\n\n**Complexity Analysis**:\n-   Let $|V|$ be the number of nodes and $|E|$ be the number of edges in the graph $G$. In our case, $|E| \\le 2|V|$.\n-   **Time Complexity**: The initialization of the heap dictionary takes $O(|V|)$ time. The pre-processing of the root set $R$ takes $O(|R|)$ time. The BFS traversal visits each reachable node and each of its edges at most once. Therefore, the time complexity of the mark phase is proportional to the number of nodes and edges in the reachable subgraphs, which is $O(|V|+|E|)$ in the worst case (if all nodes are reachable).\n-   **Space Complexity**: The space required is dominated by the heap dictionary, the marked set, and the BFS queue. In the worst case, all nodes are reachable, so the space complexity is $O(|V|)$ to store these structures.",
            "answer": "```python\nimport collections\nimport numpy as np\n\ndef run_gc(heap_data, roots):\n    \"\"\"\n    Performs mark-and-sweep garbage collection and returns the sorted list of survivor IDs.\n\n    Args:\n        heap_data (list): A list of tuples (id, next, prev) representing the heap.\n        roots (list): A list of integer root pointers.\n\n    Returns:\n        list: A sorted list of integer IDs of the surviving nodes.\n    \"\"\"\n    # Step 1: Represent the heap as a dictionary for efficient access.\n    # The set of valid node IDs is the set of keys of this dictionary.\n    heap = {node[0]: (node[1], node[2]) for node in heap_data}\n    valid_node_ids = set(heap.keys())\n\n    # Step 2: Initialize data structures for the Mark phase (BFS traversal).\n    # 'marked' will store the set of reachable nodes (M).\n    # 'queue' is the frontier for the BFS.\n    marked = set()\n    queue = collections.deque()\n\n    # Step 3: Populate the initial queue with valid and unique roots.\n    # A root is valid if it exists in the heap (is in valid_node_ids).\n    # The null sentinel (-1) and non-existent IDs are ignored.\n    for root_id in roots:\n        if root_id in valid_node_ids and root_id not in marked:\n            marked.add(root_id)\n            queue.append(root_id)\n\n    # Step 4: Perform the Mark phase using Breadth-First Search (BFS).\n    # Explore the graph starting from the roots, following both 'next' and 'prev' pointers.\n    while queue:\n        current_id = queue.popleft()\n\n        # Retrieve pointers for the current node.\n        next_id, prev_id = heap[current_id]\n\n        # Process neighbors (nodes pointed to by 'next' and 'prev').\n        for neighbor_id in [next_id, prev_id]:\n            # A neighbor is processed only if it's a valid node and has not been marked yet.\n            if neighbor_id in valid_node_ids and neighbor_id not in marked:\n                marked.add(neighbor_id)\n                queue.append(neighbor_id)\n\n    # Step 5: The 'marked' set now contains all survivor IDs.\n    # The 'sweep' phase conceptually removes all other nodes.\n    # The required output is the sorted list of these survivor IDs.\n    survivors = sorted(list(marked))\n    return survivors\n\ndef solve():\n    \"\"\"\n    Runs the garbage collection simulation for all test cases and prints the result\n    in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (simple finite chain)\n        (\n            [(1, 2, -1), (2, 3, 1), (3, -1, 2)],\n            [2]\n        ),\n        # Test case 2 (two components, one isolated)\n        (\n            [(10, 11, -1), (11, -1, 10), (20, -1, -1)],\n            [10]\n        ),\n        # Test case 3 (circular doubly linked list with duplicate roots)\n        (\n            [(30, 31, 32), (31, 32, 30), (32, 30, 31)],\n            [31, 31]\n        ),\n        # Test case 4 (broken pointer to non-existent node)\n        (\n            [(40, 999, -1), (41, 40, -1)],\n            [41]\n        ),\n        # Test case 5 (empty roots)\n        (\n            [(50, 51, -1), (51, -1, 50)],\n            []\n        ),\n        # Test case 6 (self-looping node and a null root entry)\n        (\n            [(60, 60, 60)],\n            [60, -1]\n        ),\n    ]\n\n    formatted_results = []\n    for heap_data, roots in test_cases:\n        survivor_ids = run_gc(heap_data, roots)\n        # Format each list of results as a string \"[id1,id2,...]\" with no spaces.\n        formatted_results.append(f\"[{','.join(map(str, survivor_ids))}]\")\n\n    # Join all formatted strings into the final output format.\n    # e.g., \"[[1,2,3],[10,11]]\"\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the classic mark-and-sweep algorithm is simple, modern systems require collectors that run concurrently with the application to minimize pause times. This introduces significant challenges, as the object graph can change while the collector is traversing it. This practice asks you to play the role of an adversary: devise a sequence of pointer updates that breaks a naive concurrent collector and identify the minimal safeguard—the write barrier—needed to maintain correctness ().",
            "id": "3643335",
            "problem": "Consider a heap modeled as a directed graph $G=(V,E)$ with a designated root set $R\\subseteq V$. An object $x\\in V$ is reachable if and only if there exists a path from some root $r\\in R$ to $x$ using edges in $E$. A Mark-Sweep Garbage Collection (MSGC) marking phase performs a graph traversal from $R$ to discover reachable objects, while the mutator (the application thread) may continue to perform pointer updates during marking. Assume an incremental marking traversal that maintains three color sets over $V$: white (unmarked), gray (marked but not yet scanned), and black (marked and scanned). At the start of marking, all objects are white except roots, which are placed gray, and scanning progresses by repeatedly taking a gray object, visiting its outgoing edges, and coloring it black.\n\nLet the initial heap be as follows. The set of vertices is $V=\\{r,a,b,w\\}$ and the root set is $R=\\{r\\}$. The edge set is $E=\\{(r,a),(r,b),(a,w)\\}$. The collector begins at $r$, colors $r$ black and enqueues $a$ and $b$ gray. It then scans $b$ next, coloring $b$ black. At this moment, $a$ is still gray and $w$ is white.\n\nWhich option below both (i) gives a concrete mutator update sequence that causes the naive MSGC (with no write barrier) to erroneously reclaim a reachable object and (ii) correctly identifies the minimal write barrier needed to preserve reachability correctness under this concurrent marking?\n\nA. After $b$ is black and before $a$ is scanned, the mutator first performs a store that creates the edge $(b,w)$ and then clears the edge $(a,w)$. The minimal barrier is the incremental update barrier that, on a store creating $(x,y)$ with $x$ black and $y$ white, shades $y$ gray.\n\nB. Before $a$ is scanned, the mutator clears the edge $(a,w)$ but performs no other update. The minimal barrier is a snapshot-at-the-beginning deletion barrier that, on overwriting any pointer to a white target $y$, shades $y$ gray.\n\nC. After $b$ is black and before $a$ is scanned, the mutator performs a store that creates $(b,w)$ but leaves $(a,w)$ intact until after $a$ is scanned. The minimal barrier is a read barrier that shades the loaded target gray on every pointer read.\n\nD. While $b$ is gray and before $b$ is scanned, the mutator performs a store that creates $(b,w)$; subsequently, after $b$ is black but before $a$ is scanned, the mutator clears $(a,w)$. The minimal barrier is the incremental update barrier described in option A.\n\nE. After $b$ is black and before $a$ is scanned, the mutator first performs a store that creates $(b,w)$ and then clears $(a,w)$. The minimal barrier is a snapshot-at-the-beginning deletion barrier that shades overwritten white targets gray regardless of the new value.",
            "solution": "We proceed from first principles. Reachability in $G=(V,E)$ with root set $R$ is defined by the existence of a directed path in $E$ from some $r\\in R$ to a node. A correct MSGC must ensure that every reachable node is marked before sweeping, even if the mutator alters $E$ during marking. Tri-color marking assigns one of three colors to each node: white (unseen), gray (discovered but not yet scanned), and black (scanned). The traversal expands gray nodes, marking their targets gray and coloring the source black once all its outgoing edges have been considered.\n\nIn the presence of a mutator, without any coordination, the collector’s traversal can be invalidated if the mutator changes $E$ such that the traversal misses a reachable white node. Two well-established barriers enforce correctness:\n\n- The incremental update barrier (often attributed to Edsger W. Dijkstra): on a pointer store that creates an edge $(x,y)$ where $x$ is black and $y$ is white, shade $y$ gray. This enforces the invariant “no black points to white,” which ensures that all edges out of black nodes either point to already marked objects or immediately force marking.\n\n- The snapshot-at-the-beginning deletion barrier (often attributed to Atsushi Yuasa): on overwriting a pointer to a white target $y$, shade $y$ gray regardless of the new value. This preserves a logical snapshot of the heap at the beginning of marking by ensuring that any white object that was initially reachable cannot be hidden by deletions before being discovered.\n\nWe analyze the given initial configuration. Initially, $R=\\{r\\}$, and $E$ contains $(r,a)$, $(r,b)$, and $(a,w)$. After the collector scans $r$, it marks $r$ black and enqueues $a$ and $b$ gray. Suppose it scans $b$ next and marks $b$ black. At that moment, $a$ is gray and $w$ is white. The path $(r,b)$ exists, and the path $(a,w)$ exists; $w$ is reachable by the path $(r,a),(a,w)$ in the current heap.\n\nWe now consider each option.\n\nOption A: Sequence and barrier\n- Sequence: After $b$ is black and before $a$ is scanned, the mutator first creates $(b,w)$ and then clears $(a,w)$.\n- Effect without a barrier: At the moment of the store creating $(b,w)$, $b$ is black and $w$ is white. This introduces a black-to-white edge, violating the “no black points to white” property. Because the collector will not rescan $b$ (it is already black), it will not discover $w$ via $(b,w)$. Then the mutator removes $(a,w)$ before $a$ is scanned. When $a$ is eventually scanned, it no longer points to $w$, so $w$ remains white. However, $w$ is still reachable via $(r,b)$ followed by $(b,w)$, so the traversal misses a reachable white node. During sweep, $w$ would be erroneously reclaimed despite being reachable, which is a correctness violation.\n- Barrier correctness and minimality: The incremental update barrier would trigger on the store that creates $(b,w)$ with $b$ black and $w$ white, immediately shading $w$ gray. Once gray, $w$ will be discovered and marked regardless of the later deletion of $(a,w)$. This barrier is minimal for this sequence because the precise hazard is the creation of a black-to-white edge; the barrier acts exactly at that event and nowhere else. A deletion barrier would also prevent the violation when $(a,w)$ is cleared (by shading $w$), but it fires on every overwrite of a pointer to a white target, including many cases not implicated here. Therefore, incremental update is the minimal barrier that preserves reachability correctness for this sequence. Verdict — Correct.\n\nOption B: Sequence and barrier\n- Sequence: Before $a$ is scanned, the mutator clears $(a,w)$ and performs no other update.\n- Effect without a barrier: If $(a,w)$ is removed and no edge $(b,w)$ is introduced, then $w$ loses its only incoming path from $R$. $w$ becomes unreachable in the mutated heap. The collector, when scanning $a$, finds no edge to $w$, so $w$ remains white and is reclaimed during sweep, which is correct for the mutated heap. There is no correctness violation.\n- Barrier claim: The option claims the minimal necessary barrier is a deletion barrier. However, because there is no violation in the first place, no barrier is needed to preserve correctness. Verdict — Incorrect.\n\nOption C: Sequence and barrier\n- Sequence: After $b$ is black and before $a$ is scanned, the mutator creates $(b,w)$ but leaves $(a,w)$ intact until after $a$ is scanned.\n- Effect without a barrier: Because $(a,w)$ remains until after $a$ is scanned, the collector will mark $w$ when it scans $a$, turning $w$ gray and eventually black. The extra edge $(b,w)$ does not endanger correctness because $w$ will be discovered via $a$.\n- Barrier claim: The option proposes a read barrier, which fires on pointer loads, shading loaded targets gray. A read barrier is not necessary for reachability correctness in this sequence; the traversal will already find $w$ by scanning $a$. Verdict — Incorrect.\n\nOption D: Sequence and barrier\n- Sequence: While $b$ is gray and before $b$ is scanned, the mutator creates $(b,w)$; subsequently, after $b$ is black but before $a$ is scanned, the mutator clears $(a,w)$.\n- Effect without a barrier: Creating $(b,w)$ while $b$ is gray is safe because $b$ will be scanned, and the collector will discover $w$ via $(b,w)$, marking $w$ gray. Later, clearing $(a,w)$ does not hide $w$ because it has already been marked due to scanning $b$. The traversal remains correct.\n- Barrier claim: Although the option names the incremental update barrier, the sequence does not require it for correctness because the critical store occurs when $b$ is gray, not black. Verdict — Incorrect.\n\nOption E: Sequence and barrier\n- Sequence: This sequence is identical to option A: after $b$ is black and before $a$ is scanned, the mutator creates $(b,w)$ and then clears $(a,w)$.\n- Effect without a barrier: As in option A, this sequence causes a correctness violation by hiding a reachable white node from the traversal.\n- Barrier claim: The option proposes a snapshot-at-the-beginning deletion barrier. This barrier would indeed preserve correctness by shading $w$ when $(a,w)$ is cleared, ensuring $w$ is eventually marked even though $(b,w)$ was created earlier. However, relative to the specific hazard (the creation of a black-to-white edge), this barrier is not minimal; it addresses deletions broadly rather than the precise insertion that causes the tri-color violation. The incremental update barrier from option A is a strictly more targeted and minimal intervention for this sequence. Verdict — Incorrect.\n\nConclusion: Only option A both presents a mutator update sequence that breaks naive concurrent MSGC and identifies the minimal write barrier necessary to preserve reachability correctness for that sequence. The violation arises from creating a black-to-white edge $(b,w)$; shading $w$ on that store via the incremental update barrier is the minimal fix that restores the traversal’s correctness guarantees.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Beyond correctness, the performance of a garbage collector is paramount, often involving a delicate balance between conflicting goals. This exercise shifts our focus to performance engineering, where we use mathematical models to reason about these trade-offs (). You will derive the optimal size for a generational collector's nursery to minimize a combined cost function of pause time and throughput loss, demonstrating how core system parameters can be optimized analytically.",
            "id": "3643388",
            "problem": "Consider a managed runtime using Generational Garbage Collection (GC) with two generations: a nursery and an old generation. The nursery holds newly allocated objects and triggers a minor collection when it becomes full. Assume the following well-tested facts and core definitions:\n\n- Allocations arrive as a Poisson process with rate $\\lambda$ (objects per second). For a Poisson process, the expected time to accumulate $N$ allocations is $N / \\lambda$.\n- Each newly allocated object independently survives the next minor collection with probability $s \\in [0,1]$. This implies a geometric survival pattern across collections, and in particular, the expected number of survivors from a batch of $N$ new allocations at the time of the next minor collection is $sN$.\n- Minor collection pause time has two contributors:\n  1. A fixed root and metadata processing overhead $t_{r} > 0$ that does not depend on $N$.\n  2. Linear costs proportional to nursery size $N$ and survivors $sN$. Let $c_{n} > 0$ be the per-object cost to scan the nursery, and $c_{p} > 0$ be the per-object cost to process and promote each survivor into the old generation.\n\nUnder these assumptions, define the minor collection pause time as a function of the nursery size $N$ by $T(N) = t_{r} + c_{n}N + c_{p}sN$. Because the nursery fills after $N$ allocations, the expected minor collection frequency is $\\lambda / N$, so the expected fraction of wall-clock time spent in minor GC per unit time is $(\\lambda / N) \\cdot T(N)$.\n\nA systems engineer wishes to balance throughput and pause-time latency using a scalar objective that trades off these two quantities. Let $\\alpha > 0$ weight the instantaneous pause time and let $\\beta > 0$ weight the time lost to minor collections per unit time. The engineer’s objective is to choose the nursery size $N$ to minimize\n$$\nJ(N) = \\alpha \\, T(N) + \\beta \\left(\\frac{\\lambda}{N}\\right) T(N).\n$$\n\nAssume $N$ is a positive real variable representing the effective nursery capacity measured in expected number of objects. Derive the value of $N$ that minimizes $J(N)$ and report it as a single closed-form analytic expression in terms of $\\lambda$, $s$, $t_{r}$, $c_{n}$, $c_{p}$, $\\alpha$, and $\\beta$. No approximation or rounding is required in your final expression. Use the symbol $N^{\\star}$ for the optimizer.",
            "solution": "The problem statement is confirmed to be valid as it is scientifically grounded, well-posed, objective, and self-contained. The model presented is a standard and appropriate simplification for analyzing garbage collection performance. We are tasked with finding the nursery size $N$ that minimizes the objective function $J(N)$.\n\nThe objective function $J(N)$ is given by:\n$$J(N) = \\alpha \\, T(N) + \\beta \\left(\\frac{\\lambda}{N}\\right) T(N)$$\nThe minor collection pause time, $T(N)$, is defined as:\n$$T(N) = t_{r} + c_{n}N + c_{p}sN$$\nThe parameters $\\alpha$, $\\beta$, $\\lambda$, $t_{r}$, $c_{n}$, and $c_{p}$ are all specified as positive real numbers, the survival probability $s$ is in the range $[0,1]$, and the nursery size $N$ is treated as a positive real variable.\n\nTo facilitate minimization, we can first factor $T(N)$ out from the expression for $J(N)$:\n$$J(N) = \\left(\\alpha + \\frac{\\beta\\lambda}{N}\\right) T(N)$$\nNow, substitute the expression for $T(N)$:\n$$J(N) = \\left(\\alpha + \\frac{\\beta\\lambda}{N}\\right) (t_{r} + (c_{n} + c_{p}s)N)$$\nExpanding this expression gives:\n$$J(N) = \\alpha t_{r} + \\alpha(c_{n} + c_{p}s)N + \\frac{\\beta \\lambda t_{r}}{N} + \\beta \\lambda (c_{n} + c_{p}s)$$\nTo find the value of $N$ that minimizes $J(N)$, we utilize differential calculus. The minimization requires finding the critical points of $J(N)$ by taking its derivative with respect to $N$ and setting it to zero.\n$$\\frac{dJ}{dN} = \\frac{d}{dN} \\left[ \\alpha t_{r} + \\alpha(c_{n} + c_{p}s)N + \\beta \\lambda t_{r} N^{-1} + \\beta \\lambda(c_{n} + c_{p}s) \\right]$$\nThe terms $\\alpha t_{r}$ and $\\beta \\lambda(c_{n} + c_{p}s)$ are constant with respect to $N$, so their derivatives are $0$. Applying the power rule for differentiation to the terms containing $N$:\n$$\\frac{dJ}{dN} = \\alpha(c_{n} + c_{p}s) - \\beta \\lambda t_{r} N^{-2}$$\nSetting this derivative equal to $0$ to find the optimal nursery size, denoted as $N^{\\star}$:\n$$\\alpha(c_{n} + c_{p}s) - \\frac{\\beta \\lambda t_{r}}{(N^{\\star})^2} = 0$$\nWe now solve this equation for $N^{\\star}$:\n$$\\alpha(c_{n} + c_{p}s) = \\frac{\\beta \\lambda t_{r}}{(N^{\\star})^2}$$\n$$(N^{\\star})^2 = \\frac{\\beta \\lambda t_{r}}{\\alpha(c_{n} + c_{p}s)}$$\nSince $N$ represents a physical capacity, it must be a positive value. Thus, we take the positive square root to find $N^{\\star}$:\n$$N^{\\star} = \\sqrt{\\frac{\\beta \\lambda t_{r}}{\\alpha(c_{n} + c_{p}s)}}$$\nTo confirm that this critical point corresponds to a minimum, we must analyze the second derivative of $J(N)$:\n$$\\frac{d^2J}{dN^2} = \\frac{d}{dN} \\left( \\alpha(c_{n} + c_{p}s) - \\beta \\lambda t_{r} N^{-2} \\right)$$\n$$\\frac{d^2J}{dN^2} = -(-2) \\beta \\lambda t_{r} N^{-3} = \\frac{2 \\beta \\lambda t_{r}}{N^3}$$\nAccording to the problem statement, the parameters $\\beta$, $\\lambda$, and $t_{r}$ are all strictly positive. The nursery size $N$ must also be positive. Consequently, for all $N > 0$, the second derivative is positive:\n$$\\frac{d^2J}{dN^2} > 0$$\nA positive second derivative indicates that the function $J(N)$ is strictly convex for $N > 0$. Therefore, the critical point $N^{\\star}$ that we have found corresponds to a unique global minimum.",
            "answer": "$$\n\\boxed{\\sqrt{\\frac{\\beta \\lambda t_{r}}{\\alpha (c_{n} + c_{p}s)}}}\n$$"
        }
    ]
}