{
    "hands_on_practices": [
        {
            "introduction": "At the heart of any function call is the faithful transfer of data, but this process is filled with subtle details. When a small data type like an 8-bit integer is passed in a wider 32-bit register, the Application Binary Interface (ABI) must precisely define how the extra bits are filled. This exercise  simulates the critical rules of integer promotion—sign versus zero extension—and demonstrates how a robust function prologue can correct for ABI violations, preventing subtle and dangerous bugs. By building this simulator, you will gain a concrete understanding of how data integrity is maintained across function boundaries.",
            "id": "3626585",
            "problem": "Design and implement a small, self-contained simulator that formalizes an Application Binary Interface (ABI) rule for small integer promotion in a calling sequence, and then detects and repairs mismatches when callers pass $8$-bit values. Your program must codify the ABI’s canonical rule, simulate caller behavior (correct and incorrect), model callee interpretation, and apply a principled callee prologue fixup to recover the mathematically intended value.\n\nFundamental base and definitions:\n- An Application Binary Interface (ABI) is a contract governing how values are passed across function boundaries. The ABI you must implement adopts a canonical integer register width of $W_c = 32$ bits.\n- For any argument whose declared width is $w \\le 8$ bits, the caller must promote the value to $W_c$ bits according to the declared signedness:\n  - If the declared type is unsigned, the caller must perform zero extension from $w$ bits to $W_c$ bits.\n  - If the declared type is signed (two’s complement), the caller must perform sign extension from $w$ bits to $W_c$ bits.\n- Two’s complement sign extension from $w$ bits to $W_c$ bits is defined by the following function: for any integer $x$ represented in $w$ bits,\n  $$\n  \\operatorname{exts}_{w \\to W_c}(x) =\n  \\begin{cases}\n  x,  \\text{if the most significant bit of } x \\text{ is } 0,\\\\\n  x \\mid \\big(\\text{all ones in bits } [w, W_c-1]\\big),  \\text{if the most significant bit of } x \\text{ is } 1.\n  \\end{cases}\n  $$\n  For $w = 8$ and $W_c = 32$, this is equivalent to: if $(x \\ \\ \\ 2^7) \\ne 0$ then $x \\mid \\left(\\sum_{i=8}^{31} 2^i\\right)$ else $x$.\n- Zero extension from $w$ bits to $W_c$ bits is defined as\n  $$\n  \\operatorname{extz}_{w \\to W_c}(x) = x \\ \\ \\ \\left(\\sum_{i=0}^{w-1} 2^i\\right).\n  $$\n\nCaller and callee model:\n- Let the source $8$-bit payload be $v_8 \\in \\{0, 1, \\dots, 255\\}$.\n- The mathematically intended value according to the callee’s parameter type is:\n  - If the callee expects signed $8$-bit, the intended $32$-bit value is $V_{\\text{intended}} = \\operatorname{exts}_{8 \\to 32}(v_8)$, representing the integer in $\\mathbb{Z}$ encoded in two’s complement within $32$ bits.\n  - If the callee expects unsigned $8$-bit, the intended $32$-bit value is $V_{\\text{intended}} = \\operatorname{extz}_{8 \\to 32}(v_8)$.\n- The caller places a raw $32$-bit register value $R$ according to one of three behaviors:\n  1. Correct zero extension: $R = \\operatorname{extz}_{8 \\to 32}(v_8)$.\n  2. Correct sign extension: $R = \\operatorname{exts}_{8 \\to 32}(v_8)$.\n  3. Raw unextended: $R = (H \\ll 8) \\mid (v_8 \\ \\ \\ 255)$, where $H$ is a $24$-bit pattern potentially left over in bits $[8,31]$, and $\\ll$ denotes logical left shift.\n- The callee’s naive interpretation (without fixup) is:\n  - If the callee expects signed, interpret $R$ as a signed $32$-bit two’s complement integer, giving $V_{\\text{before}}$.\n  - If the callee expects unsigned, interpret $R$ as an unsigned $32$-bit integer, giving $V_{\\text{before}}$.\n- The callee’s prologue fixup you must implement is the canonical repair for small-integer promotion mismatches:\n  $$\n  V_{\\text{after}} = \n  \\begin{cases}\n  \\operatorname{exts}_{8 \\to 32}(R \\ \\ \\ 255),  \\text{if callee expects signed},\\\\\n  \\operatorname{extz}_{8 \\to 32}(R \\ \\ \\ 255),  \\text{if callee expects unsigned}.\n  \\end{cases}\n  $$\n  This corresponds to masking the low $8$ bits and re-extending according to the callee’s declared signedness. This fixup is idempotent if the caller already followed the ABI.\n\nClassification to output for each test case:\n- Let $C$ be the classification code defined by:\n  - $C = 0$ if $V_{\\text{before}} = V_{\\text{intended}}$ and $V_{\\text{after}} = V_{\\text{intended}}$.\n  - $C = 1$ if $V_{\\text{before}} \\ne V_{\\text{intended}}$ but $V_{\\text{after}} = V_{\\text{intended}}$.\n  - $C = 2$ if $V_{\\text{after}} \\ne V_{\\text{intended}}$ (unrepaired bug).\n  - $C = 3$ if $V_{\\text{before}} = V_{\\text{intended}}$ but $V_{\\text{after}} \\ne V_{\\text{intended}}$ (a regression due to fixup; this should not occur with the stated fix).\n\nTest suite:\nEach test case is a tuple $(v_8, m, s, H)$ where $v_8$ is the $8$-bit payload, $m \\in \\{0, 1, 2\\}$ is the caller mode with $0$ meaning zero extend, $1$ meaning sign extend, $2$ meaning raw unextended, $s \\in \\{0, 1\\}$ indicates the callee expects unsigned $(0)$ or signed $(1)$ semantics, and $H$ is the $24$-bit high pattern used only when $m=2$ (otherwise ignored). Use the following eight cases:\n1. $(v_8 = 5, m = 0, s = 0, H = 0)$\n2. $(v_8 = 200, m = 0, s = 1, H = 0)$\n3. $(v_8 = 128, m = 1, s = 0, H = 0)$\n4. $(v_8 = 127, m = 1, s = 1, H = 0)$\n5. $(v_8 = 255, m = 0, s = 1, H = 0)$\n6. $(v_8 = 42, m = 2, s = 0, H = 0x55AA77)$\n7. $(v_8 = 200, m = 2, s = 1, H = 0x00F0F0)$\n8. $(v_8 = 0, m = 2, s = 0, H = 0x123456)$\n\nWhat your program must do:\n- Hard-code the above test suite.\n- For each test case, construct $R$ according to $m$ and $H$.\n- Compute $V_{\\text{intended}}$ from $v_8$ and $s$.\n- Compute $V_{\\text{before}}$ from $R$ and $s$.\n- Compute $V_{\\text{after}}$ from the specified fixup.\n- Produce a classification code $C$ for each test case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of the eight integer classification codes enclosed in square brackets. For example, an output of the form $[c_1,c_2,c_3,c_4,c_5,c_6,c_7,c_8]$ where each $c_i$ is one of $\\{0,1,2,3\\}$.\n\nNo input is to be read. No external files or network access are permitted. All internal computations must be performed using integer arithmetic consistent with the above definitions. All angles, physical units, or percentages are not applicable to this problem; all numerical values are unitless integers.",
            "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of computer architecture and compiler design, specifically concerning integer representations and Application Binary Interfaces (ABIs). The problem is well-posed, with all terms, conditions, and test cases defined explicitly and without contradiction. It represents a formalizable and verifiable simulation task.\n\nThe task is to simulate an ABI rule for passing small integer arguments, detect violations, and model a callee-side fixup mechanism. The simulation will be performed for a specific test suite, and the outcome of each test will be categorized.\n\nThe fundamental principles are rooted in integer arithmetic and bit-level representation. The canonical register width is specified as $W_c = 32$ bits. We are concerned with an $8$-bit source payload, $v_8$.\n\nThe ABI dictates that such small integer arguments must be \"promoted\" to the full register width $W_c$ by the caller. The promotion rule depends on the declared signedness of the function parameter.\n1.  **Zero Extension**: For an unsigned parameter, the value $v_8$ is extended to $32$ bits by padding the most significant $24$ bits with zeros. This is formally defined as $\\operatorname{extz}_{8 \\to 32}(v_8)$.\n2.  **Sign Extension**: For a signed parameter, the value is extended based on its most significant bit (MSB) at position $7$. If the MSB is $0$, the value is treated as positive and zero-extended. If the MSB is $1$, the value is treated as negative (in two's complement) and extended by padding the most significant $24$ bits with ones. This is formally defined as $\\operatorname{exts}_{8 \\to 32}(v_8)$.\n\nThe simulation models a caller, which may or may not adhere to this ABI, and a callee, which interprets the received register value.\n-   The **intended value**, $V_{\\text{intended}}$, is what the callee should receive if the caller correctly follows the ABI. It is either $\\operatorname{extz}_{8 \\to 32}(v_8)$ or $\\operatorname{exts}_{8 \\to 32}(v_8)$, depending on the callee's expectation.\n-   The **raw register value**, $R$, is a $32$-bit pattern placed in a register by the caller. The caller might correctly extend the value, incorrectly extend it (e.g., zero-extend a signed value), or pass it unextended, leaving high-order bits in an indeterminate state (garbage).\n-   The **value before fixup**, $V_{\\text{before}}$, is the callee's naive interpretation of the raw register $R$, casting it to its expected signed or unsigned $32$-bit type.\n-   The **value after fixup**, $V_{\\text{after}}$, is the result of applying a canonical repair sequence in the function prologue. This fixup is defined as masking the low $8$ bits of the received register $R$ and re-applying the correct extension rule based on the callee's expectation: $\\operatorname{exts}_{8 \\to 32}(R \\ \\ \\ 255)$ or $\\operatorname{extz}_{8 \\to 32}(R \\ \\ \\ 255)$.\n\nThe simulation will classify each test case into one of four categories ($C \\in \\{0, 1, 2, 3\\}$) by comparing $V_{\\text{intended}}$, $V_{\\text{before}}$, and $V_{\\text{after}}$.\n\nIn the C implementation, we use fixed-width integer types to accurately model the bit-level operations. Specifically, `unsigned char` represents the $8$-bit payload $v_8$, and `unsigned int` and `signed int` represent the $32$-bit register values and interpreted integers, with `_Static_assert` used to guarantee their sizes.\n\nThe extension functions are implemented using C's type casting rules, which directly map to the desired machine-level operations:\n-   `exts_8_to_32(x)` is implemented by casting an `unsigned char` to `signed char`, and then to `signed int`. The promotion from `signed char` to `signed int` performs the sign extension.\n-   `extz_8_to_32(x)` is implemented by casting an `unsigned char` to `unsigned int`. This promotion pads the higher-order bits with zeros.\n\nAs a representative example, let us analyze Test Case 2: $(v_8 = 200, m = 0, s = 1, H = 0)$.\n-   **Givens**: The payload is $v_8 = 200$ ($0xC8$). The caller mode is $m=0$, meaning the caller performs zero extension. The callee expectation is $s=1$, meaning it expects a signed value. This is an ABI mismatch: the callee expects a sign-extended value, but the caller provides a zero-extended one.\n-   **Intended Value ($V_{\\text{intended}}$)**: The callee expects a signed value, so the intended value is the sign extension of $v_8$. As an $8$-bit signed integer, $200$ represents $200 - 256 = -56$.\n    $$V_{\\text{intended}} = \\operatorname{exts}_{8 \\to 32}(200) = -56$$\n    In $32$-bit two's complement, this is $0xFFFFFFC8$.\n-   **Register Value ($R$)**: The caller performs zero extension.\n    $$R = \\operatorname{extz}_{8 \\to 32}(200) = 200$$\n    The bit pattern in the register is $0x000000C8$.\n-   **Value Before Fixup ($V_{\\text{before}}$)**: The callee naively interprets the register $R$ as a signed $32$-bit integer.\n    $$V_{\\text{before}} = (\\text{signed})0x000000C8 = 200$$\n-   **Value After Fixup ($V_{\\text{after}}$)**: The callee applies the fixup for a signed parameter. It masks the low $8$ bits of $R$ and re-applies sign extension.\n    $$V_{\\text{after}} = \\operatorname{exts}_{8 \\to 32}(R \\ \\ \\ 255) = \\operatorname{exts}_{8 \\to 32}(0x000000C8 \\ \\ \\ 255) = \\operatorname{exts}_{8 \\to 32}(200) = -56$$\n-   **Classification ($C$)**:\n    -   Is $V_{\\text{before}} = V_{\\text{intended}}$? No, $200 \\ne -56$.\n    -   Is $V_{\\text{after}} = V_{\\text{intended}}$? Yes, $-56 = -56$.\n    -   The condition is ($V_{\\text{before}} \\ne V_{\\text{intended}}$ and $V_{\\text{after}} = V_{\\text{intended}}$), which corresponds to $C=1$. The ABI mismatch caused an incorrect interpretation, but the callee-side fixup successfully recovered the intended value.\n\nThis analysis is repeated for all eight test cases. The fixup mechanism proves robust, as it always re-derives the payload from the low $8$ bits of the register ($R \\ \\ \\ 255$ is always equal to $v_8$) and correctly re-extends it. Consequently, $V_{\\text{after}}$ is always equal to $V_{\\text{intended}}$, and classifications $C=2$ and $C=3$ never occur.",
            "answer": "```c\n// The complete and compilable C program.\n// Headers adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n// #include string.h // Not used\n// #include math.h   // Not used\n// #include complex.h // Not used\n// #include threads.h // Not used\n// #include stdatomic.h // Not used\n\n// Per C23 standard, these assertions can validate type sizes.\n// This ensures our simulation correctly models 8-bit and 32-bit quantities.\n#if __STDC_VERSION__ = 201112L\n_Static_assert(sizeof(unsigned char) == 1, \"Type 'unsigned char' must be 8 bits.\");\n_Static_assert(sizeof(signed char) == 1, \"Type 'signed char' must be 8 bits.\");\n_Static_assert(sizeof(unsigned int) == 4, \"Type 'unsigned int' must be 32 bits.\");\n_Static_assert(sizeof(signed int) == 4, \"Type 'signed int' must be 32 bits.\");\n#endif\n\n// Type definitions for clarity and precision.\ntypedef unsigned char u8;\ntypedef signed char   i8;\ntypedef unsigned int  u32;\ntypedef signed int    i32;\ntypedef _Bool bool_t; // C23 has `bool` but stdbool.h is not on the allowed list. _Bool is a keyword.\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    u8 v8; // 8-bit payload\n    int m; // Caller mode: 0=zero-extend, 1=sign-extend, 2=raw\n    int s; // Callee expectation: 0=unsigned, 1=signed\n    u32 H; // 24-bit high pattern for raw mode\n} TestCase;\n\n// Implements sign extension from 8 to 32 bits.\n// In C, casting from a signed small type to a signed larger type\n// preserves the numerical value, which means sign extension is performed.\ni32 exts_8_to_32(u8 x) {\n    return (i32)(i8)x;\n}\n\n// Implements zero extension from 8 to 32 bits.\n// In C, casting from an unsigned small type to an unsigned larger type\n// pads the higher-order bits with zero.\nu32 extz_8_to_32(u8 x) {\n    return (u32)x;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {5,   0, 0, 0x0},\n        {200, 0, 1, 0x0},\n        {128, 1, 0, 0x0},\n        {127, 1, 1, 0x0},\n        {255, 0, 1, 0x0},\n        {42,  2, 0, 0x55AA77},\n        {200, 2, 1, 0x00F0F0},\n        {0,   2, 0, 0x123456}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        u32 R; // The 32-bit raw value in the register\n\n        // 1. Construct the register value R based on the caller's mode 'm'.\n        switch (tc.m) {\n            case 0: // Correct zero extension\n                R = extz_8_to_32(tc.v8);\n                break;\n            case 1: // Correct sign extension\n                // The C cast to u32 preserves the bit pattern of the signed extended value.\n                R = (u32)exts_8_to_32(tc.v8);\n                break;\n            case 2: // Raw unextended, with high bits containing garbage 'H'\n                R = (tc.H  8) | tc.v8;\n                break;\n            default: // Should not happen\n                R = 0;\n                break;\n        }\n\n        // 2. Determine intended, before, and after values to classify the interaction.\n        if (tc.s == 1) { // Callee expects a SIGNED value.\n            i32 v_intended = exts_8_to_32(tc.v8);\n            i32 v_before = (i32)R; // Naive interpretation of R as signed.\n            i32 v_after = exts_8_to_32((u8)(R  0xFF)); // Fixup: mask and re-extend.\n\n            bool_t before_ok = (v_before == v_intended);\n            bool_t after_ok = (v_after == v_intended);\n\n            if (before_ok  after_ok) {\n                results[i] = 0;\n            } else if (!before_ok  after_ok) {\n                results[i] = 1;\n            } else if (!after_ok) {\n                results[i] = 2;\n            } else { // before_ok  !after_ok\n                results[i] = 3;\n            }\n        } else { // Callee expects an UNSIGNED value.\n            u32 v_intended = extz_8_to_32(tc.v8);\n            u32 v_before = R; // Naive interpretation of R as unsigned.\n            u32 v_after = extz_8_to_32((u8)(R  0xFF)); // Fixup: mask and re-extend.\n\n            bool_t before_ok = (v_before == v_intended);\n            bool_t after_ok = (v_after == v_intended);\n\n            if (before_ok  after_ok) {\n                results[i] = 0;\n            } else if (!before_ok  after_ok) {\n                results[i] = 1;\n            } else if (!after_ok) {\n                results[i] = 2;\n            } else { // before_ok  !after_ok\n                results[i] = 3;\n            }\n        }\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Modern languages increasingly support functions that return multiple values, a feature that must be efficiently supported by the calling convention. While returning values in registers is fast, it consumes a limited and precious resource. This practice  challenges you to quantify the impact of multi-value returns on register pressure, the demand for registers at a given point in a program. You will calculate the exact point at which returning additional values forces the compiler to spill data to memory, revealing a fundamental trade-off between language features and hardware constraints.",
            "id": "3626503",
            "problem": "A compiler backend for a Reduced Instruction Set Computer (RISC) architecture implements a calling convention under an Application Binary Interface (ABI) that must support multi-value returns without tuple packing. The machine has $R=16$ integer registers labeled $r_0,\\dots,r_{15}$. The ABI partitions registers as follows: $C=8$ caller-saved registers ($r_0$ through $r_7$), $S=4$ callee-saved registers ($r_8$ through $r_{11}$), and $3$ reserved registers ($r_{12}$ is the stack pointer, $r_{13}$ is the frame pointer, $r_{14}$ is the return address). The dedicated return registers are $v_0=r_0$, $v_1=r_1$, $v_2=r_2$, and $v_3=r_3$. Within a basic block, the register allocator has $R_{\\mathrm{alloc}}=10$ general-purpose registers available for holding live temporaries at any program point.\n\nYou are asked to develop a calling sequence that supports returning $k$ values, denoted $(r_1,\\dots,r_k)$, for $k \\in \\{1,2,3,4\\}$, without tuple packing; each value must be returned in its own dedicated register among $\\{v_0,v_1,v_2,v_3\\}$. The design must respect the ABI: the callee must preserve callee-saved registers it uses, and the caller must assume caller-saved registers are clobbered by the call.\n\nConsider a basic block $B$ containing a single call instruction to a function $f$ that returns $k$ values. Immediately before the call in $B$, there are $t_{\\mathrm{pre}}=9$ live temporaries; of these, $c=5$ are live across the call (they are live-out of the call site). Immediately after the call, in addition to the $c$ across-call live temporaries, there are $b=3$ new live temporaries introduced by subsequent operations in $B$. In a hypothetical tuple-packing design, the $k$ returned values would be represented by a single aggregated entity in one register; however, in your no-packing multi-return design, each returned value occupies its own return register, contributing individually to register pressure.\n\nUsing the fundamental definition that the register pressure at a program point is the cardinality of the live set at that point, and the liveness fact that a value is live at a program point if it is used along some path after that point before being overwritten, derive an expression for the maximum instantaneous register pressure at the point immediately after the call in $B$ as a function of $k$ under your no-packing design. Then, relative to the tuple-packing baseline (where the returns occupy one register regardless of $k$), quantify the spill slots required at that point under the constraint $R_{\\mathrm{alloc}}=10$ by computing the nonnegative difference between the required live registers and $R_{\\mathrm{alloc}}$.\n\nProvide the vector of spill slot counts for $k=1,2,3,4$ as your final answer, using the row matrix format. No rounding is required.",
            "solution": "The problem statement describes a scenario in compiler design concerning register allocation and calling conventions. Before proceeding to a solution, a critical validation of the problem's premises is required.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\nThe explicit information provided in the problem statement is as follows:\n- Total integer registers: $R=16$, labeled $r_0, \\dots, r_{15}$.\n- Caller-saved registers: $C=8$ ($r_0$ through $r_7$).\n- Callee-saved registers: $S=4$ ($r_8$ through $r_{11}$).\n- Reserved registers: $3$ ($r_{12}$ as Stack Pointer, $r_{13}$ as Frame Pointer, $r_{14}$ as Return Address).\n- Dedicated return registers: a set of $4$ registers $\\{v_0, v_1, v_2, v_3\\}$, where $v_0=r_0, v_1=r_1, v_2=r_2, v_3=r_3$.\n- General-purpose registers available to the allocator: $R_{\\mathrm{alloc}}=10$.\n- Number of values returned by function $f$: $k \\in \\{1, 2, 3, 4\\}$.\n- Design constraint: No tuple packing for return values.\n- Number of live temporaries immediately before the call: $t_{\\mathrm{pre}}=9$.\n- Number of temporaries live across the call: $c=5$.\n- Number of new live temporaries introduced by operations subsequent to the call: $b=3$.\n- Definition of register pressure: Cardinality of the live set at a program point.\n- Definition of liveness: A value is live if it will be used before being overwritten.\n- Objective: Calculate the number of spill slots required at the point of maximum pressure after the call, for each value of $k$. The number of spills is defined as the nonnegative difference between the register pressure and $R_{\\mathrm{alloc}}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of compiler theory, specifically code generation and optimization. The concepts of ABIs, calling conventions, register pressure, and liveness analysis are standard and well-defined. The register model is a plausible simplification of a real RISC architecture.\n\nThe problem is well-posed and objective. It provides all necessary numerical data and definitions to derive a unique solution. The phrasing \"maximum instantaneous register pressure at the point immediately after the call\" might seem slightly ambiguous. Strictly, at the program point *immediately* following the call instruction, only the across-call variables and the newly returned values are live. However, the mention of \"$b=3$ new live temporaries introduced by subsequent operations\" suggests that the problem is concerned with the point of highest register need in the segment of the basic block following the call. This peak pressure occurs at a point after the call and after the definitions of these new temporaries, but before the last uses of the various live values. This is a common simplification in such problems to avoid specifying a detailed instruction sequence. Under this reasonable interpretation, the problem is internally consistent and solvable. It is not incomplete, contradictory, or reliant on pseudoscience.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution can be formulated.\n\n### Solution\n\nThe primary task is to determine the number of spill slots required for different numbers of return values, $k$. A spill slot is needed for each live variable that cannot be assigned a register. The number of required spill slots, which we denote as $N_{\\mathrm{spill}}$, is the excess of register pressure over the number of available registers.\n\nThe register pressure, $P$, at a program point is the number of variables that are simultaneously live at that point. The problem asks for the maximum instantaneous pressure in the basic block after the call to function $f$. We interpret this as the point where the number of live variables is at its peak. This set of live variables comprises three distinct groups:\n1.  The set of temporaries that are live across the call site. Their values are computed before the call and are needed after the call. The number of such temporaries is given as $c=5$.\n2.  The set of values returned by the function $f$. Since there is no tuple packing, each of the $k$ returned values is an independent live variable immediately after the call. Their number is $k$.\n3.  The set of new temporaries introduced by operations that occur after the call. The problem states there are $b=3$ such temporaries. To achieve maximum pressure, we consider the point after these $b$ temporaries have been defined but before they, or any of the other $c+k$ live variables, have been used for the last time.\n\nAssuming these three sets of variables are all live at the point of maximum pressure, the total register pressure, $P(k)$, is the sum of their cardinalities:\n$$P(k) = c + b + k$$\nSubstituting the given values $c=5$ and $b=3$:\n$$P(k) = 5 + 3 + k = 8 + k$$\n\nThe register allocator has $R_{\\mathrm{alloc}}=10$ registers at its disposal. Spilling is necessary if the register pressure $P(k)$ exceeds $R_{\\mathrm{alloc}}$. The number of spill slots required, $N_{\\mathrm{spill}}(k)$, is the number of live variables that cannot be accommodated in these registers. This is given by the nonnegative difference between the pressure and the available registers:\n$$N_{\\mathrm{spill}}(k) = \\max(0, P(k) - R_{\\mathrm{alloc}})$$\nSubstituting the expressions for $P(k)$ and $R_{\\mathrm{alloc}}$:\n$$N_{\\mathrm{spill}}(k) = \\max(0, (8 + k) - 10)$$\n$$N_{\\mathrm{spill}}(k) = \\max(0, k - 2)$$\n\nWe are asked to compute this quantity for $k \\in \\{1, 2, 3, 4\\}$.\n\nFor $k=1$:\n$$N_{\\mathrm{spill}}(1) = \\max(0, 1 - 2) = \\max(0, -1) = 0$$\n\nFor $k=2$:\n$$N_{\\mathrm{spill}}(2) = \\max(0, 2 - 2) = \\max(0, 0) = 0$$\n\nFor $k=3$:\n$$N_{\\mathrm{spill}}(3) = \\max(0, 3 - 2) = \\max(0, 1) = 1$$\n\nFor $k=4$:\n$$N_{\\mathrm{spill}}(4) = \\max(0, 4 - 2) = \\max(0, 2) = 2$$\n\nThe resulting vector of spill slot counts for $k=1, 2, 3, 4$ is $(0, 0, 1, 2)$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 0  0  1  2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Beyond registers, the stack is the workhorse for passing arguments, saving state, and allocating local variables. However, using the stack requires careful management, as modern hardware imposes strict alignment rules for optimal performance. In this exercise , you will model the step-by-step changes to the stack pointer during a function call and diagnose potential misalignments. By calculating the necessary \"alignment shim,\" you'll learn how a compiler's function prologue ensures that memory operations, especially high-performance vector loads, meet the architecture's requirements.",
            "id": "3626519",
            "problem": "You are tasked with designing and analyzing a simplified calling sequence for a function under an Application Binary Interface (ABI). The goal is to reason from first principles about how the stack pointer alignment interacts with passing complex numbers and the function prologue. You must write a complete program that, given a small set of test cases, computes whether a function would perform misaligned vector loads in its prologue and determines the minimal alignment shim to avoid them.\n\nThe foundational base for this problem is as follows:\n\n- The Application Binary Interface (ABI) specifies calling conventions, including how arguments are passed and how the stack pointer is managed.\n- On a conventional $x86\\_64$-like architecture, the stack grows downward. Executing a call instruction atomically pushes the return address, consuming $8$ bytes of stack space.\n- Preserving callee-saved registers in a function prologue is modeled as a sequence of push operations, each consuming $8$ bytes.\n- A complex number can be passed either in registers (no stack space consumption for the argument itself) or on the stack as a contiguous block of $Z$ bytes, where $Z$ is the size of the complex type (for example, $8$ for a single-precision complex and $16$ for a double-precision complex).\n- Vector loads in the prologue require the stack pointer to satisfy an alignment of $A$ bytes, expressed as a condition on the congruence class $SP \\bmod A$.\n\nYou must:\n\n- Model the effect on the stack pointer $SP$ of the following events, in order: stack-passed arguments consumption, the call instruction pushing the return address, and callee prologue pushes.\n- Determine whether, at the point immediately before any explicit alignment padding, a vector load requiring $A$-byte alignment would be misaligned. That is, determine if the congruence class $SP \\bmod A$ at that point is nonzero.\n- Compute the minimal alignment shim in bytes, constrained to multiples of $8$, that the callee can subtract from $SP$ in its prologue so that the subsequent vector loads are aligned to $A$ bytes.\n\nYour program must implement the above logic and produce the required results for the following test suite. Each test case specifies:\n- $SP\\_0$: the initial congruence class of the caller's stack pointer modulo $A$ before any arguments are placed or the call occurs, expressed as an integer in $[0, A)$ that is a multiple of $8$.\n- $M$: the complex passing mode, with $M = 0$ meaning the complex number is passed in registers and $M = 1$ meaning the complex number is passed on the stack.\n- $Z$: the byte size of the complex argument.\n- $K$: the number of callee-saved registers pushed in the prologue, each push consuming $8$ bytes.\n- $A$: the alignment requirement in bytes for vector loads in the prologue.\n\nTest suite:\n1. $SP\\_0 = 0$, $M = 0$, $Z = 16$, $K = 0$, $A = 16$.\n2. $SP\\_0 = 0$, $M = 1$, $Z = 16$, $K = 1$, $A = 16$.\n3. $SP\\_0 = 8$, $M = 0$, $Z = 8$, $K = 0$, $A = 16$.\n4. $SP\\_0 = 0$, $M = 1$, $Z = 16$, $K = 0$, $A = 32$.\n5. $SP\\_0 = 8$, $M = 0$, $Z = 8$, $K = 2$, $A = 32$.\n\nFor each test case, your program must compute:\n- A boolean misalignment risk indicator $R$, where $R = 1$ if the vector load would be misaligned immediately before applying any explicit shim in the prologue, and $R = 0$ otherwise.\n- The minimal shim $S$ in bytes, constrained to multiples of $8$, that the callee must subtract from $SP$ in the prologue to achieve $A$-byte alignment for the vector loads.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of pairs enclosed in square brackets. Each pair is of the form $[R, S]$ corresponding to the test cases in the given order. For example, the output format must be exactly like:\n\"[[R\\_1,S\\_1],[R\\_2,S\\_2],[R\\_3,S\\_3],[R\\_4,S\\_4],[R\\_5,S\\_5]]\"",
            "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded in the principles of computer architecture and compiler design, is well-posed, objective, and contains all necessary information to derive a unique and meaningful solution. The problem describes a simplified but coherent model of a function calling sequence, suitable for formal analysis.\n\nThe solution proceeds by first principles, modeling the state of the stack pointer ($SP$) through the sequence of operations defined by the simplified Application Binary Interface (ABI). The stack is assumed to grow towards lower memory addresses, meaning that allocating space on the stack involves decrementing the $SP$ value.\n\nLet $SP_{caller}$ be the value of the caller's stack pointer before it prepares the arguments for the function call. We are given its congruence class modulo the alignment requirement $A$, denoted as $SP\\_0$.\n$$\nSP_{caller} \\equiv SP\\_0 \\pmod{A}\n$$\nThe evolution of the stack pointer is as follows:\n\n1.  **Argument Passing**: The caller function prepares the arguments. If the complex number argument is passed on the stack ($M=1$), the caller allocates $Z$ bytes for it, decrementing the stack pointer. If it is passed in registers ($M=0$), the stack pointer is unaffected by this argument. The change in $SP$ due to argument passing is $- M \\times Z$. The stack pointer becomes $SP_{pre-call}$.\n    $$\n    SP_{pre-call} = SP_{caller} - M \\times Z\n    $$\n\n2.  **`call` Instruction**: The processor's `call` instruction pushes the $8$-byte return address onto the stack before transferring control to the callee. This decrements the stack pointer by $8$. The stack pointer upon entry into the callee function is $SP_{entry}$.\n    $$\n    SP_{entry} = SP_{pre-call} - 8 = SP_{caller} - M \\times Z - 8\n    $$\n\n3.  **Callee Prologue**: Inside the callee, the function prologue saves $K$ callee-saved registers to the stack. Each `push` operation consumes $8$ bytes. This decrements the stack pointer by a total of $K \\times 8$ bytes. The stack pointer value immediately after the register-saving pushes, and just before any explicit alignment shim is applied, is denoted $SP_{prologue}$. This is the address at which vector loads are assumed to occur, and which therefore must be aligned.\n    $$\n    SP_{prologue} = SP_{entry} - K \\times 8 = SP_{caller} - M \\times Z - 8 - K \\times 8\n    $$\n    This can be expressed as:\n    $$\n    SP_{prologue} = SP_{caller} - (M \\times Z + 8 \\times (1 + K))\n    $$\n\nTo determine alignment, we analyze the congruence class of $SP_{prologue}$ modulo $A$. Let $\\Delta$ be the total decrement from $SP_{caller}$:\n$$\n\\Delta = M \\times Z + 8(1 + K)\n$$\nThen, the congruence class of $SP_{prologue}$ is:\n$$\nSP_{prologue} \\pmod{A} \\equiv (SP_{caller} - \\Delta) \\pmod{A}\n$$\nSubstituting the given initial condition $SP_{caller} \\equiv SP\\_0 \\pmod{A}$:\n$$\nSP_{prologue} \\pmod{A} \\equiv (SP\\_0 - \\Delta) \\pmod{A}\n$$\nLet $C$ be this final congruence class, where $C \\in [0, A-1]$.\n$$\nC = (SP\\_0 - \\Delta) \\pmod{A}\n$$\nFor computational implementation, care must be taken with the modulo operator on negative numbers. A robust calculation for $C$ is $C = (SP\\_0 - (\\Delta \\pmod{A}) + A) \\pmod{A}$.\n\nThe two required outputs are then determined from $C$:\n\n-   **Misalignment Risk ($R$)**: A misalignment occurs if $SP_{prologue}$ is not a multiple of $A$, which is true if and only if its congruence class $C$ is non-zero.\n    $$\n    R = \\begin{cases} 1  \\text{if } C \\neq 0 \\\\ 0  \\text{if } C = 0 \\end{cases}\n    $$\n\n-   **Minimal Alignment Shim ($S$)**: We need to find the smallest non-negative shim $S$, which must be a multiple of $8$, to subtract from $SP_{prologue}$ to achieve alignment. The new stack pointer $SP_{final} = SP_{prologue} - S$ must satisfy $SP_{final} \\equiv 0 \\pmod{A}$.\n    $$\n    (SP_{prologue} - S) \\pmod{A} = 0 \\implies (C - S) \\pmod{A} = 0 \\implies S \\equiv C \\pmod{A}\n    $$\n    The minimal non-negative solution is $S = C$. We must verify that this value of $S$ is a multiple of $8$. The problem states that $SP\\_0$, $Z$, and the size of a `push` operation ($8$ bytes) are all multiples of $8$. Therefore, the total decrement $\\Delta = M \\times Z + 8(1+K)$ is a sum of multiples of $8$, and is itself a multiple of $8$. The congruence class $C$ is calculated as $C \\equiv (SP\\_0 - \\Delta) \\pmod{A}$. Since $SP\\_0$ and $\\Delta$ are multiples of $8$, their difference $(SP\\_0 - \\Delta)$ is also a multiple of $8$. The value $C$ is $(SP\\_0 - \\Delta) - n \\cdot A$ for some integer $n$. The alignment requirement $A$ for all test cases ($16, 32$) is a multiple of $8$. Thus, $C$ must also be a multiple of $8$. The minimal non-negative shim $S$ is therefore simply $S=C$, which satisfies all constraints.\n\nWe now apply this methodology to each test case.\n\n**Test Case 1**: $SP\\_0 = 0, M = 0, Z = 16, K = 0, A = 16$.\n-   $\\Delta = (0 \\times 16) + 8 \\times (1 + 0) = 8$.\n-   $C = (0 - 8) \\pmod{16} = -8 \\pmod{16} = 8$.\n-   $R = 1$ because $C \\neq 0$.\n-   $S = C = 8$.\n-   Result: $[1, 8]$.\n\n**Test Case 2**: $SP\\_0 = 0, M = 1, Z = 16, K = 1, A = 16$.\n-   $\\Delta = (1 \\times 16) + 8 \\times (1 + 1) = 16 + 16 = 32$.\n-   $C = (0 - 32) \\pmod{16} = 0$.\n-   $R = 0$ because $C = 0$.\n-   $S = C = 0$.\n-   Result: $[0, 0]$.\n\n**Test Case 3**: $SP\\_0 = 8, M = 0, Z = 8, K = 0, A = 16$.\n-   $\\Delta = (0 \\times 8) + 8 \\times (1 + 0) = 8$.\n-   $C = (8 - 8) \\pmod{16} = 0$.\n-   $R = 0$ because $C = 0$.\n-   $S = C = 0$.\n-   Result: $[0, 0]$.\n\n**Test Case 4**: $SP\\_0 = 0, M = 1, Z = 16, K = 0, A = 32$.\n-   $\\Delta = (1 \\times 16) + 8 \\times (1 + 0) = 16 + 8 = 24$.\n-   $C = (0 - 24) \\pmod{32} = -24 \\pmod{32} = 8$.\n-   $R = 1$ because $C \\neq 0$.\n-   $S = C = 8$.\n-   Result: $[1, 8]$.\n\n**Test Case 5**: $SP\\_0 = 8, M = 0, Z = 8, K = 2, A = 32$.\n-   $\\Delta = (0 \\times 8) + 8 \\times (1 + 2) = 24$.\n-   $C = (8 - 24) \\pmod{32} = -16 \\pmod{32} = 16$.\n-   $R = 1$ because $C \\neq 0$.\n-   $S = C = 16$.\n-   Result: $[1, 16]$.\n\nThe collective results for the test suite are thus $[[1,8],[0,0],[0,0],[1,8],[1,16]]$.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int sp0; // Initial congruence class of caller's SP mod A\n    int m;   // Complex passing mode (0: registers, 1: stack)\n    int z;   // Size of complex argument in bytes\n    int k;   // Number of callee-saved registers pushed\n    int a;   // Alignment requirement in bytes\n} TestCase;\n\n// A struct to hold the calculated results for a single test case.\ntypedef struct {\n    int r; // Misalignment risk indicator (0 or 1)\n    int s; // Minimal alignment shim in bytes\n} Result;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {0, 0, 16, 0, 16}, // Test Case 1\n        {0, 1, 16, 1, 16}, // Test Case 2\n        {8, 0, 8,  0, 16}, // Test Case 3\n        {0, 1, 16, 0, 32}, // Test Case 4\n        {8, 0, 8,  2, 32}  // Test Case 5\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    Result results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // 1. Calculate the total stack pointer decrement (Delta).\n        // Delta = (stack-passed arg size) + (return address size) + (callee-saved registers size)\n        int delta = (tc.m * tc.z) + 8 * (1 + tc.k);\n\n        // 2. Calculate the final stack pointer congruence class (C) before any shim.\n        // C = (SP_0 - Delta) mod A\n        // The implementation (tc.sp0 - (delta % tc.a) + tc.a) % tc.a ensures\n        // a correct positive result for the modulo operation.\n        int c = (tc.sp0 - (delta % tc.a) + tc.a) % tc.a;\n\n        // 3. Determine misalignment risk (R).\n        // R is 1 if the final congruence C is not 0, otherwise 0.\n        results[i].r = (c == 0) ? 0 : 1;\n\n        // 4. Determine minimal alignment shim (S).\n        // The minimal non-negative shim S required to make the SP aligned is C itself.\n        // As derived in the analysis, C is guaranteed to be a multiple of 8.\n        results[i].s = c;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    // Format: \"[[R_1,S_1],[R_2,S_2],...,[R_N,S_N]]\"\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%d,%d]\", results[i].r, results[i].s);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}