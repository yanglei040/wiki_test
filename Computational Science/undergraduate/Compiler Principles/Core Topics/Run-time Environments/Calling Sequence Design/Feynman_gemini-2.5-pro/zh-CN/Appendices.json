{
    "hands_on_practices": [
        {
            "introduction": "在调用序列设计中，选择“调用者保存”还是“被调用者保存”寄存器约定是一个根本性的权衡。本练习将挑战你分析一个相互递归函数的动态执行剖面，为每个寄存器确定最优的保存策略以最小化总开销。通过解决这个问题，你将对程序行为如何决定最高效的约定获得定量的理解。",
            "id": "3626228",
            "problem": "两个相互递归的函数 $A$ 和 $B$ 在一个自定义的应用二进制接口 (ABI) 下执行，其中调用约定（将寄存器指定为被调用者保存或调用者保存）可以为每个寄存器单独选择。该架构提供了一个统一的成本模型：每次将寄存器保存到栈或从栈恢复寄存器的成本为 $\\sigma$ 个周期，其中 $\\sigma = 5$ 个周期。每次保存都与相应的恢复配对，因此一对保存-恢复操作的成本为 $2\\sigma$ 个周期。假设没有优化会消除冗余的保存或恢复操作，并且所选约定要求的所有保存和恢复操作都会被执行。\n\n在一次有限的运行中，测得的动态计数如下：进入 $A$ 的次数为 $N_A = 310$，进入 $B$ 的次数为 $N_B = 300$，从 $A$ 调用 $B$ 的次数为 $C_{AB} = 300$，从 $B$ 调用 $A$ 的次数为 $C_{BA} = 300$。在函数调用期间保持活跃（并在函数内部使用）的寄存器集合分别为：函数 $A$ 的 $L_A = \\{r_1, r_2, r_5\\}$，以及函数 $B$ 的 $L_B = \\{r_2, r_3, r_5\\}$。我们关注的通用寄存器全集是 $R = \\{r_1, r_2, r_3, r_4, r_5, r_6\\}$，但在此次运行中，只有并集 $U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$ 出现在活跃集中。\n\n根据调用约定的基本定义：\n- 如果一个寄存器 $r$ 被指定为被调用者保存，并且函数 $F$ 使用了 $r$，那么每次进入 $F$ 时，该函数必须保存 $r$，并在退出时恢复 $r$，每次进入 $F$ 会产生 $2\\sigma$ 个周期的成本。\n- 如果一个寄存器 $r$ 被指定为调用者保存，并且在调用点它在调用者中是活跃的，那么调用者必须在调用前保存 $r$，并在调用后恢复 $r$，每次此类调用会产生 $2\\sigma$ 个周期的成本。\n\n你可以为 $U$ 中的每个寄存器独立指定其为被调用者保存还是调用者保存。在这些规则和给定的动态计数下，确定在整个运行过程中可能的最小总动态保存/恢复开销（以周期为单位）。提供一个单一的数值答案；无需四舍五入。最终答案以周期表示。",
            "solution": "### 解题思路\n我们的目标是为活跃寄存器集合 $U = \\{r_1, r_2, r_3, r_5\\}$ 中的每个寄存器独立地选择“调用者保存”或“被调用者保存”约定，以最小化总的保存/恢复开销。由于每个寄存器的选择是独立的，我们可以对每个寄存器分别计算两种约定的开销，然后选择较小的一个。总的最小开销是所有寄存器最小开销的总和。\n\n已知一对保存-恢复操作的成本为 $2\\sigma = 2 \\times 5 = 10$ 个周期。\n\n### 成本计算公式\n对于任意一个寄存器 $r$：\n\n1.  **被调用者保存 (Callee-Saved) 成本**：\n    如果寄存器 $r$ 被指定为被调用者保存，那么任何使用了该寄存器的函数在每次被调用时都必须保存和恢复它。\n    - 如果函数 $A$ 使用 $r$ (即 $r \\in L_A$)，成本为 $N_A \\times 2\\sigma$。\n    - 如果函数 $B$ 使用 $r$ (即 $r \\in L_B$)，成本为 $N_B \\times 2\\sigma$。\n    总成本为：$Cost_{callee}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot N_A + \\mathbb{I}(r \\in L_B) \\cdot N_B)$，其中 $\\mathbb{I}(\\cdot)$ 是指示函数。\n\n2.  **调用者保存 (Caller-Saved) 成本**：\n    如果寄存器 $r$ 被指定为调用者保存，那么在每次函数调用发生时，如果该寄存器在调用者中是活跃的，调用者就必须保存和恢复它。\n    - 对于从 $A$ 到 $B$ 的调用 ($C_{AB}$ 次)，如果 $r$ 在 $A$ 中是活跃的 (即 $r \\in L_A$)，成本为 $C_{AB} \\times 2\\sigma$。\n    - 对于从 $B$ 到 $A$ 的调用 ($C_{BA}$ 次)，如果 $r$ 在 $B$ 中是活跃的 (即 $r \\in L_B$)，成本为 $C_{BA} \\times 2\\sigma$。\n    总成本为：$Cost_{caller}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot C_{AB} + \\mathbb{I}(r \\in L_B) \\cdot C_{BA})$。\n\n### 各寄存器的最小成本分析\n\n**对于寄存器 $r_1$：**\n$r_1 \\in L_A$ 且 $r_1 \\notin L_B$。\n- $Cost_{callee}(r_1) = 10 \\times (1 \\cdot N_A + 0 \\cdot N_B) = 10 \\times 310 = 3100$ 周期。\n- $Cost_{caller}(r_1) = 10 \\times (1 \\cdot C_{AB} + 0 \\cdot C_{BA}) = 10 \\times 300 = 3000$ 周期。\n$r_1$ 的最小成本为 $\\min(3100, 3000) = 3000$ 周期 (选择调用者保存)。\n\n**对于寄存器 $r_2$：**\n$r_2 \\in L_A$ 且 $r_2 \\in L_B$。\n- $Cost_{callee}(r_2) = 10 \\times (1 \\cdot N_A + 1 \\cdot N_B) = 10 \\times (310 + 300) = 6100$ 周期。\n- $Cost_{caller}(r_2) = 10 \\times (1 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times (300 + 300) = 6000$ 周期。\n$r_2$ 的最小成本为 $\\min(6100, 6000) = 6000$ 周期 (选择调用者保存)。\n\n**对于寄存器 $r_3$：**\n$r_3 \\notin L_A$ 且 $r_3 \\in L_B$。\n- $Cost_{callee}(r_3) = 10 \\times (0 \\cdot N_A + 1 \\cdot N_B) = 10 \\times 300 = 3000$ 周期。\n- $Cost_{caller}(r_3) = 10 \\times (0 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times 300 = 3000$ 周期。\n$r_3$ 的最小成本为 $\\min(3000, 3000) = 3000$ 周期 (两种约定成本相同)。\n\n**对于寄存器 $r_5$：**\n$r_5 \\in L_A$ 且 $r_5 \\in L_B$。此情况与 $r_2$ 相同。\n- $Cost_{callee}(r_5) = 10 \\times (310 + 300) = 6100$ 周期。\n- $Cost_{caller}(r_5) = 10 \\times (300 + 300) = 6000$ 周期。\n$r_5$ 的最小成本为 $\\min(6100, 6000) = 6000$ 周期 (选择调用者保存)。\n\n### 总计最小开销\n总计最小开销是 $U$ 中每个寄存器的最小成本之和。$U$ 之外的寄存器（如 $r_4$ 和 $r_6$）在此次运行中不活跃，因此不会产生保存/恢复开销。\n$$Cost_{total} = \\min Cost(r_1) + \\min Cost(r_2) + \\min Cost(r_3) + \\min Cost(r_5)$$\n$$Cost_{total} = 3000 + 6000 + 3000 + 6000 = 18000$$\n\n在整个运行过程中，可能的最小总动态保存/恢复开销为 $18000$ 个周期。",
            "answer": "$$\\boxed{18000}$$"
        },
        {
            "introduction": "除了保存寄存器，调用序列还必须确保参数能够被完美地传递。这需要由应用程序二进制接口（ABI）指定严格的规则，来规定像小整数这样的数据如何被提升到寄存器大小。在这个动手模拟练习中，你将探索整数提升中 ABI 不匹配的后果，并实现标准的被调用者端修复机制以保证数据完整性。",
            "id": "3626585",
            "problem": "设计并实现一个小型的、自包含的模拟器，该模拟器将调用序列中小整数提升的应用程序二进制接口（ABI）规则形式化，然后检测并修复调用者传递 $8$ 位值时的不匹配问题。你的程序必须将 ABI 的规范规则代码化，模拟调用者行为（正确的和不正确的），对被调用者的解释进行建模，并应用一种有原则的被调用者序言修复方法，以恢复数学上预期的值。\n\n基本原理和定义：\n- 应用程序二进制接口（ABI）是规定值如何跨函数边界传递的契约。你必须实现的 ABI 采用规范的整数寄存器宽度 $W_c = 32$ 位。\n- 对于任何声明宽度为 $w \\le 8$ 位的参数，调用者必须根据声明的有无符号性将该值提升到 $W_c$ 位：\n  - 如果声明的类型是无符号的，调用者必须执行从 $w$ 位到 $W_c$ 位的零扩展。\n  - 如果声明的类型是有符号的（二进制补码），调用者必须执行从 $w$ 位到 $W_c$ 位的符号扩展。\n- 从 $w$ 位到 $W_c$ 位的二进制补码符号扩展由以下函数定义：对于任何以 $w$ 位表示的整数 $x$，\n  $$\n  \\operatorname{exts}_{w \\to W_c}(x) =\n  \\begin{cases}\n  x,  \\text{如果 } x \\text{ 的最高有效位是 } 0,\\\\\n  x | \\big(\\text{位 } [w, W_c-1] \\text{ 上全为 1}\\big),  \\text{如果 } x \\text{ 的最高有效位是 } 1.\n  \\end{cases}\n  $$\n  对于 $w = 8$ 和 $W_c = 32$，这等同于：如果 $(x \\ 2^{7}) \\ne 0$ 则 $x | \\left(\\sum_{i=8}^{31} 2^i\\right)$ 否则 $x$。\n- 从 $w$ 位到 $W_c$ 位的零扩展定义为\n  $$\n  \\operatorname{extz}_{w \\to W_c}(x) = x \\ \\left(\\sum_{i=0}^{w-1} 2^i\\right).\n  $$\n\n调用者和被调用者模型：\n- 设源 $8$ 位有效负载为 $v_8 \\in \\{0,1,\\dots,255\\}$。\n- 根据被调用者的参数类型，数学上预期的值是：\n  - 如果被调用者期望有符号 $8$ 位，预期的 $32$ 位值是 $V_{\\text{intended}} = \\operatorname{exts}_{8 \\to 32}(v_8)$，表示在 $32$ 位内以二进制补码编码的 $\\mathbb{Z}$ 中的整数。\n  - 如果被调用者期望无符号 $8$ 位，预期的 $32$ 位值是 $V_{\\text{intended}} = \\operatorname{extz}_{8 \\to 32}(v_8)$。\n- 调用者根据以下三种行为之一放置一个原始的 $32$ 位寄存器值 $R$：\n  1. 正确的零扩展：$R = \\operatorname{extz}_{8 \\to 32}(v_8)$。\n  2. 正确的符号扩展：$R = \\operatorname{exts}_{8 \\to 32}(v_8)$。\n  3. 原始未扩展：$R = (H \\ll 8) | (v_8 \\ 255)$，其中 $H$ 是一个 $24$ 位的模式，可能残留在位 $[8,31]$ 中，$\\ll$ 表示逻辑左移。\n- 被调用者的朴素解释（无修复）是：\n  - 如果被调用者期望有符号，则将 $R$ 解释为有符号 $32$ 位二进制补码整数，得到 $V_{\\text{before}}$。\n  - 如果被调用者期望无符号，则将 $R$ 解释为无符号 $32$ 位整数，得到 $V_{\\text{before}}$。\n- 你必须实现的被调用者序言修复是针对小整数提升不匹配的规范修复方法：\n  $$\n  V_{\\text{after}} = \n  \\begin{cases}\n  \\operatorname{exts}_{8 \\to 32}(R \\ 255),  \\text{如果被调用者期望有符号},\\\\\n  \\operatorname{extz}_{8 \\to 32}(R \\ 255),  \\text{如果被调用者期望无符号}。\n  \\end{cases}\n  $$\n  这对应于屏蔽低 $8$ 位并根据被调用者声明的有无符号性重新扩展。如果调用者已经遵循了 ABI，这种修复是幂等的。\n\n每个测试用例的输出分类：\n- 令 $C$ 为分类代码，定义如下：\n  - $C = 0$ 如果 $V_{\\text{before}} = V_{\\text{intended}}$ 且 $V_{\\text{after}} = V_{\\text{intended}}$。\n  - $C = 1$ 如果 $V_{\\text{before}} \\ne V_{\\text{intended}}$ 但 $V_{\\text{after}} = V_{\\text{intended}}$。\n  - $C = 2$ 如果 $V_{\\text{after}} \\ne V_{\\text{intended}}$（未修复的错误）。\n  - $C = 3$ 如果 $V_{\\text{before}} = V_{\\text{intended}}$ 但 $V_{\\text{after}} \\ne V_{\\text{intended}}$（由于修复导致的回归；这在使用所述修复时不应发生）。\n\n测试套件：\n每个测试用例是一个元组 $(v_8, m, s, H)$，其中 $v_8$ 是 $8$ 位有效负载，$m \\in \\{0,1,2\\}$ 是调用者模式，其中 $0$ 意为零扩展，$1$ 意为符号扩展，$2$ 意为原始未扩展，$s \\in \\{0,1\\}$ 表示被调用者期望无符号（$0$）或有符号（$1$）语义，而 $H$ 是仅在 $m=2$ 时使用的 $24$ 位高位模式（否则忽略）。使用以下八个案例：\n1. $(v_8 = 5, m = 0, s = 0, H = 0)$\n2. $(v_8 = 200, m = 0, s = 1, H = 0)$\n3. $(v_8 = 128, m = 1, s = 0, H = 0)$\n4. $(v_8 = 127, m = 1, s = 1, H = 0)$\n5. $(v_8 = 255, m = 0, s = 1, H = 0)$\n6. $(v_8 = 42, m = 2, s = 0, H = 0x55AA77)$\n7. $(v_8 = 200, m = 2, s = 1, H = 0x00F0F0)$\n8. $(v_8 = 0, m = 2, s = 0, H = 0x123456)$\n\n你的程序必须做什么：\n- 硬编码上述测试套件。\n- 对每个测试用例，根据 $m$ 和 $H$ 构造 $R$。\n- 根据 $v_8$ 和 $s$ 计算 $V_{\\text{intended}}$。\n- 根据 $R$ 和 $s$ 计算 $V_{\\text{before}}$。\n- 根据指定的修复方法计算 $V_{\\text{after}}$。\n- 为每个测试用例生成分类代码 $C$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含用方括号括起来的八个整型分类代码的逗号分隔列表。例如，形式为 $[c_1,c_2,c_3,c_4,c_5,c_6,c_7,c_8]$ 的输出，其中每个 $c_i$ 是 $\\{0,1,2,3\\}$ 之一。\n\n不读取任何输入。不允许访问外部文件或网络。所有内部计算必须使用与上述定义一致的整数算术来执行。所有角度、物理单位或百分比均不适用于此问题；所有数值都是无单位的整数。",
            "solution": "### 解题方法\n该问题的核心是模拟一个关于小整数参数传递的 ABI 规则，并评估一个被调用者端的修复机制。我们将对每个测试用例，按照以下步骤进行计算和分类：\n\n1.  **确定预期值 ($V_{\\text{intended}}$)**：根据被调用者期望的类型（有符号 `s=1` 或无符号 `s=0`），对 8 位载荷 $v_8$ 进行正确的扩展。\n    -   如果 `s=0` (无符号)，$V_{\\text{intended}}$ 是 $v_8$ 的零扩展。\n    -   如果 `s=1` (有符号)，$V_{\\text{intended}}$ 是 $v_8$ 的符号扩展。例如，8 位的 200 在有符号解释下是 -56。\n\n2.  **构造寄存器值 ($R$)**：根据调用者模式 `m` 构造 32 位寄存器值。\n    -   `m=0`：对 $v_8$ 进行零扩展。\n    -   `m=1`：对 $v_8$ 进行符号扩展。\n    -   `m=2`：将高 24 位设置为 `H`，低 8 位设置为 $v_8$。\n\n3.  **计算修复前的值 ($V_{\\text{before}}$)**：将被调用者朴素地解释寄存器值 $R$。即，根据被调用者期望的类型（有符号或无符号）来直接解释 $R$。\n\n4.  **计算修复后的值 ($V_{\\text{after}}$)**：应用修复机制。该机制首先通过位掩码 `R  255` 提取低 8 位，然后根据被调用者期望的类型对这个提取出的值进行正确的扩展。\n\n5.  **分类**：比较 $V_{\\text{intended}}$, $V_{\\text{before}}$, 和 $V_{\\text{after}}$，并根据问题中定义的规则确定分类代码 $C$。\n\n### 逐案分析\n\n-   **Case 1: (v=5, m=0, s=0)** 调用者零扩展，被调用者期望无符号。完美匹配。$V_{\\text{intended}}=5, R=5, V_{\\text{before}}=5, V_{\\text{after}}=5$。**C=0**。\n-   **Case 2: (v=200, m=0, s=1)** 调用者零扩展，被调用者期望有符号。ABI 不匹配。$V_{\\text{intended}}=\\text{sign_ext}(200)=-56$。$R=200$。$V_{\\text{before}}=200$。$V_{\\text{after}}=\\text{sign_ext}(200)=-56$。修复成功。**C=1**。\n-   **Case 3: (v=128, m=1, s=0)** 调用者符号扩展，被调用者期望无符号。ABI 不匹配。$V_{\\text{intended}}=128$。$R=\\text{sign_ext}(128)=-128$ (即 0xFFFFFF80)。$V_{\\text{before}}$ 是一个大的无符号数。$V_{\\text{after}}=\\text{zero_ext}(128)=128$。修复成功。**C=1**。\n-   **Case 4: (v=127, m=1, s=1)** 调用者符号扩展，被调用者期望有符号。完美匹配。$V_{\\text{intended}}=127$。$R=127$。$V_{\\text{before}}=127$。$V_{\\text{after}}=127$。**C=0**。\n-   **Case 5: (v=255, m=0, s=1)** 调用者零扩展，被调用者期望有符号。ABI 不匹配。$V_{\\text{intended}}=\\text{sign_ext}(255)=-1$。$R=255$。$V_{\\text{before}}=255$。$V_{\\text{after}}=\\text{sign_ext}(255)=-1$。修复成功。**C=1**。\n-   **Case 6: (v=42, m=2, s=0)** 调用者传递原始值（高位有垃圾数据），被调用者期望无符号。$V_{\\text{intended}}=42$。$R=0x55AA772A$。$V_{\\text{before}}$ 是一个大的无符号数。$V_{\\text{after}}=\\text{zero_ext}(42)=42$。修复成功。**C=1**。\n-   **Case 7: (v=200, m=2, s=1)** 调用者传递原始值，被调用者期望有符号。$V_{\\text{intended}}=\\text{sign_ext}(200)=-56$。$R=0x00F0F0C8$。$V_{\\text{before}}$ 是一个大的正数。$V_{\\text{after}}=\\text{sign_ext}(200)=-56$。修复成功。**C=1**。\n-   **Case 8: (v=0, m=2, s=0)** 调用者传递原始值，被调用者期望无符号。$V_{\\text{intended}}=0$。$R=0x12345600$。$V_{\\text{before}}$ 是一个大的无符号数。$V_{\\text{after}}=\\text{zero_ext}(0)=0$。修复成功。**C=1**。\n\n修复机制是稳健的，因为它总是从寄存器的低8位重新推导有效载荷并正确地重新扩展它，确保 $V_{\\text{after}}$ 总是等于 $V_{\\text{intended}}$。因此，不会出现 $C=2$ 或 $C=3$ 的情况。\n\n将所有分类代码汇总，得到最终结果。",
            "answer": "[0,1,1,0,1,1,1,1]"
        },
        {
            "introduction": "高效的调用序列不仅要管理寄存器，还必须精确地管理系统栈，这对性能至关重要。现代处理器要求栈指针为高吞吐量的向量指令进行特定的对齐，这是一个必须在函数调用间维持的契约。本练习要求你对函数调用及序言（prologue）过程中栈指针的变化进行建模，计算为满足这些关键对齐要求所必需的调整。",
            "id": "3626519",
            "problem": "您的任务是设计并分析一个在应用二进制接口 (ABI) 下的简化函数调用序列。目标是从第一性原理出发，推理栈指针的对齐方式如何与复数的传递以及函数序言相互作用。您必须编写一个完整的程序，该程序能根据一小组测试用例，计算一个函数是否会在其序言中执行未对齐的向量加载，并确定避免这种情况所需的最小对齐填充（shim）。\n\n本问题的基础设定如下：\n\n- 应用二进制接口 (ABI) 指定了调用约定，包括参数如何传递以及栈指针如何管理。\n- 在一个常规的类 $x86\\_64$ 架构上，栈向下（低地址方向）增长。执行一条 call 指令会原子性地将返回地址压入栈中，消耗 $8$ 字节的栈空间。\n- 在函数序言中保存被调用者保存的寄存器（callee-saved registers）这一行为，被建模为一系列 push 操作，每个操作消耗 $8$ 字节。\n- 一个复数既可以通过寄存器传递（参数本身不消耗栈空间），也可以作为一个大小为 $Z$ 字节的连续块在栈上传递，其中 $Z$ 是该复数类型的大小（例如，单精度复数为 $8$ 字节，双精度复数为 $16$ 字节）。\n- 序言中的向量加载要求栈指针满足 $A$ 字节的对齐，这表示为关于同余类 $SP \\bmod A$ 的一个条件。\n\n您必须：\n\n- 建模以下事件按顺序对栈指针 $SP$ 的影响：栈传递参数的消耗、call 指令压入返回地址、以及被调用者序言中的压栈操作。\n- 判断在任何显式对齐填充之前的那个点，一个需要 $A$ 字节对齐的向量加载是否会发生未对齐。也就是说，判断该点的同余类 $SP \\bmod A$ 是否非零。\n- 计算以字节为单位的最小对齐填充量，该填充量被约束为 $8$ 的倍数，被调用者可以从其序言中的 $SP$ 减去该值，以便后续的向量加载能对齐到 $A$ 字节。\n\n您的程序必须实现上述逻辑，并针对以下测试套件生成所需结果。每个测试用例指定：\n- $SP\\_0$：调用者栈指针在放置任何参数或发生调用之前的初始同余类（模 $A$），表示为一个在 $[0, A)$ 范围内且是 $8$ 的倍数的整数。\n- $M$：复数传递模式，其中 $M = 0$ 表示复数通过寄存器传递，$M = 1$ 表示复数通过栈传递。\n- $Z$：复数参数的字节大小。\n- $K$：在序言中压栈的被调用者保存寄存器的数量，每次压栈消耗 $8$ 字节。\n- $A$：序言中向量加载的对齐要求（以字节为单位）。\n\n测试套件：\n1. $SP\\_0 = 0$, $M = 0$, $Z = 16$, $K = 0$, $A = 16$。\n2. $SP\\_0 = 0$, $M = 1$, $Z = 16$, $K = 1$, $A = 16$。\n3. $SP\\_0 = 8$, $M = 0$, $Z = 8$, $K = 0$, $A = 16$。\n4. $SP\\_0 = 0$, $M = 1$, $Z = 16$, $K = 0$, $A = 32$。\n5. $SP\\_0 = 8$, $M = 0$, $Z = 8, K = 2, A = 32$。\n\n对每个测试用例，您的程序必须计算：\n- 一个布尔类型的未对齐风险指示器 $R$，如果在应用任何显式填充之前向量加载会发生未对齐，则 $R = 1$，否则 $R = 0$。\n- 最小填充量 $S$（以字节为单位），该值被约束为 $8$ 的倍数，被调用者必须在其序言中从 $SP$ 减去该值，以实现向量加载的 $A$ 字节对齐。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，结果形式为用逗号分隔并包含在方括号中的数对列表。每个数对的形式为 $[R, S]$，并与给定顺序的测试用例相对应。例如，输出格式必须严格如下：\n\"[[R\\_1,S\\_1],[R\\_2,S\\_2],[R\\_3,S\\_3],[R\\_4,S\\_4],[R\\_5,S\\_5]]\"",
            "solution": "### 解题方法\n我们从第一性原理出发，对栈指针（$SP$）的状态进行建模。假设栈向低地址方向增长，因此分配栈空间意味着减小 $SP$ 的值。\n\n1.  **计算 $SP$ 的总变化量**：\n    我们计算从调用者初始状态到被调用者序言中向量加载点之前，$SP$ 的总减少量 $\\Delta$。这个过程包括三个步骤：\n    - 参数压栈：如果通过栈传递参数 ($M=1$)，消耗 $Z$ 字节。成本为 $M \\times Z$。\n    - `call` 指令：压入 8 字节的返回地址。\n    - 保存寄存器：压入 $K$ 个寄存器，每个 8 字节。成本为 $K \\times 8$。\n    \n    总减少量 $\\Delta = (M \\times Z) + 8 + (K \\times 8) = M \\times Z + 8 \\times (1 + K)$。\n\n2.  **计算最终的同余类**：\n    令 $SP_0$ 为初始栈指针模 $A$ 的同余类。在进行了一系列压栈操作后，新的栈指针 $SP_{prologue}$ 模 $A$ 的同余类 $C$ 为：\n    $$C = (SP_0 - \\Delta) \\pmod A$$\n    在实际计算中，为确保结果为正，我们使用 $C = (SP_0 - (\\Delta \\pmod A) + A) \\pmod A$。\n\n3.  **确定未对齐风险 ($R$) 和填充量 ($S$)**：\n    -   **风险 ($R$)**：如果向量加载点未对齐，即 $C \\neq 0$，则存在风险，$R=1$。否则 $R=0$。\n    -   **填充量 ($S$)**：为了对齐，我们需要从 $SP_{prologue}$ 再减去一个最小的非负填充量 $S$，使得 $(SP_{prologue} - S) \\pmod A = 0$。这意味着 $(C - S) \\pmod A = 0$，因此 $S$ 必须等于 $C$。由于问题中的所有输入（$SP_0$, $Z$）和操作（`push`）都是 8 的倍数，且对齐边界 $A$ 也是 8 的倍数，所以计算出的 $C$ 和 $S$ 也必然是 8 的倍数，满足约束条件。\n\n### 逐案分析\n\n**测试用例 1**: $SP\\_0 = 0, M = 0, Z = 16, K = 0, A = 16$\n- $\\Delta = (0 \\times 16) + 8 \\times (1 + 0) = 8$\n- $C = (0 - 8) \\pmod{16} = 8$\n- $R = 1$ (未对齐)，$S = 8$\n- 结果: $[1, 8]$\n\n**测试用例 2**: $SP\\_0 = 0, M = 1, Z = 16, K = 1, A = 16$\n- $\\Delta = (1 \\times 16) + 8 \\times (1 + 1) = 16 + 16 = 32$\n- $C = (0 - 32) \\pmod{16} = 0$\n- $R = 0$ (已对齐)，$S = 0$\n- 结果: $[0, 0]$\n\n**测试用例 3**: $SP\\_0 = 8, M = 0, Z = 8, K = 0, A = 16$\n- $\\Delta = (0 \\times 8) + 8 \\times (1 + 0) = 8$\n- $C = (8 - 8) \\pmod{16} = 0$\n- $R = 0$ (已对齐)，$S = 0$\n- 结果: $[0, 0]$\n\n**测试用例 4**: $SP\\_0 = 0, M = 1, Z = 16, K = 0, A = 32$\n- $\\Delta = (1 \\times 16) + 8 \\times (1 + 0) = 24$\n- $C = (0 - 24) \\pmod{32} = 8$\n- $R = 1$ (未对齐)，$S = 8$\n- 结果: $[1, 8]$\n\n**测试用例 5**: $SP\\_0 = 8, M = 0, Z = 8, K = 2, A = 32$\n- $\\Delta = (0 \\times 8) + 8 \\times (1 + 2) = 24$\n- $C = (8 - 24) \\pmod{32} = -16 \\pmod{32} = 16$\n- $R = 1$ (未对齐)，$S = 16$\n- 结果: $[1, 16]$\n\n将所有结果汇总，得到最终输出。",
            "answer": "[[1,8],[0,0],[0,0],[1,8],[1,16]]"
        }
    ]
}