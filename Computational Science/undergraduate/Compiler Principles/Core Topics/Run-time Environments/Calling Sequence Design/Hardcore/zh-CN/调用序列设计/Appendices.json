{
    "hands_on_practices": [
        {
            "introduction": "在调用约定设计中，一个最基本的权衡在于：寄存器是由调用者（caller）还是被调用者（callee）负责保存？这个选择并非随意，而是对程序性能有直接影响。此练习  提供了一个具体的场景，通过分析一对相互递归函数的动态调用数据，让你量化这一权衡。你将为每个寄存器独立决策，以最小化总的寄存器存取开销，从而深刻理解调用约定如何影响程序的运行时效率。",
            "id": "3626228",
            "problem": "两个相互递归的函数 $A$ 和 $B$ 在一个自定义的应用二进制接口 (ABI) 下执行，其中调用约定（将寄存器指定为被调用者保存或调用者保存）可以为每个寄存器单独选择。该架构提供了一个统一的成本模型：每次将寄存器保存到栈或从栈恢复的操作成本为 $\\sigma$ 个周期，其中 $\\sigma = 5$ 个周期。每次保存都与相应的恢复配对，因此一对保存-恢复操作的成本为 $2\\sigma$ 个周期。假设没有优化会消除冗余的保存或恢复操作，并且所选约定要求的所有保存和恢复操作都会被执行。\n\n在一次有限的运行中，测得的动态计数如下：进入函数 $A$ 的次数为 $N_A = 310$，进入函数 $B$ 的次数为 $N_B = 300$，从 $A$ 调用 $B$ 的次数为 $C_{AB} = 300$，从 $B$ 调用 $A$ 的次数为 $C_{BA} = 300$。在函数调用期间保持活跃（并在函数内部使用）的寄存器集合，对于函数 $A$ 是 $L_A = \\{r_1, r_2, r_5\\}$，对于函数 $B$ 是 $L_B = \\{r_2, r_3, r_5\\}$。我们关心的通用寄存器全集是 $R = \\{r_1, r_2, r_3, r_4, r_5, r_6\\}$，但在这次运行中，只有并集 $U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$ 出现在活跃集中。\n\n根据调用约定的基本定义：\n- 如果一个寄存器 $r$ 被指定为被调用者保存，并且函数 $F$ 使用了 $r$，那么每次进入 $F$ 时，该函数必须保存 $r$，并在退出时恢复 $r$，每次进入 $F$ 会产生 $2\\sigma$ 个周期的开销。\n- 如果一个寄存器 $r$ 被指定为调用者保存，并且在调用点的调用者中是活跃的，那么调用者必须在调用前保存 $r$，并在调用后恢复 $r$，每次这样的调用会产生 $2\\sigma$ 个周期的开销。\n\n你可以为 $U$ 中的每个寄存器独立地指定其为被调用者保存还是调用者保存。根据这些规则和给定的动态计数，确定在整个运行过程中最小可能的总动态保存/恢复开销，以周期为单位表示。提供一个单一的数值答案；无需四舍五入。最终答案以周期表示。",
            "solution": "我将遵循以下步骤来解决此问题：\n1.  **提取已知信息**：我将列出所有提供的数据、变量、常量和条件。\n2.  **验证问题**：我将检查问题的科学严谨性、自洽性和良定性。\n3.  **求解**：如果问题有效，我将提供分步解答。\n\n### 步骤1：提取已知信息\n- 单次寄存器保存或恢复操作的成本：$\\sigma = 5$ 个周期。\n- 一对保存-恢复操作的成本：$2\\sigma = 10$ 个周期。\n- 进入函数 $A$ 的次数：$N_A = 310$。\n- 进入函数 $B$ 的次数：$N_B = 300$。\n- 从 $A$ 调用 $B$ 的次数：$C_{AB} = 300$。\n- 从 $B$ 调用 $A$ 的次数：$C_{BA} = 300$。\n- 函数 $A$ 中跨调用活跃的寄存器集合：$L_A = \\{r_1, r_2, r_5\\}$。\n- 函数 $B$ 中跨调用活跃的寄存器集合：$L_B = \\{r_2, r_3, r_5\\}$。\n- 我们关心的寄存器全集：$U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$。\n\n### 步骤2：使用提取的已知信息进行验证\n- **科学基础**：该问题基于计算机体系结构和编译器设计的原理，特别是关于调用约定和寄存器分配。被调用者保存和调用者保存寄存器、函数调用开销以及活跃性分析等概念都是标准且明确定义的。\n- **良定性**：该问题要求计算最小可能开销，这是一个定义明确的优化问题。计算开销的规则是明确且无歧义的。所提供的数据足以计算每种可能的寄存器约定分配的成本。\n- **一致性**：动态计数是一致的。函数 $A$ 的进入次数 $N_A = 310$ 和从 $B$ 到 $A$ 的调用次数 $C_{BA} = 300$ 意味着有 $N_A - C_{BA} = 310 - 300 = 10$ 次是从外部上下文对 $A$ 的初始进入。函数 $B$ 的进入次数 $N_B = 300$ 和从 $A$ 到 $B$ 的调用次数 $C_{AB} = 300$ 意味着所有对 $B$ 的进入都源于 $A$。这描述了一个有效的执行轨迹。\n- **客观性**：该问题使用客观的、定量的数据和形式化定义进行陈述。\n\n该问题是有效的。\n\n### 步骤3：求解\n目标是为集合 $U = \\{r_1, r_2, r_3, r_5\\}$ 中的每个寄存器确定一种调用约定，以最小化总的动态保存/恢复开销。每个寄存器的选择（被调用者保存 vs. 调用者保存）是独立的。因此，我们可以为每个寄存器单独最小化其开销，然后将结果相加得到总的最小开销。\n\n对于任何寄存器 $r$，我们必须比较将其指定为被调用者保存与调用者保存的成本。一对保存-恢复操作的成本是 $2\\sigma = 2 \\times 5 = 10$ 个周期。\n\n**被调用者保存约定的成本**\n如果一个寄存器 $r$ 被指定为被调用者保存，那么如果被调用的函数本身使用了该寄存器，则该函数必须在进入时保存它，并在退出时恢复它。题目说明，如果寄存器 $r$ 在函数 $F$ 的活跃集 $L_F$ 中，则函数 $F$ “使用”了 $r$。\n一个被调用者保存的寄存器 $r$ 的总成本是使用它的每个函数所产生的成本之和。\n- 如果函数 $A$ 使用 $r$（即 $r \\in L_A$），由于 $A$ 被进入 $N_A$ 次，产生的成本是 $N_A \\times 2\\sigma$。\n- 如果函数 $B$ 使用 $r$（即 $r \\in L_B$），由于 $B$ 被进入 $N_B$ 次，产生的成本是 $N_B \\times 2\\sigma$。\n\n一个被调用者保存的寄存器 $r$ 的总成本是：\n$$Cost_{callee}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot N_A + \\mathbb{I}(r \\in L_B) \\cdot N_B)$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数，当条件为真时其值为 $1$，否则为 $0$。\n\n**调用者保存约定的成本**\n如果一个寄存器 $r$ 被指定为调用者保存，那么如果该寄存器的值在调用者中是活跃的，则调用者函数必须在调用前保存它，并在调用后恢复它。\n- 函数 $A$ 对 $B$ 进行了 $C_{AB}$ 次调用。如果 $r$ 在 $A$ 中是活跃的（即 $r \\in L_A$），则每次调用都需要进行一次保存/恢复。成本是 $C_{AB} \\times 2\\sigma$。\n- 函数 $B$ 对 $A$ 进行了 $C_{BA}$ 次调用。如果 $r$ 在 $B$ 中是活跃的（即 $r \\in L_B$），则每次调用都需要进行一次保存/恢复。成本是 $C_{BA} \\times 2\\sigma$。\n\n一个调用者保存的寄存器 $r$ 的总成本是：\n$$Cost_{caller}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot C_{AB} + \\mathbb{I}(r \\in L_B) \\cdot C_{BA})$$\n\n现在，我们为 $U$ 中的每个寄存器计算最小成本。\n\n**对于寄存器 $r_1$：**\n$r_1 \\in L_A$ 且 $r_1 \\notin L_B$。\n- $Cost_{callee}(r_1) = 2\\sigma \\times (1 \\cdot N_A + 0 \\cdot N_B) = 10 \\times 310 = 3100$ 个周期。\n- $Cost_{caller}(r_1) = 2\\sigma \\times (1 \\cdot C_{AB} + 0 \\cdot C_{BA}) = 10 \\times 300 = 3000$ 个周期。\n$r_1$ 的最小成本是 $\\min(3100, 3000) = 3000$ 个周期。这通过将 $r_1$ 设为调用者保存来实现。\n\n**对于寄存器 $r_2$：**\n$r_2 \\in L_A$ 且 $r_2 \\in L_B$。\n- $Cost_{callee}(r_2) = 2\\sigma \\times (1 \\cdot N_A + 1 \\cdot N_B) = 10 \\times (310 + 300) = 10 \\times 610 = 6100$ 个周期。\n- $Cost_{caller}(r_2) = 2\\sigma \\times (1 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times (300 + 300) = 10 \\times 600 = 6000$ 个周期。\n$r_2$ 的最小成本是 $\\min(6100, 6000) = 6000$ 个周期。这通过将 $r_2$ 设为调用者保存来实现。\n\n**对于寄存器 $r_3$：**\n$r_3 \\notin L_A$ 且 $r_3 \\in L_B$。\n- $Cost_{callee}(r_3) = 2\\sigma \\times (0 \\cdot N_A + 1 \\cdot N_B) = 10 \\times 300 = 3000$ 个周期。\n- $Cost_{caller}(r_3) = 2\\sigma \\times (0 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times 300 = 3000$ 个周期。\n$r_3$ 的最小成本是 $\\min(3000, 3000) = 3000$ 个周期。两种约定的成本相同。\n\n**对于寄存器 $r_5$：**\n$r_5 \\in L_A$ 且 $r_5 \\in L_B$。此情况与 $r_2$ 相同。\n- $Cost_{callee}(r_5) = 10 \\times (310 + 300) = 6100$ 个周期。\n- $Cost_{caller}(r_5) = 10 \\times (300 + 300) = 6000$ 个周期。\n$r_5$ 的最小成本是 $\\min(6100, 6000) = 6000$ 个周期。这通过将 $r_5$ 设为调用者保存来实现。\n\n**总最小开销**\n总最小开销是 $U$ 中每个寄存器的最小成本之和。$U$ 之外的寄存器（即 $r_4$ 和 $r_6$）在 $A$ 或 $B$ 的任何调用中都不是活跃的，因此它们不会产生保存/恢复开销。\n$$Cost_{total} = \\min Cost(r_1) + \\min Cost(r_2) + \\min Cost(r_3) + \\min Cost(r_5)$$\n$$Cost_{total} = 3000 + 6000 + 3000 + 6000 = 18000$$\n\n在整个运行过程中，最小可能的总动态保存/恢复开销是 $18000$ 个周期。",
            "answer": "$$\\boxed{18000}$$"
        },
        {
            "introduction": "一个设计良好的应用二进制接口 (ABI) 必须是一份无歧义的数据表示契约，以保证函数的正确交互。此练习  让你探索一个常见的陷阱：传递小整数（如 `char` 或 `short`）时，因符号扩展与零扩展的混淆而引发的程序错误。你将通过模拟来诊断调用方与被调用方之间的ABI失配问题，并实现一个健壮的函数序言来修正这些错误，从而确保程序行为的正确性。",
            "id": "3626585",
            "problem": "设计并实现一个小型、独立的模拟器，该模拟器用于形式化一条关于调用序列中小整数提升的应用程序二进制接口（ABI）规则，然后检测并修复当调用者传递 $8$ 位值时不匹配的情况。您的程序必须将该 ABI 的规范规则代码化，模拟调用者的行为（正确和不正确的），对被调用者的解释进行建模，并应用一种有原则的被调用者序言修复程序来恢复数学上预期的值。\n\n基本基础和定义：\n- 应用程序二进制接口（ABI）是规定值如何在函数边界间传递的契约。您必须实现的 ABI 采用规范整数寄存器宽度 $W_c = 32$ 位。\n- 对于任何声明宽度为 $w \\le 8$ 位的参数，调用者必须根据其声明的符号性将该值提升到 $W_c$ 位：\n  - 如果声明的类型是无符号的，调用者必须执行从 $w$ 位到 $W_c$ 位的零扩展。\n  - 如果声明的类型是有符号的（二进制补码），调用者必须执行从 $w$ 位到 $W_c$ 位的符号扩展。\n- 从 $w$ 位到 $W_c$ 位的二进制补码符号扩展由以下函数定义：对于任何以 $w$ 位表示的整数 $x$，\n  $$\n  \\operatorname{exts}_{w \\to W_c}(x) =\n  \\begin{cases}\n  x,  \\text{如果 } x \\text{ 的最高有效位为 } 0,\\\\\n  x | \\big(\\text{位 } [w, W_c-1] \\text{ 全为 1}\\big),  \\text{如果 } x \\text{ 的最高有效位为 } 1。\n  \\end{cases}\n  $$\n  对于 $w = 8$ 和 $W_c = 32$，这等价于：如果 $(x  2^{7}) \\ne 0$ 则 $x | \\left(\\sum_{i=8}^{31} 2^i\\right)$ 否则为 $x$。\n- 从 $w$ 位到 $W_c$ 位的零扩展定义为\n  $$\n  \\operatorname{extz}_{w \\to W_c}(x) = x  \\left(\\sum_{i=0}^{w-1} 2^i\\right).\n  $$\n\n调用者和被调用者模型：\n- 设源 $8$ 位有效负载为 $v_8 \\in \\{0,1,\\dots,255\\}$。\n- 根据被调用者的参数类型，数学上预期的值为：\n  - 如果被调用者期望有符号 $8$ 位，则预期的 $32$ 位值为 $V_{\\text{intended}} = \\operatorname{exts}_{8 \\to 32}(v_8)$，表示在 $32$ 位内以二进制补码编码的 $\\mathbb{Z}$ 中的整数。\n  - 如果被调用者期望无符号 $8$ 位，则预期的 $32$ 位值为 $V_{\\text{intended}} = \\operatorname{extz}_{8 \\to 32}(v_8)$。\n- 调用者根据以下三种行为之一放置一个原始的 $32$ 位寄存器值 $R$：\n  1. 正确的零扩展：$R = \\operatorname{extz}_{8 \\to 32}(v_8)$。\n  2. 正确的符号扩展：$R = \\operatorname{exts}_{8 \\to 32}(v_8)$。\n  3. 原始未扩展：$R = (H \\ll 8) | (v_8  255)$，其中 $H$ 是一个可能残留在位 $[8,31]$ 中的 $24$ 位模式，$\\ll$ 表示逻辑左移。\n- 被调用者的朴素解释（无修复）是：\n  - 如果被调用者期望有符号值，将 $R$ 解释为有符号 $32$ 位二进制补码整数，得到 $V_{\\text{before}}$。\n  - 如果被调用者期望无符号值，将 $R$ 解释为无符号 $32$ 位整数，得到 $V_{\\text{before}}$。\n- 您必须实现的被调用者序言修复是针对小整数提升不匹配的规范修复方法：\n  $$\n  V_{\\text{after}} = \n  \\begin{cases}\n  \\operatorname{exts}_{8 \\to 32}(R  255),  \\text{如果被调用者期望有符号值},\\\\\n  \\operatorname{extz}_{8 \\to 32}(R  255),  \\text{如果被调用者期望无符号值}。\n  \\end{cases}\n  $$\n  这对应于屏蔽低 $8$ 位，并根据被调用者声明的符号性重新进行扩展。如果调用者已经遵守了 ABI，则此修复是幂等的。\n\n每个测试用例的输出分类：\n- 设 $C$ 为分类代码，定义如下：\n  - $C = 0$ 如果 $V_{\\text{before}} = V_{\\text{intended}}$ 并且 $V_{\\text{after}} = V_{\\text{intended}}$。\n  - $C = 1$ 如果 $V_{\\text{before}} \\ne V_{\\text{intended}}$ 但 $V_{\\text{after}} = V_{\\text{intended}}$。\n  - $C = 2$ 如果 $V_{\\text{after}} \\ne V_{\\text{intended}}$ (未修复的错误)。\n  - $C = 3$ 如果 $V_{\\text{before}} = V_{\\text{intended}}$ 但 $V_{\\text{after}} \\ne V_{\\text{intended}}$ (因修复导致的退化；对于所述的修复方法，此情况不应发生)。\n\n测试套件：\n每个测试用例是一个元组 $(v_8, m, s, H)$，其中 $v_8$ 是 $8$ 位有效负载，$m \\in \\{0,1,2\\}$ 是调用者模式，其中 $0$ 表示零扩展，$1$ 表示符号扩展，$2$ 表示原始未扩展，$s \\in \\{0,1\\}$ 表示被调用者期望无符号 $(0)$ 或有符号 $(1)$ 语义，而 $H$ 是仅在 $m=2$ 时使用的 $24$ 位高位模式（否则忽略）。请使用以下八个案例：\n1. $(v_8 = 5, m = 0, s = 0, H = 0)$\n2. $(v_8 = 200, m = 0, s = 1, H = 0)$\n3. $(v_8 = 128, m = 1, s = 0, H = 0)$\n4. $(v_8 = 127, m = 1, s = 1, H = 0)$\n5. $(v_8 = 255, m = 0, s = 1, H = 0)$\n6. $(v_8 = 42, m = 2, s = 0, H = 0x55AA77)$\n7. $(v_8 = 200, m = 2, s = 1, H = 0x00F0F0)$\n8. $(v_8 = 0, m = 2, s = 0, H = 0x123456)$\n\n您的程序必须做什么：\n- 硬编码上述测试套件。\n- 对每个测试用例，根据 $m$ 和 $H$ 构造 $R$。\n- 根据 $v_8$ 和 $s$ 计算 $V_{\\text{intended}}$。\n- 根据 $R$ 和 $s$ 计算 $V_{\\text{before}}$。\n- 根据指定的修复方法计算 $V_{\\text{after}}$。\n- 为每个测试用例生成一个分类代码 $C$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个逗号分隔的八个整型分类代码列表，并用方括号括起来。例如，输出格式为 $[c_1,c_2,c_3,c_4,c_5,c_6,c_7,c_8]$，其中每个 $c_i$ 是 $\\{0,1,2,3\\}$ 中的一个。\n\n无需读取输入。不允许访问外部文件或网络。所有内部计算必须使用与上述定义一致的整数算术来执行。所有角度、物理单位或百分比均不适用于此问题；所有数值都是无单位的整数。",
            "solution": "问题陈述已经过验证，被认为是合理的。它科学地基于计算机体系结构和编译器设计的原理，特别是关于整数表示和应用程序二进制接口（ABI）。该问题定义良好，所有术语、条件和测试用例都有明确的定义且没有矛盾。它代表了一个可形式化和可验证的模拟任务。\n\n任务是模拟一个用于传递小整数参数的 ABI 规则，检测违规行为，并对被调用者端的修复机制进行建模。模拟将针对一个特定的测试套件进行，每个测试的结果将被分类。\n\n基本原理植根于整数算术和位级表示。规范寄存器宽度指定为 $W_c = 32$ 位。我们关注的是一个 $8$ 位的源有效负载 $v_8$。\n\nABI 规定，这样的小整数参数必须由调用者“提升”到完整的寄存器宽度 $W_c$。提升规则取决于函数参数声明的符号性。\n1.  **零扩展**：对于无符号参数，值 $v_8$ 通过用零填充最高有效的 24 位来扩展到 32 位。这正式定义为 $\\operatorname{extz}_{8 \\to 32}(v_8)$。\n2.  **符号扩展**：对于有符号参数，该值根据其在位置 7 的最高有效位（MSB）进行扩展。如果 MSB 为 0，则该值被视为正数并进行零扩展。如果 MSB 为 1，则该值被视为负数（在二进制补码中）并通过用一填充最高有效的 24 位来扩展。这正式定义为 $\\operatorname{exts}_{8 \\to 32}(v_8)$。\n\n模拟对一个调用者和一个被调用者进行建模，调用者可能遵守也可能不遵守此 ABI，而被调用者则解释接收到的寄存器值。\n-   **预期值**，$V_{\\text{intended}}$，是如果调用者正确遵守 ABI，被调用者应该收到的值。它要么是 $\\operatorname{extz}_{8 \\to 32}(v_8)$ 要么是 $\\operatorname{exts}_{8 \\to 32}(v_8)$，取决于被调用者的期望。\n-   **原始寄存器值**，$R$，是调用者放入寄存器的一个 $32$ 位模式。调用者可能正确地扩展了值，错误地扩展了它（例如，对一个有符号值进行零扩展），或者未经扩展地传递它，使高位处于不确定状态（垃圾数据）。\n-   **修复前的值**，$V_{\\text{before}}$，是被调用者对原始寄存器 $R$ 的朴素解释，将其转换为其期望的有符号或无符号 $32$ 位类型。\n-   **修复后的值**，$V_{\\text{after}}$，是在函数序言中应用规范修复序列的结果。此修复定义为屏蔽接收到的寄存器 $R$ 的低 $8$ 位，并根据被调用者的期望重新应用正确的扩展规则：$\\operatorname{exts}_{8 \\to 32}(R  255)$ 或 $\\operatorname{extz}_{8 \\to 32}(R  255)$。\n\n模拟将通过比较 $V_{\\text{intended}}$、$V_{\\text{before}}$ 和 $V_{\\text{after}}$，将每个测试用例分为四类之一（$C \\in \\{0, 1, 2, 3\\}$）。\n\n在 C 语言实现中，我们使用固定宽度的整数类型来精确地模拟位级操作。具体来说，`unsigned char` 表示 $8$ 位有效负载 $v_8$，而 `unsigned int` 和 `signed int` 表示 $32$ 位的寄存器值和解释后的整数，并使用 `_Static_assert` 来保证它们的大小。\n\n扩展函数是使用 C 语言的类型转换规则实现的，这些规则直接映射到所需的机器级操作：\n-   `exts_8_to_32(x)` 的实现方式是先将一个 `unsigned char` 转换为 `signed char`，然后再转换为 `signed int`。从 `signed char`到 `signed int` 的提升会执行符号扩展。\n-   `extz_8_to_32(x)` 的实现方式是将一个 `unsigned char` 转换为 `unsigned int`。这种提升会用零填充高位。\n\n作为一个代表性例子，我们来分析测试用例 2：$(v_8 = 200, m = 0, s = 1, H = 0)$。\n-   **已知条件**：有效负载为 $v_8 = 200$ ($0xC8$)。调用者模式为 $m=0$，表示调用者执行零扩展。被调用者期望为 $s=1$，表示它期望一个有符号值。这是一个 ABI 不匹配：被调用者期望一个符号扩展的值，但调用者提供了一个零扩展的值。\n-   **预期值 ($V_{\\text{intended}}$)**：被调用者期望一个有符号值，所以预期值是 $v_8$ 的符号扩展。作为一个 $8$ 位有符号整数，$200$ 表示 $200 - 256 = -56$。\n    $$V_{\\text{intended}} = \\operatorname{exts}_{8 \\to 32}(200) = -56$$\n    在 $32$ 位二进制补码中，这是 $0xFFFFFFC8$。\n-   **寄存器值 ($R$)**：调用者执行零扩展。\n    $$R = \\operatorname{extz}_{8 \\to 32}(200) = 200$$\n    寄存器中的位模式是 $0x000000C8$。\n-   **修复前的值 ($V_{\\text{before}}$)**：被调用者朴素地将寄存器 $R$ 解释为一个有符号 $32$ 位整数。\n    $$V_{\\text{before}} = (\\text{signed})0x000000C8 = 200$$\n-   **修复后的值 ($V_{\\text{after}}$)**：被调用者为有符号参数应用修复。它屏蔽 $R$ 的低 $8$ 位并重新应用符号扩展。\n    $$V_{\\text{after}} = \\operatorname{exts}_{8 \\to 32}(R  255) = \\operatorname{exts}_{8 \\to 32}(0x000000C8  255) = \\operatorname{exts}_{8 \\to 32}(200) = -56$$\n-   **分类 ($C$)**：\n    -   $V_{\\text{before}} = V_{\\text{intended}}$ 吗？不，$200 \\ne -56$。\n    -   $V_{\\text{after}} = V_{\\text{intended}}$ 吗？是，$-56 = -56$。\n    -   条件是 ($V_{\\text{before}} \\ne V_{\\text{intended}}$ 且 $V_{\\text{after}} = V_{\\text{intended}}$)，这对应于 $C=1$。ABI 不匹配导致了不正确的解释，但被调用者端的修复成功恢复了预期值。\n\n对所有八个测试用例重复此分析。修复机制被证明是稳健的，因为它总是从寄存器的低 $8$ 位重新推导出有效负载（$R  255$ 总是等于 $v_8$）并正确地重新扩展它。因此，$V_{\\text{after}}$ 总是等于 $V_{\\text{intended}}$，分类 $C=2$ 和 $C=3$ 永远不会出现。",
            "answer": "[0,1,1,0,1,1,1,1]"
        },
        {
            "introduction": "现代处理器通过向量指令（SIMD）等技术实现高性能计算，但这通常要求内存操作数满足严格的对齐要求。此练习  将调用序列的设计与底层硬件约束联系起来。你将分析从参数传递、`call` 指令执行到保存寄存器等一系列操作如何影响栈指针的对齐状态。通过计算必要的对齐填充（shim），你将学会如何确保调用序列满足硬件要求，从而避免因内存未对齐而导致的严重性能损失。",
            "id": "3626519",
            "problem": "您的任务是为一个应用程序二进制接口（ABI）下的函数设计并分析一个简化的调用序列。目标是从第一性原理出发，推导栈指针的对齐方式如何与复数传递及函数序言相互作用。您必须编写一个完整的程序，该程序能根据一小组测试用例，计算函数是否会在其序言中执行未对齐的向量加载，并确定避免这种情况所需的最小对齐填充（shim）。\n\n该问题的基础如下：\n\n- 应用程序二进制接口（ABI）规定了调用约定，包括如何传递参数以及如何管理栈指针。\n- 在传统的类 $x86\\_64$ 架构上，栈向下增长。执行 `call` 指令会原子性地将返回地址压栈，消耗 $8$ 字节的栈空间。\n- 在函数序言中保存被调用者保存的寄存器被建模为一系列 `push` 操作，每次操作消耗 $8$ 字节。\n- 复数可以通过寄存器传递（参数本身不消耗栈空间），也可以作为 $Z$ 字节的连续块在栈上传递，其中 $Z$ 是复数类型的大小（例如，单精度复数为 $8$ 字节，双精度复数为 $16$ 字节）。\n- 序言中的向量加载要求栈指针满足 $A$ 字节的对齐，表示为关于同余类 $SP \\bmod A$ 的条件。\n\n您必须：\n\n- 按顺序对以下事件对栈指针 $SP$ 的影响进行建模：栈传递参数的消耗、`call` 指令压入返回地址以及被调用者序言的压栈操作。\n- 确定在任何显式对齐填充之前的那个时刻，需要 $A$ 字节对齐的向量加载是否会发生未对齐。即，确定此时的同余类 $SP \\bmod A$ 是否非零。\n- 计算最小对齐填充（shim）的字节数，该值限制为 $8$ 的倍数，被调用者可以在其序言中从 $SP$ 中减去该值，以使后续的向量加载对齐到 $A$ 字节。\n\n您的程序必须实现上述逻辑，并为以下测试套件生成所需的结果。每个测试用例规定了：\n- $SP\\_0$: 在放置任何参数或发生调用之前，调用者的栈指针模 $A$ 的初始同余类，表示为 $[0, A)$ 范围内一个 $8$ 的倍数的整数。\n- $M$: 复数传递模式，$M = 0$ 表示复数通过寄存器传递，$M = 1$ 表示复数在栈上传递。\n- $Z$: 复数参数的字节大小。\n- $K$: 在序言中压栈的被调用者保存寄存器的数量，每次压栈消耗 $8$ 字节。\n- $A$: 序言中向量加载的对齐要求（字节）。\n\n测试套件：\n1. $SP\\_0 = 0$, $M = 0$, $Z = 16$, $K = 0$, $A = 16$。\n2. $SP\\_0 = 0$, $M = 1$, $Z = 16$, $K = 1$, $A = 16$。\n3. $SP\\_0 = 8$, $M = 0$, $Z = 8$, $K = 0$, $A = 16$。\n4. $SP\\_0 = 0$, $M = 1$, $Z = 16$, $K = 0$, $A = 32$。\n5. $SP\\_0 = 8$, $M = 0$, $Z = 8$, $K = 2$, $A = 32$。\n\n对于每个测试用例，您的程序必须计算：\n- 一个布尔类型的未对齐风险指示器 $R$，如果在序言中应用任何显式填充之前向量加载会发生未对齐，则 $R = 1$，否则 $R = 0$。\n- 最小填充 $S$（以字节为单位），限制为 $8$ 的倍数，被调用者必须在序言中从 $SP$ 中减去该值以实现向量加载的 $A$ 字节对齐。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的键值对列表。每个键值对的形式为 $[R, S]$，按给定顺序对应于测试用例。例如，输出格式必须与以下完全相同：\n\"[[R\\_1,S\\_1],[R\\_2,S\\_2],[R\\_3,S\\_3],[R\\_4,S\\_4],[R\\_5,S\\_5]]\"",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于计算机体系结构和编译器设计的原理，问题定义明确、客观，并包含推导出唯一且有意义解所需的所有必要信息。该问题描述了一个简化的但连贯的函数调用序列模型，适用于形式化分析。\n\n解决方案从第一性原理出发，通过简化的应用程序二进制接口（ABI）定义的操作序列来建模栈指针（$SP$）的状态。假设栈向低内存地址增长，这意味着在栈上分配空间涉及递减 $SP$ 的值。\n\n设 $SP_{caller}$ 为调用者在为函数调用准备参数之前的栈指针值。我们已知其关于对齐要求 $A$ 的模同余类，记为 $SP\\_0$。\n$$\nSP_{caller} \\equiv SP\\_0 \\pmod{A}\n$$\n栈指针的演变如下：\n\n1.  **参数传递**：调用者函数准备参数。如果复数参数在栈上传递（$M=1$），调用者为其分配 $Z$ 字节，从而递减栈指针。如果它在寄存器中传递（$M=0$），栈指针不受此参数影响。由于参数传递引起的 $SP$ 变化为 $- M \\times Z$。栈指针变为 $SP_{pre-call}$。\n    $$\n    SP_{pre-call} = SP_{caller} - M \\times Z\n    $$\n\n2.  **`call` 指令**：处理器的 `call` 指令在将控制权转移给被调用者之前，会将 $8$ 字节的返回地址压入栈中。这会使栈指针递减 $8$。进入被调用者函数时的栈指针为 $SP_{entry}$。\n    $$\n    SP_{entry} = SP_{pre-call} - 8 = SP_{caller} - M \\times Z - 8\n    $$\n\n3.  **被调用者序言**：在被调用者内部，函数序言将 $K$ 个被调用者保存的寄存器保存到栈上。每次 `push` 操作消耗 $8$ 字节。这会使栈指针总共递减 $K \\times 8$ 字节。在保存寄存器的压栈操作之后，且在应用任何显式对齐填充之前的栈指针值，记为 $SP_{prologue}$。假定向量加载在此地址发生，因此该地址必须对齐。\n    $$\n    SP_{prologue} = SP_{entry} - K \\times 8 = SP_{caller} - M \\times Z - 8 - K \\times 8\n    $$\n    这可以表示为：\n    $$\n    SP_{prologue} = SP_{caller} - (M \\times Z + 8 \\times (1 + K))\n    $$\n\n为确定对齐，我们分析 $SP_{prologue}$ 模 $A$ 的同余类。设 $\\Delta$ 为从 $SP_{caller}$ 开始的总递减量：\n$$\n\\Delta = M \\times Z + 8(1 + K)\n$$\n那么，$SP_{prologue}$ 的同余类为：\n$$\nSP_{prologue} \\pmod{A} \\equiv (SP_{caller} - \\Delta) \\pmod{A}\n$$\n代入给定的初始条件 $SP_{caller} \\equiv SP\\_0 \\pmod{A}$：\n$$\nSP_{prologue} \\pmod{A} \\equiv (SP\\_0 - \\Delta) \\pmod{A}\n$$\n设 $C$ 为此最终同余类，其中 $C \\in [0, A-1]$。\n$$\nC = (SP\\_0 - \\Delta) \\pmod{A}\n$$\n对于计算实现，必须注意负数的模运算。一个稳健的 $C$ 计算方法是 $C = (SP\\_0 - (\\Delta \\pmod{A}) + A) \\pmod{A}$。\n\n然后从 $C$ 确定两个所需的输出：\n\n-   **未对齐风险 ($R$)**：如果 $SP_{prologue}$ 不是 $A$ 的倍数，则会发生未对齐，这当且仅当其同余类 $C$ 非零时成立。\n    $$\n    R = \\begin{cases} 1  \\text{if } C \\neq 0 \\\\ 0  \\text{if } C = 0 \\end{cases}\n    $$\n\n-   **最小对齐填充 ($S$)**：我们需要找到最小的非负填充 $S$（必须是 $8$ 的倍数），从 $SP_{prologue}$ 中减去它以实现对齐。新的栈指针 $SP_{final} = SP_{prologue} - S$ 必须满足 $SP_{final} \\equiv 0 \\pmod{A}$。\n    $$\n    (SP_{prologue} - S) \\pmod{A} = 0 \\implies (C - S) \\pmod{A} = 0 \\implies S \\equiv C \\pmod{A}\n    $$\n    最小非负解为 $S = C$。我们必须验证 $S$ 的这个值是 $8$ 的倍数。问题陈述中指出 $SP\\_0$、$Z$ 以及 `push` 操作的大小（$8$ 字节）都是 $8$ 的倍数。因此，总递减量 $\\Delta = M \\times Z + 8(1+K)$ 是 $8$ 的倍数的和，其本身也是 $8$ 的倍数。同余类 $C$ 计算为 $C \\equiv (SP\\_0 - \\Delta) \\pmod{A}$。由于 $SP\\_0$ 和 $\\Delta$ 都是 $8$ 的倍数，它们的差 $(SP\\_0 - \\Delta)$ 也是 $8$ 的倍数。值 $C$ 为 $(SP\\_0 - \\Delta) - n \\cdot A$，其中 $n$ 为某个整数。所有测试用例的对齐要求 $A$（$16, 32$）都是 $8$ 的倍数。因此，$C$ 也必须是 $8$ 的倍数。所以最小非负填充 $S$ 就是 $S=C$，它满足所有约束条件。\n\n现在我们将此方法应用于每个测试用例。\n\n**测试用例 1**：$SP\\_0 = 0, M = 0, Z = 16, K = 0, A = 16$。\n-   $\\Delta = (0 \\times 16) + 8 \\times (1 + 0) = 8$。\n-   $C = (0 - 8) \\pmod{16} = -8 \\pmod{16} = 8$。\n-   $R = 1$ 因为 $C \\neq 0$。\n-   $S = C = 8$。\n-   结果：$[1, 8]$。\n\n**测试用例 2**：$SP\\_0 = 0, M = 1, Z = 16, K = 1, A = 16$。\n-   $\\Delta = (1 \\times 16) + 8 \\times (1 + 1) = 16 + 16 = 32$。\n-   $C = (0 - 32) \\pmod{16} = 0$。\n-   $R = 0$ 因为 $C = 0$。\n-   $S = C = 0$。\n-   结果：$[0, 0]$。\n\n**测试用例 3**：$SP\\_0 = 8, M = 0, Z = 8, K = 0, A = 16$。\n-   $\\Delta = (0 \\times 8) + 8 \\times (1 + 0) = 8$。\n-   $C = (8 - 8) \\pmod{16} = 0$。\n-   $R = 0$ 因为 $C = 0$。\n-   $S = C = 0$。\n-   结果：$[0, 0]$。\n\n**测试用例 4**：$SP\\_0 = 0, M = 1, Z = 16, K = 0, A = 32$。\n-   $\\Delta = (1 \\times 16) + 8 \\times (1 + 0) = 16 + 8 = 24$。\n-   $C = (0 - 24) \\pmod{32} = -24 \\pmod{32} = 8$。\n-   $R = 1$ 因为 $C \\neq 0$。\n-   $S = C = 8$。\n-   结果：$[1, 8]$。\n\n**测试用例 5**：$SP\\_0 = 8, M = 0, Z = 8, K = 2, A = 32$。\n-   $\\Delta = (0 \\times 8) + 8 \\times (1 + 2) = 24$。\n-   $C = (8 - 24) \\pmod{32} = -16 \\pmod{32} = 16$。\n-   $R = 1$ 因为 $C \\neq 0$。\n-   $S = C = 16$。\n-   结果：$[1, 16]$。\n\n因此，该测试套件的汇总结果是 $[[1,8],[0,0],[0,0],[1,8],[1,16]]$。",
            "answer": "[[1,8],[0,0],[0,0],[1,8],[1,16]]"
        }
    ]
}