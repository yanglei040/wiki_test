{
    "hands_on_practices": [
        {
            "introduction": "At the heart of any calling convention lies a fundamental trade-off: who is responsible for preserving a register's value across a function call? This practice explores the strategic decision between designating registers as caller-saved or callee-saved. By analyzing a scenario of mutual recursion, you will quantify the performance impact of this choice and learn to optimize the save/restore overhead based on dynamic execution behavior .",
            "id": "3626228",
            "problem": "Two mutually recursive functions $A$ and $B$ execute under a custom Application Binary Interface (ABI) where the calling convention (assignment of registers as callee-saved versus caller-saved) may be chosen per register. The architecture provides a uniform cost model: each save or restore of a register to the stack costs $\\sigma$ cycles, with $\\sigma = 5$ cycles. Every save is paired with a corresponding restore, so a save-restore pair costs $2\\sigma$ cycles. Assume no optimization eliminates redundant saves or restores, and that all saves and restores required by the chosen convention are performed.\n\nThere is a finite run in which the dynamic counts are measured as follows: the number of entries into $A$ is $N_A = 310$, the number of entries into $B$ is $N_B = 300$, the number of calls from $A$ to $B$ is $C_{AB} = 300$, and the number of calls from $B$ to $A$ is $C_{BA} = 300$. The sets of registers that are live across calls (and also used within the functions) are $L_A = \\{r_1, r_2, r_5\\}$ for function $A$, and $L_B = \\{r_2, r_3, r_5\\}$ for function $B$. The universe of general-purpose registers of interest is $R = \\{r_1, r_2, r_3, r_4, r_5, r_6\\}$, but only the union $U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$ appears in the live sets during this run.\n\nBy the foundational definitions of calling conventions:\n- If a register $r$ is designated callee-saved and a function $F$ uses $r$, then on each entry to $F$ the function must save $r$ and, on exit, restore $r$, incurring $2\\sigma$ cycles per entry to $F$.\n- If a register $r$ is designated caller-saved and is live in the caller at a call site, the caller must save $r$ before the call and restore $r$ after the call, incurring $2\\sigma$ cycles per such call.\n\nYou may assign, independently for each register in $U$, whether it is callee-saved or caller-saved. Under these rules and the given dynamic counts, determine the minimal possible total dynamic save/restore overhead across the entire run, expressed in cycles. Provide a single numerical answer; no rounding is required. Express the final answer in cycles.",
            "solution": "The user wants me to solve the problem by following these steps:\n1.  **Extract Givens**: I will list all provided data, variables, constants, and conditions.\n2.  **Validate**: I will check the problem for scientific soundness, self-consistency, and well-posedness.\n3.  **Solve**: If valid, I will provide a step-by-step solution.\n\n### Step 1: Extract Givens\n- Cost of a single register save or restore operation: $\\sigma = 5$ cycles.\n- Cost of a save-restore pair: $2\\sigma = 10$ cycles.\n- Number of entries into function $A$: $N_A = 310$.\n- Number of entries into function $B$: $N_B = 300$.\n- Number of calls from $A$ to $B$: $C_{AB} = 300$.\n- Number of calls from $B$ to $A$: $C_{BA} = 300$.\n- Set of registers live across calls in function $A$: $L_A = \\{r_1, r_2, r_5\\}$.\n- Set of registers live across calls in function $B$: $L_B = \\{r_2, r_3, r_5\\}$.\n- Universe of registers of interest: $U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is grounded in the principles of computer architecture and compiler design, specifically regarding calling conventions and register allocation. The concepts of callee-saved and caller-saved registers, function call overhead, and liveness analysis are standard and well-defined.\n- **Well-Posedness**: The problem asks for the minimum possible overhead, which is a well-defined optimization problem. The rules for calculating overhead are explicit and unambiguous. The provided data is sufficient to calculate the costs for each possible register convention assignment.\n- **Consistency**: The dynamic counts are consistent. The $N_A = 310$ entries into function $A$ and $C_{BA} = 300$ calls from $B$ to $A$ imply that there were $N_A - C_{BA} = 310 - 300 = 10$ initial entries into $A$ from an external context. The $N_B = 300$ entries into function $B$ and $C_{AB} = 300$ calls from $A$ to $B$ imply that all entries into $B$ originated from $A$. This describes a valid execution trace.\n- **Objectivity**: The problem is stated using objective, quantitative data and formal definitions.\n\nThe problem is valid.\n\n### Step 3: Solution\nThe objective is to determine a calling convention for each register in the set $U = \\{r_1, r_2, r_3, r_5\\}$ that minimizes the total dynamic save/restore overhead. The choice for each register (callee-saved vs. caller-saved) is independent. Therefore, we can minimize the overhead for each register individually and sum the results to find the total minimum overhead.\n\nFor any register $r$, we must compare the cost of designating it as callee-saved versus caller-saved. The cost for a save-restore pair is $2\\sigma = 2 \\times 5 = 10$ cycles.\n\n**Cost of Callee-Saved Convention**\nIf a register $r$ is designated callee-saved, the callee function must save it upon entry and restore it upon exit if the function itself uses the register. The problem states that a function $F$ \"uses\" a register $r$ if $r$ is in its live set $L_F$.\nThe total cost for a callee-saved register $r$ is the sum of costs for each function that uses it.\n- If function $A$ uses $r$ (i.e., $r \\in L_A$), the cost incurred is $N_A \\times 2\\sigma$, as $A$ is entered $N_A$ times.\n- If function $B$ uses $r$ (i.e., $r \\in L_B$), the cost incurred is $N_B \\times 2\\sigma$, as $B$ is entered $N_B$ times.\n\nThe total cost for a callee-saved register $r$ is:\n$$Cost_{callee}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot N_A + \\mathbb{I}(r \\in L_B) \\cdot N_B)$$\nwhere $\\mathbb{I}(\\cdot)$ is the indicator function, which is $1$ if the condition is true and $0$ otherwise.\n\n**Cost of Caller-Saved Convention**\nIf a register $r$ is designated caller-saved, the caller function must save it before a call and restore it after the call, if the register's value is live in the caller.\n- Function $A$ makes $C_{AB}$ calls to $B$. If $r$ is live in $A$ (i.e., $r \\in L_A$), a save/restore is needed for each of these calls. The cost is $C_{AB} \\times 2\\sigma$.\n- Function $B$ makes $C_{BA}$ calls to $A$. If $r$ is live in $B$ (i.e., $r \\in L_B$), a save/restore is needed for each of these calls. The cost is $C_{BA} \\times 2\\sigma$.\n\nThe total cost for a caller-saved register $r$ is:\n$$Cost_{caller}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot C_{AB} + \\mathbb{I}(r \\in L_B) \\cdot C_{BA})$$\n\nNow, we calculate the minimum cost for each register in $U$.\n\n**For register $r_1$:**\n$r_1 \\in L_A$ and $r_1 \\notin L_B$.\n- $Cost_{callee}(r_1) = 2\\sigma \\times (1 \\cdot N_A + 0 \\cdot N_B) = 10 \\times 310 = 3100$ cycles.\n- $Cost_{caller}(r_1) = 2\\sigma \\times (1 \\cdot C_{AB} + 0 \\cdot C_{BA}) = 10 \\times 300 = 3000$ cycles.\nThe minimum cost for $r_1$ is $\\min(3100, 3000) = 3000$ cycles. This is achieved by making $r_1$ caller-saved.\n\n**For register $r_2$:**\n$r_2 \\in L_A$ and $r_2 \\in L_B$.\n- $Cost_{callee}(r_2) = 2\\sigma \\times (1 \\cdot N_A + 1 \\cdot N_B) = 10 \\times (310 + 300) = 10 \\times 610 = 6100$ cycles.\n- $Cost_{caller}(r_2) = 2\\sigma \\times (1 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times (300 + 300) = 10 \\times 600 = 6000$ cycles.\nThe minimum cost for $r_2$ is $\\min(6100, 6000) = 6000$ cycles. This is achieved by making $r_2$ caller-saved.\n\n**For register $r_3$:**\n$r_3 \\notin L_A$ and $r_3 \\in L_B$.\n- $Cost_{callee}(r_3) = 2\\sigma \\times (0 \\cdot N_A + 1 \\cdot N_B) = 10 \\times 300 = 3000$ cycles.\n- $Cost_{caller}(r_3) = 2\\sigma \\times (0 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times 300 = 3000$ cycles.\nThe minimum cost for $r_3$ is $\\min(3000, 3000) = 3000$ cycles. The cost is the same for either convention.\n\n**For register $r_5$:**\n$r_5 \\in L_A$ and $r_5 \\in L_B$. This case is identical to $r_2$.\n- $Cost_{callee}(r_5) = 10 \\times (310 + 300) = 6100$ cycles.\n- $Cost_{caller}(r_5) = 10 \\times (300 + 300) = 6000$ cycles.\nThe minimum cost for $r_5$ is $\\min(6100, 6000) = 6000$ cycles. This is achieved by making $r_5$ caller-saved.\n\n**Total Minimal Overhead**\nThe total minimal overhead is the sum of the minimum costs for each register in $U$. Registers outside of $U$ (i.e., $r_4$ and $r_6$) are not live across any calls in $A$ or $B$, so they incur no save/restore overhead.\n$$Cost_{total} = \\min Cost(r_1) + \\min Cost(r_2) + \\min Cost(r_3) + \\min Cost(r_5)$$\n$$Cost_{total} = 3000 + 6000 + 3000 + 6000 = 18000$$\n\nThe minimal possible total dynamic save/restore overhead across the entire run is $18000$ cycles.",
            "answer": "$$\\boxed{18000}$$"
        },
        {
            "introduction": "A calling convention is a strict contract, and a mismatch in data interpretation between a caller and callee can lead to subtle and hard-to-diagnose bugs. This exercise focuses on the Application Binary Interface (ABI) rules for passing small integer types, a common source of such issues. Through a hands-on simulation, you will see how concepts like sign and zero extension are critical for correctness and how a well-designed function prologue can enforce ABI compliance .",
            "id": "3626585",
            "problem": "Design and implement a small, self-contained simulator that formalizes an Application Binary Interface (ABI) rule for small integer promotion in a calling sequence, and then detects and repairs mismatches when callers pass $8$-bit values. Your program must codify the ABI’s canonical rule, simulate caller behavior (correct and incorrect), model callee interpretation, and apply a principled callee prologue fixup to recover the mathematically intended value.\n\nFundamental base and definitions:\n- An Application Binary Interface (ABI) is a contract governing how values are passed across function boundaries. The ABI you must implement adopts a canonical integer register width of $W_c = 32$ bits.\n- For any argument whose declared width is $w \\le 8$ bits, the caller must promote the value to $W_c$ bits according to the declared signedness:\n  - If the declared type is unsigned, the caller must perform zero extension from $w$ bits to $W_c$ bits.\n  - If the declared type is signed (two’s complement), the caller must perform sign extension from $w$ bits to $W_c$ bits.\n- Two’s complement sign extension from $w$ bits to $W_c$ bits is defined by the following function: for any integer $x$ represented in $w$ bits,\n  $$\n  \\operatorname{exts}_{w \\to W_c}(x) =\n  \\begin{cases}\n  x, & \\text{if the most significant bit of } x \\text{ is } 0,\\\\\n  x \\,\\vert\\, \\big(\\text{all ones in bits } [w, W_c-1]\\big), & \\text{if the most significant bit of } x \\text{ is } 1.\n  \\end{cases}\n  $$\n  For $w = 8$ and $W_c = 32$, this is equivalent to: if $(x \\,\\&\\, 2^{7}) \\ne 0$ then $x \\,\\vert\\, \\left(\\sum_{i=8}^{31} 2^i\\right)$ else $x$.\n- Zero extension from $w$ bits to $W_c$ bits is defined as\n  $$\n  \\operatorname{extz}_{w \\to W_c}(x) = x \\,\\&\\, \\left(\\sum_{i=0}^{w-1} 2^i\\right).\n  $$\n\nCaller and callee model:\n- Let the source $8$-bit payload be $v_8 \\in \\{0,1,\\dots,255\\}$.\n- The mathematically intended value according to the callee’s parameter type is:\n  - If the callee expects signed $8$-bit, the intended $32$-bit value is $V_{\\text{intended}} = \\operatorname{exts}_{8 \\to 32}(v_8)$, representing the integer in $\\mathbb{Z}$ encoded in two’s complement within $32$ bits.\n  - If the callee expects unsigned $8$-bit, the intended $32$-bit value is $V_{\\text{intended}} = \\operatorname{extz}_{8 \\to 32}(v_8)$.\n- The caller places a raw $32$-bit register value $R$ according to one of three behaviors:\n  1. Correct zero extension: $R = \\operatorname{extz}_{8 \\to 32}(v_8)$.\n  2. Correct sign extension: $R = \\operatorname{exts}_{8 \\to 32}(v_8)$.\n  3. Raw unextended: $R = (H \\ll 8) \\,\\vert\\, (v_8 \\,\\&\\, 255)$, where $H$ is a $24$-bit pattern potentially left over in bits $[8,31]$, and $\\ll$ denotes logical left shift.\n- The callee’s naive interpretation (without fixup) is:\n  - If the callee expects signed, interpret $R$ as a signed $32$-bit two’s complement integer, giving $V_{\\text{before}}$.\n  - If the callee expects unsigned, interpret $R$ as an unsigned $32$-bit integer, giving $V_{\\text{before}}$.\n- The callee’s prologue fixup you must implement is the canonical repair for small-integer promotion mismatches:\n  $$\n  V_{\\text{after}} = \n  \\begin{cases}\n  \\operatorname{exts}_{8 \\to 32}(R \\,\\&\\, 255), & \\text{if callee expects signed},\\\\\n  \\operatorname{extz}_{8 \\to 32}(R \\,\\&\\, 255), & \\text{if callee expects unsigned}.\n  \\end{cases}\n  $$\n  This corresponds to masking the low $8$ bits and re-extending according to the callee’s declared signedness. This fixup is idempotent if the caller already followed the ABI.\n\nClassification to output for each test case:\n- Let $C$ be the classification code defined by:\n  - $C = 0$ if $V_{\\text{before}} = V_{\\text{intended}}$ and $V_{\\text{after}} = V_{\\text{intended}}$.\n  - $C = 1$ if $V_{\\text{before}} \\ne V_{\\text{intended}}$ but $V_{\\text{after}} = V_{\\text{intended}}$.\n  - $C = 2$ if $V_{\\text{after}} \\ne V_{\\text{intended}}$ (unrepaired bug).\n  - $C = 3$ if $V_{\\text{before}} = V_{\\text{intended}}$ but $V_{\\text{after}} \\ne V_{\\text{intended}}$ (a regression due to fixup; this should not occur with the stated fix).\n\nTest suite:\nEach test case is a tuple $(v_8, m, s, H)$ where $v_8$ is the $8$-bit payload, $m \\in \\{0,1,2\\}$ is the caller mode with $0$ meaning zero extend, $1$ meaning sign extend, $2$ meaning raw unextended, $s \\in \\{0,1\\}$ indicates the callee expects unsigned $(0)$ or signed $(1)$ semantics, and $H$ is the $24$-bit high pattern used only when $m=2$ (otherwise ignored). Use the following eight cases:\n1. $(v_8 = 5, m = 0, s = 0, H = 0)$\n2. $(v_8 = 200, m = 0, s = 1, H = 0)$\n3. $(v_8 = 128, m = 1, s = 0, H = 0)$\n4. $(v_8 = 127, m = 1, s = 1, H = 0)$\n5. $(v_8 = 255, m = 0, s = 1, H = 0)$\n6. $(v_8 = 42, m = 2, s = 0, H = 0x55AA77)$\n7. $(v_8 = 200, m = 2, s = 1, H = 0x00F0F0)$\n8. $(v_8 = 0, m = 2, s = 0, H = 0x123456)$\n\nWhat your program must do:\n- Hard-code the above test suite.\n- For each test case, construct $R$ according to $m$ and $H$.\n- Compute $V_{\\text{intended}}$ from $v_8$ and $s$.\n- Compute $V_{\\text{before}}$ from $R$ and $s$.\n- Compute $V_{\\text{after}}$ from the specified fixup.\n- Produce a classification code $C$ for each test case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of the eight integer classification codes enclosed in square brackets. For example, an output of the form $[c_1,c_2,c_3,c_4,c_5,c_6,c_7,c_8]$ where each $c_i$ is one of $\\{0,1,2,3\\}$.\n\nNo input is to be read. No external files or network access are permitted. All internal computations must be performed using integer arithmetic consistent with the above definitions. All angles, physical units, or percentages are not applicable to this problem; all numerical values are unitless integers.",
            "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of computer architecture and compiler design, specifically concerning integer representations and Application Binary Interfaces (ABIs). The problem is well-posed, with all terms, conditions, and test cases defined explicitly and without contradiction. It represents a formalizable and verifiable simulation task.\n\nThe task is to simulate an ABI rule for passing small integer arguments, detect violations, and model a callee-side fixup mechanism. The simulation will be performed for a specific test suite, and the outcome of each test will be categorized.\n\nThe fundamental principles are rooted in integer arithmetic and bit-level representation. The canonical register width is specified as $W_c = 32$ bits. We are concerned with an $8$-bit source payload, $v_8$.\n\nThe ABI dictates that such small integer arguments must be \"promoted\" to the full register width $W_c$ by the caller. The promotion rule depends on the declared signedness of the function parameter.\n1.  **Zero Extension**: For an unsigned parameter, the value $v_8$ is extended to $32$ bits by padding the most significant $24$ bits with zeros. This is formally defined as $\\operatorname{extz}_{8 \\to 32}(v_8)$.\n2.  **Sign Extension**: For a signed parameter, the value is extended based on its most significant bit (MSB) at position $7$. If the MSB is $0$, the value is treated as positive and zero-extended. If the MSB is $1$, the value is treated as negative (in two's complement) and extended by padding the most significant $24$ bits with ones. This is formally defined as $\\operatorname{exts}_{8 \\to 32}(v_8)$.\n\nThe simulation models a caller, which may or may not adhere to this ABI, and a callee, which interprets the received register value.\n-   The **intended value**, $V_{\\text{intended}}$, is what the callee should receive if the caller correctly follows the ABI. It is either $\\operatorname{extz}_{8 \\to 32}(v_8)$ or $\\operatorname{exts}_{8 \\to 32}(v_8)$, depending on the callee's expectation.\n-   The **raw register value**, $R$, is a $32$-bit pattern placed in a register by the caller. The caller might correctly extend the value, incorrectly extend it (e.g., zero-extend a signed value), or pass it unextended, leaving high-order bits in an indeterminate state (garbage).\n-   The **value before fixup**, $V_{\\text{before}}$, is the callee's naive interpretation of the raw register $R$, casting it to its expected signed or unsigned $32$-bit type.\n-   The **value after fixup**, $V_{\\text{after}}$, is the result of applying a canonical repair sequence in the function prologue. This fixup is defined as masking the low $8$ bits of the received register $R$ and re-applying the correct extension rule based on the callee's expectation: $\\operatorname{exts}_{8 \\to 32}(R \\,\\&\\, 255)$ or $\\operatorname{extz}_{8 \\to 32}(R \\,\\&\\, 255)$.\n\nThe simulation will classify each test case into one of four categories ($C \\in \\{0, 1, 2, 3\\}$) by comparing $V_{\\text{intended}}$, $V_{\\text{before}}$, and $V_{\\text{after}}$.\n\nIn the C implementation, we use fixed-width integer types to accurately model the bit-level operations. Specifically, `unsigned char` represents the $8$-bit payload $v_8$, and `unsigned int` and `signed int` represent the $32$-bit register values and interpreted integers, with `_Static_assert` used to guarantee their sizes.\n\nThe extension functions are implemented using C's type casting rules, which directly map to the desired machine-level operations:\n-   `exts_8_to_32(x)` is implemented by casting an `unsigned char` to `signed char`, and then to `signed int`. The promotion from `signed char` to `signed int` performs the sign extension.\n-   `extz_8_to_32(x)` is implemented by casting an `unsigned char` to `unsigned int`. This promotion pads the higher-order bits with zeros.\n\nAs a representative example, let us analyze Test Case 2: $(v_8 = 200, m = 0, s = 1, H = 0)$.\n-   **Givens**: The payload is $v_8 = 200$ ($0xC8$). The caller mode is $m=0$, meaning the caller performs zero extension. The callee expectation is $s=1$, meaning it expects a signed value. This is an ABI mismatch: the callee expects a sign-extended value, but the caller provides a zero-extended one.\n-   **Intended Value ($V_{\\text{intended}}$)**: The callee expects a signed value, so the intended value is the sign extension of $v_8$. As an $8$-bit signed integer, $200$ represents $200 - 256 = -56$.\n    $$V_{\\text{intended}} = \\operatorname{exts}_{8 \\to 32}(200) = -56$$\n    In $32$-bit two's complement, this is $0xFFFFFFC8$.\n-   **Register Value ($R$)**: The caller performs zero extension.\n    $$R = \\operatorname{extz}_{8 \\to 32}(200) = 200$$\n    The bit pattern in the register is $0x000000C8$.\n-   **Value Before Fixup ($V_{\\text{before}}$)**: The callee naively interprets the register $R$ as a signed $32$-bit integer.\n    $$V_{\\text{before}} = (\\text{signed})0x000000C8 = 200$$\n-   **Value After Fixup ($V_{\\text{after}}$)**: The callee applies the fixup for a signed parameter. It masks the low $8$ bits of $R$ and re-applies sign extension.\n    $$V_{\\text{after}} = \\operatorname{exts}_{8 \\to 32}(R \\,\\&\\, 255) = \\operatorname{exts}_{8 \\to 32}(0x000000C8 \\,\\&\\, 255) = \\operatorname{exts}_{8 \\to 32}(200) = -56$$\n-   **Classification ($C$)**:\n    -   Is $V_{\\text{before}} = V_{\\text{intended}}$? No, $200 \\ne -56$.\n    -   Is $V_{\\text{after}} = V_{\\text{intended}}$? Yes, $-56 = -56$.\n    -   The condition is ($V_{\\text{before}} \\ne V_{\\text{intended}}$ and $V_{\\text{after}} = V_{\\text{intended}}$), which corresponds to $C=1$. The ABI mismatch caused an incorrect interpretation, but the callee-side fixup successfully recovered the intended value.\n\nThis analysis is repeated for all eight test cases. The fixup mechanism proves robust, as it always re-derives the payload from the low $8$ bits of the register ($R \\,\\&\\, 255$ is always equal to $v_8$) and correctly re-extends it. Consequently, $V_{\\text{after}}$ is always equal to $V_{\\text{intended}}$, and classifications $C=2$ and $C=3$ never occur.",
            "answer": "```c\n// The complete and compilable C program.\n// Headers adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n// #include <string.h> // Not used\n// #include <math.h>   // Not used\n// #include <complex.h> // Not used\n// #include <threads.h> // Not used\n// #include <stdatomic.h> // Not used\n\n// Per C23 standard, these assertions can validate type sizes.\n// This ensures our simulation correctly models 8-bit and 32-bit quantities.\n#if __STDC_VERSION__ >= 201112L\n_Static_assert(sizeof(unsigned char) == 1, \"Type 'unsigned char' must be 8 bits.\");\n_Static_assert(sizeof(signed char) == 1, \"Type 'signed char' must be 8 bits.\");\n_Static_assert(sizeof(unsigned int) == 4, \"Type 'unsigned int' must be 32 bits.\");\n_Static_assert(sizeof(signed int) == 4, \"Type 'signed int' must be 32 bits.\");\n#endif\n\n// Type definitions for clarity and precision.\ntypedef unsigned char u8;\ntypedef signed char   i8;\ntypedef unsigned int  u32;\ntypedef signed int    i32;\ntypedef _Bool bool_t; // C23 has `bool` but stdbool.h is not on the allowed list. _Bool is a keyword.\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    u8 v8; // 8-bit payload\n    int m; // Caller mode: 0=zero-extend, 1=sign-extend, 2=raw\n    int s; // Callee expectation: 0=unsigned, 1=signed\n    u32 H; // 24-bit high pattern for raw mode\n} TestCase;\n\n// Implements sign extension from 8 to 32 bits.\n// In C, casting from a signed small type to a signed larger type\n// preserves the numerical value, which means sign extension is performed.\ni32 exts_8_to_32(u8 x) {\n    return (i32)(i8)x;\n}\n\n// Implements zero extension from 8 to 32 bits.\n// In C, casting from an unsigned small type to an unsigned larger type\n// pads the higher-order bits with zero.\nu32 extz_8_to_32(u8 x) {\n    return (u32)x;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {5,   0, 0, 0x0},\n        {200, 0, 1, 0x0},\n        {128, 1, 0, 0x0},\n        {127, 1, 1, 0x0},\n        {255, 0, 1, 0x0},\n        {42,  2, 0, 0x55AA77},\n        {200, 2, 1, 0x00F0F0},\n        {0,   2, 0, 0x123456}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        u32 R; // The 32-bit raw value in the register\n\n        // 1. Construct the register value R based on the caller's mode 'm'.\n        switch (tc.m) {\n            case 0: // Correct zero extension\n                R = extz_8_to_32(tc.v8);\n                break;\n            case 1: // Correct sign extension\n                // The C cast to u32 preserves the bit pattern of the signed extended value.\n                R = (u32)exts_8_to_32(tc.v8);\n                break;\n            case 2: // Raw unextended, with high bits containing garbage 'H'\n                R = (tc.H << 8) | tc.v8;\n                break;\n            default: // Should not happen\n                R = 0;\n                break;\n        }\n\n        // 2. Determine intended, before, and after values to classify the interaction.\n        if (tc.s == 1) { // Callee expects a SIGNED value.\n            i32 v_intended = exts_8_to_32(tc.v8);\n            i32 v_before = (i32)R; // Naive interpretation of R as signed.\n            i32 v_after = exts_8_to_32((u8)(R & 0xFF)); // Fixup: mask and re-extend.\n\n            bool_t before_ok = (v_before == v_intended);\n            bool_t after_ok = (v_after == v_intended);\n\n            if (before_ok && after_ok) {\n                results[i] = 0;\n            } else if (!before_ok && after_ok) {\n                results[i] = 1;\n            } else if (!after_ok) {\n                results[i] = 2;\n            } else { // before_ok && !after_ok\n                results[i] = 3;\n            }\n        } else { // Callee expects an UNSIGNED value.\n            u32 v_intended = extz_8_to_32(tc.v8);\n            u32 v_before = R; // Naive interpretation of R as unsigned.\n            u32 v_after = extz_8_to_32((u8)(R & 0xFF)); // Fixup: mask and re-extend.\n\n            bool_t before_ok = (v_before == v_intended);\n            bool_t after_ok = (v_after == v_intended);\n\n            if (before_ok && after_ok) {\n                results[i] = 0;\n            } else if (!before_ok && after_ok) {\n                results[i] = 1;\n            } else if (!after_ok) {\n                results[i] = 2;\n            } else { // before_ok && !after_ok\n                results[i] = 3;\n            }\n        }\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Modern processors achieve high performance using vector instructions, which often impose strict memory alignment requirements. This practice delves into the management of the stack pointer, demonstrating how every operation in a calling sequence—from pushing arguments to saving registers—affects its alignment. You will model the stack pointer's state throughout a function call and determine the necessary adjustments to satisfy hardware constraints, linking ABI design directly to performance optimization .",
            "id": "3626519",
            "problem": "You are tasked with designing and analyzing a simplified calling sequence for a function under an Application Binary Interface (ABI). The goal is to reason from first principles about how the stack pointer alignment interacts with passing complex numbers and the function prologue. You must write a complete program that, given a small set of test cases, computes whether a function would perform misaligned vector loads in its prologue and determines the minimal alignment shim to avoid them.\n\nThe foundational base for this problem is as follows:\n\n- The Application Binary Interface (ABI) specifies calling conventions, including how arguments are passed and how the stack pointer is managed.\n- On a conventional $x86\\_64$-like architecture, the stack grows downward. Executing a call instruction atomically pushes the return address, consuming $8$ bytes of stack space.\n- Preserving callee-saved registers in a function prologue is modeled as a sequence of push operations, each consuming $8$ bytes.\n- A complex number can be passed either in registers (no stack space consumption for the argument itself) or on the stack as a contiguous block of $Z$ bytes, where $Z$ is the size of the complex type (for example, $8$ for a single-precision complex and $16$ for a double-precision complex).\n- Vector loads in the prologue require the stack pointer to satisfy an alignment of $A$ bytes, expressed as a condition on the congruence class $SP \\bmod A$.\n\nYou must:\n\n- Model the effect on the stack pointer $SP$ of the following events, in order: stack-passed arguments consumption, the call instruction pushing the return address, and callee prologue pushes.\n- Determine whether, at the point immediately before any explicit alignment padding, a vector load requiring $A$-byte alignment would be misaligned. That is, determine if the congruence class $SP \\bmod A$ at that point is nonzero.\n- Compute the minimal alignment shim in bytes, constrained to multiples of $8$, that the callee can subtract from $SP$ in its prologue so that the subsequent vector loads are aligned to $A$ bytes.\n\nYour program must implement the above logic and produce the required results for the following test suite. Each test case specifies:\n- $SP\\_0$: the initial congruence class of the caller's stack pointer modulo $A$ before any arguments are placed or the call occurs, expressed as an integer in $[0, A)$ that is a multiple of $8$.\n- $M$: the complex passing mode, with $M = 0$ meaning the complex number is passed in registers and $M = 1$ meaning the complex number is passed on the stack.\n- $Z$: the byte size of the complex argument.\n- $K$: the number of callee-saved registers pushed in the prologue, each push consuming $8$ bytes.\n- $A$: the alignment requirement in bytes for vector loads in the prologue.\n\nTest suite:\n1. $SP\\_0 = 0$, $M = 0$, $Z = 16$, $K = 0$, $A = 16$.\n2. $SP\\_0 = 0$, $M = 1$, $Z = 16$, $K = 1$, $A = 16$.\n3. $SP\\_0 = 8$, $M = 0$, $Z = 8$, $K = 0$, $A = 16$.\n4. $SP\\_0 = 0$, $M = 1$, $Z = 16$, $K = 0$, $A = 32$.\n5. $SP\\_0 = 8$, $M = 0$, $Z = 8$, $K = 2$, $A = 32$.\n\nFor each test case, your program must compute:\n- A boolean misalignment risk indicator $R$, where $R = 1$ if the vector load would be misaligned immediately before applying any explicit shim in the prologue, and $R = 0$ otherwise.\n- The minimal shim $S$ in bytes, constrained to multiples of $8$, that the callee must subtract from $SP$ in the prologue to achieve $A$-byte alignment for the vector loads.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of pairs enclosed in square brackets. Each pair is of the form $[R, S]$ corresponding to the test cases in the given order. For example, the output format must be exactly like:\n\"[[R\\_1,S\\_1],[R\\_2,S\\_2],[R\\_3,S\\_3],[R\\_4,S\\_4],[R\\_5,S\\_5]]\"",
            "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded in the principles of computer architecture and compiler design, is well-posed, objective, and contains all necessary information to derive a unique and meaningful solution. The problem describes a simplified but coherent model of a function calling sequence, suitable for formal analysis.\n\nThe solution proceeds by first principles, modeling the state of the stack pointer ($SP$) through the sequence of operations defined by the simplified Application Binary Interface (ABI). The stack is assumed to grow towards lower memory addresses, meaning that allocating space on the stack involves decrementing the $SP$ value.\n\nLet $SP_{caller}$ be the value of the caller's stack pointer before it prepares the arguments for the function call. We are given its congruence class modulo the alignment requirement $A$, denoted as $SP\\_0$.\n$$\nSP_{caller} \\equiv SP\\_0 \\pmod{A}\n$$\nThe evolution of the stack pointer is as follows:\n\n1.  **Argument Passing**: The caller function prepares the arguments. If the complex number argument is passed on the stack ($M=1$), the caller allocates $Z$ bytes for it, decrementing the stack pointer. If it is passed in registers ($M=0$), the stack pointer is unaffected by this argument. The change in $SP$ due to argument passing is $- M \\times Z$. The stack pointer becomes $SP_{pre-call}$.\n    $$\n    SP_{pre-call} = SP_{caller} - M \\times Z\n    $$\n\n2.  **`call` Instruction**: The processor's `call` instruction pushes the $8$-byte return address onto the stack before transferring control to the callee. This decrements the stack pointer by $8$. The stack pointer upon entry into the callee function is $SP_{entry}$.\n    $$\n    SP_{entry} = SP_{pre-call} - 8 = SP_{caller} - M \\times Z - 8\n    $$\n\n3.  **Callee Prologue**: Inside the callee, the function prologue saves $K$ callee-saved registers to the stack. Each `push` operation consumes $8$ bytes. This decrements the stack pointer by a total of $K \\times 8$ bytes. The stack pointer value immediately after the register-saving pushes, and just before any explicit alignment shim is applied, is denoted $SP_{prologue}$. This is the address at which vector loads are assumed to occur, and which therefore must be aligned.\n    $$\n    SP_{prologue} = SP_{entry} - K \\times 8 = SP_{caller} - M \\times Z - 8 - K \\times 8\n    $$\n    This can be expressed as:\n    $$\n    SP_{prologue} = SP_{caller} - (M \\times Z + 8 \\times (1 + K))\n    $$\n\nTo determine alignment, we analyze the congruence class of $SP_{prologue}$ modulo $A$. Let $\\Delta$ be the total decrement from $SP_{caller}$:\n$$\n\\Delta = M \\times Z + 8(1 + K)\n$$\nThen, the congruence class of $SP_{prologue}$ is:\n$$\nSP_{prologue} \\pmod{A} \\equiv (SP_{caller} - \\Delta) \\pmod{A}\n$$\nSubstituting the given initial condition $SP_{caller} \\equiv SP\\_0 \\pmod{A}$:\n$$\nSP_{prologue} \\pmod{A} \\equiv (SP\\_0 - \\Delta) \\pmod{A}\n$$\nLet $C$ be this final congruence class, where $C \\in [0, A-1]$.\n$$\nC = (SP\\_0 - \\Delta) \\pmod{A}\n$$\nFor computational implementation, care must be taken with the modulo operator on negative numbers. A robust calculation for $C$ is $C = (SP\\_0 - (\\Delta \\pmod{A}) + A) \\pmod{A}$.\n\nThe two required outputs are then determined from $C$:\n\n-   **Misalignment Risk ($R$)**: A misalignment occurs if $SP_{prologue}$ is not a multiple of $A$, which is true if and only if its congruence class $C$ is non-zero.\n    $$\n    R = \\begin{cases} 1 & \\text{if } C \\neq 0 \\\\ 0 & \\text{if } C = 0 \\end{cases}\n    $$\n\n-   **Minimal Alignment Shim ($S$)**: We need to find the smallest non-negative shim $S$, which must be a multiple of $8$, to subtract from $SP_{prologue}$ to achieve alignment. The new stack pointer $SP_{final} = SP_{prologue} - S$ must satisfy $SP_{final} \\equiv 0 \\pmod{A}$.\n    $$\n    (SP_{prologue} - S) \\pmod{A} = 0 \\implies (C - S) \\pmod{A} = 0 \\implies S \\equiv C \\pmod{A}\n    $$\n    The minimal non-negative solution is $S = C$. We must verify that this value of $S$ is a multiple of $8$. The problem states that $SP\\_0$, $Z$, and the size of a `push` operation ($8$ bytes) are all multiples of $8$. Therefore, the total decrement $\\Delta = M \\times Z + 8(1+K)$ is a sum of multiples of $8$, and is itself a multiple of $8$. The congruence class $C$ is calculated as $C \\equiv (SP\\_0 - \\Delta) \\pmod{A}$. Since $SP\\_0$ and $\\Delta$ are multiples of $8$, their difference $(SP\\_0 - \\Delta)$ is also a multiple of $8$. The value $C$ is $(SP\\_0 - \\Delta) - n \\cdot A$ for some integer $n$. The alignment requirement $A$ for all test cases ($16, 32$) is a multiple of $8$. Thus, $C$ must also be a multiple of $8$. The minimal non-negative shim $S$ is therefore simply $S=C$, which satisfies all constraints.\n\nWe now apply this methodology to each test case.\n\n**Test Case 1**: $SP\\_0 = 0, M = 0, Z = 16, K = 0, A = 16$.\n-   $\\Delta = (0 \\times 16) + 8 \\times (1 + 0) = 8$.\n-   $C = (0 - 8) \\pmod{16} = -8 \\pmod{16} = 8$.\n-   $R = 1$ because $C \\neq 0$.\n-   $S = C = 8$.\n-   Result: $[1, 8]$.\n\n**Test Case 2**: $SP\\_0 = 0, M = 1, Z = 16, K = 1, A = 16$.\n-   $\\Delta = (1 \\times 16) + 8 \\times (1 + 1) = 16 + 16 = 32$.\n-   $C = (0 - 32) \\pmod{16} = 0$.\n-   $R = 0$ because $C = 0$.\n-   $S = C = 0$.\n-   Result: $[0, 0]$.\n\n**Test Case 3**: $SP\\_0 = 8, M = 0, Z = 8, K = 0, A = 16$.\n-   $\\Delta = (0 \\times 8) + 8 \\times (1 + 0) = 8$.\n-   $C = (8 - 8) \\pmod{16} = 0$.\n-   $R = 0$ because $C = 0$.\n-   $S = C = 0$.\n-   Result: $[0, 0]$.\n\n**Test Case 4**: $SP\\_0 = 0, M = 1, Z = 16, K = 0, A = 32$.\n-   $\\Delta = (1 \\times 16) + 8 \\times (1 + 0) = 16 + 8 = 24$.\n-   $C = (0 - 24) \\pmod{32} = -24 \\pmod{32} = 8$.\n-   $R = 1$ because $C \\neq 0$.\n-   $S = C = 8$.\n-   Result: $[1, 8]$.\n\n**Test Case 5**: $SP\\_0 = 8, M = 0, Z = 8, K = 2, A = 32$.\n-   $\\Delta = (0 \\times 8) + 8 \\times (1 + 2) = 24$.\n-   $C = (8 - 24) \\pmod{32} = -16 \\pmod{32} = 16$.\n-   $R = 1$ because $C \\neq 0$.\n-   $S = C = 16$.\n-   Result: $[1, 16]$.\n\nThe collective results for the test suite are thus $[[1,8],[0,0],[0,0],[1,8],[1,16]]$.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int sp0; // Initial congruence class of caller's SP mod A\n    int m;   // Complex passing mode (0: registers, 1: stack)\n    int z;   // Size of complex argument in bytes\n    int k;   // Number of callee-saved registers pushed\n    int a;   // Alignment requirement in bytes\n} TestCase;\n\n// A struct to hold the calculated results for a single test case.\ntypedef struct {\n    int r; // Misalignment risk indicator (0 or 1)\n    int s; // Minimal alignment shim in bytes\n} Result;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {0, 0, 16, 0, 16}, // Test Case 1\n        {0, 1, 16, 1, 16}, // Test Case 2\n        {8, 0, 8,  0, 16}, // Test Case 3\n        {0, 1, 16, 0, 32}, // Test Case 4\n        {8, 0, 8,  2, 32}  // Test Case 5\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    Result results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // 1. Calculate the total stack pointer decrement (Delta).\n        // Delta = (stack-passed arg size) + (return address size) + (callee-saved registers size)\n        int delta = (tc.m * tc.z) + 8 * (1 + tc.k);\n\n        // 2. Calculate the final stack pointer congruence class (C) before any shim.\n        // C = (SP_0 - Delta) mod A\n        // The implementation (tc.sp0 - (delta % tc.a) + tc.a) % tc.a ensures\n        // a correct positive result for the modulo operation.\n        int c = (tc.sp0 - (delta % tc.a) + tc.a) % tc.a;\n\n        // 3. Determine misalignment risk (R).\n        // R is 1 if the final congruence C is not 0, otherwise 0.\n        results[i].r = (c == 0) ? 0 : 1;\n\n        // 4. Determine minimal alignment shim (S).\n        // The minimal non-negative shim S required to make the SP aligned is C itself.\n        // As derived in the analysis, C is guaranteed to be a multiple of 8.\n        results[i].s = c;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    // Format: \"[[R_1,S_1],[R_2,S_2],...,[R_N,S_N]]\"\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%d,%d]\", results[i].r, results[i].s);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}