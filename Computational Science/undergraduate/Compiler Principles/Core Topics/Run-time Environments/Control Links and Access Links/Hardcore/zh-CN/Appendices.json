{
    "hands_on_practices": [
        {
            "introduction": "这个练习提供了一个包含嵌套过程的具体场景。你的目标是通过应用基本寻址公式，找到正确的活动记录基地址来计算非局部变量的地址，这需要你理解如何利用访问链接来定位静态作用域链。这项实践将巩固你对静态作用域核心机制的理解。",
            "id": "3633091",
            "problem": "一种具有嵌套过程的静态作用域语言使用活动记录，其中包含控制链接（动态链接，DL）和访问链接（静态链接，SL）。控制链接（DL）指向调用者的活动记录以支持返回操作。访问链接（SL）指向词法外层过程的活动记录以支持非局部访问。每个活动记录都有一个基（帧）地址，在过程中声明的局部变量，其地址是该过程活动记录的基地址与编译时偏移量的和。假设访问链接（SL）字段始终包含词法外层活动记录的基地址，并且偏移量是相对于活动记录的基地址来度量的。\n\n考虑以下两种情景。在这两种情景中，全局过程 $G$ 词法上包含过程 $A$，而 $A$（在情景 1 中）词法上包含 $B$，$B$ 包含 $C$，$C$ 包含 $D$。过程 $D$ 引用了一个在 $A$ 中声明的非局部变量 $x$，该变量距离 $A$ 的活动记录基地址的编译时偏移量为 $+48$。\n\n情景 1（原始嵌套）：\n- 在 $D$ 中引用发生时，活跃的活动记录具有以下基地址和访问链接（SL）内容：\n  - $D$：基地址 = $8280$, $SL(D) = 8420$。\n  - $C$：基地址 = $8420$, $SL(C) = 8600$。\n  - $B$：基地址 = $8600$, $SL(B) = 8800$。\n  - $A$：基地址 = $8800$, $SL(A) = 9000$。\n  - $G$：基地址 = $9000$。\n\n情景 2（修改后的嵌套）：在 $A$ 和 $B$ 之间插入一个新的词法包装过程 $E$（使得 $G$ 包含 $A$，$A$ 包含 $E$，$E$ 包含 $B$，$B$ 包含 $C$，$C$ 包含 $D$）。在这次修改后的嵌套下的一次独立运行中，$D$ 中引用发生时，活跃的活动记录具有：\n- $D$：基地址 = $10840$, $SL(D) = 11000$。\n- $C$：基地址 = $11000$, $SL(C) = 11240$。\n- $B$：基地址 = $11240$, $SL(B) = 11520$。\n- $E$：基地址 = $11520$, $SL(E) = 11720$。\n- $A$：基地址 = $11720$, $SL(A) = 12000$。\n- $G$：基地址 = $12000$。\n\n仅使用上述关于控制链接（DL）、访问链接（SL）和活动记录寻址的基本事实，计算在情景 1 中从 $D$ 内部引用非局部变量 $x$ 时的地址，然后在情景 2 中重新计算该地址。报告定义为如下的单一标量 $\\Delta$：\n$$\n\\Delta \\;=\\; \\text{addr}_{2}(x) \\;-\\; \\text{addr}_{1}(x),\n$$\n其中 $\\text{addr}_{1}(x)$ 和 $\\text{addr}_{2}(x)$ 分别是 $x$ 在情景 1 和情景 2 中的地址。以精确整数形式给出 $\\Delta$ 的最终值。不要四舍五入。",
            "solution": "该问题要求计算在一个静态作用域语言中，涉及嵌套过程的两种情景下，非局部变量 $x$ 内存地址的差异。如问题所述，寻址的基本原则是，一个变量的地址是其所在过程的活动记录基地址与它在该记录中的编译时偏移量之和。\n\n所讨论的变量 $x$ 在过程 $A$ 中声明，其编译时偏移量为 $48$。设 $\\text{base_addr}(A)$ 为过程 $A$ 的活动记录的基地址，$\\text{offset}(x)$ 为 $x$ 的编译时偏移量。变量 $x$ 的内存地址，记为 $\\text{addr}(x)$，由以下公式给出：\n$$\n\\text{addr}(x) = \\text{base_addr}(A) + \\text{offset}(x)\n$$\n问题将访问链接（$SL$）描述为定位词法外层过程活动记录的机制。例如，当过程 $D$ 中的代码引用在 $A$ 中声明的变量 $x$ 时，运行时系统通常会从 $D$ 的活动记录开始，沿着访问链接链条进行查找，直到到达 $A$ 的活动记录。这个链条的长度取决于引用过程（$D$）和定义过程（$A$）之间的静态嵌套深度。然而，问题直接为两种情景提供了所有相关活动记录的基地址，这使得我们无需执行此遍历操作。我们可以直接使用给定的 $A$ 活动记录的基地址。\n\n在情景 1 中，词法嵌套为 $G \\supset A \\supset B \\supset C \\supset D$。问题提供了引用时刻的活跃活动记录数据。具体对于过程 $A$，它说明：\n- $A$：基地址 = $8800$。\n\n设 $\\text{addr}_1(x)$ 为 $x$ 在情景 1 中的地址。使用给定的基地址和 $x$ 的常量偏移量：\n$$\n\\text{addr}_1(x) = \\text{base_addr}_1(A) + \\text{offset}(x) = 8800 + 48 = 8848\n$$\n\n在情景 2 中，引入了一个新过程 $E$，将词法嵌套修改为 $G \\supset A \\supset E \\supset B \\supset C \\supset D$。问题为一次独立的运行提供了一组新的活动记录数据。对于过程 $A$，该数据为：\n- $A$：基地址 = $11720$。\n\n设 $\\text{addr}_2(x)$ 为 $x$ 在情景 2 中的地址。$x$ 在 $A$ 内的偏移量是一个编译时常量，保持不变。在这次运行中，$A$ 的活动记录的基地址是不同的。\n$$\n\\text{addr}_2(x) = \\text{base_addr}_2(A) + \\text{offset}(x) = 11720 + 48 = 11768\n$$\n问题要求计算数量 $\\Delta$，定义为这两个地址之间的差值：\n$$\n\\Delta = \\text{addr}_2(x) - \\text{addr}_1(x)\n$$\n代入计算出的值：\n$$\n\\Delta = 11768 - 8848\n$$\n执行减法运算：\n$$\n\\Delta = 2920\n$$\n关于控制链接（$DL$）、其他过程（$B$、$C$、$D$、$E$、$G$）的基地址以及访问链接（$SL$）字段内容的信息，尽管与所描述的静态作用域规则一致，但对计算而言最终是辅助性的，因为决定性的值——即每种情景下 $A$ 的活动记录的基地址——是直接给出的。",
            "answer": "$$\\boxed{2920}$$"
        },
        {
            "introduction": "在掌握了基本机制后，这个思想实验将挑战你预测一个关键实现错误的后果：交换控制链接和访问链接。通过分析这个故障如何影响变量访问和函数返回，你将更深刻地体会到这两种链接在管理运行时环境中所扮演的独特且不可互换的角色。",
            "id": "3633102",
            "problem": "一个用于静态作用域、块结构语言（类似于 Pascal 的嵌套过程）的编译器，其目标是一个简单的运行时系统，该系统具有以下活动记录（AR）约定。位于帧指针 $FP$ 处的被调用者的 AR 包含两个过程间链接：\n- 位于内存地址 $[FP - 2]$ 的控制链（也称为动态链），它必须指向调用者的帧指针，以便函数尾声可以恢复调用者的环境。\n- 位于内存地址 $[FP - 1]$ 的访问链（也称为静态链），它必须指向词法外层过程的帧，以支持静态作用域下的非局部变量访问。\n\n假设以下经过充分测试的事实：\n- 从静态嵌套深度为 $d$ 的过程中，对向外 $\\Delta d$ 层声明的变量进行静态作用域非局部变量访问，其实现方式是沿着访问链追溯 $\\Delta d$ 次以到达定义帧，然后使用该帧内的已知偏移量。\n- 函数尾声通过首先设置 `FP := mem[FP - 2]`，然后跳转到存储在调用者 AR 中固定偏移量 $k$ 处的返回地址来恢复控制权，也就是说，它在恢复 $FP$ 后执行跳转到 `mem[FP + k]` 的操作。\n- 返回地址本身不存储在被调用者的 AR 中；它存储在调用者的 AR 中，距离调用者的 $FP$ 有一个偏移量 $k$。\n\n你的任务是设计一个故障注入测试，在每次调用时，有意地交换写入被调用者 AR 的控制链和访问链字段的值（也就是说，它将词法父过程的帧指针写入 $[FP - 2]$，并将调用者的帧指针写入 $[FP - 1]$）。你必须预测将导致何种类型的错误行为以及如何检测每种行为。\n\n考虑两类测试程序：\n- $\\mathcal{V}$ 类（变量绑定测试）：一个包含三个嵌套过程 $P$、$Q$ 和 $R$ 的程序，其中 $Q$ 嵌套在 $P$ 中，$R$ 也嵌套在 $P$ 中（因此 $Q$ 和 $R$ 是兄弟关系），并且 $Q$ 调用 $R$。假设 $P$ 声明一个变量 $x$ 并初始化为 $x = 1$，$Q$ 声明一个局部变量 $x = 2$（遮蔽了 $P$ 的 $x$），$R$ 读取在静态作用域下可见的非局部变量 $x$ 并将其返回给 $Q$，然后 $Q$ 将其打印出来。\n- $\\mathcal{C}$ 类（控制转移测试）：一个程序，其中 $P$ 调用 $Q$，$Q$ 调用 $R$。在调用 $R$ 之后，$Q$ 立即执行一个独特的副作用（例如，打印整数 $1$），而在 $Q$ 返回后，$P$ 执行另一个不同的独特副作用（例如，打印整数 $2$）。此程序中没有非局部变量访问。\n\n选择所有正确描述在注入故障下预期错误行为以及针对每类测试的可靠检测方法的陈述。\n\nA. 在 $\\mathcal{V}$ 类中，$R$ 在解析非局部变量 $x$ 时将遵循错误的链接链，实际上表现得好像该语言使用动态作用域。观察到的打印输出将是 $2$，而不是静态正确的 $1$。一种可靠的检测方法是使用所描述的有意遮蔽，并将观察到的值与静态作用域的期望值进行比较。\n\nB. 交换控制链和访问链仅在调用者同时也是词法父过程时才影响返回；否则，它是无害的。因此，如果 $Q$ 和 $R$ 是嵌套在 $P$ 中的兄弟过程，$\\mathcal{C}$ 类不会检测到错误。\n\nC. 在 $\\mathcal{V}$ 类中，$R$ 中的第一次非局部访问几乎肯定会立即崩溃，因为错误的链接链将指向已释放的内存。因此，主要预期的症状是空指针解引用或段错误，而不是错误的值。\n\nD. 在 $\\mathcal{C}$ 类中，当 $Q$ 调用 $R$ 时，$R$ 的尾声将从错误的链接中恢复 $FP$，然后从错误的调用者 AR（词法父过程的帧）中获取返回地址。控制将恢复到 $P$ 的续体，而不是 $Q$ 的调用后位置，因此 $Q$ 中紧随调用 $R$ 之后的副作用将被跳过，只有 $P$ 的副作用会被观察到。一种可靠的检测方法是在两个调用后位置都放置独特的副作用，并检查哪些副作用发生以及它们的顺序。\n\nE. 通用的栈金丝雀和地址空间布局随机化（ASLR）足以专门检测控制链和访问链的交换；因此，$\\mathcal{V}$ 类和 $\\mathcal{C}$ 类对于高置信度地揭示此故障都不是必需的。\n\n选择所有适用项。",
            "solution": "问题的核心在于过程的调用者与其词法父过程之间的区别。注入的故障仅当这两者不同时才可观察到，即 $FP_{caller} \\neq FP_{lexical\\_parent}$。在这种情况下，控制链和访问链通常会指向不同的帧；而该故障交换了这两个指针。\n\n**正确行为（无故障）：**\n*   `mem[$FP_{callee}$ - 2]` (控制链) $= FP_{caller}$\n*   `mem[$FP_{callee}$ - 1]` (访问链) $= FP_{lexical\\_parent}$\n\n**故障行为（交换）：**\n*   `mem[$FP_{callee}$ - 2]` (控制链) $= FP_{lexical\\_parent}$\n*   `mem[$FP_{callee}$ - 1]` (访问链) $= FP_{caller}$\n\n让我们分析对每类测试程序的影响。对于这两种分析，我们都考虑暴露故障的关键调用。在 $Q$ 和 $R$ 是嵌套在 $P$ 中的兄弟过程，且 $Q$ 调用 $R$ 的结构中，我们有：\n*   $R$ 的调用者是 $Q$。因此，$FP_{caller} = FP_Q$。\n*   $R$ 的词法父过程是 $P$。因此，$FP_{lexical\\_parent} = FP_P$。\n由于 $P$ 和 $Q$ 是不同的过程，因此 $FP_P \\neq FP_Q$。\n\n**$\\mathcal{V}$ 类（变量绑定测试）分析**\n\n1.  **正确行为：** 在过程 $R$ 中，必须解析对非局部变量 $x$ 的引用。根据静态作用域规则，$R$ 应该找到在其词法外层作用域 $P$ 中声明的 $x$。$P.x$ 的值是 $1$。为此，生成的代码会从 $R$ 的帧开始沿着访问链，该链正确地指向 $P$ 的帧（$FP_P$）。获取到值 $1$。$R$ 返回 $1$，$Q$ 打印 $1$。\n2.  **故障行为：** $R$ 的 AR 中的 `access link` 字段被篡改；它现在指向调用者的帧指针 $FP_Q$。当 $R$ 试图访问非局部变量 $x$ 时，它会沿着这个错误的访问链到达 $Q$ 的活动记录。运行时系统在 $Q$ 的帧中搜索 $x$。过程 $Q$ 有一个局部变量 `x`，其值为 $2$。这就是将被找到和访问的变量。这种通过向上搜索动态调用链（调用者、调用者的调用者等）来解析非局部引用的机制，正是**动态作用域**的定义。\n3.  **结果：** $R$ 将访问 $Q.x$ 并检索到值 $2$。它将 $2$ 返回给 $Q$，$Q$ 随后打印 $2$。预期的输出是 $1$。这种差异揭示了故障。\n\n**$\\mathcal{C}$ 类（控制转移测试）分析**\n\n1.  **正确行为：** 调用序列是 $P \\to Q \\to R$。$R$ 执行然后返回。$R$ 的 AR 中的控制链指向其调用者 $Q$。$R$ 的尾声将 $FP$ 恢复为 $FP_Q$，并跳转到存储在 $Q$ 帧中的返回地址。执行在 $Q$ 中紧随调用 $R$ 之后继续。$Q$ 打印 $1$。然后 $Q$ 完成并返回到 $P$。$P$ 打印 $2$。观察到的输出是 $1$ 后跟 $2$。\n2.  **故障行为：** $R$ 的 AR 中的 `control link` 字段被篡改；它现在指向词法父过程的帧指针 $FP_P$。当 $R$ 执行其尾声时：\n    a. 它恢复帧指针：`FP := mem[FP_R - 2]`，该值已被设置为 $FP_P$。运行时现在表现得好像控制权要返回到 $P$ 的帧。\n    b. 它跳转到返回地址：`jump to mem[FP + k]`，现在是 `jump to mem[FP_P + k]`。\n    c. 根据问题的规则，调用的返回地址存储在调用者的 AR 中。调用 $P \\to Q$ 将其返回地址（$P$ 内部的一个地址）存储在 `mem[FP_P + k]` 处。\n    d. 因此，从 $R$ 的错误返回实际上将控制权返回到 $P$ 中紧随调用 $Q$ 之后的位置。\n3.  **结果：** 过程 $Q$ 的其余部分，包括 `print(1)` 副作用，被跳过。执行在 $P$ 中恢复，$P$ 接着执行自己的副作用 `print(2)`。唯一观察到的输出是 $2$。预期的输出是 $1$ 然后是 $2$。\n\n### 逐项分析选项\n\n*   **A. 在 $\\mathcal{V}$ 类中，$R$ 在解析非局部变量 $x$ 时将遵循错误的链接链，实际上表现得好像该语言使用动态作用域。观察到的打印输出将是 $2$，而不是静态正确的 $1$。一种可靠的检测方法是使用所描述的有意遮蔽，并将观察到的值与静态作用域的期望值进行比较。**\n    *   该陈述与对 $\\mathcal{V}$ 类的分析完全匹配。被交换的访问链指向调用者的帧，导致解析遵循动态链。这导致访问 $Q.x$（值为 $2$）而不是 $P.x$（值为 $1$）。检测方法是可靠的。\n    *   **结论：正确。**\n\n*   **B. 交换控制链和访问链仅在调用者同时也是词法父过程时才影响返回；否则，它是无害的。因此，如果 $Q$ 和 $R$ 是嵌套在 $P$ 中的兄弟过程，$\\mathcal{C}$ 类不会检测到错误。**\n    *   该陈述在逻辑上是有缺陷的。交换操作恰恰在调用者*是*词法父过程时是无害的（空操作），因为那时 $FP_{caller} = FP_{lexical\\_parent}$。只有当它们不同时，交换才有影响。$Q$ 和 $R$ 是兄弟过程且 $Q$ 调用 $R$ 的情况，正是调用者（$Q$）*不是*词法父过程（$P$）的典型例子，因此故障会被暴露。\n    *   **结论：不正确。**\n\n*   **C. 在 $\\mathcal{V}$ 类中，$R$ 中的第一次非局部访问几乎肯定会立即崩溃，因为错误的链接链将指向已释放的内存。因此，主要预期的症状是空指针解引用或段错误，而不是错误的值。**\n    *   这是不正确的。错误的访问链指向 $R$ 的调用者 $Q$ 的帧指针 $FP_Q$。当 $R$ 正在执行时，其调用者 $Q$ 必须仍然是活动的。它的活动记录在栈上并且是有效的、已分配的内存。访问将被引导到一个有效的帧中。虽然任意的偏移量可能导致访问冲突，但该问题通过有意的遮蔽来构造，使得访问更有可能解析到遮蔽变量（$Q.x$），从而导致错误的值，而不是崩溃。\n    *   **结论：不正确。**\n\n*   **D. 在 $\\mathcal{C}$ 类中，当 $Q$ 调用 $R$ 时，$R$ 的尾声将从错误的链接中恢复 $FP$，然后从错误的调用者 AR（词法父过程的帧）中获取返回地址。控制将恢复到 $P$ 的续体，而不是 $Q$ 的调用后位置，因此 $Q$ 中紧随调用 $R$ 之后的副作用将被跳过，只有 $P$ 的副作用会被观察到。一种可靠的检测方法是在两个调用后位置都放置独特的副作用，并检查哪些副作用发生以及它们的顺序。**\n    *   该陈述准确地描述了故障对 $\\mathcal{C}$ 类的影响。错误的控制链导致了一次“长返回”，返回到 $R$ 的词法祖父过程（$P$）而不是其直接父过程（$Q$），从而绕过了 $Q$ 中的调用后代码。检测方法是可靠的。\n    *   **结论：正确。**\n\n*   **E. 通用的栈金丝雀和地址空间布局随机化（ASLR）足以专门检测控制链和访问链的交换；因此，$\\mathcal{V}$ 类和 $\\mathcal{C}$ 类对于高置信度地揭示此故障都不是必需的。**\n    *   这是不正确的。栈金丝雀检测破坏栈的缓冲区溢出，而 ASLR 通过随机化内存位置使利用内存损坏变得更加困难。这里讨论的故障是编译器代码生成中的一个逻辑错误：它将格式正确但不正确的指针写入其指定的槽位。它没有溢出任何缓冲区，也不依赖于固定地址。这些安全机制并非为检测此类逻辑错误而设计。像 $\\mathcal{V}$ 类和 $\\mathcal{C}$ 类这样的特定语义测试是必需的。\n    *   **结论：不正确。**",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "最后的这项实践是一个综合性练习，你需要编写一个程序来模拟整个运行时系统。你将为一个涉及嵌套调用和非局部访问的复杂场景，显式地创建活动记录、管理调用栈，并正确设置控制链接和访问链接。这将整合所有相关概念，并检验你从第一性原理出发实现这些机制的能力。",
            "id": "3633059",
            "problem": "你需要构建一个小的、自包含的正确性测试程序，该程序模拟编译器运行时系统如何为词法嵌套函数维护活动记录、控制链接和访问链接。目标是从原理出发，生成一个可执行的产物，以展示动态链接和访问链接之间的相互作用。\n\n基本原理：\n- 术语“活动记录”（Activation Record, AR）表示为每次函数激活创建的运行时数据结构；它包含簿记信息，如返回地址、局部变量、动态链接和访问链接。\n- 动态链接是指从当前活动记录指向其调用者活动记录的指针，表示按实际执行顺序排列的调用链（动态链）。\n- 访问链接，也称为静态链接，是指从当前活动记录指向其词法外层函数活动记录的指针，表示词法嵌套结构（静态链）。\n- 在词法作用域语言中，变量解析沿着静态链进行：要访问在祖先词法层级定义的非局部变量，需沿着访问链接跳转所需次数，直到到达相应的活动记录。\n\n问题场景：\n- 考虑一个由三个词法嵌套函数组成的结构，其层级分别表示为：最外层的 root 函数为 $L=0$，其内嵌的 outer 函数为 $L=1$，而在 outer 函数内嵌套的 inner 函数为 $L=2$。假设层级 $L=0$ 的 root 函数有一个局部变量 $A$，层级 $L=1$ 的 outer 函数有一个局部变量 $B$，层级 $L=2$ 的 inner 函数有一个局部变量 $C$。\n- outer 函数的值定义为 root 函数的 $A$ 与 outer 函数的 $B$ 之和。由于 $A$ 定义在词法层级 $L=0$，outer 函数必须通过其访问链接找到 root 函数的活动记录，并从中读取 $A$。\n- inner 函数必须执行两个操作：\n  1. 它必须在 outer 函数已经处于活动状态时调用 outer 函数。这次调用需要为被调用者提供正确的动态链接以供返回，以及正确的访问链接，以确保 outer 函数在被重入时仍然能引用到正确的 root 函数的 $A$。这体现了根据词法层级计算并传递被调用者访问链接的必要性。\n  2. 它必须通过两次跟随自己的访问链接（从层级 $L=2$ 到 $L=1$，再从 $L=1$ 到 $L=0$）来引用 root 函数的 $A$，从而读取其外层函数的外层变量。\n- inner 函数的结果是它调用的 outer 函数的当前值、通过两次访问链接跳转获得的 root 函数的 $A$、以及它自己的局部变量 $C$ 的总和。这强制要求同时使用动态链接（用于 inner 和 outer 之间的调用/返回）和访问链接（用于遍历 $L=2 \\rightarrow L=1 \\rightarrow L=0$）。\n\n实现要求：\n- 编写一个完整的程序，构建包含词法层级、动态链接、访问链接和局部变量字段的显式活动记录。程序应实现函数调用，并根据词法嵌套规则从调用者的访问链计算被调用者的访问链接：被调用者的访问链接必须指向其词法外层函数的活动记录，该记录通过沿调用者的访问链向上查找直到找到相应层级来确定。\n- 对于每个测试用例，程序必须模拟一次顶层运行，过程如下：创建包含局部变量 $A$ 的 root 活动记录，然后调用包含局部变量 $B$ 的 outer 函数，outer 函数再调用包含局部变量 $C$ 的 inner 函数。inner 函数必须既调用 outer 函数，又通过两次访问链接跳转来访问 $A$。\n- 你的程序应为每个测试用例生成一个数值结果，该结果等于上面定义的 inner 函数的返回值。不允许外部输入；请将测试用例嵌入代码中。\n\n测试套件：\n- 使用以下四个测试用例，每个测试用例是一个三元组 $(A,B,C)$：\n  - $(3,4,5)$\n  - $(0,0,0)$\n  - $(-2,5,1)$\n  - $(1000000000,1,2)$\n这些用例涵盖了一般情况、零边界情况、正负值混合情况以及一个保持在安全整数范围内的大数值情况。\n\n答案格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是按上述顺序列出的第 $i$ 个测试用例计算出的整数。不得有任何其他输出。\n\n角度单位和物理单位在此不适用。\n\n约束与现实性：\n- 你必须遵守词法作用域下关于活动记录、动态链接和访问链接的定义。被调用者的访问链接必须根据其词法层级的词法父级，从调用者当前的访问链中推导出来；不允许使用快捷方式或直接共享调用者的局部变量。\n- 你的实现必须在逻辑上保持一致，在编译器原理范畴内科学合理，并且必须显式创建和链接活动记录，以反映动态链和静态链。",
            "solution": "首先，我们定义活动记录的结构 `ActivationRecord`。此结构是我们模拟的基本单元。\n- `struct ActivationRecord* dynamic_link`：指向调用函数 AR 的指针。此链接链代表程序的动态执行路径。\n- `struct ActivationRecord* access_link`：指向词法上包围当前函数的函数的 AR 的指针。此链接链代表源代码的静态（或词法）嵌套结构。\n- `int lexical_level`：一个整数，表示函数的嵌套深度，全局（root）作用域从 $L=0$ 开始。\n- `long long local_variable`：用于存储函数局部变量的空间。我们使用 `long long` 以适应测试套件中的大数值。\n\n模拟过程通过执行指定的调用链进行：顶层环境调用 `root`（层级 $L=0$），`root` 调用 `outer`（层级 $L=1$），`outer` 再调用 `inner`（层级 $L=2$）。\n\n1.  **调用 `root(A)`**：为 `root` 创建一个 AR。其词法层级设置为 $L=0$。它的 `dynamic_link` 和 `access_link` 均为 `NULL`，因为在我们的模拟范围内，它是最外层的函数，没有调用者或词法父级。其局部变量 $A$ 被存储起来。\n\n2.  **从 `root` 调用 `outer(B)`**：为 `outer` 的首次激活创建一个新的 AR。其词法层级为 $L=1$。`dynamic_link` 设置为指向调用者 `root` 的 AR。`access_link` 必须指向 `outer` 的词法父级，即 `root`（在层级 $L=0$）的 AR。调用者（`root`，层级 $L=0$）可以在其自身上下文中找到被调用者父级（层级 $L=1-1=0$）的 AR；这正是它自己的 AR。\n\n3.  **从 `outer` 调用 `inner(C)`**：为 `inner` 创建一个新的 AR。其词法层级为 $L=2$。`dynamic_link` 指向其调用者 `outer` 的 AR。`access_link` 指向 `inner` 的词法父级，即 `outer`（在层级 $L=1$）。调用者（`outer`，层级 $L=1$）提供自己的 AR作为被调用者的访问链接。\n\n问题的核心在于 `inner` 函数上下文中执行的逻辑。\n\n**操作 1：`inner` 调用 `outer`**\n`inner` 函数（在层级 $L=2$）调用 `outer` 函数（在层级 $L=1$）。这为 `outer` 创建了第二个不同的活动记录。\n- 这个新的 `outer` AR 的 `dynamic_link` 指向其调用者 `inner` 的 AR。\n- 必须计算 `access_link`。被调用者 (`outer`) 定义在层级 $L=1$，因此其词法父级在层级 $L=1-1=0$。调用者（`inner`，在层级 $L=2$）必须通过遍历自己的访问链接链来找到层级 $L=0$ 的最新 AR。所需的跳转次数是调用者层级与被调用者父级层级之间的差值：$L_{\\text{caller}} - (L_{\\text{callee}} - 1) = 2 - (1 - 1) = 2$。然而，一个更通用的算法指出，处于层级 $L_c$ 的调用者必须遍历 $L_c - L_p$ 个链接，其中 $L_p$ 是被调用者父级的层级。在这里，即为 $2 - 0 = 2$ 次跳转。从 `inner` 的 AR 沿着链条（`inner_AR` $\\rightarrow$ `outer_AR_1` $\\rightarrow$ `root_AR`）走两步，可以正确地找到 `root` 的 AR。这成为新的 `outer` AR 的 `access_link`。\n- 这次 `outer` 调用的返回值定义为其局部变量 $B$ 与其词法父级的 $A$ 之和。该函数通过其新建立的 `access_link` 向前一步到达 `root` AR 来找到 $A$。因此，这次调用的结果是 $A+B$。\n\n**操作 2：`inner` 访问 `root` 的变量 $A$**\n`inner` 函数需要访问变量 $A$，该变量定义在 `root` 的作用域（层级 $L=0$）中。\n- 变量解析沿着静态（访问）链向上进行。从 `inner` 在层级 $L=2$ 的 AR 开始，我们必须找到层级 $L=0$ 的 AR。这需要遍历 $L_{\\text{inner}} - L_{\\text{root}} = 2 - 0 = 2$ 个访问链接。路径同样是 `inner_AR` $\\rightarrow$ `outer_AR_1` $\\rightarrow$ `root_AR`。从这个 AR 中读取 $A$ 的值。\n\n**最终计算**\n`inner` 函数的最终结果是指定三个部分的总和：\n1.  调用 `outer` 函数的结果：$(A+B)$。\n2.  通过遍历两个访问链接获得的 `root` 的 $A$ 值：$A$。\n3.  它自己的局部变量：$C$。\n因此，总结果为 $(A+B) + A + C = 2A + B + C$。",
            "answer": "[15,0,2,2000000003]"
        }
    ]
}