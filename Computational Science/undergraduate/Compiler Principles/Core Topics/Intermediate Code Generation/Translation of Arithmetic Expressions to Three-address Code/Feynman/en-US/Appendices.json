{
    "hands_on_practices": [
        {
            "introduction": "Translating an arithmetic expression into three-address code often presents opportunities for optimization. In this first exercise , we explore how a seemingly complex expression can be simplified using basic algebraic identities. This practice highlights the crucial compiler design principle of semantics-preserving transformation, forcing us to consider how an optimization can change a program's behavior if not applied carefully, especially concerning undefined operations like division by zero.",
            "id": "3676892",
            "problem": "A compiler intermediate representation uses Three-Address Code (TAC), where each instruction has at most one operator and up to three operands, and temporaries are introduced to break complex expressions into single-operation steps. Consider the source-level arithmetic assignment $$y := \\frac{a^{2} - b^{2}}{a - b},$$ where $a$, $b$, and $y$ are variables ranging over the real numbers and the division operator is undefined when the denominator equals zero.\n\nYour tasks are:\n- Translate the assignment into a sequence of TAC instructions that compute the value of $y$ without performing any algebraic simplification.\n- Then, using only algebraic laws valid over the real numbers and semantics-preserving transformations, derive an optimized TAC sequence that reduces the number of operations, provided the optimization guards against division-by-zero at runtime.\n- Finally, under the explicit precondition that $a - b \\neq 0$, state the simplified, closed-form analytic expression for $y$ that the optimized TAC computes.\n\nProvide the final simplified expression for $y$ only. No numerical evaluation is required.",
            "solution": "The problem is subjected to validation.\n\n**Step 1: Extract Givens**\n- The source-level arithmetic assignment is $$y := \\frac{a^{2} - b^{2}}{a - b}$$.\n- The variables $a$, $b$, and $y$ are defined as ranging over the real numbers.\n- A constraint is given: the division operator is undefined when the denominator equals zero.\n- Task 1: Translate the assignment into a sequence of Three-Address Code (TAC) instructions without any algebraic simplification.\n- Task 2: Derive an optimized TAC sequence using algebraic laws and semantics-preserving transformations, which must include a guard against division-by-zero at runtime.\n- Task 3: State the simplified, closed-form analytic expression for $y$ under the explicit precondition that $a - b \\neq 0$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically and mathematically sound. It is a well-posed problem from the field of computer science, specifically compiler design and optimization. The algebraic principles involved (the difference of squares) are fundamental theorems of algebra. The problem distinguishes between the general case where division by zero must be handled and a special case where a precondition ($a - b \\neq 0$) makes the denominator non-zero, which is a crucial and well-defined distinction. The tasks are clearly specified, and the problem contains all necessary information to proceed. The problem does not violate any of the invalidity criteria.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Solution Derivation**\n\nThe problem requires a three-part analysis of the assignment $y := \\frac{a^{2} - b^{2}}{a - b}$.\n\n**Part 1: Unoptimized Three-Address Code (TAC) Translation**\n\nA direct translation of the expression into Three-Address Code involves breaking down the computation into a sequence of instructions, each having at most one operator. We introduce temporary variables (e.g., $t_1, t_2, \\dots$) to hold intermediate results. The order of operations follows standard mathematical precedence: exponentiation, then subtraction, and finally division.\n\n1.  Compute $a^2$: Let $t_1 = a * a$.\n2.  Compute $b^2$: Let $t_2 = b * b$.\n3.  Compute the numerator $a^2 - b^2$: Let $t_3 = t_1 - t_2$.\n4.  Compute the denominator $a - b$: Let $t_4 = a - b$.\n5.  Perform the division: Let $t_5 = t_3 / t_4$.\n6.  Assign the result to $y$: Let $y = t_5$.\n\nThe resulting TAC sequence is:\n```\nt_1 := a * a\nt_2 := b * b\nt_3 := t_1 - t_2\nt_4 := a - b\nt_5 := t_3 / t_4\ny := t_5\n```\n\nThis sequence involves a total of $5$ arithmetic operations: two multiplications, two subtractions, and one division.\n\n**Part 2: Optimized Three-Address Code (TAC) Translation**\n\nThe optimization relies on the algebraic identity for the difference of squares: $a^2 - b^2 = (a - b)(a + b)$. Substituting this into the original expression gives:\n$$y = \\frac{(a - b)(a + b)}{a - b}$$\nAlgebraically, one can cancel the $(a - b)$ term from the numerator and denominator, which simplifies the expression to $y = a + b$. However, this cancellation is only valid if $a - b \\neq 0$. If $a - b = 0$, the original expression is undefined (due to division by zero), whereas the simplified expression $y = a + b = 2a$ would produce a value.\n\nA semantics-preserving transformation must therefore retain the behavior of the original expression with respect to the domain of definition. The optimized code must still guard against the division-by-zero condition. The optimization lies in restructuring the computation to be more efficient in the common case where $a - b \\neq 0$. Instead of computing the full numerator and denominator, we first check the condition $a - b = 0$.\n\nThe optimized logic is as follows:\n1.  Compute the value of the denominator, $a-b$.\n2.  Check if this value is zero.\n3.  If it is zero, a runtime error (division by zero) occurs.\n4.  If it is non-zero, compute the result using the simplified expression $a+b$.\n\nThe optimized TAC sequence, including the explicit guard, can be written using a conditional jump:\n```\nt_1 := a - b\nif t_1 == 0 goto L_error\nt_2 := a + b\ny := t_2\ngoto L_end\nL_error: (code to handle division-by-zero exception)\nL_end: (end of this code segment)\n```\n\nThe TAC for the valid computation path is:\n```\nt_1 := a - b\nif t_1 == 0 goto L_error\nt_2 := a + b\ny := t_2\n```\n\nIn the case where $a \\neq b$, this sequence requires only $2$ arithmetic operations (one subtraction, one addition), which is a significant reduction from the $5$ operations in the unoptimized version. The optimization correctly preserves the semantics by checking the condition that would lead to division by zero *before* performing an invalid algebraic cancellation.\n\n**Part 3: Simplified Analytic Expression with Precondition**\n\nThe final part of the problem asks for the simplified, closed-form analytic expression for $y$ under the explicit precondition that $a - b \\neq 0$.\n\nGiven the expression:\n$$y := \\frac{a^{2} - b^{2}}{a - b}$$\nWe use the difference of squares identity, $a^2 - b^2 = (a - b)(a + b)$:\n$$y = \\frac{(a - b)(a + b)}{a - b}$$\nThe precondition $a - b \\neq 0$ explicitly states that the denominator is non-zero. This makes the division operation well-defined and allows for the cancellation of the $(a - b)$ term from the numerator and the denominator.\n$$y = a + b$$\nThis is the final simplified expression that the optimized TAC computes in the non-error path.",
            "answer": "$$\n\\boxed{a + b}\n$$"
        },
        {
            "introduction": "Beyond algebraic rules, a compiler must faithfully adhere to the specific semantics of the source language. This exercise  shifts our focus to the practical details of code generation for integer arithmetic, including its specific division rules and the necessity of explicit runtime error checks. By working through this problem, you will gain insight into how abstract expressions are translated into robust code that handles real-world computational constraints.",
            "id": "3676915",
            "problem": "A statically typed imperative language uses three-address code (TAC) as its intermediate representation, where each instruction computes at most one operator and references at most three addresses. In this language, variables $x$, $y$, and $p$ are all 32-bit signed integers, the division operator on integers truncates toward zero, and division by zero signals a runtime error. Consider the source-level assignment $p = (x - y)/(x + y)$.\n\nStarting from the principles that (i) an arithmetic expression can be represented as an abstract syntax tree whose internal nodes are operators and whose leaves are operands, and (ii) TAC evaluates each internal node into a temporary before its parent can use that value, derive a TAC sequence that uses one temporary for the numerator and one temporary for the denominator, performs an explicit runtime check for division by zero before the division, and then assigns the quotient to $p$. Assume the right-hand side is evaluated left-to-right and that there are no side effects in evaluating $x$ and $y$.\n\nDiscuss the integer-division edge cases that arise from truncation toward zero and from division by zero, and compare how the result would differ if integer division were defined as the floor function applied to the real quotient. Then, taking the specific input values $x = 3$ and $y = 7$, compute the resulting value that will be stored in $p$ under the given truncation-toward-zero semantics. Report only that final numeric value of $p$ as your answer.",
            "solution": "The problem statement is a valid exercise in compiler principles, specifically concerning the translation of arithmetic expressions into three-address code (TAC), the handling of integer arithmetic semantics, and runtime error checking. The premises are scientifically grounded in computer science, and the problem is well-posed, objective, and self-contained. All variables, conditions, and required outputs are clearly defined.\n\nThe problem asks for a derivation of a TAC sequence for the assignment $p := (x - y)/(x + y)$, a discussion of integer division edge cases, and a final calculation for specific values of $x$ and $y$.\n\nFirst, we address the translation to three-address code. The process starts from the principles laid out in the problem statement.\n\n(i) An arithmetic expression can be represented as an abstract syntax tree (AST). For the right-hand side of the assignment, $(x - y)/(x + y)$, the AST has the division operator `/` at its root. The left child is the subtree for the numerator, $(x - y)$, and the right child is the subtree for the denominator, $(x + y)$. The AST can be represented textually as `div(sub(x, y), add(x, y))`.\n\n(ii) TAC evaluates each internal node into a temporary variable. A post-order traversal of the expression's AST is typically used to generate the code. The problem specifies left-to-right evaluation for the right-hand side, which means for the operator `/`, its left operand $(x-y)$ is evaluated before its right operand $(x+y)$. This corresponds to visiting the left subtree of the `/` node before the right one.\n\nFollowing these principles and the problem's constraints, we derive the TAC sequence.\n1.  Evaluate the numerator $(x - y)$ and store it in a temporary variable, `t_1`. This corresponds to the `sub(x, y)` node.\n    `t_1 := x - y`\n2.  Evaluate the denominator $(x + y)$ and store it in a second temporary variable, `t_2`. This corresponds to the `add(x, y)` node.\n    `t_2 := x + y`\n3.  Perform an explicit runtime check for division by zero. The denominator is now in `t_2`. If `t_2` is equal to $0$, control must be transferred to an error-handling routine. We use a conditional jump to a label, say `L_error`.\n    `if t_2 == 0 goto L_error`\n4.  If the check passes (i.e., `t_2` $\\neq 0$), the division is performed. A strict three-address code instruction contains at most one operator. Therefore, we compute the quotient and store it in a new temporary, `t_3`.\n    `t_3 := t_1 / t_2`\n5.  Finally, the result is assigned to the variable `p`. This is a copy instruction.\n    `p := t_3`\n6.  To ensure proper control flow, an unconditional jump is added to bypass the error-handling code.\n    `goto L_end`\n\nThe complete TAC sequence, including the labels for control flow, is as follows:\n```\nt_1 := x - y\nt_2 := x + y\nif t_2 == 0 goto L_error\nt_3 := t_1 / t_2\np := t_3\ngoto L_end\nL_error: signal_error()\nL_end:\n```\nThis sequence adheres to all specified constraints: it uses one temporary for the numerator (`t_1`), one for the denominator (`t_2`), performs the explicit check before division, and correctly assigns the final result.\n\nNext, we discuss the integer-division edge cases.\nThe first edge case is **division by zero**. This occurs when the denominator $(x + y)$ is $0$, which means $y = -x$. The provided TAC explicitly checks for this condition with `if t_2 == 0 goto L_error`. This prevents the hardware from executing an illegal operation and instead transfers control to a routine that signals a runtime error, as required by the language specification.\n\nThe second edge case involves the semantics of integer division for negative results. The problem specifies that division **truncates toward zero**. Let $a$ and $b$ be two integers, with $b \\neq 0$. The real quotient is $q_{real} = a/b$. Truncation toward zero means the result of the integer division is $\\text{trunc}(q_{real})$, which is obtained by discarding the fractional part of $q_{real}$.\n- If $q_{real} \\ge 0$, $\\text{trunc}(q_{real}) = \\lfloor q_{real} \\rfloor$. For example, $7/2 = 3.5 \\implies 3$.\n- If $q_{real} < 0$, $\\text{trunc}(q_{real}) = \\lceil q_{real} \\rceil$. For example, $-7/2 = -3.5 \\implies -3$.\nThis behavior is standard in languages like C, C++, and Java.\n\nThe problem asks for a comparison with integer division defined as the **floor function** applied to the real quotient, i.e., $\\lfloor q_{real} \\rfloor$.\n- If $q_{real} \\ge 0$, the floor function gives the same result as truncation.\n- If $q_{real} < 0$ and $q_{real}$ is not an integer, the floor function gives a different result. $\\lfloor q_{real} \\rfloor$ rounds down to the nearest integer (more negative), while truncation rounds toward zero (less negative). For example, for a real quotient of $-3.5$, floor division yields $-4$, whereas truncation yields $-3$. Floor division is the standard in Python. The key difference arises only for negative non-integer quotients.\n\nFinally, we compute the value of $p$ for the specific inputs $x = 3$ and $y = 7$. The variables are 32-bit signed integers.\nThe expression is $p = (x - y)/(x + y)$.\n1.  Calculate the numerator: $x - y = 3 - 7 = -4$.\n2.  Calculate the denominator: $x + y = 3 + 7 = 10$.\n3.  The division to be performed is $(-4) / 10$.\n4.  The real quotient is $-0.4$.\n5.  According to the language's specified semantics, integer division truncates toward zero.\n    $\\text{trunc}(-0.4) = 0$.\n    Therefore, the value assigned to $p$ is $0$.\nIf the language had used floor division, the result would have been $\\lfloor -0.4 \\rfloor = -1$, illustrating the semantic difference.\nThe final value stored in $p$ under the specified rules is $0$.",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "Efficient code generation is not just about correctness, but also about optimizing the use of finite machine resources. This final practice  challenges you to go beyond a simple left-to-right translation and find an evaluation order that minimizes the number of temporary variables required. Mastering this skill is essential for generating compact and high-performance code, as it directly relates to the efficient allocation of processor registers.",
            "id": "3676922",
            "problem": "Given the arithmetic expression $a + b * c - d / (e + f)$, consider generating three-address code (TAC, three-address code) for a machine model in which each TAC instruction is of the form `x := y op z` with $x$, $y$, and $z$ denoting variables or temporaries, and `op` denoting a binary operator chosen from $\\{+, -, *, /\\}$. Assume the following context and constraints:\n- All variables $a$, $b$, $c$, $d$, $e$, and $f$ denote values in an environment free of side effects; reading any of these variables does not alter program state.\n- Operators $*$ and $/$ have higher precedence than $+$ and $-$, and parentheses enforce the grouping $(e + f)$ prior to the division by $d$.\n- The semantics of the original expression must be preserved exactly; reordering is permitted only insofar as it does not change the mathematical value determined by the original precedence and grouping. You may choose any evaluation order of independent subexpressions and may reuse temporaries once their previous values are no longer needed.\n- A temporary is any symbol not in $\\{a,b,c,d,e,f\\}$ introduced to hold intermediate results. Distinct temporaries are counted by name; reassigning a temporary counts as reuse, not as introducing a new temporary.\n\nTasks:\n1. Derive a correct TAC sequence that computes the value of $a + b * c - d / (e + f)$ into a target variable $g$, starting from the formal definitions above and preserving the given precedence and grouping.\n2. Reorder the evaluation of subexpressions, and design the TAC to minimize the number of distinct temporaries introduced, while keeping the semantics unchanged. Justify that your reordering and reuse strategy is valid under the constraints.\n3. Determine the minimal possible number of distinct temporaries required to compute $g$ without changing semantics. Provide rigorous reasoning for any lower bound you claim, and show that your TAC achieves this bound.\n\nYour final submitted answer must be the minimal number of distinct temporaries required, expressed as a single real-valued number. No rounding is needed.",
            "solution": "The problem as stated is valid. It presents a well-defined task from the domain of compiler theory, specifically code generation and optimization. The expression $a + b * c - d / (e + f)$ is unambiguous, the constraints on three-address code generation are standard, and the objective of minimizing temporary variables is a classical optimization problem. The problem is self-contained, scientifically grounded in computer science principles, and free from any factual or logical inconsistencies.\n\nThe task is to determine the minimum number of distinct temporary variables required to compute the value of the expression $a + b * c - d / (e + f)$ and assign it to a variable $g$.\n\nFirst, we represent the expression as an abstract syntax tree (AST) to visualize the dependencies and order of operations, respecting operator precedence ($*$ and $/$ before $+$ and $-$) and parentheses. The expression is equivalent to $(a + (b * c)) - (d / (e + f))$. The AST is as follows: the root is the final $-$ operation. Its left child is the subtree for $a + (b * c)$ and its right child is the subtree for $d / (e + f)$.\n\n- The root node is $-$.\n  - The left child of the root is a $+$ node.\n    - The left child of this $+$ node is the leaf $a$.\n    - The right child of this $+$ node is a $*$ node with children, the leaves $b$ and $c$.\n  - The right child of the root is a $/$ node.\n    - The left child of the $/$ node is the leaf $d$.\n    - The right child of the $/$ node is a $+$ node with children, the leaves $e$ and $f$.\n\nTo find the minimum number of temporaries required, we can apply the principles of the Sethi-Ullman algorithm. This algorithm assigns a number, let's call it $N(n)$, to each node $n$ in the AST, representing the minimum number of temporaries (or registers) required to evaluate the subtree rooted at $n$.\n\nThe rules for calculating $N(n)$ are:\n1.  If $n$ is a leaf node (a variable or constant), $N(n) = 0$, as its value can be accessed directly from memory and does not require an intermediate temporary for its own computation.\n2.  If $n$ is an internal node with an operator `op` and children $n_L$ and $n_R$, then:\n    - Let $N_L = N(n_L)$ and $N_R = N(n_R)$.\n    - If $N_L \\neq N_R$, we should evaluate the more complex subtree first (the one requiring more temporaries). We compute its value, store it in one of a set of temporaries, and then evaluate the simpler subtree. The number of temporaries needed is $\\max(N_L, N_R)$.\n    - If $N_L = N_R$, we must evaluate one subtree (e.g., $n_R$), store its result in a new temporary, and then evaluate the other subtree $n_L$. While $n_L$ is being evaluated, it requires $N_L$ temporaries, and the result of $n_R$ must remain stored. Thus, the total number of temporaries needed is $N_L + 1$.\n    - So, in summary: $N(n) = \\begin{cases} \\max(N_L, N_R) & \\text{if } N_L \\neq N_R \\\\ N_L + 1 & \\text{if } N_L = N_R \\end{cases}$\n\nLet's apply this bottom-up to our AST:\n\n- **Leaves**: For the leaves $a, b, c, d, e, f$, we have $N(a)=N(b)=N(c)=N(d)=N(e)=N(f)=0$.\n\n- **Node `*`**: This node has children $b$ and $c$. We have $N(b) = 0$ and $N(c) = 0$. Since $N(b) = N(c)$, the number of temporaries is $N(*) = N(b) + 1 = 0 + 1 = 1$. This corresponds to an instruction like `t_1 := b * c`.\n\n- **Node `+` (for `e + f`)**: This node has children $e$ and $f$. We have $N(e) = 0$ and $N(f) = 0$. Since $N(e) = N(f)$, the number of temporaries is $N(+) = N(e) + 1 = 0 + 1 = 1$. This corresponds to an instruction like `t_1 := e + f`.\n\n- **Node `+` (for `a + ...`)**: This is the left child of the root. Its children are the leaf $a$ and the $*$ node. Let's call the $*$ node $n_{b*c}$. We have $N(a) = 0$ and $N(n_{b*c}) = 1$. Since these are not equal, the number of temporaries is $N(+) = \\max(N(a), N(n_{b*c})) = \\max(0, 1) = 1$. To achieve this, we must evaluate the more complex subtree ($n_{b*c}$) first:\n    1. `t_1 := b * c`\n    2. `t_1 := a + t_1` (The temporary is reused)\nSo, the subtree $a + (b * c)$ can be evaluated with a single temporary.\n\n- **Node `/`**: This is the right child of the root. Its children are the leaf $d$ and the $+$ node for $e+f$. Let's call the $+$ node $n_{e+f}$. We have $N(d) = 0$ and $N(n_{e+f}) = 1$. Since these are not equal, the number of temporaries is $N(/) = \\max(N(d), N(n_{e+f})) = \\max(0, 1) = 1$. To achieve this, we evaluate the more complex subtree ($n_{e+f}$) first:\n    1. `t_1 := e + f`\n    2. `t_1 := d / t_1` (The temporary is reused)\nSo, the subtree $d / (e + f)$ can also be evaluated with a single temporary.\n\n- **Root Node `-`**: This node has the two $+$ and $/$ nodes as its children. Let's call them $n_L$ for $a + (b*c)$ and $n_R$ for $d / (e+f)$. From our analysis above, $N(n_L) = 1$ and $N(n_R) = 1$. Since $N(n_L) = N(n_R) = 1$, the number of temporaries required for the root node is $N(-) = N(n_L) + 1 = 1 + 1 = 2$.\n\nThis result of $2$ constitutes a rigorous lower bound on the number of distinct temporaries required. The reasoning is that to evaluate the final subtraction, we must compute the values of both of its operands, $a + (b*c)$ and $d / (e+f)$. As both sub-expressions are non-trivial (i.e., they are not simple leaves), their evaluation requires intermediate results. According to the logic derived from the Sethi-Ullman algorithm, because the two main subtrees have equal complexity in terms of temporary needs (each requires $1$ temporary), we are forced into a situation where we must compute the result of one subtree, store it in a temporary, and then proceed to compute the second subtree. The computation of the second subtree will itself require at least one temporary. During this time, the result of the first subtree must be kept alive. Therefore, at some point during the evaluation, two temporaries must be simultaneously live.\n\nWe can construct a three-address code sequence that achieves this bound of $2$ temporaries. Let the temporaries be `t_1` and `t_2`. The strategy is to evaluate one of the main subtrees, store the result, then evaluate the other main subtree using a different temporary, and finally combine the results.\n\n```\nt_1 := e + f\nt_1 := d / t_1\nt_2 := b * c\nt_2 := a + t_2\nt_2 := t_2 - t_1\ng := t_2\n```\n\nThis sequence uses a maximum of two distinct temporaries, `t_1` and `t_2`, which are simultaneously required at steps 3 and 4. This demonstrates that the lower bound of $2$ is achievable. Therefore, the minimal number of distinct temporaries required is $2$.",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}