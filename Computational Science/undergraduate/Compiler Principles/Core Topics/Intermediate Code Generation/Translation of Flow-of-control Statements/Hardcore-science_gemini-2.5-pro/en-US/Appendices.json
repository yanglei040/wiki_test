{
    "hands_on_practices": [
        {
            "introduction": "A compiler's work isn't finished until it generates code the machine can run. This first practice takes us to the final step of translating a `do-while` loop, focusing on how a logical jump back to the loop's start is encoded as a numerical offset for the program counter. By calculating this PC-relative displacement, you will gain a concrete understanding of backpatching and the interplay between code layout and control flow .",
            "id": "3677994",
            "problem": "Consider a compiler that translates a high-level do-while loop into three-address code using classical backpatching for boolean expressions with short-circuit evaluation. The target machine uses program counter (PC) relative conditional branches: a conditional branch at instruction address $i$ encodes an integer displacement $\\delta$ such that control transfers to target address $T$ if and only if $T = (i + 1) + \\delta$, where addresses count instructions and labels do not occupy instruction slots.\n\nThe translation scheme for a statement of the form do $S$ while $(B)$ is based on these core definitions:\n- The semantics of do-while: the body $S$ executes at least once before the boolean expression $B$ is evaluated; if $B$ evaluates to true, control repeats the loop; otherwise, it exits the loop.\n- Backpatching for boolean expressions: translating $B$ yields a code sequence and two lists $B.true$ and $B.false$ of instruction addresses for conditional and unconditional jumps whose targets are not yet known. Backpatching $B.true$ assigns the loop-head target so that true continues the loop, and backpatching $B.false$ assigns the loop-exit target so that false leaves the loop.\n\nAssume the following concrete layout constraints for a particular do-while loop:\n- The first instruction of the loop (the loop head) is at address $pc_{0} = 1000$.\n- Translating the body $S$ produces exactly $\\ell_{S} = 73$ instructions.\n- Translating the boolean expression $B$ produces exactly $\\ell_{B} = 9$ instructions, with its final instruction at address $pc_{end}$ being the single conditional branch whose true-target is to be backpatched to the loop head. All labels occupy no instruction slots, and no additional instructions are introduced during backpatching.\n\nUnder these conditions, after placing the $B$-code immediately following the body $S$, the compiler backpatches $B.true$ to the loop head at $pc_{0}$. Using only the above fundamentals and definitions, determine the signed PC-relative displacement $\\delta$ that must be encoded in the conditional branch at $pc_{end}$ to jump back to the loop head when $B$ evaluates to true. Provide your final answer as an integer. No rounding is required.",
            "solution": "The problem statement has been validated and is deemed sound, self-contained, and well-posed. It presents a standard scenario in compiler construction concerning the translation of control-flow statements into machine-level instructions with program counter (PC) relative addressing. All necessary parameters are provided, and the objective is clearly defined.\n\nThe goal is to determine the signed PC-relative displacement, denoted by $\\delta$, for a conditional branch instruction. The relationship between the target address $T$, the address of the branch instruction $i$, and the displacement $\\delta$ is given by the formula:\n$$T = (i + 1) + \\delta$$\nThis formula models a common architecture where the PC is advanced to the next instruction address before the displacement is applied. To find $\\delta$, we can rearrange this equation:\n$$\\delta = T - (i + 1)$$\n\nWe must determine the values of the target address $T$ and the branch instruction address $i$ from the problem's specifications.\n\n1.  **Determining the Target Address $T$**:\n    The problem describes the translation of a `do S while (B)` loop. In such a loop, if the condition $B$ is true, control jumps back to the beginning of the loop to re-execute the body $S$. The problem states that the true-target of the conditional branch is backpatched to the loop head. The address of the loop head, which is the first instruction of the statement $S$, is given as $pc_{0}$.\n    Therefore, the target address $T$ is:\n    $$T = pc_{0} = 1000$$\n\n2.  **Determining the Branch Instruction Address $i$**:\n    The conditional branch is specified as the final instruction of the code generated for the boolean expression $B$. To find its address, we must determine the layout of the generated code in memory.\n    The structure of the generated code for `do S while (B)` is the code for $S$ followed immediately by the code for $B$.\n    - The first instruction of the loop, which is the start of the code for the body $S$, is at address $pc_{0} = 1000$.\n    - The code for $S$ consists of $\\ell_{S} = 73$ instructions. These instructions occupy the address range from $pc_{0}$ to $pc_{0} + \\ell_{S} - 1$.\n      Numerically, this is from address $1000$ to $1000 + 73 - 1 = 1072$.\n    - The code for the boolean expression $B$ immediately follows the code for $S$. Thus, its first instruction is at address $(pc_{0} + \\ell_{S} - 1) + 1 = pc_{0} + \\ell_{S}$.\n      Numerically, this is address $1073$.\n    - The code for $B$ consists of $\\ell_{B} = 9$ instructions. The final instruction of this block is the conditional branch instruction whose address we seek. Its address, $i$, which the problem denotes as $pc_{end}$, is the last address in the sequence.\n    This address can be calculated as the starting address of the $B$-block plus the number of instructions in it, minus one.\n    $$i = pc_{end} = (pc_{0} + \\ell_{S}) + \\ell_{B} - 1$$\n    Substituting the given values:\n    $$i = 1000 + 73 + 9 - 1 = 1000 + 82 - 1 = 1081$$\n    So, the conditional branch instruction is located at address $i = 1081$.\n\n3.  **Calculating the Displacement $\\delta$**:\n    Now we substitute the determined values of $T$ and $i$ into the rearranged formula for $\\delta$:\n    $$\\delta = T - (i + 1)$$\n    $$\\delta = 1000 - (1081 + 1)$$\n    $$\\delta = 1000 - 1082$$\n    $$\\delta = -82$$\n\nThe displacement is negative, which is expected for a jump that returns control to an earlier point in the program (the loop head). The magnitude of the jump, $82$, corresponds to the total number of instructions in the loop body ($S$) and the conditional check ($B$), which is $\\ell_S + \\ell_B = 73 + 9 = 82$. The jump from the instruction at address $i = 1081$ must land at $T = 1000$. The PC is first incremented to $1082$, and then the displacement $\\delta = -82$ is added, resulting in the correct target address $1082 + (-82) = 1000$.",
            "answer": "$$\\boxed{-82}$$"
        },
        {
            "introduction": "Modern languages use short-circuit evaluation not just for speed, but for safety, preventing unnecessary operations that might have side effects. This exercise challenges you to analyze the control flow for a nested boolean expression and calculate the expected number of function calls, quantifying the efficiency of this core compiler optimization. It demonstrates how a compiler's adherence to language semantics directly impacts program performance and behavior .",
            "id": "3677918",
            "problem": "Consider the translation to low-level control flow of short-circuit boolean expressions in a language with left-to-right evaluation order. The language implements short-circuit logical AND and OR, written as $E_{1} \\land E_{2}$ and $E_{1} \\lor E_{2}$, with the following evaluation semantics: for $E_{1} \\land E_{2}$, $E_{2}$ is evaluated only if $E_{1}$ evaluates to $\\text{true}$; for $E_{1} \\lor E_{2}$, $E_{2}$ is evaluated only if $E_{1}$ evaluates to $\\text{false}$. A correct lowering to labels and conditional jumps must preserve these semantics so that operands whose values cannot affect the final result are not evaluated.\n\nYou are given four functions $f(), g(), h(), k()$ that each return a boolean. The high-level expression is\n$$\n(f() \\land g()) \\lor (h() \\land k()).\n$$\nAssume the compiler targets a Control Flow Graph (CFG) structure using basic blocks and conditional branches; the correct lowering must ensure that only the operands necessary to determine the value of the expression are executed. The library contract for these functions warns that executing unnecessary operands after the result is already determined may have undefined behavior due to side effects; therefore, the lowering must strictly adhere to short-circuit control flow and should not speculatively evaluate any operand.\n\nSuppose every individual call’s return value is independent of the others and identically distributed across evaluations, with\n- $\\mathbb{P}(f() \\text{ returns } \\text{true}) = p_{f}$,\n- $\\mathbb{P}(g() \\text{ returns } \\text{true}) = p_{g}$,\n- $\\mathbb{P}(h() \\text{ returns } \\text{true}) = p_{h}$,\n- $\\mathbb{P}(k() \\text{ returns } \\text{true}) = p_{k}$.\nAssume independence both between functions and across repeated evaluations of the whole expression.\n\nA program evaluates the above expression $N$ times on independent inputs. Under a correct short-circuit-preserving lowering that ensures only necessary calls occur, what is the closed-form analytic expression for the expected total number of function calls performed across the $N$ evaluations? Express your answer in terms of $N$, $p_{f}$, $p_{g}$, and $p_{h}$ only. Do not round; provide the exact expression.",
            "solution": "The problem statement is rigorously analyzed and found to be valid. It is scientifically grounded in the principles of compiler design and probability theory, is well-posed, objective, and self-contained. The initial-seeming peculiarity that the final expression must not contain $p_k$ is a direct and logical consequence of short-circuit evaluation semantics, which makes the number of function calls independent of the return value of the last potential function in a chain.\n\nThe problem asks for the expected total number of function calls when evaluating the expression $(f() \\land g()) \\lor (h() \\land k())$ for $N$ independent trials. The evaluation follows left-to-right, short-circuit semantics.\n\nLet $C$ be the random variable representing the number of function calls in a single evaluation. The total number of calls over $N$ evaluations is $C_{total} = \\sum_{i=1}^{N} C_i$, where $C_i$ is the number of calls in the $i$-th evaluation. By the linearity of expectation, the expected total number of calls is $E[C_{total}] = \\sum_{i=1}^{N} E[C_i]$. Since all evaluations are independent and identically distributed, $E[C_i] = E[C]$ for all $i$, so $E[C_{total}] = N \\cdot E[C]$.\n\nWe can find $E[C]$ by applying the linearity of expectation to the individual function calls within a single evaluation. Let $I_f, I_g, I_h, I_k$ be indicator variables such that $I_x = 1$ if function $x()$ is called and $I_x = 0$ otherwise. The total number of calls in one evaluation is $C = I_f + I_g + I_h + I_k$.\nThe expected number of calls is then:\n$$\nE[C] = E[I_f + I_g + I_h + I_k] = E[I_f] + E[I_g] + E[I_h] + E[I_k]\n$$\nThe expectation of an indicator variable is the probability of the event it indicates, so $E[I_x] = \\mathbb{P}(x() \\text{ is called})$. We will now calculate these probabilities based on the specified short-circuit evaluation rules.\n\n1.  **Probability of calling $f()$**: The function $f()$ is the first operand in the expression. It is always evaluated.\n    $$\n    \\mathbb{P}(f() \\text{ is called}) = 1\n    $$\n\n2.  **Probability of calling $g()$**: The expression is of the form $E_1 \\land E_2$, where $E_1 = f()$. The function $g()$ is part of the second operand. Due to short-circuiting, $g()$ is called if and only if $f()$ evaluates to $\\text{true}$.\n    $$\n    \\mathbb{P}(g() \\text{ is called}) = \\mathbb{P}(f() \\text{ returns true}) = p_f\n    $$\n\n3.  **Probability of calling $h()$**: The overall expression is of the form $(f() \\land g()) \\lor (h() \\land k())$. Let the first subexpression be $E_{left} = f() \\land g()$. The function $h()$, as the first part of the second subexpression, is called if and only if $E_{left}$ evaluates to $\\text{false}$. $E_{left}$ is false if either $f()$ returns $\\text{false}$, or if $f()$ returns $\\text{true}$ but $g()$ returns $\\text{false}$. These are mutually exclusive events.\n    $$\n    \\mathbb{P}(h() \\text{ is called}) = \\mathbb{P}(E_{left} \\text{ is false}) = \\mathbb{P}(f() \\text{ is false}) + \\mathbb{P}(f() \\text{ is true} \\land g() \\text{ is false})\n    $$\n    Using the given probabilities and independence:\n    $$\n    \\mathbb{P}(h() \\text{ is called}) = (1 - p_f) + p_f(1 - p_g) = 1 - p_f + p_f - p_f p_g = 1 - p_f p_g\n    $$\n\n4.  **Probability of calling $k()$**: The function $k()$ is the second part of the subexpression $h() \\land k()$. It is called if and only if the evaluation reaches this subexpression (i.e., $h()$ is called) AND $h()$ evaluates to $\\text{true}$.\n    $$\n    \\mathbb{P}(k() \\text{ is called}) = \\mathbb{P}(h() \\text{ is called AND } h() \\text{ returns true})\n    $$\n    Since the return value of $h()$ is independent of the conditions that led to its call:\n    $$\n    \\mathbb{P}(k() \\text{ is called}) = \\mathbb{P}(h() \\text{ is called}) \\times \\mathbb{P}(h() \\text{ returns true}) = (1 - p_f p_g) p_h\n    $$\n    It is critical to note that the decision to call $k()$ depends on the return value of $h()$ (with probability $p_h$), but not on the return value of $k()$ itself (which would be $p_k$). Therefore, the expression for the number of calls correctly excludes $p_k$, as required by the problem statement.\n\nNow we sum these probabilities to find the expected number of calls for a single evaluation, $E[C]$:\n$$\nE[C] = \\mathbb{P}(f() \\text{ is called}) + \\mathbb{P}(g() \\text{ is called}) + \\mathbb{P}(h() \\text{ is called}) + \\mathbb{P}(k() \\text{ is called})\n$$\n$$\nE[C] = 1 + p_f + (1 - p_f p_g) + (1 - p_f p_g)p_h\n$$\nThis expression can be simplified by factoring out the common term $(1 - p_f p_g)$:\n$$\nE[C] = 1 + p_f + (1 - p_f p_g)(1 + p_h)\n$$\nExpanding this for a different representation:\n$$\nE[C] = 1 + p_f + 1 + p_h - p_f p_g - p_f p_g p_h = 2 + p_f + p_h - p_f p_g - p_f p_g p_h\n$$\nFinally, the expected total number of function calls across $N$ independent evaluations is $N$ times this value:\n$$\nE[C_{total}] = N \\cdot E[C] = N (1 + p_f + (1 - p_f p_g)(1 + p_h))\n$$\nThis is the closed-form analytic expression in terms of $N$, $p_f$, $p_g$, and $p_h$.",
            "answer": "$$\n\\boxed{N(1 + p_f + (1 - p_f p_g)(1 + p_h))}\n$$"
        },
        {
            "introduction": "This final practice provides a comprehensive workout in control-flow analysis, starting with the task of reverse-engineering unstructured \"spaghetti code\" into a structured equivalent. You will then re-lower this structured code into an Intermediate Representation, formally proving its equivalence to the original by constructing a Control Flow Graph (CFG). Calculating the graph's cyclomatic complexity introduces a powerful metric for reasoning about code complexity, a vital skill in compiler optimization and software testing .",
            "id": "3677965",
            "problem": "Consider the following goto-based program that uses integer variables $i$, $n$, $s$, $t$, and $r$. The initial conditions are $s \\leftarrow 0$ and $n \\ge 0$ is a given input. Labels are denoted $L_{k}$ for integers $k$ and control transfers use conditional or unconditional jumps.\n\n$L_{0}$: $i \\leftarrow 0$; $s \\leftarrow 0$; goto $L_{1}$\n\n$L_{1}$: if $i \\ge n$ goto $L_{7}$ else goto $L_{2}$\n\n$L_{2}$: $t \\leftarrow i \\times i$; if $(t \\bmod 3) = 0$ goto $L_{5}$ else goto $L_{4}$\n\n$L_{4}$: $s \\leftarrow s + t$; goto $L_{6}$\n\n$L_{5}$: $s \\leftarrow s - i$; goto $L_{6}$\n\n$L_{6}$: $i \\leftarrow i + 1$; goto $L_{1}$\n\n$L_{7}$: if $s  0$ goto $L_{9}$ else goto $L_{8}$\n\n$L_{8}$: $r \\leftarrow s$; goto $L_{10}$\n\n$L_{9}$: $r \\leftarrow -s$; goto $L_{10}$\n\n$L_{10}$: halt\n\nStarting from the foundational principles of translating flow-of-control statements in compiler design, namely the translation of structured constructs into Intermediate Representation (IR) with labels, conditional jumps, and basic blocks, perform the following:\n\n1. Reconstruct this program into structured constructs using a loop and conditionals that are semantically equivalent to the given goto-based version, without changing the observable behavior computed for $r$.\n2. Re-lower the structured version back into a canonical three-address code Intermediate Representation (IR) using standard translation schemes for $if$-statements and $while$-loops, introducing labels and conditional/unconditional jumps to delineate basic blocks.\n3. Build the Control-Flow Graph (CFG) of the re-lowered IR, identifying its basic blocks and directed edges among them, and justify that the CFG is isomorphic to that of the original goto-based program (thus establishing equivalence of the IRs).\n4. Compute the cyclomatic complexity of the re-lowered IR’s CFG as a single real-valued number. Express the final cyclomatic complexity value as your answer. No rounding is required.\n\nYour final answer must be the cyclomatic complexity value of the re-lowered IR’s CFG.",
            "solution": "The problem statement is valid. It presents a well-defined task within the domain of compiler principles, providing a self-contained, logically consistent, and unambiguous goto-based program for control-flow analysis. The problem is scientifically grounded in established computer science theory and can be solved through formal, objective methods. We will proceed with the four required tasks.\n\n### 1. Reconstruction into Structured Constructs\n\nThe provided goto-based program can be analyzed to reveal its underlying structured logic.\n\n- The statements at label $L_{0}$ (`i - 0; s - 0;`) are initialization steps executed once before any looping.\n- The block starting at $L_{1}$ and ending with the jump back to $L_{1}$ from $L_{6}$ forms a loop. The entry condition at $L_{1}$ is `if i = n goto L_exit`, which is equivalent to a `while (i  n)` loop.\n- Inside this loop (labels $L_{2}$ through $L_{6}$), the program calculates `t - i * i`. Based on the condition `(t mod 3) = 0`, it follows one of two paths:\n    - If `(t mod 3) = 0` is false, it proceeds to $L_{4}$ and executes `s - s + t`.\n    - If `(t mod 3) = 0` is true, it proceeds to $L_{5}$ and executes `s - s - i`.\n    - Both paths converge at $L_{6}$, where the loop counter `i` is incremented (`i - i + 1`), and control returns to the loop condition at $L_{1}$. This structure is an `if-else` statement nested within the loop.\n- After the loop terminates (when `i = n`), control transfers to $L_{7}$. The statements at labels $L_{7}$, $L_{8}$, and $L_{9}$ compute the absolute value of $s$ and store it in $r$. Specifically, `if s  0` then `r - -s`, else `r - s`.\n- Finally, the program halts at $L_{10}$.\n\nBased on this analysis, the semantically equivalent structured program is:\n```c\ns = 0;\ni = 0;\nwhile (i  n) {\n    t = i * i;\n    if ((t % 3) == 0) {\n        s = s - i;\n    } else {\n        s = s + t;\n    }\n    i = i + 1;\n}\nif (s  0) {\n    r = -s;\n} else {\n    r = s;\n}\nhalt;\n```\nNote that the initialization `s - 0` is explicitly given in the problem and also appears at $L_0$. The effect is the same.\n\n### 2. Re-lowering to Three-Address Code IR\n\nUsing standard translation schemes for structured control-flow statements, we can lower the above program into a three-address code Intermediate Representation (IR). This process involves creating basic blocks delineated by labels and jumps.\n\n- **Block $B'_{0}$ (Initialization):**\n  `i - 0`\n  `s - 0`\n  `goto B'_{1}`\n\n- **Block $B'_{1}$ (Loop Header):**\n  `if i = n goto B'_{6}`\n  `else goto B'_{2}`\n\n- **Block $B'_{2}$ (Loop Body, Conditional):**\n  `t - i * i`\n  `tmp - t mod 3`\n  `if tmp = 0 goto B'_{4}`\n  `else goto B'_{3}`\n\n- **Block $B'_{3}$ (Inner `else` branch):**\n  `s - s + t`\n  `goto B'_{5}`\n\n- **Block $B'_{4}$ (Inner `then` branch):**\n  `s - s - i`\n  `goto B'_{5}`\n\n- **Block $B'_{5}$ (Loop Increment):**\n  `i - i + 1`\n  `goto B'_{1}`\n\n- **Block $B'_{6}$ (Post-Loop, Absolute Value):**\n  `if s  0 goto B'_{8}`\n  `else goto B'_{7}`\n\n- **Block $B'_{7}$ (Absolute Value `else` branch):**\n  `r - s`\n  `goto B'_{9}`\n\n- **Block $B'_{8}$ (Absolute Value `then` branch):**\n  `r - -s`\n  `goto B'_{9}`\n\n- **Block $B'_{9}$ (Halt):**\n  `halt`\n\nThis IR consists of $10$ basic blocks, labeled $B'_{0}$ through $B'_{9}$.\n\n### 3. Control-Flow Graph (CFG) Construction and Isomorphism\n\nFirst, we identify the basic blocks of the **original** goto-based program. A basic block starts at a label that is a target of a jump or at the beginning of the program, and it ends with a jump or just before another leader instruction. The leaders in the original code are the instructions at labels $L_{0}, L_{1}, L_{2}, L_{4}, L_{5}, L_{6}, L_{7}, L_{8}, L_{9}, L_{10}$. This gives $10$ basic blocks, which we denote $B_{k}$ for the block starting at label $L_{k}$ (with $B_0, B_1, B_2, B_4, B_5, B_6, B_7, B_8, B_9, B_{10}$).\n\nThe Control-Flow Graph $G = (V, E)$ for the original program has a set of vertices $V = \\{B_{0}, B_{1}, B_{2}, B_{4}, B_{5}, B_{6}, B_{7}, B_{8}, B_{9}, B_{10}\\}$ ($|V| = N = 10$) and a set of directed edges $E$ determined by the jumps:\n- $E = \\{ (B_{0}, B_{1}), (B_{1}, B_{2}), (B_{1}, B_{7}), (B_{2}, B_{4}), (B_{2}, B_{5}), (B_{4}, B_{6}), (B_{5}, B_{6}), (B_{6}, B_{1}), (B_{7}, B_{8}), (B_{7}, B_{9}), (B_{8}, B_{10}), (B_{9}, B_{10}) \\}$\nThe number of edges is $|E| = 12$.\n\nThe CFG $G' = (V', E')$ for the **re-lowered IR** has a set of vertices $V' = \\{B'_{0}, B'_{1}, B'_{2}, B'_{3}, B'_{4}, B'_{5}, B'_{6}, B'_{7}, B'_{8}, B'_{9}\\}$ ($|V'| = N = 10$) and a set of directed edges $E'$:\n- $E' = \\{ (B'_{0}, B'_{1}), (B'_{1}, B'_{2}), (B'_{1}, B'_{6}), (B'_{2}, B'_{3}), (B'_{2}, B'_{4}), (B'_{3}, B'_{5}), (B'_{4}, B'_{5}), (B'_{5}, B'_{1}), (B'_{6}, B'_{7}), (B'_{6}, B'_{8}), (B'_{7}, B'_{9}), (B'_{8}, B'_{9}) \\}$\nThe number of edges is $|E'| = 12$.\n\nTo justify that $G$ and $G'$ are isomorphic, we must demonstrate a bijection $f: V \\to V'$ that preserves adjacency. Let's define the mapping based on the functional role of each block:\n- $f(B_{0}) = B'_{0}$ (Initialization)\n- $f(B_{1}) = B'_{1}$ (Loop header)\n- $f(B_{2}) = B'_{2}$ (Loop body pre-conditional)\n- $f(B_{4}) = B'_{3}$ (The `else` path of the inner `if`)\n- $f(B_{5}) = B'_{4}$ (The `then` path of the inner `if`)\n- $f(B_{6}) = B'_{5}$ (Loop increment and continue)\n- $f(B_{7}) = B'_{6}$ (Post-loop conditional)\n- $f(B_{8}) = B'_{7}$ (The `else` path of the outer `if`)\n- $f(B_{9}) = B'_{8}$ (The `then` path of the outer `if`)\n- $f(B_{10}) = B'_{9}$ (Halt/Exit)\n\nThis function $f$ is a bijection between $V$ and $V'$. We check that for any edge $(u, v) \\in E$, the edge $(f(u), f(v)) \\in E'$. For example, $(B_{6}, B_{1}) \\in E$, and the corresponding edge in $G'$ is $(f(B_{6}), f(B_{1})) = (B'_{5}, B'_{1})$, which is in $E'$. Similarly, $(B_{2}, B_{4}) \\in E$ corresponds to $(f(B_{2}), f(B_{4})) = (B'_{2}, B'_{3}) \\in E'$. A full check confirms that all $12$ edges are preserved under this mapping. Therefore, the CFG of the re-lowered IR is isomorphic to the CFG of the original program.\n\n### 4. Cyclomatic Complexity Calculation\n\nThe cyclomatic complexity $M$ of a control-flow graph can be computed using several equivalent formulas. We will use the formula based on the number of nodes, edges, and connected components of the graph. For a CFG with a single entry and single exit point, there is $P=1$ connected component. The formula is:\n$$M = E - N + 2P$$\nUsing the CFG for the re-lowered IR (which is isomorphic to the original), we have:\n- Number of nodes (basic blocks) $N = 10$.\n- Number of edges (control transfers) $E = 12$.\n- Number of connected components $P = 1$.\n\nSubstituting these values into the formula:\n$$M = 12 - 10 + 2(1) = 2 + 2 = 4$$\n\nAlternatively, we can use the formula $M = D + 1$, where $D$ is the number of decision nodes (nodes with an out-degree of $2$).\nThe decision nodes in the graph are:\n1.  $B'_{1}$ (or $B_{1}$): `if i >= n`\n2.  $B'_{2}$ (or $B_{2}$): `if tmp = 0`\n3.  $B'_{6}$ (or $B_{7}$): `if s  0`\nThere are $D=3$ decision nodes. Thus, the complexity is:\n$$M = 3 + 1 = 4$$\n\nBoth methods yield the same result. The cyclomatic complexity of the CFG is $4$.",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}