{
    "hands_on_practices": [
        {
            "introduction": "赋值语句的翻译看似直接，但当表达式包含自增（`++`）等副作用时，情况就变得复杂。正确的代码生成要求我们严格遵守语言定义的求值顺序和副作用的发生时机。本练习将通过一个涉及多重后置自增操作的例子，训练你精确追踪变量状态变化的能力，这是保证编译器正确性的基石。",
            "id": "3622053",
            "problem": "您正在为一个简单的命令式语言设计一个代码生成器，该语言包含整型变量和两种构造：赋值 `:=` 和后置自增 `++`。目标是正确地将带有副作用的表达式翻译成三地址码 (TAC)，同时保留源语言的语义保证。\n\n核心定义与保证：\n- 每个变量表示一个存储整数的独立内存位置。所有算术运算都基于数学上的整数，并且不会溢出。\n- 后置自增 $v++$ 产生 $v$ 的当前值，并作为副作用将 $v$ 的值增加 1。这个增量必须被持久化。\n- 在任何二元表达式 $E_1 \\circ E_2$ 中（对于任何运算符 $\\circ$），求值从左到右进行：$E_1$ 被完全求值（包括所有副作用），然后是 $E_2$，最后应用该运算符。\n- 在赋值语句 $x := E$ 中，右侧表达式 $E$ 在存入 $x$ 之前被完全求值（包括所有副作用）。\n- 后置自增出现的翻译模式：为对 $v++$ 求值，生成 TAC 时需使用一个新的临时变量 $t$ 将其分裂为一个取值阶段和一个写回阶段：首先 $t := v$（取值），然后 $v := v + 1$（写回）；表达式 $v++$ 贡献的值是 $t$。\n\n考虑以下顺序执行的程序片段，其中括号表示显式分组，并且每个运算符处的求值顺序都如上所述从左到右进行：\n1. `a := y++`\n2. `b := (y++) + (y++)`\n3. `c := (y++) * ((y++) - 1) - (y++)`\n4. `y := y++`\n5. `w := a + b + c + y`\n\n假设初始状态为 $y = 3$，所有其他变量在执行此片段之前均未初始化。仅使用上述核心定义和翻译模式，并确保每个 $v++$ 都通过使用一个新的临时变量分裂为取值阶段和写回阶段来处理，请确定在将该片段作为正确翻译的 TAC 执行后，$w$ 的最终值。\n\n请以单个整数形式提供您的答案。无需四舍五入。",
            "solution": "问题陈述经核实具有科学依据、是良构的且客观的。它描述了编译器设计中的一个标准问题，即关于将带有副作用的表达式翻译成中间代码。求值顺序、后置自增的副作用以及赋值语义的规则都得到了明确且无歧义的定义，从而可以对程序执行进行唯一的、确定性的追踪。因此，该问题是有效的。\n\n任务是通过追踪五个语句序列的执行过程来确定变量 $w$ 的最终值。追踪将严格遵守所提供的语义规则，逐步进行。我们从初始状态 $y=3$ 且所有其他变量均未初始化开始。每次后置自增操作 $v++$ 的翻译都将使用一个新的临时变量 $t_i$ 来将取值与自增 $v$ 的副作用分开。\n\n初始状态：$y=3$。\n\n1.  **语句 1：** $a := y++$\n    首先对右侧 (RHS) 的 $y++$ 进行求值。\n    *   取值阶段：一个临时变量 $t_1$ 被赋予 $y$ 的当前值。$t_1 := y$，因此 $t_1$ 变为 $3$。\n    *   写回阶段：变量 $y$ 自增。$y := y + 1$，因此 $y$ 变为 $3+1=4$。\n    RHS 表达式的值是在临时变量中捕获的值，即 $3$。\n    最后，执行对 $a$ 的赋值：$a := 3$。\n    **语句 1 后的状态：** $y=4$，$a=3$。\n\n2.  **语句 2：** $b := (y++) + (y++)$\n    RHS 是一个二元加法。根据规则，左操作数在右操作数之前被完全求值。\n    *   求值左操作数，第一个 $y++$：\n        *   取值阶段：$t_2 := y$。$y$ 的当前值是 $4$，因此 $t_2$ 变为 $4$。\n        *   写回阶段：$y := y + 1$。$y$ 的值变为 $4+1=5$。\n        左操作数的值是 $4$。\n    *   求值右操作数，第二个 $y++$。来自左操作数的副作用已经完成。\n        *   取值阶段：$t_3 := y$。$y$ 的当前值是 $5$，因此 $t_3$ 变为 $5$。\n        *   写回阶段：$y := y + 1$。$y$ 的值变为 $5+1=6$。\n        右操作数的值是 $5$。\n    *   应用加法运算符：$4 + 5 = 9$。\n    执行对 $b$ 的赋值：$b := 9$。\n    **语句 2 后的状态：** $y=6$，$a=3$，$b=9$。\n\n3.  **语句 3：** $c := (y++) \\times \\big((y++) - 1\\big) - (y++)$\n    表达式根据相同级别运算符从左到右的优先级进行求值，并且括号强制执行。其结构是 $(E_1 \\times E_2) - E_3$。\n    *   首先，求值子表达式 $(y++) \\times \\big((y++) - 1\\big)$。\n        *   求值其左操作数，第一个 $y++$：\n            *   取值阶段：$t_4 := y$。$y$ 的当前值是 $6$，因此 $t_4$ 变为 $6$。\n            *   写回阶段：$y := y + 1$。$y$ 的值变为 $6+1=7$。\n            该操作数的值是 $6$。\n        *   求值其右操作数，$\\big((y++) - 1\\big)$。\n            *   求值内部的 $y++$：\n                *   取值阶段：$t_5 := y$。$y$ 的当前值是 $7$，因此 $t_5$ 变为 $7$。\n                *   写回阶段：$y := y + 1$。$y$ 的值变为 $7+1=8$。\n                这个内部 $y++$ 的值是 $7$。\n            *   应用减法：$7 - 1 = 6$。子表达式 $\\big((y++) - 1\\big)$ 的值是 $6$。\n        *   应用乘法运算符：$6 \\times 6 = 36$。\n    *   整个表达式现在简化为 $36 - (y++)$。\n        *   求值右操作数，最后一个 $y++$。\n            *   取值阶段：$t_6 := y$。$y$ 的当前值是 $8$，因此 $t_6$ 变为 $8$。\n            *   写回阶段：$y := y + 1$。$y$ 的值变为 $8+1=9$。\n            该操作数的值是 $8$。\n    *   应用最后的减法运算符：$36 - 8 = 28$。\n    执行对 $c$ 的赋值：$c := 28$。\n    **语句 3 后的状态：** $y=9$，$a=3$，$b=9$，$c=28$。\n\n4.  **语句 4：** $y := y++$\n    处理此语句时，首先完全求值 RHS，然后执行赋值。\n    *   求值 RHS，$y++$：\n        *   取值阶段：$t_7 := y$。$y$ 的当前值是 $9$，因此 $t_7$ 变为 $9$。\n        *   写回阶段：$y := y + 1$。$y$ 的值变为 $9+1=10$。\n    *   RHS 表达式的值是 $t_7$，即 $9$。\n    *   最后，执行赋值：$y := 9$。此赋值覆盖了由写回阶段产生的 $y$ 值。\n    **语句 4 后的状态：** $y=9$，$a=3$，$b=9$，$c=28$。\n\n5.  **语句 5：** $w := a + b + c + y$\n    RHS 表达式不涉及副作用。我们代入变量的当前值。\n    *   $a=3$，$b=9$，$c=28$，$y=9$。\n    *   求和计算：$3 + 9 + 28 + 9 = 12 + 28 + 9 = 40 + 9 = 49$。\n    执行对 $w$ 的赋值：$w := 49$。\n    **最终状态：** $y=9$，$a=3$，$b=9$，$c=28$，$w=49$。\n\n在整个片段执行完毕后，$w$ 的最终值为 $49$。",
            "answer": "$$\n\\boxed{49}\n$$"
        },
        {
            "introduction": "在前一个练习的基础上，我们进一步探讨副作用在更复杂场景下的影响，特别是当它出现在计算内存地址（如数组索引）的表达式中时。本练习  聚焦于一个经典的棘手案例：`a[i++] := a[i]`。它旨在揭示为何必须使用临时变量来“冻结”值，以确保在副作用（$i$ 的递增）发生之前，地址计算和右侧取值都使用正确的索引，从而严格遵循语言的语义规范。",
            "id": "3622020",
            "problem": "我们正在为一个小型命令式源语言设计编译器，用于将涉及数组和后自增运算符的赋值语句翻译成一种底层中间表示 (IR)。该源语言具有以下语义，这些语义由语言规范定义并保证：\n\n- 表达式求值顺序为从左到右。\n- 在赋值语句 $L := R$ 中，右侧 $R$ 会被完全求值以产生一个值，然后左侧 $L$ 才会被求值为一个地址，并被赋予所产生的值。\n- 后自增运算符 $x++$ 产生 $x$ 的当前值，并作为一个副作用，在操作数求值后将 $x$ 的值增加 1。\n\n该编译器旨在生成经典的三地址码 (TAC)，其中三地址码 (TAC) 是一种中间表示 (IR)，其每条指令最多包含一个运算符，作用于最多两个操作数，并产生最多一个结果。此处的 TAC 适用以下约束：\n\n- 仅有的有状态内存位置是标量变量（如 $i$）和数组（如 $a$）；$i$ 和 $a$ 之间不存在函数调用或别名。\n- 允许的指令形式包括将标量读入临时变量 (`t := i`)、对临时变量或标量进行整数加法 (`t := u + c` 或 `i := i + c`)、数组加载 (`t := load(a, t_idx)`) 和数组存储 (`store(a, t_idx, t_val)`)。每个临时变量最多被写入一次（临时变量的单次赋值），并且由源运算符引发的副作用（如 `i := i + 1`）必须且仅出现一次。\n- 生成的 TAC 必须保持指定的源语言级别的求值顺序以及由 $i++$ 蕴含的副作用的单次出现；编译器不得引入虚假的增量操作或跨副作用对求值进行重排序。\n\n考虑在上述语义和 TAC 约束下，对单个源语句 `a[i++] := a[i]` 进行降级翻译。设 $\\tau$ 表示为确保语义正确性（包括保持已定义的求值顺序并避免任何双重增量或重排序错误）而必须在 TAC 中引入的不同临时变量的最小数量。\n\n确定最小的 $\\tau$ 值。请用一个整数表示你的答案。无需四舍五入，也不涉及单位。",
            "solution": "该问题要求确定将源语句 `a[i++] := a[i]` 正确翻译成特定的三地址码 (TAC) 所需的最小临时变量数量 $\\tau$，同时要遵循语言定义的语义。\n\n首先，让我们将所提供的语义和约束形式化。\n1.  **赋值语义 ($L := R$)**：首先完全求值右侧 $R$ 以产生一个值。然后，求值左侧 $L$ 以确定一个内存地址。最后，将来自 $R$ 的值存储到由 $L$ 确定的地址中。\n2.  **后自增语义 ($x++$)**：该表达式产生变量 $x$ 的当前值。作为一个副作用，在获取其值之后，$x$ 的值会增加 1。\n3.  **TAC 指令形式**：翻译必须使用一组受限的指令，包括 `t := i`、`t := u + c`、`i := i+c`、`t := load(a, t_idx)` 和 `store(a, t_idx, t_val)`。从这些形式中得出的一个关键约束是，用于数组索引的操作数 (`t_idx`) 和要存储的值 (`t_val`) 都必须保存在临时变量中。\n\n让我们应用这些规则来翻译语句 `a[i++] := a[i]`。设 $i_0$ 表示语句开始执行时变量 $i$ 的值。\n\n**步骤 1：求值右侧 (RHS)**\nRHS 是表达式 `a[i]`。根据赋值语义，它首先被求值。\n- 为了求值 `a[i]`，编译器必须首先确定索引，即 $i$ 的当前值，也就是 $i_0$。\n- 用于从数组加载的 TAC 指令是 `t := load(a, t_idx)`，它要求索引位于一个临时变量中。因此，我们必须首先将 $i$ 的值复制到一个临时变量中。我们称这个临时变量为 $t_1$。\n  `t1 := i`\n  执行此指令后，$t_1$ 持有值 $i_0$。\n- 现在，我们可以从数组中加载值。加载的结果必须存储在一个临时变量中。我们称之为 $t_2$。\n  `t2 := load(a, t1)`\n  执行此指令后，$t_2$ 持有 $a[i_0]$ 的值。\n至此，RHS 的求值完成。要赋的最终值现在存储在 $t_2$ 中。\n\n**步骤 2：求值左侧 (LHS)**\nLHS 是表达式 `a[i++]`，必须对其求值以产生一个地址。此求值在 RHS 完全求值之后发生。\n- 数组访问的索引由表达式 `i++` 确定。\n- 后自增运算符产生 $i$ 的当前值，该值仍然是 $i_0$（因为副作用尚未发生）。这个我们进行最终 `store` 操作所需的值 $i_0$，已经恰好存储在我们的临时变量 $t_1$ 中。\n- 在为索引获取到值 $i_0$ 之后，必须执行后自增运算符的副作用。这包括对变量 $i$ 进行增量操作。\n  `i := i + 1`\n  变量 $i$ 现在持有值 $i_0 + 1$。LHS 的求值现已完成。目标地址由数组 $a$ 和索引 $i_0$ 指定，该索引保存在 $t_1$ 中。\n\n**步骤 3：执行赋值**\n最后一步是将从 RHS 获得的值存储到由 LHS 确定的地址中。\n- 用于此操作的 TAC 指令是 `store(a, t_idx, t_val)`。这种指令形式要求索引和值都位于临时变量中。\n- 索引是 $i_0$，保存在 $t_1$ 中。\n- 要存储的值是 $a[i_0]$，保存在 $t_2$ 中。\n- 因此，最终的指令是：\n  `store(a, t1, t2)`\n\n**完整的 TAC 序列和最小性分析**\n完整的、顺序正确的 TAC 指令序列是：\n1. `t1 := i`\n2. `t2 := load(a, t1)`\n3. `i := i + 1`\n4. `store(a, t1, t2)`\n\n这个序列使用了两个不同的临时变量 $t_1$ 和 $t_2$。这表明使用 $\\tau = 2$ 是可以实现正确翻译的。\n\n为了确定这是否是最小数量，我们分析数据依赖和生命周期。\n1.  用于 `store` 操作的索引值 $i_0$ 必须在步骤 $4$ 时可用。然而，变量 $i$ 在步骤 $3$ 被修改。因此，值 $i_0$ 必须在增量操作发生前保存在一个与 $i$ 分开的位置。由于编译器只能为此目的引入临时变量，因此至少需要一个临时变量来保存该索引。\n2.  从 RHS 加载的值 $a[i_0]$ 也必须在步骤 $4$ 时可用。TAC 指令 `t := load(...)` 要求将结果放入一个临时变量中。\n3.  关键点在于，对于最终的 `store(a, t1, t2)` 指令，索引值 ($i_0$) 和源值 ($a[i_0]$) 都必须同时在临时变量中可用。如果尝试只使用一个临时变量（例如 `t`），将会失败：\n    - `t := i` （现在 `t` 持有索引 $i_0$）\n    - `t := load(a, t)` （现在 `t` 持有值 $a[i_0]$，但之前在 `t` 中的索引 $i_0$ 被覆盖而丢失）。\n    由于最终的 `store` 指令需要用到索引，而它已被覆盖，因此这个序列是不正确的。\n4.  索引值 $i_0$ 和加载值 $a[i_0]$ 的生命周期是重叠的。它们在最终的 `store` 指令中都需要。由于 TAC 形式要求这两个量在 `store` 指令执行时都必须存在于临时变量中，因此它们必须占据两个不同的临时变量。\n\n因此，所需的最小临时变量数量为 $\\tau=2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "除了副作用，指针和别名（aliasing）是赋值翻译中另一个必须审慎处理的关键问题。当两个不同的表达式（例如 `x` 和 `*alias`）可能指向同一内存位置时，编译器优化器可能会做出错误的简化，导致程序行为不符合预期。本练习  探讨了如何生成在存在别名时依然正确的代码，特别是如何确保像内存写入这样的可观察行为（observable behavior）不被错误地优化掉。",
            "id": "3621961",
            "problem": "编译器后端必须将高级赋值语句 `x := *alias` 转换为加载/存储机器的低级指令序列，同时在可能存在别名的情况下保持可观察语义。程序状态由顺序一致性内存和寄存器组成。赋值的操作语义规定，先将右侧表达式求值为一个值，然后将该值写入左侧变量。指针变量 `alias` 在运行时可能求值为变量 `x` 的地址，因此 `alias` 和 `x` 可能表示相同的内存位置。对 `x` 的写入是一个可观察事件，即使写入的值与已存储在 `x` 处的值相同，也绝不能被消除。编译器的优化器包含死存储消除 (Dead Store Elimination, DSE)，它会移除被证明是冗余的存储操作，但后端提供了一种特殊的“必须存储”(must-store)操作来强制进行一次可观察的写操作。\n\n给定以下目标级指令形式及其代价，其中所有代价都是按每条执行的指令计算的非负整数：\n- 加载 (Load): `LD rt, [rp]` 将内存地址 `rp` 处的字读入寄存器 `rt`；代价为 $3$。\n- 强制存储 (Mandatory store): `ST! [rx], rt` 将寄存器 `rt` 中的字写入内存地址 `rx`，且该操作不能被死存储消除移除；代价为 $4$。\n- 寄存器移动 (Register move): `MOV rd, rs` 将寄存器 `rs` 的内容复制到寄存器 `rd`；代价为 $1$。\n\n不存在内存到内存的移动操作。翻译前的初始寄存器分配为：`rx` 持有 `x` 的地址，`rp` 持有 `alias` 的运行时值（一个地址），并且有一个可用的暂存寄存器 `rt`。不允许使用其他寄存器或指令。除了 `ST!` 之外的任何存储操作，如果被证明是冗余的，都可能被死存储消除移除，并且这种移除不得改变可观察行为。\n\n仅使用这些指令，翻译 `x := *alias`，以满足以下条件：\n- 在所有运行时情况下，包括当 `rp` 和 `rx` 持有相等地址时，可观察语义都得以保留。\n- 翻译过程在执行写操作之前对右侧进行求值，这与赋值语义一致。\n- 对 `x` 的写入保持可观察性，且不被死存储消除。\n\n在满足这些约束的条件下，确定执行一次此赋值操作的最小总动态代价，表示为所执行指令的代价之和。请以单个整数形式提供答案；无需四舍五入。",
            "solution": "已根据指定的验证标准对问题陈述进行了分析。\n\n### 第1步：提取已知条件\n- **赋值语句：** `x := *alias`\n- **操作语义：** 对右侧 (RHS) 求值，然后将得到的值写入左侧 (LHS)。\n- **别名条件：** 指针 `alias` 可能持有 `x` 的地址，这意味着它们各自的地址寄存器 `rp` 和 `rx` 可能包含相同的值。\n- **可观察性约束：** 对 `x` 的写入是一个可观察事件，即使写入的值与已存在的值相同，也绝不能被死存储消除 (DSE) 移除。\n- **初始寄存器状态：**\n    - 寄存器 `rx` 持有 `x` 的地址。\n    - 寄存器 `rp` 持有指针 `alias` 的地址值。\n    - 寄存器 `rt` 是一个通用的暂存寄存器。\n- **指令集和代价：**\n    - `LD rt, [rp]`：从内存地址 `rp` 加载一个字到寄存器 `rt`。代价：$3$。\n    - `ST! [rx], rt`：将寄存器 `rt` 中的字存储到内存地址 `rx`。这是一个强制存储，不能被 DSE 移除。代价：$4$。\n    - `MOV rd, rs`：将寄存器 `rs` 的值复制到寄存器 `rd`。代价：$1$。\n- **目标：** 在遵守所有约束的条件下，确定正确翻译并执行一次该赋值语句的最小总动态代价。结果必须是一个整数。\n\n### 第2步：使用提取的已知条件进行验证\n该问题在编译器构造和计算机体系结构领域内定义明确且具有科学依据。\n- **科学依据：** 加载/存储体系结构、别名分析、死存储消除和可观察的程序行为等概念是编译器理论中的基本和标准概念。\n- **良构性：** 问题提供了明确的目标（最小化代价）、带有明确代价的受约束指令集，以及对初始状态和所需语义的完整描述。通过逻辑推导可以确定唯一的最小代价。\n- **客观性：** 问题使用精确、无歧义的技术术语进行表述。\n\n验证清单中列出的缺陷均不存在。该问题被认为是有效的。\n\n### 第3步：解答\n任务是将高级赋值语句 `x := *alias` 翻译成加载/存储机器的低级指令序列。就给定的寄存器而言，这对应于用内存地址 `rp` 处的值来更新内存地址 `rx` 处的内存位置。\n\n赋值语义规定了一个两阶段过程：\n1.  **对右侧求值：** 必须首先对右侧的表达式 `*alias` 进行求值。这涉及从 `alias` 指向的内存位置获取值。该地址在寄存器 `rp` 中。唯一能够从内存读取的指令是加载指令 `LD`。我们必须将值加载到一个临时存储位置，即暂存寄存器 `rt`。\n    - 指令：`LD rt, [rp]`\n    - 效果：内存地址 `rp` 处的值被加载到 `rt` 中。\n    - 代价：$3$。\n\n2.  **写入左侧：** 从右侧求值得到的值（现在保存在寄存器 `rt` 中）必须被写入与左侧变量 `x` 对应的内存位置。`x` 的地址在寄存器 `rx` 中。问题陈述强制规定这次写入必须是一个可观察事件，并且不能被优化消除。这明确要求使用强制存储指令 `ST!`。\n    - 指令：`ST! [rx], rt`\n    - 效果：`rt` 中的值被写入内存地址 `rx`。这次写入保证会发生。\n    - 代价：$4$。\n\n按指定顺序组合这两个步骤，得到指令序列：\n1.  `LD rt, [rp]`\n2.  `ST! [rx], rt`\n\n让我们验证这个序列在所有指定条件下是否正确。\n- **正确的语义：** 该序列首先将 `*alias` 的值加载到一个寄存器（`rt`）中，然后将该寄存器的值存储到 `x`。这正确地实现了“先对右侧求值，再写入左侧”的语义。\n- **别名情况下的正确性：** 我们必须考虑 `rp = rx` 的情况。\n    - `LD rt, [rp]` 变为 `LD rt, [rx]`。`x` 的初始值被加载到 `rt` 中。\n    - `ST! [rx], rt` 将 `rt` 中的值存回 `x`。写操作发生，保持了 `x` 的值，但满足了可观察性要求。\n- **可观察性：** 使用 `ST!` 确保了对 `x` 的写入不会被死存储消除优化移除，满足了问题的一个关键约束。\n\n此序列的总动态代价是各个指令代价的总和：\n$$ \\text{总代价} = \\text{代价}(\\text{LD}) + \\text{代价}(\\text{ST!}) = 3 + 4 = 7 $$\n\n我们必须确认这是最小代价。\n- 为了获取 `*alias` 的值，必须从内存加载。唯一的指令是 `LD`，代价为 $3$。\n- 为了更新 `x`，必须向内存存储。为满足可观察性约束，必须使用 `ST!`，代价为 $4$。\n- `MOV` 指令（代价 $1$）在寄存器之间移动数据。由于只有一个暂存寄存器 `rt`，且地址寄存器 `rx` 和 `rp` 必须被保留，直到它们分别被 `ST!` 和 `LD` 指令使用，因此没有机会使用 `MOV` 指令来降低总代价。例如，尝试使用一个地址寄存器作为临时寄存器会导致一个代价更高的序列（代价为 $8$）或破坏必要的信息。\n\n因此，这个两指令序列是满足所有问题约束的可能的最有效序列。最小总动态代价是 $7$。",
            "answer": "$$\\boxed{7}$$"
        }
    ]
}