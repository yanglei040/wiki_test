{
    "hands_on_practices": [
        {
            "introduction": "The first step in correctly translating code is understanding the language's \"rules of the road\"—its evaluation order and how it handles side effects. This practice exercise focuses on the post-increment operator, a common source of subtle bugs, and requires you to act as the compiler's execution engine. By meticulously tracing variable states according to a strict left-to-right evaluation order, you will see how separating a side effect (the increment) from an expression's value is crucial for correctness. This hands-on trace builds the foundational skill of thinking like a compiler, ensuring that generated code respects the precise semantics defined by the source language. ",
            "id": "3622053",
            "problem": "You are designing a code generator for a simple imperative language with integer variables and two constructs: assignment $:=$ and post-increment $++$. The goal is to translate expressions with side effects correctly into three-address code (TAC), while preserving the semantic guarantees of the source language.\n\nCore definitions and guarantees:\n- Each variable denotes a distinct memory location holding an integer. All arithmetic is on mathematical integers and does not overflow.\n- The post-increment $v++$ yields the current value of $v$ and, as a side effect, increments $v$ by $1$. The increment must persist.\n- In any binary expression $E_1 \\circ E_2$ (for any operator $\\circ$), evaluation occurs left-to-right: $E_1$ is fully evaluated (including all side effects), then $E_2$, and then the operator is applied.\n- In an assignment $x := E$, the right-hand side $E$ is fully evaluated (including all side effects) before storing into $x$.\n- Translation pattern for a post-increment occurrence: to evaluate $v++$, produce TAC that splits into a value phase and a writeback phase using a fresh temporary $t$: first $t := v$ (value), then $v := v + 1$ (writeback); the value contributed by the expression $v++$ is $t$.\n\nConsider the following straight-line program fragment, where parentheses indicate explicit grouping and evaluation order is left-to-right at each operator as specified above:\n1. $a := y++$\n2. $b := (y++) + (y++)$\n3. $c := (y++) \\times \\big((y++) - 1\\big) - (y++)$\n4. $y := y++$\n5. $w := a + b + c + y$\n\nAssume the initial state is $y = 3$ and all other variables are uninitialized prior to executing the fragment. Using only the core definitions and the translation pattern above, and ensuring that each $v++$ is handled by splitting into a value phase and a writeback phase with a fresh temporary, determine the final value of $w$ after executing the fragment as correctly translated TAC.\n\nProvide your answer as a single integer. No rounding is required.",
            "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It describes a standard problem in compiler design concerning the translation of expressions with side effects into intermediate code. The rules for evaluation order, side effects of post-increment, and assignment semantics are explicitly and unambiguously defined, allowing for a unique, deterministic trace of program execution. The problem is therefore valid.\n\nThe task is to determine the final value of the variable $w$ by tracing the execution of a sequence of five statements. The trace will be performed step-by-step, adhering strictly to the provided semantic rules. We begin with the initial state where $y=3$ and all other variables are uninitialized. The translation of each post-increment operation $v++$ will use a fresh temporary variable $t_i$ to separate the value retrieval from the side-effect of incrementing $v$.\n\nInitial State: $y=3$.\n\n1.  **Statement 1:** $a := y++$\n    The right-hand side (RHS), $y++$, is evaluated first.\n    *   Value phase: A temporary variable $t_1$ is assigned the current value of $y$. $t_1 := y$, so $t_1$ becomes $3$.\n    *   Writeback phase: The variable $y$ is incremented. $y := y + 1$, so $y$ becomes $3+1=4$.\n    The value of the RHS expression is the value captured in the temporary, which is $3$.\n    Finally, the assignment to $a$ occurs: $a := 3$.\n    **State after statement 1:** $y=4$, $a=3$.\n\n2.  **Statement 2:** $b := (y++) + (y++)$\n    The RHS is a binary addition. According to the rules, the left operand is fully evaluated before the right operand.\n    *   Evaluate the left operand, the first $y++$:\n        *   Value phase: $t_2 := y$. The current value of $y$ is $4$, so $t_2$ becomes $4$.\n        *   Writeback phase: $y := y + 1$. The value of $y$ becomes $4+1=5$.\n        The value of the left operand is $4$.\n    *   Evaluate the right operand, the second $y++$. The side effect from the left operand has already completed.\n        *   Value phase: $t_3 := y$. The current value of $y$ is $5$, so $t_3$ becomes $5$.\n        *   Writeback phase: $y := y + 1$. The value of $y$ becomes $5+1=6$.\n        The value of the right operand is $5$.\n    *   Apply the addition operator: $4 + 5 = 9$.\n    The assignment to $b$ occurs: $b := 9$.\n    **State after statement 2:** $y=6$, $a=3$, $b=9$.\n\n3.  **Statement 3:** $c := (y++) \\times \\big((y++) - 1\\big) - (y++)$\n    The expression is evaluated according to left-to-right precedence for operators of the same level, with parentheses enforced. The structure is $(E_1 \\times E_2) - E_3$.\n    *   First, evaluate the sub-expression $(y++) \\times \\big((y++) - 1\\big)$.\n        *   Evaluate its left operand, the first $y++$:\n            *   Value phase: $t_4 := y$. The current value of $y$ is $6$, so $t_4$ becomes $6$.\n            *   Writeback phase: $y := y + 1$. The value of $y$ becomes $6+1=7$.\n            The value of this operand is $6$.\n        *   Evaluate its right operand, $\\big((y++) - 1\\big)$.\n            *   Evaluate the inner $y++$:\n                *   Value phase: $t_5 := y$. The current value of $y$ is $7$, so $t_5$ becomes $7$.\n                *   Writeback phase: $y := y + 1$. The value of $y$ becomes $7+1=8$.\n                The value of this inner $y++$ is $7$.\n            *   Apply the subtraction: $7 - 1 = 6$. The value of the sub-expression $\\big((y++) - 1\\big)$ is $6$.\n        *   Apply the multiplication operator: $6 \\times 6 = 36$.\n    *   The overall expression is now reduced to $36 - (y++)$.\n        *   Evaluate the right operand, the final $y++$.\n            *   Value phase: $t_6 := y$. The current value of $y$ is $8$, so $t_6$ becomes $8$.\n            *   Writeback phase: $y := y + 1$. The value of $y$ becomes $8+1=9$.\n            The value of this operand is $8$.\n    *   Apply the final subtraction operator: $36 - 8 = 28$.\n    The assignment to $c$ occurs: $c := 28$.\n    **State after statement 3:** $y=9$, $a=3$, $b=9$, $c=28$.\n\n4.  **Statement 4:** $y := y++$\n    This statement is handled by first fully evaluating the RHS and then performing the assignment.\n    *   Evaluate the RHS, $y++$:\n        *   Value phase: $t_7 := y$. The current value of $y$ is $9$, so $t_7$ becomes $9$.\n        *   Writeback phase: $y := y + 1$. The value of $y$ becomes $9+1=10$.\n    *   The value of the RHS expression is $t_7$, which is $9$.\n    *   Finally, the assignment occurs: $y := 9$. This assignment overwrites the value of $y$ that resulted from the writeback phase.\n    **State after statement 4:** $y=9$, $a=3$, $b=9$, $c=28$.\n\n5.  **Statement 5:** $w := a + b + c + y$\n    The RHS expression involves no side effects. We substitute the current values of the variables.\n    *   $a=3$, $b=9$, $c=28$, $y=9$.\n    *   The sum is evaluated: $3 + 9 + 28 + 9 = 12 + 28 + 9 = 40 + 9 = 49$.\n    The assignment to $w$ occurs: $w := 49$.\n    **Final State:** $y=9$, $a=3$, $b=9$, $c=28$, $w=49$.\n\nThe final value of $w$ after the entire fragment has been executed is $49$.",
            "answer": "$$\n\\boxed{49}\n$$"
        },
        {
            "introduction": "While the previous exercise showed what happens when we follow the rules, this problem explores *how* a compiler enforces them. We will analyze a notoriously tricky statement, $a[i++] := a[i]$, where a side effect on an index variable interacts with its use in both the source and destination of an assignment. This practice demonstrates that temporary variables are not just a convenience but an absolute necessity for preserving correctness, serving as safe-havens for intermediate values that would otherwise be corrupted by side effects before they can be used. By determining the minimum number of temporaries required, you will gain a deeper appreciation for data-flow dependencies and the compiler's role in managing data lifetimes. ",
            "id": "3622020",
            "problem": "A compiler for a small imperative source language is being designed to translate assignment statements involving arrays and post-increment operators into a low-level Intermediate Representation (IR). The source language has the following semantics, which are defined and guaranteed by the language specification:\n\n- Expression evaluation order is left-to-right.\n- In an assignment $L := R$, the right-hand side $R$ is fully evaluated, producing a value, before the left-hand side $L$ is evaluated to an address and then assigned the produced value.\n- The post-increment operator $x++$ yields the current value of $x$ and, as a side effect, increases $x$ by $1$ after the operand is evaluated.\n\nThe compiler targets a classical Three-Address Code (TAC), an IR in which each instruction has at most one operator applied to at most two operands and produces at most one result. The following constraints apply to the TAC used here:\n\n- The only stateful memory locations are scalar variables (such as $i$) and arrays (such as $a$); there are no function calls or aliasing between $i$ and $a$.\n- Allowed instruction forms include reading a scalar into a temporary ($t := i$), integer addition on temporaries or scalars ($t := u + c$ or $i := i + c$), array load ($t := \\mathrm{load}(a, t_{\\mathrm{idx}})$), and array store ($\\mathrm{store}(a, t_{\\mathrm{idx}}, t_{\\mathrm{val}})$). Each temporary is written at most once (single assignment for temporaries), and side effects such as $i := i + 1$ must appear exactly once if induced by a source operator.\n- The generated TAC must preserve the specified source-level order of evaluation and the single occurrence of the side effect implied by $i++$; the compiler must not introduce spurious increments or reorder evaluation across side effects.\n\nConsider lowering the single source statement $a[i++] := a[i]$ under the above semantics and TAC constraints. Let $\\tau$ denote the minimal number of distinct temporary variables that must be introduced in the TAC to ensure semantic correctness, including preservation of the defined order of evaluation and avoidance of any double-increment or reordering bugs.\n\nDetermine the minimal $\\tau$. Express your answer as a single integer. No rounding is required, and no units are involved.",
            "solution": "The problem requires determining the minimal number of temporary variables, $\\tau$, needed to correctly translate the source statement $a[i++] := a[i]$ into a specific Three-Address Code (TAC), while adhering to the language's defined semantics.\n\nFirst, let us formalize the semantics and constraints provided.\n1.  **Assignment Semantics ($L := R$)**: The right-hand side, $R$, is fully evaluated to produce a value. Then, the left-hand side, $L$, is evaluated to determine a memory address. Finally, the value from $R$ is stored at the address from $L$.\n2.  **Post-Increment Semantics ($x++$)**: The expression yields the current value of the variable $x$. As a side effect, $x$ is incremented by $1$ after its value has been obtained.\n3.  **TAC Instruction Forms**: The translation must use a restricted set of instructions, including $t := i$, $t := u + c$, $i := i+c$, $t := \\mathrm{load}(a, t_{\\mathrm{idx}})$, and $\\mathrm{store}(a, t_{\\mathrm{idx}}, t_{\\mathrm{val}})$. A critical constraint derived from these forms is that the operands for array indexing ($t_{\\mathrm{idx}}$) and the value being stored ($t_{\\mathrm{val}}$) must be held in temporary variables (denoted by $t$, $u$, $t_{\\mathrm{idx}}$, $t_{\\mathrm{val}}$).\n\nLet us apply these rules to translate the statement $a[i++] := a[i]$. Let $i_0$ denote the value of the variable $i$ at the beginning of the statement's execution.\n\n**Step 1: Evaluation of the Right-Hand Side (RHS)**\nThe RHS is the expression $a[i]$. According to the assignment semantics, this is evaluated first.\n- To evaluate $a[i]$, the compiler must first determine the index, which is the current value of $i$, i.e., $i_0$.\n- The TAC instruction for loading from an array is $t := \\mathrm{load}(a, t_{\\mathrm{idx}})$, which requires the index to be in a temporary variable. Therefore, we must first copy the value of $i$ into a temporary. Let's call this temporary $t_1$.\n  $$t_1 := i$$\n  After this instruction, $t_1$ holds the value $i_0$.\n- Now, we can load the value from the array. The result of the load must be stored in a temporary variable. Let's call this $t_2$.\n  $$t_2 := \\mathrm{load}(a, t_1)$$\n  After this instruction, $t_2$ holds the value of $a[i_0]$.\nAt this point, the RHS evaluation is complete. The resulting value to be assigned is now stored in $t_2$.\n\n**Step 2: Evaluation of the Left-Hand Side (LHS)**\nThe LHS is the expression $a[i++]$, which must be evaluated to produce an address. This evaluation happens after the RHS is fully evaluated.\n- The index of the array access is determined by the expression $i++$.\n- The post-increment operator yields the current value of $i$, which is still $i_0$ (since the side effect has not yet occurred). This value, $i_0$, which we need for the final `store` operation, is already conveniently stored in our temporary variable $t_1$.\n- After the value $i_0$ is obtained for the index, the side effect of the post-increment operator must be executed. This consists of incrementing the variable $i$.\n  $$i := i + 1$$\n  The variable $i$ now holds the value $i_0 + 1$. The evaluation of the LHS is now complete. The target address is specified by the array $a$ and the index $i_0$, which is held in $t_1$.\n\n**Step 3: Performing the Assignment**\nThe final step is to store the value obtained from the RHS into the address determined by the LHS.\n- The TAC instruction for this is $\\mathrm{store}(a, t_{\\mathrm{idx}}, t_{\\mathrm{val}})$. This instruction form requires both the index and the value to be in temporary variables.\n- The index is $i_0$, which is held in $t_1$.\n- The value to be stored is $a[i_0]$, which is held in $t_2$.\n- Thus, the final instruction is:\n  $$\\mathrm{store}(a, t_1, t_2)$$\n\n**Complete TAC Sequence and Minimality Analysis**\nThe complete, correctly ordered sequence of TAC instructions is:\n$1$. $t_1 := i$\n$2$. $t_2 := \\mathrm{load}(a, t_1)$\n$3$. $i := i + 1$\n$4$. $\\mathrm{store}(a, t_1, t_2)$\n\nThis sequence uses two distinct temporary variables, $t_1$ and $t_2$. This demonstrates that a correct translation is possible with $\\tau = 2$.\n\nTo determine if this is the minimal number, we analyze the data dependencies and lifetimes.\n1.  The value of the index for the `store` operation, $i_0$, must be available at Step $4$. However, the variable $i$ is modified at Step $3$. Therefore, the value $i_0$ must be saved in a location separate from $i$ before the increment occurs. As the compiler can only introduce temporaries for this purpose, at least one temporary is required to hold the index.\n2.  The value loaded from the RHS, $a[i_0]$, must also be available at Step $4$. The TAC instruction $t := \\mathrm{load}(...)$ requires the result to be placed in a temporary.\n3.  The crucial point is that for the final $\\mathrm{store}(a, t_1, t_2)$ instruction, both the index value ($i_0$) and the source value ($a[i_0]$) must be simultaneously available in temporary variables. An attempt to use a single temporary, say $t$, would fail:\n    - $t := i$ (Now $t$ holds the index $i_0$)\n    - $t := \\mathrm{load}(a, t)$ (Now $t$ holds the value $a[i_0]$, but the index $i_0$ that was in $t$ is overwritten and lost).\n    Since the index is needed for the final `store` instruction, and it was overwritten, this sequence is incorrect.\n4.  The lifetimes of the index value $i_0$ and the loaded value $a[i_0]$ overlap. They are both needed for the final `store` instruction. Since the TAC forms require both of these quantities to reside in temporaries at the time of the `store`, they must occupy two distinct temporary variables.\n\nTherefore, the minimal number of temporary variables required is $\\tau=2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Once correctness is guaranteed, a compiler's next goal is to generate efficient code. This exercise moves from correctness to optimization, focusing on a chained assignment statement, $a := b := c := d$, that involves a large, complex expression. Here, we explore how to translate the statement while evaluating the complex right-hand side only once and minimizing the peak number of temporaries, which correspond to registers in a real machine. This problem connects high-level language features like right-associative assignment to low-level optimization strategies, providing insight into how compilers produce code that is not just correct, but also performant. ",
            "id": "3622043",
            "problem": "Consider a deterministic imperative language with expression-valued assignment where the operator $:=$ is right-associative and the expression $x := y$ evaluates $y$ once, assigns that value to $x$, and yields that assigned value as its result. All variables $a$, $b$, $c$, $d$, $w$, $x$, $y$, $z$, $p$, $q$, $r$, and $s$ denote distinct memory-resident scalar locations, and all primitive arithmetic operators $+$, $-$, and $\\times$ are pure (no side effects) and strict in both operands. The intermediate representation uses three-address code with the following constraints:\n\n- Each primitive binary operation must have its operands in temporaries and produces its result in a temporary. Memory-to-memory operations are disallowed.\n- A load from a variable $v$ into a temporary is written as $t := v$.\n- A store from a temporary $t$ to a variable $v$ is written as $v := t$.\n- A store $v := t$ does not clobber $t$; the temporary $t$ remains available afterward.\n- Temporaries may be reused when they are no longer live; the cost we measure is the peak number of simultaneously live temporaries during the translation.\n\nLet the chained assignment be $a := b := c := d$ with the right-associative parse $a := (b := (c := d))$, and let the expression $d$ be\n$$\nd \\;=\\; \\big((w + x) \\times (y + z)\\big) \\;+\\; \\big((p - q) \\times (r - s)\\big).\n$$\n\nTranslate $a := b := c := d$ into the above three-address code so that $d$ is evaluated exactly once and the peak number of simultaneously live temporaries is minimized. Under these rules and assumptions, determine the minimal peak number of simultaneously live temporaries required. Provide your final answer as a single integer. No rounding is needed.",
            "solution": "The fundamental base for this derivation is the operational semantics of expression-valued, right-associative assignment and the purity of primitive arithmetic operators. Right-associativity dictates the parse $a := (b := (c := d))$, so the execution must:\n\n1. Evaluate $d$ to a single value,\n2. Assign that value to $c$,\n3. Use the resulting value of $c := d$ as the value for $b := (\\cdot)$, which assigns the same value to $b$,\n4. Use the resulting value of $b := (\\cdot)$ as the value for $a := (\\cdot)$, which assigns the same value to $a$.\n\nBecause a store $v := t$ does not destroy $t$, once we have computed the value of $d$ into some temporary, we can perform $c := t$, then $b := t$, then $a := t$ without increasing the peak count of simultaneously live temporaries beyond what is required to compute $d$ itself. Therefore, the minimal peak number of simultaneously live temporaries for the entire chained assignment equals the minimal peak required to evaluate $d$ once.\n\nWe now focus on minimizing the peak number of live temporaries during the evaluation of\n$$\nd \\;=\\; \\big((w + x) \\times (y + z)\\big) \\;+\\; \\big((p - q) \\times (r - s)\\big).\n$$\nThe expression $d$ is a full binary tree with leaves $w$, $x$, $y$, $z$, $p$, $q$, $r$, $s$. Each leaf load $t := v$ requires a temporary to hold the value. For a binary operator node with left subtree requiring $L$ simultaneously live temporaries and right subtree requiring $R$, the minimal peak depends on evaluation order. A classical, well-tested fact from code generation for expression trees (the Sethi–Ullman labeling) states that the minimal number of simultaneously live temporaries is given by labeling leaves with $1$, and for each binary node, if its children have labels $\\ell$ and $r$, then the node's label is $\\max(\\ell, r)$ if $\\ell \\neq r$, and $\\ell + 1$ if $\\ell = r$. This yields the minimal peak under optimal evaluation order.\n\nCompute labels bottom-up:\n\n- Leaves $w$, $x$, $y$, $z$, $p$, $q$, $r$, $s$ each have label $1$.\n- Nodes $(w + x)$ and $(y + z)$ each have equal children $1$ and $1$, so their labels are $1 + 1 = 2$.\n- The node $(w + x) \\times (y + z)$ has children both labeled $2$, equal, so its label is $2 + 1 = 3$.\n- Similarly, nodes $(p - q)$ and $(r - s)$ each have label $2$, and $(p - q) \\times (r - s)$ has label $2 + 1 = 3$.\n- The root addition combines two children each labeled $3$, equal, so the root label is $3 + 1 = 4$.\n\nTherefore, the minimal peak number of simultaneously live temporaries needed to evaluate $d$ once is $4$. After $d$ is computed into a temporary, say $t$, the chained assignment requires only stores $c := t$, $b := t$, and $a := t$, which do not increase the peak beyond $4$ because $t$ persists and no additional temporaries need to be live concurrently.\n\nHence, the minimal peak number of simultaneously live temporaries for translating $a := b := c := d$ under the stated constraints is $4$.",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}