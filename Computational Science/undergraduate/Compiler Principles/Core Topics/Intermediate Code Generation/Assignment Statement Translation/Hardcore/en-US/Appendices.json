{
    "hands_on_practices": [
        {
            "introduction": "Translating statements with side effects, such as the post-increment operator ($v++$), is a fundamental task for any compiler. The key challenge lies in correctly ordering the \"value\" part of the expression (what it contributes to the larger calculation) and the \"side effect\" part (the increment itself). This exercise challenges you to trace the execution of a series of assignments involving post-increments, carefully applying the rules of left-to-right evaluation to understand how variable states evolve, which is a crucial drill for building the meticulous mindset required for code generation. ",
            "id": "3622053",
            "problem": "You are designing a code generator for a simple imperative language with integer variables and two constructs: assignment $:=$ and post-increment $++$. The goal is to translate expressions with side effects correctly into three-address code (TAC), while preserving the semantic guarantees of the source language.\n\nCore definitions and guarantees:\n- Each variable denotes a distinct memory location holding an integer. All arithmetic is on mathematical integers and does not overflow.\n- The post-increment $v++$ yields the current value of $v$ and, as a side effect, increments $v$ by $1$. The increment must persist.\n- In any binary expression $E_1 \\circ E_2$ (for any operator $\\circ$), evaluation occurs left-to-right: $E_1$ is fully evaluated (including all side effects), then $E_2$, and then the operator is applied.\n- In an assignment $x := E$, the right-hand side $E$ is fully evaluated (including all side effects) before storing into $x$.\n- Translation pattern for a post-increment occurrence: to evaluate $v++$, produce TAC that splits into a value phase and a writeback phase using a fresh temporary $t$: first $t := v$ (value), then $v := v + 1$ (writeback); the value contributed by the expression $v++$ is $t$.\n\nConsider the following straight-line program fragment, where parentheses indicate explicit grouping and evaluation order is left-to-right at each operator as specified above:\n1. $a := y++$\n2. $b := (y++) + (y++)$\n3. $c := (y++) \\times \\big((y++) - 1\\big) - (y++)$\n4. $y := y++$\n5. $w := a + b + c + y$\n\nAssume the initial state is $y = 3$ and all other variables are uninitialized prior to executing the fragment. Using only the core definitions and the translation pattern above, and ensuring that each $v++$ is handled by splitting into a value phase and a writeback phase with a fresh temporary, determine the final value of $w$ after executing the fragment as correctly translated TAC.\n\nProvide your answer as a single integer. No rounding is required.",
            "solution": "To determine the final value of $w$, we trace the execution of the five statements step-by-step, applying the given semantic rules. We start with the initial state $y = 3$. Each post-increment operation, $v++$, is split into a value phase (capturing the current value in a temporary) and a writeback phase (incrementing $v$).\n\n**Initial State:** $y=3$.\n\n1.  **Statement 1:** $a := y++$\n    The right-hand side (RHS), $y++$, is evaluated first.\n    *   Value phase: A temporary variable $t_1$ is assigned the current value of $y$. $t_1 := y$, so $t_1$ becomes $3$.\n    *   Writeback phase: The variable $y$ is incremented. $y := y + 1$, so $y$ becomes $3+1=4$.\n    The value of the RHS expression is $3$.\n    Finally, the assignment to $a$ occurs: $a := 3$.\n    **State after statement 1:** $y=4$, $a=3$.\n\n2.  **Statement 2:** $b := (y++) + (y++)$\n    The RHS is a binary addition. The left operand is fully evaluated before the right operand.\n    *   Evaluate the left operand, the first $y++$:\n        *   Value phase: $t_2 := y$. The current value of $y$ is $4$, so $t_2$ becomes $4$.\n        *   Writeback phase: $y := y + 1$. The value of $y$ becomes $4+1=5$.\n        The value of the left operand is $4$.\n    *   Evaluate the right operand, the second $y++$:\n        *   Value phase: $t_3 := y$. The current value of $y$ is $5$, so $t_3$ becomes $5$.\n        *   Writeback phase: $y := y + 1$. The value of $y$ becomes $5+1=6$.\n        The value of the right operand is $5$.\n    *   Apply the addition operator: $4 + 5 = 9$.\n    The assignment to $b$ occurs: $b := 9$.\n    **State after statement 2:** $y=6$, $a=3$, $b=9$.\n\n3.  **Statement 3:** $c := (y++) \\times \\big((y++) - 1\\big) - (y++)$\n    The expression is evaluated left-to-right: $(E_1 \\times E_2) - E_3$.\n    *   First, evaluate $(y++) \\times \\big((y++) - 1\\big)$.\n        *   Evaluate its left operand, the first $y++$:\n            *   Value phase: $t_4 := y$. The current value of $y$ is $6$, so $t_4$ becomes $6$.\n            *   Writeback phase: $y := y + 1$. The value of $y$ becomes $7$.\n            The value of this operand is $6$.\n        *   Evaluate its right operand, $\\big((y++) - 1\\big)$.\n            *   Evaluate the inner $y++$:\n                *   Value phase: $t_5 := y$. The current value of $y$ is $7$, so $t_5$ becomes $7$.\n                *   Writeback phase: $y := y + 1$. The value of $y$ becomes $8$.\n                The value of this inner $y++$ is $7$.\n            *   Apply the subtraction: $7 - 1 = 6$.\n        *   Apply the multiplication operator: $6 \\times 6 = 36$.\n    *   The overall expression is now reduced to $36 - (y++)$.\n        *   Evaluate the right operand, the final $y++$.\n            *   Value phase: $t_6 := y$. The current value of $y$ is $8$, so $t_6$ becomes $8$.\n            *   Writeback phase: $y := y + 1$. The value of $y$ becomes $9$.\n            The value of this operand is $8$.\n    *   Apply the final subtraction operator: $36 - 8 = 28$.\n    The assignment to $c$ occurs: $c := 28$.\n    **State after statement 3:** $y=9$, $a=3$, $b=9$, $c=28$.\n\n4.  **Statement 4:** $y := y++$\n    This statement is handled by first fully evaluating the RHS and then performing the assignment.\n    *   Evaluate the RHS, $y++$:\n        *   Value phase: $t_7 := y$. The current value of $y$ is $9$, so $t_7$ becomes $9$.\n        *   Writeback phase: $y := y + 1$. The value of $y$ becomes $10$.\n    *   The value of the RHS expression is $t_7$, which is $9$.\n    *   Finally, the assignment occurs: $y := 9$. This assignment overwrites the value of $y$ that resulted from the writeback phase.\n    **State after statement 4:** $y=9$, $a=3$, $b=9$, $c=28$.\n\n5.  **Statement 5:** $w := a + b + c + y$\n    The RHS expression involves no side effects. We substitute the current values of the variables.\n    *   $a=3$, $b=9$, $c=28$, $y=9$.\n    *   The sum is evaluated: $3 + 9 + 28 + 9 = 12 + 28 + 9 = 40 + 9 = 49$.\n    The assignment to $w$ occurs: $w := 49$.\n    **Final State:** $y=9$, $a=3$, $b=9$, $c=28$, $w=49$.\n\nThe final value of $w$ after the entire fragment has been executed is $49$.",
            "answer": "$$\n\\boxed{49}\n$$"
        },
        {
            "introduction": "The order of evaluation can lead to subtle but critical bugs if not handled correctly. A classic example is an assignment involving array access where an index variable is also modified, as in the hypothetical statement `a[i++] := a[i]`. This practice problem forces you to dissect a specific, defined rule for a hypothetical language: the right-hand side is fully evaluated *before* the left-hand side's address is computed. Mastering this requires careful use of temporary variables to snapshot values at the correct moment, a core skill in generating correct intermediate code. ",
            "id": "3622020",
            "problem": "A compiler for a small imperative source language is being designed to translate assignment statements involving arrays and post-increment operators into a low-level Intermediate Representation (IR). The source language has the following semantics, which are defined and guaranteed by the language specification:\n\n- Expression evaluation order is left-to-right.\n- In an assignment $L := R$, the right-hand side $R$ is fully evaluated, producing a value, before the left-hand side $L$ is evaluated to an address and then assigned the produced value.\n- The post-increment operator $x++$ yields the current value of $x$ and, as a side effect, increases $x$ by $1$ after the operand is evaluated.\n\nThe compiler targets a classical Three-Address Code (TAC), an IR where each instruction has at most one operator applied to at most two operands and produces at most one result. The following constraints apply to the TAC used here:\n\n- The only stateful memory locations are scalar variables (such as $i$) and arrays (such as $a$); there are no function calls or aliasing between $i$ and $a$.\n- Allowed instruction forms include reading a scalar into a temporary ($t := i$), integer addition on temporaries or scalars ($t := u + c$ or $i := i + c$), array load ($t := \\mathrm{load}(a, t_{\\mathrm{idx}})$), and array store ($\\mathrm{store}(a, t_{\\mathrm{idx}}, t_{\\mathrm{val}})$). Each temporary is written at most once (single assignment for temporaries), and side effects such as $i := i + 1$ must appear exactly once if induced by a source operator.\n- The generated TAC must preserve the specified source-level order of evaluation and the single occurrence of the side effect implied by $i++$; the compiler must not introduce spurious increments or reorder evaluation across side effects.\n\nConsider lowering the single source statement `a[i++] := a[i]` under the above semantics and TAC constraints. Let $\\tau$ denote the minimal number of distinct temporary variables that must be introduced in the TAC to ensure semantic correctness, including preservation of the defined order of evaluation and avoidance of any double-increment or reordering bugs.\n\nDetermine the minimal $\\tau$. Express your answer as a single integer. No rounding is required, and no units are involved.",
            "solution": "The problem requires determining the minimal number of temporary variables, $\\tau$, needed to correctly translate the source statement `a[i++] := a[i]` into Three-Address Code (TAC) while adhering to the language's defined semantics.\n\nLet us apply the rules to translate the statement $a[i++] := a[i]$. Let $i_0$ denote the value of the variable $i$ at the beginning of the statement's execution.\n\n**Step 1: Evaluation of the Right-Hand Side (RHS)**\nThe RHS is the expression $a[i]$. According to the assignment semantics, this is evaluated first.\n- To evaluate $a[i]$, the compiler must first determine the index, which is the current value of $i$, i.e., $i_0$.\n- The TAC requires the array index to be in a temporary variable. Therefore, we must first copy the value of $i$ into a temporary, $t_1$.\n  $$t_1 := i$$\n- Now, we can load the value from the array into another temporary, $t_2$.\n  $$t_2 := \\mathrm{load}(a, t_1)$$\nAt this point, the RHS evaluation is complete. The resulting value to be assigned is now stored in $t_2$.\n\n**Step 2: Evaluation of the Left-Hand Side (LHS)**\nThe LHS is the expression $a[i++]$, which must be evaluated to produce an address. This evaluation happens after the RHS is fully evaluated.\n- The index of the array access is determined by the expression $i++$.\n- The post-increment operator yields the current value of $i$, which is still $i_0$ (since the side effect has not yet occurred). This value is already stored in our temporary variable $t_1$.\n- After the value $i_0$ is obtained for the index, the side effect of the post-increment operator must be executed. This consists of incrementing the variable $i$.\n  $$i := i + 1$$\nThe variable $i$ now holds the value $i_0 + 1$. The evaluation of the LHS is now complete. The target address is specified by the array $a$ and the index $i_0$, which is held in $t_1$.\n\n**Step 3: Performing the Assignment**\nThe final step is to store the value obtained from the RHS into the address determined by the LHS. The TAC instruction for this is $\\mathrm{store}(a, t_{\\mathrm{idx}}, t_{\\mathrm{val}})$, which requires both the index and the value to be in temporary variables.\n- The index is $i_0$, which is held in $t_1$.\n- The value to be stored is $a[i_0]$, which is held in $t_2$.\n- Thus, the final instruction is:\n  $$\\mathrm{store}(a, t_1, t_2)$$\n\n**Complete TAC Sequence and Minimality Analysis**\nThe complete, correctly ordered sequence of TAC instructions is:\n1.  $t_1 := i$\n2.  $t_2 := \\mathrm{load}(a, t_1)$\n3.  $i := i + 1$\n4.  $\\mathrm{store}(a, t_1, t_2)$\n\nThis sequence uses two distinct temporary variables, $t_1$ and $t_2$, so a correct translation is possible with $\\tau = 2$.\n\nTo determine if this is minimal, we analyze the data dependencies.\n1.  The index value $i_0$ must be saved before $i$ is incremented at step 3, because this same index $i_0$ is needed for the `store` at step 4. This requires at least one temporary variable ($t_1$).\n2.  The value loaded from the array, $a[i_0]$, must be held in a register until the `store` at step 4. The TAC format requires this to be a temporary ($t_2$).\n3.  The lifetimes of the index value ($i_0$ in $t_1$) and the loaded value ($a[i_0]$ in $t_2$) overlap. Both are needed for the final `store` instruction. They cannot be held in the same temporary variable, because loading the value into the temporary would overwrite the index.\n\nTherefore, two distinct temporary variables are necessary. The minimal number required is $\\tau=2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "A truly robust compiler must be \"defensive\"—it must generate correct code even in the presence of tricky situations like pointer aliasing. This exercise explores the interaction between assignment translation and an optimizer like Dead Store Elimination (DSE). When translating `x := *alias`, you must consider the possibility that `alias` points to `x` itself, making the assignment a self-write that might be semantically important and must not be optimized away. This practice will guide you in generating a low-level instruction sequence that is both correct and respects the observable behavior of the program, even under worst-case aliasing. ",
            "id": "3621961",
            "problem": "A compiler backend must translate the high-level assignment statement $x := *\\mathrm{alias}$ into a low-level instruction sequence for a load/store machine while preserving observable semantics under possible aliasing. The program state consists of a sequentially consistent memory and registers. The operational semantics of assignment stipulate that the right-hand side expression is evaluated to a value, then that value is written to the left-hand side variable. The pointer variable $\\mathrm{alias}$ may evaluate at run time to the address $\\&x$, so that $\\mathrm{alias}$ and $\\&x$ may denote the same memory location. The write to $x$ is an observable event and must not be eliminated even if it writes the same value already stored at $x$. The compiler’s optimizer includes Dead Store Elimination (DSE), which removes a store that is proven redundant, but the backend offers a special “must-store” operation to force an observable write.\n\nYou are given the following target-level instruction forms and their costs, where all costs are nonnegative integers measured per executed instruction:\n- Load: $\\mathrm{LD}\\ r_{t},\\ [r_{p}]$ reads the word at the memory address in $r_{p}$ into register $r_{t}$; cost $3$.\n- Mandatory store: $\\mathrm{ST!}\\ [r_{x}],\\ r_{t}$ writes the word in $r_{t}$ to the memory address in $r_{x}$ and is not removable by Dead Store Elimination; cost $4$.\n- Register move: $\\mathrm{MOV}\\ r_{d},\\ r_{s}$ copies the contents of register $r_{s}$ to register $r_{d}$; cost $1$.\n\nThere is no memory-to-memory move. The initial register assignment before translation is: $r_{x}$ holds $\\&x$, $r_{p}$ holds the run-time value of $\\mathrm{alias}$ (an address), and one scratch register $r_{t}$ is available. No other registers or instructions are permitted. Any store other than $\\mathrm{ST!}$ may be removed by Dead Store Elimination if it is proven redundant, and such removal must not change observable behavior.\n\nUsing only these instructions, translate $x := *\\mathrm{alias}$ so that:\n- The observable semantics are preserved for all run-time cases, including when $r_{p}$ and $r_{x}$ hold equal addresses.\n- The translation evaluates the right-hand side before performing the write, consistent with the assignment semantics.\n- The write to $x$ remains observable and is not eliminated by Dead Store Elimination.\n\nSubject to these constraints, determine the minimal total dynamic cost to perform this assignment once, expressed as the sum of the costs of the executed instructions. Provide your answer as a single integer; no rounding is required.",
            "solution": "To translate the assignment $x := *\\mathrm{alias}$ correctly, we must follow the specified two-phase semantics: first evaluate the right-hand side (RHS), then write to the left-hand side (LHS). The translation must remain correct even if $\\mathrm{alias}$ points to $x$.\n\n1.  **Evaluate RHS**: The RHS is $*\\mathrm{alias}$. We must load the value from the memory address held in register $r_p$. This value is stored in the scratch register $r_t$.\n    *   Instruction: $\\mathrm{LD}\\ r_{t},\\ [r_{p}]$\n    *   Cost: 3\n\n2.  **Write to LHS**: The value now in $r_t$ must be stored at the address of $x$, which is in register $r_x$. The problem requires this write to be observable and not subject to Dead Store Elimination (DSE). Therefore, we must use the mandatory store instruction.\n    *   Instruction: $\\mathrm{ST!}\\ [r_{x}],\\ r_{t}$\n    *   Cost: 4\n\nThe resulting instruction sequence is:\n1.  $\\mathrm{LD}\\ r_{t},\\ [r_{p}]$\n2.  $\\mathrm{ST!}\\ [r_{x}],\\ r_{t}$\n\nThis sequence is minimal because both a load and a store are necessary, and these are the only instructions available for those operations. The use of $\\mathrm{ST!}$ is mandated by the observability constraint. This sequence correctly handles all cases, including aliasing (when $r_p = r_x$), by first loading the value from the source address and then performing the mandatory store to the destination address.\n\nThe minimal total dynamic cost is the sum of the costs of these two instructions:\n$$ \\text{Total Cost} = 3 + 4 = 7 $$",
            "answer": "$$\\boxed{7}$$"
        }
    ]
}