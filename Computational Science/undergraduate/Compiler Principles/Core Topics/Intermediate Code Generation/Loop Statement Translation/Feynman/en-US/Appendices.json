{
    "hands_on_practices": [
        {
            "introduction": "This first practice serves as a bridge between a loop's high-level logic and its concrete mathematical behavior. By analyzing a `while` loop with a constant stride, you will determine the exact number of iterations and compute a final value accumulated within the loop body. This exercise reinforces the fundamentals of how a compiler must reason about arithmetic progressions to understand and optimize loops.",
            "id": "3653514",
            "problem": "Consider a structured loop in an imperative intermediate representation over mathematical integers, with variables initialized as follows: $i \\leftarrow a$, $s \\leftarrow 0$, where $a$, $n$, and $d$ are integers satisfying $0 \\le a \\le n$, $d \\ge 1$, and $d$ divides $(n - a)$. The loop has the high-level form: while the predicate $i \\le n$ holds, execute a loop body that performs the update $s \\leftarrow s + (2i + 1)$ and then advances the loop variable by $i \\leftarrow i + d$. You must lower this loop into the canonical single-entry single-exit loop form with a preheader, a header that tests the predicate $i \\le n$, a body that computes the loop’s payload, and a latch that updates $i$ and branches back to the header in a Control Flow Graph (CFG). The lowering must preserve semantics so that the last iteration executes when $i = n$ if and only if $i$ reaches $n$ under the stated divisibility condition.\n\nStarting only from the fundamental operational semantics of loops (namely: a while-loop evaluates its predicate at the header; if true, it executes the body and loops; if false, it exits) and standard canonical loop structure in a CFG (header test, body, and latch with backedge), derive the exact dynamic sequence of values taken by $i$, the resulting number of body executions as a function of $a$, $n$, and $d$, and then compute the closed-form expression for the final value of $s$ at loop exit. Assume unbounded-precision arithmetic and no integer overflow.\n\nProvide your final answer as a single closed-form analytic expression in terms of $a$, $n$, and $d$. No derivations are to be included in the final answer. No rounding is required.",
            "solution": "The user wants me to analyze a specific loop and derive a closed-form expression for the final value of a variable.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   **Initial variable values**: $i \\leftarrow a$, $s \\leftarrow 0$.\n-   **Loop predicate**: $i \\le n$.\n-   **Loop body update**: $s \\leftarrow s + (2i + 1)$.\n-   **Loop variable update (latch)**: $i \\leftarrow i + d$.\n-   **Constraints on parameters**: $a$, $n$, and $d$ are integers. $0 \\le a \\le n$. $d \\ge 1$. $d$ divides $(n - a)$, which can be written as $(n-a) \\equiv 0 \\pmod{d}$.\n-   **Termination condition**: The last iteration executes when $i = n$.\n-   **Arithmetic model**: Unbounded-precision arithmetic.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded**: The problem is grounded in the principles of compiler design (loop analysis, intermediate representation, control flow graphs) and discrete mathematics (arithmetic progressions, summation). All concepts are well-established and formal.\n-   **Well-Posed**: The problem is well-posed. The givens are sufficient and consistent. The constraints, particularly that $d$ divides $(n - a)$, ensure that the loop counter $i$ will exactly reach the value $n$, leading to a well-defined number of iterations. A unique, stable, and meaningful solution exists.\n-   **Objective**: The problem is stated in precise, objective mathematical and computational language. There are no subjective or ambiguous terms.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a well-defined mathematical problem in the context of computer science. I will proceed with the derivation of the solution.\n\n### Derivation of the Solution\n\nThe problem describes a `while` loop. In a canonical Control Flow Graph (CFG) representation, this structure consists of a preheader for initialization, a header for the conditional test, a body for the main computation, and a latch for updating the loop counter and branching back to the header.\n\n1.  **Analyze the sequence of the loop counter `i`**:\n    The loop counter $i$ is initialized to $a$. In each iteration, it is incremented by $d$. Therefore, the sequence of values taken by $i$ at the beginning of each iteration (at the header test) forms an arithmetic progression:\n    $$ a, a+d, a+2d, a+3d, \\dots $$\n\n2.  **Determine the number of loop iterations**:\n    The loop executes as long as the predicate $i \\le n$ is true. The problem states that $d$ divides $(n-a)$. This implies that there exists an integer $m$ such that $n - a = m d$. Since $n \\ge a$ and $d \\ge 1$, we have $m \\ge 0$.\n    The sequence of values for $i$ is $a+0d, a+1d, a+2d, \\dots, a+md$. The last value in this sequence is $a+md = a+(n-a) = n$.\n    The loop body will execute for each of these values since each value $a+kd$ for $k \\in \\{0, 1, \\dots, m\\}$ satisfies $a+kd \\le a+md = n$.\n    The sequence of values of $i$ for which the body executes is $a, a+d, \\ldots, n$.\n    To find the number of iterations, let's count the number of terms in this sequence. The terms can be indexed by $k \\in \\{0, 1, \\dots, m\\}$. The total number of terms is $(m - 0) + 1 = m+1$.\n    Let $N_{iter}$ be the number of iterations.\n    $$ N_{iter} = m+1 $$\n    Substituting $m = \\frac{n-a}{d}$:\n    $$ N_{iter} = \\frac{n-a}{d} + 1 = \\frac{n-a+d}{d} $$\n\n3.  **Compute the final value of `s`**:\n    The variable $s$ is initialized to $0$. In each iteration, the value $(2i+1)$ is added to $s$. The final value of $s$ is the sum of $(2i+1)$ over all values of $i$ for which the loop body executes.\n    $$ s_{final} = \\sum_{k=0}^{m} \\left( 2(a+kd) + 1 \\right) $$\n    The terms being added to $s$ form an arithmetic series. Let's identify the first term, the last term, and the number of terms.\n    -   **Number of terms**: $N = N_{iter} = m+1 = \\frac{n-a+d}{d}$.\n    -   **First term (for $k=0$)**: $T_1 = 2(a+0 \\cdot d) + 1 = 2a+1$.\n    -   **Last term (for $k=m$)**: $T_N = 2(a+m \\cdot d) + 1$. Since $a+md = n$, this is $T_N = 2n+1$.\n\n    The sum of an arithmetic series is given by the formula $S_N = \\frac{N}{2}(\\text{first term} + \\text{last term})$.\n    Applying this formula to find $s_{final}$:\n    $$ s_{final} = \\frac{N_{iter}}{2} (T_1 + T_N) $$\n    Substituting the expressions for $N_{iter}$, $T_1$, and $T_N$:\n    $$ s_{final} = \\frac{1}{2} \\left( \\frac{n-a+d}{d} \\right) \\left( (2a+1) + (2n+1) \\right) $$\n    Now, we simplify the expression:\n    $$ s_{final} = \\frac{1}{2} \\left( \\frac{n-a+d}{d} \\right) (2a + 2n + 2) $$\n    $$ s_{final} = \\frac{1}{2} \\left( \\frac{n-a+d}{d} \\right) \\cdot 2(a+n+1) $$\n    $$ s_{final} = \\left( \\frac{n-a+d}{d} \\right) (n+a+1) $$\n    This is the final closed-form expression for the value of $s$ upon loop termination.",
            "answer": "$$\\boxed{\\left(\\frac{n-a+d}{d}\\right)(n+a+1)}$$"
        },
        {
            "introduction": "Real-world code is seldom as simple as a single, uninterrupted loop; statements like `break` and `continue` create complex control flow paths. This practice challenges you to translate a nested loop containing these statements into a formal Control Flow Graph (CFG). Mastering this translation is essential for building the foundational data structures upon which all subsequent analyses and optimizations depend.",
            "id": "3653528",
            "problem": "Consider the following high-level program fragment that nests two loops and uses a conditional continue in the outer loop and a conditional break in the inner loop. Let $I$, $J$, and $k$ be fixed integers with $I \\geq 1$, $J \\geq 1$, and $0 \\leq k  J$. The fragment is:\n\nFor $i$ from $0$ to $I-1$:\n- If $i \\bmod 2 = 1$, then continue to the next iteration of the outer loop.\n- For $j$ from $0$ to $J-1$:\n  - If $j = k$, then break out of the inner loop (i.e., proceed as if the inner loop has completed for the current $i$).\n  - Execute a basic statement $S(i,j)$ that has no internal control flow (it neither branches nor calls any procedures).\n\nAssume a conventional compiler translation into Three-Address Code (TAC), in which:\n- Each loop is implemented using a loop-initialization block, a loop-condition test block, a loop-body block, and a loop-increment block, connected via explicit conditional and unconditional jumps.\n- Each conditional test (including loop conditions and the tests for $i \\bmod 2 = 1$ and $j = k$) is placed in its own basic block.\n- Each of the following is placed in its own basic block: loop initializations ($i := 0$, $j := 0$), loop increments ($i := i + 1$, $j := j + 1$), the statement $S(i,j)$, and a unique function exit block.\n- There is exactly one function entry and exactly one function exit, so the Control Flow Graph (CFG) has $1$ connected component.\n\nStarting from the above fragment and assumptions, construct the CFG by identifying the basic blocks and their control-flow edges implied by the conventional TAC translation, including the effects of the $continue$ and $break$ statements. Then, compute the cyclomatic complexity of the resulting CFG using first principles from compiler theory and graph theory.\n\nProvide your final answer as a single integer representing the cyclomatic complexity. No rounding is required, and no units are involved.",
            "solution": "The problem requires the determination of the cyclomatic complexity for a Control Flow Graph (CFG) that is constructed from a given high-level program fragment according to a specific set of compiler translation rules. The analysis will proceed by first validating the problem, then systematically identifying the components of the CFG (its nodes and edges), and finally applying the formal definition of cyclomatic complexity.\n\nThe problem statement is validated as follows:\n1.  **Givens Extraction**: The problem provides a nested loop structure with conditional `continue` and `break` statements. The variables $I$, $J$, and $k$ are defined as fixed integers with constraints $I \\geq 1$, $J \\geq 1$, and $0 \\leq k  J$. Crucially, it specifies a set of precise rules for translating this code into a CFG, including how basic blocks are formed for initializations, conditional tests, increments, and other statements. It also states that the CFG has a single connected component.\n2.  **Validation Check**: The problem is scientifically grounded in compiler theory and graph theory, using standard concepts like basic blocks, CFGs, and cyclomatic complexity. The rules given for constructing the CFG are explicit and unambiguous, making the problem well-posed. The language is objective and formal. The problem is self-contained and does not violate any scientific principles.\n3.  **Verdict**: The problem is deemed valid. A rigorous solution can be derived.\n\nThe solution is derived in three stages: identification of basic blocks, construction of the CFG by defining control flow edges, and calculation of cyclomatic complexity.\n\nFirst, we identify the set of basic blocks, which will serve as the vertices $V$ of our CFG, $G=(V,E)$. Based on the specified rules, each conditional test, initialization, increment, and the statement $S(i,j)$ form their own basic blocks. We also include a unique exit block.\nThe resulting basic blocks are:\n- $B_1$: Outer loop initialization: `$i := 0$`\n- $B_2$: Outer loop conditional test: `$i  I$`\n- $B_3$: `continue` statement conditional test: `$i \\bmod 2 = 1$`\n- $B_4$: Inner loop initialization: `$j := 0$`\n- $B_5$: Inner loop conditional test: `$j  J$`\n- $B_6$: `break` statement conditional test: `$j = k$`\n- $B_7$: The basic statement: `$S(i,j)$`\n- $B_8$: Inner loop increment: `$j := j + 1$`\n- $B_9$: Outer loop increment: `$i := i + 1$`\n- $B_{10}$: The unique function exit block.\n\nThis enumeration gives a total of $N = |V| = 10$ nodes in the CFG.\n\nSecond, we determine the directed edges $E$ that represent the flow of control between these blocks.\n- $B_1 \\to B_2$: After initializing `$i$`, the outer loop condition is checked.\n- $B_2 \\to B_3$: If `$i  I$` is true, control enters the outer loop body, starting at the `$i \\bmod 2$` test.\n- $B_2 \\to B_{10}$: If `$i  I$` is false, the outer loop terminates, and control goes to the exit block.\n- $B_3 \\to B_9$: If `$i \\bmod 2 = 1$` is true, the `continue` statement executes, transferring control to the outer loop's increment block, $B_9$.\n- $B_3 \\to B_4$: If `$i \\bmod 2 = 1$` is false, execution proceeds sequentially to the inner loop's initialization.\n- $B_4 \\to B_5$: After initializing `$j$`, the inner loop condition is checked.\n- $B_5 \\to B_6$: If `$j  J$` is true, control enters the inner loop body, starting at the `$j=k$` test.\n- $B_5 \\to B_9$: If `$j  J$` is false, the inner loop terminates. Control then proceeds to the next effective statement, which is the outer loop's increment block, $B_9$.\n- $B_6 \\to B_9$: If `$j = k$` is true, the `break` statement executes, terminating the inner loop and transferring control to the statement following it, which is the outer loop's increment block, $B_9$.\n- $B_6 \\to B_7$: If `$j = k$` is false, execution proceeds sequentially to the statement `$S(i,j)$`.\n- $B_7 \\to B_8$: After executing `$S(i,j)$`, control flows to the inner loop's increment.\n- $B_8 \\to B_5$: After incrementing `$j$`, control flows back to the inner loop's condition test.\n- $B_9 \\to B_2$: After incrementing `$i$`, control flows back to the outer loop's condition test.\n\nCounting these transitions, we find the total number of edges to be $E = |E| = 13$.\n\nThird, we calculate the cyclomatic complexity, $V(G)$. For a graph with $N$ nodes, $E$ edges, and $P$ connected components, the complexity is given by the formula:\n$$V(G) = E - N + 2P$$\nThe problem specifies that the CFG has $1$ connected component, so $P=1$. Substituting the values for $N$ and $E$ derived above:\n$$V(G) = 13 - 10 + 2(1) = 3 + 2 = 5$$\n\nThis result can be verified using the alternative formula for structured programs, $V(G) = D + 1$, where $D$ is the number of predicate nodes (nodes with an out-degree greater than $1$). In our CFG, the predicate nodes are:\n- $B_2$ (test `$i  I$`)\n- $B_3$ (test `$i \\bmod 2 = 1$`)\n- $B_5$ (test `$j  J$`)\n- $B_6$ (test `$j = k$`)\nThere are $D=4$ such nodes. The cyclomatic complexity is therefore:\n$$V(G) = 4 + 1 = 5$$\nBoth methods produce the same result, confirming the correctness of the analysis. The cyclomatic complexity of the specified CFG is $5$.",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "Modern compilers rely on intermediate representations like Static Single Assignment (SSA) form to enable powerful optimizations. This final exercise explores how loop variables are handled in SSA, specifically through the use of $\\phi$-functions. By calculating the runtime cost associated with lowering a $\\phi$-function back to machine-level instructions, you will gain a deeper understanding of the practical trade-offs involved in using this advanced representation.",
            "id": "3653540",
            "problem": "A compiler transforms structured loops into a low-level control-flow form and places variables into Static Single Assignment (SSA) form. Consider a canonical lowering of the following nested loops in a high-level language into a control-flow graph with explicit headers and latches, under the following assumptions:\n\n- The outer loop iterates $N$ times with index $i$ taking values $0, 1, \\dots, N-1$ (i.e., the guard is $i  N$).\n- For each fixed outer index $i$, the inner loop iterates with index $j$ subject to the bound $j  i$. That is, on each outer iteration, $j$ takes values $0, 1, \\dots, i-1$ in sequence.\n- The compiler performs canonical loop lowering so that each loop has a unique preheader, header, body, and latch. The loop header dominates the body and latch and has exactly two incoming edges: one from the preheader and one from the latch (the backedge). The inner index $j$ is reinitialized to $0$ at the start of each inner-loop execution (i.e., at entry from the preheader to the inner header) and is incremented by $1$ in the inner latch along the backedge. There are no abnormal exits (no breaks or continues) and the loop bodies are straight-line code.\n- The compiler constructs SSA form and places a single $\\phi$-function for the inner index $j$ at the inner loop header to merge its two reaching definitions: the initial value $0$ from the preheader and the incremented value $j+1$ from the latch.\n- When deconstructing SSA, the compiler lowers each $\\phi$-function into a parallel copy implemented as one register-to-register move along each incoming edge to the header, executed whenever that edge is taken at runtime. Assume no copy coalescing or elimination occurs.\n\nUsing only the fundamental definitions of SSA form, $\\phi$-functions at dominance-merge points, and canonical loop lowering semantics as stated above, derive a closed-form expression in terms of $N$ for the total number of runtime register-to-register move instructions that are executed solely due to the inner loop header’s $\\phi$-function for $j$ over the entire execution of the nested loops.\n\nState your final answer as a single closed-form analytic expression in $N$. No rounding is required; do not include units. Assume $N$ is a nonnegative integer.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. It is based on standard principles of compiler design, including control-flow graphs, loop lowering, and Static Single Assignment (SSA) form. Therefore, the problem is valid.\n\nThe objective is to find a closed-form expression for the total number of register-to-register move instructions executed due to the de-SSA lowering of the $\\phi$-function for the inner loop index, $j$.\n\nAccording to the problem statement, SSA deconstruction lowers the $\\phi$-function at the inner loop header into one register-to-register move instruction along each incoming edge to that header. A move is executed every time one of these edges is traversed at runtime.\n\nThe inner loop header has exactly two incoming edges as per the canonical loop structure described:\n1.  An edge from the inner loop's preheader, which is traversed once each time the inner loop is entered.\n2.  An edge from the inner loop's latch, which is the backedge of the loop, traversed after each iteration of the inner loop body to test the condition for the next iteration.\n\nLet $M$ be the total number of executed move instructions. This total is the sum of the number of times each of these two edges is traversed over the entire execution of the nested loops. Let $M_{pre}$ be the total traversals of the preheader-to-header edge, and let $M_{latch}$ be the total traversals of the latch-to-header (backedge) edge.\n$$\nM = M_{pre} + M_{latch}\n$$\nThe outer loop iterates with index $i$ for the values $0, 1, \\dots, N-1$. For each of these $N$ iterations, the control flow enters the body of the outer loop, which contains the inner loop structure. The inner loop's preheader is therefore entered exactly once for each value of $i$. Thus, the preheader-to-header edge of the inner loop is traversed $N$ times in total.\n$$\nM_{pre} = N\n$$\nNext, we analyze the number of traversals of the inner loop's backedge. For a fixed outer loop index $i$, the inner loop iterates with index $j$ subject to the condition $j  i$. The index $j$ is initialized to $0$ and is incremented by $1$ in the latch. The inner loop body executes for $j = 0, 1, \\dots, i-1$.\n\nFor a fixed $i$, let's count the number of times the inner backedge is taken. The backedge is taken after the body completes for a given $j$, to return to the header. This occurs for each value of $j$ for which the body executes. The values of $j$ for which the body executes are $0, 1, \\dots, i-1$. There are $i$ such values. After the body executes for $j=i-1$, the latch increments $j$ to $i$ and takes the backedge one last time to the header, where the condition $i  i$ is evaluated as false, causing the loop to terminate. Therefore, for a given outer loop index $i$, the inner loop backedge is traversed exactly $i$ times.\n\nTo find the total number of backedge traversals, $M_{latch}$, we must sum the number of traversals for each iteration of the outer loop, from $i=0$ to $i=N-1$.\n$$\nM_{latch} = \\sum_{i=0}^{N-1} i\n$$\nThis is the sum of the first $N-1$ non-negative integers. The sum of an arithmetic series $0 + 1 + 2 + \\dots + (k-1)$ is given by the formula $\\frac{k(k-1)}{2}$. In our case, the series is $0 + 1 + \\dots + (N-1)$, which is the sum of the first $N$ terms of an arithmetic progression. The sum is given by $\\frac{n(a_1+a_n)}{2}$ where $n$ is the number of terms. Here $n=N$, $a_1=0$, and $a_N=N-1$. The sum is $\\frac{N(0 + N-1)}{2} = \\frac{N(N-1)}{2}$.\n$$\nM_{latch} = \\sum_{i=0}^{N-1} i = 0 + 1 + 2 + \\dots + (N-1) = \\frac{(N-1)N}{2}\n$$\nNow, we can compute the total number of move instructions, $M$, by summing the contributions from both edges.\n$$\nM = M_{pre} + M_{latch} = N + \\frac{N(N-1)}{2}\n$$\nTo obtain a single closed-form expression, we simplify this algebraically.\n$$\nM = \\frac{2N}{2} + \\frac{N^2 - N}{2} = \\frac{2N + N^2 - N}{2} = \\frac{N^2 + N}{2}\n$$\nThis can be factored as:\n$$\nM = \\frac{N(N+1)}{2}\n$$\nThis expression represents the sum of the first $N$ positive integers, also known as the $N$-th triangular number.\n\nAlternatively, we can reason that the total number of moves is equal to the total number of times the inner loop header is entered. For a given outer index $i$, the inner header is entered once from the preheader (to start the loop for $j=0$) and $i$ times from the latch (for the iterations corresponding to $j=0, \\dots, i-1$). Thus, for a given $i$, the header is entered $1+i$ times. Summing over all possible values of $i$:\n$$\nM = \\sum_{i=0}^{N-1} (1+i) = (1+0) + (1+1) + \\dots + (1 + (N-1)) = \\sum_{k=1}^{N} k\n$$\nThis is the sum of the first $N$ positive integers, which confirms the result.\n$$\n\\sum_{k=1}^{N} k = \\frac{N(N+1)}{2}\n$$\nThe total number of runtime register-to-register move instructions is $\\frac{N(N+1)}{2}$.",
            "answer": "$$\n\\boxed{\\frac{N(N+1)}{2}}\n$$"
        }
    ]
}