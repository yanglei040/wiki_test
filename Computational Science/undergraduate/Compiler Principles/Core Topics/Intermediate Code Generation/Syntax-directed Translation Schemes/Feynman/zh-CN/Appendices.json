{
    "hands_on_practices": [
        {
            "introduction": "在许多编程语言中，运算符重载是一种常见特性，同一个符号（例如 `-`）可以根据上下文代表不同的含义，如算术取反或布尔求补。本练习将指导您构建一个语法导向的翻译方案，利用属性来追踪表达式的类型，从而解决语义上的歧义。通过这个实践，您将理解编译器如何根据从语法树中综合出的类型信息，来选择正确的语义动作。",
            "id": "3673777",
            "problem": "考虑一个表达式语法片段，该片段允许带括号的因子、整型字面量和一元减号运算符：\n- 产生式：$F \\to -\\,F$\n- 产生式：$F \\to (\\,F\\,)$\n- 产生式：$F \\to \\text{num}$\n- 产生式：$F \\to \\text{true}$\n- 产生式：$F \\to \\text{false}$\n\n设计一个语法导向翻译（SDT），用于区分一元减号作用于因子 $F$ 时的两种重载解释：对于数值操作数，它执行算术取反；对于布尔操作数，它执行布尔补码。你的 SDT 必须使用属性 $F.\\text{type}$ 和 $F.\\text{opkind}$ 来决定和记录运算符的语义，并使用一个综合属性 $F.\\text{val}$ 来携带表达式求值计算出的数值结果。假设遵循以下约定：\n- 属性 $F.\\text{type}$ 的取值范围是 $\\{\\text{int}, \\text{bool}\\}$。\n- 属性 $F.\\text{opkind}$ 的取值范围是 $\\{\\text{neg}, \\text{not}\\}$，分别表示算术取反和布尔补码。\n- 属性 $F.\\text{val}$ 是数值型的，对于布尔值，使用 $1$ 表示 $\\text{true}$，$0$ 表示 $\\text{false}$。\n\n从语法导向定义和综合属性的基本定义出发，为给定的产生式构建一个 S-属性 SDT，该 SDT 能在每种情况下正确设置 $F.\\text{type}$、$F.\\text{opkind}$ 和 $F.\\text{val}$。然后，将你的 SDT 应用于输入字符串，该字符串由 11 个连续的一元减号作用于带括号的字面量 $\\text{false}$ 组成，即字符串\n$-(-(-(-(-(-(-(-(-(-(-(\\text{false})))))))))))$，\n并计算语法分析树根部综合属性 $F.\\text{val}$ 的数值。将你的最终答案表示为一个实数值。无需四舍五入。",
            "solution": "该问题要求为给定的语法片段设计一个 S-属性语法导向翻译（SDT），然后用它来评估一个特定的输入字符串。一个 S-属性 SDT 是一种只使用综合属性的语法导向定义。语法分析树中一个节点的综合属性值是根据其子节点的属性计算出来的。这使得自下而上的直接求值成为可能。\n\n首先，我们将通过为语法中的每个产生式指定语义规则来正式定义 SDT。所用属性为 $F.\\text{type}$（可以是 $\\text{int}$ 或 $\\text{bool}$）、$F.\\text{opkind}$（可以是 $\\text{neg}$ 或 $\\text{not}$）以及 $F.\\text{val}$（用于存放数值）。\n\n语法产生式及其对应的语义规则如下：\n\n1.  产生式：$F \\to \\text{num}$\n    此产生式处理整型字面量。类型为 $\\text{int}$，值是数字的词法值。\n    -   类型语义规则：$F.\\text{type} := \\text{int}$\n    -   值语义规则：$F.\\text{val} := \\text{num.lexval}$\n    \n2.  产生式：$F \\to \\text{true}$\n    此产生式处理布尔字面量 $\\text{true}$。类型为 $\\text{bool}$，数值定义为 $1$。\n    -   类型语义规则：$F.\\text{type} := \\text{bool}$\n    -   值语义规则：$F.\\text{val} := 1$\n\n3.  产生式：$F \\to \\text{false}$\n    此产生式处理布尔字面量 $\\text{false}$。类型为 $\\text{bool}$，数值定义为 $0$。\n    -   类型语义规则：$F.\\text{type} := \\text{bool}$\n    -   值语义规则：$F.\\text{val} := 0$\n\n4.  产生式：$F \\to (F_1)$\n    此产生式处理带括号的表达式。括号不改变内部表达式 $F_1$ 的类型或值。属性直接从子节点综合而来。设 $F_1$ 表示右侧的非终结符。\n    -   类型语义规则：$F.\\text{type} := F_1.\\text{type}$\n    -   值语义规则：$F.\\text{val} := F_1.\\text{val}$\n\n5.  产生式：$F \\to - F_1$\n    这是核心产生式，其中一元减号运算符被重载。语义动作取决于操作数 $F_1$ 的类型。设 $F_1$ 表示右侧的非终结符。\n    -   如果 $F_1.\\text{type} = \\text{int}$：运算符执行算术取反。\n        -   $F.\\text{type} := \\text{int}$\n        -   $F.\\text{opkind} := \\text{neg}$\n        -   $F.\\text{val} := -F_1.\\text{val}$\n    -   如果 $F_1.\\text{type} = \\text{bool}$：运算符执行布尔补码（逻辑非）。根据数值约定（$1$ 代表 $\\text{true}$，$0$ 代表 $\\text{false}$），对值 $v$ 进行的 NOT 操作等价于 $1-v$。\n        -   $F.\\text{type} := \\text{bool}$\n        -   $F.\\text{opkind} := \\text{not}$\n        -   $F.\\text{val} := 1 - F_1.\\text{val}$\n\n现在，我们将此 SDT 应用于输入字符串 $-(-(-(-(-(-(-(-(-(-(-(\\text{false}))))))))))))$。该字符串由带括号的字面量 $\\text{false}$ 嵌套在 11 个连续的一元减号运算符中组成。\n\n综合属性的求值在语法分析树上自下而上进行。让我们从最内层的表达式开始向外追踪计算过程。\n\n设 $F_{(0)}$ 是最内层表达式 $\\text{false}$ 的非终结符节点。\n-   使用产生式 $F \\to \\text{false}$：\n    $F_{(0)}.\\text{type} = \\text{bool}$\n    $F_{(0)}.\\text{val} = 0$\n\n设 $F_{(1)}$ 是 $(\\text{false})$ 的节点，对应于产生式 $F \\to (F_{(0)})$。\n-   使用产生式 $F \\to (F_1)$：\n    $F_{(1)}.\\text{type} = F_{(0)}.\\text{type} = \\text{bool}$\n    $F_{(1)}.\\text{val} = F_{(0)}.\\text{val} = 0$\n\n现在我们开始处理 11 次一元减号的应用链。我们用 $v_k$ 表示应用 $k$ 次一元减号后属性 $F.\\text{val}$ 的值。在应用任何减号运算符之前的初始值为 $v_0 = F_{(1)}.\\text{val} = 0$。\n\n第一次一元减号的应用作用于 $F_{(1)}$，为表达式 $-(\\text{false})$ 创建一个新节点 $F_{(2)}$。\n-   使用产生式 $F \\to -F_1$，其中 $F_1 = F_{(1)}$：\n    因为 $F_{(1)}.\\text{type}$ 是 $\\text{bool}$，我们应用布尔补码规则。\n    $F_{(2)}.\\text{type}$ 变为 $\\text{bool}$。\n    $F_{(2)}.\\text{opkind}$ 变为 $\\text{not}$。\n    值 $v_1 = F_{(2)}.\\text{val}$ 计算如下：\n    $$v_1 = 1 - F_{(1)}.\\text{val} = 1 - v_0 = 1 - 0 = 1$$\n\n第二次一元减号的应用作用于 $F_{(2)}$。\n-   使用产生式 $F \\to -F_1$，其中 $F_1 = F_{(2)}$：\n    因为 $F_{(2)}.\\text{type}$ 是 $\\text{bool}$，我们再次应用布尔补码规则。\n    值 $v_2 = F_{(3)}.\\text{val}$ 计算如下：\n    $$v_2 = 1 - F_{(2)}.\\text{val} = 1 - v_1 = 1 - 1 = 0$$\n\n一个清晰的模式出现了。在每一步中，表达式的类型都保持为 $\\text{bool}$，因此总是选择布尔补码的语义规则。应用 $k$ 次一元减号后表达式的值 $v_k$ 遵循递推关系：\n$$v_k = 1 - v_{k-1} \\quad \\text{对于 } k \\geq 1$$\n初始条件为 $v_0 = 0$。\n\n让我们计算一下值的序列：\n-   $v_0 = 0$\n-   $v_1 = 1 - v_0 = 1$\n-   $v_2 = 1 - v_1 = 0$\n-   $v_3 = 1 - v_2 = 1$\n-   $v_4 = 1 - v_3 = 0$\n\n值 $v_k$ 在 $1$ 和 $0$ 之间交替。具体来说，对于初始值 $v_0=0$：\n$$v_k = \\begin{cases} 0  \\text{如果 } k \\text{ 是偶数} \\\\ 1  \\text{如果 } k \\text{ 是奇数} \\end{cases}$$\n这可以表示为 $v_k = k \\pmod 2$。\n\n问题要求计算完整表达式的值，该表达式涉及 11 次一元减号运算符的应用。因此，我们需要计算 $v_{11}$。\n由于 $k=11$ 是一个奇数，最终值为：\n$$v_{11} = 1$$\n\n因此，整个输入字符串的语法分析树根部的综合属性 $F.\\text{val}$ 为 $1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "编译器的核心任务之一，是将高级源代码翻译成机器可以执行的低级表示。基于栈的虚拟机为求值算术表达式提供了一个简洁而强大的目标平台。本练习聚焦于代码生成这一核心任务，您将设计一个语法导向翻译方案，将中缀表达式转换为栈机指令序列，从而学习如何利用属性系统地构建出遵循文法规则（如运算符结合性）的目标代码。",
            "id": "3673805",
            "problem": "考虑用于左结合乘法表达式的上下文无关文法，其产生式为 $E \\rightarrow E * T \\mid T$ 和 $T \\rightarrow \\mathrm{id}$。设计一个语法制导翻译（SDT）方案，该方案为每个非终结符 $X \\in \\{E, T\\}$ 使用一个综合属性 $X.\\mathrm{code}$，以生成用于在栈式机上求值表达式的指令序列。该栈式机支持指令 $\\mathrm{LOAD}(x)$（将标识符 $x$ 的值推入栈）和 $\\mathrm{MUL}$（弹出栈顶的两个值 $r_{2}$ 和 $r_{1}$，计算 $r_{1} \\times r_{2}$，并将结果推入栈）。所有标识符都根据一个环境映射 $\\sigma$进行求值，其中 $\\sigma(x)$ 是绑定到标识符 $x$ 的实数值。\n\n从上下文无关文法的基础定义和给定栈式机的操作语义出发，提出一个能够正确执行文法所定义的左结合求值，并对 $E.\\mathrm{code}$ 进行标注以使生成的代码能正确执行入栈和出栈操作的SDT方案。\n\n然后，将你的SDT方案应用于输入表达式 $w * x * y * z$，其环境映射为 $\\sigma(w) = \\frac{6}{5}$，$\\sigma(x) = -3$，$\\sigma(y) = \\frac{7}{5}$，以及 $\\sigma(z) = 2$。在生成代码后，根据指定的语义在栈式机上进行概念性执行，并计算出确切的最终栈顶值。无需四舍五入；请以精确的分数或小数形式表示你的答案，不要使用百分号。",
            "solution": "该问题要求为一个给定的上下文无关文法设计一个语法制导翻译（SDT）方案，将此SDT应用于一个特定的输入表达式，并通过概念性执行生成的代码来找到最终的数值结果。\n\n### 第一部分：语法制导翻译（SDT）方案的设计\n\n目标是为文法中的每个产生式定义语义规则，以生成一个栈式机指令序列。非终结符 $X$ 的属性 $X.\\text{code}$ 将存储用于计算从 $X$ 派生的表达式并将结果留在栈顶的指令序列。我们使用 $||$ 来表示指令序列的连接。\n\n**产生式 1： $T \\rightarrow \\mathrm{id}$**\n该产生式代表了表达式的基本情况，即单个标识符。为对其求值，我们必须将其值加载到栈上。词法单元 $\\mathrm{id}$ 的词法值（名称）通过一个属性可用，我们将其表示为 $\\mathrm{id}.\\text{lexval}$。\n语义规则是：\n$T.\\text{code} := \"\\mathrm{LOAD}(\" \\ || \\ \\mathrm{id}.\\text{lexval} \\ || \\ \")\"$\n\n**产生式 2： $E \\rightarrow T$**\n该产生式处理仅由单个项组成的表达式。计算此类表达式的代码就是计算该项本身的代码。\n语义规则是：\n$E.\\text{code} := T.\\text{code}$\n\n**产生式 3： $E \\rightarrow E_1 * T$**\n这是一个捕获左结合性的左递归产生式。为了计算 $E_1 * T$ 形式的表达式，我们必须首先计算左子表达式 $E_1$，它会将其结果留在栈上。然后，我们计算右子表达式 $T$，它会将其结果留在 $E_1$ 的结果之上。最后，我们执行乘法指令，该指令弹出两个结果并将其乘积推入栈中。\n综合属性的语义规则在自底向上分析期间应用。$E_1$ 和 $T$ 的代码此时已经生成。因此，我们可以将它们连接起来。\n语义规则是：\n$E.\\text{code} := E_1.\\text{code} \\ || \\ T.\\text{code} \\ || \\ \"\\mathrm{MUL}\"$\n\n完整的SDT总结如下：\n| 产生式             | 语义规则                                         |\n|------------------------|-------------------------------------------------------|\n| $T \\rightarrow \\mathrm{id}$  | $T.\\text{code} := \"\\mathrm{LOAD}(\\mathrm{id}.\\text{lexval})\"$ |\n| $E \\rightarrow T$        | $E.\\text{code} := T.\\text{code}$                      |\n| $E \\rightarrow E_1 * T$  | $E.\\text{code} := E_1.\\text{code} \\ || \\ T.\\text{code} \\ || \\ \"\\mathrm{MUL}\"$ |\n\n### 第二部分：为 $w * x * y * z$ 生成代码\n\n我们将SDT应用于输入字符串 $w * x * y * z$。左递归文法自然地导致左结合分析。该表达式被分析为 $(((w * x) * y) * z)$。我们可以通过模拟自底向上分析（或标注分析树）来追踪代码生成过程。\n\n1.  **解析 $w$**：\n    *   $T \\rightarrow \\mathrm{id}_w \\implies T.\\text{code} = \"\\mathrm{LOAD}(w)\"$\n    *   $E \\rightarrow T \\implies E_1.\\text{code} = \"\\mathrm{LOAD}(w)\"$\n\n2.  **解析 $w * x$**：这对应于产生式 $E \\rightarrow E_1 * T_x$。\n    *   对于子表达式 $x$：$T_x \\rightarrow \\mathrm{id}_x \\implies T_x.\\text{code} = \"\\mathrm{LOAD}(x)\"$\n    *   对于表达式 $w * x$：$E_2.\\text{code} = E_1.\\text{code} \\ || \\ T_x.\\text{code} \\ || \\ \"\\mathrm{MUL}\" = \"\\mathrm{LOAD}(w) \\ \\mathrm{LOAD}(x) \\ \\mathrm{MUL}\"$\n\n3.  **解析 $(w * x) * y$**：这对应于产生式 $E \\rightarrow E_2 * T_y$。\n    *   对于子表达式 $y$：$T_y \\rightarrow \\mathrm{id}_y \\implies T_y.\\text{code} = \"\\mathrm{LOAD}(y)\"$\n    *   对于表达式 $(w * x) * y$：$E_3.\\text{code} = E_2.\\text{code} \\ || \\ T_y.\\text{code} \\ || \\ \"\\mathrm{MUL}\" = \"\\mathrm{LOAD}(w) \\ \\mathrm{LOAD}(x) \\ \\mathrm{MUL} \\ \\mathrm{LOAD}(y) \\ \\mathrm{MUL}\"$\n\n4.  **解析 $((w * x) * y) * z$**：这对应于产生式 $E \\rightarrow E_3 * T_z$。\n    *   对于子表达式 $z$：$T_z \\rightarrow \\mathrm{id}_z \\implies T_z.\\text{code} = \"\\mathrm{LOAD}(z)\"$\n    *   对于完整表达式：$E.\\text{code} = E_3.\\text{code} \\ || \\ T_z.\\text{code} \\ || \\ \"\\mathrm{MUL}\" = \"\\mathrm{LOAD}(w) \\ \\mathrm{LOAD}(x) \\ \\mathrm{MUL} \\ \\mathrm{LOAD}(y) \\ \\mathrm{MUL} \\ \\mathrm{LOAD}(z) \\ \\mathrm{MUL}\"$\n\n最终生成的指令序列是：\n$\\mathrm{LOAD}(w)$, $\\mathrm{LOAD}(x)$, $\\mathrm{MUL}$, $\\mathrm{LOAD}(y)$, $\\mathrm{MUL}$, $\\mathrm{LOAD}(z)$, $\\mathrm{MUL}$\n\n### 第三部分：概念性执行与最终值计算\n\n我们在给定环境下执行此代码序列：$\\sigma(w) = \\frac{6}{5}$，$\\sigma(x) = -3$，$\\sigma(y) = \\frac{7}{5}$，$\\sigma(z) = 2$。\n栈由一个列表 `[...]` 表示，栈顶在右侧。\n\n1.  **初始栈：** `[]`\n2.  **$\\mathrm{LOAD}(w)$：** `[ $\\frac{6}{5}$ ]`\n3.  **$\\mathrm{LOAD}(x)$：** `[ $\\frac{6}{5}$, $-3$ ]`\n4.  **$\\mathrm{MUL}$：**\n    *   弹出 $r_2 = -3$。\n    *   弹出 $r_1 = \\frac{6}{5}$。\n    *   计算 $r_1 \\times r_2 = \\frac{6}{5} \\times (-3) = -\\frac{18}{5}$。\n    *   推入结果。栈： `[ $-\\frac{18}{5}$ ]`\n5.  **$\\mathrm{LOAD}(y)$：** `[ $-\\frac{18}{5}$, $\\frac{7}{5}$ ]`\n6.  **$\\mathrm{MUL}$：**\n    *   弹出 $r_2 = \\frac{7}{5}$。\n    *   弹出 $r_1 = -\\frac{18}{5}$。\n    *   计算 $r_1 \\times r_2 = (-\\frac{18}{5}) \\times (\\frac{7}{5}) = -\\frac{126}{25}$。\n    *   推入结果。栈： `[ $-\\frac{126}{25}$ ]`\n7.  **$\\mathrm{LOAD}(z)$：** `[ $-\\frac{126}{25}$, $2$ ]`\n8.  **$\\mathrm{MUL}$：**\n    *   弹出 $r_2 = 2$。\n    *   弹出 $r_1 = -\\frac{126}{25}$。\n    *   计算 $r_1 \\times r_2 = (-\\frac{126}{25}) \\times 2 = -\\frac{252}{25}$。\n    *   推入结果。栈： `[ $-\\frac{252}{25}$ ]`\n\n执行结束时，栈顶的值为 $-\\frac{252}{25}$。这个值也可以表示为 $-10.08$。根据问题说明，精确的分数形式是合适的。\n最终计算：\n$$\n\\left( \\left( \\frac{6}{5} \\times (-3) \\right) \\times \\frac{7}{5} \\right) \\times 2 = \\left( -\\frac{18}{5} \\times \\frac{7}{5} \\right) \\times 2 = \\left( -\\frac{126}{25} \\right) \\times 2 = -\\frac{252}{25}\n$$",
            "answer": "$$\\boxed{-\\frac{252}{25}}$$"
        },
        {
            "introduction": "除了简单的翻译，现代编译器还会执行复杂的静态分析，以便在程序运行前发现错误并优化代码。一个典型的例子是在编译时识别出分母为常数零的“除零”错误。本练习将带您进入静态分析与优化的领域，展示语法导向翻译如何让编译器变得更“智能”。您将实现常量折叠技术，在编译期对表达式部分求值，并利用这些信息来区分可以静态捕获的错误和需要运行时检查的情况。",
            "id": "3673782",
            "problem": "在一个上下文无关文法 (CFG) 的框架内，为算术表达式设计一个语法指导翻译 (SDT)。该 SDT 能够在解析时，当分母为常量零时静态地标记除以零错误，并在其他情况下为每次除法生成一个运行时检查。仅使用综合属性。你的 SDT 必须确定每个子表达式是否为常量，如果是，则计算其数值；如果存在任何变量，则该子表达式应被视为非常量。假设数值字面量是整数，标识符是非常量未知数。考虑以下具有标准优先级和结合性的 CFG（乘法和除法比加法和减法结合得更紧密，括号可以覆盖优先级）。该文法是：\n$$\nE \\to E + T \\mid E - T \\mid T\n$$\n$$\nT \\to T \\times F \\mid T \\div F \\mid F\n$$\n$$\nF \\to (E) \\mid \\text{num} \\mid \\text{id}\n$$\n该 SDT 必须：\n- 对于每个形如 $T \\to T \\div F$ 的产生式，如果 $F$ 是常量且 $F.\\text{val} = 0$，则标记一个静态的除以零错误。否则，为该除法生成一个运行时检查。\n- 当一个子表达式可以由数值字面量和完全是常量的子表达式证明为常量时，为 $E$、$T$ 和 $F$ 传播和计算一个综合属性 $\\text{val}$；如果一个子表达式不是常量，则将 $\\text{val}$ 设置为一个未知标记。\n- 在整个树中累积插入的运行时检查和静态的除以零标记的综合计数，并在根节点处提供这些总数。\n\n假设未知标记用符号 $\\bot$ 表示，并且当完全是常量时，$\\text{val}$ 的求值遵循常规的整数算术，否则为 $\\bot$。对于输入表达式\n$$\n\\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big) \\div \\big(x \\div (2 - 3)\\big),\n$$\n使用你的 SDT 计算在解析此表达式期间生成的运行时检查的总数。仅报告运行时检查的数量。你不需要报告静态标记的数量。将你的最终答案表示为单个整数，无需舍入说明。",
            "solution": "任务是设计一个仅使用综合属性的语法指导翻译 (SDT) 来分析算术表达式。该 SDT 必须静态检测除以常量零的情况，并为所有其他除法操作生成一个运行时检查。我们被要求计算特定表达式 $\\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big) \\div \\big(x \\div (2 - 3)\\big)$ 的运行时检查总数。\n\n首先，我们定义 SDT。对于文法中的每个非终结符 $X \\in \\{E, T, F\\}$，我们定义一组综合属性：\n1.  $X.\\text{is\\_const}$：一个布尔属性，如果以 $X$ 为根的子表达式是编译时常量，则为真，否则为假。\n2.  $X.\\text{val}$：如果 $X.\\text{is\\_const}$ 为真，则为子表达式的整数值。如果子表达式不是常量或其求值导致错误（如除以零），其值是一个未知标记，用 $\\bot$ 表示。\n3.  $X.\\text{rc}$：一个整型属性，计算为以 $X$ 为根的子表达式生成的运行时检查的数量。\n4.  $X.\\text{sf}$：一个整型属性，计算为以 $X$ 为根的子表达式引发的静态除以零标记的数量。\n\n上下文无关文法中每个产生式的语义规则如下。\n\n对于终结符产生式：\n-   $F \\to \\text{num}$:\n    $$F.\\text{is\\_const} \\leftarrow \\text{true}$$\n    $$F.\\text{val} \\leftarrow \\text{num.lexval}$$\n    $$F.\\text{rc} \\leftarrow 0$$\n    $$F.\\text{sf} \\leftarrow 0$$\n-   $F \\to \\text{id}$:\n    $$F.\\text{is\\_const} \\leftarrow \\text{false}$$\n    $$F.\\text{val} \\leftarrow \\bot$$\n    $$F.\\text{rc} \\leftarrow 0$$\n    $$F.\\text{sf} \\leftarrow 0$$\n\n对于非终结符产生式：\n-   $F \\to (E)$:\n    $$F.\\text{is\\_const} \\leftarrow E.\\text{is\\_const}$$\n    $$F.\\text{val} \\leftarrow E.\\text{val}$$\n    $$F.\\text{rc} \\leftarrow E.\\text{rc}$$\n    $$F.\\text{sf} \\leftarrow E.\\text{sf}$$\n-   $T \\to F$:\n    $$T.\\text{is\\_const} \\leftarrow F.\\text{is\\_const}$$\n    $$T.\\text{val} \\leftarrow F.\\text{val}$$\n    $$T.\\text{rc} \\leftarrow F.\\text{rc}$$\n    $$T.\\text{sf} \\leftarrow F.\\text{sf}$$\n-   $E \\to T$:\n    $$E.\\text{is\\_const} \\leftarrow T.\\text{is\\_const}$$\n    $$E.\\text{val} \\leftarrow T.\\text{val}$$\n    $$E.\\text{rc} \\leftarrow T.\\text{rc}$$\n    $$E.\\text{sf} \\leftarrow T.\\text{sf}$$\n-   $E \\to E_1 + T_2$:\n    $$E.\\text{is\\_const} \\leftarrow E_1.\\text{is\\_const} \\land T_2.\\text{is\\_const}$$\n    $$E.\\text{val} \\leftarrow \\begin{cases} E_1.\\text{val} + T_2.\\text{val}  \\text{if } E.\\text{is\\_const} \\\\ \\bot  \\text{otherwise} \\end{cases}$$\n    $$E.\\text{rc} \\leftarrow E_1.\\text{rc} + T_2.\\text{rc}$$\n    $$E.\\text{sf} \\leftarrow E_1.\\text{sf} + T_2.\\text{sf}$$\n-   $E \\to E_1 - T_2$:\n    $$E.\\text{is\\_const} \\leftarrow E_1.\\text{is\\_const} \\land T_2.\\text{is\\_const}$$\n    $$E.\\text{val} \\leftarrow \\begin{cases} E_1.\\text{val} - T_2.\\text{val}  \\text{if } E.\\text{is\\_const} \\\\ \\bot  \\text{otherwise} \\end{cases}$$\n    $$E.\\text{rc} \\leftarrow E_1.\\text{rc} + T_2.\\text{rc}$$\n    $$E.\\text{sf} \\leftarrow E_1.\\text{sf} + T_2.\\text{sf}$$\n-   $T \\to T_1 \\times F_2$:\n    $$T.\\text{is\\_const} \\leftarrow T_1.\\text{is\\_const} \\land F_2.\\text{is\\_const}$$\n    $$T.\\text{val} \\leftarrow \\begin{cases} T_1.\\text{val} \\times F_2.\\text{val}  \\text{if } T.\\text{is\\_const} \\\\ \\bot  \\text{otherwise} \\end{cases}$$\n    $$T.\\text{rc} \\leftarrow T_1.\\text{rc} + F_2.\\text{rc}$$\n    $$T.\\text{sf} \\leftarrow T_1.\\text{sf} + F_2.\\text{sf}$$\n-   $T \\to T_1 \\div F_2$:\n    如果 $F_2.\\text{is\\_const} = \\text{true}$ 且 $F_2.\\text{val} = 0$：\n    $$T.\\text{is\\_const} \\leftarrow \\text{false}$$\n    $$T.\\text{val} \\leftarrow \\bot$$\n    $$T.\\text{rc} \\leftarrow T_1.\\text{rc} + F_2.\\text{rc}$$\n    $$T.\\text{sf} \\leftarrow T_1.\\text{sf} + F_2.\\text{sf} + 1$$\n    否则：\n    $$T.\\text{is\\_const} \\leftarrow T_1.\\text{is\\_const} \\land F_2.\\text{is\\_const}$$\n    $$T.\\text{val} \\leftarrow \\begin{cases} T_1.\\text{val} \\div F_2.\\text{val}  \\text{if } T.\\text{is\\_const} \\\\ \\bot  \\text{otherwise} \\end{cases}$$\n    $$T.\\text{rc} \\leftarrow T_1.\\text{rc} + F_2.\\text{rc} + 1$$\n    $$T.\\text{sf} \\leftarrow T_1.\\text{sf} + F_2.\\text{sf}$$\n\n现在，我们以自底向上的方式将这些规则应用于输入表达式 $\\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big) \\div \\big(x \\div (2 - 3)\\big)$，这对应于对解析树的后序遍历。我们将一个子表达式 $s$ 的节点的属性表示为 $A(s) = (\\text{is\\_const}, \\text{val}, \\text{rc}, \\textsf)$。\n\n1.  **最内层的子表达式：**\n    -   $s_1 = (4-4)$：操作数是 $\\text{num}_4$ 和 $\\text{num}_4$。对于 $\\text{num}_4$，$A(\\text{num}_4) = (\\text{true}, 4, 0, 0)$。\n        应用 $E \\to E_1 - T_2$ 的规则：\n        $A(s_1) = (\\text{true} \\land \\text{true}, 4-4, 0+0, 0+0) = (\\text{true}, 0, 0, 0)$。\n    -   $s_2 = (7 \\div 1)$：操作数是 $\\text{num}_7$ 和 $\\text{num}_1$。$A(\\text{num}_7) = (\\text{true}, 7, 0, 0)$ 且 $A(\\text{num}_1) = (\\text{true}, 1, 0, 0)$。分母是常量，其值为 1，而不是 0。\n        应用 $T \\to T_1 \\div F_2$ 规则的“Else”部分：\n        $A(s_2) = (\\text{true} \\land \\text{true}, 7 \\div 1, 0+0+1, 0+0) = (\\text{true}, 7, 1, 0)$。\n        增加了一个运行时检查。\n    -   $s_3 = (2 - 3)$：操作数是 $\\text{num}_2$ 和 $\\text{num}_3$。$A(\\text{num}_2) = (\\text{true}, 2, 0, 0)$ 且 $A(\\text{num}_3) = (\\text{true}, 3, 0, 0)$。\n        应用 $E \\to E_1 - T_2$ 的规则：\n        $A(s_3) = (\\text{true} \\land \\text{true}, 2-3, 0+0, 0+0) = (\\text{true}, -1, 0, 0)$。\n\n2.  **中间子表达式：**\n    -   $s_4 = (8 \\div (4-4))$：操作数是 $\\text{num}_8$（其 $A(\\text{num}_8) = (\\text{true}, 8, 0, 0)$）和 $s_1$（其 $A(s_1) = (\\text{true}, 0, 0, 0)$）。分母是常量，其值为 0。\n        应用 $T \\to T_1 \\div F_2$ 规则的“If”部分：\n        $A(s_4) = (\\text{false}, \\bot, 0+0, 0+0+1) = (\\text{false}, \\bot, 0, 1)$。\n        引发了一个静态标记。此次除法不添加运行时检查。\n    -   $s_5 = (x \\div (2-3))$：操作数是 $\\text{id}_x$（其 $A(\\text{id}_x) = (\\text{false}, \\bot, 0, 0)$）和 $s_3$（其 $A(s_3) = (\\text{true}, -1, 0, 0)$）。分母是常量，其值为 -1，而不是 0。\n        应用 $T \\to T_1 \\div F_2$ 规则的“Else”部分：\n        条件 $T.\\text{is\\_const}$ 为假，因为 $T_1.\\text{is\\_const}$（对于 $x$）为假。\n        $A(s_5) = (\\text{false} \\land \\text{true}, \\bot, 0+0+1, 0+0) = (\\text{false}, \\bot, 1, 0)$。\n        增加了一个运行时检查。\n\n3.  **更高级别的子表达式：**\n    -   $s_6 = \\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big)$：这是 $s_4 \\div s_2$。操作数是 $s_4$（其 $A(s_4) = (\\text{false}, \\bot, 0, 1)$）和 $s_2$（其 $A(s_2) = (\\text{true}, 7, 1, 0)$）。分母 $s_2$ 是常量，其值为 7，而不是 0。\n        应用 $T \\to T_1 \\div F_2$ 规则的“Else”部分：\n        条件 $T.\\text{is\\_const}$ 为假，因为 $T_1.\\text{is\\_const}$（对于 $s_4$）为假。\n        运行时检查计数是子节点计数的总和，再加上当前除法的一个：$T.\\text{rc} = s_4.\\text{rc} + s_2.\\text{rc} + 1 = 0 + 1 + 1 = 2$。\n        静态标记计数是子节点计数的总和：$T.\\text{sf} = s_4.\\text{sf} + s_2.\\text{sf} = 1 + 0 = 1$。\n        $A(s_6) = (\\text{false}, \\bot, 2, 1)$。\n        增加了一个运行时检查。\n\n4.  **根表达式：**\n    -   $s_7 = \\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big) \\div \\big(x \\div (2 - 3)\\big)$：这是 $s_6 \\div s_5$。操作数是 $s_6$（其 $A(s_6) = (\\text{false}, \\bot, 2, 1)$）和 $s_5$（其 $A(s_5) = (\\text{false}, \\bot, 1, 0)$）。分母 $s_5$ 不是常量。\n        应用 $T \\to T_1 \\div F_2$ 规则的“Else”部分：\n        条件 $T.\\text{is\\_const}$ 为假，因为两个操作数都不是常量。\n        运行时检查计数是 $T.\\text{rc} = s_6.\\text{rc} + s_5.\\text{rc} + 1 = 2 + 1 + 1 = 4$。\n        静态标记计数是 $T.\\text{sf} = s_6.\\text{sf} + s_5.\\text{sf} = 1 + 0 = 1$。\n        $A(s_7) = (\\text{false}, \\bot, 4, 1)$。\n        增加了一个运行时检查。\n\n除法及其检查的摘要：\n-   $8 \\div (4-4)$：分母是常量 $0 \\implies$ 静态标记。（$\\text{rc}=0$）\n-   $7 \\div 1$：分母是常量非零 $\\implies$ 运行时检查。（$\\text{rc}=1$）\n-   $x \\div (2-3)$：分母是常量非零 $\\implies$ 运行时检查。（$\\text{rc}=1$）\n-   $(...) \\div (7 \\div 1)$：分母是常量非零 $\\implies$ 运行时检查。（$\\text{rc}=1$）\n-   $(...) \\div (x \\div (2-3))$：分母不是常量 $\\implies$ 运行时检查。（$\\text{rc}=1$）\n\n运行时检查的总数是每个分母不为常量零的除法的检查数之和：$0 + 1 + 1 + 1 + 1 = 4$。\n解析树根节点处 `rc` 属性的最终值为 $4$。",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}