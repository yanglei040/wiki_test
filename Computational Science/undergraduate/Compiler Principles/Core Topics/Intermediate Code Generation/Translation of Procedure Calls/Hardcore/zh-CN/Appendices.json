{
    "hands_on_practices": [
        {
            "introduction": "理解过程调用如何消耗栈空间是编译器设计的基础。本练习提供了一个关于运行时栈的动手模拟。通过计算不同参数传递机制——传值调用与传引用调用——的栈位移，您将对它们的性能权衡以及递归过程中活动记录的管理机制有一个具体的认识。",
            "id": "3678364",
            "problem": "一台机器为过程调用实现了一个向下增长的运行时栈。以下核心事实和定义支配其执行模型。\n\n- 运行时栈为活动过程保存活动记录（也称为栈帧）。栈指针 (SP) 始终指向栈顶，压入 $k$ 字节会从 SP 中减去 $k$，而弹出 $k$ 字节会向 SP 加上 $k$。帧指针 (FP) 是当前活动记录中的一个稳定指针；它在进入时保存，在返回时恢复。\n- 每次调用都遵循标准的调用者推送、被调用者保存的约定：\n  1. 调用者计算并推送被调用者的实参，总共占用 $P$ 字节。\n  2. `call` 指令推送大小为 $w$ 字节的返回地址。\n  3. 被调用者的序言推送调用者的 $FP$（大小为 $w$），设置 $FP \\leftarrow SP$，并从 SP 中减去其局部存储大小 $L$。\n  4. 返回时，被调用者的结语将 $L$ 加回 SP，通过弹出 $w$ 字节来恢复保存的 $FP$，并执行返回指令，该指令通过向 SP 加上 $w$ 来弹出返回地址。最后，调用者通过向 SP 加上 $P$ 来移除参数块。\n- 按值传递将实参复制到被调用者的参数区域。按引用传递只传递实参的地址（一个指针）。在这两种情况下，整数参数占用 $w$ 字节，指针也占用 $w$ 字节。\n\n考虑如下定义的两个相互递归的过程 $f$ 和 $g$。它们接受两个参数：一个大小为 $s$ 字节的结构化聚合 $S$ 和一个整数 $n$。当 $n \\le 0$ 时，这些过程执行的简单相互递归终止。\n\n- 过程 $f(S, n)$:\n  - 如果 $n \\le 0$，立即返回。\n  - 否则，调用 $g(S, n - 1)$ 然后返回。\n- 过程 $g(S, n)$:\n  - 如果 $n \\le 0$，立即返回。\n  - 否则，调用 $f(S, n - 1)$ 然后返回。\n\n假设以下具体大小：\n- 字长 $w = 8$ 字节。\n- 聚合大小 $s = 48$ 字节。\n- $f$ 的局部存储（包括任何已保存的被调用者保存寄存器）为 $L_f = 16$ 字节。\n- $g$ 的局部存储为 $L_g = 24$ 字节。\n- 程序从一个名为 `main` 的过程开始，该过程的局部存储为 $L_{m} = 32$ 字节，没有参数。在建立自己的活动记录后，`main` 调用 $f(S_0, N)$，其中 $S_0$ 是一个全局聚合，$N = 4$。\n\n你需要针对第一个参数 $S$ 的两种不同调用约定，模拟整个执行过程中的栈增长和内容：\n- 场景 A：$S$ 按值传递。\n- 场景 B：$S$ 按引用传递。\n\n对于这两种场景，跟踪每次调用和返回时上述约定所隐含的 $SP$ 和 $FP$ 的逐步变化，并确定 $SP$ 相对于 `main` 序言完成后其值的最大向下位移。然后计算最大值之间的差（场景 A 减去场景 B）。用一个以字节为单位的数字表达你的最终答案。不需要四舍五入。",
            "solution": "该问题要求我们计算在两种不同的参数传递机制下，递归调用链中运行时栈的最大位移，并找出这两种位移的差值。我们将以 `main` 函数序言完成后的栈指针位置为基准（位移为0），向下增长的位移为正值。\n\n程序的调用链为 `main` → `f(4)` → `g(3)` → `f(2)` → `g(1)` → `f(0)`。当 `f(0)` 被调用并完成其序言后，栈的深度达到最大。\n\n一次调用的栈消耗包括：调用者压入的参数（大小 $P$）、`call` 指令压入的返回地址（大小 $w=8$）、被调用者序言压入的旧帧指针（大小 $w=8$）以及为局部变量分配的空间（大小 $L$）。\n\n**场景 A：$S$ 按值传递**\n\n1.  **参数大小**：结构体 $S$ (48字节) + 整数 $n$ (8字节) = 56 字节。即 $P = 56$。\n2.  **栈位移计算**：我们累加每次调用产生的位移。\n    *   **`main` 调用 `f(4)`**：\n        *   压入参数 (56) + 返回地址 (8) = 64 字节。\n        *   `f` 序言：压入旧 $FP$ (8) + 局部变量 $L_f$ (16) = 24 字节。\n        *   进入 `f(4)` 后位移：$64 + 24 = 88$。\n    *   **`f(4)` 调用 `g(3)`**：\n        *   压入参数 (56) + 返回地址 (8) = 64 字节。\n        *   `g` 序言：压入旧 $FP$ (8) + 局部变量 $L_g$ (24) = 32 字节。\n        *   进入 `g(3)` 后位移：$88 + 64 + 32 = 184$。\n    *   **`g(3)` 调用 `f(2)`**：\n        *   压入参数 (56) + 返回地址 (8) = 64 字节。\n        *   `f` 序言：24 字节。\n        *   进入 `f(2)` 后位移：$184 + 64 + 24 = 272$。\n    *   **`f(2)` 调用 `g(1)`**：\n        *   压入参数 (56) + 返回地址 (8) = 64 字节。\n        *   `g` 序言：32 字节。\n        *   进入 `g(1)` 后位移：$272 + 64 + 32 = 368$。\n    *   **`g(1)` 调用 `f(0)`**：\n        *   压入参数 (56) + 返回地址 (8) = 64 字节。\n        *   `f` 序言：24 字节。\n        *   进入 `f(0)` 后位移（最大位移）：$368 + 64 + 24 = 456$。\n\n场景 A 的最大位移为 **456 字节**。\n\n**场景 B：$S$ 按引用传递**\n\n1.  **参数大小**：$S$ 的地址指针 (8字节) + 整数 $n$ (8字节) = 16 字节。即 $P = 16$。\n2.  **栈位移计算**：\n    *   **`main` 调用 `f(4)`**：\n        *   压入参数 (16) + 返回地址 (8) = 24 字节。\n        *   `f` 序言 (24 字节)。\n        *   进入 `f(4)` 后位移：$24 + 24 = 48$。\n    *   **`f(4)` 调用 `g(3)`**：\n        *   压入参数 (16) + 返回地址 (8) = 24 字节。\n        *   `g` 序言 (32 字节)。\n        *   进入 `g(3)` 后位移：$48 + 24 + 32 = 104$。\n    *   **`g(3)` 调用 `f(2)`**：\n        *   压入参数 (16) + 返回地址 (8) = 24 字节。\n        *   `f` 序言 (24 字节)。\n        *   进入 `f(2)` 后位移：$104 + 24 + 24 = 152$。\n    *   **`f(2)` 调用 `g(1)`**：\n        *   压入参数 (16) + 返回地址 (8) = 24 字节。\n        *   `g` 序言 (32 字节)。\n        *   进入 `g(1)` 后位移：$152 + 24 + 32 = 208$。\n    *   **`g(1)` 调用 `f(0)`**：\n        *   压入参数 (16) + 返回地址 (8) = 24 字节。\n        *   `f` 序言 (24 字节)。\n        *   进入 `f(0)` 后位移（最大位移）：$208 + 24 + 24 = 256$。\n\n场景 B 的最大位移为 **256 字节**。\n\n**最终计算**\n\n最大位移之间的差值为：\n$$ \\text{差值} = \\text{场景 A 位移} - \\text{场景 B 位移} = 456 - 256 = 200 \\text{ 字节} $$",
            "answer": "$$\n\\boxed{200}\n$$"
        },
        {
            "introduction": "编译器必须严格遵守应用程序二进制接口 (ABI)，以确保代码的互操作性。本实践聚焦于 ABI 的一个关键细节：参数整理。您将通过应用符号扩展和零扩展规则，把不同整数类型的源级变量转换为它们正确的 $64$ 位寄存器表示，从而阐明在调用点为保证类型安全的过程调用所需的底层数据转换。",
            "id": "3678301",
            "problem": "考虑一个 $64$ 位架构，其应用程序二进制接口（ABI）要求所有窄于机器寄存器宽度的整数参数在调用点被扩展到 $64$ 位，然后再放入参数寄存器中。规则是：有符号窄整数必须符号扩展到 $64$ 位，无符号窄整数必须零扩展到 $64$ 位。被调用者将从其 $64$ 位的参数寄存器中读取参数。假设所有有符号整数都采用二进制补码表示法，并且机器寄存器以二进制补码算术的标准方式解释位运算。\n\n你正在编译一个从调用者过程到被调用者过程 $g$ 的调用，调用者中具有以下源级别的类型和值：\n- 一个值为 $-45$ 的有符号 $8$ 位整数 $a$。\n- 一个值为 $0x\\mathrm{F234}$ 的无符号 $16$ 位整数 $b$。\n- 一个值为 $0x\\mathrm{80001234}$ 的有符号 $32$ 位整数 $c$。\n\n被调用者 $g$ 期望在其寄存器 $\\mathrm{X0}$、$\\mathrm{X1}$ 和 $\\mathrm{X2}$ 中接收三个 $64$ 位参数，分别对应于调用者的 $a$、$b$ 和 $c$。在其序言（prologue）中，$g$ 使用位运算和算术运算对 $64$ 位寄存器执行以下验证和计算：\n- 它通过取 $\\mathrm{X0}$ 的低 $8$ 位并将其算术扩展到 $64$ 位来计算一个规范的符号扩展，得到一个值 $x'$。\n- 它通过取 $\\mathrm{X1}$ 的低 $16$ 位并将其逻辑扩展（零扩展）到 $64$ 位来计算一个规范的零扩展，得到一个值 $y'$。\n- 它通过取 $\\mathrm{X2}$ 的低 $32$ 位并将其算术扩展到 $64$ 位来计算一个规范的符号扩展，得到一个值 $z'$。\n- 它形成一个由下式定义的惩罚项 $P$：\n$$\nP \\;=\\; |\\mathrm{X0} - x'| \\;+\\; 2\\,|\\mathrm{X1} - y'| \\;+\\; 3\\,|\\mathrm{X2} - z'| ,\n$$\n其中 $|\\,\\cdot\\,|$ 是有符号 $64$ 位整数的绝对值。\n- 它返回一个 $64$ 位整数\n$$\nR \\;=\\; x' \\;+\\; 2y' \\;+\\; 4z' \\;+\\; P .\n$$\n\n你的任务是根据上述 ABI 规则，在调用点插入所需的扩展，将调用者的过程调用转换为被调用者的调用约定，然后确定当调用点遵守 ABI 时，$g$ 对给定的 $a$、$b$ 和 $c$ 产生的确切数值返回值 $R$。以单个整数形式提供最终答案。不需要四舍五入，也不涉及单位。在相关处将任何中间十六进制常数和所有数字表示为数学实体，但最终答案必须是单个整数。",
            "solution": "该问题要求我们确定一个过程调用的返回值，这涉及到理解应用程序二进制接口（ABI）关于参数传递的规则，特别是整数扩展，然后执行被调用者过程中定义的一系列算术和位运算。这个过程可以分解为四个主要步骤：\n1. 确定调用者放置在参数寄存器 $\\mathrm{X0}$、$\\mathrm{X1}$ 和 $\\mathrm{X2}$ 中的 $64$ 位值。\n2. 确定被调用者计算出的值 $x'$、$y'$ 和 $z'$。\n3. 计算惩罚项 $P$。\n4. 计算最终返回值 $R$。\n\n**第 1 步：确定寄存器 $\\mathrm{X0}$、$\\mathrm{X1}$ 和 $\\mathrm{X2}$ 中的值**\n\nABI 规定，窄于 $64$ 位寄存器宽度的整数参数在调用点进行扩展。有符号整数进行符号扩展，无符号整数进行零扩展。我们将此规则应用于每个参数。\n\n*   **参数 `a` 到寄存器 $\\mathrm{X0}$：**\n    参数 $a$ 是一个值为 $-45$ 的有符号 $8$ 位整数。首先，我们找到它的 $8$ 位二进制补码表示。正值 $45$ 的 $8$ 位二进制是 $00101101_2$。为了得到 $-45$，我们取其二进制补码：将各位取反（$11010010_2$）然后加 $1$，得到 $11010011_2$。用十六进制表示，这是 $0x\\mathrm{D3}$。\n    由于 $a$ 是有符号类型，ABI 要求将其符号扩展到 $64$ 位。其 $8$ 位表示（$11010011_2$）的最高有效位（MSB）是 $1$，所以我们必须在前面加上 $56$ 个 $1$。\n    寄存器 $\\mathrm{X0}$ 中得到的 $64$ 位值是：\n    $$ \\mathrm{X0} = 0x\\mathrm{FFFFFFFFFFFFFFD3} $$\n    这个 $64$ 位有符号整数的十进制值是 $-45$。\n\n*   **参数 `b` 到寄存器 $\\mathrm{X1}$：**\n    参数 $b$ 是一个值为 $0x\\mathrm{F234}$ 的无符号 $16$ 位整数。\n    由于 $b$ 是无符号类型，ABI 要求将其零扩展到 $64$ 位。我们在其 $16$ 位表示前加上 $48$ 个零。\n    寄存器 $\\mathrm{X1}$ 中得到的 $64$ 位值是：\n    $$ \\mathrm{X1} = 0x\\mathrm{000000000000F234} $$\n    这个整数的十进制值是 $0x\\mathrm{F234} = 15 \\cdot 16^3 + 2 \\cdot 16^2 + 3 \\cdot 16^1 + 4 \\cdot 16^0 = 61440 + 512 + 48 + 4 = 62004$。\n\n*   **参数 `c` 到寄存器 $\\mathrm{X2}$：**\n    参数 $c$ 是一个值为 $0x\\mathrm{80001234}$ 的有符号 $32$ 位整数。\n    由于 $c$ 是有符号类型，我们必须对其进行符号扩展。其 $32$ 位表示（$0x\\mathrm{8...}$）的最高有效位是 $1$，表示这是一个负数。因此，我们在前面加上 $32$ 个 $1$。\n    寄存器 $\\mathrm{X2}$ 中得到的 $64$ 位值是：\n    $$ \\mathrm{X2} = 0x\\mathrm{FFFFFFFF80001234} $$\n    为了找到 $c$ 的十进制值，我们可以解释这个 $32$ 位二进制补码数。其大小是 $0x\\mathrm{80001234}$ 的二进制补码，即 $2^{32} - 0x\\mathrm{80001234}$。或者，更简单地说，其值为 $-(2^{31} - 0x\\mathrm{00001234}) = -(2147483648 - 4660) = -2147478988$。\n\n**第 2 步：确定值 $x'$、$y'$ 和 $z'$**\n\n被调用者 $g$ 计算它自己参数的规范版本。\n\n*   **计算 $x'$：**\n    $g$ 通过取 $\\mathrm{X0}$ 的低 $8$ 位并将其符号扩展到 $64$ 位来计算 $x'$。$\\mathrm{X0}$ ($0x\\mathrm{FFFFFFFFFFFFFFD3}$) 的低 $8$ 位是 $0x\\mathrm{D3}$。$0x\\mathrm{D3}$ 的最高有效位是 $1$，所以符号扩展的结果是：\n    $$ x' = 0x\\mathrm{FFFFFFFFFFFFFFD3} $$\n    这与 $\\mathrm{X0}$ 中的值相同。$x'$ 的十进制值是 $-45$。\n\n*   **计算 $y'$：**\n    $g$ 通过取 $\\mathrm{X1}$ 的低 $16$ 位并将其零扩展到 $64$ 位来计算 $y'$。$\\mathrm{X1}$ ($0x\\mathrm{000000000000F234}$) 的低 $16$ 位是 $0x\\mathrm{F234}$。零扩展得到：\n    $$ y' = 0x\\mathrm{000000000000F234} $$\n    这与 $\\mathrm{X1}$ 中的值相同。$y'$ 的十进制值是 $62004$。\n\n*   **计算 $z'$：**\n    $g$ 通过取 $\\mathrm{X2}$ 的低 $32$ 位并将其符号扩展到 $64$ 位来计算 $z'$。$\\mathrm{X2}$ ($0x\\mathrm{FFFFFFFF80001234}$) 的低 $32$ 位是 $0x\\mathrm{80001234}$。其最高有效位是 $1$，所以符号扩展的结果是：\n    $$ z' = 0x\\mathrm{FFFFFFFF80001234} $$\n    这与 $\\mathrm{X2}$ 中的值相同。$z'$ 的十进制值是 $-2147478988$。\n\n**第 3 步：计算惩罚项 $P$**\n\n惩罚项 $P$ 定义为 $P = |\\mathrm{X0} - x'| + 2|\\mathrm{X1} - y'| + 3|\\mathrm{X2} - z'|$。由于调用者正确地遵循了 ABI 规则，它放入寄存器中的值已经被正确扩展。被调用者对低位的规范性重新扩展会产生完全相同的值。\n*   $\\mathrm{X0} - x' = 0x\\mathrm{FFFFFFFFFFFFFFD3} - 0x\\mathrm{FFFFFFFFFFFFFFD3} = 0$\n*   $\\mathrm{X1} - y' = 0x\\mathrm{000000000000F234} - 0x\\mathrm{000000000000F234} = 0$\n*   $\\mathrm{X2} - z' = 0x\\mathrm{FFFFFFFF80001234} - 0x\\mathrm{FFFFFFFF80001234} = 0$\n\n因此，惩罚项为：\n$$ P = |0| + 2|0| + 3|0| = 0 $$\n\n**第 4 步：计算最终返回值 $R$**\n\n最终返回值 $R$ 由公式 $R = x' + 2y' + 4z' + P$ 给出。我们代入找到的十进制值：\n*   $x' = -45$\n*   $y' = 62004$\n*   $z' = -2147478988$\n*   $P = 0$\n\n计算如下：\n$$ R = (-45) + 2(62004) + 4(-2147478988) + 0 $$\n$$ R = -45 + 124008 - 8589915952 $$\n$$ R = 123963 - 8589915952 $$\n$$ R = -8589791989 $$\n\n因此，确切的数值返回值为 $-8589791989$。",
            "answer": "$$ \\boxed{-8589791989} $$"
        },
        {
            "introduction": "这最后一个实践将调用约定的概念整合到一个完整的、端到端的间接函数调用模拟中，它追踪一个值从调用者到被调用者再返回的全过程。通过手动执行参数整理、模拟被调用者的算术运算，并根据特定的 ABI 处理返回值，您将巩固对机器代码层面整个过程调用生命周期的理解。",
            "id": "3678249",
            "problem": "编译器需要在一台遵循 System V 应用二进制接口 (ABI) 的 $64$-位小端序机器上，翻译一个通过函数指针进行的高级间接调用，该函数指针的签名为 $\\texttt{int (*p)(int)}$。该翻译必须确保类型安全的参数编组和正确的返回处理。考虑以下设定，其中只规定了在机器接口层面推导调用序列所需的基本操作事实：\n\n- 应用二进制接口 (ABI) 对整数参数和返回值使用以下约定：\n  - 一个 $\\texttt{int}$ 是一个 $32$-位二进制补码整数。\n  - 第一个整数参数通过寄存器 $\\mathrm{RDI}$ 的低 $32$ 位（即 $\\mathrm{EDI}$）传递。调用者必须通过将该 $\\texttt{int}$ 的精确 $32$-位二进制补码表示放入 $\\mathrm{EDI}$ 来编组参数。被调用者不假定 $\\mathrm{RDI}$ 高 $32$ 位的内容。\n  - 返回 $\\texttt{int}$ 的函数将其结果存放在 $\\mathrm{EAX}$ 中。写入 $\\mathrm{EAX}$ 会隐式地零扩展到 $\\mathrm{RAX}$。\n- 间接调用使用 $\\mathrm{RAX}$ 中的目标地址：该指令将控制权转移到 $\\mathrm{RAX}$ 中包含的地址处的代码，并将一个返回地址压入运行时栈。你可以假设返回地址和栈管理不影响任何与本问题相关的通用参数或返回寄存器。\n- 指令集架构 (ISA) 是小端序的；下面被调用函数中的所有算术运算都是在 $\\mathrm{EAX}$ 上以 $2^{32}$ 为模进行的。\n\n高级源代码包含：\n- 一个类型为 $\\texttt{int (*)(int)}$ 的函数指针 $\\texttt{p}$，存储在地址 $\\mathtt{0x0000000000403000}$。\n- 一个函数 $\\texttt{f}$，位于地址 $\\mathtt{0x0000000000401100}$。\n- 指针 $\\texttt{p}$ 被初始化为函数 $\\texttt{f}$ 的地址（即，地址 $\\mathtt{0x0000000000403000}$ 处的内存中存放着 $\\mathtt{0x0000000000401100}$ 的 $64$-位小端序编码）。\n- 一个调用表达式 $\\texttt{r = (*p)(a);}$，其中 $\\texttt{a}$ 是一个值为 $-123456789$ 的 $\\texttt{int}$。\n\n编译器生成一个标准的调用序列，该序列实现了类型安全的参数编组和正确的返回处理，并严格遵守上述 ABI 规则：\n- 它将 $\\texttt{p}$ 的 $64$-位值从内存加载到 $\\mathrm{RAX}$ 中。\n- 它将 $\\texttt{a}$ 的 $32$-位二进制补码表示移动到 $\\mathrm{EDI}$ 中。\n- 它通过 $\\mathrm{RAX}$ 执行间接调用。\n- 它从 $\\mathrm{EAX}$ 中读取 $\\texttt{int}$ 类型的返回值（该值因此在 $\\mathrm{RAX}$ 中被零扩展）。\n\n函数 $\\texttt{f}$ 的机器码体（在对 $\\mathrm{EAX}$ 可观察的算术效果层面上表述）如下：\n- 将参数 $\\mathrm{EDI}$ 复制到 $\\mathrm{EAX}$。\n- 计算 $\\mathrm{EAX} \\leftarrow (\\mathrm{EAX} \\times 3) \\bmod 2^{32}$。\n- 计算 $\\mathrm{EAX} \\leftarrow (\\mathrm{EAX} + 1) \\bmod 2^{32}$。\n- 计算 $\\mathrm{EAX} \\leftarrow \\mathrm{EAX} \\oplus \\mathtt{0x80000000}$。\n- 返回，将 $\\texttt{int}$ 结果留在 $\\mathrm{EAX}$ 中（并因此零扩展到 $\\mathrm{RAX}$）。\n\n在这些条件下，当调用返回到调用者后，$\\mathrm{RAX}$ 中保存的精确无符号 $64$-位整数值是多少？请用一个没有四舍五入的精确整数以十进制形式表示你的答案。",
            "solution": "任务是确定在函数调用 `r = (*p)(a);` 完成后，`RAX` 寄存器中的最终无符号 $64$-位整数值。这需要追踪参数 `a` 的值在函数 `f` 中定义的一系列操作中的变化。\n\n这个过程包含三个主要阶段：\n1.  根据指定的 `int` 表示，将参数 `a` 编组到 `EDI` 寄存器中。\n2.  在函数 `f` 内部对该值执行算术和位运算，这些运算操作 `EAX` 寄存器。\n3.  处理返回值，考虑从 `EAX`到 `RAX` 的零扩展规则。\n\n让我们逐步进行。\n\n**步骤 1：参数编组**\n\n参数 `a` 是一个值为 $-123456789$ 的 `int`。根据题目，`int` 是一个 $32$-位二进制补码整数。第一个整数参数在 `EDI` 寄存器中传递。我们必须首先找到 $-123456789$ 的 $32$-位二进制补码表示。\n\n首先，我们将正值 $123456789$ 表示为一个 $32$-位无符号十六进制整数。\n$$ 123456789_{10} = \\mathtt{0x075BCD15} $$\n为了找到 $-123456789$ 的二进制补码表示，我们对 $\\mathtt{0x075BCD15}$ 进行按位取反，然后加 $1$。\n$\\mathtt{0x075BCD15}$ 的 $32$-位表示是：\n$$ \\mathtt{0000\\;0111\\;0101\\;1011\\;1100\\;1101\\;0001\\;0101_2} $$\n该值的按位取反（反码）是：\n$$ \\mathtt{1111\\;1000\\;1010\\;0100\\;0011\\;0010\\;1110\\;1010_2} $$\n用十六进制表示，这是 $\\mathtt{0xF8A432EA}$。\n现在，我们给这个结果加 $1$：\n$$ \\mathtt{0xF8A432EA} + 1 = \\mathtt{0xF8A432EB} $$\n因此，$-123456789$ 的 $32$-位二进制补码表示是 $\\mathtt{0xF8A432EB}$。这个值被放入 `EDI` 寄存器中。\n$$ \\mathrm{EDI} \\leftarrow \\mathtt{0xF8A432EB} $$\n\n**步骤 2：执行函数 `f`**\n\n函数 `f` 执行一系列操作。参数从 `EDI` 传递到 `EAX`，所有后续的算术运算都在 `EAX` 上以 $2^{32}$ 为模进行。\n\n1.  **将 `EDI` 复制到 `EAX`**：\n    $$ \\mathrm{EAX} \\leftarrow \\mathrm{EDI} = \\mathtt{0xF8A432EB} $$\n\n2.  **计算 `EAX` $\\leftarrow$ (`EAX` $\\times$ $3$) mod $2^{32}$**：\n    我们将 `EAX` 中的值乘以 $3$。该乘法在 $32$-位整数上进行，我们保留结果的低 $32$ 位。\n    $$ \\mathtt{0xF8A432EB} \\times 3 $$\n    用十六进制进行乘法运算：\n    $$ \\mathrm{EAX} \\leftarrow \\mathtt{0xE9EC98C1} $$\n    另外，使用有符号十进制算术，`EAX` 中的初始值表示 $-123456789$。\n    $$ -123456789 \\times 3 = -370370367 $$\n    $-370370367$ 的 $32$-位二进制补码表示确实是 $\\mathtt{0xE9EC98C1}$，这证实了结果。\n\n3.  **计算 `EAX` $\\leftarrow$ (`EAX` + $1$) mod $2^{32}$**：\n    我们将 `EAX` 的当前值加 $1$。\n    $$ \\mathrm{EAX} \\leftarrow \\mathtt{0xE9EC98C1} + 1 = \\mathtt{0xE9EC98C2} $$\n\n4.  **计算 `EAX` $\\leftarrow$ `EAX` $\\oplus$ $\\mathtt{0x80000000}$**：\n    我们与常量 $\\mathtt{0x80000000}$ 进行按位异或 (XOR) 操作。这个常量只有最高有效位（第 $31$ 位）被设置为 $1$。因此，XOR 操作将翻转 `EAX` 的最高有效位，并保持所有其他位不变。\n    `EAX` 中的十六进制值是 $\\mathtt{0xE9EC98C2}$。最高有效的十六进制数字是 `E`，其二进制表示为 `1110`。该 $32$-位值的最高有效位是 $1$。\n    翻转此位会将最高有效的半字节从 `1110` (`E`) 变为 `0110` (`6`)。\n    $$ \\mathrm{EAX} \\leftarrow \\mathtt{0xE9EC98C2} \\oplus \\mathtt{0x80000000} = \\mathtt{0x69EC98C2} $$\n    函数 `f` 现在返回，`EAX` 中为这个值。\n\n**步骤 3：返回值处理**\n\n题目指出，返回 `int` 的函数将其结果放入 `EAX` 中，并且“写入 `EAX` 会隐式地零扩展到 `RAX`”。这是 $64$-位 x$86$ 架构上的一个标准行为。当 $32$-位 `EAX` 寄存器被修改时，$64$-位 `RAX` 寄存器的高 $32$ 位会被清零。\n\n因此，在 `f` 计算出其最终结果并将其放入 `EAX` 后，完整的 `RAX` 寄存器持有：\n$$ \\mathrm{RAX} \\leftarrow \\mathtt{0x0000000069EC98C2} $$\n然后函数将控制权返回给调用者。此时 `RAX` 中的值就是函数的返回值。\n\n**步骤 4：最终转换**\n\n问题要求 `RAX` 中的精确无符号 $64$-位整数值，并以十进制表示。我们必须将十六进制值 $\\mathtt{0x69EC98C2}$ 转换为十进制。\n$$ \\mathtt{0x69EC98C2} = (6 \\times 16^7) + (9 \\times 16^6) + (14 \\times 16^5) + (12 \\times 16^4) + (9 \\times 16^3) + (8 \\times 16^2) + (12 \\times 16^1) + (2 \\times 16^0) $$\n$$ = (6 \\times 268435456) + (9 \\times 16777216) + (14 \\times 1048576) + (12 \\times 65536) + (9 \\times 4096) + (8 \\times 256) + (12 \\times 16) + (2 \\times 1) $$\n$$ = 1610612736 + 150994944 + 14680064 + 786432 + 36864 + 2048 + 192 + 2 $$\n$$ = 1777113282 $$\n`RAX` 寄存器中的最终值为 $1777113282$。",
            "answer": "$$\\boxed{1777113282}$$"
        }
    ]
}