{
    "hands_on_practices": [
        {
            "introduction": "Compilers must not only translate logic correctly but also ensure program safety. This practice explores the crucial role of short-circuit evaluation in translating a common loop structure, where an array access is guarded by a bounds check . By generating control-flow code that respects the semantics of the `` operator, we can prevent costly runtime errors and then analyze the performance implications of this safe-by-construction approach.",
            "id": "3677647",
            "problem": "A compiler backend must translate the loop condition in the high-level statement\nwhile ((i < n) && a[i] != 0) { i := i + 1; }\ninto low-level control-flow that respects short-circuit evaluation, meaning the second conjunct is evaluated only if the first conjunct evaluates to true. Use the standard control-flow-oriented translation of boolean expressions into Three-Address Code (TAC) with explicit labels, ensuring that the bound check $i < n$ is always performed before the array access $a[i]$. Then, extend this translation to the canonicalized form of the equivalent for-loop:\nfor (i := i_0; (i < n) && (a[i] \\neq 0); i := i + 1) { /* empty body */ }\nwhere $i_0$ is the given initial value of $i$ and $0 \\le i_0 \\le n$.\n\nAssume the following probabilistic model of program inputs for the canonicalized for-loop:\n- The array segment $a[i_0], a[i_0+1], \\dots, a[n-1]$ consists of independent elements.\n- For each index $j \\in \\{i_0, i_0+1, \\dots, n-1\\}$, the event $a[j] = 0$ occurs with probability $p$, where $p \\in (0,1]$, and $a[j] \\neq 0$ otherwise.\n\nUnder this model, the translated TAC executes the test sequence in each iteration in short-circuit fashion: it checks $i < n$ first; only if true does it read and compare $a[i]$. Let $X$ be the random variable equal to the total number of array reads of the form $a[i]$ performed by this TAC until the loop exits.\n\nUsing only fundamental definitions of short-circuit evaluation and the semantics of TAC-generated control flow, together with the definition of mathematical expectation for a nonnegative, integer-valued random variable, derive a closed-form analytic expression for the expected value $\\mathbb{E}[X]$ as a function of $n$, $i_0$, and $p$. Express your final answer in simplest closed form. No rounding is required.",
            "solution": "The problem requires the derivation of the expected number of array reads for a loop with a short-circuiting condition, based on a probabilistic model of the array's contents. We begin by formalizing the control flow semantics implied by the problem statement and then proceed to the probabilistic analysis.\n\nFirst, we analyze the control flow generated for the boolean expression `(i < n) && (a[i] != 0)`. The `&&` operator implies short-circuit evaluation, meaning the second operand `a[i] != 0` is evaluated only if the first operand `i < n` is true. In a standard translation to Three-Address Code (TAC), this is implemented using conditional jumps. For a `while` loop of the form `while (B1 && B2) S`, the structure is as follows:\n\n`L_loop:`\n`  if not B1 goto L_exit`\n`  if not B2 goto L_exit`\n`  S`\n`  goto L_loop`\n`L_exit:`\n\nApplying this to the specific problem, with `B1` as `$i < n$` and `B2` as `$a[i] \\neq 0$`, and the body `S` as `$i := i + 1$`, the TAC would be:\n`L_loop:`\n`  t1 := i < n`\n`  if t1 = 0 goto L_exit`\n`  t2 := a[i]       ; Array read occurs here`\n`  t3 := t2 != 0`\n`  if t3 = 0 goto L_exit`\n`  i := i + 1`\n`  goto L_loop`\n`L_exit:`\n\nThis control flow explicitly confirms that the array access `a[i]` occurs only if the condition `$i < n$` is satisfied. This is the crucial semantic property we will use. The given `for`-loop is equivalent to an initialization `$i := i_0$` followed by this `while` loop structure.\n\nLet `$X$` be the random variable representing the total number of array reads. An array read takes the form `$a[i]$`. According to the control flow, an array read occurs during an iteration with a given value of `$i$` if and only if the test `$i < n$` evaluates to true. The loop starts with `$i = i_0$` and increments `$i$` in each successful iteration. The loop can potentially run for values of `$i$` from `$i_0$` up to `$n-1$`. If `$i$` reaches `$n$`, the condition `$i < n$` becomes false, and the loop terminates without an array read for that value of `$i$`.\n\nWe need to calculate the expected value of `$X$`, denoted `$\\mathbb{E}[X]$`. Since `$X$` is a non-negative, integer-valued random variable, its expectation can be calculated using the tail-sum formula:\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{\\infty} P(X \\ge k) $$\nThe number of array reads cannot exceed the number of possible values of `$i$` for which a read could occur, which is `$n - i_0$` (for `$i = i_0, i_0+1, \\dots, n-1$`). Therefore, the maximum value of `$X$` is `$n-i_0$`, and the sum is finite:\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{n-i_0} P(X \\ge k) $$\nNote that if `$i_0 \\ge n$`, the range of summation is empty, correctly yielding `$\\mathbb{E}[X] = 0$`, as the loop condition `$i < n$` is false initially. We will assume `$i_0 < n$` for the main derivation.\n\nLet's determine the probability `$P(X \\ge k)$` for an integer `$k$` where `$1 \\le k \\le n-i_0$`. The event `$X \\ge k$` means that at least `$k$` array reads are performed. The first read is `$a[i_0]`, the second is `$a[i_0+1]`, and the `$k$`-th read is `$a[i_0+k-1]$`.\nFor the `$k$`-th read (of `$a[i_0+k-1]`) to occur, two conditions must be met:\n1. The loop must not have terminated in any of the previous iterations for `$i = i_0, i_0+1, \\dots, i_0+k-2$`. This requires that the second part of the loop condition, `$a[i] \\neq 0$`, was true for all these values of `$i$`.\n2. The bounds check `$i < n$` must pass for the current iteration, i.e., `$i_0+k-1 < n$`. This is guaranteed by our summation limit `$k \\le n-i_0$`.\n\nThe condition for the `$k$`-th read to happen is thus `$a[j] \\neq 0$` for all `$j \\in \\{i_0, i_0+1, \\dots, i_0+k-2\\}$`. The probabilistic model states that for any `$j$`, `$P(a[j] \\neq 0) = 1 - p$`, and the events are independent. Therefore, the probability of this sequence of `$k-1$` events is:\n$$ P(X \\ge k) = \\prod_{j=i_0}^{i_0+k-2} P(a[j] \\neq 0) = (1-p)^{k-1} $$\nThis holds for `$1 \\le k \\le n-i_0$`. For `$k=1$`, the product is over an empty set, which is `$1$`, so `$P(X \\ge 1) = (1-p)^0 = 1$`, which is correct as `$a[i_0]$` is always read if `$i_0<n$`.\n\nNow we can substitute this back into the formula for the expectation:\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{n-i_0} (1-p)^{k-1} $$\nThis is a finite geometric series. Let's perform a change of index by setting `$j = k-1$`. When `$k=1$`, `$j=0$`. When `$k=n-i_0$`, `$j=n-i_0-1$`.\nThe sum becomes:\n$$ \\mathbb{E}[X] = \\sum_{j=0}^{n-i_0-1} (1-p)^j $$\nLet `$r = 1-p$`. The sum is $\\sum_{j=0}^{N} r^j$ where `$N = n-i_0-1$`. The number of terms is `$N+1 = n-i_0$`.\n\nWe analyze two cases for the value of `$p \\in (0,1]$`.\n\nCase 1: `$p=1$`.\nIn this case, `$r = 1-p = 0$`. The sum becomes:\n$$ \\mathbb{E}[X] = \\sum_{j=0}^{n-i_0-1} 0^j = 0^0 + 0^1 + 0^2 + \\dots $$\nBy convention, `$0^0=1$`. All other terms are `$0$`. Thus, if `$n-i_0-1 \\ge 0$` (i.e. `$n>i_0$`), the sum is `$1$`. If `$n \\le i_0$`, the sum is empty and equals `$0$`. This aligns with the physical situation: if `$p=1$`, the first array element read, `$a[i_0]$`, will be `$0$` with certainty, causing the loop to terminate. Thus, exactly one read occurs if the loop starts (`$i_0<n$`), and zero reads occur otherwise.\n\nCase 2: `$p \\in (0,1)$`.\nIn this case, `$r = 1-p \\in (0,1)` and is not equal to `$1$`. We can use the standard formula for a finite geometric series: `$\\sum_{j=0}^{N} r^j = \\frac{1-r^{N+1}}{1-r}$`.\nSubstituting `$r=1-p$` and `$N+1 = n-i_0$`:\n$$ \\mathbb{E}[X] = \\frac{1 - (1-p)^{n-i_0}}{1 - (1-p)} = \\frac{1 - (1-p)^{n-i_0}}{p} $$\n\nThis single expression also correctly handles the edge cases.\n- If `$p=1$`, and `$i_0 < n$`, the expression gives `$\\frac{1 - (0)^{n-i_0}}{1} = 1$`.\n- If `$i_0 = n$`, the exponent `$n-i_0 = 0$`, and the expression becomes `$\\frac{1-(1-p)^0}{p} = \\frac{1-1}{p} = 0$`.\nBoth results match our analysis. Thus, the derived expression is valid for all `$p \\in (0,1]$` and `$0 \\le i_0 \\le n$`.\n\nThe expression is in its simplest closed form.",
            "answer": "$$ \\boxed{\\frac{1 - (1-p)^{n-i_0}}{p}} $$"
        },
        {
            "introduction": "Once we understand the target control flow, the next question is how to generate it efficiently. This exercise delves into the mechanics of backpatching, a powerful technique for translating boolean expressions in a single pass . You will compare two distinct strategies for handling logical negation, discovering how a clever manipulation of internal data structures can be more efficient than generating additional code.",
            "id": "3677573",
            "problem": "Consider an imperative language translated to Intermediate Representation (IR), where boolean expressions are compiled using short-circuit evaluation and the backpatching method. In this method, each boolean subexpression is represented by two lists of forward branches, a true list and a false list, denoted by $TL(\\cdot)$ and $FL(\\cdot)$, respectively. Each element in these lists is one unresolved branch that will later be backpatched to a concrete label when control destinations become known. A backpatch operation is defined as the act of filling one unresolved branch target with a concrete label; each unresolved jump counts as one backpatch operation when it is resolved.\n\nYou are to translate a statement of the form $if\\ (!(A\\ \\wedge\\ B))$ using short-circuit evaluation. Two strategies are considered:\n\n- Strategy $\\mathsf{Swap}$: Translate $A \\wedge B$ using short-circuit control flow and implement logical negation by flipping the true and false lists of the resulting expression, without introducing any additional IR nodes or branch instructions for the negation.\n\n- Strategy $\\mathsf{NegNode}$: Translate $A \\wedge B$ to produce code with explicit temporary true and false labels for the conjunction’s outcome, then materialize the logical negation as a separate IR node that, at those temporary labels, emits forward branches to the final then and else destinations. The final then/else destinations are not known at the time the negation node is emitted, so these two branches are forward branches that must be backpatched later.\n\nAssume the following properties of the subexpressions $A$ and $B$, based on their internal structure and the standard short-circuit translation of relational atoms into $if\\ \\cdots\\ goto\\ L_{true};\\ goto\\ L_{false}$ form:\n\n- $|TL(A)| = 3$, $|FL(A)| = 2$.\n- $|TL(B)| = 4$, $|FL(B)| = 3$.\n\nUnder short-circuit evaluation of $A \\wedge B$, evaluating $B$ occurs only when $A$ evaluates to true, which implies that all entries in $TL(A)$ must be backpatched to the entry label of $B$. After building the conjunction, $TL(A \\wedge B)$ is the set of forward branches that reach the overall true outcome of the conjunction, and $FL(A \\wedge B)$ is the set that reach the overall false outcome.\n\nUsing the definitions above and these cardinalities, compute the total number of backpatch operations required for Strategy $\\mathsf{Swap}$ and Strategy $\\mathsf{NegNode}$, and then compute the savings (defined as the number of backpatch operations in Strategy $\\mathsf{NegNode}$ minus the number in Strategy $\\mathsf{Swap}$). Express your final answer as a single integer with no units. No rounding is needed; report the exact integer.",
            "solution": "The problem requires an analysis of the total number of backpatch operations for two different compiler strategies for translating the statement `if (!(A \\wedge B))`. A backpatch operation is defined as the resolution of a single unresolved forward branch. Therefore, the total number of backpatch operations is equivalent to the total number of unresolved forward branches created and resolved during the compilation process.\n\nFirst, we establish the semantics of short-circuit evaluation for a conjunction $E = A \\wedge B$. The control flow dictates that $B$ is evaluated only if $A$ is true. If $A$ is false, the entire expression is false.\n1.  The branches in the true list of $A$, $TL(A)$, must be resolved to target the entry point of the code for subexpression $B$. This constitutes a set of backpatch operations, numbering $|TL(A)|$.\n2.  The true list for the combined expression $E$, $TL(E)$, consists of only those branches that make the entire expression true. This occurs only if both $A$ and $B$ are true. Thus, $TL(A \\wedge B) = TL(B)$.\n3.  The false list for the combined expression $E$, $FL(E)$, consists of any branch that makes the expression false. This occurs if $A$ is false, or if $A$ is true and $B$ is false. Thus, $FL(A \\wedge B)$ is the union of the false lists of its components: $FL(A \\wedge B) = FL(A) \\cup FL(B)$. The subexpressions $A$ and $B$ are distinct, so their lists of jumps are disjoint. The cardinality is $|FL(A \\wedge B)| = |FL(A)| + |FL(B)|$.\n\nThe given cardinalities for the subexpressions are:\n- $|TL(A)| = 3$\n- $|FL(A)| = 2$\n- $|TL(B)| = 4$\n- $|FL(B)| = 3$\n\nThe total number of unresolved branches originating from the atomic translation of $A$ and $B$ is $|TL(A)| + |FL(A)| + |TL(B)| + |FL(B)| = 3 + 2 + 4 + 3 = 12$.\n\nWe now analyze each strategy.\n\n**Strategy $\\mathsf{Swap}$**\n\nThis strategy first computes the lists for $A \\wedge B$ and then swaps them to implement the logical negation.\n1.  **Code Generation:** The translation of subexpressions $A$ and $B$ introduces a total of $12$ unresolved branches, as calculated above. The $\\mathsf{Swap}$ strategy does not introduce any new branches; it only re-purposes the existing ones. Therefore, the total number of backpatch operations must be exactly $12$. We can verify this by tracing their resolution.\n2.  **Internal Backpatching:** To form the code for $A \\wedge B$, the branches in $TL(A)$ are backpatched to the beginning of the code for $B$. This requires $|TL(A)| = 3$ backpatch operations.\n3.  **Final List Resolution:** The `if` statement evaluates the condition $C = !(A \\wedge B)$.\n    - The true list for $C$, $TL(C)$, is obtained by swapping, so $TL(C) = FL(A \\wedge B) = FL(A) \\cup FL(B)$. These branches are backpatched to the `then` clause. The number of operations is $|FL(A)| + |FL(B)| = 2 + 3 = 5$.\n    - The false list for $C$, $FL(C)$, is similarly $FL(C) = TL(A \\wedge B) = TL(B)$. These branches are backpatched to the `else` clause. The number of operations is $|TL(B)| = 4$.\n4.  **Total Operations:** The total number of backpatch operations for Strategy $\\mathsf{Swap}$, denoted $N_{\\mathsf{Swap}}$, is the sum of all resolved branches.\n    $$N_{\\mathsf{Swap}} = |TL(A)| + (|FL(A)| + |FL(B)|) + |TL(B)|$$\n    $$N_{\\mathsf{Swap}} = 3 + (2 + 3) + 4 = 3 + 5 + 4 = 12$$\n    This confirms that all $12$ initial unresolved branches are resolved.\n\n**Strategy $\\mathsf{NegNode}$**\n\nThis strategy first resolves the true and false outcomes of $A \\wedge B$ to temporary labels and then generates new branches for the negation.\n1.  **Code Generation and Internal Resolution:** As before, translating $A$ and $B$ creates $12$ initial unresolved branches. This strategy resolves all of them internally and then creates new ones.\n    - Backpatching $TL(A)$ to the entry of $B$: $|TL(A)| = 3$ operations.\n    - The lists for $A \\wedge B$ are $TL(A \\wedge B)=TL(B)$ and $FL(A \\wedge B)=FL(A) \\cup FL(B)$.\n    - Backpatching $TL(A \\wedge B)$ to a temporary true label $L_{true\\_temp}$: $|TL(B)| = 4$ operations.\n    - Backpatching $FL(A \\wedge B)$ to a temporary false label $L_{false\\_temp}$: $|FL(A)| + |FL(B)| = 2 + 3 = 5$ operations.\n    - At this point, all $3 + 4 + 5 = 12$ of the original unresolved branches have been backpatched.\n2.  **Negation Node Generation:** The `NegNode` itself generates new code and new unresolved branches at the temporary labels.\n    - At $L_{true\\_temp}$ (where $A \\wedge B$ is true), the negation `!` makes the outcome false. A new branch `goto L_final_else` is created. This is $1$ new unresolved branch.\n    - At $L_{false\\_temp}$ (where $A \\wedge B$ is false), the negation `!` makes the outcome true. A new branch `goto L_final_true` is created. This is a $2^{nd}$ new unresolved branch.\n3.  **Final List Resolution:** These two new branches form the final true and false lists for the condition $C = !(A \\wedge B)$.\n    - $TL(C)$ contains the one branch to `L_final_true`. Backpatching this to the `then` clause requires $1$ operation.\n    - $FL(C)$ contains the one branch to `L_final_false`. Backpatching this to the `else` clause requires $1$ operation.\n4.  **Total Operations:** The total number of backpatch operations for Strategy $\\mathsf{NegNode}$, $N_{\\mathsf{NegNode}}$, is the sum of operations for resolving the initial branches and the newly generated branches.\n    $$N_{\\mathsf{NegNode}} = (\\text{ops for initial branches}) + (\\text{ops for new branches})$$\n    $$N_{\\mathsf{NegNode}} = (|TL(A)| + |TL(B)| + |FL(A)| + |FL(B)|) + 2$$\n    $$N_{\\mathsf{NegNode}} = (3 + 4 + 2 + 3) + 2 = 12 + 2 = 14$$\n\n**Calculation of Savings**\n\nThe problem defines savings as the number of backpatch operations in Strategy $\\mathsf{NegNode}$ minus the number in Strategy $\\mathsf{Swap}$.\n$$Savings = N_{\\mathsf{NegNode}} - N_{\\mathsf{Swap}}$$\n$$Savings = 14 - 12 = 2$$\nThe $\\mathsf{NegNode}$ strategy requires $2$ more backpatch operations than the $\\mathsf{Swap}$ strategy, resulting in a saving of $2$ for the latter over the former.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Can a compiler's translation algorithm be as \"smart\" as a human applying logical identities? This problem investigates that question by comparing two paths to compiling a boolean expression: one that starts with algebraic simplification using De Morgan’s laws, and another that translates the expression directly . The result reveals an elegant principle where the structure of a good syntax-directed translation algorithm naturally mirrors the rules of logic, leading to optimal control flow without a separate optimization step.",
            "id": "3677653",
            "problem": "Consider the boolean expression $E = \\neg(A \\lor B) \\land C$ to be compiled into low-level control-flow using short-circuit evaluation within an Intermediate Representation (IR). Assume the following foundational bases:\n- Boolean short-circuit semantics: For $X \\lor Y$, if $X$ is true, $Y$ is not evaluated; for $X \\land Y$, if $X$ is false, $Y$ is not evaluated. For $\\neg X$, the truth value is inverted without changing evaluation order.\n- De Morgan’s laws: $\\neg(A \\lor B) \\equiv (\\neg A) \\land (\\neg B)$.\n- A standard backpatching-style translation for boolean expressions to labeled control flow: each primitive condition $X \\in \\{A,B,C\\}$ is compiled to one conditional branch of the form “if $X$ goto $L_{\\text{t}}$” with fall-through to $L_{\\text{f}}$, and labels are patched to realize short-circuit behavior.\n\nAssume that $A$, $B$, and $C$ are independent primitive tests, each compiled to exactly one conditional branch instruction when evaluated. An unconditional jump may be used to connect blocks but does not count toward the branch count in this problem. Define:\n- The branch count as the expected number of conditional branch instructions executed during one evaluation of $E$.\n- A taken branch as a conditional branch whose target is taken (i.e., control transfers to the branch target); a fall-through occurs when the conditional branch is not taken and execution continues to the next sequential instruction.\n\nUse the following layout constraint to make measurement consistent across both translations: place the final false label $L_{\\text{false}}$ immediately after the last test so that if the last test determines the expression is false, evaluation completes by fall-through. The final true label $L_{\\text{true}}$ may be reached by a conditional branch. Assume the probabilities of $A$, $B$, and $C$ being true at runtime are $p_A$, $p_B$, and $p_C$, respectively, with $0 \\leq p_A, p_B, p_C \\leq 1$, and all independence assumptions hold.\n\nTasks:\n1. Derive a short-circuit code sequence for $E$ by first rewriting $E$ using De Morgan’s laws to $(\\neg A) \\land (\\neg B) \\land C$ and then translating to IR with conditional branches and labels satisfying the short-circuit semantics and the given layout constraint.\n2. Derive a direct short-circuit code sequence for $E$ without algebraic rewriting, translating $\\neg(A \\lor B) \\land C$ to IR using backpatching lists for true and false exits and the same layout constraint.\n3. For each translation, starting strictly from the short-circuit semantics and independence of $A$, $B$, and $C$, compute the expected branch count as a function of $p_A$, $p_B$, and $p_C$, and simplify.\n4. Report, as your final answer, the difference between the expected branch counts of the De Morgan translation and the direct short-circuit translation as a single closed-form expression in terms of $p_A$, $p_B$, and $p_C$. No rounding is required. Express your final answer as an analytical expression with no units.\n\nYour final answer must be a single analytical expression.",
            "solution": "The problem requires a comparison of the expected number of conditional branches executed for two different compilations of the boolean expression $E = \\neg(A \\lor B) \\land C$. The probabilities of the primitive tests $A$, $B$, and $C$ being true are given as $p_A$, $p_B$, and $p_C$, respectively, and these events are independent.\n\n### 1. Translation of the De Morgan's Form: $E_1 = (\\neg A) \\land (\\neg B) \\land C$\n\nFirst, we apply De Morgan's laws to rewrite the expression as $E_1 = (\\neg A) \\land (\\neg B) \\land C$. This is a conjunction of three terms. According to short-circuit semantics for the logical AND ($\\land$) operator, evaluation proceeds from left to right and stops as soon as a term evaluates to false. The entire expression is true only if all terms are true.\n\nWe translate this into a sequence of conditional branches. The goal is to reach a label $L_{\\text{true}}$ if $E_1$ is true, and a label $L_{\\text{false}}$ if $E_1$ is false.\n\n1.  Evaluate the first term, $\\neg A$. For $\\neg A$ to be true, $A$ must be false. If $A$ is true, then $\\neg A$ is false, and the entire conjunction $E_1$ is false. Therefore, the first test is: `if A is true, go to L_false`.\n2.  If the first test falls through, it means $A$ is false, so $\\neg A$ is true. We proceed to the second term, $\\neg B$. For $\\neg B$ to be true, $B$ must be false. If $B$ is true, then $\\neg B$ is false, and $E_1$ is false. The second test is: `if B is true, go to L_false`.\n3.  If the second test falls through, it means $A$ and $B$ are both false, so $(\\neg A) \\land (\\neg B)$ is true. We proceed to the final term, $C$. If $C$ is true, the entire expression $E_1$ is true. The final test is: `if C is true, go to L_true`.\n4.  If the test for $C$ is not taken (i.e., $C$ is false), the expression $E_1$ is false. The problem specifies a layout constraint where $L_{\\text{false}}$ immediately follows the last test, so this case is handled by a fall-through.\n\nThe resulting intermediate code sequence is:\n```\n    if A goto L_false      // Branch 1\n    if B goto L_false      // Branch 2\n    if C goto L_true       // Branch 3\nL_false:\n    // Code for when the expression is false.\n    // An unconditional jump might be needed here to bypass the true block.\n    // ...\nL_true:\n    // Code for when the expression is true.\n```\nLet $\\mathbb{E}_1$ be the expected number of conditional branches executed for this translation. Using the principle of linearity of expectation, $\\mathbb{E}_1$ is the sum of the probabilities that each branch is executed.\n- Branch $1$ (`if A...`) is always executed. Its contribution to the expected value is $1$.\n- Branch $2$ (`if B...`) is executed only if the first test falls through, which occurs when $A$ is false. The probability of this is $P(\\neg A) = 1 - p_A$.\n- Branch $3$ (`if C...`) is executed only if the first two tests fall through, which occurs when $A$ is false AND $B$ is false. Due to independence, the probability is $P(\\neg A \\land \\neg B) = P(\\neg A)P(\\neg B) = (1-p_A)(1-p_B)$.\n\nSumming these probabilities gives the expected branch count $\\mathbb{E}_1$:\n$$ \\mathbb{E}_1 = 1 + P(\\neg A) + P(\\neg A \\land \\neg B) $$\n$$ \\mathbb{E}_1 = 1 + (1 - p_A) + (1 - p_A)(1 - p_B) $$\nWe can simplify this expression:\n$$ \\mathbb{E}_1 = 1 + (1 - p_A)(1 + (1 - p_B)) $$\n$$ \\mathbb{E}_1 = 1 + (1 - p_A)(2 - p_B) $$\n$$ \\mathbb{E}_1 = 1 + 2 - p_B - 2p_A + p_A p_B $$\n$$ \\mathbb{E}_1 = 3 - 2p_A - p_B + p_A p_B $$\n\n### 2. Direct Translation of $E_2 = \\neg(A \\lor B) \\land C$\n\nNow, we consider the direct translation of the original expression $E_2 = \\neg(A \\lor B) \\land C$ without algebraic rewriting, using backpatching semantics. The expression has the form $X \\land Y$, where $X = \\neg(A \\lor B)$ and $Y = C$.\n\n1.  For a conjunction $X \\land Y$, we first evaluate $X$. If $X$ is false, the entire expression is false, and we short-circuit. In our case, $X = \\neg(A \\lor B)$ is false if and only if $(A \\lor B)$ is true.\n2.  To test if $(A \\lor B)$ is true using short-circuiting, we first test $A$. If $A$ is true, then $(A \\lor B)$ is true, so $\\neg(A \\lor B)$ is false, and the entire expression $E_2$ is false. We branch to $L_{\\text{false}}$.\n3.  If $A$ is false, we must test $B$. If $B$ is true, then $(A \\lor B)$ is true, so $\\neg(A \\lor B)$ is false, and $E_2$ is false. We again branch to $L_{\\text{false}}$.\n4.  If we fall through both tests on $A$ and $B$, it means both were false. In this case, $(A \\lor B)$ is false, which means $X = \\neg(A \\lor B)$ is true. We must then proceed to evaluate $Y = C$.\n5.  We test $C$. If $C$ is true, the entire expression $E_2$ is true. We branch to $L_{\\text{true}}$.\n6.  If $C$ is false, the expression is false. As per the layout constraint, this corresponds to falling through to $L_{\\text{false}}$.\n\nThe resulting intermediate code sequence is:\n```\n    if A goto L_false      // Branch 1\n    if B goto L_false      // Branch 2\n    if C goto L_true       // Branch 3\nL_false:\n    // ...\n```\nThis code sequence is identical to the one generated for the De Morgan's form $E_1$. This is not a coincidence; a standard compiler's syntax-directed translation mechanism (like backpatching) for boolean expressions is designed to generate optimal control flow that directly reflects the logical semantics. Logically equivalent expressions, such as $E_1$ and $E_2$, naturally translate into identical control flow graphs.\n\nSince the code sequences are identical, the conditions under which each branch is executed are also identical. Therefore, the expected number of branches executed, $\\mathbb{E}_2$, must be the same as $\\mathbb{E}_1$.\n$$ \\mathbb{E}_2 = \\mathbb{E}_1 = 3 - 2p_A - p_B + p_A p_B $$\n\n### 3. Difference in Expected Branch Counts\n\nThe problem asks for the difference between the expected branch counts of the two translations, $\\mathbb{E}_1 - \\mathbb{E}_2$.\nSince we have rigorously established that $\\mathbb{E}_1 = \\mathbb{E}_2$, the difference is:\n$$ \\mathbb{E}_1 - \\mathbb{E}_2 = (3 - 2p_A - p_B + p_A p_B) - (3 - 2p_A - p_B + p_A p_B) = 0 $$\nThe difference is zero, irrespective of the values of $p_A$, $p_B$, and $p_C$. This indicates that for the given translation scheme, applying De Morgan's law as a preliminary algebraic optimization step yields no performance difference in terms of the number of conditional branches executed for this particular expression.",
            "answer": "$$\n\\boxed{0}\n$$"
        }
    ]
}