{
    "hands_on_practices": [
        {
            "introduction": "像 Python 这样的语言支持链式比较（例如 $a \\lt b \\lt c$），这为程序员提供了便利。然而，编译这种表达式需要仔细考虑，以确保共享操作数（如 $b$）只被求值一次，并正确实现短路行为。这项练习将指导你生成高效的三地址码，并进一步分析其在概率模型下的预期执行成本，从而揭示编译器优化对程序性能的直接影响。",
            "id": "3677567",
            "problem": "一个编译器前端的目标是一种带有条件和无条件跳转的三地址中间表示，并对布尔表达式使用短路求值。源语言的链式比较语义与 Python 的语义相匹配：表达式 $a  b  c  d$ 在逻辑上等价于 $(a  b) \\wedge (b  c) \\wedge (c  d)$，并具有以下操作约束：操作数从左到右求值，中间操作数（如 $b$ 或 $c$）只求值一次并在相邻的比较中被重用，且一旦结果确定，求值就会短路。假设操作数的求值可能会产生副作用，因此禁止重新计算 $b$ 或 $c$。\n\n任务：\n- 推导一个短路三地址代码序列，用于计算 $a  b  c  d$ 的布尔值并存入目标临时变量 $t_{\\mathrm{res}}$ 中，其中布尔值用 $1$ (真) 和 $0$ (假) 表示。你的代码序列必须：\n  - 严格从左到右对操作数 $a$、$b$、$c$ 和 $d$ 进行求值，每个操作数最多求值一次。\n  - 通过重用临时变量来避免对 $b$ 和 $c$ 的重新计算。\n  - 使用条件分支，在第一个失败的比较处进行短路。\n  - 当且仅当链式比较成立时，将 $t_{\\mathrm{res}}$ 设置为 $1$，否则将其设置为 $0$，然后跳转到一个公共退出标签。\n\n- 在一个成本模型下，每个操作数的求值成本为零，每次基本比较 $x  y$ 的成本为单位成本。假设事件 $(a  b)$、$(b  c)$ 和 $(c  d)$ 是独立的，其概率分别为 $\\Pr(a  b) = p_{ab}$、$\\Pr(b  c) = p_{bc}$ 和 $\\Pr(c  d) = p_{cd}$。利用上述操作语义和你的代码结构，推导出一个关于 $p_{ab}$、$p_{bc}$ 和 $p_{cd}$ 的函数，表示所执行的基本比较次数的期望值的闭式解析表达式。将此表达式作为你的最终答案。无需进行四舍五入。",
            "solution": "该问题是有效的，因为它科学地基于编译器设计原理，信息充分且一致，问题陈述良构且客观。它提出了一个可形式化的任务，并且有唯一可推导的解。\n\n该任务包含两部分。第一，根据特定的操作语义，为链式比较 $a  b  c  d$ 推导一个三地址代码序列。第二，基于给定的概率模型，计算执行的基本比较的期望次数。\n\n### 第一部分：三地址代码生成\n\n表达式 $a  b  c  d$ 等价于 $(a  b) \\wedge (b  c) \\wedge (c  d)$。操作语义要求短路求值、从左到右的操作数求值以及共享操作数（$b$ 和 $c$）的单次求值。我们可以使用条件分支来实现这一点。如果合取中的任何一个比较不成立，整个表达式就为假，我们可以立即跳转到处理假值情况的位置。\n\n设 $t_{\\mathrm{res}}$ 为存放结果的目标临时变量，其中 $1$ 代表真，$0$ 代表假。对操作数 $a、b、c、d$ 的求值可能有副作用，因此必须按顺序且仅求值一次。我们可以将它们的值存储在临时变量 $t_a, t_b, t_c, t_d$ 中，不过为了最终代码的简洁，我们可以假设三地址代码求值器会处理所需的单次求值，从而直接使用操作数。关键在于控制流。\n\n一个合适的三地址代码序列如下。我们定义两个标签：`L_false` 用于表达式求值为假的情况，`L_end` 用于公共退出点。\n\n1.  进行第一次比较，$a  b$。如果为假，则整个表达式为假。\n    `if a  b goto L1`\n    `goto L_false`\n\n2.  `L1:` 进行第二次比较，$b  c$。这里重用了操作数 $b$。如果为假，则表达式为假。\n    `if b  c goto L2`\n    `goto L_false`\n\n3.  `L2:` 进行第三次比较，$c  d$。这里重用了操作数 $c$。如果为假，则表达式为假。\n    `if c  d goto L_true`\n    `goto L_false`\n\n4.  `L_true:` 如果控制流到达此点，则所有比较都已成功。表达式为真。\n    `t_res = 1`\n    `goto L_end`\n\n5.  `L_false:` 如果任何比较失败，控制流会跳转到此处。表达式为假。\n    `t_res = 0`\n\n6.  `L_end:` 后续代码的公共退出点。\n\n这个序列可以写得更紧凑，这对于中间表示来说是典型的：\n\n`if not (a  b) goto L_false`\n`if not (b  c) goto L_false`\n`if not (c  d) goto L_false`\n`t_res = 1`\n`goto L_end`\n`L_false: t_res = 0`\n`L_end: ...`\n\n这种结构正确地实现了指定的短路语义。比较 $(a  b)$、$(b  c)$ 和 $(c  d)$ 是顺序执行的，求值在第一个返回假值的比较处停止。\n\n### 第二部分：期望比较次数\n\n设 $N$ 是表示执行的基本比较次数的随机变量。成本模型为每次比较分配成本 $1$，为操作数求值分配成本 $0$。给定每个比较为真的概率作为独立事件：$\\Pr(a  b) = p_{ab}$，$\\Pr(b  c) = p_{bc}$，以及 $\\Pr(c  d) = p_{cd}$。\n\n我们可以通过使用期望的线性性质来确定 $N$ 的期望值，记作 $E[N]$。设 $I_k$ 是一个指示随机变量，表示第 $k$ 次比较被执行的事件。\n-   如果比较 $(a  b)$ 被执行，则 $I_1 = 1$，否则 $I_1 = 0$。\n-   如果比较 $(b  c)$ 被执行，则 $I_2 = 1$，否则 $I_2 = 0$。\n-   如果比较 $(c  d)$ 被执行，则 $I_3 = 1$，否则 $I_3 = 0$。\n\n总比较次数为 $N = I_1 + I_2 + I_3$。\n根据期望的线性性质，$E[N] = E[I_1] + E[I_2] + E[I_3]$。指示变量的期望是它所指示事件的概率，所以 $E[I_k] = \\Pr(I_k = 1)$。\n\n1.  **$I_1$ 的期望值**：第一次比较 $(a  b)$ 总是被执行。因此，它被执行的概率是 $1$。\n    $$E[I_1] = \\Pr(I_1 = 1) = 1$$\n\n2.  **$I_2$ 的期望值**：第二次比较 $(b  c)$ 仅在第一次比较 $(a  b)$ 求值为真时才执行。根据短路规则，如果 $(a  b)$ 为假，求值就会终止。\n    $$E[I_2] = \\Pr(I_2 = 1) = \\Pr(a  b) = p_{ab}$$\n\n3.  **$I_3$ 的期望值**：第三次比较 $(c  d)$ 仅在第一次比较 $(a  b)$ 和第二次比较 $(b  c)$ 都求值为真时才执行。\n    $$E[I_3] = \\Pr(I_3 = 1) = \\Pr((a  b) \\wedge (b  c))$$\n    由于给定事件是独立的，我们可以将它们的概率相乘：\n    $$\\Pr((a  b) \\wedge (b  c)) = \\Pr(a  b) \\cdot \\Pr(b  c) = p_{ab} p_{bc}$$\n    因此，\n    $$E[I_3] = p_{ab} p_{bc}$$\n\n总的期望比较次数是这些期望值的和：\n$$E[N] = E[I_1] + E[I_2] + E[I_3]$$\n$$E[N] = 1 + p_{ab} + p_{ab}p_{bc}$$\n\n这是期望比较次数的闭式解析表达式。值得注意的是，概率 $p_{cd}$ 没有出现在表达式中。这是正确的，因为执行的比较*次数*仅取决于前两次比较的结果，而与第三次比较无关。第三次比较如果被执行，则无论其结果如何都会执行。$p_{cd}$ 的值与计算整个表达式为真的概率有关，但与此成本模型下求值步骤的期望次数无关。",
            "answer": "$$\\boxed{1 + p_{ab} + p_{ab}p_{bc}}$$"
        },
        {
            "introduction": "在理解了需要生成什么样的控制流之后，我们来深入探讨编译器是如何通过“回填”技术具体实现这一点的。本练习将对比两种处理逻辑非（`!`）的策略：一种是直接交换真假出口列表，另一种是生成显式的求反节点。通过计算两种策略所需的回填操作数量，你将亲身体会到，精巧地操纵跳转列表比生成额外代码更为高效，这正是编译器内部优化的一个缩影。",
            "id": "3677573",
            "problem": "考虑一种命令式语言，它被翻译成中间表示（IR），其中布尔表达式使用短路求值和回填方法进行编译。在这种方法中，每个布尔子表达式由两个前向分支列表表示：一个真列表和一个假列表，分别表示为 $TL(\\cdot)$ 和 $FL(\\cdot)$。这些列表中的每个元素都是一个未解析的分支，当控制流目标已知时，该分支将被回填到一个具体标号。一次回填操作定义为用一个具体标号填充一个未解析分支目标的行为；每个未解析的跳转在被解析时计为一次回填操作。\n\n你需要使用短路求值来翻译一个形如 `if ` $\\neg(A \\wedge B)$ 的语句。考虑以下两种策略：\n\n- $\\mathsf{Swap}$ 策略：使用短路控制流翻译 $A \\wedge B$，并通过翻转结果表达式的真假列表来实现逻辑非，而不为该否定操作引入任何额外的IR节点或分支指令。\n\n- $\\mathsf{NegNode}$ 策略：翻译 $A \\wedge B$ 以生成带有显式临时真假标号的代码来表示合取式的结果，然后将逻辑非具体化为一个单独的IR节点，该节点在这些临时标号处，向最终的then和else目标发出前向分支。在生成否定节点时，最终的then/else目标是未知的，因此这两个分支是必须在稍后被回填的前向分支。\n\n假设子表达式 $A$ 和 $B$ 具有以下属性，这些属性基于它们的内部结构以及将关系原子标准短路翻译为 `if ... goto L_true; goto L_false` 形式：\n\n- $|TL(A)| = 3$, $|FL(A)| = 2$.\n- $|TL(B)| = 4$, $|FL(B)| = 3$.\n\n在对 $A \\wedge B$ 进行短路求值时，只有当 $A$ 的求值为真时才会对 $B$ 进行求值，这意味着 $TL(A)$ 中的所有条目都必须回填到 $B$ 的入口标号。构建合取式后，$TL(A \\wedge B)$ 是到达合取式整体真结果的前向分支集合，而 $FL(A \\wedge B)$ 是到达整体假结果的集合。\n\n使用上述定义和这些基数，计算$\\mathsf{Swap}$策略和$\\mathsf{NegNode}$策略所需的总回填操作数，然后计算节省量（定义为$\\mathsf{NegNode}$策略中的回填操作数减去$\\mathsf{Swap}$策略中的回填操作数）。请用一个没有单位的整数表示最终答案。无需四舍五入，报告精确的整数值。",
            "solution": "该问题要求分析两种不同的编译器策略在翻译语句 `if ` $\\neg(A \\wedge B)$ 时所需的回填操作总数。一次回填操作被定义为解析一个单一的未解析前向分支。因此，回填操作的总数等同于在编译过程中创建和解析的未解析前向分支的总数。\n\n首先，我们确定合取式 $E = A \\wedge B$ 的短路求值语义。控制流规定，只有当 $A$ 为真时才对 $B$ 进行求值。如果 $A$ 为假，则整个表达式为假。\n1.  $A$ 的真列表 $TL(A)$ 中的分支必须被解析，以指向子表达式 $B$ 代码的入口点。这构成了一组回填操作，数量为 $|TL(A)|$。\n2.  组合表达式 $E$ 的真列表 $TL(E)$ 仅由那些使整个表达式为真的分支组成。这种情况只在 $A$ 和 $B$ 都为真时发生。因此，$TL(A \\wedge B) = TL(B)$。\n3.  组合表达式 $E$ 的假列表 $FL(E)$ 由任何使表达式为假的分支组成。这种情况在 $A$ 为假，或者 $A$ 为真而 $B$ 为假时发生。因此，$FL(A \\wedge B)$ 是其组件假列表的并集：$FL(A \\wedge B) = FL(A) \\cup FL(B)$。由于子表达式 $A$ 和 $B$ 是不同的，所以它们的跳转列表是不相交的。其基数为 $|FL(A \\wedge B)| = |FL(A)| + |FL(B)|$。\n\n给定的子表达式基数为：\n- $|TL(A)| = 3$\n- $|FL(A)| = 2$\n- $|TL(B)| = 4$\n- $|FL(B)| = 3$\n\n源自 $A$ 和 $B$ 原子翻译的未解析分支总数为 $|TL(A)| + |FL(A)| + |TL(B)| + |FL(B)| = 3 + 2 + 4 + 3 = 12$。\n\n我们现在分析每种策略。\n\n**$\\mathsf{Swap}$ 策略**\n\n该策略首先计算 $A \\wedge B$ 的列表，然后交换它们以实现逻辑非。\n1.  **代码生成：** 如上计算，子表达式 $A$ 和 $B$ 的翻译总共引入了 $12$ 个未解析分支。$\\mathsf{Swap}$ 策略不引入任何新分支，它只是重新利用现有的分支。因此，回填操作的总数必须恰好是 $12$。我们可以通过追踪它们的解析过程来验证这一点。\n2.  **内部回填：** 为了形成 $A \\wedge B$ 的代码，$TL(A)$ 中的分支被回填到 $B$ 代码的开头。这需要 $|TL(A)| = 3$ 次回填操作。\n3.  **最终列表解析：** `if` 语句对条件 $C = \\neg(A \\wedge B)$ 进行求值。\n    - $C$ 的真列表 $TL(C)$ 是通过交换得到的，所以 $TL(C) = FL(A \\wedge B) = FL(A) \\cup FL(B)$。这些分支被回填到 `then` 子句。操作次数为 $|FL(A)| + |FL(B)| = 2 + 3 = 5$。\n    - 类似地，$C$ 的假列表 $FL(C)$ 为 $FL(C) = TL(A \\wedge B) = TL(B)$。这些分支被回填到 `else` 子句。操作次数为 $|TL(B)| = 4$。\n4.  **总操作数：** $\\mathsf{Swap}$ 策略的回填操作总数，记为 $N_{\\mathsf{Swap}}$，是所有已解析分支的总和。\n    $$N_{\\mathsf{Swap}} = |TL(A)| + (|FL(A)| + |FL(B)|) + |TL(B)|$$\n    $$N_{\\mathsf{Swap}} = 3 + (2 + 3) + 4 = 3 + 5 + 4 = 12$$\n    这证实了所有 $12$ 个初始未解析分支都得到了解析。\n\n**$\\mathsf{NegNode}$ 策略**\n\n该策略首先将 $A \\wedge B$ 的真假结果解析到临时标号，然后为否定操作生成新的分支。\n1.  **代码生成和内部解析：** 和之前一样，翻译 $A$ 和 $B$ 会创建 $12$ 个初始未解析分支。此策略在内部解析所有这些分支，然后创建新的分支。\n    - 将 $TL(A)$ 回填到 $B$ 的入口：$|TL(A)| = 3$ 次操作。\n    - $A \\wedge B$ 的列表是 $TL(A \\wedge B)=TL(B)$ 和 $FL(A \\wedge B)=FL(A) \\cup FL(B)$。\n    - 将 $TL(A \\wedge B)$ 回填到一个临时真标号 $L_{true\\_temp}$：$|TL(B)| = 4$ 次操作。\n    - 将 $FL(A \\wedge B)$ 回填到一个临时假标号 $L_{false\\_temp}$：$|FL(A)| + |FL(B)| = 2 + 3 = 5$ 次操作。\n    - 此时，所有 $3 + 4 + 5 = 12$ 个原始未解析分支都已被回填。\n2.  **否定节点生成：** `NegNode` 本身在临时标号处生成新的代码和新的未解析分支。\n    - 在 $L_{true\\_temp}$ 处（即 $A \\wedge B$ 为真），否定 `!` 使结果为假。创建一个新分支 `goto L_final_else`。这是一个新的未解析分支。\n    - 在 $L_{false\\_temp}$ 处（即 $A \\wedge B$ 为假），否定 `!` 使结果为真。创建一个新分支 `goto L_final_true`。这是第二个新的未解析分支。\n3.  **最终列表解析：** 这两个新分支构成了条件 $C = \\neg(A \\wedge B)$ 的最终真假列表。\n    - $TL(C)$ 包含一个指向 `L_final_true` 的分支。将其回填到 `then` 子句需要 $1$ 次操作。\n    - $FL(C)$ 包含一个指向 `L_final_false` 的分支。将其回填到 `else` 子句需要 $1$ 次操作。\n4.  **总操作数：** $\\mathsf{NegNode}$ 策略的回填操作总数 $N_{\\mathsf{NegNode}}$ 是解析初始分支和新生成分支的操作数之和。\n    $$N_{\\mathsf{NegNode}} = (\\text{初始分支的操作数}) + (\\text{新分支的操作数})$$\n    $$N_{\\mathsf{NegNode}} = (|TL(A)| + |TL(B)| + |FL(A)| + |FL(B)|) + 2$$\n    $$N_{\\mathsf{NegNode}} = (3 + 4 + 2 + 3) + 2 = 12 + 2 = 14$$\n\n**节省量计算**\n\n问题将节省量定义为 $\\mathsf{NegNode}$ 策略中的回填操作数减去 $\\mathsf{Swap}$ 策略中的回填操作数。\n$$Savings = N_{\\mathsf{NegNode}} - N_{\\mathsf{Swap}}$$\n$$Savings = 14 - 12 = 2$$\n$\\mathsf{NegNode}$ 策略比 $\\mathsf{Swap}$ 策略多需要 $2$ 次回填操作，这意味着后者（$\\mathsf{Swap}$策略）比前者（$\\mathsf{NegNode}$策略）节省了 $2$ 次操作。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "短路求值不仅关乎性能，它对于保证程序的正确性也至关重要。本练习以一个包含边界检查的常见 `while` 循环为例，展示了短路求值如何防止数组越界等运行时错误。在此基础上，你将进行一次形式化的性能分析，计算循环中数组访问的期望次数，这充分体现了编译技术、程序安全性与运行效率之间密不可分的联系。",
            "id": "3677647",
            "problem": "编译器后端必须将高级语句\n`while ((i  n)  a[i] != 0) { i := i + 1; }`\n中的循环条件翻译成遵循短路求值原则的低级控制流，这意味着只有当第一个合取项为真时，才会对第二个合取项求值。使用将布尔表达式翻译为带有显式标签的三地址码 (TAC) 的标准控制流导向方法，确保边界检查 $i  n$ 总是在数组访问 $a[i]$ 之前执行。然后，将此翻译扩展到等价 for 循环的规范化形式：\n`for (i := i_0; (i  n)  (a[i] != 0); i := i + 1) { /* empty body */ }`\n其中 $i_0$ 是 $i$ 的给定初始值，且 $0 \\le i_0 \\le n$。\n\n对于该规范化的 for 循环，假设程序输入遵循以下概率模型：\n- 数组段 $a[i_0], a[i_0+1], \\dots, a[n-1]$ 由独立元素组成。\n- 对于每个索引 $j \\in \\{i_0, i_0+1, \\dots, n-1\\}$，事件 $a[j] = 0$ 发生的概率为 $p$，其中 $p \\in (0,1]$，否则 $a[j] \\neq 0$。\n\n在此模型下，翻译后的 TAC 在每次迭代中以短路方式执行测试序列：它首先检查 $i  n$；仅当该条件为真时，它才读取并比较 $a[i]$。令 $X$ 为一个随机变量，其值等于该 TAC 在循环退出前执行的形如 $a[i]$ 的数组读取总次数。\n\n仅使用短路求值的基本定义、TAC 生成的控制流的语义，以及非负整数值随机变量的数学期望定义，推导期望值 $\\mathbb{E}[X]$ 作为 $n$、$i_0$ 和 $p$ 的函数的闭式解析表达式。请用最简闭式形式表示您的最终答案。无需四舍五入。",
            "solution": "本题要求基于数组内容的概率模型，为一个带有短路条件的循环推导数组读取次数的期望值。我们首先将问题陈述中隐含的控制流语义形式化，然后进行概率分析。\n\n首先，我们分析为布尔表达式 `(i  n)  (a[i] != 0)` 生成的控制流。`` 运算符意味着短路求值，即只有在第一个操作数 `i  n` 为真时，才会对第二个操作数 `a[i] != 0` 求值。在到三地址码 (TAC) 的标准翻译中，这是通过条件跳转实现的。对于形如 `while (B1  B2) S` 的 `while` 循环，其结构如下：\n\n`L_loop:`\n`  if not B1 goto L_exit`\n`  if not B2 goto L_exit`\n`  S`\n`  goto L_loop`\n`L_exit:`\n\n将此应用于具体问题，其中 `B1` 为 $i  n$，`B2` 为 $a[i] \\neq 0$，循环体 `S` 为 `i := i + 1`，则 TAC 将是：\n`L_loop:`\n`  t1 := i  n`\n`  if t1 = 0 goto L_exit`\n`  t2 := a[i]       ; Array read occurs here`\n`  t3 := t2 != 0`\n`  if t3 = 0 goto L_exit`\n`  i := i + 1`\n`  goto L_loop`\n`L_exit:`\n\n此控制流明确证实了数组访问 `a[i]` 仅在条件 $i  n$ 满足时发生。这是我们将要使用的关键语义属性。给定的 `for` 循环等价于初始化 `i := i_0` 后跟此 `while` 循环结构。\n\n令 $X$ 为代表数组读取总次数的随机变量。一次数组读取的形式为 $a[i]$。根据控制流，对于给定的 $i$ 值，当且仅当测试 $i  n$ 为真时，该次迭代中才会发生数组读取。循环从 $i = i_0$ 开始，并在每次成功迭代后将 $i$ 递增。循环可能对 $i$ 从 $i_0$ 到 $n-1$ 的值运行。如果 $i$ 达到 $n$，条件 $i  n$ 变为假，循环终止，且不会对该 $i$ 值进行数组读取。\n\n我们需要计算 $X$ 的期望值，记为 $\\mathbb{E}[X]$。由于 $X$ 是一个非负整数值随机变量，其期望值可以使用尾和公式计算：\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{\\infty} P(X \\ge k) $$\n数组读取的次数不能超过可能发生读取的 $i$ 值的数量，即 $n - i_0$（对于 $i = i_0, i_0+1, \\dots, n-1$）。因此，$X$ 的最大值为 $n-i_0$，且该和是有限的：\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{n-i_0} P(X \\ge k) $$\n注意，如果 $i_0 \\ge n$，求和范围为空，正确地得出 $\\mathbb{E}[X] = 0$，因为循环条件 $i  n$ 初始时为假。在主要推导中，我们将假设 $i_0  n$。\n\n我们来确定概率 $P(X \\ge k)$，其中 $k$ 是一个整数，且 $1 \\le k \\le n-i_0$。事件 $X \\ge k$ 意味着至少执行了 $k$ 次数组读取。第一次读取是 $a[i_0]$，第二次是 $a[i_0+1]$，第 $k$ 次读取是 $a[i_0+k-1]$。\n要使第 $k$ 次读取（读取 $a[i_0+k-1]$）发生，必须满足两个条件：\n1. 在之前对 $i = i_0, i_0+1, \\dots, i_0+k-2$ 的所有迭代中，循环必须没有终止。这要求循环条件的第二部分 $a[i] \\neq 0$ 对所有这些 $i$ 的值都为真。\n2. 对于当前迭代，边界检查 $i  n$ 必须通过，即 $i_0+k-1  n$。这一点由我们的求和上限 $k \\le n-i_0$ 保证。\n\n因此，第 $k$ 次读取发生的条件是对于所有 $j \\in \\{i_0, i_0+1, \\dots, i_0+k-2\\}$，都有 $a[j] \\neq 0$。概率模型指出，对于任何 $j$，$P(a[j] \\neq 0) = 1 - p$，且这些事件是独立的。因此，这 $k-1$ 个事件序列的概率是：\n$$ P(X \\ge k) = \\prod_{j=i_0}^{i_0+k-2} P(a[j] \\neq 0) = (1-p)^{k-1} $$\n此式对 $1 \\le k \\le n-i_0$ 成立。当 $k=1$ 时，乘积是对一个空集的，结果为 $1$，所以 $P(X \\ge 1) = (1-p)^0 = 1$，这是正确的，因为如果 $i_0  n$，则至少会发生一次数组访问尝试（尽管它可能立即失败，但读取会发生）。\n\n现在我们将此代入期望公式，得到一个几何级数：\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{n-i_0} (1-p)^{k-1} $$\n令 $j = k-1$，我们将求和变量改为从 $0$ 到 $n-i_0-1$：\n$$ \\mathbb{E}[X] = \\sum_{j=0}^{n-i_0-1} (1-p)^j $$\n这是一个公比为 $r = 1-p$ 的几何级数的和。项数为 $N = n-i_0$。该和的公式为 $\\frac{1-r^N}{1-r}$。\n$$ \\mathbb{E}[X] = \\frac{1 - (1-p)^{n-i_0}}{1 - (1-p)} = \\frac{1 - (1-p)^{n-i_0}}{p} $$\n这个闭式表达式给出了在给定概率模型下，数组读取次数的期望值。",
            "answer": "$$ \\boxed{\\frac{1 - (1-p)^{n-i_0}}{p}} $$"
        }
    ]
}