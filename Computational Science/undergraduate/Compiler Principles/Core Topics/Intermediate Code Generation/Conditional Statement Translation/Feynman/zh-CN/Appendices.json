{
    "hands_on_practices": [
        {
            "introduction": "本练习将带你实践一种经典技术——回填（backpatching），用于翻译带有短路求值（short-circuit evaluation）的复杂布尔表达式。通过计算生成三地址代码（Three-Address Code, TAC）所需的指令总数，你将深入理解编译器如何通过维护真假链表来管理未决的跳转，以及如何为子表达式顺序生成代码块。这项实践是掌握控制流翻译基础的关键一步 。",
            "id": "3630921",
            "problem": "一个编译器使用短路求值和回填方法为布尔条件生成三地址码（TAC）。回填方法为每个布尔表达式 $E$ 维护两个列表：$E.true$ 和 $E.false$，它们包含目标地址尚不确定、必须在稍后填写的跳转指令的索引。短路求值强制从左到右执行，因此会先生成左操作数的子表达式代码，并由其决定是否对右操作数进行求值。\n\n假设对于可能带有函数调用和副作用的基本布尔子表达式，采用以下翻译方案。对于任何基本布尔子表达式 $P$：\n- 编译器首先生成 $s_P$ 条 TAC 指令来计算 $P$（包括所有函数调用和副作用），并将布尔结果保存在一个临时变量 $t_P$ 中。\n- 紧随这 $s_P$ 条指令之后，编译器生成两条 TAC 指令：一条条件跳转“if $t_P$ goto $\\_$”和一条无条件跳转“goto $\\_$”，它们分别作为单个未解析的目标被记录到 $P.true$ 和 $P.false$ 中。\n\n对于使用短路语义和回填的布尔复合：\n- 对于 $E_1 \\lor E_2$：编译器将 $E_1.false$ 中的所有索引回填到 $E_2$ 测试代码的开始处，并构造 $E.true = \\operatorname{merge}(E_1.true, E_2.true)$ 和 $E.false = E_2.false$。除了 $E_1$ 和 $E_2$ 的指令外，不生成额外的 TAC 指令。\n- 对于 $E_1 \\land E_2$：编译器将 $E_1.true$ 中的所有索引回填到 $E_2$ 测试代码的开始处，并构造 $E.true = E_2.true$ 和 $E.false = \\operatorname{merge}(E_1.false, E_2.false)$。除了 $E_1$ 和 $E_2$ 的指令外，不生成额外的 TAC 指令。\n\n最后，对于条件语句“if $E$ goto $L_T$ else goto $L_F$”，编译器将 $E.true$ 中的所有索引回填到 $L_T$，并将 $E.false$ 中的所有索引回填到 $L_F$。标号是地址，不是指令；放置标号不会生成 TAC 指令。\n\n考虑翻译条件 $E \\equiv \\bigl(A \\lor (B \\land C)\\bigr)$，其中 $A$、$B$ 和 $C$ 是可能包含函数调用和副作用的基本布尔子表达式，遵循上述方案。假设在生成两条跳转指令之前，$A$、$B$ 和 $C$ 的求值分别需要 $s_A = 11$、$s_B = 6$ 和 $s_C = 4$ 条 TAC 指令。假设代码生成从 TAC 索引 $q_0 = 250$ 开始。\n\n仅使用上述方案，并确保短路求值保留副作用的从左到右顺序，确定仅用于求值该条件并跳转到相应目标所生成的 TAC 指令总数（即为 $A$、$B$、$C$ 及其相关的条件和无条件跳转生成的所有 TAC 指令，以及实现短路所需的任何控制流），不包括 $L_T$ 或 $L_F$ 处主体中的任何指令。请以单个整数形式提供您的答案。无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是有效的。这是一个编译器设计领域内定义明确的问题，为生成布尔表达式的三地址码（TAC）提供了一套清晰一致的规则。所有必要的数据都已提供，问题没有科学缺陷或含糊之处。\n\n任务是遵循指定的短路求值和回填方案，确定为条件表达式 $E \\equiv \\bigl(A \\lor (B \\land C)\\bigr)$ 生成的 TAC 指令总数。\n\n任何基本布尔子表达式 $P$ 的翻译方案规定，编译器会生成：\n1.  $s_P$ 条用于计算 $P$ 的指令。\n2.  两条后续的跳转指令：一条条件跳转（“if $t_P$ goto $\\_ $”）和一条无条件跳转（“goto $\\_ $”）。\n\n因此，为任何单个基本子表达式 $P$ 生成的 TAC 指令总数为 $s_P + 2$。\n\n问题明确指出，$E_1 \\lor E_2$ 和 $E_1 \\land E_2$ 的复合规则不生成任何额外的 TAC 指令。逻辑连接是通过回填跳转目标来实现的。这意味着为复合表达式生成的指令总数是为其组成的基本子表达式生成的指令之和，这些指令根据求值顺序在内存中顺序排列。\n\n要翻译的表达式是 $E \\equiv \\bigl(A \\lor (B \\land C)\\bigr)$。由于短路求值和副作用的从左到右处理，求值顺序是 $A$，然后在必要时是 $B$，再在必要时是 $C$。这些基本表达式的代码将按此顺序生成。\n\n1.  **基本子表达式 $A$ 的代码：**\n    为 $A$ 求值的指令数给定为 $s_A = 11$。\n    为 $A$ 生成的 TAC 指令总数为 $N_A = s_A + 2 = 11 + 2 = 13$。\n\n2.  **基本子表达式 $B$ 的代码：**\n    为 $B$ 求值的指令数给定为 $s_B = 6$。\n    为 $B$ 生成的 TAC 指令总数为 $N_B = s_B + 2 = 6 + 2 = 8$。\n\n3.  **基本子表达式 $C$ 的代码：**\n    为 $C$ 求值的指令数给定为 $s_C = 4$。\n    为 $C$ 生成的 TAC 指令总数为 $N_C = s_C + 2 = 4 + 2 = 6$。\n\n整个条件 $E$ 的总代码由 $A$ 的代码块、紧随其后的 $B$ 的代码块、再紧随其后的 $C$ 的代码块组成。这些块之间的控制流完全通过回填每个块内包含的跳转指令来处理。\n\n让我们追踪生成的代码块的排列。设代码生成从指令索引 $q_0 = 250$ 开始。\n-   **$A$ 的代码**：生成 $N_A = 13$ 条指令，占用从 $250$ 到 $250 + 13 - 1 = 262$ 的索引。下一个可用指令索引是 $263$。\n-   **$B$ 的代码**：$E_1 \\lor E_2$ 的规则规定 $E_1$（即 $A$）的 `false` 出口跳转到 $E_2$（即 $B \\land C$）代码的开始处。对于 $B \\land C$，$B$ 的代码会先生成。它将从索引 $263$ 开始放置。该代码块生成 $N_B = 8$ 条指令，占用从 $263$ 到 $263 + 8 - 1 = 270$ 的索引。下一个可用索引是 $271$。\n-   **$C$ 的代码**：$E_1 \\land E_2$ 的规则规定 $E_1$（即 $B$）的 `true` 出口跳转到 $E_2$（即 $C$）代码的开始处。$C$ 的代码将从索引 $271$ 开始放置。该代码块生成 $N_C = 6$ 条指令，占用从 $271$ 到 $271 + 6 - 1 = 276$ 的索引。\n\n为该条件生成的总指令集跨越从索引 $250$ 到 $276$。指令总数是每个基本部分指令数的总和。\n\n指令总数，$N_{total}$：\n$$N_{total} = N_A + N_B + N_C$$\n$$N_{total} = (s_A + 2) + (s_B + 2) + (s_C + 2)$$\n代入给定值 $s_A=11$、$s_B=6$ 和 $s_C=4$：\n$$N_{total} = (11 + 2) + (6 + 2) + (4 + 2)$$\n$$N_{total} = 13 + 8 + 6$$\n$$N_{total} = 27$$\n\n用于求值条件并执行必要跳转的全部代码包含 $27$ 条 TAC 指令。对于整个语句“if $E$ goto $L_T$ else goto $L_F$”的最终回填仅填充这些已生成的跳转指令的目标地址，不增加任何新指令。",
            "answer": "$$\\boxed{27}$$"
        },
        {
            "introduction": "现代优化编译器大多依赖于静态单赋值（Static Single Assignment, SSA）形式。本练习将你的视角从指令跳转转向数据流，通过确定条件语句在SSA转换中需要插入的 $\\phi$-函数数量，你将学会如何处理来自不同控制路径的值的合并问题。理解 $\\phi$-函数的放置是进行高级优化的前提 。",
            "id": "3630892",
            "problem": "考虑一个命令式语言中的以下源码级条件语句，该语言具有标量变量和传统的控制流图（CFG），需要为其构建静态单赋值（SSA）形式：\n\nif (p) { x = a; y = b; } else { x = c; y = d; }\nuse(x, y);\n\n假设存在以下基本模型和约束：\n- 静态单赋值（SSA）形式要求每个变量仅被赋值一次，并且在CFG的汇合点处放置称为$\\phi$-函数的特殊合并函数，以协调多个到达定义。\n- 当一个变量在某个汇合节点有来自不同前驱的$\\geq 2$个不同到达定义，并且该变量在该汇合点是活跃的（live）时，就需要插入一个$\\phi$-函数。\n- 使用剪枝SSA（pruned SSA）：仅为在汇合点活跃的变量插入$\\phi$-函数。\n- 只允许使用标量$\\phi$-函数；不存在聚合或元组$\\phi$-函数。并行复制（Parallel copies）是可用的，但不会改变$\\phi$-函数的数量。\n- 该CFG有一个入口块，根据谓词$p$分支到一个then-块和一个else-块，这两个块在调用$use(x, y)$之前立即在一个单一的汇合块处重新汇合。\n- 右侧的$a$、$b$、$c$和$d$是在分支之前严格定义的、不同的SSA名称，并且在两个分支中都可用。\n- 变量$x$和$y$在汇合点都是活跃的，因为它们在汇合后被$use(x, y)$使用。\n\n在这些假设下，并通过将两个分支分组到一个单一的汇合块中（没有重复或级联的汇合点）来最小化$\\phi$-节点的数量，请确定为了将该条件语句正确地转换为剪枝SSA形式，必须在汇合点插入的$\\phi$-函数的最小数量$n_{\\phi}$。您的最终答案必须是一个数字。不需要四舍五入。",
            "solution": "该问题要求确定将给定的条件语句转换为剪枝静态单赋值（SSA）形式所需的最少$\\phi$-函数数量。分析过程通过将SSA构建规则应用于所涉及的变量来进行。\n\n源码级的条件语句是：\n`if (p) { x = a; y = b; } else { x = c; y = d; } use(x, y);`\n\n问题指定了一个控制流图（CFG），它有一个包含基于谓词$p$的条件分支的入口块。这个入口块有两个后继：一个'then'块（$B_{then}$）和一个'else'块（$B_{else}$）。这两个块随后在一个单一的汇合块$B_{join}$处重新汇合。\n\n在SSA形式中，每个变量只被赋值一次。当一个变量在多个后来合并的控制流路径中被赋值时，它的名称必须进行版本化。让我们追踪变量$x$和$y$的赋值情况。\n\n1.  **变量重命名**：\n    原始变量$x$和$y$在'then'和'else'两个分支中都被赋值。为了遵守单赋值规则，我们为每次赋值引入新的版本（名称）。\n    - 在$B_{then}$中，赋值变为$x_1 = a$和$y_1 = b$。\n    - 在$B_{else}$中，赋值变为$x_2 = c$和$y_2 = d$。\n    变量$a, b, c, d$在分支前定义，并假定已处于正确的SSA形式。\n\n2.  **$\\phi$-函数的插入**：\n    问题指出，如果满足两个条件，就应在汇合节点为某个变量插入一个$\\phi$-函数：\n    a) 该变量有来自汇合节点不同前驱的两个或更多个不同的到达定义。\n    b) 该变量在该汇合节点是活跃的（live）。\n\n    这对应于剪枝SSA形式的定义，它避免为在汇合点不活跃的变量插入$\\phi$-函数。我们在汇合块$B_{join}$处分析条件语句中赋值的每个变量，$x$和$y$。\n\n    **对变量$x$的分析**：\n    - **到达定义**：在进入$B_{join}$时，概念变量$x$有两个来自其前驱$B_{then}$和$B_{else}$的不同定义。定义$x_1$从$B_{then}$到达，定义$x_2$从$B_{else}$到达。因此，条件(a)得到满足。\n    - **活跃性**：问题明确指出，“$x$和$y$在汇合点都是活跃的，因为它们在汇合后被$use(x, y)$使用。”因此，对于$x$，条件(b)得到满足。\n    - 由于两个条件都满足，因此在$B_{join}$处必须为$x$设置一个$\\phi$-函数。该函数将合并$x$的两个版本：\n    $$x_3 = \\phi(x_1, x_2)$$\n    新版本$x_3$将在调用$use$时被使用。这计为一个$\\phi$-函数。\n\n    **对变量$y$的分析**：\n    - **到达定义**：同样地，对于$y$，在进入$B_{join}$时，有两个不同的到达定义：来自$B_{then}$的$y_1$和来自$B_{else}$的$y_2$。条件(a)得到满足。\n    - **活跃性**：问题还指出$y$在汇合点是活跃的。条件(b)得到满足。\n    - 由于两个条件都满足，因此在$B_{join}$处也必须为$y$设置一个$\\phi$-函数：\n    $$y_3 = \\phi(y_1, y_2)$$\n    新版本$y_3$将在调用$use$时被使用。这计为第二个$\\phi$-函数。\n\n3.  **计算$\\phi$-函数的数量**：\n    问题规定：“只允许使用标量$\\phi$-函数；不存在聚合或元组$\\phi$-函数。”这意味着我们不能将$x$和$y$的合并分组到一个复合操作中。每个需要合并的变量都必须有自己独立的$\\phi$-函数。\n\n    根据以上分析：\n    - 变量$x$需要一个$\\phi$-函数。\n    - 变量$y$需要一个$\\phi$-函数。\n\n    $\\phi$-函数的总最小数量$n_{\\phi}$是每个变量所需$\\phi$-函数的总和。\n    $$n_{\\phi} = 1 + 1 = 2$$\n    这个数字是最小的，因为每个$\\phi$-函数的插入都由剪枝SSA构建算法的充分必要条件决定。在分支内没有其他变量被赋值，所以不需要其他$\\phi$-函数。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "为了极致的性能，编译器有时会将控制流转换为数据流，这个过程被称为“if-conversion”。本练习要求你将一个常见的条件更新（如计算运行中的最小值和最大值）翻译成不含分支指令的序列。通过使用位掩码（bitmask）和位运算，你将体验到如何消除分支，生成对现代处理器更友好的高效代码 。",
            "id": "3630902",
            "problem": "你需要以一种类似编译器的思维方式，实现将一对条件更新转换为无分支代码。需要转换的源级构造是应用于有限有符号整数序列的典型动态最小和最大值更新：\n- 对于每个新的输入值 $x$，使用条件语句“if $x  m$ then $m := x$”更新动态最小值 $m$，并使用条件语句“if $x  M$ then $M := x$”更新动态最大值 $M$。\n\n你的任务是使用比较转掩码和位选择技术，将这两个条件语句替换为一个无分支序列。其目的是模拟编译器如何在中间表示（IR）中将控制流降级为数据流，从而在不为这些更新生成分支的情况下完成任务。你必须基于以下经过充分检验的事实来构建你的方法：\n- 在C语言的无符号整数抽象机中，对于一个 $w$ 位类型，减法是按模 $2^w$ 执行的。\n- 在C语言中进行比较时，关系表达式（如 $(x  y)$）的求值结果为一个在 $\\{0,1\\}$ 集合内的整数。\n- 有符号整数使用二进制补码算术，可以建模为模 $2^w$ 运算，而位运算 $\\land$、$\\lor$ 和位取反 $\\lnot$ 则作用于定宽整数的每个位。\n- 使用一个在目标位宽上全为1或全为0的掩码 $U$，通过适当组合位运算，可以在两个值 $a$ 和 $b$ 之间进行无分支选择。\n\n你必须采纳并实现的约束和假设：\n- 使用一个定宽有符号整数模型，其中 $w = 64$。将最小和最大的有符号值分别表示为 $-2^{63}$ 和 $2^{63}-1$。\n- 对于每个输入值 $x$，对 $m$ 和 $M$ 的更新必须在更新步骤本身不使用任何分支指令。具体来说，每次更新必须仅能通过比较得到 $\\{0,1\\}$、使用无符号减法形成一个掩码 $U \\in \\{0, 2^{64}-1\\}$ 以及使用位运算在备选项之间进行选择来表达。\n- 你必须将每个序列的动态最小值 $m$ 和最大值 $M$ 初始化为其第一个元素，然后按顺序处理剩余元素。\n\n设计并实现一个完整的程序，该程序：\n- 将上述无分支转换应用于下面测试套件中的每个序列。\n- 生成单行输出，其中包含用方括号括起来的、以逗号分隔的数对列表，每个数对本身也是一个用方括号括起来的、以逗号分隔的列表 $[m,M]$。例如，格式为 $[[m_1,M_1],[m_2,M_2],\\dots]$，不含空格。\n\n用于覆盖典型、边界和边缘情况的测试套件：\n- 情况A（一般混合符号）：$\\langle 3,-1,4,-5,2 \\rangle$。\n- 情况B（全部相等）：$\\langle 7,7,7,7 \\rangle$。\n- 情况C（递增）：$\\langle -2,0,5,9,12 \\rangle$。\n- 情况D（递减）：$\\langle 10,9,8,7,6 \\rangle$。\n- 情况E（接近极值但不含绝对最小值）：$\\langle 0,2^{63}-1,-(2^{63}-1),-1,1 \\rangle$。\n- 情况F（包含绝对最小值和最大值）：$\\langle 5,-2^{63},0,2^{63}-1 \\rangle$。\n\n你的程序必须为每种情况计算在用无分支更新处理完整个序列后的最终动态最小值 $m$ 和最大值 $M$，并以确切的单行格式输出它们：\n- 输出格式：单行文本，格式为 $[[m_A,M_A],[m_B,M_B],[m_C,M_C],[m_D,M_D],[m_E,M_E],[m_F,M_F]]$，其中下标表示对应的情况。不允许有额外的空白或文本。\n\n不要读取任何输入。将上述测试套件硬编码在你的程序中。最终输出为纯整数。不涉及物理单位。本问题不适用角度和百分比。",
            "solution": "问题要求实现一个无分支算法，用于查找有符号整数序列的动态最小值和最大值。此任务模拟了一种常见的编译器优化技术，其中条件分支被转换为一系列算术和位运算，该技术被称为“if-conversion”或“谓词化（predication）”。解决方案必须遵循一种特定方法，即在 $w=64$ 位的二进制补码整数上使用比较转掩码和位选择。\n\n需要转换的源级条件语句如下：\n1. 对于动态最小值 $m$：`if ($x  m$) then $m := x$`\n2. 对于动态最大值 $M$：`if ($x  M$) then $M := x$`\n\n这些可以用三元运算符表示为：\n$m = (x  m) ? x : m$\n$M = (x  M) ? x : M$\n\n无分支转换的核心在于用位选择机制替换三元条件选择。使用位掩码 $U$ 在两个值 $v_a$ 和 $v_b$ 之间进行选择的通用公式是：\n$$v_{new} = (v_a \\land U) \\lor (v_b \\land \\lnot U)$$\n在这里，$\\land$ 表示按位与运算符，$\\lor$ 表示按位或运算符，$\\lnot$ 表示按位非（取反）运算符。如果掩码 $U$ 在目标位宽上是全1或全0，则此公式有效。\n- 如果 $U$ 是一个全为1的位掩码（例如 `0xFF...FF`），那么 $\\lnot U$ 就是全为0。表达式简化为 $(v_a \\land \\text{all}_1s) \\lor (v_b \\land \\text{all}_0s) = v_a \\lor 0 = v_a$。\n- 如果 $U$ 是一个全为0的位掩码（例如 `0x00...00`），那么 $\\lnot U$ 就是全为1。表达式简化为 $(v_a \\land \\text{all}_0s) \\lor (v_b \\land \\text{all}_1s) = 0 \\lor v_b = v_b$。\n\n关键步骤是直接从比较结果生成这样的掩码 $U$，而无需分支。问题指出，像 $(x  y)$ 这样的C语言关系表达式的求值结果为一个整数，真为 $1$，假为 $0$。我们需要将这个布尔结果映射到一个全宽度的位掩码。指定的方法是使用无符号减法。\n\n让我们为一个 $w=64$ 位的系统将其形式化。\n1. 比较的结果，比如 $c = (x  m)$，是一个值为 $1$ 或 $0$ 的 `int` 类型。\n2. 我们将此结果强制转换为一个64位无符号整数，称之为 $c_{64u}$。因此，$c_{64u} \\in \\{0, 1\\}$。\n3. 我们使用无符号减法生成掩码 $U$：$U = 0 - c_{64u}$。在一个 $w$ 位的无符号系统中，此操作按模 $2^{64}$ 执行。\n   - 如果比较为真，$c_{64u} = 1$。掩码变为 $U = 0 - 1 \\pmod{2^{64}} = 2^{64} - 1$。在二进制中，这是一个由64个1组成的序列（`0xFFFFFFFFFFFFFFFF`）。\n   - 如果比较为假，$c_{64u} = 0$。掩码变为 $U = 0 - 0 = 0$。在二进制中，这是一个由64个0组成的序列（`0x0000000000000000`）。\n\n这个生成的掩码 $U$ 正是位选择公式所需要的。在二进制补码系统中，当掩码的位模式被重新解释为有符号64位整数时，它们对应于 $-1$（全1）和 $0$（全0）。\n\n将此方法应用于最小值更新：`if ($x  m$) then $m := x$`。\n- 如果为真，选择的值（$v_a$）是 $x$。\n- 如果为假，选择的值（$v_b$）是 $m$。\n- 条件是 $(x  m)$。\n- 掩码是 $U_{min} = 0 - (\\text{unsigned long long})(x  m)$。\n- 新的最小值计算为 $m_{new} = (x \\land (\\text{long long})U_{min}) \\lor (m \\land \\lnot((\\text{long long})U_{min}))$。\n\n将此方法应用于最大值更新：`if ($x  M$) then $M := x$`。\n- 如果为真，选择的值（$v_a$）是 $x$。\n- 如果为假，选择的值（$v_b$）是 $M$。\n- 条件是 $(x  M)$。\n- 掩码是 $U_{max} = 0 - (\\text{unsigned long long})(x  M)$。\n- 新的最大值计算为 $M_{new} = (x \\land (\\text{long long})U_{max}) \\lor (M \\land \\lnot((\\text{long long})U_{max}))$。\n\nC语言的实现将对64位有符号整数 $x$、$m$ 和 $M$ 使用 `long long` 类型，对中间掩码的生成使用 `unsigned long long` 类型。在假定的二进制补码架构上，将用于位选择的 `unsigned long long` 掩码重新解释转换为 `long long` 是明确定义的，它会保留 $0$ 和 $-1$ 的位模式。\n\n程序将每个测试序列的 $m$ 和 $M$ 初始化为第一个元素，然后遍历剩余元素，对每个元素应用这两个无分支更新步骤。然后收集每个序列的最终 $m$ 和 $M$ 值，并按指定格式打印。极值常量 $2^{63}-1$ 和 $-2^{63}$ 使用 `long long` 字面量定义，以确保它们具有正确的值和类型。",
            "answer": "[[-5,4],[7,7],[-2,12],[6,10],[-9223372036854775807,9223372036854775807],[-9223372036854775808,9223372036854775807]]"
        }
    ]
}