{
    "hands_on_practices": [
        {
            "introduction": "我们从最基本的情况开始：一维数组。这个练习将挑战你处理非零起始索引（特别是负数索引）的情况。理解这一点是掌握通用地址计算公式的关键，该公式是所有数组转换的基础，并能强化你对数组下界在地址计算中作用的理解 。",
            "id": "3677213",
            "problem": "在传统的编译器中间表示中，三地址码 ($3$AC) 用于在标准内存模型的指导下将数组引用转换为显式的地址计算。考虑一个一维数组 $A$，其下界和上界分别为 $-5$ 和 $5$，记为 $A[-5..5]$。该数组的每个元素占用 $w$ 字节，并在内存中连续存放。设 $B$ 表示第一个元素 $A[-5]$ 的机器地址。一个高级程序在运行时计算一个索引 $i := t - 2$，其中 $t$ 是一个整型变量，然后引用 $A[i]$。\n\n使用以下基本原则：\n- 一维数组是连续存储的，因此连续元素的地址之差为元素宽度 $w$。\n- 基地址 $B$ 指向下界索引处的元素，此处为 $A[-5]$。\n- 为了引用 $A[i]$，编译器必须计算下界元素和目标元素之间的元素数量，通过乘以 $w$ 将该计数转换为字节位移，并将结果加到 $B$ 上以获得有效地址。\n\n推导正确处理负数下界的三地址码 (3AC) 序列，方法是首先将逻辑索引 $i$ 偏移为从零开始的位移（即，在缩放前加上 $+5$），然后计算有效地址。根据该推导，将有效地址计算简化为用 $B$、$w$ 和 $t$ 表示 $A[i]$ 地址 $E$ 的单个封闭形式的代数表达式。\n\n仅提供 $E$ 的简化代数表达式作为最终答案。无需四舍五入。",
            "solution": "所述问题是有效的。这是一个编译器设计领域内的适定问题，具体涉及数组寻址的中间代码生成。所有必要的参数和定义都已提供，问题没有科学上的不准确、矛盾和歧义之处。\n\n任务是推导数组访问的三地址码 ($3$AC)，然后将底层计算简化为有效内存地址的单个代数表达式。\n\n首先，我们建立计算一维数组中元素地址的基本公式。对于声明为 `Array[low..high]` 的数组，其中 $low$ 是索引用法下界，元素 $Array[i]$ 的内存地址由以下公式给出：\n$$\n\\text{Address}(\\text{Array}[i]) = \\text{BaseAddress} + (i - \\text{low}) \\times w\n$$\n其中 $\\text{BaseAddress}$ 是第一个元素 $Array[low]$ 的内存地址，$w$ 是数组中每个元素的宽度（以字节为单位）。\n\n在给定问题中，我们有数组 $A[-5..5]$。已知条件如下：\n- 下界，$low = -5$。\n- 上界，$high = 5$。\n- 元素宽度为 $w$。\n- 基地址为 $B$，定义为第一个元素 $A[-5]$ 的地址。\n- 索引 $i$ 在运行时计算为 $i := t - 2$，其中 $t$ 是一个整型变量。\n\n问题要求使用三地址码进行特定的推导路径。高级操作是计算元素 $A[i]$ 的有效地址 $E$。\n\n计算 $A[i]$ 的有效地址 $E$ 的操作序列可以分解为一系列三地址指令。我们使用临时变量 $t_1, t_2, \\dots$ 来保存中间结果。\n\n1.  首先，根据变量 $t$ 计算索引 $i$ 的值。\n    $$t_1 = t - 2$$\n    在这里，临时变量 $t_1$ 保存 $i$ 的值。\n\n2.  接下来，计算从数组起始位置开始的、从零开始的位移。数组从索引 $-5$ 开始。起始元素 ($A[-5]$) 与目标元素 $A[i]$ (或 $A[t_1]$) 之间的元素数量由 $i - \\text{low} = t_1 - (-5) = t_1 + 5$ 给出。问题陈述明确指出“在缩放前加上 $+5$”。\n    $$t_2 = t_1 + 5$$\n    在这里，$t_2$ 表示元素的从零开始的偏移量，即如果数组从 $0$ 开始索引，它的位置。\n\n3.  然后，这个从零开始的偏移量必须乘以元素宽度 $w$，以获得相对于基地址 $B$ 的字节偏移量。\n    $$t_3 = t_2 \\times w$$\n    在这里，$t_3$ 是从数组开头算起的总字节位移。\n\n4.  最后，通过将这个字节偏移量 $t_3$ 加到基地址 $B$ 上，得到有效地址 $E$。\n    $$E = B + t_3$$\n\n这样就完成了三地址码序列的推导。为了找到 $E$ 的简化、单一封闭形式的代数表达式，我们对这些中间步骤进行回代。\n\n从 $E$ 的最终表达式开始：\n$$E = B + t_3$$\n\n代入 $t_3$ 的表达式：\n$$E = B + (t_2 \\times w)$$\n\n代入 $t_2$ 的表达式：\n$$E = B + ((t_1 + 5) \\times w)$$\n\n代入 $t_1$ 的表达式：\n$$E = B + (((t - 2) + 5) \\times w)$$\n\n现在，我们简化括号内的表达式：\n$$E = B + ((t + 3) \\times w)$$\n\n这可以更简洁地写成：\n$$E = B + w(t + 3)$$\n\n这个最终表达式表示了元素 $A[t-2]$ 的有效地址 $E$，用基地址 $B$、元素宽度 $w$ 和运行时变量 $t$ 来表示。这个结果通过计算从基地址开始的正确偏移量，正确地包含了数组的负数下界。",
            "answer": "$$\\boxed{B + w(t + 3)}$$"
        },
        {
            "introduction": "掌握了一维数组后，我们将维度扩展到多维。这引入了新的复杂性，例如由行主序等存储布局引起的问题。这项练习不仅要求你推导三维数组更复杂的地址公式，还会引导你探索编译器如何在嵌套循环中优化这些计算——这是一个常见且对性能至关重要的场景 。",
            "id": "3677304",
            "problem": "一个三维数组 $B[i][j][k]$ 以行主序存储，这意味着最右边的索引在内存中变化最快。该数组在三个维度上分别具有任意的下界和上界 $[l_1..u_1][l_2..u_2][l_3..u_3]$。每个元素占用 $w$ 个字节。设数组 $B$ 的基地址为 $\\text{base}(B)$。考虑将源级引用 $B[i][j][k]$ 翻译成有效地址，使用三地址码 (3AC)，然后在 $j$ 和 $k$ 在关于 $i$ 的内层循环中保持不变的嵌套循环上下文中，使用循环不变代码外提来重构 3AC。\n\n任务：\n1.  仅从行主序布局、数组跨度和多维数组的仿射地址计算的定义出发，推导 $B[i][j][k]$ 的有效地址表达式，该表达式用 $\\text{base}(B)$、$i$、$j$、$k$、$l_1$、$l_2$、$l_3$、$u_2$、$u_3$ 和 $w$ 表示。\n2.  生成一个线性的三地址码 (3AC) 序列，用于计算给定三元组 $(i,j,k)$ 的有效地址。\n3.  现在考虑以下完美嵌套循环，其中 $i$ 是最内层循环的索引，而 $j$ 和 $k$ 在内层循环体中是不变的：\n```\n对于 k 从 K_0 到 K_1：\n  对于 j 从 J_0 到 J_1：\n    对于 i 从 I_0 到 I_1：\n      使用 B[i][j][k]\n```\n使用循环不变代码外提重构你的 3AC，使得与 $i$ 无关的计算被提升到内层循环之外，并且内层循环使用强度削减和一个归纳变量，以在每次迭代中通过一个常量增量来推进有效地址。\n\n答案规格：\n作为你的最终答案，提供一个单一的闭式解析表达式，表示当从 $i$ 移动到 $i+1$ 且 $j$ 和 $k$ 固定时，有效地址的每次迭代增量。该表达式应为 $l_2$、$u_2$、$l_3$、$u_3$ 和 $w$ 的函数。最终的方框答案中不要包含任何单位。如果你选择使用跨度 $n_2 = u_2 - l_2 + 1$ 和 $n_3 = u_3 - l_3 + 1$ 进行简化，请确保你的最终表达式仅依赖于 $l_2$、$u_2$、$l_3$、$u_3$ 和 $w$。不需要进行四舍五入。",
            "solution": "问题要求推导和优化三维数组元素 $B[i][j][k]$ 的地址计算。该数组定义了下界和上界 $[l_1..u_1]$、$[l_2..u_2]$ 和 $[l_3..u_3]$，并以行主序存储。每个元素占用 $w$ 个字节。\n\n### 步骤1：有效地址公式的推导\n在行主序存储方案中，最右边的索引变化最快。要计算元素 $B[i][j][k]$ 的地址，我们首先确定其相对于基地址 $\\text{base}(B)$ 的偏移量，基地址是第一个元素 $B[l_1][l_2][l_3]$ 的地址。偏移量是排在 $B[i][j][k]$ 前面的元素数量与元素大小 $w$ 的乘积。\n\n首先，我们定义每个维度的跨度，即元素数量：\n- 第1维度（$i$）的跨度：$n_1 = u_1 - l_1 + 1$\n- 第2维度（$j$）的跨度：$n_2 = u_2 - l_2 + 1$\n- 第3维度（$k$）的跨度：$n_3 = u_3 - l_3 + 1$\n\n在线性内存布局中，排在 $B[i][j][k]$ 之前的元素总数，是通过考虑每个索引相对于其下界的贡献来计算的：\n1.  来自第一个索引 $i$ 的贡献：数组由 $n_1$ 个二维“平面”组成，每个平面的大小为 $n_2 \\times n_3$。为了到达索引 $i$ 对应的平面，需要跳过的完整平面数量是 $(i - l_1)$。这相当于 $(i - l_1) \\times n_2 \\times n_3$ 个元素。\n2.  来自第二个索引 $j$ 的贡献：在第 $i$ 个平面内，数据被组织成 $n_2$ 个“行”，每行大小为 $n_3$。为了到达索引 $j$ 对应的行，需要跳过的完整行数是 $(j - l_2)$。这相当于额外的 $(j - l_2) \\times n_3$ 个元素。\n3.  来自第三个索引 $k$ 的贡献：在第 $i$ 个平面的第 $j$ 行内，为了到达索引为 $k$ 的元素，需要跳过的元素数量是 $(k - l_3)$。\n\n排在 $B[i][j][k]$ 之前的元素总数是这些贡献的总和：\n$$ \\text{offset\\_in\\_elements} = (i - l_1) n_2 n_3 + (j - l_2) n_3 + (k - l_3) $$\n字节偏移量是这个数量乘以元素大小 $w$。因此，$B[i][j][k]$ 的有效地址是：\n$$ \\text{addr}(B[i][j][k]) = \\text{base}(B) + w \\times \\left[ (i - l_1) n_2 n_3 + (j - l_2) n_3 + (k - l_3) \\right] $$\n代入 $n_2$ 和 $n_3$ 的定义，我们得到所需的表达式：\n$$ \\text{addr}(B[i][j][k]) = \\text{base}(B) + w \\left[ (i - l_1)(u_2 - l_2 + 1)(u_3 - l_3 + 1) + (j - l_2)(u_3 - l_3 + 1) + (k - l_3) \\right] $$\n\n### 步骤2：三地址码 (3AC) 序列\n上述公式可以翻译成一个线性的三地址码指令序列。我们记 $n_2 = u_2 - l_2 + 1$ 和 $n_3 = u_3 - l_3 + 1$。3AC 如下：\n$$ t_1 = i - l_1 $$\n$$ t_2 = t_1 \\times n_2 $$\n$$ t_3 = t_2 \\times n_3 $$\n$$ t_4 = j - l_2 $$\n$$ t_5 = t_4 \\times n_3 $$\n$$ t_6 = k - l_3 $$\n$$ t_7 = t_3 + t_5 $$\n$$ t_8 = t_7 + t_6 $$\n$$ t_9 = w \\times t_8 $$\n$$ \\text{addr} = \\text{base}(B) + t_9 $$\n\n### 步骤3：为循环优化和增量计算进行重构\n问题指定了一个嵌套循环结构，其中最内层循环对 $i$ 进行迭代，而 $j$ 和 $k$ 保持不变。\n```\n对于 k = K_0 到 K_1:\n  对于 j = J_0 到 J_1:\n    对于 i = I_0 到 I_1:\n      使用 B[i][j][k]\n```\n为了优化 $i$-循环内的地址计算，我们应用循环不变代码外提。我们重排地址公式，以便将依赖于 $i$ 的项与不依赖于 $i$ 的项分开。\n$$ \\text{addr}(B[i][j][k]) = \\text{base}(B) + w(i \\cdot n_2 n_3 - l_1 n_2 n_3) + w((j - l_2) n_3) + w(k - l_3) $$\n$$ \\text{addr}(B[i][j][k]) = \\left[ \\text{base}(B) - w \\cdot l_1 n_2 n_3 + w \\cdot (j - l_2) n_3 + w \\cdot (k - l_3) \\right] + i \\cdot (w \\cdot n_2 n_3) $$\n该表达式具有 $C_{j,k} + i \\cdot S_i$ 的形式，其中：\n- $C_{j,k} = \\text{base}(B) - w l_1 n_2 n_3 + w (j - l_2) n_3 + w (k - l_3)$ 是相对于 $i$-循环的循环不变部分。\n- $S_i = w n_2 n_3$ 是步长，即 $i$ 所乘的常数因子。\n\n$C_{j,k}$ 和 $S_i$ 的计算可以被提升出 $i$-循环。循环内部的地址计算 $C_{j,k} + i \\cdot S_i$ 是强度削减的候选对象。我们不必在每次迭代中都进行乘法，而是可以维护一个归纳变量（例如 $p$），它持有当前地址。在循环开始前，$p$ 被初始化为第一个元素 $B[I_0][j][k]$ 的地址。在每次迭代中，$p$ 通过加上一个常量增量来更新，以获得下一个元素 $B[i+1][j][k]$ 的地址。\n\n每次迭代的增量是当 $i$ 增加1时地址的差值：\n$$ \\text{增量} = \\text{addr}(B[i+1][j][k]) - \\text{addr}(B[i][j][k]) $$\n使用优化形式 $C_{j,k} + i \\cdot S_i$：\n$$ \\text{增量} = [C_{j,k} + (i+1) \\cdot S_i] - [C_{j,k} + i \\cdot S_i] $$\n$$ \\text{增量} = (C_{j,k} + i \\cdot S_i + S_i) - (C_{j,k} + i \\cdot S_i) = S_i $$\n所以，增量就是步长 $S_i = w n_2 n_3$。这个常数代表了数组一个完整的 $(j,k)$-平面的内存大小。\n\n最后一步是使用问题陈述中指定的变量 $l_2$、$u_2$、$l_3$、$u_3$ 和 $w$ 来表示这个增量。我们代入 $n_2$ 和 $n_3$ 的表达式：\n$$ \\text{增量} = w \\times (u_2 - l_2 + 1) \\times (u_3 - l_3 + 1) $$\n这就是在内层循环的每次迭代中加到地址归纳变量上的常数值的闭式解析表达式。",
            "answer": "$$\n\\boxed{w (u_2 - l_2 + 1) (u_3 - l_3 + 1)}\n$$"
        },
        {
            "introduction": "最后，我们来处理另一个常见的实际场景：嵌套数组访问，例如 $A[B[i]]$。这种情况需要仔细地将操作排序：一次地址计算，一次内存加载以获取内部索引，然后是最终的地址计算。这项练习将展示三地址码如何显式且安全地对内存操作进行排序 。",
            "id": "3677330",
            "problem": "考虑一个在字节寻址机器上，对从零开始索引的数组进行标准编译的场景。以下基本原则适用：\n\n- 数组元素的线性地址由公式 $ \\mathrm{addr}(X[k]) = \\mathrm{base}(X) + k \\cdot \\mathrm{size}(X) $ 给出，其中 $ \\mathrm{base}(X) $ 是数组的基地址（以字节为单位），$ k $ 是从零开始的索引，$ \\mathrm{size}(X) $ 是元素的大小（以字节为单位）。\n- 三地址码 (TAC) 是一种中间表示，其中每个语句最多有三个操作数并执行一个操作，例如 $ t := a \\ \\mathrm{op} \\ b $、$ t := \\mathrm{mem}[\\alpha] $ 或 $ \\mathrm{mem}[\\alpha] := t $。TAC 用于对计算进行排序，并显式地建模内存加载和存储。\n\n你需要将嵌套数组引用 $ A[B[i]] $ 翻译成三地址码 (TAC)，该 TAC 能够安全地对内层索引和外层地址的计算进行排序，并通过重用临时变量而非重新计算子表达式来最小化内存加载。假设以下具体场景，其布局元数据在编译时已知：\n\n- 数组 $ A $ 的基地址为 $ A_0 = 4096 $，元素大小为 $ s_A = 8 $，长度为 $ n_A = 100 $。\n- 数组 $ B $ 的基地址为 $ B_0 = 2048 $，元素大小为 $ s_B = 4 $，长度为 $ n_B = 64 $。\n- 运行时索引为 $ i = 11 $。\n- 位置 $ B[i] $ 处的内存内容是整数 $ 17 $，即 $ B[11] = 17 $。\n\n假设边界元数据 $ n_A $ 和 $ n_B $ 是代码生成器可用的编译时常量，并且基地址 $ A_0 $ 和 $ B_0 $ 也是编译时常量；因此，使用它们不会产生任何内存加载。将内存加载显式地建模为 $ t := \\mathrm{mem}[\\alpha] $，其中 $ \\alpha $ 是计算出的字节地址。\n\n推导满足以下条件的 TAC：\n- 计算 $ B[i] $ 的地址，\n- 加载一次值 $ j = B[i] $，并将其作为临时变量重用于外层访问，\n- 计算 $ A[j] $ 的地址，而无需重新加载 $ B[i] $ 或重新计算内层地址。\n\n在推导出 TAC 之后，使用提供的数值数据计算外层访问 $ \\mathrm{addr}(A[B[i]]) $ 的最终字节地址。将最终答案以表示字节地址的单个实数值形式提供。无需四舍五入。在最终的方框输出中，表达最终答案时无需单位。",
            "solution": "该问题已经过验证，被认为是有效的。这是一个在编译原理领域内良构且有科学依据的问题，具有一套完整且一致的给定条件。将数组引用翻译为三地址码并计算最终地址所需的所有数据均已提供。\n\n主要任务是将嵌套数组引用 $A[B[i]]$ 翻译成一系列三地址码 (TAC) 指令，然后使用提供的数值数据计算最终的内存地址。求值必须从最内层的表达式开始向外进行。\n\n首先，我们必须确定内层索引的值，该值由表达式 $B[i]$ 给出。这包括两个步骤：1. 计算元素 $B[i]$ 的内存地址。2. 从该内存地址加载值。\n\n元素 $X[k]$ 的地址由公式 $\\mathrm{addr}(X[k]) = \\mathrm{base}(X) + k \\cdot \\mathrm{size}(X)$ 给出。对于内层数组访问 $B[i]$，基地址是 $B_0$，索引是 $i$，元素大小是 $s_B$。因此，$B[i]$ 的地址是：\n$$ \\mathrm{addr}(B[i]) = B_0 + i \\cdot s_B $$\n\n让我们用 TAC 来表示这个计算。我们使用表示为 $t_n$ 的临时变量来保存中间结果。\n1.  计算偏移量（以字节为单位）：$t_0 := i \\cdot s_B$。\n2.  计算 $B[i]$ 的完整地址：$t_1 := B_0 + t_0$。\n\n在地址被计算并存储在 $t_1$ 中之后，下一步是从这个内存位置加载值。这个值将作为外层数组 $A$ 的索引。让我们按照问题陈述的建议，将这个值称为 $j$。\n3.  加载值：$j := \\mathrm{mem}[t_1]$。\n\n现在我们有了内层索引 $j = B[i]$ 的值，我们可以继续进行外层数组访问 $A[j]$。这个元素的地址由相同的通用公式给出：\n$$ \\mathrm{addr}(A[j]) = A_0 + j \\cdot s_A $$\n\n这个计算也被翻译成 TAC，重用了保存 $B[i]$ 值的临时变量 $j$，从而避免了第二次内存加载。\n4.  计算外层数组的偏移量：$t_2 := j \\cdot s_A$。\n5.  计算 $A[B[i]]$ 的最终地址：$t_3 := A_0 + t_2$。\n\n变量 $t_3$ 现在保存着最终的目标字节地址。完整的 TAC 序列是：\n1.  $t_0 := i \\cdot s_B$\n2.  $t_1 := B_0 + t_0$\n3.  $j := \\mathrm{mem}[t_1]$\n4.  $t_2 := j \\cdot s_A$\n5.  $t_3 := A_0 + t_2$\n\n现在，我们代入给定的数值来计算最终地址。\n提供的数据是：\n- 数组 $A$：基地址 $A_0 = 4096$，元素大小 $s_A = 8$。\n- 数组 $B$：基地址 $B_0 = 2048$，元素大小 $s_B = 4$。\n- 运行时索引：$i = 11$。\n- 内存内容：$B[11]$ 处的值被给定为 $17$。\n\n让我们用这些值来执行 TAC 序列。\n\n步骤 1：计算 $B[11]$ 的地址。\n偏移量是 $i \\cdot s_B = 11 \\cdot 4 = 44$。\n地址是 $\\mathrm{addr}(B[11]) = B_0 + 44 = 2048 + 44 = 2092$。\n所以，$t_1 = 2092$。\n\n步骤 2：加载 $B[11]$ 的值。\n问题陈述指出此位置的值是 $17$。\n所以，$j = \\mathrm{mem}[2092] = 17$。\n\n步骤 3：计算 $A[17]$ 的地址。\n我们使用加载的值 $j = 17$ 作为数组 $A$ 的索引。\n偏移量是 $j \\cdot s_A = 17 \\cdot 8 = 136$。\n最终地址是 $\\mathrm{addr}(A[17]) = A_0 + 136 = 4096 + 136 = 4232$。\n\n因此，表达式 $A[B[i]]$ 的最终字节地址是 $4232$。",
            "answer": "$$\n\\boxed{4232}\n$$"
        }
    ]
}