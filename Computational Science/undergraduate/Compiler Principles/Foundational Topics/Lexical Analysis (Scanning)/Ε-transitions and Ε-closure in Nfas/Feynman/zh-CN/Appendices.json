{
    "hands_on_practices": [
        {
            "introduction": "本练习将带你完整地走过一个核心流程：使用汤普森构造法将一个正则表达式转换为等价的 NFA，然后通过计算 ε-闭包来模拟其对输入符号的响应。这个过程不仅是理解正则表达式和自动机之间理论联系的关键，也是构建词法分析器等工具的基础实践 。通过这个练习，你将熟练掌握如何系统地构建和分析 NFA 的状态转换。",
            "id": "3683735",
            "problem": "考虑正则表达式 (regex) $(a \\mid b)^{*}a$。使用汤普森构造法 (Thompson’s construction)，为该正则表达式构建一个非确定性有限自动机 (NFA)，并仅从基本定义出发：一个 NFA 由一个有限的状态集、一个包含输入符号标记的转移和空串 (epsilon) 转移的转移关系、以及一个指定的开始状态和接受状态组成；一个 $\\varepsilon$-转移（epsilon-transition）在不消耗输入的情况下使自动机发生状态变化；一个状态集的 $\\varepsilon$-闭包 (epsilon-closure) 是从该集合仅通过 $\\varepsilon$-转移可达的所有状态的集合。汤普森构造法关于文字、连接、选择和克林闭包（Kleene star）的应用应遵循其标准规则：对于一个文字 $x$，创建两个状态，并在它们之间添加一个标记为 $x$ 的转移；对于连接，通过一个 $\\varepsilon$-转移将左侧子 NFA 的接受状态连接到右侧子 NFA 的开始状态；对于选择，创建一个新的开始状态，通过 $\\varepsilon$-转移连接到各子 NFA 的开始状态，并创建一个新的接受状态，从各子 NFA 的接受状态通过 $\\varepsilon$-转移连接到该新接受状态；对于克林闭包，创建一个新的开始状态和接受状态，添加从新开始状态到子 NFA 的开始状态和新接受状态的 $\\varepsilon$-转移，以及从子 NFA 的接受状态到其开始状态和新接受状态的 $\\varepsilon$-转移。\n\n请按特定顺序构造 NFA：首先为 $a$ 构建子 NFA，然后为 $b$ 构建子 NFA，接着构成选择 $(a \\mid b)$，然后应用克林闭包 $(a \\mid b)^{*}$，再为最后的文字 $a$ 构建子 NFA，最后将 $(a \\mid b)^{*}$ 与 $a$ 连接起来。从 $0$ 开始用整数标记状态，在创建每个新状态时，按照刚才描述的组件构造顺序，严格递增地分配新的状态标签。在完整的 NFA 构建完成后，根据汤普森方法确定总的开始状态和接受状态。\n\n计算从总开始状态出发的初始 $\\varepsilon$-闭包。然后，通过从该初始 $\\varepsilon$-闭包中的状态出发，执行所有标记为 $b$ 的移动，来模拟消耗单个输入符号 $b$ 的过程，并计算所得状态集的 $\\varepsilon$-闭包。作为最终结果，报告消耗 $b$ 之后该 $\\varepsilon$-闭包的基数（状态数量）。你的答案必须是一个不带单位的整数。不需要四舍五入。",
            "solution": "问题陈述经评估有效。它在科学上基于形式语言理论的原理，特别是关于非确定性有限自动机 (NFA) 的构造和模拟。该问题定义明确，提供了精确的正则表达式、特定的构造算法（汤普森构造法）和严格的状态标记协议。目标清晰明确，能够导出一个唯一的、可验证的解。\n\n我们开始逐步为正则表达式 $(a \\mid b)^{*}a$ 构建 NFA，遵循指定的顺序并从 $0$ 开始顺序标记状态。\n\n1.  **为第一个文字 `a` 构建 NFA**：我们创建两个状态 $0$ 和 $1$，并在输入符号 $a$ 上添加一个从 $0$ 到 $1$ 的转移。开始状态是 $0$，接受状态是 $1$。\n    - $N(a_1)$: 状态 $\\{0, 1\\}$，开始状态 $0$，接受状态 $1$，转移 $0 \\xrightarrow{a} 1$。\n\n2.  **为文字 `b` 构建 NFA**：我们创建两个新状态 $2$ 和 $3$，并在输入符号 $b$ 上添加一个从 $2$ 到 $3$ 的转移。\n    - $N(b)$: 状态 $\\{2, 3\\}$，开始状态 $2$，接受状态 $3$，转移 $2 \\xrightarrow{b} 3$。\n\n3.  **为选择 `(a | b)` 构建 NFA**：我们使用选择规则组合 $N(a_1)$ 和 $N(b)$。我们创建一个新的开始状态 $4$ 和一个新的接受状态 $5$。我们添加从新开始状态到旧开始状态的 $\\varepsilon$-转移（$4 \\xrightarrow{\\varepsilon} 0$ 和 $4 \\xrightarrow{\\varepsilon} 2$），以及从旧接受状态到新接受状态的 $\\varepsilon$-转移（$1 \\xrightarrow{\\varepsilon} 5$ 和 $3 \\xrightarrow{\\varepsilon} 5$）。\n    - $N(a \\mid b)$: 状态 $\\{0, 1, 2, 3, 4, 5\\}$，开始状态 $4$，接受状态 $5$。\n\n4.  **为克林闭包 `(a | b)*` 构建 NFA**：我们对 $N(a \\mid b)$ 应用克林闭包操作。我们创建一个新的开始状态 $6$ 和一个新的接受状态 $7$。我们添加以下 $\\varepsilon$-转移：\n    - 从新开始状态到旧开始状态：$6 \\xrightarrow{\\varepsilon} 4$。\n    - 从新开始状态到新接受状态（对于空字符串情况）：$6 \\xrightarrow{\\varepsilon} 7$。\n    - 从旧接受状态到旧开始状态（用于重复）：$5 \\xrightarrow{\\varepsilon} 4$。\n    - 从旧接受状态到新接受状态（用于退出循环）：$5 \\xrightarrow{\\varepsilon} 7$。\n    - $N((a \\mid b)^{*})$: 状态 $\\{0, 1, 2, 3, 4, 5, 6, 7\\}$，开始状态 $6$，接受状态 $7$。\n\n5.  **为第二个文字 `a` 构建 NFA**：我们为表达式中最后的 $a$ 创建两个新状态 $8$ 和 $9$。\n    - $N(a_2)$: 状态 $\\{8, 9\\}$，开始状态 $8$，接受状态 $9$，转移 $8 \\xrightarrow{a} 9$。\n\n6.  **为连接 `(a | b)*a` 构建 NFA**：我们连接 $N((a \\mid b)^{*})$ 和 $N(a_2)$。这通过添加一个从第一个 NFA 的接受状态 ($7$) 到第二个 NFA 的开始状态 ($8$) 的 $\\varepsilon$-转移来完成。最终的开始状态是第一个 NFA 的开始状态 ($6$)，接受状态是第二个 NFA 的接受状态 ($9$)。\n    - 转移：$7 \\xrightarrow{\\varepsilon} 8$。\n    - $(a \\mid b)^{*}a$ 的完整 NFA 的开始状态是 $6$，接受状态是 $9$。\n\n最终 NFA 的完整转移集合如下：\n- $0 \\xrightarrow{a} 1$\n- $1 \\xrightarrow{\\varepsilon} 5$\n- $2 \\xrightarrow{b} 3$\n- $3 \\xrightarrow{\\varepsilon} 5$\n- $4 \\xrightarrow{\\varepsilon} 0$\n- $4 \\xrightarrow{\\varepsilon} 2$\n- $5 \\xrightarrow{\\varepsilon} 4$\n- $5 \\xrightarrow{\\varepsilon} 7$\n- $6 \\xrightarrow{\\varepsilon} 4$\n- $6 \\xrightarrow{\\varepsilon} 7$\n- $7 \\xrightarrow{\\varepsilon} 8$\n- $8 \\xrightarrow{a} 9$\n\n接下来，我们按要求执行模拟。\n\nNFA 的总开始状态是 $q_{start} = 6$。第一步是计算开始状态的 $\\varepsilon$-闭包，记为 $\\text{ECLOSE}(\\{6\\})$。这是从状态 $6$ 仅通过 $\\varepsilon$-转移可达的所有状态的集合。\n- 从集合 $\\{6\\}$ 开始。\n- 从状态 $6$，我们可以通过 $\\varepsilon$-转移到达状态 $4$ 和 $7$。集合变为 $\\{4, 6, 7\\}$。\n- 从状态 $4$，我们可以通过 $\\varepsilon$-转移到达状态 $0$ 和 $2$。集合变为 $\\{0, 2, 4, 6, 7\\}$。\n- 从状态 $7$，我们可以通过一个 $\\varepsilon$-转移到达状态 $8$。集合变为 $\\{0, 2, 4, 6, 7, 8\\}$。\n- 状态 $0$、$2$ 和 $8$ 没有出射的 $\\varepsilon$-转移。闭包计算完成。\n所以，初始 $\\varepsilon$-闭包是 $S_0 = \\text{ECLOSE}(\\{6\\}) = \\{0, 2, 4, 6, 7, 8\\}$。\n\n第二步是找出从 $S_0$ 消耗输入符号 $b$ 后可达的状态集。这是集合 $\\text{move}(S_0, b)$。我们检查 $S_0$ 中的每个状态：\n- 状态 $0$：有一个在 $a$ 上的出射转移，而不是 $b$。\n- 状态 $2$：有一个出射转移 $2 \\xrightarrow{b} 3$。这导致状态 $3$。\n- 状态 $4$：只有 $\\varepsilon$-转移。\n- 状态 $6$：只有 $\\varepsilon$-转移。\n- 状态 $7$：只有一个 $\\varepsilon$-转移。\n- 状态 $8$：有一个在 $a$ 上的出射转移，而不是 $b$。\n唯一的结果状态是 $3$。所以，$S_1 = \\text{move}(S_0, b) = \\{3\\}$。\n\n最后一步是计算结果集 $S_1$ 的 $\\varepsilon$-闭包。我们需要计算 $\\text{ECLOSE}(\\{3\\})$。\n- 从集合 $\\{3\\}$ 开始。\n- 从状态 $3$，我们可以通过一个 $\\varepsilon$-转移（$3 \\xrightarrow{\\varepsilon} 5$）到达状态 $5$。集合变为 $\\{3, 5\\}$。\n- 从状态 $5$，我们可以通过 $\\varepsilon$-转移（$5 \\xrightarrow{\\varepsilon} 4$，$5 \\xrightarrow{\\varepsilon} 7$）到达状态 $4$ 和 $7$。集合变为 $\\{3, 4, 5, 7\\}$。\n- 从状态 $4$，我们可以到达状态 $0$ 和 $2$（$4 \\xrightarrow{\\varepsilon} 0$，$4 \\xrightarrow{\\varepsilon} 2$）。集合变为 $\\{0, 2, 3, 4, 5, 7\\}$。\n- 从状态 $7$，我们可以到达状态 $8$（$7 \\xrightarrow{\\varepsilon} 8$）。集合变为 $\\{0, 2, 3, 4, 5, 7, 8\\}$。\n- 状态 $0$、$2$ 和 $8$ 没有出射的 $\\varepsilon$-转移。闭包计算过程完成。\n最终的集合是 $S_{final} = \\text{ECLOSE}(\\{3\\}) = \\{0, 2, 3, 4, 5, 7, 8\\}$。\n\n问题要求这个最终集合的基数。\n基数是 $S_{final}$ 中的状态数：$|\\{0, 2, 3, 4, 5, 7, 8\\}| = 7$。",
            "answer": "$$\n\\boxed{7}\n$$"
        },
        {
            "introduction": "理论知识最终需要通过代码实现来巩固。这个实践任务要求你编写一个计算 ε-闭包的函数，并用一系列精心设计的测试用例来验证其健壮性 。这不仅是对图遍历算法（如深度优先搜索）的直接应用，更能让你深刻理解在处理循环、多重边等复杂情况下，ε-闭包算法的实现细节和正确性保证。",
            "id": "3683779",
            "problem": "你需要用一种通用编程语言实现一个鲁棒的函数，该函数用于计算一个非确定性有限自动机（NFA）中一个状态集的 epsilon-闭包。你的程序必须嵌入并执行一个预定义的单元测试套件，该套件用于检验在包括自循环、多重边、不连通分量、环、空转移集和空起始集等边缘情况下的正确性。程序必须将所有测试用例的结果生成为精确格式化的单行输出。\n\n使用的基本原理和定义：\n- 一个 NFA 是一个五元组 $(Q,\\Sigma,\\delta,q_0,F)$，其中 $Q$ 是一个有限的状态集，$\\Sigma$ 是一个输入字母表，$\\delta: Q \\times (\\Sigma \\cup \\{\\varepsilon\\}) \\to \\mathcal{P}(Q)$ 是一个转移函数，$q_0 \\in Q$ 是起始状态，$F \\subseteq Q$ 是接受状态集。在本问题中，只有 $\\varepsilon$-转移是相关的。\n- 对于一个状态集 $S \\subseteq Q$，其 epsilon-闭包 $\\varepsilon\\text{-closure}(S)$ 定义为满足以下条件的最小集 $C \\subseteq Q$：\n  - $S \\subseteq C$，且\n  - 对于任何 $p \\in C$，如果存在一个从 $p$到 $q$ 的 $\\varepsilon$-转移（即 $q \\in \\delta(p,\\varepsilon)$），那么 $q \\in C$。\n- 这里的最小集是相对于集合包含关系而言的，并且可以被描述为从 $S$ 出发，经过零次或多次 $\\varepsilon$-转移可达的所有状态的集合。\n\n表示方法与约束：\n- 状态由非负整数标识，$Q = \\{0,1,\\dots,N-1\\}$，其中 $N \\ge 1$ 为某个整数。\n- $\\varepsilon$-转移关系表示为 $Q$ 上的一个有向图，由一个有序对的多重集 $E_\\varepsilon \\subseteq Q \\times Q$ 定义。允许多重边，即同一个有序对可以出现多次。也允许自循环。\n- 输入字母表 $\\Sigma$、非 $\\varepsilon$ 转移和接受状态与此任务无关，必须忽略。\n\n你的 epsilon-闭包函数必须接受一个集合 $S \\subseteq Q$（可能为空），并返回集合 $\\varepsilon\\text{-closure}(S)$，其形式为一个按升序排列的、包含不重复状态标识符的排序列表。\n\n嵌入程序中的测试套件规范：\n- 使用以下七个测试用例。对于每个测试用例，都给定了状态数 $N$、以有序对形式列出的 $\\varepsilon$-边多重集 $E_\\varepsilon$ 以及起始集 $S$。\n  - 测试用例 1 (自循环加前向链):\n    - $N = 4$\n    - $E_\\varepsilon = \\{(0,0),(0,1),(1,2)\\}$\n    - $S = \\{0\\}$\n  - 测试用例 2 (多重边):\n    - $N = 4$\n    - $E_\\varepsilon = \\{(1,2),(1,2),(2,3),(2,3)\\}$\n    - $S = \\{1\\}$\n  - 测试用例 3 (不连通分量；隔离查询):\n    - $N = 6$\n    - $E_\\varepsilon = \\{(0,1),(1,2),(3,4)\\}$\n    - $S = \\{5\\}$\n  - 测试用例 4 (空 $\\varepsilon$-转移图；多源集):\n    - $N = 3$\n    - $E_\\varepsilon = \\varnothing$\n    - $S = \\{0,2\\}$\n  - 测试用例 5 (通过 $\\varepsilon$-转移形成的环):\n    - $N = 5$\n    - $E_\\varepsilon = \\{(0,1),(1,0),(1,2),(2,1)\\}$\n    - $S = \\{0\\}$\n  - 测试用例 6 (在带自循环的图上的空起始集):\n    - $N = 1$\n    - $E_\\varepsilon = \\{(0,0)\\}$\n    - $S = \\varnothing$\n  - 测试用例 7 (分支、多个分量的并集以及一个不可达的自循环):\n    - $N = 7$\n    - $E_\\varepsilon = \\{(0,1),(1,2),(1,3),(3,5),(4,4),(2,6)\\}$\n    - $S = \\{1,4\\}$\n\n算法期望：\n- 计算必须仅依赖于 $\\varepsilon\\text{-closure}(S)$ 作为 $\\varepsilon$-可达性下的最小不动点的定义。这可以通过从 $S$ 开始，在 $\\varepsilon$-边上进行图可达性计算来实现，同时维护一个已访问集合以避免在环上无限回归并合并多重边。\n- 自循环、环和多重边不得导致程序不终止或输出重复；必须通过集合语义消除重复项，并且最终输出必须按升序排序。\n\n答案类型和最终输出格式：\n- 对于每个测试用例，结果是一个整数列表，表示按升序排列的 $\\varepsilon\\text{-closure}(S)$。对于空集，输出一个空列表。\n- 你的程序应生成单行输出，其中包含七个测试用例的结果，格式为一个由方括号括起来的、逗号分隔的列表，其中每个单独的结果本身也是一个由方括号括起来的、逗号分隔的、不含空格的状态标识符列表。例如，符合此规范的输出看起来像 $[[0,1],[2],[]]$，其中第三个结果是空列表。你的程序必须严格按照这种单行格式打印聚合结果，不得包含任何额外的字符或空白。",
            "solution": "问题陈述经评估有效。它科学地基于自动机理论的既定原则，该理论是理论计算机科学的一个子领域。问题定义良好，提供了 $\\varepsilon$-闭包的精确、形式化定义，以及一套完整且一致的测试用例。所用语言客观、明确。因此，可以构建一个解决方案。\n\n问题的核心是在一个非确定性有限自动机（NFA）中，计算给定状态集 $S$ 的 $\\varepsilon$-闭包。NFA 的状态以集合 $Q = \\{0, 1, \\dots, N-1\\}$ 的形式给出，其 $\\varepsilon$-转移表示为一个有向图 $G = (Q, E_\\varepsilon)$，其中 $E_\\varepsilon$ 是表示转移的有序对多重集。\n\n$\\varepsilon\\text{-closure}(S)$ 的定义是包含 $S$ 且在 $\\varepsilon$-转移关系下闭合的最小集合。这等同于找出 $Q$ 中所有可从 $S$ 内任一状态出发，通过遍历零条或多条 $\\varepsilon$-边到达的状态。这种重新描述将问题框定为图的可达性问题。\n\n在有向图中确定可达性的标准高效算法是图遍历，例如深度优先搜索（DFS）或广度优先搜索（BFS）。我们将采用基于 DFS 的方法。\n\n算法流程如下：\n1. **图表示**：首先将输入的边多重集 $E_\\varepsilon$ 转换为邻接表表示。对于每个状态 $u \\in Q$，我们维护一个状态列表 $v$，其中存在边 $(u, v) \\in E_\\varepsilon$。这允许在单一步骤中高效地检索从给定状态可达的所有状态。\n\n2. **初始化**：我们需要两个辅助数据结构：\n    - 一个集合，用于存储遍历过程中已访问的状态，以避免重复处理并正确处理环。一个大小为 $N$ 的布尔数组（我们称其概念表示为 $V$），初始化为 false，可用于此目的。\n    - 一个栈，我们可称之为 `worklist`，用于管理 DFS 过程中待访问的状态。\n\n3. **遍历的起始**：遍历从初始状态集 $S$ 开始。对于 $S$ 中的每个状态 $s$，我们将其在 $V$ 中的对应条目标记为 true，并将 $s$ 推入 `worklist` 栈中。这确保了 $S$ 中的所有状态都包含在最终的闭包中，满足条件 $S \\subseteq \\varepsilon\\text{-closure}(S)$。\n\n4. **迭代遍历**：算法的主要部分是一个循环，只要 `worklist` 不为空就一直持续。在每次迭代中：\n    - 从 `worklist` 中弹出一个状态 $u$。\n    - 在邻接表中查找 $u$ 的邻居。对于每个邻居 $v$（即对于每个转移 $u \\xrightarrow{\\varepsilon} v$）：\n    - 如果 $v$ 尚未被访问（即其在 $V$ 中的条目为 false），我们将其在 $V$ 中的条目标记为 true，并将其推入 `worklist` 中。\n\n5. **结果提取**：当 `worklist` 为空时，遍历完成。所有已访问状态的集合，即 $V$ 中为 true 的条目所代表的集合，构成了 $\\varepsilon\\text{-closure}(S)$。为了生成所需的排序输出，我们可以从状态 $0$ 迭代到 $N-1$，并收集所有满足其在 $V$ 中第 $i$ 个条目为 true 的状态 $i$。这个过程自然会产生一个闭包中状态的排序列表。\n\n这种算法方法是鲁棒的，并且能正确处理所有指定的边缘情况：\n- **环和自循环**：使用已访问集合 $V$ 确保每个状态最多被处理一次，从而防止遍历陷入无限循环。\n- **多重边**：邻接表的构建或遍历内部的逻辑自然地处理了多重边。虽然一个状态可能被多次添加为邻居，但通过与已访问集合 $V$ 的检查，确保了它仅在第一次遇到时被推入 `worklist`。\n- **不连通分量**：遍历算法只探索从初始集 $S$ 可达的状态。任何处于从 $S$ 不可达的分量中的状态将永远不会被访问。\n- **空起始集 ($S = \\varnothing$)**：如果 $S$ 为空，`worklist` 将不会被填充初始种子，主循环不会执行，最终的闭包被正确地识别为空集。\n- **空转移集 ($E_\\varepsilon = \\varnothing$)**：如果没有转移，那么从 $S$ 无法到达任何新状态。算法将只访问 $S$ 本身中的状态，正确地得出 $\\varepsilon\\text{-closure}(S) = S$。",
            "answer": "```\n[[0,1,2],[1,2,3],[5],[0,2],[0,1,2],[],[1,2,3,4,5,6]]\n```"
        },
        {
            "introduction": "ε-转移虽然功能强大，但在词法分析器等实际应用中也可能引入微妙的陷阱，例如零长度匹配问题。本练习旨在探讨一个其语言包含空串 $ε$ 的 NFA，在遵循“最长匹配”原则的词法分析器中可能引发的问题 。通过分析，你将学会如何将自动机的理论性质（例如，开始状态的 ε-闭包包含接受状态）与实际工具的行为和潜在缺陷联系起来。",
            "id": "3683718",
            "problem": "考虑构建一个词法分析器，它将多个正则表达式词法单元规则组合成一个单一的非确定性有限自动机 (NFA)。NFA 被定义为一个五元组 $\\left(Q,\\Sigma,\\delta,q_0,F\\right)$，其中 $Q$ 是一个有限状态集，$\\Sigma$ 是一个有限输入字母表，$\\delta:Q\\times\\left(\\Sigma\\cup\\{\\varepsilon\\}\\right)\\to 2^Q$ 是转移函数，$q_0\\in Q$ 是起始状态，$F\\subseteq Q$ 是接受状态集。当且仅当存在一条从 $q_0$ 到某个 $f\\in F$ 的路径，其边上的标签（允许 $\\varepsilon$-移动）连接起来等于 $w$ 时，NFA 接受字符串 $w\\in\\Sigma^*$。对于任何状态集 $S\\subseteq Q$，$S$ 的 $\\varepsilon$-闭包，记作 $\\varepsilon\\text{-closure}(S)$，是从 $S$ 中任何状态仅通过零次或多次 $\\varepsilon$-转移可到达的状态集合。在针对多个词法单元规则的标准组合 NFA 构造中，全局起始状态 $q_0$ 具有到每个规则 NFA 起始状态的 $\\varepsilon$-转移。\n\n假设我们在字母表 $\\Sigma=\\{a,b\\}$ 上组合以下两个词法单元规则：\n\n- 规则 A：正则表达式 $a^*$，词法单元类型为 $\\text{A}$。\n- 规则 B：正则表达式 $ab$，词法单元类型为 $\\text{B}$。\n\n令组合后的 NFA $\\mathcal{N}=\\left(Q,\\Sigma,\\delta,q_0,F\\right)$ 使用常规的 NFA 片段：\n\n- 对于 $a^*$，一个单一状态 $q_A$，其中 $\\delta\\!\\left(q_A,a\\right)=\\{q_A\\}$ 且 $q_A\\in F$。\n- 对于 $ab$，一个链式结构 $q_B \\xrightarrow{a} p_1 \\xrightarrow{b} p_2$，其中 $p_2\\in F$。\n\n组合过程引入了 $\\delta\\!\\left(q_0,\\varepsilon\\right)=\\{q_A,q_B\\}$，并且没有其他 $\\varepsilon$-转移。除了所述的转移外，没有其他转移。假设词法分析器实现常规的最长匹配（maximal-munch）策略：在所有模式匹配剩余输入前缀的词法单元中，它会在当前位置输出消耗长度最长的那一个，并在出现平局时使用规则优先级。\n\n仅使用上述基本原理和构造方法，推断关于 $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 的性质，以及是否有任何接受状态可以在不消耗输入的情况下达到，然后考虑其对词法分析器的操作影响。选择所有正确的陈述：\n\nA. $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 包含一个接受状态，因此 $\\mathcal{N}$ 接受 $\\varepsilon$。在词法分析器中，这可能导致在没有其他规则匹配任何符号的位置上，输出零长度的词法单元。\n\nB. 对于输入 $\\text{\"ab\"}$，最长匹配策略会输出消耗 $\\text{\"ab\"}$ 的词法单元 $\\text{B}$，而不是长度为 $0$ 或 $1$ 的词法单元 $\\text{A}$，尽管 $\\text{A}$ 的模式能匹配 $\\varepsilon$。\n\nC. 将 $a^*$ 替换为 $a^+$ 会从规则 A 的语言中移除 $\\varepsilon$，并从 $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 中消除任何接受状态；这可以防止零长度词法单元的输出，并修复过早接受的问题。\n\nD. 仅仅将规则 B 的优先级置于规则 A 之上，就足以在所有输入（包括 $\\varepsilon$ 和像 $\\text{\"b\"}$ 这样的输入）上防止零长度词法单元的产生。\n\nE. 移除从 $q_0$ 到 $q_A$ 和 $q_B$ 的 $\\varepsilon$-转移，可以在保留对预期词法单元识别的同时消除过早接受，因为自动机在分支到规则 NFA 之前会等待读取一个符号。\n\n通过选择正确的选项来回答。",
            "solution": "首先将验证问题陈述的科学合理性、清晰度和完整性。\n\n### 步骤 1：提取已知条件\n\n-   **NFA 定义：** NFA 是一个五元组 $\\mathcal{N}=\\left(Q,\\Sigma,\\delta,q_0,F\\right)$。\n    -   $Q$：一个有限状态集。\n    -   $\\Sigma$：一个有限输入字母表。\n    -   $\\delta:Q\\times\\left(\\Sigma\\cup\\{\\varepsilon\\}\\right)\\to 2^Q$：转移函数。\n    -   $q_0\\in Q$：起始状态。\n    -   $F\\subseteq Q$：接受状态集。\n-   **$\\varepsilon$-闭包定义：** 对于一个状态集 $S\\subseteq Q$，$\\varepsilon\\text{-closure}(S)$ 是从 $S$ 中任何状态仅使用零次或多次 $\\varepsilon$-转移可到达的状态集合。\n-   **组合 NFA 构造：** 一个全局起始状态 $q_0$ 具有到每个单独规则 NFA 起始状态的 $\\varepsilon$-转移。\n-   **输入字母表：** $\\Sigma=\\{a,b\\}$。\n-   **词法单元规则：**\n    -   规则 A：正则表达式 $a^*$，词法单元类型为 $\\text{A}$。\n    -   规则 B：正则表达式 $ab$，词法单元类型为 $\\text{B}$。\n-   **NFA 片段：**\n    -   对于 $a^*$：一个单一状态 $q_A$，其中 $\\delta\\!\\left(q_A,a\\right)=\\{q_A\\}$ 且 $q_A\\in F$。这意味着 $q_A$ 既是此片段的起始状态也是接受状态。\n    -   对于 $ab$：一个链式结构 $q_B \\xrightarrow{a} p_1 \\xrightarrow{b} p_2$，其中 $q_B$ 是片段的起始状态且 $p_2\\in F$。\n-   **NFA 组合：** $\\delta\\!\\left(q_0,\\varepsilon\\right)=\\{q_A,q_B\\}$。不存在其他 $\\varepsilon$-转移。\n-   **词法分析器策略：** 最长匹配（maximal-munch）。平局由规则优先级打破。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据：** 该问题牢固地建立在词法分析的标准理论之上，这是编译器设计中的一个核心主题。NFA、$\\varepsilon$-闭包和构造原则的定义都是标准且符合事实的。\n-   **问题良定：** 该问题提供了特定的正则表达式和构造相应 NFA 的精确方法。关于此 NFA 属性及其在词法分析器中行为的问题定义明确，并允许得出唯一的、可推导的解。\n-   **客观性：** 语言是技术性的、精确的，使用了自动机理论中既定的术语。没有主观或模糊的陈述。\n\n该问题没有表现出任何无效性缺陷：\n1.  **科学上不合理：** 这些概念和构造在计算机科学中是标准的。用于 $a^*$ 的 NFA 片段是该语言的一个有效（尽管是最小的）自动机。\n2.  **不相关：** 该问题与扫描器的 $\\varepsilon$-转移和 NFA 构造主题直接相关。\n3.  **不完整/矛盾：** 定义 NFA 所需的所有组件都已提供。定义是一致的。\n4.  **不可行：** 该问题是一个理论练习，不涉及物理上或科学上难以置信的条件。\n5.  **问题非良定：** 基于给定的定义，可以进行唯一的分析。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。将推导出一个完整的解答。\n\n### 推导与选项分析\n\n我们首先根据所提供的信息，正式定义组合后的 NFA $\\mathcal{N}=\\left(Q,\\Sigma,\\delta,q_0,F\\right)$。\n\n-   状态集为 $Q = \\{q_0, q_A, q_B, p_1, p_2\\}$。\n-   字母表为 $\\Sigma = \\{a, b\\}$。\n-   起始状态为 $q_0$。\n-   接受状态集为 $F = \\{q_A, p_2\\}$，因为 $q_A$ 是规则 A 的接受状态，$p_2$ 是规则 B 的接受状态。\n-   转移函数 $\\delta$ 定义如下：\n    -   $\\delta(q_0, \\varepsilon) = \\{q_A, q_B\\}$\n    -   $\\delta(q_A, a) = \\{q_A\\}$\n    -   $\\delta(q_B, a) = \\{p_1\\}$\n    -   $\\delta(p_1, b) = \\{p_2\\}$\n    -   对于所有其他对 $(q, c)$，$\\delta(q, c) = \\emptyset$。\n\n现在我们分析这个 NFA 的属性。\n\n起始状态 $\\{q_0\\}$ 的 $\\varepsilon\\text{-closure}$ 是从 $q_0$ 仅使用 $\\varepsilon$-转移可达的所有状态的集合。根据定义，$q_0$ 在其自身的闭包中（零次转移）。从 $q_0$，我们可以通过一次 $\\varepsilon$-转移到达 $q_A$ 和 $q_B$。从 $q_A$ 或 $q_B$ 没有进一步的 $\\varepsilon$-转移。因此：\n$$ \\varepsilon\\text{-closure}(\\{q_0\\}) = \\{q_0, q_A, q_B\\} $$\n一个 NFA 当且仅当其起始状态的 $\\varepsilon$-闭包包含至少一个接受状态时，才接受空字符串 $\\varepsilon$。在数学上，这表示为 $\\varepsilon\\text{-closure}(\\{q_0\\}) \\cap F \\neq \\emptyset$。\n我们来检查这个条件：\n$$ \\varepsilon\\text{-closure}(\\{q_0\\}) \\cap F = \\{q_0, q_A, q_B\\} \\cap \\{q_A, p_2\\} = \\{q_A\\} $$\n由于交集非空，NFA $\\mathcal{N}$ 接受空字符串 $\\varepsilon$。\n\n现在我们评估每个选项：\n\n**A. $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 包含一个接受状态，因此 $\\mathcal{N}$ 接受 $\\varepsilon$。在词法分析器中，这可能导致在没有其他规则匹配任何符号的位置上，输出零长度的词法单元。**\n-   如上所推导，$\\varepsilon\\text{-closure}(\\{q_0\\}) = \\{q_0, q_A, q_B\\}$。接受状态集为 $F = \\{q_A, p_2\\}$。交集是 $\\{q_A\\}$，非空。所以，起始状态的 $\\varepsilon$-闭包确实包含一个接受状态（$q_A$）。\n-   这直接意味着 NFA $\\mathcal{N}$ 接受空字符串 $\\varepsilon$。\n-   在词法分析器中，如果输入指针位于一个没有任何规则可以匹配非空前缀的位置（例如，输入是 $\"b...\"$ 或到达文件末尾），词法分析器将搜索所有可能的匹配。规则 A ($a^*$) 总能匹配长度为 $0$ 的空字符串 $\\varepsilon$。如果这是找到的唯一匹配，最长匹配策略将选择它。这导致输出一个零长度的词法单元。如果词法分析器没有特殊机制来处理它，这可能导致无限循环，因为输入指针没有前进。该陈述完全正确。\n-   **结论：正确。**\n\n**B. 对于输入 $\\text{\"ab\"}$，最长匹配策略会输出消耗 $\\text{\"ab\"}$ 的词法单元 $\\text{B}$，而不是长度为 $0$ 或 $1$ 的词法单元 $\\text{A}$，尽管 $\\text{A}$ 的模式能匹配 $\\varepsilon$。**\n-   我们来分析输入字符串 $\"ab\"$ 的可能匹配。\n    1.  **规则 A ($a^*$):** 此规则可以匹配前缀 $\\varepsilon$（长度 $0$）和前缀 $\"a\"$（长度 $1$）。相应的词法单元类型为 $\\text{A}$。\n    2.  **规则 B ($ab$):** 此规则可以匹配前缀 $\"ab\"$（长度 $2$）。相应的词法单元类型为 $\\text{B}$。\n-   词法分析器识别出所有可能的匹配及其长度：一个长度为 $0$ 的匹配（类型 $\\text{A}$），一个长度为 $1$ 的匹配（类型 $\\text{A}$），以及一个长度为 $2$ 的匹配（类型 $\\text{B}$）。\n-   最长匹配策略规定词法分析器必须选择最长的有效匹配。在这里，最长的匹配长度为 $2$。\n-   因此，词法分析器将在消耗字符串 $\"ab\"$ 后输出词法单元 $\\text{B}$。来自规则 $\\text{A}$ 的较短匹配被丢弃。该陈述准确地描述了此行为。\n-   **结论：正确。**\n\n**C. 将 $a^*$ 替换为 $a^+$ 会从规则 A 的语言中移除 $\\varepsilon$，并从 $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 中消除任何接受状态；这可以防止零长度词法单元的输出，并修复过早接受的问题。**\n-   正则表达式 $a^+$ 匹配一个或多个 $a$。它的语言不包含空字符串 $\\varepsilon$。\n-   一个标准的 $a^+$ NFA 片段可以构建为 $q_{A,1} \\xrightarrow{a} q_{A,2}$，带有一个循环 $\\delta(q_{A,2}, a) = \\{q_{A,2}\\}$，并且 $q_{A,2}$ 是此片段唯一的接受状态。\n-   在新的组合 NFA 中，组合规则将给出 $\\delta(q_0, \\varepsilon) = \\{q_{A,1}, q_B\\}$。这里，$q_{A,1}$ 是 $a^+$ 片段的起始状态。\n-   新的 $\\varepsilon\\text{-closure}(\\{q_0\\})$ 将是 $\\{q_0, q_{A,1}, q_B\\}$。\n-   新的接受状态集将是 $F' = \\{q_{A,2}, p_2\\}$。\n-   交集是 $\\varepsilon\\text{-closure}(\\{q_0\\}) \\cap F' = \\{q_0, q_{A,1}, q_B\\} \\cap \\{q_{A,2}, p_2\\} = \\emptyset$。\n-   由于起始状态的 $\\varepsilon$-闭包不再包含接受状态，NFA不再接受 $\\varepsilon$。这意味着它永远不能产生零长度的匹配，从而解决了输出零长度词法单元和卡住的问题。该陈述是正确的。\n-   **结论：正确。**\n\n**D. 仅仅将规则 B 的优先级置于规则 A 之上，就足以在所有输入（包括 $\\varepsilon$ 和像 $\\text{\"b\"}$ 这样的输入）上防止零长度词法单元的产生。**\n-   词法分析器的算法首先应用最长匹配规则来找到最长的可能匹配。规则优先级仅用于在多个规则产生*相同*最大长度的匹配时打破平局。\n-   考虑输入字符串 $\"b\"$。\n    -   规则 A ($a^*$) 匹配前缀 $\\varepsilon$（长度 $0$）。\n    -   规则 B ($ab$) 不匹配 $\"b\"$ 的任何前缀，因为第一个字符必须是 $a$。\n-   词法分析器找到的唯一匹配是规则 A 的长度为 $0$ 的匹配。由于这是唯一的匹配，它也是最长的匹配。长度上没有平局，所以规则优先级根本不会被考虑。\n-   词法分析器将选择长度为 $0$ 的匹配并输出一个类型为 $\\text{A}$ 的零长度词法单元。陈述中说优先化规则 B“足以防止”这种情况是错误的。\n-   **结论：错误。**\n\n**E. 移除从 $q_0$ 到 $q_A$ 和 $q_B$ 的 $\\varepsilon$-转移，可以在保留对预期词法单元识别的同时消除过早接受，因为自动机在分支到规则 NFA 之前会等待读取一个符号。**\n-   该陈述建议移除转移 $\\delta(q_0, \\varepsilon) = \\{q_A, q_B\\}$。\n-   根据问题描述，“除了所述的转移外，没有其他转移。” 这意味着如果这些 $\\varepsilon$-转移被移除，状态 $q_0$ 将完全没有出向转移。\n-   一个从状态 $q_0$ 开始且没有任何出向转移的 NFA 永远无法离开 $q_0$。\n-   由于 $q_0$ 不是接受状态（$F = \\{q_A, p_2\\}$），这个修改后的 NFA 在任何输入上都无法到达任何接受状态。\n-   这样一个自动机所识别的语言将是空集 $\\emptyset$。这当然不能“保留对预期词法单元的识别”。自动机变得无法工作。该陈述的前提是根本性错误的。\n-   **结论：错误。**",
            "answer": "$$\\boxed{ABC}$$"
        }
    ]
}