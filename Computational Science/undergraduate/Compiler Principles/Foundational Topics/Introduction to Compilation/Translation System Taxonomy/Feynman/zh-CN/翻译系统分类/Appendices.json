{
    "hands_on_practices": [
        {
            "introduction": "要对翻译系统进行分类，一个核心的维度是区分其“理解”程序的深度。一些系统仅在程序的表面文本上进行操作，而另一些则会深入构建并分析其语义结构。这个练习将通过我们日常Web开发中接触到的工具，来具体化这一区别，帮助你识别哪些系统执行了真正的语义分析，而哪些仅仅是纯粹的语法替换 。这有助于我们为不同类型的翻译器建立一个基本的分类框架。",
            "id": "3678697",
            "problem": "在编译器原理中，一个翻译系统将源语言 $L_s$ 中的字符串映射到目标域中的输出。典型的编译器流水线包含词法分析、语法分析、语义分析和代码生成等阶段。语义分析是根据语言定义检查程序与意义相关的属性的阶段，通常需要一个抽象语法树（AST）以及符号表、作用域解析和类型检查等结构；其形式化通常使用属性文法，在AST上计算属性以强制执行约束。相比之下，纯粹的语法替换操作于表层形式，而不会为源语言构建AST或强制执行作用域和类型规则；例子包括由文本标记上的模式匹配驱动的宏展开和模板替换。\n\n考虑以下四个Web开发翻译系统，每个系统都将一些输入文本映射到浏览器或运行时所消耗的输出。你的任务是分类哪些系统必然执行语义分析（如上定义）而非纯粹的语法替换。\n\n- 系统 $T_1$：一个 Mustache 风格的模板引擎，它将像 `{{name}}` 这样的分隔符替换为来自上下文对象的值，支持通过迭代上下文中的数组来重复片段的迭代部分，并将结果字符串插入到超文本标记语言（HTML）页面中。它不解析层叠样式表（CSS）或 JavaScript（JS），不为模板语言构建抽象语法树（AST），也不执行类型检查或符号表构建；未定义的变量仅渲染为空字符串。\n\n- 系统 $T_2$：一个用正则表达式实现的 JavaScript XML（JSX）转换器，它扫描 JavaScript 源文本以查找尖括号括起来的标签，然后在文本中注入对库函数的调用。它不调用 JavaScript 解析器，不跟踪标识符绑定，并且不知道字符串或注释等嵌套的语法上下文；它在标签出现在字符串或模板字面量内部的输入上会失败。\n\n- 系统 $T_3$：一个 Babel transpiler 插件，它接收现代 JavaScript（ECMAScript (ES) 版本 $6$）并输出 ES 版本 $5$。它首先将输入解析成一个抽象语法树（AST），然后将箭头函数转换为函数表达式，并将块级作用域声明转换为函数级作用域声明。在转换过程中，它执行作用域分析以避免变量捕获，并在必要时维护一个符号表来重命名标识符。\n\n- 系统 $T_4$：一个 TypeScript 到 JavaScript 的 transpiler，它在通过擦除类型来生成 JavaScript 之前，根据 TypeScript 规范对程序进行完全的类型检查。该 transpiler 构建一个符号表，解析导入和命名空间，并拒绝存在类型不匹配的程序。生成的 JavaScript 除了类型注解外，与原始程序相对应。\n\n哪个选项正确列出了属于语义分析类别而非纯粹语法替换的系统？\n\nA. $T_3$ 和 $T_4$\n\nB. $T_2$、$T_3$ 和 $T_4$\n\nC. $T_1$ 和 $T_3$\n\nD. $T_1$、$T_2$ 和 $T_4$",
            "solution": "首先将验证问题陈述，以确保其科学性、自洽性和客观性。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n\n问题提供了以下定义和描述：\n-   **翻译系统：** 一个将源语言（表示为 $L_s$）中的字符串映射到目标域中的输出的系统。\n-   **典型编译器流水线：** 包含词法分析、语法分析、语义分析和代码生成等阶段。\n-   **语义分析：** 定义为这样一个阶段：\n    1.  检查程序与意义相关的属性。\n    2.  通常需要一个抽象语法树（AST）。\n    3.  使用符号表、作用域解析和类型检查等结构。\n    4.  可以使用属性文法进行形式化。\n-   **纯粹的语法替换：** 定义为这样一个过程：\n    1.  操作于表层形式（例如，文本标记）。\n    2.  不为源语言构建AST。\n    3.  不强制执行作用域和类型规则。\n    4.  例子包括宏展开和模板替换。\n\n问题接着描述了四个翻译系统：\n-   **系统 $T_1$ (Mustache 风格的模板引擎)：** 将像 `{{name}}` 这样的分隔符替换为上下文值。它明确“不为模板语言构建抽象语法树（AST），也不执行类型检查或符号表构建”。未定义的变量被渲染为空字符串。\n-   **系统 $T_2$ (使用正则表达式的JSX转换器)：** 使用正则表达式扫描 JavaScript 文本以查找标签，并注入函数调用。它明确“不调用 JavaScript 解析器，不跟踪标识符绑定，并且不知道嵌套的语法上下文”。\n-   **系统 $T_3$ (Babel transpiler 插件)：** 将 ECMAScript (ES) 版本 $6$ 转换为 ES 版本 $5$。它“将输入解析成一个抽象语法树（AST）”， “执行作用域分析以避免变量捕获”，并“维护一个符号表来在必要时重命名标识符”。\n-   **系统 $T_4$ (TypeScript 到 JavaScript 的 transpiler)：** 它在生成 JavaScript 之前“对程序进行完全的类型检查”，“构建一个符号表”，“解析导入和命名空间”，并“拒绝存在类型不匹配的程序”。\n\n任务是确定这些系统（$T_1$, $T_2$, $T_3$, $T_4$）中哪些执行了所定义的语义分析。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题陈述进行评估。\n-   **科学性：** 该问题牢固地植根于编译器设计的既定原则，这是计算机科学的一个核心领域。语义分析、AST、符号表、作用域和类型检查的定义都是标准且准确的。所举的技术示例（Mustache、JSX、Babel、TypeScript）都是真实世界的，其描述的行为与它们（或类似系统）的运作方式一致。\n-   **良构性（Well-Posed）：** 这个问题是良构的。它为两个感兴趣的类别（“语义分析”和“纯粹的语法替换”）提供了清晰、明确的定义。然后，它描述了四个系统，并提供了足够的细节以便根据这些定义对它们进行分类。问题清晰明确，指导解答者执行此分类。存在唯一的解。\n-   **客观性：** 语言技术性强、精确，没有主观或含糊的术语。对系统的描述是基于事实的，并依据其操作机制。\n\n问题陈述没有明显的缺陷。它在科学上不是不健全的，也不是不完整、矛盾、不现实或含糊不清的。它是编译器原理领域一个有效、结构良好的问题。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。现在开始解答过程。\n\n**解题推导**\n\n任务是根据所提供的定义，将每个系统（$T_1$, $T_2$, $T_3$, $T_4$）分类为执行“语义分析”或“纯粹的语法替换”。\n\n一个系统执行**语义分析**，如果它检查与意义相关的属性，这需要构建一个AST并使用像符号表这样的结构来进行作用域解析或类型检查。\n一个系统执行**纯粹的语法替换**，如果它在表层文本上操作，而不构建AST，也不强制执行作用域或类型规则。\n\n**系统 $T_1$ 的分析：**\n对 $T_1$ 的描述明确指出它“不为模板语言构建抽象语法树（AST）”并且“不执行类型检查或符号表构建”。相反，它基于分隔符执行文本替换。这种行为完全符合“纯粹的语法替换”的定义。因此，$T_1$ 不执行语义分析。\n\n**系统 $T_2$ 的分析：**\n对 $T_2$ 的描述指出它使用“正则表达式”来“扫描……源文本”。它“不调用 JavaScript 解析器”并且“不跟踪标识符绑定”。在没有解析的情况下使用正则表达式对原始文本进行操作是表层替换的标志，而不是深层的结构或语义理解。无法处理像字符串这样的嵌套上下文进一步证实了它缺乏语法意识，更不用说语义意识了。这符合“纯粹的语法替换”的定义。因此，$T_2$ 不执行语义分析。\n\n**系统 $T_3$ 的分析：**\n对 $T_3$ 的描述指出它“将输入解析成一个抽象语法树（AST）”。此外，它“执行作用域分析”并“维护一个符号表”。这些行为——构建AST、管理符号表和分析作用域——是问题陈述中定义的语义分析的核心活动。重命名标识符的目的是在转换过程中保留程序的意义（语义）。因此，$T_3$ 执行语义分析。\n\n**系统 $T_4$ 的分析：**\n对 $T_4$ 的描述指出它“对程序进行完全的类型检查”，“构建一个符号表”，并“解析导入和命名空间”。类型检查是语义分析的一种主要且关键的形式。构建符号表和解析命名空间也是此阶段的重要组成部分，因为它们决定了标识符的意义和关系。如果没有先将代码解析成AST以获得一个可操作的结构，这些活动是不可能完成的。因此，$T_4$ 执行语义分析。\n\n**结论：**\n根据分析，系统 $T_3$ 和 $T_4$ 是执行语义分析的系统。系统 $T_1$ 和 $T_2$ 是纯粹语法替换的例子。问题要求找出属于语义分析类别的系统。这些是 $T_3$ 和 $T_4$。\n\n**选项逐一分析**\n\n-   **A. $T_3$ 和 $T_4$**: 该选项列出了被确定为执行语义分析的两个系统，$T_3$ 和 $T_4$。\n    **结论：正确。**\n\n-   **B. $T_2$, $T_3$, 和 $T_4$**: 该选项错误地包含了 $T_2$，它被确定为纯粹的语法替换系统。\n    **结论：不正确。**\n\n-   **C. $T_1$ 和 $T_3$**: 该选项错误地包含了 $T_1$，它被确定为纯粹的语法替换系统。\n    **结论：不正确。**\n\n-   **D. $T_1$, $T_2$, 和 $T_4$**: 该选项错误地包含了 $T_1$ 和 $T_2$，它们被确定为纯粹的语法替换系统。\n    **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "理解了语义分析的重要性后，我们进一步探索编译器内部的构造。编译过程并非一个铁板一块的黑箱，而是一个分阶段的流水线，每个阶段都处理和生成特定的数据结构。这个练习通过一个假想的宏系统 $\\mathcal{M}$，挑战我们思考不同功能的宏应该被放置在编译流水线的哪个阶段 。通过为这些宏找到“正确的位置”，你将能更深刻地理解编译流程中从词法分析到语义分析的数据流和依赖关系。",
            "id": "3678689",
            "problem": "考虑一个源语言 $\\mathcal{L}$，其到目标语言 $\\mathcal{T}$ 的翻译系统被组织为一系列阶段：词法分析、解析为抽象语法树 (AST)、包括类型检查的语义分析、优化和代码生成。在编译器原理的意义上，一个翻译系统被定义为一组分阶段的转换，这些转换在生成 $\\mathcal{T}$ 的同时保留 $\\mathcal{L}$ 的预期语义。一个独立的预翻译工具是独立于翻译器的外部工具，它在运行时无法访问编译器内部的产物，如 AST 或符号表；它可以在翻译器开始工作前修改源文本，但它本身不属于语言的一个语义阶段。\n\n现为语言 $\\mathcal{L}$ 提出了一个宏处理器 $\\mathcal{M}$，它支持三种构造：\n\n- 构造 $1$：基于模式的卫生宏，它匹配已解析的 AST 形式并展开为新的 AST，通过与编译器符号表绑定的生成的唯一标识符来引入新的词法绑定。卫生性保证了新引入的绑定不会意外地捕获或被现有标识符捕获。\n\n- 构造 $2$：作用于词法单元流的条件包含指令，如 $\\mathsf{ifdef}$ 和 $\\mathsf{endif}$，仅由外部配置标志控制。它们在语法分析之前运行，可以在不检查语言级语义的情况下排除或包含词法单元序列。\n\n- 构造 $3$：类型导向的宏，它根据宏参数的静态类型在多个专用函数调用之间进行选择。其展开需要类型推断后已解析类型的知识，并可能查询符号表和重载决议的结果。\n\n你必须根据翻译系统的分类法对 $\\mathcal{M}$ 进行归类，并将每种构造放置在编译流水线中的适当位置，以保证保留 $\\mathcal{L}$ 的预期语义并且在科学上是合理的。选择最能反映对所有三种构造的正确分类和放置策略的选项。\n\nA. 将 $\\mathcal{M}$ 的所有构造都视为一个独立的预翻译工具，在词法分析之前完全运行 $\\mathcal{M}$。理由是：宏展开纯粹是文本性的，独立于编译器；编译器只看到展开后的文本，然后照常执行其各个阶段。\n\nB. 仅将构造 $1$ 集成到翻译器中，将卫生宏展开置于语法分析之后和语义分析之前，但将构造 $2$ 和 $3$ 视为外部预翻译，在词法分析之前完全运行。\n\nC. 将 $\\mathcal{M}$ 作为翻译器的一部分。将构造 $2$ 放置在语法分析之前，作用于词法单元流，作为一个集成到前端的早期文本门控；将构造 $1$ 放置在语法分析和语义分析之间，作用于可访问符号表的 AST；将构造 $3$ 放置在类型决议之后的语义分析阶段内，允许基于已解析的静态类型做出展开决策。\n\nD. 在代码生成后运行 $\\mathcal{M}$，通过宏展开来转换机器码。理由是：通过延迟展开，可以利用目标表示来指导宏决策，同时避免干扰早期的分析。\n\nE. 将所有构造都集成在语法分析之后但在类型决议严格之前，这样宏系统只能看到语法而看不到任何语义信息。理由是：统一放置简化了流水线并避免了外部预处理，同时使宏远离词法分析。",
            "solution": "该问题要求对为语言 $\\mathcal{L}$ 提出的宏处理器 $\\mathcal{M}$ 进行分析，并将其正确定位在一个标准的编译流水线中。给定的流水线为：词法分析 $\\rightarrow$ 解析为抽象语法树 (AST) $\\rightarrow$ 语义分析 (包括类型检查) $\\rightarrow$ 优化 $\\rightarrow$ 代码生成。首先必须评估问题陈述的有效性。\n\n### 问题有效性验证\n\n**第 1 步：提取已知条件**\n- **编译流水线**：词法分析 $\\rightarrow$ 语法分析 (生成 AST) $\\rightarrow$ 语义分析 (带类型检查) $\\rightarrow$ 优化 $\\rightarrow$ 代码生成。\n- **源语言**：$\\mathcal{L}$。\n- **目标语言**：$\\mathcal{T}$。\n- **预翻译工具定义**：独立于翻译器，运行时无法访问编译器内部产物 (AST, 符号表)，在翻译前修改源文本，并且不属于语义阶段。\n- **宏处理器 $\\mathcal{M}$ 的构造**：\n    1.  **构造 1 (卫生宏)**：匹配已解析的 AST 形式，展开为新的 AST，使用与编译器符号表绑定的唯一标识符引入词法绑定。\n    2.  **构造 2 (条件包含)**：作用于词法单元流 ($\\mathsf{ifdef}$)，由外部标志控制，在语法分析之前运行，不检查语言级语义。\n    3.  **构造 3 (类型导向的宏)**：根据参数的静态类型选择函数调用，需要类型推断后已解析类型的知识，并可能查询符号表和重载决议的结果。\n\n**第 2 步：使用提取的已知条件进行验证**\n问题陈述在科学上是合理的、定义明确且客观的。它使用了编译器设计领域的标准术语。\n- **科学合理性**：编译阶段 (词法分析、语法分析、语义分析)、内部表示 (AST, 符号表) 以及不同的宏展开策略 (基于文本/词法单元、基于 AST、类型导向) 的概念是计算机科学中基础且公认的。三种构造的描述与现实世界中的语言特性一致 (例如，构造 2 对应 C 风格的预处理器，构造 1 对应 Lisp/Scheme 的宏，构造 3 对应像 Nim 或 D 这样的语言中的元编程特性)。\n- **定义明确性**：每种构造的属性都为其在编译流水线中的位置提供了具体的约束。例如，一个操作 AST 的构造必须放在语法分析之后，而一个依赖于已解析类型的构造必须放在语义分析的相关阶段之后。这些约束是清晰且充分的，足以确定一个唯一的、合乎逻辑的安排。\n- **客观性**：问题以精确、技术性的术语陈述，没有歧义或主观论断。任务是找到一个科学上合理的放置方式，这在编译器工程领域是一个客观的标准。\n\n该问题没有表现出任何诸如事实不成立、不完整、矛盾或含糊不清的缺陷。定义是自洽的，足以进行严谨的分析。\n\n**第 3 步：结论与行动**\n问题是有效的。解决方案将通过分析每种构造的放置要求来展开。\n\n### 解决方案的推导\n\n每种宏构造的正确放置位置取决于它对编译过程中产生的数据结构的依赖关系。\n\n1.  **构造 1 (卫生宏) 的分析**：\n    - 描述中称其“匹配已解析的 AST 形式并展开为新的 AST”。这明确要求存在一个抽象语法树 (AST)。AST 是语法分析阶段的输出。因此，该构造必须在语法分析*之后*运行。\n    - 它还需要“与编译器符号表绑定”以生成用于卫生性的唯一标识符。这证实了它不是一个外部工具，而必须与编译器的内部状态集成。\n    - 其输出是一个新的 AST，随后必须对其进行语义正确性分析 (例如，类型检查)。因此，展开应发生在语义分析*之前*。\n    - **构造 1 的结论**：放置在语法分析阶段和语义分析阶段之间。\n\n2.  **构造 2 (条件包含) 的分析**：\n    - 描述指明它“作用于词法单元流”并且“在语法分析之前运行”。词法单元流是词法分析阶段的输出和语法分析阶段的输入。\n    - 它基于“外部配置标志”运行，并且不需要“语言级语义”。这使其成为一个简单的、非语义的过滤步骤。\n    - 这种行为是集成到编译器前端的预处理器的典型特征，它在词法单元被送入语法分析器之前对其进行操作。\n    - **构造 2 的结论**：放置在词法分析 (生成词法单元流) 之后和语法分析之前。\n\n3.  **构造 3 (类型导向的宏) 的分析**：\n    - 其定义是，它基于“宏参数的静态类型”进行展开，并“需要类型推断后已解析类型的知识”以及“重载决议的结果”。\n    - 类型推断、类型检查和重载决议是语义分析阶段的主要职责。该构造的宏展开器在这些信息可用之前无法运行。\n    - 因此，这种展开必须在语义分析阶段计算出必要的类型信息*期间*或*之后*发生。它作用于一个经过语义注解的 AST。\n    - **构造 3 的结论**：放置在语义分析阶段内，在类型决议发生之后。\n\n**综合分析**：\n这三种构造必须放置在编译流水线的三个不同阶段：\n- 构造 2：语法分析之前 (作用于词法单元流)。\n- 构造 1：语法分析之后，语义分析之前 (作用于原始 AST)。\n- 构造 3：语义分析期间/之后 (作用于带类型注解的 AST)。\n\n由于这些构造需要与编译器的内部数据结构 (词法单元流、AST、符号表、类型信息) 深度集成，宏处理器 $\\mathcal{M}$ 不能是问题中定义的单一、整体的“预翻译工具”。它必须是翻译器本身的一个集成组件，其功能分布在整个流水线中。\n\n### 选项评估\n\n**A. 将 $\\mathcal{M}$ 的所有构造都视为一个独立的预翻译工具，在词法分析之前完全运行 $\\mathcal{M}$。理由是：宏展开纯粹是文本性的，独立于编译器；编译器只看到展开后的文本，然后照常执行其各个阶段。**\n这是不正确的。这个理由被构造 $1$ 和 $3$ 的定义所证伪。构造 $1$ 需要 AST，而 AST 在语法分析之前是不可用的。构造 $3$ 需要已解析的类型，而这些类型在语义分析之前是不可用的。将 $\\mathcal{M}$ 归类为外部预翻译工具与其对编译器内部产物的指定依赖性相矛盾。\n**结论：不正确。**\n\n**B. 仅将构造 $1$ 集成到翻译器中，将卫生宏展开置于语法分析之后和语义分析之前，但将构造 $2$ 和 $3$ 视为外部预翻译，在词法分析之前完全运行。**\n这是不正确的。虽然它正确地放置了构造 $1$，但它错误地分类和放置了构造 $3$。构造 $3$ 需要来自语义分析器的类型信息，因此不可能作为外部预翻译工具运行。\n**结论：不正确。**\n\n**C. 将 $\\mathcal{M}$ 作为翻译器的一部分。将构造 $2$ 放置在语法分析之前，作用于词法单元流，作为一个集成到前端的早期文本门控；将构造 $1$ 放置在语法分析和语义分析之间，作用于可访问符号表的 AST；将构造 $3$ 放置在类型决议之后的语义分析阶段内，允许基于已解析的静态类型做出展开决策。**\n这个选项与为所有三种构造推导出的放置位置完全一致。它正确地指出 $\\mathcal{M}$ 必须是翻译器的一个集成部分。它将构造 $2$ 放在语法分析之前的词法单元流上。它将构造 $1$ 放在语法分析和语义分析之间的 AST 上。它将构造 $3$ 放在语义分析阶段内类型决议之后。这代表了一个科学上合理且内部一致的编译器架构。\n**结论：正确。**\n\n**D. 在代码生成后运行 $\\mathcal{M}$，通过宏展开来转换机器码。理由是：通过延迟展开，可以利用目标表示来指导宏决策，同时避免干扰早期的分析。**\n这是不正确的。这些构造是根据高级语言概念定义的：词法单元 (构造 $2$)、通过 AST 的句法结构 (构造 $1$) 和静态类型 (构造 $3$)。这些概念在最终的机器码输出中并非以结构化方式存在，或者根本不存在。宏展开本质上是一种源到源或源到中间表示 (IR) 的转换，而不是编译后的二进制修改。\n**结论：不正确。**\n\n**E. 将所有构造都集成在语法分析之后但在类型决议严格之前，这样宏系统只能看到语法而看不到任何语义信息。理由是：统一放置简化了流水线并避免了外部预处理，同时使宏远离词法分析。**\n这是不正确的。这个放置位置仅对构造 $1$ 是正确的。对构造 $2$ 是不正确的，因为它在语法分析之前作用于词法单元流。对构造 $3$ 则是严重错误的，因为它明确需要语义信息 (已解析的类型)，因此*必须*放置在类型决议开始之后，而不是“严格之前”。宏系统“只能看到语法而看不到任何语义信息”的理由与构造 $3$ 的定义直接矛盾。\n**结论：不正确。**",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "最后，我们将视角从编译器内部的流水线提升到整个翻译系统的顶层架构。一个强大的编程语言特性（如闭包或异常）往往不是单靠编译器转换就能实现的，它需要编译器和运行时系统之间的精密协作。这个练习让你扮演语言设计者的角色，分析不同的系统架构（从简单的栈式机到带有复杂运行时库的虚拟机）如何支持或限制高级语言特性的实现 。这揭示了翻译系统分类的最终目的：理解不同架构在实现语言功能时的能力与权衡。",
            "id": "3678705",
            "problem": "考虑编译器原理中翻译系统的分类。假设在以下明确约束下存在三种翻译系统类别，以及必须支持的三种小型语言特性：\n\n翻译系统类别：\n- $T_0$：一个语法导向的翻译器，为传统的调用/返回栈式机生成目标三地址代码，该栈式机具有基本算术、条件分支和函数调用/返回功能。它没有堆分配，没有除了普通返回之外的动态栈回溯机制，也不支持续延或协程。运行时系统仅限于调用和返回所需的最小代码；它不提供专门的控制特性。\n- $T_{\\text{lib}}$：一个编译器，它执行语法导向的翻译，生成传统低级语言代码，并链接一个标准的运行时库，该库提供堆分配、带标签的记录、函数指针和普通的调用/返回。除了可以在用户代码中实现的功能外，它没有内置的非局部控制转移原语（没有异常，没有续延）。\n- $T_{\\text{VM}}$：一个字节码虚拟机（VM）解释器，内置了用于抛出异常（包括跨活动记录的动态栈回溯）和用于让出/恢复协程（生成器帧）的操作。翻译器将源构造映射到虚拟机字节码；运行时系统实现栈回溯和协程恢复。\n\n语言特性：\n- 闭包：具有词法作用域的一等函数。闭包可以逃逸其定义作用域。闭包的行为由其代码指针和来自词法环境的自由变量绑定所定义。\n- 异常：通过 raise/try/catch 实现的非局部控制转移。抛出的异常可以跨越任意 $k \\ge 1$ 个动态调用帧传播，直到找到匹配的处理程序。\n- 生成器：可以通过 yield 挂起，并在之后从挂起点恢复的函数，可能多次恢复，并在多次让出之间保持局部状态。\n\n定义与基础：\n- 语法导向的翻译将规则与抽象语法树（AST）相关联，确定性地将源构造映射到目标构造，而无需在目标现有原语之外增加新的运行时机制。其正确性基于这样一个原则：通过翻译保留的语义必须可以作为可用目标操作的组合来实现。\n- 当一个源语义效果无法通过局部句法重写，在不进行全局插桩或使用在执行时改变活动记录、控制流或内存生命周期的专门机制的情况下，归约为一系列现有的目标原语时，就需要运行时支持。\n\n任务：\n使用上述约束和定义，从第一性原理出发，就环境、活动记录的生命周期以及控制转移语义进行推理，以预测哪种翻译系统类别可以主要通过语法导向的翻译来处理每个特性，以及哪种需要运行时支持。通过描述在规定约束下实现每个特性的最小原型来验证你的预测。\n\n在这些假设下，选择所有正确的陈述：\n\nA. 在 $T_{\\text{lib}}$ 中，具有词法作用域的一等闭包可以通过语法导向的翻译来实现，该翻译将每个闭包转换为一个由代码指针和捕获其自由变量的堆分配环境记录组成的对，仅使用运行时库提供的堆分配和普通函数调用。\n\nB. 在 $T_0$ 中，可以仅通过语法导向的翻译来实现跨 $k$ 个帧（$k \\ge 1$）非局部传播的异常，而无需改变任何函数签名或调用约定。\n\nC. 在 $T_{\\text{lib}}$ 中，生成器可以通过语法导向的翻译编译成显式状态机，其中每个生成器被翻译成一个存储有限状态和局部变量的堆分配记录，以及一个在每次调用时推进状态的调度函数，而无需任何特殊的虚拟机恢复操作。\n\nD. 在 $T_{\\text{VM}}$ 中，异常可以通过语法导向的翻译来处理，该翻译插入虚拟机的 raise 和处理程序设置字节码，而动态回溯和处理程序发现由虚拟机运行时提供；因此，主要机制是运行时对非局部控制转移的支持。\n\nE. 在 $T_0$ 中，闭包可以完全在调用栈上实现而无需堆分配，并且仍然是一等的（即可任意逃逸），仅使用语法导向的翻译和普通的调用/返回。",
            "solution": "该问题陈述是编译器设计原则中的一个有效练习。它为翻译系统（$T_0$、$T_{\\text{lib}}$、$T_{\\text{VM}}$）建立了一个清晰的分类，具有明确定义的约束和能力。它还定义了三种标准的语言特性（闭包、异常、生成器），并为“语法导向的翻译”与“运行时支持”提供了正式定义。任务是推理哪个系统可以通过何种机制支持哪个特性。该问题是自包含的，科学上基于已建立的计算机科学理论，并且是客观的。\n\n分析的核心在于活动记录的生命周期和控制转移的机制。\n- 在像 $T_0$ 的目标机这样的简单栈式机中，函数调用的活动记录（栈帧）仅在该调用的动态范围内存在。它在进入时创建，在退出（返回）时销毁。控制流仅限于函数内的直接跳转和调用/返回序列。\n- 在具有堆的系统中，例如 $T_{\\text{lib}}$ 的目标机，可以分配生命周期独立于调用栈的数据。这对于实现那些状态必须在其创建函数调用结束后仍然存在的特性至关重要。\n- 像 $T_{\\text{VM}}$ 这样的虚拟机提供了一个更高级别的抽象，其中运行时系统可以将复杂的控制和数据管理操作（如栈回溯或协程状态管理）作为原子原语来实现，从而简化了编译器的任务。\n\n基于这些第一性原理，我们评估每个选项：\n\nA. 在 $T_{\\text{lib}}$ 中，具有词法作用域的一等闭包可以通过语法导向的翻译来实现，该翻译将每个闭包转换为一个由代码指针和捕获其自由变量的堆分配环境记录组成的对，仅使用运行时库提供的堆分配和普通函数调用。\n\n该陈述描述了在编译到带堆分配的目标（如 C 语言）的语言中，实现一等（可逃逸）闭包的标准且正确的方法。闭包的根本问题在于，如果它们可以逃逸其定义的范围（例如，通过从函数返回），它们的词法环境（其自由变量的绑定）必须在定义函数的栈帧被释放后仍然存在。一个纯粹基于栈的环境会导致悬挂指针，这被称为“向上 funarg 问题”（upward funarg problem）。系统 $T_{\\text{lib}}$ 提供了堆分配。一个语法导向的翻译方案可以如下解决此问题：\n1. 创建闭包时，编译器生成代码在堆上分配一个记录。\n2. 然后，它生成代码将当前词法环境中的所有自由变量的值或引用复制到这个堆分配的记录中。\n3. 闭包值本身随后表示为一个指针-对：一个指向函数机器代码的指针，和一个指向这个堆分配环境记录的指针。\n当闭包被调用时，环境指针作为隐藏参数传递，使函数代码能够访问其捕获的变量。整个过程只使用堆分配、记录创建和普通函数调用，根据 $T_{\\text{lib}}$ 的定义，这些都是其目标机中可用的原语。这是一个通过局部句法重写，将复杂的源级语义（词法闭包）实现为可用目标原语组合的完美示例。\n结论：**正确**。\n\nB. 在 $T_0$ 中，可以仅通过语法导向的翻译来实现跨 $k$ 个帧（$k \\ge 1$）非局部传播的异常，而无需改变任何函数签名或调用约定。\n\n该陈述不正确。系统 $T_0$ 受到严重限制：它“没有除了普通返回之外的动态栈回溯机制”。跨 $k$ 个帧传播异常需要非局部控制转移，即从 `raise` 点跳转到祖先活动记录中的处理程序，并回溯（销毁）所有中间的 $k-1$ 个活动记录。$T_0$ 缺乏任何实现此功能的原语。要“仅通过语法导向的翻译”来实现这一点，编译器必须转换代码以显式管理控制流。一种常见（但低效）的方法是从每个函数返回一个错误状态。例如，调用 `y = f(x);` 会被转换为 `status = f(x, ); if (status != OK) return status;`。然而，这明确地改变了函数签名（增加了一个返回参数和一个状态返回值）和调用约定，直接违反了陈述的条件。如果不改变签名，可以使用一个全局标志，但每个函数在每次调用后仍需被插桩以检查此标志并手动返回，这是一种全局插桩，而不是问题定义中语法导向翻译所暗示的局部重写。栈回溯的基本机制在 $T_0$ 中是缺失的，并且没有专门的运行时机制或侵入性的全局代码转换是无法合成的。\n结论：**不正确**。\n\nC. 在 $T_{\\text{lib}}$ 中，生成器可以通过语法导向的翻译编译成显式状态机，其中每个生成器被翻译成一个存储有限状态和局部变量的堆分配记录，以及一个在每次调用时推进状态的调度函数，而无需任何特殊的虚拟机恢复操作。\n\n该陈述正确。生成器必须在多次 `yield` 调用之间保留其局部状态和执行点。普通函数调用不支持这一点，因为其活动记录在返回时被销毁。与闭包非常相似，解决方案是将必须持久化的状态从栈上移到堆上。$T_{\\text{lib}}$ 提供了堆。语法导向的翻译可以将生成器函数转换为：\n1. 一个在堆上分配的状态记录，用于存储生成器的所有局部变量和一个额外的状态变量，以表示当前的执行点（即，它位于哪个 `yield` 处）。\n2. 一个单一的调度函数。每次调用时，此函数使用状态变量（例如，在 `switch` 语句中）跳转到紧跟上一个 `yield` 之后的代码段。它执行直到遇到下一个 `yield`，此时它将新的执行点和任何更新的局部变量保存回堆分配的状态记录中，然后返回让出的值。\n这种技术，有时被称为“生成器转换”或与“续延传递风格转换”相关，仅依赖于堆分配、记录和普通函数调用。运行时系统不需要特殊的 `resume` 或 `yield` 原语。挂起和恢复的语义完全由转换后的代码结构模拟。\n结论：**正确**。\n\nD. 在 $T_{\\text{VM}}$ 中，异常可以通过语法导向的翻译来处理，该翻译插入虚拟机的 raise 和处理程序设置字节码，而动态回溯和处理程序发现由虚拟机运行时提供；因此，主要机制是运行时对非局部控制转移的支持。\n\n该陈述正确。$T_{\\text{VM}}$ 的定义指出它具有“用于抛出异常的内置操作（包括跨活动记录的动态栈回溯）”。问题对“运行时支持”的定义包括“一个在执行时改变活动记录、控制流或内存生命周期的专门机制”。动态栈回溯正是这样一种机制。因此，编译器的任务变成了一个直接的、语法导向的映射：`try/catch` 块翻译为注册处理程序的字节码，而 `raise` 语句翻译为 `RAISE` 字节码。虚拟机解释器在遇到 `RAISE` 字节码时，执行搜索调用栈以寻找处理程序并回溯栈帧的复杂逻辑。这完全符合选项中的描述。编译器使用简单的翻译，而运行时提供了强大的语义实现。\n结论：**正确**。\n\nE. 在 $T_0$ 中，闭包可以完全在调用栈上实现而无需堆分配，并且仍然是一等的（即可任意逃逸），仅使用语法导向的翻译和普通的调用/返回。\n\n该陈述根本不正确。“一等”这个术语意味着闭包可以像任何其他数据一样被对待：存储在变量中，传递给函数，以及至关重要地，从函数中返回。能够“任意逃逸”是关键。如果一个函数创建了一个闭包并返回它，那么该闭包的生命周期必须超过其创建函数的活动周期。创建函数的活动记录存在于调用栈上，并在函数返回时被销毁。如果闭包的词法环境（包含其自由变量）存储在这个栈帧中，那么任何后续对返回闭包的使用都将访问已释放的内存，导致悬挂指针和未定义行为。正确地实现一等、可逃逸的闭包要求其捕获的环境具有独立于栈的生命周期，这需要具有动态范围的存储，即堆分配。系统 $T_0$ 明确规定“没有堆分配”。因此，它只能支持非逃逸的闭包（向下 funarg），而不能支持完全一等的闭包。\n结论：**不正确**。",
            "answer": "$$\\boxed{ACD}$$"
        }
    ]
}