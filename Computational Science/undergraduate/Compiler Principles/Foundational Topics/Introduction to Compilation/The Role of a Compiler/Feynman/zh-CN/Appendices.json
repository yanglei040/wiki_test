{
    "hands_on_practices": [
        {
            "introduction": "编译器的角色远不止是简单的代码翻译，它更是一个精密的优化引擎。然而，优化并非总能带来纯粹的收益，常常需要在相互冲突的目标之间做出复杂的权衡。本练习  将通过一个量化模型，带你亲身体验循环展开这一经典优化中的权衡过程。你需要计算出一个临界点，在该点上，降低循环开销带来的好处恰好被寄存器压力增大所引入的代价所抵消。",
            "id": "3674633",
            "problem": "考虑一个对数组进行线性变换的简单循环，其中编译器的作用包括选择变换（例如循环展开）和管理寄存器分配，以最小化执行时间。每次原始迭代的循环体需要一定数量的活跃临时变量，而机器的寄存器文件是有限的。当编译器以因子 $u$ 展开循环时，一些临时变量在 $u$ 个合并的迭代中共享，而另一些则是每次迭代所独有的。如果同时活跃值的总数超过了可用寄存器 $R$ 的数量，编译器的寄存器分配器必须生成到内存的溢出（spills），每次溢出都会产生一个额外的周期成本 $s$。\n\n使用以下科学上合理且自洽的模型和参数：\n\n- 每次原始迭代的基础计算成本为 $c$ 个周期。在此场景中，$c = 20$。\n- 每次原始迭代的控制和地址更新开销为 $h$ 个周期。在此场景中，$h = 30$。\n- 可用寄存器数量为 $R = 13$。\n- 在一个展开 $u$ 倍的块中共享的即时活跃临时变量为 $L_{\\text{shared}} = 5$（例如，循环索引、$A$、$B$、$C$ 的基址指针，以及一个循环不变量标量）。\n- 每次原始迭代独有的即时活跃临时变量为 $L_{\\text{iter}} = 3$（例如，从 $B[i]$ 和 $C[i]$ 加载的值，以及一个中间乘积 $C[i]\\times D$）。\n- 在展开块的峰值处，同时活跃的临时变量总数建模为 $L(u) = L_{\\text{shared}} + u\\,L_{\\text{iter}}$。\n- 如果 $L(u) > R$，则溢出值的数量为 $S(u) = L(u) - R$，否则 $S(u) = 0$。\n- 溢出成本参数 $s$ 代表每个溢出值在每个 $u$ 次迭代的块中的总周期惩罚（例如，该溢出值的一次组合加载和存储）。因此，每次原始迭代的溢出惩罚为 $\\frac{s\\,S(u)}{u}$。\n- 在展开因子为 $u$ 的情况下，每次原始迭代的平均周期数建模为\n$$\nC(u) \\;=\\; c \\;+\\; \\frac{h}{u} \\;+\\; \\frac{s\\,S(u)}{u}.\n$$\n\n在此设定下，以 $u=2$ 展开得到 $L(2) = 5 + 2\\cdot 3 = 11 \\leq 13$，因此 $S(2)=0$。以 $u=3$ 展开得到 $L(3) = 5 + 3\\cdot 3 = 14 > 13$，因此 $S(3)=14-13=1$。\n\n使用上述模型，确定使编译器在展开因子 $u=2$（无溢出）和展开因子 $u=3$（每个块有一次溢出）之间无差异的盈亏平衡溢出成本 $s^{\\star}$（以周期为单位），即满足 $C(2)=C(3)$ 的 $s$ 值。最终答案以周期表示。无需四舍五入。",
            "solution": "编译器的作用包括将源程序转换为目标机器码，并在机器约束下优化性能。两个相关的基本事实是：\n\n- 循环展开通过将分支和索引更新工作分摊到 $u$ 次迭代中来减少控制流开销，从而为每次原始迭代的成本贡献了 $\\frac{h}{u}$ 这一项。\n- 寄存器分配受到大小为 $R$ 的有限寄存器文件的约束。如果同时活跃的临时变量的峰值数量 $L(u)$ 超过 $R$，超出的部分 $S(u)=\\max(0,L(u)-R)$ 必须溢出到内存中，并且每个溢出的值都会产生额外的周期惩罚。在所述模型下，每次原始迭代的溢出惩罚是 $\\frac{s\\,S(u)}{u}$，因为 $s$ 是针对每个包含 $u$ 次迭代的块而言的。\n\n从基本原理出发，将这些结合起来，得到每次原始迭代的成本模型\n$$\nC(u) \\;=\\; c \\;+\\; \\frac{h}{u} \\;+\\; \\frac{s\\,S(u)}{u},\n$$\n其中 $c$ 是每次原始迭代的基础计算成本，$h$ 是每次迭代的控制和地址更新开销，而 $s$ 是每个溢出值在每个 $u$ 次迭代的块中的溢出成本。\n\n我们已知：\n- $c = 20$，\n- $h = 30$，\n- $R = 13$，\n- $L_{\\text{shared}} = 5$，\n- $L_{\\text{iter}} = 3$，\n- $L(u) = L_{\\text{shared}} + u\\,L_{\\text{iter}}$，\n- $S(u) = \\max\\big(0,\\,L(u) - R\\big)$。\n\n计算特定展开因子下的活跃度和溢出情况：\n- 对于 $u=2$，\n$$\nL(2) \\;=\\; 5 + 2\\cdot 3 \\;=\\; 11,\n$$\n并且因为 $11 \\leq 13$，\n$$\nS(2) \\;=\\; 0.\n$$\n因此，\n$$\nC(2) \\;=\\; c + \\frac{h}{2} + \\frac{s\\,S(2)}{2} \\;=\\; 20 + \\frac{30}{2} + \\frac{s\\cdot 0}{2} \\;=\\; 20 + 15 \\;=\\; 35.\n$$\n\n- 对于 $u=3$，\n$$\nL(3) \\;=\\; 5 + 3\\cdot 3 \\;=\\; 14,\n$$\n并且因为 $14 > 13$，\n$$\nS(3) \\;=\\; 14 - 13 \\;=\\; 1.\n$$\n因此，\n$$\nC(3) \\;=\\; c + \\frac{h}{3} + \\frac{s\\,S(3)}{3} \\;=\\; 20 + \\frac{30}{3} + \\frac{s\\cdot 1}{3} \\;=\\; 20 + 10 + \\frac{s}{3} \\;=\\; 30 + \\frac{s}{3}.\n$$\n\n我们寻求使 $C(2) = C(3)$ 成立的盈亏平衡溢出成本 $s^{\\star}$。令两个表达式相等，解出 $s$：\n$$\n35 \\;=\\; 30 + \\frac{s}{3}\n\\;\\;\\Longrightarrow\\;\\;\n\\frac{s}{3} \\;=\\; 5\n\\;\\;\\Longrightarrow\\;\\;\ns \\;=\\; 15.\n$$\n\n因此，盈亏平衡溢出成本为 $s^{\\star} = 15$ 个周期：如果 $s  15$ 个周期，展开到 $u=3$ 是有利的；如果 $s > 15$ 个周期，在此模型下展开到 $u=2$（避免了溢出）更好。这量化了编译器必须在因循环展开而减少的控制开销和增加的寄存器压力之间所做的权衡。",
            "answer": "$$\\boxed{15}$$"
        },
        {
            "introduction": "我们如何能确信编译器正确地保留了程序的语义，尤其是对于复杂的控制流结构？答案在于系统性的测试。本练习  将让你扮演编译器验证工程师的角色。你将首先需要精确地定义一个包含贯穿（fallthrough）和稀疏分支等棘手特性的 `switch` 语句的正确行为，然后以此为“黄金标准”，来评估并检测两种常见但存在缺陷的底层实现策略中的错误。",
            "id": "3674700",
            "problem": "编译器将高级控制流结构转换为低级程序表示，同时为所有输入保留源程序的语义。考虑语义保留的要求：对于函数 $f$ 定义域中的每一个输入 $x$，编译后的程序必须计算出与源语义相同的输出。特别是，将 $switch$ 语句降级为跳转表或对 case 标签进行二分搜索时，必须保留语义，包括在省略 $break$ 语句时遵守 $fallthrough$（贯穿）行为。\n\n使用以下 $switch$ 结构，基于输入 $x$ 和一个初始化为 $0$ 的局部累加器 $r$，定义函数 $f:\\mathbb{Z}\\to\\mathbb{Z}$ 的源语义。语义由 case 标签指定的操作序列确定，其中 $fallthrough$ 意味着在没有 $break$ 语句干预的情况下继续执行到下一个 case：\n- 对于 $x=-2$：应用 $r\\leftarrow r+1$，然后 $fallthrough$ 到 $x=-1$ 的情况。\n- 对于 $x=-1$：应用 $r\\leftarrow r+2$，然后 $break$。\n- 对于 $x=0$：应用 $r\\leftarrow 0$，然后 $break$。\n- 对于 $x=1$：应用 $r\\leftarrow 1$，然后 $fallthrough$ 到 $x=2$ 的情况。\n- 对于 $x=2$：应用 $r\\leftarrow r+4$，然后 $break$。\n- 对于 $x=5$ 或 $x=6$：应用 $r\\leftarrow 10$，然后 $break$。\n- 对于 $x=10$：应用 $r\\leftarrow -10$，然后 $break$。\n- 对于 $x=1000$：应用 $r\\leftarrow 100$，然后 $break$。\n- 对于任何其他 $x$：应用 $r\\leftarrow 99$，然后 $break$。\n\n根据语义保留的第一原则，正确的输出函数是由上述操作语义产生的数学映射 $f(x)$。\n\n现在考虑两种针对 $switch$ 的有缺陷的降级策略，它们都忽略了贯穿语义：\n\n1.  一种基于跳转表的错误实现，记为 $g_{\\mathrm{JT}}(x)$，它：\n    -   假设一个从 $k_{\\min}=-2$ 到 $k_{\\max}=1000$ 的密集连续范围。\n    -   对于 $x  k_{\\min}$ 或 $x > k_{\\max}$ 的情况，返回默认值 (99)。\n    -   对于范围内的其他 $x$，它找到满足 $k \\le x$ 的最大 case 标签 $k \\in \\mathcal{K}$，并返回其对应的单 case 值（即忽略任何贯穿行为）。\n\n2.  一种基于二分搜索的错误实现，记为 $g_{\\mathrm{BS}}(x)$，它：\n    -   在已排序的 case 标签列表 $\\mathcal{K}_s$ 上执行搜索。\n    -   它找到第一个大于 $x$ 的 case 标签 $k' \\in \\mathcal{K}_s$。\n    -   如果找到这样的 $k'$，则返回其对应的单 case 值 $v(k')$。\n    -   如果没有找到这样的标签（即 $x$ 大于或等于所有 case 标签），则返回默认值 (99)。\n\n对于测试集 $X = \\{-3, -2, -1, 0, 1, 2, 3, 5, 6, 7, 9, 10, 999, 1000, 1001\\}$，计算两个检测布尔向量 $d_{\\mathrm{JT}}(X)$ 和 $d_{\\mathrm{BS}}(X)$。对于每个 $x \\in X$，如果对应的实现 $g(x) \\neq f(x)$，则检测布尔值为 $1$，否则为 $0$。",
            "solution": "该问题要求分析编译器语义，特别是将 `switch` 控制流语句降级为低级表示。我们必须将给定函数 $f(x)$ 的正确操作语义与两种不同的错误实现 $g_{\\mathrm{JT}}(x)$ 和 $g_{\\mathrm{BS}}(x)$ 进行比较，以确定这些实现在哪些测试输入上会失败。检测布尔值 $d(x)$ 定义为：如果一个有缺陷的降级实现与正确输出 $f(x)$ 不一致，则为 $1$，否则为 $0$。\n\n分析分三个阶段进行：\n1.  从源语义推导出正确的函数 $f(x)$。\n2.  推导每个有缺陷的函数 $g_{\\mathrm{JT}}(x)$ 和 $g_{\\mathrm{BS}}(x)$ 的输出。\n3.  比较集合 $X=\\{-3, -2, -1, 0, 1, 2, 3, 5, 6, 7, 9, 10, 999, 1000, 1001\\}$ 中每个测试输入 $x$ 的输出，以生成检测布尔向量 $d_{\\mathrm{JT}}(x)$ 和 $d_{\\mathrm{BS}}(x)$。\n\n令 case 标签集合为 $\\mathcal{K} = \\{-2, -1, 0, 1, 2, 5, 6, 10, 1000\\}$。\n\n**1. 推导正确的函数 $f(x)$**\n\n函数 $f:\\mathbb{Z}\\to\\mathbb{Z}$ 由一个带有初始化为 $0$ 的累加器 $r$ 的 `switch` 语句的操作语义定义。我们必须考虑 `fallthrough` 行为。\n\n-   对于 $x=-2$：执行 $x=-2$ 的 case，设置 $r \\leftarrow 0+1=1$。然后它贯穿到 $x=-1$ 的 case，执行 $r \\leftarrow 1+2=3$。一个 `break` 语句随后终止执行。因此，$f(-2)=3$。\n-   对于 $x=-1$：执行 $x=-1$ 的 case，设置 $r \\leftarrow 0+2=2$，后跟一个 `break`。因此，$f(-1)=2$。\n-   对于 $x=0$：执行 $x=0$ 的 case，设置 $r \\leftarrow 0$，后跟一个 `break`。因此，$f(0)=0$。\n-   对于 $x=1$：执行 $x=1$ 的 case，设置 $r \\leftarrow 1$。然后它贯穿到 $x=2$ 的 case，执行 $r \\leftarrow 1+4=5$。一个 `break` 语句随后终止执行。因此，$f(1)=5$。\n-   对于 $x=2$：执行 $x=2$ 的 case，设置 $r \\leftarrow 0+4=4$，后跟一个 `break`。因此，$f(2)=4$。\n-   对于 $x=5$ 或 $x=6$：执行相应的 case，设置 $r \\leftarrow 10$，后跟一个 `break`。因此，$f(5)=10$ 且 $f(6)=10$。\n-   对于 $x=10$：执行 $x=10$ 的 case，设置 $r \\leftarrow -10$，后跟一个 `break`。因此，$f(10)=-10$。\n-   对于 $x=1000$：执行 $x=1000$ 的 case，设置 $r \\leftarrow 100$，后跟一个 `break`。因此，$f(1000)=100$。\n-   对于任何其他输入 $x$（`default` 情况）：执行 `default` case，设置 $r \\leftarrow 99$。因此，对于 $x \\notin \\mathcal{K}$，$f(x)=99$。\n\n将此逻辑应用于测试集 $X$，我们得到 $f(x)$ 的以下结果：\n-   $f(-3)=99$ (默认)\n-   $f(-2)=3$ (贯穿)\n-   $f(-1)=2$\n-   $f(0)=0$\n-   $f(1)=5$ (贯穿)\n-   $f(2)=4$\n-   $f(3)=99$ (默认)\n-   $f(5)=10$\n-   $f(6)=10$\n-   $f(7)=99$ (默认)\n-   $f(9)=99$ (默认)\n-   $f(10)=-10$\n-   $f(999)=99$ (默认)\n-   $f(1000)=100$\n-   $f(1001)=99$ (默认)\n\n**2. 推导有缺陷的函数输出**\n\n我们现在分析两种有缺陷的、不合时宜的实现，它们都明显忽略了 `fallthrough` 语义。单 case 返回值（记为 $v(k)$）是：$v(-2)=1$, $v(-1)=2$, $v(0)=0$, $v(1)=1$, $v(2)=4$, $v(5)=10$, $v(6)=10$, $v(10)=-10$ 和 $v(1000)=100$。\n\n**2.1. 跳转表错误实现 $g_{\\mathrm{JT}}(x)$**\n此函数具有以下逻辑：\n-   如果 $x  -2$ 或 $x > 1000$，返回 $99$。\n-   否则，找到满足 $k \\le x$ 的最大 case 标签 $k \\in \\mathcal{K}$，并返回其单 case 值 $v(k)$。\n\n将此逻辑应用于测试集 $X$：\n-   $g_{\\mathrm{JT}}(-3)=99$ (因为 $x  -2$)\n-   $g_{\\mathrm{JT}}(-2)=v(-2)=1$ (小于等于 -2 的最大 k 是 -2)\n-   $g_{\\mathrm{JT}}(-1)=v(-1)=2$ (小于等于 -1 的最大 k 是 -1)\n-   $g_{\\mathrm{JT}}(0)=v(0)=0$ (小于等于 0 的最大 k 是 0)\n-   $g_{\\mathrm{JT}}(1)=v(1)=1$ (小于等于 1 的最大 k 是 1)\n-   $g_{\\mathrm{JT}}(2)=v(2)=4$ (小于等于 2 的最大 k 是 2)\n-   $g_{\\mathrm{JT}}(3)=v(2)=4$ (小于等于 3 的最大 k 是 2)\n-   $g_{\\mathrm{JT}}(5)=v(5)=10$ (小于等于 5 的最大 k 是 5)\n-   $g_{\\mathrm{JT}}(6)=v(6)=10$ (小于等于 6 的最大 k 是 6)\n-   $g_{\\mathrm{JT}}(7)=v(6)=10$ (小于等于 7 的最大 k 是 6)\n-   $g_{\\mathrm{JT}}(9)=v(6)=10$ (小于等于 9 的最大 k 是 6)\n-   $g_{\\mathrm{JT}}(10)=v(10)=-10$ (小于等于 10 的最大 k 是 10)\n-   $g_{\\mathrm{JT}}(999)=v(10)=-10$ (小于等于 999 的最大 k 是 10)\n-   $g_{\\mathrm{JT}}(1000)=v(1000)=100$ (小于等于 1000 的最大 k 是 1000)\n-   $g_{\\mathrm{JT}}(1001)=99$ (因为 $x > 1000$)\n\n**2.2. 二分搜索错误实现 $g_{\\mathrm{BS}}(x)$**\n此函数具有以下逻辑：\n-   找到第一个 case 标签 $k' \\in \\mathcal{K}$ 使得 $k' > x$。\n-   如果存在这样的 $k'$，则返回其单 case 值 $v(k')$。\n-   否则，返回 $99$。\n\n将此逻辑应用于测试集 $X$，其中已排序的标签为 $\\mathcal{K}_s=\\{-2, -1, 0, 1, 2, 5, 6, 10, 1000\\}$：\n-   $g_{\\mathrm{BS}}(-3)=v(-2)=1$ (下一个更大的是 -2)\n-   $g_{\\mathrm{BS}}(-2)=v(-1)=2$ (下一个更大的是 -1)\n-   $g_{\\mathrm{BS}}(-1)=v(0)=0$ (下一个更大的是 0)\n-   $g_{\\mathrm{BS}}(0)=v(1)=1$ (下一个更大的是 1)\n-   $g_{\\mathrm{BS}}(1)=v(2)=4$ (下一个更大的是 2)\n-   $g_{\\mathrm{BS}}(2)=v(5)=10$ (下一个更大的是 5)\n-   $g_{\\mathrm{BS}}(3)=v(5)=10$ (下一个更大的是 5)\n-   $g_{\\mathrm{BS}}(5)=v(6)=10$ (下一个更大的是 6)\n-   $g_{\\mathrm{BS}}(6)=v(10)=-10$ (下一个更大的是 10)\n-   $g_{\\mathrm{BS}}(7)=v(10)=-10$ (下一个更大的是 10)\n-   $g_{\\mathrm{BS}}(9)=v(10)=-10$ (下一个更大的是 10)\n-   $g_{\\mathrm{BS}}(10)=v(1000)=100$ (下一个更大的是 1000)\n-   $g_{\\mathrm{BS}}(999)=v(1000)=100$ (下一个更大的是 1000)\n-   $g_{\\mathrm{BS}}(1000)=99$ (没有标签大于 1000)\n-   $g_{\\mathrm{BS}}(1001)=99$ (没有标签大于 1001)\n\n**3. 检测错误实现**\n\n我们现在为每个 $x \\in X$ 计算检测布尔值 $d_{\\mathrm{JT}}(x)=(f(x) \\neq g_{\\mathrm{JT}}(x))$ 和 $d_{\\mathrm{BS}}(x)=(f(x) \\neq g_{\\mathrm{BS}}(x))$。\n\n| $x$   | $f(x)$ | $g_{\\mathrm{JT}}(x)$ | $g_{\\mathrm{BS}}(x)$ | $d_{\\mathrm{JT}}(x)$ | $d_{\\mathrm{BS}}(x)$ |\n|-------|--------|----------------------|----------------------|----------------------|----------------------|\n| $-3$  | $99$   | $99$                 | $1$                  | $0$                  | $1$                  |\n| $-2$  | $3$    | $1$                  | $2$                  | $1$                  | $1$                  |\n| $-1$  | $2$    | $2$                  | $0$                  | $0$                  | $1$                  |\n| $0$   | $0$    | $0$                  | $1$                  | $0$                  | $1$                  |\n| $1$   | $5$    | $1$                  | $4$                  | $1$                  | $1$                  |\n| $2$   | $4$    | $4$                  | $10$                 | $0$                  | $1$                  |\n| $3$   | $99$   | $4$                  | $10$                 | $1$                  | $1$                  |\n| $5$   | $10$   | $10$                 | $10$                 | $0$                  | $0$                  |\n| $6$   | $10$   | $10$                 | $-10$                | $0$                  | $1$                  |\n| $7$   | $99$   | $10$                 | $-10$                | $1$                  | $1$                  |\n| $9$   | $99$   | $10$                 | $-10$                | $1$                  | $1$                  |\n| $10$  | $-10$  | $-10$                | $100$                | $0$                  | $1$                  |\n| $999$ | $99$   | $-10$                | $100$                | $1$                  | $1$                  |\n| $1000$| $100$  | $100$                | $99$                 | $0$                  | $1$                  |\n| $1001$| $99$   | $99$                 | $99$                 | $0$                  | $0$                  |\n\n得到的检测向量是：\n$d_{\\mathrm{JT}}(X) = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0]$\n$d_{\\mathrm{BS}}(X) = [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0]$\n\n这些布尔序列构成了解决方案。该测试套件成功地识别了多种类型的错误。对于 $g_{\\mathrm{JT}}(x)$，错误源于忽略 `fallthrough`（$x=-2, 1$）以及对稀疏 case 的不正确处理（$x=3, 7, 9, 999$）。对于 $g_{\\mathrm{BS}}(x)$，其奇特的逻辑导致与 $f(x)$ 广泛不一致，在几乎所有测试用例上都失败了。它没有失败的情况（$x=5, 1001$）是巧合。",
            "answer": "对于跳转表实现 $g_{\\mathrm{JT}}(x)$，检测向量为：\n[0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0]\n\n对于二分搜索实现 $g_{\\mathrm{BS}}(x)$，检测向量为：\n[1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0]"
        }
    ]
}