{
    "hands_on_practices": [
        {
            "introduction": "The analysis-synthesis model is powerfully demonstrated in optimizing simple expressions. This first exercise explores the transformation of Boolean expressions, specifically converting short-circuit evaluation to more efficient, branchless eager evaluation. You will apply analysis facts about purity, exceptions, and side effects to determine when the synthesis phase can safely perform this optimization, reinforcing the core principle that semantic analysis is the key to sound code transformation .",
            "id": "3621439",
            "problem": "A compiler for a language with Boolean expressions uses the analysis–synthesis model of compilation: an analysis pass annotates Intermediate Representation (IR) with semantic facts, and a synthesis pass performs semantics-preserving rewrites guided by those facts. The language has short-circuit conjunction and disjunction, written as $\\land_{\\mathrm{sc}}$ and $\\lor_{\\mathrm{sc}}$, with left-to-right evaluation order. The eager Boolean operators $\\land$ and $\\lor$ evaluate both operands. Observational equivalence means equality of the final produced value, the multiset of externally visible side effects, and the exception behavior.\n\nThe analysis annotates each IR node $e$ with three facts:\n- $pure(e)$ is $\\mathrm{true}$ if $e$ is referentially transparent (no side effects).\n- $nothrow(e)$ is $\\mathrm{true}$ if evaluating $e$ cannot raise any exception or undefined behavior.\n- $order\\_independent(e)$ is $\\mathrm{true}$ if evaluating $e$ does not impose any constraint on relative evaluation order with other expressions (in particular, no inter-expression dependence via side effects).\n\nSuppose the IR contains four Boolean-valued expressions $e_1$, $e_2$, $e_3$, $e_4$ with the following analysis facts:\n- $pure(e_1)=\\mathrm{true}$, $nothrow(e_1)=\\mathrm{true}$, $order\\_independent(e_1)=\\mathrm{true}$.\n- $pure(e_2)=\\mathrm{false}$, $nothrow(e_2)=\\mathrm{true}$, $order\\_independent(e_2)=\\mathrm{false}$.\n- $pure(e_3)=\\mathrm{true}$, $nothrow(e_3)=\\mathrm{false}$, $order\\_independent(e_3)=\\mathrm{true}$.\n- $pure(e_4)=\\mathrm{true}$, $nothrow(e_4)=\\mathrm{true}$, $order\\_independent(e_4)=\\mathrm{true}$.\n\nConsider the IR expression\n$$\nE \\;=\\; (\\, e_1 \\;\\land_{\\mathrm{sc}}\\; e_4 \\,) \\;\\lor_{\\mathrm{sc}}\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,).\n$$\n\nThe synthesis pass is permitted to convert short-circuiting operators to branchless eager evaluation only when the IR indicates no side effects and safe evaluation order. Which of the following candidate transformations are sound under these rules (i.e., they preserve observational equivalence of $E$ while making only transformations the rules permit)? Choose all that apply.\n\nA. Replace $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ by $e_1 \\;\\land\\; e_4$, leaving the outer $\\lor_{\\mathrm{sc}}$ and the right $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$ unchanged.\n\nB. Replace $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$ by $e_2 \\;\\land\\; e_3$, leaving the outer $\\lor_{\\mathrm{sc}}$ and the left $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ unchanged.\n\nC. Replace the outer $\\lor_{\\mathrm{sc}}$ by eager $\\lor$, and simultaneously replace $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ by $e_1 \\;\\land\\; e_4$, yielding $E'=(\\, e_1 \\;\\land\\; e_4 \\,) \\;\\lor\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,)$.\n\nD. Rewrite $E$ into the arithmetic expression\n$$\nE'' \\;=\\; 1 \\;-\\; \\big( 1 - e_1 e_4 \\big)\\, \\big( 1 - e_2 e_3 \\big),\n$$\nwith Boolean values represented as $0$ and $1$, and multiplication and subtraction interpreted over $\\{0,1\\}$, to obtain fully branchless eager evaluation.\n\nAnswer choices should be evaluated strictly under the stated analysis facts and rule: conversion to branchless eager evaluation is allowed only when $pure(\\cdot)$, $nothrow(\\cdot)$, and $order\\_independent(\\cdot)$ indicate safety for the specific operands being converted.",
            "solution": "The core of the problem is to determine when a short-circuit operator $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ can be replaced by an eager one $A \\;\\text{op}\\; B$. This transformation preserves the final value but may alter the program's behavior by evaluating $B$ when it would have otherwise been skipped. For the transformation to be observationally equivalent, this unconditional evaluation of $B$ must not introduce new side effects or exceptions. This means that $B$ must be pure ($pure(B) = \\mathrm{true}$) and non-throwing ($nothrow(B) = \\mathrm{true}$). The problem's synthesis rule is even stricter, requiring that for a conversion to be permitted, all involved operands must be pure, non-throwing, and order-independent.\n\nLet's analyze the properties of the given expressions:\n- $e_1, e_4$: Are pure, non-throwing, and order-independent. These are \"safe\" to re-evaluate or reorder.\n- $e_2$: Is not pure and not order-independent. It has side effects.\n- $e_3$: Can throw an exception.\n\nThe expression to transform is $E \\;=\\; (\\, e_1 \\;\\land_{\\mathrm{sc}}\\; e_4 \\,) \\;\\lor_{\\mathrm{sc}}\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,)$.\n\n**A. Replace $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ by $e_1 \\;\\land\\; e_4$.**\nThis transformation affects the operands $e_1$ and $e_4$. Both are pure, non-throwing, and order-independent. Therefore, this transformation is permitted by the synthesis rule. It is also sound because the unconditional evaluation of $e_4$ introduces no new side effects or exceptions.\n**Conclusion: Correct.**\n\n**B. Replace $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$ by $e_2 \\;\\land\\; e_3$.**\nThis transformation would unconditionally evaluate $e_3$. Since $nothrow(e_3)$ is false, this could introduce an exception where none existed before (i.e., when $e_2$ is false). This violates observational equivalence, so the transformation is not sound. Furthermore, because operand $e_2$ is not pure and $e_3$ is not non-throwing, this transformation is not permitted by the synthesis rule.\n**Conclusion: Incorrect.**\n\n**C. Replace the outer $\\lor_{\\mathrm{sc}}$ by eager $\\lor$, ...**\nThis transformation involves changing $L \\lor_{\\mathrm{sc}} R$ to $L' \\lor R$, where $R = (e_2 \\land_{\\mathrm{sc}} e_3)$. This would make the evaluation of $R$ unconditional, regardless of the value of $L'$. However, $R$ is not pure (due to $e_2$) and can throw (due to $e_3$). Evaluating $R$ when it would have been skipped (when $L'$ is true) would introduce side effects and potentially an exception. The transformation is not sound and not permitted.\n**Conclusion: Incorrect.**\n\n**D. Rewrite $E$ into the arithmetic expression $E'' = \\dots$.**\nThis transformation implies fully eager evaluation of all four sub-expressions $e_1, e_2, e_3, e_4$. As established in the analyses of B and C, unconditionally evaluating $e_2$ and $e_3$ is not sound because of their side effects and exception behavior.\n**Conclusion: Incorrect.**\n\nOnly transformation A is both permitted by the compiler's rules and sound because it preserves observational equivalence.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Building on expression-level transformations, we now turn to a more complex challenge: memory. Reordering memory operations is a critical optimization, but it is only safe if the operations do not interfere with each other. This practice delves into alias analysis, the technique compilers use to determine if different pointers might refer to the same memory location, and shows how the precision of this analysis directly impacts the optimizations that can be legally synthesized .",
            "id": "3621393",
            "problem": "In the analysis–synthesis model of compilation, the analysis phase computes conservative alias information that the synthesis (transformation) phase uses to justify memory reordering. A fundamental criterion is that a reordering of a memory read and write is semantics-preserving in a sequential, single-threaded, non-volatile program if and only if the two memory operations do not access the same abstract location and at least one of them is a write. Equivalently, if two memory operations may access the same abstract location and at least one is a write, there exists a potential memory dependence and the reordering is disallowed.\n\nConsider alias analysis with precision parameter $\\alpha \\in \\{0,1,2\\}$, with the following interpretation:\n- $\\alpha=0$: flow-insensitive, field-insensitive, context-insensitive, heap-insensitive; all pointers of compatible type may alias, and all fields of a structure are merged into one abstract location class.\n- $\\alpha=1$: flow-insensitive, field-sensitive (distinct fields of the same structure are separate abstract locations), context-insensitive, heap-insensitive (all heap allocations are merged into one abstract location class).\n- $\\alpha=2$: flow-insensitive, field-sensitive, context-insensitive, heap allocation–site sensitive (different syntactic allocation sites are distinct abstract locations); additionally, allocations are modeled as returning fresh, non-overlapping memory.\n\nAssume a language with strict sequential semantics, no concurrency, no volatile accesses, and no undefined behavior. Consider the following two straight-line fragments and proposed optimization sequences that attempt to reorder a load and a store. All variables denote pointers to integers, and $\\rightarrow$ denotes field selection through a pointer to a structure instance.\n\nFragment A (structure fields):\n- Program: Let $p$ be a pointer to a structure with integer fields $x$ and $y$. Execute in order:\n  $$\n  S_x:\\; p \\rightarrow x := 1;\\quad L_y:\\; t := p \\rightarrow y.\n  $$\n- Proposed sequence $\\Sigma_A$: Reorder the load before the store, i.e., transform to\n  $$\n  L_y:\\; t := p \\rightarrow y;\\quad S_x:\\; p \\rightarrow x := 1.\n  $$\n\nFragment B (distinct heap allocation sites):\n- Program: Let $a := \\mathrm{alloc}_1()$ and $b := \\mathrm{alloc}_2()$, where $\\mathrm{alloc}_1$ and $\\mathrm{alloc}_2$ denote syntactically distinct allocation sites that each return a fresh, non-overlapping heap object. Execute in order:\n  $$\n  S_a:\\; *a := 0;\\quad L_b:\\; u := *b.\n  $$\n- Proposed sequence $\\Sigma_B$: Reorder the load before the store, i.e., transform to\n  $$\n  L_b:\\; u := *b;\\quad S_a:\\; *a := 0.\n  $$\n\nQuestion. Using only the definitions above and the legality criterion stated at the beginning, which option correctly characterizes which of $\\Sigma_A$ and $\\Sigma_B$ are semantics-preserving under each $\\alpha \\in \\{0,1,2\\}$?\n\nA. Under $\\alpha=0$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal; under $\\alpha=1$: only $\\Sigma_A$ is legal; under $\\alpha=2$: both $\\Sigma_A$ and $\\Sigma_B$ are legal.\n\nB. Under $\\alpha=0$: $\\Sigma_A$ is legal; under $\\alpha=1$: both $\\Sigma_A$ and $\\Sigma_B$ are legal; under $\\alpha=2$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal.\n\nC. Under $\\alpha=0$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal; under $\\alpha=1$: neither is legal; under $\\alpha=2$: only $\\Sigma_B$ is legal.\n\nD. Under $\\alpha=0$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal; under $\\alpha=1$: only $\\Sigma_B$ is legal; under $\\alpha=2$: only $\\Sigma_B$ is legal.",
            "solution": "The legality of reordering a store and a subsequent load hinges on whether alias analysis can prove that they access distinct memory locations. If the analysis cannot prove this (i.e., they *may alias*), the reordering is illegal. We must evaluate this for each precision level $\\alpha$.\n\n**Analysis for $\\alpha=0$ (field-insensitive, heap-insensitive)**\nThis is the least precise analysis.\n-   **Fragment A ($\\Sigma_A$)**: Because the analysis is **field-insensitive**, it considers all fields of a structure (like $x$ and $y$) as part of a single abstract location. Thus, it must assume $p \\rightarrow x$ and $p \\rightarrow y$ may alias. Reordering is **not legal**.\n-   **Fragment B ($\\Sigma_B$)**: Because the analysis is **heap-insensitive**, it considers all heap allocations as a single abstract location. It cannot distinguish between memory from `alloc_1` and `alloc_2`. Thus, it must assume $*a$ and $*b$ may alias. Reordering is **not legal**.\n-   **Conclusion for $\\alpha=0$**: Neither transformation is legal.\n\n**Analysis for $\\alpha=1$ (field-sensitive, heap-insensitive)**\nThis analysis can distinguish structure fields but not heap allocations.\n-   **Fragment A ($\\Sigma_A$)**: The analysis is **field-sensitive**. It can now distinguish between the distinct fields $x$ and $y$. It proves that $p \\rightarrow x$ and $p \\rightarrow y$ do not alias. The reordering is **legal**.\n-   **Fragment B ($\\Sigma_B$)**: The analysis remains **heap-insensitive**. It still cannot distinguish between the allocations for $a$ and $b$. It must assume $*a$ and $*b$ may alias. Reordering is **not legal**.\n-   **Conclusion for $\\alpha=1$**: Only $\\Sigma_A$ is legal.\n\n**Analysis for $\\alpha=2$ (field-sensitive, heap allocation-site sensitive)**\nThis is the most precise analysis.\n-   **Fragment A ($\\Sigma_A$)**: The analysis remains field-sensitive, so the reordering in $\\Sigma_A$ is still **legal**.\n-   **Fragment B ($\\Sigma_B$)**: The analysis is now **heap allocation-site sensitive**. It can distinguish between objects created at different syntactic sites (`alloc_1` vs. `alloc_2`). It proves that $a$ and $b$ point to distinct, non-overlapping memory regions, so $*a$ and $*b$ do not alias. The reordering is **legal**.\n-   **Conclusion for $\\alpha=2$**: Both $\\Sigma_A$ and $\\Sigma_B$ are legal.\n\n**Final Summary:**\n-   For $\\alpha=0$: Neither is legal.\n-   For $\\alpha=1$: Only $\\Sigma_A$ is legal.\n-   For $\\alpha=2$: Both are legal.\n\nThis summary matches option A perfectly.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Our final practice elevates the scope from local reordering to global code motion across an entire function's control-flow graph (CFG). This exercise simulates a common optimization where computations are moved to earlier basic blocks to eliminate redundancy, guided by analysis data about motion safety. You will use concepts like dominator trees and Static Single Assignment (SSA) form to synthesize an optimal schedule, illustrating how the analysis-synthesis model operates on the structural properties of a program to perform powerful, non-local transformations .",
            "id": "3621417",
            "problem": "A compiler applies the analysis-synthesis model to perform global code motion on a program in Static Single Assignment (SSA) form over a Control Flow Graph (CFG). The analysis phase has computed, for each instruction node $n$, a Boolean flag $MotionSafe(n)$ indicating whether moving $n$ to an earlier CFG block preserves the observable semantics, including memory effects and exceptions. The synthesis phase must place each movable computation to a block that dominates all its uses, subject to operand availability and the constraint that side-effecting or potentially-exceptional operations remain stationary wherever $MotionSafe(n)$ is not satisfied. For correctness, the synthesis must place each movable node into the minimal block (in the dominator tree) that still dominates all its uses, so as not to increase live ranges beyond necessity.\n\nConsider the following CFG with blocks $b_0$ (entry), $b_1$, $b_2$, $b_3$, and $b_4$:\n- Control-flow: $b_0 \\to b_1$, $b_1$ branches to $b_2$ and $b_3$, and both $b_2$ and $b_3$ go to $b_4$. The dominator relationships are: $b_0$ dominates $b_1$, and $b_1$ dominates $b_2$, $b_3$, and $b_4$. The immediate dominators are $idom(b_1)=b_0$, $idom(b_2)=b_1$, $idom(b_3)=b_1$, $idom(b_4)=b_1$.\n- Instructions (SSA names in math):\n  - In $b_1$: $n_1$: $x := a + b$, with $MotionSafe(n_1) = \\mathrm{true}$. Then branch on $p$.\n  - In $b_2$: $n_2$: $t_2 := x \\times 2$, with $MotionSafe(n_2) = \\mathrm{true}$. Then $n_3$: $store(s, t_2)$, with $MotionSafe(n_3) = \\mathrm{false}$. Then goto $b_4$.\n  - In $b_3$: $n_4$: $t_4 := x \\times 3$, with $MotionSafe(n_4) = \\mathrm{true}$. Then $n_5$: $t_5 := u / v$, with $MotionSafe(n_5) = \\mathrm{false}$ due to potential divide-by-zero exception. Then goto $b_4$.\n  - In $b_4$: $\\phi$: $y := \\phi(t_2, t_4)$. Then $n_{6a}$: $l := load(q)$, with $MotionSafe(n_{6a}) = \\mathrm{true}$ and alias analysis guarantees the store to $s$ does not alias $q$. Then $n_{6b}$: $z := y + l$, with $MotionSafe(n_{6b}) = \\mathrm{true}$.\n\nDefinitions:\n- Dominance: A block $d$ dominates a block $m$ if every path from $b_0$ to $m$ contains $d$.\n- Minimal dominating placement: For a node $n$ with uses in blocks $\\{u_i\\}$, a legal placement block $d$ must dominate every $u_i$ and be minimal in the dominator tree, meaning no strict descendant of $d$ also dominates all $\\{u_i\\}$.\n\nSubject to these rules:\n- Only nodes $n$ with $MotionSafe(n) = \\mathrm{true}$ may be moved earlier.\n- Nodes with $MotionSafe(n) = \\mathrm{false}$ remain stationary and must not be reordered across control-flow such that their execution frequency or ordering changes.\n- A moved node must be placed where all its operands are available (i.e., the block of placement must dominate the definitions of its operands) and the node must dominate all its uses.\n\nWhich of the following scheduling choices is both legal and consistent with the minimal dominating placement policy?\n\nA. Keep $n_1$ in $b_1$. Move $n_2$ from $b_2$ to $b_1$. Move $n_4$ from $b_3$ to $b_1$. Keep $n_3$ in $b_2$ and $n_5$ in $b_3$. Keep $n_6a$ and $n_6b$ in $b_4$.\n\nB. Move $n_1$ from $b_1$ to $b_0$. Move $n_2$ from $b_2$ to $b_0$. Move $n_4$ from $b_3$ to $b_0$. Move $n_6a$ from $b_4$ to $b_0$. Move $n_6b$ from $b_4$ to $b_1$. Keep $n_3$ in $b_2$ and $n_5$ in $b_3$.\n\nC. Move $n_2$ from $b_2$ to $b_1$. Move $n_4$ from $b_3$ to $b_1$. Move $n_5$ from $b_3$ to $b_1$. Move $n_6b$ from $b_4$ to $b_1$. Keep $n_1$ in $b_1$, $n_3$ in $b_2$, and $n_6a$ in $b_4$.\n\nD. Move $n_2$ from $b_2$ to $b_1$. Keep $n_4$ in $b_3$. Keep $n_1$ in $b_1$, $n_3$ in $b_2$, $n_5$ in $b_3$, and $n_6a$, $n_6b$ in $b_4$.",
            "solution": "To solve this, we must determine the optimal placement for each movable instruction ($n_1, n_2, n_4, n_{6a}, n_{6b}$) based on the \"minimal dominating placement\" policy. Stationary instructions ($n_3, n_5$) remain in their original blocks.\n\nFirst, the dominator tree based on the given immediate dominators ($idom(b_1)=b_0$, $idom(b_2)=b_1$, $idom(b_3)=b_1$, $idom(b_4)=b_1$) is: $b_0$ is the root, and its child is $b_1$. The children of $b_1$ are $b_2$, $b_3$, and $b_4$.\n\nNow, let's analyze each movable instruction:\n\n1.  **$n_1: x := a + b$ (in $b_1$)**:\n    -   Uses: The result $x$ is used by $n_2$ in $b_2$ and by $n_4$ in $b_3$. The set of use blocks is $\\{b_2, b_3\\}$.\n    -   Minimal Dominating Placement: The block must dominate both $b_2$ and $b_3$. The common dominators are $\\{b_0, b_1\\}$. The minimal one (lowest in the tree) is $b_1$.\n    -   Conclusion: $n_1$ is already in its optimal block. **Keep $n_1$ in $b_1$**.\n\n2.  **$n_2: t_2 := x \\times 2$ (in $b_2$)**:\n    -   Uses: The result $t_2$ is used by the stationary instruction $n_3$ in $b_2$ and by the $\\phi$-function in $b_4$. The set of use blocks is $\\{b_2, b_4\\}$.\n    -   Minimal Dominating Placement: The block must dominate both $b_2$ and $b_4$. Common dominators are $\\{b_0, b_1\\}$. The minimal one is $b_1$.\n    -   Operand Availability: The operand $x$ is defined in $b_1$, so it is available for a computation in $b_1$.\n    -   Conclusion: $n_2$ should be moved to achieve its optimal placement. **Move $n_2$ to $b_1$**.\n\n3.  **$n_4: t_4 := x \\times 3$ (in $b_3$)**:\n    -   Uses: The result $t_4$ is used by the $\\phi$-function in $b_4$. The use block is $\\{b_4\\}$.\n    -   Minimal Dominating Placement: The block must dominate $b_4$. The valid hoisting targets that dominate the original block $b_3$ are $\\{b_0, b_1\\}$. Both also dominate $b_4$. The minimal one is $b_1$.\n    -   Operand Availability: The operand $x$ is defined in $b_1$ and is available there.\n    -   Conclusion: $n_4$ should be moved. **Move $n_4$ to $b_1$**.\n\n4.  **$n_{6a}: l := load(q)$ (in $b_4$)**:\n    -   Uses: The result $l$ is used by $n_{6b}$ in $b_4$. The use block is $\\{b_4\\}$.\n    -   Minimal Dominating Placement: The block must dominate $b_4$. The dominators are $\\{b_0, b_1, b_4\\}$. The minimal one is $b_4$ itself.\n    -   Conclusion: $n_{6a}$ is already in its optimal block. **Keep $n_{6a}$ in $b_4$**.\n\n5.  **$n_{6b}: z := y + l$ (in $b_4$)**:\n    -   Uses: We assume the result $z$ is live on exit from $b_4$, so the use block is $\\{b_4\\}$.\n    -   Minimal Dominating Placement: The minimal dominating block is $b_4$.\n    -   Operand Availability: An operand is $y$, which is defined by a $\\phi$-function in $b_4$. A value defined by a $\\phi$-function is only available *within* its block, not in any strictly dominating block. Therefore, $n_{6b}$ cannot be moved out of $b_4$.\n    -   Conclusion: **Keep $n_{6b}$ in $b_4$**.\n\n**Summary of the correct schedule:**\n- $n_1$: Keep in $b_1$.\n- $n_2$: Move to $b_1$.\n- $n_3$: Keep in $b_2$.\n- $n_4$: Move to $b_1$.\n- $n_5$: Keep in $b_3$.\n- $n_{6a}$: Keep in $b_4$.\n- $n_{6b}$: Keep in $b_4$.\n\nThis schedule matches option A exactly.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}