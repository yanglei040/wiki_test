{
    "hands_on_practices": [
        {
            "introduction": "理解一个语言类的结构，关键在于研究它在各种运算下的闭包性质。本练习探讨递归可枚举语言在右商运算下的闭包性 。这个实践的核心在于要求你进行构造性思考：通过结合两个现有的识别器，设计一个能够识别右商语言的新算法，这将让你掌握“交错” (dovetailing) 这一计算理论中的关键构造技巧。",
            "id": "1444605",
            "problem": "在形式语言理论中，我们研究不同语言类的性质。设 $\\Sigma$ 是一个有限字母表。一个语言 $L$ 是 $\\Sigma^*$ 的一个子集，其中 $\\Sigma^*$ 是 $\\Sigma$ 上所有有限字符串的集合。如果存在一台图灵机，对于每个输入字符串 $w \\in L$ 该图灵机都会停机并接受，而对于任何输入字符串 $w \\notin L$ 它或者停机并拒绝，或者永远运行，那么语言 $L$ 就被称为**可识别的**（或递归可枚举的）。\n\n一个重要的问题是，一个语言类在某些运算下是否封闭。考虑语言 $L_1$ 对语言 $L_2$ 的**右商**，记为 $L_1 / L_2$，其定义如下：\n$$L_1 / L_2 = \\{w \\in \\Sigma^* \\mid \\exists x \\in L_2 \\text{ 使得 } wx \\in L_1\\}$$\n这里，$wx$ 表示字符串 $w$ 和字符串 $x$ 的连接。\n\n下列哪个陈述准确地描述了可识别语言类在右商运算下的封闭性？\n\nA. 可识别语言类在右商运算下是封闭的。\n\nB. 可识别语言类在右商运算下是不封闭的。\n\nC. 可识别语言类在右商运算下是封闭的，当且仅当语言 $L_2$ 是可判定的。\n\nD. 可识别语言类在右商运算下是封闭的，当且仅当语言 $L_1$ 是可判定的。\n\nE. 可识别语言类在右商运算下是封闭的，当且仅当 $L_1$ 和 $L_2$ 都是正则语言。",
            "solution": "我们回顾一下定义：一个语言 $L \\subseteq \\Sigma^{*}$ 是可识别的，如果存在一台图灵机（TM）$M$，它在输入为 $w$ 时，如果 $w \\in L$ 则停机并接受，如果 $w \\notin L$ 则拒绝或永远运行。$L_{1}$ 对 $L_{2}$ 的右商是\n$$\nL_{1}/L_{2}=\\{\\,w \\in \\Sigma^{*} \\mid \\exists x \\in L_{2}\\ \\text{使得}\\ wx \\in L_{1}\\,\\}.\n$$\n我们必须确定可识别语言类在此运算下是否封闭。\n\n设 $L_{1},L_{2} \\subseteq \\Sigma^{*}$ 是可识别的。根据可识别性，存在图灵机 $M_{1}$ 和 $M_{2}$，使得 $M_{1}$ 识别 $L_{1}$ 且 $M_{2}$ 识别 $L_{2}$。定义 $L=L_{1}/L_{2}$。\n\n$L$ 的识别器的构造：\n1. 因为 $L_{2}$ 是可识别的，所以存在一个 $L_{2}$ 的枚举器 $E_{2}$，它是通过在 $\\Sigma^{*}$ 的所有字符串上对 $M_{2}$ 进行“燕尾”式（dovetailing）模拟得到的：枚举 $\\Sigma^{*}$ 中的所有字符串 $x$ 并以燕尾方式模拟 $M_{2}(x)$；每当 $M_{2}(x)$ 接受时，就输出 $x$。这将产生一个无限序列（可能包含重复）$x_{1},x_{2},\\dots$，该序列恰好列出了 $L_{2}$ 的所有成员。\n\n2. 对于输入 $w \\in \\Sigma^{*}$，我们通过在时间步长 $t=1,2,3,\\dots$ 上进行两级燕尾式模拟来构建 $L$ 的识别器 $M$：\n   - 在阶段 $t$，读取（或生成）$E_{2}$ 到目前为止输出的前 $t$ 个字符串 $x_{1},\\dots,x_{t}$。\n   - 对于每个 $i \\in \\{1,\\dots,t\\}$，在输入 $w x_{i}$ 上模拟 $M_{1}$ 正好 $t$ 步（从之前阶段模拟停止的地方继续）。\n   - 如果在这些 $t$ 步内，任何一个模拟接受了，那么就停机并接受 $w$。\n\n正确性证明：\n- 可靠性（Soundness）：如果 $M$ 接受 $w$，那么在某个阶段 $t$，某个模拟 $M_{1}(w x_{i})$ 接受了，并且 $x_{i}$ 是由 $E_{2}$ 枚举出的一个元素，因此 $x_{i} \\in L_{2}$。所以 $w x_{i} \\in L_{1}$ 且 $w \\in L_{1}/L_{2}$。\n\n- 完备性（Completeness）：假设 $w \\in L_{1}/L_{2}$。那么存在一个 $x \\in L_{2}$ 使得 $w x \\in L_{1}$。由于 $x \\in L_{2}$，$x$ 会在枚举器 $E_{2}$ 的枚举中以某个 $x_{j}$ 的形式出现在有限索引 $j$ 处。由于 $w x \\in L_{1}$， $M_{1}(w x)$ 会在有限步数 $s$ 内接受。选择任意阶段 $t \\geq \\max\\{j,s\\}$。根据构造，在阶段 $t$，我们会模拟 $M_{1}(w x_{j})$ 至少 $s$ 步，因此我们会检测到接受状态，于是 $M$ 接受 $w$。\n\n- 对于非成员的不接受性：如果 $w \\notin L_{1}/L_{2}$，那么对于每一个 $x \\in L_{2}$，都有 $w x \\notin L_{1}$，所以 $M_{1}(w x)$ 永远不会接受。因此，没有任何阶段会产生接受状态，$M$ 会在输入 $w$ 上永远运行，这对于识别器处理非成员字符串是允许的。\n\n因此，$M$ 识别语言 $L=L_{1}/L_{2}$，这证明了只要 $L_{1}$ 和 $L_{2}$ 是可识别的，$L_{1}/L_{2}$ 也是可识别的。所以，可识别语言类在右商运算下是封闭的。在这些选项中，这精确地对应于陈述 A，而陈述 B、C、D 和 E 都是错误的。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在了解了我们能够计算什么之后，我们来探索计算的边界。在程序分析中，我们常常希望判断一个程序生成的语言是否具有某种“好”的性质，但莱斯定理 (Rice's Theorem) 告诉我们，几乎所有这类非平凡的性质都是不可判定的。本练习  让你应用莱斯定理来分析一个具体的语言性质，并深入辨析递归可枚举 (RE) 与余递归可枚举 (co-RE) 之间的区别，从而加深你对存在性验证（“存在一个……”）和普适性验证（“对于所有……”）之间不对称性的理解。",
            "id": "1446132",
            "problem": "考虑所有在固定输入字母表 $\\Sigma$ 上的图灵机集合。对于任意图灵机 $M$，我们将其语言记为 $L(M)$，该语言是 $M$ 接受的所有字符串的集合。\n\n我们为任意给定的语言 $L$ 定义一个特定的性质，我们称之为“完全平方长度”性质。一个语言 $L$ 被称为具有完全平方长度性质，当且仅当对于 $L$ 中的每个字符串 $w$， $w$ 的长度（记为 $|w|$）是一个完全平方数。也就是说，对于某个非负整数 $k$，有 $|w| = k^2$。\n\n判定问题如下：给定任意一个图灵机 $M$ 的描述，确定其语言 $L(M)$ 是否具有完全平方长度性质。\n\n下列哪个陈述正确描述了该问题的可计算性？\n\nA. 该问题是可判定的。\n\nB. 该问题是不可判定的，但其语言具有该性质的图灵机集合是可识别的。\n\nC. 该问题是不可判定的，但其语言不具有该性质的图灵机集合是可识别的。\n\nD. 该问题是不可判定的，并且其语言具有该性质的图灵机集合既不是可识别的，也不是余可识别的。",
            "solution": "设 $\\Sigma$ 是一个固定的输入字母表。对于一个图灵机 $M$，设 $L(M) \\subseteq \\Sigma^{*}$ 是它的语言。定义\n$$\nS \\triangleq \\{w \\in \\Sigma^{*} : \\exists k \\in \\mathbb{N} \\text{ 使得 } |w| = k^{2}\\}.\n$$\n所讨论的性质是\n$$\n\\mathcal{P}(L) \\iff L \\subseteq S.\n$$\n\n步骤 1：通过莱斯定理证明不可判定性。\n性质 $\\mathcal{P}$ 仅依赖于语言 $L(M)$，而不依赖于 $M$ 的语法描述，因此它是一个外延性质。该性质是非平凡的，因为存在一个机器 $M_{\\emptyset}$，其语言 $L(M_{\\emptyset}) = \\emptyset \\subseteq S$ 满足 $\\mathcal{P}$；也存在一个机器 $M_{\\text{all}}$，其语言 $L(M_{\\text{all}}) = \\Sigma^{*}$ 不满足 $\\mathcal{P}$，因为存在一个不是完全平方数的 $n \\in \\mathbb{N}$，因此在 $\\Sigma^{*}$ 中存在一个长度为 $n$ 的字符串不在 $S$ 中。根据莱斯定理，判定 $L(M)$ 是否具有性质 $\\mathcal{P}$ 是不可判定的。因此选项 A 是错误的。\n\n步骤 2：补集的可识别性。\n令 $T \\triangleq \\Sigma^{*} \\setminus S = \\{w \\in \\Sigma^{*} : \\neg \\exists k \\in \\mathbb{N} \\, (|w| = k^{2})\\}$。集合 $T$ 是可判定的，因为我们可以计算 $|w|$ 并通过检查是否存在 $k \\in \\mathbb{N}$ 使得 $k^{2} = |w|$ 来判定 $|w|$ 是否是完全平方数。考虑下标集\n$$\n\\overline{P} \\triangleq \\{\\langle M \\rangle : \\exists w \\in T \\text{ 使得 } M \\text{ accepts } w\\}.\n$$\n为 $\\overline{P}$ 定义一个识别器：在输入 $\\langle M \\rangle$ 时，枚举所有 $w \\in T$（这是可能的，因为 $T$ 是可判定的），并对每个这样的 $w$ 进行 $M$ 的模拟的燕尾式执行（dovetail）。如果某个模拟接受了，那么就接受。如果 $\\langle M \\rangle \\in \\overline{P}$，那么存在这样一个 $w$，识别器会停机并接受；否则，该过程会发散。因此 $\\overline{P}$ 是可识别的。\n\n步骤 3：性质本身不可识别。\n令 $P \\triangleq \\{\\langle M \\rangle : L(M) \\subseteq S\\}$。我们已经证明了 $P$ 是不可判定的，且 $\\overline{P}$ 是可识别的。如果 $P$ 也是可识别的，那么 $P$ 就将是可判定的，这与通过莱斯定理建立的不可判定性相矛盾。因此，$P$ 是不可识别的。\n\n综合以上几点，该问题是不可判定的，其语言不具有该性质的图灵机集合是可识别的，而其语言具有该性质的图灵机集合是不可识别的。这对应于选项 C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "现在，让我们将这些抽象的理论应用于一个与软件工程和编译器设计直接相关的问题：检测无限循环。这个问题  挑战了一个常见的直觉，即判断一个程序是否存在一个可能导致无限循环的输入。要证明这一点，你需要运用从停机问题之补集进行的归约，这揭示了算法能力的根本局限性，并解释了为何静态分析器等工具无法完美地捕捉所有潜在的无限循环，从而将计算理论与现实世界中的挑战联系起来。",
            "id": "3666183",
            "problem": "考虑语言 $L_{\\text{loop}} = \\{ \\langle p \\rangle \\mid \\exists x\\; \\text{$p(x)$ does not halt} \\}$，其中 $\\langle p \\rangle$ 表示由编译器前端生成的程序 $p$ 的标准编码，而 $x$ 的范围是编码后的输入。使用以下基本依据：一个语言 $L$ 是递归可枚举的（RE），其定义是存在一个图灵机，它对 $L$ 中的所有字符串停机并接受，等价地，存在一个枚举器，它列出所有且仅列出 $L$ 中的字符串；以及经典停机问题集合 $HALT = \\{ \\langle p, x \\rangle \\mid \\text{$p(x)$ halts} \\}$ 的定义，以及一个公认的事实，即 $\\overline{HALT} = \\{ \\langle p, x \\rangle \\mid \\text{$p(x)$ does not halt} \\}$ 不是递归可枚举的。假设有人提议通过构造一个枚举器来证明 $L_{\\text{loop}}$ 是递归可枚举的。对于每个程序编码 $\\langle p \\rangle$，该枚举器对所有输入 $x$ 进行交叉模拟（dovetailing），逐步模拟 $p(x)$ 的执行，同时交错地搜索“不停机证据”，例如重复的格局或其他句法循环模式；当为某个 $x$ 找到此类证据时，枚举器输出 $\\langle p \\rangle$。下列哪个陈述正确地分析了这一提议以及 $L_{\\text{loop}}$ 的递归可枚举性？\n\nA. 对于任意图灵完备程序，不存在可计算的、有限的证书能统一地证明其不停机，因此所提议的枚举器无法保证最终能为 $L_{\\text{loop}}$ 的所有成员输出结果；此外，如果 $L_{\\text{loop}}$ 是递归可枚举的，那么 $\\overline{HALT}$ 将可以通过一个映射归约成为递归可枚举的，这与一个广为接受的结论相矛盾。\n\nB. 通过交叉模拟并等待格局重复，最终可以检测到所有的发散（divergence）；因此该枚举器有效，并且 $L_{\\text{loop}}$ 是递归可枚举的。\n\nC. 通过在一个对不停机问题可靠且完备的逻辑中枚举形式化证明，可以使该提议有效，该逻辑能为每个发散的程序证明其不停机；因此 $L_{\\text{loop}}$ 是递归可枚举的。\n\nD. 如上所述，该提议实际上枚举了补集 $\\overline{L_{\\text{loop}}}$，因为任何在所有输入上都停机的程序，对于每个输入都会产生一个有限的模拟轨迹，从而为全体性（totality）提供了有效证据。\n\nE. 该提议正确地为一类受限的有限状态程序生成了一个枚举器，在这类程序中，格局重复是不停机的完备证据，但它不能扩展到图灵完备程序；因此，它并未能证明 $L_{\\text{loop}}$ 在一般情况下是递归可枚举的。\n\n选择所有适用的选项。",
            "solution": "从定义开始。一个语言 $L$ 是递归可枚举的，如果存在一个图灵机 $M$，使得对于每个字符串 $w$，如果 $w \\in L$，则 $M$ 停机并接受 $w$，而如果 $w \\notin L$，则 $M$ 要么拒绝，要么不停机；等价地，存在一个枚举器，它恰好打印出 $L$ 中的所有字符串。停机问题集合 $HALT = \\{ \\langle p, x \\rangle \\mid \\text{$p(x)$ halts} \\}$ 已知是递归可枚举的，而其补集 $\\overline{HALT} = \\{ \\langle p, x \\rangle \\mid \\text{$p(x)$ does not halt} \\}$ 不是递归可枚举的。\n\n我们分析所提议的策略。它试图将不停机视为具有某种肯定的、可检测的证书的事物，例如重复的格局或句法循环。对于图灵完备模型，这通常是不可能的：一个计算过程可能通过不断增加其访问的纸带部分而发散，而从不重复一个完整的格局。更根本地说，如果存在一个系统的、可计算的过程，当程序 $p$ 在某个输入 $x$ 上 $p(x)$ 不停机时，该过程最终能产生一个可被枚举器识别的有限见证（witness），那么 $L_{\\text{loop}}$ 的成员资格将是半可判定的。\n\n一个精确的论证使用了从 $\\overline{HALT}$ 到 $L_{\\text{loop}}$ 的映射归约。给定任意实例 $\\langle p, x \\rangle$，构造一个程序 $q$，它忽略自身的输入并模拟 $p(x)$；形式上，定义 $q(y)$ 运行 $p(x)$ 而不做其他任何事情。那么：\n- 如果 $p(x)$ 停机，那么对于每个 $y$，$q(y)$ 都停机，所以不存在一个输入使得 $q$ 发散，因此 $\\langle q \\rangle \\notin L_{\\text{loop}}$。\n- 如果 $p(x)$ 不停机，那么对于每个 $y$，$q(y)$ 都不停机，所以存在一个输入使得 $q$ 发散，因此 $\\langle q \\rangle \\in L_{\\text{loop}}$。\n\n因此，$\\langle p, x \\rangle \\in \\overline{HALT}$ 当且仅当 $\\langle q \\rangle \\in L_{\\text{loop}}$。如果 $L_{\\text{loop}}$ 是递归可枚举的，那么通过将可计算的变换 $\\langle p, x \\rangle \\mapsto \\langle q \\rangle$ 与 $L_{\\text{loop}}$ 的枚举器组合，我们将得到一个用于 $\\overline{HALT}$ 的半判定过程，这与 $\\overline{HALT}$ 不是递归可枚举的既定事实相矛盾。因此，$L_{\\text{loop}}$ 不是递归可枚举的。\n\n现在评估各个选项：\n\nA. 这个选项阐明了两点。首先，对于所有发散的计算，不存在一个图灵机能保证找到的通用的、可计算的、有限的不停机证书，因为发散问题不是半可判定的。其次，它陈述了映射归约论证：从任意 $\\langle p, x \\rangle$ 构造一个忽略其输入并模拟 $p(x)$ 的程序 $q$，得到 $\\langle p, x \\rangle \\in \\overline{HALT}$ 当且仅当 $\\langle q \\rangle \\in L_{\\text{loop}}$。如果 $L_{\\text{loop}}$ 是递归可枚举的，那么 $\\overline{HALT}$ 也将是递归可枚举的，这与一个广为接受的结论相矛盾。这两部分都是正确的。结论：正确。\n\nB. 这个选项声称格局重复足以检测所有的发散。对于图灵机，一个计算可以发散而从不重复一个完整的格局（例如，通过不断写入新符号并无限向右移动）。循环检测是不停机的不完备证据。因此，该枚举器会漏掉那些不重复格局而发散的程序，从而无法枚举出 $L_{\\text{loop}}$ 的所有成员。此外，即使发生重复，也无法保证枚举器能在有界时间内为所有发散的运行检测到它。$L_{\\text{loop}}$ 是递归可枚举的这一结论是错误的。结论：不正确。\n\nC. 这个选项假设存在一个针对任意图灵完备程序的不停机问题的可靠且完备的证明系统，并提议枚举此类证明。如果这样的系统存在并且是有效可枚举的，那么 $\\overline{HALT}$ 将是递归可枚举的，因为对于任何对 $\\langle p, x \\rangle$，人们可以枚举证明，直到找到一个证明 $p(x)$ 发散的证明。这与 $\\overline{HALT}$ 的非递归可枚举性相矛盾。对于任意程序的不停机问题，不存在可计算可枚举的、完备的证明系统。结论：不正确。\n\nD. 这个选项断言该提议通过累积全体停机（total halting）的证据来枚举 $\\overline{L_{\\text{loop}}}$。然而，“在所有输入上都停机”是一个全称性质（universal property），通常不接受有限的、可计算的证书；观察到在许多输入上停机并不能证明在所有输入上都停机。不存在一个有效的过程，能在给定 $\\langle p \\rangle$ 和有限次模拟后，确认其在 $\\overline{L_{\\text{loop}}}$ 中的成员资格。结论：不正确。\n\nE. 这个选项区分了有限状态模型和图灵完备模型。对于有限状态程序，如确定性有限自动机，重复一个格局确实意味着不停机，并且循环检测可以是完备的证据，因此基于循环检测的枚举器对于那个受限的类别是成功的。然而，问题涉及的是图灵完备程序，在这种情况下，这类证据是不完备的，并且上面的归约论证表明 $L_{\\text{loop}}$ 不是递归可枚举的。该选项的结论——即该提议并未能证明 $L_{\\text{loop}}$ 在一般情况下是递归可枚举的——是正确的。结论：正确。\n\n因此，正确的陈述是 A 和 E。",
            "answer": "$$\\boxed{AE}$$"
        }
    ]
}