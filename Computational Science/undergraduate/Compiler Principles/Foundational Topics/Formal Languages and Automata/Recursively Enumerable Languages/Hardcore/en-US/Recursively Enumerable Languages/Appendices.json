{
    "hands_on_practices": [
        {
            "introduction": "A key way to understand any class of languages is to determine which operations it is closed under. This tells us what transformations we can apply without leaving the comfortable confines of that class. This exercise  asks you to investigate the closure of recursively enumerable languages under the right quotient, a complex operation involving strings from two different languages. Successfully tackling this problem requires a constructive proof where you design a Turing Machine that recognizes the resulting language, honing your skills in the essential computability technique of dovetailing.",
            "id": "1444605",
            "problem": "In the theory of formal languages, we study the properties of different classes of languages. Let $\\Sigma$ be a finite alphabet. A language $L$ is a subset of $\\Sigma^*$, the set of all finite strings over $\\Sigma$. A language $L$ is called **recognizable** (or recursively enumerable) if there exists a Turing Machine that halts and accepts on every input string $w \\in L$, and either halts and rejects or runs forever on any input string $w \\notin L$.\n\nAn important question is whether a class of languages is closed under certain operations. Consider the **right quotient** of a language $L_1$ by a language $L_2$, denoted $L_1 / L_2$, which is defined as:\n$$L_1 / L_2 = \\{w \\in \\Sigma^* \\mid \\exists x \\in L_2 \\text{ such that } wx \\in L_1\\}$$\nHere, $wx$ represents the concatenation of string $w$ and string $x$.\n\nWhich of the following statements accurately describes the closure property of the class of recognizable languages under the right quotient operation?\n\nA. The class of recognizable languages is closed under the right quotient operation.\n\nB. The class of recognizable languages is not closed under the right quotient operation.\n\nC. The class of recognizable languages is closed under the right quotient operation if and only if the language $L_2$ is decidable.\n\nD. The class of recognizable languages is closed under the right quotient operation if and only if the language $L_1$ is decidable.\n\nE. The class of recognizable languages is closed under the right quotient operation if and only if both $L_1$ and $L_2$ are regular languages.",
            "solution": "We recall the definition: a language $L \\subseteq \\Sigma^{*}$ is recognizable if there exists a Turing machine (TM) $M$ that, on input $w$, halts and accepts if $w \\in L$, and either rejects or runs forever if $w \\notin L$. The right quotient of $L_{1}$ by $L_{2}$ is\n$$\nL_{1}/L_{2}=\\{\\,w \\in \\Sigma^{*} \\mid \\exists x \\in L_{2}\\ \\text{such that}\\ wx \\in L_{1}\\,\\}.\n$$\nWe must determine whether the class of recognizable languages is closed under this operation.\n\nLet $L_{1},L_{2} \\subseteq \\Sigma^{*}$ be recognizable. By recognizability, there exist TMs $M_{1}$ and $M_{2}$ such that $M_{1}$ recognizes $L_{1}$ and $M_{2}$ recognizes $L_{2}$. Define $L=L_{1}/L_{2}$.\n\nConstruction of a recognizer for $L$:\n1. Because $L_{2}$ is recognizable, there exists an enumerator $E_{2}$ for $L_{2}$ obtained by dovetailing $M_{2}$ over all strings in $\\Sigma^{*}$: enumerate all strings $x \\in \\Sigma^{*}$ and simulate $M_{2}(x)$ in a dovetailed fashion; whenever $M_{2}(x)$ accepts, output $x$. This produces an infinite sequence (with possible repetitions) $x_{1},x_{2},\\dots$ listing exactly the members of $L_{2}$.\n\n2. On input $w \\in \\Sigma^{*}$, we build a recognizer $M$ for $L$ by a two-level dovetailing over time steps $t=1,2,3,\\dots$:\n   - At stage $t$, read (or generate) the first $t$ strings $x_{1},\\dots,x_{t}$ output so far by $E_{2}$.\n   - For each $i \\in \\{1,\\dots,t\\}$, simulate $M_{1}$ on input $w x_{i}$ for exactly $t$ steps (continuing from where the simulation left off in earlier stages).\n   - If any of these simulations accepts within these $t$ steps, then halt and accept $w$.\n\nCorrectness:\n- Soundness: If $M$ accepts $w$, then at some stage $t$ one of the simulations $M_{1}(w x_{i})$ accepts, and $x_{i}$ is an element enumerated by $E_{2}$, hence $x_{i} \\in L_{2}$. Therefore $w x_{i} \\in L_{1}$ and $w \\in L_{1}/L_{2}$.\n\n- Completeness: Suppose $w \\in L_{1}/L_{2}$. Then there exists $x \\in L_{2}$ such that $w x \\in L_{1}$. Since $x \\in L_{2}$, $x$ appears as some $x_{j}$ in the enumeration $E_{2}$ at a finite index $j$. Since $w x \\in L_{1}$, $M_{1}(w x)$ accepts in some finite number of steps $s$. Choose any stage $t \\geq \\max\\{j,s\\}$. By construction, at stage $t$ we simulate $M_{1}(w x_{j})$ for at least $s$ steps, so we detect acceptance and $M$ accepts $w$.\n\n- Non-acceptance on negatives: If $w \\notin L_{1}/L_{2}$, then for every $x \\in L_{2}$, $w x \\notin L_{1}$, so $M_{1}(w x)$ never accepts. Hence no stage produces acceptance, and $M$ runs forever on $w$, which is permitted for a recognizer on nonmembers.\n\nThus $M$ recognizes $L=L_{1}/L_{2}$, proving that whenever $L_{1}$ and $L_{2}$ are recognizable, so is $L_{1}/L_{2}$. Therefore the class of recognizable languages is closed under the right quotient operation. Among the options, this corresponds precisely to statement A, while statements B, C, D, and E are false.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "While we can sometimes build recognizers for new languages, many interesting questions about programs are fundamentally undecidable. Rice's Theorem provides a powerful tool for quickly proving that any non-trivial property of a Turing machine's language is undecidable. This exercise  moves beyond a simple \"decidable or not\" question, asking you to pinpoint a property's exact classification within the hierarchy of undecidable problems. By analyzing whether a language contains only strings of perfect square length, you'll practice distinguishing between recursively enumerable (RE) and co-recursively enumerable (co-RE) properties, revealing a crucial asymmetry in what we can prove about programs.",
            "id": "1446132",
            "problem": "Consider the set of all Turing machines over a fixed input alphabet $\\Sigma$. For any Turing machine $M$, we denote its language as $L(M)$, which is the set of all strings that $M$ accepts.\n\nWe define a specific property, which we will call the \"Perfect Square Length\" property, for any given language $L$. A language $L$ is said to possess the Perfect Square Length property if and only if for every string $w$ in $L$, the length of $w$ (denoted $|w|$) is a perfect square. That is, $|w| = k^2$ for some non-negative integer $k$.\n\nThe decision problem is as follows: given the description of an arbitrary Turing machine $M$, determine whether its language $L(M)$ has the Perfect Square Length property.\n\nWhich of the following statements correctly describes the computability of this problem?\n\nA. The problem is decidable.\n\nB. The problem is undecidable, but the set of Turing machines whose languages have the property is recognizable.\n\nC. The problem is undecidable, but the set of Turing machines whose languages do not have the property is recognizable.\n\nD. The problem is undecidable, and the set of Turing machines whose languages have the property is neither recognizable nor co-recognizable.",
            "solution": "Let $\\Sigma$ be a fixed input alphabet. For a Turing machine $M$, let $L(M) \\subseteq \\Sigma^{*}$ be its language. Define\n$$\nS \\triangleq \\{w \\in \\Sigma^{*} : \\exists k \\in \\mathbb{N} \\text{ with } |w| = k^{2}\\}.\n$$\nThe property in question is\n$$\n\\mathcal{P}(L) \\iff L \\subseteq S.\n$$\n\nStep 1: Undecidability via Rice's theorem.\nThe property $\\mathcal{P}$ depends only on the language $L(M)$, not on the syntactic description of $M$, so it is an extensional property. It is nontrivial because there exists a machine $M_{\\emptyset}$ with $L(M_{\\emptyset}) = \\emptyset \\subseteq S$ satisfying $\\mathcal{P}$, and there exists a machine $M_{\\text{all}}$ with $L(M_{\\text{all}}) = \\Sigma^{*}$ failing $\\mathcal{P}$ since there exists $n \\in \\mathbb{N}$ that is not a perfect square, hence there is a string of length $n$ in $\\Sigma^{*}$ not in $S$. By Rice's theorem, deciding whether $L(M)$ has $\\mathcal{P}$ is undecidable. Thus option A is false.\n\nStep 2: Recognizability of the complement.\nLet $T \\triangleq \\Sigma^{*} \\setminus S = \\{w \\in \\Sigma^{*} : \\neg \\exists k \\in \\mathbb{N} \\, (|w| = k^{2})\\}$. The set $T$ is decidable because one can compute $|w|$ and decide whether $|w|$ is a perfect square by checking whether there exists $k \\in \\mathbb{N}$ with $k^{2} = |w|$. Consider the index set\n$$\n\\overline{P} \\triangleq \\{\\langle M \\rangle : \\exists w \\in T \\text{ such that } M \\text{ accepts } w\\}.\n$$\nDefine a recognizer for $\\overline{P}$: on input $\\langle M \\rangle$, enumerate all $w \\in T$ (possible since $T$ is decidable), and dovetail simulations of $M$ on each such $w$. If some simulation accepts, then accept. If $\\langle M \\rangle \\in \\overline{P}$, then there exists such a $w$ and the recognizer halts and accepts; otherwise, the procedure diverges. Hence $\\overline{P}$ is recognizable.\n\nStep 3: Non-recognizability of the property itself.\nLet $P \\triangleq \\{\\langle M \\rangle : L(M) \\subseteq S\\}$. We have shown that $P$ is undecidable and that $\\overline{P}$ is recognizable. If $P$ were also recognizable, then $P$ would be decidable, contradicting the undecidability established by Rice's theorem. Therefore, $P$ is not recognizable.\n\nCombining these, the problem is undecidable, and the set of machines whose languages do not have the property is recognizable, while the set of machines whose languages do have the property is not recognizable. This corresponds to option C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "The theoretical concepts of computability have profound practical implications for building software development tools. This final challenge  bridges theory and practice by asking you to analyze a common but flawed approach to detecting infinite loops in programs. To see the error, you must apply the technique of a mapping reduction from the Halting Problem, a cornerstone of computer science. This exercise will solidify your understanding of why properties related to non-termination are often not recursively enumerable and, consequently, why automated bug-finders and compilers have inherent limitations.",
            "id": "3666183",
            "problem": "Consider the language $L_{\\text{loop}} = \\{ \\langle p \\rangle \\mid \\exists x\\; \\text{$p(x)$ does not halt} \\}$, where $\\langle p \\rangle$ denotes a standard encoding of a program $p$ produced by a compiler front end and $x$ ranges over encoded inputs. Use the following foundational bases: the definition that a language $L$ is recursively enumerable (RE) if there exists a Turing machine that halts and accepts exactly the strings in $L$, equivalently, there exists an enumerator that lists all and only strings in $L$; and the definition of the classical Halting Problem set $HALT = \\{ \\langle p, x \\rangle \\mid \\text{$p(x)$ halts} \\}$ together with the established fact that $\\overline{HALT} = \\{ \\langle p, x \\rangle \\mid \\text{$p(x)$ does not halt} \\}$ is not recursively enumerable. Suppose one proposes to prove that $L_{\\text{loop}}$ is recursively enumerable by constructing an enumerator that, for each program encoding $\\langle p \\rangle$, dovetails over all inputs $x$ and simulates $p(x)$ step by step, while interleaving searches for “evidence of non-termination” such as repeated configurations or other syntactic cycle patterns; when such evidence is found for some $x$, the enumerator outputs $\\langle p \\rangle$. Which of the following statements correctly analyze this proposal and the RE status of $L_{\\text{loop}}$?\n\nA. There is no computable, finite certificate that uniformly witnesses non-termination for arbitrary Turing-complete programs, so the proposed enumerator cannot guarantee eventual output for all members of $L_{\\text{loop}}$; moreover, if $L_{\\text{loop}}$ were recursively enumerable then $\\overline{HALT}$ would be recursively enumerable via a mapping reduction, contradicting a well-established result.\n\nB. By dovetailing simulations and waiting until a configuration repeats, one will eventually detect all divergences; therefore the enumerator works and $L_{\\text{loop}}$ is recursively enumerable.\n\nC. The proposal can be made valid by enumerating formal proofs in a sound and complete logic for non-termination that proves non-termination for every divergent program; therefore $L_{\\text{loop}}$ is recursively enumerable.\n\nD. The proposal, as stated, actually enumerates the complement $\\overline{L_{\\text{loop}}}$ because any program that halts on all inputs will yield a finite simulation trace for each input, providing effective evidence of totality.\n\nE. The proposal correctly produces an enumerator for a restricted class of finite-state programs where configuration repetition is complete evidence of non-termination, but it does not extend to Turing-complete programs; therefore it does not establish that $L_{\\text{loop}}$ is recursively enumerable in general.\n\nSelect all that apply.",
            "solution": "Begin from the definitions. A language $L$ is recursively enumerable if there exists a Turing machine $M$ such that for every string $w$, if $w \\in L$ then $M$ halts and accepts $w$, and if $w \\notin L$ then $M$ either rejects or does not halt; equivalently, there exists an enumerator that prints exactly the strings of $L$. The Halting Problem set $HALT = \\{ \\langle p, x \\rangle \\mid \\text{$p(x)$ halts} \\}$ is known to be recursively enumerable, while its complement $\\overline{HALT} = \\{ \\langle p, x \\rangle \\mid \\text{$p(x)$ does not halt} \\}$ is not recursively enumerable.\n\nWe analyze the proposed strategy. It attempts to treat non-termination as something with a positive, detectable certificate, for example a repeated configuration or syntactic cycle. For Turing-complete models, this is not generally possible: a computation may diverge by continually increasing the portion of tape it visits without ever repeating a complete configuration. More fundamentally, if there were a systematic, computable procedure that, when a program $p$ has some input $x$ on which $p(x)$ does not halt, eventually produces a finite witness recognizable by the enumerator, then membership in $L_{\\text{loop}}$ would be semi-decidable.\n\nA precise argument uses a mapping reduction from $\\overline{HALT}$ to $L_{\\text{loop}}$. Given any instance $\\langle p, x \\rangle$, construct a program $q$ that ignores its own input and simulates $p(x)$; formally, define $q(y)$ to run $p(x)$ and do nothing else. Then:\n- If $p(x)$ halts, $q(y)$ halts for every $y$, so there does not exist an input on which $q$ diverges, and thus $\\langle q \\rangle \\notin L_{\\text{loop}}$.\n- If $p(x)$ does not halt, $q(y)$ does not halt for every $y$, so there exists an input on which $q$ diverges, and thus $\\langle q \\rangle \\in L_{\\text{loop}}$.\n\nTherefore, $\\langle p, x \\rangle \\in \\overline{HALT}$ if and only if $\\langle q \\rangle \\in L_{\\text{loop}}$. If $L_{\\text{loop}}$ were recursively enumerable, then by composing the computable transformation $\\langle p, x \\rangle \\mapsto \\langle q \\rangle$ with an enumerator for $L_{\\text{loop}}$, we would obtain a semi-decision procedure for $\\overline{HALT}$, contradicting the established fact that $\\overline{HALT}$ is not recursively enumerable. Hence $L_{\\text{loop}}$ is not recursively enumerable.\n\nNow evaluate the options:\n\nA. This option articulates two points. First, there is no general computable, finite certificate for non-termination that a Turing machine can be guaranteed to find for all divergent computations, because divergence is not semi-decidable. Second, it states the mapping reduction argument: from any $\\langle p, x \\rangle$ construct $q$ that ignores its input and simulates $p(x)$, yielding $\\langle p, x \\rangle \\in \\overline{HALT}$ if and only if $\\langle q \\rangle \\in L_{\\text{loop}}$. If $L_{\\text{loop}}$ were recursively enumerable, then $\\overline{HALT}$ would be recursively enumerable, which contradicts a well-established result. Both parts are correct. Verdict: Correct.\n\nB. This option claims configuration repetition suffices to detect all divergences. For Turing machines, a computation can diverge without ever repeating a complete configuration (for example, by writing fresh symbols and shifting right indefinitely). Cycle detection is incomplete evidence for divergence. Consequently, the enumerator would miss programs that diverge without repetition and fail to enumerate all members of $L_{\\text{loop}}$. Moreover, even if repetition occurs, there is no guarantee that the enumerator will detect it within bounded time for all divergent runs. The conclusion that $L_{\\text{loop}}$ is recursively enumerable is false. Verdict: Incorrect.\n\nC. This option posits a sound and complete proof system for non-termination of arbitrary Turing-complete programs and proposes to enumerate such proofs. If such a system existed and were effectively enumerable, then $\\overline{HALT}$ would be recursively enumerable, because for any pair $\\langle p, x \\rangle$ one could enumerate proofs until finding a proof that $p(x)$ diverges. This contradicts the non-recursive-enumerability of $\\overline{HALT}$. No computably enumerable, complete proof system for non-termination of arbitrary programs exists. Verdict: Incorrect.\n\nD. This option asserts that the proposal enumerates $\\overline{L_{\\text{loop}}}$ by accumulating evidence of total halting. However, “halts on all inputs” is a universal property and does not admit a finite, computable certificate in general; observing halting on many inputs does not prove halting on all inputs. There is no effective procedure that, given $\\langle p \\rangle$ and finite simulations, confirms membership in $\\overline{L_{\\text{loop}}}$. Verdict: Incorrect.\n\nE. This option distinguishes finite-state models from Turing-complete models. For finite-state programs such as deterministic finite automata, repeating a configuration does imply non-termination, and cycle detection can be complete evidence, so an enumerator based on cycle detection can succeed for that restricted class. However, the question concerns Turing-complete programs, where such evidence is incomplete and the reduction argument above shows $L_{\\text{loop}}$ is not recursively enumerable. The option’s conclusion that the proposal does not establish that $L_{\\text{loop}}$ is recursively enumerable in general is correct. Verdict: Correct.\n\nTherefore, the correct statements are A and E.",
            "answer": "$$\\boxed{AE}$$"
        }
    ]
}