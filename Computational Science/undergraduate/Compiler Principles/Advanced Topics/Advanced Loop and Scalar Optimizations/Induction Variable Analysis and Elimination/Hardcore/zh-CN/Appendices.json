{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你完成一个典型的强度削减过程。你将学习如何识别循环中依赖于基本归纳变量的派生归纳变量，并用一个更高效的加法运算来替代成本较高的乘法运算。这个基础练习是理解和应用归纳变量优化的关键第一步 。",
            "id": "3644333",
            "problem": "在编译原理的全局优化策略背景下，考虑一个归纳变量的循环强度削减。设 $A$ 是一个定义在整数上的数组，对于所有整数 $k$，有 $A[k] = k$。设 $L$、$U$、$s$ 和 $c$ 为整数，其中 $s \\in \\mathbb{Z}_{0}$，$U  L$，且 $s$ 整除 $U - L$。考虑以下将值累加到标量 $sum$ 的程序片段：\n- 初始化 $sum := 0$。\n- 对于 $i := L$；当 $i  U$ 时；执行 $i := i + s$：\n  - 令 $x := i \\cdot 2 + c$。\n  - 更新 $sum := sum + A[x]$。\n\n仅使用循环的操作语义和归纳变量的定义，推导此循环的一个强度削减版本。该版本应将循环内部的乘以 2 操作替换为一个派生变量的增量操作，该派生变量在每次迭代中通过一个循环不变量进行更新，同时保持程序在 $sum$ 上的可观察行为不变。通过显式地关联变换前后累加的值，证明该变换是语义保持的。\n\n最后，计算循环退出时 $sum$ 值的闭式解析表达式，该表达式应以 $L$、$U$、$s$ 和 $c$ 表示。将您的答案表示为单个简化的解析表达式。无需四舍五入，不涉及单位。最终答案必须是单个表达式。",
            "solution": "问题要求三件事：首先，对给定的程序片段执行循环强度削减；其次，证明此变换是语义保持的；第三，计算累加器变量 `sum` 最终值的闭式解析表达式。\n\n该问题陈述已被验证，并被认为是具有科学依据、良构且客观的。它包含了所有必要信息，没有矛盾。\n\n原始程序片段是：\n- 初始化 $sum := 0$。\n- 对于 $i := L$；当 $i  U$ 时；执行 $i := i + s$：\n  - 令 $x := i \\cdot 2 + c$。\n  - 更新 $sum := sum + A[x]$。\n\n已知条件是：\n- $A$ 是一个数组，满足对于所有整数 $k$，$A[k] = k$。\n- $L, U, s, c$ 是整数。\n- $s \\in \\mathbb{Z}_{0}$，$U  L$，且 $s$ 整除 $U - L$。\n\n**第一部分：循环强度削减**\n\n变量 $i$ 是循环的基本归纳变量。它被初始化为 $L$，并在每次迭代中增加循环不变量 $s$。\n变量 $x$ 是一个派生归纳变量，因为它在每次迭代中的值是基本归纳变量 $i$ 的线性函数：$x = 2i + c$。\n\n让我们分析在连续迭代中 $i$ 和 $x$ 的值。设 $i_j$ 和 $x_j$ 分别是第 $j$ 次迭代（$j=0, 1, 2, \\dots$）中 $i$ 和 $x$ 的值。\n在下一次迭代中，$i$ 的值 $i_{j+1}$ 为 $i_{j+1} = i_j + s$。\n$x$ 相应的值 $x_{j+1}$ 是：\n$$x_{j+1} = 2 \\cdot i_{j+1} + c = 2 \\cdot (i_j + s) + c = (2 \\cdot i_j + c) + 2 \\cdot s$$\n认识到 $x_j = 2 \\cdot i_j + c$，我们得到递推关系：\n$$x_{j+1} = x_j + 2s$$\n这表明 $x$ 的值在每次迭代中都增加一个循环不变量常数 $2s$。因此，乘法 $i \\cdot 2$ 可以被一个加法替换。这就是强度削减的核心。\n\n我们引入一个新变量，称之为 $x'$，它将追踪 $x$ 的值。\n1.  在循环之前，$x'$ 必须初始化为 $x$ 在第一次迭代中应有的值。$i$ 的第一个值是 $L$，所以我们初始化 $x' := 2 \\cdot L + c$。\n2.  在循环内部，我们使用 $x'$ 来代替表达式 $2 \\cdot i + c$。对 `sum` 的更新变为 $sum := sum + A[x']$。\n3.  在使用后，我们根据推导出的递推关系为下一次迭代更新 $x'$：$x' := x' + 2s$。\n\n强度削减后的程序片段是：\n- 初始化 $sum := 0$。\n- 初始化 $x' := 2 \\cdot L + c$。\n- 对于 $i := L$；当 $i  U$ 时；执行 $i := i + s$：\n  - 更新 $sum := sum + A[x']$。\n  - 更新 $x' := x' + 2s$。\n\n**第二部分：语义保持性证明**\n\n我们必须证明强度削减后的循环计算出的 `sum` 最终值与原始循环相同。\n设循环控制变量 $i$ 所取的值序列为 $i_0, i_1, \\dots, i_{N-1}$，其中 $N$ 是总迭代次数。我们有 $i_j = L + j \\cdot s$。\n\n在原始循环中，第 $j$ 次迭代中使用的 $x$ 的值是 $x_j$：\n$$x_j = 2 \\cdot i_j + c = 2(L + j \\cdot s) + c = 2L + c + 2sj$$\n加到 `sum` 上的值序列是 $A[x_0], A[x_1], \\dots, A[x_{N-1}]$。\n\n在变换后的循环中，使用了一个新变量 $x'$。我们将其在第 $j$ 次迭代开始时的值记为 $x'_j$。\n- 初始化：循环开始前，$x'$ 被初始化为 $x'_0 = 2L + c$。这是在第一次迭代（$j=0$）中使用的值。\n- 更新：在第 $j$ 次迭代结束时，$x'$ 被更新以用于第 $j+1$ 次迭代：$x'_{j+1} = x'_j + 2s$。\n\n我们可以通过展开递推关系来找到 $x'_j$ 的闭式：\n$x'_0 = 2L + c$\n$x'_1 = x'_0 + 2s = (2L+c) + 2s$\n$x'_2 = x'_1 + 2s = (2L+c) + 2s + 2s = 2L+c + 2(2s)$\n根据归纳法，在第 $j$ 次迭代中使用的 $x'$ 的值是：\n$$x'_j = 2L + c + j \\cdot 2s$$\n比较原始循环中的值 $x_j$ 和变换后循环中的值 $x'_j$，我们发现对于所有的 $j=0, 1, \\dots, N-1$，$x_j = x'_j$。\n由于两个循环中用作数组 $A$ 索引的值序列（$x_0, x_1, \\dots$ 和 $x'_0, x'_1, \\dots$）是相同的，并且 `sum` 变量在两种情况下都初始化为 0，因此加到 `sum` 上的值序列 $A[x_j]$ 是相同的。所以，`sum` 的最终值相同，该变换是语义保持的。\n\n**第三部分：`sum` 的闭式表达式**\n\n`sum` 的最终值是所有循环迭代中 $A[x]$ 的总和。由于 $A[k]=k$，这也就是 $x$ 值本身的总和。\n$$sum = \\sum_{j=0}^{N-1} x_j$$\n首先，我们确定迭代次数 $N$。只要 $i  U$，循环就会继续。$i$ 的值为 $L, L+s, L+2s, \\dots, L+(N-1)s$。当 $i \\ge U$ 时，循环终止。所以，最后一次迭代是满足 $L+(N-1)s  U$ 的那次。\n$$ (N-1)s  U-L \\implies N-1  \\frac{U-L}{s} \\implies N  \\frac{U-L}{s} + 1 $$\n我们已知 $s$ 整除 $U-L$。令 $\\frac{U-L}{s} = K$，其中 $K$ 是一个正整数。\n条件变为 $N  K+1$。由于 $N$ 必须是整数，迭代次数为 $N=K$。\n因此，迭代次数为 $N = \\frac{U-L}{s}$。\n\n现在我们计算总和。被加的项 $x_j = 2L + c + 2sj$ 构成一个等差数列。\n等差数列的和由公式 $S_N = \\frac{N}{2}(\\text{首项} + \\text{末项})$ 给出。\n- 项数：$N = \\frac{U-L}{s}$。\n- 首项 ($j=0$): $x_0 = 2L + c$。\n- 末项 ($j=N-1$): $x_{N-1} = 2L + c + 2s(N-1)$。\n\n总和是：\n$$ sum = \\frac{N}{2}(x_0 + x_{N-1}) = \\frac{N}{2}((2L+c) + (2L+c+2s(N-1))) $$\n$$ sum = \\frac{N}{2}(4L + 2c + 2s(N-1)) = N(2L+c+s(N-1)) $$\n现在，代入 $N = \\frac{U-L}{s}$：\n$$ sum = \\left(\\frac{U-L}{s}\\right) \\left(2L+c+s\\left(\\frac{U-L}{s}-1\\right)\\right) $$\n$$ sum = \\left(\\frac{U-L}{s}\\right) (2L+c+(U-L)-s) $$\n化简括号内的表达式：\n$$ sum = \\left(\\frac{U-L}{s}\\right) (L+U+c-s) $$\n这就是 `sum` 的最终闭式解析表达式。",
            "answer": "$$ \\boxed{\\frac{(U-L)(L+U+c-s)}{s}} $$"
        },
        {
            "introduction": "实际编程中的循环常常包含复杂的控制流，例如提前退出。本练习模拟了这种情况，要求你在存在 `break` 语句的循环中安全地消除一个派生归纳变量。通过这个练习，你将深入理解保证变换语义等价性的关键在于确保仿射关系在使用点上成立 。",
            "id": "3645851",
            "problem": "当条件 $A[i]  k$ 满足时，一个循环会通过 break 语句提前退出。该循环使用索引 $i$ 作为基本归纳变量，并维护一个独立的计数器 $iter$，该计数器仅用于日志记录（累加一个校验和）。考虑以下循环语义的规范，其中所有更新在每次迭代中都按所示顺序发生：\n- 初始化：$i \\leftarrow 0$， $iter \\leftarrow 1$， $checksum \\leftarrow 0$。\n- 当 $i  n$ 时：\n  - 如果 $A[i]  k$，则 break。\n  - $checksum \\leftarrow checksum + iter$。\n  - $iter \\leftarrow iter + 2$。\n  - $i \\leftarrow i + 1$。\n\n假设 $A$ 是一个长度为 $n$ 的一维数组，其元素由等差数列 $A[i] = a + d \\cdot i$ 定义，适用于所有满足 $0 \\le i  n$ 的整数 $i$，其中 $a$ 和 $d$ 是固定整数且 $d  0$。假设 $iter$ 在循环外部不被使用，也不用于控制流。机器模型是标准的顺序执行模型：每个循环体实例构成一次迭代，按程序顺序执行，并且 break 语句会立即终止循环，而不执行该次迭代中的后续语句。\n\n仅使用编译原理中的以下基本理论：\n- 基本归纳变量（BIV）是在每次循环体执行时都以固定增量变化的变量（例如，对于某个常数 $c$，有 $i \\leftarrow i + c$）。\n- 派生归纳变量（DIV）是任何可以在某个一致的程序点上表示为基本归纳变量（BIV）的仿射函数的循环变量（例如，$x = \\alpha \\cdot i + \\beta$，其中 $i$ 是 BIV，$\\alpha$、$\\beta$ 是常数），前提是该表达式在该程序点有效，且变量 $x$ 没有以其他破坏仿射关系的方式被修改。\n- 保留语义的转换必须在转换后程序中可达的原始执行的所有有限前缀上，保持在所有关注的程序点上观察到的值不变。\n\n任务：\n1. 在 $checksum$ 更新点，识别哪个变量是基本归纳变量，哪个是派生归纳变量。推导用 $i$ 表示 $iter$ 的仿射关系，该关系在每次到达该点的迭代中都成立，不假设 $a$、$d$、$k$ 或 $n$ 的任何具体数值。\n2. 使用此仿射关系从循环中消除 $iter$，同时在每条执行路径（包括通过 break 提前退出）上保留 $checksum$ 中累加的精确值。陈述在存在提前退出的情况下，使此消除操作保留语义的关键条件。\n3. 现在用 $n = 50$，$a = 7$，$d = 3$ 和 $k = 61$ 实例化参数。计算循环终止时 $checksum$ 的精确最终值。你的最终答案必须是一个实数值。无需四舍五入。",
            "solution": "在尝试提供解决方案之前，将首先对问题的科学合理性、自洽性和完整性进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **初始化**：$i \\leftarrow 0$, $iter \\leftarrow 1$, $checksum \\leftarrow 0$。\n- **循环条件**：`while` $i  n$。\n- **循环体（按顺序）**：\n    1. `if` $A[i]  k$, `break`。\n    2. $checksum \\leftarrow checksum + iter$。\n    3. $iter \\leftarrow iter + 2$。\n    4. $i \\leftarrow i + 1$。\n- **数组定义**：$A[i] = a + d \\cdot i$，对于 $0 \\le i  n$。\n- **参数约束**：$a, d$ 是整数；$d  0$。\n- **变量角色**：$i$ 是基本归纳变量（BIV）。$iter$ 仅用于日志记录。\n- **执行模型**：标准顺序执行；`break` 是立即的。\n- **理论基础**：BIV、派生归纳变量（DIV）和保留语义的转换的定义。\n- **任务**：\n    1. 识别 BIV 和 DIV，并推导在 $checksum$ 更新点的仿射关系 $iter = f(i)$。\n    2. 解释如何消除 $iter$ 以及在存在提前退出时保留其语义的条件。\n    3. 对于 $n = 50$，$a = 7$，$d = 3$ 和 $k = 61$，计算 $checksum$ 的最终值。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在编译原理领域内是良定义的，特别关注归纳变量分析和强度削减，这是一种标准的优化技术。\n- **科学/事实合理性**：该问题基于已确立的计算机科学原理。归纳变量和程序语义的概念是编译器设计的基础。没有违反任何科学定律。\n- **良构性**：问题规范足够详细。初始状态、循环不变量、更新规则和终止条件都已明确陈述，从而可以得到一个唯一的、可确定的解。\n- **客观性和完整性**：问题以精确、客观的语言陈述。所有必要的参数和定义都已提供。它不包含任何矛盾。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将开始制定解决方案。\n\n### 解决方案\n\n**任务1：识别归纳变量和仿射关系**\n\n基本归纳变量（BIV）是在每次循环迭代中其值以固定常数变化的变量。变量 $i$ 初始化为 $0$，并在每次未提前退出的迭代中通过 $i \\leftarrow i + 1$ 进行更新。因此，它符合增量为 $1$ 的 BIV 的定义。\n\n派生归纳变量（DIV）是其值可以表示为 BIV 的仿射函数的变量，即 $x = \\alpha \\cdot i + \\beta$，其中 $\\alpha$ 和 $\\beta$ 为常数。我们研究 $iter$ 是否是相对于 BIV $i$ 的 DIV。\n\n让我们追踪在每次迭代开始时 $i$ 和 $iter$ 的值，这与 $checksum$ 更新发生的程序点相同（因为更新发生在循环体内 $i$ 和 $iter$ 被修改之前）。\n- 在迭代 $i=0$ 之前：$i=0$, $iter=1$。\n- 在迭代 $i=1$ 之前：上一次迭代（$i=0$）完成，所以 $i$ 变为 $0+1=1$，$iter$ 变为 $1+2=3$。\n- 在迭代 $i=2$ 之前：上一次迭代（$i=1$）完成，所以 $i$ 变为 $1+1=2$，$iter$ 变为 $3+2=5$。\n\n我们观察到一个模式。令 $iter_i$ 为给定索引 $i$ 的循环体开始时 $iter$ 的值。\n对于 $i=0$，$iter_0 = 1 = 2(0)+1$。\n对于 $i=1$，$iter_1 = 3 = 2(1)+1$。\n对于 $i=2$，$iter_2 = 5 = 2(2)+1$。\n\n这表明存在仿射关系 $iter = 2i + 1$。我们用数学归纳法证明这一点。\n- **基础情况**：对于第一次迭代（$i=0$），初始值为 $iter=1$。公式给出 $2(0)+1=1$。基础情况成立。\n- **归纳步骤**：假设对于某个迭代 $j \\ge 0$，在迭代开始时 $iter$ 的值为 $2j+1$。如果这次迭代完成，下一次迭代开始时的值将被更新。$i$ 的新值将是 $j+1$。$iter$ 的新值将是 $(2j+1)+2 = 2j+3$。我们可以将其重写为 $2(j+1)+1$。这与下一个索引 $j+1$ 的仿射关系形式相匹配。\n\n因此，关系 $iter = 2i + 1$ 在 $checksum$ 被更新的程序点上成立，对于每个到达此点的迭代 $i$ 都成立。所以，$i$ 是 BIV，而 $iter$ 是相对于 $i$ 的 DIV，其中 $\\alpha=2$ 且 $\\beta=1$。\n\n**任务2：消除 `iter` 和语义保留**\n\n给定仿射关系 $iter = 2i + 1$，我们可以执行强度削减转换。原始的更新是 $checksum \\leftarrow checksum + iter$。我们替换 $iter$ 的表达式：\n$checksum \\leftarrow checksum + (2i + 1)$。\n\n转换后的循环变为：\n- 初始化：$i \\leftarrow 0$，$checksum \\leftarrow 0$。\n- `while` $i  n$:\n    - `if` $A[i]  k$, `break`。\n    - $checksum \\leftarrow checksum + (2i + 1)$。\n    - $i \\leftarrow i + 1$。\n\n变量 $iter$ 及其更新 $iter \\leftarrow iter + 2$ 现在是死代码，因为题目说明 $iter$ 在此累加之外不被使用。它们可以通过死代码消除来移除。\n\n使这种消除操作即使在有提前退出的情况下也保留语义的关键条件是，仿射关系 $iter = 2i+1$ 在 $iter$ 被使用的*特定程序点*（即 $checksum$ 更新点）上为真。`break` 语句在此点*之前*有条件地执行。\n- 如果 `break` 条件对于索引 $i$ 满足，循环终止，语句 $checksum \\leftarrow checksum + iter$ 不会为这个 $i$ 执行。在转换后的循环中，语句 $checksum \\leftarrow checksum + (2i+1)$ 也不会执行。行为是相同的。\n- 如果 `break` 条件对于索引 $i$ 不满足，$checksum$ 更新被执行。此时，$iter$ 的值保证为 $2i+1$。转换后的代码使用这个等价表达式，导致加到 $checksum$ 上的值相同。\n因此，该转换在所有可能的执行路径上都保留了语义。\n\n**任务3：计算最终的 `checksum`**\n\n我们给定的参数是 $n = 50$，$a = 7$，$d = 3$ 和 $k = 61$。\n数组元素由 $A[i] = a + d \\cdot i = 7 + 3i$ 定义。\n如果 $A[i]  k$，循环会提前终止，这可以转化为：\n$7 + 3i  61$\n$3i  54$\n$i  18$\n\n由于 $i$ 必须是整数，满足此条件的第一个 $i$ 值是 $i = 19$。\n这意味着循环将对 $i = 0, 1, 2, \\dots, 18$ 执行。当循环开始 $i=19$ 的迭代时，条件 $A[19]  61$ 将为真（$7 + 3(19) = 64  61$），并且 `break` 语句将被执行。因此，对于 $i=19$ 或任何后续索引，将不会执行 $checksum$ 更新。\n\n$checksum$ 的最终值是所有执行到 $checksum$ 更新的迭代中 $(2i+1)$ 项的总和。这对应于 $i$ 从 $0$ 到 $18$ 的范围。\n$$ checksum_{final} = \\sum_{i=0}^{18} (2i + 1) $$\n我们可以将求和拆分：\n$$ checksum_{final} = \\left( \\sum_{i=0}^{18} 2i \\right) + \\left( \\sum_{i=0}^{18} 1 \\right) $$\n$$ checksum_{final} = 2 \\left( \\sum_{i=0}^{18} i \\right) + (18 - 0 + 1) \\cdot 1 $$\n前 $N$ 个非负整数的和由公式 $\\sum_{i=0}^{N} i = \\frac{N(N+1)}{2}$ 给出。对于 $N=18$：\n$$ \\sum_{i=0}^{18} i = \\frac{18(18+1)}{2} = \\frac{18 \\times 19}{2} = 9 \\times 19 = 171 $$\n将此代回到 $checksum_{final}$ 的表达式中：\n$$ checksum_{final} = 2(171) + 19 $$\n$$ checksum_{final} = 342 + 19 = 361 $$\n另外，我们认识到这个和是前 19 个奇数的和（$2(0)+1, 2(1)+1, \\dots, 2(18)+1$）。前 $m$ 个奇数的和是 $m^2$。这里，有 $m=19$ 项（从 $i=0$ 到 $i=18$），所以和是 $19^2 = 361$。\n$checksum$ 的最终值是 $361$。",
            "answer": "$$\\boxed{361}$$"
        },
        {
            "introduction": "优化并非孤立进行，不同的技术常常协同作用。本练习将归纳变量消除与另一项关键优化——循环展开——相结合。你将学习如何通过重构地址计算，显著减少展开后循环体内的乘法运算次数，从而量化优化带来的性能收益 。",
            "id": "3645835",
            "problem": "考虑一个对归纳变量 (IV) $i$ 的循环，该循环使用仿射索引表达式计算逐元素和并存入一个目标数组。设 $X$、$Y$ 和 $Z$ 为元素数组（为简单起见，假设元素大小为单位尺寸），$p_{X}$、$p_{Y}$、$p_{Z}$ 为常量基偏移量，$s_{X}$、$s_{Y}$、$s_{Z}$ 为常量步长，所有这些都在编译时已知。该循环为\n$$\n\\text{for } i = 0, 1, \\dots, n-1:\\quad Z[p_{Z} + s_{Z} \\cdot i] \\leftarrow X[p_{X} + s_{X} \\cdot i] + Y[p_{Y} + s_{Y} \\cdot i].\n$$\n假设 $n$ 是一个正整数，可被选定的展开因子 $u \\geq 2$ 整除。将循环按因子 $u$ 展开，引入派生的归纳变量 $i+0, i+1, \\dots, i+(u-1)$ 来索引每个展开组内的 $u$ 个通道。针对整数地址算术，在以下成本模型下进行计算：\n- 在运行时计算一个仿射索引 $p + s \\cdot q$（其中 $q$ 是一个运行时变化的量）精确地产生一次整数乘法（用于 $s \\cdot q$）和一次整数加法（用于加上 $p$）。\n- 将一个编译时常量加到一个运行时值上，精确地产生一次整数加法，不产生整数乘法。\n- 所有常量 $p_{X}$、$p_{Y}$、$p_{Z}$、$s_{X}$、$s_{Y}$、$s_{Z}$ 以及通道索引 $k \\in \\{0,1,\\dots,u-1\\}$ 都是编译时常量。\n\n任务：\n1. 使用归纳变量和循环展开的定义，用 $i$ 和 $k$ 表示 $u$ 个通道索引，并写出 $X$、$Y$ 和 $Z$ 各自的朴素展开仿射索引。\n2. 展示如何通过为每个数组引入一个基指针（每个展开组计算一次）和用于 $u$ 个通道的多个常量偏移量，来从仿射索引中消除 $u$ 个派生归纳变量 $i+0, i+1, \\dots, i+(u-1)$。在一个展开组内，提供所有三个数组的结果仿射形式。\n3. 在给定的成本模型下，比较朴素展开的地址计算与消除归纳变量后的计算，并推导出一个用 $n$ 和 $u$ 表示的闭式表达式，该表达式表示在整个展开循环执行过程中（假设没有剩余迭代，即 $n$ 可被 $u$ 整除）所节省的整数乘法总数。将最终结果以单个解析表达式的形式给出。\n\n不需要数值舍入。最终答案必须是关于 $n$ 和 $u$ 的单个闭式解析表达式。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤1：提取已知条件\n- **数组**：$X$, $Y$, $Z$。\n- **基偏移量**：$p_{X}$, $p_{Y}$, $p_{Z}$ (编译时常量)。\n- **步长**：$s_{X}$, $s_{Y}$, $s_{Z}$ (编译时常量)。\n- **原始循环**：`for` $i = 0, 1, \\dots, n-1$。\n- **原始循环体**：$Z[p_{Z} + s_{Z} \\cdot i] \\leftarrow X[p_{X} + s_{X} \\cdot i] + Y[p_{Y} + s_{Y} \\cdot i]$。\n- **循环上界**：$n$，一个正整数。\n- **展开因子**：$u \\geq 2$。\n- **展开假设**：$n$ 可被 $u$ 整除。\n- **派生索引**：原始索引 $i$ 被一组用于每个展开组的索引所取代，对应于原始迭代 $i, i+1, \\dots, i+(u-1)$，其中 $i$现在是步长为 $u$ 的展开循环的归纳变量。\n- **通道索引**：$k \\in \\{0, 1, \\dots, u-1\\}$ (编译时常量)。\n- **成本模型**：\n  - 计算 $p + s \\cdot q$（其中 $q$ 是运行时变量）的成本：1 次乘法，1 次加法。\n  - 将编译时常量加到运行时值的成本：0 次乘法，1 次加法。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：问题基于编译器设计中的基本和标准概念，特别是循环展开、归纳变量分析和强度削减等代码优化技术。这些是计算机科学中公认的课题。该问题具有科学合理性。\n- **良态的**：问题清晰地结构化为三个不同的任务。它提供了所有必要的信息，包括精确的成本模型和简化假设（$n$ 可被 $u$ 整除），以得出一个唯一的解析解。\n- **客观性**：问题以正式、客观的语言陈述。术语都有定义，成本模型是明确的，没有主观解释的余地。\n\n### 步骤3：结论与行动\n该问题有效，因为它具有科学依据、是良态的、客观且自洽的。将提供完整的解决方案。\n\n---\n\n### 解答推导\n\n通过完成问题陈述中指定的三个任务来推导解答。\n\n**任务1：朴素展开的仿射索引**\n\n原始循环使用归纳变量 $i$ 从 $0$ 迭代到 $n-1$。\n$$ \\text{for } i = 0, 1, \\dots, n-1: \\quad Z[p_{Z} + s_{Z} \\cdot i] \\leftarrow X[p_{X} + s_{X} \\cdot i] + Y[p_{Y} + s_{Y} \\cdot i] $$\n将此循环按因子 $u$ 展开，会将其转换为一个执行 $n/u$ 次的新循环。根据问题的表述，我们继续将新循环的归纳变量称为 $i$，它遍历值 $0, u, 2u, \\dots, n-u$。这个新循环的每次迭代执行原始循环 $u$ 次迭代的工作。\n\n与单个新迭代 $i$ 对应的原始迭代组是原始索引为 $i+k$ 的那些迭代，其中通道索引 $k$ 的范围是从 $0$ 到 $u-1$。为了获得朴素展开的代码，我们在地址计算表达式中用 $i+k$ 替换原始归纳变量。\n\n对于每个数组 $A \\in \\{X, Y, Z\\}$ 和每个通道 $k \\in \\{0, 1, \\dots, u-1\\}$，仿射索引表达式为：\n$$ \\text{address}(A, i, k) = p_{A} + s_{A} \\cdot (i+k) $$\n因此，展开的循环体由 $u$ 条形如下式的语句组成：\n$$ Z[p_{Z} + s_{Z} \\cdot (i+k)] \\leftarrow X[p_{X} + s_{X} \\cdot (i+k)] + Y[p_{Y} + s_{Y} \\cdot (i+k)] $$\n其中 $k = 0, 1, \\dots, u-1$。这些就是朴素展开的仿射索引。\n\n**任务2：消除派生归纳变量**\n\n目标是减少地址计算所需的昂贵运算（乘法）的数量。我们通过对仿射索引表达式进行代数变换来实现这一点。这种技术是一种强度削减。\n\n考虑任意数组 $A$ 的朴素仿射索引：\n$$ p_{A} + s_{A} \\cdot (i+k) $$\n使用乘法对加法的分配律，我们可以将其重写为：\n$$ p_{A} + s_{A} \\cdot i + s_{A} \\cdot k $$\n我们可以根据各项是依赖于运行时循环变量 $i$ 还是编译时常量来重新组合它们：\n$$ \\left( p_{A} + s_{A} \\cdot i \\right) + \\left( s_{A} \\cdot k \\right) $$\n这种形式提示了一种更高效的计算地址的方法。\n对于每个展开组（即，对于新循环变量 $i$ 的每次迭代）：\n1.  为每个数组计算一个基指针，每组一次。该基指针对应于第一个通道（$k=0$）的地址：\n    $$ \\text{base\\_ptr}_{A}(i) = p_{A} + s_{A} \\cdot i $$\n2.  对于每个通道 $k \\in \\{0, 1, \\dots, u-1\\}$，通过将一个常量偏移量加到基指针上来计算最终地址。此偏移量在编译时已知：\n    $$ \\text{offset}_{A}(k) = s_{A} \\cdot k $$\n通道 $k$ 的结果仿射形式为：\n$$ \\text{address}(A, i, k) = \\text{base\\_ptr}_{A}(i) + \\text{offset}_{A}(k) $$\n这种重新表述消除了后续 $u-1$ 个通道计算中与运行时变量 $i$ 的乘法，代之以加上一个预先计算好的常量。\n\n**任务3：成本比较与节省量**\n\n现在我们根据提供的成本模型，分析朴素展开循环和优化后展开循环的整数乘法总数，然后计算节省量。分析涵盖整个循环的执行，其中包括 $n/u$ 次展开循环的迭代。\n\n**朴素展开地址计算的成本：**\n新循环运行 $n/u$ 次。在每次迭代中，我们处理 $u$ 个通道。对于每个通道 $k$，我们计算 3 个地址（分别用于 $X$、$Y$ 和 $Z$）。地址计算的形式为 $p_{A} + s_{A} \\cdot (i+k)$。由于 $i$ 是一个运行时变量，量 $i+k$ 也是一个运行时变化的量。根据成本模型，当 $q$ 在运行时变化时，计算 $p+s \\cdot q$ 的成本是 1 次乘法。\n- 每个通道的乘法次数：$3$（$X, Y, Z$ 各一次）。\n- 每个展开组的乘法次数：$u \\text{ lanes} \\times 3 \\text{ mults/lane} = 3u$。\n- 整个循环的总乘法次数：$(n/u) \\text{ groups} \\times 3u \\text{ mults/group} = 3n$。\n因此，朴素展开循环中的总乘法次数为 $M_{\\text{naive}} = 3n$。这与原始的、未展开的循环相同。\n\n**消除归纳变量后的计算成本：**\n新循环运行 $n/u$ 次。在展开循环的每次迭代中（对于给定的 $i$）：\n1.  我们计算 3 个基指针，每个数组一个：$\\text{base\\_ptr}_{X}(i)$、$\\text{base\\_ptr}_{Y}(i)$、$\\text{base\\_ptr}_{Z}(i)$。每个计算的形式都是 $p_A + s_A \\cdot i$。由于 $i$ 是一个运行时变量，每个基指针的计算成本是 1 次乘法。\n    - 一个组中所有基指针的乘法次数：$3$。\n2.  对于 $u$ 个通道中的每一个，我们通过将一个编译时常量偏移量加到基指针上来计算最终地址：$\\text{address}(A, i, k) = \\text{base\\_ptr}_{A}(i) + \\text{offset}_{A}(k)$。根据成本模型，将一个常量加到一个运行时值上需要 0 次乘法。\n    - 特定通道偏移量的乘法次数：$0$。\n- 每个展开组的总乘法次数：$3 + 0 = 3$。\n- 整个循环的总乘法次数：$(n/u) \\text{ groups} \\times 3 \\text{ mults/group} = \\frac{3n}{u}$。\n因此，优化后循环中的总乘法次数为 $M_{\\text{optimized}} = \\frac{3n}{u}$。\n\n**节省的整数乘法总数：**\n节省的数量是朴素计算成本与优化计算成本之间的差值。\n$$ \\text{Savings} = M_{\\text{naive}} - M_{\\text{optimized}} $$\n$$ \\text{Savings} = 3n - \\frac{3n}{u} $$\n提取公因式 $3n$，我们得到：\n$$ \\text{Savings} = 3n \\left(1 - \\frac{1}{u}\\right) $$\n将其写为单个分数形式，得到最终的闭式表达式：\n$$ \\text{Savings} = \\frac{3n(u-1)}{u} $$",
            "answer": "$$\n\\boxed{\\frac{3n(u-1)}{u}}\n$$"
        }
    ]
}