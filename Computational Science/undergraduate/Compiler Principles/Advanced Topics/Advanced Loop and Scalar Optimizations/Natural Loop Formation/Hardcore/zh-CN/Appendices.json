{
    "hands_on_practices": [
        {
            "introduction": "掌握自然循环的理论定义是第一步，而将其应用于具体的控制流图 (Control Flow Graph, CFG) 是检验和深化理解的关键。本练习  将引导你手动完成从支配关系计算到回边识别，再到闩锁 (latch) 节点判定的全过程。通过这个循序渐进的计算，你将对循环的结构化属性建立起直观而坚实的认识。",
            "id": "3659023",
            "problem": "给定一个可约控制流图 (CFG) $G=(V,E)$，其具有唯一的入口节点 $s$，节点集为 $V=\\{1,2,3,4,5,6,7,8,9,10\\}$。有向边集为\n$$\nE=\\{(1,2),(2,3),(3,4),(4,5),(5,3),(4,6),(6,7),(7,4),(4,8),(8,9),(9,8),(9,10)\\}.\n$$\n从基本定义开始：\n- 节点 $a$ 支配节点 $b$ （记作“$a$ dominates $b$”），当且仅当从 $s$ 到 $b$ 的每一条路径都包含 $a$。\n- 对于节点 $n\\neq s$，其直接支配者 $\\operatorname{idom}(n)$ 是 $n$ 的唯一的严格支配者，它支配 $n$ 的所有其他严格支配者。\n- 一条边 $(t,h)$ 是回边，当且仅当 $h$ 支配 $t$。\n- 对于一条回边 $(t,h)$，与头节点 $h$ 相关联的自然循环 $L(h)$ 是包含 $h$ 和 $t$ 的最小节点集合，满足对于任意节点 $x\\in L(h)\\setminus\\{h\\}$，都存在一条从 $x$ 到 $t$ 的不经过 $h$ 的路径，且该路径上的所有节点都在 $L(h)$ 中。\n- 锁存节点 (latch) 是一个节点 $l$，它有一条边 $(l,h)$ 指向循环头节点 $h$，并且满足 $l \\in L(h)$。\n\n任务：\n1. 使用入口为 $s=1$ 的支配定义，推导每个节点 $n\\in V\\setminus\\{1\\}$ 的 $\\operatorname{idom}(n)$。\n2. 通过检查头尾节点的支配条件，找出所有的回边 $(t,h)$。\n3. 对于该图 $G$ 中的每条回边 $(t,h)$，使用上述定义来论证，如果 $\\operatorname{idom}(h)\\neq t$，那么在该图中 $t$ 是 $L(h)$ 的锁存节点。枚举 $G$ 中所有这样的锁存节点 $t$，并验证每个自然循环 $L(h)$ 都有一个唯一的锁存节点。\n4. 设 $S$ 为你在第3项中枚举的所有锁存节点的数字标签之和。计算 $S$。\n\n给出 $S$ 的最终值，为一个整数。无需四舍五入。",
            "solution": "问题要求我们分析一个给定的控制流图 (CFG) $G=(V,E)$，以确定其自然循环及相关的锁存节点，然后计算这些锁存节点标签的总和。整个过程将遵循问题陈述中指定的四个任务。\n\n给定的 CFG 具有节点集 $V=\\{1,2,3,4,5,6,7,8,9,10\\}$ 和边集 $E=\\{(1,2),(2,3),(3,4),(4,5),(5,3),(4,6),(6,7),(7,4),(4,8),(8,9),(9,8),(9,10)\\}$。唯一的入口节点是 $s=1$。\n\n**任务1：推导每个节点 $n\\in V\\setminus\\{1\\}$ 的直接支配者 $\\operatorname{idom}(n)$。**\n\n如果从入口节点 $s=1$ 到节点 $b$ 的每一条路径都包含节点 $a$，那么节点 $a$ 支配节点 $b$。直接支配者 $\\operatorname{idom}(n)$ 是 $n$ 的严格支配者中，在任何从 $s$ 出发的路径上离 $n$ 最近的那一个。\n\n- **节点 2**：从 $1$ 出发的唯一路径是 $1 \\to 2$。$2$ 的支配者是 $\\{1, 2\\}$。严格支配者是 $\\{1\\}$。因此，$\\operatorname{idom}(2)=1$。\n- **节点 3**：任何到 $3$ 的路径都必须先经过 $1 \\to 2$。例如，$1 \\to 2 \\to 3$。另一条路径可以是 $1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 3$，但这条路径也经过了 $2$。$3$ 的支配者是 $\\{1, 2, 3\\}$。因此，$\\operatorname{idom}(3)=2$。\n- **节点 4**：任何到 $4$ 的路径都必须先经过 $1 \\to 2 \\to 3$。例如，$1 \\to 2 \\to 3 \\to 4$。$4$ 的支配者是 $\\{1, 2, 3, 4\\}$。因此，$\\operatorname{idom}(4)=3$。\n- **节点 5**：任何到 $5$ 的路径都必须通过边 $(4,5)$ 经过 $4$。$5$ 的支配者是 $\\{1, 2, 3, 4, 5\\}$。因此，$\\operatorname{idom}(5)=4$。\n- **节点 6**：任何到 $6$ 的路径都必须通过边 $(4,6)$ 经过 $4$。$6$ 的支配者是 $\\{1, 2, 3, 4, 6\\}$。因此，$\\operatorname{idom}(6)=4$。\n- **节点 7**：任何到 $7$ 的路径都必须通过边 $(6,7)$ 经过 $6$。$7$ 的支配者是 $\\{1, 2, 3, 4, 6, 7\\}$。因此，$\\operatorname{idom}(7)=6$。\n- **节点 8**：任何到 $8$ 的路径都必须经过 $4$。$8$ 的支配者是 $\\{1, 2, 3, 4, 8\\}$。因此，$\\operatorname{idom}(8)=4$。\n- **节点 9**：任何到 $9$ 的路径都必须通过边 $(8,9)$ 经过 $8$。$9$ 的支配者是 $\\{1, 2, 3, 4, 8, 9\\}$。因此，$\\operatorname{idom}(9)=8$。\n- **节点 10**：任何到 $10$ 的路径都必须通过边 $(9,10)$ 经过 $9$。$10$ 的支配者是 $\\{1, 2, 3, 4, 8, 9, 10\\}$。因此，$\\operatorname{idom}(10)=9$。\n\n支配关系集合 $\\operatorname{dom}(n)$ 和直接支配者 $\\operatorname{idom}(n)$ 如下：\n- $\\operatorname{dom}(2) = \\{1,2\\}$, $\\operatorname{idom}(2)=1$\n- $\\operatorname{dom}(3) = \\{1,2,3\\}$, $\\operatorname{idom}(3)=2$\n- $\\operatorname{dom}(4) = \\{1,2,3,4\\}$, $\\operatorname{idom}(4)=3$\n- $\\operatorname{dom}(5) = \\{1,2,3,4,5\\}$, $\\operatorname{idom}(5)=4$\n- $\\operatorname{dom}(6) = \\{1,2,3,4,6\\}$, $\\operatorname{idom}(6)=4$\n- $\\operatorname{dom}(7) = \\{1,2,3,4,6,7\\}$, $\\operatorname{idom}(7)=6$\n- $\\operatorname{dom}(8) = \\{1,2,3,4,8\\}$, $\\operatorname{idom}(8)=4$\n- $\\operatorname{dom}(9) = \\{1,2,3,4,8,9\\}$, $\\operatorname{idom}(9)=8$\n- $\\operatorname{dom}(10) = \\{1,2,3,4,8,9,10\\}$, $\\operatorname{idom}(10)=9$\n\n**任务2：找出所有的回边 $(t,h)$。**\n\n如果一条有向边 $(t,h)$ 的头节点 $h$ 支配其尾节点 $t$，则该边是回边。我们检查 $E$ 中的每一条边：\n- $(1,2)$：$2$ 不支配 $1$。\n- $(2,3)$：$3$ 不支配 $2$。\n- $(3,4)$：$4$ 不支配 $3$。\n- $(4,5)$：$5$ 不支配 $4$。\n- $(5,3)$：$3$ 是否支配 $5$？是的，$3 \\in \\operatorname{dom}(5)=\\{1,2,3,4,5\\}$。这是一条回边，其中 $t=5, h=3$。\n- $(4,6)$：$6$ 不支配 $4$。\n- $(6,7)$：$7$ 不支配 $6$。\n- $(7,4)$：$4$ 是否支配 $7$？是的，$4 \\in \\operatorname{dom}(7)=\\{1,2,3,4,6,7\\}$。这是一条回边，其中 $t=7, h=4$。\n- $(4,8)$：$8$ 不支配 $4$。\n- $(8,9)$：$9$ 不支配 $8$。\n- $(9,8)$：$8$ 是否支配 $9$？是的，$8 \\in \\operatorname{dom}(9)=\\{1,2,3,4,8,9\\}$。这是一条回边，其中 $t=9, h=8$。\n- $(9,10)$：$10$ 不支配 $9$。\n\n回边的集合是 $\\{(5,3), (7,4), (9,8)\\}$。\n\n**任务3：分析回边并确定锁存节点。**\n\n我们必须论证，对于此图中的每条回边 $(t,h)$，如果 $\\operatorname{idom}(h) \\neq t$，那么 $t$ 就是自然循环 $L(h)$ 的锁存节点。我们还要枚举这些锁存节点 $t$，并验证每个循环的锁存节点的唯一性。\n\n一个以 $h$ 为头节点的循环的锁存节点 $l$ 是指位于自然循环 $L(h)$ 内，且有一条边 $(l,h)$ 指向循环头 $h$ 的节点。\n\n对于回边 $(t,h)$，其自然循环 $L(h)$ 由 $h$ 以及所有可以不经过 $h$ 到达 $t$ 的节点组成。\n\n**情况1：回边 $(t,h) = (5,3)$**\n- **条件检查**：$\\operatorname{idom}(h)=\\operatorname{idom}(3)=2$。尾节点是 $t=5$。由于 $2 \\neq 5$，条件 $\\operatorname{idom}(h)\\neq t$ 成立。\n- **自然循环 $L(3)$**：我们找到可以不经过 $h=3$ 到达 $t=5$ 的节点集合。\n  - 从 $5$ 开始向后搜索：$5$ 的前驱是 $4$。路径 $4 \\to 5$ 不包含 $3$。所以，$4 \\in L(3)$。\n  - $4$ 的前驱是 $3$ 和 $7$。从 $3$ 出发的路径被阻塞。从 $7$ 出发的路径继续：$7 \\to 4 \\to 5$ 不包含 $3$。所以，$7 \\in L(3)$。\n  - $7$ 的前驱是 $6$。路径 $6 \\to 7 \\to 4 \\to 5$ 不包含 $3$。所以，$6 \\in L(3)$。\n  - $6$ 的前驱是 $4$，它已经在集合中。\n  可以不经过 $3$ 到达 $5$ 的节点是 $\\{4,5,6,7\\}$。\n  因此，$L(3) = \\{3\\} \\cup \\{4,5,6,7\\} = \\{3,4,5,6,7\\}$。\n- **锁存节点确定**：头节点 $h=3$ 的前驱是 $\\{2, 5\\}$。我们检查其中哪些在 $L(3)$ 中。\n  - $2 \\notin L(3)$，所以 $2$ 不是锁存节点。\n  - $5 \\in L(3)$，所以 $5$ 是一个锁存节点。\n  唯一从其自身的循环 $L(3)$ 内部进入 $h=3$ 的边是 $(5,3)$。因此，$5$ 是 $L(3)$ 的唯一锁存节点。\n- **结论**：条件成立，尾节点 $t=5$ 确实是唯一的锁存节点。\n\n**情况2：回边 $(t,h) = (7,4)$**\n- **条件检查**：$\\operatorname{idom}(h)=\\operatorname{idom}(4)=3$。尾节点是 $t=7$。由于 $3 \\neq 7$，条件 $\\operatorname{idom}(h)\\neq t$ 成立。\n- **自然循环 $L(4)$**：我们找到可以不经过 $h=4$ 到达 $t=7$ 的节点。\n  - 从 $7$ 开始向后搜索：$7$ 的前驱是 $6$。路径 $6 \\to 7$ 不包含 $4$。所以，$6 \\in L(4)$。\n  - $6$ 的前驱是 $4$。这条路径被阻塞。\n  可以不经过 $4$ 到达 $7$ 的节点是 $\\{6,7\\}$。\n  因此，$L(4) = \\{4\\} \\cup \\{6,7\\} = \\{4,6,7\\}$。\n- **锁存节点确定**：头节点 $h=4$ 的前驱是 $\\{3, 7\\}$。我们检查哪些在 $L(4)$ 中。\n  - $3 \\notin L(4)$，所以 $3$ 不是锁存节点。\n  - $7 \\in L(4)$，所以 $7$ 是一个锁存节点。\n  唯一从其自身的循环 $L(4)$ 内部进入 $h=4$ 的边是 $(7,4)$。因此，$7$ 是 $L(4)$ 的唯一锁存节点。\n- **结论**：条件成立，尾节点 $t=7$ 是唯一的锁存节点。\n\n**情况3：回边 $(t,h) = (9,8)$**\n- **条件检查**：$\\operatorname{idom}(h)=\\operatorname{idom}(8)=4$。尾节点是 $t=9$。由于 $4 \\neq 9$，条件 $\\operatorname{idom}(h)\\neq t$ 成立。\n- **自然循环 $L(8)$**：我们找到可以不经过 $h=8$ 到达 $t=9$ 的节点。\n  - 从 $9$ 开始向后搜索：$9$ 的唯一前驱是 $8$。任何到 $9$ 的路径都必须经过 $8$。唯一的例外是从 $9$ 到自身的平凡零长度路径。\n  唯一可以不经过 $8$ 到达 $9$ 的节点是 $9$ 本身。\n  因此，$L(8) = \\{8\\} \\cup \\{9\\} = \\{8,9\\}$。\n- **锁存节点确定**：头节点 $h=8$ 的前驱是 $\\{4, 9\\}$。我们检查哪些在 $L(8)$ 中。\n  - $4 \\notin L(8)$，所以 $4$ 不是锁存节点。\n  - $9 \\in L(8)$，所以 $9$ 是一个锁存节点。\n  唯一从其自身的循环 $L(8)$ 内部进入 $h=8$ 的边是 $(9,8)$。因此，$9$ 是 $L(8)$ 的唯一锁存节点。\n- **结论**：条件成立，尾节点 $t=9$ 是唯一的锁存节点。\n\n在这三种情况下，前提 $\\operatorname{idom}(h) \\neq t$ 为真，结论 $t$ 是 $L(h)$ 的唯一锁存节点也为真。问题所要求的论证对于这个特定的图 $G$ 是成立的。枚举出的锁存节点是 $\\{5, 7, 9\\}$。\n\n**任务4：计算锁存节点标签的总和 $S$。**\n\n锁存节点的集合是 $\\{5, 7, 9\\}$。它们的数字标签之和 $S$ 是：\n$$S = 5 + 7 + 9 = 21$$",
            "answer": "$$\n\\boxed{21}\n$$"
        },
        {
            "introduction": "真实的程序控制流远比简单的循环复杂，例如，结构化异常处理 (try/catch) 会引入非局部的控制转移。这个练习  挑战你在一个包含异常边的控制流图中，严格运用支配关系和自然循环的定义。这有助于你理解这些形式化定义的普适性和强大之处，即它们能够精确地刻画各种复杂控制结构，而不仅仅是简单的循环。",
            "id": "3659054",
            "problem": "考虑一个控制流图 (CFG) $G=(V,E)$，它模拟了带有单个 try/catch 的结构化异常，其中 $V=\\{e,h,b_1,b_2,t,c,x\\}$，$E$ 由以下有向边组成：\n- 正常边：$(e,h)$、$(h,b_1)$、$(b_1,b_2)$、$(b_2,t)$、$(t,h)$、$(h,x)$。\n- 异常边（从 try 块到 catch 处理程序）：$(b_1,c)$、$(b_2,c)$。\n- 处理程序续行：$(c,x)$。\n\n假设结构化异常具有通常的语义：一条异常边会立即将控制权转移到 catch 处理程序 $c$，之后控制流转向 $x$；不存在从 $c$ 到 $h$、$t$、$b_1$ 或 $b_2$ 的边。节点 $e$ 是唯一入口，$x$ 是唯一出口，$h$ 是一个循环头候选节点，$t$ 是 try 块内的一个循环尾候选节点，$c$ 是 catch 处理程序。\n\n根据编译原理中用于支配和自然循环的正式定义，评估在存在异常边的情况下，$h$ 是否仍然支配 $t$，以及与回边 $(t,h)$ 相关联的自然循环 $L(h)$ 是如何计算的。选择唯一的最佳答案。\n\nA. $h$ 支配 $t$，并且 $L(h)$ 的计算方法是：取 $t$ 的所有前驱节点（包括通过任何类型的边可达的节点），但 $h$ 除外，然后迭代地查找前驱节点直至集合不再增长，最后再添加 $h$。因为 $c$ 无法到达 $t$，所以得到 $L(h)=\\{h,t,b_2,b_1\\}$。\n\nB. $h$ 不支配 $t$，因为异常边引入了一条从 $e$ 经由 $c$ 到达 $t$ 且避开 $h$ 的路径，所以 $(t,h)$ 不是一条回边，且 $L(h)$ 未定义。\n\nC. 只有在计算支配关系时忽略异常边，$h$ 才支配 $t$；因此 $L(h)$ 的计算必须从前驱闭包中排除异常边，得到 $L(h)=\\{h,t,b_2,b_1\\}$。\n\nD. $h$ 支配 $t$，但 $L(h)$ 还必须包含 $c$，因为 $c$ 可以从 try 块到达；循环成员必须包括 try 块的所有后继节点，包括处理程序，所以 $L(h)=\\{h,t,b_2,b_1,c\\}$。",
            "solution": "该问题陈述是编译原理中的一个有效练习，具体涉及包含结构化异常处理的控制流图 (CFG) 上的数据流分析。它具有科学依据，问题定义明确且客观。我们可以开始进行解答。\n\n解答需要将支配、回边和自然循环的正式定义应用到所提供的控制流图 $G=(V,E)$ 上。\n\n**1. 正式定义**\n\n*   **支配 (Dominance):** 在一个具有唯一入口节点 $e$ 的 CFG 中，如果从入口节点 $e$ 到节点 $n$ 的每一条路径都包含节点 $d$，则称节点 $d$ *支配* 节点 $n$，记作 $d \\operatorname{dom} n$。根据定义，每个节点都支配其自身。\n*   **回边 (Back Edge):** CFG 中的一条有向边 $(u, v)$ 是*回边*，如果其头节点 $v$ 支配其尾节点 $u$。节点 $v$ 被称为循环头。\n*   **自然循环 (Natural Loop):** 给定一条回边 $(u,v)$，其*自然循环*由头节点 $v$ 以及图中所有能够在不经过 $v$ 的情况下到达尾节点 $u$ 的节点组成。\n    计算回边 $(u,v)$ 的自然循环中节点集合的算法如下：\n    1.  将尾节点 $u$ 加入循环集合。\n    2.  从 $u$ 开始进行反向图遍历，以找到其所有前驱节点。如果前驱节点 $p$ 不是头节点 $v$，则将其添加到循环集合中。\n    3.  对添加到循环集合中的任何新节点重复步骤2，直到没有更多节点可以添加为止。\n    4.  最后，将头节点 $v$ 添加到计算出的节点集合中。\n\n**2. 对给定 CFG 的分析**\n\n我们将这些定义应用于给定的 CFG $G=(V,E)$，其中 $V=\\{e,h,b_1,b_2,t,c,x\\}$，边集合为 $E = \\{(e,h), (h,b_1), (b_1,b_2), (b_2,t), (t,h), (h,x), (b_1,c), (b_2,c), (c,x)\\}$。唯一入口节点是 $e$。\n\n**2.1. $h$ 对 $t$ 的支配关系**\n\n要确定 $h$ 是否支配 $t$，我们必须找出从入口节点 $e$ 到节点 $t$ 的所有可能路径。\n1.  从 $e$ 出发，唯一的出边是 $(e,h)$。因此，从 $e$到任何其他节点的任何路径都必须以子路径 $e \\rightarrow h$ 开始。\n2.  从 $h$ 出发，有两条出边：$(h,b_1)$ 和 $(h,x)$。到 $t$ 的路径不能走向 $x$，因为 $x$ 是唯一的出口，没有指回图中的出边。因此，到 $t$ 的路径必须沿着 $h \\rightarrow b_1$ 继续。\n3.  从 $b_1$ 出发，有两条出边：$(b_1,b_2)$ 和异常边 $(b_1,c)$。\n    *   如果路径走 $(b_1,c)$ 这条边，它会到达 catch 处理程序 $c$。从 $c$ 出发的唯一出边是 $(c,x)$。不存在从 $c$ 或 $x$ 到 $t$ 的路径。所以，这条路径无法到达 $t$。\n    *   因此，要到达 $t$，路径必须走 $(b_1,b_2)$ 这条边。\n4.  从 $b_2$ 出发，有两条出边：$(b_2,t)$ 和异常边 $(b_2,c)$。\n    *   同样，如果路径走 $(b_2,c)$ 这条边，它会到达 $c$ 然后到 $x$，无法到达 $t$。\n    *   因此，要到达 $t$，路径必须走 $(b_2,t)$ 这条边。\n\n综合这些步骤，从入口节点 $e$ 到节点 $t$ 的唯一路径是 $e \\rightarrow h \\rightarrow b_1 \\rightarrow b_2 \\rightarrow t$。由于这条路径包含 $h$，因此从 $e$ 到 $t$ 的每一条路径都必须包含 $h$。\n根据定义，**$h$ 支配 $t$**。异常边的存在不会改变这一事实，因为它们导向一条不会重新连接到 $t$ 的退出路径 ($c \\rightarrow x$)。\n\n**2.2. 回边识别**\n\n问题将边 $(t,h)$ 确定为一条潜在的回边。由于其头节点 $h$ 支配其尾节点 $t$，因此边 **$(t,h)$ 确实是一条回边**。\n\n**2.3. 自然循环 $L(h)$ 的计算**\n\n自然循环 $L(h)$ 与回边 $(t,h)$ 相关联。遵循算法：\n1.  设循环节点集 `LoopNodes` 初始为空。我们将找到所有能够在不经过头节点 $h$ 的情况下到达尾节点 $t$ 的节点。\n2.  我们从 $t$ 开始进行反向可达性搜索，同时避开 $h$。\n    *   从 $t$ 开始。$t$ 能否在不经过 $h$ 的情况下到达 $t$？可以（长度为0的路径）。将 $t$ 添加到 `LoopNodes`。\n    *   查找 `LoopNodes` 中节点的前驱节点。$t$ 的唯一前驱是 $b_2$。\n    *   考虑 $b_2$。$b_2$ 能否在不经过 $h$ 的情况下到达 $t$？可以，通过路径 $b_2 \\rightarrow t$。将 $b_2$ 添加到 `LoopNodes`。现在 `LoopNodes` 为 $\\{t, b_2\\}$。\n    *   查找新节点的前驱节点。$b_2$ 的唯一前驱是 $b_1$。\n    *   考虑 $b_1$。$b_1$ 能否在不经过 $h$ 的情况下到达 $t$？可以，通过路径 $b_1 \\rightarrow b_2 \\rightarrow t$。将 $b_1$ 添加到 `LoopNodes`。现在 `LoopNodes` 为 $\\{t, b_2, b_1\\}$。\n    *   查找新节点的前驱节点。$b_1$ 的唯一前驱是 $h$。没有路径可以从 $b_1$ 的一个前驱（即 $h$）开始，在不经过 $h$ 的情况下到达 $b_1$。遍历到此停止。\n    *   前驱搜索必须考虑所有边，包括异常边。$c$ 的前驱是 $\\{b_1, b_2\\}$，但 $c$ 无法到达 $t$，所以从 $t$ 开始的反向搜索永远不会遇到 $c$。\n3.  能够在不经过 $h$ 的情况下到达 $t$ 的节点集合是 $\\{t, b_2, b_1\\}$。\n4.  自然循环是这个集合再加上头节点 $h$。\n    因此，$L(h) = \\{t, b_2, b_1\\} \\cup \\{h\\} = \\{h, b_1, b_2, t\\}$。\n\n**3. 选项评估**\n\n*   **A. $h$ 支配 $t$，并且 $L(h)$ 的计算方法是：取 $t$ 的所有前驱节点（包括通过任何类型的边可达的节点），但 $h$ 除外，然后迭代地查找前驱节点直至集合不再增长，最后再添加 $h$。因为 $c$ 无法到达 $t$，所以得到 $L(h)=\\{h,t,b_2,b_1\\}$。**\n    *   陈述“$h$ 支配 $t$”是正确的。\n    *   对自然循环计算的描述是对标准算法的正确重述。\n    *   “因为 $c$ 无法到达 $t$”的推理正确地解释了为什么 $c$ 没有被包含在从 $t$ 开始的反向遍历中。\n    *   最终结果 $L(h)=\\{h,t,b_2,b_1\\}$（集合中顺序无关）与我们的推导相符。\n    *   **结论：正确。**\n\n*   **B. $h$ 不支配 $t$，因为异常边引入了一条从 $e$ 经由 $c$ 到达 $t$ 且避开 $h$ 的路径，所以 $(t,h)$ 不是一条回边，且 $L(h)$ 未定义。**\n    *   前提“$h$ 不支配 $t$”是错误的。\n    *   所给出的理由，“一条从 $e$ 经由 $c$ 到达 $t$ 的路径”，对于给定的 CFG 在事实上是不正确的。任何到达 $c$ 的路径只能继续到 $x$，而无法到达 $t$。\n    *   由于前提是错误的，结论是无效的。\n    *   **结论：不正确。**\n\n*   **C. 只有在计算支配关系时忽略异常边，$h$ 才支配 $t$；因此 $L(h)$ 的计算必须从前驱闭包中排除异常边，得到 $L(h)=\\{h,t,b_2,b_1\\}$。**\n    *   断言“只有在忽略异常边时 $h$ 才支配 $t$”是错误的。我们的分析表明，在包括异常边的完整 CFG 上，$h$ 支配 $t$。\n    *   “因此 $L(h)$ 的计算必须排除异常边”的推理是基于错误前提的推论失据 (non-sequitur)。自然循环的标准定义是在整个图上操作的。除非定义了特定的非标准分析框架，否则不能任意排除边。\n    *   虽然最终的 $L(h)$ 集合碰巧是正确的，但关于支配和循环计算的推理都存在根本性缺陷。\n    *   **结论：不正确。**\n\n*   **D. $h$ 支配 $t$，但 $L(h)$ 还必须包含 $c$，因为 $c$ 可以从 try 块到达；循环成员必须包括 try 块的所有后继节点，包括处理程序，所以 $L(h)=\\{h,t,b_2,b_1,c\\}$。**\n    *   陈述“$h$ 支配 $t$”是正确的。\n    *   关于循环成员资格的推理是不正确的。它提出了一条基于“try 块”语义的临时规则 (ad-hoc rule)，而不是基于自然循环的形式化、图论定义。该定义取决于一个循环头、一个循环尾，以及到循环尾的反向可达性，而不是从循环体内部节点的前向可达性。\n    *   如推导所示，$c$ 无法到达 $t$，因此根据标准定义，它不能成为自然循环 $L(h)$ 的一部分。所得出的集合是不正确的。\n    *   **结论：不正确。**\n\n基于对编译原理中形式化定义的严格应用，选项 A 提供了完全正确的分析。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "从理论到实践的跨越是编译器学习中的重要一环，将抽象的算法转化为可执行的代码是衡量掌握程度的最终标准。这个综合性练习  要求你不仅要推导算法，还要完整地实现它，以处理一系列测试用例。通过编写代码来计算支配集、识别回边并最终找出自然循环，你将获得宝贵的工程实践经验，并深刻理解这些概念在自动化工具中的实现原理。",
            "id": "3659041",
            "problem": "给定一个控制流图 (CFG)，形式化为一个有向图 $G = (V, E, s)$，其中 $V$ 是一个由不同正整数标记的节点的有限集，$E \\subseteq V \\times V$ 是一个有向边集，而 $s \\in V$ 是唯一的入口节点。对于节点 $u, v \\in V$，如果存在一条从 $u$ 到 $v$ 的有向边，则记为 $(u, v) \\in E$。对于任意节点 $n \\in V$，定义其前驱节点集为 $\\mathrm{pred}(n) = \\{ p \\in V \\mid (p, n) \\in E \\}$。支配节点集 $\\mathrm{dom}(n) \\subseteq V$ 是指从 $s$ 到 $n$ 的每一条路径上都出现的节点的集合。根据定义，对于所有 $n \\in V$，$n \\in \\mathrm{dom}(n)$；对于入口节点 $s$，$\\mathrm{dom}(s) = \\{ s \\}$。\n\n一条有向边 $(t, h) \\in E$ 被称为回边，当且仅当 $h \\in \\mathrm{dom}(t)$。一条回边 $(t, h)$ 的自然循环，记作 $L(h)$，是包含 $h$ 的最小节点集，使得对于所有 $n \\in L(h)$ 且 $n \\ne h$ 的节点，都存在一条从 $n$ 到 $t$ 的不经过 $h$ 的路径。等价地，如果 $h \\in \\mathrm{dom}(t)$，则 $L(h) = \\{ h \\} \\cup \\{ n \\in V \\mid \\exists \\text{ a path } n \\leadsto t \\text{ in } G \\text{ that avoids } h \\}$。\n\n任务：\n1. 从 CFG 可达性和支配关系的基本定义出发，推导并指定一个算法，用于为给定的边 $(t, h)$ 计算 $L(h)$。该算法必须：\n   - 仅使用入口节点 $s$、前驱关系和集合交集运算，计算所有节点 $n \\in V$ 的支配节点集 $\\mathrm{dom}(n)$。\n   - 通过检查 $h \\in \\mathrm{dom}(t)$ 是否成立来判断 $(t, h)$ 是否为回边。\n   - 如果 $(t, h)$ 是回边，则通过从 $t$ 开始，在 $\\mathrm{pred}(\\cdot)$ 上执行后向可达性分析，同时避开 $h$，然后将 $h$ 加入结果集，从而计算出 $L(h)$。\n   - 如果 $(t, h)$ 不是回边，则定义输出为空集。\n2. 基于支配节点属性和可达性定义，证明你的算法的正确性。\n3. 将该算法实现为一个完整的程序。对于下面测试套件中的每个测试用例，程序需要构建 CFG，计算所有节点的 $\\mathrm{dom}(\\cdot)$，识别 $(t, h)$ 是否为回边，并将集合 $L(h)$ 作为节点标识符（整数）的升序排序列表输出。如果 $(t, h)$ 不是回边，则输出空列表。\n\n测试套件：\n- 情况 A：\n  - $V = \\{ 1, 2, 3, 4 \\}$。\n  - $E = \\{ (1, 2), (2, 3), (3, 2), (3, 4) \\}$。\n  - $s = 1$。\n  - $(t, h) = (3, 2)$。\n- 情况 B：\n  - $V = \\{ 1, 2, 3, 4, 5, 6 \\}$。\n  - $E = \\{ (1, 2), (2, 3), (3, 4), (4, 5), (5, 3), (4, 6) \\}$。\n  - $s = 1$。\n  - $(t, h) = (5, 3)$。\n- 情况 C：\n  - $V = \\{ 1, 2, 3, 4, 5, 6, 7 \\}$。\n  - $E = \\{ (1, 2), (2, 3), (3, 4), (4, 3), (3, 5), (5, 6), (6, 3), (6, 7) \\}$。\n  - $s = 1$。\n  - $(t, h) = (6, 3)$。\n- 情况 D：\n  - $V = \\{ 1, 2, 3, 4 \\}$。\n  - $E = \\{ (1, 2), (2, 3), (1, 3), (3, 4) \\}$。\n  - $s = 1$。\n  - $(t, h) = (3, 2)$。\n- 情况 E：\n  - $V = \\{ 1 \\}$。\n  - $E = \\{ (1, 1) \\}$。\n  - $s = 1$。\n  - $(t, h) = (1, 1)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是 $L(h)$ 中节点的方括号括起来的、逗号分隔的升序列表。对于 $(t, h)$ 不是回边的测试用例，输出空列表 $[\\,]$。因此，总输出必须是单个列表的列表，例如 $[[1,2],[3]]$。\n\n你的程序必须是自包含的，并且不得读取任何输入。它必须硬编码上述测试套件，并准确生成一行输出，按顺序将五个结果显示为单个列表的列表。输出中唯一允许的数据类型是整数、整数列表以及这些类型的嵌套列表。",
            "solution": "经评估，用户提供的问题是有效的。它在科学上基于编译器理论和图算法的原理，问题陈述清晰，定义精确，并且完全客观。它是自包含、一致的，并且需要应用标准的、非平凡的算法。因此，我们可以进行形式化的解答。\n\n### **1. 算法推导**\n\n该任务要求开发一种算法，用于计算控制流图 $G = (V, E, s)$ 中与潜在回边 $(t, h)$ 相关联的自然循环 $L(h)$。整个过程分为三个主要阶段：计算支配节点集、识别回边和计算自然循环的节点。\n\n#### **1.1. 支配节点计算**\n\n一个节点 $n$ 的支配节点集，记作 $\\mathrm{dom}(n)$，是指从入口节点 $s$ 到 $n$ 的每一条路径都包含的节点 $m$ 的集合。该定义提供了两个基本条件：\n1.  对于任意节点 $n \\in V$，$n \\in \\mathrm{dom}(n)$。\n2.  对于入口节点 $s$，$\\mathrm{dom}(s) = \\{s\\}$。\n\n对于任何其他节点 $n \\neq s$，一个节点 $m$ 要支配 $n$，当且仅当它支配 $n$ 的所有直接前驱。这导出了支配节点的基本数据流方程：\n$$\n\\mathrm{dom}(n) = \\{n\\} \\cup \\left( \\bigcap_{p \\in \\mathrm{pred}(n)} \\mathrm{dom}(p) \\right) \\quad \\text{for } n \\neq s\n$$\n其中 $\\mathrm{pred}(n) = \\{ p \\in V \\mid (p, n) \\in E \\}$ 是 $n$ 的前驱节点集。\n\n这个方程组可以使用迭代不动点算法求解。算法过程如下：\n\n1.  **初始化**：\n    *   初始化入口节点的支配节点集：$\\mathrm{dom}(s) \\leftarrow \\{s\\}$。\n    *   对于所有其他节点 $n \\in V \\setminus \\{s\\}$，将其支配节点集初始化为图中的所有节点集合：$\\mathrm{dom}(n) \\leftarrow V$。这代表了最保守的初始假设。\n\n2.  **迭代**：\n    *   重复遍历所有节点 $n \\in V \\setminus \\{s\\}$，并使用上述方程重新计算它们的支配节点集，直到在一次完整的遍历中没有任何 $\\mathrm{dom}(n)$ 集合发生变化。这个状态就是不动点。\n    *   设 $\\mathrm{dom}_{\\text{old}}(n)$ 为一次迭代开始时节点 $n$ 的支配节点集。新的集合计算如下：\n        $$\n        \\mathrm{dom}_{\\text{new}}(n) \\leftarrow \\{n\\} \\cup \\left( \\bigcap_{p \\in \\mathrm{pred}(n)} \\mathrm{dom}_{\\text{old}}(p) \\right)\n        $$\n    *   可以使用一个布尔标志 `changed` 来跟踪在一次迭代中是否有任何集合 $\\mathrm{dom}(n)$ 被修改。当 `changed` 在对所有节点的一次完整遍历后保持为假时，循环终止。\n\n这个迭代过程保证会收敛，因为集合的域是一个有限格（$V$ 的幂集），并且交集运算是单调的，这使得支配节点集在每次迭代中只会缩小（或保持不变）。\n\n#### **1.2. 回边识别**\n\n一条有向边 $(t, h) \\in E$ 被定义为**回边**，当且仅当它的头节点 $h$ 支配它的尾节点 $t$。\n在计算完图中所有节点的支配节点集后，这个检查就是一个简单的集合成员测试：\n\n*   如果 $h \\in \\mathrm{dom}(t)$，则边 $(t, h)$ 是一条回边。\n*   如果不满足此条件，则 $(t, h)$ 不是回边，问题规定输出应为空集 $\\emptyset$。\n\n#### **1.3. 自然循环计算**\n\n如果 $(t, h)$ 被识别为回边，则计算其自然循环 $L(h)$。问题提供了一个构造性定义：\n$$\nL(h) = \\{ h \\} \\cup \\{ n \\in V \\mid \\exists \\text{ a path } n \\leadsto t \\text{ in } G \\text{ that avoids } h \\}\n$$\n这个定义规定，自然循环由头节点 $h$ 本身，以及所有能通过不经过 $h$ 的路径到达尾节点 $t$ 的节点组成。短语“避开 $h$”意味着 $h$ 不作为从 $n$ 到 $t$ 路径上的中间节点出现。\n\n这个节点集可以通过从节点 $t$ 开始，在图 $G$ 上执行后向可达性搜索来找到。该搜索反向遍历边（即从一个节点到其前驱），并且不能“穿过”$h$。\n\n算法如下：\n\n1.  **初始化**：\n    *   将循环节点集 `loop_nodes` 初始化为 $\\{h\\}$。\n    *   初始化一个工作列表（例如，用于图遍历的栈或队列），`worklist`，并将 $t$ 添加进去。\n    *   将 $t$ 标记为“已访问”以避免重复处理。如果 $t \\neq h$，则将 $t$ 添加到 `loop_nodes`。如果 $t=h$，它已在该集合中。\n\n2.  **后向遍历**：\n    *   当 `worklist` 不为空时：\n        *   从 `worklist` 中取出一个节点 $m$。\n        *   对于 $m$ 的每个前驱 $p \\in \\mathrm{pred}(m)$：\n            *   如果节点 $p$ 尚未被添加到 `loop_nodes` 中（因此尚未被访问），则将 $p$ 添加到 `loop_nodes`，将其标记为已访问，并将其添加到 `worklist` 中。这里的隐含条件是 $p \\neq h$，因为如果 $p=h$，它在初始化时就已经在 `loop_nodes` 中，检查会失败。这正确地在头节点 $h$ 处“停止”了后向搜索。\n\n3.  **最终确定**：\n    *   最终得到的集合 `loop_nodes` 就是自然循环 $L(h)$。\n    *   对于最终输出，此集合的元素必须按升序排序。\n\n### **2. 正确性证明**\n\n整个过程的正确性取决于其三个组成部分的正确性。\n\n*   **支配节点算法**：用于计算支配节点的迭代不动点算法的正确性是数据流分析中的一个标准结论。递推关系 $\\mathrm{dom}(n) = \\{n\\} \\cup \\bigcap_{p \\in \\mathrm{pred}(n)} \\mathrm{dom}(p)$ 直接形式化了支配的定义。从一个保守状态 ($V$) 开始，在 $V$ 的子集构成的有限格上迭代应用此规则，保证能收敛到最大不动点，这正是支配关系集。\n\n*   **回边识别**：该算法测试 $h \\in \\mathrm{dom}(t)$ 是否成立。这是所提供的回边定义的直接实现。因此，其正确性是不言而喻的。\n\n*   **自然循环计算**：我们必须证明由后向遍历算法生成的集合（我们称之为 $A$）与定义的集合 $L(h) = \\{ h \\} \\cup B$ 等价，其中 $B = \\{ n \\in V \\mid \\exists \\text{ a path } n \\leadsto t \\text{ that avoids } h \\}$。\n\n    该算法用 $\\{h\\}$ 初始化一个集合 `loop_nodes`，然后从 $t$ 开始执行后向搜索。设 $B'$ 是此次搜索访问的所有节点（包括 $t$）的集合。算法生成的最终集合是 $A = \\{h\\} \\cup B'$。我们需要证明 $B' = B$。\n\n    1.  **证明 $B' \\subseteq B$**：\n        设 $n$ 是 $B'$ 中的任意节点。这意味着从 $t$ 开始的后向搜索到达了 $n$。该搜索构造了一个节点序列 $(v_0, v_1, \\dots, v_k)$，其中 $v_0 = t$，$v_k = n$，并且对于每个 $i \\in \\{1, \\dots, k\\}$，$v_i \\in \\mathrm{pred}(v_{i-1})$。此外，搜索逻辑确保对于所有 $i \\in \\{1, \\dots, k\\}$，$v_i \\neq h$。将此序列反转，得到原图中的一条路径：$n = v_k \\to v_{k-1} \\to \\dots \\to v_1 \\to v_0 = t$。此路径上的中间节点是 $\\{v_1, \\dots, v_{k-1}\\}$。由于所有这些节点都不是 $h$，所以这条路径“避开了 $h$”。因此，$n \\in B$。由于这对任何 $n \\in B'$ 都成立，我们有 $B' \\subseteq B$。\n\n    2.  **证明 $B \\subseteq B'$**：\n        设 $n$ 是 $B$ 中的任意节点。根据定义，存在一条路径 $P: n \\leadsto t$ 避开 $h$。设此路径为 $P = (v_k, v_{k-1}, \\dots, v_1, v_0)$，其中 $v_k = n$，$v_0 = t$，并且对于所有 $i \\in \\{1, \\dots, k-1\\}$，$v_i \\neq h$。集合 $B$ 的定义可以解释为对于任何非平凡路径，$n \\neq h$。如果 $n=t$，路径长度为 0，$t$ 自然在 $B$ 中，也（作为搜索的起点）在 $B'$ 中。假设 $n \\neq t$。后向搜索从 $t=v_0$ 开始，并将其添加到工作列表中。然后它将探索前驱。由于 $(v_1, v_0) \\in E$，则 $v_1 \\in \\mathrm{pred}(v_0)$。因为 $v_1$ 是避开 $h$ 的路径上的一个中间节点，所以 $v_1 \\ne h$。因此，搜索将访问 $v_1$。通过归纳法，对于任何 $i \\in \\{1, \\dots, k\\}$，由于 $v_i \\in \\mathrm{pred}(v_{i-1})$ 且 $v_i \\ne h$（无论是作为中间节点还是因为 $n \\neq h$），搜索在访问了 $v_{i-1}$ 之后最终会到达 $v_i$。最终，搜索将到达 $v_k=n$。因此，$n \\in B'$。由于这对任何 $n \\in B$ 都成立，我们有 $B \\subseteq B'$。\n\n    由 $B' \\subseteq B$ 和 $B \\subseteq B'$ 可得 $B' = B$。该算法正确地计算了不经过 $h$ 就能到达 $t$ 的节点集合，最终结果是该集合与 $\\{h\\}$ 的并集，这正是 $L(h)$ 的定义。该算法是正确的。",
            "answer": "[[2, 3], [3, 4, 5], [3, 5, 6], [], [1]]"
        }
    ]
}