{
    "hands_on_practices": [
        {
            "introduction": "优化的首要原则是正确性。循环外提（loop unswitching）虽然看似只是将循环不变的条件判断移出循环，但必须小心处理循环体内的控制流。本练习  挑战你追踪程序的执行路径，特别是 `continue` 语句如何改变执行流程，以确保转换后的代码在语义上与原始代码完全等价。这个实践旨在强调在进行任何代码重构时，维护程序原始逻辑的至关重要性。",
            "id": "3654403",
            "problem": "考虑一个具有类似 C 语言控制流语义的命令式语言中的以下循环。分支上的条件是循环不变的，意味着它在循环的迭代中不会改变，并且没有异常出口（没有异常或非局部 goto）。continue 语句的语义如下：在循环内部遇到时，执行会立即跳转到循环的更新表达式，然后到下一次迭代的循环头测试。\n\n原始循环：\nfor (int $i$ = $0$; $i$  $N$; ++$i$) {\n  if ($flag$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  } else {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n  }\n  $S_3(i)$;\n  $T(i)$;\n}\n\n假设如下：\n- 布尔值 $flag$ 是循环不变的：它在循环内不被修改，因此对于每次迭代 $i$，其值都是相同的。\n- 函数和语句 $A(i)$、$B(i)$、$logA(i)$、$logB(i)$、$S_1(i)$、$S_2(i)$、$S_3(i)$ 和 $T(i)$ 可能有副作用，但不会改变 $i$、$N$ 或 $flag$，也不会导致异常控制流。\n- 循环体唯一的提前退出是通过所示的 continue 语句。\n- 没有会因复制循环体而被违反的数据依赖（例如，没有对共享循环不变状态的写操作，这种写操作会因循环判断外提而被错误地复制）。\n\n循环判断外提（Loop unswitching）是一种转换，它通过复制循环并将专门化版本置于不变条件的每个分支下，从而将循环不变条件从循环中提升出来。该转换必须保留由 continue 语句所隐含的每次迭代的控制流和副作用顺序。以下哪个转换后的程序正确地应用了循环判断外提，从而对于所有的 $N$ 和 $flag$ 的两种值都能保留原始语义？\n\nA)\nif ($flag$) {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n}\n\nB)\nif ($flag$) {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    $S_3(i)$;\n    $T(i)$;\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    $S_3(i)$;\n    $T(i)$;\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n  }\n}\n\nC)\nfor (int $i$ = $0$; $i$  $N$; ++$i$) {\n  if ($flag$) {\n    if ($A(i)$) { $logA(i)$; }  // continue 已移除\n    $S_1(i)$;\n  } else {\n    if ($B(i)$) { $logB(i)$; }  // continue 已移除\n    $S_2(i)$;\n  }\n  $S_3(i)$;\n  $T(i)$;\n}\n\nD)\nif ($flag$) {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n  }\n}\n// $S_3(i)$ 和 $T(i)$ 在外提判断后的循环之外执行（缺少每次迭代的放置）\n\n选择在循环判断外提下保留原始的每次迭代语义的选项，包括正确处理由 continue 引起的提前退出和副作用顺序。",
            "solution": "用户提供了一个关于称为循环判断外提（loop unswitching）的编译器优化问题。任务是验证问题陈述，如果有效，则确定所提出的代码转换中哪一个能正确保留原始循环的语义。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n问题提供了以下内容：\n- **原始循环代码：**\n  ```c\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($flag$) {\n      if ($A(i)$) { $logA(i)$; continue; }\n      $S_1(i)$;\n    } else {\n      if ($B(i)$) { $logB(i)$; continue; }\n      $S_2(i)$;\n    }\n    $S_3(i)$;\n    $T(i)$;\n  }\n  ```\n- **控制流语义：**\n    - 语言是类 C 的。\n    - `continue` 使执行跳转到循环更新（`++$i$`），然后是循环测试（`$i$  $N$`），跳过当前迭代中循环体的剩余部分。\n- **假设：**\n    - 布尔变量 `$flag$` 是循环不变的（其值在整个循环执行过程中是恒定的）。\n    - 函数和语句 `$A(i)$、$B(i)$、$logA(i)$、$logB(i)$、$S_1(i)$、$S_2(i)$、$S_3(i)$、$T(i)$` 可能有副作用，但不修改 `$i$`、`$N$` 或 `$flag$`。\n    - 除了指定的 `continue` 语句外，没有异常控制流（例如异常、`goto`）。\n    - 循环复制不会违反数据依赖。\n- **核心任务：**\n    - 循环判断外提被定义为通过复制循环将循环不变条件从循环中提升出来。\n    - 正确的转换必须保留每次迭代的控制流和副作用顺序。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题陈述进行评估。\n- **科学依据：** 该问题设置在编译器优化的背景下，这是计算机科学的一个标准主题。循环判断外提是一项成熟的技术。类 C 的语义被精确定义。该问题在科学上和事实上都是合理的。\n- **适定性：** 问题要求在一组选项中确定哪种转换在语义上等同于原始代码。这是一个定义明确的问题，基于对程序控制流的逻辑分析，有唯一正确的答案。\n- **客观性：** 问题以代码和明确的语义规则陈述。正确性标准——保留语义——是客观且可验证的。\n- **完整性和一致性：** 问题提供了所有必要的信息：原始代码、执行规则（`continue` 语义）和关键假设（`$flag$` 的循环不变性、某些副作用的缺失）。设置是自洽且无矛盾的。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。它是编译器原理领域中一个形式良好的问题。可以继续进行求解过程。\n\n### 推导与选项分析\n\n基本任务是追踪原始循环单次迭代的执行路径，并确保转换后的代码能完全复制它。\n\n**原始循环分析**\n\n让我们分析任意一次迭代 `$i$` 的操作序列。\n1. 对循环不变条件 `if ($flag$)`进行求值。\n2. **情况 `$flag$` 为真：**\n   - 对条件 `$A(i)$` 进行求值。\n   - 如果 `$A(i)$` 为真，则执行 `$logA(i)$`，并触发 `continue` 语句。这会立即跳过 `$S_1(i)$、$S_3(i)$ 和 $T(i)$` 的执行。循环进入下一次迭代 (`++$i$`)。\n   - 如果 `$A(i)$` 为假，则执行 `$S_1(i)$`，然后执行 `$S_3(i)$` 和 `$T(i)$`。循环随后进入下一次迭代。\n    *`$flag$` 为真时总结：*\n      - 路径1：`$A(i)$` 为真 $\\implies$ 执行 `$logA(i)$`。\n      - 路径2：`$A(i)$` 为假 $\\implies$ 执行 `$S_1(i), S_3(i), T(i)$`。\n3. **情况 `$flag$` 为假：**\n   - 对条件 `$B(i)$` 进行求值。\n   - 如果 `$B(i)$` 为真，则执行 `$logB(i)$`，并触发 `continue` 语句。这会立即跳过 `$S_2(i)$、$S_3(i)$ 和 $T(i)$` 的执行。循环进入下一次迭代。\n   - 如果 `$B(i)$` 为假，则执行 `$S_2(i)$`，然后执行 `$S_3(i)$` 和 `$T(i)$`。循环随后进入下一次迭代。\n    *`$flag$` 为假时总结：*\n      - 路径1：`$B(i)$` 为真 $\\implies$ 执行 `$logB(i)$`。\n      - 路径2：`$B(i)$` 为假 $\\implies$ 执行 `$S_2(i), S_3(i), T(i)$`。\n\n**循环判断外提转换**\n\n该转换将 `if ($flag$)` 移出循环，创建两个专门化的循环。\n\n- **`if` 分支（对于 `$flag$` 为真）：** 循环体应只包含当 `$flag$` 为真时执行的代码。根据我们的分析，这是：\n  ```c\n  if ($A(i)$) { $logA(i)$; continue; }\n  $S_1(i)$;\n  $S_3(i)$;\n  $T(i)$;\n  ```\n  这是因为 `$S_3(i)$` 和 `$T(i)$` 是所有不执行 `continue` 的路径所共有的。\n\n- **`else` 分支（对于 `$flag$` 为假）：** 循环体应只包含当 `$flag$` 为假时执行的代码。根据我们的分析，这是：\n  ```c\n  if ($B(i)$) { $logB(i)$; continue; }\n  $S_2(i)$;\n  $S_3(i)$;\n  $T(i)$;\n  ```\n\n将这些组合到外提判断的结构中，得到以下正确的转换：\n```c\nif ($flag$) {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n}\n```\n\n现在，我们将每个提供的选项与这个推导出的正确转换进行评估。\n\n**逐项选项分析**\n\n**A)**\n```c\nif ($flag$) {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n}\n```\n此代码与从第一原理推导出的转换完全匹配。对于 `$flag$` 为真的情况，如果 `$A(i)$` 为真，它正确执行 `$logA(i)$` 并跳过其余部分，否则执行 `$S_1(i), S_3(i), T(i)$`。对于 `$flag$` 为假的情况，它对 `$B(i)$` 和 `$S_2(i)$` 也做了同样正确的处理。对于所有情况，控制流和副作用顺序都得以保留。\n**结论：正确。**\n\n**B)**\n```c\nif ($flag$) {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    $S_3(i)$;\n    $T(i)$;\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  }\n} // ... else 分支类似\n```\n此转换错误地重排了语句。在原始循环中，如果 `$flag$` 为真且 `$A(i)$` 为真，`$S_3(i)$` 和 `$T(i)$` *不会*被执行。在此转换后的代码中，`$S_3(i)$` 和 `$T(i)$` 在每次迭代开始时无条件执行。这违反了原始程序的语义。\n**结论：不正确。**\n\n**C)**\n```c\nfor (int $i$ = $0$; $i$  $N$; ++$i$) {\n  if ($flag$) {\n    if ($A(i)$) { $logA(i)$; }  // continue 已移除\n    $S_1(i)$;\n  } // ... else 分支类似\n  $S_3(i)$;\n  $T(i)$;\n}\n```\n这不是循环判断外提；这是对原始循环的修改，其中 `continue` 语句被移除了。在原始循环中，如果 `$flag$` 为真且 `$A(i)$` 为真，`continue` 会阻止 `$S_1(i)$、$S_3(i)$ 和 `$T(i)$` 的执行。在这个修改后的代码中，无论 `$A(i)$` 的值如何，所有这些语句都会被执行。这显著地改变了控制流。\n**结论：不正确。**\n\n**D)**\n```c\nif ($flag$) {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i$  $N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n  }\n}\n// S_3(i) 和 T(i) 在外提判断后的循环之外执行...\n```\n此转换从复制的循环内部省略了语句 `$S_3(i)$` 和 `$T(i)$`。在原始代码中，`$S_3(i)$` 和 `$T(i)$` 在每次未触发 `continue` 的迭代中都会执行。通过将它们从循环体中移除，此转换未能保留原始程序的行为和副作用。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在确保了正确性之后，我们来探讨循环外提的性能优势。循环外提的一个主要好处是改善数据局部性，从而提高缓存效率。本练习  提供了一个矩阵乘法的具体场景，其中一个循环不变条件决定了内存访问模式。通过循环外提，我们可以为行主序（缓存友好）和列主序（缓存不友好）的访问分别生成专门的循环，并量化这两种情况下的缓存未命中差异。",
            "id": "3654402",
            "problem": "考虑维度为 $n \\times n$ 的方阵 $A$、$B$ 和 $C$。它们以连续的行主序布局存储在主内存中，每个元素占用 $w$ 字节。要执行的计算是由三层嵌套循环 $(i,k,j)$ 定义的矩阵乘积累加：对于每个固定的 $i$，对于每个 $k$，根据一个循环不变的标志 $t$（指示 $A$ 是否已预转置）从 $A$ 中读取一个标量，然后使用 $B$ 的整个第 $k$ 行来更新 $C$ 的第 $i$ 行中的所有条目。具体来说，对于每对 $(i,k)$，当 $t$ 为假（未转置）时，代码读取 $A[i][k]$；当 $t$ 为真（已转置）时，代码读取 $A[k][i]$。该值被绑定到一个标量，然后在内部的 $j$ 循环中重复使用，并对 $\\{0,1,\\dots,n-1\\}$ 中的所有 $j$ 进行累加 $C[i][j] \\leftarrow C[i][j] + a \\cdot B[k][j]$。\n\n关于 $t$ 的分支相对于 $i$、$k$ 和 $j$ 循环是循环不变的。应用称为循环外提 (loop unswitching) 的变换，为计算生成两个专门化版本：一个用于 $t=\\text{false}$ 的情况，另一个用于 $t=\\text{true}$ 的情况。使用以下缓存模型和假设来估计仅由读取 $A$ 引起的缓存行为：\n\n- 处理器有一个一级 (L1) 缓存，该缓存是全相联的，采用最近最少使用 (LRU) 替换策略，缓存行大小为 $L$ 字节。\n- 令 $p = L/w$ 表示一个缓存行可以容纳的矩阵元素数量；假设 $p$ 是一个正整数，且 $n$ 是 $p$ 的整数倍。\n- 对于给定的 $(i,k)$ 读取的每个 $A$ 元素，在整个内部 $j$ 循环中都会被重用，而无需额外加载 $A$。但是，由于对 $B$ 的流式访问和对 $C$ 的更新，不同 $(i,k)$ 对之间对 $A$ 行的重用可以忽略不计。因此，在给定的外部循环迭代 $i$ 中，当首次访问 $A$ 的某一行中的任何元素时，计为一次缓存行填充，并且不计算进一步的跨迭代重用。\n- 不包括来自 $B$ 或 $C$ 的任何缓存行为；只计算由访问 $A$ 引起的缓存行填充。\n\n从行主序寻址的定义和循环外提的基本属性出发，推导在每个专门化版本（$t=\\text{false}$ 和 $t=\\text{true}$）中，整个计算过程中由读取 $A$ 引起的一级缓存行填充总数，然后为这些总数之间的差值提供一个单一的封闭形式解析表达式，定义为\n$$\\Delta = \\text{fills}_{t=\\text{true}} - \\text{fills}_{t=\\text{false}}.$$\n\n用 $n$ 和 $p$ 表示您的最终答案。不需要进行数值计算；请提供精确的解析表达式。",
            "solution": "所述问题是有效的。它在科学上基于计算机体系结构和编译器优化的原理，特别是缓存行为分析和循环变换。该问题定义明确，具有所有必要的参数（$n$、$p$）、清晰的计算模型和明确的目标。语言是客观的，其假设虽然进行了简化，但是明确且一致的。\n\n核心任务是分析因循环外提产生的两种不同情况下访问矩阵 $A$ 时的缓存行填充次数。循环外提是一种编译器优化技术，它将循环不变的条件分支移到循环外部，并在分支的每个路径内复制循环体。\n\n原始的循环结构是：\n`for i = 0 to n-1:`\n  `for k = 0 to n-1:`\n    `if t:`\n      `a = A[k][i]`\n    `else:`\n      `a = A[i][k]`\n    `for j = 0 to n-1:`\n      `C[i][j] += a * B[k][j]`\n\n对循环不变标志 $t$ 应用循环外提会产生两个独立的代码块：\n\n情况1：$t=\\text{false}$\n`for i = 0 to n-1:`\n  `for k = 0 to n-1:`\n    `a = A[i][k]`\n    `for j = 0 to n-1:`\n      `C[i][j] += a * B[k][j]`\n\n情况2：$t=\\text{true}$\n`for i = 0 to n-1:`\n  `for k = 0 to n-1:`\n    `a = A[k][i]`\n    `for j = 0 to n-1:`\n      `C[i][j] += a * B[k][j]`\n\n现在，我们将根据提供的缓存模型，分析每种情况下从矩阵 $A$ 读取数据所产生的缓存行填充次数。矩阵以连续的行主序布局存储。元素 $A[r][c]$ 的内存地址可以表示为 $\\text{Addr}(A[r][c]) = \\text{Addr}(A[0][0]) + (r \\cdot n + c) \\cdot w$，其中 $w$ 是每个元素的字节大小。\n\n一个缓存行的大小为 $L$ 字节，包含 $p = L/w$ 个元素。问题规定我们必须根据以下规则计算缓存填充：“在给定的外部循环迭代 $i$ 中，当首次访问 $A$ 的某一行中的任何元素时，计为一次缓存行填充，并且不计算进一步的跨迭代重用。” 这意味着我们对外部 $i$ 循环的每次迭代的分析是独立的，我们将每次迭代的填充次数相加。\n\n**$t=\\text{false}$ 情况分析（非转置访问）**\n\n在这种情况下，对矩阵 $A$ 的访问模式是 $A[i][k]$。对于访问 $A$ 的循环，其顺序是 $i$ 作为外层循环，$k$ 作为内层循环。\n对于固定的外层循环索引 $i$，内层循环 `for k = 0 to n-1` 访问元素 $A[i][0], A[i][1], \\dots, A[i][n-1]$。\n这个访问序列对应于对矩阵 $A$ 的第 $i$ 行进行顺序扫描。由于矩阵是行主序布局，这些元素在内存中是连续的。\n当访问 $A[i][0]$ 时，会发生一次缓存未命中，包含该行前 $p$ 个元素（从 $A[i][0]$ 到 $A[i][p-1]$）的缓存行被加载。这算作 1 次缓存行填充。\n后续的 $p-1$ 次访问，即对 $A[i][1], \\dots, A[i][p-1]$ 的访问，将是缓存命中。\n下一次访问，即对 $A[i][p]$ 的访问，将导致另一次缓存未命中，加载该行的第二个缓存行。这个过程会持续遍历整行。\n由于一行包含 $n$ 个元素，每个缓存行容纳 $p$ 个元素，并且 $n$ 是 $p$ 的整数倍，因此构成单行的缓存行数量恰好是 $\\frac{n}{p}$。\n因此，对于外层循环的每次迭代（对于每个固定的 $i$），访问 $A$ 的一整行会导致 $\\frac{n}{p}$ 次缓存行填充。\n\n根据指定的计数规则，我们将外层循环的所有迭代（从 $i=0$ 到 $i=n-1$）的填充次数相加。\n总填充次数为：\n$$ \\text{fills}_{t=\\text{false}} = \\sum_{i=0}^{n-1} \\frac{n}{p} = n \\cdot \\frac{n}{p} = \\frac{n^2}{p} $$\n\n**$t=\\text{true}$ 情况分析（转置访问）**\n\n在这种情况下，对矩阵 $A$ 的访问模式是 $A[k][i]$。\n对于固定的外层循环索引 $i$，内层循环 `for k = 0 to n-1` 访问元素 $A[0][i], A[1][i], \\dots, A[n-1][i]$。\n这个访问序列对应于对矩阵 $A$ 的第 $i$ 列进行扫描。\n我们来检查这个序列中两个连续访问的内存位置：$A[k][i]$ 和 $A[k+1][i]$。\n$\\text{Addr}(A[k][i]) = \\text{Addr}(A[0][0]) + (k \\cdot n + i) \\cdot w$\n$\\text{Addr}(A[k+1][i]) = \\text{Addr}(A[0][0]) + ((k+1) \\cdot n + i) \\cdot w$\n它们的地址差为：\n$$ \\Delta \\text{Addr} = ((k+1)n + i)w - (kn + i)w = nw $$\n连续内存访问之间的步长是 $n \\cdot w$ 字节。\n一个缓存行的大小是 $L = p \\cdot w$ 字节。\n问题陈述 $n$ 是 $p$ 的倍数，这意味着 $n \\ge p$。因此，步长 $n \\cdot w$ 大于或等于缓存行大小 $p \\cdot w$。这意味着列访问序列 $A[0][i], A[1][i], \\dots, A[n-1][i]$ 中的每个元素都位于不同的缓存行中。\n\n为了更严谨，我们来分析元素 $A[k][i]$ 的缓存行索引。为简单起见，假设矩阵基地址为 $0$，地址 $(kn+i)w$ 的缓存行索引为 $\\lfloor \\frac{(kn+i)w}{L} \\rfloor = \\lfloor \\frac{kn+i}{p} \\rfloor$。\n由于 $n$ 是 $p$ 的倍数，我们可以写成 $n = m \\cdot p$，其中 $m \\ge 1$ 是一个整数。\n$A[k][i]$ 的行索引是 $\\lfloor \\frac{k(mp)+i}{p} \\rfloor = \\lfloor km + \\frac{i}{p} \\rfloor = km + \\lfloor \\frac{i}{p} \\rfloor$。\n对于固定的 $i$，随着 $k$ 的增加，项 $km$ 确保从 $0$ 到 $n-1$ 的每个 $k$ 值都会产生一个唯一的缓存行索引。具体来说，如果 $k_1 \\ne k_2$，那么 $A[k_1][i]$ 和 $A[k_2][i]$ 的行索引将会不同。\n因此，在内层 $k$ 循环中的 $n$ 次访问，每次都会导致一次缓存未命中。\n对于外层循环的每次迭代（对于每个固定的 $i$），有 $n$ 次缓存行填充。\n\n将外层循环的所有迭代（从 $i=0$ 到 $i=n-1$）相加：\n$$ \\text{fills}_{t=\\text{true}} = \\sum_{i=0}^{n-1} n = n \\cdot n = n^2 $$\n\n**计算差值**\n\n问题要求计算差值 $\\Delta = \\text{fills}_{t=\\text{true}} - \\text{fills}_{t=\\text{false}}$。\n代入推导出的表达式：\n$$ \\Delta = n^2 - \\frac{n^2}{p} $$\n将 $n^2$ 项提取出来，得到最终的解析表达式：\n$$ \\Delta = n^2 \\left(1 - \\frac{1}{p}\\right) $$\n这个表达式表示了从空间局部性访问模式（对行主序矩阵进行逐行访问）切换到非局部性访问模式（逐列访问）时，缓存未命中的增加量。",
            "answer": "$$ \\boxed{n^2 \\left(1 - \\frac{1}{p}\\right)} $$"
        },
        {
            "introduction": "循环外提的威力还在于它可以作为一种“使能”优化，为其他更强大的优化技术铺平道路。本练习  展示了如何通过循环外提移除循环内部的分支，使循环体变得统一，从而允许编译器应用强大的 SIMD（单指令多数据）矢量化技术。你将通过一个性能模型来计算预期的加速比，将代码转换与可量化的性能提升直接联系起来。",
            "id": "3654460",
            "problem": "一个图像处理循环遍历一幅图像，并为每个像素根据一个循环不变量 $colorSpace$ 来选择一个转换例程，该变量在进入循环前只设置一次。两种可能的例程实现了标准化的转换：\n- 如果 $colorSpace$ 是文本字符串 \"RGB\"，该例程使用公式 $Y = 0.2126 R + 0.7152 G + 0.0722 B$ 从红色、绿色和蓝色分量计算亮度 $Y$。\n- 如果 $colorSpace$ 是文本字符串 \"YCbCr\"，该例程直接使用 $Y$ 分量作为亮度，无需进行额外的算术运算。\n\n在基线实现中，$colorSpace$ 在循环体内对每个像素都会被检查，这阻碍了向量化，并为每次迭代增加了固定的分支开销。应用循环外提（loop unswitching）后，通过复制循环将分支提升到循环外部：一个专用于 \"RGB\" 的循环和一个专用于 \"YCbCr\" 的循环。这种转换使得对每个专用循环进行单指令多数据（SIMD）向量化成为可能。\n\n假设以下条件，所有条件均与一个以时钟周期为单位的简单吞吐量成本模型一致：\n- 基线（外提前）标量循环每次迭代产生 $c_b = 1$ 个时钟周期的分支开销，并且无法被向量化。\n- 标量操作成本为：每次乘法 $c_m = 1$ 个时钟周期，每次加法 $c_a = 1$ 个时钟周期，每次加载 $c_l = 1$ 个时钟周期，每次存储 $c_s = 1$ 个时钟周期。\n- 每个向量的 SIMD 向量化操作成本为：每次向量乘法 $c^{\\text{vec}}_m = 1$ 个时钟周期，每次向量加法 $c^{\\text{vec}}_a = 1$ 个时钟周期，每次向量加载 $c^{\\text{vec}}_l = 1$ 个时钟周期，每次向量存储 $c^{\\text{vec}}_s = 1$ 个时钟周期。\n- SIMD 宽度为 $w = 8$ 像素，图像尺寸为 $W = 2048$ 和 $H = 1024$，因此像素总数 $N = W \\cdot H$ 可被 $w$ 整除，不存在剩余循环。\n- 对于每个像素的 \"RGB\" 例程：有 $n_m = 3$ 次乘法和 $n_a = 2$ 次加法，以及 $n_l = 3$ 次加载（用于 $R$, $G$, $B$）和 $n_s = 1$ 次存储（用于 $Y$）。\n- 对于每个像素的 \"YCbCr\" 例程：有 $n_m = 0$ 次乘法和 $n_a = 0$ 次加法，以及 $n_l = 1$ 次加载（用于 $Y$）和 $n_s = 1$ 次存储（用于 $Y$）。\n- 经过循环外提后，分支不在像素循环内部执行；假设其一次性成本与 $N$ 相比可以忽略不计。\n- 在程序的不同运行中，$colorSpace$ 等于文本字符串 \"RGB\" 的概率为 $p = 0.6$；否则它等于文本字符串 \"YCbCr\" 的概率为 $1 - p$。\n\n仅使用循环不变性、循环外提（loop unswitching）的定义，以及一个针对加载、存储、乘法和加法的标准加性吞吐量模型（以时钟周期为单位），从第一性原理推导因循环外提及由此产生的 SIMD 向量化所带来的预期加速比 $S$ 的解析表达式。加速比定义为每像素的预期基线时钟周期数与每像素的预期外提后时钟周期数之比。在给定参数下对 $S$ 进行数值计算。将最终答案表示为一个无量纲实数，并四舍五入到四位有效数字。",
            "solution": "该问题要求推导因循环外提（loop unswitching）及随后的 SIMD 向量化所产生的预期加速比 $S$ 的解析表达式。加速比定义为基线实现中每像素的预期处理时间与优化实现中每像素的预期处理时间之比。我们将使用所提供的加性吞吐量成本模型从第一性原理进行推导。\n\n设 $C_{\\text{baseline}}$ 为基线实现中每像素的执行时间（以时钟周期为单位），$C_{\\text{optimized}}$ 为优化实现的时间。加速比 $S$ 是它们期望值的比值：\n$$S = \\frac{E[C_{\\text{baseline}}]}{E[C_{\\text{optimized}}]}$$\n期望 $E[\\cdot]$ 是对由 $colorSpace$ 变量的值决定的两条可能代码路径计算的，\"RGB\" 路径的概率为 $p$，“YCbCr” 路径的概率为 $1-p$。\n\n首先，我们确定基线实现的每像素预期成本 $E[C_{\\text{baseline}}]$。在这种情况下，循环包含一个为每个像素执行的条件分支，这会产生固定的开销 $c_b$ 并阻止向量化。处理过程是标量的。\n\n对于 \"RGB\" 路径，每像素的成本 $C_{\\text{baseline, RGB}}$ 是算术和内存操作的成本之和，再加上分支开销。操作次数给定为 $n_m = 3$ 次乘法，$n_a = 2$ 次加法，$n_l = 3$ 次加载和 $n_s = 1$ 次存储。标量成本为 $c_m = 1$，$c_a = 1$，$c_l = 1$ 和 $c_s = 1$。分支开销为 $c_b=1$。\n$$C_{\\text{baseline, RGB}} = (n_m \\cdot c_m + n_a \\cdot c_a + n_l \\cdot c_l + n_s \\cdot c_s) + c_b$$\n$$C_{\\text{baseline, RGB}} = (3 \\cdot 1 + 2 \\cdot 1 + 3 \\cdot 1 + 1 \\cdot 1) + 1 = (3 + 2 + 3 + 1) + 1 = 9 + 1 = 10 \\text{ 周期/像素}$$\n\n对于 \"YCbCr\" 路径，操作次数为 $n_m = 0$，$n_a = 0$，$n_l = 1$ 和 $n_s = 1$。每像素的成本 $C_{\\text{baseline, YCbCr}}$ 为：\n$$C_{\\text{baseline, YCbCr}} = (n_m \\cdot c_m + n_a \\cdot c_a + n_l \\cdot c_l + n_s \\cdot c_s) + c_b$$\n$$C_{\\text{baseline, YCbCr}} = (0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1) + 1 = (0 + 0 + 1 + 1) + 1 = 2 + 1 = 3 \\text{ 周期/像素}$$\n\n每像素的预期基线成本是这两个成本的加权平均，使用概率 $p=0.6$：\n$$E[C_{\\text{baseline}}] = p \\cdot C_{\\text{baseline, RGB}} + (1-p) \\cdot C_{\\text{baseline, YCbCr}}$$\n$$E[C_{\\text{baseline}}] = 0.6 \\cdot 10 + (1-0.6) \\cdot 3 = 6.0 + 0.4 \\cdot 3 = 6.0 + 1.2 = 7.2 \\text{ 周期/像素}$$\n\n接下来，我们确定优化实现的每像素预期成本 $E[C_{\\text{optimized}}]$。经过循环外提后，条件分支被提升出循环。两个产生的专用循环中的每一个都可以使用 SIMD 指令进行向量化，每个操作的宽度为 $w=8$ 像素。循环内的分支开销被消除了。\n\n对于 \"RGB\" 路径，向量化循环一次处理 $w$ 个像素。每个包含 $w$ 个像素的向量的成本 $C_{\\text{vec, RGB}}$ 是使用向量化操作成本计算的，这些成本均被给定为每次向量操作 $1$ 个时钟周期 ($c^{\\text{vec}}_m = c^{\\text{vec}}_a = c^{\\text{vec}}_l = c^{\\text{vec}}_s = 1$)。\n$$C_{\\text{vec, RGB}} = n_m \\cdot c^{\\text{vec}}_m + n_a \\cdot c^{\\text{vec}}_a + n_l \\cdot c^{\\text{vec}}_l + n_s \\cdot c^{\\text{vec}}_s$$\n$$C_{\\text{vec, RGB}} = 3 \\cdot 1 + 2 \\cdot 1 + 3 \\cdot 1 + 1 \\cdot 1 = 3 + 2 + 3 + 1 = 9 \\text{ 周期/向量}$$\n每像素的成本 $C_{\\text{optimized, RGB}}$ 是这个成本除以 SIMD 宽度 $w$：\n$$C_{\\text{optimized, RGB}} = \\frac{C_{\\text{vec, RGB}}}{w} = \\frac{9}{8} \\text{ 周期/像素}$$\n\n对于 \"YCbCr\" 路径，每个包含 $w$ 个像素的向量的成本 $C_{\\text{vec, YCbCr}}$ 为：\n$$C_{\\text{vec, YCbCr}} = n_m \\cdot c^{\\text{vec}}_m + n_a \\cdot c^{\\text{vec}}_a + n_l \\cdot c^{\\text{vec}}_l + n_s \\cdot c^{\\text{vec}}_s$$\n$$C_{\\text{vec, YCbCr}} = 0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 0 + 0 + 1 + 1 = 2 \\text{ 周期/向量}$$\n每像素的成本 $C_{\\text{optimized, YCbCr}}$ 为：\n$$C_{\\text{optimized, YCbCr}} = \\frac{C_{\\text{vec, YCbCr}}}{w} = \\frac{2}{8} = \\frac{1}{4} \\text{ 周期/像素}$$\n\n每像素的预期优化成本是这两个成本的加权平均：\n$$E[C_{\\text{optimized}}] = p \\cdot C_{\\text{optimized, RGB}} + (1-p) \\cdot C_{\\text{optimized, YCbCr}}$$\n$$E[C_{\\text{optimized}}] = 0.6 \\cdot \\frac{9}{8} + (1-0.6) \\cdot \\frac{2}{8} = \\frac{0.6 \\cdot 9 + 0.4 \\cdot 2}{8} = \\frac{5.4 + 0.8}{8} = \\frac{6.2}{8} = 0.775 \\text{ 周期/像素}$$\n\n现在我们可以构造加速比 $S$ 的完整解析表达式：\n$$S = \\frac{p \\cdot C_{\\text{baseline, RGB}} + (1-p) \\cdot C_{\\text{baseline, YCbCr}}}{p \\cdot C_{\\text{optimized, RGB}} + (1-p) \\cdot C_{\\text{optimized, YCbCr}}}$$\n$$S = \\frac{p \\cdot ((n_{m}^{\\text{RGB}} c_m + \\dots) + c_b) + (1-p) \\cdot ((n_{m}^{\\text{YCbCr}} c_m + \\dots) + c_b)}{p \\cdot \\frac{1}{w}(n_{m}^{\\text{RGB}} c_m^{\\text{vec}} + \\dots) + (1-p) \\cdot \\frac{1}{w}(n_{m}^{\\text{YCbCr}} c_m^{\\text{vec}} + \\dots)}$$\n此表达式表示从第一性原理推导出的通用公式。\n\n最后，我们代入计算出的预期成本来求 $S$ 的数值：\n$$S = \\frac{E[C_{\\text{baseline}}]}{E[C_{\\text{optimized}}]} = \\frac{7.2}{0.775}$$\n$$S = \\frac{7.2}{0.775} = \\frac{7200}{775} = \\frac{1440}{155} = \\frac{288}{31} \\approx 9.29032258...$$\n四舍五入到四位有效数字，加速比为 $9.290$。",
            "answer": "$$\n\\boxed{9.290}\n$$"
        }
    ]
}