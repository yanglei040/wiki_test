{
    "hands_on_practices": [
        {
            "introduction": "The first and most critical question a compiler must answer before applying a transformation is whether it is *correct*. For loop fusion, correctness hinges on preserving the program's original data dependencies. This exercise  challenges you to apply fundamental dependence analysis—Read-After-Write (RAW), Write-After-Read (WAR), and Write-After-Write (WAW)—to determine if fusing a producer-consumer loop pair is legal and how to handle statement reordering.",
            "id": "3652559",
            "problem": "Consider arrays $A$ and $B$ of length $N$, and two loops over the common iteration space $i \\in \\{0,1,\\dots,N-1\\}$:\n- Loop $1$: for each $i$, assign $A[i] \\leftarrow i$.\n- Loop $2$: for each $i$, assign $B[A[i]] \\leftarrow i$.\n\nAssume sequential program semantics where each statement in program order observes the effects of all earlier statements, and assume $A$ and $B$ refer to disjoint memory regions. You are asked to evaluate the legality of loop fusion and the need for temporaries under the following reasoning bases:\n- The definitions of data dependences: a Read-After-Write (RAW) or true dependence exists when a statement $S_2$ reads a memory location previously written by a statement $S_1$; a Write-After-Read (WAR) or anti-dependence exists when $S_2$ writes a location previously read by $S_1$; and a Write-After-Write (WAW) or output dependence exists when both $S_1$ and $S_2$ write the same location. Correct transformations must preserve all true dependences and avoid creating behavior-changing anti- or output dependences.\n- The definition of loop fusion: combining two loops with the same iteration space into a single loop over that space, preserving sequential semantics.\n\nConsider fusing Loop $1$ and Loop $2$ into a single loop and analyze whether fusion causes a Write-After-Read hazard and whether temporaries are needed if statement reordering is desired. Select all correct statements:\n\nA. Fusing into a single loop with the per-iteration order $A[i] \\leftarrow i$ followed by $B[A[i]] \\leftarrow i$ is legal and does not introduce a Write-After-Read hazard; no temporary is required under the stated assumptions.\n\nB. Fusion is illegal because the fused body necessarily introduces a Write-After-Read hazard on $A[i]$ even if $A[i] \\leftarrow i$ is executed before $B[A[i]] \\leftarrow i$.\n\nC. Fusion is legal, and if one wishes to reorder the fused body to execute the $B$ update before updating $A$, introducing a temporary $t$ as $t \\leftarrow i$ and using $B[t] \\leftarrow i$ together with $A[i] \\leftarrow t$ eliminates any anti-dependence on $A[i]$ while preserving the original semantics.\n\nD. Fusion creates an output dependence on $B$ across iterations that makes the transformation unsafe unless $A$ is strictly monotonic; therefore, it is unsafe for $A[i]=i$.",
            "solution": "The user wants me to validate and solve a problem concerning loop fusion and data dependence analysis in compiler theory.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   Arrays: $A$ and $B$ of length $N$.\n-   Iteration space: $i \\in \\{0, 1, \\dots, N-1\\}$.\n-   Loop $1$: For each $i$, assign $A[i] \\leftarrow i$. Let this statement in iteration $i$ be $S_{1,i}$.\n-   Loop $2$: For each $i$, assign $B[A[i]] \\leftarrow i$. Let this statement in iteration $i$ be $S_{2,i}$.\n-   Program semantics: Sequential, effects of earlier statements are visible to later ones.\n-   Memory regions: $A$ and $B$ are disjoint.\n-   Reasoning bases:\n    -   Data dependences: Read-After-Write (RAW, true), Write-After-Read (WAR, anti), Write-After-Write (WAW, output).\n    -   Correctness criteria: Transformations must preserve all true dependences and avoid creating behavior-changing anti- or output dependences.\n    -   Loop fusion: Combining two loops with the same iteration space into one.\n-   Task: Analyze the legality of fusing Loop $1$ and Loop $2$ and the need for temporaries.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientifically Grounded:** The problem is firmly rooted in the well-established field of compiler optimization, specifically dependence analysis and loop transformations. The concepts of data dependences (RAW, WAR, WAW) and loop fusion are standard topics in computer science and engineering curricula. The problem is scientifically and factually sound.\n-   **Well-Posed:** The problem is clearly defined. The initial state (two sequential loops), the transformation (loop fusion), and the criteria for correctness (dependence preservation) are all explicitly given. A definite answer regarding the legality of fusion and the properties of the transformed code can be derived.\n-   **Objective:** The problem statement is phrased in precise, technical language, free from any subjective or ambiguous terms.\n-   **Completeness and Consistency:** The problem is self-contained. All necessary information (loop bounds, loop bodies, memory disjointness) is provided. There are no internal contradictions.\n-   **Other Flaws:** The problem does not exhibit any other flaws such as being unrealistic, ill-posed, trivial, or unverifiable. It is a standard, non-trivial exercise in applying compiler principles.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. I will proceed to derive the solution.\n\n### Solution Derivation\n\nFirst, we analyze the data dependences in the original, unfused program.\n-   Loop $1$ (for $i \\in \\{0, \\dots, N-1\\}$): $S_{1,i}: A[i] \\leftarrow i$. This loop writes to the array $A$. After its completion, $A[i]$ holds the value $i$ for all $i$ in the iteration space.\n-   Loop $2$ (for $i \\in \\{0, \\dots, N-1\\}$): $S_{2,i}: B[A[i]] \\leftarrow i$. This loop reads from array $A$ and writes to array $B$.\n\nThe crucial dependence is between the loops. For any given index $k \\in \\{0, \\dots, N-1\\}$, the statement $S_{1,k}$ writes to $A[k]$, and the statement $S_{2,k}$ reads from $A[k]$. Since Loop $1$ executes entirely before Loop $2$, $S_{2,k}$ reads the value written by $S_{1,k}$. This constitutes a Read-After-Write (RAW), or true, dependence from $S_{1,k}$ to $S_{2,k}$. Any legal transformation must preserve this set of dependences for all $k$.\n\nIn the original program, since $A[k]$ becomes $k$ after Loop $1$, Loop $2$ effectively executes $B[k] \\leftarrow k$ for all $k \\in \\{0, \\dots, N-1\\}$. The final state is $A[i]=i$ and $B[i]=i$ for all $i$.\n\nNow, let's analyze the proposed fusion and the options. The fused loop would combine the bodies of Loop $1$ and Loop $2$:\n$$\n\\text{for } i \\in \\{0, \\dots, N-1\\} \\{ \\\\\n\\quad \\dots \\text{fused body} \\dots \\\\\n\\}\n$$\n\n### Option-by-Option Analysis\n\n**A. Fusing into a single loop with the per-iteration order $A[i] \\leftarrow i$ followed by $B[A[i]] \\leftarrow i$ is legal and does not introduce a Write-After-Read hazard; no temporary is required under the stated assumptions.**\n\nThe fused loop body would be:\n1.  $S_A: A[i] \\leftarrow i$\n2.  $S_B: B[A[i]] \\leftarrow i$\n\nLet's analyze this fused loop. Within a single iteration $i$:\n-   $S_A$ writes the value $i$ to the memory location $A[i]$.\n-   $S_B$ then reads the memory location $A[i]$. Because of the sequential execution within the loop body, it reads the value $i$ that was just written. The assignment thus becomes $B[i] \\leftarrow i$.\n\nThis execution preserves the original true dependence. The original inter-loop dependence ($S_{1,i} \\rightarrow S_{2,i}$) is transformed into an intra-iteration dependence in the fused loop. The final state of arrays $A$ and $B$ is identical to the original program ($A[i]=i$ and $B[i]=i$). Therefore, the fusion is legal.\n\nA Write-After-Read (WAR) hazard would occur if a statement writes to a location that a preceding statement reads. Here, $S_A$ does not read from memory (its right-hand side is the induction variable $i$). $S_B$ reads from $A[i]$, but $S_A$ does not read from any location that $S_B$ writes. The dependence on $A[i]$ is that $S_A$ writes to it, and $S_B$ reads from it. This is a Read-After-Write (RAW) flow, not a Write-After-Read (WAR) anti-dependence. No new, problematic WAR hazard is introduced. Since the fusion is legal and directly implements the logic, no temporary variable is needed.\n\n**Verdict: Correct.**\n\n**B. Fusion is illegal because the fused body necessarily introduces a Write-After-Read hazard on $A[i]$ even if $A[i] \\leftarrow i$ is executed before $B[A[i]] \\leftarrow i$.**\n\nThis statement claims fusion is illegal. As demonstrated in the analysis for option A, fusion is legal. The statement also incorrectly identifies the dependence on $A[i]$ as a WAR hazard. The dependence is RAW ($A[i]$ is written, then read). The presence of a dependence does not automatically make a transformation illegal; legality depends on preserving the original program's semantics, which this fusion does.\n\n**Verdict: Incorrect.**\n\n**C. Fusion is legal, and if one wishes to reorder the fused body to execute the B update before updating A, introducing a temporary $t$ as $t \\leftarrow i$ and using $B[t] \\leftarrow i$ together with $A[i] \\leftarrow t$ eliminates any anti-dependence on A[i] while preserving the original semantics.**\n\n-   **Fusion is legal**: This part is correct.\n-   **Reordering**: Consider naively reordering the statements in the fused body to be $S_B$ then $S_A$:\n    1.  $B[A[i]] \\leftarrow i$\n    2.  $A[i] \\leftarrow i$\n    This reordering is illegal. The first statement reads $A[i]$ *before* it is updated in the current iteration, violating the original program's true dependence. This illegal ordering introduces a WAR (anti-dependence) on $A[i]$: the read in the first statement is followed by a write to the same location in the second statement.\n-   **Proposed Transformation**: The option suggests a new loop body to enable the conceptual reordering:\n    1.  $t \\leftarrow i$\n    2.  $B[t] \\leftarrow i$\n    3.  $A[i] \\leftarrow t$\n    This sequence calculates $B[i] \\leftarrow i$ and $A[i] \\leftarrow i$, which correctly reproduces the final state of the original program.\n-   **Eliminates anti-dependence**: Let's analyze the dependences between the new statements for updating $A$ and $B$: $S_{C,A}: A[i] \\leftarrow t$ and $S_{C,B}: B[t] \\leftarrow i$. Neither statement reads a location that the other writes. They are independent with respect to memory arrays $A$ and $B$. Therefore, they can be scheduled in any order after $t \\leftarrow i$. This successfully eliminates the dependence on $A[i]$ that prevented the naive reordering, and thus resolves the associated anti-dependence.\nThe statement accurately describes a valid compiler technique (often involving scalar replacement or renaming) to increase instruction-level parallelism by breaking data dependences.\n\n**Verdict: Correct.**\n\n**D. Fusion creates an output dependence on $B$ across iterations that makes the transformation unsafe unless $A$ is strictly monotonic; therefore, it is unsafe for $A[i]=i$.**\n\n-   **Output Dependence (WAW)**: An output dependence exists between an operation in iteration $i$ and an operation in a later iteration $j$ if they both write to the same memory location. The write to $B$ is specified by $B[A[i]] \\leftarrow i$.\n-   **Analysis for $A[i]=i$**: In the fused loop, $A[i]$ is set to $i$ before the write to $B$. Thus, the write is to $B[i]$. For two different iterations $i$ and $j$ ($i \\neq j$), the writes are to $B[i]$ and $B[j]$, which are distinct memory locations. Therefore, for the specific case $A[i]=i$, there is **no** output dependence on $B$ across iterations.\n-   **Logical Flaw**: The statement has a logical contradiction. It posits a condition for safety (\"unsafe unless $A$ is strictly monotonic\") and then applies it to a case where the condition is met ($A[i]=i$ is strictly monotonic), but draws the opposite conclusion (\"therefore, it is unsafe for $A[i]=i$\"). If the premise were true, the conclusion for $A[i]=i$ should be that it is safe.\n-   As shown, the premise itself is false, as no output dependence exists for this problem. The transformation is perfectly safe.\n\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "Once a transformation is deemed legal, the next question is whether it is *profitable*. This practice  puts you in the role of a compiler engineer building a quantitative model to predict performance. Using a detailed cost model and profile data, you will estimate the speedup from loop fusion by accounting for its effects on memory hierarchy performance and branch prediction, two key drivers of modern CPU efficiency.",
            "id": "3652519",
            "problem": "A compiler backend for a Central Processing Unit (CPU) considers fusing two adjacent loops, $L_1$ and $L_2$, that iterate over the same range of $i \\in \\{0,\\dots,N-1\\}$ with $N = 10^7$. Loop $L_1$ computes $a[i]$ from $b[i]$, and loop $L_2$ consumes $a[i]$ to produce $d[i]$. Profile-guided optimization has produced the following per-iteration measurements for the program version where the loops are not fused:\n- Loop $L_1$: arithmetic base cost $c_1 = 2$ cycles; memory references per iteration $R_1 = 2$; average Level $1$ (L$1$) data cache miss rate per memory reference $m_1 = 0.05$; loop-control branch base cost $c_{\\mathrm{br}} = 1$ cycle per iteration; branch misprediction probability per iteration $p_1 = 0.003$.\n- Loop $L_2$: arithmetic base cost $c_2 = 3$ cycles; memory references per iteration $R_2 = 2$; average L$1$ data cache miss rate per memory reference $m_2 = 0.12$; branch misprediction probability per iteration $p_2 = 0.007$.\n\nThe machine model uses the following constants, derived from hardware performance monitoring:\n- L$1$ miss penalty $L = 40$ cycles.\n- Memory reference hit cost $C_h = 1$ cycle per reference.\n- Branch misprediction penalty $B = 15$ cycles.\n\nAssume the following when the loops are fused:\n- Dependence analysis allows scalar replacement, so the producer-consumer temporary $a[i]$ is not materialized in memory inside the fused loop. Consequently, the two references to $a[i]$ (the store in $L_1$ and the load in $L_2$) are eliminated from the steady-state memory traffic of the fused loop.\n- The remaining references inherit their miss behavior from the original loops: the $b[i]$ load has per-reference miss probability $m_1$, and the $d[i]$ store has per-reference miss probability $m_2$. No other references are introduced.\n- The fused loop has a single loop-control branch with misprediction probability $p_f = 0.004$ and the same base cost $c_{\\mathrm{br}}$ per iteration as above.\n\nUsing only fundamental definitions (expected cost as probability-weighted penalty plus base costs, linearity over iterations), construct a profitability model for the expected cycles and compute the speedup $S$ of the fused version over the unfused version. Express $S$ as the ratio of total expected execution cycles of the unfused code to that of the fused code for the same $N$, and give a single numerical value. Round your answer to $4$ significant figures.",
            "solution": "The problem asks for the speedup $S$ of a fused loop version over an unfused version. The speedup is defined as the ratio of the total expected execution time (in cycles) of the unfused version to that of the fused version. Since both versions perform the same number of iterations, $N = 10^7$, the speedup can be calculated as the ratio of the expected cycles per iteration.\n$$S = \\frac{\\text{Total Cycles}_{\\text{unfused}}}{\\text{Total Cycles}_{\\text{fused}}} = \\frac{N \\times T_{\\text{unfused, per iter}}}{N \\times T_{\\text{fused, per iter}}} = \\frac{T_{\\text{unfused, per iter}}}{T_{\\text{fused, per iter}}}$$\nWe will construct a profitability model for the expected number of cycles per iteration for each case. The total expected cost per iteration, $T_{\\text{iter}}$, is the sum of the costs from three main components: arithmetic operations, memory accesses, and loop control branching.\n\n$T_{\\text{iter}} = T_{\\text{arith}} + T_{\\text{mem}} + T_{\\text{branch}}$\n\nThe cost for each component is modeled as follows:\n-   Arithmetic cost, $T_{\\text{arith}}$, is the given base cost $c_{\\text{arith}}$.\n-   Memory cost, $T_{\\text{mem}}$, is the sum of expected costs for all memory references in the iteration. The expected cost for a single memory reference with miss rate $m$ is the sum of the hit cost $C_h$ and the expected penalty for a miss, which is the miss probability $m$ times the miss penalty $L$.\n    Expected Cost per Reference $= C_h + m \\times L$\n-   Branch cost, $T_{\\text{branch}}$, is the sum of the base cost for the branch instruction, $c_{\\mathrm{br}}$, and the expected penalty for a branch misprediction, which is the misprediction probability $p$ times the misprediction penalty $B$.\n    $T_{\\text{branch}} = c_{\\mathrm{br}} + p \\times B$\n\nFirst, we calculate the total expected cycles per iteration for the unfused version, $T_{\\text{unfused}}$. This is the sum of the per-iteration costs of loop $L_1$ and loop $L_2$.\n\nFor loop $L_1$:\n-   Arithmetic base cost: $c_1 = 2$ cycles.\n-   Memory references: $R_1 = 2$, with an average miss rate $m_1 = 0.05$.\n-   Branch misprediction probability: $p_1 = 0.003$.\nThe loop control branch has a base cost $c_{\\mathrm{br}} = 1$ cycle. The machine constants are L$1$ miss penalty $L = 40$ cycles, memory hit cost $C_h = 1$ cycle, and branch misprediction penalty $B = 15$ cycles.\n\nThe expected cost per iteration for $L_1$, denoted $T_1$, is:\n$$T_1 = c_1 + R_1 \\times (C_h + m_1 \\times L) + (c_{\\mathrm{br}} + p_1 \\times B)$$\n$$T_1 = 2 + 2 \\times (1 + 0.05 \\times 40) + (1 + 0.003 \\times 15)$$\n$$T_1 = 2 + 2 \\times (1 + 2) + (1 + 0.045)$$\n$$T_1 = 2 + 2 \\times 3 + 1.045$$\n$$T_1 = 2 + 6 + 1.045 = 9.045 \\text{ cycles}$$\n\nFor loop $L_2$:\n-   Arithmetic base cost: $c_2 = 3$ cycles.\n-   Memory references: $R_2 = 2$, with an average miss rate $m_2 = 0.12$.\n-   Branch misprediction probability: $p_2 = 0.007$.\nThe loop also has a control branch with base cost $c_{\\mathrm{br}} = 1$.\n\nThe expected cost per iteration for $L_2$, denoted $T_2$, is:\n$$T_2 = c_2 + R_2 \\times (C_h + m_2 \\times L) + (c_{\\mathrm{br}} + p_2 \\times B)$$\n$$T_2 = 3 + 2 \\times (1 + 0.12 \\times 40) + (1 + 0.007 \\times 15)$$\n$$T_2 = 3 + 2 \\times (1 + 4.8) + (1 + 0.105)$$\n$$T_2 = 3 + 2 \\times 5.8 + 1.105$$\n$$T_2 = 3 + 11.6 + 1.105 = 15.705 \\text{ cycles}$$\n\nThe total expected cycles per iteration for the unfused version is the sum of the costs for $L_1$ and $L_2$:\n$$T_{\\text{unfused}} = T_1 + T_2 = 9.045 + 15.705 = 24.75 \\text{ cycles}$$\n\nNext, we calculate the expected cycles per iteration for the fused version, $T_{\\text{fused}}$.\n-   Arithmetic cost: The operations of both loops are combined, so the arithmetic base cost is $c_f = c_1 + c_2 = 2 + 3 = 5$ cycles.\n-   Memory cost: The temporary array $a[i]$ is eliminated. The original memory references were a load from $b[i]$ and a store to $a[i]$ in $L_1$, and a load from $a[i]$ and a store to $d[i]$ in $L_2$. After fusion, the two references to $a[i]$ are removed. The remaining two references are the load from $b[i]$ and the store to $d[i]$. The problem states their miss probabilities are $m_1$ and $m_2$ respectively. The total memory cost is the sum of the expected costs for these two individual references.\n    $$T_{\\text{mem,fused}} = (\\text{cost of load } b[i]) + (\\text{cost of store } d[i])$$\n    $$T_{\\text{mem,fused}} = (C_h + m_1 \\times L) + (C_h + m_2 \\times L)$$\n    $$T_{\\text{mem,fused}} = (1 + 0.05 \\times 40) + (1 + 0.12 \\times 40)$$\n    $$T_{\\text{mem,fused}} = (1 + 2) + (1 + 4.8) = 3 + 5.8 = 8.8 \\text{ cycles}$$\n-   Branch cost: The fused loop has a single loop control structure with base cost $c_{\\mathrm{br}} = 1$ and a new misprediction probability $p_f = 0.004$.\n    $$T_{\\text{branch,fused}} = c_{\\mathrm{br}} + p_f \\times B = 1 + 0.004 \\times 15 = 1 + 0.06 = 1.06 \\text{ cycles}$$\n\nThe total expected cycles per iteration for the fused version is the sum of these components:\n$$T_{\\text{fused}} = T_{\\text{arith,fused}} + T_{\\text{mem,fused}} + T_{\\text{branch,fused}}$$\n$$T_{\\text{fused}} = 5 + 8.8 + 1.06 = 14.86 \\text{ cycles}$$\n\nFinally, we compute the speedup $S$:\n$$S = \\frac{T_{\\text{unfused}}}{T_{\\text{fused}}} = \\frac{24.75}{14.86} \\approx 1.665545087...$$\nRounding the result to $4$ significant figures gives $1.666$.",
            "answer": "$$\\boxed{1.666}$$"
        },
        {
            "introduction": "Effective compiler design involves understanding how different optimizations interact and enable one another. This problem  explores a powerful synergy between loop fusion and bounds-check elimination, a crucial optimization for memory-safe languages. You will analyze how fusing loops can simplify index expressions, allowing the compiler to hoist more runtime checks out of the loop and thereby reduce execution overhead.",
            "id": "3652562",
            "problem": "In a memory-safe language, each array access $X[e]$ performs a dynamic bounds check that verifies $0 \\le e < N_X$, where $N_X$ is the runtime length of array $X$. Consider three arrays $A$, $B$, and $C$ with runtime lengths $N_A$, $N_B$, and $N_C$, respectively, and a loop bound $n$ with precondition $n \\ge 3$. The program contains three loops over an induction variable $i$:\n- Loop $\\mathcal{L}_1$: $i$ ranges over $i \\in \\{1, 2, \\dots, n-2\\}$ and reads $A[i+1]$ and $B[i-1]$.\n- Loop $\\mathcal{L}_2$: $i$ ranges over $i \\in \\{0, 1, \\dots, n-3\\}$ and reads $A[i+1]$, $B[i]$, and $C[i]$.\n- Loop $\\mathcal{L}_3$: $i$ ranges over $i \\in \\{2, 3, \\dots, n-1\\}$ and reads $A[i-1]$ and $B[i-2]$.\n\nAssume an optimizing compiler for an ahead-of-time or Just-In-Time (JIT) compilation pipeline that implements the following two transformations, grounded in standard compiler principles:\n- Range-check elimination: for each loop and each array $X$ used in that loop, the compiler performs affine range analysis on the index expression $e(i)$ with the loop’s $i$-range. If it can prove that $0 \\le e(i) < N_X$ for all $i$ in the loop, it replaces all per-iteration checks for $X$ in that loop with a single loop-preheader guard that asserts the necessary relation between $n$ and $N_X$. Count each such loop-preheader guard as one bounds check. Assume that after this pass, there are no remaining per-iteration checks in any loop.\n- Loop fusion: the compiler may fuse $\\mathcal{L}_1$, $\\mathcal{L}_2$, and $\\mathcal{L}_3$ into a single loop over the union of their iteration domains, that is $i \\in \\{0, 1, \\dots, n-1\\}$, guarding each original loop body by predicates that enforce its original $i$-range. After fusion, it reruns range-check elimination and emits at most one loop-preheader guard per distinct array used across the fused loop, strong enough to make all guarded accesses to that array safe for all $i$ in the union loop.\n\nUnder these assumptions:\n- Compute the total number of loop-preheader bounds checks that must be emitted when compiling the program without fusion but with per-loop range-check elimination.\n- Compute the total number of loop-preheader bounds checks after full fusion of the three loops, followed by range-check elimination over the fused loop.\n- Finally, compute the number of eliminated checks due to fusion, defined as the difference between the two totals above. Provide your final answer as this single number. No rounding is required, and no units are involved.",
            "solution": "The problem requires us to calculate the number of loop-preheader bounds checks before and after loop fusion and then find the difference. A loop-preheader check is emitted for each distinct array accessed within a loop if the compiler can prove all accesses within the loop's iteration range are safe.\n\n**Part 1: Bounds Checks without Fusion**\nWe analyze each of the three loops independently to determine the number of preheader checks required.\n\n*   **Loop $\\mathcal{L}_1$**: Iterates for $i \\in \\{1, 2, \\dots, n-2\\}$.\n    *   Access $A[i+1]$: The index expression is $i+1$. The range of indices accessed is $[1+1, (n-2)+1] = [2, n-1]$. A preheader check is needed to ensure $0 \\le 2$ (always true) and $n-1  N_A$. This is **1 check** for array $A$.\n    *   Access $B[i-1]$: The index expression is $i-1$. The range of indices accessed is $[1-1, (n-2)-1] = [0, n-3]$. A preheader check is needed to ensure $0 \\le 0$ (always true) and $n-3  N_B$. This is **1 check** for array $B$.\n    *   Total for $\\mathcal{L}_1$: 2 checks.\n\n*   **Loop $\\mathcal{L}_2$**: Iterates for $i \\in \\{0, 1, \\dots, n-3\\}$.\n    *   Access $A[i+1]$: The index range is $[0+1, (n-3)+1] = [1, n-2]$. A check is needed to ensure $n-2  N_A$. **1 check** for array $A$.\n    *   Access $B[i]$: The index range is $[0, n-3]$. A check is needed to ensure $n-3  N_B$. **1 check** for array $B$.\n    *   Access $C[i]$: The index range is $[0, n-3]$. A check is needed to ensure $n-3  N_C$. **1 check** for array $C$.\n    *   Total for $\\mathcal{L}_2$: 3 checks.\n\n*   **Loop $\\mathcal{L}_3$**: Iterates for $i \\in \\{2, 3, \\dots, n-1\\}$.\n    *   Access $A[i-1]$: The index range is $[2-1, (n-1)-1] = [1, n-2]$. A check is needed to ensure $n-2  N_A$. **1 check** for array $A$.\n    *   Access $B[i-2]$: The index range is $[2-2, (n-1)-2] = [0, n-3]$. A check is needed to ensure $n-3  N_B$. **1 check** for array $B$.\n    *   Total for $\\mathcal{L}_3$: 2 checks.\n\nThe total number of preheader checks without fusion is the sum of checks for each loop: $2 + 3 + 2 = 7$.\n\n**Part 2: Bounds Checks with Fusion**\nAfter fusion, there is a single loop over $i \\in \\{0, 1, \\dots, n-1\\}$. The compiler emits at most one preheader check per array, which must be strong enough to cover all accesses to that array across the entire fused loop.\n\n*   **Array A**: Accessed via $A[i+1]$ (from original $\\mathcal{L}_1$ and $\\mathcal{L}_2$) and $A[i-1]$ (from original $\\mathcal{L}_3$).\n    *   The index range for $A[i+1]$ comes from $i \\in [1, n-2]$ and $i \\in [0, n-3]$. The union of these $i$-ranges is $[0, n-2]$, which produces indices $i+1 \\in [1, n-1]$.\n    *   The index range for $A[i-1]$ comes from $i \\in [2, n-1]$, which produces indices $i-1 \\in [1, n-2]$.\n    *   The overall set of indices accessed for array $A$ is the union of $[1, n-1]$ and $[1, n-2]$, which is $[1, n-1]$.\n    *   The single preheader check for $A$ must guarantee $0 \\le 1$ (true) and $n-1  N_A$. This is **1 check**.\n\n*   **Array B**: Accessed via $B[i-1]$ ($\\mathcal{L}_1$), $B[i]$ ($\\mathcal{L}_2$), and $B[i-2]$ ($\\mathcal{L}_3$).\n    *   Indices from $B[i-1]$ for $i \\in [1, n-2]$ are in $[0, n-3]$.\n    *   Indices from $B[i]$ for $i \\in [0, n-3]$ are in $[0, n-3]$.\n    *   Indices from $B[i-2]$ for $i \\in [2, n-1]$ are in $[0, n-3]$.\n    *   The overall set of indices accessed for array $B$ is the union of these ranges, which is $[0, n-3]$.\n    *   The single preheader check for $B$ must guarantee $0 \\le 0$ (true) and $n-3  N_B$. This is **1 check**.\n\n*   **Array C**: Accessed only via $C[i]$ (from $\\mathcal{L}_2$).\n    *   The range of indices accessed for $C$ for $i \\in [0, n-3]$ is $[0, n-3]$.\n    *   The single preheader check for $C$ must guarantee $0 \\le 0$ (true) and $n-3  N_C$. This is **1 check**.\n\nThe total number of preheader checks with fusion is $1 + 1 + 1 = 3$.\n\n**Part 3: Number of Eliminated Checks**\nThe number of checks eliminated by fusion is the difference between the total before fusion and the total after fusion.\n$$ \\text{Eliminated checks} = (\\text{Checks without fusion}) - (\\text{Checks with fusion}) = 7 - 3 = 4 $$\nFusion allows the compiler to reason about the global access patterns for each array across all operations, leading to a smaller number of more general checks.",
            "answer": "$$ \\boxed{4} $$"
        }
    ]
}