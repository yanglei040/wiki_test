{
    "hands_on_practices": [
        {
            "introduction": "在编译器优化中，首要原则是保证转换的正确性——即优化后的程序必须与原始程序产生完全相同的结果。对于循环融合而言，这意味着必须仔细分析和维护循环之间的数据依赖关系。这个练习将引导你深入理解数据依赖在决定循环融合合法性时的关键作用，并探讨如何通过引入临时变量等技术来解决潜在的数据冒险，从而安全地进行代码重构。",
            "id": "3652559",
            "problem": "考虑长度为 $N$ 的数组 $A$ 和 $B$，以及两个遍历共同迭代空间 $i \\in \\{0,1,\\dots,N-1\\}$ 的循环：\n- 循环 1：对于每个 $i$，赋值 $A[i] \\leftarrow i$。\n- 循环 2：对于每个 $i$，赋值 $B[A[i]] \\leftarrow i$。\n\n假设采用顺序程序语义，其中程序顺序中的每条语句都能观察到所有先前语句的效果，并假设 $A$ 和 $B$ 指向不相交的内存区域。请您基于以下推理依据，评估循环融合的合法性以及是否需要临时变量：\n- 数据依赖的定义：当语句 $S_2$ 读取由语句 $S_1$ 先前写入的内存位置时，存在写后读（RAW）或真依赖；当 $S_2$ 写入由 $S_1$ 先前读取的位置时，存在读后写（WAR）或反依赖；当 $S_1$ 和 $S_2$ 都写入同一位置时，存在写后写（WAW）或输出依赖。正确的变换必须保持所有真依赖，并避免产生改变行为的反依赖或输出依赖。\n- 循环融合的定义：将具有相同迭代空间的两个循环合并为遍历该空间的单个循环，并保持顺序语义。\n\n考虑将循环 1 和循环 2 融合成一个单一循环，并分析融合是否会导致读后写风险，以及如果希望重排语句顺序是否需要临时变量。选择所有正确的陈述：\n\nA. 融合成一个单一循环，且每次迭代中按 $A[i] \\leftarrow i$ 后接 $B[A[i]] \\leftarrow i$ 的顺序执行是合法的，并且不会引入读后写风险；在所述假设下不需要临时变量。\n\nB. 融合是非法的，因为即使 $A[i] \\leftarrow i$ 在 $B[A[i]] \\leftarrow i$ 之前执行，融合后的循环体也必然会在 $A[i]$ 上引入读后写风险。\n\nC. 融合是合法的，并且如果希望重排融合后的循环体，在更新 $A$ 之前执行对 $B$ 的更新，可以通过引入一个临时变量 $t$ 作为 $t \\leftarrow i$，并使用 $B[t] \\leftarrow i$ 和 $A[i] \\leftarrow t$ 来消除对 $A[i]$ 的任何反依赖，同时保持原始语义。\n\nD. 融合在 $B$ 上产生了跨迭代的输出依赖，这使得变换不安全，除非 $A$ 是严格单调的；因此，对于 $A[i]=i$ 的情况，它是不安全的。",
            "solution": "用户希望我验证并解决一个关于编译器理论中循环融合和数据依赖分析的问题。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n-   数组：长度为 $N$ 的 $A$ 和 $B$。\n-   迭代空间：$i \\in \\{0, 1, \\dots, N-1\\}$。\n-   循环 1：对于每个 $i$，赋值 $A[i] \\leftarrow i$。设迭代 $i$ 中的此语句为 $S_{1,i}$。\n-   循环 2：对于每个 $i$，赋值 $B[A[i]] \\leftarrow i$。设迭代 $i$ 中的此语句为 $S_{2,i}$。\n-   程序语义：顺序执行，先前语句的效果对后续语句可见。\n-   内存区域：$A$ 和 $B$ 不相交。\n-   推理依据：\n    -   数据依赖：写后读（RAW，真依赖），读后写（WAR，反依赖），写后写（WAW，输出依赖）。\n    -   正确性标准：变换必须保持所有真依赖，并避免产生改变行为的反依赖或输出依赖。\n    -   循环融合：将具有相同迭代空间的两个循环合并为一个。\n-   任务：分析融合循环 1 和循环 2 的合法性以及是否需要临时变量。\n\n**第二步：使用提取的已知条件进行验证**\n\n-   **科学依据：** 该问题牢固地植根于编译器优化这一成熟领域，特别是依赖分析和循环变换。数据依赖（RAW、WAR、WAW）和循环融合的概念是计算机科学与工程课程中的标准主题。该问题在科学上和事实上都是合理的。\n-   **良构性：** 问题定义清晰。初始状态（两个顺序循环）、变换（循环融合）以及正确性标准（依赖保持）都已明确给出。可以推导出关于融合合法性及变换后代码属性的确定性答案。\n-   **客观性：** 问题陈述使用精确的技术语言，没有任何主观或模糊的术语。\n-   **完整性与一致性：** 问题是自洽的。所有必要信息（循环边界、循环体、内存不相交性）均已提供。没有内部矛盾。\n-   **其他缺陷：** 该问题没有表现出任何其他缺陷，例如不切实际、病态、过于简单或无法验证。这是一个应用编译器原理的标准的、有一定难度的练习。\n\n**第三步：结论与行动**\n\n问题陈述是**有效的**。我将继续推导解决方案。\n\n### 解决方案推导\n\n首先，我们分析原始未融合程序中的数据依赖。\n-   循环 1（对于 $i \\in \\{0, \\dots, N-1\\}$）：$S_{1,i}: A[i] \\leftarrow i$。此循环写入数组 $A$。在其完成后，对于迭代空间中的所有 $i$，$A[i]$ 的值为 $i$。\n-   循环 2（对于 $i \\in \\{0, \\dots, N-1\\}$）：$S_{2,i}: B[A[i]] \\leftarrow i$。此循环从数组 $A$ 读取数据并写入数组 $B$。\n\n关键的依赖存在于循环之间。对于任何给定的索引 $k \\in \\{0, \\dots, N-1\\}$，语句 $S_{1,k}$ 写入 $A[k]$，而语句 $S_{2,k}$ 从 $A[k]$ 读取。由于循环 1 完全在循环 2 之前执行，$S_{2,k}$ 读取的是由 $S_{1,k}$ 写入的值。这构成了从 $S_{1,k}$ 到 $S_{2,k}$ 的写后读（RAW）或真依赖。任何合法的变换都必须为所有 $k$ 保持这组依赖关系。\n\n在原始程序中，由于循环 1 结束后 $A[k]$ 变为 $k$，循环 2 实际上对所有 $k \\in \\{0, \\dots, N-1\\}$ 执行 $B[k] \\leftarrow k$。最终状态是对于所有的 $i$，$A[i]=i$ 且 $B[i]=i$。\n\n现在，我们来分析提议的融合和各个选项。融合后的循环将合并循环 1 和循环 2 的循环体：\n$$\n\\text{for } i \\in \\{0, \\dots, N-1\\} \\{ \\\\\n\\quad \\dots \\text{fused body} \\dots \\\\\n\\}\n$$\n\n### 逐个选项分析\n\n**A. 融合成一个单一循环，且每次迭代中按 $A[i] \\leftarrow i$ 后接 $B[A[i]] \\leftarrow i$ 的顺序执行是合法的，并且不会引入读后写风险；在所述假设下不需要临时变量。**\n\n融合后的循环体将是：\n1.  $S_A: A[i] \\leftarrow i$\n2.  $S_B: B[A[i]] \\leftarrow i$\n\n我们来分析这个融合后的循环。在单次迭代 $i$ 中：\n-   $S_A$ 将值 $i$ 写入内存位置 $A[i]$。\n-   接着 $S_B$ 读取内存位置 $A[i]$。由于循环体内的顺序执行，它读取到刚刚写入的值 $i$。因此赋值操作变为 $B[i] \\leftarrow i$。\n\n这种执行方式保持了原始的真依赖。原始的循环间依赖 ($S_{1,i} \\rightarrow S_{2,i}$) 在融合后的循环中转变为迭代内依赖。数组 $A$ 和 $B$ 的最终状态与原始程序相同（$A[i]=i$ 和 $B[i]=i$）。因此，融合是合法的。\n\n如果一条语句写入一个被前序语句读取的位置，就会发生读后写（WAR）风险。在这里，$S_A$ 不从内存中读取（其右侧是归纳变量 $i$）。$S_B$ 从 $A[i]$ 读取，但 $S_A$ 不会读取任何 $S_B$ 写入的位置。对 $A[i]$ 的依赖是 $S_A$ 写入它，然后 $S_B$ 读取它。这是一个写后读（RAW）流依赖，而不是读后写（WAR）反依赖。没有引入新的、有问题的 WAR 风险。由于融合是合法的并且直接实现了逻辑，因此不需要临时变量。\n\n**结论：正确。**\n\n**B. 融合是非法的，因为即使 $A[i] \\leftarrow i$ 在 $B[A[i]] \\leftarrow i$ 之前执行，融合后的循环体也必然会在 $A[i]$ 上引入读后写风险。**\n\n该陈述声称融合是非法的。如选项 A 的分析所示，融合是合法的。该陈述还错误地将对 $A[i]$ 的依赖识别为 WAR 风险。该依赖是 RAW（先写 $A[i]$，后读）。依赖的存在本身不会自动使变换非法；合法性取决于是否保持原始程序的语义，而这种融合做到了这一点。\n\n**结论：错误。**\n\n**C. 融合是合法的，并且如果希望重排融合后的循环体，在更新 $A$ 之前执行对 $B$ 的更新，可以通过引入一个临时变量 $t$ 作为 $t \\leftarrow i$，并使用 $B[t] \\leftarrow i$ 和 $A[i] \\leftarrow t$ 来消除对 $A[i]$ 的任何反依赖，同时保持原始语义。**\n\n-   **融合是合法的**：这部分是正确的。\n-   **重排**：考虑在融合后的循环体中天真地将语句重排为先 $S_B$ 后 $S_A$：\n    1.  $B[A[i]] \\leftarrow i$\n    2.  $A[i] \\leftarrow i$\n    这种重排是非法的。第一条语句在当前迭代中更新 $A[i]$ *之前* 读取它，这违反了原始程序的真依赖。这种非法的顺序在 $A[i]$ 上引入了 WAR（反依赖）：第一条语句中的读取操作之后是第二条语句中对同一位置的写入操作。\n-   **提议的变换**：该选项建议使用一个新的循环体来实现概念上的重排：\n    1.  $t \\leftarrow i$\n    2.  $B[t] \\leftarrow i$\n    3.  $A[i] \\leftarrow t$\n    这个序列计算了 $B[i] \\leftarrow i$ 和 $A[i] \\leftarrow i$，正确地再现了原始程序的最终状态。\n-   **消除反依赖**：我们来分析用于更新 $A$ 和 $B$ 的新语句之间的依赖关系：$S_{C,A}: A[i] \\leftarrow t$ 和 $S_{C,B}: B[t] \\leftarrow i$。这两条语句都没有读取对方写入的位置。它们在内存数组 $A$ 和 $B$ 方面是独立的。因此，在 $t \\leftarrow i$ 之后，它们可以按任何顺序调度。这成功地消除了阻碍天真重排的对 $A[i]$ 的依赖，从而解决了相关的反依赖。该陈述准确地描述了一种有效的编译器技术（通常涉及标量替换或重命名），通过打破数据依赖来增加指令级并行度。\n\n**结论：正确。**\n\n**D. 融合在 $B$ 上产生了跨迭代的输出依赖，这使得变换不安全，除非 $A$ 是严格单调的；因此，对于 $A[i]=i$ 的情况，它是不安全的。**\n\n-   **输出依赖（WAW）**：如果在迭代 $i$ 中的一个操作和后续迭代 $j$ 中的一个操作都写入同一个内存位置，则它们之间存在输出依赖。对 $B$ 的写入由 $B[A[i]] \\leftarrow i$ 指定。\n-   **对于 $A[i]=i$ 的分析**：在融合后的循环中，$A[i]$ 在写入 $B$ 之前被设置为 $i$。因此，写入操作是针对 $B[i]$ 的。对于两个不同的迭代 $i$ 和 $j$ ($i \\neq j$)，写入操作分别针对 $B[i]$ 和 $B[j]$，它们是不同的内存位置。因此，对于 $A[i]=i$ 这个特定情况，在 $B$ 上**不存在**跨迭代的输出依赖。\n-   **逻辑缺陷**：该陈述存在逻辑矛盾。它提出了一个安全条件（“不安全，除非 $A$ 是严格单调的”），然后将其应用于一个满足该条件的情况（$A[i]=i$ 是严格单调的），但却得出了相反的结论（“因此，对于 $A[i]=i$ 的情况，它是不安全的”）。如果前提为真，那么对于 $A[i]=i$ 的结论应该是安全的。\n-   如上所示，前提本身就是错误的，因为对于这个问题不存在输出依赖。该变换是完全安全的。\n\n**结论：错误。**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "一旦确定循环融合是合法的，接下来的问题就是它能带来什么好处。这个练习通过一个经典的“生产者-消费者”模型，让你直观地量化循环融合的性能优势。你将计算并比较融合前后两种实现在延迟、总执行时间和内存占用上的差异，从而深刻体会循环融合是如何通过消除中间数据缓冲来显著提升程序效率的。",
            "id": "3652599",
            "problem": "考虑一个编译器优化程序中的两阶段流水线，该流水线包含一个生产者循环和一个消费者循环。生产者逐元素计算一个中间数组，消费者立即消费该中间结果以生成最终结果。我们考虑两种备选实现方式：\n\n1. 一种非融合实现，在阶段之间设置一个屏障，强制消费者等待生产者完成所有项目。\n2. 一种融合实现，其中生产者和消费者被合并到单个循环中，按顺序处理每个项目，无需屏障。\n\n使用以下来自编译器原理的基本依据：\n- 循环融合和循环分裂是在满足数据依赖约束的同时，改变循环结构并保持程序语义的变换。\n- 屏障是一种同步原语，它强制所有参与的线程或阶段到达屏障后，才能继续执行后续操作。\n- 在带有屏障的生产者-消费者流水线中，消费者在到达屏障之前无法开始任何消费，这意味着所有生产出的数据都必须被缓冲。\n- 在融合循环中，消费者立即消费同一迭代中生产者产生的值，仅需要常数大小的缓冲。\n\n假设使用以下成本模型，以抽象时间单位表示：\n- 每个元素的生产者成本为 $c_p$ 个时间单位。\n- 每个元素的消费者成本为 $c_c$ 个时间单位。\n- 屏障开销为 $b$ 个时间单位。\n- 元素数量为 $n$。\n\n在这些假设下：\n- 在带有屏障的非融合实现中，生产者在屏障前完成所有 $n$ 个项目，消费者仅在通过屏障后才开始。\n- 在融合实现中，每个元素在同一次迭代内被生产后立即被消费，没有屏障。\n\n您的任务是编写一个完整的程序，为每个提供的测试用例计算以下量：\n- 带有屏障的非融合实现中首次输出的时间，以抽象时间单位计。\n- 融合实现中首次输出的时间，以抽象时间单位计。\n- 带有屏障的非融合实现中的总完成时间，以抽象时间单位计。\n- 融合实现中的总完成时间，以抽象时间单位计。\n- 带有屏障的非融合实现所需的缓冲区大小（存储的元素数量）。\n- 融合实现所需的缓冲区大小（存储的元素数量）。\n\n所有时间计算必须以抽象时间单位进行，这些单位是无量纲的。缓冲区大小是无量纲的元素计数。\n\n请根据上述定义，纯粹以数学和逻辑术语设计计算。不涉及物理单位。\n\n测试套件：\n在以下参数四元组 $(n, c_p, c_c, b)$ 集合上评估您的程序：\n- 案例 1：$(n, c_p, c_c, b) = (8, 5, 3, 20)$。\n- 案例 2：$(n, c_p, c_c, b) = (1, 5, 3, 10)$。\n- 案例 3：$(n, c_p, c_c, b) = (1024, 1, 1, 0)$。\n- 案例 4：$(n, c_p, c_c, b) = (64, 10, 1, 100)$。\n- 案例 5：$(n, c_p, c_c, b) = (32, 2, 8, 16)$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果本身必须是按以下顺序用方括号括起来的逗号分隔列表：\n$[$非融合首次输出时间, 融合首次输出时间, 非融合总时间, 融合总时间, 非融合缓冲区大小, 融合缓冲区大小$]$。\n\n因此，完整的输出是单行：\n$[$$[$\\cdots$,$\\cdots$,$\\cdots$,$\\cdots$,$\\cdots$,$\\cdots$$]$,$[$\\cdots$,$\\cdots$,$\\cdots$,$\\cdots$,$\\cdots$,$\\cdots$$]$,$\\ldots$$]$。\n\n程序必须是自包含的，并且不需要任何输入。",
            "solution": "该问题要求基于提供的抽象成本模型，对生产者-消费者计算的两种不同循环实现策略进行定量分析。这两种策略是带有屏障的非融合方法和融合方法。我们将为每种策略推导六个性能和资源指标的数学表达式。模型的参数是元素数量 $n$、每个元素的生产者成本 $c_p$、每个元素的消费者成本 $c_c$ 和屏障开销 $b$。\n\n首先，我们来分析 **带有屏障的非融合实现**。\n在此模型中，执行过程分为三个不同的顺序阶段：\n1. 生产者循环运行至完成，生成所有 $n$ 个中间元素。\n2. 执行一个同步屏障。\n3. 消费者循环运行至完成，处理所有 $n$ 个中间元素。\n\n生产者阶段处理所有 $n$ 个元素所花费的总时间是元素数量与单位元素成本的乘积，即 $n \\cdot c_p$。\n生产者完成后，会执行一个开销为 $b$ 个时间单位的屏障。消费者只有在通过此屏障后才能开始工作。因此，在消费者能够开始处理第一个元素之前经过的总时间是 $n \\cdot c_p + b$。\n\n- **首次输出时间（非融合）**：当消费者完成处理第一个元素时，生成首次输出。这发生在消费者开始后 $c_c$ 个时间单位。首次输出时间，记为 $T_{\\text{first, unfused}}$，是完成所有生产的时间、屏障开销以及消费一个元素的时间之和。\n$$T_{\\text{first, unfused}} = (n \\cdot c_p) + b + c_c$$\n\n- **总完成时间（非融合）**：总完成时间是消费者完成处理最后一个（第 $n$ 个）元素的时间点。消费者阶段在时间 $n \\cdot c_p + b$ 开始，并花费总共 $n \\cdot c_c$ 个时间单位来处理所有 $n$ 个元素。总完成时间 $T_{\\text{total, unfused}}$ 是所有三个阶段持续时间的总和。\n$$T_{\\text{total, unfused}} = (n \\cdot c_p) + b + (n \\cdot c_c) = n \\cdot (c_p + c_c) + b$$\n\n- **所需缓冲区大小（非融合）**：由于生产者必须在消费者开始之前完成所有 $n$ 个元素的工作，所有 $n$ 个中间结果都必须存储在缓冲区中。因此，所需的缓冲区大小 $B_{\\text{unfused}}$ 等于元素数量。\n$$B_{\\text{unfused}} = n$$\n\n接下来，我们分析 **融合实现**。\n在此模型中，生产者和消费者操作被合并到单个循环中。对于 $n$ 个元素中的每一个，生产步骤之后紧跟着同一循环迭代内的消费步骤。没有屏障。这个融合循环单次迭代的成本是生产一个元素的成本和消费一个元素的成本之和，即 $c_p + c_c$。\n\n- **首次输出时间（融合）**：首次输出在融合循环的第一次迭代结束时生成。这次迭代包括生产一个元素（成本 $c_p$）然后消费它（成本 $c_c$）。首次输出时间 $T_{\\text{first, fused}}$ 是这次单次迭代的持续时间。\n$$T_{\\text{first, fused}} = c_p + c_c$$\n\n- **总完成时间（融合）**：总时间是融合循环所有 $n$ 次迭代的累积时间。由于每次迭代需要 $c_p + c_c$ 个时间单位，总完成时间 $T_{\\text{total, fused}}$ 是此持续时间乘以迭代次数。\n$$T_{\\text{total, fused}} = n \\cdot (c_p + c_c)$$\n\n- **所需缓冲区大小（融合）**：在融合循环中，一次迭代中产生的值会立即在同一次迭代中被消费。中间值仅需要在生产和消费操作之间的短暂时间内存储。这需要一个足以容纳一个元素的缓冲区。因此，所需的缓冲区大小 $B_{\\text{fused}}$ 是常数。\n$$B_{\\text{fused}} = 1$$\n\n这些推导出的公式在提供的程序中实现，用以计算每个测试用例所需的量。\n每个测试用例 $(n, c_p, c_c, b)$ 的最终结果列表将按以下顺序排列：\n$[T_{\\text{first, unfused}}, T_{\\text{first, fused}}, T_{\\text{total, unfused}}, T_{\\text{total, fused}}, B_{\\text{unfused}}, B_{\\text{fused}}]$。",
            "answer": "[[63,8,84,64,8,1],[18,8,18,8,1,1],[1025,2,2048,2048,1024,1],[741,11,804,704,64,1],[88,10,336,320,32,1]]"
        },
        {
            "introduction": "然而，一个合法的优化不一定总能带来性能提升。在现代复杂的处理器上，一个优化的最终效果取决于多种因素的微妙平衡，如缓存行为和分支预测。这个练习要求你扮演编译器的角色，建立一个精细的性能“收益模型”。通过综合考虑缓存未命中率、指令执行成本和分支预测错误惩罚，你将学习如何量化决策，判断循环融合在特定硬件环境下的真实收益，这正是现代编译器进行优化决策的核心思想。",
            "id": "3652519",
            "problem": "一个中央处理器 (CPU) 的编译器后端正在考虑合并两个相邻的循环 $L_1$ 和 $L_2$，它们在相同的范围 $i \\in \\{0,\\dots,N-1\\}$ 上进行迭代，其中 $N = 10^7$。循环 $L_1$ 从 $b[i]$ 计算 $a[i]$，循环 $L_2$ 消费 $a[i]$ 以生成 $d[i]$。对于循环未合并的程序版本，剖析导向优化得出了以下每次迭代的测量值：\n- 循环 $L_1$：算术基础成本 $c_1 = 2$ 个周期；每次迭代的内存引用次数 $R_1 = 2$；每个内存引用的平均一级（L1）数据缓存未命中率 $m_1 = 0.05$；循环控制分支基础成本 $c_{\\mathrm{br}} = 1$ 个周期/迭代；每次迭代的分支预测错误概率 $p_1 = 0.003$。\n- 循环 $L_2$：算术基础成本 $c_2 = 3$ 个周期；每次迭代的内存引用次数 $R_2 = 2$；每个内存引用的平均一级（L1）数据缓存未命中率 $m_2 = 0.12$；每次迭代的分支预测错误概率 $p_2 = 0.007$。\n\n该机器模型使用以下从硬件性能监控中得出的常量：\n- L1 未命中惩罚 $L = 40$ 个周期。\n- 内存引用命中成本 $C_h = 1$ 个周期/引用。\n- 分支预测错误惩罚 $B = 15$ 个周期。\n\n假设在循环合并后，存在以下情况：\n- 依赖性分析允许进行标量替换，因此生产者-消费者的临时变量 $a[i]$ 不会在合并后的循环内物化到内存中。因此，对 $a[i]$ 的两次引用（$L_1$ 中的存储和 $L_2$ 中的加载）将从合并后循环的稳态内存流量中消除。\n- 剩余的引用继承了原始循环的未命中行为：$b[i]$ 的加载操作具有每个引用 $m_1$ 的未命中概率，$d[i]$ 的存储操作具有每个引用 $m_2$ 的未命中概率。没有引入其他引用。\n- 合并后的循环有一个单一的循环控制分支，其预测错误概率为 $p_f = 0.004$，每次迭代的基础成本 $c_{\\mathrm{br}}$ 与上述相同。\n\n仅使用基本定义（期望成本等于概率加权的惩罚加上基础成本，迭代的线性性），为期望周期数构建一个盈利能力模型，并计算合并版本相对于未合并版本的加速比 $S$。将 $S$ 表示为在相同 $N$ 值下，未合并代码的总期望执行周期与合并代码的总期望执行周期的比率，并给出一个单一的数值。将您的答案四舍五入到 $4$ 位有效数字。",
            "solution": "题目要求计算合并循环版本相对于未合并版本的加速比 $S$。加速比定义为未合并版本的总期望执行时间（以周期为单位）与合并版本的总期望执行时间的比率。由于两个版本执行相同次数的迭代，即 $N=10^7$ 次，加速比可以计算为每次迭代的期望周期数的比率。\n$$S = \\frac{\\text{Total Cycles}_{\\text{unfused}}}{\\text{Total Cycles}_{\\text{fused}}} = \\frac{N \\times T_{\\text{unfused, per iter}}}{N \\times T_{\\text{fused, per iter}}} = \\frac{T_{\\text{unfused, per iter}}}{T_{\\text{fused, per iter}}}$$\n我们将为每种情况构建一个关于每次迭代的期望周期数的盈利能力模型。每次迭代的总期望成本 $T_{\\text{iter}}$ 是三个主要组成部分成本的总和：算术运算、内存访问和循环控制分支。\n\n$T_{\\text{iter}} = T_{\\text{arith}} + T_{\\text{mem}} + T_{\\text{branch}}$\n\n每个组成部分的成本模型如下：\n-   算术成本 $T_{\\text{arith}}$ 是给定的基础成本 $c_{\\text{arith}}$。\n-   内存成本 $T_{\\text{mem}}$ 是该次迭代中所有内存引用的期望成本之和。对于未命中率为 $m$ 的单个内存引用，其期望成本是命中成本 $C_h$ 与未命中的期望惩罚之和，即未命中概率 $m$ 乘以未命中惩罚 $L$。\n    每个引用的期望成本 $= C_h + m \\times L$\n-   分支成本 $T_{\\text{branch}}$ 是分支指令的基础成本 $c_{\\mathrm{br}}$ 与分支预测错误的期望惩罚之和，即预测错误概率 $p$ 乘以预测错误惩罚 $B$。\n    $T_{\\text{branch}} = c_{\\mathrm{br}} + p \\times B$\n\n首先，我们计算未合并版本每次迭代的总期望周期数 $T_{\\text{unfused}}$。这是循环 $L_1$ 和循环 $L_2$ 每次迭代成本的总和。\n\n对于循环 $L_1$：\n-   算术基础成本：$c_1 = 2$ 个周期。\n-   内存引用：$R_1 = 2$，平均未命中率为 $m_1 = 0.05$。\n-   分支预测错误概率：$p_1 = 0.003$。\n循环控制分支的基础成本为 $c_{\\mathrm{br}} = 1$ 个周期。机器常量为：L1 未命中惩罚 $L = 40$ 个周期，内存命中成本 $C_h = 1$ 个周期，分支预测错误惩罚 $B = 15$ 个周期。\n\n$L_1$ 每次迭代的期望成本，记为 $T_1$，为：\n$$T_1 = c_1 + R_1 \\times (C_h + m_1 \\times L) + (c_{\\mathrm{br}} + p_1 \\times B)$$\n$$T_1 = 2 + 2 \\times (1 + 0.05 \\times 40) + (1 + 0.003 \\times 15)$$\n$$T_1 = 2 + 2 \\times (1 + 2) + (1 + 0.045)$$\n$$T_1 = 2 + 2 \\times 3 + 1.045$$\n$$T_1 = 2 + 6 + 1.045 = 9.045 \\text{ cycles}$$\n\n对于循环 $L_2$：\n-   算术基础成本：$c_2 = 3$ 个周期。\n-   内存引用：$R_2 = 2$，平均未命中率为 $m_2 = 0.12$。\n-   分支预测错误概率：$p_2 = 0.007$。\n该循环也有一个控制分支，基础成本为 $c_{\\mathrm{br}} = 1$。\n\n$L_2$ 每次迭代的期望成本，记为 $T_2$，为：\n$$T_2 = c_2 + R_2 \\times (C_h + m_2 \\times L) + (c_{\\mathrm{br}} + p_2 \\times B)$$\n$$T_2 = 3 + 2 \\times (1 + 0.12 \\times 40) + (1 + 0.007 \\times 15)$$\n$$T_2 = 3 + 2 \\times (1 + 4.8) + (1 + 0.105)$$\n$$T_2 = 3 + 2 \\times 5.8 + 1.105$$\n$$T_2 = 3 + 11.6 + 1.105 = 15.705 \\text{ cycles}$$\n\n未合并版本每次迭代的总期望周期数是 $L_1$ 和 $L_2$ 成本的总和：\n$$T_{\\text{unfused}} = T_1 + T_2 = 9.045 + 15.705 = 24.75 \\text{ cycles}$$\n\n接下来，我们计算合并版本每次迭代的期望周期数 $T_{\\text{fused}}$。\n-   算术成本：两个循环的操作被合并，因此算术基础成本为 $c_f = c_1 + c_2 = 2 + 3 = 5$ 个周期。\n-   内存成本：临时数组 $a[i]$ 被消除了。原始的内存引用是在 $L_1$ 中从 $b[i]$ 加载和向 $a[i]$ 存储，以及在 $L_2$ 中从 $a[i]$ 加载和向 $d[i]$ 存储。合并后，对 $a[i]$ 的两次引用被移除。剩下的两个引用是从 $b[i]$ 加载和向 $d[i]$ 存储。题目说明它们的未命中概率分别为 $m_1$ 和 $m_2$。总内存成本是这两个单独引用的期望成本之和。\n    $$T_{\\text{mem,fused}} = (\\text{cost of load } b[i]) + (\\text{cost of store } d[i])$$\n    $$T_{\\text{mem,fused}} = (C_h + m_1 \\times L) + (C_h + m_2 \\times L)$$\n    $$T_{\\text{mem,fused}} = (1 + 0.05 \\times 40) + (1 + 0.12 \\times 40)$$\n    $$T_{\\text{mem,fused}} = (1 + 2) + (1 + 4.8) = 3 + 5.8 = 8.8 \\text{ cycles}$$\n-   分支成本：合并后的循环具有单一的循环控制结构，其基础成本为 $c_{\\mathrm{br}} = 1$，新的预测错误概率为 $p_f = 0.004$。\n    $$T_{\\text{branch,fused}} = c_{\\mathrm{br}} + p_f \\times B = 1 + 0.004 \\times 15 = 1 + 0.06 = 1.06 \\text{ cycles}$$\n\n合并版本每次迭代的总期望周期数是这些组成部分的总和：\n$$T_{\\text{fused}} = T_{\\text{arith,fused}} + T_{\\text{mem,fused}} + T_{\\text{branch,fused}}$$\n$$T_{\\text{fused}} = 5 + 8.8 + 1.06 = 14.86 \\text{ cycles}$$\n\n最后，我们计算加速比 $S$：\n$$S = \\frac{T_{\\text{unfused}}}{T_{\\text{fused}}} = \\frac{24.75}{14.86} \\approx 1.665545087...$$\n将结果四舍五入到 $4$ 位有效数字，得到 $1.666$。",
            "answer": "$$\\boxed{1.666}$$"
        }
    ]
}