{
    "hands_on_practices": [
        {
            "introduction": "编译器会执行诸如死代码消除 (Dead Code Elimination, DCE) 等优化来提升性能。然而，一个有缺陷的 DCE 可能会错误地移除带有副作用的代码，从而改变程序的行为。本练习将使用蜕变测试 (metamorphic testing) 来为 DCE 构建一个验证器。你将学习如何定义和检查一个语义等价关系，以确保优化能够保持程序的可观察输出不变，尤其是在存在全局变量、volatile 操作或原子操作等副作用的情况下。",
            "id": "3643049",
            "problem": "您的任务是在编译器模糊测试（fuzzing compilers）的背景下，设计并实现一个用于死代码消除（dead code elimination）的蜕变测试生成器和检查器。目标是捕获一个在常量守卫（constant guards）下成立的语义保持关系，并检测由于遗漏副作用（missed side effects）而导致的违规行为。您将使用一个模拟可观察输出的小型、确定性的命令式核心。最终交付物必须是一个完整的、可运行的程序，该程序需按指定的确切格式生成单行输出。\n\n本练习的基础源于编译器理论中的两条原则：\n- 语义保持优化：如果一个变换将程序 $P$ 映射到 $P'$，使得对于所有初始状态，两者都产生相同的可观察行为，则该变换是有效的。\n- 死代码消除（DCE）：不影响程序可观察行为的代码可以被消除。对于一个常量守卫，如果一个代码块由一个可证明为始终为假的条件守护，那么当该代码块没有副作用时，执行或移除该代码块都不能改变可观察输出。\n\n我们将程序的可观察行为定义为执行后测量的输出向量。设程序是一个函数 $E(P, \\sigma) \\rightarrow \\mathbf{o}$，它将程序 $P$ 和初始状态 $\\sigma$ 映射到一个输出向量 $\\mathbf{o}$。对于一个常量守卫 $G \\in \\{0,1\\}$ 和一个代码块 $B$：\n- 如果 $B$ 是纯的（没有副作用且不改变可观察输出），那么 $G = 0$ 的程序和 $G = 1$ 的相同程序必须具有相同的 $\\mathbf{o}$，即 $E(P; G \\!=\\! 0, \\sigma) = E(P; G \\!=\\! 1, \\sigma)$。\n- 如果 $B$ 具有副作用（例如，写入全局状态、写入易失性位置、原子操作），那么切换常量守卫可能会改变 $\\mathbf{o}$，这表明 $B$ 影响了可观察行为，因此在DCE下不能被消除。\n\n您的任务是：\n1. 为一小部分安全的命令式操作实现一个确定性求值器，其具有以下可观察输出：\n   - 根据输入 $a$ 和 $b$ 计算出的结果 $r = a \\cdot b + b + a$。\n   - 一个全局状态 $g$。\n   - 一个易失性接收器 $v$。\n   - 一个原子计数器 $c$。\n   可观察输出向量为 $\\mathbf{o} = [r, g, v, c]$。\n\n2. 实现一个蜕变检查器，评估程序的两个版本：一个将常量守卫设置为 $0$（受保护的代码块不执行），另一个设置为 $1$（受保护的代码块执行）。对于每个测试用例，计算距离\n   $$ d = |r_0 - r_1| + |g_0 - g_1| + |v_0 - v_1| + |c_0 - c_1|, $$\n   其中 $\\mathbf{o}_0 = [r_0, g_0, v_0, c_0]$ 是 $G = 0$ 时的输出，$\\mathbf{o}_1 = [r_1, g_1, v_1, c_1]$ 是 $G = 1$ 时的输出。$d = 0$ 的值表示在死代码消除下具有蜕变等价性；$d \\neq 0$ 的值则揭示了可能由副作用引起的可观察差异。\n\n3. 使用一个固定的测试套件，该套件涵盖：\n   - 受保护代码块是纯的且不影响输出的一般情况。\n   - 边界条件，如空代码块。\n   - 受保护代码块包含副作用（全局写入、易失性写入、原子操作）的重要边缘情况。\n\n该迷你语言在受保护代码块内支持以下指令类型：\n- 对局部变量 $x$ 的纯局部算术运算：加上一个常量和乘以一个常量。\n- 副作用操作：\n  - 将全局状态 $g$ 增加一个常量。\n  - 将一个常量写入易失性接收器 $v$。\n  - 对原子计数器 $c$ 执行原子性的取值并加操作，增加一个常量。\n\n基础程序使用输入 $(a,b)$ 并计算 $r = a \\cdot b + b + a$，如果受保护代码块是纯的，则该计算与代码块无关。在任何测试中，受保护的代码块都不直接修改 $r$。\n\n测试套件（所有初始状态和常量均为整数，选择以避免未定义行为）：\n- 情况 1（仅纯局部更改）：\n  - 输入：$(a,b) = (3,4)$。\n  - 初始状态：$(g,v,c) = (10,100,0)$。\n  - 代码块：将局部变量 $x$ 加上 $5$，然后将局部变量 $x$ 乘以 $2$。\n  - 预期蜕变结果：$d = 0$。\n- 情况 2（全局副作用）：\n  - 输入：$(a,b) = (2,5)$。\n  - 初始状态：$(g,v,c) = (0,0,0)$。\n  - 代码块：将全局变量 $g$ 增加 $7$。\n  - 预期蜕变结果：$d = 7$。\n- 情况 3（空代码块边界）：\n  - 输入：$(a,b) = (0,0)$。\n  - 初始状态：$(g,v,c) = (0,0,0)$。\n  - 代码块：空。\n  - 预期蜕变结果：$d = 0$。\n- 情况 4（易失性副作用）：\n  - 输入：$(a,b) = (7,1)$。\n  - 初始状态：$(g,v,c) = (0,3,2)$。\n  - 代码块：通过增量将 $3$ 写入易失性接收器 $v$。\n  - 预期蜕变结果：$d = 3$。\n- 情况 5（原子性副作用）：\n  - 输入：$(a,b) = (4,2)$。\n  - 初始状态：$(g,v,c) = (1,0,5)$。\n  - 代码块：对 $c$ 执行原子性的取值并加 $5$。\n  - 预期蜕变结果：$d = 5$。\n- 情况 6（混合纯操作与副作用）：\n  - 输入：$(a,b) = (1,3)$。\n  - 初始状态：$(g,v,c) = (2,8,0)$。\n  - 代码块：将局部变量 $x$ 加上 $1$，将全局变量 $g$ 增加 $4$，向 $v$ 易失性写入 $2$，对 $c$ 原子性加 $1$。\n  - 预期蜕变结果：$d = 7$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含按测试套件顺序排列的结果，以逗号分隔并用方括号括起来：\n  - 对于上述测试套件，程序必须按以下格式打印单行\n    `[d_1,d_2,d_3,d_4,d_5,d_6]`。\n- 不应打印任何额外文本。\n\n不涉及物理单位。角度不适用。如果需要，请将任何分数表示为小数，尽管此测试套件仅使用整数。\n\n您的实现必须是完全自包含的、确定性的，并且不需要任何输入。它必须遵守最终答案部分中的约束。",
            "solution": "用户提供了一个有效的问题陈述。该问题在编译器理论的原理上具有科学依据，特别涉及像死代码消除（DCE）这样的语义保持优化以及副作用的处理。问题陈述清晰，目标明确，拥有一个确定性的计算模型，以及一套完整的测试用例和预期结果。语言客观且正式。注意到“易失性写入”操作的措辞存在轻微歧义，但通过遵循所提供预期结果的一致性解释得以解决。\n\n核心任务是为编译器的DCE优化实现一个蜕变测试。蜕变测试是一种在没有正式预言机（oracle，即预期正确输出的来源）时用于验证软件属性的技术。它转而检查不同程序输入及其相应输出之间被称为蜕变关系的数学关系的保持情况。\n\n在此背景下，蜕变关系涉及一个包含由常量条件守护的代码块 $B$ 的程序 $P$。设 $E(P, \\sigma) \\rightarrow \\mathbf{o}$ 是一个函数，它以初始状态 $\\sigma$ 执行程序 $P$ 以产生一个可观察的输出向量 $\\mathbf{o}$。两个测试输入是同一程序的两个变体：一个变体中代码块 $B$ 由一个恒为假的条件（例如 `if (0)`）守护，另一个变体中守护条件恒为真（例如 `if (1)`）。\n\n如果代码块 $B$ 是“纯”的，意味着它对程序的可观察状态没有副作用，那么一个正确的DCE优化可以完全消除该代码块及其守护条件。在这种情况下，无论该代码块名义上是否被执行，可观察输出都必须相同。这就得出了蜕变关系：\n$$\nE(P; G = 0, \\sigma) = E(P; G = 1, \\sigma)\n$$\n其中 $G \\in \\{0, 1\\}$ 是常量守卫。\n\n然而，如果代码块 $B$ 包含副作用（例如，修改全局变量、执行I/O或执行原子操作），即使它不贡献于某个特定的计算结果，它也不再是“死代码”。一个正确的编译器不能消除这样的代码块，其执行将改变可观察状态。这导致了蜕变关系的破坏，即 $E(P; G = 0, \\sigma) \\neq E(P; G = 1, \\sigma)$。检测这种差异是我们测试的目标。\n\n可观察输出向量定义为 $\\mathbf{o} = [r, g, v, c]$，其中：\n- $r$ 是一个计算结果，$r = a \\cdot b + b + a$，源自程序输入 $(a,b)$。\n- $g$ 是一个全局整型变量。\n- $v$ 是一个易失性整型接收器，模拟一个其修改是可观察副作用的内存位置。\n- $c$ 是一个原子整型计数器，模拟一个在并发上下文中必须被正确处理的状态。\n\n为了量化两个程序变体输出之间的差异，我们计算输出向量 $\\mathbf{o}_0$（对应守护条件 $G=0$）和 $\\mathbf{o}_1$（对应守护条件 $G=1$）之间的曼哈顿距离 $d$：\n$$\nd = |r_0 - r_1| + |g_0 - g_1| + |v_0 - v_1| + |c_0 - c_1|\n$$\n距离 $d=0$ 表明蜕变关系成立，说明受保护的代码块相对于可观察状态是纯的。距离 $d \\neq 0$ 表明关系被破坏，从而正确识别出副作用的存在。\n\n实现策略如下：\n1.  定义数据结构来表示测试用例参数（`TestCase`）、初始状态（`InitialState`）、程序的运行时状态（`RuntimeState`，包括 `_Atomic` 计数器）以及最终的输出向量（`OutputVector`）。\n2.  实现一个求值器函数 `evaluate`，该函数模拟程序执行。此函数接受一个测试用例和一个守护值（$0$ 或 $1$）作为输入。它初始化 `RuntimeState`，计算结果 $r$，并且如果守护值为 $1$，则调用一个辅助函数 `execute_guarded_block` 来应用受保护代码块内的操作。最后，它组装并返回 `OutputVector`。\n3.  `execute_guarded_block` 函数使用一个 `switch` 语句为 6 个测试用例中的每一个实现逻辑。它通过指针修改传入的 `RuntimeState`。涉及全局状态 $g$、易失性接收器 $v$ 和原子计数器 $c$ 的操作直接修改 `RuntimeState` 结构体中的相应字段。原子操作使用 `stdatomic.h` 中的函数正确实现，以模拟编译器必须遵守的语义。\n4.  `main` 函数将测试套件定义为一个 `TestCase` 结构体数组。它遍历此数组，对每个测试用例分别使用守护条件 $G=0$ 和 $G=1$ 调用 `evaluate` 函数，以获得 $\\mathbf{o}_0$ 和 $\\mathbf{o}_1$。\n5.  对于每个测试用例，它计算距离 $d$ 并存储它。\n6.  最后，它以精确的格式 $[d_1,d_2,d_3,d_4,d_5,d_6]$ 打印所有计算出的距离。\n\n问题描述中的一个轻微歧义，“通过增量将 $X$ 写入 $Y$”，对于易失性和全局写入均被解释为 `Y += X`，因为这是唯一能产生所提供预期结果并确保内部一致性的解释。",
            "answer": "```c\n#include"
        },
        {
            "introduction": "诸如循环不变量代码外提 (Loop Invariant Code Motion, LICM) 等高级优化依赖于精确的静态分析（如别名分析）来确保其安全性。模糊测试器不仅需要能测试最终的程序输出，还必须能检验编译器的内部推理过程。在本练习中，你将为 LICM 实现别名分析检查器的核心逻辑。通过对内存地址进行建模并求解潜在的重叠，你将获得验证这一最重要编译器优化之一其安全前提条件的实践经验。",
            "id": "3643001",
            "problem": "你需要编写一个完整、可运行的程序，该程序使用一个简化的、可靠的别名分析模型，来评估在循环不变代码外提（LICM）中将加载操作提升出循环的安全性。其目的是模拟一个模糊测试框架，该框架生成指针密集型模式，并验证 LICM 是否只外提那些通过无别名推理可证明为不变的加载操作。\n\n基本原理。从编译器理论中的以下标准定义开始：\n\n- 内存地址被建模为一个序对 $\\left(i, o\\right)$，其中 $i$ 是内存对象标识符（一个用于区分不同分配的整数索引），$o$ 是该对象内的字节偏移量。两个地址 $\\left(i, o\\right)$ 和 $\\left(j, p\\right)$ 发生别名，当且仅当 $i = j$ 且 $o = p$。\n- 循环归纳变量 $k$ 在单位步长的整数范围内变化，即 $k \\in \\left[L, U\\right)$，其中 $L$ 和 $U$ 是整数，迭代集合为 $\\{L, L+1, \\dots, U-1\\}$。\n- 加载地址是循环变量的仿射（线性）函数，$o_L(k) = a_L \\cdot k + b_L$，其中 $a_L$ 和 $b_L$ 为整数。存储地址类似，$o_S(k) = a_S \\cdot k + b_S$。\n- 循环不变表达式是指其值在循环的各次迭代中不发生变化的表达式。对于加载地址而言，这意味着 $a_L = 0$（因此对所有 $k$，$o_L(k) = b_L$ 是一个常量）。\n- 当且仅当加载操作的地址是循环不变的，并且所读取的内存位置不被循环内的任何存储操作所覆盖时，循环不变代码外提（LICM）才可以将该加载操作从循环内部提升到循环之前。在上述别名模型下，这意味着对于任何迭代 $k \\in [L,U)$，都不能存在其地址与加载地址发生别名的存储操作。\n\n你的程序必须实现以下逻辑推导和决策过程：\n\n1. 对于给定的加载地址 $o_L(k) = a_L \\cdot k + b_L$，外提的一个必要条件是地址的循环不变性。即，检查 $a_L = 0$。如果 $a_L \\neq 0$，则该加载操作不能被外提。\n2. 假设 $a_L = 0$，则加载地址是对象 $i_L$ 内的常量偏移 $b_L$。对于循环中每一个地址为 $o_S(k) = a_S \\cdot k + b_S$、目标对象为 $i_S$ 的存储操作：\n   - 如果 $i_S \\neq i_L$，根据不同对象的定义，该存储不可能与加载发生别名，可以忽略。\n   - 如果 $i_S = i_L$ 且 $a_S = 0$，则该存储与加载发生别名，当且仅当 $b_S = b_L$。\n   - 如果 $i_S = i_L$ 且 $a_S \\neq 0$，则该存储与加载发生别名，当且仅当存在一个整数 $k \\in [L, U)$ 使得 $a_S \\cdot k + b_S = b_L$。这等价于存在一个整数解\n     $$ k = \\frac{b_L - b_S}{a_S} $$\n     同时满足 $a_S \\mid (b_L - b_S)$ 和 $L \\le k  U$。\n3. LICM 外提是安全的，当且仅当加载地址是循环不变的，并且循环中没有任何存储操作在任何迭代中与该加载发生别名。\n\n建模说明：\n\n- 别名模型通过构造将不同的内存对象标识符视为不相交的，这代表了从分配来源或限定不相交性推导出的无别名证明。在同一对象内，别名问题简化为偏移量的整数相等性问题。\n- 循环是单位步长的，因此迭代集合是一个连续的整数区间。你必须使用精确整数算术来测试可除性和边界。\n\n输入模型。没有输入。你的程序必须嵌入并评估以下固定的测试套件。每个测试包含边界 $L$、$U$、一个加载描述 $(i_L, a_L, b_L)$ 和一个存储列表 $\\{(i_{S_t}, a_{S_t}, b_{S_t})\\}_{t=1}^m$。\n\n测试套件：\n\n- 测试 $1$：$L=0$, $U=10$, 加载 $(i_L=0, a_L=0, b_L=16)$；存储 $\\{(1, 1, 0)\\}$。\n- 测试 $2$：$L=0$, $U=7$, 加载 $(i_L=0, a_L=0, b_L=16)$；存储 $\\{(0, 0, 24)\\}$。\n- 测试 $3$：$L=0$, $U=5$, 加载 $(i_L=0, a_L=0, b_L=16)$；存储 $\\{(0, 0, 16)\\}$。\n- 测试 $4$：$L=0$, $U=4$, 加载 $(i_L=2, a_L=0, b_L=8)$；存储 $\\{(2, 4, 0)\\}$。\n- 测试 $5$：$L=0$, $U=3$, 加载 $(i_L=5, a_L=0, b_L=8)$；存储 $\\{(5, 3, 1)\\}$。\n- 测试 $6$：$L=0$, $U=5$, 加载 $(i_L=1, a_L=2, b_L=0)$；存储 $\\{\\}$。\n- 测试 $7$：$L=0$, $U=10$, 加载 $(i_L=6, a_L=0, b_L=8)$；存储 $\\{(7, 0, 8), (6, 0, 12), (6, 2, 1)\\}$。\n\n你的程序必须为每个测试计算布尔决策“可以安全外提”，其中结果为 $1$ 代表“可以安全外提”，$0$ 代表“不可以安全外提”。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，格式完全如下：\n`[r_1,r_2,r_3,r_4,r_5,r_6,r_7]`\n其中每个 $r_t$ 对于按顺序排列的测试 $t$ 要么是 $0$ 要么是 $1$。输出字符串中不允许有空格。此问题中没有物理单位，也没有角度，任何小数值都必须按规定使用精确整数算术计算。",
            "solution": "该问题要求实现一个决策过程，以确定将加载指令提升出循环的安全性，这是一种被称为循环不变代码外提（LICM）的常见编译器优化。安全性检查基于一个已定义的内存地址和别名分析模型。解决方案是通过系统地应用所提供的规则得出的。\n\n内存地址是一个序对 $(i, o)$，其中 $i$ 是一个整数对象标识符，$o$ 是一个字节偏移量。两个地址 $(i, o)$ 和 $(j, p)$ 发生别名，当且仅当 $i = j$ 且 $o = p$。加载和存储的循环相关地址被建模为循环归纳变量 $k$ 的仿射函数，该变量在整数范围 $[L, U)$ 内迭代，即 $k \\in \\{L, L+1, \\dots, U-1\\}$。加载地址偏移量为 $o_L(k) = a_L \\cdot k + b_L$，存储地址偏移量为 $o_S(k) = a_S \\cdot k + b_S$。\n\n该决策过程遵循一个两步的逻辑进展。\n\n首先，只有当加载的有效地址是循环不变时，才能考虑将其外提。这意味着它的值在一次迭代到下一次迭代之间不会改变。对于地址函数 $o_L(k) = a_L \\cdot k + b_L$，这要求循环归纳变量 $k$ 的系数必须为零。\n$$ a_L = 0 $$\n如果 $a_L \\neq 0$，加载地址随每次迭代而改变，使其本质上是循环变化的。这样的加载不能被外提，决策过程判定其为不安全。\n\n其次，如果加载地址是循环不变的（即 $a_L = 0$，因此地址是对象 $i_L$ 内的常量偏移 $b_L$），我们必须保证循环内的任何存储指令都不会修改（覆盖）这个内存位置。这需要检查循环中的每一个存储操作与该加载的关系。对于由 $(i_S, a_S, b_S)$ 描述的每个存储，我们分析潜在的别名。\n\n别名分析对每个存储按以下情况进行区分：\n1.  **不相交的内存对象**：如果存储操作作用于与加载不同的内存对象，即 $i_S \\neq i_L$，根据问题的定义，它们保证不会发生别名。该存储相对于此加载是良性的。\n\n2.  **相同的内存对象，不变的存储地址**：如果存储到相同的对象（$i_S = i_L$）并且其地址也是循环不变的（$a_S = 0$），那么加载和存储都访问常量偏移量。当且仅当这些常量偏移量相等时，才会发生别名：\n    $$ b_S = b_L $$\n    如果此条件成立，则加载在每次迭代中都会被覆盖，外提是不安全的。\n\n3.  **相同的内存对象，变化的存储地址**：如果存储到相同的对象（$i_S = i_L$）但其地址是循环变化的（$a_S \\neq 0$），则如果存在一个在范围 $[L, U)$ 内的整数迭代 $k$，使得存储地址等于加载地址，就会发生别名。我们必须为整数 $k$ 求解以下方程：\n    $$ a_S \\cdot k + b_S = b_L $$\n    重新整理 $k$ 可得：\n    $$ k = \\frac{b_L - b_S}{a_S} $$\n    要存在别名，必须同时满足两个条件：\n    a. 该方程必须有整数解 $k$。这当且仅当分子是分母的整数倍时才成立，可以使用模运算符进行检查：$(b_L - b_S) \\pmod{a_S} = 0$。\n    b. 整数解 $k$ 必须在循环的迭代集合内，即 $L \\le k  U$。\n\n如果对于任何存储，通过情况2或情况3检测到别名，则无别名保证被违反，外提是不安全的。\n\n当且仅当加载地址是循环不变的（$a_L = 0$）并且循环内绝对没有任何存储操作在任何迭代 $k \\in [L, U)$ 中与加载地址发生别名时，LICM 才被确定为是安全的。程序为每个测试用例实现了这一逻辑，对于‘可以安全外提’产生结果 1，对于‘不可以安全外提’产生结果 0。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include"
        },
        {
            "introduction": "在 C 和 C++ 等语言中，未定义行为 (Undefined Behavior, UB) 允许编译器进行激进的优化，但它也是许多隐蔽错误的根源。模糊测试是发现编译器过度利用 UB 所导致错误的有效方法。本练习将指导你构建一个基于变异 (mutation-based) 的、针对 UB 的模糊测试器。通过创建一个对 UB 有明确语义的玩具语言，并实现一个模拟编译器激进假设的变异算子，你将亲眼见证对 UB 的依赖如何导致程序行为产生可观察的差异。",
            "id": "3642978",
            "problem": "给定一个简化场景，您需要在此场景中通过使用变异算子来检测对未定义行为的依赖，从而探索对编译器进行模糊测试的方法。任务是为一种玩具表达式语言构建一个小型解释器，该语言模拟整数计算和未定义行为的概念；应用一个系统性的变异算子，该算子移除由未定义行为保护的分支；并在一个有限的输入环境测试套件上，比较原始程序（在有定义语义下解释）与变异后程序的输出。\n\n基本原理和定义：\n- 编译器优化正确性的指导原则是语义保持：优化不得改变程序的可观察语义。如果编译器依赖于未定义行为（UB），它可能会做出一些在有定义语义下无法保证的假设。我们通过一种部分语义来对 UB 进行建模，该语义可能无法产生一个有定义的整数结果。\n- 考虑一个包含变量 $x$、$y$ 和 $z$ 的玩具整数输入表达式语言，以及以下表达式：常量、变量、加法、减法、乘法、一种检查除法、一个有定义性谓词和一个条件表达式。形式上，表达式 $E$ 由以下部分构成：\n  1. $E ::= c$，其中 $c \\in \\mathbb{Z}$。\n  2. $E ::= x \\mid y \\mid z$。\n  3. $E ::= E_1 + E_2 \\mid E_1 - E_2 \\mid E_1 \\times E_2$。\n  4. $E ::= \\mathrm{div\\_checked}(E_1,E_2)$。\n  5. $E ::= \\mathrm{is\\_defined}(E)$。\n  6. $E ::= \\mathrm{if}(C, T, F)$，其中 $C$ 是一个条件表达式，其结果为一个整数，该整数被解释为布尔值（非零为真，零为假）。\n- 语义将表达式映射到一个有定义的整数或一个未定义的结果。设 $\\llbracket E \\rrbracket(\\rho)$ 表示在环境 $\\rho$ 下对 $E$ 的求值，其中 $\\rho$ 为变量 $x$、$y$ 和 $z$ 赋予整数值。我们定义：\n  1. 常量和变量：$\\llbracket c \\rrbracket(\\rho) = \\langle \\mathrm{def}, c \\rangle$，$\\llbracket x \\rrbracket(\\rho) = \\langle \\mathrm{def}, \\rho(x) \\rangle$，$y$ 和 $z$ 同理。\n  2. 二元算术运算：对于 $E_1 \\circ E_2$，其中 $\\circ \\in \\{+, -, \\times\\}$，如果 $\\llbracket E_1 \\rrbracket(\\rho)$ 或 $\\llbracket E_2 \\rrbracket(\\rho)$ 是未定义的，则结果是未定义的；否则，结果是整数算术运算的结果。\n  3. 检查除法：如果任一操作数是未定义的，或者除数求值为 $0$，则 $\\llbracket \\mathrm{div\\_checked}(E_1,E_2) \\rrbracket(\\rho)$ 是未定义的；否则，结果为整数除法 $E_1 / E_2$。\n  4. 有定义性谓词：$\\llbracket \\mathrm{is\\_defined}(E) \\rrbracket(\\rho) = \\langle \\mathrm{def}, b \\rangle$，其中如果 $\\llbracket E \\rrbracket(\\rho)$ 有定义，则 $b = 1$；否则 $b = 0$。该谓词本身不会变为未定义。\n  5. 条件表达式：$\\llbracket \\mathrm{if}(C,T,F) \\rrbracket(\\rho)$ 首先对 $C$ 求值。如果 $C$ 是未定义的，有定义语义会将其视为假，选择 $F$；如果 $C$ 有定义且非零，则求值并返回 $\\llbracket T \\rrbracket(\\rho)$；如果 $C$ 有定义且为零，则求值并返回 $\\llbracket F \\rrbracket(\\rho)$。如果所选分支求值为未定义，则结果是未定义的。\n\n变异算子：\n- 变异算子通过移除检查有定义性的保护条件，来模拟一类依赖于未定义行为的编译器变换。该算子 $\\mathcal{M}$ 作用于抽象语法树，并将任何形式为 $\\mathrm{if}(\\mathrm{is\\_defined}(E), T, F)$ 的条件表达式替换为分支 $T$，从而系统地移除了“未定义”分支 $F$。该算子会递归地作用于子表达式，以产生一个变异后的程序 $\\mathcal{M}(E)$。\n\n任务：\n- 实现上述定义的玩具语言的解释器，并实现变异算子 $\\mathcal{M}$。\n- 对于下方的每个测试用例，将程序实例化为一个抽象语法树 $E$，应用 $\\mathcal{M}$ 得到变异后的程序 $\\mathcal{M}(E)$，并在指定的输入环境 $\\rho$ 上比较 $\\llbracket E \\rrbracket(\\rho)$ 和 $\\llbracket \\mathcal{M}(E) \\rrbracket(\\rho)$ 的输出。一个环境 $\\rho$ 是一个三元组 $(x,y,z) \\in \\mathbb{Z}^3$。如果两个结果都有定义且整数值相等，则认为它们相等；否则它们不相等。\n- 您的程序的最终输出必须是单行文本，其中包含一个用方括号括起来的、由逗号分隔的整数 $0$ 或 $1$ 的列表，其中每个条目对应一个测试用例，如果变异后的程序在所有列出的环境下都与原始程序观察等价，则为 $1$，否则为 $0$。\n\n测试套件：\n- 测试用例 1（基本的带回退机制的受保护除法）：\n  - 程序 $E_1 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)), \\mathrm{div\\_checked}(x,y) + 1, 0)$。\n  - 环境：$(10,2,0)$、$(10,0,0)$、$(0,5,0)$、$(-9,3,0)$。\n- 测试用例 2（始终有定义的保护条件，正常路径）：\n  - 程序 $E_2 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)), x \\times 2, -1)$。\n  - 环境：$(7,123,0)$、$(-8,42,0)$、$(0,999,0)$。\n- 测试用例 3（嵌套保护，多个潜在的未定义点）：\n  - 程序 $E_3 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)), \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)), \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z), 7), 8)$。\n  - 环境：$(12,3,2)$、$(12,0,2)$、$(12,3,0)$、$(0,10,2)$、$(9,-3,-3)$。\n- 测试用例 4（由于分支相同，移除保护条件是保持语义的）：\n  - 程序 $E_4 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)), x + 0, x + 0)$。\n  - 环境：$(5,100,0)$、$(-1,2,0)$。\n\n最终输出格式：\n- 您的程序应产生一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i \\in \\{0,1\\}$ 对应测试用例 $i$ 的等价性检查结果。",
            "solution": "用户提供的问题陈述是有效的。这是一个在计算机科学领域内，特别是在编译器理论和程序语义学方面，定义良好且具有科学依据的问题。它提供了一个形式化系统，包含一种玩具编程语言、一套包括未定义行为概念在内的有定义操作语义，以及一个旨在模拟依赖于未定义行为假设的编译器优化的变异算子。任务是实现这个系统，将其应用于一组给定的测试用例，并确定原始程序与变异程序之间的观察等价性。该问题是自包含的、逻辑一致的且没有歧义。\n\n解决方案首先构建必要的数据结构来表示该语言的抽象语法树（AST）。然后，实现两个主要函数：一个根据指定语义计算表达式值的解释器，以及一个根据给定算子规则转换表达式AST的变异函数。最后，通过构建程序的AST、对其进行变异，并在一个输入环境套件上比较原始AST和变异AST的求值结果来执行每个测试用例。\n\n### 1. 数据表示和语义\n\n表达式 $E$ 表示为AST中的一个节点。每个节点包含一个类型标签和一个与该类型对应的有效载荷（例如，一个常量值、一个变量标识符，或指向操作子节点的指针）。\n\n求值语义 $\\llbracket E \\rrbracket(\\rho)$ 将一个表达式 $E$ 和一个环境 $\\rho$（一个从变量 $x, y, z$到整数值的映射）映射到一个结果。结果是一个二元组 $\\langle \\text{status}, \\text{value} \\rangle$，其中status（状态）为有定义或未定义。这通过一个包含布尔标志和整数值的结构来实现。\n\n解释器是一个递归函数 `eval(E, rho)`，它遍历AST。\n- 对于常量和变量，它直接从AST节点或环境 $\\rho$ 返回有定义的值。\n- 对于算术运算 $E_1 \\circ E_2$（其中 $\\circ \\in \\{+, -, \\times\\}$），它递归地对 $E_1$ 和 $E_2$ 求值。如果任一子求值导致未定义状态，则该操作的结果也为未定义。否则，执行整数运算。\n- 对于 $\\mathrm{div\\_checked}(E_1, E_2)$，它遵循算术运算的逻辑，但增加了对除数的检查：如果 $\\llbracket E_2 \\rrbracket(\\rho)$ 的值为 $0$，则结果为未定义。\n- 谓词 $\\llbracket \\mathrm{is\\_defined}(E) \\rrbracket(\\rho)$ 对 $E$ 求值。如果 $\\llbracket E \\rrbracket(\\rho)$ 有定义，它返回一个有定义的结果 $\\langle \\mathrm{def}, 1 \\rangle$；如果 $\\llbracket E \\rrbracket(\\rho)$ 无定义，则返回 $\\langle \\mathrm{def}, 0 \\rangle$。此操作本身永远不会产生未定义结果。\n- 条件表达式 $\\llbracket \\mathrm{if}(C, T, F) \\rrbracket(\\rho)$ 是独特的。它首先对条件 $C$ 求值。如果 $\\llbracket C \\rrbracket(\\rho)$ 是未定义的，语义规定将其视为假条件，因此对假分支 $F$ 求值。如果 $\\llbracket C \\rrbracket(\\rho)$ 有定义，其整数值被视为布尔值（$0$ 为假，非零为真）以选择 $T$ 或 $F$ 分支进行求值。\n\n### 2. 变异算子\n\n变异算子 $\\mathcal{M}$ 实现为一个递归函数 `mutate(E)`，它构建一个新的、变异后的AST。转换是组合的：\n- 对于 `if` 以外的表达式类型，算子对子表达式递归调用，并用变异后的子表达式重建相同类型的表达式。例如，$\\mathcal{M}(E_1+E_2) = \\mathcal{M}(E_1) + \\mathcal{M}(E_2)$。\n- 对于条件表达式 $\\mathrm{if}(C, T, F)$，算子检查条件 $C$。\n  - 如果 $C$ 的形式是 $\\mathrm{is\\_defined}(E')$，整个 `if` 表达式将被替换为对真分支 $T$ 进行变异的结果。即 $\\mathcal{M}(\\mathrm{if}(\\mathrm{is\\_defined}(E'), T, F)) = \\mathcal{M}(T)$。这模拟了编译器假设保护条件总是为真，从而消除检查和假分支。\n  - 否则，算子递归地进入所有三个子表达式：$\\mathcal{M}(\\mathrm{if}(C, T, F)) = \\mathrm{if}(\\mathcal{M}(C), \\mathcal{M}(T), \\mathcal{M}(F))$。\n\n### 3. 测试用例分析\n\n对于给定的测试用例，一个程序与其变异版本是观察等价的，当且仅当对于每个指定的环境 $\\rho$，$\\llbracket E \\rrbracket(\\rho)$ 和 $\\llbracket \\mathcal{M}(E) \\rrbracket(\\rho)$ 要么都是未定义的，要么都有定义且具有相同的整数值。\n\n**测试用例 1：** $E_1 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{div\\_checked}(x,y) + 1,\\, 0)$\n- 变异后的程序：$\\mathcal{M}(E_1) = \\mathcal{M}(\\mathrm{div\\_checked}(x,y) + 1) = \\mathrm{div\\_checked}(x,y) + 1$。\n- 环境 $(10, 0, 0)$：\n  - $\\llbracket E_1 \\rrbracket((10,0,0))$：$\\mathrm{div\\_checked}(10,0)$ 是未定义的。$\\mathrm{is\\_defined}(\\dots)$ 为假（$0$）。`if` 语句计算其假分支，产生一个有定义的结果 $0$。\n  - $\\llbracket \\mathcal{M}(E_1) \\rrbracket((10,0,0))$：$\\mathrm{div\\_checked}(10,0) + 1$ 试图计算除以零，导致一个未定义的结果。\n- 结果不同（$0$ vs. 未定义）。因此，等价性为 $0$。\n\n**测试用例 2：** $E_2 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x \\times 2,\\, -1)$\n- 变异后的程序：$\\mathcal{M}(E_2) = \\mathcal{M}(x \\times 2) = x \\times 2$。\n- 条件 $\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1))$ 对于任何整数 $x$ 总是为真，因为除以 $1$ 总是被定义的。\n- 因此，$\\llbracket E_2 \\rrbracket(\\rho)$ 总是计算真分支 $x \\times 2$，这与变异后的程序 $\\mathcal{M}(E_2)$ 相同。\n- 对于所有输入，程序是等价的。因此，等价性为 $1$。\n\n**测试用例 3：** $E_3 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)),\\, \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z),\\, 7),\\, 8)$\n- 变异后的程序：变异算子被递归应用。外部 `if` 条件匹配模式，因此它被其真分支的变异结果所取代。真分支是另一个也匹配该模式的 `if`。\n  - $\\mathcal{M}(E_3) = \\mathcal{M}(\\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)), \\dots, 7))$\n  - $= \\mathcal{M}(\\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z)) = \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z)$。\n- 环境 $(12, 0, 2)$：\n  - $\\llbracket E_3 \\rrbracket((12,0,2))$：$\\mathrm{div\\_checked}(12,0)$ 是未定义的。外部 `is_defined` 为假（$0$）。`if` 语句计算假分支，产生一个有定义的结果 $8$。\n  - $\\llbracket \\mathcal{M}(E_3) \\rrbracket((12,0,2))$：$\\mathrm{div\\_checked}(12,0) + \\mathrm{div\\_checked}(0,2)$ 由于第一项而未定义。\n- 结果不同（$8$ vs. 未定义）。因此，等价性为 $0$。\n\n**测试用例 4：** $E_4 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x + 0,\\, x + 0)$\n- 变异后的程序：$\\mathcal{M}(E_4) = \\mathcal{M}(x+0) = x+0$。\n- 条件 $\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1))$ 总是为真。原始程序总是计算真分支 $x+0$。\n- 真假分支是相同的，并且变异后的程序也等价于 $x+0$。因此，原始程序和变异程序对于所有输入将产生相同的结果。\n- 程序是等价的。因此，等价性为 $1$。\n\n测试用例的最终结果是 $[0, 1, 0, 1]$。",
            "answer": "```c\n#include"
        }
    ]
}