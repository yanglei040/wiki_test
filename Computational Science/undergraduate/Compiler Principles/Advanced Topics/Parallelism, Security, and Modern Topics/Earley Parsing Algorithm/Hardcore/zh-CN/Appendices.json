{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握 Earley 算法，最好的方法莫过于亲手实践。这个练习  将引导你逐步执行该算法，在一个简单但高度模糊的文法上，手动追踪预测（Predictor）、扫描（Scanner）和完成（Completer）这三个核心操作。通过构建分析表（chart），你不仅能深入理解算法的内部机制，还能直观地看到 Earley 算法是如何优雅地处理歧义性，并发现一个输入字符串所有可能的分析树。",
            "id": "3639800",
            "problem": "考虑上下文无关文法（CFG）$G$，其开始符号为 $S$，产生式为 $S \\to S\\,S \\mid a$。设输入串为长度为 $3$ 的 $\\mathtt{aaa}$。使用 Earley 分析算法，该算法将状态表示为点项 $[A \\to \\alpha\\,\\cdot\\,\\beta, i]$，其中 $A$ 是一个非终结符，$\\alpha$ 和 $\\beta$ 是终结符和非终结符串（可能为空），点表示在产生式右侧的当前位置，$i$ 是该成分开始的起始位置索引。Earley 算法使用三个基本操作：预测器（Predictor）（为紧邻点右侧的非终结符添加产生式）、扫描器（Scanner）（消耗输入中一个匹配的终结符以推进点的位置）和完成器（Completer）（当一个成分分析完成时，它会推进在其起始位置等待该成分的任何状态）。使用新的开始符号 $S'$ 和产生式 $S' \\to S$ 来增广该文法。\n\n为输入 $\\mathtt{aaa}$ 构建 Earley 分析表 $C_0, C_1, C_2, C_3$，显示在每个位置由预测器、扫描器和完成器创建的项目，并保持起始位置索引。根据已完成的项目以及由完成器步骤隐含的回溯指针，从基本原理推断该算法在文法 $G$ 下为 $\\mathtt{aaa}$ 找到了多少棵不同的分析树。请以单个整数形式给出最终答案。无需四舍五入，答案中不应包含任何单位。",
            "solution": "首先，我们将文法 $G$ 进行增广，引入新的开始符号 $S'$ 和产生式 $S' \\to S$。增广后的文法 $G'$ 为：\n$S' \\to S$\n$S \\to S\\,S$\n$S \\to a$\n\n输入串为 $\\mathtt{aaa}$，我们将其表示为 $w = w_1 w_2 w_3$，其中 $w_1=w_2=w_3=\\mathtt{a}$。我们构建 Earley 分析表 $C_0, C_1, C_2, C_3$。一个项目（item）的形式为 $[A \\to \\alpha\\,\\cdot\\,\\beta, i]$，其中 $i$ 是输入串中的起始位置索引（从 $0$ 开始）。\n\n**分析表 $C_0$：**\n初始化，并在索引 $0$ 处对增广开始规则应用预测器，直到没有新项目可以添加。\n1. $[S' \\to \\cdot S, 0]$ (种子项)\n2. $[S \\to \\cdot S\\,S, 0]$ (对项目 1 进行预测)\n3. $[S \\to \\cdot a, 0]$ (对项目 1 进行预测)\n\n**分析表 $C_1$（处理输入 $w_1 = \\mathtt{a}$ 后）：**\n首先对 $C_0$ 中期望终结符 $\\mathtt{a}$ 的项目应用扫描器，然后运行完成器和预测器直到达到不动点。\n1. $[S \\to a \\cdot, 0]$ (对 $C_0$ 中的 $[S \\to \\cdot a, 0]$ 进行扫描)\n2. $[S' \\to S \\cdot, 0]$ (对项目 1 进行完成，推进 $C_0$ 中的 $[S' \\to \\cdot S, 0]$)\n3. $[S \\to S \\cdot S, 0]$ (对项目 1 进行完成，推进 $C_0$ 中的 $[S \\to \\cdot S S, 0]$)\n4. $[S \\to \\cdot S\\,S, 1]$ (对项目 3 进行预测，因为当前位置为 $1$)\n5. $[S \\to \\cdot a, 1]$ (对项目 3 进行预测)\n\n**分析表 $C_2$（处理输入 $w_2 = \\mathtt{a}$ 后）：**\n1. $[S \\to a \\cdot, 1]$ (对 $C_1$ 中的 $[S \\to \\cdot a, 1]$ 进行扫描)\n   现在用这个新完成的项目 $[S \\to a \\cdot, 1]$ (一个跨越索引 $1$ 到 $2$ 的 $S$) 应用完成器。\n2. $[S \\to S \\cdot S, 1]$ (对项目 1 进行完成，推进 $C_1$ 中的 $[S \\to \\cdot S\\,S, 1]$)\n3. $[S \\to S\\,S \\cdot, 0]$ (对项目 1 进行完成，推进 $C_1$ 中的 $[S \\to S \\cdot S, 0]$，这是一个跨越 $0$ 到 $2$ 的已完成 $S$)\n   现在对新完成的项目 3 应用完成器。\n4. $[S' \\to S \\cdot, 0]$ (对项目 3 进行完成，推进 $C_0$ 中的 $[S' \\to \\cdot S, 0]$)\n5. $[S \\to S \\cdot S, 0]$ (对项目 3 进行完成，推进 $C_0$ 中的 $[S \\to \\cdot S\\,S, 0]$)\n   最后，应用预测器。\n6. $[S \\to \\cdot S\\,S, 2]$ (对项目 2 和 5 进行预测，因为当前位置为 $2$)\n7. $[S \\to \\cdot a, 2]$ (对项目 2 和 5 进行预测)\n\n**分析表 $C_3$（处理输入 $w_3 = \\mathtt{a}$ 后）：**\n1. $[S \\to a \\cdot, 2]$ (对 $C_2$ 中的 $[S \\to \\cdot a, 2]$ 进行扫描)\n   这是一个从索引 $2$ 到 $3$ 的已完成 $S$。我们运行完成器。\n2. $[S \\to S \\cdot S, 2]$ (对项目 1 进行完成，推进 $C_2$ 中的 $[S \\to \\cdot S\\,S, 2]$)\n3. $[S \\to S\\,S \\cdot, 1]$ (对项目 1 进行完成，推进 $C_2$ 中的 $[S \\to S \\cdot S, 1]$，这是一个从 $1$ 到 $3$ 的已完成 $S$)\n4. $[S \\to S\\,S \\cdot, 0]$ (对项目 1 进行完成，推进 $C_2$ 中的 $[S \\to S \\cdot S, 0]$，这是形成一个从 $0$ 到 $3$ 的已完成 $S$ 的**第一种方式**)\n   我们用新完成的项目继续运行完成器。项目 3 ($S$ 跨越 $1-3$) 可以完成等待中的项目。\n5. $[S \\to S\\,S \\cdot, 0]$ 的**第二种推导** (对项目 3 进行完成，推进 $C_1$ 中的 $[S \\to S \\cdot S, 0]$)。\n   项目 $[S \\to S\\,S \\cdot, 0]$ 无论如何推导，都代表从 $0$ 到 $3$ 的已完成 $S$。它们会触发来自 $C_0$ 的进一步完成。\n6. $[S' \\to S \\cdot, 0]$ (对项目 4 和 5 进行完成，推进 $C_0$ 中的 $[S' \\to \\cdot S, 0]$)。这个项目表示成功分析了整个字符串。\n7. $[S \\to S \\cdot S, 0]$ (对项目 4 和 5 进行完成，推进 $C_0$ 中的 $[S \\to \\cdot S\\,S, 0]$)。\n项目 $[S' \\to S \\cdot, 0]$ 出现在 $C_3$ 中证实了字符串 $\\mathtt{aaa}$ 属于该语言。\n\n**计算分析树：**\n不同分析树的数量等于最终接受项目 $[S' \\to S \\cdot, 0]$ 在 $C_3$ 中的不同推导数量。由于 $S' \\to S$ 是无歧义的，这等于形成一个跨越索引 $0$ 到 $3$ 的成分 $S$ 的方式数量。\n\n让 $N(A, i, j)$ 表示非终结符 $A$ 跨越从索引 $i$ 到 $j$ 的输入子串的不同分析树的数量。\n- 由终结符产生式（如 $S \\to a$）生成的成分只有一个推导：\n  - $N(S, 0, 1) = 1$ (来自 $C_1$ 中的 $[S \\to a \\cdot, 0]$)\n  - $N(S, 1, 2) = 1$ (来自 $C_2$ 中的 $[S \\to a \\cdot, 1]$)\n  - $N(S, 2, 3) = 1$ (来自 $C_3$ 中的 $[S \\to a \\cdot, 2]$)\n\n- 对于递归产生式 $S \\to S\\,S$，我们对所有可能的分割点 $k$ 求和：$N(S, i, j) = \\sum_{k=i+1}^{j-1} N(S, i, k) \\times N(S, k, j)$。\n\n- 计算子串 $\\mathtt{aa}$ 的 $N(S, 0, 2)$ (分割点 $k=1$):\n  $N(S, 0, 2) = N(S, 0, 1) \\times N(S, 1, 2) = 1 \\times 1 = 1$。\n\n- 计算子串 $\\mathtt{aa}$ 的 $N(S, 1, 3)$ (分割点 $k=2$):\n  $N(S, 1, 3) = N(S, 1, 2) \\times N(S, 2, 3) = 1 \\times 1 = 1$。\n\n- 最后，计算完整字符串 $\\mathtt{aaa}$ 的 $N(S, 0, 3)$ (分割点 $k=1, 2$):\n  $N(S, 0, 3) = N(S, 0, 1) \\times N(S, 1, 3) + N(S, 0, 2) \\times N(S, 2, 3)$\n  代入已知值：\n  $N(S, 0, 3) = (1 \\times 1) + (1 \\times 1) = 1 + 1 = 2$。\n\n这两个项对应于两种不同的分析方式：\n1. **右结合**: $S \\to S_{0,1} S_{1,3} \\to a (aa)$。这对应于用一个跨越 $(1,3)$ 的 $S$ (即 $[S \\to S\\,S \\cdot, 1]$) 来完成 $C_1$ 中的 $[S \\to S \\cdot S, 0]$。\n2. **左结合**: $S \\to S_{0,2} S_{2,3} \\to (aa) a$。这对应于用一个跨越 $(2,3)$ 的 $S$ (即 $[S \\to a \\cdot, 2]$) 来完成 $C_2$ 中的 $[S \\to S \\cdot S, 0]$。\n\n由于有两种方式可以推导出跨越整个输入的 $S$，该算法发现了两棵不同的分析树。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "在通过上一个练习  理解了 Earley 算法的基本工作原理之后，一个自然而然的问题是：它的性能如何？解析器的效率在很大程度上取决于文法的结构。本练习  将让你通过对比分析，亲身体验文法重构对解析性能的影响。你将为一个文法及其提取左公因子（left-factored）后的版本分别构建 Earley 分析表，并量化比较两者生成的分析项目总数，从而深入理解文法设计如何影响算法的效率。",
            "id": "3639827",
            "problem": "考虑上下文无关文法（CFG）$G$，其开始符号为 $S$，产生式为 $S \\to a\\,A \\mid a\\,B$，$A \\to x$ 和 $B \\to y$。设 $G$ 的左因子化重构 $G^{\\mathrm{lf}}$ 定义为引入一个新的非终结符 $C$，使得 $S \\to a\\,C$，$C \\to A \\mid B$，$A \\to x$ 和 $B \\to y$。使用Earley分析算法，以增广开始符号 $S_{0} \\to S$ 来分析输入字符串 $w = a\\,x$。Earley算法构建一系列集合（通常称为图表），其中位置 $i$ 处的集合表示为 $E_{i}$，包含形式为 $[A \\to \\alpha\\,\\bullet\\,\\beta, j]$ 的Earley项目，表示一个产生式 $A \\to \\alpha\\beta$，点表示右侧的当前位置，$j$ 表示起始索引。\n\n定义以下两个度量：\n- 对于输入 $w$，一个文法的总预测数是通过预测器操作在所有 $E_{i}$ 中添加的不同项目的数量（每个不同项目在总体上只计数一次）。\n- 对于输入 $w$，一个文法的总项目增长量是，在位置 $|w|$ 处的图表在预测器、扫描器和完成器操作下完全闭合后（每个 $E_{i}$ 内的重复项已消除），所有位置 $i$ 的集合基数 $|E_{i}|$ 的总和。\n\n计算在输入 $w = a\\,x$ 上，$G^{\\mathrm{lf}}$ 的总项目增长量与 $G$ 的总项目增长量之比 $R$。将你最终的 $R$ 表示为一个简化的精确分数。不需要四舍五入。",
            "solution": "该问题要求计算在使用 Earley 算法分析输入字符串 $w = a\\,x$ 时，左因子化的上下文无关文法 $G^{\\mathrm{lf}}$ 的总项目增长量与原始文法 $G$ 的总项目增长量之比。总项目增长量定义为所有 Earley 集（图表）基数的总和，即 $\\sum_{i=0}^{|w|} |E_i|$。输入字符串长度为 2，因此我们将构建集合 $E_0, E_1, E_2$。增广开始规则为 $S_0 \\to S$。\n\n### 第1部分：文法 $G$ 的分析\n\n文法 $G$ 由以下产生式给出：\n$S_0 \\to S$\n$S \\to a\\,A \\mid a\\,B$\n$A \\to x$\n$B \\to y$\n\n**为 $G$ 构建 Earley 图表：**\n\n**集合 $E_0$：**\n1.  初始化：$[S_0 \\to \\bullet S, 0]$。\n2.  **预测器**：从 $[S_0 \\to \\bullet S, 0]$ 预测 $S$ 的产生式。\n    - 添加 $[S \\to \\bullet a A, 0]$。\n    - 添加 $[S \\to \\bullet a B, 0]$。\n最终集合为 $E_0 = \\{ [S_0 \\to \\bullet S, 0], [S \\to \\bullet a A, 0], [S \\to \\bullet a B, 0] \\}$。\n基数 $|E_0| = 3$。\n\n**集合 $E_1$ (处理输入 'a')：**\n1.  **扫描器**：扫描 $E_0$ 中等待 'a' 的项目。\n    - 从 $[S \\to \\bullet a A, 0]$ 得到 $[S \\to a \\bullet A, 0]$。\n    - 从 $[S \\to \\bullet a B, 0]$ 得到 $[S \\to a \\bullet B, 0]$。\n2.  **预测器**：对新项目进行闭包。\n    - 从 $[S \\to a \\bullet A, 0]$ 预测 $A$ 的规则，起始索引为 1：添加 $[A \\to \\bullet x, 1]$。\n    - 从 $[S \\to a \\bullet B, 0]$ 预测 $B$ 的规则，起始索引为 1：添加 $[B \\to \\bullet y, 1]$。\n最终集合为 $E_1 = \\{ [S \\to a \\bullet A, 0], [S \\to a \\bullet B, 0], [A \\to \\bullet x, 1], [B \\to \\bullet y, 1] \\}$。\n基数 $|E_1| = 4$。\n\n**集合 $E_2$ (处理输入 'x')：**\n1.  **扫描器**：扫描 $E_1$ 中等待 'x' 的项目。\n    - 从 $[A \\to \\bullet x, 1]$ 得到 $[A \\to x \\bullet, 1]$。\n2.  **完成器**：新项目 $[A \\to x \\bullet, 1]$ 是一个已完成的 $A$ (起始索引 $k=1$) 。在 $E_1$ 中寻找等待 $A$ 的项目。\n    - 找到 $[S \\to a \\bullet A, 0]$，推进得到 $[S \\to a A \\bullet, 0]$。\n3.  **完成器**：新项目 $[S \\to a A \\bullet, 0]$ 是一个已完成的 $S$ (起始索引 $k=0$) 。在 $E_0$ 中寻找等待 $S$ 的项目。\n    - 找到 $[S_0 \\to \\bullet S, 0]$，推进得到 $[S_0 \\to S \\bullet, 0]$。\n最终集合为 $E_2 = \\{ [A \\to x \\bullet, 1], [S \\to a A \\bullet, 0], [S_0 \\to S \\bullet, 0] \\}$。\n基数 $|E_2| = 3$。\n\n**$G$ 的总项目增长量：**\n$\\text{Total}(G) = |E_0| + |E_1| + |E_2| = 3 + 4 + 3 = 10$。\n\n### 第2部分：文法 $G^{\\mathrm{lf}}$ 的分析\n\n左因子化文法 $G^{\\mathrm{lf}}$ 如下：\n$S_0 \\to S$\n$S \\to a\\,C$\n$C \\to A \\mid B$\n$A \\to x$\n$B \\to y$\n\n**为 $G^{\\mathrm{lf}}$ 构建 Earley 图表：**\n\n**集合 $E_0$：**\n1.  初始化：$[S_0 \\to \\bullet S, 0]$。\n2.  **预测器**：从 $[S_0 \\to \\bullet S, 0]$ 预测 $S$ 的产生式。\n    - 添加 $[S \\to \\bullet a C, 0]$。\n最终集合为 $E_0 = \\{ [S_0 \\to \\bullet S, 0], [S \\to \\bullet a C, 0] \\}$。\n基数 $|E_0| = 2$。\n\n**集合 $E_1$ (处理输入 'a')：**\n1.  **扫描器**：扫描 $E_0$ 中等待 'a' 的项目。\n    - 从 $[S \\to \\bullet a C, 0]$ 得到 $[S \\to a \\bullet C, 0]$。\n2.  **预测器**：对新项目进行闭包。\n    - 从 $[S \\to a \\bullet C, 0]$ 预测 $C$ 的规则，起始索引为 1：添加 $[C \\to \\bullet A, 1]$ 和 $[C \\to \\bullet B, 1]$。\n    - 从 $[C \\to \\bullet A, 1]$ 预测 $A$ 的规则：添加 $[A \\to \\bullet x, 1]$。\n    - 从 $[C \\to \\bullet B, 1]$ 预测 $B$ 的规则：添加 $[B \\to \\bullet y, 1]$。\n最终集合为 $E_1 = \\{ [S \\to a \\bullet C, 0], [C \\to \\bullet A, 1], [C \\to \\bullet B, 1], [A \\to \\bullet x, 1], [B \\to \\bullet y, 1] \\}$。\n基数 $|E_1| = 5$。\n\n**集合 $E_2$ (处理输入 'x')：**\n1.  **扫描器**：扫描 $E_1$ 中等待 'x' 的项目。\n    - 从 $[A \\to \\bullet x, 1]$ 得到 $[A \\to x \\bullet, 1]$。\n2.  **完成器**：新项目 $[A \\to x \\bullet, 1]$ 是一个已完成的 $A$ ($k=1$) 。在 $E_1$ 中寻找等待 $A$ 的项目。\n    - 找到 $[C \\to \\bullet A, 1]$，推进得到 $[C \\to A \\bullet, 1]$。\n3.  **完成器**：新项目 $[C \\to A \\bullet, 1]$ 是一个已完成的 $C$ ($k=1$) 。在 $E_1$ 中寻找等待 $C$ 的项目。\n    - 找到 $[S \\to a \\bullet C, 0]$，推进得到 $[S \\to a C \\bullet, 0]$。\n4.  **完成器**：新项目 $[S \\to a C \\bullet, 0]$ 是一个已完成的 $S$ ($k=0$) 。在 $E_0$ 中寻找等待 $S$ 的项目。\n    - 找到 $[S_0 \\to \\bullet S, 0]$，推进得到 $[S_0 \\to S \\bullet, 0]$。\n最终集合为 $E_2 = \\{ [A \\to x \\bullet, 1], [C \\to A \\bullet, 1], [S \\to a C \\bullet, 0], [S_0 \\to S \\bullet, 0] \\}$。\n基数 $|E_2| = 4$。\n\n**$G^{\\mathrm{lf}}$ 的总项目增长量：**\n$\\text{Total}(G^{\\mathrm{lf}}) = |E_0| + |E_1| + |E_2| = 2 + 5 + 4 = 11$。\n\n### 第3部分：计算比率 $R$\n\n比率 $R$ 是 $G^{\\mathrm{lf}}$ 的总项目增长量与 $G$ 的总项目增长量之比。\n$R = \\frac{\\text{Total}(G^{\\mathrm{lf}})}{\\text{Total}(G)} = \\frac{11}{10}$。\n\n该比率已经是一个简化的精确分数。",
            "answer": "$$\\boxed{\\frac{11}{10}}$$"
        },
        {
            "introduction": "理论的生命力在于实践。这个终极挑战  将带你从纸上推演走向代码实现。你不仅需要从零开始实现 Earley 解析器，还要为其加入一项关键的性能优化技术——基于 $\\text{FIRST}$ 集的预测剪枝（prediction pruning）。通过完成这项任务，你将深刻体会到在构建实用的解析器时，如何在确保算法完备性的前提下，有效地提升其运行效率，这对于编译原理和自然语言处理等领域的应用至关重要。",
            "id": "3639842",
            "problem": "您需要实现并分析带有和不带有基于 $\\text{FIRST}$ 集的预测剪枝的 Earley 分析算法。该任务必须使用编译器原理中的核心定义进行构建。一个上下文无关文法是一个元组 $\\mathcal{G} = (N, \\Sigma, P, S)$，其中 $N$ 是一个非终结符的有限集合，$\\Sigma$ 是一个终结符的有限集合，$P$ 是一组形如 $A \\rightarrow \\alpha$ 的产生式的有限集合，其中 $A \\in N$ 且 $\\alpha \\in (N \\cup \\Sigma)^{*}$，$S \\in N$ 是开始符号。序列 $\\alpha$ 的 $\\text{FIRST}$ 集定义为可以作为任何由 $\\alpha$ 推导出的字符串的第一个符号的终结符集合，如果 $\\alpha$ 可以推导出 $\\epsilon$，则该集合也包含空串符号 $\\epsilon$。\n\nEarley 算法为每个输入位置 $k$ 维护一个项表（chart），其中的项形如 $(X \\rightarrow \\alpha \\bullet \\beta, i)$，其中 $X \\rightarrow \\alpha \\beta$ 是一个产生式，$\\bullet$ 指示了在产生式右侧的当前位置，$i$ 是该项开始的起始索引。三个基本操作是：预测（prediction）、扫描（scanning）和完成（completion）。预测操作会为紧跟在 $\\bullet$ 后面的每个非终结符 $Y$ 的每个产生式添加项 $(Y \\rightarrow \\bullet \\gamma, k)$。扫描操作将 $\\bullet$ 越过与下一个输入符号匹配的终结符。完成操作会推进那些 $\\beta$ 以一个已完成的非终结符开头的项。\n\n您必须实现该算法两次：一个执行所有预测的基础版 Earley 分析器，以及一个剪枝变体，该变体仅在相对于当前展望（lookahead）符号的 $\\text{FIRST}$ 集成员关系证明其合理性时才执行预测。具体来说，对于在输入位置 $k$ 的项 $(X \\rightarrow \\alpha \\bullet Y \\beta, k)$，剪枝的预测器仅当位置 $k$ 的展望终结符 $t$ 满足 $t \\in \\text{FIRST}(Y)$，或者当 $\\epsilon \\in \\text{FIRST}(Y)$ 时，才可添加 $(Y \\rightarrow \\bullet \\gamma, k)$（后者确保了当 $Y$ 可以推导出空串时的完整性）。在输入结束时（当 $k$ 等于输入长度时），剪枝必须仅在 $\\epsilon \\in \\text{FIRST}(Y)$ 时才允许预测。\n\n从以下基本基础开始：\n- 上下文无关文法的 $\\text{FIRST}$ 集定义，包括对 $\\epsilon$ 推导的处理：对于序列 $\\alpha_1 \\alpha_2 \\dots \\alpha_m$，$\\text{FIRST}(\\alpha_1 \\alpha_2 \\dots \\alpha_m)$ 包含来自 $\\text{FIRST}(\\alpha_1)$ 中除 $\\epsilon$ 之外的终结符，并且如果 $\\epsilon \\in \\text{FIRST}(\\alpha_1)$，则还包含来自 $\\text{FIRST}(\\alpha_2)$ 中除 $\\epsilon$ 之外的终结符，以此类推；如果每个 $\\alpha_j$ 都可以推导出 $\\epsilon$，则 $\\epsilon$ 属于 $\\text{FIRST}(\\alpha_1 \\alpha_2 \\dots \\alpha_m)$。\n- Earley 项和操作根据项表索引和产生式结构进行定义。\n- 展望的确定性解释：位置 $k$ 处的展望终结符是输入符号 $w_k$（如果 $k$ 小于输入长度），否则没有终结符存在，只允许基于 $\\epsilon$ 的预测。\n\n使用以下文法 $\\mathcal{G}$，其中 $\\text{FIRST}(A) = \\{a, b\\}$ 被满足：\n- 非终结符 $N = \\{S, A, C\\}$ 和开始符号 $S$。\n- 终结符 $\\Sigma = \\{a, b, c\\}$。\n- 产生式 $P$：\n  1. $S \\rightarrow A \\, C$\n  2. $A \\rightarrow a \\, A$\n  3. $A \\rightarrow a$\n  4. $A \\rightarrow b$\n  5. $C \\rightarrow c \\, C$\n  6. $C \\rightarrow \\epsilon$\n\n为了进行接受检查，使用一个合成的开始符号 $S'$ 和产生式 $S' \\rightarrow S$ 来增广文法。计算所有非终结符（包括 $S'$）的 $\\text{FIRST}$ 集。\n\n您的程序必须：\n- 使用上述定义，通过不动点算法计算 $\\text{FIRST}$ 集。\n- 在相同的项表基础设施上实现两个分析器：基础版 Earley 和剪枝版 Earley。剪枝的预测器必须仅在位置 $k$ 的展望终结符 $t$ 满足 $t \\in \\text{FIRST}(Y)$ 或 $\\epsilon \\in \\text{FIRST}(Y)$ 时才添加 $(Y \\rightarrow \\bullet \\gamma, k)$。\n- 为每次分析跟踪两个可量化的指标：\n  - $p$：在所有项表中，通过预测步骤添加的唯一项的整数计数。\n  - $u$：在所有项表中，通过所有步骤（预测、扫描、完成）添加的所有唯一项的整数计数。\n\n对于接受，当且仅当项 $(S' \\rightarrow S \\bullet, 0)$ 出现在索引等于输入长度的项表中时，分析成功。\n\n测试套件：\n- 输入 $w_1 = \\text{\"accc\"}$。\n- 输入 $w_2 = \\text{\"b\"}$。\n- 输入 $w_3 = \\text{\"bc\"}$。\n- 输入 $w_4 = \\text{\"d\"}$。\n- 输入 $w_5 = \\text{\"\"}$（空字符串）。\n- 输入 $w_6 = \\text{\"a\"}$。\n\n对于每个输入 $w_i$，运行两个分析器并报告一个列表 $[s_b, s_p, p_b, p_p, u_b, u_p]$，其中 $s_b$ 和 $s_p$ 分别是表示基础版和剪枝版接受状态的 $0$ 或 $1$，$p_b$ 和 $p_p$ 分别是基础版和剪枝版的预测计数，$u_b$ 和 $u_p$ 分别是基础版和剪枝版的总唯一项计数。您的程序应生成单行输出，其中包含这些六元组列表的逗号分隔列表，并用方括号括起来，例如 $[[s_b, s_p, p_b, p_p, u_b, u_p], \\dots]$。\n\n最终输出格式必须是精确的一行：\n- 一个单独的外部列表，其中包含每个测试用例的一个内部列表，按 $w_1$ 到 $w_6$ 的顺序排列。\n- 输出中无空白字符。\n- 所有条目必须是整数。\n\n此问题不涉及物理单位或角度；所有数值输出必须是纯整数。",
            "solution": "该解决方案源自编译器理论的第一性原理，依赖于 $\\text{FIRST}$ 集和 Earley 算法的形式化定义。一个上下文无关文法 $\\mathcal{G} = (N, \\Sigma, P, S)$ 通过产生式指定推导过程。符号序列的 $\\text{FIRST}$ 集决定了哪个终结符可能作为从该序列推导出的任何字符串的第一个符号，以及是否可以推导出空串 $\\epsilon$。\n\n$\\text{FIRST}$ 集的计算使用单调不动点方法。对每个非终结符 $A \\in N$，初始化 $\\text{FIRST}(A)$ 为空集，并在存在 $A \\rightarrow \\epsilon$ 时标记 $\\epsilon \\in \\text{FIRST}(A)$。然后，对每个产生式 $A \\rightarrow \\alpha_1 \\alpha_2 \\dots \\alpha_m$ 进行迭代：\n- 对于 $j=1$ 到 $m$，将 $\\text{FIRST}(\\alpha_j)$ 中除 $\\epsilon$ 外的终结符合并到 $\\text{FIRST}(A)$ 中。如果 $\\epsilon \\in \\text{FIRST}(\\alpha_j)$，则继续到 $j+1$；否则，停止。\n- 如果每个 $\\alpha_j$ 都能推导出 $\\epsilon$（包括 $m=0$ 的情况），则将 $\\epsilon$ 加入 $\\text{FIRST}(A)$。\n当没有 $\\text{FIRST}$ 集再增长时，此过程终止。根据定义，对于终结符 $a \\in \\Sigma$，$FIRST(a) = \\{a\\}$。\n\nEarley 算法在按输入位置 $k$ 索引的项表中操作项 $(X \\rightarrow \\alpha \\bullet \\beta, i)$。它执行三个操作，直到项表中没有新项被添加：\n- 预测：如果 $\\beta$ 以非终结符 $Y$ 开始，为所有产生式 $Y \\rightarrow \\gamma$ 添加 $(Y \\rightarrow \\bullet \\gamma, k)$。\n- 扫描：如果 $\\beta$ 以终结符 $t$ 开始且下一个输入符号是 $t$，则在项表 $k+1$ 中推进到 $(X \\rightarrow \\alpha t \\bullet \\beta', i)$。\n- 完成：如果一个项 $(Y \\rightarrow \\gamma \\bullet, j)$ 在项表 $k$ 中完成，则将在项表 $j$ 中的任何项 $(X \\rightarrow \\alpha \\bullet Y \\beta, i)$ 推进到项表 $k$ 中的 $(X \\rightarrow \\alpha Y \\bullet \\beta, i)$。\n\n如果 $(S' \\rightarrow S \\bullet, 0)$ 出现在索引等于输入长度的项表中，则接受成立。为了比较基础版和剪枝版预测策略，我们引入一个基于 $\\text{FIRST}$ 集的剪枝规则。当遇到项 $(X \\rightarrow \\alpha \\bullet Y \\beta, k)$ 时：\n- 设 $t$ 为位置 $k$ 处的展望终结符（如果 $k$ 小于输入长度）。如果 $t \\in \\text{FIRST}(Y)$，则允许预测 $(Y \\rightarrow \\bullet \\gamma, k)$。\n- 如果 $\\epsilon \\in \\text{FIRST}(Y)$，则始终允许预测（包括在输入结束时），因为 $Y$ 可以在不消耗输入的情况下推导出 $\\epsilon$；禁止此类预测会破坏完整性，因为它会阻止必要的完成步骤。\n- 在输入结束时，只允许 $\\epsilon \\in \\text{FIRST}(Y)$ 的预测。\n\n此规则保持了完整性，因为任何需要 $Y$ 匹配终结符 $t$ 的推导都必须满足 $t \\in \\text{FIRST}(Y)$，因此被剪枝禁止的预测无法产生成功的扫描。如果 $Y$ 可以推导出 $\\epsilon$，剪枝允许独立于展望的预测，确保完成步骤仍然可用，以便在不消耗输入的情况下推进越过 $Y$ 的项。因此，剪枝不会移除任何可能导致接受的推导，但当展望终结符不在 $\\text{FIRST}(Y)$ 中时，它会减少预测项的数量。\n\n对于给定的文法：\n- $S \\rightarrow A \\, C$,\n- $A \\rightarrow a \\, A \\mid a \\mid b$,\n- $C \\rightarrow c \\, C \\mid \\epsilon$,\n我们计算出 $\\text{FIRST}(A) = \\{a, b\\}$，$\\text{FIRST}(C) = \\{c, \\epsilon\\}$，以及 $\\text{FIRST}(S) = \\text{FIRST}(A) = \\{a, b\\}$，因为 $A$ 无法推导出 $\\epsilon$。增广的开始符号 $S'$ 满足 $\\text{FIRST}(S') = \\text{FIRST}(S) = \\{a, b\\}$。\n\n我们实现了两个共享项表基础设施和项表示的分析器。我们强制项的唯一性以确保终止和指标的准确性。对于每个输入 $w_i$，我们记录：\n- $s_b$：基础版接受情况（成功为 $1$，失败为 $0$），\n- $s_p$：剪枝版接受情况（成功为 $1$，失败为 $0$），\n- $p_b$：基础版中添加的预测项数量，\n- $p_p$：剪枝版中添加的预测项数量，\n- $u_b$：基础版中添加的总唯一项数量，\n- $u_p$：剪枝版中添加的总唯一项数量。\n\n解释测试套件：\n- 对于 $w_1 = \\text{\"accc\"}$，预期接受，因为 $A$ 推导出 $\\text{\"a\"}$，$C$ 推导出 $\\text{\"ccc\"}$。剪枝应能减少那些展望与预期非终结符的 $\\text{FIRST}$ 集不一致的预测。\n- 对于 $w_2 = \\text{\"b\"}$，预期接受，因为 $A$ 推导出 $\\text{\"b\"}$，$C$ 推导出 $\\epsilon$；由于 $\\epsilon \\in \\text{FIRST}(C)$，剪枝应保持完整性。\n- 对于 $w_3 = \\text{\"bc\"}$，预期接受，因为 $A$ 推导出 $\\text{\"b\"}$，$C$ 推导出 $\\text{\"c\"}$；剪枝应是安全的。\n- 对于 $w_4 = \\text{\"d\"}$，预期失败，因为 $\\text{\"d\"} \\notin \\text{FIRST}(S)$；剪枝将在起始项表中避免许多预测。\n- 对于 $w_5 = \\text{\"\"}$，预期失败，因为 $A$ 无法推导出 $\\epsilon$；剪枝会阻止在位置 0 对 $A$ 进行不必要的预测，而基础版仍会探索这些项。\n- 对于 $w_6 = \\text{\"a\"}$，预期接受，因为 $A$ 推导出 $\\text{\"a\"}$，$C$ 推导出 $\\epsilon$。\n\n最终程序将构建文法，通过不动点迭代计算 $\\text{FIRST}$ 集，运行两个分析器，为每个测试用例聚合指标，并以要求的无空格嵌套列表格式打印单行结果。这证明了剪枝预测器保持了完整性，并通过项计数来量化性能变化。",
            "answer": "[[1,1,13,11,41,39],[1,1,9,9,22,22],[1,1,11,11,29,29],[0,0,4,1,10,7],[0,0,7,4,10,7],[1,1,9,9,22,22]]"
        }
    ]
}