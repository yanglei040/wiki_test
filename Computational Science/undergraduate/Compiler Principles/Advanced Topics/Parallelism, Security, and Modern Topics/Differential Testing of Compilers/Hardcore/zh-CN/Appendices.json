{
    "hands_on_practices": [
        {
            "introduction": "“实现定义的行为”（Implementation-Defined Behavior）是差分测试的一个关键目标，因为不同编译器可能会做出不同的选择。本练习聚焦于 C 语言的整数提升规则以及 `char` 类型有符号性的模糊之处。 通过将编译器的输出与一个精确的数学模型进行比较，我们不仅可以验证 `signed char` 和 `unsigned char` 的标准行为，还能揭示编译器对普通 `char` 类型究竟采取了哪种实现。",
            "id": "3637901",
            "problem": "你的任务是设计并实现一个自包含的程序，用于对 C 编程语言（C）中的字符算术的整数提升规则进行差分测试，重点关注字符操作数在求值前被提升为 `int` 类型后，其运行时加法结果是否与整数集 $\\mathbb{Z}$ 中的数学加法相匹配。此任务的基本依据是 C 语言中关于整数提升和常规算术转换的定义，以及 $\\mathbb{Z}$ 中加法运算经过充分检验的数学性质。整数提升规则规定，对于加法运算符 $+$，当两个操作数的原始类型是较小的整数类型之一时（例如 `char`、`signed char`、`unsigned char`），并且原始类型的所有值都能在 `int` 中表示时，这两个操作数都会被提升为 `int`（或 `unsigned int`）。在主流系统中，`char` 的所有值都可以在 `int` 中表示，因此 `char`、`signed char` 和 `unsigned char` 在进行加法运算前都会被提升为 `int`。你的程序必须验证，在对原始 $8$ 位值进行明确定义的解释下，这种提升所产生的结果与 $\\mathbb{Z}$ 中的数学加法相等。\n\n为一个 8 位量 $x \\in \\{0,1,\\dots,255\\}$ 定义两个解释函数：\n- 有符号解释 $f_s(x)$，它将 8 位值按二进制补码形式的有符号 8 位值映射到 $\\mathbb{Z}$：\n$$\nf_s(x) = \\begin{cases}\nx,  \\text{if } 0 \\le x \\le 127, \\\\\nx - 256,  \\text{if } 128 \\le x \\le 255,\n\\end{cases}\n$$\n- 无符号解释 $f_u(x)$，它直接映射到 $\\mathbb{Z}$：\n$$\nf_u(x) = x.\n$$\n\n对于每个测试用例对 $(a,b)$，其中 $a,b \\in \\{0,1,\\dots,255\\}$，你必须计算四个布尔值（编码为整数 0 或 1），用于检查 C 语言中基于整数提升的加法是否与 $\\mathbb{Z}$ 中相应的数学加法一致：\n- $b_s$：如果在 C 语言中经整数提升后求值的 `((signed char)a) + ((signed char)b)` 等于 $\\mathbb{Z}$ 中的 $f_s(a) + f_s(b)$，则为 $1$；否则为 $0$。\n- $b_u$：如果在 C 语言中经整数提升后求值的 `((unsigned char)a) + ((unsigned char)b)` 等于 $\\mathbb{Z}$ 中的 $f_u(a) + f_u(b)$，则为 $1$；否则为 $0$。\n- $b_{p=s}$：如果在 C 语言中经整数提升后求值的 `((char)a) + ((char)b)` 等于 $\\mathbb{Z}$ 中的 $f_s(a) + f_s(b)$，则为 $1$；否则为 $0$。\n- $b_{p=u}$：如果在 C 语言中经整数提升后求值的 `((char)a) + ((char)b)` 等于 $\\mathbb{Z}$ 中的 $f_u(a) + f_u(b)$，则为 $1$；否则为 $0$。\n\n这种设计实现了跨编译器的差分测试（DT）：对于遵循标准的编译器，前两个布尔值 $b_s$ 和 $b_u$ 必须为 $1$，而 $b_{p=s}$ 与 $b_{p=u}$ 的对比可能会揭示因 `char` 类型的默认有符号性是实现定义的而产生的差异。\n\n使用以下测试用例对 $(a,b)$ 的测试套件，该套件的选择旨在覆盖一般情况、边界和边缘条件：\n- 测试 1：$(a,b) = (100,27)$，均在 $[0,127]$ 范围内。\n- 测试 2：$(a,b) = (200,60)$，一个大于 $127$，一个在 $[0,127]$ 范围内。\n- 测试 3：$(a,b) = (255,1)$，一个上边界和一个小的正数。\n- 测试 4：$(a,b) = (128,128)$，两者都恰好在有符号负数的边界上。\n- 测试 5：$(a,b) = (0,0)$，最小边界值。\n- 测试 6：$(a,b) = (127,1)$，跨越有符号边界。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中应包含每个测试用例的四个布尔值，按 $(b_s,b_u,b_{p=s},b_{p=u})$ 的顺序排列，并将所有六个测试的结果展开。最终输出格式为：\n[$b_s^{(1)}$,$b_u^{(1)}$,$b_{p=s}^{(1)}$,$b_{p=u}^{(1)}$,$b_s^{(2)}$,$b_u^{(2)}$,$b_{p=s}^{(2)}$,$b_{p=u}^{(2)}$,$b_s^{(3)}$,$b_u^{(3)}$,$b_{p=s}^{(3)}$,$b_{p=u}^{(3)}$,$b_s^{(4)}$,$b_u^{(4)}$,$b_{p=s}^{(4)}$,$b_{p=u}^{(4)}$,$b_s^{(5)}$,$b_u^{(5)}$,$b_{p=s}^{(5)}$,$b_{p=u}^{(5)}$,$b_s^{(6)}$,$b_u^{(6)}$,$b_{p=s}^{(6)}$,$b_{p=u}^{(6)}$]。\n\n无需外部输入。不涉及物理单位、角度单位或百分比格式；所有输出均为整数。程序必须是自包含的，并且可直接运行。验证过程必须通过确保所有实际加法都在提升为 `int` 后进行，并且不将结果缩窄回更窄的整数类型，从而避免未定义行为（UB）。这项差分测试突出了普通 `char` 有符号性的实现定义行为，同时确认了 `signed char` 和 `unsigned char` 的可移植提升语义。",
            "solution": "该问题是有效的。它以 C 编程语言的形式化规范和基本整数算术为科学依据，问题陈述清晰，具有明确的目标和方法论，并且没有歧义或矛盾。\n\n任务是设计一个程序，以经验性地验证 C 语言中字符算术的整数提升规则。被测试的核心原则在 C 标准（ISO/IEC 9899，关于“整数提升”的第 6.3.1.1 节）中定义：如果一个 `int` 可以表示某个整数类型的所有值，则该值被转换为 `int`。在 `sizeof(int) > sizeof(char)` 的典型现代架构上，对于像 `char`、`signed char` 和 `unsigned char` 这样的小整数类型，当它们作为像 `+` 这样的二元算术运算符的操作数时，会发生到 `int` 的提升。我们的程序将测试这种提升及后续在 C 语言中的加法运算结果，是否与整数集 $\\mathbb{Z}$ 中的数学期望结果一致。\n\n该验证基于对一个 8 位值 $x \\in \\{0, 1, \\dots, 255\\}$ 的两种不同解释。\n1.  有符号解释 $f_s(x)$，它对应于二进制补码表示：当 $0 \\le x \\le 127$ 时，$f_s(x) = x$；当 $128 \\le x \\le 255$ 时，$f_s(x) = x - 256$。\n2.  无符号解释 $f_u(x)$，它是一个直接映射：$f_u(x) = x$。\n\n这些函数作为我们的数学基准真相。对于给定的 8 位值对 $(a, b)$，程序将基于四种不同的比较，计算出四个布尔值，表示为整数 $1$ (真) 或 $0$ (假)。\n\n**1. `signed char` 算术验证 ($b_s$)**\n第一个测试验证显式 `signed char` 操作数的行为。在 C 语言中，表达式 `((signed char)a) + ((signed char)b)` 被求值。$a$ 和 $b$ 的位模式首先被解释为 `signed char`。根据 C 标准，两个操作数随后被提升为 `int` 类型。加法运算在这些 `int` 值上执行。我们将把这个计算结果与数学和 $f_s(a) + f_s(b)$ 进行比较。\n$$b_s = \\begin{cases} 1  \\text{if } (\\mathtt{(int)((signed char)a) + (int)((signed char)b)}) = (f_s(a) + f_s(b)) \\\\ 0  \\text{otherwise} \\end{cases}$$\n对于任何遵循标准的编译器，此测试预计会通过，从而得到 $b_s=1$。\n\n**2. `unsigned char` 算术验证 ($b_u$)**\n第二个测试验证 `unsigned char` 操作数的行为。在 C 语言中，表达式 `((unsigned char)a) + ((unsigned char)b)` 被求值。两个操作数类型均为 `unsigned char`，它们被提升为 `int`（因为 `int` 可以表示 `unsigned char` 的整个范围，通常是 $[0, 255]$）。加法在产生的 `int` 值上执行。此结果将与数学和 $f_u(a) + f_u(b)$（即 $a+b$）进行比较。\n$$b_u = \\begin{cases} 1  \\text{if } (\\mathtt{(int)a + (int)b}) = (f_u(a) + f_u(b)) \\\\ 0  \\text{otherwise} \\end{cases}$$\n此测试在任何遵循标准的编译器上也预计会通过，从而得到 $b_u=1$。\n\n**3. `char` 算术验证（实现定义的行为）**\n第三和第四个测试探查普通 `char` 类型的实现定义的有符号性。C 标准允许 `char` 的行为既可以像 `signed char`，也可以像 `unsigned char`。我们对 C 表达式 `((char)a) + ((char)b)` 求值，其中操作数同样在加法前被提升为 `int`。然后将结果与有符号和无符号两种数学模型进行比较。\n-   $b_{p=s}$ 测试 `char` 的行为是否像 `signed char`：\n    $$b_{p=s} = \\begin{cases} 1  \\text{if } (\\mathtt{(int)((char)a) + (int)((char)b)}) = (f_s(a) + f_s(b)) \\\\ 0  \\text{otherwise} \\end{cases}$$\n-   $b_{p=u}$ 测试 `char` 的行为是否像 `unsigned char`：\n    $$b_{p=u} = \\begin{cases} 1  \\text{if } (\\mathtt{(int)((char)a) + (int)((char)b)}) = (f_u(a) + f_u(b)) \\\\ 0  \\text{otherwise} \\end{cases}$$\n对于任何给定的编译器，在 $f_s$ 和 $f_u$ 不同的测试用例中，$b_{p=s}$ 或 $b_{p=u}$ 中恰好有一个会是 $1$。这对布尔值揭示了该实现对 `char` 有符号性的选择。这是该测试的差分方面，因为不同的编译器可能会对这对布尔值产生不同的结果。\n\n程序的结构是遍历一个精心挑选的测试用例套件 $(a,b)$，以探查边界条件和一般行为。对于每一对值，它计算四个 C 语言结果和两个数学结果，执行四次比较，并存储得到的整数布尔值。最后，它按照规定，将所有 $6 \\times 4 = 24$ 个结果以展开的、逗号分隔的列表形式打印出来，并用方括号括起来。该实现使用一个 `struct` 来表示测试用例以提高代码清晰度，并在打印前将最终的布尔值存储在一个整型数组中。数学解释函数 $f_s(x)$ 和 $f_u(x)$ 在 C 语言中作为辅助函数实现。C 语言中的所有算术运算都在提升后使用 `int` 类型执行，以确保结果不受 8 位溢出的影响，从而为本测试的目的正确地为数学域 $\\mathbb{Z}$ 建模。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include \n```"
        },
        {
            "introduction": "不同的编程语言可能对同一个操作规定了不同的语义。本练习将探讨整数除法这一经典例子，对比 C 语言中“向零截断”的规则与 Python 等语言中“向下取整”的规则。 通过从第一性原理出发实现两种语义的“神谕”，你将学会如何创建测试，以精确判断一个编译器遵循哪种标准，这在跨语言兼容性和代码移植中是一项至关重要的技能。",
            "id": "3637968",
            "problem": "设计并实现一个完整的、可运行的程序，作为可执行的预言机（oracle），用于对编译器在整数除法和取余语义上进行差分测试。重点是检测在实现向零舍入除法与向下舍入（floor）除法的编译器之间的不一致性。您必须从编译器理论和离散数学的第一性原理出发推导出算法，然后在一个自包含的程序中实现它。\n\n给定一组整数输入对 $(x,y)$，其中 $x,y \\in \\mathbb{Z}$。对于每一对输入，您的程序必须计算两种整数除法语义：\n\n1. 向零截断（Truncation-toward-zero）除法语义，这是多种主流语言（如C语言标准）所定义的；它产生一个商 $q_{tz}$ 和一个余数 $r_{tz}$，旨在反映将 $x/y$ 向零舍入的结果。\n2. 向下舍入（Floor-division）除法语义，这是多种语言和规范所定义的；它产生一个商 $q_{f}$ 和一个余数 $r_{f}$，旨在反映将 $x/y$ 向下舍入到不大于它的最大整数。\n\n您的推导必须基于整数的欧几里得分解：对于任何 $x \\in \\mathbb{Z}$ 和 $y \\in \\mathbb{Z}$ 且 $y \\neq 0$，存在 $q \\in \\mathbb{Z}$ 和 $r \\in \\mathbb{Z}$ 使得\n$$\nx = q \\cdot y + r.\n$$\n该分解将 $q$ 定义为在给定舍入约定下的商，将 $r$ 定义为余数。您不能假设任何快捷公式。相反，您必须结合以下公认事实，从上述分解中推导出算法步骤：\n- 绝对值函数 $|z|$，对于 $z \\in \\mathbb{Z}$。\n- 向下取整函数 $\\lfloor z \\rfloor$ 和向上取整函数 $\\lceil z \\rceil$，对于 $z \\in \\mathbb{R}$。\n- 符号函数 $\\operatorname{sgn}(z)$，根据 $z$ 是负数、零还是正数，分别产生 $-1$、 $0$ 或 $1$。\n\n目标是为每个测试用例 $(x,y)$ 生成以下内容：\n- 向零截断的商 $q_{tz}$ 和余数 $r_{tz}$。\n- 向下舍入的商 $q_{f}$ 和余数 $r_{f}$。\n- 一个布尔不匹配指示符 $m$，当且仅当 $q_{tz} \\neq q_{f}$ 或 $r_{tz} \\neq r_{f}$ 时定义为 $m = 1$，否则为 $m = 0$。\n- 一个有效性指示符 $v$，如果 $y \\neq 0$ 则定义为 $v = 1$；否则为 $v = 0$。当 $v=0$ 时，遇到除零错误，两种语义都应被视为未定义行为。在这种情况下，您必须为商和余数输出中性值（为两个商和两个余数都选择 $0$），并设置 $m = 0$。\n- 为了进行运行时自检，您必须计算两个布尔不变量：\n  - $p_{tz}$，当且仅当向零截断的余数满足 $|r_{tz}|  |y|$ 并且 $r_{tz}$ 与 $x$ 同号或为零时，其值为 $1$；否则 $p_{tz} = 0$。\n  - $p_{f}$，当且仅当向下舍入的余数满足以下符号一致的边界条件时，其值为 $1$：当 $y > 0$ 时， $0 \\le r_{f}  |y|$；当 $y  0$ 时， $-|y|  r_{f} \\le 0$；否则 $p_{f} = 0$。\n\n您的推导必须从欧几里得分解以及向下取整、向上取整、绝对值和符号函数的定义开始，并逻辑地推导出计算 $(q_{tz}, r_{tz})$ 和 $(q_{f}, r_{f})$ 的算法，并尽可能只使用对非负值的整数运算。\n\n所有计算均使用有符号的 $64$ 位整数。如果 $y = 0$，则将两种语义都视为经典编译器理论意义上的未定义行为，并设置 $v = 0$。\n\n测试套件：\n您必须实现以下有序的测试用例集，每个用例为一个数对 $(x,y)$：\n- $(7,3)$\n- $(-3,2)$\n- $(3,-2)$\n- $(-7,-3)$\n- $(0,5)$\n- $(5,5)$\n- $(1234567890123456789,10)$\n- $(-1234567890123456789,10)$\n- $(9,-1)$\n- $(5,0)$\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，其本身也是一个列表：\n$$\n[\\,[v,q_{tz},r_{tz},q_{f},r_{f},m,p_{tz},p_{f}],\\ldots\\,]\n$$\n例如，整体形状必须是 $[\\text{case}_1,\\text{case}_2,\\ldots,\\text{case}_{10}]$，不含多余的空格或文本。这一行是您的程序应生成的唯一输出。\n\n此问题不涉及任何物理单位、角度单位或百分比；所有计算值均为整数或表示为整数的布尔值。",
            "solution": "该问题是有效的。它在科学上基于离散数学和计算机科学的既定原则，特别是整数除法理论及其在编程语言中的实现。问题陈述清晰，提供了一套完整且一致的定义、约束和测试用例，从而可以推导出一个唯一且可验证的解决方案。所有术语都得到了客观和形式化的定义。\n\n解决方案源于整数 $x$ 和 $y$（其中 $y \\neq 0$）的基本欧几里得分解：\n$$\nx = q \\cdot y + r\n$$\n在这里，$q$ 是商，$r$ 是余数。不同的整数除法语义源于根据实数 $x/y$ 选择商 $q$ 的不同规则。我们将推导向零截断和向下舍入除法语义的算法。所有计算都将使用有符号的 $64$ 位整数。\n\n**1. 向零截断除法语义 ($q_{tz}, r_{tz}$)**\n\n这种语义在 C 语言和许多其他语言中是标准，它通过截断实数 $z = x/y$（即移除其小数部分）来定义商 $q_{tz}$，这等同于向 $0$ 舍入。\n\n截断函数 $\\operatorname{trunc}(z)$ 可以使用向下取整和向上取整函数正式定义为：\n$$\n\\operatorname{trunc}(z) = \\begin{cases} \\lfloor z \\rfloor  \\text{if } z \\ge 0 \\\\ \\lceil z \\rceil  \\text{if } z  0 \\end{cases}\n$$\n因此，商 $q_{tz}$ 是：\n$$\nq_{tz} = \\operatorname{trunc}(x/y)\n$$\n相应的余数 $r_{tz}$ 则由分解公式唯一确定：\n$$\nr_{tz} = x - q_{tz} \\cdot y\n$$\n这种语义的一个关键属性是，余数 $r_{tz}$ 的符号总是与被除数 $x$ 相同，或者为 $0$。形式上，如果 $r_{tz} \\neq 0$，则 $\\operatorname{sgn}(r_{tz}) = \\operatorname{sgn}(x)$。此外，余数的绝对值严格小于除数的绝对值：$|r_{tz}|  |y|$。这些属性构成了不变量 $p_{tz}$ 的基础。\n\n在 C 语言中，用于有符号整数的内置整数运算符 `/` 和 `%` 被规定实现向零截断语义。因此，对于 $y \\neq 0$，我们可以直接计算：\n- $q_{tz} = x / y$\n- $r_{tz} = x \\% y$\n\n**2. 向下舍入除法语义 ($q_{f}, r_{f}$)**\n\n这种语义通过将实数 $z = x/y$ 向负无穷方向舍入来定义商 $q_{f}$。这正是向下取整函数 $\\lfloor z \\rfloor$ 的定义。\n\n商 $q_f$ 定义为：\n$$\nq_{f} = \\lfloor x/y \\rfloor\n$$\n余数 $r_f$ 随后定义为：\n$$\nr_{f} = x - q_{f} \\cdot y = x - \\lfloor x/y \\rfloor \\cdot y\n$$\n根据向下取整函数的定义，我们有 $\\lfloor z \\rfloor \\le z  \\lfloor z \\rfloor + 1$。代入 $z = x/y$ 和 $q_f = \\lfloor x/y \\rfloor$，我们得到 $q_f \\le x/y  q_f + 1$。\n- 如果 $y > 0$，两边乘以 $y$ 得到 $q_f \\cdot y \\le x  q_f \\cdot y + y$。减去 $q_f \\cdot y$ 得到 $0 \\le x - q_f \\cdot y  y$。因此，$0 \\le r_f  y$。\n- 如果 $y  0$，两边乘以 $y$ 会反转不等号：$q_f \\cdot y \\ge x > q_f \\cdot y + y$。减去 $q_f \\cdot y$ 得到 $0 \\ge x - q_f \\cdot y > y$。因此，$y  r_f \\le 0$。\n\n这两个关于 $r_f$ 的条件（对于 $y>0$，$0 \\le r_f  |y|$；对于 $y0$，$-|y|  r_f \\le 0$）与不变量 $p_f$ 的定义相匹配。\n\n**3. 实现的算法推导**\n\n虽然 $q_{tz}$ 和 $r_{tz}$ 可以在 C 语言中直接计算，但我们必须使用可用的整数运算推导出计算 $q_f$ 和 $r_f$ 的算法。我们将 $q_f$ 与已经计算出的 $q_{tz}$ 关联起来。\n\n- **情况1：$x/y \\ge 0$（即 $x$ 和 $y$ 同号或 $x=0$）。**\n在这种情况下，$\\operatorname{trunc}(x/y) = \\lfloor x/y \\rfloor$。因此，$q_f = q_{tz}$。从而，$r_f = x - q_f \\cdot y = x - q_{tz} \\cdot y = r_{tz}$。两种语义之间没有区别。\n\n- **情况2：$x/y  0$（即 $x$ 和 $y$ 异号）。**\n  - 如果 $x/y$ 是整数（即 $x$ 是 $y$ 的倍数，所以 $r_{tz} = 0$），那么 $\\operatorname{trunc}(x/y) = x/y = \\lfloor x/y \\rfloor$。同样，$q_f = q_{tz}$ 且 $r_f = r_{tz}$。\n  - 如果 $x/y$ 不是整数（即 $r_{tz} \\neq 0$），那么 $\\lfloor x/y \\rfloor = \\lceil x/y \\rceil - 1 = \\operatorname{trunc}(x/y) - 1$。这意味着 $q_f = q_{tz} - 1$。\n    那么余数 $r_f$ 为：\n    $$\n    r_f = x - q_f \\cdot y = x - (q_{tz} - 1) \\cdot y = (x - q_{tz} \\cdot y) + y = r_{tz} + y\n    $$\n\n这就导出了一个完整的算法：\n1.  使用 C 运算符 `/` 和 `%` 计算 $q_{tz}$ 和 $r_{tz}$。\n2.  检查 $x$ 和 $y$ 是否异号且 $r_{tz}$ 不为零。\n3.  如果此条件为真，则 $q_f = q_{tz} - 1$ 且 $r_f = r_{tz} + y$。\n4.  否则，$q_f = q_{tz}$ 且 $r_f = r_{tz}$。\n\n**4. 特殊情况与指示符**\n\n- **除以零（$y=0$）：** 这是未定义行为。问题规定输出应为中性值。有效性指示符 $v$ 设置为 $0$。所有商和余数的输出（$q_{tz}, r_{tz}, q_f, r_f$）都设置为 $0$。不匹配指示符 $m$ 设置为 $0$。对于不变量，由于 $|r_{tz}|  |y|$ 变为 $|0||0|$（假），$p_{tz}$ 为 $0$。$p_f$ 的两个条件都失败，因为 $y$ 既不是正数也不是负数，所以 $p_f$ 也为 $0$。输出元组为 $[0,0,0,0,0,0,0,0]$。\n\n- **指示符：** 对于每个有效情况（$y \\neq 0$）：\n    - $v = 1$。\n    - 如果 $q_{tz} \\neq q_f$ 或 $r_{tz} \\neq r_{f}$，则 $m = 1$，否则 $m=0$。\n    - 如果 $|r_{tz}|  |y|$ 且 $(x \\ge 0 \\text{  } r_{tz} \\ge 0) || (x \\le 0 \\text{  } r_{tz} \\le 0)$，则 $p_{tz} = 1$。\n    - 如果 $(y > 0 \\text{ and } 0 \\le r_f  y)$ 或 $(y  0 \\text{ and } y  r_f \\le 0)$，则 $p_f = 1$。\n\n至此，推导完成。该逻辑现在可以用于 C 程序的实现。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include \n```"
        }
    ]
}