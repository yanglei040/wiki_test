{
    "hands_on_practices": [
        {
            "introduction": "内存对齐是实现 SIMD 峰值性能的关键因素，因为非对齐的内存访问可能导致严重的性能损失。这个实践问题将让你分析一个常见场景，并应用一种名为“循环剥离”(loop peeling)的编译器技术来解决它 。你将量化性能增益，从而具体理解为什么编译器会花费如此大的力气来确保数据为矢量指令正确对齐。",
            "id": "3670086",
            "problem": "一个编译器按如下方式对更新单精度值连续数组的循环进行矢量化：对于从 $0$ 到 $N-1$ 的索引 $i$，它执行 $x[i] \\leftarrow x[i] + c$ 操作，其中 $x$ 是一个元素大小为 $E$ 字节的数组，而 $c$ 是一个标量常数。该机器支持宽度为 $W$ 个元素的单指令多数据 (SIMD) 矢量，其自然对齐为 $A$ 字节。数组 $x$ 的基地址 $p$ 满足 $p \\bmod A = 8$ 字节。假设 $E = 4$ 字节（单精度），$W = 8$，$A = 32$ 字节，因此 $W \\cdot E = A$。元素总数为 $N = 1022$。\n\n使用以下成本模型，该模型受吞吐量限制，且迭代之间无重叠，成本可累加：\n- 处理一个元素的标量迭代成本为 $c_s = 3$ 个周期。\n- 处理 $W$ 个元素的对齐 SIMD 矢量迭代成本为 $c_a = 2$ 个周期。\n- 一次未对齐的 SIMD 矢量迭代（由于整个循环中持续的基地址未对齐）会产生每次矢量迭代 $d = 5$ 个周期的额外惩罚，因此其成本为 $c_a + d$。\n\n从内存对齐和同余的定义出发，确定所需的最小非负标量剥离迭代次数 $k$，使得在剥离 $k$ 次标量迭代后，SIMD 主体在与 $A$ 对齐的地址上操作。然后，提出由 $k$ 次迭代的标量序言、一个对齐的 SIMD 主体和处理剩余部分的标量结尾组成的循环结构。与不进行剥离并因此所有矢量迭代都未对齐执行的朴素 SIMD 矢量化相比，量化通过执行此循环剥离所节省的总周期数。将最终结果表示为节省的周期数的单个整数。在最终的方框答案中不要包含任何单位。",
            "solution": "用户要求我解决一个关于 SIMD 矢量化和内存对齐的编译器优化问题。我将首先验证问题陈述。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 循环操作为对于索引 $i$ 从 $0$ 到 $N-1$，$x[i] \\leftarrow x[i] + c$。\n- 元素总数：$N = 1022$。\n- 每个元素的大小：$E = 4$ 字节。\n- SIMD 矢量宽度：$W = 8$ 个元素。\n- 自然对齐要求：$A = 32$ 字节。\n- 数组 $x$ 的基地址 $p$ 具有属性 $p \\bmod A = 8$ 字节。\n- 题目说明 $W \\cdot E = A$，即 $8 \\cdot 4 = 32$，与给定值一致。\n- 单次标量迭代的成本：$c_s = 3$ 个周期。\n- 单次对齐 SIMD 矢量迭代的成本：$c_a = 2$ 个周期。\n- 单次未对齐 SIMD 矢量迭代的成本惩罚：$d = 5$ 个周期。\n- 单次未对齐 SIMD 矢量迭代的成本为 $c_a + d$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学性：** 该问题描述了计算机体系结构和编译器优化中的一个经典场景，特别是考虑了内存对齐的循环矢量化。成本模型虽然简化，但反映了标量处理与矢量处理之间现实世界中的性能权衡，以及未对齐内存访问的惩罚。其原理是合理的。\n- **良构性：** 所有必要的常数（$N$、$E$、$W$、$A$、$c_s$、$c_a$、$d$）和初始条件（$p \\bmod A = 8$）都已提供。所提出的问题——求出剥离迭代的次数、描述最终的循环结构并量化性能增益——是具体的，并能导出一个唯一的、有意义的解。\n- **客观性：** 该问题以精确、量化的术语陈述。成本模型有明确定义，没有主观解释的余地。\n\n**步骤 3：结论与行动**\n问题有效。它具有科学性、良构性和客观性。我将继续进行解答。\n\n### 解题过程\n\n解题过程包括三个主要部分：\n1.  确定为对齐主矢量循环的起始地址所需的标量剥离迭代次数 $k$。\n2.  计算朴素的、未对齐的矢量化策略的总执行时间。\n3.  计算使用循环剥离的优化策略的总执行时间，然后求出差值以量化节省的周期数。\n\n**1. 确定剥离迭代的次数 ($k$)**\n\n数组 $x$ 的第 $i$ 个元素的地址由 $p + i \\cdot E$ 给出，其中 $p$ 是基地址。为了让 SIMD 矢量循环在对齐的数据上操作，其起始地址必须是对齐大小 $A$ 的倍数。如果我们剥离 $k$ 次标量迭代，矢量循环将从索引 $k$ 开始处理。该元素的地址是 $p + k \\cdot E$。因此，对齐条件是：\n$$(p + k \\cdot E) \\bmod A = 0$$\n我们已知以下值：$p \\bmod A = 8$，$E = 4$，$A = 32$。将这些值代入同余关系式：\n$$((p \\bmod A) + (k \\cdot E) \\bmod A) \\bmod A = 0$$\n$$ (8 + 4k) \\bmod 32 = 0 $$\n这个方程意味着 $8 + 4k$ 必须是 $32$ 的倍数。我们可以将其写成一个整数方程：\n$$8 + 4k = 32j$$\n其中 $j$ 是一个正整数。我们寻求满足此条件的最小非负整数 $k$。\n$$4k = 32j - 8$$\n$$k = 8j - 2$$\n为了找到最小的非负 $k$，我们从 $1$ 开始测试 $j$ 的整数值：\n- 对于 $j=1$：$k = 8(1) - 2 = 6$。\n这是 $k$ 的最小非负整数值。\n因此，必须从循环开始处剥离 $k=6$ 次标量迭代。\n\n提议的循环结构如下：\n- **标量序言：** 一个从 $i=0$ 到 $k-1=5$ 迭代的循环，执行 $x[i] \\leftarrow x[i] + c$ 操作。\n- **对齐的 SIMD 主体：** 一个从索引 $i=k=6$ 开始的矢量化循环。它每次迭代处理 $W=8$ 个元素。此循环及后续结尾部分要处理的元素数量为 $N - k = 1022 - 6 = 1016$。矢量迭代的次数为 $\\lfloor \\frac{1016}{8} \\rfloor = 127$。此循环覆盖的索引范围为从 $6$ 到 $6 + (127 \\cdot 8) - 1 = 1021$。\n- **标量结尾：** 用于处理剩余元素的循环。剩余元素的数量为 $(N - k) \\bmod W = 1016 \\bmod 8 = 0$。因此，不需要标量结尾。\n\n**2. 计算朴素（未对齐）矢量化的成本**\n\n在朴素的矢量化策略中，编译器会生成一个从索引 $0$ 开始的 SIMD 循环，而不进行剥离。由于基地址 $p$ 未对齐 ($p \\bmod 32 = 8$)，所有的矢量内存访问都将是未对齐的，因为任何后续矢量块（在索引 $j \\cdot W$ 处）的起始地址是 $p + (j \\cdot W) \\cdot E = p + j \\cdot A$，并且 $(p + j \\cdot A) \\bmod A = p \\bmod A = 8 \\neq 0$。\n\n一次未对齐矢量迭代的成本是 $c_m = c_a + d = 2 + 5 = 7$ 个周期。\n完整的矢量迭代次数是 $N_{\\text{vec, naive}} = \\lfloor \\frac{N}{W} \\rfloor = \\lfloor \\frac{1022}{8} \\rfloor = 127$。\n矢量部分的成本是 $T_{\\text{vec, naive}} = N_{\\text{vec, naive}} \\cdot c_m = 127 \\cdot 7 = 889$ 个周期。\n\n必须由标量结尾处理的剩余元素数量是 $N_{\\text{epilogue, naive}} = N \\bmod W = 1022 \\bmod 8 = 6$。\n标量结尾的成本是 $T_{\\text{epilogue, naive}} = N_{\\text{epilogue, naive}} \\cdot c_s = 6 \\cdot 3 = 18$ 个周期。\n\n朴素策略的总成本是 $T_{\\text{naive}} = T_{\\text{vec, naive}} + T_{\\text{epilogue, naive}} = 889 + 18 = 907$ 个周期。\n\n**3. 计算优化（剥离后）矢量化的成本和节省量**\n\n在优化策略中，我们首先执行一个 $k=6$ 次迭代的标量序言。\n序言的成本是 $T_{\\text{prologue}} = k \\cdot c_s = 6 \\cdot 3 = 18$ 个周期。\n\n序言之后，还剩下 $N' = N - k = 1022 - 6 = 1016$ 个元素。SIMD 循环从索引 $6$ 开始，该处的地址是对齐的。此循环中的所有矢量迭代都是对齐的。\n对齐的矢量迭代次数是 $N_{\\text{vec, opt}} = \\lfloor \\frac{N'}{W} \\rfloor = \\lfloor \\frac{1016}{8} \\rfloor = 127$。\n矢量部分的成本是 $T_{\\text{vec, opt}} = N_{\\text{vec, opt}} \\cdot c_a = 127 \\cdot 2 = 254$ 个周期。\n\n最终标量结尾的元素数量是 $N_{\\text{epilogue, opt}} = N' \\bmod W = 1016 \\bmod 8 = 0$。\n结尾的成本是 $T_{\\text{epilogue, opt}} = 0$ 个周期。\n\n优化策略的总成本是 $T_{\\text{opt}} = T_{\\text{prologue}} + T_{\\text{vec, opt}} + T_{\\text{epilogue, opt}} = 18 + 254 + 0 = 272$ 个周期。\n\n最后，节省的总周期数是朴素成本和优化成本之差：\n$$\\text{Savings} = T_{\\text{naive}} - T_{\\text{opt}} = 907 - 272 = 635$$\n\n与朴素的未对齐矢量化相比，循环剥离策略节省了 $635$ 个周期。",
            "answer": "$$\\boxed{635}$$"
        },
        {
            "introduction": "SIMD 指令会推测性地对多个数据元素同时执行操作，这可能会违反语言的顺序语义，尤其是在可能出现异常（如除以零）的情况下。本练习探讨了 SIMD 的推测性执行与编译器必须遵守的“as-if”规则之间的冲突 。你将通过建模不同的执行语义，来观察天真的矢量化如何改变程序的可观察行为，并进一步实现安全措施以确保其正确性。",
            "id": "3670137",
            "problem": "你的任务是设计并实现一个完整且可运行的程序，用于检测一种称为单指令多数据 (SIMD) 矢量化的编译器转换，何时会改变一个可能因除零而引发异常的循环的可观察行为。核心场景是一个计算 $c[i] = a[i] / b[i]$ 的循环，索引 $i$ 从 $0$ 到 $n-1$，其中 $b[i]$ 可能等于 $0$，因此在循环被矢量化时，可能会改变异常发生的方式以及 $c[i]$ 元素被写入的方式。\n\n基本前提：在顺序执行模型中，程序按程序顺序（在循环索引上从左到右）执行操作。可观察行为包括哪些迭代执行了内存写入，以及是否发生了异常情况（如除零）。根据 as-if 规则和源语言的顺序语义，编译器受限于那些能够保持可观察行为不变的转换。然而，SIMD 矢量化中的推测性执行和乱序执行可能导致在顺序短路语义下不会执行的操作被执行，从而写入额外的元素，并改变异常出现的索引。这些事实被广泛接受，并作为本任务的基础出发点。\n\n使用以下要求设计一个检测器和多种防护措施：\n\n1. 为循环定义一个顺序标量语义：迭代 $i$ 从 $0$ 到 $n-1$，计算 $a[i]/b[i]$ 并赋值给 $c[i]$，直到遇到第一个满足 $b[s] = 0$ 的索引 $s$。此时，循环停止，不写入 $c[s]$ 或任何 $j \\ge s$ 的 $c[j]$。为了此检测器的目的，将任何满足 $b[i] = 0$（包括 $-0$）的值都视作零。\n\n2. 定义一个使用固定矢量宽度 $w$ 的朴素 SIMD 矢量化语义模型：以宽度为 $w$ 的区块处理索引，为区块通道 $j$（其中 $i+j  n$）执行所有除法 $a[i+j]/b[i+j]$，并将所有结果写入 $c[i+j]$，即使某些 $b[i+j] = 0$。这模拟了跨通道的推测性执行，并且不会在遇到第一个零时短路。\n\n3. 定义两种防护措施以保持与标量语义相同的可观察行为：\n   - 防护 $G_1$（预扫描与回退）：预先扫描整个 $b[i]$ 数组，检查是否有任何 $b[i] = 0$。如果发现任何零，则完全跳过矢量化并执行标量循环；否则，使用朴素 SIMD 矢量化语义。这是一个保守的选择，确保在存在零时行为完全相同，并且仅在安全时才进行完全矢量化。\n   - 防护 $G_2$（掩码前缀）：通过预扫描计算第一个零的索引 $s$。仅对索引 $i  s$ 执行矢量化计算；不为任何 $i \\ge s$ 的索引写入 $c[i]$。这模拟了一种矢量化掩码执行，它尊重短路行为，并避免在第一个异常索引及其之后进行推测性写入。\n\n4. 实现一个检测器，比较朴素 SIMD 矢量化语义产生的结果与标量语义产生的结果，并报告行为是否发生改变。为了使比较明确无误，将所有 $c[i]$ 初始化为非数值（not-a-number），并将任何保持为非数值的 $c[i]$ 视为“未写入”。如果在矢量化语义和标量语义之间，任何索引 $k$ 的写入状态或值存在差异，则检测到行为改变。所有计算均使用双精度浮点算术。如果在矢量化语义下任何除法生成了 $\\infty$ 或非数值，出于检测目的，将其视为一次有效的写入。\n\n5. 对于每种防护措施（$G_1$ 和 $G_2$），实现其相应的语义，并报告该防护措施是否保持了与标量语义相同的行为。\n\n6. 你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是针对一个测试用例的三整数列表 $[x_1, x_2, x_3]$，其中 $x_1$ 表示朴素 SIMD 矢量化语义相对于标量语义是否改变了行为，$x_2$ 表示防护 $G_1$ 是否保持了行为，$x_3$ 表示防护 $G_2$ 是否保持了行为。使用 $0$ 表示“无改变”或“已保持”，使用 $1$ 表示“已改变”或“未保持”。\n\n不涉及物理单位。角度不适用。百分比不适用。\n\n测试套件与覆盖范围：\n\n所有测试用例均使用固定的矢量宽度 $w = 4$。每个测试的循环长度 $n$ 以及数组 $a$ 和 $b$ 如下所示。所有值均为双精度字面量。\n\n- 测试用例 1（理想情况，无零值）：\n  - $n = 6$\n  - $a = [\\,1,\\,2,\\,3,\\,4,\\,5,\\,6\\,]$\n  - $b = [\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$\n\n- 测试用例 2（多个零，较早出现零）：\n  - $n = 6$\n  - $a = [\\,10,\\,20,\\,30,\\,40,\\,50,\\,60\\,]$\n  - $b = [\\,2,\\,0,\\,5,\\,10,\\,0,\\,3\\,]$\n\n- 测试用例 3（零在首位索引）：\n  - $n = 4$\n  - $a = [\\,7,\\,8,\\,9,\\,10\\,]$\n  - $b = [\\,0,\\,2,\\,3,\\,4\\,]$\n\n- 测试用例 4（零在末位索引）：\n  - $n = 4$\n  - $a = [\\,8,\\,16,\\,24,\\,32\\,]$\n  - $b = [\\,2,\\,2,\\,2,\\,0\\,]$\n\n- 测试用例 5（带符号的零）：\n  - $n = 4$\n  - $a = [\\,1.0,\\,-2.0,\\,3.5,\\,-4.5\\,]$\n  - $b = [\\,1.0,\\,-0.0,\\,2.0,\\,2.0\\,]$\n\n- 测试用例 6（零跨越矢量区块边界）：\n  - $n = 9$\n  - $a = [\\,1,\\,2,\\,3,\\,4,\\,5,\\,6,\\,7,\\,8,\\,9\\,]$\n  - $b = [\\,1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,1,\\,1,\\,1\\,]$\n\n最终输出格式规范：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个包含三个整数的方括号列表 $[x_1,x_2,x_3]$。例如，包含两个测试用例的有效输出应为 $[[0,0,0],[1,0,0]]$。你的程序必须严格按照此格式生成一行输出，且不得读取任何输入。",
            "solution": "该问题要求设计并实现一个程序，用以分析编译器进行的 SIMD（单指令，多数据）矢量化如何改变一个循环的可观察行为，特别是在存在除零异常的情况下。该分析通过将一个明确定义的顺序（标量）循环的输出与一个朴素矢量化循环以及两个带防护措施的矢量化循环的输出进行比较来执行。\n\n问题的核心原则是编译器对 `as-if` 规则的遵守，该规则允许任何不改变由语言抽象机所定义的程序可观察行为的转换。在像 C 这样的顺序语言中，程序的执行及其副作用（内存写入、异常）由程序顺序定义。像 `for (i=0; i",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include"
        },
        {
            "introduction": "对于包含数据依赖（例如直方图等归约操作）的循环，矢量化是一项挑战，因为多个通道可能试图同时更新同一内存位置，从而产生竞争条件。这个问题介绍了一种强大的矢量化归约模式：通道私有化 (lane privatization)。你将为每个通道提供一个私有数据副本，而不是对共享数据结构使用缓慢的原子操作，并仅在最后合并结果 。这个练习展示了如何将一个看似顺序的问题转化为一个高度并行的任务，这是高性能计算中的一项核心技能。",
            "id": "3670122",
            "problem": "给定一个整数观测序列，您必须使用单指令多数据（SIMD）原则计算一个具有 $k$ 个箱（bin）的直方图。其目标是将一个逻辑上的标量直方图更新操作转换为一种通过私有化每个通道的箱（bin）然后进行合并的方法，从而消除对原子增量的需求，并分析在并行更新单个共享直方图时可能出现的竞争。\n\n使用的基本依据和定义：\n- 一个宽度为 $L$ 的 SIMD 向量在 $L$ 个独立的通道上执行相同的指令。在标量代码中，对共享数组的直方图增量操作需要在单个内存位置上进行读-改-写。在并行的 SIMD 解释中， $L$ 个通道中的每一个都会同时尝试进行这样的增量操作，如果这些增量操作的目标是同一个箱（bin），为了保证正确性，这将需要原子操作。\n- 一个具有 $k$ 个箱（bin）的直方图由一个映射 $b(x)$ 定义，该映射将每个观测值 $x$ 映射到一个位于 $\\{0, 1, \\dots, k-1\\}$ 中的箱索引。在本问题中，假设 $x \\in \\{0, 1, \\dots, k-1\\}$， $b(x)$ 是恒等映射 $b(x) = x$。\n- 通道私有化设计为每个通道分配 $k$ 个计数器，并在主处理阶段中以每个通道私有的方式执行增量，无需原子操作，然后通过一个合并步骤，以加法方式将 $L$ 个私有直方图归约为一个全局直方图。在单线程程序中，此合并无需原子操作。\n\n需要执行的竞争分析：\n- 令 $p_i$ 表示一个观测值映射到箱 $i$ 的概率，其中 $i \\in \\{0, \\dots, k-1\\}$。对于一个大小为 $s$ 的 SIMD 向量组（对于最后一个组，$s \\le L$），根据 $\\{p_i\\}$ 抽取 $s$ 个独立的箱分配。将竞争度量定义为该组内映射到同一个箱的无序通道对的数量。利用期望的线性和独立性假设，一组中此类冲突对的期望数量为\n$$\n\\mathbb{E}[\\text{pairs in one group of size } s] \\;=\\; \\binom{s}{2} \\sum_{i=0}^{k-1} p_i^2.\n$$\n如果 $L \\nmid N$，则最后一个组的大小为 $s_{\\text{last}}  L$。预期的总冲突对数是此表达式在所有组上的总和。\n\n编程任务：\n- 在相同的输入上实现两种直方图计算：\n  1. 一个逻辑上需要原子增量的朴素共享直方图更新（您将在单线程中顺序模拟它以获得最终计数）。\n  2. 一个具有 $L$ 个通道的通道私有化 SIMD 风格直方图：为每个通道维护 $k$ 个计数器，以大小为 $L$ 的组为单位，在每个通道上跨数据集私有地对它们进行增量，然后通过按箱求和将 $L$ 个私有直方图合并成一个单一的 $k$ 箱直方图。在单线程程序中，此合并仅使用普通加法。\n- 验证两个结果直方图是否相同。\n- 计算：\n  1. 观察到的竞争对：对于每个大小为 $s$ 的组，计算组内每个箱的重复数，对所有箱求和 $\\binom{m}{2}$（其中 $m$ 是该组中每个箱的计数），并在所有组上累加。\n  2. 使用经验箱概率 $p_i = \\frac{h_i}{N}$ 计算预期的竞争对，其中 $h_i$ 是箱 $i$ 的朴素直方图计数，$N$ 是数据集长度。对于每个大小为 $s$ 的组，将 $\\binom{s}{2} \\sum_i p_i^2$ 加到总数中。\n  3. 朴素方法在处理期间所需的原子增量总数，等于 $N$。\n  4. 通道私有化方法在处理期间所需的原子增量数，在单线程程序中等于 $0$。\n  5. 如果您通过复制通道 0 的数据，然后按箱加上通道 1 到 $L-1$ 的数据来实现合并，则在合并步骤中执行的标量加法次数，等于 $k \\cdot (L - 1)$。\n\n用于测试不同行为的测试套件：\n- 情况 A（由于结构化数据，观察到的竞争最小的理想路径）：\n  - $k = 16$， $L = 8$， $N = 64$。\n  - 数据：$d_j = j \\bmod 16$，对于 $j = 0, 1, \\dots, 63$。\n- 情况 B（导致高竞争的倾斜分布）：\n  - $k = 4$， $L = 8$， $N = 40$。\n  - 数据：如果 $(j \\bmod 5) \\neq 0$，则 $d_j = 0$，否则 $d_j = j \\bmod 4$，对于 $j = 0, 1, \\dots, 39$。\n- 情况 C（所有观测值都指向同一个箱的退化分布）：\n  - $k = 1$， $L = 8$， $N = 32$。\n  - 数据：对于所有的 $j$，$d_j = 0$。\n- 情况 D（标量宽度的边界条件）：\n  - $k = 10$， $L = 1$， $N = 37$。\n  - 数据：$d_j = j \\bmod 10$，对于 $j = 0, 1, \\dots, 36$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 按 A、B、C、D 的顺序，为每种情况输出六个值：\n  1. 如果朴素直方图和私有化直方图完全相等，则为布尔整数 $1$，否则为 $0$。\n  2. 观察到的竞争对（整数）。\n  3. 预期的竞争对（浮点数，四舍五入到六位小数）。\n  4. 朴素处理期间的原子增量总数，等于 $N$（整数）。\n  5. 私有化处理期间的原子增量数，等于 $0$（整数）。\n  6. 合并期间的标量加法数，等于 $k \\cdot (L - 1)$（整数）。\n- 因此，单行包含 24 个用方括号括起来的逗号分隔值，顺序为：$\\text{eq}_A,\\text{obsPairs}_A,\\text{expPairs}_A,\\text{naiveAtomics}_A,\\text{privAtomics}_A,\\text{mergeAdds}_A,\\dots,\\text{eq}_D,\\text{obsPairs}_D,\\text{expPairs}_D,\\text{naiveAtomics}_D,\\text{privAtomics}_D,\\text{mergeAdds}_D$。",
            "solution": "所提出的问题要求对两种直方图算法——一种朴素的、基于共享内存的方法和一种模拟单指令多数据（SIMD）执行的通道私有化方法——进行分析和比较，同时对内存访问竞争进行定量分析。该问题定义明确，科学上基于既定的计算机科学原理，并且为所需的计算提供了所有必要的参数和公式。我们将着手提供一个完整的解决方案。\n\n核心任务是根据一个包含 $N$ 个整数观测值的数据集，计算一个具有 $k$ 个箱（bin）的直方图。观测值 $x$ 的箱索引由恒等映射 $b(x) = x$ 给出。\n\n**1. 朴素（共享）直方图实现**\n\n该方法利用一个大小为 $k$ 的单一共享数组 `hist` 来存储箱计数。算法通过逐一迭代 $N$ 个观测值来进行。对于每个观测值 $d_j$，相应箱的计数会增加：\n$$ \\text{hist}[b(d_j)] \\leftarrow \\text{hist}[b(d_j)] + 1 $$\n在一个真正的并行执行环境中，多个线程或 SIMD 通道可以并发处理不同的数据元素，这种对共享内存位置的读-改-写操作会引入竞争条件。如果两个通道同时读取同一个计数器值，两者都基于旧值计算一个新值，当它们都写回时，其中一个更新就会丢失。为确保正确性，每次增量都必须以原子方式执行。因此，对于大小为 $N$ 的数据集，朴素的并行方法将需要 $N$ 次原子增量。在这个单线程模拟中，我们执行标准增量，但将所需的逻辑原子操作数计为 $N$。\n\n**2. 通道私有化 SIMD 风格实现**\n\n该方法旨在消除主处理阶段对原子操作的需求。关键思想是私有化。我们不使用一个共享直方图，而是分配 $L$ 个私有直方图，每个 SIMD 通道一个。这个结构可以表示为一个大小为 $L \\times k$ 的二维数组 `private_hist`。\n\n该算法分两个阶段运行：\n\n**阶段 1：并行处理（模拟）**\n数据集以大小为 $L$ 的块进行处理。对于每个块，通道 $l$（其中 $l \\in \\{0, 1, \\dots, L-1\\}$）负责单个观测值。它更新自己的私有直方图，不干扰任何其他通道。\n$$ \\text{private\\_hist}[l][b(d_{j+l})] \\leftarrow \\text{private\\_hist}[l][b(d_{j+l})] + 1 $$\n由于每个通道只写入其私有内存，因此不存在数据竞争，也无需原子操作。此处理阶段的原子增量数为 $0$。如果 $N$ 不是 $L$ 的倍数，最后一组会更小，包含 $N \\pmod L$ 个元素。\n\n**阶段 2：合并**\n所有观测值处理完毕后，$L$ 个私有直方图必须合并成一个单一的最终直方图。这是一个归约操作。一个直接的方法是通过复制第一个通道直方图的内容来初始化最终直方图，然后串行地加上其余 $L-1$ 个通道的内容。对于 $L-1$ 个通道中的每一个，我们执行 $k$ 次标量加法。因此，合并步骤中的标量加法总数为：\n$$ \\text{合并加法数} = k \\cdot (L-1) $$\n如果 $L=1$，这个值正确地为 $0$，因为不需要合并。这个最终直方图必须与朴素方法生成的直方图完全相同。\n\n**3. 竞争分析**\n\n在朴素模型中，当一个 SIMD 组中的多个通道试图同时更新同一个箱时，就会发生竞争。我们从经验和理论上分析这种竞争。\n\n**观察到的竞争对**\n我们以大小为 $s$ 的组（对于完整组 $s=L$，对于最后一组 $s  L$）遍历数据集。对于每个组，我们计算映射到每个箱 $i$ 的观测值数量 $m_i$。该组内单个箱 $i$ 的冲突对数量是选择两个映射到它的观测值的方法数，即 $\\binom{m_i}{2} = \\frac{m_i(m_i-1)}{2}$。该组的总观察竞争是对所有箱求和 $\\sum_{i=0}^{k-1} \\binom{m_i}{2}$。总计是这些值在所有组上的总和。\n\n**预期的竞争对**\n预期冲突对的数量是基于箱分配的经验概率分布计算的。首先，计算朴素直方图计数 $h_i$。一个观测值落入箱 $i$ 的经验概率是 $p_i = h_i / N$。项 $\\sum_{i=0}^{k-1} p_i^2$ 表示两个随机选择的独立观测值落入同一个箱的概率。\n对于一组 $s$ 个独立的观测值，有 $\\binom{s}{2}$ 对观测值。根据期望的线性性，该组中冲突对的期望数量是：\n$$ \\mathbb{E}[\\text{pairs in group of size } s] = \\binom{s}{2} \\sum_{i=0}^{k-1} p_i^2 $$\n总的预期竞争是该量在数据集中所有组上的总和。\n\n现在，实现将继续为四个指定的测试用例计算这些指标。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include"
        }
    ]
}