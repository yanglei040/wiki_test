{
    "hands_on_practices": [
        {
            "introduction": "控制依赖初看起来可能很直观，但严谨的分析常常会揭示其中的精妙之处。第一个练习使用一个简单的条件语句序列，旨在说明为什么基于后支配者（postdominator）概念的形式化定义至关重要，它能帮助我们准确识别那些仅凭直觉可能会错过的依赖关系。",
            "id": "3632542",
            "problem": "考虑以下包含两个基于相同布尔表达式的条件语句和一个结尾语句的顺序代码片段：\nif ($p$) $S_1$;\nif ($\\lnot p$) $S_2$;\n$S_3$;\n假设 $p$ 在求值时没有副作用；$S_1$、$S_2$ 和 $S_3$ 是基本块，它们不抛出异常，不执行异常控制转移，并且总是顺序执行到其后继语句。将此片段建模为一个控制流图（CFG），该图包含一个 $Entry$ 节点、一个 $Exit$ 节点和两个不同的谓词节点：$B_1$ 用于对 $p$ 的第一次测试，$B_2$ 用于对 $\\lnot p$ 的第二次测试；then-分支分别指向 $S_1$ 和 $S_2$，而 else-分支则顺序执行到序列中的下一条语句。\n\n使用基于后支配的控制依赖的标准基础理论：\n- 如果从节点 $Y$ 到 $Exit$ 的每条路径都包含节点 $X$，则称节点 $X$ 后支配节点 $Y$。\n- 如果节点 $Y$ 至少有两个后继节点，并且节点 $X$ 后支配 $Y$ 的某些但非全部后继节点，则称节点 $X$ 控制依赖于节点 $Y$。\n\n将“控制依赖于 $p$”解释为“控制依赖于对 $p$ 或 $\\lnot p$ 求值的谓词节点之一”，即 $B_1$ 或 $B_2$。在此意义上，$S_1$、$S_2$、$S_3$ 中哪些语句控制依赖于 $p$？\n\n选择唯一的最佳选项：\nA. 仅 $S_1$\n\nB. 仅 $S_2$\n\nC. $S_1$ 和 $S_2$，但非 $S_3$\n\nD. $S_1$、$S_2$ 和 $S_3$\n\nE. $S_1$、$S_2$、$S_3$ 均不",
            "solution": "问题陈述是关于控制依赖分析的一个有效练习，这是编译器理论中的一个标准主题。它提供了一个清晰的代码片段、一套用于构建相应控制流图 (CFG) 的特定规则，以及关于后支配和控制依赖的精确定义。该问题是自包含的、逻辑一致且良构的。\n\n解题过程分为三步：\n1.  根据问题描述构建控制流图 (CFG)。\n2.  分析 CFG 内的后支配关系。\n3.  应用控制依赖的定义来确定语句 $S_1$、$S_2$ 和 $S_3$ 对谓词节点 $B_1$ 和 $B_2$ 的依赖关系。\n\n**1. 控制流图 (CFG) 构建**\n\n问题指定了程序片段和 CFG 的结构。\n程序片段：\n```\nif (p) S1;\nif (¬p) S2;\nS3;\n```\n节点为 $Entry$、$B_1$ (用于 `if (p)`)、$S_1$、$B_2$ (用于 `if (¬p)`)、$S_2$、$S_3$ 和 $Exit$。边由控制流和顺序执行行为决定：\n\n-   $Entry \\rightarrow B_1$: 执行从第一个条件语句开始。\n-   $B_1 \\xrightarrow{\\text{true}} S_1$: 如果 $p$ 为真，执行 $S_1$。\n-   $B_1 \\xrightarrow{\\text{false}} B_2$: 如果 $p$ 为假，跳过 $S_1$ 并顺序执行到下一条语句，该语句从 $B_2$ 开始。\n-   $S_1 \\rightarrow B_2$: $S_1$ 执行后，顺序执行到下一条语句，该语句从 $B_2$ 开始。\n-   $B_2 \\xrightarrow{\\text{true}} S_2$: 如果 $\\lnot p$ 为真（即 $p$ 为假），执行 $S_2$。\n-   $B_2 \\xrightarrow{\\text{false}} S_3$: 如果 $\\lnot p$ 为假（即 $p$ 为真），跳过 $S_2$ 并顺序执行到 $S_3$。\n-   $S_2 \\rightarrow S_3$: $S_2$ 执行后，顺序执行到 $S_3$。\n-   $S_3 \\rightarrow Exit$: $S_3$ 执行后，片段终止。\n\n我们可以根据 $p$ 的值追踪两条可能的执行路径：\n-   如果 $p$ 为真：$Entry \\rightarrow B_1 \\rightarrow S_1 \\rightarrow B_2 \\rightarrow S_3 \\rightarrow Exit$。\n-   如果 $p$ 为假：$Entry \\rightarrow B_1 \\rightarrow B_2 \\rightarrow S_2 \\rightarrow S_3 \\rightarrow Exit$。\n\n**2. 后支配分析**\n\n所提供的定义指出：如果从节点 $Y$ 到 $Exit$ 的每条路径都包含节点 $X$，则称节点 $X$ 后支配节点 $Y$。我们分析控制依赖检查所需的关键后支配关系。\n\n-   **$S_3$ 的后支配分析**：\n    -   从 $S_2$ 出发的任何路径都必须经过 $S_3$ ($S_2 \\rightarrow S_3 \\rightarrow Exit$)。因此，$S_3$ 后支配 $S_2$。\n    -   从 $B_2$ 出发的路径是 $B_2 \\rightarrow S_2 \\rightarrow S_3 \\rightarrow Exit$ 和 $B_2 \\rightarrow S_3 \\rightarrow Exit$。两条路径都包含 $S_3$。因此，$S_3$ 后支配 $B_2$。\n    -   从 $S_1$ 出发的任何路径都必须经过 $B_2$ ($S_1 \\rightarrow B_2 \\rightarrow ...$)，并且我们已经确定 $S_3$ 后支配 $B_2$。因此，$S_3$ 后支配 $S_1$。\n    -   从 $B_1$ 出发的路径是 $B_1 \\rightarrow S_1 \\rightarrow B_2 \\rightarrow S_3 \\rightarrow Exit$ 和 $B_1 \\rightarrow B_2 \\rightarrow S_2 \\rightarrow S_3 \\rightarrow Exit$。两条路径都包含 $S_3$。因此，$S_3$ 后支配 $B_1$。\n\n-   **涉及 $S_1$ 的后支配分析**：\n    -   从 $B_1$ 出发的一条路径是 $B_1 \\rightarrow B_2 \\rightarrow ...$。该路径不包含 $S_1$。因此，$S_1$ 不后支配 $B_1$。\n    -   从 $B_2$ 出发的一条路径是 $B_2 \\rightarrow S_2 \\rightarrow S_3 \\rightarrow Exit$。该路径不包含 $S_1$。因此，$S_1$ 不后支配 $B_2$。\n\n-   **涉及 $S_2$ 的后支配分析**：\n    -   从 $B_2$ 出发的一条路径是 $B_2 \\rightarrow S_3 \\rightarrow Exit$。该路径不包含 $S_2$。因此，$S_2$ 不后支配 $B_2$。\n    -   从 $S_3$ 出发的一条路径是 $S_3 \\rightarrow Exit$`。该路径不包含 `$S_2$`。因此，`$S_2$` 不后支配 `$S_3$`。\n\n**3. 控制依赖分析**\n\n所提供的定义指出：如果节点 $Y$ 至少有两个后继节点，并且节点 $X$ 后支配 $Y$ 的某些但非全部后继节点，则称节点 $X$ 控制依赖于节点 $Y$。我们针对谓词 $B_1$ 和 $B_2$，为每个语句 $S_1, S_2, S_3$ 检查此条件。\n\n**对 $B_1$ 的控制依赖**\n-   谓词节点是 $Y=B_1$。其后继节点是 $S_1$（真分支）和 $B_2$（假分支）。\n\n-   $S_1$ 是否控制依赖于 $B_1$？($X=S_1$)\n    -   $S_1$ 是否后支配 $S_1$？是，这是当然的。\n    -   $S_1$ 是否后支配 $B_2$？否。存在从 $B_2$ 到 $Exit$ 的路径不经过 $S_1$。\n    -   由于 $S_1$ 后支配一个后继节点（$S_1$）但不是另一个（$B_2$），因此**$S_1$ 控制依赖于 $B_1$**。\n\n-   $S_2$ 是否控制依赖于 $B_1$？($X=S_2$)\n    -   $S_2$ 是否后支配 $S_1$？否。路径 $S_1 \\rightarrow B_2 \\rightarrow S_3 \\rightarrow Exit$ 不包含 $S_2$。\n    -   $S_2$ 是否后支配 $B_2$？否。路径 $B_2 \\rightarrow S_3 \\rightarrow Exit$ 不包含 $S_2$。\n    -   由于 $S_2$ 不后支配任何一个后继节点，因此**$S_2$ 不控制依赖于 $B_1$**。\n\n-   $S_3$ 是否控制依赖于 $B_1$？($X=S_3$)\n    -   $S_3$ 是否后支配 $S_1$？是，如后支配分析所示。\n    -   $S_3$ 是否后支配 $B_2$？是，如后支配分析所示。\n    -   由于 $S_3$ 后支配 $B_1$ 的*所有*后继节点，因此**$S_3$ 不控制依赖于 $B_1$**。\n\n**对 $B_2$ 的控制依赖**\n-   谓词节点是 $Y=B_2$。其后继节点是 $S_2$（$\\lnot p$ 的真分支）和 $S_3$（$\\lnot p$ 的假分支）。\n\n-   $S_1$ 是否控制依赖于 $B_2$？($X=S_1$)\n    -   $S_1$ 是否后支配 $S_2$？否。路径 $S_2 \\rightarrow S_3 \\rightarrow Exit$ 不包含 $S_1$。\n    -   $S_1$ 是否后支配 $S_3$？否。路径 $S_3 \\rightarrow Exit$ 不包含 $S_1$。\n    -   由于 $S_1$ 不后支配任何一个后继节点，因此**$S_1$ 不控制依赖于 $B_2$**。\n\n-   $S_2$ 是否控制依赖于 $B_2$？($X=S_2$)\n    -   $S_2$ 是否后支配 $S_2$？是，这是当然的。\n    -   $S_2$ 是否后支配 $S_3$？否。路径 $S_3 \\rightarrow Exit$ 不包含 $S_2$。\n    -   由于 $S_2$ 后支配一个后继节点（$S_2$）但不是另一个（$S_3$），因此**$S_2$ 控制依赖于 $B_2$**。\n\n-   $S_3$ 是否控制依赖于 $B_2$？($X=S_3$)\n    -   $S_3$ 是否后支配 $S_2$？是，如后支配分析所示。\n    -   $S_3$ 是否后支配 $S_3$？是，这是当然的。\n    -   由于 $S_3$ 后支配 $B_2$ 的*所有*后继节点，因此**$S_3$ 不控制依赖于 $B_2$**。\n\n**结论**\n-   $S_1$ 控制依赖于 $B_1$。\n-   $S_2$ 控制依赖于 $B_2$。\n-   $S_3$ 不控制依赖于 $B_1$ 或 $B_2$。\n\n问题询问哪些语句“控制依赖于 $p$”，意即控制依赖于 $B_1$ 或 $B_2$。根据我们的分析，这些语句是 $S_1$ 和 $S_2$。\n\n**逐项分析**\n-   A. 仅 $S_1$：**不正确**。$S_2$ 控制依赖于 $B_2$。\n-   B. 仅 $S_2$：**不正确**。$S_1$ 控制依赖于 $B_1$。\n-   C. $S_1$ 和 $S_2$，但非 $S_3$：**正确**。这与我们的分析相符。$S_1$ 依赖于 $B_1$，$S_2$ 依赖于 $B_2$，而 $S_3$ 两者都不依赖，因为它是汇合点的后支配节点。\n-   D. $S_1$、$S_2$ 和 $S_3$：**不正确**。$S_3$ 不控制依赖于任何一个谓词。\n-   E. $S_1$、$S_2$、$S_3$ 均不：**不正确**。如前所示，$S_1$ 和 $S_2$ 是控制依赖的。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在掌握了基础知识之后，我们将控制依赖分析应用于一个更动态的结构：一个具有多个出口路径的循环。这个练习突出了该分析的一个关键优势：它能够精确地指出哪些语句的执行是由循环的正常终止条件决定的，哪些是由像 `break` 这样的提前退出条件决定的。这种区分对于许多编译器优化至关重要。",
            "id": "3632600",
            "problem": "考虑以下控制流图 (Control Flow Graph, CFG)，它表示一个具有两种不同退出路径的循环：一个 $break$ 退出和一个正常退出。节点标记如下：$N_0$ (入口)，$N_1$ (循环头测试)，$N_2$ (循环体)，$N_3$ (break 决定)，$N_4$ (到 $N_1$ 的循环回边)，$N_{be}$ (通过 $break$ 退出到达的循环后路径的起点)，$N_{ne}$ (通过正常退出到达的循环后路径的起点)，$P_{b1}$、$P_{b2}$ (循环后 $break$ 退出路径上的语句)，$P_{n1}$、$P_{n2}$、$P_{n3}$ (循环后正常退出路径上的语句)，$J$ (两条循环后路径合并的连接节点)，$S_{c1}$、$S_{c2}$ (连接后的公共语句)，以及 $X$ (唯一的程序出口)。有向边如下：\n- $N_0 \\to N_1$。\n- $N_1$ (循环测试) 有两个后继节点：当结果为真 (迭代) 时为 $N_1 \\to N_2$，当结果为假 (正常退出) 时为 $N_1 \\to N_{ne}$。\n- $N_2 \\to N_3$。\n- $N_3$ (break 决定) 有两个后继节点：当结果为真 (执行 $break$) 时为 $N_3 \\to N_{be}$，当结果为假 (继续循环) 时为 $N_3 \\to N_4$。\n- $N_4 \\to N_1$ (回边)。\n- $N_{be} \\to P_{b1} \\to P_{b2} \\to J$。\n- $N_{ne} \\to P_{n1} \\to P_{n2} \\to P_{n3} \\to J$。\n- $J \\to S_{c1} \\to S_{c2} \\to X$。\n\n假设循环保证在有限次迭代内终止，因此从任何节点出发的每条路径最终都会到达 $X$，并且除了所示的出口之外，没有其他出口或异常控制转移。从任一出口 ($N_{be}$ 或 $N_{ne}$) 出发的所有路径都汇入 $J$，然后通过 $S_{c1}$ 和 $S_{c2}$ 到达 $X$。\n\n使用基于后支配 (postdominator) 的标准控制依赖定义：如果节点 $Y$ 后支配 $Z$ 的某个特定后继节点 $s$，但 $Y$ 不后支配 $Z$，则节点 $Y$ 控制依赖于节点 $Z$ (相对于后继 $s$)。设 $D_b$ 为控制依赖于 $break$ 退出路径的循环后语句节点的集合，这被理解为通过后继 $N_{be}$ 对 $N_3$ 的依赖。设 $D_n$ 为控制依赖于正常退出路径的循环后语句节点的集合，这被理解为通过后继 $N_{ne}$ 对 $N_1$ 的依赖。定义 $d_b = |D_b|$ 和 $d_n = |D_n|$。\n\n计算标量 $\\Phi = d_b^{2} - 2 d_n$。请以单个实数形式提供 $\\Phi$ 的最终值。不需要也不允许进行四舍五入。",
            "solution": "控制依赖分析的基础是后支配关系。如果从节点 $Q$ 到唯一程序出口 $X$ 的每一条路径都包含节点 $P$，那么节点 $P$ 后支配节点 $Q$。当且仅当节点 $Y$ 后支配 $Z$ 的某个特定后继节点 $s$，但 $Y$ 不后支配 $Z$ 时，节点 $Y$ 控制依赖于节点 $Z$ (相对于后继 $s$)。我们将此定义应用于指定的退出决策及其后继节点。\n\n我们首先在所有路径都到达 $X$ 的假设下推导后支配关系。从 CFG 可以看出，两个退出路径（$N_{be}$ 用于 $break$ 退出，$N_{ne}$ 用于正常退出）都汇入 $J$，然后通过 $S_{c1}$ 和 $S_{c2}$ 到达 $X$。因此，序列 $J \\to S_{c1} \\to S_{c2} \\to X$ 位于所有已经离开循环并通往 $X$ 的路径上。此外，由于循环保证终止，任何从循环内节点出发的路径最终都会通过 $N_{be}$ 或 $N_{ne}$ 退出，因此也会经过 $J$、$S_{c1}$、$S_{c2}$ 并到达 $X$。\n\n我们分别为两个退出决策计算控制依赖集。\n\n$break$ 退出控制依赖集 $D_b$：\n- break 决策发生在 $N_3$，其 $break$ 后继是 $N_{be}$ (真分支)，继续后继是 $N_4$ (假分支)。考虑后继 $N_{be}$。节点 $P_{b1}$ 和 $P_{b2}$ 严格位于从 $N_{be}$ 到 $J$ 的路径上，因此从 $N_{be}$ 到 $X$ 的每条路径都包含 $P_{b1}$ 和 $P_{b2}$。因此，$P_{b1}$ 和 $P_{b2}$ 后支配 $N_{be}$。\n- $P_{b1}$ 和 $P_{b2}$ 是否后支配 $N_3$？不是。从 $N_3$ 出发，假分支的后继 $N_4$ 会回到循环中的 $N_1$，并可能沿着通过 $N_{ne}$ 的正常退出路径到达 $X$，这条路径不经过 $P_{b1}$ 或 $P_{b2}$。因此，$P_{b1}$ 和 $P_{b2}$ 不后支配 $N_3$。\n- 根据定义，后支配 $N_{be}$ 但不后支配 $N_3$ 的节点 $Y$ 在后继 $N_{be}$ 上控制依赖于 $N_3$。因此 $P_{b1}$ 和 $P_{b2}$ 属于 $D_b$。\n- 那么 $J$、$S_{c1}$ 和 $S_{c2}$ 呢？这些节点中的每一个都位于从 $N_3$ 到 $X$ 的所有路径上，因为无论选择 $break$ 还是继续循环，终止路径都会经过 $J$，然后是 $S_{c1}$ 和 $S_{c2}$。因此，$J$、$S_{c1}$ 和 $S_{c2}$ 后支配 $N_3$。所以，根据定义，它们不相对于任何后继结果控制依赖于 $N_3$。\n- 因此 $D_b = \\{P_{b1}, P_{b2}\\}$ 且 $d_b = |D_b| = 2$。\n\n正常退出控制依赖集 $D_n$：\n- 正常退出决策发生在循环头 $N_1$，其后继为 $N_2$ (真，继续循环) 和 $N_{ne}$ (假，正常退出)。考虑后继 $N_{ne}$。节点 $P_{n1}$、$P_{n2}$ 和 $P_{n3}$ 严格位于从 $N_{ne}$ 到 $J$ 的路径上，所以从 $N_{ne}$ 到 $X$ 的每条路径都包含 $P_{n1}$、$P_{n2}$ 和 $P_{n3}$。因此，$P_{n1}$、$P_{n2}$ 和 $P_{n3}$ 后支配 $N_{ne}$。\n- $P_{n1}$、$P_{n2}$ 和 $P_{n3}$ 是否后支配 $N_1$？不是。存在从 $N_1$ 经过 $N_2$ 和循环体到 $N_3$ 的路径，这些路径可能通过 $N_{be}$ 执行 $break$ 退出；这样的到 $X$ 的路径不包含 $P_{n1}$、$P_{n2}$ 或 $P_{n3}$。因此，这些节点不后支配 $N_1$。\n- 根据定义，后支配 $N_{ne}$ 但不后支配 $N_1$ 的节点 $Y$ 在后继 $N_{ne}$ 上控制依赖于 $N_1$。因此 $P_{n1}$、$P_{n2}$ 和 $P_{n3}$ 属于 $D_n$。\n- 和之前一样，根据终止假设，$J$、$S_{c1}$ 和 $S_{c2}$ 后支配 $N_1$，因为两种最终结果（正常退出或 break）都会通向 $J$ 及之后的节点。因此，这些公共的循环后节点不相对于任何后继控制依赖于 $N_1$。\n- 因此 $D_n = \\{P_{n1}, P_{n2}, P_{n3}\\}$ 且 $d_n = |D_n| = 3$。\n\n最后，计算所要求的标量值：\n$$\n\\Phi = d_b^{2} - 2 d_n = (2)^{2} - 2 \\cdot (3) = 4 - 6 = -2.\n$$\n不需要进行四舍五入，结果是一个实数。",
            "answer": "$$\\boxed{-2}$$"
        },
        {
            "introduction": "我们的最后一个练习旨在弥合你所编写的代码与编译器实际分析的控制流图之间的差距。通过研究为短路逻辑运算符生成的CFG，你将看到在编译器生成的结构中控制依赖是如何产生的。理解这一点是掌握如何在真实世界的代码上应用优化的关键。",
            "id": "3632598",
            "problem": "考虑一个将逻辑合取和析取的短路求值降低为显式基于分支的基本块的编译器。以下函数体包含两个复合条件，它们被编译为短路形式。生成的控制流图 (CFG) 由基本块集合 $\\{b_0, b_1, b_2, b_3, b_5, b_6, b_7, b_8, b_9, b_{11}, b_{12}, b_{13}, b_{14}\\}$ 给出，其有向边如下：\n- $b_0 \\rightarrow b_1$。\n- $b_1$ 是一个谓词块，测试第一个条件的左操作数；它有 $2$ 个后继：$b_1 \\xrightarrow{\\text{true}} b_2$ 和 $b_1 \\xrightarrow{\\text{false}} b_5$。\n- $b_2$ 是一个谓词块，测试第一个条件的内部析取的第一个操作数；它有 $2$ 个后继：$b_2 \\xrightarrow{\\text{true}} b_6$ 和 $b_2 \\xrightarrow{\\text{false}} b_3$。\n- $b_3$ 是一个谓词块，测试第一个条件的内部析取的第二个操作数；它有 $2$ 个后继：$b_3 \\xrightarrow{\\text{true}} b_6$ 和 $b_3 \\xrightarrow{\\text{false}} b_5$。\n- $b_5 \\rightarrow b_7$ 且 $b_6 \\rightarrow b_7$。\n- $b_7 \\rightarrow b_8$。\n- $b_8$ 是一个谓词块，测试第二个条件的内部析取的第一个操作数；它有 $2$ 个后继：$b_8 \\xrightarrow{\\text{true}} b_{11}$ 和 $b_8 \\xrightarrow{\\text{false}} b_9$。\n- $b_9$ 是一个谓词块，测试第二个条件的内部析取的第二个操作数；它有 $2$ 个后继：$b_9 \\xrightarrow{\\text{true}} b_{11}$ 和 $b_9 \\xrightarrow{\\text{false}} b_{12}$。\n- $b_{11}$ 是一个谓词块，测试第二个条件的合取的右操作数；它有 $2$ 个后继：$b_{11} \\xrightarrow{\\text{true}} b_{13}$ 和 $b_{11} \\xrightarrow{\\text{false}} b_{12}$。\n- $b_{13} \\rightarrow b_{12}$ 且 $b_{12} \\rightarrow b_{14}$，其中 $b_{14}$ 是唯一出口。\n\n基于后支配节点（postdominators）来处理经典意义上的控制依赖。设 $S$ 是所有仅为实现复合条件的短路求值而引入的谓词块的集合，即 $S = \\{b_1, b_2, b_3, b_8, b_9, b_{11}\\}$。设 $T$ 为不同的控制依赖边的总数，这些边的源点在 $S$ 中，目标是 CFG 中的任意基本块。\n\n计算 $T$ 的值。最终答案必须是一个无单位的实数。不需要四舍五入。",
            "solution": "用户要求我计算在给定的控制流图（CFG）中，源于特定谓词块集合 $S$ 的控制依赖边的总数 $T$。\n\n解决方案分为三个主要步骤：\n1.  首先，我们为给定的 CFG 构建后支配节点树。\n2.  其次，利用后支配节点树，我们确定集合 $S$ 中每个谓词块的控制依赖关系。\n3.  最后，我们对找到的不同控制依赖边的数量进行求和。\n\n如果从 CFG 中的节点 $V$ 到唯一出口节点的所有路径都包含节点 $U$，则称节点 $U$ 后支配节点 $V$。出口节点是 $b_{14}$。一个节点 $V$（$V$ 不是出口节点）的直接后支配节点，记作 $ipdom(V)$，是在任何从 $V$ 到出口的路径上最接近 $V$ 的 $V$ 的后支配节点。所有对 $(ipdom(V), V)$ 的集合定义了后支配节点树，其中 $ipdom(V)$ 是 $V$ 的父节点。\n\n如果存在一条从 $X$ 到 $Y$ 的路径，该路径以边 $X \\rightarrow Z$ 开始，使得 $Y$ 后支配 $Z$，并且 $Y$ 不严格后支配 $X$，则称节点 $Y$ 控制依赖于节点 $X$。一种更具操作性的方法是使用后支配节点树：对于具有多个后继的谓词节点 $X$，当且仅当 $Y$ 是后支配节点树中从 $X$ 的一个后继到 $X$ 的直接后支配节点 $ipdom(X)$（不包括 $ipdom(X)$）的路径上的一个节点时，节点 $Y$ 控制依赖于 $X$。\n\n**步骤 1：构建后支配节点树**\n\n首先，我们必须确定 CFG 中每个节点 $n$ 的后支配节点集 $PDOM(n)$。我们从出口节点 $b_{14}$ 向后推导。对于一个节点 $n$，其后支配节点集为 $PDOM(n) = \\{n\\} \\cup (\\bigcap_{s \\in successors(n)} PDOM(s))$。\n\n- $PDOM(b_{14}) = \\{b_{14}\\}$\n- $PDOM(b_{12}) = \\{b_{12}\\} \\cup PDOM(b_{14}) = \\{b_{12}, b_{14}\\}$\n- $PDOM(b_{13}) = \\{b_{13}\\} \\cup PDOM(b_{12}) = \\{b_{13}, b_{12}, b_{14}\\}$\n- $PDOM(b_{11}) = \\{b_{11}\\} \\cup (PDOM(b_{13}) \\cap PDOM(b_{12})) = \\{b_{11}\\} \\cup \\{b_{12}, b_{14}\\} = \\{b_{11}, b_{12}, b_{14}\\}$\n- $PDOM(b_9) = \\{b_9\\} \\cup (PDOM(b_{11}) \\cap PDOM(b_{12})) = \\{b_9\\} \\cup \\{b_{12}, b_{14}\\} = \\{b_9, b_{12}, b_{14}\\}$\n- $PDOM(b_8) = \\{b_8\\} \\cup (PDOM(b_{11}) \\cap PDOM(b_9)) = \\{b_8\\} \\cup \\{b_{12}, b_{14}\\} = \\{b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_7) = \\{b_7\\} \\cup PDOM(b_8) = \\{b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_6) = \\{b_6\\} \\cup PDOM(b_7) = \\{b_6, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_5) = \\{b_5\\} \\cup PDOM(b_7) = \\{b_5, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_3) = \\{b_3\\} \\cup (PDOM(b_6) \\cap PDOM(b_5)) = \\{b_3\\} \\cup PDOM(b_7) = \\{b_3, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_2) = \\{b_2\\} \\cup (PDOM(b_6) \\cap PDOM(b_3)) = \\{b_2\\} \\cup PDOM(b_7) = \\{b_2, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_1) = \\{b_1\\} \\cup (PDOM(b_2) \\cap PDOM(b_5)) = \\{b_1\\} \\cup PDOM(b_7) = \\{b_1, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_0) = \\{b_0\\} \\cup PDOM(b_1) = \\{b_0, b_1, b_7, b_8, b_{12}, b_{14}\\}$\n\n从后支配节点集中，我们找到每个节点的直接后支配节点：\n- $ipdom(b_{12}) = b_{14}$\n- $ipdom(b_{13}) = b_{12}$\n- $ipdom(b_{11}) = b_{12}$\n- $ipdom(b_9) = b_{12}$\n- $ipdom(b_8) = b_{12}$\n- $ipdom(b_7) = b_8$\n- $ipdom(b_6) = b_7$\n- $ipdom(b_5) = b_7$\n- $ipdom(b_3) = b_7$\n- $ipdom(b_2) = b_7$\n- $ipdom(b_1) = b_7$\n- $ipdom(b_0) = b_1$\n\n这就定义了后支配节点树，其中出口 $b_{14}$ 是根节点，节点 $U$ 的子节点是所有满足 $ipdom(V)=U$ 的节点 $V$。树的结构是：$b_{14}$ 是 $b_{12}$ 的父节点；$b_{12}$ 是 $b_8, b_9, b_{11}, b_{13}$ 的父节点；$b_8$ 是 $b_7$ 的父节点；$b_7$ 是 $b_1, b_2, b_3, b_5, b_6$ 的父节点；$b_1$ 是 $b_0$ 的父节点。\n\n**步骤 2：计算控制依赖**\n\n我们现在分析 $S = \\{b_1, b_2, b_3, b_8, b_9, b_{11}\\}$ 中的每个谓词块。\n\n1.  **源点: $b_1$**\n    - 后继: $b_2, b_5$。\n    - 汇合点: $ipdom(b_1) = b_7$。\n    - 在后支配节点树中从 $b_2$ 到 $b_7$ 的路径: $b_2 \\rightarrow b_7$。路径上不包括 $b_7$ 的节点: $\\{b_2\\}$。\n    - 在后支配节点树中从 $b_5$ 到 $b_7$ 的路径: $b_5 \\rightarrow b_7$。路径上不包括 $b_7$ 的节点: $\\{b_5\\}$。\n    - 控制依赖于 $b_1$ 的节点: $\\{b_2, b_5\\}$。依赖数量: $2$。\n\n2.  **源点: $b_2$**\n    - 后继: $b_3, b_6$。\n    - 汇合点: $ipdom(b_2) = b_7$。\n    - 从 $b_3$ 到 $b_7$ 的路径: $b_3 \\rightarrow b_7$。节点: $\\{b_3\\}$。\n    - 从 $b_6$ 到 $b_7$ 的路径: $b_6 \\rightarrow b_7$。节点: $\\{b_6\\}$。\n    - 控制依赖于 $b_2$ 的节点: $\\{b_3, b_6\\}$。依赖数量: $2$。\n\n3.  **源点: $b_3$**\n    - 后继: $b_5, b_6$。\n    - 汇合点: $ipdom(b_3) = b_7$。\n    - 从 $b_5$ 到 $b_7$ 的路径: $b_5 \\rightarrow b_7$。节点: $\\{b_5\\}$。\n    - 从 $b_6$ 到 $b_7$ 的路径: $b_6 \\rightarrow b_7$。节点: $\\{b_6\\}$。\n    - 控制依赖于 $b_3$ 的节点: $\\{b_5, b_6\\}$。依赖数量: $2$。\n\n4.  **源点: $b_8$**\n    - 后继: $b_9, b_{11}$。\n    - 汇合点: $ipdom(b_8) = b_{12}$。\n    - 从 $b_9$ 到 $b_{12}$ 的路径: $b_9 \\rightarrow b_{12}$。节点: $\\{b_9\\}$。\n    - 从 $b_{11}$ 到 $b_{12}$ 的路径: $b_{11} \\rightarrow b_{12}$。节点: $\\{b_{11}\\}$。\n    - 控制依赖于 $b_8$ 的节点: $\\{b_9, b_{11}\\}$。依赖数量: $2$。\n\n5.  **源点: $b_9$**\n    - 后继: $b_{11}, b_{12}$。\n    - 汇合点: $ipdom(b_9) = b_{12}$。\n    - 从 $b_{11}$ 到 $b_{12}$ 的路径: $b_{11} \\rightarrow b_{12}$。节点: $\\{b_{11}\\}$。\n    - 从 $b_{12}$ 到 $b_{12}$ 的路径：路径为空（它在汇合点处开始和结束）。\n    - 控制依赖于 $b_9$ 的节点: $\\{b_{11}\\}$。依赖数量: $1$。\n\n6.  **源点: $b_{11}$**\n    - 后继: $b_{13}, b_{12}$。\n    - 汇合点: $ipdom(b_{11}) = b_{12}$。\n    - 从 $b_{13}$ 到 $b_{12}$ 的路径: $b_{13} \\rightarrow b_{12}$。节点: $\\{b_{13}\\}$。\n    - 从 $b_{12}$ 到 $b_{12}$ 的路径：路径为空。\n    - 控制依赖于 $b_{11}$ 的节点: $\\{b_{13}\\}$。依赖数量: $1$。\n\n**步骤 3：计算总依赖数 $T$**\n\n不同的控制依赖边的总数 $T$ 是 $S$ 中每个源块的计数之和。所有这些边的集合是 $\\{ (b_1, b_2), (b_1, b_5), (b_2, b_3), (b_2, b_6), (b_3, b_5), (b_3, b_6), (b_8, b_9), (b_8, b_{11}), (b_9, b_{11}), (b_{11}, b_{13}) \\}$。所有这些对都是不同的。\n$$T = 2 + 2 + 2 + 2 + 1 + 1 = 10$$\n不同的控制依赖边的总数是 $10$。",
            "answer": "$$\\boxed{10}$$"
        }
    ]
}