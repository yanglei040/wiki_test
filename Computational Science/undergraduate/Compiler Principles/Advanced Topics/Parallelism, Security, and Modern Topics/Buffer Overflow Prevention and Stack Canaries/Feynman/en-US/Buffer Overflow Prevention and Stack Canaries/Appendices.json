{
    "hands_on_practices": [
        {
            "introduction": "A compiler has choices when instrumenting code for security, and these choices carry different performance trade-offs. This exercise  challenges you to model and compare the overhead of two common strategies for placing stack canary checks: placing a check at every function exit or consolidating checks into a single epilogue. By analyzing their static instrumentation complexity and dynamic runtime cost, you will build a foundational understanding of the performance implications of security features.",
            "id": "3625563",
            "problem": "A compiler inserts stack canary instrumentation to mitigate buffer overflows. Consider a program with a set of $m$ functions $\\{f_{1},\\dots,f_{m}\\}$. For function $f_{i}$, let $n_{i}$ be the number of return statements (that is, exit points in its Control Flow Graph (CFG)). The compiler can choose between two code-generation strategies for canary checks:\n- Strategy $\\mathcal{P}$ (per-exit): Insert a canary check directly at each return statement.\n- Strategy $\\mathcal{S}$ (single-epilogue): Restructure the function to a single epilogue by rewriting each return as an unconditional jump to a unique epilogue block that performs the canary check once, then returns.\n\nAssume the following realistic cost model, where all costs are positive constants independent of $i$ and the input:\n- Writing the canary in the function prologue costs $c_{\\text{pro}}$ cycles per dynamic call.\n- Performing a canary check costs $c_{\\text{chk}}$ cycles per dynamic call site where the check is executed.\n- Each inserted unconditional jump to the epilogue in Strategy $\\mathcal{S}$ costs $c_{\\text{jmp}}$ cycles on the unique executed path per dynamic call.\n- For Strategy $\\mathcal{P}$, assume no additional jump is introduced beyond the return itself; the canary check is placed in-line at each return.\n\nLet the dynamic call count of $f_{i}$ during a particular execution be $k_{i}$, and define the total dynamic call count $K \\coloneqq \\sum_{i=1}^{m} k_{i}$. Assume that for every call, exactly $1$ return site is executed (that is, precisely one exit path is taken), and there are no non-local exits such as $longjmp$. Ignore all cache and pipeline side effects; model cost additively as the sum of per-call costs across calls.\n\nTasks:\n- Using only the definitions above and standard asymptotic notation, justify the per-function static instrumentation complexity class for Strategy $\\mathcal{P}$ and Strategy $\\mathcal{S}$ in terms of $n_{i}$, and explain why these differ.\n- Then, derive a tight, closed-form expression for the worst-case total added runtime cost (in cycles) over the entire program execution when the more expensive of the two strategies is used, expressed as a function of $K$, $c_{\\text{pro}}$, $c_{\\text{chk}}$, and $c_{\\text{jmp}}$. Provide this final worst-case total cost as a single simplified analytic expression. No rounding is required. No units should be included in the final expression.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of compiler design and computer security, specifically regarding stack-based buffer overflow mitigation. The problem is well-posed, providing a clear and consistent set of definitions, assumptions, and cost models. It is objective and free of ambiguity, allowing for a rigorous, formal solution.\n\nWe will address the two tasks in order: first, the static instrumentation complexity, and second, the worst-case total added runtime cost.\n\n### Part 1: Static Instrumentation Complexity\n\nStatic instrumentation complexity refers to the computational complexity of the compiler's task of modifying the code of a single function, $f_{i}$, at compile-time. This complexity is analyzed as a function of the number of return statements, $n_{i}$.\n\nFor Strategy $\\mathcal{P}$ (per-exit), the compiler must perform the following actions for function $f_{i}$:\n1.  Identify all $n_{i}$ return statements (exit points) in the function's Control Flow Graph (CFG).\n2.  At each of these $n_{i}$ locations, insert the sequence of instructions corresponding to the canary check.\n\nThe work performed is directly proportional to the number of sites that must be modified. Since $n_{i}$ distinct sites require code insertion, the static instrumentation complexity for Strategy $\\mathcal{P}$ is in the complexity class $\\Theta(n_{i})$.\n\nFor Strategy $\\mathcal{S}$ (single-epilogue), the compiler must perform these actions for function $f_{i}$:\n1.  Create a single new basic block, which will serve as the common epilogue. This block contains the canary check instructions followed by a single return instruction. This step's complexity is constant with respect to $n_{i}$, i.e., $\\Theta(1)$.\n2.  Identify all $n_{i}$ original return statements.\n3.  At each of these $n_{i}$ locations, replace the return instruction with an unconditional jump instruction that targets the newly created common epilogue block.\n\nThe dominant work is iterating through and modifying the $n_{i}$ original return sites. Therefore, the static instrumentation complexity for Strategy $\\mathcal{S}$ is also in the complexity class $\\Theta(n_{i})$.\n\nThe problem asks why these differ. While both strategies belong to the same asymptotic complexity class, $\\Theta(n_{i})$, the nature of the instrumentation and its impact on the final machine code differ significantly.\n-   **Operation Type**: Strategy $\\mathcal{P}$ performs *code insertion* at $n_{i}$ locations. Strategy $\\mathcal{S}$ performs *code replacement* (or *patching*) at $n_{i}$ locations and creates one new code block.\n-   **Code Size (Code Bloat)**: For Strategy $\\mathcal{P}$, the total size of the added code is $n_{i}$ times the size of the canary check code sequence. For Strategy $\\mathcal{S}$, the added code consists of one instance of the check code plus $n_{i}$ jump instructions. If the check code sequence is significantly larger than a jump instruction, Strategy $\\mathcal{S}$ results in substantially smaller code size, especially for large $n_{i}$.\n-   **CFG Modification**: Strategy $\\mathcal{P}$ only modifies the content of existing basic blocks. Strategy $\\mathcal{S}$ alters the structure of the CFG itself by creating a new node (the epilogue block) and redirecting $n_{i}$ terminal edges to this new node.\n\nIn summary, although their compile-time algorithmic complexity scales identically with $n_{i}$, the strategies differ in their implementation details, impact on final code size, and modifications to the control flow graph.\n\n### Part 2: Worst-Case Total Added Runtime Cost\n\nThe added runtime cost is the dynamic overhead introduced by the canary instrumentation for each function call. We first determine the cost per call for each strategy. This cost is independent of the function index $i$ and the number of returns $n_{i}$, as the problem states that exactly one return path is executed per call.\n\nLet $C_{\\mathcal{P}}$ be the added cost per call for Strategy $\\mathcal{P}$.\n-   A canary is written in the function prologue, costing $c_{\\text{pro}}$.\n-   On the single executed exit path, one in-line canary check is performed, costing $c_{\\text{chk}}$.\n-   No additional jumps are introduced.\nSo, the cost per call is $C_{\\mathcal{P}} = c_{\\text{pro}} + c_{\\text{chk}}$.\n\nLet $C_{\\mathcal{S}}$ be the added cost per call for Strategy $\\mathcal{S}$.\n-   A canary is written in the function prologue, costing $c_{\\text{pro}}$.\n-   The executed exit path is rewritten as an unconditional jump to the epilogue. This jump costs $c_{\\text{jmp}}$.\n-   The epilogue performs a single canary check, costing $c_{\\text{chk}}$.\nSo, the cost per call is $C_{\\mathcal{S}} = c_{\\text{pro}} + c_{\\text{jmp}} + c_{\\text{chk}}$.\n\nThe problem asks for the total cost when the \"more expensive\" of the two strategies is used. We must compare $C_{\\mathcal{P}}$ and $C_{\\mathcal{S}}$.\n$$C_{\\mathcal{S}} - C_{\\mathcal{P}} = (c_{\\text{pro}} + c_{\\text{jmp}} + c_{\\text{chk}}) - (c_{\\text{pro}} + c_{\\text{chk}}) = c_{\\text{jmp}}$$\nThe problem states that all costs are positive constants, so $c_{\\text{jmp}} > 0$. This implies that $C_{\\mathcal{S}} > C_{\\mathcal{P}}$. Therefore, Strategy $\\mathcal{S}$ is uniformly the more expensive strategy in terms of dynamic runtime cost.\n\nThe worst-case added cost for any single function call is the maximum of the two costs:\n$$C_{\\text{worst-per-call}} = \\max(C_{\\mathcal{P}}, C_{\\mathcal{S}}) = C_{\\mathcal{S}} = c_{\\text{pro}} + c_{\\text{chk}} + c_{\\text{jmp}}$$\nThe total added runtime cost over the entire program execution is the sum of the costs for each dynamic call. Since the worst-case cost per call is constant, we multiply this cost by the total number of dynamic calls, $K$.\n$$C_{\\text{total-worst}} = K \\times C_{\\text{worst-per-call}}$$\nSubstituting the expression for $C_{\\text{worst-per-call}}$, we get:\n$$C_{\\text{total-worst}} = K (c_{\\text{pro}} + c_{\\text{chk}} + c_{\\text{jmp}})$$\nThis is the tight, closed-form expression for the worst-case total added runtime cost.",
            "answer": "$$\n\\boxed{K(c_{\\text{pro}} + c_{\\text{chk}} + c_{\\text{jmp}})}\n$$"
        },
        {
            "introduction": "Building on the concept of performance overhead, this next practice moves into a more realistic engineering scenario. Real-world systems, especially in embedded computing, operate under tight constraints where every byte of memory and every CPU cycle counts. This problem  requires you to act as a systems designer, choosing a stack canary size that balances the need for strong security against hard budgets for memory usage and execution time.",
            "id": "3625579",
            "problem": "An embedded control unit uses compiler-inserted stack canaries to mitigate stack-based buffer overflows. A stack canary of size $k$ bits is placed in each protected function’s stack frame and checked on function return. Assume the following foundational facts hold: when a canary value is drawn uniformly at random from all $k$-bit strings and kept secret during an exploit attempt, the probability that an attacker’s overflow silently passes the check in a single attempt is $2^{-k}$; each active protected stack frame holds exactly one canary; copying and comparing the canary incurs a cost that is linear in the number of bytes processed.\n\nThe device is single-threaded and runs a periodic control loop. The Central Processing Unit (CPU) frequency is $f = 80 \\times 10^{6}$ cycles per second, and the loop period is $T = 2 \\times 10^{-3}$ seconds. In the worst case during one period, there are $W = 40$ protected function activations (each activation creates one protected stack frame and later destroys it). The compiler’s code sequence for placing and checking canaries has a fixed per-activation overhead of $c_{0} = 10$ cycles plus an additional per-activation overhead proportional to canary size of $c_{1} = 6$ cycles per byte, accounting for both prologue and epilogue combined. The designer imposes a hard budget that canary handling must consume no more than a fraction $r = 0.015$ of the CPU cycles available per period.\n\nThe Static Random Access Memory (SRAM) budget allocated exclusively for storing canaries in simultaneously live frames is $B = 256$ bytes. At most $D_{\\max} = 40$ protected frames can be live at once (worst-case call depth). Each canary is stored as a whole number of bytes, so $k$ must be a multiple of $8$ and each canary occupies $\\lceil k/8 \\rceil$ bytes.\n\nThe security requirement is that the probability of an undetected stack-smashing attempt in a single attempt must be at most $p_{\\mathrm{req}} = 10^{-9}$. Under these constraints and assumptions, choose $k$ (in bits) to minimize overhead while meeting the security requirement and not violating either the timing or SRAM constraints. Give the unique smallest feasible $k$ consistent with all constraints. Express your final answer as an integer number of bits.",
            "solution": "The objective is to determine the unique smallest feasible integer value for the stack canary size, denoted by $k$ in bits, that satisfies all given constraints. These constraints pertain to security, timing (CPU overhead), and memory (SRAM usage). The problem also specifies that $k$ must be a multiple of $8$, and the goal is to minimize overhead. The total overhead is an increasing function of $k$, so minimizing overhead is equivalent to finding the minimum feasible value of $k$.\n\nWe will analyze each constraint sequentially to derive a valid range for $k$.\n\n1.  **Security Constraint:**\n    The probability of an attacker's single-attempt overflow going undetected is given by $2^{-k}$. This probability must be no greater than the required maximum probability, $p_{\\mathrm{req}} = 10^{-9}$. This establishes the inequality:\n    $$2^{-k} \\le 10^{-9}$$\n    To solve for $k$, we apply the base-$2$ logarithm to both sides.\n    $$\\log_{2}(2^{-k}) \\le \\log_{2}(10^{-9})$$\n    Using the property of logarithms $\\log_b(a^c) = c\\log_b(a)$, this simplifies to:\n    $$-k \\le -9 \\log_{2}(10)$$\n    Multiplying by $-1$ reverses the inequality sign:\n    $$k \\ge 9 \\log_{2}(10)$$\n    We can calculate the value of $\\log_{2}(10)$ using the change of base formula: $\\log_{2}(10) = \\frac{\\ln(10)}{\\ln(2)} \\approx \\frac{2.302585}{0.693147} \\approx 3.321928$.\n    $$k \\ge 9 \\times 3.321928 \\approx 29.89735$$\n    Since $k$ must be an integer, the minimum value of $k$ that satisfies the security requirement is $30$.\n    $$k \\ge 30$$\n\n2.  **Timing Constraint:**\n    The total number of CPU cycles available within one control loop period, $T = 2 \\times 10^{-3}$ seconds, is the product of the CPU frequency, $f = 80 \\times 10^{6}$ cycles/second, and the period duration.\n    $$C_{\\text{total}} = f \\times T = (80 \\times 10^{6}) \\times (2 \\times 10^{-3}) = 160000 \\text{ cycles}$$\n    The budget for canary handling is a fraction $r = 0.015$ of this total.\n    $$C_{\\text{budget}} = r \\times C_{\\text{total}} = 0.015 \\times 160000 = 2400 \\text{ cycles}$$\n    The cost of canary operations per activation consists of a fixed overhead $c_{0} = 10$ cycles and a variable part proportional to the canary size in bytes. Since $k$ is a multiple of $8$, the size in bytes is $k/8$. The variable overhead is $c_{1} = 6$ cycles/byte. The cost per activation is:\n    $$C_{\\text{activation}} = c_{0} + c_{1} \\times \\frac{k}{8} = 10 + 6 \\times \\frac{k}{8} = 10 + \\frac{3}{4}k$$\n    In the worst case, there are $W = 40$ protected function activations per period. The total overhead per period must not exceed the budget.\n    $$W \\times C_{\\text{activation}} \\le C_{\\text{budget}}$$\n    $$40 \\times \\left(10 + \\frac{3}{4}k\\right) \\le 2400$$\n    Dividing by $40$:\n    $$10 + \\frac{3}{4}k \\le 60$$\n    $$\\frac{3}{4}k \\le 50$$\n    $$k \\le \\frac{200}{3} \\approx 66.667$$\n    As $k$ must be an integer, the timing constraint implies $k \\le 66$.\n\n3.  **SRAM Constraint:**\n    The SRAM budget for canaries is $B = 256$ bytes. This memory must accommodate the canaries for the worst-case number of simultaneously live frames, $D_{\\max} = 40$. The memory usage per canary is $k/8$ bytes.\n    The total SRAM usage is $S_{\\text{used}} = D_{\\max} \\times \\frac{k}{8}$. This must not exceed the budget $B$.\n    $$D_{\\max} \\times \\frac{k}{8} \\le B$$\n    $$40 \\times \\frac{k}{8} \\le 256$$\n    $$5k \\le 256$$\n    $$k \\le \\frac{256}{5} = 51.2$$\n    Since $k$ must be an integer, this implies $k \\le 51$. This upper bound is stricter than that from the timing constraint.\n\n4.  **Synthesizing Constraints and Minimization:**\n    We must find an integer $k$ that satisfies all derived conditions simultaneously:\n    - From security: $k \\ge 30$.\n    - From SRAM: $k \\le 51$.\n    - From the problem statement: $k$ must be a multiple of $8$.\n\n    Combining the inequalities, the feasible range for $k$ is $30 \\le k \\le 51$. We now identify the multiples of $8$ within this range:\n    The multiples of $8$ are $8, 16, 24, 32, 40, 48, 56, \\dots$.\n    The multiples that lie in the interval $[30, 51]$ are $32$, $40$, and $48$.\n    The set of all feasible values for $k$ is $\\{32, 40, 48\\}$.\n\n    The problem asks to choose $k$ to minimize overhead. The total overhead is $C_{\\text{canary}} = 40 \\times (10 + \\frac{3}{4}k)$, which is a monotonically increasing function of $k$. Therefore, to minimize overhead, we must select the smallest value from the set of feasible solutions.\n    The smallest value in the set $\\{32, 40, 48\\}$ is $32$.\n\n    Thus, the unique smallest feasible canary size that meets all requirements is $k=32$ bits.",
            "answer": "$$\\boxed{32}$$"
        },
        {
            "introduction": "Security features are most effective when applied intelligently, not just universally. This final practice explores the powerful synergy between static analysis and runtime security mitigations. In this hypothetical scenario , you will analyze a compiler optimization that selectively removes canaries from a recursive function where they are proven to be unnecessary, quantifying the performance savings and justifying the safety of this decision.",
            "id": "3625643",
            "problem": "A modern compiler for a language with automatic storage duration (stack) uses stack canaries to defend against buffer overflows. In the standard scheme, the compiler inserts a canary value between local buffers and control data in each function’s stack frame. On function entry, writing the canary incurs a fixed cost in cycles, and on function exit, checking the canary incurs a fixed cost in cycles. Consider a recursive function whose maximum recursion depth is $d$, meaning that at peak recursion there are $d$ active stack frames of this function on the call stack. Assume no tail-call elimination and that the function returns all the way back to the original caller after reaching the base case.\n\nUse only the following foundational facts:\n- Each recursive call allocates a new stack frame, so the number of active stack frames from this function at peak recursion is exactly $d$.\n- For each stack frame on which the compiler instruments a canary, the prologue writes the canary once and the epilogue checks it once; these are constant-time operations per frame.\n- The cumulative canary cost is the sum of these per-frame costs over all instrumented frames across the full call and return path.\n\nSuppose the measured cycle costs are as follows: writing the canary in the prologue costs $c_{w} = 9$ cycles, and checking the canary in the epilogue costs $c_{v} = 21$ cycles. The recursion depth is $d = 19$. A sound range analysis proves that for all frames deeper than a threshold depth $t = 7$ (counting depth from the outermost call as depth $1$ and increasing by $1$ with each recursive call), all local buffer writes are within bounds, under the function’s argument invariants. Under this proof, a compiler optimization proposes to elide canary insertion in those inner frames of depth strictly greater than $t$, but to keep canaries for frames at depths $1$ through $t$.\n\nTasks:\n1. Derive, from first principles and the facts above, an expression for the cumulative canary cycle cost under (i) full instrumentation (a canary on every frame) and (ii) selective instrumentation (canaries only on frames up to depth $t$), in terms of $c_{w}$, $c_{v}$, $d$, and $t$.\n2. Using the provided numerical values, compute the exact number of cycles saved by selective instrumentation compared to full instrumentation. Give your final answer as a single integer.\n3. Briefly justify, based on the stated proof condition, whether eliding canaries on inner frames (depths greater than $t$) preserves safety, articulating the principle that supports your conclusion. Your justification should not alter the numerical result requested in Task 2.\n\nNo approximation is required; provide an exact integer for the cycles saved. Do not include any units in your final answer box.",
            "solution": "The problem requires an analysis of the computational cost savings from a compiler optimization that selectively elides stack canaries in a recursive function. The solution will proceed by first deriving the general expressions for the cost, then computing the specific numerical savings, and finally justifying the safety of the optimization based on the provided information.\n\nLet us define the given parameters:\n- $d$: the maximum recursion depth.\n- $t$: the depth threshold for canary elision. Canaries are used for depths $k$ where $1 \\le k \\le t$.\n- $c_w$: the cycle cost for writing a canary in a function's prologue.\n- $c_v$: the cycle cost for verifying a canary in a function's epilogue.\n\nThe execution of the recursive function involves a \"call\" phase, where the recursion deepens from depth $1$ to $d$, and a \"return\" phase, where the function returns from depth $d$ back to $1$. The problem states there is no tail-call elimination, so each of the $d$ calls creates a new stack frame, and each frame is later destroyed upon return.\n\n**Task 1: Derivation of Cumulative Cost Expressions**\n\n**(i) Full Instrumentation Cost ($C_{\\text{full}}$)**\nUnder full instrumentation, every stack frame, from depth $k=1$ to $k=d$, is protected by a canary.\nDuring the call phase, a canary is written in the prologue of each of the $d$ function calls. The total cost for writing canaries is the number of frames multiplied by the per-frame write cost:\n$$C_{\\text{write, full}} = d \\cdot c_w$$\nDuring the return phase, the canary is checked in the epilogue as each of the $d$ functions returns. The total cost for verifying canaries is the number of frames multiplied by the per-frame verification cost:\n$$C_{\\text{verify, full}} = d \\cdot c_v$$\nThe cumulative canary cycle cost is the sum of all write and verification costs across the entire execution path.\n$$C_{\\text{full}} = C_{\\text{write, full}} + C_{\\text{verify, full}} = d \\cdot c_w + d \\cdot c_v$$\nFactoring out $d$, we get the expression for the total cost under full instrumentation:\n$$C_{\\text{full}} = d (c_w + c_v)$$\n\n**(ii) Selective Instrumentation Cost ($C_{\\text{selective}}$)**\nUnder selective instrumentation, canaries are only inserted and checked for frames at depths $k$ such that $1 \\le k \\le t$. Frames at depths $k > t$ are not instrumented.\nThe number of instrumented frames is therefore $t$.\nDuring the call phase, canaries are written only for the first $t$ frames (depths $1$ through $t$). The total write cost is:\n$$C_{\\text{write, selective}} = t \\cdot c_w$$\nSimilarly, during the return phase, canaries are checked only for these same $t$ frames. The total verification cost is:\n$$C_{\\text{verify, selective}} = t \\cdot c_v$$\nThe cumulative canary cycle cost for selective instrumentation is the sum of these costs:\n$$C_{\\text{selective}} = C_{\\text{write, selective}} + C_{\\text{verify, selective}} = t \\cdot c_w + t \\cdot c_v$$\nFactoring out $t$, we get the expression for the total cost under selective instrumentation:\n$$C_{\\text{selective}} = t (c_w + c_v)$$\n\n**Task 2: Computation of Cycles Saved**\n\nThe number of cycles saved, which we denote as $S$, is the difference between the cost of full instrumentation and the cost of selective instrumentation.\n$$S = C_{\\text{full}} - C_{\\text{selective}}$$\nSubstituting the expressions derived in Task 1:\n$$S = d(c_w + c_v) - t(c_w + c_v)$$\nFactoring out the term $(c_w + c_v)$:\n$$S = (d - t)(c_w + c_v)$$\nThis expression represents the savings from not performing a write and a check for each of the $(d-t)$ frames at depths greater than $t$.\n\nNow, we substitute the given numerical values:\n- $d = 19$\n- $t = 7$\n- $c_w = 9$ cycles\n- $c_v = 21$ cycles\n\nThe calculation is as follows:\n$$S = (19 - 7)(9 + 21)$$\n$$S = (12)(30)$$\n$$S = 360$$\nThus, the exact number of cycles saved by the optimization is $360$.\n\n**Task 3: Justification of Safety**\n\nThe fundamental principle supporting the safety of this optimization is that a security mitigation is only necessary if the threat it is designed to prevent can actually occur.\nThe problem states that a \"sound range analysis proves that for all frames deeper than a threshold depth $t=7$... all local buffer writes are within bounds\".\nStack canaries are a defense mechanism specifically designed to detect stack-based buffer overflows, which are a consequence of out-of-bounds memory writes. A canary is placed on the stack between local buffers and control data (like the return address). If a buffer write overflows its intended boundary, it will overwrite the canary. The function's epilogue checks if the canary value has been altered, and if so, it can terminate the program to prevent the execution of potentially hijacked control flow.\nThe term \"sound range analysis\" implies a formal proof that is guaranteed to be correct. This proof establishes that for stack frames at depths greater than $t$, no buffer write can ever exceed its allocated bounds. If no out-of-bounds writes can occur, then buffer overflows are impossible in these specific frames.\nTherefore, a canary in these frames is redundant. It protects against an event that has been proven not to happen. Eliding the canary for frames at depths greater than $t$ does not introduce a vulnerability because the underlying condition that the canary detects (a buffer overflow) has been statically proven to be absent. The safety of the program is preserved, as it now relies on the correctness of the formal proof from the sound range analysis rather than on runtime detection by a canary for those specific frames.",
            "answer": "$$\\boxed{360}$$"
        }
    ]
}