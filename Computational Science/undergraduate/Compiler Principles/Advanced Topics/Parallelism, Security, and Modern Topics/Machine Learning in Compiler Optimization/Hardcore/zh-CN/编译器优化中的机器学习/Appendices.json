{
    "hands_on_practices": [
        {
            "introduction": "我们从一个经典的编译器优化问题开始：决定是否要将代码推测性地移出循环。本练习将演示如何利用机器学习模型的预测，基于预期成本效益分析做出原则性决策。你将确定一个盈亏平衡点，在该点上优化开始变得有利可图，从而将概率性预测与具体的编译器行为联系起来。",
            "id": "3656426",
            "problem": "一个即时优化编译器考虑在别名不确定的情况下，采用推测性代码移动，将一个循环不变的内存加载操作提升出循环。为了保证正确性，编译器在循环预头部插入一个运行时守卫，用于检查非别名情况；如果守卫通过，加载操作将被提升并在循环前执行一次；如果守卫失败，执行将回退到原始循环。编译器使用机器学习 (ML) 根据代码特征来预测守卫通过的概率。假设以下以处理器周期表示的、科学上现实的成本模型：\n- 在没有推测的情况下，每次循环迭代执行加载的成本为 $c_{l} = 4$。\n- 运行时守卫的一次性成本为 $c_{g} = 20$。\n- 如果守卫通过，在循环外执行一次的被提升的加载成本为 $c_{o} = 4$。\n- 如果守卫失败，除了执行原始循环外，还有 $c_{f} = 12$ 的回退开销（例如，由于错误预测恢复和控制转移）。\n\n设循环有 $N$ 次迭代。一个逻辑回归模型通过 sigmoid 函数 $\\sigma(u) = \\frac{1}{1+\\exp(-u)}$（其中 $u = \\mathbf{w}^{\\top}\\mathbf{x} + b$）从特征向量 $\\mathbf{x}$、权重向量 $\\mathbf{w}$ 和偏置 $b$ 预测守卫通过的概率 $p$。对于此程序，设\n$\\mathbf{w} = (0.8,\\,-0.5,\\,1.2)$，$\\mathbf{x} = (0.4,\\,0.6,\\,0.3)$，且 $b = -0.1$。\n使用基于期望和逻辑函数基本定义的、有原则的期望成本分析，确定实值阈值 $N^{\\star}$，使得当 $N > N^{\\star}$ 时，带守卫的提升策略的期望总周期严格小于基线（非推测性）策略。根据给定的数字计算 $N^{\\star}$，并将您的最终答案表示为单个实数。将答案四舍五入到四位有效数字。",
            "solution": "问题要求我们求出循环迭代次数的阈值 $N^{\\star}$，当迭代次数超过这个值时，推测性代码提升策略会比基线非推测性策略更高效。这需要进行期望成本分析。\n\n首先，我们定义两种策略的总周期成本。设 $N$ 为循环迭代次数。给出的成本如下：\n-   原始循环中每次迭代的加载成本：$c_{l} = 4$。\n-   运行时守卫的一次性成本：$c_{g} = 20$。\n-   如果守卫通过，被提升的加载的一次性成本：$c_{o} = 4$。\n-   如果守卫失败，一次性回退开销：$c_{f} = 12$。\n\n基线策略在所有 $N$ 次迭代中都在循环内执行加载。其总成本 $C_{base}$ 为：\n$$C_{base} = N c_{l}$$\n\n带守卫的提升策略是推测性的。其成本取决于运行时守卫的结果。设 $p$ 为守卫通过（非别名）的概率。因此，守卫失败的概率是 $1-p$。\n\n-   如果守卫通过（概率为 $p$），总成本包括守卫成本和单次被提升的加载成本。加载操作不在循环内执行。\n    $$C_{pass} = c_{g} + c_{o}$$\n-   如果守卫失败（概率为 $1-p$），总成本包括守卫成本、回退开销以及执行原始循环的成本，其中加载仍在每次迭代中执行。\n    $$C_{fail} = c_{g} + c_{f} + N c_{l}$$\n\n推测性策略的期望总成本 $E[C_{spec}]$ 是这两种结果的加权平均值：\n$$E[C_{spec}] = p \\cdot C_{pass} + (1-p) \\cdot C_{fail}$$\n$$E[C_{spec}] = p(c_{g} + c_{o}) + (1-p)(c_{g} + c_{f} + N c_{l})$$\n\n问题要求找到阈值 $N^{\\star}$，使得当 $N > N^{\\star}$ 时，推测性策略严格更优，即其期望成本小于基线成本：\n$$E[C_{spec}]  C_{base}$$\n$$p(c_{g} + c_{o}) + (1-p)(c_{g} + c_{f} + N c_{l})  N c_{l}$$\n\n我们现在对 $N$ 求解这个不等式。让我们展开左侧：\n$$p c_{g} + p c_{o} + c_{g} + c_{f} + N c_{l} - p c_{g} - p c_{f} - p N c_{l}  N c_{l}$$\n合并同类项，我们得到：\n$$c_{g} + p c_{o} + c_{f} - p c_{f} + (1-p) N c_{l}  N c_{l}$$\n为了分离 $N$，我们将所有包含 $N$ 的项移到一边：\n$$c_{g} + c_{f} + p(c_{o} - c_{f})  N c_{l} - (1-p) N c_{l}$$\n$$c_{g} + c_{f} + p(c_{o} - c_{f})  N c_{l} (1 - (1-p))$$\n$$c_{g} + c_{f} + p(c_{o} - c_{f})  p N c_{l}$$\n由于 $p > 0$ 且 $c_{l} > 0$，我们可以除以 $p c_{l}$ 而不改变不等式的方向：\n$$N > \\frac{c_{g} + c_{f} + p(c_{o} - c_{f})}{p c_{l}}$$\n这给出了阈值 $N^{\\star}$ 的表达式：\n$$N^{\\star} = \\frac{c_{g} + c_{f} + p(c_{o} - c_{f})}{p c_{l}}$$\n\n接下来，我们必须使用给定的逻辑回归模型计算概率 $p$。sigmoid 函数的输入是 $u = \\mathbf{w}^{\\top}\\mathbf{x} + b$。给定的向量为 $\\mathbf{w} = (0.8,\\,-0.5,\\,1.2)$ 和 $\\mathbf{x} = (0.4,\\,0.6,\\,0.3)$。形式上，它们是列向量：\n$$\\mathbf{w} = \\begin{pmatrix} 0.8 \\\\ -0.5 \\\\ 1.2 \\end{pmatrix}, \\quad \\mathbf{x} = \\begin{pmatrix} 0.4 \\\\ 0.6 \\\\ 0.3 \\end{pmatrix}$$\n偏置为 $b = -0.1$。我们计算 $u$：\n$$u = \\mathbf{w}^{\\top}\\mathbf{x} + b = \\begin{pmatrix} 0.8  -0.5  1.2 \\end{pmatrix} \\begin{pmatrix} 0.4 \\\\ 0.6 \\\\ 0.3 \\end{pmatrix} - 0.1$$\n$$u = (0.8)(0.4) + (-0.5)(0.6) + (1.2)(0.3) - 0.1$$\n$$u = 0.32 - 0.30 + 0.36 - 0.1 = 0.02 + 0.36 - 0.1 = 0.28$$\n概率 $p$ 是 sigmoid 函数 $\\sigma(u)$ 的输出：\n$$p = \\sigma(u) = \\frac{1}{1 + \\exp(-u)} = \\frac{1}{1 + \\exp(-0.28)}$$\n\n现在我们将给定的数值代入 $N^{\\star}$ 的表达式中：\n$c_{l} = 4$, $c_{g} = 20$, $c_{o} = 4$, $c_{f} = 12$.\n$$N^{\\star} = \\frac{20 + 12 + p(4 - 12)}{p \\cdot 4} = \\frac{32 - 8p}{4p} = \\frac{8 - 2p}{p} = \\frac{8}{p} - 2$$\n代入 $p$ 的表达式：\n$$N^{\\star} = \\frac{8}{\\frac{1}{1 + \\exp(-0.28)}} - 2 = 8(1 + \\exp(-0.28)) - 2$$\n$$N^{\\star} = 8 + 8\\exp(-0.28) - 2 = 6 + 8\\exp(-0.28)$$\n现在我们计算数值：\n$$\\exp(-0.28) \\approx 0.75578374$$\n$$N^{\\star} \\approx 6 + 8(0.75578374) = 6 + 6.0462699$$\n$$N^{\\star} \\approx 12.0462699$$\n四舍五入到四位有效数字，我们得到：\n$$N^{\\star} \\approx 12.05$$\n\n因此，对于任何大于 $12.05$ 的循环迭代次数 $N$，带守卫的提升策略的期望成本都严格小于基线成本。",
            "answer": "$$\\boxed{12.05}$$"
        },
        {
            "introduction": "做出正确的预测是理想情况，但理解错误预测的后果对于构建稳健的系统至关重要。本实践探讨了“错误预测惩罚”的概念，量化了当机器学习模型做出错误的优化选择时所导致的性能损失。通过分析不同的优化过程，你将了解到风险最高的决策并非总是与最强大的优化相关，而是与那些收益与开销成本极其接近的决策相关。",
            "id": "3656416",
            "problem": "考虑一个使用机器学习 (ML) 来调整优化遍的编译器。结果质量 (QoR) 定义为预期运行时。设基线预期运行时为 $Q_0 = 1.00$ 秒。对于每个遍 $i$，启用它会根据以下模型改变运行时\n$$\nQ_{\\text{enable},i} = Q_0 (1 - s_i) + h_i,\n$$\n其中 $s_i$ 是真实的分数加速比 ($0 \\le s_i  1$)，$h_i$ 是以秒为单位的开销（例如，由于代码大小增加或寄存器压力增大）。ML 策略在预测的净运行时 $Q_0 (1 - \\hat{s}_i) + h_i$ 严格小于基线 $Q_0$ 时启用遍 $i$，这等价于 $\\hat{s}_i > h_i / Q_0$。由于 $Q_0 = 1.00$，决策规则简化为 $\\hat{s}_i > h_i$。\n\n假设 ML 模型对每个遍 $i$ 的预测在 $s_i$ 上具有大小为 $\\Delta = 0.02$ 的绝对误差，即 $\\hat{s}_i = s_i \\pm \\Delta$。对于每个遍，将其在误差大小为 $\\Delta$ 时的错误预测惩罚定义为：与该遍的最优决策相比，因对该遍做出错误决策（当最优选择是禁用时启用，或当最优选择是启用时禁用）而可能导致预期运行时的最大增加量，假设所有其他遍都保持不变。遍 $i$ 的最优决策是在 $Q_{\\text{enable},i}  Q_0$ 时启用，否则禁用。\n\n四个优化遍具有以下真实参数：\n- Loop Unrolling (循环展开): $s_A = 0.06$, $h_A = 0.04$。\n- Instruction Scheduling (指令调度): $s_B = 0.04$, $h_B = 0.01$。\n- Function Inlining (函数内联): $s_C = 0.09$, $h_C = 0.08$。\n- Register Pressure Reduction (寄存器压力减小): $s_D = 0.025$, $h_D = 0.03$。\n\n当模型误差为 $\\Delta = 0.02$ 时，哪个单一遍会因错误预测而产生最大的预期运行时惩罚？\n\n选项：\n- A. Loop Unrolling (循环展开)\n- B. Instruction Scheduling (指令调度)\n- C. Function Inlining (函数内联)\n- D. Register Pressure Reduction (寄存器压力减小)",
            "solution": "用户希望我验证问题，如果问题有效，则求解具有最大错误预测惩罚的优化遍。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n-   基线预期运行时：$Q_0 = 1.00$ 秒。\n-   启用遍 $i$ 的运行时模型：$Q_{\\text{enable},i} = Q_0 (1 - s_i) + h_i$。\n-   $s_i$：真实分数加速比，$0 \\le s_i  1$。\n-   $h_i$：以秒为单位的开销。\n-   ML 策略决策规则：如果 $\\hat{s}_i > h_i$，则启用遍 $i$。\n-   ML 模型预测误差：$\\hat{s}_i = s_i \\pm \\Delta$，绝对误差大小为 $\\Delta = 0.02$。这可以解释为预测值 $\\hat{s}_i$ 位于区间 $[s_i - \\Delta, s_i + \\Delta]$ 内。\n-   最优决策规则：如果 $Q_{\\text{enable},i}  Q_0$（简化为 $s_i > h_i$），则启用遍 $i$。否则，禁用。\n-   错误预测惩罚定义：与最优决策相比，由错误决策导致的预期运行时的最大可能增加量。\n-   遍 A (Loop Unrolling): $s_A = 0.06$, $h_A = 0.04$。\n-   遍 B (Instruction Scheduling): $s_B = 0.04$, $h_B = 0.01$。\n-   遍 C (Function Inlining): $s_C = 0.09$, $h_C = 0.08$。\n-   遍 D (Register Pressure Reduction): $s_D = 0.025$, $h_D = 0.03$。\n\n**第 2 步：使用提取的已知信息进行验证**\n该问题具有科学依据，用一个简化但合理的线性模型来模拟编译器优化的性能权衡。为此目的使用机器学习是计算机科学中的一个有效概念。问题定义明确，提供了所有必要的定义、数据和清晰的问题。所有术语如“错误预测惩罚”都得到了明确定义。数据是一致的，没有违反任何给定的约束。该问题需要仔细应用定义，而不是一个简单或结构不良的问题。\n\n**第 3 步：结论和行动**\n问题有效。我将继续进行求解。\n\n### 求解推导\n\n分析的目的是找出哪个遍具有最大的错误预测惩罚。这个惩罚是指当基于 ML 的决策错误时，与最优决策相比所产生的运行时增加量。\n\n首先，让我们将运行时和决策形式化。禁用遍 $i$ 时的基线运行时为 $Q_{\\text{disable},i} = Q_0 = 1.00$ 秒。启用遍 $i$ 时的运行时为 $Q_{\\text{enable},i} = Q_0(1-s_i) + h_i = 1.00(1-s_i) + h_i = 1 - s_i + h_i$。\n\n最优决策是在启用该遍可以减少运行时的情况下启用它，即 $Q_{\\text{enable},i}  Q_{\\text{disable},i}$。\n$$\n1 - s_i + h_i  1\n$$\n$$\ns_i > h_i\n$$\n因此，最优策略是：如果 $s_i > h_i$ 则启用，如果 $s_i \\le h_i$ 则禁用。\n\n基于 ML 的策略根据预测的加速比 $\\hat{s}_i$ 做出决策。如果 $\\hat{s}_i > h_i$ 则启用该遍。如果 ML 策略的决策与最优决策不同，则发生错误预测。\n\n错误预测惩罚是错误行为的运行时与最优行为的运行时之间的差值。错误决策有两种情况：\n\n1.  **错误地启用：** 最优决策是禁用 ($s_i \\le h_i$)，但 ML 模型启用了它 ($\\hat{s}_i > h_i$)。\n    -   最优决策（禁用）的运行时：$Q_{opt} = Q_0 = 1.00$。\n    -   错误决策（启用）的运行时：$Q_{wrong} = 1 - s_i + h_i$。\n    -   惩罚 = $Q_{wrong} - Q_{opt} = (1 - s_i + h_i) - 1 = h_i - s_i$。由于 $s_i \\le h_i$，该值为非负。\n\n2.  **错误地禁用：** 最优决策是启用 ($s_i > h_i$)，但 ML 模型禁用了它 ($\\hat{s}_i \\le h_i$)。\n    -   最优决策（启用）的运行时：$Q_{opt} = 1 - s_i + h_i$。\n    -   错误决策（禁用）的运行时：$Q_{wrong} = Q_0 = 1.00$。\n    -   惩罚 = $Q_{wrong} - Q_{opt} = 1 - (1 - s_i + h_i) = s_i - h_i$。由于 $s_i > h_i$，该值为正。\n\n在两种情况下，如果发生错误预测，惩罚的大小都是 $|s_i - h_i|$。\n\n只有当 ML 模型的预测 $\\hat{s}_i$ 能够跨越决策边界 $h_i$ 时，才可能发生错误预测。已知模型的预测 $\\hat{s}_i$ 位于区间 $[s_i - \\Delta, s_i + \\Delta]$ 内，其中 $\\Delta = 0.02$。当且仅当这个可能的预测区间包含阈值 $h_i$ 时，才会发生错误预测。\n-   情况 1（错误地启用，$s_i \\le h_i$）：只有当 $s_i + \\Delta > h_i$ 时，才可能出现预测 $\\hat{s}_i > h_i$。\n-   情况 2（错误地禁用，$s_i > h_i$）：只有当 $s_i - \\Delta \\le h_i$ 时，才可能出现预测 $\\hat{s}_i \\le h_i$。\n\n综合这两种情况，当且仅当 $s_i - \\Delta \\le h_i \\le s_i + \\Delta$ 时，才可能发生错误预测，这等价于 $|s_i - h_i| \\le \\Delta$。\n\n如果 $|s_i - h_i| > \\Delta$，则区间 $[s_i - \\Delta, s_i + \\Delta]$ 不包含 $h_i$。所有可能的预测 $\\hat{s}_i$ 都与真实值 $s_i$ 在阈值 $h_i$ 的同一侧。因此，ML 策略将总是做出正确的决策，错误预测惩罚为 $0$。\n\n因此，遍 $i$ 的错误预测惩罚，记为 $P_i$，为：\n$$\nP_i = \\begin{cases} |s_i - h_i|  \\text{如果 } |s_i - h_i| \\le \\Delta \\\\ 0  \\text{如果 } |s_i - h_i| > \\Delta \\end{cases}\n$$\n给定 $\\Delta = 0.02$。我们现在为每个遍计算 $P_i$。\n\n**A. Loop Unrolling (循环展开)**\n-   $s_A = 0.06$, $h_A = 0.04$。\n-   差值：$|s_A - h_A| = |0.06 - 0.04| = 0.02$。\n-   条件：$|s_A - h_A| \\le \\Delta$ 是否成立？是，$0.02 \\le 0.02$。\n-   可能发生错误预测。最优选择是启用 ($s_A > h_A$)。预测值为 $\\hat{s}_A = s_A - \\Delta = 0.04$ 会导致“禁用”决策（因为 $0.04 \\ngtr 0.04$）。\n-   惩罚：$P_A = |s_A - h_A| = 0.02$ 秒。\n\n**B. Instruction Scheduling (指令调度)**\n-   $s_B = 0.04$, $h_B = 0.01$。\n-   差值：$|s_B - h_B| = |0.04 - 0.01| = 0.03$。\n-   条件：$|s_B - h_B| \\le \\Delta$ 是否成立？否，$0.03 > 0.02$。\n-   不可能发生错误预测。预测区间为 $[0.04-0.02, 0.04+0.02] = [0.02, 0.06]$。所有可能的 $\\hat{s}_B$ 都大于 $h_B = 0.01$，因此 ML 模型将总是正确地启用该遍。\n-   惩罚：$P_B = 0$ 秒。\n\n**C. Function Inlining (函数内联)**\n-   $s_C = 0.09$, $h_C = 0.08$。\n-   差值：$|s_C - h_C| = |0.09 - 0.08| = 0.01$。\n-   条件：$|s_C - h_C| \\le \\Delta$ 是否成立？是，$0.01 \\le 0.02$。\n-   可能发生错误预测。最优选择是启用 ($s_C > h_C$)。在 $[0.07, 0.08]$ 范围内的预测将导致错误的“禁用”决策。\n-   惩罚：$P_C = |s_C - h_C| = 0.01$ 秒。\n\n**D. Register Pressure Reduction (寄存器压力减小)**\n-   $s_D = 0.025$, $h_D = 0.03$。\n-   差值：$|s_D - h_D| = |0.025 - 0.03| = |-0.005| = 0.005$。\n-   条件：$|s_D - h_D| \\le \\Delta$ 是否成立？是，$0.005 \\le 0.02$。\n-   可能发生错误预测。最优选择是禁用 ($s_D  h_D$)。在 $(0.03, 0.045]$ 范围内的预测将导致错误的“启用”决策。\n-   惩罚：$P_D = |s_D - h_D| = 0.005$ 秒。\n\n**结论**\n比较惩罚值：\n-   $P_A = 0.02$\n-   $P_B = 0$\n-   $P_C = 0.01$\n-   $P_D = 0.005$\n最大的错误预测惩罚是 $0.02$ 秒，对应于 Loop Unrolling（循环展开）遍。\n\n### 逐项分析\n\n-   **A. Loop Unrolling (循环展开)**：计算出的错误预测惩罚为 $P_A = 0.02$ 秒。这是四个遍中的最大值 ($0.02 > 0$, $0.02 > 0.01$, $0.02 > 0.005$)。因此，该遍会产生最大的错误预测惩罚。**正确**。\n\n-   **B. Instruction Scheduling (指令调度)**：对于此遍，$|s_B - h_B| = 0.03 > \\Delta = 0.02$。鉴于模型的误差大小，不可能发生错误预测。惩罚为 $P_B = 0$。这不是最大的惩罚。**不正确**。\n\n-   **C. Function Inlining (函数内联)**：计算出的错误预测惩罚为 $P_C = 0.01$ 秒。这小于 Loop Unrolling 的惩罚 ($0.01  0.02$)。**不正确**。\n\n-   **D. Register Pressure Reduction (寄存器压力减小)**：计算出的错误预测惩罚为 $P_D = 0.005$ 秒。这小于 Loop Unrolling 和 Function Inlining 的惩罚。**不正确**。\n\n产生最大错误预测惩罚的单一遍是 Loop Unrolling（循环展开）。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "为了实用，基于机器学习的编译器必须运行得很快，这通常需要缓存模型的预测结果。本练习旨在解决设计一个安全高效的缓存系统所面临的工程挑战。你将需要制定一个失效规则，通过结合代码哈希和对预测误差的形式化界定，确保只有在安全的情况下才能重用缓存结果，即使程序代码已被早期的编译器过程修改。",
            "id": "3656494",
            "problem": "您正在为一个编译器构建一个用于机器学习预测的缓存，该编译器使用这些预测来指导基于每个函数的优化。每个函数都由一个中间表示（IR）表示，从中提取一个固定长度的特征向量。早期的 IR 遍（pass）可以在缓存的预测被重用之前改变 IR，因此您的缓存必须使用从 IR 签名派生的代码哈希和一个有原则的失效规则来确保安全性。您的任务是从第一性原理出发，形式化重用条件，并实现一个程序将其应用于一个小型测试套件。\n\n基本基础：\n- 一个特征提取器将一个函数的 IR 映射到一个数值特征向量 $\\mathbf{f} \\in \\mathbb{R}^{d}$，对于相同的 IR 状态，该向量在多次编译中是一致的。\n- 一个确定性的机器学习模型通过函数 $M:\\mathbb{R}^{d} \\to \\mathbb{R}$ 将特征映射到一个标量预测值 $y \\in \\mathbb{R}$。\n- 一个确定性的哈希函数 $H$ 将一个字符串和一个整数元组映射到一个机器字，并用于派生缓存键。哈希碰撞是可能的，但很罕见，在本练习中被忽略。\n- 在一组早期的 IR 遍下，一部分特征维度被指定为“稳定的”。设 $\\mathbf{s} \\in \\{0,1\\}^{d}$ 是一个二进制掩码，如果第 $i$ 个特征被包含在哈希签名中并被视为对稳定性至关重要，则 $s_{i}=1$。\n- 失效规则必须是安全的，这意味着如果缓存被重用，重用的预测与早期遍之后假设的重新计算的预测之间的偏差，必须能够以一种可从模型结构和观察到的 IR 差异推导出的方式进行限定。\n\n本问题中使用的模型和表示：\n- 模型是线性的：$M(\\mathbf{f}) = \\mathbf{w}^{\\top}\\mathbf{f} + b$，其中权重向量为 $\\mathbf{w} \\in \\mathbb{R}^{d}$，偏置为 $b \\in \\mathbb{R}$。\n- 每个函数的缓存键是通过将函数标识符字符串与由 $\\mathbf{s}$ 选择的特征子向量一起进行哈希来构建的。\n- 设 $\\mathbf{f}^{(0)}$ 是早期遍之前的特征，$\\mathbf{f}^{(1)}$ 是早期遍之后的特征。哈希签名在插入时由 $\\mathbf{f}^{(0)}$ 构建，在查找时由 $\\mathbf{f}^{(1)}$ 构建。\n- 失效规则必须仅依赖于：两个哈希签名的相等性，以及归因于非哈希特征维度（即 $s_{i}=0$ 的维度）差异而导致的 $M(\\cdot)$ 潜在变化的界限。该界限应从模型结构和基本不等式推导得出，无需假设任何预言机（oracle）。\n\n设计要求：\n- 推导、论证并实现一个保守的重用条件，该条件使用：\n  - 哈希子向量的哈希签名相等。\n  - 一个容差参数 $\\tau \\in \\mathbb{R}_{\\ge 0}$，它为因非哈希特征的差异而导致模型输出的允许变化设定了上限。该容差作为配置的一部分提供。\n- 如果条件表明可以安全重用，则为该测试用例返回重用标志 $1$；否则返回 $0$。\n\n所有测试用例的配置：\n- 维度 $d = 4$。\n- 权重向量 $\\mathbf{w} = \\langle 0.4, -0.1, 0.2, 0.05 \\rangle$。\n- 偏置 $b = 0.0$。\n- 稳定性掩码 $\\mathbf{s} = \\langle 1, 0, 1, 0 \\rangle$。\n- 容差 $\\tau = 0.15$。\n\n测试套件：\n对于每个测试用例，给定一个函数标识符、一个初始特征向量 $\\mathbf{f}^{(0)} \\in \\mathbb{Z}^{d}$ 和一个遍处理后的特征向量 $\\mathbf{f}^{(1)} \\in \\mathbb{Z}^{d}$。\n\n- 用例 A：标识符 “foo”，$\\mathbf{f}^{(0)} = \\langle 10, 3, 2, 5 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 10, 4, 2, 4 \\rangle$。\n- 用例 B：标识符 “bar”，$\\mathbf{f}^{(0)} = \\langle 0, 0, 0, 0 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 0, 1, 0, 0 \\rangle$。\n- 用例 C：标识符 “baz”，$\\mathbf{f}^{(0)} = \\langle 7, 2, 3, 1 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 8, 2, 3, 1 \\rangle$。\n- 用例 D：标识符 “qux”，$\\mathbf{f}^{(0)} = \\langle 9, 9, 9, 9 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 9, 13, 9, 3 \\rangle$。\n- 用例 E：标识符 “edge”，$\\mathbf{f}^{(0)} = \\langle 1, 1, 1, 1 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 1, 1, 1, 1 \\rangle$。\n\n程序要求：\n- 实现一个完整的程序，该程序：\n  - 编码上述模型和配置。\n  - 根据函数标识符和掩码特征子向量计算缓存签名。\n  - 使用您推导出的安全失效规则为每个测试用例决定是否重用。\n- 最终输出格式：\n  - 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的整数列表（例如，“[1,0,1]”），每个整数对应一个测试用例，顺序为 A、B、C、D、E。其中 $1$ 表示“重用缓存的预测”，$0$ 表示“失效并重新计算”。",
            "solution": "我们使用线性模型和将特征分解为哈希（对稳定性至关重要）和非哈希（容许变化）分量的方法，来形式化缓存和失效问题。\n\n基本定义：\n- 设特征维度为 $d \\in \\mathbb{N}$。此处 $d = 4$。\n- 设线性模型为 $M(\\mathbf{f}) = \\mathbf{w}^{\\top}\\mathbf{f} + b$，其中 $\\mathbf{w} \\in \\mathbb{R}^{d}$ 和 $b \\in \\mathbb{R}$ 是由先前训练设定的固定常数。对于本测试，$\\mathbf{w} = \\langle 0.4, -0.1, 0.2, 0.05 \\rangle$ 且 $b = 0.0$。\n- 设稳定性掩码为 $\\mathbf{s} \\in \\{0,1\\}^{d}$，其值为 $\\mathbf{s} = \\langle 1, 0, 1, 0 \\rangle$。$s_{i}=1$ 的索引 $i$ 被包含在代码哈希签名中。\n- 设函数标识符为字符串 $\\text{id}$。令 $H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}))$ 表示标识符和子向量 $\\text{proj}_{\\mathbf{s}}(\\mathbf{f}) = \\{ f_{i} \\mid s_{i}=1 \\}$ 的一个确定性 64 位哈希值。\n- 对于每个函数，我们观察到一对 $(\\mathbf{f}^{(0)}, \\mathbf{f}^{(1)})$，其中 $\\mathbf{f}^{(0)}$ 在早期 IR 遍之前，$\\mathbf{f}^{(1)}$ 在其之后。\n\n基于原则的安全失效规则推导：\n- 仅当两个条件都满足时，才应重用缓存：\n  1. 哈希的对稳定性至关重要的内容的等价性得到保持。这由 $H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(0)})) = H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(1)}))$ 来体现。这依赖于 $H$ 的确定性以及掩码 $\\mathbf{s}$ 表征了其变化必须强制失效的子空间的假设。\n  2. 由于非哈希特征的差异导致模型输出的变化是可证明地小的。对于一个线性模型，对任意 $\\mathbf{u}, \\mathbf{v} \\in \\mathbb{R}^{d}$，\n     $$\n     \\left|M(\\mathbf{u}) - M(\\mathbf{v})\\right| = \\left|\\mathbf{w}^{\\top}(\\mathbf{u}-\\mathbf{v})\\right|.\n     $$\n     使用掩码 $\\mathbf{s}$ 将差异分解为哈希坐标和非哈希坐标。如果哈希坐标不变（由哈希相等性强制），则只有非哈希坐标有贡献。设 $\\Delta \\mathbf{f} = \\mathbf{f}^{(1)} - \\mathbf{f}^{(0)}$。考虑索引集 $U = \\{ i \\mid s_{i} = 0 \\}$。那么\n     $$\n     \\left|M(\\mathbf{f}^{(1)}) - M(\\mathbf{f}^{(0)})\\right| = \\left|\\sum_{i \\in U} w_{i} \\Delta f_{i}\\right| \\le \\sum_{i \\in U} \\left|w_{i}\\right| \\cdot \\left|\\Delta f_{i}\\right|.\n     $$\n     该不等式源于实数的三角不等式。这仅使用逐坐标的绝对变化和绝对权重，为模型输出偏差提供了一个最坏情况下的界限。如果此界限小于或等于一个容差 $\\tau \\in \\mathbb{R}_{\\ge 0}$（由系统设计者设定），则在指定容差下重用缓存的预测是安全的；否则，使其失效。\n\n因此，保守的重用规则是：\n- 当且仅当同时满足以下两个条件时重用：\n  - $H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(0)})) = H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(1)}))$, 并且\n  - $\\sum_{i: s_{i}=0} \\left|w_{i}\\right| \\cdot \\left|f^{(1)}_{i} - f^{(0)}_{i}\\right| \\le \\tau$。\n\n算法设计：\n- 使用一个固定的 64 位滚动哈希算法计算 $h_{0} = H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(0)}))$ 和 $h_{1} = H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(1)}))$，该算法将函数标识符与掩码后的整数特征混合。确定性确保了相等的输入产生相等的输出。\n- 如果 $h_{0} \\ne h_{1}$，返回重用标志 $0$。\n- 否则，计算非哈希偏差界限 $B = \\sum_{i: s_{i}=0} \\left|w_{i}\\right| \\cdot \\left|f^{(1)}_{i} - f^{(0)}_{i}\\right|$ 并与 $\\tau$ 比较；如果 $B \\le \\tau$，返回重用标志 $1$，否则返回 $0$。\n\n对给定的测试套件进行手动推理，其中 $\\mathbf{w} = \\langle 0.4, -0.1, 0.2, 0.05 \\rangle$，$b = 0.0$，$\\mathbf{s} = \\langle 1, 0, 1, 0 \\rangle$，$\\tau = 0.15$：\n- 用例 A：“foo”，$\\mathbf{f}^{(0)} = \\langle 10, 3, 2, 5 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 10, 4, 2, 4 \\rangle$。哈希坐标（基于 0 的索引：$i=0$ 和 $i=2$）未改变。非哈希差异：$\\left|\\Delta f_{1}\\right| = 1$，$\\left|\\Delta f_{3}\\right| = 1$。界限 $B = \\left|{-0.1}\\right|\\cdot 1 + \\left|0.05\\right|\\cdot 1 = 0.1 + 0.05 = 0.15 \\le 0.15$。重用标志为 $1$。\n- 用例 B：“bar”，$\\mathbf{f}^{(0)} = \\langle 0, 0, 0, 0 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 0, 1, 0, 0 \\rangle$。哈希坐标未改变。非哈希差异：$\\left|\\Delta f_{1}\\right| = 1$，$\\left|\\Delta f_{3}\\right| = 0$。界限 $B = 0.1 \\cdot 1 + 0.05 \\cdot 0 = 0.1 \\le 0.15$。重用标志为 $1$。\n- 用例 C：“baz”，$\\mathbf{f}^{(0)} = \\langle 7, 2, 3, 1 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 8, 2, 3, 1 \\rangle$。哈希坐标 $i=0$ 发生变化，因此 $h_{0} \\ne h_{1}$，失效。重用标志为 $0$。\n- 用例 D：“qux”，$\\mathbf{f}^{(0)} = \\langle 9, 9, 9, 9 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 9, 13, 9, 3 \\rangle$。哈希坐标未改变。非哈希差异：$\\left|\\Delta f_{1}\\right| = 4$，$\\left|\\Delta f_{3}\\right| = 6$。界限 $B = 0.1 \\cdot 4 + 0.05 \\cdot 6 = 0.4 + 0.3 = 0.7 > 0.15$。失效。重用标志为 $0$。\n- 用例 E：“edge”，$\\mathbf{f}^{(0)} = \\langle 1, 1, 1, 1 \\rangle$，$\\mathbf{f}^{(1)} = \\langle 1, 1, 1, 1 \\rangle$。特征完全相同，因此签名相等且界限 $B=0$。重用标志为 $1$。\n\n因此，预期的重用标志序列为 $\\langle 1, 1, 0, 0, 1 \\rangle$。\n\n该实现使用 64 位 FNV 风格的混合算法为标识符和掩码特征确定性地计算哈希签名，通过绝对值评估非哈希坐标上的界限，与 $\\tau$ 进行比较，并按指定格式打印标志。",
            "answer": "$$\\boxed{[1,1,0,0,1]}$$"
        }
    ]
}