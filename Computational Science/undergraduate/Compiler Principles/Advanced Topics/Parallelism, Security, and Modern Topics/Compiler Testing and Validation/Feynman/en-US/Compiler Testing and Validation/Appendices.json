{
    "hands_on_practices": [
        {
            "introduction": "A compiler's most fundamental duty is to correctly interpret the semantics of the source language, including its rules for arithmetic. This practice targets constant folding, a common optimization where the compiler computes the value of constant expressions at compile time. You will build a reference evaluator to validate how a compiler should handle integer operations with mixed widths and signs, forcing you to engage with the critical details of two's complement representation and sign-extension rules that are essential for correct code generation .",
            "id": "3630005",
            "problem": "You are tasked with building a self-contained reference evaluator to validate constant folding and sign extension semantics for integer operations across widths $8$, $16$, $32$, and $64$. This is a compiler testing and validation exercise: your program must compute the canonical result of constant expressions under precisely specified mixed-width rules so that compiler outputs (such as constant-folded code or intermediate representation) can be compared against the reference.\n\nFundamental Base and Definitions:\n- Two's complement representation for a signed integer of width $w$ uses $w$ bits, with range $\\left[-2^{w-1}, 2^{w-1}-1\\right]$, and for an unsigned integer of width $w$, the range is $\\left[0, 2^{w}-1\\right]$.\n- Bit-width masking is defined by the modulus $2^w$: given any integer $x$, its width-$w$ bit pattern is the residue class $x \\bmod 2^w$. Define $M_w = 2^w - 1$ as the all-ones mask of width $w$.\n- Sign extension from width $w$ to width $W$ for a signed operand is defined by replicating the sign bit $b_{w-1}$ into all higher bits up to $W-1$. For an unsigned operand, extension to width $W$ is defined by zero extension. All operands are first reduced to width $w$ via masking before any extension.\n- Mixed-width binary operation semantics:\n  1. Let the first operand have width $w_a$ and signedness $s_a \\in \\{0,1\\}$ (where $1$ means signed, $0$ means unsigned). Let the second operand have width $w_b$ and signedness $s_b \\in \\{0,1\\}$. Define the target width $W = \\max(w_a, w_b)$.\n  2. Extend the first operand to width $W$ using sign extension if $s_a = 1$, otherwise zero extension. Extend the second operand to width $W$ using sign extension if $s_b = 1$, otherwise zero extension.\n  3. Perform the operation in modular arithmetic over $\\mathbb{Z}/2^W\\mathbb{Z}$ for addition, subtraction, and multiplication. For left shift by $c$, compute $(x \\ll c) \\bmod 2^W$. For right shift by $c$, if the value being shifted is signed, perform arithmetic right shift (replicating the sign bit); if it is unsigned, perform logical right shift (inserting zeros at the high end). The shift amount $c$ for each test is a nonnegative integer strictly less than $W$.\n  4. Interpret the resulting width-$W$ bit pattern in two ways: as an unsigned integer $u \\in [0, 2^W-1]$, and as a signed integer $s \\in \\left[-2^{W-1}, 2^{W-1}-1\\right]$ using two's complement interpretation.\n- All operations are over pure integers and bit patterns. No physical units apply, and no angles are involved.\n\nRequired Program Behavior:\n- Embed the test suite below directly in the program source. Do not read any input.\n- For each test case, compute the result according to the rules above and produce two numbers: the unsigned interpretation $u$ and the signed interpretation $s$ of the width-$W$ result.\n- The final output format must be a single line containing a comma-separated list of per-test-case results, each result formatted as a two-element list $[u,s]$, all enclosed within one outer pair of square brackets. For example: $[[u_1,s_1],[u_2,s_2],\\dots]$ with no spaces.\n- The only permissible numeric types in the output are integers. The overall output type is therefore a list of lists of integers.\n\nTest Suite:\nLet $\\text{op} \\in \\{\\text{add}, \\text{sub}, \\text{mul}, \\text{shl}, \\text{shr}\\}$ denote the operation on operand $a$ and operand $b$. Each operand is described by $(w, s, v)$ where $w \\in \\{8,16,32,64\\}$ is bit-width, $s \\in \\{0,1\\}$ is signedness ($1$ signed, $0$ unsigned), and $v$ is the width-$w$ bit pattern interpreted as a nonnegative integer in $[0, 2^w - 1]$ prior to extension. For negative conceptual values, $v$ is the two's complement width-$w$ bit pattern. The target width is $W = \\max(w_a, w_b)$, and the shift amount $c$ is given by operand $b$’s value and satisfies $0 \\le c < W$.\n\nProvide the following $10$ test cases:\n\n1. $\\text{op} = \\text{add}$; $a = (8,1,255)$ which conceptually represents $-1$; $b = (16,0,1)$ representing $+1$. Here $W=16$.\n2. $\\text{op} = \\text{add}$; $a = (16,1,32768)$ which conceptually represents $-32768$; $b = (8,0,255)$ representing $255$. Here $W=16$.\n3. $\\text{op} = \\text{sub}$; $a = (8,1,255)$ representing $-1$; $b = (32,0,0)$ representing $0$. Here $W=32$.\n4. $\\text{op} = \\text{mul}$; $a = (64,0,256)$ representing $256$; $b = (8,1,254)$ representing $-2$. Here $W=64$.\n5. $\\text{op} = \\text{shl}$; $a = (8,1,255)$ representing $-1$; $b = (8,0,1)$ representing shift count $c=1$. Here $W=8$.\n6. $\\text{op} = \\text{shr}$; $a = (8,1,254)$ representing $-2$; $b = (8,0,1)$ representing $c=1$. Here $W=8$.\n7. $\\text{op} = \\text{shr}$; $a = (8,0,128)$ representing unsigned $128$; $b = (8,0,1)$ representing $c=1$. Here $W=8$.\n8. $\\text{op} = \\text{add}$; $a = (64,1,9223372036854775808)$ representing $-2^{63}$; $b = (32,0,1)$ representing $+1$. Here $W=64$.\n9. $\\text{op} = \\text{sub}$; $a = (8,1,128)$ representing $-128$; $b = (16,0,0)$ representing $0$. Here $W=16$.\n10. $\\text{op} = \\text{mul}$; $a = (16,0,65535)$ representing $65535$; $b = (8,0,2)$ representing $2$. Here $W=16$.\n\nDeliverable:\n- Implement the evaluator in the C programming language. The program must compile and run without input, embed the test suite, and print exactly one line containing the nested list of results in the format $[[u_1,s_1],[u_2,s_2],\\dots,[u_{10},s_{10}]]$ with no spaces.",
            "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded in the principles of computer arithmetic, well-posed with a clear and deterministic set of rules, and expressed in objective, formal language. There are no contradictions, ambiguities, or missing information that would prevent the derivation of a unique solution.\n\nThe task is to implement a reference evaluator for mixed-width integer arithmetic, covering addition, subtraction, multiplication, and bit shifts. The process for each operation is meticulously defined. We will construct a C program to execute the specified test suite and produce results according to these rules. The core of the solution lies in correctly modeling two's complement arithmetic, sign/zero extension, and the specific behavior of each operation.\n\nWe will use the standard C types `unsigned long long` and `long long`. The C standard guarantees these types are at least $64$ bits wide, which is sufficient to represent all bit patterns and values in this problem.\n\nThe overall approach for each test case is as follows:\n1.  Define a data structure to represent an operand with its width `$w$`, signedness `$s$`, and value bit-pattern `$v$`.\n2.  For each test case, determine the target width `$W = \\max(w_a, w_b)$`.\n3.  Extend each operand, `$a$` and `$b$`, from its native width (`$w_a$` or `$w_b$`) to the target width `$W$`. The extension is based on the operand's signedness `$s$`.\n4.  Perform the specified binary operation on the extended operands. All arithmetic is performed modulo `$2^W$`.\n5.  The resulting `$W`\\-bit pattern is interpreted in two ways: as an unsigned integer `$u$` and as a signed integer `$s$`.\n\nLet's detail the critical steps.\n\n**1. Data Representation**\nWe represent an operand `(w, s, v)` using a structure. The value `$v$` is stored as an `unsigned long long`, representing the raw bit pattern.\n\n**2. Sign Extension**\nA crucial function is the sign extension of a `$w`\\--bit value to a wider format. A value `$v$` is negative in `$w`\\--bit two's complement if its sign bit, bit `$w-1$`, is set. Sign extension replicates this sign bit into all higher-order bits of the target width.\n\nWe define a helper function, `sign_extend(v, w)`, which takes a `$w`\\--bit pattern `$v$` and returns its `$64`\\--bit signed equivalent. This is achieved by left-shifting the value to align its sign bit with the sign bit of a `$64`\\--bit integer, casting to a signed type to lock in the sign, and then arithmetically right-shifting it back. This can be expressed as:\n`((long long)(v << (64 - w))) >> (64 - w)`\nThis correctly handles both positive and negative values. For example, extending the `$8`\\--bit value `$255$` (`$0xFF$`), which represents `$-1$`, to `$64$` bits will result in the `$64`\\--bit value `$-1$` (`$0xFFFFFFFFFFFFFFFF$`).\n\n**3. Operand Extension to Target Width `$W$`**\nBefore an operation, each operand `$(w,s,v)$` must be extended to the target width `$W$`.\n- If `$s=0$` (unsigned), the operand is zero-extended. This is a no-op on the bit pattern `$v$` itself, as we work with `unsigned long long`.\n- If `$s=1$` (signed), the operand is sign-extended. We apply the `sign_extend` logic. The conceptual value is obtained, and we work with its bit pattern. Our implementation will extend a signed operand `$v$` from its width `$w$` to the target width `$W$` by first checking its sign bit `$(v \\gg (w-1)) \\& 1$`. If the sign bit is `$1$`, we fill the bits from `$w$` to `$W-1$` with `$1$s. This is done by computing a mask `((1ULL \\ll W) - 1) \\oplus ((1ULL \\ll w) - 1)` (for `$W < 64$`) and `OR`ing it with `$v$`.\n\n**4. Operations**\nLet `$v_a'$` and `$v_b'$` be the bit patterns of operands `$a$` and `$b$` after extension to width `$W$`.\n\n-   **Addition, Subtraction, Multiplication:** These are performed using standard `unsigned long long` arithmetic. The results naturally wrap around modulo `$2^{64}$`. We then apply a mask to truncate the result to `$W$` bits.\n    - `$res = (v_a' + v_b') \\pmod{2^W}$`\n    - `$res = (v_a' - v_b') \\pmod{2^W}$`\n    - `$res = (v_a' \\times v_b') \\pmod{2^W}$`\n    The mask for `$W<64$` bits is `$M_W = (1ULL \\ll W) - 1$`. For `$W=64$`, the mask is `$\\sim0ULL$`.\n\n-   **Left Shift (`shl`):** The extended value `$v_a'$` is shifted left by `$c=v_b$`. The result is masked to `$W$` bits.\n    - `$res = (v_a' \\ll c) \\pmod{2^W}$`\n\n-   **Right Shift (`shr`):** The behavior depends on the signedness `$s_a$` of the operand being shifted.\n    - If `$s_a=0$` (unsigned), a logical right shift is performed on `$v_a'$`.\n        `$res = v_a' \\gg c$`\n    - If `$s_a=1$` (signed), an arithmetic right shift is performed. This is implemented by treating the `$W`\\--bit pattern `$v_a'$` as a signed number, performing the shift, and then taking the resulting bit pattern. We use our `sign_extend` helper:\n        `$tmp = \\text{sign\\_extend}(v_a', W)$`\n        `$tmp = tmp \\gg c$`\n        `$res = (\\text{unsigned long long})tmp$`\n\n**5. Final Interpretation**\nThe final `$W`\\--bit result pattern, `$res_u$`, is the unsigned result `$u$`. To find the signed result `$s$`, we interpret `$res_u$` as a `$W`\\--bit two's complement number. This is done by sign-extending `$res_u$` from width `$W$` to `$64$` bits using our `sign_extend` helper function.\n\nLet's illustrate with Test Case 9:\n`op = sub; a = (8,1,128); b = (16,0,0)`\n1.  Target width `$W = \\max(8,16) = 16$`.\n2.  Operand `$a = (w_a=8, s_a=1, v_a=128)$`. `$v_a$` is `$0x80$`. Since `$s_a=1$`, we sign-extend from `$8$` to `$16$` bits. The `$8`\\--bit value `$128$` (`$0x80$`) represents `$-128$`. Sign-extending to `$16$` bits yields `$0xFF80$`. So, `$v_a' = 65408$`.\n3.  Operand `$b = (w_b=16, s_b=0, v_b=0)$`. Since `$s_b=0$`, we zero-extend from `$16$` to `$16$` bits (no change). So, `$v_b' = 0$`.\n4.  Operation is `sub`. We compute `$v_a' - v_b'` in modulo `$2^{16}$` arithmetic.\n    `$65408 - 0 = 65408$`. The `$16`\\--bit result is `$65408$` (`$0xFF80$`).\n5.  The unsigned result is `$u_9 = 65408$`.\n6.  For the signed result `$s_9$`, we interpret the `$16`\\--bit pattern `$0xFF80$` as a signed number. `sign_extend(65408, 16)` gives `$-128$`. So, `$s_9 = -128$`.\n7.  The final result for this case is `$[65408,-128]$`.\n\nThis methodology is applied to all test cases to generate the final output.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Note: 'unsigned long long' and 'long long' are used for 64-bit integer arithmetic,\n// as they are guaranteed by the C standard to be at least 64 bits wide.\n\n// Represents an operand with its width, signedness, and value bit-pattern.\ntypedef struct {\n    int w;                  // width in {8, 16, 32, 64}\n    int s;                  // signedness {0: unsigned, 1: signed}\n    unsigned long long v;   // value bit-pattern\n} Operand;\n\n// Represents a single test case.\ntypedef struct {\n    char op[4];             // \"add\", \"sub\", \"mul\", \"shl\", \"shr\"\n    Operand a;\n    Operand b;\n} TestCase;\n\n// Represents the pair of results for a test case.\ntypedef struct {\n    unsigned long long u;   // Unsigned interpretation\n    long long s;            // Signed interpretation\n} Result;\n\n// Helper function to sign-extend a value 'v' of width 'w' to a 64-bit signed integer.\n// This is critical for interpreting values and for arithmetic right shifts.\nlong long sign_extend(unsigned long long v, int w) {\n    if (w >= 64) {\n        return (long long)v;\n    }\n    // The following sequence shifts the value's sign bit to the 64-bit sign bit position,\n    // casts to a signed type to trigger sign extension via an arithmetic right shift,\n    // and then shifts it back to its original magnitude.\n    int shift_amount = 64 - w;\n    return ((long long)(v << shift_amount)) >> shift_amount;\n}\n\n// Helper function to extend an operand's bit-pattern 'v' from width 'w' to target width 'W'.\nunsigned long long extend_to_W(unsigned long long v, int w, int s, int W) {\n    if (s == 0 || w >= W) {\n        // Zero extension is a no-op on the raw bits.\n        // No extension is needed if the original width is not smaller than the target.\n        return v;\n    }\n\n    // Signed extension: check the sign bit at original width 'w'.\n    unsigned long long sign_bit = (v >> (w - 1)) & 1;\n    if (sign_bit) {\n        // The value is negative. We need to fill upper bits from 'w' to 'W-1' with 1s.\n        // Create a mask of 1s from bit `w` up to `W-1`.\n        unsigned long long mask = 0;\n        if (W == 64) {\n             mask = (~0ULL) << w;\n        } else {\n             mask = ((1ULL << W) - 1) & (~((1ULL << w) - 1));\n        }\n        return v | mask;\n    } else {\n        // The value is positive, so it's effectively zero-extended.\n        return v;\n    }\n}\n\nint main(void) {\n    TestCase test_cases[] = {\n        {\"add\", {8,  1, 255},                  {16, 0, 1}},\n        {\"add\", {16, 1, 32768},                {8,  0, 255}},\n        {\"sub\", {8,  1, 255},                  {32, 0, 0}},\n        {\"mul\", {64, 0, 256},                  {8,  1, 254}},\n        {\"shl\", {8,  1, 255},                  {8,  0, 1}},\n        {\"shr\", {8,  1, 254},                  {8,  0, 1}},\n        {\"shr\", {8,  0, 128},                  {8,  0, 1}},\n        {\"add\", {64, 1, 9223372036854775808ULL}, {32, 0, 1}},\n        {\"sub\", {8,  1, 128},                  {16, 0, 0}},\n        {\"mul\", {16, 0, 65535},                {8,  0, 2}}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    Result results[num_cases];\n\n    for (int i = 0; i < num_cases; ++i) {\n        Operand a = test_cases[i].a;\n        Operand b = test_cases[i].b;\n        const char *op = test_cases[i].op;\n\n        // 1. Determine target width W\n        int W = (a.w > b.w) ? a.w : b.w;\n\n        // 2. Extend operands to width W\n        unsigned long long val_a_ext = extend_to_W(a.v, a.w, a.s, W);\n        unsigned long long val_b_ext = extend_to_W(b.v, b.w, b.s, W);\n        \n        unsigned long long result_pattern = 0;\n\n        // 3. Perform operation\n        if (strcmp(op, \"add\") == 0) {\n            result_pattern = val_a_ext + val_b_ext;\n        } else if (strcmp(op, \"sub\") == 0) {\n            result_pattern = val_a_ext - val_b_ext;\n        } else if (strcmp(op, \"mul\") == 0) {\n            result_pattern = val_a_ext * val_b_ext;\n        } else if (strcmp(op, \"shl\") == 0) {\n            unsigned long long shift_amount = b.v;\n            result_pattern = val_a_ext << shift_amount;\n        } else if (strcmp(op, \"shr\") == 0) {\n            unsigned long long shift_amount = b.v;\n            if (a.s == 1) { // Arithmetic shift for signed operand a\n                long long temp = sign_extend(val_a_ext, W);\n                temp = temp >> shift_amount;\n                result_pattern = (unsigned long long)temp;\n            } else { // Logical shift for unsigned operand a\n                result_pattern = val_a_ext >> shift_amount;\n            }\n        }\n        \n        // 4. Mask result to target width W\n        unsigned long long u_res;\n        if (W < 64) {\n            unsigned long long mask_W = (1ULL << W) - 1;\n            u_res = result_pattern & mask_W;\n        } else {\n            u_res = result_pattern; // No mask needed for 64-bit\n        }\n        \n        // 5. Interpret result as both unsigned (u) and signed (s)\n        results[i].u = u_res;\n        results[i].s = sign_extend(u_res, W);\n    }\n\n    // Print the results in the exact specified format.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%llu,%lld]\", results[i].u, results[i].s);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Sophisticated optimizations rely on analyses that gather information across an entire program, represented as a Control-Flow Graph (CFG). This exercise explores the validation of liveness analysis, which determines the variables that may be used in the future. Instead of implementing the iterative algorithm to compute liveness, your task is to verify that a candidate solution satisfies the fundamental dataflow equations, reinforcing the core theory and providing a robust method for testing the output of any liveness analyzer .",
            "id": "3629971",
            "problem": "You are tasked with validating a backward dataflow liveness analysis on a set of Control-Flow Graphs (CFGs), adhering to the mathematical principles of compiler testing and validation. A Control-Flow Graph (CFG) is a directed graph whose nodes represent program points (basic blocks or statements), and edges represent possible control flow transitions. For a node $n$, the successor set is denoted $\\mathrm{succ}(n)$. The liveness analysis attaches to each node $n$ two sets of variables: $LIVE\\_IN[n]$ and $LIVE\\_OUT[n]$. Each node $n$ also has sets $USE[n]$ (variables read before any redefinition) and $DEF[n]$ (variables defined in the node). Variables are drawn from a finite universe $\\{v_0, v_1, \\dots, v_{K-1}\\}$.\n\nFundamental definitions for backward liveness analysis are:\n- $LIVE\\_OUT[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} LIVE\\_IN[s]$,\n- $LIVE\\_IN[n] = USE[n] \\cup \\left(LIVE\\_OUT[n] \\setminus DEF[n]\\right)$.\n\nYour program must validate, for each provided test case, whether the candidate sets $LIVE\\_IN/LIVE\\_OUT$ satisfy these equations simultaneously at every node in the CFG. Each test case includes:\n- The number of nodes $N$ and variables $K$,\n- The successor lists $\\mathrm{succ}(n)$ for each node $n \\in \\{0,1,\\dots,N-1\\}$,\n- The $USE[n]$ and $DEF[n]$ sets,\n- Candidate $LIVE\\_IN[n]$ and $LIVE\\_OUT[n]$ sets.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Use $1$ for true (all equations satisfied in the test case) and $0$ for false. No other output is permitted.\n\nTest Suite (all sets are subsets of $\\{v_0, v_1, \\dots\\}$ and all node indices are integers in $\\{0,\\dots,N-1\\}$):\n\n- Test Case $1$ (split and join):\n  - $N = 4$, $K = 3$.\n  - Successors:\n    - $\\mathrm{succ}(0) = [\\,1, 2\\,]$,\n    - $\\mathrm{succ}(1) = [\\,3\\,]$,\n    - $\\mathrm{succ}(2) = [\\,3\\,]$,\n    - $\\mathrm{succ}(3) = [\\,]$.\n  - Sets:\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{v_0\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{v_1\\}$,\n    - $USE[2] = \\{\\}$, $DEF[2] = \\{v_0\\}$,\n    - $USE[3] = \\{v_1\\}$, $DEF[3] = \\{\\}$.\n  - Candidate liveness:\n    - $LIVE\\_IN[0] = \\{v_1\\}$, $LIVE\\_OUT[0] = \\{v_0,v_1\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{v_1\\}$,\n    - $LIVE\\_IN[2] = \\{v_1\\}$, $LIVE\\_OUT[2] = \\{v_1\\}$,\n    - $LIVE\\_IN[3] = \\{v_1\\}$, $LIVE\\_OUT[3] = \\{\\}$.\n\n- Test Case $2$ (same CFG as test case $1$; intentionally incorrect $LIVE\\_OUT[0]$):\n  - $N = 4$, $K = 3$.\n  - Successors: identical to test case $1$.\n  - Sets: identical to test case $1$.\n  - Candidate liveness:\n    - $LIVE\\_IN[0] = \\{v_1\\}$, $LIVE\\_OUT[0] = \\{v_0\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{v_1\\}$,\n    - $LIVE\\_IN[2] = \\{v_1\\}$, $LIVE\\_OUT[2] = \\{v_1\\}$,\n    - $LIVE\\_IN[3] = \\{v_1\\}$, $LIVE\\_OUT[3] = \\{\\}$.\n\n- Test Case $3$ (boundary: exit node uses a variable):\n  - $N = 2$, $K = 1$.\n  - Successors:\n    - $\\mathrm{succ}(0) = [\\,1\\,]$,\n    - $\\mathrm{succ}(1) = [\\,]$.\n  - Sets:\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{\\}$.\n  - Candidate liveness:\n    - $LIVE\\_IN[0] = \\{v_0\\}$, $LIVE\\_OUT[0] = \\{v_0\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{\\}$.\n\n- Test Case $4$ (loop with join and exit):\n  - $N = 4$, $K = 3$.\n  - Successors:\n    - $\\mathrm{succ}(0) = [\\,1\\,]$,\n    - $\\mathrm{succ}(1) = [\\,2\\,]$,\n    - $\\mathrm{succ}(2) = [\\,1, 3\\,]$,\n    - $\\mathrm{succ}(3) = [\\,]$.\n  - Sets:\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{v_0\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{v_1\\}$,\n    - $USE[2] = \\{v_1\\}$, $DEF[2] = \\{\\}$,\n    - $USE[3] = \\{v_2\\}$, $DEF[3] = \\{\\}$.\n  - Candidate liveness:\n    - $LIVE\\_IN[0] = \\{v_2\\}$, $LIVE\\_OUT[0] = \\{v_0,v_2\\}$,\n    - $LIVE\\_IN[1] = \\{v_0,v_2\\}$, $LIVE\\_OUT[1] = \\{v_0,v_1,v_2\\}$,\n    - $LIVE\\_IN[2] = \\{v_0,v_1,v_2\\}$, $LIVE\\_OUT[2] = \\{v_0,v_2\\}$,\n    - $LIVE\\_IN[3] = \\{v_2\\}$, $LIVE\\_OUT[3] = \\{\\}$.\n\n- Test Case $5$ (edge case with an unreachable node):\n  - $N = 3$, $K = 2$.\n  - Successors:\n    - $\\mathrm{succ}(0) = [\\,1\\,]$,\n    - $\\mathrm{succ}(1) = [\\,]$,\n    - $\\mathrm{succ}(2) = [\\,]$.\n  - Sets:\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{v_1\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{\\}$,\n    - $USE[2] = \\{v_1\\}$, $DEF[2] = \\{\\}$.\n  - Candidate liveness:\n    - $LIVE\\_IN[0] = \\{v_0\\}$, $LIVE\\_OUT[0] = \\{v_0\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{\\}$,\n    - $LIVE\\_IN[2] = \\{v_1\\}$, $LIVE\\_OUT[2] = \\{\\}$.\n\nYour program must construct these test cases internally (no input) and, for each, check the two equations above for every node. The required output is a single line with a list of $N_{tests}$ integers, one per test case, in order, using $1$ when all nodes satisfy both equations and $0$ otherwise, printed exactly in the format $[r_1,r_2,\\dots,r_{N\\_{tests}}]$.",
            "solution": "The user has provided a problem that requires the validation of liveness analysis results for several control-flow graphs (CFGs).\n\n### Step 1: Extract Givens\n- **Task**: Validate candidate liveness sets ($LIVE\\_IN$, $LIVE\\_OUT$) against the fundamental dataflow equations of backward liveness analysis for a given set of test cases.\n- **Liveness Analysis Equations**:\n  1. $LIVE\\_OUT[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} LIVE\\_IN[s]$\n  2. $LIVE\\_IN[n] = USE[n] \\cup \\left(LIVE\\_OUT[n] \\setminus DEF[n]\\right)$\n- **Definitions**:\n  - $n$: a node in the CFG, from the set $\\{0, 1, \\dots, N-1\\}$.\n  - $\\mathrm{succ}(n)$: the set of successors of node $n$.\n  - $USE[n]$: set of variables used at node $n$ before definition.\n  - $DEF[n]$: set of variables defined at node $n$.\n  - Variables: from the finite universe $\\{v_0, v_1, \\dots, v_{K-1}\\}$.\n- **Output Format**: A single line containing a comma-separated list of validation results ($1$ for true, $0$ for false) for each test case, enclosed in square brackets. Example: `[1,0,1,...]`.\n- **Test Cases**: Five test cases are provided, each specifying the number of nodes $N$, the number of variables $K$, the successor lists for each node, the $USE$ and $DEF$ sets for each node, and the candidate $LIVE\\_IN$ and $LIVE\\_OUT$ sets for each node.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is rooted in compiler theory, a core area of computer science. The definitions for CFGs and the dataflow equations for liveness analysis are standard, correct, and fundamental to the field. The problem is scientifically sound.\n- **Well-Posed**: The task is to verify a given set of data against a pair of explicit mathematical equations. For each node in each test case, all necessary data is provided. The verification process is deterministic: compute the right-hand side of each equation and compare it to the given left-hand side. A unique and unambiguous boolean result (true/false) exists for each test case. The problem is well-posed.\n- **Objective**: The problem is stated using formal mathematical notation and provides concrete, objective data. The criteria for validation are the strict equality of sets defined by the equations. There is no ambiguity or subjectivity.\n- **Completeness and Consistency**: All necessary components for each test case ($N, K$, successor lists, $USE, DEF, LIVE\\_IN, LIVE\\_OUT$ sets) are fully specified. There are no contradictions.\n- **Feasibility**: The test cases involve small graphs and a small number of variables, making them computationally trivial and perfectly suited for an example program.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined, scientifically sound, and objective problem from the field of compiler design.\n\n### Principle-Based Design\nThe solution will validate the provided liveness analysis data by systematically applying the two fundamental equations of backward liveness analysis to every node in each test case CFG.\n\n**1. Data Representation:**\nThe sets of variables ($USE$, $DEF$, $LIVE\\_IN$, $LIVE\\_OUT$) are subsets of a small, finite universe $\\{v_0, v_1, \\dots, v_{K-1}\\}$. This structure is ideally suited for a bitmask representation. A set will be represented by an integer, where the $i$-th bit is $1$ if variable $v_i$ is in the set, and $0$ otherwise. This allows for highly efficient set operations using bitwise logic:\n- **Set Union ($A \\cup B$)**: Implemented as a bitwise OR (`A | B`).\n- **Set Intersection ($A \\cap B$)**: Implemented as a bitwise AND (`A & B`).\n- **Set Difference ($A \\setminus B$)**: Implemented as `A & (~B)`, where `~` is the bitwise NOT operator.\n\n**2. CFG and Test Case Structure:**\nTo organize the data for each test case, a hierarchical structure of `structs` will be used:\n- A `Node` struct will encapsulate all data for a single node: its $USE$, $DEF$, $LIVE\\_IN$, and $LIVE\\_OUT$ sets (as integer bitmasks), its number of successors, and a pointer to an array of successor indices.\n- A `TestCase` struct will represent a complete test scenario, containing the number of nodes $N$, the number of variables $K$, and a pointer to an array of `Node` structs.\n\n**3. Validation Algorithm:**\nA function, `validate_test_case`, will be created to determine the validity of a single test case. This function will iterate through every node $n$ from $0$ to $N-1$ and perform two checks:\n\n- **Check 1: $LIVE\\_OUT[n]$ Validation**\n  The equation is $LIVE\\_OUT[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} LIVE\\_IN[s]$.\n  To validate this, the algorithm will compute the right-hand side by initializing an empty set (an integer with value $0$) and then iterating through all successors $s$ of node $n$. In each iteration, it performs a bitwise OR with `LIVE_IN[s]`. The final result is then compared with the provided `LIVE_OUT[n]`.\n\n- **Check 2: $LIVE\\_IN[n]$ Validation**\n  The equation is $LIVE\\_IN[n] = USE[n] \\cup (LIVE\\_OUT[n] \\setminus DEF[n])$.\n  The algorithm computes the right-hand side in two steps. First, it calculates the set difference $LIVE\\_OUT[n] \\setminus DEF[n]$ using the bitwise operation `LIVE_OUT[n] & (~DEF[n])`. Second, it computes the union of this result with $USE[n]$ using a bitwise OR. This final computed value is then compared with the provided `LIVE_IN[n]`.\n\nIf either of these checks fails for any node in the CFG, the entire test case is deemed invalid, and the function returns $0$. If all checks pass for all nodes, the test case is valid, and the function returns $1$.\n\n**4. Main Execution Logic:**\nThe `main` function will statically define all data for the five test cases as specified in the problem. These definitions will be used to initialize an array of `TestCase` structs. The program will then iterate through this array, call `validate_test_case` for each, and store the $0$ or $1$ result. Finally, it will print the collected results in the specified format `[r_1,r_2,r_3,r_4,r_5]` to standard output.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// A struct to hold all data for a single node in a CFG.\n// Sets are represented as bitmasks, where bit i corresponds to variable v_i.\ntypedef struct {\n    int use_set;\n    int def_set;\n    int live_in_set;\n    int live_out_set;\n    int num_succ;\n    const int *succ;\n} Node;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int N;             // Number of nodes\n    int K;             // Number of variables\n    const Node *nodes; // Array of nodes in the CFG\n} TestCase;\n\n// Validates the liveness equations for a single test case.\n// Returns 1 if all equations hold for all nodes, 0 otherwise.\nint validate_liveness(const TestCase *tc) {\n    for (int n = 0; n < tc->N; ++n) {\n        const Node *current_node = &tc->nodes[n];\n\n        // 1. Validate LIVE_OUT[n] = U_{s in succ(n)} LIVE_IN[s]\n        int computed_live_out = 0;\n        for (int i = 0; i < current_node->num_succ; ++i) {\n            int s_idx = current_node->succ[i];\n            computed_live_out |= tc->nodes[s_idx].live_in_set;\n        }\n\n        if (computed_live_out != current_node->live_out_set) {\n            return 0; // Fails validation\n        }\n\n        // 2. Validate LIVE_IN[n] = USE[n] U (LIVE_OUT[n] \\ DEF[n])\n        int live_out_minus_def = current_node->live_out_set & (~current_node->def_set);\n        int computed_live_in = current_node->use_set | live_out_minus_def;\n\n        if (computed_live_in != current_node->live_in_set) {\n            return 0; // Fails validation\n        }\n    }\n    return 1; // All nodes passed validation\n}\n\nint main(void) {\n    // --- Test Case 1 Data ---\n    const int succs_1_0[] = {1, 2};\n    const int succs_1_1[] = {3};\n    const int succs_1_2[] = {3};\n    const int succs_1_3[] = {};\n    const Node nodes_1[] = {\n        // USE, DEF, IN, OUT, num_succ, succ_list\n        {(0), (1<<0), (1<<1), (1<<0)|(1<<1), 2, succs_1_0}, // Node 0\n        {(1<<0), (1<<1), (1<<0), (1<<1), 1, succs_1_1},     // Node 1\n        {(0), (1<<0), (1<<1), (1<<1), 1, succs_1_2},         // Node 2\n        {(1<<1), (0), (1<<1), (0), 0, succs_1_3}            // Node 3\n    };\n\n    // --- Test Case 2 Data ---\n    const Node nodes_2[] = {\n        // Node 0 has incorrect LIVE_OUT\n        {(0), (1<<0), (1<<1), (1<<0), 2, succs_1_0},         // Node 0\n        {(1<<0), (1<<1), (1<<0), (1<<1), 1, succs_1_1},     // Node 1\n        {(0), (1<<0), (1<<1), (1<<1), 1, succs_1_2},         // Node 2\n        {(1<<1), (0), (1<<1), (0), 0, succs_1_3}            // Node 3\n    };\n\n    // --- Test Case 3 Data ---\n    const int succs_3_0[] = {1};\n    const int succs_3_1[] = {};\n    const Node nodes_3[] = {\n        {(0), (0), (1<<0), (1<<0), 1, succs_3_0}, // Node 0\n        {(1<<0), (0), (1<<0), (0), 0, succs_3_1}  // Node 1\n    };\n    \n    // --- Test Case 4 Data ---\n    const int succs_4_0[] = {1};\n    const int succs_4_1[] = {2};\n    const int succs_4_2[] = {1, 3};\n    const int succs_4_3[] = {};\n    const Node nodes_4[] = {\n        {(0), (1<<0), (1<<2), (1<<0)|(1<<2), 1, succs_4_0},                         // Node 0\n        {(1<<0), (1<<1), (1<<0)|(1<<2), (1<<0)|(1<<1)|(1<<2), 1, succs_4_1},        // Node 1\n        {(1<<1), (0), (1<<0)|(1<<1)|(1<<2), (1<<0)|(1<<2), 2, succs_4_2},           // Node 2\n        {(1<<2), (0), (1<<2), (0), 0, succs_4_3}                                   // Node 3\n    };\n\n    // --- Test Case 5 Data ---\n    const int succs_5_0[] = {1};\n    const int succs_5_1[] = {};\n    const int succs_5_2[] = {};\n    const Node nodes_5[] = {\n        {(0), (1<<1), (1<<0), (1<<0), 1, succs_5_0}, // Node 0\n        {(1<<0), (0), (1<<0), (0), 0, succs_5_1},     // Node 1\n        {(1<<1), (0), (1<<1), (0), 0, succs_5_2}      // Node 2\n    };\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {4, 3, nodes_1},\n        {4, 3, nodes_2},\n        {2, 1, nodes_3},\n        {4, 3, nodes_4},\n        {3, 2, nodes_5}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        results[i] = validate_liveness(&test_cases[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "The true power of a compiler lies in its ability to transform code to make it faster, but these transformations are only valid if they preserve the original program's meaning. This practice demonstrates the critical link between a program analysis—alias analysis—and the safety of an optimization—instruction reordering. By simulating a code transformation under various memory aliasing scenarios, you will see firsthand how an incorrect alias analysis can lead to semantic bugs, highlighting the necessity of conservative and correct analysis for building a reliable optimizing compiler .",
            "id": "3630025",
            "problem": "You are given a single-threaded, deterministic execution model for a language where memory is modeled as a finite array of integers. Let the memory state be a total function $\\sigma : \\{0, 1, \\dots, L-1\\} \\to \\mathbb{Z}$, where $L$ is the memory length. Consider two arrays $A$ and $B$ represented as contiguous subranges of the same underlying memory $M$ with base indices $a$ and $b$ and lengths $n_A$ and $n_B$, respectively. The array $A$ occupies the addresses $\\{a, a+1, \\dots, a+n_A-1\\}$ and the array $B$ occupies the addresses $\\{b, b+1, \\dots, b+n_B-1\\}$. Two pointers $p$ and $q$ point into $A$ and $B$ at logical indices $i$ and $j$, respectively, so that $p$ refers to address $a+i$ and $q$ refers to address $b+j$. Let $c$ be a fixed integer constant.\n\nIn this model, the original program fragment executes the following sequence of operations in program order:\n1. $v_1 := *p$,\n2. $v_2 := *q$,\n3. $*q := v_2 + c$,\n4. $*p := v_1 + v_2$.\n\nAn optimizer may attempt to reorder the load/store operations. The reordering under test moves the store to $*q$ earlier across the load from $*p$, producing the sequence:\n1. $v_2 := *q$,\n2. $*q := v_2 + c$,\n3. $v_1 := *p$,\n4. $*p := v_1 + v_2$.\n\nThe purpose of alias analysis is to conservatively determine relationships between memory references. Define:\n- \"may-alias\" between $p$ and $q$ to be true if the subranges of $A$ and $B$ overlap, i.e., if $\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1)$.\n- \"must-not-alias\" to be true if the subranges do not overlap, i.e., if $\\max(a, b) > \\min(a+n_A-1, b+n_B-1)$.\n\nUnder single-threaded sequential semantics, a reordering is semantics-preserving if and only if the final memory state and produced values are equal for all inputs. From first principles, a store may be moved earlier across a load only if it cannot change the value observed by that load, which in this case holds if and only if the addresses $a+i$ and $b+j$ are different.\n\nYour task is to write a complete, runnable program that:\n- For each provided test case, constructs the memory $M$ with the given initial contents $\\sigma$ and parameters $(L, a, n_A, b, n_B, i, j, c)$.\n- Computes a boolean $s$ indicating whether the above reordering is semantics-preserving for the specific pointers $p$ and $q$, by simulating both the original sequence and the reordered sequence and comparing the final contents at the affected addresses.\n- Computes a boolean $m$ indicating whether $A$ and $B$ may-alias, based solely on their subrange overlap $(\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1))$.\n- Produces a single line of output containing the results as a comma-separated list of pairs $[s, m]$ enclosed in square brackets, with all booleans printed as integers ($0$ for false, $1$ for true). The format must be exactly:\n$[[s_1,m_1],[s_2,m_2],\\dots,[s_T,m_T]]$\nwhere $T$ is the number of test cases.\n\nTest Suite:\nUse the following five test cases. In each case, $L=10$ and $M$ is initialized as given. All indices are zero-based. The values of $L$, $a$, $n_A$, $b$, $n_B$, $i$, $j$, and $c$ appear in parentheses after the memory initializer.\n\n1. $M = [10,20,30,40,50,60,70,80,90,100]$, $(L=10, a=0, n_A=4, b=5, n_B=4, i=1, j=2, c=3)$. Arrays are disjoint, $p$ at address $1$, $q$ at address $7$.\n2. $M = [1,3,5,7,9,11,13,15,17,19]$, $(L=10, a=2, n_A=4, b=3, n_B=4, i=1, j=0, c=4)$. Arrays overlap and $p$ and $q$ point to the same address $3$.\n3. $M = [2,4,6,8,10,12,14,16,18,20]$, $(L=10, a=2, n_A=5, b=4, n_B=5, i=0, j=3, c=5)$. Arrays partially overlap; $p$ at address $2$, $q$ at address $7$.\n4. $M = [0,1,2,3,4,5,6,7,8,9]$, $(L=10, a=0, n_A=5, b=5, n_B=5, i=4, j=0, c=2)$. Arrays are adjacent but disjoint; $p$ at address $4$, $q$ at address $5$.\n5. $M = [9,8,7,6,5,4,3,2,1,0]$, $(L=10, a=1, n_A=7, b=1, n_B=7, i=3, j=3, c=1)$. Arrays are identical; $p$ and $q$ both at address $4$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case contributing a pair $[s,m]$ where $s$ and $m$ are integers $0$ or $1$. For example, for three cases the output would look like $[[1,0],[0,1],[1,1]]$. Your program must produce exactly one line in this format for the five test cases described above.",
            "solution": "We derive the safety of the given reordering from the principles of single-threaded sequential program semantics and the core definitions of aliasing.\n\nLet the memory state be a function $\\sigma : \\mathcal{A} \\to \\mathbb{Z}$ over the set of addresses $\\mathcal{A} = \\{0, 1, \\dots, L-1\\}$. The operational semantics of a load from address $\\alpha \\in \\mathcal{A}$ yields the value $\\sigma(\\alpha)$ and does not change the state. The semantics of a store of value $w \\in \\mathbb{Z}$ to address $\\alpha$ yields a new state $\\sigma'$ such that $\\sigma'(\\alpha) = w$ and $\\forall \\beta \\neq \\alpha, \\sigma'(\\beta) = \\sigma(\\beta)$. In a single-threaded program, the semantics is sequential: a program executes as a sequence of state transformations where loads observe the current state and stores update it.\n\nDefine the addresses $\\alpha_p = a+i$ and $\\alpha_q = b+j$. The original sequence executes:\n1. $v_1 := \\sigma(\\alpha_p)$,\n2. $v_2 := \\sigma(\\alpha_q)$,\n3. $\\sigma_1 := \\sigma[\\alpha_q \\mapsto (v_2 + c)]$,\n4. $\\sigma_2 := \\sigma_1[\\alpha_p \\mapsto (v_1 + v_2)]$.\n\nThe reordered sequence executes:\n1. $v_2' := \\sigma(\\alpha_q)$,\n2. $\\sigma'_1 := \\sigma[\\alpha_q \\mapsto (v_2' + c)]$,\n3. $v_1' := \\sigma'_1(\\alpha_p)$,\n4. $\\sigma'_2 := \\sigma'_1[\\alpha_p \\mapsto (v_1' + v_2')]$.\n\nWe compare $\\sigma_2$ and $\\sigma'_2$ to determine semantics preservation. Consider two cases:\n\nCase 1: $\\alpha_p \\neq \\alpha_q$. In the original sequence, the store to $\\alpha_q$ in step $3$ does not affect the value read from $\\alpha_p$ in step $1$ because the load happened before the store. In the reordered sequence, the store to $\\alpha_q$ occurs before the load from $\\alpha_p$, but since $\\alpha_p \\neq \\alpha_q$, the value at $\\alpha_p$ is unchanged by the store to $\\alpha_q$. Therefore, $v_1' = \\sigma(\\alpha_p) = v_1$, $v_2' = \\sigma(\\alpha_q) = v_2$, and the final assignments are identical: $\\sigma_2(\\alpha_q) = v_2 + c = \\sigma'_2(\\alpha_q)$ and $\\sigma_2(\\alpha_p) = v_1 + v_2 = \\sigma'_2(\\alpha_p)$, with all other addresses equal as well. Hence, the reordering is semantics-preserving when $\\alpha_p \\neq \\alpha_q$.\n\nCase 2: $\\alpha_p = \\alpha_q$. In the original sequence, we have:\n- $v_1 = \\sigma(\\alpha_p)$,\n- $v_2 = \\sigma(\\alpha_p)$,\n- After step $3$, $\\sigma_1(\\alpha_p) = v_2 + c$,\n- After step $4$, $\\sigma_2(\\alpha_p) = v_1 + v_2$.\n\nIn the reordered sequence:\n- $v_2' = \\sigma(\\alpha_p)$,\n- After step $2$, $\\sigma'_1(\\alpha_p) = v_2' + c$,\n- Then $v_1' = \\sigma'_1(\\alpha_p) = v_2' + c$,\n- After step $4$, $\\sigma'_2(\\alpha_p) = v_1' + v_2' = (v_2' + c) + v_2' = 2 v_2' + c$.\n\nComparing the final values at $\\alpha_p$, in the original we have $\\sigma_2(\\alpha_p) = v_1 + v_2 = 2 \\sigma(\\alpha_p)$ (since $v_1 = v_2 = \\sigma(\\alpha_p)$), while in the reordered sequence we have $\\sigma'_2(\\alpha_p) = 2 \\sigma(\\alpha_p) + c$. Since $c$ is typically nonzero, the states differ. Even if $c = 0$, the sequences still differ in intermediate observations, and generally the transformation is unsafe because it changes the value read by the load at $\\alpha_p$. Therefore, the reordering is not semantics-preserving when $\\alpha_p = \\alpha_q$.\n\nThis analysis shows that the necessary and sufficient condition for correctness of the tested reordering is $\\alpha_p \\neq \\alpha_q$. From the perspective of alias analysis, a conservative \"may-alias\" result indicates potential equality of addresses at runtime. In the formulation for arrays $A$ and $B$, \"may-alias\" is defined as the subranges of $A$ and $B$ overlapping: $\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1)$. If \"may-alias\" is true, a compiler that respects alias analysis must not apply this reordering, because it cannot guarantee $\\alpha_p \\neq \\alpha_q$ for all executions without further information. If \"must-not-alias\" is true (no overlap), then $\\alpha_p \\neq \\alpha_q$ holds for any valid $i$ and $j$ within the bounds, and the reordering is safe.\n\nAlgorithmic design for the program:\n- For each test case, initialize the memory array $M$ to the given contents.\n- Compute $\\alpha_p = a+i$ and $\\alpha_q = b+j$. Assert that both lie in $\\{0, 1, \\dots, L-1\\}$.\n- Simulate the original sequence by copying $M$ into a working array and performing the operations to produce $\\sigma_2$.\n- Simulate the reordered sequence by copying $M$ into a second working array and performing the operations to produce $\\sigma'_2$.\n- Compute the boolean $s$ as $1$ if and only if the values at $\\alpha_p$ and $\\alpha_q$ are equal in both final states; otherwise, $s = 0$.\n- Compute the boolean $m$ as $1$ if and only if $\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1)$; otherwise, $m = 0$.\n- Output the results for all test cases in the required single-line format $[[s_1,m_1],[s_2,m_2],\\dots,[s_T,m_T]]$.\n\nApplying this to the five test cases in the problem:\n- Case $1$: $\\alpha_p = 1$, $\\alpha_q = 7$, disjoint ranges, $s = 1$, $m = 0$.\n- Case $2$: $\\alpha_p = 3$, $\\alpha_q = 3$, overlapping ranges with identical addresses, $s = 0$, $m = 1$.\n- Case $3$: $\\alpha_p = 2$, $\\alpha_q = 7$, overlapping ranges but different addresses, $s = 1$, $m = 1$.\n- Case $4$: $\\alpha_p = 4$, $\\alpha_q = 5$, adjacent disjoint ranges, $s = 1$, $m = 0$.\n- Case $5$: $\\alpha_p = 4$, $\\alpha_q = 4$, identical ranges with identical addresses, $s = 0$, $m = 1$.\n\nThese results concretely validate that load/store reordering must respect may-alias relations: when may-alias is true, performing the reordering can produce different semantics in cases where $\\alpha_p = \\alpha_q$, and a conservative compiler will avoid the transformation unless it can prove non-aliasing.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int *mem;   // pointer to initial memory contents\n    int L;      // memory length\n    int a;      // base index of array A\n    int nA;     // length of array A\n    int b;      // base index of array B\n    int nB;     // length of array B\n    int i;      // index into array A (for p)\n    int j;      // index into array B (for q)\n    int c;      // constant added in the store to *q\n} TestCase;\n\n// Simulate the original and reordered sequences and return 1 if they produce the same final values\n// at the affected addresses, otherwise 0.\nstatic int simulate_safety(const TestCase *tc) {\n    int L = tc->L;\n    // Copy the initial memory into two working arrays.\n    int *orig = (int *)malloc(sizeof(int) * L);\n    int *reord = (int *)malloc(sizeof(int) * L);\n    if (!orig || !reord) {\n        // In a constrained environment, simply treat allocation failure as unsafe.\n        free(orig);\n        free(reord);\n        return 0;\n    }\n    memcpy(orig, tc->mem, sizeof(int) * L);\n    memcpy(reord, tc->mem, sizeof(int) * L);\n\n    // Compute the absolute addresses for p and q.\n    int p_idx = tc->a + tc->i;\n    int q_idx = tc->b + tc->j;\n\n    // Bounds check to ensure indices are valid; if invalid, mark unsafe and clean up.\n    if (p_idx < 0 || p_idx >= L || q_idx < 0 || q_idx >= L) {\n        free(orig);\n        free(reord);\n        return 0;\n    }\n\n    // Original sequence:\n    int v1 = orig[p_idx];\n    int v2 = orig[q_idx];\n    orig[q_idx] = v2 + tc->c;\n    orig[p_idx] = v1 + v2;\n\n    // Reordered sequence (store to *q moved before load from *p):\n    int v2b = reord[q_idx];\n    reord[q_idx] = v2b + tc->c;\n    int v1b = reord[p_idx];\n    reord[p_idx] = v1b + v2b;\n\n    // Compare the final values at the affected addresses.\n    int same = (orig[p_idx] == reord[p_idx]) && (orig[q_idx] == reord[q_idx]) ? 1 : 0;\n\n    free(orig);\n    free(reord);\n    return same;\n}\n\n// Compute may-alias: whether the ranges [a, a+nA-1] and [b, b+nB-1] overlap.\nstatic int may_alias_ranges(int a, int nA, int b, int nB) {\n    int start_max = (a > b) ? a : b;\n    int end_min = ((a + nA - 1) < (b + nB - 1)) ? (a + nA - 1) : (b + nB - 1);\n    return (start_max <= end_min) ? 1 : 0;\n}\n\nint main(void) {\n    // Define the initial memory contents for each test case.\n    static int mem1[] = {10,20,30,40,50,60,70,80,90,100};\n    static int mem2[] = {1,3,5,7,9,11,13,15,17,19};\n    static int mem3[] = {2,4,6,8,10,12,14,16,18,20};\n    static int mem4[] = {0,1,2,3,4,5,6,7,8,9};\n    static int mem5[] = {9,8,7,6,5,4,3,2,1,0};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        // Case 1: Disjoint arrays, p=1, q=7\n        { mem1, 10, 0, 4, 5, 4, 1, 2, 3 },\n        // Case 2: Overlap and same address, p=q=3\n        { mem2, 10, 2, 4, 3, 4, 1, 0, 4 },\n        // Case 3: Partial overlap but different addresses, p=2, q=7\n        { mem3, 10, 2, 5, 4, 5, 0, 3, 5 },\n        // Case 4: Adjacent disjoint arrays, p=4, q=5\n        { mem4, 10, 0, 5, 5, 5, 4, 0, 2 },\n        // Case 5: Identical ranges and same address, p=q=4\n        { mem5, 10, 1, 7, 1, 7, 3, 3, 1 }\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = (int)(sizeof(test_cases) / sizeof(test_cases[0]));\n    // Prepare result arrays.\n    int safe[num_cases];\n    int may[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        safe[i] = simulate_safety(&test_cases[i]);\n        may[i] = may_alias_ranges(test_cases[i].a, test_cases[i].nA, test_cases[i].b, test_cases[i].nB);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    // Format: [[s1,m1],[s2,m2],...]\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%d,%d]\", safe[i], may[i]);\n        if (i + 1 < num_cases) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}