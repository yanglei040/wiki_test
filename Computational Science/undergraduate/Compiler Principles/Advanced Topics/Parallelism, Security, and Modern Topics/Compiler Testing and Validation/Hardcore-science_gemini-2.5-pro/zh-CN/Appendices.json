{
    "hands_on_practices": [
        {
            "introduction": "许多高级优化依赖于对程序中数据流动的精确理解，而数据流分析为此提供了理论基础。本练习将重点从实现分析本身转移到验证其结果的正确性。你将通过检查给定的活跃变量集是否在整个控制流图上满足其数据流方程，来测试编译器静态分析阶段的可靠性。",
            "id": "3629971",
            "problem": "您的任务是遵循编译器测试与验证的数学原理，对一组控制流图（CFG）上的后向数据流活跃性分析进行验证。控制流图（CFG）是一种有向图，其节点代表程序点（基本块或语句），边代表可能的控制流转换。对于一个节点 $n$，其后继节点集合表示为 $\\mathrm{succ}(n)$。活跃性分析为每个节点 $n$ 附加了两组变量集合：$LIVE\\_IN[n]$ 和 $LIVE\\_OUT[n]$。每个节点 $n$ 也拥有集合 $USE[n]$（在任何重定义之前读取的变量）和 $DEF[n]$（在该节点中定义的变量）。变量从一个有限的全域集合 $\\{v_0, v_1, \\dots, v_{K-1}\\}$ 中选取。\n\n后向活跃性分析的基本定义如下：\n- $LIVE\\_OUT[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} LIVE\\_IN[s]$,\n- $LIVE\\_IN[n] = USE[n] \\cup \\left(LIVE\\_OUT[n] \\setminus DEF[n]\\right)$.\n\n您的程序必须为每个提供的测试用例验证，候选集合 $LIVE\\_IN/LIVE\\_OUT$ 是否在CFG中的每个节点上同时满足这些方程。每个测试用例包括：\n- 节点数 $N$ 和变量数 $K$，\n- 每个节点 $n \\in \\{0,1,\\dots,N-1\\}$ 的后继列表 $\\mathrm{succ}(n)$，\n- $USE[n]$ 和 $DEF[n]$ 集合，\n- 候选的 $LIVE\\_IN[n]$ 和 $LIVE\\_OUT[n]$ 集合。\n\n您的程序应生成一行输出，包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，若所有方程都满足，则使用 $1$ 表示真，否则使用 $0$ 表示假。不允许有其他输出。\n\n测试套件（所有集合都是 $\\{v_0, v_1, \\dots\\}$ 的子集，所有节点索引都是 $\\{0,\\dots,N-1\\}$ 中的整数）：\n\n- 测试用例 1（分支与汇合）：\n  - $N = 4$, $K = 3$。\n  - 后继节点：\n    - $\\mathrm{succ}(0) = [\\,1, 2\\,]$,\n    - $\\mathrm{succ}(1) = [\\,3\\,]$,\n    - $\\mathrm{succ}(2) = [\\,3\\,]$,\n    - $\\mathrm{succ}(3) = [\\,]$。\n  - 集合：\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{v_0\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{v_1\\}$,\n    - $USE[2] = \\{\\}$, $DEF[2] = \\{v_0\\}$,\n    - $USE[3] = \\{v_1\\}$, $DEF[3] = \\{\\}$。\n  - 候选活跃性集合：\n    - $LIVE\\_IN[0] = \\{v_1\\}$, $LIVE\\_OUT[0] = \\{v_0,v_1\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{v_1\\}$,\n    - $LIVE\\_IN[2] = \\{v_1\\}$, $LIVE\\_OUT[2] = \\{v_1\\}$,\n    - $LIVE\\_IN[3] = \\{v_1\\}$, $LIVE\\_OUT[3] = \\{\\}$。\n\n- 测试用例 2（与测试用例1使用相同的CFG；$LIVE\\_OUT[0]$ 故意设置错误）：\n  - $N = 4$, $K = 3$。\n  - 后继节点：与测试用例1相同。\n  - 集合：与测试用例1相同。\n  - 候选活跃性集合：\n    - $LIVE\\_IN[0] = \\{v_1\\}$, $LIVE\\_OUT[0] = \\{v_0\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{v_1\\}$,\n    - $LIVE\\_IN[2] = \\{v_1\\}$, $LIVE\\_OUT[2] = \\{v_1\\}$,\n    - $LIVE\\_IN[3] = \\{v_1\\}$, $LIVE\\_OUT[3] = \\{\\}$。\n\n- 测试用例 3（边界情况：出口节点使用一个变量）：\n  - $N = 2$, $K = 1$。\n  - 后继节点：\n    - $\\mathrm{succ}(0) = [\\,1\\,]$,\n    - $\\mathrm{succ}(1) = [\\,]$。\n  - 集合：\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{\\}$。\n  - 候选活跃性集合：\n    - $LIVE\\_IN[0] = \\{v_0\\}$, $LIVE\\_OUT[0] = \\{v_0\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{\\}$。\n\n- 测试用例 4（带汇合和出口的循环）：\n  - $N = 4$, $K = 3$。\n  - 后继节点：\n    - $\\mathrm{succ}(0) = [\\,1\\,]$,\n    - $\\mathrm{succ}(1) = [\\,2\\,]$,\n    - $\\mathrm{succ}(2) = [\\,1, 3\\,]$,\n    - $\\mathrm{succ}(3) = [\\,]$。\n  - 集合：\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{v_0\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{v_1\\}$,\n    - $USE[2] = \\{v_1\\}$, $DEF[2] = \\{\\}$,\n    - $USE[3] = \\{v_2\\}$, $DEF[3] = \\{\\}$。\n  - 候选活跃性集合：\n    - $LIVE\\_IN[0] = \\{v_2\\}$, $LIVE\\_OUT[0] = \\{v_0,v_2\\}$,\n    - $LIVE\\_IN[1] = \\{v_0,v_2\\}$, $LIVE\\_OUT[1] = \\{v_0,v_1,v_2\\}$,\n    - $LIVE\\_IN[2] = \\{v_0,v_1,v_2\\}$, $LIVE\\_OUT[2] = \\{v_0,v_2\\}$,\n    - $LIVE\\_IN[3] = \\{v_2\\}$, $LIVE\\_OUT[3] = \\{\\}$。\n\n- 测试用例 5（带有不可达节点的边缘情况）：\n  - $N = 3$, $K = 2$。\n  - 后继节点：\n    - $\\mathrm{succ}(0) = [\\,1\\,]$,\n    - $\\mathrm{succ}(1) = [\\,]$,\n    - $\\mathrm{succ}(2) = [\\,]$。\n  - 集合：\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{v_1\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{\\}$,\n    - $USE[2] = \\{v_1\\}$, $DEF[2] = \\{\\}$。\n  - 候选活跃性集合：\n    - $LIVE\\_IN[0] = \\{v_0\\}$, $LIVE\\_OUT[0] = \\{v_0\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{\\}$,\n    - $LIVE\\_IN[2] = \\{v_1\\}$, $LIVE\\_OUT[2] = \\{\\}$。\n\n您的程序必须在内部构造这些测试用例（无输入），并为每个测试用例检查以上两个方程是否对每个节点都成立。要求的输出是一行包含 $N_{tests}$ 个整数的列表，每个测试用例一个，按顺序排列。当所有节点都满足两个方程时使用 $1$，否则使用 $0$，并严格按照 $[r_1,r_2,\\dots,r_{N_{tests}}]$ 的格式打印。",
            "solution": "用户提供了一个问题，要求对几个控制流图（CFG）的活跃性分析结果进行验证。\n\n### 第1步：提取已知条件\n- **任务**：对于给定的一组测试用例，根据后向活跃性分析的基本数据流方程，验证候选的活跃性集合（$LIVE\\_IN$，$LIVE\\_OUT$）。\n- **活跃性分析方程**：\n  1. $LIVE\\_OUT[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} LIVE\\_IN[s]$\n  2. $LIVE\\_IN[n] = USE[n] \\cup \\left(LIVE\\_OUT[n] \\setminus DEF[n]\\right)$\n- **定义**：\n  - $n$：CFG中的一个节点，来自集合 $\\{0, 1, \\dots, N-1\\}$。\n  - $\\mathrm{succ}(n)$：节点 $n$ 的后继节点集合。\n  - $USE[n]$：在节点 $n$ 中，先于定义而被使用的变量集合。\n  - $DEF[n]$：在节点 $n$ 中被定义的变量集合。\n  - 变量：来自有限的全域集合 $\\{v_0, v_1, \\dots, v_{K-1}\\}$。\n- **输出格式**：单行输出，包含一个用方括号括起来的逗号分隔列表，其中包含每个测试用例的验证结果（$1$ 为真，$0$ 为假）。例如：`[1,0,1,...]`。\n- **测试用例**：提供了五个测试用例，每个都指定了节点数 $N$、变量数 $K$、每个节点的后继列表、每个节点的 $USE$ 和 $DEF$ 集合，以及每个节点的候选 $LIVE\\_IN$ 和 $LIVE\\_OUT$ 集合。\n\n### 第2步：使用已知条件进行验证\n- **科学严谨性**：该问题植根于编译器理论，这是计算机科学的核心领域。CFG的定义和活跃性分析的数据流方程都是该领域的标准、正确且基础的内容。该问题是科学合理的。\n- **适定性**：任务是根据一对明确的数学方程来验证一组给定的数据。对于每个测试用例中的每个节点，所有必要的数据都已提供。验证过程是确定性的：计算每个方程的右侧，并与给定的左侧进行比较。每个测试用例都存在一个唯一且明确的布尔结果（真/假）。该问题是适定的。\n- **客观性**：问题使用形式化的数学符号陈述，并提供了具体的、客观的数据。验证的标准是由方程定义的集合的严格相等。不存在任何模糊性或主观性。\n- **完整性与一致性**：每个测试用例的所有必要组件（$N, K$, 后继列表, $USE, DEF, LIVE\\_IN, LIVE\\_OUT$ 集合）都已完全指定。不存在矛盾之处。\n- **可行性**：测试用例涉及小型图和少量变量，使其在计算上非常简单，非常适合作为示例程序。\n\n### 第3步：结论与行动\n该问题是**有效**的。这是一个来自编译器设计领域，定义明确、科学严谨且客观的问题。我将继续提供解决方案。\n\n### 基于原则的设计\n该解决方案将通过系统地将后向活跃性分析的两个基本方程应用于每个测试用例CFG中的每个节点，来验证所提供的活跃性分析数据。\n\n**1. 数据表示：**\n变量集合（$USE$, $DEF$, $LIVE\\_IN$, $LIVE\\_OUT$）是小的有限全域集合 $\\{v_0, v_1, \\dots, v_{K-1}\\}$ 的子集。这种结构非常适合使用位掩码表示。一个集合将由一个整数表示，如果变量 $v_i$ 在集合中，则第 $i$ 位为 $1$，否则为 $0$。这允许使用位运算逻辑进行高效的集合操作：\n- **集合并集 ($A \\cup B$)**：实现为按位或（`A | B`）。\n- **集合交集 ($A \\cap B$)**：实现为按位与（`A  B`）。\n- **集合差集 ($A \\setminus B$)**：实现为 `A  (~B)`，其中 `~` 是按位非运算符。\n\n**2. CFG与测试用例结构：**\n为了组织每个测试用例的数据，将使用 `struct` 的层次结构：\n- 一个 `Node` 结构体将封装单个节点的所有数据：其 $USE$、$DEF$、$LIVE\\_IN$ 和 $LIVE\\_OUT$ 集合（作为整数位掩码）、其后继节点的数量以及一个指向后继节点索引数组的指针。\n- 一个 `TestCase` 结构体将代表一个完整的测试场景，包含节点数 $N$、变量数 $K$ 以及一个指向 `Node` 结构体数组的指针。\n\n**3. 验证算法：**\n将创建一个函数 `validate_test_case` 来确定单个测试用例的有效性。该函数将遍历从 $0$ 到 $N-1$ 的每个节点 $n$，并执行两次检查：\n\n- **检查1：$LIVE\\_OUT[n]$ 验证**\n  方程为 $LIVE\\_OUT[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} LIVE\\_IN[s]$。\n  为验证这一点，算法将通过初始化一个空集（值为 $0$ 的整数）来计算方程的右侧，然后遍历节点 $n$ 的所有后继节点 $s$。在每次迭代中，它与 `LIVE_IN[s]` 执行按位或运算。最终结果将与提供的 `LIVE_OUT[n]`进行比较。\n\n- **检查2：$LIVE\\_IN[n]$ 验证**\n  方程为 $LIVE\\_IN[n] = USE[n] \\cup (LIVE\\_OUT[n] \\setminus DEF[n])$。\n  算法分两步计算方程的右侧。首先，它使用位运算 `LIVE_OUT[n]  (~DEF[n])` 计算集合差 $LIVE\\_OUT[n] \\setminus DEF[n]$。其次，它使用按位或运算将此结果与 $USE[n]$ 求并集。这个最终计算出的值将与提供的 `LIVE_IN[n]` 进行比较。\n\n如果这些检查中的任何一个对于CFG中的任何节点失败，则整个测试用例被视为无效，函数返回 $0$。如果所有节点的所有检查都通过，则测试用例有效，函数返回 $1$。\n\n**4. 主执行逻辑：**\n`main` 函数将静态定义问题中指定的五个测试用例的所有数据。这些定义将用于初始化一个 `TestCase` 结构体数组。然后，程序将遍历此数组，为每个测试用例调用 `validate_test_case`，并存储结果 $0$ 或 $1$。最后，它将按照指定的格式 `[r_1,r_2,r_3,r_4,r_5]` 将收集到的结果打印到标准输出。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include"
        },
        {
            "introduction": "优化内存访问对性能至关重要，但由于指针别名的存在，这类优化充满了风险。本练习将通过模拟一个有争议的指令重排序优化，来演示如何测试内存优化的安全性。通过比较优化前后的最终内存状态，你可以直接验证该变换是否保持了程序的语义，并理解别名分析在其中扮演的关键角色。",
            "id": "3630025",
            "problem": "给定一个语言的单线程确定性执行模型，其中内存被建模为一个有限的整数数组。设内存状态为一个全函数 $\\sigma : \\{0, 1, \\dots, L-1\\} \\to \\mathbb{Z}$，其中 $L$ 是内存长度。考虑两个数组 $A$ 和 $B$，它们表示为同一底层内存 $M$ 的连续子区域，基址分别为 $a$ 和 $b$，长度分别为 $n_A$ 和 $n_B$。数组 $A$ 占据地址 $\\{a, a+1, \\dots, a+n_A-1\\}$，数组 $B$ 占据地址 $\\{b, b+1, \\dots, b+n_B-1\\}$。两个指针 $p$ 和 $q$ 分别指向 $A$ 和 $B$ 中的逻辑索引 $i$ 和 $j$，因此 $p$ 指向地址 $a+i$，$q$ 指向地址 $b+j$。设 $c$ 为一个固定的整数常量。\n\n在此模型中，原始程序片段按程序顺序执行以下操作序列：\n1. $v_1 := *p$,\n2. $v_2 := *q$,\n3. $*q := v_2 + c$,\n4. $*p := v_1 + v_2$.\n\n优化器可能会尝试重排加载/存储操作。被测试的重排将对 $*q$ 的存储操作提前到从 $*p$ 加载的操作之前，产生以下序列：\n1. $v_2 := *q$,\n2. $*q := v_2 + c$,\n3. $v_1 := *p$,\n4. $*p := v_1 + v_2$.\n\n别名分析（alias analysis）的目的是保守地确定内存引用之间的关系。定义：\n- $p$ 和 $q$ 之间存在“可能别名”（may-alias），当且仅当 $A$ 和 $B$ 的子区域重叠时为真，即 $\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1)$。\n- “必不别名”（must-not-alias），当且仅当子区域不重叠时为真，即 $\\max(a, b)  \\min(a+n_A-1, b+n_B-1)$。\n\n在单线程顺序语义下，当且仅当对于所有输入，最终的内存状态和产生的值都相等时，一个重排才是语义保持的（semantics-preserving）。从第一性原理出发，只有当一个存储操作不会改变某个加载操作所观察到的值时，该存储操作才能被提前到该加载操作之前。在本例中，这当且仅当地址 $a+i$ 和 $b+j$ 不同时成立。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 对每个给定的测试用例，使用给定的初始内容 $\\sigma$ 和参数 $(L, a, n_A, b, n_B, i, j, c)$ 构建内存 $M$。\n- 通过模拟原始序列和重排后序列，并比较受影响地址处的最终内容，计算一个布尔值 $s$，表示上述重排对于特定的指针 $p$ 和 $q$ 是否是语义保持的。\n- 仅根据 $A$ 和 $B$ 的子区域是否重叠 $(\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1))$，计算一个布尔值 $m$，表示它们是否存在“可能别名”。\n- 生成一行输出，其中包含结果。结果是一个由方括号括起来的逗号分隔的 $[s, m]$ 对列表，所有布尔值都打印为整数（$0$ 表示 false，$1$ 表示 true）。格式必须严格如下：\n$[[s_1,m_1],[s_2,m_2],\\dots,[s_T,m_T]]$\n其中 $T$ 是测试用例的数量。\n\n测试套件：\n使用以下五个测试用例。在每个用例中，$L=10$ 且 $M$ 按给定值初始化。所有索引都是从零开始的。$L, a, n_A, b, n_B, i, j, c$ 的值出现在内存初始化器后面的括号中。\n\n1. $M = [10,20,30,40,50,60,70,80,90,100]$, $(L=10, a=0, n_A=4, b=5, n_B=4, i=1, j=2, c=3)$。数组不相交，$p$ 指向地址 $1$，$q$ 指向地址 $7$。\n2. $M = [1,3,5,7,9,11,13,15,17,19]$, $(L=10, a=2, n_A=4, b=3, n_B=4, i=1, j=0, c=4)$。数组重叠，且 $p$ 和 $q$ 指向同一地址 $3$。\n3. $M = [2,4,6,8,10,12,14,16,18,20]$, $(L=10, a=2, n_A=5, b=4, n_B=5, i=0, j=3, c=5)$。数组部分重叠；$p$ 指向地址 $2$，$q$ 指向地址 $7$。\n4. $M = [0,1,2,3,4,5,6,7,8,9]$, $(L=10, a=0, n_A=5, b=5, n_B=5, i=4, j=0, c=2)$。数组相邻但不相交；$p$ 指向地址 $4$，$q$ 指向地址 $5$。\n5. $M = [9,8,7,6,5,4,3,2,1,0]$, $(L=10, a=1, n_A=7, b=1, n_B=7, i=3, j=3, c=1)$。数组相同；$p$ 和 $q$ 都指向地址 $4$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表，每个测试用例贡献一对 $[s,m]$，其中 $s$ 和 $m$ 是整数 $0$ 或 $1$。例如，对于三个用例，输出将类似于 $[[1,0],[0,1],[1,1]]$。你的程序必须为上述五个测试用例严格按照此格式生成一行输出。",
            "solution": "我们从单线程顺序程序语义的原理和别名分析的核心定义来推导给定重排的安全性。\n\n设内存状态是一个定义在地址集 $\\mathcal{A} = \\{0, 1, \\dots, L-1\\}$ 上的函数 $\\sigma : \\mathcal{A} \\to \\mathbb{Z}$。从地址 $\\alpha \\in \\mathcal{A}$ 加载的操作语义产生值 $\\sigma(\\alpha)$ 并且不改变状态。将值 $w \\in \\mathbb{Z}$ 存储到地址 $\\alpha$ 的语义产生一个新状态 $\\sigma'$，使得 $\\sigma'(\\alpha) = w$ 且 $\\forall \\beta \\neq \\alpha, \\sigma'(\\beta) = \\sigma(\\beta)$。在单线程程序中，语义是顺序的：程序作为一系列状态转换来执行，其中加载操作观察当前状态，存储操作更新状态。\n\n定义地址 $\\alpha_p = a+i$ 和 $\\alpha_q = b+j$。原始序列执行如下：\n1. $v_1 := \\sigma(\\alpha_p)$,\n2. $v_2 := \\sigma(\\alpha_q)$,\n3. $\\sigma_1 := \\sigma[\\alpha_q \\mapsto (v_2 + c)]$,\n4. $\\sigma_2 := \\sigma_1[\\alpha_p \\mapsto (v_1 + v_2)]$.\n\n重排后的序列执行如下：\n1. $v_2' := \\sigma(\\alpha_q)$,\n2. $\\sigma'_1 := \\sigma[\\alpha_q \\mapsto (v_2' + c)]$,\n3. $v_1' := \\sigma'_1(\\alpha_p)$,\n4. $\\sigma'_2 := \\sigma'_1[\\alpha_p \\mapsto (v_1' + v_2')]$.\n\n我们比较 $\\sigma_2$ 和 $\\sigma'_2$ 来确定语义是否保持。考虑两种情况：\n\n情况 1：$\\alpha_p \\neq \\alpha_q$。在原始序列中，步骤 3 中对 $\\alpha_q$ 的存储不影响步骤 1 中从 $\\alpha_p$ 读取的值，因为加载发生在存储之前。在重排后的序列中，对 $\\alpha_q$ 的存储发生在从 $\\alpha_p$ 加载之前，但由于 $\\alpha_p \\neq \\alpha_q$，$\\alpha_p$ 处的值不受对 $\\alpha_q$ 的存储影响。因此，$v_1' = \\sigma(\\alpha_p) = v_1$，$v_2' = \\sigma(\\alpha_q) = v_2$，并且最终的赋值是相同的：$\\sigma_2(\\alpha_q) = v_2 + c = \\sigma'_2(\\alpha_q)$ 且 $\\sigma_2(\\alpha_p) = v_1 + v_2 = \\sigma'_2(\\alpha_p)$，所有其他地址的值也相等。因此，当 $\\alpha_p \\neq \\alpha_q$ 时，该重排是语义保持的。\n\n情况 2：$\\alpha_p = \\alpha_q$。在原始序列中，我们有：\n- $v_1 = \\sigma(\\alpha_p)$,\n- $v_2 = \\sigma(\\alpha_p)$,\n- 在步骤 3 之后，$\\sigma_1(\\alpha_p) = v_2 + c$,\n- 在步骤 4 之后，$\\sigma_2(\\alpha_p) = v_1 + v_2$.\n\n在重排后的序列中：\n- $v_2' = \\sigma(\\alpha_p)$,\n- 在步骤 2 之后，$\\sigma'_1(\\alpha_p) = v_2' + c$,\n- 然后 $v_1' = \\sigma'_1(\\alpha_p) = v_2' + c$,\n- 在步骤 4 之后，$\\sigma'_2(\\alpha_p) = v_1' + v_2' = (v_2' + c) + v_2' = 2 v_2' + c$.\n\n比较 $\\alpha_p$ 处的最终值，在原始序列中我们有 $\\sigma_2(\\alpha_p) = v_1 + v_2 = 2 \\sigma(\\alpha_p)$（因为 $v_1 = v_2 = \\sigma(\\alpha_p)$），而在重排后的序列中我们有 $\\sigma'_2(\\alpha_p) = 2 \\sigma(\\alpha_p) + c$。由于 $c$ 通常为非零，因此状态不同。即使 $c = 0$，序列在中间观察值上仍有差异，并且通常该转换是不安全的，因为它改变了在 $\\alpha_p$ 处加载操作读取的值。因此，当 $\\alpha_p = \\alpha_q$ 时，该重排不是语义保持的。\n\n此分析表明，被测重排的正确性的充要条件是 $\\alpha_p \\neq \\alpha_q$。从别名分析的角度来看，一个保守的“可能别名”（may-alias）结果表明在运行时地址可能相等。在针对数组 $A$ 和 $B$ 的表述中，“可能别名”被定义为 $A$ 和 $B$ 的子区域重叠：$\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1)$。如果“可能别名”为真，一个遵循别名分析的编译器就不能应用此重排，因为它在没有更多信息的情况下无法保证对所有执行都有 $\\alpha_p \\neq \\alpha_q$。如果“必不别名”（must-not-alias）为真（无重叠），那么对于任何在边界内的有效 $i$ 和 $j$，$\\alpha_p \\neq \\alpha_q$ 都成立，该重排是安全的。\n\n程序算法设计：\n- 对每个测试用例，将内存数组 $M$ 初始化为给定内容。\n- 计算 $\\alpha_p = a+i$ 和 $\\alpha_q = b+j$。断言两者都位于 $\\{0, 1, \\dots, L-1\\}$ 内。\n- 通过将 $M$ 复制到一个工作数组中并执行操作来模拟原始序列，以产生 $\\sigma_2$。\n- 通过将 $M$ 复制到第二个工作数组中并执行操作来模拟重排后的序列，以产生 $\\sigma'_2$。\n- 计算布尔值 $s$：当且仅当在两个最终状态中 $\\alpha_p$ 和 $\\alpha_q$ 处的值相等时为 $1$；否则为 $0$。\n- 计算布尔值 $m$：当且仅当 $\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1)$ 时为 $1$；否则为 $0$。\n- 以所需的单行格式 $[[s_1,m_1],[s_2,m_2],\\dots,[s_T,m_T]]$ 输出所有测试用例的结果。\n\n将此应用于问题中的五个测试用例：\n- 用例 1：$\\alpha_p = 1$, $\\alpha_q = 7$，区域不相交，$s = 1$, $m = 0$。\n- 用例 2：$\\alpha_p = 3$, $\\alpha_q = 3$，区域重叠且地址相同，$s = 0$, $m = 1$。\n- 用例 3：$\\alpha_p = 2$, $\\alpha_q = 7$，区域重叠但地址不同，$s = 1$, $m = 1$。\n- 用例 4：$\\alpha_p = 4$, $\\alpha_q = 5$，区域相邻但不相交，$s = 1$, $m = 0$。\n- 用例 5：$\\alpha_p = 4$, $\\alpha_q = 4$，区域相同且地址相同，$s = 0$, $m = 1$。\n\n这些结果具体验证了加载/存储重排必须遵循“可能别名”关系：当“可能别名”为真时，在 $\\alpha_p = \\alpha_q$ 的情况下执行重排可能会产生不同的语义，保守的编译器会避免这种转换，除非它能证明不存在别名。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include"
        }
    ]
}