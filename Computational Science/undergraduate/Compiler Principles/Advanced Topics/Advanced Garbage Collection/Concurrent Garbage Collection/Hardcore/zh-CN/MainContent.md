## 引言
在现代软件开发中，[自动内存管理](@entry_id:746589)，即垃圾回收（GC），已成为不可或缺的一环，它将开发者从繁琐的手动内存管理中解放出来。然而，传统的垃圾回收技术常常需要“冻结”整个应用程序，即“stop-the-world”（STW）暂停，这在对响应能力要求极高的交互式应用和在线服务中是不可接受的。本文旨在深入探讨并发[垃圾回收](@entry_id:637325)技术，这是一种旨在最大限度减少甚至消除STW暂停的高级内存管理方法。通过允许[垃圾回收](@entry_id:637325)器与应用程序线程同时运行，并发GC带来了显著的性能优势，但同时也引入了确保[数据一致性](@entry_id:748190)和正确性的严峻挑战。

为了系统地掌握这一复杂主题，我们将分三个章节展开：首先，在“原理与机制”中，我们将深入并发GC的理论核心，揭示三色抽象[不变量](@entry_id:148850)如何成为正确性的基石，并探讨[写屏障](@entry_id:756777)和[读屏障](@entry_id:754124)等关键技术如何维护这一[不变量](@entry_id:148850)。接着，在“应用与跨学科连接”部分，我们将视野拓宽至整个系统生态，考察并发GC如何与编译器、[操作系统](@entry_id:752937)乃至硬件架构协同工作，并探索其思想在数据库和分布式系统等领域的惊人应用。最后，“动手实践”部分将提供一系列精心设计的练习，帮助你将理论知识转化为解决实际问题的能力，从根本上理解并发GC的正确性、性能成本与可伸缩性。让我们开始探索如何在动态和并发的世界中，实现既高效又安全的[自动内存管理](@entry_id:746589)。

## 原理与机制

在上一章中，我们介绍了垃圾回收（GC）在现代编程语言[运行时环境](@entry_id:754454)中的关键作用。本章将深入探讨并发[垃圾回收](@entry_id:637325)的核心原理与机制。并发GC旨在最大限度地减少或消除因[垃圾回收](@entry_id:637325)而导致应用程序暂停的“stop-the-world”（STW）现象，从而提高响应能力和用户体验。然而，允许应用程序（**mutator**）与[垃圾回收](@entry_id:637325)器（**collector**）同时运行，引入了根本性的挑战：收集器如何在mutator不断修改对象图的同时，安全、准确地识别并回收不再使用的内存？本章将系统地阐述解决这一挑战的关键技术。

### 三色抽象：并发标记的理论基础

为了在并发环境中正确地追踪存活对象，我们需要一个形式化的模型来描述标记过程的状态。**三色抽象** (tri-color abstraction) 就是为此而生的理论框架。它将堆中的所有对象逻辑上划分为三个集合：

*   **白色 (White)**：对象尚未被收集器访问。在标记阶段开始时，除根对象（roots）外，所有对象均为白色。在标记阶段结束时，所有剩余的白色对象都被视作垃圾。

*   **灰色 (Gray)**：对象已被收集器访问到，但其引用的子对象尚未被完全扫描。灰色对象是待处理工作队列的抽象表示。

*   **黑色 (Black)**：对象已被收集器访问，并且其所有子对象也已被完全扫描。

垃圾收集器的标记过程可以被看作是将对象从白色集合移动到灰色集合，再从灰色集合移动到黑色集合的过程。该过程从**根集合**（roots，例如全局变量和线程栈上的指针）开始，根对象首先被置为灰色。随后，收集器不断地从灰色集合中取出一个对象，扫描其所有子对象，将遇到的白色子对象置为灰色，然后将该对象自身置为黑色。当灰色集合为空时，标记阶段完成。

这个过程的核心是维护一个至关重要的[不变量](@entry_id:148850)——**三色[不变量](@entry_id:148850)** (tri-color invariant)：**在任何时候，不存在从黑色对象到白色对象的直接指针**。

为什么这个[不变量](@entry_id:148850)如此重要？想象一下如果违反了这个[不变量](@entry_id:148850)：一个黑色对象 `b` 引用了一个白色对象 `w`。由于 `b` 已经是黑色的，收集器认为其扫描工作已经完成，将不会再次访问它。因此，收集器将永远无法通过 `b` 发现 `w`。如果不存在其他从灰色对象到 `w` 的路径，`w` 将在标记结束后保持白色，并被错误地回收，即使它实际上是可达的。这就是所谓的“丢失对象”问题，是并发GC必须避免的致命错误。

在单线程的STW回收器中，三色[不变量](@entry_id:148850)天然成立，因为mutator被完全冻结。但在并发GC中，mutator的指针写操作可能会随时破坏这个[不变量](@entry_id:148850)。因此，我们需要一种机制来在mutator和collector之间进行协调，这种机制就是**屏障** (barriers)。

### 屏障技术：维护[不变量](@entry_id:148850)的关键

屏障是在mutator执行特定操作（主要是指针写入）时插入的一小段额外代码，其目的是监测并响应可能破坏三色[不变量](@entry_id:148850)的行为。主要有两种屏障策略：[增量更新](@entry_id:750602)屏障和快照-起始屏障。

#### [增量更新](@entry_id:750602)[写屏障](@entry_id:756777) (Incremental-Update Write Barrier)

[增量更新](@entry_id:750602)策略，也称为Dijkstra风格屏障，其核心思想是“修复”即将被破坏的[不变量](@entry_id:148850)。当mutator试图执行一个 `b.f = w` 的写操作，而 `b` 是黑色对象，`w` 是白色对象时，[写屏障](@entry_id:756777)会介入。

最直接的修复方式是防止 `w` 在被 `b` 引用后仍为白色。屏障会在指针写入发生之前或之后，将 `w` 的颜色从白色变为灰色。这确保了 `(black) -> (white)` 的边不会形成，取而代之的是一条允许存在的 `(black) -> (gray)` 边。被置为灰色的 `w` 会被添加到标记工作队列中，确保收集器最终会处理它。这种屏障被称为**目标屏障** (destination barrier)，因为它作用于指针写入的目标对象 。

这种屏障的逻辑可以概括为：在赋值操作 `$o_1.f \leftarrow o_2$` 发生时，如果 `$c(o_1)=\mathsf{B}$`（黑色）且 `$c(o_2)=\mathsf{W}$`（白色），则屏障必须将 `$o_2$` 变为灰色（`$c(o_2)\leftarrow \mathsf{G}$`）并将其加入待处理队列。这是保持[不变量](@entry_id:148850)所需的最小工作，因为它只关注新建立的引用关系，避免了对 `$o_1$` 的重复扫描。

然而，一个看似简单的屏障实现可能会因为并发执行的时序问题而失败。考虑一个天真的**前置[写屏障](@entry_id:756777)** (pre-write barrier)，它只在源对象 *已经是* 黑色时才触发。这在源对象从灰色变为黑色的过程中存在一个危险的“[窗口期](@entry_id:196836)”。

考虑以下事件序列 ：
1.  mutator 准备执行 `$x.f := y$`，其中 `$x$` 是灰色（`$x \in G$`），`$y$` 是白色（`$y \in W$`）。屏障检查 `$x$` 的颜色，发现它不是黑色，因此不执行任何操作。
2.  此时，collector 线程介入。它扫描对象 `$x$`，发现其所有字段（包括 `$f$`）都为空，于是认为对 `$x$` 的扫描已完成，并将其颜色从灰色变为黑色。
3.  mutator 线程恢复执行，完成指针写入 `$x.f := y$`。
4.  最终状态是：`$x$` 是黑色，但它现在指向一个白色对象 `$y$`。三色[不变量](@entry_id:148850)被打破。由于 collector 不会再扫描黑色的 `$x$`，`$y$` 将被错误地回收。

这个例子揭示了[并发算法](@entry_id:635677)设计的复杂性。正确的屏障实现必须以原子方式或通过更复杂的协议来处理这种竞态条件，确保在 collector 将对象标记为黑色与 mutator 修改该对象之间不存在可乘之机。

#### 快照-起始[写屏障](@entry_id:756777) (Snapshot-At-The-Beginning Write Barrier)

与[增量更新](@entry_id:750602)屏障试图“修复”非法指针不同，**快照-起始** (SATB) 屏障采取了不同的哲学：它保证所有在GC周期开始那一刻（逻辑上的“快照”时间点 `$t_0$`）可达的对象都会被标记为存活，无论它们在标记过程中是否变得不可达。

为了实现这一点，SATB[写屏障](@entry_id:756777)监视指针的**覆盖**操作。当mutator执行 `$p.f = new\_obj$`，覆盖了字段 `$p.f$` 中原有的指针 `$old\_obj$` 时，SATB屏障会记录下被覆盖的旧值 `$old\_obj$`。通过将 `$old\_obj$` 及其可达的子图视为存活，收集器确保了即使连接到 `$old\_obj$` 的最后一条路径被切断，它也不会在[本轮](@entry_id:169326)GC中被回收。这种屏障被称为**源屏障** (source barrier)，因为它作用于指针写入的源位置。

SATB的一个显著后果是**浮动垃圾** (floating garbage) 的产生 。浮动垃圾指的是那些在快照时刻 `$t_0$` 是存活的，但在并发标记期间（时间间隔为 `$\Delta t$`）死掉的对象。由于SATB的保守策略，这些对象仍会被标记为存活并保留下来，直到下一次GC周期才能被回收。

我们可以对浮动垃圾的数量进行建模。假设对象的“死亡”是一个[无记忆过程](@entry_id:267313)，每个对象在单位时间内死亡的概率（[风险率](@entry_id:266388)）为常数 `$\mu$`。那么，任何一个在 `$t_0$` 时刻存活的对象，在 `$\Delta t$` 时间内死亡的概率是 `$1 - \exp(-\mu \Delta t)$`。这个概率也代表了在初始存活对象集合中，成为浮动垃圾的对象的预期比例 `$f(\Delta t, \mu)$` 。这意味着并发标记阶段持续时间越长（`$\Delta t$` 越大），产生的浮动垃圾就越多。

#### [读屏障](@entry_id:754124)与性能权衡

除了[写屏障](@entry_id:756777)，还有**[读屏障](@entry_id:754124)** (read barrier)，它在mutator每次读取指针时触发。[读屏障](@entry_id:754124)在某些类型的GC（尤其是移动式GC）中至关重要，它可以确保mutator在对象被移动后总能读取到对象的新地址。例如，Brooks风格的间接寻址技术通过在每个对象前设置一个转发指针，将[读屏障](@entry_id:754124)实现为一次无条件的额外内存解引用。

选择[读屏障](@entry_id:754124)还是[写屏障](@entry_id:756777)，涉及到深刻的性能权衡。对于一个读操作远多于写操作的应用程序（`$R \gg W$`），[写屏障](@entry_id:756777)的开销被分摊到较少的操作上，而[读屏障](@entry_id:754124)的开销则会影响到每一次读操作，累积起来可能非常巨大。反之，如果写操作非常昂贵（例如，由于需要昂贵的内存围栏或导致[缓存一致性](@entry_id:747053)流量），而[读屏障](@entry_id:754124)的实现非常轻量（例如，额外解引用总能命中L1缓存），那么即使读操作频繁，[读屏障](@entry_id:754124)也可能更优。

例如，在一个假设场景中，读写比为 `$100:1$` ：
*   在“Alpha配置”下，[写屏障](@entry_id:756777)成本极高（`$310$` 周期），而聚合的[读屏障](@entry_id:754124)成本较低（`$115$` 周期）。此时，采用Brooks风格的[读屏障](@entry_id:754124)更有利。
*   在“Beta配置”下，[写屏障](@entry_id:756777)成本极低（`$21$` 周期），而聚合的[读屏障](@entry_id:754124)成本则显著更高（`$230$` 周期）。此时，采用[写屏障](@entry_id:756777)的策略是明智的。

这表明，不存在普遍最优的屏障策略，最佳选择取决于工作负载特性和底层硬件[微架构](@entry_id:751960)。

### 根集合扫描：并发GC的另一大挑战

标记过程的起点是根集合，包括全局变量、CPU寄存器以及每个线程的[调用栈](@entry_id:634756)。在STW模式下，获取根集合很简单：停止所有线程，然后安全地扫描它们的栈和寄存器。但在并发GC中，如何在不长时间暂停线程的情况下获取一个一致的根集合快照，是一个极具挑战性的问题。

#### 安全点与时间-到-安全点问题

一种常见的协作式方法是**安全点** (safepoint)。安全点是代码中预设的一些位置，mutator线程在执行到这些位置时会检查一个全局标志。如果GC请求线程暂停，mutator会在此处保存状态、暴露其根给GC，然后进入等待状态。

然而，这种协作模型面临着“**时间-到-安全点**”(Time-To-Safepoint, TTSP) 问题：如果一个线程长时间运行在一个没有安全点检查的紧凑循环中，它将无法响应GC的暂停请求，导致整个GC过程乃至整个应用程序停滞 。

为了解决这个问题并保证有界的暂[停时](@entry_id:261799)间，现代[运行时系统](@entry_id:754463)通常采用一种**升级策略**。首先，GC发起一个协作式安全点请求，并给予一个时间“租约”（例如 `$T$`）。如果在租约到期后某个线程仍未响应，系统将升级为抢占式中断。这通常通过向该线程发送一个[操作系统](@entry_id:752937)信号（如 `SIGUSR2`）来实现。信号处理器会中断该线程的执行，在此时刻进行**保守式栈扫描** (conservative stack scanning)，即把栈上任何看起来像合法堆指针的字（例如，值落在堆地址范围内且对齐的整数）都当作根来处理。这种方法是“保守的”，因为它可能错将整数当成指针，导致一些垃圾对象被保留；但它是“安全的”，因为它保证了不会遗漏任何真正的根。通过这种方式，GC可以在有界延迟内（`$T + \Delta$`，其中 `$\Delta$` 是信号传递和处理的延迟）获得所有线程的根集合，从而继续其并发标记工作。

#### 信号处理与死锁

直接在信号处理器中执行复杂的栈扫描逻辑充满了危险。一个关键的危险是**[死锁](@entry_id:748237)**。例如，许多运行时使用**线程本地分配缓冲** (Thread-Local Allocation Buffer, TLAB) 来加速[内存分配](@entry_id:634722)。当TLAB耗尽时，线程需要获取一个全局堆锁 `$L_H$` 来申请一块新的内存。

考虑以下[死锁](@entry_id:748237)场景 ：
1.  线程 `$T_i$` 正在执行TLAB重填逻辑，并持有锁 `$L_H$`。
2.  此时，GC向 `$T_i$` 发送信号以获取其根。
3.  信号处理器在 `$T_i$` 的上下文中执行，并尝试获取另一个全局GC锁 `$L_W$`（例如，用于向全局标记队列中添加根）。
4.  与此同时，另一个线程 `$T_j$` 可能正持有锁 `$L_W$`，并尝试分配内存，因此它在等待锁 `$L_H$`。
5.  现在，`$T_i$` 持有 `$L_H$` 等待 `$L_W$`，而 `$T_j$` 持有 `$L_W$` 等待 `$L_H$`。一个经典的死锁形成了。

这个例子表明，信号处理器必须是**[异步信号](@entry_id:746555)安全**的。正确的做法是，信号处理器只执行最少且[绝对安全](@entry_id:262916)的操作：例如，仅仅设置一个标志位，然后立即返回。线程本身在下一次到达安全点时检查这个标志，并由线程自己安全地（即不持有任何锁时）执行栈扫描等协作工作。这种设计将复杂和可能阻塞的操作移出了信号处理的脆弱上下文，从而避免了死锁。

#### 精确扫描、保守扫描与[内存泄漏](@entry_id:635048)

获取根的过程还涉及到另一个维度：**精确性** (precision)。

*   **精确式GC** (Precise GC) 知道栈上和寄存器中每个字的确切类型。它只把真正的指针当作根。
*   **保守式GC** (Conservative GC) 则不然，它通过值的[模式匹配](@entry_id:137990)来“猜测”哪些字是，这在无法获得精确类型信息时（例如在与C/C++代码互操作时）非常有用。

保守式扫描的主要问题是**伪根** (false roots)：一个整数或其它数据，其位模式恰好与一个有效的、对齐的堆地址相同。伪根的影响取决于其生命周期 ：
*   **瞬时伪根**：栈上一个随机的整数值可能在一轮GC中恰好指向某个对象，导致该对象被错误地保留。但由于栈上数据变化很快，这个伪根在下一轮GC时很可能就消失了，被固定的对象也会被回收。这只会暂时增加内存占用，通常不是大问题。
*   **永久伪根**：如果一个伪根被存储在长生命周期的全局[数据结构](@entry_id:262134)中，并且永不改变，它就会永久地“钉住”一个本应被回收的对象。更糟糕的是，如果程序持续地产生这类永久伪根（例如，将新分配对象的地址作为整数ID存入一个永不清理的全局列表中），就会导致**无界内存滞留** (unbounded retention)，这实际上是一种由GC机制自身导致的[内存泄漏](@entry_id:635048)。

只有精确的根扫描（知道全局列表存的是整数而非指针）才能避免这种由保守扫描引发的[内存泄漏](@entry_id:635048)问题。

### 底层正确性：[内存模型](@entry_id:751871)与内存围栏

所有[并发算法](@entry_id:635677)的正确性最终都依赖于底层硬件的**[内存模型](@entry_id:751871)** (memory model)。在现代[多核处理器](@entry_id:752266)上，特别是像ARM这样的**弱序[内存模型](@entry_id:751871)** (weakly ordered memory model) 架构上，为了性能，处理器和编译器可以自由地对内存操作进行重排序。

这种重排序可能悄无声息地破坏GC屏障的逻辑。回到Dijkstra屏障的例子，mutator的代码顺序是 ：
1.  `$S_2$`: 将 `$x$` 的颜色标记为灰色 (`$\mathrm{mark}[x] := \mathrm{gray}$`)。
2.  `$S_3$`: 建立指针 (`$b.f := x$`)。

在弱序模型下，另一个核心上的 collector 线程完全有可能先观察到 `$S_3$` 的结果（即看到新的指针 `$b.f = x$`），然后再观察到 `$S_2$` 的结果（看到 `$\mathrm{mark}[x]$` 仍然是白色）。这同样会打破三色[不变量](@entry_id:148850)。

为了解决这个问题，必须使用**内存围栏** (memory fences) 或具有特定顺序语义的原子操作来强制跨线程的内存可见性顺序。C11标准和现代语言提供了一种强大的机制：**[释放-获取语义](@entry_id:754235)** (release-acquire semantics)。

*   当mutator发布一个共享指针时，它需要使用**释放写** (store-release)。这个操作保证在此之前的**所有**内存写入（如对象字段的初始化）对其他线程都变得可见。
*   当collector或其他线程读取这个共享指针时，它需要使用**获取读** (load-acquire)。这个操作保证在此之后的所有内存读取都能看到由配对的“释放写”所保证的内存状态。

通过在发布共享指针时使用 `store-release`，在读取该指针时使用 `load-acquire`，我们可以在两个线程之间建立一个**同步于** (synchronizes-with) 关系，进而形成一个**先于** (happens-before) 的偏[序关系](@entry_id:138937)。这个关系链保证了：如果 collector 看到了新发布的指针，那么它也一定能看到在此之前发生的所有初始化和屏障操作  。例如，要安全地发布一个新初始化的对象`$o$`，mutator必须用 `store-release` 将指向 `$o$` 的指针 `$p$` 存入共享位置 `$R$`，而 collector 必须用 `load-acquire` 从 `$R$` 中读取 `$p$`。只有这样，才能保证 collector 在看到 `$p$` 后，也一定能看到 `$o$` 被完全初始化的状态，从而安全地对其进行扫描。

总之，并发[垃圾回收](@entry_id:637325)是一个涉及算法理论、系统设计和底层硬件特性的复杂领域。从三色抽象和屏障机制，到并发的根扫描协议，再到[内存模型](@entry_id:751871)的精确控制，每一个环节都必须精心设计，才能在保证程序正确性的同时，实现低延迟、高响应的性能目标。