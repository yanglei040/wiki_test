{
    "hands_on_practices": [
        {
            "introduction": "安全点最基本的要求是，在垃圾回收器扫描栈时，机器的实际状态（如栈指针 $SP$）必须与栈图（stack map）中编码的信息完全一致。任何不匹配都可能导致灾难性后果，例如丢失对活动对象的引用，从而导致内存被错误回收。本练习  模拟了一个经典的编译器错误场景，要求你诊断并修复因指令顺序不当导致的栈状态不一致问题，从而加深对安全点精确性重要性的理解。",
            "id": "3669416",
            "problem": "一个用于精确式垃圾回收语言的编译器，其目标是一个具有栈指针（$SP$）和可选帧指针（$FP$）的常规架构。调用约定规定，被调用者在序言（prologue）中通过从 $SP$ 中减去一个非零的帧大小 $k$ 来为其帧分配空间，并在尾声（epilogue）中通过将 $k$ 加到 $SP$ 上来恢复 $SP$。垃圾回收器（GC）是“stop-the-world”类型的，并依赖于精确的栈映射（stack map）：存在一个从程序计数器（$PC$）到一组根位置（root location）的映射函数 $\\mathsf{Map}: PC \\rightarrow \\{(\\text{reg}, \\ell)\\}$，每个根位置要么是一个寄存器，要么是一个由基址（$SP$ 或 $FP$）和偏移量 $\\ell$ 描述的内存位置。在安全点（safepoint），GC 扫描器使用当前的 $PC$ 和 $\\mathsf{Map}$ 来枚举所有存活的根（live root），然后追踪对象图。\n\n考虑一个调试场景，其中被调用者的尾声在安全点扫描之前修改了 $SP$。具体来说，编译器在被调用者的尾声中，在 $SP$ 已恢复为其调用者的值 $SP_{\\text{post}} = SP_{\\text{pre}} + k$ 之后，放置了一条安全点轮询指令，但该轮询点的栈映射是相对于尾声前状态生成的，并期望 $SP$ 的值为 $SP_{\\text{pre}}$。假设一个存活指针 $p$ 被溢出到内存中，其位置相对于 $SP_{\\text{pre}}$ 的偏移量为 $o$，即地址为 $SP_{\\text{pre}} + o$，并且安全点的 $\\mathsf{Map}$ 将此根标识为 $\\langle SP, o \\rangle$。如果 GC 恰好在尾声中的安全点轮询处被触发，扫描器将读取 $\\langle SP_{\\text{post}}, o \\rangle$ 的位置，这可能导致找不到指针 $p$，从而可能引发过早回收。\n\n从基本原则出发：\n- 精确 GC 要求，在任何安全点，机器状态（$SP$、$FP$、寄存器）和栈映射必须在栈帧布局上保持一致；也就是说，如果 $\\mathsf{Map}(PC)$ 引用了 $\\langle SP, o \\rangle$，那么实际的 $SP$ 值必须等于构建 $\\mathsf{Map}(PC)$ 时所假设的 $SP$ 值。\n- 调用约定保证了序言和尾声会精确地将 $SP$ 调整 $k$，并且所有驻留在栈上的局部变量都位于相对于正常执行期间使用的 $SP$ 的固定偏移量处。\n- 安全点机制必须在存活性和位置信息精确的、明确定义的程序点上确保程序的静止状态（quiescence）。\n\n现在要求你通过在代码生成中施加顺序约束来修复此漏洞，并提出一种使用“注入暂停”（instrumented pauses）来扩大竞争窗口以验证修复的方法。哪个选项正确地指定了足以防止不匹配的顺序约束和一种可靠的验证方法？\n\nA. 约束代码生成，使得尾声中的任何安全点轮询都放置在 $SP$ 恢复之前，即轮询在 $SP = SP_{\\text{pre}}$ 的状态下执行，并确保该轮询点的栈映射是为尾声前状态构建的。验证方法为：在安全点轮询后立即插入一个注入的暂停：一个忙等待循环，该循环在一个全局标志 $G$ 上自旋，直到另一个线程触发 GC，从而最大化在轮询点停止的机会；然后使用在偏移量 $\\{o_i\\}$ 处溢出的存活指针进行压力测试，并检查没有根丢失。 \n\nB. 将所有栈映射切换为仅使用相对于 $FP$ 的偏移量，完全忽略 $SP$，并从被调用者的尾声中移除安全点轮询。验证方法为：启用一个扫描整个栈的保守回退机制，比较存活对象集合；如果集合匹配，则断定修复是正确的。\n\nC. 增加安全点轮询的频率，并在调用者侧的调用点（call sites）的返回指令之后插入它们，保持被调用者的尾声不变。验证方法为：通过计算执行期间安全点的命中次数，并观察到程序不再崩溃。\n\nD. 在 $SP$ 恢复和安全点轮询之间插入一条内存屏障指令以防止重排序，并修改 GC 扫描器，使其读取 $SP$ 两次并取平均值，以减少瞬时不一致性。验证方法为：通过对屏障开销进行微基准测试，而不检查根的准确性。\n\nE. 在每个安全点，通过遍历当前栈帧并推断偏移量，在运行时重新计算栈映射，从而避免依赖预计算的映射。验证方法为：打印推断出的映射，并通过目视检查 $SP$ 和偏移量看起来是否合理。\n\n选择正确的选项。",
            "solution": "精确垃圾回收的基本要求是，在扫描时刻，栈映射中对根的抽象描述与具体的机器状态之间必须保持一致。形式上，如果 $\\mathsf{Map}(PC)$ 包含基址 $B \\in \\{SP, FP\\}$ 的条目 $\\langle B, o \\rangle$，那么扫描器必须在地址 $B_{\\text{actual}} + o$ 处读取内存，其中 $B_{\\text{actual}}$ 必须等于构建 $\\mathsf{Map}$ 时所假设的基址值。$B_{\\text{actual}}$ 与假设基址之间的任何偏差都会使地址与实际根集合之间的对应关系失效。\n\n根据调用约定，被调用者的尾声执行 $SP \\leftarrow SP + k$ 操作，其中 $k > 0$ 是帧大小。如果安全点轮询被放置在此调整之后，但该轮询的栈映射期望 $SP = SP_{\\text{pre}}$，那么扫描器将在 $SP_{\\text{post}} + o = (SP_{\\text{pre}} + k) + o$ 的位置读取，这与预期的地址 $SP_{\\text{pre}} + o$ 相差 $k$。这可能导致漏掉溢出的指针 $p$。\n\n因此，修复方案必须强制执行一个顺序约束，以使轮询点的机器状态与其栈映射保持一致。原则上存在两种等效策略：要么将轮询提前，以便在扫描时 $SP = SP_{\\text{pre}}$，并为此状态构建 $\\mathsf{Map}$；要么在恢复 $SP$ 后保留轮询，并为尾声后状态重新构建 $\\mathsf{Map}$，使其条目使用带有新偏移量 $o'$ 的 $\\langle SP_{\\text{post}}, o' \\rangle$。问题要求“通过顺序约束修复并使用注入暂停进行验证”，这与前一种策略相符：约束代码生成，使得在安全点轮询之前不修改 $SP$，并通过一个特意设置的暂停来验证，该暂停会提高恰好在该点停止的可能性。\n\n验证方法的设计必须能够增加命中安全点的概率，并捕获状态不匹配的情况。在轮询后立即插入一个注入暂停，可以扩大 GC 在被调用者处于尾声阶段时暂停整个世界（stop the world）的时间窗口。为了证明其正确性，应该创建在多个偏移量 $\\{o_i\\}$ 处有根溢出的测试，并检查在压力下（即在暂停期间并发触发 GC），没有根会丢失，例如，可以通过保留对象并验证没有对象被过早回收来实现。\n\n分析每个选项：\n\nA. 该选项施加了必要的顺序约束：在恢复 $SP$ 之前放置安全点轮询，确保在轮询点 $SP = SP_{\\text{pre}}$，并为尾声前状态构建栈映射。这保证了扫描器读取的地址 $SP_{\\text{pre}} + o$ 与 $\\mathsf{Map}$ 相匹配。通过在轮询后进行注入的忙等待来进行验证是合适的：通过自旋直到 GC 触发，我们最大化了在被调用者处于尾声阶段且 $SP$ 仍为尾声前值时停止的机会，从而验证了在偏移量 $\\{o_i\\}$ 处溢出的根能被正确找到。这是正确的。\n\nB. 切换到相对于 $FP$ 的偏移量可能不可行或不充分，因为在优化下 $FP$ 可能会被省略或挪作他用，而从尾声中移除安全点轮询会降低安全点的覆盖率，可能损害延迟。此外，启用一个保守回退机制进行验证并不能证明精确机制是正确的；保守扫描通过过近似（over-approximating）根集合可能会掩盖错误。其验证标准（在保守扫描下比较存活对象集合）对于证明精确性的正确性是不可靠的。这是不正确的。\n\nC. 增加安全点轮询的频率并将其移动到调用点的返回指令之后，并不能解决尾声轮询点处 $SP$ 和栈映射之间的根本不匹配问题。计算安全点命中次数不能构成正确性验证；它衡量的是频率，而不是精确性。此外，将轮询放在返回指令之后会改变程序点，并且如果映射不一致，在调用点边缘仍然可能遭受状态不匹配的问题。这是不正确的。\n\nD. 内存屏障不能解决逻辑上的不匹配问题；它们只约束硬件重排序。栈映射期望一个特定的 $SP$ 值，而读取 $SP$ 两次并“取平均值”是无稽之谈，因为 $SP$ 不是一个可以取平均值的量；它是一个指针值。对屏障开销进行微基准测试忽略了根的准确性，无法验证正确性。这是不正确的。\n\nE. 在运行时重新计算栈映射违背了使用精确预计算映射的初衷，并且通常开销巨大且复杂；可靠地“推断偏移量”需要完整的符号信息，并且无法保证成功。打印推断出的映射并进行目视检查不是一种可靠的验证方法。这是不正确的。\n\n因此，唯一一个既能正确修复顺序问题，又提供了使用注入暂停的可靠验证策略的选项是 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "保证机器状态的一致性是正确实现安全点的必要条件，但还不够。编译器还必须能够识别出所有活跃的托管引用（managed reference），以便在栈图中正确记录它们。本练习  探讨了一个更棘手的挑战：当内联汇编等底层代码向编译器“隐藏”了一个指针时，垃圾回收器的假设就会被打破。通过解决这个问题，你将学会如何通过多种策略来重建编译器与运行时之间的“契约”，确保所有根（root）都能被准确追踪。",
            "id": "3669445",
            "problem": "某个托管运行时实现了一个精确式、移动式垃圾回收器，并使用协作式安全点，这些安全点作为显式轮询插入到程序中明确定义的位置。根据定义，在安全点，每一个对托管对象的存活引用都必须能通过栈映射被垃圾回收器发现，该栈映射精确地枚举了所有存活引用及其位置（栈槽和寄存器）。考虑以下一个简化的、面向 x86-$64$ 应用程序二进制接口的类C函数，其中使用了内联汇编。该内联汇编将一个托管引用暂存到一个被调用者保存寄存器中，并在稍后使用它。运行时在这两次使用之间插入了一个安全点轮询。\n\n代码草图（用于说明，不可直接编译）：\n\n\ntypedef struct Obj { int f; } Obj;\n\nvoid g(Obj* p) {\n  // 使用内联汇编将托管指针暂存到 rbx 中。\n  asm volatile(\n    \"mov %0, %%rbx\n\\t\"\n    :\n    : \"r\"(p)\n    : \"rbx\", \"memory\"\n  );\n\n  // 一个可能触发垃圾回收的协作式安全点轮询。\n  safepoint_poll();\n\n  // 稍后，仍通过内联汇编使用隐藏在 rbx 中的副本。\n  asm volatile(\n    \"mov (%%rbx), %%eax\n\\t\"  // 读取字段 f\n    :\n    :\n    : \"rbx\", \"rax\", \"memory\"\n  );\n}\n\n假设以下基本事实：\n- 垃圾回收器是精确且移动式的：它可能在回收过程中移动对象，并且它假设在安全点的所有存活引用都可以从栈映射中发现。它不会保守式地扫描未被枚举的栈字或寄存器。\n- 编译器仅根据其内部对托管引用的存活性分析和显式注解来构建栈映射；它不检查内联汇编的语义。\n- 安全点轮询可能导致一次回收。如果在该轮询点，一个存活引用未在栈映射中枚举，回收器可能会在移动对象时不更新那个隐藏的副本，从而在该副本稍后被解引用时导致内存损坏。\n\n在上面的代码中，第一个内联汇编将托管引用复制到寄存器 rbx 中，但外围的编译器无法“看到” rbx 包含一个在轮询后仍然存活的托管引用。因此，在轮询点，栈映射可能会忽略这个引用。你必须选择如何使这个程序在精确式、移动式回收器下变得稳健。\n\n以下哪些变更是修复该程序的稳健方法，从而使其即使在轮询点发生回收也能保持正确？选择所有适用项。\n\nA. 用一个安全点栅栏将从第一个内联汇编到第二个内联汇编之间的区域包围起来（即，防止在该区域内插入或执行轮询或调用），并将任何安全点轮询移到该栅栏区域之外。确保该栅栏区域不会调用可能阻塞或轮询的代码。这保证了当引用被隐藏在 rbx 中时，不会发生回收。\n\nB. 保留 safepoint_poll 的位置，但将该托管引用明确发布给编译器的栈映射机制，使其在轮询点之后仍然存活。例如，将该引用物化到一个声明为垃圾回收器根的专用溢出槽中，或使用一个编译器可识别的 keepalive 指令，以便轮询点的栈映射能够枚举该引用的位置（无论是在溢出槽中还是在指定寄存器中）。\n\nC. 依赖平台调用约定和 \"memory\" 销毁标记：由于 rbx 是被调用者保存寄存器，并且汇编在销毁列表中列出了 \"memory\"，因此即使它没有在栈映射中列出，运行时也会在轮询时隐式扫描 rbx，所以不需要额外的工作。\n\nD. 强制进行保守式枚举，让运行时在每个安全点都保守式地扫描所有通用寄存器和所有栈字，而不改变汇编代码。这样就避免了为该引用添加特定注解的需要。\n\nE. 将原始引用替换为堆句柄：在第一个内联汇编之前，在运行时的句柄表中为 p 注册一个句柄；当需要该对象时，内联汇编必须通过此句柄进行加载和存储；在第二个内联汇编之后，注销该句柄。由于句柄是一个已知的根，垃圾回收器会在对象重定位时更新它，即使在轮询点发生了回收，内联汇编也能观察到更新后的地址。",
            "solution": "### 问题验证\n\n#### 步骤 1：提取已知条件\n- 一个托管运行时实现了一个精确式、移动式垃圾回收器（GC）。\n- GC 使用作为显式轮询插入的协作式安全点。\n- 在安全点，一个栈映射精确地枚举了所有存活引用及其位置（栈槽和寄存器）。\n- 函数 `g(Obj* p)` 接受一个托管引用 `p`。\n- 一条内联汇编指令 `mov %0, %%rbx` 将 `p` 复制到 `rbx` 寄存器。\n- 调用了一个安全点轮询 `safepoint_poll()`。\n- 第二条内联汇编指令 `mov (%%rbx), %%eax` 解引用 `rbx`。\n- 假设：GC 是精确且移动式的；它只使用栈映射，不进行保守式扫描。\n- 假设：编译器根据其内部的存活性分析和显式注解来构建栈映射；它不检查内联汇编的语义。\n- 假设：安全点轮询可能触发垃圾回收。\n- 假设：如果一个存活引用不在栈映射中，GC 不会更新它，从而导致内存损坏。\n\n#### 步骤 2：使用提取的已知条件进行验证\n该问题陈述在科学上是成立的。它提出了编译器和运行时系统工程中一个经典且根本性的挑战：当底层代码（如内联汇编）与垃圾回收器交互时，如何确保内存安全。所描述的概念——精确式移动 GC、协作式安全点、栈映射以及“隐藏”指针的危险——都是该领域的标准课题。\n\n问题提取得当。它描述了一个具有明确定义缺陷的特定代码片段，并要求在给定的系统约束（例如，精确式 GC）内找到稳健的修正方法。使用的语言客观且 unambiguous。问题是自洽的，不包含矛盾信息。提供的假设对于正确界定问题至关重要。\n\n该问题并非微不足道或故作高深；它需要对编译器、托管运行时及其执行的代码之间的契约有扎实的理解。\n\n#### 步骤 3：结论与行动\n问题陈述是**有效**的。这是一个计算机科学领域中健全且表述良好的问题。我现在将进行解答。\n\n### 基于原则的推导\n\n核心问题在于违反了垃圾回收器的不变性。GC 的运作原则是，由编译器生成的栈映射提供了在安全点时栈上和寄存器中所有存活托管引用的完整枚举。在给定的代码中，引用 `p`被复制到 `rbx` 寄存器中。由于编译器不分析内联汇编的语义，其存活性分析可能会得出结论，认为变量 `p` 在第一个汇编块之后就不再需要了。因此，在为 `safepoint_poll()` 调用生成栈映射时，编译器没有任何信息表明 `rbx` 包含一个必须被保留的存活引用。\n\n如果在轮询点发生垃圾回收，GC 将使用不完整的栈映射来扫描根。它可能会找到并重定位 `p` 最初指向的对象（如果它可以通过其他路径访问），或者回收其内存（如果不能访问）。无论哪种情况，存储在 `rbx` 中的指针值都不会被更新，因为 GC 不知道它的存在。这个指针现在是陈旧的。随后的解引用 `mov (%%rbx), %%eax` 将会从一个无效的内存地址读取，导致内存损坏、段错误或其他未定义行为。\n\n一个稳健的解决方案必须恢复这一不变性。这可以通过两种主要策略实现：\n1.  **防止回收：** 确保在引用对编译器隐藏的期间，不会发生垃圾回收。\n2.  **通知回收器：** 将隐藏的存活引用的存在和位置明确地传达给编译器和运行时，以便它被包含在栈映射中并由 GC 正确更新。\n\n### 逐项分析\n\n**A. 用一个安全点栅栏将从第一个内联汇编到第二个内联汇编之间的区域包围起来（即，防止在该区域内插入或执行轮询或调用），并将任何安全点轮询移到该栅栏区域之外。确保该栅栏区域不会调用可能阻塞或轮询的代码。这保证了当引用被隐藏在 rbx 中时，不会发生回收。**\n\n此方法实现了第一种策略：防止回收。一个“安全点栅栏”或“GC不安全区域”是托管运行时中的一种标准机制。它建立了一个代码块，在该代码块中线程不处于 GC 安全状态。运行时保证此区域内的轮询被禁用，或者如果请求回收，该线程不会被暂停以进行 GC。通过将 `rbx` 持有隐藏指针的整个区域用栅栏围起来，我们确保 `safepoint_poll()` 不会触发回收。由于对象不能被移动或回收，`rbx` 中的指针保持有效。该区域不得阻塞或调出的约束至关重要，因为这类操作可能隐式地向运行时让步并触发回收。这是一个稳健且实用的解决方案。\n\n**结论：正确。**\n\n**B. 保留 safepoint_poll 的位置，但将该托管引用明确发布给编译器的栈映射机制，使其在轮询点之后仍然存活。例如，将该引用物化到一个声明为垃圾回收器根的专用溢出槽中，或使用一个编译器可识别的 keepalive 指令，以便轮询点的栈映射能够枚举该引用的位置（无论是在溢出槽中还是在指定寄存器中）。**\n\n此方法实现了第二种策略：通知回收器。该方案不是隐藏引用，而是让编译器意识到该引用必须被视为在 `safepoint_poll()`之后仍然存活。诸如 `GC.KeepAlive()` 内建函数或局部变量上的特殊注解之类的机制会告诉编译器延长引用的生命周期。然后，编译器会确保该引用被记录在安全点的栈映射中。GC在读取栈映射时，会找到该引用（无论它是在像 `rbx` 这样的寄存器中还是在栈槽中），并在对象被重定位时更新它。这直接解决了汇编代码与编译器/GC之间的信息鸿沟。在许多托管环境中，这是解决该问题的稳健且惯用的方法。\n\n**结论：正确。**\n\n**C. 依赖平台调用约定和 \"memory\" 销毁标记：由于 rbx 是被调用者保存寄存器，并且汇编在销毁列表中列出了 \"memory\"，因此即使它没有在栈映射中列出，运行时也会在轮询时隐式扫描 rbx，所以不需要额外的工作。**\n\n这个建议是基于对所涉及组件的误解。\n- **被调用者保存寄存器：** `rbx` 在 x86-64 System V ABI 下作为“被调用者保存”的状态是函数调用的一个契约，确保被调用者保留调用者的值。这个约定与 GC 在安全点的根查找机制无关。GC 遵循自己的规则，如问题所述，这些规则完全基于栈映射。\n- **\"memory\" 销毁标记：** `memory` 销毁标记是给*编译器*的指令。它强制编译器假定该汇编块可能读取或写入任何内存位置。这可以防止编译器跨汇编块重排序读/写操作，并使其已缓存在寄存器中的任何内存值失效。它不提供关于寄存器*内容*的任何信息。编译器无法从这个销毁标记推断出 `rbx` 持有一个托管引用。\n问题明确指出 GC 是**精确的**，不会扫描未枚举的位置。因此，运行时*不会*“隐式扫描 `rbx`”。\n\n**结论：不正确。**\n\n**D. 强制进行保守式枚举，让运行时在每个安全点都保守式地扫描所有通用寄存器和所有栈字，而不改变汇编代码。这样就避免了为该引用添加特定注解的需要。**\n\n这建议改变垃圾回收器的基本设计，从精确式变为部分保守式。虽然保守式 GC 可能会在 `rbx` 中找到类似指针的值并将其视为一个根，但这并不是对*程序*的修复。它是对整个*运行时系统*的修改。问题要求的是一种在*给定现有运行时约束*（其中之一是精确式 GC）下修复程序的稳健方法。将 GC 的算法从精确式改为保守式违反了问题的前提。解决方案必须在指定的系统内工作，而不是通过改变其核心原则来解决。\n\n**结论：不正确。**\n\n**E. 将原始引用替换为堆句柄：在第一个内联汇编之前，在运行时的句柄表中为 p 注册一个句柄；当需要该对象时，内联汇编必须通过此句柄进行加载和存储；在第二个内联汇编之后，注销该句柄。由于句柄是一个已知的根，垃圾回收器会在对象重定位时更新它，即使在轮询点发生了回收，内联汇编也能观察到更新后的地址。**\n\n这是一个基于间接引用的经典且稳健的解决方案。“句柄”是对托管对象的一个稳定引用，通常是指向运行时管理的表中某个位置的指针。GC 知道要将整个表作为根集进行扫描。程序的逻辑将是：\n1. 创建一个句柄 `h`，它指向一个包含对象 `p` 地址的内存位置。\n2. 内联汇编接收句柄的地址 ``。要获取对象的地址，它必须首先解引用 `h`。\n3. 如果 GC 在轮询点运行，它会重定位对象 `p` 并更新存储在 `h` 处的地址。\n4. 第二个内联汇编块再次解引用 `h`，得到对象新的、正确的地址。\n指向对象的原始指针绝不会跨越安全点持续存在；每次需要时，它都会从稳定的句柄重新加载。这将代码与对象的物理位置解耦，使其不受重定位的影响。\n\n**结论：正确。**",
            "answer": "$$\\boxed{ABE}$$"
        },
        {
            "introduction": "在确保了安全点的正确性之后，下一个关键问题就是性能。安全点检查本身会带来开销，因此高效地实现它们至关重要。本练习  将引导你对两种常见的安全点轮询（polling）实现策略——内联检查与运行时存根调用——进行性能建模和比较。你将通过量化分析，理解在不同硬件架构下，分支预测等微架构特性如何影响性能决策，从而学会在实际工程中进行权衡。",
            "id": "3669414",
            "problem": "考虑一个托管运行时，它在紧凑循环的每次迭代中插入一个安全点轮询，以便可以安全地启动垃圾回收和去优化。安全点是程序中的一个点，在该点上，所有线程的栈都处于已知状态，并且所有存活的引用都可以通过栈映射被发现。栈映射为每个安全点记录了寄存器和内存中存活对象引用的位置，以支持精确的垃圾回收。实现安全点轮询通常使用两种编译器策略：(i) 内联轮询，即在循环体中生成一个条件检查；以及 (ii) 调用运行时存根，即循环体无条件调用一个处理安全点协议并返回的存根。\n\n假设一个即时 (JIT) 编译器面向两种架构，标记为 $\\mathcal{A}$ 和 $\\mathcal{B}$。设内联轮询所使用的条件分支的分支预测错误率为 $p \\in [0,1]$。使用以下基于标准微架构定义的成本模型假设：\n- 一个条件分支的基本执行成本为 $b$ 个周期（包括比较和分支微操作），当预测错误时，会因流水线清空和前端重定向而产生 $m$ 个周期的额外惩罚。\n- 在循环体中执行时，从一个热点轮询内存位置（例如，受页保护的标志或轮询页）加载的成本为 $l$ 个周期。在运行时存根内部执行时，同一次加载的成本为 $l_{s}$ 个周期。\n- 当实际上沒有进入安全点时，在热路径上，对存根的无条件调用及其返回的总开销为 $c$ 个周期。此开销包括返回栈操作和前端成本，但不包括任何分支预测错误，因为调用是无条件的，且存根的快速路径相对于返回是无分支的。\n- 在热路径上不会进入安全点；你只需对轮询开销进行建模。\n\n对于内联轮询，循环体执行一次轮询位置的加载和一次条件分支；期望的每次迭代开销是基础成本加上期望的预测错误惩罚之和。对于调用方法，循环体执行一次无条件调用和返回；如果没有请求安全点，存根会执行一次加载并立即返回，其快速路径中没有条件分支。\n\n使用上述原理，从第一性原理出发，推导出盈亏平衡预测错误概率 $p^{\\ast}$，在该概率下，内联轮询的期望每次迭代开销等于调用方法的开销。然后，为以下两种架构数值计算 $p^{\\ast}$：\n\n- 架构 $\\mathcal{A}$：$l = 4$ 个周期，$b = 1$ 个周期，$m = 18$ 个周期，$c = 9$ 个周期，$l_{s} = 4$ 个周期。\n- 架构 $\\mathcal{B}$：$l = 3$ 个周期，$b = 2$ 个周期，$m = 12$ 个周期，$c = 8$ 个周期，$l_{s} = 3$ 个周期。\n\n将结果对 $\\left(p^{\\ast}_{\\mathcal{A}}, p^{\\ast}_{\\mathcal{B}}\\right)$ 报告为无量纲的纯数字。将你的数值结果四舍五入到四位有效数字。按要求使用 LaTeX 的 $\\texttt{pmatrix}$ 环境将最终答案表示为行向量。",
            "solution": "问题要求推导出一个盈亏平衡预测错误概率 $p^{\\ast}$，在该概率下，两种实现安全点轮询的不同编译器策略表现出相等的性能开销。这两种策略是内联轮询和调用运行时存根。我们将首先根据所提供的微架构参数为每种策略建立成本模型，然后以符号形式求解盈亏平衡概率 $p^{\\ast}$，最后为指定的两种架构 $\\mathcal{A}$ 和 $\\mathcal{B}$ 计算数值。\n\n令 $C_{\\text{inline}}$ 表示内联轮询策略的期望每次迭代开销。问题指出，该策略包括在循环体中执行的一次内存加载和一次条件分支。总成本是这些操作成本的总和。\n从热点轮询内存位置加载的成本为 $l$。\n条件分支的成本有两个组成部分：基础执行成本 $b$ 和潜在的预测错误惩罚。分支以概率 $p$ 发生预测错误，产生 $m$ 个周期的额外成本。因此，分支的期望成本是其基础成本与期望惩罚之和，即 $b + p \\times m$。\n因此，内联轮询的总期望开销为：\n$$C_{\\text{inline}} = l + b + pm$$\n\n接下来，令 $C_{\\text{callout}}$ 表示调用策略的每次迭代开销。该策略涉及对运行时存根的无条件调用，然后由存根执行内存加载。我们关心的是实际上没有进入安全点的热路径。\n无条件调用及其相应返回的成本为 $c$。\n在存根内部执行时，内存加载的成本为 $l_s$。\n问题明确指出，调用是无条件的，且存根的快速路径是无分支的，因此在该策略的热路径上无需考虑分支预测错误的成本。\n调用策略的总开销是这两个组成部分之和：\n$$C_{\\text{callout}} = c + l_s$$\n\n盈亏平衡预测错误概率 $p^{\\ast}$ 是使两种策略成本相等的特定 $p$ 值：$C_{\\text{inline}} = C_{\\text{callout}}$。我们可以建立方程：\n$$l + b + p^{\\ast}m = c + l_s$$\n\n现在我们求解这个关于 $p^{\\ast}$ 的方程，以找到盈亏平衡概率的一般符号表达式：\n$$p^{\\ast}m = c + l_s - l - b$$\n$$p^{\\ast} = \\frac{c + l_s - l - b}{m}$$\n\n这个表达式用架构成本参数来表示盈亏平衡概率。我们现在将使用此公式计算给定两种架构的数值。\n\n对于架构 $\\mathcal{A}$，给出的参数如下：\n$l = 4$ 个周期\n$b = 1$ 个周期\n$m = 18$ 个周期\n$c = 9$ 个周期\n$l_s = 4$ 个周期\n\n将这些值代入我们推导出的 $p^{\\ast}$ 表达式中：\n$$p^{\\ast}_{\\mathcal{A}} = \\frac{9 + 4 - 4 - 1}{18} = \\frac{8}{18} = \\frac{4}{9}$$\n将其表示为四舍五入到四位有效数字的小数：\n$$p^{\\ast}_{\\mathcal{A}} \\approx 0.4444$$\n\n对于架构 $\\mathcal{B}$，给出的参数如下：\n$l = 3$ 个周期\n$b = 2$ 个周期\n$m = 12$ 个周期\n$c = 8$ 个周期\n$l_s = 3$ 个周期\n\n将这些值代入 $p^{\\ast}$ 的表达式中：\n$$p^{\\ast}_{\\mathcal{B}} = \\frac{8 + 3 - 3 - 2}{12} = \\frac{6}{12} = \\frac{1}{2}$$\n作为小数，这正好是 $0.5$。为了遵守四舍五入到四位有效数字的要求，我们将其表示为：\n$$p^{\\ast}_{\\mathcal{B}} = 0.5000$$\n\n最终结果是这两个概率对 $(p^{\\ast}_{\\mathcal{A}}, p^{\\ast}_{\\mathcal{B}})$。对于任何给定的架构，如果实际的分支预测错误率 $p$ 大于 $p^{\\ast}$，则调用策略更高效。如果 $p$ 小于 $p^{\\ast}$，则内联轮询是首选的、开销更低的策略。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4444 & 0.5000\n\\end{pmatrix}\n}\n$$"
        }
    ]
}