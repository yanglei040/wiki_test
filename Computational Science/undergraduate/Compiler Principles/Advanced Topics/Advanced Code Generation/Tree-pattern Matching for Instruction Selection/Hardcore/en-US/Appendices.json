{
    "hands_on_practices": [
        {
            "introduction": "This first exercise puts you in the role of a compiler designer tasked with generating efficient code. You will apply the core algorithm of tree-pattern matching: bottom-up dynamic programming. By calculating the minimum cost to generate code for each part of an expression tree, you will directly experience the fundamental trade-off between using a sequence of simple instructions versus a single, powerful, and complex instruction, seeing how the optimal choice depends on the specific costs provided by the target architecture .",
            "id": "3679133",
            "problem": "You are designing a teaching Instruction Set Architecture (ISA) to illustrate tree-pattern matching for instruction selection. The ISA supports the following instruction tiles, each of which emits exactly one machine instruction when selected:\n\n- A binary addition tile that matches the tree pattern $+(x,y)$ with cost $1$.\n- A shift-left-by-constant tile that matches the tree pattern $\\ll(x,k)$ for integral $k$ with cost $1$.\n- A family of addressing-mode tiles (generalized Load Effective Address, written as $LEA$) that match either $+(x,\\ll(x,k))$ or $+(\\ll(x,k),x)$ when the same subexpression $x$ appears twice. For these tiles:\n  - If $k \\in \\{0,1,2,3\\}$, the cost is $1$.\n  - If $k \\in \\{4,5\\}$, the cost is $2$.\n  - If $k \\notin \\{0,1,2,3,4,5\\}$, the pattern cannot be matched.\n\nAssume leaves $a$, $b$, $c$ are already resident in registers and can be used as operands with zero cost. No reassociation or algebraic rewrites are permitted beyond matching both $+(x,\\ll(x,k))$ and $+(\\ll(x,k),x)$ as the same $LEA$ pattern. You must use bottom-up tree-pattern matching and compute an optimal cover of the given expression tree by minimizing the sum of tile costs.\n\nConsider the expression tree\n$$\nE = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big).\n$$\n\nLet $C_{\\text{base}}$ denote the minimal total cost when only the addition and shift tiles are available (i.e., $LEA$ tiles are disallowed). Let $C_{\\text{lea}}$ denote the minimal total cost when all the above tiles, including the $LEA$ family, are available as separate tiles for each encodable $k$ with the stated costs.\n\nCompute the single numeric quantity\n$$\nD \\triangleq C_{\\text{base}} - C_{\\text{lea}}.\n$$\n\nProvide your final answer as a single real number. No rounding is required. No units are necessary.",
            "solution": "The user wants me to solve the following problem:\nYou are designing a teaching Instruction Set Architecture (ISA) to illustrate tree-pattern matching for instruction selection. The ISA supports the following instruction tiles, each of which emits exactly one machine instruction when selected:\n\n- A binary addition tile that matches the tree pattern $+(x,y)$ with cost $1$.\n- A shift-left-by-constant tile that matches the tree pattern $\\ll(x,k)$ for integral $k$ with cost $1$.\n- A family of addressing-mode tiles (generalized Load Effective Address, written as $LEA$) that match either $+(x,\\ll(x,k))$ or $+(\\ll(x,k),x)$ when the same subexpression $x$ appears twice. For these tiles:\n  - If $k \\in \\{0,1,2,3\\}$, the cost is $1$.\n  - If $k \\in \\{4,5\\}$, the cost is $2$.\n  - If $k \\notin \\{0,1,2,3,4,5\\}$, the pattern cannot be matched.\n\nAssume leaves $a$, $b$, $c$ are already resident in registers and can be used as operands with zero cost. No reassociation or algebraic rewrites are permitted beyond matching both $+(x,\\ll(x,k))$ and $+(\\ll(x,k),x)$ as the same $LEA$ pattern. You must use bottom-up tree-pattern matching and compute an optimal cover of the given expression tree by minimizing the sum of tile costs.\n\nConsider the expression tree\n$$\nE = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big).\n$$\n\nLet $C_{\\text{base}}$ denote the minimal total cost when only the addition and shift tiles are available (i.e., $LEA$ tiles are disallowed). Let $C_{\\text{lea}}$ denote the minimal total cost when all the above tiles, including the $LEA$ family, are available as separate tiles for each encodable $k$ with the stated costs.\n\nCompute the single numeric quantity\n$$\nD \\triangleq C_{\\text{base}} - C_{\\text{lea}}.\n$$\n\nProvide your final answer as a single real number. No rounding is required. No units are necessary.\n\n### Step 1: Problem Validation\n\nI will first validate the problem statement.\n\n#### 1.1. Extract Givens\n- **Tiles (Base):**\n  1. `$+(x,y)$`, cost `$1$`.\n  2. `$\\ll(x,k)$` for integral `$k$`, cost `$1$`.\n- **Tiles (LEA):**\n  1. `$+(x,\\ll(x,k))$` or `$+ (\\ll(x,k), x)`.\n     - Cost `$1$` if `$k \\in \\{0,1,2,3\\}$`.\n     - Cost `$2$` if `$k \\in \\{4,5\\}$`.\n- **Operands:** Leaves `$a, b, c$` have cost `$0$`.\n- **Method:** Bottom-up tree-pattern matching (dynamic programming) for minimal cost.\n- **Constraints:** No reassociation or algebraic rewrites beyond the specific $LEA$ pattern.\n- **Expression Tree:** `$E = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big)$`.\n- **Quantities to Find:**\n  - `$C_{\\text{base}}$`: minimal cost with only base tiles.\n  - `$C_{\\text{lea}}$`: minimal cost with all tiles.\n  - `$D = C_{\\text{base}} - C_{\\text{lea}}$`.\n\n#### 1.2. Validate Using Extracted Givens\nThe problem is well-defined within the domain of compiler theory, specifically instruction selection via tree-pattern matching. This is a standard application of dynamic programming on trees.\n- **Scientifically Grounded:** The concepts are fundamental to compiler design. The ISA is a simplified but plausible model for educational purposes. All principles are sound within computer science.\n- **Well-Posed:** The expression tree, tile set, costs, and optimization goal (minimum total cost) are all explicitly defined. This structure guarantees a unique minimal cost for each case, making the problem well-posed.\n- **Objective and Complete:** The problem is stated using formalisms and contains all necessary information to derive a solution. There are no subjective or ambiguous terms.\n\n#### 1.3. Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Step 2: Solution Derivation\n\nThe problem requires computing the minimal cost to cover the given expression tree with two different sets of instruction tiles. We will use a bottom-up dynamic programming approach, computing the minimal cost for each subtree. Let `$cost(N)$` denote the minimal cost to evaluate the subtree rooted at node `$N$`. The cost for the leaves `$a, b, c$` is given as `$0$`.\n\nLet us decompose the expression tree `$E$` into its primary subtrees:\n- `$E_1 = +(a, \\ll(a,3))$`\n- `$E_2 = +(b, \\ll(b,4))$`\n- `$E_3 = +(\\ll(c,5), c)`\nThe full tree is `$E = +\\big(+(E_1, E_2), E_3\\big)`.\n\n#### 2.1. Calculation of $C_{\\text{base}}$\n\nIn this scenario, only the addition tile (`cost = 1`) and shift tile (`cost = 1`) are available. Let `$cost_B(N)$` be the cost of a subtree `$N$`.\n\n1.  **Cost of shift subtrees:**\n    - `$cost_B(\\ll(a,3)) = \\text{cost}(\\ll) + cost_B(a) = 1 + 0 = 1$`. A single shift tile is used.\n    - `$cost_B(\\ll(b,4)) = \\text{cost}(\\ll) + cost_B(b) = 1 + 0 = 1$`.\n    - `$cost_B(\\ll(c,5)) = \\text{cost}(\\ll) + cost_B(c) = 1 + 0 = 1$`.\n\n2.  **Cost of subtrees $E_1, E_2, E_3$:**\n    - For `$E_1 = +(a, \\ll(a,3))`, we must use an addition tile. The cost is the tile cost plus the costs of its children's subtrees:\n      `$cost_B(E_1) = \\text{cost}(+) + cost_B(a) + cost_B(\\ll(a,3)) = 1 + 0 + 1 = 2$`.\n    - Similarly for `$E_2 = +(b, \\ll(b,4))`:\n      `$cost_B(E_2) = \\text{cost}(+) + cost_B(b) + cost_B(\\ll(b,4)) = 1 + 0 + 1 = 2$`.\n    - And for `$E_3 = +(\\ll(c,5), c)`:\n      `$cost_B(E_3) = \\text{cost}(+) + cost_B(\\ll(c,5)) + cost_B(c) = 1 + 1 + 0 = 2$`.\n\n3.  **Cost of intermediate and root nodes:**\n    - The next node is `$+(E_1, E_2)`:\n      `$cost_B(+(E_1, E_2)) = \\text{cost}(+) + cost_B(E_1) + cost_B(E_2) = 1 + 2 + 2 = 5$`.\n    - The root node is `$E = +\\big(+(E_1, E_2), E_3\\big)`:\n      `$cost_B(E) = \\text{cost}(+) + cost_B(+(E_1, E_2)) + cost_B(E_3) = 1 + 5 + 2 = 8$`.\n\nTherefore, the minimal cost using only the base tiles is `$C_{\\text{base}} = 8$`.\n\n#### 2.2. Calculation of $C_{\\text{lea}}$\n\nNow, we introduce the `$LEA$` family of tiles. At each `+` node, we must check if a `$LEA$` tile can provide a less expensive cover. Let `$cost_L(N)$` be the cost of a subtree `$N$`.\n\n1.  **Cost of shift subtrees:** These are unaffected as no new tiles match them.\n    - `$cost_L(\\ll(a,3)) = 1$`\n    - `$cost_L(\\ll(b,4)) = 1$`\n    - `$cost_L(\\ll(c,5)) = 1$`\n\n2.  **Cost of subtree $E_1 = +(a, \\ll(a,3))$:**\n    - **Option 1 (ADD tile):** `$cost_L = \\text{cost}(+) + cost_L(a) + cost_L(\\ll(a,3)) = 1 + 0 + 1 = 2$`.\n    - **Option 2 (LEA tile):** The pattern `$+(x, \\ll(x,k))$` matches with `$x=a$` and `$k=3$`. Since `$k=3` is in the set `$\\{0,1,2,3\\}$`, the cost of this tile is `$1$`. This tile covers the entire subtree `$E_1$`.\n    - The minimal cost is `$cost_L(E_1) = \\min(2, 1) = 1$`.\n\n3.  **Cost of subtree $E_2 = +(b, \\ll(b,4))$:**\n    - **Option 1 (ADD tile):** `$cost_L = \\text{cost}(+) + cost_L(b) + cost_L(\\ll(b,4)) = 1 + 0 + 1 = 2$`.\n    - **Option 2 (LEA tile):** The pattern `$+(x, \\ll(x,k))$` matches with `$x=b$` and `$k=4$`. Since `$k=4$` is in the set `$\\{4,5\\}$`, the cost of this tile is `$2$`.\n    - The minimal cost is `$cost_L(E_2) = \\min(2, 2) = 2$`.\n\n4.  **Cost of subtree $E_3 = +(\\ll(c,5), c)$:**\n    - **Option 1 (ADD tile):** `$cost_L = \\text{cost}(+) + cost_L(\\ll(c,5)) + cost_L(c) = 1 + 1 + 0 = 2$`.\n    - **Option 2 (LEA tile):** The pattern `$+ (\\ll(x,k), x)` matches with `$x=c$` and `$k=5$`. Since `$k=5$` is in the set `$\\{4,5\\}$`, the cost of this tile is `$2$`.\n    - The minimal cost is `$cost_L(E_3) = \\min(2, 2) = 2$`.\n\n5.  **Cost of intermediate and root nodes:**\n    - The node `$+(E_1, E_2)` does not match any `$LEA$` pattern. We must use an addition tile.\n      `$cost_L(+(E_1, E_2)) = \\text{cost}(+) + cost_L(E_1) + cost_L(E_2) = 1 + 1 + 2 = 4$`.\n    - The root node `$E = +\\big(+(E_1, E_2), E_3\\big)` also does not match any `$LEA$` pattern. We must use an addition tile.\n      `$cost_L(E) = \\text{cost}(+) + cost_L(+(E_1, E_2)) + cost_L(E_3) = 1 + 4 + 2 = 7$`.\n\nTherefore, the minimal cost using all available tiles is `$C_{\\text{lea}} = 7$`.\n\n#### 2.3. Final Calculation\n\nWe are asked to compute `$D = C_{\\text{base}} - C_{\\text{lea}}$`.\nUsing our calculated values:\n`$D = 8 - 7 = 1$`.\nThe difference in cost is due to the ability to cover the subtree `$+(a, \\ll(a,3))$` with a single, lower-cost `$LEA$` instruction (cost `$1$`) instead of a combination of a shift and an add instruction (total cost `$2$`). For the other two potential `$LEA$` matches, the special tile offered no cost improvement over the generic composition.",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "While finding a low-cost cover is essential, a compiler's primary duty is to generate correct code. This practice explores the critical concept of \"legality\" in pattern matching, where a pattern might match an expression syntactically but be invalid due to subtle hardware constraints. This hypothetical scenario involving an overloaded instruction-encoding bit will challenge you to think beyond simple pattern matching and appreciate why compilers need precise legality predicates to ensure the generated instructions are actually valid on the target processor .",
            "id": "3679135",
            "problem": "Consider a code generator that uses tree-pattern matching for instruction selection. Expression trees use terminals for operations and leaves for operands; for example, a subtree $+(x, c)$ denotes integer addition of register value $x$ and constant $c$. Patterns carry legality predicates that constrain which target-machine encodings are valid.\n\nAssume a target architecture \"Zeta\" with an add-immediate instruction ADDI that is defined in two forms: an immediate form and a register form. The immediate form nominally uses a $k$-bit signed immediate field in two's complement, but due to a compact encoding, the most significant bit of the immediate subfield (the sign bit) is overloaded by the decoder as a form selector. Concretely, when the most significant immediate bit is $0$, the word decodes as ADDI with an immediate; when it is $1$, the word decodes as the register form and there is no immediate. Thus, even though the field is $k$ bits wide, only those constant values whose two's complement representation has a $0$ in the most significant bit are encodable as immediates. The two's complement representation of a signed $k$-bit integer $v$ has range $[-2^{k-1}, 2^{k-1}-1]$ and uses a $1$ in the most significant bit exactly for negative $v$.\n\nThe instruction selector has a tree-pattern for a decrement, DEC, expressed as a specialization of ADDI with the constant equal to $-1$, i.e., DEC is emitted when the pattern $+(x,-1)$ is matched and the legality predicate holds. The legality predicate used by the selector is the usual signed-$k$-bit encodability test: the immediate must satisfy $v \\in [-2^{k-1}, 2^{k-1}-1]$.\n\nYou must reason from the above definitions to determine whether matching $+(x,-1)$ to DEC is actually legal on Zeta, and explain the outcome precisely in terms of bit-level constraints implied by the overloaded sign-bit rule. Assume $k \\geq 2$ and that the selector enforces only the standard two's complement range test unless otherwise stated.\n\nWhich statement best describes the correct legality outcome and the implication for tree-pattern matching on $+(x,-1)$ under Zeta’s encoding rule?\n\nA. The match is always legal because $-1$ lies in $[-2^{k-1}, 2^{k-1}-1]$ for any $k \\geq 1$, so DEC is emitted as ADDI with immediate $-1$.\n\nB. The match is legal if and only if $k \\geq 2$, because for $k=1$ the range is too small; for $k \\geq 2$ the usual signed range test suffices, so DEC is always emitted.\n\nC. The match is illegal under Zeta’s overloaded sign-bit rule, because any negative immediate (including $-1$) has a $1$ in the most significant bit, which selects the register form and makes the immediate form invalid; the legality predicate must therefore reject $+(x,-1)$ for DEC, and the matcher must choose an alternative such as a register constant or a subtract-immediate with an unsigned $1$ if available.\n\nD. The match is legal because assemblers can encode $-1$ by modular wraparound to $2^k-1$; the selector emits DEC and the assembler fixes the encoding regardless of the sign bit.",
            "solution": "The problem statement will first be validated for scientific soundness, self-consistency, and clarity.\n\n### Step 1: Extract Givens\n-   **System**: A code generator using tree-pattern matching for instruction selection.\n-   **Expression Tree**: A subtree `$+(x, c)$` represents the addition of a register value `$x$` and a constant `$c$`.\n-   **Architecture**: A target architecture named \"Zeta\".\n-   **Instruction**: Zeta has an add-immediate instruction, `ADDI`, with an immediate form and a register form.\n-   **Immediate Field**: The immediate form uses a `$k$`-bit signed field in two's complement.\n-   **Encoding Rule**: The most significant bit (MSB) of the `$k$`-bit immediate field is overloaded.\n    -   If MSB is `$0$`, the instruction is decoded as `ADDI` with an immediate.\n    -   If MSB is `$1$`, the instruction is decoded as the register form of `ADDI`, and there is no immediate.\n-   **Encoding Consequence**: Only constant values `$v$` whose `$k$`-bit two's complement representation has an MSB of `$0$` are encodable as immediates.\n-   **Two's Complement Definition**: A signed `$k$`-bit integer `$v$` has a range of `$[-2^{k-1}, 2^{k-1}-1]$`. For a negative value, its two's complement representation has a `$1$` in the MSB.\n-   **Pattern Matching Rule**: The instruction selector has a pattern for a decrement operation, `DEC`, which is generated from the expression tree `$+(x, -1)$`.\n-   **Legality Predicate**: The predicate used by the instruction selector to validate the match is the standard signed `$k$`-bit range test: the immediate value `$v$` must satisfy `$v \\in [-2^{k-1}, 2^{k-1}-1]$`.\n-   **Assumptions**: `$k \\geq 2$`. The selector enforces only the standard range test.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientific Groundedness**: The problem is well-grounded in the principles of compiler design and computer architecture. Concepts like instruction selection, tree-pattern matching, instruction set architecture (ISA) quirks, immediate encoding, two's complement arithmetic, and legality predicates are standard topics in the field. The specific encoding rule, while hypothetical, is a realistic example of design trade-offs in ISAs.\n-   **Well-Posedness**: The problem is well-posed. It provides a clear set of rules for an architecture and a compiler, sets up a specific scenario, and asks for a logical deduction based on these rules. A unique, deterministic answer can be derived.\n-   **Objectivity**: The problem is stated in precise, objective, and technical language, free from ambiguity or subjective claims.\n\nThe problem does not exhibit any of the listed flaws. It is not scientifically unsound, as it uses correct definitions of two's complement and standard compiler concepts. It is not incomplete; the core of the problem lies in the discrepancy between the compiler's predicate and the hardware's reality, which is intentional. It is not unrealistic, ill-posed, or trivial.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. A solution will be derived.\n\n### Solution Derivation\nThe central task is to determine if matching the expression tree `$+(x, -1)$` to a `DEC` instruction, implemented as `ADDI` with an immediate of `$-1$`, is legal on the Zeta architecture. This requires comparing the legality as determined by the compiler's predicate with the legality as dictated by the hardware's decoding rules.\n\n1.  **Analyze the immediate value**: The immediate value in question is `$v = -1$`.\n\n2.  **Determine the `$k$`-bit two's complement representation of `$-1$`**:\n    The two's complement representation of a negative number `$-|N|$` in a `$k$`-bit system can be found by computing `$2^k - |N|$`. For `$-1$`, this is `$2^k - 1$`.\n    In binary, `$2^k$` is a `$1$` followed by `$k$` zeros (`$100...0$`, a `$(k+1)$`-bit number).\n    The value `$2^k - 1$` is therefore a sequence of `$k$` ones (`$11...1$` in `$k$` bits).\n    For example, with `$k=8$`, `$-1$` is `$11111111_2$`. With `$k=16$`, `$-1$` is `$1111111111111111_2$`.\n    Crucially, for any `$k \\ge 2$`, the most significant bit (MSB) of the `$k$`-bit two's complement representation of `$-1$` is always `$1$`.\n\n3.  **Apply the Zeta architecture's hardware decoding rule**:\n    The problem states that for the `ADDI` instruction, the immediate form is selected only when the MSB of the immediate field is `$0$`. If the MSB is `$1$`, the hardware decodes the instruction as the register form of `ADDI`.\n    Since the `$k$`-bit representation of `$-1$` has an MSB of `$1$`, an `ADDI` instruction with `$-1$` as an immediate would be misinterpreted by the Zeta CPU's decoder as the register form of the instruction. Therefore, it is **not possible** to legally encode `$-1$` as an immediate for the `ADDI` instruction on Zeta.\n\n4.  **Analyze the instruction selector's legality predicate**:\n    The problem states the selector uses the standard signed `$k$`-bit encodability test: an immediate `$v$` is legal if `$v \\in [-2^{k-1}, 2^{k-1}-1]$`.\n    For the value `$v = -1$` and the assumption `$k \\ge 2$`:\n    - The lower bound `-2^{k-1}` is always less than or equal to `$-1$` (e.g., for `$k=2$`, `$-2 \\le -1$`; for `$k=3$`, `$-4 \\le -1$`, etc.).\n    - The upper bound `$2^{k-1}-1$` is always greater than or equal to `$-1$` (e.g., for `$k=2$`, `$1 \\ge -1$`; for `$k=3$`, `$3 \\ge -1$`, etc.).\n    Thus, `$-1$` always satisfies the condition `$v \\in [-2^{k-1}, 2^{k-1}-1]$` for `$k \\ge 2$`.\n    This means the instruction selector, using its specified (but flawed) predicate, will incorrectly determine that the match is legal and attempt to emit an `ADDI` instruction with an immediate of `$-1$`.\n\n5.  **Conclusion**:\n    There is a direct conflict. The compiler's legality predicate passes, but the hardware's decoding rule makes the resulting instruction invalid or incorrect. The question asks whether the match is *actually* legal, which must be judged by the hardware's constraints, not the compiler's potentially faulty logic. Based on the hardware rules of the Zeta architecture, the match is **illegal**. A correctly implemented compiler for Zeta would need a more sophisticated legality predicate that checks not only the standard signed range but also the specific MSB constraint: in this case, it must verify that the immediate value is non-negative, `$v \\in [0, 2^{k-1}-1]$`.\n\n### Option-by-Option Analysis\n\n*   **A. The match is always legal because $-1$ lies in $[-2^{k-1}, 2^{k-1}-1]$ for any $k \\geq 1$, so DEC is emitted as ADDI with immediate $-1$.**\n    This statement correctly observes that `$-1$` satisfies the standard signed range check. However, it completely ignores the critical detail of the problem: Zeta's overloaded sign-bit rule, which forbids immediates with an MSB of `$1$`. The conclusion that the match is \"legal\" is fundamentally incorrect because legality is determined by the target architecture, not just the compiler's range check.\n    **Verdict: Incorrect.**\n\n*   **B. The match is legal if and only if $k \\geq 2$, because for $k=1$ the range is too small; for $k \\geq 2$ the usual signed range test suffices, so DEC is always emitted.**\n    The problem statement explicitly assumes `$k \\ge 2$`, making the discussion of `$k=1$` moot. More importantly, this option makes the same fundamental error as option A: it asserts that the \"usual signed range test suffices,\" which is false. This test is precisely what is insufficient for the Zeta architecture due to the special MSB rule.\n    **Verdict: Incorrect.**\n\n*   **C. The match is illegal under Zeta’s overloaded sign-bit rule, because any negative immediate (including $-1$) has a $1$ in the most significant bit, which selects the register form and makes the immediate form invalid; the legality predicate must therefore reject $+(x,-1)$ for DEC, and the matcher must choose an alternative such as a register constant or a subtract-immediate with an unsigned $1$ if available.**\n    This statement provides a complete and correct analysis.\n    1.  It correctly identifies the match as \"illegal under Zeta’s overloaded sign-bit rule.\"\n    2.  It provides the correct reason: any negative immediate (which includes `$-1$`) has an MSB of `$1$` in two's complement.\n    3.  It correctly deduces the consequence of this bit pattern: the CPU decoder will select the register form, making the intended immediate operation invalid.\n    4.  It correctly describes the implication for a proper compiler: the legality predicate *should* be designed to reject this pattern, and the compiler should seek an alternative instruction sequence.\n    **Verdict: Correct.**\n\n*   **D. The match is legal because assemblers can encode $-1$ by modular wraparound to $2^k-1$; the selector emits DEC and the assembler fixes the encoding regardless of the sign bit.**\n    This statement is flawed. The two's complement representation of `$-1$` *is* the bit pattern corresponding to the unsigned value `$2^k-1$`, but that is not the issue. The issue is the MSB of that bit pattern. The claim that \"the assembler fixes the encoding regardless of the sign bit\" contradicts the problem description. The sign bit's function is a physical property of the CPU's decoder, not a software convention that an assembler can override. The hardware will interpret the instruction based on the bit pattern it receives; no amount of assembler magic can change that.\n    **Verdict: Incorrect.**",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "Real-world performance is often influenced by factors that are difficult to predict with certainty. This advanced exercise moves beyond deterministic costs to model instruction selection as a decision under uncertainty. You will use probability and expected value to determine the optimal choice between two instruction sequences whose feasibility depends on various stochastic factors, providing insight into how modern compilers can make statistically-informed decisions to generate the best code on average .",
            "id": "3679177",
            "problem": "Consider a target machine similar to the Intel Complex Instruction Set Computer (CISC) architecture that provides a Load Effective Address (LEA) instruction capable of computing an address of the form $b + s \\cdot i + d$, where $b$ is a base register, $i$ is an index register, $s \\in \\{1,2,4,8\\}$ is a hardware-supported scale, and $d$ is a displacement. You are performing tree-pattern matching for instruction selection on the expression tree $x + (y \\ll k)$, where $x$ and $y$ are values in registers and $k$ is a nonnegative integer constant. Two candidate covers are available:\n\n- A single-instruction cover using LEA when it is feasible to encode $y \\ll k$ as $s \\cdot y$ with $s = 2^{k}$ (hence requiring $k \\in \\{0,1,2,3\\}$), subject to addressing mode constraints (index register usable and addressing form permitted). The cost of using LEA depends on $k$: for $k \\in \\{0,1,2\\}$ the LEA cost is $c_{\\mathrm{LEA}}(k) = 1.0$ (in abstract cost units), and for $k = 3$ the LEA cost is $c_{\\mathrm{LEA}}(3) = 1.3$ due to a scale-$8$ port pressure effect.\n- A two-instruction cover using an addition and a shift, i.e., $\\mathrm{ADD} + \\mathrm{SHL}$, which is always feasible and has total cost $c_{\\mathrm{ADD}} + c_{\\mathrm{SHL}} = 2.0$ (in the same abstract cost units).\n\nThe compiler’s register allocator and the surrounding context induce the following stochastic constraints, assumed independent:\n\n- The probability that $k$ is encodable for LEA, i.e., $k \\in \\{0,1,2,3\\}$, is $p_{S} = 0.65$. Conditional on being encodable, the distribution of $k$ is: $\\Pr(k = 0) = 0.25$, $\\Pr(k = 1) = 0.25$, $\\Pr(k = 2) = 0.35$, and $\\Pr(k = 3) = 0.15$.\n- The probability that the index register $y$ is usable in the LEA addressing mode (e.g., it is not the stack pointer) is $p_{I} = 0.90$.\n- The probability that the required LEA addressing form is permitted by the current mode constraints (e.g., displacement form and register destination) is $p_{M} = 0.80$.\n\nUse the foundational definitions that instruction selection seeks a minimum-cost cover and that expected cost is the probability-weighted average of costs. Model feasibility for LEA with an indicator that requires all constraints to hold simultaneously and assume independence of these constraints.\n\nDerive, from first principles, the expected minimal cost for covering the expression $x + (y \\ll k)$ under these conditions, and compute the final numerical value. Round your final numerical answer to five significant figures. Express the final cost in abstract cost units.",
            "solution": "The problem requires the derivation of the expected minimal cost for covering the expression tree $x + (y \\ll k)$. The selection is between two candidate covers: a single `LEA` instruction and a two-instruction sequence of `ADD` + `SHL`. The choice depends on the feasibility and cost of the `LEA` instruction, which are governed by stochastic constraints.\n\nLet $C_{min}$ be the random variable representing the minimal cost for covering the expression. We are tasked with computing its expected value, $E[C_{min}]$.\n\nFirst, we define the events that determine the feasibility of the `LEA` instruction. The `LEA` instruction can implement the expression as $x + s \\cdot y$, where the base register holds $x$, the index register holds $y$, the scale is $s=2^k$, and the displacement is $d=0$. Feasibility requires three independent conditions to be met:\n1.  Event $S$: The scale $s=2^k$ is supported by the hardware. The supported scales are $s \\in \\{1, 2, 4, 8\\}$, which corresponds to the shift amount $k$ being in the set $\\{0, 1, 2, 3\\}$. The probability of this event is given as $\\Pr(S) = p_S = 0.65$.\n2.  Event $I$: The register holding the value $y$ is usable as an index register. The probability is given as $\\Pr(I) = p_I = 0.90$.\n3.  Event $M$: The `LEA` addressing form is permitted by the current context. The probability is given as $\\Pr(M) = p_M = 0.80$.\n\nLet $F_{LEA}$ be the event that the `LEA` instruction is a feasible cover. Since the events $S$, $I$, and $M$ are independent, the probability of $F_{LEA}$ is the product of their individual probabilities:\n$$\n\\Pr(F_{LEA}) = \\Pr(S \\cap I \\cap M) = \\Pr(S)\\Pr(I)\\Pr(M) = p_S p_I p_M\n$$\nSubstituting the given numerical values:\n$$\n\\Pr(F_{LEA}) = 0.65 \\times 0.90 \\times 0.80 = 0.468\n$$\nThe complementary event, $\\neg F_{LEA}$, where the `LEA` cover is not feasible, has a probability of:\n$$\n\\Pr(\\neg F_{LEA}) = 1 - \\Pr(F_{LEA}) = 1 - 0.468 = 0.532\n$$\n\nNext, we establish the cost associated with each scenario. The instruction selection process seeks a minimal-cost cover.\nThe cost of the two-instruction (`ADD` + `SHL`) cover is constant: $C_{AS} = 2.0$. This cover is always available.\nThe cost of the `LEA` cover, $C_{LEA}(k)$, depends on the value of $k$:\n$$\nC_{LEA}(k) = \\begin{cases} 1.0  \\text{if } k \\in \\{0, 1, 2\\} \\\\ 1.3  \\text{if } k = 3 \\end{cases}\n$$\nIf the `LEA` instruction is not feasible (event $\\neg F_{LEA}$), the only choice is the `ADD`+`SHL` sequence, so the cost is $C_{min} = C_{AS} = 2.0$.\nIf the `LEA` instruction is feasible (event $F_{LEA}$), the compiler chooses the cover with the lower cost: $C_{min} = \\min(C_{LEA}(k), C_{AS})$. The event $F_{LEA}$ implies that $k \\in \\{0, 1, 2, 3\\}$. For these values of $k$, $C_{LEA}(k)$ is either $1.0$ or $1.3$. Both are less than $C_{AS} = 2.0$. Therefore, if `LEA` is feasible, it is always the minimal cost choice. Thus, if $F_{LEA}$ occurs, $C_{min} = C_{LEA}(k)$.\n\nWe can now compute the expected minimal cost $E[C_{min}]$ using the law of total expectation, conditioning on the feasibility of `LEA`:\n$$\nE[C_{min}] = \\Pr(F_{LEA}) \\cdot E[C_{min} | F_{LEA}] + \\Pr(\\neg F_{LEA}) \\cdot E[C_{min} | \\neg F_{LEA}]\n$$\nWe have already determined the components:\n$E[C_{min} | \\neg F_{LEA}] = C_{AS} = 2.0$.\n$E[C_{min} | F_{LEA}] = E[C_{LEA}(k) | F_{LEA}]$.\n\nThe expectation $E[C_{LEA}(k) | F_{LEA}]$ is the expected cost of `LEA` given that it is feasible. Since $F_{LEA} = S \\cap I \\cap M$ and the value of $k$ is independent of events $I$ and $M$, this conditional expectation simplifies:\n$$\nE[C_{LEA}(k) | F_{LEA}] = E[C_{LEA}(k) | S \\cap I \\cap M] = E[C_{LEA}(k) | S]\n$$\nThis is the expected cost of `LEA`, given that the shift amount $k$ is encodable. We compute this using the provided conditional probabilities for $k$:\n$$\nE[C_{LEA}(k) | S] = \\sum_{j \\in \\{0,1,2,3\\}} C_{LEA}(j) \\cdot \\Pr(k=j | S)\n$$\nSubstituting the given values:\n$$\nE[C_{LEA}(k) | S] = C_{LEA}(0)\\Pr(k=0|S) + C_{LEA}(1)\\Pr(k=1|S) + C_{LEA}(2)\\Pr(k=2|S) + C_{LEA}(3)\\Pr(k=3|S)\n$$\n$$\nE[C_{LEA}(k) | S] = (1.0)(0.25) + (1.0)(0.25) + (1.0)(0.35) + (1.3)(0.15)\n$$\n$$\nE[C_{LEA}(k) | S] = 1.0 \\cdot (0.25 + 0.25 + 0.35) + 1.3 \\cdot 0.15\n$$\n$$\nE[C_{LEA}(k) | S] = 1.0 \\cdot (0.85) + 0.195 = 0.85 + 0.195 = 1.045\n$$\nSo, the expected cost when `LEA` is feasible is $E[C_{min} | F_{LEA}] = 1.045$.\n\nFinally, we substitute all values back into the formula for $E[C_{min}]$:\n$$\nE[C_{min}] = (\\Pr(F_{LEA}))(E[C_{min} | F_{LEA}]) + (\\Pr(\\neg F_{LEA}))(E[C_{min} | \\neg F_{LEA}])\n$$\n$$\nE[C_{min}] = (0.468)(1.045) + (0.532)(2.0)\n$$\n$$\nE[C_{min}] = 0.48906 + 1.064 = 1.55306\n$$\nThe problem requires the answer to be rounded to five significant figures.\n$$\nE[C_{min}] \\approx 1.5531\n$$\nThis is the expected minimal cost for covering the expression, in abstract cost units.",
            "answer": "$$ \\boxed{1.5531} $$"
        }
    ]
}