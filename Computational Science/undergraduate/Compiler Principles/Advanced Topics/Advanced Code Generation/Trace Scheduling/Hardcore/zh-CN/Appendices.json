{
    "hands_on_practices": [
        {
            "introduction": "迹调度（trace scheduling）的第一步是识别出程序中最常执行的“热路径”，即迹。这个选择过程并非凭空猜测，而是基于性能剖析数据（profile data）的量化决策。本练习将引导你推导一个简洁而强大的启发式评分函数，用于权衡优化某条路径所带来的潜在收益与补偿代码的开销，从而做出明智的选择。",
            "id": "3676420",
            "problem": "迹调度是一种编译技术，它在控制流图 (CFG) 中选择一条高概率路径（一条迹），并应用推测性代码移动来优化该路径，同时通过恢复代码来补偿迹外的执行。考虑控制流图中的一条边，可以在其上推测性地应用一项优化。设该边的动态执行概率为 $p$，若该优化在该边上实现，估计的周期节省为 $b$（收益），若推测失败，补偿的估计周期开销为 $c$（成本）。假设以下原则成立：\n- 在单条边上进行推测性优化的观测性能影响被建模为一个随机变量，如果该边执行，则其值为 $b$；如果该边不执行，则其值为 $-c$。\n- 期望性能影响是在该边执行概率 $p$ 下的平均值。\n- 在性能影响相互独立的假设下，一条迹内不同边的分数可加性地聚合。\n- 评分函数 $w(p,b,c)$ 对 $b$ 和 $c$ 都是线性的，对 $b$ 严格递增，对 $c$ 严格递减，并满足归一化约束 $w(1,b,0)=b$ 和 $w(0,0,c)=-c$。\n\n任务 1：仅使用上述原则和概率论中的期望定义，推导出边评分函数 $w(p,b,c)$ 的闭式解析表达式。\n\n任务 2：应用你推导出的评分函数，在以下控制流图中选择主迹。该控制流图有一个起始节点 $S$，其后有两个分支，通向两条不同的路径，这两条路径在节点 $D$ 处重新汇合。两个候选迹是：\n- 迹 $T_1$：$S \\rightarrow B_1 \\rightarrow C \\rightarrow D$\n- 迹 $T_2$：$S \\rightarrow B_2 \\rightarrow E \\rightarrow D$\n\n对于每条边，提供了剖析执行概率 $p$、收益 $b$（单位：周期）和成本 $c$（单位：周期）：\n- 边 $e_1: S \\rightarrow B_1$：$p=0.7$，$b=8$，$c=3$\n- 边 $e_2: B_1 \\rightarrow C$：$p=0.9$，$b=5$，$c=2$\n- 边 $e_3: C \\rightarrow D$：$p=0.95$，$b=4$，$c=4$\n- 边 $e_4: S \\rightarrow B_2$：$p=0.3$，$b=12$，$c=9$\n- 边 $e_5: B_2 \\rightarrow E$：$p=0.8$，$b=6$，$c=1$\n- 边 $e_6: E \\rightarrow D$：$p=0.85$，$b=3$，$c=5$\n\n通过将迹上各边的分数相加来计算每条迹的总分，并选择总分较高的迹作为主迹。报告所选迹的总分。以周期为单位表示你的答案。无需四舍五入。",
            "solution": "该问题被评估为有效，因为它在编译器理论方面有科学依据，问题定义明确、客观且自包含。所有必要的信息都已提供，并且前提与迹选择的标准启发式模型一致。\n\n**第 1 部分：边评分函数的推导**\n\n问题要求基于一组源自概率论的原则，推导出边评分函数 $w(p, b, c)$。\n\n第一个原则指出，在单条边上进行推测性优化的性能影响是一个随机变量，我们称之为 $X$。这个随机变量可以取两个值：\n1.  如果优化成功，则获得 $b$ 个周期的收益，这发生在边被执行时。此事件的概率为 $p$。\n2.  如果优化不成功（即推测失败），则产生 $c$ 个周期的成本（表示为负收益 $-c$），这发生在边未被执行时。因此，此事件的概率为 $1-p$。\n\n第二个原则指出，评分函数 $w(p, b, c)$ 是期望性能影响。离散随机变量的期望值是每个可能值与其概率乘积的总和。将此定义应用于随机变量 $X$：\n$$\nE[X] = \\sum_{i} x_i P(X=x_i)\n$$\n在我们的情况下，值为 $b$ 和 $-c$，概率分别为 $p$ 和 $1-p$。\n$$\nw(p, b, c) = E[X] = (b \\cdot p) + ((-c) \\cdot (1-p))\n$$\n简化此表达式，得到评分函数的闭式解析表达式：\n$$\nw(p, b, c) = bp - c(1-p)\n$$\n我们必须根据问题中陈述的其余原则来验证这个推导出的函数。\n- **线性性**：函数 $w(p, b, c) = p \\cdot b + (p-1) \\cdot c$ 是关于 $b$ 和 $c$ 的线性函数。此条件满足。\n- **单调性**：要检查其是否对 $b$ 严格递增，我们对 $b$ 求偏导数：\n$$\n\\frac{\\partial w}{\\partial b} = p\n$$\n由于 $p$ 是一个概率，所以 $0 \\le p \\le 1$。对于任何具有非零执行概率（$p>0$）的边，该函数对 $b$ 是严格递增的。\n要检查其是否对 $c$ 严格递减，我们对 $c$ 求偏导数：\n$$\n\\frac{\\partial w}{\\partial c} = -(1-p) = p-1\n$$\n由于 $p \\le 1$，所以 $p-1 \\le 0$。对于任何推测可能失败的边（$p1$），该函数对 $c$ 是严格递减的。对于非平凡情况，两个单调性条件都满足。\n- **归一化**：我们检查两个归一化约束：\n$$\nw(1, b, 0) = b \\cdot 1 - 0 \\cdot (1-1) = b\n$$\n$$\nw(0, 0, c) = 0 \\cdot 0 - c \\cdot (1-0) = -c\n$$\n两个约束都满足。推导出的函数 $w(p,b,c) = bp - c(1-p)$ 是正确的。\n\n**第 2 部分：应用于控制流图**\n\n第三个原则指出，一条迹的总分是其构成边的分数之和。我们现在将把推导出的评分函数应用于两个候选迹 $T_1$ 和 $T_2$ 中的每条边。\n\n**迹 $T_1$：$S \\rightarrow B_1 \\rightarrow C \\rightarrow D$**\n该迹由边 $e_1$、$e_2$ 和 $e_3$ 组成。\n\n- **边 $e_1: S \\rightarrow B_1$**：$p_1=0.7$，$b_1=8$，$c_1=3$。\n$$\nw_1 = b_1 p_1 - c_1(1-p_1) = 8(0.7) - 3(1-0.7) = 5.6 - 3(0.3) = 5.6 - 0.9 = 4.7\n$$\n- **边 $e_2: B_1 \\rightarrow C$**：$p_2=0.9$，$b_2=5$，$c_2=2$。\n$$\nw_2 = b_2 p_2 - c_2(1-p_2) = 5(0.9) - 2(1-0.9) = 4.5 - 2(0.1) = 4.5 - 0.2 = 4.3\n$$\n- **边 $e_3: C \\rightarrow D$**：$p_3=0.95$，$b_3=4$，$c_3=4$。\n$$\nw_3 = b_3 p_3 - c_3(1-p_3) = 4(0.95) - 4(1-0.95) = 3.8 - 4(0.05) = 3.8 - 0.2 = 3.6\n$$\n\n迹 $T_1$ 的总分是各边分数之和：\n$$\n\\text{Score}(T_1) = w_1 + w_2 + w_3 = 4.7 + 4.3 + 3.6 = 12.6\n$$\n\n**迹 $T_2$：$S \\rightarrow B_2 \\rightarrow E \\rightarrow D$**\n该迹由边 $e_4$、$e_5$ 和 $e_6$ 组成。\n\n- **边 $e_4: S \\rightarrow B_2$**：$p_4=0.3$，$b_4=12$，$c_4=9$。\n$$\nw_4 = b_4 p_4 - c_4(1-p_4) = 12(0.3) - 9(1-0.3) = 3.6 - 9(0.7) = 3.6 - 6.3 = -2.7\n$$\n- **边 $e_5: B_2 \\rightarrow E$**：$p_5=0.8$，$b_5=6$，$c_5=1$。\n$$\nw_5 = b_5 p_5 - c_5(1-p_5) = 6(0.8) - 1(1-0.8) = 4.8 - 1(0.2) = 4.8 - 0.2 = 4.6\n$$\n- **边 $e_6: E \\rightarrow D$**：$p_6=0.85$，$b_6=3$，$c_6=5$。\n$$\nw_6 = b_6 p_6 - c_6(1-p_6) = 3(0.85) - 5(1-0.85) = 2.55 - 5(0.15) = 2.55 - 0.75 = 1.8\n$$\n\n迹 $T_2$ 的总分是这些分数之和：\n$$\n\\text{Score}(T_2) = w_4 + w_5 + w_6 = -2.7 + 4.6 + 1.8 = 3.7\n$$\n\n**结论**\n\n为了选择主迹，我们比较总分：\n$\\text{Score}(T_1) = 12.6$\n$\\text{Score}(T_2) = 3.7$\n\n由于 $12.6 > 3.7$，迹 $T_1$ 的分数更高，因此被选为主迹。问题要求报告所选迹的总分。\n所选迹 $T_1$ 的总分是 $12.6$ 个周期。",
            "answer": "$$\n\\boxed{12.6}\n$$"
        },
        {
            "introduction": "选定迹后，编译器会大胆地重排指令以提升性能，甚至进行推测性代码移动。本练习探讨了一个经典且棘手的场景：当两个内存地址可能重叠（aliasing）时，如何安全地将一个内存读取（load）操作移动到一个内存写入（store）操作之前。你将学习如何设计精确的运行时检查（runtime check）和恢复代码，以确保这种推测性移动在任何情况下都能保证程序的正确性。",
            "id": "3676434",
            "problem": "在迹调度（trace scheduling）中，编译器选择一条可能的路径（即迹），并执行激进的、有时是推测性的代码移动，前提是必须保持程序的语义。进行推理的一个基本依据是依赖模型：当且仅当两个内存操作的重排序不违反由别名（aliasing）引起的数据依赖时，该重排序才是合法的。具体来说，对于一个写入字节地址区间 $[P, P + w_s - 1]$ 的存储操作和一个从 $[Q, Q + w_l - 1]$ 读取的加载操作（其中 $P, Q$ 是整数地址，$w_s, w_l$ 是以字节为单位的访问宽度），将加载操作移动到存储操作之前的重排序是语义安全的，当且仅当这两个区间不相交，即当且仅当 $[P, P + w_s - 1] \\cap [Q, Q + w_l - 1] = \\emptyset$。当编译时别名分析无法证明不存在别名时，可以通过插入运行时检查（RC）和恢复代码来使推测性移动变得正确。\n\n考虑以下中间表示（三地址形式，仅标量采用静态单赋值（SSA）形式），其中内存是字节可寻址的，且访问可能非对齐。所有地址都是有效的（不会引发错误），并且所有内存操作都是顺序一致的。访问宽度为 $w_s = 4$ 字节和 $w_l = 4$ 字节。假设热点迹为 $\\text{B0} \\rightarrow \\text{B1} \\rightarrow \\text{B2} \\rightarrow \\text{B4}$。\n\n- 块 $\\text{B0}$：\n  - $1$: $t_0 \\leftarrow g(x)$\n  - $2$: goto $\\text{B1}$\n\n- 块 $\\text{B1}$：\n  - $3$: $*p \\leftarrow h(t_0)$\n  - $4$: if $c$ then goto $\\text{B2}$ else goto $\\text{B3}$\n\n- 块 $\\text{B2}$ （在迹上）：\n  - $5$: $v \\leftarrow *q$\n  - $6$: $y_1 \\leftarrow v + k$\n  - $7$: goto $\\text{B4}$\n\n- 块 $\\text{B3}$ （不在迹上）：\n  - $8$: $y_2 \\leftarrow y_0 + k$\n  - $9$: goto $\\text{B4}$\n\n- 块 $\\text{B4}$：\n  - $10$: $y \\leftarrow \\phi(y_1, y_2)$\n\n这里，$p, q$ 是地址值变量，$k$ 是一个标量，$g(\\cdot), h(\\cdot)$ 是无副作用的算术函数。指令 $3$ 的存储操作向地址区间 $[P, P + 3]$ 写入 $w_s = 4$ 字节，其中 $P$ 是 $p$ 的整数值。指令 $5$ 的加载操作从 $[Q, Q + 3]$ 读取 $w_l = 4$ 字节，其中 $Q$ 是 $q$ 的整数值。编译时别名分析产生别名不确定性 $U$，意味着它无法证明在热点迹上 $[P, P + 3] \\cap [Q, Q + 3] = \\emptyset$。\n\n你的任务是从以下选项中选择一个合法的迹调度方案，该方案在热点迹上将指令 $5$ 的加载操作提升到指令 $3$ 的存储操作之上，并包含一套正确且充分的运行时检查（RC）来验证该推测，以及一个在检查失败时能保持所有执行流原始语义的恢复路径纲要。运行时检查应使用关于 $P, Q, w_s, w_l$ 的整数地址比较来表示，并且在给定的假设（字节可寻址内存，可能存在非对齐的 $4$ 字节访问）下必须是正确的。恢复代码必须确保，在 RC 失败时，可观察到的效果与执行原始程序时相同。\n\n哪个选项是正确的？\n\nA. 调度方案：在 $\\text{B1}$ 中，在新的指令 $3'$ 处插入 RC：计算 $P \\leftarrow \\operatorname{uaddr}(p)$ 和 $Q \\leftarrow \\operatorname{uaddr}(q)$，然后测试 $((P + w_s \\le Q) \\lor (Q + w_l \\le P))$。如果 RC 通过，执行新的指令 $4'$：$v_{\\text{hoist}} \\leftarrow *$ $q$，然后执行原始指令 $3$：$*$ $p \\leftarrow h(t_0)$，接着是原始分支指令 $4$。在 $\\text{B2}$ 中，用 $5'$：$v \\leftarrow v_{\\text{hoist}}$ 替换指令 $5$。插入一个恢复块 $\\text{R}$，其纲要如下：在 $3'$ 处 RC 失败时，分支到 $\\text{R}$，$\\text{R}$ 会执行原始指令 $3$（存储操作），然后按程序顺序执行原始的控制和使用点：如果 $c$ 为真，则执行 $v \\leftarrow *$ $q$ 和 $y_1 \\leftarrow v + k$ 并跳转到 $\\text{B4}$；否则，执行 $y_2 \\leftarrow y_0 + k$ 并跳转到 $\\text{B4}$。无其他更改。这里 $\\operatorname{uaddr}(\\cdot)$ 表示指针的无符号整数地址。\n\nB. 调度方案：将指令 $5$ 移动到 $\\text{B0}$ 的末尾（在 $\\text{B1}$ 的任何代码之前），不进行 RC，理由是使用不同 SSA 名称的加载和存储可以交换顺序。在 $\\text{B2}$ 中，用提升后的值替换 $5$。由于加载没有副作用，因此不需要恢复代码。\n\nC. 调度方案：将指令 $5$ 提升到 $\\text{B1}$ 中指令 $3$ 的紧邻位置之前，并插入仅测试 $(P \\neq Q)$ 的 RC。如果 RC 通过，在 $\\text{B2}$ 中使用提升后的值；如果 RC 失败，则顺序执行指令 $3$ 及后续代码，如同原始代码一样。不需要单独的恢复块。\n\nD. 调度方案：保持指令 $5$ 在指令 $3$ 之后，但将其从 $\\text{B2}$ 移动到 $\\text{B1}$ 中分支指令 $4$ 之后，这样在不知道 $c$ 的值之前就执行加载操作。插入测试 $((P + w_s  Q) \\lor (Q + w_l  P))$ 的 RC。如果 RC 失败，先执行指令 $3$，然后再次执行指令 $5$ 以确保获得最新值。由于加载仍在存储之后，因此不需要额外的恢复代码。",
            "solution": "用户旨在识别迹调度中推测性代码移动的正确实现。具体任务是在热点迹上将一个加载指令提升到一个存储指令之上，这需要一个运行时检查（RC）和一个恢复路径，以在推测不安全的情况下保持程序语义。\n\n首先，我们建立支配此转换的基本原则。\n程序在块 $\\text{B1}$ 中包含一个存储指令 `$3$: $*p \\leftarrow h(t_0)$`，在块 $\\text{B2}$ 中包含一个加载指令 `$5$: v \\leftarrow *q$`。热点迹是 $\\text{B0} \\rightarrow \\text{B1} \\rightarrow \\text{B2} \\rightarrow \\text{B4}$。目标是将指令 `$5$` 的加载操作移动到指令 `$3$` 的存储操作之前的位置。\n\n存储操作向内存区间 $I_s = [P, P + w_s - 1] = [P, P + 3]$ 写入 `$w_s = 4$` 字节，其中 `$P$` 是指针 `$p$` 中地址的整数值。加载操作从内存区间 $I_l = [Q, Q + w_l - 1] = [Q, Q + 3]$ 读取 `$w_l = 4$` 字节，其中 `$Q$` 是指针 `$q$` 中地址的整数值。\n\n在热点迹的原始程序顺序中，加载在存储之后执行。如果内存区间 $I_s$ 和 $I_l$ 重叠，加载操作会读取可能由该存储操作写入的值。这构成了一种真正的数据依赖，也称为写后读（Read-After-Write, RAW）依赖。\n\n将加载提升到在存储之前执行，意味着加载操作会在存储有机会更新内存*之前*读取内存中的值。如果区间 $I_s$ 和 $I_l$ 重叠，这种重排序会改变加载读取到的值，从而违反程序语义。仅当两个区间不重叠时，重排序才是合法的。\n\n问题陈述中指出，编译时别名分析无法证明指针 `$p$` 和 `$q$` 不存在别名。因此，需要进行推测性执行。加载被激进地移动，并插入一个运行时检查（RC）以在执行时验证此推测的安全性。\n\n安全重排序的条件是内存区间不相交，正如问题所述：$I_s \\cap I_l = \\emptyset$。对于两个区间 $[a, b]$ 和 $[c, d]$，它们不相交的充要条件是一个区间在另一个区间开始之前结束。将此应用于我们的内存访问，条件是：\n$$(P + w_s - 1   Q) \\lor (Q + w_l - 1   P)$$\n由于内存地址是整数，严格不等式 `$a   b$` 等价于 `$a + 1 \\le b`。因此，该条件可以重写为：\n$$(P + w_s \\le Q) \\lor (Q + w_l \\le P)$$\n给定 `$w_s = 4$` 和 `$w_l = 4$`，正确的运行时检查应为：\n$$((P + 4 \\le Q) \\lor (Q + 4 \\le P))$$\n这是 RC 必须测试的条件。如果其求值结果为真，则推测是安全的，程序可以继续使用推测性加载的值。\n\n如果 RC 失败，则意味着内存区间可能重叠（$I_s \\cap I_l \\neq \\emptyset$）。为了保持原始程序语义，执行必须恢复到原始的、非推测性的顺序。这就是恢复代码的目的。恢复路径必须确保：\n1.  存储操作（`$*p \\leftarrow \\dots$`）被执行。\n2.  原始的控制流（条件分支 `if $c$`）被执行。\n3.  如果原始路径是到 $\\text{B2}$（即 `$c$` 为真），则加载操作（`$v \\leftarrow *q$`）在存储操作*之后*执行，并且后续的计算（`$y_1 \\leftarrow v + k$`）被执行。\n4.  如果原始路径是到 $\\text{B3}$（即 `$c$` 为假），则 $\\text{B3}$ 中的代码被正常执行。\n\n最后，我们考虑控制推测。加载操作从一个条件执行的块（$\\text{B2}$）移动到了迹上一个无条件执行的块（$\\text{B1}$）。这是安全的，因为问题陈述中指出所有内存访问都是有效的（不会引发错误）。\n\n在建立了这些原则之后，我们来评估每个选项。\n\n**A. 调度方案：在 $\\text{B1}$ 中，在新的指令 $3'$ 处插入 RC：计算 $P \\leftarrow \\operatorname{uaddr}(p)$ 和 $Q \\leftarrow \\operatorname{uaddr}(q)$，然后测试 $((P + w_s \\le Q) \\lor (Q + w_l \\le P))$。如果 RC 通过，执行新的指令 $4'$：$v_{\\text{hoist}} \\leftarrow *$ $q$，然后执行原始指令 $3$：$*$ $p \\leftarrow h(t_0)$，接着是原始分支指令 $4$。在 $\\text{B2}$ 中，用 $5'$：$v \\leftarrow v_{\\text{hoist}}$ 替换指令 $5$。插入一个恢复块 $\\text{R}$，其纲要如下：在 $3'$ 处 RC 失败时，分支到 $\\text{R}$，$\\text{R}$ 会执行原始指令 $3$（存储操作），然后按程序顺序执行原始的控制和使用点：如果 $c$ 为真，则执行 $v \\leftarrow *$ $q$ 和 $y_1 \\leftarrow v + k$ 并跳转到 $\\text{B4}$；否则，执行 $y_2 \\leftarrow y_0 + k$ 并跳转到 $\\text{B4}$。无其他更改。这里 $\\operatorname{uaddr}(\\cdot)$ 表示指针的无符号整数地址。**\n\n*   **运行时检查**：RC 被指定为 `$((P + w_s \\le Q) \\lor (Q + w_l \\le P))$`。这与我们推导出的不相交区间的正确条件完全匹配。\n*   **推测路径（RC 通过）**：代码将加载（`$v_{\\text{hoist}} \\leftarrow *q$`）提升到存储（`$*p \\leftarrow h(t_0)$`）之前。在块 $\\text{B2}$ 中，使用了提升后的加载结果。这正确地实现了推测性调度。\n*   **恢复路径（RC 失败）**：失败时，分支到一个恢复块 $\\text{R}$。该块首先执行存储操作（`$*p \\leftarrow h(t_0)$`）。然后，它通过检查 `$c$` 并执行来自块 $\\text{B2}$ 或 $\\text{B3}$ 的相应代码，正确地重新创建了原始程序的控制流。这忠实地为存储操作之后的所有可能控制流恢复了原始程序语义。\n\n此选项提供了一个完全正确且鲁棒的推测性加载提升实现，包括正确的 RC 和全面的恢复机制。\n\n**结论：正确**\n\n**B. 调度方案：将指令 $5$ 移动到 $\\text{B0}$ 的末尾（在 $\\text{B1}$ 的任何代码之前），不进行 RC，理由是使用不同 SSA 名称的加载和存储可以交换顺序。在 $\\text{B2}$ 中，用提升后的值替换 $5$。由于加载没有副作用，因此不需要恢复代码。**\n\n所提供的理由存在根本性缺陷。静态单赋值（SSA）形式适用于标量值（寄存器或变量），而不适用于通过指针访问的内存位置。指针 `$p$` 和 `$q$` 是不同的 SSA 变量这一事实，并不能提供任何关于它们所指向内存的信息。它们可能是别名，指向相同或重叠的内存区域。在没有运行时检查的情况下重排序可能存在别名的加载和存储，违反了数据依赖，因而在语义上是不正确的。\n\n**结论：不正确**\n\n**C. 调度方案：将指令 $5$ 提升到 $\\text{B1}$ 中指令 $3$ 的紧邻位置之前，并插入仅测试 $(P \\neq Q)$ 的 RC。如果 RC 通过，在 $\\text{B2}$ 中使用提升后的值；如果 RC 失败，则顺序执行指令 $3$ 及后续代码，如同原始代码一样。不需要单独的恢复块。**\n\n提议的运行时检查 `$P \\neq Q$` 是不充分的。内存访问是 `$4$` 字节宽（`$w_s=4, w_l=4$`）并且可能非对齐。例如，如果 `$P = 100$` 且 `$Q = 101$`，那么 `$P \\neq Q$`，但存储区间 $[100, 103]$ 和加载区间 $[101, 104]$ 重叠。在存储之前执行加载将是一个错误。检查必须考虑访问宽度，而这个检查没有做到。恢复的描述也比选项 A 模糊和不完整。\n\n**结论：不正确**\n\n**D. 调度方案：保持指令 $5$ 在指令 $3$ 之后，但将其从 $\\text{B2}$ 移动到 $\\text{B1}$ 中分支指令 $4$ 之后，这样在不知道 $c$ 的值之前就执行加载操作。插入测试 $((P + w_s  Q) \\lor (Q + w_l  P))$ 的 RC。如果 RC 失败，先执行指令 $3$，然后再次执行指令 $5$ 以确保获得最新值。由于加载仍在存储之后，因此不需要额外的恢复代码。**\n\n这个选项在多方面都有缺陷。\n1.  **调度目标**：主要目标是将加载*提升到存储之上*。该调度明确地将加载保持在存储*之后*（`保持指令 $5$ 在指令 $3$ 之后`），因此未能达到指定的目标。\n2.  **调度逻辑**：在一个基本块中，将一条指令放在终止分支*之后*在逻辑上是不可能的。这表明对控制流的理解有误。\n3.  **运行时检查**：提议的 RC 是 `$((P + w_s  Q) \\lor (Q + w_l  P))$`。这有细微的错误。如前所述，对于整数地址，正确的边界条件使用 `$\\le$`。例如，如果存储区间是 $[100, 103]$ 且加载区间是 $[104, 107]$，那么 `$P=100$`, `$w_s=4$`, `$Q=104$`。这两个区间不相交。然而，`$P+w_s = 104$`，所以条件 `$P+w_s  Q$`（即 `$104  104$`）为假。这个检查过于严格，会在此情况下错误地报告可能存在别名。\n4.  **恢复**：“不需要额外的恢复”的理由是基于加载仍在存储之后的事实，但这与跨越潜在数据依赖进行推测性重排序的整个前提相矛盾。\n\n**结论：不正确**\n\n综上所述，只有选项 A 提出了一个能够实现既定目标的调度方案，它具有数学上正确的运行时检查和完整、正确的恢复机制，能够在所有执行路径上保持程序语义。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在选定迹并优化指令序列后，最后一步是将这些指令映射到处理器的具体功能单元上，这个过程称为指令调度。本练习模拟了这一最终阶段，要求你在一个超长指令字（VLIW）处理器上，为给定的指令序列找到执行时间最短的调度方案。你需要巧妙地处理数据依赖、控制约束、硬件资源限制以及指令延迟，以实现最优的并行执行效率。",
            "id": "3676472",
            "problem": "考虑一个超长指令字（VLIW）流水线模型，该模型具有三个完全流水线化的功能单元：一个加载单元，延迟为 $L_{load}=4$；一个加法器，延迟为 $L_{add}=1$；以及一个乘法器，延迟为 $L_{mul}=3$。每个功能单元在每个周期最多能接收一条新指令，并且全局发射宽度为 $W=2$（所有单元在每个周期最多可以发射两条指令）。一条指令的结果在其发射后恰好 $L$ 个周期变为可用，一条依赖指令可以在其操作数变为可用的同一周期内发射。假设所有内存访问都是独立的（无别名冲突），没有存储指令，并且算术指令无副作用。所选的热路径通过一个条件分支，我们假设允许算术指令跨分支进行推测性移动，但加载指令不能在分支解析之前发射。分支谓词由路径中的一个加法指令计算。\n\n该程序路径包含以下指令，其显式数据依赖关系构成一个有向无环图（DAG）：\n\n- $L_1$: $\\text{r}_1 \\leftarrow \\text{M}[p]$ （加载），无依赖。\n- $L_2$: $\\text{r}_2 \\leftarrow \\text{M}[q]$ （加载），无依赖。\n- $A_1$: $\\text{r}_3 \\leftarrow \\text{r}_1 + \\text{r}_2$ （加法），依赖于 $L_1$ 和 $L_2$。\n- $M_1$: $\\text{r}_4 \\leftarrow \\text{r}_3 \\times s$ （乘法），依赖于 $A_1$。\n- $A_2$: $\\text{r}_5 \\leftarrow \\text{r}_4 + \\text{r}_2$ （加法），依赖于 $M_1$ 和 $L_2$。\n- $A_3$: $\\text{r}_6 \\leftarrow u + v$ （加法），无依赖；当 $A_3$ 完成时，分支解析。\n- $L_3$: $\\text{r}_8 \\leftarrow \\text{M}[r]$ （加载），受该分支的控制依赖，并且不能在分支解析前发射。\n- $M_2$: $\\text{r}_9 \\leftarrow \\text{r}_8 \\times \\text{r}_4$ （乘法），依赖于 $L_3$ 和 $M_1$。\n- $A_4$: $\\text{r}_{10} \\leftarrow \\text{r}_9 + \\text{r}_3$ （加法），依赖于 $M_2$ 和 $A_1$。\n- $M_3$: $\\text{r}_{12} \\leftarrow \\text{r}_5 \\times \\text{r}_3$ （乘法），依赖于 $A_2$ 和 $A_1$。\n- $A_5$: $\\text{r}_{11} \\leftarrow \\text{r}_{10} + \\text{r}_{12}$ （加法），依赖于 $A_4$ 和 $M_3$。\n\n假设输入 $p$、$q$、$r$、$s$、$u$ 和 $v$ 在周期 $0$ 时可用，并从发射周期 $0$ 开始计算周期数。遵守所有数据依赖、控制约束（加载指令不能先于分支解析）、各单元的发射限制以及全局发射宽度 $W=2$。\n\n调度此路径以最小化完成时间（makespan）$T$，定义为从周期 $0$ 的第一次发射开始，$A_5$ 完成时所在的周期。以单个实数值数字的形式提供最小的 $T$（单位为周期）。无需四舍五入；将 $T$ 表示为整数个周期。",
            "solution": "用户提供的问题是一个针对超长指令字（VLIW）架构的、定义明确的指令调度练习。所有指定的约束——功能单元延迟、发射宽度以及数据/控制依赖——都清晰、一致，并且在计算机体系结构和编译器设计的原则上有科学依据。因此，该问题被认为是有效的，下面将构建一个正式的解决方案。\n\n目标是确定给定指令序列的最小完成时间（makespan）$T$。完成时间定义为最后一条指令 $A_5$ 的完成周期。我们从周期 $0$ 开始。\n\n设 $t_{issue}(I)$ 是指令 $I$ 发射的周期，$t_{complete}(I)$ 是其结果可用的周期。对于延迟为 $L$ 的指令，其完成时间为 $t_{complete}(I) = t_{issue}(I) + L$。一条指令只有在满足其所有数据依赖（即其操作数可用）、解析其控制依赖，并且所需硬件资源可用的情况下才能发射。\n\n硬件参数如下：\n- 加载单元延迟：$L_{load} = 4$ 周期。有 $1$ 个加载单元。\n- 加法器单元延迟：$L_{add} = 1$ 周期。有 $1$ 个加法器单元。\n- 乘法器单元延迟：$L_{mul} = 3$ 周期。有 $1$ 个乘法器单元。\n- 全局发射宽度：$W=2$ 条指令/周期。\n\n指令依赖关系如下：\n- $A_1$ 依赖于 $L_1$ 和 $L_2$。\n- $M_1$ 依赖于 $A_1$。\n- $A_2$ 依赖于 $M_1$ 和 $L_2$。\n- $L_3$ 受 $A_3$ 的控制依赖（不能在 $A_3$ 完成前发射）。\n- $M_2$ 依赖于 $L_3$ 和 $M_1$。\n- $A_4$ 依赖于 $M_2$ 和 $A_1$。\n- $M_3$ 依赖于 $A_2$ 和 $A_1$。\n- $A_5$ 依赖于 $A_4$ 和 $M_3$。\n\n解决方案涉及构建一个最优调度。一个关键步骤是分析由依赖关系和有限资源施加的约束。用于三条加载指令（$L_1, L_2, L_3$）的单个加载单元以及较长的加载延迟（$L_{load}=4$）是主要的瓶颈。\n\n首先，我们确定三条加载指令的最优调度，这些指令必须串行执行。设它们的发射周期为 $t_{issue}(L_1), t_{issue}(L_2), t_{issue}(L_3)$。为最小化完成时间，它们应尽早调度，以某种排列方式占据周期 $0$、$1$ 和 $2$ 的加载单元。\n\n指令 $A_3$（延迟 $L_{add}=1$）没有数据依赖。但是，它解析了一个控制 $L_3$ 执行的分支条件。这施加了控制依赖 $t_{issue}(L_3) \\ge t_{complete}(A_3) = t_{issue}(A_3) + 1$。为了让 $L_3$ 能够尽早发射，$A_3$ 必须在周期 $0$ 发射。这是可能的，因为它可以与来自不同功能单元的另一条指令共同发射，受全局发射宽度 $W=2$ 的限制。\n如果我们在周期 $0$ 发射 $A_3$，它将在周期 $t_{complete}(A_3) = 0 + 1 = 1$ 完成。对 $L_3$ 的约束变为 $t_{issue}(L_3) \\ge 1$。这意味着 $L_3$ 不能在周期 $0$ 发射。\n\n加载指令的发射槽是周期 $0, 1, 2$。由于 $t_{issue}(L_3) \\ge 1$，在周期 $0$ 发射的指令必须是 $L_1$ 或 $L_2$。另外两条加载指令将在周期 $1$ 和 $2$ 发射。这导致了加载指令排序的两种主要情况：\n\n情况1：优先处理 $L_1$ 和 $L_2$。加载指令的发射序列是 $(L_1, L_2, L_3)$ 或 $(L_2, L_1, L_3)$。我们来分析发射时间为 $t_{issue}(L_1)=0$、$t_{issue}(L_2)=1$ 和 $t_{issue}(L_3)=2$ 的情况。\n- $t_{complete}(L_1) = 0+4=4$。\n- $t_{complete}(L_2) = 1+4=5$。\n- $t_{complete}(L_3) = 2+4=6$。\n\n现在我们计算依赖指令的最早可能完成时间（这是一个尽早调度（ASAP）的方案，我们稍后将根据所有资源约束进行验证）：\n- $A_1$ 依赖于 $L_1, L_2$：$t_{issue}(A_1) \\ge \\max(t_c(L_1), t_c(L_2)) = 5$。延迟 $L_{add}=1$，所以 $t_{complete}(A_1) \\ge 5+1=6$。\n- $M_1$ 依赖于 $A_1$：$t_{issue}(M_1) \\ge 6$。延迟 $L_{mul}=3$，所以 $t_{complete}(M_1) \\ge 6+3=9$。\n- $A_2$ 依赖于 $M_1, L_2$：$t_{issue}(A_2) \\ge \\max(9, 5) = 9$。延迟 $L_{add}=1$，所以 $t_{complete}(A_2) \\ge 9+1=10$。\n- $M_2$ 依赖于 $L_3, M_1$：$t_{issue}(M_2) \\ge \\max(6, 9) = 9$。延迟 $L_{mul}=3$，所以 $t_{complete}(M_2) \\ge 9+3=12$。\n- $M_3$ 依赖于 $A_2, A_1$：$t_{issue}(M_3) \\ge \\max(10, 6) = 10$。延迟 $L_{mul}=3$，所以 $t_{complete}(M_3) \\ge 10+3=13$。\n- $A_4$ 依赖于 $M_2, A_1$：$t_{issue}(A_4) \\ge \\max(12, 6) = 12$。延迟 $L_{add}=1$，所以 $t_{complete}(A_4) \\ge 12+1=13$。\n- $A_5$ 依赖于 $A_4, M_3$：$t_{issue}(A_5) \\ge \\max(13, 13) = 13$。延迟 $L_{add}=1$，所以 $t_{complete}(A_5) \\ge 13+1=14$。\n此分析为这种加载顺序确立了完成时间的下界为 $T \\ge 14$ 个周期。\n\n情况2：优先处理 $L_3$ 而不是 $L_2$。加载指令的发射序列是 $(L_1, L_3, L_2)$，发射时间为 $t_{issue}(L_1)=0$、$t_{issue}(L_3)=1$ 和 $t_{issue}(L_2)=2$。\n- $t_{complete}(L_1) = 0+4=4$。\n- $t_{complete}(L_3) = 1+4=5$。\n- $t_{complete}(L_2) = 2+4=6$。\n\n现在我们计算最早完成时间：\n- $A_1$ 依赖于 $L_1, L_2$：$t_{issue}(A_1) \\ge \\max(4, 6) = 6$。所以，$t_{complete}(A_1) \\ge 6+1=7$。\n- $M_1$ 依赖于 $A_1$：$t_{issue}(M_1) \\ge 7$。所以，$t_{complete}(M_1) \\ge 7+3=10$。\n- $A_2$ 依赖于 $M_1, L_2$：$t_{issue}(A_2) \\ge \\max(10, 6) = 10$。所以，$t_{complete}(A_2) \\ge 10+1=11$。\n- $M_2$ 依赖于 $L_3, M_1$：$t_{issue}(M_2) \\ge \\max(5, 10) = 10$。所以，$t_{complete}(M_2) \\ge 10+3=13$。\n- $M_3$ 依赖于 $A_2, A_1$：$t_{issue}(M_3) \\ge \\max(11, 7) = 11$。所以，$t_{complete}(M_3) \\ge 11+3=14$。\n- $A_4$ 依赖于 $M_2, A_1$：$t_{issue}(A_4) \\ge \\max(13, 7) = 13$。所以，$t_{complete(A_4)} \\ge 13+1=14$。\n- $A_5$ 依赖于 $A_4, M_3$：$t_{issue}(A_5) \\ge \\max(14, 14) = 14$。所以，$t_{complete}(A_5) \\ge 14+1=15$。\n这种加载顺序产生的最小完成时间为 $T=15$ 个周期。\n\n比较这两种情况，最小完成时间为 $14$ 个周期，这是通过优先发射加载指令 $L_1$ 和 $L_2$ 实现的。下面构建了一个实现此完成时间的具体调度，验证了 $14$ 这个下界是可以达到的。\n\n最优调度 ($T=14$)：\n- 周期 $0$：发射 $L_1$（加载单元）和 $A_3$（加法单元）。（使用 $W=2$）。$A_3$ 在周期 $1$ 完成。$L_1$ 在周期 $4$ 完成。\n- 周期 $1$：发射 $L_2$（加载单元）。（使用 $W=1$）。$L_2$ 在周期 $5$ 完成。\n- 周期 $2$：发射 $L_3$（加载单元）。（使用 $W=1$）。由于 $A_3$ 已完成，可以发射 $L_3$。$L_3$ 在周期 $6$ 完成。\n- 周期 $3, 4$：空闲。\n- 周期 $5$：发射 $A_1$（加法单元）。来自 $L_1$（周期 $4$ 就绪）和 $L_2$（周期 $5$ 就绪）的操作数可用。$A_1$ 在周期 $6$ 完成。\n- 周期 $6$：发射 $M_1$（乘法单元）。来自 $A_1$（周期 $6$ 就绪）的操作数可用。$M_1$ 在周期 $9$ 完成。\n- 周期 $7, 8$：空闲。\n- 周期 $9$：发射 $A_2$（加法单元）和 $M_2$（乘法单元）。（使用 $W=2$）。\n  - $A_2$ 的操作数来自 $M_1$（在 $9$ 就绪）和 $L_2$（在 $5$ 就绪），均可用。$A_2$ 在周期 $10$ 完成。\n  - $M_2$ 的操作数来自 $L_3$（在 $6$ 就绪）和 $M_1$（在 $9$ 就绪），均可用。$M_2$ 在周期 $12$ 完成。\n- 周期 $10$：发射 $M_3$（乘法单元）。来自 $A_2$（在 $10$ 就绪）和 $A_1$（在 $6$ 就绪）的操作数可用。$M_3$ 在周期 $13$ 完成。\n- 周期 $11$：空闲。\n- 周期 $12$：发射 $A_4$（加法单元）。来自 $M_2$（在 $12$ 就绪）和 $A_1$（在 $6$ 就绪）的操作数可用。$A_4$ 在周期 $13$ 完成。\n- 周期 $13$：发射 $A_5$（加法单元）。来自 $A_4$（在 $13$ 就绪）和 $M_3$（在 $13$ 就绪）的操作数可用。$A_5$ 在周期 $14$ 完成。\n\n此调度有效，遵守所有约束，并达到了计算出的下界。因此，最小完成时间为 $14$ 个周期。",
            "answer": "$$\\boxed{14}$$"
        }
    ]
}