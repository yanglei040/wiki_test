{
    "hands_on_practices": [
        {
            "introduction": "指令调度的核心在于优化基本块（basic block）内的指令序列，这是编译器优化中最基础也最重要的任务之一。本练习将带你处理一个典型的场景：在多发射（dual-issue）处理器上调度一个向量点积计算。通过这个实践，你将学习如何识别并权衡数据依赖性（由计算的先后关系决定）和资源限制（由处理器的硬件能力决定），这是理解所有高级调度算法的基石。",
            "id": "3646497",
            "problem": "一个编译器针对一个用于浮点运算的双发射流水线，并且必须调度一个计算长度为$4$的点积的基本块。机器模型如下：该流水线每个周期最多可以向两个对称的槽中发射$W=2$个操作，除了发射宽度外没有结构性冒险，唯一的数据冒险由指令延迟决定。一个浮点乘法指令的延迟为$L_{\\text{mul}}=4$个周期，一个浮点加法指令的延迟为$L_{\\text{add}}=1$个周期。一个指令的结果在其发射后恰好$L$个周期后可用，其中$L$是该指令的延迟。所有输入操作数在周期$0$时可用，寄存器重命名消除了命名相关，并且基本块中没有内存操作。编译器可以在任何周期的任何槽中调度任何加法或乘法指令，但需满足上述约束。\n\n向量$\\{a_k\\}$和$\\{b_k\\}$（其中$k \\in \\{0,1,2,3\\}$）的点积计算为$s = \\sum_{k=0}^{3} a_k b_k$。要调度的基本块由四个独立的乘法指令（产生部分积）和通过三个加法指令进行平衡归约（产生最终的标量$s$）组成。设四个乘法指令表示为$m_0,m_1,m_2,m_3$，两个第一级加法指令为$a_{01}$和$a_{23}$，最后的加法指令为$a_f$。该基本块的有向无环图（Directed Acyclic Graph (DAG)）具有边$m_0 \\rightarrow a_{01}$、$m_1 \\rightarrow a_{01}$、$m_2 \\rightarrow a_{23}$、$m_3 \\rightarrow a_{23}$，以及$a_{01} \\rightarrow a_f$、$a_{23} \\rightarrow a_f$，边的权重等于生产者指令的延迟。\n\n从带有资源约束和固定延迟的DAG上的指令调度的基本原理出发，确定一个能最小化完成时间（makespan）的有效调度。识别哪些周期是完全填充的（两个发射槽都已使用），并识别依赖图中的一条关键路径。最后，报告$s$可用的最早周期索引，从周期$0$作为第一个发射机会开始计算。\n\n将最终答案表示为最小化的makespan（以周期为单位），为一个精确的整数，不带单位。",
            "solution": "该问题要求在一个双发射处理器上为一个基本块找到一个最优的指令调度。一个有效的调度必须同时满足由有向无环图（DAG）定义的数据依赖约束，以及由机器发射宽度给出的资源约束。目标是最小化makespan，即从执行开始到最终结果可用所需的时间。\n\n设$S_i$为指令$i$的发射周期，$L_i$为其延迟。指令$i$的结果在周期$S_i + L_i$开始时可用。依赖于指令$i$结果的指令$j$不能在此时间之前发射。指令集包括四个乘法指令$\\{m_0, m_1, m_2, m_3\\}$和三个加法指令$\\{a_{01}, a_{23}, a_f\\}$。延迟为$L_{\\text{mul}}=4$和$L_{\\text{add}}=1$。机器每个周期最多可以发射$W=2$条指令。所有输入在周期$0$时可用。\n\n首先，我们确定makespan的一个下界。makespan受计算依赖图中的最长路径（即关键路径）和可用硬件资源的限制。\n\n$1$. **数据依赖界限（关键路径）：** 计算的结构是$s = (a_0 b_0 + a_1 b_1) + (a_2 b_2 + a_3 b_3)$。这对应于一个DAG，其中乘法指令的结果输入给第一级加法指令，而第一级加法指令的结果又输入给最后的加法指令。从输入到最终结果的一条路径涉及一次乘法和两次加法。例如，涉及$m_0$的路径是$m_0 \\rightarrow a_{01} \\rightarrow a_f$。如果调度没有资源约束，它们的执行将因数据依赖而被串行化。如果$m_0$在周期$C_0=0$发射，其结果在$C_0 + L_{\\text{mul}} = 4$时可用。然后$a_{01}$可以在$C_1=4$时发射，其结果在$C_1 + L_{\\text{add}} = 5$时可用。最后，$a_f$可以在$C_2=5$时发射，最终结果$s$在$C_2 + L_{\\text{add}} = 6$时可用。因此，DAG的关键路径长度为$L_{\\text{mul}} + L_{\\text{add}} + L_{\\text{add}} = 4 + 1 + 1 = 6$个周期。因此，makespan必须至少为$6$个周期。\n\n$2$. **资源界限：** 基本块总共包含$7$条指令（$4$个乘法，$3$个加法）。对于双发射机器（$W=2$），发射所有指令至少需要$\\lceil \\frac{7}{2} \\rceil = 4$个周期。具体到乘法指令，有4条独立的指令。发射它们至少需要$\\lceil \\frac{4}{2} \\rceil = 2$个周期。\n\n我们将使用一种贪心方法（也称为列表调度）来构建一个调度。在每个周期，我们识别出“就绪”指令集——即那些数据依赖已满足的指令——并从中最多发射$W=2$条。\n\n**周期 $0$:**\n初始就绪集包含四个乘法指令：$\\{m_0, m_1, m_2, m_3\\}$，因为它们的输入都可用。\n我们可以发射其中的两个。我们发射$m_0$和$m_1$。\n- **调度：** 发射$m_0$，$m_1$。\n- **状态：** $m_0, m_1$正在执行中。它们的结果将在周期$0 + L_{\\text{mul}} = 4$时可用。\n\n**周期 $1$:**\n现在的就绪集包含剩下的乘法指令：$\\{m_2, m_3\\}$。\n我们同时发射$m_2$和$m_3$。\n- **调度：** 发射$m_2$，$m_3$。\n- **状态：** $m_0, m_1, m_2, m_3$正在执行中。$m_2, m_3$的结果将在周期$1 + L_{\\text{mul}} = 5$时可用。\n\n**周期 $2$和$3$:**\n没有指令就绪。加法指令$a_{01}$和$a_{23}$正在等待乘法指令的结果。这造成了停顿。\n- **调度：** 停顿（没有指令发射）。\n\n**周期 $4$:**\n来自$m_0$和$m_1$的结果现在可用。这使得指令$a_{01}$就绪，因为它的两个依赖都已满足。就绪集为$\\{a_{01}\\}$。\n- **调度：** 发射$a_{01}$。一个发射槽未使用。\n- **状态：** $a_{01}$的结果将在周期$4 + L_{\\text{add}} = 5$时可用。\n\n**周期 $5$:**\n来自$m_2$和$m_3$的结果可用。这使得指令$a_{23}$就绪。同样在周期$5$，$a_{01}$的结果也变为可用。就绪集为$\\{a_{23}\\}$。最终加法指令$a_f$的另一个输入尚未就绪。\n- **调度：** 发射$a_{23}$。一个发射槽未使用。\n- **状态：** $a_{23}$的结果将在周期$5 + L_{\\text{add}} = 6$时可用。\n\n**周期 $6$:**\n来自$a_{23}$的结果现在可用。来自$a_{01}$的结果从周期$5$开始就可用。最终加法指令$a_f$的两个输入现在都已就绪。就绪集为$\\{a_f\\}$。\n- **调度：** 发射$a_f$。一个发射槽未使用。\n- **状态：** 最终结果$s$将在周期$6 + L_{\\text{add}} = 7$时可用。\n\n**周期 $7$:**\n计算完成。结果$s$可用。\n\n此调度的makespan为$7$个周期。这比$6$个周期的关键路径界限要长。其原因是资源约束。$W=2$的发射宽度迫使四个独立的乘法指令必须在两个周期内调度。在周期$1$发射的乘法指令（$m_2, m_3$）比在周期$0$发射的指令晚一个周期完成。这个一周期延迟沿着依赖链传播，延迟了$a_{23}$，随后又延迟了$a_f$，最终与理论上无资源约束的下界相比，总执行时间增加了一个周期。没有其他调度可以做得更好，因为调度四个乘法指令至少需要两个周期，这不可避免地在其结果的可用性上产生了一个周期的交错。这种交错无法克服。\n\n**分析总结：**\n- **最小Makespan：** $s$可用的最早周期是周期$7$。\n- **完全填充的周期：** 一个周期如果两个发射槽都被使用，则为完全填充。在此调度中，周期$0$（发射了$m_0, m_1$）和周期$1$（发射了$m_2, m_3$）是完全填充的。\n- **关键路径：** 调度的关键路径是决定makespan的依赖指令序列。完成时间由$a_f$的结果在周期$7$可用所决定。这是因为$a_f$在周期$6$发射，而这又是被其最晚到达的输入（来自$a_{23}$，在周期$6$可用）所决定的。$a_{23}$在周期$5$的发射是被其输入（来自$m_2$和$m_3$，在周期$5$可用）所决定的。而$m_2$和$m_3$在周期$1$的发射是由于资源约束（因为$m_0$和$m_1$占用了周期$0$的发射槽）所决定的。因此，此调度的关键路径是链$m_2 \\rightarrow a_{23} \\rightarrow a_f$（或$m_3 \\rightarrow a_{23} \\rightarrow a_f$），其中第一个依赖是由资源引起的，而后续的是真正的数据依赖。“依赖图中的关键路径”可以理解为抽象DAG中在最终调度中成为关键的那条路径。\n\n所要求的最终答案是$s$可用的最早周期索引。这就是最优调度的makespan。\n最终Makespan = $7$个周期。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "真实世界的程序充满了分支，因此优化不能局限于单个基本块。本练习将你带入全局调度的领域，特别是超块（superblock）调度技术，它通过推测性地执行热路径上的指令来打破基本块的壁垒。通过对比局部调度与全局调度的效果，你将亲身体会到推测执行在提升常见路径性能方面的威力，以及它在非常见路径上可能引入的开销，这正是高级编译器设计的核心权衡之一。",
            "id": "3646565",
            "problem": "一个编译器后端的目标是一个简单的标量机，它必须调度一个包含一条热路径和一个非热路径分支的区域。其目标是对比在热路径上进行局部基本块调度与全局超块调度，并量化由于推测性移动在热路径上所带来的改进以及在非热路径上所产生的开销。机器模型和区域如下所示。\n\n机器模型假设：\n- 单发射：每个周期最多可以发射 $1$ 条指令。\n- 固定延迟：整数加法延迟为 $1$，整数乘法延迟为 $2$，加载延迟为 $3$，存储延迟为 $1$，分支延迟为 $1$。\n- 使用由前一条指令产生的值的指令，其发射周期不得早于该生产指令的发射周期加上其延迟。没有其他结构性冒险。\n- 已知该区域中的所有加载操作都是无故障且无副作用的，因此可以在不改变程序语义的情况下，将它们推测性地移动到分支之前执行。算术指令没有副作用。存储和分支指令具有其通常的副作用，不能跨越其动态控制依赖进行推测执行。\n\n控制流区域：\n- 块 $A$ (入口):\n  - $a_1$: 整数加法 (延迟 $1$)\n  - $a_2$: 整数乘法 (延迟 $2$)，依赖于 $a_1$ 的结果\n  - $a_3$: 条件分支 (延迟 $1$)，依赖于 $a_2$ 的结果；以概率 $p_B$ 跳转到 $B$ (热路径)，以概率 $1 - p_B$ 跳转到 $C$ (非热路径)\n- 块 $B$ ($A$ 的热后继):\n  - $b_1$: 加载 (延迟 $3$)，不依赖于 $A$\n  - $b_2$: 整数乘法 (延迟 $2$)，依赖于 $b_1$ 的结果并产生值 $g$\n- 块 $C$ ($A$ 的非热路径后继):\n  - $c_1$: 整数加法 (延迟 $1$)\n  - $c_2$: 整数乘法 (延迟 $2$)，依赖于 $c_1$ 的结果并产生值 $g$\n- 块 $D$ ($B$ 和 $C$ 之后的汇合点):\n  - $d_1$: 存储 (延迟 $1$)，使用 $g$\n\n应用的调度规则：\n- 在局部基本块调度下，每个块被独立调度；任何指令都不能跨越块边界移动。当沿某条路径执行时，如果后继块中的消费指令在其生产指令的值就绪（由于延迟）之前到达，执行必须停顿，插入所需数量的空操作，直到值就绪可以发射消费指令为止。\n- 在全局超块调度下，将热路径 $A \\rightarrow B \\rightarrow D$ 视为一个单一的调度区域。只要遵守依赖关系并且上述合法性假设成立，您可以将 $B$ 中的指令向上移动到 $A$ 中 $a_3$ 之前。您不能将 $d_1$ 移动到 $a_3$ 之上。非热路径 $A \\rightarrow C \\rightarrow D$ 即使分支跳转到 $C$，也会执行放置在 $a_3$ 之前的任何推测性操作；在非热路径上，这些操作就成了浪费的工作。\n\n给定热分支概率 $p_B = 0.8$，请完成以下任务：\n- 在局部基本块调度下，推导出热路径和非热路径上的最小周期调度，并计算如上所述由块内和块间依赖引起的所有必需的停顿。\n- 在全局超块调度下，推导出热路径（超块路径 $A \\rightarrow B \\rightarrow D$）和非热路径（$A \\rightarrow C \\rightarrow D$）上的最小周期调度，在合法的情况下对 $B$ 的指令在分支 $a_3$ 之前进行推测性移动，并计算非热路径上浪费的执行开销。\n- 根据这些调度，使用给定的 $p_B$ 计算局部基本块调度 $E_{\\text{local}}$ 和全局超块调度 $E_{\\text{super}}$ 下每次进入该区域的期望周期数。\n- 最后，计算定义为 $E_{\\text{local}} / E_{\\text{super}}$ 的加速比。\n\n将您的最终数值答案（加速比）四舍五入到四位有效数字。答案中不要包含任何单位。在计算期望值时，将分支概率表示为小数 $0.8$。",
            "solution": "我们从局部基本块调度和全局超块调度的基本定义开始。在这两种情况下，机器每个周期最多发射 $1$ 条指令，并且消费指令的发射时间必须至少是其生产指令的发射周期加上生产指令的延迟。在局部调度下，不允许跨块边界的代码移动，因此在进入后继块时，块间依赖可能导致停顿。在超块调度下，只要保持数据依赖和控制依赖的合法性，代码就可以沿着热路径向上移动；我们假设加载和算术指令可以在分支前安全地进行推测，但存储指令 $d_1$ 不能被提升到 $a_3$ 之上。\n\n步骤 $1$：局部基本块调度和路径周期。\n\n- 块 $A$ 有 $a_1$ (延迟 $1$)，$a_2$ (延迟 $2$) 依赖于 $a_1$，$a_3$ (延迟 $1$) 依赖于 $a_2$。在单发射的情况下：\n  - 在周期 $1$ 发射 $a_1$。\n  - 因为 $a_2$ 依赖于 $a_1$ 且 $a_1$ 的延迟为 $1$，我们可以在周期 $2$ 发射 $a_2$。\n  - $a_3$ 依赖于在周期 $2$ 发射且延迟为 $2$ 的 $a_2$，所以 $a_3$ 不能早于周期 $2 + 2 = 4$ 发射。因此，周期 $3$ 是一个停顿，我们在周期 $4$ 发射 $a_3$。\n  - 因此，块 $A$ 占用周期 $1$ 到 $4$。\n\n- 块 $B$ 有独立的 $b_1$ (延迟 $3$) 和依赖于 $b_1$ 的 $b_2$ (延迟 $2$)：\n  - 在 $B$ 的相对周期 $1$ 发射 $b_1$。\n  - $b_2$ 可以在相对周期 $1 + 3 = 4$ 发射，因此相对周期 $2$ 和 $3$ 是停顿。\n  - 因此，进入 $B$ 时，它占用 $4$ 个周期。\n\n- 块 $C$ 有 $c_1$ (延迟 $1$) 和依赖于 $c_1$ 的 $c_2$ (延迟 $2$)：\n  - 在相对周期 $1$ 发射 $c_1$。\n  - 在相对周期 $2$ 发射 $c_2$，因为 $1 + 1 = 2$。\n  - 因此，进入 $C$ 时，它占用 $2$ 个周期。\n\n- 块 $D$ 有一个使用 $g$ 的单一存储指令 $d_1$。在局部调度下，$d_1$ 不能被移动到块 $D$ 之前，因此从前驱块进入 $D$ 时，我们可能需要停顿直到 $g$ 就绪。\n\n现在通过对这些块进行排序并遵守在 $D$ 处 $g$ 的跨块就绪条件，来计算每条路径的总周期数。\n\n热路径 $A \\rightarrow B \\rightarrow D$：\n- $A$ 使用周期 $1$ 到 $4$；在周期 $5$ 进入 $B$。\n- 在 $B$ 中：在周期 $5$ 发射 $b_1$，在周期 $6$ 和 $7$ 停顿，在周期 $8$ 发射 $b_2$。来自 $b_2$（延迟 $2$）的结果 $g$ 在周期 $8 + 2 = 10$ 时就绪。\n- 在周期 $9$（紧接着完成 $B$ 后）进入 $D$。因为 $g$ 直到周期 $10$ 才就绪，我们必须在周期 $9$ 停顿，并在周期 $10$ 发射 $d_1$。\n- 热路径在周期 $10$ 完成。\n\n非热路径 $A \\rightarrow C \\rightarrow D$：\n- $A$ 使用周期 $1$ 到 $4$；在周期 $5$ 进入 $C$。\n- 在 $C$ 中：在周期 $5$ 发射 $c_1$，在周期 $6$ 发射 $c_2$。来自 $c_2$（延迟 $2$）的结果 $g$ 在周期 $6 + 2 = 8$ 时就绪。\n- 在周期 $7$ 进入 $D$。因为 $g$ 直到周期 $8$ 才就绪，所以在周期 $7$ 停顿，并在周期 $8$ 发射 $d_1$。\n- 非热路径在周期 $8$ 完成。\n\n因此，在局部基本块调度下：\n- 热路径周期数：$10$。\n- 非热路径周期数：$8$。\n\n步骤 $2$：在热路径 $A \\rightarrow B \\rightarrow D$ 上的全局超块调度及非热路径行为。\n\n在超块调度下，我们将热路径视为一个单一的调度区域。我们可以将 $B$ 的指令向上移动到分支 $a_3$ 之前，因为 $b_1$ 和 $b_2$ 没有副作用且遵守数据依赖。我们不能将 $d_1$ 移动到 $a_3$ 之前。\n\n我们选择一个能将 $b_1$ 的 $3$ 周期延迟隐藏在 $A$ 的工作中的顺序：\n- 在周期 $1$ 发射 $b_1$ 以尽早开始长延迟的加载操作。\n- 在周期 $2$ 发射 $a_1$。\n- 在周期 $3$ 发射 $a_2$（依赖于延迟为 $1$ 的 $a_1$）。\n- $b_2$ 依赖于延迟为 $3$ 的 $b_1$，因此它可以在周期 $1 + 3 = 4$ 发射。在周期 $4$ 发射 $b_2$。\n- $a_3$ 依赖于在周期 $3$ 发射的 $a_2$（延迟 $2$），因此 $a_3$ 可以在周期 $3 + 2 = 5$ 发射。在周期 $5$ 发射 $a_3$。\n- 在热路径上（分支到 $B$），我们继续到 $D$。在周期 $4$ 发射的 $b_2$（延迟 $2$）所产生的值 $g$ 在周期 $6$ 就绪，因此在周期 $6$ 发射 $d_1$。\n- 在非热路径上（分支到 $C$），我们仍然在分支前执行了推测的 $b_1$ 和 $b_2$，然后在周期 $6$ 进入 $C$ 并对 $C$ 进行局部调度：在周期 $6$ 发射 $c_1$，在周期 $7$ 发射 $c_2$，然后来自 $c_2$（延迟 $2$）的 $g$ 在周期 $9$ 就绪，因此在周期 $9$ 发射 $d_1$。\n\n因此，在超块调度下：\n- 热路径周期数：在周期 $6$ 完成。\n- 非热路径周期数：在周期 $9$ 完成。\n- 相对于局部调度，热路径上的改进是节省了 $10 - 6 = 4$ 个周期。\n- 表现为非热路径上浪费工作的补偿开销是该路径上预期的额外 $9 - 8 = 1$ 个周期。\n\n步骤 $3$：使用 $p_B = 0.8$ 计算期望周期数和加速比。\n\n设 $p_B = 0.8$ 且 $1 - p_B = 0.2$。\n\n局部调度期望周期数：\n$$\nE_{\\text{local}} \\;=\\; p_B \\cdot 10 \\;+\\; (1 - p_B) \\cdot 8 \\;=\\; 0.8 \\cdot 10 \\;+\\; 0.2 \\cdot 8 \\;=\\; 8 \\;+\\; 1.6 \\;=\\; 9.6.\n$$\n\n超块调度期望周期数：\n$$\nE_{\\text{super}} \\;=\\; p_B \\cdot 6 \\;+\\; (1 - p_B) \\cdot 9 \\;=\\; 0.8 \\cdot 6 \\;+\\; 0.2 \\cdot 9 \\;=\\; 4.8 \\;+\\; 1.8 \\;=\\; 6.6.\n$$\n\n加速比：\n$$\n\\text{Speedup} \\;=\\; \\frac{E_{\\text{local}}}{E_{\\text{super}}} \\;=\\; \\frac{9.6}{6.6} \\;=\\; 1.454545\\ldots\n$$\n\n四舍五入到四位有效数字，加速比为 $1.455$。",
            "answer": "$$\\boxed{1.455}$$"
        },
        {
            "introduction": "循环是程序性能的关键瓶颈，而软件流水线（software pipelining）是攻克这一瓶颈的强大技术。本练习将引导你使用模调度（modulo scheduling）方法，通过重叠不同循环迭代的执行来最大化吞吐率。你将学会分析并计算决定循环性能的两个核心下界——资源约束和循环携带依赖（recurrence-constrained）——并确定最小启动间隔（Initiation Interval, $II$），从而深入理解现代处理器如何实现对循环的高度并行化执行。",
            "id": "3646538",
            "problem": "一个编译器后端的目标是一个超长指令字 (VLIW) 机器，并且必须使用带旋转寄存器的模调度对以下循环进行软件流水线处理，以最大化吞吐率。该循环计算一个带每次迭代乘积项的一阶线性递推：\n- 对于每个迭代索引 $i \\in \\{1,2,\\dots\\}$，循环执行以下数据流：\n  1. $u_i \\leftarrow \\text{load}(A[i])$,\n  2. $v_i \\leftarrow \\text{load}(B[i])$,\n  3. $p_i \\leftarrow u_i \\times v_i$,\n  4. $q_i \\leftarrow \\gamma \\times x_{i-1}$,\n  5. $x_i \\leftarrow p_i + q_i$,\n  6. $\\text{store}(x_i \\to Y[i])$.\n假设在循环开始前，初始值 $x_0$ 是可用的。目标机器和操作延迟如下：\n- 只有一个硬件乘法单元。它是完全流水线化的，流水线延迟为 $L_{\\text{mul}} = 3$ 个周期，启动间隔为 $I_{\\text{mul}} = 2$ 个周期，这意味着无论有多少个乘法正在执行，最多每 $2$ 个周期可以发出一个新的乘法操作。\n- 加载操作的延迟为 $L_{\\text{load}} = 2$ 个周期。存储操作可以在任何周期发出，没有资源争用，并且对关键路径没有影响。整数加法的延迟为 $L_{\\text{add}} = 1$ 个周期。所有非乘法资源（加法、加载、存储）都是充足的，不会限制吞吐率。\n- 内存是完全缓存的，没有内存冲突。唯一的资源瓶颈是上面描述的乘法单元。\n- 唯一的循环携带相关是通过递推变量 $x_i$，它在下一次迭代的乘法 $q_{i+1} \\leftarrow \\gamma \\times x_{i}$ 中被使用。\n\n仅使用模调度的基本定义，包括将启动间隔 (II) 定义为连续循环迭代开始时间之间的稳态周期间隔，以及合法调度必须满足所有资源限制和数据相关性（包括循环携带相关）的要求，确定与这些约束一致的最小可能启动间隔。然后，构建一个有效的稳态模调度，通过为每个操作分配一个稳态时间偏移（以周期为单位）来实现这个启动间隔，并解释对于跨迭代的值所必需的旋转寄存器分配。\n\n仅报告最小启动间隔 $\\,\\text{II}\\,$ 作为您的最终数值答案（一个整数）。无需四舍五入，也无需单位。",
            "solution": "该问题要求计算软件流水线化循环的最小启动间隔 (II)，并构建相应的模调度。模调度的最小启动间隔受两个下界约束：资源约束的 II ($\\text{II}_{\\text{Res}}$) 和递推约束的 II ($\\text{II}_{\\text{Rec}}$)。最小可能 II 由 $\\text{II}_{\\text{min}} = \\max(\\text{II}_{\\text{Res}}, \\text{II}_{\\text{Rec}})$ 给出。\n\n首先，我们确定资源约束的下界 $\\text{II}_{\\text{Res}}$。这个界限源于循环体的资源需求。循环包含以下操作：$2$ 个加载，$2$ 个乘法，$1$ 个加法和 $1$ 个存储。问题指出，除了乘法单元外，所有资源都是充足的。因此，我们只需要考虑单个乘法单元施加的约束。\n\n循环体每次迭代包含两个乘法操作：\n1.  $p_i \\leftarrow u_i \\times v_i$\n2.  $q_i \\leftarrow \\gamma \\times x_{i-1}$\n\n问题指出，乘法单元是完全流水线化的，但其启动间隔为 $I_{\\text{mul}} = 2$ 个周期。这意味着该单元最多每 $2$ 个周期可以接受一个新的乘法操作。因此，其吞吐率为每周期 $0.5$ 个操作。\n\n在一个启动间隔为 $\\text{II}$ 的稳态软件流水线中，可以执行的某一类型操作的总数是 $\\text{II}$ 除以该操作类型功能单元的启动间隔。对于一个 $\\text{II}$ 周期的核心代码段，乘法单元的总需求是 $2$ 个操作。总可用容量是 $\\frac{\\text{II}}{I_{\\text{mul}}} = \\frac{\\text{II}}{2}$ 个操作。对于一个有效的调度，需求不能超过容量：\n$$2 \\le \\frac{\\text{II}}{2}$$\n$$4 \\le \\text{II}$$\n因此，资源约束的最小启动间隔是 $\\text{II}_{\\text{Res}} = 4$。\n\n接下来，我们确定递推约束的下界 $\\text{II}_{\\text{Rec}}$。这个界限源于循环携带的数据相关。问题指出，唯一的循环携带相关是通过变量 $x_i$，它在迭代 $i$ 中计算，并在迭代 $i+1$ 中使用。让我们在数据相关图中追踪这个递推环路。\n\n1.  值 $x_{i-1}$ 被乘法 $q_i \\leftarrow \\gamma \\times x_{i-1}$ 使用。我们称此操作为 $\\text{mul}_q$。\n2.  结果 $q_i$ 被加法 $x_i \\leftarrow p_i + q_i$ 使用。我们称此操作为 $\\text{add}_x$。\n3.  结果 $x_i$ 接着在下一次迭代 $i+1$ 中被乘法 $q_{i+1} \\leftarrow \\gamma \\times x_i$ 使用。\n\n因此，递推环路是 $\\text{mul}_q \\rightarrow \\text{add}_x \\rightarrow \\text{mul}_q(\\text{next iter})$。在单次迭代的数据流中，沿着这条路径的总延迟是环路中操作（即 $\\text{mul}_q$ 和 $\\text{add}_x$）的延迟之和。乘法延迟为 $L_{\\text{mul}} = 3$ 个周期，加法延迟为 $L_{\\text{add}} = 1$ 个周期。总延迟 $\\Lambda$ 为：\n$$\\Lambda = L_{\\text{mul}} + L_{\\text{add}} = 3 + 1 = 4 \\text{ 周期}$$\n此递推的相关距离 $d$ 是 $1$ 次迭代，因为一次迭代中计算的值在紧接着的下一次迭代中使用。递推约束的 II 由公式 $\\text{II}_{\\text{Rec}} = \\lceil \\frac{\\Lambda}{d} \\rceil$ 给出。\n$$\\text{II}_{\\text{Rec}} = \\lceil \\frac{4}{1} \\rceil = 4$$\n\n计算出两个下界后，我们找到最小可能的启动间隔：\n$$\\text{II}_{\\text{min}} = \\max(\\text{II}_{\\text{Res}}, \\text{II}_{\\text{Rec}}) = \\max(4, 4) = 4$$\n最小启动间隔是 $4$ 个周期。\n\n现在，我们必须构建一个实现 $\\text{II}=4$ 的有效模调度。一个调度是通过为每个操作分配一个稳态时间偏移 $S(\\text{op})$ 来定义的。这些偏移必须满足所有数据相关和资源约束。来自迭代 $i$ 的操作 `op` 的发出时间是 $S_i(\\text{op}) = S(\\text{op}) + i \\cdot \\text{II}$。\n\n让操作表示为：$\\text{load}_A$, $\\text{load}_B$, $\\text{mul}_p$, $\\text{mul}_q$, $\\text{add}_x$, $\\text{store}_Y$。\n相关性约束是：\n- $S(\\text{mul}_p) \\ge S(\\text{load}_A) + L_{\\text{load}} = S(\\text{load}_A) + 2$\n- $S(\\text{mul}_p) \\ge S(\\text{load}_B) + L_{\\text{load}} = S(\\text{load}_B) + 2$\n- $S(\\text{add}_x) \\ge S(\\text{mul}_p) + L_{\\text{mul}} = S(\\text{mul}_p) + 3$\n- $S(\\text{add}_x) \\ge S(\\text{mul}_q) + L_{\\text{mul}} = S(\\text{mul}_q) + 3$\n- $S(\\text{store}_Y) \\ge S(\\text{add}_x) + L_{\\text{add}} = S(\\text{add}_x) + 1$\n- 递推：$S_i(\\text{mul}_q) + \\text{II} \\ge S_i(\\text{add}_x) + L_{\\text{add}} \\implies S(\\text{mul}_q) + 4 \\ge S(\\text{add}_x) + 1$\n\n乘法单元的资源约束要求任何两个乘法操作的发出时间至少相隔 $I_{\\text{mul}}=2$ 个周期。在模调度中，这意味着对于所有整数 $i, j$，都有 $|(S(\\text{mul}_p) + i \\cdot \\text{II}) - (S(\\text{mul}_q) + j \\cdot \\text{II})| \\ge 2$。如果 $|(S(\\text{mul}_p) - S(\\text{mul}_q)) \\pmod{\\text{II}}|$ 不是 $0$ 或 $1$，则此条件满足。当 $\\text{II}=4$ 且 $I_{\\text{mul}}=2$ 时，循环体中的两个乘法操作完全利用了乘法器。它们的调度时间模 $4$ 必须相隔 $2$，例如 $\\{0, 2\\}$ 或 $\\{1, 3\\}$。\n\n让我们尝试构建一个调度。我们设置 $S(\\text{mul}_p) = 0$ 和 $S(\\text{mul}_q)=2$。这满足资源约束，因为 $(S(\\text{mul}_p) \\pmod 4, S(\\text{mul}_q) \\pmod 4) = (0, 2)$。\n根据对乘法的相关性，我们有：\n- $S(\\text{add}_x) \\ge S(\\text{mul}_p) + 3 = 0 + 3 = 3$\n- $S(\\text{add}_x) \\ge S(\\text{mul}_q) + 3 = 2 + 3 = 5$\n所以，我们必须有 $S(\\text{add}_x) \\ge 5$。我们选择最早可能的时间，$S(\\text{add}_x) = 5$。\n现在我们检查递推约束：$S(\\text{mul}_q) + 4 \\ge S(\\text{add}_x) + 1 \\implies 2 + 4 \\ge 5 + 1 \\implies 6 \\ge 6$。条件等式成立，这是预期的，因为 $\\text{II}_{\\text{Rec}} = \\text{II}$。\n接下来，调度加载操作：\n- $S(\\text{mul}_p) \\ge S(\\text{load}_A) + 2 \\implies 0 \\ge S(\\text{load}_A) + 2 \\implies S(\\text{load}_A) \\le -2$。我们设置 $S(\\text{load}_A) = -2$。\n- 类似地，我们设置 $S(\\text{load}_B) = -2$。\n最后，调度存储操作：\n- $S(\\text{store}_Y) \\ge S(\\text{add}_x) + 1 \\ge 5 + 1 = 6$。我们设置 $S(\\text{store}_Y) = 6$。\n\n最终的调度偏移是：\n$S(\\text{load}_A) = -2$, $S(\\text{load}_B) = -2$, $S(\\text{mul}_p) = 0$, $S(\\text{mul}_q) = 2$, $S(\\text{add}_x) = 5$, $S(\\text{store}_Y) = 6$。\n\n稳态核心代码段执行来自不同原始循环迭代的操作。在这个 $4$ 周期核心代码段中，每个周期的调度是：\n- 周期 0：来自迭代 $i$ 的 $\\text{mul}_p$。($S(\\text{mul}_p) \\pmod 4 = 0$)\n- 周期 1：来自迭代 $i-1$ 的 $\\text{add}_x$。($S(\\text{add}_x) \\pmod 4 = 5 \\pmod 4 = 1$)\n- 周期 2：来自迭代 $i+1$ 的 $\\text{load}_A, \\text{load}_B$ ($S(\\text{load}) \\pmod 4 = -2 \\pmod 4 = 2$)；来自迭代 $i$ 的 $\\text{mul}_q$ ($S(\\text{mul}_q) \\pmod 4 = 2$)；来自迭代 $i-1$ 的 $\\text{store}_Y$ ($S(\\text{store}_Y) \\pmod 4 = 6 \\pmod 4 = 2$)。\n- 周期 3：没有调度任何操作。\n\n最后，我们解释旋转寄存器的作用。变量 $x$ 表现出循环携带相关：在迭代 $i$ 中计算的值 $x_i$ 在迭代 $i+1$ 中被使用。在软件流水线执行中，多个迭代的部分（例如 $i-1$, $i$, $i+1$）同时处于活动状态。这意味着变量 $x$ 的多个“版本”（即 $x_{i-1}$, $x_i$）必须同时有效。如果为 $x$ 使用单个静态寄存器，来自迭代 $i$ 的 $\\text{add}_x$ 对 $x_i$ 的计算将在来自迭代 $i$ 的 $\\text{mul}_q$ 读取 $x_{i-1}$ 的值之前将其覆盖。这是一个写后读 (WAR) 冒险。\n\n旋转寄存器解决了这个问题。循环核心代码段中的指令引用一个虚拟寄存器名。硬件为软件流水线循环的每个连续迭代自动将此虚拟寄存器映射到一个不同的物理寄存器。对于变量 $x$，$\\text{add}_x$ 指令将被编写为以虚拟寄存器 $VR_k$ 为目标，而 $\\text{mul}_q$ 指令将被编写为从虚拟寄存器 $VR_{k'}$ 读取。硬件确保在迭代 $i$ 中由 $\\text{add}_x$ 写入的物理寄存器与在迭代 $i+1$ 中由 $\\text{mul}_q$ 读取的物理寄存器是同一个。这有效地为每次迭代重命名了变量，在重叠的迭代中保持了数据流，而不需要显式的寄存器到寄存器移动指令。",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}