{
    "hands_on_practices": [
        {
            "introduction": "要掌握指令选择，第一步是理解如何用代表机器指令的模式（“瓦片”）来覆盖有向无环图（DAG），并计算总成本。这个练习将帮助你通过一个具体的例子来实践这一核心概念。你将决定是使用多个简单的指令，还是使用一个更复杂的融合指令（如融合乘加指令 FMA）来覆盖一个表达式图，从而找到成本最低的方案。",
            "id": "3634952",
            "problem": "编译器后端通过用指令模式覆盖中间表示（IR）有向无环图（DAG）来执行指令选择，从而使每个 IR 操作节点都由一条目标指令实现，并且总成本最小化。考虑算术表达式 $$((a+b)\\times(c+d))+(a+b),$$ 的 IR DAG，其中子表达式 $$a+b$$ 是显式共享的。设 DAG 节点标记如下：$$n_{1}=\\mathrm{add}(a,b),\\quad n_{2}=\\mathrm{add}(c,d),\\quad n_{3}=\\mathrm{mul}(n_{1},n_{2}),\\quad n_{4}=\\mathrm{add}(n_{3},n_{1}).$$ 所有叶节点 $$a,b,c,d$$ 都是已在寄存器中可用的值，成本为零。\n\n目标机器支持以下指令模式（树模式），成本以抽象单位计算：\n- $$p_{\\mathrm{add}}:\\ \\mathrm{add}(x,y)\\ \\text{成本为}\\ 1.$$\n- $$p_{\\mathrm{mul}}:\\ \\mathrm{mul}(x,y)\\ \\text{成本为}\\ 2.$$\n- $$p_{\\mathrm{fma}}:\\ \\mathrm{add}(\\mathrm{mul}(x,y),z)\\ \\text{成本为}\\ 2.$$\n\n此处的 $$\\mathrm{add}$$ 和 $$\\mathrm{mul}$$ 是可交换运算符，并且由于交换律，融合乘加（FMA）指令 $$p_{\\mathrm{fma}}$$ 可以匹配 $$\\mathrm{add}(\\mathrm{mul}(x,y),z)$$ 或 $$\\mathrm{add}(z,\\mathrm{mul}(x,y))$$。如果节点的运算符及其子树的形状与模式一致，则该模式匹配该节点；当在某个节点选择 $$p_{\\mathrm{fma}}$$ 时，它会在一条指令中同时覆盖该 $$\\mathrm{add}$$ 节点及其 $$\\mathrm{mul}$$ 子节点。每个内部 IR 节点必须被某个选定的模式恰好覆盖一次，叶节点 $$a,b,c,d$$ 不产生任何成本。总成本是所选模式的成本之和。\n\n仅使用有向无环图（DAG）、模式匹配以及用于指令选择的加性成本模型的定义，确定覆盖给定表达式的 DAG 的最小可能总成本。将最小总成本报告为单个整数。无需四舍五入；请提供一个精确的整数。",
            "solution": "用户希望我解决这个问题。我将首先验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **中间表示（IR）DAG：** 问题描述了表达式 `((a+b) * (c+d)) + (a+b)` 的一个有向无环图（DAG）。\n- **DAG 节点：**\n  - $n_{1} = \\mathrm{add}(a,b)$\n  - $n_{2} = \\mathrm{add}(c,d)$\n  - $n_{3} = \\mathrm{mul}(n_{1},n_{2})$\n  - $n_{4} = \\mathrm{add}(n_{3},n_{1})$ (这是 DAG 的根节点)。\n- **叶节点：** 叶节点 $a, b, c, d$ 是寄存器中已有的值，成本为零。\n- **指令模式与成本：**\n  - $p_{\\mathrm{add}}: \\mathrm{add}(x,y)$，成本为 $1$。\n  - $p_{\\mathrm{mul}}: \\mathrm{mul}(x,y)$，成本为 $2$。\n  - $p_{\\mathrm{fma}}: \\mathrm{add}(\\mathrm{mul}(x,y),z)$，成本为 $2$。\n- **运算符属性：** 运算符 $\\mathrm{add}$ 和 $\\mathrm{mul}$ 是可交换的。\n- **覆盖规则：** 每个内部 IR 节点（$n_1, n_2, n_3, n_4$）必须被一个选定的模式恰好覆盖一次。一个模式可以覆盖多个节点（例如，$p_{\\mathrm{fma}}$ 覆盖一个 $\\mathrm{add}$ 和一个 $\\mathrm{mul}$ 节点）。\n- **目标：** 确定覆盖该 DAG 的最小可能总成本。总成本是所选模式的成本之和。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学性：** 该问题是通过 DAG 覆盖进行指令选择的经典实例，这是编译器构造中的一个基本主题。IR DAG、模式匹配和成本模型的概念都是标准的且科学合理的。\n2.  **适定性：** 问题提供了一个完全指定的 DAG，一组具有确定成本的瓦片（模式），以及在一个精确的覆盖约束（划分节点集）下的明确目标函数（最小化总成本）。这种结构保证了解的存在性和唯一性（或具有唯一的最小成本）。\n3.  **客观性：** 问题使用计算机科学和编译器理论中标准的、形式化的、无歧义的语言进行陈述。它不含主观论断。\n\n该问题没有表现出任何科学上不合理、不完整、矛盾或模棱两可的缺陷。它是编译器理论领域内一个定义明确的优化问题。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。我将继续进行完整解答。\n\n任务是找到一组指令模式，它们共同地、恰好一次地覆盖 DAG 的所有内部节点 $\\{n_1, n_2, n_3, n_4\\}$，并使所选模式的成本之和最小化。这等同于寻找节点集的最小成本划分，其中划分的每个块都由单个指令模式覆盖。\n\n需要覆盖的节点是 $n_1 = \\mathrm{add}(a,b)$，$n_2 = \\mathrm{add}(c,d)$，$n_3 = \\mathrm{mul}(n_1,n_2)$，以及根节点 $n_4 = \\mathrm{add}(n_3,n_1)$。令 $\\mathcal{N} = \\{n_1, n_2, n_3, n_4\\}$ 为内部节点集合。\n\n我们分析在每个节点上可能匹配的模式。如果一个节点是某个模式的根，则称该模式在该节点上匹配。\n- 在 $n_1 = \\mathrm{add}(a,b)$ 处：唯一匹配的模式是 $p_{\\mathrm{add}}$。叶节点 $a$ 和 $b$ 不构成 `mul` 子树，所以 $p_{\\mathrm{fma}}$ 无法匹配。如果选择此模式，它将覆盖节点 $\\{n_1\\}$。\n- 在 $n_2 = \\mathrm{add}(c,d)$ 处：同样，只有 $p_{\\mathrm{add}}$ 可以匹配。如果选择此模式，它将覆盖节点 $\\{n_2\\}$。\n- 在 $n_3 = \\mathrm{mul}(n_1,n_2)$ 处：唯一匹配的模式是 $p_{\\mathrm{mul}}$。如果选择此模式，它将覆盖节点 $\\{n_3\\}$。\n- 在 $n_4 = \\mathrm{add}(n_3,n_1)$ 处：\n  1. $p_{\\mathrm{add}}$ 模式可以匹配。如果选择此模式，它将覆盖节点 $\\{n_4\\}$。\n  2. $p_{\\mathrm{fma}}$ 模式，即 $\\mathrm{add}(\\mathrm{mul}(x,y),z)$，也可以匹配。问题陈述中指出 $\\mathrm{add}$ 是可交换的，因此该模式可以匹配 $\\mathrm{add}(\\mathrm{mul}(...),...)$ 或 $\\mathrm{add}(...,\\mathrm{mul}(...))$。节点 $n_4$ 是 $\\mathrm{add}(n_3,n_1)$。由于 $n_3$ 是一个 $\\mathrm{mul}$ 节点，这个结构匹配 $p_{\\mathrm{fma}}$。如果选择此模式，它将同时覆盖 $\\mathrm{add}$ 节点 $n_4$ 及其子 $\\mathrm{mul}$ 节点 $n_3$。被覆盖的节点集是 $\\{n_3, n_4\\}$。\n\n为了找到最小成本覆盖，我们必须为根节点 $n_4$ 的覆盖做出选择。这导致了两种不同的划分节点集 $\\mathcal{N}$ 的情况。\n\n**情况 1：使用 $p_{\\mathrm{add}}$ 模式覆盖节点 $n_4$。**\n- 我们选择 $p_{\\mathrm{add}}$ 模式在节点 $n_4$ 处进行匹配。这覆盖了节点集 $\\{n_4\\}$。产生的成本为 $1$。\n- 剩余需要覆盖的节点是 $\\{n_1, n_2, n_3\\}$。\n- 为了覆盖节点 $n_3 = \\mathrm{mul}(n_1,n_2)$，我们必须使用 $p_{\\mathrm{mul}}$ 模式。这覆盖了节点集 $\\{n_3\\}$。此模式产生的成本为 $2$。\n- 剩余需要覆盖的节点是 $\\{n_1, n_2\\}$。\n- 为了覆盖节点 $n_1 = \\mathrm{add}(a,b)$，我们必须使用 $p_{\\mathrm{add}}$ 模式。这覆盖了节点集 $\\{n_1\\}$。成本为 $1$。\n- 为了覆盖节点 $n_2 = \\mathrm{add}(c,d)$，我们必须使用 $p_{\\mathrm{add}}$ 模式。这覆盖了节点集 $\\{n_2\\}$。成本为 $1$。\n- 完整的覆盖由在 $n_4$、$n_3$、$n_1$ 和 $n_2$ 处匹配的模式组成。被覆盖的节点集是 $\\{n_4\\}$、$\\{n_3\\}$、$\\{n_1\\}$ 和 $\\{n_2\\}$，它们构成了 $\\mathcal{N}$ 的一个划分。这是一个有效的覆盖。\n- 这种情况下的总成本是所选模式的成本之和：$1 (\\text{用于 } n_4) + 2 (\\text{用于 } n_3) + 1 (\\text{用于 } n_1) + 1 (\\text{用于 } n_2) = 5$。\n\n**情况 2：使用 $p_{\\mathrm{fma}}$ 模式覆盖节点 $n_4$。**\n- 我们选择 $p_{\\mathrm{fma}}$ 模式在节点 $n_4$ 处进行匹配。该模式匹配结构 $\\mathrm{add}(n_3, n_1)$，因为 $n_3$ 是一个 $\\mathrm{mul}$ 节点。这单个模式同时覆盖了节点 $n_4$ 和 $n_3$。被覆盖的节点集是 $\\{n_3, n_4\\}$。产生的成本为 $2$。\n- 剩余需要覆盖的节点是 $\\{n_1, n_2\\}$。\n- 为了覆盖节点 $n_1 = \\mathrm{add}(a,b)$，我们必须使用 $p_{\\mathrm{add}}$ 模式。这覆盖了 $\\{n_1\\}$。成本为 $1$。\n- 为了覆盖节点 $n_2 = \\mathrm{add}(c,d)$，我们必须使用 $p_{\\mathrm{add}}$ 模式。这覆盖了 $\\{n_2\\}$。成本为 $1$。\n- 完整的覆盖由一个在 $n_4$ 处的 $p_{\\mathrm{fma}}$ 模式和在 $n_1$、$n_2$ 处的 $p_{\\mathrm{add}}$ 模式组成。被覆盖的节点集是 $\\{n_3, n_4\\}$、$\\{n_1\\}$ 和 $\\{n_2\\}$，它们构成了 $\\mathcal{N}$ 的一个划分。这也是一个有效的覆盖。\n- 这种情况下的总成本是：$2 (\\text{用于 } n_4 \\text{ 和 } n_3) + 1 (\\text{用于 } n_1) + 1 (\\text{用于 } n_2) = 4$。\n\n**结论**\n我们已经枚举了 DAG 所有可能的有效覆盖。两种可能的总成本是 $5$ 和 $4$。最小可能总成本是这些值中的最小值。\n$$ \\min(5, 4) = 4 $$\n因此，覆盖给定 DAG 的最小成本是 $4$。这是通过使用一条融合乘加指令和两条加法指令实现的。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "现实世界中的计算机体系结构充满了各种限制，一个优秀的编译器必须能够应对这些限制。这个练习模拟了一个非常普遍的约束：指令中立即数的大小限制。你将探索当一个常量对于单条指令来说太大时，编译器如何通过生成额外的“物化”指令来处理它，并学会如何通过共享这个物化后的常量来优化总指令数。",
            "id": "3635002",
            "problem": "编译器后端必须对以下中间表示执行有向无环图（DAG）覆盖的指令选择。目标机是一种类似于“精简指令集计算机第五版”（RISC-V）的加载-存储架构，具有以下相关属性：\n- 所有输入变量 $x$、$y$ 和 $z$ 都已在寄存器中。\n- 机器支持单位成本为 $1$ 的算术指令：ADD、ADDI 和 MUL。\n- 立即数形式的 ADDI 使用一个有符号的 $12$ 位立即数；也就是说，立即数 $i$ 必须满足 $-2048 \\le i \\le 2047$ 才能直接编码。\n- LUI 指令以单位成本 $1$ 将常数的高位部分加载到寄存器中。任何满足 $|C| \\le 2047$ 的常数 $C$ 都可以通过对零寄存器使用 ADDI 在一条指令中具体化，而任何满足 $|C|  2047$ 的常数 $C$ 都可以通过 LUI 后跟 ADDI 在恰好 $2$ 条指令中具体化。假设机器有足够的寄存器，以便常数一旦具体化，就可以重用而无需额外的溢出成本。\n\n需要覆盖的中间表示是一个带有共享常数子表达式的有向无环图（DAG）：\n- 节点：\n  - $n_{1} = \\mathrm{CONST}(5000)$\n  - $n_{2} = \\mathrm{CONST}(131071)$\n  - $n_{3} = \\mathrm{ADD}(x, n_{1})$\n  - $n_{4} = \\mathrm{ADD}(y, n_{1})$\n  - $n_{5} = \\mathrm{MUL}(z, n_{2})$\n  - $n_{6} = \\mathrm{ADD}(n_{5}, n_{1})$\n  - $n_{7} = \\mathrm{ADD}(n_{3}, n_{4})$\n  - $n_{8} = \\mathrm{ADD}(n_{7}, n_{6})$  (根节点)\n\n语义：\n- $\\mathrm{ADD}(a,b)$ 表示 $a$ 和 $b$ 的整数加法。\n- $\\mathrm{MUL}(a,b)$ 表示 $a$ 和 $b$ 的整数乘法。\n- $\\mathrm{CONST}(C)$ 表示整数常数 $C$。\n- 常数 $5000$ 和 $131071$ 的绝对值大于 $2047$，因此它们不符合 ADDI 立即数范围。\n\n通过 DAG 覆盖进行指令选择时，必须选择将节点映射到机器指令的模式，同时要遵守立即数范围的约束，并允许通过 LUI 后跟 ADDI 来具体化大常数。任何将不可编码的常数用作 ADD 或 MUL 的操作数，都要求该常数事先已具体化到寄存器中。具体化的常数可以在其在 DAG 中的所有使用处共享，而无需额外的具体化成本。\n\n使用这些规则并以最小化机器指令总数为目标进行优化，计算覆盖以 $n_{8}$ 为根的整个 DAG 所需的最小指令数。仅返回最小计数（一个整数）。假设不允许代数重组或重新排序；您必须精确地覆盖给定的 DAG。假设所有指令的成本均为 $1$。您不需要对答案进行四舍五入。",
            "solution": "我们从编译器后端中用于指令选择的有向无环图（DAG）覆盖的核心定义开始。一个 DAG $G$ 编码了操作之间的数据依赖关系。一个覆盖将 DAG 节点映射到目标机指令模式，使得：\n- 每个中间表示节点的语义都由一个或多个目标指令实现。\n- 仅当常数操作数符合目标的立即数范围时，才允许使用立即数形式的指令。\n- 共享的子图（例如具有多个父节点的常数节点）可以实现一次并在父节点之间重用，前提是目标机有足够的寄存器。总成本目标是所选目标指令成本的总和。\n\n给定目标机属性：\n- ADD 成本为 $1$，有两个寄存器操作数。\n- ADDI 成本为 $1$，但仅当立即数 $i$ 满足 $-2048 \\le i \\le 2047$ 时才可用。\n- LUI 成本为 $1$，可以与成本为 $1$ 的 ADDI 组合以具体化任何更大的常数。根据假设，对于 $|C|  2047$，常数 $C$ 通过 $\\mathrm{LUI} + \\mathrm{ADDI}$ 在恰好 $2$ 条指令中具体化。\n\n我们分析该 DAG：\n- $n_{1} = \\mathrm{CONST}(5000)$ 的 $|5000|  2047$，因此需要具体化。根据规则，通过 $\\mathrm{LUI} + \\mathrm{ADDI}$ 具体化 $5000$ 的成本是 $2$ 条指令。因为 $n_{1}$ 被 $n_{3}$、$n_{4}$ 和 $n_{6}$ 共享，我们可以重用存放 $5000$ 的单个具体化寄存器，而无需额外的具体化成本。\n- $n_{2} = \\mathrm{CONST}(131071)$ 的 $|131071|  2047$，因此也需要具体化。通过 $\\mathrm{LUI} + \\mathrm{ADDI}$ 具体化 $131071$ 的成本是 $2$ 条指令。它在 $n_{5}$ 中使用一次。\n\n接下来，我们列举操作符节点以及在立即数约束下的可行指令选择：\n- $n_{3} = \\mathrm{ADD}(x, n_{1})$：由于 $n_{1}$ 对于 ADDI 立即数来说太大了，我们不能直接使用带有 $5000$ 的 ADDI。唯一的选择是使用带有两个寄存器的 ADD：用于 $x$ 的寄存器和存放具体化的 $5000$ 的寄存器。此 ADD 的成本为 $1$。\n- $n_{4} = \\mathrm{ADD}(y, n_{1})$：与 $n_{3}$ 的推理相同；ADD 的成本为 $1$。\n- $n_{5} = \\mathrm{MUL}(z, n_{2})$：没有乘法立即数指令。我们必须将 $z$ 与存放具体化的 $131071$ 的寄存器相乘。此 MUL 的成本为 $1$。\n- $n_{6} = \\mathrm{ADD}(n_{5}, n_{1})$：同样，由于 $n_{1}$ 不符合立即数范围，我们必须使用带有两个寄存器的 ADD。成本为 $1$。\n- $n_{7} = \\mathrm{ADD}(n_{3}, n_{4})$：两个输入都是由先前计算产生的寄存器；带有两个寄存器的 ADD 成本为 $1$。\n- $n_{8} = \\mathrm{ADD}(n_{7}, n_{6})$：类似地，带有两个寄存器的 ADD 成本为 $1$。\n\n现在我们对成本求和，注意由于共享，每个常数的具体化只计算一次：\n- 唯一大常数的具体化成本：\n  - 对于 $5000$：$2$ 条指令（在 $n_{3}$、$n_{4}$ 和 $n_{6}$ 之间共享）。\n  - 对于 $131071$：$2$ 条指令（在 $n_{5}$ 中使用）。\n  具体化的总成本是 $2 + 2 = 4$。\n- 操作符指令成本：\n  - $n_{3}$：ADD，成本 $1$。\n  - $n_{4}$：ADD，成本 $1$。\n  - $n_{5}$：MUL，成本 $1$。\n  - $n_{6}$：ADD，成本 $1$。\n  - $n_{7}$：ADD，成本 $1$。\n  - $n_{8}$：ADD，成本 $1$。\n  操作符的总成本是 $1 + 1 + 1 + 1 + 1 + 1 = 6$。\n\n因此，最小总指令数为\n$$\n4 + 6 = 10.\n$$\n\n剩下的工作是证明其最优性。任何试图在 $n_{1}$ 或 $n_{2}$ 作为操作数出现的地方使用 ADDI 代替 ADD 的尝试都是不可行的，因为 $5000$ 和 $131071$ 超出了立即数范围 $[-2048, 2047]$。没有乘法立即数指令，所以 $n_{5}$ 必须使用带有具体化常数的 MUL。没有其他模式可以减少组合中间结果所需的 ADD 数量，因为代数重组是不允许的，并且 DAG 强制了加法的精确结构。因为我们可以在 $5000$ 的三个使用处共享其具体化，所以任何将 $5000$ 具体化一次以上的覆盖都是严格次优的。因此，计算出的覆盖是最优的，最小总指令数为 $10$。",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "在编译器优化中，最直观的策略（例如，总是共享公共子表达式）并不总是最优的。这个练习提出了一个更高级的优化挑战，迫使你进行成本效益分析。你需要权衡是计算一次某个值并在多个地方共享它，还是为了使用更高效的融合指令而重复计算它，从而找到整体成本最低的解决方案。",
            "id": "3634928",
            "problem": "编译器后端必须通过用目标机器指令模式覆盖中间表示有向无环图 (DAG) 来执行指令选择。在加性成本模型中，每条选择的指令都有一个整数成本，总成本是 DAG 覆盖中所有指令成本的总和。考虑以下情况：一个共享的生产者节点为多个消费者节点提供输入。\n\n生产者节点是 $S = \\mathrm{SHL}(x, 1)$，即按常数 1 左移。按常数进行 $\\mathrm{SHL}$ 的成本是 $1$ 个成本单位。值 $S$ 被四个消费者节点使用：\n- $C_1 = \\mathrm{ADD}(S, a)$，非融合成本为 $2$。\n- $C_2 = \\mathrm{SUB}(b, S)$，非融合成本为 $2$。\n- $C_3 = \\mathrm{AND}(S, c)$，非融合成本为 $1$。\n- $C_4 = \\mathrm{XOR}(S, d)$，非融合成本为 $1$。\n\n目标机器还提供了融合指令模式，这些模式包含了 $\\mathrm{SHL}(x,1)$ 的计算和消费者操作，但这些融合模式仅在结果 $S$ 不被共享时才适用（即，为该消费者提供输入的 $\\mathrm{SHL}$ 不被任何其他消费者使用）。融合模式及其成本如下：\n- $\\mathrm{FADD}(x, a)$ 计算 $\\mathrm{ADD}(\\mathrm{SHL}(x,1), a)$，成本为 $1$。\n- $\\mathrm{FSUB}(b, x)$ 计算 $\\mathrm{SUB}(b, \\mathrm{SHL}(x,1))$，成本为 $2$。\n- $\\mathrm{FAND}(x, c)$ 计算 $\\mathrm{AND}(\\mathrm{SHL}(x,1), c)$，成本为 $1$。\n- $\\mathrm{FXOR}(x, d)$ 计算 $\\mathrm{XOR}(\\mathrm{SHL}(x,1), d)$，成本为 $2$。\n\n假设采用加性成本模型，并忽略寄存器分配和调度的影响。您可以选择计算一次 $S$ 并在消费者的任意子集中共享它（这些消费者必须使用非融合模式），也可以选择在消费者的任意子集中复制 $\\mathrm{SHL}(x,1)$ 的计算，以便为这些消费者启用相应的融合模式。如果没有消费者共享 $S$，则无需单独具化 $S$。\n\n从有向无环图覆盖和加性成本模型的基本定义出发，推导出一个有原则的决策准则，用于判断何时进行复制是有益的，并计算在所有选择（哪些消费者（如果有的话）应该接收复制的计算以启用融合模式）中可实现的精确最小总成本（以成本单位计）。请以单个整数成本单位作为最终答案。由于所有成本都是整数，因此无需四舍五入。",
            "solution": "该问题要求在加性成本模型下，为指令复制提供一个决策准则，并求出计算图片段的最小总成本。该问题提法恰当，在编译器理论中有科学依据，并包含了获得唯一解所需的所有信息。\n\n首先，让我们将问题形式化。我们有四个消费者节点，用 $i \\in \\{1, 2, 3, 4\\}$ 索引。对于每个消费者 $i$，我们有两种实现选择：\n1. 一条成本为 $C_{nf,i}$ 的非融合指令。该指令以值 $S = \\mathrm{SHL}(x, 1)$ 作为输入，该值由一个共享的生产者节点计算得出。计算一次 $S$ 的成本为 $C_{S} = 1$。\n2. 一条成本为 $C_{f,i}$ 的融合指令。该指令直接计算消费者操作作用于移位值 $\\mathrm{SHL}(x, 1)$ 的等效结果，并且只有当生产者节点 $S$ 为该消费者复制时（即其结果不被任何其他消费者使用时）才能使用。成本 $C_{f,i}$ 包括了 $\\mathrm{SHL}$ 操作的成本。\n\n给定的成本如下：\n- 生产者成本：$C_{S} = 1$。\n- 非融合消费者成本：$C_{nf,1}=2$，$C_{nf,2}=2$，$C_{nf,3}=1$，$C_{nf,4}=1$。\n- 融合指令成本：$C_{f,1}=1$，$C_{f,2}=2$，$C_{f,3}=1$，$C_{f,4}=2$。\n\n任务是将消费者集合 $I = \\{1, 2, 3, 4\\}$ 划分为两个不相交的集合：$I_{share}$，即使用单个共享计算 $S$ 结果的消费者集合；以及 $I_{fuse}$，即我们将为其使用融合指令的消费者集合。总成本是所有选定指令成本的总和。\n\n总成本函数 $Cost(I_{share}, I_{fuse})$ 可以表示为：\n$$Cost(I_{share}, I_{fuse}) = (\\text{Cost of shared portion}) + (\\text{Cost of fused portion})$$\n融合部分的成本是各个融合指令成本的总和：$\\sum_{j \\in I_{fuse}} C_{f,j}$。共享部分的成本取决于是否有节点实际在共享。如果 $I_{share}$ 非空，我们必须支付共享生产者 $S$ 的成本 $C_{S}$，以及每条非融合消费者指令的成本。如果 $I_{share}$ 为空，则此成本为 $0$。令 $\\delta(I_{share})$ 为一个指示函数，如果 $I_{share}$ 非空，则其值为 $1$，否则为 $0$。总成本为：\n$$Cost(I_{share}, I_{fuse}) = \\delta(I_{share}) \\cdot C_{S} + \\sum_{i \\in I_{share}} C_{nf,i} + \\sum_{j \\in I_{fuse}} C_{f,j}$$\n由于 $I_{share}$ 和 $I_{fuse}$ 构成了 $I$ 的一个划分，我们可以将问题定义为找到使该函数最小化的集合 $I_{fuse} \\subseteq I$。\n\n**有原则的复制决策准则**\n\n为了推导出一个关于何时复制（即使用融合模式）是有益的准则，我们可以分析将单个消费者 $k$ 从共享组 $I_{share}$ 移动到融合组 $I_{fuse}$ 时总成本的变化 $\\Delta Cost$。我们必须考虑两种情况。\n\n情况 1：共享组最初包含多个消费者，即 $|I_{share}|  1$。\n设初始划分为 $(I_{share}, I_{fuse})$。成本为 $Cost_{old} = C_{S} + \\sum_{i \\in I_{share}} C_{nf,i} + \\sum_{j \\in I_{fuse}} C_{f,j}$。\n我们将消费者 $k \\in I_{share}$ 移动到融合组。新的划分为 $(I'_{share}, I'_{fuse})$，其中 $I'_{share} = I_{share} \\setminus \\{k\\}$ 且 $I'_{fuse} = I_{fuse} \\cup \\{k\\}$。由于 $|I_{share}|  1$，新的共享组 $I'_{share}$ 非空。\n新的成本为 $Cost_{new} = C_{S} + \\sum_{i \\in I'_{share}} C_{nf,i} + \\sum_{j \\in I'_{fuse}} C_{f,j} = C_{S} + (\\sum_{i \\in I_{share}} C_{nf,i} - C_{nf,k}) + (\\sum_{j \\in I_{fuse}} C_{f,j} + C_{f,k})$。\n成本变化为 $\\Delta Cost = Cost_{new} - Cost_{old} = C_{f,k} - C_{nf,k}$。\n因此，如果 $\\Delta Cost  0$，即 $C_{f,k}  C_{nf,k}$，那么为消费者 $k$ 进行复制是有益的。\n\n情况 2：共享组最初只包含一个消费者，即 $I_{share} = \\{k\\}$。\n初始成本为 $Cost_{old} = C_{S} + C_{nf,k} + \\sum_{j \\in I_{fuse}} C_{f,j}$。\n我们将消费者 $k$ 移动到融合组。新的共享组 $I'_{share}$ 现在为空。\n新的成本为 $Cost_{new} = 0 + \\sum_{j \\in I_{fuse} \\cup \\{k\\}} C_{f,j} = \\sum_{j \\in I_{fuse}} C_{f,j} + C_{f,k}$。\n成本变化为 $\\Delta Cost = Cost_{new} - Cost_{old} = (C_{f,k} + \\sum_{j \\in I_{fuse}} C_{f,j}) - (C_{S} + C_{nf,k} + \\sum_{j \\in I_{fuse}} C_{f,j}) = C_{f,k} - C_{nf,k} - C_{S}$。\n因此，如果 $\\Delta Cost  0$，即 $C_{f,k}  C_{nf,k} + C_{S}$，那么为最后一个共享消费者 $k$ 进行复制是有益的。\n\n**最小总成本的计算**\n\n由于只有 4 个消费者，因此有 $2^4 = 16$ 种可能的划分。我们可以通过穷举评估每种划分的成本来找到最小值，按融合消费者的数量 $|I_{fuse}|$ 分组。\n\n令 $I_{fuse}$ 为融合消费者的索引集合。那么 $I_{share} = \\{1,2,3,4\\} \\setminus I_{fuse}$。\n\n情况 $|I_{fuse}| = 0$：$I_{fuse} = \\emptyset$。\n$I_{share} = \\{1,2,3,4\\}$。共享组非空。\n总成本 = $C_{S} + (C_{nf,1} + C_{nf,2} + C_{nf,3} + C_{nf,4}) = 1 + (2+2+1+1) = 7$。\n\n情况 $|I_{fuse}| = 1$：\n- $I_{fuse}=\\{1\\}$：成本 = $(C_{S} + C_{nf,2}+C_{nf,3}+C_{nf,4}) + C_{f,1} = (1+2+1+1)+1 = 6$。\n- $I_{fuse}=\\{2\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,3}+C_{nf,4}) + C_{f,2} = (1+2+1+1)+2 = 7$。\n- $I_{fuse}=\\{3\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,2}+C_{nf,4}) + C_{f,3} = (1+2+2+1)+1 = 7$。\n- $I_{fuse}=\\{4\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,2}+C_{nf,3}) + C_{f,4} = (1+2+2+1)+2 = 8$。\n\n情况 $|I_{fuse}| = 2$：\n- $I_{fuse}=\\{1,2\\}$：成本 = $(C_{S} + C_{nf,3}+C_{nf,4}) + (C_{f,1}+C_{f,2}) = (1+1+1)+(1+2) = 6$。\n- $I_{fuse}=\\{1,3\\}$：成本 = $(C_{S} + C_{nf,2}+C_{nf,4}) + (C_{f,1}+C_{f,3}) = (1+2+1)+(1+1) = 6$。\n- $I_{fuse}=\\{1,4\\}$：成本 = $(C_{S} + C_{nf,2}+C_{nf,3}) + (C_{f,1}+C_{f,4}) = (1+2+1)+(1+2) = 7$。\n- $I_{fuse}=\\{2,3\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,4}) + (C_{f,2}+C_{f,3}) = (1+2+1)+(2+1) = 7$。\n- $I_{fuse}=\\{2,4\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,3}) + (C_{f,2}+C_{f,4}) = (1+2+1)+(2+2) = 8$。\n- $I_{fuse}=\\{3,4\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,2}) + (C_{f,3}+C_{f,4}) = (1+2+2)+(1+2) = 8$。\n\n情况 $|I_{fuse}| = 3$：\n- $I_{fuse}=\\{1,2,3\\}$：成本 = $(C_{S} + C_{nf,4}) + (C_{f,1}+C_{f,2}+C_{f,3}) = (1+1)+(1+2+1) = 6$。\n- $I_{fuse}=\\{1,2,4\\}$：成本 = $(C_{S} + C_{nf,3}) + (C_{f,1}+C_{f,2}+C_{f,4}) = (1+1)+(1+2+2) = 7$。\n- $I_{fuse}=\\{1,3,4\\}$：成本 = $(C_{S} + C_{nf,2}) + (C_{f,1}+C_{f,3}+C_{f,4}) = (1+2)+(1+1+2) = 7$。\n- $I_{fuse}=\\{2,3,4\\}$：成本 = $(C_{S} + C_{nf,1}) + (C_{f,2}+C_{f,3}+C_{f,4}) = (1+2)+(2+1+2) = 8$。\n\n情况 $|I_{fuse}| = 4$：$I_{fuse} = \\{1,2,3,4\\}$。\n$I_{share} = \\emptyset$。共享部分的成本为 $0$。\n总成本 = $C_{f,1}+C_{f,2}+C_{f,3}+C_{f,4} = 1+2+1+2 = 6$。\n\n通过评估所有 16 种可能的配置，我们发现最小总成本是 6 个成本单位。这个最小成本可以通过几种不同的配置实现，例如，只融合消费者 1，或融合所有消费者。",
            "answer": "$$\\boxed{6}$$"
        }
    ]
}