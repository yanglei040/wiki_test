{
    "hands_on_practices": [
        {
            "introduction": "Mastering the linear scan algorithm begins with a solid grasp of its core mechanics. This exercise provides a hands-on opportunity to trace the algorithm on a straight-line code block. You will derive live intervals for temporary variables and simulate the allocator's process to determine the peak register pressure, which dictates the minimum number of registers ($k^{\\star}$) needed to avoid spilling.",
            "id": "3650259",
            "problem": "Consider a straight-line Intermediate Representation (IR) block with temporaries $t_{1}, t_{2}, \\dots, t_{11}$ defined and used at program points labeled by integers $1, 2, \\dots, 12$. The IR is:\n\nAt program point $1$: $t_{1} \\leftarrow a + b$.\nAt program point $2$: $t_{2} \\leftarrow t_{1} + c$.\nAt program point $3$: $t_{3} \\leftarrow t_{1} \\times t_{2}$.\nAt program point $4$: $t_{4} \\leftarrow t_{3} + d$.\nAt program point $5$: $t_{5} \\leftarrow t_{2} + t_{4}$.\nAt program point $6$: $t_{6} \\leftarrow t_{5} + e$.\nAt program point $7$: $t_{7} \\leftarrow t_{6} + t_{3}$.\nAt program point $8$: $t_{8} \\leftarrow t_{7} + t_{4}$.\nAt program point $9$: $t_{9} \\leftarrow t_{8} + t_{2}$.\nAt program point $10$: $t_{10} \\leftarrow t_{9} + t_{1}$.\nAt program point $11$: $t_{11} \\leftarrow t_{10} + t_{5}$.\nAt program point $12$: $\\text{out} \\leftarrow t_{11} + t_{6}$.\n\nAssume the standard definition of liveness and live intervals in a straight-line block: the live interval of a temporary $t_{i}$ is the half-open interval $[s_{i}, e_{i})$, where $s_{i}$ is the index where $t_{i}$ is defined, and $e_{i}$ is one plus the largest index where $t_{i}$ is used.\n\nApply Linear Scan Register Allocation (LSRA). Linear Scan Register Allocation (LSRA) processes intervals in order of increasing $s_{i}$, maintains an active set of intervals sorted by their end indices, expires any active interval $j$ with $e_{j} \\le s_{i}$ when moving to $t_{i}$, and if the active set has size $k$ at the start of $t_{i}$ (after expiration), it performs a spill decision to keep at most $k$ intervals in registers. Assume each temporary requires exactly one register for the duration of its interval, and ignore any coalescing.\n\nYour task:\n- Derive the live intervals $[s_{i}, e_{i})$ from the IR by first principles of liveness.\n- Conceptually trace LSRA’s walk over starts $s_{i}$ and identify when a spill decision would occur as a function of $k$.\n- Finally, compute the minimal integer $k^{\\star}$ such that, under LSRA, no spill decisions occur anywhere in the block.\n\nExpress your final answer as a single integer $k^{\\star}$. No rounding is required and no units apply. The work you show may include identifying where spills would occur for particular values of $k$, but the final answer must be only the value of $k^{\\star}$.",
            "solution": "The objective is to determine the minimal integer number of registers, denoted $k^{\\star}$, required to allocate all temporary variables in the given Intermediate Representation (IR) block using the Linear Scan Register Allocation (LSRA) algorithm without any spills.\n\nFirst, we must derive the live interval for each temporary variable $t_i$. According to the problem definition, the live interval is a half-open interval $[s_i, e_i)$, where $s_i$ is the program point at which $t_i$ is defined, and $e_i$ is one plus the largest program point where $t_i$ is used.\n\nWe analyze the IR to find the definition point ($s_i$) and all use points for each temporary $t_i$. The last use point determines $e_i$.\n\n- For $t_1$: Defined at $s_1=1$. Uses are at points $2$, $3$, and $10$. The last use is at point $10$, so $e_1 = 10+1=11$. The interval is $[1, 11)$.\n- For $t_2$: Defined at $s_2=2$. Uses are at points $3$, $5$, and $9$. The last use is at point $9$, so $e_2 = 9+1=10$. The interval is $[2, 10)$.\n- For $t_3$: Defined at $s_3=3$. Uses are at points $4$ and $7$. The last use is at point $7$, so $e_3 = 7+1=8$. The interval is $[3, 8)$.\n- For $t_4$: Defined at $s_4=4$. Uses are at points $5$ and $8$. The last use is at point $8$, so $e_4 = 8+1=9$. The interval is $[4, 9)$.\n- For $t_5$: Defined at $s_5=5$. Uses are at points $6$ and $11$. The last use is at point $11$, so $e_5 = 11+1=12$. The interval is $[5, 12)$.\n- For $t_6$: Defined at $s_6=6$. Uses are at points $7$ and $12$. The last use is at point $12$, so $e_6 = 12+1=13$. The interval is $[6, 13)$.\n- For $t_7$: Defined at $s_7=7$. The only use is at point $8$. The last use is at point $8$, so $e_7 = 8+1=9$. The interval is $[7, 9)$.\n- For $t_8$: Defined at $s_8=8$. The only use is at point $9$. The last use is at point $9$, so $e_8 = 9+1=10$. The interval is $[8, 10)$.\n- For $t_9$: Defined at $s_9=9$. The only use is at point $10$. The last use is at point $10$, so $e_9 = 10+1=11$. The interval is $[9, 11)$.\n- For $t_{10}$: Defined at $s_{10}=10$. The only use is at point $11$. The last use is at point $11$, so $e_{10} = 11+1=12$. The interval is $[10, 12)$.\n- For $t_{11}$: Defined at $s_{11}=11$. The only use is at point $12$. The last use is at point $12$, so $e_{11} = 12+1=13$. The interval is $[11, 13)$.\n\nNext, we apply the LSRA algorithm. The algorithm processes intervals sorted by their start points $s_i$. To avoid spilling when allocating a register for a new interval $t_i$, the number of available registers, $k$, must be strictly greater than the number of intervals already in the `active` set (i.e., those that have started but not yet ended). The minimal required number of registers, $k^{\\star}$, is therefore one more than the maximum number of intervals that are active just before allocating a new interval. This is equivalent to finding the maximum number of simultaneously overlapping live intervals at any point in the program.\n\nLet's trace the LSRA process and the size of the `active` set, denoted $|\\text{active}|$, just before allocating each new interval $t_i$. Intervals are processed in the order $t_1, t_2, \\ldots, t_{11}$.\n\n1.  Process $t_1$ (starts at $s_1=1$): The `active` set is empty. $|\\text{active}|=0$. Need $k > 0$.\n2.  Process $t_2$ (starts at $s_2=2$): No intervals expire. The `active` set is $\\{t_1\\}$. $|\\text{active}|=1$. Need $k > 1$.\n3.  Process $t_3$ (starts at $s_3=3$): No intervals expire. The `active` set is $\\{t_1, t_2\\}$. $|\\text{active}|=2$. Need $k > 2$.\n4.  Process $t_4$ (starts at $s_4=4$): No intervals expire. The `active` set is $\\{t_1, t_2, t_3\\}$. $|\\text{active}|=3$. Need $k > 3$.\n5.  Process $t_5$ (starts at $s_5=5$): No intervals expire. The `active` set is $\\{t_1, t_2, t_3, t_4\\}$. $|\\text{active}|=4$. Need $k > 4$.\n6.  Process $t_6$ (starts at $s_6=6$): No intervals expire. The `active` set is $\\{t_1, t_2, t_3, t_4, t_5\\}$. $|\\text{active}|=5$. Need $k > 5$.\n7.  Process $t_7$ (starts at $s_7=7$): No intervals expire. The `active` set is $\\{t_1, t_2, t_3, t_4, t_5, t_6\\}$. $|\\text{active}|=6$. To allocate $t_7$ without a spill, we require $k > 6$. This establishes that $k^{\\star} \\ge 7$. After allocation, the size of the `active` set becomes $7$.\n8.  Process $t_8$ (starts at $s_8=8$): The interval for $t_3$ is $[3, 8)$. Since $e_3 = 8 \\le s_8=8$, it expires and is removed from the `active` set. The `active` set becomes $\\{t_1, t_2, t_4, t_5, t_6, t_7\\}$. $|\\text{active}|=6$. Again, to allocate $t_8$ without a spill, we require $k > 6$. This confirms the requirement $k^{\\star} \\ge 7$.\n9.  Process $t_9$ (starts at $s_9=9$): The intervals for $t_4$ ($[4, 9)$) and $t_7$ ($[7, 9)$) expire since $e_4=9 \\le 9$ and $e_7=9 \\le 9$. The `active` set becomes $\\{t_1, t_2, t_5, t_6, t_8\\}$. $|\\text{active}|=5$. This requires $k > 5$.\n10. Process $t_{10}$ (starts at $s_{10}=10$): Intervals $t_2$ ($[2, 10)$) and $t_8$ ($[8, 10)$) expire. The `active` set becomes $\\{t_1, t_5, t_6, t_9\\}$. $|\\text{active}|=4$. This requires $k > 4$.\n11. Process $t_{11}$ (starts at $s_{11}=11$): Intervals $t_1$ ($[1, 11)$) and $t_9$ ($[9, 11)$) expire. The `active` set becomes $\\{t_5, t_6, t_{10}\\}$. $|\\text{active}|=3$. This requires $k > 3$.\n\nThe most stringent requirement encountered is $k > 6$, which occurred when processing $t_7$ and $t_8$. The minimal integer $k$ satisfying $k > 6$ is $7$.\n\nAlternatively, $k^{\\star}$ is the maximum number of intervals that are simultaneously live at any program point $p$. Let's check the number of active intervals at program point $p=7$:\n- $t_1: [1, 11)$ is active at $7$.\n- $t_2: [2, 10)$ is active at $7$.\n- $t_3: [3, 8)$ is active at $7$.\n- $t_4: [4, 9)$ is active at $7$.\n- $t_5: [5, 12)$ is active at $7$.\n- $t_6: [6, 13)$ is active at $7$.\n- $t_7: [7, 9)$ is active at $7$.\nAll seven intervals $\\{t_1, t_2, t_3, t_4, t_5, t_6, t_7\\}$ are simultaneously active at point $7$. The number of concurrently live temporaries is $7$. This peak pressure determines the minimum number of registers required.\n\nTherefore, the minimal number of registers required to avoid any spills is $7$.",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "When register pressure exceeds the number of available registers, the compiler must spill a value to memory—but the choice of which value to spill is critical for performance. This practice delves into the economics of spilling by presenting a high-pressure scenario within a nested loop. Your task is to analyze and compare the dynamic execution costs ($C$) associated with spilling different values, thereby gaining insight into the heuristics that guide modern compilers.",
            "id": "3650266",
            "problem": "A compiler backend uses linear scan register allocation with live range splitting at loop boundaries. Consider the following three-level nested loops and value lifetimes. There are $R=2$ allocatable physical registers available to hold the three simultaneously live values $x$, $y$, and $s$ inside the innermost loop. Outside the innermost loop, only $x$ may be live, and there is no additional register pressure.\n\nThe program structure is as follows, with iteration counts given by $N_{o}=100$ for the outer loop, $N_{m}=50$ for the middle loop, and $N_{i}=20$ for the inner loop:\n\n- At the start of each outer-loop iteration, define $x$ once. The value $x$ is loop-invariant with respect to the middle and inner loops and is never redefined inside them.\n- At the start of each middle-loop iteration, define $y$ once. The value $y$ is loop-invariant with respect to the inner loop and is not used outside the associated middle-loop iteration.\n- At the start of each middle-loop iteration, define an accumulator $s$. Then, in each inner-loop iteration:\n  - Use $x$ once and $y$ once to compute an update to $s$.\n  - Update $s$ once per inner-loop iteration (so $s$ is live across inner-loop iterations).\n- After each inner loop completes, there is exactly one use of $x$ in the middle-loop body. After the middle loop completes, there is exactly one final use of $x$ in the outer-loop body. The final outer-loop use can reuse any $x$ reload performed immediately after the last inner loop.\n\nYou are allowed to split live ranges only at the entry and exit of the innermost loop. Inside the inner loop, since $x$, $y$, and $s$ are all simultaneously live and $R=2$, you must choose exactly one of $\\{x,y,s\\}$ to spill for the entire duration of the inner loop. Outside the inner loop, you may keep $x$ in a register without additional pressure.\n\nThe dynamic spill cost model is as follows:\n\n- Each executed load of a spilled value contributes $1$ to the cost, and each executed store of a spilled value contributes $1$ to the cost. The total dynamic spill cost $C$ is the total number of executed spill loads and stores across all iterations.\n- If $v \\in \\{x,y\\}$ is ever spilled at any point in its live range, then immediately after its definition at its loop level, a single store is performed per defining loop iteration to materialize its memory home. For $x$, this is once per outer-loop iteration; for $y$, this is once per middle-loop iteration.\n- If a value is spilled inside the inner loop and is used $U$ times in the inner loop body of a given middle-loop iteration, that contributes $U$ loads for that middle-loop iteration.\n- If $x$ is spilled inside the inner loop, then for each middle-loop iteration, after the inner loop completes, a single load is required to use $x$ once in the middle-loop body. The final use of $x$ at the end of the outer loop reuses the load from the last middle-loop iteration, incurring no extra load.\n- If $s$ is not kept in a register inside the inner loop, then each inner-loop iteration performs one load of $s$ and one store of $s$.\n\nAssume there are no other simultaneous live values, no function calls, and no calling convention effects. Choose the inner-loop splitting and spill placement that minimizes $C$, and compute the minimal $C$ as an exact integer (number of memory operations). No rounding is required. Express your final answer as a single number.",
            "solution": "The task is to determine which of the three values—$x$, $y$, or $s$—should be spilled during the execution of the innermost loop to minimize the total dynamic spill cost, $C$. We must calculate the cost for each of the three mutually exclusive scenarios and select the one with the minimum cost. Let these costs be $C_x$, $C_y$, and $C_s$.\n\nThe total number of executions for each loop level are:\n- Outer loop: $N_o = 100$ times.\n- Middle loop: $N_o \\times N_m = 100 \\times 50 = 5000$ times.\n- Inner loop: $N_o \\times N_m \\times N_i = 100 \\times 50 \\times 20 = 100000$ times.\n\n**Case 1: Spill value $x$**\n\nIf $x$ is spilled, the costs are incurred as follows:\n1.  **Initial Store:** A store of $x$ to its memory home is performed once per definition. $x$ is defined once per outer-loop iteration.\n    - Cost of stores = $N_o = 100$.\n2.  **Inner Loop Loads:** $x$ is used once in each inner-loop iteration. Since it is spilled, each use requires a load.\n    - Cost of inner-loop loads = $1 \\times (N_o \\times N_m \\times N_i) = 100000$.\n3.  **Middle Loop Loads:** $x$ is used once in the middle-loop body after the inner loop completes. This happens for each middle-loop iteration and requires a load.\n    - Cost of middle-loop loads = $1 \\times (N_o \\times N_m) = 5000$.\n4.  **Outer Loop Load:** The final use of $x$ reuses the load from the last middle-loop iteration, incurring no extra cost.\n\nThe total cost for spilling $x$, $C_x$, is the sum of these components:\n$$C_x = N_o + (N_o \\times N_m \\times N_i) + (N_o \\times N_m)$$\n$$C_x = 100 + (100 \\times 50 \\times 20) + (100 \\times 50) = 100 + 100000 + 5000 = 105100$$\n\n**Case 2: Spill value $y$**\n\nIf $y$ is spilled, the costs are incurred as follows:\n1.  **Initial Store:** A store of $y$ is performed once per definition. $y$ is defined once per middle-loop iteration.\n    - Cost of stores = $N_o \\times N_m = 100 \\times 50 = 5000$.\n2.  **Inner Loop Loads:** $y$ is used once in each inner-loop iteration, requiring a load each time.\n    - Cost of inner-loop loads = $1 \\times (N_o \\times N_m \\times N_i) = 100000$.\nThe value $y$ is not used outside the inner loop, so there are no other spill costs.\n\nThe total cost for spilling $y$, $C_y$, is the sum of these components:\n$$C_y = (N_o \\times N_m) + (N_o \\times N_m \\times N_i)$$\n$$C_y = (100 \\times 50) + (100 \\times 50 \\times 20) = 5000 + 100000 = 105000$$\n\n**Case 3: Spill value $s$**\n\nIf the accumulator $s$ is spilled, the cost model states that each update within the inner loop requires one load and one store.\n1.  **Inner Loop Loads and Stores:** The value of $s$ is updated once per inner-loop iteration. This consists of loading the old value, computing the new value, and storing the new value.\n    - Cost per inner-loop iteration = $1$ load + $1$ store = $2$.\n    - Total cost = $2 \\times (N_o \\times N_m \\times N_i) = 2 \\times 100000 = 200000$.\nThere are no other specified costs for spilling $s$.\n\nThe total cost for spilling $s$, $C_s$, is:\n$$C_s = 2 \\times N_o \\times N_m \\times N_i$$\n$$C_s = 2 \\times (100 \\times 50 \\times 20) = 2 \\times 100000 = 200000$$\n\n**Comparison and Final Answer**\n\nWe compare the total dynamic spill costs for the three cases:\n- $C_x = 105100$\n- $C_y = 105000$\n- $C_s = 200000$\n\nThe minimum cost is achieved by spilling value $y$.\n$$C_{min} = \\min(C_x, C_y, C_s) = \\min(105100, 105000, 200000) = 105000$$\n\nThe minimal dynamic spill cost is $105000$. This results from spilling the value $y$ inside the innermost loop, while keeping $x$ and $s$ in the two available registers.",
            "answer": "$$\\boxed{105000}$$"
        },
        {
            "introduction": "Spilling and reloading from memory is not always the most efficient solution to high register pressure. This exercise introduces rematerialization, an optimization where it is sometimes cheaper to recompute a value than to access memory. By setting up and solving a cost equation, you will determine the crossover point ($r^{\\ast}$) where rematerialization becomes more profitable than spilling, a key trade-off in compiler design.",
            "id": "3650284",
            "problem": "Consider a target machine with $R$ allocatable general-purpose registers and a linear scan register allocator. Costs are modeled as follows: each memory access (load or store) costs $c_{\\text{mem}}$, and each arithmetic/logic instruction costs $c_{\\text{alu}}$. Assume that all memory accesses have the same cost $c_{\\text{mem}}$ and all arithmetic/logic instructions have the same cost $c_{\\text{alu}}$.\n\nYou are given the following straight-line code fragment (pseudo-assembly), where constant materialization for a $32$-bit immediate $K$ requires exactly $t=2$ arithmetic/logic instructions (for example, one high-immediate construct and one add-immediate), and where $K$ is used at $U=5$ later points:\n- At program point $p_1$, a rematerializable value $k$ is defined by materializing the constant $K$ (this definition itself uses existing arithmetic/logic instructions that are part of the program semantics and is not optional).\n- Between $p_1$ and program points $p_2, p_3, p_4, p_5, p_6$, the value $k$ is used exactly $U=5$ times, once at each of these points.\n- Due to register pressure with $R=2$ allocatable registers and the live ranges of other temporaries (not shown), the linear scan allocator must spill $k$ immediately after $p_1$; $k$ cannot be kept resident in a register across its uses.\n\nTwo allocation strategies are considered:\n1. Baseline spilling: store $k$ to its spill slot at $p_1$ and reload $k$ from memory immediately before each of its $U=5$ uses.\n2. Rematerialization: do not store $k$ at $p_1$ and, instead of reloading from memory, recompute $k$ immediately before each of its $U=5$ uses by re-materializing $K$ using $t=2$ arithmetic/logic instructions per use.\n\nAssume no other costs differ between the two strategies, and assume the def at $p_1$ must exist in both strategies to compute $k$ initially as required by the program semantics. The rematerialization strategy reduces memory traffic but increases the total number of instructions.\n\nDefine the crossover point as the value of the ratio $r^{\\ast}=\\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$ for which the total cost of the baseline spilling strategy equals the total cost of the rematerialization strategy. Compute $r^{\\ast}$ for the scenario described above and express your final answer as a simplified exact expression with no units. No rounding is required.",
            "solution": "The goal is to determine the crossover point, defined by the ratio $r^{\\ast} = \\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$, at which the total cost of the baseline spilling strategy is equal to the total cost of the rematerialization strategy. Let $C_{\\text{spill}}$ represent the total additional cost incurred by the spilling strategy and $C_{\\text{remat}}$ be the total additional cost for the rematerialization strategy. The cost of the initial definition of the value $k$ at program point $p_1$ is common to both strategies and is therefore excluded from the comparison.\n\nFirst, let us analyze the cost of the baseline spilling strategy, $C_{\\text{spill}}$.\nThe problem states that due to register pressure, the value $k$ must be spilled immediately after its definition at $p_1$. This means the allocator inserts a `store` instruction to write the value of $k$ from a register to its spill slot in memory. This single operation incurs a cost of $c_{\\text{mem}}$.\nSubsequently, before each of the $U=5$ uses of $k$ (at points $p_2$ through $p_6$), the value must be read back from memory into a register. This requires inserting a `load` instruction before each use. Since there are $U=5$ uses, this results in $U$ load operations. The total cost for these loads is $U \\times c_{\\text{mem}}$.\nThe total additional cost for the spilling strategy is the sum of the initial store cost and the subsequent load costs:\n$$ C_{\\text{spill}} = 1 \\cdot c_{\\text{mem}} + U \\cdot c_{\\text{mem}} = (U+1) c_{\\text{mem}} $$\nGiven that the number of uses is $U=5$, the cost is:\n$$ C_{\\text{spill}} = (5+1) c_{\\text{mem}} = 6 c_{\\text{mem}} $$\n\nNext, let us analyze the cost of the rematerialization strategy, $C_{\\text{remat}}$.\nIn this strategy, the value $k$ is not stored to memory after its definition at $p_1$, so there is no `store` cost. Instead of loading the value from memory before each use, it is recomputed.\nThe value $k$ is defined by materializing a constant $K$, which requires $t=2$ arithmetic/logic instructions. This recomputation is performed before each of the $U=5$ uses.\nThe total number of additional arithmetic/logic instructions is the product of the number of uses and the number of instructions per rematerialization, which is $U \\times t$.\nThe cost of a single arithmetic/logic instruction is $c_{\\text{alu}}$. Therefore, the total additional cost for the rematerialization strategy is:\n$$ C_{\\text{remat}} = (U \\cdot t) \\cdot c_{\\text{alu}} $$\nGiven the values $U=5$ and $t=2$, the cost is:\n$$ C_{\\text{remat}} = (5 \\cdot 2) c_{\\text{alu}} = 10 c_{\\text{alu}} $$\n\nThe crossover point occurs when the costs of the two strategies are equal:\n$$ C_{\\text{spill}} = C_{\\text{remat}} $$\nSubstituting the derived expressions for the costs:\n$$ (U+1) c_{\\text{mem}} = (U \\cdot t) c_{\\text{alu}} $$\nWe are asked to find the ratio $r^{\\ast} = \\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$. We can find this by rearranging the equation:\n$$ r^{\\ast} = \\frac{c_{\\text{mem}}}{c_{\\text{alu}}} = \\frac{U \\cdot t}{U+1} $$\nNow, we substitute the specified numerical values, $U=5$ and $t=2$, into this expression:\n$$ r^{\\ast} = \\frac{5 \\cdot 2}{5+1} = \\frac{10}{6} $$\nSimplifying the fraction gives the final result:\n$$ r^{\\ast} = \\frac{5}{3} $$\nThis value represents the ratio of memory access cost to ALU operation cost at which both strategies are equally expensive.",
            "answer": "$$\\boxed{\\frac{5}{3}}$$"
        }
    ]
}