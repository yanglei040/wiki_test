{
    "hands_on_practices": [
        {
            "introduction": "常量传播是编译器优化中的一项基本技术。这项练习将指导你从头开始构建用于常量传播的格结构，定义相遇（meet）算子，并将其应用于一个简单的控制流图，以正确地合并在控制流交汇点的信息。通过这个实践，你将掌握数据流分析的核心机制。",
            "id": "3657805",
            "problem": "对于单个变量的前向必须常量传播分析使用抽象域 $D = \\{\\perp\\} \\cup \\{n \\in \\mathbb{Z}\\} \\cup \\{\\top\\}$，其中 $\\perp$ 表示不可达信息，$n$ 表示变量绝对是整数常量 $n$，而 $\\top$ 表示变量不是单个常量。考虑变量集 $V = \\{x,y,z,w\\}$ 的逐点积域 $D^{V}$。你需要构建 $D$ 上的格结构，选择一个序关系，在该序关系下，跨前驱节点的汇合是一个 meet 算子，它将冲突的常量合并为 $\\top$。\n\n任务：\n- 使用格论的第一性原理，为 $D$ 指定一个偏序 $\\preceq$，使 $(D,\\preceq)$ 成为一个适用于前向必须常量传播分析的格，并从此序关系推导出二元 meet 算子 $a \\sqcap b$ 在 $D$ 上的精确、分情况的定义。\n- 然后，在控制流图 (CFG) 的连接点 $P$ 处，为前向必须常量传播分析分析以下代码片段。假设抽象域中的算术运算当且仅当所有操作数都是常量时才计算为常量；否则它产生 $\\top$。\n\n程序（P的三个前驱）：\n- 入口：$y := 7$；控制流分裂到 $B_{1}$、$B_{2}$、$B_{3}$。\n- 块 $B_{1}$：$x := 4$; $z := y$; $w := 0$; goto $P$。\n- 块 $B_{2}$：$x := 5$; $z := 9$; $w := x - x$; goto $P$。\n- 块 $B_{3}$：assume false; $x := 100$; $z := 1000$; $w := 10000$; goto $P$。\n\n$B_{3}$ 中的守卫条件始终为 false，因此通过 $B_{3}$ 的路径是不可达的。\n\n问题：在点 $P$，使用你的 $a \\sqcap b$ 算子对来自三个前驱的传入抽象状态进行交会后，计算 $V$ 中抽象值（在 $D$ 中）为 $\\top$ 的变量数量。请以整数形式给出最终答案。",
            "solution": "该问题要求我们对给定的代码片段执行前向必须常量传播分析。这个过程包括两个主要部分：首先，为抽象域定义格结构；其次，应用这个结构来分析代码。\n\n第1部分：定义格和 Meet 算子\n\n问题的抽象域为 $D = \\{\\perp\\} \\cup \\{n \\in \\mathbb{Z}\\} \\cup \\{\\top\\}$。\n- $\\top$ 表示变量不是一个单一的常量 (Not-a-Constant)。\n- $n \\in \\mathbb{Z}$ 表示变量的常量值为 $n$。\n- $\\perp$ 表示程序点不可达 (Unreachable)。\n\n对于一个“必须”分析，汇合操作是相遇（meet, $\\sqcap$），它计算其操作数的最大下界（Greatest Lower Bound, GLB）。为了使相遇算子符合常量传播的逻辑，我们需要定义一个偏序关系 $\\sqsubseteq$：\n- 当两条路径给出冲突的常量值时（例如 $c_1$ 和 $c_2$），它们的结果必须是 $\\top$ (Not-a-Constant)。根据 GLB 的定义，$c_1 \\sqcap c_2 = \\top$，这意味着 $\\top$ 必须是所有常量 $c$ 的下界，即 $\\top \\sqsubseteq c$ 对所有 $c \\in \\mathbb{Z}$ 成立。因此，$\\top$ 是格的**底元素** (bottom element)。\n- 当一条可达路径与一条不可达路径汇合时，我们只关心可达路径的信息。这意味着 $x \\sqcap \\perp = x$ 对于任何 $x \\in D$ 都成立。根据 GLB 的定义，这意味着 $x \\sqsubseteq \\perp$ 对所有 $x$ 成立。因此，$\\perp$ 是格的**顶元素** (top element)。\n\n综上，我们为 $D$ 定义了如下的偏序关系 $\\sqsubseteq$：\n$$ \\forall c \\in \\mathbb{Z}, \\quad \\top \\sqsubseteq c \\sqsubseteq \\perp $$\n任何两个不同的常量 $c_1, c_2$ 是不可比较的。\n\n在这个格结构 $(D, \\sqsubseteq)$ 中，相遇算子 $a \\sqcap b$（即 $a$ 和 $b$ 的最大下界）定义如下：\n- $a \\sqcap \\perp = a$ (与顶元素相遇，结果不变)。\n- $a \\sqcap \\top = \\top$ (与底元素相遇，结果为底)。\n- 对于常量 $c_1, c_2 \\in \\mathbb{Z}$：\n    - 若 $c_1 = c_2$，则 $c_1 \\sqcap c_2 = c_1$。\n    - 若 $c_1 \\neq c_2$，则它们的最大下界是 $\\top$。因此，$c_1 \\sqcap c_2 = \\top$。\n\n此框架是根据问题要求构建的，并与代码分析的逻辑一致。\n\n第2部分：分析代码片段\n\n分析在变量集 $V = \\{x, y, z, w\\}$ 的积域 $D^V$ 上执行。一个抽象状态是一个元组 $(v_x, v_y, v_z, v_w)$。状态的 meet 操作是逐点执行的。\n\n程序以语句 $y := 7$ 开始。假设在此之前变量不是常量（或未知），那么进入三个后继块（$B_1, B_2, B_3$）时的状态是 $S_{in} = (\\top, 7, \\top, \\top)$。我们现在追踪每个块的执行，以找出它们出口处的抽象状态。\n\n- **通过块 $B_1$ 的路径**：\n    - 入口状态：$(\\top, 7, \\top, \\top)$。\n    - 在 `x := 4` 之后：$(4, 7, \\top, \\top)$。\n    - 在 `z := y` 之后：由于 $y$ 的抽象值是 $7$， $z$ 被赋值为 $7$。状态变为 $(4, 7, 7, \\top)$。\n    - 在 `w := 0` 之后：状态变为 $(4, 7, 7, 0)$。\n    - 来自 $B_1$ 的输出状态是 $S_{out,1} = (4, 7, 7, 0)$。\n\n- **通过块 $B_2$ 的路径**：\n    - 入口状态：$(\\top, 7, \\top, \\top)$。\n    - 在 `x := 5` 之后：$(5, 7, \\top, \\top)$。\n    - 在 `z := 9` 之后：$(5, 7, 9, \\top)$。\n    - 在 `w := x - x` 之后：$x$ 的抽象值是 $5$。操作是 $5 - 5$，其计算结果为常量 $0$。状态变为 $(5, 7, 9, 0)$。\n    - 来自 $B_2$ 的输出状态是 $S_{out,2} = (5, 7, 9, 0)$。\n\n- **通过块 $B_3$ 的路径**：\n    - 该块以 `assume false` 开始，此路径不可达。\n    - 对于数据流分析，不可达路径贡献格的顶元素 $\\perp$。\n    - 来自 $B_3$ 的输出状态是 $S_{out,3} = (\\perp, \\perp, \\perp, \\perp)$。\n\n在连接点 $P$ 处，我们计算来自三个前驱块的抽象状态的 meet：\n$$S_P = S_{out,1} \\sqcap S_{out,2} \\sqcap S_{out,3}$$\n$$S_P = (4, 7, 7, 0) \\sqcap (5, 7, 9, 0) \\sqcap (\\perp, \\perp, \\perp, \\perp)$$\n\n我们逐点计算每个变量的 meet：\n- $v_x = 4 \\sqcap 5 \\sqcap \\perp$。由于 $4 \\neq 5$，所以 $4 \\sqcap 5 = \\top$。然后，$\\top \\sqcap \\perp = \\top$。所以，$v_x = \\top$。\n- $v_y = 7 \\sqcap 7 \\sqcap \\perp$。由于常量相等，$7 \\sqcap 7 = 7$。然后，$7 \\sqcap \\perp = 7$。所以，$v_y = 7$。\n- $v_z = 7 \\sqcap 9 \\sqcap \\perp$。由于 $7 \\neq 9$，所以 $7 \\sqcap 9 = \\top$。然后，$\\top \\sqcap \\perp = \\top$。所以，$v_z = \\top$。\n- $v_w = 0 \\sqcap 0 \\sqcap \\perp$。由于常量相等，$0 \\sqcap 0 = 0$。然后，$0 \\sqcap \\perp = 0$。所以，$v_w = 0$。\n\n点 $P$ 处的最终抽象状态是 $S_P = (\\top, 7, \\top, 0)$。\n\n问题要求的是抽象值为 $\\top$ 的变量数量。\n- 变量 $x$：抽象值为 $\\top$。\n- 变量 $y$：抽象值为 $7$。\n- 变量 $z$：抽象值为 $\\top$。\n- 变量 $w$：抽象值为 $0$。\n\n抽象值为 $\\top$ 的变量是 $x$ 和 $z$。数量为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "别名分析是另一项至关重要的静态分析技术，它用于确定不同的变量名是否可能指向同一内存位置。这项练习将挑战你将格理论应用于一个全新的领域——变量的分区集合，以跟踪“必然别名”（must-alias）关系。这个过程将展示抽象释义框架的普适性和强大功能，让你理解如何为更复杂的程序属性建模。",
            "id": "3657763",
            "problem": "考虑一个在控制流图（CFG）上进行的前向必别名数据流分析，该分析定义在有限变量集 $V = \\{a,b,c,d\\}$ 上。数据流域是 $V$ 的所有分区的集合，记为 $\\Pi(V)$，具有以下结构：\n\n- 偏序关系：对于 $P, Q \\in \\Pi(V)$，当且仅当 $P$ 是 $Q$ 的一个细化时，记为 $P \\preceq Q$。等价地，如果由 $P$ 导出的等价关系 $R_{P} \\subseteq V \\times V$ 满足 $R_{P} \\subseteq R_{Q}$。\n- 交会算子：对于 $P, Q \\in \\Pi(V)$，交会 $P \\wedge Q \\in \\Pi(V)$ 通过等价关系 $R_{P \\wedge Q} = R_{P} \\cap R_{Q}$ 定义，这是 $P$ 和 $Q$ 的公共细化。\n- 转移函数：每个语句 $\\operatorname{alias}(u,v)$（其中 $u,v \\in V$）定义了一个单调转移函数 $f_{u,v} : \\Pi(V) \\to \\Pi(V)$，它将一个分区 $P$ 映射到一个新的分区，该新分区的等价关系是包含 $R_{P} \\cup \\{(u,v),(v,u)\\}$ 的最小等价关系。也就是说，它合并 $P$ 中包含 $u$ 和 $v$ 的块（然后在自反性、对称性和传递性下闭合）。\n\n该CFG由一个入口节点、一个菱形分支结构和一个汇合后块组成，其边上的语句标签如下：\n\n- 从入口到左分支，该块先应用 $\\operatorname{alias}(a,b)$，然后应用 $\\operatorname{alias}(b,c)$。\n- 从入口到右分支，该块应用 $\\operatorname{alias}(a,b)$。\n- 两个分支在一个汇合节点处连接。\n- 汇合后，一个最终块应用 $\\operatorname{alias}(c,d)$，然后流向出口。\n\n假设入口处的初始输入是离散分区 $P_{\\text{entry}} = \\{\\{a\\},\\{b\\},\\{c\\},\\{d\\}\\}$（在 $\\preceq$ 序下 $\\Pi(V)$ 的底元素）。仅使用上述定义，沿着CFG执行基于交会的不动点计算，以确定出口分区。你的答案必须是出口分区中的块数，表示为一个实值整数。无需单位，也无需四舍五入。",
            "solution": "该问题要求计算给定控制流图（CFG）出口处的必别名数据流事实。这是一个定义在变量集 $V = \\{a, b, c, d\\}$ 的分区格上的前向数据流分析问题。分析过程是通过在CFG中传播分区信息，对语句应用转移函数，并在汇合点应用交会算子来进行的。\n\n格域是 $\\Pi(V)$，即 $V$ 的所有分区的集合。偏序关系由细化给出：对于两个分区 $P, Q \\in \\Pi(V)$，$P \\preceq Q$ 当且仅当 $P$ 是 $Q$ 的一个细化。该格的底元素代表最少的信息（没有已知的别名），是每个变量都在其自己的块中的离散分区。\n\nCFG入口点的初始条件给定为底元素：\n$P_{\\text{entry}} = \\{\\{a\\}, \\{b\\}, \\{c\\}, \\{d\\}\\}$。\n\n分析过程如下：\n\n1.  **从入口流向分支**：数据流事实 $P_{\\text{entry}}$ 传播到左、右两个分支的输入端。设 $P_{L_{\\text{in}}}$ 和 $P_{R_{\\text{in}}}$ 分别是左、右分支输入端的分区。\n    $$P_{L_{\\text{in}}} = P_{R_{\\text{in}}} = P_{\\text{entry}} = \\{\\{a\\}, \\{b\\}, \\{c\\}, \\{d\\}\\}$$\n\n2.  **左分支分析**：左分支包含一个由两个顺序语句组成的块：先是 $\\operatorname{alias}(a,b)$，然后是 $\\operatorname{alias}(b,c)$。我们按顺序应用它们对应的转移函数。\n    -   $\\operatorname{alias}(a,b)$ 的转移函数（记为 $f_{a,b}$）合并包含 $a$ 和 $b$ 的块。\n        $$P_1 = f_{a,b}(P_{L_{\\text{in}}}) = f_{a,b}(\\{\\{a\\}, \\{b\\}, \\{c\\}, \\{d\\}\\}) = \\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}$$\n    -   接着，将 $\\operatorname{alias}(b,c)$ 的转移函数（记为 $f_{b,c}$）应用于 $P_1$。它合并包含 $b$ 的块（即 $\\{a,b\\}$）和包含 $c$ 的块（即 $\\{c\\}$）。\n        $$P_{L_{\\text{out}}} = f_{b,c}(P_1) = f_{b,c}(\\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}) = \\{\\{a,b,c\\}, \\{d\\}\\}$$\n    这是左分支输出端的数据流事实。\n\n3.  **右分支分析**：右分支包含单个语句 $\\operatorname{alias}(a,b)$。\n    -   将其转移函数 $f_{a,b}$ 应用于输入分区 $P_{R_{\\text{in}}}$。\n        $$P_{R_{\\text{out}}} = f_{a,b}(P_{R_{\\text{in}}}) = f_{a,b}(\\{\\{a\\}, \\{b\\}, \\{c\\}, \\{d\\}\\}) = \\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}$$\n    这是右分支输出端的数据流事实。\n\n4.  **汇合点分析**：两个分支在一个汇合节点处合并。对于“必”分析，汇合点的数据流事实是所有入路径事实的交会。交会算子 $\\wedge$ 由相应等价关系的交集定义：$R_{P \\wedge Q} = R_P \\cap R_Q$。这对应于在格中找到输入分区的最大下界（GLB），即它们的最细公共细化。\n    -   汇合点的输入是 $P_{L_{\\text{out}}} = \\{\\{a,b,c\\}, \\{d\\}\\}$ 和 $P_{R_{\\text{out}}} = \\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}$。\n    -   我们需要计算 $P_{\\text{join}} = P_{L_{\\text{out}}} \\wedge P_{R_{\\text{out}}}$。\n    -   让我们在细化序 $\\preceq$ 下分析这两个分区之间的关系。如果分区 $P$ 中的每个块都是分区 $Q$ 中某个块的子集，则称分区 $P$ 细化分区 $Q$（$P \\preceq Q$）。\n    -   考虑 $P_{R_{\\text{out}}}$ 的块：$\\{a,b\\}$、$\\{c\\}$ 和 $\\{d\\}$。\n    -   考虑 $P_{L_{\\text{out}}}$ 的块：$\\{a,b,c\\}$ 和 $\\{d\\}$。\n    -   我们检查 $P_{R_{\\text{out}}}$ 是否细化 $P_{L_{\\text{out}}}$：\n        -   来自 $P_{R_{\\text{out}}}$ 的块 $\\{a,b\\}$ 是来自 $P_{L_{\\text{out}}}$ 的块 $\\{a,b,c\\}$ 的子集。\n        -   来自 $P_{R_{\\text{out}}}$ 的块 $\\{c\\}$ 是来自 $P_{L_{\\text{out}}}$ 的块 $\\{a,b,c\\}$ 的子集。\n        -   来自 $P_{R_{\\text{out}}}$ 的块 $\\{d\\}$ 是来自 $P_{L_{\\text{out}}}$ 的块 $\\{d\\}$ 的子集。\n    -   由于 $P_{R_{\\text{out}}}$ 的所有块都是 $P_{L_{\\text{out}}}$ 中块的子集，因此我们有 $P_{R_{\\text{out}}} \\preceq P_{L_{\\text{out}}}$。\n    -   当一个元素小于或等于另一个元素时，这两个元素的交会（GLB）就是较小的那个元素。\n        $$P_{\\text{join}} = P_{L_{\\text{out}}} \\wedge P_{R_{\\text{out}}} = P_{R_{\\text{out}}} = \\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}$$\n    这个分区成为汇合后块的输入。\n\n5.  **汇合后块分析**：汇合后，一个最终块应用语句 $\\operatorname{alias}(c,d)$。\n    -   将转移函数 $f_{c,d}$ 应用于分区 $P_{\\text{join}}$。它合并包含 $c$ 的块（即 $\\{c\\}$）和包含 $d$ 的块（即 $\\{d\\}$）。\n        $$P_{\\text{exit}} = f_{c,d}(P_{\\text{join}}) = f_{c,d}(\\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}) = \\{\\{a,b\\}, \\{c,d\\}\\}$$\n    这是CFG出口处的最终分区。\n\n6.  **最终答案**：问题要求的是出口分区 $P_{\\text{exit}}$ 中的块数。\n    -   出口分区是 $P_{\\text{exit}} = \\{\\{a,b\\}, \\{c,d\\}\\}$。\n    -   这些块是 $\\{a,b\\}$ 和 $\\{c,d\\}$。\n    -   块的数量是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "本练习旨在探讨数据流分析的理论边界。你将使用一个专门设计的非分配性格（non-distributive lattice）来揭示一个深刻的概念：当传递函数不满足分配律时，标准的数据流分析算法可能会损失精度。通过计算算法结果（最大不动点，MFP）与理想结果（所有路径上的相遇，MOP）之间的差异，你将亲身体会到为什么分配律如此重要。",
            "id": "3657744",
            "problem": "考虑在一个小的控制流图（CFG）上进行一次前向的 may 型到达定义分析，该图有两条并行路径在一个汇合块处合并。其基础是 Kildall 的单调数据流分析框架：一个数据流问题指定了一个流事实的格、一个汇合算子以及沿边应用的单调转换函数；该算法计算一个最大不动点（MFP）。众所周知，当框架是分配性的，即当每个转换函数对汇合算子都满足分配律时，MFP 等于所有路径上交汇（MOP）解。在本问题中，您将为到达定义构建一个非分配性框架，并量化其精度损失。\n\n设单个变量的具体定义标识符全集为 $D = \\{d_{1}, d_{2}, d_{3}\\}$。我们定义一个抽象域（一个商格）$L = \\{\\bot, a, b, c, \\top\\}$，通过具体化映射 $\\gamma : L \\to \\mathcal{P}(D)$ 具有以下解释：\n- $\\gamma(\\bot) = \\varnothing$，\n- $\\gamma(a) = \\{d_{1}\\}$，\n- $\\gamma(b) = \\{d_{2}\\}$，\n- $\\gamma(c) = \\{d_{1}, d_{2}\\}$，\n- $\\gamma(\\top) = \\{d_{1}, d_{2}, d_{3}\\}$。\n\n为 $L$ 配备由代表元上的逆子集关系导出的偏序，即对于 $x, y \\in L$，当且仅当 $\\gamma(x) \\supseteq \\gamma(y)$ 时，$x \\preceq y$。使用汇合算子 $\\sqcap$ 作为 $\\preceq$ 中的最大下界，它与代表元上的集合论并集一致：\n$$\nx \\sqcap y \\;=\\; \\alpha\\big(\\gamma(x) \\cup \\gamma(y)\\big),\n$$\n其中 $\\alpha$ 是自然抽象，它将 $\\mathcal{P}(D)$ 中的具体集映射到 $L$，方法是将任何包含 $d_{3}$ 的集合都折叠到 $\\top$，否则完全如上所述进行映射。具体来说，$\\sqcap$ 满足对于任何 $x \\in L$，$a \\sqcap b = c$，$c \\sqcap a = c$，$c \\sqcap b = c$，$\\top \\sqcap x = \\top$，以及 $\\bot \\sqcap x = x$。\n\n在汇合块处定义一个转换函数 $f : L \\to L$，该函数模拟一个粗略的、路径敏感的“类 phi”合并，当且仅当 $d_{1}$ 和 $d_{2}$ 可能同时到达时，它会引入一个新的定义 $d_{3}$。形式上，令 $p : \\mathcal{P}(D) \\to \\mathcal{P}(D)$ 为\n$$\np(S) \\;=\\; \\begin{cases}\nS \\cup \\{d_{3}\\},  \\text{若 } \\{d_{1}, d_{2}\\} \\subseteq S, \\\\\nS,  \\text{否则},\n\\end{cases}\n$$\n并设 $f(x) = \\alpha\\big(p(\\gamma(x))\\big)$。这个 $f$ 相对于 $\\preceq$ 是单调的，但它对 $\\sqcap$ 不满足分配律。\n\n现在考虑一个 CFG 片段，其中左前驱为汇合块产生抽象输入 $a$（只有 $d_{1}$ 可能到达），右前驱产生 $b$（只有 $d_{2}$ 可能到达）。汇合点出口处的 MFP 解是将转换函数应用于前驱的汇合结果，即 $f(a \\sqcap b)$，而同一程序点上的 MOP 解是 $f(a) \\sqcap f(b)$。\n\n计算整数差\n$$\n\\Delta \\;=\\; \\big|\\gamma\\big(f(a \\sqcap b)\\big)\\big| \\;-\\; \\big|\\gamma\\big(f(a) \\sqcap f(b)\\big)\\big|,\n$$\n其中 $|\\cdot|$ 表示集合的基数。请以整数形式表达您的最终答案。无需四舍五入，也无需单位。",
            "solution": "该问题要求计算最大不动点（MFP）解和所有路径上交汇（MOP）解在具体域中的大小差异，以揭示非分配性框架导致的精度损失。\n\n我们将分别计算 $\\Delta = |\\gamma(f(a \\sqcap b))| - |\\gamma(f(a) \\sqcap f(b))|$ 中的两项。\n\n**第1步：计算 MFP 项 $|\\gamma(f(a \\sqcap b))|$**\n\n该项表示先在抽象域中汇合，然后应用转换函数。\n\n1.  **计算汇合结果 $a \\sqcap b$**：\n    根据汇合算子的定义，$x \\sqcap y = \\alpha(\\gamma(x) \\cup \\gamma(y))$。\n    -   $\\gamma(a) = \\{d_1\\}$\n    -   $\\gamma(b) = \\{d_2\\}$\n    -   $\\gamma(a) \\cup \\gamma(b) = \\{d_1, d_2\\}$\n    -   现在应用抽象函数 $\\alpha$。因为 $\\{d_1, d_2\\}$ 不包含 $d_3$，所以根据定义，$\\alpha(\\{d_1, d_2\\}) = c$。\n    -   因此，$a \\sqcap b = c$。\n\n2.  **应用转换函数 $f$**：\n    现在我们计算 $f(a \\sqcap b) = f(c)$。\n    -   函数定义为 $f(x) = \\alpha(p(\\gamma(x)))$。\n    -   $\\gamma(c) = \\{d_1, d_2\\}$。\n    -   将具体转换函数 $p$ 应用于 $\\gamma(c)$。$p(S)$ 的定义是，如果 $\\{d_1, d_2\\} \\subseteq S$，则 $p(S) = S \\cup \\{d_3\\}$。\n    -   对于 $S = \\{d_1, d_2\\}$，该条件为真。\n    -   因此，$p(\\{d_1, d_2\\}) = \\{d_1, d_2\\} \\cup \\{d_3\\} = \\{d_1, d_2, d_3\\}$。\n    -   最后，应用抽象函数 $\\alpha$。任何包含 $d_3$ 的集合都会被映射到 $\\top$。\n    -   所以，$f(c) = \\alpha(\\{d_1, d_2, d_3\\}) = \\top$。\n\n3.  **计算具体集的大小**：\n    MFP 解是 $\\top$。其具体化的大小是：\n    $|\\gamma(f(a \\sqcap b))| = |\\gamma(\\top)| = |\\{d_1, d_2, d_3\\}| = 3$。\n\n**第2步：计算 MOP 项 $|\\gamma(f(a) \\sqcap f(b))|$**\n\n该项表示先对每条路径应用转换函数，然后在抽象域中汇合结果。\n\n1.  **分别应用转换函数 $f$**：\n    -   计算 $f(a)$:\n        -   $\\gamma(a) = \\{d_1\\}$。\n        -   应用 $p$ 到 $\\{d_1\\}$。条件 $\\{d_1, d_2\\} \\subseteq \\{d_1\\}$ 为假。\n        -   因此，$p(\\{d_1\\}) = \\{d_1\\}$。\n        -   $f(a) = \\alpha(\\{d_1\\}) = a$。\n    -   计算 $f(b)$:\n        -   $\\gamma(b) = \\{d_2\\}$。\n        -   应用 $p$ 到 $\\{d_2\\}$。条件 $\\{d_1, d_2\\} \\subseteq \\{d_2\\}$ 为假。\n        -   因此，$p(\\{d_2\\}) = \\{d_2\\}$。\n        -   $f(b) = \\alpha(\\{d_2\\}) = b$。\n\n2.  **计算汇合结果 $f(a) \\sqcap f(b)$**：\n    我们现在需要计算 $a \\sqcap b$。正如在第1步中计算的那样，$a \\sqcap b = c$。\n    -   所以，$f(a) \\sqcap f(b) = c$。\n\n3.  **计算具体集的大小**：\n    MOP 解是 $c$。其具体化的大小是：\n    $|\\gamma(f(a) \\sqcap f(b))| = |\\gamma(c)| = |\\{d_1, d_2\\}| = 2$。\n\n**第3步：计算差值 $\\Delta$**\n$$\n\\Delta = |\\gamma(f(a \\sqcap b))| - |\\gamma(f(a) \\sqcap f(b))| = 3 - 2 = 1\n$$\n这个值为1的差异量化了精度损失。MFP 分析（先合并后转换）错误地推断出定义 $d_3$ 可能到达，而更精确的 MOP 分析（先转换后合并）正确地排除了这种可能性。",
            "answer": "$$\n\\boxed{1}\n$$"
        }
    ]
}