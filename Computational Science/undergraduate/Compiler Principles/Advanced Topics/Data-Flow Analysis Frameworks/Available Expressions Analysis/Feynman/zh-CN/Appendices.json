{
    "hands_on_practices": [
        {
            "introduction": "循环是程序优化的重点区域，这个练习聚焦于一个嵌套循环的场景，旨在揭示一个重要且微妙的区别：循环不变表达式与可用表达式。你将分析一个在内层循环中计算，但在外层循环中其操作数被修改的表达式。通过这个过程，你将理解为何一个表达式即使在循环内部是“不变的”，但根据严格的可用表达式分析定义，它在循环头部却可能并“不可用”。",
            "id": "3622919",
            "problem": "考虑以下构成双层循环嵌套的结构化三地址代码。该程序仅在内层循环体中计算表达式 $x+y$，且仅在外层循环体中修改 $x$。假设 $N$ 和 $M$ 是正整数，变量 $x$、$y$、$i$、$j$ 和 $t$ 均为标量。\n\n入口块 $B_{0}$：\n- 将 $x$ 和 $y$ 初始化为任意值。\n- 设置 $i \\leftarrow 0$。\n\n外层循环头 $B_{1}$：\n- 测试 $i  N$；若为真，则跳转到 $B_{2}$；否则，退出。\n\n外层循环体前序 $B_{2}$：\n- 更新 $x \\leftarrow x + 1$。\n- 设置 $j \\leftarrow 0$。\n- 跳转到 $B_{3}$。\n\n内层循环头 $B_{3}$：\n- 测试 $j  M$；若为真，则跳转到 $B_{4}$；否则，跳转到 $B_{5}$。\n\n内层循环体 $B_{4}$：\n- 计算 $t \\leftarrow x + y$。\n- 更新 $j \\leftarrow j + 1$。\n- 跳转到 $B_{3}$。\n\n外层循环尾部 $B_{5}$：\n- 更新 $i \\leftarrow i + 1$。\n- 跳转到 $B_{1}$。\n\n出口块：\n- 返回 $t$。\n\n对表达式全集 $\\mathcal{E} = \\{x+y\\}$，在控制流图 (CFG) 上执行经典的前向可用表达式分析。使用标准定义：如果从程序入口到程序点 $p$ 的每一条路径上，表达式 $e$ 都已被求值，且自其最后一次求值以来，它的任何操作数都未被重新定义，则称表达式 $e$ 在点 $p$ 处是可用的。使用标准的向前数据流框架，其中交集为交会算子，传递函数为 $\\mathrm{OUT}[B] = \\mathrm{GEN}[B] \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}[B])$，边界条件为 $\\mathrm{IN}[\\text{entry}] = \\varnothing$。\n\n令内层循环头点为 $B_{3}$ 的起始处，外层循环头点为 $B_{1}$ 的起始处。定义指示变量 $A_{\\text{in}}$ 和 $A_{\\text{out}}$，其中如果 $x+y$ 在内层循环头处可用，则 $A_{\\text{in}} = 1$，否则 $A_{\\text{in}} = 0$；类似地，如果 $x+y$ 在外层循环头处可用，则 $A_{\\text{out}} = 1$，否则 $A_{\\text{out}} = 0$。报告单个整数代码\n$$C = A_{\\text{in}} + 2 A_{\\text{out}}.$$\n精确计算 $C$。你的最终答案必须是一个不带单位的整数。",
            "solution": "此问题要求使用经典的前向可用表达式分析，确定表达式 $x+y$ 在两个特定程序点——内层和外层循环的头部——的可用性。\n\n首先，我们根据问题描述建立控制流图 (CFG)。基本块为 $B_0$ 到 $B_5$。每个块的前驱如下：\n- $\\mathrm{pred}(B_0) = \\emptyset$ (入口块)\n- $\\mathrm{pred}(B_1) = \\{B_0, B_5\\}$\n- $\\mathrm{pred}(B_2) = \\{B_1\\}$\n- $\\mathrm{pred}(B_3) = \\{B_2, B_4\\}$\n- $\\mathrm{pred}(B_4) = \\{B_3\\}$\n- $\\mathrm{pred}(B_5) = \\{B_3\\}$\n\n该分析是针对表达式全集 $\\mathcal{E} = \\{x+y\\}$ 进行的。我们为每个基本块 $B$ 定义集合 $\\mathrm{GEN}[B]$（在块 $B$ 中生成的表达式）和 $\\mathrm{KILL}[B]$（在块 $B$ 中杀死的表达式）。如果一个表达式的某个操作数被重新定义，则该表达式被杀死。\n- $B_0$：初始化 $x$ 和 $y$。这重新定义了 $x+y$ 的两个操作数。\n  $\\mathrm{GEN}[B_0] = \\emptyset$, $\\mathrm{KILL}[B_0] = \\{x+y\\}$。\n- $B_1$：仅包含一个测试。没有操作数被修改，也没有表达式被计算。\n  $\\mathrm{GEN}[B_1] = \\emptyset$, $\\mathrm{KILL}[B_1] = \\emptyset$。\n- $B_2$：语句 $x \\leftarrow x + 1$ 重新定义了 $x$。\n  $\\mathrm{GEN}[B_2] = \\emptyset$, $\\mathrm{KILL}[B_2] = \\{x+y\\}$。\n- $B_3$：仅包含一个测试。\n  $\\mathrm{GEN}[B_3] = \\emptyset$, $\\mathrm{KILL}[B_3] = \\emptyset$。\n- $B_4$：语句 $t \\leftarrow x + y$ 计算表达式 $x+y$。没有操作数被重新定义。\n  $\\mathrm{GEN}[B_4] = \\{x+y\\}$, $\\mathrm{KILL}[B_4] = \\emptyset$。\n- $B_5$：变量 $i$ 被更新，它不是 $x+y$ 的操作数。\n  $\\mathrm{GEN}[B_5] = \\emptyset$, $\\mathrm{KILL}[B_5] = \\emptyset$。\n\n数据流分析框架被指定为一种前向分析，以交集 ($\\cap$) 为交会算子。每个块 $B$ 的入口 ($\\mathrm{IN}[B]$) 和出口 ($\\mathrm{OUT}[B]$) 处的可用表达式集合的数据流方程为：\n$$ \\mathrm{IN}[B] = \\bigcap_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $$\n$$ \\mathrm{OUT}[B] = \\mathrm{GEN}[B] \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}[B]) $$\n边界条件为 $\\mathrm{IN}[B_0] = \\emptyset$。\n\n我们迭代求解这个方程组，直到达到一个不动点。我们将集合 $\\{x+y\\}$ 简记为 $E$，空集记为 $\\emptyset$。\n\n我们可以利用 GEN/KILL 集的性质，通过代入法来解这个系统。\n1.  对 $B_0$：$\\mathrm{IN}[B_0] = \\emptyset$。\n    $\\mathrm{OUT}[B_0] = \\mathrm{GEN}[B_0] \\cup (\\mathrm{IN}[B_0] \\setminus \\mathrm{KILL}[B_0]) = \\emptyset \\cup (\\emptyset \\setminus E) = \\emptyset$。\n2.  对 $B_4$：传递函数为 $\\mathrm{OUT}[B_4] = \\mathrm{GEN}[B_4] \\cup (\\mathrm{IN}[B_4] \\setminus \\mathrm{KILL}[B_4]) = E \\cup (\\mathrm{IN}[B_4] \\setminus \\emptyset) = E$。\n    无论 $\\mathrm{IN}[B_4]$ 是什么，$\\mathrm{OUT}[B_4]$ 总是 $E=\\{x+y\\}$。\n3.  对 $B_2$：传递函数为 $\\mathrm{OUT}[B_2] = \\mathrm{GEN}[B_2] \\cup (\\mathrm{IN}[B_2] \\setminus \\mathrm{KILL}[B_2]) = \\emptyset \\cup (\\mathrm{IN}[B_2] \\setminus E) = \\emptyset$。\n    无论 $\\mathrm{IN}[B_2]$ 是什么，$\\mathrm{OUT}[B_2]$ 总是 $\\emptyset$。\n\n现在我们可以确定内层循环头 $B_3$ 处的状态。\n4.  对 $B_3$：$\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_2] \\cap \\mathrm{OUT}[B_4]$。\n    使用我们从第 2 步和第 3 步的发现：\n    $\\mathrm{IN}[B_3] = \\emptyset \\cap E = \\emptyset$。\n    由于表达式 $x+y$ 在进入内层循环的路径上（经由 $B_2$）被杀死，因此它在内层循环头处不可能是可用的，因为可用性要求该性质在*每条*路径上都成立。\n    $B_3$ 的输出是：\n    $\\mathrm{OUT}[B_3] = \\mathrm{GEN}[B_3] \\cup (\\mathrm{IN}[B_3] \\setminus \\mathrm{KILL}[B_3]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$。\n\n现在我们可以确定外层循环头 $B_1$ 处的状态。\n5.  首先，我们需要 $B_1$ 的前驱 $B_0$ 和 $B_5$ 的状态。我们已知 $\\mathrm{OUT}[B_0] = \\emptyset$。\n    对 $B_5$：$\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_3] = \\emptyset$。\n    $\\mathrm{OUT}[B_5] = \\mathrm{GEN}[B_5] \\cup (\\mathrm{IN}[B_5] \\setminus \\mathrm{KILL}[B_5]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$。\n6.  对 $B_1$：$\\mathrm{IN}[B_1] = \\mathrm{OUT}[B_0] \\cap \\mathrm{OUT}[B_5] = \\emptyset \\cap \\emptyset = \\emptyset$。\n    表达式 $x+y$ 在外层循环头处不可用。这是因为在从入口开始的初始路径上（$B_0 \\to B_1$），该表达式尚未被计算。\n\n循环头处 IN 集的不动点解为：\n- $\\mathrm{IN}[B_1] = \\emptyset$\n- $\\mathrm{IN}[B_3] = \\emptyset$\n\n现在我们计算指示变量 $A_{\\text{out}}$ 和 $A_{\\text{in}}$。\n- $A_{\\text{out}}$ 对应于 $x+y$ 在外层循环头 $B_1$ 起始处的可用性。这由 $\\mathrm{IN}[B_1]$ 决定。由于 $\\mathrm{IN}[B_1] = \\emptyset$，该表达式不可用。因此，$A_{\\text{out}} = 0$。\n- $A_{\\text{in}}$ 对应于 $x+y$ 在内层循环头 $B_3$ 起始处的可用性。这由 $\\mathrm{IN}[B_3]$ 决定。由于 $\\mathrm{IN}[B_3] = \\emptyset$，该表达式不可用。因此，$A_{\\text{in}} = 0$。\n\n最后，我们计算整数代码 $C$：\n$$ C = A_{\\text{in}} + 2 A_{\\text{out}} = 0 + 2 \\times 0 = 0 $$\n\n分析表明，根据可用表达式的标准定义，$x+y$ 在内层和外层循环头处均不可用。$B_2$ 中对 $x$ 的重新定义在进入内层循环之前杀死了该表达式，而通向外层循环的初始路径上没有进行计算，这也阻止了其在该处的可用性。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "现代编程语言通常包含复杂的控制流结构，例如异常处理。这个进阶练习将可用表达式分析应用于一个包含 `try-catch` 块的控制流图。你将需要考虑正常执行路径和异常跳转路径，并分析这两种路径如何共同影响表达式在代码块入口处的可用性。这个练习将展示数据流分析框架如何稳健地处理非线性、甚至看似不连续的控制转移。",
            "id": "3622911",
            "problem": "考虑一种具有结构化异常处理的高级语言。一个 try-catch 结构被编译成一个控制流图 (CFG)，其中正常边按直线顺序连接基本块，而异常边则从可能抛出异常的操作直接跳转到 catch 处理程序的入口。可用表达式分析是一种前向、全路径交汇、must 分析，它作用于按集合包含关系排序的候选表达式格上，并使用交集作为交汇操作。如果一个表达式在到达某个程序点的所有路径上都已被计算，并且自上次计算以来其操作数均未被重新赋值，则该表达式在该程序点是可用的。\n\n假设候选表达式集合仅限于单个表达式 $E$，其中 $E$ 为 $x \\times y$。考虑以下代码，其基本块标记为 $B_{1}$ 到 $B_{5}$，处理程序块标记为 $H$：\n\n- $B_{1}$：$e := x \\times y$。\n- $B_{2}$：$t := f(y)$，其中对 $f$ 的调用可能会抛出类型为 $\\mathsf{Ex}$ 的异常，并且对 $x$ 或 $y$ 没有副作用。\n- $B_{3}$：$k := y$。\n- 正常边：$B_{1} \\rightarrow B_{2} \\rightarrow B_{3} \\rightarrow B_{5}$。\n- 异常边：$B_{2} \\dashrightarrow H$。\n- $H$：$x := x + 1$，然后是 $m := y$，接着是正常边 $H \\rightarrow B_{5}$。\n- $B_{5}$：try-catch 结束（无进一步计算）。\n\n假设：\n- $B_{1}$ 中的乘法不会抛出异常。\n- 只有 $B_{2}$ 可能抛出异常。\n- 除了 $H$ 中对 $x$ 的赋值语句外，没有其他语句会修改 $x$ 或 $y$。\n\n使用可用表达式分析的标准定义（前向、must、对前驱节点取交集，用 $GEN$ 表示在块中计算的表达式，用 $KILL$ 表示因操作数赋值而失效的表达式），确定 $E$ 在以下位置的可用性：\n1. 处理程序块 $H$ 的入口。\n2. 块 $B_{5}$ 的入口（try-catch 结构的出口）。\n\n将可用性编码为：$1$ 表示“可用”，$0$ 表示“不可用”。以单行矩阵 $\\begin{pmatrix} a  b \\end{pmatrix}$ 的形式提供最终答案，其中 $a$ 对应于处理程序入口， $b$ 对应于出口。无需四舍五入，也无需报告单位。",
            "solution": "该问题要求我们对一个包含异常控制流的给定控制流图 (CFG) 进行可用表达式分析。该分析是一种前向的 must 分析，意味着我们沿控制流方向传播信息，并且一个表达式仅当在通往某个程序点的所有路径上都可用时，才被认为是可用的。此分析的交汇操作是集合交集。\n\n我们关心的表达式是 $E = x \\times y$。我们需要确定它在处理程序块 $H$ 的入口和块 $B_5$ 的入口处的可用性。我们分别用 $IN[B]$ 和 $OUT[B]$ 表示在块 $B$ 入口和出口处的可用表达式集合。控制该分析的数据流方程为：\n$$OUT[B] = GEN[B] \\cup (IN[B] - KILL[B])$$\n$$IN[B] = \\bigcap_{P \\in pred(B)} OUT[P]$$\n其中 $pred(B)$ 是块 $B$ 的所有前驱节点的集合。分析的初始化条件为 $IN[B_{entry}] = \\emptyset$，所有其他的 $IN$ 集合等于所有候选表达式的集合，在本例中即为 $\\{E\\}$。迭代应用这些方程，直到达到不动点。\n\n首先，我们确定每个基本块相对于表达式 $E = x \\times y$ 的 $GEN$ 和 $KILL$ 集合。\n- **块 $B_1$ ($e := x \\times y$)：** 此块计算表达式 $E$。它不重新赋值 $x$ 或 $y$。因此，$GEN[B_1] = \\{E\\}$ 且 $KILL[B_1] = \\emptyset$。\n- **块 $B_2$ ($t := f(y)$)：** 此块不计算 $E$。问题陈述表明，对 $f(y)$ 的调用对 $x$ 或 $y$ 没有副作用。因此，$GEN[B_2] = \\emptyset$ 且 $KILL[B_2] = \\emptyset$。\n- **块 $B_3$ ($k := y$)：** 此块不计算 $E$，也不修改其操作数 $x$ 或 $y$。因此，$GEN[B_3] = \\emptyset$ 且 $KILL[B_3] = \\emptyset$。\n- **块 $H$ ($x := x + 1; m := y$)：** 此块修改变量 $x$，它是 $E$ 的一个操作数。这会使表达式 $E$ 无效（kill）。该块不计算 $E$。因此，$GEN[H] = \\emptyset$ 且 $KILL[H] = \\{E\\}$。\n- **块 $B_5$ (结束)：** 此块不执行与 $E$ 相关的计算或赋值。因此，$GEN[B_5] = \\emptyset$ 且 $KILL[B_5] = \\emptyset$。\n\n该 CFG 具有以下前驱关系：\n- $pred(B_2) = \\{B_1\\}$\n- $pred(B_3) = \\{B_2\\}$ (正常路径)\n- $pred(H) = \\{B_2\\}$ (异常路径)\n- $pred(B_5) = \\{B_3, H\\}$\n\n我们现在执行迭代数据流分析。设 $U = \\{E\\}$ 为表达式的全集。\n**初始化：**\n- $IN[B_1] = \\emptyset$ (相关代码片段的入口点)。\n- 对于所有其他块 $B$，我们初始化 $IN[B] = U = \\{E\\}$。\n- 我们将所有 $OUT$ 集合初始化为 $U = \\{E\\}$ 来开始迭代，除了真正程序入口块的出口应为 $\\emptyset$。首次计算出的 $OUT$ 集合将很快修正这一点。\n\n**迭代 1：**\n我们根据每个块的 $IN$ 集合计算其 $OUT$ 集合，然后根据其前驱节点的 $OUT$ 集合更新每个块的 $IN$ 集合。\n1.  $IN[B_1] = \\emptyset$。\n    $OUT[B_1] = GEN[B_1] \\cup (IN[B_1] - KILL[B_1]) = \\{E\\} \\cup (\\emptyset - \\emptyset) = \\{E\\}$。\n\n2.  $IN[B_2] = OUT[B_1] = \\{E\\}$。\n    $OUT[B_2] = GEN[B_2] \\cup (IN[B_2] - KILL[B_2]) = \\emptyset \\cup (\\{E\\} - \\emptyset) = \\{E\\}$。\n\n3.  $B_3$ 和 $H$ 的前驱都只有 $B_2$。\n    $IN[B_3] = OUT[B_2] = \\{E\\}$。\n    $OUT[B_3] = GEN[B_3] \\cup (IN[B_3] - KILL[B_3]) = \\emptyset \\cup (\\{E\\} - \\emptyset) = \\{E\\}$。\n\n    $IN[H] = OUT[B_2] = \\{E\\}$。\n    $OUT[H] = GEN[H] \\cup (IN[H] - KILL[H]) = \\emptyset \\cup (\\{E\\} - \\{E\\}) = \\emptyset$。\n\n4.  $B_5$ 是正常路径和异常路径的汇合点。\n    $IN[B_5] = OUT[B_3] \\cap OUT[H] = \\{E\\} \\cap \\emptyset = \\emptyset$。\n    $OUT[B_5] = GEN[B_5] \\cup (IN[B_5] - KILL[B_5]) = \\emptyset \\cup (\\emptyset - \\emptyset) = \\emptyset$。\n\n**迭代 2：**\n我们使用迭代 1 结束时的值重复此过程。\n1.  $IN[B_1]$ 固定为 $\\emptyset$，$OUT[B_1]$ 保持为 $\\{E\\}$。\n2.  $IN[B_2] = OUT[B_1] = \\{E\\}$。无变化。$OUT[B_2]$ 保持为 $\\{E\\}$。\n3.  $IN[B_3] = OUT[B_2] = \\{E\\}$。无变化。$OUT[B_3]$ 保持为 $\\{E\\}$。\n4.  $IN[H] = OUT[B_2] = \\{E\\}$。无变化。$OUT[H]$ 保持为 $\\emptyset$。\n5.  $IN[B_5] = OUT[B_3] \\cap OUT[H] = \\{E\\} \\cap \\emptyset = \\emptyset$。无变化。$OUT[B_5]$ 保持为 $\\emptyset$。\n\n由于在第二次迭代期间没有 $IN$ 或 $OUT$ 集合发生变化，算法已达到不动点。最终的稳定状态是：\n- $IN[H] = \\{E\\}$\n- $IN[B_5] = \\emptyset$\n\n现在我们可以回答问题提出的两个问题了。\n\n**1. $E$ 在处理程序块 $H$ 入口处的可用性。**\n在 $H$ 入口处的可用性由集合 $IN[H]$ 给出。我们的分析结论是 $IN[H] = \\{E\\}$。这意味着表达式 $E$ 在此点是可用的。\n逻辑路径如下：到达处理程序 $H$ 的唯一方式是通过来自 $B_2$ 的异常边。要确定在 $H$ 入口处什么是可用的，我们查看在 $B_2$ 出口处什么是可用的。表达式 $E$ 在 $B_1$ 中生成，并且在 $B_2$ 中没有被 kill。因此，$OUT[B_2] = \\{E\\}$。因为这是通往 $H$ 的唯一路径，所以 $IN[H] = OUT[B_2] = \\{E\\}$。可用性编码为 $1$。\n\n**2. $E$ 在块 $B_5$ 入口处的可用性。**\n在 $B_5$ 入口处的可用性由 $IN[B_5]$ 给出。我们的分析结论是 $IN[B_5] = \\emptyset$。这意味着表达式 $E$ 是不可用的。\n逻辑如下：$B_5$ 是一个汇合点，有两个前驱节点 $B_3$ 和 $H$。在“must”分析中，一个表达式要在汇合点可用，它必须在所有进入路径上都可用。\n- **通过 $B_3$ 的路径**：$E$ 在 $B_3$ 的出口处可用，所以 $OUT[B_3] = \\{E\\}$。\n- **通过 $H$ 的路径**：$E$ 在 $H$ 的入口处可用，但在 $H$ 内部被对 $x$ 的赋值所 kill。因此，$E$ 在 $H$ 的出口处不可用，所以 $OUT[H] = \\emptyset$。\n由于 $IN[B_5]$ 是其前驱节点的 $OUT$ 集合的交集，所以 $IN[B_5] = OUT[B_3] \\cap OUT[H] = \\{E\\} \\cap \\emptyset = \\emptyset$。因为 $E$ 在异常路径上不可用，所以它不能被认为在 $B_5$ 的入口处可用。可用性编码为 $0$。\n\n最终答案是一个行矩阵，包含处理程序入口（$1$）和 try-catch 出口（$0$）的可用性代码。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1  0 \\end{pmatrix}}$$"
        }
    ]
}