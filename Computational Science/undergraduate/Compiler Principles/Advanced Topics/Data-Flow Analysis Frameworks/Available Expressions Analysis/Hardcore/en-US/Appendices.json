{
    "hands_on_practices": [
        {
            "introduction": "Mastering available expressions analysis begins with the foundational iterative algorithm. This first exercise provides a concrete control-flow graph and asks you to manually trace the flow of information, computing the $IN$ and $OUT$ sets for each basic block until a stable solution, or fixed point, is reached. This practice is essential for building an intuition for how 'must' analyses converge across branching and joining paths. ",
            "id": "3622931",
            "problem": "Consider a forward data-flow analysis for available expressions on the following control-flow graph (CFG) with basic blocks $B_1$ through $B_7$. The single expression of interest is $e = a \\times b$. The program in three-address code form is partitioned into basic blocks as follows (each bullet lists the statements in one basic block in program order):\n\n- $B_1$: $t_1 := a \\times b$, if $p$ then goto $B_2$ else goto $B_3$.\n- $B_2$: $a := a + 1$, goto $B_4$.\n- $B_3$: $t_2 := a \\times b$, goto $B_4$.\n- $B_4$: if $q$ then goto $B_5$ else goto $B_6$.\n- $B_5$: $b := b + 1$, goto $B_7$.\n- $B_6$: $t_3 := a \\times b$, goto $B_7$.\n- $B_7$: return.\n\nUse the standard framework for available expression analysis (AEA), which is a forward must analysis with meet operator set intersection. Let the universe of expressions be $U = \\{ e \\}$, where $e$ abbreviates $a \\times b$. For each basic block $B$, define:\n- $\\mathrm{GEN}_B = \\{ e \\}$ if $B$ evaluates $a \\times b$ and no assignment to $a$ or $b$ occurs after that evaluation within $B$; otherwise $\\mathrm{GEN}_B = \\varnothing$.\n- $\\mathrm{KILL}_B = \\{ e \\}$ if $B$ assigns to either $a$ or $b$ anywhere within $B$; otherwise $\\mathrm{KILL}_B = \\varnothing$.\n\nUse the canonical forward transfer function and meet:\n- For each basic block $B$, $\\mathrm{OUT}[B] = \\mathrm{GEN}_B \\cup \\left( \\mathrm{IN}[B] \\setminus \\mathrm{KILL}_B \\right)$.\n- For each basic block $B$ with predecessors $\\mathrm{pred}(B)$, $\\mathrm{IN}[B] = \\bigcap_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P]$.\n\nInitialization:\n- $\\mathrm{IN}[B_1] = \\varnothing$.\n- For all $B \\neq B_1$, $\\mathrm{IN}[B] = U$.\n\nCompute the maximal fixed point of the above equations for this CFG. Let $N$ be the number of basic blocks $B$ such that $e \\in \\mathrm{IN}[B]$ at the fixed point. Report the value of $N$ as a single integer. No rounding is necessary.",
            "solution": "The problem is well-defined, self-contained, and scientifically grounded in the principles of compiler theory, specifically data-flow analysis. It provides a complete specification of the control-flow graph (CFG), the data-flow framework (available expression analysis), the transfer functions, the meet operator, and the initialization conditions. The problem is therefore valid and a solution can be derived.\n\nThe task is to compute the maximal fixed point for the available expression sets, $\\mathrm{IN}[B]$ and $\\mathrm{OUT}[B]$, for each basic block $B$ in the given CFG. The expression of interest is $e = a \\times b$. The universe of expressions is $U = \\{e\\}$. We will use an iterative algorithm to solve the data-flow equations until a fixed point is reached.\n\nFirst, we determine the structure of the CFG by identifying the predecessors of each basic block:\n- $\\mathrm{pred}(B_1) = \\varnothing$\n- $\\mathrm{pred}(B_2) = \\{B_1\\}$\n- $\\mathrm{pred}(B_3) = \\{B_1\\}$\n- $\\mathrm{pred}(B_4) = \\{B_2, B_3\\}$\n- $\\mathrm{pred}(B_5) = \\{B_4\\}$\n- $\\mathrm{pred}(B_6) = \\{B_4\\}$\n- $\\mathrm{pred}(B_7) = \\{B_5, B_6\\}$\n\nNext, we compute the $\\mathrm{GEN}_B$ and $\\mathrm{KILL}_B$ sets for each basic block $B$ according to the provided definitions.\n- $B_1$: $t_1 := a \\times b$, ...\n  This block computes $a \\times b$ and does not subsequently modify $a$ or $b$.\n  $\\mathrm{GEN}_{B_1} = \\{e\\}$, $\\mathrm{KILL}_{B_1} = \\varnothing$.\n- $B_2$: $a := a + 1$, ...\n  This block assigns to $a$, which is a component of $e$.\n  $\\mathrm{GEN}_{B_2} = \\varnothing$, $\\mathrm{KILL}_{B_2} = \\{e\\}$.\n- $B_3$: $t_2 := a \\times b$, ...\n  This block computes $a \\times b$ and does not subsequently modify $a$ or $b$.\n  $\\mathrm{GEN}_{B_3} = \\{e\\}$, $\\mathrm{KILL}_{B_3} = \\varnothing$.\n- $B_4$: if $q$ ...\n  This block contains no relevant computations or assignments.\n  $\\mathrm{GEN}_{B_4} = \\varnothing$, $\\mathrm{KILL}_{B_4} = \\varnothing$.\n- $B_5$: $b := b + 1$, ...\n  This block assigns to $b$, which is a component of $e$.\n  $\\mathrm{GEN}_{B_5} = \\varnothing$, $\\mathrm{KILL}_{B_5} = \\{e\\}$.\n- $B_6$: $t_3 := a \\times b$, ...\n  This block computes $a \\times b$ and does not subsequently modify $a$ or $b$.\n  $\\mathrm{GEN}_{B_6} = \\{e\\}$, $\\mathrm{KILL}_{B_6} = \\varnothing$.\n- $B_7$: return.\n  This block has no relevant statements.\n  $\\mathrm{GEN}_{B_7} = \\varnothing$, $\\mathrm{KILL}_{B_7} = \\varnothing$.\n\nWe now apply the iterative algorithm to find the fixed point. The data-flow equations are:\n$$ \\mathrm{IN}[B] = \\bigcap_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $$\n$$ \\mathrm{OUT}[B] = \\mathrm{GEN}_B \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}_B) $$\n\nInitialization:\n- $\\mathrm{IN}[B_1] = \\varnothing$\n- For $B \\in \\{B_2, B_3, B_4, B_5, B_6, B_7\\}$, $\\mathrm{IN}[B] = U = \\{e\\}$.\n- All $\\mathrm{OUT}$ sets are implicitly empty or will be computed in the first pass.\n\n**Iteration 1:**\nWe calculate the $\\mathrm{OUT}$ set for each block, then update the $\\mathrm{IN}$ sets for the next iteration.\n- $\\mathrm{OUT}[B_1] = \\mathrm{GEN}_{B_1} \\cup (\\mathrm{IN}[B_1] \\setminus \\mathrm{KILL}_{B_1}) = \\{e\\} \\cup (\\varnothing \\setminus \\varnothing) = \\{e\\}$\n- $\\mathrm{IN}[B_2]$ can be updated immediately: $\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_1] = \\{e\\}$. This is the same as the initial value.\n- $\\mathrm{OUT}[B_2] = \\mathrm{GEN}_{B_2} \\cup (\\mathrm{IN}[B_2] \\setminus \\mathrm{KILL}_{B_2}) = \\varnothing \\cup (\\{e\\} \\setminus \\{e\\}) = \\varnothing$\n- $\\mathrm{IN}[B_3]$ can also be updated: $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] = \\{e\\}$. This is the same as the initial value.\n- $\\mathrm{OUT}[B_3] = \\mathrm{GEN}_{B_3} \\cup (\\mathrm{IN}[B_3] \\setminus \\mathrm{KILL}_{B_3}) = \\{e\\} \\cup (\\{e\\} \\setminus \\varnothing) = \\{e\\}$\n- Now we compute the $\\mathrm{IN}$ set for $B_4$:\n  $\\mathrm{IN}[B_4] = \\mathrm{OUT}[B_2] \\cap \\mathrm{OUT}[B_3] = \\varnothing \\cap \\{e\\} = \\varnothing$. The initial value $\\{e\\}$ changes to $\\varnothing$.\n- $\\mathrm{OUT}[B_4] = \\mathrm{GEN}_{B_4} \\cup (\\mathrm{IN}[B_4] \\setminus \\mathrm{KILL}_{B_4}) = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$\n- $\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_4] = \\varnothing$. The initial value $\\{e\\}$ changes to $\\varnothing$.\n- $\\mathrm{OUT}[B_5] = \\mathrm{GEN}_{B_5} \\cup (\\mathrm{IN}[B_5] \\setminus \\mathrm{KILL}_{B_5}) = \\varnothing \\cup (\\varnothing \\setminus \\{e\\}) = \\varnothing$\n- $\\mathrm{IN}[B_6] = \\mathrm{OUT}[B_4] = \\varnothing$. The initial value $\\{e\\}$ changes to $\\varnothing$.\n- $\\mathrm{OUT}[B_6] = \\mathrm{GEN}_{B_6} \\cup (\\mathrm{IN}[B_6] \\setminus \\mathrm{KILL}_{B_6}) = \\{e\\} \\cup (\\varnothing \\setminus \\varnothing) = \\{e\\}$\n- $\\mathrm{IN}[B_7] = \\mathrm{OUT}[B_5] \\cap \\mathrm{OUT}[B_6] = \\varnothing \\cap \\{e\\} = \\varnothing$. The initial value $\\{e\\}$ changes to $\\varnothing$.\n- $\\mathrm{OUT}[B_7] = \\mathrm{GEN}_{B_7} \\cup (\\mathrm{IN}[B_7] \\setminus \\mathrm{KILL}_{B_7}) = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$\n\nThe state after the first full iteration is:\n- $\\mathrm{IN}[B_1] = \\varnothing$, $\\mathrm{OUT}[B_1] = \\{e\\}$\n- $\\mathrm{IN}[B_2] = \\{e\\}$, $\\mathrm{OUT}[B_2] = \\varnothing$\n- $\\mathrm{IN}[B_3] = \\{e\\}$, $\\mathrm{OUT}[B_3] = \\{e\\}$\n- $\\mathrm{IN}[B_4] = \\varnothing$, $\\mathrm{OUT}[B_4] = \\varnothing$\n- $\\mathrm{IN}[B_5] = \\varnothing$, $\\mathrm{OUT}[B_5] = \\varnothing$\n- $\\mathrm{IN}[B_6] = \\varnothing$, $\\mathrm{OUT}[B_6] = \\{e\\}$\n- $\\mathrm{IN}[B_7] = \\varnothing$, $\\mathrm{OUT}[B_7] = \\varnothing$\n\n**Iteration 2:**\nWe recompute all values to check for changes.\n- $\\mathrm{OUT}[B_1]$ depends on $\\mathrm{IN}[B_1]$, which is unchanged. So $\\mathrm{OUT}[B_1] = \\{e\\}$ (no change).\n- $\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_1] = \\{e\\}$ (no change).\n- $\\mathrm{OUT}[B_2]$ depends on $\\mathrm{IN}[B_2]$, which is unchanged. So $\\mathrm{OUT}[B_2] = \\varnothing$ (no change).\n- $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] = \\{e\\}$ (no change).\n- $\\mathrm{OUT}[B_3]$ depends on $\\mathrm{IN}[B_3]$, which is unchanged. So $\\mathrm{OUT}[B_3] = \\{e\\}$ (no change).\n- $\\mathrm{IN}[B_4] = \\mathrm{OUT}[B_2] \\cap \\mathrm{OUT}[B_3] = \\varnothing \\cap \\{e\\} = \\varnothing$ (no change).\n- $\\mathrm{OUT}[B_4]$ depends on $\\mathrm{IN}[B_4]$, which is unchanged. So $\\mathrm{OUT}[B_4] = \\varnothing$ (no change).\n- $\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_4] = \\varnothing$ (no change).\n- $\\mathrm{OUT}[B_5]$ depends on $\\mathrm{IN}[B_5]$, which is unchanged. So $\\mathrm{OUT}[B_5] = \\varnothing$ (no change).\n- $\\mathrm{IN}[B_6] = \\mathrm{OUT}[B_4] = \\varnothing$ (no change).\n- $\\mathrm{OUT}[B_6]$ depends on $\\mathrm{IN}[B_6]$, which is unchanged. So $\\mathrm{OUT}[B_6] = \\{e\\}$ (no change).\n- $\\mathrm{IN}[B_7] = \\mathrm{OUT}[B_5] \\cap \\mathrm{OUT}[B_6] = \\varnothing \\cap \\{e\\} = \\varnothing$ (no change).\n- $\\mathrm{OUT}[B_7]$ depends on $\\mathrm{IN}[B_7]$, which is unchanged. So $\\mathrm{OUT}[B_7] = \\varnothing$ (no change).\n\nSince no $\\mathrm{IN}$ or $\\mathrm{OUT}$ set changed during the second iteration, the algorithm has converged, and we have reached the maximal fixed point.\n\nThe final $\\mathrm{IN}$ sets are:\n- $\\mathrm{IN}[B_1] = \\varnothing$\n- $\\mathrm{IN}[B_2] = \\{e\\}$\n- $\\mathrm{IN}[B_3] = \\{e\\}$\n- $\\mathrm{IN}[B_4] = \\varnothing$\n- $\\mathrm{IN}[B_5] = \\varnothing$\n- $\\mathrm{IN}[B_6] = \\varnothing$\n- $\\mathrm{IN}[B_7] = \\varnothing$\n\nThe problem asks for $N$, the number of basic blocks $B$ such that $e \\in \\mathrm{IN}[B]$ at the fixed point. We examine the final $\\mathrm{IN}$ sets:\n- For $B_1$, $e \\notin \\mathrm{IN}[B_1]$.\n- For $B_2$, $e \\in \\mathrm{IN}[B_2]$.\n- For $B_3$, $e \\in \\mathrm{IN}[B_3]$.\n- For $B_4$, $e \\notin \\mathrm{IN}[B_4]$.\n- For $B_5$, $e \\notin \\mathrm{IN}[B_5]$.\n- For $B_6$, $e \\notin \\mathrm{IN}[B_6]$.\n- For $B_7$, $e \\notin \\mathrm{IN}[B_7]$.\n\nThe condition $e \\in \\mathrm{IN}[B]$ is met for two basic blocks: $B_2$ and $B_3$.\nTherefore, the value of $N$ is $2$.",
            "answer": "$$ \\boxed{2} $$"
        },
        {
            "introduction": "Data-flow analysis is most powerful when applied to loops, the source of most program execution time and optimization opportunities. This problem focuses on a nested loop structure to explore how expression availability interacts with variable modifications across different loop levels. By analyzing this scenario, you will see why the strict 'must-be-available-on-all-paths' rule is crucial and how it impacts potential optimizations like loop-invariant code motion. ",
            "id": "3622919",
            "problem": "Consider the following structured three-address code that forms a two-level loop nest. The program computes the expression $x+y$ only in the inner loop body and modifies $x$ only in the outer loop body. Assume $N$ and $M$ are positive integers, and variables $x$, $y$, $i$, $j$, and $t$ are scalars.\n\nEntry block $B_{0}$:\n- Initialize $x$ and $y$ to arbitrary values.\n- Set $i \\leftarrow 0$.\n\nOuter loop header $B_{1}$:\n- Test $i < N$; if true, branch to $B_{2}$; otherwise, exit.\n\nOuter loop body prologue $B_{2}$:\n- Update $x \\leftarrow x + 1$.\n- Set $j \\leftarrow 0$.\n- Jump to $B_{3}$.\n\nInner loop header $B_{3}$:\n- Test $j < M$; if true, branch to $B_{4}$; otherwise, branch to $B_{5}$.\n\nInner loop body $B_{4}$:\n- Compute $t \\leftarrow x + y$.\n- Update $j \\leftarrow j + 1$.\n- Jump to $B_{3}$.\n\nOuter loop latch $B_{5}$:\n- Update $i \\leftarrow i + 1$.\n- Jump to $B_{1}$.\n\nExit block:\n- Return $t$.\n\nPerform classical forward available expressions analysis over the Control Flow Graph (CFG) for the universe of expressions $\\mathcal{E} = \\{x+y\\}$. Use the standard definition: an expression $e$ is available at a program point $p$ if along every path from the program entry to $p$, $e$ has been evaluated and, since its last evaluation, none of its operands have been redefined. Use the standard forward data-flow framework with intersection as the meet operator, transfer function $\\mathrm{OUT}[B] = \\mathrm{GEN}[B] \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}[B])$, and boundary condition $\\mathrm{IN}[\\text{entry}] = \\varnothing$.\n\nLet the inner loop header point be the beginning of $B_{3}$ and the outer loop header point be the beginning of $B_{1}$. Define indicator variables $A_{\\text{in}}$ and $A_{\\text{out}}$ where $A_{\\text{in}} = 1$ if $x+y$ is available at the inner loop header and $A_{\\text{in}} = 0$ otherwise; similarly, $A_{\\text{out}} = 1$ if $x+y$ is available at the outer loop header and $A_{\\text{out}} = 0$ otherwise. Report a single integer code\n$$C = A_{\\text{in}} + 2 A_{\\text{out}}.$$\nCompute $C$ exactly. Your final answer must be a single integer with no units.",
            "solution": "The problem requires a determination of the availability of the expression $x+y$ at two specific program points—the headers of the inner and outer loops—using classical forward available expressions analysis.\n\nFirst, we establish the Control Flow Graph (CFG) from the problem description. The basic blocks are $B_0$ through $B_5$. The predecessors of each block are as follows:\n- $\\mathrm{pred}(B_0) = \\emptyset$ (Entry block)\n- $\\mathrm{pred}(B_1) = \\{B_0, B_5\\}$\n- $\\mathrm{pred}(B_2) = \\{B_1\\}$\n- $\\mathrm{pred}(B_3) = \\{B_2, B_4\\}$\n- $\\mathrm{pred}(B_4) = \\{B_3\\}$\n- $\\mathrm{pred}(B_5) = \\{B_3\\}$\n\nThe analysis is performed for the universe of expressions $\\mathcal{E} = \\{x+y\\}$. We define the sets $\\mathrm{GEN}[B]$ (expressions generated in block $B$) and $\\mathrm{KILL}[B]$ (expressions killed in block $B$) for each basic block $B$. An expression is killed if one of its operands is redefined.\n- $B_0$: Initializes $x$ and $y$. This redefines both operands of $x+y$.\n  $\\mathrm{GEN}[B_0] = \\emptyset$, $\\mathrm{KILL}[B_0] = \\{x+y\\}$.\n- $B_1$: Contains only a test. No operands are modified, and no expressions are computed.\n  $\\mathrm{GEN}[B_1] = \\emptyset$, $\\mathrm{KILL}[B_1] = \\emptyset$.\n- $B_2$: The statement $x \\leftarrow x + 1$ redefines $x$.\n  $\\mathrm{GEN}[B_2] = \\emptyset$, $\\mathrm{KILL}[B_2] = \\{x+y\\}$.\n- $B_3$: Contains only a test.\n  $\\mathrm{GEN}[B_3] = \\emptyset$, $\\mathrm{KILL}[B_3] = \\emptyset$.\n- $B_4$: The statement $t \\leftarrow x + y$ computes the expression $x+y$. No operand is redefined.\n  $\\mathrm{GEN}[B_4] = \\{x+y\\}$, $\\mathrm{KILL}[B_4] = \\emptyset$.\n- $B_5$: The variable $i$ is updated, which is not an operand of $x+y$.\n  $\\mathrm{GEN}[B_5] = \\emptyset$, $\\mathrm{KILL}[B_5] = \\emptyset$.\n\nThe data-flow analysis framework is specified as a forward analysis with intersection ($\\cap$) as the meet operator. The data-flow equations for the set of available expressions at the entry ($\\mathrm{IN}[B]$) and exit ($\\mathrm{OUT}[B]$) of each block $B$ are:\n$$ \\mathrm{IN}[B] = \\bigcap_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $$\n$$ \\mathrm{OUT}[B] = \\mathrm{GEN}[B] \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}[B]) $$\nThe boundary condition is $\\mathrm{IN}[B_0] = \\emptyset$.\n\nWe solve this system of equations iteratively until a fixed point is reached. Let's denote the set $\\{x+y\\}$ simply as $E$ and the empty set as $\\emptyset$.\n\nWe can solve this system by substitution, leveraging the properties of the GEN/KILL sets.\n1.  For $B_0$: $\\mathrm{IN}[B_0] = \\emptyset$.\n    $\\mathrm{OUT}[B_0] = \\mathrm{GEN}[B_0] \\cup (\\mathrm{IN}[B_0] \\setminus \\mathrm{KILL}[B_0]) = \\emptyset \\cup (\\emptyset \\setminus E) = \\emptyset$.\n2.  For $B_4$: The transfer function is $\\mathrm{OUT}[B_4] = \\mathrm{GEN}[B_4] \\cup (\\mathrm{IN}[B_4] \\setminus \\mathrm{KILL}[B_4]) = E \\cup (\\mathrm{IN}[B_4] \\setminus \\emptyset) = E$.\n    $\\mathrm{OUT}[B_4]$ is always $E=\\{x+y\\}$, regardless of $\\mathrm{IN}[B_4]$.\n3.  For $B_2$: The transfer function is $\\mathrm{OUT}[B_2] = \\mathrm{GEN}[B_2] \\cup (\\mathrm{IN}[B_2] \\setminus \\mathrm{KILL}[B_2]) = \\emptyset \\cup (\\mathrm{IN}[B_2] \\setminus E) = \\emptyset$.\n    $\\mathrm{OUT}[B_2]$ is always $\\emptyset$, regardless of $\\mathrm{IN}[B_2]$.\n\nNow we can determine the state at the inner loop header, $B_3$.\n4.  For $B_3$: $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_2] \\cap \\mathrm{OUT}[B_4]$.\n    Using our findings from steps 2 and 3:\n    $\\mathrm{IN}[B_3] = \\emptyset \\cap E = \\emptyset$.\n    Since the expression $x+y$ is killed on the entry path to the inner loop (via $B_2$), it cannot be available at the inner loop header, as availability requires the property to hold on *every* path.\n    The output of $B_3$ is:\n    $\\mathrm{OUT}[B_3] = \\mathrm{GEN}[B_3] \\cup (\\mathrm{IN}[B_3] \\setminus \\mathrm{KILL}[B_3]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$.\n\nNow we can determine the state at the outer loop header, $B_1$.\n5.  First, we need the state of the predecessors of $B_1$, which are $B_0$ and $B_5$. We know $\\mathrm{OUT}[B_0] = \\emptyset$.\n    For $B_5$: $\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_3] = \\emptyset$.\n    $\\mathrm{OUT}[B_5] = \\mathrm{GEN}[B_5] \\cup (\\mathrm{IN}[B_5] \\setminus \\mathrm{KILL}[B_5]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$.\n6.  For $B_1$: $\\mathrm{IN}[B_1] = \\mathrm{OUT}[B_0] \\cap \\mathrm{OUT}[B_5] = \\emptyset \\cap \\emptyset = \\emptyset$.\n    The expression $x+y$ is not available at the outer loop header. This is because on the initial path from entry ($B_0 \\to B_1$), the expression has not yet been computed.\n\nThe fixed-point solution for the IN sets at the loop headers is:\n- $\\mathrm{IN}[B_1] = \\emptyset$\n- $\\mathrm{IN}[B_3] = \\emptyset$\n\nNow we compute the indicator variables $A_{\\text{out}}$ and $A_{\\text{in}}$.\n- $A_{\\text{out}}$ corresponds to the availability of $x+y$ at the beginning of the outer loop header, $B_1$. This is determined by $\\mathrm{IN}[B_1]$. Since $\\mathrm{IN}[B_1] = \\emptyset$, the expression is not available. Thus, $A_{\\text{out}} = 0$.\n- $A_{\\text{in}}$ corresponds to the availability of $x+y$ at the beginning of the inner loop header, $B_3$. This is determined by $\\mathrm{IN}[B_3]$. Since $\\mathrm{IN}[B_3] = \\emptyset$, the expression is not available. Thus, $A_{\\text{in}} = 0$.\n\nFinally, we compute the integer code $C$:\n$$ C = A_{\\text{in}} + 2 A_{\\text{out}} = 0 + 2 \\times 0 = 0 $$\n\nThe analysis demonstrates that, according to the standard definition of available expressions, $x+y$ is available at neither the inner nor the outer loop header. The redefinition of $x$ in $B_2$ kills the expression before entry to the inner loop, and the lack of computation on the initial path to the outer loop prevents its availability there.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Real-world programs frequently use pointers, which introduce uncertainty about which memory locations are being accessed—a phenomenon known as aliasing. This final practice extends our analysis to handle the complexities of pointer assignments, a critical step for ensuring the correctness of any compiler optimization. You will apply the principle of conservative analysis to determine how a single pointer store can 'kill' a wide range of expressions based on may-point-to information. ",
            "id": "3622890",
            "problem": "Consider forward data-flow analysis for Available Expressions in a basic block. Begin from the standard semantics: an expression is available at a program point if along every path to that point the expression has been computed and none of its constituent memory locations have been subsequently modified. For a direct assignment to a scalar variable, any expression containing that variable ceases to be guaranteed available after the assignment. For a store through a pointer, the set of possibly modified variables is given by the may-point-to set computed by alias analysis; expressions containing any of those variables cease to be guaranteed available. No algebraic identities (such as commutativity) are assumed for syntactic equality, so, for example, $a+b$ and $b+a$ are considered distinct expressions.\n\nYou are given the following program fragment in a single basic block (source-level pseudocode), where all variables denote scalar integer locations and the operator symbols denote standard arithmetic on those locations:\n\n1. $r_1 := a + b$\n\n2. $r_2 := x \\times y$\n\n3. $r_3 := y + a$\n\n4. $r_4 := x + y$\n\n5. $r_5 := z + a$\n\n6. $r_6 := z \\times y$\n\n7. $r_7 := a \\times y$\n\n8. $r_8 := b + a$\n\n9. $r_9 := x + a$\n\n10. $*p := 3$\n\nLet the universe of candidate expressions for Available Expressions analysis be the set of all right-hand-side arithmetic expressions that syntactically appear in the above fragment:\n$$\n\\mathcal{E} = \\{\\, a+b,\\; x\\times y,\\; y+a,\\; x+y,\\; z+a,\\; z\\times y,\\; a\\times y,\\; b+a,\\; x+a \\,\\}.\n$$\nA flow-insensitive alias analysis reports the may-point-to set for the pointer $p$ as\n$$\n\\mathrm{pts}(p) = \\{\\, x,\\; z \\,\\},\n$$\nand that $p$ does not may-alias any of $a$, $b$, or $y$. Under a conservative Available Expressions analysis, determine the cardinality of the $KILL$ set for statement $10$ relative to the universe $\\mathcal{E}$, where $KILL$ collects all expressions from $\\mathcal{E}$ that cease to be guaranteed available immediately after statement $10$ due to potential modification by $*p := 3$.\n\nProvide your final answer as a single integer. No rounding is required.",
            "solution": "An expression is available if it has been previously computed and its constituent variables have not been modified since. The problem asks us to determine the `KILL` set for statement $10$, `$*p := 3$`. In Available Expressions analysis, a statement's `KILL` set comprises all expressions from the universe of interest that are invalidated by the statement. An expression is invalidated, or \"killed\", if the statement modifies one or more of its constituent variables.\n\nThe statement in question, `$*p := 3$`, is a store through a pointer `$p$`. To determine which variables are modified, we must consult the results of an alias analysis. The problem provides the may-point-to set for `$p$` as `$\\mathrm{pts}(p) = \\{\\, x,\\; z \\,\\}`. This means that the pointer `$p$` may be an alias for (i.e., may point to the memory location of) either variable `$x$` or variable `$z$`.\n\nA conservative data-flow analysis must account for all possibilities. Therefore, the statement `$*p := 3$` must be treated as potentially modifying any variable in the may-point-to set. The set of variables potentially modified by statement $10$ is $\\{\\, x,\\; z \\,\\}$. Consequently, any expression containing either `$x$` or `$z$` as an operand is killed by this statement. The problem also states that `$p$` does not may-alias `$a$`, `$b$`, or `$y$`, confirming that these variables are not affected by the assignment.\n\nThe universe of expressions under consideration is given as:\n$$\n\\mathcal{E} = \\{\\, a+b,\\; x\\times y,\\; y+a,\\; x+y,\\; z+a,\\; z\\times y,\\; a\\times y,\\; b+a,\\; x+a \\,\\}\n$$\nWe will now examine each expression in $\\mathcal{E}$ to determine if it is killed by the potential modification of $x$ or $z$. Let $\\mathrm{vars}(e)$ denote the set of variables in an expression $e$. An expression $e$ is in the `KILL` set for statement $10$ if $\\mathrm{vars}(e) \\cap \\{\\, x,\\; z \\,\\} \\neq \\emptyset$.\n\n1.  $a+b$: $\\mathrm{vars}(a+b) = \\{a, b\\}$. Intersection with $\\{\\,x, z\\,\\}$ is $\\emptyset$. This expression is not killed.\n2.  $x\\times y$: $\\mathrm{vars}(x\\times y) = \\{x, y\\}$. Intersection with $\\{\\,x, z\\,\\}$ is $\\{x\\}$. This expression is killed.\n3.  $y+a$: $\\mathrm{vars}(y+a) = \\{y, a\\}$. Intersection with $\\{\\,x, z\\,\\}$ is $\\emptyset$. This expression is not killed.\n4.  $x+y$: $\\mathrm{vars}(x+y) = \\{x, y\\}$. Intersection with $\\{\\,x, z\\,\\}$ is $\\{x\\}$. This expression is killed.\n5.  $z+a$: $\\mathrm{vars}(z+a) = \\{z, a\\}$. Intersection with $\\{\\,x, z\\,\\}$ is $\\{z\\}$. This expression is killed.\n6.  $z\\times y$: $\\mathrm{vars}(z\\times y) = \\{z, y\\}$. Intersection with $\\{\\,x, z\\,\\}$ is $\\{z\\}$. This expression is killed.\n7.  $a\\times y$: $\\mathrm{vars}(a\\times y) = \\{a, y\\}$. Intersection with $\\{\\,x, z\\,\\}$ is $\\emptyset$. This expression is not killed.\n8.  $b+a$: $\\mathrm{vars}(b+a) = \\{b, a\\}$. Intersection with $\\{\\,x, z\\,\\}$ is $\\emptyset$. This expression is not killed.\n9.  $x+a$: $\\mathrm{vars}(x+a) = \\{x, a\\}$. Intersection with $\\{\\,x, z\\,\\}$ is $\\{x\\}$. This expression is killed.\n\nBased on this analysis, the `KILL` set for statement $10$ is:\n$$\n\\mathrm{KILL}_{10} = \\{\\, x\\times y,\\; x+y,\\; z+a,\\; z\\times y,\\; x+a \\,\\}\n$$\nThe problem asks for the cardinality of this set. By counting the elements, we find:\n$$\n|\\mathrm{KILL}_{10}| = 5\n$$",
            "answer": "$$\n\\boxed{5}\n$$"
        }
    ]
}