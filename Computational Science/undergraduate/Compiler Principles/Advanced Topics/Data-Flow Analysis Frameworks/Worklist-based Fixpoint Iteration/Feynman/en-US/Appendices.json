{
    "hands_on_practices": [
        {
            "introduction": "Constant propagation is a fundamental optimization that replaces variables with their known constant values. This exercise provides a hands-on opportunity to simulate a worklist-based constant propagation analysis on a program in Static Single Assignment (SSA) form. By manually tracing the algorithm, you will gain a concrete understanding of how dataflow values on a lattice evolve and converge to a fixpoint, and how the worklist efficiently manages dependencies between SSA definitions. ",
            "id": "3683107",
            "problem": "Consider forward constant propagation formulated as a monotone dataflow analysis over a three-level lattice for each Static Single Assignment (SSA) name. The lattice for each SSA value $V$ is $L = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$ with partial order $\\bot \\leq n \\leq \\top$ for any integer $n \\in \\mathbb{Z}$, and distinct integers are incomparable except through $\\top$. The join operator $\\sqcup$ satisfies: for any $x \\in L$, $x \\sqcup \\bot = x$; for any integers $m, n \\in \\mathbb{Z}$, $m \\sqcup n = m$ if $m = n$ and $m \\sqcup n = \\top$ if $m \\neq n$; and for any $x \\in L$, $x \\sqcup \\top = \\top$. Transfer functions are monotone with respect to this lattice and defined as follows:\n- For a constant definition $v := \\text{Const}(k)$ with $k \\in \\mathbb{Z}$, the transfer yields $k$.\n- For an addition $v := \\text{add}(u, w)$, the transfer yields $Val[u] + Val[w]$ if both $Val[u]$ and $Val[w]$ are integers; yields $\\bot$ if $Val[u] = \\bot$ or $Val[w] = \\bot$; and yields $\\top$ otherwise.\n- For a phi-node $v := \\phi(u, w)$, the transfer yields $Val[u] \\sqcup Val[w]$.\n\nA standard First-In, First-Out (FIFO) worklist algorithm is used. Initially, for every SSA name $v$, $Val[v] = \\bot$. The worklist is initialized with the SSA definitions in the exact order given below. When an SSA name $n$ is dequeued, its right-hand side is evaluated using the current $Val[\\cdot]$ to produce a candidate value $new$. If $new \\neq Val[n]$, then set $Val[n] := new$ and enqueue all users of $n$ to the back of the worklist (duplicates are allowed). Users are enqueued in the order listed in the Users mapping below. The algorithm terminates when the worklist is empty.\n\nThe SSA fragment and its def-use relations are:\n- Definitions (each defines a unique SSA name):\n  1. $c := \\text{Const}(4)$\n  2. $d := \\text{Const}(9)$\n  3. $e := \\text{add}(c, c)$\n  4. $y := \\phi(c, c)$\n  5. $b := \\phi(e, d)$\n  6. $a := \\phi(c, b)$\n  7. $x := \\phi(y, d)$\n  8. $f := \\text{add}(x, a)$\n- Users mapping (for each SSA name, the list of users to be enqueued upon its update, in this exact order):\n  - $c$: users $e, y, a$\n  - $d$: users $b, x$\n  - $e$: users $b$\n  - $y$: users $x$\n  - $b$: users $a$\n  - $a$: users $f$\n  - $x$: users $f$\n  - $f$: no users\n- Initial worklist order (front to back): $[x, a, b, y, e, f, c, d]$.\n\nStarting from $Val[\\cdot] = \\bot$ for all SSA names, run the FIFO worklist-based fixpoint iteration with the transfer functions above. Compute the total number of dequeues (worklist pop operations) executed until the algorithm reaches a fixpoint and the worklist becomes empty. Give your answer as a single integer with no units. No rounding is required.",
            "solution": "The problem is first validated against the required criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Lattice:** For each SSA name $v$, the lattice is $L = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$.\n- **Partial Order:** $\\bot \\leq n \\leq \\top$ for any integer $n \\in \\mathbb{Z}$. Distinct integers are incomparable.\n- **Join Operator ($\\sqcup$):**\n    - For any $x \\in L$, $x \\sqcup \\bot = x$.\n    - For any integers $m, n \\in \\mathbb{Z}$, $m \\sqcup n = m$ if $m=n$, and $m \\sqcup n = \\top$ if $m \\neq n$.\n    - For any $x \\in L$, $x \\sqcup \\top = \\top$.\n- **Transfer Functions:**\n    - For $v := \\text{Const}(k)$ with $k \\in \\mathbb{Z}$, the transfer function yields $k$.\n    - For $v := \\text{add}(u, w)$, the transfer function yields:\n        - $Val[u] + Val[w]$ if both $Val[u]$ and $Val[w]$ are integers.\n        - $\\bot$ if $Val[u] = \\bot$ or $Val[w] = \\bot$.\n        - $\\top$ otherwise.\n    - For $v := \\phi(u, w)$, the transfer function yields $Val[u] \\sqcup Val[w]$.\n- **Algorithm:** First-In, First-Out (FIFO) worklist algorithm.\n- **Initial State:**\n    - For every SSA name $v$, $Val[v] = \\bot$.\n    - The initial worklist is $[x, a, b, y, e, f, c, d]$, ordered from front to back.\n- **Update Rule:** When an SSA name $n$ is dequeued, its right-hand side is evaluated to get a value $new$. If $new \\neq Val[n]$, then $Val[n]$ is updated to $new$ and all users of $n$ are enqueued to the back of the worklist according to the specified order.\n- **SSA Definitions:**\n    1. $c := \\text{Const}(4)$\n    2. $d := \\text{Const}(9)$\n    3. $e := \\text{add}(c, c)$\n    4. $y := \\phi(c, c)$\n    5. $b := \\phi(e, d)$\n    6. $a := \\phi(c, b)$\n    7. $x := \\phi(y, d)$\n    8. $f := \\text{add}(x, a)$\n- **Users Mapping (Def-Use Chains):**\n    - $c$: users $e, y, a$\n    - $d$: users $b, x$\n    - $e$: users $b$\n    - $y$: users $x$\n    - $b$: users $a$\n    - $a$: users $f$\n    - $x$: users $f$\n    - $f$: no users\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded:** The problem is a standard exercise in dataflow analysis, a fundamental topic in compiler design and program analysis. The concepts of SSA, lattices, monotone frameworks, and worklist algorithms are well-established in computer science.\n- **Well-Posed:** The problem provides a deterministic algorithm, a complete set of initial conditions, and unambiguous rules for state transition. The lattice has a finite height ($3$ levels), and the values in the state can only move up the lattice. This guarantees that the algorithm will terminate and produce a unique result.\n- **Objective:** The problem is stated using formal and precise language. All definitions, rules, and data are given explicitly, leaving no room for subjective interpretation.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. A detailed solution will be provided by simulating the specified worklist algorithm.\n\n### Solution\n\nWe trace the execution of the FIFO worklist algorithm. Let $W$ be the worklist and $D$ be the dequeue count. The state is maintained in the map $Val[\\cdot]$. Initially, $Val[v] = \\bot$ for all SSA names $v \\in \\{a, b, c, d, e, f, x, y\\}$, $D=0$, and $W = [x, a, b, y, e, f, c, d]$.\n\n1.  Dequeue $x$. $D=1$. For $x := \\phi(y, d)$, we evaluate $Val[y] \\sqcup Val[d] = \\bot \\sqcup \\bot = \\bot$. This equals the current $Val[x] = \\bot$. No update. $W = [a, b, y, e, f, c, d]$.\n2.  Dequeue $a$. $D=2$. For $a := \\phi(c, b)$, we evaluate $Val[c] \\sqcup Val[b] = \\bot \\sqcup \\bot = \\bot$. This equals the current $Val[a] = \\bot$. No update. $W = [b, y, e, f, c, d]$.\n3.  Dequeue $b$. $D=3$. For $b := \\phi(e, d)$, we evaluate $Val[e] \\sqcup Val[d] = \\bot \\sqcup \\bot = \\bot$. This equals the current $Val[b] = \\bot$. No update. $W = [y, e, f, c, d]$.\n4.  Dequeue $y$. $D=4$. For $y := \\phi(c, c)$, we evaluate $Val[c] \\sqcup Val[c] = \\bot \\sqcup \\bot = \\bot$. This equals the current $Val[y] = \\bot$. No update. $W = [e, f, c, d]$.\n5.  Dequeue $e$. $D=5$. For $e := \\text{add}(c, c)$, since $Val[c]=\\bot$, the transfer function yields $\\bot$. This equals the current $Val[e] = \\bot$. No update. $W = [f, c, d]$.\n6.  Dequeue $f$. $D=6$. For $f := \\text{add}(x, a)$, since $Val[x]=\\bot$, the transfer function yields $\\bot$. This equals the current $Val[f] = \\bot$. No update. $W = [c, d]$.\n7.  Dequeue $c$. $D=7$. For $c := \\text{Const}(4)$, the new value is $4$. This is different from $Val[c] = \\bot$. Update $Val[c] := 4$. Enqueue users of $c$: $e, y, a$. $W = [d, e, y, a]$.\n8.  Dequeue $d$. $D=8$. For $d := \\text{Const}(9)$, the new value is $9$. This is different from $Val[d] = \\bot$. Update $Val[d] := 9$. Enqueue users of $d$: $b, x$. $W = [e, y, a, b, x]$.\n9.  Dequeue $e$. $D=9$. For $e := \\text{add}(c, c)$, we evaluate $Val[c] + Val[c] = 4 + 4 = 8$. This is different from $Val[e] = \\bot$. Update $Val[e] := 8$. Enqueue users of $e$: $b$. $W = [y, a, b, x, b]$.\n10. Dequeue $y$. $D=10$. For $y := \\phi(c, c)$, we evaluate $Val[c] \\sqcup Val[c] = 4 \\sqcup 4 = 4$. This is different from $Val[y] = \\bot$. Update $Val[y] := 4$. Enqueue users of $y$: $x$. $W = [a, b, x, b, x]$.\n11. Dequeue $a$. $D=11$. For $a := \\phi(c, b)$, we evaluate $Val[c] \\sqcup Val[b] = 4 \\sqcup \\bot = 4$. This is different from $Val[a] = \\bot$. Update $Val[a] := 4$. Enqueue users of $a$: $f$. $W = [b, x, b, x, f]$.\n12. Dequeue $b$. $D=12$. For $b := \\phi(e, d)$, we evaluate $Val[e] \\sqcup Val[d] = 8 \\sqcup 9 = \\top$. This is different from $Val[b] = \\bot$. Update $Val[b] := \\top$. Enqueue users of $b$: $a$. $W = [x, b, x, f, a]$.\n13. Dequeue $x$. $D=13$. For $x := \\phi(y, d)$, we evaluate $Val[y] \\sqcup Val[d] = 4 \\sqcup 9 = \\top$. This is different from $Val[x] = \\bot$. Update $Val[x] := \\top$. Enqueue users of $x$: $f$. $W = [b, x, f, a, f]$.\n14. Dequeue $b$. $D=14$. For $b := \\phi(e, d)$, we evaluate $Val[e] \\sqcup Val[d] = 8 \\sqcup 9 = \\top$. This equals the current $Val[b] = \\top$. No update. $W = [x, f, a, f]$.\n15. Dequeue $x$. $D=15$. For $x := \\phi(y, d)$, we evaluate $Val[y] \\sqcup Val[d] = 4 \\sqcup 9 = \\top$. This equals the current $Val[x] = \\top$. No update. $W = [f, a, f]$.\n16. Dequeue $f$. $D=16$. For $f := \\text{add}(x, a)$, current values are $Val[x]=\\top$ and $Val[a]=4$. Since $Val[x]$ is not an integer, the transfer function yields $\\top$. This is different from $Val[f] = \\bot$. Update $Val[f] := \\top$. There are no users of $f$ to enqueue. $W = [a, f]$.\n17. Dequeue $a$. $D=17$. For $a := \\phi(c, b)$, we evaluate $Val[c] \\sqcup Val[b] = 4 \\sqcup \\top = \\top$. This is different from $Val[a] = 4$. Update $Val[a] := \\top$. Enqueue users of $a$: $f$. $W = [f, f]$.\n18. Dequeue $f$. $D=18$. For $f := \\text{add}(x, a)$, current values are $Val[x]=\\top$ and $Val[a]=\\top$. Since one or both inputs are not integers, the transfer function yields $\\top$. This equals the current $Val[f] = \\top$. No update. $W = [f]$.\n19. Dequeue $f$. $D=19$. For $f := \\text{add}(x, a)$, current values are $Val[x]=\\top$ and $Val[a]=\\top$. The transfer function yields $\\top$. This equals the current $Val[f] = \\top$. No update. $W = []$.\n\nThe worklist is now empty. The algorithm terminates. The total number of dequeues is $19$.\nThe final state is:\n$Val[a] = \\top$\n$Val[b] = \\top$\n$Val[c] = 4$\n$Val[d] = 9$\n$Val[e] = 8$\n$Val[f] = \\top$\n$Val[x] = \\top$\n$Val[y] = 4$\n\nThe question asks for the total number of dequeues performed. Based on the trace, this number is $19$.",
            "answer": "$$\n\\boxed{19}\n$$"
        },
        {
            "introduction": "The power of worklist-based fixpoint iteration extends beyond traditional dataflow analysis. This practice demonstrates its versatility by applying it to a core problem in automata theory: computing the $\\epsilon$-closure of a set of states in a Non-deterministic Finite Automaton (NFA). Viewing this as a graph reachability problem, you will use a worklist to find all states reachable through $\\epsilon$-transitions, reinforcing the general nature of the fixpoint algorithm as a tool for exploring state spaces until closure is reached. ",
            "id": "3683091",
            "problem": "A compiler front end models a lexical recognizer as a non-deterministic finite automaton (NFA) embedded in the compilerâ€™s Intermediate Representation (IR). The IR nodes are basic blocks that correspond to NFA states. Among the control-flow edges, some are special $\\epsilon$-transitions that do not consume input. The $\\epsilon$-closure of a set of states is defined as the least set of states that contains the set and is closed under reachability by zero or more $\\epsilon$-transitions. You will compute the size of an $\\epsilon$-closure by viewing the problem as a monotone dataflow analysis on a finite lattice and using a worklist-based fixpoint iteration.\n\nLet the set of states be $Q=\\{q_0,q_1,q_2,q_3,q_4,q_5,q_6,q_7,q_8,q_9,q_{10},q_{11}\\}$. The $\\epsilon$-transitions (and only these transitions) are:\n- $q_0 \\to q_1$, $q_0 \\to q_2$.\n- $q_1 \\to q_3$.\n- $q_2 \\to q_3$, $q_2 \\to q_4$.\n- $q_3 \\to q_5$.\n- $q_4 \\to q_2$, $q_4 \\to q_6$.\n- $q_5 \\to q_7$.\n- $q_6 \\to q_7$.\n- $q_7 \\to q_8$, $q_7 \\to q_9$.\n- $q_8 \\to q_{10}$.\n- $q_9 \\to q_{10}$, $q_9 \\to q_{11}$.\n- $q_{10}$ has no outgoing $\\epsilon$-transitions.\n- $q_{11} \\to q_6$.\n\nIn addition, there exist several non-$\\epsilon$ symbol-labeled transitions (for example, $q_1 \\xrightarrow{a} q_2$, $q_2 \\xrightarrow{b} q_9$, $q_6 \\xrightarrow{c} q_3$, $q_7 \\xrightarrow{d} q_0$, $q_{10} \\xrightarrow{e} q_4$), but these do not participate in the $\\epsilon$-closure and must be ignored for the computation below.\n\nDefine the initial set of states as $S_0=\\{q_0,q_4,q_9\\}$. Consider the powerset lattice $\\langle 2^{Q}, \\subseteq \\rangle$ with set union as the least upper bound. Model $\\epsilon$-closure computation as the least fixpoint of a monotone function over this lattice, and implement the computation conceptually via a worklist: begin with the worklist containing exactly the elements of $S_0$, maintain a visited set initialized to $S_0$, repeatedly pop a state from the worklist, and for each outgoing $\\epsilon$-successor not yet in the visited set, add it to the visited set and push it onto the worklist; terminate when the worklist becomes empty. The visited set at termination is the $\\epsilon$-closure of $S_0$.\n\nUsing this formulation and only the $\\epsilon$-transitions listed above, what is the exact cardinality of the $\\epsilon$-closure of $S_0$? Express your final answer as an integer. No rounding is required or permitted, and no physical units are involved.",
            "solution": "The problem asks for the cardinality of the $\\epsilon$-closure of an initial set of states $S_0$ within a given non-deterministic finite automaton (NFA). The computation is to be performed using a worklist-based fixpoint iteration algorithm, as described.\n\nFirst, we establish the formal components of the problem.\nThe set of all states is $Q=\\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$. The total number of states is $|Q| = 12$.\nThe initial set of states for which the closure is to be computed is $S_0 = \\{q_0, q_4, q_9\\}$.\nThe $\\epsilon$-transitions define a directed graph $G=(Q, E)$, where an edge $(u, v) \\in E$ exists if there is an $\\epsilon$-transition from state $u$ to state $v$. The set of edges $E$ is given by:\n$E = \\{$\n$(q_0, q_1), (q_0, q_2),$\n$(q_1, q_3),$\n$(q_2, q_3), (q_2, q_4),$\n$(q_3, q_5),$\n$(q_4, q_2), (q_4, q_6),$\n$(q_5, q_7),$\n$(q_6, q_7),$\n$(q_7, q_8), (q_7, q_9),$\n$(q_8, q_{10}),$\n$(q_9, q_{10}), (q_9, q_{11}),$\n$(q_{11}, q_6)$\n$\\}$\nThe non-$\\epsilon$ transitions are explicitly stated to be ignored for this computation.\n\nThe $\\epsilon$-closure of $S_0$, denoted $\\epsilon\\text{-closure}(S_0)$, is the set of all states reachable from any state in $S_0$ by following zero or more $\\epsilon$-transitions. The problem specifies a worklist algorithm to compute this set. Let $V$ be the set of visited states (which will become the closure set) and $W$ be the worklist.\n\nThe algorithm proceeds as follows:\n1. Initialize the visited set $V$ and the worklist $W$ with the initial set of states $S_0$.\n2. While the worklist $W$ is not empty:\n   a. Remove a state $u$ from $W$.\n   b. For each state $v$ such that there is an $\\epsilon$-transition from $u$ to $v$:\n      i. If $v$ is not in $V$:\n         - Add $v$ to $V$.\n         - Add $v$ to $W$.\n3. The final set $V$ is the $\\epsilon$-closure of $S_0$.\n\nWe now trace the execution of this algorithm. The order of processing elements from the worklist does not affect the final result, only the sequence of intermediate steps. We will treat the worklist as a queue (First-In, First-Out) for a systematic traversal.\n\n**Initialization:**\n- Visited set: $V = \\{q_0, q_4, q_9\\}$\n- Worklist: $W = [q_0, q_4, q_9]$\n\n**Iteration 1:** Pop $q_0$ from $W$.\n- Successors of $q_0$ are $q_1$ and $q_2$.\n- $q_1 \\notin V$. Add $q_1$ to $V$ and $W$.\n- $q_2 \\notin V$. Add $q_2$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_4, q_9\\}$\n- $W = [q_4, q_9, q_1, q_2]$\n\n**Iteration 2:** Pop $q_4$ from $W$.\n- Successors of $q_4$ are $q_2$ and $q_6$.\n- $q_2 \\in V$. No action.\n- $q_6 \\notin V$. Add $q_6$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_4, q_6, q_9\\}$\n- $W = [q_9, q_1, q_2, q_6]$\n\n**Iteration 3:** Pop $q_9$ from $W$.\n- Successors of $q_9$ are $q_{10}$ and $q_{11}$.\n- $q_{10} \\notin V$. Add $q_{10}$ to $V$ and $W$.\n- $q_{11} \\notin V$. Add $q_{11}$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_4, q_6, q_9, q_{10}, q_{11}\\}$\n- $W = [q_1, q_2, q_6, q_{10}, q_{11}]$\n\n**Iteration 4:** Pop $q_1$ from $W$.\n- Successor of $q_1$ is $q_3$.\n- $q_3 \\notin V$. Add $q_3$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_6, q_9, q_{10}, q_{11}\\}$\n- $W = [q_2, q_6, q_{10}, q_{11}, q_3]$\n\n**Iteration 5:** Pop $q_2$ from $W$.\n- Successors of $q_2$ are $q_3$ and $q_4$.\n- $q_3 \\in V$. No action.\n- $q_4 \\in V$. No action.\n- $W = [q_6, q_{10}, q_{11}, q_3]$\n\n**Iteration 6:** Pop $q_6$ from $W$.\n- Successor of $q_6$ is $q_7$.\n- $q_7 \\notin V$. Add $q_7$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_6, q_7, q_9, q_{10}, q_{11}\\}$\n- $W = [q_{10}, q_{11}, q_3, q_7]$\n\n**Iteration 7:** Pop $q_{10}$ from $W$.\n- $q_{10}$ has no outgoing $\\epsilon$-transitions.\n- $W = [q_{11}, q_3, q_7]$\n\n**Iteration 8:** Pop $q_{11}$ from $W$.\n- Successor of $q_{11}$ is $q_6$.\n- $q_6 \\in V$. No action.\n- $W = [q_3, q_7]$\n\n**Iteration 9:** Pop $q_3$ from $W$.\n- Successor of $q_3$ is $q_5$.\n- $q_5 \\notin V$. Add $q_5$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_9, q_{10}, q_{11}\\}$\n- $W = [q_7, q_5]$\n\n**Iteration 10:** Pop $q_7$ from $W$.\n- Successors of $q_7$ are $q_8$ and $q_9$.\n- $q_8 \\notin V$. Add $q_8$ to $V$ and $W$.\n- $q_9 \\in V$. No action.\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$\n- $W = [q_5, q_8]$\n\nAt this point, the visited set $V$ contains all $12$ states from $q_0$ to $q_{11}$. The algorithm continues until the worklist is empty, but no new states can be added to $V$.\n\n**Iteration 11:** Pop $q_5$ from $W$.\n- Successor of $q_5$ is $q_7$.\n- $q_7 \\in V$. No action.\n- $W = [q_8]$\n\n**Iteration 12:** Pop $q_8$ from $W$.\n- Successor of $q_8$ is $q_{10}$.\n- $q_{10} \\in V$. No action.\n- $W = []$\n\n**Termination:**\nThe worklist $W$ is now empty. The algorithm terminates. The final visited set is the $\\epsilon$-closure of $S_0$.\n$\\epsilon\\text{-closure}(S_0) = V_{final} = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$.\nThis is the complete set of states $Q$.\n\nThe problem asks for the cardinality of this set.\n$|\\epsilon\\text{-closure}(S_0)| = |Q| = 12$.\n\nAlternatively, we can reason about reachability more directly. The $\\epsilon$-closure of $S_0$ is the union of the closures of its individual elements: $\\epsilon\\text{-closure}(S_0) = \\bigcup_{s \\in S_0} \\epsilon\\text{-closure}(\\{s\\})$. We only need to find one element in $S_0$ from which all states are reachable.\nLet's analyze reachability from $q_0 \\in S_0$:\n- $q_0 \\to \\{q_1, q_2\\}$\n- from $\\{q_1, q_2\\} \\to \\{q_3, q_4\\}$\n- from $\\{q_3, q_4\\} \\to \\{q_5, q_2, q_6\\}$\n- from $\\{q_5, q_6\\} \\to \\{q_7\\}$\n- from $\\{q_7\\} \\to \\{q_8, q_9\\}$\n- from $\\{q_8, q_9\\} \\to \\{q_{10}, q_{11}\\}$\n- from $\\{q_{11}\\} \\to \\{q_6\\}$\nThrough these paths, it is evident that all states $q_1, \\dots, q_{11}$ are reachable from $q_0$. Since the closure of $\\{q_0\\}$ by definition includes $q_0$ itself, $\\epsilon\\text{-closure}(\\{q_0\\}) = Q$.\nBecause $\\epsilon\\text{-closure}(S_0) = \\epsilon\\text{-closure}(\\{q_0\\}) \\cup \\epsilon\\text{-closure}(\\{q_4\\}) \\cup \\epsilon\\text{-closure}(\\{q_9\\})$, and $\\epsilon\\text{-closure}(\\{q_0\\}) = Q$, the resulting union must also be $Q$.\nThus, the cardinality of the $\\epsilon$-closure of $S_0$ is the cardinality of $Q$, which is $12$.",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "Real-world programs often contain complex control flow, such as exceptions, which dataflow analyses must model correctly. This advanced problem challenges you to apply a worklist algorithm to a Control Flow Graph with both normal and exceptional edges, where the dataflow propagation rules differ for each type of edge. By carefully tracking the flow of information, you will see how the worklist framework can be adapted to handle sophisticated, non-uniform propagation logic, a key skill in designing robust program analyzers. ",
            "id": "3683032",
            "problem": "Consider a forward, may dataflow analysis formulated as a monotone framework over the powerset lattice of facts. Let the finite domain of facts be $D = \\{a, b, c\\}$, equipped with the subset order $\\subseteq$ and the least upper bound (join) operator given by set union $\\cup$. For each node $x$ in a control-flow graph, let the transfer function be $f_x : 2^D \\to 2^D$, and assume all transfer functions are monotone. The dataflow equations are:\n$$IN[x] = \\bigcup_{p \\in \\mathrm{pred}(x)} FLOW_{p \\to x},$$\n$$OUT[x] = f_x(IN[x]),$$\nwhere $FLOW_{p \\to x}$ is the value propagated along the edge from predecessor $p$ to $x$.\n\nModel exceptional control flow by assigning each node $n$ that may throw an exception both a normal successor and an exceptional successor. For a normal edge $n \\to s$, define $FLOW_{n \\to s} = OUT[n]$. For an exceptional edge $n \\to e$, define an edge-specific transfer $g_n : 2^D \\to 2^D$ and set $FLOW_{n \\to e} = g_n(IN[n])$. Intuitively, $g_n$ models that exceptions transfer control before $n$ completes its normal effect.\n\nConsider the following control-flow graph:\n- Nodes: $\\mathrm{entry}, n_1, n_2, n_3, e$.\n- Normal edges: $\\mathrm{entry} \\to n_1$, $n_1 \\to n_2$, $n_2 \\to n_3$, $n_3 \\to n_1$.\n- Exceptional edges: $n_1 \\to e$, $n_2 \\to e$.\n- The exception handler $e$ has a normal edge $e \\to n_3$.\n\nLet the transfer functions be:\n- $f_{\\mathrm{entry}}(X) = X$,\n- $f_{n_1}(X) = X \\cup \\{a\\}$,\n- $f_{n_2}(X) = X \\cup \\{b\\}$,\n- $f_{n_3}(X) = X \\cup \\{c\\}$,\n- $f_e(X) = X$,\nand the exceptional edge transfers:\n- $g_{n_1}(X) = X \\cap \\{a\\}$,\n- $g_{n_2}(X) = X \\cap \\{a, b\\}$.\n\nUse a standard worklist-based fixpoint iteration with a First-In-First-Out (FIFO) worklist. Initialize $IN[x] = \\varnothing$ and $OUT[x] = \\varnothing$ for all nodes $x$. Initialize the worklist in the order $[\\mathrm{entry}, n_1, n_2, n_3, e]$. When a node $x$ is dequeued, recompute $OUT[x] := f_x(IN[x])$. If $OUT[x]$ increases, then for each normal successor $s$ update $IN[s] := IN[s] \\cup OUT[x]$ and enqueue $s$ if $IN[s]$ increases. Additionally, after processing $x$, propagate along exceptional edges from $x$: for each exceptional successor $e$, update $IN[e] := IN[e] \\cup g_x(IN[x])$ and enqueue $e$ if $IN[e]$ increases.\n\nDefine stabilization of $OUT[e]$ as the point in the iteration after which $OUT[e]$ no longer changes for the remainder of the run. Under the setup above, determine the total number of worklist dequeues performed up to and including the dequeue on which $OUT[e]$ attains its final fixpoint value. Express your answer as an integer. No rounding is required.",
            "solution": "The problem statement is first validated against the specified criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Domain:** A finite set of facts $D = \\{a, b, c\\}$.\n- **Lattice:** The powerset lattice $(2^D, \\subseteq)$, with join operator $\\cup$.\n- **Analysis Type:** Forward, may-analysis.\n- **Dataflow Equations:**\n    - $IN[x] = \\bigcup_{p \\in \\mathrm{pred}(x)} FLOW_{p \\to x}$\n    - $OUT[x] = f_x(IN[x])$\n- **Flow on Edges:**\n    - Normal edge $n \\to s$: $FLOW_{n \\to s} = OUT[n]$\n    - Exceptional edge $n \\to e$: $FLOW_{n \\to e} = g_n(IN[n])$\n- **Control-Flow Graph:**\n    - Nodes: $\\{\\mathrm{entry}, n_1, n_2, n_3, e\\}$\n    - Normal edges: $\\mathrm{entry} \\to n_1$, $n_1 \\to n_2$, $n_2 \\to n_3$, $n_3 \\to n_1$, $e \\to n_3$\n    - Exceptional edges: $n_1 \\to e$, $n_2 \\to e$\n- **Transfer Functions ($f_x$):**\n    - $f_{\\mathrm{entry}}(X) = X$\n    - $f_{n_1}(X) = X \\cup \\{a\\}$\n    - $f_{n_2}(X) = X \\cup \\{b\\}$\n    - $f_{n_3}(X) = X \\cup \\{c\\}$\n    - $f_e(X) = X$\n- **Exceptional Edge Transfers ($g_x$):**\n    - $g_{n_1}(X) = X \\cap \\{a\\}$\n    - $g_{n_2}(X) = X \\cap \\{a, b\\}$\n- **Algorithm:** Worklist-based fixpoint iteration using a FIFO queue.\n- **Initialization:**\n    - For all nodes $x$, $IN[x] = \\emptyset$ and $OUT[x] = \\emptyset$.\n    - Worklist $W = [\\mathrm{entry}, n_1, n_2, n_3, e]$.\n- **Algorithm Logic:** When a node $x$ is dequeued, $OUT[x]$ is recomputed. If $OUT[x]$ increases, the change is propagated to its normal successors. After processing $x$, flow is propagated to exceptional successors based on $g_x(IN[x])$. A successor is enqueued if its $IN$ set increases.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded within the field of compiler principles and dataflow analysis. It is well-posed, as the use of a finite lattice and monotone transfer functions guarantees the existence of a least fixpoint and the termination of the worklist algorithm. The problem statement is objective, complete, and internally consistent, providing all necessary definitions, initial conditions, and the specific algorithm to be used. The algorithm's rules, while featuring a specific handling for exceptional flow, are explicitly defined and unambiguous. The problem is a concrete instance of a standard computer science problem, not trivial, and its solution is mathematically verifiable.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A step-by-step solution will be provided by tracing the execution of the specified worklist algorithm.\n\n### Solution\n\nWe trace the state of the analysis, which consists of the $IN$ and $OUT$ sets for each node and the worklist $W$. A standard worklist algorithm treats the worklist as a set of nodes requiring processing, so a node is not added if it is already on the worklist. We will follow this convention. The worklist $W$ is a FIFO queue.\n\n**Initial State:**\n- $IN[x] = \\emptyset$ for all $x \\in \\{\\mathrm{entry}, n_1, n_2, n_3, e\\}$.\n- $OUT[x] = \\emptyset$ for all $x \\in \\{\\mathrm{entry}, n_1, n_2, n_3, e\\}$.\n- $W = [\\mathrm{entry}, n_1, n_2, n_3, e]$.\n- Dequeue count = $0$.\n\n**Iteration 1:**\n- **Dequeue:** $\\mathrm{entry}$. $W = [n_1, n_2, n_3, e]$. **Dequeue Count = 1**.\n- $IN[\\mathrm{entry}] = \\emptyset$. $new\\_OUT[\\mathrm{entry}] = f_{\\mathrm{entry}}(\\emptyset) = \\emptyset$.\n- $OUT[\\mathrm{entry}]$ does not change.\n- No propagation occurs.\n\n**Iteration 2:**\n- **Dequeue:** $n_1$. $W = [n_2, n_3, e]$. **Dequeue Count = 2**.\n- $IN[n_1] = \\emptyset$. $new\\_OUT[n_1] = f_{n_1}(\\emptyset) = \\{a\\}$.\n- $OUT[n_1]$ changes from $\\emptyset$ to $\\{a\\}$.\n- Normal propagation to $n_2$: $IN[n_2]$ changes from $\\emptyset$ to $\\emptyset \\cup \\{a\\} = \\{a\\}$. Since $n_2$ is already in $W$, it is not added again.\n- Exceptional propagation to $e$: $exn\\_flow = g_{n_1}(IN[n_1]) = g_{n_1}(\\emptyset) = \\emptyset$. $IN[e]$ does not change.\n\n**Iteration 3:**\n- **Dequeue:** $n_2$. $W = [n_3, e]$. **Dequeue Count = 3**.\n- $IN[n_2] = \\{a\\}$. $new\\_OUT[n_2] = f_{n_2}(\\{a\\}) = \\{a\\} \\cup \\{b\\} = \\{a, b\\}$.\n- $OUT[n_2]$ changes from $\\emptyset$ to $\\{a, b\\}$.\n- Normal propagation to $n_3$: $IN[n_3]$ changes from $\\emptyset$ to $\\emptyset \\cup \\{a, b\\} = \\{a, b\\}$. $n_3$ is already in $W$.\n- Exceptional propagation to $e$: $exn\\_flow = g_{n_2}(IN[n_2]) = g_{n_2}(\\{a\\}) = \\{a\\} \\cap \\{a, b\\} = \\{a\\}$. $IN[e]$ changes from $\\emptyset$ to $\\emptyset \\cup \\{a\\} = \\{a\\}$. $e$ is already in $W$.\n\n**Iteration 4:**\n- **Dequeue:** $n_3$. $W = [e]$. **Dequeue Count = 4**.\n- $IN[n_3] = \\{a, b\\}$. $new\\_OUT[n_3] = f_{n_3}(\\{a, b\\}) = \\{a, b\\} \\cup \\{c\\} = \\{a, b, c\\}$.\n- $OUT[n_3]$ changes from $\\emptyset$ to $\\{a, b, c\\}$.\n- Normal propagation to $n_1$: $IN[n_1]$ changes from $\\emptyset$ to $\\emptyset \\cup \\{a, b, c\\} = \\{a, b, c\\}$. $n_1$ is not in $W$, so it is enqueued. $W = [e, n_1]$.\n- Node $n_3$ has no exceptional successors.\n\n**Iteration 5:**\n- **Dequeue:** $e$. $W = [n_1]$. **Dequeue Count = 5**.\n- $IN[e] = \\{a\\}$. $new\\_OUT[e] = f_e(\\{a\\}) = \\{a\\}$.\n- $OUT[e]$ changes from $\\emptyset$ to $\\{a\\}$.\n- Normal propagation to $n_3$: $IN[n_3]$ is $\\{a, b\\}$. It becomes $\\{a, b\\} \\cup \\{a\\} = \\{a, b\\}$. No change.\n- Node $e$ has no exceptional successors.\n\n**Iteration 6:**\n- **Dequeue:** $n_1$. $W = []$. **Dequeue Count = 6**.\n- $IN[n_1] = \\{a, b, c\\}$. $new\\_OUT[n_1] = f_{n_1}(\\{a, b, c\\}) = \\{a, b, c\\} \\cup \\{a\\} = \\{a, b, c\\}$.\n- $OUT[n_1]$ changes from $\\{a\\}$ to $\\{a, b, c\\}$.\n- Normal propagation to $n_2$: $IN[n_2]$ changes from $\\{a\\}$ to $\\{a\\} \\cup \\{a, b, c\\} = \\{a, b, c\\}$. $n_2$ is not in $W$, so it is enqueued. $W = [n_2]$.\n- Exceptional propagation to $e$: $exn\\_flow = g_{n_1}(IN[n_1]) = g_{n_1}(\\{a, b, c\\}) = \\{a, b, c\\} \\cap \\{a\\} = \\{a\\}$. $IN[e]$ is $\\{a\\}$, so no change.\n\n**Iteration 7:**\n- **Dequeue:** $n_2$. $W = []$. **Dequeue Count = 7**.\n- $IN[n_2] = \\{a, b, c\\}$. $new\\_OUT[n_2] = f_{n_2}(\\{a, b, c\\}) = \\{a, b, c\\} \\cup \\{b\\} = \\{a, b, c\\}$.\n- $OUT[n_2]$ changes from $\\{a, b\\}$ to $\\{a, b, c\\}$.\n- Normal propagation to $n_3$: $IN[n_3]$ changes from $\\{a,b\\}$ to $\\{a,b\\} \\cup \\{a,b,c\\} = \\{a,b,c\\}$. $n_3$ is not in $W$, so it is enqueued. $W=[n_3]$.\n- Exceptional propagation to $e$: $exn\\_flow = g_{n_2}(IN[n_2]) = g_{n_2}(\\{a, b, c\\}) = \\{a, b, c\\} \\cap \\{a, b\\} = \\{a, b\\}$. $IN[e]$ changes from $\\{a\\}$ to $\\{a\\} \\cup \\{a, b\\} = \\{a, b\\}$. $e$ is not in $W$, so it is enqueued. $W = [n_3, e]$.\n\n**Iteration 8:**\n- **Dequeue:** $n_3$. $W = [e]$. **Dequeue Count = 8**.\n- $IN[n_3] = \\{a, b, c\\}$. $new\\_OUT[n_3] = f_{n_3}(\\{a, b, c\\}) = \\{a, b, c\\} \\cup \\{c\\} = \\{a, b, c\\}$.\n- $OUT[n_3]$ was already $\\{a, b, c\\}$. No change.\n- No propagation occurs.\n\n**Iteration 9:**\n- **Dequeue:** $e$. $W = []$. **Dequeue Count = 9**.\n- $IN[e] = \\{a, b\\}$. $new\\_OUT[e] = f_e(\\{a, b\\}) = \\{a, b\\}$.\n- $OUT[e]$ changes from $\\{a\\}$ to $\\{a, b\\}$.\n- Normal propagation to $n_3$: $IN[n_3]$ is $\\{a, b, c\\}$. It becomes $\\{a, b, c\\} \\cup \\{a, b\\} = \\{a, b, c\\}$. No change.\n- The worklist $W$ is now empty. The algorithm terminates.\n\nThe fixpoint value for $OUT[e]$ is $\\{a, b\\}$. This value is attained during the processing of node $e$ in iteration $9$. As the algorithm terminates immediately after this step, this is the final value. The question asks for the total number of dequeues up to and including this point.\n\nThe number of dequeues is $9$.",
            "answer": "$$\n\\boxed{9}\n$$"
        }
    ]
}