{
    "hands_on_practices": [
        {
            "introduction": "本练习将带你深入工作表不动点迭代算法的核心机制。我们将以一个经典的编译器优化——常量传播——为背景，在一个静态单赋值（SSA）形式的程序片段上，手动模拟整个分析过程。通过追踪每个变量的值如何在格（lattice）上从 $\\bot$ 演变至最终的稳定状态，你将对不动点迭代的收敛过程建立一个具体而直观的理解。",
            "id": "3683107",
            "problem": "考虑将前向常量传播形式化为对每个静态单赋值（SSA）名称的三级格上的单调数据流分析。对于每个 SSA 值 $V$，其格为 $L = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$，偏序关系为：对于任意整数 $n \\in \\mathbb{Z}$，有 $\\bot \\leq n \\leq \\top$，且不同的整数除了通过 $\\top$ 之外是不可比较的。连接运算符 $\\sqcup$ 满足：对于任意 $x \\in L$，有 $x \\sqcup \\bot = x$；对于任意整数 $m, n \\in \\mathbb{Z}$，如果 $m = n$，则 $m \\sqcup n = m$，如果 $m \\neq n$，则 $m \\sqcup n = \\top$；对于任意 $x \\in L$，有 $x \\sqcup \\top = \\top$。转移函数关于此格是单调的，定义如下：\n- 对于常量定义 $v := \\text{Const}(k)$，其中 $k \\in \\mathbb{Z}$，转移函数产生 $k$。\n- 对于加法 $v := \\text{add}(u, w)$，如果 $Val[u]$ 和 $Val[w]$ 都是整数，则转移函数产生 $Val[u] + Val[w]$；如果 $Val[u] = \\bot$ 或 $Val[w] = \\bot$，则产生 $\\bot$；否则产生 $\\top$。\n- 对于 phi-节点 $v := \\phi(u, w)$，转移函数产生 $Val[u] \\sqcup Val[w]$。\n\n使用标准的先进先出（FIFO）工作列表算法。初始时，对于每个 SSA 名称 $v$，$Val[v] = \\bot$。工作列表按下面给出的确切顺序用 SSA 定义进行初始化。当一个 SSA 名称 $n$ 从队列中取出时，使用当前的 $Val[\\cdot]$ 计算其右侧表达式，以产生一个候选值 $new$。如果 $new \\neq Val[n]$，则设置 $Val[n] := new$，并将 $n$ 的所有使用者（允许重复）按下面 Users 映射中列出的顺序加入到工作列表的末尾。当工作列表为空时，算法终止。\n\nSSA 片段及其定义-使用关系如下：\n- 定义（每个定义一个唯一的 SSA 名称）：\n  1. $c := \\text{Const}(4)$\n  2. $d := \\text{Const}(9)$\n  3. $e := \\text{add}(c, c)$\n  4. $y := \\phi(c, c)$\n  5. $b := \\phi(e, d)$\n  6. $a := \\phi(c, b)$\n  7. $x := \\phi(y, d)$\n  8. $f := \\text{add}(x, a)$\n- 使用者映射（对于每个 SSA 名称，在其更新时需要入队的使用者列表，按此确切顺序）：\n  - $c$：使用者 $e, y, a$\n  - $d$：使用者 $b, x$\n  - $e$：使用者 $b$\n  - $y$：使用者 $x$\n  - $b$：使用者 $a$\n  - $a$：使用者 $f$\n  - $x$：使用者 $f$\n  - $f$：没有使用者\n- 初始工作列表顺序（从前到后）：$[x, a, b, y, e, f, c, d]$。\n\n从所有 SSA 名称的 $Val[\\cdot] = \\bot$ 开始，使用上述转移函数运行基于 FIFO 工作列表的不动点迭代。计算算法达到不动点且工作列表变为空时所执行的出队（工作列表弹出操作）总数。请以单个整数形式给出答案，不带单位。无需四舍五入。",
            "solution": "首先根据所需标准对问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知信息**\n\n- **格：** 对于每个 SSA 名称 $v$，格为 $L = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$。\n- **偏序：** $\\bot \\leq n \\leq \\top$，对于任意整数 $n \\in \\mathbb{Z}$。不同的整数不可比较。\n- **连接运算符 ($\\sqcup$)：**\n    - 对于任意 $x \\in L$, $x \\sqcup \\bot = x$。\n    - 对于任意整数 $m, n \\in \\mathbb{Z}$，如果 $m=n$，则 $m \\sqcup n = m$；如果 $m \\neq n$，则 $m \\sqcup n = \\top$。\n    - 对于任意 $x \\in L$, $x \\sqcup \\top = \\top$。\n- **转移函数：**\n    - 对于 $v := \\text{Const}(k)$，其中 $k \\in \\mathbb{Z}$，转移函数产生 $k$。\n    - 对于 $v := \\text{add}(u, w)$，转移函数产生：\n        - $Val[u] + Val[w]$，如果 $Val[u]$ 和 $Val[w]$ 都是整数。\n        - $\\bot$，如果 $Val[u] = \\bot$ 或 $Val[w] = \\bot$。\n        - $\\top$，其他情况。\n    - 对于 $v := \\phi(u, w)$，转移函数产生 $Val[u] \\sqcup Val[w]$。\n- **算法：** 先进先出（FIFO）工作列表算法。\n- **初始状态：**\n    - 对于每个 SSA 名称 $v$, $Val[v] = \\bot$。\n    - 初始工作列表为 $[x, a, b, y, e, f, c, d]$，从前到后排序。\n- **更新规则：** 当一个 SSA 名称 $n$ 从队列中取出时，计算其右侧表达式得到一个值 $new$。如果 $new \\neq Val[n]$，则将 $Val[n]$ 更新为 $new$，并根据指定顺序将 $n$ 的所有使用者加入工作列表的末尾。\n- **SSA 定义：**\n    1. $c := \\text{Const}(4)$\n    2. $d := \\text{Const}(9)$\n    3. $e := \\text{add}(c, c)$\n    4. $y := \\phi(c, c)$\n    5. $b := \\phi(e, d)$\n    6. $a := \\phi(c, b)$\n    7. $x := \\phi(y, d)$\n    8. $f := \\text{add}(x, a)$\n- **使用者映射（定义-使用链）：**\n    - $c$：使用者 $e, y, a$\n    - $d$：使用者 $b, x$\n    - $e$：使用者 $b$\n    - $y$：使用者 $x$\n    - $b$：使用者 $a$\n    - $a$：使用者 $f$\n    - $x$：使用者 $f$\n    - $f$：没有使用者\n\n**步骤 2：使用提取的已知信息进行验证**\n\n- **科学依据：** 该问题是数据流分析中的一个标准练习，这是编译器设计和程序分析中的一个基本主题。SSA、格、单调框架和工作列表算法等概念在计算机科学中是公认的。\n- **适定性：** 该问题提供了一个确定性算法、一套完整的初始条件以及明确的状态转换规则。格具有有限的高度（3级），并且状态中的值只能在格中向上移动。这保证了算法将终止并产生唯一的结果。\n- **客观性：** 问题使用形式化和精确的语言陈述。所有定义、规则和数据都明确给出，没有主观解释的余地。\n\n**步骤 3：结论与行动**\n\n问题有效。将通过模拟指定的工作列表算法来提供详细的解决方案。\n\n### 解答\n\n我们追踪 FIFO 工作列表算法的执行过程。设 $W$ 为工作列表，$D$ 为出队计数。状态保存在映射 $Val[\\cdot]$ 中。初始时，对于所有 SSA 名称 $v \\in \\{a, b, c, d, e, f, x, y\\}$，$Val[v] = \\bot$，$D=0$，并且 $W = [x, a, b, y, e, f, c, d]$。\n\n1.  从队列中取出 $x$。$D=1$。$x := \\phi(y, d)$。我们计算 $Val[y] \\sqcup Val[d] = \\bot \\sqcup \\bot = \\bot$。这等于当前的 $Val[x] = \\bot$。无更新。$W = [a, b, y, e, f, c, d]$。\n2.  从队列中取出 $a$。$D=2$。$a := \\phi(c, b)$。我们计算 $Val[c] \\sqcup Val[b] = \\bot \\sqcup \\bot = \\bot$。这等于当前的 $Val[a] = \\bot$。无更新。$W = [b, y, e, f, c, d]$。\n3.  从队列中取出 $b$。$D=3$。$b := \\phi(e, d)$。我们计算 $Val[e] \\sqcup Val[d] = \\bot \\sqcup \\bot = \\bot$。这等于当前的 $Val[b] = \\bot$。无更新。$W = [y, e, f, c, d]$。\n4.  从队列中取出 $y$。$D=4$。$y := \\phi(c, c)$。我们计算 $Val[c] \\sqcup Val[c] = \\bot \\sqcup \\bot = \\bot$。这等于当前的 $Val[y] = \\bot$。无更新。$W = [e, f, c, d]$。\n5.  从队列中取出 $e$。$D=5$。$e := \\text{add}(c, c)$。由于 $Val[c]=\\bot$，转移函数产生 $\\bot$。这等于当前的 $Val[e] = \\bot$。无更新。$W = [f, c, d]$。\n6.  从队列中取出 $f$。$D=6$。$f := \\text{add}(x, a)$。由于 $Val[x]=\\bot$ (或 $Val[a]=\\bot$)，转移函数产生 $\\bot$。这等于当前的 $Val[f] = \\bot$。无更新。$W = [c, d]$。\n7.  从队列中取出 $c$。$D=7$。$c := \\text{Const}(4)$。新值为 $4$。这与 $Val[c] = \\bot$ 不同。更新 $Val[c] := 4$。将 $c$ 的使用者入队：$e, y, a$。$W = [d, e, y, a]$。\n8.  从队列中取出 $d$。$D=8$。$d := \\text{Const}(9)$。新值为 $9$。这与 $Val[d] = \\bot$ 不同。更新 $Val[d] := 9$。将 $d$ 的使用者入队：$b, x$。$W = [e, y, a, b, x]$。\n9.  从队列中取出 $e$。$D=9$。$e := \\text{add}(c, c)$。我们计算 $Val[c] + Val[c] = 4 + 4 = 8$。这与 $Val[e] = \\bot$ 不同。更新 $Val[e] := 8$。将 $e$ 的使用者入队：$b$。$W = [y, a, b, x, b]$。\n10. 从队列中取出 $y$。$D=10$。$y := \\phi(c, c)$。我们计算 $Val[c] \\sqcup Val[c] = 4 \\sqcup 4 = 4$。这与 $Val[y] = \\bot$ 不同。更新 $Val[y] := 4$。将 $y$ 的使用者入队：$x$。$W = [a, b, x, b, x]$。\n11. 从队列中取出 $a$。$D=11$。$a := \\phi(c, b)$。我们计算 $Val[c] \\sqcup Val[b] = 4 \\sqcup \\bot = 4$。这与 $Val[a] = \\bot$ 不同。更新 $Val[a] := 4$。将 $a$ 的使用者入队：$f$。$W = [b, x, b, x, f]$。\n12. 从队列中取出 $b$。$D=12$。$b := \\phi(e, d)$。我们计算 $Val[e] \\sqcup Val[d] = 8 \\sqcup 9 = \\top$（因为 $8 \\neq 9$）。这与 $Val[b] = \\bot$ 不同。更新 $Val[b] := \\top$。将 $b$ 的使用者入队：$a$。$W = [x, b, x, f, a]$。\n13. 从队列中取出 $x$。$D=13$。$x := \\phi(y, d)$。我们计算 $Val[y] \\sqcup Val[d] = 4 \\sqcup 9 = \\top$（因为 $4 \\neq 9$）。这与 $Val[x] = \\bot$ 不同。更新 $Val[x] := \\top$。将 $x$ 的使用者入队：$f$。$W = [b, x, f, a, f]$。\n14. 从队列中取出 $b$。$D=14$。$b := \\phi(e, d)$。我们计算 $Val[e] \\sqcup Val[d] = 8 \\sqcup 9 = \\top$。这等于当前的 $Val[b] = \\top$。无更新。$W = [x, f, a, f]$。\n15. 从队列中取出 $x$。$D=15$。$x := \\phi(y, d)$。我们计算 $Val[y] \\sqcup Val[d] = 4 \\sqcup 9 = \\top$。这等于当前的 $Val[x] = \\top$。无更新。$W = [f, a, f]$。\n16. 从队列中取出 $f$。$D=16$。$f := \\text{add}(x, a)$。当前值为 $Val[x]=\\top$ 和 $Val[a]=4$。由于 $Val[x]$ 不是整数，转移函数产生 $\\top$。这与 $Val[f] = \\bot$ 不同。更新 $Val[f] := \\top$。没有 $f$ 的使用者需要入队。$W = [a, f]$。\n17. 从队列中取出 $a$。$D=17$。$a := \\phi(c, b)$。我们计算 $Val[c] \\sqcup Val[b] = 4 \\sqcup \\top = \\top$。这与 $Val[a] = 4$ 不同。更新 $Val[a] := \\top$。将 $a$ 的使用者入队：$f$。$W = [f, f]$。\n18. 从队列中取出 $f$。$D=18$。$f := \\text{add}(x, a)$。当前值为 $Val[x]=\\top$ 和 $Val[a]=\\top$。由于一个或两个输入不是整数，转移函数产生 $\\top$。这等于当前的 $Val[f] = \\top$。无更新。$W = [f]$。\n19. 从队列中取出 $f$。$D=19$。$f := \\text{add}(x, a)$。当前值为 $Val[x]=\\top$ 和 $Val[a]=\\top$。转移函数产生 $\\top$。这等于当前的 $Val[f] = \\top$。无更新。$W = []$。\n\n工作列表现在为空。算法终止。出队总数为 $19$。\n最终状态是：\n$Val[a] = \\top$\n$Val[b] = \\top$\n$Val[c] = 4$\n$Val[d] = 9$\n$Val[e] = 8$\n$Val[f] = \\top$\n$Val[x] = \\top$\n$Val[y] = 4$\n\n问题要求的是执行的出队总数。根据追踪过程，这个数字是 $19$。",
            "answer": "$$\n\\boxed{19}\n$$"
        },
        {
            "introduction": "不动点迭代的应用远不止于传统的编译器优化。本练习旨在拓宽你的视野，展示如何将该算法应用于自动机理论中的一个基本问题：计算$\\epsilon$-闭包。通过将状态可达性问题建模为在幂集格上的不动点计算，你将体会到工作表算法作为一个通用图遍历工具的强大之处，并加深对不动点概念本质的理解。",
            "id": "3683091",
            "problem": "编译器前端将一个词法识别器建模为嵌入在编译器中间表示 (IR) 中的一个非确定性有限自动机 (NFA)。IR 节点是与 NFA 状态对应的基本块。在这些控制流边中，一些是特殊的 $\\epsilon$-转移，它们不消耗任何输入。一个状态集的 $\\epsilon$-闭包被定义为包含该状态集，并且对于通过零次或多次 $\\epsilon$-转移所能达到的状态是封闭的最小状态集。你需要将此问题视为在有限格上的单调数据流分析，并使用基于工作列表的不动点迭代方法来计算一个 $\\epsilon$-闭包的大小。\n\n设状态集为 $Q=\\{q_0,q_1,q_2,q_3,q_4,q_5,q_6,q_7,q_8,q_9,q_{10},q_{11}\\}$。$\\epsilon$-转移（且仅有这些转移）如下：\n- $q_0 \\to q_1$, $q_0 \\to q_2$。\n- $q_1 \\to q_3$。\n- $q_2 \\to q_3$, $q_2 \\to q_4$。\n- $q_3 \\to q_5$。\n- $q_4 \\to q_2$, $q_4 \\to q_6$。\n- $q_5 \\to q_7$。\n- $q_6 \\to q_7$。\n- $q_7 \\to q_8$, $q_7 \\to q_9$。\n- $q_8 \\to q_{10}$。\n- $q_9 \\to q_{10}$, $q_9 \\to q_{11}$。\n- $q_{10}$ 没有出向的 $\\epsilon$-转移。\n- $q_{11} \\to q_6$。\n\n此外，还存在一些非-$\\epsilon$的符号标记转移（例如 $q_1 \\xrightarrow{a} q_2$, $q_2 \\xrightarrow{b} q_9$, $q_6 \\xrightarrow{c} q_3$, $q_7 \\xrightarrow{d} q_0$, $q_{10} \\xrightarrow{e} q_4$），但这些转移不参与 $\\epsilon$-闭包的计算，在下述计算中必须忽略。\n\n定义初始状态集为 $S_0=\\{q_0,q_4,q_9\\}$。考虑幂集格 $\\langle 2^{Q}, \\subseteq \\rangle$，其最小上界为集合并集。将 $\\epsilon$-闭包计算建模为此格上一个单调函数的最小不动点，并通过一个工作列表在概念上实现此计算：开始时工作列表恰好包含 $S_0$ 的元素，维护一个初始化为 $S_0$ 的已访问集合，重复地从工作列表中弹出一个状态，对于每个尚未在已访问集合中的出向 $\\epsilon$-后继，将其添加到已访问集合并推入工作列表；当工作列表变空时终止。终止时的已访问集合即为 $S_0$ 的 $\\epsilon$-闭包。\n\n使用此方法且仅使用上面列出的 $\\epsilon$-转移，$S_0$ 的 $\\epsilon$-闭包的准确基数是多少？请将最终答案表示为一个整数。无需也不允许进行四舍五入，且不涉及任何物理单位。",
            "solution": "问题要求在一个给定的非确定性有限自动机 (NFA) 中，计算初始状态集 $S_0$ 的 $\\epsilon$-闭包的基数。计算需要按照所描述的、基于工作列表的不动点迭代算法来执行。\n\n首先，我们确定问题的形式化组件。\n所有状态的集合是 $Q=\\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$。状态总数为 $|Q| = 12$。\n需要计算其闭包的初始状态集是 $S_0 = \\{q_0, q_4, q_9\\}$。\n$\\epsilon$-转移定义了一个有向图 $G=(Q, E)$，其中如果存在从状态 $u$ 到状态 $v$ 的 $\\epsilon$-转移，则图中存在一条边 $(u, v) \\in E$。边集 $E$ 由以下给出：\n$E = \\{$\n$(q_0, q_1), (q_0, q_2),$\n$(q_1, q_3),$\n$(q_2, q_3), (q_2, q_4),$\n$(q_3, q_5),$\n$(q_4, q_2), (q_4, q_6),$\n$(q_5, q_7),$\n$(q_6, q_7),$\n$(q_7, q_8), (q_7, q_9),$\n$(q_8, q_{10}),$\n$(q_9, q_{10}), (q_9, q_{11}),$\n$(q_{11}, q_6)$\n$\\}$\n题目明确指出，在本次计算中应忽略非-$\\epsilon$ 转移。\n\n$S_0$ 的 $\\epsilon$-闭包，记作 $\\epsilon\\text{-closure}(S_0)$，是从 $S_0$ 中任意状态出发，通过零次或多次 $\\epsilon$-转移可达的所有状态的集合。题目指定了一个工作列表算法来计算这个集合。设 $V$ 为已访问状态的集合（该集合将成为闭包集），$W$ 为工作列表。\n\n算法流程如下：\n1. 使用初始状态集 $S_0$ 初始化已访问集合 $V$ 和工作列表 $W$。\n2. 当工作列表 $W$ 不为空时：\n   a. 从 $W$ 中移除一个状态 $u$。\n   b. 对于每个满足“存在从 $u$ 到 $v$ 的 $\\epsilon$-转移”的状态 $v$：\n      i. 如果 $v$ 不在 $V$ 中：\n         - 将 $v$ 添加到 $V$ 中。\n         - 将 $v$ 添加到 $W$ 中。\n3. 最终的集合 $V$ 就是 $S_0$ 的 $\\epsilon$-闭包。\n\n我们现在来追踪这个算法的执行过程。从工作列表中处理元素的顺序不影响最终结果，只影响中间步骤的序列。为了进行系统性遍历，我们将把工作列表当作一个队列（先进先出）。\n\n**初始化：**\n- 已访问集合: $V = \\{q_0, q_4, q_9\\}$\n- 工作列表: $W = [q_0, q_4, q_9]$\n\n**第 1 轮迭代：**从 $W$ 中弹出 $q_0$。\n- $q_0$ 的后继是 $q_1$ 和 $q_2$。\n- $q_1 \\notin V$。将 $q_1$ 添加到 $V$ 和 $W$。\n- $q_2 \\notin V$。将 $q_2$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_4, q_9\\}$\n- $W = [q_4, q_9, q_1, q_2]$\n\n**第 2 轮迭代：**从 $W$ 中弹出 $q_4$。\n- $q_4$ 的后继是 $q_2$ 和 $q_6$。\n- $q_2 \\in V$。无操作。\n- $q_6 \\notin V$。将 $q_6$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_4, q_6, q_9\\}$\n- $W = [q_9, q_1, q_2, q_6]$\n\n**第 3 轮迭代：**从 $W$ 中弹出 $q_9$。\n- $q_9$ 的后继是 $q_{10}$ 和 $q_{11}$。\n- $q_{10} \\notin V$。将 $q_{10}$ 添加到 $V$ 和 $W$。\n- $q_{11} \\notin V$。将 $q_{11}$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_4, q_6, q_9, q_{10}, q_{11}\\}$\n- $W = [q_1, q_2, q_6, q_{10}, q_{11}]$\n\n**第 4 轮迭代：**从 $W$ 中弹出 $q_1$。\n- $q_1$ 的后继是 $q_3$。\n- $q_3 \\notin V$。将 $q_3$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_6, q_9, q_{10}, q_{11}\\}$\n- $W = [q_2, q_6, q_{10}, q_{11}, q_3]$\n\n**第 5 轮迭代：**从 $W$ 中弹出 $q_2$。\n- $q_2$ 的后继是 $q_3$ 和 $q_4$。\n- $q_3 \\in V$。无操作。\n- $q_4 \\in V$。无操作。\n- $W = [q_6, q_{10}, q_{11}, q_3]$\n\n**第 6 轮迭代：**从 $W$ 中弹出 $q_6$。\n- $q_6$ 的后继是 $q_7$。\n- $q_7 \\notin V$。将 $q_7$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_6, q_7, q_9, q_{10}, q_{11}\\}$\n- $W = [q_{10}, q_{11}, q_3, q_7]$\n\n**第 7 轮迭代：**从 $W$ 中弹出 $q_{10}$。\n- $q_{10}$ 没有出向的 $\\epsilon$-转移。\n- $W = [q_{11}, q_3, q_7]$\n\n**第 8 轮迭代：**从 $W$ 中弹出 $q_{11}$。\n- $q_{11}$ 的后继是 $q_6$。\n- $q_6 \\in V$。无操作。\n- $W = [q_3, q_7]$\n\n**第 9 轮迭代：**从 $W$ 中弹出 $q_3$。\n- $q_3$ 的后继是 $q_5$。\n- $q_5 \\notin V$。将 $q_5$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_9, q_{10}, q_{11}\\}$\n- $W = [q_7, q_5]$\n\n**第 10 轮迭代：**从 $W$ 中弹出 $q_7$。\n- $q_7$ 的后继是 $q_8$ 和 $q_9$。\n- $q_8 \\notin V$。将 $q_8$ 添加到 $V$ 和 $W$。\n- $q_9 \\in V$。无操作。\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$\n- $W = [q_5, q_8]$\n\n此时，已访问集合 $V$ 包含了从 $q_0$ 到 $q_{11}$ 的所有 12 个状态。算法会继续执行直到工作列表为空，但不会有新的状态被添加到 $V$ 中。\n\n**第 11 轮迭代：**从 $W$ 中弹出 $q_5$。\n- $q_5$ 的后继是 $q_7$。\n- $q_7 \\in V$。无操作。\n- $W = [q_8]$\n\n**第 12 轮迭代：**从 $W$ 中弹出 $q_8$。\n- $q_8$ 的后继是 $q_{10}$。\n- $q_{10} \\in V$。无操作。\n- $W = []$\n\n**终止：**\n工作列表 $W$ 现已为空。算法终止。最终的已访问集合是 $S_0$ 的 $\\epsilon$-闭包。\n$\\epsilon\\text{-closure}(S_0) = V_{final} = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$。\n这是完整的状态集 $Q$。\n\n问题要求计算这个集合的基数。\n$|\\epsilon\\text{-closure}(S_0)| = |Q| = 12$。\n\n另外，我们也可以更直接地从可达性角度进行推理。$S_0$ 的 $\\epsilon$-闭包是其各个元素闭包的并集：$\\epsilon\\text{-closure}(S_0) = \\bigcup_{s \\in S_0} \\epsilon\\text{-closure}(\\{s\\})$。我们只需要在 $S_0$ 中找到一个可以到达所有状态的元素。\n让我们分析从 $q_0 \\in S_0$ 出发的可达性：\n- $q_0 \\to \\{q_1, q_2\\}$\n- 从 $\\{q_1, q_2\\} \\to \\{q_3, q_4\\}$\n- 从 $\\{q_3, q_4\\} \\to \\{q_5, q_2, q_6\\}$\n- 从 $\\{q_5, q_6\\} \\to \\{q_7\\}$\n- 从 $\\{q_7\\} \\to \\{q_8, q_9\\}$\n- 从 $\\{q_8, q_9\\} \\to \\{q_{10}, q_{11}\\}$\n- 从 $\\{q_{11}\\} \\to \\{q_6\\}$\n通过这些路径，很明显所有状态 $q_1, \\dots, q_{11}$ 都可以从 $q_0$ 到达。由于 $\\{q_0\\}$ 的闭包根据定义包含 $q_0$ 本身，因此 $\\epsilon\\text{-closure}(\\{q_0\\}) = Q$。\n因为 $\\epsilon\\text{-closure}(S_0) = \\epsilon\\text{-closure}(\\{q_0\\}) \\cup \\epsilon\\text{-closure}(\\{q_4\\}) \\cup \\epsilon\\text{-closure}(\\{q_9\\})$，并且 $\\epsilon\\text{-closure}(\\{q_0\\}) = Q$，所以最终的并集也必须是 $Q$。\n因此，$S_0$ 的 $\\epsilon$-闭包的基数就是 $Q$ 的基数，即 $12$。",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "现代程序充满了复杂的控制流，例如异常处理。这个高级练习将挑战你如何将工作表算法扩展到包含异常边的控制流图上。通过为正常边和异常边定义不同的数据流转移规则，你将学习如何精确建模在基本块执行中途可能发生的控制转移，并分析其对数据流分析结果的影响。",
            "id": "3683032",
            "problem": "考虑一个前向、may 数据流分析，它被形式化为一个关于事实幂集格的单调框架。令事实的有限域为 $D = \\{a, b, c\\}$，其上配备了子集序 $\\subseteq$ 和由集合并集 $\\cup$ 给出的最小上界（连接）操作符。对于控制流图中的每个节点 $x$，令传递函数为 $f_x : 2^D \\to 2^D$，并假设所有传递函数都是单调的。数据流方程为：\n- $IN[x] = \\bigcup_{p \\in \\mathrm{pred}(x)} FLOW_{p \\to x}$，\n- $OUT[x] = f_x(IN[x])$，\n其中 $FLOW_{p \\to x}$ 是从前驱节点 $p$ 沿边传播到 $x$ 的值。\n\n通过为每个可能抛出异常的节点 $n$ 分配一个正常后继和一个异常后继来为异常控制流建模。对于一条正常边 $n \\to s$，定义 $FLOW_{n \\to s} = OUT[n]$。对于一条异常边 $n \\to e$，定义一个特定于边的传递函数 $g_n : 2^D \\to 2^D$ 并设置 $FLOW_{n \\to e} = g_n(IN[n])$。直观上，$g_n$ 模拟了异常在节点 $n$ 完成其正常效果之前转移控制流的情况。\n\n考虑以下控制流图：\n- 节点：$\\mathrm{entry}, n_1, n_2, n_3, e$。\n- 正常边：$\\mathrm{entry} \\to n_1$，$n_1 \\to n_2$，$n_2 \\to n_3$，$n_3 \\to n_1$。\n- 异常边：$n_1 \\to e$，$n_2 \\to e$。\n- 异常处理器 $e$ 有一条正常边 $e \\to n_3$。\n\n令传递函数为：\n- $f_{\\mathrm{entry}}(X) = X$，\n- $f_{n_1}(X) = X \\cup \\{a\\}$，\n- $f_{n_2}(X) = X \\cup \\{b\\}$，\n- $f_{n_3}(X) = X \\cup \\{c\\}$，\n- $f_e(X) = X$，\n以及异常边传递函数为：\n- $g_{n_1}(X) = X \\cap \\{a\\}$，\n- $g_{n_2}(X) = X \\cap \\{a, b\\}$。\n\n使用一个标准的基于工作列表的不动点迭代算法，工作列表为先进先出（FIFO）队列。对于所有节点 $x$，初始化 $IN[x] = \\varnothing$ 和 $OUT[x] = \\varnothing$。按顺序 $[\\mathrm{entry}, n_1, n_2, n_3, e]$ 初始化工作列表。当一个节点 $x$ 出队时，重新计算 $OUT[x] := f_x(IN[x])$。如果 $OUT[x]$ 增加，则对于每个正常后继 $s$，更新 $IN[s] := IN[s] \\cup OUT[x]$，并且如果 $IN[s]$ 增加，则将 $s$ 入队。此外，在处理完 $x$ 之后，沿从 $x$ 出发的异常边进行传播：对于每个异常后继 $e$，更新 $IN[e] := IN[e] \\cup g_x(IN[x])$，并且如果 $IN[e]$ 增加，则将 $e$ 入队。\n\n将 $OUT[e]$ 的稳定点定义为迭代中的一个点，此后 $OUT[e]$ 在运行的剩余时间内不再改变。在上述设置下，确定直到（并包括）$OUT[e]$ 达到其最终不动点值的出队操作，所执行的工作列表出队总数。请用一个整数表示你的答案。无需四舍五入。",
            "solution": "首先根据指定标准验证问题陈述。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **域：**一个有限的事实集合 $D = \\{a, b, c\\}$。\n- **格：**幂集格 $(2^D, \\subseteq)$，连接操作符为 $\\cup$。\n- **分析类型：**前向，may-分析。\n- **数据流方程：**\n    - $IN[x] = \\bigcup_{p \\in \\mathrm{pred}(x)} FLOW_{p \\to x}$\n    - $OUT[x] = f_x(IN[x])$\n- **边上的流：**\n    - 正常边 $n \\to s$：$FLOW_{n \\to s} = OUT[n]$\n    - 异常边 $n \\to e$：$FLOW_{n \\to e} = g_n(IN[n])$\n- **控制流图：**\n    - 节点：$\\{\\mathrm{entry}, n_1, n_2, n_3, e\\}$\n    - 正常边：$\\mathrm{entry} \\to n_1$, $n_1 \\to n_2$, $n_2 \\to n_3$, $n_3 \\to n_1$, $e \\to n_3$\n    - 异常边：$n_1 \\to e$, $n_2 \\to e$\n- **传递函数 ($f_x$)：**\n    - $f_{\\mathrm{entry}}(X) = X$\n    - $f_{n_1}(X) = X \\cup \\{a\\}$\n    - $f_{n_2}(X) = X \\cup \\{b\\}$\n    - $f_{n_3}(X) = X \\cup \\{c\\}$\n    - $f_e(X) = X$\n- **异常边传递函数 ($g_x$)：**\n    - $g_{n_1}(X) = X \\cap \\{a\\}$\n    - $g_{n_2}(X) = X \\cap \\{a, b\\}$\n- **算法：**使用 FIFO 队列的基于工作列表的不动点迭代。\n- **初始化：**\n    - 对于所有节点 $x$，$IN[x] = \\emptyset$ 且 $OUT[x] = \\emptyset$。\n    - 工作列表 $W = [\\mathrm{entry}, n_1, n_2, n_3, e]$。\n- **算法逻辑：**当一个节点 $x$ 出队时，重新计算 $OUT[x]$。如果 $OUT[x]$ 增加，则该变化会传播到其正常后继。处理完 $x$ 后，基于 $g_x(IN[x])$ 将流传播到异常后继。如果后继的 $IN$ 集合增加，则将其入队。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在编译器原理和数据流分析领域有科学依据。它是一个良构问题，因为有限格和单调传递函数的使用保证了最小不动点的存在以及工作列表算法的终止。问题陈述是客观、完整且内部一致的，提供了所有必要的定义、初始条件和要使用的具体算法。算法的规则，虽然对异常流有特殊的处理方式，但是是明确定义且无歧义的。该问题是标准计算机科学问题的一个具体实例，并非微不足道，其解决方案在数学上是可验证的。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。将通过追踪指定工作列表算法的执行过程来提供分步解决方案。\n\n### 解答\n\n我们追踪分析的状态，该状态包括每个节点的 $IN$ 和 $OUT$ 集合以及工作列表 $W$。标准的工作列表算法将工作列表视为一组需要处理的节点，因此如果一个节点已经在工作列表中，则不会再次添加。我们将遵循这一惯例。工作列表 $W$ 是一个 FIFO 队列。\n\n**初始状态：**\n- 对于所有 $x \\in \\{\\mathrm{entry}, n_1, n_2, n_3, e\\}$，$IN[x] = \\emptyset$。\n- 对于所有 $x \\in \\{\\mathrm{entry}, n_1, n_2, n_3, e\\}$，$OUT[x] = \\emptyset$。\n- $W = [\\mathrm{entry}, n_1, n_2, n_3, e]$。\n- 出队计数 = $0$。\n\n**迭代 1：**\n- **出队：**$\\mathrm{entry}$。$W = [n_1, n_2, n_3, e]$。**出队计数 = 1**。\n- $IN[\\mathrm{entry}] = \\emptyset$。$new\\_OUT[\\mathrm{entry}] = f_{\\mathrm{entry}}(\\emptyset) = \\emptyset$。\n- $OUT[\\mathrm{entry}]$ 没有变化。\n- 没有发生传播。\n\n**迭代 2：**\n- **出队：**$n_1$。$W = [n_2, n_3, e]$。**出队计数 = 2**。\n- $IN[n_1] = \\emptyset$。$new\\_OUT[n_1] = f_{n_1}(\\emptyset) = \\{a\\}$。\n- $OUT[n_1]$ 从 $\\emptyset$ 变为 $\\{a\\}$。\n- 向 $n_2$ 的正常传播：$IN[n_2]$ 从 $\\emptyset$ 变为 $\\emptyset \\cup \\{a\\} = \\{a\\}$。由于 $n_2$ 已经在 $W$ 中，因此不再次添加。\n- 向 $e$ 的异常传播：$exn\\_flow = g_{n_1}(IN[n_1]) = g_{n_1}(\\emptyset) = \\emptyset$。$IN[e]$ 没有变化。\n\n**迭代 3：**\n- **出队：**$n_2$。$W = [n_3, e]$。**出队计数 = 3**。\n- $IN[n_2] = \\{a\\}$。$new\\_OUT[n_2] = f_{n_2}(\\{a\\}) = \\{a\\} \\cup \\{b\\} = \\{a, b\\}$。\n- $OUT[n_2]$ 从 $\\emptyset$ 变为 $\\{a, b\\}$。\n- 向 $n_3$ 的正常传播：$IN[n_3]$ 从 $\\emptyset$ 变为 $\\emptyset \\cup \\{a, b\\} = \\{a, b\\}$。$n_3$ 已经在 $W$ 中。\n- 向 $e$ 的异常传播：$exn\\_flow = g_{n_2}(IN[n_2]) = g_{n_2}(\\{a\\}) = \\{a\\} \\cap \\{a, b\\} = \\{a\\}$。$IN[e]$ 从 $\\emptyset$ 变为 $\\emptyset \\cup \\{a\\} = \\{a\\}$。$e$ 已经在 $W$ 中。\n\n**迭代 4：**\n- **出队：**$n_3$。$W = [e]$。**出队计数 = 4**。\n- $IN[n_3] = \\{a, b\\}$。$new\\_OUT[n_3] = f_{n_3}(\\{a, b\\}) = \\{a, b\\} \\cup \\{c\\} = \\{a, b, c\\}$。\n- $OUT[n_3]$ 从 $\\emptyset$ 变为 $\\{a, b, c\\}$。\n- 向 $n_1$ 的正常传播：$IN[n_1]$ 从 $\\emptyset$ 变为 $\\emptyset \\cup \\{a, b, c\\} = \\{a, b, c\\}$。$n_1$ 不在 $W$ 中，因此入队。$W = [e, n_1]$。\n- 节点 $n_3$ 没有异常后继。\n\n**迭代 5：**\n- **出队：**$e$。$W = [n_1]$。**出队计数 = 5**。\n- $IN[e] = \\{a\\}$。$new\\_OUT[e] = f_e(\\{a\\}) = \\{a\\}$。\n- $OUT[e]$ 从 $\\emptyset$ 变为 $\\{a\\}$。\n- 向 $n_3$ 的正常传播：$IN[n_3]$ 是 $\\{a, b\\}$。它变为 $\\{a, b\\} \\cup \\{a\\} = \\{a, b\\}$。没有变化。\n- 节点 $e$ 没有异常后继。\n\n**迭代 6：**\n- **出队：**$n_1$。$W = []$。**出队计数 = 6**。\n- $IN[n_1] = \\{a, b, c\\}$。$new\\_OUT[n_1] = f_{n_1}(\\{a, b, c\\}) = \\{a, b, c\\} \\cup \\{a\\} = \\{a, b, c\\}$。\n- $OUT[n_1]$ 从 $\\{a\\}$ 变为 $\\{a, b, c\\}$。\n- 向 $n_2$ 的正常传播：$IN[n_2]$ 从 $\\{a\\}$ 变为 $\\{a\\} \\cup \\{a, b, c\\} = \\{a, b, c\\}$。$n_2$ 不在 $W$ 中，因此入队。$W = [n_2]$。\n- 向 $e$ 的异常传播：$exn\\_flow = g_{n_1}(IN[n_1]) = g_{n_1}(\\{a, b, c\\}) = \\{a, b, c\\} \\cap \\{a\\} = \\{a\\}$。$IN[e]$ 是 $\\{a\\}$，所以没有变化。\n\n**迭代 7：**\n- **出队：**$n_2$。$W = []$。**出队计数 = 7**。\n- $IN[n_2] = \\{a, b, c\\}$。$new\\_OUT[n_2] = f_{n_2}(\\{a, b, c\\}) = \\{a, b, c\\} \\cup \\{b\\} = \\{a, b, c\\}$。\n- $OUT[n_2]$ 从 $\\{a, b\\}$ 变为 $\\{a, b, c\\}$。\n- 向 $n_3$ 的正常传播：$IN[n_3]$ 从 $\\{a,b\\}$ 变为 $\\{a,b\\} \\cup \\{a,b,c\\} = \\{a,b,c\\}$。$n_3$ 不在 $W$ 中，因此入队。$W=[n_3]$。\n- 向 $e$ 的异常传播：$exn\\_flow = g_{n_2}(IN[n_2]) = g_{n_2}(\\{a, b, c\\}) = \\{a, b, c\\} \\cap \\{a, b\\} = \\{a, b\\}$。$IN[e]$ 从 $\\{a\\}$ 变为 $\\{a\\} \\cup \\{a, b\\} = \\{a, b\\}$。$e$ 不在 $W$ 中，因此入队。$W = [n_3, e]$。\n\n**迭代 8：**\n- **出队：**$n_3$。$W = [e]$。**出队计数 = 8**。\n- $IN[n_3] = \\{a, b, c\\}$。$new\\_OUT[n_3] = f_{n_3}(\\{a, b, c\\}) = \\{a, b, c\\} \\cup \\{c\\} = \\{a, b, c\\}$。\n- $OUT[n_3]$ 已经是 $\\{a, b, c\\}$。没有变化。\n- 没有发生传播。\n\n**迭代 9：**\n- **出队：**$e$。$W = []$。**出队计数 = 9**。\n- $IN[e] = \\{a, b\\}$。$new\\_OUT[e] = f_e(\\{a, b\\}) = \\{a, b\\}$。\n- $OUT[e]$ 从 $\\{a\\}$ 变为 $\\{a, b\\}$。\n- 向 $n_3$ 的正常传播：$IN[n_3]$ 是 $\\{a, b, c\\}$。它变为 $\\{a, b, c\\} \\cup \\{a, b\\} = \\{a, b, c\\}$。没有变化。\n- 工作列表 $W$ 现在为空。算法终止。\n\n$OUT[e]$ 的不动点值是 $\\{a, b\\}$。这个值是在迭代 9 中处理节点 $e$ 时达到的。由于算法在此步骤后立即终止，所以这是最终值。问题要求的是直到（并包括）这一点所执行的出队总数。\n\n出队次数为 $9$。",
            "answer": "$$\n\\boxed{9}\n$$"
        }
    ]
}