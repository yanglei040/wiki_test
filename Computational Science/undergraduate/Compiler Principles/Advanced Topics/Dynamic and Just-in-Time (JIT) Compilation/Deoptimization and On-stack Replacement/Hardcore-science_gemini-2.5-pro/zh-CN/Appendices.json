{
    "hands_on_practices": [
        {
            "introduction": "此练习将带您深入了解去优化的核心。当即时 (JIT) 编译器做出一个乐观的假设时——例如，“浮点数永远不会是 `NaN`（非数字）”——它必须准备一个备用计划。此练习旨在考验您能否准确识别当该假设失败时，为了正确回退到安全的、未优化的状态所必需的精确信息（即“去优化快照”），从而确保程序行为符合预期。",
            "id": "3636788",
            "problem": "一个用于类 Java 语言的即时 (JIT) 编译器在一个循环内部应用了推测性优化，该循环计算一个浮点数组中有多少元素不是非数值 (Not-a-Number)。该语言遵循美国电气和电子工程师协会 (IEEE) 754 的比较语义，并且不向程序暴露浮点状态标志或舍入模式的更改。该编译器支持去优化和栈上替换 (On-Stack Replacement, OSR)，能够在去优化安全点将控制权从优化后的代码转回基线解释器，并重构一个等效的执行状态。\n\n考虑这个计算非 NaN 元素数量的函数：\n- 对于长度为 $n$ 的输入数组 $a$，它计算\n  $$ s \\leftarrow 0; \\quad \\text{for } i = 0 \\text{ to } n-1: \\quad x \\leftarrow a[i]; \\quad \\text{if } (x  0.0) \\lor (x \\ge 0.0) \\text{ then } s \\leftarrow s + 1; $$\n- 根据 IEEE 754 标准，任何与 $\\text{NaN}$ 的有序比较结果都为假，因此对于 $x = \\text{NaN}$，$(x  0.0)$ 和 $(x \\ge 0.0)$ 都为假，增量操作被跳过。对于所有 $x \\neq \\text{NaN}$，$(x  0.0)$ 或 $(x \\ge 0.0)$ 中恰好有一个为真，因此执行增量操作。\n\n优化器推测数组元素不是 $\\text{NaN}$，并将条件增量替换为无条件增量。它引入了一个每次迭代的守卫检查\n$$ g(x) = \\neg \\text{isNaN}(x), $$\n该守卫检查紧接在增量操作之前，以确保正确性。如果 $g(x)$ 失败（即 $x = \\text{NaN}$），运行时必须进行去优化和栈上替换 (OSR)，切换到基线执行，从而为所有后续迭代和当前元素保持可观察到的 IEEE 754 行为。\n\n假设：\n- 数组加载 $x \\leftarrow a[i]$ 及其相关的空指针和边界检查在求值 $g(x)$ 之前完成。\n- 在求值 $g(x)$ 之前，循环体中没有发生其他副作用。\n- 该语言不为静默 $\\text{NaN}$ 暴露浮点状态标志或陷阱异常；只有值和分支结果是可观察的。\n\n哪个选项正确且最小化地指明了所需的去优化快照，以及在守卫失败时执行必须在何处恢复，以保持预期的 IEEE 754 可观察语义？\n\nA. 在基线中紧随被移除的条件判断之后恢复执行，并将当前 $x = \\text{NaN}$ 的条件判断结果强制为 $0$。快照中只需要映射 $x$，因为基线可以重新计算其他所有内容，并且这个捷径保持了 IEEE 754 的行为。\n\nB. 在基线中对应于对当前元素求值 $(x  0.0) \\lor (x \\ge 0.0)$ 之前的程序点恢复执行。去优化快照必须映射 $a$、$n$、当前循环索引 $i$、本次迭代增量前的累加器 $s$ 以及加载的 $x$（即 $\\text{NaN}$），并将解释器的程序计数器设置到该比较点。由于浮点状态标志不可观察，因此无需保留它们。\n\nC. 在基线中于函数返回之后恢复执行，并提供最终的 $s$ 值，就好像当前元素贡献了 $0$ 一样；这是等效的，因为剩余迭代的效果可以被推断和折叠，所以重构中间循环状态是不必要的。\n\nD. 在循环头恢复执行，但同时捕获并恢复浮点状态标志，以保留因与 $\\text{NaN}$ 比较而产生的无效操作标志；否则，即使语言不暴露这些标志，IEEE 754 语义也会被违反。\n\n各选项相互排斥；请选择唯一最佳选项。",
            "solution": "该问题要求我们确定当推测性优化失败时，进行去优化和栈上替换 (OSR) 的正确且最小化的需求。目标是保持原始未优化程序的可观察语义。\n\n让我们首先分析原始代码和优化后代码的行为。\n\n原始函数基于从 `$i = 0$` 到 `$n-1$` 的循环计算总和 `$s$`。其核心逻辑是：\n$$ s \\leftarrow 0; $$\n$$ \\text{for } i = 0 \\text{ to } n-1: $$\n$$ \\quad x \\leftarrow a[i]; $$\n$$ \\quad \\text{if } (x  0.0) \\lor (x \\ge 0.0) \\text{ then } s \\leftarrow s + 1; $$\n\n根据 IEEE 754 标准，任何涉及非数值 (`NaN`) 值的有序比较结果都为假。因此，如果 `$x$` 是 `NaN`，则 `$x  0.0$` 和 `$x \\ge 0.0$` 都为假，它们的析取（逻辑或）也为假，`$s$` 不会增加。对于任何其他浮点值（有限数和无穷大），条件 `$(x  0.0) \\lor (x \\ge 0.0)$` 为真，`$s$` 会增加。因此，该函数计算数组 `$a$` 中非 `NaN` 元素的数量。\n\n优化器推测 `NaN` 值是罕见的，并转换了该循环。它用一个无条件增量替换了条件增量，并由一个检查来守卫。优化后的循环体实际上是：\n$$ x \\leftarrow a[i]; $$\n$$ \\text{if } \\neg(\\neg \\text{isNaN}(x)) \\text{ then deoptimize}; \\quad \\text{// This is equivalent to if isNaN(x) then deoptimize} $$\n$$ s \\leftarrow s + 1; $$\n\n守卫是 `$g(x) = \\neg \\text{isNaN}(x)$`。当这个守卫失败时会发生去优化，也就是当 `$x$` 是 `NaN` 时。\n\n现在，让我们考虑在某个迭代 `$i$` 中守卫失败那一刻的程序状态：\n1.  循环正在执行第 `$i$` 次迭代。\n2.  数组元素 `$a[i]$` 已被加载到变量 `$x$` 中。我们知道 `$x$` 是 `NaN`。\n3.  累加器 `$s$` 保存着直到第 `$i-1$` 次迭代结束时计算出的值。当前第 `$i$` 次迭代的无条件增量 `$s \\leftarrow s + 1$` *尚未*执行。\n4.  循环变量 `$i$`、`$n$` 以及对数组 `$a$` 的引用都处于活跃状态。\n\n去优化和 OSR 的原则是，将控制权转移到未优化版本的代码（基线解释器）中，其执行点在语义上等同于优化代码中的失败点，并带有一个重构的状态，以允许未优化的代码继续正确执行。\n\n为了保持可观察的语义，解释器必须为当前迭代 `$i$` 及所有后续迭代执行原始逻辑。优化逻辑和原始逻辑之间的分歧点是条件语句。守卫 `$g(x)$` 替代了原始条件 `$(x  0.0) \\lor (x \\ge 0.0)$`。因此，在基线解释代码中正确的恢复点应该紧接在对这个原始条件求值*之前*。\n\n在这个恢复点，解释器需要足够的状态来正确执行函数的剩余部分。这就构成了去优化快照：\n- **数组和循环边界：** 对数组 `$a$` 的引用及其长度 `$n$` 是后续迭代所必需的。\n- **循环索引：** 需要当前循环索引 `$i$` 来知道正在处理哪个迭代并从那里继续。\n- **累加器：** 总和 `$s$` 的值，即当前迭代进行推测性增量*之前*的值，是至关重要的。这是第 `$i$` 次迭代开始时的 `$s$` 值。\n- **当前元素：** 需要 `$x$` 的值（即 `NaN`）以便解释器对条件 `$(x  0.0) \\lor (x \\ge 0.0)$` 进行求值。结果将为假，`$s$` 在本次迭代中不会增加（这对于 `NaN` 元素是正确的行为），然后执行将进入下一次迭代 `$i+1$`。\n\n问题陈述指明该语言不暴露浮点状态标志。这意味着这些标志的状态不属于程序可观察语义的一部分。因此，在去优化期间没有要求捕获、恢复或以其他方式管理浮点状态标志。目标是保持程序的可见输出（`$s$` 的最终值）和控制流，而不是不可观察的硬件级状态。\n\n现在，我们根据这个推导来评估每个选项。\n\n**A. 在基线中紧随被移除的条件判断之后恢复执行，并将当前 $x = \\text{NaN}$ 的条件判断结果强制为 $0$。快照中只需要映射 $x$，因为基线可以重新计算其他所有内容，并且这个捷径保持了 IEEE 754 的行为。**\n这是不正确的。OSR 的原则是在原始逻辑*内部*恢复执行，而不是用一个预先计算好的结果跳过它。恢复点是错误的。此外，声称快照中只需要 `$x$` 是错误的；解释器无法“重新计算其他所有内容”，比如 `$s$` 和 `$i$` 的当前值，除非重启整个计算。\n**结论：不正确。**\n\n**B. 在基线中对应于对当前元素求值 $(x  0.0) \\lor (x \\ge 0.0)$ 之前的程序点恢复执行。去优化快照必须映射 $a$、$n$、当前循环索引 $i$、本次迭代增量前的累加器 $s$ 以及加载的 $x$（即 $\\text{NaN}$），并将解释器的程序计数器设置到该比较点。由于浮点状态标志不可观察，因此无需保留它们。**\n这个选项与我们的分析完全一致。\n- 恢复点（“对应于对当前元素求值 `$(x  0.0) \\lor (x \\ge 0.0)$` 之前的程序点”）是正确的。\n- 去优化快照中所需的状态（`$a$`、`$n$`、`$i$`、`$s$`、`$x$`）是正确且最小化的。\n- 关于无需保留浮点状态标志的澄清也是正确的，根据问题陈述。\n这个选项正确且最小化地指明了保持可观察程序语义的需求。\n**结论：正确。**\n\n**C. 在基线中于函数返回之后恢复执行，并提供最终的 $s$ 值，就好像当前元素贡献了 $0$ 一样；这是等效的，因为剩余迭代的效果可以被推断和折叠，所以重构中间循环状态是不必要的。**\n这是不正确的。去优化发生在计算中途。OSR 是一种*继续*该计算的机制，而不是过早地终止它。剩余迭代（从 `$i+1$` 到 `$n-1$`）的效果不能被“推断和折叠”，因为它们依赖于数组 `$a$` 中的实际值，这些值必须被读取和处理。这个选项描述了一种完全不同且不正确的行为。\n**结论：不正确。**\n\n**D. 在循环头恢复执行，但同时捕获并恢复浮点状态标志，以保留因与 $\\text{NaN}$ 比较而产生的无效操作标志；否则，即使语言不暴露这些标志，IEEE 754 语义也会被违反。**\n这是不正确的，原因有二。首先，它指出必须保留浮点状态标志。如前所述，这并非必需，因为问题明确定义了它们在该语言中是不可观察的。声称 IEEE 754 语义被违反的说法过于绝对；该标准允许标志在某些实现中对用户不可见。其次，在“循环头”恢复执行意味着重新执行数组加载 `$x \\leftarrow a[i]$`，这是不必要的，因为该操作已经成功完成。更精确的恢复点是在加载之后和条件判断之前。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "虽然此练习设定在材料科学的背景下，但它揭示了理解去优化的一个关键原则：适应被违反的假设。我们从一个简化的模型（块状材料）开始，然后必须考虑一个新的、使问题复杂化的现实（纳米颗粒），并重新计算结果。这类似于当一个推测性优化被证明错误时，编译器必须从一个简单的、优化的代码路径切换到一个更通用的代码路径。",
            "id": "36823",
            "problem": "在自蔓延高温合成（SHS）领域，绝热温度（$T_{ad}$）是一个关键参数，它代表了在绝热条件下，强放热反应中产物所能达到的理论最高温度。对于一个通用反应，即元素反应物A和B反应生成化合物C（A + B $\\rightarrow$ C），该温度由能量守恒原理确定：反应物在初始温度（$T_0$）下的焓等于产物在绝热温度下的焓。\n\n使用纳米级反应物可以显著改变SHS过程。纳米颗粒的高表面积与体积比会为系统引入大量的过剩表面焓，这部分能量在反应过程中被释放出来。此外，这种过剩能量会导致诸如反应物熔点降低等现象，这一现象可用吉布斯-汤姆逊效应来描述。这会改变反应路径和总体的能量平衡。\n\n考虑一个化学计量的SHS反应，反应物为半径为$r$的球形纳米颗粒形式的元素固体A，以及块状元素固体反应物B。该反应生成单一的固相化合物C。\n\n**假设：**\n1.  反应物的初始温度为 $T_0$。\n2.  产物C以块状固体形式生成，其比热容 $C_{p,C}$ 为常数。最终的绝热温度不超过C的熔点。\n3.  纳米颗粒反应物A的过剩摩尔焓，记作 $H_{surf,A}$，可以表示为其几何形状和表面性质的函数：\n    $$H_{surf,A} = \\frac{2 \\gamma_{sl,A} V_{m,A}}{r}$$\n    其中 $\\gamma_{sl,A}$ 是反应物A的固-液界面能，$V_{m,A}$ 是其摩尔体积。\n4.  在 $T_0$ 温度下，由其块状组成元素生成产物C的标准摩尔生成焓为 $\\Delta H_{f,C}^0$。反应物A和B均为处于标准态的元素（除了A的纳米尺度特性）。\n\n推导绝热温度增加量 $\\Delta T_{ad} = T_{ad}^* - T_{ad}$ 的表达式，其中 $T_{ad}^*$ 是使用纳米级反应物A时的绝热温度，$T_{ad}$ 是使用块状反应物A进行相同反应时的绝热温度。请用 $r$、$\\gamma_{sl,A}$、$V_{m,A}$ 和 $C_{p,C}$ 表示你的答案。",
            "solution": "对于使用块状A的绝热反应（每生成一摩尔C）的能量守恒：\n反应焓为\n$$\\Delta H_{rxn} = \\Delta H_{f,C}^0 - 0 = \\Delta H_{f,C}^0$$\n这部分焓被释放出来，用于将产物C从 $T_0$ 加热到 $T_{ad}$：\n$$-\\Delta H_{f,C}^0 = C_{p,C}(T_{ad} - T_0) \\quad(1)$$\n\n当使用纳米颗粒A时，会额外释放表面焓 $H_{surf,A}$：\n$$H_{surf,A} = \\frac{2\\gamma_{sl,A}V_{m,A}}{r}$$\n总放热量变为\n$$Q^* = -\\Delta H_{f,C}^0 + H_{surf,A} = -\\Delta H_{f,C}^0 + \\frac{2\\gamma_{sl,A}V_{m,A}}{r}$$\n它将C加热到 $T_{ad}^*$：\n$$Q^* = C_{p,C}(T_{ad}^* - T_0) \\quad(2)$$\n\n将方程(1)从方程(2)中减去：\n$$C_{p,C}(T_{ad}^* - T_0) - C_{p,C}(T_{ad} - T_0) = \\frac{2\\gamma_{sl,A}V_{m,A}}{r}$$\n所以\n$$C_{p,C}(T_{ad}^* - T_{ad}) = \\frac{2\\gamma_{sl,A}V_{m,A}}{r}$$\n因此\n$$\\Delta T_{ad} = T_{ad}^* - T_{ad} = \\frac{2\\gamma_{sl,A}V_{m,A}}{r\\,C_{p,C}}$$",
            "answer": "$$\\boxed{\\frac{2\\gamma_{sl,A}V_{m,A}}{r\\,C_{p,C}}}$$"
        },
        {
            "introduction": "任何动态系统的性能，无论是化学反应还是正在运行的程序，都取决于其底层的环境参数。这个问题探讨了物理性质（密度）如何影响传播速度。通过分析密度、热导率和速度之间的关系，此练习将培养您分析性能依赖关系的直觉，这与 JIT 编译器根据运行时分析数据或硬件特性调整其优化策略的方式有异曲同工之妙。",
            "id": "36888",
            "problem": "自蔓延高温合成（SHS）是一种用于生产先进材料的燃烧技术。SHS 的一个关键参数是燃烧波速 $V$，对于窄反应区，它可以通过 Zeldovich-Frank-Kamenetskii (ZFK) 理论来描述。波速的平方由以下表达式给出：\n$$\nV^2 = C \\frac{\\lambda}{Q} \\exp\\left(-\\frac{E_a}{R T_{ad}}\\right)\n$$\n其中，$C$ 是一个取决于反应动力学和热力学的常数，$\\lambda$ 是反应物压坯的热导率，$Q$ 是单位体积的反应热，$E_a$ 是活化能，$R$ 是普适气体常数，$T_{ad}$ 是绝热燃烧温度。\n\n考虑两个 SHS 系统，系统 1 和系统 2，它们由相同的反应物粉末制备，但具有不同的初始堆积密度。\n- 系统 1 的初始密度为 $\\rho_1$，热导率为 $\\lambda_1$，波速为 $V_1$。\n- 系统 2 的初始密度为 $\\rho_2$，热导率为 $\\lambda_2$，波速为 $V_2$。\n\n做出以下假设：\n1.  两个系统具有相同的反应动力学（相同的 $E_a$）和相同的绝热温度 $T_{ad}$。因此，项 $C \\exp\\left(-\\frac{E_a}{R T_{ad}}\\right)$ 对两个系统是相同的。\n2.  单位体积的反应热 $Q$ 与初始堆积密度 $\\rho$ 成正比。\n3.  粉末压坯的有效热导率 $\\lambda$ 与密度遵循幂律关系：$\\lambda = A \\rho^n$，其中 $A$ 和 $n$ 是材料的特征正常数。\n\n使用 ZFK 模型和所提供的信息，推导出 SHS 波速之比 $\\frac{V_2}{V_1}$ 关于密度 $\\rho_1$、$\\rho_2$ 和指数 $n$ 的符号表达式。",
            "solution": "我们从 Zeldovich–Frank–Kamenetskii 关于波速平方的表达式开始\n$$\nV^2 \\;=\\; C\\,\\frac{\\lambda}{Q}\\,\\exp\\!\\Bigl(-\\frac{E_a}{R\\,T_{ad}}\\Bigr).\n$$\n根据假设，因子\n$$\nD \\;=\\; C\\,\\exp\\!\\Bigl(-\\frac{E_a}{R\\,T_{ad}}\\Bigr)\n$$ \n对于两个系统是相同的，所以我们写作\n$$\nV^2 \\;=\\; D\\,\\frac{\\lambda}{Q}.\n$$\n接下来，引入比例关系\n$$\nQ \\;=\\; B\\,\\rho,\n\\qquad\n\\lambda \\;=\\; A\\,\\rho^n,\n$$\n其中 $A,B,n$ 为常数。因此\n$$\nV^2 \\;=\\; D\\,\\frac{A\\,\\rho^n}{B\\,\\rho}\n\\;=\\;\\frac{D\\,A}{B}\\,\\rho^{\\,n-1}.\n$$\n取平方根得到\n$$\nV \\;=\\;\\sqrt{\\frac{D\\,A}{B}}\\;\\rho^{\\frac{n-1}{2}}.\n$$\n因此，对于系统 1 和 2，\n$$\n\\frac{V_2}{V_1}\n\\;=\\;\n\\frac{\\sqrt{\\frac{D\\,A}{B}}\\;\\rho_2^{\\frac{n-1}{2}}}\n     {\\sqrt{\\frac{D\\,A}{B}}\\;\\rho_1^{\\frac{n-1}{2}}}\n\\;=\\;\\left(\\frac{\\rho_2}{\\rho_1}\\right)^{\\frac{n-1}{2}}.\n$$",
            "answer": "$$\\boxed{\\left(\\frac{\\rho_2}{\\rho_1}\\right)^{\\frac{n-1}{2}}}$$"
        }
    ]
}