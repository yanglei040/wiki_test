{
    "hands_on_practices": [
        {
            "introduction": "有效的程序性能剖析需要在信息收益与性能开销之间取得平衡。在程序的每条边上都放置计数器来追踪执行路径通常会带来无法接受的开销。因此，一个核心挑战是如何选择一个最小化的计数器集合，既能唯一地标识出我们关心的关键路径，又能将性能损耗降至最低。本练习将指导你如何将这个“最优插桩”问题形式化为一个整数线性规划（ILP）模型，从而让你能够动手解决在给定成本下区分一组特定程序路径的实际问题 。",
            "id": "3640258",
            "problem": "考虑一个控制流图 $G=(V,E)$，其入口节点为 $s$，出口节点为 $t$。给定一个无环的、从入口到出口的路径集合 $\\mathcal{P}$。每条边 $e \\in E$ 都有一个非负的插桩开销成本 $w_{e}$，你可以在边 $e$ 上放置一个硬件计数器（由二元决策变量 $y_{e} \\in \\{0,1\\}$ 建模），每当 $e$ 被遍历时，该计数器加 1。对于任何路径 $p \\in \\mathcal{P}$，其计数器签名是沿插桩边的计数器值向量，通过按固定的边顺序连接每条边的计数值得到。假设 $\\mathcal{P}$ 中的每条路径最多遍历任何边一次。\n\n从控制流图和路径剖析的基本定义出发，形式化一个整数线性规划 (ILP) 模型，该模型选择一个边的子集进行插桩，以使 $\\mathcal{P}$ 中所有不同路径的计数器签名都是唯一的，同时最小化总开销 $\\sum_{e \\in E} w_{e} y_{e}$。然后，对于下面的具体实例，求解该 ILP 并以单个实数的形式报告最小总开销。\n\n实例说明：\n- 边和成本：$E=\\{e_{1},e_{2},e_{3},e_{4},e_{5}\\}$，其中 $w_{e_{1}}=2$，$w_{e_{2}}=4$，$w_{e_{3}}=3$，$w_{e_{4}}=1$，$w_{e_{5}}=5$。\n- 路径：$\\mathcal{P}=\\{p_{1},p_{2},p_{3},p_{4}\\}$，其中 $p_{1}=(e_{1},e_{2},e_{5})$，$p_{2}=(e_{1},e_{3},e_{5})$，$p_{3}=(e_{4},e_{2},e_{5})$，以及 $p_{4}=(e_{4},e_{3},e_{5})$。\n\n你的答案必须是最佳插桩的最小总开销值，以单个实数表示。不要包含单位。如果你选择近似计算，请说明为何需要近似，并四舍五入到指定数量的有效数字。否则，请提供精确值。",
            "solution": "在尝试任何解决方案之前，对问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n从问题陈述中逐字提取的已知条件如下：\n- 一个控制流图 $G=(V,E)$，其入口节点为 $s$，出口节点为 $t$。\n- 一个无环的、从入口到出口的路径集合 $\\mathcal{P}$。\n- 每条边 $e \\in E$ 都有一个非负的插桩开销成本 $w_{e}$。\n- 一个二元决策变量 $y_{e} \\in \\{0,1\\}$ 指示是否在边 $e$ 上放置计数器。\n- 对于任何路径 $p \\in \\mathcal{P}$，其计数器签名是沿插桩边的计数器值向量。\n- 假设：$\\mathcal{P}$ 中的每条路径最多遍历任何边一次。\n- 目标：形式化一个整数线性规划 (ILP) 模型，该模型选择一个边的子集进行插桩，以使 $\\mathcal{P}$ 中所有不同路径的计数器签名都是唯一的，同时最小化总开销 $\\sum_{e \\in E} w_{e} y_{e}$。\n- 实例说明：\n  - 边和成本：$E=\\{e_{1},e_{2},e_{3},e_{4},e_{5}\\}$，其中 $w_{e_{1}}=2$，$w_{e_{2}}=4$，$w_{e_{3}}=3$，$w_{e_{4}}=1$，$w_{e_{5}}=5$。\n  - 路径：$\\mathcal{P}=\\{p_{1},p_{2},p_{3},p_{4}\\}$，其中 $p_{1}=(e_{1},e_{2},e_{5})$，$p_{2}=(e_{1},e_{3},e_{5})$，$p_{3}=(e_{4},e_{2},e_{5})$，以及 $p_{4}=(e_{4},e_{3},e_{5})$。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学基础**：该问题在编译器设计领域，特别是在程序剖析方面，是一个成熟的问题。使用 ILP 进行最优插桩位置选择是一种标准且合理的方法。控制流图、路径和插桩成本的概念是该领域的基础。\n- **适定性**：该问题有明确的定义，包括一个具体的目标（最小化总成本）和一组约束（唯一的路径签名）。对于有限的边集和路径集，该问题是一个著名的组合优化问题（集合覆盖问题的一个变体），保证存在最优解。\n- **客观性**：问题以精确、无歧义且客观的语言陈述。\n- **不完整或矛盾的设置**：该问题是自包含的。实例所需的所有数据（边集、成本、路径集）都已提供且不矛盾。路径是简单的（最多遍历任何边一次）这一假设至关重要，并已明确说明。\n\n### 第 3 步：结论和行动\n该问题被认为是**有效的**，因为它具有科学基础、适定、客观且自包含。将提供一个完整的、有理有据的解决方案。\n\n### ILP 公式化\n首先，我们形式化通用的整数线性规划 (ILP) 模型。\n设 $y_e \\in \\{0, 1\\}$ 为每条边 $e \\in E$ 的二元决策变量，其中如果边 $e$ 被插桩了计数器，则 $y_e=1$，否则 $y_e=0$。总插桩开销是所有插桩边的成本之和。目标函数是最小化这个总成本：\n$$\n\\text{Minimize} \\quad Z = \\sum_{e \\in E} w_e y_e\n$$\n主要约束是任意两条不同路径的计数器签名必须是唯一的。设 $p_i$ 和 $p_j$ 是 $\\mathcal{P}$ 中两条不同的路径 ($i \\neq j$)。路径的计数器签名是来自插桩边的计数器读数向量。鉴于每条路径都是简单的（最多遍历一条边一次）的假设，如果 $e \\in p_i$，则插桩边 $e$ 上的计数器将读为 $1$，如果 $e \\notin p_i$，则读为 $0$。\n\n为了使 $p_i$ 和 $p_j$ 的签名不同，必须至少有一条被插桩的边 $e$（即 $y_e = 1$），它在一条路径中而不在另一条路径中。能够区分 $p_i$ 和 $p_j$ 的边集是它们的对称差，记为 $p_i \\Delta p_j = (p_i \\cup p_j) \\setminus (p_i \\cap p_j)$。\n为确保对 $(p_i, p_j)$ 这对路径的可区分性，我们必须从它们的对称差中至少插桩一条边。这可以表示为一个线性不等式：\n$$\n\\sum_{e \\in p_i \\Delta p_j} y_e \\ge 1\n$$\n这个约束必须对 $\\mathcal{P}$ 中每一对不同的路径都成立。\n\n完整的 ILP 模型如下：\n- **决策变量**：对于所有 $e \\in E$，$y_e \\in \\{0, 1\\}$。\n- **目标函数**：最小化 $Z = \\sum_{e \\in E} w_e y_e$。\n- **约束**：对于每一对不同的路径 $(p_i, p_j) \\in \\mathcal{P} \\times \\mathcal{P}$ 且 $i \\neq j$：\n$$\n\\sum_{e \\in p_i \\Delta p_j} y_e \\ge 1\n$$\n\n### 求解具体实例\n现在我们将此模型应用于给定的实例。\n边集为 $E=\\{e_{1},e_{2},e_{3},e_{4},e_{5}\\}$，其成本为 $w_{e_{1}}=2$，$w_{e_{2}}=4$，$w_{e_{3}}=3$，$w_{e_{4}}=1$，$w_{e_{5}}=5$。\n路径集为 $\\mathcal{P}=\\{p_{1},p_{2},p_{3},p_{4}\\}$：\n- $p_{1} = \\{e_{1},e_{2},e_{5}\\}$\n- $p_{2} = \\{e_{1},e_{3},e_{5}\\}$\n- $p_{3} = \\{e_{4},e_{2},e_{5}\\}$\n- $p_{4} = \\{e_{4},e_{3},e_{5}\\}$\n\n需要最小化的目标函数是：\n$$\nZ = 2y_{e_{1}} + 4y_{e_{2}} + 3y_{e_{3}} + y_{e_{4}} + 5y_{e_{5}}\n$$\n我们必须为 $\\mathcal{P}$ 中每一对唯一的路径生成一个约束。共有 $\\binom{4}{2}=6$ 对这样的路径。\n\n1.  **路径对 $(p_1, p_2)$**：\n    $p_1 \\Delta p_2 = (\\{e_1,e_2,e_5\\} \\cup \\{e_1,e_3,e_5\\}) \\setminus (\\{e_1,e_2,e_5\\} \\cap \\{e_1,e_3,e_5\\}) = \\{e_1,e_2,e_3,e_5\\} \\setminus \\{e_1,e_5\\} = \\{e_2,e_3\\}$。\n    约束 (C1): $y_{e_2} + y_{e_3} \\ge 1$。\n\n2.  **路径对 $(p_1, p_3)$**：\n    $p_1 \\Delta p_3 = (\\{e_1,e_2,e_5\\} \\cup \\{e_4,e_2,e_5\\}) \\setminus (\\{e_1,e_2,e_5\\} \\cap \\{e_4,e_2,e_5\\}) = \\{e_1,e_2,e_4,e_5\\} \\setminus \\{e_2,e_5\\} = \\{e_1,e_4\\}$。\n    约束 (C2): $y_{e_1} + y_{e_4} \\ge 1$。\n\n3.  **路径对 $(p_1, p_4)$**：\n    $p_1 \\Delta p_4 = (\\{e_1,e_2,e_5\\} \\cup \\{e_4,e_3,e_5\\}) \\setminus (\\{e_1,e_2,e_5\\} \\cap \\{e_4,e_3,e_5\\}) = \\{e_1,e_2,e_3,e_4,e_5\\} \\setminus \\{e_5\\} = \\{e_1,e_2,e_3,e_4\\}$。\n    约束 (C3): $y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$。\n\n4.  **路径对 $(p_2, p_3)$**：\n    $p_2 \\Delta p_3 = (\\{e_1,e_3,e_5\\} \\cup \\{e_4,e_2,e_5\\}) \\setminus (\\{e_1,e_3,e_5\\} \\cap \\{e_4,e_2,e_5\\}) = \\{e_1,e_2,e_3,e_4,e_5\\} \\setminus \\{e_5\\} = \\{e_1,e_2,e_3,e_4\\}$。\n    约束 (C4): $y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$。（与 C3 相同）。\n\n5.  **路径对 $(p_2, p_4)$**：\n    $p_2 \\Delta p_4 = (\\{e_1,e_3,e_5\\} \\cup \\{e_4,e_3,e_5\\}) \\setminus (\\{e_1,e_3,e_5\\} \\cap \\{e_4,e_3,e_5\\}) = \\{e_1,e_3,e_4,e_5\\} \\setminus \\{e_3,e_5\\} = \\{e_1,e_4\\}$。\n    约束 (C5): $y_{e_1} + y_{e_4} \\ge 1$。（与 C2 相同）。\n\n6.  **路径对 $(p_3, p_4)$**：\n    $p_3 \\Delta p_4 = (\\{e_4,e_2,e_5\\} \\cup \\{e_4,e_3,e_5\\}) \\setminus (\\{e_4,e_2,e_5\\} \\cap \\{e_4,e_3,e_5\\}) = \\{e_2,e_3,e_4,e_5\\} \\setminus \\{e_4,e_5\\} = \\{e_2,e_3\\}$。\n    约束 (C6): $y_{e_2} + y_{e_3} \\ge 1$。（与 C1 相同）。\n\n唯一的约束集是：\n- (C1): $y_{e_2} + y_{e_3} \\ge 1$\n- (C2): $y_{e_1} + y_{e_4} \\ge 1$\n- (C3): $y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$\n\n我们观察到，如果 (C1) 和 (C2) 都被满足，那么它们各自至少有一项为 $1$。例如，设 $e_i \\in \\{e_2, e_3\\}$ 的 $y_{e_i} \\ge 1$ 且 $e_j \\in \\{e_1, e_4\\}$ 的 $y_{e_j} \\ge 1$。那么 (C3) 中的和必须至少为 $1+1=2$（因为变量是非负的），这大于 $1$。因此，约束 (C3) 是冗余的，可以移除。问题简化为：\n$$\n\\text{Minimize} \\quad Z = 2y_{e_{1}} + 4y_{e_{2}} + 3y_{e_{3}} + y_{e_{4}} + 5y_{e_{5}}\n$$\n约束条件：\n$$\ny_{e_2} + y_{e_3} \\ge 1 \\\\\ny_{e_1} + y_{e_4} \\ge 1 \\\\\ny_e \\in \\{0,1\\} \\text{ for } e \\in E\n$$\n目标函数是正数项的和。为了最小化 $Z$，我们应该将尽可能多的 $y_e$ 变量设为 $0$。\n变量 $y_{e_5}$ 没有出现在任何约束中。由于其成本 $w_{e_{5}}=5$ 是正数，我们在任何最优解中都必须设置 $y_{e_5}=0$。\n\n剩下的问题可以分解为两个独立的子问题，因为约束作用于不相交的变量集：\n子问题 1：最小化 $4y_{e_{2}} + 3y_{e_{3}}$，约束条件为 $y_{e_2} + y_{e_3} \\ge 1$。\n- 选项 (a): $y_{e_2}=1, y_{e_3}=0$。成本贡献: $4(1) + 3(0) = 4$。\n- 选项 (b): $y_{e_2}=0, y_{e_3}=1$。成本贡献: $4(0) + 3(1) = 3$。\n- 选项 (c): $y_{e_2}=1, y_{e_3}=1$。成本贡献: $4(1) + 3(1) = 7$。\n该子问题的最小成本为 $3$，通过设置 $y_{e_2}=0$ 和 $y_{e_3}=1$ 实现。\n\n子问题 2：最小化 $2y_{e_{1}} + y_{e_{4}}$，约束条件为 $y_{e_1} + y_{e_4} \\ge 1$。\n- 选项 (a): $y_{e_1}=1, y_{e_4}=0$。成本贡献: $2(1) + 1(0) = 2$。\n- 选项 (b): $y_{e_1}=0, y_{e_4}=1$。成本贡献: $2(0) + 1(1) = 1$。\n- 选项 (c): $y_{e_1}=1, y_{e_4}=1$。成本贡献: $2(1) + 1(1) = 3$。\n该子问题的最小成本为 $1$，通过设置 $y_{e_1}=0$ 和 $y_{e_4}=1$ 实现。\n\n结合子问题的最优解并包括 $y_{e_5}=0$，总体的最优解是：\n$y_{e_1}=0$, $y_{e_2}=0$, $y_{e_3}=1$, $y_{e_4}=1$, $y_{e_5}=0$。\n这意味着我们应该插桩边 $e_3$ 和 $e_4$。\n\n最小总开销是子问题最优解的成本之和：\n$$\nZ_{min} = (4y_{e_{2}} + 3y_{e_{3}}) + (2y_{e_{1}} + y_{e_{4}}) + (5y_{e_{5}})\n$$\n$$\nZ_{min} = (3) + (1) + (0) = 4\n$$\n最小总开销为 $4$。这对应于插桩边 $e_3$（成本 $3$）和 $e_4$（成本 $1$）。\n在插桩了边 $e_3$ 和 $e_4$ 后，签名如下：\n- $p_1$：既不包含 $e_3$ 也不包含 $e_4$。签名：$(0,0)$。\n- $p_2$：包含 $e_3$ 但不包含 $e_4$。签名：$(1,0)$。\n- $p_3$：包含 $e_4$ 但不包含 $e_3$。签名：$(0,1)$。\n- $p_4$：同时包含 $e_3$ 和 $e_4$。签名：$(1,1)$。\n所有四个签名都是唯一的，这证实了解决方案的正确性。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "在确定了插桩位置后，下一个问题是如何利用这些计数器为每条执行路径生成一个唯一的标识符。Ball-Larus 算法通过为控制流图中的边分配权重，并把一条路径上的权重累加作为其唯一 ID，提供了一种优雅的解决方案。通过这个练习 ，你将亲手实现 Ball-Larus 算法，计算边权重和路径 ID，并探索当程序结构发生变化时该算法的稳健性，从而深刻理解路径剖析的核心机制。",
            "id": "3640199",
            "problem": "考虑一个用于无环控制流图 (CFG) 的 Ball–Larus 路径剖析方案，其中唯一的路径标识符是通过计算任意从入口到出口路径上所有边权重的总和得到的。该方案通过为每个节点分配基于从该节点到出口的不同路径数量的边权重，以及在每个分支节点处为出边设定一个固定顺序，来确保路径标识符的唯一性。假设遵循标准的 Ball–Larus 约定，即一个节点的第一条出边权重为 $0$，而后续出边的权重则反映了在固定的出边顺序下，选择前面的出边会跳过的路径的累积数量。\n\n给定以下合成的 CFG，其入口节点为 $S$，出口节点为 $X$：\n- 节点：$S, A, B, C, D, E, F, X$。\n- 有向边：$(S,A)$、$(A,B)$、$(A,C)$、$(B,D)$、$(B,E)$、$(C,F)$、$(D,X)$、$(E,X)$、$(F,X)$。\n- 出边的固定顺序：\n  - 在节点 $A$ 处：首先是 $(A,B)$，然后是 $(A,C)$。\n  - 在节点 $B$ 处：首先是 $(B,D)$，然后是 $(B,E)$。\n  - 所有其他节点只有一条出边。\n\n任务：\n1. 使用 Ball–Larus 路径剖析原理和给定的出边顺序，计算 CFG 中所有边的原始权重 $w(e)$ 以及所有从入口到出口路径的路径标识符。\n2. 现在引入一个拓扑变化，添加一条新的快捷边 $e_{s} = (B,X)$，使得节点 $B$ 有三条出边。在一个简单的修补方案下，该方案保留所有原始边的先前计算的权重，并设置 $w(e_{s}) = 0$。判断这种情况下是否会发生路径标识符冲突。如果发生冲突，请给出两条在该简单分配方案下计算出的标识符相等的不同入口到出口路径。\n3. 使用 Ball–Larus 路径剖析原理，为修改后的 CFG（包括 $e_{s}$）重新计算边权重 $w'(e)$。在节点 $B$ 处使用以下固定顺序：首先是 $(B,D)$，然后是 $(B,E)$，最后是 $(B,X)$。保持节点 $A$ 处的顺序如上所述不变。确认重新计算的权重能够为所有从入口到出口的路径恢复路径标识符的唯一性。\n4. 将重加权成本定义为\n$$\nC \\;=\\; \\sum_{e \\in E_{\\text{orig}}} \\left| w'(e) - w(e) \\right|,\n$$\n其中 $E_{\\text{orig}}$ 是添加 $e_{s}$ 之前原始 CFG 中的边集。计算 $C$ 的值，结果应为一个实数。无需四舍五入。你的最终答案应为一个没有单位的纯数字。\n\n你的最终答案应该只有 $C$ 的值。",
            "solution": "该问题要求在给定的无环控制流图 (CFG) 上逐步应用和分析 Ball–Larus 路径剖析算法。解决方案分为四个部分，对应于问题陈述中的四个任务。\n\nBall–Larus 算法包括两个主要过程：\n1.  一个从出口节点到入口节点的自底向上的过程，为每个节点 $n$ 计算 $\\text{NumPaths}(n)$，即从 $n$ 到出口节点 $X$ 的不同路径的数量。对于一个有后继节点 $s_1, s_2, \\ldots, s_k$ 的节点 $n$，$\\text{NumPaths}(n)$ 由 $\\sum_{i=1}^{k} \\text{NumPaths}(s_i)$ 给出。根据定义，$\\text{NumPaths}(X) = 1$。\n2.  一个从入口节点到出口节点的自顶向下的过程，为每条边 $e = (u,v)$ 分配权重 $w(e)$。在每个具有固定顺序出边 $(u, v_1), (u, v_2), \\ldots, (u, v_k)$ 的节点 $u$ 处，权重分配如下：$w(u, v_1) = 0$ 且当 $i  1$ 时 $w(u, v_i) = \\sum_{j=1}^{i-1} \\text{NumPaths}(v_j)$。\n\n任何从入口到出口路径的路径标识符是构成该路径的边的权重之和。\n\n### 任务1：原始边权重和路径标识符\n\n首先，我们为原始 CFG 中的所有节点 $n$ 计算 $\\text{NumPaths}(n)$。\n-   节点：$S, A, B, C, D, E, F, X$。\n-   出口节点：$X$。\n-   根据定义，$\\text{NumPaths}(X) = 1$。\n-   从 $X$ 开始反向计算：\n    -   $\\text{NumPaths}(D) = \\text{NumPaths}(X) = 1$。\n    -   $\\text{NumPaths}(E) = \\text{NumPaths}(X) = 1$。\n    -   $\\text{NumPaths}(F) = \\text{NumPaths}(X) = 1$。\n    -   $\\text{NumPaths}(C) = \\text{NumPaths}(F) = 1$。\n    -   $\\text{NumPaths}(B) = \\text{NumPaths}(D) + \\text{NumPaths}(E) = 1 + 1 = 2$。\n    -   $\\text{NumPaths}(A) = \\text{NumPaths}(B) + \\text{NumPaths}(C) = 2 + 1 = 3$。\n    -   $\\text{NumPaths}(S) = \\text{NumPaths}(A) = 3$。\n这表明从入口 $S$ 到出口 $X$ 有 $3$ 条唯一的路径。\n\n接下来，我们计算边权重 $w(e)$。\n-   节点 $S$：只有一条出边 $(S,A)$。因此，$w(S,A)=0$。\n-   节点 $A$：出边顺序为 $(A,B), (A,C)$。\n    -   $w(A,B) = 0$ (第一条边)。\n    -   $w(A,C) = \\text{NumPaths}(B) = 2$。\n-   节点 $B$：出边顺序为 $(B,D), (B,E)$。\n    -   $w(B,D) = 0$ (第一条边)。\n    -   $w(B,E) = \\text{NumPaths}(D) = 1$。\n-   节点 $C, D, E, F$ 各只有一条出边，因此它们的权重为 $0$。\n    -   $w(C,F) = 0$, $w(D,X) = 0$, $w(E,X) = 0$, $w(F,X) = 0$。\n\n原始边权重 $w(e)$ 如下：\n$w(S,A)=0$, $w(A,B)=0$, $w(A,C)=2$, $w(B,D)=0$, $w(B,E)=1$, $w(C,F)=0$, $w(D,X)=0$, $w(E,X)=0$, $w(F,X)=0$。\n\n3 条路径的标识符如下：\n1.  路径 $P_1: S \\to A \\to B \\to D \\to X$。路径 ID = $w(S,A) + w(A,B) + w(B,D) + w(D,X) = 0 + 0 + 0 + 0 = 0$。\n2.  路径 $P_2: S \\to A \\to B \\to E \\to X$。路径 ID = $w(S,A) + w(A,B) + w(B,E) + w(E,X) = 0 + 0 + 1 + 0 = 1$。\n3.  路径 $P_3: S \\to A \\to C \\to F \\to X$。路径 ID = $w(S,A) + w(A,C) + w(C,F) + w(F,X) = 0 + 2 + 0 + 0 = 2$。\n路径标识符为 $0, 1, 2$，它们是唯一的。\n\n### 任务2：添加边 $e_s = (B,X)$ 后对简单修补方案的分析\n\n添加一条新边 $e_s=(B,X)$。一个简单的修补方案保留所有原始权重 $w(e)$ 并设置 $w(e_s) = 0$。这引入了一条新路径 $P_4: S \\to A \\to B \\to X$。让我们用这个简单的权重方案计算修改后图中的路径标识符。\n-   ID($P_1: S \\to A \\to B \\to D \\to X$) = $w(S,A) + w(A,B) + w(B,D) + w(D,X) = 0 + 0 + 0 + 0 = 0$。\n-   ID($P_2: S \\to A \\to B \\to E \\to X$) = $w(S,A) + w(A,B) + w(B,E) + w(E,X) = 0 + 0 + 1 + 0 = 1$。\n-   ID($P_3: S \\to A \\to C \\to F \\to X$) = $w(S,A) + w(A,C) + w(C,F) + w(F,X) = 0 + 2 + 0 + 0 = 2$。\n-   ID($P_4: S \\to A \\to B \\to X$) = $w(S,A) + w(A,B) + w(B,X) = 0 + 0 + 0 = 0$。\n\n发生了一次冲突。两条不同的路径具有相同的标识符 $0$：\n-   冲突路径 1: $S \\to A \\to B \\to D \\to X$。\n-   冲突路径 2: $S \\to A \\to B \\to X$。\n\n### 任务3：为修改后的 CFG 重新计算权重\n\n我们在修改后的 CFG 上重新运行 Ball–Larus 算法，该图包含边 $(B,X)$。\n节点 $B$ 处出边的新顺序是 $(B,D), (B,E), (B,X)$。\n\n首先，我们为修改后的图重新计算 $\\text{NumPaths'}(n)$。\n-   $\\text{NumPaths'}(X) = 1$。\n-   $\\text{NumPaths'}(D) = 1$, $\\text{NumPaths'}(E) = 1$, $\\text{NumPaths'}(F) = 1$。\n-   $\\text{NumPaths'}(C) = \\text{NumPaths'}(F) = 1$。\n-   节点 $B$ 现在有后继节点 $D, E, X$。\n    $\\text{NumPaths'}(B) = \\text{NumPaths'}(D) + \\text{NumPaths'}(E) + \\text{NumPaths'}(X) = 1 + 1 + 1 = 3$。\n-   节点 $A$ 有后继节点 $B, C$。\n    $\\text{NumPaths'}(A) = \\text{NumPaths'}(B) + \\text{NumPaths'}(C) = 3 + 1 = 4$。\n-   $\\text{NumPaths'}(S) = \\text{NumPaths'}(A) = 4$。\n现在从 $S$到 $X$ 有 $4$ 条唯一的路径。\n\n接下来，我们重新计算边权重 $w'(e)$。\n-   节点 $S$：只有一条边 $(S,A) \\implies w'(S,A)=0$。\n-   节点 $A$：边为 $(A,B), (A,C)$。\n    -   $w'(A,B) = 0$。\n    -   $w'(A,C) = \\text{NumPaths'}(B) = 3$。\n-   节点 $B$：边为 $(B,D), (B,E), (B,X)$。\n    -   $w'(B,D) = 0$。\n    -   $w'(B,E) = \\text{NumPaths'}(D) = 1$。\n    -   $w'(B,X) = \\text{NumPaths'}(D) + \\text{NumPaths'}(E) = 1 + 1 = 2$。\n-   节点 $C, D, E, F$：各只有一条边 $\\implies$ 权重为 $0$。\n    -   $w'(C,F) = 0$, $w'(D,X) = 0$, $w'(E,X) = 0$, $w'(F,X) = 0$。\n\n4 条路径的新标识符如下：\n1.  路径 $P'_1: S \\to A \\to B \\to D \\to X$。ID = $w'(S,A) + w'(A,B) + w'(B,D) + w'(D,X) = 0+0+0+0 = 0$。\n2.  路径 $P'_2: S \\to A \\to B \\to E \\to X$。ID = $w'(S,A) + w'(A,B) + w'(B,E) + w'(E,X) = 0+0+1+0 = 1$。\n3.  路径 $P'_3: S \\to A \\to B \\to X$。ID = $w'(S,A) + w'(A,B) + w'(B,X) = 0+0+2 = 2$。\n4.  路径 $P'_4: S \\to A \\to C \\to F \\to X$。ID = $w'(S,A) + w'(A,C) + w'(C,F) + w'(F,X) = 0+3+0+0 = 3$。\n路径标识符 $0, 1, 2, 3$ 是唯一的，这证实了重新运行算法可以恢复其正确性。\n\n### 任务4：计算重加权成本 $C$\n\n重加权成本定义为 $C = \\sum_{e \\in E_{\\text{orig}}} | w'(e) - w(e) |$，其中 $E_{\\text{orig}}$ 是原始 CFG 中的边集。我们比较新权重 $w'(e)$ 和原始权重 $w(e)$ 在 9 条原始边上的差异。\n\n-   $e = (S,A)$: $|w'(S,A) - w(S,A)| = |0 - 0| = 0$。\n-   $e = (A,B)$: $|w'(A,B) - w(A,B)| = |0 - 0| = 0$。\n-   $e = (A,C)$: $|w'(A,C) - w(A,C)| = |3 - 2| = 1$。这是因为该边的权重取决于 $\\text{NumPaths'}(B)$，该值从 $2$ 变为 $3$。\n-   $e = (B,D)$: $|w'(B,D) - w(B,D)| = |0 - 0| = 0$。\n-   $e = (B,E)$: $|w'(B,E) - w(B,E)| = |1 - 1| = 0$。其权重取决于 $\\text{NumPaths'}(D)$，该值没有改变。\n-   $e = (C,F)$: $|w'(C,F) - w(C,F)| = |0 - 0| = 0$。\n-   $e = (D,X)$: $|w'(D,X) - w(D,X)| = |0 - 0| = 0$。\n-   $e = (E,X)$: $|w'(E,X) - w(E,X)| = |0 - 0| = 0$。\n-   $e = (F,X)$: $|w'(F,X) - w(F,X)| = |0 - 0| = 0$。\n\n总重加权成本 $C$ 是这些绝对差值的和：\n$$ C = 0 + 0 + 1 + 0 + 0 + 0 + 0 + 0 + 0 = 1 $$\n\n成本为 $1$，这完全是由于边 $(A,C)$ 的权重发生了变化，该边位于节点 $B$ 结构修改的上游。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "我们费心去识别和追踪完整路径的最终目的是什么？路径剖析的真正威力在于它能揭示出边剖析无法发现的、程序中不同分支之间的相关性。本练习  让你直面这一优势，你将分析一组剖析数据，其中路径信息揭示了两个分支之间强烈的互斥关系。你的任务是基于这一发现，选择一种正确且“安全”的编译器优化策略，这不仅能巩固你对路径剖析应用的理解，还能加深你对基于统计数据的优化与程序形式不变性之间关键区别的认识。",
            "id": "3640289",
            "problem": "考虑一个过程的以下控制流图 (CFG)，其中节点是基本块 (BB)，有向边代表可能的控制转移。入口为 $S$，出口为 $W$。\n\n- $S \\rightarrow B_1$。\n- $B_1$ 基于一个谓词 $P$ 进行分支：真分支走向 $B_2$，假分支走向 $B_3$。\n- $B_2$ 和 $B_3$ 是线性代码（例如，调用具有副作用的函数），并且都流入 $B_5$。\n- $B_5$ 基于一个谓词 $Q$ 进行分支：真分支走向 $U$，假分支走向 $V$。\n- $U \\rightarrow W$ 且 $V \\rightarrow W$。\n\n假设给定以下信息。\n\n1) 定义（基本依据）：\n- 控制流图 (CFG) 是一个有向图 $G=(V,E)$，其中顶点 $V$ 是基本块，边 $E$ 是可能的控制流转移；一次执行对应于 $G$ 中的一条路径。\n- 边分析 (EP) 记录每条边 $e \\in E$ 被遍历的次数。它捕获单个边的边际频率。\n- 路径分析 (PP) 记录在 $G$ 的指定区域内，每条无环路径 $\\pi$ 被执行的次数。它捕获边序列的联合频率，并能揭示仅靠 EP 无法发现的分支结果之间的相关性。\n- 如果一个变换对于所有程序输入都保留了可观察语义，那么它是安全的；当使用分析数据时，可以通过守卫式版本化来保证安全性：仅当一个运行时守卫确保语义等价时，才沿着预测的热路径执行一个特化版本，否则回退到原始版本。\n\n2) 在代表性工作负载上测得的分析数据：\n- $B_1$ 处的边分析计数：真分支被执行 $600$ 次，假分支被执行 $400$ 次。\n- $B_5$ 处的边分析计数：真分支被执行 $400$ 次，假分支被执行 $600$ 次。\n- 路径分析识别出两条频繁执行的无环路径及其计数：\n  - $p^* = \\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{false}}, V, W \\rangle$ 执行了 $600$ 次。\n  - $p' = \\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{true}}, U, W \\rangle$ 执行了 $400$ 次。\n  - 两个互补的组合 $\\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{true}}, U, W \\rangle$ 和 $\\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{false}}, V, W \\rangle$ 被观察到 $0$ 次。\n\n直观上，路径分析揭示了在观察到的执行中，$B_1$ 和 $B_5$ 处的结果之间存在强烈的互斥相关性：沿着热路径 $p^*$，每当上游的 $P$ 为真时，随后的 $Q$ 在 $B_5$ 处为假。仅靠边计数无法揭示这种相关性，因为它们只独立地为 $B_1$ 和 $B_5$ 提供边际频率。\n\n你的目标是利用这些信息，在热路径 $p^*$ 上移除 $B_5$ 处的动态检查，同时为所有输入保留正确性。\n\n以下哪种编译器变换是安全的，并且利用路径分析信息移除了 $p^*$ 路径上 $B_5$ 处的冗余检查？\n\nA. 仅使用边分析来推断 $B_1^{\\text{true}}$ 意味着 $B_5^{\\text{false}}$，并且当直接前驱是 $B_2$ 时，将 $B_5$ 处的分支替换为到 $V$ 的无条件跳转。\n\nB. 将构成 $p^*$ 的区域克隆成一个从 $B_1^{\\text{true}}$ 进入的特化追踪版本 $T^*$。在 $T^*$ 的头部插入一个运行时守卫，该守卫评估 $Q$ 并检查 $Q=\\text{false}$；如果守卫通过，则绕过 $B_5$ 直接跳转到 $V$（在 $T^*$ 中删除 $Q$ 测试），否则分支到原始代码。保持原始 CFG 完整作为回退。\n\nC. 从路径分析中，推断出不变量 $Q \\equiv \\lnot P$，并通过相应地对后继进行常量折叠来全局消除 $B_1$ 和 $B_5$ 处的两个分支。\n\nD. 重排基本块，将 $B_2 \\rightarrow B_5 \\rightarrow V$ 放置在内存中连续的位置（布局优化），但保持所有分支不变。\n\n选择正确的选项。",
            "solution": "用户希望我验证并解决一个关于编译器优化的问题，特别是对比边分析和路径分析如何实现一个安全的变换。\n\n### 步骤 1：提取已知条件\n\n- **控制流图 (CFG) 结构：**\n  - 一个有向图，入口为 $S$，出口为 $W$。\n  - $S \\rightarrow B_1$。\n  - $B_1$ 是关于谓词 $P$ 的条件分支。真分支为 $B_1 \\rightarrow B_2$，假分支为 $B_1 \\rightarrow B_3$。\n  - $B_2 \\rightarrow B_5$ 且 $B_3 \\rightarrow B_5$。\n  - $B_5$ 是关于谓词 $Q$ 的条件分支。真分支为 $B_5 \\rightarrow U$，假分支为 $B_5 \\rightarrow V$。\n  - $U \\rightarrow W$ 且 $V \\rightarrow W$。\n\n- **定义：**\n  - **边分析 (EP)：** 记录每条边 $e$ 的遍历次数。\n  - **路径分析 (PP)：** 记录每条无环路径 $\\pi$ 的执行次数。它可以揭示 EP 无法揭示的相关性。\n  - **安全变换：** 一种对所有程序输入都保留可观察语义的变换。对于分析数据，可以通过“守卫式版本化”来保证安全性，即使用运行时守卫在执行特化的优化代码版本前检查条件，并提供回退到原始未优化代码的机制。\n\n- **分析数据：**\n  - $B_1$ 处的 EP：$B_1 \\xrightarrow{\\text{true}} B_2$ 执行 600 次。$B_1 \\xrightarrow{\\text{false}} B_3$ 执行 400 次。\n  - $B_5$ 处的 EP：$B_5 \\xrightarrow{\\text{true}} U$ 执行 400 次。$B_5 \\xrightarrow{\\text{false}} V$ 执行 600 次。\n  - PP 数据：\n    - 路径 $p^* = \\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{false}}, V, W \\rangle$ 执行 600 次。\n    - 路径 $p' = \\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{true}}, U, W \\rangle$ 执行 400 次。\n    - 路径 $\\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{true}}, U, W \\rangle$ 执行 0 次。\n    - 路径 $\\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{false}}, V, W \\rangle$ 执行 0 次。\n\n- **目标：**\n  - 利用路径分析数据，在热路径 $p^*$ 上移除对谓词 $Q$ 在 $B_5$ 处的动态检查，同时确保变换是安全的。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据：** 该问题牢固地基于编译器设计的既定原则，特别是基于分析的优化、控制流分析和代码变换技术，如轨迹特化。边分析、路径分析和安全性的概念是该领域的核心。该问题在科学上是合理的。\n- **适定性：** CFG 的定义是明确的。分析数据是明确且内部一致的。例如，$B_1$ 的总流量为 $600+400=1000$。$B_5$ 的总流量也为 $600+400=1000$。路径计数总和等于总执行次数（$600+400+0+0=1000$），并且与边计数一致（例如，边 $B_1 \\rightarrow B_2$ 的计数为 600，与以 $B_1^{\\text{true}}$ 开头的路径总和 $600+0=600$ 相匹配）。目标清晰具体。\n- **客观性：** 问题使用计算机科学中精确的技术术语陈述。没有主观或含糊的陈述。\n- **缺陷清单：**\n  1. **科学/事实不合理：** 无。\n  2. **不可形式化/不相关：** 无。这是一个经典的、可形式化的编译器优化问题。\n  3. **不完整/矛盾的设置：** 无。数据是完整且一致的。\n  4. **不切实际/不可行：** 无。相关的分支在程序中很常见，所描述的优化技术是现实的。\n  5. **不适定/结构不良：** 无。问题结构良好。\n  6. **伪深奥/琐碎：** 无。该问题需要理解边分析和路径分析之间的关键区别以及优化中的安全性概念。\n  7. **超出科学可验证性：** 无。\n\n### 步骤 3：结论与行动\n\n问题陈述是有效的。这是一个在编译器原理领域中形式良好、一致且有科学依据的问题。我现在将进行解题推导和选项分析。\n\n### 解题推导\n\n问题的核心在于边分析与路径分析所能推断出的信息之间的区别，以及如何利用这些信息来执行一次*安全*的优化。\n\n1.  **来自分析的信息：**\n    - 边分析显示，$B_1$ 处的分支以概率（真：0.6，假：0.4）执行，$B_5$ 处的分支以概率（真：0.4，假：0.6）执行。如果这些分支是独立的，我们期望路径 $B_1^{\\text{true}} \\to \\dots \\to B_5^{\\text{false}}$ 被执行 $1000 \\times 0.6 \\times 0.6 = 360$ 次。\n    - 路径分析揭示了强相关性。路径 $p^* = \\langle S, B_1^{\\text{true}}, \\dots, B_5^{\\text{false}}, \\dots \\rangle$ 被执行了 600 次，而路径 $\\langle S, B_1^{\\text{true}}, \\dots, B_5^{\\text{true}}, \\dots \\rangle$ 被执行了 0 次。这表明对于观察到的工作负载，每当 $P$ 为真时，$Q$ 就为假。\n\n2.  **安全性约束：**\n    一个关键的约束是，任何变换都必须是*安全*的，这意味着它必须对*所有可能的输入*都正确，而不仅仅是分析运行中的那些。一个分析结果，无论多么强，都只是一个统计观察，而不是程序不变量的形式证明。我们不能断定 $Q \\equiv \\lnot P$ 对于所有执行都成立。可能存在一种执行路径，在分析期间未遇到，其中 $P$ 为真且 $Q$ 也为真。一个安全的优化必须正确处理这种情况。\n\n3.  **目标：**\n    目标是在热路径 $p^*$ 上消除在 $B_5$ 处对 $Q$ 的检查。该路径是在 $P$ 求值为真后进入的。\n\n4.  **机制（守卫式版本化）：**\n    问题陈述本身定义了正确的机制：“守卫式版本化”。这涉及到为预测的（热）路径创建一个特化的、更快的代码版本，并使用一个运行时检查（守卫）来确保进入此特化路径的条件得到满足。如果守卫失败，控制权将转移到原始的、未优化的代码（回退）。\n\n    将此应用于我们的问题：\n    - 当 $P$ 为真时，进入热路径。\n    - 在此路径上，我们预测 $Q$ 将为假。\n    - 因此，我们可以创建一个特化的代码序列，该序列执行 $B_2$ 的主体，然后无条件跳转到 $V$，完全绕过在 $B_5$ 处对 $Q$ 的测试。\n    - 为了保持安全性，我们必须引入一个守卫。在提交到此特化路径之前，我们必须验证我们的预测是否成立。守卫必须检查 $Q$ 是否确实为假。\n    - $B_1$ 之后的新控制流将如下所示：如果 $P$ 为真，则跳转到一个新块，即守卫。\n    - 守卫块检查 $Q$ 是否为假。\n        - 如果`真`（$Q$ 为假），则执行特化路径（$B_2$ 的代码，然后跳转到 $V$）。\n        - 如果`假`（$Q$ 为真），这是未预测到的情况。我们通过跳转到 $B_2$ 来回退到原始代码路径，然后它将继续到 $B_5$，正确地将 $Q$ 求值为真，并跳转到 $U$。\n\n这种结构实现了目标：在频繁执行的路径上（其中 $P$ 为真且 $Q$ 为假），$B_5$ 处的检查被消除了。对于罕见（或未观察到）的情况（其中 $P$ 为真且 $Q$ 也为真），正确性得以保持。\n\n### 逐项分析\n\n**A. 仅使用边分析来推断 $B_1^{\\text{true}}$ 意味着 $B_5^{\\text{false}}$，并且当直接前驱是 $B_2$ 时，将 $B_5$ 处的分支替换为到 $V$ 的无条件跳转。**\n\n- “仅使用边分析”这个前提是错误的。如前所述，仅靠边分析不足以检测 $B_1$ 和 $B_5$ 处分支之间的相关性。此信息来自路径分析。\n- “将 $B_5$ 处的分支替换为无条件跳转”这种变换是**不安全**的。它基于从统计样本（“分析数据”）中得出的推断，但将其应用得好像它是一个已证明的不变量。如果存在任何输入，使得控制流经 $B_2$ 到 $B_5$ 且谓词 $Q$ 求值为真，则此变换将导致程序错误地执行，跳转到 $V$ 而不是 $U$。\n- **结论：错误。**\n\n**B. 将构成 $p^*$ 的区域克隆成一个从 $B_1^{\\text{true}}$ 进入的特化追踪版本 $T^*$。在 $T^*$ 的头部插入一个运行时守卫，该守卫评估 $Q$ 并检查 $Q=\\text{false}$；如果守卫通过，则绕过 $B_5$ 直接跳转到 $V$（在 $T^*$ 中删除 $Q$ 测试），否则分支到原始代码。保持原始 CFG 完整作为回退。**\n\n- 这个选项（隐式地，通过引用路径 $p^*$）正确地将路径分析确定为信息来源。\n- 它描述了标准的“守卫式版本化”技术。\n  - “将区域克lone……成一个特化的追踪版本 $T^*$”：这是创建优化路径。\n  - “插入……一个运行时守卫，该守卫评估 $Q$ 并检查 $Q=\\text{false}$”：这是确保优化条件在运行时成立的关键检查。\n  - “如果守卫通过，则绕过 $B_5$ 直接跳转到 $V$（在 $T^*$ 中删除 $Q$ 测试）”：这是移除了冗余检查的优化执行路径。\n  - “否则分支到原始代码”：这是保证未预测情况下安全性的回退机制。\n- 这种变换是**安全**的，并直接实现了在热路径上移除 $B_5$ 处检查的既定目标。尽管将 $Q$ 的求值提升到 $B_2$ 之前可能存在实际的复杂性，但所描述的逻辑结构是针对此类基于分析的优化的正确和标准方法。\n- **结论：正确。**\n\n**C. 从路径分析中，推断出不变量 $Q \\equiv \\lnot P$，并通过相应地对后继进行常量折叠来全局消除 $B_1$ 和 $B_5$ 处的两个分支。**\n\n- 在编译器正确性的背景下，关键短语“推断出不变量 $Q \\equiv \\lnot P$”是一个逻辑谬误。分析数据表明了相关性；它并没有证明一个普遍为真的不变量。做出这个假设是不安全的主要来源。\n- 提议的变换“全局消除两个分支”将改变任何违反假定不变量的输入的程序行为。例如，如果存在一个输入使得 $P$ 和 $Q$ 都为真，原始程序将遵循到 $U$ 的路径。而变换后的程序，由于假设了 $P \\implies \\lnot Q$，将错误地强制路径走向 $V$。这是一种**不安全**的变换。\n- **结论：错误。**\n\n**D. 重排基本块，将 $B_2 \\rightarrow B_5 \\rightarrow V$ 放置在内存中连续的位置（布局优化），但保持所有分支不变。**\n\n- 这描述了一种代码布局优化。这种优化使用分析来识别热路径（$B_2 \\rightarrow B_5 \\rightarrow V$ 是热路径 $p^*$ 的一部分），并将它们在内存中顺序排列，以提高指令缓存局部性并可能减少分支惩罚。\n- 然而，该选项明确指出“保持所有分支不变”。\n- 问题的目标是“**移除 $B_5$ 处的动态检查**”。此变换不移除任何检查或分支。虽然它是一种利用分析信息的有效优化，但它没有解决问题的具体目标。\n- **结论：错误。**",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}