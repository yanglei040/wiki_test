{
    "hands_on_practices": [
        {
            "introduction": "To truly understand path profiling, we must start with the mechanics of how a unique identifier can be assigned to every possible execution path. This exercise takes you through the nuts and bolts of the classic Ball-Larus algorithm, a cornerstone of path profiling. By calculating edge weights and path IDs for a given control-flow graph, you will gain a concrete understanding of the process. More importantly, the exercise explores what happens when the program's structure changes, demonstrating why a naive approach fails and how a full re-analysis restores the uniqueness of path identifiers, a crucial property for the algorithm's correctness .",
            "id": "3640199",
            "problem": "Consider the Ball-Larus path profiling scheme for an acyclic Control Flow Graph (CFG), where a unique path identifier is computed as the sum of edge weights along any entry-to-exit path. The scheme ensures uniqueness by assigning edge weights based on the number of distinct paths from each node to the exit and a fixed order of outgoing edges at each branching node. Assume the standard Ball-Larus convention that the first outgoing edge of a node receives weight $0$, and subsequent weights reflect the cumulative number of paths that would be skipped by taking earlier outgoing edges, under a fixed out-edge order.\n\nYou are given the following synthetic CFG with entry node $S$ and exit node $X$:\n- Nodes: $S, A, B, C, D, E, F, X$.\n- Directed edges: $(S,A)$, $(A,B)$, $(A,C)$, $(B,D)$, $(B,E)$, $(C,F)$, $(D,X)$, $(E,X)$, $(F,X)$.\n- Fixed ordering of outgoing edges:\n  - At node $A$: first $(A,B)$, then $(A,C)$.\n  - At node $B$: first $(B,D)$, then $(B,E)$.\n  - All other nodes have a single outgoing edge.\n\nTasks:\n1. Using the Ball-Larus path profiling principles and the given out-edge orders, compute the original edge weights $w(e)$ for all edges in the CFG and the resulting path identifiers for all entry-to-exit paths.\n2. Now introduce a topological change by adding a new shortcut edge $e_{s} = (B,X)$, making node $B$ have three outgoing edges. Under a naive patch that preserves the previously computed weights on all original edges and sets $w(e_{s}) = 0$, determine whether path identifier collisions occur. If collisions occur, exhibit two distinct entry-to-exit paths whose computed identifiers are equal under this naive assignment.\n3. Recompute the edge weights $w'(e)$ for the modified CFG (including $e_{s}$) using the Ball-Larus path profiling principles with the following fixed ordering at node $B$: first $(B,D)$, then $(B,E)$, then $(B,X)$. Keep the ordering at node $A$ unchanged as specified above. Confirm that the recomputed weights restore uniqueness of path identifiers for all entry-to-exit paths.\n4. Define the reweighting cost as\n$$\nC \\;=\\; \\sum_{e \\in E_{\\text{orig}}} \\left| w'(e) - w(e) \\right|,\n$$\nwhere $E_{\\text{orig}}$ is the set of edges in the original CFG before adding $e_{s}$. Compute $C$ as a single real-valued number. No rounding is necessary. Express your final answer as a pure number with no units.\n\nYour final answer should be the value of $C$ only.",
            "solution": "The problem requires a step-by-step application and analysis of the Ball-Larus path profiling algorithm on a given acyclic Control Flow Graph (CFG). The solution is structured into four parts, corresponding to the four tasks in the problem statement.\n\nThe Ball-Larus algorithm consists of two main passes:\n1.  A bottom-up pass from the exit node to the entry node to compute `NumPaths(n)` for each node $n$, which is the number of distinct paths from $n$ to the exit node $X$. For a node $n$ with successors $s_1, s_2, \\ldots, s_k$, `NumPaths(n)` is given by $\\sum_{i=1}^{k} \\text{NumPaths}(s_i)$. By definition, $\\text{NumPaths}(X) = 1$.\n2.  A top-down pass from the entry node to the exit node to assign a weight $w(e)$ to each edge $e = (u,v)$. At each node $u$ with outgoing edges $(u, v_1), (u, v_2), \\ldots, (u, v_k)$ in a fixed order, the weights are assigned as $w(u, v_1) = 0$ and $w(u, v_i) = \\sum_{j=1}^{i-1} \\text{NumPaths}(v_j)$ for $i > 1$.\n\nThe path identifier for any entry-to-exit path is the sum of the weights of the edges constituting that path.\n\n### Task 1: Original Edge Weights and Path Identifiers\n\nFirst, we compute `NumPaths(n)` for all nodes $n$ in the original CFG.\n-   Nodes: $S, A, B, C, D, E, F, X$.\n-   Exit node: $X$.\n-   By definition, $\\text{NumPaths}(X) = 1$.\n-   Working backwards from $X$:\n    -   $\\text{NumPaths}(D) = \\text{NumPaths}(X) = 1$.\n    -   $\\text{NumPaths}(E) = \\text{NumPaths}(X) = 1$.\n    -   $\\text{NumPaths}(F) = \\text{NumPaths}(X) = 1$.\n    -   $\\text{NumPaths}(C) = \\text{NumPaths}(F) = 1$.\n    -   $\\text{NumPaths}(B) = \\text{NumPaths}(D) + \\text{NumPaths}(E) = 1 + 1 = 2$.\n    -   $\\text{NumPaths}(A) = \\text{NumPaths}(B) + \\text{NumPaths}(C) = 2 + 1 = 3$.\n    -   $\\text{NumPaths}(S) = \\text{NumPaths}(A) = 3$.\nThis indicates there are $3$ unique paths from entry $S$ to exit $X$.\n\nNext, we compute the edge weights $w(e)$.\n-   Node $S$: Single outgoing edge $(S,A)$. Thus, $w(S,A)=0$.\n-   Node $A$: Outgoing edges ordered as $(A,B), (A,C)$.\n    -   $w(A,B) = 0$ (first edge).\n    -   $w(A,C) = \\text{NumPaths}(B) = 2$.\n-   Node $B$: Outgoing edges ordered as $(B,D), (B,E)$.\n    -   $w(B,D) = 0$ (first edge).\n    -   $w(B,E) = \\text{NumPaths}(D) = 1$.\n-   Nodes $C, D, E, F$ each have a single outgoing edge, so their weights are $0$.\n    -   $w(C,F) = 0$, $w(D,X) = 0$, $w(E,X) = 0$, $w(F,X) = 0$.\n\nThe original edge weights $w(e)$ are:\n$w(S,A)=0$, $w(A,B)=0$, $w(A,C)=2$, $w(B,D)=0$, $w(B,E)=1$, $w(C,F)=0$, $w(D,X)=0$, $w(E,X)=0$, $w(F,X)=0$.\n\nThe identifiers for the $3$ paths are:\n1.  Path $P_1: S \\to A \\to B \\to D \\to X$. Path ID = $w(S,A) + w(A,B) + w(B,D) + w(D,X) = 0 + 0 + 0 + 0 = 0$.\n2.  Path $P_2: S \\to A \\to B \\to E \\to X$. Path ID = $w(S,A) + w(A,B) + w(B,E) + w(E,X) = 0 + 0 + 1 + 0 = 1$.\n3.  Path $P_3: S \\to A \\to C \\to F \\to X$. Path ID = $w(S,A) + w(A,C) + w(C,F) + w(F,X) = 0 + 2 + 0 + 0 = 2$.\nThe path identifiers are $0, 1, 2$, which are unique.\n\n### Task 2: Analysis of the Naive Patch After Adding Edge $e_s = (B,X)$\n\nA new edge $e_s=(B,X)$ is added. A naive patch keeps all original weights $w(e)$ and sets $w(e_s) = 0$. This introduces a new path $P_4: S \\to A \\to B \\to X$. Let's compute the path identifiers in this modified graph with the naive weights.\n-   ID($P_1: S \\to A \\to B \\to D \\to X$) = $w(S,A) + w(A,B) + w(B,D) + w(D,X) = 0 + 0 + 0 + 0 = 0$.\n-   ID($P_2: S \\to A \\to B \\to E \\to X$) = $w(S,A) + w(A,B) + w(B,E) + w(E,X) = 0 + 0 + 1 + 0 = 1$.\n-   ID($P_3: S \\to A \\to C \\to F \\to X$) = $w(S,A) + w(A,C) + w(C,F) + w(F,X) = 0 + 2 + 0 + 0 = 2$.\n-   ID($P_4: S \\to A \\to B \\to X$) = $w(S,A) + w(A,B) + w(B,X) = 0 + 0 + 0 = 0$.\n\nA collision occurs. Two distinct paths have the same identifier $0$:\n-   Colliding Path 1: $S \\to A \\to B \\to D \\to X$.\n-   Colliding Path 2: $S \\to A \\to B \\to X$.\n\n### Task 3: Recomputation of Weights for the Modified CFG\n\nWe re-run the Ball-Larus algorithm on the modified CFG, which includes edge $(B,X)$.\nThe new ordering for outgoing edges at $B$ is $(B,D), (B,E), (B,X)$.\n\nFirst, we recompute `NumPaths'(n)` for the modified graph.\n-   $\\text{NumPaths'}(X) = 1$.\n-   $\\text{NumPaths'}(D) = 1$, $\\text{NumPaths'}(E) = 1$, $\\text{NumPaths'}(F) = 1$.\n-   $\\text{NumPaths'}(C) = \\text{NumPaths'}(F) = 1$.\n-   Node $B$ now has successors $D, E, X$.\n    $\\text{NumPaths'}(B) = \\text{NumPaths'}(D) + \\text{NumPaths'}(E) + \\text{NumPaths'}(X) = 1 + 1 + 1 = 3$.\n-   Node $A$ has successors $B, C$.\n    $\\text{NumPaths'}(A) = \\text{NumPaths'}(B) + \\text{NumPaths'}(C) = 3 + 1 = 4$.\n-   $\\text{NumPaths'}(S) = \\text{NumPaths'}(A) = 4$.\nThere are now $4$ unique paths from $S$ to $X$.\n\nNext, we recompute the edge weights $w'(e)$.\n-   Node $S$: Single edge $(S,A) \\implies w'(S,A)=0$.\n-   Node $A$: Edges $(A,B), (A,C)$.\n    -   $w'(A,B) = 0$.\n    -   $w'(A,C) = \\text{NumPaths'}(B) = 3$.\n-   Node $B$: Edges $(B,D), (B,E), (B,X)$.\n    -   $w'(B,D) = 0$.\n    -   $w'(B,E) = \\text{NumPaths'}(D) = 1$.\n    -   $w'(B,X) = \\text{NumPaths'}(D) + \\text{NumPaths'}(E) = 1 + 1 = 2$.\n-   Nodes $C, D, E, F$: Single edge each $\\implies$ weights are $0$.\n    -   $w'(C,F) = 0$, $w'(D,X) = 0$, $w'(E,X) = 0$, $w'(F,X) = 0$.\n\nThe new identifiers for the $4$ paths are:\n1.  Path $P'_1: S \\to A \\to B \\to D \\to X$. ID = $w'(S,A) + w'(A,B) + w'(B,D) + w'(D,X) = 0+0+0+0 = 0$.\n2.  Path $P'_2: S \\to A \\to B \\to E \\to X$. ID = $w'(S,A) + w'(A,B) + w'(B,E) + w'(E,X) = 0+0+1+0 = 1$.\n3.  Path $P'_3: S \\to A \\to B \\to X$. ID = $w'(S,A) + w'(A,B) + w'(B,X) = 0+0+2 = 2$.\n4.  Path $P'_4: S \\to A \\to C \\to F \\to X$. ID = $w'(S,A) + w'(A,C) + w'(C,F) + w'(F,X) = 0+3+0+0 = 3$.\nThe path identifiers $0, 1, 2, 3$ are unique, confirming that re-running the algorithm restores correctness.\n\n### Task 4: Calculation of the Reweighting Cost $C$\n\nThe reweighting cost is defined as $C = \\sum_{e \\in E_{\\text{orig}}} | w'(e) - w(e) |$, where $E_{\\text{orig}}$ is the set of edges in the original CFG. We compare the new weights $w'(e)$ with the original weights $w(e)$ for each of the $9$ original edges.\n\n-   $e = (S,A)$: $|w'(S,A) - w(S,A)| = |0 - 0| = 0$.\n-   $e = (A,B)$: $|w'(A,B) - w(A,B)| = |0 - 0| = 0$.\n-   $e = (A,C)$: $|w'(A,C) - w(A,C)| = |3 - 2| = 1$. This is because the weight of this edge depends on $\\text{NumPaths}(B)$, which changed from $2$ to $3$.\n-   $e = (B,D)$: $|w'(B,D) - w(B,D)| = |0 - 0| = 0$.\n-   $e = (B,E)$: $|w'(B,E) - w(B,E)| = |1 - 1| = 0$. The weight depends on $\\text{NumPaths}(D)$, which did not change.\n-   $e = (C,F)$: $|w'(C,F) - w(C,F)| = |0 - 0| = 0$.\n-   $e = (D,X)$: $|w'(D,X) - w(D,X)| = |0 - 0| = 0$.\n-   $e = (E,X)$: $|w'(E,X) - w(E,X)| = |0 - 0| = 0$.\n-   $e = (F,X)$: $|w'(F,X) - w(F,X)| = |0 - 0| = 0$.\n\nThe total reweighting cost $C$ is the sum of these absolute differences:\n$$ C = 0 + 0 + 1 + 0 + 0 + 0 + 0 + 0 + 0 = 1 $$\n\nThe cost is $1$, solely due to the change in weight of edge $(A,C)$, which is upstream of the structural modification at node $B$.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "Beyond the mechanics, the true power of path profiling lies in the rich information it provides compared to simpler methods like edge profiling. This practice shifts our focus from \"how\" to \"why,\" presenting a scenario where path data reveals a crucial correlation between two separate branches that edge counts alone would miss. Your task is to use this insight to select a *sound* compiler optimizationâ€”one that is correct for all possible program inputs, not just the ones observed during profiling. This exercise underscores the difference between statistical observation and formal proof, highlighting the need for techniques like guarded versioning to safely apply profile-guided optimizations .",
            "id": "3640289",
            "problem": "Consider the following Control Flow Graph (CFG) for a procedure, where nodes are Basic Blocks (BB) and directed edges represent possible control transfers. The entry is $S$ and the exit is $W$.\n\n- $S \\rightarrow B_1$.\n- $B_1$ branches on a predicate $P$: the true edge goes to $B_2$ and the false edge goes to $B_3$.\n- $B_2$ and $B_3$ are straight-line code (e.g., calls to side-effecting functions) and both flow into $B_5$.\n- $B_5$ branches on a predicate $Q$: the true edge goes to $U$ and the false edge goes to $V$.\n- $U \\rightarrow W$ and $V \\rightarrow W$.\n\nAssume the following are given.\n\n1) Definitions (fundamental base):\n- A Control Flow Graph (CFG) is a directed graph $G=(V,E)$ with vertices $V$ as basic blocks and edges $E$ as possible control-flow transfers; an execution corresponds to a path in $G$.\n- Edge profiling (EP) records, for each edge $e \\in E$, the number of times $e$ is traversed. It captures marginal frequencies of individual edges.\n- Path profiling (PP) records, for each acyclic path $\\pi$ in a designated region of $G$, the number of times $\\pi$ is executed. It captures joint frequencies for sequences of edges and can reveal correlations between branch outcomes that EP alone cannot.\n- A transformation is sound if for all program inputs it preserves the observable semantics; when using profiling, soundness can be preserved by guarded versioning: execute a specialized version along a predicted-hot path only under a run-time guard that ensures semantic equivalence, and otherwise fall back to the original.\n\n2) Measured profiling data over a representative workload:\n- Edge profiling counts at $B_1$: the true edge is taken $600$ times and the false edge is taken $400$ times.\n- Edge profiling counts at $B_5$: the true edge is taken $400$ times and the false edge is taken $600$ times.\n- Path profiling identifies two frequently executed acyclic paths and their counts:\n  - $p^* = \\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{false}}, V, W \\rangle$ executed $600$ times.\n  - $p' = \\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{true}}, U, W \\rangle$ executed $400$ times.\n  - The two complementary combinations $\\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{true}}, U, W \\rangle$ and $\\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{false}}, V, W \\rangle$ are observed $0$ times.\n\nIntuitively, the path profiling reveals a strong mutual exclusivity correlation between the outcomes at $B_1$ and $B_5$ in the observed executions: along the hot path $p^*$, whenever $P$ is true upstream, $Q$ is subsequently false at $B_5$. Edge counts alone do not expose this correlation because they provide only marginal frequencies for $B_1$ and $B_5$ independently.\n\nYour goal is to exploit this information to remove the dynamic check at $B_5$ on the hot path $p^*$ while preserving correctness for all inputs.\n\nWhich of the following compiler transformations is sound and uses the path profiling information to remove the redundant check at $B_5$ along $p^*$?\n\nA. Use only edge profiling to infer that $B_1^{\\text{true}}$ implies $B_5^{\\text{false}}$, and replace the branch at $B_5$ with an unconditional jump to $V$ whenever the immediate predecessor is $B_2$.\n\nB. Clone the region forming $p^*$ into a specialized trace version $T^*$ entered from $B_1^{\\text{true}}$. Insert at the head of $T^*$ a run-time guard that evaluates $Q$ and checks $Q=\\text{false}$; if the guard passes, bypass $B_5$ and jump directly to $V$ (deleting the $Q$ test in $T^*$), otherwise branch to the original code. Keep the original CFG intact as a fallback.\n\nC. From the path profiling, infer the invariant $Q \\equiv \\lnot P$ and eliminate both branches at $B_1$ and $B_5$ globally by constant-folding successors accordingly.\n\nD. Reorder basic blocks to place $B_2 \\rightarrow B_5 \\rightarrow V$ contiguously in memory (layout optimization), but leave all branches in place unchanged.\n\nSelect the correct option(s).",
            "solution": "The problem asks for a *sound* compiler transformation that uses path profiling data to optimize a hot path. The key is to distinguish between a statistical observation from profiling and a proven program invariant.\n\n### 1. Analyze Profiling Data\nThe path profiling data reveals a strong correlation: for the 1000 test runs, every time the branch on predicate $P$ at $B_1$ was `true` (600 times), the branch on predicate $Q$ at $B_5$ was `false`. The edge profiles alone do not show this; they only give marginal frequencies. This suggests that along the path through $B_2$, the check of $Q$ at $B_5$ might be redundant.\n\n### 2. Evaluate Soundness\nThe core principle of a sound optimization is that it must preserve program correctness for *all* possible inputs, not just those in the profiling workload. We cannot conclude from the profile that $Q$ is *always* false when $P$ is true. An unobserved input could violate this correlation. Therefore, any transformation that permanently removes the check based on this inference is unsound.\n\n### 3. Assess the Options\n*   **A:** This is unsound. It makes a universal inference from statistical data (and incorrectly claims it's from edge profiling). If an input exists where control passes through $B_2$ and $Q$ is true, the program would produce the wrong result.\n*   **B:** This describes **guarded versioning**. It creates an optimized \"trace\" for the hot path ($p^*$) where the check at $B_5$ is removed. However, it first inserts a \"guard\" that checks the condition ($Q=\\text{false}$) at run-time. If the condition holds, it executes the fast, specialized trace. If not, it falls back to the original, unoptimized code. This is the standard method for performing such an optimization soundly. It leverages the high probability of the correlation without sacrificing correctness.\n*   **C:** This is unsound. It incorrectly promotes the observed correlation ($P \\implies \\lnot Q$) to a formal invariant ($Q \\equiv \\lnot P$) and applies it globally. This would lead to incorrect behavior for any input not matching the profile.\n*   **D:** This is a valid code layout optimization that improves instruction cache performance for the hot path. However, it does not achieve the stated goal of *removing the dynamic check* at $B_5$.\n\nTherefore, option B is the only one that is both sound and achieves the desired optimization.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "While comprehensive profiling is powerful, it comes with a performance cost. In practice, we often don't need to distinguish between all possible paths, but only a specific subset of interest. This leads to a key engineering question: what is the minimum instrumentation required to achieve our goal? This exercise challenges you to formalize this question as an optimization problem. You will develop an Integer Linear Programming (ILP) model to find the cheapest set of edge counters that guarantees a unique \"signature\" for every path in a given collection, perfectly illustrating how formal methods can be used to design efficient, low-overhead profiling strategies .",
            "id": "3640258",
            "problem": "Consider a control-flow graph $G=(V,E)$ with entry node $s$ and exit node $t$. A set of acyclic, entry-to-exit paths $\\mathcal{P}$ is given. Each edge $e \\in E$ has a nonnegative instrumentation overhead cost $w_{e}$, and you may place a hardware counter on edge $e$ (modeled by a binary decision variable $y_{e} \\in \\{0,1\\}$) that increments by $1$ whenever $e$ is traversed. For any path $p \\in \\mathcal{P}$, its counter signature is the vector of counter values along the instrumented edges, obtained by concatenating the per-edge counts in a fixed edge ordering. Assume each path in $\\mathcal{P}$ traverses any edge at most once.\n\nStarting from fundamental definitions of control-flow graphs and path profiling, formalize an Integer Linear Programming (ILP) model that chooses a subset of edges to instrument so that the counter signatures of all distinct paths in $\\mathcal{P}$ are unique, while minimizing the total overhead $\\sum_{e \\in E} w_{e} y_{e}$. Then, for the specific instance below, solve the ILP and report the minimal total overhead as a single real number.\n\nInstance specification:\n- Edges and costs: $E=\\{e_{1},e_{2},e_{3},e_{4},e_{5}\\}$ with $w_{e_{1}}=2$, $w_{e_{2}}=4$, $w_{e_{3}}=3$, $w_{e_{4}}=1$, $w_{e_{5}}=5$.\n- Paths: $\\mathcal{P}=\\{p_{1},p_{2},p_{3},p_{4}\\}$ where $p_{1}=(e_{1},e_{2},e_{5})$, $p_{2}=(e_{1},e_{3},e_{5})$, $p_{3}=(e_{4},e_{2},e_{5})$, and $p_{4}=(e_{4},e_{3},e_{5})$.\n\nYour answer must be the minimal total overhead value of the optimal instrumentation, expressed as a single real number. Do not include units. If you choose to approximate, justify why approximation is necessary and round to a stated number of significant figures. Otherwise, provide the exact value.",
            "solution": "The problem asks for an Integer Linear Programming (ILP) model to find the minimum cost instrumentation to uniquely identify a set of paths, and then to solve a specific instance.\n\n### ILP Formulation\n\nFirst, we formalize the general model.\n- **Decision Variables:** Let $y_e \\in \\{0, 1\\}$ for each edge $e \\in E$. $y_e=1$ if edge $e$ is instrumented, and $y_e=0$ otherwise.\n- **Objective Function:** We want to minimize the total instrumentation cost.\n  $$ \\text{Minimize} \\quad Z = \\sum_{e \\in E} w_e y_e $$\n- **Constraints:** For any two distinct paths $p_i, p_j \\in \\mathcal{P}$, their signatures must be different. This means there must be at least one instrumented edge that is in one path but not the other. The set of such distinguishing edges is the symmetric difference, $p_i \\Delta p_j$. Thus, for every pair $(p_i, p_j)$ with $i \\neq j$, we must instrument at least one edge from this set:\n  $$ \\sum_{e \\in p_i \\Delta p_j} y_e \\ge 1 $$\n\n### Solving the Specific Instance\n\n1.  **Identify Path Pairs:** We have 4 paths, so there are $\\binom{4}{2} = 6$ pairs to distinguish.\n    - $p_1=\\{e_1, e_2, e_5\\}$, $p_2=\\{e_1, e_3, e_5\\} \\implies p_1 \\Delta p_2 = \\{e_2, e_3\\}$. Constraint: $y_{e_2} + y_{e_3} \\ge 1$.\n    - $p_1=\\{e_1, e_2, e_5\\}$, $p_3=\\{e_4, e_2, e_5\\} \\implies p_1 \\Delta p_3 = \\{e_1, e_4\\}$. Constraint: $y_{e_1} + y_{e_4} \\ge 1$.\n    - The other pairs yield redundant or identical constraints. For example, $p_3 \\Delta p_4 = \\{e_2, e_3\\}$, giving the same first constraint. The pair $(p_1, p_4)$ gives $y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$, which is automatically satisfied if the first two constraints are met.\n\n2.  **Simplify the Problem:** The full ILP reduces to:\n    - **Minimize:** $Z = 2y_{e_{1}} + 4y_{e_{2}} + 3y_{e_{3}} + y_{e_{4}} + 5y_{e_{5}}$\n    - **Subject to:**\n      - $y_{e_2} + y_{e_3} \\ge 1$\n      - $y_{e_1} + y_{e_4} \\ge 1$\n      - $y_e \\in \\{0,1\\}$\n\n3.  **Find the Optimal Solution:**\n    - To minimize the cost, we set variables to 0 where possible. $y_{e_5}$ is not in any constraint, so we set $y_{e_5}=0$.\n    - To satisfy the first constraint ($y_{e_2} + y_{e_3} \\ge 1$), we must choose to instrument at least one of $e_2$ or $e_3$. We pick the one with the lower cost: $e_3$ (cost 3) is cheaper than $e_2$ (cost 4). So, we set $y_{e_3}=1, y_{e_2}=0$. Cost contribution = 3.\n    - To satisfy the second constraint ($y_{e_1} + y_{e_4} \\ge 1$), we pick the cheaper of $e_1$ (cost 2) and $e_4$ (cost 1). We set $y_{e_4}=1, y_{e_1}=0$. Cost contribution = 1.\n\n4.  **Calculate Total Cost:** The minimal total overhead is the sum of the costs of the chosen instrumentations:\n    - Total Cost = (Cost from first constraint) + (Cost from second constraint) = $3 + 1 = 4$.\n\nThe minimal total overhead is 4.",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}