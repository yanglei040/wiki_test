{
    "hands_on_practices": [
        {
            "introduction": "Dynamic languages frequently rely on virtual method calls, which can introduce performance overhead. To mitigate this, Just-In-Time (JIT) compilers employ Polymorphic Inline Caches (PICs) to quickly dispatch to the correct target method based on the object's type. This exercise  demonstrates how to use a probabilistic cost model to optimize a PIC's performance by determining the best order for its runtime type checks, a fundamental skill in performance-oriented compiler design.",
            "id": "3639221",
            "problem": "A Just-In-Time (JIT) compiler uses a Polymorphic Inline Cache (PIC) at a hot virtual call site. The PIC stub tests receiver-type guards in sequence and either tail-calls a direct target on a match or transfers to a megamorphic miss handler on failure of all guards. Consider a two-entry PIC that can hold at most two receiver-type entries, for types denoted $\\mathrm{A}$ and $\\mathrm{B}$. All other receiver types are grouped into an $\\mathrm{Other}$ category.\n\nAssume the following execution and cost model:\n- The receiver is of type $\\mathrm{A}$ with probability $p_{\\mathrm{A}} = 0.5$, of type $\\mathrm{B}$ with probability $p_{\\mathrm{B}} = 0.3$, and of type $\\mathrm{Other}$ with probability $p_{\\mathrm{O}} = 0.2$.\n- Each guard check costs $g = 2$ cycles (including comparison and branch resolution).\n- On a successful guard match, the direct call sequence costs $c = 6$ cycles (inclusive of any necessary dispatch and control transfer).\n- If both guards fail, control transfers to the miss handler, which costs $m = 80$ cycles (inclusive of lookup and calling the resolved target).\n- On a miss, both guard checks are executed before the miss handler; there are no early exits other than a direct call on a match. There are no additional overheads beyond the stated costs, and microarchitectural effects not captured in $g$, $c$, and $m$ may be ignored.\n\nThe compiler may order the two guards in the PIC stub as either $\\mathrm{A}$-then-$\\mathrm{B}$ or $\\mathrm{B}$-then-$\\mathrm{A}$. Using the law of total expectation from probability theory and the stated cost model, derive the expected cycles per call as a function of the guard order, determine which order minimizes the expected cycles, and compute the minimal expected cycles per call. Round your final numeric answer to four significant figures and express it in cycles per call.",
            "solution": "The problem requires the determination of the optimal ordering of receiver-type checks in a two-entry Polymorphic Inline Cache (PIC) to minimize the expected execution time in cycles per call. The analysis will be based on the law of total expectation, using the provided probabilities and cost model.\n\nLet $C$ be the random variable representing the total cycles required for a single virtual call. The expected value of $C$, denoted $E[C]$, is the quantity to be minimized. The problem provides the following parameters:\n- Probabilities of receiver types: $p_{\\mathrm{A}} = 0.5$, $p_{\\mathrm{B}} = 0.3$, and $p_{\\mathrm{O}} = 0.2$ for types $\\mathrm{A}$, $\\mathrm{B}$, and $\\mathrm{Other}$, respectively. Note that $p_{\\mathrm{A}} + p_{\\mathrm{B}} + p_{\\mathrm{O}} = 0.5 + 0.3 + 0.2 = 1$.\n- Cost of a single guard check: $g = 2$ cycles.\n- Cost of a direct call after a successful check: $c = 6$ cycles.\n- Cost of the megamorphic miss handler: $m = 80$ cycles.\n\nThe PIC stub can have two possible orderings for its checks: ($\\mathrm{A}$, $\\mathrm{B}$) or ($\\mathrm{B}$, $\\mathrm{A}$). We will calculate the expected cost for each ordering.\n\nCase 1: Guard order is $\\mathrm{A}$-then-$\\mathrm{B}$\nLet $C_{\\mathrm{A,B}}$ be the cost for this ordering. The total expected cost, $E[C_{\\mathrm{A,B}}]$, is the sum of the costs of each possible outcome weighted by their probabilities.\n- If the receiver is of type $\\mathrm{A}$ (with probability $p_{\\mathrm{A}}$), one guard check is performed, which succeeds. The total cost is one guard check plus the direct call cost. Cost: $g + c$.\n- If the receiver is of type $\\mathrm{B}$ (with probability $p_{\\mathrm{B}}$), the first guard check for $\\mathrm{A}$ fails, and the second guard check for $\\mathrm{B}$ succeeds. The total cost is two guard checks plus the direct call cost. Cost: $g + g + c = 2g + c$.\n- If the receiver is of type $\\mathrm{Other}$ (with probability $p_{\\mathrm{O}}$), both guard checks for $\\mathrm{A}$ and $\\mathrm{B}$ fail. Control transfers to the miss handler. The total cost is two guard checks plus the miss handler cost. Cost: $g + g + m = 2g + m$.\n\nBy the law of total expectation, the expected cost is:\n$$ E[C_{\\mathrm{A,B}}] = p_{\\mathrm{A}}(g+c) + p_{\\mathrm{B}}(2g+c) + p_{\\mathrm{O}}(2g+m) $$\n\nCase 2: Guard order is $\\mathrm{B}$-then-$\\mathrm{A}$\nLet $C_{\\mathrm{B,A}}$ be the cost for this ordering. The logic is symmetric to the first case.\n- If the receiver is of type $\\mathrm{B}$ (with probability $p_{\\mathrm{B}}$), one guard check is performed, which succeeds. Cost: $g + c$.\n- If the receiver is of type $\\mathrm{A}$ (with probability $p_{\\mathrm{A}}$), the first check for $\\mathrm{B}$ fails, and the second check for $\\mathrm{A}$ succeeds. Cost: $2g + c$.\n- If the receiver is of type $\\mathrm{Other}$ (with probability $p_{\\mathrm{O}}$), both checks fail. Cost: $2g + m$.\n\nThe expected cost for this ordering is:\n$$ E[C_{\\mathrm{B,A}}] = p_{\\mathrm{B}}(g+c) + p_{\\mathrm{A}}(2g+c) + p_{\\mathrm{O}}(2g+m) $$\n\nDetermining the Optimal Order\nTo find the order that minimizes the expected cycles, we compare $E[C_{\\mathrm{A,B}}]$ and $E[C_{\\mathrm{B,A}}]$. Let's examine their difference:\n$$ E[C_{\\mathrm{B,A}}] - E[C_{\\mathrm{A,B}}] = \\left[ p_{\\mathrm{B}}(g+c) + p_{\\mathrm{A}}(2g+c) + p_{\\mathrm{O}}(2g+m) \\right] - \\left[ p_{\\mathrm{A}}(g+c) + p_{\\mathrm{B}}(2g+c) + p_{\\mathrm{O}}(2g+m) \\right] $$\nThe term $p_{\\mathrm{O}}(2g+m)$ is common to both expressions and cancels out.\n$$ E[C_{\\mathrm{B,A}}] - E[C_{\\mathrm{A,B}}] = (p_{\\mathrm{B}}g + p_{\\mathrm{B}}c + 2p_{\\mathrm{A}}g + p_{\\mathrm{A}}c) - (p_{\\mathrm{A}}g + p_{\\mathrm{A}}c + 2p_{\\mathrm{B}}g + p_{\\mathrm{B}}c) $$\nThe terms $p_{\\mathrm{A}}c$ and $p_{\\mathrm{B}}c$ also cancel.\n$$ E[C_{\\mathrm{B,A}}] - E[C_{\\mathrm{A,B}}] = (p_{\\mathrm{B}}g + 2p_{\\mathrm{A}}g) - (p_{\\mathrm{A}}g + 2p_{\\mathrm{B}}g) $$\n$$ E[C_{\\mathrm{B,A}}] - E[C_{\\mathrm{A,B}}] = p_{\\mathrm{B}}g + 2p_{\\mathrm{A}}g - p_{\\mathrm{A}}g - 2p_{\\mathrm{B}}g $$\n$$ E[C_{\\mathrm{B,A}}] - E[C_{\\mathrm{A,B}}] = p_{\\mathrm{A}}g - p_{\\mathrm{B}}g = g(p_{\\mathrm{A}} - p_{\\mathrm{B}}) $$\nThe sign of the difference depends on the sign of $(p_{\\mathrm{A}} - p_{\\mathrm{B}})$, since $g > 0$. An ordering is optimal if it results in a lower expected cost.\n- If $p_{\\mathrm{A}} > p_{\\mathrm{B}}$, then $E[C_{\\mathrm{B,A}}] - E[C_{\\mathrm{A,B}}] > 0$, implying $E[C_{\\mathrm{B,A}}] > E[C_{\\mathrm{A,B}}]$. The $\\mathrm{A}$-then-$\\mathrm{B}$ order is optimal.\n- If $p_{\\mathrm{B}} > p_{\\mathrm{A}}$, then $E[C_{\\mathrm{B,A}}] - E[C_{\\mathrm{A,B}}]  0$, implying $E[C_{\\mathrm{B,A}}]  E[C_{\\mathrm{A,B}}]$. The $\\mathrm{B}$-then-$\\mathrm{A}$ order is optimal.\n\nThis confirms the general principle that to minimize average cost, one should test for the most probable outcomes first.\nGiven the probabilities $p_{\\mathrm{A}}=0.5$ and $p_{\\mathrm{B}}=0.3$, we have $p_{\\mathrm{A}} > p_{\\mathrm{B}}$. Therefore, the optimal guard order is $\\mathrm{A}$-then-$\\mathrm{B}$.\n\nComputing the Minimal Expected Cycles\nWe now compute the numerical value of the minimal expected cycles, $E[C_{\\mathrm{A,B}}]$, using the given values:\n$p_{\\mathrm{A}} = 0.5$, $p_{\\mathrm{B}} = 0.3$, $p_{\\mathrm{O}} = 0.2$\n$g = 2$, $c = 6$, $m = 80$\n\n$$ E[C_{\\mathrm{A,B}}] = p_{\\mathrm{A}}(g+c) + p_{\\mathrm{B}}(2g+c) + p_{\\mathrm{O}}(2g+m) $$\n$$ E[C_{\\mathrm{A,B}}] = 0.5(2+6) + 0.3(2 \\times 2 + 6) + 0.2(2 \\times 2 + 80) $$\n$$ E[C_{\\mathrm{A,B}}] = 0.5(8) + 0.3(4 + 6) + 0.2(4 + 80) $$\n$$ E[C_{\\mathrm{A,B}}] = 0.5(8) + 0.3(10) + 0.2(84) $$\n$$ E[C_{\\mathrm{A,B}}] = 4.0 + 3.0 + 16.8 $$\n$$ E[C_{\\mathrm{A,B}}] = 23.8 $$\nThe problem asks for the final answer to be rounded to four significant figures. The calculated value $23.8$ can be written as $23.80$ to meet this requirement. The units are cycles per call.\n\nThe minimal expected cycles per call is $23.80$.",
            "answer": "$$\n\\boxed{23.80}\n$$"
        },
        {
            "introduction": "Beyond speeding up calls, modern JITs perform aggressive speculative optimizations, such as eliminating redundant checks within hot loops. This practice  explores the central trade-off of this strategy: the substantial cycle savings from successful speculation versus the high, fixed cost of deoptimization upon failure. You will develop a cost-benefit model that uses an estimated failure rate, derived from runtime sampling, to decide whether this powerful optimization is ultimately profitable.",
            "id": "3639127",
            "problem": "A Just-In-Time (JIT) compiler in a dynamic language runtime performs speculative null-check elimination inside a hot loop by hoisting a guard before the loop. A guard is a runtime check inserted to ensure an assumed property holds; if the property fails, the system triggers deoptimization (transition to a more conservative code version) with a fixed cost. The following setting is considered. Each invocation of a method executes a loop with $L$ iterations. The baseline machine code contains a per-iteration null-check costing $c$ cycles. The speculative version hoists a single guard before the loop costing $g$ cycles per invocation. If the guard succeeds, the null-check inside the loop is eliminated for that invocation. If the guard fails, deoptimization occurs at a cost $D$ cycles, and the invocation proceeds in the baseline code (that is, its loop executes with the null-check intact). Failures are rare and the runtime adaptively samples invocations to estimate the failure frequency.\n\nOver a measurement window of $N$ invocations, the runtime records guard failures using independent Bernoulli sampling: each invocation is sampled with probability $s$, and only sampled invocations record whether a guard failure occurred. Within the sampled set, $f_s$ failures are observed.\n\nStarting from fundamental probability definitions (indicator variables, expectation, and unbiased estimation) and a first-principles cost model (linearity of expectation for expected cycles), do the following:\n- Derive an unbiased estimator for the guard failure frequency $\\phi$ (the fraction of invocations that would fail without sampling) in terms of $N$, $s$, and $f_s$.\n- Using $\\phi$, derive the expected net cycles saved over the $N$ invocations relative to the baseline code (which retains the per-iteration null-check), accounting for the guard cost and deoptimization cost.\n\nUse the following measured and architectural parameters:\n- $L = 8000$\n- $c = 3$ cycles\n- $g = 40$ cycles per invocation\n- $D = 50000$ cycles per deoptimization\n- $N = 120000$\n- $s = 0.05$\n- $f_s = 180$\n\nRound your final numeric answer to four significant figures. Express the final quantity as the total expected net cycles saved over the $N$ invocations, in cycles.",
            "solution": "The solution is divided into two parts: first, the derivation of an unbiased estimator for the guard failure frequency, and second, the derivation of the expected net cycles saved, followed by a numerical calculation.\n\n**Part 1: Unbiased Estimator for Guard Failure Frequency ($\\phi$)**\n\nLet $\\phi$ be the true probability that a guard fails for any given invocation of the method. We are asked to find an unbiased estimator, $\\hat{\\phi}$, for this parameter. The estimation is based on a measurement window of $N$ invocations.\n\nLet $F_i$ be an indicator random variable for the $i$-th invocation, where $i \\in \\{1, 2, \\dots, N\\}$.\n$$\nF_i =\n\\begin{cases}\n1  \\text{if invocation } i \\text{ would fail the guard} \\\\\n0  \\text{if invocation } i \\text{ would succeed}\n\\end{cases}\n$$\nBy definition, the probability of failure is $P(F_i=1) = \\phi$, and thus the expected value of $F_i$ is $E[F_i] = 1 \\cdot P(F_i=1) + 0 \\cdot P(F_i=0) = \\phi$.\n\nThe runtime samples invocations independently with probability $s$. Let $S_i$ be an indicator random variable for sampling.\n$$\nS_i =\n\\begin{cases}\n1  \\text{if invocation } i \\text{ is sampled} \\\\\n0  \\text{if invocation } i \\text{ is not sampled}\n\\end{cases}\n$$\nThe probability of sampling is $P(S_i=1) = s$, so $E[S_i] = s$.\n\nA failure is observed only if an invocation is both sampled and would have failed. Let $O_i$ be the indicator variable for an observed failure for the $i$-th invocation. Thus, $O_i = S_i F_i$. The total number of observed failures, $f_s$, is the sum of these indicator variables over all $N$ invocations:\n$$f_s = \\sum_{i=1}^{N} O_i = \\sum_{i=1}^{N} S_i F_i$$\nTo construct an estimator, we first find the expected value of $f_s$. Using the linearity of expectation:\n$$E[f_s] = E\\left[\\sum_{i=1}^{N} S_i F_i\\right] = \\sum_{i=1}^{N} E[S_i F_i]$$\nThe sampling process is independent of the program's behavior (whether an invocation fails). Therefore, the random variables $S_i$ and $F_i$ are independent. This allows us to write $E[S_i F_i] = E[S_i]E[F_i]$.\n$$E[S_i F_i] = s \\phi$$\nSubstituting this back into the expression for $E[f_s]$:\n$$E[f_s] = \\sum_{i=1}^{N} s\\phi = Ns\\phi$$\nAn estimator $\\hat{\\phi}$ for $\\phi$ is unbiased if its expected value is equal to $\\phi$, i.e., $E[\\hat{\\phi}] = \\phi$. Based on the relationship $E[f_s] = Ns\\phi$, we can propose the following estimator for $\\phi$:\n$$\\hat{\\phi} = \\frac{f_s}{Ns}$$\nTo verify that this estimator is unbiased, we take its expectation:\n$$E[\\hat{\\phi}] = E\\left[\\frac{f_s}{Ns}\\right] = \\frac{1}{Ns}E[f_s] = \\frac{1}{Ns}(Ns\\phi) = \\phi$$\nThus, $\\hat{\\phi} = \\frac{f_s}{Ns}$ is an unbiased estimator for the guard failure frequency $\\phi$.\n\n**Part 2: Expected Net Cycles Saved**\n\nWe need to derive the expected net cycles saved over $N$ invocations by using the speculative version of the code compared to the baseline.\n\nIn the baseline code, each of the $N$ invocations performs a null-check in every one of the $L$ loop iterations. The cost of each check is $c$ cycles. The total cost attributable to these checks over $N$ invocations is:\n$$C_{\\text{baseline}} = N L c$$\nIn the speculative version, we analyze the net cycles saved per-invocation. Let $\\Delta C_{\\text{saved}}$ be this value. There are two cases for each invocation:\n\nCase 1: The guard succeeds. This occurs with probability $1-\\phi$.\nThe per-iteration null-checks, costing a total of $Lc$ cycles, are eliminated. This is a saving. A new cost, the guard check, is introduced, costing $g$ cycles.\nThe net cycles saved in this case are: $\\Delta C_{\\text{saved, success}} = Lc - g$.\n\nCase 2: The guard fails. This occurs with probability $\\phi$.\nThe guard check is performed, costing $g$ cycles. Deoptimization occurs, costing $D$ cycles. The invocation then proceeds using the baseline code, meaning the $Lc$ cost of the null-checks is *not* saved. Compared to the baseline, we have *added* costs of $g$ and $D$.\nThe net cycles saved in this case are negative: $\\Delta C_{\\text{saved, fail}} = -(g+D)$.\n\nThe expected net cycles saved per invocation, $E[\\Delta C_{\\text{saved}}]$, is the weighted average of these two outcomes:\n$$E[\\Delta C_{\\text{saved}}] = P(\\text{success}) \\cdot \\Delta C_{\\text{saved, success}} + P(\\text{fail}) \\cdot \\Delta C_{\\text{saved, fail}}$$\n$$E[\\Delta C_{\\text{saved}}] = (1-\\phi)(Lc - g) + (\\phi)(-(g+D))$$\nExpanding this expression:\n$$E[\\Delta C_{\\text{saved}}] = Lc - g - \\phi Lc + \\phi g - \\phi g - \\phi D = Lc - g - \\phi(Lc + D)$$\nThe total expected net cycles saved over $N$ invocations, $E[\\text{Total Saved}]$, is $N$ times the per-invocation savings:\n$$E[\\text{Total Saved}] = N \\cdot E[\\Delta C_{\\text{saved}}] = N(Lc - g - \\phi(Lc+D))$$\nTo compute a numerical value, we use our unbiased estimator $\\hat{\\phi} = \\frac{f_s}{Ns}$ in place of the true frequency $\\phi$:\n$$E[\\text{Total Saved}]_{\\text{est}} = N\\left(Lc - g - \\left(\\frac{f_s}{Ns}\\right)(Lc+D)\\right)$$\nDistributing the leading $N$ simplifies the expression:\n$$E[\\text{Total Saved}]_{\\text{est}} = N(Lc-g) - \\frac{f_s}{s}(Lc+D)$$\nNow, we substitute the given numerical values:\n$L = 8000$, $c = 3$ cycles, $g = 40$ cycles, $D = 50000$ cycles, $N = 120000$, $s = 0.05$, and $f_s = 180$.\n\nFirst, calculate the term for gross savings (savings if no failures occurred):\n$$N(Lc-g) = 120000 \\times (8000 \\times 3 - 40) = 120000 \\times (24000 - 40) = 120000 \\times 23960 = 2875200000 \\text{ cycles}$$\nNext, calculate the term for the total expected cost of failures and deoptimization:\n$$\\frac{f_s}{s}(Lc+D) = \\frac{180}{0.05} \\times (8000 \\times 3 + 50000) = 3600 \\times (24000 + 50000) = 3600 \\times 74000 = 266400000 \\text{ cycles}$$\nThe estimated total net cycles saved is the difference between these two quantities:\n$$E[\\text{Total Saved}]_{\\text{est}} = 2875200000 - 266400000 = 2608800000 \\text{ cycles}$$\nThis can be written in scientific notation as $2.6088 \\times 10^9$ cycles. The problem requires rounding the final answer to four significant figures.\n$$2.6088 \\times 10^9 \\approx 2.609 \\times 10^9$$\nThe total expected net cycles saved over the $N$ invocations is approximately $2.609 \\times 10^9$ cycles.",
            "answer": "$$\\boxed{2.609 \\times 10^9}$$"
        },
        {
            "introduction": "When a compiler speculatively inlines a chain of function calls, it must decide on an optimal inlining depth, balancing potential savings against compilation overhead and the risk of deoptimization. This problem  advances our analysis from single events to modeling a long-running process, where speculation can fail on any given invocation. By applying the geometric distribution, you will derive a closed-form analytical expression for the \"breakeven\" inlining depth, providing a principled foundation for this critical optimization heuristic.",
            "id": "3639208",
            "problem": "A virtual machine employs Just-In-Time (JIT) compilation with speculative inlining to accelerate a hot loop that repeatedly calls a chain of functions. The optimizer considers an inlining depth $d$, meaning it inlines $d$ functions along the call chain into the caller. There is a single conditional branch inside the inlined region that is biased: its hot outcome occurs independently on each invocation with probability $b \\in (0,1)$, and its cold outcome occurs with probability $1-b$. The JIT emits code that speculates the hot outcome and installs a deoptimization guard that transfers control back to a non-speculative baseline when the speculation fails.\n\nAssume the following cost model, stated in terms of time:\n- Each level of inlining eliminates call overhead and exposes local optimizations that save $w$ units of time per invocation, so when speculation holds, the per-invocation runtime saving attributable to inlining depth $d$ is $w d$.\n- The one-time compilation overhead grows linearly with inlining depth and is $k d$.\n- When speculation fails the first time, deoptimization reconstructs execution state and resumes in the baseline, incurring a one-time cost $L$. After deoptimization, no further speculative benefit is realized; execution continues in the baseline with no additional savings.\n- Branch outcomes are independent across invocations.\n\nTreat the inlining depth $d$ as a continuous decision variable for the purpose of analysis. Using fundamental definitions from probability and expected value, derive the breakeven inlining depth $d^{\\star}$ such that the expected net time saved is zero. Express your final answer as a single closed-form analytical expression in terms of $b$, $w$, $k$, and $L$. No rounding is required, and no units are necessary in your final expression.",
            "solution": "The objective is to find the breakeven inlining depth, denoted as $d^{\\star}$, for which the expected net time saved is zero. The net time saved is the total time saved from successful speculative execution minus the one-time costs of compilation and deoptimization.\n\nLet $S(d)$ be the net time saved for a given inlining depth $d$. We want to find $d^{\\star}$ such that the expected value $E[S(d^{\\star})] = 0$.\n\nThe core of the problem lies in the probabilistic nature of the speculative execution. The hot path of a conditional branch is taken with probability $b$, and the cold path is taken with probability $1-b$. The JIT speculates that the hot path will be taken. Execution proceeds speculatively until the first time the cold path is taken, at which point a deoptimization event occurs. The outcomes of the branch on each invocation of the loop are independent events.\n\nLet $I$ be the random variable representing the invocation number on which the first speculation failure (i.e., the first time the cold path is taken) occurs. This is a classic Bernoulli trial process. The event of a failure on the $i$-th invocation requires $i-1$ consecutive successes (hot path) followed by one failure (cold path). The probability of this sequence of events is:\n$$P(I=i) = b^{i-1}(1-b) \\quad \\text{for } i \\in \\{1, 2, 3, \\ldots\\}$$\nThis defines a geometric distribution for the random variable $I$ with a \"success\" parameter $p = 1-b$ (where \"success\" here means the event that stops the process, i.e., a speculation failure).\n\nIf the first failure occurs on invocation $I$, then there have been $I-1$ successful speculative invocations.\nThe total time saved from these successful invocations is the per-invocation saving, $wd$, multiplied by the number of successful invocations, $I-1$.\nTotal benefit from speculation = $(I-1)wd$.\n\nThe costs associated with this speculative strategy are:\n1.  A one-time compilation overhead, which is a function of the inlining depth: $kd$.\n2.  A one-time deoptimization penalty, incurred at the first failure: $L$.\n\nThe net time saved, as a function of the random variable $I$ and the decision variable $d$, is therefore:\n$$S(d, I) = (I-1)wd - kd - L$$\n\nTo find the breakeven point, we need to compute the expected net time saved, $E[S(d,I)]$. By the linearity of expectation:\n$$E[S(d,I)] = E[(I-1)wd - kd - L] = E[(I-1)wd] - E[kd] - E[L]$$\nSince $w$, $d$, $k$, and $L$ are constants with respect to the random process (the branch outcomes), we can write:\n$$E[S(d)] = wd \\cdot E[I-1] - kd - L$$\n\nWe need to compute $E[I-1]$. The expected value of a geometric random variable $I$ with parameter $p=1-b$ is given by $E[I] = \\frac{1}{p} = \\frac{1}{1-b}$.\nThe expected number of successful invocations before the first failure is:\n$$E[I-1] = E[I] - 1 = \\frac{1}{1-b} - 1 = \\frac{1 - (1-b)}{1-b} = \\frac{b}{1-b}$$\n\nSubstituting this result back into the expression for the expected net time saved:\n$$E[S(d)] = wd \\left(\\frac{b}{1-b}\\right) - kd - L$$\nThis expression represents the expected net gain from choosing an inlining depth $d$. A positive value indicates an expected net saving, while a negative value indicates an expected net loss.\n\nThe breakeven inlining depth, $d^{\\star}$, is the depth at which the expected net time saved is exactly zero:\n$$E[S(d^{\\star})] = 0$$\n$$w d^{\\star} \\left(\\frac{b}{1-b}\\right) - k d^{\\star} - L = 0$$\n\nWe can now solve this linear equation for $d^{\\star}$. First, factor out $d^{\\star}$:\n$$d^{\\star} \\left(w \\frac{b}{1-b} - k\\right) = L$$\nProvided that the term in the parenthesis is not zero, we can solve for $d^{\\star}$:\n$$d^{\\star} = \\frac{L}{w \\frac{b}{1-b} - k}$$\nThe condition for a non-negative breakeven depth is $w \\frac{b}{1-b} - k > 0$, which implies that the expected per-invocation savings from an additional level of inlining must exceed its compilation cost.\n\nTo simplify the expression into a single fraction, we can find a common denominator for the terms in the denominator of the main fraction:\n$$w \\frac{b}{1-b} - k = \\frac{wb}{1-b} - \\frac{k(1-b)}{1-b} = \\frac{wb - k(1-b)}{1-b}$$\nSubstituting this back into the expression for $d^{\\star}$:\n$$d^{\\star} = \\frac{L}{\\frac{wb - k(1-b)}{1-b}} = \\frac{L(1-b)}{wb - k(1-b)}$$\nThis is the final closed-form analytical expression for the breakeven inlining depth.",
            "answer": "$$\n\\boxed{\\frac{L(1-b)}{wb - k(1-b)}}\n$$"
        }
    ]
}