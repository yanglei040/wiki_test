{
    "hands_on_practices": [
        {
            "introduction": "我们首先通过一个具体的计算问题来探索静态单赋值（SSA）形式如何增强数据流分析。本练习聚焦于稀疏条件常量传播（Sparse Conditional Constant Propagation, SCCP），这是一种强大的算法，它能同时推断变量的常量性与代码路径的可达性。通过解决这个问题，你将亲眼见证SSA形式下的SCCP如何精确地剪除死代码分支，并让常量值流经$\\phi$函数，从而实现比传统独立分析更优的优化效果。",
            "id": "3660120",
            "problem": "给定一个静态单赋值 (SSA) 形式的小程序，它演示了在稀疏条件常量传播 (SCCP) 下，跨 $\\phi$-函数的常量折叠行为。该环境对每个 SSA 值使用标准的三点值格 $\\{\\bot,\\text{constant},\\top\\}$，并维护一个可执行边集来建模控制流的可行性。在汇合块中的 $\\phi$-函数选择与运行时实际采用的控制流前驱相对应的操作数，在 SCCP 下，其值被计算为仅来自可执行前驱的操作数在值格上的交会 (meet)。假设使用整数布尔值，其中 $0$ 表示假，$1$ 表示真，并采用整数算术。控制流图 (CFG) 和 SSA 代码如下：\n\n- 块 $\\mathrm{B0}$ (入口):\n  - $q \\leftarrow 0$\n  - if $q \\neq 0$ goto $\\mathrm{B4}$ else goto $\\mathrm{B00}$\n- 块 $\\mathrm{B4}$:\n  - $a_4 \\leftarrow 3$\n  - goto $\\mathrm{J}$\n- 块 $\\mathrm{B00}$:\n  - $p \\leftarrow 1$\n  - if $p \\neq 0$ goto $\\mathrm{B1}$ else goto $\\mathrm{B2}$\n- 块 $\\mathrm{B1}$:\n  - $a_1 \\leftarrow 3$\n  - $b_1 \\leftarrow 3$\n  - goto $\\mathrm{J}$\n- 块 $\\mathrm{B2}$:\n  - $a_2 \\leftarrow 3$\n  - $b_2 \\leftarrow 4$\n  - goto $\\mathrm{J}$\n- 块 $\\mathrm{J}$ (前驱 $\\mathrm{B1}$, $\\mathrm{B2}$, $\\mathrm{B4}$ 的汇合点):\n  - $a \\leftarrow \\phi(a_1,a_2,a_4)$\n  - $b \\leftarrow \\phi(b_1,b_2)$\n  - $\\mathrm{out} \\leftarrow 10 \\cdot a + b$\n  - return $\\mathrm{out}$\n\n你的任务是，在应用稀疏条件常量传播至不动点，并随后进行标准代数化简和常量折叠后，确定该程序返回的数值。你必须基于以下基本定义和事实进行推理：\n\n- 静态单赋值 (SSA) 形式为每个变量精确赋值一次，并使用 $\\phi$-函数在控制流图的汇合点合并来自多个前驱的值。$\\phi$-函数的语义是产生与实际采用的控制流路径相对应的操作数。\n- 稀疏条件常量传播 (SCCP) 使用值格 $\\{\\bot,\\text{constant},\\top\\}$ 同时对值信息和控制流可执行性进行推理。传递函数是单調的，分析过程迭代至不动点。$\\phi$-函数的值是其传入操作数值在值格上的交会，且仅限于来自可执行前驱的操作数。如果有多个来自可执行路径的传入操作数是不同的常量，则 $\\phi$-函数变为 $\\top$；如果它们是相等的常量，则它变为该常量；如果只有一个可执行前驱带有常量值，而所有其他可执行前驱的操作数值为 $\\bot$，则它变为该常量。\n\n请从第一性原理出发，并使用上述框架，解释 SCCP 如何发现和利用以下情况：\n- 当所有传入操作数都是相同常量时（如 $a \\leftarrow \\phi(3,3,3)$），跨 $\\phi$-函数的常量折叠。\n- 当一个 $\\phi$-函数在不同前驱上有不同常量时（如 $b \\leftarrow \\phi(3,4)$），但其中一个前驱被发现是不可行路径时的收敛情况。\n\n计算最终返回的精确整数值 $\\mathrm{out}$。不要四舍五入，也不要包含任何单位。",
            "solution": "首先根据指定标准验证问题。\n\n### 步骤 1：提取已知信息\n- **SSA 形式的程序及其控制流图 (CFG)：**\n  - 块 $\\mathrm{B0}$ (入口):\n    - $q \\leftarrow 0$\n    - if $q \\neq 0$ goto $\\mathrm{B4}$ else goto $\\mathrm{B00}$\n  - 块 $\\mathrm{B4}$:\n    - $a_4 \\leftarrow 3$\n    - goto $\\mathrm{J}$\n  - 块 $\\mathrm{B00}$:\n    - $p \\leftarrow 1$\n    - if $p \\neq 0$ goto $\\mathrm{B1}$ else goto $\\mathrm{B2}$\n  - 块 $\\mathrm{B1}$:\n    - $a_1 \\leftarrow 3$\n    - $b_1 \\leftarrow 3$\n    - goto $\\mathrm{J}$\n  - 块 $\\mathrm{B2}$:\n    - $a_2 \\leftarrow 3$\n    - $b_2 \\leftarrow 4$\n    - goto $\\mathrm{J}$\n  - 块 $\\mathrm{J}$ (前驱 $\\mathrm{B1}$, $\\mathrm{B2}$, $\\mathrm{B4}$ 的汇合点):\n    - $a \\leftarrow \\phi(a_1, a_2, a_4)$\n    - $b \\leftarrow \\phi(b_1, b_2)$\n    - $\\mathrm{out} \\leftarrow 10 \\cdot a + b$\n    - return $\\mathrm{out}$\n- **稀疏条件常量传播 (SCCP) 框架：**\n  - 值格：$\\{\\bot,\\text{constant},\\top\\}$，其中 $\\bot$ 表示未定义，常量是特定值（例如 $0, 1, 3, 4$），而 $\\top$ 表示过度定义（非常量）。\n  - 控制流：维护一个可执行边集。\n  - $\\phi$-函数求值：其值是其操作数值的交会，仅限于来自可执行前驱的操作数。\n- **整数语义：**布尔值表示为整数，其中 $0$ 为假，$1$ 为真。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题在编译器理论（计算机科学的一个子领域）领域具有科学依据。静态单赋值 (SSA)、控制流图 (CFG) 和稀疏条件常量传播 (SCCP) 等概念都是标准且定义明确的。所提供的值格和交会规则是 SCCP 的规范表述。该问题是适定的，提供了所有必要的代码和语义规则以唯一确定分析结果。语言客观而精确。问题是自洽且内部一致的。\n\n### 步骤 3：结论与行动\n问题有效。详细解答如下。\n\n解答过程通过模拟在给定程序上运行稀疏条件常量传播 (SCCP) 算法，直到达到不动点。该算法为每个变量维护一个格值，并维护一个可执行的 CFG 边集。我们对值已改变的变量和新发现的可执行边使用工作列表。\n\n**初始化：**\n1.  所有变量初始化为 $\\bot$：$v(q) = \\bot$，$v(p) = \\bot$，$v(a_1) = \\bot$ 等。\n2.  所有 CFG 边最初都被视为不可执行。\n3.  入口块 $\\mathrm{B0}$ 总是可达的。我们将从程序入口到 $\\mathrm{B0}$ 的（概念上的）边添加到一个可执行边的工作列表中。\n\n**执行跟踪：**\n\n1.  **块 $\\mathrm{B0}$：** 算法从访问入口块 $\\mathrm{B0}$ 开始。\n    - 指令 $q \\leftarrow 0$ 被求值。$q$ 的格值从 $\\bot$ 变为常量 $0$。\n    - 条件分支 `if $q \\neq 0$` 被求值。由于 $v(q) = 0$，条件 $0 \\neq 0$ 被静态地确定为假。\n    - 因此，控制流边 $\\mathrm{B0} \\rightarrow \\mathrm{B4}$ 被确定为不可执行。\n    - 边 $\\mathrm{B0} \\rightarrow \\mathrm{B00}$ 被确定为可执行并被处理。\n\n2.  **块 $\\mathrm{B00}$：** 算法前进到块 $\\mathrm{B00}$。\n    - 指令 $p \\leftarrow 1$ 将 $p$ 的格值设置为常量 $1$。\n    - 条件分支 `if $p \\neq 0$` 被求值。由于 $v(p) = 1$，条件 $1 \\neq 0$ 被静态地确定为真。\n    - 边 $\\mathrm{B00} \\rightarrow \\mathrm{B2}$ 是不可执行的。\n    - 边 $\\mathrm{B00} \\rightarrow \\mathrm{B1}$ 是可执行的并被处理。\n\n3.  **死代码消除：** 在此阶段，SCCP 已证明块 $\\mathrm{B4}$ 和 $\\mathrm{B2}$ 是不可达的。这些块中的任何指令都不会被求值，它们定义的变量将保持其初始格值 $\\bot$。通向它们的控制流路径（$\\mathrm{B0} \\rightarrow \\mathrm{B4}$ 和 $\\mathrm{B00} \\rightarrow \\mathrm{B2}$）将从对汇合块 $\\mathrm{J}$ 的分析中被剪除。\n\n4.  **块 $\\mathrm{B1}$：** 算法前进到唯一可达的后继块 $\\mathrm{B1}$。\n    - 指令 $a_1 \\leftarrow 3$ 将 $v(a_1)$ 设置为常量 $3$。\n    - 指令 $b_1 \\leftarrow 3$ 将 $v(b_1)$ 设置为常量 $3$。\n    - 无条件跳转 `goto $\\mathrm{J}$` 使边 $\\mathrm{B1} \\rightarrow \\mathrm{J}$ 变为可执行。\n\n5.  **块 $\\mathrm{J}$ (汇合点)：** 算法到达汇合点 $\\mathrm{J}$。现在对 $\\phi$-函数进行求值。SCCP 规则规定，$\\phi$-函数的交会操作仅在对应于可执行前驱边的操作数上执行。\n    - **$a \\leftarrow \\phi(a_1, a_2, a_4)$ 的求值：**\n      $\\mathrm{J}$ 的前驱是 $\\mathrm{B1}$、$\\mathrm{B2}$ 和 $\\mathrm{B4}$。然而，分析已证明只有边 $\\mathrm{B1} \\rightarrow \\mathrm{J}$ 是可执行的。因此，$a$ 的值完全由来自 $\\mathrm{B1}$ 的操作数确定。\n      $$v(a) = v(a_1) = 3$$\n      变量 $a$ 现在已知为常量 $3$。\n\n    - **关于跨 $\\phi$ 函数的常量折叠的解释（按要求）：**\n      问题要求解释 $a \\leftarrow \\phi(3,3,3)$ 的折叠。这些赋值是 $a_1 \\leftarrow 3$、$a_2 \\leftarrow 3$ 和 $a_4 \\leftarrow 3$。在我们的具体案例中，由于只有通过 $\\mathrm{B1}$ 的路径是活动的，因此在死代码块中定义的 $a_2$ 和 $a_4$ 的值是无关紧要的。结果仅由 $a_1$ 决定。\n      然而，在一个假设情景中，如果所有三条到 $\\mathrm{J}$ 的路径都被发现是可执行的，SCCP 将会求值所有三个赋值，得到 $v(a_1)=3$、$v(a_2)=3$ 和 $v(a_4)=3$。$\\phi$-函数的值将是这些常量的交会：\n      $$v(a) = \\text{meet}(v(a_1), v(a_2), v(a_4)) = \\text{meet}(3, 3, 3) = 3$$\n      因此，SCCP 将 $\\phi$-函数折叠为一个常量，因为相同常量的交会就是该常量本身。\n\n    - **$b \\leftarrow \\phi(b_1, b_2)$ 的求值：**\n      $b$ 的 $\\phi$-函数文本表明它合并来自前驱 $\\mathrm{B1}$ 和 $\\mathrm{B2}$ 的值。如前所述，只有通过 $\\mathrm{B1}$ 的路径是可执行的。\n      $$v(b) = v(b_1) = 3$$\n      变量 $b$ 被确定为常量 $3$。\n\n    - **关于不可行路径下收敛的解释（按要求）：**\n      问题要求解释 $b \\leftarrow \\phi(3,4)$ 的情况，其中 $b_1 \\leftarrow 3$ 和 $b_2 \\leftarrow 4$。这是 SCCP 强大功能的核心展示。如果通过 $\\mathrmB1$ 和 $\\mathrmB2$ 的两条路径都是可执行的，求值结果将是：\n      $$v(b) = \\text{meet}(v(b_1), v(b_2)) = \\text{meet}(3, 4) = \\top$$\n      这将意味着 $b$ 不是一个常量。然而，SCCP 对值和控制流的同时分析证明了通过 $\\mathrm{B2}$ 的路径是不可达的。因此，来自这条死路径的操作数 $b_2$ 被排除在交会计算之外。算法只考虑来自活动路径的值，从而得到 $v(b) = v(b_1) = 3$。这防止了值保守地变为 $\\top$，并允许更精确的常量传播。\n\n6.  **最终计算：** 利用不动点值 $v(a)=3$ 和 $v(b)=3$，块 $\\mathrm{J}$ 中的最后一条指令被求值：\n    - $\\mathrm{out} \\leftarrow 10 \\cdot a + b$\n    - 这使用已发现的常量进行计算：$\\mathrm{out} \\leftarrow 10 \\cdot 3 + 3$。\n    - 表达式被折叠为单个常量：$\\mathrm{out} \\leftarrow 30 + 3 = 33$。\n    - $\\mathrm{out}$ 的格值变为常量 $33$。\n\n程序返回 $\\mathrm{out}$ 的值，SCCP 分析已确定其为 $33$。",
            "answer": "$$\\boxed{33}$$"
        },
        {
            "introduction": "静态单赋值（SSA）形式的一个主要优势在于它极大地简化了对循环的分析与优化。这个练习将引导你运用SSA的结构特性来识别循环不变量（loop-invariant），这是实现循环不变量代码外提（Loop-Invariant Code Motion, LICM）的关键一步。你将把一个嵌套循环内的冗余计算安全地移到循环外，并精确量化该优化所带来的显著性能提升。",
            "id": "3660080",
            "problem": "考虑一个程序片段，其控制流由一个嵌套循环组成，外层循环索引为 $i$，内层循环索引为 $j$。该程序在静态单赋值（SSA）形式下运行，其中每个变量只被赋值一次，控制流图中的合并点会引入 $\\phi$ 函数。已知内层循环体当前计算一个纯算术表达式 $E(i)$，该表达式仅依赖于外层循环索引 $i$，并且不读取或写入内存。内层循环将结果累加到一个标量 $s$ 中，并递增 $j$ 直到达到其边界。其结构如下：\n\n- 外层循环头包含一个针对 $i$ 的 $\\phi$ 函数，将 $i$ 初始化为 $0$，并在外层循环回边处与递增后的值合并。\n- 内层循环头包含一个针对 $j$ 的 $\\phi$ 函数，将 $j$ 初始化为 $0$，并在内层循环回边处与 $j+1$ 合并。\n- 内层循环还包含一个针对累加器 $s$ 的 $\\phi$ 函数，在循环入口处合并传入的值与每次迭代更新后的值。\n- 内层循环体计算 $E(i)$，作为对 $s$ 每次迭代贡献的一部分。\n- 内层循环条件检查 $j  M(i)$，其中 $M(i)$ 是一个依赖于 $i$ 的循环边界。\n\n假设如下：\n- 静态单赋值（SSA）形式是根据标准定义正确构建的：每个变量只有一个赋值；在控制流连接点，引入 $\\phi$ 函数以选择传入的值；定义支配其所有使用；循环头支配其回边（latch）。\n- $E(i)$ 是一个仅由 $i$ 通过整数算术构成的纯表达式，没有副作用，不访问内存，并且其求值不会抛出异常。\n- 边界函数为 $M(i) = i + 1$。\n- 外层循环中 $i$ 的范围是从 $0$ 到 $N-1$，其中 $N = 100$。\n- 对于每个固定的 $i$，内层循环中 $j$ 的范围是从 $0$ 到 $M(i)-1$。\n- 累加器 $s$ 在内层循环体中通过一个依赖于 $E(i)$ 和 $j$ 的函数进行更新，但该函数不改变 $E(i)$ 相对于 $j$ 的不变性属性。\n\n基于 $\\phi$ 函数在控制流连接点对值的选择进行建模，以及循环携带依赖在SSA定义-使用图（def-use graph）中表现为沿循环回边的环路这一基本原理，执行以下操作：\n\n1. 使用SSA结构以及外层和内层循环头中的 $\\phi$ 函数布局，判断 $E(i)$ 是相对于内层循环索引 $j$ 循环携带的，还是在内层循环中是不变的。通过SSA中的支配和定义-使用属性进行推理来证明你的答案。\n2. 提出一种优化方法，将 $E(i)$ 的计算从内层循环体下沉到内层循环的预备头（preheader）中，同时保持程序语义。解释为什么在给定假设下该优化是安全的。\n3. 计算在应用该优化前后，整个嵌套循环中 $E(i)$ 的动态求值总次数。然后，计算该优化消除的 $E(i)$ 的动态求值总次数。以单个实数值形式提供最终的消除次数。最终答案无需四舍五入，也无需单位。",
            "solution": "这个问题提得很好，并且基于编译器理论的原理，特别是关于静态单赋值（SSA）形式下的程序分析和优化。我们将按顺序解决问题的三个部分。\n\n1.  判断 $E(i)$ 是否是循环不变的。\n\n如果一个表达式对于循环 $L$ 的每次执行，在每次迭代中都求得相同的值，则该表达式被定义为相对于循环 $L$ 是循环不变的。在SSA形式的上下文中，如果一条指令的所有操作数都在循环外定义，则该指令是循环不变的。这些操作数可以是常量、循环未修改的全局变量，或其定义在循环外部的变量。\n\n我们讨论的表达式是 $E(i)$。问题陈述中说明，$E(i)$ 是一个“仅依赖于外层循环索引 $i$”的纯算术表达式。这意味着用于计算 $E(i)$ 的变量集合仅包含 $i$。因此，我们必须分析变量 $i$ 相对于内层循环的定义。\n\n设内层循环表示为 $L_{inner}$。在 $L_{inner}$ 的整个执行过程中，外层循环索引 $i$ 的值是恒定的。在SSA图中， $L_{inner}$ 内使用的特定版本 $i$ 的定义发生在进入 $L_{inner}$ 之前。具体来说，对于外层循环的某一次迭代， $i$ 的值是确定的。然后，控制流图进入内层循环的预备头，随后进入内层循环本身。在内层循环体内部没有对 $i$ 的赋值。根据SSA原则，一个变量的定义必须支配其所有使用。由于 $i$ 的定义在 $L_{inner}$ 之外，因此该定义支配了 $L_{inner}$ 内部所有对 $i$ 的使用。\n\n如果一个变量在循环 $L$ 的某次迭代中的值是根据其在 $L$ 的前一次迭代中的值计算出来的，那么该变量相对于循环 $L$ 具有循环携带依赖。在SSA中，这表现为定义-使用图中一个涉及 $L$ 循环头中 $\\phi$ 函数的环路。问题陈述中指出，内层循环头包含针对索引 $j$ 和累加器 $s$ 的 $\\phi$ 函数。内层循环头中没有针对 $i$ 的 $\\phi$ 函数。这证实了 $i$ 没有由内层循环携带的依赖。\n\n由于 $E(i)$ 的唯一变量操作数 $i$ 的定义在内层循环之外，根据定义，表达式 $E(i)$ 相对于内层循环是循环不变的。它不是相对于内层循环索引 $j$ 循环携带的。\n\n2.  提出一种优化方法。\n\n针对所述情况的标准优化是循环不变代码外提（Loop-Invariant Code Motion, LICM）。该优化识别出循环内每次迭代都产生相同结果的计算，并将它们移动到循环开始前执行一次。\n\n提议的转换是将 $E(i)$ 的计算从内层循环体移出，放入内层循环的预备头（preheader）。内层循环预备头是在进入内层循环（对于给定的外层循环迭代）之前仅执行一次的代码块。过程如下：\n- 引入一个新的临时变量，称之为 $t_{inv}$。\n- 将计算 $t_{inv} \\leftarrow E(i)$ 放置在内层循环的预备头中。\n- 内层循环体中所有使用 $E(i)$ 结果的地方都替换为使用 $t_{inv}$。\n\n在给定的假设下，此优化是安全的，原因如下：\n- **支配性（Dominance）**: 内层循环预备头支配内层循环内的每个代码块。因此，预备头中 $t_{inv}$ 的新定义将支配其在循环内的所有使用，满足了SSA的一个基本要求。\n- **纯粹性（Purity）**: 问题陈述中说明 $E(i)$ 是一个没有副作用（无内存修改、无I/O、无异常）的纯表达式。这保证了移动该计算不会改变程序的可见行为或状态，只会提升性能。\n- **执行保证（Execution Guarantee）**: 一个不变计算可以被安全地外提，条件是：要么它在原始程序中每次进入循环时都保证被执行，要么它的执行没有副作用。问题明确指出 $E(i)$ 是纯的，所以即使循环体可能不执行，外提也是安全的。在本特定案例中，内层循环边界是 $M(i) = i+1$。由于外层循环索引 $i$ 的范围是从 $0$ 到 $N-1$（其中 $N=100$），循环边界 $M(i)$ 总是 $\\geq 1$。这意味着对于外层循环的每次迭代，内层循环体都保证至少执行一次。因此，对 $E(i)$ 的计算不是推测性的（speculative），外提保证既安全又有利可图。\n\n问题陈述使用了“将计算下沉到...内层循环预备头中”这一术语。虽然标准的编译器文献通常将这种转换称为将代码“提升”或“提起”*出*循环，但所描述的代码移动在功能上是等效且正确的。\n\n3.  计算动态求值次数的减少量。\n\n我们需要计算在应用LICM优化前后，表达式 $E(i)$ 被动态求值的总次数。\n\n**优化前：**\n表达式 $E(i)$ 位于内层循环体内。因此，内层循环的每次迭代都会对其求值一次。外层循环对 $i \\in \\{0, 1, \\dots, N-1\\}$ 运行，对于每个 $i$，内层循环对 $j \\in \\{0, 1, \\dots, M(i)-1\\}$ 运行。对于给定的 $i$，内层循环的迭代次数是 $M(i)$。\n总求值次数 $C_{before}$ 是外层循环所有迭代中内层循环执行次数的总和。\n已知 $N=100$ 且 $M(i) = i+1$。\n$$C_{before} = \\sum_{i=0}^{N-1} M(i) = \\sum_{i=0}^{N-1} (i+1)$$\n这个和等价于前 $N$ 个正整数的和：\n$$C_{before} = 1 + 2 + 3 + \\dots + N = \\frac{N(N+1)}{2}$$\n代入 $N=100$：\n$$C_{before} = \\frac{100(100+1)}{2} = \\frac{100 \\times 101}{2} = 50 \\times 101 = 5050$$\n\n**优化后：**\n$E(i)$ 的计算已被移动到内层循环的预备头。对于外层循环的每次迭代，这个预备头恰好执行一次。外层循环运行 $N$ 次。\n因此，总求值次数 $C_{after}$ 为：\n$$C_{after} = \\sum_{i=0}^{N-1} 1 = N$$\n代入 $N=100$：\n$$C_{after} = 100$$\n\n**消除的求值次数：**\n优化所消除的动态求值总次数是优化前后的次数之差。\n$$C_{eliminated} = C_{before} - C_{after} = 5050 - 100 = 4950$$\n从解析上讲，这可以表示为：\n$$C_{eliminated} = \\frac{N(N+1)}{2} - N = \\frac{N^2+N-2N}{2} = \\frac{N^2-N}{2} = \\frac{N(N-1)}{2}$$\n当 $N=100$ 时，这证实了结果：\n$$C_{eliminated} = \\frac{100(100-1)}{2} = \\frac{100 \\times 99}{2} = 50 \\times 99 = 4950$$\n该优化总共消除了表达式 $E(i)$ 的 $4950$ 次动态求值。",
            "answer": "$$\\boxed{4950}$$"
        },
        {
            "introduction": "虽然SSA在优化标量变量方面表现出色，但真实世界的程序充满了复杂的内存操作和副作用。这个问题要求你分析当一个函数对全局内存产生副作用时，应用公共子表达式消除（Common Subexpression Elimination, CSE）的正确性。它突显了朴素值编号方法的局限性，并揭示了为保证优化安全性，编译器需要引入如内存SSA（Memory SSA）或效果摘要（effect summaries）等更高级的分析框架。",
            "id": "3660131",
            "problem": "考虑一种语言，它有一个单一的全局整数位置 $H$ 和一个函数 $g(x)$，该函数既读取也写入 $H$。函数 $g(x)$ 的定义如下：它将 $H$ 增加 $1$，然后返回 $x + H$。一个程序片段如下：\n- $H := 0$\n- $t_1 := g(a)$\n- if $(c)$ then $H := 0$ end\n- $t_2 := g(a)$\n假设编译器为所有标量变量（例如 $a$、$t_1$、$t_2$、$c$）构建静态单赋值（SSA）形式，但最初不将内存置于 SSA 形式。一个优化器尝试使用值编号（value numbering）进行全局公共子表达式消除（CSE），该值编号通过表达式的操作符及其操作数的值号来为其建立索引，除非另有说明，否则将函数调用视为仅由其被调用者和参数值号标识的黑盒操作。该优化器可以访问可选的效果摘要（effect summaries），当存在时，这些摘要会保守地描述函数可能读取或写入的内存位置。从第一性原理出发，使用以下事实作为基本依据：\n- 在 SSA 中，每个标量变量只被赋值一次，而支配关系（dominance）捕捉了定义沿每条路径到达其所有使用点的情况。\n- 当两个计算是引用透明的（referentially transparent）并且在相同的抽象状态下有相等的输入时，CSE 是正确的，这意味着它们会产生相等的结果而不改变可观察的行为。\n- 副作用（Side effects）会破坏引用透明性，而内存是读写内存操作的隐式操作数。\n- 效果摘要保守地近似了可能读取（may-read）和可能写入（may-write）的集合，使优化能够将内存视为显式操作数。\n构建并分析上述案例，以确定在存在 $g$ 的副作用的情况下，关于消除对 $g(a)$ 的第二次调用或为 $t_2$ 重用 $t_1$ 的安全性，哪些陈述是正确的。选择所有适用项。\n\nA. 因为 $a$ 未改变且 $t_1$ 支配 $t_2$，忽略内存的、基于 SSA 的值编号可以安全地用 $t_1$ 替换 $t_2$ 作为有效的 CSE。\n\nB. 如果有效果摘要指出 $g$ 可能读写 $H$，值编号必须在 $g(a)$ 的键中包含 $H$ 的内存版本 $M$；由于在某些路径上，两次调用之间的 $M$ 不同，因此这些调用不能通过 CSE 合并。\n\nC. 如果性能分析（profiling）显示带有 $H := 0$ 的分支很少被执行，优化器为了正确性可以忽略它，并仍然安全地用 $t_1$ 替换 $t_2$。\n\nD. 在 SSA 中对内存建模（内存 SSA）或使用别名分析（alias analysis）将代表 $H$ 的内存操作数附加到 $g$ 上，可以防止将这两个调用归类为公共子表达式，从而避免不正确的消除。\n\nE. 仅凭 SSA 重命名，将第一次调用 $g(a)$ 重排到初始化 $H := 0$ 之上是安全的，因为 $a$ 和 $H$ 在 SSA 中有不同的名称，因此不会相互干扰。",
            "solution": "所提供问题陈述的有效性得到确认。它在科学上基于编译器优化的原理，问题提出得很好，程序片段清晰可分析，术语客观。我们可以进行形式化分析。\n\n问题的核心是确定对一个函数 `$g(x)$` 的两次调用应用公共子表达式消除（CSE）的安全性，该函数对全局内存位置 `$H$` 具有副作用。函数 `$g(x)$` 被定义为执行两个动作：首先，它增加 `$H$`（`$H := H + 1$`），其次，它返回 `$x + H$` 的值。\n\n让我们跟踪程序片段的执行以及全局变量 `$H$` 的状态。\n\n1.  `$H := 0$`\n    内存位置 `$H$` 处的整数值被设置为 `$0$`。\n\n2.  `$t_1 := g(a)$`\n    函数 `$g(a)$` 被调用。\n    - 在 `$g$` 内部，`$H$` 首先被增加。其值从 `$0$` 变为 `$0 + 1 = 1$`。\n    - 然后，`$g$` 返回 `$a + H$`，其计算结果为 `$a + 1$`。\n    - 变量 `$t_1$` 被赋值为 `$a + 1$`。\n    - 在此语句之后，全局状态是 `$H$` 的值为 `$1$`。\n\n3.  `if (c) then H := 0 end`\n    该语句引入了一个条件分支，导致通往下一条语句有两条可能的控制流路径。\n    - **路径 1（如果 `$c$` 为真）：** 执行语句 `$H := 0$`。`$H$` 的值被重置为 `$0$`。\n    - **路径 2（如果 `$c$` 为假）：** `then` 代码块被跳过。`$H$` 的值保持为 `$1$`。\n\n4.  `$t_2 := g(a)$`\n    函数 `$g(a)$` 再次被调用。结果取决于 `if` 语句走了哪条路径。\n    - **在路径 1 上：** 在此调用之前 `$H$` 是 `$0$`。\n        - 在 `$g$` 内部，`$H$` 被增加到 `$0 + 1 = 1$`。\n        - `$g$` 返回 `$a + H$`，其计算结果为 `$a + 1$`。\n        - `$t_2$` 被赋值为 `$a + 1$`。\n    - **在路径 2 上：** 在此调用之前 `$H$` 是 `$1$`。\n        - 在 `$g$` 内部，`$H$` 被增加到 `$1 + 1 = 2$`。\n        - `$g$` 返回 `$a + H$`，其计算结果为 `$a + 2$`。\n        - `$t_2$` 被赋值为 `$a + 2$`。\n\n总之，`$t_1$` 的值始终是 `$a + 1$`。然而，如果 `$c$` 为真，`$t_2$` 的值是 `$a + 1$`，但如果 `$c$` 为假，则为 `$a + 2$`。由于在至少一条执行路径上（`$c$` 为假的路径），`$t_1 \\ne t_2$`，因此两个调用点处的表达式 `$g(a)` 在语义上是不等价的。因此，消除第二次调用并用 `$t_1$` 替换 `$t_2$` 是一种不安全的优化，会改变程序的可观察行为。\n\n基于此分析，我们评估每个提供的陈述。\n\n**A. 因为 `$a$` 未改变且 `$t_1$` 支配 `$t_2$`，忽略内存的、基于 SSA 的值编号可以安全地用 `$t_1$` 替换 `$t_2$` 作为有效的 CSE。**\n这个陈述描述了一个天真（naive）优化器的推理。变量 `$a$` 在两次调用之间确实是循环不变的，并且 `$t_1$` 的定义支配 `$t_2$` 的定义。一个“忽略内存”的优化器会通过被调用者和参数 `$a$` 的值号来为两个函数调用建立索引，即 `$(g, \\text{value\\_number}(a))$`。由于这些键是相同的，它会错误地将这两个调用识别为公共子表达式。该陈述的核心缺陷是声称这种替换是“安全的”。正如我们的跟踪所证明的，它是不安全的，因为它未能考虑对 `$H$` 的副作用，而 `$H$` 是 `$g(a)` 的一个隐式输入。副作用破坏引用透明性的原则被违反了。\n**结论：不正确。**\n\n**B. 如果有效果摘要指出 `$g$` 可能读写 `$H$`，值编号必须在 `$g(a)$` 的键中包含 `$H$` 的内存版本 `$M$`；由于在某些路径上，两次调用之间的 `$M$` 不同，因此这些调用不能通过 CSE 合并。**\n这个陈述描述了一种正确的、更复杂的优化策略。效果摘要会告知优化器 `$g(a)$` 读写 `$H$`。为了正确应用 CSE，优化器必须将内存视为显式操作数。这通常使用内存版本或标记（token）来建模。\n- 设 `$M_0$` 表示初始赋值后 `$H=0$` 的内存状态。第一次调用 `$g(a)$` 依赖于 `$M_0$`。\n- 这次调用产生一个新的内存状态 `$M_1$`，其中 `$H=1$`。\n- `if` 语句有条件地产生另一个状态 `$M_2$`，其中 `$H=0$`。\n- 第二次调用之前的内存状态 `$M_3$` 是两条路径（`$M_1$` 和 `$M_2$`）状态的合并。这个合并后的状态与初始状态 `$M_0$` 不同。\n因为第一次调用的输入内存状态（`$M_0$`）与第二次调用的输入内存状态（`$M_3$`）不同，所以两次调用的值编号键会不同。因此，优化器将正确地得出结论，它们不是公共子表达式。\n**结论：正确。**\n\n**C. 如果性能分析（profiling）显示带有 `$H := 0$` 的分支很少被执行，优化器为了正确性可以忽略它，并仍然安全地用 `$t_1$` 替换 `$t_2$`。**\n这个陈述建议基于性能分析数据为了性能而牺牲可靠性（soundness）。编译器正确性要求转换在所有可能的执行路径上都保持程序语义，而不仅仅是最频繁的路径。即使 `$c$` 为真的路径很少见，声称正确的优化器也必须处理它。此外，即使在 `$c$` 为假的“常见”路径上，我们的分析也显示 `$t_1 = a + 1$` 而 `$t_2 = a + 2$`。因此，在该路径上替换也是不正确的。性能分析可以指导推测性优化（speculative optimizations，必须有恢复机制），但不能在“安全”和“正确”的旗号下为语义上不正确的转换辩护。\n**结论：不正确。**\n\n**D. 在 SSA 中对内存建模（内存 SSA）或使用别名分析（alias analysis）将代表 `$H$` 的内存操作数附加到 `$g$` 上，可以防止将这两个调用归类为公共子表达式，从而避免不正确的消除。**\n这个陈述描述了两种用于处理内存依赖关系的标准且可靠（sound）的编译器框架。\n- **内存 SSA（Memory SSA）** 是 SSA 到内存的形式化扩展。它为内存状态提供版本，并在连接点（join points）使用 `$\\phi$` 函数。正如选项 B 的分析所示，第一次调用之前的内存状态版本将不同于第二次调用之前的 `$\\phi$` 版本，从而将它们区分开来。\n- **带内存操作数的别名分析（Alias analysis）** 使对内存的依赖变得显式。别名分析识别出 `$g$` 访问全局变量 `$H$`。编译器随后可以将调用建模为仿佛它接受了一个额外的、不可见的参数来表示 `$H$` 的状态，例如 `$t_1 := g(a, H_{\\text{in}})$`。由于两次调用前 `$H$` 的状态不同，因此调用不是相同的，也就不构成公共子表达式。\n这两种方法都正确地防止了不安全的 CSE。\n**结论：正确。**\n\n**E. 仅凭 SSA 重命名，将第一次调用 `$g(a)$` 重排到初始化 `$H := 0$` 之上是安全的，因为 `$a$` 和 `$H$` 在 SSA 中有不同的名称，因此不会相互干扰。**\n这个陈述在多个方面都是不正确的。首先，重排序是不安全的。原始序列是 `$H := 0; t_1 := g(a);$`。调用 `$g(a)` 读取了前一条语句写入的 `$H$` 的值。这构成了真依赖（Read-After-Write，或 RAW）。对具有真依赖的语句进行重排序是非法的，因为它会改变程序语义。其次，理由是无效的。问题指明内存*不*是 SSA 形式，所以 `$H$` 没有 SSA 名称。即使有，SSA 重命名也用于打破假依赖（写后读和写后写），而不是真依赖（读后写）。\n**结论：不正确。**",
            "answer": "$$\\boxed{BD}$$"
        }
    ]
}