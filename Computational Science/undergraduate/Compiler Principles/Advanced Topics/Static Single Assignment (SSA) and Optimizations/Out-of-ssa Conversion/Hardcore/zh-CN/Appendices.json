{
    "hands_on_practices": [
        {
            "introduction": "在将程序从静态单赋值（SSA）形式转换出来时，一个核心挑战是如何处理由 $\\phi$ 函数引发的并行复制语义。此练习  让你直面最典型的问题：当两个变量需要互相交换值时（即 $x \\leftarrow y$ 和 $y \\leftarrow x$），如何用一系列顺序的移动指令来实现这种并行交换。通过解决这个问题，你将掌握打破复制循环所需的基本策略和最小资源。",
            "id": "3660448",
            "problem": "考虑一个控制流图，其中有两个前驱块 $B_1$ 和 $B_2$，它们都分支到一个汇合块 $J$。该程序处于静态单赋值（SSA）形式，其中每个变量仅被赋值一次，并且 $J$ 中的 $\\phi$ 节点根据控制流路径选择传入的值。$\\phi$ 节点的语义等同于在指向 $J$ 的入边上插入并行拷贝，这意味着在每条边上所有拷贝同时执行。\n\n假设程序如下。在 $B_1$ 中：\n$x_1 := \\text{val}_x$，$y_1 := \\text{val}_y$，然后控制流转向 $J$。在 $B_2$ 中：$x_2 := \\text{val}_x'$，$y_2 := \\text{val}_y'$，然后控制流转向 $J$。在 $J$ 中：\n$$x_3 := \\phi(y_1, x_2) \\quad \\text{和} \\quad y_3 := \\phi(x_1, y_2)$$\n随后是使用 $r := x_3 + y_3$。在去 SSA 化（out-of-SSA conversion）过程中，假设一种标准的合并策略，该策略旨在将 $x_3$ 映射到非 SSA 变量 $x$，将 $y_3$ 映射到 $y$，并且在 $B_1$ 中也将 $x_1$ 映射到 $x$、将 $y_1$ 映射到 $y$（$B_2$ 中也类似）。在这些假设下，$\\phi$ 赋值在边 $B_1 \\to J$ 上引发了以下并行拷贝：\n$x \\leftarrow y$ 和 $y \\leftarrow x$，形成一个移动环。你可以假设变量 $x$ 和 $y$ 在边 $B_1 \\to J$ 上都是活跃的。\n\n使用 SSA 语义和去 SSA 化的基本原理（并行拷贝语义和串行移动实现），构建在 $B_1 \\to J$ 上引发的移动环，然后推导出一个使用最少临时变量的策略，以通过串行移动实现这些并行拷贝，而不违反程序语义。具体来说，将这些拷贝建模为一个关于变量的有向图，其中一条边 $u \\to v$ 表示一个必要的移动 $v \\leftarrow u$。基于这些定义，论证如何调度无环移动以及如何打破环。\n\n在上述假设下，计算正确实现环 $x \\leftarrow y, y \\leftarrow x$ 所需的最少临时变量数量。你的最终答案必须是一个精确的整数，无需四舍五入。",
            "solution": "问题要求分析静态单赋值（SSA）形式的转换输出过程，特别是实现由 $\\phi$ 节点引发的并行拷贝。我们必须确定正确地将一个特定的移动环串行化所需的最少临时变量数量。\n\n首先，我们根据提供的信息对设置进行形式化。该程序处于 SSA 形式。在块 $B_1$ 中，有赋值 $x_1 := \\text{val}_x$ 和 $y_1 := \\text{val}_y$。在块 $B_2$ 中，有 $x_2 := \\text{val}_x'$ 和 $y_2 := \\text{val}_y'$。两个块都分支到汇合块 $J$。在 $J$ 中，两个 $\\phi$ 节点合并了传入的值：\n$$\nx_3 := \\phi(y_1, x_2) \\\\\ny_3 := \\phi(x_1, y_2)\n$$\n$\\phi$ 节点的语义被定义为在传入的控制流边上的并行拷贝。我们关注从 $B_1$ 到 $J$ 的边。对于这条路径，有效的赋值由 $\\phi$ 节点的第一个参数指定：\n$$\nx_3 \\leftarrow y_1 \\\\\ny_3 \\leftarrow x_1\n$$\n这些赋值必须同时执行。\n\n问题指出，在去 SSA 化过程中，应用了一种合并策略。SSA 变量 $\\{x_1, x_2, x_3\\}$ 都被映射到单个非 SSA 变量 $x$，而 $\\{y_1, y_2, y_3\\}$ 被映射到单个非 SSA 变量 $y$。将此映射应用于边 $B_1 \\to J$ 的并行拷贝语义，我们替换 $x_3 \\to x$，$y_1 \\to y$，$y_3 \\to y$ 和 $x_1 \\to x$：\n$$\nx \\leftarrow y \\\\\ny \\leftarrow x\n$$\n这意味着在遍历从 $B_1$ 到 $J$ 的边时，非 SSA 变量 $x$ 的值必须更新为 $y$ 的原始值，同时，$y$ 的值必须更新为 $x$ 的原始值。这是一个经典的交换操作。\n\n问题要求将这些拷贝建模为一个有向图，其中一条边 $u \\to v$ 表示移动 $v \\leftarrow u$。根据这个约定：\n\\begin{itemize}\n    \\item 拷贝 $x \\leftarrow y$ 由一条从 $y$ 到 $x$ 的有向边表示：$y \\to x$。\n    \\item 拷贝 $y \\leftarrow x$ 由一条从 $x$ 到 $y$ 的有向边表示：$x \\to y$。\n\\end{itemize}\n最终得到的图包含两个节点 $x$ 和 $y$，以及两条边，形成一个长度为 2 的环：$x \\to y \\to x$。\n\n任务是使用一系列简单的移动指令来实现这些并行拷贝。让我们将拷贝前 $x$ 和 $y$ 的值表示为 $x_{\\text{old}}$ 和 $y_{\\text{old}}$。期望的最终状态是 $x = y_{\\text{old}}$ 和 $y = x_{\\text{old}}$。\n\n让我们考虑尝试使用零个临时变量，仅通过 $x$ 和 $y$ 之间的串行移动来实现这一点。有两种可能的顺序：\n\n情况 1：首先执行 $x \\leftarrow y$。\n1. $x := y$：变量 $x$ 现在持有值 $y_{\\text{old}}$。原始值 $x_{\\text{old}}$ 被覆盖并丢失。\n2. $y := x$：变量 $y$ 被赋为 $x$ 的当前值，即 $y_{\\text{old}}$。\n最终状态是 $x = y_{\\text{old}}$ 和 $y = y_{\\text{old}}$。这是不正确的，因为 $y$ 应该是 $x_{\\text{old}}$。\n\n情况 2：首先执行 $y \\leftarrow x$。\n1. $y := x$：变量 $y$ 现在持有值 $x_{\\text{old}}$。原始值 $y_{\\text{old}}$ 被覆盖并丢失。\n2. $x := y$：变量 $x$ 被赋为 $y$ 的当前值，即 $x_{\\text{old}}$。\n最终状态是 $y = x_{\\text{old}}$ 和 $x = x_{\\text{old}}$。这也是不正确的，因为 $x$ 应该是 $y_{\\text{old}}$。\n\n在这两种情况下，第一个串行移动都会破坏第二个移动所需的值。这种现象被称为“丢失拷贝”问题。因此，不可能使用零个临时变量来正确实现这个特定的移动环。所需的最少临时变量数量必须大于 $0$。\n\n现在，让我们考虑使用一个临时变量，称之为 $t$。打破移动环的策略是首先将环中一个变量的值保存到临时变量中。\n1. 将一个变量（比如 $x$）的值保存到临时变量中：$t \\leftarrow x$。（$t$ 现在持有 $x_{\\text{old}}$）\n2. 现在可以安全地覆盖变量 $x$。执行以 $x$ 为目标的移动：$x \\leftarrow y$。（$x$ 现在持有 $y_{\\text{old}}$，这是正确的）。\n3. 更新 $y$ 需要 $x$ 的原始值。这个值已保存在 $t$ 中。执行移动：$y \\leftarrow t$。（$y$ 现在持有 $x_{\\text{old}}$，这是正确的）。\n\n这三个移动的序列（$t \\leftarrow x$，$x \\leftarrow y$，$y \\leftarrow t$）正确地实现了并行交换。最终状态是 $x = y_{\\text{old}}$ 和 $y = x_{\\text{old}}$，符合要求。\n\n既然我们已经证明了 $0$ 个临时变量是不够的，而 $1$ 个临时变量是足够的，那么正确实现该环所需的最少临时变量数量是 $1$。这是一个通用结论，对于解决任何长度 $k \\ge 2$ 的单个移动环，一个临时变量是必要且充分的。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "实际的 $\\phi$ 函数集通常会产生多种类型的复制需求，而不仅仅是简单的循环。本练习  将带你进入一个更真实的场景，其中包含一个双向复制循环、一个简单的非循环复制以及一个可以忽略的平凡复制。你需要根据不同的控制流路径，为每种情况制定正确的指令序列，从而全面理解并行复制的分解过程。",
            "id": "3660371",
            "problem": "考虑一个控制流图，其中有两个前驱基本块 $B_1$ 和 $B_2$ 汇合于基本块 $B_J$。基本块 $B_J$ 处于静态单赋值 (SSA) 形式，并在其入口处包含两个 $\\phi$-函数：\n$$\nx \\leftarrow \\phi(x, y), \\quad y \\leftarrow \\phi(z, x).\n$$\n假设以下程序事实，这些事实与标准 SSA 语义一致：\n- 在 $B_1$ 中，变量 $x$ 在边 $B_1 \\to B_J$ 上是出口活跃的，并且当控制流从 $B_1$ 进入 $B_J$ 时必须保持其当前值；变量 $z$ 在 $B_1$ 的末尾是可用的。\n- 在 $B_2$ 中，变量 $x$ 和 $y$ 在边 $B_2 \\to B_J$ 上都是出口活跃的。\n- $\\phi$-函数的 SSA 语义是：在 $B_J$ 开始处的赋值 $v \\leftarrow \\phi(v_1, v_2)$ 会在控制流来自 $B_1$ 时选择 $v_1$，在控制流来自 $B_2$ 时选择 $v_2$。\n\n为了消除 SSA 形式（退出 SSA 转换），使用基于边的并行复制策略：对于进入 $B_J$ 的每条入边，$\\phi$-函数的参数会同时复制到它们在 $B_J$ 中的目标位置。假设所有关键边都已被拆分到专用的空移动块中，因此每条边上的并行复制可以被降级为一系列普通复制指令，这些指令放置在前驱块的最后一次使用之后、进入 $B_J$ 之前。形如 $v \\leftarrow v$ 的平凡自复制被省略。不执行跨越不同 $\\phi$-结果的副本合并；每个 $\\phi$-结果在 $B_J$ 中都有其自己的目标名称。\n\n在这些条件下，确定必须在两条入边 $B_1 \\to B_J$ 和 $B_2 \\to B_J$ 上插入的普通复制指令的最小总数，以忠实地实现这两个 $\\phi$-函数，并确保当控制流来自 $B_1$ 时 $x$ 保持其先前的值。\n\n你的答案必须是一个没有单位的整数，并且不需要四舍五入。",
            "solution": "出发点是静态单赋值 (SSA) 形式和 $\\phi$-函数的语义。在 SSA 中，每个变量赋值都是唯一的，而块 $B_J$ 开始处的 $\\phi$-函数会根据所采用的前驱边选择相应的传入参数。具体来说，对于 $B_J$ 中的 $x \\leftarrow \\phi(x, y)$ 和 $y \\leftarrow \\phi(z, x)$，如果控制流来自 $B_1$，则赋值为 $x \\leftarrow x$ 和 $y \\leftarrow z$；如果控制流来自 $B_2$，则赋值为 $x \\leftarrow y$ 和 $y \\leftarrow x$。\n\n通过基于边的并行复制策略进行的 SSA 退出转换，会为每条入边实现所有 $\\phi$-参数到其目标的同时赋值。由于普通的机器复制是顺序执行的，并且可能会覆盖源值，因此必须谨慎地降级并行复制。一个基本的观察是，一个并行复制集可以表示为一个有向依赖图，其顶点是变量，其边是对于每个从源 $s$ 到目标 $d$ 的复制所对应的 $d \\leftarrow s$。如果该图包含环，则需要临时变量来打破环，以便顺序执行能够保留并行语义。对于一个长度为 $m$ 的环，一个临时变量就足够了，实现该并行复制所需的最小普通复制指令数为 $m + 1$，其构造方法是：首先将一个值保存到临时变量中，然后沿环执行 $m - 1$ 次前向复制，最后从临时变量中恢复该值。\n\n我们现在列举每条入边上的并行复制集：\n\n- 在边 $B_1 \\to B_J$ 上，$\\phi$-语义产生以下并行复制：\n  $$\n  x \\leftarrow x, \\quad y \\leftarrow z.\n  $$\n  复制 $x \\leftarrow x$ 是一个平凡的自复制，因此被省略。剩下的复制 $y \\leftarrow z$ 是无环的（在这条边上没有从 $z$ 回到 $y$ 的依赖关系），可以降级为单个普通复制指令。由于 $x$ 从 $B_1$ 出口活跃，并且在到达 $B_J$ 时必须保持其当前值，省略 $x \\leftarrow x$ 满足了该要求：在 $B_1 \\to B_J$ 上没有操作会覆盖 $x$。\n\n  因此，边 $B_1 \\to B_J$ 贡献了 $1$ 条普通复制指令。\n\n- 在边 $B_2 \\to B_J$ 上，$\\phi$-语义产生以下并行复制：\n  $$\n  x \\leftarrow y, \\quad y \\leftarrow x.\n  $$\n  这在 $x$ 和 $y$ 之间形成了一个长度为 $2$ 的环。如前所述，当使用单个临时变量进行降级时，一个长度为 $m$ 的环需要 $m + 1$ 条普通复制指令。设 $t$ 为一个新的临时变量。一个正确的降级是：\n  $$\n  t \\leftarrow x, \\quad x \\leftarrow y, \\quad y \\leftarrow t,\n  $$\n  这使用了 $1$ 个临时变量和 $3$ 条普通复制指令。这个序列实现了并行语义，而不会过早地覆盖值，因为相对于 $\\phi$ 语义，$x$ 和 $y$ 的保存和更新是原子性的。\n\n  因此，边 $B_2 \\to B_J$ 贡献了 $3$ 条普通复制指令。\n\n将两条边上的贡献相加，普通复制指令的最小总数为\n$$\n1 + 3 = 4.\n$$\n\n在所述约束条件下，不可能进行进一步的简化：平凡的自复制已被省略，无环复制各产生一个操作，而长度为2的环则需要一个临时变量和恰好 $3$ 个操作来保留并行复制语义。\n\n因此，插入的普通复制指令的最小总数为 $4$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "当寄存器分配已经确定时，退出 SSA 的过程会变得更加复杂，因为它可能引入复杂的依赖关系图。这个高级练习  模拟了这样一个场景，其中多个 $\\phi$ 函数在预设的寄存器分配下交织在一起，形成一个复杂的并行复制网络。你的任务是构建并分析这个网络的依赖图，识别并分解其中的多个复制循环，最终以最少的移动指令完成转换。",
            "id": "3660351",
            "problem": "考虑一个处于静态单赋值（SSA）形式的控制流汇合块 $B$，它有两个前驱 $P$ 和 $Q$。块 $B$ 包含六个 $\\phi$ 函数，其中三个通过共享来自 $P$ 的相同传入 SSA 版本，在边 $P \\to B$ 上形成了一个 $\\phi$-web。这些 $\\phi$ 函数及其传入参数如下：\n- $x_{1} \\gets \\phi(P: a,\\; Q: e)$\n- $x_{2} \\gets \\phi(P: a,\\; Q: f)$\n- $x_{3} \\gets \\phi(P: a,\\; Q: g)$\n- $x_{4} \\gets \\phi(P: b,\\; Q: h)$\n- $x_{5} \\gets \\phi(P: c,\\; Q: i)$\n- $x_{6} \\gets \\phi(P: d,\\; Q: j)$\n\n假设寄存器分配由一个到机器寄存器 $R_{0}, R_{1}, R_{2}, R_{3}, R_{4}, R_{5}$ 的映射 $\\rho(\\cdot)$ 预先确定，如下所示：\n- 来自 $P$ 的源：$\\rho(a)=R_{0},\\; \\rho(b)=R_{1},\\; \\rho(c)=R_{2},\\; \\rho(d)=R_{3}$。\n- 来自 $Q$ 的源：$\\rho(e)=R_{2},\\; \\rho(f)=R_{3},\\; \\rho(g)=R_{1},\\; \\rho(h)=R_{0},\\; \\rho(i)=R_{5},\\; \\rho(j)=R_{4}$。\n- 在 $B$ 中的目标：$\\rho(x_{1})=R_{1},\\; \\rho(x_{2})=R_{2},\\; \\rho(x_{3})=R_{3},\\; \\rho(x_{4})=R_{0},\\; \\rho(x_{5})=R_{4},\\; \\rho(x_{6})=R_{5}$。\n\nSSA 消除转换是通过在每个传入边上插入一个并行复制来实现的，该并行复制实现了该边上 $\\phi$ 函数规定的同时赋值。并行复制语义要求在写入任何左侧之前，从其源读取每个右侧的值。实现模型只允许形式为 $u := v$ 的寄存器到寄存器的移动，并且只有一个额外的临时寄存器 $T$（不是 $R_{0},\\ldots,R_{5}$ 中的任何一个），没有可用的交换指令。\n\n仅从 SSA $\\phi$ 语义和并行复制语义的定义出发，不假设任何特殊的快捷公式，确定在利用 $P \\to B$ 边上 $a$ 的 $\\phi$-web 共享以避免不必要的保存和重载的最优调度下，实现两条边 $P \\to B$ 和 $Q \\to B$ 上的 SSA 消除并行复制所需的寄存器到寄存器移动指令的最小总数。将你的答案以单个整数形式给出。不需要四舍五入，也不涉及物理单位。",
            "solution": "该问题要求确定为具有两个前驱边 $P \\to B$ 和 $Q \\to B$ 的汇合块 $B$ 实现 SSA 消除并行复制所需的寄存器到寄存器移动指令的最小总数。我们必须分别分析每条边并将其成本相加。分析必须从并行复制的语义推导出来，而不借助于未说明的特殊公式。并行复制规定，在修改任何目标寄存器之前，必须读取所有源值。\n\n**对边 $P \\to B$ 的分析**\n\n首先，我们形式化边 $P \\to B$ 上所需的并行复制。$\\phi$ 函数定义了以下赋值：\n- $x_{1} \\gets a$\n- $x_{2} \\gets a$\n- $x_{3} \\gets a$\n- $x_{4} \\gets b$\n- $x_{5} \\gets c$\n- $x_{6} \\gets d$\n\n应用给定的寄存器分配映射 $\\rho(\\cdot)$，我们将这些赋值转换为寄存器到寄存器的传输：\n- $\\rho(x_{1}) \\gets \\rho(a) \\implies R_{1} := R_{0}$\n- $\\rho(x_{2}) \\gets \\rho(a) \\implies R_{2} := R_{0}$\n- $\\rho(x_{3}) \\gets \\rho(a) \\implies R_{3} := R_{0}$\n- $\\rho(x_{4}) \\gets \\rho(b) \\implies R_{0} := R_{1}$\n- $\\rho(x_{5}) \\gets \\rho(c) \\implies R_{4} := R_{2}$\n- $\\rho(x_{6}) \\gets \\rho(d) \\implies R_{5} := R_{3}$\n\n为了确定最小的移动序列，我们构建一个依赖图 $G_P = (V, E)$，其中 $V$ 是寄存器集合 $\\{R_{0}, R_{1}, R_{2}, R_{3}, R_{4}, R_{5}\\}$，一条边 $(u, v) \\in E$ 表示一个复制 $v := u$。这些边是：\n- $R_{0} \\to R_{1}$\n- $R_{0} \\to R_{2}$\n- $R_{0} \\to R_{3}$\n- $R_{1} \\to R_{0}$\n- $R_{2} \\to R_{4}$\n- $R_{3} \\to R_{5}$\n\n分析 $G_P$ 的结构：\n该图揭示了寄存器 $R_{0}$ 和 $R_{1}$ 之间存在一个 2-环（即 $R_{0} \\to R_{1}$ 和 $R_{1} \\to R_{0}$）。解决这样的环需要打破它，因为无论先执行哪个复制都会破坏另一个复制所需的值。这需要使用临时寄存器 $T$。\n\n寄存器 $R_{0}$ 是这个环的一部分，同时也是三个不同复制（$\\phi$-web）的源。寄存器 $R_{1}$ 也是这个环的一部分。为了打破这个环，我们必须保存 $R_{0}$ 或 $R_{1}$ 的值。由于 $R_{0}$ 中的值是三个目标（$R_{1}, R_{2}, R_{3}$）所需要的，而它自己的目标寄存器将被来自 $R_{1}$ 的值覆盖，因此最优策略是将 $R_{0}$ 的值保存到临时寄存器 $T$ 中。这个单一的保存使其值可用于所有预期的目标。\n\n1.  $T := R_{0}$：保存 $R_{0}$ 的值（来自变量 $a$）。这需要 $1$ 次移动。\n\n在这次移动之后，所需并行传输的集合在概念上发生了转变。任何需要 $R_{0}$ 原始值的传输现在都需要来自 $T$ 的值。新的传输集合是：\n- $R_{1} := T$\n- $R_{2} := T$\n- $R_{3} := T$\n- $R_{0} := R_{1}$\n- $R_{4} := R_{2}$\n- $R_{5} := R_{3}$\n\n这个新传输集合的依赖图是无环的。我们现在可以生成一个尊重剩余依赖关系的移动序列。一个复制 $d := s$ 可以被执行，如果它的目标 $d$ 不是任何其他待处理复制的源。\n- 复制 $R_{0} := R_{1}$、$R_{4} := R_{2}$ 和 $R_{5} := R_{3}$ 的目标（$R_{0}, R_{4}, R_{5}$）不是任何其他剩余复制的源。然而，它们的源（$R_{1}, R_{2}, R_{3}$）是其他复制的目标。为了遵守并行复制语义，我们必须在这些寄存器被覆盖之前，执行消耗 $R_1, R_2, R_3$ 原始值的复制。\n\n一个有效的最小移动序列构建如下：\n1.  $T := R_{0}$：保存 $R_{0}$ 的值。（$1$ 次移动）\n2.  $R_{0} := R_{1}$：现在将 $R_{1}$ 的值复制到 $R_{0}$。这是安全的，因为 $R_{0}$ 的原始值在 $T$ 中。（$1$ 次移动）\n3.  $R_{4} := R_{2}$：将 $R_{2}$ 的原始值复制到 $R_{4}$。这必须在 $R_{2}$ 被更新之前发生。（$1$ 次移动）\n4.  $R_{5} := R_{3}$：将 $R_{3}$ 的原始值复制到 $R_5$。这必须在 $R_{3}$ 被更新之前发生。（$1$ 次移动）\n5.  $R_{1} := T$：将保存的 $R_{0}$ 的值复制到 $R_{1}$。与步骤1和2一起，这完成了 $R_0$ 和 $R_1$ 的循环交换。（$1$ 次移动）\n6.  $R_{2} := T$：将保存的 $R_{0}$ 的值复制到 $R_{2}$。（$1$ 次移动）\n7.  $R_{3} := T$：将保存的 $R_{0}$ 的值复制到 $R_{3}$。（$1$ 次移动）\n\n这个序列正确地实现了所有传输。总移动次数为 $7$。这是最小的，因为有 $6$ 个基本赋值要执行，而单个环需要一次额外的移动来使用临时寄存器打破它。\n\n**对边 $Q \\to B$ 的分析**\n\n接下来，我们形式化边 $Q \\to B$ 的并行复制。$\\phi$ 函数定义了以下赋值：\n- $x_{1} \\gets e$\n- $x_{2} \\gets f$\n- $x_{3} \\gets g$\n- $x_{4} \\gets h$\n- $x_{5} \\gets i$\n- $x_{6} \\gets j$\n\n应用寄存器分配映射 $\\rho(\\cdot)$：\n- $\\rho(x_{1}) \\gets \\rho(e) \\implies R_{1} := R_{2}$\n- $\\rho(x_{2}) \\gets \\rho(f) \\implies R_{2} := R_{3}$\n- $\\rho(x_{3}) \\gets \\rho(g) \\implies R_{3} := R_{1}$\n- $\\rho(x_{4}) \\gets \\rho(h) \\implies R_{0} := R_{0}$\n- $\\rho(x_{5}) \\gets \\rho(i) \\implies R_{4} := R_{5}$\n- $\\rho(x_{6}) \\gets \\rho(j) \\implies R_{5} := R_{4}$\n\n复制 $R_{0} := R_{0}$ 是一个空操作，需要 $0$ 次移动。我们分析剩下的五个非平凡传输。依赖图 $G_Q$ 由以下边组成：\n- $R_{2} \\to R_{1}$\n- $R_{3} \\to R_{2}$\n- $R_{1} \\to R_{3}$\n- $R_{5} \\to R_{4}$\n- $R_{4} \\to R_{5}$\n\n图 $G_Q$ 分解为两个不相交的分量：\n1.  一个 3-环：$R_{1} \\to R_{3} \\to R_{2} \\to R_{1}$。\n2.  一个 2-环：$R_{4} \\leftrightarrow R_{5}$。\n\n我们必须使用临时寄存器 $T$ 来解决每个环。由于这些分量是不相交的，我们可以顺序解决它们，并重用 $T$。\n\n要解决 $\\{R_{1}, R_{2}, R_{3}\\}$ 上的 3-环，它涉及 $3$ 个寄存器，我们需要 $3+1 = 4$ 次移动：\n1.  $T := R_{1}$ （保存环中任意一个寄存器的值，例如 $R_1$）\n2.  $R_{1} := R_{2}$\n3.  $R_{2} := R_{3}$\n4.  $R_{3} := T$ （恢复保存的值以完成该环）\n这个子问题需要 $4$ 次移动。\n\n要解决 $\\{R_{4}, R_{5}\\}$ 上的 2-环，它涉及 $2$ 个寄存器，我们需要 $2+1 = 3$ 次移动。寄存器 $T$ 再次可用。\n1.  $T := R_{4}$ （保存 $R_4$ 的值）\n2.  $R_{4} := R_{5}$\n3.  $R_{5} := T$ （恢复保存的值）\n这个子问题需要 $3$ 次移动。\n\n边 $Q \\to B$ 的总移动次数是每个不相交分量移动次数的总和：$4 + 3 = 7$。\n\n**最小移动总数**\n\n最小移动总数是每条边所需移动次数的总和：\n总移动次数 = ($P \\to B$ 的移动次数) + ($Q \\to B$ 的移动次数) = $7 + 7 = 14$。\n\n最终答案是 $14$。",
            "answer": "$$\\boxed{14}$$"
        }
    ]
}