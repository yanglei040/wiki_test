{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a classic demonstration of Conditional Constant Propagation's core strength: path pruning. By simulating the algorithm on a simple diamond-shaped control flow graph, you will see firsthand how evaluating a condition with a constant value can render an entire code path unreachable. This practice solidifies the fundamental concept of simplifying $\\phi$ functions by eliminating inputs from non-executable paths .",
            "id": "3630643",
            "problem": "Consider the following program in Static Single Assignment (SSA) form and its diamond-shaped Control Flow Graph (CFG). The program uses the standard semantics of the SSA $\\phi$-function at merge points. You are to apply Conditional Constant Propagation (CCP) to determine the constant value computed at the exit.\n\nBlocks and statements:\n- Entry block $B_{0}$:\n  - $a_{0} := 7$\n  - $b_{0} := a_{0} - a_{0}$\n  - `if` ($b_{0} == 1$) `then goto` $B_{1}$ `else goto` $B_{2}$\n- Then block $B_{1}$:\n  - $c_{1} := 11$\n  - `goto` $B_{3}$\n- Else block $B_{2}$:\n  - $c_{2} := 17$\n  - `goto` $B_{3}$\n- Merge block $B_{3}$:\n  - $c_{3} := \\phi(c_{1}, c_{2})$\n  - $r := 3c_{3} - 2$\n\nYou must reason from the foundational definitions of data-flow analysis as they apply to CCP:\n- The CCP value domain is the three-point constant propagation lattice $D = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$, where $\\bot$ denotes “uninitialized/unreachable,” any $z \\in \\mathbb{Z}$ denotes a known integer constant, and $\\top$ denotes “unknown/non-constant.”\n- Transfer functions evaluate operations on known constants using standard arithmetic semantics.\n- A conditional branch with a known-constant predicate determines edge feasibility and reachability.\n- An SSA $\\phi$-function yields the incoming value from a predecessor that is actually feasible; if multiple feasible predecessors provide the same known constant, the result is that constant; otherwise, if multiple feasible predecessors remain but the values differ or are not constant, the result is $\\top$.\n\nStarting from these foundations, simulate CCP on the given diamond-shaped CFG. The guard in $B_{0}$ may create a contradiction that affects reachability of one branch. After CCP stabilizes and all possible constant foldings are performed, compute the exact value of $r$ at the exit of block $B_{3}$.\n\nGive your final answer as a single exact integer. No rounding is required.",
            "solution": "The problem requires the application of the Conditional Constant Propagation (CCP) algorithm to a given program in Static Single Assignment (SSA) form to determine the final value of the variable $r$. The CCP algorithm integrates constant propagation with reachability analysis. The state of the analysis for each variable is maintained on the three-point lattice $D = \\{\\bot, \\mathbb{Z}, \\top\\}$, where $\\bot$ signifies that a variable is uninitialized or its defining code is unreachable, any integer $z \\in \\mathbb{Z}$ represents a known constant value, and $\\top$ signifies a value that is not a constant.\n\nThe analysis proceeds by simulating the program's execution, updating the lattice values of variables and determining the feasibility of control flow paths. We maintain a map of lattice values for all variables, initialized to $\\bot$:\n$Val(a_{0}) = \\bot$, $Val(b_{0}) = \\bot$, $Val(c_{1}) = \\bot$, $Val(c_{2}) = \\bot$, $Val(c_{3}) = \\bot$, $Val(r) = \\bot$.\n\nWe also track the reachability of each basic block. Initially, only the entry block $B_{0}$ is reachable.\n\n1.  **Analysis of Entry Block $B_0$**:\n    This block is the entry point and is therefore reachable. We analyze its statements in order.\n    -   Statement $a_{0} := 7$: The variable $a_{0}$ is assigned the constant value $7$. Its lattice value is updated from $\\bot$ to $7$. So, $Val(a_{0}) = 7$.\n    -   Statement $b_{0} := a_{0} - a_{0}$: The transfer function for subtraction is applied to the lattice value of $a_{0}$. Since $Val(a_{0}) = 7$, a known constant, the expression evaluates to $7 - 7 = 0$. The lattice value of $b_{0}$ is updated from $\\bot$ to $0$. So, $Val(b_{0}) = 0$.\n    -   Statement `if` ($b_{0} == 1$) `then goto` $B_{1}$ `else goto` $B_{2}$: This is a conditional branch. The predicate involves the variable $b_{0}$, for which we have a constant value $Val(b_{0}) = 0$. The condition is evaluated as $0 == 1$, which is definitively `false`.\n    -   According to the principles of CCP, a conditional branch with a known-constant predicate determines edge feasibility. Since the predicate is false, the `then` branch to block $B_{1}$ is determined to be non-executable, and the `else` branch to block $B_{2}$ is determined to be executable.\n    -   This means block $B_{1}$ is unreachable, while block $B_{2}$ is reachable.\n\n2.  **Analysis of Then Block $B_1$**:\n    -   As determined from the analysis of $B_{0}$, block $B_{1}$ is unreachable. Therefore, the statements within it are never executed during the abstract interpretation.\n    -   The statement $c_{1} := 11$ is not processed.\n    -   The lattice value of $c_{1}$ remains at its initial state, $Val(c_{1}) = \\bot$.\n\n3.  **Analysis of Else Block $B_2$**:\n    -   This block is reachable via the edge from $B_{0}$. We analyze its statements.\n    -   Statement $c_{2} := 17$: The variable $c_{2}$ is assigned the constant value $17$. Its lattice value is updated from $\\bot$ to $17$. So, $Val(c_{2}) = 17$.\n    -   Statement `goto` $B_{3}$: This is an unconditional jump. The edge from $B_{2}$ to $B_{3}$ is executable, which makes the merge block $B_{3}$ reachable.\n\n4.  **Analysis of Merge Block $B_3$**:\n    -   This block is reachable. We analyze its statements.\n    -   Statement $c_{3} := \\phi(c_{1}, c_{2})$: This SSA $\\phi$-function merges values from the predecessor blocks, $B_{1}$ and $B_{2}$. The CCP rule for a $\\phi$-function is to consider only the inputs from feasible predecessor paths.\n    -   The predecessor path from $B_{1}$ is non-executable. The value of $c_{1}$ defined in $B_{1}$ is therefore irrelevant. Its lattice value is $\\bot$.\n    -   The predecessor path from $B_{2}$ is executable. The value provided along this path is $c_{2}$, for which we have $Val(c_{2}) = 17$.\n    -   Since there is only one feasible path reaching the $\\phi$-function, the result of the $\\phi$-function is the value from that single path. Thus, $c_{3}$ takes the value of $c_{2}$.\n    -   The lattice value of $c_{3}$ is updated from $\\bot$ to $17$. So, $Val(c_{3}) = 17$.\n    -   Statement $r := 3c_{3} - 2$: The transfer function for this arithmetic expression is applied. We use the determined constant value for $c_{3}$, which is $17$.\n    -   The expression evaluates to $3 \\times 17 - 2 = 51 - 2 = 49$.\n    -   The lattice value of $r$ is updated from $\\bot$ to $49$. So, $Val(r) = 49$.\n\nThe algorithm has reached a fixed point, as there are no loops and all reachable blocks have been processed. The final lattice values for the variables are:\n$Val(a_{0}) = 7$\n$Val(b_{0}) = 0$\n$Val(c_{1}) = \\bot$\n$Val(c_{2}) = 17$\n$Val(c_{3}) = 17$\n$Val(r) = 49$\n\nThe value of $r$ at the exit of block $B_{3}$ is the constant value computed by CCP, which is $49$.",
            "answer": "$$\\boxed{49}$$"
        },
        {
            "introduction": "Building on the basics, this problem illustrates the cascading power of CCP. You will trace how the optimization propagates constants through multiple control flow stages, where the result of one simplification enables the next. This exercise highlights how CCP is not just a single-pass transformation but an iterative process that can uncover optimization opportunities in sequence .",
            "id": "3630625",
            "problem": "You are given the following straight-line program represented in Static Single Assignment (SSA) form, with explicit control flow and a guarded update. Assume arithmetic and comparisons have their usual integer semantics. The entry to the program assigns a constant to the parameter and then evaluates a guarded comparison that may update the value. After the guard, the value is compared to zero and a final value is returned.\n\nProgram (labels are for readability; all variables are in SSA form):\n- Entry: define $x_0 := 1$ and branch to $B_1$.\n- Block $B_1$: evaluate the guard: if $(x_0  0)$ then branch to $B_2$ else branch to $B_3$.\n- Block $B_2$: compute the guarded update $x_1 := x_0 - 1$ and branch to $B_4$.\n- Block $B_3$: compute the alternative update $x_2 := x_0 + 2$ and branch to $B_4$.\n- Block $B_4$: merge the value with $\\phi$-function $x_3 := \\phi(B_2: x_1,\\; B_3: x_2)$; then if $(x_3 == 0)$ assign $y_1 := 7$ and branch to $B_5$, else assign $y_2 := 9$ and branch to $B_5$.\n- Block $B_5$: merge $y$ with $\\phi$-function $y_3 := \\phi(B_4\\_\\text{true}: y_1,\\; B_4\\_\\text{false}: y_2)$; compute $z_1 := y_3 + x_3$ and return $z_1$.\n\nApply conditional constant propagation from first principles, starting from the standard lattice of values where each SSA variable takes one of the abstract values $\\bot$, a concrete integer constant $c$, or $\\top$, together with control-flow executability determined by evaluating guards when operands are constants. Proceed to a fixed point, fold constants, remove inexecutables, and simplify $\\phi$-functions along the way.\n\nAfter all constant folding and unreachable code elimination implied by conditional constant propagation, what is the returned value of the program as a single integer? Provide the exact integer; no rounding is required.",
            "solution": "We apply the Conditional Constant Propagation (CCP) algorithm, tracking variable values on the {$\\bot$, constant, $\\top$} lattice and the executability of control-flow paths.\n\n1.  **Entry  Block $B_1$**: The program starts by setting $x_0 := 1$. The abstract value of $x_0$ becomes the constant $1$. The first conditional branch in $B_1$ is `if ($x_0 > 0$)`. This evaluates to `if (1 > 0)`, which is `true`. Therefore, the edge to block $B_2$ is executable, and the edge to block $B_3$ is proven to be non-executable.\n\n2.  **Block $B_2$**: Since block $B_2$ is reachable, we execute $x_1 := x_0 - 1$. With $x_0 = 1$, this becomes $x_1 := 1 - 1 = 0$. The abstract value of $x_1$ becomes the constant $0$.\n\n3.  **Block $B_4$ (First part)**: Block $B_4$ is reached from $B_2$. It begins with the $\\phi$-function $x_3 := \\phi(B_2: x_1, B_3: x_2)$. Since the predecessor $B_3$ is unreachable, the $\\phi$-function simplifies to the value from the only executable path. Thus, $x_3$ takes the value of $x_1$, which is $0$.\n\n4.  **Block $B_4$ (Second part)**: The second conditional branch is `if ($x_3 == 0$)`. This evaluates to `if (0 == 0)`, which is `true`. The 'true' path containing the assignment $y_1 := 7$ is executable, while the 'false' path with $y_2 := 9$ is not. The abstract value of $y_1$ becomes the constant $7$.\n\n5.  **Block $B_5$**: This block is reached from the 'true' path of $B_4$. The $\\phi$-function is $y_3 := \\phi(B_4_{\\text{true}}: y_1, B_4_{\\text{false}}: y_2)$. Again, only one path is executable, so the $\\phi$-function simplifies. $y_3$ takes the value of $y_1$, which is $7$.\n\n6.  **Final Calculation**: The last statement is $z_1 := y_3 + x_3$. Substituting the constant values we found: $z_1 := 7 + 0 = 7$.\n\nThe algorithm terminates, having proven that the returned value $z_1$ is the constant $7$.",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "This final practice explores a more advanced application of conditional constant propagation, moving from simple forward propagation to deductive reasoning. You will analyze a scenario where a variable is not initially constant, but its value can be precisely determined by considering the sequence of logical conditions required to reach a specific block of code. This exercise reveals the path-sensitive nature of the algorithm and its ability to discover constants that are only valid along certain execution paths .",
            "id": "3630560",
            "problem": "A compiler applies Sparse Conditional Constant Propagation (SCCP) in Static Single Assignment (SSA) form to a program. SCCP uses a three-point lattice for value states with elements $\\bot$ (undefined), constant $c \\in \\mathbb{Z}$, and $\\top$ (overdefined), the meet operator that prefers more precise information, and conditional edge feasibility to restrict which incoming values to $\\phi$-functions and uses are considered. The semantics of SSA are that each variable name is assigned exactly once, and $\\phi$-functions merge values from different control-flow predecessors.\n\nConsider the following SSA-form control-flow graph (CFG), where all branches are mutually exclusive in execution and reach a common join, and the variable $x$ is of integer type:\n\n- Entry block $\\mathrm{E}$ splits nondeterministically to three predecessor blocks $\\mathrm{A}$, $\\mathrm{B}$, and $\\mathrm{C}$.\n- In $\\mathrm{A}$: assign $x_{\\mathrm{A}} := 1$ and $\\mathrm{goto}$ join $\\mathrm{J}$.\n- In $\\mathrm{B}$: assign $x_{\\mathrm{B}} := 2$ and $\\mathrm{goto}$ join $\\mathrm{J}$.\n- In $\\mathrm{C}$: assign $x_{\\mathrm{C}} := 3$ and $\\mathrm{goto}$ join $\\mathrm{J}$.\n- In join block $\\mathrm{J}$: define $x := \\phi(x_{\\mathrm{A}}, x_{\\mathrm{B}}, x_{\\mathrm{C}})$, then branch on the guard $\\mathrm{if}\\ (x  1)\\ \\mathrm{goto}\\ \\mathrm{T1}\\ \\mathrm{else}\\ \\mathrm{goto}\\ \\mathrm{F1}$.\n- In block $\\mathrm{T1}$: branch on the guard $\\mathrm{if}\\ (x  3)\\ \\mathrm{goto}\\ \\mathrm{U}\\ \\mathrm{else}\\ \\mathrm{goto}\\ \\mathrm{F2}$.\n- In block $\\mathrm{U}$: compute $y := 3x^{2} - 5x + 7$ and then halt.\n- In blocks $\\mathrm{F1}$ and $\\mathrm{F2}$: halt without computing $y$.\n\nStarting from the fundamental SCCP definitions above (value lattice $\\{\\bot, c, \\top\\}$, SSA $\\phi$-semantics, and feasibility of control-flow edges derived from evaluating guards), determine the value that SCCP deduces for $x$ at block $\\mathrm{U}$ by intersecting the feasible predecessors and then compute the resulting value of $y := 3x^{2} - 5x + 7$ at block $\\mathrm{U}$.\n\nProvide your final answer for $y$ as a single real-valued number. No rounding is required.",
            "solution": "The problem requires us to trace the Sparse Conditional Constant Propagation (SCCP) algorithm to determine the value of the variable $y$ in block $\\mathrm{U}$. SCCP performs path-sensitive analysis.\n\n1.  **Initial State at Join Block $\\mathrm{J}$**: The variable $x$ in block $\\mathrm{J}$ is defined by the $\\phi$-function $x := \\phi(x_{\\mathrm{A}}, x_{\\mathrm{B}}, x_{\\mathrm{C}})$. The incoming values from the three executable predecessor blocks $\\mathrm{A}$, $\\mathrm{B}$, and $\\mathrm{C}$ are $1$, $2$, and $3$ respectively. Since these values are different, the abstract value of $x$ at the start of block $\\mathrm{J}$ is $\\top$ (overdefined).\n\n2.  **Path-Sensitive Deduction for Block $\\mathrm{U}$**: While the value of $x$ is $\\top$ in general, we are interested in its value specifically within block $\\mathrm{U}$. To reach block $\\mathrm{U}$, execution must pass through a sequence of conditional branches.\n    *   To get from block $\\mathrm{J}$ to block $\\mathrm{T1}$, the condition $(x > 1)$ must be true.\n    *   To get from block $\\mathrm{T1}$ to block $\\mathrm{U}$, the condition $(x  3)$ must be true.\n    *   Therefore, any execution path that reaches block $\\mathrm{U}$ must have a value for $x$ that satisfies both conditions simultaneously: $(x > 1) \\land (x  3)$.\n\n3.  **Refining the Value of $x$**: We test the possible initial values of $x$ against the combined condition:\n    *   If $x=1$ (from path $\\mathrm{A}$), the condition $(x > 1)$ is false. Execution branches to $\\mathrm{F1}$, so block $\\mathrm{U}$ is unreachable.\n    *   If $x=2$ (from path $\\mathrm{B}$), the condition $(x > 1)$ is true, and the condition $(x  3)$ is also true. Execution reaches block $\\mathrm{U}$. This path is feasible.\n    *   If $x=3$ (from path $\\mathrm{C}$), the condition $(x > 1)$ is true, but the condition $(x  3)$ is false. Execution branches to $\\mathrm{F2}$, so block $\\mathrm{U}$ is unreachable.\n\n    The analysis proves that block $\\mathrm{U}$ is reachable only if the program takes the path through block $\\mathrm{B}$. Thus, SCCP can deduce that *within block $\\mathrm{U}$*, the value of $x$ is guaranteed to be $2$.\n\n4.  **Final Computation**: Using the deduced constant value $x=2$, we compute the value of $y$ in block $\\mathrm{U}$:\n    $$ y := 3x^{2} - 5x + 7 $$\n    Substituting $x=2$:\n    $$ y = 3(2)^{2} - 5(2) + 7 $$\n    $$ y = 3(4) - 10 + 7 $$\n    $$ y = 12 - 10 + 7 $$\n    $$ y = 9 $$\n\nThe value of $y$ computed in block $\\mathrm{U}$ is $9$.",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}