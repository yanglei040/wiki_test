{
    "hands_on_practices": [
        {
            "introduction": "To master pruned Static Single Assignment (SSA) form, we begin with its core principle: the liveness check. This exercise focuses on a single control-flow join and explores how changes in subsequent code affect a variable's liveness. By analyzing three simple variants of the same code structure, you will see precisely when a $\\phi$-function is justified and when it is pruned, building a foundational understanding of the liveness condition. ",
            "id": "3665069",
            "problem": "Consider a Control Flow Graph (CFG) for a straight-line fragment in a compiler front-end. You are to reason about converting the program to Static Single Assignment (SSA) form, specifically the pruned variant, which inserts only those merge functions that are justified by variable liveness.\n\nUse the following fundamental base:\n- Definition of Static Single Assignment (SSA): each variable is assigned exactly once, and special merge functions $\\phi$ are placed at control-flow joins to merge values from different paths.\n- Definition of pruned SSA: identical to SSA, except that a $\\phi$-function for a variable $v$ at a join block is inserted only if $v$ is live at that join block.\n- Definition of liveness at a program point: a variable $v$ is live at a point if there exists a path from that point to a use of $v$ without an intervening redefinition of $v$.\n- Block-level dataflow sets: for a basic block $B$, $\\text{use}(B)$ is the set of variables used in $B$ before any redefinition in $B$; $\\text{def}(B)$ is the set of variables defined in $B$; $\\text{live-in}(B) = \\text{use}(B) \\cup (\\text{live-out}(B) \\setminus \\text{def}(B))$ and $\\text{live-out}(B) = \\bigcup_{S \\in \\text{succ}(B)} \\text{live-in}(S)$.\n\nThe CFG shape is the same for all variants below:\n- $B_0$: $x := 0$; if $p$ then goto $B_1$ else goto $B_2$.\n- $B_1$: $x := 1$; goto $B_3$.\n- $B_2$: goto $B_3$.\n- $B_3$: variant-specific code; then goto $B_4$.\n- $B_4$: variant-specific code; then exit.\n\nThree variants differ only in $B_3$ and $B_4$ as follows.\n- Variant I:\n  - $B_3$: $t := x + 1$; goto $B_4$.\n  - $B_4$: return $t$.\n- Variant II:\n  - $B_3$: $x := 5$; $t := x + 1$; goto $B_4$.\n  - $B_4$: return $t$.\n- Variant III:\n  - $B_3$: goto $B_4$.\n  - $B_4$: $y := x$; return $y$.\n\nAssume $x$, $t$, $y$ are distinct program variables, and $p$ is a boolean condition. For each variant, decide whether pruned SSA will insert a $\\phi(x)$ at the join block $B_3$, using only the base definitions above. Choose the correct claim from the options below.\n\nA. Pruned SSA inserts $\\phi(x)$ at $B_3$ in Variant I and Variant III, but not in Variant II, because $x$ is live at $B_3$ only in Variant I and Variant III.\n\nB. Pruned SSA inserts $\\phi(x)$ at $B_3$ in all three variants, because $B_3$ lies in the dominance frontier of the definitions of $x$ regardless of liveness.\n\nC. Pruned SSA inserts $\\phi(x)$ at $B_3$ only if both $B_1$ and $B_2$ redefine $x$; with a redefinition on only one side, no $\\phi(x)$ is needed at $B_3$.\n\nD. Pruned SSA inserts $\\phi(x)$ at $B_3$ in Variant II, because there are two reaching definitions of $x$ at $B_3$ even if $x$ is immediately redefined in $B_3$.\n\nSelect all options that are correct and justify your choice using the notion of liveness at the join. Be precise: your reasoning must follow from the given base definitions and the control-flow structure above, not from any unstated algorithmic shortcut.",
            "solution": "The user has requested an analysis of a compiler problem related to pruned Static Single Assignment (SSA) form.\n\n### Step 1: Extract Givens\n\n-   **Definition of Static Single Assignment (SSA):** Each variable is assigned exactly once. Special merge functions, denoted as $\\phi$, are placed at control-flow joins to merge values from different paths.\n-   **Definition of pruned SSA:** A $\\phi$-function for a variable $v$ is inserted at a join block only if $v$ is live at that join block.\n-   **Definition of Liveness:** A variable $v$ is live at a point if there exists a path from that point to a use of $v$ without an intervening redefinition of $v$.\n-   **Block-level Dataflow Sets:** For a basic block $B$:\n    -   $\\text{use}(B)$: set of variables used in $B$ before any redefinition in $B$.\n    -   $\\text{def}(B)$: set of variables defined in $B$.\n    -   $\\text{live-in}(B) = \\text{use}(B) \\cup (\\text{live-out}(B) \\setminus \\text{def}(B))$.\n    -   $\\text{live-out}(B) = \\bigcup_{S \\in \\text{succ}(B)} \\text{live-in}(S)$.\n-   **Control Flow Graph (CFG) Structure:**\n    -   $B_0$: $x := 0$; if $p$ then goto $B_1$ else goto $B_2$.\n    -   $B_1$: $x := 1$; goto $B_3$.\n    -   $B_2$: goto $B_3$.\n    -   $B_3$: variant-specific code; then goto $B_4$.\n    -   $B_4$: variant-specific code; then exit.\n-   **CFG Successors:**\n    -   $\\text{succ}(B_0) = \\{B_1, B_2\\}$.\n    -   $\\text{succ}(B_1) = \\{B_3\\}$.\n    -   $\\text{succ}(B_2) = \\{B_3\\}$.\n    -   $\\text{succ}(B_3) = \\{B_4\\}$.\n    -   $\\text{succ}(B_4) = \\{\\text{exit}\\}$.\n-   **Code Variants:**\n    -   **Variant I:**\n        -   $B_3$: $t := x + 1$; goto $B_4$.\n        -   $B_4$: return $t$.\n    -   **Variant II:**\n        -   $B_3$: $x := 5$; $t := x + 1$; goto $B_4$.\n        -   $B_4$: return $t$.\n    -   **Variant III:**\n        -   $B_3$: goto $B_4$.\n        -   $B_4$: $y := x$; return $y$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is scientifically grounded, well-posed, and objective.\n1.  **Scientific or Factual Soundness:** The problem is based on established concepts in compiler theory, namely Control Flow Graphs, Static Single Assignment form (both standard and pruned), and liveness analysis. The definitions provided are standard and correct.\n2.  **Non-Formalizable or Irrelevant:** The problem is a formal exercise in applying dataflow analysis, directly relevant to compiler principles.\n3.  **Incomplete or Contradictory Setup:** The problem provides a complete CFG structure, explicit code for each block in three different variants, and all necessary definitions for liveness analysis and pruned SSA. The information is self-contained and consistent.\n4.  **Unrealistic or Infeasible:** The code fragments are simple, valid, and represent plausible program structures. The analysis is computationally feasible.\n5.  **Ill-Posed or Poorly Structured:** The problem is well-posed. For each variant, a unique determination can be made about the insertion of a $\\phi$-function based on the provided rules. The terminology is precise.\n6.  **Pseudo-Profound, Trivial, or Tautological:** The problem requires a careful, step-by-step application of liveness analysis, distinguishing between different program variants. It tests a core conceptual distinction between standard and pruned SSA.\n7.  **Outside Scientific Verifiability:** The claims can be verified by executing the defined dataflow analysis algorithm.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. The solution process will now proceed.\n\n### Derivation of the Correct Answer\n\nThe core of the problem is to determine, for each variant, whether a $\\phi$-function for the variable $x$, denoted $\\phi(x)$, should be inserted at the beginning of block $B_3$.\n\nA $\\phi$-function for a variable is inserted at a control-flow join point if there are multiple distinct definitions of that variable reaching the join. In the given CFG, $B_3$ is a join point, as it is the successor of both $B_1$ and $B_2$. The variable $x$ is defined in $B_0$ (as $x := 0$) and redefined in $B_1$ (as $x := 1$). The path through $B_2$ does not redefine $x$. Therefore, two different definitions of $x$ reach the entry of $B_3$: the one from $B_1$ and the one from $B_0$ (which flows through $B_2$). This satisfies the condition for inserting a $\\phi$-function in standard SSA.\n\nHowever, the problem specifies **pruned SSA**. According to the provided definition, a $\\phi(x)$ function is inserted at $B_3$ only if $x$ is **live** at the entry of $B_3$. We must therefore perform a liveness analysis for each variant. Liveness is a backward dataflow analysis problem. We will compute the sets $\\text{live-in}(B)$ and $\\text{live-out}(B)$ for each block $B$, iterating until a fixed point is reached. We assume nothing is live at the program's exit, so $\\text{live-out}(B_4) = \\text{live-in}(\\text{exit}) = \\emptyset$. The question hinges on whether $x \\in \\text{live-in}(B_3)$.\n\n**Analysis of Variant I**\n-   $B_3$: $t := x + 1$; goto $B_4$.\n-   $B_4$: return $t$.\n\n1.  **Block $B_4$**:\n    -   The statement is `return t`. The variable $t$ is used.\n    -   $\\text{use}(B_4) = \\{t\\}$, $\\text{def}(B_4) = \\emptyset$.\n    -   $\\text{live-out}(B_4) = \\emptyset$.\n    -   $\\text{live-in}(B_4) = \\text{use}(B_4) \\cup (\\text{live-out}(B_4) \\setminus \\text{def}(B_4)) = \\{t\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{t\\}$.\n\n2.  **Block $B_3$**:\n    -   The statement is $t := x + 1$. The variable $x$ is used, and $t$ is defined.\n    -   $\\text{use}(B_3) = \\{x\\}$, $\\text{def}(B_3) = \\{t\\}$.\n    -   $\\text{live-out}(B_3) = \\text{live-in}(\\text{succ}(B_3)) = \\text{live-in}(B_4) = \\{t\\}$.\n    -   $\\text{live-in}(B_3) = \\text{use}(B_3) \\cup (\\text{live-out}(B_3) \\setminus \\text{def}(B_3)) = \\{x\\} \\cup (\\{t\\} \\setminus \\{t\\}) = \\{x\\} \\cup \\emptyset = \\{x\\}$.\n\nConclusion for Variant I: $x$ is in $\\text{live-in}(B_3)$. Therefore, in pruned SSA, a $\\phi(x)$ function is inserted at $B_3$.\n\n**Analysis of Variant II**\n-   $B_3$: $x := 5$; $t := x + 1$; goto $B_4$.\n-   $B_4$: return $t$.\n\n1.  **Block $B_4$**: Same as in Variant I.\n    -   $\\text{live-in}(B_4) = \\{t\\}$.\n\n2.  **Block $B_3$**:\n    -   The statements are $x := 5$ followed by $t := x + 1$. The use of $x$ in the second statement is preceded by a redefinition of $x$ within the same block. According to the definition $\\text{use}(B)$ is the set of variables \"used in $B$ before any redefinition in $B$\". Thus, $x$ is not in $\\text{use}(B_3)$.\n    -   $\\text{use}(B_3) = \\emptyset$.\n    -   Both $x$ and $t$ are defined. $\\text{def}(B_3) = \\{x, t\\}$.\n    -   $\\text{live-out}(B_3) = \\text{live-in}(B_4) = \\{t\\}$.\n    -   $\\text{live-in}(B_3) = \\text{use}(B_3) \\cup (\\text{live-out}(B_3) \\setminus \\text{def}(B_3)) = \\emptyset \\cup (\\{t\\} \\setminus \\{x, t\\}) = \\emptyset \\cup \\emptyset = \\emptyset$.\n\nConclusion for Variant II: $x$ is **not** in $\\text{live-in}(B_3)$ because it is redefined in $B_3$ before any subsequent use on any path starting from the entry of $B_3$. Therefore, in pruned SSA, a $\\phi(x)$ function is **not** inserted at $B_3$.\n\n**Analysis of Variant III**\n-   $B_3$: goto $B_4$.\n-   $B_4$: $y := x$; return $y$.\n\n1.  **Block $B_4$**:\n    -   The statements are $y := x$ followed by `return y`. The variable $x$ is used to define $y$. The variable $y$ is used in the return statement, but this use is preceded by its definition within $B_4$. Thus, $\\text{use}(B_4)$ contains $x$.\n    -   $\\text{use}(B_4) = \\{x\\}$, $\\text{def}(B_4) = \\{y\\}$.\n    -   $\\text{live-out}(B_4) = \\emptyset$.\n    -   $\\text{live-in}(B_4) = \\text{use}(B_4) \\cup (\\text{live-out}(B_4) \\setminus \\text{def}(B_4)) = \\{x\\} \\cup (\\emptyset \\setminus \\{y\\}) = \\{x\\}$.\n\n2.  **Block $B_3$**:\n    -   This is an empty block containing only a goto.\n    -   $\\text{use}(B_3) = \\emptyset$, $\\text{def}(B_3) = \\emptyset$.\n    -   $\\text{live-out}(B_3) = \\text{live-in}(B_4) = \\{x\\}$.\n    -   $\\text{live-in}(B_3) = \\text{use}(B_3) \\cup (\\text{live-out}(B_3) \\setminus \\text{def}(B_3)) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}$.\n\nConclusion for Variant III: $x$ is in $\\text{live-in}(B_3)$. Therefore, in pruned SSA, a $\\phi(x)$ function is inserted at $B_3$.\n\n**Summary of Results**\n-   Variant I: $\\phi(x)$ is inserted at $B_3$.\n-   Variant II: $\\phi(x)$ is **not** inserted at $B_3$.\n-   Variant III: $\\phi(x)$ is inserted at $B_3$.\n\n### Option-by-Option Analysis\n\n**A. Pruned SSA inserts $\\phi(x)$ at $B_3$ in Variant I and Variant III, but not in Variant II, because $x$ is live at $B_3$ only in Variant I and Variant III.**\nThis statement perfectly matches our derived results. Our analysis shows that a $\\phi(x)$ is required in Variant I and Variant III, but not in Variant II. The reason provided, that $x$ is live at the entry of $B_3$ only in Variants I and III, is precisely the outcome of our liveness analysis.\n**Verdict: Correct**\n\n**B. Pruned SSA inserts $\\phi(x)$ at $B_3$ in all three variants, because $B_3$ lies in the dominance frontier of the definitions of $x$ regardless of liveness.**\nThis statement incorrectly claims that a $\\phi(x)$ is inserted in all three variants. Our analysis shows it is not inserted in Variant II. The reasoning provided describes the criterion for standard (non-pruned) SSA, but the problem explicitly concerns pruned SSA, which adds a liveness requirement. This option ignores the crucial \"pruned\" aspect.\n**Verdict: Incorrect**\n\n**C. Pruned SSA inserts $\\phi(x)$ at $B_3$ only if both $B_1$ and $B_2$ redefine $x$; with a redefinition on only one side, no $\\phi(x)$ is needed at $B_3$.**\nThis statement's reasoning is fundamentally flawed. A $\\phi$-function is needed precisely because multiple, different definitions reach a join point. In this CFG, the definition $x := 1$ from $B_1$ and the definition $x:=0$ from $B_0$ (via $B_2$) meet at $B_3$. This necessitates a merge. The claim that a redefinition on only one side means no $\\phi(x)$ is needed is the opposite of the truth.\n**Verdict: Incorrect**\n\n**D. Pruned SSA inserts $\\phi(x)$ at $B_3$ in Variant II, because there are two reaching definitions of $x$ at $B_3$ even if $x$ is immediately redefined in $B_3$.**\nThis statement incorrectly claims a $\\phi(x)$ is inserted in Variant II. The condition of having two reaching definitions is necessary but not sufficient for pruned SSA. The fact that \"$x$ is immediately redefined in $B_3$\" is precisely the reason why $x$ is not live-in at $B_3$, and thus the reason why the $\\phi(x)$ is **not** inserted. The logic presented is backwards.\n**Verdict: Incorrect**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Building on the liveness condition, this practice applies the concept to a complete program, contrasting pruned SSA with its predecessor, minimal SSA. You will first determine the set of potential $\\phi$-functions using the iterated dominance frontier algorithm, and then use liveness analysis to identify which of these are unnecessary. This exercise uses a hypothetical variable that is defined but never read, providing a clear and powerful demonstration of how pruned SSA avoids generating useless code. ",
            "id": "3665127",
            "problem": "Consider the following control-flow graph (CFG) with basic blocks labeled $B_{0}$ through $B_{9}$. The program has variables $a$ and $b$, and boolean conditions $p$, $q$, and $r$. Each basic block contains the following statements and control transfers:\n- $B_{0}$: $a \\leftarrow 0$; $b \\leftarrow 0$; $\\text{goto } B_{1}$.\n- $B_{1}$: $\\text{if } p \\text{ then goto } B_{2} \\text{ else goto } B_{3}$.\n- $B_{2}$: $a \\leftarrow 1$; $\\text{goto } B_{4}$.\n- $B_{3}$: $\\text{if } q \\text{ then goto } B_{5} \\text{ else goto } B_{6}$.\n- $B_{5}$: $a \\leftarrow 2$; $\\text{goto } B_{4}$.\n- $B_{6}$: $b \\leftarrow b + 1$; $\\text{goto } B_{4}$.\n- $B_{4}$: $\\text{if } r \\text{ then goto } B_{7} \\text{ else goto } B_{8}$.\n- $B_{7}$: $a \\leftarrow 3$; $\\text{goto } B_{9}$.\n- $B_{8}$: $t \\leftarrow b$; $\\text{goto } B_{9}$.\n- $B_{9}$: $u \\leftarrow b$; return.\n\nAssume the unique entry is $B_{0}$ and the unique exit is $B_{9}$. The only variable possibly used in expressions on the right-hand side in this program is $b$; there is no use of $a$ in any right-hand side or condition.\n\nUsing the standard definitions of dominance, dominance frontier, and liveness from compiler theory, perform the following tasks:\n1. Compute the dominance frontier of all basic blocks that define $a$ and report the union set $DF(a)$.\n2. Using the minimal Static Single Assignment (SSA) construction (placing $\\phi$-functions at the iterated dominance frontier of the definition sites), determine at which join blocks $\\phi(a)$ would be placed.\n3. Perform liveness analysis for variable $a$ on the original program (before inserting any $\\phi$-functions) to determine at which join blocks $a$ is live-in.\n4. Focusing on pruned SSA form (which places $\\phi$-functions only at join blocks where the variable is live-in), determine how many $\\phi(a)$ insertions from minimal SSA are eliminated by pruning because $a$ is dead-in at those join points.\n\nProvide as your final answer the total number of $\\phi(a)$ insertions eliminated by pruned SSA compared to minimal SSA. Your answer must be a single integer. No rounding is necessary. Express your final answer as a pure number without any units.",
            "solution": "The user wants to solve a problem about Static Single Assignment (SSA) form, specifically comparing minimal SSA with pruned SSA.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n\n*   **Control-Flow Graph (CFG):**\n    *   Basic blocks: $B_{0}, B_{1}, B_{2}, B_{3}, B_{4}, B_{5}, B_{6}, B_{7}, B_{8}, B_{9}$.\n    *   Unique entry: $B_{0}$.\n    *   Unique exit: $B_{9}$.\n*   **Block Contents and Control Flow:**\n    *   $B_{0}$: $a \\leftarrow 0$; $b \\leftarrow 0$; goto $B_{1}$.\n    *   $B_{1}$: if $p$ then goto $B_{2}$ else goto $B_{3}$.\n    *   $B_{2}$: $a \\leftarrow 1$; goto $B_{4}$.\n    *   $B_{3}$: if $q$ then goto $B_{5}$ else goto $B_{6}$.\n    *   $B_{5}$: $a \\leftarrow 2$; goto $B_{4}$.\n    *   $B_{6}$: $b \\leftarrow b + 1$; goto $B_{4}$.\n    *   $B_{4}$: if $r$ then goto $B_{7}$ else goto $B_{8}$.\n    *   $B_{7}$: $a \\leftarrow 3$; goto $B_{9}$.\n    *   $B_{8}$: $t \\leftarrow b$; goto $B_{9}$.\n    *   $B_{9}$: $u \\leftarrow b$; return.\n*   **Variables:** $a, b, t, u$.\n*   **Conditions:** $p, q, r$.\n*   **Crucial Constraint:** \"The only variable possibly used in expressions on the right-hand side in this program is $b$; there is no use of $a$ in any right-hand side or condition.\"\n*   **Tasks:**\n    1.  Compute the dominance frontier union set $DF(a)$ for all blocks defining $a$.\n    2.  Determine where $\\phi(a)$ functions are placed for minimal SSA.\n    3.  Determine at which join blocks $a$ is live-in.\n    4.  Determine how many $\\phi(a)$ insertions are eliminated by pruned SSA compared to minimal SSA.\n\n**1.2. Validate Using Extracted Givens**\n\n*   **Scientifically Grounded:** The problem uses standard, well-defined concepts from compiler theory: control-flow graphs, dominance, dominance frontiers, liveness analysis, and Static Single Assignment (SSA) form (both minimal and pruned). These concepts are fundamental to compiler construction and optimization. The problem is scientifically sound.\n*   **Well-Posed:** The CFG is completely specified, the tasks are clearly defined, and they lead to a unique, quantifiable answer.\n*   **Objective:** The problem statement is written in formal, objective language without ambiguity or subjective claims.\n*   **Completeness:** The problem provides all necessary information to solve it. The constraint about the use of variable $a$ is critical and explicitly stated.\n*   **Consistency:** The provided information is internally consistent.\n\n**1.3. Verdict and Action**\n\nThe problem is valid. I will proceed with a full solution.\n\n### Step 2: Solution\n\nThe overall goal is to compare the number of $\\phi$-functions inserted for variable $a$ under minimal SSA and pruned SSA. This requires four main steps as outlined in the problem.\n\n**CFG Structure and Dominators**\n\nFirst, we establish the structure of the CFG and compute the dominator tree, which is essential for calculating dominance frontiers.\nThe predecessors (Pred) and successors (Succ) of each block are:\n*   $Pred(B_{0}) = \\emptyset$ (entry)\n*   $Pred(B_{1}) = \\{B_{0}\\}$, $Succ(B_{1}) = \\{B_{2}, B_{3}\\}$\n*   $Pred(B_{2}) = \\{B_{1}\\}$, $Succ(B_{2}) = \\{B_{4}\\}$\n*   $Pred(B_{3}) = \\{B_{1}\\}$, $Succ(B_{3}) = \\{B_{5}, B_{6}\\}$\n*   $Pred(B_{4}) = \\{B_{2}, B_{5}, B_{6}\\}$, $Succ(B_{4}) = \\{B_{7}, B_{8}\\}$\n*   $Pred(B_{5}) = \\{B_{3}\\}$, $Succ(B_{5}) = \\{B_{4}\\}$\n*   $Pred(B_{6}) = \\{B_{3}\\}$, $Succ(B_{6}) = \\{B_{4}\\}$\n*   $Pred(B_{7}) = \\{B_{4}\\}$, $Succ(B_{7}) = \\{B_{9}\\}$\n*   $Pred(B_{8}) = \\{B_{4}\\}$, $Succ(B_{8}) = \\{B_{9}\\}$\n*   $Pred(B_{9}) = \\{B_{7}, B_{8}\\}$, $Succ(B_{9}) = \\emptyset$ (exit)\n\nBlocks with more than one predecessor are called join points. The join points in this CFG are $B_{4}$ and $B_{9}$.\n\nNext, we determine the immediate dominator ($idom$) for each block. A block $X$ dominates block $Y$ if every path from the entry to $Y$ includes $X$. The immediate dominator of $Y$ is the last dominator on any path from the entry to $Y$.\n*   $idom(B_{0}) = \\text{none}$ (entry node)\n*   $idom(B_{1}) = B_{0}$\n*   $idom(B_{2}) = B_{1}$\n*   $idom(B_{3}) = B_{1}$\n*   $idom(B_{4}) = B_{1}$ (The common dominator of its predecessors $\\{B_{2}, B_{5}, B_{6}\\}$ is $B_{1}$)\n*   $idom(B_{5}) = B_{3}$\n*   $idom(B_{6}) = B_{3}$\n*   $idom(B_{7}) = B_{4}$\n*   $idom(B_{8}) = B_{4}$\n*   $idom(B_{9}) = B_{4}$ (The common dominator of its predecessors $\\{B_{7}, B_{8}\\}$ is $B_{4}$)\n\nThe dominator tree is:\n$B_{0} \\to B_{1} \\to \\{B_{2}, B_{3}, B_{4}\\}$\n$B_{3} \\to \\{B_{5}, B_{6}\\}$\n$B_{4} \\to \\{B_{7}, B_{8}, B_{9}\\}$\n\n**Task 1 & 2: Minimal SSA Construction**\n\nMinimal SSA form requires placing $\\phi$-functions at the iterated dominance frontier of the set of blocks containing definitions of a variable. The dominance frontier $DF(X)$ of a block $X$ is the set of all blocks $Y$ such that $X$ dominates a predecessor of $Y$, but $X$ does not strictly dominate $Y$.\n\nLet's compute the dominance frontiers ($DF$) for the blocks that define variable $a$. The set of blocks defining $a$, let's call it $Defs(a)$, is:\n$Defs(a) = \\{B_{0}, B_{2}, B_{5}, B_{7}\\}$\n\nWe compute the $DF$ for these blocks:\n*   $DF(B_{0})$: $B_{0}$ dominates all blocks. It has no dominance frontier. $DF(B_{0}) = \\emptyset$.\n*   $DF(B_{2})$: $B_{2}$ has one successor, $B_{4}$. $B_{2}$ dominates one of $B_{4}$'s predecessors (namely, $B_{2}$ itself), but $B_{2}$ ($idom(B_2)=B_1$) does not strictly dominate $B_{4}$ ($idom(B_4)=B_1$). Thus, $B_{4} \\in DF(B_{2})$. So, $DF(B_{2}) = \\{B_{4}\\}$.\n*   $DF(B_{5})$: $B_{5}$ has one successor, $B_{4}$. $B_{5}$ dominates a predecessor of $B_{4}$ (itself), but does not strictly dominate $B_{4}$. Thus, $B_{4} \\in DF(B_{5})$. So, $DF(B_{5}) = \\{B_{4}\\}$.\n*   $DF(B_{7})$: $B_{7}$ has one successor, $B_{9}$. $B_{7}$ dominates a predecessor of $B_{9}$ (itself), but does not strictly dominate $B_{9}$ ($idom(B_9)=B_4$). Thus, $B_{9} \\in DF(B_{7})$. So, $DF(B_{7}) = \\{B_{9}\\}$.\n\nFor Task 1, the union set $DF(a)$ is:\n$DF(a) = DF(B_{0}) \\cup DF(B_{2}) \\cup DF(B_{5}) \\cup DF(B_{7}) = \\emptyset \\cup \\{B_{4}\\} \\cup \\{B_{4}\\} \\cup \\{B_{9}\\} = \\{B_{4}, B_{9}\\}$.\n\nFor Task 2, we find the iterated dominance frontier, $IDF(Defs(a))$. We start with the set $\\Phi = DF(a) = \\{B_{4}, B_{9}\\}$. We then add the dominance frontiers of the blocks in $\\Phi$ to the set, and iterate until no new blocks are added.\n*   $DF(B_{4})$: The successors of $B_{4}$ are $B_{7}$ and $B_{8}$. $B_{4}$ strictly dominates both, so $DF_{local}(B_{4}) = \\emptyset$. The children of $B_4$ in the dominator tree are $B_7, B_8, B_9$. $DF(B_7)=\\{B_9\\}$, but $B_4$ strictly dominates $B_9$. $DF(B_8)=\\{B_9\\}$, but $B_4$ strictly dominates $B_9$. $DF(B_9)=\\emptyset$. So $DF(B_{4}) = \\emptyset$.\n*   $DF(B_{9})$: $B_{9}$ has no successors, so $DF(B_{9}) = \\emptyset$.\n\nSince $DF(B_{4})$ and $DF(B_{9})$ are empty, the iteration stops immediately. The set of nodes where $\\phi(a)$ must be placed for minimal SSA is $IDF(Defs(a)) = \\{B_{4}, B_{9}\\}$.\nMinimal SSA will insert $\\mathbf{2}$ $\\phi$-functions for variable $a$, one at $B_{4}$ and one at $B_{9}$.\n\n**Task 3: Liveness Analysis for Variable $a$**\n\nA variable is *live* at a program point if its current value might be used in the future. Liveness is a backward data-flow analysis problem. The data-flow equations for a block $B$ are:\n$LiveOut(B) = \\bigcup_{S \\in Succ(B)} LiveIn(S)$\n$LiveIn(B) = Use(B) \\cup (LiveOut(B) \\setminus Def(B))$\n\nHere, $Use(B)$ is the set of variables used in $B$ before they are defined, and $Def(B)$ is the set of variables defined in $B$.\n\nThe problem statement provides a critical piece of information: \"...there is no use of $a$ in any right-hand side or condition.\" This means that for variable $a$, the set $Use(B)$ is empty for all blocks $B \\in \\{B_{0}, \\dots, B_{9}\\}$.\nLet's analyze the consequence:\n$LiveIn(B) = \\emptyset \\cup (LiveOut(B) \\setminus Def_{a}(B)) = LiveOut(B) \\setminus Def_{a}(B)$.\n\nThe analysis starts from the exit block, assuming all live sets are initially empty. At the program exit (after $B_{9}$), no variables are live.\n*   $LiveOut(B_{9}) = \\emptyset$.\n*   $LiveIn(B_{9}) = Use(B_{9}) \\cup (LiveOut(B_{9}) \\setminus Def(B_{9})) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$.\n*   For any predecessor $P$ of $B_{9}$ (i.e., $B_{7}, B_{8}$), $LiveOut(P)$ will include $LiveIn(B_{9})$, which is $\\emptyset$.\n*   $LiveOut(B_{8}) = LiveIn(B_{9}) = \\emptyset$.\n*   $LiveIn(B_{8}) = Use(B_{8}) \\cup (LiveOut(B_{8}) \\setminus Def(B_{8})) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$.\n*   $LiveOut(B_{7}) = LiveIn(B_{9}) = \\emptyset$.\n*   $LiveIn(B_{7}) = Use(B_{7}) \\cup (LiveOut(B_{7}) \\setminus \\{a\\}) = \\emptyset \\cup (\\emptyset \\setminus \\{a\\}) = \\emptyset$.\n\nThis pattern propagates backward through the entire graph. Since $Use(a)$ is always empty, the liveness of $a$ is never initiated. Any definition of $a$ is a \"dead store\" because the value is never read. The fixed-point solution for the liveness of $a$ is that $LiveIn_{a}(B) = \\emptyset$ and $LiveOut_{a}(B) = \\emptyset$ for all blocks $B$.\n\nFor Task 3, we are asked at which join blocks ($B_{4}$, $B_{9}$) the variable $a$ is live-in.\n*   Is $a$ live-in at $B_{4}$? No, $LiveIn_{a}(B_{4}) = \\emptyset$.\n*   Is $a$ live-in at $B_{9}$? No, $LiveIn_{a}(B_{9}) = \\emptyset$.\nThe answer is that $a$ is not live-in at any join block.\n\n**Task 4: Pruning and Final Calculation**\n\n*   **Minimal SSA:** Inserts $\\phi(a)$ functions at all join points in the iterated dominance frontier of definition sites. As found in Task 2, these are $B_{4}$ and $B_{9}$. Total insertions = $2$.\n\n*   **Pruned SSA:** Inserts $\\phi(a)$ functions only at join points where the variable $a$ is also live. These are the nodes in the set $\\{B | B \\text{ is a join point}\\} \\cap IDF(Defs(a)) \\cap \\{B | a \\in LiveIn(B)\\}$.\n    *   The join points are $\\{B_{4}, B_{9}\\}$.\n    *   $IDF(Defs(a)) = \\{B_{4}, B_{9}\\}$.\n    *   The set of blocks where $a$ is live-in is $\\emptyset$.\n    *   The intersection of these three sets is $\\emptyset$.\n    *   Therefore, pruned SSA inserts $0$ $\\phi(a)$ functions.\n\nThe number of $\\phi(a)$ insertions eliminated by pruned SSA is the number of insertions in minimal SSA minus the number in pruned SSA.\nNumber eliminated = (Minimal SSA insertions) - (Pruned SSA insertions) = $2 - 0 = 2$.\nThe two eliminated $\\phi$-functions are the ones at $B_{4}$ and $B_{9}$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Our final practice explores a more nuanced and realistic scenario involving a loop with multiple exit paths. Unlike a variable that is globally dead, the variable here is live along one exit path but dead along another, requiring a more careful analysis. This problem illustrates how pruned SSA's liveness check precisely identifies which control-flow merges require $\\phi$-functions, solidifying your understanding of its role in producing efficient, optimized code. ",
            "id": "3665045",
            "problem": "A compiler constructs Static Single Assignment (SSA) form, and its pruned variant, by placing merge functions $\\phi$ only where they are justified by control-flow merging and variable liveness. Consider the following control-flow graph (CFG) for a loop with multiple exits operating on a single variable $z$, and ignore all other variables.\n\n- Entry goes to a loop preheader named P, which assigns $z := 0$ and then transfers control to the loop header named H.\n- H evaluates a loop condition and transfers control to either L1 or L2.\n- In L1, the statement $z := z + 1$ executes; then a conditional transfers to either EJ (exit to a join), R (exit to a non-join), or back to H (loop backedge).\n- In L2, the statement $z := 3 \\times z$ executes; then a conditional transfers to either EJ, R, or back to H.\n- EJ is an exit block that immediately uses $z$ in the statement $x := z - 3$, then transfers to OUT.\n- R is an exit block that does not use $z$ and transfers directly to OUT.\n- OUT is a block with no further use of $z$.\n\nAssume the standard definitions:\n- SSA form assigns each variable exactly once per name version; merge functions $\\phi$ are inserted at points where distinct control-flow paths carrying different definitions meet.\n- A block $Y$ is in the dominance frontier of a block $X$ if $X$ dominates a predecessor of $Y$ but does not strictly dominate $Y$.\n- In pruned SSA form, a $\\phi$ for a variable $v$ is inserted at a block $Y$ only if $Y$ lies in the iterated dominance frontier of some definition of $v$ and $v$ is live-in at $Y$.\n- A variable is live-in at a block if there exists a path from the block’s entry to a use of the variable without encountering a redefinition along that path.\n\nOnly the variable $z$ is of interest. Using the CFG above and the stated definitions, determine the total number of $\\phi$-functions that pruned SSA will insert for $z$ across the entire CFG. Express your answer as a single integer with no units. No rounding is required, and only an exact count should be provided.",
            "solution": "The user wants to determine the total number of $\\phi$-functions inserted for a variable $z$ in a given control-flow graph (CFG) when using the pruned Static Single Assignment (SSA) form.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n- **Control-Flow Graph (CFG) Structure:**\n    - `Entry` -> `P`\n    - `P`: contains assignment `z := 0`, then -> `H`\n    - `H`: loop header, conditional -> `L1` or `L2`\n    - `L1`: contains assignment `z := z + 1`, then conditional -> `EJ`, `R`, or `H`\n    - `L2`: contains assignment `z := 3 \\times z`, then conditional -> `EJ`, `R`, or `H`\n    - `EJ`: exit block, contains use `x := z - 3`, then -> `OUT`\n    - `R`: exit block, does not use `z`, then -> `OUT`\n    - `OUT`: block with no further use of `z`\n- **Variable of Interest:** $z$\n- **Definitions:**\n    - **SSA form:** Each variable is assigned exactly once. $\\phi$-functions merge values at control-flow confluence points.\n    - **Dominance Frontier (DF):** A block $Y$ is in the dominance frontier of a block $X$ if $X$ dominates a predecessor of $Y$ but does not strictly dominate $Y$.\n    - **Pruned SSA form:** A $\\phi$ for a variable $v$ is inserted at a block $Y$ only if $Y$ is in the iterated dominance frontier of some definition of $v$, and $v$ is live-in at $Y$.\n    - **Liveness:** A variable is live-in at a block if there exists a path from the block’s entry to a use of the variable without an intervening redefinition.\n\n**1.2. Validate Using Extracted Givens**\nThe problem is well-defined and grounded in the established principles of compiler construction.\n- **Scientifically Grounded:** The concepts of CFGs, SSA, dominance frontiers, and liveness analysis are core topics in compiler theory. The definitions provided are standard and correct.\n- **Well-Posed:** The CFG is described unambiguously. The task is specific: count the number of $\\phi$-functions for a single variable under the rules of pruned SSA. A unique, integer-valued solution can be derived.\n- **Objective:** The problem statement is free of subjective language and relies entirely on formal definitions from computer science.\n\n**1.3. Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### Step 2: Solution Derivation\n\nThe process for determining $\\phi$-function placement in pruned SSA form involves two main stages:\n1.  Determine all potential placement locations using the Iterated Dominance Frontier (IDF) algorithm, which is the standard for SSA construction.\n2.  Prune this set of locations by checking the liveness of the variable at each candidate block. A $\\phi$-function is only necessary if the variable is live-in at the merge point.\n\n**2.1. Standard SSA Placement (Iterated Dominance Frontier)**\n\nFirst, we identify the blocks that contain definitions of the variable $z$. Let this set be $D$.\n- Block $P$: $z := 0$\n- Block $L1$: $z := z + 1$\n- Block $L2$: $z := 3 \\times z$\nSo, the set of defining blocks is $D = \\{P, L1, L2\\}$.\n\nThe set of blocks requiring $\\phi$-functions in standard SSA is the Iterated Dominance Frontier of $D$, denoted $IDF(D)$. To compute this, we must first determine the dominator tree of the CFG.\n\n**Dominator Tree:**\nA block $X$ dominates a block $Y$ if every path from `Entry` to $Y$ must pass through $X$.\n- `Entry` is the root, dominating all other blocks.\n- `P` has `Entry` as its only predecessor, so `P` is immediately dominated by `Entry`.\n- `H` has `P` as its only non-looping predecessor path, so `H` is immediately dominated by `P`.\n- `L1` and `L2` are reached from `H`, so they are immediately dominated by `H`.\n- `EJ` is reached from `L1` and `L2`. The immediate dominator of `L1` and `L2` is `H`. The lowest common ancestor of these predecessors in the dominator tree is `H`. Thus, `EJ` is immediately dominated by `H`.\n- `R` is also reached from `L1` and `L2`. By the same logic, `R` is immediately dominated by `H`.\n- `OUT` is reached from `EJ` and `R`. The immediate dominator of both `EJ` and `R` is `H`, so `OUT` is immediately dominated by `H`.\n\nThe dominator tree structure is: `Entry` $\\rightarrow$ `P` $\\rightarrow$ `H`, with `L1`, `L2`, `EJ`, `R`, and `OUT` all being children of `H`.\n\n**Dominance Frontiers (DF):**\nNow we compute the dominance frontiers for the blocks in $D$.\n- $DF(P)$: $P$ strictly dominates all blocks from `H` onwards. For any block $Y$ whose predecessor is dominated by $P$, $P$ also strictly dominates $Y$. Thus, $DF(P) = \\emptyset$.\n- $DF(L1)$:\n    - For the join point `H` (predecessors $\\{P, L1, L2\\}$), `L1` dominates its predecessor `L1` but does not strictly dominate `H`. So, $H \\in DF(L1)$.\n    - For the join point `EJ` (predecessors $\\{L1, L2\\}$), `L1` dominates its predecessor `L1` but does not strictly dominate `EJ`. So, $EJ \\in DF(L1)$.\n    - For the join point `R` (predecessors $\\{L1, L2\\}$), `L1` dominates its predecessor `L1` but does not strictly dominate `R`. So, $R \\in DF(L1)$.\n    - Thus, $DF(L1) = \\{H, EJ, R\\}$.\n- $DF(L2)$: By symmetry with `L1`, $DF(L2) = \\{H, EJ, R\\}$.\n\n**Iterated Dominance Frontier (IDF):**\nThe set of candidate blocks is $IDF(D) = IDF(\\{P, L1, L2\\})$.\n- $IDF_0(D) = DF(P) \\cup DF(L1) \\cup DF(L2) = \\emptyset \\cup \\{H, EJ, R\\} \\cup \\{H, EJ, R\\} = \\{H, EJ, R\\}$.\n- To iterate, we compute the DFs of the blocks in $IDF_0(D)$:\n    - $DF(H)$: The loop-back edges from `L1` and `L2` to `H` mean that $H$ is in its own dominance frontier. $H$ dominates a predecessor of itself (`L1` or `L2`) but does not strictly dominate itself. So, $DF(H)=\\{H\\}$.\n    - $DF(EJ)$: The successor of `EJ` is `OUT`. `EJ` dominates its predecessor `EJ` for the path to `OUT`, but `EJ` does not strictly dominate `OUT`. So, $OUT \\in DF(EJ)$. Thus, $DF(EJ) = \\{OUT\\}$.\n    - $DF(R)$: By symmetry with `EJ`, $DF(R) = \\{OUT\\}$.\n- $IDF_1(D) = IDF_0(D) \\cup DF(H) \\cup DF(EJ) \\cup DF(R) = \\{H, EJ, R\\} \\cup \\{H\\} \\cup \\{OUT\\} \\cup \\{OUT\\} = \\{H, EJ, R, OUT\\}$.\n- For the next iteration, we need $DF(OUT)$. Since `OUT` has no successors in the given CFG fragment, $DF(OUT) = \\emptyset$. The iteration has converged.\nThe set of candidate blocks for $\\phi$-functions is $\\{H, EJ, R, OUT\\}$.\n\n**2.2. Pruning with Liveness Analysis**\n\nA $\\phi$-function is placed at a block $Y$ only if $Y \\in IDF(D)$ and $z$ is live-in at $Y$. We check the liveness condition for each candidate block.\n\n- **Candidate `H`:** A variable is live-in at `H` if there is a path from `H` to a use of $z$ that is not killed by a redefinition.\n    - Path `H` $\\rightarrow$ `L1`: Block `L1` contains the statement $z := z + 1$, which uses $z$. This use is reached from `H` without an intermediate redefinition of $z$.\n    - Path `H` $\\rightarrow$ `L2`: Block `L2` contains the statement $z := 3 \\times z$, which uses $z$. This use is reached from `H` without an intermediate redefinition of $z$.\n    - Since such paths exist, $z$ is live-in at `H`.\n    - **Result:** A $\\phi$-function for $z$ is placed at `H`.\n\n- **Candidate `EJ`:**\n    - Block `EJ` itself contains the statement $x := z - 3$, which is a use of $z$.\n    - A path from the entry of `EJ` to this use exists within the block.\n    - Thus, $z$ is live-in at `EJ`.\n    - **Result:** A $\\phi$-function for $z$ is placed at `EJ`.\n\n- **Candidate `R`:**\n    - The problem states that `R` \"does not use $z$\". Its successor is `OUT`.\n    - `OUT` is stated to have \"no further use of $z$\".\n    - Therefore, there is no path starting from the entry of `R` that leads to a use of $z$.\n    - Thus, $z$ is **not** live-in at `R`.\n    - **Result:** The potential $\\phi$-function at `R` is pruned.\n\n- **Candidate `OUT`:**\n    - The problem states that `OUT` has \"no further use of $z$\".\n    - Any path starting from the entry of `OUT` does not lead to a use of $z$.\n    - Thus, $z$ is **not** live-in at `OUT`.\n    - **Result:** The potential $\\phi$-function at `OUT` is pruned.\n\n**2.3. Final Count**\n\nThe blocks where pruned SSA requires a $\\phi$-function for variable $z$ are those that survive the liveness-based pruning:\n- `H`: Yes\n- `EJ`: Yes\n- `R`: No\n- `OUT`: No\n\nThe total number of $\\phi$-functions is the count of \"Yes\" entries, which is $2$.",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}