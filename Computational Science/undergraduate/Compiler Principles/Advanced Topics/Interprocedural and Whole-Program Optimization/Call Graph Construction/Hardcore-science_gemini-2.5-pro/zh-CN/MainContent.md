## 引言
在现代[编译器设计](@entry_id:271989)中，**[调用图](@entry_id:747097) (Call Graph)** 是一种描绘程序中函数间调用关系的基础[数据结构](@entry_id:262134)，其准确性直接影响着高级优化的效果和[静态分析](@entry_id:755368)的可靠性。然而，面对函数指针、虚方法等复杂的语言特性，如何在编译期静态地、安全地确定所有可能的调用目标，构成了一个核心挑战。本文旨在系统性地揭示[调用图](@entry_id:747097)构建的全过程，帮助读者深入理解这一关键的编译器技术。

本文将分为三个部分展开。在**“原理与机制”**一章中，我们将首先建立[调用图](@entry_id:747097)的基本概念，强调其健全性原则，并区分直接调用与间接调用。随后，我们将深入探讨解析间接调用的核心技术，包括针对函数指针的[指向分析](@entry_id:753542)和针对动态派发的类层次[结构分析](@entry_id:153861)与快速类型分析。在**“应用与跨学科联系”**一章中，我们将展示[调用图](@entry_id:747097)在实际中的广泛应用，从死代码消除、过程间优化等编译器经典任务，到其在软件工程、[并发编程](@entry_id:637538)以及区块链安[全等](@entry_id:273198)领域的关键作用。最后，在**“动手实践”**部分，读者将通过一系列精心设计的练习，亲手为不同编程[范式](@entry_id:161181)下的代码片段构建[调用图](@entry_id:747097)，将理论知识转化为实践能力。

## 原理与机制

在编译器的诸多分析与优化任务中，程序的**[调用图](@entry_id:747097) (Call Graph)** 是一种至关重要的基础性数据结构。它以图的形式描绘了程序中函数（或过程）之间可能存在的调用关系。一个精确且可靠的[调用图](@entry_id:747097)是进行有效的[过程间分析](@entry_id:750770) (Interprocedural Analysis)、[代码优化](@entry_id:747441)（如内联、死代码消除）以及安全漏洞检测的前提。本章将深入探讨[调用图](@entry_id:747097)的构建原理、核心机制以及在面对现代编程语言复杂特性时所采用的各种分析技术。

### [调用图](@entry_id:747097)的基本概念

#### 什么是[调用图](@entry_id:747097)？

一个[调用图](@entry_id:747097)可以形式化地表示为一个[有向图](@entry_id:272310) $G=(V, E)$，其中：

-   **节点集 $V$ (Vertices)**：代表程序中所有的函数或过程。
-   **[边集](@entry_id:267160) $E$ (Edges)**：代表过程之间的调用关系。一条从节点 $u$ 指向节点 $v$ 的有向边 $(u, v) \in E$ 表示，在程序的某个执行过程中，函数 $u$ 内部存在一个调用点，该调用点可能会调用函数 $v$。

[调用图](@entry_id:747097)的构建旨在静态地（即在编译时，不实际运行程序）识别出所有潜在的运行时调用。这是编译器进行全局性分析和优化的基础，因为它揭示了信息（如数据流、常量值等）如何在不同函数间传递。

#### [调用图](@entry_id:747097)的健全性

在构建[调用图](@entry_id:747097)时，首要的原则是**健全性 (Soundness)**。一个[调用图](@entry_id:747097)被称为健全的，当且仅当它包含了程序在*任何可能*的执行中发生的所有实际调用。换言之，它必须是真实调用关系的一个**过近似 (Over-approximation)**。如果程序在运行时可能发生一次从 $u$ 到 $v$ 的调用，那么健全的[调用图](@entry_id:747097) $G=(V, E)$ 中必须包含边 $(u, v)$。

我们可以通过程序的**执行轨迹 (Execution Trace)** 来更形式化地理解健全性。一个执行轨迹记录了单次具体运行中发生的一系列调用事件。例如，$(u \to v)$ 表示在某次运行中，函数 $u$ 实际调用了函数 $v$。如果我们将所有可能的执行轨迹中出现过的所有调用事件汇集起来，得到一个集合 $\mathcal{R}$，那么一个健全的[调用图](@entry_id:747097)的[边集](@entry_id:267160) $E$ 必须满足 $\mathcal{R} \subseteq E$ 。

为何健全性如此重要？因为它保证了基于[调用图](@entry_id:747097)进行的优化的**安全性 (Safety)**。例如，如果一个编译器根据[调用图](@entry_id:747097)得出结论“函数 $g$ 永远不会被函数 $f$ 调用”（即 $(f, g) \notin E$），并基于此信息进行优化（比如移除一段依赖于此调用的代码），那么这个结论必须对所有可能的执行都成立。如果[调用图](@entry_id:747097)是不健全的，遗漏了某条可能的边 $(f, g)$，那么这种优化就可能破坏程序的正确性 。一个不包含在健全[调用图](@entry_id:747097)中的边，代表了一次绝无可能发生的调用。

#### May-Call 与 Must-Call 分析

在实践中，我们区分两种主要的调用关系分析：

-   **May-Call 分析**：构建一个包含所有*可能*发生的调用的图。这正是我们通常所说的健全[调用图](@entry_id:747097)，它是一个过近似。其[边集](@entry_id:267160) $E_{\text{may}}$ 必须包含所有实际可能发生的调用。这个信息对于保证优化的**安全性**至关重要。例如，在进行虚函数[去虚拟化](@entry_id:748352)时，分析必须识别出所有可能的目标，任何遗漏都将导致错误。

-   **Must-Call 分析**：构建一个只包含在*所有*可行执行路径上都*必然*发生的调用的图。其[边集](@entry_id:267160) $E_{\text{must}}$ 是真实调用关系的一个**欠近似 (Under-approximation)**。例如，如果每次执行函数 $f$ 时都必然会调用日志函数 $\ell$，那么边 $(f, \ell)$ 就属于 $E_{\text{must}}$。

这两种分析提供了不同性质的信息，并且它们之间存在一个明确的关系：对于任何程序，必然有 $E_{\text{must}} \subseteq E_{\text{may}}$ 。Must-Call 信息对于评估优化的**收益性 (Profitability)** 极具价值。例如，如果知道 $(f, \ell) \in E_{\text{must}}$，编译器就可以更自信地对这个调用点进行如内联等重量级优化，因为优化的收益将在每一次 $f$ 的执行中都得到体现。相反，仅凭 $(f, g) \in E_{\text{may}}$ 的信息，编译器无法判断该调用是否频繁发生，也许它位于一个极少执行的“冷”分支上，此时优化的开销可能得不偿失 。

### 构建[调用图](@entry_id:747097)：从直接调用到间接调用

[调用图](@entry_id:747097)的构建过程可以分为两部分：处理简单的直接调用和应对复杂的间接调用。

#### 直接调用及其在编译流程中的演变

**直接调用 (Direct Call)** 是指调用目标在语法上被明确指定的调用，例如 `foo()` 或 `Math.sin()`。在源代码层面，识别这些调用相对直接，只需进行[语法分析](@entry_id:267960)即可。

然而，[调用图](@entry_id:747097)并非一成不变。在从高级语言源代码到低级[中间表示](@entry_id:750746) (Intermediate Representation, IR) 乃至最终的机器码的转换过程中，编译器会执行各种变换，这些变换会深刻地改变[调用图](@entry_id:747097)的结构 。

-   **内联 (Inlining)**：编译器可能将一个函数（如 $g$）的函数体直接替换到其调用点（如在 $f$ 中）。这会导致原本存在的调用边 $(f, g)$ 在IR层面的[调用图](@entry_id:747097)中消失。如果函数 $g$ 在所有调用点都被完全内联，其独立的IR过程甚至可能被彻底删除。

-   **克隆与特化 (Cloning and Specialization)**：为了优化，编译器可能会将一个[源函数](@entry_id:161358) $g$ 复制成多个特化的IR版本，例如 $g^{(1)}, g^{(2)}, \dots$。这些克隆体都源于同一个[源函数](@entry_id:161358)，但可能因为针对不同的调用上下文（如常量参数）而有所不同。

-   **大纲化 (Outlining)**：与内联相反，编译器可能将一个函数（如 $f$）内部的某块代码区域提取出来，形成一个新的、仅在IR层面存在的辅助函数 $s$。此时，会在IR[调用图](@entry_id:747097)中引入一条新的从 $f$ 到 $s$ 的边。

这些变换说明，源代码层面的[调用图](@entry_id:747097)与IR层面的[调用图](@entry_id:747097)之间存在一种复杂的映射关系。一个[源函数](@entry_id:161358)可能对应多个、一个或零个（在完全内联后）IR过程。同时，IR层面的[调用图](@entry_id:747097)中可能存在一些在源代码中找不到对应物的“合成”函数 。尽管存在这些变换，一个关键的[不变性](@entry_id:140168)通常被保持：IR层面两个过程之间的调用关系，若这两个过程分别源于[源函数](@entry_id:161358) $f$ 和 $g$，那么源程序中必然存在从 $f$ 到 $g$ 的调用路径（或由大纲化等变换引入）。

#### 间接调用的挑战

**间接调用 (Indirect Call)** 是指调用目标在编译时无法通过简单的[语法分析](@entry_id:267960)确定，必须在运行时才能决议。这在现代编程语言中非常普遍，主要形式包括：

-   **函数指针调用 (Function Pointer Calls)**：通过存储在变量中的函数地址进行调用，如 C/C++ 中的 `(*p)()`。
-   **动态派发 (Dynamic Dispatch)**：在面向对象语言中，通过基类或接口引用调用虚方法或接口方法，如 Java/C++ 中的 `shape->draw()`。

对于间接调用，编译器必须进行[静态分析](@entry_id:755368)，以保守地计算出所有可能的目标集合。一个简单的、仅基于名称的解析方案是完全不够的，因为它无法追踪指针的传递和别名关系 。

### 解析间接调用的核心技术

为了处理间接调用并构建一个健全的[调用图](@entry_id:747097)，编译器采用了多种专门的[静态分析](@entry_id:755368)技术。

#### 函数[指针分析](@entry_id:753541)：[指向分析](@entry_id:753542)

对于通过函数指针进行的调用，核心任务是确定该指针在运行时可能指向哪些函数。这项任务由**[指向分析](@entry_id:753542) (Points-To Analysis, PTA)** 完成。[指向分析](@entry_id:753542)的目标是为程序中的每个指针变量计算其**指向集 (Points-to Set)**，即该指针可能指向的内存地址（在这里特指函数地址）的集合。

[指向分析](@entry_id:753542)的精度和成本取决于其设计上的多个维度权衡：

-   **流不敏感 vs. 流敏感 (Flow-Insensitive vs. Flow-Sensitive)**：
    **流不敏感分析**忽略语句的执行顺序，将整个程序（或函数）中的所有赋值语句视为一个无序集合。一个指针的指向集是所有曾赋给它的地址的并集。这种分析速度快，但精度较低。
    **流敏感分析**则精确地遵循程序的控制流。它为每个程序点计算指针的指向集，赋值语句会更新（杀死旧值，赋予新值）指向集。在[控制流](@entry_id:273851)汇合点（如 `if` 语句结束后），来自不同分支的指向集会被合并（取并集）。流敏感分析更精确，因为它能利用代码的顺序信息来排除不成立的调用目标，但其分析成本也更高 。

    例如，考虑代码片段：`p =  (*p)(); p =  (*p)();`。流不敏感分析会得出 $p$ 的指向集为 $\{f1, f2\}$，因此两次调用都可能指向 $f1$ 或 $f2$。而流敏感分析会精确地知道第一次调用指向 $f1$，第二次调用指向 $f2$。

-   **上下文不敏感 vs. 上下文敏感 (Context-Insensitive vs. Context-Sensitive)**：
    **上下文不敏感分析**在分析一个函数时，不区分它是由哪个调用者、在哪个调用上下文中调用的。当分析一个[函数调用](@entry_id:753765) `h(p)` 时，它会将实际参数 `p` 的指向集信息合并到形式参数（`h` 的参数）的指向集中。这意味着来自不同调用点的指针信息会在被调函数内部“混合”，可能导致精度损失。
    **[上下文敏感分析](@entry_id:747793)**则会为不同的调用上下文分别分析被调函数，从而保持信息的隔离，获得更高的精度。例如，它可能会区分对 `h()` 的不同调用（例如，在不同的调用点），并为 `h` 生成两个特化的分析结果。

[指向分析](@entry_id:753542)的这些精度维度（以及其他如字段敏感性、数组索引敏感性等）共同决定了[调用图](@entry_id:747097)的[精确度](@entry_id:143382)。一个更精确的[指向分析](@entry_id:753542)能生成更小的目标集，从而构建出边更少的[调用图](@entry_id:747097)，为后续优化提供更多机会。

#### 动态派发分析：CHA 与 RTA

对于面向对象语言中的虚方法调用（动态派发），编译器同样需要确定可能的目标。

-   **类层次[结构分析](@entry_id:153861) (Class Hierarchy Analysis, CHA)**：这是最基础且易于实现的分析方法。对于一个静态类型为 $T$ 的对象上的虚方法调用 `obj.m()`，CHA会查找类 $T$ 及其在整个程序类继承层次结构中的所有子类（包括直接和间接子类），将它们当中所有实现了方法 `m` 的版本都作为潜在的调用目标。CHA不关心一个类是否在程序中被真正实例化，只要它存在于类库中，就会被考虑 。

-   **快速类型分析 (Rapid Type Analysis, RTA)**：RTA 是对 CHA 的一个重要改进。它在CHA的基础上，额外考虑了程序中哪些类被**实际实例化**。RTA首先通过一次遍历，找出程序中所有 `new` 关键字创建的对象的类型，形成一个“已实例化类型”集合 $Types_{seen}$。然后，对于一个虚调用，RTA计算出的目标集是CHA目标集与那些属于 $Types_{seen}$ 的类所对应的方法的交集 。

通过只考虑实际可能存在的对象类型，RTA能够有效地剪枝掉那些仅存在于类库但从未在当前程序中实例化的子类所对应的方法，从而生成比CHA更精确（即边更少）的[调用图](@entry_id:747097) 。

### 算法基础与现实挑战

#### 构建算法：[不动点迭代](@entry_id:749443)

从全局来看，[调用图](@entry_id:747097)的构建过程是一个相互依赖、逐步完善的**[不动点迭代](@entry_id:749443) (Fixpoint Iteration)** 过程，这在[数据流](@entry_id:748201)分析中非常典型。算法的核心思想是：[调用图](@entry_id:747097)的边和可达函数的集合是相互促进增长的。发现一条新的调用边，可能会将一个新的函数标记为“可达”；而一个新的可达函数被处理时，其内部的调用点又可能为[调用图](@entry_id:747097)增添新的边。

这个过程可以被形式化地描述为一个在格 (Lattice) 上的[单调函数](@entry_id:145115)求最小[不动点](@entry_id:156394)的过程 。

1.  **初始化**：从一个初始状态开始，通常是只包含程序入口点（如 `main` 函数）的集合和一个空[调用图](@entry_id:747097) $G_0 = (\varnothing, \varnothing)$。维护一个“待处理”函数的工作列表 (worklist)，初始时只包含入口点。

2.  **迭代**：只要工作列表不为空，就从中取出一个函数 $f$ 进行处理。分析 $f$ 内部的所有调用点：
    -   对于**直接调用** $f \to g$，如果 $g$ 尚未被处理，则将其加入工作列表，并向[调用图](@entry_id:747097)添加边 $(f, g)$。
    -   对于**间接调用**（如通过指针 `p`），使用当前的分析信息（如 `p` 的指向集）来解析所有可能的目标 $\{g_1, g_2, \dots\}$。对于每个目标 $g_i$，如果它尚未被处理，则加入工作列表，并向[调用图](@entry_id:747097)添加边 $(f, g_i)$。

3.  **合并与收敛**：在处理多个模块（如独立编译单元）时，每个模块的分析结果（部分[调用图](@entry_id:747097)）需要被合并到全局图中。这个[合并操作](@entry_id:636132)必须是单调递增的，通常是取并集 ($G_{k+1} = G_k \cup H$)，其中 $H$ 是新分析出的信息。整个迭代过程会不断地向[调用图](@entry_id:747097)中添加节点和边，直到某一次迭代后，图不再发生任何变化，此时算法达到**[不动点](@entry_id:156394) (Fixpoint)**，宣告收敛。由于程序中的函数和可能的边是有限的，这个过程保证会终止。

这种迭代算法，无论处理模块的顺序如何（称为**混沌迭代**），最终都会收敛到同一个唯一的、最小的健全[调用图](@entry_id:747097)，为整个程序的分析提供了坚实的基础 。

#### 应对现实挑战：动态加载

在真实世界的软件中，一个严峻的挑战是**动态加载**，即程序在运行时根据计算出的字符串名称从外部库（如 `.dll` 或 `.so` 文件）中加载函数。例如，`lookup("process_data")`。

这种情况打破了传统的**封闭世界假设 (Closed-World Assumption)**，即编译器在编译时可以访问到程序的所有代码。当调用的目标名称是一个在运行时才能确定的字符串时，[静态分析](@entry_id:755368)器面临着一个看似无穷的目标集。

为了在这种情况下依然能构建一个健全的[调用图](@entry_id:747097)，必须采取保守的策略 ：

-   **最保守的健全策略**：分析器可以假设，任何与调用点类型签名匹配的、且存在于程序可能加载的所有捆绑库中的导出函数，都是一个潜在的目标。这会向[调用图](@entry_id:747097)中加入大量的边，虽然健全，但可能极其不精确。

-   **通过程序变换增强分析**：一个更高级的方法是，编译器可以对程序进行变换。例如，在动态加载的调用点前插入一个运行时检查，强制要求加载的函数名称必须在一个预定义的**白名单 (Whitelist)** $\mathcal{W}$ 中。通过这个变换，[静态分析](@entry_id:755368)器就可以安全地将目标集缩小到白名单中的函数，从而在保持健全性的同时，极大地提高了[调用图](@entry_id:747097)的精度。

与之相对，一些基于历史数据或日志的启发式方法（如只考虑最常见的几个目标）虽然可能在多数情况下正确，但它们本质上是**不健全**的，因为总存在未被观察到的执行路径，这在要求绝对正确的优化场景中是不可接受的 。

综上所述，[调用图](@entry_id:747097)的构建是一个复杂而精妙的过程，它始于对健全性的基本要求，发展出针对不同语言特性的专门分析技术，并最终依赖于一个稳健的迭代算法框架。它是编译器理解程序全局行为、释放强大优化潜能的基石。