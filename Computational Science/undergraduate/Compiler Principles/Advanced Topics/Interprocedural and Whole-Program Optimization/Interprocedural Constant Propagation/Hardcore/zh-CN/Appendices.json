{
    "hands_on_practices": [
        {
            "introduction": "首先，让我们来追踪跨过程常量传播的基本机制。第一个练习  将指导你逐步完成将常量参数代入函数调用并计算结果的过程。通过跟踪涉及位运算的一系列嵌套函数调用的数据流，你将亲眼见证编译器如何将复杂的表达式简化为单一的常量值。",
            "id": "3648241",
            "problem": "考虑无符号$32$位整数及其通常的位运算符：按位与 $\\mathbin{\\}$、按位或 $\\mathbin{|}$、异或 $\\oplus$、逻辑右移 $\\gg$ 和左移 $\\ll$。假设一个纯粹的、无副作用的程序包含以下函数，这些函数被建模为作用于无符号$32$位整数的数学函数：\n- $g(x) \\triangleq x \\mathbin{\\} 0x\\mathrm{FF}$。\n- $h(z) \\triangleq g(z) \\mathbin{|} \\big((z \\gg 8) \\mathbin{\\} 0x\\mathrm{0F}\\big)$。\n- $f(p) \\triangleq \\big(\\big(g(p) + g(0x\\mathrm{1234})\\big) \\oplus h\\big(p \\mathbin{|} 0x\\mathrm{00F0}\\big)\\big) \\mathbin{\\} 0x\\mathrm{7F}$。\n\n入口点计算 $f(0x\\mathrm{5600})$。仅使用关于数据流分析的第一性原理以及上述运算符的语义，解释过程间常量传播如何发现并折叠对 $g$ 和 $h$ 的调用中的常量，包括将 $g(0x\\mathrm{1234})$ 跨过程折叠为 $0x\\mathrm{34}$。然后，通过完全应用这些常量折叠，确定 $f(0x\\mathrm{5600})$ 返回的确切值。\n\n将最终答案表示为一个精确的十进制整数。不需要四舍五入。",
            "solution": "题目要求解释过程间常量传播（ICP）如何确定 $f(0x\\mathrm{5600})$ 的值，并计算出这个值。该过程涉及跨函数边界跟踪常量值，以及折叠其操作数均为常量的表达式。\n\n首先，我们根据要求，从第一性原理简要概述过程间常量传播。ICP 是一种编译器优化技术，它将常量传播扩展到单个函数的边界之外。它作为一种数据流分析运行，其目标是确定在程序的每个点上，一个变量是否持有特定的常量值。该分析通常对每个变量使用一个可能值的格（lattice），通常由三个级别组成：\n1.  $\\top$ (顶): 代表值是非常量（Non-constant），即在不同的执行路径上可能持有不同的值，或者其值无法在编译期确定。\n2.  一组常量值 $c_1, c_2, \\ldots$：代表变量持有一个已知的、特定的常量值。\n3.  $\\bot$ (底): 代表值是未初始化的，或该程序点是不可达的。\n\n分析过程是迭代进行的。当一个函数（比如 $q(\\text{params})$）以常量参数被调用时（例如 $q(c_1, c_2)$），分析可以创建一个 $q$ 的特化版本，其中其形式参数被这些常量值替换。这允许在 $q$ 的函数体内进行常量折叠。如果分析确定这个 $q$ 的特化版本总是返回一个常量值 $R$，那么调用点 $q(c_1, c_2)$ 就可以被直接替换为 $R$。这种替换是过程间常量折叠的精髓。\n\n现在，我们应用这个过程来计算 $f(0x\\mathrm{5600})$。入口点是表达式 $f(p)$，其参数 $p$ 的常量值为 $0x\\mathrm{5600}$。$f(p)$ 的定义是：\n$$f(p) \\triangleq \\big(\\big(g(p) + g(0x\\mathrm{1234})\\big) \\oplus h\\big(p \\mathbin{|} 0x\\mathrm{00F0}\\big)\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n代入 $p = 0x\\mathrm{5600}$ 得到：\n$$f(0x\\mathrm{5600}) = \\big(\\big(g(0x\\mathrm{5600}) + g(0x\\mathrm{1234})\\big) \\oplus h\\big(0x\\mathrm{5600} \\mathbin{|} 0x\\mathrm{00F0}\\big)\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n\n分析通过评估可以简化为常量的子表达式来进行。\n\n1.  **分析调用 $g(0x\\mathrm{1234})$**。参数 $0x\\mathrm{1234}$ 是一个常量。编译器用 $x = 0x\\mathrm{1234}$ 分析 $g(x) \\triangleq x \\mathbin{\\} 0x\\mathrm{FF}$ 的函数体。\n    $$g(0x\\mathrm{1234}) = 0x\\mathrm{1234} \\mathbin{\\} 0x\\mathrm{FF}$$\n    用二进制表示，这是 $0001\\,0010\\,0011\\,0100_2 \\mathbin{\\} 1111\\,1111_2$，结果是 $0011\\,0100_2$。\n    $$g(0x\\mathrm{1234}) = 0x\\mathrm{34}$$\n    ICP 确定 $g(0x\\mathrm{1234})$ 返回常量 $0x\\mathrm{34}$。然后这个调用被折叠，将 $g(0x\\mathrm{1234})$ 替换为 $0x\\mathrm{34}$。\n\n2.  **分析 $h$ 的参数**。参数是 $p \\mathbin{|} 0x\\mathrm{00F0}$。因为 $p$ 是常量 $0x\\mathrm{5600}$，所以这个表达式可以被折叠。\n    $$0x\\mathrm{5600} \\mathbin{|} 0x\\mathrm{00F0} = 0101\\,0110\\,0000\\,0000_2 \\mathbin{|} 0000\\,0000\\,1111\\,0000_2 = 0101\\,0110\\,1111\\,0000_2 = 0x\\mathrm{56F0}$$\n    对 $h$ 的调用变成了 $h(0x\\mathrm{56F0})$。\n\n3.  现在 $f$ 的主表达式简化为：\n    $$f(0x\\mathrm{5600}) = \\big(\\big(g(0x\\mathrm{5600}) + 0x\\mathrm{34}\\big) \\oplus h(0x\\mathrm{56F0})\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n\n4.  **分析调用 $g(0x\\mathrm{5600})$**。参数是常量 $0x\\mathrm{5600}$。\n    $$g(0x\\mathrm{5600}) = 0x\\mathrm{5600} \\mathbin{\\} 0x\\mathrm{FF} = 0x\\mathrm{00}$$\n    这个调用被折叠为常量 $0x\\mathrm{00}$。\n\n5.  **分析调用 $h(0x\\mathrm{56F0})$**。参数是常量 $0x\\mathrm{56F0}$。其定义是 $h(z) \\triangleq g(z) \\mathbin{|} \\big((z \\gg 8) \\mathbin{\\} 0x\\mathrm{0F}\\big)$。当 $z=0x\\mathrm{56F0}$ 时，这变成：\n    $$h(0x\\mathrm{56F0}) = g(0x\\mathrm{56F0}) \\mathbin{|} \\big((0x\\mathrm{56F0} \\gg 8) \\mathbin{\\} 0x\\mathrm{0F}\\big)$$\n    这需要对 $g(0x\\mathrm{56F0})$ 进行内部分析：\n    $$g(0x\\mathrm{56F0}) = 0x\\mathrm{56F0} \\mathbin{\\} 0x\\mathrm{FF} = 0x\\mathrm{F0}$$\n    表达式的另一部分被折叠：\n    $$0x\\mathrm{56F0} \\gg 8 = 0x\\mathrm{56}$$\n    $$(0x\\mathrm{56F0} \\gg 8) \\mathbin{\\} 0x\\mathrm{0F} = 0x\\mathrm{56} \\mathbin{\\} 0x\\mathrm{0F} = 0101\\,0110_2 \\mathbin{\\} 0000\\,1111_2 = 0000\\,0110_2 = 0x\\mathrm{06}$$\n    将这些值代回到 $h$ 的表达式中：\n    $$h(0x\\mathrm{56F0}) = 0x\\mathrm{F0} \\mathbin{|} 0x\\mathrm{06} = 1111\\,0000_2 \\mathbin{|} 0000\\,0110_2 = 1111\\,0110_2 = 0x\\mathrm{F6}$$\n    调用 $h(0x\\mathrm{56F0})$ 被折叠为常量 $0x\\mathrm{F6}$。\n\n6.  **最终计算**。所有函数调用都已被折叠为常量。我们将这些值代回到 $f(0x\\mathrm{5600})$ 的表达式中：\n    $$f(0x\\mathrm{5600}) = \\big((0x\\mathrm{00} + 0x\\mathrm{34}) \\oplus 0x\\mathrm{F6}\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n    现在，我们执行最后的算术和位运算。\n    - 加法：$0x\\mathrm{00} + 0x\\mathrm{34} = 0x\\mathrm{34}$。\n    - 异或：$0x\\mathrm{34} \\oplus 0x\\mathrm{F6}$。用二进制表示：\n      $0x\\mathrm{34} = 0011\\,0100_2$\n      $0x\\mathrm{F6} = 1111\\,0110_2$\n      $0x\\mathrm{34} \\oplus 0x\\mathrm{F6} = 1100\\,0010_2 = 0x\\mathrm{C2}$。\n    - 按位与：$0x\\mathrm{C2} \\mathbin{\\} 0x\\mathrm{7F}$。用二进制表示：\n      $0x\\mathrm{C2} = 1100\\,0010_2$\n      $0x\\mathrm{7F} = 0111\\,1111_2$\n      $0x\\mathrm{C2} \\mathbin{\\} 0x\\mathrm{7F} = 0100\\,0010_2 = 0x\\mathrm{42}$。\n\n最终值为 $0x\\mathrm{42}$。题目要求答案为十进制。我们将十六进制结果转换为十进制：\n$$0x\\mathrm{42} = 4 \\times 16^1 + 2 \\times 16^0 = 64 + 2 = 66$$\n因此，$f(0x\\mathrm{5600})$ 返回的值是 $66$。",
            "answer": "$$\\boxed{66}$$"
        },
        {
            "introduction": "现实世界的程序经常从多个位置用不同的参数调用同一个函数。一种简单的分析可能会合并来自这些调用的信息，从而失去精度。这个练习  展示了*上下文敏感*分析的威力，它独立分析每一次函数调用，从而实现更积极的优化。你将看到编译器如何为同一个函数确定不同的常量结果，甚至处理默认参数值等特性。",
            "id": "3648314",
            "problem": "一种语言使用传值调用（call-by-value），包含纯函数，并支持默认参数值。考虑以下用一阶、无副作用的伪代码编写的程序。如果一次调用省略了带有默认值形式参数的实际参数，则被调用者的形式参数将采用默认值。所有算术运算都是在整数上进行的。\n\n- 函数定义：\n  - $\\;k(v)$:\n    - 如果 $\\;v \\bmod 2 = 1\\;$ 则返回 $\\;v\\;$ 否则返回 $\\;2 \\times v$。\n  - $\\;h(u)$:\n    - 返回 $\\;u^{2} - 2u + 1$。\n  - $\\;g(x = 5)$:\n    - 令 $\\;y := x + 3$。\n    - 如果 $\\;y > 10\\;$ 则令 $\\;z := y \\times 2\\;$ 否则令 $\\;z := y - 4$。\n    - 返回 $\\;h(z) + k(x)$。\n\n- 主程序：\n  - 令 $\\;a := g()$。\n  - 令 $\\;b := g(7)$。\n  - 令 $\\;c := a + 2 \\times b$。\n  - 输出 $\\;c$。\n\n使用在过程间控制流图（ICFG）上具有每次调用点上下文敏感性的过程间常量传播，以及标准的常量传播格，其元素为 $\\;\\{\\bot\\;\\} \\cup \\mathbb{Z} \\cup \\{\\top\\;\\}$，对于任意整数 $\\;n\\;$，排序为 $\\;\\bot \\sqsubset n \\sqsubset \\top\\;$。将来自实际参数的常量（包括调用 $\\;g()\\;$ 中的默认绑定）传播到 $\\;g\\;$ 的函数体中，然后再传播到 $\\;h\\;$ 和 $\\;k\\;$ 中，并在格值为已知整数的任何地方执行常量折叠。假设没有别名、没有异常，并且控制流图（CFG）只有所示的分支。\n\n在完全应用所述的过程间常量传播和常量折叠后，运行时为 $\\;c\\;$ 计算出的确切值是多少？请给出确切的整数答案，不要四舍五入。",
            "solution": "目标是确定在应用了具有每次调用点上下文敏感性的过程间常量传播和常量折叠后，变量 $c$ 的最终值。分析将模拟每个函数调用的特定上下文。\n\n主程序包含三个顺序赋值：\n1. `令 a := g()`\n2. `令 b := g(7)`\n3. `令 c := a + 2 × b`\n\n我们将按顺序分析每个赋值。\n\n**1. `令 a := g()` 的分析**\n\n此调用没有提供参数，因此使用 `g` 的默认参数，即 `x = 5`。我们现在在 `x=5` 的上下文中分析 `g` 的函数体。\n\n- **`令 y := x + 3`**: 因为 `x=5`，此表达式被折叠为 `y := 5 + 3`，得到 `y=8`。\n- **`如果 y > 10`**: 条件变为 `8 > 10`，其结果为假。因此，分析沿 `else` 分支进行。\n- **`令 z := y - 4`**: 因为 `y=8`，此表达式被折叠为 `z := 8 - 4`，得到 `z=4`。\n- **`返回 h(z) + k(x)`**: 返回表达式现在是 `h(4) + k(5)`。我们分别分析这两个调用。\n  - **对 `h(4)` 的调用**: 在 `h(u)` 的函数体中，`u` 被绑定为 `4`。返回表达式 `u² - 2u + 1`（即 `(u-1)²`）被计算为 `(4-1)² = 3² = 9`。因此，`h(4)` 返回常量 `9`。\n  - **对 `k(5)` 的调用**: 在 `k(v)` 的函数体中，`v` 被绑定为 `5`。条件 `v mod 2 = 1` 变为 `5 mod 2 = 1`，结果为真。因此，执行 `then` 分支，返回 `v`。`k(5)` 返回常量 `5`。\n- **`g()` 的最终返回值**: 表达式 `h(4) + k(5)` 的结果是 `9 + 5 = 14`。\n\n因此，`let a := g()` 的赋值被有效地转换为 `let a := 14`。\n\n**2. `令 b := g(7)` 的分析**\n\n此调用提供了显式参数 `7`，因此 `x` 被绑定为 `7`。我们现在在 `x=7` 的上下文中分析 `g` 的函数体。\n\n- **`令 y := x + 3`**: 因为 `x=7`，此表达式被折叠为 `y := 7 + 3`，得到 `y=10`。\n- **`如果 y > 10`**: 条件变为 `10 > 10`，其结果为假。分析再次沿 `else` 分支进行。\n- **`令 z := y - 4`**: 因为 `y=10`，此表达式被折叠为 `z := 10 - 4`，得到 `z=6`。\n- **`返回 h(z) + k(x)`**: 返回表达式现在是 `h(6) + k(7)`。\n  - **对 `h(6)` 的调用**: 在 `h(u)` 中，`u` 被绑定为 `6`。返回表达式 `(u-1)²` 被计算为 `(6-1)² = 5² = 25`。因此，`h(6)` 返回常量 `25`。\n  - **对 `k(7)` 的调用**: 在 `k(v)` 中，`v` 被绑定为 `7`。条件 `v mod 2 = 1` 变为 `7 mod 2 = 1`，结果为真。函数返回 `v`。`k(7)` 返回常量 `7`。\n- **`g(7)` 的最终返回值**: 表达式 `h(6) + k(7)` 的结果是 `25 + 7 = 32`。\n\n因此，`let b := g(7)` 的赋值被有效地转换为 `let b := 32`。\n\n**3. `令 c := a + 2 * b` 的分析**\n\n在程序的这一点上，分析器已经确定 `a=14` 和 `b=32`。最后的赋值可以进行常量折叠。\n\n- **`令 c := a + 2 × b`**: 用 `a` 和 `b` 的常量值代入，我们得到 `c := 14 + 2 * 32`。\n- 遵循运算顺序，首先执行乘法：`2 × 32 = 64`。\n- 表达式变为 `c := 14 + 64`。\n- 最后的加法得到 `c := 78`。\n\n在这些优化之后，运行时为 `c` 计算出的值是 `78`。",
            "answer": "$$\\boxed{78}$$"
        },
        {
            "introduction": "当编译器遇到一个其代码不可用的函数调用（例如，预编译库中的函数）时，会发生什么？答案在于函数摘要。最后一个练习  探讨了关于函数行为的简明摘要如何足以实现重要的优化，例如证明一个条件分支永远不会被执行。这展示了一项使跨过程分析变得实用和可扩展的关键技术。",
            "id": "3648217",
            "problem": "考虑一个对整型变量的过程间常量传播分析，该分析使用经典的常量传播格。单个变量的格定义为 $D = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$，其中 $\\bot$ 表示无信息，每个 $c \\in \\mathbb{Z}$ 表示常量 $c$，而 $\\top$ 表示冲突或未知信息。偏序关系由 $\\bot \\leq c \\leq \\top$ (对于任意 $c \\in \\mathbb{Z}$) 给出，其中对于所有 $c \\in \\mathbb{Z}$ 都有 $\\bot \\leq \\top$ 和 $c \\leq \\top$。并操作符在环境上逐点定义，对于单个变量 $v$ 而言：$c \\sqcup c = c$，$c \\sqcup c' = \\top$ (对于 $c \\neq c'$)，$c \\sqcup \\bot = c$，$c \\sqcup \\top = \\top$，其他情况对称。赋值和算术运算的转换函数是常量传播的标准函数（例如，对于赋值语句 $v := n$ 且 $n \\in \\mathbb{Z}$，转换函数将 $v$ 设置为 $n$；对于二元运算 $v := a \\,\\text{op}\\, b$，如果 $a$ 和 $b$ 都是常量，转换函数将 $v$ 设置为计算出的常量，否则设置为 $\\top$）。\n\n给定以下两个对整数进行操作的过程：\n- 过程 $g$ 接受一个整数输入 $y$ 并返回一个整数。分析无法获知 $g$ 的函数体，但它有一个摘要 $S_{g}$，该摘要是可靠且足够精确的，以保证以下属性：$S_{g}$ 断言 $g(2) \\neq 0$。\n- 过程 $f$ 定义如下（伪代码形式，所有整数字面量均为数学常量）：\n  1. 令 $r := 9$。\n  2. 如果 $g(x) = 0$ 则设置 $r := x + 7$。\n  3. 返回 $r$。\n\n假设该过程间常量传播分析在参数值级别上是上下文敏感的，并且在分析对 $g$ 的调用时使用 $S_{g}$。分析从一个初始环境开始，在该环境中，对 $f$ 的调用点处我们有 $x = 2$ 作为常量，即输入环境将 $x$ 映射到 $2$。\n\n使用上述格和转换语义作为基本依据，确定当 $x = 2$ 且摘要 $S_{g}$ 成立时，分析在过程 $f$ 的出口处为 $r$ 的值推导出的常量。请以单个整数形式提供最终结果。无需四舍五入。以纯数字形式表示答案，不带任何单位。",
            "solution": "任务是确定在分析从输入 $x$ 为常量 $2$ 的信息开始时，为过程 $f$ 出口处的变量 $r$ 推导出的常量值。\n\n设环境（或抽象状态）是一个从变量到格 $D$ 中值的映射。分析过程如下：\n\n1.  **进入过程 $f$：** 分析是上下文敏感的，并且是针对一个对 $f$ 的调用进行的，其中参数 $x$ 已知为 $2$。在 $f$ 开始时的初始环境是 $\\sigma_{0} = \\{x \\to 2\\}$。所有其他局部变量（如 $r$）都隐式地处于 $\\bot$ 状态。\n\n2.  **分析第 1 行：`令 r := 9`**\n    这是一个常量赋值。该语句的转换函数会更新环境。 $r$ 的值被设置为常量 $9$。环境变为：\n    $$ \\sigma_{1} = \\sigma_{0}[r \\to 9] = \\{x \\to 2, r \\to 9\\} $$\n\n3.  **分析第 2 行：`如果 g(x) = 0 则设置 r := x + 7`**\n    分析必须评估分支条件 `g(x) = 0`。\n    -   从环境 $\\sigma_1$ 中，分析知道 $x$ 是常量 $2$。因此，函数调用实际上是 $g(2)$。\n    -   问题陈述了分析对过程 $g$ 使用摘要 $S_{g}$。摘要 $S_{g}$ 断言 $g(2) \\neq 0$。\n    -   这意味着，在 $x=2$ 的特定上下文中，条件 `g(x) = 0` 保证评估为**假**。\n    -   一个可靠的静态分析可以利用此信息来确定条件语句的 `then` 分支是一条不可行路径。当 $x=2$ 时，该路径永远不会被执行。\n\n4.  **控制流与状态合并：**\n    分析推断出控制流将总是绕过 `then` 代码块，并沿着隐式的 `else` 路径继续。\n    -   **来自 `then` 分支的状态：** 由于此路径不可达，它对条件语句之后的状态没有贡献任何信息。在数据流框架中，其输出状态可以被认为是所有变量的底元素，即 $\\sigma_{then} = \\{x \\to \\bot, r \\to \\bot\\}$。\n    -   **来自 `else` 分支的状态：** `else` 分支被采用。进入此路径的环境是 $\\sigma_1 = \\{x \\to 2, r \\to 9\\}$。隐式的 `else` 代码块不包含任何语句，因此离开此路径的环境保持不变：$\\sigma_{else} = \\sigma_1 = \\{x \\to 2, r \\to 9\\}$。\n    -   在 `if-then` 语句之后的程序点的环境是所有传入控制流路径（`then` 和 `else` 分支）的环境的并集。\n    $$ \\sigma_{2} = \\sigma_{then} \\sqcup \\sigma_{else} $$\n    我们对每个变量逐点执行并操作：\n    -   对于 $x$：$\\sigma_2(x) = \\sigma_{then}(x) \\sqcup \\sigma_{else}(x) = \\bot \\sqcup 2 = 2$。\n    -   对于 $r$：$\\sigma_2(r) = \\sigma_{then}(r) \\sqcup \\sigma_{else}(r) = \\bot \\sqcup 9 = 9$。\n    因此，条件语句之后的环境是 $\\sigma_{2} = \\{x \\to 2, r \\to 9\\}$。$r$ 的值保持为 $9$。\n\n5.  **分析第 3 行：`返回 r`**\n    该过程返回变量 $r$ 的值。此时，分析已确定当前环境 $\\sigma_2$ 中 $r$ 的值是常量 $9$。\n\n因此，过程间常量传播分析推断出，对于输入 $x=2$，过程 $f$ 出口处 $r$ 的值是常量 $9$。",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}