{
    "hands_on_practices": [
        {
            "introduction": "当编译器实现闭包转换时，它必须创建一个具体的数据结构——即环境（environment）——来存储捕获的自由变量。本练习将环境这一抽象概念与内存的物理现实联系起来。通过根据标准应用程序二进制接口（ABI）的对齐规则计算精确的内存布局，你将理解编译器如何为其生成的数据结构确保性能和正确性。",
            "id": "3627610",
            "problem": "考虑一个用于64位应用程序二进制接口 (ABI) 的编译器中，对一个词法作用域函数进行闭包转换。该函数在其环境记录中捕获了三个自由变量：$x:\\mathrm{int32}$、$y:\\mathrm{double}$ 和 $z:\\mathrm{int64}$。环境是在堆上分配的一个连续记录。假设存在以下广泛使用的 ABI 对齐规则：类型为 $\\mathrm{int32}$ 的字段对齐要求为 $4$ 字节，大小为 $4$ 字节；类型为 $\\mathrm{double}$ 的字段对齐要求为 $8$ 字节，大小为 $8$ 字节；类型为 $\\mathrm{int64}$ 的字段对齐要求为 $8$ 字节，大小为 $8$ 字节。为保证正确性和互操作性，必须选择记录的对齐方式以满足其成员中最严格的字段对齐要求，并且每个字段的起始偏移量必须是其自身对齐要求的倍数。字段必须按声明顺序 $x$、然后 $y$、然后 $z$ 进行布局。\n\n根据这些基本规则，确定：\n- 环境记录的适当对齐方式，\n- 记录中 $x$、$y$ 和 $z$ 的最小非负字节偏移量，以满足所有对齐约束，\n- 在应用任何必要的尾部填充后，环境记录的最终打包大小（以字节为单位），以使总大小是记录对齐的倍数。\n\n请解释你在字段之间引入的任何填充。将 $(x, y, z)$ 的最终偏移量以及最终记录大小表示为四个以字节为单位的整数。无需四舍五入。在最终的方框答案中不要包含单位，但所有量均以字节为单位计算。",
            "solution": "本问题要求确定由编译器生成的环境记录的内存布局，具体包括其对齐方式、字段偏移量和总大小，同时遵守标准的应用程序二进制接口 (ABI) 对齐规则。\n\n### 第 1 步：问题验证\n\n根据指定标准对问题陈述进行验证。\n\n**1. 提取已知条件：**\n- 架构：$64$位 ABI。\n- 捕获的自由变量（字段）及其顺序：\n  1. $x$：类型 $\\mathrm{int32}$，大小 $4$ 字节，对齐 $4$ 字节。\n  2. $y$：类型 $\\mathrm{double}$，大小 $8$ 字节，对齐 $8$ 字节。\n  3. $z$：类型 $\\mathrm{int64}$，大小 $8$ 字节，对齐 $8$ 字节。\n- 字段布局规则：字段必须按声明顺序布局：$x$，然后 $y$，然后 $z$。\n- 字段对齐规则：每个字段的起始偏移量（从记录开头算起）必须是其自身对齐要求的倍数。\n- 记录对齐规则：整个记录的对齐方式必须等于其任何字段中最严格（即最大）的对齐要求。\n- 记录大小规则：记录的总大小必须是记录对齐的倍数，这可能需要添加尾部填充。\n\n**2. 使用提取的已知条件进行验证：**\n- **科学依据：** 该问题牢固植根于计算机科学，特别是编译器设计和系统编程领域。数据结构的对齐规则是编译器如何在现代硬件上为性能和正确性管理内存的基本概念。为 $\\mathrm{int32}$、$\\mathrm{double}$ 和 $\\mathrm{int64}$ 指定的大小和对齐方式是常见 $64$ 位 ABI（例如，System V AMD64 ABI）的标准。该问题在科学上是合理的。\n- **适定性：** 该问题提供了一套完整的规则和数据。目标是计算四个特定的整数值。约束条件定义明确，可导出一个唯一且稳定的解。\n- **客观性：** 问题陈述使用了精确的技术术语，没有歧义或主观因素。\n\n**3. 结论与行动：**\n该问题是有效的。这是一个来自编译原理领域的适定、有科学依据且客观的问题。可以开始求解过程。\n\n### 第 2 步：解题推导\n\n通过系统地应用给定规则来推导解决方案。所有计算均以字节为单位。\n\n**1. 确定记录对齐**\n环境记录的对齐方式由其成员中最严格的对齐要求决定。\n- $x$ ($\\mathrm{int32}$) 的对齐：$4$ 字节。\n- $y$ ($\\mathrm{double}$) 的对齐：$8$ 字节。\n- $z$ ($\\mathrm{int64}$) 的对齐：$8$ 字节。\n\n最严格的对齐是这些值的最大值：\n$$ \\text{记录对齐} = \\max(4, 8, 8) = 8 \\text{ 字节} $$\n整个环境记录的基地址必须是 $8$ 的倍数。\n\n**2. 确定字段偏移量**\n我们按照指定的顺序（$x, y, z$）布局字段，在必要时添加填充以满足每个字段的对齐要求。设字段的偏移量为其相对于记录开头（偏移量 $0$）的起始字节位置。\n\n- **字段 $x$ ($\\mathrm{int32}$):**\n  - 大小：$4$ 字节。\n  - 对齐：$4$ 字节。\n  - 记录从偏移量 $0$ 开始。$x$ 的第一个可用偏移量是 $0$。\n  - 由于 $0$ 是 $4$ 的倍数（即 $0 = 0 \\times 4$），此位置有效。\n  - **$x$ 的偏移量是 $0$。**\n  - $x$ 占据字节 $0$ 到 $3$。\n  - 记录的当前大小为 $4$ 字节。\n\n- **字段 $y$ ($\\mathrm{double}$):**\n  - 大小：$8$ 字节。\n  - 对齐：$8$ 字节。\n  - $x$ 之后的下一个可用偏移量是 $4$。\n  - $y$ 的偏移量必须是其对齐要求 $8$ 的倍数。\n  - 值 $4$ 不是 $8$ 的倍数。我们必须将偏移量前移到下一个 $8$ 的倍数。\n  - 大于或等于 $4$ 的最小的 $8$ 的倍数是 $8$。\n  - 因此，我们必须在字段 $x$ 和字段 $y$ 之间插入填充。\n  - 填充大小 = 所需偏移量 - 当前大小 = $8 - 4 = 4$ 字节。\n  - 这 $4$ 个填充字节占据偏移量 $4$ 到 $7$。\n  - **$y$ 的偏移量是 $8$。**\n  - $y$ 占据字节 $8$ 到 $15$。\n  - 记录的当前大小现在是（$y$ 的偏移量 + $y$ 的大小） = $8 + 8 = 16$ 字节。\n\n- **字段 $z$ ($\\mathrm{int64}$):**\n  - 大小：$8$ 字节。\n  - 对齐：$8$ 字节。\n  - $y$ 之后的下一个可用偏移量是 $16$。\n  - $z$ 的偏移量必须是其对齐要求 $8$ 的倍数。\n  - 由于 $16$ 是 $8$ 的倍数（即 $16 = 2 \\times 8$），此位置有效，无需任何额外填充。\n  - **$z$ 的偏移量是 $16$。**\n  - $z$ 占据字节 $16$ 到 $23$。\n  - 记录的当前大小现在是（$z$ 的偏移量 + $z$ 的大小） = $16 + 8 = 24$ 字节。\n\n**3. 确定最终记录大小**\n记录的总大小必须是其对齐（$8$ 字节）的倍数。这是为了确保在这类记录组成的数组中，每个记录都从正确对齐的地址开始。\n\n- 布局完所有字段后，记录的大小为 $24$ 字节。\n- 记录的对齐为 $8$ 字节。\n- 我们检查当前大小是否是记录对齐的倍数。$24$ 是 $8$ 的倍数（$24 = 3 \\times 8$）。\n- 由于大小已经是其对齐的倍数，因此不需要尾部填充。\n- **环境记录的最终打包大小为 $24$ 字节。**\n\n**结果摘要：**\n- 记录对齐：$8$ 字节。\n- $x$ 的偏移量：$0$ 字节。\n- $y$ 的偏移量：$8$ 字节。\n- $z$ 的偏移量：$16$ 字节。\n- 最终记录大小：$24$ 字节。\n\n问题要求四个整数值：$(x, y, z)$ 的偏移量和最终记录大小。这些值是 $0, 8, 16, 24$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0  8  16  24 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在了解了物理布局之后，本练习将探讨闭包转换中至关重要的语义问题，尤其是在处理可变状态时。通过仔细追踪一个包含共享、可变变量和别名（aliasing）的程序执行过程，你将揭示闭包如何随时间与其词法环境互动。这种理解对于推导许多具有头等函数特性的现代语言中的程序行为至关重要。",
            "id": "3658728",
            "problem": "考虑一个具有词法作用域、传值调用、以 $\\lambda$ 表示的第一类匿名函数、词法环境和可变绑定的语言。编译器通过为每个闭包合成一个显式的堆分配环境记录来进行闭包转换。该记录包含对捕获的可变变量的盒（box）的引用（指针）以及捕获的不可变变量的直接值。其语义如下：\n\n- 所有可变变量都表示为堆分配的盒；赋值操作 $v := e$ 会将值写入 $v$ 的盒中。\n- 闭包由一个代码指针和一个环境指针组成；环境存储捕获的自由变量。如果捕获的变量是可变的，环境持有指向其盒的指针。如果它是不可变的，环境直接持有其值。\n- 别名（Aliasing）意味着两个名称引用同一个可变的盒。别名在外部作用域中通过将第二个名称绑定到现有变量盒的指针来创建；因此，改变任何一个名称都会改变同一个底层的盒。\n\n给定外部作用域中的以下程序片段：\n- 初始化 $x := 1$ 和 $y := 0$ 作为可变绑定（每个都绑定到自己的盒）。\n- 创建 $x$ 的别名 $u$，通过将 $u$ 绑定到与 $x$ 相同的盒（即，$u$ 和 $x$ 共享同一个可变单元）。\n- 定义一个嵌套的函数生成器\n  $$\\text{make} \\equiv \\lambda a.\\; \\lambda b.\\; \\big( x := x + a + b;\\; y := y + x \\big).$$\n  内部的 $\\lambda$ 闭包了 $x$、 $y$ 和 $a$。\n- 执行以下序列：\n  1. 绑定 $h := \\text{make}(2)$。\n  2. 调用 $h(3)$。\n  3. 执行外部作用域的修改 $u := u + 4$。\n  4. 调用 $h(1)$。\n  5. 绑定 $k := \\text{make}(1)$。\n  6. 调用 $k(2)$。\n\n任务：\n- 仅使用词法作用域、自由变量与绑定变量的基本定义，以及上面给出的闭包转换规则，推导出编译器为 $\\text{make}$ 返回的闭包所合成的环境结构，明确指出哪些字段是指向盒的指针，哪些是立即值。解释外部作用域中通过 $u$ 对 $x$ 的别名如何在运行时与这些环境相互作用。\n- 计算整个序列完成后存储在 $x$ 的盒中的最终值。将此最终值作为你的唯一数值答案。无需四舍五入；报告精确的整数。",
            "solution": "该问题在编译器设计和编程语言语义学的原则范围内是适定（well-posed）且具有科学依据的。它提供了一套清晰、自洽的关于作用域、可变性和闭包转换的规则，以及一个确定性的操作序列。因此，该问题被认为是有效的，并且可以构建一个解决方案。\n\n根据要求，解答分为两部分：首先，分析闭包环境结构；其次，逐步跟踪程序执行以确定变量 $x$ 的最终值。\n\n**第一部分：闭包环境结构**\n\n问题定义了一个函数生成器 $\\text{make}$：\n$$ \\text{make} \\equiv \\lambda a.\\; \\lambda b.\\; \\big( x := x + a + b;\\; y := y + x \\big) $$\n`make` 函数接受一个参数 $a$ 并返回一个匿名的内部函数。我们将此内部函数表示为 $f_{\\text{inner}} = \\lambda b.\\; \\big( \\dots \\big)$。为了确定 $f_{\\text{inner}}$ 的闭包结构，我们必须根据词法作用域的规则识别其自由变量。\n\n$f_{\\text{inner}}$ 的函数体使用了变量 $x$、 $y$、 $a$ 和 $b$。\n- 变量 $b$ 是 $f_{\\text{inner}}$ 的一个参数，因此它是 $f_{\\text{inner}}$ 内的一个绑定变量。它不属于闭包捕获的环境；其值在调用时提供。\n- 变量 $x$、 $y$ 和 $a$ 在 $f_{\\text{inner}}$ 内部没有被绑定（即，它们不是其参数或局部定义的变量）。因此，它们是自由变量。\n\n在词法作用域下，这些自由变量从定义 $f_{\\text{inner}}$ 的环境中捕获。该定义发生在 `make` 函数的函数体内。\n- $a$ 是 `make` 的一个参数。根据标准函数式语言的约定，函数参数是不可变绑定。\n- $x$ 和 $y$ 在 `make` 之外的外部作用域中定义。问题陈述指明它们是可变变量。\n\n问题为闭包转换提供了明确的规则：\n1.  捕获的可变变量在环境中作为指向其堆分配盒的指针存储。\n2.  捕获的不可变变量在环境中作为直接值存储。\n\n将这些规则应用于 $f_{\\text{inner}}$ 的自由变量：\n- $x$ 是可变的，所以闭包的环境将包含一个指向 $x$ 的堆分配盒的指针。\n- $y$ 是可变的，所以环境将包含一个指向 $y$ 的堆分配盒的指针。\n- $a$ 是 `make` 的不可变参数，所以环境将包含创建闭包时传递给 `make` 的 $a$ 的值。\n\n因此，编译器为 `make` 返回的每个闭包合成一个具有以下结构的环境记录：\n- 一个用于 $x$ 的字段，包含一个指向变量 $x$ 的共享的、堆分配的盒的指针。\n- 一个用于 $y$ 的字段，包含一个指向变量 $y$ 的共享的、堆分配的盒的指针。\n- 一个用于 $a$ 的字段，包含传递给 `make` 的立即整数值。\n\n在外部作用域中，$x$ 被 $u$ 别名化意味着名称 $x$ 和 $u$ 都绑定到引用完全相同的堆分配盒的指针。由 `make` 创建的任何闭包都将捕获指向这同一个盒的指针。因此，闭包内对 $x$ 的任何赋值，或外部作用域中对 $x$ 的任何赋值，或外部作用域中对别名 $u$ 的任何赋值，都将修改这一个共享盒的内容。所有三个访问路径（$x$、$u$ 以及任何闭包中捕获的引用）都别名化到同一个可变内存位置。\n\n**第二部分：执行跟踪**\n\n我们跟踪存储在 $x$ 和 $y$ 的堆分配盒中的值。让我们将 $x$ 的盒中的值表示为 $\\text{val}(x)$，将 $y$ 的盒中的值表示为 $\\text{val}(y)$。\n\n**初始状态：**\n- 为 $x$ 创建一个盒并初始化：$\\text{val}(x) = 1$。\n- 为 $y$ 创建一个盒并初始化：$\\text{val}(y) = 0$。\n- 名称 $u$ 被设置为 $x$ 的别名，指向同一个盒。\n\n**1. `h := make(2)`**\n- `make` 函数以 $a = 2$ 被调用。\n- 它返回一个新的闭包，我们命名为 $h$。\n- $h$ 的环境（我们称之为 $E_h$）被创建。\n  - $E_h$ 捕获一个指向 $x$ 的盒的指针。\n  - $E_h$ 捕获一个指向 $y$ 的盒的指针。\n  - $E_h$ 捕获 $a$ 的值，即 $2$。\n- 盒的状态未改变：$\\text{val}(x) = 1$，$\\text{val}(y) = 0$。\n\n**2. `h(3)`**\n- 闭包 $h$ 以 $b = 3$ 被调用。\n- 使用环境 $E_h$ 执行函数体 `x := x + a + b; y := y + x`。\n- 第一个语句：`x := x + a + b`。\n  - 读取 $\\text{val}(x) = 1$。\n  - 从 $E_h$ 读取 $a$，其值为 $2$。\n  - 参数 $b$ 是 $3$。\n  - $x$ 的新值是 $1 + 2 + 3 = 6$。这个值被写入 $x$ 的盒中。\n  - 状态变为：$\\text{val}(x) = 6$，$\\text{val}(y) = 0$。\n- 第二个语句：`y := y + x`。\n  - 读取 $\\text{val}(y) = 0$。\n  - 读取 $\\text{val}(x)$ 的*新*值，即 $6$。\n  - $y$ 的新值是 $0 + 6 = 6$。这个值被写入 $y$ 的盒中。\n  - 状态变为：$\\text{val}(x) = 6$，$\\text{val}(y) = 6$。\n\n**3. `u := u + 4`**\n- 这个赋值发生在外部作用域。\n- 因为 $u$ 是 $x$ 的别名，它引用同一个盒。\n- 读取 $\\text{val}(u)$，即 $\\text{val}(x) = 6$。\n- 新值是 $6 + 4 = 10$。这个值被写入 $x$ 的盒中（通过别名 $u$）。\n- 状态变为：$\\text{val}(x) = 10$，$\\text{val}(y) = 6$。\n\n**4. `h(1)`**\n- 同一个闭包 $h$ 再次被调用，这次的参数是 $b = 1$。\n- 它使用相同的环境 $E_h$，其中捕获的 $a$ 的值仍然是 $2$。\n- 第一个语句：`x := x + a + b`。\n  - 读取 $\\text{val}(x) = 10$。\n  - 从 $E_h$ 读取 $a$，其值为 $2$。\n  - 参数 $b$ 是 $1$。\n  - $x$ 的新值是 $10 + 2 + 1 = 13$。\n  - 状态变为：$\\text{val}(x) = 13$，$\\text{val}(y) = 6$。\n- 第二个语句：`y := y + x`。\n  - 读取 $\\text{val}(y) = 6$。\n  - 读取 $\\text{val}(x)$ 的新值，即 $13$。\n  - $y$ 的新值是 $6 + 13 = 19$。\n  - 状态变为：$\\text{val}(x) = 13$，$\\text{val}(y) = 19$。\n\n**5. `k := make(1)`**\n- `make` 函数以 $a = 1$ 被调用。\n- 它返回一个*新*的闭包，我们命名为 $k$。\n- 为 $k$ 创建了一个新的环境 $E_k$。\n  - $E_k$ 捕获一个指向*同一个* $x$ 的盒的指针。\n  - $E_k$ 捕获一个指向*同一个* $y$ 的盒的指针。\n  - $E_k$ 捕获 $a$ 的值，即 $1$。\n- 盒的状态未改变：$\\text{val}(x) = 13$，$\\text{val}(y) = 19$。\n\n**6. `k(2)`**\n- 闭包 $k$ 以 $b = 2$ 被调用。\n- 它使用环境 $E_k$ 执行。\n- 第一个语句：`x := x + a + b`。\n  - 读取 $\\text{val}(x) = 13$。\n  - 从 $E_k$ 读取 $a$，其值为 $1$。\n  - 参数 $b$ 是 $2$。\n  - $x$ 的新值是 $13 + 1 + 2 = 16$。\n  - 状态变为：$\\text{val}(x) = 16$，$\\text{val}(y) = 19$。\n- 第二个语句：`y := y + x`。\n  - 读取 $\\text{val}(y) = 19$。\n  - 读取 $\\text{val}(x)$ 的新值，即 $16$。\n  - $y$ 的新值是 $19 + 16 = 35$。\n  - 状态变为：$\\text{val}(x) = 16$，$\\text{val}(y) = 35$。\n\n执行序列完成。存储在 $x$ 的盒中的最终值是 $16$。",
            "answer": "$$ \\boxed{16} $$"
        },
        {
            "introduction": "本练习聚焦于一个经典且富有启发性的场景：在循环内部创建闭包。它突出了按值捕获（capture-by-value）与按引用捕获（capture-by-reference）循环变量之间的深刻差异，这也是程序员常见的错误来源。通过推导两种捕获策略的最终结果，你将巩固对变量值被捕获的“时间点”的理解，以及这个时间点如何影响最终生成的闭包的行为。",
            "id": "3653501",
            "problem": "考虑以下高级程序片段，它在一个循环内部构建一个闭包数组，并在循环终止后调用这些闭包。设 $N$ 是一个正整数。\n\n程序描述：\n- 初始化一个空数组 $A$。\n- 对于从 $1$ 到 $N$ 的每个整数 $i$：\n  - 令 $m = 2 i$。\n  - 将闭包 $g(x) = 3 x + i + m$ 附加到 $A$ 中。\n- 循环终止后，对于从 $1$ 到 $N$ 的每个 $k$，使用参数 $x = k$ 调用 $A$ 中的第 $k$ 个闭包。\n\n假设使用词法作用域和标准闭包转换，并采纳以下核心定义：\n- 在按值捕获变量 $v$ 的情况下，闭包在创建时存储 $v$ 当前值的副本。\n- 在按引用捕获变量 $v$ 的情况下，闭包存储一个指向持有 $v$ 值的内存位置（一个环境单元）的指针，因此未来对 $v$ 的更改对所有引用该位置的闭包都可见。\n\n假设当按引用捕获时，循环归纳变量按常规转换为一个环境单元，因此在循环中创建的所有按引用捕获 $i$ 的闭包共享一个为 $i$ 分配的堆单元。循环在每次迭代中递增此单元；循环终止后，该单元持有值 $N+1$。变量 $m$ 是一个每次迭代新生成的局部变量，并按值捕获。\n\n定义 $S_{\\text{val}}$ 为当 $i$ 按值捕获时，所有调用返回值的总和；定义 $S_{\\text{ref}}$ 为当 $i$ 按引用捕获时（如上所述，所有闭包共享一个 $i$ 的单元），所有调用返回值的总和。令\n$$\nD \\equiv S_{\\text{val}} - S_{\\text{ref}}.\n$$\n\n仅使用上述定义以及词法作用域和闭包转换的语义，推导出一个关于 $N$ 的 $D$ 的闭式表达式。请给出最终答案，形式为关于 $N$ 的单个闭式解析表达式。无需四舍五入，也不涉及单位。",
            "solution": "用户希望我解决这个问题。\n\n### 步骤1：提取已知条件\n- 一个正整数 $N$。\n- 一个数组 $A$，初始为空。\n- 一个循环：`for i from 1 to N`。\n- 循环内部：\n    - 定义局部变量 $m$ 为 $m=2i$。\n    - 将闭包 $g(x) = 3x + i + m$ 附加到 $A$ 中。\n- 循环之后：对于从 $1$ 到 $N$ 的每个整数 $k$，使用参数 $x=k$ 调用 $A$ 中的第 $k$ 个闭包。\n- 按值捕获变量 $v$ 的定义：闭包在创建时存储 $v$ 当前值的副本。\n- 按引用捕获变量 $v$ 的定义：闭包存储一个指向 $v$ 所在位置的指针。\n- 按引用捕获循环变量 $i$ 的语义规则：所有闭包共享一个为 $i$ 分配的堆单元。循环终止后，该单元持有值 $N+1$。\n- 局部变量 $m$ 的语义规则：它是一个每次迭代新生成的局部变量，并按值捕获。\n- 当 $i$ 按值捕获时，$S_{\\text{val}}$ 是结果的总和。\n- 当 $i$ 按引用捕获时，$S_{\\text{ref}}$ 是结果的总和。\n- $D \\equiv S_{\\text{val}} - S_{\\text{ref}}$.\n- 目标是找到 $D$ 关于 $N$ 的闭式表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于编译器设计和编程语言语义学的原理。词法作用域、闭包和捕获机制（按值、按引用）等概念是计算机科学中的基本且明确定义的概念。\n- **适定性**：该问题是适定的。它提供了所有必要的定义和约束，以确定 $D$ 作为 $N$ 的函数的唯一解析解。\n- **客观性**：该问题使用形式计算机科学中常见的精确、客观的语言进行陈述。\n- 该问题不违反任何无效性标准。所提供的循环变量按引用捕获的语义虽然具体，但模拟了一种真实世界的行为（例如，ES6 的 `let` 出现之前，JavaScript 循环中的 `var`），并且描述清晰无歧义。\n\n### 步骤3：结论与行动\n该问题有效且可以解决。\n\n### 解题推导\n\n目标是计算 $D = S_{\\text{val}} - S_{\\text{ref}}$。我们将首先分别推导 $S_{\\text{val}}$ 和 $S_{\\text{ref}}$ 的表达式。\n\n程序创建了 $N$ 个闭包，每个闭包对应于从 $i=1$ 到 $N$ 的一次循环迭代。我们将第 $i$ 次迭代期间创建的闭包表示为 $c_i$。该闭包定义的函数是 $g(x) = 3x+i+m$，其中 $m=2i$。两种情况之间的关键区别在于变量 $i$ 是如何被捕获的。变量 $m$ 总是按值捕获。\n\n在循环的第 $i$ 次迭代中（此时循环计数器为 $i$），变量 $m$ 被赋值为 $2i$。由于 $m$ 是一个按值捕获的、每次迭代新生成的局部变量，闭包 $c_i$ 将永久存储 $m$ 的值 $2i$。因此，$c_i$ 中函数的定义实际上是 $g(x) = 3x + i_{\\text{captured}} + 2i$。\n\n循环结束后，数组 $A$ 中的第 $k$ 个闭包（即 $c_k$）被以参数 $x=k$ 调用。\n\n**1. 计算 $S_{\\text{val}}$ （按值捕获 `i`）**\n\n在这种情况下，循环变量 $i$ 是按值捕获的。当闭包 $c_k$ 在第 $k$ 次迭代中创建时，它存储了 $i$ 当前值的副本，即 $k$。\n因此，对于第 $k$ 个闭包 $c_k$，$i_{\\text{captured}}$ 的值为 $k$。\n$c_k$ 实现的函数是：\n$$g_k(x) = 3x + k + 2k = 3x + 3k$$\n然后用参数 $x=k$ 调用该闭包。返回值为：\n$$g_k(k) = 3k + 3k = 6k$$\n$S_{\\text{val}}$ 是这些返回值从 $k=1$ 到 $N$ 的总和：\n$$S_{\\text{val}} = \\sum_{k=1}^{N} g_k(k) = \\sum_{k=1}^{N} 6k$$\n使用前 $N$ 个整数的和的公式 $\\sum_{k=1}^{N} k = \\frac{N(N+1)}{2}$：\n$$S_{\\text{val}} = 6 \\sum_{k=1}^{N} k = 6 \\left( \\frac{N(N+1)}{2} \\right) = 3N(N+1)$$\n\n**2. 计算 $S_{\\text{ref}}$ （按引用捕获 `i`）**\n\n在这种情况下，循环变量 $i$ 按引用捕获。所有闭包 $c_1, c_2, \\dots, c_N$ 共享对 $i$ 的单一内存位置的引用。问题陈述，循环会递增此位置的值，循环终止后，此位置的值为 $N+1$。\n闭包在循环*结束之后*被调用。因此，在调用时，对共享的 $i$ 的引用进行解引用将为每个闭包都得到值 $N+1$。\n\n当闭包 $c_k$ 在第 $k$ 次迭代中创建时，它捕获了对 $i$ 的引用，并捕获了当时 $m$ 的值，即 $2k$。\n$c_k$ 实现的函数是：\n$$g_k(x) = 3x + i_{\\text{ref}} + 2k$$\n其中 $i_{\\text{ref}}$ 代表在调用时通过解引用共享的 $i$ 指针获得的值。\n这个闭包 $c_k$ 在循环*之后*以参数 $x=k$ 被调用。此时，$i_{\\text{ref}} = N+1$。返回值为：\n$$g_k(k) = 3k + (N+1) + 2k = 5k + N + 1$$\n$S_{\\text{ref}}$ 是这些值从 $k=1$ 到 $N$ 的总和：\n$$S_{\\text{ref}} = \\sum_{k=1}^{N} (5k + N + 1)$$\n我们可以拆分求和：\n$$S_{\\text{ref}} = \\sum_{k=1}^{N} 5k + \\sum_{k=1}^{N} (N+1)$$\n$$S_{\\text{ref}} = 5 \\left( \\sum_{k=1}^{N} k \\right) + N(N+1)$$\n再次使用求和公式：\n$$S_{\\text{ref}} = 5 \\left( \\frac{N(N+1)}{2} \\right) + N(N+1)$$\n提出公因式 $N(N+1)$：\n$$S_{\\text{ref}} = N(N+1) \\left( \\frac{5}{2} + 1 \\right) = N(N+1) \\left( \\frac{7}{2} \\right) = \\frac{7}{2}N(N+1)$$\n\n**3. 计算 $D$**\n\n现在我们可以计算 $D = S_{\\text{val}} - S_{\\text{ref}}$：\n$$D = 3N(N+1) - \\frac{7}{2}N(N+1)$$\n提出公因式 $N(N+1)$：\n$$D = N(N+1) \\left( 3 - \\frac{7}{2} \\right) = N(N+1) \\left( \\frac{6}{2} - \\frac{7}{2} \\right)$$\n$$D = N(N+1) \\left( -\\frac{1}{2} \\right) = -\\frac{N(N+1)}{2}$$\n这是 $D$ 作为 $N$ 的函数的最终闭式表达式。",
            "answer": "$$\n\\boxed{-\\frac{N(N+1)}{2}}\n$$"
        }
    ]
}