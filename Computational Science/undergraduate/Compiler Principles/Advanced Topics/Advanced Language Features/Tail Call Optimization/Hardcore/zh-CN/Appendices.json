{
    "hands_on_practices": [
        {
            "introduction": "要掌握尾调用优化，首要的技能便是精确识别出“尾部位置”的函数调用。这并非一个模糊的概念，而是一个可以根据语言结构严格定义的属性。本练习  将带你深入代码的细节，通过在一个包含嵌套条件、let绑定和复杂表达式的函数中应用一系列明确的语义规则，来锻炼你识别真正尾调用的能力。",
            "id": "3673993",
            "problem": "考虑一种严格的、采用传值调用、函数参数和二元运算符从左到右求值的语言。该语言具有以下构造和经过充分验证的语义事实，这些是推理尾位置（tail position）和尾调用优化（Tail Call Optimization, TCO）的基础：\n- 在该语言中，如果一个表达式在求值时，当前函数在当前激活帧中不执行任何进一步的计算，并立即返回该表达式的值，则称该表达式处于尾位置。\n- 条件表达式 $\\mathrm{if}\\ \\phi\\ \\mathrm{then}\\ e_1\\ \\mathrm{else}\\ e_2$ 的值是 $e_1$ 或 $e_2$ 的值。如果整个条件表达式处于尾位置，那么其被选择的分支也处于尾位置，但条件 $\\phi$ 不处于尾位置。\n- let-绑定 $\\mathrm{let}\\ v = e_1\\ \\mathrm{in}\\ e_2$ 的值是 $e_2$ 的值。如果整个 let-绑定处于尾位置，那么 $e_2$ 处于尾位置，而 $e_1$ 不处于（因为对 $e_1$ 的求值之后必须接着对 $e_2$ 进行求值）。\n- 对于一个二元运算符表达式 $e_1 \\oplus e_2$（例如用 $+$ 进行的加法或用 $\\land$ 进行的短路合取），如果整个运算符表达式处于尾位置，则操作数 $e_1$ 和 $e_2$ 都不处于尾位置，因为在求值一个操作数后，运行时仍然需要执行运算符组合或可能需要求值另一个操作数。\n- 对于一个序列 $e_1;\\ e_2$（其值为 $e_2$ 的值），如果整个序列处于尾位置，那么 $e_2$ 处于尾位置，而 $e_1$ 不处于。\n- 在传值调用和从左到右参数求值的规则下，对于函数调用 $f(e_1,\\ldots,e_n)$，参数 $e_i$ 不处于尾位置（因为调用尚未发生），而如果其值被直接返回，则调用本身可能处于尾位置。\n\n考虑函数 $F(x,y)$，其中标记的调用点 $c_i$ 已被明确指出：\n\n$F(x,y) =$\n$\\quad \\mathrm{if}\\ x > 0\\ \\mathrm{then}$\n$\\quad\\quad c_1(\\mathrm{abs}(x))$\n$\\quad \\mathrm{else}$\n$\\quad\\quad \\mathrm{let}\\ t = c_2(x)\\ \\mathrm{in}$\n$\\quad\\quad\\quad \\mathrm{if}\\ t == 0\\ \\mathrm{then}$\n$\\quad\\quad\\quad\\quad c_3(y)\\ \\land\\ c_4(x)$\n$\\quad\\quad\\quad \\mathrm{else}$\n$\\quad\\quad\\quad\\quad \\mathrm{let}\\ u = c_9(t)\\ \\mathrm{in}$\n$\\quad\\quad\\quad\\quad\\quad \\mathrm{if}\\ y > t\\ \\mathrm{then}$\n$\\quad\\quad\\quad\\quad\\quad\\quad 10 + c_5(t - y)$\n$\\quad\\quad\\quad\\quad\\quad \\mathrm{else}$\n$\\quad\\quad\\quad\\quad\\quad\\quad c_6(c_7(x),\\ c_8(y));\\ c_{10}(u)$\n\n假设 $\\land$（逻辑合取）具有通常的短路语义：$e_1 \\land e_2$ 仅当 $e_1$ 的求值为 $\\mathrm{true}$ 时才对 $e_2$ 求值；如果 $e_1$ 为 $\\mathrm{false}$，其值为 $\\mathrm{false}$，否则其值为 $e_2$ 的值。\n\n在 $F$ 中，哪些标记的调用点 $c_i$ 处于尾位置？\n\nA. $\\{c_1,\\ c_6,\\ c_{10}\\}$\n\nB. $\\{c_1,\\ c_{10}\\}$\n\nC. $\\{c_1,\\ c_3,\\ c_4,\\ c_{10}\\}$\n\nD. $\\{c_1,\\ c_5,\\ c_6,\\ c_{10}\\}$",
            "solution": "推导始于严格传值调用求值的基本定义和尾位置的定义：一个表达式处于尾位置，指的是一旦它计算出其值，当前函数将不执行任何进一步的计算并直接返回该值。这是一个结构性属性：如果一个函数的整个函数体处于尾位置，那么在一个顶层的 $\\mathrm{if}$ 表达式中，其分支处于尾位置；在一个 $\\mathrm{let}$ 表达式中，只有其主体部分处于尾位置；在一个序列中，只有第二个表达式处于尾位置；在二元运算符表达式中，两个操作数都不处于尾位置，因为运算符仍然需要组合操作数。\n\n我们对 $F(x,y)$ 进行结构性分析。\n\n1. $F(x,y)$ 的整个右侧都处于尾位置，因为它产生函数的返回值。\n\n2. 顶层条件：\n- 表达式 $\\mathrm{if}\\ x > 0\\ \\mathrm{then}\\ \\cdots\\ \\mathrm{else}\\ \\cdots$ 处于尾位置，因此无论选择哪个分支，该分支也处于尾位置。条件 $x > 0$ 不处于尾位置，但它不包含任何标记的调用。\n\n3. 第一个分支 ($x > 0$):\n- 表达式：$c_1(\\mathrm{abs}(x))$。\n- 调用 $c_1(\\cdot)$ 所在位置的值被直接返回，因此 $c_1$ 处于尾位置。\n- 参数 $\\mathrm{abs}(x)$ 不处于尾位置（也未被标记），但这不影响我们对标记的尾调用的集合。\n\n4. 第二个分支 ($x \\ge 0$):\n- 表达式：$\\mathrm{let}\\ t = c_2(x)\\ \\mathrm{in}\\ \\cdots$。\n- 整个 $\\mathrm{let}$ 表达式处于尾位置，因此其主体部分也处于尾位置；然而，$c_2(x)$ 不处于尾位置，因为在对 $c_2(x)$ 求值后，计算会继续执行其主体部分。\n\n5. 关于 $t$ 的嵌套条件：\n- 如果 $t == 0$，则表达式为 $c_3(y)\\ \\land\\ c_4(x)$。\n- 整个运算符表达式 $c_3(y)\\ \\land\\ c_4(x)$ 处于尾位置，但根据严格传值调用和短路求值的成熟语义， $c_3(y)$ 和 $c_4(x)$ 都不处于尾位置。在对 $c_3(y)$ 求值后，运行时仍需应用合取逻辑（并可能求值 $c_4(x)$），而在对 $c_4(x)$ 求值后，它仍需得出运算符的结果。因此，$c_3$ 和 $c_4$ 不是尾调用。\n\n- Else（即 $t \\ne 0$）：$\\mathrm{let}\\ u = c_9(t)\\ \\mathrm{in}\\ \\cdots$。\n- 这个 $\\mathrm{let}$ 表达式的主体部分处于尾位置，但 $c_9(t)$ 本身不处于，原因同上：其后还有主体部分的求值。\n\n6. 在 $\\mathrm{let}\\ u$ 主体内部关于 $y$ 的条件：\n- Then 分支：$10 + c_5(t - y)$。\n- 这是一个处于尾位置的二元运算符表达式，但 $c_5(\\cdot)$ 不处于尾位置，因为在 $c_5$ 返回后，还必须执行加 10 的操作。因此，$c_5$ 不是尾调用。\n\n- Else 分支：$c_6(c_7(x),\\ c_8(y));\\ c_{10}(u)$。\n- 这是一个序列，其值是第二个表达式 $c_{10}(u)$ 的值。因为整个序列处于尾位置，所以第二个表达式 $c_{10}(u)$ 处于尾位置，而第一个表达式 $c_6(\\cdot)$ 不处于（因为其后还有计算：对 $c_{10}(u)$ 的求值）。\n- 此外，在调用 $c_6(c_7(x),\\ c_8(y))$ 中，参数在传值调用下从左到右求值，参数 $c_7(x)$ 和 $c_8(y)$ 不处于尾位置，因为它们是一个调用（$c_6$）的参数，而这个调用本身不是最终返回的表达式。因此，$c_6$、$c_7$ 和 $c_8$ 都不是尾调用。\n- 在 $c_{10}(u)$ 中，该调用本身是序列中的第二个表达式，其值被直接返回；因此 $c_{10}$ 处于尾位置。\n\n汇总所有标记点中的尾调用：\n- 尾调用：$c_1$, $c_{10}$。\n- 非尾调用：$c_2$, $c_3$, $c_4$, $c_5$, $c_6$, $c_7$, $c_8$, $c_9$。\n\n逐个选项分析：\n- A. $\\{c_1,\\ c_6,\\ c_{10}\\}$：包含 $c_6$，但由于序列中其后有 $c_{10}(u)$，所以它不处于尾位置。不正确。\n- B. $\\{c_1,\\ c_{10}\\}$：与上面推导出的集合完全一致。正确。\n- C. $\\{c_1,\\ c_3,\\ c_4,\\ c_{10}\\}$：包含 $c_3$ 和 $c_4$，它们在 $\\land$ 运算符表达式内部，不处于尾位置。不正确。\n- D. $\\{c_1,\\ c_5,\\ c_6,\\ c_{10}\\}$：包含 $c_5$（因后续的加法而不处于尾位置）和 $c_6$（因其后有 $c_{10}(u)$ 而不处于尾位置）。不正确。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "识别出尾调用是第一步，但为什么要进行优化呢？尾调用优化的核心价值在于其显著的性能提升。本练习  旨在将这种性能优势从一个定性的概念转化为一个可量化的结果。通过建立一个精细的成本模型，你将能够分析并计算出在有无尾调用优化的情况下，一个递归函数的执行时间差异，从而直观地理解消除函数调用栈开销所带来的巨大加速效应。",
            "id": "3673955",
            "problem": "考虑一个尾递归函数 $f(n, a)$，在每个递归步骤中，它对累加器 $a$ 执行恰好 $k$ 次算术运算，并将 $n$ 减 1，直到 $n=0$ 时返回 $a$。在编译器性能分析中使用的标准加法成本模型下，假设每步成本（单位：纳秒 ns）如下：每次算术运算的成本 $t_{a}$，每次条件检查（测试 $n=0$）的成本 $t_{c}$，执行函数调用的成本 $t_{\\text{call}}$，执行函数返回的成本 $t_{\\text{return}}$，栈帧分配和销毁的成本 $t_{\\text{frame}}$，在尾调用优化（TCO）下将尾调用转换为跳转的成本 $t_{\\text{jmp}}$，以及在 $n=0$ 时最终返回的基本情况返回开销 $t_{b}$。尾调用优化（TCO）是一种编译器转换，它将尾部位置的调用替换为跳转，而无需分配新的栈帧。\n\n使用编译原理中的基本定义，对未应用尾调用优化时的运行时间 $T_{\\text{noTCO}}(n)$ 和应用尾调用优化时的运行时间 $T_{\\text{TCO}}(n)$ 进行建模。然后，将解析加速比 $S(n,k)$ 定义为比率 $T_{\\text{noTCO}}(n)/T_{\\text{TCO}}(n)$。\n\n最后，使用基准参数 $n=750000$, $k=3$, $t_{a}=1.2$ ns, $t_{c}=0.9$ ns, $t_{\\text{call}}=18$ ns, $t_{\\text{return}}=17$ ns, $t_{\\text{frame}}=12$ ns, $t_{\\text{jmp}}=2.5$ ns, 以及 $t_{b}=10$ ns，计算 $S(n,k)$ 的值。将最终数值答案四舍五入到四位有效数字。加速比是无量纲的；最终答案中不要包含任何单位。",
            "solution": "问题陈述具有科学依据，提法恰当，客观，并提供了一套完整且一致的已知条件。未发现任何缺陷。因此，我将开始解答。\n\n首先，我们对没有尾调用优化（TCO）的函数的运行时间 $T_{\\text{noTCO}}(n)$ 进行建模。该函数的第一个参数值从 $n$ 递减到 $0$ 被调用。这涉及 $n$ 个递归步骤和一个基本情况。\n\n对于 $n$ 个递归步骤中的每一个（即，当输入参数为 $n, n-1, \\dots, 1$ 时的函数调用），会产生以下成本：\n1.  一次条件检查，测试参数是否为 $0$：$t_c$。\n2.  $k$ 次算术运算：$k \\cdot t_a$。\n3.  一次递归函数调用：$t_{\\text{call}}$。\n4.  栈帧管理（分配与最终销毁）：$t_{\\text{frame}}$。\n5.  一次函数返回，它将更深层递归调用的结果传播回来：$t_{\\text{return}}$。\n\n一个递归步骤的成本，对应于一个发起下一次递归调用的单一栈帧的生命周期，是这些成本的总和：$t_c + k t_a + t_{\\text{call}} + t_{\\text{frame}} + t_{\\text{return}}$。由于存在 $n$ 个这样的递归步骤，它们对总运行时间的贡献为 $n(t_c + k t_a + t_{\\text{call}} + t_{\\text{frame}} + t_{\\text{return}})$。\n\n接下来，我们考虑基本情况，即当函数以参数 $0$ 被调用时。这次最终调用产生的成本如下：\n1.  一次条件检查，其结果为真：$t_c$。\n2.  本次最终调用的栈帧管理：$t_{\\text{frame}}$。\n3.  从基本情况的最终返回，及其特定的开销：$t_b$。\n\n基本情况的总成本是 $t_c + t_{\\text{frame}} + t_b$。\n\n因此，没有 TCO 的总运行时间 $T_{\\text{noTCO}}(n)$ 是 $n$ 个递归步骤的成本与一个基本情况的成本之和：\n$$T_{\\text{noTCO}}(n) = n(k t_a + t_c + t_{\\text{call}} + t_{\\text{return}} + t_{\\text{frame}}) + (t_c + t_{\\text{frame}} + t_b)$$\n\n接下来，我们对应用了 TCO 的运行时间 $T_{\\text{TCO}}(n)$ 进行建模。TCO 将尾递归转换为一个循环。在初始调用时只分配一个栈帧，并为所有后续的“递归”步骤（现在是跳转）重用。\n\n1.  为整个计算过程管理一个单一的栈帧：$t_{\\text{frame}}$。\n2.  递归被转换为一个运行 $n$ 次的循环。在每次迭代中，会产生以下成本：\n    a. 一次条件检查：$t_c$。\n    b. $k$ 次算术运算：$k \\cdot t_a$。\n    c. 一次跳转到循环/函数的开头：$t_{\\text{jmp}}$。\n这 $n$ 次迭代的总成本为 $n(t_c + k t_a + t_{\\text{jmp}})$。\n3.  循环结束后，执行最后一次条件检查以退出：$t_c$。\n4.  函数向其原始调用者执行一次返回，这对应于基本情况的返回：$t_b$。\n\n将这些成本相加，带有 TCO 的总运行时间为：\n$$T_{\\text{TCO}}(n) = t_{\\text{frame}} + n(t_c + k t_a + t_{\\text{jmp}}) + t_c + t_b$$\n通过重新整理，我们可以将其表示为与 $T_{\\text{noTCO}}(n)$ 类似的形式：\n$$T_{\\text{TCO}}(n) = n(k t_a + t_c + t_{\\text{jmp}}) + (t_c + t_{\\text{frame}} + t_b)$$\n加速比 $S(n, k)$ 是两个运行时间的比率：\n$$S(n, k) = \\frac{T_{\\text{noTCO}}(n)}{T_{\\text{TCO}}(n)} = \\frac{n(k t_a + t_c + t_{\\text{call}} + t_{\\text{return}} + t_{\\text{frame}}) + (t_c + t_{\\text{frame}} + t_b)}{n(k t_a + t_c + t_{\\text{jmp}}) + (t_c + t_{\\text{frame}} + t_b)}$$\n现在，我们代入给定的基准参数：$n=750000$, $k=3$, $t_a=1.2$, $t_c=0.9$, $t_{\\text{call}}=18$, $t_{\\text{return}}=17$, $t_{\\text{frame}}=12$, $t_{\\text{jmp}}=2.5$, 以及 $t_b=10$。所有时间单位均为纳秒（ns），但在计算比率时会被抵消。\n\n首先，计算分子中 $n$ 的系数：\n$$k t_a + t_c + t_{\\text{call}} + t_{\\text{return}} + t_{\\text{frame}} = (3)(1.2) + 0.9 + 18 + 17 + 12 = 3.6 + 0.9 + 18 + 17 + 12 = 51.5$$\n接下来，计算分母中 $n$ 的系数：\n$$k t_a + t_c + t_{\\text{jmp}} = (3)(1.2) + 0.9 + 2.5 = 3.6 + 0.9 + 2.5 = 7.0$$\n计算分子和分母共有的常数项：\n$$t_c + t_{\\text{frame}} + t_b = 0.9 + 12 + 10 = 22.9$$\n现在，将这些值代入 $n=750000$ 的加速比公式中：\n$$S(750000, 3) = \\frac{750000(51.5) + 22.9}{750000(7.0) + 22.9}$$\n$$S(750000, 3) = \\frac{38625000 + 22.9}{5250000 + 22.9} = \\frac{38625022.9}{5250022.9}$$\n执行除法运算：\n$$S(750000, 3) \\approx 7.35710036$$\n将结果四舍五入到四位有效数字，得到 $7.357$。",
            "answer": "$$\n\\boxed{7.357}\n$$"
        },
        {
            "introduction": "在真实的编译器中，各种优化并非独立存在，它们相互影响，其应用顺序至关重要。本练习  探讨了尾调用优化（TCO）与另一个核心编译阶段——寄存器分配（RA）之间的深刻相互作用。通过分析活跃变量和干涉图，你将发现为什么在寄存器分配之前执行TCO，能够减少寄存器溢出（spill）的次数，从而生成更高质量的机器码，这揭示了编译器设计中关于“阶段排序”（phase ordering）的一个关键原则。",
            "id": "3673956",
            "problem": "考虑一个程序，其中函数 $f$ 对函数 $g$ 进行尾调用。编译器流水线可以在寄存器分配（RA）之前或之后执行尾调用优化（TCO）。假设机器有 $R$ 个物理寄存器，并且调用约定指定了一个常规的调用指令，该指令会创建一个返回地址，并要求一组调用者保存的寄存器在调用过程中被视为已破坏。在 TCO 中，尾调用被实现为一个跳转，它不创建返回地址，也不对调用者的活跃范围施加调用破坏约束，因为调用者不会恢复执行。\n\n使用以下编译器理论中的基本事实作为你的出发点：\n- 在任何程序点 $p$，同时活跃的临时变量集合 $L(p)$ 会在冲突图 $G$ 中导出一个大小至少为 $\\lvert L(p)\\rvert$ 的团。因此，色数 $\\chi(G)$ 满足 $\\chi(G)\\geq \\omega(G)$，其中 $\\omega(G)$ 是 $G$ 的最大团大小。\n- 如果 $\\chi(G)\\leq R$，则使用 $R$ 种颜色通过图着色进行寄存器分配可以成功且无需溢出。如果 $\\chi(G)>R$，则必须将一些临时变量溢出到内存；用 $s$ 表示溢出决策的数量。\n- 尾调用转换会移除调用者的续延，因此在非尾调用版本中仅在调用后使用的任何临时变量，在 TCO 之后在调用点不再活跃，并且返回地址节点（及其冲突）也不存在，因为控制流不会返回。\n\n考虑 $f$ 中的一个特定尾调用点 $p$，在任何优化之前，传递给 $g$ 的参数是 $x_1,x_2,x_3$，有一个临时变量 $t$ 在从 $g$ 返回后专门由 $f$ 使用，并且该调用创建了一个返回地址 $r$。假设 $R=4$，并且在非 TCO 版本中，点 $p$ 处的同时活跃集是 $L_{\\text{noTCO}}(p)=\\{x_1,x_2,x_3,t,r\\}$，因此 $\\lvert L_{\\text{noTCO}}(p)\\rvert=5$。在 TCO 下，该调用变成一个跳转；$f$ 中的续延被消除，并且不创建返回地址，从而得到 $L_{\\text{TCO}}(p)=\\{x_1,x_2,x_3,a\\}$，其中如果需要，$a$ 是一个用于移动参数的临时变量，因此 $\\lvert L_{\\text{TCO}}(p)\\rvert=4$。假设如果 TCO 安排在 RA 之后，则流水线不会重新运行 RA。\n\n在当前场景下，哪个陈述最好地利用冲突图解释了为什么在 RA 之前执行 TCO 比在 RA 之后执行 TCO 产生的溢出 $s$ 更少？\n\nA. 在点 $p$，没有 TCO 的情况下，冲突图 $G_{\\text{noTCO}}$ 包含一个大小为 $\\omega(G_{\\text{noTCO}})\\geq 5$ 的团，因此在 $R=4$ 的情况下 RA 必须溢出（$\\chi(G_{\\text{noTCO}})>4\\Rightarrow s\\geq 1$）。有 TCO 的情况下，$G_{\\text{TCO}}$ 的 $\\omega(G_{\\text{TCO}})\\leq 4$，使其可 $4$-着色，并允许 RA 避免溢出（$s=0$）。如果 TCO 安排在 RA 之后且 RA 不重新运行，则先前选择的溢出仍然存在，因此 $s_{\\text{before}}\\leq s_{\\text{after}}$，在这种情况下严格减少。\n\nB. RA 独立于控制流和活跃性，因此 TCO 不会改变冲突图；因此无论遍（pass）的顺序如何，$s$ 都是相同的。\n\nC. 在 RA 之前执行 TCO 会在调用点合并调用者和被调用者的活跃范围，增加了冲突和最大团的大小，因此 $s$ 增加。\n\nD. 溢出计数 $s$ 仅由函数参数的数量决定；TCO 不影响参数，因此无论遍（pass）的顺序如何，都不能影响 $s$。",
            "solution": "问题陈述在编译器优化领域提出了一个有效且定义明确的问题，特别是关于尾调用优化（TCO）和寄存器分配（RA）的阶段顺序。给定的条件在科学上是合理的、内部一致的，并且足以推导出一个逻辑结论。\n\n问题的核心在于理解 TCO 如何影响变量的活跃性，而变量的活跃性又会改变用于寄存器分配的冲突图的结构。在 RA 期间所需的溢出数量 $s$ 是冲突图 $G$ 的色数 $\\chi(G)$ 和可用物理寄存器数量 $R$ 的直接函数。如果 $\\chi(G) > R$，则溢出是必要的。色数的下界是图中最大团的大小 $\\omega(G)$，而最大团的大小本身的下界是任何同时活跃变量集合的大小。\n\n让我们根据所提供的信息分析 TCO 和 RA 这两个遍（pass）的两种可能顺序。\n\n**场景1：在 RA *之前* 执行 TCO。**\n\n1. TCO 遍将函数 $f$ 中的尾调用转换为到函数 $g$ 的跳转。此转换消除了 $f$ 中的续延。\n2. 因此，仅在调用 $g$ 之后使用的临时变量 $t$ 在调用点 $p$ 不再活跃。返回地址 $r$ 也不被创建。\n3. 然后对这个优化后的代码进行活跃性分析。如题所给，在点 $p$ 处同时活跃的临时变量集合是 $L_{\\text{TCO}}(p)=\\{x_1, x_2, x_3, a\\}$。\n4. 这个集合的大小是 $\\lvert L_{\\text{TCO}}(p)\\rvert = 4$。根据问题的基本事实，这个集合在产生的冲突图 $G_{\\text{TCO}}$ 中导出一个大小至少为 4 的团。\n5. 因此，最大团的大小满足 $\\omega(G_{\\text{TCO}}) \\geq 4$。\n6. 寄存器分配器现在尝试使用 $R=4$ 个寄存器对 $G_{\\text{TCO}}$ 进行着色。要成功分配而不产生溢出，必须满足条件 $\\chi(G_{\\text{TCO}}) \\leq R=4$。\n7. 由于 $\\chi(G_{\\text{TCO}}) \\geq \\omega(G_{\\text{TCO}}) \\geq 4$，$\\chi(G_{\\text{TCO}})$ 有可能等于 4。如果该图是 4-可着色的（对于最大团大小为 4 的图来说，这是一个常见的结果，特别是对于通常用于建模冲突的完美图，如区间图），RA 就可以成功完成，溢出数量为 $s_1=0$。\n\n**场景2：在 TCO *之前* 执行 RA。**\n\n1. 对原始的、未优化的代码进行活跃性分析。\n2. 在调用点 $p$，同时活跃的临时变量集合是 $L_{\\text{noTCO}}(p) = \\{x_1, x_2, x_3, t, r\\}$。\n3. 这个集合的大小是 $\\lvert L_{\\text{noTCO}}(p)\\rvert = 5$。这个集合在冲突图 $G_{\\text{noTCO}}$ 中导出一个大小至少为 5 的团。\n4. 因此，最大团的大小 $\\omega(G_{\\text{noTCO}}) \\geq 5$。\n5. 寄存器分配器尝试用 $R=4$ 个寄存器对 $G_{\\text{noTCO}}$ 进行着色。色数必须满足 $\\chi(G_{\\text{noTCO}}) \\geq \\omega(G_{\\text{noTCO}}) \\geq 5$。\n6. 由于 $\\chi(G_{\\text{noTCO}}) > R=4$，该图不是 4-可着色的。不修改图的情况下，RA 是不可能的。分配器必须采取将一个或多个临时变量溢出到内存的策略。至少需要 $\\omega(G_{\\text{noTCO}}) - R = 5 - 4 = 1$ 次溢出才能打破这个 5-团。设溢出次数为 $s_2 \\geq 1$。\n7. 在 RA 完成后（包括生成溢出/重载代码），TCO 遍开始运行。然而，问题明确指出“如果 TCO 安排在 RA 之后，则流水线不会重新运行 RA”。这意味着溢出决策是最终的。生成的代码已经包含了溢出指令，并且它们不会被移除。\n\n**结论**\n\n比较这两种情况，当 TCO 在 RA 之前执行时，溢出数量为 $s_1 = 0$（在这个理想情况下），而当 RA 在 TCO 之前执行时，溢出数量为 $s_2 \\geq 1$。因此，在 RA 之前执行 TCO 会导致更少的溢出。根本原因在于，TCO 通过减少最大同时活跃变量集的大小来降低寄存器压力，这反过来又减小了冲突图的最大团大小，从而可能使其能够用可用寄存器进行着色。\n\n---\n\n**选项评估**\n\n**A. 在点 $p$，没有 TCO 的情况下，冲突图 $G_{\\text{noTCO}}$ 包含一个大小为 $\\omega(G_{\\text{noTCO}})\\geq 5$ 的团，因此在 $R=4$ 的情况下 RA 必须溢出（$\\chi(G_{\\text{noTCO}})>4\\Rightarrow s\\geq 1$）。有 TCO 的情况下，$G_{\\text{TCO}}$ 的 $\\omega(G_{\\text{TCO}})\\leq 4$，使其可 $4$-着色，并允许 RA 避免溢出（$s=0$）。如果 TCO 安排在 RA 之后且 RA 不重新运行，则先前选择的溢出仍然存在，因此 $s_{\\text{before}}\\leq s_{\\text{after}}$，在这种情况下严格减少。**\n这个陈述准确地总结了上述分析。它正确地识别了团的大小，应用图着色原理推断出在 RA 优先的情况下溢出的必要性（$\\omega \\geq 5, R=4$），并指出了在 TCO 优先的情况下避免溢出的可能性（$\\omega$ 可能为 $4$, $R=4$）。它还正确地应用了 RA 不会重新运行的约束。结论 $s_{\\text{before}}  s_{\\text{after}}$ 在此场景下是正确的。\n**结论：正确。**\n\n**B. RA 独立于控制流和活跃性，因此 TCO 不会改变冲突图；因此无论遍（pass）的顺序如何，$s$ 都是相同的。**\n这个陈述根本上是错误的。通过图着色进行的寄存器分配严重依赖于活跃性分析，而活跃性分析又依赖于控制流图。冲突图是活跃性重叠的直接表示。TCO 修改了控制流和活跃性，因此改变了冲突图。\n**结论：错误。**\n\n**C. 在 RA 之前执行 TCO 会在调用点合并调用者和被调用者的活跃范围，增加了冲突和最大团的大小，因此 $s$ 增加。**\n这个陈述的观点与事实相反。TCO 通过消除保留调用者续延（例如临时变量 $t$ 和返回地址 $r$）的需要，从而*减少*了调用点的寄存器压力。这会*减少*冲突以及冲突图中相应团的大小，而不是增加它。\n**结论：错误。**\n\n**D. 溢出计数 $s$ 仅由函数参数的数量决定；TCO 不影响参数，因此无论遍（pass）的顺序如何，都不能影响 $s$。**\n这是一个不正确的过度简化。溢出计数 $s$ 取决于程序中寄存器压力最高点所有同时活跃变量的总压力，而不仅仅是函数参数。在这种情况下，TCO 的主要影响是作用于构成调用者续延的非参数变量（$t$ 和 $r$），这直接影响了活跃性、冲突图，并因此影响了溢出的可能性。\n**结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}