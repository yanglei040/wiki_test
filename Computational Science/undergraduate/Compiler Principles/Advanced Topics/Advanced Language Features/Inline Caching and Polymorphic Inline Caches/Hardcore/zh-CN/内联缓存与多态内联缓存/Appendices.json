{
    "hands_on_practices": [
        {
            "introduction": "当一个调用点变得“巨态”（megamorphic）时，多态内联缓存（PIC）就派上了用场。然而，PIC的效率取决于其内部如何组织对不同接收者类型的检查。本练习旨在通过对比两种常见的调度策略——线性检查链和二叉决策树——来量化不同算法选择对性能的影响，帮助你理解如何应用霍夫曼编码等经典算法来优化编译器中的动态调度机制。",
            "id": "3646106",
            "problem": "在即时编译（JIT）语言中，单个动态调用点使用内联缓存（IC）来加速接收者类型上的方法分派。当该调用点变为超态（megamorphic）时，编译器会构建一个多态内联缓存（PIC）。有两种表示策略可用：\n- 一个关于接收者类标签的等式测试线性链，终止于包含目标内联存根的叶节点。\n- 一个二叉决策树，其中每个内部节点以单位成本评估接收者类标签上的一个布尔谓词，并向左或向右分支；每个叶节点恰好对应一个接收者类，并包含其内联存根。\n\n假设在此调用点有六个接收者类，其经验频率（概率）分别为 $p_{1} = 0.35$, $p_{2} = 0.25$, $p_{3} = 0.15$, $p_{4} = 0.10$, $p_{5} = 0.08$ 和 $p_{6} = 0.07$，满足 $\\sum_{i=1}^{6} p_{i} = 1$。分派的成本定义为直到到达匹配的叶节点所执行的谓词评估次数。对于任何表示，期望分派成本为 $\\sum_{i=1}^{6} p_{i} \\cdot d(i)$，其中 $d(i)$ 是类 $i$ 的深度（谓词评估次数）。\n\n任务：\n1. 构建一个最小化 $\\sum_{i=1}^{6} p_{i} \\cdot d(i)$ 的二叉决策树，并计算其最小期望成本。\n2. 构建一个最优线性链，并计算其期望成本。\n3. 设 $\\Delta$ 为最优线性链的期望成本与最优二叉决策树的期望成本之差，即 $\\Delta = \\left(\\text{最优链期望成本}\\right) - \\left(\\text{最优树期望成本}\\right)$。\n\n请以单个实数形式提供 $\\Delta$ 的值。如果进行任何近似计算，请将最终答案精确表示为小数或分数；不要使用百分号。无需四舍五入。",
            "solution": "### 解题过程\n\n该问题要求我们计算两种不同的多态内联缓存（PIC）表示的最小期望分派成本，并找出它们之间的差值。\n\n**1. 最优二叉决策树成本**\n\n构建一个最小化期望分派成本 $E_{\\text{tree}} = \\sum_{i} p_{i} \\cdot d(i)$ 的二叉决策树的任务，等同于为一组具有给定概率的符号寻找最优前缀码的问题。此问题可通过霍夫曼算法（Huffman's algorithm）解决。在此上下文中，叶节点的深度 $d(i)$ 是从根到其叶节点的路径上的内部节点数，因为每个内部节点对应一次谓词评估。\n\n给定的概率为：$p_{1} = 0.35$, $p_{2} = 0.25$, $p_{3} = 0.15$, $p_{4} = 0.10$, $p_{5} = 0.08$ 和 $p_{6} = 0.07$。\n\n我们应用霍夫曼算法：\n1.  从一个包含所有概率的列表开始，按升序排序：$\\{0.07, 0.08, 0.10, 0.15, 0.25, 0.35\\}$。\n2.  重复地将两个概率最低的节点合并成一个新的内部节点，其概率是其子节点概率之和，并将新节点插入回列表中以维持排序。\n\n- **步骤1**：合并 $0.07$ 和 $0.08$，得到新节点 $0.15$。列表变为：$\\{0.10, 0.15, 0.15, 0.25, 0.35\\}$。\n- **步骤2**：合并 $0.10$ 和 $0.15$，得到新节点 $0.25$。列表变为：$\\{0.15, 0.25, 0.25, 0.35\\}$。\n- **步骤3**：合并 $0.15$ 和 $0.25$，得到新节点 $0.40$。列表变为：$\\{0.25, 0.35, 0.40\\}$。\n- **步骤4**：合并 $0.25$ 和 $0.35$，得到新节点 $0.60$。列表变为：$\\{0.40, 0.60\\}$。\n- **步骤5**：合并 $0.40$ 和 $0.60$，得到根节点 $1.0$。\n\n通过回溯这个构造过程，我们可以确定每个原始概率（类）的深度 $d(i)$：\n- $p_{1}=0.35$ 和 $p_{2}=0.25$ 在步骤4和步骤3中较晚被合并，它们各自的深度为2。\n- $p_{3}=0.15$, $p_{4}=0.10$, $p_{5}=0.08$, $p_{6}=0.07$ 在较早的步骤中被合并，它们的深度都为3。\n\n具体来说：\n- 深度为2的类: $p_{1}(0.35), p_{2}(0.25)$\n- 深度为3的类: $p_{3}(0.15), p_{4}(0.10), p_{5}(0.08), p_{6}(0.07)$\n\n二叉树的最小期望成本为：\n$$ E_{\\text{tree}} = \\sum_{i=1}^{6} p_{i} d(i) $$\n$$ E_{\\text{tree}} = (0.35)(2) + (0.25)(2) + (0.15)(3) + (0.10)(3) + (0.08)(3) + (0.07)(3) $$\n$$ E_{\\text{tree}} = 0.70 + 0.50 + 0.45 + 0.30 + 0.24 + 0.21 $$\n$$ E_{\\text{tree}} = 2.40 $$\n\n**2. 最优线性链成本**\n\n对于等式测试的线性链，链中位置为 $k$ 的类的成本 $d(i)$ 为 $k$。为了最小化期望成本 $E_{\\text{chain}} = \\sum_{k=1}^{6} p_{i_{k}} \\cdot k$，我们必须按概率降序排列这些类。这将最高的概率与最低的成本（深度）配对。\n\n排序后的概率为：\n- 位置 $k=1$：$p_{1} = 0.35$\n- 位置 $k=2$：$p_{2} = 0.25$\n- 位置 $k=3$：$p_{3} = 0.15$\n- 位置 $k=4$：$p_{4} = 0.10$\n- 位置 $k=5$：$p_{5} = 0.08$\n- 位置 $k=6$：$p_{6} = 0.07$\n\n此最优线性链的期望成本为：\n$$ E_{\\text{chain}} = (0.35)(1) + (0.25)(2) + (0.15)(3) + (0.10)(4) + (0.08)(5) + (0.07)(6) $$\n$$ E_{\\text{chain}} = 0.35 + 0.50 + 0.45 + 0.40 + 0.40 + 0.42 $$\n$$ E_{\\text{chain}} = 2.52 $$\n\n**3. 期望成本之差**\n\n问题要求计算 $\\Delta$ 的值，即最优线性链的期望成本与最优二叉决策树的期望成本之差。\n$$ \\Delta = E_{\\text{chain}} - E_{\\text{tree}} $$\n$$ \\Delta = 2.52 - 2.40 $$\n$$ \\Delta = 0.12 $$\n\n期望成本的差值为 $0.12$。该值表示对于此特定工作负载，使用最优二叉决策树相对于最优线性链，每次分派所获得的平均性能提升。",
            "answer": "$$\\boxed{0.12}$$"
        },
        {
            "introduction": "内联缓存的快速路径只有在保证正确性的前提下才有意义。本练习探讨了正确性的一个关键方面：类型安全。通过一个对象布局（形状）不变但字段类型发生改变的假想情景，你将分析为何这种情况是危险的，以及一个“守卫”（guard）必须检查哪些信息，才能防止数据损坏或垃圾回收错误等灾难性后果。",
            "id": "3646156",
            "problem": "在一个即时 (JIT) 编译器中，一个动态对象系统使用隐藏类（也称为 shapes）来表示对象布局，并采用内联缓存 (IC) 和多态内联缓存 (PIC) 来进行属性访问特化。其基本基础由以下被广泛接受的定义和不变量组成：一个 IC 通过在执行特化于某个属性的代码之前测试接收者的该属性来守护一个特化；一个 PIC 链接多个此类守护；一个隐藏类布局标识了从字段名到内存偏移量的映射；用于加载、存储和算术运算的机器指令选择是依赖于表示的；并且垃圾回收器 (GC) 在根扫描期间必须能够区分指针值和非指针值。考虑一个具有隐藏类标识符 $L$ 的对象，其字段 $f$ 位于偏移量 $k$ 处，以及一个特化的 JIT 序列，该序列在 $L$ 上进行守护，然后将 $o[k]$ 作为未装箱的 32 位整数加载，并执行假定类型为 $T = \\text{int32}$ 的算术运算。该 PIC 链有 $n$ 个分支，每个分支仅由一个类似于 $L$ 的布局标识符守护。\n\n在时间 $t_1$，程序向 $f$ 写入一个未装箱的整数，因此加载和算术运算是有效的。在时间 $t_2$，一个后续的赋值操作将 $f$ 重新类型化为一个堆分配的双精度浮点数对象，将其字段的运行时类型更改为指针（可能具有装箱或带标签的表示），同时保持偏移量 $k$ 和隐藏类标识符 $L$ 不变。JIT 代码和 PIC 仍然保持安装状态，并且守护条件继续匹配 $L$。\n\n基于上述基本定义和不变量，并且不假设任何将字段类型与布局绑定的特定于引擎的捷径，以下哪个陈述最好地描述了当类型改变但偏移量保持不变时所需的守护信息和失败模式？\n\nA. 仅守护布局标识符 $L$ 是足够的，因为偏移量 $k$ 唯一地确定了正确的表示，并且任何运行时类型的改变都必须改变 $L$。\n\nB. 守护必须同时包括布局标识符 $L$ 和字段类型 $T$（或逻辑上等价的逐槽类型纪元），因为机器指令的选择依赖于 $T$；否则，当类型改变但 $k$ 和 $L$ 保持不变时，PIC 会以错误选择的指令静默执行，如果指针被当作非指针处理（反之亦然），将导致不正确的算术运算和潜在的 GC 不安全性。\n\nC. 在对 $f$ 进行存储操作期间的写屏障确保了 GC 的安全性和 PIC 的正确性，因此类型守护是不必要的；如果类型在 $k$ 保持不变的情况下发生变化，写屏障将会更新或使 PIC 失效。\n\nD. 当字段类型改变时，仅由布局标识符守护的 PIC 将总是会缓存未命中 (miss)，因为任何重新类型化都必然会改变隐藏类标识符 $L$，即使内存偏移量 $k$ 未改变。\n\n选择唯一的最佳选项。",
            "solution": "### 从第一性原理推导\n\n问题定义了一个具有以下关键组件和行为的系统：\n1.  **隐藏类（或 Shapes）**：由 $L$ 标识的隐藏类定义了对象的内存布局，特别是从字段名（如 $f$）到内存偏移量（如 $k$）的映射。\n2.  **特化的 JIT 代码**：为属性访问生成一个机器指令序列。此代码基于对接收者对象的假设进行特化。\n3.  **内联缓存 (IC/PIC)**：特化代码由一个检查来守护。在此问题中，该守护被指定为对隐藏类标识符的检查：对象的隐藏类是否等于 $L$？\n4.  **表示依赖性**：机器指令（例如，用于加载值或执行算术运算）的选择依赖于数据的运行时表示（例如，`integer`、`double`、`pointer`）。这被作为一个基本不变量给出。\n5.  **垃圾回收 (GC) 安全性**：GC 必须能够区分指针和非指针，以便正确追踪存活对象的图。\n\n场景展开如下：\n- 一个对象拥有隐藏类 $L$。存在一个 JIT 编译的序列用于访问其字段 $f$。该序列由一个对 $L$ 的检查来守护。\n- 特化代码假定偏移量 $k$ 处的值是一个未装箱的 $32$-位整数（$T = \\text{int32}$）。因此，它使用整数加载指令和整数算术指令。\n- 在时间 $t_1$，这个假设是正确的。字段 $f$ 包含一个整数，特化代码正确执行。\n- 在时间 $t_2$，字段 $f$ 被更新为一个新值：一个指向堆分配的双精度浮点数对象的指针。\n- 关键的是，问题陈述该更新*不会*改变对象的隐藏类标识符 $L$。\n\n现在，让我们分析在时间 $t_2$ 之后，当特化的 JIT 代码在这个被修改的对象上执行时会产生的后果：\n\n1.  **守护执行**：PIC 的守护检查对象的隐藏类。由于它仍然是 $L$，守护**通过**。程序继续执行特化的、但现在已不正确的代码。\n\n2.  **指令执行**：特化代码是在假定偏移量 $k$ 处是一个 $ \\text{int32} $ 值的情况下生成的。它将执行一个整数加载指令来从 `object + k` 读取数据。然而，该位置的比特位现在表示一个内存地址（一个指针）。假设在一个 $64$-位架构下，一个指针是一个 $64$-位的值。整数加载可能只读取该指针的前 $32$ 位。\n\n3.  **失败模式 1：数据损坏/不正确的算术运算**：用于整数算术的机器代码将对这些比特位进行操作。例如，一条 `ADD` 指令会将指针的比特位（或其一部分）当作一个整数，并执行加法运算。结果在计算上将是无意义的。这是一个会损坏程序数据状态的静默错误。\n\n4.  **失败模式 2：GC 不安全性**：这是最严重的后果。JIT 编译器维护元数据（通常称为栈映射 [stack maps] 或 OopMaps），这些元数据在特定的“安全点” (safepoints) 告知 GC 寄存器和栈上每个值的类型。特化代码的元数据将报告从 $o[k]$ 加载并保存在寄存器中的值是一个整数。GC 在扫描机器状态时，会看到指针的比特模式，但根据元数据，会将其解释为非指针值。因此，GC 将**不会**追踪这个指针。它所指向的堆分配的双精度浮点数对象将看起来是不可达的，并被错误地垃圾回收。之后程序任何通过不同有效引用来使用这块（现已释放的）内存的尝试都将导致释放后使用 (use-after-free)、内存损坏或程序崩溃。\n\n从此分析可以清楚地看出，如果 $L$ 不能完全确定其描述的所有字段的表示，那么仅在隐藏类 $L$ 上进行守护是不够的。为了确保正确性和安全性，守护必须更加精确。它不仅必须验证对象的布局（通过 $L$），还必须验证被访问字段的具体表示。\n\n### 选项评估\n\n让我们基于此推导来评估每个选项。\n\n**A. 仅守护布局标识符 $L$ 是足够的，因为偏移量 $k$ 唯一地确定了正确的表示，并且任何运行时类型的改变都必须改变 $L$。**\n- 这个陈述做出了一个断言：“任何运行时类型的改变都必须改变 $L$”。这与问题的核心前提直接矛盾，该前提明确设定了一个场景，其中字段类型发生变化但“$L$ 保持不变”。问题要求我们分析的正是该场景的后果。因此，该选项基于一个在问题上下文中错误的假设。\n- **结论**：**不正确**。\n\n**B. 守护必须同时包括布局标识符 $L$ 和字段类型 $T$（或逻辑上等价的逐槽类型纪元），因为机器指令的选择依赖于 $T$；否则，当类型改变但 $k$ 和 $L$ 保持不变时，PIC 会以错误选择的指令静默执行，如果指针被当作非指针处理（反之亦然），将导致不正确的算术运算和潜在的 GC 不安全性。**\n- 这个陈述准确地抓住了我们推导出的结论。\n- “守护必须同时包括布局标识符 $L$ 和字段类型 $T$”：正确。这是特化得以安全的必要条件。\n- “因为机器指令的选择依赖于 $T$”：正确。这是一个给定的不变量。\n- “当类型改变但 $k$ 和 $L$ 保持不变时，PIC 会以错误选择的指令静默执行”：正确。仅对 $L$ 进行守护是不够的，它会通过，从而导致执行不匹配的代码。\n- “导致不正确的算术运算和潜在的 GC 不安全性”：正确。这是我们识别出的两个主要失败模式。GC 不安全性的部分尤其关键。\n- 括号中的内容“（或逻辑上等价的逐槽类型纪元）”正确地指出了这种针对特定字段的类型守护的一个常见且复杂的实现细节，从而增强了该陈述的可信度。\n- **结论**：**正确**。\n\n**C. 在对 $f$ 进行存储操作期间的写屏障确保了 GC 的安全性和 PIC 的正确性，因此类型守护是不必要的；如果类型在 $k$ 保持不变的情况下发生变化，写屏障将会更新或使 PIC 失效。**\n- 写屏障是在存储操作期间执行的一种机制。可以设计一种写屏障，在字段类型改变时使依赖的 JIT 代码失效。这样的系统是一种*缓解策略*。然而，该选项声称这使得*类型守护变得不必要*。这是一个有缺陷的结论。*读取路径*特化要正确的根本逻辑要求是其假设得到验证。守护在执行时执行此验证。写屏障是一种作用于*写入路径*的*失效机制*。仅仅依赖失效机制可能很脆弱（例如，由于并发系统中的数据竞争），并且它并不能改变这样一个事实：即所描述的 PIC 在没有更精确的守护的情况下，逻辑上是不安全的。问题要求描述*所需的守护信息*，这是一个读取路径的属性。选项 B 直接解决了这个根本要求，而选项 C 描述了一种辅助机制，并错误地否定了对根本守护的需求。\n- **结论**：**不正确**。\n\n**D. 当字段类型改变时，仅由布局标识符守护的 PIC 将总是会缓存未命中 (miss)，因为任何重新类型化都必然会改变隐藏类标识符 $L$，即使内存偏移量 $k$ 未改变。**\n- 该选项与选项 A 有同样的缺陷。它断定“任何重新类型化都必然会改变隐藏类标识符 $L$”。这与问题陈述相矛盾，后者明确定义了一个 $L$ 不变的场景。如果该选项为真，则问题中的场景就不会发生，PIC 将只会缓存未命中 (miss)，从而避免静默的正确性和安全性失败。该问题的目的正是分析该断言为假的情况。\n- **结论**：**不正确**。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "内联缓存的核心机制是在运行时动态地“修补”机器代码。本练习将揭开这层抽象，展示在现代多核处理器上执行此操作的真实成本。通过对代码修补过程中的缓存一致性协议、内存屏障等底层事件进行建模，你将能够计算出这一操作的延迟，从而更深刻地理解自修改代码在性能上的权衡。",
            "id": "3646199",
            "problem": "一种用于动态语言的即时编译器使用内联缓存（ICs）和多态内联缓存（PICs）在运行时通过修补短代码序列来特化调用点。考虑一个多核系统，该系统有 $T$ 个相同的核心，共享一个一致性内存层次结构。该结构在共享广播互连上对指令强制执行写-无效一致性。每个核心上的指令缓存（I-cache）通过显式失效确认来保持一致性：一个核心在收到指令失效后会处理它，然后在互连上传输一个确认。互连将所有一致性消息和确认进行无重叠的串行化。\n\n对调用点的 IC 或 PIC 修补可能会跨越多个缓存行。假设一个特定的修补使 $B$ 个不同的指令缓存行失效。修补线程在单个源核心上运行，并对这 $B$ 行中的每一行遵循以下严格串行化的逐行协议，只有在当前行被所有其他核心完全确认后，才会处理下一行：\n\n- 将该行的代码补丁写入应用于源核心的数据缓存，本地成本为 $L_{w}$ 个周期。\n- 在源核心上执行本地指令缓存同步（以避免执行过时的指令），成本为 $L_{i}$ 个周期。\n- 发出一个完整的内存屏障，以保证写操作相对于后续失效操作的顺序，成本为 $L_{f}$ 个周期。\n- 在互连上广播该行的指令失效；该广播占用互连 $L_{b}$ 个周期。\n- 其他 $T-1$ 个核心中的每一个，在收到失效后，花费 $L_{s}$ 个周期来使其对应的 I-cache 行失效并清空其前端，然后发送一个确认，该确认占用互连 $L_{r}$ 个周期。来自不同核心的确认一旦开始，就在互连上背靠背地串行化，没有间隙，并且源核心必须在继续之前接收到所有 $T-1$ 个确认。\n\n假设以下源于一致性基本原理的最坏但现实的条件：广播在占用互连 $L_{b}$ 个周期后同时传递到所有核心；在 $T-1$ 个远程核心上的 $L_{s}$ 服务在这些核心之间完全重叠；互连上没有其他流量；以及不同行的逐行操作在时间上不重叠。\n\n在这些假设下，推导出一个闭式表达式，表示源核心为完成对所有 $B$ 行和所有 $T$ 个核心的修补所经历的最坏情况下的总停顿时间（以周期为单位）。您的最终答案必须是一个关于 $B$、$T$、$L_{w}$、$L_{i}$、$L_{f}$、$L_{b}$、$L_{s}$ 和 $L_{r}$ 的单一解析表达式，并应以周期表示。不要近似或取整；提供精确的表达式。",
            "solution": "### 解题过程\n任务是为源核心在执行与内联缓存（IC）或多态内联缓存（PIC）修补相关的自修改代码操作时所经历的停顿时间建立模型。我们根据问题描述的严格串行化协议，分步计算总时间。\n\n首先，分析完成一个缓存行修补所需的总时间。这个过程分为几个连续的阶段：\n\n1.  **本地操作**：修补线程在源核心上执行一系列本地操作。这些操作按顺序发生，其成本相加：\n    - 写入代码补丁：$L_{w}$\n    - 本地I-cache同步：$L_{i}$\n    - 内存屏障：$L_{f}$\n    本地操作总成本为 $L_{w} + L_{i} + L_{f}$。\n\n2.  **跨核心同步操作**：在本地操作之后，开始与系统中其他核心进行同步。\n    - **广播失效**：源核心在共享互连上广播失效消息。此操作占用互连 $L_{b}$ 个周期。\n    - **远程核心处理**：根据假设，广播在 $L_{b}$ 周期后同时到达所有 $T-1$ 个远程核心。每个核心花费 $L_{s}$ 个周期来处理失效。由于这些操作在所有远程核心上完全重叠，所以从广播到达远程核心到所有核心完成处理所需的时间是 $L_{s}$。\n    - **确认传输**：处理完失效后，每个远程核心发送一个确认。共有 $T-1$ 个确认，每个占用互连 $L_{r}$ 个周期。由于确认在互连上是串行化的，它们总共占用 $(T-1) \\cdot L_{r}$ 个周期。\n\n因此，从广播失效开始，到源核心接收到所有确认所需的总时间是这三个阶段时间的总和：$L_{b}$ (广播传输) + $L_{s}$ (最慢的远程核心处理时间) + $(T-1)L_{r}$ (所有确认的串行化传输)。\n\n单行的总停顿时间 $S_{\\text{line}}$ 是本地操作时间和跨核心同步时间的总和：\n$$ S_{\\text{line}} = (L_{w} + L_{i} + L_{f}) + (L_{b} + L_{s} + (T-1)L_{r}) $$\n\n由于问题规定，对 $B$ 个缓存行的修补是严格串行化的，即一个行的整个过程（从本地写入到接收完所有确认）必须在下一个行开始之前全部完成。因此，总停顿时间 $S_{\\text{total}}$ 就是单行停顿时间的 $B$ 倍。\n\n$$ S_{\\text{total}} = B \\cdot S_{\\text{line}} = B(L_{w} + L_{i} + L_{f} + L_{b} + L_{s} + (T-1)L_{r}) $$\n\n这个表达式是关于给定参数的闭式解，符合题目要求。",
            "answer": "$$\\boxed{B\\left(L_{w}+L_{i}+L_{f}+L_{b}+L_{s}+(T-1)L_{r}\\right)}$$"
        }
    ]
}