{
    "hands_on_practices": [
        {
            "introduction": "Devirtualization often relies on speculation: a compiler bets on the most frequent receiver type at a polymorphic call site, a decision typically informed by profiling data. This practice introduces a fundamental trade-off, where we must weigh the cost of a runtime check, or 'guard', against the performance gain of executing a faster direct function call. This first exercise  challenges you to formalize this trade-off by deriving an expected-gain model from first principles, helping you to quantitatively evaluate when this optimization is actually a performance win.",
            "id": "3637422",
            "problem": "A compiler is considering devirtualization at a polymorphic call site in an object-oriented language. In the baseline, the call is performed via a virtual dispatch whose per-invocation latency is a constant $c_{indirect}$ cycles. Under devirtualization, the compiler inserts a runtime type guard that executes on every invocation and, if the predicted hot receiver class is present, performs a direct call; otherwise, it falls back to the original indirect call. Assume a linear expected-cost model based on the law of total expectation and the following primitive facts: the direct call latency is a constant $c_{direct}$ cycles; the guard has a constant overhead $c_{guard}$ cycles paid on every invocation; the hot receiver case occurs with probability $p_{hot}$. Starting from these fundamentals, derive an expression for the expected per-invocation performance gain $g$ of devirtualization relative to the baseline.\n\nFor a specific call site, measurements yield $c_{indirect} = 17$ cycles, $c_{direct} = 4$ cycles, and $c_{guard} = 3$ cycles. A Profile-Guided Optimization (PGO) run estimates $p_{hot}$ as $p_{hot}^{est} = 0.88$, but a subsequent runtime sampling in a Just-In-Time (JIT) compiler shows the true hot-case probability is $p_{hot}^{true} = 0.786$.\n\nTasks:\n- Using the derived expression for $g$, compute the expected gain under the estimate, $g^{est}$, and under the true probability, $g^{true}$.\n- Derive the first-order sensitivity $\\frac{\\partial g}{\\partial p_{hot}}$ and use it to quantify how $g$ changes with misestimation of $p_{hot}$.\n- Report the absolute error in expected gain, $|g^{true} - g^{est}|$, in cycles. Round your reported answer to four significant figures and express it in cycles.",
            "solution": "The baseline expected per-invocation cost is $c_{indirect}$ because every call is dispatched indirectly. Under devirtualization, the runtime type guard executes on every invocation and contributes a constant $c_{guard}$ cycles. With probability $p_{hot}$, the direct call is taken at cost $c_{direct}$; with probability $1 - p_{hot}$, the indirect call is taken at cost $c_{indirect}$. By the law of total expectation and linearity of expectation, the expected cost with devirtualization is\n$$\n\\text{Cost}_{\\text{devirt}} = c_{guard} + p_{hot}\\,c_{direct} + (1 - p_{hot})\\,c_{indirect}.\n$$\nThe expected per-invocation gain $g$ is the baseline cost minus the devirtualized cost:\n$$\ng = c_{indirect} - \\left(c_{guard} + p_{hot}\\,c_{direct} + (1 - p_{hot})\\,c_{indirect}\\right).\n$$\nAlgebra simplifies this expression:\n\n$$\n\\begin{aligned}\ng &= c_{indirect} - c_{guard} - p_{hot}\\,c_{direct} - (1 - p_{hot})\\,c_{indirect} \\\\\n  &= c_{indirect} - c_{guard} - p_{hot}\\,c_{direct} - c_{indirect} + p_{hot}\\,c_{indirect} \\\\\n  &= p_{hot}\\,(c_{indirect} - c_{direct}) - c_{guard}.\n\\end{aligned}\n$$\n\nThis is the expected gain model that follows from the fundamental expected-value reasoning.\n\nNext, compute the expected gain under the estimate and the true probability. Using $c_{indirect} = 17$, $c_{direct} = 4$, and $c_{guard} = 3$, we have $c_{indirect} - c_{direct} = 17 - 4 = 13$.\n\nFor the estimate $p_{hot}^{est} = 0.88$,\n\n$$\ng^{est} = p_{hot}^{est}\\,(c_{indirect} - c_{direct}) - c_{guard} = 0.88 \\cdot 13 - 3 = 11.44 - 3 = 8.44.\n$$\n\n\nFor the true probability $p_{hot}^{true} = 0.786$,\n\n$$\ng^{true} = p_{hot}^{true}\\,(c_{indirect} - c_{direct}) - c_{guard} = 0.786 \\cdot 13 - 3 = 10.218 - 3 = 7.218.\n$$\n\n\nThe absolute error in expected gain due to misestimation is\n\n$$\n|g^{true} - g^{est}| = |7.218 - 8.44| = | -1.222| = 1.222.\n$$\n\n\nTo analyze sensitivity, differentiate $g$ with respect to $p_{hot}$:\n\n$$\n\\frac{\\partial g}{\\partial p_{hot}} = c_{indirect} - c_{direct}.\n$$\n\nThus, the first-order change in $g$ for a small change $\\Delta p_{hot}$ is approximately\n\n$$\n\\Delta g \\approx \\frac{\\partial g}{\\partial p_{hot}} \\,\\Delta p_{hot} = (c_{indirect} - c_{direct})\\,\\Delta p_{hot}.\n$$\n\nBecause $g$ is exactly linear in $p_{hot}$, this first-order approximation is exact for any $\\Delta p_{hot}$:\n\n$$\ng(p_{hot}^{true}) - g(p_{hot}^{est}) = (c_{indirect} - c_{direct})\\,(p_{hot}^{true} - p_{hot}^{est}).\n$$\n\nHere, $\\Delta p_{hot} = p_{hot}^{true} - p_{hot}^{est} = 0.786 - 0.88 = -0.094$, so\n\n$$\n|g^{true} - g^{est}| = |(c_{indirect} - c_{direct})\\,\\Delta p_{hot}| = |13 \\cdot (-0.094)| = 1.222.\n$$\n\n\nRounded to four significant figures and expressed in cycles, the absolute error is $1.222$ cycles.",
            "answer": "$$\\boxed{1.222}$$"
        },
        {
            "introduction": "While guarding a single 'hot' target is a powerful technique, many call sites have several likely receiver types. In such cases, a compiler must choose between more sophisticated strategies, such as generating a multi-way decision tree of type checks. This practice  asks you to analyze and compare the expected costs of two competing strategies: an optimized decision tree and a simpler guarded call with a virtual fallback. By deriving the minimal cost for each, you will learn how compilers make evidence-based decisions to generate the most efficient code for complex polymorphic calls.",
            "id": "3637428",
            "problem": "A compiler implementing devirtualization faces a polymorphic call site to a method $f$ whose dynamic receiver may be of classes $A$, $B$, or $C$. Let the probabilities that the receiver is of each class be $p_{A}$, $p_{B}$, and $p_{C}$ respectively, with $p_{A} + p_{B} + p_{C} = 1$. The compiler may choose between two devirtualization strategies evaluated in terms of expected cost, grounded in the definition of expected value $E = \\sum_{i} p_{i} c_{i}$.\n\nAssume the following cost model:\n- Each type check (e.g., evaluating a class test such as \"receiver is of class $X$\") costs $t > 0$.\n- A direct, statically bound call costs $d > 0$.\n- A fallback virtual dispatch costs an additional $v > 0$ beyond the direct call cost, so its total cost is $v + d$.\n- A guard (a single type check to confirm the most likely target) costs $g > 0$.\n\nStrategy 1 (decision tree devirtualization): Emit a decision tree of type checks to direct-call $A::f$, $B::f$, or $C::f$. The tree uses short-circuiting: for an ordering $(X, Y, Z)$, the compiler tests \"is $X$?\" first; if false, tests \"is $Y$?\"; and if both are false, calls $Z::f$ without a third test.\n\nStrategy 2 (guarded direct call): Emit a guard to the most likely target (the class with the largest probability) and a direct call if the guard passes; otherwise, fall back to the virtual dispatch.\n\nTasks:\n1. Using the law of total expectation and the given cost model, determine the ordering of $(A, B, C)$ in Strategy 1 that minimizes the expected cost. Let $p_{(1)} = \\max\\{p_{A}, p_{B}, p_{C}\\}$ denote the largest probability among the three classes.\n2. Derive the minimal expected cost of Strategy 1, expressed in terms of $p_{(1)}$, $t$, and $d$.\n3. Derive the expected cost of Strategy 2, expressed in terms of $p_{(1)}$, $g$, $v$, and $d$.\n4. Compute a single, simplified closed-form expression for the difference between Strategy 2 and the minimal Strategy 1 expected costs, defined as $D = E_{\\text{guard}} - E_{\\text{tree,min}}$.\n\nProvide the final answer as the simplified analytic expression for $D$. No numerical evaluation is required. If you introduce any additional notation, define it clearly. Do not use any units in your final expression.",
            "solution": "**Task 1 & 2: Analysis of Strategy 1 (Decision Tree Devirtualization)**\n\nStrategy $1$ involves a sequence of type checks. Let the chosen order of checks be $(C_1, C_2, C_3)$, where $\\{C_1, C_2, C_3\\}$ is a permutation of $\\{A, B, C\\}$. The compiler emits code equivalent to: \"if the receiver is of class $C_1$, call $C_1::f$; else if the receiver is of class $C_2$, call $C_2::f$; else call $C_3::f$.\"\n\nWe calculate the cost for each possible dynamic type of the receiver:\n- If the receiver is of class $C_1$ (which occurs with probability $p_{C_1}$), one type check is performed (cost $t$), and it succeeds. A direct call is then made (cost $d$). The total cost is $t + d$.\n- If the receiver is of class $C_2$ (probability $p_{C_2}$), the first type check for $C_1$ is performed and fails (cost $t$). The second type check for $C_2$ is performed and succeeds (cost $t$). A direct call is made (cost $d$). The total cost is $t + t + d = 2t + d$.\n- If the receiver is of class $C_3$ (probability $p_{C_3}$), the first check for $C_1$ fails (cost $t$), and the second check for $C_2$ fails (cost $t$). The `else` branch is taken, and a direct call to $C_3::f$ is made (cost $d$) without a third type check. The total cost is $t + t + d = 2t + d$.\n\nThe expected cost, $E_{\\text{tree}}$, for the ordering $(C_1, C_2, C_3)$ is the sum of costs weighted by their probabilities, based on the law of total expectation:\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = p_{C_1}(t + d) + p_{C_2}(2t + d) + p_{C_3}(2t + d)\n$$\nWe can factor this expression:\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = p_{C_1}t + p_{C_1}d + 2p_{C_2}t + p_{C_2}d + 2p_{C_3}t + p_{C_3}d\n$$\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (p_{C_1} + 2p_{C_2} + 2p_{C_3})t + (p_{C_1} + p_{C_2} + p_{C_3})d\n$$\nGiven the constraint $p_{A} + p_{B} + p_{C} = 1$, the second term simplifies to $d$. We can also rewrite $p_{C_2} + p_{C_3}$ as $1 - p_{C_1}$:\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (p_{C_1} + 2(p_{C_2} + p_{C_3}))t + d\n$$\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (p_{C_1} + 2(1 - p_{C_1}))t + d\n$$\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (p_{C_1} + 2 - 2p_{C_1})t + d\n$$\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (2 - p_{C_1})t + d\n$$\nTo minimize this expected cost, since $t > 0$, we must maximize the value of $p_{C_1}$. This means that the first class checked, $C_1$, must be the one with the highest probability.\nLet $p_{(1)} = \\max\\{p_{A}, p_{B}, p_{C}\\}$. The optimal ordering requires setting $C_1$ to be the class corresponding to $p_{(1)}$. The relative ordering of the remaining two classes does not affect the minimal expected cost, as their costs are identical ($2t+d$).\n\nThis completes Task 1. For Task 2, the minimal expected cost for Strategy 1, $E_{\\text{tree,min}}$, is obtained by substituting $p_{(1)}$ for $p_{C_1}$ in the derived cost formula:\n$$\nE_{\\text{tree,min}} = (2 - p_{(1)})t + d\n$$\n\n**Task 3: Analysis of Strategy 2 (Guarded Direct Call)**\n\nStrategy $2$ uses a single guard to check for the most likely target, which is the class with probability $p_{(1)}$. If the guard passes, a direct call is made. If it fails, a full virtual dispatch is performed.\n\nWe analyze the costs for the two outcomes:\n- The receiver is of the most likely class (probability $p_{(1)}$): The guard is executed (cost $g$), and it passes. A direct call is made (cost $d$). The total cost is $g + d$.\n- The receiver is not of the most likely class (probability $1 - p_{(1)}$): The guard is executed (cost $g$), and it fails. A fallback to virtual dispatch occurs (cost $v+d$). The total cost is $g + v + d$.\n\nThe expected cost for Strategy 2, $E_{\\text{guard}}$, is:\n$$\nE_{\\text{guard}} = p_{(1)}(g + d) + (1 - p_{(1)})(g + v + d)\n$$\nLet's simplify this expression:\n$$\nE_{\\text{guard}} = p_{(1)}g + p_{(1)}d + g + v + d - p_{(1)}g - p_{(1)}v - p_{(1)}d\n$$\n$$\nE_{\\text{guard}} = (p_{(1)}g - p_{(1)}g) + (p_{(1)}d - p_{(1)}d) + g + v + d - p_{(1)}v\n$$\n$$\nE_{\\text{guard}} = g + d + v - p_{(1)}v\n$$\n$$\nE_{\\text{guard}} = g + d + v(1 - p_{(1)})\n$$\n\n**Task 4: Compute the Difference in Expected Costs**\n\nThe final task is to compute the difference $D = E_{\\text{guard}} - E_{\\text{tree,min}}$. Using the expressions derived above:\n$$\nE_{\\text{guard}} = g + d + v(1 - p_{(1)})\n$$\n$$\nE_{\\text{tree,min}} = (2 - p_{(1)})t + d = 2t - p_{(1)}t + d\n$$\nThe difference $D$ is:\n$$\nD = \\left( g + d + v(1 - p_{(1)}) \\right) - \\left( (2 - p_{(1)})t + d \\right)\n$$\n$$\nD = g + d + v - p_{(1)}v - (2t - p_{(1)}t + d)\n$$\n$$\nD = g + d + v - p_{(1)}v - 2t + p_{(1)}t - d\n$$\nThe direct call cost $d$ cancels out:\n$$\nD = g + v - 2t - p_{(1)}v + p_{(1)}t\n$$\nGrouping the terms containing $p_{(1)}$ yields the final simplified expression:\n$$\nD = g + v - 2t + p_{(1)}(t - v)\n$$",
            "answer": "$$\n\\boxed{g + v - 2t + p_{(1)}(t - v)}\n$$"
        },
        {
            "introduction": "The most powerful form of devirtualization eliminates virtual calls without any runtime overhead, which requires the compiler to *prove* the receiver's exact type at compile time. This is a complex task that relies on the synergy of multiple advanced analyses and an understanding of the language's semantics. This exercise  presents a scenario where a specific combination of language features and static analyses—including Class Hierarchy Analysis and constant propagation—enables the compiler to achieve this goal. By reasoning through the necessary conditions, you will gain a deeper appreciation for the intricate logic that underpins static, guard-free devirtualization.",
            "id": "3637449",
            "problem": "An optimizing compiler for the Java programming language applies devirtualization techniques by specializing virtual calls when it can prove the dynamic type of the receiver at the call site. Consider the following small Java program that uses a subclass-distinguishing final field and an enumeration instead of numeric tags:\n\n```java\nenum Tag { CONST, ADD }\nabstract class Node {\n  final Tag tag;\n  Node(Tag t) { this.tag = t; }\n  abstract int eval();\n}\nfinal class Const extends Node {\n  final int value;\n  Const(int v) { super(Tag.CONST); this.value = v; }\n  int eval() { return value; }\n}\nfinal class Add extends Node {\n  final Node l, r;\n  Add(Node l, Node r) { super(Tag.ADD); this.l = l; this.r = r; }\n  int eval() { return l.eval() + r.eval(); }\n}\nclass Factory {\n  static Node mk(boolean b, int v) {\n    if (b) return new Const(v);\n    else return new Add(new Const(v), new Const(v));\n  }\n}\nclass Use {\n  static int run(boolean b, int v) {\n    Node n = Factory.mk(b, v);\n    if (n.tag == Tag.CONST) {\n      return ((Const) n).eval();\n    } else {\n      return n.eval();\n    }\n  }\n}\n```\n\nAssume the compiler employs:\n- Sparse Conditional Constant Propagation (SCCP; a data-flow analysis that propagates constant values through the control-flow graph),\n- Class Hierarchy Analysis (CHA; a static analysis that bounds the set of possible dynamic receiver classes),\n- Points-to analysis (an alias analysis that tracks which allocation sites a reference variable $n$ may point to under the program’s control-flow), and\n- The Java Language Specification semantics for final fields (final fields are assigned during construction and are not subsequently modified under well-defined conditions of safe publication).\n\nStarting from the fundamental definitions of dynamic dispatch (a method call resolution based on the dynamic type of the receiver object at runtime), data-flow constant propagation (flow-sensitive inference of constant values), and alias analysis (reasoning about references and mutations through them), and without assuming any special-case formulas, determine which of the following assumption sets are sufficient to allow the compiler to (i) propagate the final field value $tag$ from the object’s allocation site to the branch, (ii) establish that the branch condition $n.tag == \\mathrm{Tag.CONST}$ implies the receiver’s exact dynamic type is $\\mathrm{Const}$ in the then-branch and $\\mathrm{Add}$ in the else-branch, and hence (iii) compile direct calls to $\\mathrm{Const.eval}$ and $\\mathrm{Add.eval}$ without runtime guards.\n\nChoose the single best option.\n\nA. The field $tag$ is declared final and assigned only in each subclass constructor to a unique enumeration constant ($\\mathrm{Tag.CONST}$ for $\\mathrm{Const}$ and $\\mathrm{Tag.ADD}$ for $\\mathrm{Add}$); classes $\\mathrm{Const}$ and $\\mathrm{Add}$ are declared final; there are no reflective or low-level writes (for example, via `java.lang.reflect` or `sun.misc.Unsafe`) to $tag$; points-to analysis proves that the receiver $n$ at the call site comes from the constructors of $\\mathrm{Const}$ or $\\mathrm{Add}$; a closed-world assumption holds for Class Hierarchy Analysis (CHA), so no other subclasses of $\\mathrm{Node}$ are possible. Under these conditions, SCCP can propagate $tag$ values, the mapping from $tag$ to subclass is injective among reachable allocation sites, and devirtualization to direct calls is sound without runtime guards.\n\nB. Declaring $tag$ as final alone is sufficient; neither alias analysis nor Class Hierarchy Analysis is needed, and reflective updates or dynamic class loading do not affect the soundness of devirtualization.\n\nC. Escape analysis proves that $n$ does not escape the method $\\mathrm{Use.run}$; therefore, the compiler can replace the virtual call with a direct call target unconditionally, regardless of $tag$.\n\nD. The compiler treats the check $n.tag == \\mathrm{Tag.CONST}$ as equivalent to an `instanceof Const` test and devirtualizes based on that presumption, even without proving that each subclass constructor assigns a distinct $tag$ value or ruling out reflective writes; open-world dynamic class loading is allowed.",
            "solution": "### Derivation from First Principles\n\nThe objective is to soundly devirtualize the `eval()` calls inside `Use.run`. The core of the method is:\n```java\nNode n = Factory.mk(b, v);\nif (n.tag == Tag.CONST) {\n  return ((Const) n).eval();\n} else {\n  return n.eval();\n}\n```\nThe call `((Const) n).eval()` is already direct due to the static type of the expression after the cast. The challenge lies in the virtual call `n.eval()` within the `else`-branch. To devirtualize it to a direct call to `Add.eval()`, the compiler must prove that the dynamic type of the object referenced by `n` is `Add` in that program path.\n\nThis requires the compiler to chain together several pieces of information, corresponding to the three sub-goals in the prompt:\n\n1.  **Propagating the `tag` value:** To reason about the condition `n.tag == Tag.CONST`, the compiler must determine the possible values of `n.tag`.\n    *   **Points-to analysis** is required to determine that the reference `n` can point to objects created at two specific allocation sites: `new Const(v)` and `new Add(...)` within `Factory.mk`.\n    *   The `tag` field is `final`. According to JLS semantics, its value is set during construction and does not change.\n    *   By analyzing the constructors, the compiler sees that the `Const` allocation site initializes `tag` to the constant `Tag.CONST`, and the `Add` site initializes `tag` to `Tag.ADD`.\n    *   **Sparse Conditional Constant Propagation (SCCP)** can use the flow information from points-to analysis and the immutability of the `final` field to propagate these constant values. It concludes that a read of `n.tag` will yield either `Tag.CONST` or `Tag.ADD`.\n\n2.  **Correlating `tag` value with dynamic type:** This is the crucial inferential step.\n    *   In the `then`-branch, the condition `n.tag == Tag.CONST` holds. The compiler needs to prove that this implies the type of `n` is `Const`.\n    *   In the `else`-branch, the condition `n.tag != Tag.CONST` holds. The compiler needs to prove this implies the type of `n` is `Add`.\n    *   To establish this correlation, the compiler must know the complete set of types that `n` could possibly have and the `tag` value associated with each.\n    *   **Class Hierarchy Analysis (CHA)** discovers the subclasses of `Node`. In this code, it finds `Const` and `Add`.\n    *   However, Java supports dynamic class loading. A new subclass of `Node` could be loaded at runtime. To rule this out, the compiler must operate under a **closed-world assumption**, which posits that the classes seen at compile time are the only classes that will exist at runtime. With this assumption, CHA can guarantee that `Const` and `Add` are the *only* possible concrete types for an object of static type `Node`.\n    *   The compiler can then build a mapping: Type `Const` $\\rightarrow$ `tag` is `Tag.CONST`; Type `Add` $\\rightarrow$ `tag` is `Tag.ADD`. Since `Tag.CONST` $\\neq$ `Tag.ADD`, this mapping is injective for the set of known subclasses.\n    *   This logic depends on the immutability of the `tag` value post-construction. While `final` provides this guarantee, mechanisms like reflection (`java.lang.reflect.Field.set`) or `sun.misc.Unsafe` can circumvent it. Therefore, a sound compiler must also assume **no such reflective or low-level writes** occur.\n    *   Given all these conditions, the compiler can conclude: if `n.tag == Tag.CONST`, the type must be `Const`. If `n.tag != Tag.CONST`, since the only other possible type is `Add`, the type must be `Add`.\n\n3.  **Compiling to direct calls:**\n    *   With the type of `n` proven in both branches, devirtualization is straightforward. The call in the `then`-branch is already direct. In the `else`-branch, the compiler can replace the virtual call `n.eval()` with a direct call to `Add.eval()`. No runtime type checks (guards) are needed.\n\n### Option-by-Option Analysis\n\n**A. The field `tag` is declared `final` and assigned only in each subclass constructor to a unique enumeration constant (`Tag.CONST` for `Const` and `Tag.ADD` for `Add`); classes `Const` and `Add` are declared `final`; there are no reflective or low-level writes (for example, via `java.lang.reflect` or `sun.misc.Unsafe`) to `tag`; points-to analysis proves that the receiver `n` at the call site comes from the constructors of `Const` or `Add`; a closed-world assumption holds for Class Hierarchy Analysis (CHA), so no other subclasses of `Node` are possible. Under these conditions, SCCP can propagate `tag` values, the mapping from `tag` to subclass is injective among reachable allocation sites, and devirtualization to direct calls is sound without runtime guards.**\n\nThis option comprehensively lists all the necessary conditions derived from first principles: the `final` and uniquely assigned `tag`, the absence of reflective writes, the use of points-to analysis, and the critical role of CHA under a closed-world assumption. It correctly describes the consequences: SCCP can propagate values, the tag-to-type mapping is injective, and devirtualization is sound.\n\n**Verdict:** **Correct**.\n\n**B. Declaring `tag` as `final` alone is sufficient; neither alias analysis nor Class Hierarchy Analysis is needed, and reflective updates or dynamic class loading do not affect the soundness of devirtualization.**\n\nThis option is incorrect on multiple grounds.\n*   Declaring `tag` as `final` is not sufficient. Without alias (points-to) analysis, the compiler cannot connect the reference `n` to the allocation sites where `tag` is initialized.\n*   Without CHA (and a closed-world view), the compiler cannot prove that `n.tag != Tag.CONST` implies the type is `Add`, as other unknown subclasses of `Node` might exist.\n*   Allowing reflective updates would break the constancy of `tag`, making the check useless. Allowing open-world dynamic class loading breaks the reasoning for the `else`-branch.\n\n**Verdict:** **Incorrect**.\n\n**C. Escape analysis proves that `n` does not escape the method `Use.run`; therefore, the compiler can replace the virtual call with a direct call target unconditionally, regardless of `tag`.**\n\nThis option misapplies the concept of escape analysis. While it is true that the object `n` does not escape the method `Use.run`, this fact alone does not determine its concrete type. The type of `n` depends on the data-flow from the parameter `b`. Escape analysis helps with optimizations like stack allocation or lock elision, but it does not resolve data-dependent type uncertainty. The claim that the call can be devirtualized \"unconditionally, regardless of `tag`\" is false, as the compiler would not know *which* direct call to make (`Const.eval` or `Add.eval`).\n\n**Verdict:** **Incorrect**.\n\n**D. The compiler treats the check `n.tag == Tag.CONST` as equivalent to an `instanceof Const` test and devirtualizes based on that presumption, even without proving that each subclass constructor assigns a distinct `tag` value or ruling out reflective writes; open-world dynamic class loading is allowed.**\n\nThis option describes an unsound and incorrect compiler. A compiler cannot make a \"presumption\" of equivalence without proof.\n*   If the compiler does not prove the tag assignment is distinct (e.g., if `Add` also used `Tag.CONST`), the presumption is false.\n*   If reflective writes are possible, the `tag` value at the check site may have no relation to the object's original type.\n*   If open-world loading is allowed, `n.tag != Tag.CONST` does not imply the type is `Add`, invalidating the devirtualization in the `else`-branch.\nA compiler making such assumptions would generate incorrect code that could lead to runtime errors (e.g., `ClassCastException` or calling the wrong method).\n\n**Verdict:** **Incorrect**.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}