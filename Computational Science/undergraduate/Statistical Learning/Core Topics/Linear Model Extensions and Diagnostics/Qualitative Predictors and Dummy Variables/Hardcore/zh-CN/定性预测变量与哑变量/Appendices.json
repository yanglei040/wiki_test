{
    "hands_on_practices": [
        {
            "introduction": "包含哑变量的线性回归模型非常强大，但解释其系数可能颇具挑战性，尤其是在存在交互项的情况下。本练习提供了一种动手实践的方法，通过模拟一次“类别转换”，您可以量化改变一个定性特征对模型预测结果的具体影响。这种反事实分析不仅能帮助您理解哑变量系数的实际意义，还能加深您对整个模型工作原理的认识。",
            "id": "3164642",
            "problem": "给定一个线性回归模型，其定性预测变量使用参考单元（也称带截距项的独热编码）虚拟变量进行编码。设预测结果表示为 $\\hat{y}(\\mathbf{x}, \\mathbf{z})$，其中 $\\mathbf{x} \\in \\mathbb{R}^p$ 是定量特征向量，$\\mathbf{z}$ 是类别水平向量，每个类别变量对应一个水平。对于每个具有水平集 $\\mathcal{L}_c$ 的类别变量 $c$，指定的基线水平 $\\text{baseline}_c \\in \\mathcal{L}_c$ 不被显式编码；只有 $\\mathcal{L}_c \\setminus \\{\\text{baseline}_c\\}$ 中的水平的指示变量会进入模型。模型中可以选择性地包含类别水平与定量特征之间的交互作用。\n\n该模型的形式化表达如下\n$$\n\\hat{y}(\\mathbf{x}, \\mathbf{z}) \\;=\\; \\beta_0 \\;+\\; \\sum_{j=1}^{p} \\beta_j x_j \\;+\\; \\sum_{c \\in \\mathcal{C}} \\sum_{l \\in \\mathcal{L}_c \\setminus \\{\\text{baseline}_c\\}} \\gamma_{c,l}\\,\\mathbf{1}\\{z_c = l\\}\n\\;+\\; \\sum_{(c,j)\\in \\mathcal{I}} \\sum_{l \\in \\mathcal{L}_c \\setminus \\{\\text{baseline}_c\\}} \\delta_{c,l,j}\\,\\mathbf{1}\\{z_c = l\\}\\,x_j,\n$$\n其中 $\\beta_0 \\in \\mathbb{R}$ 是截距，$\\beta_j \\in \\mathbb{R}$ 是定量特征的系数，$\\gamma_{c,l} \\in \\mathbb{R}$ 是类别变量 $c$ 在水平 $l$ 上的主效应虚拟系数，$\\delta_{c,l,j} \\in \\mathbb{R}$ 是类别变量 $c$ 的水平 $l$ 与定量特征 $x_j$ 之间的交互作用系数。集合 $\\mathcal{I}$ 列出了模型中存在的类别-定量交互作用对。\n\n对于给定的观测值 $(\\mathbf{x}, \\mathbf{z})$，考虑一个反事实情况，其中单个类别变量 $c^\\star$ 的水平从 $a$ 变为 $b$，产生 $\\mathbf{z}_{c^\\star \\leftarrow b}$。将原始类别转换效应定义为\n$$\n\\Delta_{c^\\star:a \\to b}(\\mathbf{x}, \\mathbf{z})\n\\;=\\;\n\\hat{y}(\\mathbf{x}, \\mathbf{z}_{c^\\star \\leftarrow b})\n-\n\\hat{y}(\\mathbf{x}, \\mathbf{z}),\n$$\n并将标准化效应大小（给定一个正标量 $\\sigma  0$）定义为\n$$\nE^{\\mathrm{std}}_{c^\\star:a \\to b}(\\mathbf{x}, \\mathbf{z}) = \\frac{\\Delta_{c^\\star:a \\to b}(\\mathbf{x}, \\mathbf{z})}{\\sigma}.\n$$\n\n您的任务是编写一个程序，根据每个测试用例中提供的模型规范，计算 $E^{\\mathrm{std}}_{c^\\star:a \\to b}(\\mathbf{x}, \\mathbf{z})$。所有测试用例均使用带截距项的参考单元编码；每个类别变量的基线水平都有明确指定。如果一个类别水平等于其基线水平，其主效应贡献为 $0$；同样地，对于交互作用，缺失或基线水平的贡献为 $0$。\n\n测试套件：\n\n- 测试用例 1：\n  - 定量特征：一个名为 $x$ 的特征，其系数 $\\beta_x = 1.5$，截距 $\\beta_0 = 2.0$。\n  - 类别变量：一个名为 color 的变量，其水平为 $\\{\\text{red}, \\text{blue}, \\text{green}\\}$，基线水平为 red。主效应系数：$\\gamma_{\\text{color},\\text{blue}} = 0.8$，$\\gamma_{\\text{color},\\text{green}} = -0.5$。无交互作用。\n  - 观测值：$x = 3.0$，color = red。将 color 切换为 blue。使用 $\\sigma = 0.4$。\n\n- 测试用例 2：\n  - 定量特征：一个名为 $x$ 的特征，其系数 $\\beta_x = -1.0$，截距 $\\beta_0 = 0.0$。\n  - 类别变量：一个名为 color 的变量，其水平为 $\\{\\text{red}, \\text{blue}, \\text{green}\\}$，基线水平为 red。主效应系数：$\\gamma_{\\text{color},\\text{blue}} = 1.2$，$\\gamma_{\\text{color},\\text{green}} = -0.3$。无交互作用。\n  - 观测值：$x = -5.0$，color = green。将 color 切换为 green。使用 $\\sigma = 1.0$。\n\n- 测试用例 3：\n  - 定量特征：一个名为 $p$ 的特征，其系数 $\\beta_p = -2.0$，截距 $\\beta_0 = 0.0$。\n  - 类别变量：\n    - brand，水平为 $\\{\\text{A}, \\text{B}\\}$，基线为 A；$\\gamma_{\\text{brand},\\text{B}} = 1.2$。\n    - season，水平为 $\\{\\text{winter}, \\text{spring}, \\text{summer}, \\text{autumn}\\}$，基线为 winter；$\\gamma_{\\text{season},\\text{spring}} = 0.5$，$\\gamma_{\\text{season},\\text{summer}} = 1.0$，$\\gamma_{\\text{season},\\text{autumn}} = 0.2$。\n    - 无交互作用。\n  - 观测值：$p = 0.75$，brand = B，season = autumn。将 season 切换为 summer。使用 $\\sigma = 0.5$。\n\n- 测试用例 4：\n  - 定量特征：一个名为 $n\\_users$ 的特征，其系数 $\\beta_{n\\_users} = 0.2$，截距 $\\beta_0 = 0.0$。\n  - 类别变量：一个名为 tier 的变量，其水平为 $\\{\\text{basic}, \\text{pro}, \\text{enterprise}\\}$，基线为 basic。主效应系数：$\\gamma_{\\text{tier},\\text{pro}} = 0.3$，$\\gamma_{\\text{tier},\\text{enterprise}} = 1.0$。\n  - 存在交互作用：tier 和 $n\\_users$ 之间，其中 $\\delta_{\\text{tier},\\text{pro},\\,n\\_users} = 0.1$，$\\delta_{\\text{tier},\\text{enterprise},\\,n\\_users} = 0.05$。\n  - 观测值：$n\\_users = 10$，tier = pro。将 tier 切换为 enterprise。使用 $\\sigma = 0.2$。\n\n- 测试用例 5：\n  - 定量特征：两个特征 $x_1$ 和 $x_2$，其系数 $\\beta_{x_1} = 1.0$，$\\beta_{x_2} = -0.5$，截距 $\\beta_0 = 5.0$。\n  - 类别变量：\n    - brand，水平为 $\\{\\text{A}, \\text{B}\\}$，基线为 A；$\\gamma_{\\text{brand},\\text{B}} = -0.7$。\n    - region，水平为 $\\{\\text{north}, \\text{south}, \\text{east}\\}$，基线为 north；$\\gamma_{\\text{region},\\text{south}} = 0.4$，$\\gamma_{\\text{region},\\text{east}} = -0.2$。\n    - 无交互作用。\n  - 观测值：$x_1 = 4.0$，$x_2 = -2.0$，brand = B，region = south。将 brand 切换为 A。使用 $\\sigma = 0.7$。\n\n您的程序必须为每个测试用例计算标准化效应大小 $E^{\\mathrm{std}}_{c^\\star:a \\to b}(\\mathbf{x}, \\mathbf{z})$，并生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5]$）。不涉及物理单位。不涉及角度。不涉及百分比。输出条目必须是实数（浮点数），并按测试用例 1 到 5 的顺序排列。",
            "solution": "该问题要求在一个线性回归模型中，计算与单个类别预测变量的反事实变化相关的标准化效应大小 $E^{\\mathrm{std}}$。该模型包含了定量特征、定性（类别）特征及其交互作用。\n\n首先，我们必须形式化原始类别转换效应 $\\Delta_{c^\\star:a \\to b}(\\mathbf{x}, \\mathbf{z})$ 的计算。模型由下式给出：\n$$\n\\hat{y}(\\mathbf{x}, \\mathbf{z}) \\;=\\; \\beta_0 \\;+\\; \\sum_{j=1}^{p} \\beta_j x_j \\;+\\; \\sum_{c \\in \\mathcal{C}} \\sum_{l \\in \\mathcal{L}_c \\setminus \\{\\text{baseline}_c\\}} \\gamma_{c,l}\\,\\mathbf{1}\\{z_c = l\\}\n\\;+\\; \\sum_{(c,j)\\in \\mathcal{I}} \\sum_{l \\in \\mathcal{L}_c \\setminus \\{\\text{baseline}_c\\}} \\delta_{c,l,j}\\,\\mathbf{1}\\{z_c = l\\}\\,x_j\n$$\n该效应定义为预测结果的差异：\n$$\n\\Delta_{c^\\star:a \\to b}(\\mathbf{x}, \\mathbf{z}) \\;=\\; \\hat{y}(\\mathbf{x}, \\mathbf{z}_{c^\\star \\leftarrow b}) - \\hat{y}(\\mathbf{x}, \\mathbf{z})\n$$\n其中 $\\mathbf{z}_{c^\\star \\leftarrow b}$ 是与 $\\mathbf{z}$ 相同的特征向量，只是类别变量 $c^\\star$ 的水平从 $a$ 变为了 $b$。\n\n当我们计算这个差值时，$\\hat{y}$ 的模型表达式中所有不依赖于 $c^\\star$ 水平的项都将抵消。这包括截距 $\\beta_0$、所有定量预测变量的主效应 $\\sum_{j=1}^{p} \\beta_j x_j$，以及所有其他 $c \\neq c^\\star$ 的类别变量 $c \\in \\mathcal{C}$ 的主效应和交互作用效应。\n\n唯一不被抵消的部分是与 $c^\\star$ 相关的部分。让我们定义一个类别变量 $c$ 的水平 $l$ 对给定定量特征向量 $\\mathbf{x}$ 的预测的总贡献。我们用 $f(c, l, \\mathbf{x})$ 表示这个贡献。根据模型定义，这个贡献是：\n$$\nf(c, l, \\mathbf{x}) = \\left( \\sum_{l' \\in \\mathcal{L}_c \\setminus \\{\\text{baseline}_c\\}} \\gamma_{c,l'}\\,\\mathbf{1}\\{l = l'\\} \\right) + \\left( \\sum_{(c,j)\\in \\mathcal{I}} \\sum_{l' \\in \\mathcal{L}_c \\setminus \\{\\text{baseline}_c\\}} \\delta_{c,l',j}\\,\\mathbf{1}\\{l = l'\\}\\,x_j \\right)\n$$\n这个表达式可以被简化。如果水平 $l$ 是基线水平 $\\text{baseline}_c$，那么所有的指示函数 $\\mathbf{1}\\{l=l'\\}$ 都为零，因此 $f(c, \\text{baseline}_c, \\mathbf{x}) = 0$。如果 $l$ 不是基线水平，则表达式简化为：\n$$\nf(c, l, \\mathbf{x}) = \\gamma_{c,l} + \\sum_{j \\text{ s.t. } (c,j) \\in \\mathcal{I}} \\delta_{c,l,j}\\,x_j \\quad \\text{for } l \\neq \\text{baseline}_c\n$$\n我们可以通过采用基线水平的系数为零的约定来统一这些情况：对于所有的 $c, j$，$\\gamma_{c,\\text{baseline}_c} = 0$ 且 $\\delta_{c,\\text{baseline}_c,j} = 0$。\n\n原始效应 $\\Delta_{c^\\star:a \\to b}$ 是新水平 $b$ 和原始水平 $a$ 的贡献之差：\n$$\n\\Delta_{c^\\star:a \\to b}(\\mathbf{x}, \\mathbf{z}) = f(c^\\star, b, \\mathbf{x}) - f(c^\\star, a, \\mathbf{x})\n$$\n$$\n\\Delta_{c^\\star:a \\to b} = \\left( \\gamma_{c^\\star,b} + \\sum_{j \\text{ s.t. } (c^\\star,j) \\in \\mathcal{I}} \\delta_{c^\\star,b,j}\\,x_j \\right) - \\left( \\gamma_{c^\\star,a} + \\sum_{j \\text{ s.t. } (c^\\star,j) \\in \\mathcal{I}} \\delta_{c^\\star,a,j}\\,x_j \\right)\n$$\n最后，通过除以 $\\sigma$ 得到标准化效应大小：\n$$\nE^{\\mathrm{std}}_{c^\\star:a \\to b}(\\mathbf{x}, \\mathbf{z}) = \\frac{\\Delta_{c^\\star:a \\to b}}{\\sigma}\n$$\n现在我们将此框架应用于每个测试用例。\n\n测试用例 1：\n- 将 $c^\\star=\\text{color}$ 从 $a=\\text{red}$ 切换到 $b=\\text{blue}$。\n- 水平 $\\text{red}$ 是基线，所以 $\\gamma_{\\text{color,red}}=0$。$\\text{blue}$ 的系数是 $\\gamma_{\\text{color,blue}} = 0.8$。\n- 没有交互作用，所以所有的 $\\delta$ 系数都为 $0$。\n- $\\Delta_{\\text{color}:\\text{red} \\to \\text{blue}} = (\\gamma_{\\text{color,blue}}) - (\\gamma_{\\text{color,red}}) = 0.8 - 0 = 0.8$。\n- 给定 $\\sigma = 0.4$，标准化效应为 $E^{\\mathrm{std}} = 0.8 / 0.4 = 2.0$。\n\n测试用例 2：\n- 将 $c^\\star=\\text{color}$ 从 $a=\\text{green}$ 切换到 $b=\\text{green}$。\n- 由于起始水平与结束水平相同，预测的变化必定为零。\n- $\\Delta_{\\text{color}:\\text{green} \\to \\text{green}} = \\hat{y}(\\dots, \\text{color}=\\text{green}) - \\hat{y}(\\dots, \\text{color}=\\text{green}) = 0$。\n- 使用 $\\sigma = 1.0$，标准化效应为 $E^{\\mathrm{std}} = 0 / 1.0 = 0.0$。\n\n测试用例 3：\n- 将 $c^\\star=\\text{season}$ 从 $a=\\text{autumn}$ 切换到 $b=\\text{summer}$。\n- 变量 `brand` 不变，因此其贡献抵消。没有交互作用。\n- `season` 的基线是 `winter`。`autumn` 和 `summer` 都不是基线。\n- 系数为 $\\gamma_{\\text{season,autumn}} = 0.2$ 和 $\\gamma_{\\text{season,summer}} = 1.0$。\n- $\\Delta_{\\text{season}:\\text{autumn} \\to \\text{summer}} = \\gamma_{\\text{season,summer}} - \\gamma_{\\text{season,autumn}} = 1.0 - 0.2 = 0.8$。\n- 使用 $\\sigma = 0.5$，标准化效应为 $E^{\\mathrm{std}} = 0.8 / 0.5 = 1.6$。\n\n测试用例 4：\n- 将 $c^\\star=\\text{tier}$ 从 $a=\\text{pro}$ 切换到 $b=\\text{enterprise}$。\n- 此案例包括 `tier` 和 $n\\_users$ 之间的交互作用。\n- 观测值为 $n\\_users = 10$。`tier` 的基线是 `basic`。\n- 变化涉及两个非基线水平，`pro` 和 `enterprise`。\n- $\\Delta_{\\text{tier}:\\text{pro} \\to \\text{enterprise}} = f(\\text{tier}, \\text{enterprise}, \\{n\\_users: 10\\}) - f(\\text{tier}, \\text{pro}, \\{n\\_users: 10\\})$。\n- $f(\\text{tier}, \\text{enterprise}, \\{n\\_users: 10\\}) = \\gamma_{\\text{tier,enterprise}} + \\delta_{\\text{tier,enterprise},n\\_users} \\times n\\_users = 1.0 + 0.05 \\times 10 = 1.5$。\n- $f(\\text{tier}, \\text{pro}, \\{n\\_users: 10\\}) = \\gamma_{\\text{tier,pro}} + \\delta_{\\text{tier,pro},n\\_users} \\times n\\_users = 0.3 + 0.1 \\times 10 = 1.3$。\n- $\\Delta = 1.5 - 1.3 = 0.2$。\n- 使用 $\\sigma = 0.2$，标准化效应为 $E^{\\mathrm{std}} = 0.2 / 0.2 = 1.0$。\n\n测试用例 5：\n- 将 $c^\\star=\\text{brand}$ 从 $a=\\text{B}$ 切换到 $b=\\text{A}$。\n- 水平 `A` 是 `brand` 的基线，因此其有效系数为 $0$。水平 `B` 的系数为 $\\gamma_{\\text{brand,B}} = -0.7$。\n- 没有交互作用。其他变量（`region`、$x_1$、$x_2$）的状态无关紧要，因为它们的贡献会抵消。\n- $\\Delta_{\\text{brand}:\\text{B} \\to \\text{A}} = \\gamma_{\\text{brand,A}} - \\gamma_{\\text{brand,B}} = 0 - (-0.7) = 0.7$。\n- 使用 $\\sigma = 0.7$，标准化效应为 $E^{\\mathrm{std}} = 0.7 / 0.7 = 1.0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the standardized effect size for a counterfactual category switch\n    in a linear regression model for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            \"c_star\": \"color\",\n            \"from_level\": \"red\",\n            \"to_level\": \"blue\",\n            \"x_vals\": {\"x\": 3.0},\n            \"coeffs\": {\n                \"gamma\": {\"color\": {\"blue\": 0.8, \"green\": -0.5}}\n            },\n            \"baselines\": {\"color\": \"red\"},\n            \"sigma\": 0.4\n        },\n        # Test case 2\n        {\n            \"c_star\": \"color\",\n            \"from_level\": \"green\",\n            \"to_level\": \"green\",\n            \"x_vals\": {\"x\": -5.0},\n            \"coeffs\": {\n                \"gamma\": {\"color\": {\"blue\": 1.2, \"green\": -0.3}}\n            },\n            \"baselines\": {\"color\": \"red\"},\n            \"sigma\": 1.0\n        },\n        # Test case 3\n        {\n            \"c_star\": \"season\",\n            \"from_level\": \"autumn\",\n            \"to_level\": \"summer\",\n            \"x_vals\": {\"p\": 0.75},\n            \"coeffs\": {\n                \"gamma\": {\n                    \"brand\": {\"B\": 1.2},\n                    \"season\": {\"spring\": 0.5, \"summer\": 1.0, \"autumn\": 0.2}\n                }\n            },\n            \"baselines\": {\"brand\": \"A\", \"season\": \"winter\"},\n            \"sigma\": 0.5\n        },\n        # Test case 4\n        {\n            \"c_star\": \"tier\",\n            \"from_level\": \"pro\",\n            \"to_level\": \"enterprise\",\n            \"x_vals\": {\"n_users\": 10},\n            \"coeffs\": {\n                \"gamma\": {\"tier\": {\"pro\": 0.3, \"enterprise\": 1.0}},\n                \"delta\": {\n                    \"tier\": {\n                        \"pro\": {\"n_users\": 0.1},\n                        \"enterprise\": {\"n_users\": 0.05}\n                    }\n                }\n            },\n            \"baselines\": {\"tier\": \"basic\"},\n            \"sigma\": 0.2\n        },\n        # Test case 5\n        {\n            \"c_star\": \"brand\",\n            \"from_level\": \"B\",\n            \"to_level\": \"A\",\n            \"x_vals\": {\"x1\": 4.0, \"x2\": -2.0},\n            \"coeffs\": {\n                \"gamma\": {\n                    \"brand\": {\"B\": -0.7},\n                    \"region\": {\"south\": 0.4, \"east\": -0.2}\n                }\n            },\n            \"baselines\": {\"brand\": \"A\", \"region\": \"north\"},\n            \"sigma\": 0.7\n        }\n    ]\n\n    def get_level_contribution(c_var, level, x_vals, coeffs, baselines):\n        \"\"\"\n        Calculates the total contribution of a specific categorical level to the\n        prediction, including main and interaction effects.\n        \"\"\"\n        if level == baselines[c_var]:\n            return 0.0\n\n        # Main effect (gamma coefficient)\n        gamma = coeffs.get(\"gamma\", {}).get(c_var, {}).get(level, 0.0)\n\n        # Sum of interaction effects (delta coefficients)\n        delta_sum = 0.0\n        # Check if interactions are defined for the variable and level\n        delta_coeffs_for_level = coeffs.get(\"delta\", {}).get(c_var, {}).get(level)\n        if delta_coeffs_for_level:\n            for x_var, x_val in x_vals.items():\n                if x_var in delta_coeffs_for_level:\n                    delta_sum += delta_coeffs_for_level[x_var] * x_val\n        \n        return gamma + delta_sum\n\n    results = []\n    for case in test_cases:\n        c_star = case[\"c_star\"]\n        from_level = case[\"from_level\"]\n        to_level = case[\"to_level\"]\n        x_vals = case[\"x_vals\"]\n        coeffs = case[\"coeffs\"]\n        baselines = case[\"baselines\"]\n        sigma = case[\"sigma\"]\n\n        # Calculate contribution from the original level\n        contrib_from = get_level_contribution(\n            c_star, from_level, x_vals, coeffs, baselines\n        )\n        \n        # Calculate contribution from the new (counterfactual) level\n        contrib_to = get_level_contribution(\n            c_star, to_level, x_vals, coeffs, baselines\n        )\n\n        # Raw effect is the difference in contributions\n        raw_effect = contrib_to - contrib_from\n        \n        # Standardized effect\n        std_effect = raw_effect / sigma\n        results.append(std_effect)\n\n    # Format the output as specified\n    formatted_results = [f\"{r:.16g}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在比较不同模型时，我们需要在模型的拟合优度和复杂度之间找到平衡。赤池信息准则（Akaike Information Criterion, AIC）等信息准则是标准工具，但它们要求我们正确计算模型的参数数量。本练习将处理模型选择中一个关键且常被误解的方面：一个具有多个水平的定性预测变量会给模型增加远不止一个参数。通过这个练习，您将学习如何正确计算包含哑变量的模型的“自由度”，并应用一个惩罚模型复杂度的准则，该准则基于模型中所有可估计系数的总数，而非仅仅是预测变量的数量。",
            "id": "3164632",
            "problem": "一位数据分析师正在比较一个统计学习场景中的候选回归模型，其中出现了具有多个水平的多个定性预测变量。当使用具有单一参考水平的虚拟变量对定性预测变量进行编码时，每个具有 $L$ 个观测水平的定性预测变量为线性预测器贡献 $L-1$ 个自由系数，而一个定量预测变量贡献一个自由斜率系数，截距贡献一个自由系数。从模型选择应最小化真实数据生成分布与候选模型分布之间的期望 Kullback–Leibler 散度（Kullback–Leibler (KL) 散度）的原则出发，并利用训练对数似然会按与自由参数数量成比例的量高估样本外性能的渐近理由，推导出一个信息准则，该准则惩罚可估计水平系数的总数，而不仅仅是预测变量的数量。然后，将您推导出的准则应用于以下拟合模型：\n- 最大化对数似然为 $\\ln L(\\hat{\\theta}) = -920.35$。\n- 有 $q = 4$ 个定量预测变量。\n- 有三个定性预测变量，其水平分别为 $L_{1} = 30$，$L_{2} = 7$ 和 $L_{3} = 4$。\n计算此拟合模型的水平惩罚信息准则的值。将最终答案四舍五入到四位有效数字。",
            "solution": "问题要求基于最小化期望 Kullback-Leibler (KL) 散度推导出一个模型选择准则，然后将该准则应用于一个特定的回归模型。\n\n首先，我们验证问题陈述。\n\n**步骤1：提取已知条件**\n- **模型选择原则：** 最小化真实数据生成分布与候选模型分布之间的期望 Kullback–Leibler (KL) 散度。\n- **渐近理由：** 训练对数似然会按与自由参数数量成比例的量高估样本外性能。\n- **参数计数规则：**\n    - 一个具有 $L$ 个水平的定性预测变量为线性预测器贡献 $L-1$ 个自由系数。\n    - 一个定量预测变量贡献一个自由斜率系数。\n    - 截距贡献一个自由系数。\n- **推导任务：** 推导一个信息准则，该准则基于其自由参数（系数）的正确计数来惩罚模型，特别是那些由定性预测变量的水平产生的参数，而不是简单地计算预测变量的数量。\n- **应用数据：**\n    - 最大化对数似然，$\\ln L(\\hat{\\theta}) = -920.35$。\n    - 定量预测变量数量，$q = 4$。\n    - 三个定性预测变量，其水平分别为 $L_{1} = 30$，$L_{2} = 7$ 和 $L_{3} = 4$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在科学上基于已建立的模型选择统计理论。KL 散度、对数似然和参数惩罚的概念是赤池信息准则（AIC）的基本原则。问题提得很好，为推导准则并计算其值提供了清晰的理论基础和所有必要的数据。语言客观而精确。问题引导用户在一个包含虚拟变量的线性模型中正确地计算参数数量，这是回归分析中的一个标准程序。因此，该问题被认为是有效的。\n\n**步骤3：结论与行动**\n问题是有效的。我们继续进行解答。\n\n**信息准则的推导**\n\n设真实未知的数据生成概率分布为 $f(x)$。设 $g_{\\theta}(x)$ 是对应于候选模型的概率分布，由向量 $\\theta$ 参数化。从 $g_{\\theta}$ 到 $f$ 的 Kullback-Leibler (KL) 散度衡量了当使用 $g_{\\theta}$ 来近似 $f$ 时丢失的信息：\n$$\nD_{\\text{KL}}(f || g_{\\theta}) = \\int f(x) \\ln \\left( \\frac{f(x)}{g_{\\theta}(x)} \\right) dx = E_{f}[\\ln f(X)] - E_{f}[\\ln g_{\\theta}(X)]\n$$\n为了选择最佳模型，我们寻求最小化这个散度。由于 $E_{f}[\\ln f(X)]$ 对所有候选模型都是常数，最小化 $D_{\\text{KL}}(f || g_{\\theta})$ 等价于最大化模型的期望对数似然 $E_{f}[\\ln g_{\\theta}(X)]$。\n\n真实的分布 $f$ 是未知的，所以这个期望不能直接计算。取而代之的是，我们使用训练数据上的最大化对数似然 $\\ln L(\\hat{\\theta}) = \\sum_{i=1}^{n} \\ln g_{\\hat{\\theta}}(x_i)$，其中 $\\hat{\\theta}$ 是 $\\theta$ 的最大似然估计。\n\n如问题所述，$\\ln L(\\hat{\\theta})$ 是模型在新数据上期望性能的一个有偏估计量。问题提供了渐近结果，即这个样本内对数似然会高估真实的期望样本外对数似然，高估的量与自由参数的数量成正比，我们将其表示为 $k$。具体来说，偏差约等于 $k$。\n$$\nE[\\text{expected log-likelihood for new data}] \\approx \\ln L(\\hat{\\theta}) - k\n$$\n为了校正这种乐观偏差，我们用估计参数的数量来惩罚最大化对数似然。如果一个模型的惩罚后对数似然 $\\ln L(\\hat{\\theta}) - k$ 的值更高，那么它就是更优的模型。\n\n传统上，信息准则是在偏差尺度（-2 乘以对数似然）上表示的，并且是需要最小化的。将惩罚后的对数似然乘以 -2，得到信息准则，我们称之为 $IC$：\n$$\nIC = -2(\\ln L(\\hat{\\theta}) - k) = -2\\ln L(\\hat{\\theta}) + 2k\n$$\n这就是众所周知的赤池信息准则 (AIC)。问题中提到的“水平惩罚信息准则”正是这个准则，其中 $k$ 是通过按规定正确计算所有自由系数得出的。\n\n**自由参数数量 ($k$) 的计算**\n\n问题为计算模型线性预测器中的自由参数数量 $k$ 提供了明确的方法。\n- 模型包含一个截距，贡献 $1$ 个参数。\n- 有 $q = 4$ 个定量预测变量，每个贡献一个斜率系数。这提供了 $4$ 个参数。\n- 有三个定性预测变量。对于一个使用参考水平编码的具有 $L$ 个水平的预测变量，它贡献 $L-1$ 个参数（用于虚拟变量）。\n    - 预测变量1有 $L_1 = 30$ 个水平，贡献 $L_1 - 1 = 30 - 1 = 29$ 个参数。\n    - 预测变量2有 $L_2 = 7$ 个水平，贡献 $L_2 - 1 = 7 - 1 = 6$ 个参数。\n    - 预测变量3有 $L_3 = 4$ 个水平，贡献 $L_3 - 1 = 4 - 1 = 3$ 个参数。\n\n可估计系数的总数 $k$ 是这些参数的和：\n$$\nk = 1 + q + (L_1 - 1) + (L_2 - 1) + (L_3 - 1)\n$$\n代入给定值：\n$$\nk = 1 + 4 + (30 - 1) + (7 - 1) + (4 - 1) = 1 + 4 + 29 + 6 + 3 = 43\n$$\n注意，这个计数遵循了问题对线性预测器中系数的关注。\n\n**对拟合模型的应用**\n\n现在我们使用推导出的公式和给定的模型数据来计算信息准则的值。\n- 推导出的准则：$IC = -2\\ln L(\\hat{\\theta}) + 2k$\n- 给定的最大化对数似然：$\\ln L(\\hat{\\theta}) = -920.35$\n- 计算出的参数数量：$k = 43$\n\n将这些值代入公式：\n$$\nIC = -2(-920.35) + 2(43)\n$$\n$$\nIC = 1840.7 + 86\n$$\n$$\nIC = 1926.7\n$$\n问题要求最终答案四舍五入到四位有效数字。将 $1926.7$ 四舍五入到四位有效数字得到 $1927$。",
            "answer": "$$\\boxed{1927}$$"
        },
        {
            "introduction": "普通最小二乘法（Ordinary Least Squares, OLS）回归的一个关键假设是同方差性，即误差项的方差是恒定的。当模型包含定性预测变量时，这个假设常常被违反，因为不同的类别可能表现出不同水平的“噪音”。本练习将引导您完成一个完整而真实的建模流程：首先学习如何使用模型残差来诊断跨组别的异方差性问题，然后应用加权最小二乘法（Weighted Least Squares, WLS）来构建一个更有效、更可靠的模型。",
            "id": "3164625",
            "problem": "给定一个统计学习任务，涉及一个包含单个定量预测变量和通过虚拟变量编码的多水平定性预测变量的线性模型。目标是诊断并建模跨类别水平的异方差性，并使用加权最小二乘法（WLS）引入水平特定的权重。请在以下基础框架内进行操作：经典线性模型假设响应变量 $y$ 通过设计矩阵 $X$ 与预测变量呈线性关系，并带有加性误差 $\\varepsilon$，使得 $\\mathbb{E}[\\varepsilon] = 0$，误差不相关，且各组间的方差可能不恒定。具有多个水平的定性预测变量通过相对于所选参考水平的虚拟变量来表示。对于每个测试用例，假设定性预测变量具有水平 $A$、$B$ 和 $C$，并且参考水平是 $A$。\n\n您的程序必须：\n- 构建设计矩阵 $X$，包含截距、定量预测变量 $x$ 以及非参考水平 $B$ 和 $C$ 的虚拟变量。\n- 仅使用给定数据和设计矩阵计算普通最小二乘法（OLS）估计值。\n- 计算残差 $r = y - X\\hat{\\beta}_{\\text{OLS}}$，并为每个水平 $g \\in \\{A,B,C\\}$ 估计一个水平特定的方差 $\\hat{\\sigma}^2_g$，即该水平内残差平方的均值。\n- 通过计算比率 $R = \\max_g \\hat{\\sigma}^2_g \\,/\\, \\min_g \\hat{\\sigma}^2_g$ 并将其与阈值 $\\tau$ 进行比较来诊断异方差性。如果 $R  \\tau$，则声明存在异方差性。\n- 如果存在异方差性，则使用对角权重 $w_i = 1 / \\hat{\\sigma}^2_{g(i)}$ 执行 WLS，其中 $g(i)$ 表示观测值 $i$ 的水平。如果不存在，则对所有 $i$ 设置 $w_i = 1$。计算 WLS 估计值。\n- 从 OLS 和 WLS 中提取以下系数：$x$ 的斜率，以及水平 $B$ 和 $C$（相对于 $A$）的虚拟系数。\n\n对于数值输出，请将所有浮点数结果四舍五入到 $6$ 位小数。此问题中没有物理单位，也没有角度。不使用百分比。\n\n测试套件：\n使用以下测试用例（每个测试用例是一个元组 $(x, y, \\text{groups})$）和共同的阈值 $\\tau = 1.5$。在所有情况下，groups 是一个与 $x$ 和 $y$ 长度相同的列表，仅包含字符串 \"A\"、\"B\" 或 \"C\"。设计矩阵必须使用 \"A\"作为参考水平。\n\n- 测试用例 1（跨水平异方差）：\n    - x = `[1, 2, 3, 4, 1.5, 2.5, 3.5, 4.5, 0.5, 1.5, 2.5, 3.5]`\n    - y = `[3.7, 4.9, 6.6, 7.8, 5.75, 2.95, 7.95, 5.55, 4.25, 3.95, 7.0, 6.65]`\n    - groups = `[\"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"C\", \"C\", \"C\", \"C\"]`\n\n- 测试用例 2（跨水平近似同方差）：\n    - x = `[1, 2, 3, 4, 1.5, 2.5, 3.5, 4.5, 0.5, 1.5, 2.5, 3.5]`\n    - y = `[3.8, 4.6, 6.7, 7.9, 3.45, 4.45, 6.35, 7.55, 3.5, 4.55, 6.4, 7.65]`\n    - groups = `[\"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"C\", \"C\", \"C\", \"C\"]`\n\n- 测试用例 3（组大小不平衡，强异方差性）：\n    - x = `[1, 2, 3, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 1, 3, 5]`\n    - y = `[1.6, 1.8, 2.8, 3.3, 3.7, 4.29, 4.71, 5.28, 5.72, 2.5, -1.0, 4.0]`\n    - groups = `[\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"C\", \"C\", \"C\"]`\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例贡献一个形式如下的列表：\n$[\\text{hetero}, \\text{OLS\\_slope\\_x}, \\text{WLS\\_slope\\_x}, \\text{OLS\\_gamma\\_B}, \\text{WLS\\_gamma\\_B}, \\text{OLS\\_gamma\\_C}, \\text{WLS\\_gamma\\_C}]$。\n此处 $\\text{hetero}$ 是一个布尔值（True 或 False），其余条目是四舍五入到 $6$ 位小数的浮点数。对于三个测试用例，程序必须打印如下单行：\n$[[\\ldots],[\\ldots],[\\ldots]]$。",
            "solution": "用户提供的问题已经过评估，是有效的。\n\n## 问题验证\n\n### 步骤 1：提取给定信息\n- **统计模型**：一个线性模型，包含响应变量 $y$、一个定量预测变量 $x$ 以及一个具有三个水平（$A$、$B$、$C$）的定性预测变量。\n- **模型假设**：加性误差 $\\varepsilon$，其期望为 $\\mathbb{E}[\\varepsilon] = 0$，误差不相关，并且在定性预测变量的各个水平之间可能存在非恒定方差（异方差性）。\n- **编码方案**：定性预测变量使用虚拟变量进行编码，其中水平 $A$ 被指定为参考水平。\n- **任务**：\n    1. 构建设计矩阵 $X$，包含截距、预测变量 $x$ 以及水平 $B$ 和 $C$ 的虚拟变量。\n    2. 计算普通最小二乘法（OLS）估计值 $\\hat{\\beta}_{\\text{OLS}}$。\n    3. 计算残差 $r = y - X\\hat{\\beta}_{\\text{OLS}}$。\n    4. 对每个水平 $g \\in \\{A,B,C\\}$，估计水平特定的方差 $\\hat{\\sigma}^2_g$，即该水平内残差平方的均值。\n    5. 通过计算比率 $R = \\max_g \\hat{\\sigma}^2_g \\,/\\, \\min_g \\hat{\\sigma}^2_g$ 并检查是否 $R  \\tau$ 来诊断异方差性。\n    6. 如果存在异方差性（$R  \\tau$），则使用权重 $w_i = 1 / \\hat{\\sigma}^2_{g(i)}$ 执行加权最小二乘法（WLS）。如果不存在，则将所有权重 $w_i$ 设置为 1。计算 WLS 估计值。\n    7. 从 OLS 和 WLS 估计中提取 $x$ 的斜率以及水平 $B$ 和 $C$ 的虚拟系数。\n- **常数和参数**：异方差性阈值 $\\tau = 1.5$。\n- **数据**：提供了三个测试用例，每个测试用例包含一个元组 $(x, y, \\text{groups})$，其中 $x$ 和 $y$ 是数字列表，而 $\\text{groups}$ 是字符串（\"A\"、\"B\"、\"C\"）列表。\n- **输出要求**：所有浮点数结果必须四舍五入到 $6$ 位小数。最终输出必须是一个单行字符串，表示一个列表的列表，其中每个内部列表包含一个测试用例的结果。\n\n### 步骤 2：使用提取的给定信息进行验证\n- **科学依据**：该问题牢固地植根于标准的统计学和计量经济学理论。OLS 的使用、用于检测异方差性的残差分析以及作为纠正措施的 WLS 都是线性回归分析中的经典主题。OLS 和 WLS 的公式是应用于统计学的线性代数的基本原理。\n- **适定性**：该问题是适定的。每个测试用例的数据都已完全提供。分析步骤是按算法指定的，没有任何模糊之处。给定所提供的预测变量值，产生的设计矩阵是满列秩的，保证了 OLS 和 WLS 系数向量的唯一解。\n- **客观性**：问题以精确、客观的语言陈述。所有术语都是统计学领域的标准术语。\n\n### 步骤 3：结论与行动\n该问题在科学上是合理的、适定的、客观的，并包含唯一解所需的所有信息。因此，它被认为是**有效的**。将提供一个解决方案。\n\n## 解决方法论\n\n此问题要求实现一个标准统计工作流程，以处理同时包含定量和定性预测变量的线性回归模型中的异方差性问题。解决方案按照一系列明确的步骤进行，从模型设定和估计到诊断和校正。\n\n### 1. 模型设定和设计矩阵\n线性模型设定如下：\n$$\ny_i = \\beta_0 + \\beta_1 x_i + \\gamma_B D_{i,B} + \\gamma_C D_{i,C} + \\varepsilon_i\n$$\n此处，$y_i$ 和 $x_i$ 分别是响应变量和定量预测变量的第 $i$ 个观测值。$\\beta_0$ 是截距，表示在参考组（$A$）中当 $x=0$ 时 $y$ 的期望值。$\\beta_1$ 是定量预测变量 $x$ 的斜率系数。$D_{i,B}$ 和 $D_{i,C}$ 是定性预测变量水平的虚拟变量。\n- 如果观测值 $i$ 属于组 $B$，则 $D_{i,B} = 1$，否则为 $0$。\n- 如果观测值 $i$ 属于组 $C$，则 $D_{i,C} = 1$，否则为 $0$。\n对于参考组 $A$ 中的观测值， $D_{i,B}$ 和 $D_{i,C}$ 均为 $0$。\n系数 $\\gamma_B$ 和 $\\gamma_C$ 分别表示与组 $A$ 相比，观测值属于组 $B$ 或组 $C$ 对截距的差异效应。\n\n该模型可以表示为矩阵形式 $y = X\\beta + \\varepsilon$，其中 $y$ 是响应向量，$X$ 是设计矩阵，$\\beta$ 是系数向量，$\\varepsilon$ 是误差向量。对于 $N$ 个观测值，大小为 $N \\times 4$ 的设计矩阵 $X$ 构建如下：\n$$\nX = \\begin{bmatrix}\n1  x_1  D_{1,B}  D_{1,C} \\\\\n1  x_2  D_{2,B}  D_{2,C} \\\\\n\\vdots  \\vdots  \\vdots  \\vdots \\\\\n1  x_N  D_{N,B}  D_{N,C}\n\\end{bmatrix}\n\\quad \\text{和} \\quad\n\\beta = \\begin{bmatrix} \\beta_0 \\\\ \\beta_1 \\\\ \\gamma_B \\\\ \\gamma_C \\end{bmatrix}\n$$\n\n### 2. 普通最小二乘法（OLS）估计\n$\\beta$ 的 OLS 估计量，记为 $\\hat{\\beta}_{\\text{OLS}}$，通过最小化残差平方和 $\\sum r_i^2 = (y-X\\beta)^T(y-X\\beta)$ 求得。这产生了封闭形式的解：\n$$\n\\hat{\\beta}_{\\text{OLS}} = (X^T X)^{-1} X^T y\n$$\n\n### 3. 异方差性诊断\n获得 $\\hat{\\beta}_{\\text{OLS}}$ 后，我们计算残差向量 $r = y - X\\hat{\\beta}_{\\text{OLS}}$。异方差性意味着误差方差 $\\text{Var}(\\varepsilon_i) = \\sigma_i^2$ 在所有观测值上不是恒定的。在这个问题中，我们检验方差在组 $\\{A, B, C\\}$ 之间是否恒定。我们估计每个组 $g$ 的方差为该组内观测值的残差平方的均值：\n$$\n\\hat{\\sigma}^2_g = \\frac{1}{n_g} \\sum_{i \\in \\text{group } g} r_i^2\n$$\n其中 $n_g$ 是组 $g$ 中的观测值数量。\n\n一个简单的诊断工具是最大估计组方差与最小估计组方差的比率：\n$$\nR = \\frac{\\max(\\hat{\\sigma}^2_A, \\hat{\\sigma}^2_B, \\hat{\\sigma}^2_C)}{\\min(\\hat{\\sigma}^2_A, \\hat{\\sigma}^2_B, \\hat{\\sigma}^2_C)}\n$$\n如果该比率 $R$ 超过预定义阈值 $\\tau$，我们得出结论，存在显著的异方差性。对于此问题，$\\tau = 1.5$。\n\n### 4. 加权最小二乘法（WLS）估计\n如果检测到异方差性，OLS 估计量就不再是最佳线性无偏估计量（BLUE），尽管它仍然是无偏的。WLS 通过给予方差较大的观测值较小的权重，提供了一个更有效的估计量。WLS 估计量是：\n$$\n\\hat{\\beta}_{\\text{WLS}} = (X^T W X)^{-1} X^T W y\n$$\n其中 $W$ 是一个权重的对角矩阵。最优权重与误差方差成反比，$w_i = 1/\\sigma_i^2$。由于真实方差是未知的，我们使用它们的估计值。对于属于组 $g(i)$ 的观测值 $i$，权重被设置为 $w_i = 1/\\hat{\\sigma}^2_{g(i)}$。因此，权重矩阵 $W$ 是：\n$$\nW = \\text{diag}(w_1, w_2, \\ldots, w_N)\n$$\n如果没有检测到异方差性（$R \\le \\tau$），则指示我们使用单位权重，即对所有 $i$ 使用 $w_i = 1$。这使得 $W$ 成为单位矩阵 $I$，并且 WLS 估计量与 OLS 估计量相同：$\\hat{\\beta}_{\\text{WLS}} = (X^T I X)^{-1} X^T I y = \\hat{\\beta}_{\\text{OLS}}$。\n\n### 5. 提取系数\n每个测试用例的最后一步是从估计的向量 $\\hat{\\beta}_{\\text{OLS}}$ 和 $\\hat{\\beta}_{\\text{WLS}}$ 中提取相关系数。所需的系数是：\n- $x$ 的斜率：$\\hat{\\beta}_1$，即 $\\hat{\\beta}$ 向量的第二个元素。\n- 水平 $B$ 的虚拟系数：$\\hat{\\gamma}_B$，第三个元素。\n- 水平 $C$ 的虚拟系数：$\\hat{\\gamma}_C$，第四个元素。\n这些值连同异方差性的布尔标志一起，被编译成最终的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of statistical learning problems involving OLS, heteroscedasticity\n    diagnosis, and WLS for a linear model with a qualitative predictor.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            [1, 2, 3, 4, 1.5, 2.5, 3.5, 4.5, 0.5, 1.5, 2.5, 3.5],\n            [3.7, 4.9, 6.6, 7.8, 5.75, 2.95, 7.95, 5.55, 4.25, 3.95, 7.0, 6.65],\n            [\"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"C\", \"C\", \"C\", \"C\"],\n        ),\n        (\n            [1, 2, 3, 4, 1.5, 2.5, 3.5, 4.5, 0.5, 1.5, 2.5, 3.5],\n            [3.8, 4.6, 6.7, 7.9, 3.45, 4.45, 6.35, 7.55, 3.5, 4.55, 6.4, 7.65],\n            [\"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"C\", \"C\", \"C\", \"C\"],\n        ),\n        (\n            [1, 2, 3, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 1, 3, 5],\n            [1.6, 1.8, 2.8, 3.3, 3.7, 4.29, 4.71, 5.28, 5.72, 2.5, -1.0, 4.0],\n            [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"C\", \"C\", \"C\"],\n        )\n    ]\n    \n    tau = 1.5\n    all_results = []\n    \n    for case in test_cases:\n        x_data, y_data, groups_data = case\n        \n        # Convert to numpy arrays for vectorized operations\n        x = np.array(x_data)\n        y = np.array(y_data)\n        groups = np.array(groups_data)\n        n_obs = len(y)\n        \n        # 1. Construct the design matrix X\n        X = np.zeros((n_obs, 4))\n        X[:, 0] = 1  # Intercept\n        X[:, 1] = x  # Quantitative predictor\n        X[:, 2] = (groups == \"B\").astype(int)  # Dummy for level B\n        X[:, 3] = (groups == \"C\").astype(int)  # Dummy for level C\n        \n        # 2. Compute the Ordinary Least Squares (OLS) estimate\n        try:\n            XTX_inv = np.linalg.inv(X.T @ X)\n            beta_ols = XTX_inv @ (X.T @ y)\n        except np.linalg.LinAlgError:\n            # This case should not occur with the given test data\n            # but is good practice for numerical stability.\n            all_results.append(None)\n            continue\n            \n        # 3. Compute residuals and estimate level-specific variances\n        residuals = y - X @ beta_ols\n        \n        group_indices = {\n            'A': np.where(groups == 'A')[0],\n            'B': np.where(groups == 'B')[0],\n            'C': np.where(groups == 'C')[0]\n        }\n        \n        group_variances = {}\n        for level, indices in group_indices.items():\n            if len(indices) > 0:\n                group_variances[level] = np.mean(residuals[indices]**2)\n            else:\n                 group_variances[level] = np.nan # Handle cases where a group might be empty\n        \n        valid_variances = [v for v in group_variances.values() if not np.isnan(v)]\n        \n        # 4. Diagnose heteroscedasticity\n        hetero_present = False\n        if len(valid_variances) > 1:\n            R = max(valid_variances) / min(valid_variances) if min(valid_variances) > 0 else float('inf')\n            if R > tau:\n                hetero_present = True\n\n        # 5. Perform WLS if heteroscedasticity is present\n        if hetero_present:\n            weights = np.ones(n_obs)\n            for level, var in group_variances.items():\n                if not np.isnan(var) and var > 0:\n                    weights[group_indices[level]] = 1.0 / var\n\n            W = np.diag(weights)\n            \n            try:\n                XTWX_inv = np.linalg.inv(X.T @ W @ X)\n                beta_wls = XTWX_inv @ (X.T @ W @ y)\n            except np.linalg.LinAlgError:\n                all_results.append(None)\n                continue\n        else:\n            # If not heteroscedastic, WLS is equivalent to OLS (with unit weights)\n            beta_wls = beta_ols\n            \n        # 6. Extract coefficients and round to 6 decimal places\n        ols_slope_x = round(beta_ols[1], 6)\n        wls_slope_x = round(beta_wls[1], 6)\n        ols_gamma_B = round(beta_ols[2], 6)\n        wls_gamma_B = round(beta_wls[2], 6)\n        ols_gamma_C = round(beta_ols[3], 6)\n        wls_gamma_C = round(beta_wls[3], 6)\n        \n        case_result = [\n            hetero_present,\n            ols_slope_x, wls_slope_x,\n            ols_gamma_B, wls_gamma_B,\n            ols_gamma_C, wls_gamma_C\n        ]\n        all_results.append(case_result)\n        \n    # Final print statement in the exact required format.\n    # Convert each inner list to its string representation\n    results_str = [str(res).replace(\"'\", \"\") for res in all_results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}