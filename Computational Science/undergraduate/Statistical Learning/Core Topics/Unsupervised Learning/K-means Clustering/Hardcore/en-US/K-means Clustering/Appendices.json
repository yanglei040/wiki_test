{
    "hands_on_practices": [
        {
            "introduction": "To truly master an algorithm, you must move beyond theory and get your hands dirty with code. This first practice challenges you to implement the foundational Lloyd's algorithm for $k$-means clustering from the ground up . By deriving its computational complexity and testing it on carefully designed datasets, you will gain a concrete understanding of its performance characteristics and see firsthand how data structure can dramatically influence convergence speed.",
            "id": "3134960",
            "problem": "Consider Lloyd’s algorithm for $k$-means clustering. The algorithm iterates two steps: an assignment step that maps each data point to the nearest centroid using the Euclidean distance in $\\mathbb{R}^d$, and an update step that recomputes each centroid as the arithmetic mean of the points currently assigned to its cluster. Let $n$ denote the number of points, $k$ the number of clusters, $d$ the dimension, and $t$ the number of iterations until convergence (defined as no change in assignments). The fundamental base for analysis should be the following well-tested facts: in each assignment step, for each of the $n$ points, the distance to each of the $k$ centroids in $\\mathbb{R}^d$ is computed using the Euclidean norm, and in each update step, each centroid is updated by computing the mean of the points assigned to it.\n\nTask:\n- Derive the computational complexity of one iteration of Lloyd’s algorithm starting from these facts and the definitions of Euclidean distance and arithmetic mean, and use this derivation to justify the asymptotic complexity $O(n k d t)$ for the total algorithm until convergence.\n- Implement Lloyd’s algorithm for $k$-means clustering as described above, using the Euclidean distance in $\\mathbb{R}^d$ and convergence based on unchanged assignments. In case any cluster becomes empty during an update, deterministically reinitialize that centroid to the data point that currently has the largest Euclidean distance to its assigned centroid (this maintains progress and avoids undefined means).\n- Build and run on the following deterministic test suite. All angles mentioned below must be interpreted in radians.\n\nTest suite:\n1. Adversarial circle datasets in $\\mathbb{R}^2$ intended to demonstrate slow convergence behavior, with $k=2$ and centroids initialized to two adjacent points on the unit circle to create a narrow initial decision boundary that migrates as the centroids move. For each $n \\in \\{16,32,64\\}$, construct $n$ points evenly spaced on the unit circle at angles $\\theta_i = \\frac{2\\pi i}{n}$ (for $i = 0,1,\\dots,n-1$), represented in Cartesian coordinates as $(\\cos\\theta_i,\\sin\\theta_i)$. Initialize centroids to the points at angles $\\theta_0 = 0$ and $\\theta_1 = \\frac{2\\pi}{n}$.\n2. A well-separated “happy path” dataset in $\\mathbb{R}^2$ intended to exhibit fast convergence, with $n=200$, $k=2$, formed by two isotropic Gaussian blobs: $100$ points sampled deterministically by seeding a pseudo-random number generator and taking a fixed sequence from a normal distribution centered at $(0,0)$ with variance $1$ in each coordinate, and $100$ points centered at $(10,10)$ with the same variance. Initialize centroids to the first two points of the dataset order to maintain determinism.\n3. An edge-case dataset in $\\mathbb{R}^1$ with repeated identical values, $n=9$, $k=3$, consisting of all points equal to $0$. Initialize centroids to $-1$, $0$, and $1$.\n\nFor each test case, run Lloyd’s algorithm until convergence and record:\n- The number of iterations $t$.\n- The product $n \\cdot k \\cdot d \\cdot t$ as an integer, which is a scalar reflecting the asymptotic operation count factor implied by the complexity derivation.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[t, n \\cdot k \\cdot d \\cdot t]$, in the same order as the test suite, for example, $[[t_1, n_1 k_1 d_1 t_1],[t_2, n_2 k_2 d_2 t_2],[t_3, n_3 k_3 d_3 t_3],[t_4, n_4 k_4 d_4 t_4]]$.\n\nNote: There are no physical units involved. All angles are specified in radians. The required outputs are integers or lists of integers, and the final output format must be precisely the single-line bracketed list described above.",
            "solution": "The user-provided problem is assessed to be valid as it is scientifically grounded in the well-established theory of k-means clustering, is well-posed with deterministic test cases, is objective, and contains no contradictions or ambiguities. It presents a standard but non-trivial task in algorithm analysis and implementation.\n\n### Part 1: Computational Complexity Derivation\n\nThe total computational complexity of Lloyd's algorithm is the product of the number of iterations, $t$, and the complexity of a single iteration. An iteration consists of two sequential steps: the assignment step and the update step. We derive the complexity of each step based on the provided a priori facts.\n\nLet $n$ be the number of data points, $k$ be the number of clusters, and $d$ be the dimension of the data space $\\mathbb{R}^d$.\n\n**Assignment Step Complexity**\n\nThe problem states that in the assignment step, \"for each of the $n$ points, the distance to each of the $k$ centroids in $\\mathbb{R}^d$ is computed using the Euclidean norm\".\n\n1.  **Distance Calculation**: The Euclidean distance between a data point $\\mathbf{x} = (x_1, \\dots, x_d)$ and a centroid $\\mathbf{c} = (c_1, \\dots, c_d)$ is given by $D(\\mathbf{x}, \\mathbf{c}) = \\sqrt{\\sum_{i=1}^{d} (x_i - c_i)^2}$. To compute this value, we perform:\n    *   $d$ subtractions ($x_i - c_i$).\n    *   $d$ multiplications (squaring).\n    *   $d-1$ additions (summation).\n    *   $1$ square root operation.\n    The total number of arithmetic operations is $d+d+(d-1)+1 = 3d$. Thus, the complexity of a single distance calculation is proportional to the dimension $d$, which is $O(d)$. Note that for the purpose of finding the *nearest* centroid, we can work with the squared Euclidean distance, $D^2(\\mathbf{x}, \\mathbf{c}) = \\sum_{i=1}^{d} (x_i - c_i)^2$, which avoids the computationally more expensive square root operation but has the same $O(d)$ complexity.\n\n2.  **Total Assignment Cost**: For each of the $n$ data points, we compute its distance to all $k$ centroids. This requires $n \\times k$ distance calculations. The total cost for all distance calculations is therefore $n \\times k \\times O(d) = O(nkd)$.\n\n3.  **Finding the Minimum**: For each data point, after computing its distances to the $k$ centroids, we must find the minimum of these $k$ values to determine the assignment. This requires $k-1$ comparisons, an operation of complexity $O(k)$. Since this must be done for all $n$ points, the total complexity for finding all minima is $n \\times O(k) = O(nk)$.\n\n4.  **Overall Assignment Complexity**: The total complexity of the assignment step is the sum of the costs of distance calculations and finding the minima: $O(nkd) + O(nk)$. Since $d \\ge 1$, the $O(nkd)$ term dominates. Therefore, the complexity of the assignment step is $O(nkd)$.\n\n**Update Step Complexity**\n\nThe problem states that in the update step, \"each centroid is updated by computing the mean of the points assigned to it\".\n\n1.  **Mean Calculation**: Let cluster $j$ contain $n_j$ points, denoted $\\{\\mathbf{x}_{j,1}, \\dots, \\mathbf{x}_{j, n_j}\\}$. The new centroid $\\mathbf{c}_j'$ is their arithmetic mean: $\\mathbf{c}_j' = \\frac{1}{n_j} \\sum_{i=1}^{n_j} \\mathbf{x}_{j,i}$.\n    *   To compute the sum $\\sum_{i=1}^{n_j} \\mathbf{x}_{j,i}$, we are summing $n_j$ vectors, each of dimension $d$. This requires $(n_j - 1) \\times d$ additions. The complexity is $O(n_j d)$.\n    *   To compute the final mean, we divide the resulting sum vector by the scalar $n_j$. This involves $d$ divisions, an operation of complexity $O(d)$.\n    *   The total complexity to update one centroid for cluster $j$ is $O(n_j d) + O(d) = O(n_j d)$.\n\n2.  **Total Update Cost**: We must perform this update for all $k$ clusters. The total complexity is the sum of the costs for each cluster: $\\sum_{j=1}^{k} O(n_j d)$. This can be written as $O(d \\sum_{j=1}^{k} n_j)$.\n    Since each of the $n$ data points is assigned to exactly one cluster, the sum of the number of points in all clusters is equal to the total number of points: $\\sum_{j=1}^{k} n_j = n$.\n    Therefore, the complexity of the update step is $O(nd)$.\n\nThe special rule for handling empty clusters requires finding the data point with the largest distance to its assigned centroid. This involves a scan through $n$ pre-computed distances, which is an $O(n)$ operation. This cost is incurred only if a cluster is empty and is dominated by the $O(nd)$ cost of the standard update process (since $d \\ge 1$), so it does not alter the asymptotic complexity of the update step.\n\n**Total Complexity**\n\nThe complexity of a single iteration of Lloyd's algorithm is the sum of the complexities of the assignment and update steps:\n$$ C_{\\text{iteration}} = C_{\\text{assignment}} + C_{\\text{update}} = O(nkd) + O(nd) $$\nSince $k \\ge 1$, the term $O(nkd)$ dominates $O(nd)$. Thus, the complexity of one iteration is $O(nkd)$.\n\nIf the algorithm runs for $t$ iterations until convergence, the total computational complexity is:\n$$ C_{\\text{total}} = t \\times C_{\\text{iteration}} = t \\times O(nkd) = O(nkdt) $$\nThis justifies the asymptotic complexity of $O(nkdt)$ for the entire algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef lloyds_algorithm(data, k, initial_centroids):\n    \"\"\"\n    Performs k-means clustering using Lloyd's algorithm.\n\n    Args:\n        data (np.ndarray): The dataset of shape (n, d).\n        k (int): The number of clusters.\n        initial_centroids (np.ndarray): The initial centroids of shape (k, d).\n\n    Returns:\n        int: The number of iterations 't' until convergence.\n    \"\"\"\n    n, d = data.shape\n    centroids = np.copy(initial_centroids)\n    # Initialize assignments with a sentinel value that won't match any valid assignment\n    assignments = np.full(n, -1, dtype=int)\n    \n    t = 0\n    while True:\n        # --- Assignment Step ---\n        # Compute squared Euclidean distances from each point to each centroid\n        # cdist is efficient for this. 'sqeuclidean' avoids sqrt calculation.\n        dist_sq = cdist(data, centroids, 'sqeuclidean')\n        \n        # Assign each point to the closest centroid\n        # np.argmin handles ties by picking the first occurrence.\n        new_assignments = np.argmin(dist_sq, axis=1)\n        \n        # --- Convergence Check ---\n        # If assignments have not changed, the algorithm has converged.\n        if np.array_equal(new_assignments, assignments):\n            break\n            \n        assignments = new_assignments\n        \n        # --- Update Step ---\n        \n        # Per problem spec, find the point to use for reinitializing empty clusters.\n        # This is the point with the largest distance to ITS OWN assigned centroid.\n        # We use the distances and assignments from the current step to find this point.\n        dists_to_assigned_centroids = dist_sq[np.arange(n), assignments]\n        farthest_point_idx = np.argmax(dists_to_assigned_centroids)\n        reinit_point = data[farthest_point_idx]\n        \n        new_centroids = np.zeros_like(centroids)\n        for j in range(k):\n            # Select all points assigned to the current cluster\n            cluster_points = data[assignments == j]\n            \n            # If the cluster is not empty, compute the mean\n            if len(cluster_points) > 0:\n                new_centroids[j] = np.mean(cluster_points, axis=0)\n            # If the cluster is empty, reinitialize its centroid\n            else:\n                new_centroids[j] = reinit_point\n\n        centroids = new_centroids\n        t += 1 # Increment iteration count after a full (assign + update) cycle\n\n    return t\n\ndef solve():\n    \"\"\"\n    Generates test cases, runs Lloyd's algorithm, and prints the results.\n    \"\"\"\n    test_cases = []\n    \n    # Test Suite Part 1: Adversarial circle datasets\n    k1 = 2\n    d1 = 2\n    for n1 in [16, 32, 64]:\n        thetas = 2 * np.pi * np.arange(n1) / n1\n        points = np.column_stack([np.cos(thetas), np.sin(thetas)])\n        \n        # Initial centroids at angles 0 and 2*pi/n\n        c_theta_0 = 0.0\n        c_theta_1 = 2 * np.pi / n1\n        initial_centroids = np.array([\n            [np.cos(c_theta_0), np.sin(c_theta_0)],\n            [np.cos(c_theta_1), np.sin(c_theta_1)]\n        ])\n        test_cases.append({\n            \"name\": f\"Circle n={n1}\",\n            \"data\": points, \"k\": k1, \"d\": d1, \"n\": n1,\n            \"initial_centroids\": initial_centroids\n        })\n\n    # Test Suite Part 2: Well-separated Gaussian blobs\n    n2 = 200\n    k2 = 2\n    d2 = 2\n    np.random.seed(0) # For deterministic results\n    blob1 = np.random.normal(loc=0.0, scale=1.0, size=(100, d2))\n    blob2 = np.random.normal(loc=10.0, scale=1.0, size=(100, d2))\n    points2 = np.vstack([blob1, blob2])\n    # Initialize centroids to the first two points of the dataset\n    initial_centroids2 = points2[:k2]\n    test_cases.append({\n        \"name\": \"Gaussians\",\n        \"data\": points2, \"k\": k2, \"d\": d2, \"n\": n2,\n        \"initial_centroids\": initial_centroids2\n    })\n    \n    # Test Suite Part 3: Edge-case with identical points\n    n3 = 9\n    k3 = 3\n    d3 = 1\n    points3 = np.zeros((n3, d3))\n    initial_centroids3 = np.array([[-1.0], [0.0], [1.0]])\n    test_cases.append({\n        \"name\": \"Edge-case\",\n        \"data\": points3, \"k\": k3, \"d\": d3, \"n\": n3,\n        \"initial_centroids\": initial_centroids3\n    })\n    \n    results = []\n    for case in test_cases:\n        t = lloyds_algorithm(case[\"data\"], case[\"k\"], case[\"initial_centroids\"])\n        n, k, d = case[\"n\"], case[\"k\"], case[\"d\"]\n        product = n * k * d * t\n        results.append([t, product])\n    \n    # The final print statement must produce the exact required format.\n    # str() on a list of lists creates a string like '[[...], [...]]'\n    # .replace(\" \", \"\") removes spaces to match the required dense format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world data is rarely composed of just one data type. This practice explores how to apply $k$-means to mixed datasets containing both numerical and categorical features using one-hot encoding . You will investigate how a scaling factor, $\\alpha$, applied to the encoded categorical variables can alter the geometry of the feature space, effectively changing the 'importance' of categorical versus numerical attributes and directly influencing the final cluster assignments.",
            "id": "3134973",
            "problem": "Consider a dataset consisting of points with one real-valued feature and one categorical feature. The categorical feature takes one of three values: A, B, or C. You will represent the categorical feature using one-hot encoding with a scaling factor $\\,\\alpha\\,$ applied to each dummy variable. That is, for category A, use the one-hot vector $[1,0,0]$; for category B, $[0,1,0]$; for category C, $[0,0,1]$, and then multiply this vector by $\\,\\alpha\\,$. The real-valued feature is kept unscaled. The full encoded feature vector for a point is the concatenation of the real-valued feature (first component) and the $\\,\\alpha$-scaled one-hot vector (remaining components).\n\nBase definitions to use:\n- Euclidean distance in $\\mathbb{R}^d$ between two vectors $\\,\\mathbf{x}\\,$ and $\\,\\mathbf{y}\\,$ is given by $\\,\\|\\mathbf{x}-\\mathbf{y}\\|_2\\,$, and the squared Euclidean distance is $\\,\\|\\mathbf{x}-\\mathbf{y}\\|_2^2\\,$.\n- The $\\,k$-means objective $\\,J\\,$ for $\\,k\\,$ clusters with centroids $\\,\\{\\boldsymbol{\\mu}_j\\}_{j=1}^k\\,$ and an assignment function $\\,c(i)\\in\\{1,\\dots,k\\}\\,$ that maps each point index $\\,i\\,$ to its cluster is given by\n$$\nJ \\;=\\; \\sum_{i} \\big\\| \\mathbf{x}_i - \\boldsymbol{\\mu}_{c(i)} \\big\\|_2^2.\n$$\nThe centroid of a cluster is defined as the arithmetic mean of the feature vectors assigned to that cluster.\n\nYour task is to analyze how the scaling $\\,\\alpha\\,$ of the categorical one-hot dummy variables affects Euclidean distances and the $\\,k$-means objective $\\,J\\,$ under a single Lloyd iteration (assignment step followed by centroid recomputation, but without repeating).\n\nUse the following dataset of $\\,6\\,$ points. Each point has a real-valued component and a categorical label:\n- Point $\\,0\\,$: real-valued $\\,0.0\\,$, category A.\n- Point $\\,1\\,$: real-valued $\\,0.3\\,$, category A.\n- Point $\\,2\\,$: real-valued $\\,0.9\\,$, category A.\n- Point $\\,3\\,$: real-valued $\\,1.2\\,$, category B.\n- Point $\\,4\\,$: real-valued $\\,0.6\\,$, category C.\n- Point $\\,5\\,$: real-valued $\\,1.0\\,$, category C.\n\nEncode categories using the one-hot order $[A,B,C]$.\n\nPerform the following for each specified value of $\\,\\alpha\\,$ in the test suite:\n1. Build the encoded dataset using the above scheme (real-valued feature first, then $\\,\\alpha$-scaled one-hot).\n2. Initialize $\\,k=2\\,$ centroids as the encoded vectors of point $\\,0\\,$ and point $\\,5\\,$ respectively.\n3. Assign each point to the nearest centroid using the squared Euclidean distance to avoid unnecessary square roots; if distances are exactly equal, break ties by choosing the centroid with the smaller index.\n4. Recompute the centroids as the mean of the points assigned to each cluster in the encoded feature space.\n5. Compute the $\\,k$-means objective $\\,J\\,$ as the sum of squared Euclidean distances from each point to its recomputed cluster centroid.\n6. Compute the Euclidean distance $\\,\\|\\mathbf{x}_1 - \\mathbf{x}_4\\|_2\\,$ between the encoded vectors for point $\\,1\\,$ and point $\\,4\\,$.\n\nTest suite for $\\,\\alpha\\,$:\n- $\\,\\alpha = 0.0\\,$,\n- $\\,\\alpha = 0.5\\,$,\n- $\\,\\alpha = 1.0\\,$,\n- $\\,\\alpha = 1.5\\,$.\n\nYour program should output a single line containing the results for the test suite as a list of pairs, where each pair contains two floating-point numbers $[d, J]$, with $\\,d\\,$ being the Euclidean distance $\\,\\|\\mathbf{x}_1 - \\mathbf{x}_4\\|_2\\,$ for the given $\\,\\alpha\\,$ and $\\,J\\,$ being the corresponding $\\,k$-means objective after the single Lloyd iteration for that $\\,\\alpha\\,$. The final output format must be a single line in the form\n$$\n[[d_0,J_0],[d_1,J_1],[d_2,J_2],[d_3,J_3]]\n$$\ncorresponding to $\\,\\alpha\\,$ values in the given order. Express each floating-point number rounded to six decimal places. No external input should be read, and no physical units or angles are involved in this problem.",
            "solution": "The user wants me to solve a k-means clustering problem.\n\n### Step 1: Validation of the Problem Statement\nI will first validate the problem statement according to the specified rules.\n\n#### Step 1.1: Extract Givens\n- **Dataset**: 6 points, each with a real-valued feature and a categorical feature (A, B, or C).\n    - Point 0: real-valued $0.0$, category A.\n    - Point 1: real-valued $0.3$, category A.\n    - Point 2: real-valued $0.9$, category A.\n    - Point 3: real-valued $1.2$, category B.\n    - Point 4: real-valued $0.6$, category C.\n    - Point 5: real-valued $1.0$, category C.\n- **Feature Encoding**:\n    - A point with real value $r$ and a category is encoded into a vector.\n    - Categorical feature is one-hot encoded with order [A, B, C].\n        - A: $[1,0,0]$\n        - B: $[0,1,0]$\n        - C: $[0,0,1]$\n    - The one-hot vector is scaled by a factor $\\alpha$.\n    - The final feature vector is the concatenation of the real feature and the scaled one-hot vector: $[r, \\alpha \\cdot \\text{one-hot}]$.\n- **Distance Metric**: Squared Euclidean distance $\\|\\mathbf{x}-\\mathbf{y}\\|_2^2$ for assignments. Final distance $\\|\\mathbf{x}_1-\\mathbf{x}_4\\|_2$ is Euclidean.\n- **k-means Algorithm**:\n    - $k=2$.\n    - Objective function: $J = \\sum_{i} \\| \\mathbf{x}_i - \\boldsymbol{\\mu}_{c(i)} \\|_2^2$.\n    - Initial centroids: Encoded vectors of point 0 and point 5.\n    - Process: A single Lloyd iteration (one assignment step, one centroid recomputation step).\n    - Tie-breaking: If distances to centroids are equal, assign to the centroid with the smaller index.\n- **Tasks for each $\\alpha$**:\n    1. Build the encoded dataset.\n    2. Initialize centroids.\n    3. Assign points to nearest centroid.\n    4. Recompute centroids.\n    5. Compute the final k-means objective $J$.\n    6. Compute the distance $d = \\|\\mathbf{x}_1 - \\mathbf{x}_4\\|_2$.\n- **Test Suite**: $\\alpha \\in \\{0.0, 0.5, 1.0, 1.5\\}$.\n- **Output Format**: A list of $[d, J]$ pairs, `[[d_0,J_0],[d_1,J_1],[d_2,J_2],[d_3,J_3]]`, with numbers rounded to six decimal places.\n\n#### Step 1.2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on standard concepts in machine learning and linear algebra, specifically k-means clustering, one-hot encoding, and Euclidean distance. The definitions and procedures are standard and correct.\n- **Well-Posed**: The problem is fully specified. The dataset, encoding scheme, initial conditions, and algorithm steps are all defined without ambiguity. A unique solution exists for each value of $\\alpha$.\n- **Objective**: The problem statement is written in precise, objective language. It requests a specific, verifiable calculation.\n- The problem does not violate any of the invalidity criteria. It is a well-defined computational task within the field of statistical learning.\n\n#### Step 1.3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Step 2: Solution\nThe solution is a step-by-step calculation for a general $\\alpha$, which is then applied to the specific values in the test suite.\n\n#### 2.1 Feature Vector Encoding\nA point with real value $r$ and a category is represented as a $4$-dimensional vector $\\mathbf{x} = [r, \\alpha v_1, \\alpha v_2, \\alpha v_3]$, where $[v_1, v_2, v_3]$ is the one-hot vector for the category in the order [A, B, C].\n\nThe dataset is encoded as follows:\n- $\\mathbf{x}_0 = [0.0, \\alpha, 0, 0]$\n- $\\mathbf{x}_1 = [0.3, \\alpha, 0, 0]$\n- $\\mathbf{x}_2 = [0.9, \\alpha, 0, 0]$\n- $\\mathbf{x}_3 = [1.2, 0, \\alpha, 0]$\n- $\\mathbf{x}_4 = [0.6, 0, 0, \\alpha]$\n- $\\mathbf{x}_5 = [1.0, 0, 0, \\alpha]$\n\n#### 2.2 Single Lloyd Iteration\n\n**Initial Centroids**\nThe two initial centroids, $\\boldsymbol{\\mu}_1^{(0)}$ and $\\boldsymbol{\\mu}_2^{(0)}$, are initialized as the encoded vectors of point $0$ and point $5$.\n- $\\boldsymbol{\\mu}_1^{(0)} = \\mathbf{x}_0 = [0.0, \\alpha, 0, 0]$\n- $\\boldsymbol{\\mu}_2^{(0)} = \\mathbf{x}_5 = [1.0, 0, 0, \\alpha]$\n\n**Assignment Step**\nEach point $\\mathbf{x}_i$ is assigned to the cluster corresponding to the closer centroid, using squared Euclidean distance.\n\n- For $\\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_3, \\mathbf{x}_4, \\mathbf{x}_5$, the assignment is independent of $\\alpha$:\n    - $\\mathbf{x}_0$: $\\|\\mathbf{x}_0 - \\boldsymbol{\\mu}_1^{(0)}\\|_2^2 = 0$. Assigned to Cluster $1$.\n    - $\\mathbf{x}_1$: $\\|\\mathbf{x}_1 - \\boldsymbol{\\mu}_1^{(0)}\\|_2^2 = (0.3)^2 = 0.09$. $\\|\\mathbf{x}_1 - \\boldsymbol{\\mu}_2^{(0)}\\|_2^2 = (-0.7)^2 + \\alpha^2 + (-\\alpha)^2 = 0.49 + 2\\alpha^2$. Assigned to Cluster $1$.\n    - $\\mathbf{x}_3$: $\\|\\mathbf{x}_3 - \\boldsymbol{\\mu}_1^{(0)}\\|_2^2 = (1.2)^2 + (-\\alpha)^2 + \\alpha^2 = 1.44 + 2\\alpha^2$. $\\|\\mathbf{x}_3 - \\boldsymbol{\\mu}_2^{(0)}\\|_2^2 = (0.2)^2 + \\alpha^2 + (-\\alpha)^2 = 0.04 + 2\\alpha^2$. Assigned to Cluster $2$.\n    - $\\mathbf{x}_4$: $\\|\\mathbf{x}_4 - \\boldsymbol{\\mu}_1^{(0)}\\|_2^2 = (0.6)^2 + (-\\alpha)^2 + \\alpha^2 = 0.36 + 2\\alpha^2$. $\\|\\mathbf{x}_4 - \\boldsymbol{\\mu}_2^{(0)}\\|_2^2 = (-0.4)^2 = 0.16$. Assigned to Cluster $2$.\n    - $\\mathbf{x}_5$: $\\|\\mathbf{x}_5 - \\boldsymbol{\\mu}_2^{(0)}\\|_2^2 = 0$. Assigned to Cluster $2$.\n\n- For $\\mathbf{x}_2 = [0.9, \\alpha, 0, 0]$, the assignment depends on $\\alpha$:\n    - $\\|\\mathbf{x}_2 - \\boldsymbol{\\mu}_1^{(0)}\\|_2^2 = (0.9)^2 = 0.81$.\n    - $\\|\\mathbf{x}_2 - \\boldsymbol{\\mu}_2^{(0)}\\|_2^2 = (0.9-1.0)^2 + \\alpha^2 + (-\\alpha)^2 = (-0.1)^2 + 2\\alpha^2 = 0.01 + 2\\alpha^2$.\n    - We compare $0.81$ with $0.01 + 2\\alpha^2$. The assignment goes to Cluster $1$ if $0.81 \\le 0.01 + 2\\alpha^2$, and to Cluster $2$ otherwise.\n    - $0.81 \\le 0.01 + 2\\alpha^2 \\implies 0.80 \\le 2\\alpha^2 \\implies 0.4 \\le \\alpha^2$.\n    - Thus, $\\mathbf{x}_2$ is assigned to Cluster $1$ if $\\alpha^2 \\ge 0.4$ and to Cluster $2$ if $\\alpha^2 < 0.4$.\n\nThe test values are $\\alpha \\in \\{0.0, 0.5, 1.0, 1.5\\}$.\n- For $\\alpha=0.0$, $\\alpha^2 = 0.0 < 0.4$.\n- For $\\alpha=0.5$, $\\alpha^2 = 0.25 < 0.4$.\n- For $\\alpha=1.0$, $\\alpha^2 = 1.0 \\ge 0.4$.\n- For $\\alpha=1.5$, $\\alpha^2 = 2.25 \\ge 0.4$.\n\nThis defines two scenarios for the cluster assignments.\n\n**Update Step (Centroid Recomputation)**\n\n- **Scenario 1: $\\alpha^2 < 0.4$ (for $\\alpha=0.0, 0.5$)**\n    - Cluster $1$: $\\{\\mathbf{x}_0, \\mathbf{x}_1\\}$\n    - Cluster $2$: $\\{\\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4, \\mathbf{x}_5\\}$\n    - New centroids:\n        - $\\boldsymbol{\\mu}_1^{(1)} = \\frac{1}{2}(\\mathbf{x}_0 + \\mathbf{x}_1) = \\frac{1}{2}[0.3, 2\\alpha, 0, 0] = [0.15, \\alpha, 0, 0]$\n        - $\\boldsymbol{\\mu}_2^{(1)} = \\frac{1}{4}(\\mathbf{x}_2+\\mathbf{x}_3+\\mathbf{x}_4+\\mathbf{x}_5) = \\frac{1}{4}[3.7, \\alpha, \\alpha, 2\\alpha] = [0.925, 0.25\\alpha, 0.25\\alpha, 0.5\\alpha]$\n\n- **Scenario 2: $\\alpha^2 \\ge 0.4$ (for $\\alpha=1.0, 1.5$)**\n    - Cluster $1$: $\\{\\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2\\}$\n    - Cluster $2$: $\\{\\mathbf{x}_3, \\mathbf{x}_4, \\mathbf{x}_5\\}$\n    - New centroids:\n        - $\\boldsymbol{\\mu}_1^{(1)} = \\frac{1}{3}(\\mathbf{x}_0+\\mathbf{x}_1+\\mathbf{x}_2) = \\frac{1}{3}[1.2, 3\\alpha, 0, 0] = [0.4, \\alpha, 0, 0]$\n        - $\\boldsymbol{\\mu}_2^{(1)} = \\frac{1}{3}(\\mathbf{x}_3+\\mathbf{x}_4+\\mathbf{x}_5) = \\frac{1}{3}[2.8, 0, \\alpha, 2\\alpha] = [\\frac{2.8}{3}, 0, \\frac{\\alpha}{3}, \\frac{2\\alpha}{3}]$\n\n#### 2.3 Calculation of Required Outputs\n\n**Euclidean Distance $d = \\|\\mathbf{x}_1 - \\mathbf{x}_4\\|_2$**\nThis distance depends only on the encoding, not the clustering result.\n- $\\mathbf{x}_1 - \\mathbf{x}_4 = [0.3-0.6, \\alpha-0, 0-0, 0-\\alpha] = [-0.3, \\alpha, 0, -\\alpha]$\n- $d^2 = \\|\\mathbf{x}_1 - \\mathbf{x}_4\\|_2^2 = (-0.3)^2 + \\alpha^2 + 0^2 + (-\\alpha)^2 = 0.09 + 2\\alpha^2$\n- $d = \\sqrt{0.09 + 2\\alpha^2}$\n\n**k-means Objective $J$**\nThe objective $J$ is the sum of squared distances from each point to its new centroid $\\boldsymbol{\\mu}_{c(i)}^{(1)}$.\n\n- **Scenario 1 ($J_1$ for $\\alpha^2 < 0.4$):**\n    - Sum of squared distances for Cluster $1$: $\\|\\mathbf{x}_0 - \\boldsymbol{\\mu}_1^{(1)}\\|_2^2 + \\|\\mathbf{x}_1 - \\boldsymbol{\\mu}_1^{(1)}\\|_2^2 = (0.0-0.15)^2 + (0.3-0.15)^2 = 0.0225 + 0.0225 = 0.045$.\n    - Sum of squared distances for Cluster $2$: This is the sum of variances of the components. A more direct calculation yields $\\sum_{i \\in C_2} \\|\\mathbf{x}_i - \\boldsymbol{\\mu}_2^{(1)}\\|_2^2 = 0.1875 + 2.5\\alpha^2$.\n    - $J_1 = 0.045 + 0.1875 + 2.5\\alpha^2 = 0.2325 + 2.5\\alpha^2$.\n\n- **Scenario 2 ($J_2$ for $\\alpha^2 \\ge 0.4$):**\n    - Sum of squared distances for Cluster $1$: $\\|\\mathbf{x}_0 - \\boldsymbol{\\mu}_1^{(1)}\\|_2^2 + \\|\\mathbf{x}_1 - \\boldsymbol{\\mu}_1^{(1)}\\|_2^2 + \\|\\mathbf{x}_2 - \\boldsymbol{\\mu}_1^{(1)}\\|_2^2 = (0.0-0.4)^2 + (0.3-0.4)^2 + (0.9-0.4)^2 = 0.16 + 0.01 + 0.25 = 0.42$.\n    - Sum of squared distances for Cluster $2$: $\\sum_{i \\in C_2} \\|\\mathbf{x}_i - \\boldsymbol{\\mu}_2^{(1)}\\|_2^2 = \\frac{1}{3}(0.56 + 4\\alpha^2)$.\n    - $J_2 = 0.42 + \\frac{0.56 + 4\\alpha^2}{3}$.\n\n#### 2.4 Final Computations for Test Suite\n\n- **For $\\alpha = 0.0$:** (Scenario 1)\n    - $d = \\sqrt{0.09 + 2(0.0)^2} = \\sqrt{0.09} = 0.3$.\n    - $J = 0.2325 + 2.5(0.0)^2 = 0.2325$.\n    - Result: $[0.300000, 0.232500]$\n\n- **For $\\alpha = 0.5$:** (Scenario 1)\n    - $d = \\sqrt{0.09 + 2(0.5)^2} = \\sqrt{0.09 + 0.5} = \\sqrt{0.59} \\approx 0.768115$.\n    - $J = 0.2325 + 2.5(0.5)^2 = 0.2325 + 0.625 = 0.8575$.\n    - Result: $[0.768115, 0.857500]$\n\n- **For $\\alpha = 1.0$:** (Scenario 2)\n    - $d = \\sqrt{0.09 + 2(1.0)^2} = \\sqrt{2.09} \\approx 1.445683$.\n    - $J = 0.42 + \\frac{0.56 + 4(1.0)^2}{3} = 0.42 + \\frac{4.56}{3} = 0.42 + 1.52 = 1.94$.\n    - Result: $[1.445683, 1.940000]$\n\n- **For $\\alpha = 1.5$:** (Scenario 2)\n    - $d = \\sqrt{0.09 + 2(1.5)^2} = \\sqrt{0.09 + 4.5} = \\sqrt{4.59} \\approx 2.142429$.\n    - $J = 0.42 + \\frac{0.56 + 4(1.5)^2}{3} = 0.42 + \\frac{0.56 + 9}{3} = 0.42 + \\frac{9.56}{3} \\approx 0.42 + 3.186667 = 3.606667$.\n    - Result: $[2.142429, 3.606667]$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a single Lloyd iteration for k-means clustering on a mixed-type dataset\n    for various scaling factors of the categorical features.\n    \"\"\"\n    # Define the dataset of points with a real value and a categorical label.\n    raw_data = [\n        (0.0, 'A'), (0.3, 'A'), (0.9, 'A'),\n        (1.2, 'B'), (0.6, 'C'), (1.0, 'C')\n    ]\n\n    # Map categories to one-hot vectors based on the order [A, B, C].\n    categories = {'A': np.array([1, 0, 0]), 'B': np.array([0, 1, 0]), 'C': np.array([0, 0, 1])}\n    \n    # Test suite of scaling factors for the one-hot encoded features.\n    alphas = [0.0, 0.5, 1.0, 1.5]\n\n    final_results = []\n\n    for alpha in alphas:\n        # Step 1: Build the encoded dataset.\n        # The feature vector is [real_value, alpha * one_hot_vector].\n        encoded_data = []\n        for r_val, cat in raw_data:\n            scaled_one_hot = alpha * categories[cat]\n            point = np.concatenate(([r_val], scaled_one_hot))\n            encoded_data.append(point)\n        X = np.array(encoded_data)\n\n        # Step 2: Initialize k=2 centroids using point 0 and point 5.\n        initial_centroids = np.array([X[0], X[5]])\n\n        # Step 3: Assign each point to the nearest centroid.\n        # Tie-breaking: assign to the centroid with the smaller index (0).\n        assignments = []\n        for point in X:\n            dist_sq_0 = np.sum((point - initial_centroids[0])**2)\n            dist_sq_1 = np.sum((point - initial_centroids[1])**2)\n            if dist_sq_0 = dist_sq_1:\n                assignments.append(0)\n            else:\n                assignments.append(1)\n        assignments = np.array(assignments)\n\n        # Step 4: Recompute the centroids as the mean of assigned points.\n        cluster_0_points = X[assignments == 0]\n        cluster_1_points = X[assignments == 1]\n        \n        new_centroids = np.zeros_like(initial_centroids)\n        # Ensure clusters are not empty before computing mean.\n        if len(cluster_0_points) > 0:\n            new_centroids[0] = np.mean(cluster_0_points, axis=0)\n        if len(cluster_1_points) > 0:\n            new_centroids[1] = np.mean(cluster_1_points, axis=0)\n\n        # Step 5: Compute the k-means objective J.\n        # J is the sum of squared Euclidean distances to the new centroids.\n        J = 0.0\n        if len(cluster_0_points) > 0:\n            J += np.sum((cluster_0_points - new_centroids[0])**2)\n        if len(cluster_1_points) > 0:\n            J += np.sum((cluster_1_points - new_centroids[1])**2)\n\n        # Step 6: Compute the Euclidean distance between encoded points 1 and 4.\n        d = np.linalg.norm(X[1] - X[4])\n\n        final_results.append([d, J])\n\n    # Format the final output string as specified.\n    # [[d_0,J_0],[d_1,J_1],...] with values rounded to six decimal places.\n    result_strings = []\n    for d, J in final_results:\n        result_strings.append(f\"[{d:.6f},{J:.6f}]\")\n    \n    output_string = f\"[{','.join(result_strings)}]\"\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Standard $k$-means treats every data point with equal importance, but what if some points are more significant than others? This advanced practice guides you through the theory and implementation of weighted $k$-means, an important extension of the algorithm . You will derive the modified centroid update rule directly from the objective function and demonstrate its equivalence to the intuitive concept of data point duplication, solidifying your understanding of how the algorithm's core mathematics dictates its behavior.",
            "id": "3134938",
            "problem": "Design and implement a program that formalizes and tests the effect of point multiplicity in the context of $k$-means clustering. Begin from core definitions and derive how assigning multiplicities to data points can be represented either by integer replication of those points or by nonnegative weights. Then implement the corresponding algorithms to validate the equivalence and to measure centroid drift as weights vary.\n\nFundamental base:\n- Use the standard $k$-means objective on a finite dataset $\\{x_i\\}_{i=1}^n \\subset \\mathbb{R}^d$, defined by minimizing the within-cluster sum of squared distances, with hard assignments $r_{ik} \\in \\{0,1\\}$ such that $\\sum_{k=1}^K r_{ik} = 1$ for each $i$.\n- Use the squared Euclidean norm and standard principles from multivariable calculus, including setting gradients to zero to find minimizers.\n- Use the interpretation that integer multiplicity corresponds to repeating a data point an integer number of times.\n\nTasks:\n- From the objective with nonnegative weights $\\{w_i\\}_{i=1}^n$, derive the centroid update rule that minimizes the objective for fixed assignments. Justify each step using the above fundamental base, without using any pre-stated final formula or shortcut. Explain why hard cluster assignment does not depend on $\\{w_i\\}$ when distances are squared Euclidean.\n- Prove, using only the definitions and linearity of summation, that the weighted objective with integer $\\{w_i\\}$ is exactly equivalent to the unweighted objective on a dataset where each $x_i$ is duplicated $w_i$ times. Conclude that the centroid updates coincide in that case.\n- Implement deterministic procedures that, given a dataset, integer weights, and initial centroids, perform a single $k$-means assignment step followed by a centroid update, in both the weighted and the duplicated-unweighted formulations. Use squared Euclidean distances and do not randomize any aspect.\n\nTest suite and required outputs:\nImplement the following four test cases. For each, compute the specified result. The program must aggregate the four results into a single line of output containing a comma-separated list enclosed in square brackets, with no extra spaces.\n\n- Test case $1$ (single-cluster equivalence in $\\mathbb{R}^1$): Data $x_1 = 0$, $x_2 = 2$ with integer weights $w_1 = 3$, $w_2 = 1$. Compute the centroid once as a weighted update and once by duplicating $x_1$ three times and $x_2$ once, then taking the unweighted mean. Return a boolean indicating whether the absolute difference between the two centroids is less than $\\varepsilon = 10^{-12}$.\n\n- Test case $2$ (single-cluster equivalence in $\\mathbb{R}^2$ with a zero-weight edge case): Data $x_1 = (0,0)$, $x_2 = (2,2)$, $x_3 = (10,10)$ with integer weights $w_1 = 1$, $w_2 = 1$, $w_3 = 0$. Compute the centroid once as a weighted update and once by duplicating according to weights (note that zero-weight points are duplicated zero times). Return a boolean indicating whether the Euclidean norm of the difference between the two centroids is less than $\\varepsilon = 10^{-12}$.\n\n- Test case $3$ (single $k$-means iteration equivalence in $\\mathbb{R}^2$ with $K = 2$): Data points\n$x_1 = (0,0)$, $x_2 = (1,0)$, $x_3 = (0,1)$, $x_4 = (5,5)$, $x_5 = (6,5)$, $x_6 = (5,6)$\nwith integer weights\n$w_1 = 1$, $w_2 = 2$, $w_3 = 1$, $w_4 = 1$, $w_5 = 1$, $w_6 = 3$.\nUse fixed initial centroids $\\mu_1^{(0)} = (0,0)$ and $\\mu_2^{(0)} = (5,5)$. Perform one assignment step by minimizing squared Euclidean distance to the current centroids (note that this step does not depend on $\\{w_i\\}$), followed by one centroid update. Do this once using the weighted update with the original data and once using the unweighted update on the dataset where each $x_i$ is duplicated $w_i$ times. Return a boolean indicating whether the Euclidean norms of the differences between corresponding centroids are each less than $\\varepsilon = 10^{-12}$.\n\n- Test case $4$ (centroid drift as a single weight varies, $K = 1$): Consider $n = 5$ copies of the point $(0,0)$, each with unit weight $1$, and a single outlier at $(3,0)$ whose weight $w$ varies over the set $\\{0,1,2,5,10\\}$. For each specified $w$, compute the updated centroid for $K = 1$ (which reduces to a weighted mean of all points) and then compute the Euclidean distance from the origin to this centroid. Return the list of these five distances, each rounded to $6$ decimal places.\n\nFinal output format:\n- The program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. The elements, in order, must be: the boolean from Test case $1$, the boolean from Test case $2$, the boolean from Test case $3$, and the list from Test case $4$ (itself enclosed in square brackets, with comma-separated entries, no spaces). For example, the structure must be $[b_1,b_2,b_3,[d_1,d_2,d_3,d_4,d_5]]$, where $b_j$ are booleans and $d_j$ are floats formatted to exactly $6$ decimal places.\n\nImplementation constraints:\n- Use squared Euclidean distance throughout.\n- All integer weights are nonnegative.\n- Use a strict tolerance of $\\varepsilon = 10^{-12}$ for equality checks.\n- No randomness, no external inputs, and no file or network access are allowed.",
            "solution": "The user has provided a problem that requires the formalization, derivation, and implementation of weighted $k$-means clustering. The problem is well-defined, scientifically sound, and internally consistent.\n\n### **Problem Validation**\n\n**Step 1: Extracted Givens**\n- **Unweighted $k$-means Objective:** Minimize $J = \\sum_{i=1}^n \\sum_{k=1}^K r_{ik} \\|x_i - \\mu_k\\|^2$ for a dataset $\\{x_i\\}_{i=1}^n \\subset \\mathbb{R}^d$.\n- **Assignments:** $r_{ik} \\in \\{0,1\\}$ with $\\sum_{k=1}^K r_{ik} = 1$.\n- **Metric:** Squared Euclidean norm.\n- **Optimization Principle:** Find minimizers by setting the gradient of the objective function to zero.\n- **Weighted $k$-means Objective:** An extension of the unweighted objective with nonnegative weights $\\{w_i\\}_{i=1}^n$.\n- **Multiplicity Interpretation:** An integer weight $w_i$ is equivalent to duplicating the data point $x_i$ a total of $w_i$ times in an unweighted formulation.\n- **Task 1:** Derive the centroid update rule for the weighted objective. Explain why the cluster assignment rule is independent of the weights.\n- **Task 2:** Prove that for integer weights, the weighted objective is equivalent to the unweighted objective on a duplicated dataset.\n- **Task 3:** Implement algorithms for a single iteration of $k$-means for both the weighted and duplicated-unweighted approaches.\n- **Test Cases:** Four specific test cases are provided with data, weights, initial conditions, and expected outputs to validate the theoretical equivalence and measure centroid drift. All floating-point comparisons must use a tolerance of $\\varepsilon = 10^{-12}$. Test case 4 requires rounding to $6$ decimal places.\n- **Output Format:** A single-line string `[b_1,b_2,b_3,[d_1,d_2,d_3,d_4,d_5]]` representing the results of the four test cases.\n\n**Step 2: Validation Using Extracted Givens**\nThe problem is assessed as valid based on the following criteria:\n- **Scientifically Grounded:** The problem is rooted in the fundamental principles of statistical learning, specifically the $k$-means algorithm, and uses standard optimization techniques from multivariable calculus. Weighted $k$-means is a standard extension of the algorithm.\n- **Well-Posed:** All tasks are clearly defined, and all test cases are supplied with the necessary data and initial conditions to produce a unique, verifiable solution.\n- **Objective:** The problem is stated in precise, unambiguous mathematical and algorithmic terms.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n---\n\n### **Theoretical Derivations**\n\nThis section provides the mathematical derivations required by the problem statement.\n\n**1. Derivation of the Weighted Centroid Update Rule**\n\nThe objective of weighted $k$-means is to find the set of centroids $\\{\\mu_k\\}_{k=1}^K$ and assignments $\\{r_{ik}\\}$ that minimize the within-cluster sum of squared distances, where each point's contribution is scaled by a weight $w_i$. The objective function $J$ is:\n$$\nJ(\\{\\mu_k\\}, \\{r_{ik}\\}) = \\sum_{i=1}^n \\sum_{k=1}^K r_{ik} w_i \\|x_i - \\mu_k\\|^2\n$$\nThe $k$-means algorithm minimizes this function iteratively. In the centroid update step (the M-step), the assignments $\\{r_{ik}\\}$ are fixed, and we seek to find the centroids $\\{\\mu_k\\}$ that minimize $J$. Since the terms for different clusters are independent, we can minimize the objective for each cluster separately.\n\nLet's focus on updating a single centroid, $\\mu_k$. We only need to consider the part of the objective function that depends on $\\mu_k$, which we denote $J_k$:\n$$\nJ_k = \\sum_{i=1}^n r_{ik} w_i \\|x_i - \\mu_k\\|^2\n$$\nHere, $x_i \\in \\mathbb{R}^d$ and $\\mu_k \\in \\mathbb{R}^d$. The squared Euclidean norm is $\\|x_i - \\mu_k\\|^2 = (x_i - \\mu_k)^T(x_i - \\mu_k)$. To find the minimum, we compute the gradient of $J_k$ with respect to $\\mu_k$ and set it to zero.\n$$\n\\nabla_{\\mu_k} J_k = \\nabla_{\\mu_k} \\sum_{i=1}^n r_{ik} w_i (x_i - \\mu_k)^T(x_i - \\mu_k)\n$$\nUsing the linearity of the gradient operator and the identity $\\nabla_v (u-v)^T(u-v) = -2(u-v)$, we get:\n$$\n\\nabla_{\\mu_k} J_k = \\sum_{i=1}^n r_{ik} w_i \\nabla_{\\mu_k} (\\|x_i - \\mu_k\\|^2) = \\sum_{i=1}^n r_{ik} w_i [-2(x_i - \\mu_k)]\n$$\nSetting the gradient to zero to find the optimal $\\mu_k$:\n$$\n-2 \\sum_{i=1}^n r_{ik} w_i (x_i - \\mu_k) = 0\n$$\nAssuming not all points assigned to cluster $k$ have zero weight, we can divide by $-2$:\n$$\n\\sum_{i=1}^n r_{ik} w_i x_i - \\sum_{i=1}^n r_{ik} w_i \\mu_k = 0\n$$\n$$\n\\left(\\sum_{i=1}^n r_{ik} w_i\\right) \\mu_k = \\sum_{i=1}^n r_{ik} w_i x_i\n$$\nSolving for $\\mu_k$, we obtain the centroid update rule:\n$$\n\\mu_k = \\frac{\\sum_{i=1}^n r_{ik} w_i x_i}{\\sum_{i=1}^n r_{ik} w_i}\n$$\nThis shows that the optimal centroid for a cluster is the weighted average of the data points assigned to that cluster. If the denominator is zero (i.e., no points with positive weight are assigned to the cluster), the centroid is undefined and typically left unchanged or re-initialized.\n\n**Explanation of Weight-Independence in the Assignment Step:**\nIn the assignment step (the E-step), the centroids $\\{\\mu_k\\}$ are fixed. For each data point $x_i$, we must assign it to the cluster that minimizes its contribution to the total objective $J$. The contribution of point $x_i$ is $\\sum_{k=1}^K r_{ik} w_i \\|x_i - \\mu_k\\|^2$. Since exactly one $r_{ik}$ is $1$ (and others are $0$), this contribution becomes $w_i \\|x_i - \\mu_c\\|^2$, where $c$ is the index of the assigned cluster.\n\nTo minimize this term for a given point $x_i$, we must choose the cluster index $c$ that minimizes $w_i \\|x_i - \\mu_c\\|^2$.\n- If $w_i  0$, the weight $w_i$ is a positive constant factor. Minimizing $w_i \\|x_i - \\mu_c\\|^2$ is equivalent to minimizing $\\|x_i - \\mu_c\\|^2$ (or its square root, the Euclidean distance).\n- If $w_i = 0$, the contribution of point $x_i$ to the objective is always zero, regardless of its assignment. The assignment is therefore arbitrary and has no impact on the objective function or subsequent centroid updates.\n\nIn either case, the decision rule for assigning a point to a cluster depends only on finding the nearest centroid in terms of Euclidean distance, not on the specific value of the weight $w_i$.\n\n**2. Proof of Equivalence for Integer Weights**\n\nWe will now prove that for a set of nonnegative integer weights $\\{w_i\\}_{i=1}^n$, the weighted $k$-means objective is identical to the standard (unweighted) $k$-means objective on a dataset where each point $x_i$ is duplicated $w_i$ times.\n\nLet the original dataset be $X = \\{x_i\\}_{i=1}^n$. Let the integer weights be $W = \\{w_i\\}_{i=1}^n$, where $w_i \\in \\{0, 1, 2, \\dots\\}$.\nConstruct a new, duplicated dataset $X' = \\{x'_j\\}_{j=1}^{N'}$, where $N' = \\sum_{i=1}^n w_i$. This new dataset contains $w_i$ copies of each point $x_i$. We can define a mapping $\\phi: \\{1, \\dots, N'\\} \\to \\{1, \\dots, n\\}$ such that $x'_j = x_{\\phi(j)}$. The set of indices $j$ that map to a given $i$ (i.e., the preimage $\\phi^{-1}(i)$) has size $|\\phi^{-1}(i)| = w_i$.\n\nThe unweighted $k$-means objective for the duplicated dataset $X'$ is:\n$$\nJ'_{unweighted} = \\sum_{j=1}^{N'} \\sum_{k=1}^K r'_{jk} \\|x'_j - \\mu_k\\|^2\n$$\nwhere $r'_{jk} \\in \\{0,1\\}$ are the hard assignments for the points in $X'$.\n\nFor any point $x'_j$ in the duplicated dataset, its location is $x_{\\phi(j)}$. The cluster assignment for $x'_j$ is determined by finding the centroid $\\mu_k$ that is closest in Euclidean distance. Since all duplicates of a given point $x_i$ are at the same location, they will all be assigned to the same cluster. That is, for any $j_1, j_2$ such that $\\phi(j_1) = \\phi(j_2) = i$, we will have $r'_{j_1,k} = r'_{j_2,k} = r_{ik}$ for all $k=1, \\dots, K$.\n\nWe can now rewrite the objective $J'_{unweighted}$ by grouping the sum over $j$ according to the original points $x_i$:\n$$\nJ'_{unweighted} = \\sum_{i=1}^n \\sum_{j \\in \\phi^{-1}(i)} \\left( \\sum_{k=1}^K r'_{jk} \\|x'_j - \\mu_k\\|^2 \\right)\n$$\nWithin the inner sum over $j \\in \\phi^{-1}(i)$, we know that $x'_j = x_i$ and $r'_{jk} = r_{ik}$. Substituting these in:\n$$\nJ'_{unweighted} = \\sum_{i=1}^n \\sum_{j \\in \\phi^{-1}(i)} \\left( \\sum_{k=1}^K r_{ik} \\|x_i - \\mu_k\\|^2 \\right)\n$$\nThe term $\\sum_{k=1}^K r_{ik} \\|x_i - \\mu_k\\|^2$ is constant for all $j$ in the set $\\phi^{-1}(i)$. The size of this set is $w_i$. Therefore, the sum over $j \\in \\phi^{-1}(i)$ simplifies to multiplying by the size of the set:\n$$\n\\sum_{j \\in \\phi^{-1}(i)} \\left( \\dots \\right) = w_i \\left( \\sum_{k=1}^K r_{ik} \\|x_i - \\mu_k\\|^2 \\right)\n$$\nSubstituting this back into the expression for $J'_{unweighted}$:\n$$\nJ'_{unweighted} = \\sum_{i=1}^n w_i \\left( \\sum_{k=1}^K r_{ik} \\|x_i - \\mu_k\\|^2 \\right) = \\sum_{i=1}^n \\sum_{k=1}^K r_{ik} w_i \\|x_i - \\mu_k\\|^2\n$$\nThis is precisely the weighted objective function $J_{weighted}$. Since the objective functions are identical, their minimization with respect to $\\{\\mu_k\\}$ must yield the same solution. Thus, the centroid update rule derived from the unweighted objective on the duplicated dataset is equivalent to the weighted update rule on the original dataset, which confirms the conclusion that the centroid updates coincide.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Formalizes, implements, and tests weighted k-means clustering.\n    - Derives weighted centroid updates.\n    - Proves equivalence with duplicated-unweighted data for integer weights.\n    - Runs four test cases to validate theory and measure centroid drift.\n    \"\"\"\n    epsilon = 1e-12\n\n    # Helper function to format results for the final print statement.\n    def format_result(item):\n        if isinstance(item, list):\n            # Format the list of floats to 6 decimal places, no spaces.\n            return f\"[{','.join(f'{x:.6f}' for x in item)}]\"\n        else:\n            # For booleans, the default str() is 'True' or 'False', which must be lowercased.\n            return str(item).lower()\n\n    # --- Test Case 1 ---\n    # Single-cluster equivalence in R^1\n    x1_data = np.array([0., 2.])\n    w1_data = np.array([3, 1])\n    \n    # Weighted approach\n    centroid_weighted_1 = np.sum(x1_data * w1_data) / np.sum(w1_data)\n    \n    # Duplicated-unweighted approach\n    x1_dup = np.repeat(x1_data, w1_data)\n    centroid_dup_1 = np.mean(x1_dup)\n    \n    result_1 = np.abs(centroid_weighted_1 - centroid_dup_1)  epsilon\n\n    # --- Test Case 2 ---\n    # Single-cluster equivalence in R^2 with a zero-weight edge case\n    x2_data = np.array([[0., 0.], [2., 2.], [10., 10.]])\n    w2_data = np.array([1, 1, 0])\n    \n    # Weighted approach\n    # Note: Handles sum of weights being zero if all weights are zero\n    sum_weights_2 = np.sum(w2_data)\n    if sum_weights_2 > 0:\n        centroid_weighted_2 = np.sum(x2_data * w2_data[:, np.newaxis], axis=0) / sum_weights_2\n    else: # Should not happen in this test case\n        centroid_weighted_2 = np.zeros(x2_data.shape[1])\n        \n    # Duplicated-unweighted approach\n    w2_data_int = w2_data.astype(int)\n    x2_dup = np.repeat(x2_data, w2_data_int, axis=0)\n    \n    if x2_dup.shape[0] > 0:\n        centroid_dup_2 = np.mean(x2_dup, axis=0)\n    else:\n        centroid_dup_2 = np.zeros(x2_data.shape[1])\n    \n    result_2 = np.linalg.norm(centroid_weighted_2 - centroid_dup_2)  epsilon\n\n    # --- Test Case 3 ---\n    # Single k-means iteration equivalence in R^2 with K=2\n    x3_data = np.array([[0.,0.], [1.,0.], [0.,1.], [5.,5.], [6.,5.], [5.,6.]])\n    w3_data = np.array([1, 2, 1, 1, 1, 3])\n    mu3_initial = np.array([[0.,0.], [5.,5.]])\n\n    # Assignment step (common for both methods, independent of weights)\n    # Using numpy broadcasting to compute all squared distances at once\n    dist_sq = np.sum((x3_data[:, np.newaxis, :] - mu3_initial[np.newaxis, :, :])**2, axis=2)\n    assignments = np.argmin(dist_sq, axis=1)\n\n    # Weighted update\n    mu3_weighted_new = np.zeros_like(mu3_initial)\n    for k in range(2):\n        mask = (assignments == k)\n        cluster_weights = w3_data[mask]\n        sum_cluster_weights = np.sum(cluster_weights)\n        if sum_cluster_weights > 0:\n            mu3_weighted_new[k] = np.sum(x3_data[mask] * cluster_weights[:, np.newaxis], axis=0) / sum_cluster_weights\n        else: # If cluster is empty\n            mu3_weighted_new[k] = mu3_initial[k]\n    \n    # Duplicated-unweighted update\n    w3_data_int = w3_data.astype(int)\n    x3_dup = np.repeat(x3_data, w3_data_int, axis=0)\n    assignments_dup = np.repeat(assignments, w3_data_int, axis=0)\n    \n    mu3_dup_new = np.zeros_like(mu3_initial)\n    for k in range(2):\n        mask = (assignments_dup == k)\n        if np.any(mask):\n            mu3_dup_new[k] = np.mean(x3_dup[mask], axis=0)\n        else:\n            mu3_dup_new[k] = mu3_initial[k]\n\n    diff1 = np.linalg.norm(mu3_weighted_new[0] - mu3_dup_new[0])\n    diff2 = np.linalg.norm(mu3_weighted_new[1] - mu3_dup_new[1])\n    result_3 = (diff1  epsilon) and (diff2  epsilon)\n\n    # --- Test Case 4 ---\n    # Centroid drift as a single weight varies\n    base_points = np.array([[0., 0.]] * 5)\n    base_weights = np.array([1] * 5)\n    outlier_point = np.array([[3., 0.]])\n    outlier_weights = [0, 1, 2, 5, 10]\n    \n    distances = []\n    for w in outlier_weights:\n        # Full dataset and weights\n        all_points = np.vstack((base_points, outlier_point))\n        all_weights = np.append(base_weights, w)\n        \n        # Compute centroid (weighted mean)\n        sum_weights_4 = np.sum(all_weights)\n        if sum_weights_4 > 0:\n            centroid = np.sum(all_points * all_weights[:, np.newaxis], axis=0) / sum_weights_4\n        else:\n            centroid = np.zeros(2)\n\n        # Compute Euclidean distance from the origin\n        distance = np.linalg.norm(centroid)\n        distances.append(distance)\n        \n    result_4 = distances\n    \n    # -- Aggregate and Print Results --\n    final_results = [result_1, result_2, result_3, result_4]\n    \n    # The print statement must produce a single line in the specified format.\n    print(f\"[{','.join(map(format_result, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}