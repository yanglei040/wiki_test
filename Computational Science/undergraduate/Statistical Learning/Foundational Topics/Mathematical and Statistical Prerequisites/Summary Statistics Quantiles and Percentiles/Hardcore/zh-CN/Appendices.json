{
    "hands_on_practices": [
        {
            "introduction": "虽然分位数的概念看似简单，但从有限的数据集中精确计算它却涉及到一些微妙的选择。本练习将深入探讨用于定义经验分位数的不同“插值”方法，这些方法处理落在数据点之间的值。你将探索这些看似微小的技术决策如何能显著影响下游应用，特别是当分位数被用来定义算法公平性分析等敏感领域中的决策阈值时。",
            "id": "3177907",
            "problem": "给定两组代表两个不同人口群体的有限实值分数集，以及一个全局决策规则。根据该规则，当且仅当个体的分数大于或等于一个阈值时，该个体才被接受。该阈值由两组混合分数的指定经验分位数定义。主要目标是比较在不同插值规则下计算的经验分位数，并量化它们对使用百分位阈值的公平性指标的下游影响。\n\n起点和定义：\n- 令 $X$ 为一个实值随机变量，其累积分布函数 (CDF) 为 $F(x) = \\mathbb{P}(X \\le x)$。对于分位数水平 $q \\in [0,1]$，$q$-分位数是任何满足 $F(x_q) \\ge q$ 和 $F(x_q^{-}) \\le q$ 的值 $x_q$，其中 $x_q^{-}$ 表示左极限。\n- 给定一个大小为 $n$ 的有限样本，经验累积分布函数 (ECDF) 为 $F_n(x) = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbf{1}\\{X_i \\le x\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，$X_i$ 是观测到的分数。经验 $q$-分位数使用 $F_n$ 和一个插值规则来定义，该规则指定了如何处理相邻顺序统计量之间的非整数秩。\n- 需要比较的插值规则是以下广泛使用的约定：“lower”（选择不超过目标秩的最大观测值）、“higher”（选择不小于目标秩的最小观测值）、“nearest”（选择最接近的观测秩）、“midpoint”（包围目标秩的相邻观测值的平均值）和“linear”（根据目标秩的小数部分在两个相邻观测值之间进行线性插值）。所有规则都作用于排序后的混合分数，仅在如何解决顺序统计量之间的分数秩上有所不同。\n\n待评估的公平性指标：\n- 公平性指标是人口均等 (Demographic Parity, DP) 差异。对于接受率分别为 $r_{\\mathcal{A}}$ 和 $r_{\\mathcal{B}}$ 的群体 $\\mathcal{A}$ 和 $\\mathcal{B}$，DP 差异定义为 $d = |r_{\\mathcal{A}} - r_{\\mathcal{B}}|$。接受率必须表示为小数（例如，百分之六十表示为 $0.6$）。\n- 接受与否由一个全局阈值 $T_q$ 决定，该阈值计算为两组混合分数的经验 $q$-分位数。当且仅当个体的分数大于或等于 $T_q$ 时，该个体被接受。\n\n任务：\n- 对于每个测试用例，在两组的混合分数上，使用 $\\{\\text{linear}, \\text{lower}, \\text{higher}, \\text{nearest}, \\text{midpoint}\\}$ 中的每种插值规则计算 $T_q$。\n- 对于每种规则，计算接受率 $r_{\\mathcal{A}}$ 和 $r_{\\mathcal{B}}$，然后计算 DP 差异 $d$。\n- 令 $d_{\\text{linear}}$ 为使用“linear”规则时的 DP 差异。通过计算以下公式，量化该测试用例中插值对公平性指标的影响：\n$$\\Delta = \\max_{m \\in \\{\\text{lower}, \\text{higher}, \\text{nearest}, \\text{midpoint}\\}} \\left| d_{m} - d_{\\text{linear}} \\right|,$$\n其中 $d_{m}$ 是在方法 $m$ 下的 DP 差异。\n- 整个测试套件的最终输出是 $\\Delta$ 值的单个列表，每个测试用例一个值，打印在单行上，以逗号分隔，并用方括号括起来，例如 $[0.0,0.1,0.05]$。\n\n测试套件：\n- 用例 1（一般情况）：\n  - 群体 $\\mathcal{A}$ 分数：[$0.10$, $0.20$, $0.35$, $0.40$, $0.50$]\n  - 群体 $\\mathcal{B}$ 分数：[$0.05$, $0.25$, $0.30$, $0.45$, $0.55$]\n  - 分位数水平 $q$：$0.70$\n- 用例 2（小样本和中位数阈值的边界情况）：\n  - 群体 $\\mathcal{A}$ 分数：[$0.20$, $0.80$, $0.90$]\n  - 群体 $\\mathcal{B}$ 分数：[$0.10$, $0.70$, $0.95$]\n  - 分位数水平 $q$：$0.50$\n- 用例 3（平局和重复值）：\n  - 群体 $\\mathcal{A}$ 分数：[$0.30$, $0.30$, $0.30$, $0.60$, $0.60$]\n  - 群体 $\\mathcal{B}$ 分数：[$0.40$, $0.40$, $0.40$, $0.40$, $0.70$]\n  - 分位数水平 $q$：$0.60$\n- 用例 4（极端上分位数）：\n  - 群体 $\\mathcal{A}$ 分数：[$0.20$, $0.40$, $0.60$, $0.80$]\n  - 群体 $\\mathcal{B}$ 分数：[$0.10$, $0.30$, $0.50$, $0.70$]\n  - 分位数水平 $q$：$0.95$\n\n精确输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是为第 $i$ 个测试用例计算的 $\\Delta$。",
            "solution": "该问题要求分析不同经验分位数插值方法对公平性指标，特别是人口均等 (DP) 差异的影响。对于每个给定的测试用例，我们必须计算一个指标 $\\Delta$，它表示使用替代插值方法（'lower', 'higher', 'nearest', 'midpoint'）相对于基准 'linear' 插值方法所引起的 DP 差异的最大偏差。\n\n每个测试用例的处理过程如下：\n1.  将群体 $\\mathcal{A}$ 和群体 $\\mathcal{B}$ 的分数合并成一个单一的混合数据集。\n2.  对于五种指定的插值方法中的每一种 ($m \\in \\{\\text{linear}, \\text{lower}, \\text{higher}, \\text{nearest}, \\text{midpoint}\\}$），计算决策阈值 $T_q^{(m)}$。此阈值是使用方法 $m$ 计算的混合分数的经验 $q$-分位数。\n3.  对于每个阈值 $T_q^{(m)}$，确定每个群体的接受率 $r_{\\mathcal{A}}^{(m)}$ 和 $r_{\\mathcal{B}}^{(m)}$。如果个体的分数大于或等于阈值，则该个体被接受。接受率是一个群体中被接受的个体所占的比例。\n4.  计算每种方法的 DP 差异，$d_m = |r_{\\mathcal{A}}^{(m)} - r_{\\mathcal{B}}^{(m)}|$。\n5.  最后，计算目标指标 $\\Delta = \\max_{m \\in \\{\\text{lower}, \\text{higher}, \\text{nearest}, \\text{midpoint}\\}} |d_m - d_{\\text{linear}}|$。\n\n计算的核心是经验 $q$-分位数的计算。设大小为 $n$ 的混合并排序后的样本表示为 0 索引序列 $S = (x_0, x_1, \\dots, x_{n-1})$。分位数的值由索引 $k = q(n-1)$ 决定。令 $i = \\lfloor k \\rfloor$ 为该索引的下取整，$j = \\lceil k \\rceil$ 为上取整。不同插值方法的阈值 $T_q$ 计算如下：\n- Linear：$T_q = x_i + (k-i)(x_j - x_i)$\n- Lower：$T_q = x_i$\n- Higher：$T_q = x_j$\n- Midpoint：$T_q = (x_i + x_j) / 2$\n- Nearest：$T_q = x_{\\text{round}(k)}$，其中小数部分为 0.5 时，取整到最近的偶数整数。\n\n我们现在将此方法应用于每个测试用例。\n\n**用例 1：**\n- 群体 $\\mathcal{A}$ 分数：[$0.10, 0.20, 0.35, 0.40, 0.50$] ($n_{\\mathcal{A}} = 5$)\n- 群体 $\\mathcal{B}$ 分数：[$0.05, 0.25, 0.30, 0.45, 0.55$] ($n_{\\mathcal{B}} = 5$)\n- 分位数水平 $q = 0.70$\n混合并排序后的分数为 $S = (0.05, 0.10, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.55)$，大小 $n=10$。\n索引为 $k = 0.70 \\times (10-1) = 6.3$。因此，$i=6$ 且 $j=7$。值为 $x_6 = 0.40$ 和 $x_7 = 0.45$。\n- $T_q^{(\\text{linear})} = 0.40 + (6.3-6)(0.45-0.40) = 0.415$。\n  $r_{\\mathcal{A}} = 1/5 = 0.2$, $r_{\\mathcal{B}} = 2/5 = 0.4$。 $d_{\\text{linear}} = |0.2 - 0.4| = 0.2$。\n- $T_q^{(\\text{lower})} = x_6 = 0.40$。\n  $r_{\\mathcal{A}} = 2/5 = 0.4$, $r_{\\mathcal{B}} = 2/5 = 0.4$。 $d_{\\text{lower}} = |0.4 - 0.4| = 0.0$。\n- $T_q^{(\\text{higher})} = x_7 = 0.45$。\n  $r_{\\mathcal{A}} = 1/5 = 0.2$, $r_{\\mathcal{B}} = 2/5 = 0.4$。 $d_{\\text{higher}} = |0.2 - 0.4| = 0.2$。\n- $T_q^{(\\text{nearest})} = x_{\\text{round}(6.3)} = x_6 = 0.40$。\n  $d_{\\text{nearest}} = d_{\\text{lower}} = 0.0$。\n- $T_q^{(\\text{midpoint})} = (0.40+0.45)/2 = 0.425$。\n  $r_{\\mathcal{A}} = 1/5 = 0.2$, $r_{\\mathcal{B}} = 2/5 = 0.4$。 $d_{\\text{midpoint}} = |0.2 - 0.4| = 0.2$。\n与 $d_{\\text{linear}}$ 的差异为 $|0.0 - 0.2| = 0.2$, $|0.2 - 0.2| = 0.0$, $|0.0 - 0.2| = 0.2$ 和 $|0.2 - 0.2| = 0.0$。\n$\\Delta = \\max(0.2, 0.0, 0.2, 0.0) = 0.2$。\n\n**用例 2：**\n- 群体 $\\mathcal{A}$ 分数：[$0.20, 0.80, 0.90$] ($n_{\\mathcal{A}} = 3$)\n- 群体 $\\mathcal{B}$ 分数：[$0.10, 0.70, 0.95$] ($n_{\\mathcal{B}} = 3$)\n- 分位数水平 $q = 0.50$\n混合并排序后的分数为 $S = (0.10, 0.20, 0.70, 0.80, 0.90, 0.95)$，大小 $n=6$。\n索引为 $k = 0.50 \\times (6-1) = 2.5$。因此，$i=2$ 且 $j=3$。值为 $x_2 = 0.70$ 和 $x_3 = 0.80$。\n- $T_q^{(\\text{linear})} = 0.70 + (2.5-2)(0.80-0.70) = 0.75$。\n  $r_{\\mathcal{A}} = 2/3$, $r_{\\mathcal{B}} = 1/3$。 $d_{\\text{linear}} = |2/3 - 1/3| = 1/3$。\n- $T_q^{(\\text{lower})} = x_2 = 0.70$。\n  $r_{\\mathcal{A}} = 2/3$, $r_{\\mathcal{B}} = 2/3$。 $d_{\\text{lower}} = |2/3 - 2/3| = 0.0$。\n- $T_q^{(\\text{higher})} = x_3 = 0.80$。\n  $r_{\\mathcal{A}} = 2/3$, $r_{\\mathcal{B}} = 1/3$。 $d_{\\text{higher}} = |2/3 - 1/3| = 1/3$。\n- $T_q^{(\\text{nearest})} = x_{\\text{round}(2.5)} = x_2 = 0.70$。\n  $d_{\\text{nearest}} = d_{\\text{lower}} = 0.0$。\n- $T_q^{(\\text{midpoint})} = (0.70+0.80)/2 = 0.75$。\n  $d_{\\text{midpoint}} = d_{\\text{linear}} = 1/3$。\n与 $d_{\\text{linear}}$ 的差异为 $|0.0 - 1/3| = 1/3$, $|1/3 - 1/3| = 0.0$, $|0.0 - 1/3| = 1/3$ 和 $|1/3 - 1/3| = 0.0$。\n$\\Delta = \\max(1/3, 0.0, 1/3, 0.0) = 1/3 \\approx 0.333...$。\n\n**用例 3：**\n- 群体 $\\mathcal{A}$ 分数：[$0.30, 0.30, 0.30, 0.60, 0.60$] ($n_{\\mathcal{A}} = 5$)\n- 群体 $\\mathcal{B}$ 分数：[$0.40, 0.40, 0.40, 0.40, 0.70$] ($n_{\\mathcal{B}} = 5$)\n- 分位数水平 $q = 0.60$\n混合并排序后的分数为 $S = (0.30, 0.30, 0.30, 0.40, 0.40, 0.40, 0.40, 0.60, 0.60, 0.70)$，大小 $n=10$。\n索引为 $k = 0.60 \\times (10-1) = 5.4$。因此，$i=5$ 且 $j=6$。值为 $x_5 = 0.40$ 和 $x_6 = 0.40$。\n由于 $x_i = x_j$，所有插值方法都产生相同的阈值 $T_q = 0.40$。\n因此，对于所有方法 $m$，$d_m$ 都是相同的。\n对于 $T_q = 0.40$：\n$r_{\\mathcal{A}} = 2/5 = 0.4$。\n$r_{\\mathcal{B}} = 5/5 = 1.0$。\n$d = |0.4 - 1.0| = 0.6$。\n由于对所有 $m$ 都有 $d_m=0.6$，因此对所有其他方法都有 $d_m - d_{\\text{linear}} = 0$。\n$\\Delta = 0.0$。\n\n**用例 4：**\n- 群体 $\\mathcal{A}$ 分数：[$0.20, 0.40, 0.60, 0.80$] ($n_{\\mathcal{A}} = 4$)\n- 群体 $\\mathcal{B}$ 分数：[$0.10, 0.30, 0.50, 0.70$] ($n_{\\mathcal{B}} = 4$)\n- 分位数水平 $q = 0.95$\n混合并排序后的分数为 $S = (0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80)$，大小 $n=8$。\n索引为 $k = 0.95 \\times (8-1) = 6.65$。因此，$i=6$ 且 $j=7$。值为 $x_6 = 0.70$ 和 $x_7 = 0.80$。\n- $T_q^{(\\text{linear})} = 0.70 + (6.65-6)(0.80-0.70) = 0.765$。\n  $r_{\\mathcal{A}} = 1/4 = 0.25$, $r_{\\mathcal{B}} = 0/4 = 0.0$。 $d_{\\text{linear}} = |0.25 - 0.0| = 0.25$。\n- $T_q^{(\\text{lower})} = x_6 = 0.70$。\n  $r_{\\mathcal{A}} = 1/4 = 0.25$, $r_{\\mathcal{B}} = 1/4 = 0.25$。 $d_{\\text{lower}} = |0.25 - 0.25| = 0.0$。\n- $T_q^{(\\text{higher})} = x_7 = 0.80$。\n  $r_{\\mathcal{A}} = 1/4 = 0.25$, $r_{\\mathcal{B}} = 0/4 = 0.0$。 $d_{\\text{higher}} = |0.25 - 0.0| = 0.25$。\n- $T_q^{(\\text{nearest})} = x_{\\text{round}(6.65)} = x_7 = 0.80$。\n  $d_{\\text{nearest}} = d_{\\text{higher}} = 0.25$。\n- $T_q^{(\\text{midpoint})} = (0.70+0.80)/2 = 0.75$。\n  $r_{\\mathcal{A}} = 1/4 = 0.25$, $r_{\\mathcal{B}} = 0/4 = 0.0$。 $d_{\\text{midpoint}} = |0.25 - 0.0| = 0.25$。\n与 $d_{\\text{linear}}$ 的差异为 $|0.0 - 0.25| = 0.25$, $|0.25 - 0.25| = 0.0$, $|0.25 - 0.25| = 0.0$ 和 $|0.25 - 0.25| = 0.0$。\n$\\Delta = \\max(0.25, 0.0, 0.0, 0.0) = 0.25$。\n\n四个测试用例最终计算出的 $\\Delta$ 值为 $[0.2, 0.333..., 0.0, 0.25]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_delta(scores_A, scores_B, q):\n    \"\"\"\n    Computes the maximum impact of quantile interpolation on the DP difference.\n\n    Args:\n        scores_A (list): A list of real-valued scores for group A.\n        scores_B (list): A list of real-valued scores for group B.\n        q (float): The quantile level, between 0 and 1.\n\n    Returns:\n        float: The computed Delta value for the test case.\n    \"\"\"\n    scores_A_np = np.array(scores_A)\n    scores_B_np = np.array(scores_B)\n    \n    n_A = len(scores_A)\n    n_B = len(scores_B)\n\n    # Pool the scores from both groups.\n    pooled_scores = np.concatenate((scores_A_np, scores_B_np))\n    \n    interpolation_methods = ['linear', 'lower', 'higher', 'nearest', 'midpoint']\n    dp_differences = {}\n    \n    for method in interpolation_methods:\n        # Step 1: Compute the decision threshold T_q using the specified interpolation method.\n        # numpy.quantile's 'method' parameter was named 'interpolation' in older versions.\n        T_q = np.quantile(pooled_scores, q, method=method)\n        \n        # Step 2: Compute acceptance rates for each group.\n        # Acceptance is defined as score = T_q.\n        rate_A = np.sum(scores_A_np = T_q) / n_A\n        rate_B = np.sum(scores_B_np = T_q) / n_B\n        \n        # Step 3: Compute the Demographic Parity (DP) difference.\n        d_m = np.abs(rate_A - rate_B)\n        dp_differences[method] = d_m\n        \n    # Step 4: Quantify the effect of interpolation relative to the 'linear' method.\n    d_linear = dp_differences['linear']\n    other_methods = ['lower', 'higher', 'nearest', 'midpoint']\n    \n    max_abs_diff = 0.0\n    for method in other_methods:\n        diff = np.abs(dp_differences[method] - d_linear)\n        if diff  max_abs_diff:\n            max_abs_diff = diff\n            \n    return max_abs_diff\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case)\n        (\n            [0.10, 0.20, 0.35, 0.40, 0.50],\n            [0.05, 0.25, 0.30, 0.45, 0.55],\n            0.70\n        ),\n        # Case 2 (boundary with small sample and median threshold)\n        (\n            [0.20, 0.80, 0.90],\n            [0.10, 0.70, 0.95],\n            0.50\n        ),\n        # Case 3 (ties and repeated values)\n        (\n            [0.30, 0.30, 0.30, 0.60, 0.60],\n            [0.40, 0.40, 0.40, 0.40, 0.70],\n            0.60\n        ),\n        # Case 4 (extreme upper quantile)\n        (\n            [0.20, 0.40, 0.60, 0.80],\n            [0.10, 0.30, 0.50, 0.70],\n            0.95\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        scores_A, scores_B, q = case\n        delta = calculate_delta(scores_A, scores_B, q)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "百分位数提供了一种将原始数据转换为标准化的、基于秩次(rank)的尺度的强大方法。本练习在二元分类的背景下，重点围绕ROC曲线下面积（AUC）这一指标，探讨了这种变换的特性。通过将模型预测分数转换为百分位数，你将揭示AUC固有的基于秩次的本质及其对单调变换的不变性，同时你也会看到百分位数归一化如何协调来自不同组别的分数，从而构建更稳健的模型。",
            "id": "3177941",
            "problem": "给定您二元分类数据集，其中包含一个标签向量和一个对应的实值预测分数向量。您的任务是 (i) 推导并实现一个预测分数的经验百分位数转换，(ii) 为原始分数和百分位数转换后的分数计算受试者工作特征曲线下面积（AUC；定义如下），以及 (iii) 评估在此转换下AUC的稳定性。此外，在一个多组设置中，其中原始分数尺度因组而异，实现一个分组百分位数归一化，以探究基于百分位数的排序是否比原始分数更具信息量。\n\n使用的基本原理和定义：\n- 令 $N$ 为观测值的数量，索引为 $i \\in \\{1,\\dots,N\\}$。每个观测值都有一个二元标签 $Y_i \\in \\{0,1\\}$ 和一个实值预测分数 $S_i \\in \\mathbb{R}$。\n- 分数的经验累积分布函数（ECDF）定义为 $$F_N(s) = \\frac{1}{N}\\sum_{j=1}^{N} \\mathbf{1}\\{S_j \\le s\\},$$ 其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。百分位数是表示为 $[0,1]$ 区间内小数的分位数；在此任务中，请将百分位数表示为 $[0,1]$ 区间内的小数（不带百分号）。\n- 使用平均秩次来处理相同值：如果相同分数的排序位置横跨整数秩次 $r_{\\text{low}},\\dots,r_{\\text{high}}$，则为每个相同分数分配平均秩次 $$r_{\\text{mid}} = \\frac{r_{\\text{low}} + r_{\\text{high}}}{2}。$$ 将 $S_i$ 的全局经验百分位数定义为 $$P_i = \\frac{r_i - 0.5}{N},$$ 其中 $r_i$ 是 $S_i$ 在所有 $N$ 个分数中的平均秩次。在具有分组 $G_i \\in \\{0,1,\\dots\\}$ 的多组情况下，将分组百分位数定义为 $$P^{(g)}_i = \\frac{r^{(g)}_i - 0.5}{N_g},$$ 其中 $r^{(g)}_i$ 是 $S_i$ 在其所属组 $g = G_i$ 内的平均秩次，而 $N_g$ 是组 $g$ 中的观测值数量。\n- 受试者工作特征（ROC）曲线（此处定义为通过对分数设定阈值可实现的真阳性率和假阳性率对的集合）其曲线下面积（AUC）可定义为一个随机选择的正标签分数超过一个随机选择的负标签分数的概率，其中相同值各计一半功劳。使用秩次，令 $m = \\sum_{i=1}^{N} \\mathbf{1}\\{Y_i = 1\\}$ 且 $n = \\sum_{i=1}^{N} \\mathbf{1}\\{Y_i = 0\\}$，并令 $R^+ = \\sum_{i: Y_i=1} r_i$ 为正标签观测值的平均秩次之和；则AUC由下式给出 $$\\text{AUC} = \\frac{R^+ - \\frac{m(m+1)}{2}}{m \\cdot n}。$$\n\n您的程序必须为下面的每个测试案例执行以下操作：\n1. 使用基于平均秩次的公式计算原始分数的AUC。\n2. 计算全局百分位数分数 $P_i$ 和相应的AUC，然后计算绝对差 $$\\Delta_{\\text{global}} = \\left|\\text{AUC}_{\\text{raw}} - \\text{AUC}_{\\text{global}}\\right|。$$\n3. 计算分组百分位数分数 $P^{(g)}_i$ 和相应的AUC，以及提升量 $$\\Delta_{\\text{group}} = \\text{AUC}_{\\text{group}} - \\text{AUC}_{\\text{raw}}。$$\n4. 以小数形式报告所有的AUC和差异值。\n\n测试套件（每个案例提供标签 $Y$、分数 $S$ 和整数分组标签 $G$）：\n- 案例 1（连续且分数大多唯一；单组）：\n  - $Y = [0,0,0,0,1,1,1,1,1,0,1,0]$\n  - $S = [0.10,0.15,0.20,0.25,0.30,0.22,0.27,0.35,0.40,0.12,0.33,0.18]$\n  - $G = [0,0,0,0,0,0,0,0,0,0,0,0]$\n- 案例 2（大量相同值；单组）：\n  - $Y = [0,0,1,1,0,1,0,1]$\n  - $S = [0.50,0.50,0.50,0.50,0.70,0.70,0.20,0.20]$\n  - $G = [0,0,0,0,0,0,0,0]$\n- 案例 3（极端异常值；单組）：\n  - $Y = [0,0,0,0,1,1,1,1,1,0]$\n  - $S = [0.01,0.02,0.03,100.00,0.04,0.05,0.06,0.07,0.08,0.90]$\n  - $G = [0,0,0,0,0,0,0,0,0,0]$\n- 案例 4（退化的恒定分数；单组）：\n  - $Y = [0,0,0,1,1,1,0,1]$\n  - $S = [0.30,0.30,0.30,0.30,0.30,0.30,0.30,0.30]$\n  - $G = [0,0,0,0,0,0,0,0]$\n- 案例 5（两个原始分数尺度不同的组；预期基于百分位数的排序更具信息量）：\n  - $Y = [0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1]$\n  - $S = [20,22,18,24,35,37,33,39,1030,1050,1100,1080,1005,1010,995,1020]$\n  - $G = [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表的列表。对于每个测试案例，按此顺序输出列表 $[\\text{AUC}_{\\text{raw}}, \\text{AUC}_{\\text{global}}, \\Delta_{\\text{global}}, \\text{AUC}_{\\text{group}}, \\Delta_{\\text{group}}]$，所有值均为小数。將五个案例的结果汇总到一个列表中，并将其完全作为一行打印，例如，$$[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],\\dots].$$",
            "solution": "该问题陈述已经过严格验证，并被认为是有效的。它在科学上基于既定的统计学原理，问题阐述清晰，定义和数据明确，并且表述客观。所有必要的组成部分，包括使用平均秩次的经验百分位数定义和计算受试者工作特征曲线下面积（AUC）的基于秩次的公式，均已提供。测试案例定义明确，涵盖了与待测概念相关的一系列场景。\n\n解决方案首先实现一个根据给定公式计算AUC的函数。该函数将是核心计算模块。随后，对于每个测试案例，我们将分三个不同步骤计算所需的统计量：一次针对原始预测分数，一次针对全局转换后的百分位数分数，以及一次针对分组转换后的百分位数分数。\n\n### 1. AUC 计算\nAUC由以下公式给出：\n$$\n\\text{AUC} = \\frac{R^+ - \\frac{m(m+1)}{2}}{m \\cdot n}\n$$\n其中，$m$ 是正标签（$Y_i=1$）的数量，$n$ 是负标签（$Y_i=0$）的数量，而 $R^+$ 是对应于正标签的分数 $S_i$ 的平均秩次之和。平均秩次用于处理分数中的相同值。如果一组相同值占据的秩次从 $r_{\\text{low}}$ 到 $r_{\\text{high}}$，则每个分数都被赋予平均秩次 $r_{\\text{mid}} = (r_{\\text{low}} + r_{\\text{high}})/2$。实现将使用 `scipy.stats.rankdata` 并设置 `method='average'` 来高效且正确地计算这些平均秩次。\n\n### 2. 全局百分位数转换\n分数 $S_i$ 的全局百分位数 $P_i$ 定义为：\n$$\nP_i = \\frac{r_i - 0.5}{N}\n$$\n其中 $r_i$ 是 $S_i$ 的全局平均秩次，$N$ 是总观测数。这种转换是秩次的严格保序（单调）函数。由于AUC公式完全基于秩次，任何此类转换都不会改变分数之间的相对秩次。因此，基于原始分数计算的AUC（$\\text{AUC}_{\\text{raw}}$）必须与基于全局百分位数分数计算的AUC（$\\text{AUC}_{\\text{global}}$）相同。所以，绝对差 $\\Delta_{\\text{global}} = \\left|\\text{AUC}_{\\text{raw}} - \\text{AUC}_{\\text{global}}\\right|$ 理论上应为 $0$。\n\n### 3. 分组百分位数转换\n对于属于组 $g = G_i$ 的观测值 $i$，其分组百分位数为：\n$$\nP^{(g)}_i = \\frac{r^{(g)}_i - 0.5}{N_g}\n$$\n此处，$r^{(g)}_i$ 是 **仅** 在组 $g$ 内的分数中计算出的 $S_i$ 的平均秩次，$N_g$ 是该组中的观测值数量。此转换将每组内的分数重新缩放到一个共同的 $[0, 1]$ 范围内。与全局转换不同，这 **不会** 保留跨不同组分数的整体秩次排序。来自低尺度组的高分可能比来自高尺度组的低分获得更高的百分位数秩次。这可能会改变整体AUC。我们将计算新的分数集 $P^{(g)}_i$，然后使用这些新分数计算 $\\text{AUC}_{\\text{group}}$。提升量由 $\\Delta_{\\text{group}} = \\text{AUC}_{\\text{group}} - \\text{AUC}_{\\text{raw}}$ 来衡量。\n\n### 4. 算法实现\n对于每个测试案例，算法如下：\n1.  接收标签向量 $Y$、分数向量 $S$ 和分组赋值向量 $G$。\n2.  **原始AUC**：计算所有分数 $S$ 的平均秩次，以找到正样本的秩次，求和得到 $R^+$，并使用所提供的公式计算 $\\text{AUC}_{\\text{raw}}$。\n3.  **全局百分位数AUC**：\n    a. 使用上一步得到的相同全局平均秩次 $r_i$。\n    b. 计算全局百分位数分数 $P_i = (r_i - 0.5) / N$。\n    c. 使用标签 $Y$ 和分数 $P$ 计算 $\\text{AUC}_{\\text{global}}$。\n    d. 计算 $\\Delta_{\\text{global}} = |\\text{AUC}_{\\text{raw}} - \\text{AUC}_{\\text{global}}|$。\n4.  **分组百分位数AUC**：\n    a. 初始化一个新的分数向量 $P_{\\text{group}}$。\n    b. 对于 $G$ 中的每个唯一组 $g$：\n        i.   分离出该组的分数 $S_g$ 和标签 $Y_g$。\n        ii.  计算分数 $S_g$ 的平均秩次 $r^{(g)}_i$。\n        iii. 计算特定于组的百分位数 $P^{(g)}_i = (r^{(g)}_i - 0.5) / N_g$。\n        iv.  将这些百分位数分数放回 $P_{\\text{group}}$ 中相应的位置。\n    c. 使用标签 $Y$ 和分数 $P_{\\text{group}}$ 计算 $\\text{AUC}_{\\text{group}}$。\n    d. 计算 $\\Delta_{\\text{group}} = \\text{AUC}_{\\text{group}} - \\text{AUC}_{\\text{raw}}$。\n5.  收集五个结果值：$[\\text{AUC}_{\\text{raw}}, \\text{AUC}_{\\text{global}}, \\Delta_{\\text{global}}, \\text{AUC}_{\\text{group}}, \\Delta_{\\text{group}}]$。\n\n此过程被系统地应用于所有测试案例，并且结果被汇总到一个最终列表中以供输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import rankdata\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases, calculating AUC for raw scores,\n    global-percentile-transformed scores, and groupwise-percentile-transformed\n    scores, along with specified difference metrics.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"Y\": np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0]),\n            \"S\": np.array([0.10, 0.15, 0.20, 0.25, 0.30, 0.22, 0.27, 0.35, 0.40, 0.12, 0.33, 0.18]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n        },\n        {\n            \"Y\": np.array([0, 0, 1, 1, 0, 1, 0, 1]),\n            \"S\": np.array([0.50, 0.50, 0.50, 0.50, 0.70, 0.70, 0.20, 0.20]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0])\n        },\n        {\n            \"Y\": np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 0]),\n            \"S\": np.array([0.01, 0.02, 0.03, 100.00, 0.04, 0.05, 0.06, 0.07, 0.08, 0.90]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n        },\n        {\n            \"Y\": np.array([0, 0, 0, 1, 1, 1, 0, 1]),\n            \"S\": np.array([0.30, 0.30, 0.30, 0.30, 0.30, 0.30, 0.30, 0.30]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0])\n        },\n        {\n            \"Y\": np.array([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]),\n            \"S\": np.array([20, 22, 18, 24, 35, 37, 33, 39, 1030, 1050, 1100, 1080, 1005, 1010, 995, 1020]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1])\n        }\n    ]\n\n    def calculate_auc(labels, scores):\n        \"\"\"\n        Calculates AUC using the rank-based formula.\n        AUC = (R_pos - m*(m+1)/2) / (m*n)\n        \"\"\"\n        pos_mask = (labels == 1)\n        m = np.sum(pos_mask)\n        n = len(labels) - m\n\n        if m == 0 or n == 0:\n            return 0.5 # Or np.nan, but 0.5 is a common convention for non-discriminable case\n\n        ranks = rankdata(scores, method='average')\n        R_pos = np.sum(ranks[pos_mask])\n\n        auc = (R_pos - m * (m + 1) / 2) / (m * n)\n        return auc\n\n    def process_case(Y, S, G):\n        \"\"\"\n        Processes a single test case according to the problem description.\n        \"\"\"\n        N = len(Y)\n\n        # 1. Raw-score AUC\n        auc_raw = calculate_auc(Y, S)\n\n        # 2. Global percentile AUC\n        ranks_global = rankdata(S, method='average')\n        P_global = (ranks_global - 0.5) / N\n        auc_global = calculate_auc(Y, P_global)\n        delta_global = abs(auc_raw - auc_global)\n\n        # 3. Groupwise percentile AUC\n        P_group = np.zeros_like(S, dtype=float)\n        unique_groups = np.unique(G)\n        for g_id in unique_groups:\n            group_mask = (G == g_id)\n            S_g = S[group_mask]\n            N_g = len(S_g)\n            if N_g  0:\n                ranks_g = rankdata(S_g, method='average')\n                P_g_vals = (ranks_g - 0.5) / N_g\n                P_group[group_mask] = P_g_vals\n        \n        auc_group = calculate_auc(Y, P_group)\n        delta_group = auc_group - auc_raw\n        \n        return [auc_raw, auc_global, delta_global, auc_group, delta_group]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"Y\"], case[\"S\"], case[\"G\"])\n        results.append(result)\n        \n    # Python's default float representation is sufficient for \"decimals\"\n    # The requirement is to format the list of lists into a string.\n    # e.g. [[a1, b1, ...], [a2, b2, ...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从样本中估算出的分位数是一个统计量，和任何统计量一样，它也具有不确定性。这个高级练习将带领你从简单地计算分位数，发展到对其进行统计推断。你将使用统计学中的一个基本工具——delta方法——来将样本分位数估计的不确定性传播到一个更复杂的下游风险度量中，从而量化你对风险评估的信心。",
            "id": "3177964",
            "problem": "给定一个包含 $n$ 个标准化每日损失幅度的数据集：\n$0.80,\\, 0.55,\\, 1.20,\\, 0.30,\\, 0.95,\\, 0.67,\\, 1.50,\\, 0.40,\\, 0.72,\\, 0.88,\\, 1.10,\\, 0.33,\\, 0.60,\\, 0.77,\\, 0.25,\\, 1.30,\\, 0.52,\\, 0.66,\\, 0.90,\\, 0.45$。\n您的任务是使用基本定义来估计高分位数风险并量化其不确定性，然后根据非参数自助法摘要验证您的不确定性估计的量级。\n\n使用经验累积分布函数（CDF；cumulative distribution function）反演，从样本中估计 $p=0.90$ 的 $p$-分位数。将下游风险度量定义为 $R(q) = \\exp(\\beta q)$，其中 $\\beta = 0.50$，并在您的经验分位数估计值处进行评估。从基本原理出发，使用 Delta 方法，通过将经验分位数中的不确定性在 $R(\\cdot)$ 中传播，来推导和计算 $\\widehat{R}$ 的标准误。为了估计样本分位数方差在分位数处的密度 $f(q)$，请使用最近顺序统计量的对称间距（即，通过经验CDF在 $x_{(r-1)}$ 和 $x_{(r+1)}$ 上的有限差分来局部近似 $f(q)$，其中 $r$ 是经验 $p$-分位数的索引）。作为量级检查，使用 $B = 1000$ 个重抽样样本的非参数自助法得出的风险度量的样本标准差为 $0.121$。\n\n计算并报告 $\\widehat{R}$ 的 Delta 方法标准误，并将您的答案四舍五入到四位有效数字。不涉及物理单位；请提供一个无单位的数值。",
            "solution": "目标是使用 Delta 方法计算估计的风险度量 $\\widehat{R} = R(\\widehat{q}_p)$ 的标准误。该过程涉及几个步骤：找到样本分位数，推导标准误的 Delta 方法近似形式，估计该近似的各个组成部分，最后计算数值。\n\n首先，我们必须确定样本量并对给定数据进行排序，以找到顺序统计量 $x_{(i)}$。样本量为 $n = 20$。排序后的数据集为：\n$x_{(1)} = 0.25$, $x_{(2)} = 0.30$, $x_{(3)} = 0.33$, $x_{(4)} = 0.40$, $x_{(5)} = 0.45$,\n$x_{(6)} = 0.52$, $x_{(7)} = 0.55$, $x_{(8)} = 0.60$, $x_{(9)} = 0.66$, $x_{(10)} = 0.67$,\n$x_{(11)} = 0.72$, $x_{(12)} = 0.77$, $x_{(13)} = 0.80$, $x_{(14)} = 0.88$, $x_{(15)} = 0.90$,\n$x_{(16)} = 0.95$, $x_{(17)} = 1.10$, $x_{(18)} = 1.20$, $x_{(19)} = 1.30$, $x_{(20)} = 1.50$。\n\n问题指定使用经验CDF反演来估计 $p=0.90$ 的分位数 $\\widehat{q}_{0.90}$。样本 $p$-分位数的一个常用定义是第 $r$ 个顺序统计量，其中 $r = \\lceil n \\cdot p \\rceil$。\n对于 $n=20$ 和 $p=0.90$，索引为：\n$$r = \\lceil 20 \\times 0.90 \\rceil = \\lceil 18 \\rceil = 18$$\n因此，估计的 $0.90$-分位数是第 $18$ 个顺序统计量：\n$$\\widehat{q}_{0.90} = x_{(18)} = 1.20$$\n\n风险度量为 $R(q) = \\exp(\\beta q)$，其中 $\\beta=0.50$。估计的风险为：\n$$\\widehat{R} = R(\\widehat{q}_{0.90}) = \\exp(0.50 \\times 1.20) = \\exp(0.60)$$\n\nDelta 方法近似了估计量 $\\widehat{\\theta}$ 的函数 $g(\\widehat{\\theta})$ 的方差。对于单变量估计量，其近似为 $\\text{Var}(g(\\widehat{\\theta})) \\approx [g'(\\theta)]^2 \\text{Var}(\\widehat{\\theta})$。\n在我们的情景中，$\\widehat{\\theta}$ 是样本分位数 $\\widehat{q}_p$，$g(\\cdot)$ 是风险函数 $R(\\cdot)$。因此，$\\widehat{R}$ 的方差为：\n$$\\text{Var}(\\widehat{R}) \\approx [R'(q_p)]^2 \\text{Var}(\\widehat{q}_p)$$\n其中 $q_p$ 是真实总体分位数。标准误是方差的平方根。\n\n首先，我们求 $R(q)$ 的导数：\n$$R'(q) = \\frac{d}{dq} \\exp(\\beta q) = \\beta \\exp(\\beta q)$$\n我们使用我们的估计值来计算它：\n$$R'(\\widehat{q}_{0.90}) = 0.50 \\times \\exp(0.50 \\times 1.20) = 0.50 \\exp(0.60)$$\n\n接下来，我们需要样本分位数的方差 $\\text{Var}(\\widehat{q}_p)$。该方差的大样本近似为：\n$$\\text{Var}(\\widehat{q}_p) \\approx \\frac{p(1-p)}{n [f(q_p)]^2}$$\n其中 $f(q_p)$ 是概率密度函数在真实分位数 $q_p$ 处的值。我们需要估计 $f(q_p)$。问题指导我们使用围绕我们的估计分位数 $x_{(r)}$ 的最近顺序统计量的对称间距。这给出了密度估计：\n$$\\widehat{f}(x_{(r)}) = \\frac{(r+1)/n - (r-1)/n}{x_{(r+1)} - x_{(r-1)}} = \\frac{2/n}{x_{(r+1)} - x_{(r-1)}}$$\n对于我们的分位数 $\\widehat{q}_{0.90} = x_{(18)}$，我们有 $r=18$。我们需要相邻的顺序统计量 $x_{(17)}$ 和 $x_{(19)}$。\n从排序后的列表中，$x_{(17)} = 1.10$ 且 $x_{(19)} = 1.30$。\n将这些值与 $n=20$ 一起代入：\n$$\\widehat{f}(\\widehat{q}_{0.90}) = \\frac{2/20}{x_{(19)} - x_{(17)}} = \\frac{0.1}{1.30 - 1.10} = \\frac{0.1}{0.2} = 0.50$$\n\n现在我们可以估计样本分位数的方差：\n$$\\widehat{\\text{Var}}(\\widehat{q}_{0.90}) = \\frac{p(1-p)}{n [\\widehat{f}(\\widehat{q}_{0.90})]^2} = \\frac{0.90 \\times (1-0.90)}{20 \\times (0.50)^2} = \\frac{0.09}{20 \\times 0.25} = \\frac{0.09}{5} = 0.018$$\n\n最后，我们结合这些结果来求出估计的风险度量 $\\widehat{R}$ 的方差：\n$$\\widehat{\\text{Var}}(\\widehat{R}) \\approx [R'(\\widehat{q}_{0.90})]^2 \\widehat{\\text{Var}}(\\widehat{q}_{0.90})$$\n$$\\widehat{\\text{Var}}(\\widehat{R}) \\approx [0.50 \\exp(0.60)]^2 \\times 0.018$$\n标准误 $\\text{SE}(\\widehat{R})$ 是方差的平方根：\n$$\\text{SE}(\\widehat{R}) = \\sqrt{\\widehat{\\text{Var}}(\\widehat{R})} \\approx \\sqrt{[0.50 \\exp(0.60)]^2 \\times 0.018}$$\n$$\\text{SE}(\\widehat{R}) \\approx |0.50 \\exp(0.60)| \\sqrt{0.018} = 0.50 \\exp(0.60) \\sqrt{0.018}$$\n现在我们计算数值：\n$$\\exp(0.60) \\approx 1.8221188$$\n$$\\sqrt{0.018} \\approx 0.1341640786$$\n$$\\text{SE}(\\widehat{R}) \\approx 0.50 \\times 1.8221188 \\times 0.1341640786 \\approx 0.122235$$\n四舍五入到四位有效数字，我们得到 $0.1222$。该值与提供的自助法估计值 $0.121$ 一致，证实了我们计算的合理性。",
            "answer": "$$\\boxed{0.1222}$$"
        }
    ]
}