{
    "hands_on_practices": [
        {
            "introduction": "我们从工具变量方法中最直观的形式——二元工具变量——开始。该练习将指导你推导出基本的沃尔德估计量 (Wald estimator)，它将因果效应 $\\beta$ 表示为一个简单的差异之比。通过从通用的工具变量协方差公式出发，并将其特化到二元工具变量的情形，你将对工具变量如何分离出因果效应建立起深刻的直觉理解 。",
            "id": "3131775",
            "problem": "一位教育研究者试图估计训练强度对测试表现的因果效应。设 $Y$ 表示学生的项目后测试分数，$D$ 表示完成的训练时数，是连续变量。由于学生可能会自我选择他们的训练强度，因此 $D$ 可能是内生的。研究者利用一个鼓励分配 $Z \\in \\{0,1\\}$（离散变量），该分配为参加训练提供额外的后勤支持，其中 $Z=1$ 表示被分配到鼓励组，$Z=0$ 表示未被鼓励。\n\n假设以下基本条件成立：\n- 线性结构关系成立：$Y = \\alpha + \\beta D + u$，其中 $u$ 是一个未观测到的误差项。\n- 相关性：$\\operatorname{Cov}(Z,D) \\neq 0$。\n- 排他性和外生性：$Z$ 仅通过 $D$ 影响 $Y$，且 $E[u \\mid Z] = E[u]$。\n- $Z$的随机分配：除了上述对 $D$ 的影响外，$Z$ 与 $(D,u)$ 相互独立。\n\n从这些条件以及协方差和条件期望的基本定义出发，当 $D$ 是连续的时，推导一个可以用离散工具变量 $Z$ 识别的因果参数 $\\beta$ 的表达式。然后，对于二元变量 $Z$，展示已识别的表达式如何特化为涉及两组 $Z=1$ 和 $Z=0$ 之间条件期望差异的比率（即，双样本分组和差分比率表示）。\n\n最后，研究者从一个大样本中收集了汇总统计数据：\n- $Z=1$ 时的平均训练时数：$\\overline{D}_{1} = 5.77$；$Z=0$ 时的平均训练时数：$\\overline{D}_{0} = 4.22$。\n- $Z=1$ 时的平均测试分数：$\\overline{Y}_{1} = 12.84$；$Z=0$ 时的平均测试分数：$\\overline{Y}_{0} = 10.31$。\n\n使用您推导出的双样本分组和差分比率表示，计算 $\\beta$ 的工具变量估计值，并报告您的最终数值答案。将您的答案四舍五入到四位有效数字。",
            "solution": "该问题为工具变量（IV）估计提供了一个有效且定义明确的场景。我们的任务是为一个因果参数推导IV估计量，然后根据汇总统计数据计算其值。\n\n首先，我们推导因果参数 $\\beta$ 的一般表达式。结构模型由下式给出：\n$$ Y = \\alpha + \\beta D + u $$\n其中 $Y$ 是测试分数，$D$ 是训练强度，$\\beta$ 是 $D$ 对 $Y$ 的因果效应，$u$ 是一个未观测到的误差项。变量 $D$ 可能是内生的，意味着 $\\operatorname{Cov}(D, u) \\neq 0$。\n\n我们给定了一个工具变量 $Z$，即鼓励分配，它满足两个关键条件：\n1.  **相关性**：$\\operatorname{Cov}(Z, D) \\neq 0$。工具变量对内生变量 $D$ 有因果效应。\n2.  **外生性和排他性**：$E[u \\mid Z] = E[u]$。工具变量 $Z$ 与结构性误差 $u$ 不相关，并且仅通过其对 $D$ 的影响来影响结果 $Y$。\n\n条件 $E[u \\mid Z] = E[u]$ 意味着 $Z$ 和 $u$ 之间的协方差为零。我们可以使用全期望定律来证明这一点：\n$$ \\operatorname{Cov}(Z, u) = E[Zu] - E[Z]E[u] $$\n我们有 $E[Zu] = E[E[Zu \\mid Z]] = E[Z \\cdot E[u \\mid Z]]$。因为 $E[u \\mid Z] = E[u]$（相对于 $Z$ 是一个常数），所以这变成 $E[Z \\cdot E[u]] = E[u]E[Z]$。\n将此代入协方差公式得出：\n$$ \\operatorname{Cov}(Z, u) = E[u]E[Z] - E[Z]E[u] = 0 $$\n\n为了识别 $\\beta$，我们利用这个性质，计算结构方程与工具变量 $Z$ 的协方差：\n$$ \\operatorname{Cov}(Z, Y) = \\operatorname{Cov}(Z, \\alpha + \\beta D + u) $$\n利用协方差的性质，我们可以展开右边：\n$$ \\operatorname{Cov}(Z, Y) = \\operatorname{Cov}(Z, \\alpha) + \\operatorname{Cov}(Z, \\beta D) + \\operatorname{Cov}(Z, u) $$\n我们评估每一项：\n-   $\\operatorname{Cov}(Z, \\alpha) = 0$ 因为 $\\alpha$ 是一个常数。\n-   根据双线性性质，$\\operatorname{Cov}(Z, \\beta D) = \\beta \\operatorname{Cov}(Z, D)$。\n-   根据外生性假设，$\\operatorname{Cov}(Z, u) = 0$。\n\n这将方程简化为：\n$$ \\operatorname{Cov}(Z, Y) = \\beta \\operatorname{Cov}(Z, D) $$\n给定相关性条件（$\\operatorname{Cov}(Z, D) \\neq 0$），我们可以解出 $\\beta$：\n$$ \\beta = \\frac{\\operatorname{Cov}(Z, Y)}{\\operatorname{Cov}(Z, D)} $$\n这就是IV估计量的一般公式。\n\n接下来，我们将此公式特化到工具变量 $Z$ 是一个二元变量，$Z \\in \\{0, 1\\}$ 的情况。对于任何随机变量 $X$，其与二元变量 $Z$ 的协方差可以用条件期望来表示。设 $p = P(Z=1)$。则 $P(Z=0) = 1-p$。\n$$ \\operatorname{Cov}(Z, X) = E[ZX] - E[Z]E[X] $$\n各项为：\n$E[ZX] = 1 \\cdot E[X \\mid Z=1] P(Z=1) + 0 \\cdot E[X \\mid Z=0] P(Z=0) = p \\cdot E[X \\mid Z=1]$。\n$E[Z] = p$。\n$E[X] = E[X \\mid Z=1]P(Z=1) + E[X \\mid Z=0]P(Z=0) = p E[X \\mid Z=1] + (1-p)E[X \\mid Z=0]$。\n代入这些可得：\n$$ \\operatorname{Cov}(Z, X) = p E[X \\mid Z=1] - p [p E[X \\mid Z=1] + (1-p)E[X \\mid Z=0]] $$\n$$ \\operatorname{Cov}(Z, X) = p(1-p)E[X \\mid Z=1] - p(1-p)E[X \\mid Z=0] $$\n$$ \\operatorname{Cov}(Z, X) = p(1-p) (E[X \\mid Z=1] - E[X \\mid Z=0]) $$\n将此结果应用于 $\\beta$ 的IV公式的分子和分母：\n$$ \\beta = \\frac{p(1-p)(E[Y \\mid Z=1] - E[Y \\mid Z=0])}{p(1-p)(E[D \\mid Z=1] - E[D \\mid Z=0])} $$\n假设 $p$ 不为 $0$ 或 $1$，项 $p(1-p)$ 可以消去，得到差分比率表示，也称为沃尔德（Wald）估计量：\n$$ \\beta = \\frac{E[Y \\mid Z=1] - E[Y \\mid Z=0]}{E[D \\mid Z=1] - E[D \\mid Z=0]} $$\n\n最后，我们使用提供的汇总统计数据计算 $\\beta$ 的数值估计。样本均值被用作总体条件期望的估计。样本IV估计值 $\\hat{\\beta}_{IV}$ 由下式给出：\n$$ \\hat{\\beta}_{IV} = \\frac{\\overline{Y}_{1} - \\overline{Y}_{0}}{\\overline{D}_{1} - \\overline{D}_{0}} $$\n给定的数据是：\n-   平均训练时数：$Z=1$ 时为 $\\overline{D}_{1} = 5.77$，$Z=0$ 时为 $\\overline{D}_{0} = 4.22$。\n-   平均测试分数：$Z=1$ 时为 $\\overline{Y}_{1} = 12.84$，$Z=0$ 时为 $\\overline{Y}_{0} = 10.31$。\n\n将这些值代入公式：\n$$ \\hat{\\beta}_{IV} = \\frac{12.84 - 10.31}{5.77 - 4.22} $$\n我们计算分子和分母的差值：\n$$ \\hat{\\beta}_{IV} = \\frac{2.53}{1.55} $$\n进行除法运算得到数值估计：\n$$ \\hat{\\beta}_{IV} \\approx 1.632258... $$\n按照要求，将结果四舍五入到四位有效数字，我们得到 $1.632$。",
            "answer": "$$\\boxed{1.632}$$"
        },
        {
            "introduction": "工具变量的“魔力”在于它能够“清洗”内生变量中与误差项相关的部分。在这个计算练习中，你将通过模拟一个存在已知内生性问题的数据集来亲手验证这一“清洗”特性。你将直观地看到，第一阶段的回归预测如何生成一个与结构误差项不相关的新变量 $\\hat{x}$，从而为无偏估计创造了条件 。",
            "id": "2402330",
            "problem": "给定结构模型 $y = \\beta_0 + \\beta_1 x + u$，其中回归量 $x$ 是内生的，满足 $\\mathrm{Cov}(x, u) \\ne 0$。设 $Z$ 是一个旨在用作工具变量的外部变量。目标是通过样本相关系数，在数值上证明：当 $Z$ 是外生且相关的工具变量时，将 $x$ 正交投影到由常数项和 $Z$ 张成的空间上，可以消除其与结构误差 $u$ 之间的样本相关性。\n\n数据生成过程。对于每个观测值 $i \\in \\{1,\\dots,n\\}$：\n- 从 $Z_i \\sim \\mathcal{N}(0,1)$ 中独立同分布地（i.i.d.）抽取 $Z_i$。\n- 从 $(u_i, v_i)^\\top \\sim \\mathcal{N}\\!\\left(\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}, \\begin{bmatrix}1  \\rho \\\\ \\rho  1\\end{bmatrix}\\right)$ 中独立同分布地抽取 $(u_i, v_i)^\\top$，且与 $\\{Z_i\\}_{i=1}^n$ 独立。\n- 构建 $x_i = \\pi Z_i + v_i$。\n- 构建 $y_i = \\beta_0 + \\beta_1 x_i + u_i$。\n\n定义 $n \\times 2$ 矩阵 $X = \\begin{bmatrix}\\mathbf{1}  Z\\end{bmatrix}$，其中 $\\mathbf{1}$ 是 $n \\times 1$ 的全一向量，$Z$ 是堆叠了 $\\{Z_i\\}_{i=1}^n$ 的 $n \\times 1$ 向量。令 $\\hat{x}$ 表示 $x$ 在 $X$ 的列空间上的正交投影，即 $\\hat{x} = P x$，其中 $P = X(X^\\top X)^{-1}X^\\top$。\n\n对于任意两个长度为 $n$ 的向量 $a$ 和 $b$，定义样本相关系数\n$$\n\\widehat{\\mathrm{Corr}}(a,b) = \\frac{\\sum_{i=1}^n (a_i - \\bar{a})(b_i - \\bar{b})}{\\sqrt{\\sum_{i=1}^n (a_i - \\bar{a})^2}\\,\\sqrt{\\sum_{i=1}^n (b_i - \\bar{b})^2}},\n$$\n其中 $\\bar{a} = \\frac{1}{n}\\sum_{i=1}^n a_i$ 且 $\\bar{b} = \\frac{1}{n}\\sum_{i=1}^n b_i$。\n\n任务。对于下面测试套件中的每个参数元组 $(n,\\beta_0,\\beta_1,\\pi,\\rho,s)$：\n- 使用上述数据生成过程，以参数 $(\\beta_0,\\beta_1,\\pi,\\rho)$ 模拟一个大小为 $n$ 的数据集，在该案例中对所有抽样使用 $s$ 作为伪随机种子。\n- 计算两个浮点数：$\\widehat{\\mathrm{Corr}}(x,u)$ 和 $\\widehat{\\mathrm{Corr}}(\\hat{x},u)$。\n- 将每个浮点数四舍五入到 $6$ 位小数。\n\n测试套件。使用以下四组参数：\n- 案例 A: $(n,\\beta_0,\\beta_1,\\pi,\\rho,s) = (2000, 1.0, 1.5, 1.0, 0.7, 12345)$。\n- 案例 B: $(n,\\beta_0,\\beta_1,\\pi,\\rho,s) = (2000, 0.0, 2.0, 0.2, 0.7, 54321)$。\n- 案例 C: $(n,\\beta_0,\\beta_1,\\pi,\\rho,s) = (2000, 0.5, 1.0, 0.8, 0.0, 202311)$。\n- 案例 D: $(n,\\beta_0,\\beta_1,\\pi,\\rho,s) = (50, -0.5, 1.2, 0.9, 0.8, 777)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由四个列表组成的逗号分隔列表，每个列表对应一个测试案例，顺序为 A、B、C、D。每个内部列表必须是 $[\\widehat{\\mathrm{Corr}}(x,u), \\widehat{\\mathrm{Corr}}(\\hat{x},u)]$ 的形式，其中每个条目都四舍五入到 $6$ 位小数。总输出必须是单行，格式严格遵循\n$[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$\n不含空格，其中 $a_j$ 和 $b_j$ 是案例 $j \\in \\{1,2,3,4\\}$ 所需的四舍五入后的浮点数。",
            "solution": "该问题陈述是有效的。它提出了一个定义明确的计量经济学计算任务，该任务在科学上是合理的、内部一致且客观的。其目标是数值上展示工具变量（IV）法的一个基本原理，特别是第一阶段投影在清除内生回归量与结构误差项的相关性方面的作用。\n\n结构模型由 $y_i = \\beta_0 + \\beta_1 x_i + u_i$ 给出，适用于每个观测值 $i \\in \\{1, \\dots, n\\}$。回归量 $x$ 是内生的，意味着它与误差项 $u$ 相关，形式上表示为 $\\mathrm{Cov}(x, u) \\ne 0$。这种相关性违反了普通最小二乘法（OLS）的核心假设，并使得 $\\beta_1$ 的 OLS 估计量不一致。这种内生性的来源是一个共同的未观测因素，通过误差分量 $u_i$ 和 $v_i$ 之间的相关性 $\\rho$ 进行建模。\n\n数据生成过程规定如下：\n$1$. 工具变量 $Z_i$ 从标准正态分布 $Z_i \\sim \\mathcal{N}(0,1)$ 中抽取。\n$2$. 误差分量 $(u_i, v_i)^\\top$ 从均值为 $\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$、协方差矩阵为 $\\begin{bmatrix}1  \\rho \\\\ \\rho  1\\end{bmatrix}$ 的二元正态分布中抽取。关键在于，工具变量 $\\{Z_i\\}$ 与误差分量 $\\{(u_i,v_i)\\}$ 独立。这使得 $Z$ 成为一个外生变量，因为 $\\mathrm{Cov}(Z_i, u_i) = 0$。\n$3$. 内生回归量通过第一阶段方程 $x_i = \\pi Z_i + v_i$ 构建。参数 $\\pi$ 控制工具变量的相关性；如果 $\\pi \\ne 0$，那么 $Z$ 是 $x$ 的一个相关工具变量。内生性的产生是因为 $\\mathrm{Cov}(x_i, u_i) = \\mathrm{Cov}(\\pi Z_i + v_i, u_i) = \\pi\\mathrm{Cov}(Z_i, u_i) + \\mathrm{Cov}(v_i, u_i) = 0 + \\rho = \\rho$。因此，当 $\\rho \\ne 0$ 时，我们就有了内生性。理论上的总体相关系数是 $\\mathrm{Corr}(x_i, u_i) = \\frac{\\rho}{\\sqrt{\\mathrm{Var}(x_i)\\mathrm{Var}(u_i)}} = \\frac{\\rho}{\\sqrt{(\\pi^2+1)(1)}} = \\frac{\\rho}{\\sqrt{\\pi^2+1}}$。我们的第一个计算任务是计算样本相关系数 $\\widehat{\\mathrm{Corr}}(x, u)$ 以确认模拟数据中存在这种内生性。\n\nIV方法的核心是分离出 $x$ 中仅由外生工具变量 $Z$ 引起的变动，从而创建一个与结构误差 $u$ 不相关的新变量。这是通过将向量 $x$ 正交投影到由工具变量张成的线性子空间上来实现的。在本问题中，工具变量是一个常数项和变量 $Z$。我们构建 $n \\times 2$ 的工具变量矩阵 $X = [\\mathbf{1} \\quad Z]$，其中 $\\mathbf{1}$ 是一个 $n \\times 1$ 的全一向量。\n\n$x$ 在 $X$ 的列空间上的投影由 $\\hat{x} = P x$ 给出，其中 $P = X(X^\\top X)^{-1}X^\\top$ 是投影矩阵。在计算上，$\\hat{x}$ 是将 $x$ 对 $X$ 进行 OLS 回归得到的拟合值。也就是说，我们在线性模型 $x = X\\gamma + \\text{residual}$ 中求解系数 $\\hat{\\gamma}$，得到 $\\hat{\\gamma} = (X^\\top X)^{-1}X^\\top x$。然后，投影向量为 $\\hat{x} = X\\hat{\\gamma}$。我们将采用一种数值上更稳定的方法，即使用最小二乘算法（例如，基于QR分解的算法）来求解 $\\hat{\\gamma}$，而不是显式地计算矩阵的逆。\n\n第二个计算任务是计算 $\\widehat{\\mathrm{Corr}}(\\hat{x}, u)$。根据构造，$\\hat{x}$ 是 $X$ 列向量的线性组合，具体为 $\\hat{x} = \\hat{\\gamma}_0 \\mathbf{1} + \\hat{\\gamma}_1 Z$。由于 $Z$ 是外生的（$\\mathrm{Cov}(Z, u) = 0$），且常数项也显然是外生的，因此它们的任何线性组合在总体中也必定与 $u$ 不相关。因此，我们预期样本相关系数 $\\widehat{\\mathrm{Corr}}(\\hat{x}, u)$ 会接近于 $0$，这反映了成功地从回归量中“清除”了内生性。该模拟将在各种参数设置下展示这一特性。\n\n对于每个测试案例 $(n, \\beta_0, \\beta_1, \\pi, \\rho, s)$，算法按以下步骤进行：\n$1$. 用给定的种子 $s$ 初始化一个伪随机数生成器。\n$2$. 根据指定的分布为 $Z$、$u$ 和 $v$ 生成 $n$ 个样本。\n$3$. 使用 $x_i = \\pi Z_i + v_i$ 构建向量 $x$。\n$4$. 使用标准样本相关系数公式计算并存储 $\\widehat{\\mathrm{Corr}}(x, u)$。\n$5$. 构建矩阵 $X = [\\mathbf{1} \\quad Z]$。\n$6$. 在 $x \\approx X\\gamma$ 中求解 $\\hat{\\gamma}$ 的最小二乘问题。\n$7$. 计算投影向量 $\\hat{x} = X\\hat{\\gamma}$。\n$8$. 计算并存储 $\\widehat{\\mathrm{Corr}}(\\hat{x}, u)$。\n$9$. 按要求将两个相关系数值四舍五入到 $6$ 位小数。\n然后将所有测试案例的结果汇总成指定的最终输出格式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the instrumental variables simulation problem for a given set of test cases.\n    \"\"\"\n    test_cases = [\n        # (n, beta_0, beta_1, pi, rho, s)\n        (2000, 1.0, 1.5, 1.0, 0.7, 12345),\n        (2000, 0.0, 2.0, 0.2, 0.7, 54321),\n        (2000, 0.5, 1.0, 0.8, 0.0, 202311),\n        (50, -0.5, 1.2, 0.9, 0.8, 777),\n    ]\n\n    all_results = []\n\n    for n, beta_0, beta_1, pi, rho, s in test_cases:\n        # 1. Set up the pseudorandom number generator for reproducibility.\n        rng = np.random.default_rng(s)\n\n        # 2. Generate data according to the Data-Generating Process (DGP).\n        # Draw the exogenous instrument Z.\n        Z = rng.normal(loc=0.0, scale=1.0, size=n)\n\n        # Draw the correlated error components (u, v).\n        mean_uv = [0, 0]\n        cov_uv = [[1, rho], [rho, 1]]\n        uv_draws = rng.multivariate_normal(mean_uv, cov_uv, size=n)\n        u = uv_draws[:, 0]\n        v = uv_draws[:, 1]\n\n        # Construct the endogenous regressor x.\n        x = pi * Z + v\n        \n        # Note: y is not needed for the requested calculations.\n        # y = beta_0 + beta_1 * x + u\n\n        # 3. Compute the sample correlation between original x and the error u.\n        # This demonstrates the endogeneity.\n        corr_xu = np.corrcoef(x, u)[0, 1]\n\n        # 4. Compute the orthogonal projection of x onto the space of instruments.\n        # The instruments are a constant and Z.\n        X_mat = np.c_[np.ones(n), Z]\n        \n        # Find the coefficients of the projection (first-stage regression).\n        # np.linalg.lstsq is a numerically stable way to solve this.\n        gamma_hat = np.linalg.lstsq(X_mat, x, rcond=None)[0]\n        \n        # Compute the projected vector x_hat.\n        x_hat = X_mat @ gamma_hat\n\n        # 5. Compute the sample correlation between the projected x_hat and the error u.\n        # This should be close to zero, demonstrating the \"purging\" of endogeneity.\n        corr_xhat_u = np.corrcoef(x_hat, u)[0, 1] if np.std(x_hat) > 1e-9 else 0.0 # handle case of zero variance if pi=0\n\n        # 6. Store the rounded results for this case.\n        result_pair = [round(corr_xu, 6), round(corr_xhat_u, 6)]\n        all_results.append(result_pair)\n\n    # 7. Print the final results in the specified format.\n    # The format is a string representation of a list of lists with no spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "一个有效的工具变量必须与内生变量相关，但当这种相关性很弱时会发生什么呢？本练习通过蒙特卡洛模拟，展示了使用弱工具变量对统计检验功效 (statistical power) 的影响。你将学会如何量化由第一阶段 F 统计量衡量的工具变量强度，如何直接影响你检测真实因果效应的能力，这是应用研究中一项至关重要的诊断技能 。",
            "id": "2402339",
            "problem": "构建一个程序，使用蒙特卡洛模拟来量化在线性工具变量设定中，弱工具变量如何影响原假设 $H_0:\\ \\beta=0$ 检验的实证功效。考虑以下针对单个内生回归量和单个工具变量（无截距项）的数据生成过程：\n- 对于每次重复以及对于每个观测索引 $i \\in \\{1,\\dots,n\\}$，抽取 $z_i \\sim \\mathcal{N}(0,1)$。\n- 抽取独立的标准正态扰动项 $e_{1i} \\sim \\mathcal{N}(0,1)$ 和 $e_{2i} \\sim \\mathcal{N}(0,1)$，并通过设置 $v_i = e_{1i}$ 和 $u_i = \\rho\\,e_{1i} + \\sqrt{1-\\rho^2}\\,e_{2i}$ 来构建相关系数为 $\\rho$ 的配对 $(v_i,u_i)$。\n- 设定 $x_i = \\pi\\,z_i + v_i$ 和 $y_i = \\beta\\,x_i + u_i$。\n\n对于每个大小为 $n$ 的模拟数据集，计算：\n1. 由样本矩条件 $\\frac{1}{n}\\sum_{i=1}^n z_i(y_i-\\beta x_i)=0$ 定义的 $\\beta$ 的恰好识别工具变量估计量，即\n$$\n\\hat{\\beta} = \\frac{\\sum_{i=1}^n z_i y_i}{\\sum_{i=1}^n z_i x_i}.\n$$\n2. 基于标量矩条件的相关传统大样本标准误，\n$$\n\\widehat{V}(\\hat{\\beta}) \\;=\\; \\frac{\\widehat{S}}{n\\,\\widehat{Q}^2},\\quad \\widehat{S}=\\frac{1}{n}\\sum_{i=1}^n (z_i\\hat{u}_i)^2,\\quad \\widehat{Q}=\\frac{1}{n}\\sum_{i=1}^n z_i x_i,\\quad \\hat{u}_i = y_i - \\hat{\\beta} x_i,\n$$\n以及对应的 $H_0:\\ \\beta=0$ 检验统计量，\n$$\nT \\;=\\; \\frac{\\hat{\\beta}-0}{\\sqrt{\\widehat{V}(\\hat{\\beta})}}.\n$$\n使用基于标准正态分位数 $c_\\alpha$ 的双侧拒绝法则，如果 $|T|>c_\\alpha$ 则拒绝 $H_0$，其中 $c_\\alpha$ 满足 $\\Pr(|Z|>c_\\alpha)=\\alpha$，对于 $Z\\sim \\mathcal{N}(0,1)$。\n\n3. 在 $x_i$ 对 $z_i$ 的回归中（无截距项）用于检验工具变量相关性的第一阶段 $F$-统计量，从普通最小二乘斜率 $\\hat{a} = \\frac{\\sum_{i=1}^n z_i x_i}{\\sum_{i=1}^n z_i^2}$ 计算得出，残差为 $r_i = x_i - \\hat{a} z_i$，残差方差为 $\\hat{\\sigma}^2 = \\frac{1}{n-1}\\sum_{i=1}^n r_i^2$，标准误为 $\\operatorname{se}(\\hat{a})=\\sqrt{\\hat{\\sigma}^2 / \\sum_{i=1}^n z_i^2}$，相应的 $t$-统计量为 $t_1=\\hat{a}/\\operatorname{se}(\\hat{a})$，并且 $F = t_1^2$。\n\n对于下面的每一组参数，将上述步骤重复 $R$ 次独立实验，并报告：\n- 实证功效，定义为当真实 $\\beta$ 不等于 $0$ 时，在显著性水平 $\\alpha$ 下拒绝原假设的重复次数所占的比例。\n- 在 $R$ 次重复实验中的平均第一阶段 $F$-统计量。\n\n使用以下参数值测试套件，每个都指定为元组 $(n,\\pi,\\rho,\\beta,\\alpha,R,\\text{seed})$：\n- 情况 A（强工具变量，大样本）：$(500,\\,0.5,\\,0.6,\\,1.0,\\,0.05,\\,1000,\\,123)$。\n- 情况 B（弱工具变量，大样本）：$(500,\\,0.05,\\,0.6,\\,1.0,\\,0.05,\\,1000,\\,456)$。\n- 情况 C（中等强度工具变量，小样本）：$(100,\\,0.35,\\,0.6,\\,1.0,\\,0.05,\\,1000,\\,789)$。\n\n您的程序必须：\n- 完全按照描述实现模拟。\n- 对于每种情况，计算 $R$ 次重复实验的实证功效和平均第一阶段 $F$-统计量。\n- 将每个报告值四舍五入到三位小数。\n- 生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果本身必须是按 $[\\text{功效}, \\text{平均F值}]$ 顺序排列的双元素列表。例如，一个包含三个案例的有效输出应如下所示：$[[0.842,12.531],[0.121,1.472],[0.563,6.214]]$。\n\n不涉及物理单位。所有数值答案必须是纯数字。不涉及角度。百分比必须表示为小数，而不是使用百分号。",
            "solution": "问题陈述经确认为科学上合理、提法明确且客观。它提出了一个计算计量经济学中的标准练习，目的是分析弱工具变量对假设检验统计功效的影响。解决方案通过指定的蒙特卡洛模拟构建。\n\n模拟的核心是一个含单个内生回归量 $x_i$ 和单个工具变量 $z_i$ 的线性模型的数据生成过程 (DGP)。该模型由两个方程定义：\n第一阶段方程 $x_i = \\pi z_i + v_i$ 将内生回归量 $x_i$ 与工具变量 $z_i$ 联系起来。参数 $\\pi$ 控制工具变量的强度。$\\pi$ 值接近于零表示“弱工具变量”，意味着 $z_i$ 对 $x_i$ 的解释力很小。\n结构方程 $y_i = \\beta x_i + u_i$ 定义了结果变量 $y_i$。内生性产生的原因是误差项 $v_i$ 和 $u_i$ 相关，相关性为 $\\text{Corr}(v_i, u_i) = \\rho$。这种相关性是通过独立的标准正态扰动项 $e_{1i} \\sim \\mathcal{N}(0,1)$ 和 $e_{2i} \\sim \\mathcal{N}(0,1)$ 显式构建的，具体方法是设置 $v_i = e_{1i}$ 和 $u_i = \\rho e_{1i} + \\sqrt{1-\\rho^2} e_{2i}$。这种相关性违反了普通最小二乘法中回归量与误差项不相关的假设，因此必须使用工具变量估计量。\n\n在一次模拟运行的 $R$ 次重复中，每次重复都会根据此 DGP 生成一个大小为 $n$ 的数据集。然后，计算以下量：\n\n1.  **工具变量估计量**：$\\beta$ 的恰好识别 IV 估计量是通过矩条件 $E[z_i(y_i - \\beta x_i)]=0$ 的样本模拟计算得出的。这得出了表达式 $\\hat{\\beta} = \\left(\\sum_{i=1}^n z_i y_i\\right) / \\left(\\sum_{i=1}^n z_i x_i\\right)$。只要工具变量是有效的，即相关的（$\\pi \\neq 0$）和外生的（$E[z_i u_i] = 0$，这通过构造是成立的），该估计量就是 $\\beta$ 的一致估计量。\n\n2.  **假设检验**：对原假设 $H_0: \\beta=0$ 进行 $t$-检验。检验统计量是 $T = (\\hat{\\beta} - 0) / \\sqrt{\\widehat{V}(\\hat{\\beta})}$，其中 $\\widehat{V}(\\hat{\\beta})$ 是 $\\hat{\\beta}$ 的估计方差。所提供的方差公式 $\\widehat{V}(\\hat{\\beta}) = \\widehat{S} / (n \\widehat{Q}^2)$，其中 $\\widehat{S}=\\frac{1}{n}\\sum_{i=1}^n (z_i\\hat{u}_i)^2$ 且 $\\widehat{Q}=\\frac{1}{n}\\sum_{i=1}^n z_i x_i$，是一种异方差稳健形式。如果检验统计量的绝对值 $|T|$ 超过了标准正态分布的临界值 $c_\\alpha$，则在显著性水平 $\\alpha$ 下拒绝原假设，其中 $c_\\alpha$ 的定义为 $\\Pr(|Z| > c_\\alpha) = \\alpha$，对于 $Z \\sim \\mathcal{N}(0,1)$。考虑到模拟中的真实值为 $\\beta \\neq 0$，检验的实证功效是在 $R$ 次重复中正确拒绝 $H_0$ 的比例。\n\n3.  **第一阶段 F-统计量**：作为工具变量强度的诊断方法，计算了 $x_i$ 对 $z_i$ 的第一阶段回归的 $F$-统计量。因为只有一个工具变量，所以这等价于 $z_i$ 系数 $\\hat{a}$ 的 $t$-统计量的平方。这个 $t$-统计量是 $t_1 = \\hat{a} / \\operatorname{se}(\\hat{a})$。平均 $F$-统计量较低（通常以低于 10 的值作为经验法则）是弱工具变量的一个广泛使用的指标。众所周知，这类工具变量会导致一些问题，包括有限样本中的有偏 IV 估计量和扭曲的检验水平。\n\n该程序针对三组不同的参数集实现了此模拟。这些情况旨在突出不同的情景：强工具变量（情况 A：$\\pi=0.5$）、弱工具变量（情况 B：$\\pi=0.05$）以及样本量较小的中等强度工具变量（情况 C：$n=100$，$\\pi=0.35$）。最终输出报告了每种情况下的计算出的实证功效和平均第一阶段 $F$-统计量，为工具变量强度和样本大小如何影响 IV 模型中统计推断的可靠性提供了定量说明。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef run_simulation(n, pi, rho, beta, alpha, R, seed):\n    \"\"\"\n    Runs a Monte Carlo simulation for the instrumental variables model.\n\n    Args:\n        n (int): Sample size.\n        pi (float): Instrument strength parameter.\n        rho (float): Correlation between structural and first-stage errors.\n        beta (float): True coefficient of the endogenous regressor.\n        alpha (float): Significance level for the hypothesis test.\n        R (int): Number of repetitions.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        tuple: A tuple containing the empirical power and the average F-statistic.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    rejection_count = 0\n    total_f_stat = 0.0\n\n    # Calculate the two-sided critical value from the standard normal distribution.\n    c_alpha = norm.ppf(1 - alpha / 2)\n\n    for _ in range(R):\n        # Step 1: Generate data according to the DGP\n        z = rng.normal(loc=0, scale=1, size=n)\n        e1 = rng.normal(loc=0, scale=1, size=n)\n        e2 = rng.normal(loc=0, scale=1, size=n)\n\n        v = e1\n        u = rho * e1 + np.sqrt(1 - rho**2) * e2\n        x = pi * z + v\n        y = beta * x + u\n\n        # Step 2: Compute the IV estimator for beta\n        sum_zy = np.dot(z, y)\n        sum_zx = np.dot(z, x)\n        \n        # Avoid division by zero, though highly unlikely with continuous variables\n        if sum_zx == 0:\n            continue\n            \n        beta_hat = sum_zy / sum_zx\n\n        # Step 3: Compute the t-statistic for H_0: beta = 0\n        u_hat = y - beta_hat * x\n        Q_hat = sum_zx / n\n        S_hat = np.mean((z * u_hat)**2)\n        \n        # Denominator of variance estimator\n        var_denom = n * Q_hat**2\n        if var_denom == 0:\n            continue\n\n        V_hat_beta_hat = S_hat / var_denom\n        \n        # Ensure variance is non-negative before taking square root\n        if V_hat_beta_hat < 0:\n            continue\n        \n        se_beta_hat = np.sqrt(V_hat_beta_hat)\n        \n        if se_beta_hat == 0:\n            continue\n            \n        t_stat = beta_hat / se_beta_hat\n\n        # Step 4: Perform the hypothesis test\n        if np.abs(t_stat) > c_alpha:\n            rejection_count += 1\n\n        # Step 5: Compute the first-stage F-statistic\n        sum_zz = np.dot(z, z)\n        \n        if sum_zz == 0:\n            continue\n\n        a_hat = sum_zx / sum_zz\n        r = x - a_hat * z\n        sigma2_hat = np.sum(r**2) / (n - 1)\n        se_a_hat = np.sqrt(sigma2_hat / sum_zz)\n        \n        if se_a_hat == 0:\n            continue\n\n        t1_stat = a_hat / se_a_hat\n        f_stat = t1_stat**2\n        total_f_stat += f_stat\n\n    empirical_power = rejection_count / R\n    average_f_stat = total_f_stat / R\n\n    return empirical_power, average_f_stat\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (n, pi, rho, beta, alpha, R, seed)\n        (500, 0.5, 0.6, 1.0, 0.05, 1000, 123),  # Case A\n        (500, 0.05, 0.6, 1.0, 0.05, 1000, 456), # Case B\n        (100, 0.35, 0.6, 1.0, 0.05, 1000, 789), # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        power, avg_f = run_simulation(*case)\n        # Format each result pair to 3 decimal places\n        power_str = f\"{power:.3f}\"\n        avg_f_str = f\"{avg_f:.3f}\"\n        results.append(f\"[{power_str},{avg_f_str}]\")\n\n    # Format the final output string as a list of lists\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}