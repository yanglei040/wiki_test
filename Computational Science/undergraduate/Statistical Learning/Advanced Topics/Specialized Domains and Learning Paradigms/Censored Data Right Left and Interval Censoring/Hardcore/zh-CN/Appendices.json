{
    "hands_on_practices": [
        {
            "introduction": "我们的实践探索之旅将从生存分析的基石——Kaplan-Meier估计量开始。这个练习不仅会指导你如何从右删失数据中计算生存概率，还将通过推导和应用Greenwood公式，让你理解估计结果的统计不确定性。掌握这项实践  对于准确描述和解读任何数据集中的生存模式至关重要。",
            "id": "3107041",
            "problem": "一项生物医学研究观察了右删失下的生存时间。对于受试者 $i$，设 $T_i$ 为失效时间，$C_i$ 为删失时间，且删失是独立的。观测数据为 $(X_i, \\Delta_i)$，其中 $X_i = \\min(T_i, C_i)$ 且 $\\Delta_i = \\mathbf{1}\\{T_i \\leq C_i\\}$。定义生存函数 $S(t) = \\mathbb{P}(T > t)$，累积风险函数 $\\Lambda(t) = \\int_0^t \\lambda(u)\\,\\mathrm{d}u$，以及根据在不同观测事件时间点的经验跳跃构建的 Kaplan–Meier (KM) 估计量 $\\hat{S}(t)$。该研究追踪了 $n = 10$ 名个体，其观测数据对为\n$$\n\\{(t_i, \\delta_i)\\}_{i=1}^{10} = \\{(1.5,1),\\ (2.0,0),\\ (3.0,1),\\ (4.0,1),\\ (5.5,0),\\ (6.0,1),\\ (7.0,0),\\ (7.5,1),\\ (8.0,1),\\ (9.0,0)\\},\n$$\n其中 $t_i$ 以月为单位，$\\delta_i \\in \\{0,1\\}$ 表示删失（$0$）或事件（$1$）。假设为非信息性右删失，且潜在的失效时间分布是连续的。\n\n从右删失的基本定义、风险过程 $Y(t) = \\sum_{i=1}^{n} \\mathbf{1}\\{X_i \\geq t\\}$ 和计数过程 $N(t) = \\sum_{i=1}^{n} \\mathbf{1}\\{X_i \\leq t,\\ \\Delta_i=1\\}$ 出发，通过以下步骤推导在固定时间 $t$ 处 $\\hat{S}(t)$ 的影响函数：\n- 建立在独立右删失下 $\\Lambda(t)$ 的 Nelson–Aalen 估计量的影响函数，\n- 应用泛函 delta 方法将累积风险函数映射到生存函数，\n- 仔细地对 $\\hat{S}(t)$ 的乘积极限形式进行线性化，以获得一个经过右删失调整的影响函数表示，从而导出被称为 Greenwood 公式的 $\\hat{S}(t)$ 的经典大样本方差。\n\n然后，使用所提供的数据集，计算在 $t = 8.0$ 个月时的 Kaplan–Meier 估计值 $\\hat{S}(t)$ 以及 $\\hat{S}(8.0)$ 的 Greenwood 大样本方差。将估计的渐近方差的最终数值表示为一个实数，并将您的答案四舍五入到四位有效数字。不需要物理单位。",
            "solution": "用户需要对一个生存分析问题进行详细的推导和计算。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件**\n\n- **模型：** 右删失生存数据。$T_i$ 是失效时间，$C_i$ 是删失时间。删失是独立的且非信息性的。\n- **观测数据：** 对于受试者 $i$，为 $(X_i, \\Delta_i)$，其中 $X_i = \\min(T_i, C_i)$ 且 $\\Delta_i = \\mathbf{1}\\{T_i \\leq C_i\\}$。\n- **定义：**\n    - 生存函数：$S(t) = \\mathbb{P}(T > t)$。\n    - 累积风险函数：$\\Lambda(t) = \\int_0^t \\lambda(u)\\,\\mathrm{d}u$。\n    - 风险过程：$Y(t) = \\sum_{i=1}^{n} \\mathbf{1}\\{X_i \\geq t\\}$。\n    - 计数过程：$N(t) = \\sum_{i=1}^{n} \\mathbf{1}\\{X_i \\leq t, \\Delta_i=1\\}$。\n    - Kaplan-Meier (KM) 估计量：$\\hat{S}(t)$。\n- **数据集：** $n = 10$ 名受试者，数据为 $\\{(t_i, \\delta_i)\\}_{i=1}^{10} = \\{(1.5,1), (2.0,0), (3.0,1), (4.0,1), (5.5,0), (6.0,1), (7.0,0), (7.5,1), (8.0,1), (9.0,0)\\}`。时间单位为月。\n- **任务：**\n    1. 遵循指定路径，涉及 Nelson-Aalen 估计量、泛函 delta 方法和乘积极限公式的线性化，推导 $\\hat{S}(t)$ 的影响函数，最终得到 Greenwood 方差公式。\n    2. 使用所提供的数据集，计算 $\\hat{S}(8.0)$ 及其使用 Greenwood 公式的大样本方差。\n\n**1.2. 使用提取的已知条件进行验证**\n\n- **结论：** 该问题有效。\n- **理由：**\n    - **科学上成立：** 该问题是生存分析中的一个标准练习，而生存分析是生物统计学和统计学习的核心课题。所有引入的概念——右删失、Kaplan-Meier 估计、Nelson-Aalen 估计、影响函数、计数过程和 Greenwood 公式——都是该领域中基础且成熟的概念。\n    - **提法明确：** 问题提供了进行推导和计算所需的所有数据和理论结构。要求具体，并能导向一个唯一且有意义的解。\n    - **客观：** 问题以精确、形式化的数学和统计语言陈述，没有歧义或主观性。\n    - 该问题不违反任何无效性标准。它在指定的科学领域内是一个完整、一致且可形式化的问题。\n\n### 步骤2：推导与求解\n\n求解过程分为两部分：首先是影响函数和方差的理论推导，其次是使用给定数据集进行数值计算。\n\n**第一部分：理论推导**\n\n主要目标是找到 $\\hat{S}(t) - S(t)$ 的一个渐近表示，该表示能揭示每个观测值的影响。这会引导我们得到影响函数和渐近方差的公式。\n\n**1.1. Nelson-Aalen 估计量的影响函数**\n\n累积风险函数 $\\Lambda(t) = \\int_0^t \\lambda(u)\\,\\mathrm{d}u$ 的 Nelson-Aalen (NA) 估计量由一个 Stieltjes 积分给出：\n$$\n\\hat{\\Lambda}_{NA}(t) = \\int_0^t \\frac{\\mathrm{d}N(u)}{Y(u)} = \\sum_{j: t_j \\leq t, \\delta_j=1} \\frac{1}{Y(t_j)}\n$$\n其中 $t_j$ 是不同的事件时间。\n\n为了理解 $\\hat{\\Lambda}_{NA}(t)$ 的性质，我们使用计数过程理论。对于每个受试者 $i$，我们定义计数过程 $N_i(t) = \\mathbf{1}\\{X_i \\leq t, \\Delta_i=1\\}$ 和风险过程 $Y_i(t) = \\mathbf{1}\\{X_i \\geq t\\}$。过程 $M_i(t) = N_i(t) - \\int_0^t Y_i(u)\\,\\mathrm{d}\\Lambda(u)$ 是一个零均值鞅。总过程为 $N(t) = \\sum_i N_i(t)$ 和 $Y(t) = \\sum_i Y_i(t)$，总鞅为 $M(t) = \\sum_i M_i(t)$。\n\n我们可以将差值 $\\hat{\\Lambda}_{NA}(t) - \\Lambda(t)$ 写为：\n$$\n\\hat{\\Lambda}_{NA}(t) - \\Lambda(t) = \\int_0^t \\frac{\\mathrm{d}N(u)}{Y(u)} - \\int_0^t \\mathrm{d}\\Lambda(u) = \\int_0^t \\frac{\\mathrm{d}N(u) - Y(u)\\mathrm{d}\\Lambda(u)}{Y(u)}\n$$\n代入 $\\mathrm{d}N(u) = \\mathrm{d}M(u) + Y(u)\\mathrm{d}\\Lambda(u)$，我们得到：\n$$\n\\hat{\\Lambda}_{NA}(t) - \\Lambda(t) = \\int_0^t \\frac{\\mathrm{d}M(u)}{Y(u)} = \\sum_{i=1}^n \\int_0^t \\frac{\\mathrm{d}M_i(u)}{Y(u)}\n$$\n对于大的 $n$，根据大数定律，$Y(u)/n \\to \\pi(u) = \\mathbb{P}(X_i \\geq u) = S(u-)P(C_i \\geq u-)$。因此，我们可以用 $n\\pi(u)$ 来近似 $Y(u)$。\n$$\n\\hat{\\Lambda}_{NA}(t) - \\Lambda(t) \\approx \\sum_{i=1}^n \\int_0^t \\frac{\\mathrm{d}M_i(u)}{n\\pi(u)} = \\frac{1}{n} \\sum_{i=1}^n \\int_0^t \\frac{\\mathrm{d}M_i(u)}{\\pi(u)}\n$$\n这个表示表明 $\\hat{\\Lambda}_{NA}(t) - \\Lambda(t)$ 渐近地是一个独立同分布项的和。第 $i$ 个受试者对 $\\hat{\\Lambda}_{NA}(t)$ 的影响函数（IF）是和式中的项：\n$$\nIF_i(\\hat{\\Lambda}_{NA}, t) = \\int_0^t \\frac{\\mathrm{d}M_i(u)}{\\pi(u)} = \\int_0^t \\frac{\\mathrm{d}N_i(u) - Y_i(u)\\mathrm{d}\\Lambda(u)}{\\pi(u)}\n= \\frac{\\Delta_i \\mathbf{1}\\{X_i \\leq t\\}}{\\pi(X_i)} - \\int_0^t \\frac{Y_i(u)\\mathrm{d}\\Lambda(u)}{\\pi(u)}\n$$\n\n**1.2. 从累积风险函数到生存函数**\n\nKaplan-Meier 估计量由乘积极限公式定义：\n$$\n\\hat{S}(t) = \\prod_{u \\leq t} \\left(1 - \\frac{\\mathrm{d}N(u)}{Y(u)}\\right)\n$$\n真实的生存函数可以表示为累积风险的乘积积分：$S(t) = \\prod_{u \\leq t}(1 - \\mathrm{d}\\Lambda(u))$。为了找到 $\\hat{S}(t)$ 的影响函数，我们对估计量进行线性化。一个常用的方法是首先对对数进行线性化：\n$$\n\\ln \\hat{S}(t) = \\sum_{u \\leq t} \\ln\\left(1 - \\frac{\\mathrm{d}N(u)}{Y(u)}\\right)\n$$\n对小的 $x$ 使用泰勒展开 $\\ln(1-x) \\approx -x$，并注意到 $\\mathrm{d}N(u)/Y(u)$ 很小，我们有：\n$$\n\\ln \\hat{S}(t) \\approx \\sum_{u \\leq t} -\\frac{\\mathrm{d}N(u)}{Y(u)} = -\\hat{\\Lambda}_{NA}(t)\n$$\n类似地，$\\ln S(t) = \\sum_{u \\leq t} \\ln(1 - \\mathrm{d}\\Lambda(u)) \\approx -\\int_0^t \\mathrm{d}\\Lambda(u) = -\\Lambda(t)$。\n这给出了近似 $\\ln \\hat{S}(t) - \\ln S(t) \\approx -(\\hat{\\Lambda}_{NA}(t) - \\Lambda(t))$。\n取指数并进行线性化 $\\exp(x) \\approx 1+x$ 得到：\n$$\n\\hat{S}(t) = S(t) \\exp(\\ln \\hat{S}(t) - \\ln S(t)) \\approx S(t) (1 + \\ln \\hat{S}(t) - \\ln S(t)) \\approx S(t) (1 - (\\hat{\\Lambda}_{NA}(t) - \\Lambda(t)))\n$$\n整理后得到关键关系：\n$$\n\\hat{S}(t) - S(t) \\approx -S(t) (\\hat{\\Lambda}_{NA}(t) - \\Lambda(t))\n$$\n这是泛函 delta 方法的一个应用，对于连续情况，其映射为 $\\phi(\\Lambda) = \\exp(-\\Lambda(t))$，其导数为 $-\\exp(-\\Lambda(t))=-S(t)$。基于 Duhamel 方程的更严谨的论证证实了这一结果。\n\n代入 $\\hat{\\Lambda}_{NA}(t)$ 的影响函数表示，我们得到 $\\hat{S}(t)$ 的影响函数：\n$$\nIF_i(\\hat{S}, t) = -S(t) IF_i(\\hat{\\Lambda}_{NA}, t) = -S(t) \\int_0^t \\frac{\\mathrm{d}M_i(u)}{\\pi(u)}\n$$\n\n**1.3. 渐近方差与 Greenwood 公式**\n\n$\\sqrt{n}(\\hat{S}(t) - S(t))$ 的渐近方差由影响函数的方差 $\\mathbb{E}[IF_i(\\hat{S},t)^2]$ 给出。\n$$\n\\text{Var}(\\sqrt{n}(\\hat{S}(t)-S(t))) \\approx \\mathbb{E}[IF_i(\\hat{S},t)^2] = S(t)^2 \\mathbb{E}\\left[ \\left(\\int_0^t \\frac{\\mathrm{d}M_i(u)}{\\pi(u)}\\right)^2 \\right]\n$$\n根据关于鞅的随机积分的性质，方差为：\n$$\n\\mathbb{E}\\left[\\int_0^t \\frac{\\mathrm{d}\\langle M_i \\rangle_u}{\\pi(u)^2}\\right] = \\int_0^t \\frac{\\mathbb{E}[\\mathrm{d}\\langle M_i \\rangle_u]}{\\pi(u)^2}\n$$\n可预测变差是 $\\mathrm{d}\\langle M_i \\rangle_u = Y_i(u)(1-\\mathrm{d}\\Lambda(u))\\mathrm{d}\\Lambda(u)$，其期望是 $\\pi(u)(1-\\mathrm{d}\\Lambda(u))\\mathrm{d}\\Lambda(u)$。\n因此，$\\sqrt{n}(\\hat{S}(t)-S(t))$ 的渐近方差是：\n$$\nS(t)^2 \\int_0^t \\frac{(1-\\mathrm{d}\\Lambda(u))\\mathrm{d}\\Lambda(u)}{\\pi(u)}\n$$\n为了从数据中估计这个方差，我们用经验对应量替换理论量。积分变成了对观测到的事件时间 $t_j$ 的求和。我们使用 $d_j/Y_j$ 来估计 $\\mathrm{d}\\Lambda(t_j)$，用 $Y_j/n$ 来估计 $\\pi(t_j)$。$\\hat{S}(t)$ 的方差估计量（未被 $\\sqrt{n}$ 缩放）是：\n$$\n\\widehat{\\text{Var}}(\\hat{S}(t)) = \\frac{1}{n} \\hat{S}(t)^2 \\left( \\sum_{j: t_j \\leq t} \\frac{(1-d_j/Y_j)(d_j/Y_j)}{Y_j/n} \\right) = \\hat{S}(t)^2 \\sum_{j: t_j \\leq t} \\frac{d_j(Y_j-d_j)}{Y_j^3}\n$$\n这个公式与 Greenwood 公式是渐近等价的。Greenwood 公式由有限样本（超几何）论证推导而来，由于其在小样本中表现更佳而通常被优先使用。其形式为：\n$$\n\\widehat{\\text{Var}}_{GW}(\\hat{S}(t)) = \\hat{S}(t)^2 \\sum_{j: t_j \\leq t} \\frac{d_j}{Y_j(Y_j - d_j)}\n$$\n对于大的 $Y_j$，$Y_j-d_j \\approx Y_j$，所以 $\\frac{d_j}{Y_j(Y_j-d_j)} \\approx \\frac{d_j}{Y_j^2}$，这与基于鞅的估计相差一个因子 $(Y_j-d_j)/Y_j$。两种方法都得到渐近等价的结果，这证明了使用 Greenwood 公式作为“经典大样本方差”的合理性。\n\n**第二部分：数值计算**\n\n我们为给定的数据计算 $\\hat{S}(8.0)$ 及其方差。排序后的观测时间为 $1.5_E, 2.0_C, 3.0_E, 4.0_E, 5.5_C, 6.0_E, 7.0_C, 7.5_E, 8.0_E, 9.0_C$，其中 E 表示事件，C 表示删失。不同的事件时间是 $1.5, 3.0, 4.0, 6.0, 7.5, 8.0$。由于所有事件时间都是唯一的，所以在每个事件时间 $t_j$ 的事件数 $d_j$ 均为 1。\n\n我们构建 Kaplan-Meier 表：\n- $t_j$：不同的事件时间。\n- $Y_j = Y(t_j)$：在时间 $t_j$ 前刻处于风险中的受试者数量。\n- $d_j$：在时间 $t_j$ 的事件数量。\n\n| 事件时间 $t_j$ | 风险人数 $Y_j$ | 事件数 $d_j$ | 生存因子 $(1-d_j/Y_j)$ | KM 估计值 $\\hat{S}(t_j)$ | Greenwood 项 $\\frac{d_j}{Y_j(Y_j-d_j)}$ |\n|---|---|---|---|---|---|\n| $1.5$ | $10$ | $1$ | $1 - \\frac{1}{10} = 0.9$ | $1.0 \\times 0.9 = 0.90$ | $\\frac{1}{10(9)} = \\frac{1}{90}$ |\n| $3.0$ | $8$ | $1$ | $1 - \\frac{1}{8} = 0.875$ | $0.90 \\times 0.875 = 0.7875$ | $\\frac{1}{8(7)} = \\frac{1}{56}$ |\n| $4.0$ | $7$ | $1$ | $1 - \\frac{1}{7} \\approx 0.8571$ | $0.7875 \\times \\frac{6}{7} \\approx 0.675$ | $\\frac{1}{7(6)} = \\frac{1}{42}$ |\n| $6.0$ | $5$ | $1$ | $1 - \\frac{1}{5} = 0.8$ | $0.675 \\times 0.8 = 0.54$ | $\\frac{1}{5(4)} = \\frac{1}{20}$ |\n| $7.5$ | $3$ | $1$ | $1 - \\frac{1}{3} \\approx 0.6667$ | $0.54 \\times \\frac{2}{3} = 0.36$ | $\\frac{1}{3(2)} = \\frac{1}{6}$ |\n| $8.0$ | $2$ | $1$ | $1 - \\frac{1}{2} = 0.5$ | $0.36 \\times 0.5 = 0.18$ | $\\frac{1}{2(1)} = \\frac{1}{2}$ |\n\n**2.1. $\\hat{S}(8.0)$ 的计算**\n\n在 $t=8.0$ 时的 Kaplan-Meier 估计值是在 $t=8.0$ 事件发生后计算的值。\n$$\n\\hat{S}(8.0) = \\left(1-\\frac{1}{10}\\right)\\left(1-\\frac{1}{8}\\right)\\left(1-\\frac{1}{7}\\right)\\left(1-\\frac{1}{5}\\right)\\left(1-\\frac{1}{3}\\right)\\left(1-\\frac{1}{2}\\right)\n$$\n$$\n\\hat{S}(8.0) = \\frac{9}{10} \\times \\frac{7}{8} \\times \\frac{6}{7} \\times \\frac{4}{5} \\times \\frac{2}{3} \\times \\frac{1}{2}\n$$\n$$\n\\hat{S}(8.0) = \\frac{9 \\times 7 \\times 6 \\times 4 \\times 2 \\times 1}{10 \\times 8 \\times 7 \\times 5 \\times 3 \\times 2} = \\frac{9 \\times 6 \\times 4}{10 \\times 8 \\times 5 \\times 3} = \\frac{216}{1200} = \\frac{9}{50} = 0.18\n$$\n\n**2.2. $\\hat{S}(8.0)$ 方差的计算**\n\n我们使用 Greenwood 公式：$\\widehat{\\text{Var}}_{GW}(\\hat{S}(t)) = \\hat{S}(t)^2 \\sum_{j: t_j \\leq t} \\frac{d_j}{Y_j(Y_j - d_j)}$。对于 $t=8.0$，求和包括了表中计算的所有项。\n$$\n\\sum_{j: t_j \\leq 8.0} \\frac{d_j}{Y_j(Y_j-d_j)} = \\frac{1}{90} + \\frac{1}{56} + \\frac{1}{42} + \\frac{1}{20} + \\frac{1}{6} + \\frac{1}{2}\n$$\n为了对分数求和，我们找到一个公分母。 $90, 56, 42, 20, 6, 2$ 的最小公倍数是 $2520$。\n$$\n\\text{和} = \\frac{28}{2520} + \\frac{45}{2520} + \\frac{60}{2520} + \\frac{126}{2520} + \\frac{420}{2520} + \\frac{1260}{2520} = \\frac{28+45+60+126+420+1260}{2520} = \\frac{1939}{2520}\n$$\n现在，我们可以计算方差：\n$$\n\\widehat{\\text{Var}}_{GW}(\\hat{S}(8.0)) = (\\hat{S}(8.0))^2 \\times \\frac{1939}{2520} = (0.18)^2 \\times \\frac{1939}{2520}\n$$\n$$\n\\widehat{\\text{Var}}_{GW}(\\hat{S}(8.0)) = 0.0324 \\times \\frac{1939}{2520} \\approx 0.0324 \\times 0.769444... \\approx 0.02492999...\n$$\n将最终值四舍五入到四位有效数字得到 $0.02493$。",
            "answer": "$$\\boxed{0.02493}$$"
        },
        {
            "introduction": "在描述生存曲线之后，我们通常希望理解不同因素如何影响生存时间。Cox比例风险模型是实现这一目标的强大工具，但其有效性依赖于关键的假设。这项实践  深入探讨了模型诊断这一核心技能，教你如何利用不同类型的残差来检验模型拟合情况，并验证至关重要的比例风险假设，从而确保你的分析结论是稳健和可靠的。",
            "id": "3107112",
            "problem": "一项临床研究跟踪了 $n=200$ 名患者，其协变量向量为 $X_i$，事件时间为 $T_i$。由于随访在固定的管理时间 $C_i$ 结束，许多事件未被观测到；观测时间为 $U_i = \\min(T_i, C_i)$，指示符 $\\delta_i = \\mathbf{1}\\{T_i \\le C_i\\}$ 编码了右删失。在这项研究中，大约 $80\\%$ 的患者是右删失的，即对于大约 $80\\%$ 的 $i$，有 $\\delta_i=0$。\n\n假设拟合了 Cox 比例风险 (Proportional Hazards (PH)) 模型，其风险函数为 $\\lambda(t \\mid X_i) = \\lambda_0(t)\\exp(X_i^\\top \\beta)$，并且您希望使用基于残差的诊断来评估两个方面：(i) 在重度右删失情况下，残差（对比鞅残差与偏差残差）在检测协变量函数形式方面的适用性，以及 (ii) 使用 Schoenfeld 残差判断某一特定系数 $\\beta_k$ 是否可能随时间变化，即 $\\beta_k(t)$。\n\n基于右删失、风险函数和 Cox 比例风险模型的基本定义，选择一个选项，该选项正确地对比了重度右删失情况下鞅残差与偏差残差的行为，并提出了一种使用 Schoenfeld 残差检测时变效应 $\\beta_k(t)$ 的科学有效诊断方法。\n\nA. 在重度右删失下，鞅残差高度偏斜，具有长的负向拖尾，且上界为 $1$，因此偏差残差更受青睐，因为它们能近似地使鞅残差对称化并稳定其尺度。为了诊断协变量 $X_k$ 的时变效应，计算事件时间点的标准化 Schoenfeld 残差，并将其对时间的函数（例如 $\\log(t)$）进行回归，检验斜率是否非零；显著的趋势表明 $\\beta_k(t)$ 随时间变化。\n\nB. 在重度右删失下，偏差残差比鞅残差更偏斜，因为许多个体观测到的事件为 $0$；因此，鞅残差更受青睐。为了诊断时变效应，在每个随访时间点对所有个体的 Schoenfeld 残差求平均，并检验其均值是否为零；偏离零意味着没有时变效应。\n\nC. 在重度右删失下，鞅残差和偏差残差都是对称的且均值为零，因此它们之间的选择无关紧要。为了诊断时变效应，将 $X_k$ 的 Schoenfeld 残差对协变量 $X_k$ 本身进行回归，并检验斜率是否不为零；非零斜率表示 $\\beta_k(t)$ 存在时间变异性。\n\nD. 在重度右删失下，鞅残差倾向于紧密聚集在零附近，但偏差残差会膨胀到非常大的正值；因此，应避免使用偏差残差。为了诊断时变效应，在事件时间和删失时间计算 Schoenfeld 残差，并检验其与 $\\log(t)$ 的独立性。",
            "solution": "问题陈述在生存分析和统计学习领域内提出了一个有效的问题，特别是有关于 Cox 比例风险模型的诊断程序。其设置是标准的，术语是精确的，重度删失的背景是一个定义明确且常见的实践挑战。所有元素都具有科学依据并且可以形式化。因此，我们可以进行完整的解答。\n\n问题要求评估 Cox 模型残差诊断的两个不同方面：\n1.  在重度右删失下，用于评估协变量函数形式的鞅残差与偏差残差的性质及相对适用性。\n2.  使用 Schoenfeld 残差检验时变系数（即违反比例风险 (PH) 假设）的正确程序。\n\n**第 1 部分：鞅残差与偏差残差**\n\nCox 模型中个体 $i$ 的鞅残差定义为：\n$$M_i = \\delta_i - \\hat{\\Lambda}(U_i \\mid X_i) = \\delta_i - \\hat{\\Lambda}_0(U_i) \\exp(X_i^\\top \\hat{\\beta})$$\n其中 $\\delta_i$ 是事件指示符（如果发生事件则为 $1$，如果删失则为 $0$），$U_i$ 是观测到的随访时间，$\\hat{\\Lambda}(U_i \\mid X_i)$ 是个体 $i$ 在时间 $U_i$ 的估计累积风险。\n\n鞅残差的范围是 $(-\\infty, 1]$。\n-   如果个体 $i$ 在时间 $U_i$ 被删失，则 $\\delta_i = 0$，残差为 $M_i = -\\hat{\\Lambda}(U_i \\mid X_i)$。该值始终为负。\n-   如果个体 $i$ 在时间 $U_i$ 经历事件，则 $\\delta_i = 1$，残差为 $M_i = 1 - \\hat{\\Lambda}(U_i \\mid X_i)$。该值通常为正或接近于零，因为在大多数事件时间点之前的累积风险通常小于 $1$。\n\n问题陈述中提到大约 $80\\%$ 的个体是右删失的。这意味着大约 $80\\%$ 的鞅残差将是负的（对应于 $\\delta_i = 0$），而只有大约 $20\\%$ 对应于事件（$\\delta_i = 1$）。这种不平衡导致鞅残差的分布高度偏斜，有大量的负值和一条长的负向拖尾。例如，在将这些偏斜的残差与协变量作图以检查非线性函数形式时，它们很难进行视觉解释。\n\n偏差残差是为解决这种偏度而设计的对鞅残差的一种变换。偏差残差 $D_i$ 由下式给出：\n$$D_i = \\text{sign}(M_i) \\sqrt{-2[M_i + \\delta_i \\log(\\delta_i - M_i)]}$$\n其中对 $\\delta_i=0$ 的情况，$\\log$ 项会进行适当处理。这种变换使残差的分布“对称化”，使其看起来更像标准线性回归模型中的残差，如果模型指定正确，理想情况下应服从标准正态分布。通过创建一个更对称、偏度更小的分布，偏差残差通常被认为在图形诊断（如检测非线性或识别异常值）方面优于鞅残差，尤其是在重度删失情况下，鞅残差的偏度最为明显。\n\n**第 2 部分：用于时变效应的 Schoenfeld 残差**\n\nCox 模型所基于的比例风险假设指出，任何两个个体之间的风险比随时间是恒定的。对于特定的协变量 $X_k$，这意味着其系数 $\\beta_k$ 是恒定的。一个时变系数 $\\beta_k(t)$ 违反了这一假设。\n\nSchoenfeld 残差是专门为诊断此类违规而设计的。对于在时间 $t_j$ 发生的每个事件，都会为每个协变量 $k$ 计算一个 Schoenfeld 残差。该残差是发生事件的个体 $j$ 的协变量值 $X_{jk}$ 与当时风险集 $R(t_j)$ 中所有个体的该协变量期望值之差：\n$$r_{jk} = X_{jk} - E[X_k \\mid R(t_j)] = X_{jk} - \\frac{\\sum_{i \\in R(t_j)} X_{ik} \\exp(X_i^\\top \\hat{\\beta})}{\\sum_{i \\in R(t_j)} \\exp(X_i^\\top \\hat{\\beta})}$$\n关键的是，这些残差**仅在事件时间点**定义。\n\n在比例风险假设下（即 $\\beta_k$ 是恒定的），协变量 $k$ 的 Schoenfeld 残差在所有时间 $t$ 的期望值为零。因此，Schoenfeld 残差 $r_{jk}$ 对时间 $t_j$ 的图应显示为围绕零的随机散点。如果 $\\beta_k(t)$ 不是恒定的，此图中将出现系统性趋势。\n\n检验时变效应的正式方法涉及将（标准化的）Schoenfeld 残差对时间的函数 $g(t)$ 进行回归。$g(t)$ 的常见选择包括 $t$ 本身，或 $\\log(t)$，后者可能更适合捕捉某些偏离模式。该检验的模型为：\n$$r^*_{jk} = \\gamma_0 + \\gamma_1 g(t_j) + \\epsilon_j$$\n其中 $r^*_{jk}$ 是标准化的 Schoenfeld 残差。统计上显著的非零斜率（$\\gamma_1 \\neq 0$）提供了反对比例风险假设的证据，表明协变量 $X_k$ 的效应随时间变化。\n\n**选项评估**\n\n**A. 在重度右删失下，鞅残差高度偏斜，具有长的负向拖尾，且上界为 $1$，因此偏差残差更受青睐，因为它们能近似地使鞅残差对称化并稳定其尺度。为了诊断协变量 $X_k$ 的时变效应，计算事件时间点的标准化 Schoenfeld 残差，并将其对时间的函数（例如 $\\log(t)$）进行回归，检验斜率是否非零；显著的趋势表明 $\\beta_k(t)$ 随时间变化。**\n该选项正确描述了重度删失下鞅残差和偏差残差的性质，以及在此背景下偏好偏差残差的理由。它还准确地概述了使用 Schoenfeld 残差检验比例风险假设的标准、科学有效程序。\n**结论：正确。**\n\n**B. 在重度右删失下，偏差残差比鞅残差更偏斜，因为许多个体观测到的事件为 $0$；因此，鞅残差更受青睐。为了诊断时变效应，在每个随访时间点对所有个体的 Schoenfeld 残差求平均，并检验其均值是否为零；偏离零意味着没有时变效应。**\n该选项在两点上都是错误的。首先，根据设计，偏差残差的偏度*小于*鞅残差。其次，Schoenfeld 残差的程序被错误陈述：它们仅在事件时间点计算，检验的是随时间的趋势（而不是静态均值），并且最后一句（“偏离零意味着没有时变效应”）与正确解释相反。\n**结论：错误。**\n\n**C. 在重度右删失下，鞅残差和偏差残差都是对称的且均值为零，因此它们之间的选择无关紧要。为了诊断时变效应，将 $X_k$ 的 Schoenfeld 残差对协变量 $X_k$ 本身进行回归，并检验斜率是否不为零；非零斜率表示 $\\beta_k(t)$ 存在时间变异性。**\n该选项是错误的。在重度删失下，鞅残差不是对称的。此外，它建议将 Schoenfeld 残差对协变量 $X_k$ 进行回归，这是一个检查函数形式（线性）的程序，而不是检验比例风险假设（时间不变性）的程序。检验时间变异性需要将残差与时间关联起来。\n**结论：错误。**\n\n**D. 在重度右删失下，鞅残差倾向于紧密聚集在零附近，但偏差残差会膨胀到非常大的正值；因此，应避免使用偏差残差。为了诊断时变效应，在事件时间和删失时间计算 Schoenfeld 残差，并检验其与 $\\log(t)$ 的独立性。**\n该选项对残差的行为给出了错误的描述。在重度删失下，大多数鞅残差是大的负值，而不是聚集在零附近。偏差残差不会“膨胀到非常大的正值”。对 Schoenfeld 残差检验的描述也存在根本性缺陷，因为这些残差在删失时间点没有定义。\n**结论：错误。**\n\n基于此分析，只有选项 A 提供了对统计概念和程序的正确且连贯的说明。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "虽然像Cox模型这样的经典模型功能强大，但现代机器学习为生存分析提供了全新的、更灵活的思路。这项练习  介绍了一种离散时间框架，它构成了许多先进生存模型（包括基于神经网络的模型）的基础。通过推导和实现该方法的似然函数，你将亲身体验一种通用技术，它直接对特定时间区间内的事件发生条件概率进行建模，从而架起了传统统计学与现代机器学习之间的桥梁。",
            "id": "3107045",
            "problem": "您的任务是推导并实现两种在右删失情况下用于学习风险函数的生存分析目标函数。考虑一个随机生存时间 $T \\in \\mathbb{R}_{\\ge 0}$ 和协变量 $\\mathbf{X} \\in \\mathbb{R}^{p}$。在右删失情况下，每个观测对象 $i$ 提供 $(t_i, \\delta_i, \\mathbf{x}_i)$，其中 $t_i$ 是观测时间，$\\delta_i \\in \\{0,1\\}$ 指示事件是否发生（$\\delta_i = 1$）或观测是否被删失（$\\delta_i = 0$），$\\mathbf{x}_i$ 是协变量。时间以天为单位。要求的所有输出都是无量纲实数；最终输出不需要物理单位。\n\n目标是通过将时间离散化为若干区间并使用右删失下的交叉熵损失来学习风险函数 $h(t \\mid \\mathbf{X})$，并将其与Cox比例风险(CPH)偏似然训练目标进行数值比较。您必须从基本定义出发推导这两个目标，并为指定的测试用例实现它们。\n\n需要使用的基本定义：\n\n- 生存函数为 $S(t \\mid \\mathbf{X}) = \\mathbb{P}(T > t \\mid \\mathbf{X})$。\n- （瞬时）风险函数为 $h(t \\mid \\mathbf{X}) = \\lim_{\\Delta t \\to 0^{+}} \\frac{\\mathbb{P}(t \\le T  t+\\Delta t \\mid T \\ge t, \\mathbf{X})}{\\Delta t}$。\n- 对于离散时间建模，设时间分区由区间边界 $0 = b_0  b_1  \\dots  b_K$ 给出，区间为 $B_k = [b_{k-1}, b_k)$，其中 $k = 1,\\dots,K$。第 $k$ 个区间的离散风险是条件概率 $p_k(\\mathbf{X}) = \\mathbb{P}(T \\in B_k \\mid T \\ge b_{k-1}, \\mathbf{X})$。\n- 假设一个分段逻辑斯蒂模型 $p_k(\\mathbf{X}) = \\sigma(\\alpha_k + \\boldsymbol{\\beta}^{\\top}\\mathbf{X})$，其中 $\\sigma(u) = \\frac{1}{1 + e^{-u}}$，$\\alpha_k \\in \\mathbb{R}$ 是未知的区间截距项，$\\boldsymbol{\\beta} \\in \\mathbb{R}^{p}$ 是共享的系数向量。\n\n基于这些定义，您必须：\n\n1. 根据分段离散风险 $p_k(\\mathbf{X})$ 推导右删失下的离散时间似然，清楚地区分在区间 $m$ 中发生事件的未删失对象和在时间 $t$ 观测到的删失对象（其时间可能落在某个区间内）的贡献。证明负对数似然可以写成在风险区间上的交叉熵形式，其中一个对象为在观测时间之前完全经过的区间贡献生存项，如果发生事件，则在事件区间贡献一个事件项。阐明如何处理删失时间严格位于区间内部的删失观测：仅对右边界 $b_k$ 满足 $b_k \\le t$ 的区间包含生存项，而不对包含 $t$ 的区间包含任何项。\n2. 从Cox比例风险(CPH)模型 $h(t \\mid \\mathbf{X}) = h_0(t)\\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{X})$ 出发，推导针对不同事件时间的CPH偏似然及其负对数形式。将每个事件时间 $t_i$ 的风险集 $R(t_i)$ 定义为观测时间至少为 $t_i$ 的对象集合。基准风险 $h_0(t)$ 在偏似然中被消去。说明事件时间重复需要特殊处理，但所提供的测试用例将具有不同的事件时间，因此不需要进行重复时间处理。\n\n您必须实现一个程序，在给定指定的测试套件的情况下，计算：\n\n- 使用您推导出的交叉熵和分段逻辑斯蒂风险计算的离散时间负对数似然 $L_{\\text{disc}}$。\n- 使用您的推导，其中风险集由观测时间定义且仅考虑事件（$\\delta_i = 1$）的Cox偏负对数似然 $L_{\\text{cox}}$。\n- 差值 $L_{\\text{diff}} = L_{\\text{disc}} - L_{\\text{cox}}$。\n\n测试套件：\n\n对于下面的每个测试用例，都给定了协变量、观测时间（天）、事件指示符、区间边界、区间截距项和系数向量。\n\n- 案例1（一般情况，混合事件与删失）：\n  - 区间边界：$[0, 2, 5, 10]$，所以 $K=3$ 个区间。\n  - 区间截距项：$(\\alpha_1, \\alpha_2, \\alpha_3) = (-2.0, -1.0, -0.5)$。\n  - 系数：$\\boldsymbol{\\beta} = (0.5, -0.3)$。\n  - 观测数据：五个对象\n    - $\\mathbf{x}_1 = (1.0, 0.5)$, $t_1 = 1.5$, $\\delta_1 = 1$。\n    - $\\mathbf{x}_2 = (-0.5, 1.0)$, $t_2 = 3.0$, $\\delta_2 = 1$。\n    - $\\mathbf{x}_3 = (0.3, -0.2)$, $t_3 = 7.0$, $\\delta_3 = 1$。\n    - $\\mathbf{x}_4 = (1.5, 0.0)$, $t_4 = 4.0$, $\\delta_4 = 0$。\n    - $\\mathbf{x}_5 = (-1.2, 2.0)$, $t_5 = 9.0$, $\\delta_5 = 0$。\n- 案例2（边缘情况，全部删失且部分删失发生在区间内部）：\n  - 区间边界：$[0, 2, 5, 8]$，所以 $K=3$ 个区间。\n  - 区间截距项：$(\\alpha_1, \\alpha_2, \\alpha_3) = (-2.2, -1.3, -0.8)$。\n  - 系数：$\\boldsymbol{\\beta} = (0.4, 0.2)$。\n  - 观测数据：四个对象，全部删失\n    - $\\mathbf{x}_1 = (0.0, 1.0)$, $t_1 = 1.8$, $\\delta_1 = 0$。\n    - $\\mathbf{x}_2 = (-1.0, 0.5)$, $t_2 = 2.2$, $\\delta_2 = 0$。\n    - $\\mathbf{x}_3 = (0.3, 0.3)$, $t_3 = 4.9$, $\\delta_3 = 0$。\n    - $\\mathbf{x}_4 = (0.5, -0.2)$, $t_4 = 6.0$, $\\delta_4 = 0$。\n- 案例3（边界条件，事件发生在第一个和最后一个区间，删失时间靠近区间边界）：\n  - 区间边界：$[0, 2, 8]$，所以 $K=2$ 个区间。\n  - 区间截距项：$(\\alpha_1, \\alpha_2) = (-1.5, -0.2)$。\n  - 系数：$\\boldsymbol{\\beta} = (-0.1, 0.6)$。\n  - 观测数据：四个对象\n    - $\\mathbf{x}_1 = (0.2, 1.0)$, $t_1 = 0.5$, $\\delta_1 = 1$。\n    - $\\mathbf{x}_2 = (-0.7, 0.8)$, $t_2 = 1.9$, $\\delta_2 = 0$。\n    - $\\mathbf{x}_3 = (1.2, -0.4)$, $t_3 = 7.5$, $\\delta_3 = 1$。\n    - $\\mathbf{x}_4 = (-0.3, 0.1)$, $t_4 = 7.9$, $\\delta_4 = 0$。\n\n实现要求：\n\n- 对于离散时间目标，对于在区间 $m$ 中时间 $t_i$ 发生的事件，包含对区间 $k = 1,\\dots,m-1$ 的生存贡献项和对区间 $m$ 的事件贡献项。对于严格落在某个区间内的删失观测（时间为 $t_i$），仅包括右边界 $b_k$ 满足 $b_k \\le t_i$ 的区间的生存贡献项；不包括包含 $t_i$ 的那个区间的任何项。\n- 对于Cox偏似然，只考虑 $\\delta_i = 1$ 的对象，并假设所有事件时间都不同。对于每个事件时间 $t_i$，使用事件和删失观测的观测时间 $t_j$ 来定义风险集 $R(t_i) = \\{ j : t_j \\ge t_i \\}$。使用线性预测器 $\\eta_j = \\boldsymbol{\\beta}^{\\top}\\mathbf{x}_j$。\n- 对逻辑斯蒂函数和对数求和使用数值稳定的计算方法。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为用逗号分隔并由方括号括起的列表。对于每个测试用例，按 $[L_{\\text{disc}}, L_{\\text{cox}}, L_{\\text{diff}}]$ 的顺序输出三个浮点数，并按顺序将所有测试用例的结果聚合起来，形成一个九元素的列表。例如，最终输出应类似于 \"[l1_disc,l1_cox,l1_diff,l2_disc,l2_cox,l2_diff,l3_disc,l3_cox,l3_diff]\"。不应打印任何额外文本。",
            "solution": "该问题要求推导并实现用于右删失数据生存分析的两个目标函数：一个离散时间负对数似然函数和Cox偏负对数似然函数。\n\n**离散时间负对数似然($L_{\\text{disc}}$)的推导**\n\n我们首先对离散时间中的生存过程进行建模。时间轴被划分为$K$个区间，$B_k = [b_{k-1}, b_k)$，其中$k \\in \\{1, \\dots, K\\}$且$b_0 = 0$。在生存到区间$k$开始的条件下，该区间的离散风险表示为$p_k(\\mathbf{X}) = \\mathbb{P}(T \\in B_k \\mid T \\ge b_{k-1}, \\mathbf{X})$。因此，在生存到$b_{k-1}$的条件下，安全度过区间$k$的概率是$1 - p_k(\\mathbf{X})$。在区间边界$b_m$处的生存函数是安全度过所有先前区间的累积概率：$S(b_m \\mid \\mathbf{X}) = \\mathbb{P}(T > b_m \\mid \\mathbf{X}) = \\prod_{k=1}^{m} (1 - p_k(\\mathbf{X}))$。\n\n似然函数$L$是每个独立对象$i=1, \\dots, N$的似然贡献$L_i$的乘积。每个对象提供一个观测值$(t_i, \\delta_i, \\mathbf{x}_i)$，其中$t_i$是观测时间，$\\delta_i \\in \\{0, 1\\}$是事件指示符，$\\mathbf{x}_i$是协变量。我们确定$t_i$所在的区间$m_i$，使得$t_i \\in [b_{m_i-1}, b_{m_i})$。\n\n1.  **未删失对象($\\delta_i=1$)的贡献**：事件在时间$t_i$发生于区间$m_i$内。这意味着该对象安全度过了区间$1, \\dots, m_i-1$，然后在区间$m_i$内经历了事件。这个序列的概率是：\n    $$L_i = \\mathbb{P}(T \\ge b_{m_i-1} \\mid \\mathbf{x}_i) \\cdot \\mathbb{P}(T \\in B_{m_i} \\mid T \\ge b_{m_i-1}, \\mathbf{x}_i) = S(b_{m_i-1} \\mid \\mathbf{x}_i) \\cdot p_{m_i}(\\mathbf{x}_i)$$\n    $$L_i = \\left( \\prod_{k=1}^{m_i-1} (1-p_k(\\mathbf{x}_i)) \\right) p_{m_i}(\\mathbf{x}_i)$$\n\n2.  **删失对象($\\delta_i=0$)的贡献**：已知该对象在时间$t_i$时仍然存活。根据问题规范，我们只包括那些右边界$b_k$小于或等于$t_i$的区间$k$的生存项。由于$t_i \\in [b_{m_i-1}, b_{m_i})$，满足此条件的区间是$1, \\dots, m_i-1$。因此，似然贡献是安全度过区间$m_i-1$的概率：\n    $$L_i = \\mathbb{P}(T > b_{m_i-1} \\mid \\mathbf{x}_i) = S(b_{m_i-1} \\mid \\mathbf{x}_i) = \\prod_{k=1}^{m_i-1} (1-p_k(\\mathbf{x}_i))$$\n\n总对数似然$\\ell = \\sum_{i=1}^N \\log L_i$。对于对象$i$，对数似然为：\n$$\\log L_i = \\delta_i \\log p_{m_i}(\\mathbf{x}_i) + \\sum_{k=1}^{m_i-1} \\log(1-p_k(\\mathbf{x}_i))$$\n这个结构表明，似然函数是类似于交叉熵损失的项的总和。对于每个对象$i$和每个区间$k$，我们可以想象一个二元结果：事件或生存。对于区间$k  m_i$，对象存活下来，我们加上生存的对数概率$\\log(1-p_k)$。如果事件发生在区间$m_i$内，我们加上事件的对数概率$\\log p_{m_i}$。总对数似然是所有对象在其各自时间区间上的这些对数概率的总和。\n\n模型假设风险具有分段逻辑斯蒂形式：$p_k(\\mathbf{X}) = \\sigma(\\eta_k(\\mathbf{X}))$，其中$\\eta_k(\\mathbf{X}) = \\alpha_k + \\boldsymbol{\\beta}^{\\top}\\mathbf{X}$且$\\sigma(u) = 1/(1+e^{-u})$是sigmoid函数。我们使用恒等式$\\log \\sigma(u) = -\\log(1+\\exp(-u))$和$\\log(1-\\sigma(u)) = \\log\\sigma(-u) = -\\log(1+\\exp(u))$。对象$i$的负对数似然（其中$\\eta_{ik} = \\eta_k(\\mathbf{x}_i)$）是：\n$$-\\log L_i = -\\left( \\delta_i \\log p_{m_i}(\\mathbf{x}_i) + \\sum_{k=1}^{m_i-1} \\log(1-p_k(\\mathbf{x}_i)) \\right)$$\n$$-\\log L_i = \\delta_i [-\\log \\sigma(\\eta_{im_i})] + \\sum_{k=1}^{m_i-1} [-\\log(1-\\sigma(\\eta_{ik}))]$$\n$$-\\log L_i = \\delta_i \\log(1+\\exp(-\\eta_{im_i})) + \\sum_{k=1}^{m_i-1} \\log(1+\\exp(\\eta_{ik}))$$\n总离散时间负对数似然是所有对象的总和：\n$$L_{\\text{disc}} = \\sum_{i=1}^{N} \\left( \\delta_i \\log(1+\\exp(-\\eta_{im_i})) + \\sum_{k=1}^{m_i-1} \\log(1+\\exp(\\eta_{ik})) \\right)$$\n为保证数值稳定性，项$\\log(1+\\exp(x))$可以计算为`logaddexp(0, x)`。\n\n**Cox偏负对数似然($L_{\\text{cox}}$)的推导**\n\nCox比例风险(CPH)模型将风险函数指定为$h(t \\mid \\mathbf{X}) = h_0(t) \\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{X})$，其中$h_0(t)$是任意的基准风险，$\\boldsymbol{\\beta}$是系数。偏似然通过考虑在给定的事件时间点哪个对象经历事件的条件概率，从而绕过了对$h_0(t)$的估计。\n\n令不同的事件时间排序为$t_{(1)}  t_{(2)}  \\dots  t_{(D)}$。令$i$为在时间$t_i$经历事件的对象的索引。在时间$t_i$的风险集，记为$R(t_i)$，是在时间$t_i$时仍有事件风险的所有对象$j$的集合（即，他们的观测时间$t_j \\ge t_i$）。\n\n在风险集$R(t_i)$中的条件下，对象$i$在无穷小区间$[t_i, t_i+dt)$内发生事件的概率是$h(t_i \\mid \\mathbf{x}_i)dt$。风险集中任何对象在此区间内发生事件的概率是$\\sum_{j \\in R(t_i)} h(t_i \\mid \\mathbf{x}_j)dt$。在$t_i$时刻风险集中发生了一个事件的条件下，该事件发生在特定对象$i$身上的条件概率是：\n$$\\frac{h(t_i \\mid \\mathbf{x}_i)dt}{\\sum_{j \\in R(t_i)} h(t_i \\mid \\mathbf{x}_j)dt} = \\frac{h_0(t_i) \\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{x}_i)}{\\sum_{j \\in R(t_i)} h_0(t_i) \\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{x}_j)} = \\frac{\\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{x}_i)}{\\sum_{j \\in R(t_i)} \\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{x}_j)}$$\n基准风险$h_0(t_i)$被消去，这是偏似然的关键特征。\n\n总偏似然$L_{\\text{cph}}$是所有观测到的事件的这些条件概率的乘积。令$\\mathcal{E}$为经历了事件的对象($\\delta_i=1$)的索引集合。如题设，假设事件时间是不同的：\n$$L_{\\text{cph}}(\\boldsymbol{\\beta}) = \\prod_{i \\in \\mathcal{E}} \\frac{\\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{x}_i)}{\\sum_{j \\in R(t_i)} \\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{x}_j)}$$\n对数偏似然为：\n$$\\ell_{\\text{cph}}(\\boldsymbol{\\beta}) = \\sum_{i \\in \\mathcal{E}} \\left( \\boldsymbol{\\beta}^{\\top}\\mathbf{x}_i - \\log\\left(\\sum_{j \\in R(t_i)} \\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{x}_j)\\right) \\right)$$\n用于训练最小化的Cox偏负对数似然是$L_{\\text{cox}} = -\\ell_{\\text{cph}}$：\n$$L_{\\text{cox}}(\\boldsymbol{\\beta}) = \\sum_{i \\in \\mathcal{E}} \\left( \\log\\left(\\sum_{j \\in R(t_i)} \\exp(\\boldsymbol{\\beta}^{\\top}\\mathbf{x}_j)\\right) - \\boldsymbol{\\beta}^{\\top}\\mathbf{x}_i \\right)$$\n为了数值稳定性，项$\\log(\\sum_j \\exp(\\eta_j))$（其中$\\eta_j = \\boldsymbol{\\beta}^{\\top}\\mathbf{x}_j$）使用log-sum-exp技巧进行计算。\n\n在案例数据集中，有$\\mathbfx_3$，这是个错字，应为$\\mathbf{x}_3$。\n$$-\\log L_i = \\delta_i \\log(1+\\exp(-\\eta_{im_i})) + \\sum_{k=1}^{m_i-1} \\log(1+\\exp(\\eta_{ik}))$$\n应为：\n$$-\\log L_i = \\delta_i \\log(1+\\exp(-\\eta_{i,m_i})) + \\sum_{k=1}^{m_i-1} \\log(1+\\exp(\\eta_{i,k}))$$",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef compute_L_disc(observations, bin_edges, alphas, beta):\n    \"\"\"\n    Computes the discrete-time negative log-likelihood.\n    \"\"\"\n    times = observations[:, 0]\n    deltas = observations[:, 1]\n    X = observations[:, 2:]\n    \n    n_subjects = X.shape[0]\n    total_neg_log_likelihood = 0.0\n\n    extended_bins = np.append(bin_edges, [np.inf])\n    bin_indices = np.digitize(times, extended_bins)\n\n    for i in range(n_subjects):\n        delta_i, x_i = deltas[i], X[i]\n        m_i = bin_indices[i] \n        \n        subject_neg_log_lik = 0.0\n\n        # Survival terms for bins k = 1, ..., m_i-1\n        for k in range(1, m_i):\n            alpha_k = alphas[k-1]\n            eta_ik = alpha_k + np.dot(beta, x_i)\n            # Add log(1 + exp(eta_ik))\n            subject_neg_log_lik += np.logaddexp(0, eta_ik)\n            \n        # Event term for bin m_i, if event occurred\n        if delta_i == 1:\n            if m_i = len(alphas):\n                alpha_mi = alphas[m_i-1]\n                eta_imi = alpha_mi + np.dot(beta, x_i)\n                # Add log(1 + exp(-eta_imi))\n                subject_neg_log_lik += np.logaddexp(0, -eta_imi)\n        \n        total_neg_log_likelihood += subject_neg_log_lik\n\n    return total_neg_log_likelihood\n\ndef compute_L_cox(observations, beta):\n    \"\"\"\n    Computes the Cox partial negative log-likelihood.\n    \"\"\"\n    times = observations[:, 0]\n    deltas = observations[:, 1]\n    X = observations[:, 2:]\n\n    neg_log_likelihood = 0.0\n\n    etas = X @ beta\n    \n    event_indices = np.where(deltas == 1)[0]\n    \n    for i in event_indices:\n        t_i = times[i]\n        eta_i = etas[i]\n\n        risk_set_indices = np.where(times >= t_i)[0]\n        \n        risk_set_etas = etas[risk_set_indices]\n        \n        log_sum_exp_risk_set = logsumexp(risk_set_etas)\n        term = log_sum_exp_risk_set - eta_i\n        neg_log_likelihood += term\n\n    return neg_log_likelihood\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"bin_edges\": np.array([0, 2, 5, 10]),\n            \"alphas\": np.array([-2.0, -1.0, -0.5]),\n            \"beta\": np.array([0.5, -0.3]),\n            \"obs\": np.array([\n                [1.5, 1, 1.0, 0.5],\n                [3.0, 1, -0.5, 1.0],\n                [7.0, 1, 0.3, -0.2],\n                [4.0, 0, 1.5, 0.0],\n                [9.0, 0, -1.2, 2.0]\n            ])\n        },\n        {\n            \"bin_edges\": np.array([0, 2, 5, 8]),\n            \"alphas\": np.array([-2.2, -1.3, -0.8]),\n            \"beta\": np.array([0.4, 0.2]),\n            \"obs\": np.array([\n                [1.8, 0, 0.0, 1.0],\n                [2.2, 0, -1.0, 0.5],\n                [4.9, 0, 0.3, 0.3],\n                [6.0, 0, 0.5, -0.2]\n            ])\n        },\n        {\n            \"bin_edges\": np.array([0, 2, 8]),\n            \"alphas\": np.array([-1.5, -0.2]),\n            \"beta\": np.array([-0.1, 0.6]),\n            \"obs\": np.array([\n                [0.5, 1, 0.2, 1.0],\n                [1.9, 0, -0.7, 0.8],\n                [7.5, 1, 1.2, -0.4],\n                [7.9, 0, -0.3, 0.1]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        obs = case[\"obs\"]\n        bin_edges = case[\"bin_edges\"]\n        alphas = case[\"alphas\"]\n        beta = case[\"beta\"]\n\n        l_disc = compute_L_disc(obs, bin_edges, alphas, beta)\n        l_cox = compute_L_cox(obs, beta)\n        l_diff = l_disc - l_cox\n        \n        results.extend([l_disc, l_cox, l_diff])\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}