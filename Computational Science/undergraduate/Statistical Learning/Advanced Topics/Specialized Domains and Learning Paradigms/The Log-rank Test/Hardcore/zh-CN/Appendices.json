{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握对数秩检验，最好的方法是回归其组合学的根源。这个练习将引导你手动计算一个小数据集的精确置换分布。通过这种方式，你将看到“期望事件数”这个概念是如何在零假设（即处理组和对照组没有差异）下，通过考虑所有可能的分组情况而产生的。这种基础练习能够揭示对数秩检验精确的、非参数的逻辑，而无需依赖大样本近似，从而为你建立坚实的理论基础。",
            "id": "1962134",
            "problem": "在一项小型临床试验中，一种新疗法（A组）正在与对照组（B组）进行比较。共有六名受试者参加该研究，其中三名被随机分配到A组，三名被分配到B组。该研究随时间追踪受试者，记录发生特定不良事件的时间，或者如果他们在没有发生事件的情况下退出研究（删失），则记录他们最后一次随访的时间。\n\n所有六名受试者的合并数据如下，其中时间以月为单位，状态为“事件”或“删失”：\n- 受试者 1: (3, 事件)\n- 受试者 2: (5, 事件)\n- 受试者 3: (6, 删失)\n- 受试者 4: (8, 事件)\n- 受试者 5: (10, 删失)\n- 受试者 6: (12, 事件)\n\n观察到的受试者分组情况为：\n- A组（治疗组）：结果为 (5, 事件), (6, 删失) 和 (12, 事件) 的受试者。\n- B组（对照组）：结果为 (3, 事件), (8, 事件) 和 (10, 删失) 的受试者。\n\n为了检验两组之间的事件时间分布没有差异的原假设，您将执行一个精确对数秩检验。这包括为受试者的每一种可能的分组情况计算对数秩统计量的分子 $U = \\sum_{j} (O_j - E_j)$。\n\n通过构建统计量 $U$ 的精确置换分布，计算观测数据的双侧p值。将您的最终答案四舍五入到四位有效数字。",
            "solution": "我们按时间对六名受试者进行排序：$t_{1}=3$ (事件), $t_{2}=5$ (事件), $t_{3}=6$ (删失), $t_{4}=8$ (事件), $t_{5}=10$ (删失), $t_{6}=12$ (事件)。在每个事件时间 $j$，$O_{j}-E_{j}$ 是对数秩分子，其中 $O_{j}$ 是A组的事件数，$E_{j}=d_{j}\\,n_{Aj}/n_{j}$，$d_{j}$ 是在时间 $j$ 发生的事件数，$n_{j}$ 是在 $j$ 之前处于风险中的总人数，$n_{Aj}$ 是在 $j$ 之前A组处于风险中的人数。在时间 $t_{1},t_{2},t_{4},t_{6}$ 有 $d_{j}=1$；在 $t_{3},t_{5}$ 的删失贡献为零。\n\n设 $a_{i}\\in\\{0,1\\}$ 表示受试者 $i$ 是否在A组，且 $\\sum_{i=1}^{6}a_{i}=3$。那么：\n- 在 $t_{1}=3$ 时: $n_{1}=6$, $n_{A1}=3$, $E_{1}=1\\cdot(3/6)=\\frac{1}{2}$, $O_{1}=a_{1}$，所以贡献为 $a_{1}-\\frac{1}{2}$。\n- 在 $t_{2}=5$ 时: $n_{2}=5$, $n_{A2}=3-a_{1}$, $E_{2}=\\frac{3-a_{1}}{5}$, $O_{2}=a_{2}$，所以贡献为 $a_{2}-\\frac{3-a_{1}}{5}$。\n- 在 $t_{3}=6$ (删失)时: 无贡献。\n- 在 $t_{4}=8$ 时: $n_{3}=3$, $n_{A3}=3-a_{1}-a_{2}-a_{3}$, $E_{3}=\\frac{3-a_{1}-a_{2}-a_{3}}{3}$, $O_{3}=a_{4}$，所以贡献为 $a_{4}-\\frac{3-a_{1}-a_{2}-a_{3}}{3}$。\n- 在 $t_{5}=10$ (删失)时: 无贡献。\n- 在 $t_{6}=12$ 时: $n_{4}=1$, $E_{4}=a_{6}$, $O_{4}=a_{6}$，所以贡献为 $0$。\n\n因此，\n$$\nU=(a_{1}-\\tfrac{1}{2})+\\Bigl(a_{2}-\\tfrac{3-a_{1}}{5}\\Bigr)+\\Bigl(a_{4}-\\tfrac{3-a_{1}-a_{2}-a_{3}}{3}\\Bigr),\n$$\n化简为\n$$\nU=\\tfrac{23}{15}a_{1}+\\tfrac{4}{3}a_{2}+\\tfrac{1}{3}a_{3}+a_{4}-\\tfrac{21}{10}.\n$$\n\n观察到的分配是A组：$(5,\\text{事件})$, $(6,\\text{删失})$, $(12,\\text{事件})$, 即 $(a_{1},a_{2},a_{3},a_{4},a_{5},a_{6})=(0,1,1,0,0,1)$。因此\n$$\nU_{\\text{obs}}=\\tfrac{4}{3}\\cdot 1+\\tfrac{1}{3}\\cdot 1-\\tfrac{21}{10}=\\tfrac{5}{3}-\\tfrac{21}{10}=-\\tfrac{13}{30}.\n$$\n\n为了构建精确的置换分布，我们枚举所有 $\\binom{6}{3}=20$ 种分配。因为 $U$ 仅取决于 $(a_{1},a_{2},a_{3},a_{4})$ 且 $\\sum_{i=1}^{6}a_{i}=3$，所以前四个中的允许计数为 $k\\in\\{1,2,3\\}$。对于每个满足 $1\\leq |S|\\leq 3$ 的子集 $S\\subset\\{1,2,3,4\\}$，$U(S)=\\sum_{i\\in S}w_{i}-c$，其中权重为 $w_{1}=\\tfrac{23}{15}$，$w_{2}=\\tfrac{4}{3}$，$w_{3}=\\tfrac{1}{3}$，$w_{4}=1$，且 $c=\\tfrac{21}{10}$。这些值（在所有20种分配中的重复次数）为：\n- 对于 $|S|=1$: $-\\tfrac{17}{30}$, $-\\tfrac{23}{30}$, $-\\tfrac{53}{30}$, $-\\tfrac{33}{30}$ (每项计数为1)。\n- 对于 $|S|=2$: $\\tfrac{23}{30}$, $-\\tfrac{7}{30}$, $\\tfrac{13}{30}$, $-\\tfrac{13}{30}$, $\\tfrac{7}{30}$, $-\\tfrac{23}{30}$ (每项计数为2)。\n- 对于 $|S|=3$: $\\tfrac{33}{30}$, $\\tfrac{53}{30}$, $\\tfrac{23}{30}$, $\\tfrac{17}{30}$ (每项计数为1)。\n\n汇总起来，$U$ 的完整多重集的计数为：$\\tfrac{53}{30}(1)$, $\\tfrac{33}{30}(1)$, $\\tfrac{23}{30}(3)$, $\\tfrac{17}{30}(1)$, $\\tfrac{13}{30}(2)$, $\\tfrac{7}{30}(2)$, $-\\tfrac{7}{30}(2)$, $-\\tfrac{13}{30}(2)$, $-\\tfrac{17}{30}(1)$, $-\\tfrac{23}{30}(3)$, $-\\tfrac{33}{30}(1)$, $-\\tfrac{53}{30}(1)$。\n\n当 $|U_{\\text{obs}}|=\\tfrac{13}{30}$ 时，双侧p值是满足 $|U|\\geq \\tfrac{13}{30}$ 的比例。满足 $|U|  \\tfrac{13}{30}$ 的值是 $\\pm\\tfrac{7}{30}$ (总计数为4)。因此p值为\n$$\np=\\frac{20-4}{20}=\\frac{16}{20}=0.8.\n$$\n\n四舍五入到四位有效数字，p值为 $0.8000$。",
            "answer": "$$\\boxed{0.8000}$$"
        },
        {
            "introduction": "理解了对数秩检验的基本机理后，我们来探讨其一个关键特性：处理删失数据的能力。许多简单的统计方法在面对不完整的生存数据时会失效。本练习将对数秩检验与一种仅分析未删失观测值的“朴素”Wilcoxon秩和检验方法进行对比，让你亲眼见证忽略删失数据可能如何导致错误的结论。这个对比突显了在生存分析中正确处理删失数据的极端重要性，并证明了对数秩检验在这种情况下的优越性。",
            "id": "1962146",
            "problem": "在一项临床试验中，为比较一种新治疗药物（A组）与一种标准治疗（B组）对患者生存时间的影响。共有16名患者入组，并被随机分配到两个组中的一个，每组8名患者。主要终点是发生特定事件所需的时间（以月为单位）。一些患者在观察期结束时失访或未经历该事件；这些被记录为删失观测值。\n\n两组的观测时间如下，其中 `+` 符号表示一个删失观测值：\n- **A组（新药）：** 21, 26, 31, 35+, 35+, 35+, 35+, 35+\n- **B组（标准治疗）：** 5, 10, 15, 18, 22, 27, 32, 38\n\n一位数据分析师提出了两种不同的方法来检验两组生存分布没有差异的原假设。\n1. 对数秩检验，这是分析此类带删失的事件时间数据的标准方法。\n2. 一种“朴素的”Wilcoxon秩和检验（也称为Mann-Whitney U检验），*仅*应用于经历了事件的患者子集（即非删失观测值）。\n\n你的任务是计算每种方法的检验统计量。令$Z$为对数秩检验的检验统计量，计算公式为 $Z = (\\sum(O_A - E_A)) / \\sqrt{\\sum V}$，其中$O_A$是A组的观测事件数，$E_A$是期望事件数，$V$是方差。令$U$为Wilcoxon秩和检验的检验统计量，定义为为每个组计算的两个可能的$U$统计量中的较小者。\n\n计算数对 $(Z, U)$ 的值。对于最终答案，将$Z$表示为四舍五入到三位有效数字的值，将$U$表示为精确整数。",
            "solution": "该问题要求基于提供的A、B两组生存数据，计算两个统计检验值。\n\n**第一部分：朴素Wilcoxon秩和检验（Mann-Whitney U检验）**\n\n此检验仅对经历事件的受试者进行。我们首先提取每组的事件时间。\n- A组事件时间：{21, 26, 31}。经历事件的受试者样本量为 $n_A = 3$。\n- B组事件时间：{5, 10, 15, 18, 22, 27, 32, 38}。经历事件的受试者样本量为 $n_B = 8$。\n\n接下来，我们将所有事件时间合并，并从最小到最大进行排序。在这种朴素分析中，总观测数为 $N = n_A + n_B = 3 + 8 = 11$。\n\n| 时间 | 组   | 秩   |\n|------|------|------|\n| 5    | B    | 1    |\n| 10   | B    | 2    |\n| 15   | B    | 3    |\n| 18   | B    | 4    |\n| 21   | A    | 5    |\n| 22   | B    | 6    |\n| 26   | A    | 7    |\n| 27   | B    | 8    |\n| 31   | A    | 9    |\n| 32   | B    | 10   |\n| 38   | B    | 11   |\n\n现在，我们计算每组的秩和。\n- A组的秩和（$R_A$）：$5 + 7 + 9 = 21$。\n- B组的秩和（$R_B$）：$1 + 2 + 3 + 4 + 6 + 8 + 10 + 11 = 45$。\n作为检验，总秩和应为 $\\frac{N(N+1)}{2} = \\frac{11(12)}{2} = 66$。而实际上，$R_A + R_B = 21 + 45 = 66$。\n\n每组的Mann-Whitney U统计量计算如下：\n$U_A = R_A - \\frac{n_A(n_A+1)}{2} = 21 - \\frac{3(3+1)}{2} = 21 - 6 = 15$。\n$U_B = R_B - \\frac{n_B(n_B+1)}{2} = 45 - \\frac{8(8+1)}{2} = 45 - 36 = 9$。\n作为检验，$U_A + U_B = 15 + 9 = 24$，这应该等于 $n_A n_B = 3 \\times 8 = 24$。计算正确。\n\n检验统计量 $U$ 是 $U_A$ 和 $U_B$ 中的较小者。\n$U = \\min(15, 9) = 9$。\n\n**第二部分：对数秩检验**\n\n此检验使用所有数据，包括删失观测值，来比较生存分布。原假设是两组的生存函数相同。我们在每个不同的事件时间点计算观测事件数（$O_A$）、期望事件数（$E_A$）和方差（$V$）。\n\n数据如下：\n- A组：{21, 26, 31, 35+, 35+, 35+, 35+, 35+} ($N_A=8$)\n- B组：{5, 10, 15, 18, 22, 27, 32, 38} ($N_B=8$)\n不同的事件时间为：5, 10, 15, 18, 21, 22, 26, 27, 31, 32, 38。\n\n我们构建一个表格来记录在每个事件时间 $t_j$ 的计算。\n- $n_{Aj}$：在 $t_j$ 时刻之前A组的风险人数。\n- $n_{Bj}$：在 $t_j$ 时刻之前B组的风险人数。\n- $N_j = n_{Aj} + n_{Bj}$：总风险人数。\n- $d_j$：在 $t_j$ 时刻的总事件数。对于此数据集，所有事件时间的 $d_j=1$。\n- $d_{Aj}$：在 $t_j$ 时刻A组的事件数。\n- $O_{Aj} = d_{Aj}$：A组的观测事件数。\n- $E_{Aj} = d_j \\frac{n_{Aj}}{N_j}$：在 $H_0$ 下A组的期望事件数。\n- $V_j = \\frac{n_{Aj} n_{Bj} d_j (N_j - d_j)}{N_j^2 (N_j-1)}$：在 $H_0$ 下 $O_{Aj}$ 的方差。\n\n| $t_j$ | $n_{Aj}$ | $n_{Bj}$ | $N_j$ | $d_j$ | $d_{Aj}$ | $O_{Aj}-E_{Aj}$ | $V_j$ |\n|-------|----------|----------|-------|-------|----------|-----------------------|-----------------------|\n| 5     | 8        | 8        | 16    | 1     | 0        | $0 - 8/16 = -0.5000$  | $\\frac{8 \\cdot 8 \\cdot 1 \\cdot 15}{16^2 \\cdot 15} = 0.2500$ |\n| 10    | 8        | 7        | 15    | 1     | 0        | $0 - 8/15 \\approx -0.5333$ | $\\frac{8 \\cdot 7 \\cdot 1 \\cdot 14}{15^2 \\cdot 14} \\approx 0.2489$ |\n| 15    | 8        | 6        | 14    | 1     | 0        | $0 - 8/14 \\approx -0.5714$ | $\\frac{8 \\cdot 6 \\cdot 1 \\cdot 13}{14^2 \\cdot 13} \\approx 0.2449$ |\n| 18    | 8        | 5        | 13    | 1     | 0        | $0 - 8/13 \\approx -0.6154$ | $\\frac{8 \\cdot 5 \\cdot 1 \\cdot 12}{13^2 \\cdot 12} \\approx 0.2367$ |\n| 21    | 8        | 4        | 12    | 1     | 1        | $1 - 8/12 \\approx 0.3333$  | $\\frac{8 \\cdot 4 \\cdot 1 \\cdot 11}{12^2 \\cdot 11} \\approx 0.2222$ |\n| 22    | 7        | 4        | 11    | 1     | 0        | $0 - 7/11 \\approx -0.6364$ | $\\frac{7 \\cdot 4 \\cdot 1 \\cdot 10}{11^2 \\cdot 10} \\approx 0.2314$ |\n| 26    | 7        | 3        | 10    | 1     | 1        | $1 - 7/10 = 0.3000$   | $\\frac{7 \\cdot 3 \\cdot 1 \\cdot 9}{10^2 \\cdot 9} = 0.2100$ |\n| 27    | 6        | 3        | 9     | 1     | 0        | $0 - 6/9 \\approx -0.6667$ | $\\frac{6 \\cdot 3 \\cdot 1 \\cdot 8}{9^2 \\cdot 8} \\approx 0.2222$ |\n| 31    | 6        | 2        | 8     | 1     | 1        | $1 - 6/8 = 0.2500$    | $\\frac{6 \\cdot 2 \\cdot 1 \\cdot 7}{8^2 \\cdot 7} = 0.1875$ |\n| 32    | 5        | 2        | 7     | 1     | 0        | $0 - 5/7 \\approx -0.7143$ | $\\frac{5 \\cdot 2 \\cdot 1 \\cdot 6}{7^2 \\cdot 6} \\approx 0.2041$ |\n| 38    | 0        | 1        | 1     | 1     | 0        | $0 - 0/1 = 0$         | $0$ （因为 $N_j-1=0$） |\n注意：在$t=35$时，A组有5名受试者被删失，因此在$t=38$的事件发生时，$n_{Aj}=0$。\n\n现在我们对 $O_{Aj}-E_{Aj}$ 和 $V_j$ 两列求和。\n$\\sum(O_{Aj}-E_{Aj}) \\approx -0.5000 - 0.5333 - 0.5714 - 0.6154 + 0.3333 - 0.6364 + 0.3000 - 0.6667 + 0.2500 - 0.7143 + 0 = -3.3542$\n\n$\\sum V_j \\approx 0.2500 + 0.2489 + 0.2449 + 0.2367 + 0.2222 + 0.2314 + 0.2100 + 0.2222 + 0.1875 + 0.2041 + 0 = 2.2579$\n\n对数秩检验统计量 $Z$ 是：\n$Z = \\frac{\\sum(O_{Aj}-E_{Aj})}{\\sqrt{\\sum V_j}} = \\frac{-3.3542}{\\sqrt{2.2579}} \\approx \\frac{-3.3542}{1.50263} \\approx -2.2322$\n\n四舍五入到三位有效数字，$Z = -2.23$。\n\n数对 $(Z, U)$ 的值为 $(-2.23, 9)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} -2.23  9 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在真实世界的研究中，我们经常遇到可能影响结果并混淆处理效应比较的协变量。分层对数秩检验是一种强大的扩展方法，它允许我们通过在协变量的不同水平（或分层）内进行比较来控制这些混杂因素。通过这个编程练习，你将学习如何根据一个非线性变换的协变量对数据进行分层，并实现分层对数秩检验。这项实践将使你掌握一种调整组间基线差异的实用技术，从而对处理效应做出更准确、更可靠的评估。",
            "id": "3185163",
            "problem": "给定包含右删失的双处理生存数据，以及一个可能非线性地改变风险率的连续协变量 $Z$。您的任务是实现对两种处理进行分层对数秩比较，其中分层是通过对 $Z$ 进行非线性变换构成的，然后评估在单个层内是否仍存在任何残余的处理差异。\n\n基本依据和假设：\n- 设生存函数为 $S(t)$，风险函数为 $h(t)$。对于每个分层，设时间 $t$ 之前的风险集为 $R(t)$，其中有 $n(t)$ 个个体处于风险中，并且在标记为 $1$ 的处理组中有 $n_{1}(t)$ 个个体处于风险中。\n- 在每个分层内两种处理的风险率相等的原假设下，在任何一个不同的事件时间 $t$（以 $R(t)$ 和当时的总事件数 $d(t)$ 为条件），归因于处理 $1$ 的事件数遵循无放回超几何定律。因此，在每个事件时间，处理 $1$ 的期望事件数与 $n_{1}(t)$ 成正比，其变异性反映了无放回抽样（有限总体校正）。事件时间的平局必须使用这种无放回机制来处理。\n\n需要计算的内容：\n- 非线性分层：对于每个测试用例，通过 $f(Z) = Z^{2}$ 变换协变量，并根据该测试用例内 $f(Z)$ 的样本中位数将数据精确地分为两层。$f(Z)$ 小于或等于中位数的个体属于下层，$f(Z)$ 严格大于中位数的个体属于上层。\n- 在每个分层内，通过对该层中不同事件时间 $t$ 的数据进行汇总，构建一个对数秩类型的得分：将在时间 $t$ 观测到的处理 $1$ 中的事件计数与其在原假设下的条件期望（基于超几何定律）进行比较，并汇总包含针对平局的无放回有限样本校正的相应条件方差。将得到的层级贡献定义为观测值减去期望值的总和，及其方差。\n- 通过将两个分层的观测值减期望值的贡献及其方差相加，形成总体分层统计量，然后构建一个单一的二次型，该二次型在原假设下渐近服从自由度为一的卡方分布。同时，为每个单独的分层计算其自身的自由度为一的二次型和p值。\n- 显著性阈值：使用水平 $\\alpha = 0.05$。\n- 层内残余评估：生成一个布尔值，当且仅当至少有一个分层的层内p值严格小于 $\\alpha$ 时，该值为真。\n\n需要遵守的实现细节：\n- 右删失：在事件时间 $t$，风险集必须包括所有观测时间大于或等于 $t$ 的个体。如果在时间 $t$ 删失一个个体，则该个体在时间 $t$ 的风险集中被计数，但在时间 $t$ 不贡献任何事件。\n- 在事件时间 $t$ 的平局必须使用无放回超几何模型来处理处理组间的事件分布，并在方差中使用相应的有限总体校正。\n- 如果一个分层没有信息（例如，没有事件或退化的风险集导致方差为零），其方差贡献被视为零。在此类分层中，层内统计量定义为零，p值定义为一。\n\n测试套件：\n实现您的程序，为以下三个测试用例计算所需的输出。每个用例都包含观测时间、事件指示符、处理标签和协变量 $Z$ 的数组。所有数字都没有单位。\n\n- 测试用例 $1$（正常路径；两个分层中都有明显差异）：\n  - times $=$ $[2,3,4,5,\\,6,7,8,9,\\,1,2,3,4,\\,8,9,10,11]$\n  - events $=$ $[1,1,1,0,\\,1,1,1,1,\\,1,1,1,1,\\,1,1,1,1]$\n  - groups $=$ $[0,0,0,0,\\,1,1,1,1,\\,0,0,0,0,\\,1,1,1,1]$\n  - $Z$ $=$ $[1,-1,1,-1,\\,1,-1,1,-1,\\,2,-2,2,-2,\\,2,-2,2,-2]$\n\n- 测试用例 $2$（边界行为；一个分层没有事件）：\n  - times $=$ $[5,6,7,8,\\,3,6,4,5]$\n  - events $=$ $[0,0,0,0,\\,1,1,1,1]$\n  - groups $=$ $[0,1,0,1,\\,0,0,1,1]$\n  - $Z$ $=$ $[1,-1,-1,1,\\,2,2,-2,-2]$\n\n- 测试用例 $3$（边缘情况，事件时间有多个平局）：\n  - times $=$ $[5,5,5,9,\\,7,7,9,9]$\n  - events $=$ $[1,1,1,0,\\,1,1,0,0]$\n  - groups $=$ $[0,1,0,1,\\,0,1,0,1]$\n  - $Z$ $=$ $[1,-1,1,-1,\\,2,-2,2,-2]$\n\n每个测试用例的必需输出：\n- 设 $S$ 为自由度为一的总体分层卡方统计量。\n- 设 $P$ 为使用自由度为一的卡方累积分布函数（CDF）计算出的相应p值。\n- 设 $B$ 为一个布尔值，指示是否有任何单个分层的层内p值严格低于 $\\alpha$。\n\n您的程序应生成单行输出，其中包含一个含三个元素的列表，每个元素对应一个测试用例，而每个元素本身是一个列表 $[S,P,B]$。浮点数 $S$ 和 $P$ 必须四舍五入到恰好六位小数，而 $B$ 必须是 True 或 False。该行必须严格按照以下格式打印（无多余空格）：例如，$[[S_{1},P_{1},B_{1}],[S_{2},P_{2},B_{2}],[S_{3},P_{3},B_{3}]]$。",
            "solution": "用户提供了一个有效且定义明确的生存分析问题。任务是实现一个分层对数秩检验，以比较两个处理组的生存分布，分层基于连续协变量 $Z$ 的非线性变换。该方法依赖于已建立的统计学原理，特别是用于处理事件时间平局的原假设下事件分布的超几何模型。\n\n整个过程包括四个主要步骤：数据分层、计算每个层内的对数秩统计量、汇总为单个分层检验统计量，以及评估单个层内的残余处理差异。\n\n1.  **数据分层**\n    对于每个受试者 $i$，我们给定一个观测时间 $T_i$、一个事件指示符 $\\delta_i$（$1$ 表示事件，$0$ 表示删失）、一个处理组分配 $G_i \\in \\{0, 1\\}$ 和一个连续协变量值 $Z_i$。\n    分层基于协变量 $Z$ 的非线性变换进行。具体来说，我们为所有受试者计算 $f(Z_i) = Z_i^2$。然后计算这些变换值的样本中位数 $m = \\text{median}(\\{f(Z_i)\\})$。数据被划分为两个分层：\n    -   下层：所有满足 $f(Z_i) \\le m$ 的受试者 $i$。\n    -   上层：所有满足 $f(Z_i)  m$ 的受试者 $i$。\n\n2.  **每个层内的对数秩检验**\n    在每个分层 $k$ 内，我们进行一个类似于标准对数秩检验的比较。设 $t_1  t_2  \\dots  t_D$ 是在分层 $k$ 中观测到的不同事件时间。在每个事件时间 $t_j$：\n    -   风险集 $R(t_j)$ 由该层中在时间 $t_j$ 或恰好在时间 $t_j$ 之前仍在观察中的所有个体组成。即，其观测时间 $T_i \\ge t_j$ 的个体。\n    -   设 $n_j$ 是风险集 $R(t_j)$ 中的个体总数。\n    -   设 $n_{1j}$ 是 $R(t_j)$ 中属于处理组 $1$ 的个体数。\n    -   设 $d_j$ 是在时间 $t_j$ 发生的事件总数。\n    -   设 $d_{1j}$ 是在时间 $t_j$ 处理组 $1$ 个体中观测到的事件数。\n\n    在原假设 ($H_0$) 下，即层内两个处理组的风险率没有差异，组 $1$ 的事件数 $d_{1j}$（以计数 $n_j$、$n_{1j}$ 和 $d_j$ 为条件）遵循超几何分布。\n    在时间 $t_j$，组 $1$ 中的期望事件数由以下公式给出：\n    $$ E_j = d_j \\frac{n_{1j}}{n_j} $$\n    在时间 $t_j$，组 $1$ 事件数的方差，包含了用于处理事件时间平局的有限总体校正，由超几何分布的方差给出：\n    $$ V_j = d_j \\frac{n_{1j}}{n_j} \\left(1 - \\frac{n_{1j}}{n_j}\\right) \\frac{n_j - d_j}{n_j - 1} $$\n    如果分母 $n_j - 1$ 为零（即 $n_j \\le 1$），或者如果 $n_{1j}=0$、$n_{1j}=n_j$、$d_j=0$ 或 $d_j=n_j$，则方差 $V_j$ 为 $0$。\n\n3.  **汇总和统计量构建**\n    一个层内所有唯一事件时间的贡献被汇总。对于分层 $k$：\n    -   层级得分为观测事件数减去期望事件数的总和：$O_k - E_k = \\sum_{j} (d_{1j} - E_j)$。\n    -   层级方差为各方差之和：$V_k = \\sum_j V_j$。\n\n    为了获得总体分层检验统计量，我们将两个分层（我们将其标记为 $k=1, 2$）的得分和方差相加：\n    -   总得分：$O - E = (O_1 - E_1) + (O_2 - E_2) = \\sum_k (O_k - E_k)$。\n    -   总方差：$V = V_1 + V_2 = \\sum_k V_k$。\n\n    然后，总体分层对数秩统计量 $S$ 被构建为一个二次型：\n    $$ S = \\frac{(O - E)^2}{V} $$\n    在所有分层中处理效应均为零的全局原假设下，$S$ 渐近服从自由度为一的卡方（$\\chi^2$）分布。如果 $V=0$，统计量 $S$ 定义为 $0$。\n\n4.  **假设检验和残余评估**\n    -   **总体检验**：总体分层检验的p值 $P$ 是从 $\\chi^2(1)$ 分布的生存函数（1 - CDF）计算得出的：$P = \\text{Pr}(\\chi^2_1 \\ge S)$。\n    -   **层内评估**：为评估任何单个层内是否存在显著的处理差异，为每个层 $k$ 计算一个单独的统计量：\n        $$ S_k = \\frac{(O_k - E_k)^2}{V_k} $$\n        在特定于层的原假设下，这个 $S_k$ 也服从 $\\chi^2(1)$ 分布。相应的p值为 $P_k = \\text{Pr}(\\chi^2_1 \\ge S_k)$。如果一个分层的方差为零（$V_k=0$），它不提供任何比较信息；在这种情况下，其统计量 $S_k$ 定义为 $0$，其p值 $P_k$ 定义为 $1$。\n    -   **布尔标志**：如果任何层内p值 $P_k$ 严格小于指定的显著性水平 $\\alpha = 0.05$，则布尔标志 $B$ 设置为 `True`。否则，$B$ 设置为 `False`。\n\n    每个测试用例的最终输出是一个列表 $[S, P, B]$，其中浮点值 $S$ 和 $P$ 四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef stratified_log_rank(times: np.ndarray, events: np.ndarray, groups: np.ndarray, z: np.ndarray) - list:\n    \"\"\"\n    Performs a stratified log-rank test on survival data.\n\n    Args:\n        times: Array of observed times.\n        events: Array of event indicators (1=event, 0=censored).\n        groups: Array of treatment group labels (0 or 1).\n        z: Array of continuous covariate values.\n\n    Returns:\n        A list containing [S, P, B]:\n        S: The overall stratified chi-square statistic.\n        P: The corresponding p-value.\n        B: A boolean indicating if any stratum has p  0.05.\n    \"\"\"\n    # --- 1. Stratification ---\n    z_sq = z**2\n    median_z_sq = np.median(z_sq)\n    \n    lower_stratum_mask = z_sq = median_z_sq\n    upper_stratum_mask = z_sq  median_z_sq\n\n    strata_masks = [lower_stratum_mask, upper_stratum_mask]\n    \n    stratum_results = []\n\n    # --- 2. Per-Stratum Calculation ---\n    for mask in strata_masks:\n        if not np.any(mask):\n            # Stratum is empty, contribute zero information.\n            stratum_results.append({'O_minus_E': 0.0, 'V': 0.0})\n            continue\n\n        s_times = times[mask]\n        s_events = events[mask]\n        s_groups = groups[mask]\n\n        # Find unique event times in this stratum\n        unique_event_times = np.unique(s_times[s_events == 1])\n        \n        stratum_O_minus_E = 0.0\n        stratum_V = 0.0\n        \n        if unique_event_times.size == 0:\n            # No events in stratum, contribute zero information.\n            stratum_results.append({'O_minus_E': 0.0, 'V': 0.0})\n            continue\n\n        for t in unique_event_times:\n            # Identify risk set at time t\n            at_risk_mask = s_times = t\n            n_j = np.sum(at_risk_mask)\n            \n            # Sub-populations in risk set\n            risk_set_groups = s_groups[at_risk_mask]\n            n_1j = np.sum(risk_set_groups == 1)\n\n            # Identify events at time t\n            event_mask = (s_times == t)  (s_events == 1)\n            d_j = np.sum(event_mask)\n            d_1j = np.sum(event_mask  (s_groups == 1))\n\n            if n_j == 0: # Should not happen if there are events\n                continue\n\n            # Calculate expected events and variance\n            E_j = d_j * (n_1j / n_j)\n            stratum_O_minus_E += (d_1j - E_j)\n\n            if n_j  1:\n                term1 = d_j * (n_1j / n_j) * (1 - n_1j / n_j)\n                correction = (n_j - d_j) / (n_j - 1)\n                V_j = term1 * correction\n            else:\n                # Variance is 0 if risk set size is 1 or less\n                V_j = 0.0\n            \n            stratum_V += V_j\n\n        stratum_results.append({'O_minus_E': stratum_O_minus_E, 'V': stratum_V})\n    \n    # --- 3. Aggregation and Statistic Construction ---\n    # Within-stratum statistics\n    alpha = 0.05\n    has_significant_stratum = False\n    \n    for res in stratum_results:\n        V_k = res['V']\n        O_minus_E_k = res['O_minus_E']\n        \n        if V_k  0:\n            S_k = (O_minus_E_k**2) / V_k\n            P_k = chi2.sf(S_k, 1)\n        else:\n            S_k = 0.0\n            P_k = 1.0\n        \n        if P_k  alpha:\n            has_significant_stratum = True\n\n    # Overall stratified statistic\n    total_O_minus_E = sum(res['O_minus_E'] for res in stratum_results)\n    total_V = sum(res['V'] for res in stratum_results)\n\n    if total_V  0:\n        S = (total_O_minus_E**2) / total_V\n        P = chi2.sf(S, 1)\n    else:\n        S = 0.0\n        P = 1.0\n\n    return [S, P, has_significant_stratum]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"times\": np.array([2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 8, 9, 10, 11]),\n            \"events\": np.array([1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]),\n            \"groups\": np.array([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]),\n            \"z\": np.array([1, -1, 1, -1, 1, -1, 1, -1, 2, -2, 2, -2, 2, -2, 2, -2]),\n        },\n        {\n            \"times\": np.array([5, 6, 7, 8, 3, 6, 4, 5]),\n            \"events\": np.array([0, 0, 0, 0, 1, 1, 1, 1]),\n            \"groups\": np.array([0, 1, 0, 1, 0, 0, 1, 1]),\n            \"z\": np.array([1, -1, -1, 1, 2, 2, -2, -2]),\n        },\n        {\n            \"times\": np.array([5, 5, 5, 9, 7, 7, 9, 9]),\n            \"events\": np.array([1, 1, 1, 0, 1, 1, 0, 0]),\n            \"groups\": np.array([0, 1, 0, 1, 0, 1, 0, 1]),\n            \"z\": np.array([1, -1, 1, -1, 2, -2, 2, -2]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        S, P, B = stratified_log_rank(**case)\n        results.append([round(S, 6), round(P, 6), B])\n\n    # Format the output string without spaces inside the inner lists.\n    formatted_results = []\n    for res_list in results:\n        # Format floats to 6 decimal places, ensuring trailing zeros\n        s_str = f\"{res_list[0]:.6f}\"\n        p_str = f\"{res_list[1]:.6f}\"\n        b_str = str(res_list[2])\n        formatted_results.append(f\"[{s_str},{p_str},{b_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}