{
    "hands_on_practices": [
        {
            "introduction": "Kaplan-Meier (KM) 估计是生存分析中的基石工具，用于从删失数据中估计生存函数。然而，我们得到的生存曲线的精度并非一成不变，它很大程度上取决于数据的内在结构，特别是删失的程度。本练习  旨在通过一个思想实验，帮助我们深入理解删失率对KM估计量方差的影响，从而建立关于生存数据中“信息量”的关键直觉。",
            "id": "3179136",
            "problem": "一项队列研究从基线开始随访 $n=100$ 名独立受试者。考虑使用非参数 Kaplan–Meier (KM) 估计量来估计 $t=9$ 个月时的生存函数。在下述两种研究设计中，$t=9$ 个月之前恰好有三个不同的事件时间，分别为 $t_1=3$、$t_2=6$ 和 $t_3=9$ 个月，对应的事件数分别为 $d_1=5$、$d_2=4$ 和 $d_3=3$。事件与删失不会恰好发生在同一记录时间点。这些设计的唯一区别在于事件时间之间删失的受试者数量，具体如下：\n\n- 设计 L（较低删失）：在 $0$ 到 $3$ 个月之间，删失 $c_{(0,3)}=0$ 人；在 $3$ 到 $6$ 个月之间，删失 $c_{(3,6)}=2$ 人；在 $6$ 到 $9$ 个月之间，删失 $c_{(6,9)}=3$ 人。在 $t=9$ 个月之前没有其他失访。\n- 设计 H（较高删失）：在 $0$ 到 $3$ 个月之间，删失 $c_{(0,3)}=10$ 人；在 $3$ 到 $6$ 个月之间，删失 $c_{(3,6)}=10$ 人；在 $6$ 到 $9$ 个月之间，删失 $c_{(6,9)}=10$ 人。在 $t=9$ 个月之前没有其他失访。\n\n仅使用 KM 估计量、风险集的基本定义，以及 KM 估计量在固定时间点上经过充分检验的大样本方差行为，判断哪个陈述最能描述设计 H 和设计 L 在 $t=9$ 个月时方差的比较情况。选择唯一最佳答案。\n\nA. 设计 H 在 $t=9$ 个月时的方差较小，因为提供信息的个体较少，从而导致变异性降低。\n\nB. 设计 H 在 $t=9$ 个月时的方差较大，因为在 $t=9$ 个月之前增加的删失减少了事件时间点的风险集大小，从而增大了乘积极限估计量的变异性。\n\nC. 两种设计在 $t=9$ 个月时的方差相同，因为 KM 估计量及其变异性仅取决于事件数和事件时间，而不取决于删失。\n\nD. 设计 H 在 $t=9$ 个月时的方差是未定义的，因为严重的删失使得在 $t=9$ 个月之前的非参数生存估计无效。",
            "solution": "用户希望我验证一个关于 Kaplan-Meier 估计量在两种不同删失情景下其方差比较的问题陈述。\n\n### 步骤1：提取已知条件\n\n-   基线时总受试者数：$n=100$，独立。\n-   任务：使用 Kaplan-Meier (KM) 估计量估计 $t=9$ 个月时的生存函数 $S(t)$。\n-   不同的事件时间：$t_1=3$ 个月，$t_2=6$ 个月，$t_3=9$ 个月。\n-   事件数：$t_1$ 时 $d_1=5$，$t_2$ 时 $d_2=4$，$t_3$ 时 $d_3=3$。\n-   在同一记录时间点，事件和删失没有出现结。\n-   设计 L（较低删失）：\n    -   在 $(0, 3)$ 个月内删失的受试者数：$c_{(0,3)}=0$。\n    -   在 $(3, 6)$ 个月内删失的受试者数：$c_{(3,6)}=2$。\n    -   在 $(6, 9)$ 个月内删失的受试者数：$c_{(6,9)}=3$。\n-   设计 H（较高删失）：\n    -   在 $(0, 3)$ 个月内删失的受试者数：$c_{(0,3)}=10$。\n    -   在 $(3, 6)$ 个月内删失的受试者数：$c_{(3,6)}=10$。\n    -   在 $(6, 9)$ 个月内删失的受试者数：$c_{(6,9)}=10$。\n-   问题要求比较设计 H 和设计 L 中 KM 估计量在 $t=9$ 个月时的方差 $\\text{Var}(\\hat{S}(9))$。\n\n### 步骤2：使用提取的已知条件进行验证\n\n必须评估问题陈述的科学依据、适定性和客观性。\n\n1.  **科学或事实不健全性**：该问题基于成熟的生存分析统计理论。Kaplan-Meier 估计量、风险集、删失以及通过 Greenwood 公式进行方差估计都是该领域的标准课题。该设置描述了一个合理的队列研究。未检测到科学或事实上的不健全之处。\n2.  **不可形式化或不相关**：该问题完全可以在生存分析的框架内形式化，并且与*生存分析基础*这一主题直接相关。\n3.  **不完整或矛盾的设置**：该问题提供了计算感兴趣量所需的所有必要数据。我们来验证一下数字的一致性。\n    -   对于设计 L，在每个事件时间 $t_i$ 的风险个体数 $n_i$：\n        -   $n_{1,L} = 100 - c_{(0,3)} = 100 - 0 = 100$。\n        -   $n_{2,L} = (n_{1,L} - d_1) - c_{(3,6)} = (100 - 5) - 2 = 93$。\n        -   $n_{3,L} = (n_{2,L} - d_2) - c_{(6,9)} = (93 - 4) - 3 = 86$。\n    -   对于设计 H，在每个事件时间 $t_i$ 的风险个体数 $n_i$：\n        -   $n_{1,H} = 100 - c_{(0,3)} = 100 - 10 = 90$。\n        -   $n_{2,H} = (n_{1,H} - d_1) - c_{(3,6)} = (90 - 5) - 10 = 75$。\n        -   $n_{3,H} = (n_{2,H} - d_2) - c_{(6,9)} = (75 - 4) - 10 = 61$。\n    在两种设计中，每个时间点的风险人数 ($n_i$) 始终大于事件数 ($d_i$)，因此计算是良定义的。设置是完整且内部一致的。\n4.  **不切实际或不可行**：这些数字对于医学或工程可靠性研究是合理的。不存在物理上或科学上的不可能性。\n5.  **不适定或结构不良**：问题明确，要求比较方差，这是一个良定义的统计量。可以推导出唯一、稳定且有意义的解。\n6.  **伪深刻、琐碎或同义反复**：该问题测试了关于删失对生存估计精度影响的核心概念点。它并不琐碎，因为它需要理解 KM 估计量方差公式的结构。\n7.  **无法进行科学验证**：这些主张在数学上是可验证的。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。开始解题。\n\n### 推导\n\n生存函数 $S(t)$ 的 Kaplan-Meier (KM) 估计量由乘积极限公式给出：\n$$ \\hat{S}(t) = \\prod_{i: t_i \\le t} \\left( 1 - \\frac{d_i}{n_i} \\right) $$\n其中 $t_i$ 是不同的事件时间，$d_i$ 是在 $t_i$ 时的事件数，$n_i$ 是在 $t_i$ 之前风险集中的个体数量（即，正在被观察且尚未发生事件的个体）。\n\n问题关注的是 $t=9$ 个月时 KM 估计量的方差。$\\hat{S}(t)$ 的大样本近似方差最常用的公式是 Greenwood 公式：\n$$ \\widehat{\\text{Var}}(\\hat{S}(t)) \\approx [\\hat{S}(t)]^2 \\sum_{i: t_i \\le t} \\frac{d_i}{n_i(n_i - d_i)} $$\n我们需要比较设计 L 的 $\\widehat{\\text{Var}}(\\hat{S}_L(9))$ 和设计 H 的 $\\widehat{\\text{Var}}(\\hat{S}_H(9))$。求和将针对三个事件时间 $t_1=3$、$t_2=6$ 和 $t_3=9$ 进行。\n\n我们来计算两种设计的风险集大小 $n_i$。\n\n**对于设计 L（较低删失）：**\n-   在 $t_1=3$ 时的风险集：$n_{1,L} = 100$。\n-   $t_1$ 后的存活者数：$100 - 5 = 95$。\n-   在 $(3,6)$ 期间删失的人数：$c_{(3,6)} = 2$。\n-   在 $t_2=6$ 时的风险集：$n_{2,L} = 95 - 2 = 93$。\n-   $t_2$ 后的存活者数：$93 - 4 = 89$。\n-   在 $(6,9)$ 期间删失的人数：$c_{(6,9)} = 3$。\n-   在 $t_3=9$ 时的风险集：$n_{3,L} = 89 - 3 = 86$。\n\n**对于设计 H（较高删失）：**\n-   在 $t_1=3$ 时的风险集：$n_{1,H} = 100 - 10 = 90$。\n-   $t_1$ 后的存活者数：$90 - 5 = 85$。\n-   在 $(3,6)$ 期间删失的人数：$c_{(3,6)} = 10$。\n-   在 $t_2=6$ 时的风险集：$n_{2,H} = 85 - 10 = 75$。\n-   $t_2$ 后的存活者数：$75 - 4 = 71$。\n-   在 $(6,9)$ 期间删失的人数：$c_{(6,9)} = 10$。\n-   在 $t_3=9$ 时的风险集：$n_{3,H} = 71 - 10 = 61$。\n\n通过直接比较，对于每个事件时间 $i \\in \\{1, 2, 3\\}$，设计 H 中的风险集大小都小于设计 L：\n-   $n_{1,H} = 90  n_{1,L} = 100$\n-   $n_{2,H} = 75  n_{2,L} = 93$\n-   $n_{3,H} = 61  n_{3,L} = 86$\n\n现在，我们来分析对方差的影响。方差公式由两部分组成：生存估计的平方 $[\\hat{S}(9)]^2$ 和求和项 $\\sum_{i=1}^3 \\frac{d_i}{n_i(n_i-d_i)}$。\n\n1.  **求和项分析：** 求和中的各项形式为 $\\frac{d_i}{n_i(n_i-d_i)}$。由于在每个时间点 $i$，两个设计中的 $d_i$ 都是恒定的，并且函数 $f(x) = \\frac{k}{x(x-k)}$（对于固定的 $k>0$）在 $x>k$ 时是递减函数，所以较小的 $n_i$ 值会导致该项的值较大。\n    由于对于所有 $i=1, 2, 3$ 都有 $n_{i,H}  n_{i,L}$，因此：\n    $$ \\frac{d_i}{n_{i,H}(n_{i,H} - d_i)} > \\frac{d_i}{n_{i,L}(n_{i,L} - d_i)} \\quad \\text{对于每个 } i. $$\n    因此，设计 H 的整个和更大：\n    $$ \\sum_{i=1}^3 \\frac{d_i}{n_{i,H}(n_{i,H} - d_i)} > \\sum_{i=1}^3 \\frac{d_i}{n_{i,L}(n_{i,L} - d_i)} $$\n\n2.  **生存估计分析：** 生存估计 $\\hat{S}(9)$ 是各项 $(1 - d_i/n_i)$ 的乘积。由于 $n_{i,H}  n_{i,L}$，风险估计 $d_i/n_{i,H} > d_i/n_{i,L}$，这意味着对于每个 $i$，生存因子 $(1 - d_i/n_{i,H})  (1 - d_i/n_{i,L})$。因此，设计 H 的乘积更小：$\\hat{S}_H(9)  \\hat{S}_L(9)$。这意味着前置因子 $[\\hat{S}_H(9)]^2$ 小于 $[\\hat{S}_L(9)]^2$。\n\n尽管这两个效应（求和项和前置因子）方向相反，但求和项的变化通常占主导地位。这里测试的核心原理是，删失减少了可用于估计的信息量，这直观上必然导致更高的方差（更低的精度）。较小的风险集直接反映了这种信息损失。我们通过计算来证实这一点。\n\n对于设计 L：$\\hat{S}_L(9) = (1 - \\frac{5}{100})(1 - \\frac{4}{93})(1 - \\frac{3}{86}) \\approx 0.8770$。\nL 的求和项：$\\frac{5}{100(95)} + \\frac{4}{93(89)} + \\frac{3}{86(83)} \\approx 0.000526 + 0.000483 + 0.000420 = 0.001429$。\n$\\widehat{\\text{Var}}(\\hat{S}_L(9)) \\approx (0.8770)^2 \\times 0.001429 \\approx 0.7691 \\times 0.001429 \\approx 0.001099$。\n\n对于设计 H：$\\hat{S}_H(9) = (1 - \\frac{5}{90})(1 - \\frac{4}{75})(1 - \\frac{3}{61}) \\approx 0.8494$。\nH 的求和项：$\\frac{5}{90(85)} + \\frac{4}{75(71)} + \\frac{3}{61(58)} \\approx 0.000654 + 0.000751 + 0.000848 = 0.002253$。\n$\\widehat{\\text{Var}}(\\hat{S}_H(9)) \\approx (0.8494)^2 \\times 0.002253 \\approx 0.7215 \\times 0.002253 \\approx 0.001626$。\n\n计算证实了 $\\widehat{\\text{Var}}(\\hat{S}_H(9)) > \\widehat{\\text{Var}}(\\hat{S}_L(9))$。设计 H 的方差更大。这是因为更重的删失导致风险集大小 ($n_i$) 减小，这使得单个方差贡献项 $\\frac{d_i}{n_i(n_i-d_i)}$ 的增加程度，比生存估计前置因子 $[\\hat{S}(9)]^2$ 的减少程度更为显著。\n\n### 逐项分析\n\nA. 设计 H 在 $t=9$ 个月时的方差较小，因为提供信息的个体较少，从而导致变异性降低。\n这个陈述基于两个理由是错误的。首先，我们的计算表明设计 H 的方差更大，而不是更小。其次，其推理有缺陷；提供信息的个体较少（即有效样本量较小）会导致变异性*增加*，而不是减少。\n**结论：错误。**\n\nB. 设计 H 在 $t=9$ 个月时的方差较大，因为在 $t=9$ 个月之前增加的删失减少了事件时间点的风险集大小，从而增大了乘积极限估计量的变异性。\n这个陈述正确地声称设计 H 的方差更大。其提供的推理正是导致这一结果的机制：增加的删失导致风险集 ($n_i$) 变小，这反过来又增加了 Greenwood 公式中的各项，从而“增大了变异性”。这与我们的推导完全一致。\n**结论：正确。**\n\nC. 两种设计在 $t=9$ 个月时的方差相同，因为 KM 估计量及其变异性仅取决于事件数和事件时间，而不取决于删失。\n这个陈述是错误的。我们的计算表明方差是不同的。其推理从根本上是错误的。KM 估计 $\\hat{S}(t)$ 及其方差都明确地依赖于风险集大小 $n_i$，而风险集大小直接受删失模式的影响。\n**结论：错误。**\n\nD. 设计 H 在 $t=9$ 个月时的方差是未定义的，因为严重的删失使得在 $t=9$ 个月之前的非参数生存估计无效。\n这个陈述是错误的。只要风险集不变为零，KM 估计量及其方差就是良定义的。在设计 H 中，$t=9$ 个月时的风险集是 $n_{3,H} = 61$，远大于零。设计 H 中的删失程度还不足以导致估计量未定义。\n**结论：错误。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在临床研究中，比较不同治疗组的生存曲线是一项核心任务。虽然对数秩检验（log-rank test）等方法可以比较整个曲线，但一个如平均生存时间差异这样的总结性指标往往更具临床解释性。限制性平均生存时间（Restricted Mean Survival Time, RMST）正为此而生，它通过计算生存曲线下的面积来提供一个稳健的比较。本练习  提供了一个将RMST理论转化为具体代码实现的机会，这在处理不满足比例风险假设的数据时尤其有价值。",
            "id": "3179108",
            "problem": "给定两个治疗组 A 和 B，每个组的估计生存曲线表示为一个在有限时间网格上的右连续、非增的分段常数阶梯函数。目的是计算直至一个有限时间终点的限制性平均生存时间 (RMST)，然后以一种在非比例风险 (NPH) 条件下仍然有效的方式比较这两个治疗组。比较应通过在该时间终点的限制性平均生存时间之差进行，该差值总结了到该时间点为止的总体平均生存情况，且不依赖于比例风险假设。\n\n基本原理：\n- 生存函数定义为 $S(t)=\\mathbb{P}(Tt)$，其中 $T$ 是一个非负的事件发生时间随机变量。\n- 截至有限时间终点 $\\,\\tau\\,$ 的限制性平均生存时间定义为生存曲线下从 $\\,t=0\\,$ 到 $\\,t=\\tau\\,$ 的面积。\n- 对于一个在有限网格 $0=g_0g_1\\dotsg_m$ 上定义的右连续阶梯函数 $S(t)$，该函数在每个区间 $[g_k,g_{k+1})$ 上为常数，其值等于在 $g_k$ 处给定的值。如果 $\\tau$ 严格位于一个区间内部，则最后一个区间在 $\\tau$ 处被截断。\n\n程序输入规范：\n- 程序应内部存储一个测试用例列表。每个测试用例包含：\n  - 一个严格递增的时间网格 $[g_0,g_1,\\dots,g_m]$，其中 $g_0=0$ 且 $g_m\\ge \\tau$。\n  - 两个生存值列表，一个用于 A 组，一个用于 B 组，每个列表长度为 $m+1$。索引 $k$ 处的值是区间 $[g_k,g_{k+1})$ 上的右连续生存水平。\n  - 一个有限的时间终点 $\\tau$，其中 $0\\le \\tau\\le g_m$。\n- 所有生存值都在 $[0,1]$ 范围内，并且随网格索引非递增。\n\n任务：\n- 对每个测试用例，使用上述分段常数解释，通过对给定的阶梯函数从 $t=0$ 积分到 $t=\\tau$ 来计算 A 组和 B 组的限制性平均生存时间。\n- 计算差值 $\\Delta=\\mathrm{RMST}_B-\\mathrm{RMST}_A$。\n- 报告一个偏好指标 $I$，定义如下：\n  - 如果 $\\Delta0$，则 $I=1$\n  - 如果 $\\Delta0$，则 $I=-1$\n  - 如果 $\\Delta=0$，则 $I=0$\n  使用 $10^{-12}$ 的数值容差来判断相等。\n\n要求的数值输出格式：\n- 对于每个测试用例，输出一个包含四个值的列表：$[\\mathrm{RMST}_A,\\mathrm{RMST}_B,\\Delta,I]$。\n- 前三个值必须是四舍五入到六位小数的浮点数。最后一个值必须是整数。\n- 程序必须生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，其中每个元素是该测试用例的方括号四值列表。例如：$[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\dots]$。\n\n需要在程序内部实现的测试套件：\n- 案例 1 (非比例风险，生存曲线交叉且内部截断)：\n  - 网格：$[0.0,2.0,5.0,8.0,12.0]$\n  - A 组：$[1.0,0.92,0.80,0.74,0.70]$\n  - B 组：$[1.0,0.96,0.78,0.77,0.72]$\n  - 时间终点：$\\tau=10.0$\n- 案例 2 (时间终点等于最后一个网格点)：\n  - 网格：$[0.0,3.0,6.0,9.0,12.0]$\n  - A 组：$[1.0,0.90,0.82,0.70,0.60]$\n  - B 组：$[1.0,0.95,0.75,0.72,0.65]$\n  - 时间终点：$\\tau=12.0$\n- 案例 3 (小的时间终点在第一个区间内，预期为平局)：\n  - 网格：$[0.0,4.0,9.0]$\n  - A 组：$[1.0,0.85,0.70]$\n  - B 组：$[1.0,0.88,0.68]$\n  - 时间终点：$\\tau=2.0$\n- 案例 4 (多次交叉且时间终点在网格点上)：\n  - 网格：$[0.0,1.0,2.5,4.0,7.5,10.0]$\n  - A 组：$[1.0,0.97,0.90,0.86,0.80,0.78]$\n  - B 组：$[1.0,0.99,0.91,0.85,0.79,0.76]$\n  - 时间终点：$\\tau=7.5$\n\n您的程序应计算每个案例的四个要求值，并按照上述描述的精确格式在单行中打印它们。不涉及用户输入；所有数据都嵌入在程序中。",
            "solution": "所提出的问题是有效的。它在科学上基于生存分析（统计学的一个分支）的原理，并且问题定义良好，具有清晰、客观和完整的规范。获得唯一解所需的所有数据和定义都已提供。\n\n主要目标是计算两个治疗组 A 和 B 截至指定时间终点 $\\tau$ 的限制性平均生存时间 (RMST)。RMST 是一个用于比较生存分布的稳健指标，尤其是在不满足比例风险假设时。每个组的生存函数 $S(t)$ 均以右连续、分段常数的阶梯函数形式提供。\n\n截至时间 $\\tau > 0$ 的 RMST 定义为生存曲线下从时间 $t=0$ 到 $t=\\tau$ 的总面积：\n$$\n\\mathrm{RMST}(\\tau) = \\int_{0}^{\\tau} S(t) dt\n$$\n生存函数 $S_A(t)$ 和 $S_B(t)$ 定义在一个有限的、严格递增的时间网格 $G = \\{g_0, g_1, \\dots, g_m\\}$ 上，其中 $g_0=0$。对于每个组，都给出了一个相应的生存概率列表 $s = \\{s_0, s_1, \\dots, s_m\\}$。问题规定生存函数 $S(t)$ 在每个区间 $[g_k, g_{k+1})$ 上为常数，取值为 $s_k$。即：\n$$\nS(t) = s_k \\quad \\text{for } t \\in [g_k, g_{k+1})\n$$\n计算 $\\mathrm{RMST}(\\tau)$ 的积分可以通过对阶梯函数在区间 $[0, \\tau]$ 上形成的矩形面积求和来完成。设网格点为 $g_0, g_1, \\dots, g_m$。我们遍历由这些网格点定义的区间。\n\n对于每个区间 $[g_k, g_{k+1})$（其中 $k \\in \\{0, 1, \\dots, m-1\\}$），我们计算其对积分的贡献。\n让我们考虑一个从 $g_k$ 开始的区间。\n如果时间终点 $\\tau$ 小于或等于 $g_k$，那么该区间及所有后续区间对积分的面积贡献为零。\n如果时间终点 $\\tau$ 大于 $g_{k+1}$，则该区间的完整矩形面积都包括在内。面积为高度 $s_k$ 乘以区间宽度 $(g_{k+1} - g_k)$。\n如果时间终点 $\\tau$ 落在该区间内，即 $g_k  \\tau \\le g_{k+1}$，则其贡献来自一个被截断的矩形。面积为高度 $s_k$ 乘以宽度 $(\\tau - g_k)$。这是对积分的最后贡献。\n\n这个过程可以表述为一个算法。我们将 $\\mathrm{RMST}$ 初始化为 $0$。然后我们从 $k=0$ 迭代到 $m-1$：\n1. 定义区间起点 $t_{\\text{start}} = g_k$ 和终点 $t_{\\text{end}} = g_{k+1}$。\n2. 如果 $\\tau \\le t_{\\text{start}}$，则积分完成，我们停止。\n3. 确定积分区间的有效终点。这是区间终点 $t_{\\text{end}}$ 和时间终点 $\\tau$ 中的较小值。设其为 $t_{\\text{effective\\_end}} = \\min(\\tau, t_{\\text{end}})$。\n4. 该分段的矩形宽度为 $w_k = t_{\\text{effective\\_end}} - t_{\\text{start}}$。\n5. 该分段的生存概率为 $s_k$。\n6. 要加上的面积是 $A_k = s_k \\times w_k$。\n7. 将此面积加到总和中：$\\mathrm{RMST} = \\mathrm{RMST} + A_k$。\n\n使用此方法计算出 $\\mathrm{RMST}_A$ 和 $\\mathrm{RMST}_B$ 后，我们求它们的差：\n$$\n\\Delta = \\mathrm{RMST}_B - \\mathrm{RMST}_A\n$$\n$\\Delta$ 的符号表明哪个治疗组在时间终点 $\\tau$ 前有更长的平均生存时间。正的 $\\Delta$ 有利于 B 组，而负的 $\\Delta$ 有利于 A 组。\n\n最后，我们根据 $\\Delta$ 定义一个偏好指标 $I$，使用数值容差 $\\epsilon=10^{-12}$ 来处理与零比较时潜在的浮点不精确性。\n$$\nI = \\begin{cases}\n1  \\text{if } \\Delta > \\epsilon \\\\\n-1  \\text{if } \\Delta  -\\epsilon \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n每个测试用例的最终输出是一个包含计算值的列表：$[\\mathrm{RMST}_A, \\mathrm{RMST}_B, \\Delta, I]$，其中前三个值四舍五入到六位小数。\n\n例如，我们来计算案例 1 的结果：\n- 网格: $g = [0.0, 2.0, 5.0, 8.0, 12.0]$\n- A 组生存率: $s_A = [1.0, 0.92, 0.80, 0.74, 0.70]$\n- B 组生存率: $s_B = [1.0, 0.96, 0.78, 0.77, 0.72]$\n- 时间终点: $\\tau = 10.0$\n\n对于 A 组:\n- 区间 $[0.0, 2.0)$: 面积 = $s_{A,0} \\times (2.0 - 0.0) = 1.0 \\times 2.0 = 2.0$\n- 区间 $[2.0, 5.0)$: 面积 = $s_{A,1} \\times (5.0 - 2.0) = 0.92 \\times 3.0 = 2.76$\n- 区间 $[5.0, 8.0)$: 面积 = $s_{A,2} \\times (8.0 - 5.0) = 0.80 \\times 3.0 = 2.40$\n- 区间 $[8.0, 12.0)$，在 $\\tau=10.0$ 处截断: 面积 = $s_{A,3} \\times (10.0 - 8.0) = 0.74 \\times 2.0 = 1.48$\n- $\\mathrm{RMST}_A = 2.0 + 2.76 + 2.40 + 1.48 = 8.64$\n\n对于 B 组:\n- 区间 $[0.0, 2.0)$: 面积 = $s_{B,0} \\times (2.0 - 0.0) = 1.0 \\times 2.0 = 2.0$\n- 区间 $[2.0, 5.0)$: 面积 = $s_{B,1} \\times (5.0 - 2.0) = 0.96 \\times 3.0 = 2.88$\n- 区间 $[5.0, 8.0)$: 面积 = $s_{B,2} \\times (8.0 - 5.0) = 0.78 \\times 3.0 = 2.34$\n- 区间 $[8.0, 12.0)$，在 $\\tau=10.0$ 处截断: 面积 = $s_{B,3} \\times (10.0 - 8.0) = 0.77 \\times 2.0 = 1.54$\n- $\\mathrm{RMST}_B = 2.0 + 2.88 + 2.34 + 1.54 = 8.76$\n\n比较:\n- $\\Delta = \\mathrm{RMST}_B - \\mathrm{RMST}_A = 8.76 - 8.64 = 0.12$\n- 由于 $0.12 > 10^{-12}$，指标 $I=1$。\n- 案例 1 的结果是 $[8.640000, 8.760000, 0.120000, 1]$。\n此过程将应用于所有提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Restricted Mean Survival Time (RMST) problem for a set of predefined test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: non-proportional hazards with crossing survival and interior truncation\n        {\n            \"grid\": np.array([0.0, 2.0, 5.0, 8.0, 12.0]),\n            \"surv_a\": np.array([1.0, 0.92, 0.80, 0.74, 0.70]),\n            \"surv_b\": np.array([1.0, 0.96, 0.78, 0.77, 0.72]),\n            \"tau\": 10.0,\n        },\n        # Case 2: horizon equals last grid point\n        {\n            \"grid\": np.array([0.0, 3.0, 6.0, 9.0, 12.0]),\n            \"surv_a\": np.array([1.0, 0.90, 0.82, 0.70, 0.60]),\n            \"surv_b\": np.array([1.0, 0.95, 0.75, 0.72, 0.65]),\n            \"tau\": 12.0,\n        },\n        # Case 3: small horizon inside the first interval, tie expected\n        {\n            \"grid\": np.array([0.0, 4.0, 9.0]),\n            \"surv_a\": np.array([1.0, 0.85, 0.70]),\n            \"surv_b\": np.array([1.0, 0.88, 0.68]),\n            \"tau\": 2.0,\n        },\n        # Case 4: multiple crossings and horizon on a grid point\n        {\n            \"grid\": np.array([0.0, 1.0, 2.5, 4.0, 7.5, 10.0]),\n            \"surv_a\": np.array([1.0, 0.97, 0.90, 0.86, 0.80, 0.78]),\n            \"surv_b\": np.array([1.0, 0.99, 0.91, 0.85, 0.79, 0.76]),\n            \"tau\": 7.5,\n        },\n    ]\n\n    def calculate_rmst(grid, survival_values, tau):\n        \"\"\"\n        Calculates the RMST for a right-continuous piecewise-constant survival function.\n        \n        Args:\n            grid (np.ndarray): The time grid points.\n            survival_values (np.ndarray): The survival probabilities on each interval.\n            tau (float): The time horizon for restriction.\n            \n        Returns:\n            float: The calculated RMST.\n        \"\"\"\n        rmst = 0.0\n        # Iterate through the intervals defined by the grid\n        for i in range(len(grid) - 1):\n            t_start = grid[i]\n            t_end = grid[i+1]\n            \n            # If the integration horizon is before or at the start of this interval, we are done.\n            if tau = t_start:\n                break\n            \n            # The value of the survival function in this interval [t_start, t_end)\n            s_val = survival_values[i]\n            \n            # Calculate the width of the integration for this interval.\n            # It's the distance from t_start to either tau or t_end, whichever is smaller.\n            integration_end = min(tau, t_end)\n            width = integration_end - t_start\n            \n            # Add the area of this rectangular segment to the total RMST.\n            rmst += s_val * width\n            \n        return rmst\n\n    formatted_results = []\n    tolerance = 1e-12\n\n    for case in test_cases:\n        grid, surv_a, surv_b, tau = case[\"grid\"], case[\"surv_a\"], case[\"surv_b\"], case[\"tau\"]\n\n        rmst_a = calculate_rmst(grid, surv_a, tau)\n        rmst_b = calculate_rmst(grid, surv_b, tau)\n        \n        delta = rmst_b - rmst_a\n        \n        if delta > tolerance:\n            indicator = 1\n        elif delta  -tolerance:\n            indicator = -1\n        else:\n            indicator = 0\n            \n        # Format the result list for this case as a string\n        case_result_str = (\n            f\"[{rmst_a:.6f},{rmst_b:.6f},{delta:.6f},{indicator}]\"\n        )\n        formatted_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当我们希望研究协变量如何影响事件时间时，就需要借助回归模型，例如Cox比例风险模型和加速失效时间（Accelerated Failure Time, AFT）模型。然而，每个模型都有其核心假设，如Cox模型的比例风险（Proportional Hazards, PH）假设，违背这些假设可能会导致错误的结论。这项高级练习  将通过一个模拟研究，在一个已知PH假设不成立的场景中，探索哪种模型能提供更准确的预测，从而教会我们模型选择与诊断的关键一课。",
            "id": "3179084",
            "problem": "考虑一个影响事件时间随机变量 $T$ 的二元协变量 $x \\in \\{0,1\\}$。设生存函数定义为 $S(t \\mid x) = \\mathbb{P}(T  t \\mid x)$ (对于 $t \\ge 0$)，概率密度函数为 $f(t \\mid x)$，风险函数为 $h(t \\mid x) = \\frac{f(t \\mid x)}{S(t \\mid x)}$，累积风险函数为 $H(t \\mid x) = \\int_0^t h(u \\mid x) \\, du$。截至有限时间范围 $\\tau  0$ 的限制性平均生存时间 (RMST) 定义为\n$$\n\\mathrm{RMST}_x(\\tau) = \\int_0^\\tau S(t \\mid x)\\, dt.\n$$\n\n两种广泛使用的模型类别是：\n- Cox比例风险 (PH) 模型，该模型假定 $h(t \\mid x) = h_0(t)\\,\\exp(\\beta_{\\mathrm{Cox}} x)$，其中 $h_0(t)$ 是一个未指定的基线风险函数，$\\beta_{\\mathrm{Cox}}$ 是一个回归系数。\n- 加速失效时间 (AFT) 模型，该模型假定 $\\log T = \\mu + \\beta_{\\mathrm{AFT}} x + \\sigma Z$，其中 $Z \\sim \\mathcal{N}(0,1)$，$\\mu \\in \\mathbb{R}$，$\\beta_{\\mathrm{AFT}} \\in \\mathbb{R}$，且 $\\sigma  0$；这意味着一个对数正态生存分布，并且当 $\\beta_{\\mathrm{AFT}} \\ne 0$ 时，通常违反比例风险假设。\n\n从上述核心定义出发，您必须：\n1. 在对数正态AFT数据生成过程下，使用参数 $(\\mu, \\beta, \\sigma)$ 和率为 $\\lambda_c$ 的独立指数删失来模拟右删失生存数据。对于每个个体 $i$，抽取 $x_i \\in \\{0,1\\}$，$Z_i \\sim \\mathcal{N}(0,1)$，设置 $T_i = \\exp(\\mu + \\beta x_i + \\sigma Z_i)$，抽取 $C_i \\sim \\mathrm{Exp}(\\lambda_c)$，并观测 $Y_i = \\min(T_i, C_i)$ 及事件指示符 $\\delta_i = \\mathbb{I}\\{T_i \\le C_i\\}$。\n2. 通过最大化单个二元协变量 $x$ 的偏似然来拟合 Cox PH 模型，并使用 Breslow 估计量估计基线累积风险。使用这些来构建预测的生存函数 $\\widehat{S}_{\\mathrm{Cox}}(t \\mid x)$。\n3. 在右删失下通过最大似然法拟合对数正态 AFT 模型以估计 $(\\widehat{\\mu}, \\widehat{\\beta}, \\widehat{\\sigma})$，并使用拟合的参数构建预测的生存函数 $\\widehat{S}_{\\mathrm{AFT}}(t \\mid x)$。\n4. 在对数正态数据生成过程下计算真实生存函数 $S_{\\mathrm{true}}(t \\mid x)$，并计算相应的真实限制性平均生存时间 $\\mathrm{RMST}^{\\mathrm{true}}_x(\\tau) = \\int_0^\\tau S_{\\mathrm{true}}(t \\mid x) \\, dt$。使用在 $[0,\\tau]$ 上的足够精细的网格对所有积分进行数值近似。\n5. 对于每个模型 $M \\in \\{\\mathrm{Cox}, \\mathrm{AFT}\\}$ 和组 $x \\in \\{0,1\\}$，计算预测的限制性平均生存时间 $\\mathrm{RMST}^{M}_x(\\tau) = \\int_0^\\tau \\widehat{S}_M(t \\mid x)\\, dt$，以及其相对于真实值的绝对校准误差 $E^{M}_x(\\tau) = \\left|\\mathrm{RMST}^{M}_x(\\tau) - \\mathrm{RMST}^{\\mathrm{true}}_x(\\tau)\\right|$。通过平均绝对误差在两个组之间聚合校准，\n$$\n\\overline{E}^{M}(\\tau) = \\frac{E^{M}_0(\\tau) + E^{M}_1(\\tau)}{2}.\n$$\n6. 通过比较 $\\overline{E}^{\\mathrm{AFT}}(\\tau)$ 和 $\\overline{E}^{\\mathrm{Cox}}(\\tau)$ 来决定哪个模型能产生更好的 RMST$(\\tau)$ 校准：值较小的模型被认为校准得更好。\n\n您的程序必须实现上述完整流程，并评估一个包含以下参数集的测试套件。每个测试用例是一个元组 $(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed})$，其中 $n$ 是样本量，$p$ 是 $x=1$ 的概率，$\\mu$ 是对数尺度截距，$\\beta$ 是AFT效应，$\\sigma$ 是对数尺度标准差，$\\lambda_c$ 是指数删失率，$\\tau$ 是RMST时间范围，$\\text{seed}$ 是随机种子：\n- 案例 1：$(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed}) = (1000, 0.5, 2.0, 0.7, 0.6, 0.05, 10.0, 1)$。\n- 案例 2：$(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed}) = (1000, 0.5, 2.0, 1.0, 0.9, 0.2, 8.0, 2)$。\n- 案例 3：$(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed}) = (500, 0.2, 1.5, 0.8, 0.5, 0.1, 6.0, 3)$。\n- 案例 4：$(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed}) = (400, 0.5, 1.0, 1.2, 1.0, 0.3, 5.0, 4)$。\n\n数值单位：将时间视为任意单位；无需进行物理单位转换。不涉及角度。百分比必须表示为小数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例（按上述顺序），该元素必须是一个布尔值，指示加速失效时间模型是否比Cox比例风险模型产生更好的 RMST$(\\tau)$ 校准，即 $\\overline{E}^{\\mathrm{AFT}}(\\tau)  \\overline{E}^{\\mathrm{Cox}}(\\tau)$ 是否成立。最终输出必须如下所示\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4],\n$$\n其中每个 $\\text{result}_k \\in \\{\\text{True},\\text{False}\\}$。",
            "solution": "用户想要解决一个统计模拟问题。\n\n计划如下：\n1.  **验证问题陈述**：\n    -   提取所有给定信息：定义、模型规范、模拟步骤、计算公式和测试用例。\n    -   检查是否存在任何科学、逻辑或结构上的缺陷。\n\n2.  **若有效，则设计解决方案**：\n    -   该问题是一个多步骤的模拟和建模练习。我需要将其分解为一系列清晰的操作。\n    -   **步骤1：数据生成**。这一点已明确说明。对于每个个体 $i=1, ..., n$：\n        -   抽取 $x_i \\sim \\text{Bernoulli}(p)$。\n        -   抽取 $Z_i \\sim \\mathcal{N}(0,1)$。\n        -   计算真实事件时间 $T_i = \\exp(\\mu + \\beta x_i + \\sigma Z_i)$。\n        -   抽取删失时间 $C_i \\sim \\text{Exp}(\\lambda_c)$。\n        -   观测时间为 $Y_i = \\min(T_i, C_i)$。\n        -   事件指示符为 $\\delta_i = \\mathbb{I}\\{T_i \\le C_i\\}$。\n    -   **步骤2：Cox PH模型拟合**。\n        -   模型为 $h(t \\mid x) = h_0(t) \\exp(\\beta_{\\text{Cox}} x)$。\n        -   需要最大化单个二元协变量 $x$ 的偏对数似然来找到 $\\widehat{\\beta}_{\\text{Cox}}$。偏对数似然是：\n            $$ \\ell(\\beta) = \\sum_{i=1}^n \\delta_i \\left( \\beta x_i - \\log \\sum_{j \\in R(Y_i)} \\exp(\\beta x_j) \\right) $$\n            其中 $R(Y_i) = \\{j: Y_j \\ge Y_i\\}$ 是在时间 $Y_i$ 的风险集。\n        -   我将需要一个数值优化器（如Newton-Raphson或任何来自`scipy.optimize`的优化器）来找到 $\\widehat{\\beta}_{\\text{Cox}}$。Newton-Raphson是Cox模型的标准方法。\n            -   得分函数（一阶导数）：$U(\\beta) = \\frac{\\partial \\ell}{\\partial \\beta} = \\sum_{i=1}^n \\delta_i \\left( x_i - \\frac{\\sum_{j \\in R(Y_i)} x_j \\exp(\\beta x_j)}{\\sum_{j \\in R(Y_i)} \\exp(\\beta x_j)} \\right)$。\n            -   信息矩阵（负二阶导数）：$I(\\beta) = -\\frac{\\partial^2 \\ell}{\\partial \\beta^2} = \\sum_{i=1}^n \\delta_i \\left( \\frac{\\sum_{j \\in R(Y_i)} x_j^2 \\exp(\\beta x_j)}{\\sum_{j \\in R(Y_i)} \\exp(\\beta x_j)} - \\left( \\frac{\\sum_{j \\in R(Y_i)} x_j \\exp(\\beta x_j)}{\\sum_{j \\in R(Y_i)} \\exp(\\beta x_j)} \\right)^2 \\right)$。\n        -   找到 $\\widehat{\\beta}_{\\text{Cox}}$ 后，我需要使用 Breslow 估计量来估计累积基线风险 $H_0(t)$。\n            $$ \\widehat{H}_0(t) = \\sum_{Y_i \\le t, \\delta_i=1} \\frac{1}{\\sum_{j \\in R(Y_i)} \\exp(\\widehat{\\beta}_{\\text{Cox}} x_j)} $$\n            这是一个在观测到的事件时间处跳跃的阶梯函数。\n        -   Cox模型的预测生存函数是 $\\widehat{S}_{\\text{Cox}}(t \\mid x) = \\exp(-\\widehat{H}(t \\mid x)) = \\exp(-\\widehat{H}_0(t) \\exp(\\widehat{\\beta}_{\\text{Cox}} x))$。\n    -   **步骤3：对数正态AFT模型拟合**。\n        -   模型为 $\\log T = \\mu + \\beta x + \\sigma Z$，其中 $Z \\sim \\mathcal{N}(0,1)$。这等价于 $T \\sim \\text{Log-Normal}(\\mu + \\beta x, \\sigma^2)$。\n        -   令 $V_i = \\log Y_i$。该模型可以写成一个删失数据的线性回归模型：$V_i = \\mu + \\beta x_i + \\sigma Z_i^*$，其中 $Z_i^*$ 是误差项。\n        -   需要最大化来自参数分布的右删失数据的似然函数。对于个体 $i$，对似然的贡献是：\n            $$ L_i(\\mu, \\beta, \\sigma) = [f_{T_i}(Y_i \\mid x_i)]^{\\delta_i} [S_{T_i}(Y_i \\mid x_i)]^{1-\\delta_i} $$\n            其中 $f_{T_i}$ 和 $S_{T_i}$ 是对数正态分布的PDF和生存函数。\n        -   让我们处理对数似然和标准化变量。令 $z_i = (\\log Y_i - (\\mu + \\beta x_i)) / \\sigma$。\n        -   $\\log T_i$ 的PDF是 $f_{\\log T_i}(v) = \\frac{1}{\\sigma} \\phi\\left(\\frac{v - (\\mu+\\beta x_i)}{\\sigma}\\right)$，其中 $\\phi$ 是标准正态PDF。\n        -   $\\log T_i$ 的生存函数是 $S_{\\log T_i}(v) = 1 - \\Phi\\left(\\frac{v - (\\mu+\\beta x_i)}{\\sigma}\\right) = \\Phi\\left(-\\frac{v - (\\mu+\\beta x_i)}{\\sigma}\\right)$，其中 $\\Phi$ 是标准正态CDF。\n        -   使用变量变换公式，$T_i = \\exp(\\log T_i)$ 的PDF是 $f_{T_i}(t) = f_{\\log T_i}(\\log t) \\frac{1}{t}$。\n        -   因此，$f_{T_i}(t) = \\frac{1}{t\\sigma} \\phi\\left(\\frac{\\log t - (\\mu+\\beta x_i)}{\\sigma}\\right)$。\n        -   $T_i$ 的生存函数是 $S_{T_i}(t) = S_{\\log T_i}(\\log t)$。\n        -   因此，$S_{T_i}(t) = \\Phi\\left(-\\frac{\\log t - (\\mu+\\beta x_i)}{\\sigma}\\right)$。\n        -   需要最大化的对数似然是：\n            $$ \\ell(\\mu, \\beta, \\sigma) = \\sum_{i=1}^n \\left\\{ \\delta_i \\log f_{T_i}(Y_i \\mid x_i) + (1-\\delta_i) \\log S_{T_i}(Y_i \\mid x_i) \\right\\} $$\n            $$ \\ell(\\mu, \\beta, \\sigma) = \\sum_{i=1}^n \\left\\{ \\delta_i \\left[ -\\log Y_i - \\log \\sigma + \\log \\phi(z_i) \\right] + (1-\\delta_i) \\log \\Phi(-z_i) \\right\\} $$\n            其中 $z_i = (\\log Y_i - \\mu - \\beta x_i)/\\sigma$。\n        -   我需要使用`scipy.optimize`中的数值优化器来最大化此函数，以求解 $(\\mu, \\beta, \\sigma)$。让我们在负对数似然上使用`minimize`。参数是 $(\\mu, \\beta, \\log \\sigma)$ 以确保 $\\sigma > 0$。\n        -   找到 $(\\widehat{\\mu}, \\widehat{\\beta}, \\widehat{\\sigma})$ 后，AFT模型的预测生存函数是：\n            $$ \\widehat{S}_{\\text{AFT}}(t \\mid x) = \\Phi\\left(-\\frac{\\log t - (\\widehat{\\mu}+\\widehat{\\beta} x)}{\\widehat{\\sigma}}\\right) $$\n    -   **步骤4：真实生存函数和RMST**。\n        -   数据由参数为 $(\\mu, \\beta, \\sigma)$ 的对数正态AFT模型生成。所以真实生存函数是已知的。\n        -   $S_{\\text{true}}(t \\mid x) = \\Phi\\left(-\\frac{\\log t - (\\mu+\\beta x)}{\\sigma}\\right)$。\n        -   真实的RMST是 $\\mathrm{RMST}^{\\text{true}}_x(\\tau) = \\int_0^\\tau S_{\\text{true}}(t \\mid x) \\, dt$。\n    -   **步骤5：预测的RMST和误差计算**。\n        -   对于每个模型 $M \\in \\{\\text{Cox}, \\text{AFT}\\}$ 和组 $x \\in \\{0,1\\}$，计算预测的RMST：\n            $$ \\mathrm{RMST}^{M}_x(\\tau) = \\int_0^\\tau \\widehat{S}_M(t \\mid x)\\, dt $$\n        -   这些积分将进行数值计算。问题指定使用“在$[0,\\tau]$上足够精细的网格”。我可以使用辛普森法则或梯形法则。让我们使用从 $0$ 到 $\\tau$ 的1000个点的网格。\n        -   然后，计算绝对校准误差：\n            $$ E^{M}_x(\\tau) = \\left|\\mathrm{RMST}^{M}_x(\\tau) - \\mathrm{RMST}^{\\text{true}}_x(\\tau)\\right| $$\n        -   最后，平均绝对误差：\n            $$ \\overline{E}^{M}(\\tau) = \\frac{E^{M}_0(\\tau) + E^{M}_1(\\tau)}{2} $$\n    -   **步骤6：比较**。\n        -   比较 $\\overline{E}^{\\text{AFT}}(\\tau)$ 和 $\\overline{E}^{\\text{Cox}}(\\tau)$。\n        -   如果 $\\overline{E}^{\\text{AFT}}(\\tau)  \\overline{E}^{\\text{Cox}}(\\tau)$，则该测试用例的结果为 `True`，否则为 `False`。\n    -   **实现细节**：\n        -   数值积分：我可以使用 `np.trapz` 或 `scipy.integrate.simps` 或 `scipy.integrate.quad`。鉴于所要求的自包含性以及网格建议，在一个numpy数组上实现一个简单的梯形法则是稳健且足够的。\n        -   优化：`scipy.optimize.minimize` 将是Cox和AFT模型拟合的主力。我需要定义负对数似然函数。对于Cox模型，Newton-Raphson实现可能更标准和高效。让我检查一下复杂性。\n        -   Cox模型拟合：为Newton-Raphson实现得分和信息矩阵是直接的，但涉及到遍历排序后的事件时间。\n            -   按观测时间 $Y_i$ 对数据进行排序。\n            -   遍历事件时间 $t_k$。对于每个 $t_k$，风险集 $R(t_k)$ 很容易确定。\n            -   风险集上的求和，如 $\\sum_{j \\in R(t_k)} \\exp(\\beta x_j)$、$\\sum_{j \\in R(t_k)} x_j \\exp(\\beta x_j)$ 等，可以通过逆向累积和高效计算。让我们看看。按 $Y_i$ 升序对数据排序。设排序后的索引为 $p_1, ..., p_n$。在时间 $Y_{p_k}$ 的风险集是 $\\{p_k, p_{k+1}, ..., p_n\\}$。所以风险集上的求和是逆向累积和。这是高效的。\n            `w_j = exp(beta * x_j)`。计算 `S0 = sum(w_j for j in R(t))`，`S1 = sum(x_j * w_j for j in R(t))`，`S2 = sum(x_j^2 * w_j for j in R(t))`。\n            得分是事件上的总和：`Sum_{i: delta_i=1} (x_i - S1(Y_i) / S0(Y_i))`。\n            信息是事件上的总和：`Sum_{i: delta_i=1} (S2(Y_i)/S0(Y_i) - (S1(Y_i)/S0(Y_i))^2)`。\n            这看起来很可靠。\n        -   AFT模型拟合：对数似然涉及 `scipy.stats.norm.logpdf` 和 `scipy.stats.norm.logsf`。`scipy`是允许的。`scipy.stats.norm`是其中的一部分。`logsf(x) = log(1-cdf(x))`。这正是我所需要的。\n        -   Breslow估计量：得到 $\\widehat{\\beta}_{\\text{Cox}}$ 后，我需要计算 $\\widehat{H}_0(t)$。这也最好在排序后的数据上完成。\n            -   设唯一的事件时间为 $t_{(1)}  t_{(2)}  ...  t_{(D)}$。\n            -   设 $d_k$ 是在 $t_{(k)}$ 处的事件数。\n            -   设 $R_k$ 是在 $t_{(k)}$ 之前的风险集。\n            -   $\\widehat{H}_0(t)$ 在 $t_{(k)}$ 处的跳跃是 $\\frac{d_k}{\\sum_{j \\in R_k} \\exp(\\widehat{\\beta}_{\\text{Cox}} x_j)}$。\n            -   同样，这可以通过对排序数据使用逆向累积和来高效计算。\n        -   `solve`函数的一般结构：\n            -   遍历每个测试用例。\n            -   在循环内部：\n                -   设置随机种子。\n                -   生成数据（步骤1）。\n                -   拟合Cox模型（步骤2）。\n                -   拟合AFT模型（步骤3）。\n                -   计算真实RMST（步骤4）。\n                -   计算预测的RMST和误差（步骤5）。\n                -   比较误差并存储布尔结果（步骤6）。\n            -   打印结果列表。\n该问题在科学上和数学上是合理的，描述了生存分析中的一个标准模拟研究。所有术语都有明确的定义，并且程序是按算法指定的。测试用例中提供的参数对于此类研究是合理的。因此，该问题被认为是有效的。\n\n### 基于原则的解决方案设计\n\n解决方案通过为每个测试用例实现问题陈述中描述的六步流程来展开。\n\n1.  **数据生成**：一个函数将从对数正态加速失效时间 (AFT) 模型模拟右删失生存数据。对于 $n$ 个个体中的每一个，它生成一个二元协变量 $x_i$，一个真实事件时间 $T_i = \\exp(\\mu + \\beta x_i + \\sigma Z_i)$（其中 $Z_i \\sim \\mathcal{N}(0,1)$），以及一个来自速率为 $\\lambda_c$ 的指数分布的删失时间 $C_i$。个体 $i$ 的观测数据是随访时间 $Y_i = \\min(T_i, C_i)$ 和事件指示符 $\\delta_i = \\mathbb{I}(T_i \\leq C_i)$。为确保可复现性，为每个测试用例提供了参数 $(n, p, \\mu, \\beta, \\sigma, \\lambda_c)$ 和一个随机种子。\n\n2.  **Cox模型拟合**：\n    -   **参数估计**：通过最大化偏对数似然来估计Cox比例风险 (PH) 模型的系数 $\\beta_{\\mathrm{Cox}}$。这是一个非线性优化问题，此处使用 `scipy.optimize.minimize` 提供的 BFGS 算法解决。目标函数（负偏对数似然）是根据公式 $\\ell(\\beta) = \\sum_{i: \\delta_i=1} [\\beta x_i - \\log(\\sum_{j \\in R(Y_i)} \\exp(\\beta x_j))]$ 构建的，其中 $R(Y_i)$ 是在时间 $Y_i$ 处于风险中的个体集合。为了高效地计算风险集总和，首先按观测时间 $Y_i$ 对数据进行排序，并使用逆向累积和。\n    -   **基线风险估计**：使用 Breslow 估计量来估计累积基线风险 $H_0(t)$。这是一个在每个观测到的事件时间 $t_k$ 增加的阶梯函数。在 $t_k$ 处的跳跃大小是在 $t_k$ 发生的事件数除以风险得分的总和 $\\sum_{j \\in R(t_k)} \\exp(\\widehat{\\beta}_{\\mathrm{Cox}}x_j)$。\n    -   **生存预测**：估计的生存函数则为 $\\widehat{S}_{\\mathrm{Cox}}(t|x) = \\exp(-\\widehat{H}_0(t)\\exp(\\widehat{\\beta}_{\\mathrm{Cox}}x))$。\n\n3.  **AFT模型拟合**：\n    -   **参数估计**：通过最大化右删失数据的全对数似然来估计对数正态AFT模型参数 $(\\mu, \\beta, \\sigma)$。对数似然函数为 $\\ell(\\mu, \\beta, \\sigma) = \\sum_i [\\delta_i \\log f(Y_i|x_i) + (1-\\delta_i) \\log S(Y_i|x_i)]$，其中 $f$ 和 $S$ 是对数正态分布的PDF和生存函数。通过最小化负对数似然来找到参数，同样使用BFGS算法。为确保 $\\sigma > 0$ 的约束，优化是在 $\\log(\\sigma)$上进行的。\n    -   **生存预测**：利用估计的参数 $(\\widehat{\\mu}, \\widehat{\\beta}, \\widehat{\\sigma})$，预测的生存函数为 $\\widehat{S}_{\\mathrm{AFT}}(t|x) = \\Phi\\left(-\\frac{\\log t - (\\widehat{\\mu} + \\widehat{\\beta}x)}{\\widehat{\\sigma}}\\right)$，其中 $\\Phi$ 是标准正态CDF。\n\n4.  **真实量**：由于数据生成过程是已知的，真实生存函数 $S_{\\mathrm{true}}(t|x)$ 就是具有真实参数 $(\\mu, \\beta, \\sigma)$ 的对数正态生存函数。真实限制性平均生存时间 (RMST) 是此函数从 $0$ 到指定时间范围 $\\tau$ 的积分。\n\n5.  **RMST计算与误差评估**：所有RMST值（真实的、Cox预测的、AFT预测的）都是通过在从 $t=0$到$t=\\tau$ 的区间上对相应的生存函数进行数值积分来计算的。为此，在一个精细的点网格上应用梯形法则 (`numpy.trapz`)。然后，对于每个模型 $M \\in \\{\\mathrm{Cox}, \\mathrm{AFT}\\}$，通过在两个协变量组（$x=0$ 和 $x=1$）上平均预测与真实RMST之间的绝对差异，计算平均绝对校准误差 $\\overline{E}^M(\\tau)$。\n\n6.  **模型比较**：最后，如果AFT模型的平均绝对误差 $\\overline{E}^{\\mathrm{AFT}}(\\tau)$ 小于Cox模型的误差 $\\overline{E}^{\\mathrm{Cox}}(\\tau)$，则判定AFT模型具有更好的校准效果。此比较为每个测试用例产生一个布尔结果。由于数据是从AFT模型生成的，预计AFT模型通常会表现更好，这为实现的正确性提供了概念性检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation study and print the results.\n    \"\"\"\n\n    def _fit_cox_model(Y, delta, x):\n        \"\"\"\n        Fits a Cox PH model for a single binary covariate using partial likelihood.\n        Implements Breslow's method for handling event times.\n        Returns the coefficient and a function for the Breslow baseline cumulative hazard.\n        \"\"\"\n        sort_idx = np.argsort(Y)\n        Y_sorted = Y[sort_idx]\n        delta_sorted = delta[sort_idx]\n        x_sorted = x[sort_idx]\n\n        def neg_log_partial_likelihood(beta, Y_s, delta_s, x_s):\n            beta = beta[0]\n            risk_scores = np.exp(beta * x_s)\n            risk_set_sums = np.cumsum(risk_scores[::-1])[::-1]\n            \n            # Use a small epsilon for numerical stability\n            log_risk_set_sums = np.log(risk_set_sums + 1e-30)\n            \n            event_indices = (delta_s == 1)\n            linear_term_at_events = beta * x_s[event_indices]\n            log_risk_set_sums_at_events = log_risk_set_sums[event_indices]\n            \n            log_likelihood = np.sum(linear_term_at_events - log_risk_set_sums_at_events)\n            return -log_likelihood\n\n        res = minimize(\n            neg_log_partial_likelihood,\n            x0=np.array([0.0]),\n            args=(Y_sorted, delta_sorted, x_sorted),\n            method='BFGS'\n        )\n        beta_cox = res.x[0]\n\n        risk_scores_est = np.exp(beta_cox * x_sorted)\n        risk_set_sums_est = np.cumsum(risk_scores_est[::-1])[::-1]\n        \n        event_mask = (delta_sorted == 1)\n        unique_event_times, event_time_indices = np.unique(Y_sorted[event_mask], return_inverse=True)\n        num_events_at_time = np.bincount(event_time_indices)\n        \n        y_event_indices = np.searchsorted(Y_sorted, unique_event_times)\n        risk_set_sum_at_event_time = risk_set_sums_est[y_event_indices]\n        \n        hazard_jumps = num_events_at_time / (risk_set_sum_at_event_time + 1e-30)\n        cum_hazard_jumps = np.cumsum(hazard_jumps)\n\n        def breslow_estimator(t_grid):\n            H0_t = np.zeros_like(t_grid, dtype=float)\n            indices = np.searchsorted(unique_event_times, t_grid, side='right')\n            valid_indices = (indices > 0)\n            H0_t[valid_indices] = cum_hazard_jumps[indices[valid_indices] - 1]\n            return H0_t\n            \n        return beta_cox, breslow_estimator\n\n    def _fit_aft_model(Y, delta, x):\n        \"\"\"\n        Fits a log-normal AFT model using maximum likelihood for right-censored data.\n        \"\"\"\n        log_Y = np.log(Y)\n        initial_params = np.array([1.0, 0.0, 0.0])\n        is_event = (delta == 1)\n        if np.sum(is_event) > 2:\n            x_event = x[is_event]\n            if np.any(x_event != x_event[0]):\n                log_Y_event = log_Y[is_event]\n                X = np.vstack([np.ones(len(x_event)), x_event]).T\n                try:\n                    params, _, _, _ = np.linalg.lstsq(X, log_Y_event, rcond=None)\n                    mu_init, beta_init = params\n                    residuals = log_Y_event - X @ params\n                    sigma_init = np.std(residuals)\n                    if sigma_init > 1e-4:\n                        initial_params = np.array([mu_init, beta_init, np.log(sigma_init)])\n                except np.linalg.LinAlgError:\n                    pass\n\n        def neg_log_likelihood(params, log_Y_l, delta_l, x_l):\n            mu, beta, log_sigma = params\n            sigma = np.exp(log_sigma)\n            if sigma  1e-6: return np.inf\n\n            z = (log_Y_l - mu - beta * x_l) / sigma\n            \n            events_mask = (delta_l == 1)\n            loglik = np.sum(norm.logpdf(z[events_mask]) - log_sigma - log_Y_l[events_mask])\n            loglik += np.sum(norm.logsf(z[~events_mask]))\n            \n            return -loglik if np.isfinite(loglik) else np.inf\n\n        res = minimize(\n            neg_log_likelihood,\n            initial_params,\n            args=(log_Y, delta, x),\n            method='BFGS'\n        )\n        mu_aft, beta_aft, log_sigma_aft = res.x\n        sigma_aft = np.exp(log_sigma_aft)\n        return mu_aft, beta_aft, sigma_aft\n\n    def _run_simulation_case(n, p, mu, beta, sigma, lambda_c, tau, seed):\n        \"\"\"\n        Runs the full pipeline for one test case.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        x = rng.binomial(1, p, size=n)\n        Z = rng.standard_normal(size=n)\n        T = np.exp(mu + beta * x + sigma * Z)\n        if lambda_c > 0:\n            C = rng.exponential(scale=1 / lambda_c, size=n)\n        else:\n            C = np.full(n, np.inf)\n        Y = np.minimum(T, C)\n        delta = (T = C).astype(int)\n\n        t_grid = np.linspace(0, tau, 2001)\n\n        beta_cox, H0_func = _fit_cox_model(Y, delta, x)\n        H0_on_grid = H0_func(t_grid)\n        S_cox_0 = np.exp(-H0_on_grid)\n        S_cox_1 = np.exp(-H0_on_grid * np.exp(beta_cox))\n        rmst_cox_0 = np.trapz(S_cox_0, t_grid)\n        rmst_cox_1 = np.trapz(S_cox_1, t_grid)\n\n        mu_aft, beta_aft, sigma_aft = _fit_aft_model(Y, delta, x)\n        with np.errstate(divide='ignore'):\n            log_t_grid = np.log(t_grid)\n        \n        S_aft_0 = norm.sf((log_t_grid - mu_aft) / sigma_aft)\n        S_aft_1 = norm.sf((log_t_grid - (mu_aft + beta_aft)) / sigma_aft)\n        S_aft_0[0] = 1.0\n        S_aft_1[0] = 1.0\n        rmst_aft_0 = np.trapz(S_aft_0, t_grid)\n        rmst_aft_1 = np.trapz(S_aft_1, t_grid)\n\n        S_true_0 = norm.sf((log_t_grid - mu) / sigma)\n        S_true_1 = norm.sf((log_t_grid - (mu + beta)) / sigma)\n        S_true_0[0] = 1.0\n        S_true_1[0] = 1.0\n        rmst_true_0 = np.trapz(S_true_0, t_grid)\n        rmst_true_1 = np.trapz(S_true_1, t_grid)\n\n        E_cox_0 = np.abs(rmst_cox_0 - rmst_true_0)\n        E_cox_1 = np.abs(rmst_cox_1 - rmst_true_1)\n        E_bar_cox = (E_cox_0 + E_cox_1) / 2.0\n\n        E_aft_0 = np.abs(rmst_aft_0 - rmst_true_0)\n        E_aft_1 = np.abs(rmst_aft_1 - rmst_true_1)\n        E_bar_aft = (E_aft_0 + E_aft_1) / 2.0\n\n        return E_bar_aft  E_bar_cox\n\n    test_cases = [\n        (1000, 0.5, 2.0, 0.7, 0.6, 0.05, 10.0, 1),\n        (1000, 0.5, 2.0, 1.0, 0.9, 0.2, 8.0, 2),\n        (500, 0.2, 1.5, 0.8, 0.5, 0.1, 6.0, 3),\n        (400, 0.5, 1.0, 1.2, 1.0, 0.3, 5.0, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _run_simulation_case(*case)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}