{
        "hands_on_practices": [
            {
                "introduction": "GMRES 算法的威力在于其巧妙地将一个庞大而复杂的线性系统问题，转化为一系列易于处理的小型最小二乘问题。第一个练习 [@problem_id:3542064] 将带您直击这一核心机制。您将通过直接求解和使用数值上更稳定的 Givens 旋转进行 QR 分解这两种方法，来手动解决一个两步的 GMRES 最小化问题，并验证它们能够得到相同的结果，从而巩固对 GMRES 基本计算核心的理解。",
                "problem": "考虑将重启参数为 $m=2$ 的广义最小残差（GMRES）方法应用于线性系统 $A x = b$。经过两步 Arnoldi 迭代，该方法构建了一个标准正交基 $V_{3}$ 和一个 $(m+1)\\times m$ 的上海森堡矩阵 $\\underline{H}_{2} \\in \\mathbb{R}^{3 \\times 2}$，使得残差通过求解最小二乘问题 $\\min_{y \\in \\mathbb{R}^{2}} \\| \\beta e_{1} - \\underline{H}_{2} y \\|_{2}$ 得以最小化，其中 $\\beta = \\|r_{0}\\|_{2}$ 且 $e_{1} = (1,0,0)^{\\top} \\in \\mathbb{R}^{3}$。取\n$$\n\\underline{H}_{2} \\;=\\; \\begin{pmatrix}\n3  3 \\\\\n4  4 \\\\\n0  7\n\\end{pmatrix},\n\\qquad\n\\beta \\;=\\; 10,\n\\qquad\ne_{1} \\;=\\; \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}.\n$$\n你的任务是：\n- 通过显式求解这个两步最小二乘问题 $\\min_{y \\in \\mathbb{R}^{2}} \\| \\beta e_{1} - \\underline{H}_{2} y \\|_{2}$ 并计算所得残差的范数，来计算最小残差范数。\n- 独立地，对 $\\underline{H}_{2}$ 应用两次连续的 Givens 旋转，将其转换为上三角形式，并将相同的旋转应用于右侧向量 $\\beta e_{1}$。在两次旋转后，确定旋转后的右侧向量最后一个分量的大小，并验证它等于从最小二乘解中获得的残差范数。\n\n将残差范数报告为单个实数。如果你选择对中间量进行近似，请确保最终报告的残差范数是精确的；无需四舍五入。",
                "solution": "问题陈述已经过验证，并被确定为数值线性代数领域中一个适定且有科学依据的问题。所有必要的数据都已提供，任务也已明确定义。\n\n问题要求计算一个两步广义最小残差（GMRES）方法的最小残差范数。最小化问题由下式给出：\n$$\n\\min_{y \\in \\mathbb{R}^{2}} \\| \\beta e_{1} - \\underline{H}_{2} y \\|_{2}\n$$\n其中 $\\mathbb{R}$ 是实数集，给定的量是：\n$$\n\\underline{H}_{2} = \\begin{pmatrix} 3  3 \\\\ 4  4 \\\\ 0  7 \\end{pmatrix}, \\quad \\beta = 10, \\quad e_{1} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n最小二乘问题右侧的向量是 $\\beta e_{1} = 10 \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 10 \\\\ 0 \\\\ 0 \\end{pmatrix}$。我们将此向量表示为 $g$。\n\n我们将按要求使用两种方法计算残差范数。\n\n### 方法一：通过正规方程组显式求解\n\n最小化欧几里得范数 $\\| g - \\underline{H}_{2} y \\|_{2}$ 的向量 $y \\in \\mathbb{R}^{2}$ 是正规方程组的解：\n$$\n(\\underline{H}_{2}^{\\top} \\underline{H}_{2}) y = \\underline{H}_{2}^{\\top} g\n$$\n首先，我们计算矩阵 $\\underline{H}_{2}^{\\top} \\underline{H}_{2}$：\n$$\n\\underline{H}_{2}^{\\top} \\underline{H}_{2} = \\begin{pmatrix} 3  4  0 \\\\ 3  4  7 \\end{pmatrix} \\begin{pmatrix} 3  3 \\\\ 4  4 \\\\ 0  7 \\end{pmatrix} = \\begin{pmatrix} 3 \\cdot 3 + 4 \\cdot 4 + 0 \\cdot 0  3 \\cdot 3 + 4 \\cdot 4 + 0 \\cdot 7 \\\\ 3 \\cdot 3 + 4 \\cdot 4 + 7 \\cdot 0  3 \\cdot 3 + 4 \\cdot 4 + 7 \\cdot 7 \\end{pmatrix}\n$$\n$$\n\\underline{H}_{2}^{\\top} \\underline{H}_{2} = \\begin{pmatrix} 9 + 16  9 + 16 \\\\ 9 + 16  9 + 16 + 49 \\end{pmatrix} = \\begin{pmatrix} 25  25 \\\\ 25  74 \\end{pmatrix}\n$$\n接下来，我们计算向量 $\\underline{H}_{2}^{\\top} g$：\n$$\n\\underline{H}_{2}^{\\top} g = \\begin{pmatrix} 3  4  0 \\\\ 3  4  7 \\end{pmatrix} \\begin{pmatrix} 10 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 3 \\cdot 10 + 4 \\cdot 0 + 0 \\cdot 0 \\\\ 3 \\cdot 10 + 4 \\cdot 0 + 7 \\cdot 0 \\end{pmatrix} = \\begin{pmatrix} 30 \\\\ 30 \\end{pmatrix}\n$$\n现在我们求解关于 $y = \\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix}$ 的 $2 \\times 2$ 线性系统：\n$$\n\\begin{pmatrix} 25  25 \\\\ 25  74 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix} = \\begin{pmatrix} 30 \\\\ 30 \\end{pmatrix}\n$$\n这对应于以下方程组：\n$25 y_1 + 25 y_2 = 30$\n$25 y_1 + 74 y_2 = 30$\n用第二个方程减去第一个方程得到：\n$$\n(74 - 25) y_2 = 30 - 30 \\implies 49 y_2 = 0 \\implies y_2 = 0\n$$\n将 $y_2 = 0$ 代入第一个方程：\n$$\n25 y_1 + 25(0) = 30 \\implies 25 y_1 = 30 \\implies y_1 = \\frac{30}{25} = \\frac{6}{5}\n$$\n最优解是 $y^* = \\begin{pmatrix} 6/5 \\\\ 0 \\end{pmatrix}$。\n残差向量是 $r = g - \\underline{H}_{2} y^*$：\n$$\nr = \\begin{pmatrix} 10 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 3  3 \\\\ 4  4 \\\\ 0  7 \\end{pmatrix} \\begin{pmatrix} 6/5 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 10 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 3 \\cdot (6/5) \\\\ 4 \\cdot (6/5) \\\\ 0 \\cdot (6/5) \\end{pmatrix} = \\begin{pmatrix} 10 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 18/5 \\\\ 24/5 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 50/5 - 18/5 \\\\ -24/5 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 32/5 \\\\ -24/5 \\\\ 0 \\end{pmatrix}\n$$\n最小残差范数是 $\\|r\\|_{2}$：\n$$\n\\|r\\|_{2} = \\sqrt{\\left(\\frac{32}{5}\\right)^2 + \\left(-\\frac{24}{5}\\right)^2 + 0^2} = \\frac{1}{5}\\sqrt{32^2 + 24^2} = \\frac{1}{5}\\sqrt{1024 + 576} = \\frac{1}{5}\\sqrt{1600} = \\frac{40}{5} = 8\n$$\n\n### 方法二：使用 Givens 旋转进行 QR 分解\n\n最小二乘问题可以通过应用一系列正交变换（Givens 旋转）来求解，以将 $\\underline{H}_{2}$ 转换为上三角形式。这等价于计算 $\\underline{H}_{2}$ 的 QR 分解。设 $Q$ 是这些正交矩阵的乘积。在此类变换下范数保持不变：\n$$\n\\| g - \\underline{H}_{2} y \\|_{2} = \\| Q(g - \\underline{H}_{2} y) \\|_{2} = \\| Qg - Q\\underline{H}_{2} y \\|_{2}\n$$\n我们将此过程应用于增广系统 $[\\underline{H}_{2} | g]$。\n$$\n\\left[ \\underline{H}_{2} | g \\right] = \\left( \\begin{array}{cc|c} 3  3  10 \\\\ 4  4  0 \\\\ 0  7  0 \\end{array} \\right)\n$$\n**第一次 Givens 旋转：**\n我们的目标是将位置 $(2,1)$ 处的元素 $h_{21} = 4$ 置零。我们在 $(1,2)$-平面上使用一个旋转 $G_1$。参数 $c_1 = \\cos(\\theta_1)$ 和 $s_1 = \\sin(\\theta_1)$ 由第一列向量的元素 $\\begin{pmatrix} 3 \\\\ 4 \\end{pmatrix}$ 确定。\n$$\nr_1 = \\sqrt{3^2 + 4^2} = \\sqrt{25} = 5\n$$\n$$\nc_1 = \\frac{3}{r_1} = \\frac{3}{5}, \\quad s_1 = \\frac{4}{r_1} = \\frac{4}{5}\n$$\n旋转矩阵是 $G_1 = \\begin{pmatrix} c_1  s_1  0 \\\\ -s_1  c_1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 3/5  4/5  0 \\\\ -4/5  3/5  0 \\\\ 0  0  1 \\end{pmatrix}$。\n将 $G_1$ 应用于增广系统：\n$$\nG_1 \\left[ \\underline{H}_{2} | g \\right] = \\begin{pmatrix} 3/5  4/5  0 \\\\ -4/5  3/5  0 \\\\ 0  0  1 \\end{pmatrix} \\left( \\begin{array}{cc|c} 3  3  10 \\\\ 4  4  0 \\\\ 0  7  0 \\end{array} \\right) = \\left( \\begin{array}{cc|c} 5  5  6 \\\\ 0  0  -8 \\\\ 0  7  0 \\end{array} \\right)\n$$\n**第二次 Givens 旋转：**\n接下来，我们处理第二列的次对角线元素，该元素现在位于位置 $(3,2)$，值为 $7$。我们在 $(2,3)$-平面上应用一个旋转 $G_2$，利用位置 $(2,2)$ 处的元素来将该元素置零。要旋转的向量是第二列的 $\\begin{pmatrix} 0 \\\\ 7 \\end{pmatrix}$。\n$$\nr_2 = \\sqrt{0^2 + 7^2} = 7\n$$\n$$\nc_2 = \\frac{0}{r_2} = 0, \\quad s_2 = \\frac{7}{r_2} = 1\n$$\n旋转矩阵是 $G_2 = \\begin{pmatrix} 1  0  0 \\\\ 0  c_2  s_2 \\\\ 0  -s_2  c_2 \\end{pmatrix} = \\begin{pmatrix} 1  0  0 \\\\ 0  0  1 \\\\ 0  -1  0 \\end{pmatrix}$。\n将 $G_2$ 应用于第一步的结果：\n$$\nG_2 (G_1 \\left[ \\underline{H}_{2} | g \\right]) = \\begin{pmatrix} 1  0  0 \\\\ 0  0  1 \\\\ 0  -1  0 \\end{pmatrix} \\left( \\begin{array}{cc|c} 5  5  6 \\\\ 0  0  -8 \\\\ 0  7  0 \\end{array} \\right) = \\left( \\begin{array}{cc|c} 5  5  6 \\\\ 0  7  0 \\\\ 0  0  8 \\end{array} \\right)\n$$\n原始问题现在被转换为最小化：\n$$\n\\left\\| \\begin{pmatrix} 6 \\\\ 0 \\\\ 8 \\end{pmatrix} - \\begin{pmatrix} 5  5 \\\\ 0  7 \\\\ 0  0 \\end{pmatrix} y \\right\\|_{2}\n$$\n范数的平方是：\n$$\n\\left\\| \\begin{pmatrix} 6 - (5y_1 + 5y_2) \\\\ 0 - 7y_2 \\\\ 8 - 0 \\end{pmatrix} \\right\\|_{2}^{2} = (6 - 5y_1 - 5y_2)^2 + (-7y_2)^2 + 8^2\n$$\n为了最小化此表达式，我们选择 $y_1$ 和 $y_2$ 使前两项为零。这可以通过求解上三角系统来实现：\n$$\n\\begin{pmatrix} 5  5 \\\\ 0  7 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix} = \\begin{pmatrix} 6 \\\\ 0 \\end{pmatrix}\n$$\n这得出 $y_2=0$ 和 $y_1=6/5$，这与之前找到的 $y^*$ 相同。\n对于这个 $y^*$ 的选择，残差范数就是剩余项的平方根：\n$$\n\\text{最小残差范数} = \\sqrt{8^2} = 8\n$$\n这个值 $8$，是旋转后的右侧向量 $Qg = \\begin{pmatrix} 6 \\\\ 0 \\\\ 8 \\end{pmatrix}$ 的最后一个分量的大小。\n\n### 结论\n两种方法都得出了相同的最小残差范数结果。\n方法一得到的残差范数为 $8$。\n方法二表明，残差范数是变换后的右侧向量最后一个分量的大小，即 $|8| = 8$。\n所求的残差范数为 $8$。",
                "answer": "$$\\boxed{8}$$",
                "id": "3542064"
            },
            {
                "introduction": "虽然重启策略使得 GMRES 能够应用于大规模问题，但它也伴随着代价：丢弃已构建的 Krylov 子空间可能导致收敛缓慢，甚至完全停滞。本练习 [@problem_id:3593977] 提供了一个极具说服力的案例研究，您将亲手构建并编码一个例子，其中使用小的固定重启参数 $m$ 的 GMRES($m$) 算法完全无法取得进展。通过分析这种失败背后的几何原理，您将深刻理解重启策略的局限性以及预处理算子结构的重要性。",
                "problem": "您需要构造一个严格的例子，在该例子中，广义最小残差方法 (GMRES) 在重启动下表现出根本不同的行为。该任务涉及数值线性代数中的预处理 GMRES 算法。设预处理为左预处理，因此变换后的系统为 $M^{-1} A x = M^{-1} b$，且算法所最小化的残差为 $\\| M^{-1} (b - A x) \\|_{2}$。构造和分析必须从关于 Krylov 子空间和残差多项式的基本原理出发。\n\n起始基本定义和事实：\n- 广义最小残差方法 (GMRES) 构造迭代解 $x_k$，使得预处理后的残差满足 $r_k = p_k(M^{-1} A) r_0$，其中 $r_0 = b - A x_0$，$p_k$ 是一个次数至多为 $k$ 且满足 $p_k(0) = 1$ 的多项式，并且预处理后残差的欧几里得范数在所有此类多项式中被最小化。\n- 由矩阵 $B$ 和向量 $v$ 生成的 Krylov 子空间为 $\\mathcal{K}_k(B, v) = \\operatorname{span}\\{v, B v, B^2 v, \\dots, B^{k-1} v\\}$。\n- 重启动的 GMRES($m$) 在连续的循环中应用一个 $m$ 次残差多项式，因此在 $j$ 次循环后，残差为 $r_{jm} = \\left(\\prod_{i=1}^j p_m^{(i)}(M^{-1} A)\\right) r_0$，其中每个 $p_m^{(i)}$ 是一个满足 $p_m^{(i)}(0) = 1$ 的 $m$ 次多项式，并在该循环中生成的相应 Krylov 子空间上最小化残差。\n\n问题：\n1. 构造一个具体的矩阵 $A \\in \\mathbb{R}^{n \\times n}$、一个左预处理器 $M \\in \\mathbb{R}^{n \\times n}$、一个右端项 $b \\in \\mathbb{R}^n$、一个初始猜测 $x_0 \\in \\mathbb{R}^n$ 和一个重启动长度 $m$，使得重启动的 GMRES($m$) 停滞（在多次循环中残差范数没有减小），而未重启动的 GMRES 在至多 $n$ 次迭代内收敛到解。使用残差多项式表征以及关于 Krylov 子空间和正交性的几何论证来证明此行为。\n2. 对于一个科学上合理且可测试的场景，考虑以下使用维度 $n = 4$ 和左预处理的显式测试套件：\n   - 定义 $A$ 为 $\\mathbb{R}^{4 \\times 4}$ 中的循环下移位排列矩阵，即 $A e_1 = e_2$，$A e_2 = e_3$，$A e_3 = e_4$，$A e_4 = e_1$，其中 $(e_i)_{i=1}^4$ 是 $\\mathbb{R}^4$ 中的标准基向量。\n   - 定义左预处理器 $M = \\operatorname{diag}(1, 2, 3, 4)$。\n   - 定义 $b = e_1$ 和 $x_0 = 0$。\n   - 使用重启动长度 $m = 1$ 来演示停滞现象，并使用未重启动的 GMRES 来演示收敛性。\n   - 同时测试 $m = 2$ 和 $m = 4$ 以探究中间行为和边界行为，并测试一个修改后的右端项 $b = e_1 + e_2$ 以打破导致停滞的正交性条件。\n3. 您的程序必须在变换后的系统 $M^{-1} A x = M^{-1} b$ 上实现左预处理 GMRES，并测量原始残差范数 $\\| b - A x \\|_{2}$ 用于报告。它必须为指定的测试套件计算以下可量化的输出：\n   - 测试 1（停滞，重启动 GMRES($m=1$)）：在使用 $m = 1$ 进行 $8$ 次重启动循环后，比率 $\\rho_1 = \\| r_{\\text{final}} \\|_{2} / \\| r_{\\text{initial}} \\|_{2}$，其中 $r_{\\text{initial}} = b - A x_0$，$r_{\\text{final}}$ 是最终残差。这是一个浮点数。\n   - 测试 2（未重启动 GMRES 收敛）：在不重启动的情况下进行至多 $n$ 次迭代后，最终残差范数 $\\rho_2 = \\| r_{\\text{final}} \\|_{2}$。这是一个浮点数。\n   - 测试 3（$m = 2$ 时的进展）：一个布尔值，指示使用 $m = 2$ 的重启动 GMRES 在 $4$ 次重启动循环后是否减小了残差范数，即最终范数是否严格小于初始范数。这是一个布尔值。\n   - 测试 4（边界，$m = n$）：对于使用 $m = 4$ 的重启动 GMRES，在单次循环后，最终残差范数 $\\rho_4 = \\| r_{\\text{final}} \\|_{2}$。这是一个浮点数。\n   - 测试 5（通过更改 $b$ 打破停滞）：一个布尔值，指示对于修改后的右端项 $b = e_1 + e_2$，使用 $m = 1$ 的重启动 GMRES 在 $8$ 次循环后是否减小了残差范数。这是一个布尔值。\n4. 角度单位和物理单位不适用于这个纯数学问题。所有范数均为 $\\mathbb{R}^n$ 中的欧几里得范数。矩阵和向量的元素是无单位的实数。\n5. 最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”），其中 result1 和 result2 是浮点数，result3 和 result5 是布尔值，result4 是浮点数。\n\n您的解答必须使用残差多项式表征 $r_k = p_k(M^{-1} A) r_0$（其中 $p_k(0) = 1$）以及 Krylov 子空间的几何性质来证明您的构造。代码必须是完整的、可“直接运行”的，并为给定的测试套件产生指定的输出。",
                "solution": "该问题要求构造一个数值线性代数中的例子，其中重启动的广义最小残差方法 (GMRES) 停滞，而未重启动的 GMRES 收敛。分析必须基于 Krylov 子空间和残差多项式的基本原理。\n\nGMRES 算法的核心在于从仿射子空间 $x_0 + \\mathcal{K}_k(B, \\tilde{r}_0)$ 中找到线性系统 $Bx=c$ 的近似解 $x_k$，其中 $x_0$ 是初始猜测，$\\mathcal{K}_k(B, \\tilde{r}_0) = \\operatorname{span}\\{\\tilde{r}_0, B\\tilde{r}_0, \\dots, B^{k-1}\\tilde{r}_0\\}$ 是由矩阵 $B$ 和初始残差 $\\tilde{r}_0 = c - Bx_0$ 生成的 $k$ 阶 Krylov 子空间。选择迭代解 $x_k$ 使其残差 $\\tilde{r}_k = c - Bx_k$ 具有最小可能的欧几里得范数 $\\|\\tilde{r}_k\\|_2$。对于一个左预处理系统 $M^{-1}Ax = M^{-1}b$，我们设 $B = M^{-1}A$ 和 $c = M^{-1}b$。GMRES 随之最小化预处理后残差的范数 $\\| M^{-1}(b-Ax_k) \\|_2$。\n\nGMRES 的一个关键几何特性是，新的预处理残差 $\\tilde{r}_k = M^{-1}(b - Ax_k)$ 与子空间 $B \\mathcal{K}_k(B, \\tilde{r}_0)$ 正交，其中 $\\tilde{r}_0 = M^{-1}(b - Ax_0)$ 是初始预处理残差。重启动 GMRES($m$) 的停滞现象发生在算法从一个循环到下一个循环没有任何进展时。如果一个循环结束时的预处理残差向量 $\\tilde{r}_m$ 与该循环开始时的残差向量 $\\tilde{r}_0$ 成比例，并且范数的减小为零或可忽略不计，则会发生这种情况。如果 $\\tilde{r}_m=\\tilde{r}_0$，则出现完全没有进展（零减少）的情况。这在一个特定条件下发生：如果初始预处理残差 $\\tilde{r}_0$ 已经与用于残差更新的搜索空间 $B\\mathcal{K}_m(B, \\tilde{r}_0)$ 正交。在这种情况下，通过零更新满足最小化条件，导致 $\\tilde{r}_m = \\tilde{r}_0$。\n\n我们使用指定的参数构造这样一个例子。\n设 $n=4$。系统矩阵是循环下移位排列矩阵：\n$$A = \\begin{pmatrix} 0  0  0  1 \\\\ 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\n左预处理器是一个对角矩阵：\n$$M = \\operatorname{diag}(1, 2, 3, 4) = \\begin{pmatrix} 1  0  0  0 \\\\ 0  2  0  0 \\\\ 0  0  3  0 \\\\ 0  0  0  4 \\end{pmatrix}$$\n右端项向量为 $b = e_1 = (1, 0, 0, 0)^T$，初始猜测为 $x_0 = 0$。\n\n预处理后的矩阵是 $B = M^{-1}A$：\n$$B = \\begin{pmatrix} 1  0  0  0 \\\\ 0  1/2  0  0 \\\\ 0  0  1/3  0 \\\\ 0  0  0  1/4 \\end{pmatrix} \\begin{pmatrix} 0  0  0  1 \\\\ 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  1 \\\\ 1/2  0  0  0 \\\\ 0  1/3  0  0 \\\\ 0  0  1/4  0 \\end{pmatrix}$$\n初始残差为 $r_0 = b - Ax_0 = e_1$。初始预处理残差为 $\\tilde{r}_0 = M^{-1}r_0 = M^{-1}e_1 = e_1$。\n\n**1. 重启动 GMRES(m) 停滞分析 ($m=1, 2, 3$)**\n\n考虑重启动长度 $m  4$ 的 GMRES($m$)。第一个循环从 $\\tilde{r}_0=e_1$ 开始。Krylov 子空间为 $\\mathcal{K}_m(B, e_1)$。\n我们来计算基向量：\n$e_1$\n$B e_1 = (1/2)e_2$\n$B^2 e_1 = (1/6)e_3$\n$B^3 e_1 = (1/24)e_4$\nKrylov 子空间为 $\\mathcal{K}_m(B, e_1) = \\operatorname{span}\\{e_1, e_2, \\dots, e_m\\}$。\n新残差必须与之正交的子空间是 $B \\mathcal{K}_m(B, e_1) = \\operatorname{span}\\{B e_1, \\dots, B e_m\\} = \\operatorname{span}\\{e_2, e_3, \\dots, e_{m+1}\\}$。\n\n对于任何 $m  4$，子空间 $\\mathcal{K}_m(B, e_1)$ 和 $B\\mathcal{K}_m(B, e_1)$ 关于标准内积是正交的，因为它们由不相交的标准基向量集合张成。例如，对于 $m=1$，$\\mathcal{K}_1(B, e_1) = \\operatorname{span}\\{e_1\\}$ 和 $B\\mathcal{K}_1(B, e_1) = \\operatorname{span}\\{e_2\\}$，它们是正交的。\n初始预处理残差 $\\tilde{r}_0 = e_1$ 位于 $\\mathcal{K}_m(B, e_1)$ 中，因此与 $B\\mathcal{K}_m(B, e_1)$ 中的每个向量正交。\nGMRES 条件要求新残差 $\\tilde{r}_m$ 与 $B\\mathcal{K}_m(B, e_1)$ 正交。由于 $\\tilde{r}_0$ 已经满足此正交性条件，算法发现最佳选择是 $\\tilde{r}_m = \\tilde{r}_0$，这对应于零校正 $x_m = x_0$。残差范数不减小。这就是停滞。此推理适用于任何重启动循环，以及任何重启动长度 $m=1, 2, 3$。\n从残差多项式的角度来看，算法寻找一个次数至多为 $m$ 且满足 $p_m(0)=1$ 的多项式 $p_m(z)$，以最小化 $\\|\\tilde{r}_m\\|_2 = \\| p_m(B) \\tilde{r}_0 \\|_2$。该范数为 $\\| p_m(B) e_1 \\|_2$。因为向量 $e_1, Be_1, \\dots, B^m e_1$ 相互正交，对于 $p_m(z)=\\sum c_j z^j$，我们有 $\\| p_m(B) e_1 \\|_2^2 = \\sum_{j=0}^m c_j^2 \\| B^j e_1 \\|_2^2$。在 $c_0=p_m(0)=1$ 的条件下，当所有其他系数为零时，即 $p_m(z)=1$，达到最小值。因此，$\\tilde{r}_m = p_m(B)\\tilde{r}_0 = \\tilde{r}_0$。\n\n**2. 未重启动 GMRES 收敛性分析 ($m=4$)**\n\n对于未重启动的 GMRES，算法最多运行 $n=4$ 次迭代，构建子空间 $\\mathcal{K}_4(B, e_1) = \\operatorname{span}\\{e_1, (1/2)e_2, (1/6)e_3, (1/24)e_4\\} = \\operatorname{span}\\{e_1, e_2, e_3, e_4\\} = \\mathbb{R}^4$。由于 Krylov 子空间是整个解空间，GMRES 保证能找到使残差为零的精确校正 $z_4 = x_{exact} - x_0$。因此，未重启动的 GMRES（等同于 GMRES($4$) 的一个循环）收敛到精确解，最终的残差范数（包括预处理后和原始的）将为零（或达到机器精度）。\n\n**3. 打破停滞现象的分析 ($b = e_1+e_2$)**\n\n我们将右端项更改为 $b = e_1 + e_2$。初始残差为 $r_0 = e_1 + e_2$，预处理后的初始残差为 $\\tilde{r}_0 = M^{-1}(e_1 + e_2) = e_1 + (1/2)e_2$。\n现在考虑 GMRES($1$)。Krylov 子空间为 $\\mathcal{K}_1(B, \\tilde{r}_0) = \\operatorname{span}\\{e_1 + (1/2)e_2\\}$。\n用于残差更新的子空间是 $B\\mathcal{K}_1(B, \\tilde{r}_0) = \\operatorname{span}\\{B(e_1 + (1/2)e_2)\\}$。\n$B(e_1 + (1/2)e_2) = B e_1 + (1/2)B e_2 = (1/2)e_2 + (1/2)M^{-1}Ae_2 = (1/2)e_2 + (1/2)M^{-1}e_3 = (1/2)e_2 + (1/6)e_3$。\n通过内积检查关键的正交性条件：\n$$ \\tilde{r}_0^T (B \\tilde{r}_0) = (e_1 + (1/2)e_2)^T ((1/2)e_2 + (1/6)e_3) = (1/2)(1/2) = 1/4 \\neq 0 $$\n由于 $\\tilde{r}_0$ 与 $B\\mathcal{K}_1(B, \\tilde{r}_0)$ 不正交，GMRES 的更新将非零。算法会将 $\\tilde{r}_0$ 投影到 $B\\mathcal{K}_1(B, \\tilde{r}_0)$ 的正交补上，从而产生一个新的残差 $\\tilde{r}_1$，满足 $\\|\\tilde{r}_1\\|_2  \\|\\tilde{r}_0\\|_2$。因此，停滞现象被打破，GMRES($1$) 将在每个循环中取得进展。\n\n这完成了对指定测试案例中观察到的行为的理论证明。所构造的例子巧妙地分离出了导致重启动 GMRES 停滞的几何条件。",
                "answer": "```python\nimport numpy as np\nfrom scipy.sparse.linalg import gmres\n\ndef solve():\n    \"\"\"\n    Constructs and solves the test cases for GMRES stagnation and convergence.\n    \"\"\"\n    n = 4\n    # Define standard basis vectors\n    e1 = np.zeros(n)\n    e1[0] = 1.0\n    e2 = np.zeros(n)\n    e2[1] = 1.0\n\n    # Define the matrix A as the cyclic down-shift permutation matrix\n    A = np.roll(np.eye(n), 1, axis=0)\n\n    # Define the diagonal preconditioner M\n    M = np.diag(np.arange(1, n + 1).astype(float))\n    \n    # Define the initial guess\n    x0 = np.zeros(n)\n    \n    # Define the inverse of the preconditioner\n    M_inv = np.linalg.inv(M)\n    \n    # Pre-compute the transformed matrix for the left-preconditioned system\n    A_tilde = M_inv @ A\n\n    results = []\n\n    # --- Test 1: Stagnation with m=1 ---\n    # b = e1, m=1, 8 restart cycles\n    b1 = e1\n    r_initial_norm_1 = np.linalg.norm(b1 - A @ x0)\n    b_tilde_1 = M_inv @ b1\n    # For m=1 and 8 cycles, restart=1 and maxiter=8\n    x_final_1, _ = gmres(A_tilde, b_tilde_1, x0=x0, restart=1, maxiter=8, atol=1e-12)\n    r_final_1 = b1 - A @ x_final_1\n    rho1 = np.linalg.norm(r_final_1) / r_initial_norm_1\n    results.append(rho1)\n\n    # --- Test 2: Unrestarted GMRES convergence ---\n    # b = e1, unrestarted (m=n=4), max n iterations\n    # For unrestarted GMRES with n=4, restart=4 and maxiter=4\n    x_final_2, _ = gmres(A_tilde, b_tilde_1, x0=x0, restart=4, maxiter=4, atol=1e-12)\n    r_final_2 = b1 - A @ x_final_2\n    rho2 = np.linalg.norm(r_final_2)\n    results.append(rho2)\n\n    # --- Test 3: Progress for m=2 ---\n    # b = e1, m=2, 4 restart cycles. Check for any reduction in norm.\n    r_initial_norm_3 = np.linalg.norm(b1 - A @ x0)\n    # For m=2 and 4 cycles, restart=2 and maxiter=8\n    x_final_3, _ = gmres(A_tilde, b_tilde_1, x0=x0, restart=2, maxiter=8, atol=1e-12)\n    r_final_norm_3 = np.linalg.norm(b1 - A @ x_final_3)\n    progress_3 = r_final_norm_3  r_initial_norm_3\n    results.append(progress_3)\n\n    # --- Test 4: Boundary case m=n ---\n    # b = e1, m=4, 1 cycle. This is identical to unrestarted GMRES.\n    # For m=4 and 1 cycle, restart=4 and maxiter=4\n    x_final_4, _ = gmres(A_tilde, b_tilde_1, x0=x0, restart=4, maxiter=4, atol=1e-12)\n    r_final_4 = b1 - A @ x_final_4\n    rho4 = np.linalg.norm(r_final_4)\n    results.append(rho4)\n\n    # --- Test 5: Breaking stagnation by changing b ---\n    # b = e1+e2, m=1, 8 cycles. Check for any reduction in norm.\n    b5 = e1 + e2\n    r_initial_norm_5 = np.linalg.norm(b5 - A @ x0)\n    b_tilde_5 = M_inv @ b5\n    # For m=1 and 8 cycles, restart=1 and maxiter=8\n    x_final_5, _ = gmres(A_tilde, b_tilde_5, x0=x0, restart=1, maxiter=8, atol=1e-12)\n    r_final_norm_5 = np.linalg.norm(b5 - A @ x_final_5)\n    progress_5 = r_final_norm_5  r_initial_norm_5\n    results.append(progress_5)\n\n    # Format the final output string exactly as specified\n    formatted_results = []\n    for res in results:\n        if isinstance(res, bool):\n            formatted_results.append(str(res).lower())\n        else:\n            formatted_results.append(f\"{res:.15e}\") # Use scientific notation for precision\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```",
                "id": "3593977"
            },
            {
                "introduction": "如果固定的重启参数 $m$ 可能导致停滞，一个自然的问题是：我们能否动态地调整 $m$ 以提升算法性能？最后一个练习 [@problem_id:3542130] 正是探讨这一思想，指导您实现一个简单而有效的自适应策略。通过分析 Arnoldi 过程中产生的谱信息（即 Ritz 值），您将决定是否需要扩大 Krylov 子空间，这为您提供了一个如何构建更“智能”、更鲁棒的 GMRES 算法的实践范例。",
                "problem": "考虑广义最小残差（GMRES）方法及其重启动变体 GMRES($m$)，其中重启动参数为 $m$。GMRES 方法在 Krylov 子空间 $\\mathcal{K}_{k}(A,r_{0}) = \\operatorname{span}\\{r_{0}, A r_{0}, \\dots, A^{k-1} r_{0}\\}$ 上最小化残差，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个非奇异矩阵，$x_{0}$ 是初始猜测值，$r_{0} = b - A x_{0}$ 是初始残差。重启动的 GMRES($m$) 执行 $m$ 次内迭代来构建 Krylov 子空间，然后用新的残差重新启动，并丢弃先前的信息。Krylov 子空间通过 Arnoldi 过程 $A V_{m} = V_{m+1} \\bar{H}_{m}$ 构建，其中 $V_{m}$ 的列是标准正交的，$\\bar{H}_{m} \\in \\mathbb{R}^{(m+1) \\times m}$ 是上海森伯格（upper Hessenberg）矩阵，其主方阵部分 $H_{m} \\in \\mathbb{R}^{m \\times m}$ 定义了 $A$ 到 $\\mathcal{K}_{m}$ 上的一个投影。$H_{m}$ 的特征值被称为 Ritz 值，并作为矩阵 $A$ 特征值的近似值。\n\n在本问题中，您需要设计一个简单的动态准则，在一个周期结束时根据 Ritz 值的行为来调整重启动参数 $m$，从第一性原理出发论证该准则，并将其应用于一个示例问题，以展示其相比于固定 $m$ 值的改进效果。您的最终答案必须是一个实数值。\n\n使用的基本原理：\n- 在第 $k$ 步的 GMRES 残差是 $\\|p_{k}(A) r_{0}\\|_{2}$ 在所有满足 $p_k(0)=1$ 的 $k$ 次多项式 $p_k$ 上的最小值，该最小值通过由 Arnoldi 关系定义的正交投影实现。\n- Ritz 值是 $H_{m}$ 的特征值；对于对称矩阵 $A$，$H_{m}$ 是三对角的（Lanczos 过程），其特征值首先逼近 $A$ 的极端特征值。\n\n自适应准则说明：\n- 从 $m_{0} = 2$ 开始。\n- 在第一个 GMRES($m_{0}$) 周期结束时，计算 $H_{2}$ 的两个 Ritz 值 $\\{\\theta_{1}, \\theta_{2}\\}$。\n- 定义谱展布指标 $S(H_{2}) = \\theta_{\\max} - \\theta_{\\min}$。\n- 使用自适应规则：如果 $S(H_{2})  \\tau$，则设置 $m_{\\text{next}} = m_{0} + 1$；否则，保持 $m_{\\text{next}} = m_{0}$。在本问题中，取 $\\tau = 30$。\n\n示例问题：\n- 设 $A = \\operatorname{diag}(1, 10, 100) \\in \\mathbb{R}^{3 \\times 3}$，$x_{0} = 0$ 且 $b = (1, 1, 1)^{\\top}$，因此 $r_{0} = b$。\n- 执行一个 GMRES(2) 周期，以构建 Arnoldi 基 $\\{v_{1}, v_{2}\\}$ 和投影矩阵 $H_{2}$。\n- 计算 $H_{2}$ 的 Ritz 值，评估 $S(H_{2})$，并根据上述规则确定 $m_{\\text{next}}$。\n- 利用所列的核心定义和事实，解释为何所选的 $m_{\\text{next}}$ 在此示例问题上比固定的 $m=2$ 能改善收敛性。\n\n答案规格：\n- 将 $m_{\\text{next}}$ 作为您的最终答案报告。\n- 无需四舍五入。",
                "solution": "根据指定标准，所提供的问题被评估为有效。它在数值线性代数领域有科学依据，特别关注 GMRES 方法的收敛特性。该问题是适定的，具有一组明确的已知条件和一个确定的目标，从而可以计算出唯一解。语言客观且正式。所有必要组成部分，包括矩阵 $A$、初始残差 $r_0$、初始重启动参数 $m_0$ 以及自适应准则阈值 $\\tau$，均已明确提供。\n\n任务是通过将指定的自适应准则应用于一个示例问题来确定 GMRES 的下一个重启动参数 $m_{\\text{next}}$。这需要执行 GMRES($m_0$) 的第一个周期以计算必要的量。初始参数为 $m_0=2$。\n\n示例问题由矩阵 $A = \\operatorname{diag}(1, 10, 100) \\in \\mathbb{R}^{3 \\times 3}$、初始猜测值 $x_{0} = 0$ 和向量 $b = (1, 1, 1)^{\\top}$ 定义。初始残差为 $r_{0} = b - A x_{0} = (1, 1, 1)^{\\top}$。\n\n自适应准则依赖于 Arnoldi 过程生成的 Hessenberg 矩阵 $H_2$ 的特征值。对于给定的对称矩阵 $A$，Arnoldi 过程简化为 Lanczos 算法，得到的矩阵 $H_m$ 是对称三对角矩阵。我们将其元素记为 $H_m(j,j) = \\alpha_j$ 和 $H_m(j,j+1) = H_m(j+1,j) = \\beta_j$。\n\n我们现在执行 $m=2$ 步的 Arnoldi (Lanczos) 迭代来构建 $H_2$。\n\n**步骤 1：初始化**\n初始残差为 $r_0 = (1, 1, 1)^{\\top}$。\n初始残差的范数为 $\\beta = \\|r_0\\|_2 = \\sqrt{1^2 + 1^2 + 1^2} = \\sqrt{3}$。\n第一个标准正交基向量是 $v_1 = \\frac{r_0}{\\beta} = \\frac{1}{\\sqrt{3}}(1, 1, 1)^{\\top}$。\n\n**步骤 2：Arnoldi 过程的第一次迭代 ($j=1$)**\n计算向量 $w_1 = A v_1$：\n$$w_1 = \\operatorname{diag}(1, 10, 100) \\left( \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 10 \\\\ 100 \\end{pmatrix}$$\n计算 $H_2$ 的第一个对角线元素 $\\alpha_1 = h_{11}$：\n$$\\alpha_1 = v_1^{\\top} w_1 = \\left( \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1  1  1 \\end{pmatrix} \\right) \\left( \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 10 \\\\ 100 \\end{pmatrix} \\right) = \\frac{1}{3}(1 + 10 + 100) = \\frac{111}{3} = 37$$\n计算未归一化的下一个向量：\n$$\\hat{w}_1 = w_1 - \\alpha_1 v_1 = \\frac{1}{\\sqrt{3}}\\begin{pmatrix} 1 \\\\ 10 \\\\ 100 \\end{pmatrix} - 37 \\left( \\frac{1}{\\sqrt{3}}\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{3}}\\begin{pmatrix} 1 - 37 \\\\ 10 - 37 \\\\ 100 - 37 \\end{pmatrix} = \\frac{1}{\\sqrt{3}}\\begin{pmatrix} -36 \\\\ -27 \\\\ 63 \\end{pmatrix}$$\n计算 $H_2$ 的第一个次对角线元素 $\\beta_1 = h_{21}$：\n$$\\beta_1 = \\|\\hat{w}_1\\|_2 = \\frac{1}{\\sqrt{3}}\\sqrt{(-36)^2 + (-27)^2 + (63)^2} = \\frac{1}{\\sqrt{3}}\\sqrt{1296 + 729 + 3969} = \\frac{\\sqrt{5994}}{\\sqrt{3}} = \\sqrt{1998}$$\n第二个标准正交基向量是 $v_2 = \\frac{\\hat{w}_1}{\\beta_1} = \\frac{1}{\\sqrt{1998}} \\frac{1}{\\sqrt{3}} \\begin{pmatrix} -36 \\\\ -27 \\\\ 63 \\end{pmatrix} = \\frac{1}{\\sqrt{5994}}\\begin{pmatrix} -36 \\\\ -27 \\\\ 63 \\end{pmatrix}$。\n\n**步骤 3：Arnoldi 过程的第二次迭代 ($j=2$)**\n计算向量 $w_2 = A v_2$：\n$$w_2 = \\frac{1}{\\sqrt{5994}} \\operatorname{diag}(1, 10, 100) \\begin{pmatrix} -36 \\\\ -27 \\\\ 63 \\end{pmatrix} = \\frac{1}{\\sqrt{5994}} \\begin{pmatrix} -36 \\\\ -270 \\\\ 6300 \\end{pmatrix}$$\n计算 $H_2$ 的第二个对角线元素 $\\alpha_2 = h_{22}$：\n$$\\alpha_2 = v_2^{\\top} w_2 = \\frac{1}{5994} \\begin{pmatrix} -36  -27  63 \\end{pmatrix} \\begin{pmatrix} -36 \\\\ -270 \\\\ 6300 \\end{pmatrix}$$\n$$\\alpha_2 = \\frac{1}{5994} ((-36)^2 + (-27)(-270) + (63)(6300)) = \\frac{1}{5994} (1296 + 7290 + 396900) = \\frac{405486}{5994}$$\n由于 $5994 = 74 \\times 81$ 且 $405486 = 5006 \\times 81$，我们可以简化：\n$$\\alpha_2 = \\frac{5006}{74} = \\frac{2503}{37}$$\n\n**步骤 4：计算 Ritz 值和谱展布指标 $S(H_2)$**\n得到的对称三对角矩阵是：\n$$H_2 = \\begin{pmatrix} \\alpha_1  \\beta_1 \\\\ \\beta_1  \\alpha_2 \\end{pmatrix} = \\begin{pmatrix} 37  \\sqrt{1998} \\\\ \\sqrt{1998}  \\frac{2503}{37} \\end{pmatrix}$$\nRitz 值 $\\{\\theta_1, \\theta_2\\}$ 是 $H_2$ 的特征值。我们需要计算谱展布指标 $S(H_2) = \\theta_{\\max} - \\theta_{\\min}$。直接计算特征值在数值上计算量很大。相反，我们可以利用 $H_2$ 的特征值、迹和行列式之间的关系。\n$$\\theta_{\\max} + \\theta_{\\min} = \\operatorname{tr}(H_2) = \\alpha_1 + \\alpha_2 = 37 + \\frac{2503}{37} = \\frac{37^2 + 2503}{37} = \\frac{1369 + 2503}{37} = \\frac{3872}{37}$$\n$$\\theta_{\\max} \\theta_{\\min} = \\det(H_2) = \\alpha_1 \\alpha_2 - \\beta_1^2 = (37)\\left(\\frac{2503}{37}\\right) - (\\sqrt{1998})^2 = 2503 - 1998 = 505$$\n谱展布的平方由以下恒等式给出：\n$$S(H_2)^2 = (\\theta_{\\max} - \\theta_{\\min})^2 = (\\theta_{\\max} + \\theta_{\\min})^2 - 4\\theta_{\\max}\\theta_{\\min}$$\n代入计算出的值：\n$$S(H_2)^2 = \\left(\\frac{3872}{37}\\right)^2 - 4(505) = \\frac{3872^2}{37^2} - 2020 = \\frac{14992384}{1369} - \\frac{2020 \\times 1369}{1369}$$\n$$S(H_2)^2 = \\frac{14992384 - 2765380}{1369} = \\frac{12227004}{1369}$$\n\n**步骤 5：应用自适应准则**\n自适应规则要求将 $S(H_2)$ 与阈值 $\\tau = 30$ 进行比较。这等同于将 $S(H_2)^2$ 与 $\\tau^2 = 30^2 = 900$ 进行比较。\n我们必须确定 $\\frac{12227004}{1369}  900$ 是否成立。\n$$12227004  900 \\times 1369$$\n$$12227004  1232100$$\n这个不等式显然成立。因此，我们已经确定 $S(H_2) > 30$。\n根据自适应规则，如果 $S(H_2) > \\tau$，我们必须设置 $m_{\\text{next}} = m_0 + 1$。由于 $m_0 = 2$，我们得到：\n$$m_{\\text{next}} = 2 + 1 = 3$$\n\n**步骤 6：改进效果的论证**\n在这种特殊情况下，将重启动参数从 $m=2$ 增加到 $m=3$ 带来的改进是显著的。GMRES 的收敛性基于找到一个满足 $p_k(0)=1$ 的 $k$ 次多项式 $p_k$，使得残差范数 $\\|r_k\\|_2 = \\|p_k(A)r_0\\|_2$ 最小化。为了使这个范数很小，多项式 $p_k(z)$ 在矩阵 $A$ 的特征值处必须很小，并由 $r_0$ 在相应特征空间中的分量加权。\n\n矩阵 $A$ 有三个不同的特征值：$\\{\\lambda_1, \\lambda_2, \\lambda_3\\} = \\{1, 10, 100\\}$。初始残差 $r_0 = (1, 1, 1)^{\\top}$ 在所有三个对应的特征向量方向上都有非零分量。因此，$A$ 关于 $r_0$ 的最小多项式的次数为 3。\n\nGMRES 的一个众所周知的性质是，如果迭代次数 $k$ 等于这个最小多项式的次数，它就会找到精确解。\n- 使用固定的重启动参数 $m=2$，该方法构建一个维度为 2 的 Krylov 子空间 $\\mathcal{K}_2$。最小化多项式的次数为 2。一个二次多项式只有两个根（即 Ritz 值），通常不能在三个不同的点 $\\{1, 10, 100\\}$ 上都为零。因此，GMRES(2) 将无法在一个周期内收敛。它会计算出一个近似解，用新的残差重新启动，并丢失在第一个周期中收集到的所有谱信息，对于像本问题这样具有大条件数（$\\kappa(A) = 100$）的问题，这通常会导致收敛缓慢。\n- 自适应准则通过观察到 Ritz 值存在较大的谱展布（$S(H_2) > 30$），正确地诊断出维度为 2 的小 Krylov 子空间不足以捕捉矩阵 $A$ 的谱特性。因此，它指定增加子空间的维度。\n- 通过设置 $m_{\\text{next}}=3$，我们运行的是 GMRES(3)。由于矩阵维度为 $n=3$，这等同于运行完全（非重启动）的 GMRES。GMRES 将构建完整的 Krylov 子空间 $\\mathcal{K}_3(A, r_0)$，也就是整个空间 $\\mathbb{R}^3$。这保证了该方法将在一个包含 3 次迭代的单一周期内找到精确解。\n\n因此，将 $m$ 从 2 切换到 3，将方法从一个缓慢收敛的迭代过程转变为一个在单一周期内收敛到精确解的过程。最终答案是为 $m_{\\text{next}}$ 确定的值。",
                "answer": "$$\\boxed{3}$$",
                "id": "3542130"
            }
        ]
    }