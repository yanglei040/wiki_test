{
        "hands_on_practices": [
            {
                "introduction": "本章的第一个练习旨在通过手动计算来巩固基本概念。在编写代码或分析复杂系统之前，通过直接、循序渐进的计算来理解吉文斯旋转的核心机制至关重要 ([@problem_id:1029885])。这个练习将引导你为一个小型矩阵手动执行 $QR$ 分解，帮助你建立对该过程几何意义的直观理解。",
                "problem": "考虑 $3 \\times 3$ 矩阵 $A$ 如下：\n\n$$\nA = \\begin{bmatrix} \n1 & 2 & 1 \\\\\n0 & 3 & 1 \\\\\n2 & 1 & 2 \n\\end{bmatrix}.\n$$\n\n使用Givens旋转计算 $A$ 的QR分解，并确保上三角矩阵 $R$ 的对角线元素为正。$R$ 的 $(2,3)$ 元是多少？",
                "solution": "我们对 $A$ 的行进行两次Givens旋转，以将下对角线元素置零，同时保持 $R$ 的对角线为正。\n\n1.  将 $(3,1)$ 元置零。令\n   $$\n   c_1 = \\frac{a_{11}}{\\sqrt{a_{11}^2 + a_{31}^2}}\n       = \\frac{1}{\\sqrt{1+4}}\n       = \\frac{1}{\\sqrt5}, \n   \\quad\n   s_1 = \\frac{a_{31}}{\\sqrt{a_{11}^2 + a_{31}^2}}\n       = \\frac{2}{\\sqrt5}.\n   $$\n   在 $(1,3)$ 平面上的Givens旋转 $G_1$ 给出\n   $$\n   G_1 A = \\begin{bmatrix}\n   \\sqrt{5} & \\frac{4}{\\sqrt{5}} & \\sqrt{5} \\\\\n   0 & 3 & 1 \\\\\n   0 & -\\frac{3}{\\sqrt{5}} & 0\n   \\end{bmatrix}.\n   $$\n\n2.  将新的 $(3,2)$ 元置零。设\n   $$\n   c_2 = \\frac{3}{\\sqrt{9 + \\tfrac{9}{5}}}\n       = \\sqrt{\\frac56},\n   \\quad\n   s_2 = \\frac{-\\tfrac{3}{\\sqrt5}}{\\sqrt{9 + \\tfrac{9}{5}}}\n       = -\\frac{1}{\\sqrt6}.\n   $$\n   将 $G_2$ 应用于最后两行得到\n   $$\n   G_2G_1 A = R = \\begin{bmatrix}\n         \\sqrt{5} & \\frac{4}{\\sqrt{5}} & \\sqrt{5} \\\\\n         0 & \\frac{3\\sqrt{30}}{5} & \\frac{\\sqrt{30}}{6} \\\\\n         0 & 0 & r_{33}\n       \\end{bmatrix},\n   $$\n   根据构造，$r_{33}$ 自动为正。因此 $R$ 的 $(2,3)$ 元是\n   $$\n   r_{23} = \\frac{\\sqrt{30}}{6}.\n   $$",
                "answer": "$$\\boxed{\\frac{\\sqrt{30}}{6}}$$",
                "id": "1029885"
            },
            {
                "introduction": "将算法从理论转化为实际代码会带来新的挑战，尤其是在数值稳定性方面。这个练习将指导你使用吉文斯旋转创建一个稳健的 $QR$ 分解程序，重点是避免使用三角函数并稳定地计算旋转参数 ([@problem_id:3236226])。掌握这一点是将理论知识应用于解决现实世界计算问题的关键一步。",
                "problem": "实现一个程序，该程序使用 Givens 旋转计算一个实数矩阵的薄因子分解，将其分解为一个正交因子和一个上三角因子，并满足以下约束和检查。\n\n给定一个实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 且 $m \\ge n$，目标是找到矩阵 $Q \\in \\mathbb{R}^{m \\times m}$ 和 $R \\in \\mathbb{R}^{m \\times n}$，使得 $Q$ 是正交矩阵，$R$ 是上三角矩阵，并且在浮点舍入误差范围内满足 $A \\approx Q R$。您必须使用 Givens 旋转，通过对行进行左乘来将各个次对角线元素置零。严格禁止使用任何三角函数；相反，应仅从要消去的矩阵元素计算 Givens 参数。具体来说，当消去主元 $a$ 下方的元素 $b$ 时，您的旋转必须仅由 $a$ 和 $b$ 构造。\n\n基本原理：\n- 如果一个方阵 $Q$ 满足 $Q^\\mathsf{T} Q = I$，则称其为正交矩阵。\n- 在由第 $i$ 和第 $j$ 坐标轴张成的平面中的 Givens 旋转由一个 $2 \\times 2$ 的块定义\n$$\nG_{(i,j)} = \\begin{bmatrix} c & s \\\\ -s & c \\end{bmatrix}\n$$\n其中实数标量 $c$ 和 $s$ 满足 $c^2 + s^2 = 1$，其余位置为单位矩阵的元素。用 $G_{(i,j)}$ 左乘只会混合目标矩阵的第 $i$ 行和第 $j$ 行。\n\n您的任务：\n- 实现一个稳健的算法，对每一列 $j$，使用连续的 Givens 旋转来消去所有 $i > j$ 的元素 $A_{ij}$。\n- 当消去主元 $a$ 下方的元素 $b$ 时，不使用三角函数，仅利用 $a$ 和 $b$ 来确定 $c$ 和 $s$。对于非常大、非常小或零值的 $a$ 和 $b$，您的方法必须是良好缩放且数值稳定的。\n- 将总的正交因子累积为所应用的 Givens 旋转的转置的乘积，从而使最终的因子分解满足 $A \\approx Q R$。\n\n验证要求：\n- 定义一个容差 $\\tau = 10^{-10}$。\n- 对于每个测试矩阵 $A$，计算因子 $Q$ 和 $R$ 并验证以下内容：\n  1. 重构：相对 Frobenius 范数误差满足\n  $$\n  \\frac{\\lVert A - Q R \\rVert_F}{\\max\\{\\lVert A \\rVert_F, 1\\}} \\le \\tau.\n  $$\n  2. 正交性：与正交性的偏差满足\n  $$\n  \\lVert Q^\\mathsf{T} Q - I \\rVert_{\\max} \\le \\tau.\n  $$\n  3. 三角性：$R$ 的严格下三角部分很小，\n  $$\n  \\max_{i > j} |R_{ij}| \\le \\tau.\n  $$\n- 对于每个测试矩阵，您的程序必须返回一个布尔值，当且仅当上述所有三个检查都通过时，该值为真。\n\n测试套件：\n使用且仅使用以下五个实数矩阵（每个矩阵都满足 $m \\ge n$）：\n\n1. $A_1 \\in \\mathbb{R}^{4 \\times 3}$，其行向量为：$(2,-1,0),\\quad (3,4,1),\\quad (0,1,3),\\quad (5,-2,2).$\n\n2. $A_2 \\in \\mathbb{R}^{5 \\times 3}$，其行向量为：$(10^{-12},2,-3),\\quad (4,-5,6),\\quad (7,8,-10^{-12}),\\quad (-2,0.5,1.5),\\quad (3,-10^{-9},2.5).$\n\n3. $A_3 \\in \\mathbb{R}^{3 \\times 3}$ (已经是上三角矩阵)，其行向量为：$(4,-1,2),\\quad (0,3,-5),\\quad (0,0,2).$\n\n4. $A_4 \\in \\mathbb{R}^{6 \\times 4}$，其行向量为：$(1,2,3,4),\\quad (2,0,-1,1),\\quad (0,-3,1,2),\\quad (-1,4,0,-2),\\quad (3,-1,2,0),\\quad (5,2,-2,1).$\n\n5. $A_5 \\in \\mathbb{R}^{4 \\times 3}$ (列秩亏：第三列等于第一列加上第二列的两倍)，其行向量为：$(1,0,1),\\quad (2,-1,0),\\quad (3,1,5),\\quad (4,2,8).$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按 $A_1$ 到 $A_5$ 的顺序为每个测试矩阵提供一个布尔值结果。例如，输出应如下所示：`[True,True,True,True,True]`。\n\n角度和物理单位：\n- 此问题中不需要角度或物理单位；不要报告任何角度或物理量。\n\n实现约束：\n- 不要调用任何三角函数。您可以使用平方根以及从 $a$ 和 $b$ 计算出的欧几里得范数。\n- 实现语言在最终答案部分指定；无需读取输入。",
                "solution": "用户要求使用 Givens 旋转实现一个实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$ (其中 $m \\ge n$) 的 QR 因子分解。该分解应产生一个正交矩阵 $Q \\in \\mathbb{R}^{m \\times m}$ 和一个上三角矩阵 $R \\in \\mathbb{R}^{m \\times n}$，使得 $A \\approx QR$。实现过程不得使用三角函数，并且必须是数值稳定的。\n\n### 问题验证\n\n首先，我将根据既定标准验证问题陈述。\n\n**步骤1：提取要点**\n\n-   **任务**：使用 Givens 旋转计算矩阵 $A \\in \\mathbb{R}^{m \\times n}$ ($m \\ge n$) 的 QR 因子分解。\n-   **输出矩阵**：一个正交矩阵 $Q \\in \\mathbb{R}^{m \\times m}$ 和一个上三角矩阵 $R \\in \\mathbb{R}^{m \\times n}$。\n-   **方法**：通过左乘 Givens 旋转矩阵 $G$ 顺序消去次对角线元素 $A_{ij}$ ($i > j$) 。\n-   **Givens 参数约束**：旋转参数 $c$ 和 $s$ 必须根据主元元素 $a$ 和待置零元素 $b$ 计算得出，不得使用三角函数。该计算必须是数值稳定的。\n-   **$Q$ 的累积**：$Q$ 是通过累积各个 Givens 旋转矩阵的转置形成的：$Q = G_1^\\mathsf{T} G_2^\\mathsf{T} \\cdots G_k^\\mathsf{T}$。\n-   **验证**：需要以 $\\tau = 10^{-10}$ 的容差进行三项检查：\n    1.  重构误差：$\\frac{\\lVert A - Q R \\rVert_F}{\\max\\{\\lVert A \\rVert_F, 1\\}} \\le \\tau$。\n    2.  正交性误差：$\\lVert Q^\\mathsf{T} Q - I \\rVert_{\\max} \\le \\tau$。\n    3.  三角性误差：$\\max_{i > j} |R_{ij}| \\le \\tau$。\n-   **测试用例**：提供了五个特定的矩阵 $A_1, \\dots, A_5$。\n-   **最终输出**：一个布尔值列表，每个测试用例对应一个布尔值，表示是否所有三项检查都通过。\n\n**步骤2：使用提取的要点进行验证**\n\n该问题具有科学依据，定义明确且客观。它描述了数值线性代数中的一个标准基础算法。约束条件和验证检查是精确且可形式化的。\n\n存在一个微小的不一致之处：问题标题为“薄因子分解”，但输出矩阵（$Q \\in \\mathbb{R}^{m \\times m}$，$R \\in \\mathbb{R}^{m \\times n}$）的明确定义描述了通常所说的*完整* QR 因子分解。正交性验证检查 $\\lVert Q^\\mathsf{T} Q - I \\rVert_{\\max} \\le \\tau$ 进一步证实了期望得到的是完整的 $m \\times m$ 单位矩阵，从而强化了对完整因子分解的要求。这种差异是标题用词不当，而非实质性矛盾。问题正文中的详细说明是一致且明确的。\n\n**步骤3：结论与行动**\n\n该问题被判定为**有效**。我将根据维度和验证要求中明确规定的内容，着手实现完整的 QR 因子分解。\n\n### 算法设计与原理\n\n该算法的核心是通过从左侧应用一系列 Givens 旋转，将矩阵 $A$ 转换为上三角矩阵 $R$：\n$$\nG_k \\cdots G_2 G_1 A = R\n$$\n每个 Givens 旋转 $G$ 都是一个正交矩阵，因此它们的乘积也是正交的。设 $Q_{\\text{applied}} = G_k \\cdots G_1$。那么 $Q_{\\text{applied}} A = R$，这意味着 $A = Q_{\\text{applied}}^\\mathsf{T} R$。因此，所求的正交因子为 $Q = Q_{\\text{applied}}^\\mathsf{T} = (G_k \\cdots G_1)^\\mathsf{T} = G_1^\\mathsf{T} G_2^\\mathsf{T} \\cdots G_k^\\mathsf{T}$。\n\n我们可以通过将 $R$ 初始化为 $A$、$Q$ 初始化为 $I_m$（$m \\times m$ 单位矩阵）并迭代更新它们来实现。对于用于将某个元素置零的每个 Givens 旋转 $G$，我们更新：\n1.  $R \\leftarrow G R$\n2.  $Q \\leftarrow Q G^\\mathsf{T}$\n\n**Givens 旋转**\n\nGivens 旋转矩阵 $G$ 用于将向量中的特定元素置零。为了使用第 $j$ 行的主元 $a$（在同一列中）消去第 $i$ 行的元素 $b$，我们在 $(j, i)$ 平面中应用一个旋转。对向量 $\\begin{pmatrix} a \\\\ b \\end{pmatrix}$ 的变换是：\n$$\n\\begin{pmatrix} c  & s \\\\ -s & c \\end{pmatrix} \\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\begin{pmatrix} \\sqrt{a^2+b^2} \\\\ 0 \\end{pmatrix}\n$$\n这要求 $c^2 + s^2 = 1$。参数 $c$ 和 $s$ 可以在不使用三角函数的情况下确定：\n$$\nr = \\sqrt{a^2+b^2}, \\quad c = \\frac{a}{r}, \\quad s = \\frac{b}{r}\n$$\n为了数值稳定性，特别是为了防止大的 $a, b$ 导致溢出或小的 $a, b$ 导致精度损失，计算 $r = \\sqrt{a^2+b^2}$ 时应使用一个等效于 `hypot(a, b)` 的稳健函数。\n\n**过程**\n\n该算法逐列进行，从 $j=0$ 到 $n-1$。对每一列 $j$，它遍历对角线下方的行，从 $i=j+1$ 到 $m-1$，将元素 $R_{ij}$ 置零。\n\n对于每个要置零的元素 $R_{ij}$：\n1.  主元是 $a = R_{j,j}$，目标元素是 $b = R_{i,j}$。\n2.  稳定地计算旋转参数 $c$ 和 $s$。如果 $b$ 已经为零，则旋转是单位变换（$c=1, s=0$）。\n3.  将旋转应用于矩阵 $R$ 的第 $j$ 行和第 $i$ 行。对于从 $j$ 到 $n-1$ 的每一列 $k$，元素 $(R_{j,k}, R_{i,k})$ 会被更新：\n    $$\n    \\begin{pmatrix} R'_{j,k} \\\\ R'_{i,k} \\end{pmatrix} = \\begin{pmatrix} c  & s \\\\ -s & c \\end{pmatrix} \\begin{pmatrix} R_{j,k} \\\\ R_{i,k} \\end{pmatrix}\n    $$\n4.  通过右乘 $G^\\mathsf{T}$ 来更新矩阵 $Q$。这会混合 $Q$ 的第 $j$ 列和第 $i$ 列：\n    $$\n    \\begin{pmatrix} Q'_{\\text{col } j} & Q'_{\\text{col } i} \\end{pmatrix} = \\begin{pmatrix} Q_{\\text{col } j} & Q_{\\text{col } i} \\end{pmatrix} \\begin{pmatrix} c & -s \\\\ s & c \\end{pmatrix}\n    $$\n\n重复此过程，直到所有次对角线元素都为零，从而得到最终的矩阵 $Q$ 和 $R$。然后对计算出的因子执行验证检查。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef givens_qr_factorization(A: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Computes the full QR factorization of a matrix A using Givens rotations.\n\n    Args:\n        A (np.ndarray): An m x n real matrix with m >= n.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple (Q, R) where Q is an m x m\n        orthogonal matrix and R is an m x n upper triangular matrix.\n    \"\"\"\n    m, n = A.shape\n    # Use float64 for higher precision to meet the tight tolerance\n    R = A.copy().astype(np.float64)\n    Q = np.identity(m, dtype=np.float64)\n\n    # Iterate through columns to introduce zeros\n    for j in range(n):\n        # Iterate through rows below the diagonal to zero out elements\n        for i in range(j + 1, m):\n            # Pivot element is R[j, j], element to zero is R[i, j]\n            a = R[j, j]\n            b = R[i, j]\n\n            # If the subdiagonal element is already zero, no rotation is needed.\n            # Using a small tolerance check is robust for floating point numbers.\n            if np.isclose(b, 0.0):\n                continue\n\n            # Compute Givens rotation parameters c and s stably.\n            # np.hypot(a, b) calculates sqrt(a^2 + b^2) without intermediate\n            # overflow or underflow. This satisfies the problem's constraint\n            # as it relies only on arithmetic and square roots.\n            r = np.hypot(a, b)\n            c = a / r\n            s = b / r\n\n            # The Givens rotation matrix G has the 2x2 block [[c, s], [-s, c]].\n            # Update R: R_new = G @ R_old.\n            # This transformation affects rows j and i of R.\n            # new_row_j = c * old_row_j + s * old_row_i\n            # new_row_i = -s * old_row_j + c * old_row_i\n            # We copy the slices to avoid overwriting data that's still needed.\n            R_j_row = R[j, j:].copy()\n            R_i_row = R[i, j:].copy()\n            R[j, j:] = c * R_j_row + s * R_i_row\n            R[i, j:] = -s * R_j_row + c * R_i_row\n\n            # Update Q: Q_new = Q_old @ G.T.\n            # G.T has the 2x2 block [[c, -s], [s, c]].\n            # This transformation affects columns j and i of Q.\n            # new_col_j = c * old_col_j + s * old_col_i\n            # new_col_i = -s * old_col_j + c * old_col_i\n            Q_j_col = Q[:, j].copy()\n            Q_i_col = Q[:, i].copy()\n            Q[:, j] = c * Q_j_col + s * Q_i_col\n            Q[:, i] = -s * Q_j_col + c * Q_i_col\n\n    return Q, R\n\ndef solve():\n    \"\"\"\n    Main function to run the Givens QR factorization on test cases and verify.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[2, -1, 0], [3, 4, 1], [0, 1, 3], [5, -2, 2]], dtype=float),\n        np.array([[1e-12, 2, -3], [4, -5, 6], [7, 8, -1e-12], [-2, 0.5, 1.5], [3, -1e-9, 2.5]], dtype=float),\n        np.array([[4, -1, 2], [0, 3, -5], [0, 0, 2]], dtype=float),\n        np.array([[1, 2, 3, 4], [2, 0, -1, 1], [0, -3, 1, 2], [-1, 4, 0, -2], [3, -1, 2, 0], [5, 2, -2, 1]], dtype=float),\n        np.array([[1, 0, 1], [2, -1, 0], [3, 1, 5], [4, 2, 8]], dtype=float),\n    ]\n\n    tau = 1e-10\n    results = []\n\n    for A in test_cases:\n        m, n = A.shape\n        Q, R = givens_qr_factorization(A)\n\n        # 1. Reconstruction check\n        norm_A = np.linalg.norm(A, 'fro')\n        recon_err = np.linalg.norm(A - Q @ R, 'fro') / max(norm_A, 1.0)\n        check1 = recon_err = tau\n\n        # 2. Orthogonality check\n        I_m = np.identity(m)\n        ortho_err = np.max(np.abs(Q.T @ Q - I_m))\n        check2 = ortho_err = tau\n\n        # 3. Triangularity check\n        # np.tril(R, k=-1) extracts the strict lower triangular part of R.\n        tri_err = np.max(np.abs(np.tril(R, k=-1)))\n        check3 = tri_err = tau\n        \n        results.append(check1 and check2 and check3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```",
                "id": "3236226"
            },
            {
                "introduction": "数值算法的效率通常取决于输入矩阵的结构。最后的这个练习探讨了在分解稀疏矩阵时一个至关重要的问题——“填充”（fill-in），即在原本为零的位置上产生了非零元素 ([@problem_id:3569157])。通过将数值过程与图论联系起来，你将分析为何操作顺序如此重要，并学习如何通过明智的排序策略来避免性能的急剧下降。",
                "problem": "设 $k \\ge 3$ 为一个整数，考虑一个稀疏矩阵 $A \\in \\mathbb{R}^{(k+1)\\times (k+1)}$，其列索引为 $0,1,2,\\dots,k$，行索引也为 $0,1,2,\\dots,k$，定义如下\n$$\nA_{0,0}=1,\\quad A_{i,0}=1\\ \\text{for}\\ i=1,\\dots,k,\\quad A_{i,i}=1\\ \\text{for}\\ i=1,\\dots,k,\n$$\n且所有其他元素均为 $0$。换言之，第一列的每一行都有一个非零元，而其他每一列 $i \\in \\{1,\\dots,k\\}$ 仅在其自身的第 $i$ 行有一个非零元。\n\n您将使用 Givens 旋转进行瘦 QR 分解 $A=QR$，遵循以下协议：按 $0,1,2,\\dots,k$ 的顺序处理各列；对于每一列 $j$，对成对的行应用一系列 Givens 旋转，以将列 $j$ 中对角线位置 $(j,j)$ 以下的所有元素置为零，同时保持 $Q$ 的正交性和 $R$ 的上三角性。\n\n从以下核心事实出发：(i) Givens 旋转是一种正交变换，其作用在除了一个选定的 $2\\times 2$ 主子空间外的所有行上都表现为单位变换；(ii) 在没有列主元选择的情况下，QR 分解中上三角因子 $R$ 的非零模式与在相同列序下 $A^{\\top}A$ 的 Cholesky 因子的非零模式相同，回答下列问题：\n\n1. 构造与 $A$ 相关的列交集图，并利用图消去法解释为什么在形成 $R$ 时，首先处理第 0 列会导致严重的“填充”（fill-in）。\n2. 确定 $R$ 中对应于列 $1,2,\\dots,k$ 的子矩阵中，纯粹由于此排序导致的填充而变为非零的严格上三角元素的精确数量，并以关于 $k$ 的闭式表达式给出（即，在输入中结构上为零但在 $R$ 中变为非零的元素）。\n3. 提出一种能够避免这种填充的列排序策略，并从组合学的角度证明其合理性。\n\n您的最终答案应为问题2中所要求的单个闭式表达式。无需四舍五入。",
                "solution": "所述问题具有科学依据，提法恰当且客观。它基于数值线性代数的既定原理，特别是稀疏 QR 分解。所有必要信息均已提供，问题清晰明确。因此，该问题是有效的，我将着手提供完整解答。\n\n对于整数 $k \\ge 3$，矩阵 $A \\in \\mathbb{R}^{(k+1)\\times (k+1)}$ 由其非零元素定义：$A_{0,0}=1$，$A_{i,0}=1$（对于 $i=1,\\dots,k$），以及 $A_{i,i}=1$（对于 $i=1,\\dots,k$）。所有其他元素均为零。行和列的索引从 $0$ 到 $k$。\n\n令 $\\mathbf{c}_j$ 表示 $A$ 的第 $j$ 列。根据定义：\n- 第一列 $\\mathbf{c}_0$ 的元素为 $A_{i,0}=1$（对于所有 $i \\in \\{0, 1, \\dots, k\\}$）。因此，$\\mathbf{c}_0$ 是全一向量。\n- 对于任何其他列 $j \\in \\{1, \\dots, k\\}$，唯一的非零元素是 $A_{j,j}=1$。因此，$\\mathbf{c}_j$ 是标准基向量 $\\mathbf{e}_j$（使用从 0 开始的索引，在第 $j$ 个位置为 1）。\n\n例如，当 $k=3$ 时，矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n1  0  0  0 \\\\\n1  1  0  0 \\\\\n1  0  1  0 \\\\\n1  0  0  1\n\\end{pmatrix}\n$$\n这个矩阵是下三角矩阵。然而，正如我们将看到的，通过从左到右逐列消去次对角线元素来执行 QR 分解会引入大量的填充。\n\n问题陈述了一个关键事实：$A$ 的 QR 分解得到的上三角因子 $R$ 的非零模式与矩阵 $A^{\\mathsf{T}}A$ 的 Cholesky 因子的非零模式完全相同。这使我们能够通过分析 $A^{\\mathsf{T}}A$ 的结构及其符号 Cholesky 分解来确定 $R$ 中的填充。\n\n令 $B = A^{\\mathsf{T}}A$。元素 $B_{ij}$ 是 $A$ 的第 $i$ 列 $\\mathbf{c}_i$ 和第 $j$ 列 $\\mathbf{c}_j$ 的内积。\n- 当 $i=j=0$ 时：$B_{00} = \\mathbf{c}_0^{\\mathsf{T}} \\mathbf{c}_0 = \\sum_{l=0}^{k} 1^2 = k+1$。\n- 当 $i=0$ 且 $j \\in \\{1, \\dots, k\\}$ 时：$B_{0j} = \\mathbf{c}_0^{\\mathsf{T}} \\mathbf{c}_j = \\mathbf{c}_0^{\\mathsf{T}} \\mathbf{e}_j = 1$。根据对称性，$B_{j0}=1$。\n- 当 $i, j \\in \\{1, \\dots, k\\}$ 且 $i \\neq j$ 时：$B_{ij} = \\mathbf{c}_i^{\\mathsf{T}} \\mathbf{c}_j = \\mathbf{e}_i^{\\mathsf{T}} \\mathbf{e}_j = 0$。\n- 当 $i \\in \\{1, \\dots, k\\}$ 时：$B_{ii} = \\mathbf{c}_i^{\\mathsf{T}} \\mathbf{c}_i = \\mathbf{e}_i^{\\mathsf{T}} \\mathbf{e}_i = 1$。\n\n所以，矩阵 $B=A^{\\mathsf{T}}A$ 具有以下结构：\n$$\nB = \\begin{pmatrix}\nk+1  1  1  \\dots  1 \\\\\n1  1  0  \\dots  0 \\\\\n1  0  1  \\dots  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n1  0  0  \\dots  1\n\\end{pmatrix}\n$$\n\n**1. 列交集图与填充**\n\n$A$ 的列交集图（记为 $G_A$）的顶点为 $\\{0, 1, \\dots, k\\}$，对应于 $A$ 的各列。当且仅当列 $\\mathbf{c}_i$ 和 $\\mathbf{c}_j$ 在同一行中都有非零元素时，顶点 $i$ 和 $j$ 之间存在一条边。这等价于条件 $B_{ij} = (A^{\\mathsf{T}}A)_{ij} \\neq 0$（对于 $i \\neq j$）。\n\n根据 $B$ 的结构，我们可以构造 $G_A$：\n- 对于所有 $j \\in \\{1, \\dots, k\\}$，都存在一条边 $(0, j)$，因为 $B_{0j}=1$。\n- 对于 $i, j \\in \\{1, \\dots, k\\}$ 且 $i \\neq j$，不存在边 $(i, j)$，因为 $B_{ij}=0$。\n这个图是一个“星形图”，其中顶点 0 是中心，顶点 $\\{1, 2, \\dots, k\\}$ 是叶节点。\n\n形成 Cholesky 因子（或执行高斯消去）的过程可以在这个图上建模。当一个顶点 $v$ 被消去时，它的所有邻居会形成一个“团”（clique），即它们之间两两相连。这些新生成的边对应于“填充”——即在 $B$ 中为零但在 Cholesky 因子中变为非零的元素。\n\n问题指定按 $0, 1, 2, \\dots, k$ 的顺序处理列。这对应于按相同顺序消去 $G_A$ 中的顶点。我们首先消去顶点 0。顶点 0 的邻居是集合 $\\{1, 2, \\dots, k\\}$。当顶点 0 被消去时，它的所有邻居之间都会添加边。也就是说，对于每一对不同的 $i, j \\in \\{1, 2, \\dots, k\\}$，都会创建一条新边 $(i, j)$。\n\n由顶点 $\\{1, \\dots, k\\}$ 诱导的原始子图是空的（没有边）。在消去顶点 0 之后，这个子图变成了一个完全图（一个团）。这表明 $B$ 的 Cholesky 因子中（因此也是 $R$ 中）对应的子矩阵变得完全稠密。这就是由这种排序引起的“严重填充”。\n\n**2. 填充元素的数量**\n\n我们需要求的是 $R$ 中对应于列 $1, 2, \\dots, k$ 的子矩阵中，属于填充的严格上三角元素的数量。我们将这个 $k \\times k$ 的子矩阵记为 $R_{1:k, 1:k}$。\n\n- **原始结构**：原始矩阵 $A$ 中从 1 到 $k$ 的列是标准基向量 $\\mathbf{e}_1, \\dots, \\mathbf{e}_k$。因此，对于任何满足 $1 \\le i  j \\le k$ 的索引对 $(i, j)$，元素 $A_{ij}$ 均为 $0$。$A$ 中对应于列 $\\{1, \\dots, k\\}$ 和行 $\\{1, \\dots, k\\}$ 的子矩阵的严格上三角部分完全为零。\n- **分解后结构**：如上所述，首先消去第 0 列导致顶点 $\\{1, \\dots, k\\}$ 上的子图变成一个团。这意味着在上三角因子 $R$ 中，子矩阵 $R_{1:k, 1:k}$ 将是一个稠密的上三角矩阵。对于 $1 \\le i \\le j \\le k$ 的每个元素 $R_{ij}$ 都将是非零的。\n- **计算填充**：填充元素是指那些在 $A$ 中为零但在 $R$ 中非零的元素。我们关心的是对应于列 $1, \\dots, k$ 的子矩阵的严格上三角元素。这些是满足 $1 \\le i  j \\le k$ 的元素 $R_{ij}$。由于所有这些元素在 $A$ 中都为零，而在 $R$ 中变为非零，因此填充元素的数量就是这些位置的总数。这正是一个 $k \\times k$ 矩阵的严格上三角部分的元素数量。\n\n此类元素的数量由以下求和给出：\n$$ \\sum_{j=2}^{k} (j-1) = \\sum_{i=1}^{k-1} i = \\frac{(k-1)k}{2} = \\binom{k}{2} $$\n这个表达式给出了所要求的填充元素的精确数量。对于 $k \\ge 3$，这个数总是正的。\n\n**3. 最优列排序**\n\n严重的填充是由于首先消去了度数最高的顶点（星形图的中心）造成的。为了最小化填充，一个通用的启发式方法是“最小度”排序，它优先消去邻居最少的顶点。\n\n在图 $G_A$ 中，顶点 0 的度为 $k$，而每个顶点 $j \\in \\{1, \\dots, k\\}$ 的度为 1。因此，最小度排序会先消去顶点 $1, 2, \\dots, k$（以任意顺序），然后再消去顶点 0。\n让我们考虑排序 $1, 2, \\dots, k, 0$。\n- 消去顶点 1：它唯一的邻居是 0。没有需要连接的邻居对，因此没有填充。\n- 消去顶点 2：它唯一的邻居是 0。没有填充。\n- ...\n- 消去顶点 k：它唯一的邻居是 0。没有填充。\n在消去从 1 到 k 的所有顶点后，没有创建任何新边。图中只剩下孤立的顶点 0。然后，消去顶点 0 也不会产生填充。\n这种排序是一种“完美消去排序”，因为它产生零填充。\n\n因此，任何将第 0 列放在最后处理的排序，例如 $(1, 2, \\dots, k, 0)$，都将避免所述的填充。从组合学的角度来看，这可以通过对列交集图应用最小度算法来证明其合理性。\n\n最终需要的答案是第 2 部分的闭式表达式。填充元素的数量 = $\\frac{k(k-1)}{2}$。",
                "answer": "$$\\boxed{\\frac{k(k-1)}{2}}$$",
                "id": "3569157"
            }
        ]
    }