{
        "hands_on_practices": [
            {
                "introduction": "计算 Wilkinson 位移的公式看似简单——求解一个 $2 \\times 2$ 矩阵的特征值。然而，在有限精度计算中，一个直接的实现可能会因灾难性相消而导致灾难性的失败。本练习将深入探讨这个微妙但至关重要的问题，并指导你推导出一个数值稳健的公式，这是高质量数值软件的基石。[@problem_id:3283423]",
                "problem": "考虑在带位移的正交-三角（QR）算法中确定位移的尾部 $2 \\times 2$ 子块：\n$$\nB \\;=\\; \\begin{pmatrix} a & b \\\\ b & c \\end{pmatrix}\n$$\nWilkinson 位移定义为 $B$ 的特征值中，与右下角元素 $c$ 更接近（绝对差值更小）的那一个。仅从特征多项式定义 $\\det(B - \\lambda I) = 0$ 和二次公式出发，完成以下任务：\n\n1) 推导 $B$ 的两个特征值（用 $a$、$b$ 和 $c$ 表示），并根据 $d = \\tfrac{a - c}{2}$ 的符号，确定哪个分支对应于更接近 $c$ 的特征值。解释为什么当 $|d| \\gg |b|$ 且 $d > 0$ 时，使用朴素的二次公式表达式直接计算更接近 $c$ 的特征值会出现灾难性抵消。\n\n2) 通过对特征方程及其所蕴含的恒等式进行纯代数操作，推导出一个数值稳定的、用于计算更接近 $c$ 的特征值的闭式表达式，该表达式避免了对两个几乎相等的数进行相减。\n\n3) 使用你推导出的稳定表达式，计算特定尾部子块的 Wilkinson 位移\n$$\nB \\;=\\; \\begin{pmatrix} 10^{8} & 10^{-4} \\\\ 10^{-4} & 10^{-8} \\end{pmatrix}\n$$\n将你的最终数值以十位有效数字的十进制小数形式给出。\n\n你的最终答案必须是一个实数（无单位）。",
                "solution": "用户提出了一个关于在 QR 算法中用于寻找对称矩阵特征值的 Wilkinson 位移的三部分问题。我将首先验证问题陈述，然后逐步解决它。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   所讨论的矩阵是一个 $2 \\times 2$ 的对称子块：$B = \\begin{pmatrix} a  b \\\\ b  c \\end{pmatrix}$。\n-   Wilkinson 位移定义为 $B$ 的特征值中更接近 $c$ 的那一个。\n-   定义了一个辅助变量：$d = \\frac{a - c}{2}$。\n-   推导必须从特征多项式 $\\det(B - \\lambda I) = 0$ 和二次公式开始。\n-   第 1 部分：推导 $B$ 的特征值，根据 $\\operatorname{sgn}(d)$ 的符号确定更接近 $c$ 的特征值，并解释当 $|d| \\gg |b|$ 且 $d > 0$ 时，朴素计算中发生的灾难性抵消。\n-   第 2 部分：为 Wilkinson 位移推导一个数值稳定的闭式表达式。\n-   第 3 部分：计算特定矩阵 $B = \\begin{pmatrix} 10^{8}  10^{-4} \\\\ 10^{-4}  10^{-8} \\end{pmatrix}$ 的 Wilkinson 位移，并将结果四舍五入到十位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学性基础：** 该问题是数值线性代数中的一个标准基础课题。Wilkinson 位移、QR 算法以及数值稳定性分析（特别是灾难性抵消）都是公认的概念。该矩阵是对称的，确保了特征值为实数，这与上下文一致。\n-   **适定性：** 问题陈述清晰，包含一系列逻辑任务，导向一个唯一的数学推导和一个特定的数值结果。所有必要的定义和数据都已提供。\n-   **客观性：** 语言正式、精确，没有任何主观或模糊的术语。\n\n**步骤 3：结论与行动**\n该问题是有效的。这是一个适定的、具有科学依据的数值分析问题。我现在将进行完整的解答。\n\n### 第 1 部分：特征值推导与抵消分析\n\n矩阵 $B$ 的特征值 $\\lambda$ 是特征多项式的根，由 $\\det(B - \\lambda I) = 0$ 给出。\n$$\n\\det\\left(\\begin{pmatrix} a  b \\\\ b  c \\end{pmatrix} - \\lambda \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\\right) = \\det\\begin{pmatrix} a - \\lambda  b \\\\ b  c - \\lambda \\end{pmatrix} = 0\n$$\n展开行列式得到二次方程：\n$$\n(a - \\lambda)(c - \\lambda) - b^2 = 0\n$$\n$$\n\\lambda^2 - (a+c)\\lambda + (ac - b^2) = 0\n$$\n使用二次公式求解 $\\lambda$：\n$$\n\\lambda = \\frac{(a+c) \\pm \\sqrt{(a+c)^2 - 4(ac - b^2)}}{2}\n$$\n$$\n\\lambda = \\frac{(a+c) \\pm \\sqrt{a^2 + 2ac + c^2 - 4ac + 4b^2}}{2}\n$$\n$$\n\\lambda = \\frac{(a+c) \\pm \\sqrt{a^2 - 2ac + c^2 + 4b^2}}{2}\n$$\n$$\n\\lambda = \\frac{(a+c) \\pm \\sqrt{(a-c)^2 + 4b^2}}{2}\n$$\n引入给定变量 $d = \\frac{a-c}{2}$，我们有 $a-c = 2d$。我们还注意到 $\\frac{a+c}{2} = \\frac{(c+2d)+c}{2} = c+d$。将这些代入 $\\lambda$ 的表达式中：\n$$\n\\lambda = \\frac{a+c}{2} \\pm \\frac{\\sqrt{4d^2 + 4b^2}}{2} = (c+d) \\pm \\sqrt{d^2+b^2}\n$$\n两个特征值为 $\\lambda_1 = c+d+\\sqrt{d^2+b^2}$ 和 $\\lambda_2 = c+d-\\sqrt{d^2+b^2}$。\n\nWilkinson 位移是更接近 $c$ 的特征值。我们必须比较距离 $|\\lambda_1 - c|$ 和 $|\\lambda_2 - c|$。\n$$\n|\\lambda_1 - c| = |d + \\sqrt{d^2+b^2}|\n$$\n$$\n|\\lambda_2 - c| = |d - \\sqrt{d^2+b^2}|\n$$\n由于 $b^2 \\ge 0$，我们有 $\\sqrt{d^2+b^2} \\ge \\sqrt{d^2} = |d|$。较小的距离对应于 $d$ 和 $\\sqrt{d^2+b^2}$ 相减的表达式。这取决于 $d$ 的符号。\n-   如果 $d > 0$，那么 $|d - \\sqrt{d^2+b^2}| = \\sqrt{d^2+b^2}-d$ 小于 $|d + \\sqrt{d^2+b^2}| = d+\\sqrt{d^2+b^2}$。更接近的特征值是 $\\lambda_2$。\n-   如果 $d  0$，那么 $|d + \\sqrt{d^2+b^2}| = \\sqrt{d^2+b^2}-|d|$ 小于 $|d - \\sqrt{d^2+b^2}| = |d|+\\sqrt{d^2+b^2}$。更接近的特征值是 $\\lambda_1$。\n-   如果 $d = 0$，两个特征值与 $c$ 的距离相等。按照惯例（例如，如 Wilkinson 的原始著作中所述），可以选择一个特定的分支。\n\n我们可以使用符号函数 $\\operatorname{sgn}(d)$ 来统一这个选择，其中我们定义 $\\operatorname{sgn}(0)=1$。绝对值较小的项总是 $d - \\operatorname{sgn}(d)\\sqrt{d^2+b^2}$。因此，Wilkinson 位移 $\\mu$ 由下式给出：\n$$\n\\mu = c + \\left(d - \\operatorname{sgn}(d)\\sqrt{d^2+b^2}\\right)\n$$\n\n现在，考虑 $|d| \\gg |b|$ 且 $d0$ 的情况。Wilkinson 位移为 $\\mu = c+d-\\sqrt{d^2+b^2}$。\n在这种情况下，$\\sqrt{d^2+b^2} = d\\sqrt{1+(b/d)^2}$。由于 $(b/d)^2$ 非常小，使用二项式近似：\n$$\n\\sqrt{d^2+b^2} \\approx d\\left(1 + \\frac{1}{2}\\left(\\frac{b}{d}\\right)^2\\right) = d + \\frac{b^2}{2d}\n$$\n$\\sqrt{d^2+b^2}$ 的值非常接近 $d$。当在有限精度算术中计算表达式 $\\mu = c + (d - \\sqrt{d^2+b^2})$ 时，减法 $d - \\sqrt{d^2+b^2}$ 涉及两个几乎相等的数。这会导致结果中有效数字的大量损失，这种效应被称为灾难性抵消。计算出的位移结果的相对精度会非常低。\n\n### 第 2 部分：数值稳定表达式的推导\n\n为了避免 $d - \\operatorname{sgn}(d)\\sqrt{d^2+b^2}$ 中的灾难性抵消，我们可以使用基于“分子有理化”的代数操作。\n令引起不稳定的项为 $T = d - \\operatorname{sgn}(d)\\sqrt{d^2+b^2}$。我们将其乘以并除以其共轭项 $d + \\operatorname{sgn}(d)\\sqrt{d^2+b^2}$。\n$$\nT = \\frac{\\left(d - \\operatorname{sgn}(d)\\sqrt{d^2+b^2}\\right) \\left(d + \\operatorname{sgn}(d)\\sqrt{d^2+b^2}\\right)}{d + \\operatorname{sgn}(d)\\sqrt{d^2+b^2}}\n$$\n$$\nT = \\frac{d^2 - (\\operatorname{sgn}(d))^2(d^2+b^2)}{d + \\operatorname{sgn}(d)\\sqrt{d^2+b^2}}\n$$\n由于当 $d \\neq 0$ 时 $(\\operatorname{sgn}(d))^2=1$：\n$$\nT = \\frac{d^2 - (d^2+b^2)}{d + \\operatorname{sgn}(d)\\sqrt{d^2+b^2}} = \\frac{-b^2}{d + \\operatorname{sgn}(d)\\sqrt{d^2+b^2}}\n$$\n分母 $d + \\operatorname{sgn}(d)\\sqrt{d^2+b^2}$ 涉及两个同号项（$d$ 和 $\\operatorname{sgn}(d)\\sqrt{...}$）的相加，从而避免了抵消。\n将这个稳定的 $T$ 表达式代回位移公式 $\\mu = c+T$，我们得到数值稳定的形式：\n$$\n\\mu = c - \\frac{b^2}{d + \\operatorname{sgn}(d)\\sqrt{d^2+b^2}}\n$$\n\n### 第 3 部分：数值计算\n\n我们给定的矩阵是：\n$$\nB = \\begin{pmatrix} 10^{8}  10^{-4} \\\\ 10^{-4}  10^{-8} \\end{pmatrix}\n$$\n参数为 $a = 10^8$，$b = 10^{-4}$ 和 $c = 10^{-8}$。\n首先，我们计算 $d$。\n$$\nd = \\frac{a-c}{2} = \\frac{10^8 - 10^{-8}}{2} = 5 \\times 10^7 - 5 \\times 10^{-9}\n$$\n由于 $d  0$，$\\operatorname{sgn}(d) = 1$。Wilkinson 位移 $\\mu$ 的稳定公式是：\n$$\n\\mu = c - \\frac{b^2}{d + \\sqrt{d^2+b^2}}\n$$\n我们有以下数值：\n$c = 10^{-8}$\n$b^2 = (10^{-4})^2 = 10^{-8}$\n\n问题现在是高精度地计算 $\\mu = 10^{-8} - \\frac{10^{-8}}{d + \\sqrt{d^2+10^{-8}}}$。\n我们来计算分母 $D = d + \\sqrt{d^2+b^2}$。\n$d = 49999999.999999995$\n$d^2 = (49999999.999999995)^2 \\approx 2.5 \\times 10^{15}$\n$b^2 = 10^{-8}$\n项 $\\sqrt{d^2+b^2}$ 非常接近 $d$。使用高精度计算器，我们发现：\n$d+\\sqrt{d^2+b^2} \\approx 99999999.99999999000000001...$\n这大约是 $10^8 - 10^{-8}$。我们来计算这个分数：\n$$\n\\frac{b^2}{d + \\sqrt{d^2+b^2}} = \\frac{10^{-8}}{99999999.999999990...} \\approx \\frac{10^{-8}}{10^8} = 10^{-16}\n$$\n所以，位移的初步近似是 $\\mu \\approx 10^{-8} - 10^{-16} = 0.0000000099999999$。\n为了达到要求的十位有效数字，需要更精确的计算。使用具有足够精度的计算工具（例如，Python 的 `Decimal` 库，精度设为 50 位），我们可以计算稳定的表达式：\n$\\mu = c - \\frac{b^2}{d+\\sqrt{d^2+b^2}}$\n这得到的值是：\n$\\mu \\approx 0.000000009999999899999999...$\n用科学记数法表示，这是 $9.999999899999999... \\times 10^{-9}$。\n\n要将其四舍五入到十位有效数字，我们检查前十一位有效数字：$9.999999899$。第十一位数字是 $9$，它 $\\ge 5$，所以我们必须对第十位数字进行进位。\n第十位有效数字是 $9$。将其进位后得到 $0$，并向第九位数字进位。\n第九位有效数字是 $8$。加上进位后变成 $9$。\n四舍五入到十位有效数字的值是 $9.99999990 \\times 10^{-9}$。\n作为十进制小数，这是 $0.00000000999999990$。",
                "answer": "$$\n\\boxed{0.00000000999999990}\n$$",
                "id": "3283423"
            },
            {
                "introduction": "在 QR 算法中执行一次 Wilkinson 位移步之后，我们如何确定是否已成功地找到了一个特征值？本练习将探讨被称为“紧缩”(deflation)的实用终止条件。它将收敛的抽象概念与一个具体的、向后稳定的数值检验联系起来，这个检验对于 QR 算法的效率和成功至关重要。[@problem_id:3598798]",
                "problem": "考虑一个实对称三对角矩阵 $T \\in \\mathbb{R}^{5 \\times 5}$，其对角线元素为 $a_{1},a_{2},a_{3},a_{4},a_{5}$，次对角线元素为 $b_{1},b_{2},b_{3},b_{4}$，由下式给出\n$$\nT=\\begin{pmatrix}\n4.237  0.512  0  0  0 \\\\\n0.512  3.781  0.398  0  0 \\\\\n0  0.398  3.215  0.307  0 \\\\\n0  0  0.307  2.103  1.0\\times 10^{-12} \\\\\n0  0  0  1.0\\times 10^{-12}  2.050\n\\end{pmatrix}.\n$$\n使用威尔金森位移（Wilkinson shift）执行一个隐式正交三角（QR）步骤，该位移定义为 $T$ 的末尾 $2\\times 2$ 主子矩阵中更接近右下角对角线元素的那个特征值。假设机器ε为 $\\epsilon=2^{-52}$，与电气和电子工程师协会（IEEE）浮点算术标准（IEEE 754）中的双精度一致。\n\n在经过威尔金森位移的隐式QR步骤和凸起追逐（bulge chasing）后，更新后的三对角矩阵 $T^{(1)}$ 的底部次对角线元素的测量值为\n$$\n|b_{4}^{(1)}|=4.2\\times 10^{-16}\n$$\n且相邻对角线元素的大小满足\n$$\n|a_{4}^{(1)}|=2.103,\\quad |a_{5}^{(1)}|=2.050\n$$\n\n从正交变换的基本向后稳定性原理以及对称三对角相似变换步骤的扰动行为出发，通过比较末尾底部次对角线元素的大小与相邻对角线元素的大小，推导紧缩检验（deflation test）。然后，计算标量\n$$\n\\delta \\;=\\; |b_{4}^{(1)}| \\;-\\; \\epsilon\\big(|a_{4}^{(1)}|+|a_{5}^{(1)}|\\big)\n$$\n对于上述数据。将 $\\delta$ 的最终数值结果四舍五入到四位有效数字。",
                "solution": "问题要求做两件事：首先，在QR算法的背景下，基于向后稳定性原理，为对称三对角矩阵推导紧缩检验；其次，根据此检验和给定的数据计算特定的值 $\\delta$。\n\n首先，我们来推导紧缩检验。用于寻找特征值的QR算法迭代地对矩阵 $T$ 应用正交相似变换，以生成一个收敛到对角（或块对角）形式的矩阵序列 $T^{(k)}$。对于一个对称三对角矩阵 $T$，每一步都会产生一个新的对称三对角矩阵 $T^{(k+1)} = (Q^{(k)})^T T^{(k)} Q^{(k)}$。\n\n证明紧缩合理性的核心原理是向后稳定性。如果一个算法在有限精度算术中计算出的解是原始问题某个轻微扰动版本的精确解，那么该算法就被认为是向后稳定的。对于对称特征值问题，这意味着计算出的矩阵 $T$ 的特征值是某个矩阵 $T+E$ 的精确特征值，其中扰动 $E$ 是“小的”。\n\n一个单一的隐式QR步骤涉及一系列吉文斯旋转（Givens rotations）。由于浮点舍入误差，计算出的矩阵（我们称之为 $\\hat{T}^{(1)}$）与初始矩阵 $T$ 并非精确正交相似。然而，由 J.H. Wilkinson 开创的向后误差分析表明，$\\hat{T}^{(1)}$ 与一个扰动后的矩阵 $T+E$ 是精确正交相似的。也就是说，对于某个精确的正交矩阵 $\\hat{Q}$，有 $\\hat{T}^{(1)} = \\hat{Q}^T (T+E) \\hat{Q}$。向后误差矩阵 $E$ 的范数很小，通常其上界为 $\\|E\\|_2 \\approx c \\cdot n \\cdot \\epsilon \\cdot \\|T\\|_2$，其中 $n$ 是矩阵的维数，$\\epsilon$ 是机器ε，$c$ 是一个小的常数。\n\n紧缩（Deflation）是当一个次对角线元素 $b_{k-1}$ 的大小被认为可以忽略不计时，将其设置为零的过程。这个操作将矩阵分裂成两个更小的、独立的三对角子问题，从而简化了整个计算过程。让我们考虑一步计算后的矩阵，为简单起见，我们将其表示为 $T^{(1)}$，其对角线元素为 $a_i^{(1)}$，次对角线元素为 $b_i^{(1)}$。将元素 $b_{k-1}^{(1)}$ 设置为零是对矩阵 $T^{(1)}$ 的一次有意扰动。如果我们将结果矩阵称为 $T'$，那么 $T' = T^{(1)} + F$，其中 $F$ 是一个扰动矩阵，仅有两个非零元素：$F_{k-1, k} = F_{k, k-1} = -b_{k-1}^{(1)}$。\n\n如果这个有意的扰动 $F$ 可以在概念上被QR步骤固有的向后误差 $E$ 所吸收，那么它就是合理的。换句话说，我们通过将 $b_{k-1}^{(1)}$ 设置为零所引入的误差，不应大于我们因浮点运算已经产生的误差。这个扰动的大小由其范数来衡量，即 $\\|F\\|_2 = |b_{k-1}^{(1)}|$。\n\n因此，紧缩的条件是 $|b_{k-1}^{(1)}| \\le \\text{tol}$，其中 $\\text{tol}$ 是代表可接受误差尺度的容差。虽然可以使用像 $\\epsilon \\|T^{(1)}\\|_2$ 这样的全局容差，但在高质量的数值库（如LAPACK）中，采用了一个更实用、局部且被广泛接受的标准。该标准将 $|b_{k-1}^{(1)}|$ 与相邻对角线元素 $a_{k-1}^{(1)}$ 和 $a_k^{(1)}$ 的不确定性进行比较。在浮点运算中存储像 $a_k^{(1)}$ 这样的数的不确定性量级为 $\\epsilon |a_k^{(1)}|$。将两个相邻对角线元素的不确定性相加，可以得到一个合理的局部数值噪声尺度。\n\n因此，标准的紧缩检验是：如果次对角线元素 $b_{k-1}^{(1)}$ 的大小与机器精度乘以相邻对角线元素大小之和的量级相当或更小，则宣布其可以忽略不计。这可以正式表述为：\n$$\n|b_{k-1}^{(1)}| \\le \\epsilon \\left( |a_{k-1}^{(1)}| + |a_k^{(1)}| \\right)\n$$\n如果此不等式成立，则将 $b_{k-1}^{(1)}$ 设置为零是一个向后稳定的操作，因为引入的误差在局部 $2 \\times 2$ 块表示的“噪声”范围之内。\n\n接下来，我们为问题中提供的具体数据计算量 $\\delta$。问题设定在矩阵的末尾，因此我们关心的是次对角线元素 $b_4^{(1)}$ 以及相邻的对角线元素 $a_4^{(1)}$ 和 $a_5^{(1)}$。需要计算的量是：\n$$\n\\delta = |b_{4}^{(1)}| - \\epsilon\\big(|a_{4}^{(1)}|+|a_{5}^{(1)}|\\big)\n$$\n$\\delta$ 的符号直接表明是否满足紧缩准则（如果 $\\delta \\le 0$，则准则满足）。\n\n给定的值为：\n- $|b_{4}^{(1)}| = 4.2 \\times 10^{-16}$\n- $|a_{4}^{(1)}| = 2.103$\n- $|a_{5}^{(1)}| = 2.050$\n- $\\epsilon = 2^{-52}$\n\n首先，我们计算对角线元素大小之和：\n$$\n|a_{4}^{(1)}|+|a_{5}^{(1)}| = 2.103 + 2.050 = 4.153\n$$\n接下来，我们计算紧缩容差项 $\\epsilon(|a_{4}^{(1)}|+|a_{5}^{(1)}|)$：\n$$\n\\epsilon(|a_{4}^{(1)}|+|a_{5}^{(1)}|) = 2^{-52} \\times 4.153\n$$\nIEEE 754 双精度下的机器ε值为 $\\epsilon = 2^{-52} \\approx 2.220446049250313 \\times 10^{-16}$。\n$$\n\\text{tol} = (2.220446049250313 \\times 10^{-16}) \\times 4.153 \\approx 9.22151325333190 \\times 10^{-16}\n$$\n现在，我们可以通过代入数值来计算 $\\delta$：\n$$\n\\delta = 4.2 \\times 10^{-16} - 9.22151325333190 \\times 10^{-16}\n$$\n$$\n\\delta = (4.2 - 9.22151325333190) \\times 10^{-16}\n$$\n$$\n\\delta = -5.02151325333190 \\times 10^{-16}\n$$\n问题要求将最终答案四舍五入到四位有效数字。\n$$\n\\delta \\approx -5.022 \\times 10^{-16}\n$$\n$\\delta$ 的负值证实了紧缩准则 $|b_{4}^{(1)}| \\le \\epsilon(|a_{4}^{(1)}|+|a_{5}^{(1)}|)$ 是满足的，因此次对角线元素 $b_{4}^{(1)}$ 将被设置为零。",
                "answer": "$$ \\boxed{-5.022 \\times 10^{-16}} $$",
                "id": "3598798"
            },
            {
                "introduction": "对于三对角矩阵，位移 QR 算法的真正威力在于其隐式实现，它避免了显式构造稠密矩阵的巨大计算开销。本练习将引导你实践“凸起追逐”(bulge chasing)技术，这是一种通过一系列精心设计的 Givens 旋转来施加相似变换，同时保持矩阵三对角结构的优雅方法。通过这个练习，你将揭示使该算法在实践中获得成功的精妙机制。[@problem_id:3598770]",
                "problem": "考虑一个实对称三对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其对角线元素为 $d_1,\\dots,d_n$，次/超对角线元素为 $e_1,\\dots,e_{n-1}$，因此 $A$ 的形式如下：\n$$\nA=\n\\begin{bmatrix}\nd_1  e_1  0  \\cdots  0 \\\\\ne_1  d_2  e_2  \\ddots  \\vdots \\\\\n0  e_2  d_3  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  e_{n-1} \\\\\n0  \\cdots  0  e_{n-1}  d_n\n\\end{bmatrix}.\n$$\n在正交三角(QR)分解中，对于一个给定的矩阵 $B$，我们寻求一个正交矩阵 $Q$ 和一个上三角矩阵 $R$，使得 $B=QR$。对对称三对角矩阵 $A$ 的隐式位移QR迭代过程是：构建 $B = A - \\mu I$，对 $B$ 进行QR分解 $B = QR$，然后通过正交相似变换 $A \\gets RQ + \\mu I$ 来更新 $A$。当位移 $\\mu$ 是根据尾部的 $2 \\times 2$ 主子矩阵选择时，它被称为Wilkinson位移。这一系列相似变换可以通过使用平面旋转（Givens旋转）来隐式且高效地执行，从而在因位移引入的“凸起”于 $n-1$ 步内被追逐到底部后，三对角结构得以保持。\n\n从以下基本依据出发：\n- 正交三角(QR)分解 $B=QR$ 的定义，其中 $Q^\\top Q = I$ 且 $R$ 是上三角矩阵。\n- 对于对称矩阵 $A$，带有正交相似变换的QR算法保持对称性这一事实。\n- 由标准基向量 $e_k$ 和 $e_{k+1}$ 张成的平面中的Givens旋转的定义，该旋转可以消去一个二维向量的第二个分量。\n- Wilkinson位移的特征，即选择 $\\mu$ 等于 $A$ 的尾部 $2\\times 2$ 主子矩阵的两个特征值中更接近右下角元素的那个。\n\n你的任务是：\n1. 通过引用实对称 $2\\times 2$ 矩阵的特征值公式以及一个能减轻灾难性抵消的选择，推导出Wilkinson位移 $\\mu$ 从 $A$ 的尾部 $2\\times 2$ 主子矩阵得到的表达式。\n2. 从第一性原理出发解释，在使用根据 $A - \\mu I$ 的第一列计算出的Givens旋转时，引入位移 $\\mu$ 是如何产生一个“凸起”的，以及一系列 $n-1$ 次Givens旋转（每次作为正交相似变换应用）是如何追逐这个凸起以恢复三对角形式的。\n3. 实现一个程序，对于每个提供的测试矩阵，使用一系列在 $n-1$ 步后恢复三对角形式的Givens旋转，对 $A$ 执行一步带Wilkinson位移的隐式QR步骤。通过同时计算显式QR步骤 $A_{\\mathrm{exp}} = RQ + \\mu I$（使用 $A - \\mu I$ 的稠密QR分解）来验证正确性，并报告每个测试用例的差的Frobenius范数 $\\|A_{\\mathrm{implicit}} - A_{\\mathrm{exp}}\\|_F$。\n\n使用以下参数值测试套件，每个套件由其对角线列表 $[d_1,\\dots,d_n]$ 和次/超对角线列表 $[e_1,\\dots,e_{n-1}]$ 指定：\n- 测试用例 $1$ (一般情况, $n=6$)：$d=[4.0,\\,1.5,\\,3.2,\\,2.8,\\,5.5,\\,6.1]$, $e=[0.7,\\,-1.0,\\,0.5,\\,0.3,\\,-0.8]$。\n- 测试用例 $2$ (边界情况, $n=2$)：$d=[1.0,\\,2.0]$, $e=[0.5]$。\n- 测试用例 $3$ (尾部特征值近似重根, $n=5$)：$d=[1.2,\\,-0.3,\\,0.1,\\,1.0,\\,1.0000001]$, $e=[0.01,\\,0.0,\\,0.02,\\,1\\times 10^{-8}]$。\n- 测试用例 $4$ (较大结构化情况, $n=10$)：$d=[1.0,\\,2.0,\\,3.0,\\,4.0,\\,5.0,\\,6.0,\\,7.0,\\,8.0,\\,9.0,\\,10.0]$, $e=[0.5,\\,-0.4,\\,0.3,\\,-0.2,\\,0.1,\\,-0.05,\\,0.04,\\,-0.03,\\,0.02]$。\n- 测试用例 $5$ (对角矩阵边缘情况, $n=5$)：$d=[2.0,\\,3.0,\\,5.0,\\,7.0,\\,11.0]$, $e=[0.0,\\,0.0,\\,0.0,\\,0.0]$。\n\n任何旋转计算的角度单位都隐含在Givens旋转的三角函数参数化中，无需报告；根据标准的数值线性代数惯例，所有内部计算均以弧度为单位。不涉及物理单位。\n\n你的程序必须：\n- 从 $d$ 和 $e$ 构造 $A$。\n- 使用 $A$ 的尾部 $2\\times 2$ 子块计算Wilkinson位移 $\\mu$。\n- 使用Givens旋转执行一步隐式位移QR步骤，以追逐凸起并在 $n-1$ 步后恢复三对角形式，得到 $A_{\\mathrm{implicit}}$。\n- 通过对 $A - \\mu I$ 进行稠密QR分解来计算显式QR步骤，以获得 $A_{\\mathrm{exp}}$。\n- 对于每个测试用例，计算Frobenius范数 $\\|A_{\\mathrm{implicit}} - A_{\\mathrm{exp}}\\|_F$ 作为一个浮点数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是第 $k$ 个测试用例的浮点数Frobenius范数。",
                "solution": "用户提供的问题被评估为有效。这是一个在数值线性代数领域内的适定、有科学依据且客观的问题。它要求推导、解释并实现一个核心算法，即针对对称三对角矩阵的带Wilkinson位移的隐式QR步骤。解决问题所需的所有数据和定义均已提供。\n\n### 1. Wilkinson位移的推导\n\nWilkinson位移 $\\mu$ 是对称三对角矩阵 $A$ 的尾部 $2 \\times 2$ 主子矩阵的两个特征值之一。这个子矩阵，我们称之为 $A_{sub}$，由下式给出：\n$$\nA_{sub} = \n\\begin{bmatrix}\nd_{n-1}  e_{n-1} \\\\\ne_{n-1}  d_n\n\\end{bmatrix}\n$$\n$A_{sub}$ 的特征值 $\\lambda$ 是其特征多项式 $\\det(A_{sub} - \\lambda I) = 0$ 的根。\n$$\n\\det \\begin{bmatrix}\nd_{n-1} - \\lambda  e_{n-1} \\\\\ne_{n-1}  d_n - \\lambda\n\\end{bmatrix} = 0\n$$\n$$\n(d_{n-1} - \\lambda)(d_n - \\lambda) - e_{n-1}^2 = 0\n$$\n$$\n\\lambda^2 - (d_{n-1} + d_n)\\lambda + (d_{n-1}d_n - e_{n-1}^2) = 0\n$$\n这是一个关于 $\\lambda$ 的二次方程。使用二次公式，其根为：\n$$\n\\lambda = \\frac{(d_{n-1} + d_n) \\pm \\sqrt{(d_{n-1} + d_n)^2 - 4(d_{n-1}d_n - e_{n-1}^2)}}{2}\n$$\n简化判别式：\n$$\n(d_{n-1}^2 + 2d_{n-1}d_n + d_n^2) - 4d_{n-1}d_n + 4e_{n-1}^2 = d_{n-1}^2 - 2d_{n-1}d_n + d_n^2 + 4e_{n-1}^2 = (d_{n-1} - d_n)^2 + (2e_{n-1})^2\n$$\n因此，特征值为：\n$$\n\\lambda = \\frac{d_{n-1} + d_n}{2} \\pm \\frac{\\sqrt{(d_{n-1} - d_n)^2 + 4e_{n-1}^2}}{2} = \\frac{d_{n-1} + d_n}{2} \\pm \\sqrt{\\left(\\frac{d_{n-1} - d_n}{2}\\right)^2 + e_{n-1}^2}\n$$\n我们定义一个辅助变量 $\\delta = \\frac{d_{n-1} - d_n}{2}$。两个特征值为：\n$$\n\\lambda_1, \\lambda_2 = d_n + \\delta \\pm \\sqrt{\\delta^2 + e_{n-1}^2}\n$$\nWilkinson位移 $\\mu$ 定义为更接近 $d_n$ 的那个特征值。特征值与 $d_n$ 的距离为 $|\\lambda_1 - d_n| = |\\delta + \\sqrt{\\delta^2 + e_{n-1}^2}|$ 和 $|\\lambda_2 - d_n| = |\\delta - \\sqrt{\\delta^2 + e_{n-1}^2}|$。由于 $\\sqrt{\\delta^2 + e_{n-1}^2} \\geq |\\delta|$，幅度较小的一项是 $\\delta$ 与平方根项相减的那一项。这对应于选择与 $\\delta$ 符号相反的符号。因此，位移 $\\mu$ 是满足以下条件的特征值：\n$$\n\\mu - d_n = \\delta - \\mathrm{sign}(\\delta) \\sqrt{\\delta^2 + e_{n-1}^2}\n$$\n所以，位移是：\n$$\n\\mu = d_n + \\delta - \\mathrm{sign}(\\delta) \\sqrt{\\delta^2 + e_{n-1}^2}\n$$\n如果 $\\delta=0$，则出现一个特殊情况，按照惯例我们可以选择任一符号。`numpy.sign(0)` 为 $0$，这将导致不正确的位移 $\\mu=d_n$。一个稳健的实现会使用 `copysign` 或显式处理这种情况。\n\n如果 $|\\delta| \\gg |e_{n-1}|$，直接计算此公式可能会遭受灾难性抵消，因为我们将在两个几乎相等的大数之间进行减法。通过利用韦达定理，可以推导出更数值稳定的公式。对于二次方程 $x^2 - (r_1+r_2)x + r_1 r_2 = 0$，有 $r_1 = (r_1r_2)/r_2$。令 $x = \\lambda - d_n$。特征方程变为 $x^2 - 2\\delta x - e_{n-1}^2 = 0$。根的乘积为 $(\\mu-d_n)(\\lambda_{other}-d_n) = -e_{n-1}^2$。我们想要的根是 $\\mu-d_n$。另一个根是 $\\lambda_{other}-d_n = \\delta + \\mathrm{sign}(\\delta)\\sqrt{\\delta^2 + e_{n-1}^2}$。因此，我们可以写出：\n$$\n\\mu - d_n = \\frac{-e_{n-1}^2}{\\lambda_{other}-d_n} = \\frac{-e_{n-1}^2}{\\delta + \\mathrm{sign}(\\delta)\\sqrt{\\delta^2 + e_{n-1}^2}}\n$$\n这给出了Wilkinson位移最终的、数值上更优的公式：\n$$\n\\mu = d_n - \\frac{e_{n-1}^2}{\\delta + \\mathrm{sign}(\\delta)\\sqrt{\\delta^2 + e_{n-1}^2}}\n$$\n这种形式避免了灾难性抵消，并且即使在 $e_{n-1}$ 很小的情况下也是稳健的。如果 $e_{n-1}=0$，则 $\\mu=d_n$，这是正确的，因为此时 $d_n$ 是一个解耦的特征值。如果 $\\delta=0$，分母为 $\\sqrt{e_{n-1}^2}=|e_{n-1}|$，因此 $\\mu = d_n - |e_{n-1}|$，这是其中一个特征值。\n\n### 2. 隐式QR步骤与凸起追逐\n\n对对称三对角矩阵 $A$ 的隐式位移QR步骤计算相似变换 $A_{new} = Q^T A Q$，其中 $A - \\mu I = QR$，而无需显式地构建矩阵 $Q$。该过程依赖于隐式Q定理，该定理指出，如果构造一个正交矩阵 $G$ 使得 $G^T A G$ 是三对角的，并且 $G$ 的第一列与 $Q$ 的第一列相同，那么 $G$ 本质上就是 $Q$（在列的符号上可能有所不同）。该过程使用Givens旋转分 $n-1$ 步展开。\n\n1.  **位移引入和初始旋转：**\n    一个显式的QR步骤首先会构建 $B = A - \\mu I$。$B$ 的第一列是 $[d_1 - \\mu, e_1, 0, \\dots, 0]^T$。QR分解中的第一个正交矩阵 $Q_1$ 被选择用来将该列向量的第二个元素置零。对于隐式步骤，我们只需要计算这个旋转的参数。我们在 $(1,2)$ 平面（作用于第1行/列和第2行/列）中找到一个参数为 $(c,s)$ 的Givens旋转 $G_1$，使得：\n    $$\n    \\begin{bmatrix} c  s \\\\ -s  c \\end{bmatrix}\n    \\begin{bmatrix} d_1 - \\mu \\\\ e_1 \\end{bmatrix} =\n    \\begin{bmatrix} * \\\\ 0 \\end{bmatrix}\n    $$\n    矩阵 $G_1$ 的第一列与完整的正交矩阵 $Q$ 的第一列相同。\n\n2.  **凸起产生：**\n    这个旋转立即作为相似变换应用于 $A$：$A^{(1)} = G_1^T A G_1$。我们来分析填充情况。$A$ 是三对角的，所以 $A_{1,3} = A_{3,1} = 0$。\n    - 左乘 $G_1^T A$ 会混合第1行和第2行。$G_1^T A$ 在位置 $(1,3)$ 处的元素变为 $c A_{1,3} + s A_{2,3} = c \\cdot 0 + s \\cdot e_2 = s e_2$。\n    - 随后的右乘 $G_1$ 会混合第1列和第2列。这不会影响第3列。\n    - 因此，得到的矩阵 $A^{(1)}$ 在位置 $(1,3)$ 处有一个新的非零项。根据对称性，$A^{(1)}_{3,1}$ 也非零。这个在三对角带外的非期望元素被称为“凸起”。\n    $$\n    A^{(1)} = G_1^T A G_1 = \\begin{bmatrix} *  *  \\mathbf{se_2}  0  \\cdots \\\\ *  *  *  *  \\cdots \\\\ \\mathbf{se_2}  *  *  e_3  \\cdots \\\\ 0  *  e_3  d_4  \\cdots \\\\ \\vdots  \\vdots  \\vdots  \\vdots  \\ddots \\end{bmatrix}\n    $$\n\n3.  **凸起追逐：**\n    必须恢复三对角形式。这是通过将凸起“追逐”到底部并移出矩阵来实现的，这一过程需要一系列 $n-2$ 次额外的Givens旋转。\n    - **步骤 $k=1$ (追逐1)：** 矩阵 $A^{(1)}$ 在 $(1,3)$ (和 $(3,1)$) 位置有一个凸起。为了消除它，我们在 $(2,3)$ 平面设计一个Givens旋转 $G_2$。选择 $G_2$ 以将凸起置零。我们根据 $A^{(1)}$ 第一列中的元素，具体是向量 $(A^{(1)}_{2,1}, A^{(1)}_{3,1})^T$ 来构造 $G_2$。\n    - 我们应用相似变换 $A^{(2)} = G_2^T A^{(1)} G_2$。\n    - 左乘 $G_2^T A^{(1)}$ 被设计用来将 $A^{(1)}_{3,1}$ 置零。右乘 $A^{(1)}G_2$ 不影响第一列，所以 $A^{(2)}_{3,1}$ 保持为零。根据对称性，$A^{(2)}_{1,3}$ 也为零。\n    - 然而，这个变换移动了凸起。原始矩阵 $A$ 有一个非零的 $A_{3,4}=e_3$。矩阵 $A^{(1)}$ 仍然有 $A^{(1)}_{3,4} = e_3$，因为 $G_1$ 没有影响这个元素。变换 $G_2^T A^{(1)}$ 混合了第2行和第3行。新的元素 $A^{(2)}_{2,4}$ 成为 $A^{(1)}_{2,4}=0$ 和 $A^{(1)}_{3,4}=e_3$ 的线性组合，因此非零。凸起从 $(1,3)$ 被“追逐”到了 $(2,4)$。\n\n4.  **一般追逐步骤：**\n    这个过程被迭代。对于 $k = 1, \\dots, n-2$，我们有一个矩阵 $A^{(k)}$，在位置 $(k-1, k+1)$ 有一个凸起。我们在 $(k,k+1)$ 平面构造一个Givens旋转 $G_{k+1}$，其参数由向量 $(A^{(k)}_{k, k-1}, A^{(k)}_{k+1, k-1})^T$ 决定，以消去在 $(k+1, k-1)$ 的凸起。相似变换 $A^{(k+1)} = G_{k+1}^T A^{(k)} G_{k+1}$ 消除了这个凸起，但在 $(k, k+2)$ 处产生了一个新的凸起。\n\n5.  **终止：**\n    经过总共 $n-1$ 次旋转（$G_1, \\dots, G_{n-1}$）后，凸起被追逐到位置 $(n-2, n)$，然后通过在 $(n-1, n)$ 平面中的最后一次旋转 $G_{n-1}$ 被完全追逐出矩阵。最终得到的矩阵 $A_{new} = G_{n-1}^T \\dots G_1^T A G_1 \\dots G_{n-1}$ 是三对角的，并且与原始矩阵 $A$ 正交相似。这样就完成了一步隐式QR步骤。\n\n### 3. 实现\n实现将遵循上述推导的逻辑。\n- 一个函数将为每个测试用例 $k$ 构造稠密矩阵 $A_k$。\n- Wilkinson位移 $\\mu$ 将使用数值稳定的公式计算。\n- $A_{\\mathrm{implicit}}$ 将通过初始化 $A_k$ 并应用 $n-1$ 次Givens相似变换序列来计算，从由位移引起的旋转开始，然后是 $n-2$ 次凸起追逐旋转。\n- $A_{\\mathrm{exp}}$ 将通过构建 $B = A_k - \\mu I$，使用 `scipy.linalg.qr` 找到其稠密QR分解 $B=QR$，然后构建 $A_{\\mathrm{exp}} = RQ + \\mu I$ 来计算。\n- 将计算并报告每个用例的差的Frobenius范数 $\\|A_{\\mathrm{implicit}} - A_{\\mathrm{exp}}\\|_F$。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef solve():\n    \"\"\"\n    Solves the problem of performing one implicit shifted QR step on several\n    tridiagonal matrices and validating the result against an explicit QR step.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case, n=6)\n        {'d': [4.0, 1.5, 3.2, 2.8, 5.5, 6.1], 'e': [0.7, -1.0, 0.5, 0.3, -0.8]},\n        # Test case 2 (boundary case, n=2)\n        {'d': [1.0, 2.0], 'e': [0.5]},\n        # Test case 3 (near-multiple trailing eigenvalues, n=5)\n        {'d': [1.2, -0.3, 0.1, 1.0, 1.0000001], 'e': [0.01, 0.0, 0.02, 1e-8]},\n        # Test case 4 (larger structured case, n=10)\n        {'d': [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0], 'e': [0.5, -0.4, 0.3, -0.2, 0.1, -0.05, 0.04, -0.03, 0.02]},\n        # Test case 5 (diagonal matrix edge case, n=5)\n        {'d': [2.0, 3.0, 5.0, 7.0, 11.0], 'e': [0.0, 0.0, 0.0, 0.0]},\n    ]\n    \n    results = []\n\n    for case in test_cases:\n        d = np.array(case['d'], dtype=float)\n        e = np.array(case['e'], dtype=float)\n        n = len(d)\n        \n        # Construct the full tridiagonal matrix A\n        A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1)\n\n        if n  2:\n            results.append(0.0)\n            continue\n            \n        # 1. Compute Wilkinson shift mu\n        d_n = d[-1]\n        d_n_minus_1 = d[-2]\n        e_n_minus_1 = e[-1]\n\n        if e_n_minus_1 == 0.0:\n            mu = d_n\n        else:\n            delta = (d_n_minus_1 - d_n) / 2.0\n            sign_delta = np.copysign(1.0, delta) if delta != 0.0 else 1.0\n            discriminant_sqrt = np.sqrt(delta**2 + e_n_minus_1**2)\n            # Numerically stable formula for the Wilkinson shift\n            mu = d_n - (e_n_minus_1**2) / (delta + sign_delta * discriminant_sqrt)\n\n        # 2. Perform one implicit shifted QR step\n        A_implicit = A.copy()\n        \n        # Helper to apply Givens rotation as a similarity transformation\n        def apply_givens_similarity(M, c, s, k):\n            # Rotates rows k and k+1\n            row1 = M[k, :].copy()\n            row2 = M[k+1, :].copy()\n            M[k, :] = c * row1 + s * row2\n            M[k+1, :] = -s * row1 + c * row2\n            \n            # Rotates columns k and k+1\n            col1 = M[:, k].copy()\n            col2 = M[:, k+1].copy()\n            M[:, k] = c * col1 + s * col2\n            M[:, k+1] = -s * col1 + c * col2\n            \n        # Helper to compute Givens rotation parameters\n        def get_givens_params(a, b):\n            if b == 0.0:\n                return 1.0, 0.0\n            else:\n                r = np.hypot(a, b)\n                return a / r, b / r\n\n        # Introduction of the bulge\n        x = A_implicit[0, 0] - mu\n        y = A_implicit[1, 0] \n        c, s = get_givens_params(x, y)\n        apply_givens_similarity(A_implicit, c, s, 0)\n\n        # Bulge chasing\n        for k in range(n - 2):\n            # The bulge is at (k, k+2) and (k+2, k).\n            # We choose G_k+1 in plane (k+1, k+2) to zero out the bulge.\n            # The rotation is defined by column k.\n            x = A_implicit[k+1, k]\n            y = A_implicit[k+2, k]\n            \n            c, s = get_givens_params(x, y)\n            apply_givens_similarity(A_implicit, c, s, k + 1)\n            \n        # 3. Perform one explicit shifted QR step\n        A_exp = A.copy()\n        Id = np.identity(n)\n        B = A_exp - mu * Id\n        Q, R = qr(B)\n        A_exp = R @ Q + mu * Id\n\n        # 4. Compute and store the Frobenius norm of the difference\n        diff_norm = np.linalg.norm(A_implicit - A_exp, 'fro')\n        results.append(diff_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```",
                "id": "3598770"
            }
        ]
    }