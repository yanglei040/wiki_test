{
        "hands_on_practices": [
            {
                "introduction": "要深入理解计算误差的来源，我们必须首先掌握数字在计算机中的表示方式。本练习将引导你从第一性原理出发，剖析 IEEE 754 浮点标准的内部结构，通过计算单精度和双精度格式下的关键参数，你将对可表示数值的范围、精度限制以及溢出和下溢的边界有更深刻的认识。[@problem_id:3579628]",
                "problem": "考虑遵循国际电气与电子工程师协会（IEEE）浮点算术标准（IEEE 754）的二进制（基数为 $2$）算术，采用默认的“向最近舍入，偶数优先”的舍入模式。我们将关注两种标准格式：\n- binary32（通常称为单精度），对于规格化数使用 $p=24$ 位的尾数精度，指数场为 $8$ 位，偏置值为 $127$，并支持非规格化数；\n- binary64（通常称为双精度），对于规格化数使用 $p=53$ 位的尾数精度，指数场为 $11$ 位，偏置值为 $1023$，并支持非规格化数。\n\n从该格式的第一性原理出发：规格化数的表示，其有效数（significand）有一个隐含的前导 $1$，其无偏指数范围由指数场的边界和偏置值决定；非规格化数的表示，其有效数没有隐含的前导 $1$，并采用等于最小规格化指数的固定最小指数；以及默认舍入为“向最近舍入，偶数优先”的事实。对规格化结果采用广泛使用的单位舍入误差模型，即一个正确舍入的浮点运算满足 $\\mathrm{fl}(x\\circ y)=(x\\circ y)(1+\\delta)$，其中 $|\\delta|\\leq u$，单位舍入误差 $u$ 仅取决于格式，前提是精确结果是有限的且是规格化的。\n\n你的任务是：\n1. 对于 binary32 和 binary64，分别确定最小正非规格化数、最小正规格化数和最大可表示有限数。将每个数精确表示为 $2$ 的幂的乘积或和。\n2. 在“向最近舍入，偶数优先”模式下，确定 binary32 和 binary64 各自的单位舍入误差 $u$。\n3. 对于每种格式的浮点乘法，确定两个量级阈值 $T_{\\mathrm{under}}$ 和 $T_{\\mathrm{over}}$，使其具有以下性质：\n   - 如果 $|x|,|y|\\geq T_{\\mathrm{under}}$ 且 $x,y$ 在该格式下是可表示的，那么精确乘积 $xy$ 的量级至少为最小正规格化数。\n   - 如果 $|x|,|y|\\leq T_{\\mathrm{over}}$ 且 $x,y$ 在该格式下是可表示的，那么精确乘积 $xy$ 的量级至多为最大可表示有限数。\n   使用这些阈值划定输入量级的区域 $[T_{\\mathrm{under}},T_{\\mathrm{over}}]$，在此区域内，浮点乘积保证为一个有限的规格化数，因此标准舍入误差模型 $|\\delta|\\leq u$ 适用于乘法。将 $T_{\\mathrm{under}}$ 和 $T_{\\mathrm{over}}$ 精确表示为 $2$ 的幂和根式（如果需要）。\n\n将你的最终结果以单行矩阵的形式报告，各项顺序如下：\n- binary32 最小正非规格化数，binary32 最小正规格化数，binary32 最大有限数，binary32 单位舍入误差，binary32 $T_{\\mathrm{under}}$，binary32 $T_{\\mathrm{over}}$，binary64 最小正非规格化数，binary64 最小正规格化数，binary64 最大有限数，binary64 单位舍入误差，binary64 $T_{\\mathrm{under}}$，binary64 $T_{\\mathrm{over}}$。\n\n不需要单位。不要近似；请给出精确表达式。最终答案必须是指定的单行矩阵格式。",
                "solution": "问题陈述是数值分析中一个关于 IEEE 754 浮点算术标准性质的适定练习。它在科学上是合理的、自成体系且客观的。所有术语和参数都是标准的且定义清晰。该问题是有效的。\n\n解决方案分为三部分，针对 binary32 和 binary64 两种格式，分别解决问题中指定的三个任务。\n\n在 IEEE 754 标准中，一个浮点数 $v$ 表示为 $v = (-1)^s \\times m \\times 2^E$，其中 $s$ 是符号位，$m$ 是有效数（significand），$E$ 是无偏指数。指数由一个 $k$ 位的存储指数场（记为 $e$）和一个偏置值决定，即 $E = e - \\text{bias}$。\n\n对于 **binary32**（单精度）：\n该格式共使用 $32$ 位，其中 $k=8$ 位用于指数，有效数的总精度为 $p=24$ 位（对于规格化数，包含 $1$ 个隐含位和 $23$ 个显式小数位）。偏置值为 $127$。\n存储的指数 $e$ 的范围是从 $0$ 到 $2^8 - 1 = 255$。\n规格化数对应 $1 \\le e \\le 254$。其有效数有一个隐含的前导 $1$，所以 $m = 1.f_{1}f_{2}...f_{23}$，这意味着 $1 \\le m  2$。无偏指数为 $E = e - 127$，范围从 $E_{\\min} = 1-127 = -126$ 到 $E_{\\max} = 254-127 = 127$。\n非规格化数对应 $e=0$。其有效数有一个隐含的前导 $0$，所以 $m = 0.f_{1}f_{2}...f_{23}$，这意味着 $0  m  1$。指数固定为最小规格化指数，即 $E_{\\min} = -126$。\n\n对于 **binary64**（双精度）：\n该格式共使用 $64$ 位，其中 $k=11$ 位用于指数，有效数的总精度为 $p=53$ 位（$1$ 个隐含位加上 $52$ 个显式小数位）。偏置值为 $1023$。\n存储的指数 $e$ 的范围是从 $0$ 到 $2^{11} - 1 = 2047$。\n规格化数对应 $1 \\le e \\le 2046$。其有效数为 $1 \\le m  2$。无偏指数为 $E = e - 1023$，范围从 $E_{\\min} = 1-1023 = -1022$ 到 $E_{\\max} = 2046-1023 = 1023$。\n非规格化数对应 $e=0$。其有效数为 $0  m  1$。指数固定为 $E_{\\min} = -1022$。\n\n**1. 特征数**\n\n**binary32：**\n- **最小正非规格化数 ($SPS_{32}$):** 这出现在非规格化数的最小可能非零有效数和固定的非规格化指数下。有效数是 $m=0.0...01_2 = 2^{-23}$。指数是 $E_{\\min} = -126$。\n$$SPS_{32} = 2^{-23} \\times 2^{-126} = 2^{-149}$$\n- **最小正规格化数 ($SPN_{32}$):** 这出现在最小规格化指数和最小规格化有效数下。指数是 $E_{\\min} = -126$。有效数是 $m=1.0...0_2 = 1$。\n$$SPN_{32} = 1 \\times 2^{-126} = 2^{-126}$$\n- **最大可表示有限数 ($LFN_{32}$):** 这出现在最大规格化指数和最大可能有效数下。指数是 $E_{\\max}=127$。有效数是 $m=1.1...1_2$（小数点后有 $23$ 个 $1$），即 $m = \\sum_{i=0}^{23} 2^{-i} = 2 - 2^{-23}$。\n$$LFN_{32} = (2 - 2^{-23}) \\times 2^{127} = 2^{128} - 2^{104}$$\n\n**binary64：**\n- **最小正非规格化数 ($SPS_{64}$):** 有效数是 $m=0.0...01_2 = 2^{-52}$（有 $52$ 个小数位）。指数是 $E_{\\min} = -1022$。\n$$SPS_{64} = 2^{-52} \\times 2^{-1022} = 2^{-1074}$$\n- **最小正规格化数 ($SPN_{64}$):** 指数是 $E_{\\min} = -1022$。有效数是 $m=1$。\n$$SPN_{64} = 1 \\times 2^{-1022} = 2^{-1022}$$\n- **最大可表示有限数 ($LFN_{64}$):** 指数是 $E_{\\max}=1023$。有效数是 $m=1.1...1_2$（小数点后有 $52$ 个 $1$），即 $m = 2 - 2^{-52}$。\n$$LFN_{64} = (2 - 2^{-52}) \\times 2^{1023} = 2^{1024} - 2^{971}$$\n\n**2. 单位舍入误差**\n\n对于“向最近舍入”的舍入模式，单位舍入误差 $u$ 是机器 epsilon $\\epsilon$ 的一半。机器 epsilon 是 $1$ 和下一个可表示的最大浮点数之间的距离。对于一个精度为 $p$ 的系统，数字 $1$ 表示为有效数为 $1$、指数为 $0$。下一个更大的数其有效数为 $1+2^{-(p-1)}$。因此，$\\epsilon = 2^{-(p-1)}$。\n单位舍入误差为 $u = \\frac{1}{2}\\epsilon = \\frac{1}{2} \\times 2^{-(p-1)} = 2^{-p}$。\n\n- **binary32：** 精度 $p=24$，单位舍入误差为 $u_{32} = 2^{-24}$。\n- **binary64：** 精度 $p=53$，单位舍入误差为 $u_{64} = 2^{-53}$。\n\n**3. 乘法阈值**\n\n我们需要确定浮点乘法的阈值 $T_{\\mathrm{under}}$ 和 $T_{\\mathrm{over}}$。\n\n- **下溢阈值 $T_{\\mathrm{under}}$：** 问题定义 $T_{\\mathrm{under}}$ 为：如果 $|x| \\geq T_{\\mathrm{under}}$ 且 $|y| \\geq T_{\\mathrm{under}}$，则精确乘积 $|xy| \\geq SPN$。由于我们有 $|x||y| \\geq T_{\\mathrm{under}}^2$，我们必须强制 $T_{\\mathrm{under}}^2 \\geq SPN$。当等式成立时，达到最紧的此类阈值：\n$$T_{\\mathrm{under}}^2 = SPN \\implies T_{\\mathrm{under}} = \\sqrt{SPN}$$\n- **对于 binary32：** $T_{\\mathrm{under},32} = \\sqrt{SPN_{32}} = \\sqrt{2^{-126}} = 2^{-63}$。\n- **对于 binary64：** $T_{\\mathrm{under},64} = \\sqrt{SPN_{64}} = \\sqrt{2^{-1022}} = 2^{-511}$。\n\n- **上溢阈值 $T_{\\mathrm{over}}$：** 问题定义 $T_{\\mathrm{over}}$ 为：如果 $|x| \\leq T_{\\mathrm{over}}$ 且 $|y| \\leq T_{\\mathrm{over}}$，则精确乘积 $|xy| \\leq LFN$。由于我们有 $|x||y| \\leq T_{\\mathrm{over}}^2$，我们必须强制 $T_{\\mathrm{over}}^2 \\leq LFN$。当等式成立时，达到最大的此类阈值：\n$$T_{\\mathrm{over}}^2 = LFN \\implies T_{\\mathrm{over}} = \\sqrt{LFN}$$\n- **对于 binary32：** $T_{\\mathrm{over},32} = \\sqrt{LFN_{32}} = \\sqrt{(2-2^{-23}) \\times 2^{127}} = \\sqrt{2^{128} \\times (1-2^{-24})} = 2^{64}\\sqrt{1-2^{-24}}$。\n- **对于 binary64：** $T_{\\mathrm{over},64} = \\sqrt{LFN_{64}} = \\sqrt{(2-2^{-52}) \\times 2^{1023}} = \\sqrt{2^{1024} \\times (1-2^{-53})} = 2^{512}\\sqrt{1-2^{-53}}$。\n\n这些阈值为输入量级定义了一个范围 $[T_{\\mathrm{under}}, T_{\\mathrm{over}}]$。如果 $|x|$ 和 $|y|$ 都在此范围内，它们的乘积 $|xy|$ 将落在范围 $[SPN, LFN]$ 内，从而确保精确结果是一个有限的规格化数，并且标准舍入误差模型 $\\mathrm{fl}(xy)=xy(1+\\delta)$（其中 $|\\delta| \\leq u$）适用。\n\n**结果总结：**\n十二个所求值按指定顺序排列在一个单行矩阵中。\n1. binary32 $SPS$：$2^{-149}$\n2. binary32 $SPN$：$2^{-126}$\n3. binary32 $LFN$：$2^{128}-2^{104}$\n4. binary32 $u$：$2^{-24}$\n5. binary32 $T_{\\mathrm{under}}$：$2^{-63}$\n6. binary32 $T_{\\mathrm{over}}$：$2^{64}\\sqrt{1-2^{-24}}$\n7. binary64 $SPS$：$2^{-1074}$\n8. binary64 $SPN$：$2^{-1022}$\n9. binary64 $LFN$：$2^{1024}-2^{971}$\n10. binary64 $u$：$2^{-53}$\n11. binary64 $T_{\\mathrm{under}}$：$2^{-511}$\n12. binary64 $T_{\\mathrm{over}}$：$2^{512}\\sqrt{1-2^{-53}}$",
                "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{-149}  2^{-126}  2^{128}-2^{104}  2^{-24}  2^{-63}  2^{64}\\sqrt{1-2^{-24}}  2^{-1074}  2^{-1022}  2^{1024}-2^{971}  2^{-53}  2^{-511}  2^{512}\\sqrt{1-2^{-53}}\n\\end{pmatrix}\n}\n$$",
                "id": "3579628"
            },
            {
                "introduction": "理论知识只有在实践中得到验证才能变得鲜活。这个编程练习旨在通过一个具体的例子——数学恒等式 $\\sqrt{x \\cdot x} = \\lvert x \\rvert$——来展示前一个练习中探讨的理论边界（如上溢和下溢）是如何在实际代码中导致预期之外的结果。通过精心设计一组测试用例，你将亲眼见证并理解为何在有限精度算术中，我们不能理所当然地认为数学公理永远成立。[@problem_id:3276013]",
                "problem": "设计并实现一个程序，通过实验证明，在符合电气和电子工程师协会（IEEE）$754$ binary$64$（双精度）标准的有限精度算术中，恒等式 $\\sqrt{x \\cdot x} = \\lvert x \\rvert$ 并不对所有可表示的 $x$ 都成立。你的程序必须只使用运行时提供的双精度浮点运算，并且不得模拟更高的精度。\n\n使用以下基本原理来指导你的推理和实现：浮点算术使用固定的精度和有界的指数范围来近似表示实数；基本运算会舍入到最近的可表示值（采用“向最近舍入，偶数优先”规则），其中溢出（overflow）会映射到 $\\pm \\infty$，而下溢（underflow）可能产生非规格化数（subnormal numbers）或零。这些是 IEEE $754$ binary$64$ 算术的标准、经过充分测试的特性。\n\n任务说明：\n- 对于每个测试值 $x$，使用平台的双精度算术计算 $y = \\sqrt{x \\cdot x}$ 和 $z = \\lvert x \\rvert$。对于每种情况，使用该语言针对双精度浮点数的精确相等运算符，记录一个布尔值，以指示 $y$ 和 $z$ 在浮点层面上是否按位相等。\n- 构建测试套件，使其覆盖典型数值大小、溢出和下溢的情况。为 binary$64$ 定义以下机器参数：\n  - $M$：可表示的最大有限正数（maximum finite）。\n  - $m$：可表示的最小正规格化数（minimum positive normal）。\n  - $\\varepsilon$：$1$ 与下一个更大的可表示数之间的距离（$1$ 附近的单位舍入误差）。\n  - $s = m \\cdot \\varepsilon$：可表示的最小正非规格化数。\n  - $T_{\\text{overflow}} = \\sqrt{M}$。\n  - $T_{\\text{zero}} = \\sqrt{s}$。\n  - $\\operatorname{nextafter}(a, b)$：在 $b$ 的方向上与 $a$ 相邻的可表示数。\n- 仅使用双精度算术和上述参数，构建以下 $x$ 值的测试套件：\n  1. $x_1 = 1.234567890123456$。\n  2. $x_2 = -98765.4321$。\n  3. $x_3 = 0$。\n  4. $x_4 = 2^{600}$。\n  5. $x_5 = -2^{600}$。\n  6. $x_6 = 2^{-600}$。\n  7. $x_7 = -2^{-600}$。\n  8. $x_8 = \\operatorname{nextafter}(T_{\\text{overflow}}, 0)$。\n  9. $x_9 = \\operatorname{nextafter}(T_{\\text{overflow}}, +\\infty)$。\n  10. $x_{10} = \\operatorname{nextafter}(T_{\\text{zero}}, 0)$。\n  11. $x_{11} = \\operatorname{nextafter}(T_{\\text{zero}}, +\\infty)$。\n- 你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与测试用例 $x_1$ 到 $x_{11}$ 一致。每个列表元素必须是一个布尔值，表示在精确浮点相等性下 $\\sqrt{x \\cdot x}$ 是否等于 $\\lvert x \\rvert$。例如，输出形式为 $[b_1,b_2,\\dots,b_{11}]$，其中每个 $b_i$ 为 true 或 false。\n\n注意事项和要求：\n- 所有计算必须在双精度（IEEE $754$ binary$64$）下进行。\n- 不涉及物理单位。\n- 不涉及角度。\n- 最终输出必须是指定列表格式的单行文本。",
                "solution": "该问题陈述是有效的。它提出了一个定义明确且具有科学依据的研究，探讨了有限精度算术的局限性，这是数值分析和科学计算中的一个基本课题。该问题是自洽的，其术语定义严谨，并且要求的计算在指定的 IEEE $754$ binary$64$ 环境下是可行的。\n\n数学恒等式 $\\sqrt{x \\cdot x} = \\lvert x \\rvert$ 对于所有实数 $x \\in \\mathbb{R}$ 都是一个公理。然而，计算机算术并非在实数域 $\\mathbb{R}$ 上运行，而是在一个有理数的有限子集上运行，这些数可表示为浮点值。用于双精度浮点数的 IEEE $754$ binary$64$ 标准对这些值的范围和精度都施加了严格的限制。这些限制是理想数学恒等式与其计算评估之间出现差异的根源。当中间计算 $x \\cdot x$ 导致溢出或下溢时，该恒等式恰好会失效。\n\n在 IEEE $754$ binary$64$ 格式中，一个数由一个符号位、一个 $11$ 位指数和一个 $52$ 位有效数（尾数）表示。这种结构定义了该系统的关键特性：\n- 最大有限正数，$M \\approx 1.797 \\times 10^{308}$。任何大于 $M$ 的结果都会溢出为正无穷大 ($+\\infty$)。\n- 最小正规格化数，$m \\approx 2.225 \\times 10^{-308}$，对应于最小规格化指数 $-1022$。\n- 最小正非规格化数，$s \\approx 4.94 \\times 10^{-324}$。任何量级小于 $s$ 且无法表示为非规格化数的结果都会下溢并被刷新为 $0$。问题正确地将 $s$ 定义为 $s = m \\cdot \\varepsilon$，其中 $\\varepsilon$ 是机器 epsilon，因为 $m=2^{-1022}$ 且 $\\varepsilon=2^{-52}$，得出 $s=2^{-1074}$。\n\n该测试套件旨在探究这些极限。我们将分析每种情况，以预测 `sqrt(x*x) == abs(x)` 的计算评估将产生真（true）还是假（false）。\n\n1.  **情况 $x_1, x_2, x_3$（行为良好的值）：**\n    - 对于 $x_1 = 1.234567890123456$ 和 $x_2 = -98765.4321$， $x$ 和 $x \\cdot x$ 的值都在规格化浮点数的范围内。虽然乘积 $x \\cdot x$ 可能需要超过 $53$ 位的精度并因此产生舍入误差，但现代浮点单元，特别是 `sqrt` 函数，被规定为高度精确的（正确舍入）。对于大多数行为良好的输入，这些运算的组合预期在数值上是稳定的，并能恢复原始的量级。该恒等式将成立。\n    - 对于 $x_3 = 0$，该恒等式显然为真：$\\sqrt{0.0 \\cdot 0.0} = \\sqrt{0.0} = 0.0$，且 $\\lvert 0.0 \\rvert = 0.0$。\n\n2.  **情况 $x_4, x_5, x_9$（溢出）：**\n    - 乘法中溢出的阈值是 $x$ 满足 $\\lvert x \\rvert > \\sqrt{M}$。值 $T_{\\text{overflow}} = \\sqrt{M} \\approx 1.34 \\times 10^{154}$。\n    - 对于 $x_4 = 2^{600}$ 和 $x_5 = -2^{600}$，其量级为 $\\lvert x \\rvert = 2^{600}$。中间乘积为 $(2^{600})^2 = 2^{1200}$。binary$64$ 数的最大指数是 $1023$。由于 $1200 > 1023$，乘积 $x \\cdot x$ 将溢出为 $+\\infty$。随后的运算 $\\sqrt{+\\infty}$ 返回 $+\\infty$。由于 $x$ 是一个有限数，因此 $+\\infty \\ne \\lvert x \\rvert$。该恒等式将失效。\n    - 对于 $x_9 = \\operatorname{nextafter}(T_{\\text{overflow}}, +\\infty)$，根据定义，$x_9$ 的值是严格大于 $T_{\\text{overflow}}$ 的最小可表示数。因此，$x_9^2 > M$，导致 $x_9 \\cdot x_9$ 溢出为 $+\\infty$。如前所述，结果 $\\sqrt{+\\infty} = +\\infty$ 不等于有限值 $\\lvert x_9 \\rvert$。该恒等式将失效。\n\n3.  **情况 $x_6, x_7, x_{10}$（下溢）：**\n    - 乘法中下溢的阈值与最小正非规格化数 $s = 2^{-1074}$ 有关。如果 $x \\cdot x$ 产生的结果小于 $0$ 和 $s$ 之间的中点（即 $ s/2$），它将被刷新为 $0$。这发生在 $\\lvert x \\rvert  \\sqrt{s/2}$ 时。我们定义 $T_{\\text{zero}} = \\sqrt{s} = \\sqrt{2^{-1074}} = 2^{-537}$。\n    - 对于 $x_6 = 2^{-600}$ 和 $x_7 = -2^{-600}$，其量级为 $\\lvert x \\rvert = 2^{-600}$。中间乘积为 $(2^{-600})^2 = 2^{-1200}$。可表示的最小（非规格化）正数的有效指数为 $-1074$。由于 $-1200  -1074$， $x \\cdot x$ 的结果太小而无法表示，并下溢为 $0.0$。然后 $\\sqrt{0.0} = 0.0$，这不等于原始的非零量级 $2^{-600}$。该恒等式将失效。\n    - 对于 $x_{10} = \\operatorname{nextafter}(T_{\\text{zero}}, 0)$，$x_{10}$ 的值严格小于 $T_{\\text{zero}}$。因此，$x_{10}^2  T_{\\text{zero}}^2 = s$。这个乘积 $x_{10} \\cdot x_{10}$ 落入其下溢为 $0.0$ 的范围内。结果 $\\sqrt{0.0} = 0.0$ 不等于非零值 $\\lvert x_{10} \\rvert$。该恒等式将失效。\n\n4.  **情况 $x_8, x_{11}$（边界邻近值）：**\n    - 对于 $x_8 = \\operatorname{nextafter}(T_{\\text{overflow}}, 0)$，该值是严格小于 $T_{\\text{overflow}}$ 的最大可表示数。因此，$x_8^2  M$，所以乘积 $x_8 \\cdot x_8$ 不会溢出，并将得到一个接近 $M$ 的有限数。随后的正确舍入的平方根运算预计将精确地逆转平方运算，所以 $\\sqrt{x_8 \\cdot x_8}$ 将等于 $\\lvert x_8 \\rvert$。该恒等式将成立。\n    - 对于 $x_{11} = \\operatorname{nextafter}(T_{\\text{zero}}, +\\infty)$，该值严格大于 $T_{\\text{zero}} = \\sqrt{s}$。乘积 $x_{11}^2 > s$。这个结果足够大，可以表示为一个非零（非规格化）数。这个非规格化数的平方根是良好定义的，并且预计会以足够的精度计算以恢复原始值 $\\lvert x_{11} \\rvert$。该恒等式将成立。\n\n因此，实验演示将表明，该恒等式在情况 $x_4, x_5, x_6, x_7, x_9, x_{10}$ 下会失效，而在其余情况下成立。这证实了这些失败是有限精度算术中溢出和下溢的可预测后果。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Empirically demonstrates the failure of the identity sqrt(x*x) = abs(x)\n    in IEEE 754 double-precision arithmetic due to overflow and underflow.\n    \"\"\"\n    \n    # Define machine parameters for binary64 (double precision) using numpy.finfo.\n    finfo = np.finfo(np.float64)\n    M = finfo.max          # Largest finite positive number\n    m = finfo.tiny         # Smallest positive normal number\n    eps = finfo.eps        # Machine epsilon\n    \n    # Per the problem statement, s is the smallest positive subnormal number.\n    # np.finfo.smallest_subnormal provides this directly.\n    # The problem's formula s = m * eps is also correct for binary64.\n    # Let's verify: m = 2**-1022, eps = 2**-52, so m*eps = 2**-1074.\n    # np.finfo.smallest_subnormal is also 2**-1074.\n    s = finfo.smallest_subnormal\n\n    # Define thresholds based on the machine parameters.\n    # T_overflow is the threshold for x above which x*x overflows.\n    T_overflow = np.sqrt(M)\n    \n    # T_zero is the threshold for x below which x*x may underflow to zero.\n    T_zero = np.sqrt(s)\n\n    # Build the test suite of values for x.\n    test_suite = [\n        1.234567890123456,                          # x1: Normal number\n        -98765.4321,                                # x2: Normal negative number\n        0.0,                                        # x3: Zero\n        2.0**600,                                   # x4: Large number causing overflow in x*x\n        -2.0**600,                                  # x5: Large negative number causing overflow in x*x\n        2.0**-600,                                  # x6: Small number causing underflow in x*x\n        -2.0**-600,                                 # x7: Small negative number causing underflow in x*x\n        np.nextafter(T_overflow, 0),                # x8: Value just below overflow threshold\n        np.nextafter(T_overflow, np.inf),           # x9: Value just above overflow threshold\n        np.nextafter(T_zero, 0),                    # x10: Value just below underflow-to-zero threshold\n        np.nextafter(T_zero, np.inf)                # x11: Value just above underflow-to-zero threshold\n    ]\n\n    results = []\n    for x in test_suite:\n        # Perform the computations in double precision.\n        # y = sqrt(x * x)\n        y = np.sqrt(x * x)\n        \n        # z = |x|\n        z = np.abs(x)\n        \n        # Record a Boolean indicating whether y and z are bitwise equal.\n        # The '==' operator on numpy floats performs this exact comparison.\n        # The result string must be lowercase 'true' or 'false'.\n        is_equal = (y == z)\n        results.append(str(is_equal).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```",
                "id": "3276013"
            },
            {
                "introduction": "计算误差的来源不仅限于浮点表示的固有局限性，还包括我们用来处理这些计算的工具，例如编译器。本练习将模拟“积极”编译器优化（如 `-ffast-math` 标志）的行为，以揭示其如何通过牺牲严格的 IEEE 754 合规性来换取速度，从而引入数值差异。通过对比严格与积极两种语义下的计算结果，你将学会识别和诊断由算法重排、对特殊值（如 NaN 和带符号零）的处理不当等引起的微妙错误。[@problem_id:3276009]",
                "problem": "您需要编写一个完整的程序，通过精心选择的数值示例，展示当一个实现做出类似于常见编译器标志（如 `-ffast-math`）所启用的激进浮点假设时，浮点计算结果会如何变化。本主题是关于数值方法和科学计算中计算误差的来源。目标是使这些差异系统化、可复现，并可归因于有限精度的基本原理。\n\n从以下基本基础开始：\n- 电气与电子工程师协会（IEEE）754 标准定义了浮点格式和语义。在 binary64 中，每个操作都如同以无限精度执行，然后舍入到最近的可表示数，我们用舍入运算符 $\\mathrm{fl}(\\cdot)$ 表示。对于一个基本运算 $\\circ\\in\\{+,-,\\times,\\div\\}$，计算出的结果满足 $\\mathrm{fl}(x\\circ y)=(x\\circ y)(1+\\delta)$，其中 $|\\delta|\\le u$，$u$ 是单位舍入。这些运算在浮点算术中不满足结合律，因此 $\\mathrm{fl}((x+y)+z)$ 不必等于 $\\mathrm{fl}(x+(y+z))$。\n- IEEE 754 还规定了特殊值：非数值（NaN）、$+\\infty$、$-\\infty$、带符号的零 ${+}0$ 和 ${-}0$，以及次规范数。NaN 在大多数运算中会传播。除以 ${-}0$ 会产生带符号的无穷大。次规范数填补了下溢间隙，但在某些系统上为了速度可能会被刷写为零。\n\n您必须为一组固定的表达式实现两种求值语义：\n- 严格语义：模拟 IEEE 754 binary64 的行为，保留指定的操作顺序、NaN 传播、带符号的零和次规范数。\n- 激进语义：模拟一组在激进优化下通常允许的不安全假设，即：\n  - 在方便时对加法进行重组结合，包括在归约中对正项和负项进行分组。\n  - 在每次运算前，将每个 ${-}0$ 视为 ${+}0$（忽略零的符号）。\n  - 在每一步都将次规范的输入和结果刷写为 $0$，即，将任何满足 $0|x|\\tau$ 的 $x$ 映射为 $0$，其中 $\\tau$ 是 binary64 中最小的正规范数。\n  - 在每次运算前，将任何 NaN 输入视为 $0$（无 NaN 传播）。\n  - 当两个操作数按位相等且为有限数时，无论是否存在异常情况，都应用代数恒等式 $x/x=1$。\n\n您的程序必须评估以下测试套件。每个测试都定义了在两种语义下要计算的数据和表达式。不涉及角度。没有物理单位。\n\n- 测试 $1$（加法的非结合性）：使用 $x=10^{16}$, $y=-10^{16}$, $z=1$。在严格语义下，计算 $((x+y)+z)$。在激进语义下，使用上述分步激进规则计算 $x+(y+z)$。\n- 测试 $2$（除法中的带符号零）：使用 $a=1.0$, $b=-0.0$。在两种语义下计算 $a/b$。\n- 测试 $3$（通过 $x/x=1$ 进行 NaN 折叠）：使用 $a=0.0$。在两种语义下计算 $(a/a)-1$。\n- 测试 $4$（求和中的次规范数刷写）：令 $s=\\mathrm{nextafter}(0,1)$ 为 binary64 中最小的正次规范数，且 $N=1000$。在严格语义下，从左到右计算总和 $\\sum_{k=1}^{N} s$。在激进语义下，在每次加法时应用分步刷写和带符号零规则。\n- 测试 $5$（归约重排序）：令 $N=200000$。考虑交错调和部分和 $S_{N}=\\sum_{k=1}^{N}(-1)^{k+1}\\frac{1}{k}$。在严格语义下，按索引顺序从左到右求和。在激进语义下，首先对所有正项求和，然后对所有负项求和，最后将两个部分和相加，并应用分步激进规则。\n\n对于每个测试 $i\\in\\{1,2,3,4,5\\}$，定义一个布尔结果 $B_i$，当且仅当两种语义在数值上可观察的意义上表现不同时，该结果为真，即：\n- 一个结果是 NaN 而另一个不是；或\n- 两者都是无穷大但符号不同；或\n- 两者都是有限数但值不完全相等；或\n- 两者在数值上比较相等，但一个是 ${+}0$ 而另一个是 ${-}0$。\n\n您的程序必须产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[B_1,B_2,B_3,B_4,B_5]$。\n\n约束和指南：\n- 使用 binary64 算术。在 Python 中，您可以依赖于遵循 IEEE 754 的数值库提供的默认双精度浮点数和运算。\n- 确保激进语义是通过代码中的显式转换实现的，而不是依赖于解释器设置。\n- 最终输出必须是可复现的，无需任何外部输入。\n- 您的程序不得读取任何输入，并且除了最终的单行输出外，不得打印任何其他内容。",
                "solution": "该问题要求实现两种不同的浮点求值语义，“严格”语义和“激进”语义，以展示不安全的编译器优化如何改变数值结果。问题的有效性建立如下：\n\n- **科学或事实的健全性**：该问题在根本上是健全的。它基于公认的 IEEE 754 浮点算术标准，并探讨了与该标准相关的常见（尽管不安全）的优化。非结合性、带符号的零、NaN 传播、次规范数和灾难性抵消等概念都是数值分析的核心主题。\n- **适定性**：该问题是适定的。五个测试中的每一个都为两种语义定义了具体的数据、表达式和求值规则。比较结果的标准是精确的，确保每个测试都有一个唯一的布尔结果 ($B_i$)。\n- **完整性和一致性**：问题陈述是自洽的。它为严格和激进语义提供了所有必要的定义，为测试用例提供了所有数据，并规定了确切的输出格式。没有相互矛盾的约束。\n\n因此，该问题被认为是有效的。下面是每个测试用例的逐步分析和解决方案。我们使用 binary64 浮点算术，其单位舍入为 $u = 2^{-53}$。最小的正规范数是 $\\tau = 2^{-1022}$。$\\mathrm{fl}(\\cdot)$ 表示舍入到最近的可表示数的操作。\n\n### 测试 1：加法的非结合性\n- **数据**：$x = 10^{16}$，$y = -10^{16}$，$z = 1$。\n- **严格语义**：表达式按指定方式计算：$\\mathrm{fl}(\\mathrm{fl}(x+y)+z)$。内部操作是 $\\mathrm{fl}(x+y) = \\mathrm{fl}(10^{16} - 10^{16}) = 0$。然后外部操作是 $\\mathrm{fl}(0+z) = \\mathrm{fl}(0+1) = 1$。严格语义的结果是 $1.0$。\n- **激进语义**：表达式被重组为 $\\mathrm{fl}(x + \\mathrm{fl}(y+z))$。内部操作是 $\\mathrm{fl}(y+z) = \\mathrm{fl}(-10^{16} + 1)$。在 binary64 中，$y$ 和 $z$ 之间指数的差异过大，导致加法无法影响 $y$。由于 $|z/y| = 10^{-16} > u \\approx 1.11 \\times 10^{-16}$，加 1 的操作会因吸收（淹没）而丢失。因此，$\\mathrm{fl}(-10^{16} + 1) = -10^{16}$。然后外部操作是 $\\mathrm{fl}(x - 10^{16}) = \\mathrm{fl}(10^{16} - 10^{16}) = 0$。激进语义的结果是 $0.0$。\n- **结果**：结果 $1.0$ 和 $0.0$ 都是有限数且不完全相等。因此，$B_1$ 为真。\n\n### 测试 2：除法中的带符号零\n- **数据**：$a = 1.0$，$b = -0.0$。\n- **严格语义**：表达式为 $\\mathrm{fl}(a/b)$。根据 IEEE 754，一个正数除以一个负零会得到负无穷大。$\\mathrm{fl}(1.0 / -0.0) = -\\infty$。\n- **激进语义**：应用“在每次运算前将每个 $-0$ 视为 $+0$”的规则。操作数 $b = -0.0$ 在除法前被转换为 $+0.0$。表达式变为 $\\mathrm{fl}(1.0 / +0.0)$，得到正无穷大：$+\\infty$。\n- **结果**：结果是 $-\\infty$ 和 $+\\infty$。两者都是无穷大但符号不同。因此，$B_2$ 为真。\n\n### 测试 3：通过 $x/x=1$ 进行 NaN 折叠\n- **数据**：$a = 0.0$。\n- **严格语义**：表达式为 $\\mathrm{fl}(\\mathrm{fl}(a/a)-1)$。除法 $\\mathrm{fl}(0.0/0.0)$ 在 IEEE 754 下是无效操作，并正确地产生一个非数值（NaN）。随后的操作 $\\mathrm{fl}(\\mathrm{NaN} - 1)$ 会传播 NaN。严格语义的结果是 NaN。\n- **激进语义**：应用“当两个操作数按位相等且为有限数时，应用代数恒等式 $x/x=1$”的规则。在子表达式 $a/a$ 中，操作数 $a=0.0$ 是有限的且与其自身按位相等。该子表达式计算结果为 $1.0$ 而不是 NaN。完整的表达式则变为 $\\mathrm{fl}(1.0 - 1.0) = 0.0$。\n- **结果**：一个结果是 NaN，另一个不是。因此，$B_3$ 为真。\n\n### 测试 4：求和中的次规范数刷写\n- **数据**：$s$ 是 binary64 中最小的正次规范数（$s = 2^{-1074}$），$N=1000$。\n- **严格语义**：表达式是从左到右求和 $\\sum_{k=1}^{N} s$。该和计算为 $N \\times s = 1000 \\times 2^{-1074}$。这个结果是一个非零值，其本身也是一个次规范数，因为 $1000 \\times 2^{-1074}  \\tau = 2^{-1022}$。\n- **激进语义**：在每一步都应用“将次规范的输入和结果刷写为 $0$”的规则。在求和的每次加法中，项 $s$ 是一个次规范输入，并被刷写为 $0.0$。求和变为 $\\sum_{k=1}^{N} 0.0$，结果恰好是 $0.0$。\n- **结果**：结果是一个非零的次规范数和 $0.0$。它们都是有限数且不完全相等。因此，$B_4$ 为真。\n\n### 测试 5：归约重排序\n- **数据**：交错调和部分和 $S_{N}=\\sum_{k=1}^{N}(-1)^{k+1}\\frac{1}{k}$，其中 $N=200000$。\n- **严格语义**：按从左到右的顺序计算总和：$1 - 1/2 + 1/3 - 1/4 + \\dots$。对于项的绝对值递减的交错级数，这种求和顺序在数值上是稳定的。结果将是级数极限 $\\ln(2) \\approx 0.69314718$ 的一个精确近似。\n- **激进语义**：通过对正项和负项进行分组来重排序求和：$S_N = \\left(\\sum_{k \\text{ 为奇数}} \\frac{1}{k}\\right) + \\left(\\sum_{k \\text{ 为偶数}} \\frac{-1}{k}\\right)$。令 $P = \\sum_{j=1}^{N/2} \\frac{1}{2j-1}$ 且 $M = \\sum_{j=1}^{N/2} \\frac{-1}{2j}$。对于大的 $N$， $P$ 和 $M$ 的绝对值都会变得很大。$P \\approx \\frac{1}{2}\\ln(N)$ 且 $M \\approx -\\frac{1}{2}\\ln(N)$。计算 $S_N = \\mathrm{fl}(P+M)$ 涉及将两个符号相反、大小几乎相等的巨大数相加。这是灾难性抵消的典型案例，其中大部分有效数字会丢失。激进语义结果的精度将远低于严格语义结果的精度。\n- **结果**：两个有限结果一个稳定、精确的近似值，另一个是遭受灾难性抵消的不精确值。它们不会完全相等。因此，$B_5$ 为真。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Demonstrates differences between strict and aggressive floating-point semantics.\n    \"\"\"\n\n    # --- Comparison Helper ---\n    def are_different(res_s, res_a):\n        \"\"\"\n        Determines if two results are observably different based on problem criteria.\n        \"\"\"\n        # Case 1: One is NaN and the other is not.\n        if np.isnan(res_s) != np.isnan(res_a):\n            return True\n        # Case 2: Both are infinite with different signs.\n        if np.isinf(res_s) and np.isinf(res_a) and res_s != res_a:\n            return True\n        # Case 3: Both are finite but not equal.\n        if np.isfinite(res_s) and np.isfinite(res_a) and res_s != res_a:\n            return True\n        # Case 4: Both are zero but with different signs.\n        if res_s == 0.0 and res_a == 0.0 and np.signbit(res_s) != np.signbit(res_a):\n            return True\n        return False\n\n    # --- Aggressive Semantics Helper ---\n    TAU = np.finfo(np.float64).tiny # Minimal positive normal number\n\n    def aggressive_transform(x):\n        \"\"\"\n        Applies a set of aggressive transformations to a single float value.\n        \"\"\"\n        val = np.float64(x)\n        # Rule: Treat any NaN input as 0\n        if np.isnan(val):\n            return np.float64(0.0)\n        # Rule: Treat every -0 as +0\n        if val == 0.0 and np.signbit(val):\n            val = np.float64(0.0)\n        # Rule: Flush subnormal inputs and results to 0\n        if 0  np.abs(val)  TAU:\n            return np.float64(0.0)\n        return val\n\n    results = []\n\n    # --- Test 1: Non-associativity in addition ---\n    x, y, z = np.float64(1e16), np.float64(-1e16), np.float64(1.0)\n    # Strict\n    res1_s = (x + y) + z\n    # Aggressive\n    inner_sum = aggressive_transform(y) + aggressive_transform(z)\n    res1_a = aggressive_transform(x) + aggressive_transform(inner_sum)\n    results.append(are_different(res1_s, res1_a))\n\n    # --- Test 2: Signed zero in division ---\n    a, b = np.float64(1.0), np.copysign(np.float64(0.0), -1.0) # -0.0\n    # Strict\n    res2_s = a / b\n    # Aggressive\n    res2_a = aggressive_transform(a) / aggressive_transform(b)\n    results.append(are_different(res2_s, res2_a))\n\n    # --- Test 3: NaN folding via x/x=1 ---\n    a = np.float64(0.0)\n    # Strict\n    res3_s = (a / a) - 1.0\n    # Aggressive: special rule x/x=1 for finite x\n    term1_a = np.float64(1.0) # a/a -> 1.0\n    res3_a = aggressive_transform(term1_a) - aggressive_transform(1.0)\n    results.append(are_different(res3_s, res3_a))\n    \n    # --- Test 4: Subnormal flushing in a sum ---\n    s = np.nextafter(np.float64(0), np.float64(1)) # Minimal positive subnormal\n    N = 1000\n    # Strict\n    total_s = np.float64(0.0)\n    for _ in range(N):\n        total_s += s\n    res4_s = total_s\n    # Aggressive\n    total_a = aggressive_transform(0.0)\n    term_a = aggressive_transform(s) # flushes s to 0.0\n    for _ in range(N):\n        total_a += term_a\n        total_a = aggressive_transform(total_a)\n    res4_a = total_a\n    results.append(are_different(res4_s, res4_a))\n\n    # --- Test 5: Reduction reordering ---\n    N = 200000\n    # Strict: left-to-right summation\n    total_s = np.float64(0.0)\n    for k in range(1, N + 1):\n        total_s += ((-1)**(k + 1)) / k\n    res5_s = total_s\n    # Aggressive: sum positives, then negatives\n    pos_sum = np.float64(0.0)\n    for k in range(1, N + 1, 2):\n        pos_sum += 1.0 / k\n    \n    neg_sum = np.float64(0.0)\n    for k in range(2, N + 1, 2):\n        neg_sum += -1.0 / k\n    \n    # Per the problem description, stepwise rules are applied. For this test,\n    # reassociation is the key rule. The other aggressive transforms (NaN, subnormal)\n    # do not trigger on these terms.\n    res5_a = pos_sum + neg_sum\n    results.append(are_different(res5_s, res5_a))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```",
                "id": "3276009"
            }
        ]
    }