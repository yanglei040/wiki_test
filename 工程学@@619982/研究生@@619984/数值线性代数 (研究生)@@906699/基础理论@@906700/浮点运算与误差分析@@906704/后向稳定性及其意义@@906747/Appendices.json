{
        "hands_on_practices": [
            {
                "introduction": "在数值线性代数中，即使是最基本的操作（如点积）也可能受到浮点误差的显著影响。这个练习旨在阐明一个核心原则：计算方式与计算内容同等重要。通过从第一性原理出发，推导和比较朴素求和、成对求和以及补偿求和这三种不同算法的后向误差界，你将亲手量化算法设计对数值稳定性的直接影响 [@problem_id:3533794]。",
                "problem": "考虑给定向量的点积 $s = x^{\\top} y$\n$$\nx = \\begin{pmatrix}\n2^{10}  -3.7  5.1  -8.2  1.3  -0.75  9.9  -4.0\n\\end{pmatrix}^{\\top}, \\quad\ny = \\begin{pmatrix}\n1.0  2.5  -3.1  4.2  -5.3  6.4  -7.5  8.6\n\\end{pmatrix}^{\\top}.\n$$\n假设算术运算在电气和电子工程师协会 (IEEE) 754 binary64 (双精度) 模型中执行，采用舍入到最近值的方式，因此单位舍入误差为 $u = 2^{-53}$。对于每个基本运算 $\\mathrm{op} \\in \\{+, -, \\times\\}$，使用标准浮点模型 $\\,\\mathrm{fl}(a \\,\\mathrm{op}\\, b) = (a \\,\\mathrm{op}\\, b)(1 + \\delta)$，其中 $|\\delta| \\le u$。\n\n定义三种计算 $s$ 的近似值 $\\widehat{s}$ 的算法：\n- 算法 A (朴素算法): 对 $i = 1,\\dots,n$ 计算 $s_i = \\mathrm{fl}(x_i \\times y_i)$，然后从左到右累加 $\\widehat{s} = \\mathrm{fl}(\\cdots \\mathrm{fl}(\\mathrm{fl}(s_1 + s_2) + s_3) + \\cdots + s_n)$。\n- 算法 B (成对求和): 对 $i = 1,\\dots,n$ 计算 $s_i = \\mathrm{fl}(x_i \\times y_i)$，然后在一个平衡二叉树中，在每个内部节点使用 $\\mathrm{fl}(\\cdot + \\cdot)$ 对 $\\{s_i\\}$ 进行成对求和。\n- 算法 C (补偿/Kahan求和): 对 $i = 1,\\dots,n$ 计算 $s_i = \\mathrm{fl}(x_i \\times y_i)$，然后应用补偿求和循环\n  $\n  c \\leftarrow 0,\\; \\widehat{s} \\leftarrow 0,\\; \\text{for } i=1{:}n:\\; y' \\leftarrow \\mathrm{fl}(s_i - c),\\; t \\leftarrow \\mathrm{fl}(\\widehat{s} + y'),\\; c \\leftarrow \\mathrm{fl}(\\mathrm{fl}(t - \\widehat{s}) - y'),\\; \\widehat{s} \\leftarrow t.\n  $\n\n令 $n$ 表示向量长度，这里 $n = 8$。对于每种算法，从浮点模型的第一性原理出发，推导一个分量形式的后向误差界，形式如下：存在一个扰动 $\\Delta x$ 使得\n$$\n\\widehat{s} = (x + \\Delta x)^{\\top} y, \\quad |\\Delta x| \\le \\theta_{\\mathrm{alg}} |x|\n$$\n(分量形式的不等式)，并获得 $\\theta_{\\mathrm{alg}}$ 作为一个关于 $u$ 和 $n$ (以及算法特定结构) 的函数的可计算显式上界。然后对 $u = 2^{-53}$ 和 $n = 8$ 对这些界进行数值计算。\n\n将最终结果以行矩阵的形式报告，其中包含三个数值\n$$\n\\theta_{\\mathrm{naive}},\\; \\theta_{\\mathrm{pairwise}},\\; \\theta_{\\mathrm{comp}}\n$$\n按此顺序排列，并四舍五入到四位有效数字。不需要单位。",
                "solution": "所述问题是浮点算法后向误差分析中的一个有效练习。它在科学上基于标准的浮点算术模型，问题定义明确，提供了所有必要数据，并且表达客观。因此，将提供一个解答。\n\n目标是为三种不同的点积算法找到一个界 $\\theta_{\\mathrm{alg}}$，使得计算结果 $\\widehat{s}$ 是扰动向量 $x+\\Delta x$ 与原始向量 $y$ 的精确点积。即，\n$$ \\widehat{s} = (x + \\Delta x)^{\\top} y $$\n其分量形式的后向误差满足 $|\\Delta x| \\le \\theta_{\\mathrm{alg}} |x|$。这等价于找到一个界 $\\theta_{\\mathrm{alg}}$，使得对于每个分量 $i=1, \\dots, n$：\n$$ |\\Delta x_i| \\le \\theta_{\\mathrm{alg}} |x_i| $$\n计算得到的和 $\\widehat{s}$ 通常可以表示为精确乘积 $x_i y_i$ 与某个乘性误差的和，即 $\\widehat{s} = \\sum_{i=1}^n x_i y_i (1+\\zeta_i)$。将其与期望的后向误差形式相等，可得：\n$$ \\sum_{i=1}^n (x_i + \\Delta x_i) y_i = \\sum_{i=1}^n x_i y_i (1 + \\zeta_i) $$\n$$ \\sum_{i=1}^n \\Delta x_i y_i = \\sum_{i=1}^n x_i y_i \\zeta_i $$\n这个等式必须对任意向量 $y$ 成立。这意味着对于每个 $i$，我们必须有 $\\Delta x_i y_i = x_i y_i \\zeta_i$，这可以简化为 $\\Delta x_i = x_i \\zeta_i$。因此，条件 $|\\Delta x| \\le \\theta_{\\mathrm{alg}} |x|$ 变为 $|x_i \\zeta_i| \\le \\theta_{\\mathrm{alg}} |x_i|$，这意味着我们需要找到一个对所有 $i=1, \\dots, n$ 成立的统一界 $\\theta_{\\mathrm{alg}} \\ge |\\zeta_i|$。\n\n我们使用标准浮点模型，其中对于任何基本运算 $\\mathrm{op}$，$\\mathrm{fl}(a \\ \\mathrm{op} \\ b) = (a \\ \\mathrm{op} \\ b)(1+\\delta)$，其中 $|\\delta| \\le u$。$k$ 个此类因子的乘积满足 $\\prod_{j=1}^k (1+\\delta_j) = 1+\\eta_k$，其中 $|\\eta_k| \\le \\gamma_k = \\frac{ku}{1-ku}$，假设 $ku  1$。\n\n对于所有三种算法，第一步是计算乘积 $s_i = \\mathrm{fl}(x_i y_i)$。\n$$ s_i = x_i y_i (1+\\delta'_i), \\quad |\\delta'_i| \\le u $$\n剩下的分析关注这些乘积 $\\{s_i\\}$ 是如何求和的。\n\n**算法 A：朴素求和**\n在朴素的从左到右求和中，计算出的和 $\\widehat{s}$ 具有以下形式\n$$ \\widehat{s} = \\mathrm{fl}(\\cdots \\mathrm{fl}(\\mathrm{fl}(s_1 + s_2) + s_3) + \\cdots + s_n) $$\n对舍入误差传播的详细分析表明，这可以写成：\n$$ \\widehat{s} = s_1 \\prod_{k=2}^n(1+\\delta_k) + s_2 \\prod_{k=2}^n(1+\\delta_k) + s_3 \\prod_{k=3}^n(1+\\delta_k) + \\dots + s_n(1+\\delta_n) $$\n其中每个 $|\\delta_k| \\le u$。\n代入 $s_i = x_i y_i (1+\\delta'_i)$，总和中 $x_i y_i$ 的项是 $x_i y_i (1+\\zeta_i)$，其中 $1+\\zeta_i$ 是 $(1+\\delta)$ 项的乘积。\n对于 $i=1$：$1+\\zeta_1 = (1+\\delta'_1) \\prod_{k=2}^n(1+\\delta_k)$。这是 $1+(n-1)=n$ 个扰动项的乘积。因此， $|\\zeta_1| \\le \\gamma_n$。\n对于 $i=2$：$1+\\zeta_2 = (1+\\delta'_2) \\prod_{k=2}^n(1+\\delta_k)$。这也是 $n$ 个扰动项的乘积。因此， $|\\zeta_2| \\le \\gamma_n$。\n对于 $i > 2$：$1+\\zeta_i = (1+\\delta'_i) \\prod_{k=i}^n(1+\\delta_k)$。这是 $1+(n-i+1) = n-i+2$ 个项的乘积。因此，$|\\zeta_i| \\le \\gamma_{n-i+2}$。\n这个界必须对所有 $i$ 成立。最坏的情况是 $i=1$ 和 $i=2$，这给出了统一界 $|\\zeta_i| \\le \\gamma_n$。因此，\n$$ \\theta_{\\mathrm{naive}} = \\gamma_n = \\frac{nu}{1-nu} $$\n\n**算法 B：成对求和**\n在成对求和中，对于 $n=8$（2的幂），求和在一个平衡二叉树中进行。任何单个项 $s_i$ 被包含到最终和中所经历的求和步骤数为 $\\log_2(n)$。\n计算值 $\\widehat{s}$ 可以写成 $\\sum_{i=1}^n x_i y_i (1+\\zeta_i)$。项 $1+\\zeta_i$ 对应于影响 $x_i y_i$ 的累积乘性误差。这包括来自乘法 $x_i y_i$ 的一个误差和来自求和树的 $\\log_2(n)$ 个误差。每个项 $x_i y_i$ 总共受到 $1+\\log_2(n)$ 次浮点运算的影响。因此，累积误差因子由 $\\gamma_{1+\\log_2(n)}$ 界定。这个界对所有 $i$ 都是统一的。\n$$ \\theta_{\\mathrm{pairwise}} = \\gamma_{1+\\log_2 n} = \\frac{(1+\\log_2 n)u}{1-(1+\\log_2 n)u} $$\n\n**算法 C：补偿 (Kahan) 求和**\n补偿求和使用一个校正项 $c$ 来跟踪主求和过程中的舍入误差。令 $\\widehat{s}$ 为项 $\\{s_i\\}$ 补偿求和的结果。来自详细误差分析（例如，Higham, 1993, \"The Accuracy of Floating Point Summation\"）的一个标准结果表明 $\\widehat{s} = \\sum_{i=1}^n s_i(1+\\mu_i)$，其中 $|\\mu_i| \\le 2u + O(nu^2)$。这个界反映了误差累积在很大程度上被阻止了。\n将此与初始乘法 $s_i = x_i y_i(1+\\delta'_i)$ 的误差结合起来，我们得到：\n$$ \\widehat{s} = \\sum_{i=1}^n x_i y_i (1+\\delta'_i)(1+\\mu_i) $$\n所以，$\\zeta_i = (1+\\delta'_i)(1+\\mu_i) - 1 = \\delta'_i + \\mu_i + \\delta'_i\\mu_i$。\n为了获得一个可计算的界，我们使用 $|\\delta'_i| \\le u$ 以及来自同一文献的对 $|\\mu_i|$ 的更明确的界，即 $|\\mu_i| \\le 2u + 2(n-i+1)u^2$。为了得到 $|\\zeta_i|$ 的统一界，我们取 $i$ 的最坏情况，即 $i=1$：$|\\mu_i| \\le 2u + 2nu^2$。\n$$ |\\zeta_i| \\le (1+u)(1 + 2u + 2nu^2) - 1 = 1+2u+2nu^2+u+2u^2+2nu^3 - 1 = 3u + 2(n+1)u^2 + 2nu^3 $$\n这给出了我们对补偿算法的界：\n$$ \\theta_{\\mathrm{comp}} = 3u + 2(n+1)u^2 + 2nu^3 $$\n对于小的 $u$，这个界大约是 $3u$，这表明其精度有了极大的提高，且在很大程度上与 $n$ 无关。\n\n**数值计算**\n我们已知 $u = 2^{-53}$ 和 $n = 8$。\n\n对于算法 A (朴素算法)：\n$$ \\theta_{\\mathrm{naive}} = \\frac{8u}{1-8u} = \\frac{8 \\times 2^{-53}}{1-8 \\times 2^{-53}} = \\frac{2^{-50}}{1-2^{-50}} \\approx 8.881784197 \\times 10^{-16} $$\n四舍五入到四位有效数字，结果为 $8.882 \\times 10^{-16}$。\n\n对于算法 B (成对求和)：\n当 $n=8$ 时，$\\log_2(n) = 3$。\n$$ \\theta_{\\mathrm{pairwise}} = \\frac{(1+3)u}{1-(1+3)u} = \\frac{4u}{1-4u} = \\frac{4 \\times 2^{-53}}{1-4 \\times 2^{-53}} = \\frac{2^{-51}}{1-2^{-51}} \\approx 4.440892099 \\times 10^{-16} $$\n四舍五入到四位有效数字，结果为 $4.441 \\times 10^{-16}$。\n\n对于算法 C (补偿求和)：\n$$ \\theta_{\\mathrm{comp}} = 3u + 2(8+1)u^2 + 2(8)u^3 = 3u + 18u^2 + 16u^3 $$\n$$ \\theta_{\\mathrm{comp}} = 3 \\times 2^{-53} + 18 \\times (2^{-53})^2 + 16 \\times (2^{-53})^3 = 3 \\times 2^{-53} + 18 \\times 2^{-106} + 16 \\times 2^{-159} $$\n$u^2$ 和 $u^3$ 的项比 $u$ 的项小几个数量级。\n第一项：$3 \\times 2^{-53} \\approx 3.330669074 \\times 10^{-16}$。\n第二项：$18 \\times 2^{-106} \\approx 2.21859... \\times 10^{-31}$。\n高阶项不影响前四位有效数字。\n$$ \\theta_{\\mathrm{comp}} \\approx 3u \\approx 3.330669074 \\times 10^{-16} $$\n四舍五入到四位有效数字，结果为 $3.331 \\times 10^{-16}$。\n\n最终报告的值是 $\\theta_{\\mathrm{naive}}$、$\\theta_{\\mathrm{pairwise}}$ 和 $\\theta_{\\mathrm{comp}}$ 的三个数值界。",
                "answer": "$$ \\boxed{ \\begin{pmatrix} 8.882 \\times 10^{-16}  4.441 \\times 10^{-16}  3.331 \\times 10^{-16} \\end{pmatrix} } $$",
                "id": "3533794"
            },
            {
                "introduction": "带部分主元的高斯消元法（GEPP）是求解线性方程组的标准算法，在实践中通常表现稳定。然而，它的后向稳定性并非无条件的，而是取决于一个关键量——主元增长因子 $\\rho$。本练习将通过一个经典的矩阵示例，让你亲手执行符号形式的 GEPP 分解，并计算其主元增长，从而揭示在特定情况下 GEPP 可能遇到的稳定性挑战 [@problem_id:3533819]。这个过程将加深你对常用数值算法理论保证及其局限性的理解。",
                "problem": "考虑部分主元高斯消去法 (GEPP)，该方法经过一系列行交换，将一个非奇异矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 分解为一个单位下三角因子 $L$ 和一个上三角因子 $U$。主元增长因子按元素定义为\n$$\\rho \\;=\\; \\frac{\\max_{i,j} |u_{i j}|}{\\max_{i,j} |a_{i j}|},$$\n其中 $U$ 是在精确算术下对给定矩阵 $A$ 使用 GEPP 所产生的精确上三角因子。在浮点模型中进行计算，其中每个基本算术运算 $x \\,\\circ\\, y$ ($\\circ \\in \\{+,-,\\times,\\div\\}$) 都被替换为 $\\operatorname{fl}(x \\,\\circ\\, y) = (x \\,\\circ\\, y)(1+\\delta)$，其中 $|\\delta| \\leq u$，$u$ 是单位舍入误差。假设 GEPP 的决胜规则是，当主元列中的多个候选元素具有相等的最大绝对值时，选择其中行索引最小的那个作为主元。\n\n通过考虑由以下方式定义的显式 $6 \\times 6$ 矩阵 $A$ 来构造一个具体矩阵\n- $a_{i i} = 1$，对于 $i=1,2,3,4,5,6$，\n- $a_{i+1,i} = -1$，对于 $i=1,2,3,4,5$，\n- $a_{i,6} = 1$，对于 $i=1,2,3,4,5,6$，\n- $A$ 的所有其他元素均为 $0$。\n\n任务：\n1. 对 $A$ 符号化地应用 GEPP 过程（遵守所述的决胜规则），并确定在精确算术下产生的精确上三角因子 $U$。\n2. 计算该矩阵 $A$ 的精确主元增长因子 $\\rho$。\n3. 使用标准的浮点误差模型，推导一个形式为 $\\|\\Delta A\\|_{\\infty} / \\|A\\|_{\\infty}$ 的范数形式的后向误差界，该界用 $u$ 以及从 $A$、$L$ 和 $U$ 计算出的量符号化地表示。你的推导应基于第一性原理：浮点模型、后向误差的定义（对于计算解 $\\hat{x}$，存在 $\\Delta A$ 使得 $(A+\\Delta A)\\hat{x}=\\hat{b}$），以及范数的次可乘性；不要假设任何现成的稳定性定理。\n4. 从该后向误差界，推导求解线性系统 $A x = b$ 的前向误差影响，用无穷范数条件数 $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty}\\,\\|A^{-1}\\|_{\\infty}$ 和单位舍入误差 $u$ 表示；通过计算 $\\|A\\|_{\\infty}$ 和 $\\|A^{-1}\\|_{\\infty}$，使你的推论对这个特定的 $A$ 明确。\n\n你最终报告的结果必须是该矩阵 $A$ 的主元增长因子 $\\rho$ 的精确值。不需要四舍五入。将最终结果表示为单个实数。",
                "solution": "用户提供了一个数值线性代数问题。我将首先根据指定标准验证问题陈述，如果有效，则继续进行完整解答。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- **算法**：部分主元高斯消去法 (GEPP)。\n- **矩阵**：$A \\in \\mathbb{R}^{n \\times n}$，其中 $n=6$。\n- **矩阵定义**：\n    - $a_{i i} = 1$，对于 $i=1,2,3,4,5,6$。\n    - $a_{i+1,i} = -1$，对于 $i=1,2,3,4,5$。\n    - $a_{i,6} = 1$，对于 $i=1,2,3,4,5,6$。\n    - $A$ 的所有其他元素均为 $0$。\n- **主元增长因子**：$\\rho = \\frac{\\max_{i,j} |u_{i j}|}{\\max_{i,j} |a_{i j}|}$，其中 $U$ 是 GEPP 产生的精确上三角因子。\n- **浮点模型**：$\\operatorname{fl}(x \\,\\circ\\, y) = (x \\,\\circ\\, y)(1+\\delta)$，其中 $|\\delta| \\leq u$。\n- **GEPP 决胜规则**：当多个主元候选元素具有相等的最大绝对值时，选择行索引最小的那个。\n- **任务**：\n    1. 对 $A$ 应用 GEPP 求精确因子 $U$。\n    2. 计算精确主元增长因子 $\\rho$。\n    3. 推导范数形式的后向误差界 $\\|\\Delta A\\|_{\\infty} / \\|A\\|_{\\infty}$。\n    4. 通过计算 $\\kappa_{\\infty}(A)$ 推导求解 $Ax=b$ 的前向误差影响。\n- **最终答案要求**：$\\rho$ 的精确值。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有科学依据、提法恰当、客观且自成体系。这是数值线性代数中的一个标准练习，旨在针对一个特定的、性质良好（尽管是说明性的）的矩阵，探讨主元增长和误差分析的概念。矩阵定义清晰明确。带有指定决胜规则的 GEPP 算法是确定性的。任务定义清晰，能够导出一个唯一且有意义的答案。不存在矛盾、信息缺失或违反科学原理的情况。\n\n**第 3 步：结论与行动**\n该问题被判定为**有效**。我将继续进行解答。\n\n### 解答\n\n给定的矩阵 $A$ 是一个 $6 \\times 6$ 矩阵，定义如下：\n$$\nA = \\begin{pmatrix}\n1  0  0  0  0  1 \\\\\n-1  1  0  0  0  1 \\\\\n0  -1  1  0  0  1 \\\\\n0  0  -1  1  0  1 \\\\\n0  0  0  -1  1  1 \\\\\n0  0  0  0  -1  1\n\\end{pmatrix}\n$$\n$A$ 中任意元素的最大绝对值为 $\\max_{i,j} |a_{ij}| = 1$。\n\n**任务 1：应用 GEPP 求 U**\n\n我们执行部分主元高斯消去法。令 $A^{(1)} = A$。\n\n**第 1 步 ($k=1$):**\n第一列是 $(1, -1, 0, 0, 0, 0)^T$。最大绝对值是 $1$，出现在第 1 行和第 2 行。根据决胜规则，我们从行索引最小的行中选择主元，因此主元是 $a_{11}^{(1)} = 1$。无需行交换，所以 $P_1 = I$。唯一的乘数是 $l_{21} = a_{21}^{(1)} / a_{11}^{(1)} = -1 / 1 = -1$。我们更新第 2 行：$R_2 \\leftarrow R_2 - l_{21} R_1 = R_2 + R_1$。\n$R_2: (-1, 1, 0, 0, 0, 1) + (1, 0, 0, 0, 0, 1) = (0, 1, 0, 0, 0, 2)$。\n得到的矩阵是：\n$$\nA^{(2)} = \\begin{pmatrix}\n1  0  0  0  0  1 \\\\\n0  1  0  0  0  2 \\\\\n0  -1  1  0  0  1 \\\\\n0  0  -1  1  0  1 \\\\\n0  0  0  -1  1  1 \\\\\n0  0  0  0  -1  1\n\\end{pmatrix}\n$$\n\n**第 2 步 ($k=2$):**\n主元列（从第 2 行开始）是 $(1, -1, 0, 0, 0)^T$。最大绝对值是 $1$，出现在第 2 行和第 3 行。我们选择主元 $a_{22}^{(2)} = 1$。无行交换。乘数是 $l_{32} = a_{32}^{(2)} / a_{22}^{(2)} = -1 / 1 = -1$。更新第 3 行：$R_3 \\leftarrow R_3 - l_{32} R_2 = R_3 + R_2$。\n$R_3: (0, -1, 1, 0, 0, 1) + (0, 1, 0, 0, 0, 2) = (0, 0, 1, 0, 0, 3)$。\n$$\nA^{(3)} = \\begin{pmatrix}\n1  0  0  0  0  1 \\\\\n0  1  0  0  0  2 \\\\\n0  0  1  0  0  3 \\\\\n0  0  -1  1  0  1 \\\\\n0  0  0  -1  1  1 \\\\\n0  0  0  0  -1  1\n\\end{pmatrix}\n$$\n\n**第 3 步 ($k=3$):**\n主元列：$(1, -1, 0, 0)^T$。主元是 $a_{33}^{(3)} = 1$。乘数是 $l_{43} = -1$。更新第 4 行：$R_4 \\leftarrow R_4 + R_3$。\n$R_4: (0, 0, -1, 1, 0, 1) + (0, 0, 1, 0, 0, 3) = (0, 0, 0, 1, 0, 4)$。\n$$\nA^{(4)} = \\begin{pmatrix}\n1  0  0  0  0  1 \\\\\n0  1  0  0  0  2 \\\\\n0  0  1  0  0  3 \\\\\n0  0  0  1  0  4 \\\\\n0  0  0  -1  1  1 \\\\\n0  0  0  0  -1  1\n\\end{pmatrix}\n$$\n\n**第 4 步 ($k=4$):**\n主元列：$(1, -1, 0)^T$。主元是 $a_{44}^{(4)} = 1$。乘数是 $l_{54} = -1$。更新第 5 行：$R_5 \\leftarrow R_5 + R_4$。\n$R_5: (0, 0, 0, -1, 1, 1) + (0, 0, 0, 1, 0, 4) = (0, 0, 0, 0, 1, 5)$。\n$$\nA^{(5)} = \\begin{pmatrix}\n1  0  0  0  0  1 \\\\\n0  1  0  0  0  2 \\\\\n0  0  1  0  0  3 \\\\\n0  0  0  1  0  4 \\\\\n0  0  0  0  1  5 \\\\\n0  0  0  0  -1  1\n\\end{pmatrix}\n$$\n\n**第 5 步 ($k=5$):**\n主元列：$(1, -1)^T$。主元是 $a_{55}^{(5)} = 1$。乘数是 $l_{65} = -1$。更新第 6 行：$R_6 \\leftarrow R_6 + R_5$。\n$R_6: (0, 0, 0, 0, -1, 1) + (0, 0, 0, 0, 1, 5) = (0, 0, 0, 0, 0, 6)$。\n最终的上三角矩阵 $U$ 是：\n$$\nU = A^{(6)} = \\begin{pmatrix}\n1  0  0  0  0  1 \\\\\n0  1  0  0  0  2 \\\\\n0  0  1  0  0  3 \\\\\n0  0  0  1  0  4 \\\\\n0  0  0  0  1  5 \\\\\n0  0  0  0  0  6\n\\end{pmatrix}\n$$\n没有进行任何行交换，所以置换矩阵是单位矩阵，$P=I$。下三角矩阵 $L$ 包含这些乘数：\n$$\nL = \\begin{pmatrix}\n1  0  0  0  0  0 \\\\\n-1  1  0  0  0  0 \\\\\n0  -1  1  0  0  0 \\\\\n0  0  -1  1  0  0 \\\\\n0  0  0  -1  1  0 \\\\\n0  0  0  0  -1  1\n\\end{pmatrix}\n$$\n\n**任务 2：计算主元增长因子 $\\rho$**\n\n主元增长因子定义为 $\\rho = \\frac{\\max_{i,j} |u_{ij}|}{\\max_{i,j} |a_{ij}|}$。\n从矩阵 $A$ 可知，$\\max_{i,j} |a_{ij}| = 1$。\n从矩阵 $U$ 可知，所有元素都是非负的。最大值显然是 $u_{66} = 6$。所以，$\\max_{i,j} |u_{ij}| = 6$。\n因此，主元增长因子是：\n$$ \\rho = \\frac{6}{1} = 6 $$\n\n**任务 3：推导范数形式的后向误差界**\n\n当使用 GEPP 求解 $Ax=b$ 时，计算解 $\\hat{x}$ 是一个扰动系统 $(A+\\Delta A)\\hat{x}=b$ 的精确解。LU 分解后进行前向和后向替换的浮点误差分析的一个标准结果给出了扰动 $\\Delta A$ 的一个界。忽略 $u^2$ 及更高阶的项，该界为：\n$$ |\\Delta A| \\le 3 \\gamma_n |P^T||\\hat{L}||\\hat{U}| $$\n其中 $\\gamma_n = \\frac{nu}{1-nu} \\approx nu$（对于小的 $u$），$|\\cdot|$ 表示绝对值矩阵。对于我们的问题，$P=I$，计算出的因子 $\\hat{L}$ 和 $\\hat{U}$ 接近于精确因子 $L$ 和 $U$。因此，我们可以用以下方式近似该界：\n$$ |\\Delta A| \\le 3nu |L||U| $$\n取无穷范数并使用范数的次可乘性：\n$$ \\|\\Delta A\\|_{\\infty} \\le 3nu \\left\\| |L||U| \\right\\|_{\\infty} $$\n我们有 $n=6$。矩阵 $|L|$ 和 $|U|=U$ 分别是：\n$$\n|L| = \\begin{pmatrix}\n1  0  0  0  0  0 \\\\\n1  1  0  0  0  0 \\\\\n0  1  1  0  0  0 \\\\\n0  0  1  1  0  0 \\\\\n0  0  0  1  1  0 \\\\\n0  0  0  0  1  1\n\\end{pmatrix}, \\quad |U| = U = \\begin{pmatrix}\n1  0  0  0  0  1 \\\\\n0  1  0  0  0  2 \\\\\n0  0  1  0  0  3 \\\\\n0  0  0  1  0  4 \\\\\n0  0  0  0  1  5 \\\\\n0  0  0  0  0  6\n\\end{pmatrix}\n$$\n我们计算乘积 $|L||U|$：\n$$\n|L||U| = \\begin{pmatrix}\n1  0  0  0  0  1 \\\\\n1  1  0  0  0  1+2 \\\\\n0  1  1  0  0  2+3 \\\\\n0  0  1  1  0  3+4 \\\\\n0  0  0  1  1  4+5 \\\\\n0  0  0  0  1  5+6\n\\end{pmatrix} = \\begin{pmatrix}\n1  0  0  0  0  1 \\\\\n1  1  0  0  0  3 \\\\\n0  1  1  0  0  5 \\\\\n0  0  1  1  0  7 \\\\\n0  0  0  1  1  9 \\\\\n0  0  0  0  1  11\n\\end{pmatrix}\n$$\n无穷范数 $\\|B\\|_{\\infty} = \\max_i \\sum_j |b_{ij}|$ 是最大绝对行和。\n$|L||U|$ 的行和为：$1+1=2$, $1+1+3=5$, $1+1+5=7$, $1+1+7=9$, $1+1+9=11$, $1+11=12$。\n所以，$\\left\\| |L||U| \\right\\|_{\\infty} = 12$。\n原始矩阵 $A$ 的无穷范数是：\n$\\|A\\|_{\\infty} = \\max_i \\sum_j |a_{ij}| = \\max(2,3,3,3,3,2) = 3$。\n相对后向误差界是：\n$$ \\frac{\\|\\Delta A\\|_{\\infty}}{\\|A\\|_{\\infty}} \\le \\frac{3(6)u (12)}{3} = 72u $$\n\n**任务 4：推导前向误差影响**\n\n解的相对前向误差的界为：\n$$ \\frac{\\|x-\\hat{x}\\|_{\\infty}}{\\|x\\|_{\\infty}} \\le \\kappa_{\\infty}(A) \\frac{\\|\\Delta A\\|_{\\infty}}{\\|A\\|_{\\infty}} $$\n其中 $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty} \\|A^{-1}\\|_{\\infty}$ 是条件数。我们需要计算 $A^{-1} = (LU)^{-1} = U^{-1}L^{-1}$。\n首先，我们求 $L$ 和 $U$ 的逆。\n求解 $Lx=y$ 得到 $x_1=y_1$, $x_2=y_2+x_1$, $x_3=y_3+x_2=y_3+y_2+y_1$ 等。因此 $L^{-1}$ 是全为 1 的下三角矩阵：\n$$\nL^{-1} = \\begin{pmatrix}\n1  0  0  0  0  0 \\\\\n1  1  0  0  0  0 \\\\\n1  1  1  0  0  0 \\\\\n1  1  1  1  0  0 \\\\\n1  1  1  1  1  0 \\\\\n1  1  1  1  1  1\n\\end{pmatrix}\n$$\n求解 $Ux=y$ 得到 $x_6 = y_6/6$，以及对于 $i6$ 有 $x_i = y_i - u_{i,6} x_6 = y_i - i \\cdot (y_6/6)$。\n$$\nU^{-1} = \\begin{pmatrix}\n1  0  0  0  0  -1/6 \\\\\n0  1  0  0  0  -2/6 \\\\\n0  0  1  0  0  -3/6 \\\\\n0  0  0  1  0  -4/6 \\\\\n0  0  0  0  1  -5/6 \\\\\n0  0  0  0  0  1/6\n\\end{pmatrix}\n$$\n现在，计算 $A^{-1} = U^{-1}L^{-1}$ 的元素 $(A^{-1})_{ij} = \\sum_k (U^{-1})_{ik} (L^{-1})_{kj}$。\n- 当 $i  6, j  6$ 时，$(A^{-1})_{ij} = (U^{-1})_{ii} (L^{-1})_{ij} = 1 \\cdot (L^{-1})_{ij}$，即当 $i \\ge j$ 时为 $1$，否则为 $0$。\n- 当 $i  6, j = 6$ 时，$(A^{-1})_{i6} = \\sum_{k=1}^6 (U^{-1})_{ik} (L^{-1})_{k6} = \\sum_{k=1}^6 (U^{-1})_{ik} \\cdot 1 = (U^{-1})_{ii} + (U^{-1})_{i6} = 1 - i/6$。\n- 当 $i = 6$ 时，$(A^{-1})_{6j} = \\sum_{k=1}^6 (U^{-1})_{6k} (L^{-1})_{kj} = (U^{-1})_{66} (L^{-1})_{6j} = 1/6 \\cdot 1 = 1/6$。\n因此，矩阵为：\n$$\nA^{-1} = \\begin{pmatrix}\n1  0  0  0  0  5/6 \\\\\n1  1  0  0  0  4/6 \\\\\n1  1  1  0  0  3/6 \\\\\n1  1  1  1  0  2/6 \\\\\n1  1  1  1  1  1/6 \\\\\n1/6  1/6  1/6  1/6  1/6  1/6\n\\end{pmatrix}\n$$\n$A^{-1}$ 的无穷范数是最大绝对行和：\n第 1 行：$1 + 5/6 = 11/6$\n第 2 行：$1 + 1 + 4/6 = 16/6$\n第 3 行：$1+1+1+3/6 = 21/6$\n第 4 行：$1+1+1+1+2/6 = 26/6$\n第 5 行：$1+1+1+1+1+1/6 = 31/6$\n第 6 行：$6 \\times (1/6) = 1$\n最大值为 $31/6$。所以，$\\|A^{-1}\\|_{\\infty} = 31/6$。\n条件数是 $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty} \\|A^{-1}\\|_{\\infty} = 3 \\cdot \\frac{31}{6} = \\frac{31}{2} = 15.5$。\n前向误差的影响是：\n$$ \\frac{\\|x-\\hat{x}\\|_{\\infty}}{\\|x\\|_{\\infty}} \\le \\kappa_{\\infty}(A) \\frac{\\|\\Delta A\\|_{\\infty}}{\\|A\\|_{\\infty}} \\le (15.5)(72u) = 1116u $$\n这表明对于这个特定矩阵，解的计算预期会产生大约是单位舍入误差 $u$ 的 $1116$ 倍的前向误差。\n\n问题要求的是主元增长因子 $\\rho$ 的单个值。\n$\\rho$ 的最终计算总结：\n$\\max_{i,j} |a_{ij}| = 1$。\n$\\max_{i,j} |u_{ij}| = 6$。\n$\\rho = 6/1 = 6$。",
                "answer": "$$\\boxed{6}$$",
                "id": "3533819"
            },
            {
                "introduction": "当线性系统 $A x = b$ 的矩阵 $A$ 的元素跨越多个数量级时，即出现“病态缩放”（ill-scaling），标准求解算法的数值稳定性会面临严峻考验。本练习介绍了一种强大的实用技术——对角平衡（diagonal equilibration），通过对矩阵的行和列进行缩放预处理，来改善其数值属性。你将通过编写代码来实现一个平衡方案，并在一系列测试用例上，用分量形式的后向误差来量化平衡前后解的质量改进，从而将误差分析的理论与高性能计算的实践联系起来 [@problem_id:3533816]。",
                "problem": "考虑线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$b \\in \\mathbb{R}^{n}$，该系统在电气和电子工程师协会（IEEE）$754$ 模型的浮点运算下求解，单位舍入误差为 $u$。近似解 $\\hat{x}$ 的分量形式后向误差定义为以下量\n$$\n\\eta(A,b,\\hat{x}) = \\max_{1 \\leq i \\leq n} \\frac{|r_i|}{\\left(|A| \\cdot |\\hat{x}| + |b|\\right)_i},\n$$\n其中 $r = b - A \\hat{x}$ 是残差，$|\\cdot|$ 表示分量形式的绝对值，分母按分量形式解释，并遵循约定 $0/0 = 0$ 以及当 $\\alpha > 0$ 时 $\\alpha/0 = \\infty$。一个后向稳定的算法旨在生成一个 $\\hat{x}$，使其 $\\eta(A,b,\\hat{x})$ 的量级为 $u$ 乘以适度的增长因子。当 $A$ 的元素跨越多个数量级时，除非通过正对角行和列缩放来平衡系统，否则分量形式的保证可能会退化。\n\n对角平衡构造正对角矩阵 $D_r$ 和 $D_c$，使得缩放后的系统 $D_r A D_c y = D_r b$ 具有更平衡的数值大小；然后通过 $\\hat{x}_{\\mathrm{eq}} = D_c \\hat{y}$ 恢复原系统的解。一种实用的方案是，选择 $D_r$ 使得 $D_r A$ 的每一行都具有单位最大绝对值元素，然后选择 $D_c$ 使得 $D_r A D_c$ 的每一列都具有单位最大绝对值元素，并约定恒为零的行或列的对角缩放值为 $1$。\n\n从浮点模型和分量形式后向误差的定义出发，设计并实现一个程序，该程序能够：\n- 通过组合一个对角元素为 $10^{e_i}$ 的对角矩阵 $D$ 和一个对角占优扰动 $B = I + \\varepsilon R$（其中 $R$ 的元素在 $[-1,1]$ 中均匀分布，$I$ 是单位矩阵），构造其元素跨越指定数量级的矩阵 $A$。\n- 对于一个给定的参考向量 $x_{\\mathrm{ref}}$，构造 $b = A x_{\\mathrm{ref}}$。\n- 通过直接求解 $A x = b$ 计算 $\\hat{x}_{\\mathrm{uns}}$，并评估 $\\eta_{\\mathrm{uns}} = \\eta(A,b,\\hat{x}_{\\mathrm{uns}})$。\n- 执行对角平衡以获得 $A_{\\mathrm{eq}} = D_r A D_c$ 和 $b_{\\mathrm{eq}} = D_r b$，求解 $A_{\\mathrm{eq}} y = b_{\\mathrm{eq}}$ 得到 $\\hat{y}$，构造 $\\hat{x}_{\\mathrm{eq}} = D_c \\hat{y}$，并评估 $\\eta_{\\mathrm{eq}} = \\eta(A,b,\\hat{x}_{\\mathrm{eq}})$。\n- 对每个测试案例，以浮点数形式报告改进因子 $\\rho = \\eta_{\\mathrm{uns}} / \\eta_{\\mathrm{eq}}$。\n\n使用以下测试套件，每个套件由 $(\\text{名称}, n, \\text{指数}, \\varepsilon, \\text{seed}_R, \\text{seed}_x)$ 指定：\n- 案例 $1$ (常规情况): $(\\text{\"happy\\_path\"}, 10, \\text{长度为 }10\\text{ 的线性间隔指数 }[-8,\\ldots,8], 10^{-2}, 123, 321)$。\n- 案例 $2$ (平衡情况): $(\\text{\"balanced\"}, 10, \\text{长度为 }10\\text{ 的全零指数}, 10^{-2}, 456, 654)$。\n- 案例 $3$ (极端情况): $(\\text{\"extreme\"}, 12, \\text{长度为 }12\\text{ 的线性间隔指数 }[-12,\\ldots,12], 10^{-3}, 789, 987)$。\n- 案例 $4$ (交替情况): $(\\text{\"alternating\"}, 12, \\text{长度为 }12\\text{ 的交替指数 }[-9,9,-9,9,\\ldots], 5 \\cdot 10^{-3}, 135, 531)$。\n\n每个案例的矩阵构造细节：\n- 使用指定的指数构造 $D = \\mathrm{diag}(10^{e_1}, \\ldots, 10^{e_n})$。\n- 使用 $\\text{seed}_R$ 生成 $R \\in \\mathbb{R}^{n \\times n}$，其独立元素在 $[-1,1]$ 上均匀分布。\n- 设置 $B = I + \\varepsilon R$ 并定义 $A = D B$。\n- 使用 $\\text{seed}_x$ 生成 $x_{\\mathrm{ref}} \\in \\mathbb{R}^{n}$，其元素在 $[0.1,1]$ 上均匀分布，然后乘以从以零为阈值的标准正态分布中得到的随机符号；构造 $b = A x_{\\mathrm{ref}}$。\n\n平衡细节：\n- 对于 $D_r = \\mathrm{diag}(d^{(r)}_1,\\ldots,d^{(r)}_n)$，如果最大值非零，则设置 $d^{(r)}_i = 1 / \\max_j |a_{ij}|$，否则 $d^{(r)}_i = 1$。\n- 对于应用于 $A_1 = D_r A$ 的 $D_c = \\mathrm{diag}(d^{(c)}_1,\\ldots,d^{(c)}_n)$，如果最大值非零，则设置 $d^{(c)}_j = 1 / \\max_i |(A_1)_{ij}|$，否则 $d^{(c)}_j = 1$。\n\n数值约定：\n- 按分量计算 $\\eta(A,b,\\hat{x})$，约定 $0/0 = 0$ 和当 $\\alpha > 0$ 时 $\\alpha/0 = \\infty$。\n- 如果 $\\eta_{\\mathrm{eq}} = 0$，则该案例报告 $\\rho = \\infty$。\n\n您的程序应生成单行输出，其中包含四个测试案例的改进因子，格式为方括号内的逗号分隔列表（例如，$[\\rho_1,\\rho_2,\\rho_3,\\rho_4]$）。输出必须是浮点数。不允许用户输入，所有随机抽样必须使用指定的种子以确保可复现性。",
                "solution": "当前的问题要求分析求解线性系统 $A x = b$ 的分量形式后向稳定性以及对角平衡的效果。我们的任务是，对于一组通过编程生成的病态缩放矩阵，量化特定平衡方案所带来的后向稳定性改善。\n\n该分析的基础是后向误差的概念。对于系统 $A x = b$（其中 $A \\in \\mathbb{R}^{n \\times n}$，$b \\in \\mathbb{R}^{n}$）的一个计算解 $\\hat{x}$，后向误差衡量了最小扰动 $(\\Delta A, \\Delta b)$ 的大小，使得 $\\hat{x}$ 是扰动后系统 $(A + \\Delta A) \\hat{x} = b + \\Delta b$ 的精确解。一个后向稳定的算法保证计算出的解是某个邻近问题的精确解，这意味着后向误差很小。问题指定了一个分量形式的相对后向误差，定义为：\n$$\n\\eta(A,b,\\hat{x}) = \\max_{1 \\leq i \\leq n} \\frac{|r_i|}{\\left(|A| \\cdot |\\hat{x}| + |b|\\right)_i}\n$$\n其中 $r = b - A \\hat{x}$ 是残差向量，$|\\cdot|$ 表示分量形式的绝对值。若 $\\eta(A,b,\\hat{x}) \\approx u$，其中 $u$ 是浮点运算的单位舍入误差（对于 IEEE $754$ 双精度，$u = 2^{-53} \\approx 1.11 \\times 10^{-16}$），则表明具有优异的后向稳定性。此定义意味着存在扰动 $\\Delta A$ 和 $\\Delta b$，使得 $(A + \\Delta A) \\hat{x} = b + \\Delta b$，且满足 $|\\Delta A| \\le \\eta(A,b,\\hat{x}) |A|$ 和 $|\\Delta b| \\le \\eta(A,b,\\hat{x}) |b|$。\n\n问题要求我们构造专门设计为病态缩放的测试矩阵。这通过构造 $A = D B$ 来实现，其中 $D = \\mathrm{diag}(10^{e_1}, \\ldots, 10^{e_n})$ 是一个对角矩阵，它引入了行数量级的巨大变化。矩阵 $B$ 是单位矩阵的一个小扰动，$B = I + \\varepsilon R$，其中 $R$ 的随机元素来自 $U[-1,1]$，$\\varepsilon$ 是一个小参数。对于足够小的 $\\varepsilon$，$B$ 是强对角占优的，因此是良态且非奇异的，从而确保 $A$ 也是非奇异的。右侧项构造成 $b = A x_{\\mathrm{ref}}$，其中 $x_{\\mathrm{ref}}$ 是一个已知的参考解。这种设置使我们能够将任何数值困难主要归因于 $A$ 的不良缩放，而不是底层问题的病态性。\n\n任务的核心是比较求解 $A x = b$ 的两种方法：\n\n1.  **直接（未缩放）解法**：我们使用标准数值求解器直接求解 $A x = b$。这会得到一个解 $\\hat{x}_{\\mathrm{uns}}$。然后我们计算其分量形式后向误差 $\\eta_{\\mathrm{uns}} = \\eta(A, b, \\hat{x}_{\\mathrm{uns}})$。对于病态缩放的矩阵，我们预期像带部分主元的高斯消去法（`numpy.linalg.solve` 中的实现）这样的标准算法可能会产生一个具有较大后向误差的解。\n\n2.  **平衡解法**：我们首先对系统应用双边对角缩放。平衡的目标是产生一个新的系统 $A_{\\mathrm{eq}} y = b_{\\mathrm{eq}}$，其中 $A_{\\mathrm{eq}}$ 的元素在数量级上更加均匀。具体方案如下：\n    a.  **行缩放**：找到一个对角矩阵 $D_r = \\mathrm{diag}(d_1^{(r)}, \\dots, d_n^{(r)})$，使得 $A_1 = D_r A$ 的每一行都具有为 $1$ 的最大绝对值。缩放因子为 $d_i^{(r)} = 1 / \\max_j |a_{ij}|$，如果第 $i$ 行全为零，则 $d_i^{(r)} = 1$。\n    b.  **列缩放**：找到一个对角矩阵 $D_c = \\mathrm{diag}(d_1^{(c)}, \\dots, d_n^{(c)})$，使得 $A_{\\mathrm{eq}} = A_1 D_c = D_r A D_c$ 的每一列都具有为 $1$ 的最大绝对值。缩放因子为 $d_j^{(c)} = 1 / \\max_i |(A_1)_{ij}|$，如果 $A_1$ 的第 $j$ 列全为零，则 $d_j^{(c)} = 1$。\n    \n    原始系统 $A x = b$ 被转换为 $(D_r A D_c) (D_c^{-1} x) = D_r b$，即 $A_{\\mathrm{eq}} y = b_{\\mathrm{eq}}$，其中 $y = D_c^{-1} x$ 且 $b_{\\mathrm{eq}} = D_r b$。我们求解这个缩放得更好的系统得到 $\\hat{y}$，然后通过 $\\hat{x}_{\\mathrm{eq}} = D_c \\hat{y}$ 恢复原始问题的解。此方法的后向误差是相对于原始问题进行评估的：$\\eta_{\\mathrm{eq}} = \\eta(A, b, \\hat{x}_{\\mathrm{eq}})$。\n\n最后，我们为每个测试案例计算改进因子 $\\rho = \\eta_{\\mathrm{uns}} / \\eta_{\\mathrm{eq}}$。一个 $\\rho \\gg 1$ 的值表明了平衡的有效性。实现使用 `numpy` 进行所有数值计算，并按规定设定随机数生成器的种子以确保可复现性。分量形式后向误差函数 $\\eta$ 的实现非常谨慎，以处理 $0/0=0$ 和对于 $\\alpha > 0$ 的 $\\alpha/0=\\infty$ 的约定。如果 $\\eta_{\\mathrm{eq}} = 0$，表明找到了数值上的精确解，则改进因子 $\\rho$ 取为无穷大。\n\n每个测试案例的程序步骤如下：\n1.  根据案例参数（$n$、指数、$\\varepsilon$、种子）构造矩阵 $A$ 和向量 $b$。\n2.  求解 $A x = b$ 得到 $\\hat{x}_{\\mathrm{uns}}$ 并计算 $\\eta_{\\mathrm{uns}}$。\n3.  计算缩放矩阵 $D_r$ 和 $D_c$。\n4.  构造平衡后的系统 $A_{\\mathrm{eq}} = D_r A D_c$ 和 $b_{\\mathrm{eq}} = D_r b$。\n5.  求解 $A_{\\mathrm{eq}} y = b_{\\mathrm{eq}}$ 得到 $\\hat{y}$。\n6.  计算平衡后的解 $\\hat{x}_{\\mathrm{eq}} = D_c \\hat{y}$。\n7.  计算原始系统对应的后向误差 $\\eta_{\\mathrm{eq}}$。\n8.  计算改进因子 $\\rho = \\eta_{\\mathrm{uns}} / \\eta_{\\mathrm{eq}}$。\n\n这种系统性的比较将突显对角平衡在数值线性代数中的实际益处。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef calculate_eta(A, b, x_hat):\n    \"\"\"\n    Computes the componentwise backward error eta(A, b, x_hat).\n    \"\"\"\n    if x_hat is None:\n        return np.inf\n\n    n = A.shape[0]\n    r = b - A @ x_hat\n    abs_r = np.abs(r)\n    \n    # Denominator term: (|A|*|x_hat| + |b|)_i\n    denominator = np.abs(A) @ np.abs(x_hat) + np.abs(b)\n    \n    # Initialize ratios to 0, which handles the 0/0 case.\n    ratios = np.zeros(n, dtype=float)\n    \n    # Case 1: Denominator is non-zero\n    denom_nz_mask = denominator != 0\n    ratios[denom_nz_mask] = abs_r[denom_nz_mask] / denominator[denom_nz_mask]\n    \n    # Case 2: Denominator is zero, but numerator is non-zero (alpha/0 - inf)\n    num_nz_denom_z_mask = (denominator == 0)  (abs_r != 0)\n    ratios[num_nz_denom_z_mask] = np.inf\n    \n    return np.max(ratios)\n\ndef process_case(n, exponents, epsilon, seed_R, seed_x):\n    \"\"\"\n    Processes a single test case for the equilibration problem.\n    \"\"\"\n    # 1. Setup: Construct A, xref, and b\n    rng_R = np.random.default_rng(seed_R)\n    rng_x = np.random.default_rng(seed_x)\n    \n    # Construct D\n    D = np.diag(np.power(10.0, exponents))\n    \n    # Construct B = I + epsilon * R\n    R = rng_R.uniform(-1.0, 1.0, size=(n, n))\n    B = np.eye(n) + epsilon * R\n    \n    # Construct A = D * B\n    A = D @ B\n    \n    # Construct x_ref\n    x_ref_mag = rng_x.uniform(0.1, 1.0, size=n)\n    x_ref_signs = np.sign(rng_x.standard_normal(size=n))\n    x_ref_signs[x_ref_signs == 0] = 1.0  # Convention for sign(0)\n    x_ref = x_ref_mag * x_ref_signs\n    \n    # Construct b = A * x_ref\n    b = A @ x_ref\n    \n    # 2. Unscaled Solution\n    try:\n        x_hat_uns = np.linalg.solve(A, b)\n        eta_uns = calculate_eta(A, b, x_hat_uns)\n    except np.linalg.LinAlgError:\n        eta_uns = np.inf\n\n    # 3. Equilibrated Solution\n    # Row scaling\n    row_maxes = np.max(np.abs(A), axis=1)\n    dr_diag = np.ones(n)\n    nonzero_rows = row_maxes != 0\n    dr_diag[nonzero_rows] = 1.0 / row_maxes[nonzero_rows]\n    Dr = np.diag(dr_diag)\n    \n    A1 = Dr @ A\n    \n    # Column scaling\n    col_maxes = np.max(np.abs(A1), axis=0)\n    dc_diag = np.ones(n)\n    nonzero_cols = col_maxes != 0\n    dc_diag[nonzero_cols] = 1.0 / col_maxes[nonzero_cols]\n    Dc = np.diag(dc_diag)\n    \n    A_eq = A1 @ Dc\n    b_eq = Dr @ b\n    \n    try:\n        y_hat = np.linalg.solve(A_eq, b_eq)\n        x_hat_eq = Dc @ y_hat\n        eta_eq = calculate_eta(A, b, x_hat_eq)\n    except np.linalg.LinAlgError:\n         eta_eq = np.inf\n\n    # 4. Improvement Factor\n    if eta_eq == 0:\n        if eta_uns == 0:\n            rho = 1.0 # Or undefined, but 1.0 is reasonable\n        else:\n            rho = np.inf\n    else:\n        rho = eta_uns / eta_eq\n        \n    return rho\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        (10, np.linspace(-8, 8, 10), 1e-2, 123, 321),\n        # Case 2 (balanced)\n        (10, np.zeros(10), 1e-2, 456, 654),\n        # Case 3 (extreme)\n        (12, np.linspace(-12, 12, 12), 1e-3, 789, 987),\n        # Case 4 (alternating)\n        (12, np.array([-9, 9] * 6, dtype=float), 5e-3, 135, 531)\n    ]\n\n    results = []\n    for n, exponents, epsilon, seed_R, seed_x in test_cases:\n        result = process_case(n, exponents, epsilon, seed_R, seed_x)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```",
                "id": "3533816"
            }
        ]
    }