{"hands_on_practices": [{"introduction": "自回归（AR）模型的识别是时间序列分析的核心任务之一。其理论基石是 Yule-Walker 方程，它揭示了时间序列的自相关结构（ACF）与其底层模型参数之间的直接数学关系。本练习将带你深入这一核心原理，通过求解 Yule-Walker 方程组，从给定的理论自相关函数值反向推算出 AR 模型的参数 $\\phi_i$，让你在实践中领会 ACF 如何成为识别模型不可或缺的“指纹” [@problem_id:2373109]。", "id": "2373109", "problem": "考虑一个零均值、协方差平稳的 $p$ 阶自回归 (AR) 过程 (Autoregressive (AR)($p$))，其定义为 $X_t = \\sum_{i=1}^p \\phi_i X_{t-i} + \\varepsilon_t$，其中 $\\{\\varepsilon_t\\}$ 是一个方差为 $\\sigma^2_\\varepsilon$ 的白噪声序列。令理论自协方差函数为 $\\gamma_k = \\mathbb{E}[X_t X_{t-k}]$，理论自相关函数 (Autocorrelation Function (ACF)) 为 $\\rho_k = \\gamma_k / \\gamma_0$，且 $\\rho_0 = 1$。对于每个 $k \\in \\{1,\\dots,p\\}$，连接 $\\{\\phi_i\\}_{i=1}^p$ 与 $\\{\\rho_k\\}_{k=1}^p$ 的总体矩条件是：\n$$\n\\rho_k = \\sum_{i=1}^p \\phi_i \\rho_{k-i},\n$$\n并满足对称条件 $\\rho_{-k} = \\rho_k$。等价地，该方程组可以写成一个托普利茨 (Toeplitz) 线性系统\n$$\nR \\,\\boldsymbol{\\phi} = \\boldsymbol{r},\n$$\n其中 $R \\in \\mathbb{R}^{p \\times p}$ 的元素为 $R_{ij} = \\rho_{|i-j|}$（对于 $i,j \\in \\{1,\\dots,p\\}$），$\\boldsymbol{\\phi} = [\\phi_1,\\dots,\\phi_p]^\\top$ 以及 $\\boldsymbol{r} = [\\rho_1,\\dots,\\rho_p]^\\top$。\n\n您的任务是，通过求解上述线性系统，为以下每个测试用例精确计算 $\\boldsymbol{\\phi}$。在数值报告中，每个分量必须四舍五入到 $6$ 位小数。最终输出必须将所有结果聚合在单行中，形式为列表的列表，其中每个内部列表包含该测试用例的 $p$ 个系数，顺序为 $[\\phi_1,\\dots,\\phi_p]$。\n\n测试套件：\n- 用例 $1$：$p = 1$，$(\\rho_1) = (0.6)$。\n- 用例 $2$：$p = 1$，$(\\rho_1) = (0.99)$。\n- 用例 $3$：$p = 1$，$(\\rho_1) = (-0.75)$。\n- 用例 $4$：$p = 2$，$(\\rho_1,\\rho_2) = (0.625,\\,0.5125)$。\n- 用例 $5$：$p = 2$，$(\\rho_1,\\rho_2) = (0.8,\\,0.46)$。\n- 用例 $6$：$p = 3$，$(\\rho_1,\\rho_2,\\rho_3) = (0.42105263157894735,\\,0.3684210526315789,\\,0.29473684210526313)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的列表的列表形式的结果，每个数字四舍五入到 $6$ 位小数。例如，一个有效的输出形如 $[[a_{11},\\dots,a_{1p_1}],[a_{21},\\dots,a_{2p_2}],\\dots]$，其中每个 $a_{ij}$ 是一个恰好有 $6$ 位小数的浮点数。", "solution": "该问题要求针对几组给定的理论自相关函数 (ACF) 值 $\\{\\rho_k\\}$，计算一个零均值、协方差平稳的 $p$ 阶自回归过程（记为 AR($p$)）的系数 $\\boldsymbol{\\phi} = [\\phi_1, \\dots, \\phi_p]^\\top$。\n\nAR($p$) 过程由以下随机差分方程定义：\n$$\nX_t = \\sum_{i=1}^p \\phi_i X_{t-i} + \\varepsilon_t\n$$\n其中 $\\{\\varepsilon_t\\}$ 是一个均值为 $0$、方差为 $\\sigma^2_\\varepsilon$ 的白噪声过程。项 $\\varepsilon_t$ 与过程的过去值 $X_{t-k}$（对于 $k>0$）不相关。\n\n滞后为 $k$ 的自协方差 $\\gamma_k$ 定义为 $\\gamma_k = \\mathbb{E}[X_t X_{t-k}]$。为了找到系数 $\\phi_i$ 和自协方差之间的关系，我们将 AR($p$) 方程两边乘以 $X_{t-k}$（对于 $k \\in \\{1, \\dots, p\\}$）并取期望：\n$$\n\\mathbb{E}[X_t X_{t-k}] = \\mathbb{E}\\left[\\left(\\sum_{i=1}^p \\phi_i X_{t-i}\\right) X_{t-k}\\right] + \\mathbb{E}[\\varepsilon_t X_{t-k}]\n$$\n对于 $k > 0$，根据白噪声的性质，最后一项 $\\mathbb{E}[\\varepsilon_t X_{t-k}]$ 为 $0$。这得到：\n$$\n\\gamma_k = \\sum_{i=1}^p \\phi_i \\mathbb{E}[X_{t-i} X_{t-k}] = \\sum_{i=1}^p \\phi_i \\gamma_{k-i}\n$$\n自相关函数 (ACF) $\\rho_k$ 定义为 $\\rho_k = \\gamma_k / \\gamma_0$。将上述方程两边除以方差 $\\gamma_0$ 得到 Yule-Walker 方程：\n$$\n\\rho_k = \\sum_{i=1}^p \\phi_i \\rho_{k-i}\n$$\n这些方程对 $k \\in \\{1, \\dots, p\\}$ 成立。我们使用 ACF 的性质：对于任意整数 $k$，$\\rho_0 = 1$ 且 $\\rho_{-k} = \\rho_k$。\n\n问题陈述，这个包含 $p$ 个未知数 $\\{\\phi_i\\}_{i=1}^p$ 的 $p$ 元线性方程组可以写成矩阵形式 $R \\boldsymbol{\\phi} = \\boldsymbol{r}$。让我们对一个通用的 $p$ 展开这个方程组：\n当 $k=1: \\rho_1 = \\phi_1\\rho_0 + \\phi_2\\rho_{-1} + \\dots + \\phi_p\\rho_{1-p} = \\phi_1\\rho_0 + \\phi_2\\rho_1 + \\dots + \\phi_p\\rho_{p-1}$\n当 $k=2: \\rho_2 = \\phi_1\\rho_1 + \\phi_2\\rho_0 + \\dots + \\phi_p\\rho_{2-p} = \\phi_1\\rho_1 + \\phi_2\\rho_0 + \\dots + \\phi_p\\rho_{p-2}$\n...\n当 $k=p: \\rho_p = \\phi_1\\rho_{p-1} + \\phi_2\\rho_{p-2} + \\dots + \\phi_p\\rho_0$\n\n其矩阵形式为：\n$$\n\\begin{pmatrix}\n\\rho_0 & \\rho_1 & \\rho_2 & \\dots & \\rho_{p-1} \\\\\n\\rho_1 & \\rho_0 & \\rho_1 & \\dots & \\rho_{p-2} \\\\\n\\rho_2 & \\rho_1 & \\rho_0 & \\dots & \\rho_{p-3} \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\rho_{p-1} & \\rho_{p-2} & \\rho_{p-3} & \\dots & \\rho_0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\phi_1 \\\\\n\\phi_2 \\\\\n\\phi_3 \\\\\n\\vdots \\\\\n\\phi_p\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\rho_1 \\\\\n\\rho_2 \\\\\n\\rho_3 \\\\\n\\vdots \\\\\n\\rho_p\n\\end{pmatrix}\n$$\n矩阵 $R$ 是一个对称托普利茨 (Toeplitz) 矩阵，其元素为 $R_{ij} = \\rho_{|i-j|}$（对 $i,j \\in \\{1,\\dots,p\\}$ 使用基于 1 的索引），且 $\\rho_0=1$。向量 $\\boldsymbol{r}$ 是 $[\\rho_1, \\dots, \\rho_p]^\\top$。任务是为每个测试用例求解此线性系统 $\\boldsymbol{\\phi} = R^{-1}\\boldsymbol{r}$。\n\n**用例 1：** $p=1$，$(\\rho_1) = (0.6)$。\n方程组为 $[\\rho_0][\\phi_1] = [\\rho_1]$，可简化为 $1 \\cdot \\phi_1 = 0.6$。因此，$\\phi_1 = 0.6$。\n\n**用例 2：** $p=1$，$(\\rho_1) = (0.99)$。\n方程组为 $1 \\cdot \\phi_1 = 0.99$。因此，$\\phi_1 = 0.99$。\n\n**用例 3：** $p=1$，$(\\rho_1) = (-0.75)$。\n方程组为 $1 \\cdot \\phi_1 = -0.75$。因此，$\\phi_1 = -0.75$。\n\n**用例 4：** $p=2$，$(\\rho_1, \\rho_2) = (0.625, 0.5125)$。\n方程组为 $\\begin{pmatrix} 1 & 0.625 \\\\ 0.625 & 1 \\end{pmatrix} \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} 0.625 \\\\ 0.5125 \\end{pmatrix}$。解此方程组得 $\\phi_1 = 0.5$ 和 $\\phi_2 = 0.2$。\n\n**用例 5：** $p=2$，$(\\rho_1, \\rho_2) = (0.8, 0.46)$。\n方程组为 $\\begin{pmatrix} 1 & 0.8 \\\\ 0.8 & 1 \\end{pmatrix} \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} 0.8 \\\\ 0.46 \\end{pmatrix}$。解此方程组得 $\\phi_1 = 1.2$ 和 $\\phi_2 = -0.5$。\n\n**用例 6：** $p=3$, $(\\rho_1, \\rho_2, \\rho_3) = (0.42105263157894735, 0.3684210526315789, 0.29473684210526313)$。\n令 $\\rho_1 \\approx 0.421$，$\\rho_2 \\approx 0.368$，$\\rho_3 \\approx 0.295$。该系统为：\n$$\n\\begin{pmatrix}\n1 & \\rho_1 & \\rho_2 \\\\\n\\rho_1 & 1 & \\rho_1 \\\\\n\\rho_2 & \\rho_1 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\phi_1 \\\\\n\\phi_2 \\\\\n\\phi_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\rho_1 \\\\\n\\rho_2 \\\\\n\\rho_3\n\\end{pmatrix}\n$$\n使用提供的 $\\rho_k$ 高精度值求解此 $3 \\times 3$ 线性方程组，可得 $\\phi_1 = 0.2$，$\\phi_2 = 0.3$ 和 $\\phi_3 = 0.1$。\n\n所需的 Python 代码将为每组参数实现该系统的一个通用求解器。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the AR(p) coefficients phi given the theoretical autocorrelations rho_k\n    by solving the Yule-Walker equations in their matrix form R*phi = r.\n    \"\"\"\n    test_cases = [\n        {'p': 1, 'rho': [0.6]},\n        {'p': 1, 'rho': [0.99]},\n        {'p': 1, 'rho': [-0.75]},\n        {'p': 2, 'rho': [0.625, 0.5125]},\n        {'p': 2, 'rho': [0.8, 0.46]},\n        {'p': 3, 'rho': [0.42105263157894735, 0.3684210526315789, 0.29473684210526313]}\n    ]\n\n    all_phis = []\n\n    for case in test_cases:\n        p = case['p']\n        rho_k = case['rho']\n\n        # The vector r is [rho_1, ..., rho_p]^T\n        r = np.array(rho_k)\n\n        # The matrix R is a symmetric Toeplitz matrix R_ij = rho_{|i-j|}\n        # We need autocorrelations from rho_0 to rho_{p-1}.\n        # rho_0 is always 1.\n        rho_full = np.concatenate(([1.0], np.array(rho_k)))\n\n        # Construct the Toeplitz matrix R using scipy.linalg.toeplitz or manually.\n        # Manual construction:\n        R = np.zeros((p, p))\n        for i in range(p):\n            for j in range(p):\n                # Using 0-based indexing for numpy arrays\n                R[i, j] = rho_full[abs(i - j)]\n\n        # Solve the linear system R * phi = r for phi\n        phi = np.linalg.solve(R, r)\n        all_phis.append(phi)\n\n    # Format the final output string as a list of lists, with each number\n    # rounded to 6 decimal places.\n    formatted_results = []\n    for phi_vector in all_phis:\n        # Format each coefficient in the vector\n        formatted_phi = [f\"{x:.6f}\" for x in phi_vector]\n        # Create the string for the inner list\n        formatted_results.append(f\"[{','.join(formatted_phi)}]\")\n    \n    # Create the final output string for the outer list\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"}, {"introduction": "在掌握了如何从 ACF 求解模型参数后，我们来逆向操作：从参数出发生成数据，并观察其特征。具有复数特征根的二阶自回归（AR(2)）过程是一个经典例子，其理论 ACF 呈现阻尼正弦波形态，而 PACF 则在滞后 2 阶后“截尾”。这个练习要求你从头开始模拟一个 AR(2) 过程，并计算其样本 ACF 和 PACF，通过编程实践来亲眼验证这一重要的模型识别特征 [@problem_id:2373131]。", "id": "2373131", "problem": "考虑一个计算经济学和金融学中的单变量、协方差平稳时间序列，其底层数据生成过程可被建模为一个线性自回归模型。你的任务是构建并验证一个过程，该过程的样本自相关函数 (ACF) 呈现出清晰的正弦模式，而其样本偏自相关函数 (PACF) 则不呈现该模式。重点在于从第一性原理出发，推导并实现其逻辑：包括协方差平稳性、自协方差、自相关以及通过 Levinson–Durbin 递归求解 Yule–Walker 方程组得到的偏自相关的定义。请勿使用任何预构建的时间序列工具；直接根据其定义实现所需的估计量。\n\n需要使用的基本定义：\n\n- 一个零均值、弱平稳过程拥有自协方差序列 $\\{\\gamma_{k}\\}_{k \\in \\mathbb{Z}}$，其中 $\\gamma_{k} = \\mathbb{E}[(X_{t} - \\mu)(X_{t-k} - \\mu)]$ 仅依赖于滞后 $k$。此处 $\\mu = \\mathbb{E}[X_{t}]$ 是一个常数，且 $\\operatorname{Var}(X_{t}) = \\gamma_{0} \\lt \\infty$ 不依赖于 $t$。\n\n- 滞后 $k$ 阶的自相关为 $\\rho_{k} = \\gamma_{k}/\\gamma_{0}$。\n\n- 滞后 $k$ 阶的偏自相关，记为 $\\alpha_{k}$，是在移除了对中间滞后项 $1,\\dots,k-1$ 的线性依赖后，$X_{t}$ 与 $X_{t-k}$ 之间的相关性。它是一个 $k$ 阶自回归的 Yule–Walker 线性方程组解中的最后一个系数，并且可以通过将 Levinson–Durbin 算法应用于样本自协方差序列来递归计算。\n\n你将模拟一个由下式定义的二阶自回归过程 $\\text{AR}(2)$：\n$$\nX_{t} = \\phi_{1} X_{t-1} + \\phi_{2} X_{t-2} + \\varepsilon_{t},\n$$\n其中 $\\{\\varepsilon_{t}\\}$ 是一个独立同分布的白噪声序列，满足 $\\varepsilon_{t} \\sim \\mathcal{N}(0,\\sigma^{2})$，且 $\\sigma^{2} = 1$。选择 $(\\phi_{1},\\phi_{2})$，使得特征多项式 $1 - \\phi_{1} z - \\phi_{2} z^{2}$ 的根为复数且位于单位圆外，以确保协方差平稳性和振荡动态。\n\n从第一性原理实现：\n\n- 一个带有预烧期以近似平稳性的 $\\text{AR}(2)$ 模拟器。\n\n- 使用以下公式计算样本均值 $\\hat{\\mu}$ 和样本自协方差序列 $\\{\\hat{\\gamma}_{k}\\}_{k=0}^{K}$：\n$$\n\\hat{\\mu} = \\frac{1}{n} \\sum_{t=1}^{n} X_{t}, \\qquad\n\\hat{\\gamma}_{k} = \\frac{1}{n} \\sum_{t=k+1}^{n} (X_{t} - \\hat{\\mu})(X_{t-k} - \\hat{\\mu}).\n$$\n\n- 样本自相关序列 $\\hat{\\rho}_{k} = \\hat{\\gamma}_{k}/\\hat{\\gamma}_{0}$，其中 $k=0,1,\\dots,K$。\n\n- 通过将 Levinson–Durbin 递归应用于 $\\{\\hat{\\gamma}_{k}\\}_{k=0}^{K}$ 来计算样本 PACF $\\{\\hat{\\alpha}_{k}\\}_{k=1}^{K}$。\n\n每个模拟序列的验证标准必须按如下方式计算：\n\n- 定义 $K$ 为诊断性检验的最大滞后阶数。\n\n- 如果以下两个条件同时成立，则声明 ACF 具有“清晰的正弦模式”：\n  1. 在丢弃绝对值小于容差 $\\varepsilon$ 的项后，序列 $\\{\\hat{\\rho}_{k}\\}_{k=1}^{K}$ 中的符号变化次数至少为 $S_{\\min}$。\n  2. 绝对值呈衰减趋势，即 $|\\hat{\\rho}_{K}| \\lt |\\hat{\\rho}_{1}|$。\n\n- 通过验证对于 $\\text{AR}(2)$ 过程，PACF 在滞后 2 阶后有效截尾，来声明 PACF “不具有正弦模式”。该条件可操作化为：\n$$\n\\max_{k \\in \\{3,4,\\dots,K\\}} |\\hat{\\alpha}_{k}| \\le \\tau,\n$$\n其中 $\\tau$ 是一个选定的容差。\n\n测试套件：\n\n你必须精确运行以下三个案例，其中每个元组指定了 $(\\phi_{1}, \\phi_{2}, n, K, \\text{seed}, \\text{burn\\_in})$：\n\n- 案例 1：$(\\phi_{1}, \\phi_{2}, n, K, \\text{seed}, \\text{burn\\_in}) = (\\, 1.5,\\, -0.75,\\, 600,\\, 20,\\, 123,\\, 500 \\,)$。\n\n- 案例 2：$(\\phi_{1}, \\phi_{2}, n, K, \\text{seed}, \\text{burn\\_in}) = (\\, 1.2,\\, -0.64,\\, 400,\\, 20,\\, 456,\\, 500 \\,)$。\n\n- 案例 3：$(\\phi_{1}, \\phi_{2}, n, K, \\text{seed}, \\text{burn\\_in}) = (\\, 1.6,\\, -0.85,\\, 300,\\, 20,\\, 789,\\, 500 \\,)$。\n\n在上述标准中使用 $\\varepsilon = 0.05$，$S_{\\min} = 3$ 和 $\\tau = 0.30$。\n\n对于每个案例，输出一个布尔值。当且仅当两个诊断条件都满足时，该布尔值为真：即根据上述规则 ACF 是正弦的，并且 PACF 因为在滞后 2 阶后于容差 $\\tau$ 内有效截尾而不呈现正弦模式。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[\\text{result1},\\text{result2},\\text{result3}]$，其中每个条目是按顺序对应于上述三个案例的布尔值。\n\n在此任务中，不得报告任何物理单位或角度作为输出。如果理论中出现任何内部角度，请将其解释为弧度，但不要输出任何角度。", "solution": "问题陈述已经过验证。所有给定的条件、定义和约束都已被提取和分析。该问题被认定为具有科学依据、良构且客观。这是计算时间序列分析中的一个标准练习，特别是关于自回归模型的性质。测试案例的参数被选择以满足指定的平稳性和振荡行为条件。对于一个 $\\text{AR}(2)$ 过程 $X_{t} = \\phi_{1} X_{t-1} + \\phi_{2} X_{t-2} + \\varepsilon_{t}$，平稳性要求特征多项式 $1 - \\phi_{1} z - \\phi_{2} z^{2} = 0$ 的根位于单位圆外。这等价于条件 $\\phi_{1} + \\phi_{2} < 1$，$\\phi_{2} - \\phi_{1} < 1$ 和 $|\\phi_{2}| < 1$。导致正弦自相关函数的振荡行为要求根为复数，这在 $\\phi_{1}^{2} + 4\\phi_{2} < 0$ 时发生。所有三个提供的参数集 $(\\phi_{1}, \\phi_{2})$ 都满足这些条件。因此，该问题被视为有效，并将构建一个解决方案。\n\n任务是模拟一个二阶自回归 $\\text{AR}(2)$ 过程，并验证其样本统计量符合理论预期。具体来说，对于具有复特征根的 $\\text{AR}(2)$ 过程，理论自相关函数 (ACF) 表现出类似于阻尼正弦波的行为，而理论偏自相关函数 (PACF) 在滞后 2 阶后截尾。我们将从第一性原理出发实现必要的算法，以验证给定样本数据的这种行为。\n\n首先，我们模拟由 $X_{t} = \\phi_{1} X_{t-1} + \\phi_{2} X_{t-2} + \\varepsilon_{t}$ 定义的 $\\text{AR}(2)$ 过程，其中 $\\varepsilon_{t}$ 是均值为 $0$、方差为 $\\sigma^2=1$ 的白噪声过程。使用一个预烧期来确保模拟序列近似于一个弱平稳过程。初始值 $X_0$ 和 $X_{-1}$ 设置为 $0$。在生成总共 $n + \\text{burn\\_in}$ 个点后，丢弃前 $\\text{burn\\_in}$ 个样本，留下一个长度为 $n$ 的序列。\n\n接下来，我们计算样本统计量。样本均值估计为 $\\hat{\\mu} = \\frac{1}{n} \\sum_{t=1}^{n} X_{t}$。利用这个值，我们根据指定的公式计算样本自协方差序列 $\\{\\hat{\\gamma}_{k}\\}_{k=0}^{K}$：\n$$\n\\hat{\\gamma}_{k} = \\frac{1}{n} \\sum_{t=k+1}^{n} (X_{t} - \\hat{\\mu})(X_{t-k} - \\hat{\\mu})\n$$\n这是一个有偏估计量，因为求和项包含 $n-k$ 个项，而除数是 $n$。然后计算样本自相关函数 (ACF) 为 $\\hat{\\rho}_{k} = \\hat{\\gamma}_{k}/\\hat{\\gamma}_{0}$，滞后阶数 $k=0, 1, \\dots, K$。\n\n分析的核心是计算样本偏自相关函数 (PACF)，记为 $\\{\\hat{\\alpha}_{k}\\}_{k=1}^{K}$。滞后 $k$ 阶的 PACF, $\\alpha_k$，被定义为拟合数据的 $k$ 阶自回归模型中的最后一个系数 $\\phi_{k,k}$。这些系数由 Yule–Walker 方程确定，该方程将模型系数与自相关联系起来：\n$$\n\\begin{pmatrix} 1 & \\rho_1 & \\dots & \\rho_{k-1} \\\\ \\rho_1 & 1 & \\dots & \\rho_{k-2} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\rho_{k-1} & \\rho_{k-2} & \\dots & 1 \\end{pmatrix} \\begin{pmatrix} \\phi_{k,1} \\\\ \\phi_{k,2} \\\\ \\vdots \\\\ \\phi_{k,k} \\end{pmatrix} = \\begin{pmatrix} \\rho_1 \\\\ \\rho_2 \\\\ \\vdots \\\\ \\rho_k \\end{pmatrix}\n$$\n我们使用计算上高效的 Levinson–Durbin 递归方法，对每个滞后 $k=1, \\dots, K$ 求解该系统以得到 $\\phi_{k,k}$。给定样本自相关 $\\{\\hat{\\rho}_k\\}$，样本 PACF 系数 $\\{\\hat{\\alpha}_k = \\hat{\\phi}_{k,k}\\}$ 被递归计算。\n当 $k=1$ 时：\n$$ \\hat{\\alpha}_1 = \\hat{\\phi}_{1,1} = \\hat{\\rho}_1 $$\n当 $k > 1$ 时：\n$$ \\hat{\\alpha}_k = \\hat{\\phi}_{k,k} = \\frac{\\hat{\\rho}_k - \\sum_{j=1}^{k-1} \\hat{\\phi}_{k-1,j} \\hat{\\rho}_{k-j}}{1 - \\sum_{j=1}^{k-1} \\hat{\\phi}_{k-1,j} \\hat{\\rho}_{j}} $$\n中间 $\\text{AR}(k)$ 模型的其他系数更新如下：\n$$ \\hat{\\phi}_{k,j} = \\hat{\\phi}_{k-1,j} - \\hat{\\alpha}_k \\hat{\\phi}_{k-1,k-j} \\quad \\text{for } j=1, \\dots, k-1 $$\n此算法被迭代应用于 $k=1, \\dots, K$，以获得完整的样本 PACF 序列。\n\n最后，我们应用指定的验证标准。如果满足两个条件，ACF 就被认为具有“清晰的正弦模式”：\n1. 在序列 $\\{\\hat{\\rho}_{k}\\}_{k=1}^{K}$ 中，仅考虑 $|\\hat{\\rho}_{k}| \\ge \\varepsilon = 0.05$ 的项，其符号变化的次数必须至少为 $S_{\\min} = 3$。\n2. 绝对值必须表现出整体衰减，具体为 $|\\hat{\\rho}_{K}| < |\\hat{\\rho}_{1}|$。\n\n如果 PACF 在真实模型阶数 2 之后有效截尾，则声明其“不具有正弦模式”。这通过以下条件进行检验：\n$$ \\max_{k \\in \\{3,4,\\dots,K\\}} |\\hat{\\alpha}_{k}| \\le \\tau $$\n其中容差为 $\\tau = 0.30$。\n\n当且仅当 ACF 和 PACF 的标准都得到满足时，一个测试案例才通过验证。该过程将对提供的三个测试案例中的每一个执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_ar2_series(phi1, phi2, n, burn_in, seed):\n    \"\"\"\n    Simulates a zero-mean AR(2) process.\n\n    Args:\n        phi1 (float): The first AR coefficient.\n        phi2 (float): The second AR coefficient.\n        n (int): The length of the output series.\n        burn_in (int): The number of initial points to discard.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        numpy.ndarray: The simulated AR(2) time series of length n.\n    \"\"\"\n    total_len = n + burn_in\n    rng = np.random.default_rng(seed)\n    epsilon = rng.normal(loc=0.0, scale=1.0, size=total_len)\n    \n    x = np.zeros(total_len)\n    # Initial values are X_0=0, X_{-1}=0, so first two terms are just noise\n    if total_len > 0:\n        x[0] = epsilon[0]\n    if total_len > 1:\n        x[1] = phi1 * x[0] + epsilon[1]\n\n    for t in range(2, total_len):\n        x[t] = phi1 * x[t-1] + phi2 * x[t-2] + epsilon[t]\n        \n    return x[burn_in:]\n\ndef compute_acf_pacf(series, K):\n    \"\"\"\n    Computes sample ACF and PACF from first principles using Levinson-Durbin.\n\n    Args:\n        series (numpy.ndarray): The time series data.\n        K (int): The maximum lag to compute.\n\n    Returns:\n        tuple: A tuple containing:\n            - numpy.ndarray: The sample ACF up to lag K.\n            - numpy.ndarray: The sample PACF up to lag K.\n    \"\"\"\n    n = len(series)\n    mu_hat = np.mean(series)\n    demeaned_series = series - mu_hat\n\n    # Sample Autocovariance\n    gamma_hat = np.zeros(K + 1)\n    for k in range(K + 1):\n        # As per problem: (1/n) * sum_{t=k+1 to n} ...\n        # which involves n-k terms\n        gamma_hat[k] = (1/n) * np.sum(demeaned_series[k:] * demeaned_series[:n-k])\n\n    # Sample Autocorrelation\n    rho_hat = gamma_hat / gamma_hat[0]\n\n    # Sample Partial Autocorrelation (Levinson-Durbin recursion)\n    pacf = np.zeros(K + 1)\n    phi = np.zeros(K + 1)\n    \n    for k in range(1, K + 1):\n        # Calculate phi_k,k which is the PACF at lag k\n        num_sum = np.dot(phi[1:k], rho_hat[k-1:0:-1])\n        den_sum = np.dot(phi[1:k], rho_hat[1:k])\n        \n        phi_kk = (rho_hat[k] - num_sum) / (1 - den_sum)\n        pacf[k] = phi_kk\n        \n        # Update phi coefficients for the next iteration\n        phi_old = phi[1:k].copy()\n        phi[k] = phi_kk\n        phi[1:k] = phi_old - phi_kk * phi_old[::-1]\n\n    return rho_hat, pacf\n\ndef verify_criteria(rho_hat, pacf, K, epsilon, S_min, tau):\n    \"\"\"\n    Verifies the conditions for ACF and PACF patterns.\n\n    Args:\n        rho_hat (numpy.ndarray): The sample ACF.\n        pacf (numpy.ndarray): The sample PACF.\n        K (int): The maximum lag.\n        epsilon (float): Threshold for ACF magnitude.\n        S_min (int): Minimum number of sign changes for ACF.\n        tau (float): Threshold for PACF cutoff.\n\n    Returns:\n        bool: True if all criteria are met, False otherwise.\n    \"\"\"\n    # 1. ACF sinusoidal pattern verification\n    acf_is_sinusoidal = False\n    \n    # Condition 1.1: Sign changes\n    rho_filtered = [r for r in rho_hat[1:K+1] if np.abs(r) >= epsilon]\n    num_sign_changes = 0\n    if len(rho_filtered) > 1:\n        for i in range(len(rho_filtered) - 1):\n            if np.sign(rho_filtered[i]) != np.sign(rho_filtered[i+1]):\n                num_sign_changes += 1\n    \n    # Condition 1.2: Magnitude decay\n    magnitude_decay = np.abs(rho_hat[K]) < np.abs(rho_hat[1])\n    \n    if num_sign_changes >= S_min and magnitude_decay:\n        acf_is_sinusoidal = True\n\n    # 2. PACF cutoff verification\n    pacf_cuts_off = False\n    if K >= 3:\n        max_abs_pacf_tail = np.max(np.abs(pacf[3:K+1]))\n        if max_abs_pacf_tail <= tau:\n            pacf_cuts_off = True\n    else: # If K < 3, criteria cannot be checked, so it is considered not met.\n        pacf_cuts_off = False\n\n    return acf_is_sinusoidal and pacf_cuts_off\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (phi1, phi2, n, K, seed, burn_in)\n        (1.5, -0.75, 600, 20, 123, 500),\n        (1.2, -0.64, 400, 20, 456, 500),\n        (1.6, -0.85, 300, 20, 789, 500),\n    ]\n\n    epsilon = 0.05\n    S_min = 3\n    tau = 0.30\n\n    results = []\n    for case in test_cases:\n        phi1, phi2, n, K, seed, burn_in = case\n        \n        # 1. Simulate the AR(2) process\n        series = generate_ar2_series(phi1, phi2, n, burn_in, seed)\n        \n        # 2. Compute sample ACF and PACF from first principles\n        rho_hat, pacf_hat = compute_acf_pacf(series, K)\n        \n        # 3. Verify conditions\n        result = verify_criteria(rho_hat, pacf_hat, K, epsilon, S_min, tau)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "为了建立完整的模型识别能力，我们必须能够区分 AR 过程和另一种基本的时间序列模型——移动平均（MA）过程。MA 过程具有“有限记忆”的特性，其 ACF 会在特定阶数 $q$ 后突然“截尾”至零，而其 PACF 则表现出拖尾或振荡衰减，这与 AR 过程的特征恰好相反。本练习将通过对白噪声序列应用移动平均滤波器来生成一个 MA 过程，让你在实践中观察其独特的 ACF 和 PACF 模式，从而深化对不同模型“指纹”的理解 [@problem_id:2373117]。", "id": "2373117", "problem": "给定一个白噪声驱动的线性时间序列，该序列是通过对独立同分布（i.i.d.）新息应用一个简单移动平均滤波器得到的。设 $\\{x_t\\}_{t=0}^{T-1}$ 为独立同分布的高斯新息，其均值为 $0$，方差为 $\\sigma^2$。将滤波后的序列 $\\{y_t\\}$ 定义为\n$$\ny_t \\;=\\; \\frac{1}{5}\\sum_{i=0}^{4} x_{t-i}\\quad \\text{for all } t \\in \\{4,5,\\dots,T-1\\},\n$$\n因此，可用的滤波后样本为 $\\{y_0,\\dots,y_{n-1}\\}$，其中 $n = T-4$，并且 $y_j$ 对应于原始时间索引 $t=j+4$。需要分析序列 $\\{y_t\\}$ 的自相关函数（ACF）和偏自相关函数（PACF）。\n\n需要用到的定义：\n- 对于样本 $\\{y_0,\\dots,y_{n-1}\\}$（其样本均值为 $\\bar y$），滞后 $k \\in \\{0,1,\\dots,K\\}$ 阶的样本自相关为\n$$\n\\hat r_k \\;=\\; \\frac{\\sum_{t=k}^{n-1} (y_t-\\bar y)(y_{t-k}-\\bar y)}{\\sum_{t=0}^{n-1} (y_t-\\bar y)^2}.\n$$\n- 滞后 $k \\in \\{1,2,\\dots,K\\}$ 阶的样本偏自相关（记为 $\\widehat\\phi_k$）是在 $y_t$ 对 $\\{y_{t-1},\\dots,y_{t-k}\\}$ 的线性投影中 $y_{t-k}$ 的系数，定义为该最小二乘投影的正规方程组的唯一解。\n- $\\{y_t\\}$ 的精确（总体）自相关函数 $\\rho_k$ 需要利用 $\\{y_t\\}$ 作为白噪声的线性滤波器的定义以及自协方差函数的定义，从第一性原理推导得出。\n\n对于下方的每组参数集，执行以下步骤：\n1. 使用指定的伪随机种子生成 $\\{x_t\\}_{t=0}^{T-1}$，其中 $x_t \\sim \\mathcal N(0,\\sigma^2)$。\n2. 通过上述定义的长度为5的移动平均滤波器构建 $\\{y_t\\}$，并舍弃前4个索引，使得计算样本为 $\\{y_0,\\dots,y_{n-1}\\}$，其中 $n=T-4$。\n3. 使用上述定义计算样本自相关 $\\{\\hat r_k\\}_{k=0}^{K}$，其中 $K=20$。\n4. 使用上述定义计算样本偏自相关 $\\{\\widehat\\phi_k\\}_{k=1}^{K}$，其中 $K=20$。\n5. 从第一性原理推导滤波后过程 $\\{y_t\\}$ 的精确（总体）自相关值 $\\{\\rho_k\\}_{k=1}^{4}$。这些精确值仅用于滞后 $k \\in \\{1,2,3,4\\}$。\n6. 计算以下三个摘要指标：\n   - $e_1 \\;=\\; \\max_{k \\in \\{1,2,3,4\\}} \\left| \\hat r_k - \\rho_k \\right|$。\n   - $e_2 \\;=\\; \\max_{k \\in \\{5,6,\\dots,20\\}} \\left| \\hat r_k \\right|$。\n   - $e_3 \\;=\\; \\dfrac{\\frac{1}{15}\\sum_{k=6}^{20} |\\widehat\\phi_k|}{|\\widehat\\phi_1| + 10^{-12}}$。\n\n为每组参数集报告 $(e_1,e_2,e_3)$，四舍五入到恰好 $6$ 位小数。\n\n测试套件（每个项目列出 $(T,\\sigma,\\text{seed})$）：\n- 案例A: $(T,\\sigma,\\text{seed}) = (1000,\\,1.0,\\,11)$。\n- 案例B: $(T,\\sigma,\\text{seed}) = (200,\\,2.0,\\,22)$。\n- 案例C: $(T,\\sigma,\\text{seed}) = (80,\\,0.5,\\,33)$。\n- 案例D: $(T,\\sigma,\\text{seed}) = (50,\\,1.0,\\,44)$。\n- 案例E: $(T,\\sigma,\\text{seed}) = (25,\\,1.0,\\,55)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个按 $[e_{1,A},e_{2,A},e_{3,A}]$ 顺序排列且包含三个浮点数的列表。例如，所需的结构是\n$$\n\\big[\\,[e_{1,A},e_{2,A},e_{3,A}],[e_{1,B},e_{2,B},e_{3,B}],\\dots\\big],\n$$\n且每个浮点数必须四舍五入到恰好 $6$ 位小数。", "solution": "所提出的问题是有效的。它在科学上基于线性时间序列分析的既定理论，特别是关于移动平均（MA）过程的理论。该问题提法恰当，提供了所有必要的定义、参数和一组清晰的计算任务。其中没有矛盾、歧义或事实错误。因此，我们将着手提供一个完整的解决方案。\n\n问题的核心是分析一个时间序列 $\\{y_t\\}$ 的性质，该序列是通过对一个高斯白噪声过程 $\\{x_t\\}$ 应用一个阶数 $q=4$ 的简单移动平均滤波器生成的。这种构造将 $\\{y_t\\}$ 定义为一个4阶移动平均过程，记为MA($4$)。\n\n首先，我们从第一性原理推导过程 $\\{y_t\\}$ 的精确（或总体）自相关函数（ACF）$\\rho_k$。该过程定义为：\n$$\ny_t = \\frac{1}{5}\\sum_{i=0}^{4} x_{t-i}\n$$\n其中 $\\{x_t\\}$ 是独立同分布（i.i.d.）的随机变量，其均值 $E[x_t] = 0$，方差 $\\text{Var}(x_t) = E[x_t^2] = \\sigma^2$。\n\n过程 $\\{y_t\\}$ 的均值为：\n$$\nE[y_t] = E\\left[\\frac{1}{5}\\sum_{i=0}^{4} x_{t-i}\\right] = \\frac{1}{5}\\sum_{i=0}^{4} E[x_{t-i}] = 0\n$$\n因此过程 $\\{y_t\\}$ 是零均值的。自协方差函数 $\\gamma_k = E[y_t y_{t-k}]$ 决定了其相关性结构。过程的方差是滞后 $k=0$ 阶的自协方差：\n$$\n\\gamma_0 = E[y_t^2] = E\\left[ \\left(\\frac{1}{5}\\sum_{i=0}^{4} x_{t-i}\\right)^2 \\right] = \\frac{1}{25} E\\left[ \\sum_{i=0}^{4}\\sum_{j=0}^{4} x_{t-i}x_{t-j} \\right]\n$$\n由于 $\\{x_t\\}$ 的独立同分布特性，期望 $E[x_{t-i}x_{t-j}]$ 仅在时间索引匹配时（即 $t-i=t-j$，意味着 $i=j$）才非零。在这种情况下，$E[x_{t-i}^2] = \\sigma^2$。\n$$\n\\gamma_0 = \\frac{1}{25} \\sum_{i=0}^{4} E[x_{t-i}^2] = \\frac{1}{25} \\sum_{i=0}^{4} \\sigma^2 = \\frac{5\\sigma^2}{25} = \\frac{\\sigma^2}{5}\n$$\n对于滞后 $k > 0$，自协方差为：\n$$\n\\gamma_k = E[y_t y_{t-k}] = \\frac{1}{25} E\\left[ \\left(\\sum_{i=0}^{4} x_{t-i}\\right) \\left(\\sum_{j=0}^{4} x_{t-k-j}\\right) \\right]\n$$\n交叉项 $E[x_{t-i}x_{t-k-j}]$ 仅在 $t-i = t-k-j$ 时（可简化为 $j=i-k$）非零。我们必须计算满足此条件且受约束 $i, j \\in \\{0, 1, 2, 3, 4\\}$ 的数对 $(i,j)$ 的数量。对于 $k \\in \\{1, 2, 3, 4\\}$，这样的数对数量为 $5-k$。\n当 $k=1$ 时，有4个数对：$(1,0), (2,1), (3,2), (4,3)$。因此，$\\gamma_1 = \\frac{4\\sigma^2}{25}$。\n当 $k=2$ 时，有3个数对：$(2,0), (3,1), (4,2)$。因此，$\\gamma_2 = \\frac{3\\sigma^2}{25}$。\n当 $k=3$ 时，有2个数对：$(3,0), (4,1)$。因此，$\\gamma_3 = \\frac{2\\sigma^2}{25}$。\n当 $k=4$ 时，有1个数对：$(4,0)$。因此，$\\gamma_4 = \\frac{\\sigma^2}{25}$。\n当 $k \\ge 5$ 时，在指定范围内没有数对 $(i, j)$ 满足条件 $j=i-k$，因此滤波器窗口不重叠。所以，对于所有 $k \\ge 5$，$\\gamma_k = 0$。\n\n总体ACF为 $\\rho_k = \\gamma_k / \\gamma_0$。注意 $\\sigma^2$ 会被消掉。\n$$\n\\rho_k = \\frac{(5-k)\\sigma^2/25}{5\\sigma^2/25} = \\frac{5-k}{5} = 1 - \\frac{k}{5} \\quad \\text{for } k \\in \\{1, 2, 3, 4\\}\n$$\n具体来说，指标 $e_1$ 所需的值为：\n- $\\rho_1 = 4/5 = 0.8$\n- $\\rho_2 = 3/5 = 0.6$\n- $\\rho_3 = 2/5 = 0.4$\n- $\\rho_4 = 1/5 = 0.2$\n\n计算过程涉及模拟该过程并计算样本统计量。\n1.  对于每个测试用例 $(T, \\sigma, \\text{seed})$，使用指定的伪随机种子从正态分布 $\\mathcal{N}(0, \\sigma^2)$ 生成一个包含 $T$ 个独立同分布随机变量的序列 $\\{x_t\\}_{t=0}^{T-1}$。\n2.  通过将 $\\{x_t\\}$ 与滤波器核 $[1/5, 1/5, 1/5, 1/5, 1/5]$ 进行卷积来构建滤波后的序列 $\\{y_t\\}$。取卷积的‘valid’部分，这对应于滤波器与数据完全重叠的索引，从而产生一个长度为 $n = T-4$ 的样本。为便于计算，该样本记为 $\\{y_0, \\dots, y_{n-1}\\}$，其中 $y_j$ 对应于原始时间 $t=j+4$ 处的过程值。\n3.  使用提供的公式计算 $K=20$ 的样本自相关函数（ACF）$\\{\\hat r_k\\}_{k=0}^{K}$：\n    $$\n    \\hat r_k = \\frac{\\sum_{t=k}^{n-1} (y_t-\\bar y)(y_{t-k}-\\bar y)}{\\sum_{t=0}^{n-1} (y_t-\\bar y)^2}\n    $$\n    其中 $\\bar y$ 是 $\\{y_0, \\dots, y_{n-1}\\}$ 的样本均值。分母是中心化后数据的总平方和，分子是滞后 $k$ 阶的样本自协方差。\n4.  计算 $K=20$ 的样本偏自相关函数（PACF）$\\{\\widehat\\phi_k\\}_{k=1}^{K}$。值 $\\widehat\\phi_k$ 定义为 $k$ 阶 Yule-Walker 方程解的最后一个系数。对于每个滞后 $k \\in \\{1, \\dots, K\\}$，我们求解方程组 $\\mathbf{R}_k \\boldsymbol{\\phi}_k = \\mathbf{r}_k$，其中 $\\mathbf{R}_k$ 是一个由样本自相关构成的 $k \\times k$ Toeplitz 矩阵，$(\\mathbf{R}_k)_{ij} = \\hat r_{|i-j|}$，并且 $\\mathbf{r}_k = [\\hat r_1, \\dots, \\hat r_k]^T$。PACF系数 $\\widehat\\phi_k$ 是解向量 $\\boldsymbol{\\phi}_k$ 的第 $k$ 个元素。该方程组可使用专门的 Toeplitz 求解器高效求解。当 $k=1$ 时，$\\widehat\\phi_1$ 就是 $\\hat r_1$。\n5.  在计算出理论值 $\\{\\rho_k\\}$ 和样本统计量 $\\{\\hat r_k\\}, \\{\\widehat\\phi_k\\}$ 后，按规定计算最终指标：\n    - $e_1 = \\max_{k \\in \\{1,2,3,4\\}} | \\hat r_k - \\rho_k |$：该指标衡量在相关性非零的滞后阶数上，样本ACF与真实ACF之间的最大偏差。\n    - $e_2 = \\max_{k \\in \\{5,6,\\dots,20\\}} | \\hat r_k |$：该指标量化了在真实ACF为零的尾部，样本ACF的大小。对于一个MA过程，ACF理想情况下应在滞后 $q=4$ 后截尾。\n    - $e_3 = (\\frac{1}{15}\\sum_{k=6}^{20} |\\widehat\\phi_k|) / (|\\widehat\\phi_1| + 10^{-12})$：该指标评估PACF尾部的行为。对于一个MA过程，PACF预期会指数级衰减，而不是截尾。该指标计算PACF尾部（从滞后6阶开始）的平均大小与第一个PACF系数大小的比值。\n\n实现过程将为每个提供的测试用例精确地遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_toeplitz\n\ndef solve():\n    \"\"\"\n    Solves the time series analysis problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, sigma, seed)\n        (1000, 1.0, 11),\n        (200, 2.0, 22),\n        (80, 0.5, 33),\n        (50, 1.0, 44),\n        (25, 1.0, 55),\n    ]\n\n    all_results = []\n    for T, sigma, seed in test_cases:\n        # Set maximum lag for analysis\n        K = 20\n\n        # Step 1: Generate white noise process {x_t}\n        rng = np.random.default_rng(seed)\n        x = rng.normal(loc=0.0, scale=sigma, size=T)\n\n        # Step 2: Construct filtered series {y_t} via moving average\n        filter_coeffs = np.full(5, 1.0/5.0)\n        # 'valid' convolution generates the series y_t for t=4..T-1\n        # The resulting sample is of length n = T - 4\n        y = np.convolve(x, filter_coeffs, mode='valid')\n        n = len(y)\n\n        # Step 3: Compute sample autocorrelations {r_k}\n        y_mean = np.mean(y)\n        y_demeaned = y - y_mean\n        \n        # The denominator is constant for all lags\n        denom_acf = np.sum(y_demeaned**2)\n        \n        # Ensure denominator is not zero to avoid division errors, though unlikely\n        if denom_acf == 0:\n            r_hat = np.zeros(K + 1)\n        else:\n            r_hat = np.zeros(K + 1)\n            for k in range(K + 1):\n                # Numerator is the sample autocovariance at lag k\n                # sum_{t=k}^{n-1} (y_t-y_bar)(y_{t-k}-y_bar)\n                num_acf = np.dot(y_demeaned[k:], y_demeaned[:n-k])\n                r_hat[k] = num_acf / denom_acf\n\n        # Step 4: Compute sample partial autocorrelations {phi_k}\n        phi_hat = np.zeros(K + 1)  # Index 0 is unused, phi_hat[k] stores phi_k\n        if n > 1:\n            phi_hat[1] = r_hat[1]\n        \n            for k in range(2, K + 1):\n                if k >= n: # Cannot compute if lag k is too large for sample\n                    continue\n                # Solve Yule-Walker equations for PACF at lag k\n                # R_k * phi_k = r_k\n                # R_k is a Toeplitz matrix formed by r_hat[0]...r_hat[k-1]\n                # c is the first column of the Toeplitz matrix\n                c = r_hat[:k]\n                # b is the right-hand side vector\n                b = r_hat[1:k+1]\n                \n                try:\n                    # solve_toeplitz returns the solution to phi_k = [phi_k1, ..., phi_kk]\n                    solution = solve_toeplitz((c, c), b, check_finite=False)\n                    # The PACF at lag k is the last coefficient, phi_kk\n                    phi_hat[k] = solution[-1]\n                except np.linalg.LinAlgError:\n                    # Matrix is singular, PACF is ill-defined. Set to 0.\n                    phi_hat[k] = 0.0\n\n        # Step 5: Define exact (population) autocorrelation values for lags 1-4\n        rho_exact = np.array([0.8, 0.6, 0.4, 0.2])\n\n        # Step 6: Compute the three summary metrics\n        \n        # e1: max deviation of sample ACF from population ACF for lags 1-4\n        e1 = np.max(np.abs(r_hat[1:5] - rho_exact))\n\n        # e2: max magnitude of sample ACF for lags 5-20 (where population ACF is 0)\n        # Slicing up to K+1 to include r_hat[K]\n        e2 = np.max(np.abs(r_hat[5:K+1]))\n\n        # e3: ratio of average PACF tail magnitude to first PACF magnitude\n        phi_hat_abs = np.abs(phi_hat)\n        # Sum over k from 6 to 20 (15 terms)\n        num_e3 = (1.0/15.0) * np.sum(phi_hat_abs[6:K+1])\n        den_e3 = phi_hat_abs[1] + 1e-12\n        e3 = num_e3 / den_e3\n        \n        case_result = [round(e1, 6), round(e2, 6), round(e3, 6)]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The output format is a string representation of a list of lists.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"}]}