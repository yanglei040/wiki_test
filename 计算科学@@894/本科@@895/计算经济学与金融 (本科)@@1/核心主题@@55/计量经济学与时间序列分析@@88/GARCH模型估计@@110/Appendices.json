{"hands_on_practices": [{"introduction": "GARCH 模型的核心在于捕捉波动的持续性，即一个冲击对未来波动的影响会持续多久。这个特性主要由参数 $\\alpha_1$ 和 $\\beta_1$ 的和来衡量。这个动手实践通过计算波动率冲击的“半衰期”，将抽象的参数和转化为一个直观的时间概念，帮助你理解不同参数组合下波动持续性的具体含义。[@problem_id:2395686]", "id": "2395686", "problem": "考虑一个用于零均值收益率过程 $\\left\\{r_t\\right\\}$ 的单变量广义自回归条件异方差(GARCH)模型，其阶数为 $\\left(1,1\\right)$：\n$$r_t=\\epsilon_t,\\quad \\epsilon_t=\\sqrt{h_t}\\,z_t,$$\n其中 $\\left\\{z_t\\right\\}$ 是独立同分布的，其数学期望 $\\mathbb{E}\\left[z_t\\right]=0$ 且方差 $\\mathbb{V}\\mathrm{ar}\\left[z_t\\right]=1$，条件方差 $\\left\\{h_t\\right\\}$ 的过程如下：\n$$h_t=\\omega+\\alpha_1\\,\\epsilon_{t-1}^2+\\beta_1\\,h_{t-1},$$\n参数满足 $\\omega>0$, $\\alpha_1\\ge 0$, $\\beta_1\\ge 0$。在协方差平稳性条件 $\\alpha_1+\\beta_1<1$ 下，单位波动率冲击的影响会以 $\\alpha_1+\\beta_1$ 的速率几何衰减。将波动率冲击的半衰期定义为预期影响衰减至其初始幅度一半所需的时间期数 $k$，由下式给出：\n$$k=\\frac{\\ln\\left(0.5\\right)}{\\ln\\left(\\alpha_1+\\beta_1\\right)},$$\n其中 $\\ln\\left(\\cdot\\right)$ 表示自然对数。对于边界情况 $\\alpha_1+\\beta_1=1$，半衰期取为 $+\\infty$。\n\n您的任务是为下列每一组参数（每组代表一种不同的金融资产）计算半衰期 $k$。将每对 $\\left(\\alpha_1,\\beta_1\\right)$ 视为一个独立的测试用例。假设 $\\omega>0$ 使得 $h_t$ 良定义，并且 $\\alpha_1,\\beta_1$ 满足上述非负约束。按照约定，如果 $\\alpha_1+\\beta_1=1$，该测试用例的输出必须为 $+\\infty$。\n\n测试集（资产与参数）：\n- 资产 A：$\\alpha_1=0.05$，$\\beta_1=0.90$。\n- 资产 B：$\\alpha_1=0.05$，$\\beta_1=0.949$。\n- 资产 C：$\\alpha_1=0.10$，$\\beta_1=0.40$。\n- 资产 D：$\\alpha_1=0.10$，$\\beta_1=0.90$。\n- 资产 E：$\\alpha_1=0.02$，$\\beta_1=0.92$。\n\n对程序输出的要求：\n- 对每种资产，使用上述公式计算半衰期 $k$。\n- 对于边界情况 $\\alpha_1+\\beta_1=1$，输出 $+\\infty$。\n- 对于所有有限的 $k$，四舍五入到恰好 $6$ 位小数。\n- 程序应生成单行输出，其中包含按 A、B、C、D、E 顺序排列的所有结果，格式为一个用方括号括起来的、无空格的逗号分隔列表，例如 $\\left[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D,\\text{result}_E\\right]$。\n- 在输出行中将 $+\\infty$ 直接表示为 $\\text{inf}$。\n\n不涉及物理单位。不涉及角度。每个测试用例的最终答案必须是浮点数，边界情况按规定用 $\\text{inf}$ 表示。解决方案应适用于上面提供的确切参数值，并遵循测试集的顺序。", "solution": "所提出的问题在科学上是适定的，并为获得唯一解提供了足够的信息。任务是在几种不同的参数设置下，计算广义自回归条件异方差（即GARCH($1,1$)）过程中波动率冲击的半衰期。\n\n用于零均值收益率序列 $r_t$ 的GARCH($1,1$)模型由以下方程定义：\n$$r_t = \\epsilon_t$$\n$$\\epsilon_t = \\sqrt{h_t} z_t$$\n其中 $\\{z_t\\}$ 是一个均值为零、方差为一的独立同分布(i.i.d.)过程。条件方差 $h_t$ 按如下方式演变：\n$$h_t = \\omega + \\alpha_1 \\epsilon_{t-1}^2 + \\beta_1 h_{t-1}$$\n波动率冲击的持续性由参数 $\\alpha_1$ 和 $\\beta_1$ 的和决定。这个和，我们记为 $S = \\alpha_1 + \\beta_1$，决定了过去冲击对未来条件方差影响的衰减速率。对于一个协方差平稳过程，要求 $S < 1$。\n\n半衰期 $k$ 定义为冲击的预期影响衰减到其初始值的 $50\\%$ 所需的时间周期数。这由关系式 $(\\alpha_1 + \\beta_1)^k = 0.5$ 决定。求解 $k$ 可得以下公式：\n$$k = \\frac{\\ln(0.5)}{\\ln(\\alpha_1 + \\beta_1)}$$\n此公式在 $\\alpha_1 + \\beta_1 < 1$ 时有效。介于 $0$ 和 $1$ 之间的数的对数是负数，因此分子和分母均为负数，从而得到一个正的半衰期 $k$。\n\n在 $\\alpha_1 + \\beta_1 = 1$ 的特殊情况下，该过程被称为积分GARCH（IGARCH）模型。在这种机制下，冲击对条件方差具有无限持续的效应，因此半衰期 $k$ 被取为 $+\\infty$。\n\n我们现在为每个指定的参数集计算半衰期。\n\n1.  **资产 A**：参数为 $\\alpha_1 = 0.05$ 和 $\\beta_1 = 0.90$。\n    持续性为 $S = 0.05 + 0.90 = 0.95$。\n    半衰期计算如下：\n    $$k_A = \\frac{\\ln(0.5)}{\\ln(0.95)} \\approx \\frac{-0.693147}{-0.051293} \\approx 13.513427$$\n    结果四舍五入到 $6$ 位小数是 $13.513427$。\n\n2.  **资产 B**：参数为 $\\alpha_1 = 0.05$ 和 $\\beta_1 = 0.949$。\n    持续性为 $S = 0.05 + 0.949 = 0.999$。这表明持续性非常高。\n    半衰期计算如下：\n    $$k_B = \\frac{\\ln(0.5)}{\\ln(0.999)} \\approx \\frac{-0.693147}{-0.0010005} \\approx 692.800063$$\n    结果四舍五入到 $6$ 位小数是 $692.800063$。\n\n3.  **资产 C**：参数为 $\\alpha_1 = 0.10$ 和 $\\beta_1 = 0.40$。\n    持续性为 $S = 0.10 + 0.40 = 0.50$。\n    半衰期计算如下：\n    $$k_C = \\frac{\\ln(0.5)}{\\ln(0.5)} = 1$$\n    结果表示为 $6$ 位小数是 $1.000000$。\n\n4.  **资产 D**：参数为 $\\alpha_1 = 0.10$ 和 $\\beta_1 = 0.90$。\n    持续性为 $S = 0.10 + 0.90 = 1.0$。\n    这对应于IGARCH的边界情况。半衰期是无限的。\n    $$k_D = +\\infty$$\n\n5.  **资产 E**：参数为 $\\alpha_1 = 0.02$ 和 $\\beta_1 = 0.92$。\n    持续性为 $S = 0.02 + 0.92 = 0.94$。\n    半衰期计算如下：\n    $$k_E = \\frac{\\ln(0.5)}{\\ln(0.94)} \\approx \\frac{-0.693147}{-0.061875} \\approx 11.202302$$\n    结果四舍五入到 $6$ 位小数是 $11.202302$。\n\n最终结果按要求汇编成一个单一列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the volatility shock half-life for a GARCH(1,1) model\n    for a given test suite of parameters.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains (alpha_1, beta_1) for an asset.\n    test_cases = [\n        (0.05, 0.90),   # Asset A\n        (0.05, 0.949),  # Asset B\n        (0.10, 0.40),   # Asset C\n        (0.10, 0.90),   # Asset D\n        (0.02, 0.92)    # Asset E\n    ]\n\n    results = []\n    for alpha_1, beta_1 in test_cases:\n        # Calculate the shock persistence parameter\n        persistence = alpha_1 + beta_1\n\n        # Check for the boundary case (IGARCH) where persistence is 1.\n        # np.isclose is used for safe floating-point comparison.\n        if np.isclose(persistence, 1.0):\n            result_str = 'inf'\n        else:\n            # Calculate the half-life k using the provided formula.\n            # k = ln(0.5) / ln(alpha_1 + beta_1)\n            half_life = np.log(0.5) / np.log(persistence)\n            # Format the result to exactly 6 decimal places.\n            result_str = f\"{half_life:.6f}\"\n        \n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of results enclosed in square brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "理解了 GARCH 模型的构成后，下一个关键问题是如何估计其参数。标准方法是最大似然估计（MLE），它依赖于数值优化算法来寻找使对数似然函数最大化的参数值。为了使优化过程高效而精确，推导并使用对数似然函数的解析梯度至关重要。本练习将带你深入 GARCH 估计的“引擎盖下”，亲手实现这一核心计算，从而连接计量经济学理论与实际编程。[@problem_id:2395726]", "id": "2395726", "problem": "考虑一个单变量收益率序列 $\\{r_t\\}_{t=1}^T$，该序列由一个阶数为 $\\left(1,1\\right)$ 的广义自回归条件异方差（GARCH）模型建模，该模型具有零条件均值和正态分布误差。该模型由下式给出：\n$$\nr_t = \\varepsilon_t, \\quad \\varepsilon_t \\mid \\mathcal{F}_{t-1} \\sim \\mathcal{N}\\!\\left(0, h_t\\right),\n$$\n其条件方差动态为\n$$\nh_t = \\omega + \\alpha \\,\\varepsilon_{t-1}^2 + \\beta \\,h_{t-1},\n$$\n对于所有 $t \\in \\{1,\\dots,T\\}$，其中参数向量为 $\\theta = \\left(\\omega,\\alpha,\\beta\\right)$，且满足 $\\omega > 0$，$\\alpha \\ge 0$，$\\beta \\ge 0$ 和 $\\alpha + \\beta < 1$。在正态分布假设下，样本的对数似然为\n$$\n\\ell\\!\\left(\\theta\\right) = -\\frac{1}{2}\\sum_{t=1}^{T}\\left[\\log\\!\\left(2\\pi\\right) + \\log\\!\\left(h_t\\right) + \\frac{\\varepsilon_t^2}{h_t}\\right].\n$$\n假设初始化为\n$$\nh_0 = \\frac{\\omega}{1-\\alpha-\\beta}, \\qquad \\varepsilon_0^2 = h_0.\n$$\n\n任务：\n1. 在上述初始化条件下，从第一性原理推导总对数似然 $\\ell\\!\\left(\\theta\\right)$ 关于 $\\theta = \\left(\\omega,\\alpha,\\beta\\right)$ 的解析梯度向量。\n2. 实现一个程序，在给定数据和参数向量 $\\theta$ 的情况下，计算其在 $\\theta$ 处的解析梯度（而非数值近似）。\n\n测试集：\n- 使用长度为 $T = 12$ 的收益率序列，如下所示\n$$\n\\{r_t\\}_{t=1}^{12} = \\{\\,0.004,\\,-0.002,\\,0.006,\\,0.000,\\,-0.007,\\,0.005,\\,-0.0035,\\,0.001,\\,0.000,\\,0.0045,\\,-0.0025,\\,0.003\\,\\}.\n$$\n- 在以下四个参数向量处评估梯度，每个向量都满足 $\\omega > 0$，$\\alpha \\ge 0$，$\\beta \\ge 0$ 和 $\\alpha + \\beta < 1$：\n  1. $\\theta_1 = \\left(0.00001,\\,0.05,\\,0.90\\right)$,\n  2. $\\theta_2 = \\left(0.00001,\\,0.09,\\,0.90\\right)$,\n  3. $\\theta_3 = \\left(0.00002,\\,0.00,\\,0.80\\right)$,\n  4. $\\theta_4 = \\left(0.00002,\\,0.10,\\,0.00\\right)$。\n\n要求的最终输出格式：\n- 您的程序必须产生单行输出，其中包含四个测试案例的梯度向量列表，顺序与上文所列一致，形式为用方括号括起来的、以逗号分隔的列表。将每个梯度向量表示为包含三个实数的列表，顺序为 $\\left[\\frac{\\partial \\ell}{\\partial \\omega},\\,\\frac{\\partial \\ell}{\\partial \\alpha},\\,\\frac{\\partial \\ell}{\\partial \\beta}\\right]$。例如，输出应具有以下形式\n$$\n\\big[\\,[g_{1,\\omega}, g_{1,\\alpha}, g_{1,\\beta}],\\,[g_{2,\\omega}, g_{2,\\alpha}, g_{2,\\beta}],\\,[g_{3,\\omega}, g_{3,\\alpha}, g_{3,\\beta}],\\,[g_{4,\\omega}, g_{4,\\alpha}, g_{4,\\beta}]\\,\\big].\n$$\n\n所有答案均为实数；不涉及物理单位。不涉及角度。计算过程中若出现百分比，最终输出时必须表示为小数。输出必须严格遵循上述指定的单行格式。", "solution": "问题要求推导并实现 GARCH($1$,$1$) 模型对数似然的解析梯度。该问题陈述在科学上是合理的，数学上是适定的且信息完整。我们开始求解。\n\n对于一个条件均值为零的收益率序列 $\\{r_t\\}_{t=1}^T$，所指定的 GARCH($1$,$1$) 模型如下：\n$$\nr_t = \\varepsilon_t, \\quad \\varepsilon_t \\mid \\mathcal{F}_{t-1} \\sim \\mathcal{N}(0, h_t)\n$$\n$$\nh_t = \\omega + \\alpha \\varepsilon_{t-1}^2 + \\beta h_{t-1}\n$$\n参数向量为 $\\theta = (\\omega, \\alpha, \\beta)^T$。大小为 $T$ 的样本的对数似然函数由下式给出：\n$$\n\\ell(\\theta) = -\\frac{1}{2}\\sum_{t=1}^{T}\\left[\\log(2\\pi) + \\log(h_t) + \\frac{r_t^2}{h_t}\\right]\n$$\n其中根据模型定义，我们代入了 $\\varepsilon_t = r_t$。\n\n梯度向量 $\\nabla_\\theta \\ell(\\theta)$ 的分量为 $\\frac{\\partial \\ell}{\\partial \\omega}$、$\\frac{\\partial \\ell}{\\partial \\alpha}$ 和 $\\frac{\\partial \\ell}{\\partial \\beta}$。令 $\\theta_j$ 为 $\\theta$ 的一个通用分量。对求和应用链式法则，得到总对数似然关于 $\\theta_j$ 的偏导数：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_j} = \\sum_{t=1}^{T} \\frac{\\partial}{\\partial \\theta_j} \\left(-\\frac{1}{2} \\left[ \\log(h_t) + \\frac{r_t^2}{h_t} \\right]\\right) = \\sum_{t=1}^{T} \\left( -\\frac{1}{2} \\left[ \\frac{1}{h_t} - \\frac{r_t^2}{h_t^2} \\right] \\right) \\frac{\\partial h_t}{\\partial \\theta_j}\n$$\n该表达式可简化为：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_j} = \\sum_{t=1}^{T} \\frac{1}{2h_t^2} \\left( r_t^2 - h_t \\right) \\frac{\\partial h_t}{\\partial \\theta_j}\n$$\n为评估此梯度，我们必须计算条件方差的时间序列 $\\{h_t\\}_{t=1}^T$ 及其关于每个参数的偏导数 $\\{\\frac{\\partial h_t}{\\partial \\theta_j}\\}_{t=1}^T$。这些都可以通过从 GARCH($1$,$1$) 方差方程推导出的递推关系获得。\n\n首先，我们建立 $\\{h_t\\}$ 的递推关系。问题指定了初始化 $h_0 = \\frac{\\omega}{1-\\alpha-\\beta}$ 和 $\\varepsilon_0^2 = h_0$。对于 $t>1$，$\\varepsilon_{t-1}^2 = r_{t-1}^2$ 由数据给出。$t=1$ 时的条件方差为：\n$$\nh_1 = \\omega + \\alpha \\varepsilon_0^2 + \\beta h_0 = \\omega + (\\alpha + \\beta) h_0 = \\omega + (\\alpha + \\beta) \\frac{\\omega}{1-\\alpha-\\beta} = \\frac{\\omega(1-\\alpha-\\beta) + \\omega(\\alpha+\\beta)}{1-\\alpha-\\beta} = \\frac{\\omega}{1-\\alpha-\\beta}\n$$\n这是该过程的无条件方差。对于 $t=2, \\dots, T$，方差通过递推计算：\n$$\nh_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}\n$$\n\n接下来，我们推导 $h_t$ 偏导数的递推公式。\n\n**1. 关于 $\\omega$ 的导数**\n我们将 $h_t$ 的表达式对 $\\omega$ 求导。\n对于 $t=1$：\n$$ \\frac{\\partial h_1}{\\partial \\omega} = \\frac{\\partial}{\\partial \\omega} \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right) = \\frac{1}{1-\\alpha-\\beta} $$\n对于 $t > 1$：\n$$ \\frac{\\partial h_t}{\\partial \\omega} = \\frac{\\partial}{\\partial \\omega} (\\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}) = 1 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\omega} $$\n这为 $\\{\\frac{\\partial h_t}{\\partial \\omega}\\}_{t=1}^T$ 定义了一个简单的线性递推关系。\n\n**2. 关于 $\\alpha$ 的导数**\n我们对 $\\alpha$ 求导。对于 $t=1$：\n$$ \\frac{\\partial h_1}{\\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right) = \\omega(-1)(1-\\alpha-\\beta)^{-2}(-1) = \\frac{\\omega}{(1-\\alpha-\\beta)^2} $$\n对于 $t > 1$，$r_{t-1}^2$ 是一个固定的数据点，其关于 $\\alpha$ 的导数为零：\n$$ \\frac{\\partial h_t}{\\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} (\\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}) = r_{t-1}^2 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\alpha} $$\n\n**3. 关于 $\\beta$ 的导数**\n我们对 $\\beta$ 求导。对于 $t=1$：\n$$ \\frac{\\partial h_1}{\\partial \\beta} = \\frac{\\partial}{\\partial \\beta} \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right) = \\omega(-1)(1-\\alpha-\\beta)^{-2}(-1) = \\frac{\\omega}{(1-\\alpha-\\beta)^2} $$\n对于 $t > 1$：\n$$ \\frac{\\partial h_t}{\\partial \\beta} = \\frac{\\partial}{\\partial \\beta} (\\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}) = h_{t-1} + \\beta \\frac{\\partial h_{t-1}}{\\partial \\beta} $$\n\n**算法总结**\n\n为计算给定参数集 $\\theta = (\\omega, \\alpha, \\beta)$ 和收益率序列 $\\{r_t\\}_{t=1}^T$ 的梯度向量 $\\nabla_\\theta \\ell(\\theta)$，我们执行以下步骤：\n\n1.  初始化长度为 $T$ 的数组，用于存储序列 $h_t$、$\\frac{\\partial h_t}{\\partial \\omega}$、$\\frac{\\partial h_t}{\\partial \\alpha}$ 和 $\\frac{\\partial h_t}{\\partial \\beta}$（$t=1, \\dots, T$）。\n2.  计算 $t=1$ 时的初始值：\n    -   $h_1 = \\frac{\\omega}{1-\\alpha-\\beta}$\n    -   $\\frac{\\partial h_1}{\\partial \\omega} = \\frac{1}{1-\\alpha-\\beta}$\n    -   $\\frac{\\partial h_1}{\\partial \\alpha} = \\frac{\\omega}{(1-\\alpha-\\beta)^2}$\n    -   $\\frac{\\partial h_1}{\\partial \\beta} = \\frac{\\omega}{(1-\\alpha-\\beta)^2}$\n3.  从 $t=2$ 迭代到 $T$，使用先前计算的 $t-1$ 时的值来计算每个序列的值：\n    -   $h_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}$\n    -   $\\frac{\\partial h_t}{\\partial \\omega} = 1 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\omega}$\n    -   $\\frac{\\partial h_t}{\\partial \\alpha} = r_{t-1}^2 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\alpha}$\n    -   $\\frac{\\partial h_t}{\\partial \\beta} = h_{t-1} + \\beta \\frac{\\partial h_{t-1}}{\\partial \\beta}$\n4.  将梯度分量 $(\\frac{\\partial \\ell}{\\partial \\omega}, \\frac{\\partial \\ell}{\\partial \\alpha}, \\frac{\\partial \\ell}{\\partial \\beta})$ 初始化为零。\n5.  从 $t=1$ 迭代到 $T$，计算每个时间步对总梯度的贡献并累加求和：\n    -   公共因子：$c_t = \\frac{1}{2h_t^2} ( r_t^2 - h_t )$\n    -   $\\frac{\\partial \\ell}{\\partial \\omega} \\mathrel{+}= c_t \\cdot \\frac{\\partial h_t}{\\partial \\omega}$\n    -   $\\frac{\\partial \\ell}{\\partial \\alpha} \\mathrel{+}= c_t \\cdot \\frac{\\partial h_t}{\\partial \\alpha}$\n    -   $\\frac{\\partial \\ell}{\\partial \\beta} \\mathrel{+}= c_t \\cdot \\frac{\\partial h_t}{\\partial \\beta}$\n6.  最终累加的和构成了梯度向量。此过程在提供的程序中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_garch_gradient(r, omega, alpha, beta):\n    \"\"\"\n    Computes the analytical gradient of the GARCH(1,1) log-likelihood.\n\n    Args:\n        r (np.ndarray): The series of returns.\n        omega (float): GARCH parameter omega.\n        alpha (float): GARCH parameter alpha.\n        beta (float): GARCH parameter beta.\n\n    Returns:\n        list[float]: The gradient vector [d_ell/d_omega, d_ell/d_alpha, d_ell/d_beta].\n    \"\"\"\n    T = len(r)\n    r_sq = r**2\n\n    # Arrays to store h_t and its derivatives\n    h = np.zeros(T)\n    dh_domega = np.zeros(T)\n    dh_dalpha = np.zeros(T)\n    dh_dbeta = np.zeros(T)\n    \n    # Check for stationarity condition to avoid division by zero\n    stat_denom = 1.0 - alpha - beta\n    if stat_denom <= 0:\n        # Parameters violate the stationarity constraint, which would make h0 infinite or negative.\n        # This case is not expected for the given valid test cases but is good practice.\n        return [np.nan, np.nan, np.nan]\n\n    # Initialization for t=1 (index 0)\n    # h_1 = omega / (1 - alpha - beta)\n    h[0] = omega / stat_denom\n    \n    # Derivatives of h_1\n    # dh1/d_omega = 1 / (1 - alpha - beta)\n    dh_domega[0] = 1.0 / stat_denom\n    # dh1/d_alpha = omega / (1 - alpha - beta)^2\n    dh_dalpha[0] = omega / (stat_denom**2)\n    # dh1/d_beta = omega / (1 - alpha - beta)^2\n    dh_dbeta[0] = omega / (stat_denom**2)\n    \n    # Recursive calculation for t = 2 to T (indices 1 to T-1)\n    for t in range(1, T):\n        # h_t = omega + alpha * r_{t-1}^2 + beta * h_{t-1}\n        h[t] = omega + alpha * r_sq[t-1] + beta * h[t-1]\n        \n        # dh_t/d_omega = 1 + beta * dh_{t-1}/d_omega\n        dh_domega[t] = 1.0 + beta * dh_domega[t-1]\n        \n        # dh_t/d_alpha = r_{t-1}^2 + beta * dh_{t-1}/d_alpha\n        dh_dalpha[t] = r_sq[t-1] + beta * dh_dalpha[t-1]\n        \n        # dh_t/d_beta = h_{t-1} + beta * dh_{t-1}/d_beta\n        dh_dbeta[t] = h[t-1] + beta * dh_dbeta[t-1]\n        \n    # Compute the gradient of the log-likelihood\n    grad_omega = 0.0\n    grad_alpha = 0.0\n    grad_beta = 0.0\n    \n    for t in range(T):\n        common_factor = 0.5 * (r_sq[t] / h[t] - 1.0) / h[t]\n        grad_omega += common_factor * dh_domega[t]\n        grad_alpha += common_factor * dh_dalpha[t]\n        grad_beta += common_factor * dh_dbeta[t]\n\n    return [grad_omega, grad_alpha, grad_beta]\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the data and test cases from the problem statement.\n    returns_data = np.array([\n        0.004, -0.002, 0.006, 0.000, -0.007, 0.005, \n        -0.0035, 0.001, 0.000, 0.0045, -0.0025, 0.003\n    ])\n    \n    test_cases = [\n        (0.00001, 0.05, 0.90),  # theta_1\n        (0.00001, 0.09, 0.90),  # theta_2\n        (0.00002, 0.00, 0.80),  # theta_3\n        (0.00002, 0.10, 0.00)   # theta_4\n    ]\n\n    results = []\n    for params in test_cases:\n        omega, alpha, beta = params\n        gradient = compute_garch_gradient(returns_data, omega, alpha, beta)\n        results.append(gradient)\n\n    # Format the results into the required string format.\n    # The string representation of a list in Python already includes brackets and spaces.\n    # Joining the string representations of each gradient list with a comma\n    # and enclosing in outer brackets produces the desired format.\n    # e.g., \"[[g1_w, g1_a, g1_b],[g2_w, g2_a, g2_b]]\"\n    result_str = f\"[{','.join(map(str, results))}]\"\n    \n    # To remove spaces for a more compact representation, though not strictly required by example\n    result_str_no_space = result_str.replace(\" \", \"\")\n\n    print(result_str_no_space)\n\nsolve()\n```"}, {"introduction": "在应用计量经济模型时，一个核心挑战是模型设定误差：一个看似拟合良好的模型可能并非源于其正确捕捉了数据的真实生成过程。本练习旨在揭示一个经典的陷阱：当一个时间序列的均值存在未被建模的结构性突变时，它所产生的序列相关性可能被错误地识别为 GARCH 效应。通过完成这项模拟研究，你将培养模型诊断的批判性思维，并学会在应用 GARCH 模型前审慎地检验数据。[@problem_id:2399496]", "id": "2399496", "problem": "您的任务是设计并实现一个仿真和测试程序，用以研究时间序列均值中的结构性断点如何会被标准的自回归条件异方差检验错误地识别为记作 $GARCH(1,1)$ 的一阶广义自回归条件异方差。您的程序必须完全独立，无需任何用户交互即可产生结果。\n\n使用的基本依据包括以下经过充分检验的定义和事实。\n\n- 一个时间序列 $\\{y_t\\}_{t=1}^T$ 在已知时间 $T_b$ 的均值上存在结构性断点，是指其确定性均值在 $t = T_b + 1$ 时从 $\\mu_1$ 变为 $\\mu_2$，而创新项方差保持不变。具体来说，对于 $t \\le T_b$，$y_t = \\mu_1 + \\varepsilon_t$；对于 $t > T_b$，$y_t = \\mu_2 + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n- 一个普通最小二乘法 (OLS) 均值模型为 $y_t = x_t^{\\prime}\\beta + \\varepsilon_t$，其中 $x_t$ 包含一个截距项以及（在适用时）额外的回归量，例如断点虚拟变量 $d_t$（当 $t \\le T_b$ 时，$d_t = 0$；当 $t > T_b$ 时，$d_t = 1$）。OLS残差为 $e_t = y_t - x_t^{\\prime}\\hat{\\beta}$。\n- 针对零均值创新项 $\\{u_t\\}$ 的 $GARCH(1,1)$ 模型为 $u_t = \\sqrt{h_t} z_t$，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$，条件方差为 $h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}$。参数需满足 $\\omega > 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$ 以及 $\\alpha + \\beta < 1$ 以确保无条件方差有限。观测到的序列是 $y_t = \\mu + u_t$。\n- 针对一个 OLS 残差序列 $\\{e_t\\}$ 的 $q$ 阶自回归条件异方差的 Engle 拉格朗日乘子 (LM) 检验，其步骤是将 $e_t^2$ 对一个常数项和 $e_t^2$ 的 $q$ 阶滞后项进行回归，计算决定系数 $R^2$，并构建统计量 $LM = n R^2$，其中 $n$ 是该回归中可用观测值的数量。在截至滞后 $q$ 阶不存在自回归条件异方差的原假设下，$LM$ 渐近服从自由度为 $q$ 的 $\\chi^2_q$ 分布。$p$-值是 $1 - F_{\\chi^2_q}(LM)$，其中 $F_{\\chi^2_q}$ 是自由度为 $q$ 的卡方分布的累积分布函数。\n\n您的任务是精确地实施以下步骤。\n\n1. 数据生成过程 (DGP) 的仿真：\n   - 均值存在结构性断点且方差恒定：对于给定的参数 $T$, $\\mu_1$, $\\mu_2$, $\\sigma$ 和断点分数 $b \\in (0,1)$，按照上述描述仿真 $\\{y_t\\}$，其中 $T_b = \\lfloor b T \\rfloor$，$\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n   - 无断点的独立同分布 (iid) 同方差序列：$y_t = \\mu + \\varepsilon_t$，$\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n   - 无均值断点的 $GARCH(1,1)$ 序列：$y_t = \\mu + u_t$，其中 $u_t$ 遵循上文定义的 $GARCH(1,1)$ 过程。将 $h_0$ 初始化为无条件方差 $h_0 = \\omega/(1-\\alpha-\\beta)$，并使用 500 步的初始预烧期以减轻初始化效应。\n\n2. 建模与残差提取：\n   - 对每个仿真序列，拟合两个 OLS 均值模型以获得残差 $\\{e_t\\}$：\n     - 错误设定的均值：对所有 $t$ 采用仅含截距项的模型 $x_t = [1]$。\n     - 正确设定的均值：当 DGP 存在结构性断点时，采用截距项加断点虚拟变量，即 $x_t = [1, d_t]$；否则采用仅含截距项的模型。\n\n3. 自回归条件异方差检验：\n   - 对每组残差和指定的滞后阶数 $q$，运行上述 Engle LM 检验，并基于 $\\chi^2_q$ 分布计算 $p$-值。\n\n4. 解释原则（用于您的推理，不属于输出部分）：低 $p$-值表示拒绝无自回归条件异方差的原假设。需要观察的核心现象是，当均值设定错误时，均值中的结构性断点会引致 $e_t^2$ 的序列相关性，从而导致对 $GARCH$-类行为的伪检测。\n\n使用以下参数集测试套件。所有随机抽样必须使用相同的固定种子 $12345$ 生成，以确保结果可复现。\n\n- 测试用例 1（理想路径，样本中期的强断点）：\n  - DGP: 均值存在结构性断点且方差恒定。\n  - 参数: $T = 4000$, $\\mu_1 = 0.0$, $\\mu_2 = 2.0$, $\\sigma = 1.0$, $b = 0.5$, $q = 5$。\n\n- 测试用例 2（边界条件，后期断点，检验中最小滞后）：\n  - DGP: 均值存在结构性断点且方差恒定。\n  - 参数: $T = 4000$, $\\mu_1 = 0.0$, $\\mu_2 = 3.0$, $\\sigma = 1.0$, $b = 0.9$, $q = 1$。\n\n- 测试用例 3（边缘情况，真实的 $GARCH(1,1)$）：\n  - DGP: 无均值断点的 $GARCH(1,1)$。\n  - 参数: $T = 5000$, $\\mu = 0.0$, $\\omega = 0.1$, $\\alpha = 0.05$, $\\beta = 0.9$, $q = 5$。\n\n- 测试用例 4（对照组，iid 同方差）：\n  - DGP: 无均值断点的同方差 iid。\n  - 参数: $T = 4000$, $\\mu = 0.0$, $\\sigma = 1.0$, $q = 5$。\n\n每个测试用例的必需输出：\n\n- 对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算两个 $p$-值：\n  - $p^{(i)}_{\\text{misspec}}$: 使用仅含截距项均值模型的 LM 检验 $p$-值。\n  - $p^{(i)}_{\\text{well}}$: 使用正确设定的均值模型（仅在适用时包含断点虚拟变量）的 LM 检验 $p$-值。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中包含 8 个结果，顺序严格按照\n  $[p^{(1)}_{\\text{misspec}}, p^{(1)}_{\\text{well}}, p^{(2)}_{\\text{misspec}}, p^{(2)}_{\\text{well}}, p^{(3)}_{\\text{misspec}}, p^{(3)}_{\\text{well}}, p^{(4)}_{\\text{misspec}}, p^{(4)}_{\\text{well}}]$，\n  每个值四舍五入到六位小数。例如，输出可能看起来像 $[0.000001,0.845210,0.000004,0.612345,0.000000,0.000000,0.523410,0.523410]$。\n\n本问题中的所有量均为无单位的实数，不涉及任何物理单位。不使用角度。在概念上引用百分比时，必须将其视为小数；但是，您必须仅输出上述指定的 $p$-值。", "solution": "该问题陈述已经过严格验证，并被认定为有效。它在科学上植根于成熟的计量经济学理论，特别是时间序列错误设定的研究。该问题定义明确，为获得唯一、可验证的解提供了完整且一致的定义、参数和程序。不存在逻辑矛盾、歧义或事实错误。此任务是计量经济学中的一个标准计算练习，而非寻求主观看法或推测性推理。我们现在开始系统性地求解。\n\n目标是通过计算来证明，如果未能正确建模，时间序列均值中的结构性断点会如何产生自回归条件异方差（ARCH）的伪证据——这一现象在实践中可能导致错误模型选择。解决方案分为三个主要阶段：数据仿真、模型估计与残差提取、以及假设检验。\n\n首先，我们处理指定的三种不同数据生成过程（DGP）的仿真。所有随机操作均使用固定的随机种子 $12345$，以确保可复现性。\n\n1.  **结构性断点序列**：一个时间序列 $\\{y_t\\}_{t=1}^T$ 根据以下模型生成，其均值存在单个断点：\n    $$\n    y_t =\n    \\begin{cases}\n    \\mu_1 + \\varepsilon_t & \\text{for } t \\le T_b \\\\\n    \\mu_2 + \\varepsilon_t & \\text{for } t > T_b\n    \\end{cases}\n    $$\n    其中断点为 $T_b = \\lfloor bT \\rfloor$（对于给定的断点分数 $b \\in (0,1)$），创新项 $\\varepsilon_t$ 是从正态分布 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0, \\sigma^2)$ 中抽取的独立同分布（iid）样本。\n\n2.  **$GARCH(1,1)$ 序列**：一个受广义自回归条件异方差过程 $(1,1)$ 支配的时间序列 $\\{y_t\\}_{t=1}^T$ 生成为 $y_t = \\mu + u_t$。创新项 $u_t$ 定义为 $u_t = \\sqrt{h_t} z_t$，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$。条件方差 $h_t$ 按如下方式演变：\n    $$\n    h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}\n    $$\n    参数必须满足平稳性条件 $\\omega > 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$, 和 $\\alpha + \\beta < 1$。仿真以 $h_0$ 设置为无条件方差 $h_{uncond} = \\frac{\\omega}{1-\\alpha-\\beta}$ 进行初始化，并生成一个 500 个点的初始样本随后丢弃，以减轻初始化偏差。\n\n3.  **IID 同方差序列**：这是一个作为基线的对照序列，生成方式为 $y_t = \\mu + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0, \\sigma^2)$。\n\n其次，对于每个仿真序列 $\\{y_t\\}$，从两种不同的普通最小二乘法（OLS）均值模型设定中获取残差。通用的 OLS 模型为 $y_t = x_t^{\\prime}\\beta + e_t$，其中 $x_t$ 是回归量向量，$\\beta$ 是系数向量，$e_t$ 是残差。$\\beta$ 的 OLS 估计量为 $\\hat{\\beta} = (X'X)^{-1}X'y$，其中 $X$ 和 $y$ 分别是回归量和因变量的矩阵和向量形式。残差随后计算为 $e = y - X\\hat{\\beta}$。\n\n1.  **错误设定的模型**：该模型始终假设一个简单的常数均值，通过单个回归量——一个截距项来实现。因此，对于所有 $t$，$x_t = [1]$。对于有结构性断点的 DGP，此模型是错误设定的。\n\n2.  **正确设定的模型**：该模型正确地反映了 DGP 的潜在均值结构。对于结构性断点 DGP，回归量是一个截距项和一个断点虚拟变量 $d_t$，其中当 $t \\le T_b$ 时 $d_t=0$，当 $t > T_b$ 时 $d_t=1$。因此，$x_t = [1, d_t]$。对于 GARCH 和 IID DGP，由于它们具有常数均值，正确设定的模型与错误设定的模型相同，仅包含一个截距项。\n\n第三，将从每个模型中提取的残差序列 $\\{e_t\\}$ 用于进行 $q$ 阶 ARCH 效应的 Engle 拉格朗日乘子（LM）检验。该检验的原假设是在滞后 $q$ 阶内不存在 ARCH，即在辅助回归中 $H_0: \\gamma_1 = \\gamma_2 = \\dots = \\gamma_q = 0$：\n$$\ne_t^2 = \\gamma_0 + \\gamma_1 e_{t-1}^2 + \\dots + \\gamma_q e_{t-q}^2 + \\nu_t\n$$\nLM 检验统计量计算为 $LM = nR^2$，其中 $n$ 是辅助回归中的观测数量（$n = T-q$），$R^2$ 是该回归的决定系数。在原假设下，LM 统计量渐近服从自由度为 $q$ 的卡方分布，$LM \\sim \\chi^2_q$。$p$-值，即观测到至少与计算出的检验统计量一样极端的统计量的概率，由 $1 - F_{\\chi^2_q}(LM)$ 给出，其中 $F_{\\chi^2_q}$ 是 $\\chi^2_q$ 分布的累积分布函数。\n\n一个低的 $p$-值（例如，< 0.05）导致拒绝原假设，表明存在 ARCH 效应。分析的核心在于比较结构性断点 DGP 中，来自错误设定模型和正确设定模型的 $p$-值。如果错误设定的模型产生低的 $p$-值而正确设定的模型产生高的 $p$-值，则证实了 ARCH 的伪检测。对于 GARCH DGP，预计两个模型都会产生低的 $p$-值。对于 IID DGP，预计两者都会产生高的 $p$-值。对四个指定的测试用例中的每一个都实施整个过程，以生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    # Establish a reproducible random number generator\n    rng = np.random.default_rng(12345)\n\n    def generate_structural_break(T, mu1, mu2, sigma, b, rng_gen):\n        \"\"\"Generates a time series with a structural break in the mean.\"\"\"\n        Tb = int(np.floor(b * T))\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = np.zeros(T)\n        y[:Tb] = mu1 + innovations[:Tb]\n        y[Tb:] = mu2 + innovations[Tb:]\n        return y, Tb\n\n    def generate_garch(T, mu, omega, alpha, beta, rng_gen):\n        \"\"\"Generates a GARCH(1,1) time series.\"\"\"\n        burn_in = 500\n        total_len = T + burn_in\n        \n        z = rng_gen.normal(loc=0.0, scale=1.0, size=total_len)\n        u = np.zeros(total_len)\n        h = np.zeros(total_len)\n        \n        h[0] = omega / (1 - alpha - beta)\n        u[0] = np.sqrt(h[0]) * z[0]\n        \n        for t in range(1, total_len):\n            h[t] = omega + alpha * u[t-1]**2 + beta * h[t-1]\n            u[t] = np.sqrt(h[t]) * z[t]\n        \n        y = mu + u[burn_in:]\n        return y\n\n    def generate_iid(T, mu, sigma, rng_gen):\n        \"\"\"Generates an IID homoskedastic time series.\"\"\"\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = mu + innovations\n        return y\n\n    def get_residuals(y, with_break_dummy, Tb=None):\n        \"\"\"\n        Fits an OLS model to the data and returns the residuals.\n        \"\"\"\n        T = len(y)\n        if with_break_dummy:\n            if Tb is None:\n                raise ValueError(\"Tb must be provided for break dummy model.\")\n            X = np.ones((T, 2))\n            dummy = np.zeros(T)\n            dummy[Tb:] = 1.0\n            X[:, 1] = dummy\n        else:\n            X = np.ones((T, 1))\n\n        beta_hat = np.linalg.lstsq(X, y, rcond=None)[0]\n        y_hat = X @ beta_hat\n        residuals = y - y_hat\n        return residuals\n\n    def engle_lm_test(residuals, q):\n        \"\"\"\n        Performs the Engle LM test for ARCH effects.\n        \"\"\"\n        T = len(residuals)\n        e_sq = residuals**2\n        \n        # Dependent variable for the auxiliary regression\n        Y_aux = e_sq[q:]\n        n = len(Y_aux) # n = T - q\n        \n        # Independent variables (constant + q lags of e_sq)\n        X_aux = np.ones((n, q + 1))\n        for i in range(q):\n            # lag i+1\n            X_aux[:, i + 1] = e_sq[q - 1 - i : T - 1 - i]\n            \n        # OLS on the auxiliary regression\n        try:\n            # lstsq returns sum of squared residuals in the second element\n            rss_val = np.linalg.lstsq(X_aux, Y_aux, rcond=None)[1][0]\n        except IndexError:\n            # This can happen if the problem is perfectly determined, rss is empty.\n            rss_val = 0.0\n\n        # Total sum of squares of the dependent variable\n        tss = np.sum((Y_aux - np.mean(Y_aux))**2)\n        \n        if tss < 1e-12: # Handle cases with zero variance\n             R2 = 0.0\n        else:\n            R2 = 1 - rss_val / tss\n\n        lm_stat = n * R2\n        p_value = 1 - chi2.cdf(lm_stat, q)\n        \n        return p_value\n\n    test_cases = [\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 2.0, 'sigma': 1.0, 'b': 0.5, 'q': 5}},\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 3.0, 'sigma': 1.0, 'b': 0.9, 'q': 1}},\n        {'type': 'garch', 'params': {'T': 5000, 'mu': 0.0, 'omega': 0.1, 'alpha': 0.05, 'beta': 0.9, 'q': 5}},\n        {'type': 'iid', 'params': {'T': 4000, 'mu': 0.0, 'sigma': 1.0, 'q': 5}}\n    ]\n    \n    results = []\n    \n    # Test case 1\n    case = test_cases[0]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n    \n    # Test case 2\n    case = test_cases[1]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n\n    # Test case 3\n    case = test_cases[2]\n    params = case['params']\n    y = generate_garch(params['T'], params['mu'], params['omega'], params['alpha'], params['beta'], rng)\n    # For GARCH DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Test case 4\n    case = test_cases[3]\n    params = case['params']\n    y = generate_iid(params['T'], params['mu'], params['sigma'], rng)\n    # For IID DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```"}]}