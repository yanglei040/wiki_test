{"hands_on_practices": [{"introduction": "在深入研究波动率模型的估计与检验之前，首要任务是透彻理解其核心机制。本练习将指导你将一个因子-GARCH模型的数学表达式转化为可执行的代码。通过这个过程，你将亲手实现条件方差的递归计算，并了解如何将一个可观测的外部因子（如市场波动率指数VIX）整合进单个资产的波动率模型中，这是掌握更复杂应用的基础。[@problem_id:2411181]", "id": "2411181", "problem": "要求您实现一个简单的因子-广义自回归条件异方差（Factor-GARCH）模型，在该模型中，一个可观测的全市场波动率因子，例如芝加哥期权交易所（CBOE）波动率指数（VIX），会影响单个资产回报过程的条件方差。\n\n请从以下基本原则和定义开始：\n- 资产回报的程式化事实：资产回报表现出波动率聚集性，即大的（小的）冲击之后往往跟随着大的（小的）冲击。\n- 条件方差建模：向前一期的条件方差被建模为其自身滞后项和滞后平方新息的函数。\n- 条件异方差过程的高斯（正态）对数似然。\n\n模型设定：\n- 设回报序列为 $\\{r_t\\}_{t=1}^T$，可观测的非负因子序列为 $\\{f_t\\}_{t=1}^T$，条件方差序列为 $\\{h_t\\}_{t=1}^T$。\n- 观测方程为 $r_t = \\sqrt{h_t}\\,\\varepsilon_t$，其中 $\\varepsilon_t \\sim \\text{i.i.d. } \\mathcal{N}(0,1)$。\n- 方差递归式（带一阶滞后的因子-GARCH）为\n$$\nh_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1} + \\phi f_{t-1},\n$$\n参数满足 $\\omega \\ge 0$、$\\alpha \\ge 0$、$\\beta \\ge 0$、$\\phi \\ge 0$。为保证数值稳定性和现实性，假设对所有 $t$ 都有 $\\alpha + \\beta < 1$ 且 $f_t \\ge 0$。\n- 初始化：\n  - 设置 $r_0 = 0$ 和 $f_0 = f_1$。\n  - 设置一个小的下限 $\\epsilon = 10^{-8}$ 以确保正值。\n  - 初始化\n  $$\n  h_0 = \\max\\left(\\epsilon,\\ \\frac{\\omega}{\\max(1 - \\alpha - \\beta,\\ \\epsilon)} + \\phi f_0\\right).\n  $$\n  - 对于每个 $t \\in \\{1,\\dots,T\\}$，通过递归计算 $h_t$，并强制 $h_t \\leftarrow \\max(h_t, \\epsilon)$。\n- 向前一步的方差预测为\n$$\nh_{T+1} = \\omega + \\alpha r_T^2 + \\beta h_T + \\phi f_T,\n$$\n并强制其至少为 $\\epsilon$。\n- 高斯负对数似然为\n$$\n\\text{NLL} = \\frac{1}{2}\\sum_{t=1}^T \\left(\\ln(2\\pi) + \\ln(h_t) + \\frac{r_t^2}{h_t}\\right).\n$$\n\n您的任务：\n- 实现一个程序，对于下述每个测试用例，计算三个量：最终的条件方差 $h_T$、向前一步的预测值 $h_{T+1}$以及高斯负对数似然 $\\text{NLL}$。\n- 严格使用上述初始化和递归规则。\n- 将每个报告的量四舍五入到 $6$ 位小数。\n\n测试套件：\n- 使用以下回报序列和因子序列，其中所有值都是无量纲的：\n  - 序列 A（用于案例 $1$、$2$、$3$）：\n    - 回报：$[0.01,\\ -0.02,\\ 0.015,\\ -0.005,\\ 0.0,\\ 0.02,\\ -0.015,\\ 0.01]$\n    - 因子：$[0.20,\\ 0.25,\\ 0.22,\\ 0.24,\\ 0.21,\\ 0.23,\\ 0.26,\\ 0.22]$\n  - 序列 B（用于案例 $4$）：\n    - 回报：$[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0]$\n    - 因子：$[0.10,\\ 0.20,\\ 0.30,\\ 0.25,\\ 0.15]$\n\n- 案例和参数 $(\\omega,\\ \\alpha,\\ \\beta,\\ \\phi)$：\n  - 案例 $1$（理想路径）：使用序列 A，参数为 $(0.0001,\\ 0.10,\\ 0.85,\\ 0.05)$。\n  - 案例 $2$（无因子效应）：使用序列 A，参数为 $(0.0001,\\ 0.10,\\ 0.85,\\ 0.00)$。\n  - 案例 $3$（近边界持续性）：使用序列 A，参数为 $(0.00005,\\ 0.08,\\ 0.91,\\ 0.07)$。\n  - 案例 $4$（零回报下的纯因子驱动）：使用序列 B，参数为 $(0.0001,\\ 0.00,\\ 0.90,\\ 0.20)$。\n\n要求的输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 对于每个案例，按顺序输出 $h_T$、$h_{T+1}$ 和 $\\text{NLL}$，均四舍五入到 $6$ 位小数。\n- 按案例 $1$、案例 $2$、案例 $3$、案例 $4$ 的顺序汇总所有案例并展平输出。例如，最终输出应如下所示：\n$[h_T^{(1)}, h_{T+1}^{(1)}, \\text{NLL}^{(1)}, h_T^{(2)}, h_{T+1}^{(2)}, \\text{NLL}^{(2)}, h_T^{(3)}, h_{T+1}^{(3)}, \\text{NLL}^{(3)}, h_T^{(4)}, h_{T+1}^{(4)}, \\text{NLL}^{(4)}]$,\n其中每个条目都打印到 $6$ 位小数。", "solution": "所提出的问题是金融计量经济学领域中一个明确定义的计算任务。它具有科学依据和数学一致性，并为得出唯一解提供了所有必要信息。所指定的模型，即因子-GARCH($1,1$)过程，是广义自回归条件异方差（GARCH）框架的一个标准扩展，旨在捕捉经验上观察到的资产回报中的波动率聚集现象。引入外部因子使模型能够解释影响单个资产方差的全市场波动率冲击。該問題是有效的，可以通過仔細實現指定的演算法來構建解決方案。\n\n问题的核心是为资产回报序列 $\\{r_t\\}_{t=1}^T$ 的条件方差 $h_t$ 建模。时间 $t$ 的回报由观测方程 $r_t = \\sqrt{h_t}\\,\\varepsilon_t$ 定义，其中 $\\varepsilon_t$ 是服从标准正态分布 $\\mathcal{N}(0,1)$ 的独立同分布随机变量。这意味着在给定直至时间 $t-1$ 的信息条件下，$r_t$ 的条件分布是均值为 $0$、方差为 $h_t$ 的正态分布。\n\n条件方差的演变由因子-GARCH($1,1$)递归式描述：\n$$\nh_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1} + \\phi f_{t-1}\n$$\n该方程有四个组成部分：\n1.  常数截距项 $\\omega$，它为方差提供了一个基准水平。\n2.  ARCH 项 $\\alpha r_{t-1}^2$，它捕捉了上一期平方冲击（平方回报）的影响。$|r_{t-1}|$ 的较大值会导致较高的方差 $h_t$，从而对波动率聚集进行建模。\n3.  GARCH 项 $\\beta h_{t-1}$，它代表了上一期条件方差的影响。该项为波动率过程引入了持续性。\n4.  因子项 $\\phi f_{t-1}$，它包含了可观测的滞后外部因子 $f_{t-1}$ 对当前方差的影响。\n\n参数被约束为非负（$\\omega, \\alpha, \\beta, \\phi \\ge 0$），以确保方差 $h_t$ 为非负。在没有因子的情况下，要求约束条件 $\\alpha + \\beta < 1$ 以使方差过程是弱平稳的。\n\n计算过程建立在该递归定义之上。精确的算法实现如下：\n\n首先，我们必须初始化该过程。$h_t$ 的递归依赖于 $t-1$ 时的值。因此，我们需要 $t=0$ 时的初始值。问题指定了 $r_0 = 0$ 和 $f_0 = f_1$，其中 $f_1$ 是因子序列中的第一个观测值。初始方差 $h_0$ 是基于 GARCH 过程的长期无条件方差设定的，并根据初始因子水平进行了调整。GARCH($1,1$) 过程的无条件方差为 $E[h] = \\frac{\\omega}{1-\\alpha-\\beta}$。初始化将其扩展为：\n$$\nh_0 = \\max\\left(\\epsilon,\\ \\frac{\\omega}{\\max(1 - \\alpha - \\beta,\\ \\epsilon)} + \\phi f_0\\right)\n$$\n使用一个小的正下限 $\\epsilon = 10^{-8}$ 来确保分母不为零且 $h_0$ 严格为正，这对于数值稳定性至关重要，尤其是在为似然函数计算对数时。\n\n其次，我们从 $t=1$ 迭代到 $T$ 来计算条件方差序列 $\\{h_t\\}_{t=1}^T$。在每一步中，我们使用上一步的已知值（$r_{t-1}$, $h_{t-1}$, $f_{t-1}$）应用方差递归公式。每次计算后，得到的 $h_t$ 也会被限制在不小于 $\\epsilon$ 的水平，以在整个序列中保持正值。此循环中计算的最终值为 $h_T$。\n\n第三，我们计算向前一步的方差预测值 $h_{T+1}$。这是使用时间 $T$ 的最后可用数据直接应用递归公式：\n$$\nh_{T+1} = \\omega + \\alpha r_T^2 + \\beta h_T + \\phi f_T\n$$\n该值也受下限 $\\epsilon$ 的限制。\n\n第四，我们计算高斯负对数似然（NLL）。对于单个观测值 $r_t$，其条件对数似然为 $\\ell_t = -\\frac{1}{2}(\\ln(2\\pi) + \\ln(h_t) + r_t^2/h_t)$。整个序列 $\\{r_t\\}_{t=1}^T$ 的总 NLL 是这些单个对数似然的负值之和：\n$$\n\\text{NLL} = \\sum_{t=1}^T -\\ell_t = \\frac{1}{2}\\sum_{t=1}^T \\left(\\ln(2\\pi) + \\ln(h_t) + \\frac{r_t^2}{h_t}\\right)\n$$\n此计算使用观测到的回报序列 $\\{r_t\\}_{t=1}^T$ 和计算出的条件方差序列 $\\{h_t\\}_{t=1}^T$。\n\n整体算法被实现为一个函数，该函数接受回报序列、因子序列和模型参数。此函数执行所述的初始化、递归、预测和 NLL 计算。对问题陈述中指定的四个测试用例中的每一个重复此过程。每个案例的最终结果——$h_T$、$h_{T+1}$ 和 $\\text{NLL}$——都被四舍五入到 $6$ 位小数，并汇总到一个列表中以供输出。使用 NumPy 有助于数组操作和 `log`、`pi` 等数学函数。", "answer": "```python\nimport numpy as np\n\ndef calculate_factor_garch(r_data, f_data, params):\n    \"\"\"\n    Computes h_T, h_{T+1}, and NLL for a Factor-GARCH(1,1) model.\n\n    Args:\n        r_data (list): The return series {r_t}.\n        f_data (list): The observable factor series {f_t}.\n        params (tuple): The model parameters (omega, alpha, beta, phi).\n\n    Returns:\n        tuple: A tuple containing (h_T, h_{T+1}, NLL).\n    \"\"\"\n    omega, alpha, beta, phi = params\n    epsilon = 1e-8\n\n    r = np.array(r_data, dtype=float)\n    f = np.array(f_data, dtype=float)\n    T = len(r)\n\n    # Prepare extended series with initial values at t=0.\n    # r_ext corresponds to {r_0, r_1, ..., r_T}\n    r_ext = np.insert(r, 0, 0.0) \n    # f_ext corresponds to {f_0, f_1, ..., f_T}\n    # f_0 = f_1, where f_1 is the first element of the original f_data array.\n    f_ext = np.insert(f, 0, f[0])\n\n    # h array will store {h_0, h_1, ..., h_T}\n    h = np.zeros(T + 1)\n\n    # Initialize h_0\n    h_denom = max(1.0 - alpha - beta, epsilon)\n    h_uncond = omega / h_denom + phi * f_ext[0]\n    h[0] = max(epsilon, h_uncond)\n\n    # Recursion for h_t, t = 1, ..., T\n    for t in range(1, T + 1):\n        h_val = omega + alpha * r_ext[t - 1]**2 + beta * h[t - 1] + phi * f_ext[t - 1]\n        h[t] = max(h_val, epsilon)\n\n    # The final conditional variance is h at time T.\n    h_T = h[T]\n\n    # One-step-ahead forecast for h_{T+1}\n    h_Tplus1_val = omega + alpha * r_ext[T]**2 + beta * h[T] + phi * f_ext[T]\n    h_Tplus1 = max(h_Tplus1_val, epsilon)\n\n    # Calculate Gaussian Negative Log-Likelihood\n    # The sum is over t=1,...,T, which corresponds to h[1:]\n    h_for_nll = h[1:]\n    nll = 0.5 * np.sum(np.log(2 * np.pi) + np.log(h_for_nll) + r**2 / h_for_nll)\n\n    return h_T, h_Tplus1, nll\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the required quantities for each,\n    then prints the formatted output.\n    \"\"\"\n    # Series A data\n    series_A_r = [0.01, -0.02, 0.015, -0.005, 0.0, 0.02, -0.015, 0.01]\n    series_A_f = [0.20, 0.25, 0.22, 0.24, 0.21, 0.23, 0.26, 0.22]\n    \n    # Series B data\n    series_B_r = [0.0, 0.0, 0.0, 0.0, 0.0]\n    series_B_f = [0.10, 0.20, 0.30, 0.25, 0.15]\n\n    test_cases = [\n        # Case 1: Series A, (omega, alpha, beta, phi) = (0.0001, 0.10, 0.85, 0.05)\n        {\"r\": series_A_r, \"f\": series_A_f, \"params\": (0.0001, 0.10, 0.85, 0.05)},\n        # Case 2: Series A, (omega, alpha, beta, phi) = (0.0001, 0.10, 0.85, 0.0)\n        {\"r\": series_A_r, \"f\": series_A_f, \"params\": (0.0001, 0.10, 0.85, 0.00)},\n        # Case 3: Series A, (omega, alpha, beta, phi) = (0.00005, 0.08, 0.91, 0.07)\n        {\"r\": series_A_r, \"f\": series_A_f, \"params\": (0.00005, 0.08, 0.91, 0.07)},\n        # Case 4: Series B, (omega, alpha, beta, phi) = (0.0001, 0.00, 0.90, 0.20)\n        {\"r\": series_B_r, \"f\": series_B_f, \"params\": (0.0001, 0.00, 0.90, 0.20)},\n    ]\n\n    results = []\n    for case in test_cases:\n        h_T, h_Tplus1, nll = calculate_factor_garch(case[\"r\"], case[\"f\"], case[\"params\"])\n        results.extend([\n            round(h_T, 6),\n            round(h_Tplus1, 6),\n            round(nll, 6)\n        ])\n\n    # Format the final output string to 6 decimal places.\n    # The format specifier ensures trailing zeros are included.\n    formatted_results = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "掌握了模型的基本构造后，下一步是学习如何从数据中估计模型参数并进行假设检验。本练习将引导你探讨金融市场中一个有趣的现象——“星期几效应”，即波动率是否在每周的不同日子呈现系统性变化。你将通过在GARCH模型的方差方程中引入虚拟变量来捕捉这一效应，并运用准最大似然法（QML）进行估计和似然比（LR）检验，这些都是计量经济学中的核心技能。[@problem_id:2411105]", "id": "2411105", "problem": "您的任务是设计并实现一个完整的、可运行的程序，通过将虚拟变量引入一个能够捕捉金融回报率中波动率聚集现象的条件方差模型，来检验波动率中的“星期效应”。您需要使用的基本原理是：条件期望和条件方差的定义，许多金融回报序列呈现出时变条件方差（“波动率聚集”）的观察现象，以及广义自回归条件异方差（GARCH）模型是表示此类条件方差动态的一种经过充分检验的方法。在“高斯分布”假设下，基于似然的推断（拟最大似然）是经过充分检验且适合用于估计的方法，而“似然比检验”是检验嵌套假设的标准方法。\n\n对于一组给定的合成测试用例，您的程序必须完成以下任务：\n\n1. 将回报率序列 $\\{r_t\\}_{t=1}^T$ 视为均值为零、条件异方差的序列，其条件方差 $\\sigma_t^2$ 服从 GARCH($1,1$) 型递归。在条件方差方程中，通过加性虚拟变量来引入“星期效应”。设 $D_t$ 为星期一、星期二、星期四和星期五的星期指示器向量（星期三是基准日，没有指示器）。指示器向量 $D_t \\in \\mathbb{R}^4$ 使用一个为期 $5$ 天的周期定义如下：$D_t = [\\mathbb{1}\\{\\text{周一}\\}, \\mathbb{1}\\{\\text{周二}\\}, \\mathbb{1}\\{\\text{周四}\\}, \\mathbb{1}\\{\\text{周五}\\}]^\\top$。日期按固定的星期一、星期二、星期三、星期四、星期五的顺序循环，然后重复；模拟的指数中没有周末。\n\n2. 将无约束模型（包含波动率中的星期效应）定义为：\n$$\nr_t = \\sigma_t z_t, \\quad z_t \\stackrel{\\text{i.i.d.}}{\\sim} \\mathcal{N}(0,1),\n$$\n$$\n\\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2 + \\gamma^\\top D_t,\n$$\n其中参数满足 $\\omega > 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$, $\\alpha + \\beta < 1$，并且 $\\gamma \\in \\mathbb{R}_+^4$ 受到约束，以确保 $\\sigma_t^2 > 0$ 几乎必然成立。有约束（零）模型将 $\\gamma = 0$ 并使用：\n$$\n\\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2.\n$$\n这些是用于模拟波动率聚集和外生方差效应的、经过标准且充分检验的结构。\n\n3. 对于每个测试用例，从一个已知的数据生成过程（DGP）中模拟回报率，该过程采用上述无约束形式，具有已知的参数值 $(\\omega, \\alpha, \\beta, \\gamma)$ 和一个固定的种子以保证可复现性。使用 $B$ 个观测值作为预烧期，然后保留最后的 $T$ 个观测值用于估计。使用一个能够满足 $\\alpha + \\beta < 1$ 且考虑了 $D_t$ 在 $5$ 天周期内平均贡献的长期平均值来初始化 $\\sigma_1^2$。\n\n4. 通过最大化高斯对数似然（拟最大似然）来估计无约束模型和有约束模型。使用任何能够确保 $\\omega > 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$, $\\alpha + \\beta < 1$ 以及 $\\gamma \\ge 0$ 的平滑重参数化方法，使得数值优化在原始参数空间中是无约束的，但约束在模型空间中成立。对于观测值 $t$，高斯对数似然贡献为：\n$$\n\\ell_t = -\\tfrac{1}{2}\\left(\\log(2\\pi) + \\log \\sigma_t^2 + \\frac{r_t^2}{\\sigma_t^2}\\right),\n$$\n总对数似然为 $L = \\sum_{t=1}^{T} \\ell_t$。\n\n5. 使用似然比统计量检验零假设 $H_0: \\gamma = 0$ 与无约束备择假设：\n$$\n\\text{LR} = 2\\left[L_{\\text{无约束}} - L_{\\text{有约束}}\\right].\n$$\n在标准正则性条件下，当 $H_0$ 成立时，$\\text{LR}$ 渐近服从自由度为 $k$ 的卡方分布，其中 $k$ 是约束的数量。这里，$k = 4$。使用自由度为 $4$ 的卡方分布计算 $p$ 值，如果 $p$ 值小于 $0.05$，则在 $0.05$ 的水平上拒绝 $H_0$。将拒绝决策表示为布尔值。\n\n6. 您的程序必须生成单行输出，其中包含所有测试用例的布尔结果，形式为逗号分隔的列表并用方括号括起来，例如，“[True,False,True]”。\n\n测试套件（所有数字均与日回报率一致，采用十进制单位；不涉及物理单位）：\n\n- 通用设置：对于所有测试用例，使用 $T = 2000$ 和 $B = 500$ 的预烧期。星期模式从 $t=1$ 开始，为星期一，然后是星期二、星期三、星期四、星期五，并重复。\n\n- 测试用例 $1$（零假设，中等持续性）：\n  - 种子: $123$。\n  - 参数: $\\omega = 5 \\times 10^{-6}$, $\\alpha = 0.05$, $\\beta = 0.90$, $\\gamma = [0, 0, 0, 0]$。\n  - 预期行为：在 $0.05$ 的水平上不拒绝 $H_0$。\n\n- 测试用例 $2$（单一强星期一效应）：\n  - 种子: $456$。\n  - 参数: $\\omega = 5 \\times 10^{-6}$, $\\alpha = 0.05$, $\\beta = 0.90$, $\\gamma = [2\\times 10^{-5}, 0, 0, 0]$。\n  - 预期行为：在 $0.05$ 的水平上拒绝 $H_0$。\n\n- 测试用例 $3$（多个强星期效应）：\n  - 种子: $789$。\n  - 参数: $\\omega = 5 \\times 10^{-6}$, $\\alpha = 0.05$, $\\beta = 0.90$, $\\gamma = [2\\times 10^{-5}, 1.5\\times 10^{-5}, 1\\times 10^{-5}, 5\\times 10^{-6}]$。\n  - 预期行为：在 $0.05$ 的水平上拒绝 $H_0$。\n\n- 测试用例 $4$（零假设，接近单位根的高持续性）：\n  - 种子: $321$。\n  - 参数: $\\omega = 1 \\times 10^{-6}$, $\\alpha = 0.05$, $\\beta = 0.94$, $\\gamma = [0, 0, 0, 0]$。\n  - 预期行为：在 $0.05$ 的水平上不拒绝 $H_0$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为由 `True` 或 `False` 布尔值组成的逗号分隔列表，并用方括号括起来，例如：“[False,True,True,False]”。", "solution": "所述问题是有效的。这是一个定义明确的计算计量经济学练习，基于已建立的时间序列分析和假设检验理论。任务是实现一个似然比检验，以检验 GARCH($1,1$) 模型的条件方差设定中是否存在确定性的星期效应。该过程需要几个不同的步骤：从一个已知的数据生成过程（DGP）模拟合成数据，通过拟最大似然法（QML）估计有约束和无约束模型，最后计算检验统计量及其相关的 p 值以做出决策。\n\n问题的核心在于 GARCH($1,1$) 模型，它捕捉了在许多金融时间序列中观察到的波动率聚集现象。回报率 $r_t$ 的模型由下式给出\n$$\nr_t = \\sigma_t z_t, \\quad z_t \\stackrel{\\text{i.i.d.}}{\\sim} \\mathcal{N}(0,1)\n$$\n其中 $z_t$ 是一个标准正态新息，$\\sigma_t^2$ 是在时间 $t$ 的条件方差。问题为该条件方差指定了两个嵌套模型。\n\n无约束模型通过一个虚拟变量向量 $D_t \\in \\mathbb{R}^4$ 引入了星期效应：\n$$\n\\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2 + \\gamma^\\top D_t\n$$\n对应于零假设 $H_0$ 的有约束模型通过将参数向量 $\\gamma$ 设置为零来排除这些效应：\n$$\nH_0: \\gamma = 0 \\quad \\implies \\quad \\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2\n$$\n参数受到约束以确保方差过程表现良好：$\\omega > 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$，并且为保证平稳性，$\\alpha + \\beta < 1$。星期效应的系数 $\\gamma$ 被约束为非负，$\\gamma \\ge 0$，以排除负的方差贡献。\n\n算法设计如下：\n\n首先，构建一个数据生成函数。对于每个测试用例，我们使用指定的参数 $(\\omega, \\alpha, \\beta, \\gamma)$ 和随机种子，从无约束模型中模拟一个长度为 $T+B$ 的时间序列。星期虚拟变量 $D_t$ 按周期构建。过程用无条件方差进行初始化，在平稳性假设下，该值为 $E[\\sigma_t^2] = (\\omega + E[\\gamma^\\top D_t]) / (1 - \\alpha - \\beta)$。由于日期在一个为期 $5$ 天的周内循环，期望 $E[\\gamma^\\top D_t]$ 是一周内的平均效应：$\\frac{1}{5}(\\gamma_1 + \\gamma_2 + \\gamma_3 + \\gamma_4)$，其中 $\\gamma = [\\gamma_1, \\gamma_2, \\gamma_3, \\gamma_4]^\\top$。前 $B=500$ 个观测值作为预烧期被丢弃，以减轻初始条件的影响，留下一个大小为 $T=2000$ 的样本用于估计。\n\n其次，我们必须定义用于估计的对数似然函数。假设高斯新息，观测值 $t$ 的对数似然贡献为：\n$$\n\\ell_t(\\theta) = -\\frac{1}{2}\\left(\\log(2\\pi) + \\log \\sigma_t^2(\\theta) + \\frac{r_t^2}{\\sigma_t^2(\\theta)}\\right)\n$$\n其中 $\\theta$ 代表模型参数的向量。总对数似然为 $L(\\theta) = \\sum_{t=1}^T \\ell_t(\\theta)$。通过使用数值优化器最大化此函数来执行估计。\n\n为了在优化过程中处理参数约束，我们采用重参数化。优化器在一个无约束的参数空间中操作，这些参数在用于似然计算之前被转换以满足所需的约束。让无约束参数为 $p_i$。一个合适的转换为：\n- $\\omega = \\exp(p_0)$ 以确保 $\\omega > 0$。\n- $\\alpha = \\frac{\\exp(p_1)}{1+\\exp(p_1)}$ 以确保 $\\alpha \\in (0,1)$。\n- $\\beta = (1-\\alpha) \\times \\frac{\\exp(p_2)}{1+\\exp(p_2)}$ 以确保 $\\beta \\in (0, 1-\\alpha)$，从而 $\\alpha+\\beta < 1$。\n- $\\gamma_j = \\exp(p_{2+j})$ 对于 $j \\in \\{1,2,3,4\\}$ 以确保 $\\gamma_j > 0$。\n\n条件方差序列 $\\sigma_t^2(\\theta)$ 是递归计算的。我们使用当前的参数估计值 $\\theta$ 初始化 $\\sigma_1^2$ 为模型隐含的无条件方差。然后，对于 $t=2, \\dots, T$，我们使用 GARCH 递归计算 $\\sigma_t^2$。优化器将最小化总对数似然的负数，即 $-L(\\theta)$。\n\n第三，对于每个测试用例，我们执行两次估计。我们首先拟合有约束模型，它有 $3$ 个参数 $(\\omega, \\alpha, \\beta)$，以获得最大化后的对数似然 $L_{\\text{有约束}}$。然后我们拟合无约束模型，它有 $7$ 个参数 $(\\omega, \\alpha, \\beta, \\gamma_1, \\gamma_2, \\gamma_3, \\gamma_4)$，以获得 $L_{\\text{无约束}}$。\n\n最后，计算似然比（LR）检验统计量：\n$$\n\\text{LR} = 2(L_{\\text{无约束}} - L_{\\text{有约束}})\n$$\n在零假设 $H_0: \\gamma = 0$ 下，此统计量渐近服从一个卡方分布，其自由度等于约束的数量，即 $k=4$。p 值计算为 $P(\\chi^2_4 > \\text{LR})$。如果此 p 值小于指定的显著性水平 $0.05$，则拒绝零假设。然后报告每个测试用例此决策的结果，一个布尔值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef generate_data(T, B, seed, omega, alpha, beta, gamma):\n    \"\"\"\n    Generates synthetic returns from a GARCH(1,1) model with day-of-week effects.\n    \"\"\"\n    np.random.seed(seed)\n    total_len = T + B\n    \n    # Create day-of-week dummy variables\n    # D_t = [Mon, Tue, Thu, Fri]\n    dummies = np.zeros((total_len, 4))\n    for t in range(total_len):\n        day_of_week = t % 5  # 0:Mon, 1:Tue, 2:Wed, 3:Thu, 4:Fri\n        if day_of_week == 0:   # Monday\n            dummies[t, 0] = 1.0\n        elif day_of_week == 1: # Tuesday\n            dummies[t, 1] = 1.0\n        elif day_of_week == 3: # Thursday\n            dummies[t, 2] = 1.0\n        elif day_of_week == 4: # Friday\n            dummies[t, 3] = 1.0\n            \n    # Initialize returns and variances\n    returns = np.zeros(total_len)\n    sigma_sq = np.zeros(total_len)\n    \n    # Initial variance is the unconditional variance\n    mean_gamma_effect = np.sum(gamma) / 5.0\n    uncond_var = (omega + mean_gamma_effect) / (1.0 - alpha - beta)\n    \n    # Generate standard normal innovations\n    z = np.random.normal(0.0, 1.0, total_len)\n    \n    # First observation\n    sigma_sq[0] = uncond_var\n    returns[0] = np.sqrt(sigma_sq[0]) * z[0]\n    \n    # Generate the rest of the series\n    for t in range(1, total_len):\n        gamma_effect = np.dot(gamma, dummies[t])\n        sigma_sq[t] = omega + alpha * returns[t-1]**2 + beta * sigma_sq[t-1] + gamma_effect\n        if sigma_sq[t] < 1e-12: # Floor variance to avoid numerical issues\n            sigma_sq[t] = 1e-12\n        returns[t] = np.sqrt(sigma_sq[t]) * z[t]\n        \n    return returns[B:], dummies[B:]\n\ndef neg_log_likelihood(params_unconstrained, returns, dummies, is_unrestricted):\n    \"\"\"\n    Calculates the negative of the GARCH log-likelihood function.\n    \"\"\"\n    T = len(returns)\n    \n    # Reparameterization to enforce constraints\n    omega = np.exp(params_unconstrained[0])\n    alpha_trans = np.exp(params_unconstrained[1])\n    alpha = alpha_trans / (1.0 + alpha_trans)\n    beta_trans = np.exp(params_unconstrained[2])\n    beta = (1.0 - alpha) * (beta_trans / (1.0 + beta_trans))\n\n    if is_unrestricted:\n        gamma = np.exp(params_unconstrained[3:])\n        mean_gamma_effect = np.sum(gamma) / 5.0\n    else:\n        gamma = np.zeros(4)\n        mean_gamma_effect = 0.0\n\n    # Ensure stationarity for unconditional variance calculation\n    if (alpha + beta) >= 1.0:\n        return 1e9 # Penalize non-stationary region\n        \n    # Initialize variance series\n    sigma_sq = np.zeros(T)\n    uncond_var = (omega + mean_gamma_effect) / (1.0 - alpha - beta)\n    \n    # It's standard to initialize with unconditional variance.\n    sigma_sq[0] = uncond_var\n\n    # GARCH recursion\n    for t in range(1, T):\n        gamma_effect = np.dot(gamma, dummies[t])\n        sigma_sq[t] = omega + alpha * returns[t-1]**2 + beta * sigma_sq[t-1] + gamma_effect\n        if sigma_sq[t] < 1e-12:\n            sigma_sq[t] = 1e-12\n\n    # Avoid log(0) or division by zero\n    if np.any(sigma_sq <= 0):\n        return 1e9\n\n    # Log-likelihood calculation\n    log_likelihood = -0.5 * np.sum(np.log(2 * np.pi) + np.log(sigma_sq) + returns**2 / sigma_sq)\n\n    if np.isnan(log_likelihood) or np.isinf(log_likelihood):\n        return 1e9\n\n    return -log_likelihood\n\ndef fit_garch(returns, dummies, is_unrestricted):\n    \"\"\"\n    Fits a GARCH(1,1) model (restricted or unrestricted) using QML.\n    \"\"\"\n    if is_unrestricted:\n        # Initial guess for [log(w), ...log(alpha_trans), ...log(beta_trans), ...log(gamma)]\n        x0 = np.array([-12.0, -2.5, 2.5, -16.0, -16.0, -16.0, -16.0])\n    else:\n        # Initial guess for [log(w), ...log(alpha_trans), ...log(beta_trans)]\n        x0 = np.array([-12.0, -2.5, 2.5])\n    \n    res = minimize(\n        neg_log_likelihood,\n        x0=x0,\n        args=(returns, dummies, is_unrestricted),\n        method='L-BFGS-B'\n    )\n    \n    max_log_likelihood = -res.fun\n    return max_log_likelihood\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {'seed': 123, 'omega': 5e-6, 'alpha': 0.05, 'beta': 0.90, 'gamma_vec': np.array([0.0, 0.0, 0.0, 0.0])},\n        # Test Case 2\n        {'seed': 456, 'omega': 5e-6, 'alpha': 0.05, 'beta': 0.90, 'gamma_vec': np.array([2e-5, 0.0, 0.0, 0.0])},\n        # Test Case 3\n        {'seed': 789, 'omega': 5e-6, 'alpha': 0.05, 'beta': 0.90, 'gamma_vec': np.array([2e-5, 1.5e-5, 1e-5, 5e-6])},\n        # Test Case 4\n        {'seed': 321, 'omega': 1e-6, 'alpha': 0.05, 'beta': 0.94, 'gamma_vec': np.array([0.0, 0.0, 0.0, 0.0])}\n    ]\n    \n    common_settings = {'T': 2000, 'B': 500}\n    results = []\n\n    for case in test_cases:\n        # 1. Generate data\n        returns, dummies = generate_data(\n            T=common_settings['T'],\n            B=common_settings['B'],\n            seed=case['seed'],\n            omega=case['omega'],\n            alpha=case['alpha'],\n            beta=case['beta'],\n            gamma=case['gamma_vec']\n        )\n        \n        # 2. Fit restricted model (H0)\n        logL_restricted = fit_garch(returns, dummies, is_unrestricted=False)\n        \n        # 3. Fit unrestricted model (H1)\n        logL_unrestricted = fit_garch(returns, dummies, is_unrestricted=True)\n        \n        # 4. Perform Likelihood Ratio test\n        LR_statistic = 2 * (logL_unrestricted - logL_restricted)\n        \n        # The LR statistic should be non-negative.\n        if LR_statistic < 0:\n            LR_statistic = 0\n            \n        degrees_of_freedom = 4\n        p_value = chi2.sf(LR_statistic, df=degrees_of_freedom)\n        \n        # 5. Make decision\n        reject_H0 = p_value < 0.05\n        results.append(reject_H0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "在真实的金融市场中，模型的参数并非一成不变，监管政策或市场结构的改变可能导致波动率行为发生结构性变化。本练习将挑战你解决一个更贴近前沿研究的问题：如何检测波动率聚类行为的结构性断点。你将结合GARCH模型模拟与一种强大的非参数检验方法（循环移位随机化），从零开始构建一个稳健的统计检验，以判断干预措施是否改变了市场的波动动态。[@problem_id:2411151]", "id": "2411151", "problem": "您面临一个来自计算经济学与金融学的概念性问题：确定交易暂停（熔断机制）的引入是否改变了某个股票指数的波动率聚集行为。波动率聚集是指大的收益率（绝对值）倾向于跟随大的收益率，而小的收益率倾向于跟随小的收益率，从而导致波动率度量指标的持续性。\n\n编写一个完整且可运行的程序，该程序对指定测试套件中的每个测试用例，仅使用此处说明的定义来执行以下所有步骤。\n\n- 数据生成过程：\n  - 设干预前（断点前）和干预后（断点后）的收益率序列是通过连接一个记为 GARCH(1,1) 的一阶高斯广义自回归条件异方差模型的两个分段生成的。时间指数为 $t$ 时的创新项是 $r_t$，其中 $r_t = \\sigma_t z_t$，而 $z_t \\sim \\mathcal{N}(0,1)$ 是独立同分布的。条件方差 $\\sigma_t^2$ 根据以下公式演变\n  $$\n  \\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2,\n  $$\n  其中 $\\omega \\gt 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$, 并且为保证协方差平稳性，$\\alpha + \\beta \\lt 1$。\n  - 对于长度为 $n_{\\text{pre}}$ 的断点前分段，使用参数 $(\\omega_{\\text{pre}}, \\alpha_{\\text{pre}}, \\beta_{\\text{pre}})$。对于长度为 $n_{\\text{post}}$ 的断点后分段，使用参数 $(\\omega_{\\text{post}}, \\alpha_{\\text{post}}, \\beta_{\\text{post}})$。\n  - 对于断点前分段，在 $t=1$ 时通过设置 $\\sigma_0^2 = \\omega_{\\text{pre}} / \\left(1 - \\alpha_{\\text{pre}} - \\beta_{\\text{pre}}\\right)$ 和 $r_0 = 0$ 来初始化递归。对断点前分段在 $t=1,2,\\dots,n_{\\text{pre}}$ 上进行演化。\n  - 在断点处，紧接在 $t = n_{\\text{pre}} + 1$ 之前，切换到断点后参数。使用与断点前分段方差递归的最后一个实现值 $r_{n_{\\text{pre}}}$ 和 $\\sigma_{n_{\\text{pre}}}^2$ 相同的初始条件，对 $t = n_{\\text{pre}} + 1, \\dots, n_{\\text{pre}} + n_{\\text{post}}$ 继续递归。\n  - 在整个过程中，按需提取并使用相同的独立标准正态创新项 $z_t$ 序列。整个程序必须在开始时将伪随机数生成器种子设置为 $12345$，以确保结果是可复现的。\n\n- 波动率聚集指数：\n  - 对每个分段（断点前和断点后），定义平方收益率序列 $s_t = r_t^2$。\n  - 对每个分段，将平方收益率的滞后1阶样本自相关定义为\n  $$\n  \\rho_1 = \\frac{\\sum_{t=2}^{n} \\left(s_t - \\bar{s}\\right)\\left(s_{t-1} - \\bar{s}\\right)}{\\sum_{t=1}^{n} \\left(s_t - \\bar{s}\\right)^2},\n  $$\n  其中 $n$ 是分段长度，$\\bar{s} = \\frac{1}{n}\\sum_{t=1}^{n} s_t$。\n  - 设 $\\rho_{\\text{pre}}$ 为断点前分段的值，$\\rho_{\\text{post}}$ 为断点后分段的值。将观测到的检验统计量定义为\n  $$\n  D_{\\text{obs}} = \\rho_{\\text{post}} - \\rho_{\\text{pre}}.\n  $$\n\n- 通过循环移位随机化进行假设检验：\n  - 考虑原假设，即干预没有改变波动率聚集，因此数据是由单一的、聚集行为没有变化的平稳过程生成的。在此原假设和平稳性条件下，对平方收益率序列进行循环移位会保持其联合分布不变，同时保持分段长度固定。\n  - 设 $T = n_{\\text{pre}} + n_{\\text{post}}$ 且 $s_1, s_2, \\dots, s_T$ 为完整的平方收益率序列。对于每个随机移位 $k \\in \\{0,1,\\dots,T-1\\}$，将循环移位后的序列定义为 $s_t^{(k)} = s_{((t-1-k) \\bmod T)+1}$，其中 $t=1,\\dots,T$。对于每次移位，将 $s^{(k)}$ 分割为一个长度为 $n_{\\text{pre}}$ 的断点前分段和一个长度为 $n_{\\text{post}}$ 的断点后分段，计算相应的样本自相关 $\\rho_{\\text{pre}}^{(k)}$ 和 $\\rho_{\\text{post}}^{(k)}$，并定义\n  $$\n  D^{(k)} = \\rho_{\\text{post}}^{(k)} - \\rho_{\\text{pre}}^{(k)}.\n  $$\n  - 对每个测试用例，执行 $K$ 次独立的随机移位（每次从 $\\{0,1,\\dots,T-1\\}$ 中均匀抽取 $k$）以生成 $\\{D^{(k)}\\}_{k=1}^K$。使用加一法将双边 $p$ 值定义为\n  $$\n  p = \\frac{1 + \\#\\{k \\in \\{1,\\dots,K\\} : |D^{(k)}| \\ge |D_{\\text{obs}}|\\}}{K + 1}.\n  $$\n  - 对于给定的显著性水平 $\\alpha$，当且仅当 $p \\le \\alpha$ 时，判定干预改变了波动率聚集。\n\n- 测试套件：\n  - 使用以下三个测试用例。所有参数值必须严格按照给定的值使用。在每种情况下，报告一个布尔判定结果，以指示波动率聚集是否发生改变（如果改变则为真(true)，否则为假(false)）。\n    1. 案例 A（预期聚集性发生变化）：$n_{\\text{pre}} = 1500$， $n_{\\text{post}} = 1500$， $\\omega_{\\text{pre}} = 0.0001$， $\\alpha_{\\text{pre}} = 0.08$， $\\beta_{\\text{pre}} = 0.90$， $\\omega_{\\text{post}} = 0.0001$， $\\alpha_{\\text{post}} = 0.05$， $\\beta_{\\text{post}} = 0.50$， $K = 2000$， $\\alpha = 0.05$。\n    2. 案例 B（无变化）：$n_{\\text{pre}} = 1500$， $n_{\\text{post}} = 1500$， $\\omega_{\\text{pre}} = 0.0001$， $\\alpha_{\\text{pre}} = 0.06$， $\\beta_{\\text{pre}} = 0.92$， $\\omega_{\\text{post}} = 0.0001$， $\\alpha_{\\text{post}} = 0.06$， $\\beta_{\\text{post}} = 0.92$， $K = 2000$， $\\alpha = 0.05$。\n    3. 案例 C（仅无条件方差发生变化）：$n_{\\text{pre}} = 1500$， $n_{\\text{post}} = 1500$， $\\omega_{\\text{pre}} = 0.0001$， $\\alpha_{\\text{pre}} = 0.07$， $\\beta_{\\text{pre}} = 0.90$， $\\omega_{\\text{post}} = 0.0010$， $\\alpha_{\\text{post}} = 0.07$， $\\beta_{\\text{post}} = 0.90$， $K = 2000$， $\\alpha = 0.05$。\n\n- 最终输出格式：\n  - 您的程序必须产生单行输出，其中包含一个由方括号括起来的逗号分隔列表，按案例 A、案例 B、案例 C 的顺序为每个测试用例提供一个布尔值。例如，一个有效的输出如下所示\n  $$\n  [\\text{True},\\text{False},\\text{False}].\n  $$\n  - 不能打印任何其他文本。\n\n所有计算都是纯数学的，无量纲的；不涉及任何物理单位。不使用角度。所有比率或比例必须表示为小数（例如，$0.05$），而不是带百分号的百分比。", "solution": "该问题已经过验证并被确定为有效。其科学基础在于金融计量经济学的原理，具体来说，是使用 GARCH($1$,$1$) 模型来表示波动率聚集。该问题是适定的，为得到唯一、可复现的解提供了完整且明确的指令、参数和定义。\n\n任务是确定 GARCH($1$,$1$) 过程参数中的结构性断点是否导致波动率聚集发生统计上显著的变化。波动率聚集是通过平方收益率的滞后1阶自相关来衡量的。解决方案包括三个主要阶段：模拟时间序列，计算聚集度量指标的观测变化，以及使用非参数置换检验来评估此变化的统计显著性。\n\n对每个测试用例，该方法通过以下计算步骤序列来实现。\n\n**步骤1：生成 GARCH($1$,$1$) 时间序列**\n\n生成一个总长度为 $T = n_{\\text{pre}} + n_{\\text{post}}$ 的金融收益率时间序列 $\\{r_t\\}_{t=1}^T$。该过程定义为 $r_t = \\sigma_t z_t$，其中 $z_t \\sim \\mathcal{N}(0,1)$ 是独立同分布的标准正态创新项。条件方差 $\\sigma_t^2$ 遵循 GARCH($1$,$1$) 递归式：\n$$\n\\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2\n$$\n生成过程分为两个分段：\n- **断点前分段 ($t=1, \\dots, n_{\\text{pre}}$):** 参数为 $(\\omega_{\\text{pre}}, \\alpha_{\\text{pre}}, \\beta_{\\text{pre}})$。递归在 $t=1$ 时进行初始化，使用无条件方差作为 $\\sigma_0^2$ 的起始点，并设置初始平方收益率 $r_0^2$ 为 $0$。具体来说，$\\sigma_0^2 = \\omega_{\\text{pre}} / (1 - \\alpha_{\\text{pre}} - \\beta_{\\text{pre}})$ 且 $r_0 = 0$。\n- **断点后分段 ($t=n_{\\text{pre}}+1, \\dots, T$):** 参数切换为 $(\\omega_{\\text{post}}, \\alpha_{\\text{post}}, \\beta_{\\text{post}})$。$\\sigma_{n_{\\text{pre}}+1}^2$ 的递归使用断点前时期的最后可用值，即 $r_{n_{\\text{pre}}}^2$ 和 $\\sigma_{n_{\\text{pre}}}^2$。\n\n为整个序列一次性生成随机变量序列 $\\{z_t\\}_{t=1}^T$，以确保创新过程的连续性。使用固定的随机种子 $12345$ 来确保可复现性。\n\n**步骤2：计算观测检验统计量 $D_{\\text{obs}}$**\n\n波动率聚集由平方收益率 $s_t = r_t^2$ 的滞后1阶样本自相关来量化。对于一个长度为 $n$ 的分段，此自相关 $\\rho_1$ 计算如下：\n$$\n\\rho_1 = \\frac{\\sum_{t=2}^{n} (s_t - \\bar{s})(s_{t-1} - \\bar{s})}{\\sum_{t=1}^{n} (s_t - \\bar{s})^2}\n$$\n其中 $\\bar{s}$ 是序列 $\\{s_t\\}_{t=1}^n$ 的样本均值。\n\n此计算分别对断点前的平方收益率序列和断点后的序列执行，以获得 $\\rho_{\\text{pre}}$ 和 $\\rho_{\\text{post}}$。用于衡量聚集性变化的观测检验统计量，是这两个值之间的差：\n$$\nD_{\\text{obs}} = \\rho_{\\text{post}} - \\rho_{\\text{pre}}\n$$\n\n**步骤3：通过循环移位随机化进行假设检验**\n\n为了评估 $D_{\\text{obs}}$ 是否具有统计显著性，我们检验原假设 $H_0$，即干预对波动率聚集没有影响。在 $H_0$ 下，整个平方收益率序列 $\\{s_t\\}_{t=1}^T$ 被认为是平稳的。该性质意味着其统计特性在循环移位下是不变的。这构成了置换检验的基础。\n\n该检验统计量的零分布通过以下过程生成：\n- 总共执行 $K$ 次随机循环移位。对于每次试验 $j=1, \\dots, K$，从 $\\{0, 1, \\dots, T-1\\}$ 中均匀抽取一个随机整数移位量 $k_j$。\n- 对于每个 $k_j$，对完整序列 $\\{s_t\\}$ 进行循环移位，以创建一个新序列 $\\{s_t^{(k_j)}\\}$。\n- 这个移位后的序列被分割成一个长度为 $n_{\\text{pre}}$ 的新“断点前”分段和一个长度为 $n_{\\text{post}}$ 的“断点后”分段。\n- 计算相应的自相关系数 $\\rho_{\\text{pre}}^{(k_j)}$ 和 $\\rho_{\\text{post}}^{(k_j)}$，从而得到一个来自置换的检验统计量 $D^{(k_j)} = \\rho_{\\text{post}}^{(k_j)} - \\rho_{\\text{pre}}^{(k_j)}$。\n\n集合 $\\{D^{(k_j)}\\}_{j=1}^K$ 是原假设下检验统计量分布的一个样本。\n\n**步骤4：决策规则**\n\n通过将观测统计量 $|D_{\\text{obs}}|$ 与置换后统计量绝对值 $|D^{(k_j)}|$ 的分布进行比较来计算双边 $p$ 值。使用加一法来处理有限样本， $p$ 值为：\n$$\np = \\frac{1 + \\#\\{j \\in \\{1,\\dots,K\\} : |D^{(k_j)}| \\ge |D_{\\text{obs}}|\\}}{K + 1}\n$$\n通过将 $p$ 值与预先指定的显著性水平 $\\alpha$ 进行比较来做出最终决策。如果 $p \\le \\alpha$，我们拒绝原假设，并得出结构性断点显著改变了波动率聚集行为的结论。否则，我们无法拒绝原假设。每个测试用例的结果都是一个指示此决策的布尔值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the final results.\n    \"\"\"\n    # Set the pseudorandom number generator seed for reproducibility of the entire program.\n    np.random.seed(12345)\n\n    test_cases = [\n        # Case A (expected change in clustering)\n        {\n            \"n_pre\": 1500, \"n_post\": 1500,\n            \"params_pre\": {\"omega\": 0.0001, \"alpha\": 0.08, \"beta\": 0.90},\n            \"params_post\": {\"omega\": 0.0001, \"alpha\": 0.05, \"beta\": 0.50},\n            \"K\": 2000, \"alpha_sig\": 0.05\n        },\n        # Case B (no change)\n        {\n            \"n_pre\": 1500, \"n_post\": 1500,\n            \"params_pre\": {\"omega\": 0.0001, \"alpha\": 0.06, \"beta\": 0.92},\n            \"params_post\": {\"omega\": 0.0001, \"alpha\": 0.06, \"beta\": 0.92},\n            \"K\": 2000, \"alpha_sig\": 0.05\n        },\n        # Case C (change in unconditional variance only)\n        {\n            \"n_pre\": 1500, \"n_post\": 1500,\n            \"params_pre\": {\"omega\": 0.0001, \"alpha\": 0.07, \"beta\": 0.90},\n            \"params_post\": {\"omega\": 0.0010, \"alpha\": 0.07, \"beta\": 0.90},\n            \"K\": 2000, \"alpha_sig\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        decision = perform_test(case)\n        results.append(decision)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_rho(s):\n    \"\"\"\n    Calculates the lag-1 sample autocorrelation of a series.\n    \n    Args:\n        s (np.ndarray): The input series (squared returns).\n        \n    Returns:\n        float: The sample autocorrelation at lag 1.\n    \"\"\"\n    if len(s) < 2:\n        return 0.0\n    \n    s_bar = np.mean(s)\n    s_dev = s - s_bar\n    numerator = np.dot(s_dev[1:], s_dev[:-1])\n    denominator = np.dot(s_dev, s_dev)\n    \n    if denominator == 0:\n        return 0.0\n        \n    return numerator / denominator\n\ndef generate_garch_series(n_pre, n_post, params_pre, params_post):\n    \"\"\"\n    Generates a GARCH(1,1) time series with a structural break.\n    \n    Args:\n        n_pre (int): Length of the pre-break segment.\n        n_post (int): Length of the post-break segment.\n        params_pre (dict): GARCH parameters for the pre-break segment.\n        params_post (dict): GARCH parameters for the post-break segment.\n        \n    Returns:\n        np.ndarray: The generated return series r_t.\n    \"\"\"\n    T = n_pre + n_post\n    r = np.zeros(T)\n    sigma_sq = np.zeros(T)\n    z = np.random.standard_normal(T)\n\n    # Pre-break segment\n    omega_pre = params_pre[\"omega\"]\n    alpha_pre = params_pre[\"alpha\"]\n    beta_pre = params_pre[\"beta\"]\n    \n    # Initialization\n    r_prev_sq = 0.0  # r_0^2 = 0\n    sigma_sq_prev = omega_pre / (1.0 - alpha_pre - beta_pre) # sigma_0^2\n\n    for t in range(n_pre):\n        sigma_sq[t] = omega_pre + alpha_pre * r_prev_sq + beta_pre * sigma_sq_prev\n        r[t] = np.sqrt(sigma_sq[t]) * z[t]\n        \n        r_prev_sq = r[t]**2\n        sigma_sq_prev = sigma_sq[t]\n\n    # Post-break segment\n    omega_post = params_post[\"omega\"]\n    alpha_post = params_post[\"alpha\"]\n    beta_post = params_post[\"beta\"]\n\n    for t in range(n_pre, T):\n        sigma_sq[t] = omega_post + alpha_post * r_prev_sq + beta_post * sigma_sq_prev\n        r[t] = np.sqrt(sigma_sq[t]) * z[t]\n\n        r_prev_sq = r[t]**2\n        sigma_sq_prev = sigma_sq[t]\n        \n    return r\n\ndef perform_test(case):\n    \"\"\"\n    Performs the full hypothesis test for a single test case.\n    \n    Args:\n        case (dict): A dictionary containing all parameters for the test case.\n        \n    Returns:\n        bool: True if clustering changed (H0 rejected), False otherwise.\n    \"\"\"\n    n_pre = case[\"n_pre\"]\n    n_post = case[\"n_post\"]\n    params_pre = case[\"params_pre\"]\n    params_post = case[\"params_post\"]\n    K = case[\"K\"]\n    alpha_sig = case[\"alpha_sig\"]\n    \n    T = n_pre + n_post\n\n    # Step 1: Generate data and compute observed statistic\n    r = generate_garch_series(n_pre, n_post, params_pre, params_post)\n    s = r**2\n    \n    s_pre = s[:n_pre]\n    s_post = s[n_pre:]\n    \n    rho_pre = calculate_rho(s_pre)\n    rho_post = calculate_rho(s_post)\n    \n    D_obs = rho_post - rho_pre\n\n    # Step 2: Perform circular-shift randomization test\n    shifts = np.random.randint(0, T, size=K)\n    count_ge = 0\n    \n    for k in shifts:\n        s_shifted = np.roll(s, shift=int(k))\n        \n        s_shifted_pre = s_shifted[:n_pre]\n        s_shifted_post = s_shifted[n_pre:]\n        \n        rho_pre_k = calculate_rho(s_shifted_pre)\n        rho_post_k = calculate_rho(s_shifted_post)\n        \n        D_k = rho_post_k - rho_pre_k\n        \n        if abs(D_k) >= abs(D_obs):\n            count_ge += 1\n\n    # Step 3: Calculate p-value and make decision\n    p_value = (1 + count_ge) / (K + 1)\n    \n    decision = p_value <= alpha_sig\n    return decision\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n```"}]}