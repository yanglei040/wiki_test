{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解源于实践。本练习将指导你从零开始构建一个完整的增强迪基-福勒（ADF）检验程序，包括如何通过赤池信息准则（AIC）选择最佳滞后阶数，以及如何使用参数自助法（parametric bootstrap）来估计非标准的临界值。通过完成这项任务[@problem_id:2445580]，你将不仅仅是调用一个函数，而是深入掌握单位根检验的核心机制。", "id": "2445580", "problem": "编写一个完整、可运行的程序，该程序使用增广迪基-福勒 (Augmented Dickey-Fuller, ADF) 方法实现单位根检验，以确定一个单变量时间序列是稳定的（零阶单整，$I(0)$）还是不稳定的（一阶单整，$I(1)$）。此任务必须从第一性原理出发，使用基础的时间序列定义和标准的计算步骤来解决，而不依赖于预封装的单位根检验函数。您的程序必须为提供的几个合成时间序列中的每一个，在显著性水平 $\\alpha = 0.05$ 下决定是否拒绝单位根原假设，然后报告该序列是 $I(0)$（拒绝）还是 $I(1)$（不拒绝）。\n\n需要使用的基本依据和定义：\n- 如果一个单变量过程 $\\{y_t\\}$ 是弱平稳的，具有有限且不随时间变化的均值和自协方差，则该过程是 $I(0)$。如果 $\\Delta y_t = y_t - y_{t-1}$ 是 $I(0)$ 但 $y_t$ 本身不是 $I(0)$，则该过程是 $I(1)$。\n- 增广迪基-福勒 (ADF) 检验基于普通最小二乘法回归，将一阶差分 $\\Delta y_t$ 对一个滞后水平项 $y_{t-1}$、有限个滞后差分项 $\\Delta y_{t-i}$（其中 $i \\in \\{1,\\dots,p\\}$，用于吸收短期序列相关性）以及允许的确定性回归量（一个截距项，以及可选的线性时间趋势项）进行回归。检验统计量是 $y_{t-1}$ 的估计系数与其估计标准误的常规比率。因为原假设是单位根，该统计量服从一个非标准分布，其临界值取决于回归中包含了哪些确定性回归量。\n- 为了在不调用预先制表的临界值的情况下保持科学真实性，通过在单位根原假设下进行参数自举 (parametric bootstrap)，使用相同的样本量和相同的确定性回归量集，来近似ADF统计量的零分布。\n\n必需的算法选择和约束：\n- 在ADF回归中始终包含一个截距项。仅在测试案例指定时才包含线性趋势回归量。\n- 通过赤池信息准则 (Akaike Information Criterion, AIC) 在集合 $\\{0,1,\\dots,p_{\\max}\\}$ 中选择滞后阶数 $p$，其中 $p_{\\max} = \\left\\lfloor 12\\,(T/100)^{1/4}\\right\\rfloor$，$T$ 是样本大小。如果出现平局，则选择最小的 $p$。\n- 通过普通最小二乘法估计每个回归，并计算 $y_{t-1}$ 系数的检验统计量，即估计系数除以其估计标准误。\n- 使用 $B = 1200$ 次重复的自举法，在单位根原假设下，近似水平 $\\alpha = 0.05$ 的左尾临界值。在原假设下，将 $y_t$ 模拟为一个从 $0$ 开始的随机游走，其新息项 (innovations) 为独立同分布的、均值为零、方差为一的高斯分布，并在ADF回归中包含相同的确定性回归量（截距项，以及案例要求的趋势项）。在该案例的所有自举重复中，均使用在原始序列上选择的 $p$。\n- 如果观测到的ADF检验统计量小于或等于自举法得到的 $\\alpha$-分位数，则拒绝原假设（分类为 $I(0)$）；否则，不拒绝原假设（分类为 $I(1)$）。\n\n需要实现和评估的测试套件：\n生成以下四个合成时间序列，每个序列长度为 $T = 400$，使用方差为 $1$ 的独立同分布高斯新息项，并使用指定的种子以确保可复现性。对于每个序列，指定是否在ADF回归中包含线性趋势回归量。\n\n- 案例 1 (稳定自回归)：$y_t = \\phi y_{t-1} + \\varepsilon_t$，其中 $\\phi = 0.6$，$y_0 = 0$，数据生成过程中无确定性趋势，ADF回归中包含截距项，ADF回归中不包含趋势项。使用种子 $s_1 = 202405$。\n- 案例 2 (带漂移的随机游走)：$y_t = y_{t-1} + \\delta + \\varepsilon_t$，其中 $\\delta = 0.1$，$y_0 = 0$，ADF回归中包含截距项，ADF回归中不包含趋势项。使用种子 $s_2 = 202406$。\n- 案例 3 (趋势平稳自回归)：$y_t = \\beta t + u_t$，其中 $u_t = \\phi u_{t-1} + \\varepsilon_t$，$\\phi = 0.7$，$\\beta = 0.05$，$u_0 = 0$，ADF回归中包含截距项和线性趋势项。使用种子 $s_3 = 202407$。\n- 案例 4 (带移动平均增量的单位根)：$y_t = y_{t-1} + v_t$ 其中 $v_t = \\varepsilon_t + \\theta \\varepsilon_{t-1}$ 且 $\\theta = 0.5$，$y_0=0$，$\\varepsilon_{-1}=0$，ADF回归中包含截距项，ADF回归中不包含趋势项。使用种子 $s_4 = 202408$。\n\n需要强制执行的实现细节：\n- 在所有案例中，新息项序列 $\\{\\varepsilon_t\\}$ 均为均值为 $0$、方差为 $1$ 的高斯分布。\n- 自举法必须使用固定的种子，以便结果是可复现的。\n- 每个案例的输出是一个布尔值：如果序列被分类为 $I(0)$（在 $\\alpha = 0.05$ 水平下拒绝单位根原假设），则输出 $\\text{True}$；如果被分类为 $I(1)$（不拒绝），则输出 $\\text{False}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的布尔值列表，按案例1、2、3、4的顺序排列，元素以逗号分隔并用方括号括起来，例如，形式为“[True,False,True,False]”的一行。", "solution": "该问题要求从第一性原理出发，实现增广迪基-福勒 (ADF) 检验，以将数个合成时间序列分类为零阶单整 $I(0)$ 或一阶单整 $I(1)$。此过程涉及回归估计、模型选择，以及使用参数自举法进行临界值估计的假设检验。\n\n经评估，该问题陈述是有效的。它在科学上基于已建立的时间序列计量经济学，问题设定良好，具有完整且一致的规范集，并以客观、正式的语言表达。所有必需的参数、数据生成过程和算法选择均已提供，从而可以构建一个唯一且可验证的计算解决方案。因此，我们可以着手解决。\n\n解决方案的方法论包括以下步骤：\n\n1.  **增广迪基-福勒回归的公式化**\n    ADF 检验研究时间序列 $\\{y_t\\}$ 中单位根的原假设。这是通过估计一个回归模型来完成的。对于一个选定的滞后阶数 $p$，模型为：\n    $$ \\Delta y_t = \\gamma y_{t-1} + \\sum_{i=1}^p \\beta_i \\Delta y_{t-i} + \\mathbf{d}_t^T \\boldsymbol{\\delta} + u_t $$\n    其中 $\\Delta y_t = y_t - y_{t-1}$ 是序列的一阶差分，$y_{t-1}$ 是滞后水平项，$\\Delta y_{t-i}$ 是滞后差分项以处理误差项 $u_t$ 中的序列相关性，而 $\\mathbf{d}_t$ 是确定性项（例如，一个常数项和/或一个线性时间趋势）的向量。关键参数是 $\\gamma$。单位根的原假设对应于 $H_0: \\gamma = 0$，其备择假设为平稳性的单边假设 $H_a: \\gamma < 0$。\n\n2.  **普通最小二乘法 (OLS) 估计与检验统计量**\n    该回归模型可以表示为矩阵形式 $\\mathbf{z} = \\mathbf{X}\\boldsymbol{\\theta} + \\mathbf{u}$，其中 $\\mathbf{z}$ 是因变量 $\\Delta y_t$ 的观测值向量，$\\mathbf{X}$ 是所有回归量（$y_{t-1}$、滞后差分项和确定性项）的观测值矩阵，$\\boldsymbol{\\theta}$ 是待估计的参数向量（$\\gamma$、$\\beta_i$ 和 $\\boldsymbol{\\delta}$）。\n\n    参数向量的 OLS 估计量由下式给出：\n    $$ \\hat{\\boldsymbol{\\theta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{z} $$\n    残差计算为 $\\mathbf{e} = \\mathbf{z} - \\mathbf{X}\\hat{\\boldsymbol{\\theta}}$。回归误差的估计方差为 $s^2 = \\frac{\\mathbf{e}^T \\mathbf{e}}{N - k}$，其中 $N$ 是回归中使用的观测数量，$k$ 是估计参数的数量（即 $\\mathbf{X}$ 的列数）。\n\n    ADF 检验统计量是系数 $\\gamma$（即 $\\boldsymbol{\\theta}$ 的第一个元素）的标准 $t$-统计量。其计算公式为：\n    $$ t_\\gamma = \\frac{\\hat{\\gamma}}{\\widehat{\\text{SE}}(\\hat{\\gamma})} $$\n    其中 $\\hat{\\gamma}$ 是 $\\gamma$ 的 OLS 估计值，其标准误为 $\\widehat{\\text{SE}}(\\hat{\\gamma}) = \\sqrt{s^2 (\\mathbf{X}^T \\mathbf{X})^{-1}_{11}}$，而 $(\\mathbf{X}^T \\mathbf{X})^{-1}_{11}$ 是回归量交叉乘积矩阵的逆矩阵的第一个对角元素。\n\n3.  **通过赤池信息准则 (AIC) 选择滞后阶数**\n    必须选择滞后阶数 $p$ 以确保残差 $u_t$ 近似为白噪声。我们从范围 $\\{0, 1, \\dots, p_{\\max}\\}$ 中选择 $p$，其中 $p_{\\max} = \\lfloor 12 (T/100)^{1/4} \\rfloor$。对于样本量 $T=400$，这得到 $p_{\\max} = \\lfloor 12 (400/100)^{1/4} \\rfloor = \\lfloor 12 \\cdot 4^{1/4} \\rfloor = \\lfloor 12 \\sqrt{2} \\rfloor = 16$。\n\n    对于每个候选的滞后阶数 $p$，我们估计ADF回归并计算 AIC，其定义为：\n    $$ \\text{AIC}(p) = N_p \\ln\\left(\\frac{\\text{RSS}_p}{N_p}\\right) + 2k_p $$\n    其中 $N_p = T-1-p$ 是具有 $p$ 阶滞后的模型的有效观测数，$\\text{RSS}_p$ 是残差平方和 $(\\mathbf{e}^T \\mathbf{e})$，$k_p$ 是回归量总数（包括确定性项）。最优滞后阶数 $p^*$ 是最小化 AIC 的那一个。若出现平局，则选择最小的 $p$。\n\n4.  **通过参数自举近似临界值**\n    在原假设 $H_0: \\gamma = 0$ 下，$t$-统计量 $t_\\gamma$ 不遵循标准的学生 $t$-分布。其分布（通常称为 Dickey-Fuller 分布）取决于样本大小和回归中包含的确定性项。我们使用参数自举法来近似此分布。\n\n    该过程如下：\n    a. 生成 $B=1200$ 个自举样本 $\\{y_t^*\\}_{t=1}^T$，每个样本均来自零假设的数据生成过程，即一个简单的随机游走：$y_t^* = y_{t-1}^* + \\eta_t$，其中 $y_0^*=0$，新息项 $\\eta_t \\sim \\mathcal{N}(0,1)$ 是独立同分布的标准高斯变量。\n    b. 对每个自举样本，使用与原始数据相同的设定进行ADF检验：相同的确定性回归量和上一步中选择的相同最优滞后阶数 $p^*$。\n    c. 计算并存储每次重复中得到的 $t$-统计量 $t_\\gamma^*$。\n    d. 这 $B$ 个统计量的集合构成一个经验分布，用以近似 ADF 统计量的真实零分布。显著性水平 $\\alpha=0.05$ 的左尾临界值，记为 $c_{0.05}$，是该经验分布的第 $5$ 个百分位数。\n\n5.  **假设检验与分类**\n    决策规则是将根据原始数据计算出的 ADF 统计量 $t_\\gamma$ 与自举法得到的临界值 $c_{0.05}$进行比较。\n    - 如果 $t_\\gamma \\le c_{0.05}$，我们拒绝原假设 $H_0$。这提供了反对单位根存在的证据，序列被分类为平稳的，即 $I(0)$。结果为 $\\text{True}$。\n    - 如果 $t_\\gamma > c_{0.05}$，我们无法拒绝原假设 $H_0$。没有足够的证据排除单位根的存在，序列被分类为非平稳的，即 $I(1)$。结果为 $\\text{False}$。\n\n这完成了该程序逻辑设计的完整过程，现在将为每个指定的测试案例实施该程序。", "answer": "```python\nimport numpy as np\n\ndef _generate_series(case_params: dict) -> np.ndarray:\n    \"\"\"Generates a time series based on the specified case parameters.\"\"\"\n    T = case_params[\"T\"]\n    seed = case_params[\"seed\"]\n    dgp_type = case_params[\"dgp_type\"]\n    \n    rng = np.random.default_rng(seed)\n    eps = rng.standard_normal(T)\n    \n    y = np.zeros(T)\n\n    if dgp_type == 1:  # Stable AR(1)\n        phi = 0.6\n        y[0] = 0\n        for t in range(1, T):\n            y[t] = phi * y[t-1] + eps[t]\n    elif dgp_type == 2:  # Random walk with drift\n        delta = 0.1\n        y[0] = 0\n        for t in range(1, T):\n            y[t] = y[t-1] + delta + eps[t]\n    elif dgp_type == 3:  # Trend-stationary AR\n        phi = 0.7\n        beta = 0.05\n        u = np.zeros(T)\n        u[0] = 0\n        for t in range(1, T):\n            u[t] = phi * u[t-1] + eps[t]\n        time_trend = np.arange(1, T + 1)\n        y = beta * time_trend + u\n    elif dgp_type == 4:  # Unit root with MA(1) noise\n        theta = 0.5\n        v = np.zeros(T)\n        v[0] = eps[0]  # eps_{-1} = 0\n        for t in range(1, T):\n            v[t] = eps[t] + theta * eps[t-1]\n        y = np.cumsum(v)\n\n    return y\n\ndef _run_adf_regression(y: np.ndarray, p: int, include_trend: bool) -> tuple:\n    \"\"\"\n    Constructs matrices and performs OLS for the ADF regression.\n    \n    Returns:\n        t_stat (float): The t-statistic for the lagged level coefficient.\n        aic (float): The Akaike Information Criterion value.\n    \"\"\"\n    T = len(y)\n    delta_y = np.diff(y)\n    \n    # Effective number of observations\n    n_eff = T - 1 - p\n    \n    # Dependent variable: delta_y[t] for t = p, ..., T-2\n    # This corresponds to Delta y_{p+1} ... Delta y_{T-1}\n    z = delta_y[p:]\n    \n    # Regressors\n    # 1. Lagged level: y[t-1] for t=p+1,...,T-1. Corresponds to y[p:T-1]\n    regressors = [y[p:-1]]\n    \n    # 2. Lagged differences: Delta y_{t-i} for i=1..p\n    for i in range(1, p + 1):\n        # For a given t, Delta y_{t-i} is delta_y[t-1-i]\n        # For t running from p+1 to T-1, this is a slice\n        # from (p+1)-1-i to (T-1)-1-i, i.e., p-i to T-2-i\n        regressors.append(delta_y[p - i : n_eff + p - i])\n\n    # 3. Deterministic terms\n    regressors.append(np.ones(n_eff))\n    if include_trend:\n        # Time index t runs from p+1 to T-1\n        regressors.append(np.arange(p + 1, T))\n\n    X = np.stack(regressors, axis=1)\n    k = X.shape[1]\n    \n    try:\n        # OLS estimation: beta_hat = (X'X)^{-1} X'z\n        beta_hat = np.linalg.solve(X.T @ X, X.T @ z)\n        \n        residuals = z - X @ beta_hat\n        rss = residuals @ residuals\n        \n        # AIC\n        if n_eff > 0:\n            aic = n_eff * np.log(rss / n_eff) + 2 * k\n        else:\n            aic = np.inf\n\n        # T-statistic for gamma (coefficient on y_{t-1})\n        sigma2 = rss / (n_eff - k)\n        var_cov = sigma2 * np.linalg.inv(X.T @ X)\n        se_gamma = np.sqrt(var_cov[0, 0])\n        t_stat = beta_hat[0] / se_gamma\n\n    except np.linalg.LinAlgError:\n        # Handle cases of perfect multicollinearity (unlikely but possible)\n        t_stat, aic = np.nan, np.inf\n\n    return t_stat, aic\n\ndef solve():\n    \"\"\"\n    Main function to run the ADF tests for all specified cases.\n    \"\"\"\n    test_cases = [\n        {\"dgp_type\": 1, \"T\": 400, \"seed\": 202405, \"include_trend\": False, \"B\": 1200, \"alpha\": 0.05},\n        {\"dgp_type\": 2, \"T\": 400, \"seed\": 202406, \"include_trend\": False, \"B\": 1200, \"alpha\": 0.05},\n        {\"dgp_type\": 3, \"T\": 400, \"seed\": 202407, \"include_trend\": True, \"B\": 1200, \"alpha\": 0.05},\n        {\"dgp_type\": 4, \"T\": 400, \"seed\": 202408, \"include_trend\": False, \"B\": 1200, \"alpha\": 0.05},\n    ]\n\n    results = []\n    \n    # Fixed seed for bootstrap to ensure reproducibility\n    BOOTSTRAP_SEED = 12345\n    boot_rng = np.random.default_rng(BOOTSTRAP_SEED)\n\n    for case in test_cases:\n        # 1. Generate the time series\n        y = _generate_series(case)\n        T = case[\"T\"]\n        \n        # 2. Select optimal lag order p using AIC\n        p_max = int(12 * (T / 100)**(1/4))\n        aics = []\n        for p in range(p_max + 1):\n            _, aic = _run_adf_regression(y, p, case[\"include_trend\"])\n            aics.append((aic, p))\n        \n        # Smallest p wins ties due to stable sort nature or explicit handling.\n        # min() on tuples (aic, p) naturally prefers smaller p for same aic.\n        best_p = min(aics)[1]\n        \n        # 3. Calculate ADF statistic for the original series\n        observed_t_stat, _ = _run_adf_regression(y, best_p, case[\"include_trend\"])\n        \n        # 4. Run bootstrap to find the critical value\n        bootstrap_t_stats = []\n        for _ in range(case[\"B\"]):\n            # Generate a series under the null (random walk)\n            innovations = boot_rng.standard_normal(T)\n            y_star = np.cumsum(innovations)\n            \n            # Calculate t-stat on this bootstrapped series\n            t_stat_star, _ = _run_adf_regression(y_star, best_p, case[\"include_trend\"])\n            if not np.isnan(t_stat_star):\n                 bootstrap_t_stats.append(t_stat_star)\n        \n        # 5. Determine the critical value and make a decision\n        critical_value = np.quantile(bootstrap_t_stats, case[\"alpha\"])\n        \n        is_I0 = observed_t_stat <= critical_value\n        results.append(is_I0)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "掌握了检验的执行方法后，下一个关键问题是：单位根检验在现实世界中有什么用？这个练习[@problem_id:2445622]通过一个直观的案例——分析在线游戏内容更新对玩家数量的影响——来回答这个问题。你将使用ADF检验来判断一个外部冲击（内容更新）造成的是一个会随时间消散的暂时性高峰，还是一个永久性的水平变化，从而将单位根的存在与否与冲击的持久性直接联系起来。", "id": "2445622", "problem": "考虑三个合成的时间序列，它们代表了一款在线游戏的每日同时在线玩家数量。每个序列都在指定的一天包含一次内容更新。对于每个序列，通过基于增广 Dickey–Fuller (ADF) 框架的单位根检验，判断内容更新是产生永久性的水平变化还是暂时性的峰值。\n\n定义和检验规则：\n- 设 $\\{y_t\\}_{t=0}^{T}$ 为一个单变量时间序列。定义 $\\Delta y_t \\equiv y_t - y_{t-1}$。\n- 包含截距项（无确定性趋势）且恰好有 $p=2$ 个增广滞后项的 ADF 回归方程为\n$$\n\\Delta y_t \\;=\\; \\alpha \\;+\\; \\gamma \\, y_{t-1} \\;+\\; \\beta_1 \\, \\Delta y_{t-1} \\;+\\; \\beta_2 \\, \\Delta y_{t-2} \\;+\\; \\varepsilon_t,\\quad t=3,4,\\dots,T,\n$$\n其中 $\\varepsilon_t$ 为回归扰动项。\n- 原假设为存在单位根：$H_0: \\gamma = 0$。备择假设为围绕一个常数平稳：$H_1: \\gamma < 0$。\n- 计算上述回归中 $\\gamma$ 的普通最小二乘 $t$-统计量，并将其与包含截距项（无趋势）设定下的 Dickey–Fuller $5\\%$ 临界值 $-2.86$ 进行比较。当且仅当 $t$-统计量小于或等于 $-2.86$ 时，拒绝 $H_0$。\n- 内容更新的分类规则：如果拒绝 $H_0$，则将更新的影响分类为暂时性（过程平稳，冲击会衰减）；如果未拒绝 $H_0$，则将影响分类为永久性（过程存在单位根，冲击会持续）。\n\n数据生成过程（测试套件）：\n所有新息都是独立同分布的高斯随机变量。为保证可复现性，使用一个固定的伪随机数生成器种子，其值为 $12345$。对于以下每种情况，取指定的 $y_0$ 值，并为每个 $t$ 独立地生成 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n- 情况 A（带漂移的随机游走和永久性更新跳跃）：\n  - 参数：$T = 500$, $y_0 = 1000$, $\\mu = 0.2$, $\\sigma = 5$, $\\Delta = 50$, 更新日 $\\tau = 300$。\n  - $t=1,2,\\dots,T$ 的递归式：\n    $$\n    y_t \\;=\\; y_{t-1} \\;+\\; \\mu \\;+\\; \\varepsilon_t \\;+\\; \\Delta \\cdot \\mathbf{1}\\{t=\\tau\\}.\n    $$\n- 情况 B（带有脉冲更新冲击的平稳自回归）：\n  - 参数：$T = 500$, $y_0 = 1000$, $\\phi = 0.6$, 目标均值 $\\bar{y}=1000$，因此截距项 $c = \\bar{y}\\,(1-\\phi) = 400$, $\\sigma = 10$, 脉冲大小 $A=120$, 更新日 $\\tau = 300$。\n  - $t=1,2,\\dots,T$ 的递归式：\n    $$\n    y_t \\;=\\; c \\;+\\; \\phi\\, y_{t-1} \\;+\\; \\varepsilon_t \\;+\\; A \\cdot \\mathbf{1}\\{t=\\tau\\}.\n    $$\n- 情况 C（高度持续但平稳的自回归，带有脉冲更新冲击）：\n  - 参数：$T = 1200$, $y_0 = 1000$, $\\phi = 0.9$, 目标均值 $\\bar{y}=1000$，因此截距项 $c = \\bar{y}\\,(1-\\phi) = 100$, $\\sigma = 5$, 脉冲大小 $A=100$, 更新日 $\\tau = 800$。\n  - $t=1,2,\\dots,T$ 的递归式：\n    $$\n    y_t \\;=\\; c \\;+\\; \\phi\\, y_{t-1} \\;+\\; \\varepsilon_t \\;+\\; A \\cdot \\mathbf{1}\\{t=\\tau\\}.\n    $$\n\n任务：\n- 对于这三种情况中的每一种，使用指定的参数和种子生成序列，计算如上定义的 ADF $t$-统计量（恰好有 $p=2$ 个增广滞后项和截距项），使用临界值 $-2.86$ 在显著性水平 $\\alpha = 0.05$ 下进行假设检验，并根据上述规则将更新的影响分类为永久性或暂时性。\n\n要求的最终输出格式：\n- 你的程序应生成一行输出，其中按顺序 $\\text{[情况 A, 情况 B, 情况 C]}$ 包含三个分类结果，格式为一个无空格、逗号分隔的 Python 风格布尔值列表，例如 $\\text{[True,False,True]}$，其中 $\\text{True}$ 表示永久性影响，$\\text{False}$ 表示暂时性影响。", "solution": "对所提出的问题进行验证。\n\n### 步骤 1：提取已知信息\n问题提供了以下数据、定义和规则：\n- 一个单变量时间序列 $\\{y_t\\}_{t=0}^{T}$。\n- 一阶差分算子：$\\Delta y_t \\equiv y_t - y_{t-1}$。\n- 包含截距项和 $p=2$ 个滞后项的增广 Dickey–Fuller (ADF) 回归模型：\n$$\n\\Delta y_t \\;=\\; \\alpha \\;+\\; \\gamma \\, y_{t-1} \\;+\\; \\beta_1 \\, \\Delta y_{t-1} \\;+\\; \\beta_2 \\, \\Delta y_{t-2} \\;+\\; \\varepsilon_t,\\quad t=3,4,\\dots,T.\n$$\n- 单位根的原假设为 $H_0: \\gamma = 0$。\n- 平稳性的备择假设为 $H_1: \\gamma < 0$。\n- 决策规则是在 $5\\%$ 的显著性水平下，如果 $\\gamma$ 的普通最小二乘 (OLS) $t$-统计量小于或等于临界值 $-2.86$，则拒绝 $H_0$。\n- 定义了一个分类规则：如果未拒绝 $H_0$，则影响为“永久性”；如果拒绝 $H_0$，则影响为“暂时性”。\n- 必须使用一个固定的伪随机数生成器种子 $12345$。\n- 指定了三种具有特定数据生成过程 (DGP) 的情况：\n    - 情况 A: $y_t = y_{t-1} + \\mu + \\varepsilon_t + \\Delta \\cdot \\mathbf{1}\\{t=\\tau\\}$, 参数为 $T = 500$, $y_0 = 1000$, $\\mu = 0.2$, $\\sigma = 5$, $\\Delta = 50$, $\\tau = 300$。\n    - 情况 B: $y_t = c + \\phi y_{t-1} + \\varepsilon_t + A \\cdot \\mathbf{1}\\{t=\\tau\\}$, 参数为 $T = 500$, $y_0 = 1000$, $\\phi = 0.6$, $c = 400$, $\\sigma = 10$, $A = 120$, $\\tau = 300$。\n    - 情况 C: $y_t = c + \\phi y_{t-1} + \\varepsilon_t + A \\cdot \\mathbf{1}\\{t=\\tau\\}$, 参数为 $T = 1200$, $y_0 = 1000$, $\\phi = 0.9$, $c = 100$, $\\sigma = 5$, $A = 100$, $\\tau = 800$。\n- 要求的输出是一个布尔值列表 `[情况 A 结果, 情况 B 结果, 情况 C 结果]`，其中 `True` 表示“永久性”影响，`False` 表示“暂时性”影响。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据指定的验证标准对问题进行评估。\n- **科学性**：该问题基于时间序列计量经济学的标准、公认原理，特别是单位根过程理论和增广 Dickey-Fuller 检验的应用。数据生成过程 (DGP) 代表了典型的模型：带漂移的随机游走（非平稳）和自回归过程（平稳）。\n- **适定性**：该问题是完全指定的。为数据生成（$T, y_0, \\sigma$ 等）和 ADF 检验（$p=2$、仅含截距项模型、临界值）所需的所有参数都已提供。该任务是一个直接的计算过程，对于给定的随机种子，其结果是明确且唯一的。\n- **客观性**：该问题以精确的量化术语陈述，没有任何主观或模糊的语言。\n- **其他缺陷**：问题的设置是内部一致的。例如，在情况 B 中，截距项 $c$ 与目标均值 $\\bar{y}$ 和自回归参数 $\\phi$ 一致：$c = \\bar{y}(1-\\phi) = 1000(1-0.6) = 400$。同样，对于情况 C，$c = 1000(1-0.9) = 100$。不存在矛盾、信息缺失或不科学的前提。\n\n### 步骤 3：结论和行动\n此问题有效。这是一个定义明确的计量经济学计算任务。将提供一个解决方案。\n\n### 求解推导\n任务是为三个合成的时间序列将一次内容更新的影响分类为“永久性”或“暂时性”。分类取决于增广 Dickey–Fuller (ADF) 单位根检验的结果。每种情况的步骤如下。\n\n1.  **时间序列生成**：对于每种情况，根据其指定的数据生成过程 (DGP)，生成一个长度为 $T+1$ 的时间序列 $\\{y_t\\}_{t=0}^T$。从重置为 $12345$ 的种子开始，为每个序列生成一组独特的伪随机高斯新息 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n2.  **ADF 回归设置**：ADF 检验回归指定为：\n    $$\n    \\Delta y_t = \\alpha + \\gamma y_{t-1} + \\beta_1 \\Delta y_{t-1} + \\beta_2 \\Delta y_{t-2} + \\varepsilon_t\n    $$\n    该回归针对 $t = 3, 4, \\dots, T$ 进行。这为回归提供了 $N = T-2$ 个观测值。我们将因变量的观测值向量定义为 $Y = [\\Delta y_3, \\Delta y_4, \\dots, \\Delta y_T]^T$。自变量的设计矩阵 $X$ 由 $N$ 行和 $k=4$ 列构成：\n    $$\n    X = \\begin{bmatrix}\n    1 & y_2 & \\Delta y_2 & \\Delta y_1 \\\\\n    1 & y_3 & \\Delta y_3 & \\Delta y_2 \\\\\n    \\vdots & \\vdots & \\vdots & \\vdots \\\\\n    1 & y_{T-1} & \\Delta y_{T-1} & \\Delta y_{T-2}\n    \\end{bmatrix}\n    $$\n    该模型可以写成矩阵形式 $Y = X \\mathbf{\\theta} + \\mathbf{\\varepsilon}$，其中 $\\mathbf{\\theta} = [\\alpha, \\gamma, \\beta_1, \\beta_2]^T$。\n\n3.  **OLS 估计和 t-统计量计算**：使用普通最小二乘法 (OLS) 估计回归系数向量 $\\hat{\\mathbf{\\theta}}$：\n    $$\n    \\hat{\\mathbf{\\theta}} = (X^T X)^{-1} X^T Y\n    $$\n    我们感兴趣的系数是 $\\hat{\\gamma}$，它是 $\\hat{\\mathbf{\\theta}}$ 的第二个元素。为了计算其 $t$-统计量，我们首先需要它的标准误 $\\text{SE}(\\hat{\\gamma})$。\n    回归误差的方差 $\\sigma^2_\\varepsilon$ 通过残差平方和 (SSR) 估计：\n    $$\n    \\hat{\\sigma}^2_\\varepsilon = \\frac{\\text{SSR}}{N-k} = \\frac{(Y-X\\hat{\\mathbf{\\theta}})^T(Y-X\\hat{\\mathbf{\\theta}})}{N-k}\n    $$\n    系数向量的估计协方差矩阵是：\n    $$\n    \\widehat{\\text{Cov}}(\\hat{\\mathbf{\\theta}}) = \\hat{\\sigma}^2_\\varepsilon (X^T X)^{-1}\n    $$\n    $\\hat{\\gamma}$ 的方差是该矩阵的第二个对角元素（索引 $1,1$），我们称之为 $\\widehat{\\text{Var}}(\\hat{\\gamma})$。标准误是其平方根：\n    $$\n    \\text{SE}(\\hat{\\gamma}) = \\sqrt{\\widehat{\\text{Var}}(\\hat{\\gamma})}\n    $$\n    然后，$\\gamma$ 的 $t$-统计量计算如下：\n    $$\n    t_{\\gamma} = \\frac{\\hat{\\gamma}}{\\text{SE}(\\hat{\\gamma})}\n    $$\n\n4.  **假设检验和分类**：将计算出的 $t$-统计量 $t_{\\gamma}$与提供的 $5\\%$ 临界值 $c_{0.05} = -2.86$ 进行比较。\n    - 如果 $t_{\\gamma} \\le -2.86$，则拒绝原假设 $H_0: \\gamma=0$。检验表明序列是平稳的。根据问题的规则，更新的影响被分类为“暂时性”，对应于布尔值 `False`。\n    - 如果 $t_{\\gamma} > -2.86$，我们未能拒绝原假设。检验没有提供足够的证据来反驳单位根的存在。影响被分类为“永久性”，对应于布尔值 `True`。\n\n将此完整过程以计算方式实现，并应用于所定义的三个案例中的每一个。\n\n- **情况 A** 代表一个随机游走，根据定义，它是一个具有单位根的过程（$\\gamma=0$）。我们预期检验将无法拒绝原假设，从而得到“永久性”的分类（`True`）。\n- **情况 B** 是一个平稳的 AR(1) 过程，其中 $\\phi=0.6$，远离单位根边界。真实的 $\\gamma = \\phi - 1 = -0.4$。该检验应具有较高的功效来拒绝原假设，从而得出“暂时性”的分类（`False`）。\n- **情况 C** 是一个平稳的 AR(1) 过程，其中 $\\phi=0.9$，该过程高度持续且接近单位根。真实的 $\\gamma = \\phi - 1 = -0.1$。已知 ADF 检验在这种情况下功效较低，这意味着即使原假设为假，它们也常常无法拒绝原假设。因此，检验很可能将此过程分类为具有单位根，从而得出“永久性”的分类（`True`）。\n\n最终输出将是这三个布尔结果的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_adf_test(params):\n    \"\"\"\n    Generates a time series based on a given DGP and performs an ADF test.\n\n    Args:\n        params (dict): A dictionary containing parameters for the DGP and the test.\n                       Keys: 'T', 'y0', 'sigma', 'tau', 'type', and other DGP-specific params.\n\n    Returns:\n        bool: True if the effect is classified as 'permanent', False otherwise.\n    \"\"\"\n    # Unpack parameters\n    T = params['T']\n    y0 = params['y0']\n    sigma = params['sigma']\n    tau = params['tau']\n    dgp_type = params['type']\n\n    # Set seed for reproducibility for this specific case\n    rng = np.random.default_rng(12345)\n    \n    # Generate random innovations\n    eps = rng.normal(0, sigma, size=T)\n\n    # Generate the time series y from t=0 to T\n    y = np.zeros(T + 1)\n    y[0] = y0\n\n    if dgp_type == 'A':\n        mu = params['mu']\n        delta = params['delta']\n        for t in range(1, T + 1):\n            jump = delta if t == tau else 0\n            y[t] = y[t-1] + mu + eps[t-1] + jump\n    elif dgp_type in ['B', 'C']:\n        c = params['c']\n        phi = params['phi']\n        A = params['A']\n        for t in range(1, T + 1):\n            impulse = A if t == tau else 0\n            y[t] = c + phi * y[t-1] + eps[t-1] + impulse\n            \n    # Prepare data for ADF regression\n    # The regression uses observations from t=3 to T\n    # Total observations in regression: N = T - 2\n    \n    # First differences: delta_y_t = y_t - y_{t-1} for t=1,...,T\n    delta_y = y[1:] - y[:-1]\n\n    # Dependent variable: Y = [delta_y_3, ..., delta_y_T]\n    # Corresponds to delta_y[2:]\n    Y = delta_y[2:]\n    \n    # Number of observations and parameters in the regression\n    N = T - 2\n    k = 4 # alpha, gamma, beta1, beta2\n\n    # Design matrix X\n    # Columns: intercept, y_{t-1}, delta_y_{t-1}, delta_y_{t-2}\n    # For t=3..T, this corresponds to:\n    # y[2:-1] for y_{t-1}\n    # delta_y[1:-1] for delta_y_{t-1}\n    # delta_y[0:-2] for delta_y_{t-2}\n    X = np.zeros((N, k))\n    X[:, 0] = 1.0  # Intercept alpha\n    X[:, 1] = y[2:-1]  # Lagged level y_{t-1}\n    X[:, 2] = delta_y[1:-1]  # Lagged difference delta_y_{t-1}\n    X[:, 3] = delta_y[0:-2]  # Second lagged difference delta_y_{t-2}\n\n    # Perform OLS regression to find coefficients theta_hat\n    # theta_hat = (X.T @ X)^-1 @ X.T @ Y\n    # Using np.linalg.lstsq is more numerically stable\n    coeffs, ssr_array, _, _ = np.linalg.lstsq(X, Y, rcond=None)\n    \n    gamma_hat = coeffs[1]\n    \n    # Calculate t-statistic for gamma\n    if ssr_array.size == 0:\n        # This case happens if the model is a perfect fit, which is highly unlikely\n        # with random data. Return a default to avoid crashing.\n        return True\n\n    ssr = ssr_array[0]\n    dof = N - k\n    sigma_eps_sq_hat = ssr / dof\n\n    # Covariance matrix of coefficients\n    try:\n        X_T_X_inv = np.linalg.inv(X.T @ X)\n    except np.linalg.LinAlgError:\n        # In case of perfect multicollinearity\n        return True # Cannot reject H0 if test cannot be computed\n\n    var_gamma_hat = sigma_eps_sq_hat * X_T_X_inv[1, 1]\n    se_gamma_hat = np.sqrt(var_gamma_hat)\n\n    if se_gamma_hat == 0:\n        return True # Avoid division by zero, non-rejection is a safe default\n\n    t_statistic = gamma_hat / se_gamma_hat\n    \n    # Critical value from the problem\n    critical_value = -2.86\n    \n    # Decision rule\n    # H0 not rejected -> permanent -> True\n    # H0 rejected -> temporary -> False\n    return t_statistic > critical_value\n\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all three cases and print the result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'type': 'A', 'T': 500, 'y0': 1000, 'mu': 0.2, 'sigma': 5,\n            'delta': 50, 'tau': 300\n        },\n        {\n            'type': 'B', 'T': 500, 'y0': 1000, 'phi': 0.6, 'c': 400,\n            'sigma': 10, 'A': 120, 'tau': 300\n        },\n        {\n            'type': 'C', 'T': 1200, 'y0': 1000, 'phi': 0.9, 'c': 100,\n            'sigma': 5, 'A': 100, 'tau': 800\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        is_permanent = run_adf_test(case)\n        results.append(is_permanent)\n\n    # Format output as specified: [True,False,True]\n    result_str = f\"[{','.join(map(str, results))}]\"\n    print(result_str)\n\nsolve()\n```"}, {"introduction": "单位根检验告诉我们一个序列是否会回归其均值，但它没有告诉我们回归的速度有多快。在确定一个序列是平稳的（即冲击是暂时的）之后，量化其均值回归的速度至关重要。这个练习[@problem_id:2445619]引入了“半衰期”这一概念，它能量化一个冲击的影响消退一半所需的时间，让你能够从自回归系数 $\\rho$ 中提取出更丰富、更具经济直觉的信息。", "id": "2445619", "problem": "给定离散时间中的一阶自回归过程的概念，其中，与确定性成分（均值或趋势）的偏差的单步条件期望，每个周期以系数 $\\rho$ 进行乘法演变。对于标量时间序列 $\\{x_t\\}$ 的增广 Dickey-Fuller (ADF) 回归，其形式为 $\\Delta x_t = \\mu + \\tau t + \\gamma x_{t-1} + \\sum_{i=1}^{p} \\psi_i \\Delta x_{t-i} + \\varepsilon_t$，偏差动态的自回归系数为 $\\rho = 1 + \\gamma$。\n\n将半衰期 $h(\\rho)$ 定义为最小的非负实数，使得经过 $h(\\rho)$ 个周期后，预期偏差的量值等于其初始量值的一半。请以周期为单位表示半衰期。\n\n实现一个程序，给定多个 $\\rho$ 值，计算相应的半衰期（以周期为单位）。用于测试的输入 $\\rho$ 值为：\n- $\\rho = 0.8$\n- $\\rho = 0.98$\n- $\\rho = 0.5$\n- $\\rho = -0.5$\n- $\\rho = 0.0$\n- $\\rho = 1.0$\n- $\\rho = -1.0$\n- $\\rho = 1.05$\n- $\\rho = -1.2$\n- $\\rho = 0.2$\n\n要求：\n-对于 $\\lvert \\rho \\rvert \\in (0,1)$，返回一个等于半衰期（以周期为单位）的有限实数，四舍五入到六位小数。\n- 对于 $\\rho = 0$，返回 $0.000000$。\n- 对于 $\\lvert \\rho \\rvert \\ge 1$，返回该语言浮点类型的正无穷大值。\n- 最终输出必须是单行，包含一个逗号分隔的结果列表，并用方括号括起来（例如，$[a,b,c]$），其顺序与上述测试套件相同。有限结果必须四舍五入到六位小数；无限结果必须表示为该语言的浮点无穷大字面量。\n\n您的程序必须是自包含的，且不得读取任何输入。它必须精确地计算并打印一次上述测试套件的结果，并遵循要求的格式。", "solution": "问题陈述在科学上是合理的且定义明确。我们可以进行形式化推导。\n\n问题描述了一个偏差序列 $\\{y_t\\}$ 的一阶自回归过程。该偏差相对于其确定性成分的条件期望的演变由以下关系给出：\n$$ \\mathbb{E}[y_t | \\mathcal{F}_{t-1}] = \\rho y_{t-1} $$\n其中 $\\mathcal{F}_{t-1}$ 代表在时间 $t-1$ 可用的信息，而 $\\rho$ 是自回归系数。根据迭代期望定律，在未来 $h$ 个周期后，以时间 $t_0$ 的信息为条件，偏差的期望值为：\n$$ \\mathbb{E}[y_{t_0+h} | \\mathcal{F}_{t_0}] = \\rho^h y_{t_0} $$\n\n半衰期 $h(\\rho)$ 被定义为最小的非负实数周期数，在此之后，这个未来预期偏差的量值等于其初始量值 $|y_{t_0}|$ 的一半。这在数学上表示为：\n$$ |\\mathbb{E}[y_{t_0+h} | \\mathcal{F}_{t_0}]| = \\frac{1}{2} |y_{t_0}| $$\n代入条件期望的表达式，我们得到：\n$$ |\\rho^h y_{t_0}| = \\frac{1}{2} |y_{t_0}| $$\n对于任何 $y_{t_0} \\neq 0$ 的非平凡过程，我们可以将其简化为半衰期的核心方程：\n$$ |\\rho|^h = \\frac{1}{2} $$\n现在我们通过分析 $\\rho$ 值的三种穷尽且互斥的情况来求解 $h$。\n\n情况1：均值回归的平稳过程，其中 $0 < |\\rho| < 1$。\n在这种情况下，偏差的量值随时间呈指数衰减。为了求出 $h$，我们对等式两边取自然对数：\n$$ \\ln(|\\rho|^h) = \\ln\\left(\\frac{1}{2}\\right) $$\n利用对数的性质，这变为：\n$$ h \\ln(|\\rho|) = -\\ln(2) $$\n由于 $0 < |\\rho| < 1$，因此 $\\ln(|\\rho|)$ 是一个负实数。解出的 $h$ 必须是一个正结果：\n$$ h = -\\frac{\\ln(2)}{\\ln(|\\rho|)} = \\frac{\\ln(2)}{-\\ln(|\\rho|)} = \\frac{\\ln(2)}{\\ln(1/|\\rho|)} $$\n这为任何此类平稳自回归过程提供了一个唯一的、有限的、正的半衰期。\n\n情况2：单位根或爆炸性过程，其中 $|\\rho| \\ge 1$。\n如果 $|\\rho| = 1$，方程变为 $1^h = 1/2$，简化为 $1 = 1/2$。这是一个矛盾，对于非负的 $h$ 不存在解。预期偏差的量值不会衰减。\n如果 $|\\rho| > 1$，那么对于任何 $h > 0$，我们有 $|\\rho|^h > 1$。表达式 $|\\rho|^h$ 永远不会等于 $1/2$。预期偏差的量值会无界增长。\n在这两种子情况下，对于任何有限的 $h$，半衰期的条件都永远不会满足。因此，半衰期被定义为无穷大。\n$$ h(\\rho) = \\infty \\quad \\text{for } |\\rho| \\ge 1 $$\n\n情况3：瞬时衰减过程，其中 $\\rho = 0$。\n如果 $\\rho = 0$，动态方程为 $\\mathbb{E}[y_{t+1}|\\mathcal{F}_t] = 0 \\cdot y_t = 0$。预期偏差在一个周期后变为零。问题指定在这种情况下，半衰期应返回为 $0.0$。这是一种约定，表示衰减在第一个时间步内完成。\n$$ h(0) = 0 $$\n\n综合这些情况，半衰期 $h(\\rho)$ 的完整公式是：\n$$\nh(\\rho) =\n\\begin{cases}\n\\frac{\\ln(2)}{\\ln(1/|\\rho|)} & \\text{if } 0 < |\\rho| < 1 \\\\\n0 & \\text{if } \\rho = 0 \\\\\n\\infty & \\text{if } |\\rho| \\ge 1\n\\end{cases}\n$$\n\n我们将此公式应用于所提供的一组 $\\rho$ 值：\n- 对于 $\\rho = 0.8$：$h(0.8) = \\frac{\\ln(2)}{\\ln(1/0.8)} \\approx 3.106284$ 周期。\n- 对于 $\\rho = 0.98$：$h(0.98) = \\frac{\\ln(2)}{\\ln(1/0.98)} \\approx 34.308731$ 周期。\n- 对于 $\\rho = 0.5$：$h(0.5) = \\frac{\\ln(2)}{\\ln(1/0.5)} = \\frac{\\ln(2)}{\\ln(2)} = 1.0$ 周期。\n-对于 $\\rho = -0.5$：$h(-0.5) = \\frac{\\ln(2)}{\\ln(1/|-0.5|)} = \\frac{\\ln(2)}{\\ln(2)} = 1.0$ 周期。\n- 对于 $\\rho = 0.0$：根据定义，$h(0.0) = 0.0$ 周期。\n- 对于 $\\rho = 1.0$：$|\\rho|=1$，所以 $h(1.0) = \\infty$。\n- 对于 $\\rho = -1.0$：$|\\rho|=1$，所以 $h(-1.0) = \\infty$。\n- 对于 $\\rho = 1.05$：$|\\rho|>1$，所以 $h(1.05) = \\infty$。\n- 对于 $\\rho = -1.2$：$|\\rho|>1$，所以 $h(-1.2) = \\infty$。\n- 对于 $\\rho = 0.2$：$h(0.2) = \\frac{\\ln(2)}{\\ln(1/0.2)} = \\frac{\\ln(2)}{\\ln(5)} \\approx 0.430677$ 周期。\n\n实现将计算这些值，并按要求格式化它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the half-life of an autoregressive process for given coefficients.\n    \n    The half-life h(rho) is derived from the equation |rho|^h = 1/2.\n    - If 0 < |rho| < 1, h = ln(2) / ln(1/|rho|).\n    - If |rho| >= 1, the deviation does not halve, so h is infinite.\n    - If rho = 0, the problem specifies h = 0.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.8,\n        0.98,\n        0.5,\n        -0.5,\n        0.0,\n        1.0,\n        -1.0,\n        1.05,\n        -1.2,\n        0.2,\n    ]\n\n    results = []\n    \n    # Pre-compute ln(2) for efficiency\n    ln_2 = np.log(2)\n\n    for rho in test_cases:\n        # Calculate the absolute value of rho\n        abs_rho = abs(rho)\n        result = 0.0 # Placeholder for the result of one case\n\n        # Case 1: Unit root or explosive process (|rho| >= 1)\n        if abs_rho >= 1.0:\n            result = np.inf\n        # Case 2: Instantaneous decay (rho = 0)\n        # We must check this separately as log(1/0) is undefined.\n        elif rho == 0.0:\n            result = 0.0\n        # Case 3: Stationary mean-reverting process (0 < |rho| < 1)\n        else:\n            result = ln_2 / np.log(1.0 / abs_rho)\n        \n        results.append(result)\n\n    # Format the results for output.\n    # Finite numbers are rounded to 6 decimal places.\n    # Infinity is represented as 'inf'.\n    formatted_results = []\n    for res in results:\n        if res == np.inf:\n            formatted_results.append('inf')\n        else:\n            # Format to exactly six decimal places as required.\n            formatted_results.append(f'{res:.6f}')\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}