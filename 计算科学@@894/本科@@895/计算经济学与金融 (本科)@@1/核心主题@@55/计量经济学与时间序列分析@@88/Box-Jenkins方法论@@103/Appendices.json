{"hands_on_practices": [{"introduction": "应用Box-Jenkins方法论的第一步是确保时间序列是平稳的，如果不是，我们必须对其进行差分处理。这个练习将让你亲手实践如何通过在计算环境中应用统计检验来确定必要的差分阶数 $d$ [@problem_id:2378207]。这项实践旨在连接单位根等理论概念与实际编程实现，这是构建可靠ARIMA模型的关键前提。", "id": "2378207", "problem": "您的任务是，在自回归积分移动平均 (ARIMA) 模型的背景下，遵循 Box–Jenkins 方法论，确定能使给定时间序列达到协方差平稳的最小差分阶数。设 $\\{y_t\\}_{t=0}^{T}$ 为一个实值离散时间随机过程。定义后向差分算子 $\\Delta$ 为 $\\Delta y_t = y_t - y_{t-1}$，其 d 次迭代 $\\Delta^d y_t$ 指的是将 $\\Delta$ 应用 d 次。如果对于最小的非负整数 d，$\\Delta^d y_t$ 是协方差平稳的而 $\\Delta^{d-1} y_t$ 不是，则称该序列为 d 阶单整（记作 I(d)）。\n\n您的目标是编写一个程序，对以下每个数据生成过程（DGP），模拟一条样本路径，并确定使 $\\Delta^d y_t$ 协方差平稳的最小整数 $d \\in \\{0,1,2\\}$。出于经济学解释的考虑，可将第一个 DGP 视为货币流通速度（广义流动性版本，通常标记为 M2 速度）的一种程式化表征。\n\n所有过程都使用独立同分布的高斯新息 $\\{\\varepsilon_t\\}$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$，并采用指定的初始条件。除非另有说明，取 $y_0 = 0$。请使用指定的种子以确保可复现性。\n\n需要模拟和分析的 DGP 测试套件：\n1. 带漂移的随机游走 (程式化的 M2V)：\n   - 动态过程: $y_t = y_{t-1} + c + \\varepsilon_t$ for $t \\in \\{1,\\dots,T\\}$。\n   - 参数: $T = 500$, $c = 0.002$, $\\sigma = 0.01$, seed $= 1729$。\n2. 具有高持续性的一阶平稳自回归过程：\n   - 动态过程: $y_t = \\phi\\, y_{t-1} + \\varepsilon_t$ for $t \\in \\{1,\\dots,T\\}$。\n   - 参数: $T = 500$, $\\phi = 0.9$, $\\sigma = 0.05$, seed $= 2024$。\n3. 二阶单整：\n   - 动态过程: $\\Delta^2 y_t = \\varepsilon_t$ for $t \\in \\{1,\\dots,T\\}$ with $y_{-1} = 0$ and $y_0 = 0$。\n   - 等价表示: $y_t = 2 y_{t-1} - y_{t-2} + \\varepsilon_t$ for $t \\ge 1$。\n   - 参数: $T = 500$, $\\sigma = 0.05$, seed $= 7$。\n4. 具有中等持续性的一阶平稳自回归过程：\n   - 动态过程: $y_t = \\phi\\, y_{t-1} + \\varepsilon_t$ for $t \\in \\{1,\\dots,T\\}$。\n   - 参数: $T = 500$, $\\phi = 0.5$, $\\sigma = 0.05$, seed $= 11$。\n\n您的程序必须：\n- 使用指定参数为每个 DGP 模拟一条样本路径。\n- 对每条样本路径，使用基于协方差平稳性定义的、统计上可靠且可复现的决策规则，确定使 $\\Delta^d y_t$ 协方差平稳的最小 $d \\in \\{0,1,2\\}$。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与上述测试套件一致。例如，输出 $[1,0,2,0]$ 表示第一个序列被评估为 $I(1)$，第二个为 $I(0)$，第三个为 $I(2)$，第四个为 $I(0)$。\n\n不涉及物理单位或角度。所有输出必须是整数。您的程序不得要求用户任何输入，也不得从任何文件或网络读取或写入数据。最终输出格式必须是精确的一行：\n- 一个形式为 $[\\text{d}_1,\\text{d}_2,\\text{d}_3,\\text{d}_4]$ 的列表，其中每个 $\\text{d}_i \\in \\{0,1,2\\}$ 对应于 DGP $i$ 的估计单整阶数。", "solution": "问题陈述要求为几个指定的离散时间随机过程确定其单整阶数，记为 $d$。单整阶数 $d$ 定义为使一个时间序列达到协方差平稳所需的最小差分次数。这是时间序列计量经济学中的一项基本任务，尤其是在用于自回归积分移动平均（ARIMA）建模的 Box-Jenkins 框架内。\n\n在进行求解之前，我们必须确定问题的有效性。\n\n**问题验证**\n\n**第 1 步：提取已知信息**\n- 任务：为四个给定的数据生成过程 (DGP)，模拟一条样本路径，并确定使 $d$ 次差分序列 $\\Delta^d y_t$ 协方差平稳的最小整数 $d \\in \\{0,1,2\\}$。\n- 定义：如果 $\\Delta^d y_t$ 是平稳的而 $\\Delta^{d-1} y_t$ 不是，则称一个序列为 d 阶单整，记作 $I(d)$。\n- 数据生成过程 (DGP):\n    1. 带漂移的随机游走：$y_t = y_{t-1} + c + \\varepsilon_t$，其中 $T=500$, $c=0.002$, $\\sigma=0.01$, $y_0=0$, seed=$1729$。\n    2. 一阶平稳自回归过程 (AR(1))：$y_t = \\phi y_{t-1} + \\varepsilon_t$，其中 $T=500$, $\\phi=0.9$, $\\sigma=0.05$, $y_0=0$, seed=$2024$。\n    3. 二阶单整：$\\Delta^2 y_t = \\varepsilon_t$ (或 $y_t = 2y_{t-1} - y_{t-2} + \\varepsilon_t$)，其中 $T=500$, $\\sigma=0.05$, $y_{-1}=0, y_0=0$, seed=$7$。\n    4. 平稳 AR(1)：$y_t = \\phi y_{t-1} + \\varepsilon_t$，其中 $T=500$, $\\phi=0.5$, $\\sigma=0.05$, $y_0=0$, seed=$11$。\n- 新息：$\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$ 是独立同分布 (i.i.d.) 的高斯变量。\n- 方法论要求：使用“统计上可靠且可复现的决策规则”。\n- 输出格式：包含四个整数的单行列表 `[d1,d2,d3,d4]`。\n\n**第 2 步：使用提取的已知信息进行验证**\n- **科学依据：** 该问题基于时间序列分析中的标准经典模型（随机游走、AR(1) 过程），并采用了协方差平稳性、差分和单整阶数等明确定义的概念。这些是指定的 Box-Jenkins 方法论主题的核心。其前提在事实上和数学上都是合理的。\n- **适定性：** 所有 DGP 都有完整的参数、初始条件和随机种子说明，确保了可复现性。目标是明确的。“统计上可靠且可复现的决策规则”这一表述要求解决者选择一种适当的统计检验，这是该领域的标准期望。既定程序是一系列的单位根检验，例如增广 Dickey-Fuller (ADF) 检验。因此，该问题是适定的，因为存在一种标准方法来找到一个唯一的、可验证的解。\n- **客观性：** 该问题以精确的数学语言陈述，没有主观性或歧义。DGP 是客观模型。\n\n**第 3 步：结论与行动**\n该问题具有科学合理性、适定性和客观性。它包含了获得唯一解所需的所有必要信息。因此，该问题被判定为**有效的**。我们现在开始进行求解。\n\n**基于原理的解决方案**\n\n问题的核心是区分平稳与非平稳时间序列。如果一个离散时间随机过程 $\\{y_t\\}$ 的统计特性关于时间平移是不变的，那么它就是（弱）协方差平稳的。具体来说，对于所有整数 $t$ 和 $k$：\n1. 均值是常数：$E[y_t] = \\mu$。\n2. 方差是有限的常数：$Var(y_t) = \\sigma_y^2 < \\infty$。\n3. 自协方差仅取决于滞后阶数 $k$：$Cov(y_t, y_{t-k}) = \\gamma_k$。\n\n违反这些属性的过程是非平稳的。经济和金融数据中一种常见的非平稳性是存在单位根，此时过程具有无限记忆，其方差随时间增加。一个具有 $d$ 个单位根的过程被称为 $d$ 阶单整，记作 $I(d)$。通过将后向差分算子 $\\Delta$ 应用 $d$ 次，可以使这样的过程变得平稳，其中 $\\Delta y_t = y_t - y_{t-1}$。\n\n为了确定单整阶数 $d$，我们采用一种使用增广 Dickey-Fuller (ADF) 检验的序贯假设检验程序。ADF 检验旨在检测单位根的存在。它基于以下形式的 OLS 回归：\n$$ \\Delta y_t = \\alpha + \\beta t + \\gamma y_{t-1} + \\sum_{i=1}^{p} \\delta_i \\Delta y_{t-i} + u_t $$\n原假设是序列存在单位根（$H_0: \\gamma = 0$），备择假设是序列平稳或趋势平稳（$H_1: \\gamma < 0$）。检验统计量是估计系数 $\\hat{\\gamma}$ 的 t-统计量，在原假设下，它遵循非标准的 Dickey-Fuller 分布。我们将此统计量与预先制表的临界值进行比较。包含项 $\\alpha$（常数项）、$\\beta t$（时间趋势项）和滞后差分项 $\\Delta y_{t-i}$ 分别是为了解释过程中的漂移、确定性趋势和更高阶的自回归动态，以确保误差项 $u_t$ 是白噪声。\n\n是否包含常数项和趋势项的选择定义了三种主要的回归模型：\n- 无常数项，无趋势项 ('nc'): $\\Delta y_t = \\gamma y_{t-1} + \\dots$\n- 有常数项，无趋势项 ('c'): $\\Delta y_t = \\alpha + \\gamma y_{t-1} + \\dots$\n- 有常数项和趋势项 ('ct'): $\\Delta y_t = \\alpha + \\beta t + \\gamma y_{t-1} + \\dots$\n\n我们的算法步骤如下：\n1.  **模拟 DGP**：对于四个测试用例中的每一个，我们使用指定的参数、动态过程、初始条件和随机种子，生成长度为 $T+1 = 501$ 个点（$t=0, \\dots, 500$）的样本路径。\n2.  **实现 ADF 检验**：由于所需的库 `numpy` 和 `scipy` 不包含预构建的 ADF 检验，我们从第一性原理出发实现它。这包括为 OLS 回归构建因变量和设计矩阵，使用 `numpy.linalg.lstsq` 求解系数，并计算系数 $\\gamma$ 的 t-统计量。为简单起见，并考虑到 DGP 的性质，我们将使用 $p=1$ 的固定滞后阶数。\n3.  **序贯检验程序**：对每个模拟序列，我们通过以下步骤确定最小的 $d \\in \\{0, 1, 2\\}$，使用的显著性水平为 5%：\n    -   **检验 $d=0$**：我们检验原始序列 $y_t$ 是否存在单位根。为对潜在的确定性趋势具有稳健性，我们使用 'ct' 模型。5% 的临界值约为 $-3.41$。如果 ADF 统计量小于此值，我们拒绝存在单位根的原假设，并得出结论 $d=0$。\n    -   **检验 $d=1$**：如果前一个检验未能拒绝 $H_0$，我们检验一阶差分序列 $\\Delta y_t$。该序列应不再具有确定性趋势，但可能具有非零均值（漂移）。我们使用 'c' 模型。5% 的临界值约为 $-2.86$。如果 ADF 统计量小于此值，我们得出结论 $d=1$。\n    -   **检验 $d=2$**：如果前两个检验都未能拒绝原假设，我们检验二阶差分序列 $\\Delta^2 y_t$。该序列应为一个零均值平稳过程。我们使用 'nc' 模型。5% 的临界值约为 $-1.94$。如果 ADF 统计量小于此值，我们得出结论 $d=2$。如果此检验也未能拒绝，我们根据问题陈述的规定，将 $d=2$ 赋为其最高阶数。\n\n这个严谨的、基于原理的程序提供了问题陈述所要求的“统计上可靠且可复现的决策规则”。", "answer": "```python\nimport numpy as np\n# from scipy import linalg # numpy.linalg is sufficient and preferred.\n\ndef solve():\n    \"\"\"\n    Simulates four time series processes and determines their order of integration d.\n    \"\"\"\n\n    def adf_test(series: np.ndarray, p: int, regression_type: str) -> float:\n        \"\"\"\n        Performs an Augmented Dickey-Fuller test.\n\n        Args:\n            series: The time series to test.\n            p: The number of lagged differences to include.\n            regression_type: 'nc' (no constant), 'c' (constant), 'ct' (constant, trend).\n\n        Returns:\n            The ADF t-statistic for the lagged level term.\n        \"\"\"\n        n_obs = len(series)\n        dx = np.diff(series)\n\n        # Dependent variable (y_t - y_{t-1})\n        y = dx[p:]\n        n_reg_obs = len(y)\n\n        # Build design matrix X for OLS: y = X*beta + error\n        # Column 0: Lagged level (y_{t-1})\n        X = [series[p:-1]]\n\n        # Columns 1 to p: Lagged differences\n        if p > 0:\n            for i in range(p):\n                # Lag i is dx_{t-i}, index is p-i-1 relative to start of dx\n                X.append(dx[p - i - 1 : n_reg_obs + p - i - 1])\n\n        # Add constant and/or trend\n        if regression_type == 'c':\n            X.append(np.ones(n_reg_obs))\n        elif regression_type == 'ct':\n            X.append(np.ones(n_reg_obs))\n            # Trend starts from time p+1\n            trend = np.arange(p + 1, n_obs)\n            X.append(trend)\n\n        X = np.stack(X, axis=1)\n\n        # Perform OLS using np.linalg.lstsq\n        try:\n            coeffs, residuals_sum_sq, rank, s = np.linalg.lstsq(X, y, rcond=None)\n        except np.linalg.LinAlgError:\n            return 0.0 # Cannot solve, return value that won't reject H0\n        \n        n_regressors = X.shape[1]\n        if rank < n_regressors:\n            return 0.0 # Singular matrix, cannot compute reliably\n\n        # Extract coefficient for the lagged level term\n        gamma_hat = coeffs[0]\n\n        # Calculate standard error of gamma_hat\n        # residuals_sum_sq from lstsq is a single-element array\n        res_var = residuals_sum_sq[0] / (n_reg_obs - n_regressors)\n        xtx_inv = np.linalg.inv(X.T @ X)\n        se_gamma_hat = np.sqrt(res_var * xtx_inv[0, 0])\n\n        if se_gamma_hat == 0:\n            return 0.0\n\n        adf_stat = gamma_hat / se_gamma_hat\n        return adf_stat\n\n    def determine_d(series: np.ndarray) -> int:\n        \"\"\"\n        Determines the order of integration d for a series by sequential ADF tests.\n        \"\"\"\n        # Critical values for a 5% significance level, T~500\n        cv_ct = -3.41  # Model with constant and trend\n        cv_c = -2.86   # Model with constant\n        cv_nc = -1.94  # Model with no constant\n\n        p = 1 # Number of lags for ADF test\n\n        # Test for d=0 (I(0))\n        adf_stat_0 = adf_test(series, p, 'ct')\n        if adf_stat_0 < cv_ct:\n            return 0\n\n        # Test for d=1 (I(1))\n        diff1 = np.diff(series)\n        adf_stat_1 = adf_test(diff1, p, 'c')\n        if adf_stat_1 < cv_c:\n            return 1\n            \n        # Test for d=2 (I(2))\n        diff2 = np.diff(series, n=2)\n        adf_stat_2 = adf_test(diff2, p, 'nc')\n        if adf_stat_2 < cv_nc:\n            return 2\n        \n        # If all tests fail to reject, return highest order as per problem spec\n        return 2\n\n    # --- Test Suite---\n    \n    T = 500\n    test_cases = [\n        {'type': 'rw_drift', 'T': T, 'c': 0.002, 'sigma': 0.01, 'seed': 1729},\n        {'type': 'ar1', 'T': T, 'phi': 0.9, 'sigma': 0.05, 'seed': 2024},\n        {'type': 'i2', 'T': T, 'sigma': 0.05, 'seed': 7},\n        {'type': 'ar1', 'T': T, 'phi': 0.5, 'sigma': 0.05, 'seed': 11},\n    ]\n\n    results = []\n\n    for params in test_cases:\n        np.random.seed(params['seed'])\n        eps = np.random.normal(0, params['sigma'], params['T'] + 1)\n        y = np.zeros(params['T'] + 1)\n\n        if params['type'] == 'rw_drift':\n            # y_t = y_{t-1} + c + eps_t, with y_0 = 0\n            for t in range(1, params['T'] + 1):\n                y[t] = y[t-1] + params['c'] + eps[t]\n        \n        elif params['type'] == 'ar1':\n            # y_t = phi * y_{t-1} + eps_t, with y_0 = 0\n            for t in range(1, params['T'] + 1):\n                y[t] = params['phi'] * y[t-1] + eps[t]\n\n        elif params['type'] == 'i2':\n            # y_t = 2*y_{t-1} - y_{t-2} + eps_t, with y_{-1}=0, y_0=0\n            # Note: y array starts with y_0. y_{-1} is implicitly 0.\n            y[1] = 2 * y[0] - 0 + eps[1] # y_1 = eps_1\n            for t in range(2, params['T'] + 1):\n                y[t] = 2 * y[t-1] - y[t-2] + eps[t]\n        \n        # Determine the order of integration for the simulated series\n        d = determine_d(y)\n        results.append(d)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "一旦我们获得了（或转换得到）平稳序列，下一步就是识别自回归（AR）和移动平均（MA）阶数并估计模型参数。本练习聚焦于AR模型参数估计背后的核心逻辑 [@problem_id:2378239]。通过亲手求解Yule-Walker方程，你将更深刻地理解一个过程的自相关性与其潜在参数之间的关系，这是模型估计过程中的一个基本概念。", "id": "2378239", "problem": "在计算经济学和金融学的时间序列建模中，根据 Box–Jenkins 方法论，考虑一个弱平稳的二阶自回归过程，记为二阶自回归 (AR(2)) 过程。该过程用于模拟宏观金融序列，例如对数消费增长率与其均值的偏差。设该过程由参数 $\\phi_1$ 和 $\\phi_2$ 刻画，并令 $\\rho_k$ 表示滞后 $k$ 阶的自相关。在弱平稳性条件下，Yule–Walker 方程将自相关与自回归参数联系起来。假定前两阶自相关与参数之间存在以下关系：$\\rho_1 = \\phi_1 + \\phi_2 \\rho_1$ 和 $\\rho_2 = \\phi_1 \\rho_1 + \\phi_2$。从 AR(2) 结构以及自协方差和自相关函数的定义出发，可以将这些关系确立为连接二阶矩与动态过程的平衡条件。仅使用这两个关系，求解该方程组，将 $\\phi_1$ 和 $\\phi_2$ 表示为 $\\rho_1$ 和 $\\rho_2$ 的显式函数。你的最终答案必须是闭式解析表达式。如果解的唯一性需要任何正则性条件，请在推理过程中说明，但不要包含在最终答案中。无需进行数值计算。", "solution": "所提出的问题是，将一个弱平稳二阶自回归过程 (记为 AR(2)) 的自回归参数 $\\phi_1$ 和 $\\phi_2$ 确定为前两阶理论自相关 $\\rho_1$ 和 $\\rho_2$ 的函数。所给出的关系是滞后 $k=1$ 和 $k=2$ 时的 Yule-Walker 方程。它们构成了一个含有两个未知数 $\\phi_1$ 和 $\\phi_2$ 的二元线性方程组。\n\n给定的方程组为：\n$$\n\\rho_1 = \\phi_1 + \\phi_2 \\rho_1 \\quad (1)\n$$\n$$\n\\rho_2 = \\phi_1 \\rho_1 + \\phi_2 \\quad (2)\n$$\n\n为便于求解 $\\phi_1$ 和 $\\phi_2$，我们可以将该方程组重排为标准矩阵形式 $A\\mathbf{x} = \\mathbf{b}$，其中 $\\mathbf{x} = \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix}$。\n方程 ($1$) 可写作：\n$$\n1 \\cdot \\phi_1 + \\rho_1 \\cdot \\phi_2 = \\rho_1\n$$\n方程 ($2$) 可写作：\n$$\n\\rho_1 \\cdot \\phi_1 + 1 \\cdot \\phi_2 = \\rho_2\n$$\n该方程组的矩阵形式为：\n$$\n\\begin{pmatrix} 1 & \\rho_1 \\\\ \\rho_1 & 1 \\end{pmatrix} \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} \\rho_1 \\\\ \\rho_2 \\end{pmatrix}\n$$\n这个方程组可以使用多种解线性系统的方法求解，例如代入法、消元法或矩阵求逆（例如，使用 Cramer's rule）。我们将采用代数代入法进行求解。\n\n从方程 ($2$) 中，我们可以用 $\\phi_1$ 和已知的自相关表示 $\\phi_2$：\n$$\n\\phi_2 = \\rho_2 - \\phi_1 \\rho_1\n$$\n现在，将这个 $\\phi_2$ 的表达式代入方程 ($1$)：\n$$\n\\rho_1 = \\phi_1 + (\\rho_2 - \\phi_1 \\rho_1) \\rho_1\n$$\n我们分配右侧的 $\\rho_1$ 项：\n$$\n\\rho_1 = \\phi_1 + \\rho_1 \\rho_2 - \\phi_1 \\rho_1^2\n$$\n接下来，我们将所有含 $\\phi_1$ 的项移到方程一侧，其余项移到另一侧，以求解 $\\phi_1$：\n$$\n\\rho_1 - \\rho_1 \\rho_2 = \\phi_1 - \\phi_1 \\rho_1^2\n$$\n在右侧提出公因子 $\\phi_1$，在左侧提出公因子 $\\rho_1$：\n$$\n\\rho_1 (1 - \\rho_2) = \\phi_1 (1 - \\rho_1^2)\n$$\n为了分离出 $\\phi_1$，我们必须除以 $(1 - \\rho_1^2)$。这一步需要一个保证解唯一性的正则性条件，即系数矩阵的行列式不为零。行列式为 $1 \\cdot 1 - \\rho_1 \\cdot \\rho_1 = 1 - \\rho_1^2$。因此，条件是 $1 - \\rho_1^2 \\neq 0$，这等价于 $|\\rho_1| \\neq 1$。对于任何非确定性的弱平稳过程，对于任意非零滞后 $k$，其自相关 $|\\rho_k|$ 必须严格小于 $1$。因此，对于我们所关注的平稳 AR($2$) 过程，我们有 $|\\rho_1| < 1$，这保证了该条件得到满足。\n\n进行除法运算，我们得到 $\\phi_1$ 的表达式：\n$$\n\\phi_1 = \\frac{\\rho_1 (1 - \\rho_2)}{1 - \\rho_1^2}\n$$\n现在我们将这个 $\\phi_1$ 的表达式代回我们关于 $\\phi_2$ 的方程中：\n$$\n\\phi_2 = \\rho_2 - \\rho_1 \\phi_1 = \\rho_2 - \\rho_1 \\left( \\frac{\\rho_1 (1 - \\rho_2)}{1 - \\rho_1^2} \\right)\n$$\n化简表达式：\n$$\n\\phi_2 = \\rho_2 - \\frac{\\rho_1^2 (1 - \\rho_2)}{1 - \\rho_1^2}\n$$\n为了合并各项，我们使用公分母 $(1 - \\rho_1^2)$:\n$$\n\\phi_2 = \\frac{\\rho_2 (1 - \\rho_1^2) - \\rho_1^2 (1 - \\rho_2)}{1 - \\rho_1^2}\n$$\n展开分子：\n$$\n\\phi_2 = \\frac{\\rho_2 - \\rho_2 \\rho_1^2 - \\rho_1^2 + \\rho_1^2 \\rho_2}{1 - \\rho_1^2}\n$$\n项 $-\\rho_2 \\rho_1^2$ 和 $+\\rho_1^2 \\rho_2$ 相互抵消，得到 $\\phi_2$ 的最终表达式：\n$$\n\\phi_2 = \\frac{\\rho_2 - \\rho_1^2}{1 - \\rho_1^2}\n$$\n因此，我们成功地将自回归参数 $\\phi_1$ 和 $\\phi_2$ 表示为自相关 $\\rho_1$ 和 $\\rho_2$ 的显式函数。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\rho_1(1 - \\rho_2)}{1 - \\rho_1^2} & \\frac{\\rho_2 - \\rho_1^2}{1 - \\rho_1^2} \\end{pmatrix}}\n$$"}, {"introduction": "建立时间序列模型的最终目的往往是预测未来。最后的这项实践将带你从模型构建阶段走向模型应用阶段 [@problem_id:2378255]。它提供了一个具体的练习，不仅要计算点预测，还要计算预测区间，后者是量化这些预测周围不确定性的关键，对于在经济和金融领域做出明智决策至关重要。", "id": "2378255", "problem": "考虑在 Box–Jenkins 框架下的以下一阶自回归 (AR(1)) 模型，该模型用于描述一个单变量、零均值、协方差平稳的时间序列 $\\{X_t\\}$：\n$$\nX_t = 0.8\\,X_{t-1} + \\epsilon_t,\n$$\n其中 $\\{\\epsilon_t\\}$ 是独立同分布 (i.i.d.) 的高斯新息，满足 $\\epsilon_t \\sim \\mathcal{N}(0,\\sigma_{\\epsilon}^{2})$ 且 $\\sigma_{\\epsilon}^{2} = 4$。观测到 $X_T = 100$。计算未来三步的点预测值 $X_{T+1|T}$、$X_{T+2|T}$、$X_{T+3|T}$，并在高斯假设下，为每个预测值计算相应的双侧 $95\\%$ 预测区间。使用标准正态分位数 $z_{0.975} = 1.96$。\n\n答案格式与舍入要求：\n- 请将最终答案表示为单个 $1 \\times 9$ 的行矩阵，顺序如下：\n$$\n\\big(X_{T+1|T},\\ \\text{Lower}_{T+1},\\ \\text{Upper}_{T+1},\\ X_{T+2|T},\\ \\text{Lower}_{T+2},\\ \\text{Upper}_{T+2},\\ X_{T+3|T},\\ \\text{Lower}_{T+3},\\ \\text{Upper}_{T+3}\\big).\n$$\n- 将每个数值舍入至四位有效数字。\n- 最终答案中不包含任何单位。", "solution": "所给问题是有效的。这是一个时间序列分析中定义明确的问题，其基础是成熟的 Box-Jenkins 自回归模型方法论。所有必要的参数和条件都已提供，不存在科学或逻辑上的矛盾。我们将开始推导解答。\n\n该模型是一个一阶自回归过程，即 AR($1$)，由下式给出：\n$$X_t = \\phi X_{t-1} + \\epsilon_t$$\n指定的参数为 $\\phi = 0.8$，新息 $\\{\\epsilon_t\\}$ 是独立同分布的高斯随机变量，其均值为 $0$，方差为 $\\sigma_{\\epsilon}^2 = 4$。最终观测值为 $X_T = 100$。\n\n首先，我们计算点预测值。未来 $h$ 步的点预测值，记为 $X_{T+h|T}$，是 $X_{T+h}$ 在给定截至时间 $T$ 的所有可用信息（我们记为 $\\mathcal{F}_T$）下的条件期望。\n$$X_{T+h|T} = E[X_{T+h} | \\mathcal{F}_T]$$\n对于 AR($1$) 模型，预测的递归性质为 $X_{T+h|T} = \\phi X_{T+h-1|T}$。通过重复代入，可以得到点预测的通用公式：\n$$X_{T+h|T} = \\phi^h X_T$$\n\n我们将此公式应用于 $h=1, 2, 3$。\n当 $h=1$ 时：\n$$X_{T+1|T} = \\phi X_T = 0.8 \\times 100 = 80$$\n当 $h=2$ 时：\n$$X_{T+2|T} = \\phi^2 X_T = (0.8)^2 \\times 100 = 0.64 \\times 100 = 64$$\n当 $h=3$ 时：\n$$X_{T+3|T} = \\phi^3 X_T = (0.8)^3 \\times 100 = 0.512 \\times 100 = 51.2$$\n\n接下来，我们构建 $95\\%$ 的预测区间。$X_{T+h}$ 的一个双侧 $(1-\\alpha) \\times 100\\%$ 预测区间由下式给出：\n$$X_{T+h|T} \\pm z_{1-\\alpha/2} \\sqrt{\\text{Var}(e_T(h))}$$\n其中 $e_T(h) = X_{T+h} - X_{T+h|T}$ 是 $h$ 步预测误差，$z_{1-\\alpha/2}$ 是标准正态分布的相应分位数。对于 $95\\%$ 的区间，$\\alpha=0.05$，且题目已给出 $z_{0.975} = 1.96$。\n\n预测误差的方差 $\\text{Var}(e_T(h))$ 是从预测误差的移动平均表示中推导出来的。对于 AR($1$) 过程，其 $h$ 步预测误差为：\n$$e_T(h) = \\epsilon_{T+h} + \\phi \\epsilon_{T+h-1} + \\dots + \\phi^{h-1} \\epsilon_{T+1} = \\sum_{j=0}^{h-1} \\phi^j \\epsilon_{T+h-j}$$\n由于新息 $\\{\\epsilon_t\\}$ 是独立的且方差为 $\\sigma_{\\epsilon}^2$，误差的方差为：\n$$\\text{Var}(e_T(h)) = \\text{Var}\\left(\\sum_{j=0}^{h-1} \\phi^j \\epsilon_{T+h-j}\\right) = \\sum_{j=0}^{h-1} (\\phi^j)^2 \\text{Var}(\\epsilon_{T+h-j}) = \\sigma_{\\epsilon}^2 \\sum_{j=0}^{h-1} \\phi^{2j}$$\n这是一个有限几何级数的和：\n$$\\text{Var}(e_T(h)) = \\sigma_{\\epsilon}^2 \\frac{1 - \\phi^{2h}}{1 - \\phi^2}$$\n我们已知 $\\sigma_{\\epsilon}^2 = 4$ 且 $\\phi=0.8$。\n\n当 $h=1$ 时：\n预测误差方差为 $\\text{Var}(e_T(1)) = \\sigma_{\\epsilon}^2 = 4$。\n误差的标准差为 $\\sqrt{\\text{Var}(e_T(1))} = \\sqrt{4} = 2$。\n预测区间的半宽为 $z_{0.975} \\times 2 = 1.96 \\times 2 = 3.92$。\n区间为 $80 \\pm 3.92$，即：\n下界：$80 - 3.92 = 76.08$\n上界：$80 + 3.92 = 83.92$\n\n当 $h=2$ 时：\n预测误差方差为 $\\text{Var}(e_T(2)) = \\sigma_{\\epsilon}^2 (1 + \\phi^2) = 4(1 + (0.8)^2) = 4(1 + 0.64) = 4(1.64) = 6.56$。\n误差的标准差为 $\\sqrt{6.56}$。\n预测区间的半宽为 $z_{0.975} \\times \\sqrt{6.56} = 1.96 \\times \\sqrt{6.56} \\approx 5.02005$。\n区间为 $64 \\pm 5.02005$，即：\n下界：$64 - 5.02005 = 58.97995$\n上界：$64 + 5.02005 = 69.02005$\n\n当 $h=3$ 时：\n预测误差方差为 $\\text{Var}(e_T(3)) = \\sigma_{\\epsilon}^2 (1 + \\phi^2 + \\phi^4) = 4(1 + (0.8)^2 + (0.8)^4) = 4(1 + 0.64 + 0.4096) = 4(2.0496) = 8.1984$。\n误差的标准差为 $\\sqrt{8.1984}$。\n预测区间的半宽为 $z_{0.975} \\times \\sqrt{8.1984} = 1.96 \\times \\sqrt{8.1984} \\approx 5.61195$。\n区间为 $51.2 \\pm 5.61195$，即：\n下界：$51.2 - 5.61195 = 45.58805$\n上界：$51.2 + 5.61195 = 56.81195$\n\n最后，我们按要求将所有结果舍入至四位有效数字。\n$X_{T+1|T} = 80.00$\nLower$_{T+1} = 76.08$\nUpper$_{T+1} = 83.92$\n$X_{T+2|T} = 64.00$\nLower$_{T+2} = 58.98$\nUpper$_{T+2} = 69.02$\n$X_{T+3|T} = 51.20$\nLower$_{T+3} = 45.59$\nUpper$_{T+3} = 56.81$\n\n将这些值汇编到最终的答案矩阵中。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n80.00 & 76.08 & 83.92 & 64.00 & 58.98 & 69.02 & 51.20 & 45.59 & 56.81\n\\end{pmatrix}\n}\n$$"}]}