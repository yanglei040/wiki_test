{"hands_on_practices": [{"introduction": "本练习将带你实践 Box-Jenkins 方法论中的一个基本步骤：模型识别。通过检查样本自相关函数 (ACF) 和偏自相关函数 (PACF) 的特征模式，你可以推断出合适的 $ARMA(p,q)$ 模型阶数。掌握这项技能对于构建有效的时间序列预测至关重要，它能帮助你从数据本身的行为中选择最简约且最合适的模型结构 [@problem_id:1282998]。", "id": "1282998", "problem": "一位环境科学家正在分析一个代表某特定城市多年来日均温度异常的时间序列数据集。该数据已被证实是平稳的。为了给该时间序列确定一个合适的模型，该科学家计算了样本自相关函数（ACF）和样本偏自相关函数（PACF）。\n\n分析揭示了以下两个关键特征：\n1. 样本ACF随着滞后的增加呈指数级衰减趋向于零。\n2. 样本PACF在滞后1和滞后2处显示出两个统计上显著的尖峰，然后突然截断，所有后续的相关性在统计上都不显著（即，在零附近的置信区间内）。\n\n基于对ACF和PACF的这些观察，下列哪个自回归移动平均（ARMA）模型（记为ARMA(p,q)，其中'p'是自回归阶数，'q'是移动平均阶数）是对此时间序列建模最合适的选择？\n\nA. ARMA(2,0)\nB. ARMA(0,2)\nC. ARMA(1,1)\nD. ARMA(2,2)\nE. ARMA(0,0)", "solution": "我们用一个ARMA$(p,q)$过程来为一个平稳的单变量时间序列 $\\{X_{t}\\}$ 建模，其定义为\n$$\nX_{t}=\\sum_{i=1}^{p}\\phi_{i}X_{t-i}+\\varepsilon_{t}+\\sum_{j=1}^{q}\\theta_{j}\\varepsilon_{t-j},\n$$\n其中 $\\{\\varepsilon_{t}\\}$ 是均值为 $0$、方差为 $\\sigma_{\\varepsilon}^{2}$ 的白噪声。令 $\\rho_{k}$ 表示滞后 $k$ 处的自相关函数（ACF），$\\alpha_{k}$ 表示滞后 $k$ 处的偏自相关函数（PACF）。\n\n关键的识别属性：\n- 对于AR$(p)$过程（即 $q=0$）：当 $k\\to\\infty$ 时，$\\rho_{k}$ 呈指数级或阻尼正弦式衰减，而PACF在滞后 $p$ 后截断，即对于所有 $k>p$，有 $\\alpha_{k}=0$。\n- 对于MA$(q)$过程（即 $p=0$）：ACF在滞后 $q$ 后截断，即对于所有 $k>q$，有 $\\rho_{k}=0$，而PACF呈指数级或阻尼正弦式衰减。\n- 对于 $p\\geq 1$ 且 $q\\geq 1$ 的ARMA$(p,q)$过程：$\\rho_{k}$ 和 $\\alpha_{k}$ 通常都呈指数级或阻尼正弦式衰减，没有明显的截断。\n\n给定的观察结果：\n1. 样本ACF随着滞后增加呈指数级衰减趋向于零。这排除了有限 $q>0$ 的纯MA$(q)$模型（其ACF会截断），并与AR$(p)$或ARMA$(p,q)$模型一致。\n2. 样本PACF在滞后1和2处显示出两个显著的尖峰，然后突然截断（之后不显著）。这是AR$(2)$过程的标志性特征，即PACF在 $p=2$ 处截断。\n\n综合这两点，ACF的行为（衰减）和PACF的行为（在2处截断）唯一地指向一个没有MA项的AR$(2)$过程，即ARMA$(2,0)$。\n\n检查选项：\n- A. ARMA$(2,0)$ 符合AR$(2)$的特征：ACF衰减，PACF在2处截断。\n- B. ARMA$(0,2)$ 的ACF应在滞后2处截断，这与观察到的指数衰减相矛盾。\n- C. ARMA$(1,1)$ 通常会显示ACF和PACF均衰减，而不是PACF在滞后2处截断。\n- D. ARMA$(2,2)$ 通常会显示ACF和PACF均衰减，而不是PACF在滞后2处截断。\n- E. ARMA$(0,0)$ （白噪声）在滞后0之后不会有显著的ACF或PACF，这与观察结果相矛盾。\n\n因此，最合适的模型是ARMA$(2,0)$，对应于选项A。", "answer": "$$\\boxed{A}$$"}, {"introduction": "模型估计只是工作的一半，批判性地解读结果同样至关重要。本问题提出了一个实践中常见的场景：当估计的自回归系数 $\\hat{\\phi}$ 和移动平均系数 $\\hat{\\theta}$ 几乎相等时，这通常意味着模型存在冗余。理解这一诊断线索有助于遵循简约性原则，避免过度参数化，并可能揭示数据预处理（如差分）中存在的问题 [@problem_id:2378231]。", "id": "2378231", "problem": "您正在使用 Box–Jenkins 方法对金融时间序列的季度超额收益进行建模。假设您对一个去均值化的序列 $\\{y_t\\}$ 拟合了一个阶数为 $\\left(1,1\\right)$ 的自回归移动平均 (ARMA) 模型，其形式如下\n$$\ny_t \\;=\\; \\phi\\, y_{t-1} \\;+\\; \\varepsilon_t \\;-\\; \\theta\\, \\varepsilon_{t-1},\n$$\n其中 $\\{\\varepsilon_t\\}$ 是一个均值为零、方差为 $\\sigma^2$ 的白噪声序列，$\\phi$ 是自回归系数，$\\theta$ 是移动平均系数。您的估计值满足 $\\hat{\\phi} \\approx \\hat{\\theta}$，并且两者在常规水平下均具有统计显著性。\n\n在 Box–Jenkins 框架内，以下哪种解释最为恰当？\n\nA. $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 近似相等表明自回归和移动平均的动态效应几乎相互抵消，因此该过程的行为接近白噪声；模型很可能过度参数化，并且如果之前进行了差分，则序列可能被过度差分。应考虑简化为 AR$\\left(1\\right)$ 或 MA$\\left(1\\right)$ 模型，或使用更低阶的差分。\n\nB. 这些估计值提供了 $y_t$ 中存在单位根的强有力证据，因此您应该对序列再进行一次差分，并用 $d \\leftarrow d + 1$ 重新拟合一个 ARIMA 模型。\n\nC. 因为 $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 相近且具有统计显著性，所以模型必然违反了平稳性或可逆性，意味着 $|\\phi| \\ge 1$ 或 $|\\theta| \\ge 1$。\n\nD. $\\hat{\\phi} \\approx \\hat{\\theta}$ 的模式主要表明存在未建模的季节性；您应该在季节性滞后项上添加阶数为 $\\left(1,1\\right)$ 的季节性自回归和移动平均项。", "solution": "此问题要求在 Box–Jenkins 方法的背景下，对自回归移动平均 (ARMA) 模型的一个特定估计结果进行解释。该问题陈述是有效的，因为它科学地基于时间序列计量经济学的既定原则，问题提法良好，并使用了客观、精确的语言。\n\n我们必须分析所提供的阶数为 $(1,1)$ 的 ARMA 模型，该模型为一个去均值化的时间序列 $\\{y_t\\}$ 指定，形式如下：\n$$\ny_t \\;=\\; \\phi\\, y_{t-1} \\;+\\; \\varepsilon_t \\;-\\; \\theta\\, \\varepsilon_{t-1}\n$$\n在这里，$\\{\\varepsilon_t\\}$ 表示一个均值为 $0$、方差为 $\\sigma^2$ 的白噪声过程。估计得出的关键发现是，自回归系数的估计值 $\\hat{\\phi}$ 近似等于移动平均系数的估计值 $\\hat{\\theta}$，即 $\\hat{\\phi} \\approx \\hat{\\theta}$。\n\n为了理解这一结果的含义，我们使用由 $L^k z_t = z_{t-k}$ 定义的后移算子 $L$。ARMA($1,1$) 模型方程可以改写为：\n$$\ny_t - \\phi L y_t = \\varepsilon_t - \\theta L \\varepsilon_t\n$$\n将 $y_t$ 和 $\\varepsilon_t$ 因子分解出来，我们得到多项式表示法：\n$$\n(1 - \\phi L) y_t = (1 - \\theta L) \\varepsilon_t\n$$\n条件 $\\hat{\\phi} \\approx \\hat{\\theta}$ 意味着自回归多项式 $\\Phi(L) = 1 - \\phi L$ 和移动平均多项式 $\\Theta(L) = 1 - \\theta L$ 几乎相同。如果 $\\phi$ 精确等于 $\\theta$，方程将是：\n$$\n(1 - \\phi L) y_t = (1 - \\phi L) \\varepsilon_t\n$$\n对于一个平稳且可逆的过程，我们必须有 $|\\phi| < 1$ 和 $|\\theta| < 1$。在平稳性条件 $|\\phi| < 1$ 下，算子 $(1 - \\phi L)$ 是可逆的。原则上，我们可以从方程两边消去这个公因子，从而得到：\n$$\ny_t = \\varepsilon_t\n$$\n这个结果方程描述了一个白噪声过程。因此，条件 $\\hat{\\phi} \\approx \\hat{\\theta}$ 强烈暗示自回归和移动平均部分正在相互抵消，且过程 $\\{y_t\\}$ 是或者非常接近白噪声。\n\n用 ARMA($1,1$) 模型来建模一个白噪声过程是**过度参数化**的一个实例。Box–Jenkins 方法强调**简约性原则**，该原则要求应选择能够对数据提供充分描述的最简单模型。一个 ARMA($0,0$) 模型（即白噪声）比一个 ARMA($1,1$) 模型更简约。发现 $\\hat{\\phi} \\approx \\hat{\\theta}$ 是一个典型的诊断信号，表明模型可能过度参数化，应当进行简化。\n\n此外，这种类型的参数冗余是**过度差分**的一个已知症状。如果对一个平稳序列进行差分，会在其移动平均部分引入一个单位根。例如，如果原始序列已经是平稳的，比如说 $z_t = \\eta_t$ 其中 $\\eta_t$ 是白噪声，而我们错误地进行一阶差分得到 $y_t = z_t - z_{t-1} = \\eta_t - \\eta_{t-1}$，那么所得到的过程 $y_t$ 是一个 $\\theta=1$ 的不可逆 MA($1$) 过程。当对这样的序列拟合 ARMA($1,1$) 模型时，估计量通常会产生彼此接近且接近单位根的系数 $\\hat{\\phi}$ 和 $\\hat{\\theta}$（即 $\\hat{\\phi} \\approx \\hat{\\theta} \\approx 1$），因为 AR 部分试图抵消由差分引入的 MA 单位根。因此，如果 $y_t$ 是通过对另一个序列进行差分得到的，那么参数冗余就是一个强有力的指标，表明差分操作是不必要的。\n\n现在我们基于此分析来评估给出的选项。\n\n**A. $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 近似相等表明自回归和移动平均的动态效应几乎相互抵消，因此该过程的行为接近白噪声；模型很可能过度参数化，并且如果之前进行了差分，则序列可能被过度差分。应考虑简化为 AR$\\left(1\\right)$ 或 MA$\\left(1\\right)$ 模型，或使用更低阶的差分。**\n这个陈述是对情况的精确而完整的描述。它正确地指出了动态效应的抵消、过程接近白噪声的含义、过度参数化的问题，以及与过度差分的潜在联系。所建议的措施——将模型简化为 AR($1$)、MA($1$)，甚至 ARMA($0,0$)，或者降低差分阶数——是根据 Box–Jenkins 方法论的标准和正确补救措施。\n结论：**正确**。\n\n**B. 这些估计值提供了 $y_t$ 中存在单位根的强有力证据，因此您应该对序列再进行一次差分，并用 $d \\leftarrow d + 1$ 重新拟合一个 ARIMA 模型。**\n这种解释是不正确的。过程 $y_t$ 中的单位根将由自回归多项式 $(1-\\phi L)$ 中的 $\\phi=1$ 来表征。条件 $\\hat{\\phi} \\approx \\hat{\\theta}$ 本身并不意味着 $\\hat{\\phi} \\approx 1$。相反，它预示着冗余。对序列再进行一次差分是错误的做法，因为证据指向的是可能存在的过度差分，而不是差分不足。进一步差分会加剧问题。\n结论：**不正确**。\n\n**C. 因为 $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 相近且具有统计显著性，所以模型必然违反了平稳性或可逆性，意味着 $|\\phi| \\ge 1$ 或 $|\\theta| \\ge 1$。**\n这个陈述做出了一个必然性的断言，而这个断言是错误的。完全有可能出现 $\\hat{\\phi} \\approx \\hat{\\theta}$ 的情况，而两个系数都远在单位圆内（例如，$\\hat{\\phi}=0.4$ 和 $\\hat{\\theta}=0.41$）。在这种情况下，估计出的模型既是平稳的也是可逆的。问题在于参数冗余，而不必然是平稳性或可逆性的问题，尽管如果发生了过度差分，冗余也可能出现在边界附近。“必然”一词使该陈述确定无疑是错误的。\n结论：**不正确**。\n\n**D. $\\hat{\\phi} \\approx \\hat{\\theta}$ 的模式主要表明存在未建模的季节性；您应该在季节性滞后项上添加阶数为 $\\left(1,1\\right)$ 的季节性自回归和移动平均项。**\n这是一种错误的归因。在 Box-Jenkins 框架中，未建模季节性的主要信号是在非季节性模型的残差中，在季节性滞后（例如，对于季度数据，滞后阶数为 $4, 8, 12, \\dots$）上存在显著的自相关。$\\hat{\\phi} \\approx \\hat{\\theta}$ 的模式是 AR 和 MA 多项式之间存在公因子的典型标志，表明存在过度参数化或过度差分。它不是季节性的信号。\n结论：**不正确**。\n\n基于严谨的分析，选项 A 在 Box-Jenkins 框架内为给定的估计结果提供了唯一正确和全面的解释。", "answer": "$$\\boxed{A}$$"}, {"introduction": "本练习将理论知识转化为计算实践，这是现代经济和金融分析的一项核心技能。你将编写代码来计算模型的脉冲响应函数 (IRF)，它揭示了系统对一个冲击随时间的动态反应。这个练习将巩固你对 $ARMA$ 模型如何将抽象的 $(\\phi_i)$ 和 $(\\theta_j)$ 参数转化为具体动态路径的理解 [@problem_id:2372460]。", "id": "2372460", "problem": "给定一个在计算经济学和金融学中用于为回报率、消费增长或其他宏观金融时间序列建模的离散时间自回归移动平均 (ARMA) 过程。对于整数 $p \\ge 0$ 和 $q \\ge 0$，ARMA$(p,q)$ 模型定义为\n$$\ny_t - \\sum_{i=1}^{p} \\phi_i y_{t-i} \\;=\\; \\varepsilon_t + \\sum_{j=1}^{q} \\theta_j \\varepsilon_{t-j},\n$$\n其中 $(\\varepsilon_t)$ 是一个零均值、有限方差的白噪声新息，参数 $(\\phi_1,\\ldots,\\phi_p)$ 和 $(\\theta_1,\\ldots,\\theta_q)$ 是实数，使得自回归多项式的所有根都在单位圆盘之外（平稳性），且移动平均多项式的所有根都在单位圆盘之外（可逆性）。理论脉冲响应函数 (IRF) 由 Wold 表示中的系数 $(\\psi_k)_{k \\ge 0}$ 定义\n$$\ny_t \\;=\\; \\sum_{k=0}^{\\infty} \\psi_k \\,\\varepsilon_{t-k},\n$$\n它描述了 $y_t$ 对时间 $t$ 发生的单位新息响应的时间路径。\n\n编写一个完整、可运行的程序，实现一个函数。该函数在给定 ARMA$(p,q)$ 系数 $(\\phi_1,\\ldots,\\phi_p)$ 和 $(\\theta_1,\\ldots,\\theta_q)$ 以及一个正整数 $N$ 的情况下，返回模型所蕴含的前 $N$ 个理论脉冲响应系数 $(\\psi_0,\\ldots,\\psi_{N-1})$。您的程序必须将此函数应用于以下参数集的测试套件，其中每个参数集都满足所述的平稳性和可逆性条件：\n\n- 测试用例 $1$：$p=1$，$(\\phi_1) = (0.5)$，$q=0$，$(\\theta_1,\\ldots,\\theta_q)=()$，$N=6$。\n- 测试用例 $2$：$p=0$，$(\\phi_1,\\ldots,\\phi_p)=()$，$q=1$，$(\\theta_1)=(0.8)$，$N=6$。\n- 测试用例 $3$：$p=1$，$(\\phi_1)=(0.7)$，$q=1$，$(\\theta_1)=(-0.4)$，$N=6$。\n- 测试用例 $4$：$p=0$，$(\\phi_1,\\ldots,\\phi_p)=()$，$q=0$，$(\\theta_1,\\ldots,\\theta_q)=()$，$N=6$。\n- 测试用例 $5$：$p=2$，$(\\phi_1,\\phi_2)=(1.2,-0.32)$，$q=2$，$(\\theta_1,\\theta_2)=(0.3,-0.2)$，$N=8$。\n- 测试用例 $6$：$p=1$，$(\\phi_1)=(0.99)$，$q=0$，$(\\theta_1,\\ldots,\\theta_q)=()$，$N=6$。\n\n对于每个测试用例，您的程序必须计算给定模型所蕴含的前 $N$ 个理论脉冲响应系数 $(\\psi_0,\\ldots,\\psi_{N-1})$。将每个系数表示为四舍五入到 $6$ 位小数的实数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素本身是针对一个测试用例的 $N$ 个四舍五入后系数的、由方括号括起来的逗号分隔列表，且不含任何空格。例如，输出应如下所示\n$$\n[ [a_{1,0},a_{1,1},\\ldots], [a_{2,0},a_{2,1},\\ldots], \\ldots ]\n$$\n但完全不含空格，并且每个 $a_{i,j}$ 都被替换为相应的四舍五入后的浮点数。具体而言，所需格式恰好是\n$$\n[[\\psi^{(1)}_0,\\ldots,\\psi^{(1)}_{N_1-1}],[\\psi^{(2)}_0,\\ldots,\\psi^{(2)}_{N_2-1}],\\ldots],\n$$\n其中上标表示测试用例的索引。仅作为格式化的明确示例，一个有效的单行输出可能是\n$$\n[[1.000000,0.500000],[1.000000,0.800000,0.000000]],\n$$\n但您的程序必须生成与上述六个指定测试用例相对应的输出，而不是此示例。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取给定信息**\n\nARMA$(p,q)$ 模型定义如下：\n$$\ny_t - \\sum_{i=1}^{p} \\phi_i y_{t-i} \\;=\\; \\varepsilon_t + \\sum_{j=1}^{q} \\theta_j \\varepsilon_{t-j}\n$$\n其中 $(\\varepsilon_t)$ 是一个白噪声过程，$p \\ge 0$，$q \\ge 0$。自回归多项式的根在单位圆盘之外（平稳性），移动平均多项式的根在单位圆盘之外（可逆性）。\n\nWold 表示（或移动平均表示）为：\n$$\ny_t \\;=\\; \\sum_{k=0}^{\\infty} \\psi_k \\,\\varepsilon_{t-k}\n$$\n系数 $(\\psi_k)_{k \\ge 0}$ 构成了脉冲响应函数 (IRF)。\n\n任务是为六个测试用例计算前 $N$ 个 IRF 系数，即 $(\\psi_0, \\ldots, \\psi_{N-1})$。\n\n测试用例：\n1. $p=1$，$(\\phi_1) = (0.5)$，$q=0$，$(\\theta_j)=()$，$N=6$。\n2. $p=0$，$(\\phi_j)=()$，$q=1$，$(\\theta_1)=(0.8)$，$N=6$。\n3. $p=1$，$(\\phi_1)=(0.7)$，$q=1$，$(\\theta_1)=(-0.4)$，$N=6$。\n4. $p=0$，$(\\phi_j)=()$，$q=0$，$(\\theta_j)=()$，$N=6$。\n5. $p=2$，$(\\phi_1,\\phi_2)=(1.2,-0.32)$，$q=2$，$(\\theta_1,\\theta_2)=(0.3,-0.2)$，$N=8$。\n6. $p=1$，$(\\phi_1)=(0.99)$，$q=0$，$(\\theta_j)=()$，$N=6$。\n\n所有测试用例均被声明满足平稳性和可逆性条件。\n\n**步骤2：使用提取的给定信息进行验证**\n\n根据指定标准对问题进行审查。\n- **科学依据**：该问题基于线性时间序列模型的标准理论，特别是 ARMA 过程，这是计量经济学、统计学和计算金融学的基础课题。其定义和关系在文献中是正确且标准的。\n- **适定性**：该问题是适定的。对于一个平稳且可逆的 ARMA 过程，其 Wold 表示的系数 $(\\psi_k)$ 由参数 $(\\phi_i)$ 和 $(\\theta_j)$ 唯一确定。平稳性和可逆性成立的规定至关重要，确保了唯一、稳定解的存在。\n- **客观性**：该问题以精确的数学语言表述。任务是客观的，需要计算明确定义的量。\n- **完整性与一致性**：该问题提供了所有必要信息——模型方程、所有测试用例的参数值，以及所需的 IRF 系数数量 $N$。信息内部一致。\n- **现实性与可行性**：参数值对于经济学和金融学中的应用是现实的。计算任务是基础的，并且完全可行。\n\n**步骤3：结论与行动**\n\n问题有效。它具有科学依据，是适定的，并且信息完整。将提供解决方案。\n\n**求解推导**\n\nARMA$(p,q)$ 模型可以使用滞后算子 $L$ 进行紧凑表示，其中 $L^k z_t = z_{t-k}$。模型方程变为：\n$$\n\\left(1 - \\sum_{i=1}^{p} \\phi_i L^i\\right) y_t \\;=\\; \\left(1 + \\sum_{j=1}^{q} \\theta_j L^j\\right) \\varepsilon_t\n$$\n我们定义自回归多项式 $\\phi(L) = 1 - \\sum_{i=1}^{p} \\phi_i L^i$ 和移动平均多项式 $\\theta(L) = 1 + \\sum_{j=1}^{q} \\theta_j L^j$。于是方程为 $\\phi(L)y_t = \\theta(L)\\varepsilon_t$。\n\nWold 表示为 $y_t = \\psi(L)\\varepsilon_t$，其中 $\\psi(L) = \\sum_{k=0}^{\\infty} \\psi_k L^k$。\n\n通过将 Wold 形式代入 ARMA 模型的滞后算子表示，我们得到：\n$$\n\\phi(L) \\left(\\psi(L) \\varepsilon_t\\right) \\;=\\; \\theta(L) \\varepsilon_t\n$$\n这意味着多项式之间存在一个基本关系：\n$$\n\\phi(L) \\psi(L) \\;=\\; \\theta(L)\n$$\n通过令 $L$ 的同次幂系数相等，这个形式幂级数的等式允许我们确定系数 $\\psi_k$。\n$$\n\\left(1 - \\phi_1 L - \\phi_2 L^2 - \\dots - \\phi_p L^p\\right) \\left(\\psi_0 + \\psi_1 L + \\psi_2 L^2 + \\dots\\right) \\;=\\; 1 + \\theta_1 L + \\theta_2 L^2 + \\dots + \\theta_q L^q\n$$\n为了找到系数 $\\psi_k$，我们展开左侧并令 $L^k$ 的系数在 $k = 0, 1, 2, \\dots$ 时相等。\n\n对于 $k=0$（常数项，$L^0$ 的系数）：\n左侧对常数项的唯一贡献是 $1 \\cdot \\psi_0$。右侧是 $1$。\n$$\n\\psi_0 \\;=\\; 1\n$$\n对于 $k > 0$，左侧 $L^k$ 的系数是 $\\psi_k - \\sum_{i=1}^{p} \\phi_i \\psi_{k-i}$。右侧 $L^k$ 的系数是 $\\theta_k$，我们定义当 $k>q$ 时 $\\theta_k=0$。\n$$\n\\psi_k - \\sum_{i=1}^{p} \\phi_i \\psi_{k-i} \\;=\\; \\theta_k\n$$\n整理后得到 $\\psi_k$ 的递归公式：\n$$\n\\psi_k \\;=\\; \\sum_{i=1}^{p} \\phi_i \\psi_{k-i} + \\theta_k\n$$\n该递推关系对 $k \\ge 1$ 成立。为了实现，精确定义求和的界限和 $\\theta_k$ 的定义是很有用的。设 $(\\phi_1, \\dots, \\phi_p)$ 和 $(\\theta_1, \\dots, \\theta_q)$ 是给定的系数向量。\n\n计算 $(\\psi_0, \\ldots, \\psi_{N-1})$ 的算法如下：\n1.  初始化一个长度为 $N$ 的数组 `psi`。\n2.  设置初始值：$\\psi_0 = 1$。\n3.  对 $k$ 从 $1$ 到 $N-1$ 进行迭代：\n    a. 计算自回归部分：$\\text{AR\\_part} = \\sum_{i=1}^{\\min(k, p)} \\phi_i \\psi_{k-i}$。这个和是基于已计算出的 $\\psi$ 值。\n    b. 确定移动平均部分：如果 $1 \\le k \\le q$，则 $\\text{MA\\_part} = \\theta_k$，否则为 $0$。\n    c. 计算 $\\psi_k = \\text{AR\\_part} + \\text{MA\\_part}$。\n\n对每个测试用例实施此递归过程，以推导出所需的 IRF 序列。最终数值按要求四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_irf(phi, theta, N):\n    \"\"\"\n    Computes the first N coefficients of the Impulse Response Function (IRF)\n    for a given ARMA(p,q) model.\n\n    The IRF psi_k is computed using the recurrence relation:\n    psi_k = sum_{i=1 to p} phi_i * psi_{k-i} + theta_k\n    with psi_0 = 1 and theta_k = 0 for k > q.\n\n    Args:\n        phi (tuple): A tuple of p autoregressive coefficients (phi_1, ..., phi_p).\n        theta (tuple): A tuple of q moving average coefficients (theta_1, ..., theta_q).\n        N (int): The number of IRF coefficients to compute (psi_0, ..., psi_{N-1}).\n\n    Returns:\n        numpy.ndarray: An array of the first N IRF coefficients.\n    \"\"\"\n    p = len(phi)\n    q = len(theta)\n    \n    # Initialize psi array of length N\n    psi = np.zeros(N)\n    \n    # Base case: psi_0 = 1\n    if N > 0:\n        psi[0] = 1.0\n\n    # Recursively compute psi_k for k = 1, ..., N-1\n    for k in range(1, N):\n        # Autoregressive part\n        ar_part = 0.0\n        # Sum_{i=1 to p} phi_i * psi_{k-i}\n        for i in range(1, p + 1):\n            if k - i >= 0:\n                ar_part += phi[i - 1] * psi[k - i]\n        \n        # Moving average part\n        ma_part = 0.0\n        if k <= q:\n            ma_part = theta[k - 1]\n            \n        psi[k] = ar_part + ma_part\n        \n    return psi\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the IRF for each test case\n    and printing the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (phi_coeffs, theta_coeffs, N)\n        ((0.5,), (), 6),\n        ((), (0.8,), 6),\n        ((0.7,), (-0.4,), 6),\n        ((), (), 6),\n        ((1.2, -0.32), (0.3, -0.2), 8),\n        ((0.99,), (), 6),\n    ]\n\n    all_results_str = []\n    for phi_case, theta_case, n_case in test_cases:\n        # Compute the IRF coefficients for the current case.\n        psi_coeffs = compute_irf(phi_case, theta_case, n_case)\n        \n        # Round each coefficient to 6 decimal places.\n        rounded_psi = np.round(psi_coeffs, 6)\n        \n        # Format the rounded coefficients into strings with 6 decimal places.\n        formatted_psi = [f\"{x:.6f}\" for x in rounded_psi]\n        \n        # Create the string for the current case, e.g., \"[1.000000,0.500000]\"\n        case_str = f\"[{','.join(formatted_psi)}]\"\n        all_results_str.append(case_str)\n\n    # Combine all case strings into the final output format, e.g., \"[[...],[...]]\"\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"}]}