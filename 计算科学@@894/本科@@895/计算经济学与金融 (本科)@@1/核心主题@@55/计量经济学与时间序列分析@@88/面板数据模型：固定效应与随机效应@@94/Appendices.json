{"hands_on_practices": [{"introduction": "真正掌握固定效应模型的第一步是理解其估计量是如何从数据中计算出来的。这个练习 [@problem_id:2417550] 将带你剥离统计软件的封装，通过手动计算（或编写简单代码）来获得“组内”（within）估计量。这个过程将清晰地揭示固定效应模型如何通过仅利用每个实体内部随时间变化的信息，来控制那些不随时间变化的个体特征，例如公司的创新文化或个人的内在能力。", "id": "2417550", "problem": "您将获得三个独立的、在多年中观察到的公司面板数据集。对于每个数据集，请考虑具有公司特定截距项的线性面板模型：\n$$\ny_{it} = \\alpha_i + \\beta x_{it} + u_{it},\n$$\n其中，$y_{it}$ 是公司 $i$ 在年份 $t$ 的专利申请数量（一个非负整数），$x_{it}$ 是公司 $i$ 在年份 $t$ 的研发（R&amp;D）支出，以百万货币单位计量（一个非负实数），$\\alpha_i$ 是一个公司特定的截距项，捕捉了公司的基线创新文化，而 $u_{it}$ 是一个均值为零且方差有限的特异性误差项。假设对于每个公司 $i$，严格外生性条件成立：对于所有 $t$，$\\mathbb{E}[u_{it} \\mid \\{x_{is}\\}_s, \\{\\alpha_j\\}_j] = 0$。\n\n对于下方的每个数据集，请使用公司固定效应（即，允许每个公司有不受限制的 $\\alpha_i$，但所有公司共享一个共同的 $\\beta$）在该模型下估计斜率系数 $\\beta$。请使用为每个数据集提供的所有观测值。如果一个公司的 $x_{it}$ 没有公司内部变动，则该公司对 $\\beta$ 的识别没有贡献。\n\n数据集 A（平衡面板，包含 3 个公司，每个公司 3 年的数据），以四元组 $(i,t,y_{it},x_{it})$ 的形式提供：\n- $(1,1,4,4)$, $(1,2,5,6)$, $(1,3,6,8)$\n- $(2,1,2,2)$, $(2,2,6,10)$, $(2,3,4,6)$\n- $(3,1,3,0)$, $(3,2,5,4)$, $(3,3,7,8)$\n\n数据集 B（平衡面板，包含 3 个公司，每个公司 3 年的数据；一个公司的 $x_{it}$ 随时间保持不变）：\n- $(1,1,3,4)$, $(1,2,3,4)$, $(1,3,3,4)$\n- $(2,1,1,2)$, $(2,2,3,6)$, $(2,3,5,10)$\n- $(3,1,2,0)$, $(3,2,4,4)$, $(3,3,6,8)$\n\n数据集 C（非平衡面板：公司 1 有 4 年数据，公司 2 有 3 年数据，公司 3 有 3 年数据）：\n- $(1,1,6,8)$, $(1,2,6,8)$, $(1,3,7,10)$, $(1,4,7,10)$\n- $(2,1,4,6)$, $(2,2,4,6)$, $(2,3,4,6)$\n- $(3,1,3,0)$, $(3,2,4,2)$, $(3,3,5,4)$\n\n测试套件和答案规格：\n- 计算每个数据集的公司固定效应估计值 $\\beta$，记为 $\\hat{\\beta}_A$、$\\hat{\\beta}_B$ 和 $\\hat{\\beta}_C$。\n- 将每个估计值四舍五入到 6 位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序为 $[\\hat{\\beta}_A,\\hat{\\beta}_B,\\hat{\\beta}_C]$。", "solution": "问题陈述被解析并经过严格验证。\n\n步骤 1：提取已知条件\n问题提供了以下信息：\n- 一个线性面板模型：$y_{it} = \\alpha_i + \\beta x_{it} + u_{it}$。\n- 变量定义：$y_{it}$ 是专利申请数量（非负整数），$x_{it}$ 是研发支出（非负实数），$\\alpha_i$ 是公司特定截距项，而 $u_{it}$ 是特异性误差。\n- 假设：严格外生性条件成立，对于所有 $t$，$\\mathbb{E}[u_{it} \\mid \\{x_{is}\\}_s, \\{\\alpha_j\\}_j] = 0$。\n- 任务是使用公司固定效应模型为三个不同的数据集估计共同的斜率系数 $\\beta$。\n- 数据集 A（平衡面板, $N=3$, $T=3$）：$(1,1,4,4)$, $(1,2,5,6)$, $(1,3,6,8)$; $(2,1,2,2)$, $(2,2,6,10)$, $(2,3,4,6)$; $(3,1,3,0)$, $(3,2,5,4)$, $(3,3,7,8)$。\n- 数据集 B（平衡面板, $N=3$, $T=3$）：$(1,1,3,4)$, $(1,2,3,4)$, $(1,3,3,4)$; $(2,1,1,2)$, $(2,2,3,6)$, $(2,3,5,10)$; $(3,1,2,0)$, $(3,2,4,4)$, $(3,3,6,8)$。\n- 数据集 C（非平衡面板, $N=3$, $T_1=4, T_2=3, T_3=3$）：$(1,1,6,8)$, $(1,2,6,8)$, $(1,3,7,10)$, $(1,4,7,10)$; $(2,1,4,6)$, $(2,2,4,6)$, $(2,3,4,6)$; $(3,1,3,0)$, $(3,2,4,2)$, $(3,3,5,4)$。\n- 需要注意的是，如果一个公司的 $x_{it}$ 没有公司内部变动，则该公司对 $\\beta$ 的识别没有贡献。\n\n步骤 2：验证\n- **科学依据**：问题指定了一个标准的固定效应面板数据模型，这是计量经济学分析的基石。所选变量，研发支出和专利申请，是创新经济学中使用的经典指标。陈述的假设对于此类模型是标准的。该问题是合理的。\n- **适定性**：问题要求在给定完整数据集的情况下，计算一个定义明确的统计估计量（固定效应的“组内”估计量）。该估计量的公式提供了一个唯一的解。该问题是适定的。\n- **客观性**：问题使用精确的数学语言表述，并提供了明确的数值数据。它没有歧义或主观论断。该问题是客观的。\n\n步骤 3：结论\n该问题有效。这是一个定义明确的计算计量经济学练习。将提供完整的解决方案。\n\n**解题推导**\n\n模型由以下公式给出：\n$$ y_{it} = \\alpha_i + \\beta x_{it} + u_{it} $$\n其中 $i = 1, \\dots, N$ 为公司索引，$t = 1, \\dots, T_i$ 为时间索引。$\\alpha_i$ 项代表不可观测的、不随时间变化的公司特定效应。固定效应估计量通过对每个公司内部的数据进行去均值处理来消除 $\\alpha_i$。\n\n首先，我们对每个公司 $i$ 的方程求时间平均值：\n$$ \\frac{1}{T_i} \\sum_{t=1}^{T_i} y_{it} = \\frac{1}{T_i} \\sum_{t=1}^{T_i} (\\alpha_i + \\beta x_{it} + u_{it}) $$\n令 $\\bar{y}_i = \\frac{1}{T_i} \\sum_{t=1}^{T_i} y_{it}$，$\\bar{x}_i = \\frac{1}{T_i} \\sum_{t=1}^{T_i} x_{it}$，以及 $\\bar{u}_i = \\frac{1}{T_i} \\sum_{t=1}^{T_i} u_{it}$。平均后的方程为：\n$$ \\bar{y}_i = \\alpha_i + \\beta \\bar{x}_i + \\bar{u}_i $$\n将此式从每个观测值 $(i, t)$ 的原始方程中减去，得到组内转换（或去均值）模型：\n$$ (y_{it} - \\bar{y}_i) = \\beta (x_{it} - \\bar{x}_i) + (u_{it} - \\bar{u}_i) $$\n令 $\\ddot{y}_{it} = y_{it} - \\bar{y}_i$ 及 $\\ddot{x}_{it} = x_{it} - \\bar{x}_i$。方程变为：\n$$ \\ddot{y}_{it} = \\beta \\ddot{x}_{it} + \\ddot{u}_{it} $$\n系数 $\\beta$ 通过对此转换后的模型应用普通最小二乘法（OLS）来估计。$\\beta$ 的 OLS 估计量，记作 $\\hat{\\beta}_{FE}$，由下式给出：\n$$ \\hat{\\beta}_{FE} = \\frac{\\sum_{i=1}^{N} \\sum_{t=1}^{T_i} \\ddot{x}_{it} \\ddot{y}_{it}}{\\sum_{i=1}^{N} \\sum_{t=1}^{T_i} \\ddot{x}_{it}^2} $$\n如果对于某个公司 $i$，$x_{it}$ 随时间保持不变，那么对于所有 $t$ 都有 $x_{it} = \\bar{x}_i$，这意味着 $\\ddot{x}_{it} = 0$。这样的公司对分子和分母的贡献都为 0，因此对 $\\beta$ 的估计没有影响。\n\n**数据集 A 的计算**\n\n- **公司 1**：数据 $(y,x)$: $(4,4), (5,6), (6,8)$。$T_1=3$。\n  - 均值: $\\bar{y}_1 = (4+5+6)/3 = 5$, $\\bar{x}_1 = (4+6+8)/3 = 6$。\n  - 去均值后数据 $(\\ddot{y}_{1t}, \\ddot{x}_{1t})$: $(-1,-2), (0,0), (1,2)$。\n  - $\\sum_t \\ddot{x}_{1t} \\ddot{y}_{1t} = (-1)(-2) + (0)(0) + (1)(2) = 4$。\n  - $\\sum_t \\ddot{x}_{1t}^2 = (-2)^2 + (0)^2 + (2)^2 = 8$。\n- **公司 2**：数据 $(y,x)$: $(2,2), (6,10), (4,6)$。$T_2=3$。\n  - 均值: $\\bar{y}_2 = (2+6+4)/3 = 4$, $\\bar{x}_2 = (2+10+6)/3 = 6$。\n  - 去均值后数据 $(\\ddot{y}_{2t}, \\ddot{x}_{2t})$: $(-2,-4), (2,4), (0,0)$。\n  - $\\sum_t \\ddot{x}_{2t} \\ddot{y}_{2t} = (-2)(-4) + (2)(4) + (0)(0) = 16$。\n  - $\\sum_t \\ddot{x}_{2t}^2 = (-4)^2 + (4)^2 + (0)^2 = 32$。\n- **公司 3**：数据 $(y,x)$: $(3,0), (5,4), (7,8)$。$T_3=3$。\n  - 均值: $\\bar{y}_3 = (3+5+7)/3 = 5$, $\\bar{x}_3 = (0+4+8)/3 = 4$。\n  - 去均值后数据 $(\\ddot{y}_{3t}, \\ddot{x}_{3t})$: $(-2,-4), (0,0), (2,4)$。\n  - $\\sum_t \\ddot{x}_{3t} \\ddot{y}_{3t} = (-2)(-4) + (0)(0) + (2)(4) = 16$。\n  - $\\sum_t \\ddot{x}_{3t}^2 = (-4)^2 + (0)^2 + (4)^2 = 32$。\n- **$\\hat{\\beta}_A$ 的估计值**：\n  $$ \\hat{\\beta}_A = \\frac{4 + 16 + 16}{8 + 32 + 32} = \\frac{36}{72} = 0.5 $$\n\n**数据集 B 的计算**\n\n- **公司 1**：数据 $(y,x)$: $(3,4), (3,4), (3,4)$。\n  - $x_{1t}$ 是常数。该公司对估计没有贡献。$\\sum_t \\ddot{x}_{1t} \\ddot{y}_{1t} = 0$, $\\sum_t \\ddot{x}_{1t}^2 = 0$。\n- **公司 2**：数据 $(y,x)$: $(1,2), (3,6), (5,10)$。$T_2=3$。\n  - 均值: $\\bar{y}_2 = (1+3+5)/3 = 3$, $\\bar{x}_2 = (2+6+10)/3 = 6$。\n  - 去均值后数据 $(\\ddot{y}_{2t}, \\ddot{x}_{2t})$: $(-2,-4), (0,0), (2,4)$。\n  - $\\sum_t \\ddot{x}_{2t} \\ddot{y}_{2t} = (-2)(-4) + (0)(0) + (2)(4) = 16$。\n  - $\\sum_t \\ddot{x}_{2t}^2 = (-4)^2 + (0)^2 + (4)^2 = 32$。\n- **公司 3**：数据 $(y,x)$: $(2,0), (4,4), (6,8)$。$T_3=3$。\n  - 均值: $\\bar{y}_3 = (2+4+6)/3 = 4$, $\\bar{x}_3 = (0+4+8)/3 = 4$。\n  - 去均值后数据 $(\\ddot{y}_{3t}, \\ddot{x}_{3t})$: $(-2,-4), (0,0), (2,4)$。\n  - $\\sum_t \\ddot{x}_{3t} \\ddot{y}_{3t} = (-2)(-4) + (0)(0) + (2)(4) = 16$。\n  - $\\sum_t \\ddot{x}_{3t}^2 = (-4)^2 + (0)^2 + (4)^2 = 32$。\n- **$\\hat{\\beta}_B$ 的估计值**：\n  $$ \\hat{\\beta}_B = \\frac{0 + 16 + 16}{0 + 32 + 32} = \\frac{32}{64} = 0.5 $$\n\n**数据集 C 的计算**\n\n- **公司 1**：数据 $(y,x)$: $(6,8), (6,8), (7,10), (7,10)$。$T_1=4$。\n  - 均值: $\\bar{y}_1 = (6+6+7+7)/4 = 6.5$, $\\bar{x}_1 = (8+8+10+10)/4 = 9$。\n  - 去均值后数据 $(\\ddot{y}_{1t}, \\ddot{x}_{1t})$: $(-0.5,-1), (-0.5,-1), (0.5,1), (0.5,1)$。\n  - $\\sum_t \\ddot{x}_{1t} \\ddot{y}_{1t} = 2 \\times (-0.5)(-1) + 2 \\times (0.5)(1) = 1 + 1 = 2$。\n  - $\\sum_t \\ddot{x}_{1t}^2 = 2 \\times (-1)^2 + 2 \\times (1)^2 = 2 + 2 = 4$。\n- **公司 2**：数据 $(y,x)$: $(4,6), (4,6), (4,6)$。\n  - $x_{2t}$ 是常数。该公司没有贡献。$\\sum_t \\ddot{x}_{2t} \\ddot{y}_{2t} = 0$, $\\sum_t \\ddot{x}_{2t}^2 = 0$。\n- **公司 3**：数据 $(y,x)$: $(3,0), (4,2), (5,4)$。$T_3=3$。\n  - 均值: $\\bar{y}_3 = (3+4+5)/3 = 4$, $\\bar{x}_3 = (0+2+4)/3 = 2$。\n  - 去均值后数据 $(\\ddot{y}_{3t}, \\ddot{x}_{3t})$: $(-1,-2), (0,0), (1,2)$。\n  - $\\sum_t \\ddot{x}_{3t} \\ddot{y}_{3t} = (-1)(-2) + (0)(0) + (1)(2) = 4$。\n  - $\\sum_t \\ddot{x}_{3t}^2 = (-2)^2 + (0)^2 + (2)^2 = 8$。\n- **$\\hat{\\beta}_C$ 的估计值**：\n  $$ \\hat{\\beta}_C = \\frac{2 + 0 + 4}{4 + 0 + 8} = \\frac{6}{12} = 0.5 $$\n\n估计值为 $\\hat{\\beta}_A = 0.5$, $\\hat{\\beta}_B = 0.5$ 以及 $\\hat{\\beta}_C = 0.5$。按要求四舍五入到 6 位小数后，这些值为 $0.500000$、$0.500000$ 和 $0.500000$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fixed effects estimate of beta for three panel datasets.\n    \"\"\"\n\n    # Define the datasets from the problem statement.\n    # Each dataset is a list of tuples (i, t, y_it, x_it).\n    datasets = {\n        'A': [\n            (1, 1, 4, 4), (1, 2, 5, 6), (1, 3, 6, 8),\n            (2, 1, 2, 2), (2, 2, 6, 10), (2, 3, 4, 6),\n            (3, 1, 3, 0), (3, 2, 5, 4), (3, 3, 7, 8)\n        ],\n        'B': [\n            (1, 1, 3, 4), (1, 2, 3, 4), (1, 3, 3, 4),\n            (2, 1, 1, 2), (2, 2, 3, 6), (2, 3, 5, 10),\n            (3, 1, 2, 0), (3, 2, 4, 4), (3, 3, 6, 8)\n        ],\n        'C': [\n            (1, 1, 6, 8), (1, 2, 6, 8), (1, 3, 7, 10), (1, 4, 7, 10),\n            (2, 1, 4, 6), (2, 2, 4, 6), (2, 3, 4, 6),\n            (3, 1, 3, 0), (3, 2, 4, 2), (3, 3, 5, 4)\n        ]\n    }\n\n    results = []\n\n    def calculate_fixed_effects_beta(data):\n        \"\"\"\n        Calculates the FE estimator for a single dataset.\n        The estimator is the ratio of the sum of within-firm cross-products\n        to the sum of within-firm squares of the regressor.\n        \"\"\"\n        # Group data by firm ID\n        firms_data = {}\n        for i, t, y, x in data:\n            if i not in firms_data:\n                firms_data[i] = {'y': [], 'x': []}\n            firms_data[i]['y'].append(y)\n            firms_data[i]['x'].append(x)\n        \n        total_numerator = 0.0\n        total_denominator = 0.0\n\n        for firm_id in firms_data:\n            y_i = np.array(firms_data[firm_id]['y'], dtype=np.float64)\n            x_i = np.array(firms_data[firm_id]['x'], dtype=np.float64)\n            \n            # A firm contributes to identification only if there is within-firm\n            # variation in the regressor x.\n            # np.ptp(x_i) checks for peak-to-peak (max - min) difference.\n            if np.ptp(x_i) == 0:\n                continue\n            \n            # Calculate means\n            mean_y_i = np.mean(y_i)\n            mean_x_i = np.mean(x_i)\n            \n            # Demean the data (within-transformation)\n            y_ddot_i = y_i - mean_y_i\n            x_ddot_i = x_i - mean_x_i\n            \n            # Add this firm's contribution to the total sums\n            total_numerator += np.sum(x_ddot_i * y_ddot_i)\n            total_denominator += np.sum(x_ddot_i**2)\n            \n        # Calculate the final beta estimate\n        if total_denominator == 0:\n            # This case should not be reached with the given valid problems.\n            # If it did, beta would be unidentified.\n            beta_hat = 0.0\n        else:\n            beta_hat = total_numerator / total_denominator\n            \n        return beta_hat\n\n    # Process each dataset in the specified order: A, B, C\n    for key in sorted(datasets.keys()):\n        beta_estimate = calculate_fixed_effects_beta(datasets[key])\n        results.append(beta_estimate)\n\n    # Format the results to 6 decimal places as strings.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Print the final output in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "在实证研究中，选择使用固定效应（FE）还是随机效应（RE）模型是一个核心决策。这个练习 [@problem_id:2417587] 将引导你走完一个完整的分析流程：分别估计 FE 和 RE 模型，然后运用 Hausman 检验在两者之间做出有依据的选择。这项实践模拟了经验研究者在分析面板数据时的真实工作流程，从估计模型的参数到进行模型设定检验。", "id": "2417587", "problem": "考虑一个计算经济学和金融学中用于医院产出的平衡面板数据模型。设有 $N$ 家医院，索引为 $i \\in \\{1,\\dots,N\\}$，$T$ 个时期，索引为 $t \\in \\{1,\\dots,T\\}$。结构模型为\n$$\ny_{it} = \\alpha_i + \\beta x_{it} + u_{it},\n$$\n其中 $y_{it}$ 是医院 $i$ 在时间 $t$ 的标量产出（例如，风险调整后的不良事件率），$x_{it}$ 是一个标量回归量（例如，护士-患者比），$\\alpha_i$ 是医院特定的不随时间变化的效应，$\\beta$ 是一个共同的斜率参数，$u_{it}$ 是一个特异性扰动项，对于所有的 $s,t$ 满足 $\\mathbb{E}[u_{it} \\mid x_{is}, \\alpha_i] = 0$。假设该面板是平衡的，并且在随机效应框架下，以下标准分解成立：$u_{it} = \\eta_i + \\varepsilon_{it}$，其中 $\\eta_i \\sim \\text{i.i.d.}$ 且 $\\varepsilon_{it} \\sim \\text{i.i.d.}$，它们相互独立，各自具有零均值和有限方差，并且在随机效应假设成立的情况下，与 $x_{it}$ 独立。\n\n从基本原理出发：\n- 固定效应（组内）估计量利用了通过在每个医院内去均值来消除 $\\alpha_i$ 的变换。定义医院内均值 $\\bar{y}_i = \\frac{1}{T}\\sum_{t=1}^T y_{it}$ 和 $\\bar{x}_i = \\frac{1}{T}\\sum_{t=1}^T x_{it}$。组内变换后的变量为 $\\tilde{y}_{it} = y_{it} - \\bar{y}_i$ 和 $\\tilde{x}_{it} = x_{it} - \\bar{x}_i$。固定效应斜率估计量是通过对变换后的无截距项模型进行普通最小二乘法得到的：\n$$\n\\hat{\\beta}_{FE} = \\frac{\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{x}_{it}\\tilde{y}_{it}}{\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{x}_{it}^{2}}.\n$$\n- 在随机效应假设下，广义最小二乘法得到一个准去均值变换。令 $\\theta = 1 - \\sqrt{\\frac{\\sigma_{\\varepsilon}^{2}}{\\sigma_{\\varepsilon}^{2} + T \\sigma_{\\eta}^{2}}}$，其中 $\\sigma_{\\eta}^{2}$ 和 $\\sigma_{\\varepsilon}^{2}$ 是 $\\eta_i$ 和 $\\varepsilon_{it}$ 的方差分量。变换后的变量为 $y_{it}^{\\ast} = y_{it} - \\theta \\bar{y}_{i}$ 和 $x_{it}^{\\ast} = x_{it} - \\theta \\bar{x}_{i}$。随机效应估计量 $\\hat{\\beta}_{RE}$ 是在 $y_{it}^{\\ast}$ 对一个常数项和 $x_{it}^{\\ast}$ 的回归中 $x_{it}^{\\ast}$ 的普通最小二乘系数。方差分量可以通过经过充分检验的恒等式 $\\operatorname{Var}(\\bar{v}_{i}) \\approx \\sigma_{\\eta}^{2} + \\sigma_{\\varepsilon}^{2}/T$ 和 $\\operatorname{Var}(v_{it} - \\bar{v}_{i}) \\approx \\sigma_{\\varepsilon}^{2}$，从混合普通最小二乘法残差 $v_{it}$ 中估计得到，其中 $\\bar{v}_{i}$ 是医院 $i$ 内 $v_{it}$ 的均值。\n- 为了评估固定效应框架和随机效应框架哪个更合适，使用基于估计量差异的 Hausman 检验。对于标量斜率，检验统计量为\n$$\nH = \\frac{(\\hat{\\beta}_{FE} - \\hat{\\beta}_{RE})^{2}}{\\operatorname{Var}(\\hat{\\beta}_{FE}) - \\operatorname{Var}(\\hat{\\beta}_{RE})},\n$$\n仅当分母为正时进行解释；在随机效应假设成立的原假设下，$H$ 渐近服从自由度为 $1$ 的卡方分布。\n\n您的任务是编写一个完整的、可运行的程序，对于下面测试套件中的每个数据集，计算：\n1. 固定效应估计量 $\\hat{\\beta}_{FE}$。\n2. 随机效应估计量 $\\hat{\\beta}_{RE}$，使用准去均值方法，其方差分量根据上述描述从混合普通最小二乘法残差中估计。\n3. Hausman 统计量 $H$ 以及一个布尔值，该值指示 $H$ 是否超过自由度为 $1$ 的卡方分布的 $5\\%$ 临界值，约为 $3.841458820694124$。\n\n需要遵守的实现细节：\n- 对于固定效应方差，使用 $\\widehat{\\sigma}_{\\varepsilon,FE}^{2} = \\frac{\\sum_{i=1}^{N}\\sum_{t=1}^{T} (\\tilde{y}_{it} - \\hat{\\beta}_{FE}\\tilde{x}_{it})^{2}}{N(T-1) - 1}$ 和 $\\operatorname{Var}(\\hat{\\beta}_{FE}) = \\widehat{\\sigma}_{\\varepsilon,FE}^{2} \\Big/\\sum_{i=1}^{N}\\sum_{t=1}^{T}\\tilde{x}_{it}^{2}$。\n- 对于混合普通最小二乘法，使用所有 $NT$ 个观测值将 $y_{it}$ 对一个常数项和 $x_{it}$ 进行回归；令 $v_{it}$ 为残差，$\\bar{v}_i = \\frac{1}{T}\\sum_{t=1}^{T} v_{it}$。通过 $\\widehat{\\sigma}_{\\varepsilon}^{2} = \\frac{1}{N(T-1)}\\sum_{i=1}^{N}\\sum_{t=1}^{T} (v_{it} - \\bar{v}_i)^{2}$ 估计 $\\sigma_{\\varepsilon}^{2}$，然后通过 $\\widehat{\\sigma}_{\\eta}^{2} = \\max\\left\\{0, \\widehat{\\operatorname{Var}}(\\bar{v}_i) - \\widehat{\\sigma}_{\\varepsilon}^{2}/T \\right\\}$ 估计 $\\sigma_{\\eta}^{2}$，其中 $\\widehat{\\operatorname{Var}}(\\bar{v}_i)$ 是使用分母 $N-1$ 计算的 $\\bar{v}_i$ 的样本方差。然后计算 $\\hat{\\theta} = 1 - \\sqrt{\\frac{\\widehat{\\sigma}_{\\varepsilon}^{2}}{\\widehat{\\sigma}_{\\varepsilon}^{2} + T \\widehat{\\sigma}_{\\eta}^{2}}}$，并构建 $y_{it}^{\\ast}$ 和 $x_{it}^{\\ast}$ 来估计 $\\hat{\\beta}_{RE}$。对于随机效应方差，在变换后的回归上使用带常数项的普通最小二乘法公式：$\\widehat{\\operatorname{Var}}(\\hat{\\beta}_{RE})$ 是 $\\widehat{\\sigma}_{RE}^{2} (X^{\\ast\\prime}X^{\\ast})^{-1}$ 的 $(2,2)$ 元素，其中 $\\widehat{\\sigma}_{RE}^{2}$ 是使用分母 $NT-2$ 的残差方差。\n- 对于 Hausman 检验，如果 $\\operatorname{Var}(\\hat{\\beta}_{FE}) - \\operatorname{Var}(\\hat{\\beta}_{RE}) \\le 0$，则设 $H = 0$ 且布尔值为 false。\n\n测试套件（平衡面板）：\n- 案例 A：$N = 4$，$T = 3$，\n$x = \\begin{bmatrix}\n3.0 & 3.5 & 4.0 \\\\\n2.0 & 2.5 & 3.0 \\\\\n1.0 & 1.0 & 1.5 \\\\\n4.0 & 3.5 & 3.0\n\\end{bmatrix}$，\n$y = \\begin{bmatrix}\n3.9 & 3.6 & 3.35 \\\\\n6.2 & 6.05 & 5.9 \\\\\n8.55 & 8.65 & 8.4 \\\\\n4.5 & 4.6 & 4.75\n\\end{bmatrix}$。\n- 案例 B：$N = 3$，$T = 2$，\n$x = \\begin{bmatrix}\n1.0 & 1.4 \\\\\n2.0 & 2.2 \\\\\n0.5 & 0.7\n\\end{bmatrix}$，\n$y = \\begin{bmatrix}\n5.7 & 5.6 \\\\\n7.35 & 7.35 \\\\\n6.85 & 6.78\n\\end{bmatrix}$。\n- 案例 C：$N = 3$，$T = 3$，\n$x = \\begin{bmatrix}\n1.0 & 1.05 & 0.95 \\\\\n2.0 & 1.95 & 2.05 \\\\\n1.5 & 1.55 & 1.45\n\\end{bmatrix}$，\n$y = \\begin{bmatrix}\n3.01 & 2.94 & 3.05 \\\\\n4.02 & 4.04 & 3.96 \\\\\n3.51 & 3.44 & 3.54\n\\end{bmatrix}$。\n\n程序输出规范：\n- 对于每个案例，计算四元组 $\\left[\\hat{\\beta}_{FE}, \\hat{\\beta}_{RE}, H, \\text{preferFE}\\right]$，其中 $\\text{preferFE}$ 是一个布尔值，如果 $H > 3.841458820694124$ 则为 true，否则为 false。\n- 将所有案例按 A、B、C 的顺序聚合到一个扁平列表中。您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，例如 $[\\hat{\\beta}_{FE,A}, \\hat{\\beta}_{RE,A}, H_A, \\text{preferFE}_A, \\hat{\\beta}_{FE,B}, \\dots]$。不应打印任何其他文本。", "solution": "问题陈述已经过严谨评估，被认定为有效。它在计算计量经济学领域提出了一个清晰、独立且具有科学依据的任务。所提供的定义、公式和数据都是适定的，并与面板数据分析的既定原则相一致。目标是实现并应用固定效应（FE）和随机效应（RE）估计量，然后通过 Hausman 检验对它们进行比较。此过程将严格按照规定执行。\n\n对于每个给定的数据集，计算过程分为三个主要阶段。所有数学实体都按要求使用 LaTeX 表示。\n\n首先，计算固定效应估计量，记为 $\\hat{\\beta}_{FE}$。该估计量依赖于组内变换，这种变换消除了不随时间变化的特定效应 $\\alpha_i$。对于每个实体 $i$，观测值 $z_{it}$ 的时间均值为 $\\bar{z}_i = \\frac{1}{T}\\sum_{t=1}^T z_{it}$。组内变换产生去均值后的变量 $\\tilde{y}_{it} = y_{it} - \\bar{y}_i$ 和 $\\tilde{x}_{it} = x_{it} - \\bar{x}_i$。FE 估计量是对变换后数据进行普通最小二乘（OLS）回归的结果：\n$$\n\\hat{\\beta}_{FE} = \\frac{\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{x}_{it}\\tilde{y}_{it}}{\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{x}_{it}^{2}}\n$$\n该估计量的方差 $\\operatorname{Var}(\\hat{\\beta}_{FE})$ 使用指定公式计算，该公式依赖于从 FE 回归残差中估计的特异性误差项的方差。残差由 $\\tilde{u}_{it} = \\tilde{y}_{it} - \\hat{\\beta}_{FE}\\tilde{x}_{it}$ 给出。误差项的方差估计为 $\\widehat{\\sigma}_{\\varepsilon,FE}^{2} = \\frac{1}{N(T-1) - 1}\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{u}_{it}^{2}$。于是估计量的方差为：\n$$\n\\operatorname{Var}(\\hat{\\beta}_{FE}) = \\frac{\\widehat{\\sigma}_{\\varepsilon,FE}^{2}}{\\sum_{i=1}^{N}\\sum_{t=1}^{T}\\tilde{x}_{it}^{2}}\n$$\n\n其次，计算随机效应估计量 $\\hat{\\beta}_{RE}$。这是一种广义最小二乘（GLS）的形式，它考虑了由随机效应 $\\eta_i$ 引起的每个实体 $i$ 内部的序列相关性。该过程包括两个步骤。首先，必须估计方差分量 $\\sigma_{\\varepsilon}^{2}$ 和 $\\sigma_{\\eta}^{2}$。这是通过使用将 $y_{it}$ 对一个常数项和 $x_{it}$ 进行混合 OLS 回归得到的残差 $v_{it}$ 来完成的。估计量为：\n$$\n\\widehat{\\sigma}_{\\varepsilon}^{2} = \\frac{1}{N(T-1)}\\sum_{i=1}^{N}\\sum_{t=1}^{T} (v_{it} - \\bar{v}_i)^{2}\n$$\n$$\n\\widehat{\\sigma}_{\\eta}^{2} = \\max\\left\\{0, \\widehat{\\operatorname{Var}}(\\bar{v}_i) - \\frac{\\widehat{\\sigma}_{\\varepsilon}^{2}}{T} \\right\\}\n$$\n其中 $\\bar{v}_i$ 是实体 $i$ 的平均残差，$\\widehat{\\operatorname{Var}}(\\bar{v}_i)$ 是其在实体间的样本方差，计算时分母为 $N-1$。利用这些方差分量，计算准去均值参数 $\\hat{\\theta}$：\n$$\n\\hat{\\theta} = 1 - \\sqrt{\\frac{\\widehat{\\sigma}_{\\varepsilon}^{2}}{\\widehat{\\sigma}_{\\varepsilon}^{2} + T \\widehat{\\sigma}_{\\eta}^{2}}}\n$$\n然后数据被变换为 $y_{it}^{\\ast} = y_{it} - \\hat{\\theta} \\bar{y}_{i}$ 和 $x_{it}^{\\ast} = x_{it} - \\hat{\\theta} \\bar{x}_{i}$。RE 估计量 $\\hat{\\beta}_{RE}$ 是将 $y_{it}^{\\ast}$ 对一个截距项和 $x_{it}^{\\ast}$ 进行 OLS 回归得到的斜率系数。其方差 $\\widehat{\\operatorname{Var}}(\\hat{\\beta}_{RE})$ 从该变换回归的标准 OLS 方差-协方差矩阵公式中获得，具体是 $\\widehat{\\sigma}_{RE}^{2} (X^{\\ast\\prime}X^{\\ast})^{-1}$ 的 $(2,2)$ 元素，其中残差方差 $\\widehat{\\sigma}_{RE}^{2}$ 的计算使用 $NT - 2$ 的自由度。\n\n第三，执行 Hausman 检验以评估 RE 模型假设的适当性。原假设是，个体效应 $\\alpha_i$ 与回归量 $x_{it}$ 不相关，这使得 RE 估计量是一致且有效的。FE 估计量在原假设和备择假设下都是一致的。它们之间的显著差异表明 RE 假设被违反。检验统计量为：\n$$\nH = \\frac{(\\hat{\\beta}_{FE} - \\hat{\\beta}_{RE})^{2}}{\\operatorname{Var}(\\hat{\\beta}_{FE}) - \\widehat{\\operatorname{Var}}(\\hat{\\beta}_{RE})}\n$$\n该统计量仅在分母为正时有效。按照规定，如果 $\\operatorname{Var}(\\hat{\\beta}_{FE}) - \\widehat{\\operatorname{Var}}(\\hat{\\beta}_{RE}) \\le 0$，则统计量 $H$ 设为 $0$。在原假设下，$H$ 服从自由度为 $1$ 的卡方分布。决策规则是将 $H$ 与 $5\\%$ 的临界值（约为 $3.841458820694124$）进行比较。如果 $H$ 超过此值，则拒绝原假设，支持 FE 模型。\n\n实现将把这整个逻辑封装在一个函数中，该函数处理每个测试用例并返回所需的四元组：$[\\hat{\\beta}_{FE}, \\hat{\\beta}_{RE}, H, \\text{preferFE}]$。最终程序会将这些结果聚合到一个单一列表中进行输出。", "answer": "```python\nimport numpy as np\n\ndef compute_estimates_for_case(N, T, x, y):\n    \"\"\"\n    Computes FE, RE estimators, and Hausman test for a single panel dataset.\n    \"\"\"\n    # Define constants\n    NT = N * T\n    CRITICAL_VALUE = 3.841458820694124\n\n    # --- Part 1: Fixed Effects (FE) Estimator and Variance ---\n\n    # 1. & 2. Within-transformation (demeaning)\n    x_bar = x.mean(axis=1, keepdims=True)\n    y_bar = y.mean(axis=1, keepdims=True)\n    x_tilde = x - x_bar\n    y_tilde = y - y_bar\n\n    # 3. Compute FE estimator\n    numerator_fe = np.sum(x_tilde * y_tilde)\n    denominator_fe = np.sum(x_tilde**2)\n    beta_fe = numerator_fe / denominator_fe\n\n    # 4. Compute variance of FE estimator\n    u_tilde = y_tilde - beta_fe * x_tilde\n    ssr_fe = np.sum(u_tilde**2)\n    df_fe = N * (T - 1) - 1\n    sigma2_eps_fe = ssr_fe / df_fe if df_fe > 0 else 0\n    var_beta_fe = sigma2_eps_fe / denominator_fe if denominator_fe != 0 else np.inf\n\n    # --- Part 2: Random Effects (RE) Estimator and Variance ---\n\n    # 1. Pooled OLS to get residuals for variance components estimation\n    x_flat = x.flatten()\n    y_flat = y.flatten()\n    X_pool = np.vstack([np.ones(NT), x_flat]).T\n    \n    # Using np.linalg.lstsq to solve for coefficients\n    b_pool, _, _, _ = np.linalg.lstsq(X_pool, y_flat, rcond=None)\n    \n    v_flat = y_flat - X_pool @ b_pool\n    v = v_flat.reshape((N, T))\n\n    # 2. Estimate variance components\n    v_bar = v.mean(axis=1)\n    v_demeaned = v - v_bar[:, np.newaxis]\n    \n    df_eps = N * (T - 1)\n    sigma2_eps_hat = np.sum(v_demeaned**2) / df_eps if df_eps > 0 else 0\n    \n    var_v_bar = np.var(v_bar, ddof=1) if N > 1 else 0\n    \n    sigma2_eta_hat = max(0, var_v_bar - sigma2_eps_hat / T)\n\n    # 3. Compute theta and perform quasi-demeaning\n    denom_theta_sq = sigma2_eps_hat + T * sigma2_eta_hat\n    if denom_theta_sq <= 1e-9: # Avoid division by zero\n        theta = 0.0\n    else:\n        theta = 1.0 - np.sqrt(sigma2_eps_hat / denom_theta_sq)\n\n    y_star = y - theta * y_bar\n    x_star = x - theta * x_bar\n\n    # 4. OLS on quasi-demeaned data\n    y_star_flat = y_star.flatten()\n    x_star_flat = x_star.flatten()\n    X_re = np.vstack([np.ones(NT), x_star_flat]).T\n    \n    b_re, _, _, _ = np.linalg.lstsq(X_re, y_star_flat, rcond=None)\n    beta_re = b_re[1]\n    \n    # 5. Compute variance of RE estimator\n    u_re_flat = y_star_flat - X_re @ b_re\n    ssr_re = np.sum(u_re_flat**2)\n    df_re = NT - 2\n    sigma2_re = ssr_re / df_re if df_re > 0 else 0\n    \n    var_beta_re = np.inf\n    try:\n        inv_X_re_T_X_re = np.linalg.inv(X_re.T @ X_re)\n        var_cov_re = sigma2_re * inv_X_re_T_X_re\n        var_beta_re = var_cov_re[1, 1]\n    except np.linalg.LinAlgError:\n        pass # var_beta_re remains inf\n\n    # --- Part 3: Hausman Test ---\n    \n    var_diff = var_beta_fe - var_beta_re\n    H = 0.0\n    prefer_fe = False\n\n    if var_diff > 0:\n        beta_diff_sq = (beta_fe - beta_re)**2\n        H = beta_diff_sq / var_diff\n        if H > CRITICAL_VALUE:\n            prefer_fe = True\n\n    return [beta_fe, beta_re, H, prefer_fe]\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs estimations, and prints aggregated results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 4, \"T\": 3,\n            \"x\": np.array([\n                [3.0, 3.5, 4.0],\n                [2.0, 2.5, 3.0],\n                [1.0, 1.0, 1.5],\n                [4.0, 3.5, 3.0]\n            ]),\n            \"y\": np.array([\n                [3.9, 3.6, 3.35],\n                [6.2, 6.05, 5.9],\n                [8.55, 8.65, 8.4],\n                [4.5, 4.6, 4.75]\n            ])\n        },\n        {\n            \"N\": 3, \"T\": 2,\n            \"x\": np.array([\n                [1.0, 1.4],\n                [2.0, 2.2],\n                [0.5, 0.7]\n            ]),\n            \"y\": np.array([\n                [5.7, 5.6],\n                [7.35, 7.35],\n                [6.85, 6.78]\n            ])\n        },\n        {\n            \"N\": 3, \"T\": 3,\n            \"x\": np.array([\n                [1.0, 1.05, 0.95],\n                [2.0, 1.95, 2.05],\n                [1.5, 1.55, 1.45]\n            ]),\n            \"y\": np.array([\n                [3.01, 2.94, 3.05],\n                [4.02, 4.04, 3.96],\n                [3.51, 3.44, 3.54]\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, T, x, y = case[\"N\"], case[\"T\"], case[\"x\"], case[\"y\"]\n        result = compute_estimates_for_case(N, T, x, y)\n        all_results.extend(result)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"}, {"introduction": "当数据中存在多种未被观测的混杂因素时，固定效应是一个强大的工具，可以帮助我们分离出特定实体的影响。这个问题 [@problem_id:2417536] 介绍了一个双向固定效应模型，它能同时控制学生的固有能力（student fixed effects）和估计教师的“增值”效应（teacher value-added）。解决这个问题需要处理识别约束，这是在更复杂的计量经济学模型中常见的挑战，也是理解高级应用的关键一步。", "id": "2417536", "problem": "考虑一个包含学生固定效应的学生考试成绩面板模型，用以控制学生的先天能力。令 $i \\in \\{1,\\dots,S\\}$ 为学生索引，$t$ 为时期（年份）索引，$g \\in \\{1,\\dots,G\\}$ 为教师索引。每个观测值是一个三元组 $(i,g,y)$，表示学生 $i$ 在某一年由教师 $g$ 授课并取得了考试成绩 $y$。结构模型为\n$$\ny_{it} \\;=\\; \\alpha_i \\;+\\; \\tau_{g(i,t)} \\;+\\; \\varepsilon_{it},\n$$\n其中 $\\alpha_i$ 是学生固定效应，$\\tau_{g}$ 是教师 $g$ 的教师增值效应，$\\varepsilon_{it}$ 是均值为零的未观测误差。模型的识别通过以下归一化约束实现\n$$\n\\sum_{i=1}^{S} \\alpha_i \\;=\\; 0\n\\quad\\text{和}\\quad\n\\sum_{g=1}^{G} \\tau_g \\;=\\; 0.\n$$\n对于一个给定的有限数据集 $\\{(i_\\ell,g_\\ell,y_\\ell)\\}_{\\ell=1}^{N}$，定义最小二乘准则\n$$\nQ(\\alpha,\\tau) \\;=\\; \\sum_{\\ell=1}^{N} \\Big(y_\\ell \\;-\\; \\alpha_{i_\\ell} \\;-\\; \\tau_{g_\\ell}\\Big)^2\n$$\n并计算满足上述两个归一化约束的唯一最小化子 $(\\widehat{\\alpha},\\widehat{\\tau})$。报告每个数据集的教师增值向量 $\\widehat{\\tau} = (\\widehat{\\tau}_1,\\dots,\\widehat{\\tau}_G)$。\n\n您的程序必须不接受任何输入，并且必须为以下三个测试用例计算 $\\widehat{\\tau}$。在下面的每个测试用例中，学生和教师均由正整数索引，每个元组的形式为 $(\\text{学生}, \\text{教师}, \\text{分数})$。\n\n- 测试用例 1：\n  - 观测值 $\\{(i_\\ell,g_\\ell,y_\\ell)\\}$:\n    $$\n    (1,1,1.1),\\;\n    (1,2,0.7),\\;\n    (1,3,0.6),\\;\n    (2,2,0.1),\\;\n    (2,1,0.5),\\;\n    (3,3,-0.5),\\;\n    (3,1,0.0),\\;\n    (4,2,-0.8),\\;\n    (4,3,-0.9).\n    $$\n- 测试用例 2：\n  - 观测值 $\\{(i_\\ell,g_\\ell,y_\\ell)\\}$:\n    $$\n    (1,1,0.2),\\;\n    (1,2,0.1),\\;\n    (2,2,0.6),\\;\n    (2,3,0.2),\\;\n    (3,3,-0.8).\n    $$\n- 测试用例 3：\n  - 观测值 $\\{(i_\\ell,g_\\ell,y_\\ell)\\}$:\n    $$\n    (1,1,0.5),\\;\n    (1,1,0.5),\\;\n    (2,1,0.2),\\;\n    (2,1,0.2),\\;\n    (3,1,-0.7),\\;\n    (3,1,-0.7).\n    $$\n\n所有三个数据集都是 $(i,g,y)$ 元组的确定性且无噪声的描述。对于每个测试用例，您必须恢复在两个归一化约束下最小化 $Q(\\alpha,\\tau)$ 的教师增值向量 $\\widehat{\\tau}$。在每个测试用例中，按教师索引 $g = 1,\\dots,G$ 的递增顺序排列 $\\widehat{\\tau}$ 的分量。\n\n最终输出格式：您的程序应生成单行输出，包含一个列表的列表作为结果，其中第 $k$ 个内部列表是测试用例 $k$ 的教师增值向量 $\\widehat{\\tau}$，按教师标识符排序。每个条目必须是四舍五入到六位小数的实数。例如，一个有效的格式是\n$$\n\\big[\\,[\\widehat{\\tau}_1^{(1)},\\ldots],\\;[\\widehat{\\tau}_1^{(2)},\\ldots],\\;[\\widehat{\\tau}_1^{(3)},\\ldots]\\,\\big].\n$$", "solution": "用户提供了一个在计量经济学领域中明确定义的数学问题。任务是为一个双向固定效应模型寻找约束最小二乘估计量。\n\n### 问题验证\n\n首先，我将验证问题陈述。\n\n**步骤 1：提取已知条件**\n\n-   **模型**：学生考试成绩的结构模型是 $y_{it} \\;=\\; \\alpha_i \\;+\\; \\tau_{g(i,t)} \\;+\\; \\varepsilon_{it}$。\n-   **参数**：$\\alpha_i$ 是学生 $i \\in \\{1, \\dots, S\\}$ 的学生固定效应，$\\tau_g$ 是教师 $g \\in \\{1, \\dots, G\\}$ 的教师增值效应。\n-   **目标函数**：我们必须最小化残差平方和，$Q(\\alpha,\\tau) \\;=\\; \\sum_{\\ell=1}^{N} (y_\\ell \\;-\\; \\alpha_{i_\\ell} \\;-\\; \\tau_{g_\\ell})^2$。\n-   **约束条件**：最小化受两个归一化约束：$\\sum_{i=1}^{S} \\alpha_i \\;=\\; 0$ 和 $\\sum_{g=1}^{G} \\tau_g \\;=\\; 0$。\n-   **数据**：提供了三个独立的数据集（测试用例），作为元组 $(i_\\ell, g_\\ell, y_\\ell)$ 的集合。\n-   **目标**：为每个测试用例计算教师增值向量 $\\widehat{\\tau} = (\\widehat{\\tau}_1, \\dots, \\widehat{\\tau}_G)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题是线性面板数据计量经济学中的一个标准练习。该模型是一个双向固定效应模型，通过约束最小二乘法进行估计是一项基本技术。该问题在科学上和数学上都是合理的。\n-   **适定性**：模型 $y_{it} = \\alpha_i + \\tau_{g(i,t)} + \\varepsilon_{it}$ 存在完全多重共线性问题；可以给所有 $\\alpha_i$ 加上一个常数，并从所有 $\\tau_g$ 中减去该常数，而不会改变预测结果。所提供的两个归一化约束 $\\sum \\alpha_i = 0$ 和 $\\sum \\tau_g = 0$ 是解决此识别问题的标准方法，并确保在学生-教师分配网络连通的情况下存在唯一解。对于所有测试用例，数据形成一个连通图，这是存在唯一最小化子的充分条件。\n-   **客观性**：问题使用清晰的数学符号和客观的语言进行描述。没有主观或模棱两可的陈述。\n-   **完整性**：所有必要的信息（模型、目标函数、约束、数据）都已提供。\n\n**步骤 3：结论与行动**\n\n问题陈述是有效的。这是一个在计算统计学中适定且有科学依据的问题。我现在将开始推导解决方案。\n\n### 解决方案的推导\n\n问题是找到解决以下约束优化问题的 $(\\widehat{\\alpha}, \\widehat{\\tau})$：\n$$\n\\min_{\\alpha, \\tau} \\sum_{\\ell=1}^{N} (y_\\ell - \\alpha_{i_\\ell} - \\tau_{g_\\ell})^2 \\quad \\text{subject to} \\quad \\sum_{i=1}^{S} \\alpha_i = 0 \\quad \\text{和} \\quad \\sum_{g=1}^{G} \\tau_g = 0\n$$\n其中 $\\alpha = (\\alpha_1, \\dots, \\alpha_S)^T$ 且 $\\tau = (\\tau_1, \\dots, \\tau_G)^T$。\n\n这是一个带线性等式约束的二次规划问题。解决此问题的最直接方法是使用拉格朗日乘数法。拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}(\\alpha, \\tau, \\lambda_1, \\lambda_2) = \\sum_{\\ell=1}^{N} (y_\\ell - \\alpha_{i_\\ell} - \\tau_{g_\\ell})^2 - \\lambda_1 \\sum_{i=1}^{S} \\alpha_i - \\lambda_2 \\sum_{g=1}^{G} \\tau_g\n$$\n通过将 $\\mathcal{L}$ 对所有参数（$\\alpha_i$, $\\tau_g$）和拉格朗日乘数（$\\lambda_1$, $\\lambda_2$）的偏导数设为零来找到解。这将得到一个线性方程组。\n\n为了实现，用矩阵代数来表述这个问题更为方便。令 $\\theta = (\\alpha_1, \\dots, \\alpha_S, \\tau_1, \\dots, \\tau_G)^T$ 为所有参数的 $(S+G) \\times 1$ 向量。单个观测值 $\\ell$ 的模型可以写成 $y_\\ell = \\mathbf{x}_\\ell^T \\theta + \\varepsilon_\\ell$，其中 $\\mathbf{x}_\\ell$ 是一个 $(S+G) \\times 1$ 的指示变量向量。具体来说，对于一个观测值 $(i_\\ell, g_\\ell, y_\\ell)$，向量 $\\mathbf{x}_\\ell$ 在对应于 $\\alpha_{i_\\ell}$ 的位置有一个 1，在对应于 $\\tau_{g_\\ell}$ 的位置有一个 1，其他位置均为零。\n\n令 $Y$ 为结果的 $N \\times 1$ 向量，$X$ 为 $N \\times (S+G)$ 的设计矩阵，其行是 $\\mathbf{x}_\\ell^T$。目标函数为 $\\|Y - X\\theta\\|^2$。约束可以写成 $C\\theta = 0$，其中 $C$ 是 $2 \\times (S+G)$ 矩阵：\n$$\nC = \\begin{pmatrix}\n\\mathbf{1}_S^T & \\mathbf{0}_G^T \\\\\n\\mathbf{0}_S^T & \\mathbf{1}_G^T\n\\end{pmatrix} = \\begin{pmatrix}\n1 & \\dots & 1 & 0 & \\dots & 0 \\\\\n0 & \\dots & 0 & 1 & \\dots & 1\n\\end{pmatrix}\n$$\n拉格朗日函数为 $\\mathcal{L}(\\theta, \\lambda) = (Y - X\\theta)^T(Y - X\\theta) - \\lambda^T C\\theta$，其中 $\\lambda = (\\lambda_1, \\lambda_2)^T$。一阶条件（Karush-Kuhn-Tucker 条件）是：\n$$\n\\nabla_\\theta \\mathcal{L} = 2X^T(X\\theta - Y) - C^T\\lambda = 0 \\implies 2X^TX\\theta - C^T\\lambda = 2X^TY\n$$\n$$\n\\nabla_\\lambda \\mathcal{L} = -C\\theta = 0 \\implies C\\theta=0\n$$\n这给出了关于未知向量 $(\\theta^T, -\\lambda^T)^T$ 的以下分块矩阵线性方程组：\n$$\n\\begin{pmatrix}\n2X^TX & C^T \\\\\nC & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\theta \\\\\n-\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2X^TY \\\\\n0\n\\end{pmatrix}\n$$\n矩阵 $X^TX$ 和 $X^TY$ 可以直接从数据构建，而无需形成大的 $N \\times (S+G)$ 矩阵 $X$。令 $N_i$ 为学生 $i$ 的观测次数，$M_g$ 为教师 $g$ 的观测次数，$N_{ig}$ 为学生 $i$ 被教师 $g$ 教导的次数。\n矩阵 $X^TX$ 是一个具有分块结构的 $(S+G) \\times (S+G)$ 矩阵：\n$$\nX^TX = \\begin{pmatrix}\n\\text{diag}(N_1, \\dots, N_S) & (N_{ig}) \\\\\n(N_{ig})^T & \\text{diag}(M_1, \\dots, M_G)\n\\end{pmatrix}\n$$\n向量 $X^TY$ 是一个 $(S+G) \\times 1$ 的向量：\n$$\nX^TY = \\left( \\sum_{\\ell:i_\\ell=1} y_\\ell, \\dots, \\sum_{\\ell:i_\\ell=S} y_\\ell, \\sum_{\\ell:g_\\ell=1} y_\\ell, \\dots, \\sum_{\\ell:g_\\ell=G} y_\\ell \\right)^T\n$$\n通过构建此 KKT 系统并使用标准线性方程求解器求解，即可找到解。解向量将包含估计的参数 $\\widehat{\\alpha}$ 和 $\\widehat{\\tau}$。与 $\\tau$ 对应的子向量是所需的输出。\n此过程将应用于三个测试用例中的每一个。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the fixed effects problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [\n            (1, 1, 1.1), (1, 2, 0.7), (1, 3, 0.6),\n            (2, 2, 0.1), (2, 1, 0.5),\n            (3, 3, -0.5), (3, 1, 0.0),\n            (4, 2, -0.8), (4, 3, -0.9),\n        ],\n        # Test case 2\n        [\n            (1, 1, 0.2), (1, 2, 0.1),\n            (2, 2, 0.6), (2, 3, 0.2),\n            (3, 3, -0.8),\n        ],\n        # Test case 3\n        [\n            (1, 1, 0.5), (1, 1, 0.5),\n            (2, 1, 0.2), (2, 1, 0.2),\n            (3, 1, -0.7), (3, 1, -0.7),\n        ],\n    ]\n\n    results = []\n    for case in test_cases:\n        tau_hat = solve_fixed_effects(case)\n        results.append(tau_hat)\n    \n    # Format the final output string as specified\n    str_results = []\n    for tau_vec in results:\n        # Format each number to six decimal places\n        formatted_nums = [f\"{num:.6f}\" for num in tau_vec]\n        # Create a string representation of the list, e.g., \"[0.1,-0.2]\"\n        str_results.append(f\"[{','.join(formatted_nums)}]\")\n\n    # Join the vector strings and wrap in the final brackets\n    final_output = f\"[{','.join(str_results)}]\"\n    print(final_output)\n\ndef solve_fixed_effects(observations):\n    \"\"\"\n    Solves the constrained least squares problem for one set of observations.\n\n    This function implements the KKT system solution for a two-way fixed effects model.\n    It constructs and solves the system:\n    [[2*X'X, C'], [C, 0]] * [theta, -lambda]' = [2*X'y, 0]'\n    \n    Args:\n        observations (list of tuples): A list of (student_id, teacher_id, score) tuples.\n\n    Returns:\n        numpy.ndarray: The estimated teacher value-added vector (tau_hat).\n    \"\"\"\n\n    # Identify unique students and teachers and their counts (S and G)\n    student_ids = sorted(list(set([obs[0] for obs in observations])))\n    teacher_ids = sorted(list(set([obs[1] for obs in observations])))\n    S = len(student_ids)\n    G = len(teacher_ids)\n    \n    # Create mappings from original IDs to 0-based indices for matrix construction\n    s_map = {sid: i for i, sid in enumerate(student_ids)}\n    t_map = {tid: i for i, tid in enumerate(teacher_ids)}\n    \n    # Initialize components of the X'X matrix and X'y vector\n    # Ns: Diagonal elements of student block (counts per student)\n    # Mg: Diagonal elements of teacher block (counts per teacher)\n    # N_sg: Student-teacher incidence counts\n    # Ys: Sum of scores per student\n    # Yg: Sum of scores per teacher\n    Ns_diag = np.zeros(S)\n    Mg_diag = np.zeros(G)\n    N_sg = np.zeros((S, G))\n    Ys = np.zeros(S)\n    Yg = np.zeros(G)\n\n    # Populate the matrices by iterating through observations\n    for sid, tid, y in observations:\n        i = s_map[sid]\n        j = t_map[tid]\n        \n        Ns_diag[i] += 1\n        Mg_diag[j] += 1\n        N_sg[i, j] += 1\n        Ys[i] += y\n        Yg[j] += y\n        \n    # Construct the full KKT matrix K\n    dim = S + G + 2\n    K = np.zeros((dim, dim))\n    \n    # Top-left block: 2 * X'X\n    K[:S, :S] = 2 * np.diag(Ns_diag)\n    K[S:S+G, S:S+G] = 2 * np.diag(Mg_diag)\n    K[:S, S:S+G] = 2 * N_sg\n    K[S:S+G, :S] = 2 * N_sg.T\n    \n    # Top-right block: C' (transpose of constraint matrix)\n    K[:S, S+G] = 1.0       # For alpha constraint\n    K[S:S+G, S+G+1] = 1.0  # For tau constraint\n    \n    # Bottom-left block: C (constraint matrix)\n    K[S+G, :S] = 1.0       # For alpha constraint\n    K[S+G+1, S:S+G] = 1.0  # For tau constraint\n    \n    # The bottom-right 2x2 block remains zero.\n\n    # Construct the RHS vector b\n    b = np.zeros(dim)\n    b[:S] = 2 * Ys\n    b[S:S+G] = 2 * Yg\n    \n    # Solve the linear system K * z = b for z = [alpha, tau, -lambda_1, -lambda_2]'\n    z = np.linalg.solve(K, b)\n    \n    # Extract the tau_hat vector from the solution\n    # tau_hat corresponds to parameters from S to S+G-1\n    tau_hat = z[S:S+G]\n    \n    return tau_hat\n\nif __name__ == '__main__':\n    solve()\n```"}]}