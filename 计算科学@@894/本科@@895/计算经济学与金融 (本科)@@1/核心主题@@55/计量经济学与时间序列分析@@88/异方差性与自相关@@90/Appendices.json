{"hands_on_practices": [{"introduction": "本练习旨在解决计量经济学中一个关键的诊断挑战：如何区分真正的条件异方差和可能模仿其行为的其他数据特征。你将研究一个时间序列均值中的结构性突变，如果被忽略，会如何在残差中产生模式，从而被标准检验错误地解读为 GARCH 效应。通过亲手模拟，你将学会认识到在进行方差建模之前正确设定均值方程的重要性。[@problem_id:2399496]", "id": "2399496", "problem": "您的任务是设计并实现一个模拟和测试程序，用于研究时间序列均值中的一个结构性断点，如何被标准的自回归条件异方差检验错误地识别为一阶广义自回归条件异方差（表示为 $GARCH(1,1)$）。您的程序必须是完全自包含的，并且无需任何用户交互即可产生结果。\n\n使用的基本依据包括以下经过充分检验的定义和事实。\n\n- 如果一个时间序列 $\\{y_t\\}_{t=1}^T$ 的确定性均值在 $t = T_b + 1$ 时从 $\\mu_1$ 变为 $\\mu_2$，而创新项方差保持不变，则称该序列在已知时间 $T_b$ 处存在一个均值上的结构性断点。具体而言，对于 $t \\le T_b$，有 $y_t = \\mu_1 + \\varepsilon_t$；对于 $t > T_b$，有 $y_t = \\mu_2 + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n- 一个普通最小二乘法（OLS）均值模型为 $y_t = x_t^{\\prime}\\beta + \\varepsilon_t$，其中 $x_t$ 包含一个截距项以及（在适用时）额外的回归量，例如一个断点虚拟变量 $d_t$，其中当 $t \\le T_b$ 时 $d_t = 0$，当 $t > T_b$ 时 $d_t = 1$。OLS残差为 $e_t = y_t - x_t^{\\prime}\\hat{\\beta}$。\n- 针对零均值创新项 $\\{u_t\\}$ 的 $GARCH(1,1)$ 模型为 $u_t = \\sqrt{h_t} z_t$，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$，条件方差为 $h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}$。参数需满足 $\\omega > 0$，$\\alpha \\ge 0$，$\\beta \\ge 0$ 以及 $\\alpha + \\beta < 1$ 以确保存在有限的无条件方差。观测到的序列为 $y_t = \\mu + u_t$。\n- 对OLS残差序列 $\\{e_t\\}$ 进行的 $q$ 阶自回归条件异方差的 Engle 拉格朗日乘数（LM）检验，其过程是将 $e_t^2$ 对一个常数项和 $e_t^2$ 的 $q$ 阶滞后项进行回归，计算决定系数 $R^2$，并构建统计量 $LM = n R^2$，其中 $n$ 是该回归中的可用观测值数量。在原假设（滞后 $q$ 阶以内不存在自回归条件异方差）下，$LM$ 统计量渐近服从 $\\chi^2_q$ 分布。$p$-值为 $1 - F_{\\chi^2_q}(LM)$，其中 $F_{\\chi^2_q}$ 是具有 $q$ 个自由度的卡方分布的累积分布函数。\n\n您的任务是精确地实现以下步骤。\n\n1. 模拟数据生成过程（DGP）：\n   - 恒定方差下的均值结构性断点：对于给定的参数 $T$、$\\mu_1$、$\\mu_2$、$\\sigma$ 和断点分数 $b \\in (0,1)$，按照上述描述模拟 $\\{y_t\\}$，其中 $T_b = \\lfloor b T \\rfloor$ 且 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n   - 无断点的独立同分布（iid）同方差序列：$y_t = \\mu + \\varepsilon_t$，$\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n   - 无均值断点的 $GARCH(1,1)$ 序列：$y_t = \\mu + u_t$，其中 $u_t$ 遵循如上定义的 $GARCH(1,1)$ 过程。将 $h_0$ 初始化为无条件方差 $h_0 = \\omega/(1-\\alpha-\\beta)$，并使用500步的初始预烧期以减轻初始化效应。\n\n2. 建模与残差提取：\n   - 对每个模拟序列，拟合两个OLS均值模型以获得残差 $\\{e_t\\}$：\n     - 错误设定的均值：对所有 $t$ 均使用仅含截距项的模型 $x_t = [1]$。\n     - 正确设定的均值：当DGP存在结构性断点时，使用截距项加断点虚拟变量，即 $x_t = [1, d_t]$，否则仅使用截距项。\n\n3. 自回归条件异方差检验：\n   - 对每组残差和指定的滞后阶数 $q$，运行上述的 Engle LM 检验，并基于 $\\chi^2_q$ 分布计算 $p$-值。\n\n4. 解释原则（供您推理，不作为输出的一部分）：一个低的 $p$-值表示拒绝不存在自回归条件异方差的原假设。需要观察的核心现象是，当均值被错误设定时，均值的结构性断点会在 $e_t^2$ 中引发序列相关性，从而导致对GARCH类型行为的伪检测。\n\n使用以下参数集的测试套件。所有随机抽样必须使用相同的固定种子 $12345$ 生成，以确保结果可复现。\n\n- 测试用例1（理想路径，样本中段的强断点）：\n  - DGP：恒定方差下的均值结构性断点。\n  - 参数：$T = 4000$，$\\mu_1 = 0.0$，$\\mu_2 = 2.0$，$\\sigma = 1.0$， $b = 0.5$，$q = 5$。\n\n- 测试用例2（边界条件，后期断点，测试中的最小滞后）：\n  - DGP：恒定方差下的均值结构性断点。\n  - 参数：$T = 4000$，$\\mu_1 = 0.0$，$\\mu_2 = 3.0$，$\\sigma = 1.0$， $b = 0.9$，$q = 1$。\n\n- 测试用例3（边缘情况，真实的 $GARCH(1,1)$）：\n  - DGP：无均值断点的 $GARCH(1,1)$。\n  - 参数：$T = 5000$，$\\mu = 0.0$，$\\omega = 0.1$，$\\alpha = 0.05$，$\\beta = 0.9$，$q = 5$。\n\n- 测试用例4（对照组，独立同分布同方差）：\n  - DGP：无均值断点的同方差独立同分布。\n  - 参数：$T = 4000$，$\\mu = 0.0$，$\\sigma = 1.0$，$q = 5$。\n\n每个测试用例的所需输出：\n\n- 对每个测试用例 $i \\in \\{1,2,3,4\\}$，计算两个 $p$-值：\n  - $p^{(i)}_{\\text{misspec}}$：使用仅含截距项的均值模型得到的LM检验 $p$-值。\n  - $p^{(i)}_{\\text{well}}$：使用正确设定的均值模型（仅在适用时包含断点虚拟变量）得到的LM检验 $p$-值。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表包含8个结果，顺序完全按照\n  $[p^{(1)}_{\\text{misspec}}, p^{(1)}_{\\text{well}}, p^{(2)}_{\\text{misspec}}, p^{(2)}_{\\text{well}}, p^{(3)}_{\\text{misspec}}, p^{(3)}_{\\text{well}}, p^{(4)}_{\\text{misspec}}, p^{(4)}_{\\text{well}}]$，\n  每个值四舍五入到六位小数。例如，输出可能看起来像 $[0.000001,0.845210,0.000004,0.612345,0.000000,0.000000,0.523410,0.523410]$。\n\n本问题中的所有量都是无单位的实数，不涉及任何物理单位。不使用角度。百分比在概念上引用时，必须处理为小数；但是，您必须只按上述描述输出指定的 $p$-值。", "solution": "问题陈述已经过严格验证，并被认定为有效。它在已建立的计量经济学理论，特别是时间序列设定错误的研究方面，具有科学依据。该问题是良定的，为获得唯一、可验证的解提供了完整且一致的定义、参数和程序。不存在逻辑矛盾、歧义或事实不准确之处。此任务是计量经济学中的一个标准计算练习，而非征求主观意见或推测性推理。我们现在开始进行系统化的求解。\n\n目标是通过计算来证明，如果一个时间序列的均值结构性断点没有被正确建模，它如何能够产生自回归条件异方差（ARCH）的伪证据，这种现象在实践中可能导致错误模型选择。解决方案分为三个主要阶段：数据模拟、模型估计与残差提取、以及假设检验。\n\n首先，我们按规定处理三种不同数据生成过程（DGP）的模拟。所有随机操作均使用固定的随机种子$12345$，以确保可复现性。\n\n1.  **结构性断点序列**：根据以下模型生成一个长度为$T$、均值有单一断点的时间序列$\\{y_t\\}_{t=1}^T$：\n    $$\n    y_t =\n    \\begin{cases}\n    \\mu_1 + \\varepsilon_t & \\text{若 } t \\le T_b \\\\\n    \\mu_2 + \\varepsilon_t & \\text{若 } t > T_b\n    \\end{cases}\n    $$\n    其中断点位置为 $T_b = \\lfloor bT \\rfloor$，对于给定的断点分数 $b \\in (0,1)$，创新项 $\\varepsilon_t$ 是从正态分布 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0, \\sigma^2)$ 中抽取的独立同分布（iid）样本。\n\n2.  **$GARCH(1,1)$序列**：一个由广义自回归条件异方差过程(1,1)驱动的时间序列 $\\{y_t\\}_{t=1}^T$ 被生成为 $y_t = \\mu + u_t$。创新项 $u_t$ 定义为 $u_t = \\sqrt{h_t} z_t$，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$。条件方差 $h_t$ 按以下方式演化：\n    $$\n    h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}\n    $$\n    参数必须满足平稳性条件 $\\omega > 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$, 以及 $\\alpha + \\beta < 1$。模拟从 $h_0$ 设置为无条件方差 $h_{uncond} = \\frac{\\omega}{1-\\alpha-\\beta}$ 开始，并生成最初的500个数据点后予以丢弃，以减轻初始化偏差。\n\n3.  **独立同分布同方差序列**：这是一个作为基线的对照序列，生成方式为 $y_t = \\mu + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0, \\sigma^2)$。\n\n其次，对于每个模拟序列 $\\{y_t\\}$，我们从两种不同的普通最小二乘法（OLS）均值模型设定中获得残差。一般OLS模型为 $y_t = x_t^{\\prime}\\beta + e_t$，其中 $x_t$ 是回归量向量，$\\beta$ 是系数向量，$e_t$ 是残差。$\\beta$的OLS估计量是 $\\hat{\\beta} = (X'X)^{-1}X'y$，其中 $X$ 和 $y$ 分别是回归量和因变量的矩阵和向量形式。残差随后计算为 $e = y - X\\hat{\\beta}$。\n\n1.  **错误设定的模型**：该模型始终假定一个简单的常数均值，通过一个单一回归量（一个截距项）实现。因此，对所有 $t$ 都有 $x_t = [1]$。对于具有结构性断点的DGP，此模型是错误设定的。\n\n2.  **正确设定的模型**：该模型正确反映了DGP的底层均值结构。对于结构性断点DGP，回归量是一个截距项和一个断点虚拟变量 $d_t$，其中当 $t \\le T_b$ 时 $d_t=0$，当 $t > T_b$ 时 $d_t=1$。因此，$x_t = [1, d_t]$。对于GARCH和IID DGP，它们具有常数均值，正确设定的模型与错误设定的模型相同，仅包含一个截距项。\n\n第三，从每个模型中提取的残差序列 $\\{e_t\\}$ 都将接受 $q$ 阶ARCH效应的Engle拉格朗日乘数（LM）检验。该检验的原假设是直到 $q$ 阶都不存在ARCH，即在辅助回归中 $H_0: \\gamma_1 = \\gamma_2 = \\dots = \\gamma_q = 0$：\n$$\ne_t^2 = \\gamma_0 + \\gamma_1 e_{t-1}^2 + \\dots + \\gamma_q e_{t-q}^2 + \\nu_t\n$$\nLM检验统计量计算为 $LM = nR^2$，其中 $n$ 是辅助回归中的观测数量（$n = T-q$），$R^2$ 是该回归的决定系数。在原假设下，LM统计量渐近服从自由度为 $q$ 的卡方分布，$LM \\sim \\chi^2_q$。$p$-值是观测到至少与计算值一样极端的检验统计量的概率，由 $1 - F_{\\chi^2_q}(LM)$ 给出，其中 $F_{\\chi^2_q}$ 是 $\\chi^2_q$ 分布的累积分布函数。\n\n一个低的$p$-值（例如，< 0.05）会导致拒绝原假设，表明存在ARCH效应。分析的核心在于比较结构性断点DGP在错误设定和正确设定模型下得到的$p$-值。如果错误设定的模型产生低的$p$-值，而正确设定的模型产生高的$p$-值，则证实了ARCH的伪检测。对于GARCH DGP，预计两个模型都会产生低的$p$-值。对于IID DGP，预计两者都会产生高的$p$-值。整个过程对四个指定的测试用例中的每一个都实施，以产生所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    # Establish a reproducible random number generator\n    rng = np.random.default_rng(12345)\n\n    def generate_structural_break(T, mu1, mu2, sigma, b, rng_gen):\n        \"\"\"Generates a time series with a structural break in the mean.\"\"\"\n        Tb = int(np.floor(b * T))\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = np.zeros(T)\n        y[:Tb] = mu1 + innovations[:Tb]\n        y[Tb:] = mu2 + innovations[Tb:]\n        return y, Tb\n\n    def generate_garch(T, mu, omega, alpha, beta, rng_gen):\n        \"\"\"Generates a GARCH(1,1) time series.\"\"\"\n        burn_in = 500\n        total_len = T + burn_in\n        \n        z = rng_gen.normal(loc=0.0, scale=1.0, size=total_len)\n        u = np.zeros(total_len)\n        h = np.zeros(total_len)\n        \n        h[0] = omega / (1 - alpha - beta)\n        u[0] = np.sqrt(h[0]) * z[0]\n        \n        for t in range(1, total_len):\n            h[t] = omega + alpha * u[t-1]**2 + beta * h[t-1]\n            u[t] = np.sqrt(h[t]) * z[t]\n        \n        y = mu + u[burn_in:]\n        return y\n\n    def generate_iid(T, mu, sigma, rng_gen):\n        \"\"\"Generates an IID homoskedastic time series.\"\"\"\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = mu + innovations\n        return y\n\n    def get_residuals(y, with_break_dummy, Tb=None):\n        \"\"\"\n        Fits an OLS model to the data and returns the residuals.\n        \"\"\"\n        T = len(y)\n        if with_break_dummy:\n            if Tb is None:\n                raise ValueError(\"Tb must be provided for break dummy model.\")\n            X = np.ones((T, 2))\n            dummy = np.zeros(T)\n            dummy[Tb:] = 1.0\n            X[:, 1] = dummy\n        else:\n            X = np.ones((T, 1))\n\n        beta_hat = np.linalg.lstsq(X, y, rcond=None)[0]\n        y_hat = X @ beta_hat\n        residuals = y - y_hat\n        return residuals\n\n    def engle_lm_test(residuals, q):\n        \"\"\"\n        Performs the Engle LM test for ARCH effects.\n        \"\"\"\n        T = len(residuals)\n        e_sq = residuals**2\n        \n        # Dependent variable for the auxiliary regression\n        Y_aux = e_sq[q:]\n        n = len(Y_aux) # n = T - q\n        \n        # Independent variables (constant + q lags of e_sq)\n        X_aux = np.ones((n, q + 1))\n        for i in range(q):\n            # lag i+1\n            X_aux[:, i + 1] = e_sq[q - 1 - i : T - 1 - i]\n            \n        # OLS on the auxiliary regression\n        try:\n            # lstsq returns sum of squared residuals in the second element\n            rss_val = np.linalg.lstsq(X_aux, Y_aux, rcond=None)[1][0]\n        except IndexError:\n            # This can happen if the problem is perfectly determined, rss is empty.\n            rss_val = 0.0\n\n        # Total sum of squares of the dependent variable\n        tss = np.sum((Y_aux - np.mean(Y_aux))**2)\n        \n        if tss < 1e-12: # Handle cases with zero variance\n             R2 = 0.0\n        else:\n            R2 = 1 - rss_val / tss\n\n        lm_stat = n * R2\n        p_value = 1 - chi2.cdf(lm_stat, q)\n        \n        return p_value\n\n    test_cases = [\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 2.0, 'sigma': 1.0, 'b': 0.5, 'q': 5}},\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 3.0, 'sigma': 1.0, 'b': 0.9, 'q': 1}},\n        {'type': 'garch', 'params': {'T': 5000, 'mu': 0.0, 'omega': 0.1, 'alpha': 0.05, 'beta': 0.9, 'q': 5}},\n        {'type': 'iid', 'params': {'T': 4000, 'mu': 0.0, 'sigma': 1.0, 'q': 5}}\n    ]\n    \n    results = []\n    \n    # Test case 1\n    case = test_cases[0]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n    \n    # Test case 2\n    case = test_cases[1]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n\n    # Test case 3\n    case = test_cases[2]\n    params = case['params']\n    y = generate_garch(params['T'], params['mu'], params['omega'], params['alpha'], params['beta'], rng)\n    # For GARCH DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Test case 4\n    case = test_cases[3]\n    params = case['params']\n    y = generate_iid(params['T'], params['mu'], params['sigma'], rng)\n    # For IID DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```"}, {"introduction": "在学习了如何识别潜在的异方差之后，我们现在转向其在风险管理中的实际应用。本练习将引导你完成一个完整的工作流程：建立一个 GARCH(1,1) 模型来预测波动率，利用这个预测来计算一个关键的风险度量指标——风险价值 (Value-at-Risk, VaR)，然后使用正式的回测来评估模型的准确性。这个实践展示了抽象的统计模型如何转化为金融决策和验证的具体工具。[@problem_id:2399425]", "id": "2399425", "problem": "您的任务是通过将波动率模型与风险价值（VaR）阈值相结合，来量化单一资产投资组合的单步未来市场风险，然后评估观测到的VaR例外事件频率是否与模型隐含的尾部概率一致。收益过程由广义自回归条件异方差（GARCH）模型定义。您必须实现一个完整的程序，该程序能够模拟收益、计算基于模型的VaR，并执行无条件覆盖的正式回测。\n\n定义与设置：\n\n- 阶数为 $(1,1)$ 的广义自回归条件异方差（GARCH）模型由以下递归式给出：\n$$\nr_t \\;=\\; \\sqrt{h_t}\\,\\varepsilon_t,\\qquad\nh_t \\;=\\; \\omega \\;+\\; \\alpha\\, r_{t-1}^2 \\;+\\; \\beta\\, h_{t-1},\n$$\n对于 $t \\in \\{1,2,\\dots,B+T\\}$，初始条件为 $r_0 \\equiv 0$ 和 $h_0 \\equiv \\dfrac{\\omega}{1-\\alpha-\\beta}$，其中 $\\omega>0$，$\\alpha \\ge 0$，$\\beta \\ge 0$ 且 $\\alpha+\\beta < 1$。这里 $r_t$ 表示收益， $h_t$ 表示条件方差。\n\n- 创新项 $\\varepsilon_t$ 是独立同分布的，其均值为 $0$，方差为 $1$。考虑两种情况：\n  1. 条件正态分布情况：$\\varepsilon_t \\sim \\mathcal{N}(0,1)$。\n  2. 条件标准化学生t分布情况：$\\varepsilon_t = \\dfrac{u_t}{\\sqrt{\\nu/(\\nu-2)}}$，其中 $u_t \\sim t_\\nu$，自由度为 $\\nu>2$；此缩放确保 $\\mathbb{E}[\\varepsilon_t^2]=1$。\n\n- 在尾部概率水平 $p \\in (0,1)$ 下的单步未来风险价值（VaR）被定义为 $r_t$ 的条件 $p$-分位数。在VaR计算的条件正态假设下，基于截至 $t-1$ 的信息，对时间 $t$ 的模型预测阈值为：\n$$\nv_{t-1}(p) \\;=\\; z_p \\,\\sqrt{h_t},\n$$\n其中 $z_p$ 是标准正态分布的 $p$-分位数，$h_t$ 是基于截至时间 $t-1$ 的信息通过GARCH递归计算出的条件方差。\n\n- 如果 $r_t &lt; v_{t-1}(p)$，则在时间 $t$ 发生一次VaR例外事件。定义指示符 $I_t \\equiv \\mathbf{1}\\{r_t &lt; v_{t-1}(p)\\}$，并令 $n \\equiv \\sum_{t=1}^{T} I_{B+t}$ 为在 $B$ 个预热期之后，长度为 $T$ 的评估样本中的例外事件总数。\n\n回测要求：\n\n- 为检验例外事件频率是否与模型隐含的尾部概率 $p$ 相匹配，使用Kupiec失败率（POF）检验。在原假设 $\\mathbb{P}(I_t=1)=p$ 对所有 $t$ 独立成立的情况下，检验统计量为：\n$$\n\\text{LR}_{\\text{uc}} \\;=\\; -2 \\left[\nn \\ln(p) + (T-n)\\ln(1-p) \\;-\\; \\big(n \\ln(\\hat{p}) + (T-n)\\ln(1-\\hat{p})\\big)\n\\right],\n$$\n其中 $\\hat{p} \\equiv n/T$ 是样本例外事件频率。使用约定 $0 \\cdot \\ln 0 \\equiv 0$。如果在显著性水平 $\\alpha_{\\text{test}}=0.05$ 下，$\\text{LR}_{\\text{uc}} > q_{0.95}(\\chi^2_1)$，则拒绝原假设，其中 $q_{0.95}(\\chi^2_1)$ 是自由度为 1 的卡方分布的 $0.95$-分位数（约等于 $3.841458820694124$）。\n\n模拟细节：\n\n- 对于每个测试用例，使用给定的随机种子以确保可复现性，从指定的GARCH模型和创新项分布中模拟总共 $B+T$ 个时期。使用最后的 $T$ 个时期进行评估（丢弃 $B$ 个预热期后）。对于每个评估时期 $t \\in \\{B+1,\\dots,B+T\\}$，使用条件方差 $h_t$ 和标准正态分位数 $z_p$ 计算VaR阈值 $v_{t-1}(p)$，然后记录是否发生例外事件。\n\n测试套件：\n\n实现您的程序来处理以下三个测试用例。对于学生t分布创新项的情况，VaR阈值仍必须使用标准正态分位数 $z_p$ 来计算；仅数据生成过程有所不同。\n\n- 测试用例1（一般情况，设定良好的正态创新项）：\n  - $T=2500$，$B=500$，\n  - $\\omega=0.0005\\times 10^{-2}$，$\\alpha=0.05$，$\\beta=0.94$，\n  - $p=0.05$，\n  - 创新项分布：正态，\n  - 随机种子：$123456$。\n\n- 测试用例2（数据生成过程中存在厚尾，VaR在正态性假设下计算）：\n  - $T=4000$，$B=500$，\n  - $\\omega=0.0002\\times 10^{-1}$，$\\alpha=0.10$，$\\beta=0.85$，\n  - $p=0.01$，\n  - 创新项分布：标准化的学生t分布，$\\nu=5$，\n  - 随机种子：$314159$。\n\n- 测试用例3（使用中位数VaR和纯ARCH模型的边界式覆盖）：\n  - $T=1000$，$B=500$，\n  - $\\omega=0.0004\\times 10^{-2}$，$\\alpha=0.15$，$\\beta=0.00$，\n  - $p=0.50$，\n  - 创新项分布：正态，\n  - 随机种子：$271828$。\n\n程序输出要求：\n\n- 对于每个测试用例，输出一个布尔值，指示Kupiec失败率检验是否在 $0.05$ 的显著性水平上拒绝了正确无条件覆盖的原假设（如果拒绝则输出 $\\text{True}$，否则输出 $\\text{False}$）。\n\n- 您的程序应生成单行输出，其中包含按顺序排列的三个测试用例的布尔值，格式为用方括号括起来的逗号分隔列表，例如 $[\\text{False},\\text{True},\\text{False}]$。\n\n所有概率都必须作为小数处理和报告，而非百分比。本问题不涉及物理单位。本问题不出现角度。\n\n您的最终程序必须是完整的，无需任何用户输入或外部文件即可运行，并且必须严格遵守指定的输出格式。", "solution": "问题陈述经评估有效。这是一个在计算金融领域（特别是在市场风险建模和模型验证方面）形式良好、科学合理且完整的练习。所有定义、参数和约束都已明确指定，并且任务是可通过算法执行的。\n\n解决方案通过根据提供的规范实现一个模拟和回测框架来展开。每个测试用例的过程如下：\n\n1.  **GARCH(1,1)过程模拟**\n    问题的核心是模拟一个遵循GARCH($1$,$1$)过程的金融收益序列 $r_t$。该模型由两个方程定义：\n    $$r_t = \\sqrt{h_t}\\,\\varepsilon_t$$\n    $$h_t = \\omega + \\alpha\\, r_{t-1}^2 + \\beta\\, h_{t-1}$$\n    其中 $r_t$ 是时间 $t$ 的收益，$h_t$ 是收益的条件方差，$\\varepsilon_t$ 是均值为零、方差为一的独立同分布（i.i.d.）创新项。模型参数 $\\omega$、$\\alpha$ 和 $\\beta$ 必须满足 $\\omega>0$、$\\alpha \\ge 0$、$\\beta \\ge 0$ 和 $\\alpha+\\beta < 1$，以确保方差过程为正且平稳。\n\n    模拟从初始条件 $r_0 = 0$ 和 $h_0 = \\frac{\\omega}{1-\\alpha-\\beta}$ 开始，其中 $h_0$ 是该过程的无条件方差。总共模拟 $B+T$ 个时期，其中 $B$ 是预热样本的长度，$T$ 是评估样本的长度。\n\n    对于每个时间步 $t \\in \\{1, 2, \\dots, B+T\\}$，抽取一个随机创新项 $\\varepsilon_t$。指定了两种类型的创新项分布：\n    - **正态分布**：$\\varepsilon_t \\sim \\mathcal{N}(0,1)$，从标准正态分布中抽取。\n    - **标准化学生t分布**：$\\varepsilon_t = \\frac{u_t}{\\sqrt{\\nu/(\\nu-2)}}$，其中 $u_t$ 从自由度为 $\\nu$ 的学生t分布中抽取。缩放因子 $\\sqrt{\\nu/(\\nu-2)}$ 确保 $\\mathbb{E}[\\varepsilon_t^2]=1$。\n\n    模拟迭代进行，使用上一步的值为每个时间步计算 $h_t$，然后计算 $r_t$。\n\n2.  **风险价值（VaR）回测**\n    在模拟了收益和方差的完整路径后，最后 $T$ 个观测值用于回测。对于评估期内的每个时间步 $t$（从 $t=B+1$ 到 $t=B+T$），我们执行以下操作：\n    - **VaR计算**：计算给定尾部概率 $p$ 下的单步未来风险价值。问题指定VaR模型基于条件正态性假设，无论真实的数据生成过程如何。其公式为：\n      $$v_{t-1}(p) = z_p \\sqrt{h_t}$$\n      此处，$z_p$ 是标准正态分布的 $p$-分位数（例如，当 $p=0.05$ 时，$z_{0.05} \\approx -1.645$）。至关重要的是要注意到，$h_t$ 是使用截至时间 $t-1$ 的可用信息对时间 $t$ 的方差预测。\n    - **例外事件识别**：如果实现的收益 $r_t$ 小于计算出的VaR阈值，则记录一次VaR例外事件（或失败）：\n      $$I_t = \\mathbf{1}\\{r_t < v_{t-1}(p)\\} = 1$$\n    计算评估期内的例外事件总数 $n = \\sum_{t=B+1}^{B+T} I_t$。\n\n3.  **Kupiec失败率（POF）检验**\n    为检验VaR模型的有效性，使用Kupiec POF检验。此检验检查观测到的例外事件频率 $\\hat{p} = n/T$ 是否在统计上与预期频率 $p$ 一致。\n    - **原假设 ($H_0$)**：VaR例外事件的概率等于 $p$，即 $\\mathbb{P}(I_t=1) = p$。\n    - **检验统计量**：该检验使用似然比（LR）统计量，在原假设下，该统计量渐近服从自由度为1的卡方分布（$\\chi^2_1$）。统计量由以下公式给出：\n      $$\\text{LR}_{\\text{uc}} = -2 \\left[ \\ln(L(p)) - \\ln(L(\\hat{p})) \\right] = -2 \\left[ (n \\ln(p) + (T-n)\\ln(1-p)) - (n \\ln(\\hat{p}) + (T-n)\\ln(1-\\hat{p})) \\right]$$\n      其中 $L(p)$ 是二项似然函数。当 $n=0$ 或 $n=T$ 时，应用约定 $0 \\cdot \\ln(0) = 0$。\n    - **决策规则**：如果在显著性水平 $\\alpha_{\\text{test}}=0.05$ 下，计算出的统计量 $\\text{LR}_{\\text{uc}}$ 大于 $\\chi^2_1$ 分布的 $0.95$-分位数（约为 $3.8415$），则拒绝原假设。拒绝意味着VaR模型在其无条件覆盖方面存在设定错误。\n\n该实现将这些步骤封装在一个单一的、可复现的程序中。每个测试用例都使用其特定的参数集和随机种子进行处理，并确定最终的布尔结果（拒绝或不拒绝）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, t, chi2\n\ndef run_backtest(T, B, omega, alpha, beta, p, innovation_dist, nu, seed):\n    \"\"\"\n    Simulates a GARCH(1,1) process and performs a Kupiec POF backtest on VaR.\n    \n    Returns:\n        bool: True if the null hypothesis is rejected, False otherwise.\n    \"\"\"\n    # 1. Initialization\n    rng = np.random.default_rng(seed)\n    N = B + T\n    \n    # 2. Generate Innovations\n    if innovation_dist == 'normal':\n        eps = rng.standard_normal(size=N)\n    elif innovation_dist == 't':\n        if nu <= 2:\n            raise ValueError(\"Degrees of freedom nu must be > 2 for finite variance.\")\n        # Scale to have variance 1\n        scale_factor = np.sqrt((nu - 2) / nu)\n        # Pass numpy's random number generator to scipy for reproducibility\n        eps = t.rvs(df=nu, size=N, random_state=rng) * scale_factor\n    else:\n        raise ValueError(\"Invalid innovation distribution specified.\")\n\n    # 3. Simulate GARCH process\n    r = np.zeros(N + 1)\n    h = np.zeros(N + 1)\n    \n    # Initial conditions\n    r[0] = 0.0\n    denominator = 1 - alpha - beta\n    if denominator > 1e-9: # Guard against division by zero\n        h[0] = omega / denominator\n    else:\n        # Fallback for alpha+beta=1, though problem parameters are stationary\n        h[0] = omega \n\n    for i in range(1, N + 1):\n        h[i] = omega + alpha * r[i-1]**2 + beta * h[i-1]\n        r[i] = np.sqrt(h[i]) * eps[i-1]\n        \n    # 4. Backtesting Loop\n    exceptions = 0\n    z_p = norm.ppf(p)\n    \n    # Evaluation period from t=B+1 to B+T, which corresponds to array indices B+1 to N\n    for i in range(B + 1, N + 1):\n        # VaR for time i is computed using variance h[i]\n        var_threshold = z_p * np.sqrt(h[i])\n        # An exception occurs if the return is less than the VaR threshold\n        if r[i] < var_threshold:\n            exceptions += 1\n            \n    # 5. Kupiec Proportion of Failures (POF) Test\n    n = exceptions\n    \n    if T == 0:\n        return False # No data to test\n\n    p_hat = n / T\n    \n    # Define a safe log-likelihood function for a binomial outcome\n    # This correctly handles the 0*log(0) = 0 convention\n    def log_likelihood(count, total, prob):\n        if total == 0:\n            return 0.0\n        # Edge cases where probability is 0 or 1\n        if prob == 0.0:\n            return 0.0 if count == 0 else -np.inf\n        if prob == 1.0:\n            return 0.0 if count == total else -np.inf\n        \n        term1 = count * np.log(prob) if count > 0 else 0.0\n        term2 = (total - count) * np.log(1 - prob) if total > count else 0.0\n        return term1 + term2\n\n    log_L_p = log_likelihood(n, T, p)\n    log_L_phat = log_likelihood(n, T, p_hat)\n    \n    # If the observed data is impossible under H0, the LR statistic is infinite\n    if log_L_p == -np.inf:\n        lr_uc = np.inf\n    else:\n        lr_uc = -2 * (log_L_p - log_L_phat)\n        \n    # 6. Decision\n    # Critical value from chi-square distribution with 1 df at 95% confidence\n    crit_val = chi2.ppf(0.95, df=1) # Approx 3.8414588...\n    \n    return lr_uc > crit_val\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, B, omega, alpha, beta, p, innovation_dist, nu, seed)\n        (2500, 500, 0.0005e-2, 0.05, 0.94, 0.05, 'normal', None, 123456),\n        (4000, 500, 0.0002e-1, 0.10, 0.85, 0.01, 't', 5, 314159),\n        (1000, 500, 0.0004e-2, 0.15, 0.00, 0.50, 'normal', None, 271828)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and call the backtesting function\n        T, B, omega, alpha, beta, p, innovation_dist, nu, seed = case\n        result = run_backtest(T, B, omega, alpha, beta, p, innovation_dist, nu, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str(True) -> 'True', str(False) -> 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "标准的 GARCH 模型功能强大，但它们假设驱动波动率的过程随时间推移是一致的。实际上，许多经济和金融序列表现出可预测的季节性模式。本练习介绍季节性 ARCH (SARCH) 模型，这是一个旨在捕捉此类规则、周期性波动的扩展模型。你将模拟一个 SARCH 过程，可以想象它代表一家零售公司季度盈利周期的影响，并验证该模型是否有效地再现了设定的季节性波动结构。[@problem_id:2399451]", "id": "2399451", "problem": "考虑一个具有季节性条件异方差的离散时间回报过程。令 $t \\in \\{1,2,\\ldots,T\\}$ 表示时间，并通过 $q(t) = ((t-1) \\bmod 4) + 1$ 定义季节指数 $q(t) \\in \\{1,2,3,4\\}$。令 $\\{\\varepsilon_t\\}$ 为独立同分布的标准正态随机变量。定义季节性自回归条件异方差（SARCH）过程如下\n$$\nr_t = \\sigma_t \\varepsilon_t, \\quad \\sigma_t^2 = \\left(\\omega + \\alpha r_{t-1}^2\\right) \\cdot S_{q(t)},\n$$\n其中 $\\omega \\gt 0$，$\\alpha \\ge 0$，且季节性乘数 $S_1,S_2,S_3,S_4$ 为正实数。初始条件为 $r_0 = 0$ 且 $\\sigma_0^2 = \\omega \\cdot S_{q(0)}$，其中 $q(0)=4$。对于给定的非负整数预烧期长度 $B$，仅使用回报值 $\\{r_t\\}_{t=B+1}^T$ 来计算统计量。\n\n对于下面的每个参数集，使用上述递归和为新息 $\\{\\varepsilon_t\\}$ 指定的随机种子来生成序列 $\\{r_t\\}_{t=1}^T$。然后，在丢弃前 $B$ 个值之后，计算以下统计量：\n\n1. 平方回报的样本滞后1阶自相关，\n$$\n\\widehat{\\rho}_1 = \\frac{\\sum_{t=B+2}^{T} \\left(r_t^2 - \\overline{x}\\right)\\left(r_{t-1}^2 - \\overline{x}\\right)}{\\sum_{t=B+1}^{T} \\left(r_t^2 - \\overline{x}\\right)^2},\n$$\n其中 $\\overline{x} = \\frac{1}{T-B} \\sum_{t=B+1}^{T} r_t^2$。\n\n2. 每个季节 $j \\in \\{1,2,3,4\\}$ 的已实现方差，\n$$\n\\widehat{v}_j = \\frac{1}{\\#\\{t \\in \\{B+1,\\ldots,T\\} : q(t)=j\\}} \\sum_{\\substack{t=B+1 \\\\ q(t)=j}}^{T} r_t^2.\n$$\n\n3. 最大与最小已实现季节性方差之比，\n$$\nR = \\frac{\\max\\{\\widehat{v}_1,\\widehat{v}_2,\\widehat{v}_3,\\widehat{v}_4\\}}{\\min\\{\\widehat{v}_1,\\widehat{v}_2,\\widehat{v}_3,\\widehat{v}_4\\}}.\n$$\n\n4. 一个表示季节性排序是否正确的布尔指标 $O$，其定义如下：$O$ 为真，当且仅当对于所有满足 $S_i \\gt S_j$ 的配对 $(i,j)$，都有 $\\widehat{v}_i \\gt \\widehat{v}_j$ 成立；对于满足 $S_i = S_j$ 的配对，则不施加任何条件。\n\n对于每个参数集，以包含三个值 $[O,\\widehat{\\rho}_1,R]$ 的列表形式生成结果，其中 $\\widehat{\\rho}_1$ 和 $R$ 四舍五入到四位小数。\n\n测试套件（所有标量参数和 $S$ 的条目均为实数；种子为非负整数）：\n\n- 情况1（具有显著季节性和中等条件异方差的一般情况）：\n  - $T = 40000$, $B = 4000$, $\\omega = 0.2$, $\\alpha = 0.3$, $S = [1.6,\\,1.2,\\,0.9,\\,0.5]$, 种子 $= 123456$。\n\n- 情况2（无 ARCH 效应，纯粹的季节性异方差，且季节性乘数存在相等值）：\n  - $T = 40000$, $B = 4000$, $\\omega = 0.2$, $\\alpha = 0.0$, $S = [2.0,\\,1.0,\\,0.5,\\,0.5]$, 种子 $= 987654$。\n\n- 情况3（高但平稳的条件异方差和季节性）：\n  - $T = 50000$, $B = 5000$, $\\omega = 0.2$, $\\alpha = 0.8$, $S = [1.5,\\,1.0,\\,0.7,\\,0.3]$, 种子 $= 24680$。\n\n- 情况4（乘数无季节性变化）：\n  - $T = 50000$, $B = 5000$, $\\omega = 0.2$, $\\alpha = 0.4$, $S = [1.0,\\,1.0,\\,1.0,\\,1.0]$, 种子 $= 13579$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个有四个条目（每个情况一个）的逗号分隔列表，每个条目本身是一个形如 $[O,\\widehat{\\rho}_1,R]$ 的列表，不含空格，且浮点值四舍五入到四位小数。例如，输出应如下所示：\n$[[\\text{True},0.1234,2.3456],[\\text{False},0.0000,1.0123],[\\text{True},0.4567,3.2109],[\\text{True},0.2345,1.0001]]$。", "solution": "问题陈述已经过验证，并被认定为有效。这是一个在计算金融领域中提法明确、内容自洽且有科学依据的问题，具体涉及季节性自回归条件异方差（SARCH）模型的模拟与分析。所有参数、方程和初始条件都已提供，从而可以得出一个唯一且可验证的解。各项任务都是客观的，并且在计算上是可行的。\n\n解决方案首先实现SARCH过程的模拟，然后为每个参数集计算指定的统计量。\n\n**1. SARCH过程模拟**\n\n对于由参数 $T$、$B$、$\\omega$、$\\alpha$、季节性乘数向量 $S$ 和一个随机种子定义的每个测试用例，我们生成一个时间序列 $\\{r_t\\}_{t=1}^T$。\n\n该过程首先使用给定的种子初始化一个伪随机数生成器，这确保了结果的可复现性。从该生成器中抽取一个包含 $T$ 个独立同分布的标准正态随机变量的序列 $\\{\\varepsilon_t\\}_{t=1}^T$。\n\n回报序列 $\\{r_t\\}$ 是递归生成的。初始条件为 $r_0 = 0$。对于从 $1$ 到 $T$ 的每个时间步 $t$，我们计算条件方差 $\\sigma_t^2$，然后计算回报 $r_t$。时间 $t$ 的季节指数为 $q(t) = ((t-1) \\pmod 4) + 1$，它映射到以0为基准的数组索引 $q_{idx} = (t-1) \\pmod 4$。\n\n递归公式为：\n$$\n\\sigma_t^2 = \\left(\\omega + \\alpha r_{t-1}^2\\right) \\cdot S_{q(t)}\n$$\n$$\nr_t = \\sigma_t \\varepsilon_t\n$$\n这个生成过程对 $t = 1, 2, \\ldots, T$ 执行。生成的回报时间序列 $\\{r_t\\}_{t=0}^T$ 被存储起来用于下一阶段。\n\n**2. 统计量的计算**\n\n生成完整序列后，前 $B$ 个回报作为预烧期被丢弃，以减轻初始条件的影响。分析在样本 $\\{r_t\\}_{t=B+1}^T$ 上进行，其长度为 $T-B$。将此样本表示为 $\\{r'_t\\}_{t=1}^{T-B}$。\n\n首先，我们计算平方回报 $\\{r_t^2\\}_{t=B+1}^T$。我们将此序列表示为 $\\{x_t\\}_{t=B+1}^T$。\n\n- **平方回报均值 ($\\overline{x}$)**: 平方回报的样本均值计算如下：\n$$\n\\overline{x} = \\frac{1}{T-B} \\sum_{t=B+1}^{T} r_t^2\n$$\n\n- **平方回报的滞后1阶自相关 ($\\widehat{\\rho}_1$)**：使用以下公式计算 $\\{x_t\\}$ 的样本滞后1阶自相关：\n$$\n\\widehat{\\rho}_1 = \\frac{\\sum_{t=B+2}^{T} \\left(r_t^2 - \\overline{x}\\right)\\left(r_{t-1}^2 - \\overline{x}\\right)}{\\sum_{t=B+1}^{T} \\left(r_t^2 - \\overline{x}\\right)^2}\n$$\n这一步通过对平方回报数组使用向量化操作来实现，以提高计算效率。\n\n- **已实现季节性方差 ($\\widehat{v}_j$)**：对于每个季节 $j \\in \\{1, 2, 3, 4\\}$，已实现方差是在该季节观测到的平方回报的平均值。我们识别出所有满足 $q(t)=j$ 的时间点 $t \\in \\{B+1, \\ldots, T\\}$。收集这些时间点的平方回报，并计算其算术平均值以得到 $\\widehat{v}_j$。\n$$\n\\widehat{v}_j = \\frac{1}{N_j} \\sum_{\\substack{t=B+1 \\\\ q(t)=j}}^{T} r_t^2, \\quad \\text{其中 } N_j = \\#\\{t \\in \\{B+1,\\ldots,T\\} : q(t)=j\\}\n$$\n\n- **方差比率 ($R$)**：最大与最小已实现季节性方差之比计算如下：\n$$\nR = \\frac{\\max\\{\\widehat{v}_1, \\widehat{v}_2, \\widehat{v}_3, \\widehat{v}_4\\}}{\\min\\{\\widehat{v}_1, \\widehat{v}_2, \\widehat{v}_3, \\widehat{v}_4\\}}\n$$\n\n- **季节性排序指标 ($O$)**：这个布尔指标是通过比较输入的季节性乘数 $\\{S_j\\}$ 的排序与计算出的已实现季节性方差 $\\{\\widehat{v}_j\\}$ 的排序来确定的。我们将 $O$ 初始化为真。然后，我们遍历来自 $\\{1, 2, 3, 4\\}$ 的所有有序索引对 $(i, j)$。如果 $S_i > S_j$ 但 $\\widehat{v}_i \\le \\widehat{v}_j$，则条件被违反，$O$ 被设置为假。如果所有这样的不等式对都得以保持，则 $O$ 保持为真。$S_i = S_j$ 的情况对 $\\widehat{v}_i$ 和 $\\widehat{v}_j$ 之间的关系不施加任何约束。\n\n**3. 算法实现**\n\n整个过程使用 Python 的 `numpy` 库实现。测试用例被结构化为字典列表。一个主函数遍历每个用例，执行如上所述的模拟和计算，并存储结果。使用 `numpy.random.default_rng(seed)` 确保了 $\\varepsilon_t$ 的生成是确定性且可复现的。`numpy` 中的向量化数组操作被用来高效地处理大规模时间序列数据，特别是在计算样本均值、自相关和季节性方差时。最后，每个用例的结果——布尔值 $O$以及四舍五入到四位小数的浮点值 $\\widehat{\\rho}_1$ 和 $R$——被格式化为一个不含空格的字符串列表 `[O,rho,R]`。这些字符串随后用逗号连接，并用方括号括起来，以生成完全符合要求的最终输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SARCH simulation and statistics problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'T': 40000, 'B': 4000, 'omega': 0.2, 'alpha': 0.3, 'S': [1.6, 1.2, 0.9, 0.5], 'seed': 123456},\n        # Case 2\n        {'T': 40000, 'B': 4000, 'omega': 0.2, 'alpha': 0.0, 'S': [2.0, 1.0, 0.5, 0.5], 'seed': 987654},\n        # Case 3\n        {'T': 50000, 'B': 5000, 'omega': 0.2, 'alpha': 0.8, 'S': [1.5, 1.0, 0.7, 0.3], 'seed': 24680},\n        # Case 4\n        {'T': 50000, 'B': 5000, 'omega': 0.2, 'alpha': 0.4, 'S': [1.0, 1.0, 1.0, 1.0], 'seed': 13579},\n    ]\n\n    all_results_formatted = []\n    \n    for params in test_cases:\n        T = params['T']\n        B = params['B']\n        omega = params['omega']\n        alpha = params['alpha']\n        S = np.array(params['S'])\n        seed = params['seed']\n        \n        # 1. Generate the SARCH sequence\n        rng = np.random.default_rng(seed)\n        epsilons = rng.standard_normal(T)\n        r = np.zeros(T + 1)\n        # r[0] is already 0.0 from np.zeros\n\n        for t in range(1, T + 1):\n            q_idx = (t - 1) % 4\n            sigma_sq_t = (omega + alpha * r[t - 1]**2) * S[q_idx]\n            r[t] = np.sqrt(sigma_sq_t) * epsilons[t - 1]\n\n        # 2. Compute statistics on the sample r[B+1:T+1]\n        r_sample = r[B + 1:]\n        r_sq_sample = np.square(r_sample)\n        \n        # Stat 1: Sample lag-1 autocorrelation of squared returns (rho_1_hat)\n        x_bar = np.mean(r_sq_sample)\n        # Numerator: sum_{t=B+2 to T} (r_t^2 - x_bar)(r_{t-1}^2 - x_bar)\n        # Denominator: sum_{t=B+1 to T} (r_t^2 - x_bar)^2\n        # r_sq_sample[1:] corresponds to t from B+2 to T\n        # r_sq_sample[:-1] corresponds to t-1, matching the numerator's range\n        num_rho = np.sum((r_sq_sample[1:] - x_bar) * (r_sq_sample[:-1] - x_bar))\n        den_rho = np.sum(np.square(r_sq_sample - x_bar))\n        rho_1_hat = num_rho / den_rho if den_rho != 0.0 else 0.0\n        \n        # Stat 2: Realized variance per season (v_hat_j)\n        v_hats = np.zeros(4)\n        sample_indices = np.arange(B + 1, T + 1)\n        # q(t) = ((t-1) mod 4) + 1. So q_idx = (t-1) mod 4.\n        sample_q_indices = (sample_indices - 1) % 4\n        for j in range(4):  # j=0 for season 1, etc.\n            season_mask = (sample_q_indices == j)\n            # Given T and B, each season has many observations, so no need to check for empty slice\n            v_hats[j] = np.mean(r_sq_sample[season_mask])\n        \n        # Stat 3: Ratio of max to min realized seasonal variance (R)\n        R = np.max(v_hats) / np.min(v_hats)\n        \n        # Stat 4: Boolean indicator of correct seasonal ordering (O)\n        O = True\n        for i in range(4):\n            for j in range(4):\n                if S[i] > S[j]:\n                    if v_hats[i] <= v_hats[j]:\n                        O = False\n                        break\n            if not O:\n                break\n        \n        # Format results for the current case\n        case_result_str = f\"[{O},{rho_1_hat:.4f},{R:.4f}]\"\n        all_results_formatted.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_formatted)}]\")\n\nsolve()\n```"}]}