{"hands_on_practices": [{"introduction": "理论上完美的工具变量在实践中可能表现不佳，一个常见的原因就是“弱工具变量”问题。当工具变量与内生变量之间的相关性很弱时，IV估计量在有限样本中会表现出严重的偏误，并且其分布也远非正态。这个动手实践 [@problem_id:2402339] 将引导你通过蒙特卡洛模拟，亲手验证弱工具变量（通常用第一阶段的 $F$ 统计量来诊断）如何导致检验功效（Power）大幅下降，从而理解为什么在应用中我们必须警惕这一问题。", "id": "2402339", "problem": "构建一个程序，使用蒙特卡罗模拟来量化在线性工具变量设定中，弱工具变量如何影响原假设 $H_0:\\ \\beta=0$ 检验的经验功效。考虑以下针对单一内生回归量和单一工具变量（无截距项）的数据生成过程：\n- 对于每次重复和每个观测索引 $i \\in \\{1,\\dots,n\\}$，抽取 $z_i \\sim \\mathcal{N}(0,1)$。\n- 抽取独立的标准正态冲击 $e_{1i} \\sim \\mathcal{N}(0,1)$ 和 $e_{2i} \\sim \\mathcal{N}(0,1)$，并通过设置 $v_i = e_{1i}$ 和 $u_i = \\rho\\,e_{1i} + \\sqrt{1-\\rho^2}\\,e_{2i}$ 来构建相关系数为 $\\rho$ 的配对 $(v_i,u_i)$。\n- 设置 $x_i = \\pi\\,z_i + v_i$ 和 $y_i = \\beta\\,x_i + u_i$。\n\n对于每个大小为 $n$ 的模拟数据集，计算：\n1. 由样本矩条件 $\\frac{1}{n}\\sum_{i=1}^n z_i(y_i-\\beta x_i)=0$ 定义的 $\\beta$ 的恰好识别工具变量估计量，即\n$$\n\\hat{\\beta} = \\frac{\\sum_{i=1}^n z_i y_i}{\\sum_{i=1}^n z_i x_i}.\n$$\n2. 基于标量矩条件的相关常规大样本标准误，\n$$\n\\widehat{V}(\\hat{\\beta}) \\;=\\; \\frac{\\widehat{S}}{n\\,\\widehat{Q}^2},\\quad \\widehat{S}=\\frac{1}{n}\\sum_{i=1}^n (z_i\\hat{u}_i)^2,\\quad \\widehat{Q}=\\frac{1}{n}\\sum_{i=1}^n z_i x_i,\\quad \\hat{u}_i = y_i - \\hat{\\beta} x_i,\n$$\n以及对应的原假设 $H_0:\\ \\beta=0$ 的检验统计量，\n$$\nT \\;=\\; \\frac{\\hat{\\beta}-0}{\\sqrt{\\widehat{V}(\\hat{\\beta})}}.\n$$\n使用基于标准正态分位数 $c_\\alpha$ 的双边拒绝法则，如果 $|T|>c_\\alpha$ 则拒绝 $H_0$，其中 $c_\\alpha$ 满足 $\\Pr(|Z|>c_\\alpha)=\\alpha$（$Z\\sim \\mathcal{N}(0,1)$）。\n\n3. 在 $x_i$ 对 $z_i$ 的回归（无截距项）中，用于检验工具变量相关性的第一阶段 $F$ 统计量。该统计量由普通最小二乘斜率 $\\hat{a} = \\frac{\\sum_{i=1}^n z_i x_i}{\\sum_{i=1}^n z_i^2}$、残差 $r_i = x_i - \\hat{a} z_i$、残差方差 $\\hat{\\sigma}^2 = \\frac{1}{n-1}\\sum_{i=1}^n r_i^2$、标准误 $\\operatorname{se}(\\hat{a})=\\sqrt{\\hat{\\sigma}^2 / \\sum_{i=1}^n z_i^2}$、对应的 $t$ 统计量 $t_1=\\hat{a}/\\operatorname{se}(\\hat{a})$ 以及 $F = t_1^2$ 计算得出。\n\n对于下方的每组参数集，将上述步骤重复 $R$ 次独立实验，并报告：\n- 经验功效，定义为当真实 $\\beta$ 不等于 $0$ 时，在显著性水平 $\\alpha$ 下原假设被拒绝的重复实验所占的比例。\n- $R$ 次重复实验中的平均第一阶段 $F$ 统计量。\n\n使用以下参数值测试集，每个测试集指定为一个元组 $(n,\\pi,\\rho,\\beta,\\alpha,R,\\text{seed})$：\n- 情况 A（强工具变量，大样本）：$(500,\\,0.5,\\,0.6,\\,1.0,\\,0.05,\\,1000,\\,123)$。\n- 情况 B（弱工具变量，大样本）：$(500,\\,0.05,\\,0.6,\\,1.0,\\,0.05,\\,1000,\\,456)$。\n- 情况 C（中等强度工具变量，小样本）：$(100,\\,0.35,\\,0.6,\\,1.0,\\,0.05,\\,1000,\\,789)$。\n\n您的程序必须：\n- 完全按照描述实现模拟。\n- 对于每种情况，计算 $R$ 次重复实验的经验功效和平均第一阶段 $F$ 统计量。\n- 将报告的每个值四舍五入到三位小数。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是 $[\\text{power}, \\text{average F}]$ 顺序的双元素列表。例如，包含三种情况的有效输出将类似于 $[[0.842,12.531],[0.121,1.472],[0.563,6.214]]$。\n\n不涉及物理单位。所有数值答案必须是纯数字。不涉及角度。百分比必须以小数形式表示，不能使用百分号。", "solution": "该问题陈述在科学上是合理、明确且客观的。它提出了一个计算计量经济学中的标准练习，旨在分析弱工具变量对假设检验统计功效的影响。其解答通过指定的蒙特卡罗模拟构建。\n\n模拟的核心是一个数据生成过程（DGP），用于一个包含单个内生回归量 $x_i$ 和单个工具变量 $z_i$ 的线性模型。该模型由两个方程定义：\n第一阶段方程 $x_i = \\pi z_i + v_i$ 将内生回归量 $x_i$ 与工具变量 $z_i$ 联系起来。参数 $\\pi$ 控制工具变量的强度。接近于零的 $\\pi$ 值表示“弱工具变量”，意味着 $z_i$ 对 $x_i$ 的解释力很小。\n结构方程 $y_i = \\beta x_i + u_i$ 定义了结果变量 $y_i$。内生性的产生是因为误差项 $v_i$ 和 $u_i$ 是相关的，其相关性为 $\\text{Corr}(v_i, u_i) = \\rho$。这种相关性是通过独立的标准正态冲击 $e_{1i} \\sim \\mathcal{N}(0,1)$ 和 $e_{2i} \\sim \\mathcal{N}(0,1)$ 显式构建的，即设定 $v_i = e_{1i}$ 和 $u_i = \\rho e_{1i} + \\sqrt{1-\\rho^2} e_{2i}$。这种相关性违反了普通最小二乘法关于回归量与误差项不相关的假设，因此必须使用工具变量估计量。\n\n在一次模拟运行的 $R$ 次重复实验中，每次都会根据此DGP生成一个大小为 $n$ 的数据集。然后，计算以下量值：\n\n1.  **工具变量估计量**：$\\beta$ 的恰好识别IV估计量是根据矩条件 $E[z_i(y_i - \\beta x_i)]=0$ 的样本类比计算得出的。这得到了表达式 $\\hat{\\beta} = \\left(\\sum_{i=1}^n z_i y_i\\right) / \\left(\\sum_{i=1}^n z_i x_i\\right)$。如果工具变量是有效的，即它是相关的（$\\pi \\neq 0$）和外生的（$E[z_i u_i] = 0$，这在构建中是成立的），那么该估计量是 $\\beta$ 的一致估计量。\n\n2.  **假设检验**：对原假设 $H_0: \\beta=0$ 进行 $t$ 检验。检验统计量为 $T = (\\hat{\\beta} - 0) / \\sqrt{\\widehat{V}(\\hat{\\beta})}$，其中 $\\widehat{V}(\\hat{\\beta})$ 是 $\\hat{\\beta}$ 的估计方差。所提供的方差公式 $\\widehat{V}(\\hat{\\beta}) = \\widehat{S} / (n \\widehat{Q}^2)$（其中 $\\widehat{S}=\\frac{1}{n}\\sum_{i=1}^n (z_i\\hat{u}_i)^2$ 和 $\\widehat{Q}=\\frac{1}{n}\\sum_{i=1}^n z_i x_i$）是一种异方差稳健形式。如果在显著性水平 $\\alpha$ 下，检验统计量的绝对值 $|T|$ 超过了标准正态分布的临界值 $c_\\alpha$，则拒绝原假设，其中 $c_\\alpha$ 由 $\\Pr(|Z| > c_\\alpha) = \\alpha$（$Z \\sim \\mathcal{N}(0,1)$）定义。该检验的经验功效是在模拟中真实值为 $\\beta \\neq 0$ 的情况下，$H_0$ 被正确拒绝的重复实验所占的比例。\n\n3.  **第一阶段 F 统计量**：作为工具变量强度的诊断方法，计算了 $x_i$ 对 $z_i$ 进行第一阶段回归的 $F$ 统计量。由于只有一个工具变量，该值等同于 $z_i$ 的系数 $\\hat{a}$ 的 $t$ 统计量的平方。这个 $t$ 统计量是 $t_1 = \\hat{a} / \\operatorname{se}(\\hat{a})$。较低的平均 $F$ 统计量（通常以低于10的值作为经验法则）是弱工具变量的一个广泛使用的指标。已知这类工具变量会导致一系列问题，包括有限样本中存在偏差的IV估计量和扭曲的检验水平。\n\n该程序针对三个不同的参数集实现了此模拟。这些情况旨在突出不同的场景：强工具变量（情况 A：$\\pi=0.5$），弱工具变量（情况 B：$\\pi=0.05$），以及样本量较小情况下的中等强度工具变量（情况 C：$n=100$，$\\pi=0.35$）。最终输出报告了每种情况计算出的经验功效和平均第一阶段 $F$ 统计量，为工具变量强度和样本量如何影响IV模型中统计推断的可靠性提供了定量说明。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef run_simulation(n, pi, rho, beta, alpha, R, seed):\n    \"\"\"\n    Runs a Monte Carlo simulation for the instrumental variables model.\n\n    Args:\n        n (int): Sample size.\n        pi (float): Instrument strength parameter.\n        rho (float): Correlation between structural and first-stage errors.\n        beta (float): True coefficient of the endogenous regressor.\n        alpha (float): Significance level for the hypothesis test.\n        R (int): Number of repetitions.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        tuple: A tuple containing the empirical power and the average F-statistic.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    rejection_count = 0\n    total_f_stat = 0.0\n\n    # Calculate the two-sided critical value from the standard normal distribution.\n    c_alpha = norm.ppf(1 - alpha / 2)\n\n    for _ in range(R):\n        # Step 1: Generate data according to the DGP\n        z = rng.normal(loc=0, scale=1, size=n)\n        e1 = rng.normal(loc=0, scale=1, size=n)\n        e2 = rng.normal(loc=0, scale=1, size=n)\n\n        v = e1\n        u = rho * e1 + np.sqrt(1 - rho**2) * e2\n        x = pi * z + v\n        y = beta * x + u\n\n        # Step 2: Compute the IV estimator for beta\n        sum_zy = np.dot(z, y)\n        sum_zx = np.dot(z, x)\n        \n        # Avoid division by zero, though highly unlikely with continuous variables\n        if sum_zx == 0:\n            continue\n            \n        beta_hat = sum_zy / sum_zx\n\n        # Step 3: Compute the t-statistic for H_0: beta = 0\n        u_hat = y - beta_hat * x\n        Q_hat = sum_zx / n\n        S_hat = np.mean((z * u_hat)**2)\n        \n        # Denominator of variance estimator\n        var_denom = n * Q_hat**2\n        if var_denom == 0:\n            continue\n\n        V_hat_beta_hat = S_hat / var_denom\n        \n        # Ensure variance is non-negative before taking square root\n        if V_hat_beta_hat < 0:\n            continue\n        \n        se_beta_hat = np.sqrt(V_hat_beta_hat)\n        \n        if se_beta_hat == 0:\n            continue\n            \n        t_stat = beta_hat / se_beta_hat\n\n        # Step 4: Perform the hypothesis test\n        if np.abs(t_stat) > c_alpha:\n            rejection_count += 1\n\n        # Step 5: Compute the first-stage F-statistic\n        sum_zz = np.dot(z, z)\n        \n        if sum_zz == 0:\n            continue\n\n        a_hat = sum_zx / sum_zz\n        r = x - a_hat * z\n        sigma2_hat = np.sum(r**2) / (n - 1)\n        se_a_hat = np.sqrt(sigma2_hat / sum_zz)\n        \n        if se_a_hat == 0:\n            continue\n\n        t1_stat = a_hat / se_a_hat\n        f_stat = t1_stat**2\n        total_f_stat += f_stat\n\n    empirical_power = rejection_count / R\n    average_f_stat = total_f_stat / R\n\n    return empirical_power, average_f_stat\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (n, pi, rho, beta, alpha, R, seed)\n        (500, 0.5, 0.6, 1.0, 0.05, 1000, 123),  # Case A\n        (500, 0.05, 0.6, 1.0, 0.05, 1000, 456), # Case B\n        (100, 0.35, 0.6, 1.0, 0.05, 1000, 789), # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        power, avg_f = run_simulation(*case)\n        # Format each result pair to 3 decimal places\n        power_str = f\"{power:.3f}\"\n        avg_f_str = f\"{avg_f:.3f}\"\n        results.append(f\"[{power_str},{avg_f_str}]\")\n\n    # Format the final output string as a list of lists\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "工具变量估计的成败取决于其核心假设——排他性约束（Exclusion Restriction），即工具变量除通过影响内生变量外，不能有任何其他途径影响被解释变量。如果这个假设不成立，工具变量本身也是“内生的”，那么估计就会产生偏误。本练习 [@problem_id:2402354] 让你直面这一根本性挑战，通过推导和模拟，量化当工具变量与模型误差项存在微小相关性时，IV估计量会产生多大的渐近偏误。", "id": "2402354", "problem": "考虑一个标量线性结构模型，其中一个经济产出由一个潜在的内生回归量和一个不可观测的扰动项生成。对于由 $i \\in \\{1,\\dots,N\\}$ 索引的每个观测值，其数据生成过程遵循以下系统：\n1. 结构方程：$y_i = \\beta x_i + u_i$。\n2. 内生回归量的第一阶段方程：$x_i = \\pi w_i + \\gamma u_i + \\varepsilon_i$。\n3. 作为代理变量构建并违反排他性约束的候选工具变量：$z_i = w_i + \\rho u_i + \\nu_i$。\n\n所有随机变量均为实值且均值为零。扰动项 $u_i$、$\\varepsilon_i$ 和 $\\nu_i$ 相互独立，并且独立于 $w_i$。工具变量构建参数 $\\rho$ 调节 $z_i$ 和 $u_i$ 之间的相关程度，因此当 $|\\rho| > 0$ 时，矩条件 $\\mathbb{E}[z_i u_i] = 0$ 被违反。假设 $(w_i,u_i,\\varepsilon_i,\\nu_i)$ 在所有 $i$ 上都是独立同分布的，其方差分别为 $\\operatorname{Var}(w_i) = \\sigma_w^2$、$\\operatorname{Var}(u_i) = \\sigma_u^2$、$\\operatorname{Var}(\\varepsilon_i) = \\sigma_\\varepsilon^2$ 和 $\\operatorname{Var}(\\nu_i) = \\sigma_\\nu^2$。\n\n你的任务是研究当使用单一有瑕疵的工具变量 $z_i$ 并通过两阶段最小二乘法（Two-Stage Least Squares, 2SLS）估计参数 $\\beta$ 时所产生的渐近偏差。请专注于无截距项的单一工具变量、单一回归量的情形。\n\n你可以无需证明即假设以下基本前提：\n- 如果 $\\{a_i\\}_{i=1}^N$ 是独立同分布的，且 $\\mathbb{E}[a_i] = \\mu$，那么根据大数定律，当 $N \\to \\infty$ 时，$\\frac{1}{N}\\sum_{i=1}^N a_i \\to \\mu$ 依概率收敛。\n- 如果 $(a_i,b_i)$ 是独立同分布且平方可积的，那么当 $N \\to \\infty$ 时，$\\frac{1}{N}\\sum_{i=1}^N a_i b_i \\to \\mathbb{E}[a_i b_i]$ 依概率收敛。\n- 样本矩之比的概率极限等于相应概率极限之比，前提是分母收敛到一个非零极限。\n\n你的程序必须执行以下步骤：\n1. 使用上述基本前提，推导单一工具变量 2SLS 估计量 $\\hat{\\beta}_{\\text{IV}}$ 的概率极限，并将其表示为总体协方差的函数。然后，由此推导出用参数 $(\\rho,\\pi,\\gamma,\\sigma_u^2,\\sigma_w^2)$ 表示的渐近偏差 $B_\\infty = \\operatorname{plim}(\\hat{\\beta}_{\\text{IV}}) - \\beta$ 的闭式表达式。\n2. 实现一个随机模拟。对于大样本量 $N$，该模拟从相互独立的分布 $w_i \\sim \\mathcal{N}(0,\\sigma_w^2)$、$u_i \\sim \\mathcal{N}(0,\\sigma_u^2)$、$\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_\\varepsilon^2)$ 和 $\\nu_i \\sim \\mathcal{N}(0,\\sigma_\\nu^2)$ 中抽取样本，根据上述系统构建 $x_i$、$y_i$ 和 $z_i$，并计算单一工具变量 2SLS 估计量 $\\hat{\\beta}_{\\text{IV}} = \\frac{\\sum_{i=1}^N z_i y_i}{\\sum_{i=1}^N z_i x_i}$。在所有测试用例中使用相同的固定随机种子和相同的 $N$，通过模拟的绝对差 $|\\hat{\\beta}_{\\text{IV}} - \\beta|$ 来近似渐近偏差的大小。此模拟旨在数值上验证你的推导所蕴含的方向和数量级。\n3. 对于每个测试用例，还需使用给定的参数值，计算步骤 1 推导出的渐近偏差的解析大小，即从总体协方差得到的 $\\left|B_\\infty\\right|$。\n\n测试套件。对于所有情况，使用 $\\sigma_u^2 = 1$、$\\sigma_w^2 = 1$、$\\sigma_\\varepsilon^2 = 1$、$\\sigma_\\nu^2 = 1$、$\\beta = 1$，样本量 $N = 200000$，以及固定的随机种子 $2025$。参数元组 $(\\pi,\\gamma,\\rho)$ 按以下情况变化：\n- 情况 1：$(\\pi,\\gamma,\\rho) = (1.0, 0.5, 0.0)$。\n- 情况 2：$(\\pi,\\gamma,\\rho) = (1.0, 0.5, 0.2)$。\n- 情况 3：$(\\pi,\\gamma,\\rho) = (0.8, 0.4, -0.3)$。\n- 情况 4：$(\\pi,\\gamma,\\rho) = (0.1, 0.5, -0.05)$。\n- 情况 5：$(\\pi,\\gamma,\\rho) = (1.0, 0.3, 0.8)$。\n\n要求的最终输出。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的每一项是按上述顺序列出的对应情况的渐近偏差的解析大小 $\\left|B_\\infty\\right|$。将每个数字四舍五入到 6 位小数。例如，输出行的形式为 $[a_1,a_2,a_3,a_4,a_5]$，其中每个 $a_j$ 是一个四舍五入到 6 位小数的浮点数。\n\n本问题不涉及物理单位。", "solution": "问题陈述提出了一个计量经济学理论中的标准问题，即当工具变量的排他性约束被违反时，两阶段最小二乘法（2SLS）估计量的渐近性质。该问题定义明确、科学上合理且内部一致。这是一个推导和计算估计量概率极限的正式练习。我将继续进行推导和后续计算。\n\n模型由每个观测值 $i$ 的以下方程组定义：\n1. 结构方程：$y_i = \\beta x_i + u_i$\n2. 第一阶段方程：$x_i = \\pi w_i + \\gamma u_i + \\varepsilon_i$\n3. 工具变量定义：$z_i = w_i + \\rho u_i + \\nu_i$\n\n随机变量 $w_i, u_i, \\varepsilon_i, \\nu_i$ 是独立同分布（i.i.d.）、相互独立、均值为零，并且各自的方差为 $\\sigma_w^2, \\sigma_u^2, \\sigma_\\varepsilon^2, \\sigma_\\nu^2$。参数 $\\beta$ 是 $x_i$ 对 $y_i$ 的真实因果效应。回归量 $x_i$ 是内生的，因为只要 $\\gamma \\neq 0$，它就与结构误差项 $u_i$ 相关，即 $\\mathbb{E}[x_i u_i] = \\mathbb{E}[(\\pi w_i + \\gamma u_i + \\varepsilon_i)u_i] = \\gamma \\sigma_u^2$。只要 $\\rho \\neq 0$，工具变量 $z_i$ 就是无效的（非外生的），因为它与结构误差项的相关性非零：$\\mathbb{E}[z_i u_i] = \\mathbb{E}[(w_i + \\rho u_i + \\nu_i)u_i] = \\rho \\sigma_u^2$。\n\n无截距项的单一工具变量、单一回归量的 $\\beta$ 的 2SLS 估计量由下式给出：\n$$\n\\hat{\\beta}_{\\text{IV}} = \\frac{\\sum_{i=1}^N z_i y_i}{\\sum_{i=1}^N z_i x_i}\n$$\n为了找到渐近偏差，我们首先推导当样本量 $N \\to \\infty$ 时 $\\hat{\\beta}_{\\text{IV}}$ 的概率极限（$\\operatorname{plim}$）。根据大数定律和连续映射定理（具体而言，是针对比率的情况），该估计量的概率极限是分子和分母中样本矩的概率极限之比：\n$$\n\\operatorname{plim}_{N \\to \\infty} \\hat{\\beta}_{\\text{IV}} = \\frac{\\operatorname{plim}_{N \\to \\infty} \\frac{1}{N}\\sum_{i=1}^N z_i y_i}{\\operatorname{plim}_{N \\to \\infty} \\frac{1}{N}\\sum_{i=1}^N z_i x_i} = \\frac{\\mathbb{E}[z_i y_i]}{\\mathbb{E}[z_i x_i]}\n$$\n期望 $\\mathbb{E}[z_i y_i]$ 和 $\\mathbb{E}[z_i x_i]$ 分别等价于协方差 $\\operatorname{Cov}(z_i, y_i)$ 和 $\\operatorname{Cov}(z_i, x_i)$，因为所有原始随机变量的均值都为零，这意味着 $\\mathbb{E}[x_i] = \\mathbb{E}[y_i] = \\mathbb{E}[z_i] = 0$。\n\n首先，我们计算分子 $\\mathbb{E}[z_i y_i]$。代入结构方程 $y_i = \\beta x_i + u_i$：\n$$\n\\mathbb{E}[z_i y_i] = \\mathbb{E}[z_i (\\beta x_i + u_i)] = \\beta \\mathbb{E}[z_i x_i] + \\mathbb{E}[z_i u_i]\n$$\n这个表达式依赖于另外两个矩。我们来推导它们。\n\n第一个矩是分母项 $\\mathbb{E}[z_i x_i]$。代入 $z_i$ 和 $x_i$ 的定义：\n$$\n\\mathbb{E}[z_i x_i] = \\mathbb{E}[(w_i + \\rho u_i + \\nu_i)(\\pi w_i + \\gamma u_i + \\varepsilon_i)]\n$$\n展开乘积并应用期望算子，我们利用 $w_i, u_i, \\varepsilon_i, \\nu_i$ 的相互独立和零均值性质。所有诸如 $\\mathbb{E}[w_i u_i]$, $\\mathbb{E}[w_i \\varepsilon_i]$ 等交叉乘积项均为零。唯一非零的项来自于平方变量的期望：\n$$\n\\mathbb{E}[z_i x_i] = \\pi \\mathbb{E}[w_i^2] + \\rho \\gamma \\mathbb{E}[u_i^2] = \\pi \\sigma_w^2 + \\rho \\gamma \\sigma_u^2\n$$\n这是工具变量和内生回归量之间的协方差。为了使工具变量具有相关性，该协方差必须非零。\n\n第二个矩是 $\\mathbb{E}[z_i u_i]$，它量化了工具变量的内生性：\n$$\n\\mathbb{E}[z_i u_i] = \\mathbb{E}[(w_i + \\rho u_i + \\nu_i)u_i]\n$$\n同样，由于独立性，$\\mathbb{E}[w_i u_i] = 0$ 且 $\\mathbb{E}[\\nu_i u_i] = 0$。该表达式简化为：\n$$\n\\mathbb{E}[z_i u_i] = \\rho \\mathbb{E}[u_i^2] = \\rho \\sigma_u^2\n$$\n现在，将这些矩代回到 $\\operatorname{plim} \\hat{\\beta}_{\\text{IV}}$ 的表达式中：\n$$\n\\operatorname{plim} \\hat{\\beta}_{\\text{IV}} = \\frac{\\beta(\\pi \\sigma_w^2 + \\rho \\gamma \\sigma_u^2) + \\rho \\sigma_u^2}{\\pi \\sigma_w^2 + \\rho \\gamma \\sigma_u^2} = \\beta + \\frac{\\rho \\sigma_u^2}{\\pi \\sigma_w^2 + \\rho \\gamma \\sigma_u^2}\n$$\n渐近偏差 $B_\\infty$ 定义为估计量的概率极限与真实参数值 $\\beta$ 之间的差：\n$$\nB_\\infty = \\operatorname{plim} \\hat{\\beta}_{\\text{IV}} - \\beta = \\frac{\\rho \\sigma_u^2}{\\pi \\sigma_w^2 + \\rho \\gamma \\sigma_u^2}\n$$\n这是渐近偏差的闭式表达式。请注意，如果 $\\rho=0$，则偏差为零，这对应于满足排他性约束 $\\mathbb{E}[z_i u_i] = 0$ 的有效工具变量的情况。\n\n所给问题指定了参数值 $\\sigma_u^2 = 1$ 和 $\\sigma_w^2 = 1$。渐近偏差的公式简化为：\n$$\nB_\\infty = \\frac{\\rho}{\\pi + \\rho \\gamma}\n$$\n该程序将为每个测试用例计算此数量的绝对值 $\\left|B_\\infty\\right|$。按要求，该实现还包含一个随机模拟，它根据指定的过程生成数据并计算估计量 $\\hat{\\beta}_{\\text{IV}}$。这可以作为对所推导的解析公式的数值验证，因为对于大样本量 $N$，模拟偏差 $\\hat{\\beta}_{\\text{IV}} - \\beta$ 应该是对渐近偏差 $B_\\infty$ 的一个紧密近似。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and simulates the asymptotic bias of a 2SLS estimator with a faulty instrument.\n    \"\"\"\n    # Fixed parameters for all test cases\n    beta = 1.0\n    sigma_u2 = 1.0\n    sigma_w2 = 1.0\n    sigma_eps2 = 1.0\n    sigma_nu2 = 1.0\n    N = 200000\n    seed = 2025\n\n    # Parameter tuples (pi, gamma, rho) for each test case\n    test_cases = [\n        (1.0, 0.5, 0.0),\n        (1.0, 0.5, 0.2),\n        (0.8, 0.4, -0.3),\n        (0.1, 0.5, -0.05),\n        (1.0, 0.3, 0.8),\n    ]\n\n    # Generate base random shocks once using the fixed seed\n    # This ensures that the variation between test cases is due only to the parameters (pi, gamma, rho)\n    rng = np.random.default_rng(seed)\n    w = rng.normal(0, np.sqrt(sigma_w2), N)\n    u = rng.normal(0, np.sqrt(sigma_u2), N)\n    eps = rng.normal(0, np.sqrt(sigma_eps2), N)\n    nu = rng.normal(0, np.sqrt(sigma_nu2), N)\n    \n    analytical_results = []\n\n    for case in test_cases:\n        pi, gamma, rho = case\n\n        # Step 1: Analytical calculation of asymptotic bias\n        # B_inf = (rho * sigma_u^2) / (pi * sigma_w^2 + rho * gamma * sigma_u^2)\n        numerator = rho * sigma_u2\n        denominator = pi * sigma_w2 + rho * gamma * sigma_u2\n        \n        # The problem statement ensures the denominator is non-zero for all test cases.\n        if denominator == 0:\n            # This case represents an irrelevant instrument, where plim is undefined.\n            # Based on problem parameters, this should not be reached.\n            asymptotic_bias = float('nan') \n        else:\n            asymptotic_bias = numerator / denominator\n        \n        analytical_results.append(abs(asymptotic_bias))\n\n        # Step 2: Stochastic simulation for numerical validation (results not printed)\n        # This part of the code is required by the problem description to be implemented,\n        # but its output is not part of the final answer. It serves to verify the\n        # analytical derivation.\n        \n        # Construct model variables based on the current case's parameters\n        x = pi * w + gamma * u + eps\n        y = beta * x + u\n        z = w + rho * u + nu\n\n        # Compute the 2SLS estimator\n        sum_zy = np.sum(z * y)\n        sum_zx = np.sum(z * x)\n        \n        if sum_zx != 0:\n            beta_hat_iv = sum_zy / sum_zx\n            # The simulated bias for a large N should be close to the asymptotic bias\n            _simulated_bias = beta_hat_iv - beta # underscore to indicate it's not used in final output\n\n    # Format the final output as a comma-separated list of strings, rounded to 6 decimal places.\n    print(f\"[{','.join([f'{x:.6f}' for x in analytical_results])}]\")\n\nsolve()\n\n```"}, {"introduction": "在解决了工具变量的有效性（相关且外生）问题后，下一个目标是提升估计的效率，即获得更精确的估计。广义矩估计（GMM）为我们提供了实现这一目标的强大框架，尤其是在存在异方差等复杂情况下。此练习 [@problem_id:2402285] 将指导你从零开始构建一个两阶段GMM估计量，并通过数值模拟证明，与简单的IV估计相比，使用最优权重矩阵的GMM如何在异方差存在时显著提高估计的效率。", "id": "2402285", "problem": "考虑一个包含单个内生回归量的线性工具变量模型。对于由 $i \\in \\{1,\\dots,n\\}$ 索引的每个观测值，设数据生成过程为\n$$\ny_i = \\beta x_i + u_i, \\quad x_i = z_i^{\\prime}\\delta + v_i,\n$$\n其中 $y_i \\in \\mathbb{R}$，$x_i \\in \\mathbb{R}$，$z_i \\in \\mathbb{R}^L$，$\\beta \\in \\mathbb{R}$，且 $\\delta \\in \\mathbb{R}^L$。工具变量 $z_i$ 满足 $\\mathbb{E}[z_i u_i] = 0$，并可能如下文所述影响 $u_i$ 的条件方差。扰动项 $v_i$ 通过 $v_i = \\lambda u_i + \\xi_i$ 引入内生性，其中 $\\lambda \\in \\mathbb{R}$ 且 $\\xi_i$ 独立于 $(z_i, u_i)$，并满足 $\\mathbb{E}[\\xi_i] = 0$。\n\n$u_i$ 中的异方差性按如下方式生成。对于每个 $i$，抽取独立于 $z_i$ 的 $\\varepsilon_i$，满足 $\\mathbb{E}[\\varepsilon_i] = 0$ 和 $\\operatorname{Var}(\\varepsilon_i) = \\sigma_\\varepsilon^2$。定义正尺度因子\n$$\ns(z_i) = 1 + \\gamma \\frac{\\lVert z_i \\rVert_2}{\\sqrt{L}},\n$$\n其中 $\\gamma \\ge 0$，并设 $u_i = s(z_i)\\,\\varepsilon_i$。这保证了 $\\mathbb{E}[z_i u_i] = 0$，同时当 $\\gamma > 0$ 时允许 $\\operatorname{Var}(u_i \\mid z_i)$ 随 $z_i$ 变化。\n\n用于广义矩估计 (Generalized Method of Moments, GMM) 的矩向量为\n$$\ng_i(\\beta) = z_i \\left(y_i - x_i \\beta\\right) \\in \\mathbb{R}^L,\n$$\n其样本均值为 $\\bar{g}_n(\\beta) = \\frac{1}{n}\\sum_{i=1}^n g_i(\\beta)$。GMM 估计量通过选择对称正定权重矩阵 $W \\in \\mathbb{R}^{L \\times L}$，在 $\\beta \\in \\mathbb{R}$ 上最小化 $\\bar{g}_n(\\beta)^{\\prime} W \\bar{g}_n(\\beta)$。最优权重矩阵定义为此类矩阵中能使 GMM 估计量的渐近方差最小化的矩阵。\n\n你的任务是编写一个完整的程序，对下面测试套件中的每一组参数，仅使用第一性原理和样本类比方法完成以下所有操作：\n- 根据上述模型精确模拟 $n$ 个观测值。将 $z_i$ 抽取为 $\\mathbb{R}^L$ 中的独立标准正态向量，然后在模拟样本中对每个工具变量列进行标准化，使其样本均值为 $0$，样本方差为 $1$。独立于彼此及 $z_i$ 抽取 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_\\varepsilon^2)$ 和 $\\xi_i \\sim \\mathcal{N}(0,\\sigma_\\xi^2)$。然后计算 $u_i = s(z_i)\\,\\varepsilon_i$，$v_i = \\lambda u_i + \\xi_i$，$x_i = z_i^{\\prime}\\delta + v_i$ 和 $y_i = \\beta x_i + u_i$。\n- 通过 GMM 计算 $\\beta$ 的两个恰好识别估计量：\n  1. 使用单位权重矩阵 $W = I_L$ 的一步 GMM。\n  2. 使用数值计算得到的最优权重矩阵的两步 GMM。该最优权重矩阵通过计算在一步估计值处评估的矩条件的样本协方差矩阵的逆来获得，即 $\\operatorname{Var}(g_i(\\beta))$ 的样本类比的逆。\n- 对每个估计量，仅使用 GMM 一阶条件和矩向量协方差所蕴含数量的样本类比，计算 $\\hat{\\beta}$ 的估计渐近协方差。\n- 对每组参数，报告一个等于以下比率的浮点数\n$$\nr = \\frac{\\operatorname{trace}\\left(\\widehat{\\operatorname{Avar}}(\\hat{\\beta}; W = I_L)\\right)}{\\operatorname{trace}\\left(\\widehat{\\operatorname{Avar}}(\\hat{\\beta}; W = \\widehat{W}_{\\text{opt}})\\right)}.\n$$\n由于 $\\beta$ 是标量，迹等于标量渐近方差本身。在存在异方差的情况下，数值最优的二步权重矩阵应弱地提高效率，因此在大样本中 $r \\ge 1$。\n\n测试套件 (每一项给出 $(n, L, \\delta, \\beta, \\gamma, \\lambda, \\sigma_\\varepsilon, \\sigma_\\xi, \\text{seed}))$：\n- 情况 A: $(n = 4000, L = 2, \\delta = [1.0,\\,0.8]^{\\prime}, \\beta = 1.25, \\gamma = 2.0, \\lambda = 0.7, \\sigma_\\varepsilon = 1.0, \\sigma_\\xi = 1.0, \\text{seed} = 1729)$。\n- 情况 B: $(n = 4000, L = 2, \\delta = [0.1,\\,0.1]^{\\prime}, \\beta = 1.25, \\gamma = 2.0, \\lambda = 0.7, \\sigma_\\varepsilon = 1.0, \\sigma_\\xi = 1.0, \\text{seed} = 2021)$。\n- 情况 C: $(n = 4000, L = 2, \\delta = [1.0,\\,0.8]^{\\prime}, \\beta = 1.25, \\gamma = 0.0, \\lambda = 0.7, \\sigma_\\varepsilon = 1.0, \\sigma_\\xi = 1.0, \\text{seed} = 99)$。\n- 情况 D: $(n = 4000, L = 3, \\delta = [1.0,\\,-0.7,\\,0.5]^{\\prime}, \\beta = 1.5, \\gamma = 5.0, \\lambda = 0.6, \\sigma_\\varepsilon = 1.0, \\sigma_\\xi = 1.0, \\text{seed} = 31415)$。\n- 情况 E: $(n = 800, L = 2, \\delta = [0.7,\\,-0.3]^{\\prime}, \\beta = 1.25, \\gamma = 3.0, \\lambda = 0.6, \\sigma_\\varepsilon = 1.0, \\sigma_\\xi = 1.0, \\text{seed} = 2718)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含情况 A 到 E 的五个比率 $r$，形式为用方括号括起来的逗号分隔列表，每个数值条目精确到小数点后六位，例如，“[1.234567,1.000001,1.543210,1.111111,1.222222]”。", "solution": "所提出的问题是计算计量经济学中一个明确定义的练习，具体涉及广义矩估计 (GMM)。该问题在科学上是合理的，内部一致，并包含获得唯一解所需的所有信息。因此，我们进行严谨的推导和实现。\n\n模型是一个线性工具变量 (IV) 系统：\n$$\n\\begin{aligned}\ny_i &= \\beta x_i + u_i \\\\\nx_i &= z_i' \\delta + v_i\n\\end{aligned}\n$$\n其中，内生性的产生是因为结构误差 $u_i$ 通过简化式误差 $v_i$ 与回归量 $x_i$ 相关。矩条件 $\\mathbb{E}[z_i u_i] = 0$ 允许我们使用 $z_i$ 作为工具变量。\n\n对于标量参数 $\\beta$ 的 GMM 估计量 $\\hat{\\beta}$，其最小化二次型 $J(\\beta) = n \\bar{g}_n(\\beta)' W \\bar{g}_n(\\beta)$，其中 $\\bar{g}_n(\\beta) = \\frac{1}{n}\\sum_{i=1}^n z_i(y_i - x_i \\beta)$ 是矩条件的样本均值，而 $W$ 是一个对称正定权重矩阵。\n\n在矩阵表示法中，设 $Z$ 为 $n \\times L$ 的工具变量矩阵，$x$ 和 $y$ 为 $n \\times 1$ 的向量。样本矩向量为 $\\bar{g}_n(\\beta) = \\frac{1}{n} Z'(y - x\\beta)$。目标函数为 $J(\\beta) = \\frac{1}{n} (y - x\\beta)' Z W Z' (y - x\\beta)$。为求最小值，我们将关于 $\\beta$ 的导数设为零：\n$$\n\\frac{\\partial J(\\beta)}{\\partial \\beta} = -\\frac{2}{n} x'ZWZ'(y-x\\beta) = 0\n$$\n$$\nx'ZWZ'y - (x'ZWZ'x)\\beta = 0\n$$\n这给出了 GMM 估计量的闭式解：\n$$\n\\hat{\\beta}(W) = (x'ZWZ'x)^{-1}(x'ZWZ'y)\n$$\n\n问题要求计算两个估计量。\n\n首先，一步 GMM 估计量 $\\hat{\\beta}_1$ 使用单位矩阵 $W = I_L$。其公式为：\n$$\n\\hat{\\beta}_1 = (x'ZZ'x)^{-1}(x'ZZ'y)\n$$\n\n其次，两步 GMM 估计量 $\\hat{\\beta}_2$ 使用一个数值最优的权重矩阵 $\\widehat{W}_{\\text{opt}}$。理论上最优的权重矩阵是矩条件协方差矩阵的逆，即 $S = \\mathbb{E}[g_i(\\beta_0)g_i(\\beta_0)']$，其中 $\\beta_0$ 是真实参数。在两步法中，我们首先获得一个一致估计量 $\\hat{\\beta}_1$，并用它来构建 $S$ 的样本类比：\n$$\n\\widehat{S}_1 = \\frac{1}{n} \\sum_{i=1}^n g_i(\\hat{\\beta}_1)g_i(\\hat{\\beta}_1)' = \\frac{1}{n} \\sum_{i=1}^n (y_i - x_i \\hat{\\beta}_1)^2 z_i z_i' = \\frac{1}{n} Z' \\operatorname{diag}(\\hat{u}_1^2) Z\n$$\n其中 $\\hat{u}_1 = y - x\\hat{\\beta}_1$ 是第一步的残差向量。估计的最优权重矩阵为 $\\widehat{W}_{\\text{opt}} = \\widehat{S}_1^{-1}$。那么，两步估计量为：\n$$\n\\hat{\\beta}_2 = (x'Z\\widehat{S}_1^{-1}Z'x)^{-1}(x'Z\\widehat{S}_1^{-1}Z'y)\n$$\n\n接下来，我们必须为每个估计量找到估计的渐近方差。GMM 估计量的渐近方差通用公式从其极限分布中导出：\n$$\n\\sqrt{n}(\\hat{\\beta} - \\beta_0) \\xrightarrow{d} \\mathcal{N}\\left(0, (G'WG)^{-1} G'WSWG (G'WG)^{-1}\\right)\n$$\n其中 $G = \\mathbb{E}[\\nabla_\\beta g_i(\\beta_0)] = \\mathbb{E}[-z_i x_i']$ 且 $S$ 的定义如前。由于 $\\beta$ 是标量，$G$ 是一个 $L \\times 1$ 的向量。样本类比为 $\\widehat{G} = -\\frac{1}{n}Z'x$ 和 $\\widehat{S}$，为保持一致性，我们取 $\\widehat{S} = \\widehat{S}_1$。$\\hat{\\beta}$ 的估计渐近方差为：\n$$\n\\widehat{\\operatorname{Avar}}(\\hat{\\beta}) = \\frac{1}{n} (\\widehat{G}'W\\widehat{G})^{-1} (\\widehat{G}'W\\widehat{S}_1W\\widehat{G}) (\\widehat{G}'W\\widehat{G})^{-1}\n$$\n代入 $\\widehat{G}$ 并针对标量情况进行简化，我们得到：\n$$\n\\widehat{\\operatorname{Avar}}(\\hat{\\beta}(W)) = n \\frac{x'ZW\\widehat{S}_1WZ'x}{(x'ZWZ'x)^2}\n$$\n\n对于一步估计量 ($W = I_L$)，其估计的渐近方差（我们记为 $V_1$）是：\n$$\nV_1 = \\widehat{\\operatorname{Avar}}(\\hat{\\beta}_1) = n \\frac{x'Z\\widehat{S}_1Z'x}{(x'ZZ'x)^2}\n$$\n\n对于使用最优权重 $\\widehat{W}_{\\text{opt}} = \\widehat{S}_1^{-1}$ 的两步估计量，其渐近方差的“三明治”公式得以简化。标准的（非稳健）方差估计量在这里是合适的，因为我们使用的是最优权重的估计值，其公式为：\n$$\nV_2 = \\widehat{\\operatorname{Avar}}(\\hat{\\beta}_2) = \\frac{1}{n} (\\widehat{G}'\\widehat{S}_1^{-1}\\widehat{G})^{-1} = n (x'Z\\widehat{S}_1^{-1}Z'x)^{-1}\n$$\n问题要求计算比率 $r = V_1 / V_2$。该比率比较了次优的一步估计量与渐近有效的两步估计量的效率。在存在异方差 ($\\gamma > 0$) 的情况下，我们预期渐近地有 $V_1 \\ge V_2$，因此 $r \\ge 1$。如果误差是同方差的 ($\\gamma = 0$)，则两种估计量都是渐近有效的，我们预期 $r \\approx 1$。\n\n实现将遵循这些推导出的公式。对每组参数，根据指定的过程模拟数据。对 $j \\in \\{1, \\dots, L\\}$ 的每个工具变量序列 $z_j$ 进行标准化，使其样本均值为 $0$，样本方差为 $1$。所有计算都使用矩阵运算以提高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and calculations for all test cases.\n    \"\"\"\n    test_cases = [\n        # (n, L, delta, beta, gamma, lambda_val, sigma_eps, sigma_xi, seed)\n        (4000, 2, [1.0, 0.8], 1.25, 2.0, 0.7, 1.0, 1.0, 1729),   # Case A\n        (4000, 2, [0.1, 0.1], 1.25, 2.0, 0.7, 1.0, 1.0, 2021),   # Case B\n        (4000, 2, [1.0, 0.8], 1.25, 0.0, 0.7, 1.0, 1.0, 99),     # Case C\n        (4000, 3, [1.0, -0.7, 0.5], 1.5, 5.0, 0.6, 1.0, 1.0, 31415),# Case D\n        (800, 2, [0.7, -0.3], 1.25, 3.0, 0.6, 1.0, 1.0, 2718),   # Case E\n    ]\n\n    results = []\n    for params in test_cases:\n        ratio = compute_variance_ratio(*params)\n        results.append(f\"{ratio:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_variance_ratio(n, L, delta, beta_true, gamma, lambda_val, sigma_eps, sigma_xi, seed):\n    \"\"\"\n    Simulates data and computes the ratio of asymptotic variances for a single parameter set.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # 1. Simulate data according to the described Data Generating Process.\n    # Draw instruments Z from a standard normal distribution.\n    Z = rng.normal(loc=0.0, scale=1.0, size=(n, L))\n    \n    # Standardize each column of Z to have mean 0 and variance 1.\n    Z_mean = np.mean(Z, axis=0)\n    Z_std = np.std(Z, axis=0)\n    Z = (Z - Z_mean) / Z_std\n\n    # Draw error components.\n    eps = rng.normal(loc=0.0, scale=sigma_eps, size=n)\n    xi = rng.normal(loc=0.0, scale=sigma_xi, size=n)\n\n    # Construct model variables based on the structural equations.\n    s = 1.0 + gamma * np.linalg.norm(Z, axis=1) / np.sqrt(L)\n    u = s * eps\n    v = lambda_val * u + xi\n    \n    delta_col = np.array(delta).reshape(-1, 1)\n    x = (Z @ delta_col).flatten() + v\n    y = beta_true * x + u\n\n    # Reshape vectors to be n x 1 for matrix algebra.\n    x = x.reshape(-1, 1)\n    y = y.reshape(-1, 1)\n\n    # 2. Compute 1-step GMM estimator (W = I_L).\n    # Pre-compute matrix products for efficiency.\n    xT_Z = x.T @ Z         # Shape: (1, L)\n    ZT_y = Z.T @ y         # Shape: (L, 1)\n    ZT_x = Z.T @ x         # Shape: (L, 1)\n\n    # beta_hat_1 = (x' * Z * Z' * y) / (x' * Z * Z' * x)\n    # The products are (xT_Z @ ZT_y) and (xT_Z @ ZT_x)\n    numerator_b1 = (xT_Z @ ZT_y).item()\n    denominator_b1 = (xT_Z @ ZT_x).item()\n    beta_hat_1 = numerator_b1 / denominator_b1\n\n    # 3. Compute the sample covariance matrix of moments, S_hat_1.\n    # S_hat_1 is the sample analog of E[g_i * g_i'] evaluated at beta_hat_1.\n    u_hat_1 = y - x * beta_hat_1\n    # S_hat_1 = (1/n) * sum(u_hat_1i^2 * zi * zi')\n    # A fast computation: (1/n) * (Z * u_hat_1).T @ (Z * u_hat_1)\n    S_hat_1 = (1 / n) * (Z * u_hat_1).T @ (Z * u_hat_1)\n\n\n    # 4. Compute the estimated asymptotic variance of the 1-step estimator.\n    # Avar(beta_hat_1) = n * (x' * Z * S_hat_1 * Z' * x) / (x' * Z * Z' * x)^2\n    numerator_v1 = (xT_Z @ S_hat_1 @ ZT_x).item()\n    var_beta_1 = n * numerator_v1 / (denominator_b1**2)\n\n    # 5. Compute the optimal weighting matrix and the 2-step GMM estimator.\n    # W_opt = inv(S_hat_1)\n    try:\n        W_opt = np.linalg.inv(S_hat_1)\n    except np.linalg.LinAlgError:\n        # If S_hat_1 is singular (e.g., due to collinearity or small n),\n        # use the pseudo-inverse as a fallback.\n        W_opt = np.linalg.pinv(S_hat_1)\n\n    # beta_hat_2 = (x' * Z * W_opt * Z' * y) / (x' * Z * W_opt * Z' * x)\n    numerator_b2 = (xT_Z @ W_opt @ ZT_y).item()\n    denominator_b2 = (xT_Z @ W_opt @ ZT_x).item()\n    # beta_hat_2 is not needed for the ratio calculation but is computed implicitly.\n\n    # 6. Compute the estimated asymptotic variance of the 2-step estimator.\n    # Avar(beta_hat_2) = n / (x' * Z * W_opt * Z' * x)\n    var_beta_2 = n / denominator_b2\n\n    # 7. Compute the final ratio.\n    ratio = var_beta_1 / var_beta_2\n    \n    return ratio\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}