{"hands_on_practices": [{"introduction": "分析动态增长模型的第一步通常是确定其长期均衡，即“稳态”。本练习将引导你使用最直接的数值方法——不动点迭代法，在一个使用Cobb-Douglas生产函数的标准索洛增长模型中求解稳态人均有效资本。通过这个实践，你将掌握将经济学中的均衡条件转化为可计算问题并加以解决的基础技能。[@problem_id:2393421]", "id": "2393421", "problem": "给定一个单部门 Solow 增长模型，其中包含外生的人口增长、技术增长和折旧。人均有效资本的稳态由净投资为零的均衡条件来表征。从基本定义出发，构建一个不动点问题，其解为人均有效资本的稳态存量，并通过不动点迭代法（FPI）进行数值求解。\n\n使用以下核心定义作为基础：\n- 稳态的定义是下一期的人均有效资本等于当前人均有效资本。\n- 总产出由一个人均有效产出函数生产，该函数二次连续可微、严格递增且凹。为使测试集具体化，此处将使用带有参数化弹性的 Cobb–Douglas 生产函数。\n- 储蓄是产出的一个固定比例，有效折旧率是人口增长、技术增长和物质折旧之和。\n\n你的任务：\n1. 仅使用上述基本定义，从稳态条件推导出一个不动点映射。解释你将计算其不动点的数学对象，并说明在给定假设下，为何在紧凸集上存在一个不动点。\n2. 实现一个不动点迭代算法，对于给定的参数，从一个严格为正的初始猜测值开始迭代，直到满足收敛准则。\n3. 使用基于不动点残差的停止规则。具体来说，设迭代值为 $k_{t}$，映射为 $T(k)$。当 $\\lvert T(k_{t}) - k_{t} \\rvert \\le \\varepsilon \\cdot \\max\\{1,\\lvert k_{t} \\rvert\\}$ 时停止，其中容差 $\\varepsilon$ 在下文指定。\n4. 使用最大迭代次数保护，以确保在未达到容差时程序能够终止。\n\n数值要求：\n- 使用容差 $\\varepsilon = 10^{-12}$。\n- 对所有测试用例，使用统一的初始猜测值 $k_{0} = 1.0$。\n- 如果储蓄为零，则直接返回该映射所蕴含的稳态值，无需迭代。\n- 如果任何参数集导致有效折旧项为非正数，请不要尝试迭代；而是返回一个非数字标志值。具体而言，此情况下返回浮点非数字值 (NaN)。\n\n测试集模型设定：\n- 生产函数为 Cobb–Douglas 函数，$f(k) = A \\, k^{\\alpha}$。\n- 储蓄率为 $s \\in [0,1]$。\n- 有效折旧项为 $\\nu = n + g + \\delta$，其中人口增长率 $n \\ge 0$，技术增长率 $g \\ge 0$，折旧率 $\\delta \\ge 0$。\n\n对于每个参数元组 $(A,\\alpha,s,n,g,\\delta)$，使用 FPI 并根据上述要求，计算你推导出的映射的不动点，即稳态 $k^{\\star}$。将结果报告为浮点数，四舍五入到小数点后六位。\n\n测试集：\n- 案例 1：$(A,\\alpha,s,n,g,\\delta) = (\\,1.0,\\,0.3,\\,0.25,\\,0.01,\\,0.02,\\,0.08\\,)$。\n- 案例 2：$(A,\\alpha,s,n,g,\\delta) = (\\,1.0,\\,0.5,\\,0.10,\\,0.02,\\,0.02,\\,0.06\\,)$。\n- 案例 3：$(A,\\alpha,s,n,g,\\delta) = (\\,1.0,\\,0.3,\\,0.00,\\,0.02,\\,0.01,\\,0.07\\,)$。\n- 案例 4：$(A,\\alpha,s,n,g,\\delta) = (\\,0.8,\\,0.8,\\,0.30,\\,0.03,\\,0.01,\\,0.04\\,)$。\n- 案例 5：$(A,\\alpha,s,n,g,\\delta) = (\\,1.0,\\,0.9,\\,0.20,\\,0.01,\\,0.02,\\,0.07\\,)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与测试用例相同，例如 $[\\text{result}_{1},\\text{result}_{2},\\dots]$。\n- 每个 $\\text{result}_{i}$ 必须是四舍五入到小数点后六位的浮点数。", "solution": "在尝试解答之前，对问题陈述进行验证。\n\n**第1步：提取已知信息**\n- **模型**：单部门 Solow 增长模型，包含外生的人口增长 `$n \\ge 0$`、技术增长 `$g \\ge 0$` 和折旧 `$\\delta \\ge 0$`。\n- **生产函数**：一个人均有效产出函数 `$f(k)$`，该函数二次连续可微、严格递增且凹。对于测试集，该函数为 Cobb-Douglas 函数 `$f(k) = A \\, k^{\\alpha}$`。\n- **储蓄**：产出的一个固定比例 `$s \\in [0,1]$`。\n- **有效折旧**：有效折旧率为 `$\\nu = n + g + \\delta$`。\n- **稳态定义**：下一期人均有效资本等于当前人均有效资本的状态，这意味着人均有效资本的基本微分方程 `$\\dot{k}$` 为零。\n- **任务**：为人均有效资本的稳态 `$k^{\\star}$` 构建一个不动点问题，并使用不动点迭代法（FPI）求解。\n- **不动点映射**：必须从稳态条件 `$s f(k) = \\nu k$` 推导得出。\n- **算法**：不动点迭代法，从初始猜测值 `$k_{0} = 1.0$` 开始。\n- **停止规则**：使用映射 `$T(k)$` 对 `$k_t$` 进行迭代，当 `$\\lvert T(k_{t}) - k_{t} \\rvert \\le \\varepsilon \\cdot \\max\\{1,\\lvert k_{t} \\rvert\\}$` 时终止。\n- **数值参数**：容差 `$\\varepsilon = 10^{-12}$`；初始猜测值 `$k_{0} = 1.0$`。必须使用最大迭代次数保护。\n- **特殊情况**：\n    - 如果 `$s = 0$`，则不经迭代直接返回稳态值。\n    - 如果 `$\\nu \\le 0$`，返回一个非数字（`NaN`）值。\n- **测试集**：提供了五个参数元组 `$(A,\\alpha,s,n,g,\\delta)$`。\n    - 案例 1：`$(\\,1.0,\\,0.3,\\,0.25,\\,0.01,\\,0.02,\\,0.08\\,)$`。\n    - 案例 2：`$(\\,1.0,\\,0.5,\\,0.10,\\,0.02,\\,0.02,\\,0.06\\,)$`。\n    - 案例 3：`$(\\,1.0,\\,0.3,\\,0.00,\\,0.02,\\,0.01,\\,0.07\\,)$`。\n    - 案例 4：`$(\\,0.8,\\,0.8,\\,0.30,\\,0.03,\\,0.01,\\,0.04\\,)$`。\n    - 案例 5：`$(\\,1.0,\\,0.9,\\,0.20,\\,0.01,\\,0.02,\\,0.07\\,)$`。\n\n**第2步：使用提取的已知信息进行验证**\n- **科学依据**：该问题基于 Solow-Swan 模型，这是宏观经济学中一个基础且成熟的框架。使用 Cobb-Douglas 生产函数并通过不动点问题推导稳态是标准的教科书程序。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。对于给定的参数约束（`$0 < \\alpha < 1$`、`$s > 0$`、`$\\nu > 0$`），模型保证存在一个唯一的、非平凡且稳定的稳态资本存量。问题提供了所有必要的信息和明确的目标。\n- **客观性**：问题使用精确、客观、形式化的数学和经济学术语进行陈述。没有主观或含糊不清的表述。\n\n**第3步：结论与行动**\n该问题有效。这是一个计算经济学中的标准、定义明确的问题，具有科学依据且内部一致。将提供完整解答。\n\n**不动点映射的推导与解的存在性**\n\n令 `$k$` 为人均有效资本。在连续时间的 Solow 模型中，`$k$` 的基本运动方程由以下微分方程给出：\n$$ \\dot{k} = s f(k) - (n + g + \\delta)k $$\n其中 `$s f(k)$` 代表人均有效总投资，而 `$(n + g + \\delta)k$` 代表人均有效折旧。项 `$\\nu = n + g + \\delta$` 是有效折旧率，它包括了物质折旧（`$\\delta$`）、因人口增长导致的资本稀释（`$n$`）以及因技术进步导致的资本稀释（`$g$`）。\n\n稳态，记为 `$k^{\\star}$`，是一个均衡点，在该点上人均有效资本存量保持不变，即 `$\\dot{k} = 0$`。这得出了稳态条件：\n$$ s f(k^{\\star}) = \\nu k^{\\star} $$\n假设 `$\\nu > 0$`，我们可以重排此方程以定义一个不动点问题。函数 `$T(k)$` 的不动点是一个值 `$k^{\\star}$`，满足 `$T(k^{\\star}) = k^{\\star}$`。我们可以从稳态条件定义这样一个函数 `$T(k)`：\n$$ k^{\\star} = \\frac{s}{\\nu} f(k^{\\star}) $$\n因此，我们必须计算其不动点的数学对象是由以下公式定义的映射 `$T: \\mathbb{R}_+ \\to \\mathbb{R}_+$`：\n$$ T(k) = \\frac{s}{\\nu} f(k) $$\n对于特定的 Cobb-Douglas 生产函数 `$f(k) = A k^{\\alpha}$`，该映射变为：\n$$ T(k) = \\left( \\frac{sA}{\\nu} \\right) k^{\\alpha} $$\n在特定条件下，Brouwer 不动点定理保证了在紧凸集上存在一个不动点。该定理指出，任何将一个紧、凸、非空的集合映射到其自身的连续函数，都至少有一个不动点。\n\n让我们分析当 `$k \\ge 0$` 时，假设 `$s>0$`、`$\\nu>0$`、`$A>0$` 且 `$0 < \\alpha < 1$` 的情况下的映射 `$T(k)$`。\n1. 我们关注的定义域是 `$k \\in [0, \\infty)$`。函数 `$T(k)$` 在此定义域上是连续的。\n2. 我们需要找到一个紧凸集 `$D \\subset [0, \\infty)$` 使得 `$T(D) \\subseteq D$`。设 `$D = [k_{min}, k_{max}]$`，其中 `$0 < k_{min} < k_{max}$`。\n3. 生产函数的标准 Inada 条件，对于 `$0 < \\alpha < 1$` 的 Cobb-Douglas 形式是满足的，这些条件是 `$\\lim_{k \\to 0} f'(k) = \\infty$` 和 `$\\lim_{k \\to \\infty} f'(k) = 0$`。\n4. 关于 `$f'(k)$` 的这些条件意味着 `$T(k)$` 的斜率，即 `$T'(k) = \\frac{s}{\\nu} f'(k)$`，在 `$k \\to 0$` 时也趋于无穷大，在 `$k \\to \\infty$` 时趋于零。\n5. 条件 `$\\lim_{k \\to 0} T'(k) = \\infty$` 确保对于足够小的 `$k_{min} > 0$`，`$T(k)$` 的图像比直线 `$y=k$` 更陡峭，这意味着 `$T(k_{min}) > k_{min}$`。\n6. 条件 `$\\lim_{k \\to \\infty} T'(k) = 0$` 确保对于足够大的 `$k_{max}$`，`$T(k)$` 的图像比直线 `$y=k$` 更平缓，这意味着 `$T(k_{max}) < k_{max}$`。\n7. 由于 `$T(k)$` 是一个连续函数，我们可以将中值定理应用于区间 `$[k_{min}, k_{max}]$` 上的函数 `$g(k) = T(k) - k$`。因为 `$g(k_{min}) > 0$` 且 `$g(k_{max}) < 0$`，所以必定存在至少一个点 `$k^{\\star} \\in (k_{min}, k_{max})$` 使得 `$g(k^{\\star}) = 0$`，这意味着 `$T(k^{\\star}) = k^{\\star}$`。这就证明了不动点的存在性。对于 `$0 < \\alpha < 1$`，`$T(k)$` 是严格凹的，这确保了正不动点 `$k^{\\star}$` 是唯一的。\n\n**算法实现**\n\n不动点迭代（FPI）算法使用递推关系 `$k_{t+1} = T(k_t)$` 生成一个序列 `$\\{k_t\\}_{t=0}^\\infty$`。给定 `$T(k)$` 的性质，对于任何初始猜测值 `$k_0 > 0$`，该序列保证收敛到唯一的正不动点 `$k^{\\star}$`。\n\n算法如下：\n1. 对于给定的参数集 `$(A, \\alpha, s, n, g, \\delta)$`，首先计算有效折旧 `$\\nu = n+g+\\delta$`。\n2. 处理特殊情况：如果 `$\\nu \\le 0$`，模型是病态的；返回 `NaN`。如果 `$s = 0$`，唯一的投资是零，所以稳态是 `$k^{\\star} = 0$`；返回 `$0.0$`。\n3. 以 `$k_t = k_0 = 1.0$` 初始化迭代。\n4. 在一个循环中，计算下一个迭代值 `$k_{t+1} = T(k_t) = (s A k_{t}^{\\alpha}) / \\nu$`。\n5. 使用指定的停止规则检查收敛性：`$\\lvert k_{t+1} - k_t \\rvert \\le \\varepsilon \\cdot \\max\\{1, \\lvert k_t \\rvert\\}$`，其中 `$\\varepsilon = 10^{-12}$`。\n6. 如果满足条件，则迭代已收敛。返回 `$k_{t+1}$`。\n7. 如果不满足条件，则更新 `$k_t \\leftarrow k_{t+1}$` 并继续下一次迭代。\n8. 必须设定最大迭代次数，以保证在不收敛的情况下程序能够终止，尽管对于给定的测试用例，预期会收敛。", "answer": "```python\nimport numpy as np\n\ndef solve_fpi(params):\n    \"\"\"\n    Computes the steady-state capital per effective worker for the Solow model\n    using Fixed Point Iteration.\n\n    Args:\n        params (tuple): A tuple containing the model parameters (A, alpha, s, n, g, delta).\n\n    Returns:\n        float: The steady-state capital k*, or np.nan if the model is ill-defined.\n    \"\"\"\n    A, alpha, s, n, g, delta = params\n    \n    # Calculate the effective depreciation rate\n    nu = n + g + delta\n    \n    # Handle special case: non-positive effective depreciation\n    if nu <= 0:\n        return np.nan\n        \n    # Handle special case: zero savings rate\n    # If s = 0, T(k) = 0 for all k, so the fixed point is k* = 0.\n    if s == 0.0:\n        return 0.0\n\n    # FPI parameters\n    k_curr = 1.0  # Initial guess k_0\n    eps = 1e-12   # Tolerance\n    max_iter = 5000 # Maximum iteration safeguard\n\n    for _ in range(max_iter):\n        # Apply the fixed-point map T(k) = (s * A * k^alpha) / nu\n        try:\n            k_next = (s * A * (k_curr ** alpha)) / nu\n        except (ValueError, OverflowError):\n            # Handle potential numerical errors for very large k\n            return np.nan\n\n        # Check for convergence using the specified mixed absolute/relative tolerance\n        if abs(k_next - k_curr) <= eps * max(1.0, abs(k_curr)):\n            return k_next\n        \n        # Update for the next iteration\n        k_curr = k_next\n\n    # If max_iter is reached without convergence, return the last computed value\n    # as a best-effort result, though this case is not expected for the given tests.\n    return k_curr\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (A, alpha, s, n, g, delta)\n        (1.0, 0.3, 0.25, 0.01, 0.02, 0.08),  # Case 1\n        (1.0, 0.5, 0.10, 0.02, 0.02, 0.06),  # Case 2\n        (1.0, 0.3, 0.00, 0.02, 0.01, 0.07),  # Case 3\n        (0.8, 0.8, 0.30, 0.03, 0.01, 0.04),  # Case 4\n        (1.0, 0.9, 0.20, 0.01, 0.02, 0.07),  # Case 5\n    ]\n    \n    results = []\n    for case in test_cases:\n        k_star = solve_fpi(case)\n        results.append(k_star)\n\n    # Format results to six decimal places for printing\n    formatted_results = []\n    for res in results:\n        if np.isnan(res):\n            formatted_results.append('nan')\n        else:\n            formatted_results.append(f\"{res:.6f}\")\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "经济建模常常需要比标准$Cobb-Douglas$生产函数更具灵活性的设定。本练习引入了更具一般性的恒定替代弹性（$CES$）生产函数，你会发现求解其稳态需要处理一个更复杂的非线性方程。我们将运用强大的求根算法——割线法，来精确地找到模型的均衡点，这让你能够处理更广泛的经济模型。[@problem_id:2443698]", "id": "2443698", "problem": "考虑一个离散时间的 Solow 增长模型，该模型具有 Harrod 中性技术进步，其中每效率单位的总产出由一个恒定替代弹性 (CES) 生产函数给出。令 $k$ 表示每效率劳动单位的资本，$y$ 表示每效率单位的产出，$s \\in (0,1)$ 表示恒定的储蓄率，$n \\ge 0$ 表示人口增长率，$g \\ge 0$ 表示劳动增强型技术增长率，$\\delta \\in (0,1)$ 表示折旧率。在稳态下，每效率单位资本 $k^{\\ast}$ 满足以下条件\n$$\ns\\, f(k^{\\ast}) = (n+g+\\delta)\\, k^{\\ast}.\n$$\n假设单位效率生产函数 $f(k)$ 是 CES 型的，其分配参数为 $\\theta \\in (0,1)$，替代弹性为 $\\sigma > 0$，定义如下\n$$\nf(k) =\n\\begin{cases}\n\\left[\\theta\\, k^{\\rho} + (1-\\theta)\\right]^{1/\\rho}, & \\text{若 } \\rho \\ne 0,\\\n$$6pt]\nk^{\\theta}, & \\text{若 } \\rho = 0,\n\\end{cases}\n\\quad\\text{其中}\\quad \\rho \\equiv \\frac{\\sigma - 1}{\\sigma}.\n$$\n定义稳态残差函数\n$$\nF(k) \\equiv s\\, f(k) - (n+g+\\delta)\\, k.\n$$\n稳态 $k^{\\ast}$ 是任何满足 $F(k^{\\ast}) = 0$ 的正值 $k^{\\ast} > 0$。\n\n您的任务是编写一个完整、可运行的程序，对下方的每个测试用例，仅使用所提供的信息，计算 $k^{\\ast}$ 的一个数值近似解 $\\widehat{k}$，使得方程 $F(\\widehat{k}) = 0$ 在 $10^{-10}$ 的绝对容差内成立。对于每个测试用例，将所列的一对正值作为初始化计算的两个起始 $k$ 值。如果某个测试用例在给定参数下没有正解，或者如果您的计算未能在有限步数内达到容差要求，您仍必须输出一个数值；然而，在本作业中，提供的所有用例都构造为有唯一的正解。\n\n测试套件 (每行为一个测试用例，其参数为 $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1})$):\n- 案例 A: $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (\\,0.200,\\ 0.010,\\ 0.020,\\ 0.050,\\ 0.400,\\ 0.800,\\ 0.100,\\ 50.000\\,)$\n- 案例 B: $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (\\,0.200,\\ 0.010,\\ 0.020,\\ 0.050,\\ 0.400,\\ 1.500,\\ 0.100,\\ 20.000\\,)$\n- 案例 C: $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (\\,0.250,\\ 0.015,\\ 0.020,\\ 0.050,\\ 0.300,\\ 0.990,\\ 1.000,\\ 10.000\\,)$\n\n程序要求：\n- 对于每个测试用例，计算唯一正稳态 $k^{\\ast}$ 的一个数值近似解 $\\widehat{k}$，使得 $|F(\\widehat{k})| \\le 10^{-10}$。\n- 使用如上定义的 CES 函数，其中 $\\rho = (\\sigma - 1)/\\sigma$，并在 $\\rho = 0$ 时使用 Cobb–Douglas 极限 $f(k) = k^{\\theta}$。\n- 输出格式：您的程序应生成单行输出，其中包含三个结果，以逗号分隔并用方括号括起，每个 $\\widehat{k}$ 四舍五入到 $10$ 位小数（例如，$[x_{A},x_{B},x_{C}]$，其中每个 $x_{\\cdot}$ 是一个小数点后恰好有 $10$ 位数字的浮点数）。", "solution": "该问题要求计算一个具有恒定替代弹性 (CES) 生产函数的 Solow 增长模型中的稳态每效率单位资本，记为 $k^{\\ast}$。稳态定义为一个满足均衡条件的正值 $k^{\\ast} > 0$：\n$$\ns\\, f(k^{\\ast}) = (n+g+\\delta)\\, k^{\\ast}\n$$\n该方程可以通过定义一个残差函数 $F(k)$ 重新表述为一个求根问题：\n$$\nF(k) \\equiv s\\, f(k) - (n+g+\\delta)\\, k\n$$\n目标是找到一个数值近似解 $\\widehat{k}$ 使得 $F(\\widehat{k}) = 0$。更确切地说，我们寻求一个值 $\\widehat{k}$，其残差的绝对值小于或等于指定的容差，即 $|F(\\widehat{k})| \\le 10^{-10}$。\n\n每效率单位生产函数 $f(k)$ 是 CES 类型的，定义为：\n$$\nf(k) =\n\\begin{cases}\n\\left[\\theta\\, k^{\\rho} + (1-\\theta)\\right]^{1/\\rho}, & \\text{若 } \\rho \\ne 0 \\\\\nk^{\\theta}, & \\text{若 } \\rho = 0\n\\end{cases}\n$$\n其中参数 $\\rho$ 通过公式 $\\rho = (\\sigma - 1)/\\sigma$ 与替代弹性 $\\sigma$ 相关。每个测试用例都提供了参数 $s$、$n$、$g$、$\\delta$、$\\theta$ 和 $\\sigma$，且它们都位于其理论有效范围内。\n\n问题为每个案例提供了两个 $k$ 的初始近似值，我们记为 $k_0$ 和 $k_1$。这种结构表明，采用双点迭代法是合适的。我们将采用割线法，这是一种用于求解此类非线性方程的成熟且通常高效的求根算法。\n\n割线法生成一个近似序列 $\\{k_i\\}_{i=0}^{\\infty}$，在适当条件下，该序列收敛于根 $k^{\\ast}$。给定两个初始点 $k_{i-1}$ 和 $k_i$，序列中的下一个点 $k_{i+1}$ 被计算为连接点 $(k_{i-1}, F(k_{i-1}))$ 和 $(k_i, F(k_i))$ 的割线与横轴交点的横坐标。迭代公式由下式给出：\n$$\nk_{i+1} = k_i - F(k_i) \\frac{k_i - k_{i-1}}{F(k_i) - F(k_{i-1})}\n$$\n计算算法如下：\n1. 使用相应测试用例中提供的值初始化前两个迭代值 $k_0$ 和 $k_1$。\n2. 计算这些点上的函数值 $F_0 = F(k_0)$ 和 $F_1 = F(k_1)$。\n3. 对于每次迭代 $i=1, 2, 3, \\dots$：\n   a. 检查分母 $F(k_i) - F(k_{i-1})$ 是否足够远离零以避免数值不稳定。如果它接近零，则方法进展停滞，应返回当前的最佳估计。\n   b. 使用割线公式计算下一个近似值 $k_{i+1}$。\n   c. 计算新的残差 $F(k_{i+1})$。\n   d. 检查收敛性：如果 $|F(k_{i+1})| \\le 10^{-10}$，算法终止，解取为 $\\widehat{k} = k_{i+1}$。\n   e. 否则，通过设置 $k_{i-1} \\leftarrow k_i$ 和 $k_i \\leftarrow k_{i+1}$ 来更新下一次迭代的迭代值。\n4. 为保证终止，设置了最大迭代次数。由于问题陈述保证了收敛性，这可作为通用实现的安全保障措施。\n\n对于每个测试用例，使用具体的参数 $(s, n, g, \\delta, \\theta, \\sigma)$ 来定义函数 $F(k)$ 的具体形式。然后，应用割线法和相应的初始值 $(k_0, k_1)$ 来找到满足容差要求的根 $\\widehat{k}$。对于所有提供的测试用例，$\\sigma$ 的值不等于 $1$，因此 $\\rho \\ne 0$，适用 CES 函数的一般形式。\n\n函数 $F(k)$ 的具体参数化如下：\n- 案例 A: $(s, n, g, \\delta, \\theta, \\sigma) = (0.200, 0.010, 0.020, 0.050, 0.400, 0.800)$。项 $(n+g+\\delta)$ 等于 $0.080$。\n- 案例 B: $(s, n, g, \\delta, \\theta, \\sigma) = (0.200, 0.010, 0.020, 0.050, 0.400, 1.500)$。项 $(n+g+\\delta)$ 等于 $0.080$。\n- 案例 C: $(s, n, g, \\delta, \\theta, \\sigma) = (0.250, 0.015, 0.020, 0.050, 0.300, 0.990)$。项 $(n+g+\\delta)$ 等于 $0.085$。\n\n以下程序实现了此数值过程，以求解每个案例的 $\\widehat{k}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the steady-state capital per efficiency unit for a set of test cases\n    using the secant method.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (s, n, g, delta, theta, sigma, k0, k1)\n    test_cases = [\n        (0.200, 0.010, 0.020, 0.050, 0.400, 0.800, 0.100, 50.000),\n        (0.200, 0.010, 0.020, 0.050, 0.400, 1.500, 0.100, 20.000),\n        (0.250, 0.015, 0.020, 0.050, 0.300, 0.990, 1.000, 10.000)\n    ]\n\n    TOLERANCE = 1e-10\n    MAX_ITER = 100\n\n    def F_residual(k, s, n, g, delta, theta, sigma):\n        \"\"\"\n        Computes the steady-state residual function F(k).\n        F(k) = s*f(k) - (n+g+delta)*k\n        \n        The function assumes k > 0.\n        \"\"\"\n        # CES production function f(k)\n        if np.isclose(sigma, 1.0):\n            # Cobb-Douglas case: f(k) = k^theta\n            # This case is included for completeness but not used by the test data.\n            f_k = np.power(k, theta)\n        else:\n            # General CES case\n            rho = (sigma - 1.0) / sigma\n            # Use numpy.power for robust floating-point exponentiation.\n            f_k = np.power(theta * np.power(k, rho) + (1.0 - theta), 1.0 / rho)\n        \n        # Effective depreciation rate, which is the slope of the break-even investment line.\n        effective_depreciation = n + g + delta\n        \n        return s * f_k - effective_depreciation * k\n\n    def secant_solver(params, k0, k1):\n        \"\"\"\n        Finds the root of F_residual using the secant method.\n        The function takes a tuple of parameters and two initial guesses.\n        \"\"\"\n        s, n, g, delta, theta, sigma = params\n        \n        k_prev, k_curr = float(k0), float(k1)\n\n        f_prev = F_residual(k_prev, s, n, g, delta, theta, sigma)\n        f_curr = F_residual(k_curr, s, n, g, delta, theta, sigma)\n        \n        for _ in range(MAX_ITER):\n            if abs(f_curr) <= TOLERANCE:\n                return k_curr\n\n            # Calculate the denominator for the secant update.\n            delta_f = f_curr - f_prev\n            \n            # If the change in function value is negligible, the method cannot proceed.\n            # Return the current best guess. This is unlikely given the problem's guarantees.\n            if np.isclose(delta_f, 0.0):\n                return k_curr\n            \n            # Secant method update formula.\n            k_next = k_curr - f_curr * (k_curr - k_prev) / delta_f\n            \n            # Update iterates for the next step.\n            k_prev, f_prev = k_curr, f_curr\n            k_curr = k_next\n            f_curr = F_residual(k_curr, s, n, g, delta, theta, sigma)\n            \n        # As per problem instructions, return the last computed value if max iterations are reached.\n        return k_curr\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and initial guesses for the solver.\n        params_tuple = case[:6]  # s, n, g, delta, theta, sigma\n        k_init_0, k_init_1 = case[6], case[7]\n        \n        # Compute the steady-state capital.\n        k_star_approx = secant_solver(params_tuple, k_init_0, k_init_1)\n        \n        # Format the result to 10 decimal places.\n        results.append(f\"{k_star_approx:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "经济分析的范畴远不止于静态的长期均衡，更核心的是理解经济体从一点到另一点的动态“转型路径”。本练习将挑战一个更高级的问题：给定一个未来的资本存量目标，我们应从怎样的初始资本水平出发？我们将学习并实践“打靶法”，这是一种精妙的算法，它将常微分方程（$ODE$）的数值积分与求根技术相结合，以解决这类重要的两点边值问题。[@problem_id:2416228]", "id": "2416228", "problem": "你的任务是编写一个完整、可运行的程序，该程序使用打靶算法数值求解人均有效资本下的连续时间 Solow 增长模型，以满足一个固定时间范围内的终端条件，而不是从一个给定的初始条件向前推进。该程序必须实现以下数学设定和要求。\n\n考虑人均有效资本 $k(t)$ 下的连续时间 Solow 模型，该模型由标准的 Solow 模型推导而来，具有 Cobb–Douglas 生产函数以及外生的人口和技术增长。设储蓄率 $s \\in (0,1)$ 为常数，资本折旧率 $\\delta \\ge 0$，人口增长率 $n \\ge 0$，技术增长率 $g \\ge 0$，人均有效产出生产函数为 $f(k) = k^{\\alpha}$ 且 $\\alpha \\in (0,1)$，则人均有效资本的运动定律为以下一阶自治常微分方程 (ODE)：\n$$\n\\frac{dk(t)}{dt} = s \\, k(t)^{\\alpha} - (n+g+\\delta)\\,k(t).\n$$\n根据其构造，对于 $t \\ge 0$ 有 $k(t) \\ge 0$。稳态 $k^{\\ast}$ 满足\n$$\n0 = s \\, (k^{\\ast})^{\\alpha} - (n+g+\\delta)\\,k^{\\ast}.\n$$\n\n你的任务是实现一个打靶算法，找到初始条件 $k(0) = k_0$，使得该 ODE 的解 $k(t)$ 在一个固定的有限时间 $T > 0$ 时满足一个终端条件：\n$$\nk(T; k_0) = \\bar{k},\n$$\n其中 $\\bar{k} > 0$ 是一个给定的目标终端人均有效资本。打靶算法必须：\n- 定义打靶函数 $\\phi(k_0) = k(T; k_0) - \\bar{k}$。\n- 对于任意给定的 $k_0$，将 ODE 从 $t=0$ 到 $t = T$ 在时间上向前进行数值积分，以评估 $k(T; k_0)$。\n- 在 $\\phi(k_0)$ 上使用一个稳健的、带区间限定的一维求根方法，以在适合双精度计算的数值公差内确定 $k_0$ 使得 $\\phi(k_0) = 0$。\n\n推导和算法设计所允许的基本依据：\n- 上述关于 $k(t)$ 且具有 Cobb–Douglas $f(k)=k^{\\alpha}$ 的运动定律。\n- 稳态的定义，ODE 右端项为 Lipschitz 连续时的解的存在性和唯一性，以及具有连续右端项的标量自治 ODE 解的单调性（保序性）。\n\n实现细节和数值要求：\n- 使用高精度 ODE 积分器。在相关情况下，应选择合适的公差以确保终端条件在很小的误差内得到满足。\n- 实现一个区间扩展策略，以确保在调用区间求根求解器之前，$\\phi(k_0)$ 的根已被置于一个区间内。你的方法必须能够防止失败，通过几何级数式地扩展区间，直到观察到符号变化或达到一个合理的上限。\n- 确保 $k(t)$ 保持非负；你必须初始化 $k_0 > 0$ 并相应地选择区间值。\n- 在为参数集计算稳态 $k^{\\ast}$ 时，注意当 $s > 0$ 和 $n+g+\\delta > 0$ 时 $k^{\\ast} > 0$，并在程序中将其表示为参数的函数，而不是在问题陈述中使用闭式解。\n\n测试套件：\n你的程序必须为以下四个参数集中的每一个计算 $k_0$。对于每种情况，目标终端资本 $\\bar{k}$ 是根据相同参数下的稳态 $k^{\\ast}$ 来指定的。所有标量必须被视为无量纲。\n\n- 情况 A (基准稳态目标):\n  - $\\alpha = 0.33$, $s = 0.25$, $n = 0.01$, $g = 0.02$, $\\delta = 0.05$, $T = 5.0$, $\\bar{k} = k^{\\ast}$。\n- 情况 B (低于稳态目标，较短时间范围):\n  - $\\alpha = 0.33$, $s = 0.25$, $n = 0.01$, $g = 0.02$, $\\delta = 0.05$, $T = 2.0$, $\\bar{k} = 0.5 \\times k^{\\ast}$。\n- 情况 C (无人口或技术增长，高于稳态目标，长时间范围):\n  - $\\alpha = 0.40$, $s = 0.15$, $n = 0.0$, $g = 0.0$, $\\delta = 0.07$, $T = 10.0$, $\\bar{k} = 1.2 \\times k^{\\ast}$。\n- 情况 D (更高储蓄率，短时间范围，略低于稳态):\n  - $\\alpha = 0.33$, $s = 0.35$, $n = 0.02$, $g = 0.01$, $\\delta = 0.04$, $T = 1.0$, $\\bar{k} = 0.9 \\times k^{\\ast}$。\n\n输出规格：\n- 对于每种情况，计算在时间 $T$ 达到终端条件所需的初始人均有效资本 $k_0$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D]。\n- 每个数字必须四舍五入到六位小数。\n- 示例格式（仅作说明）：[$1.234567$,$0.500000$,$3.210000$,$0.987654$]。\n\n约束和期望：\n- 你的解法必须是完全数值化的：不要使用 ODE 的闭式解或任何绕过数值积分和求根的变换。\n- 算法应能对所提供的参数集具有稳健性，并且在解存在的情况下能够可靠地找到 $k_0$。\n- 所有数值输出必须是浮点数。不打印百分比。不涉及角度单位。", "solution": "所提出的问题是一个描述 Solow-Swan 增长模型的一阶自治常微分方程 (ODE) 的适定两点边值问题。它在科学上基于已建立的经济学理论，在数学上是合理的。所有参数和条件都已指定，这使得解是唯一且有意义的。因此，该问题被认为是有效的。我们接下来进行数值解的推导。\n\n问题的核心是找到一个初始状态，即人均有效资本 $k(0) = k_0$，使得系统的轨迹在有限时间 $T > 0$ 到达一个指定的终端状态 $\\bar{k}$。动态由以下 ODE 控制：\n$$\n\\frac{dk(t)}{dt} = s \\, k(t)^{\\alpha} - (n+g+\\delta)\\,k(t)\n$$\n其中 $k(t) \\ge 0$，储蓄率 $s \\in (0,1)$，资本的产出弹性 $\\alpha \\in (0,1)$，有效折旧率是人口增长率 $n \\ge 0$、技术进步率 $g \\ge 0$ 和资本折旧率 $\\delta \\ge 0$ 的总和。令 $\\lambda = n+g+\\delta$。则该 ODE 为：\n$$\n\\frac{dk}{dt} = s k^{\\alpha} - \\lambda k\n$$\n问题是在方程 $k(T; k_0) = \\bar{k}$ 中求解 $k_0$，其中 $k(t; k_0)$ 表示初始条件为 $k(0)=k_0$ 的 ODE 的唯一解。\n\n这是一个边值问题，我们将按规定使用打靶算法来解决。该算法将边值问题转化为一个求根问题。我们定义一个打靶函数 $\\phi(k_0)$，其根对应于所期望的初始条件 $k_0$：\n$$\n\\phi(k_0) = k(T; k_0) - \\bar{k}\n$$\n要对一个给定的试验值 $k_0$ 评估 $\\phi(k_0)$，我们必须求解该 ODE 从 $t=0$ 到 $t=T$ 的初值问题 (IVP)。为此，需要一个高精度的数值 ODE 积分器。使用 `scipy.integrate.solve_ivp` 函数，配合如 `RK45` 或 `DOP853` 等方法，并设定足够小的相对和绝对公差（例如，分别为 $10^{-9}$ 和 $10^{-12}$）是合适的。\n\n打靶函数 $\\phi(k_0)$ 的关键性质是其单调性。对于一个标量自治 ODE $\\dot{x} = f(x)$，其中 $f$ 是 Lipschitz 连续的，其解的轨迹是有序的。如果 $x_1(0) > x_2(0)$，那么对于所有 $t > 0$ 都有 $x_1(t) > x_2(t)$。在我们的问题中，右端项 $s k^{\\alpha} - \\lambda k$ 对于 $k > 0$ 是连续可微的，因此在 $(0, \\infty)$ 的任何紧子区间上都是 Lipschitz 连续的。所以，如果我们选择两个初始条件 $k_{0,1} > k_{0,2} > 0$，对应的解将满足对于所有 $t > 0$ 都有 $k(t; k_{0,1}) > k(t; k_{0,2})$。这意味着 $k(T; k_0)$ 是一个关于 $k_0$ 的严格递增函数。因此，$\\phi(k_0)$ 也是严格递增的。一个严格单调的连续函数至多有一个根，这保证了如果解 $k_0$ 存在，它就是唯一的。\n\n为了找到这个根，我们采用一个区间求根器，如 Brent-Dekker 方法，它在 `scipy.optimize.brentq` 中可用。该方法需要一个初始区间 $[a, b]$，使得 $\\phi(a)$ 和 $\\phi(b)$ 符号相反。因此，一个稳健的区间设定策略至关重要。\n\n首先，我们确定非平凡稳态 $k^{\\ast} > 0$，在此处 $\\frac{dk}{dt} = 0$：\n$$\ns(k^{\\ast})^{\\alpha} - \\lambda k^{\\ast} = 0 \\implies s(k^{\\ast})^{\\alpha-1} = \\lambda \\implies k^{\\ast} = \\left(\\frac{s}{\\lambda}\\right)^{\\frac{1}{1-\\alpha}}\n$$\n这个稳态是所有 $k_0 > 0$ 的全局吸引子。这一性质为我们的区间设定策略提供了信息。\n存在一个平凡的特殊情况：如果目标是稳态，即 $\\bar{k} = k^{\\ast}$，那么解是显而易见的 $k_0 = k^{\\ast}$。如果 $k(0)=k^{\\ast}$，则 $\\frac{dk}{dt}=0$，所以对所有 $t$ 都有 $k(t)=k^{\\ast}$，因此 $k(T)=k^{\\ast}=\\bar{k}$。\n\n对于一般情况 $\\bar{k} \\neq k^{\\ast}$，我们分析其动态：\n1.  如果目标 $\\bar{k} < k^{\\ast}$：为了在时间 $T$ 到达 $\\bar{k}$，轨迹必须是向 $k^{\\ast}$ 演化的。如果我们从 $k_0 < k^{\\ast}$ 开始， $k(t)$ 会向 $k^{\\ast}$ 增加。为了在时间 $T$ 最终到达 $\\bar{k}$，我们必须从某个 $k_0 < \\bar{k}$ 开始。因此，根 $k_0$ 必须位于区间 $(0, \\bar{k})$ 内。这提示了一个区间，例如 $[\\epsilon, \\bar{k}]$，其中 $\\epsilon$ 是一个很小的正数。我们来测试一下：\n    - $\\phi(\\epsilon) = k(T; \\epsilon) - \\bar{k}$。由于 $k(t)$ 从接近零开始并增加， $k(T; \\epsilon)$ 会很小，所以 $\\phi(\\epsilon) < 0$。\n    - $\\phi(\\bar{k}) = k(T; \\bar{k}) - \\bar{k}$。由于 $\\bar{k} < k^{\\ast}$，所以 $\\frac{dk}{dt}|_{k=\\bar{k}} > 0$。因此，从 $\\bar{k}$ 开始的轨迹是增加的，这意味着 $k(T; \\bar{k}) > \\bar{k}$，且 $\\phi(\\bar{k}) > 0$。\n    区间 $[\\epsilon, \\bar{k}]$ 确实框定了根。\n\n2.  如果目标 $\\bar{k} > k^{\\ast}$：为了在时间 $T$ 到达 $\\bar{k}$，轨迹必须是向 $k^{\\ast}$ 演化的。如果我们从 $k_0 > k^{\\ast}$ 开始， $k(t)$ 会向 $k^{\\ast}$ 减少。为了在时间 $T$ 最终到达 $\\bar{k}$，我们必须从某个 $k_0 > \\bar{k}$ 开始。根 $k_0$ 必须位于区间 $(\\bar{k}, \\infty)$ 内。这提示了一个初始试验区间，如 $[\\bar{k}, M]$，其中 $M > \\bar{k}$。我们来测试一下：\n    - $\\phi(\\bar{k}) = k(T; \\bar{k}) - \\bar{k}$。由于 $\\bar{k} > k^{\\ast}$，所以 $\\frac{dk}{dt}|_{k=\\bar{k}} < 0$。从 $\\bar{k}$ 开始的轨迹是减少的，所以 $k(T; \\bar{k}) < \\bar{k}$，且 $\\phi(\\bar{k}) < 0$。\n    - 对于一个足够大的上界 $M$，$k(T; M)$ 也会很大，具体来说 $k(T; M) > \\bar{k}$，因此 $\\phi(M) > 0$。\n    因此，像 $[\\bar{k}, 2\\bar{k}]$ 这样的区间是一个合理的起点。\n\n为了满足问题对稳健的区间扩展策略的严格要求，我们实现了以下通用步骤：\n从一个初始区间 $[a, b]$ 开始，例如，根据上述逻辑指导。如果 $\\phi(a) \\cdot \\phi(b) \\ge 0$，则几何级数式地扩展该区间。由于 $\\phi$ 是递增的：\n- 如果 $\\phi(a) > 0$ 且 $\\phi(b) > 0$，则根小于 $a$。将区间更新为 $[a/F, a]$，其中因子 $F>1$。\n- 如果 $\\phi(a) < 0$ 且 $\\phi(b) < 0$，则根大于 $b$。将区间更新为 $[b, b \\cdot F]$。\n重复此扩展过程，直到检测到符号变化或达到最大迭代次数，以防止失败。这种系统化的方法确保了满足区间求根器的前提条件。\n\n对于每个测试用例的最终算法如下：\n1.  计算 $\\lambda = n+g+\\delta$ 和 $k^{\\ast} = (s/\\lambda)^{1/(1-\\alpha)}$。\n2.  基于 $k^{\\ast}$ 计算目标值 $\\bar{k}$。\n3.  如果 $\\bar{k} = k^{\\ast}$，则结果为 $k_0 = k^{\\ast}$。\n4.  否则，定义打靶函数 $\\phi(k_0)$，该函数内部求解 ODE 初值问题。\n5.  基于 $\\bar{k}$ 和 $k^{\\ast}$ 之间的关系建立一个初始区间 $[a, b]$。\n6.  如果这不是一个有效的区间，则迭代地扩展它，直到 $\\phi(a) \\cdot \\phi(b) < 0$。\n7.  在 $\\phi$ 上使用 `scipy.optimize.brentq`，并以找到的区间 $[a, b]$ 为参数，来找到根 $k_0$。\n8.  存储得到的 $k_0$，并四舍五入到指定精度。\n此过程将为所有提供的测试用例实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Numerically solves the continuous-time Solow growth model for the initial condition k_0\n    that results in a specific terminal condition k(T) = k_bar, using a shooting algorithm.\n    \"\"\"\n\n    # Test cases from the problem statement:\n    # (alpha, s, n, g, delta, T, k_bar_factor)\n    test_cases = [\n        (0.33, 0.25, 0.01, 0.02, 0.05, 5.0, 1.0),    # Case A\n        (0.33, 0.25, 0.01, 0.02, 0.05, 2.0, 0.5),    # Case B\n        (0.40, 0.15, 0.0,  0.0,  0.07, 10.0, 1.2),   # Case C\n        (0.33, 0.35, 0.02, 0.01, 0.04, 1.0, 0.9),    # Case D\n    ]\n\n    results = []\n    \n    # Constants for numerical methods\n    BRACKET_EXPAND_FACTOR = 2.0\n    BRACKET_MAX_ITER = 100\n    ODE_RTOL = 1e-9\n    ODE_ATOL = 1e-12\n    # A small positive number to avoid k=0 issues\n    EPSILON = 1e-9\n\n    for case in test_cases:\n        alpha, s, n, g, delta, T, k_bar_factor = case\n        \n        # Effective depreciation rate\n        lambd = n + g + delta\n        \n        # Calculate the steady state k* if it exists and is positive\n        if lambd <= 0 or s <= 0:\n            # For the given problem constraints, this branch is not taken\n            raise ValueError(\"Invalid parameters: steady state is not well-defined and positive.\")\n        \n        k_star = (s / lambd)**(1 / (1 - alpha))\n        \n        # Calculate the target terminal capital k_bar\n        k_bar = k_bar_factor * k_star\n        \n        # Special case: If target is the steady state, the solution is trivial.\n        if np.isclose(k_bar, k_star):\n            results.append(k_star)\n            continue\n            \n        # Define the right-hand side of the ODE dk/dt = s*k^alpha - lambda*k\n        def solow_ode(t, k, alpha_p, s_p, lambd_p):\n            # Ensure k is not negative, which can happen due to numerical error\n            k_val = max(k[0], 0.0)\n            return [s_p * (k_val**alpha_p) - lambd_p * k_val]\n\n        # Define the shooting function phi(k0) = k(T, k0) - k_bar\n        def shooting_function(k0):\n            if k0 <= 0:\n                # k0 must be positive. For k0->0+, k(t)->0, so phi < 0 for k_bar > 0.\n                return -k_bar\n            \n            # Solve the IVP from t=0 to T with initial condition k0\n            sol = solve_ivp(\n                fun=lambda t, y: solow_ode(t, y, alpha, s, lambd),\n                t_span=[0, T],\n                y0=[k0],\n                method='DOP853',\n                rtol=ODE_RTOL,\n                atol=ODE_ATOL\n            )\n            \n            k_T = sol.y[0, -1]\n            return k_T - k_bar\n\n        # --- Bracket finding logic ---\n        # Use model dynamics to propose an intelligent initial bracket\n        if k_bar < k_star:\n            # We expect k0 < k_bar. Root is in (0, k_bar].\n            bracket_low = EPSILON\n            bracket_high = k_bar\n        else: # k_bar > k_star\n            # We expect k0 > k_bar. Root is in (k_bar, infinity).\n            bracket_low = k_bar\n            bracket_high = k_bar * BRACKET_EXPAND_FACTOR\n            \n        val_low = shooting_function(bracket_low)\n        val_high = shooting_function(bracket_high)\n\n        # Expand bracket if root is not bracketed by the initial guess\n        for _ in range(BRACKET_MAX_ITER):\n            if val_low * val_high < 0:\n                break # Bracket found\n\n            # Since the shooting function is monotonically increasing:\n            if val_low < 0 and val_high < 0:\n                # Both points are below the root, expand to the right\n                bracket_low = bracket_high\n                bracket_high *= BRACKET_EXPAND_FACTOR\n                val_low = val_high\n                val_high = shooting_function(bracket_high)\n            elif val_low > 0 and val_high > 0:\n                # Both points are above the root, expand to the left\n                bracket_high = bracket_low\n                bracket_low /= BRACKET_EXPAND_FACTOR\n                # Ensure lower bound remains positive\n                bracket_low = max(bracket_low, EPSILON)\n                val_high = val_low\n                val_low = shooting_function(bracket_low)\n            else: # One of the ends is already the root\n                break \n        else:\n            raise RuntimeError(f\"Failed to find a bracket for case: {case}\")\n            \n        # Use a robust root-finding algorithm (Brent's method)\n        k0_solution = brentq(shooting_function, bracket_low, bracket_high)\n        results.append(k0_solution)\n\n    # Format the final output as specified\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"}]}