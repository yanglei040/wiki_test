{"hands_on_practices": [{"introduction": "许多商业决策会产生影响未来的连锁反应。本练习将探讨动态定价中的这样一种场景，即今天的价格会通过“参考价格”影响未来的消费者行为。通过从一个有限的终点向后推导，你将学习如何运用“向后归纳法”这一核心逻辑，来寻找跨时期的最优定价策略。[@problem_id:2443432]", "id": "2443432", "problem": "一家单一产品公司设定跨期价格以最大化折现利润，其中消费者根据公司最近收取的 $k$ 个价格形成参考价格。时间是离散的，周期由 $t \\in \\{1,2,\\ldots,T\\}$ 索引。在周期 $t$，公司从有限的可行集 $\\mathcal{P} = \\{0,1,2,\\ldots,10\\}$ 中选择一个价格 $p_t$。设参考价格为周期 $t$ 之前最后 $k$ 个实现价格的简单平均值，记为 $r_t = \\frac{1}{k}\\sum_{j=1}^{k} p_{t-j}$，其中样本前历史 $\\left(p_{0},p_{-1},\\ldots,p_{-(k-1)}\\right)$ 是给定的。周期 $t$ 的需求为\n$$\nq_t = \\max\\left\\{0,\\, a - b\\,p_t + \\gamma\\,(r_t - p_t)\\right\\},\n$$\n周期利润为\n$$\n\\pi_t = (p_t - c)\\,q_t.\n$$\n公司的目标是选择价格序列 $\\{p_t\\}_{t=1}^T$ 以最大化折现利润总和\n$$\n\\sum_{t=1}^{T} \\beta^{t-1}\\,\\pi_t,\n$$\n其中 $a>0$, $b>0$, $\\gamma \\ge 0$, $c \\ge 0$, $T \\in \\mathbb{N}$, $k \\in \\mathbb{N}$ 和 $\\beta \\in (0,1]$ 是给定参数。系统在周期 $t$ 开始时的状态是最后 $k$ 个实现价格的有序 $k$ 元组 $\\left(p_{t-1},p_{t-2},\\ldots,p_{t-k}\\right)$。状态转移是确定性的：选择 $p_t$ 后，下一个状态变为 $\\left(p_t,p_{t-1},\\ldots,p_{t-k+1}\\right)$。\n\n在多个利润最大化序列中，选择在最早出现平局的周期选择最小可行价格的序列。等价地，在每个周期 $t$ 和每个状态下，如果多个 $p_t \\in \\mathcal{P}$ 产生相同的最大化目标值，则选择其中最小的 $p_t$。\n\n对于下面测试套件中的每个参数化设置，计算最优价格序列 $\\{p_t^\\star\\}_{t=1}^T$。不适用任何物理单位。您的程序必须只输出一行，其中包含所有结果的聚合列表，每个内部列表按时间顺序包含该测试用例的 $T$ 个最优价格，且不含空格。例如，输出格式必须严格遵循以下形式\n$$\n[[p_1^\\star,\\ldots,p_T^\\star],[\\ldots],\\ldots].\n$$\n\n测试套件：\n- 案例1（一般情况）：$T=3$， $k=2$， $a=12$， $b=1.5$， $\\gamma=0.8$， $c=2$， $\\beta=0.95$，初始历史 $\\left(p_{0},p_{-1}\\right) = (4,6)$， $\\mathcal{P}=\\{0,1,2,\\ldots,10\\}$。\n- 案例2（单周期边界）：$T=1$， $k=3$， $a=8$， $b=1$， $\\gamma=0.5$， $c=1$， $\\beta=0.9$，初始历史 $\\left(p_{0},p_{-1},p_{-2}\\right) = (2,2,2)$， $\\mathcal{P}=\\{0,1,2,\\ldots,10\\}$。\n- 案例3（强参考效应，最小记忆）：$T=4$， $k=1$， $a=10$， $b=2$， $\\gamma=2$， $c=3$， $\\beta=0.9$，初始历史 $\\left(p_{0}\\right) = (5)$， $\\mathcal{P}=\\{0,1,2,\\ldots,10\\}$。\n\n您的程序应生成单行输出，其中包含三个最优价格序列的结果，以逗号分隔，每个序列都用方括号括起来，不含空格，并按上述案例的顺序排列。例如，所需的输出模式为\n$$\n[[\\cdot,\\cdot,\\cdot],[\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]].\n$$", "solution": "所述问题是有效的。这是一个来自计算经济学领域的适定、有限期、确定性动态规划问题，没有任何科学或逻辑缺陷。存在唯一的最优解，可以使用最优性原​​理进行计算。\n\n公司的目标是找到一个价格序列 $\\{p_t\\}_{t=1}^T$ 来最大化总折现利润。这个问题可以使用动态规划来解决，为此我们定义以下标准组件。\n\n1.  **状态**：系统在周期 $t$ 开始时的状态必须封装所有与未来决策相关的过去信息。在此模型中，未来的利润取决于下一个参考价格，而参考价格又取决于最近的价格历史。因此，时间 $t$ 的状态是最后 $k$ 个价格的有序 $k$ 元组，$S_t = (p_{t-1}, p_{t-2}, \\ldots, p_{t-k})$。状态空间是离散且有限的，由 $|\\mathcal{P}|^k$ 个可能的状态组成，其中 $|\\mathcal{P}| = 11$。\n\n2.  **行动**：在每个周期 $t$，公司选择一个行动，即价格 $p_t$。可行行动的集合是有限集 $\\mathcal{P} = \\{0, 1, 2, \\ldots, 10\\}$。\n\n3.  **回报函数**：周期 $t$ 的回报是利润 $\\pi_t$。该利润取决于当前状态 $S_t$（它决定了参考价格 $r_t$）和所选行动 $p_t$。参考价格为 $r_t = \\frac{1}{k}\\sum_{j=1}^{k} p_{t-j}$。利润函数为 $\\pi_t(S_t, p_t) = (p_t - c)q_t$，其中需求为 $q_t = \\max\\{0, a - bp_t + \\gamma(r_t - p_t)\\}$。这可以重写为 $q_t = \\max\\{0, a + \\gamma r_t - (b+\\gamma)p_t\\}$。\n\n4.  **状态转移**：系统是确定性的。如果时间 $t$ 的状态是 $S_t = (p_{t-1}, \\ldots, p_{t-k})$ 且公司选择价格 $p_t$，则时间 $t+1$ 的状态变为 $S_{t+1} = (p_t, p_{t-1}, \\ldots, p_{t-k+1})$。\n\n设 $V_t(S_t)$ 为在状态为 $S_t$ 的情况下，从周期 $t$ 到期末 $T$ 的最大折现利润。最优性原理通过 Bellman 方程表示：\n$$\nV_t(S_t) = \\max_{p_t \\in \\mathcal{P}} \\left\\{ \\pi_t(S_t, p_t) + \\beta V_{t+1}(S_{t+1}) \\right\\}\n$$\n对于 $t=1, \\ldots, T$。终端条件是在周期 $T$ 之后没有未来利润，因此对于任何状态 $S$，都有 $V_{T+1}(S) = 0$。\n\n该问题通过后向归纳法在算法上求解：\n\n1.  **初始化（周期 $t=T$）：** 我们从最后一个周期 $T$ 开始。对于每个可能的状态 $S_T = (p_{T-1}, \\ldots, p_{T-k})$，我们求解最优价格 $p_T^*(S_T)$:\n    $$\n    V_T(S_T) = \\max_{p_T \\in \\mathcal{P}} \\{ \\pi_T(S_T, p_T) \\}\n    $$\n    我们计算每个 $p_T \\in \\mathcal{P}$ 的利润，并找到产生最大利润的价格。平局打破规则规定，如果多个价格产生相同的最大值，我们必须选择最小的价格。我们将此最优价格存储在策略函数 $\\Pi_T(S_T) = p_T^*(S_T)$ 中，并将相应的最大值存储在值函数 $V_T(S_T)$ 中。对状态空间中的所有可能状态都执行此操作。\n\n2.  **递归步骤（周期 $t = T-1, \\ldots, 1$）：** 我们一次向后推一个周期。对于每个周期 $t$ 和每个状态 $S_t$，我们通过求解 Bellman 方程来找到最优价格 $p_t^*(S_t)$:\n    $$\n    V_t(S_t) = \\max_{p_t \\in \\mathcal{P}} \\left\\{ \\pi_t(S_t, p_t) + \\beta V_{t+1}((p_t, p_{t-1}, \\ldots, p_{t-k+1})) \\right\\}\n    $$\n    对于每个候选价格 $p_t \\in \\mathcal{P}$，我们计算即时利润 $\\pi_t(S_t, p_t)$ 并加上折现的未来价值 $\\beta V_{t+1}(S_{t+1})$，其中未来价值 $V_{t+1}$ 已经在归纳法的前一步中计算出来。最大化此总和的价格 $p_t$ 被选为最优策略 $\\Pi_t(S_t)$，同样要遵守平局打破规则。最大化的总和被存储为 $V_t(S_t)$。\n\n3.  **最优路径重构：** 后向归纳完成后，我们得到了所有 $t \\in \\{1, \\ldots, T\\}$ 和所有状态 $S_t$ 的最优策略 $\\Pi_t(S_t)$。为了找到最优价格序列，我们执行一次前向传递：\n    - 从给定的初始状态 $S_1 = (p_0, p_{-1}, \\ldots, p_{-(k-1)})$ 开始。\n    - 第一个最优价格是 $p_1^* = \\Pi_1(S_1)$。\n    - 下一个周期的状态是 $S_2 = (p_1^*, p_0, \\ldots, p_{-(k-2)})$。\n    - 第二个最优价格是 $p_2^* = \\Pi_2(S_2)$。\n    - 重复此过程直到 $t=T$，从而得到最优价格序列 $\\{p_1^*, p_2^*, \\ldots, p_T^*\\}$。\n\n该算法通过使用字典将状态元组映射到其值和最优策略来实现。每个周期的有限状态空间是通过将可行价格集 $\\mathcal{P}$ 与自身进行 $k$ 次笛卡尔积生成的。", "answer": "```python\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to solve the dynamic pricing problem for all test cases\n    and print the results in the specified format.\n    \"\"\"\n\n    def solve_case(T, k, a, b, gamma, c, beta, initial_history):\n        \"\"\"\n        Solves a single instance of the dynamic pricing problem using backward induction.\n        \"\"\"\n        P_set = list(range(11))\n        \n        # The state is a tuple of the last k prices.\n        # Handle k=0 case for generality, though problem states k>=1.\n        all_states = list(product(P_set, repeat=k)) if k > 0 else [()]\n        \n        # V: Value function memoization table, V[t][state] = max_profit\n        # policy: Policy function table, policy[t][state] = optimal_price\n        V = {}\n        policy = {}\n\n        # Initialize value function at the terminal time T+1 to zero.\n        V[T + 1] = {s: 0.0 for s in all_states}\n\n        # Backward induction from T down to 1\n        for t in range(T, 0, -1):\n            V[t] = {}\n            policy[t] = {}\n            for state in all_states:\n                # state = (p_{t-1}, ..., p_{t-k})\n                r_t = np.mean(state) if k > 0 else 0.0\n                \n                # Evaluate the value for each possible price p_t\n                p_values = {}\n                for p_t in P_set:\n                    q_t = max(0, a + gamma * r_t - (b + gamma) * p_t)\n                    profit_t = (p_t - c) * q_t\n                    \n                    next_state = (p_t,) + state[:-1] if k > 0 else ()\n                    \n                    # Bellman equation\n                    value = profit_t + beta * V[t + 1][next_state]\n                    p_values[p_t] = value\n                \n                # Find the maximum value among all possible prices\n                max_value = -float('inf')\n                for p_t in P_set:\n                    if p_values[p_t] > max_value:\n                        max_value = p_values[p_t]\n\n                # Find the smallest price that achieves the maximum value (tie-breaking)\n                best_p = -1\n                for p_t in P_set:\n                    if np.isclose(p_values[p_t], max_value):\n                        best_p = p_t\n                        break\n                \n                V[t][state] = max_value\n                policy[t][state] = best_p\n\n        # Forward pass to reconstruct the optimal price path\n        optimal_path = []\n        current_state = initial_history\n        for t in range(1, T + 1):\n            optimal_p = policy[t][current_state]\n            optimal_path.append(optimal_p)\n            current_state = (optimal_p,) + current_state[:-1] if k > 0 else ()\n\n        return optimal_path\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'T': 3, 'k': 2, 'a': 12, 'b': 1.5, 'gamma': 0.8, 'c': 2, 'beta': 0.95, 'initial_history': (4, 6)},\n        {'T': 1, 'k': 3, 'a': 8, 'b': 1, 'gamma': 0.5, 'c': 1, 'beta': 0.9, 'initial_history': (2, 2, 2)},\n        {'T': 4, 'k': 1, 'a': 10, 'b': 2, 'gamma': 2, 'c': 3, 'beta': 0.9, 'initial_history': (5,)},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = solve_case(**params)\n        results.append(result)\n\n    # Format the output string exactly as required, with no spaces.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "当我们面临如燃料或氧气等有限资源时，应如何找到最佳路径？本练习模拟了这样一个挑战，要求你在一个网格上航行，同时最小化能源消耗并遵守氧气预算。你将发现扩展状态空间的必要性——不仅通过位置来定义状态，还要包括已消耗的资源——这是解决带约束的动态优化问题的基石。[@problem_id:2443368]", "id": "2443368", "problem": "一辆载具必须在离散网格上确定一条最优路径，以最小化一个累加能量准则，同时受限于一个累积氧气资源约束。所有量均为无量纲标量。环境是一个矩形网格，索引为 $(i,j)$，其中 $i \\in \\{0,\\dots,N-1\\}$ 且 $j \\in \\{0,\\dots,M-1\\}$，每个网格单元都有一个非负深度值 $D_{i,j}$。从任何单元 $(i,j)$ 出发，载具可以单步离散地移动到其四个轴对齐邻居 $(i \\pm 1,j)$ 或 $(i,j \\pm 1)$ 中的任何一个，前提是该邻居仍在网格内。从 $(i,j)$ 到邻居 $(i',j')$ 的一步会产生能量成本 $c_{E}(i',j') = \\alpha + \\beta \\, D_{i',j'}$ 和氧气消耗 $c_{O}(i',j') = \\mu + \\nu \\, D_{i',j'}$，其中 $\\alpha,\\beta,\\mu,\\nu$ 是给定的非负参数。一条路径是一个有限的网格单元序列 $(x_{0},x_{1},\\dots,x_{L})$，其中 $x_{0} = s$（起点）且 $x_{L} = g$（终点），每个 $x_{\\ell+1}$ 都是 $x_{\\ell}$ 的一个有效邻居。目标是最小化总能量 $\\sum_{\\ell=0}^{L-1} c_{E}(x_{\\ell+1})$，同时满足氧气约束 $\\sum_{\\ell=0}^{L-1} c_{O}(x_{\\ell+1}) \\leq O_{\\max}$，其中 $O_{\\max}$ 是一个给定的非负整数。如果不存在可行路径，则该实例是不可行的。\n\n形式上，给定 $D \\in \\mathbb{R}_{\\ge 0}^{N \\times M}$，参数 $\\alpha,\\beta,\\mu,\\nu \\in \\mathbb{R}_{\\ge 0}$，一个整数氧气预算 $O_{\\max} \\in \\mathbb{Z}_{\\ge 0}$，以及网格坐标 $s=(i_{s},j_{s})$，$g=(i_{g},j_{g})$，计算最小能量值\n$$\nE^{\\star} \\;=\\; \\min_{(x_{0},\\dots,x_{L})} \\;\\sum_{\\ell=0}^{L-1} \\big(\\alpha + \\beta \\, D_{x_{\\ell+1}}\\big)\n\\quad\\text{subject to}\\quad x_{0}=s,\\; x_{L}=g,\\; x_{\\ell+1}\\in \\mathcal{N}(x_{\\ell}),\n\\;\\sum_{\\ell=0}^{L-1} \\big(\\mu + \\nu \\, D_{x_{\\ell+1}}\\big) \\le O_{\\max},\n$$\n其中 $\\mathcal{N}(i,j)=\\{(i\\pm 1,j),(i,j\\pm 1)\\}$ 与网格的交集，而 $D_{x}$ 表示在单元 $x$ 处求值的 $D$。如果不存在可行路径，则定义 $E^{\\star}=+\\infty$。\n\n您的程序必须解决以下测试套件中的实例，并输出一行包含每个实例的最小能量列表，格式为浮点数，使用 $+\\infty$ 表示不可行：\n\n- 测试用例 $\\mathbf{A}$：\n  - 网格大小 $N = 4$，$M = 4$，深度矩阵为\n    $$\n    D^{(A)} \\;=\\;\n    \\begin{bmatrix}\n    4 & 3 & 4 & 5\\\\\n    5 & 2 & 2 & 3\\\\\n    6 & 4 & 1 & 2\\\\\n    7 & 5 & 3 & 1\n    \\end{bmatrix}.\n    $$\n  - 参数：$\\alpha = 1$，$\\beta = 1$，$\\mu = 1$，$\\nu = 0$。\n  - 起点 $s=(0,0)$，终点 $g=(3,3)$，氧气预算 $O_{\\max}=7$。\n\n- 测试用例 $\\mathbf{B}$：与测试用例 $\\mathbf{A}$ 相同，除了氧气预算 $O_{\\max}=6$。\n\n- 测试用例 $\\mathbf{C}$：与测试用例 $\\mathbf{A}$ 相同，除了氧气预算 $O_{\\max}=5$。\n\n- 测试用例 $\\mathbf{D}$：\n  - 网格大小 $N = 4$，$M = 4$，深度矩阵为\n    $$\n    D^{(D)} \\;=\\;\n    \\begin{bmatrix}\n    5 & 5 & 5 & 5\\\\\n    5 & 1 & 1 & 5\\\\\n    5 & 1 & 5 & 5\\\\\n    5 & 1 & 1 & 1\n    \\end{bmatrix}.\n    $$\n  - 参数：$\\alpha = 1$，$\\beta = 2$，$\\mu = 1$，$\\nu = 1$。\n  - 起点 $s=(0,0)$，终点 $g=(3,3)$，氧气预算 $O_{\\max}=24$。\n\n输出格式要求：\n- 您的程序应生成单行输出，其中包含按 $\\mathbf{A},\\mathbf{B},\\mathbf{C},\\mathbf{D}$ 顺序排列的结果，格式为方括号内的逗号分隔列表，例如 `\"[e_{A},e_{B},e_{C},e_{D}]\"`，其中每个 $e_{\\cdot}$ 是一个浮点数，不可行性由浮点常量 $+\\infty$ 表示。", "solution": "用户提供了一个问题陈述，在尝试解决之前需要进行验证。\n\n### 第 1 步：提取已知条件\n- **网格环境**：一个大小为 $N \\times M$ 的离散网格，单元格为 $(i,j)$，其中 $i \\in \\{0, \\dots, N-1\\}$ 且 $j \\in \\{0, \\dots, M-1\\}$。每个单元格都有一个非负深度 $D_{i,j}$。\n- **载具动态特性**：移动仅限于四个轴对齐的邻居。移动到单元格 $(i', j')$ 会产生能量成本 $c_{E}(i',j') = \\alpha + \\beta D_{i',j'}$ 和氧气成本 $c_{O}(i',j') = \\mu + \\nu D_{i',j'}$。\n- **参数**：$\\alpha, \\beta, \\mu, \\nu$ 是非负实数。\n- **目标**：对于从起点 $s$ 到终点 $g$ 的路径 $(x_0, \\dots, x_L)$，最小化总能量 $\\sum_{\\ell=0}^{L-1} c_{E}(x_{\\ell+1})$。\n- **约束**：总氧气消耗不得超过给定的非负整数预算 $O_{\\max}$，即 $\\sum_{\\ell=0}^{L-1} c_{O}(x_{\\ell+1}) \\le O_{\\max}$。\n- **不可行性**：如果不存在满足约束的路径，则最小能量定义为 $+\\infty$。\n- **测试用例**：提供了四个具体实例（A, B, C, D），定义了网格大小、深度矩阵 $D$、成本参数、起点/终点坐标和氧气预算 $O_{\\max}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是图上的一个约束最短路径问题 (CSPP)。这是计算机科学、运筹学及相关学科中一个基础且经过充分研究的课题。其表述在数学上是严谨的，并基于离散优化的既定原则。该问题在科学上是合理的。\n2.  **适定性**：状态空间（网格）是有限的，并且由于参数和深度的非负性，所有移动成本都是非负的。这避免了可能使最短路径问题变得不适定的负成本环路等问题。对于给定的测试用例，氧气成本是整数，氧气预算 $O_{\\max}$ 也是整数，这使得动态规划方法的状态空间是离散且有限的。存在唯一的最小能量值，或者可以证明不存在可行路径。该问题是适定的。\n3.  **客观性**：该问题是用精确的数学定义和客观的数值数据来表述的。它不含主观或模棱两可的语言。\n4.  **完整性与一致性**：为每个测试用例提供了解决问题所需的所有数据（网格维度、深度、参数、起点/终点、预算）。问题陈述中没有矛盾之处。\n5.  **现实性与可行性**：该问题是一个抽象的优化模型。其组成部分（网格、成本、约束）是标准的，不代表任何科学上不合理或物理上不可能的条件。\n6.  **结构性**：问题结构良好，不包含循环论证或歧义。使用 $+\\infty$ 表示不可行性是一种标准惯例。\n7.  **相关性**：该问题是动态规划的一个应用，与最优化原理直接相关，而最优化原理是计算经济学中解决约束条件下序贯决策问题的核心概念。\n\n### 第 3 步：结论与行动\n此问题有效。将提供一个解决方案。\n\n### 解法推导\n该问题是在一个网格中寻找一条路径，该路径在满足第二个累积成本（氧气）有上限约束的条件下，最小化第一个累积成本（能量）。这是约束最短路径问题的经典实例。虽然 CSPP 在一般情况下是 NP-难问题，但所提供测试用例中氧气成本的整数性质，允许使用动态规划这种伪多项式时间解法来解决，而动态规划正是最优化原理的一种体现。\n\n最优化原理指出，一个最优策略具有这样的特性：无论初始状态和初始决策是什么，余下的决策相对于由第一个决策导致的状态，也必须构成一个最优策略。在我们的问题中，到达具有特定氧气消耗量的单元格 $(i,j)$ 的最优路径，是由一条到达某个邻近单元格且氧气消耗量相应较低的最优路径，再跟上一个最优单步移动组成的。\n\n这表明我们系统中的状态不能仅由网格位置 $(i,j)$ 来定义。到达 $(i,j)$ 所经过的路径很重要，因为它决定了消耗的氧气量。因此，我们扩展状态以包含已消耗的资源。令一个状态由元组 $(i, j, o)$ 表示，意为载具位于单元格 $(i,j)$ 且已消耗了 $o$ 单位的氧气。\n\n令 $E[i, j, o]$ 为到达状态 $(i,j,o)$ 所需的最小能量。我们的目标是计算 $\\min_{0 \\le o \\le O_{\\max}} E[i_g, j_g, o]$，其中 $(i_g, j_g)$ 是终点单元格 $g$ 的坐标。\n\n我们可以通过改编 Dijkstra 算法来解决此问题，以在扩展的状态空间图上找到最短路径。该图的节点是状态 $(i, j, o)$，路径的“长度”是其总能量成本。\n\n算法流程如下：\n1.  **初始化**：我们使用一个三维数组 `min_energy[N][M][O_max + 1]` 来存储每个状态的最小能量 $E[i, j, o]$。所有条目都初始化为 $+\\infty$。对于起始单元格 $s=(i_s, j_s)$，我们设置 `min_energy[i_s][j_s][0] = 0$，因为到达起点需要零能量且消耗零氧气。初始化一个优先队列 `pq`，其中包含起始状态：`(energy=0, i=i_s, j=j_s, oxygen=0)`。\n\n2.  **迭代**：算法反复从优先队列中提取具有最小能量 $e$ 的状态 $(e, i, j, o)$。如果此能量 $e$ 大于已知的到达状态 $(i,j,o)$ 的最小能量，我们将其丢弃，因为它代表一条次优路径。否则，我们探索单元格 $(i,j)$ 的所有有效邻居 $(i', j')$。\n\n3.  **状态转移（松弛）**：对于每个邻居 $(i', j')$，我们计算增量成本：\n    - 能量成本：$\\Delta E = \\alpha + \\beta D_{i',j'}$\n    - 氧气成本：$\\Delta O = \\mu + \\nu D_{i',j'}$\n    新状态将是 $(i', j', o + \\Delta O)$，总能量为 $e + \\Delta E$。\n\n4.  **约束与更新**：我们检查新的总氧气 $o' = o + \\Delta O$ 是否超过预算 $O_{\\max}$。如果超过，则此路径不可行，予以忽略。否则，如果新的总能量 $e' = e + \\Delta E$ 小于 `min_energy[i'][j'][o']` 的当前值，我们就找到了到达状态 $(i', j', o')$ 的一条更优路径。我们更新 `min_energy[i'][j'][o'] = e'$，并将新状态 $(e', i', j', o')$ 添加到优先队列中。\n\n5.  **终止与结果**：当优先队列为空时，算法终止。到达终点单元格 $g=(i_g, j_g)$ 的最小能量则是 `min_energy[i_g][j_g][o]` 在所有可能的氧气水平 $o \\in \\{0, \\dots, O_{\\max}\\}$ 上的最小值。如果该最小值仍为 $+\\infty$，则表示在给定的氧气预算内无法到达终点。\n\n该算法的计算复杂度由在扩展状态空间上运行的 Dijkstra 算法决定。状态数量为 $N \\times M \\times (O_{\\max} + 1)$，每个状态最多有 4 个转移。复杂度为 $O(N \\cdot M \\cdot O_{\\max} \\cdot \\log(N \\cdot M \\cdot O_{\\max}))$，对于所提供测试用例的规模而言是高效的。", "answer": "```python\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and print results for all test cases.\n    \"\"\"\n\n    def solve_case(N, M, D, alpha, beta, mu, nu, s, g, O_max):\n        \"\"\"\n        Solves a single instance of the constrained shortest path problem.\n\n        This function uses a Dijkstra-like algorithm on an expanded state space,\n        where a state is defined by (row, column, oxygen_consumed). The priority\n        queue stores tuples of (energy, row, col, oxygen), ordered by energy.\n        \"\"\"\n        # min_energy[i, j, o] stores the minimum energy to reach cell (i, j)\n        # having consumed exactly 'o' units of oxygen.\n        min_energy = np.full((N, M, O_max + 1), np.inf, dtype=np.float64)\n\n        start_i, start_j = s\n        goal_i, goal_j = g\n\n        # Initial state: at the start cell with 0 energy and 0 oxygen consumed.\n        min_energy[start_i, start_j, 0] = 0.0\n        \n        # Priority queue stores tuples of (energy, i, j, oxygen_consumed).\n        # It's ordered by energy to always expand the path with the lowest energy first.\n        pq = [(0.0, start_i, start_j, 0)]\n\n        while pq:\n            energy, i, j, o = heapq.heappop(pq)\n\n            # If we've already found a better path to this state, skip.\n            if energy > min_energy[i, j, o]:\n                continue\n\n            # Explore the four axis-aligned neighbors.\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n\n                # Check if the neighbor is within the grid boundaries.\n                if 0 <= ni < N and 0 <= nj < M:\n                    # Costs are incurred upon entering the new cell (ni, nj).\n                    energy_step = alpha + beta * D[ni, nj]\n                    oxygen_step = mu + nu * D[ni, nj]\n\n                    # For this problem, oxygen costs are guaranteed to be integers.\n                    oxygen_step_int = int(oxygen_step)\n\n                    new_energy = energy + energy_step\n                    new_oxygen = o + oxygen_step_int\n\n                    # If the path is feasible (within oxygen budget) and improves\n                    # upon a known path to the new state, update and push to queue.\n                    if new_oxygen <= O_max:\n                        if new_energy < min_energy[ni, nj, new_oxygen]:\n                            min_energy[ni, nj, new_oxygen] = new_energy\n                            heapq.heappush(pq, (new_energy, ni, nj, new_oxygen))\n\n        # The final minimum energy is the minimum over all possible oxygen\n        # levels at the goal cell.\n        result = np.min(min_energy[goal_i, goal_j, :])\n        return float(result)\n\n    # Test Case A\n    D_A = np.array([[4, 3, 4, 5], [5, 2, 2, 3], [6, 4, 1, 2], [7, 5, 3, 1]])\n    params_A = (1, 1, 1, 0)\n    s_A, g_A = (0, 0), (3, 3)\n    O_max_A = 7\n    res_A = solve_case(4, 4, D_A, *params_A, s_A, g_A, O_max_A)\n\n    # Test Case B (identical to A, but O_max = 6)\n    O_max_B = 6\n    res_B = solve_case(4, 4, D_A, *params_A, s_A, g_A, O_max_B)\n\n    # Test Case C (identical to A, but O_max = 5)\n    O_max_C = 5\n    res_C = solve_case(4, 4, D_A, *params_A, s_A, g_A, O_max_C)\n\n    # Test Case D\n    D_D = np.array([[5, 5, 5, 5], [5, 1, 1, 5], [5, 1, 5, 5], [5, 1, 1, 1]])\n    params_D = (1, 2, 1, 1)\n    s_D, g_D = (0, 0), (3, 3)\n    O_max_D = 24\n    res_D = solve_case(4, 4, D_D, *params_D, s_D, g_D, O_max_D)\n\n    results = [res_A, res_B, res_C, res_D]\n    \n    # Format the final output as a comma-separated list in brackets.\n    # The `str` function correctly handles `np.inf` by converting it to 'inf'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "并非所有决策都有一个固定的终点；有时我们必须决定何时停止寻找更好的选项。这个经典的最优停止问题模拟了在无限时间范围内接受或拒绝连续出现机会的选择。通过这个练习，你将应用稳态贝尔曼方程（stationary Bellman equation）来推导一个不随时间改变的最优策略，这是一个在经济学和金融学中至关重要的、简单而强大的阈值规则。[@problem_id:2443380]", "id": "2443380", "problem": "一位基金经理面临一个无限期动态选择问题，该问题模拟了序贯的投资机会。时间是离散的，周期由 $t \\in \\{0,1,2,\\dots\\}$ 索引。在每个周期 $t$，恰好有一个投资机会到来，其质量为 $X_{t}$，其中 $\\{X_{t}\\}$ 是一个独立同分布的序列，其共同密度函数在 $[0,1]$ 上为 $f(x)=1$，在其他情况下为 $f(x)=0$。在观察到 $X_{t}$ 后，经理必须要么接受该机会并不可撤销地停止，获得等于 $X_{t}$（以现值衡量）的即时回报，要么拒绝它并继续到下一个周期。未来的回报按每个周期 $\\delta \\in (0,1)$ 的贴现因子进行贴现。没有召回机制：被拒绝的机会以后不能再被接受。经理的目标是最大化所接受回报的期望现值。\n\n确定最优接受阈值 $\\tau^{\\ast}$ 作为 $\\delta$ 的函数的精确封闭式表达式，使得当且仅当 $X_{t} \\ge \\tau^{\\ast}$ 时，在一个周期内接受是​​最优的。\n\n请用一个关于 $\\delta$ 的解析表达式给出你的最终答案。不需要数值近似或四舍五入。", "solution": "用户提供了一个问题陈述。我现在将进行验证。\n\n**第1步：提取已知条件**\n- **问题类型**：无限期动态选择问题。\n- **时间**：离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。\n- **投资机会**：每个周期一个，质量为 $X_{t}$。\n- **$X_t$ 的分布**：$\\{X_{t}\\}$ 是一个独立同分布（i.i.d.）序列，其共同概率密度函数（PDF）在 $x \\in [0,1]$ 上为 $f(x)=1$，在其他情况下为 $f(x)=0$。这是一个在 $[0,1]$ 上的均匀分布。\n- **决策规则**：在每个周期 $t$，观察到 $X_{t}$ 后，经理必须要么接受并停止，要么拒绝并继续。\n- **回报结构**：接受将产生 $X_{t}$ 的即时回报。\n- **贴现因子**：未来的回报按每个周期 $\\delta \\in (0,1)$ 的贴现因子进行贴现。\n- **约束**：没有对被拒绝机会的召回机制。\n- **目标**：最大化所接受回报的期望现值。\n- **任务**：确定最优接受阈值 $\\tau^{\\ast}$ 作为 $\\delta$ 的函数。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据**：该问题是一个经典的最优停止问题，是动态规划、运筹学和经济学中的一个基本课题。它是一个被称为“卖房问题”或“秘书问题”变体的成熟模型。其构架建立在标准的概率论和优化原理之上。\n- **适定性**：该问题是适定的。独立同分布过程的平稳性以及带有贴现的无限期 horizons 确保了唯一、平稳的最优策略的存在。目标函数定义清晰，所有必要的参数（分布、贴现因子）都已提供。\n- **客观性**：该问题以客观、精确的数学语言陈述，没有歧义或主观论断。\n- **完备性与一致性**：该问题是自洽且内部一致的。没有缺少推导最优策略所需的信息，也没有相互矛盾的约束。\n- **可行性**：该设置是一个标准的理论模型，在其数学框架内是完全可行的。\n- **与主题相关性**：该问题是在金融/经济决策问题背景下对最优性原理的直接应用，完全属于计算经济学和金融学的指定领域。\n\n**第3步：结论与行动**\n问题有效。我将继续进行解答。\n\n该问题描述了一个无限期、离散时间的最优停止问题。问题的平稳性（机会 $X_t$ 的分布和贴现因子 $\\delta$ 不随时间变化）意味着最优策略也将是平稳的。这意味着存在一个单一的、不随时间变化的阈值 $\\tau^{\\ast}$，它决定了每个周期的最优决策。\n\n设 $V$ 为在任何周期开始时，在得知该周期投资机会质量 $X_t$ 之前，可以获得的最大期望现值。由于平稳性，$V$ 是一个常数。\n\n在任何周期 $t$，经理观察到一个质量为 $X_t = x$ 的机会。经理有两个选择：\n$1$. **接受**：过程终止，经理获得回报 $x$。\n$2$. **拒绝**：经理放弃回报 $x$ 并继续到下一个周期。从周期 $t$ 的角度看，继续的期望价值是以最优方式开始下一周期的贴现值，即 $\\delta V$。\n\n最优性原理指出，经理会选择使期望回报最大化的行动。因此，在观察到 $x$ 时，获得的值为 $\\max(x, \\delta V)$。\n\n价值函数 $V$ 是此结果在 $X_t$ 所有可能实现上的期望值。随机变量 $X_t$ 在 $[0,1]$ 上均匀分布，其PDF为 $f(x)=1$。因此，$V$ 的贝尔曼方程为：\n$$V = \\mathbb{E}[\\max(X_t, \\delta V)] = \\int_{-\\infty}^{\\infty} \\max(x, \\delta V) f(x) dx = \\int_{0}^{1} \\max(x, \\delta V) dx$$\n\n项 $\\max(x, \\delta V)$ 的结构定义了最优策略。如果 $x \\ge \\delta V$，则接受报价是​​最优的；如果 $x < \\delta V$，则拒绝是​​最优的。这证实了存在一个最优阈值，该阈值由 $\\tau^{\\ast} = \\delta V$ 给出。\n\n我们现在可以通过在阈值 $\\delta V$ 处分割积分来求解 $V$ 的积分方程。注意，由于 $X_t \\in [0,1]$ 和 $\\delta \\in (0,1)$，必然有 $V \\le 1$，这意味着 $\\delta V < 1$。阈值 $\\delta V$ 在积分区间 $[0,1]$ 内。\n$$V = \\int_{0}^{\\delta V} (\\delta V) dx + \\int_{\\delta V}^{1} x dx$$\n\n我们计算每个积分：\n第一个积分是：\n$$\\int_{0}^{\\delta V} (\\delta V) dx = \\delta V [x]_{0}^{\\delta V} = \\delta V (\\delta V - 0) = \\delta^2 V^2$$\n\n第二个积分是：\n$$\\int_{\\delta V}^{1} x dx = \\left[ \\frac{x^2}{2} \\right]_{\\delta V}^{1} = \\frac{1^2}{2} - \\frac{(\\delta V)^2}{2} = \\frac{1}{2} - \\frac{\\delta^2 V^2}{2}$$\n\n将这些代回 $V$ 的方程中：\n$$V = \\delta^2 V^2 + \\left( \\frac{1}{2} - \\frac{\\delta^2 V^2}{2} \\right)$$\n$$V = \\frac{1}{2}\\delta^2 V^2 + \\frac{1}{2}$$\n\n这是一个关于 $V$ 的二次方程。整理成标准形式 $aV^2 + bV + c = 0$：\n$$\\frac{1}{2}\\delta^2 V^2 - V + \\frac{1}{2} = 0$$\n乘以 2 以消去分数得到：\n$$\\delta^2 V^2 - 2V + 1 = 0$$\n\n我们使用二次公式 $V = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 求解 $V$：\n$$V = \\frac{-(-2) \\pm \\sqrt{(-2)^2 - 4(\\delta^2)(1)}}{2\\delta^2}$$\n$$V = \\frac{2 \\pm \\sqrt{4 - 4\\delta^2}}{2\\delta^2} = \\frac{2 \\pm 2\\sqrt{1 - \\delta^2}}{2\\delta^2}$$\n$$V = \\frac{1 \\pm \\sqrt{1 - \\delta^2}}{\\delta^2}$$\n\n这给出了 $V$ 的两个潜在解。我们必须选择在经济上有效的那一个。价值 $V$ 代表了来自受 $1$ 限制的机会的期望回报，因此必须有 $V \\le 1$。\n\n让我们考察当 $\\delta \\to 0$ 时这两个根：\n$1$. $V_1 = \\frac{1 + \\sqrt{1 - \\delta^2}}{\\delta^2}$。当 $\\delta \\to 0^+$ 时，分子趋近于 $1 + \\sqrt{1} = 2$，而分母趋近于 $0$。因此，$V_1 \\to \\infty$。这不是一个有经济意义的解。\n$2$. $V_2 = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2}$。当 $\\delta \\to 0^+$ 时，我们得到一个不定式 $0/0$。我们可以使用洛必达法则（L'Hôpital's rule）或通过乘以其共轭表达式来使分子有理化：\n$$V_2 = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2} \\times \\frac{1 + \\sqrt{1 - \\delta^2}}{1 + \\sqrt{1 - \\delta^2}} = \\frac{1 - (1 - \\delta^2)}{\\delta^2(1 + \\sqrt{1 - \\delta^2})} = \\frac{\\delta^2}{\\delta^2(1 + \\sqrt{1 - \\delta^2})} = \\frac{1}{1 + \\sqrt{1 - \\delta^2}}$$\n现在，取 $\\delta \\to 0^+$ 的极限：\n$$\\lim_{\\delta \\to 0^+} V_2 = \\frac{1}{1 + \\sqrt{1 - 0}} = \\frac{1}{2}$$\n这个结果是合理的：如果未来的回报毫无价值（$\\delta=0$），最优策略是接受第一个机会 $X_0$。其期望回报则为 $\\mathbb{E}[X_0] = \\int_0^1 x dx = 1/2$。\n此外，对于 $\\delta \\in (0,1)$，我们有 $0 \\le \\sqrt{1-\\delta^2} < 1$，所以 $V_2 = \\frac{1}{1 + \\sqrt{1-\\delta^2}}$ 位于区间 $[1/2, 1)$ 内，满足条件 $V \\le 1$。\n\n因此，正确的价值函数是：\n$$V = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2}$$\n\n问题要求的是最优接受阈值 $\\tau^{\\ast}$。如前所述，$\\tau^{\\ast} = \\delta V$。\n代入 $V$ 的表达式：\n$$\\tau^{\\ast} = \\delta \\cdot V = \\delta \\left( \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2} \\right)$$\n$$\\tau^{\\ast} = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta}$$\n\n这就是最优接受阈值的精确封闭式表达式。", "answer": "$$\\boxed{\\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta}}$$"}]}