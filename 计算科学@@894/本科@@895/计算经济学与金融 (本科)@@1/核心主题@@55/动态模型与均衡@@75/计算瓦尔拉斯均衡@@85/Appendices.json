{"hands_on_practices": [{"introduction": "我们的实践始于最基本的构建模块：单一市场中的局部均衡。这个练习将指导您计算供给与需求曲线相交所决定的瓦尔拉斯均衡价格与数量。在此基础上，我们将引入一个常见的政策干预——价格下限，并量化其对市场效率的影响，即计算由此产生的无谓损失（deadweight loss）[@problem_id:2382188]。这不仅能巩固您的基础理论，还能让您掌握将微观经济模型转化为代码并进行初步政策分析的核心技能。", "id": "2382188", "problem": "考虑一个嵌入在双商品经济体中的单一商品竞争市场，其中存在一种计价物商品，其价格被标准化为 $1$。该市场商品的反需求函数为 $P_{d}(Q) = a - b\\,Q$（其中 $a > 0$ 且 $b > 0$），反供给函数为 $P_{s}(Q) = c + d\\,Q$（其中 $c \\ge 0$ 且 $d > 0$）。数量必须为非负值，即 $Q \\ge 0$。该市场中的瓦尔拉斯均衡 (WE) 是指一个价格 $p^{\\ast}$ 和一个数量 $Q^{\\ast} \\ge 0$，使得市场出清：$P_{d}(Q^{\\ast}) = P_{s}(Q^{\\ast}) = p^{\\ast}$。如果需求和供给的唯一交点出现在负数量处，则有效率的瓦尔拉斯均衡是无交易配置 $Q^{\\ast} = 0$。\n\n现在，为该市场商品引入一个价格下限 $\\bar{p} \\ge 0$，以计价物商品的单位表示。价格下限下的实际交易数量由以下规则确定：如果该下限相对于有效率的瓦尔拉斯均衡价格不具约束力，则市场在有效率的瓦尔拉斯均衡 $(p^{\\ast},Q^{\\ast})$ 下进行交易；如果该下限具有约束力，则交易数量等于价格 $\\bar{p}$ 下的市场短边，即 $Q^{\\text{tr}} = \\min\\{Q_{d}(\\bar{p}), Q_{s}(\\bar{p})\\}$，其中 $Q_{d}(p) = \\max\\{0, (a - p)/b\\}$ 和 $Q_{s}(p) = \\max\\{0, (p - c)/d\\}$ 是由价格 $p$ 引起的非负需求量和供给量。将价格下限造成的无谓损失 (DWL) 定义为相对于有效率的瓦尔拉斯均衡的总剩余损失，即净边际收益 $P_{d}(Q) - P_{s}(Q)$ 在从价格下限下的交易数量到有效率的瓦尔拉斯均衡数量的区间上的积分：\n$$\n\\text{DWL} = \\int_{Q^{\\text{tr}}}^{Q^{\\ast}} \\big(P_{d}(Q) - P_{s}(Q)\\big)\\,dQ,\n$$\n并约定如果 $Q^{\\text{tr}} \\ge Q^{\\ast}$，则无谓损失为 $0$。\n\n您的任务是编写一个程序，对于下面列出的每个测试用例，计算出有效率的瓦尔拉斯均衡数量 $Q^{\\ast}$、价格下限下的交易数量 $Q^{\\text{tr}}$ 以及如上文定义的无谓损失 $\\text{DWL}$。所有计算都必须如规定一样假定数量为非负值。无需报告物理单位。\n\n测试套件：\n- 测试用例 1：$(a,b,c,d,\\bar{p}) = (10,1,2,1,7)$。\n- 测试用例 2：$(a,b,c,d,\\bar{p}) = (10,1,2,1,5)$。\n- 测试用例 3：$(a,b,c,d,\\bar{p}) = (10,1,2,1,6)$。\n- 测试用例 4：$(a,b,c,d,\\bar{p}) = (12,1,0,1,15)$。\n- 测试用例 5：$(a,b,c,d,\\bar{p}) = (3,1,5,1,4)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于上述顺序的每个测试用例，按顺序输出三元组 $(Q^{\\ast},Q^{\\text{tr}},\\text{DWL})$。将所有测试用例的这些三元组合并成一个扁平列表。例如，输出形式应为\n$[Q^{\\ast}_{1},Q^{\\text{tr}}_{1},\\text{DWL}_{1},Q^{\\ast}_{2},Q^{\\text{tr}}_{2},\\text{DWL}_{2},\\dots]$。", "solution": "所述问题是有效的。这是一个适定且有科学依据的微观经济学理论练习，特别是关于市场均衡和价格管制福利效应的分析。定义、参数和目标都以足够的数学精度进行了陈述，问题没有矛盾或逻辑缺陷。我们可以进行形式化的求解。\n\n任务是为几组参数计算有效率的瓦尔拉斯均衡数量 ($Q^{\\ast}$)、价格下限下的交易数量 ($Q^{\\text{tr}}$)，以及由此产生的无谓损失 (DWL)。推导过程分为三个阶段。\n\n**阶段 1：确定有效率的瓦尔拉斯均衡数量 ($Q^{\\ast}$)**\n\n瓦尔拉斯均衡数量在市场出清点找到，即需求量等于供给量之处。这对应于反需求曲线和反供给曲线的交点，前提是数量为非负。\n反需求函数为 $P_{d}(Q) = a - b\\,Q$，反供给函数为 $P_{s}(Q) = c + d\\,Q$。我们令 $P_{d}(Q) = P_{s}(Q)$：\n$$ a - b\\,Q = c + d\\,Q $$\n求解 $Q$ 可得到交点处的数量，我们将其表示为 $Q_{\\text{int}}$：\n$$ a - c = (b + d)Q $$\n$$ Q_{\\text{int}} = \\frac{a - c}{b + d} $$\n问题规定数量必须为非负 ($Q \\ge 0$)。如果 $a \\le c$，则对于 $Q > 0$，需求曲线完全位于供给曲线下方（如果 $c>a$，则从较低的价格截距开始；如果 $c=a$，则从相同的截距开始）。在这种情况下，$Q_{\\text{int}} \\le 0$，在有效率的市场中不会发生交易。问题陈述正确地将此“无交易配置”识别为有效率的结果。因此，有效率的均衡数量 $Q^{\\ast}$ 是交点数量的非负部分：\n$$ Q^{\\ast} = \\max\\left\\{0, \\frac{a - c}{b + d}\\right\\} $$\n如果 $Q^{\\ast} > 0$，则相应的均衡价格 $p^{\\ast}$ 可以通过将 $Q^{\\ast}$ 代入反需求或反供给函数中求得：\n$$ p^{\\ast} = P_{d}(Q^{\\ast}) = a - b\\left(\\frac{a - c}{b + d}\\right) = \\frac{a(b+d) - b(a-c)}{b+d} = \\frac{ad + bc}{b + d} $$\n\n**阶段 2：确定价格下限下的交易数量 ($Q^{\\text{tr}}$)**\n\n价格下限 $\\bar{p}$ 是监管者设定的最低价格。其效果取决于它是否“具有约束力”。\n\n情况 1：有效率的均衡中无交易 ($Q^{\\ast} = 0$)。\n这种情况发生在 $a \\le c$ 时。由于任何消费者愿意支付的最高价格 ($a$) 小于或等于任何供应商愿意接受的最低价格 ($c$)，因此不可能发生自愿交易。价格下限 $\\bar{p}$ 无法促成非互利的交易。在任何价格 $\\bar{p}$下，需求量或供给量（或两者）都将为零。因此，如果 $Q^{\\ast} = 0$，则交易数量 $Q^{\\text{tr}}$ 也必须为零。\n\n情况 2：有效率的均衡中有正交易量 ($Q^{\\ast} > 0$)。\n在这种情况下，存在一个均衡价格 $p^{\\ast} = (ad+bc)/(b+d)$。\n- 如果 $\\bar{p} \\le p^{\\ast}$，价格下限不具约束力。它被设定在市场自然达到的价格或以下。市场在有效率的均衡下进行交易，因此 $Q^{\\text{tr}} = Q^{\\ast}$。\n- 如果 $\\bar{p} > p^{\\ast}$，价格下限具有约束力。市场价格被强制推高至 $\\bar{p}$。在这个更高的价格下，存在过剩：供应商希望出售的数量 $Q_{s}(\\bar{p})$ 超过了消费者希望购买的数量 $Q_{d}(\\bar{p})$。交易由市场的“短边”决定，即需求方。交易数量为：\n$$ Q^{\\text{tr}} = Q_{d}(\\bar{p}) = \\max\\left\\{0, \\frac{a - \\bar{p}}{b}\\right\\} $$\n由于 $\\bar{p} > p^{\\ast}$ 且 $p^{\\ast} = a - bQ^{\\ast}$，因此 $\\bar{p} > a - bQ^{\\ast}$，这意味着 $bQ^{\\ast} > a - \\bar{p}$，所以 $Q^{\\ast} > (a-\\bar{p})/b$。因此，一个有约束力的价格下限总是导致交易数量 $Q^{\\text{tr}}$ 严格小于有效率的数量 $Q^{\\ast}$。\n\n**阶段 3：计算无谓损失 (DWL)**\n\n无谓损失是由于市场在非有效率水平的数量下运行而导致的总剩余损失。它由以下积分定义：\n$$ \\text{DWL} = \\int_{Q^{\\text{tr}}}^{Q^{\\ast}} \\big(P_{d}(Q) - P_{s}(Q)\\big)\\,dQ $$\n被积函数是消费者边际收益与生产者边际成本之差：\n$$ P_{d}(Q) - P_{s}(Q) = (a - bQ) - (c + dQ) = (a - c) - (b + d)Q $$\n当 $Q^{\\ast} > 0$ 时，我们有 $a - c = (b+d)Q^{\\ast}$。将此代入被积函数可得：\n$$ P_{d}(Q) - P_{s}(Q) = (b+d)Q^{\\ast} - (b+d)Q = (b+d)(Q^{\\ast} - Q) $$\n现在我们可以计算这个积分：\n$$ \\text{DWL} = \\int_{Q^{\\text{tr}}}^{Q^{\\ast}} (b+d)(Q^{\\ast} - Q)\\,dQ = (b+d)\\left[ Q^{\\ast}Q - \\frac{1}{2}Q^2 \\right]_{Q^{\\text{tr}}}^{Q^{\\ast}} $$\n$$ \\text{DWL} = (b+d)\\left( \\left( (Q^{\\ast})^2 - \\frac{1}{2}(Q^{\\ast})^2 \\right) - \\left( Q^{\\ast}Q^{\\text{tr}} - \\frac{1}{2}(Q^{\\text{tr}})^2 \\right) \\right) $$\n$$ \\text{DWL} = \\frac{1}{2}(b+d)(Q^{\\ast} - Q^{\\text{tr}})^2 $$\n这个公式代表了一个三角形的面积。三角形的高是数量的减少量 $Q^{\\ast} - Q^{\\text{tr}}$，底是在受限数量下的价格差距 $P_{d}(Q^{\\text{tr}}) - P_{s}(Q^{\\text{tr}})$。该公式在 $Q^{\\ast} > 0$ 时成立。如果 $Q^{\\ast}=0$，那么 $Q^{\\text{tr}}=0$，DWL 正确地计算为 $0$。如果价格下限不具约束力，则 $Q^{\\text{tr}}=Q^{\\ast}$，DWL 也正确地计算为 $0$。该问题的约定，即如果 $Q^{\\text{tr}} \\ge Q^{\\ast}$ 则 DWL 为 $0$，被此公式自然满足，因为我们的逻辑确保了 $Q^{\\text{tr}} \\le Q^{\\ast}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the efficient Walrasian equilibrium quantity (Q*),\n    the traded quantity under a price floor (Q_tr), and the\n    deadweight loss (DWL) for a series of market parameter sets.\n    \"\"\"\n    # Test cases are provided as tuples of (a, b, c, d, p_bar)\n    # P_d(Q) = a - b*Q\n    # P_s(Q) = c + d*Q\n    # p_bar is the price floor\n    test_cases = [\n        (10, 1, 2, 1, 7),\n        (10, 1, 2, 1, 5),\n        (10, 1, 2, 1, 6),\n        (12, 1, 0, 1, 15),\n        (3, 1, 5, 1, 4),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, c, d, p_bar = case\n\n        # Stage 1: Determination of the Efficient Walrasian Equilibrium Quantity (Q*)\n        # The efficient quantity Q* is the non-negative part of the intersection\n        # of the supply and demand curves.\n        q_star = np.maximum(0.0, (a - c) / (b + d))\n\n        # Stage 2: Determination of the Traded Quantity Under the Price Floor (Q_tr)\n        if q_star > 0:\n            # An efficient equilibrium with positive trade exists.\n            # Calculate the equilibrium price p* to check if the floor is binding.\n            p_star = (a * d + b * c) / (b + d)\n            \n            if p_bar <= p_star:\n                # The price floor is not binding. The market trades at the efficient equilibrium.\n                q_tr = q_star\n            else:\n                # The price floor is binding. Trade is determined by the short side of\n                # the market, which is demand at price p_bar.\n                q_tr = np.maximum(0.0, (a - p_bar) / b)\n        else:\n            # The efficient equilibrium is no-trade (Q* = 0). A price floor\n            # cannot induce trade, so the traded quantity remains zero.\n            q_tr = 0.0\n\n        # Stage 3: Calculation of Deadweight Loss (DWL)\n        # DWL arises from the reduction in quantity traded below the efficient level.\n        # The formula is 0.5 * (b+d) * (Q* - Q_tr)^2.\n        # It is non-zero only if q_tr < q_star.\n        if q_tr < q_star:\n            dwl = 0.5 * (b + d) * (q_star - q_tr)**2\n        else:\n            dwl = 0.0\n\n        # Append the calculated triplet to the master list of results.\n        results.extend([q_star, q_tr, dwl])\n\n    # Final print statement in the exact required format.\n    # The list is flattened, and elements are converted to strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "真实经济由许多相互关联的市场组成，因此我们需将视野从局部均衡扩展到一般均衡。这个练习将我们带入一个简单的阿罗-德布鲁（Arrow-Debreu）世界，您将为一个包含生产和消费的微型经济体寻找均衡[@problem_id:2382212]。您的任务是设计一个算法，以确定均衡价格，使得在生产可能性边界（Production Possibility Frontier）上，厂商的利润最大化供给恰好等于消费者的效用最大化需求。", "id": "2382212", "problem": "考虑一个 Arrow–Debreu 竞争经济模型，其中有一个消费者，该消费者拥有一家公司。这家公司可以使用一组有限的线性技术和一个单一的产能约束来生产两种消费品，从而形成一个分段线性的生产可能性边界 (PPF)。所有市场仅涉及这两种消费品；不存在要素市场。消费者的偏好为严格正的柯布-道格拉斯偏好。您将计算一个瓦尔拉斯均衡 (WE)，其定义为一个价格向量和一个配置。在此均衡下，给定价格，公司在可行生产集内实现利润最大化；消费者在预算集内实现效用最大化，其收入等于完全分配给消费者的公司利润；并且两种商品的市场均出清。\n\n基本原理：\n- 消费者的需求是通过在预算约束下最大化柯布-道格拉斯效用得到的。\n- 公司的供给是通过在由单一资源产能约束下混合可用线性技术生成的凸可行生产集上最大化利润得到的。\n- 瓦尔拉斯均衡 (WE) 是一组价格和配置，它同时满足个体最优性和市场出清条件。\n\n经济设定：\n- 存在两种商品。公司拥有一组有限的可用技术，以 $k \\in \\{1,\\dots,K\\}$ 为索引。每种技术 $k$ 将一单位通用的、固定的、不可交易的产能转化为一个净产出向量 $a_k = (a_{k1}, a_{k2}) \\in \\mathbb{R}_{+}^2$。设总产能为 $\\bar{L} > 0$。公司选择非负的活动水平 $x_k \\ge 0$ 且满足 $\\sum_{k=1}^K x_k \\le \\bar{L}$，以生产 $y = \\sum_{k=1}^K x_k a_k$。\n- 单个消费者的效用函数为 $u(c_1,c_2) = c_1^{\\alpha} c_2^{1-\\alpha}$，其中 $\\alpha \\in (0,1)$，消费向量为 $c = (c_1,c_2)$。该消费者拥有公司 100% 的所有权，没有其他禀赋，因此其收入等于公司利润。\n\n价格：\n- 设价格向量为 $p = (p_1,p_2) \\in \\mathbb{R}_{++}^2$。不失一般性，我们将 $p_1$ 标准化为 $p_1 = 1$，并记 $p_2 = q$，其中 $q > 0$。\n\n编程挑战：\n- 对下面的每一组参数，计算一个瓦尔拉斯均衡。您的程序必须确定一个价格比率 $q$ 和一个在分段线性 PPF 上的生产计划 $y = (y_1,y_2)$，该计划在消费者以公司在该价格下的利润为收入进行优化时能够使市场出清。您的计算必须基于上述基本原理。该经济体是单一消费者和单一公司的；因此，对于下面的测试实例，存在一个 WE，其中价格被标准化为 $p_1 = 1$ 和 $p_2 = q$。\n\n测试集（三个独立案例）：\n- 案例 A:\n  - 技术：$a_1 = (2.0, 0.5)$, $a_2 = (1.0, 1.2)$, $a_3 = (0.3, 2.0)$。\n  - 产能：$\\bar{L} = 10$。\n  - 偏好权重：$\\alpha = 0.5$。\n- 案例 B:\n  - 技术：$a_1 = (1.2, 0.3)$, $a_2 = (0.9, 0.9)$。\n  - 产能：$\\bar{L} = 5$。\n  - 偏好权重：$\\alpha = 0.9$。\n- 案例 C:\n  - 技术：$a_1 = (1.0, 0.4)$, $a_2 = (0.2, 1.3)$。\n  - 产能：$\\bar{L} = 12$。\n  - 偏好权重：$\\alpha = 0.1$。\n\n计算要求与验收检查：\n- 利用公司在给定价格 $q$ 下，在受产能约束的可用技术凸包上进行利润最大化，以产生一个利润最大化的产出 $y$（允许技术混合）。\n- 利用消费者在价格 $(1,q)$ 和收入等于公司利润的条件下，根据其柯布-道格拉斯需求函数得到消费 $c$。\n- 通过要求两个坐标上都满足 $c = y$ 来强制市场出清；如果在价格 $(1,q)$ 下，利润最大化集合包含多种最优技术，您必须选择一个能够（如果可行的话）使市场出清的凸组合。\n- 您的算法必须具有通用性，适用于任何满足上述结构的、包含两种商品的有限技术集。\n\n最终输出：\n- 对每个案例，输出三元组 $[q,y_1,y_2]$，其中 $q$ 是当 $p_1 = 1$ 时的均衡价格比率，$(y_1,y_2)$ 是均衡的生产/消费向量。所有三个数字必须是四舍五入到六位小数的浮点数值。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的三元组列表，这些三元组被方括号括起来，并按案例 A、案例 B、案例 C 的顺序排列。例如：$[[q_A,y_{A1},y_{A2}],[q_B,y_{B1},y_{B2}],[q_C,y_{C1},y_{C2}]]$。\n- 不涉及物理单位。\n- 您的程序必须是自包含的，并且不需要任何输入。它必须实现上述逻辑，并为给定的测试集生成指定的单行输出。每个案例的答案必须是如上定义包含三个浮点数的列表。", "solution": "所提出的问题是在单一消费者、单一公司的 Arrow-Debreu 经济中计算瓦尔拉斯均衡的一个适定实例。它在科学上基于成熟的微观经济理论，并提供了一套完整、一致的参数。因此，可以从第一性原理推导出一个严谨的解决方案。\n\n该经济体包含两种商品，索引为 $1$ 和 $2$。将商品 $1$ 的价格标准化为 $p_1 = 1$，则价格向量为 $p = (1, q)$，其中 $q = p_2 > 0$ 是商品 $2$ 的相对价格。\n\n分析的核心基于三大支柱：公司行为、消费者行为和市场出清。\n\n**1. 公司利润最大化**\n\n公司拥有一组 $K$ 种线性生产技术。每种技术 $k$ 由向量 $a_k = (a_{k1}, a_{k2})$ 表示，该向量将一单位单一的、不可交易的资源（产能）转化为一揽子商品。在总产能为 $\\bar{L}$ 的情况下，公司为每种技术选择活动水平 $x_k \\ge 0$，并受产能约束 $\\sum_{k=1}^K x_k \\le \\bar{L}$ 的限制。由此产生的生产向量为 $y = (y_1, y_2) = \\sum_{k=1}^K x_k a_k$。所有可行生产向量的集合构成了生产可能性集合 (PPS)，它是一个凸多胞体。其右上边界是生产可能性边界 (PPF)。\n\n公司的目标是最大化利润，$\\pi = p \\cdot y = y_1 + q y_2$。代入 $y$ 的表达式：\n$$\n\\pi(q) = \\max_{\\{x_k\\}} \\sum_{k=1}^K x_k (a_{k1} + q a_{k2}) \\quad \\text{subject to} \\quad \\sum_{k=1}^K x_k \\le \\bar{L}, \\quad x_k \\ge 0.\n$$\n为了最大化这个线性目标，公司会将其全部产能 $\\bar{L}$ 分配给能产生最高单位产能收益 $r_k(q) = a_{k1} + q a_{k2}$ 的技术 $k^*$。\n- 如果存在唯一的技术 $k^*$ 使得 $r_k(q)$ 最大化，公司将进行专业化生产，生产点位于 PPF 的一个顶点：$y^S(q) = \\bar{L} a_{k^*}$。\n- 如果两种技术（例如 $k_i$ 和 $k_j$）产生相同的最大收益，即 $a_{i1} + q a_{i2} = a_{j1} + q a_{j2}$，则这两种技术的任何凸组合都是最优的。这对应于在连接点 $\\bar{L} a_i$ 和 $\\bar{L} a_j$ 的 PPF 的一个面（线段）上进行生产。发生这种情况时的价格比率 $q$ 由技术本身决定：\n$$\nq = - \\frac{a_{j1} - a_{i1}}{a_{j2} - a_{i2}}\n$$\n这个 $q$ 值是连接 $\\bar{L} a_i$ 和 $\\bar{L} a_j$ 的 PPF 线段斜率的负倒数。\n\n**2. 消费者效用最大化**\n\n单个消费者具有柯布-道格拉斯偏好，其效用函数为 $u(c_1, c_2) = c_1^{\\alpha} c_2^{1-\\alpha}$，其中 $\\alpha \\in (0,1)$。该消费者拥有公司，没有其他收入来源。因此，消费者的收入 $I$ 就是公司的利润，$I = \\pi$。预算约束为 $c_1 + q c_2 = \\pi$。\n\n在预算约束下最大化柯布-道格拉斯效用，可以得到著名的需求函数：\n$$\nc_1 = \\frac{\\alpha I}{p_1} = \\alpha \\pi\n$$\n$$\nc_2 = \\frac{(1-\\alpha) I}{p_2} = \\frac{(1-\\alpha) \\pi}{q}\n$$\n这些需求的一个关键特性是，两种商品上的支出比率是恒定的：\n$$\n\\frac{p_2 c_2}{p_1 c_1} = \\frac{q c_2}{c_1} = \\frac{1-\\alpha}{\\alpha}\n$$\n这等价于边际替代率 (MRS) 等于价格比率：$\\text{MRS} = \\frac{\\partial u / \\partial c_1}{\\partial u / \\partial c_2} = \\frac{\\alpha}{1-\\alpha}\\frac{c_2}{c_1} = \\frac{p_1}{p_2} = \\frac{1}{q}$。\n\n**3. 市场出清与瓦尔拉斯均衡**\n\n在均衡状态下，市场必须出清，在这个单一消费者的经济体中，这意味着消费等于生产：$c = y$。设均衡配置为 $y^* = (y_1^*, y_2^*)$。该配置必须位于 PPF 上，并满足消费者的最优性条件。将 $y^*$ 代入消费者的最优性条件，可以建立均衡配置与均衡价格比率 $q^*$ 之间的直接联系：\n$$\n\\frac{q^* y_2^*}{y_1^*} = \\frac{1-\\alpha}{\\alpha} \\quad \\implies \\quad q^* = \\frac{1-\\alpha}{\\alpha} \\frac{y_1^*}{y_2^*}\n$$\n均衡是一对 $(q^*, y^*)$，它同时满足公司利润最大化和市场出清条件。这意味着在均衡配置 $y^*$ 处，消费者无差异曲线的斜率必须等于 PPF 的斜率，并且两者都必须等于价格比率的负值，即 $-1/q^*$。\n\n**算法方法**\n\n该算法通过系统地检查均衡配置在 PPF 上的两种可能位置来确定均衡：在顶点上或在线段上。\n\n**情况 1：均衡位于 PPF 顶点**\n如果在一个顶点 $y^* = \\bar{L} a_k$ 处，由该点的消费者最优性所隐含的价格比率 $q^*$ 使得公司发现专业化于技术 $k$ 是最优的，那么均衡就发生在该顶点。\n1. 对于给定的技术 $k$，定义潜在的均衡点 $y^* = \\bar{L} a_k$。\n2. 计算能使消费者选择该点的价格比率：$q^* = \\frac{1-\\alpha}{\\alpha} \\frac{y_1^*}{y_2^*}$。\n3. 验证在此价格 $q^*$ 下，技术 $k$ 是否确实是利润最高的。如果对于所有其他技术 $j=1,\\ldots,K$ 都满足 $r_k(q^*) \\ge r_j(q^*)$，则此条件成立。如果该条件成立，则找到了一个均衡。\n\n**情况 2：均衡位于 PPF 线段上**\n如果公司对两种技术 $a_i$ 和 $a_j$ 无差异，并且由此产生的消费点位于连接 $\\bar{L} a_i$ 和 $\\bar{L} a_j$ 的线段上，那么均衡就发生在该线段上。\n1. 对于一对技术 $(i, j)$，计算使公司无差异的唯一价格比率：$q^* = -(a_{j1}-a_{i1})/(a_{j2}-a_{i2})$。我们只考虑 $q^* > 0$ 的技术对。\n2. 通过检查在此价格 $q^*$ 下没有其他技术 $k$ 具有严格更高的利润，来验证这对技术是否确实构成了 PPF 的一条边。\n3. 如果这对技术构成了一条边，则通过找到消费者的需求射线 $y_2 = \\left(\\frac{1-\\alpha}{\\alpha}\\frac{1}{q^*}\\right) y_1$ 与由 $\\bar{L}a_i$ 和 $\\bar{L}a_j$ 定义的线段的交点，来确定消费点 $(y_1^*, y_2^*)$。\n4. 如果这个交点落在线段的边界之内，则找到了一个均衡。\n\n这种系统性搜索保证能为指定的经济结构找到唯一的均衡。实现过程将遍历所有技术和技术对，以确定每个测试集符合这两种情况中的哪一种。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_equilibrium(technologies: list[tuple[float, float]], L_bar: float, alpha: float) -> list[float]:\n    \"\"\"\n    Computes the Walrasian equilibrium for a single-consumer, single-firm economy.\n\n    Args:\n        technologies: A list of (good1, good2) output tuples per unit of capacity.\n        L_bar: Total capacity.\n        alpha: The consumer's preference parameter for good 1 in the Cobb-Douglas utility.\n\n    Returns:\n        A list containing the equilibrium price ratio [q] and allocation [y1, y2].\n    \"\"\"\n    techs = np.array(technologies, dtype=np.float64)\n    num_techs = len(techs)\n    \n    # Consumer's expenditure ratio from utility maximization\n    if alpha == 0 or alpha == 1:\n        raise ValueError(\"alpha must be in (0,1)\")\n    expenditure_ratio = (1 - alpha) / alpha\n    \n    # Epsilon for robust floating-point comparisons\n    epsilon = 1e-9\n\n    # Case 1: Check for equilibrium at a vertex (specialization in one technology)\n    for i in range(num_techs):\n        y = L_bar * techs[i]\n        y1, y2 = y[0], y[1]\n\n        # Cobb-Douglas implies interior solution, so y1 and y2 must be positive.\n        if y1 < epsilon or y2 < epsilon:\n            continue\n\n        # Price ratio q implied by consumer choosing point y\n        q_consumer = expenditure_ratio * (y1 / y2)\n\n        # Check if firm would choose technology i at this price q\n        revenue_i = techs[i, 0] + q_consumer * techs[i, 1]\n        is_optimal_for_firm = True\n        for j in range(num_techs):\n            if i == j:\n                continue\n            revenue_j = techs[j, 0] + q_consumer * techs[j, 1]\n            if revenue_j > revenue_i + epsilon:\n                is_optimal_for_firm = False\n                break\n        \n        if is_optimal_for_firm:\n            return [q_consumer, y1, y2]\n\n    # Case 2: Check for equilibrium on a segment (diversification between two technologies)\n    for i in range(num_techs):\n        for j in range(i + 1, num_techs):\n            tech_i = techs[i]\n            tech_j = techs[j]\n\n            # Price ratio q implied by firm's indifference between tech i and j\n            # a_i1 + q*a_i2 = a_j1 + q*a_j2  => q*(a_i2 - a_j2) = a_j1 - a_i1\n            delta_a2 = tech_i[1] - tech_j[1]\n            if abs(delta_a2) < epsilon:\n                continue  # Technologies have same good 2 output, can't solve for q this way\n\n            delta_a1 = tech_j[0] - tech_i[0]\n            q_firm = delta_a1 / delta_a2\n\n            if q_firm < epsilon:\n                continue  # Price must be positive\n\n            # Check if this pair (i,j) constitutes an edge of the PPF at this price\n            revenue_ij = tech_i[0] + q_firm * tech_i[1]\n            is_ppf_edge = True\n            for k in range(num_techs):\n                if k == i or k == j:\n                    continue\n                revenue_k = techs[k, 0] + q_firm * techs[k, 1]\n                if revenue_k > revenue_ij + epsilon:\n                    is_ppf_edge = False\n                    break\n            \n            if not is_ppf_edge:\n                continue\n\n            # If it is an edge, find the market-clearing allocation on this segment\n            y_i = L_bar * tech_i\n            y_j = L_bar * tech_j\n            \n            # Slope of the PPF segment\n            if abs(y_j[0] - y_i[0]) < epsilon:\n                continue # Vertical segment\n            m_seg = (y_j[1] - y_i[1]) / (y_j[0] - y_i[0])\n\n            # Slope of the consumer's demand ray\n            m_ray = expenditure_ratio / q_firm\n\n            if abs(m_ray - m_seg) < epsilon:\n                continue # Parallel lines, no unique intersection\n\n            # Find intersection of the two lines\n            # y = m_ray * x\n            # y - y_i[1] = m_seg * (x - y_i[0])\n            # m_ray*x - y_i[1] = m_seg*x - m_seg*y_i[0]\n            # (m_ray - m_seg)*x = y_i[1] - m_seg*y_i[0]\n            y1_eq = (y_i[1] - m_seg * y_i[0]) / (m_ray - m_seg)\n            y2_eq = m_ray * y1_eq\n\n            # Check if the intersection point lies on the segment\n            y1_min = min(y_i[0], y_j[0])\n            y1_max = max(y_i[0], y_j[0])\n            \n            if y1_min - epsilon <= y1_eq <= y1_max + epsilon:\n                return [q_firm, y1_eq, y2_eq]\n                \n    # This part should not be reached given the problem guarantees a solution exists.\n    return []\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'id': 'A', 'techs': [(2.0, 0.5), (1.0, 1.2), (0.3, 2.0)], 'L_bar': 10.0, 'alpha': 0.5},\n        # Case B\n        {'id': 'B', 'techs': [(1.2, 0.3), (0.9, 0.9)], 'L_bar': 5.0, 'alpha': 0.9},\n        # Case C\n        {'id': 'C', 'techs': [(1.0, 0.4), (0.2, 1.3)], 'L_bar': 12.0, 'alpha': 0.1},\n    ]\n\n    results = []\n    for case in test_cases:\n        eq = compute_equilibrium(case['techs'], case['L_bar'], case['alpha'])\n        if eq:\n            results.append(eq)\n\n    # Format the final output string as per requirements\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "在最后的练习中，我们将挑战一个更贴近现实的复杂模型：一个包含非线性税收的经济体。诸如累进所得税这类政策会使预算约束变得复杂，导致均衡通常没有解析解，而必须通过数值方法寻找[@problem_id:2382171]。您将把均衡问题构建为一个不动点问题，并使用数值求解器来找到一个所有个体决策与政府收支都相互一致的状态。掌握这种方法是现代计算经济学中分析复杂政策影响的核心能力。", "id": "2382171", "problem": "考虑一个交换生产经济体，该经济体中有一种消费品，每个代理人拥有时间禀赋。有$2$个代理人，索引为 $i \\in \\{1,2\\}$。每个代理人 $i$ 选择消费 $c_i \\ge 0$ 和闲暇 $\\ell_i \\in [0,1]$。劳动供给为 $h_i = 1 - \\ell_i \\in [0,1]$。唯一的消费品由总劳动通过线性技术 $y = h_1 + h_2$ 生产。消费品的价格归一化为$1$，税前工资为 $w = 1$。政府根据以下函数对每个代理人的劳动收入征收累进所得税\n$$\nT(I) = \\theta I + \\kappa \\max\\{0, I - I_0\\}^2,\n$$\n其中 $\\theta \\in [0,1)$、$\\kappa \\ge 0$ 和 $I_0 \\ge 0$ 是参数，$I$ 表示代理人的劳动收入。税收收入以等额一次性总付转移支付的形式返还给两个代理人，因此人均转移支付为\n$$\n\\tau = \\frac{1}{2}\\left(T(w h_1) + T(w h_2)\\right).\n$$\n给定转移支付 $\\tau$，代理人 $i$ 的预算约束为\n$$\nc_i \\le w h_i - T(w h_i) + \\tau,\n$$\n其偏好由效用函数表示\n$$\nu_i(c_i,\\ell_i) = \\alpha_i \\ln c_i + (1 - \\alpha_i) \\ln \\ell_i,\n$$\n其中 $\\alpha_i \\in (0,1)$。\n\n一个带税的竞争性均衡是一个三元组 $(h_1^\\ast,h_2^\\ast,\\tau^\\ast)$，满足：对于每个 $i \\in \\{1,2\\}$，在给定 $\\tau^\\ast$ 的情况下，选择 $h_i^\\ast \\in [0,1]$ 可以解决代理人在预算约束以及消费和闲暇非负性约束下的效用最大化问题，并且政府预算是平衡的，即 $\\tau^\\ast = \\frac{1}{2}\\left(T(h_1^\\ast)+T(h_2^\\ast)\\right)$。商品市场出清 $c_1^\\ast + c_2^\\ast = y^\\ast$ 必须成立，其中 $y^\\ast = h_1^\\ast + h_2^\\ast$，这是由可行性和政府预算平衡所隐含的。价格归一化为$1$，所有量均为无量纲量。\n\n你的任务是编写一个完整的程序，对下面测试套件中的每一组参数，计算带税的竞争性均衡，并输出均衡向量 $[h_1^\\ast,h_2^\\ast,\\tau^\\ast]$，其中每个条目四舍五入到$6$位小数。对于每个测试用例，代理人的最优消费等于所选劳动供给下预算约束的右侧，即 $c_i^\\ast = w h_i^\\ast - T(w h_i^\\ast) + \\tau^\\ast$，且 $\\ell_i^\\ast = 1 - h_i^\\ast$。\n\n测试套件（每行是一个测试用例，指定 $(\\alpha_1,\\alpha_2,\\theta,\\kappa,I_0)$）：\n- 情况 A（基线对称偏好和累进税）：$(0.5, 0.5, 0.2, 0.3, 0.5)$。\n- 情况 B（非对称偏好和相同税收）：$(0.3, 0.7, 0.2, 0.3, 0.5)$。\n- 情况 C（更强的累进税）：$(0.5, 0.5, 0.4, 0.6, 0.3)$。\n- 情况 D（无税基准）：$(0.5, 0.5, 0.0, 0.0, 0.0)$。\n- 情况 E（单一税基准）：$(0.8, 0.2, 0.1, 0.0, 0.0)$。\n\n对于每个测试用例，你的程序必须计算带税的竞争性均衡，并生成向量 $[h_1^\\ast,h_2^\\ast,\\tau^\\ast]$，四舍五入到$6$位小数。你的程序应生成单行输出，其中包含五个测试用例的结果，形式为方括号内由逗号分隔的列表，其中每个元素是对应情况的$3$维向量。例如，最终输出必须具有以下形式\n $[\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast],\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast],\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast],\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast],\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast]\\,]$,\n所有数字显示为四舍五入到$6$位小数的浮点数。不涉及角度。百分比（若有）必须表示为小数，而不是使用百分号。", "solution": "问题陈述需经过验证。\n\n### 第1步：提取已知条件\n\n- **经济体**：拥有单一消费品和时间禀赋的交换生产经济体。\n- **代理人**：$2$个代理人，索引为 $i \\in \\{1,2\\}$。\n- **选择**：消费 $c_i \\ge 0$，闲暇 $\\ell_i \\in [0,1]$。劳动供给为 $h_i = 1 - \\ell_i \\in [0,1]$。\n- **生产技术**：$y = h_1 + h_2$。\n- **价格**：消费品价格归一化为$1$。税前工资为 $w = 1$。\n- **税收函数**：$T(I) = \\theta I + \\kappa \\max\\{0, I - I_0\\}^2$，参数为 $\\theta \\in [0,1)$，$\\kappa \\ge 0$，$I_0 \\ge 0$。$I$ 是劳动收入。\n- **政府转移支付**：人均一次性总付转移支付 $\\tau = \\frac{1}{2}\\left(T(w h_1) + T(w h_2)\\right)$。\n- **预算约束**：$c_i \\le w h_i - T(w h_i) + \\tau$。假设等式成立：$c_i^\\ast = w h_i^\\ast - T(w h_i^\\ast) + \\tau^\\ast$。\n- **偏好**：效用函数 $u_i(c_i,\\ell_i) = \\alpha_i \\ln c_i + (1 - \\alpha_i) \\ln \\ell_i$，偏好参数为 $\\alpha_i \\in (0,1)$。\n- **均衡定义**：一个带税的竞争性均衡是一个三元组 $(h_1^\\ast,h_2^\\ast,\\tau^\\ast)$，满足：\n    1. 对每个代理人 $i$，在给定 $\\tau^\\ast$ 的情况下，$h_i^\\ast$ 解决了代理人的效用最大化问题。\n    2. 政府预算平衡：$\\tau^\\ast = \\frac{1}{2}\\left(T(h_1^\\ast)+T(h_2^\\ast)\\right)$。\n    3. 商品市场出清 $c_1^\\ast + c_2^\\ast = h_1^\\ast + h_2^\\ast$ 成立。\n- **任务**：对于给定的参数集 $(\\alpha_1,\\alpha_2,\\theta,\\kappa,I_0)$，计算均衡向量 $[h_1^\\ast,h_2^\\ast,\\tau^\\ast]$。\n- **测试用例**：\n    - 情况 A: $(0.5, 0.5, 0.2, 0.3, 0.5)$\n    - 情况 B: $(0.3, 0.7, 0.2, 0.3, 0.5)$\n    - 情况 C: $(0.5, 0.5, 0.4, 0.6, 0.3)$\n    - 情况 D: $(0.5, 0.5, 0.0, 0.0, 0.0)$\n    - 情况 E: $(0.8, 0.2, 0.1, 0.0, 0.0)$\n\n### 第2步：使用提取的已知条件进行验证\n\n根据验证标准对问题进行分析。\n- **科学性**：该问题描述了一个在公共财政和计算经济学中使用的标准一般均衡模型。效用函数 (Cobb-Douglas)、生产函数（线性）和税收-转移支付系统都是常规且易于理解的构造。问题是科学合理的。\n- **适定性**：该问题要求计算一个竞争性均衡，这等价于寻找一个紧凸集上连续映射的不动点。根据布劳威尔不动点定理，保证均衡存在。对于标准参数化，通常也期望唯一性。目标定义明确。问题是适定的。\n- **客观性**：该问题使用精确的数学语言陈述，没有任何主观或模棱两可的术语。\n- **完整性与一致性**：所有必要的函数、参数和均衡条件都已明确提供。测试套件也已完全指定。关于商品市场出清是由其他条件（瓦尔拉斯定律）所隐含的陈述是正确和标准的。问题是自洽且一致的。\n\n### 第3步：结论与行动\n\n该问题是有效的。这是一个计算经济学中标准的、适定的问题。开始求解。\n\n### 求解\n\n任务是为一个指定的经济环境找到一个竞争性均衡 $(h_1^\\ast, h_2^\\ast, \\tau^\\ast)$。该均衡由一组必须同时满足的条件来刻画：每个代理人的最优化和政府预算平衡。我们将其表述为一个不动点问题并进行数值求解。\n\n**1. 代理人最优化问题**\n\n每个代理人 $i \\in \\{1,2\\}$ 选择劳动供给 $h_i \\in [0,1]$ 以最大化其效用。当工资 $w=1$ 时，代理人的问题是最大化：\n$$ u_i(c_i, \\ell_i) = \\alpha_i \\ln c_i + (1 - \\alpha_i) \\ln \\ell_i $$\n满足约束条件：\n$$ c_i = h_i - T(h_i) + \\tau $$\n$$ \\ell_i = 1 - h_i $$\n$$ c_i > 0, \\ell_i > 0 $$\n将约束条件代入效用函数，问题变为选择 $h_i \\in (0,1)$ 以最大化：\n$$ V(h_i; \\tau) = \\alpha_i \\ln(h_i - T(h_i) + \\tau) + (1 - \\alpha_i) \\ln(1 - h_i) $$\n其中税收函数为 $T(h_i) = \\theta h_i + \\kappa \\max\\{0, h_i - I_0\\}^2$。\n\n**2. 一阶条件 (FOC)**\n\n对于一个内部解 $h_i \\in (0,1)$，效用最大化的一阶条件是 $\\frac{dV}{dh_i} = 0$。税收函数的导数，代表边际税率 (MTR)，是：\n$$ T'(h_i) = \\frac{dT}{dh_i} = \\theta + 2\\kappa \\max\\{0, h_i - I_0\\} $$\n对效用 $V(h_i; \\tau)$ 求关于 $h_i$ 的导数，得到一阶条件：\n$$ \\frac{\\partial V}{\\partial h_i} = \\frac{\\alpha_i}{c_i} (1 - T'(h_i)) - \\frac{1 - \\alpha_i}{1 - h_i} = 0 $$\n该条件表明，消费和闲暇之间的边际替代率必须等于税后工资率，即 $1-T'(h_i)$。整理后，我们得到给定 $\\tau$ 时最优 $h_i$ 的一个隐式方程：\n$$ h_i - T(h_i) + \\tau = \\frac{\\alpha_i}{1-\\alpha_i} (1 - h_i) (1 - T'(h_i)) $$\n\n**3. 均衡系统与计算策略**\n\n竞争性均衡是一个向量 $(h_1^\\ast, h_2^\\ast, \\tau^\\ast)$，它同时满足两个代理人的一阶条件和政府预算约束：\n1. $h_1^\\ast - T(h_1^\\ast) + \\tau^\\ast - \\frac{\\alpha_1}{1-\\alpha_1} (1 - h_1^\\ast) (1 - T'(h_1^\\ast)) = 0$\n2. $h_2^\\ast - T(h_2^\\ast) + \\tau^\\ast - \\frac{\\alpha_2}{1-\\alpha_2} (1 - h_2^\\ast) (1 - T'(h_2^\\ast)) = 0$\n3. $\\tau^\\ast = \\frac{1}{2}(T(h_1^\\ast) + T(h_2^\\ast))$\n\n该系统作为一个不动点问题进行数值求解。令 $H = (h_1, h_2)$ 为劳动供给向量。我们寻求一个不动点 $H^\\ast$，使得 $H^\\ast = F(H^\\ast)$，其中映射 $F: [0,1]^2 \\to [0,1]^2$ 定义如下：\n1. 给定一个猜测值 $H = (h_1, h_2)$，计算相应的转移支付：$\\tau(H) = \\frac{1}{2}(T(h_1) + T(h_2))$。\n2. 对每个代理人 $i$，找到在给定此转移支付 $\\tau(H)$ 下的最优劳动供给 $h_i'$，它解决了他们的效用最大化问题。这定义了新向量 $H' = F(H) = (h_1', h_2')$。\n\n不动点通过寻找函数 $E(H) = F(H) - H = 0$ 的根来找到。这是一个二维求根问题，我们使用 `scipy.optimize.root` 来求解。\n\n**4. 代理人最佳响应计算**\n\n映射 $F$ 的核心是计算代理人的最佳响应劳动供给 $h_i'(\\tau)$。\n- **角点解**：代理人可能选择不工作 ($h_i'=0$)。如果从第一个无穷小量的工作中获得的边际效用为非正，就会发生这种情况。在 $h_i \\to 0$ 时，该条件为 $\\frac{\\partial V}{\\partial h_i}|_{h_i \\to 0^+} \\le 0$。假设 $I_0 > 0$ 或 $\\kappa=0$，这简化为 $\\tau \\ge \\frac{\\alpha_i(1-\\theta)}{1-\\alpha_i}$。如果这个不等式成立，最优劳动供给为 $h_i' = 0$。\n- **内部解**：如果角点解的条件不满足，最优的 $h_i'$ 是一个位于 $(0,1)$ 内的内部解，它满足一阶条件。我们定义函数 $G_i(h; \\tau)$：\n  $$ G_i(h; \\tau) = h - T(h) + \\tau - \\frac{\\alpha_i}{1-\\alpha_i} (1 - h) (1 - T'(h)) $$\n  我们需要找到 $G_i(h; \\tau) = 0$ 的根。由于 $T(h)$ 和 $T'(h)$ 的结构，这是一个非线性方程，我们使用数值一维求根器 `scipy.optimize.brentq`。该方法需要一个函数变号的区间。鉴于内部解的存在，只要消费保持正数，$G_i(h; \\tau)$ 在 $h=0$ 附近为负，在 $h=1$ 附近为正，这确保可以在 $(0,1)$ 中找到一个根。\n\n整体算法包含一个外层循环，该循环对系统 $E(H) = 0$ 调用一个求根程序 (`root`)。在 $E(H)$ 的定义内部，对每个代理人，我们首先检查角点解。如果解是内部解，我们调用一个嵌套的求根程序 (`brentq`) 来求解代理人的一阶条件以得到其最优劳动供给。对所有测试用例重复此过程。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root, brentq\n\ndef solve():\n    \"\"\"\n    Computes the competitive equilibrium for an exchange-production economy with taxes.\n    The solution is found by solving a fixed-point problem for the agents' labor supplies.\n    \"\"\"\n\n    test_cases = [\n        (0.5, 0.5, 0.2, 0.3, 0.5),  # Case A\n        (0.3, 0.7, 0.2, 0.3, 0.5),  # Case B\n        (0.5, 0.5, 0.4, 0.6, 0.3),  # Case C\n        (0.5, 0.5, 0.0, 0.0, 0.0),  # Case D\n        (0.8, 0.2, 0.1, 0.0, 0.0),  # Case E\n    ]\n    \n    results = []\n\n    def T_func(h, theta, kappa, I0):\n        \"\"\"Computes the tax on labor income.\"\"\"\n        h = np.asanyarray(h)\n        income_above_threshold = np.maximum(0, h - I0)\n        return theta * h + kappa * income_above_threshold**2\n\n    def T_prime_func(h, theta, kappa, I0):\n        \"\"\"Computes the marginal tax rate.\"\"\"\n        h = np.asanyarray(h)\n        return theta + 2 * kappa * np.maximum(0, h - I0)\n\n    def compute_equilibrium(alpha1, alpha2, theta, kappa, I0):\n        \"\"\"\n        Calculates the equilibrium (h1*, h2*, tau*) for a given set of parameters.\n        \"\"\"\n        \n        def solve_agent_h(alpha, tau):\n            \"\"\"\n            Calculates an agent's optimal labor supply h for a given transfer tau.\n            This involves checking for a corner solution (h=0) or finding the root\n            of the first-order condition for an interior solution.\n            \"\"\"\n            # The agent's FOC implies h=0 if the marginal utility of working is non-positive at h->0.\n            # This corresponds to G(h->0) >= 0. For h<=I0, T'(h)=theta.\n            # The check_val is derived from the FOC at h -> 0.\n            # If tau is high enough, agent prefers not to work.\n            if theta < 1:\n                check_val = alpha * (1 - theta) / (1 - alpha)\n                if tau >= check_val:\n                    return 0.0\n            \n            # Define the function G(h) = 0 from the agent's first-order condition.\n            def G(h_val):\n                # Ensure h_val is within the valid domain.\n                if h_val <= 1e-12: return -1.0  # Guide solver towards positive h\n                if h_val >= 1.0 - 1e-12: return 1.0 # Guide solver away from h=1\n\n                th = T_func(h_val, theta, kappa, I0)\n                consumption = h_val - th + tau\n\n                # If consumption is non-positive, this choice is infeasible.\n                # Utility is -inf, so agent would reduce labor.\n                # The FOC function value should be large and positive.\n                if consumption <= 0:\n                    return 1e9\n\n                th_prime = T_prime_func(h_val, theta, kappa, I0)\n                \n                # FOC: c_i = (alpha_i/(1-alpha_i)) * (1-h_i) * (1-T'(h_i))\n                foc_lhs = consumption\n                foc_rhs = (alpha / (1 - alpha)) * (1 - h_val) * (1 - th_prime)\n                \n                return foc_lhs - foc_rhs\n\n            # Use brentq to find the root of G(h) for an interior solution.\n            # The search interval is (0, 1). The logic above ensures a root exists\n            # in this interval if the corner solution check fails.\n            try:\n                h_solution = brentq(G, 1e-9, 1.0 - 1e-9, xtol=1e-12, rtol=1e-12)\n                return h_solution\n            except ValueError:\n                # This case should ideally not be reached given the model's structure\n                # and the corner solution check.\n                return 0.0\n\n        def system_of_equations(h_vec):\n            \"\"\"\n            Defines the system of equations H_new - H = 0 for the fixed-point solver.\n            H = [h1, h2]. H_new is the vector of best-response labor supplies.\n            \"\"\"\n            h1, h2 = h_vec\n            \n            # Penalize out-of-bound values during iteration\n            if not (0 <= h1 <= 1 and 0 <= h2 <= 1):\n                return [1e6, 1e6]\n\n            # 1. Calculate transfer tau from current labor supplies h1, h2.\n            current_tau = 0.5 * (T_func(h1, theta, kappa, I0) + T_func(h2, theta, kappa, I0))\n            \n            # 2. Calculate each agent's optimal labor supply given the transfer.\n            h1_new = solve_agent_h(alpha1, current_tau)\n            h2_new = solve_agent_h(alpha2, current_tau)\n            \n            # 3. Return the error vector for the root finder.\n            return [h1_new - h1, h2_new - h2]\n\n        # Initial guess for the root finder. [0.5, 0.5] is a neutral starting point.\n        initial_guess = np.array([0.5, 0.5])\n        \n        # Use scipy's root finder to solve the system F(H) - H = 0.\n        solution = root(system_of_equations, initial_guess, method='hybr', tol=1e-10)\n\n        if not solution.success:\n            # Fallback to an initial guess based on no-tax solution if first fails\n            solution = root(system_of_equations, np.array([alpha1, alpha2]), method='hybr', tol=1e-10)\n            if not solution.success:\n                 # In case of persistent failure, which shouldn't happen for these parameters.\n                 raise RuntimeError(f\"Equilibrium computation failed for parameters: {alpha1, alpha2, theta, kappa, I0}\")\n\n        h1_star, h2_star = solution.x\n        \n        # Calculate the final equilibrium transfer tau*.\n        tau_star = 0.5 * (T_func(h1_star, theta, kappa, I0) + T_func(h2_star, theta, kappa, I0))\n\n        return [h1_star, h2_star, tau_star]\n\n    for case_params in test_cases:\n        alpha1, alpha2, theta, kappa, I0 = case_params\n        eq = compute_equilibrium(alpha1, alpha2, theta, kappa, I0)\n        results.append(eq)\n\n    # Format the output string exactly as required.\n    formatted_results = []\n    for res in results:\n        # Round each element to 6 decimal places and format into a string \"[v1,v2,v3]\"\n        formatted_res = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\"\n        formatted_results.append(formatted_res)\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}