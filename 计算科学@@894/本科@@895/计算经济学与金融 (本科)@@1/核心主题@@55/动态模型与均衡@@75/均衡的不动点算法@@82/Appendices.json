{"hands_on_practices": [{"introduction": "寻找马尔可夫链的长期稳态是经济学和金融学中一个典型的定点问题。平稳分布 $\\pi$ 代表一种均衡，在此均衡中，系统处于任何给定状态的概率随时间推移不再改变。本练习将抽象的定点方程 $\\pi = \\pi P$ 转化为具体的计算任务，为您提供模拟动态系统的基础技能。[@problem_id:2393467]", "id": "2393467", "problem": "考虑一个有限状态马尔可夫链，其转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 为行随机矩阵，即每个元素 $P_{ij} \\geq 0$ 且每行之和为 $1$。平稳分布是任意满足 $\\sum_{i=1}^n \\pi_i = 1$ 和不动点方程 $\\pi = \\pi P$ 的非负分量概率向量 $\\pi \\in \\mathbb{R}^n$。对于下方的每个测试用例，计算求解 $\\pi = \\pi P$、$\\sum_i \\pi_i = 1$ 且所有 $\\pi_i \\geq 0$ 的平稳分布。将每个平稳分布的各分量表示为实数，使用标准四舍五入精确到六位小数。\n\n测试套件（每个 $P^{(k)}$ 均为行随机矩阵）：\n- 测试用例 $1$（维度 $2$）：\n  $$P^{(1)} = \\begin{bmatrix}\n  0.9 & 0.1 \\\\\n  0.5 & 0.5\n  \\end{bmatrix}.$$\n- 测试用例 $2$（维度 $2$）：\n  $$P^{(2)} = \\begin{bmatrix}\n  0.999 & 0.001 \\\\\n  0.01 & 0.99\n  \\end{bmatrix}.$$\n- 测试用例 $3$（维度 $3$）：\n  $$P^{(3)} = \\begin{bmatrix}\n  0.7 & 0.2 & 0.1 \\\\\n  0.4 & 0.4 & 0.2 \\\\\n  0.3 & 0.3 & 0.4\n  \\end{bmatrix}.$$\n- 测试用例 $4$（维度 $4$）：\n  $$P^{(4)} = \\begin{bmatrix}\n  0.25 & 0.25 & 0.25 & 0.25 \\\\\n  0.25 & 0.25 & 0.25 & 0.25 \\\\\n  0.25 & 0.25 & 0.25 & 0.25 \\\\\n  0.25 & 0.25 & 0.25 & 0.25\n  \\end{bmatrix}.$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个包含四舍五入到六位小数的实数列表，不带任何附加文本。例如，包含两个测试用例的输出可能如下所示：$[[0.500000,0.500000],[0.333333,0.333333,0.333334]]$。", "solution": "该问题要求为给定的有限状态马尔可夫链（由行随机转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 定义）寻找其平稳分布 $\\pi$。\n\n平稳分布是一个概率向量 $\\pi = [\\pi_1, \\pi_2, \\dots, \\pi_n]$，满足以下三个条件：\n$1$. 对于所有 $i \\in \\{1, \\dots, n\\}$，$\\pi_i \\ge 0$。\n$2$. $\\sum_{i=1}^n \\pi_i = 1$。\n$3$. 不动点方程：$\\pi = \\pi P$。\n\n不动点方程 $\\pi = \\pi P$ 可以改写为如下的齐次线性方程组：\n$$ \\pi P - \\pi = \\mathbf{0} $$\n$$ \\pi (P - I) = \\mathbf{0} $$\n其中 $I$ 是 $n \\times n$ 单位矩阵，$\\mathbf{0}$ 是 $n$ 维零行向量。\n\n该方程表明 $\\pi$ 是矩阵 $P$ 对应于特征值 $\\lambda = 1$ 的左特征向量。等价地，通过转置方程，我们得到：\n$$ (P^T - I^T) \\pi^T = \\mathbf{0}^T $$\n$$ (P^T - I) \\pi^T = \\mathbf{0} $$\n这表明列向量 $\\pi^T$ 是转置矩阵 $P^T$ 对应于特征值 $\\lambda = 1$ 的右特征向量。\n\n对于任意行随机矩阵 $P$，其每行之和为 $1$。这意味着 $P \\mathbf{1} = \\mathbf{1}$，其中 $\\mathbf{1}$ 是全为1的列向量。因此，$\\lambda=1$ 始终是 $P$ 的一个特征值。由于矩阵与其转置矩阵具有相同的特征值集合，$\\lambda=1$ 也是 $P^T$ 的一个特征值。\n\n因此，寻找 $\\pi$ 的问题被归结为寻找 $P^T$ 对应于 $\\lambda=1$ 的特征空间。给定的矩阵对应于不可约马尔可夫链（每个状态都可从任何其他状态到达）。对于此类链，Perron-Frobenius 定理保证特征值 $\\lambda=1$ 的代数重数为 $1$。因此，其对应的特征空间是一维的。\n\n这意味着方程 $(P^T - I)\\pi^T = \\mathbf{0}$ 的任何非零解在相差一个标量乘数的情况下是唯一的。我们找到这样一个非零特征向量，称之为 $v$。根据同一定理，对于像 $P^T$ 这样的不可约非负矩阵，其对应于主特征值（此处为 $\\lambda=1$）的特征向量 $v$ 可以被选择为所有分量均为非负。\n\n最后一步是应用归一化条件 $\\sum_{i=1}^n \\pi_i = 1$。我们取找到的特征向量 $v$，通过除以其分量之和进行归一化：\n$$ \\pi^T = \\frac{v}{\\sum_{i=1}^n v_i} $$\n所得向量 $\\pi$ 是唯一的平稳分布。\n\n计算流程如下：\n$1$. 对于给定的矩阵 $P$，构造矩阵 $A = P^T - I$。\n$2$. 求 $A$ 的零空间的一个基。对于给定的问题，这将是一个单一向量 $v$。\n$3$. 确保 $v$ 的所有分量都是非负的，必要时取绝对值。\n$4$. 将 $v$ 归一化以获得概率向量 $\\pi^T$。\n$5$. 然后将所得向量的分量按要求四舍五入到六位小数。\n此方法应用于每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Computes the stationary distribution for a set of Markov chain transition matrices.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [0.9, 0.1],\n            [0.5, 0.5]\n        ]),\n        np.array([\n            [0.999, 0.001],\n            [0.01, 0.99]\n        ]),\n        np.array([\n            [0.7, 0.2, 0.1],\n            [0.4, 0.4, 0.2],\n            [0.3, 0.3, 0.4]\n        ]),\n        np.array([\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25]\n        ])\n    ]\n\n    all_results_str = []\n    \n    for P in test_cases:\n        # The stationary distribution pi is the left eigenvector of P for eigenvalue 1.\n        # This is equivalent to the right eigenvector of P.T for eigenvalue 1.\n        # We solve the system (P.T - I) * pi.T = 0.\n        \n        n = P.shape[0]\n        I = np.identity(n)\n        A = P.T - I\n\n        # Find the null space of A. For an irreducible Markov chain, this space\n        # is one-dimensional and spanned by the stationary distribution vector.\n        # The result is a basis for the null space, with basis vectors as columns.\n        v = null_space(A)\n\n        # By Perron-Frobenius theorem, the stationary distribution for an\n        # irreducible chain has all positive components. The eigenvector is\n        # unique up to a scalar, so we take the absolute value to ensure non-negativity.\n        pi_vec = np.abs(v[:, 0])\n        \n        # Normalize the vector to make it a probability distribution.\n        pi = pi_vec / np.sum(pi_vec)\n        \n        # Format results to six decimal places.\n        pi_str_list = [f\"{x:.6f}\" for x in pi]\n        all_results_str.append(f\"[{','.join(pi_str_list)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"}, {"introduction": "在动态经济模型中，一个核心任务是求解贝尔曼方程，其解（即价值函数 $V$）是贝尔曼算子 $\\mathcal{T}$ 的一个不动点。本练习要求您实现价值函数迭代这一强大的不动点算法，通过迭代逼近来数值求解该问题。通过这个实践，您将深入理解经济主体如何在动态环境中做出最优决策，这是现代宏观经济学的一块基石。[@problem_id:2393445]", "id": "2393445", "problem": "考虑一个离散时间动态规划问题，其状态变量 $k \\in \\mathcal{K} \\subset \\mathbb{R}_{+}$ 定义在一个有限网格上。决策变量是下一期的状态 $k' \\in \\mathcal{K}$。资源约束为\n$$\nc + k' = A k^{\\alpha} + (1-\\delta) k + \\bar{y},\n$$\n其中 $A > 0$，$\\alpha \\in (0,1)$，$\\delta \\in (0,1)$，以及外生禀赋 $\\bar{y} \\ge 0$。瞬时效用函数为恒定相对风险规避（CRRA）形式，\n$$\nu(c) = \\begin{cases}\n\\log(c) & \\text{若 } \\sigma = 1,\\\\\n\\dfrac{c^{1-\\sigma}}{1-\\sigma} & \\text{若 } \\sigma \\ne 1,\n\\end{cases}\n$$\n其中风险规避参数 $\\sigma > 0$ 且 $c \\ge c_{\\min} > 0$。在有界函数空间 $V:\\mathcal{K} \\to \\mathbb{R}$ 上的贝尔曼算子 $\\mathcal{T}$ 定义为\n$$\n(\\mathcal{T}V)(k) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\!\\left(A k^{\\alpha} + (1-\\delta) k + \\bar{y} - k' \\right) + \\beta V(k') \\right\\},\n$$\n其中折扣因子 $\\beta \\in (0,1)$。价值函数 $V$ 是 $\\mathcal{T}$ 的一个不动点，即满足 $V = \\mathcal{T}V$。在具有 $N \\in \\mathbb{N}$ 个点的有限网格 $\\mathcal{K} = \\{k_{1},\\dots,k_{N}\\}$ 上，将 $V$ 表示为 $\\mathbb{R}^{N}$ 中的一个向量。假设对于每个 $k$，通过限制 $k'$ 的可行选择来强制满足 $c \\ge c_{\\min}$。\n\n基本依据：你可以使用以下事实。首先，根据 Brouwer 不动点定理，紧凸集上的连续自映射保证存在不动点。其次，压缩映射定理（Banach 不动点定理）确保当 $\\mathcal{T}$ 在上确界范数下是压缩映射时，逐次逼近法的唯一性和收敛性。在这种有限网格设定下，当 $\\beta \\in (0,1)$ 且回报有界时，$\\mathcal{T}$ 在上确界范数下是一个模为 $\\beta$ 的压缩映射。\n\n任务：实现一个不动点算法（价值函数迭代），通过从初始猜测 $V_{0}(k) = 0$（对于所有 $k \\in \\mathcal{K}$）开始的逐次逼近，在有限网格上计算 $\\mathcal{T}$ 的不动点。在每次迭代 $n$ 中，计算 $V_{n+1} = \\mathcal{T}V_{n}$ 和上确界范数差 $\\Delta_{n} = \\lVert V_{n+1} - V_{n} \\rVert_{\\infty}$。当 $\\Delta_{n} \\le \\text{tol}$（其中 $\\text{tol} > 0$ 是指定的容差）或达到指定的最大迭代次数时停止。此外，对于一个指定的迭代指数 $m \\ge 1$，计算压缩不等式 $\\Delta_{m} \\le \\beta \\Delta_{m-1}$ 是否在数值松弛的范围内成立。\n\n使用与状态网格 $\\mathcal{K}$ 相等的离散行动集，因此 $k' \\in \\mathcal{K}$。对于当前状态 $k$，通过排除任何违反 $c \\ge c_{\\min}$ 的 $k'$ 来强制执行可行性。为保证数值稳定性，你可以为不可行的 $(k,k')$ 配对分配一个非常大的负效用值。你必须实现你的程序，使其能够处理以下参数值的测试套件。\n\n测试套件。对于以下每个案例，构建一个均匀间隔的网格 $\\mathcal{K} = \\{k_{1},\\dots,k_{N}\\}$，其中 $k_{1} = k_{\\min}$ 和 $k_{N} = k_{\\max}$，并报告所要求的标量值。所有数字都是无量纲的，应被视为纯数。\n\n- 案例1（基线，理想路径）：\n  - $A = 1$, $\\alpha = 0.35$, $\\delta = 0.10$, $\\beta = 0.95$, $\\sigma = 1$, $\\bar{y} = 0$,\n  - $N = 200$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 5$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$。\n  - 输出：为满足 $\\Delta_{n} \\le \\text{tol}$ 所需的整数迭代次数。\n\n- 案例2（高耐心和高曲率，更粗的网格）：\n  - $A = 1$, $\\alpha = 0.30$, $\\delta = 0.05$, $\\beta = 0.99$, $\\sigma = 2$, $\\bar{y} = 0.02$,\n  - $N = 150$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 2$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$。\n  - 输出：在索引 $j = \\left\\lfloor 0.6 \\cdot (N-1) \\right\\rfloor + 1$ 处的浮点数值 $V(k_{j})$（即，状态的索引是1-based，且等于大于或等于 $0.6 (N-1) + 1$ 的最小整数）。\n\n- 案例3（压缩检查）：\n  - $A = 1$, $\\alpha = 0.40$, $\\delta = 0.08$, $\\beta = 0.90$, $\\sigma = 3$, $\\bar{y} = 0.10$,\n  - $N = 120$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 3$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-8}$, $\\text{max\\_iter} = 10000$。\n  - 设 $m = 4$。输出：陈述 $\\Delta_{m} \\le \\beta \\Delta_{m-1} + \\varepsilon$ 在数值松弛 $\\varepsilon = 10^{-12}$ 下的布尔真值。\n\n- 案例4（不动点处的残差）：\n  - $A = 0.80$, $\\alpha = 0.25$, $\\delta = 0.07$, $\\beta = 0.97$, $\\sigma = 1.5$, $\\bar{y} = 0.05$,\n  - $N = 100$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 4$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$。\n  - 输出：收敛时的浮点数贝尔曼残差，定义为 $\\lVert V^{*} - \\mathcal{T}V^{*} \\rVert_{\\infty}$，其中 $V^{*}$ 是从你的算法得到的收敛价值函数。\n\n最终输出格式。你的程序应生成单行输出，其中包含四个案例的结果，按案例1到4的顺序排列，格式为方括号括起来的逗号分隔列表。例如，打印的行必须像 $[r_{1},r_{2},r_{3},r_{4}]$，其中 $r_{1}$ 是一个整数，$r_{2}$ 是一个浮点数，$r_{3}$ 是一个布尔值，$r_{4}$ 是一个浮点数。不应打印任何其他文本。", "solution": "所提出的问题是为一个标准的离散时间新古典增长模型寻找一个数值解。该模型由一个贝尔曼方程定义，该方程将价值函数 $V$ 刻画为贝尔曼算子 $\\mathcal{T}$ 的不动点。该问题在科学上是有效的、适定的，并且为其计算解提供了所有必要的参数。解的存在性和唯一性，以及所提出算法的收敛性，都由压缩映射定理（也称为Banach不动点定理）保证，正如问题陈述中正确指出的那样。任务是实现价值函数迭代（VFI）算法，该算法是定理证明中使用的逐次逼近法的直接计算对应物。\n\n问题的核心在于贝尔曼算子 $\\mathcal{T}$，它将一个函数 $V$ 映射到一个新函数 $\\mathcal{T}V$：\n$$\n(\\mathcal{T}V)(k) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\left(A k^{\\alpha} + (1-\\delta) k + \\bar{y} - k' \\right) + \\beta V(k') \\right\\}\n$$\n一个解，或不动点，是一个函数 $V^*$，使得 $V^* = \\mathcal{T}V^*$。VFI算法从一个初始猜测 $V_0$（这里，$V_0(k)=0$ 对所有$k$成立）开始，根据规则 $V_{n+1} = \\mathcal{T}V_n$ 进行迭代，构造一个函数序列 $\\{V_n\\}_{n=0}^{\\infty}$。因为 $\\mathcal{T}$ 在上确界范数下是一个模为 $\\beta \\in (0,1)$ 的压缩映射，所以这个序列保证会收敛到唯一的不动点 $V^*$。\n\n为了进行数值实现，资本 $k$ 的连续状态空间被离散化到一个有限的、均匀间隔的网格 $\\mathcal{K} = \\{k_1, k_2, \\dots, k_N\\}$ 上。因此，价值函数 $V:\\mathcal{K} \\to \\mathbb{R}$ 被表示为一个向量 $\\mathbf{V} \\in \\mathbb{R}^N$，其中第 $i$ 个分量 $\\mathbf{V}_i$ 对应于值 $V(k_i)$。由下一期资本 $k'$ 的选择构成的行动空间，也被限制在同一个网格 $\\mathcal{K}$ 上。\n\n迭代更新 $V_{n+1} = \\mathcal{T}V_n$ 是对网格上的每个点 $k_i \\in \\mathcal{K}$ 执行的。新价值函数向量 $\\mathbf{V}_{n+1}$ 的第 $i$ 个分量计算如下：\n$$\n(\\mathbf{V}_{n+1})_i = \\max_{j \\in \\{1, \\dots, N\\}} \\left\\{ u(c_{ij}) + \\beta (\\mathbf{V}_n)_j \\right\\}\n$$\n这里，$(\\mathbf{V}_n)_j$ 是前一次迭代在状态 $k_j$ 处的函数值，而 $c_{ij}$ 是在当前状态为 $k_i$ 时选择状态 $k_j$ 所产生的消费。根据资源约束：\n$$\nc_{ij} = A k_i^{\\alpha} + (1-\\delta) k_i + \\bar{y} - k_j\n$$\n一个关键步骤是强制执行可行性约束 $c_{ij} \\ge c_{\\min}$。任何违反此约束的 $k_j$ 选择都是不可接受的。在最大化过程中，通过为此类选择分配一个无限负的效用（在计算上，一个非常大的负数）来处理，以确保它们永远不会被选中。效用函数 $u(c)$ 定义为，当 $\\sigma=1$ 时为 $\\log(c)$，当 $\\sigma \\ne 1$ 时为 $\\frac{c^{1-\\sigma}}{1-\\sigma}$。\n\n算法流程如下：\n1.  将 $\\mathbf{V}_0$ 初始化为一个大小为 $N$ 的零向量。\n2.  对于每次迭代 $n=0, 1, 2, \\dots$:\n    a. 对于每个当前状态 $k_i$, $i=1, \\dots, N$:\n        i.  对于每个可能的下一状态 $k_j$, $j=1, \\dots, N$:\n            -   计算消费 $c_{ij} = A k_i^{\\alpha} + (1 - \\delta)k_i + \\bar{y} - k_j$。\n            -   如果 $c_{ij} < c_{\\min}$，则此选择的值为 $-\\infty$。\n            -   否则，值为 $u(c_{ij}) + \\beta (\\mathbf{V}_n)_j$。\n        ii. 将 $(\\mathbf{V}_{n+1})_i$ 设为在所有 j 的选择中找到的最大值。\n    b. 计算差的上确界范数：$\\Delta_n = \\lVert \\mathbf{V}_{n+1} - \\mathbf{V}_n \\rVert_{\\infty} = \\max_i |(\\mathbf{V}_{n+1})_i - (\\mathbf{V}_n)_i|$。\n    c. 如果 $\\Delta_n \\le \\text{tol}$ 或达到最大迭代次数，则终止。否则，设置 $\\mathbf{V}_n = \\mathbf{V}_{n+1}$ 并继续下一次迭代。\n\n为了效率，这个过程使用向量化操作进行计算实现。构建一个消费值矩阵 $C$，其条目为 $C_{ij} = c_{ij}$。然后计算一个对应的效用矩阵 $U$，对于可行的消费，其条目为 $U_{ij} = u(C_{ij})$，否则为 $U_{ij} = -\\infty$。然后贝尔曼算子可以在一个单一的向量化步骤中应用：\n$$\n\\mathbf{V}_{n+1} = \\max_{\\text{axis}=1} \\left( U + \\beta \\mathbf{V}_n^T \\right)\n$$\n其中 $\\mathbf{V}_n^T$ 被广播到矩阵 $U$ 的各行。\n\n每个案例的具体输出按如下方式确定：\n-   案例1：直到收敛所执行的总迭代次数。\n-   案例2：在特定索引处收敛后的函数 $\\mathbf{V}^*$ 的值。需要注意的是，问题描述在定义此索引时存在模糊性：公式 $j = \\lfloor 0.6 \\cdot (N-1) \\rfloor + 1$（向下取整）与括号中的文本相矛盾，后者暗示了向上取整函数。使用向下取整函数的正式数学表达式是更可靠的指令，并将被遵循。对于 $N=150$，这得出 $j = \\lfloor 0.6 \\cdot 149 \\rfloor + 1 = 89+1 = 90$。所需的值是价值函数向量的第90个元素，对应于0-based数组中的索引89。\n-   案例3：在迭代 $m=4$ 时，检查不等式 $\\Delta_4 \\le \\beta \\Delta_3 + \\varepsilon$ 是否成立。这验证了算子的压缩性质。\n-   案例4：在算法收敛到 $V^*$ 之后，计算最终的贝尔曼残差 $\\lVert V^* - \\mathcal{T}V^* \\rVert_{\\infty}$。这是通过将算子最后一次应用于收敛解 $V^*$，并计算结果 $\\mathcal{T}V^*$ 与 $V^*$ 之间的上确界范数差来找到的。\n\n该实现将为四个提供的测试案例系统地执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dynamic programming problem for four distinct test cases\n    using value function iteration and prints the results.\n    \"\"\"\n\n    def run_vfi(params):\n        \"\"\"\n        Performs value function iteration for a given set of parameters.\n        \"\"\"\n        A = params['A']\n        alpha = params['alpha']\n        delta = params['delta']\n        beta = params['beta']\n        sigma = params['sigma']\n        y_bar = params['y_bar']\n        N = params['N']\n        k_min = params['k_min']\n        k_max = params['k_max']\n        c_min = params['c_min']\n        tol = params['tol']\n        max_iter = params['max_iter']\n        case_id = params['case_id']\n\n        # 1. Grid setup\n        k_grid = np.linspace(k_min, k_max, N)\n        \n        # 2. VFI Initialization\n        V = np.zeros(N)\n        \n        # Iteration-specific storage for Case 3\n        delta_m_minus_1 = np.nan\n        delta_m = np.nan\n        \n        # 3. VFI Main Loop\n        for n in range(max_iter):\n            V_old = V.copy()\n            \n            # Vectorized Bellman operator application\n            k_current = k_grid.reshape((N, 1))\n            k_next = k_grid.reshape((1, N))\n            \n            resources = A * k_current**alpha + (1 - delta) * k_current + y_bar\n            consumption = resources - k_next\n            \n            # Utility calculation with feasibility check\n            utility = np.full((N, N), -np.inf)\n            feasible_mask = consumption >= c_min\n            \n            c_feasible = consumption[feasible_mask]\n            \n            if sigma == 1.0:\n                utility[feasible_mask] = np.log(c_feasible)\n            else:\n                utility[feasible_mask] = (c_feasible**(1 - sigma)) / (1 - sigma)\n            \n            T_V = utility + beta * V_old\n            V = np.max(T_V, axis=1)\n            \n            # Convergence check\n            diff = np.max(np.abs(V - V_old))\n\n            if case_id == 3:\n                m = params['m']\n                if n == m - 2: # Iteration m-1 (0-indexed)\n                    delta_m_minus_1 = diff\n                if n == m - 1: # Iteration m (0-indexed)\n                    delta_m = diff\n\n            if diff < tol:\n                break\n        \n        num_iterations = n + 1\n\n        # 4. Return the requested result based on the case\n        if case_id == 1:\n            return num_iterations\n        elif case_id == 2:\n            # 1-based index j from formula, convert to 0-based for numpy\n            j_one_based = int(np.floor(0.6 * (N - 1))) + 1\n            j_zero_based = j_one_based - 1\n            return V[j_zero_based]\n        elif case_id == 3:\n            epsilon = params['epsilon']\n            return delta_m <= beta * delta_m_minus_1 + epsilon\n        elif case_id == 4:\n            # Calculate the Bellman residual at the converged point V\n            k_current = k_grid.reshape((N, 1))\n            k_next = k_grid.reshape((1, N))\n            resources = A * k_current**alpha + (1 - delta) * k_current + y_bar\n            consumption = resources - k_next\n            utility = np.full((N, N), -np.inf)\n            feasible_mask = consumption >= c_min\n            c_feasible = consumption[feasible_mask]\n            \n            if sigma == 1.0:\n                utility[feasible_mask] = np.log(c_feasible)\n            else:\n                utility[feasible_mask] = (c_feasible**(1 - sigma)) / (1 - sigma)\n                \n            TV_star = np.max(utility + beta * V, axis=1)\n            residual = np.max(np.abs(TV_star - V))\n            return residual\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'case_id': 1, 'A': 1, 'alpha': 0.35, 'delta': 0.10, 'beta': 0.95, 'sigma': 1, 'y_bar': 0,\n            'N': 200, 'k_min': 1e-4, 'k_max': 5, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        },\n        {\n            'case_id': 2, 'A': 1, 'alpha': 0.30, 'delta': 0.05, 'beta': 0.99, 'sigma': 2, 'y_bar': 0.02,\n            'N': 150, 'k_min': 1e-4, 'k_max': 2, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        },\n        {\n            'case_id': 3, 'A': 1, 'alpha': 0.40, 'delta': 0.08, 'beta': 0.90, 'sigma': 3, 'y_bar': 0.10,\n            'N': 120, 'k_min': 1e-4, 'k_max': 3, 'c_min': 1e-8,\n            'tol': 1e-8, 'max_iter': 10000, 'm': 4, 'epsilon': 1e-12\n        },\n        {\n            'case_id': 4, 'A': 0.80, 'alpha': 0.25, 'delta': 0.07, 'beta': 0.97, 'sigma': 1.5, 'y_bar': 0.05,\n            'N': 100, 'k_min': 1e-4, 'k_max': 4, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_vfi(case_params)\n        results.append(result)\n\n    # Format the results into the required string format.\n    # Booleans need to be lowercased as 'true'/'false'.\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool) or isinstance(r, np.bool_):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(str(r))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "市场均衡价格是一个不动点，在该价格水平上，供给与需求达到平衡，没有任何参与者有单方面改变策略的动机。本练习将通过实现一个拍卖算法，来寻找一个分配市场中的竞争均衡，这个过程生动地展示了理论上的均衡存在性（常由不动点定理证明）如何转化为实际的市场机制。通过寻找核心中的一个点，您将把博弈论、市场设计和计算方法联系起来。[@problem_id:2393499]", "id": "2393499", "problem": "考虑一个具有分配结构的可转移效用合作市场，该市场由有限的一组买方和有限的一组不可分物品组成。设有 $n$ 个买方，索引为 $i \\in \\{1,\\dots,n\\}$，以及 $m$ 个物品，索引为 $j \\in \\{1,\\dots,m\\}$，其中 $n \\le m$。每个买方 $i$ 对获得物品 $j$ 有一个估值 $v_{ij} \\in \\mathbb{R}_{\\ge 0}$。一个可行分配是一种匹配，它将每个买方至多分配给一个物品，并将每个物品至多分配给一个买方，如果可能，则恰好匹配 $n$ 个买方。在可转移效用（TU）分配博弈中，一个结果由一个匹配、一个转移（价格）向量和买方效用共同指定，允许进行边际支付，使得买方 $i$ 获得效用 $u_i$，而卖方 $j$（物品 $j$ 的所有者）收到一笔支付 $p_j$。\n\n基本定义：\n- TU 分配博弈的核心是结果集合 $\\{(u,p,\\mu)\\}$，其中 $\\mu$ 是一个匹配，$u = (u_1,\\dots,u_n)$ 是买方效用，$p = (p_1,\\dots,p_m)$ 是物品价格，满足联盟理性：对于每一对买方-物品 $(i,j)$，$u_i + p_j \\ge v_{ij}$；对于每一个匹配对 $(i,\\mu(i))$，$u_i + p_{\\mu(i)} = v_{i,\\mu(i)}$。可行性要求在 $\\mu$ 中恰好有 $n$ 个买方被匹配。\n- 竞争均衡（在此拟线性环境中也称为瓦尔拉斯均衡）是一个价格向量 $p$ 和一个匹配 $\\mu$，使得在给定价格 $p$ 的情况下，每个被匹配的买方 $i$ 从其需求集 $\\arg\\max_{j} \\{v_{ij} - p_j\\}$ 中选择 $\\mu(i)$，并且所有买方都被匹配。对于具有可转移效用的分配市场，竞争均衡与核心结果之间的等价性是众所周知。\n\n此类均衡的存在性（因此核心的非空性）可以通过不动点理论（如 Kakutani 不动点定理）来确定，该定理保证了当买方从其需求对应中进行选择时，存在一个能够出清市场的价格向量 $p$。特别地，在标准假设下，需求对应是非空的、凸值的且上半连续的，总超额需求存在一个不动点，确保了竞争均衡的存在；在分配市场中，这样的均衡结果位于核心之内。\n\n您的任务是实现一个算法，在给定估值矩阵 $V = (v_{ij}) \\in \\mathbb{R}_{\\ge 0}^{n \\times m}$（其中 $n \\le m$）的情况下，通过迭代价格调整来构造一个竞争均衡，从而计算出核心中的一个点：\n- 从所有 $j$ 的 $p_j = 0$ 开始，迭代调整需求过剩物品的价格，直到存在一个匹配 $\\mu$ 能将所有买方匹配到他们在价格 $p$ 下需求的物品。\n- 在任意价格向量 $p$ 下，定义买方 $i$ 的需求集为 $D_i(p) = \\arg\\max_{j \\in \\{1,\\dots,m\\}} \\{v_{ij} - p_j\\}$。当 $j \\in D_i(p)$ 时，构建包含边 $(i,j)$ 的二部需求图。\n- 在当前需求图上计算一个最大匹配。如果其大小为 $n$，则停止并输出相关的效用 $u_i = v_{i,\\mu(i)} - p_{\\mu(i)}$ 以及价格 $p$；这是一个竞争均衡点，也是一个核心点。\n- 如果并非所有买方都能被匹配，则识别出买方集合 $B$ 和物品集合 $S$，这些集合中的元素可以从需求图中的未匹配买方通过交替路径（在需求边和已匹配边之间交替）到达。将所有 $j \\in S$ 的价格 $p_j$ 增加一个最小增量，该增量使得集合 $B$ 中至少一个买方对集合 $S$ 中的某个物品和集合 $S$ 之外的某个物品变得无差异。然后重新计算需求并重复。\n\n您还必须实现一个验证程序，通过检验以下条件来检查所得结果 $(u,p,\\mu)$ 是否位于核心内：\n- 对于所有 $i \\in \\{1,\\dots,n\\}$ 和所有 $j \\in \\{1,\\dots,m\\}$，$u_i + p_j \\ge v_{ij}$（在数值公差范围内）。\n- 对于所有 $i \\in \\{1,\\dots,n\\}$，如果 $\\mu(i) = j$，则 $u_i + p_j = v_{ij}$（在数值公差范围内）。\n- 恰好有 $n$ 个买方被匹配。\n\n数值假设：将所有估值视为没有物理单位的实数。不涉及角度。不要打印百分比；任何分数量都应表示为小数。\n\n测试套件：\n实现您的程序以在以下三个测试用例上运行。每个测试用例由一个估值矩阵 $V$ 定义。\n- 用例 $1$：$n = 2$，$m = 3$，其中\n$$\nV^{(1)} = \\begin{pmatrix}\n10 & 8 & 7 \\\\\n7 & 9 & 9\n\\end{pmatrix}.\n$$\n- 用例 $2$：$n = 3$，$m = 3$，其中\n$$\nV^{(2)} = \\begin{pmatrix}\n5 & 5 & 1 \\\\\n5 & 4 & 4 \\\\\n4 & 5 & 4\n\\end{pmatrix}.\n$$\n- 用例 $3$：$n = 3$，$m = 4$，其中\n$$\nV^{(3)} = \\begin{pmatrix}\n1 & 2 & 0 & 2 \\\\\n2 & 0 & 2 & 1 \\\\\n0 & 2 & 1 & 2\n\\end{pmatrix}.\n$$\n\n对于每个用例，您的程序必须：\n- 通过上述迭代价格调整方法计算 $(u,p,\\mu)$。\n- 验证计算出的结果是否在核心内，并返回布尔真值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果都是一个布尔值，指示相应测试用例的计算结果是否在核心内。对于上述三个用例，您的程序必须打印“[b1,b2,b3]”形式的单行，其中每个 $b_k$ 是 True 或 False，不带任何附加文本或换行。", "solution": "对所提出的问题进行了严格的验证。\n\n**第一步：提取已知条件**\n- 一个有 $n$ 个买方和 $m$ 个物品的可转移效用（TU）合作市场，其中 $n \\le m$。\n- 买方索引 $i \\in \\{1, \\dots, n\\}$，物品索引 $j \\in \\{1, \\dots, m\\}$。\n- 估值矩阵 $V = (v_{ij}) \\in \\mathbb{R}_{\\ge 0}^{n \\times m}$。\n- 核心结果的定义：一个三元组 $(u, p, \\mu)$，其中 $u$ 是效用向量，$p$ 是价格向量，$\\mu$ 是匹配，满足：\n    1. 联盟理性：对所有配对 $(i, j)$，$u_i + p_j \\ge v_{ij}$。\n    2. 匹配对的个体理性：对每个匹配到物品 $\\mu(i)$ 的买方 $i$，$u_i + p_{\\mu(i)} = v_{i, \\mu(i)}$。\n    3. 可行性：匹配 $\\mu$ 精确地分配了 $n$ 个买方。\n- 竞争均衡的定义：一个价格向量 $p$ 和一个匹配 $\\mu$，其中每个买方 $i$ 被匹配到其需求集 $D_i(p) = \\arg\\max_{j} \\{v_{ij} - p_j\\}$ 中的一个物品 $\\mu(i)$，并且所有 $n$ 个买方都被匹配。\n- 算法要求：必须实现迭代价格调整机制。\n    - 初始价格：对所有 $j$，$p_j = 0$。\n    - 迭代：\n        - 基于所有 $i$ 的 $D_i(p)$ 构建一个二部需求图。\n        - 找到一个最大匹配。如果其大小为 $n$，则终止。\n        - 如果不是，则识别出可以从未匹配买方通过交替路径到达的买家集合 $B$ 和物品集合 $S$。\n        - 更新价格：对所有 $j \\in S$，令 $p_j \\leftarrow p_j + \\delta$，其中 $\\delta$ 是使得集合 $B$ 中至少一个买家对集合 $S$ 之外的某个物品产生新需求的最小正价格增量。\n- 验证要求：计算出的结果 $(u, p, \\mu)$ 必须对照核心条件进行检查。\n- 测试用例：提供了三个估值矩阵 $V^{(1)}$、$V^{(2)}$ 和 $V^{(3)}$。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学依据**：该问题设定在分配博弈的经典框架内，这是合作博弈论和机制设计中一个成熟的课题，源于 Shapley 和 Shubik 的工作。核心和竞争均衡的概念，以及它们在此背景下的等价性，是基本结论。所指定的迭代价格调整算法是著名拍卖算法（例如，由 Demange、Gale 和 Sotomayor 提出的算法）的一种变体，并且实际上是解决分配问题的原始-对偶方法。该问题是科学合理的。\n- **适定性**：该问题是适定的。它提供了所有必要的数据和一个完整但复杂的算法规范。对于这类博弈，核心分配（并因此存在竞争均衡）的存在性是有保证的。该算法是构造性的，并被设计为在均衡点终止。\n- **客观性**：该问题使用精确、客观的数学语言表述，没有任何主观或模棱两可的术语。\n\n**第三步：结论与行动**\n该问题被判定为**有效**。这是一个计算经济学中标准的、非平凡的问题，定义明确且具有科学依据。我将继续进行完整解答。\n\n该解决方案需要实现一个拍卖算法，为给定的分配市场寻找竞争均衡。一个均衡结果 $(u, p, \\mu)$ 被保证处于博弈的核心内。\n\n该算法按以下步骤进行：\n1.  **初始化**：所有物品的价格初始化为零。设 $p^{(0)} \\in \\mathbb{R}^m$ 为初始价格向量，对所有 $j \\in \\{1, \\dots, m\\}$，$p_j^{(0)} = 0$。设 $k=0$ 为迭代计数器。\n\n2.  **迭代调整**：算法进行离散迭代，直到找到一个完全匹配。在每次迭代 $k$ 中：\n    a. **构建需求图**：给定当前价格向量 $p^{(k)}$，每个买方 $i$ 计算其最大可能盈余，$s_i^* = \\max_{j \\in \\{1,\\dots,m\\}} \\{v_{ij} - p_j^{(k)}\\}$。买方 $i$ 的需求集为 $D_i(p^{(k)}) = \\{j \\mid v_{ij} - p_j^{(k)} \\ge s_i^* - \\epsilon\\}$，其中 $\\epsilon$ 是一个小的数值公差。形成一个二部图 $G^{(k)}$，当且仅当 $j \\in D_i(p^{(k)})$ 时，买方 $i$ 和物品 $j$ 之间存在一条边。\n\n    b. **最大匹配**：在图 $G^{(k)}$ 上计算最大匹配 $\\mu^{(k)}$。如果此匹配的大小为 $n$，则所有买方都在当前价格下被分配了一个他们需求的物品。算法已收敛。竞争均衡为 $(\\mu^{(k)}, p^{(k)})$。然后，效用被导出为 $u_i = v_{i, \\mu^{(k)}(i)} - p_{\\mu^{(k)}(i)}^{(k)}$，对每个买方 $i$ 均如此。过程终止。\n\n    c. **价格更新**：如果匹配大小小于 $n$，则至少存在一个未匹配的买方。设 $U^{(k)}$ 为被 $\\mu^{(k)}$ 留下的未匹配买方集合。我们必须识别市场瓶颈的来源并相应地调整价格。这通过以下方式实现：\n        i. **识别交替路径集**：我们找到买方集合 $B^{(k)}$ 和物品集合 $S^{(k)}$，这些集合中的元素可以从 $U^{(k)}$ 中的任何未匹配买方通过 $G^{(k)}$ 中相对于匹配 $\\mu^{(k)}$ 的交替路径到达。为此，使用一种遍历算法（如广度优先搜索），从 $U^{(k)}$ 中的所有买方开始。\n\n        ii. **计算价格增量**：计算价格增量 $\\delta^{(k)}$。此增量必须是使至少一个买方 $i \\in B^{(k)}$ 在其 $S^{(k)}$ 内的最佳选择与 $S^{(k)}$ 外的最佳选择之间变得无差异的最小值。其公式为：\n        $$ \\delta_i = \\left( \\max_{j \\in S^{(k)}} \\{v_{ij} - p_j^{(k)}\\} \\right) - \\left( \\max_{l \\notin S^{(k)}} \\{v_{il} - p_l^{(k)}\\} \\right) $$\n        总增量为 $\\delta^{(k)} = \\min_{i \\in B^{(k)}, \\delta_i > \\epsilon} \\{\\delta_i\\}$。\n\n        iii. **应用价格更新**：集合 $S^{(k)}$ 中所有物品的价格提高 $\\delta^{(k)}$，而其他价格保持不变。\n        $$\n        p_j^{(k+1)} =\n        \\begin{cases}\n        p_j^{(k)} + \\delta^{(k)} & \\text{if } j \\in S^{(k)} \\\\\n        p_j^{(k)} & \\text{if } j \\notin S^{(k)}\n        \\end{cases}\n        $$\n        迭代计数器增加，$k \\leftarrow k+1$，过程返回到步骤 2a。\n\n3.  **核心验证**：一旦算法以一个结果 $(u, p, \\mu)$ 终止，一个验证程序将确认它是一个有效的核心分配。\n    a. 对于每个买方 $i \\in \\{1, \\dots, n\\}$ 和每个物品 $j \\in \\{1, \\dots, m\\}$，必须满足 $u_i + p_j \\ge v_{ij} - \\epsilon$。\n    b. 对于每个匹配的买方 $i$，其匹配为 $\\mu(i) = j$，必须满足 $|(u_i + p_j) - v_{ij}| \\le \\epsilon$。\n    c. 匹配的买方数量必须恰好为 $n$。\n\n此程序被实现并应用于提供的三个测试用例。最终输出为每个用例的布尔值，表示计算出的结果是否成功通过核心验证。根据分配博弈的理论，该算法保证能找到一个核心分配，因此对所有有效输入，预期结果均为 true。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the assignment market problem for the given test cases.\n    \"\"\"\n    \n    TOL = 1e-9  # Numerical tolerance for float comparisons\n\n    def find_max_matching(demand_graph, n, m):\n        \"\"\"\n        Finds a maximum matching in a bipartite graph using augmenting paths with DFS.\n        The graph is represented by an adjacency list (dict).\n        \"\"\"\n        # item_match[j] = i means item j is matched to buyer i\n        item_match = {}\n        \n        def dfs(buyer, visited_items):\n            \"\"\"DFS to find an augmenting path.\"\"\"\n            for item in demand_graph.get(buyer, []):\n                if item not in visited_items:\n                    visited_items.add(item)\n                    # If item is not matched or its matched buyer can find another match\n                    if item not in item_match or dfs(item_match[item], visited_items):\n                        item_match[item] = buyer\n                        return True\n            return False\n\n        match_size = 0\n        for i in range(n):\n            visited_items = set()\n            if dfs(i, visited_items):\n                match_size += 1\n        \n        # buyer_match[i] = j means buyer i is matched to item j\n        buyer_match = {v: k for k, v in item_match.items()}\n        return buyer_match, item_match, match_size\n\n    def find_alternating_path_sets(unmatched_buyers, demand_graph, item_match, n, m):\n        \"\"\"\n        Finds sets B (buyers) and S (items) reachable from unmatched buyers via alternating paths.\n        Uses BFS for the traversal.\n        \"\"\"\n        B = set(unmatched_buyers)\n        S = set()\n        \n        queue = list(unmatched_buyers)\n        visited_buyers = set(unmatched_buyers)\n        visited_items = set()\n\n        head = 0\n        while head < len(queue):\n            buyer = queue[head]\n            head += 1\n\n            for item in demand_graph.get(buyer, []):\n                if item not in visited_items:\n                    visited_items.add(item)\n                    S.add(item)\n                    if item in item_match:\n                        next_buyer = item_match[item]\n                        if next_buyer not in visited_buyers:\n                            visited_buyers.add(next_buyer)\n                            B.add(next_buyer)\n                            queue.append(next_buyer)\n        return B, S\n\n    def solve_one_case(V):\n        \"\"\"\n        Implements the iterative price adjustment algorithm for one valuation matrix V.\n        \"\"\"\n        n, m = V.shape\n        p = np.zeros(m, dtype=float)\n\n        while True:\n            # 1. Construct demand graph\n            surplus = V - p\n            max_surpluses = np.max(surplus, axis=1)\n            \n            demand_graph = {}\n            for i in range(n):\n                demand_graph[i] = []\n                for j in range(m):\n                    if surplus[i, j] >= max_surpluses[i] - TOL:\n                        demand_graph[i].append(j)\n            \n            # 2. Find maximum matching\n            buyer_match, item_match, match_size = find_max_matching(demand_graph, n, m)\n\n            # 3. Check for termination\n            if match_size == n:\n                break\n            \n            # 4. Price update\n            unmatched_buyers = {i for i in range(n) if i not in buyer_match}\n            \n            B, S = find_alternating_path_sets(unmatched_buyers, demand_graph, item_match, n, m)\n            \n            if not S:\n                # This should not happen in a well-defined problem\n                raise RuntimeError(\"Stalled: No items reachable from unmatched buyers.\")\n\n            all_items = set(range(m))\n            items_not_in_S = all_items - S\n            \n            min_delta = float('inf')\n            for i in B:\n                # Surplus from items in S\n                max_surplus_in_S = -float('inf')\n                if S:\n                    max_surplus_in_S = np.max(V[i, list(S)] - p[list(S)])\n                \n                # Surplus from items not in S\n                max_surplus_not_in_S = -float('inf')\n                if items_not_in_S:\n                    max_surplus_not_in_S = np.max(V[i, list(items_not_in_S)] - p[list(items_not_in_S)])\n                \n                delta_i = max_surplus_in_S - max_surplus_not_in_S\n                if delta_i > TOL:\n                    min_delta = min(min_delta, delta_i)\n\n            if min_delta == float('inf'):\n                # This may happen if S contains all items.\n                # A uniform price increase on all goods doesn't change relative preference,\n                # but might be required if valuations are low.\n                # In this specific problem structure, it signals an issue or requires a different rule.\n                # However, for the given test cases, this is not expected.\n                raise RuntimeError(\"Cannot find a positive price increment.\")\n\n            p[list(S)] += min_delta\n\n        # Algorithm terminated, calculate utilities\n        u = np.zeros(n, dtype=float)\n        for i in range(n):\n            j = buyer_match[i]\n            u[i] = V[i, j] - p[j]\n        \n        return u, p, buyer_match\n        \n    def verify_core(V, u, p, mu, n, m):\n        \"\"\"\n        Verifies if the computed outcome (u, p, mu) is in the core.\n        - mu is buyer_match dictionary.\n        \"\"\"\n        # Condition 1: u_i + p_j >= v_ij for all i,j\n        for i in range(n):\n            for j in range(m):\n                if u[i] + p[j] < V[i, j] - TOL:\n                    return False\n        \n        # Condition 2: u_i + p_mu(i) = v_i,mu(i) for matched pairs\n        for i in range(n):\n            j = mu[i]\n            if abs((u[i] + p[j]) - V[i, j]) > TOL:\n                return False\n\n        # Condition 3: Full matching\n        if len(mu) != n:\n            return False\n            \n        return True\n\n    # Test suite\n    test_cases = [\n        np.array([[10, 8, 7], [7, 9, 9]]),\n        np.array([[5, 5, 1], [5, 4, 4], [4, 5, 4]]),\n        np.array([[1, 2, 0, 2], [2, 0, 2, 1], [0, 2, 1, 2]])\n    ]\n    \n    results = []\n    for V_case in test_cases:\n        n, m = V_case.shape\n        u, p, mu = solve_one_case(V_case)\n        is_in_core = verify_core(V_case, u, p, mu, n, m)\n        results.append(is_in_core)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}