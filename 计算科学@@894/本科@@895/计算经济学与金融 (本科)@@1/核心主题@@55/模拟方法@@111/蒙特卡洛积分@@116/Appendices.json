{"hands_on_practices": [{"introduction": "蒙特卡洛积分的核心思想是通过随机抽样来近似计算定积分，尤其在处理高维或复杂积分域问题时显示出其强大威力。本练习 [@problem_id:1376816] 提供了一个直观的场景：计算一个不规则区域内非均匀分布物质的总质量。通过对少数随机点进行评估，我们将体验蒙特卡洛方法如何将一个复杂的三重积分问题转化为简单的算术平均计算。", "id": "1376816", "problem": "一位材料科学家正在研究一种在边长为1米的立方体模具中制造的新型合金。坐标系与模具对齐，使其占据由 $0 \\le x \\le 1$，$0 \\le y \\le 1$ 和 $0 \\le z \\le 1$ 定义的区域。研究发现，一种特殊硬化剂的浓度 $C$ 仅在由不等式 $0 \\le z \\le y \\le x \\le 1$ 定义的模具特定子区域内为非零。在该子区域内，点 $(x,y,z)$ 处的浓度由函数 $C(x,y,z) = k x y z$ 描述，其中 $k$ 是一个常数。在该区域外，浓度为零。模具中硬化剂的总质量由浓度函数在整个1立方米模具体积上的积分给出。\n\n为估算此总质量，一个自动化测量系统在 $N=5$ 个样本点处探测浓度，这些点被假定为单位立方体内均匀随机抽样的代表。这五个点的坐标是：\n$P_1 = (0.8, 0.7, 0.2)$\n$P_2 = (0.9, 0.5, 0.6)$\n$P_3 = (0.6, 0.8, 0.3)$\n$P_4 = (0.5, 0.4, 0.3)$\n$P_5 = (0.7, 0.9, 0.8)$\n\n给定浓度常数 $k = 4.8 \\text{ kg/m}^6$，请根据这五个样本点计算模具中硬化剂总质量的数值估计值。以千克（kg）为单位表示答案，并四舍五入到三位有效数字。", "solution": "总质量是浓度在单位立方体上的体积分：\n$$\nM=\\iiint_{[0,1]^{3}} C(x,y,z)\\,dV.\n$$\n对于体积为 $V=1$ 的区域进行均匀随机抽样，使用 $N$ 个样本 $\\{P_{i}\\}_{i=1}^{N}$ 的蒙特卡洛估计量为\n$$\n\\widehat{M}=\\frac{V}{N}\\sum_{i=1}^{N} C(P_{i})=\\frac{1}{N}\\sum_{i=1}^{N} C(P_{i}).\n$$\n此处，如果 $0 \\le z \\le y \\le x \\le 1$，则 $C(x,y,z)=k\\,x y z$，否则 $C=0$。为每个样本点评估不等式 $0 \\le z \\le y \\le x \\le 1$：\n- $P_{1}=(0.8,0.7,0.2)$：$0.2 \\le 0.7 \\le 0.8 \\le 1$ 成立，因此贡献为 $k\\cdot 0.8\\cdot 0.7\\cdot 0.2=0.112\\,k$。\n- $P_{2}=(0.9,0.5,0.6)$：$0.6 \\le 0.5$ 不成立，贡献为 $0$。\n- $P_{3}=(0.6,0.8,0.3)$：$0.8 \\le 0.6$ 不成立，贡献为 $0$。\n- $P_{4}=(0.5,0.4,0.3)$：$0.3 \\le 0.4 \\le 0.5 \\le 1$ 成立，贡献为 $k\\cdot 0.5\\cdot 0.4\\cdot 0.3=0.06\\,k$。\n- $P_{5}=(0.7,0.9,0.8)$：$0.9 \\le 0.7$ 不成立，贡献为 $0$。\n因此\n$$\n\\sum_{i=1}^{5} C(P_{i})=(0.112+0.06)\\,k=0.172\\,k,\n$$\n并且\n$$\n\\widehat{M}=\\frac{1}{5}\\cdot 0.172\\,k=0.0344\\,k.\n$$\n将 $k=4.8$ 代入得\n$$\n\\widehat{M}=0.0344\\times 4.8=0.16512,\n$$\n四舍五入到三位有效数字后为 $0.165$ 千克。", "answer": "$$\\boxed{0.165}$$"}, {"introduction": "基础蒙特卡洛方法的收敛速度可能很慢，尤其当被积函数在积分域内变化剧烈时。为了提高效率，我们可以使用重要性采样技术，将采样点集中在对积分贡献最大的“重要”区域。本练习 [@problem_id:2414609] 将通过分析对比，让你深入理解重要性采样如何减少估计量的方差，并警示一个关键点：一个糟糕的采样分布选择甚至可能导致比原始方法更差的结果。", "id": "2414609", "problem": "考虑一个非负被积函数在有限区间上的积分。设目标积分为\n$$\nI = \\int_{0}^{1} f(x)\\,dx,\n$$\n其中 $f(x) = x^{m}$，$m$ 为满足 $m > -1$ 的固定指数。定义粗略蒙特卡洛估计量为随机变量 $Y_{\\mathrm{c}} = f(U)$，其中 $U \\sim \\mathrm{Uniform}(0,1)$；并定义重要性抽样估计量为 $Y_{\\mathrm{is}} = f(X)/p(X)$，其在 $[0,1]$ 上的概率密度函数为 $p(x)$，其中 $X \\sim p$。根据定义，这些无偏估计量的方差为\n$$\n\\mathrm{Var}(Y_{\\mathrm{c}}) = \\mathbb{E}[Y_{\\mathrm{c}}^{2}] - I^{2}, \\qquad \\mathrm{Var}(Y_{\\mathrm{is}}) = \\mathbb{E}[Y_{\\mathrm{is}}^{2}] - I^{2}.\n$$\n对于重要性抽样密度，考虑在 $[0,1]$ 上参数为 $\\alpha > 0$ 和 $\\beta > 0$ 的 Beta 分布，\n$$\np(x) = \\frac{x^{\\alpha - 1}(1 - x)^{\\beta - 1}}{B(\\alpha,\\beta)},\n$$\n其中 $B(\\alpha,\\beta)$ 是 Beta 函数。假设参数的选择使所有量均为有限值；特别地，假设 $\\beta < 2$ 和 $\\alpha < 2m + 2$ 以确保 $\\mathbb{E}[Y_{\\mathrm{is}}^{2}]$ 存在。\n\n对于以下测试套件中的每一组参数 $(m,\\alpha,\\beta)$，计算比率\n$$\nr = \\frac{\\mathrm{Var}(Y_{\\mathrm{is}})}{\\mathrm{Var}(Y_{\\mathrm{c}})},\n$$\n并按指定格式生成结果。\n\n测试套件（每个三元组为 $(m,\\alpha,\\beta)$）：\n\n- 案例 1：$(2,\\tfrac{1}{2},\\tfrac{3}{2})$。\n- 案例 2：$(2,1,1)$。\n- 案例 3：$(2,\\tfrac{5}{2},1)$。\n- 案例 4：$(2,3,1)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含按上述顺序列出的各案例的结果，形式为方括号括起来的逗号分隔列表（例如 $[r_{1},r_{2}]$）。每个数字必须四舍五入到 $6$ 位小数。不应打印任何额外文本。", "solution": "该问题要求计算比率 $r = \\mathrm{Var}(Y_{\\mathrm{is}})/\\mathrm{Var}(Y_{\\mathrm{c}})$，其中 $\\mathrm{Var}(Y_{\\mathrm{c}})$ 是粗略蒙特卡洛估计量的方差，$\\mathrm{Var}(Y_{\\mathrm{is}})$ 是重要性抽样估计量的方差，两者都用于计算积分 $I = \\int_{0}^{1} f(x)\\,dx$，$f(x) = x^{m}$。分析过程首先推导每种方差的解析表达式。\n\n首先，我们计算积分 $I$ 的精确值。对于 $m > -1$：\n$$\nI = \\int_{0}^{1} x^{m} \\, dx = \\left[ \\frac{x^{m+1}}{m+1} \\right]_{0}^{1} = \\frac{1}{m+1}\n$$\n\n接下来，我们推导粗略蒙特卡洛估计量 $Y_{\\mathrm{c}} = f(U) = U^m$ 的方差，其中 $U \\sim \\mathrm{Uniform}(0,1)$。方差定义为 $\\mathrm{Var}(Y_{\\mathrm{c}}) = \\mathbb{E}[Y_{\\mathrm{c}}^{2}] - I^{2}$。二阶矩 $\\mathbb{E}[Y_{\\mathrm{c}}^{2}]$ 为：\n$$\n\\mathbb{E}[Y_{\\mathrm{c}}^{2}] = \\mathbb{E}[(U^m)^2] = \\mathbb{E}[U^{2m}] = \\int_{0}^{1} u^{2m} \\cdot 1 \\, du = \\frac{1}{2m+1}\n$$\n这要求 $2m+1 > 0$，即 $m > -1/2$。给定的条件 $m > -1$ 和测试用例 $m=2$ 满足此要求。因此，方差为：\n$$\n\\mathrm{Var}(Y_{\\mathrm{c}}) = \\frac{1}{2m+1} - \\left(\\frac{1}{m+1}\\right)^2 = \\frac{(m+1)^2 - (2m+1)}{(2m+1)(m+1)^2} = \\frac{m^2 + 2m + 1 - 2m - 1}{(2m+1)(m+1)^2} = \\frac{m^2}{(2m+1)(m+1)^2}\n$$\n\n现在，我们推导重要性抽样估计量 $Y_{\\mathrm{is}} = f(X)/p(X)$ 的方差，其中 $X$ 从密度为 $p(x) = x^{\\alpha - 1}(1 - x)^{\\beta - 1} / B(\\alpha, \\beta)$ 的 Beta 分布中抽取。方差为 $\\mathrm{Var}(Y_{\\mathrm{is}}) = \\mathbb{E}[Y_{\\mathrm{is}}^{2}] - I^{2}$。二阶矩 $\\mathbb{E}[Y_{\\mathrm{is}}^{2}]$ 的计算如下：\n$$\n\\mathbb{E}[Y_{\\mathrm{is}}^{2}] = \\int_{0}^{1} \\left(\\frac{f(x)}{p(x)}\\right)^2 p(x) \\, dx = \\int_{0}^{1} \\frac{f(x)^2}{p(x)} \\, dx\n$$\n代入 $f(x) = x^m$ 和密度 $p(x)$：\n$$\n\\mathbb{E}[Y_{\\mathrm{is}}^{2}] = \\int_{0}^{1} \\frac{(x^m)^2}{\\frac{x^{\\alpha - 1}(1 - x)^{\\beta - 1}}{B(\\alpha, \\beta)}} \\, dx = B(\\alpha, \\beta) \\int_{0}^{1} x^{2m - \\alpha + 1} (1 - x)^{1 - \\beta} \\, dx\n$$\n该积分为 Beta 函数积分形式，$B(a,b) = \\int_0^1 t^{a-1}(1-t)^{b-1}dt$。我们相应地重写被积函数的指数：\n$$\n\\mathbb{E}[Y_{\\mathrm{is}}^{2}] = B(\\alpha, \\beta) \\int_{0}^{1} x^{(2m - \\alpha + 2) - 1} (1 - x)^{(2 - \\beta) - 1} \\, dx\n$$\n此积分等于 $B(2m - \\alpha + 2, 2 - \\beta)$。问题约束条件 $\\alpha < 2m + 2$ 和 $\\beta < 2$ 保证了该积分的存在性。因此，二阶矩为：\n$$\n\\mathbb{E}[Y_{\\mathrm{is}}^{2}] = B(\\alpha, \\beta) B(2m - \\alpha + 2, 2 - \\beta)\n$$\n重要性抽样估计量的方差为：\n$$\n\\mathrm{Var}(Y_{\\mathrm{is}}) = B(\\alpha, \\beta) B(2m - \\alpha + 2, 2 - \\beta) - \\frac{1}{(m+1)^2}\n$$\n\n最后，比率 $r$ 由以下通用公式给出：\n$$\nr = \\frac{\\mathrm{Var}(Y_{\\mathrm{is}})}{\\mathrm{Var}(Y_{\\mathrm{c}})} = \\frac{B(\\alpha, \\beta) B(2m - \\alpha + 2, 2 - \\beta) - \\frac{1}{(m+1)^2}}{\\frac{m^2}{(2m+1)(m+1)^2}}\n$$\n\n对于所有测试用例，指数均为 $m=2$。我们可以将公式具体化：\n$I = \\frac{1}{2+1} = \\frac{1}{3}$。\n$\\mathrm{Var}(Y_{\\mathrm{c}}) = \\frac{2^2}{(2(2)+1)(2+1)^2} = \\frac{4}{5 \\cdot 9} = \\frac{4}{45}$。\n当 $m=2$ 时，比率 $r$ 变为：\n$$\nr = \\frac{B(\\alpha, \\beta) B(6 - \\alpha, 2 - \\beta) - \\frac{1}{9}}{\\frac{4}{45}} = \\frac{45}{4} \\left( B(\\alpha, \\beta) B(6 - \\alpha, 2 - \\beta) - \\frac{1}{9} \\right)\n$$\n\n现在我们为每个测试用例计算比率。\n\n案例 1：$(m,\\alpha,\\beta) = (2, \\frac{1}{2}, \\frac{3}{2})$。\n我们有 $\\alpha = 0.5$ 且 $\\beta = 1.5$。\n$r = \\frac{45}{4} \\left( B(0.5, 1.5) B(5.5, 0.5) - \\frac{1}{9} \\right)$。\n使用关系式 $B(x,y) = \\frac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}$：\n$B(0.5, 1.5) = B(\\frac{1}{2}, \\frac{3}{2}) = \\frac{\\Gamma(1/2)\\Gamma(3/2)}{\\Gamma(2)} = \\frac{\\sqrt{\\pi} \\cdot (1/2)\\sqrt{\\pi}}{1!} = \\frac{\\pi}{2}$。\n$B(5.5, 0.5) = B(\\frac{11}{2}, \\frac{1}{2}) = \\frac{\\Gamma(11/2)\\Gamma(1/2)}{\\Gamma(6)} = \\frac{(945/32)\\sqrt{\\pi} \\cdot \\sqrt{\\pi}}{5!} = \\frac{945\\pi}{32 \\cdot 120} = \\frac{63\\pi}{256}$。\n$r = \\frac{45}{4} \\left( \\frac{\\pi}{2} \\cdot \\frac{63\\pi}{256} - \\frac{1}{9} \\right) = \\frac{45}{4} \\frac{63\\pi^2}{512} - \\frac{45}{36} = \\frac{2835\\pi^2}{2048} - \\frac{5}{4} = \\frac{2835\\pi^2 - 2560}{2048}$。\n其数值约为 $12.408172$。\n\n案例 2：$(m,\\alpha,\\beta) = (2, 1, 1)$。\n此处，$\\alpha=1, \\beta=1$，因此 $p(x) = \\frac{x^0(1-x)^0}{B(1,1)} = 1$，即均匀分布。重要性抽样方案与粗略蒙特卡洛方案相同。因此，$\\mathrm{Var}(Y_{\\mathrm{is}}) = \\mathrm{Var}(Y_{\\mathrm{c}})$，比率 $r$ 必须为 $1$。\n用公式验证：\n$r = \\frac{45}{4} \\left( B(1, 1) B(5, 1) - \\frac{1}{9} \\right) = \\frac{45}{4} \\left( 1 \\cdot \\frac{1}{5} - \\frac{1}{9} \\right) = \\frac{45}{4} \\left( \\frac{1}{5} - \\frac{1}{9} \\right) = \\frac{45}{4} \\left( \\frac{9-5}{45} \\right) = \\frac{45}{4} \\frac{4}{45} = 1$。\n\n案例 3：$(m,\\alpha,\\beta) = (2, \\frac{5}{2}, 1)$。\n我们有 $\\alpha = 2.5$ 且 $\\beta = 1$。$B(a,1)$ 的公式为 $1/a$。\n$r = \\frac{45}{4} \\left( B(2.5, 1) B(3.5, 1) - \\frac{1}{9} \\right) = \\frac{45}{4} \\left( \\frac{1}{2.5} \\cdot \\frac{1}{3.5} - \\frac{1}{9} \\right) = \\frac{45}{4} \\left( \\frac{2}{5} \\cdot \\frac{2}{7} - \\frac{1}{9} \\right)$。\n$r = \\frac{45}{4} \\left( \\frac{4}{35} - \\frac{1}{9} \\right) = \\frac{45}{4} \\left( \\frac{36 - 35}{315} \\right) = \\frac{45}{4 \\cdot 315} = \\frac{1}{4 \\cdot 7} = \\frac{1}{28}$。\n其数值约为 $0.035714$。\n\n案例 4：$(m,\\alpha,\\beta) = (2, 3, 1)$。\n此处，$\\alpha = 3$ 且 $\\beta = 1$。抽样密度为 $p(x) = \\frac{x^{3-1}}{B(3,1)} = \\frac{x^2}{1/3} = 3x^2$。被积函数为 $f(x)=x^2$。由于 $p(x) \\propto f(x)$，估计量 $Y_{\\mathrm{is}} = \\frac{f(X)}{p(X)} = \\frac{X^2}{3X^2} = \\frac{1}{3}$ 是一个常数。常数的方差为零。因此，$r=0$。\n用公式验证：\n$r = \\frac{45}{4} \\left( B(3, 1) B(3, 1) - \\frac{1}{9} \\right) = \\frac{45}{4} \\left( \\frac{1}{3} \\cdot \\frac{1}{3} - \\frac{1}{9} \\right) = \\frac{45}{4} \\left( \\frac{1}{9} - \\frac{1}{9} \\right) = 0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import beta\n\ndef solve():\n    \"\"\"\n    Computes the ratio of variances for importance sampling vs. crude Monte Carlo\n    for the integral of f(x) = x^m from 0 to 1.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 0.5, 1.5),  # Case 1\n        (2, 1, 1),      # Case 2\n        (2, 2.5, 1),    # Case 3\n        (2, 3, 1)       # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        m, alpha, beta_p = case\n\n        # General formula for the variance of the crude Monte Carlo estimator.\n        # Var(Y_c) = E[f(U)^2] - I^2 = integral(x^(2m))dx - (integral(x^m)dx)^2\n        #          = 1/(2m+1) - 1/((m+1)^2)\n        #          = m^2 / ((2m+1)*(m+1)^2)\n        var_c = m**2 / ((2 * m + 1) * (m + 1)**2)\n\n        # General formula for the variance of the importance sampling estimator.\n        # Var(Y_is) = E[(f(X)/p(X))^2] - I^2 = integral(f(x)^2/p(x))dx - I^2\n        #           = B(alpha, beta) * B(2m - alpha + 2, 2 - beta) - 1/((m+1)^2)\n        # The conditions m > -1, alpha > 0, beta > 0, alpha < 2m+2, beta < 2 are met.\n        term1 = beta(alpha, beta_p)\n        term2 = beta(2 * m - alpha + 2, 2 - beta_p)\n        var_is = term1 * term2 - 1 / ((m + 1)**2)\n        \n        # The ratio r = Var(Y_is) / Var(Y_c).\n        # var_c is non-zero since m=2 is used in all test cases.\n        ratio = var_is / var_c\n        \n        results.append(ratio)\n\n    # Format the results to 6 decimal places as required.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "蒙特卡洛方法的应用远不止于计算传统的微积分积分，它更是解决经济金融领域复杂期望问题的利器。例如，在合作博弈论中，如何公平地为团队成员分配价值（股权）是一个核心问题，其答案便是夏普利值（Shapley value）。本练习 [@problem_id:2411557] 将指导你如何通过模拟参与者加入团队的随机顺序，来估算每位创始人的边际贡献期望，从而计算出他们的夏普利值，完美展示了计算方法在经济建模中的强大应用。", "id": "2411557", "problem": "一家初创公司的创始团队决定，在一个通过合作博弈论形式化的合作生产环境中，根据每位创始人的边际贡献来分配股权。设 $N=\\{1,\\dots,n\\}$ 为创始人集合，并设 $v:2^N \\to \\mathbb{R}_{\\ge 0}$ 为一个特征函数，该函数将每个联盟 $S \\subseteq N$ 映射到一个非负实数值产出。对于创始人 $i \\in N$，其 Shapley 值 $\\phi_i(v)$ 被定义为当创始人以均匀随机顺序到达时，$i$ 对其前辈所组成的联盟的期望边际贡献。使用蒙特卡洛（MC）模拟，通过从“$N$的所有排列”的均匀分布中抽取独立的排列样本，计算每个样本的边际贡献，然后取平均值，来近似计算每位创始人的 Shapley 值。\n\n使用的基本原则：\n- 合作博弈定义：价值函数 $v$ 为每个联盟 $S \\subseteq N$ 分配一个明确定义的收益，且 $v(\\varnothing)=0$。\n- 通过排列定义的 Shapley 值：对于任何 $i \\in N$，\n$$\n\\phi_i(v)=\\mathbb{E}_{\\pi}\\left[v\\!\\left(P_i^{\\pi}\\cup\\{i\\}\\right)-v\\!\\left(P_i^{\\pi}\\right)\\right],\n$$\n其中 $\\pi$ 是 $N$ 的一个均匀随机排列，而 $P_i^{\\pi}$ 是在排列 $\\pi$ 中位于 $i$ 之前的参与者集合。\n- 蒙特卡洛积分（样本均值近似）：如果 $X_1,\\dots,X_M$ 是从一个均值为有限值 $\\mu$ 的分布中抽取的独立同分布（i.i.d.）样本，那么根据大数定律，当 $M \\to \\infty$ 时，样本均值 $\\frac{1}{M}\\sum_{m=1}^M X_m$ 收敛于 $\\mu$。\n\n算法任务：\n- 对于下述每个测试用例，通过抽取 $M$ 个独立同分布的排列，计算每个排列中每个位置的边际贡献，并取平均值，来估计 Shapley 值向量 $\\phi(v)=(\\phi_1(v),\\dots,\\phi_n(v))$。为确保可复现性，请使用指定的伪随机种子。以任何便捷的方式（例如，位掩码）表示联盟。如有帮助，可预先计算价值函数在所有联盟 $S \\subseteq N$ 上的值。\n\n所有测试通用的数值设置：\n- 对于每个测试用例，从 $n!$ 个可能的排列中均匀抽取恰好 $M=100000$ 个独立同分布的排列。\n- 在每个测试用例开始时，为伪随机数生成器使用指定的种子 $s$。\n- 报告估计的 Shapley 值的每个分量，四舍五入到恰好 $6$ 位小数。\n- 不涉及物理单位。所有输出均为实数。\n\n测试套件：\n- 测试 A（加性，基准“理想路径”）：设 $n=3$。设 $a=(0.2,0.3,0.5)$。定义\n$$\nv_A(S)=\\sum_{i\\in S} a_i,\n$$\n且 $v_A(\\varnothing)=0$。使用种子 $s_A=314159$。\n- 测试 B（具有收益递减的成对协同效应）：设 $n=4$。设 $a=(0.8,0.6,0.4,0.2)$ 和对称的成对协同矩阵 $B=(b_{ij})$，其中 $b_{ii}=0$ 且非零项为\n$$\nb_{12}=0.3,\\quad b_{13}=0.05,\\quad b_{23}=0.1,\\quad b_{34}=0.2,\n$$\n具有对称性 $b_{ij}=b_{ji}$ 且所有其他 $b_{ij}=0$。定义\n$$\nv_B(S)=\\log\\!\\Big(1+\\sum_{i\\in S} a_i+\\sum_{i<j,\\, i,j\\in S} b_{ij}\\Big),\n$$\n其中 $\\log$ 表示自然对数，且 $v_B(\\varnothing)=0$。使用种子 $s_B=271828$。\n- 测试 C（阈值产出，零贡献创始人的边缘案例）：设 $n=4$。设 $a=(0.4,0.35,0.25,0.0)$ 且阈值 $T=0.9$。定义\n$$\nv_C(S)=\\max\\!\\Big(0,\\sum_{i\\in S} a_i - T\\Big),\n$$\n且 $v_C(\\varnothing)=0$。使用种子 $s_C=161803$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其格式为类 JSON 的列表之列表。该行必须包含三个内部列表，按 A、B、C 的顺序每个测试用例对应一个。每个内部列表必须包含该测试用例的 $n$ 个估计 Shapley 值，每个值都四舍五入到 $6$ 位小数，且不含空格。例如，结构形式必须是：\n- 外部列表：左方括号，以逗号分隔的内部列表，右方括号，\n- 内部列表：左方括号，以逗号分隔的 $n$ 个实数，右方括号。", "solution": "问题陈述被解析并确定为有效。它在科学上基于合作博弈论和数值分析，问题适定，所有必要参数均已定义，并以客观、正式的语言表述。不存在矛盾、歧义或不成立的前提。该任务是实现一个标准的蒙特卡洛模拟来估计 Shapley 值，这是一个明确定义的计算问题。\n\n该解决方案的理论基础是针对具有特征函数 $v$ 的合作博弈中的参与者 $i$ 的 Shapley 值 $\\phi_i(v)$ 的定义。$\\phi_i(v)$ 值代表了由大联盟 $N$ 产生的总盈余的公平分配，它由一组公理（有效性、对称性、零人性和可加性）唯一确定。一个等价且在计算上很有用的定义是基于对参与者随机排序的期望。具体而言，参与者 $i$ 的 Shapley 值是参与者 $i$ 对其前面参与者所组成的联盟的期望边际贡献，该期望是在参与者集合 $N$ 的所有可能排列上取平均得到的。该期望是针对 $n!$ 个可能排列上的均匀概率分布计算的。\n\n$$\n\\phi_i(v)=\\mathbb{E}_{\\pi}\\left[v(P_i^{\\pi}\\cup\\{i\\}) - v(P_i^{\\pi})\\right]\n$$\n\n此处，$\\pi$ 是从 $N=\\{1, \\dots, n\\}$ 中均匀随机选择的一个排列，而 $P_i^{\\pi}$ 是在排列 $\\pi$ 中出现在参与者 $i$ 之前的参与者集合。\n\n直接枚举所有 $n!$ 个排列即使对于中等大小的 $n$ 在计算上也是不可行的。因此，我们采用蒙特卡洛方法。根据大数定律，随机变量 $X$ 的期望 $\\mathbb{E}[X]$ 可以通过对 $X$ 进行大量独立同分布（i.i.d.）抽样并计算样本均值来近似。在此背景下，对于一个随机选择的排列 $\\pi$，参与者 $i$ 的随机变量是其边际贡献 $X_i(\\pi) = v(P_i^{\\pi}\\cup\\{i\\}) - v(P_i^{\\pi})$。我们生成大量（$M$ 个）独立同分布的随机排列 $\\pi_1, \\pi_2, \\dots, \\pi_M$。然后通过样本均值来估计 Shapley 值 $\\phi_i(v)$：\n\n$$\n\\hat{\\phi}_i(v) = \\frac{1}{M} \\sum_{m=1}^{M} \\left[ v(P_i^{\\pi_m}\\cup\\{i\\}) - v(P_i^{\\pi_m}) \\right]\n$$\n\n对于每个由参与者数量 $n$、特征函数 $v$、伪随机种子 $s$ 和蒙特卡洛样本数量 $M=100000$ 定义的测试用例，算法按以下步骤进行。\n\n1.  **初始化**：为了可复现性，使用指定的种子 $s$ 初始化伪随机数生成器。将一个大小为 $n$ 的数组 `total_contributions` 初始化为全零。此数组将用于累加每个参与者在所有抽样排列中的边际贡献。\n\n2.  **特征函数的预计算**：当参与者数量 $n$ 较小时，不同联盟的数量 $2^n$ 是可控的。为优化模拟，我们预先计算每个可能联盟 $S \\subseteq N$ 的值 $v(S)$。联盟可以使用整数位掩码高效地表示，其中从 $0$ 到 $2^n-1$ 的整数 $k$ 代表一个联盟。如果参与者 $j$（使用从0开始的索引）在联盟中，则 $k$ 的第 $j$ 位为 $1$，否则为 $0$。填充一个大小为 $2^n$ 的表 `v_values`，使得 `v_values[k]` 存储值 $v(S_k)$，其中 $S_k$ 是与掩码 $k$ 对应的联盟。\n\n3.  **蒙特卡洛模拟循环**：主循环迭代 $M$ 次。在每次迭代 $m=1, \\dots, M$ 中：\n    a. 使用初始化的随机数生成器生成参与者 $\\{0, 1, \\dots, n-1\\}$ 的一个新随机排列 $\\pi_m$。\n    b. 我们按照 $\\pi_m$ 指定的顺序遍历参与者。维护一个变量 `predecessor_mask`，初始值为 $0$（表示空集 $v(\\varnothing)=0$）。\n    c. 对于排列 $\\pi_m$ 中的每个参与者 $i$，计算其边际贡献。前辈联盟 $P_i^{\\pi_m}$ 由 `predecessor_mask` 表示。从预计算的表中以 `v_values[predecessor_mask]` 查找到值 $v(P_i^{\\pi_m})$。\n    d. 通过在 `predecessor_mask` 中设置第 $i$ 位来形成新联盟 $S' = P_i^{\\pi_m} \\cup \\{i\\}$。然后查找值 $v(S')$。\n    e. 计算边际贡献 $\\Delta_i = v(S') - v(P_i^{\\pi_m})$，并将其加到 `total_contributions[i]` 中。\n    f. 更新 `predecessor_mask` 以包含参与者 $i$，为排列中的下一个参与者做准备。\n\n4.  **最终估计**：循环完成后，通过将累积的总边际贡献除以样本数 $M$ 来计算每个参与者 $i$ 的估计 Shapley 值：$\\hat{\\phi}_i(v) = \\text{total\\_contributions}[i] / M$。\n\n这个通用算法应用于三个测试用例中的每一个，在预计算步骤中使用它们各自特定的特征函数：\n\n-   **测试 A**：$n=3$, $a=(0.2,0.3,0.5)$, $v_A(S)=\\sum_{i\\in S} a_i$。这是一个加性博弈，其解析 Shapley 值为 $\\phi_i(v_A) = a_i$。蒙特卡洛估计值应非常接近 $(0.2, 0.3, 0.5)$。\n\n-   **测试 B**：$n=4$, $a=(0.8,0.6,0.4,0.2)$, $B$ 是一个对称协同矩阵。函数 $v_B(S)=\\log(1+\\sum_{i\\in S} a_i+\\sum_{i<j,\\, i,j\\in S} b_{ij})$ 模拟了个人贡献和具有收益递减（由自然对数捕获）的成对协同效应。\n\n-   **测试 C**：$n=4$, $a=(0.4,0.35,0.25,0.0)$, $T=0.9$。函数 $v_C(S)=\\max(0,\\sum_{i\\in S} a_i - T)$ 代表一个阈值项目。注意，参与者 4（索引为 3）的个人贡献为 $a_4=0.0$。因此，其边际贡献始终为 $v_C(S \\cup \\{4\\}) - v_C(S) = \\max(0, \\sum_{i \\in S} a_i - T) - \\max(0, \\sum_{i \\in S} a_i - T) = 0$。所以，其解析 Shapley 值为 $\\phi_4(v_C) = 0.0$，这为实现提供了一个明确的检验。\n\n最终结果四舍五入到 6 位小数，并按指定格式进行格式化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem by running Monte Carlo simulations for each test case.\n    \"\"\"\n\n    def estimate_shapley_values(n, v_func, M, seed):\n        \"\"\"\n        Estimates Shapley values for a given game using Monte Carlo simulation.\n\n        Args:\n            n (int): Number of players.\n            v_func (function): The characteristic function v(S_mask).\n            M (int): Number of Monte Carlo samples (permutations).\n            seed (int): Seed for the pseudo-random number generator.\n\n        Returns:\n            np.ndarray: An array of estimated Shapley values for each player.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        \n        # 1. Pre-compute characteristic function values for all 2^n coalitions\n        num_coalitions = 1 << n\n        v_values = np.zeros(num_coalitions, dtype=float)\n        for mask in range(num_coalitions):\n            v_values[mask] = v_func(mask, n)\n\n        # 2. Monte Carlo simulation\n        total_marginal_contributions = np.zeros(n, dtype=float)\n        players = np.arange(n)\n\n        for _ in range(M):\n            # Generate a random permutation of players\n            perm = rng.permutation(players)\n            \n            predecessor_mask = 0\n            for player in perm:\n                # Marginal contribution of 'player' to the coalition of its predecessors\n                # Value of coalition without the player\n                v_predecessors = v_values[predecessor_mask]\n\n                # Value of coalition with the player\n                new_coalition_mask = predecessor_mask | (1 << player)\n                v_with_player = v_values[new_coalition_mask]\n\n                marginal_contribution = v_with_player - v_predecessors\n                total_marginal_contributions[player] += marginal_contribution\n\n                # Add player to the coalition for the next iteration\n                predecessor_mask = new_coalition_mask\n\n        # 3. Average the contributions to get the Shapley value estimates\n        shapley_values = total_marginal_contributions / M\n        return shapley_values\n\n    # Common numerical settings\n    M = 100000\n\n    # Test Case A\n    n_A = 3\n    a_A = np.array([0.2, 0.3, 0.5])\n    seed_A = 314159\n    def v_A(mask, n):\n        val = 0.0\n        for i in range(n):\n            if (mask >> i) & 1:\n                val += a_A[i]\n        return val\n\n    # Test Case B\n    n_B = 4\n    a_B = np.array([0.8, 0.6, 0.4, 0.2])\n    B = np.zeros((n_B, n_B))\n    B[0, 1] = B[1, 0] = 0.3\n    B[0, 2] = B[2, 0] = 0.05\n    B[1, 2] = B[2, 1] = 0.1\n    B[2, 3] = B[3, 2] = 0.2\n    seed_B = 271828\n    def v_B(mask, n):\n        sum_a = 0.0\n        sum_b = 0.0\n        players_in_coalition = []\n        for i in range(n):\n            if (mask >> i) & 1:\n                sum_a += a_B[i]\n                players_in_coalition.append(i)\n        \n        for i in range(len(players_in_coalition)):\n            for j in range(i + 1, len(players_in_coalition)):\n                p1 = players_in_coalition[i]\n                p2 = players_in_coalition[j]\n                sum_b += B[p1, p2]\n                \n        return np.log(1.0 + sum_a + sum_b)\n\n    # Test Case C\n    n_C = 4\n    a_C = np.array([0.4, 0.35, 0.25, 0.0])\n    T_C = 0.9\n    seed_C = 161803\n    def v_C(mask, n):\n        sum_a = 0.0\n        for i in range(n):\n            if (mask >> i) & 1:\n                sum_a += a_C[i]\n        return max(0.0, sum_a - T_C)\n\n    test_cases = [\n        {'n': n_A, 'v_func': v_A, 'seed': seed_A},\n        {'n': n_B, 'v_func': v_B, 'seed': seed_B},\n        {'n': n_C, 'v_func': v_C, 'seed': seed_C},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        shapley_values = estimate_shapley_values(case['n'], case['v_func'], M, case['seed'])\n        \n        # Format results to 6 decimal places\n        formatted_results = [f\"{val:.6f}\" for val in shapley_values]\n        all_results.append(f\"[{','.join(formatted_results)}]\")\n\n    # Print the final output in the required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n\n```"}]}