{"hands_on_practices": [{"introduction": "金融中的许多基础模型都始于对资产价格路径的建模。这个练习将指导你使用几何布朗运动（GBM）——一个金融学中的基石模型——来生成数千条可能的资产价格轨迹。通过这样做，你将亲手计算并分析“最大回撤”（Maximum Drawdown），这是一个衡量从峰值到谷底最大跌幅的关键风险指标，是任何量化风险管理者的必备技能。通过这个实践，你将掌握蒙特卡洛模拟在金融风险分析中的核心应用 [@problem_id:2403314]。", "id": "2403314", "problem": "考虑一个投资组合，其价值过程通过连续时间的几何布朗运动 (GBM) 进行建模。令 $S_t$ 表示在时间 $t \\in [0,T]$ 时的投资组合价值，初始水平为 $S_0 \\gt 0$。该过程满足随机微分方程 $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$，其中 $\\mu \\in \\mathbb{R}$ 是漂移率，$\\sigma \\ge 0$ 是波动率，而 $(W_t)_{t \\ge 0}$ 是一个标准布朗运动。在一个均匀的时间网格 $t_k = k \\Delta t$（对于 $k \\in \\{0,1,\\dots,n\\}$，其中 $\\Delta t = T/n$）上，假设 GBM 具有精确的有限期增量属性：对于每个 $k \\in \\{0,1,\\dots,n-1\\}$，对数回报率 $\\log\\left(\\frac{S_{t_{k+1}}}{S_{t_k}}\\right)$ 服从正态分布，其均值为 $(\\mu - \\tfrac{1}{2}\\sigma^2)\\Delta t$，方差为 $\\sigma^2 \\Delta t$，并且在不同的 $k$ 和不同的模拟路径之间相互独立。\n\n定义网格上的运行最大值为 $M_{t_k} = \\max_{0 \\le j \\le k} S_{t_j}$，在时间 $t_k$ 的回撤为 $D_{t_k} = 1 - \\frac{S_{t_k}}{M_{t_k}}$。一条路径在 $[0,T]$ 上的最大回撤为 $\\mathrm{MDD} = \\max_{0 \\le k \\le n} D_{t_k}$。本问题中所有的回撤都必须以小数形式表示，而不是使用百分号。\n\n对于下述测试套件中的每一组参数，独立模拟 $N_{\\text{paths}}$ 条样本路径，并在指定的网格上，从所得的最大回撤样本 $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$ 中计算：\n- 样本均值 $\\widehat{\\mathbb{E}}[\\mathrm{MDD}] = \\frac{1}{N_{\\text{paths}}}\\sum_{i=1}^{N_{\\text{paths}}} \\mathrm{MDD}^{(i)}$。\n- 在阈值 $d^\\star$ 处的超额概率，定义为 $\\widehat{\\mathbb{P}}(\\mathrm{MDD} \\ge d^\\star) = \\frac{1}{N_{\\text{paths}}}\\sum_{i=1}^{N_{\\text{paths}}} \\mathbf{1}\\{\\mathrm{MDD}^{(i)} \\ge d^\\star\\}$。\n- 在概率水平 $q$ 处的经验上分位数，记为 $Q_q$，定义为集合 $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$ 的 $q$ 阶样本分位数。\n\n为保证可复现性，在模拟每个案例时，请使用为该案例指定的精确整数随机种子。不涉及物理单位。不使用角度。所有要求的输出必须是实数。\n\n参数集测试套件，其中每个元组列出了 $(S_0,\\mu,\\sigma,T,n,N_{\\text{paths}},d^\\star,q,\\text{seed})$：\n- 案例 1：$(100,\\ 0.05,\\ 0.20,\\ 1.0,\\ 252,\\ 8000,\\ 0.20,\\ 0.95,\\ 202311)$。\n- 案例 2：$(100,\\ 0.05,\\ 0.0001,\\ 1.0,\\ 252,\\ 8000,\\ 0.01,\\ 0.95,\\ 202312)$。\n- 案例 3：$(100,\\ 0.00,\\ 0.60,\\ 1.0,\\ 252,\\ 8000,\\ 0.50,\\ 0.95,\\ 202313)$。\n- 案例 4：$(100,\\ -0.10,\\ 0.25,\\ 2.0,\\ 504,\\ 8000,\\ 0.30,\\ 0.95,\\ 202314)$。\n- 案例 5：$(100,\\ 0.02,\\ 0.15,\\ 0.25,\\ 63,\\ 8000,\\ 0.10,\\ 0.95,\\ 202315)$。\n\n您的程序必须生成单行输出，其中包含所有案例的结果，并聚合为一个列表。对于按所列顺序的每个案例，按此确切顺序输出三个值：最大回撤的样本均值、给定阈值下的超额概率以及在水平 $q$ 处的经验分位数。按案例顺序连接这些三元组，形成一个扁平列表。每个值必须四舍五入到恰好 $6$ 位小数。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，且没有空格。例如，对于两个案例，格式将是像 $[x_{1,1},x_{1,2},x_{1,3},x_{2,1},x_{2,2},x_{2,3}]$ 这样的一行，其中 $x_{i,j}$ 表示案例 $i$ 的第 $j$ 个值。", "solution": "该问题陈述经过了严格验证并被认定为有效。它在科学上基于随机微积分的既定理论及其在金融建模中的应用，特别是几何布朗运动模型。该问题是适定的，所有参数、定义和约束都得到了清晰客观的规定。它代表了计算金融领域一个标准的、可形式化的任务。因此，我将提供一个完整的解决方案。\n\n目标是计算与投资组合最大回撤（$\\mathrm{MDD}$）相关的统计数据，该投资组合的价值遵循几何布朗运动（GBM）。过程 $S_t$ 由随机微分方程 $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$ 描述。我们将采用蒙特卡洛模拟方法来生成大量样本路径，计算每条路径的 $\\mathrm{MDD}$，然后从得到的 $\\mathrm{MDD}$ 值分布中计算所需的样本统计量。\n\n对于所提供的每一组参数，求解方法包括四个主要步骤。\n\n首先，初始化模拟参数。对于每个测试案例，我们都给定了初始投资组合价值 $S_0$、漂移率 $\\mu$、波动率 $\\sigma$、时间范围 $T$、时间步数 $n$、模拟路径数 $N_{\\text{paths}}$、回撤阈值 $d^\\star$、分位数水平 $q$ 以及一个随机种子。时间离散化步长计算为 $\\Delta t = T/n$。为保证可复现性，每个案例都使用指定的种子初始化一个新的随机数生成器。\n\n其次，我们生成 $N_{\\text{paths}}$ 条 GBM 过程的样本路径。问题正确地指出，对于离散时间网格 $t_k = k \\Delta t$，GBM SDE 的精确解提供了以下关系：\n$$ S_{t_{k+1}} = S_{t_k} \\exp\\left( (\\mu - \\frac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_k \\right) $$\n其中每个 $Z_k$ 是从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取的独立随机变量。为了数值稳定性和计算效率，我们首先模拟价格过程的对数，$X_t = \\log(S_t)$。对数价格过程的增量由下式给出：\n$$ X_{t_{k+1}} - X_{t_k} = (\\mu - \\frac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_k $$\n我们生成一个 $N_{\\text{paths}} \\times n$ 的标准正态随机数矩阵。然后，对于每条路径，我们计算这些增量的累积和，以获得从 $X_0 = \\log(S_0)$ 开始的对数价格轨迹。最后，我们通过对对数价格路径取幂来获得价格路径 $S$。整个过程使用向量化的 `numpy` 操作来实现，以高效地同时生成所有 $N_{\\text{paths}}$ 条路径。得到的资产价格矩阵 $S$ 的维度为 $N_{\\text{paths}} \\times (n+1)$。\n\n第三，对于每条模拟路径，我们计算最大回撤。时间 $t_k$ 的运行最大值定义为 $M_{t_k} = \\max_{0 \\le j \\le k} S_{t_j}$。时间 $t_k$ 的回撤是 $D_{t_k} = 1 - S_{t_k}/M_{t_k}$。单条路径的最大回撤是 $\\mathrm{MDD} = \\max_{0 \\le k \\le n} D_{t_k}$。在计算上，对于所有路径的矩阵 $S$，我们首先使用 `numpy.maximum.accumulate` 沿每一行（路径）计算运行最大值。这会产生一个运行最大值矩阵 $M$。然后，回撤矩阵 $D$ 计算为 $D = 1 - S/M$。通过取 $D$ 矩阵每一行的最大值，可以找到每条路径的最大回撤，从而得到一个包含 $N_{\\text{paths}}$ 个 $\\mathrm{MDD}$ 值的向量。\n\n第四，从 $N_{\\text{paths}}$ 个最大回撤的样本（表示为 $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$）中，我们计算所需的统计量：\n- 样本均值 $\\widehat{\\mathbb{E}}[\\mathrm{MDD}]$，是 $\\mathrm{MDD}$ 样本的算术平均值。\n- 超额概率 $\\widehat{\\mathbb{P}}(\\mathrm{MDD} \\ge d^\\star)$，是 $\\mathrm{MDD}$ 大于或等于指定阈值 $d^\\star$ 的模拟路径所占的比例。\n- 经验分位数 $Q_q$，是这样一个值，样本中 $q$ 比例的 $\\mathrm{MDD}$ 低于该值。这使用 `numpy.quantile` 函数计算，该函数提供了样本分位数的标准实现。\n\n将每个测试案例计算出的这三个值收集起来，四舍五入到 $6$ 位小数，并按照问题指定的格式整理成一个单一的扁平列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating maximum drawdown statistics for a\n    Geometric Brownian Motion process via Monte Carlo simulation.\n    \"\"\"\n    test_cases = [\n        # (S0, mu, sigma, T, n, N_paths, d_star, q, seed)\n        (100.0, 0.05, 0.20, 1.0, 252, 8000, 0.20, 0.95, 202311),\n        (100.0, 0.05, 0.0001, 1.0, 252, 8000, 0.01, 0.95, 202312),\n        (100.0, 0.00, 0.60, 1.0, 252, 8000, 0.50, 0.95, 202313),\n        (100.0, -0.10, 0.25, 2.0, 504, 8000, 0.30, 0.95, 202314),\n        (100.0, 0.02, 0.15, 0.25, 63, 8000, 0.10, 0.95, 202315),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        S0, mu, sigma, T, n, N_paths, d_star, q, seed = case\n\n        # Step 1: Initialization\n        # Set the time step and initialize the random number generator for reproducibility.\n        dt = T / n\n        rng = np.random.default_rng(seed)\n\n        # Step 2: Path Generation\n        # Generate N_paths x n matrix of standard normal random variates.\n        Z = rng.standard_normal(size=(N_paths, n))\n\n        # Calculate log-returns using the exact discretization of GBM's log-process.\n        # This results in an N_paths x n matrix.\n        log_returns = (mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z\n\n        # Compute log-prices by taking the cumulative sum of log-returns.\n        # The resulting matrix has shape N_paths x (n+1).\n        log_prices = np.zeros((N_paths, n + 1))\n        log_prices[:, 0] = np.log(S0)\n        log_prices[:, 1:] = np.log(S0) + np.cumsum(log_returns, axis=1)\n\n        # Convert log-prices to prices by exponentiation.\n        S = np.exp(log_prices)\n\n        # Step 3: Maximum Drawdown (MDD) Calculation\n        # Compute the running maximum for each path.\n        M = np.maximum.accumulate(S, axis=1)\n\n        # Compute the drawdown at each time step for each path.\n        # Division by zero is avoided as S0 > 0 implies M > 0.\n        D = 1 - S / M\n\n        # Find the maximum drawdown for each path by taking the max over time.\n        mdd_samples = np.max(D, axis=1)\n\n        # Step 4: Statistical Estimation\n        # Calculate the sample mean of the maximum drawdowns.\n        mean_mdd = np.mean(mdd_samples)\n\n        # Calculate the exceedance probability P(MDD >= d*).\n        exceedance_prob = np.mean(mdd_samples >= d_star)\n\n        # Calculate the empirical q-quantile of the maximum drawdowns.\n        quantile_mdd = np.quantile(mdd_samples, q)\n\n        results.extend([mean_mdd, exceedance_prob, quantile_mdd])\n\n    # Final print statement in the exact required format.\n    # Each value is formatted to 6 decimal places.\n    output_str = f\"[{','.join([f'{val:.6f}' for val in results])}]\"\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "模拟能够提供深刻的见解，但它们本质上是估计，其准确性至关重要。这个练习将带你进入更深层次的分析，你将为一个数字期权（Digital Option）定价，这种期权有一个已知的解析解，可以作为我们模拟结果的“黄金标准”。通过比较模拟价格与精确解，你将学会如何量化蒙特卡洛误差，并理解它如何随期权的关键参数（如执行价格 $K$）而变化。这是从一个模拟使用者转变为一个能够评估和改进模型的批判性思考者的关键一步 [@problem_id:2403319]。", "id": "2403319", "problem": "要求您实现一个完整、可运行的程序，通过蒙特卡洛模拟对一个数字式现金或无价值看涨期权进行定价，并分析当行权价接近在风险中性测度下期权方差最大的阈值时，蒙特卡洛误差的行为。请在风险中性测度下的经典 Black–Scholes 框架内进行操作。所有符号定义如下。\n\n定义和建模假设：\n- 标的资产价格过程 $\\{S_t\\}_{t \\ge 0}$ 在风险中性测度下遵循几何布朗运动，其漂移率等于连续复利无风险利率 $r$，即 $dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$，其中 $\\sigma &gt; 0$ 是恒定波动率，$\\{W_t\\}_{t \\ge 0}$ 是一个标准维纳过程。\n- 时间 $0$ 的即期价格为 $S_0$，到期日为 $T &gt; 0$，行权价为 $K &gt; 0$。如果且仅如果 $S_T \\ge K$，该期权在时间 $T$ 支付一笔固定的现金 $L &gt; 0$，否则支付 $0$。到时间 $0$ 的折现因子为 $\\exp(-rT)$。\n\n基本原理：\n- 在风险中性测度下，$S_T$ 是对数正态分布的，且 $\\ln S_T$ 服从正态分布，其均值为 $\\ln S_0 + (r - \\tfrac{1}{2}\\sigma^2)T$，方差为 $\\sigma^2 T$。\n- 风险中性定价表明，任何可积收益 $X_T$ 的时间 $0$ 价格为 $\\exp(-rT)\\,\\mathbb{E}[X_T]$，其中期望是在风险中性测度下计算的。\n\n要实现和计算的任务：\n1. 通过使用模型所蕴含的对数正态表示法，模拟 $N$ 次独立的 $S_T$ 抽样，从而实现一个用于数字式现金或无价值看涨期权价格的蒙特卡洛估计量。对所有行权价使用相同的标准正态抽样流（公共随机数），以分离出行权价本身对蒙特卡洛误差的影响。为了可复现性，使用一个固定的随机种子。\n2. 对每个行权价 $K$ 计算：\n   - 蒙特卡洛价格估计值 $\\hat{C}_{\\text{MC}}(K) = \\exp(-rT)\\,\\frac{1}{N}\\sum_{i=1}^{N} L \\,\\mathbf{1}\\{S_T^{(i)} \\ge K\\}$。\n   - 蒙特卡洛标准误 $\\widehat{\\text{se}}_{\\text{MC}}(K) = \\exp(-rT)\\,\\frac{\\widehat{\\sigma}_{\\text{payoff}}}{\\sqrt{N}}$，其中 $\\widehat{\\sigma}_{\\text{payoff}}$ 是未折现模拟收益 $L \\,\\mathbf{1}\\{S_T^{(i)} \\ge K\\}$ 的样本标准差，使用总体归一化计算。\n3. 从基本原理出发，推导并计算解析价格 $C_{\\text{BS}}(K)$。不要假设任何未从模型的 $\\ln S_T$ 高斯性质和风险中性定价中推导出的定价捷径。同时，通过使用成功概率为 $p(K) = \\mathbb{P}(S_T \\ge K)$ 的伯努利随机变量的方差，推导并计算相应的解析蒙特卡洛标准误 $\\text{se}_{\\text{BS}}(K)$。\n4. 使用以下参数值为一组测试行权价，以展示当行权价在最大方差水平附近移动时蒙特卡洛误差的行为：\n   - 全局参数：$S_0 = 100$, $r = 0.02$, $\\sigma = 0.2$, $T = 1$, $L = 1$, $N = 200000$。\n   - 待评估的行权价：$K \\in \\{60, 90, 100, 110, 140\\}$。\n   - 为伪随机数生成器使用一个固定的种子 $123456$，并在不同行权价之间使用公共随机数。\n\n答案规格和输出格式：\n- 对于指定集合中的每个行权价 $K$，您的程序必须按此确切顺序计算一个包含以下五个条目的列表：$[K, \\hat{C}_{\\text{MC}}(K), C_{\\text{BS}}(K), \\widehat{\\text{se}}_{\\text{MC}}(K), \\text{se}_{\\text{BS}}(K)]$。\n- 最终的程序输出必须是单行，由这些按所提供行权价顺序排列的各行权价列表组成的、由方括号括起、逗号分隔的列表。例如，一个语法有效的输出结构为 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\dots]$，其中只包含十进制数。不要打印任何附加文本。\n\n注意：\n- 将所有输出表示为十进制数（浮点数），不加任何货币符号。\n- 不使用角度；不需要角度单位。", "solution": "所提出的问题是计算金融学中的一个标准练习，它在科学上基础扎实、提法恰当且内容完整。该问题被验证为一个可以构建解决方案的合法问题。任务是使用从 Black-Scholes 模型推导出的解析公式和蒙特卡洛模拟两种方法，对一个数字式现金或无价值看涨期权进行定价。我们还将分析蒙特卡洛估计误差的行为。\n\n首先，我们推导期权的解析价格。期权在到期日 $T$ 的收益是：若资产价格 $S_T$ 大于或等于行权价 $K$，则为 $L$；否则为 $0$。收益函数为 $X_T = L \\cdot \\mathbf{1}\\{S_T \\ge K\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。根据风险中性定价原理，期权在时间 $t=0$ 的价格，记为 $C(K)$，是在风险中性测度 $\\mathbb{Q}$ 下的折现期望收益：\n$$C(K) = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[X_T] = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[L \\cdot \\mathbf{1}\\{S_T \\ge K\\}]$$\n根据期望的线性性质，这变为：\n$$C(K) = L e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[\\mathbf{1}\\{S_T \\ge K\\}] = L e^{-rT} \\mathbb{Q}(S_T \\ge K)$$\n问题陈述指出，在 $\\mathbb{Q}$ 下，资产价格遵循几何布朗运动，这意味着 $\\ln S_T$ 是正态分布的。其均值和方差为：\n$$\\ln S_T \\sim \\mathcal{N}\\left(\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T\\right)$$\n为了计算概率 $\\mathbb{Q}(S_T \\ge K)$，我们对随机变量 $\\ln S_T$ 进行标准化。条件 $S_T \\ge K$ 等价于 $\\ln S_T \\ge \\ln K$：\n$$\\mathbb{Q}(\\ln S_T \\ge \\ln K) = \\mathbb{Q}\\left(\\frac{\\ln S_T - (\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T)}{\\sigma\\sqrt{T}} \\ge \\frac{\\ln K - (\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T)}{\\sigma\\sqrt{T}}\\right)$$\n左边的项是一个标准正态随机变量，$Z \\sim \\mathcal{N}(0, 1)$。右边的表达式通常被整理成标准的 Black-Scholes $d_2$ 参数：\n$$d_2 = \\frac{\\ln(S_0/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}$$\n因此，概率为：\n$$\\mathbb{Q}(S_T \\ge K) = \\mathbb{Q}(Z \\ge -d_2) = \\mathbb{Q}(Z \\le d_2) = \\Phi(d_2)$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数（CDF）。因此，我们记为 $C_{\\text{BS}}(K)$ 的解析价格是：\n$$C_{\\text{BS}}(K) = L e^{-rT} \\Phi(d_2)$$\n\n接下来，我们推导蒙特卡洛估计量标准误的解析公式。蒙特卡洛价格估计量为 $\\hat{C}_{\\text{MC}}(K) = e^{-rT} \\frac{1}{N}\\sum_{i=1}^{N} Y^{(i)}$，其中 $Y^{(i)} = L \\cdot \\mathbf{1}\\{S_T^{(i)} \\ge K\\}$ 是未折现收益的独立样本。标准误是该估计量方差的平方根：\n$$\\text{se}(\\hat{C}_{\\text{MC}}(K)) = \\sqrt{\\text{Var}(\\hat{C}_{\\text{MC}}(K))} = \\sqrt{\\text{Var}\\left(e^{-rT} \\frac{1}{N}\\sum_{i=1}^{N} Y^{(i)}\\right)}$$\n使用方差的性质，这可简化为：\n$$\\text{se}(\\hat{C}_{\\text{MC}}(K)) = e^{-rT} \\sqrt{\\frac{\\text{Var}(Y^{(1)})}{N}} = \\frac{e^{-rT} \\sigma_{\\text{payoff}}}{\\sqrt{N}}$$\n其中 $\\sigma_{\\text{payoff}}$ 是单个未折现收益的标准差。收益随机变量 $Y = L \\cdot \\mathbf{1}\\{S_T \\ge K\\}$ 是一个缩放的伯努利变量。它以成功概率 $p(K) = \\mathbb{Q}(S_T \\ge K) = \\Phi(d_2)$ 取值 $L$，否则取值为 $0$。$Y$ 的方差是：\n$$\\text{Var}(Y) = \\mathbb{E}[Y^2] - (\\mathbb{E}[Y])^2 = (L^2 \\cdot p(K)) - (L \\cdot p(K))^2 = L^2 p(K)(1 - p(K))$$\n收益的标准差为 $\\sigma_{\\text{payoff}} = \\sqrt{\\text{Var}(Y)} = L \\sqrt{p(K)(1 - p(K))}$。因此，解析蒙特卡洛标准误，记为 $\\text{se}_{\\text{BS}}(K)$，是：\n$$\\text{se}_{\\text{BS}}(K) = \\frac{e^{-rT} L \\sqrt{\\Phi(d_2)(1 - \\Phi(d_2))}}{\\sqrt{N}}$$\n\n蒙特卡洛模拟通过生成 $N$ 个独立的标准正态随机变量 $Z^{(i)}$ 的抽样来实现，并使用这些抽样来计算 $N$ 个模拟的终端资产价格：\n$$S_T^{(i)} = S_0 \\exp\\left( \\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T} Z^{(i)} \\right)$$\n对于每个行权价 $K$，蒙特卡洛价格估计值 $\\hat{C}_{\\text{MC}}(K)$ 是模拟收益的折现样本均值：\n$$\\hat{C}_{\\text{MC}}(K) = e^{-rT} \\frac{1}{N} \\sum_{i=1}^{N} L \\cdot \\mathbf{1}\\{S_T^{(i)} \\ge K\\}$$\n估计的标准误 $\\widehat{\\text{se}}_{\\text{MC}}(K)$ 使用未折现收益的样本标准差 $\\widehat{\\sigma}_{\\text{payoff}}$ 来计算。按照规定，使用总体归一化（除以 $N$）：\n$$\\widehat{\\sigma}_{\\text{payoff}} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(Y^{(i)} - \\bar{Y}\\right)^2}, \\quad \\text{其中 } \\bar{Y} = \\frac{1}{N} \\sum_{i=1}^{N} Y^{(i)}$$\n$$\\widehat{\\text{se}}_{\\text{MC}}(K) = e^{-rT} \\frac{\\widehat{\\sigma}_{\\text{payoff}}}{\\sqrt{N}}$$\n为确保不同行权价之间的可比性，使用了公共随机数，这意味着对所有 $K$ 值，都使用同一组 $N$ 个抽样 $\\{Z^{(i)}\\}$ 来生成资产价格路径 $\\{S_T^{(i)}\\}$。随机数生成器使用固定的种子以确保可复现性。\n\n由标准误表示的蒙特卡洛误差，与 $\\sqrt{p(K)(1 - p(K))}$ 成正比。当行权概率 $p(K) = \\Phi(d_2) = 0.5$ 时，该项达到最大值，这发生在 $d_2 = 0$ 时。解出 $K$ 可得最大方差的行权价：\n$$K_{\\text{max var}} = S_0 \\exp\\left(\\left(r - \\frac{1}{2}\\sigma^2\\right)T\\right)$$\n对于给定的参数 $S_0=100$、$r=0.02$、$\\sigma=0.2$ 和 $T=1$，这得出 $K_{\\text{max var}} = 100 \\cdot \\exp(0.02-0.02) = 100$。所提供的行权价集合 $\\{60, 90, 100, 110, 140\\}$ 被恰当地选择，以展示误差在这一点最大不确定性附近的行为。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes analytical and Monte Carlo prices and standard errors for a digital\n    cash-or-nothing call option under the Black-Scholes framework.\n    \"\"\"\n    # Global parameters from the problem statement\n    S0 = 100.0\n    r = 0.02\n    sigma = 0.2\n    T = 1.0\n    L = 1.0\n    N = 200000\n\n    # Strike prices to evaluate\n    K_values = [60.0, 90.0, 100.0, 110.0, 140.0]\n\n    # Fixed seed for reproducibility\n    seed = 123456\n\n    # --- Monte Carlo Simulation Setup ---\n    # Use a single stream of random numbers for all strikes (common random numbers)\n    rng = np.random.default_rng(seed)\n    z = rng.standard_normal(N)\n\n    # Simulate terminal asset prices based on the lognormal property\n    drift = (r - 0.5 * sigma**2) * T\n    diffusion = sigma * np.sqrt(T)\n    S_T = S0 * np.exp(drift + diffusion * z)\n\n    # --- Calculation Loop ---\n    results = []\n    discount_factor = np.exp(-r * T)\n\n    for K in K_values:\n        # 1. Analytical Calculations (Black-Scholes)\n        d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        p_K = norm.cdf(d2)  # Probability P(S_T >= K)\n\n        # Analytical price\n        C_bs = L * discount_factor * p_K\n        \n        # Analytical standard error of the MC estimator\n        payoff_var_analytical = (L**2) * p_K * (1 - p_K)\n        se_bs = discount_factor * np.sqrt(payoff_var_analytical / N)\n\n        # 2. Monte Carlo Estimators\n        # Calculate undiscounted payoffs for each simulated path\n        payoffs = L * (S_T >= K)\n\n        # Monte Carlo price estimate\n        mean_payoff = np.mean(payoffs)\n        C_mc = discount_factor * mean_payoff\n\n        # Monte Carlo standard error estimate\n        # Use population standard deviation (ddof=0) as specified\n        payoff_std_sample = np.std(payoffs, ddof=0)\n        se_mc = discount_factor * payoff_std_sample / np.sqrt(N)\n        \n        # Store the five required values for a given strike K\n        results.append([K, C_mc, C_bs, se_mc, se_bs])\n\n    # --- Output Formatting ---\n    # The final output must be a single line in the format [[...],[...],...]\n    # without extra spaces.\n    list_of_strings = []\n    for sublist in results:\n        # Format each sublist as a string \"[v1,v2,v3,v4,v5]\"\n        str_sublist = \"[\" + \",\".join(map(str, sublist)) + \"]\"\n        list_of_strings.append(str_sublist)\n\n    final_output = \"[\" + \",\".join(list_of_strings) + \"]\"\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "模拟的威力远不止于模拟资产价格。本练习将向你介绍一种全新的、功能强大的模拟范式：离散事件模拟（Discrete-Event Simulation）。与按固定时间步长推进的蒙特卡洛方法不同，离散事件模拟根据事件的发生（如订单到达或处理完成）来驱动系统状态的演化。你将为一个代表高频交易交易所撮合引擎的排队系统建模，估算订单的平均等待时间等关键性能指标，从而获得处理非同步、事件驱动型系统的宝贵实践经验 [@problem_id:2403274]。", "id": "2403274", "problem": "您将构建一个离散事件模拟器，用于模拟一个高频交易交易所的撮合引擎所代表的单服务台队列。订单以速率参数为 $\\lambda$ (订单/秒) 的 Poisson 过程到达，每个订单的处理时间服从速率参数为 $\\mu$ (订单/秒) 的指数分布。服务台遵循先到先服务 (FCFS) 准则。系统在时间 $t=0$ 时为空闲状态。您的任务是估计以秒为单位的平均排队等待时间（即从订单到达至开始服务的时间）。\n\n请基于以下定义进行模拟：\n- 速率为 $\\lambda$ 的 Poisson 到达过程具有独立平稳增量。这等价于，到达间隔时间 $\\{I_i\\}_{i \\ge 1}$ 是独立的、均值为 $1/\\lambda$ 的同分布指数随机变量。\n- 服务时间 $\\{X_i\\}_{i \\ge 1}$ 是独立的，均值为 $1/\\mu$，且与到达过程无关，彼此也相互独立。\n- 令 $A_i$ 表示第 $i$ 个订单的到达时间，$S_i$ 为服务开始时间，$C_i$ 为完成时间。第 $i$ 个订单的排队等待时间为 $W_i = S_i - A_i$。在舍弃 $b$ 个订单的预热期后，平均等待时间的估计量为\n$$\n\\widehat{W}_q = \\frac{1}{N - b} \\sum_{i=b+1}^{N} W_i.\n$$\n\n实现要求：\n- 模拟器必须在 $t=0$ 时从一个空系统和空闲服务台开始。\n- 生成均值为 $1/\\lambda$ 的独立指数随机变量作为到达间隔时间 $\\{I_i\\}$，以及均值为 $1/\\mu$ 的独立指数随机变量作为服务时间 $\\{X_i\\}$。\n- 通过 $A_i = \\sum_{j=1}^{i} I_j$ 构建到达时间，并强制执行单服务台的 FCFS 服务。\n- 对于每个参数集，通过舍弃前 $b$ 个等待时间（预热期）并对其余时间求平均，来估计以秒为单位的 $\\widehat{W}_q$。\n- 为确保在整个测试套件中的可复现性，应在最开始使用种子 $123456$ 对随机数生成器进行唯一一次初始化。\n- 时间以秒为单位。您的程序必须以秒为单位打印估计值，并四舍五入到六位小数。\n\n测试套件：\n为以下五个参数集 $(\\lambda, \\mu, N, b)$ 运行您的模拟器，其中 $N$ 是模拟的总到达数，$b$ 是预热期长度：\n1. $(800.0, 1000.0, 200000, 5000)$\n2. $(100.0, 1000.0, 200000, 5000)$\n3. $(990.0, 1000.0, 200000, 5000)$\n4. $(450.0, 500.0, 200000, 5000)$\n5. $(1000.0, 1000.0, 200000, 5000)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个估计的平均排队等待时间（以秒为单位，四舍五入到六位小数），形式为用方括号括起来的、无空格的逗号分隔列表。例如，\n\"[0.004123,0.000111,0.098765,0.018400,0.537219]\"。", "solution": "所给问题要求构建一个单服务台队列的离散事件模拟器，在排队论中这被称为 M/M/1 队列。该系统模拟了一个高频交易交易所的撮合引擎。到达过程为 Poisson 过程，服务时间服从指数分布。服务准则为先到先服务 (FCFS)。我们的目标是估计队列中的平均等待时间 $\\widehat{W}_q$。\n\n该问题在科学上和计算上都是适定的。它基于排队论的既定原理，这是性能分析的标准工具。所有必要的参数（$\\lambda, \\mu, N, b$）和初始条件（系统在 $t=0$ 时为空闲）都已提供，同时还指定了随机数生成器种子，确保了计算结果的唯一性和可复现性。因此，该问题是有效的。\n\n设 Poisson 到达速率为 $\\lambda$，指数服务速率为 $\\mu$。相应的平均到达间隔时间为 $1/\\lambda$，平均服务时间为 $1/\\mu$。我们将订单 $i-1$ 和 $i$ 之间的到达间隔时间表示为 $I_i$，将订单 $i$ 的服务时间表示为 $X_i$。\n\n模拟的核心是一组描述系统状态随时间演化的递推关系。令 $A_i$、$S_i$ 和 $C_i$ 分别为第 $i$ 个订单的到达时间、服务开始时间和完成时间，其中 $i \\in \\{1, 2, \\dots, N\\}$。\n\n第 $i$ 个订单的到达时间由到达间隔时间的累积和给出：\n$$\nA_i = \\sum_{j=1}^{i} I_j \\quad \\text{with } A_0 = 0\n$$\n这可以通过 $A_i = A_{i-1} + I_i$ 迭代计算。\n\n系统初始为空，因此第一个订单 ($i=1$) 在到达后立即开始服务：$S_1 = A_1$。其完成时间为 $C_1 = S_1 + X_1$。\n\n对于任何后续订单 $i > 1$，其服务必须在其到达（时间 $A_i$）且服务台空闲后才能开始。服务台在完成前一个订单的服务后变为空闲，时间点为 $C_{i-1}$。因此，订单 $i$ 的服务开始时间由这两个事件中较晚的那个决定：\n$$\nS_i = \\max(A_i, C_{i-1})\n$$\n订单 $i$ 的完成时间则为：\n$$\nC_i = S_i + X_i\n$$\n订单 $i$ 的排队等待时间 $W_i$ 是从其到达至服务开始所经过的时间：\n$$\nW_i = S_i - A_i = \\max(A_i, C_{i-1}) - A_i = \\max(0, C_{i-1} - A_i)\n$$\n这组关系允许对排队过程进行迭代模拟。\n\n流量强度 $\\rho = \\lambda/\\mu$ 是一个关键参数。要使稳定的稳态存在，必须有 $\\rho < 1$。在这种情况下，理论平均等待时间为 $W_q = \\frac{\\rho}{\\mu(1-\\rho)}$。测试用例 5 中，$(\\lambda, \\mu) = (1000.0, 1000.0)$，对应 $\\rho=1$。这是一个零常返 Markov 链，其期望等待时间是无限的。然而，为有限数量的订单 $N$ 运行模拟的计算任务仍然是适定的，并将产生一个有限的结果。这个结果不应被理解为对有限稳态均值的估计，而是指定有限时间过程的结果。\n\n模拟算法如下：\n1. 使用种子 $123456$ 初始化一个随机数生成器。\n2. 对于每个测试用例 $(\\lambda, \\mu, N, b)$：\n    a. 从均值为 $1/\\lambda$ 的指数分布中生成 $N$ 个独立同分布的到达间隔时间 $\\{I_i\\}_{i=1}^N$。\n    b. 从均值为 $1/\\mu$ 的指数分布中生成 $N$ 个独立同分布的服务时间 $\\{X_i\\}_{i=1}^N$。\n    c. 将 `arrival_time` 和 `completion_time_of_previous_customer` 初始化为 $0.0$。\n    d. 从 $i=1$ 迭代至 $N$，用 $I_i$ 更新 `arrival_time`，并使用递推关系计算 $S_i$、$W_i$ 和 $C_i$。$C_{i-1}$ 的值由 `completion_time_of_previous_customer` 跟踪。存储每个 $W_i$。\n3. 模拟完所有 $N$ 个订单后，舍弃前 $b$ 个等待时间，以消除初始空闲状态（预热期）的瞬态效应。\n4. 平均等待时间通过剩余 $N-b$ 个观测值的样本均值来估计：\n$$\n\\widehat{W}_q = \\frac{1}{N - b} \\sum_{i=b+1}^{N} W_i\n$$\n这个计算出的值，四舍五入到六位小数，构成了每个测试用例所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_queue(lambda_rate, mu_rate, N, b, rng):\n    \"\"\"\n    Simulates a single-server M/M/1 queue to estimate average waiting time.\n\n    Args:\n        lambda_rate (float): Arrival rate of orders.\n        mu_rate (float): Service rate of orders.\n        N (int): Total number of orders to simulate.\n        b (int): Number of burn-in orders to discard.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The estimated average waiting time in the queue.\n    \"\"\"\n    # Scale parameter for exponential distribution is the mean.\n    # Mean interarrival time = 1 / lambda_rate\n    # Mean service time = 1 / mu_rate\n    interarrival_times = rng.exponential(scale=1.0/lambda_rate, size=N)\n    service_times = rng.exponential(scale=1.0/mu_rate, size=N)\n\n    # Initialize simulation state variables\n    current_arrival_time = 0.0\n    # Tracks the completion time of the previous customer, C_{i-1}\n    completion_time_of_previous = 0.0\n    waiting_times = np.zeros(N)\n\n    # Main simulation loop over N customers\n    for i in range(N):\n        # Calculate arrival time of current customer: A_i = A_{i-1} + I_i\n        current_arrival_time += interarrival_times[i]\n        \n        # Service start time: S_i = max(A_i, C_{i-1})\n        service_start_time = max(current_arrival_time, completion_time_of_previous)\n        \n        # Waiting time in queue: W_i = S_i - A_i\n        waiting_times[i] = service_start_time - current_arrival_time\n        \n        # Update completion time for the next iteration: C_i = S_i + X_i\n        completion_time_of_previous = service_start_time + service_times[i]\n\n    # Calculate the average waiting time after the burn-in period\n    # np.mean on the slice waiting_times[b:N] is equivalent to the formula in the problem.\n    avg_waiting_time = np.mean(waiting_times[b:])\n    \n    return avg_waiting_time\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    # Initialize the random number generator exactly once at the beginning\n    # with seed 123456 to ensure reproducibility.\n    rng = np.random.default_rng(123456)\n    \n    # Define the test cases from the problem statement.\n    # Format: (lambda, mu, N, b)\n    test_cases = [\n        (800.0, 1000.0, 200000, 5000),\n        (100.0, 1000.0, 200000, 5000),\n        (990.0, 1000.0, 200000, 5000),\n        (450.0, 500.0, 200000, 5000),\n        (1000.0, 1000.0, 200000, 5000)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_rate, mu_rate, N, b = case\n        estimated_wait = simulate_queue(lambda_rate, mu_rate, N, b, rng)\n        # Format the result to six decimal places, as a string.\n        results.append(f\"{estimated_wait:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}