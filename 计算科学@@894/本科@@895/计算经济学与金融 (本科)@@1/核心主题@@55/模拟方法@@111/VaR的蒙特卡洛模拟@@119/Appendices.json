{"hands_on_practices": [{"introduction": "第一个练习将引导你实践最基础的VaR蒙特卡洛方法：自举法（bootstrap）。通过对历史收益率进行重采样，我们可以在不对收益率的潜在分布做强假设的情况下，模拟出成千上万条未来可能的价格路径。这项实践将巩固你对如何从零开始构建仿真、计算损失以及将VaR作为模拟损失分布的经验分位数来估算的理解 [@problem_id:2412304]。", "id": "2412304", "problem": "给定一个在离散时间步上定义的价格过程，其初始价格为 $S_0 \\in \\mathbb{R}_{+}$。在每一步 $t \\in \\{1,2,\\dots,H\\}$，简单收益率 $r_t$ 是从一个由给定有限历史简单收益率集合 $\\{r^{(1)}, r^{(2)}, \\dots, r^{(m)}\\}$ 支持的经验分布中的一次独立抽取，每个支持点的概率相等，为 $1/m$。价格通过简单复利演变，因此 $S_{t} = S_{t-1}\\,(1 + r_t)$，其中 $t=1,\\dots,H$。对于一个固定的时间范围 $H \\in \\mathbb{N}_0$, 在此模型下模拟 $N \\in \\mathbb{N}$ 个独立的期末价格，以获得期末价格样本 $\\{S_H^{(i)}\\}_{i=1}^N$。将路径 $i$ 上的损失定义为 $L^{(i)} = S_0 - S_H^{(i)}$（正值表示损失）。对于给定的概率水平 $q \\in [0,1]$，将 $q$ 水平下的风险价值 (VaR) 定义为损失分布的样本 $q$-分位数。具体而言，如果 $L_{(1)} \\le \\dots \\le L_{(N)}$ 是排序后的损失，且 $h = (N-1)\\,q + 1$, 其中 $k = \\lfloor h \\rfloor$ 且 $\\gamma = h - k$，那么\n$$\n\\operatorname{VaR}_q =\n\\begin{cases}\nL_{(k)} + \\gamma \\big(L_{(k+1)} - L_{(k)}\\big), & \\text{若 } 1 \\le k &lt; N, \\\\\nL_{(N)}, & \\text{若 } k \\ge N.\n\\end{cases}\n$$\n如果 $N=1$，那么 $\\operatorname{VaR}_q = L_{(1)}$。所有收益率都必须按小数形式的简单收益率处理（例如，$0.01$ 表示百分之一），并且 VaR 必须以与 $S_0$ 相同的货币单位的浮点数表示（而不是比例）。为每个测试用例使用指定的伪随机种子来初始化随机数生成器，以确保结果是可复现的。如果 $H=0$，则将其解释为一个退化时间范围，此时几乎必然有 $S_H = S_0$。\n\n您的任务是为以下每个测试用例计算 $\\operatorname{VaR}_q$。最终输出必须是单行，包含一个用方括号括起来的逗号分隔的结果列表，结果顺序与测试用例的顺序相同。每个结果必须四舍五入到六位小数。\n\n测试套件：\n1) $S_0 = 100.0$，历史收益率 $[ -0.03,\\,-0.01,\\,0.0,\\,0.005,\\,0.01,\\,0.015,\\,0.02,\\,0.03 ]$，$H = 5$，$N = 20000$，$q = 0.99$，种子 $= 202311$。\n2) $S_0 = 250.0$，历史收益率 $[ -0.02,\\,-0.015,\\,-0.01,\\,-0.005,\\,0.0,\\,0.005,\\,0.01,\\,0.015 ]$，$H = 10$，$N = 15000$，$q = 0.95$，种子 $= 42$。\n3) $S_0 = 100.0$，历史收益率 $[ -0.02,\\,0.0,\\,0.02 ]$，$H = 1$，$N = 100000$，$q = 0.5$，种子 $= 7$。\n4) $S_0 = 123.45$，历史收益率 $[ -0.01,\\,0.0,\\,0.01,\\,0.02 ]$，$H = 0$，$N = 10000$，$q = 0.99$，种子 $= 99$。\n5) $S_0 = 80.0$，历史收益率 $[ -0.05,\\,-0.01,\\,0.0,\\,0.02,\\,0.04 ]$，$H = 3$，$N = 1$，$q = 0.975$，种子 $= 555$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”），每个结果是四舍五入到六位小数的风险价值。", "solution": "问题陈述已经过严格验证，被认为是科学上合理、定义明确且完整的。它呈现了一个标准的计算金融任务：使用非参数蒙特卡洛模拟估计风险价值。我们现在将进行正式求解。\n\n问题的核心是为一个初始价值为 $S_0$ 的金融头寸估计风险价值 ($\\operatorname{VaR}_q$)。价格过程 $S_t$ 在离散时间步 $t \\in \\{1, 2, \\dots, H\\}$ 上演变。该演变由简单收益率 $r_t$ 驱动，这些收益率被建模为独立同分布的随机变量。它们的分布是给定的一组 $m$ 个历史收益率 $\\{r^{(1)}, r^{(2)}, \\dots, r^{(m)}\\}$ 的经验分布，其中每个历史收益率以 $1/m$ 的概率被抽取。\n\n时刻 $t$ 的价格由简单复利法则给出：\n$$\nS_t = S_{t-1} (1 + r_t)\n$$\n从初始价格 $S_0$ 开始，在时间范围 $H$ 的期末价格是 $H$ 次连续乘法的结果：\n$$\nS_H = S_0 \\prod_{t=1}^{H} (1 + r_t)\n$$\n与价格路径相关的损失定义为初始价格与期末价格之差：\n$$\nL = S_0 - S_H\n$$\n$L$ 的正值对应于货币损失。\n\n为了估计作为损失分布的 $q$-分位数的 $\\operatorname{VaR}_q$，我们采用蒙特卡洛方法。这涉及模拟价格过程的 $N$ 条独立路径。对于每个模拟路径 $i \\in \\{1, \\dots, N\\}$，我们生成一个包含 $H$ 个随机收益率的序列 $\\{r_{i,t}\\}_{t=1}^H$，每个收益率均从指定的经验分布中抽取。这将产生一个包含 $N$ 个期末价格的样本：\n$$\nS_H^{(i)} = S_0 \\prod_{t=1}^{H} (1 + r_{i,t}) \\quad \\text{对于 } i=1, \\dots, N\n$$\n根据这个期末价格样本，我们计算出相应的损失样本：\n$$\nL^{(i)} = S_0 - S_H^{(i)} \\quad \\text{对于 } i=1, \\dots, N\n$$\n然后将 $\\operatorname{VaR}_q$ 计算为损失集合 $\\{L^{(i)}\\}_{i=1}^N$ 的样本 $q$-分位数。问题为基于线性插值的样本分位数指定了精确的定义。设 $L_{(1)} \\le L_{(2)} \\le \\dots \\le L_{(N)}$ 为按非递减顺序排序的损失。分位数使用索引 $h = (N-1)q + 1$ 计算。设 $k = \\lfloor h \\rfloor$ 为其整数部分，$\\gamma = h - k$ 为其小数部分。$\\operatorname{VaR}_q$ 由下式给出：\n$$\n\\operatorname{VaR}_q = L_{(k)} + \\gamma (L_{(k+1)} - L_{(k)})\n$$\n对于 $1 \\le k < N$。如果 $k \\ge N$（当 $q=1$ 时发生），则 $\\operatorname{VaR}_q = L_{(N)}$。这个定义等同于分位数的“线性”('linear')插值方法，这是 `numpy` 等数值库中可用的标准实现。\n\n为了提高效率，计算算法设计为使用向量化操作：\n1.  对于每个测试用例，初始化参数 $S_0$、历史收益率数组 $\\mathcal{R}$、时间范围 $H$、路径数 $N$、分位数水平 $q$ 以及随机种子。\n2.  为伪随机数生成器设定种子以确保可复现性。\n3.  $H=0$ 的特殊情况意味着 $S_H = S_0$，因此损失始终为 $0$，且 $\\operatorname{VaR}_q = 0.0$。\n4.  $N=1$ 的特殊情况只需要模拟一条路径。根据定义，产生的单个损失 $L^{(1)} = S_0 - S_H^{(1)}$ 就是 $\\operatorname{VaR}_q$。\n5.  在一般情况下 ($H > 0$, $N > 1$)，通过从历史收益率数组中有放回地抽样，生成一个 $N \\times H$ 的收益率矩阵。\n6.  将此收益率矩阵转换为一个增长因子 $(1+r)$ 矩阵。沿每行（时间轴）对这些因子求积，得到一个总路径乘数向量。\n7.  将此向量乘以 $S_0$ 得到包含 $N$ 个期末价格的向量 $\\{S_H^{(i)}\\}$。\n8.  损失向量 $\\{L^{(i)}\\}$ 计算为 $S_0 - \\{S_H^{(i)}\\}$。\n9.  最后，将配置为线性插值的 `numpy.quantile` 函数应用于损失向量和指定的分位数水平 $q$，以计算 $\\operatorname{VaR}_q$。\n\n此过程被系统地应用于问题陈述中提供的每个测试用例。最终结果按指定精度进行四舍五入。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Value-at-Risk (VaR) for several test cases using Monte Carlo simulation.\n    \"\"\"\n    test_cases = [\n        (100.0, [-0.03, -0.01, 0.0, 0.005, 0.01, 0.015, 0.02, 0.03], 5, 20000, 0.99, 202311),\n        (250.0, [-0.02, -0.015, -0.01, -0.005, 0.0, 0.005, 0.01, 0.015], 10, 15000, 0.95, 42),\n        (100.0, [-0.02, 0.0, 0.02], 1, 100000, 0.5, 7),\n        (123.45, [-0.01, 0.0, 0.01, 0.02], 0, 10000, 0.99, 99),\n        (80.0, [-0.05, -0.01, 0.0, 0.02, 0.04], 3, 1, 0.975, 555),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, hist_returns, H, N, q, seed = case\n        \n        # Handle the degenerate case where the horizon H is 0.\n        # The terminal price is S0, so the loss is always 0.\n        if H == 0:\n            var = 0.0\n            results.append(var)\n            continue\n            \n        rng = np.random.default_rng(seed)\n        hist_returns_arr = np.array(hist_returns)\n        \n        # Handle the case where only one path is simulated (N=1).\n        # The VaR is simply the loss from that single path.\n        if N == 1:\n            # Simulate one path of H steps.\n            returns_path = rng.choice(hist_returns_arr, size=H, replace=True)\n            # The problem defines simple compounding.\n            path_multiplier = np.prod(1 + returns_path)\n            S_H = S0 * path_multiplier\n            loss = S0 - S_H\n            var = loss\n            results.append(var)\n            continue\n\n        # General case for Monte Carlo simulation (H > 0, N > 1).\n        # Generate N x H matrix of random returns by choosing from historical returns.\n        returns_matrix = rng.choice(hist_returns_arr, size=(N, H), replace=True)\n        \n        # Calculate terminal prices for all N paths using vectorized operations.\n        # The product of (1 + r_t) is taken along the time axis (axis=1).\n        path_multipliers = np.prod(1 + returns_matrix, axis=1)\n        terminal_prices = S0 * path_multipliers\n        \n        # Calculate the distribution of losses.\n        losses = S0 - terminal_prices\n        \n        # Calculate VaR, which is the sample q-quantile of the loss distribution.\n        # The problem's VaR formula corresponds to numpy's 'linear' interpolation method.\n        var = np.quantile(losses, q, method='linear')\n        \n        results.append(var)\n\n    # Format the final output as a comma-separated list string, with each\n    # result rounded to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "在基础自举法之上，这项实践将介绍一种更精密的技术，称为过滤历史模拟（Filtered Historical Simulation, FHS）。FHS通过根据当前波动率水平来调整历史收益率，改进了标准历史模拟方法，从而解决了基本自举法对静态收益率分布的假设。通过实施此方法，你将学习如何将时变波动率整合到风险模型中，从而获得更具响应性和现实感的风险估算 [@problem_id:2412321]。", "id": "2412321", "problem": "实现一个程序，使用过滤历史模拟法计算一个线性投资组合的单日风险价值 (VaR)。请从以下定义和假设开始：一个投资组合包含 $N$ 项资产，其在时间 $t \\in \\{1,\\dots,T\\}$ 内的历史简单收益率为 $\\{r_{i,t}\\}$（其中资产 $i \\in \\{1,\\dots,N\\}$），在相同时间内的历史条件波动率为 $\\{\\sigma_{i,t}\\}$，当前的条件波动率向量为 $\\sigma_{i,0}$，以及总和为 $1$ 的固定投资组合权重 $w_i$。对每个历史时间 $t$，定义标准化残差 $z_{i,t} = r_{i,t} / \\sigma_{i,t}$，假设所有的 $\\sigma_{i,t} > 0$。过滤历史模拟法通过将每个标准化的历史残差根据当前条件进行缩放，来构建一个经验情景集：情景 $t$ 中的模拟未来资产收益率为 $\\tilde{r}_{i,t} = \\sigma_{i,0} \\cdot z_{i,t}$。情景 $t$ 中对应的投资组合收益率为 $s_t = \\sum_{i=1}^N w_i \\tilde{r}_{i,t}$。将投资组合收益率的经验 $\\alpha$-分位数定义为 $\\{s_t\\}_{t=1}^T$ 的第 $k$ 个顺序统计量，其中 $k = \\lceil \\alpha T \\rceil$（$\\lceil \\cdot \\rceil$ 表示向上取整函数），使用基于 1 的索引。将置信水平为 $\\alpha$ 的单日 VaR 定义为 $\\text{VaR}_\\alpha = - q_\\alpha$，其中 $q_\\alpha$ 是 $\\{s_t\\}_{t=1}^T$ 的经验 $\\alpha$-分位数。所有收益率必须作为无单位的小数值（而非百分比）处理。\n\n你的任务是严格按照上述流程进行实现，不进行任何重采样：直接使用这 $T$ 个缩放后的情景 $\\{\\tilde{r}_{i,t}\\}$。使用以下三个测试用例；每个用例都是独立的，并应在相同的程序逻辑上进行评估：\n\n- 测试用例 1（双资产投资组合，基准当前波动率）：\n  - 历史收益率矩阵 $R \\in \\mathbb{R}^{T \\times N}$，其中 $T=5, N=2$：\n    - 行 $t=1$：$[-0.02,\\;0.01]$\n    - 行 $t=2$：$[0.01,\\;-0.005]$\n    - 行 $t=3$：$[-0.01,\\;0.015]$\n    - 行 $t=4$：$[0.02,\\;-0.01]$\n    - 行 $t=5$：$[-0.015,\\;0.005]$\n  - 历史条件波动率矩阵 $S \\in \\mathbb{R}_{>0}^{T \\times N}$：\n    - 行 $t=1$：$[0.02,\\;0.01]$\n    - 行 $t=2$：$[0.01,\\;0.005]$\n    - 行 $t=3$：$[0.01,\\;0.015]$\n    - 行 $t=4$：$[0.02,\\;0.01]$\n    - 行 $t=5$：$[0.015,\\;0.005]$\n  - 权重 $w = [0.6,\\;0.4]$。\n  - 当前波动率 $\\sigma_0 = [0.03,\\;0.02]$。\n  - 置信水平 $\\alpha = 0.05$。\n\n- 测试用例 2（历史数据和权重相同，当前波动率较低，$\\alpha$ 不同）：\n  - $R$ 和 $S$ 与测试用例 1 相同。\n  - 权重 $w = [0.6,\\;0.4]$。\n  - 当前波动率 $\\sigma_0 = [0.015,\\;0.01]$。\n  - 置信水平 $\\alpha = 0.10$。\n\n- 测试用例 3（单资产边界情况）：\n  - 历史收益率向量 $R_A = [-0.02,\\;0.01,\\;-0.01,\\;0.02,\\;-0.015]$，其中 $T=5$，$N=1$。\n  - 历史条件波动率 $S_A = [0.02,\\;0.01,\\;0.01,\\;0.02,\\;0.015]$。\n  - 权重 $w = [1.0]$。\n  - 当前波动率 $\\sigma_0 = [0.04]$。\n  - 置信水平 $\\alpha = 0.20$。\n\n程序要求：\n- 严格实现定义：对每个情景 $t$，计算 $z_{i,t} = r_{i,t} / \\sigma_{i,t}$，然后计算 $\\tilde{r}_{i,t} = \\sigma_{i,0} \\cdot z_{i,t}$，再计算 $s_t = \\sum_{i=1}^N w_i \\tilde{r}_{i,t}$。\n- 计算经验 $\\alpha$-分位数，即第 $k$ 小的值，其中 $k = \\lceil \\alpha T \\rceil$，然后计算 $\\text{VaR}_\\alpha = -q_\\alpha$。\n- 将每个测试用例的 VaR 报告为小数（无百分号），并四舍五入到六位小数。\n- 最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，“[x1,x2,x3]”），不含空格，并按测试用例 1、测试用例 2、测试用例 3 的顺序排列。\n- 你的程序必须是自包含的，并且不得读取任何外部输入或文件。", "solution": "我们从风险度量和时变波动率建模的第一性原理出发推导该算法。目标是在过滤历史模拟法下，计算一个线性投资组合在置信水平 $\\alpha$ 下的单日风险价值 (VaR)。置信水平为 $\\alpha$ 的风险价值 (VaR) 被定义为一个数值 $\\text{VaR}_\\alpha$，使得在特定模型下，损失超过 $\\text{VaR}_\\alpha$ 的概率为 $\\alpha$。对于单日时间范围和线性投资组合，设投资组合收益率为 $s$，一个常见的经验定义使用收益率分布的 $\\alpha$-分位数的负值：令 $q_\\alpha$ 为收益率的 $\\alpha$-分位数，则 $\\text{VaR}_\\alpha = - q_\\alpha$。\n\n为了在过滤历史模拟法下构建 $q_\\alpha$，我们从资产 $i \\in \\{1,\\dots,N\\}$ 在时间 $t \\in \\{1,\\dots,T\\}$ 内的历史简单收益率 $r_{i,t}$ 开始。我们假设对每个历史时间 $t$ 都存在一个条件波动率序列 $\\sigma_{i,t} > 0$，以及一个当前的条件波动率 $\\sigma_{i,0} > 0$。在一个条件异方差但标准化且平稳的创新过程的假设下，我们用波动率对收益率进行标准化，以获得 $z_{i,t} = r_{i,t} / \\sigma_{i,t}$。标准化残差 $z_{i,t}$ 被视为来自一个均值为零、尺度为单位一的平稳分布的抽样，能够捕捉可能存在的偏度和峰度等特征。\n\n为了在不指定参数分布的情况下模拟当前条件下的未来资产收益率，过滤历史模拟法将每个标准化残差根据当前波动率进行缩放：$\\tilde{r}_{i,t} = \\sigma_{i,0} \\cdot z_{i,t}$。对于权重 $w_i$ 总和为 $1$ 的线性投资组合，情景 $t$ 中的模拟投资组合收益率为\n$$\ns_t = \\sum_{i=1}^N w_i \\tilde{r}_{i,t} = \\sum_{i=1}^N w_i \\sigma_{i,0} \\frac{r_{i,t}}{\\sigma_{i,t}}.\n$$\n这 $T$ 个值 $\\{s_t\\}_{t=1}^T$ 构成了经验情景集。将它们升序排列，$s_{(1)} \\le \\cdots \\le s_{(T)}$，经验 $\\alpha$-分位数被定义为 $q_\\alpha = s_{(k)}$，其中 $k = \\lceil \\alpha T \\rceil$，使用基于 1 的索引。VaR 则为 $\\text{VaR}_\\alpha = - q_\\alpha$。\n\n我们将此方法应用于三个指定的测试用例。\n\n测试用例 1:\n- $T=5, N=2$，历史收益率 $R$ 和历史波动率 $S$：\n  - $t=1$: $r_{1,1} = -0.02$, $r_{2,1} = 0.01$, $\\sigma_{1,1} = 0.02$, $\\sigma_{2,1} = 0.01$。\n  - $t=2$: $r_{1,2} = 0.01$, $r_{2,2} = -0.005$, $\\sigma_{1,2} = 0.01$, $\\sigma_{2,2} = 0.005$。\n  - $t=3$: $r_{1,3} = -0.01$, $r_{2,3} = 0.015$, $\\sigma_{1,3} = 0.01$, $\\sigma_{2,3} = 0.015$。\n  - $t=4$: $r_{1,4} = 0.02$, $r_{2,4} = -0.01$, $\\sigma_{1,4} = 0.02$, $\\sigma_{2,4} = 0.01$。\n  - $t=5$: $r_{1,5} = -0.015$, $r_{2,5} = 0.005$, $\\sigma_{1,5} = 0.015$, $\\sigma_{2,5} = 0.005$。\n- 标准化残差 $z_{1,t} = r_{1,t}/\\sigma_{1,t} \\in \\{-1, 1, -1, 1, -1\\}$ 且 $z_{2,t} = r_{2,t}/\\sigma_{2,t} \\in \\{1, -1, 1, -1, 1\\}$。\n- 权重 $w_1 = 0.6$，$w_2 = 0.4$，当前波动率 $\\sigma_{1,0} = 0.03$，$\\sigma_{2,0} = 0.02$。\n- 对于每个 $t$，$\\tilde{r}_{1,t} = 0.03 z_{1,t}$，$\\tilde{r}_{2,t} = 0.02 z_{2,t}$。因此 $s_t = 0.6 \\cdot \\tilde{r}_{1,t} + 0.4 \\cdot \\tilde{r}_{2,t} = 0.6 \\cdot 0.03 z_{1,t} + 0.4 \\cdot 0.02 z_{2,t} = 0.018 z_{1,t} + 0.008 z_{2,t}$。\n- 使用符号模式，我们得到 $s_t \\in \\{-0.01, 0.01, -0.01, 0.01, -0.01\\}$。排序后：$[-0.01, -0.01, -0.01, 0.01, 0.01]$。\n- 当 $\\alpha = 0.05$ 时，$k = \\lceil 0.05 \\cdot 5 \\rceil = \\lceil 0.25 \\rceil = 1$，因此 $q_\\alpha = -0.01$ 且 $\\text{VaR}_\\alpha = 0.01$。\n\n测试用例 2:\n- $R$、$S$ และ $w$ 与测试用例 1 相同。\n- 当前波动率减半：$\\sigma_{1,0} = 0.015$，$\\sigma_{2,0} = 0.01$；因此 $\\tilde{r}_{1,t} = 0.015 z_{1,t}$，$\\tilde{r}_{2,t} = 0.01 z_{2,t}$ 且 $s_t = 0.6 \\cdot 0.015 z_{1,t} + 0.4 \\cdot 0.01 z_{2,t} = 0.009 z_{1,t} + 0.004 z_{2,t}$。\n- 使用相同的符号模式，$s_t \\in \\{-0.005, 0.005, -0.005, 0.005, -0.005\\}$。排序后：$[-0.005, -0.005, -0.005, 0.005, 0.005]$。\n- 当 $\\alpha = 0.10$ 时，$k = \\lceil 0.10 \\cdot 5 \\rceil = \\lceil 0.5 \\rceil = 1$，因此 $q_\\alpha = -0.005$ 且 $\\text{VaR}_\\alpha = 0.005$。\n\n测试用例 3:\n- 单资产，其 $R_A = [-0.02, 0.01, -0.01, 0.02, -0.015]$，$S_A = [0.02, 0.01, 0.01, 0.02, 0.015]$，因此 $z_{1,t} \\in \\{-1, 1, -1, 1, -1\\}$。\n- 权重 $w_1 = 1.0$，当前波动率 $\\sigma_{1,0} = 0.04$ 给出 $\\tilde{r}_{1,t} = 0.04 z_{1,t}$ 且 $s_t = \\tilde{r}_{1,t} \\in \\{-0.04, 0.04, -0.04, 0.04, -0.04\\}$。\n- 排序后：$[-0.04, -0.04, -0.04, 0.04, 0.04]$。\n- 当 $\\alpha = 0.20$ 时，$k = \\lceil 0.20 \\cdot 5 \\rceil = \\lceil 1.0 \\rceil = 1$，因此 $q_\\alpha = -0.04$ 且 $\\text{VaR}_\\alpha = 0.04$。\n\n实现细节：\n- 逐元素计算 $z_{i,t}$ 为 $r_{i,t}/\\sigma_{i,t}$。\n- 对于每个 $t$，使用给定的 $w_i$ 和 $\\sigma_{i,0}$ 计算 $s_t$。\n- 将 $\\{s_t\\}$ 升序排序，并取第 $k$ 个元素，其中 $k = \\lceil \\alpha T \\rceil$。\n- 对每个测试用例，输出 $\\text{VaR}_\\alpha = - q_\\alpha$，并四舍五入到六位小数。\n- 生成单行输出：一个用方括号括起来的逗号分隔列表，按测试用例 1、测试用例 2、测试用例 3 的顺序排列。\n\n根据以上推导，三个测试用例的预期 VaR 输出分别为 $0.01$、$0.005$ 和 $0.04$，每个都以小数表示并四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef empirical_var_fhs(R, S, w, sigma_now, alpha):\n    \"\"\"\n    Filtered Historical Simulation VaR:\n    - R: array of shape (T, N) historical returns\n    - S: array of shape (T, N) historical conditional volatilities (>0)\n    - w: array of shape (N,) portfolio weights summing to 1\n    - sigma_now: array of shape (N,) current conditional volatilities (>0)\n    - alpha: float in (0,1), VaR level\n    Returns VaR as a positive float (-alpha-quantile of returns).\n    \"\"\"\n    R = np.asarray(R, dtype=float)\n    S = np.asarray(S, dtype=float)\n    w = np.asarray(w, dtype=float)\n    sigma_now = np.asarray(sigma_now, dtype=float)\n    T, N = R.shape\n    assert S.shape == (T, N)\n    assert w.shape == (N,)\n    assert sigma_now.shape == (N,)\n    assert np.all(S > 0), \"Historical sigmas must be > 0\"\n    assert np.all(sigma_now > 0), \"Current sigmas must be > 0\"\n    # Standardized residuals z_{i,t}\n    Z = R / S\n    # Scaled returns under current volatility: \\tilde r_{i,t} = sigma_now[i] * Z[t,i]\n    # Portfolio return per scenario t: s_t = sum_i w_i * \\tilde r_{i,t}\n    scaled = Z * sigma_now  # shape (T, N)\n    s = scaled @ w  # shape (T,)\n    # Empirical alpha-quantile using k = ceil(alpha * T), 1-based\n    s_sorted = np.sort(s)\n    k = int(np.ceil(alpha * T))\n    k = max(k, 1)  # ensure at least first order statistic\n    q_alpha = s_sorted[k - 1]\n    var = -q_alpha\n    return var\n\ndef solve():\n    results = []\n\n    # Test Case 1\n    R1 = np.array([\n        [-0.02,   0.01 ],\n        [ 0.01,  -0.005],\n        [-0.01,   0.015],\n        [ 0.02,  -0.01 ],\n        [-0.015,  0.005]\n    ], dtype=float)\n    S1 = np.array([\n        [0.02,  0.01 ],\n        [0.01,  0.005],\n        [0.01,  0.015],\n        [0.02,  0.01 ],\n        [0.015, 0.005]\n    ], dtype=float)\n    w1 = np.array([0.6, 0.4], dtype=float)\n    sigma_now1 = np.array([0.03, 0.02], dtype=float)\n    alpha1 = 0.05\n    var1 = empirical_var_fhs(R1, S1, w1, sigma_now1, alpha1)\n    results.append(round(var1, 6))\n\n    # Test Case 2\n    sigma_now2 = np.array([0.015, 0.01], dtype=float)\n    alpha2 = 0.10\n    var2 = empirical_var_fhs(R1, S1, w1, sigma_now2, alpha2)\n    results.append(round(var2, 6))\n\n    # Test Case 3 (single asset)\n    R3 = np.array([[-0.02],\n                   [ 0.01],\n                   [-0.01],\n                   [ 0.02],\n                   [-0.015]], dtype=float)\n    S3 = np.array([[0.02],\n                   [0.01],\n                   [0.01],\n                   [0.02],\n                   [0.015]], dtype=float)\n    w3 = np.array([1.0], dtype=float)\n    sigma_now3 = np.array([0.04], dtype=float)\n    alpha3 = 0.20\n    var3 = empirical_var_fhs(R3, S3, w3, sigma_now3, alpha3)\n    results.append(round(var3, 6))\n\n    # Print in exact required format: single line, comma-separated, no spaces, in brackets\n    print(f\"[{','.join(map(lambda x: ('{:.6f}'.format(x)).rstrip('0').rstrip('.') if '.' in '{:.6f}'.format(x) else str(x), results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "这最后一个练习将通过一个复杂的现实场景——评估艺术品收藏的风险——来展示蒙特卡洛模拟的强大功能和灵活性。你将从基本原理出发，构建一个完整的风险模型，它结合了用于非流动性资产的特征定价模型（hedonic pricing model）和相关的冲击结构，以模拟未来的拍卖结果。这项高级实践将挑战你超越标准金融工具的思维，学习如何应用模拟技术来为独特资产类别进行估值和风险管理 [@problem_id:2412262]。", "id": "2412262", "problem": "您的任务是构建一个完整的、可运行的程序，该程序使用蒙特卡洛模拟方法，结合特征价格模型和模拟拍卖结果，来估算一个艺术品收藏的单期风险价值 (VaR)。您的设计必须从核心定义出发：特征价格模型将对数价格表示为可观察特征的线性函数，而置信水平为 $q$ 的风险价值是投资组合损失分布的 $q$-分位数。不能使用任何闭式风险公式；您必须直接模拟该分布。\n\n考虑一个包含 $M$ 件不同艺术品的收藏。每件艺术品 $j$ 都有一个特征向量 $\\mathbf{x}_j \\in \\mathbb{R}^K$ (包含一个截距项) 和一个对应的系数向量 $\\boldsymbol{\\beta} \\in \\mathbb{R}^K$。艺术品 $j$ 的特征对数价格为 $\\mu_j = \\mathbf{x}_j^{\\top}\\boldsymbol{\\beta}$。当前按模型计价的投资组合价值为 $V_0 = \\sum_{j=1}^M \\exp(\\mu_j)$ 美元。拍卖结果被建模为应用于每件艺术品特征价格基线的乘性对数正态冲击。具体来说，艺术品 $j$ 的未来价格为 $P_j = \\exp(\\mu_j + \\varepsilon_j)$，其中拍卖冲击向量 $\\boldsymbol{\\varepsilon} = (\\varepsilon_1,\\dots,\\varepsilon_M)$ 服从多元正态分布，其相关性由单个共同因子引起。为保持每件艺术品满足 $\\mathbb{E}[P_j \\mid \\mu_j] = \\exp(\\mu_j)$，假设 $\\mathbb{E}[\\exp(\\varepsilon_j)] = 1$，这意味着需要根据 $\\varepsilon_j$ 的方差进行均值调整。单期投资组合损失为 $L = V_0 - V_1$，其中 $V_1 = \\sum_{j=1}^M P_j$。置信水平为 $q \\in (0,1)$ 的VaR被计算为模拟得到的 $L$ 的经验 $q$-分位数。\n\n使用以下特征价格模型，其中包含 $M = 5$ 件艺术品和 $K = 5$ 个特征（包括一个截距项）。对于每件艺术品 $j$，其特征向量为 $\\mathbf{x}_j = (1, \\text{size}_j, \\text{pop}_j, \\text{oil}_j, \\text{age}_j)^{\\top}$，其中：\n- 尺寸（平方米），一个非负实数。\n- 受欢迎程度指数，一个大致在 $[0,10]$ 区间内的非负实数。\n- 油画媒介指示符，为 $0$ 或 $1$。\n- 年代（以十年为单位），一个非负实数。\n\n共同系数向量为 $\\boldsymbol{\\beta} = (10.0, 0.8, 0.15, 0.3, 0.02)^{\\top}$。这五件艺术品的特征如下：\n- 艺术品 1：$(1, 0.5, 8.0, 1, 5.0)$\n- 艺术品 2：$(1, 1.2, 5.0, 0, 2.0)$\n- 艺术品 3：$(1, 0.8, 9.0, 1, 10.0)$\n- 艺术品 4：$(1, 2.0, 3.0, 0, 1.0)$\n- 艺术品 5：$(1, 0.3, 6.0, 1, 3.0)$\n\n拍卖冲击通过单个市场因子产生相关性。令 $\\sigma_j \\ge 0$ 表示艺术品 $j$ 的特异性波动率参数。对于选定的相关水平 $\\rho \\in [0,1]$，在一次模拟抽样中，艺术品 $j$ 的拍卖冲击定义为\n$$\n\\varepsilon_j = m_j + \\sigma_j\\left( \\sqrt{\\rho}\\,Z + \\sqrt{1-\\rho}\\,Z_j \\right),\n$$\n其中 $Z \\sim \\mathcal{N}(0,1)$ 是共同市场因子，$Z_j \\sim \\mathcal{N}(0,1)$ 是在不同 $j$ 之间相互独立且与 $Z$ 独立的因子，而 $m_j$ 是一个确定性的均值调整项，确保 $\\mathbb{E}[\\exp(\\varepsilon_j)] = 1$，以保持特征期望价格 $\\exp(\\mu_j)$ 不变。艺术品间冲击的相关性由 $\\rho$ 控制，$\\varepsilon_j$ 的边际方差为 $\\sigma_j^2$。\n\n您的程序必须：\n- 计算每件艺术品的 $\\mu_j = \\mathbf{x}_j^{\\top}\\boldsymbol{\\beta}$ 和以美元计的 $V_0 = \\sum_{j=1}^5 \\exp(\\mu_j)$。\n- 对于每个测试用例，使用上述因子结构以及指定的 $\\rho$ 和 $\\sigma_j$ 值，模拟 $N$ 次 $(\\varepsilon_1,\\dots,\\varepsilon_5)$ 的独立抽样，并使用强制 $\\mathbb{E}[\\exp(\\varepsilon_j)] = 1$ 的均值调整项 $m_j$。\n- 对于每次抽样，计算 $V_1 = \\sum_{j=1}^5 \\exp(\\mu_j + \\varepsilon_j)$，然后计算损失 $L = V_0 - V_1$。\n- 将模拟损失的经验 $q$-分位数作为置信水平为 $q$ 的VaR估计值。\n- 为保证可复现性，使用固定的随机种子安排：设基础种子为 $20231120$；对于测试用例索引 $i \\in \\{0,1,2,3\\}$，使用种子 $20231120 + 1000\\,i$。\n- 将每个VaR四舍五入到两位小数，并报告为一个代表美元（无货币符号）的浮点数，即以美元为单位。\n\n测试套件。使用上述固定的特征价格模型，并评估以下四种情况：\n- 情况 1（理想路径）：$\\boldsymbol{\\sigma} = (0.25, 0.20, 0.30, 0.15, 0.22)$，$\\rho = 0.0$，$q = 0.95$，$N = 100000$。\n- 情况 2（高相关性）：$\\boldsymbol{\\sigma} = (0.25, 0.20, 0.30, 0.15, 0.22)$，$\\rho = 0.9$，$q = 0.99$，$N = 100000$。\n- 情况 3（零波动率边界情况）：$\\boldsymbol{\\sigma} = (0.0, 0.0, 0.0, 0.0, 0.0)$，$\\rho = 0.5$，$q = 0.975$，$N = 100000$。\n- 情况 4（小样本压力测试）：$\\boldsymbol{\\sigma} = (0.25, 0.20, 0.30, 0.15, 0.22)$，$\\rho = 0.5$，$q = 0.95$，$N = 2000$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个案例的VaR估算值，格式为逗号分隔的列表并用方括号括起，例如 $[v_1,v_2,v_3,v_4]$，其中每个 $v_i$ 是按规定四舍五入的以美元计的VaR值。", "solution": "我们从核心定义开始。特征价格模型将价格的对数表示为可观察属性的线性函数。对于特征为 $\\mathbf{x}_j \\in \\mathbb{R}^K$、系数为 $\\boldsymbol{\\beta} \\in \\mathbb{R}^K$ 的艺术品 $j$，其对数价格为 $\\mu_j = \\mathbf{x}_j^{\\top}\\boldsymbol{\\beta}$。当前模型隐含价格为 $\\exp(\\mu_j)$，因此 $M$ 件艺术品的按模型计价的投资组合价值为 $V_0 = \\sum_{j=1}^M \\exp(\\mu_j)$ 美元。\n\n为了对拍卖结果进行建模，我们需要一个随机乘性因子，该因子在扰动每件艺术品特征价格基线的同时，保持其特征期望价值不变。令 $\\varepsilon_j$ 表示艺术品 $j$ 在风险期内的拍卖对数回报率。假设 $\\boldsymbol{\\varepsilon} = (\\varepsilon_1,\\dots,\\varepsilon_M)$ 服从多元正态分布；则价格为 $P_j = \\exp(\\mu_j + \\varepsilon_j)$。对于每个 $j$，我们希望保持 $\\mathbb{E}[P_j \\mid \\mu_j] = \\exp(\\mu_j)$，这等价于 $\\mathbb{E}[\\exp(\\varepsilon_j)] = 1$。如果 $\\varepsilon_j$ 的边际分布为 $\\mathcal{N}(m_j, \\sigma_j^2)$，那么 $\\mathbb{E}[\\exp(\\varepsilon_j)] = \\exp(m_j + \\tfrac{1}{2}\\sigma_j^2)$。令其等于 $1$ 可得 $m_j + \\tfrac{1}{2}\\sigma_j^2 = 0$，即 $m_j = -\\tfrac{1}{2}\\sigma_j^2$。即使在冲击是相关的情况下，这种均值修正也能确保特征期望价格得以保持。\n\n我们通过单因子结构对跨艺术品依赖性进行建模：\n$$\n\\varepsilon_j = m_j + \\sigma_j\\left(\\sqrt{\\rho}\\,Z + \\sqrt{1-\\rho}\\,Z_j\\right),\n$$\n其中 $Z \\sim \\mathcal{N}(0,1)$ 是一个共同因子，$Z_j \\sim \\mathcal{N}(0,1)$ 是独立的特异性因子，所有因子相互独立。于是有 $\\mathbb{E}[\\varepsilon_j] = m_j$，$\\mathrm{Var}(\\varepsilon_j) = \\sigma_j^2$，且对于 $i \\neq j$，有 $\\mathrm{Cov}(\\varepsilon_i,\\varepsilon_j) = \\sigma_i \\sigma_j \\rho$。因此，艺术品间对数拍卖冲击的相关性为 $\\rho$，边际方差为 $\\sigma_j^2$。当 $\\sigma_j = 0$ 时，我们得到 $\\varepsilon_j = 0$ 几乎必然成立，这导致该艺术品的价格动态退化，并且当所有 $\\sigma_j = 0$ 时，投资组合在总体上退化，从而得出 VaR 为 $0$。\n\n单期投资组合损失定义为 $L = V_0 - V_1$，其中 $V_1 = \\sum_{j=1}^M \\exp(\\mu_j + \\varepsilon_j)$。$L$ 的正值表示相对于当前按模型计价的价值有所损失。置信水平为 $q \\in (0,1)$ 的风险价值是损失分布的 $q$-分位数：\n$$\n\\mathrm{VaR}_q = \\inf\\{\\ell \\in \\mathbb{R} : \\mathbb{P}(L \\le \\ell) \\ge q\\}.\n$$\n在相关对数正态分量下 $L$ 的分布没有闭式表达式的情况下，我们通过蒙特卡洛模拟来近似 $\\mathrm{VaR}_q$：模拟多次 $(\\varepsilon_1,\\dots,\\varepsilon_M)$ 的独立抽样，计算相应的 $L$，并取其经验 $q$-分位数。\n\n算法设计：\n1. 计算 $j \\in \\{1,\\dots,M\\}$ 的 $\\mu_j = \\mathbf{x}_j^{\\top}\\boldsymbol{\\beta}$ 和 $V_0 = \\sum_{j=1}^M \\exp(\\mu_j)$。\n2. 对于每个测试用例，其参数为 $(\\boldsymbol{\\sigma}, \\rho, q, N)$：\n   - 对每个 $j$ 设置 $m_j = -\\tfrac{1}{2}\\sigma_j^2$。\n   - 对于用例索引 $i \\in \\{0,1,2,3\\}$，使用种子 $20231120 + 1000\\,i$ 初始化伪随机数生成器。\n   - 抽取 $N$ 个独立的共同因子 $Z \\sim \\mathcal{N}(0,1)$ 和一个 $N \\times M$ 维的独立特异性因子数组 $Z_j \\sim \\mathcal{N}(0,1)$。\n   - 通过向量化构建 $\\varepsilon$：对于 $n \\in \\{1,\\dots,N\\}$ 和 $j \\in \\{1,\\dots,M\\}$，$\\varepsilon_{n,j} = m_j + \\sigma_j(\\sqrt{\\rho}\\,Z_n + \\sqrt{1-\\rho}\\,Z_{n,j})$。\n   - 对每个 $n$，计算 $V_{1,n} = \\sum_{j=1}^M \\exp(\\mu_j + \\varepsilon_{n,j})$ 和 $L_n = V_0 - V_{1,n}$。\n   - 将 $\\{L_n\\}_{n=1}^N$ 的经验 $q$-分位数作为 $\\mathrm{VaR}_q$ 的估计值。\n3. 将每个 VaR 四舍五入到两位小数（美元），并以列表形式输出。\n\n正确性说明：\n- 均值修正项 $m_j = -\\tfrac{1}{2}\\sigma_j^2$ 确保了对每个 $j$ 都有 $\\mathbb{E}[\\exp(\\varepsilon_j)]=1$，因为对于任何正态随机变量 $Y \\sim \\mathcal{N}(m,s^2)$，都有 $\\mathbb{E}[\\exp(Y)] = \\exp(m + \\tfrac{1}{2}s^2)$。这在乘性拍卖因子下保持了特征期望价格 $\\exp(\\mu_j)$。\n- 因子构造提供了预期的相关性结构：对于 $i \\neq j$，$\\mathrm{Corr}(\\varepsilon_i,\\varepsilon_j) = \\rho$，因为共享分量分别为 $\\sqrt{\\rho}\\,\\sigma_i Z$ 和 $\\sqrt{\\rho}\\,\\sigma_j Z$，而特异性分量是独立的。\n- 在边界情况 $\\boldsymbol{\\sigma} = \\mathbf{0}$ 下，所有 $\\varepsilon_j = 0$ 几乎必然成立，因此 $V_1 = V_0$ 且 $L = 0$ 几乎必然成立，所以经验分位数恰好为 $0$。\n\n实现细节：\n- 向量化计算避免了构建完整的协方差矩阵，并能优雅地处理奇异情况，包括 $\\rho \\in \\{0,1\\}$ 和 $\\sigma_j = 0$。\n- 我们对每个案例采用确定性播种，以确保可复现的VaR估计。\n- 最终输出是指定列表格式 $[v_1,v_2,v_3,v_4]$ 的单行文本，其中每个 $v_i$ 是一个四舍五入到两位小数的美元浮点数。\n\n该程序将计算以下四个测试用例的VaR：\n- 情况 1：$\\boldsymbol{\\sigma} = (0.25, 0.20, 0.30, 0.15, 0.22)$, $\\rho = 0.0$, $q = 0.95$, $N = 100000$。\n- 情况 2：$\\boldsymbol{\\sigma} = (0.25, 0.20, 0.30, 0.15, 0.22)$, $\\rho = 0.9$, $q = 0.99$, $N = 100000$。\n- 情况 3：$\\boldsymbol{\\sigma} = (0.0, 0.0, 0.0, 0.0, 0.0)$, $\\rho = 0.5$, $q = 0.975$, $N = 100000$。\n- 情况 4：$\\boldsymbol{\\sigma} = (0.25, 0.20, 0.30, 0.15, 0.22)$, $\\rho = 0.5$, $q = 0.95$, $N = 2000$。\n\n所有 VaR 输出均表示为以美元计的浮点数，四舍五入到两位小数，不带货币符号，并按要求汇总为单行的、用方括号括起来的逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hedonic_mu(X, beta):\n    \"\"\"\n    Compute hedonic log-prices mu_j = x_j^T beta for each item.\n    X: array of shape (M, K)\n    beta: array of shape (K,)\n    Returns: array mu of shape (M,)\n    \"\"\"\n    return X @ beta\n\ndef simulate_var(mu, sigmas, rho, q, N, seed):\n    \"\"\"\n    Simulate VaR at confidence level q via Monte Carlo using a one-factor\n    correlated normal model for auction shocks with mean correction.\n\n    mu: array of shape (M,), hedonic log-prices\n    sigmas: array of shape (M,), nonnegative volatilities\n    rho: float in [0,1], common correlation parameter\n    q: float in (0,1), VaR confidence level\n    N: int, number of simulations\n    seed: int, random seed for reproducibility\n    Returns: float, VaR estimate (not rounded)\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    mu = np.asarray(mu, dtype=float)\n    sigmas = np.asarray(sigmas, dtype=float)\n    M = mu.shape[0]\n\n    # Current mark-to-model portfolio value\n    V0 = np.exp(mu).sum()\n\n    # Mean correction to ensure E[exp(eps_j)] = 1\n    m = -0.5 * sigmas**2\n\n    # Draw factors\n    Z_common = rng.standard_normal(N)  # shape (N,)\n    Z_idio = rng.standard_normal((N, M))  # shape (N, M)\n\n    # Build shocks using factor structure\n    # eps_{n,j} = m_j + sigma_j*(sqrt(rho)*Z_common[n] + sqrt(1-rho)*Z_idio[n,j])\n    sqrt_rho = np.sqrt(rho)\n    sqrt_one_minus_rho = np.sqrt(1.0 - rho)\n    # Broadcast shapes: (N,1) for common, (N,M) for idio, (M,) for sigmas and m\n    eps = m + sigmas * (sqrt_rho * Z_common[:, None] + sqrt_one_minus_rho * Z_idio)\n\n    # Simulated future portfolio values V1 for each of N scenarios\n    # Compute exp(mu + eps) then sum across items\n    V1 = np.exp(mu + eps).sum(axis=1)\n\n    # Losses\n    losses = V0 - V1\n\n    # Empirical q-quantile as VaR\n    var_q = float(np.quantile(losses, q, method='linear'))\n    return var_q\n\ndef solve():\n    # Hedonic coefficients beta (K=5): (intercept, size, popularity, oil_indicator, age_in_decades)\n    beta = np.array([10.0, 0.8, 0.15, 0.3, 0.02], dtype=float)\n\n    # Features X for M=5 items (rows)\n    # Columns: [1, size, popularity, oil_indicator, age_decades]\n    X = np.array([\n        [1.0, 0.5, 8.0, 1.0, 5.0],   # Item 1\n        [1.0, 1.2, 5.0, 0.0, 2.0],   # Item 2\n        [1.0, 0.8, 9.0, 1.0, 10.0],  # Item 3\n        [1.0, 2.0, 3.0, 0.0, 1.0],   # Item 4\n        [1.0, 0.3, 6.0, 1.0, 3.0],   # Item 5\n    ], dtype=float)\n\n    mu = hedonic_mu(X, beta)\n\n    # Base seed schedule: seed_i = 20231120 + 1000*i for case index i\n    base_seed = 20231120\n\n    # Define the test cases: (sigmas, rho, q, N)\n    test_cases = [\n        # Case 1: happy path\n        (np.array([0.25, 0.20, 0.30, 0.15, 0.22], dtype=float), 0.0, 0.95, 100000),\n        # Case 2: high correlation\n        (np.array([0.25, 0.20, 0.30, 0.15, 0.22], dtype=float), 0.9, 0.99, 100000),\n        # Case 3: boundary zero volatility\n        (np.array([0.0, 0.0, 0.0, 0.0, 0.0], dtype=float), 0.5, 0.975, 100000),\n        # Case 4: small sample stress\n        (np.array([0.25, 0.20, 0.30, 0.15, 0.22], dtype=float), 0.5, 0.95, 2000),\n    ]\n\n    results = []\n    for i, (sigmas, rho, q, N) in enumerate(test_cases):\n        seed = base_seed + 1000 * i\n        var_est = simulate_var(mu, sigmas, rho, q, N, seed)\n        # Round to two decimals (dollars)\n        var_rounded = round(var_est, 2)\n        results.append(var_rounded)\n\n    # Final print statement in the exact required format: single line, bracketed, comma-separated\n    # Ensure two decimal places in output formatting\n    formatted = \"[\" + \",\" + \"\".join(f\"{v:.2f},\" for v in results) + \"]\"\n    # The above produces an extra comma; reconstruct properly without trailing comma\n    formatted = \"[\" + \",\".join(f\"{v:.2f}\" for v in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}