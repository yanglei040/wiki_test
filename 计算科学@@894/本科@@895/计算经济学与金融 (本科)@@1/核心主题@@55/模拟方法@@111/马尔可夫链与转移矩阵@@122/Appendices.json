{"hands_on_practices": [{"introduction": "本练习将马尔可夫链应用于劳动力市场动态。通过分析一个描述工人就业状态（失业、兼职、全职）之间转移的转移矩阵 $P$，您将练习计算系统的稳态分布 $\\pi$。这项核心技能使我们能够预测系统的长期均衡，例如经济体中的长期失业率，这是一个关键的宏观经济指标 [@problem_id:2409051]。", "id": "2409051", "problem": "考虑一个离散时间、时间齐次的马尔可夫链，该链模拟了经济体中一个代表性工人每周的劳动力市场状态。状态空间由失业（$U$）、兼职（$P$）和全职（$F$）组成。状态之间的转移在每周结束时根据以下行随机转移矩阵 $P$ 发生，其中状态排序为 $(U, P, F)$：\n$$\nP \\;=\\;\n\\begin{pmatrix}\n\\frac{3}{5} & \\frac{3}{10} & \\frac{1}{10} \\\\\n\\frac{1}{5} & \\frac{1}{2} & \\frac{3}{10} \\\\\n\\frac{1}{20} & \\frac{3}{20} & \\frac{4}{5}\n\\end{pmatrix}.\n$$\n在这些假设下，确定由 $P$ 隐含的长期失业率，该失业率定义为该链唯一的平稳分布中处于状态 $U$ 的平稳（不变）概率。请以精确分数（不进行四舍五入）的形式给出您的答案，表示为小数或不带百分号的分数。", "solution": "该系统是一个具有有限状态空间 $\\{U, P, F\\}$ 的离散时间、时间齐次马尔可夫链。平稳（不变）分布 $\\pi$ 是一个行向量 $\\pi = (\\pi_U, \\pi_P, \\pi_F)$，满足定义条件\n$$\n\\pi = \\pi P, \\quad \\pi_U + \\pi_P + \\pi_F = 1, \\quad \\pi_i \\ge 0 \\text{ for each state } i \\in \\{U, P, F\\}.\n$$\n因为 $P$ 的每个元素都严格为正，所以该链是不可约且非周期的，根据 Perron–Frobenius 定理，这确保了平稳分布的存在性和唯一性。\n\n设 $\\pi = (x, y, z)$，其中 $x = \\pi_U$，$y = \\pi_P$，$z = \\pi_F$。平稳性条件 $\\pi = \\pi P$ 产生了以下方程组\n$$\n\\begin{aligned}\nx &= \\frac{3}{5}x + \\frac{1}{5}y + \\frac{1}{20}z, \\\\\ny &= \\frac{3}{10}x + \\frac{1}{2}y + \\frac{3}{20}z, \\\\\nz &= \\frac{1}{10}x + \\frac{3}{10}y + \\frac{4}{5}z,\n\\end{aligned}\n$$\n以及归一化条件\n$$\nx + y + z = 1.\n$$\n将前两个方程的所有项移到左侧，重写方程如下：\n$$\n\\begin{aligned}\nx - \\frac{3}{5}x - \\frac{1}{5}y - \\frac{1}{20}z &= 0\n\\;\\;\\Rightarrow\\;\\;\n\\frac{2}{5}x - \\frac{1}{5}y - \\frac{1}{20}z = 0, \\\\\ny - \\frac{3}{10}x - \\frac{1}{2}y - \\frac{3}{20}z &= 0\n\\;\\;\\Rightarrow\\;\\;\n\\frac{1}{2}y - \\frac{3}{10}x - \\frac{3}{20}z = 0.\n\\end{aligned}\n$$\n将其中第一个方程乘以 $20$，第二个方程乘以 $20$，以消去分母：\n$$\n\\begin{aligned}\n8x - 4y - z &= 0, \\\\\n-6x + 10y - 3z &= 0.\n\\end{aligned}\n$$\n由第一个方程可得，\n$$\nz = 8x - 4y.\n$$\n将此代入第二个方程：\n$$\n-6x + 10y - 3(8x - 4y) = 0\n\\;\\;\\Rightarrow\\;\\;\n-6x + 10y - 24x + 12y = 0\n\\;\\;\\Rightarrow\\;\\;\n-30x + 22y = 0\n\\;\\;\\Rightarrow\\;\\;\ny = \\frac{15}{11}x.\n$$\n然后\n$$\nz = 8x - 4y = 8x - 4\\left(\\frac{15}{11}x\\right) = \\left(\\frac{88}{11} - \\frac{60}{11}\\right)x = \\frac{28}{11}x.\n$$\n应用归一化条件：\n$$\nx + y + z = 1\n\\;\\;\\Rightarrow\\;\\;\nx + \\frac{15}{11}x + \\frac{28}{11}x = 1\n\\;\\;\\Rightarrow\\;\\;\n\\left(1 + \\frac{15}{11} + \\frac{28}{11}\\right)x = 1\n\\;\\;\\Rightarrow\\;\\;\n\\frac{54}{11}x = 1\n\\;\\;\\Rightarrow\\;\\;\nx = \\frac{11}{54}.\n$$\n因此，平稳分布为\n$\n\\pi = \\left(\\frac{11}{54}, \\frac{15}{54}, \\frac{28}{54}\\right) = \\left(\\frac{11}{54}, \\frac{5}{18}, \\frac{14}{27}\\right),\n$\n而长期失业率，即处于状态 $U$ 的平稳概率，是\n$$\n\\pi_U = \\frac{11}{54}.\n$$\n这已经是所要求的精确分数。", "answer": "$$\\boxed{\\frac{11}{54}}$$"}, {"introduction": "此练习探讨了吸收态马尔可夫链在金融风险管理中的应用。您将为一个公司的信用评级建立模型，其中“违约”（Default）是一个吸收态，然后计算从特定初始评级开始，公司预期需要多少年才会违约。理解和计算到达吸收态的预期时间对于评估信用风险和为金融工具定价至关重要 [@problem_id:2409067]。", "id": "2409067", "problem": "一家公司的信用评级由一个离散时间、时齐马尔可夫链表示，该链在有序状态 $\\{\\text{AAA}, \\text{AA}, \\text{A}, \\text{BBB}, \\text{BB}, \\text{B}, \\text{CCC}, \\text{D}\\}$ 之间进行年度转移，其中 $\\text{D}$ 表示违约且为吸收态。在此状态顺序下，一步转移矩阵 $P$（行和为 $1$）为\n$$\nP \\;=\\;\n\\begin{pmatrix}\n0.5 & 0.5 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0.5 & 0.5 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0.5 & 0.5 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0.5 & 0.5 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0.5 & 0.5 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0.5 & 0.5 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0.5 & 0.5 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\n\\end{pmatrix}.\n$$\n每年，处于非违约状态的公司要么以 $0.5$ 的概率保持其当前评级，要么以 $0.5$ 的概率被下调一级。处于状态 $\\text{CCC}$ 的公司要么以 $0.5$ 的概率保持在 $\\text{CCC}$，要么以 $0.5$ 的概率违约（$\\text{D}$）。状态 $\\text{D}$ 是吸收态。\n\n假设公司年初的评级为 $\\text{A}$，确定其达到违约状态所需的期望年数。请以精确值的年份给出答案（不要四舍五入）。", "solution": "问题是确定一家当前信用评级为 $\\text{A}$ 的公司达到违约状态所需的期望年数。这是一个计算离散时间、时齐马尔可夫链中到达吸收态的期望时间的经典问题。\n\n设马尔可夫链的状态空间为 $S = \\{s_1, s_2, s_3, s_4, s_5, s_6, s_7, s_8\\}$，其中 $s_1 = \\text{AAA}$，$s_2 = \\text{AA}$，$s_3 = \\text{A}$，$s_4 = \\text{BBB}$，$s_5 = \\text{BB}$，$s_6 = \\text{B}$，$s_7 = \\text{CCC}$，以及 $s_8 = \\text{D}$（违约）。状态 $s_8$ 是一个吸收态，而状态 $\\{s_1, \\dots, s_7\\}$ 是暂态。公司的初始状态是 $s_3 = \\text{A}$。转移矩阵由 $P$ 给出。\n\n设 $\\mu_i$ 为从状态 $s_i$ 开始，到达吸收态 $s_8$（违约）所需的期望年数（步数）。我们的目标是求 $\\mu_3$。\n\n根据定义，从吸收态到达吸收态的期望时间为零。因此，我们有：\n$$ \\mu_8 = 0 $$\n\n对于任何暂态 $s_i$（其中 $i \\in \\{1, 2, \\dots, 7\\}$），我们可以通过对第一步的结果进行条件化，为 $\\mu_i$ 建立一个线性方程组。从状态 $s_i$ 出发的期望时间为一年，加上从下一年所达到的状态 $s_j$ 出发的期望时间，并对所有可能的下一状态 $s_j$ 求平均。其公式为：\n$$ \\mu_i = 1 + \\sum_{j=1}^{8} P_{ij} \\mu_j $$\n其中 $P_{ij}$ 是在一步内从状态 $s_i$ 转移到状态 $s_j$ 的概率。\n\n根据给定的转移矩阵 $P$：\n对于任何非违约、非 $\\text{CCC}$ 的评级（即，对于 $i \\in \\{1, 2, \\dots, 6\\}$），公司以 $0.5$ 的概率保持在状态 $s_i$ 或以 $0.5$ 的概率降级到状态 $s_{i+1}$。转移概率为 $P_{ii} = 0.5$，$P_{i,i+1} = 0.5$，对于所有其他 $j$，$P_{ij} = 0$。$\\mu_i$ 的方程是：\n$$ \\mu_i = 1 + P_{ii}\\mu_i + P_{i,i+1}\\mu_{i+1} = 1 + 0.5\\mu_i + 0.5\\mu_{i+1} $$\n整理这个方程，我们得到一个关于 $i \\in \\{1, 2, \\dots, 6\\}$ 的递推关系：\n$$ 0.5\\mu_i = 1 + 0.5\\mu_{i+1} $$\n$$ \\mu_i = 2 + \\mu_{i+1} $$\n\n对于状态 $s_7 = \\text{CCC}$，公司以概率 $P_{77}=0.5$ 保持在状态 $s_7$ 或以概率 $P_{78}=0.5$ 违约到状态 $s_8$。$\\mu_7$ 的方程是：\n$$ \\mu_7 = 1 + P_{77}\\mu_7 + P_{78}\\mu_8 = 1 + 0.5\\mu_7 + 0.5\\mu_8 $$\n代入 $\\mu_8 = 0$，我们有：\n$$ \\mu_7 = 1 + 0.5\\mu_7 $$\n$$ 0.5\\mu_7 = 1 $$\n$$ \\mu_7 = 2 $$\n所以，从状态 $\\text{CCC}$ 开始到违约的期望时间是 $2$ 年。\n\n现在我们可以使用递推关系 $\\mu_i = 2 + \\mu_{i+1}$，通过从 $\\mu_7$ 开始的反向代入，来求解剩余的 $\\mu_i$：\n\n对于状态 $s_6 = \\text{B}$：\n$$ \\mu_6 = 2 + \\mu_7 = 2 + 2 = 4 $$\n\n对于状态 $s_5 = \\text{BB}$：\n$$ \\mu_5 = 2 + \\mu_6 = 2 + 4 = 6 $$\n\n对于状态 $s_4 = \\text{BBB}$：\n$$ \\mu_4 = 2 + \\mu_5 = 2 + 6 = 8 $$\n\n最后，对于初始状态 $s_3 = \\text{A}$：\n$$ \\mu_3 = 2 + \\mu_4 = 2 + 8 = 10 $$\n\n从评级 $\\text{A}$ 开始，公司到违约的期望年数是 $10$。\n问题现已解决。推理过程完整且科学严谨。", "answer": "$$\n\\boxed{10}\n$$"}, {"introduction": "这个实践练习将理论与实证分析相结合，展示了如何使用马尔可夫链来检验金融市场的结构性变化。您将处理（合成的）金融时间序列数据，将回报分类为离散状态，为两个不同时期估计转移矩阵，并执行统计检验以确定市场动态是否发生了显著变化。这种分析对于理解市场制度的演变和调整量化模型至关重要 [@problem_id:2409049]。", "id": "2409049", "problem": "要求您实现一个自包含程序，该程序使用离散时间、有限状态马尔可夫链来评估某一股票市场的动态特性在两个历史时期之间是否存在统计上的显著变化。这两个时期旨在反映 $1980$–$2000$ 年和 $2001$–$2021$ 年，但在此次作业中，您只能使用所提供的测试用例，这些用例是合成的、但在金融上看似合理的收益序列，以小数形式表示。模型使用一个三状态马尔可夫链，其状态为 $\\{\\text{Loss}, \\text{Flat}, \\text{Gain}\\}$（亏损、持平、盈利），根据一个对称区间阈值 $\\tau &gt; 0$ 对每个收益率 $r_t$ 进行如下分类：如果 $r_t &lt; -\\tau$，则为“亏损”；如果 $|r_t| \\le \\tau$，则为“持平”；如果 $r_t &gt; \\tau$，则为“盈利”。对于每个时期，您必须根据观测到的状态序列来估计转移概率矩阵，并检验两个时期的转移矩阵相同的原假设（备择假设为两者不同）。对于每个测试用例，您的程序必须返回一个布尔值，回答在给定的显著性水平 $\\alpha$ 下，该变化是否具有统计显著性。\n\n您的程序必须从下述测试套件中隐式地解释输入参数。对于每个测试用例 $k$，输入为：\n- 分类阈值 $\\tau_k$（无单位；收益率为小数）。\n- 显著性水平 $\\alpha_k$（无单位）。\n- 两个小数收益率序列，时期 1 为 $\\{r^{(1)}_{t}\\}_{t=1}^{T^{(1)}}$，时期 2 为 $\\{r^{(2)}_{t}\\}_{t=1}^{T^{(2)}}$，其中 $T^{(1)} \\ge 2$ 且 $T^{(2)} \\ge 2$。\n\n根据第一性原理：\n- 将分类后状态的时间序列视为在状态空间 $\\{\\text{Loss}, \\text{Flat}, \\text{Gain}\\}$ 上的时间齐次一阶马尔可夫链的实现。\n- 对每个时期 $m \\in \\{1,2\\}$，构建 $3 \\times 3$ 的转移计数矩阵 $N^{(m)} = [n^{(m)}_{ij}]$，其中 $n^{(m)}_{ij}$ 统计在该时期内，从起始状态 $i$ 到目标状态 $j$ 的连续时间转移次数。在整个过程中采用固定的状态顺序 $(\\text{Loss}, \\text{Flat}, \\text{Gain})$。\n- 通过最大似然估计量 $\\hat{p}^{(m)}_{ij} = n^{(m)}_{ij}/\\sum_{j} n^{(m)}_{ij}$ 来估计每个时期的转移概率矩阵 $\\hat{P}^{(m)} = [\\hat{p}^{(m)}_{ij}]$。此估计适用于任何至少有一次观测到的出向转移的起始状态 $i$（总出向转移为零的行不贡献任何参数或似然）。\n- 使用基于每个起始行多项式模型的、适当的似然统计检验方法，来检验两个时期共享一个共同转移矩阵的原假设。决策规则必须是：当且仅当 p 值严格小于 $\\alpha$ 时，拒绝原假设。\n- 如果对于某个特定的起始状态，两个时期中至少有一个时期的总出向转移为零，则该起始状态不为检验贡献任何参数或自由度，并且其似然贡献定义为零。\n\n您的程序必须生成单行输出，其中包含一个由逗号分隔的布尔值列表，并用方括号括起来。例如，如果有三个测试用例，输出必须类似于“[True,False,True]”。\n\n测试套件：\n使用以下三个测试用例。在所有情况下，收益率均为小数（例如，$0.01$ 表示百分之一）。为紧凑地构建收益序列，请使用映射 $\\text{Gain} \\mapsto r_G = 0.01$、$\\text{Flat} \\mapsto r_F = 0.0$、$\\text{Loss} \\mapsto r_L = -0.01$，并通过将给定的有限状态模式重复指定次数来构建每个序列。分类使用每个用例指定的 $\\tau$。\n\n- 测试用例 1（具有明显机制变化的常规情况）：\n  - $\\tau_1 = 0.002, \\alpha_1 = 0.05$。\n  - 时期 1 序列：将模式 $(\\text{Gain}, \\text{Gain}, \\text{Gain}, \\text{Gain}, \\text{Loss}, \\text{Loss}, \\text{Loss}, \\text{Loss}, \\text{Flat}, \\text{Flat}, \\text{Flat}, \\text{Flat})$ 精确重复 $20$ 次。\n  - 时期 2 序列：将模式 $(\\text{Gain}, \\text{Loss}, \\text{Gain}, \\text{Loss}, \\text{Gain}, \\text{Loss}, \\text{Flat}, \\text{Gain}, \\text{Flat}, \\text{Gain}, \\text{Flat}, \\text{Gain})$ 精确重复 $20$ 次。\n\n- 测试用例 2（无变化；不包含“持平”起始行的边界情况）：\n  - $\\tau_2 = 0.002, \\alpha_2 = 0.05$。\n  - 时期 1 序列：将模式 $(\\text{Gain}, \\text{Gain}, \\text{Loss}, \\text{Loss})$ 精确重复 $50$ 次。\n  - 时期 2 序列：将相同的模式 $(\\text{Gain}, \\text{Gain}, \\text{Loss}, \\text{Loss})$ 精确重复 $50$ 次。\n\n- 测试用例 3（时期 2 中缺少一个起始行且显著性水平严格的边缘情况）：\n  - $\\tau_3 = 0.002, \\alpha_3 = 1\\times 10^{-6}$。\n  - 时期 1 序列：将模式 $(\\text{Gain}, \\text{Gain}, \\text{Gain}, \\text{Flat}, \\text{Loss}, \\text{Loss}, \\text{Loss})$ 精确重复 $10$ 次。\n  - 时期 2 序列：将模式 $(\\text{Gain}, \\text{Gain}, \\text{Gain}, \\text{Loss}, \\text{Loss}, \\text{Loss})$ 精确重复 $10$ 次。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个方括号括起来的、按测试用例顺序排列的、逗号分隔的结果列表，例如“[result1,result2,result3]”，其中每个结果都是一个布尔值，指示在该测试用例指定的 $\\alpha$ 下，转移矩阵的变化是否具有统计显著性。", "solution": "该问题要求进行一项统计检验，以确定一个被建模为离散时间马尔可夫链的股票市场，其转移动态在两个时期之间是否发生了变化。解决方案涉及将金融收益数据离散化，估计转移矩阵，并应用似然比检验来检验马尔可夫链的同质性。\n\n状态空间定义为 $S = \\{S_0, S_1, S_2\\}$，分别对应于 $\\{\\text{Loss}, \\text{Flat}, \\text{Gain}\\}$（亏损、持平、盈利）。在时间 $t$ 的一个收益观测值 $r_t$ 会根据给定的阈值 $\\tau > 0$ 被分类到一个状态中：\n$$\n\\text{State}(r_t) =\n\\begin{cases}\n    S_0 (\\text{Loss}) & \\text{if } r_t < -\\tau \\\\\n    S_1 (\\text{Flat}) & \\text{if } |r_t| \\le \\tau \\\\\n    S_2 (\\text{Gain}) & \\text{if } r_t > \\tau\n\\end{cases}\n$$\n此分类将每个时期的收益率时间序列 $\\{r^{(m)}_t\\}_{t=1}^{T^{(m)}}$（对于时期 $m \\in \\{1, 2\\}$）转换为一个状态序列。\n\n我们将每个状态序列建模为一阶时间齐次马尔可夫链的实现。该模型的核心是转移概率矩阵 $P^{(m)} = [p_{ij}^{(m)}]$，其中 $p_{ij}^{(m)}$ 是在时期 $m$ 从状态 $S_i$ 转移到状态 $S_j$ 的概率。第一步是估计这些矩阵。对于每个时期 $m$，我们构建一个 $3 \\times 3$ 的转移计数矩阵 $N^{(m)} = [n_{ij}^{(m)}]$，其中 $n_{ij}^{(m)}$ 是观测到的从状态 $S_i$ 到状态 $S_j$ 的转移次数。转移概率 $p_{ij}^{(m)}$ 的最大似然估计量 (MLE) 由观测到的转移计数之比给出：\n$$\n\\hat{p}_{ij}^{(m)} = \\frac{n_{ij}^{(m)}}{N_i^{(m)}}\n\\quad \\text{其中} \\quad\nN_i^{(m)} = \\sum_{j=0}^{2} n_{ij}^{(m)}\n$$\n此估计是针对每个总出向转移次数 $N_i^{(m)}$ 大于零的起始状态 $S_i$ 进行的。\n\n主要目标是检验原假设 $H_0$（两个时期的转移矩阵相同）与备择假设 $H_A$（它们不相同）：\n$$\nH_0: P^{(1)} = P^{(2)} \\qquad \\text{vs.} \\qquad H_A: P^{(1)} \\neq P^{(2)}\n$$\n这是一项关于两条马尔可夫链同质性的检验。由于从给定状态 $S_i$ 出发的转移遵循多项式分布，问题简化为对转移矩阵的每一行 $i$ 检验多项式分布的同质性。对此的标准程序是 Anderson-Goodman 检验，它基于似然比原则。\n\n对于每个起始状态 $S_i$，检验统计量是逐行计算的。只有当某一行 $i$ 在两个时期中都曾作为起始状态被观测到时（即 $N_i^{(1)} > 0$ 且 $N_i^{(2)} > 0$），该行才被包含在检验中。对于每个这样的有效行 $i$，我们计算一个似然比检验统计量 $G_i^2$。总检验统计量 $G^2$ 是这些单个统计量的和：\n$$\nG^2 = \\sum_{i \\text{ s.t. } N_i^{(1)}>0, N_i^{(2)}>0} G_i^2\n$$\n行 $i$ 的统计量 $G_i^2$ 比较了数据在备择假设下（使用独立的概率 $\\hat{p}_{ij}^{(1)}$ 和 $\\hat{p}_{ij}^{(2)}$）的似然与在原假设下（使用一个共同的、合并的概率 $\\hat{p}_{ij}^{\\text{pool}}$）的似然。合并概率估计为：\n$$\n\\hat{p}_{ij}^{\\text{pool}} = \\frac{n_{ij}^{(1)} + n_{ij}^{(2)}}{N_i^{(1)} + N_i^{(2)}} = \\frac{n_{ij}^{\\text{pool}}}{N_i^{\\text{pool}}}\n$$\n行 $i$ 的似然比统计量由下式给出：\n$$\nG_i^2 = 2 \\sum_{m=1}^{2} \\sum_{j=0}^{2} n_{ij}^{(m)} \\log\\left(\\frac{\\hat{p}_{ij}^{(m)}}{\\hat{p}_{ij}^{\\text{pool}}}\\right)\n$$\n其中 $n_{ij}^{(m)} = 0$ 的项被视为零。为保证计算稳定性，这可以表示为 $n \\log n$ 项的和：\n$$\nG_i^2 = 2 \\left( \\sum_{m,j} n_{ij}^{(m)}\\log n_{ij}^{(m)} - \\sum_{m} N_i^{(m)}\\log N_i^{(m)} - \\sum_{j} n_{ij}^{\\text{pool}}\\log n_{ij}^{\\text{pool}} + N_i^{\\text{pool}}\\log N_i^{\\text{pool}} \\right)\n$$\n其中每个求和都只针对计数不为零的项。\n\n在原假设下，总统计量 $G^2$ 服从卡方（$\\chi^2$）分布。检验的自由度 ($df$)是每个有效行的自由度之和。对于每个被包含的行 $i$，我们比较的是两个具有 $K=3$ 个类别的多项式分布，这贡献了 $K-1=2$ 个自由度。因此，总自由度为 $df = 2 \\times (\\text{有效行数})$。如果没有可供比较的有效行，则 $df=0$，检验无定义，我们断定没有显著变化的证据。\n\n最后，通过将计算出的 p 值与给定的显著性水平 $\\alpha_k$ 进行比较来做出决策。p 值是在假设 $H_0$ 为真的情况下，观测到至少与计算出的检验统计量一样极端的统计量的概率：\n$$\np\\text{-value} = P(\\chi^2_{df} \\ge G^2)\n$$\n当且仅当 p 值严格小于 $\\alpha_k$ 时，拒绝原假设。拒绝原假设意味着市场动态存在统计上的显著变化。如果变化是显著的，程序返回 `True`，否则返回 `False`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting statistically significant changes\n    in Markov chain dynamics between two periods for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"tau\": 0.002,\n            \"alpha\": 0.05,\n            \"period1_pattern\": ('G','G','G','G','L','L','L','L','F','F','F','F'),\n            \"period1_reps\": 20,\n            \"period2_pattern\": ('G','L','G','L','G','L','F','G','F','G','F','G'),\n            \"period2_reps\": 20,\n        },\n        {\n            \"tau\": 0.002,\n            \"alpha\": 0.05,\n            \"period1_pattern\": ('G','G','L','L'),\n            \"period1_reps\": 50,\n            \"period2_pattern\": ('G','G','L','L'),\n            \"period2_reps\": 50,\n        },\n        {\n            \"tau\": 0.002,\n            \"alpha\": 1e-6,\n            \"period1_pattern\": ('G','G','G','F','L','L','L'),\n            \"period1_reps\": 10,\n            \"period2_pattern\": ('G','G','G','L','L','L'),\n            \"period2_reps\": 10,\n        }\n    ]\n\n    # Mapping from state character to return value and state index\n    # State order: {0: Loss, 1: Flat, 2: Gain}\n    state_info = {\n        'L': {'return': -0.01, 'index': 0},\n        'F': {'return': 0.0, 'index': 1},\n        'G': {'return': 0.01, 'index': 2},\n    }\n    \n    num_states = 3\n    results = []\n\n    for case in test_cases:\n        tau = case[\"tau\"]\n        alpha = case[\"alpha\"]\n\n        # 1. Generate return sequences\n        p1_ret_seq = [state_info[s]['return'] for s in case[\"period1_pattern\"]] * case[\"period1_reps\"]\n        p2_ret_seq = [state_info[s]['return'] for s in case[\"period2_pattern\"]] * case[\"period2_reps\"]\n\n        # 2. Classify returns into states\n        def classify_returns(returns, tau):\n            states = []\n            for r in returns:\n                if r < -tau:\n                    states.append(state_info['L']['index'])\n                elif r > tau:\n                    states.append(state_info['G']['index'])\n                else: # abs(r) <= tau\n                    states.append(state_info['F']['index'])\n            return states\n\n        p1_state_seq = classify_returns(p1_ret_seq, tau)\n        p2_state_seq = classify_returns(p2_ret_seq, tau)\n\n        # 3. Compute transition count matrices\n        def get_transition_counts(state_seq, n_states):\n            counts = np.zeros((n_states, n_states), dtype=np.int64)\n            for i in range(len(state_seq) - 1):\n                origin_state = state_seq[i]\n                dest_state = state_seq[i+1]\n                counts[origin_state, dest_state] += 1\n            return counts\n\n        N1 = get_transition_counts(p1_state_seq, num_states)\n        N2 = get_transition_counts(p2_state_seq, num_states)\n\n        # 4. Perform the Anderson-Goodman test\n        total_g_squared = 0.0\n        total_df = 0\n\n        N1_row_sums = N1.sum(axis=1)\n        N2_row_sums = N2.sum(axis=1)\n\n        for i in range(num_states):\n            # A row is included if it has transitions in BOTH periods\n            if N1_row_sums[i] > 0 and N2_row_sums[i] > 0:\n                # Calculate G^2 statistic for this row\n                g_squared_i = 0.0\n                \n                N_pool_row = N1[i, :] + N2[i, :]\n                N_pool_row_sum = N_pool_row.sum()\n\n                # Use log-likelihood formula resistant to n=0\n                # G^2 = 2 * ( sum(n log n) - sum(row_sum log row_sum) - sum(col_sum log col_sum) + total log total )\n                # For a single row of the transition matrix, this applies to the 2xK contingency table\n                \n                # sum(n log n) term\n                term1 = 0.0\n                for n in np.concatenate((N1[i, :], N2[i, :])):\n                    if n > 0:\n                        term1 += n * np.log(n)\n                \n                # sum(row_sum log row_sum) term\n                term2 = 0.0\n                term2 += N1_row_sums[i] * np.log(N1_row_sums[i])\n                term2 += N2_row_sums[i] * np.log(N2_row_sums[i])\n\n                # sum(col_sum log col_sum) term\n                term3 = 0.0\n                for n_pool in N_pool_row:\n                    if n_pool > 0:\n                        term3 += n_pool * np.log(n_pool)\n\n                # total log total term\n                term4 = 0.0\n                if N_pool_row_sum > 0:\n                    term4 = N_pool_row_sum * np.log(N_pool_row_sum)\n\n                g_squared_i = 2 * (term1 - term2 - term3 + term4)\n                \n                total_g_squared += g_squared_i\n                total_df += (num_states - 1)\n\n        # 5. Calculate p-value and make a decision\n        if total_df == 0:\n            # No basis for comparison, so no evidence to reject H0\n            p_value = 1.0\n        else:\n            # sf is the survival function (1 - cdf)\n            p_value = chi2.sf(total_g_squared, total_df)\n        \n        is_significant = p_value < alpha\n        results.append(is_significant)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b), results))}]\")\n\nsolve()\n```"}]}