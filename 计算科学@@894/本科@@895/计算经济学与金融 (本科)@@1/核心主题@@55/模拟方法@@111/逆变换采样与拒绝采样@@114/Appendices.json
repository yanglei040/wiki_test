{"hands_on_practices": [{"introduction": "逆变换采样是生成随机变量最直观的方法之一，尤其是在累积分布函数的逆函数（即分位数函数）已知且易于计算时。这个练习将指导你为标准的逻辑斯谛分布实现逆变换采样，并揭示其与金融和统计学中广泛使用的对数几率（logit）变换之间的深刻联系[@problem_id:2403666]。通过这个实践，你不仅能掌握一个核心的模拟技术，还能加深对逻辑斯谛分布在建模中的作用的理解。", "id": "2403666", "problem": "要求您实现标准逻辑斯谛分布的逆变换采样法，并证明其等同于取优势比的对数（也称为对数优势或 logit）。您的实现必须是一个完整的、可运行的程序。\n\n请从以下基础理论出发：\n\n- 如果 $U$ 是一个在单位区间上服从连续均匀分布的随机变量，记作 $U \\sim \\mathrm{Uniform}(0,1)$，且 $F$ 是一个连续且严格递增的累积分布函数，那么随机变量 $X = F^{-1}(U)$ 的累积分布函数为 $F$。这是逆变换采样法的基本原理，它源于累积分布函数的定义以及 $F$ 的单调性。\n- 标准逻辑斯谛分布的累积分布函数为 $F(x) = \\dfrac{1}{1 + e^{-x}}$，对所有实数 $x \\in \\mathbb{R}$ 成立。其均值为 $0$，方差为 $\\dfrac{\\pi^2}{3}$。\n\n您的任务：\n\n1. 仅使用上述基本事实，为标准逻辑斯谛累积分布函数推导出显式的逆变换 $F^{-1}$，并解释为何该逆变换等于相应累积概率的对数优势。对于概率 $p \\in (0,1)$，对数优势变换定义为 $\\log\\!\\left(\\dfrac{p}{1-p}\\right)$，其中 $\\log$ 表示自然对数。\n2. 为以下各项实现数值稳定的函数：\n   - 逻辑斯谛累积分布函数 $F(x)$。\n   - 在 $(0,1)$ 上的逻辑斯谛逆变换 $F^{-1}(u)$。\n3. 通过一个包含典型值和边界情况值的小型测试套件，验证逆变换和对数优势关系。\n\n测试套件和要求的检查：\n\n- 使用以下概率 $u$ 来测试逆变换：$u \\in \\{0.1, 0.5, 0.9, 10^{-12}, 1 - 10^{-12}\\}$。对于此集合中的每个 $u$，计算 $x = F^{-1}(u)$ 并数值验证 $|F(x) - u| \\leq \\varepsilon$ 是否成立，容差 $\\varepsilon = 10^{-10}$。为每个 $u$ 记录一个布尔值，以表明该条件是否成立。\n- 使用以下实数值 $x$ 来测试对数优势关系：$x \\in \\{-6.0, -1.0, 0.0, 2.5, 10.0\\}$。对于此集合中的每个 $x$，计算 $u = F(x)$ 并验证 $\\left|\\log\\!\\left(\\dfrac{u}{1-u}\\right) - x\\right| \\leq \\varepsilon$ 是否成立，使用相同的容差 $\\varepsilon = 10^{-10}$。为每个 $x$ 记录一个布尔值，以表明该条件是否成立。\n- 使用逆变换采样法，通过将 $U_1, \\dots, U_N$（其中 $U_i \\sim \\mathrm{Uniform}(0,1)$）转换为 $X_i = F^{-1}(U_i)$，从标准逻辑斯谛分布中生成 $N = 100000$ 个独立同分布 (IID) 的样本。设 $\\bar{X}_N$ 为样本均值，$S_N^2$ 为样本方差。使用容差 $\\delta_{\\mathrm{mean}} = 0.02$ 和 $\\delta_{\\mathrm{var}} = 0.05$ 验证以下条件：\n  - $|\\bar{X}_N - 0| \\leq \\delta_{\\mathrm{mean}}$，\n  - $\\left|S_N^2 - \\dfrac{\\pi^2}{3}\\right| \\leq \\delta_{\\mathrm{var}}$。\n  为均值检查和方差检查各记录一个布尔值。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个以逗号分隔并用方括号括起来的结果列表（例如，“[true1,true2,...]”）。顺序必须是：\n  - 对应于 $u \\in \\{0.1, 0.5, 0.9, 10^{-12}, 1 - 10^{-12}\\}$ 的五个逆变换检查的布尔值（按此顺序），\n  - 接着是对应于 $x \\in \\{-6.0, -1.0, 0.0, 2.5, 10.0\\}$ 的五个对数优势检查的布尔值（按此顺序），\n  - 接着是关于样本均值和方差的两个蒙特卡洛检查的布尔值（按此顺序）。", "solution": "问题陈述已经过评估，并被确定为 **有效**。它在科学上基于概率论和统计学的既定原则，问题设定良好，目标和约束清晰，并以客观、明确的语言表述。所要求的任务是计算统计学中的标准练习。我们将继续提供解决方案。\n\n解决方案分为三部分：逆变换的解析推导，其数值稳定实现的讨论，以及其数值验证的方案。\n\n### 1. 解析推导\n\n逆变换采样方法的核心在于对累积分布函数 (CDF) 进行求逆。\n\n#### 1.1. 标准逻辑斯谛 CDF 的逆\n\n标准逻辑斯谛分布由其 CDF $F(x)$ 定义：\n$$F(x) = \\frac{1}{1 + e^{-x}}$$\n为了应用逆变换采样法，我们必须通过求解 $x$ 来找到逆函数 $x = F^{-1}(u)$，其中给定概率 $u = F(x)$ 且 $u \\in (0, 1)$。\n\n我们从 CDF 的方程开始：\n$$u = \\frac{1}{1 + e^{-x}}$$\n我们进行代数运算来分离出 $x$：\n$$1 + e^{-x} = \\frac{1}{u}$$\n$$e^{-x} = \\frac{1}{u} - 1$$\n$$e^{-x} = \\frac{1 - u}{u}$$\n对两边取自然对数，得到：\n$$\\ln(e^{-x}) = \\ln\\left(\\frac{1 - u}{u}\\right)$$\n$$-x = \\ln\\left(\\frac{1 - u}{u}\\right)$$\n最后，求解 $x$：\n$$x = -\\ln\\left(\\frac{1 - u}{u}\\right) = \\ln\\left(\\left(\\frac{1 - u}{u}\\right)^{-1}\\right) = \\ln\\left(\\frac{u}{1 - u}\\right)$$\n因此，逆函数，也称为分位数函数，是：\n$$F^{-1}(u) = \\ln\\left(\\frac{u}{1 - u}\\right)$$\n\n#### 1.2. 与对数优势 (Logit) 函数的等价性\n\n概率 $p$ 的对数优势，或称 logit 变换，定义为 $\\log\\left(\\frac{p}{1-p}\\right)$。通过将概率 $p$ 设置为累积概率 $u = F(x)$， $u$ 的对数优势变为：\n$$\\text{logit}(u) = \\log\\left(\\frac{u}{1 - u}\\right)$$\n将此与我们推导出的逆函数 $F^{-1}(u)$ 进行比较，我们发现它们是相同的：\n$$x = F^{-1}(u) = \\log\\left(\\frac{u}{1 - u}\\right) = \\text{logit}(u)$$\n这证明了逻辑斯谛分布的一个基本性质：来自标准逻辑斯谛分布的随机变量 $X$ 等于其自身累积概率 $U=F(X)$ 的对数优势。这种关系在逻辑斯谛回归等模型中的应用至关重要。\n\n### 2. 数值实现策略\n\n数值计算的正确性要求关注潜在的不稳定性，如溢出和精度损失。\n\n#### 2.1. CDF 函数 $F(x)$\n\n如果 $x$ 是一个大的负数，$e^{-x}$ 会变得非常大，直接实现 $F(x) = \\frac{1}{1 + e^{-x}}$ 容易发生数值溢出。一个更稳定的实现利用了代数上等价的另一种形式，$F(x) = \\frac{e^x}{1 + e^x}$，当 $x$ 为负数时，$e^x$ 趋近于 $0$，因此该形式是稳定的。因此，一个稳健的函数应该根据 $x$ 的符号进行分支：\n- 对于 $x \\ge 0$，使用 $F(x) = \\frac{1}{1 + e^{-x}}$。此时 $e^{-x}$ 介于 $0$ 和 $1$ 之间，没有溢出风险。\n- 对于 $x < 0$，使用 $F(x) = \\frac{e^x}{1 + e^x}$。此时 $e^{x}$ 介于 $0$ 和 $1$ 之间，同样没有溢出风险。\n这确保了在整个实数轴 $\\mathbb{R}$ 上的稳定性。\n\n#### 2.2. 逆 CDF 函数 $F^{-1}(u)$\n\n逆 CDF，$F^{-1}(u) = \\ln\\left(\\frac{u}{1 - u}\\right)$，可以实现为 $\\ln(u) - \\ln(1 - u)$。对于极度接近 $1$ 的 $u$ 值，如果机器精度不足，计算 $1-u$ 可能会遭受灾难性抵消。然而，对于标准的双精度浮点运算和所提供的测试值（例如 $u = 1 - 10^{-12}$），$1-u$ 的计算是精确的。因此，对于本问题，直接实现是足够且准确的。\n\n### 3. 验证方案\n\n问题指定了三组测试来验证我们推导和实现的正确性。\n\n1.  **逆变换检查**：我们将为一组概率 $u$ 计算 $x = F^{-1}(u)$，并验证 $F(x)$ 在指定的容差 $\\varepsilon = 10^{-10}$ 内恢复了原始的 $u$。这确认了我们实现的函数确实互为逆函数。\n\n2.  **对数优势关系检查**：对于一组值 $x$，我们将计算 $u=F(x)$ 并验证 $u$ 的对数优势 $\\log\\left(\\frac{u}{1-u}\\right)$ 在容差 $\\varepsilon = 10^{-10}$ 内恢复了原始的 $x$。这在数值上验证了恒等式 $x = \\text{logit}(F(x))$。\n\n3.  **蒙特卡洛模拟**：我们将使用逆变换采样法，作用于一个均匀随机数流，从标准逻辑斯谛分布中生成 $N=100000$ 个随机变量值。然后，我们将计算样本均值 $\\bar{X}_N$ 和样本方差 $S_N^2$。这些统计量将与标准逻辑斯谛分布已知的理论均值（$\\mu=0$）和方差（$\\sigma^2 = \\pi^2/3$）进行比较。结果是否在指定的容差（$\\delta_{\\mathrm{mean}} = 0.02$ 和 $\\delta_{\\mathrm{var}} = 0.05$）内，为采样方法正确生成了目标分布的变量值提供了经验证据。将使用固定的随机种子以确保结果的可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies the inverse transform sampling for the standard logistic distribution.\n    \"\"\"\n\n    # --- Task 2: Implement numerically stable functions ---\n\n    def logistic_cdf(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Numerically stable computation of the standard logistic CDF.\n        F(x) = 1 / (1 + exp(-x))\n        \"\"\"\n        x = np.asanyarray(x, dtype=float)\n        res = np.empty_like(x)\n        \n        # For non-negative x, the standard formula is stable.\n        pos_mask = (x >= 0)\n        res[pos_mask] = 1.0 / (1.0 + np.exp(-x[pos_mask]))\n        \n        # For negative x, use the equivalent form F(x) = exp(x) / (1 + exp(x)) to avoid overflow.\n        neg_mask = ~pos_mask\n        exp_x_neg = np.exp(x[neg_mask])\n        res[neg_mask] = exp_x_neg / (1.0 + exp_x_neg)\n        \n        return res\n\n    def logistic_inv_cdf(u: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the inverse of the standard logistic CDF (quantile function or logit).\n        F_inv(u) = log(u / (1 - u))\n        \"\"\"\n        u = np.asanyarray(u, dtype=float)\n        # The form log(u) - log(1-u) is equivalent and standard.\n        return np.log(u) - np.log(1 - u)\n\n    # --- Task 3: Verify the implementation ---\n\n    results = []\n    \n    # Test Suite 1: Inverse transform check\n    # For each u, compute x = F_inv(u) and check |F(x) - u| <= epsilon\n    epsilon = 1e-10\n    u_vals = np.array([0.1, 0.5, 0.9, 1e-12, 1.0 - 1e-12])\n    \n    x_from_u = logistic_inv_cdf(u_vals)\n    u_recalc = logistic_cdf(x_from_u)\n    inv_transform_checks = np.abs(u_recalc - u_vals) <= epsilon\n    results.extend(inv_transform_checks)\n\n    # Test Suite 2: Log-odds relationship check\n    # For each x, compute u = F(x) and check |log(u/(1-u)) - x| <= epsilon\n    x_vals = np.array([-6.0, -1.0, 0.0, 2.5, 10.0])\n    \n    u_from_x = logistic_cdf(x_vals)\n    # The log-odds is identical to the inverse CDF function.\n    x_recalc = logistic_inv_cdf(u_from_x)\n    log_odds_checks = np.abs(x_recalc - x_vals) <= epsilon\n    results.extend(log_odds_checks)\n\n    # Test Suite 3: Monte Carlo simulation check\n    N = 100000\n    delta_mean = 0.02\n    delta_var = 0.05\n    \n    # Use a fixed seed for reproducibility.\n    np.random.seed(42)\n    \n    # Generate N uniform samples from (0, 1)\n    uniform_samples = np.random.uniform(0.0, 1.0, N)\n    \n    # Apply inverse transform sampling\n    logistic_samples = logistic_inv_cdf(uniform_samples)\n    \n    # Calculate sample mean and variance (with ddof=1 for unbiased estimator)\n    sample_mean = np.mean(logistic_samples)\n    sample_var = np.var(logistic_samples, ddof=1)\n    \n    # Theoretical properties of the standard logistic distribution\n    true_mean = 0.0\n    true_var = np.pi**2 / 3.0\n    \n    # Perform checks\n    mean_check = np.abs(sample_mean - true_mean) <= delta_mean\n    var_check = np.abs(sample_var - true_var) <= delta_var\n    results.extend([mean_check, var_check])\n\n    # Final output formatting\n    # Convert boolean values to lowercase strings \"true\" or \"false\"\n    results_str = [str(b).lower() for b in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"}, {"introduction": "当我们无法轻易求得累积分布函数的逆函数时，拒绝采样法提供了一种强大而灵活的替代方案。该方法的核心思想是从一个简单的提议分布中抽取候选样本，然后根据一个接受准则来“筛选”出符合目标分布的样本[@problem_id:2403643]。本练习将通过为一个非标准的周期性目标分布实现拒绝采样器，让你亲身体验这个过程的每个步骤，从设置包络常数到评估采样效率。", "id": "2403643", "problem": "构建一个程序，从区间 $[0,4\\pi]$ 上的一个概率分布中生成独立抽样，其密度与 $x \\mapsto \\frac{1}{1+\\lvert \\sin(x)\\rvert}$ 成正比，并为一组参数配置计算指定的汇总统计数据。所有角度均以弧度为单位。您的程序必须仅依赖于目标分布的定义和一个明确指定的、来源于 $[0,1)$ 上独立均匀分布的随机数源，且不读取任何外部输入。\n\n目标密度定义为\n$$\nf(x) \\;=\\; c \\cdot \\frac{1}{1+\\lvert \\sin(x)\\rvert}, \\quad x \\in [0,4\\pi],\n$$\n在此区间外 $f(x)=0$，其中归一化常数 $c$ 由要求 $\\int_0^{4\\pi} f(x)\\,dx = 1$ 唯一确定。\n\n为生成候选点和报告接受率，考虑一个在 $[0,4\\pi]$ 上均匀分布的建议密度 $g$，即\n$$\ng(x) \\;=\\; \\frac{1}{4\\pi} \\quad \\text{for } x\\in[0,4\\pi], \\quad \\text{and } g(x)=0 \\text{ otherwise},\n$$\n以及一个正常数 $M$，使得对于所有 $x\\in[0,4\\pi]$，都有 $f(x)\\le M\\,g(x)$。\n\n随机数生成必须使用以下线性同余生成器 (LCG) 来产生一个可复现的、服从 $[0,1)$ 上均匀分布的变量序列。设整数状态为 $(s_n)_{n\\ge 0}$，其满足\n$$\ns_{n+1} \\;=\\; (a\\, s_n + c_0) \\bmod m,\n$$\n其中 $a=1664525$，$c_0=1013904223$，$m=2^{32}$。每个在 $[0,1)$ 上的均匀分布变量由 $u_n = s_n/m$ 给出。对于下方的每个测试用例，将 $s_0$ 初始化为指定的种子值，并按顺序使用生成的序列。\n\n测试套件：\n- 测试用例 1 (边界规模样本)：使用种子 $s_0=314159265$、常数 $M=\\frac{\\pi}{2}$，并产生 $N=1$ 个接受的抽样。输出单个接受值 $x_1$，四舍五入到 6 位小数。\n- 测试用例 2 (中等规模样本，精确 $M$)：使用种子 $s_0=271828182$、常数 $M=\\frac{\\pi}{2}$，并产生 $N=1000$ 个接受的抽样。输出两个量，四舍五入到 6 位小数：首先是总接受率（接受的抽样数除以提议的总点数），其次是接受的抽样上 $x\\mapsto \\sin(x)$ 的样本均值。\n- 测试用例 3 (大规模样本，次优 $M$)：使用种子 $s_0=141421356$、常数 $M=\\frac{\\pi}{2}+\\frac{1}{2}$，并产生 $N=50000$ 个接受的抽样。输出两个量，四舍五入到 6 位小数：首先是总接受率，其次是一个接受的抽样位于区间 $[\\pi,2\\pi]$ 内的经验概率。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n[x_1,\\ \\text{acc\\_2},\\ \\overline{\\sin}_2,\\ \\text{acc\\_3},\\ p_{[\\pi,2\\pi],3}],\n$$\n其中 $x_1$ 来自测试用例 1，$\\text{acc\\_2}$ 和 $\\overline{\\sin}_2$ 来自测试用例 2，而 $\\text{acc\\_3}$ 和 $p_{[\\pi,2\\pi],3}$ 来自测试用例 3。每个数值项必须四舍五入到 6 位小数，且方括号内不允许有空格。", "solution": "问题陈述经过验证。\n\n**步骤 1：提取给定信息**\n- 目标概率密度函数 (PDF)：$f(x) = c \\cdot \\frac{1}{1+\\lvert \\sin(x)\\rvert}$ 对于 $x \\in [0,4\\pi]$，其他情况下 $f(x)=0$。常数 $c$ 由 $\\int_0^{4\\pi} f(x)\\,dx = 1$ 定义。\n- 建议概率密度函数：$g(x) = \\frac{1}{4\\pi}$ 对于 $x \\in [0,4\\pi]$，其他情况下 $g(x)=0$。\n- 拒绝抽样常数：$M$，一个正常数，使得对于所有 $x \\in [0,4\\pi]$ 都有 $f(x) \\le M\\,g(x)$。\n- 随机数源：一个线性同余生成器 (LCG)，定义为 $s_{n+1} = (a\\, s_n + c_0) \\bmod m$，参数为 $a=1664525$，$c_0=1013904223$，$m=2^{32}$。均匀分布随机偏差为 $u_n = s_n/m$。\n- 测试用例 1：$s_0=314159265$，$M=\\frac{\\pi}{2}$，$N=1$。输出是单个接受值 $x_1$。\n- 测试用例 2：$s_0=271828182$，$M=\\frac{\\pi}{2}$，$N=1000$。输出是接受率和 $\\sin(x)$ 的样本均值。\n- 测试用例 3：$s_0=141421356$，$M=\\frac{\\pi}{2}+\\frac{1}{2}$，$N=50000$。输出是接受率和接受的抽样在 $[\\pi,2\\pi]$ 内的经验概率。\n- 格式化：所有数值输出必须四舍五入到 6 位小数。\n\n**步骤 2：使用提取的给定信息进行验证**\n- **科学依据：** 该问题描述了拒绝抽样的应用，这是计算统计学中一个标准且基础的算法。目标函数 $x \\mapsto \\frac{1}{1+\\lvert \\sin(x)\\rvert}$ 在 $[0, 4\\pi]$ 上是非负且连续的。其在该定义域上的积分是有限的，这确保了可以构建一个有效的 PDF。归一化常数 $c$ 通过计算此积分来确定。函数 $|\\sin(x)|$ 的周期为 $\\pi$，因此积分为 $4 \\int_0^\\pi \\frac{dx}{1+\\sin(x)}$。使用 Weierstrass 换元法 $t = \\tan(x/2)$，此积分的计算结果为 $2$。因此，$\\int_0^{4\\pi} \\frac{dx}{1+|\\sin(x)|} = 4 \\times 2 = 8$。归一化常数为 $c=1/8$，目标 PDF 在定义域 $[0, 4\\pi]$ 上为 $f(x) = \\frac{1}{8(1+|\\sin x|)}$。该问题在科学上是合理的。\n\n- **适定性：** 拒绝抽样方法需要一个常数 $M$ 使得 $f(x) \\le M g(x)$。这个不等式是 $\\frac{1}{8(1+|\\sin x|)} \\le M \\frac{1}{4\\pi}$，可简化为 $M \\ge \\frac{\\pi}{2} \\frac{1}{1+|\\sin x|}$。当 $|\\sin x|$ 取最小值，即 $|\\sin x|=0$ 时，右侧的表达式达到最大值。因此，我们必须有 $M \\ge \\frac{\\pi}{2}$。问题中提供了 $M=\\frac{\\pi}{2}$ (最优值) 和 $M=\\frac{\\pi}{2}+\\frac{1}{2}$ (一个有效的次优值)，两者都满足条件。LCG 参数是标准的，并产生一个确定性的伪随机序列，使得结果可复现。每个测试用例所需的所有参数（$s_0$、$M$、$N$）都已明确提供。该问题是适定的且自洽的。\n\n- **客观性：** 问题使用精确的数学定义和客观的计算任务进行陈述。没有主观或含糊的元素。\n\n**步骤 3：结论与行动**\n问题有效。将提供一个合理的解决方案。\n\n**解题推导**\n此问题的核心是实现拒绝抽样算法。该方法通过使用一个具有密度 $g(x)$ 的更简单的建议分布，从具有密度 $f(x)$ 的目标分布中生成样本。该方法要求一个常数 $M$，使得缩放后的建议密度 $M g(x)$ 作为 $f(x)$ 的包络，即对于所有 $x$，都有 $f(x) \\le M g(x)$。\n\n生成一个样本的算法如下：\n1.  从建议分布 $g(x)$ 中抽取一个候选样本 $Y$。\n2.  从 $[0,1]$ 上的均匀分布中抽取一个随机数 $U$。\n3.  如果 $U \\le \\frac{f(Y)}{M g(Y)}$，则接受候选样本 $Y$ 作为来自 $f(x)$ 的一个样本。否则，拒绝 $Y$ 并返回步骤 1。\n\n对于这个具体问题：\n- 建议分布 $g(x)$ 在 $[0, 4\\pi]$ 上是均匀的。可以通过抽取一个均匀变量 $U_1 \\sim U(0,1)$ 并设置 $Y = 4\\pi \\cdot U_1$ 来生成候选样本 $Y$。\n- 目标密度是 $f(x) = \\frac{1}{8(1+|\\sin x|)}$。\n- 建议密度是 $g(x) = \\frac{1}{4\\pi}$。\n- 接受条件的检查涉及以下比率：\n$$\n\\frac{f(Y)}{M g(Y)} = \\frac{\\frac{1}{8(1+|\\sin Y|)}}{M \\frac{1}{4\\pi}} = \\frac{4\\pi}{8M} \\cdot \\frac{1}{1+|\\sin Y|} = \\frac{\\pi}{2M} \\cdot \\frac{1}{1+|\\sin Y|}\n$$\n生成候选样本和进行接受检查所需的均匀变量序列必须由指定的 LCG 生成：$s_{n+1} = (1664525 \\cdot s_n + 1013904223) \\pmod{2^{32}}$，其中 $u_n = s_n / 2^{32}$。\n\n对于每个测试用例，流程如下：\n1.  使用给定的种子 $s_0$ 初始化 LCG。\n2.  为接受的样本初始化一个空列表，并将提议计数器设置为 $0$。\n3.  循环直到收集到 $N$ 个样本：\n    a. 增加提议计数器。\n    b. 从 LCG 生成 $U_1$ 以创建一个候选样本 $Y = 4\\pi \\cdot U_1$。\n    c. 从 LCG 生成 $U_2$ 用于接受测试。\n    d. 计算阈值 $T = \\frac{\\pi}{2M(1+|\\sin Y|)}$。\n    e. 如果 $U_2 \\le T$，则将 $Y$ 添加到接受样本列表中。\n4.  收集到 $N$ 个样本后，计算所需的统计数据。\n\n每个用例的统计数据是：\n- 用例 1：单个样本的值 $x_1$。\n- 用例 2：接受率，定义为 $\\frac{N}{\\text{总提议数}}$，以及样本均值 $\\frac{1}{N} \\sum_{i=1}^{N} \\sin(x_i)$。\n- 用例 3：接受率和经验概率 $P(\\pi \\le X \\le 2\\pi)$，计算为 $\\frac{1}{N} \\times (\\text{满足 } \\pi \\le x_i \\le 2\\pi \\text{ 的样本 } x_i \\text{ 的数量})$。\n\n所有最终数值结果必须格式化为六位小数。实现将精确遵循此逻辑以产生所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing rejection sampling for the given\n    distribution and computing the required statistics for three test cases.\n    \"\"\"\n    \n    # LCG parameters are defined as specified in the problem.\n    A_LCG = 1664525\n    C0_LCG = 1013904223\n    M_LCG = 2**32\n\n    def lcg_generator(seed):\n        \"\"\"\n        Creates a generator that yields a sequence of U(0,1) random numbers\n        using the specified Linear Congruential Generator (LCG).\n        \"\"\"\n        state = seed\n        while True:\n            state = (A_LCG * state + C0_LCG) % M_LCG\n            yield state / M_LCG\n\n    def rejection_sampler(lcg, M, N):\n        \"\"\"\n        Generates N samples from the target distribution using rejection sampling.\n\n        Args:\n            lcg (generator): The random number generator.\n            M (float): The constant for the rejection sampling envelope.\n            N (int): The number of samples to generate.\n\n        Returns:\n            tuple: A tuple containing a list of accepted samples and the total\n                   number of proposals made.\n        \"\"\"\n        accepted_samples = []\n        total_proposals = 0\n        \n        # Pre-compute the constant factor for the acceptance threshold calculation\n        acceptance_factor = np.pi / (2.0 * M)\n\n        while len(accepted_samples) < N:\n            total_proposals += 1\n            \n            # Step 1: Generate candidate Y from proposal g(x) = U[0, 4*pi]\n            u1 = next(lcg)\n            y_candidate = u1 * 4.0 * np.pi\n            \n            # Step 2: Generate U for acceptance check from U[0, 1]\n            u2 = next(lcg)\n            \n            # Step 3: Calculate acceptance threshold and check condition\n            # T(y) = f(y) / (M*g(y)) = (pi/(2*M)) * 1/(1+|sin(y)|)\n            threshold = acceptance_factor / (1.0 + np.abs(np.sin(y_candidate)))\n            \n            if u2 <= threshold:\n                accepted_samples.append(y_candidate)\n                \n        return accepted_samples, total_proposals\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (seed, M, N)\n        (314159265, np.pi / 2.0, 1),\n        (271828182, np.pi / 2.0, 1000),\n        (141421356, np.pi / 2.0 + 0.5, 50000),\n    ]\n\n    all_results = []\n\n    # --- Test Case 1 ---\n    seed1, M1, N1 = test_cases[0]\n    lcg1 = lcg_generator(seed1)\n    samples1, _ = rejection_sampler(lcg1, M1, N1)\n    x1 = samples1[0]\n    all_results.append(x1)\n\n    # --- Test Case 2 ---\n    seed2, M2, N2 = test_cases[1]\n    lcg2 = lcg_generator(seed2)\n    samples2, total_proposals2 = rejection_sampler(lcg2, M2, N2)\n    \n    # Calculate acceptance rate\n    acc_2 = N2 / total_proposals2\n    all_results.append(acc_2)\n    \n    # Calculate sample mean of sin(x)\n    mean_sin_2 = np.mean([np.sin(x) for x in samples2])\n    all_results.append(mean_sin_2)\n\n    # --- Test Case 3 ---\n    seed3, M3, N3 = test_cases[2]\n    lcg3 = lcg_generator(seed3)\n    samples3, total_proposals3 = rejection_sampler(lcg3, M3, N3)\n    \n    # Calculate acceptance rate\n    acc_3 = N3 / total_proposals3\n    all_results.append(acc_3)\n    \n    # Calculate empirical probability of x in [pi, 2*pi]\n    count_in_interval = sum(1 for x in samples3 if np.pi <= x <= 2.0 * np.pi)\n    prob_3 = count_in_interval / N3\n    all_results.append(prob_3)\n    \n    # Format all results to 6 decimal places and join them into the final string\n    formatted_results = [f'{r:.6f}' for r in all_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "任何模拟方法的可靠性都取决于其基础——伪随机数生成器的质量。这个练习是一个思想实验，旨在探讨当我们的工具（在这里是随机数生成器）存在缺陷时会发生什么[@problem_id:2403661]。通过分析一个低精度随机数生成器对逆变换采样造成的影响，你将学会批判性地评估模拟结果，并理解离散化偏差如何系统地影响期望值和风险度量（如风险价值 VaR）的估计。", "id": "2403661", "problem": "一位计算风险管理领域的研究员希望使用逆变换法来模拟一个非负损失随机变量 $X$，其累积分布函数 $F(x)$ 是连续且严格递增的：抽取 $U \\sim \\text{Uniform}(0,1)$ 并令 $X = F^{-1}(U)$。然而，唯一可用的 $U$ 的伪随机数生成器返回的值恰好有 2 位小数，即 $U \\in \\{0.00, 0.01, \\dots, 0.99\\}$，且取每个值的概率相等，均为 $1/100$。该研究员计划使用这些模拟来估计期望损失 $\\mathbb{E}[X]$ 以及高分位数风险度量，如风险价值 (VaR)，其中 $\\alpha$-水平的风险价值定义为 $\\text{VaR}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R}: F(x) \\ge \\alpha\\}$。同时考虑一个特殊情况，其中 $X$ 服从参数为 $\\lambda > 0$ 的指数分布，因此对于 $x \\ge 0$，$F(x) = 1 - e^{-\\lambda x}$。\n\n选择所有正确的陈述。\n\nA. 在低精度生成器下，模拟的 $X$ 值被限制在网格 $x_k = F^{-1}(k/100)$上，其中 $k \\in \\{0,1,\\dots,99\\}$。因此，任何基于这些模拟的 $\\text{VaR}_{0.995}(X)$ 估计量，随着模拟次数的增加，都会收敛到 $x_{99} = F^{-1}(0.99)$，从而在 $F^{-1}$ 是严格递增的情况下，低估了真实的 $\\text{VaR}_{0.995}(X)$。\n\nB. 即使使用低精度生成器，当模拟次数 $n \\to \\infty$ 时，逆变换模拟的样本均值也是 $\\mathbb{E}[X]$ 的一个一致估计量。\n\nC. 在参数为 $\\lambda$ 的指数分布情况下，从低精度逆变换模拟器计算出的期望值等于 $(1/100)\\sum_{k=0}^{99} F^{-1}(k/100)$ 并且严格小于 $1/\\lambda$。\n\nD. 在提议密度有界的情况下，从逆变换采样切换到接受-拒绝（拒绝采样）方法，可以解决由两位小数的均匀分布生成器引起的离散化偏差，而无需任何其他更改。\n\nE. 通过组合多次独立抽取，可以从两位小数的生成器中恢复任意精细的分辨率：如果 $U_j \\in \\{0.00,0.01,\\dots,0.99\\}$ 是独立的，且 $D_j = 100\\,U_j \\in \\{0,1,\\dots,99\\}$，那么对于任何正整数 $m$，变量 $V_m = \\sum_{j=1}^{m} D_j\\,100^{-j}$ 在网格 $\\{0, 1/100^{m}, 2/100^{m}, \\dots, (100^{m}-1)/100^{m}\\}$ 上是均匀分布的，从而随着 $m$ 的增加，能够以 $10^{-2m}$ 的分辨率进行逆变换采样。\n\n选择所有适用的选项。", "solution": "对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- 一个非负损失随机变量 $X$。\n- X 的累积分布函数 (CDF) 是 $F(x)$，它是连续且严格递增的。\n- 模拟方法：逆变换法， $X = F^{-1}(U)$，其中 $U \\sim \\text{Uniform}(0,1)$。\n- 可用的 $U$ 的伪随机数生成器是离散的，从集合 $\\{0.00, 0.01, \\dots, 0.99\\}$ 中生成数值，且取每个值的概率均为 $1/100$。我们将这个离散随机变量表示为 $U_d$。因此，对于 $k \\in \\{0, 1, \\dots, 99\\}$，$P(U_d = k/100) = 1/100$。\n- 目标是估计期望损失 $\\mathbb{E}[X]$ 和风险价值 (VaR)。\n- $\\alpha$-水平的风险价值定义为 $\\text{VaR}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R}: F(x) \\ge \\alpha\\}$。\n- 考虑一个特殊情况：$X$ 服从参数为 $\\lambda > 0$ 的指数分布，其中对于 $x \\ge 0$，$F(x) = 1 - e^{-\\lambda x}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据指定标准对问题进行评估。\n- **科学性**：该问题根植于计算统计学和量化金融的原理。逆变换采样、伪随机数生成器的性质、期望值和风险价值都是标准概念。有限精度生成器的情景是对现实世界计算约束的一种实用且具有教育意义的简化。\n- **适定性**：问题表述清晰。它描述了一个特定的模拟设置，并要求评估关于此设置的性质和后果的五个不同陈述。每个陈述都是一个可检验的数学命题。\n- **客观性**：语言精确、技术性强，没有任何主观性或模糊性。\n问题陈述没有违反任何无效标准。它是一个自洽、一致且科学上合理的问题。\n\n### 第 3 步：结论与行动\n问题陈述是**有效的**。将推导解答。\n\n研究员使用一个离散均匀随机变量 $U_d$，其中对于 $k \\in \\{0, 1, \\dots, 99\\}$，$P(U_d = k/100) = 1/100$。模拟的损失变量是 $X_d = F^{-1}(U_d)$。$X_d$ 的可能取值为 $x_k = F^{-1}(k/100)$，其中 $k \\in \\{0, 1, \\dots, 99\\}$。\n\n### 选项 A 的分析\n该陈述声称，基于这些模拟的 $\\text{VaR}_{0.995}(X)$ 估计量将收敛于 $x_{99} = F^{-1}(0.99)$，从而低估了真实的 $\\text{VaR}_{0.995}(X)$。\n\n在水平 $\\alpha=0.995$ 处的真实风险价值是 $\\text{VaR}_{0.995}(X) = F^{-1}(0.995)$。这是因为 $F$ 是连续且严格递增的，所以 $\\inf\\{x: F(x) \\ge \\alpha\\} = F^{-1}(\\alpha)$。\n\n正在模拟的随机变量是 $X_d = F^{-1}(U_d)$。$U_d$ 能取到的最大可能值是 $0.99$。由于 $F^{-1}$ 是严格递增的（因为 $F$ 是），所以损失的模拟值的最大可能值为 $X_{\\text{max}} = F^{-1}(0.99) = x_{99}$。\n\n任何基于 $X_d$ 分布样本的分位数统计估计量，其产生的值都不可能大于该分布支撑集中的最大可能值。随着模拟次数的增加，任何一致的经验分位数估计量都将收敛到变量 $X_d$ 的理论分位数。\n\n模拟变量 $X_d$ 的 $\\text{VaR}_{0.995}$ 是 $\\inf\\{x : P(X_d \\le x) \\ge 0.995\\}$。\n$P(X_d \\le x) = P(F^{-1}(U_d) \\le x) = P(U_d \\le F(x))$。我们需要找到满足 $P(U_d \\le F(x)) \\ge 0.995$ 的最小 $x$。\n$U_d$ 的累积分布函数是一个阶梯函数。对于 $y \\ge 0.99$，$P(U_d \\le y) = 1$。为了使 $P(U_d \\le F(x)) \\ge 0.995$，我们必须有 $P(U_d \\le F(x))=1$。这要求 $F(x) \\ge 0.99$。\n由于 $F$ 是严格递增的，满足 $F(x) \\ge 0.99$ 的最小 $x$ 是 $x = F^{-1}(0.99)$。\n因此，基于 $X_d$ 模拟的 $0.995$-分位数估计量将收敛到 $F^{-1}(0.99)$。\n\n真实值为 $\\text{VaR}_{0.995}(X) = F^{-1}(0.995)$。\n由于 $F^{-1}$ 是严格递增的，所以 $F^{-1}(0.99) < F^{-1}(0.995)$。\n基于模拟的估计收敛于 $F^{-1}(0.99)$，这是对真实值 $F^{-1}(0.995)$ 的严格低估。这是风险管理中的一个严重失误，因为尾部风险被低估了。\n\n该陈述是**正确的**。\n\n### 选项 B 的分析\n该陈述声称模拟的样本均值是 $\\mathbb{E}[X]$ 的一个一致估计量。\n样本均值为 $\\bar{X}_{d,n} = \\frac{1}{n} \\sum_{i=1}^n X_{d,i}$，其中 $X_{d,i}$ 是 $X_d = F^{-1}(U_d)$ 的独立抽取。根据大数定律，当模拟次数 $n \\to \\infty$ 时，样本均值收敛于模拟变量的期望值：$\\bar{X}_{d,n} \\to \\mathbb{E}[X_d]$。\n如果一个估计量依概率收敛于某个参数（这里是 $\\mathbb{E}[X]$），那么它就是该参数的一致估计量。因此，我们必须检查是否 $\\mathbb{E}[X_d] = \\mathbb{E}[X]$。\n\n模拟变量的期望值为：\n$$ \\mathbb{E}[X_d] = \\mathbb{E}[F^{-1}(U_d)] = \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) P\\left(U_d = \\frac{k}{100}\\right) = \\frac{1}{100} \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) $$\n真实的期望值为：\n$$ \\mathbb{E}[X] = \\mathbb{E}[F^{-1}(U)] = \\int_0^1 F^{-1}(u) \\,du $$\n$\\mathbb{E}[X_d]$ 的求和是 $\\mathbb{E}[X]$ 积分的一个左黎曼和近似，划分宽度为 $\\Delta u = 1/100$。对于一个一般的严格递增函数 $F^{-1}$，这个和不等于该积分。例如，如果 $F^{-1}(u)$ 是严格凸的，左黎曼和将严格小于该积分。如果它是严格凹的，它将严格大于该积分。一般来说，$\\mathbb{E}[X_d] \\neq \\mathbb{E}[X]$。\n由于样本均值收敛于 $\\mathbb{E}[X_d]$，而 $\\mathbb{E}[X_d]$ 不等于 $\\mathbb{E}[X]$，所以该估计量存在系统性偏差，不是 $\\mathbb{E}[X]$ 的一致估计量。\n\n该陈述是**不正确的**。\n\n### 选项 C 的分析\n该陈述专门针对指数分布情况, $F(x) = 1 - e^{-\\lambda x}$。\n其逆累积分布函数可以通过令 $u = F(x) = 1 - e^{-\\lambda x}$ 求得，即 $x = F^{-1}(u) = -\\frac{1}{\\lambda} \\ln(1-u)$。\n真实期望值是 $\\mathbb{E}[X] = 1/\\lambda$。\n\n陈述的第一部分说，从模拟器得到的期望值是 $(1/100)\\sum_{k=0}^{99} F^{-1}(k/100)$。正如在选项 B 的分析中所确立的，这是 $\\mathbb{E}[X_d]$ 的正确表达式。\n$$ \\mathbb{E}[X_d] = \\frac{1}{100} \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) = \\frac{1}{100} \\sum_{k=0}^{99} \\left(-\\frac{1}{\\lambda} \\ln\\left(1-\\frac{k}{100}\\right)\\right) $$\n第二部分声称这个值严格小于 $1/\\lambda$。这意味着我们必须证明 $\\mathbb{E}[X_d] < \\mathbb{E}[X]$。\n如前所述，$\\mathbb{E}[X_d]$ 是积分 $\\mathbb{E}[X] = \\int_0^1 F^{-1}(u) \\,du$ 的一个左黎曼和。我们来分析 $g(u) = F^{-1}(u) = -\\frac{1}{\\lambda} \\ln(1-u)$ 的凸性。\n其一阶导数是 $g'(u) = -\\frac{1}{\\lambda} \\frac{-1}{1-u} = \\frac{1}{\\lambda(1-u)}$。\n其二阶导数是 $g''(u) = \\frac{1}{\\lambda} (-1)(1-u)^{-2}(-1) = \\frac{1}{\\lambda(1-u)^2}$。\n由于 $\\lambda > 0$，我们有 $g''(u) > 0$ 对于所有 $u \\in [0,1)$。这意味着 $F^{-1}(u)$ 在其定义域上是一个严格凸函数。\n对于一个严格凸函数，任何左黎曼和都严格小于同一区间上的定积分值。\n因此，\n$$ \\mathbb{E}[X_d] = \\frac{1}{100} \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) < \\int_0^1 F^{-1}(u) \\,du = \\mathbb{E}[X] = \\frac{1}{\\lambda} $$\n陈述的两个部分都为真。\n\n该陈述是**正确的**。\n\n### 选项 D 的分析\n该陈述建议切换到接受-拒绝 (A-R) 采样将解决离散化偏差。\n标准的 A-R 算法需要从一个提议分布 $g$ 中抽取一个候选样本 $Y$，并抽取一个均匀随机数 $W \\sim \\text{Uniform}(0,1)$，如果 $W \\le \\frac{f(Y)}{Mg(Y)}$ 则接受 $Y$，其中 $f$ 是目标密度， $M$ 是一个常数使得 $f(x) \\le Mg(x)$。\n问题陈述指出，*唯一*可用的生成器是离散的 $U_d$。如果我们在接受检查中被迫使用 $U_d$ 来代替 $W$，那么条件就变成 $U_d \\le \\frac{f(Y)}{Mg(Y)}$。\n对于连续均匀分布的 $W$，给定 $Y$ 的接受概率是 $P(W \\le c) = c$，其中 $c = \\frac{f(Y)}{Mg(Y)}$。这个性质对于确保接受的样本遵循密度 $f$ 至关重要。\n对于离散生成器 $U_d$，接受概率是 $P(U_d \\le c) = (\\lfloor 100c \\rfloor + 1)/100$ (对于 $c < 1$）。这是一个阶梯函数，不等于 $c$。均匀变量的离散化破坏了接受概率。因此，被接受样本的分布将不是目标分布 $f(x)$。离散化偏差没有被解决；它只是被转移到了模拟算法的另一个部分。\n“无需任何其他更改”就能解决偏差的说法是错误的。\n\n该陈述是**不正确的**。\n\n### 选项 E 的分析\n该陈述提出了一种从低精度均匀随机变量构造更高分辨率均匀随机变量的方法。\n令 $D_j = 100 U_j$，其中 $U_j$ 是从离散生成器中独立抽取的。每个 $D_j$ 是一个在整数集合 $\\{0, 1, \\dots, 99\\}$ 上均匀分布的独立随机变量。\n提议的变量是 $V_m = \\sum_{j=1}^{m} D_j 100^{-j}$。\n我们来分析 $V_m$:\n$$ V_m = \\frac{D_1}{100} + \\frac{D_2}{100^2} + \\dots + \\frac{D_m}{100^m} = \\frac{D_1 100^{m-1} + D_2 100^{m-2} + \\dots + D_m}{100^m} $$\n分子是一个随机整数，由 $m$ 个独立的 100 进制“数字” $D_j$ 构成。每个数字序列 $(D_1, \\dots, D_m)$ 对应一个唯一的整数值，范围从 $0$ (所有 $D_j=0$) 到 $99 \\cdot 100^{m-1} + \\dots + 99 = 100^m - 1$。\n由于每个 $D_j$ 在 $\\{0, \\dots, 99\\}$ 上是均匀的且相互独立，因此每个可能的序列 $(D_1, \\dots, D_m)$ 都是等可能的，其概率为 $(1/100)^m = 1/100^m$。\n这意味着从 $0$ 到 $100^m-1$ 的每个整数都是分子可能的结果，每个结果的概率都是 $1/100^m$。\n因此，$V_m$ 是在网格 $\\{0/100^m, 1/100^m, \\dots, (100^m-1)/100^m\\}$ 上均匀分布的随机变量。\n$V_m$ 的可能值网格有 $100^m$ 个点，分辨率为 $100^{-m} = 10^{-2m}$。随着 $m$ 的增加，这个离散均匀分布为连续的 $\\text{Uniform}(0,1)$ 分布提供了一个越来越精细的近似。在逆变换法中使用 $V_m$，即 $X=F^{-1}(V_m)$，允许通过选择足够大的 $m$ 来进行模拟，使得离散化误差可以任意小。\n这个技术是有效的并且描述正确。\n\n该陈述是**正确的**。", "answer": "$$\\boxed{ACE}$$"}]}