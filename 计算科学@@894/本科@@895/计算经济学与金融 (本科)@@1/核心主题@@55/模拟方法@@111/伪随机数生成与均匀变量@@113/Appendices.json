{"hands_on_practices": [{"introduction": "伪随机数生成器（PRNGs），如线性同余生成器（LCG），是计算模拟中的主力工具，但它们的输出是否完美无瑕？本练习将带你深入LCG的内部机制，揭示其低位比特（least significant bits）可能存在的严重非随机性，特别是当模数 $m$ 是 $2$ 的幂时。通过这个实践，你将学会批判性地审视你所使用的工具，理解为什么某些生成器的质量高于其他生成器，这是迈向评估PRNG质量至关重要的一步。[@problem_id:2423215]", "id": "2423215", "problem": "考虑一个由整数 $m \\gt 0$、$a$、$c$ 和一个初始种子 $x_0$ 定义的线性同余生成器 (LCG)，其通过以下递归关系演化\n$$\nx_{n+1} \\equiv a\\,x_n + c \\pmod{m}, \\quad n \\ge 0.\n$$\n在计算经济学和金融学中，此类序列常用于生成伪随机数，旨在近似来自均匀分布的独立样本。在本问题中，您将研究当不使用完整的 $x_n$，而仅使用每个 $x_n$ 的 $k=3$ 个最低有效位时，序列的统计特性会发生什么变化。定义3位输出为\n$$\ny_n \\equiv x_n \\bmod 2^3 \\in \\{0,1,2,3,4,5,6,7\\},\n$$\n以及最低有效位为\n$$\nb_n \\equiv x_n \\bmod 2 \\in \\{0,1\\}.\n$$\n仅从模运算和LCG递归的核心定义出发，推断这些低阶位的行为，然后实现一个程序，以量化用作测试用例的各种LCG参数化下的以下经验性质。\n\n为每个测试用例需要实现的任务：\n- 从给定的LCG和指定的种子 $x_0$ 开始，生成 $N$ 个连续状态 $x_1, x_2, \\dots, x_N$。\n- 从生成的序列中，计算 $y_n = x_n \\bmod 8$ 和 $b_n = x_n \\bmod 2$，其中 $n = 1,2,\\dots,N$。\n- 计算以下诊断指标：\n  1. $y_n$ 的3位直方图相对于 $\\{0,1,\\dots,7\\}$ 上离散均匀分布的卡方统计量：\n     $$\n     \\chi^2 \\;=\\; \\sum_{j=0}^{7} \\frac{\\left(O_j - \\frac{N}{8}\\right)^2}{\\frac{N}{8}},\n     $$\n     其中 $O_j$ 是 $N$ 个样本中 $y_n = j$ 的观测计数。\n  2. 最低有效位序列 $b_n$ 的经验性一阶自相关：\n     $$\n     \\hat{\\rho}_1 \\;=\\; \\frac{\\sum_{n=1}^{N-1} \\left(b_n - \\bar{b}\\right)\\left(b_{n+1} - \\bar{b}\\right)}{\\sqrt{\\sum_{n=1}^{N-1} \\left(b_n - \\bar{b}\\right)^2} \\, \\sqrt{\\sum_{n=1}^{N-1} \\left(b_{n+1} - \\bar{b}\\right)^2}},\n     \\quad \\bar{b} \\;=\\; \\frac{1}{N}\\sum_{n=1}^{N} b_n.\n     $$\n  3. 布尔指标 $\\mathrm{isDet3}$，其当且仅当 $y_{n+1}$ 只依赖于 $y_n$ 时为真（即，3个最低有效位上的映射是自治的，可以写成 $\\mathbb{Z}/2^3\\mathbb{Z}$ 上的递归）。这种情况精确地发生在LCG模 $2^3$ 的约化与原始递归在环同态意义下可交换时。\n  4. 如果 $\\mathrm{isDet3}$ 为真，通过从 $y_0 = x_0 \\bmod 8$ 开始，在 $\\{0,1,\\dots,7\\}$ 上迭代导出的映射，直到首次返回 $y_0$，从而计算3位子序列的周期 $P_3$。如果 $\\mathrm{isDet3}$ 为假，则设 $P_3 = 0$。\n\n运行的测试套件：\n- 案例1（模为2的幂的混合LCG）：$m = 2^{31}$，$a = 1103515245$，$c = 12345$，$x_0 = 1$，$N = 100000$。\n- 案例2（模为素数的乘法LCG）：$m = 2^{31} - 1$，$a = 16807$，$c = 0$，$x_0 = 1$，$N = 100000$。\n- 案例3（模为大的2的幂的混合LCG）：$m = 2^{48}$，$a = 25214903917$，$c = 11$，$x_0 = 1$，$N = 100000$。\n\n最终输出格式：\n- 你的程序应该生成单行输出，包含一个结果列表，每个测试用例一个结果，其中每个测试用例的结果为列表\n$$\n\\left[\\chi^2,\\; \\hat{\\rho}_1,\\; \\mathrm{isDet3},\\; P_3\\right],\n$$\n其中两个数值项为实数，$P_3$ 为整数，$\\mathrm{isDet3}$ 为布尔值。将三个测试用例的结果列表聚合成一个顶层列表，并将其作为单行打印，各项用逗号分隔，并用方括号括起来，例如：\n$$\n\\big[\\,[\\chi^2_1,\\hat{\\rho}_{1,1},\\mathrm{isDet3}_1,P_{3,1}],\\;[\\chi^2_2,\\hat{\\rho}_{1,2},\\mathrm{isDet3}_2,P_{3,2}],\\;[\\chi^2_3,\\hat{\\rho}_{1,3},\\mathrm{isDet3}_3,P_{3,3}]\\,\\big].\n$$\n无需外部输入，不涉及物理单位。未使用角度。所有答案均为指定的原始数字或布尔值。", "solution": "该问题要求分析线性同余生成器 (LCG) 产生的最低有效位的统计特性。我们必须首先验证问题的陈述，然后基于数论和统计学的基本原理提供一个详尽的解决方案。\n\n该问题在科学上和数学上是良构的（定义明确的）。它涉及标准的LCG递归 $x_{n+1} \\equiv a\\,x_n + c \\pmod{m}$，并研究派生序列 $y_n \\equiv x_n \\pmod{8}$ 和 $b_n \\equiv x_n \\pmod{2}$ 的性质。所要求的诊断指标——卡方统计量、一阶自相关和低位子序列的周期——是评估伪随机数生成器质量的标准工具。测试用例的参数取自历史上具有重要意义的LCG，且问题是完全指定的，不含任何歧义或矛盾。因此，该问题被认为是**有效的**，我们可以着手解决。\n\n分析的核心在于LCG递归在模 $2^3 = 8$ 运算下的行为。\n\n**1. 3位子序列的确定性分析 ($\\mathrm{isDet3}$)**\n\n当3位值序列 $y_n = x_n \\pmod{8}$ 是自治的，即 $y_{n+1}$ 仅仅是 $y_n$ 的函数时，指标 $\\mathrm{isDet3}$ 为真。\nLCG递归为 $x_{n+1} = (a\\,x_n + c) - q_n m$，其中 $q_n = \\lfloor (a\\,x_n + c)/m \\rfloor$ 是某个整数。\n将此方程模8，我们得到：\n$$\ny_{n+1} \\equiv x_{n+1} \\pmod{8} \\equiv (a\\,x_n + c - q_n m) \\pmod{8}\n$$\n让我们用 $y_n$ 表示 $x_n$：$x_n = 8k + y_n$，其中 $k$ 为某个整数。$k$ 的值取决于 $x_n$ 的高阶位。\n将此代入同余式，得到：\n$$\ny_{n+1} \\equiv (a\\,(8k + y_n) + c - q_n m) \\pmod{8}\n$$\n$$\ny_{n+1} \\equiv (8ak + a y_n + c - q_n m) \\pmod{8}\n$$\n$$\ny_{n+1} \\equiv (a y_n + c - q_n m) \\pmod{8}\n$$\n为了让 $y_{n+1}$ 仅是 $y_n$ 的函数，该表达式必须独立于 $k$ 和 $q_n$，而这两者都依赖于 $x_n$ 的完整值。项 $a y_n + c$ 仅依赖于 $y_n$。项 $q_n m$ 引入了对 $x_n$ 高阶位的依赖，因为 $q_n$ 是 $x_n$ 的函数。\n这种依赖关系被移除当且仅当 $q_n m \\pmod{8}$ 对所有 $n$ 都是常数。对于任何序列 $x_n$（以及因此任何序列 $q_n$）要使此条件成立，最简单的方法是 $m \\equiv 0 \\pmod{8}$。如果 $m$ 是8的倍数，则 $q_n m \\equiv q_n \\cdot 0 \\equiv 0 \\pmod{8}$，无论 $q_n$ 的值如何。\n在这种情况下，$y_n$ 的递归简化为：\n$$\ny_{n+1} \\equiv a y_n + c \\pmod{8}\n$$\n这是一个在模8整数环 $\\mathbb{Z}/8\\mathbb{Z}$ 上的自洽LCG。\n\n如果 $m$ 不是8的倍数，那么 $m \\pmod{8}$ 非零。$q_n$ 的值会根据 $x_n$ 的高位而改变，这意味着 $q_n m \\pmod{8}$ 不是常数。因此，$y_{n+1}$ 将不仅仅依赖于 $y_n$。\n\n因此，$\\mathrm{isDet3}$ 为真的条件恰好是 $m \\equiv 0 \\pmod{8}$。\n\n**2. 3位子序列的周期 ($P_3$)**\n\n如果 $\\mathrm{isDet3}$ 为假 ($m \\not\\equiv 0 \\pmod{8}$)，$P_3$ 定义为 $0$。\n如果 $\\mathrm{isDet3}$ 为真，我们必须找到序列 $y_{n+1} \\equiv a y_n + c \\pmod{8}$ 的周期，从 $y_0 = x_0 \\pmod{8}$ 开始。由于状态空间 $\\{0, 1, \\dots, 7\\}$ 是有限的，这个序列保证是周期的。周期可以通过模拟序列 $y_0, y_1, y_2, \\dots$ 并记录直到首次重新访问 $y_0$ 所需的步数来找到。循环的长度就是周期 $P_3$。\n对于 $\\mathbb{Z}_{2^k}$ 上的LCG，当且仅当 $c$ 是奇数且 $a \\equiv 1 \\pmod{4}$ 时，达到 $2^k$ 的最大周期。在我们的情况中，$k=3$，这转化为 $c$ 为奇数且 $a \\equiv 1 \\pmod{4}$，周期为8。\n\n**3. 卡方统计量 ($\\chi^2$)**\n\n此统计量衡量了 $y_n$ 的观测频率与离散均匀分布的拟合优度。对于 $N$ 个样本和8个可能结果 $\\{0, 1, ..., 7\\}$，每个结果 $j$ 的期望频率是 $E_j = N/8$。如果 $O_j$ 是序列 $y_1, \\dots, y_N$ 中结果 $j$ 的观测频率，则统计量计算为：\n$$\n\\chi^2 = \\sum_{j=0}^{7} \\frac{\\left(O_j - E_j\\right)^2}{E_j} = \\sum_{j=0}^{7} \\frac{\\left(O_j - N/8\\right)^2}{N/8}\n$$\n小的 $\\chi^2$ 值（接近0）表明数据与均匀分布一致，而大的值则表明不一致。\n\n**4. 最低有效位的一阶自相关 ($\\hat{\\rho}_1$)**\n\n此统计量衡量了最低有效位序列 $b_n = x_n \\pmod{2}$ 中连续元素之间的线性相关性。所提供的公式是皮尔逊相关系数的一个变体：\n$$\n\\hat{\\rho}_1 = \\frac{\\sum_{n=1}^{N-1} (b_n - \\bar{b})(b_{n+1} - \\bar{b})}{\\sqrt{\\sum_{n=1}^{N-1} (b_n - \\bar{b})^2} \\cdot \\sqrt{\\sum_{n=1}^{N-1} (b_{n+1} - \\bar{b})^2}}\n$$\n其中 $\\bar{b} = \\frac{1}{N}\\sum_{n=1}^{N} b_n$ 是整个序列 $b_1, \\dots, b_N$ 的均值。$\\hat{\\rho}_1$ 的值接近0表示低线性相关性，而接近+1或-1的值分别表示强正相关或负相关。\n\n**测试用例分析：**\n\n- **案例 1:** $m = 2^{31}, a = 1103515245, c = 12345$。\n  - 由于 $m = 2^{31}$ 是8的倍数，$\\mathrm{isDet3}$ 为真。\n  - 导出的LCG为 $y_{n+1} \\equiv a y_n + c \\pmod{8}$。我们有 $a \\equiv 5 \\pmod{8}$ 和 $c \\equiv 1 \\pmod{8}$。由于 $a \\equiv 1 \\pmod{4}$ 且 $c$ 为奇数，周期 $P_3$ 将是最大的，即8。\n  - 序列 $y_n$ 将由 $N/P_3 = 100000/8 = 12500$ 次 $\\{0, \\dots, 7\\}$ 的一个排列的重复组成。因此，每个值恰好出现 $12500$ 次。$O_j = E_j = 12500$，导致 $\\chi^2 = 0$。\n  - LSB序列 $b_n = y_n \\pmod{2}$ 也将是周期的。从 $y_0 = 1$ 开始的 $y_n$ 序列为 $1, 6, 7, 4, 5, 2, 3, 0, \\dots$。LSB序列 $b_n$ 为 $1, 0, 1, 0, 1, 0, 1, 0, \\dots$。这是一个完美的交替序列，这意味着强烈的负一阶自相关，$\\hat{\\rho}_1 \\approx -1$。\n\n- **案例 2:** $m = 2^{31} - 1, a = 16807, c = 0$。\n  - 模 $m$ 是一个素数且不是8的倍数。因此，$\\mathrm{isDet3}$ 为假，且 $P_3 = 0$。\n  - 低阶位 $y_n$ 不是由一个简单的局部递归决定的，而是通过模一个大素数的全局运算混合的。我们期望这些位表现出伪随机性。\n  - $\\chi^2$ 应该是一个小的正值，这是随机抽样波动的特征。\n  - $\\hat{\\rho}_1$ 应该接近0，表明连续位之间相关性低。\n\n- **案例 3:** $m = 2^{48}, a = 25214903917, c = 11$。\n  - 与案例1类似，$m = 2^{48}$ 是8的倍数，所以 $\\mathrm{isDet3}$ 为真。\n  - 导出的LCG为 $y_{n+1} \\equiv a y_n + c \\pmod{8}$。我们发现 $a \\equiv 5 \\pmod{8}$ 和 $c \\equiv 3 \\pmod{8}$。同样，$a \\equiv 1 \\pmod{4}$ 且 $c$ 为奇数，所以周期 $P_3$ 是8。\n  - 如同案例1，完美的周期性意味着 $O_j = N/8$，所以 $\\chi^2 = 0$。\n  - LSB序列 $b_n = y_n \\pmod{2}$ 也将是周期的。对于 $y_0=1$，序列是 $1, 0, 3, 2, 5, 4, 7, 6, \\dots$。LSB序列再次是 $1, 0, 1, 0, 1, 0, 1, 0, \\dots$。因此，我们期望 $\\hat{\\rho}_1 \\approx -1$。\n\n这个分析揭示了模为2的幂的LCG的一个根本性弱点：它们的低阶位是高度非随机的，周期非常短。这就是为什么必须谨慎使用这类生成器，并且通常会截断其输出，只使用高阶位。\n\n**实现计划：**\n\n实现将遵循上述逻辑。一个循环将遍历所有测试用例。对每个用例，我们将：\n1.  使用LCG递归生成 $N$ 个 $x_n$ 值。Python的任意精度整数将处理大的中间乘积。\n2.  计算 $y_n$ 和 $b_n$ 序列。\n3.  通过计算 $y_n$ 中每个值的出现次数并应用公式来计算 $\\chi^2$。\n4.  使用 $b_n$ 序列直接根据提供的公式计算 $\\hat{\\rho}_1$。\n5.  通过检查 $m \\pmod{8} == 0$ 来确定 $\\mathrm{isDet3}$。\n6.  如果 $\\mathrm{isDet3}$ 为真，通过在 $\\mathbb{Z}_8$ 上迭代映射直到初始状态被重新访问来计算 $P_3$。否则，将 $P_3$ 设为0。\n结果将被收集并以指定格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_diagnostics(m, a, c, x0, N):\n    \"\"\"\n    Generates LCG sequences and computes statistical diagnostics.\n    \"\"\"\n    # Use standard Python integers which support arbitrary size.\n    # This is crucial for Case 3 where intermediate products exceed 64 bits.\n    x = np.zeros(N + 1, dtype=object)\n    x[0] = x0\n\n    # Generate N consecutive states x_1, ..., x_N\n    for n in range(N):\n        x[n+1] = (a * x[n] + c) % m\n\n    # The problem asks for analysis on x_1, ..., x_N\n    x_sequence = x[1:].astype(np.int64)\n\n    # Compute y_n and b_n sequences\n    y_n = x_sequence % 8\n    b_n = x_sequence % 2\n\n    # 1. Chi-square statistic for y_n\n    # O_j are the observed counts for j=0..7\n    # N is the number of samples, so N/8 is the expected count for each bin.\n    observed_counts, _ = np.histogram(y_n, bins=np.arange(9)) # bins are [0,1,..,8]\n    expected_count = N / 8.0\n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n\n    # 2. Lag-1 autocorrelation of b_n\n    b_mean = np.mean(b_n)\n    \n    # Slices for b_n and b_{n+1}\n    # b_current corresponds to b_1, ..., b_{N-1}\n    # b_next corresponds to b_2, ..., b_N\n    b_current = b_n[:-1]\n    b_next = b_n[1:]\n    \n    dev_current = b_current - b_mean\n    dev_next = b_next - b_mean\n    \n    numerator = np.sum(dev_current * dev_next)\n    \n    sum_sq_dev_current = np.sum(dev_current**2)\n    sum_sq_dev_next = np.sum(dev_next**2) # This is sum_{n=1}^{N-1} (b_{n+1} - b_bar)^2\n    \n    denominator = np.sqrt(sum_sq_dev_current * sum_sq_dev_next)\n    \n    # Handle case where denominator is zero (sequence is constant)\n    if denominator == 0:\n        rho1 = 0.0\n    else:\n        rho1 = numerator / denominator\n\n    # 3. Determinism indicator for y_n\n    isDet3 = (m % 8 == 0)\n\n    # 4. Period P3 of the 3-bit subsequence\n    P3 = 0\n    if isDet3:\n        y_current = x0 % 8\n        y_start = y_current\n        count = 0\n        while True:\n            count += 1\n            y_current = (a * y_current + c) % 8\n            if y_current == y_start:\n                P3 = count\n                break\n            # Safety break for unexpected behavior, though not anticipated here\n            if count > 8:\n                P3 = -1 # Should not happen based on theory\n                break\n\n    return [chi2_stat, rho1, isDet3, P3]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mixed LCG with modulus a power of two)\n        (2**31, 1103515245, 12345, 1, 100000),\n        # Case 2 (multiplicative LCG with prime modulus)\n        (2**31 - 1, 16807, 0, 1, 100000),\n        # Case 3 (mixed LCG with large power-of-two modulus)\n        (2**48, 25214903917, 11, 1, 100000),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, x0, N = case\n        result = compute_diagnostics(m, a, c, x0, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str() on a list gives a string like '[...]', so a simple join creates the required nested list string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "在金融建模中，我们常常需要生成特定范围内的随机整数，而不仅仅是区间 $[0,1)$ 上的均匀分布随机数。即使拥有一个完美的均匀随机源，不恰当的转换方法（如简单的取模运算）也会引入细微但显著的统计偏差，破坏了均匀性假设。本练习通过对比有偏的“取模法”和无偏的“拒绝采样法”，让你定量分析并纠正这一常见错误，从而掌握在蒙特卡洛模拟中正确实现采样方法的关键技能。[@problem_id:2423278]", "id": "2423278", "problem": "您可以使用一个基础的伪随机数生成器 (PRNG)，它在整数集 $\\{0,1,\\dots,m-1\\}$（其中 $m = 2^{32}$）上生成均匀分布的独立样本。您的任务是分析如何使用此源在目标范围 $[a,b]$ 内生成一个随机整数，并量化一个朴素实现所引入的偏差。这个问题的动机源于计算经济学和金融学中广泛使用的蒙特卡洛算法，在这些算法中，有偏的离散均匀采样会扭曲估计值（例如，状态转移、序贯蒙特卡洛中的重采样步骤，或离散选择模拟）。您必须从第一性原理出发，推导出相关表达式，并实现一个程序，无需通过模拟即可计算精确的偏差度量和资源使用情况。\n\n基本定义和假设：\n- 基础 PRNG 的输出 $X$ 在 $\\{0,1,\\dots,m-1\\}$ 上是严格均匀分布的，其中 $m=2^{32}$。\n- 令 $n = b-a+1$ 为目标整数范围 $[a,b]$ 的大小。\n- 朴素的“取模”映射产生 $Y_{\\mathrm{mod}} = a + (X \\bmod n)$。\n- 拒绝采样映射定义 $q = \\lfloor m/n \\rfloor$，如果 $X < qn$ 则接受一次抽取，并在接受时返回 $Y_{\\mathrm{rej}} = a + (X \\bmod n)$；否则，从基础 PRNG 重新抽取，直到接受为止。\n\n您的任务：\n1) 从第一性原理推导 $Y_{\\mathrm{mod}}$ 的精确概率质量函数（用 $m$、$n$、$q = \\lfloor m/n \\rfloor$ 和 $r = m - qn$ 表示），然后推导出 $Y_{\\mathrm{mod}}$ 的分布与 $[a,b]$ 上的理想离散均匀分布之间的全变差距离的闭式表达式。对于在 $n$ 个结果上的两个概率分布 $\\{p_i\\}$ 和 $\\{u_i\\}$，其全变差距离定义为\n$$\n\\mathrm{TVD} = \\frac{1}{2}\\sum_{i=1}^{n} \\left| p_i - u_i \\right|.\n$$\n\n2) 证明拒绝采样映射在 $[a,b]$ 上产生了一个严格均匀的分布（即全变差距离为 $0$），并推导其接受概率 $\\alpha$ 以及每个被接受的输出所需的期望基础 PRNG 抽取次数。用 $m$、$n$、$q$ 和 $r$ 表示您的答案。\n\n3) 实现一个程序，对于下面的每个测试用例，使用您推导出的公式（而不是通过模拟）计算三个量：\n- 取模方法的全变差距离，$\\mathrm{TVD}_{\\mathrm{mod}}$。\n- 拒绝方法的全变差距离，$\\mathrm{TVD}_{\\mathrm{rej}}$。\n- 在拒绝采样下，每个被接受的输出所需的期望基础 PRNG 抽取次数，$\\mathbb{E}[D]$。\n\n测试套件（使用以下 $(a,b)$ 对；这些设计旨在包含一般情况、边界情况和边缘情况）：\n- 情况 1 (一般情况): $(a,b) = (0, 9)$，因此 $n=10$。\n- 情况 2 (退化范围): $(a,b) = (5, 5)$，因此 $n=1$。\n- 情况 3 (包含负数): $(a,b) = (-2, 2)$，因此 $n=5$。\n- 情况 4 (精确整除 $m$): $(a,b) = (0, 65535)$，因此 $n=65536$。\n- 情况 5 (大的非整除数): $(a,b) = (-10, 10^{6})$，因此 $n = 1{,}000{,}011$。\n\n精确的输出要求：\n- 对于每个测试用例，按此顺序输出一个列表 $[\\mathrm{TVD}_{\\mathrm{mod}}, \\mathrm{TVD}_{\\mathrm{rej}}, \\mathbb{E}[D]]$。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为这些逐案列表的逗号分隔列表，并用方括号括起来。例如：\n\"[ [x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],... ]\" 但不含空格。您的程序必须只输出这样的一行。\n- 所有结果必须是数值（接受浮点数）。您的解决方案中不允许进行随机采样；仅使用闭式表达式计算值。", "solution": "我们从第一性原理开始。基础伪随机数生成器 (PRNG) 从有限集 $\\{0,1,\\dots,m-1\\}$ 中均匀地抽取 $X$，其中 $m = 2^{32}$。对于一个目标整数区间 $[a,b]$，定义 $n = b-a+1 \\in \\mathbb{N}$。\n\n朴素取模映射分析：\n定义朴素映射 $Y_{\\mathrm{mod}} = a + (X \\bmod n)$。由于 $X$ 在 $\\{0,1,\\dots,m-1\\}$ 上是均匀分布的，且 $(X \\bmod n)$ 的取值在 $\\{0,1,\\dots,n-1\\}$ 中，因此 $(X \\bmod n) = i$ 的概率与 $\\{0,1,\\dots,m-1\\}$ 中有多少个整数模 $n$ 的余数为 $i$ 成正比。\n\n令 $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$ 且 $r = m - qn = m \\bmod n$，其中 $r \\in \\{0,1,\\dots,n-1\\}$。当我们将 $\\{0,1,\\dots,m-1\\}$ 划分为模 $n$ 的同余类时，恰好有 $r$ 个余数出现 $q+1$ 次，有 $n-r$ 个余数出现 $q$ 次。因此，对于余数 $i$，\n- 对于 $r$ 个 $i$ 值，$\\mathbb{P}[(X \\bmod n)=i] = \\frac{q+1}{m}$。\n- 对于 $n-r$ 个 $i$ 值，$\\mathbb{P}[(X \\bmod n)=i] = \\frac{q}{m}$。\n\n在 $\\{0,1,\\dots,n-1\\}$ 上的理想离散均匀分布为每个余数分配了概率 $\\frac{1}{n}$。绝对偏差为\n$$\n\\left|\\frac{q+1}{m} - \\frac{1}{n}\\right| = \\frac{n-r}{mn}, \\quad\n\\left|\\frac{q}{m} - \\frac{1}{n}\\right| = \\frac{r}{mn}.\n$$\n因此，全变差距离为\n$$\n\\mathrm{TVD}_{\\mathrm{mod}} = \\frac{1}{2}\\left( r \\cdot \\frac{n-r}{mn} + (n-r) \\cdot \\frac{r}{mn} \\right) = \\frac{r(n-r)}{mn}.\n$$\n这个闭式表达式量化了只要 $r \\neq 0$（即只要 $n$ 不能整除 $m$）时，取模方法引入的偏差。如果 $r=0$，那么 $\\mathrm{TVD}_{\\mathrm{mod}} = 0$，并且该映射是严格均匀的。\n\n拒绝采样分析：\n如前定义 $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$，如果 $X < qn$，则接受抽取，并在接受时返回 $Y_{\\mathrm{rej}} = a + (X \\bmod n)$；否则，从基础 PRNG 重新抽取。因为被接受的集合大小为 $qn$，并且被划分为 $n$ 个同余类，每个同余类的大小恰好为 $q$，所以在接受的条件下，余数 $(X \\bmod n)$ 在 $\\{0,1,\\dots,n-1\\}$ 上是严格均匀分布的。因此，\n$$\n\\mathrm{TVD}_{\\mathrm{rej}} = 0.\n$$\n接受概率为 $\\alpha = \\frac{qn}{m} = 1 - \\frac{r}{m}$，所需的基数抽取次数 $D$ 是一个成功概率为 $\\alpha$ 的几何随机变量，所以每个被接受的输出所需的期望基础抽取次数为\n$$\n\\mathbb{E}[D] = \\frac{1}{\\alpha} = \\frac{1}{1 - \\frac{r}{m}}.\n$$\n在 $r=0$ 的特殊情况下（即当 $n$ 整除 $m$ 时），我们有 $\\alpha = 1$ 和 $\\mathbb{E}[D] = 1$。\n\n算法设计：\n给定 $(a,b)$，计算 $n = b-a+1$，然后计算 $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$ 和 $r = m - qn$。使用这些值，评估：\n- $\\mathrm{TVD}_{\\mathrm{mod}} = \\frac{r(n-r)}{mn}$。\n- $\\mathrm{TVD}_{\\mathrm{rej}} = 0$。\n- $\\mathbb{E}[D] = \\frac{1}{1 - \\frac{r}{m}}$（约定当 $r=0$ 时 $\\mathbb{E}[D]=1$）。\n不需要随机采样；这些都是闭式计算。\n\n测试套件覆盖范围：\n- 情况 $n=10$ 测试了一个通用的非整除情况（$r \\neq 0$）。\n- 情况 $n=1$ 测试了一个退化的区间（总是均匀，零偏差）。\n- 情况 $n=5$ 测试了包含负数边界和一个小的非整除情况。\n- 情况 $n=65536$ 测试了精确整除的情况（$n$ 整除 $m$）。\n- 情况 $n=1{,}000{,}011$ 测试了一个大的非整除情况。\n\n输出格式：\n对于每种情况，输出 $[\\mathrm{TVD}_{\\mathrm{mod}}, \\mathrm{TVD}_{\\mathrm{rej}}, \\mathbb{E}[D]]$。将所有五种情况的结果聚合为一个以逗号分隔的列表，并用方括号括起来，不含空格，例如，在一行上打印 \"[[x1,y1,z1],[x2,y2,z2],...]\"。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(a: int, b: int, m: int) -> tuple[float, float, float]:\n    \"\"\"\n    Compute (TVD_mod, TVD_rej, E[D]) for target range [a,b],\n    given base PRNG modulus m (here m=2^32).\n    \"\"\"\n    n = b - a + 1\n    if n <= 0:\n        raise ValueError(\"Invalid range: b must be >= a.\")\n    # Compute q and r\n    q = m // n\n    r = m - q * n  # same as m % n, but avoids negatives\n    # Total variation distance for modulo method: r*(n-r)/(m*n)\n    tvd_mod = (r * (n - r)) / (m * n)\n    # Rejection sampling is exactly uniform\n    tvd_rej = 0.0\n    # Expected number of base draws per accepted output: 1 / (1 - r/m)\n    if r == 0:\n        expected_draws = 1.0\n    else:\n        expected_draws = 1.0 / (1.0 - (r / m))\n    return float(tvd_mod), float(tvd_rej), float(expected_draws)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 9),          # n=10\n        (5, 5),          # n=1\n        (-2, 2),         # n=5\n        (0, 65535),      # n=65536 (divides 2^32)\n        (-10, 10**6),    # n=1_000_011\n    ]\n    # Base PRNG modulus m = 2^32\n    m = 2 ** 32\n\n    results_str = []\n    for a, b in test_cases:\n        tvd_mod, tvd_rej, expected_draws = compute_metrics(a, b, m)\n        # Format numbers using a consistent, compact representation\n        # Use .17g for good precision without excessive digits\n        sub = \"[\" + \",\".join([\n            format(tvd_mod, \".17g\"),\n            format(tvd_rej, \".17g\"),\n            format(expected_draws, \".17g\"),\n        ]) + \"]\"\n        results_str.append(sub)\n\n    # Final print statement in the exact required format (no spaces).\n    print(f\"[{','.join(results_str)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "许多金融模型，如期权定价和风险值的计算，都依赖于正态分布，但我们基础的PRNG通常只生成均匀分布的随机数。我们如何跨越这一差距呢？本练习将运用中心极限定理（CLT）——该定理指出，大量独立同分布的随机变量之和趋向于正态分布。通过从第一性原理出发实现这一经典方法，你将亲手实践从均匀分布构造标准正态分布的过程，从而获得构建复杂金融模拟的基本工具。[@problem_id:2423303]", "id": "2423303", "problem": "设计一个完整、可运行的程序，通过模拟来证明：$12$ 个独立同分布的 $[0,1]$ 区间上的均匀随机变量之和，是标准正态随机变量的一个良好近似。您的程序必须从计算经济学和金融学中使用的基本原理出发：从均匀分布的定义、期望的线性性、独立变量的方差可加性以及中心极限定理 (CLT) 开始。不要依赖任何内置的正态随机数生成器来创建此近似；相反，应使用伪随机数生成器模拟均匀随机数，然后将它们相加。\n\n您必须使用线性同余生成器 (LCG) 来产生均匀分布随机数。线性同余生成器由以下递推关系定义\n$$\nX_{k+1} = (a X_k + c) \\bmod m,\n$$\n其中 $a$、$c$ 为整数，$m$ 为模数。通过 $U_k = X_k / m$ 将 $X_k$ 缩放到 $[0,1)$ 区间，从而获得伪随机数 $U_k$。使用广为人知的参数选择：$m = 2^{32}$，$a = 1664525$，$c = 1013904223$。要获得 $N$ 行独立的、每行 $12$ 个的均匀抽样，需要用状态 $X_0^{(i)} = (\\text{seed} + i) \\bmod m$（其中 $i \\in \\{0,1,\\dots,N-1\\}$）初始化 $N$ 个并行流，并将每个流推进 $12$ 步，以生成每行 $12$ 个均匀抽样。\n\n对每一行 $i$，计算\n$$\nZ_i = \\sum_{j=1}^{12} U_{i,j} - 6.\n$$\n使用以下事实作为基本依据：对于 $U \\sim \\text{Uniform}(0,1)$，有 $E[U] = 1/2$ 和 $\\operatorname{Var}(U) = 1/12$；独立变量之和的均值等于均值之和，方差等于方差之和；中心极限定理断言，随着加数数量的增加，独立同分布变量的标准化和在分布上收敛于标准正态分布。请注意，上述通过减去 $6$ 进行的中心化操作，将该和标准化为均值为 $0$、方差为 $1$ 的变量，因为 $12$ 个独立的 $[0,1]$ 区间上均匀随机变量之和的方差是 $12 \\cdot (1/12) = 1$。\n\n您的程序必须使用三个诊断指标来量化模拟出的 $\\{Z_i\\}_{i=1}^N$ 与标准正态分布 $N(0,1)$ 的接近程度：\n- 样本均值 $\\hat{\\mu} = \\frac{1}{N}\\sum_{i=1}^N Z_i$，\n- 样本方差 $\\hat{\\sigma}^2 = \\frac{1}{N}\\sum_{i=1}^N (Z_i - \\hat{\\mu})^2$ (使用分母 $N$)，\n- 柯尔莫哥洛夫–斯米尔诺夫距离 $D_N = \\sup_{z \\in \\mathbb{R}} \\left| \\hat{F}_N(z) - \\Phi(z) \\right|$，其中 $\\hat{F}_N$ 是 $\\{Z_i\\}$ 的经验累积分布函数，而 $\\Phi$ 是 $N(0,1)$ 的累积分布函数。\n\n构建一个包含三种情况的测试套件，以覆盖一般情况、低样本边界情况和大种子边缘情况。对于每种情况，参数为 $(N, \\text{seed}, \\tau_\\mu, \\tau_{\\sigma^2}, \\tau_{KS})$，其中 $\\tau_\\mu$ 是 $|\\hat{\\mu} - 0|$ 的容差，$\\tau_{\\sigma^2}$ 是 $|\\hat{\\sigma}^2 - 1|$ 的容差，$\\tau_{KS}$ 是 $D_N$ 的容差。需要实现的三个测试用例是：\n- 情况 A (一般，大样本): $(N, \\text{seed}, \\tau_\\mu, \\tau_{\\sigma^2}, \\tau_{KS}) = (200000, 987654321, 0.004, 0.004, 0.020)$。\n- 情况 B (边界，低样本): $(N, \\text{seed}, \\tau_\\mu, \\tau_{\\sigma^2}, \\tau_{KS}) = (4000, 2024, 0.050, 0.060, 0.080)$。\n- 情况 C (边缘，极端种子): $(N, \\text{seed}, \\tau_\\mu, \\tau_{\\sigma^2}, \\tau_{KS}) = (150000, 4294967295, 0.004, 0.005, 0.020)$。\n\n对每种情况，根据以下定义生成一个布尔结果\n$$\n\\text{pass} = \\left( |\\hat{\\mu}| \\le \\tau_\\mu \\right) \\land \\left( |\\hat{\\sigma}^2 - 1| \\le \\tau_{\\sigma^2} \\right) \\land \\left( D_N \\le \\tau_{KS} \\right).\n$$\n\n您的程序应生成单行输出，其中按顺序包含情况 A、B 和 C 的结果，形式为用方括号括起来的逗号分隔列表（例如，“[True,False,True]”）。没有需要报告的物理单位或角度，也不需要百分比；所有数值比较均使用上述指定的绝对容差。", "solution": "问题陈述已被分析并被认为是有效的。它提出了一个定义明确、有科学依据且客观的计算任务，其根植于概率论和数值方法的基本原理。这是计算统计学中的一个标准练习，与计算经济学和金融学领域相关。其中没有矛盾、歧义或事实不准确之处。我们接下来提供一个完整的解决方案。\n\n目标是通过模拟来演示中心极限定理 (CLT)，方法是近似一个标准正态分布。这是通过对固定数量的独立同分布 (i.i.d.) 均匀随机变量求和来实现的。这种近似的理论基础是坚实的。\n\n首先，考虑一个在区间 $[0,1]$ 上均匀分布的随机变量 $U$。其概率密度函数为 $f_U(u) = 1$（当 $u \\in [0,1]$ 时），否则为 $0$。该分布的关键性质是其期望（均值）和方差：\n$$\nE[U] = \\int_0^1 u \\, du = \\frac{1}{2}\n$$\n$$\n\\operatorname{Var}(U) = E[U^2] - (E[U])^2 = \\int_0^1 u^2 \\, du - \\left(\\frac{1}{2}\\right)^2 = \\frac{1}{3} - \\frac{1}{4} = \\frac{1}{12}\n$$\n问题提出构建一个新的随机变量 $S_{12}$，作为 $n=12$ 个此类独立同分布均匀变量 $\\{U_j\\}_{j=1}^{12}$ 的和：\n$$\nS_{12} = \\sum_{j=1}^{12} U_j\n$$\n根据期望的线性性，这个和的均值是各个均值的和：\n$$\nE[S_{12}] = E\\left[\\sum_{j=1}^{12} U_j\\right] = \\sum_{j=1}^{12} E[U_j] = 12 \\times \\frac{1}{2} = 6\n$$\n因为变量 $U_j$ 是独立的，所以和的方差是各个方差的和：\n$$\n\\operatorname{Var}(S_{12}) = \\operatorname{Var}\\left(\\sum_{j=1}^{12} U_j\\right) = \\sum_{j=1}^{12} \\operatorname{Var}(U_j) = 12 \\times \\frac{1}{12} = 1\n$$\n中心极限定理指出，对于足够大的加数数量 $n$，独立同分布随机变量的标准化和的分布会逼近标准正态分布 $\\mathcal{N}(0,1)$。标准化变量（记为 $Z$）是通过减去均值并除以标准差得到的。在我们的例子中，当 $n=12$ 时，标准差为 $\\sqrt{\\operatorname{Var}(S_{12})} = \\sqrt{1} = 1$。因此，标准化变量为：\n$$\nZ = \\frac{S_{12} - E[S_{12}]}{\\sqrt{\\operatorname{Var}(S_{12})}} = \\sum_{j=1}^{12} U_j - 6\n$$\n问题假定 $n=12$ 对于使此近似达到合理的准确度是足够大的。我们的任务是通过计算来验证这一说法。\n\n模拟算法按以下步骤进行。我们必须首先生成均匀分布随机数 $U_j$。问题指定使用线性同余生成器 (LCG)，这是一类常见的伪随机数生成器，由以下递推关系定义：\n$$\nX_{k+1} = (a X_k + c) \\bmod m\n$$\n然后，整数序列 $\\{X_k\\}$ 被映射到区间 $[0,1)$ 以产生伪随机均匀变量 $U_k$：\n$$\nU_k = \\frac{X_k}{m}\n$$\n指定的参数是模数 $m = 2^{32}$、乘数 $a = 1664525$ 和增量 $c = 1013904223$。\n\n为了生成 $N$ 个独立的 $Z$ 样本，我们必须确保用于每个样本的 $12$ 个均匀随机数序列本身是独立的。这通过运行 $N$ 个并行的 LCG 流来实现，每个流从不同的初始状态（种子）开始。第 $i$ 个流（其中 $i \\in \\{0, 1, \\dots, N-1\\}$）的种子定义为 $X_0^{(i)} = (\\text{seed} + i) \\bmod m$。对每个流 $i$，我们通过迭代其 LCG 12 次来生成 $12$ 个随机数 $\\{U_{i,j}\\}_{j=1}^{12}$。由此，我们计算出目标变量的一个样本：\n$$\nZ_i = \\left(\\sum_{j=1}^{12} U_{i,j}\\right) - 6\n$$\n对所有 $N$ 个流重复此过程，以获得样本 $\\{Z_i\\}_{i=1}^N$。\n\n为了量化近似的质量，我们对生成的样本 $\\{Z_i\\}$ 计算三个诊断统计量：\n1.  样本均值，$\\hat{\\mu} = \\frac{1}{N}\\sum_{i=1}^N Z_i$。这应接近理论均值 $E[Z] = 0$。\n2.  样本方差，$\\hat{\\sigma}^2 = \\frac{1}{N}\\sum_{i=1}^N (Z_i - \\hat{\\mu})^2$。这应接近理论方差 $\\operatorname{Var}(Z) = 1$。问题指定使用分母 $N$。\n3.  柯尔莫哥洛夫-斯米尔诺夫 (KS) 距离，$D_N = \\sup_{z \\in \\mathbb{R}} \\left| \\hat{F}_N(z) - \\Phi(z) \\right|$。此处，$\\hat{F}_N(z)$ 是样本的经验累积分布函数 (ECDF)，而 $\\Phi(z)$ 是标准正态分布的累积分布函数 (CDF)。KS 距离测量观测到的 CDF 和理论 CDF 之间的最大绝对差，为分布拟合度提供了一个稳健的度量。\n\n对于三个测试用例中的每一个，通过将样本均值与 $0$ 的绝对偏差、样本方差与 $1$ 的绝对偏差以及 KS 距离分别与其各自的容差 $(\\tau_\\mu, \\tau_{\\sigma^2}, \\tau_{KS})$ 进行比较，来确定一个布尔结果。当且仅当所有三个诊断指标都在其容差范围内时，该用例才算通过。实现将使用向量化操作高效地执行这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kstest, norm\n\ndef solve():\n    \"\"\"\n    Runs a simulation to validate that the sum of 12 uniform random variables\n    approximates a standard normal distribution, based on the Central Limit Theorem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general, large sample)\n        (200000, 987654321, 0.004, 0.004, 0.020),\n        # Case B (boundary, low sample)\n        (4000, 2024, 0.050, 0.060, 0.080),\n        # Case C (edge, extreme seed)\n        (150000, 4294967295, 0.004, 0.005, 0.020),\n    ]\n\n    results = []\n    \n    # LCG parameters\n    m_val = 2**32\n    a_val = 1664525\n    c_val = 1013904223\n    \n    # Use 64-bit unsigned integers for LCG calculations to handle intermediate products safely.\n    m = np.uint64(m_val)\n    a = np.uint64(a_val)\n    c = np.uint64(c_val)\n\n    for case in test_cases:\n        N, seed, tau_mu, tau_sigma2, tau_ks = case\n        \n        # 1. Initialize N parallel LCG streams.\n        # We use Python's arbitrary-precision integers for the initial seed calculation\n        # to correctly handle the `(seed + i) % m` operation, especially for large seeds.\n        # The result is then cast to uint64 for vectorized numpy operations.\n        initial_states = np.array([(seed + i) % m_val for i in range(N)], dtype=np.uint64)\n        \n        # 2. Generate 12 uniform variates for each stream and sum them up.\n        # Vectorized operations are used for efficiency.\n        current_states = initial_states\n        sum_of_uniforms = np.zeros(N, dtype=np.float64)\n        \n        for _ in range(12):\n            # Advance the state of all N streams\n            current_states = (a * current_states + c) % m\n            # Convert integer state to uniform variate in [0, 1) and add to sum\n            sum_of_uniforms += current_states.astype(np.float64) / m_val\n            \n        # 3. Form the approximately standard normal variates Z\n        # Z_i = (sum of 12 uniforms) - 6\n        z_samples = sum_of_uniforms - 6.0\n        \n        # 4. Compute diagnostics\n        # Sample mean\n        mu_hat = np.mean(z_samples)\n        \n        # Sample variance (with denominator N, which is default for np.var)\n        sigma2_hat = np.var(z_samples)\n        \n        # Kolmogorov-Smirnov distance against the standard normal distribution N(0,1)\n        # kstest against 'norm' tests for N(0,1) by default.\n        ks_result = kstest(z_samples, 'norm')\n        ks_dist = ks_result.statistic\n        \n        # 5. Check if the results are within the given tolerances.\n        pass_mu = abs(mu_hat) <= tau_mu\n        pass_sigma2 = abs(sigma2_hat - 1.0) <= tau_sigma2\n        pass_ks = ks_dist <= tau_ks\n        \n        passed = pass_mu and pass_sigma2 and pass_ks\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}