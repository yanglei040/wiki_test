{"hands_on_practices": [{"introduction": "这个练习探讨了随机游走的一个基本但深刻的性质：首次返回起点的时间。通过解决这个问题，你将学习如何运用组合数学方法，例如通过与卡特兰数（Catalan numbers）的联系，来精确计算一个看似随机的事件的概率。这个过程不仅能加深你对随机游走内在结构的理解，还能锻炼你的抽象推理和数学建模能力。[@problem_id:2425131]", "id": "2425131", "problem": "考虑一个程式化的市场微观结构模型，其中中间价在离散时间内，每一步以相等的概率独立地向上或向下变动一个 tick。设 $\\{X_{k}\\}_{k \\geq 1}$ 为独立同分布的随机变量，满足 $\\mathbb{P}(X_{k}=1)=\\mathbb{P}(X_{k}=-1)=\\tfrac{1}{2}$，并定义对称一维随机游走 $S_{0}=0$ 和 $S_{n}=\\sum_{k=1}^{n} X_{k}$（对于 $n \\geq 1$）。将首次返回起始水平的时间定义为 $\\tau=\\min\\{k \\geq 1 : S_{k}=0\\}$。对于一个固定的正整数 $n$，计算概率 $\\mathbb{P}(\\tau=2n)$，将其表示为 $n$ 的一个闭式函数。请用一个关于 $n$ 的单一解析表达式给出最终答案。无需四舍五入。", "solution": "我们从对称简单随机游走的定义开始。长度为 $2n$ 的路径由序列 $(X_{1},\\dots,X_{2n})$ 决定，其中每个元素都在 $\\{-1,1\\}$ 中，并且每个这样的序列的概率为 $2^{-2n}$。事件 $\\{\\tau=2n\\}$ 指的是 $S_{2n}=0$ 且对于所有 $1 \\leq k \\leq 2n-1$ 都有 $S_{k} \\neq 0$。因为 $S_{k}$ 与 $k$ 具有相同的奇偶性，所以返回到 0 只能在偶数时刻发生，因此关注 $2n$ 是很自然的。\n\n为了计算实现 $\\{\\tau=2n\\}$ 的序列数量，我们首先根据第一步的符号进行分类。根据对称性，以 $X_{1}=1$ 开始的有效路径数量等于以 $X_{1}=-1$ 开始的有效路径数量。因此，我们只需计算以 $X_{1}=1$ 开始、中间保持严格为正、并最终以 $S_{2n}=0$ 结束的有效路径数量，然后将结果乘以 2。\n\n考虑满足 $X_{1}=1$，且对于 $1 \\leq k \\leq 2n-1$ 有 $S_{k} \\geq 1$ 的路径，这条路径在 $S_{2n}=0$ 处结束。去掉第一步和最后一步，对于剩下的 $2n-2$ 步，我们通过向下平移 1 个单位来定义一条变换后的路径：令 $Y_{j}=S_{j+1}-1$（对于 $j=0,1,\\dots,2n-2$），其中 $Y_{0}=0$ 且 $Y_{2n-2}=0$。条件 $S_{k} \\geq 1$（对于 $1 \\leq k \\leq 2n-1$）变为 $Y_{j} \\geq 0$（对于所有 $0 \\leq j \\leq 2n-2$）。因此，变换后的路径是一条长度为 $2n-2$ 的 Dyck 路径，即一条在整数上从 0 开始到 0 结束且从不低于 0 的最近邻路径。这种 Dyck 路径的数量是卡特兰数 $C_{n-1}$，其中\n$$\nC_{n-1}=\\frac{1}{n}\\binom{2n-2}{n-1}.\n$$\n根据对称性，以 $X_{1}=-1$ 开始、在 $2n-1$ 时刻前保持严格为负（然后在 $2n$ 时刻回到 0）的有效路径数量也是 $C_{n-1}$。因此，实现 $\\{\\tau=2n\\}$ 的序列总数为 $2 C_{n-1}$。\n\n由于每个序列的概率为 $2^{-2n}$，我们得到\n$$\n\\mathbb{P}(\\tau=2n)=\\frac{2 C_{n-1}}{2^{2n}}=\\frac{2}{2^{2n}}\\cdot \\frac{1}{n}\\binom{2n-2}{n-1}.\n$$\n这可以通过代数方法简化为中心二项式形式。使用恒等式\n$$\n\\frac{2}{n}\\binom{2n-2}{n-1}=\\frac{1}{2n-1}\\binom{2n}{n},\n$$\n我们得出结论\n$$\n\\mathbb{P}(\\tau=2n)=\\frac{1}{2n-1}\\binom{2n}{n} 2^{-2n}.\n$$\n这就是所求的关于 $n$ 的闭式表达式。", "answer": "$$\\boxed{\\frac{1}{2n-1}\\binom{2n}{n}2^{-2n}}$$"}, {"introduction": "本练习将抽象的随机游走模型应用于金融工程中的一个核心问题：衍生品定价。你将学习如何将资产价格的变动建模为一个离散时间随机游走，并利用“一步分析法”（first-step analysis）来为一种称为“障碍期权”（barrier option）的金融合约定价。这个练习旨在让你掌握将金融问题转化为随机过程模型并求解的关键技能。[@problem_id:2425167]", "id": "2425167", "problem": "考虑一个状态变量 $X_{t}$ 的离散时间模型，该模型在一个有限格点 $\\{0,1,2,\\dots,H\\}$ 上作一维随机游走，其中 $H \\in \\mathbb{N}$ 且 $H \\geq 2$。该过程从 $X_{0} = i$ 开始，其中 $i \\in \\{1,2,\\dots,H-1\\}$，并根据以下针对内部状态的转移概率进行演化：\n- $\\mathbb{P}(X_{t+1} = x+1 \\mid X_{t} = x) = p$，\n- $\\mathbb{P}(X_{t+1} = x-1 \\mid X_{t} = x) = 1-p$，\n对所有 $x \\in \\{1,2,\\dots,H-1\\}$，其中 $p \\in (0,1)$。边界状态 $0$ 和 $H$ 是吸收态：一旦 $X_{t}$ 到达 $0$ 或 $H$，它将停留在那里。\n\n设每期无风险总回报为 $1+r$，$r > 0$，并定义折现因子 $\\beta \\equiv (1+r)^{-1} \\in (0,1)$。根据风险中性定价原理，任何支付在时刻 $0$ 的价格是在风险中性测度下该支付的折现期望。\n\n定义停时 $\\tau_{H} \\equiv \\inf\\{t \\geq 0 : X_{t} = H\\}$ 和 $\\tau_{0} \\equiv \\inf\\{t \\geq 0 : X_{t} = 0\\}$。考虑一个数字向上敲入障碍期权，该期权在首次到达上方壁垒 $H$ 时支付 $1$ 个记账单位，否则支付 $0$。确切地说，当初始状态为 $X_{0}=i$ 时，其在时刻 $0$ 的价值是\n$$\nV(i) \\equiv \\mathbb{E}_{i}\\big[\\beta^{\\tau_{H}} \\mathbf{1}_{\\{\\tau_{H} < \\tau_{0}\\}}\\big],\n$$\n其中 $\\mathbb{E}_{i}[\\cdot]$ 表示以 $X_{0}=i$ 为条件的期望。\n\n从风险中性定价原理、$X_{t}$ 的马尔可夫性质和首步分析法出发（不使用任何现成公式），推导 $V(i)$ 作为 $H$、$i$、$p$ 和 $\\beta$ 的函数的闭式表达式。你的最终答案必须是关于这些参数的单一闭式解析表达式。不要提供不等式或待解方程；请提供显式表达式。无需进行四舍五入。", "solution": "所提出的问题是随机过程领域中一个定义明确的问题，具体涉及在具有吸收边界的有限格点上的一维随机游走。任务是在风险中性框架内，计算一种特定衍生证券——数字障碍期权的价格。该问题有科学依据、内容自洽且客观。我们将着手进行其严格的推导。\n\n该期权的价值 $V(i)$ 定义为在起始状态 $X_{0}=i$ 的条件下，折现后的期望支付：\n$$\nV(i) = \\mathbb{E}_{i}\\big[\\beta^{\\tau_{H}} \\mathbf{1}_{\\{\\tau_{H} < \\tau_{0}\\}}\\big]\n$$\n此处，$\\tau_{H}$ 和 $\\tau_{0}$ 分别是首次到达上方壁垒 $H$ 和下方壁垒 $0$ 的时间。状态空间为 $\\{0, 1, \\dots, H\\}$。状态 $0$ 和 $H$ 是吸收态。\n\n$V(i)$ 的边界条件由吸收态的性质决定：\n1. 如果过程从 $i=0$ 开始，它会立即被吸收。因此，$\\tau_{0}=0$ 且 $\\tau_{H}$ 必然大于 $0$。条件 $\\tau_{H} < \\tau_{0}$ 不被满足，因此支付为 $0$。所以，$V(0)=0$。\n2. 如果过程从 $i=H$ 开始，它会立即被吸收。因此，$\\tau_{H}=0$。此时尚未到达下方壁垒，所以 $\\tau_{0} > 0$。条件 $\\tau_{H} < \\tau_{0}$ 被满足。支付在时刻 $t=0$ 实现，因此折现后的价值为 $\\beta^{0} \\cdot 1 = 1$。所以，$V(H)=1$。\n\n对于任何内部状态 $i \\in \\{1, 2, \\dots, H-1\\}$，我们可以利用全期望定律和过程 $X_{t}$ 的马尔可夫性质，应用首步分析法。我们将期望基于从 $t=0$ 到 $t=1$ 的第一步结果进行条件化：\n$$\nV(i) = \\mathbb{E}_{i}\\left[ \\mathbb{E}\\left[ \\beta^{\\tau_{H}} \\mathbf{1}_{\\{\\tau_{H} < \\tau_{0}\\}} \\mid X_1 \\right] \\right]\n$$\n在时刻 $t=1$，过程将以概率 $p$ 处于状态 $i+1$，或以概率 $1-p$ 处于状态 $i-1$。\n如果 $X_{1}=i+1$，则已过去一个时间步。从此时点开始寻找折现期望支付的问题，与从状态 $i+1$ 开始的原始问题相同，但所有未来的支付都必须额外折现一个因子 $\\beta$。因此，其价值为 $\\beta V(i+1)$。\n类似地，如果 $X_{1}=i-1$，则后续的价值为 $\\beta V(i-1)$。\n\n综合这些可能性，我们得到关于 $V(i)$ 的以下二阶线性齐次差分方程：\n$$\nV(i) = p \\cdot (\\beta V(i+1)) + (1-p) \\cdot (\\beta V(i-1))\n$$\n这可以改写为：\n$$\np\\beta V(i+1) - V(i) + (1-p)\\beta V(i-1) = 0\n$$\n对 $i \\in \\{1, 2, \\dots, H-1\\}$。\n\n为求解此递推关系，我们假设解的形式为 $V(i) = \\lambda^{i}$。将此代入方程，得到特征方程：\n$$\np\\beta \\lambda^{i+1} - \\lambda^{i} + (1-p)\\beta \\lambda^{i-1} = 0\n$$\n假设 $\\lambda \\neq 0$，两边同除以 $\\lambda^{i-1}$，得到关于 $\\lambda$ 的一个二次方程：\n$$\np\\beta \\lambda^2 - \\lambda + (1-p)\\beta = 0\n$$\n该二次方程的根由求根公式给出：\n$$\n\\lambda_{1,2} = \\frac{1 \\pm \\sqrt{1 - 4(p\\beta)((1-p)\\beta)}}{2p\\beta} = \\frac{1 \\pm \\sqrt{1 - 4p(1-p)\\beta^2}}{2p\\beta}\n$$\n鉴于 $p \\in (0,1)$ 且 $\\beta \\in (0,1)$，项 $p(1-p)$ 的界限为 $0 < p(1-p) \\leq \\frac{1}{4}$，且 $\\beta^2 \\in (0,1)$。因此，判别式 $1 - 4p(1-p)\\beta^2$ 严格为正且小于 $1$。这确保了存在两个不同的实根 $\\lambda_1$ 和 $\\lambda_2$。\n\n该差分方程的通解是这些根的幂的线性组合：\n$$\nV(i) = c_1 \\lambda_1^i + c_2 \\lambda_2^i\n$$\n其中 $c_1$ 和 $c_2$ 是由边界条件决定的常数。\n设 $\\lambda_1$ 是带加号的根，$\\lambda_2$ 是带减号的根。\n使用边界条件 $V(0)=0$：\n$$\nV(0) = c_1 \\lambda_1^0 + c_2 \\lambda_2^0 = c_1 + c_2 = 0 \\implies c_2 = -c_1\n$$\n这将通解简化为：\n$$\nV(i) = c_1 (\\lambda_1^i - \\lambda_2^i)\n$$\n现在，我们应用第二个边界条件 $V(H)=1$：\n$$\nV(H) = c_1 (\\lambda_1^H - \\lambda_2^H) = 1\n$$\n由于 $\\lambda_1 \\neq \\lambda_2$，且两者均为正，对于 $H \\ge 1$ 有 $\\lambda_1^H - \\lambda_2^H \\neq 0$。我们可以解出 $c_1$：\n$$\nc_1 = \\frac{1}{\\lambda_1^H - \\lambda_2^H}\n$$\n将 $c_1$ 代回到 $V(i)$ 的表达式中，我们得到最终的闭式解：\n$$\nV(i) = \\frac{\\lambda_1^i - \\lambda_2^i}{\\lambda_1^H - \\lambda_2^H}\n$$\n代入根 $\\lambda_1$ 和 $\\lambda_2$ 的表达式，我们就得到了 $V(i)$ 作为 $H、i、p$ 和 $\\beta$ 的函数的显式解。", "answer": "$$\n\\boxed{\\frac{\\left(\\frac{1 + \\sqrt{1 - 4p(1-p)\\beta^2}}{2p\\beta}\\right)^{i} - \\left(\\frac{1 - \\sqrt{1 - 4p(1-p)\\beta^2}}{2p\\beta}\\right)^{i}}{\\left(\\frac{1 + \\sqrt{1 - 4p(1-p)\\beta^2}}{2p\\beta}\\right)^{H} - \\left(\\frac{1 - \\sqrt{1 - 4p(1-p)\\beta^2}}{2p\\beta}\\right)^{H}}}\n$$"}, {"introduction": "简单的随机游走模型是分析金融市场的基础，但其核心假设（例如，收益是独立同分布的）在现实中是否成立？这个练习引导我们从理论走向实证，介绍金融时间序列中一个著名的现象——“波动率聚集性”（volatility clustering）。你将亲手实现一个标准的统计检验（Ljung-Box检验）来识别这种模式，从而学会批判性地评估模型假设，并为理解更高级的金融模型（如GARCH）打下基础。[@problem_id:2425100]", "id": "2425100", "problem": "给定一个离散时间股价过程，其模型为随机游走。设价格为 $\\{S_t\\}_{t=0}^n$，其增量（收益率）为 $\\{r_t\\}_{t=1}^n$，定义为 $S_t = S_{t-1} + r_t$，$t \\in \\{1,\\dots,n\\}$。波动率代理变量定义为增量的平方 $\\{v_t\\}_{t=1}^n$，其中 $v_t = r_t^2$。波动率聚集被解释为序列 $\\{v_t\\}$ 在时间上的线性相关性。\n\n您的任务是实现一个统计检验，用于检验 $\\{v_t\\}$ 中的波动率聚集。该检验基于原假设：$\\{v_t\\}$ 在时间上是不相关的。令 $\\bar{v} = \\frac{1}{n}\\sum_{t=1}^n v_t$ 表示 $\\{v_t\\}$ 的样本均值。对于滞后阶数 $k \\in \\{1,\\dots,h\\}$，$\\{v_t\\}$ 的样本自相关系数为\n$$\n\\rho_k \\;=\\; \\frac{\\sum_{t=k+1}^{n} \\left(v_t - \\bar{v}\\right)\\left(v_{t-k} - \\bar{v}\\right)}{\\sum_{t=1}^{n} \\left(v_t - \\bar{v}\\right)^2}.\n$$\n令 $h' = \\min\\{h,\\,n-1\\}$。定义 $\\{v_t\\}$ 在 $h'$ 阶滞后下的 Ljung–Box 统计量为\n$$\nQ \\;=\\; n(n+2)\\sum_{k=1}^{h'} \\frac{\\rho_k^2}{n-k}.\n$$\n在 $\\{v_t\\}$ 在时间上不相关的原假设下，统计量 $Q$ 渐近服从自由度为 $h'$ 的卡方分布。使用显著性水平 $\\alpha$，定义决策规则为“检测到聚集”当且仅当\n$$\nQ \\;>\\; \\chi^2_{1-\\alpha}(h'),\n$$\n其中 $\\chi^2_{1-\\alpha}(h')$ 是自由度为 $h'$ 的卡方分布的上 $(1-\\alpha)$ 分位数。如果 $h' = 0$ 或 $\\sum_{t=1}^{n} \\left(v_t - \\bar{v}\\right)^2 = 0$，则检验必须返回对应于“未检测到聚集”的布尔值。所有布尔值必须表示为 $True$ 或 $False$。\n\n使用 $h = 10$ 和 $\\alpha = 0.01$。所有计算均无单位。\n\n请为以下参数化的数据生成过程实现该检验。在所有情况下，$\\{\\varepsilon_t\\}$ 表示独立的标准正态变量，$\\varepsilon_t \\sim \\mathcal{N}(0,1)$，并且必须使用指定的随机种子以确保可复现性。增量 $\\{r_t\\}$ 按如下方式生成，且价格过程满足 $S_t = S_{t-1} + r_t$，$S_0$ 为任意值。\n\n测试套件（五个案例）：\n- 案例 A（独立同分布的高斯收益率，长样本）：\n  - $n = 2000$，$\\sigma = 1.0$，$r_t = \\sigma \\varepsilon_t$，种子 $= 12345$。\n- 案例 B（机制转换方差，长样本）：\n  - $n = 2000$，$\\sigma_L = 1.0$，$\\sigma_H = 3.0$，数据块长度 $= 100$。\n  - 令第一个长度为 100 的数据块中 $\\sigma_t = \\sigma_L$，下一个长度为 100 的数据块中 $\\sigma_t = \\sigma_H$，此后交替进行，直到 $t = n$。\n  - $r_t = \\sigma_t \\varepsilon_t$，种子 $= 24680$。\n- 案例 C（广义自回归条件异方差类型递归，长样本）：\n  - $n = 2000$，$r_t = \\sigma_t \\varepsilon_t$，$\\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2$。\n  - 参数：$\\omega = 0.05$，$\\alpha = 0.35$，$\\beta = 0.60$，初始方差 $\\sigma_0^2 = \\frac{\\omega}{1 - \\alpha - \\beta}$，种子 $= 98765$。\n- 案例 D（退化的零收益率）：\n  - $n = 200$，对于所有 $t \\in \\{1,\\dots,n\\}$，$r_t = 0$。\n- 案例 E（独立同分布的高斯收益率，短样本）：\n  - $n = 12$，$\\sigma = 1.0$，$r_t = \\sigma \\varepsilon_t$，种子 $= 54321$。\n\n您的程序必须对每种情况评估该检验，并返回一个布尔值，指示在指定的显著性水平下是否检测到波动率聚集。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[resultA,resultB,resultC,resultD,resultE]”），其中每个条目按案例 A 到 E 的顺序依次为 $True$ 或 $False$。", "solution": "所提出的问题要求实现一个统计检验，用于检测股票收益率时间序列中的波动率聚集现象。所提出的方法是将 Ljung-Box 检验应用于平方收益率，后者可作为波动率的代理变量。该问题陈述在科学上是合理的、定义明确的，并为得出唯一、可复现的解决方案提供了所有必要信息。它基于时间序列计量经济学的既定原则。因此，我将给出完整的解法。\n\n问题的核心是检验原假设 $H_0$：平方收益率序列 $\\{v_t\\}_{t=1}^n$（其中 $v_t = r_t^2$）在时间上不相关。备择假设 $H_1$ 是至少有一个自相关系数不为零，这被解释为存在波动率聚集。\n\n首先，我们将波动率代理序列 $\\{v_t\\}$ 的样本均值定义为：\n$$ \\bar{v} = \\frac{1}{n} \\sum_{t=1}^n v_t $$\n对于给定的滞后阶数 $k$（$k$ 为正整数），样本自相关系数衡量了 $v_t$ 与其过去值 $v_{t-k}$ 之间的线性关系。所提供的公式为：\n$$ \\rho_k = \\frac{\\sum_{t=k+1}^{n} (v_t - \\bar{v})(v_{t-k} - \\bar{v})}{\\sum_{t=1}^{n} (v_t - \\bar{v})^2} $$\n分母是一个归一化因子，表示序列 $\\{v_t\\}$ 的总方差。处理分母为零的情况非常重要，这种情况当且仅当所有 $v_t$ 都相同时发生。在这种退化情况下，自相关是未定义的，问题正确地指明我们必须得出“未检测到聚集”的结论。\n\nLjung-Box 检验将前 $h'$ 个样本自相关系数的信息汇总成一个单一的检验统计量 $Q$。滞后阶数取为 $h' = \\min\\{h, n-1\\}$，其中 $h=10$ 是考虑的最大滞后阶数，$n$ 是样本量。对于 $n-1 < h$ 的短时间序列，此调整是必要的。$Q$ 统计量定义为：\n$$ Q = n(n+2) \\sum_{k=1}^{h'} \\frac{\\rho_k^2}{n-k} $$\n与更简单的 Box-Pierce 统计量相比，此统计量包含修正因子 $n(n+2)$ 和分母中的项 $(n-k)$，这改善了检验在有限样本中的性能。\n\n在 $\\{v_t\\}$ 的真实自相关系数全部为零的原假设下，$Q$ 统计量渐近服从自由度为 $h'$ 的卡方分布，记为 $\\chi^2(h')$。\n\n决策规则基于预先定义的显著性水平 $\\alpha$（给定为 0.01）。如果我们的统计量 $Q$ 的观测值异常大，我们便拒绝无自相关的原假设。“异常大”定义为超过相应卡方分布的 $(1-\\alpha)$ 分位数。这是检验的临界值 $\\chi^2_{1-\\alpha}(h')$。因此，决策规则如下：\n- 如果 $Q > \\chi^2_{1-\\alpha}(h')$，则拒绝 $H_0$。结论是检测到波动率聚集（返回 $True$）。\n- 如果 $Q \\le \\chi^2_{1-\\alpha}(h')$，则不拒绝 $H_0$。结论是没有证据表明存在波动率聚集（返回 $False$）。\n- 根据问题要求，如果 $h' = 0$ 或者 $\\{v_t\\}$ 的方差为零，我们也返回 $False$。\n\n现在我们将此程序应用于五个指定的案例。\n\n**案例 A (IID 高斯分布, $n=2000$)：** 收益率 $r_t = \\sigma \\varepsilon_t$ 由一个独立同分布 (IID) 的标准正态过程生成。因此，平方收益率 $v_t = r_t^2 = \\sigma^2 \\varepsilon_t^2$ 也是一个 IID 序列（具体来说，是一个按比例缩放的、自由度为 1 的卡方分布）。在 $\\{v_t\\}$ 中不存在理论上的自相关性。我们预计 Ljung-Box 检验将无法拒绝原假设，从而得出 $False$ 的结论。\n\n**案例 B (机制转换, $n=2000$)：** 收益率的方差 $\\sigma_t^2$ 在低状态（$\\sigma_L^2$）和高状态（$\\sigma_H^2$）之间以数据块的形式切换。一段高方差时期（大的 $r_t^2$）之后会跟随着更多来自高方差机制的观测值，低方差机制同理。这种块状结构在平方收益率 $\\{v_t\\}$ 中引发了持续性，从而导致了正自相关。检验应该能检测到这种结构，我们预计结果为 $True$。\n\n**案例 C (GARCH(1,1), $n=2000$)：** 广义自回归条件异方差 (GARCH) 模型是专门为捕捉波动率聚集而设计的。条件方差 $\\sigma_t^2$ 是过去平方收益率（$r_{t-1}^2$）和过去方差（$\\sigma_{t-1}^2$）的显式函数。参数 $\\alpha = 0.35$ 和 $\\beta = 0.60$ 导致了高持续性，因为 $\\alpha + \\beta = 0.95$，接近于 1。这确保了对波动率的冲击是持久的，从而在 $\\{v_t\\}$ 中产生了强自相关。预计该检验将强烈拒绝原假设，得出 $True$ 的结果。初始方差被正确设置为该过程的无条件方差 $\\sigma^2 = \\frac{\\omega}{1-\\alpha-\\beta}$，这是对平稳 GARCH 过程进行模拟的标准且恰当的初始化方法。\n\n**案例 D (退化, $n=200$)：** 收益率始终为零，$r_t=0$。这意味着对所有 $t$ 都有 $v_t = r_t^2 = 0$。序列 $\\{v_t\\}$ 的方差为零。自相关公式中的分母 $\\sum_{t=1}^{n} (v_t - \\bar{v})^2$ 为零。根据明确指示，检验必须返回 $False$。\n\n**案例 E (IID 高斯分布, $n=12$)：** 此案例与案例 A 类似，其基础是一个 IID 过程，因此理论上不存在波动率聚集。然而，样本量 $n=12$ 非常小。对于此案例，滞后阶数将为 $h' = \\min\\{10, 12-1\\} = 10$。Ljung-Box 检验基于渐近近似，其在如此小的样本中性能可能不佳。尽管如此，我们必须遵循指定的程序。考虑到真实的数据生成过程，最可能的结果仍然是 $False$，但相比案例 A，出现伪拒绝的可能性更大。\n\n实施过程将首先使用指定的随机种子为每个案例生成收益率序列 $\\{r_t\\}$ 以确保可复现性。然后，计算波动率代理序列 $\\{v_t\\}$。最后，计算 Ljung-Box 检验统计量 $Q$，并与来自 $\\chi^2(h')$ 分布的临界值进行比较，以得出最终的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run the volatility clustering test for all specified cases.\n    \"\"\"\n\n    # Global parameters for the Ljung-Box test\n    H_LAGS = 10\n    ALPHA = 0.01\n\n    def generate_returns(case_params):\n        \"\"\"\n        Generates the return series {r_t} based on the parameters for each case.\n        \"\"\"\n        case_id = case_params['id']\n        n = case_params['n']\n        seed = case_params['seed']\n        rng = np.random.default_rng(seed=seed)\n        \n        if case_id == 'A' or case_id == 'E':\n            sigma = case_params['sigma']\n            epsilon = rng.normal(size=n)\n            r = sigma * epsilon\n        \n        elif case_id == 'B':\n            sigma_l = case_params['sigma_L']\n            sigma_h = case_params['sigma_H']\n            block_length = case_params['block_length']\n            \n            epsilon = rng.normal(size=n)\n            sigma_t = np.zeros(n)\n            num_blocks = int(np.ceil(n / block_length))\n\n            for i in range(num_blocks):\n                start_idx = i * block_length\n                end_idx = min((i + 1) * block_length, n)\n                if i % 2 == 0:\n                    sigma_t[start_idx:end_idx] = sigma_l\n                else:\n                    sigma_t[start_idx:end_idx] = sigma_h\n            \n            r = sigma_t * epsilon\n\n        elif case_id == 'C':\n            omega = case_params['omega']\n            alpha_p = case_params['alpha']\n            beta_p = case_params['beta']\n\n            epsilon = rng.normal(size=n)\n            r = np.zeros(n)\n            sigma_sq = np.zeros(n)\n            \n            # Initial variance is the unconditional variance\n            sigma_sq_0 = omega / (1.0 - alpha_p - beta_p)\n            \n            # Initialize lagged terms\n            # r_{t-1}^2 is commonly initialized with unconditional variance\n            r_sq_lagged = sigma_sq_0\n            sigma_sq_lagged = sigma_sq_0\n\n            for t in range(n):\n                sigma_sq[t] = omega + alpha_p * r_sq_lagged + beta_p * sigma_sq_lagged\n                if sigma_sq[t] < 0: # Ensure non-negative variance\n                    sigma_sq[t] = 0\n                r[t] = np.sqrt(sigma_sq[t]) * epsilon[t]\n                \n                # Update lagged terms for the next iteration\n                r_sq_lagged = r[t]**2\n                sigma_sq_lagged = sigma_sq[t]\n\n        elif case_id == 'D':\n            r = np.zeros(n)\n\n        else:\n            raise ValueError(f\"Unknown case_id: {case_id}\")\n            \n        return r\n\n    def ljung_box_test(r_series, h, alpha):\n        \"\"\"\n        Performs the Ljung-Box test for volatility clustering.\n        \"\"\"\n        n = len(r_series)\n        v = r_series**2\n        \n        v_mean = np.mean(v)\n        v_centered = v - v_mean\n        v_variance_sum = np.sum(v_centered**2)\n\n        # Failsafe for zero variance as per problem statement\n        if np.isclose(v_variance_sum, 0.0):\n            return False\n\n        h_prime = min(h, n - 1)\n\n        # Failsafe for very short series\n        if h_prime == 0:\n            return False\n\n        rho_sq_terms = []\n        for k in range(1, h_prime + 1):\n            # Numerator of rho_k\n            autocov_k = np.sum(v_centered[k:] * v_centered[:-k])\n            rho_k = autocov_k / v_variance_sum\n            rho_sq_terms.append(rho_k**2 / (n - k))\n        \n        q_statistic = n * (n + 2) * np.sum(rho_sq_terms)\n        \n        # Degrees of freedom for the chi-square distribution is h'\n        degrees_of_freedom = h_prime\n        \n        # Critical value from chi-square distribution\n        critical_value = chi2.ppf(1 - alpha, df=degrees_of_freedom)\n        \n        return q_statistic > critical_value\n\n    test_cases = [\n        {'id': 'A', 'n': 2000, 'sigma': 1.0, 'seed': 12345},\n        {'id': 'B', 'n': 2000, 'sigma_L': 1.0, 'sigma_H': 3.0, 'block_length': 100, 'seed': 24680},\n        {'id': 'C', 'n': 2000, 'omega': 0.05, 'alpha': 0.35, 'beta': 0.60, 'seed': 98765},\n        {'id': 'D', 'n': 200, 'seed': None}, # Seed is irrelevant for zero returns\n        {'id': 'E', 'n': 12, 'sigma': 1.0, 'seed': 54321},\n    ]\n\n    results = []\n    for case in test_cases:\n        r_t = generate_returns(case)\n        is_clustered = ljung_box_test(r_t, H_LAGS, ALPHA)\n        results.append(is_clustered)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"}]}