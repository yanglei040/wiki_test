{"hands_on_practices": [{"introduction": "这个练习将引导你亲手实现自助法最常见的应用之一：为中位数等统计量估计置信区间。当一个统计量的抽样分布没有简单的解析公式时（例如中位数），自助法便显示出其强大的威力。通过这个实践，你将掌握构建自助法百分位区间的核心算法，并将其应用于一个金融场景。[@problem_id:2377547]", "id": "2377547", "problem": "考虑一个风险投资交易层面的简单回报率数据集，对于每笔交易 $i$ 其回报率定义为 $r_i = \\dfrac{\\text{cash\\_out}_i - \\text{cash\\_in}_i}{\\text{cash\\_in}_i}$，因此 $r_i \\in [-1, +\\infty)$。假设观测到的回报率是来自某个未知分布的实现值，并且数据是独立同分布（IID）的。设多重集 $x_1, x_2, \\ldots, x_n$ 的样本中位数定义为：当 $n$ 为奇数时，为中间的次序统计量；当 $n$ 为偶数时，为中间两个次序统计量的平均值。\n\n您的任务是为下面的每个测试用例计算总体中位数的双侧置信区间，该计算基于自助法（bootstrap）百分位数区间的下列定义。令 $T$ 表示样本中位数泛函。对于给定的数据集 $D = [x_1, x_2, \\ldots, x_n]$，定义经验分布 $\\hat{F}_n$，它在每个观测值上赋予 $1/n$ 的概率质量（计算多重性）。对于给定的整数 $B \\ge 1$，从 $\\hat{F}_n$ 中抽取 $B$ 个大小为 $n$ 的独立同分布自助重抽样样本（从多重集 $D$ 中有放回地抽样）。对于每个重抽样样本 $b \\in \\{1, 2, \\ldots, B\\}$，计算 $T_b = T(D^{\\ast}_b)$，即第 $b$ 个重抽样样本的样本中位数。令 $T_{(1)} \\le T_{(2)} \\le \\cdots \\le T_{(B)}$ 为排序后的值。对于名义双侧置信水平 $1 - \\alpha \\in (0,1)$，将下端点定义为经验 $p$-分位数（其中 $p = \\alpha/2$），上端点定义为经验 $q$-分位数（其中 $q = 1 - \\alpha/2$），其中对于任意概率水平 $u \\in [0,1]$，经验分位数 $Q(u)$ 通过对排序后的索引进行线性插值来定义：\n- 令 $k = 1 + (B - 1)u$。\n- 若 $k \\le 1$，则设 $Q(u) = T_{(1)}$；若 $k \\ge B$，则设 $Q(u) = T_{(B)}$。\n- 否则，记 $k = m + \\delta$，其中 $m = \\lfloor k \\rfloor$ 且 $\\delta \\in (0,1)$，并设 $Q(u) = (1 - \\delta) T_{(m)} + \\delta T_{(m+1)}$。\n\n为保证可复现性，在抽取 $B$ 个自助重抽样样本之前，请为每个测试用例使用指定的整数种子初始化伪随机数生成器。\n\n测试套件：\n- 用例 1：$D_1 = [-1.0, -0.8, -0.6, -0.5, -0.3, -0.1, 0.0, 0.2, 0.25, 0.35, 0.4, 0.5, 0.6, 0.9, 1.2, 1.5, 2.0, 3.0, 5.0]$，$B_1 = 20000$，$\\alpha_1 = 0.10$，种子 $S_1 = 202311$。\n- 用例 2：$D_2 = [-1.0, -0.9, -0.9, -0.5, -0.2, -0.1, 0.0, 0.05]$，$B_2 = 15000$，$\\alpha_2 = 0.20$，种子 $S_2 = 7$。\n- 用例 3：$D_3 = [-1.0, -1.0, -0.5, -0.5, 0.0, 0.0, 0.4, 0.4, 0.4, 1.0, 1.0, 2.5]$，$B_3 = 30000$，$\\alpha_3 = 0.05$，种子 $S_3 = 12345$。\n- 用例 4：$D_4 = [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]$，$B_4 = 10000$，$\\alpha_4 = 0.10$，种子 $S_4 = 99$。\n\n您的程序必须为每个用例计算如上定义的数对 $[\\ell, u] = [Q(\\alpha/2), Q(1 - \\alpha/2)]$。每个界限值必须报告为小数点后保留六位的小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个用例的结果，格式为一个逗号分隔的列表，并用方括号括起来，其中每个用例是一个包含两个元素的列表 $[\\ell, u]$。例如：$[[\\ell_1,u_1],[\\ell_2,u_2],[\\ell_3,u_3],[\\ell_4,u_4]]$，每个数值都四舍五入到小数点后六位。", "solution": "问题陈述已经过分析，并被认为是有效的。该问题具有科学依据、提法明确、客观，并为解决一个标准的计算统计学问题提供了一套完整且一致的给定条件。任务是根据给定的若干数据集和参数，计算总体中位数的自助法百分位数置信区间。\n\n需要实现的方法是自助法百分位数区间。这是一种非参数统计技术，用于估计统计量的抽样分布，并从而构建置信区间，而无需对潜在的总体分布做出强假设。自助法的基本原理是使用观测样本 $D = \\{x_1, x_2, \\ldots, x_n\\}$ 的经验分布函数 $\\hat{F}_n$ 作为对真实、未知的总体分布 $F$ 的近似。在 $\\hat{F}_n$ 中，每个观测数据点 $x_i$ 被赋予 $1/n$ 的概率质量。\n\n该算法按以下步骤进行：\n1.\n对于一个大小为 $n$ 的给定数据集 $D$，我们抽取大量的（$B$ 个）自助重抽样样本。每个重抽样样本（表示为 $D^{\\ast}_b$，其中 $b \\in \\{1, 2, \\ldots, B\\}$）的大小为 $n$，是通过从原始数据集 $D$ 中进行有放回抽样获得的。这个过程是从经验分布 $\\hat{F}_n$ 中抽取独立同分布样本的计算实现。\n\n2.\n对于每个自助重抽样样本 $D^{\\ast}_b$，我们计算感兴趣的统计量。在本问题中，该统计量是样本中位数，表示为 $T$。令 $T_b = T(D^{\\ast}_b)$ 为第 $b$ 个重抽样样本的样本中位数。样本中位数的定义是：对于奇数大小的样本，它是中间的次序统计量；对于偶数大小的样本，它是中间两个次序统计量的算术平均值。\n\n3.\n这 $B$ 个自助统计量的集合 $\\{T_1, T_2, \\ldots, T_B\\}$，可作为样本中位数 $T$ 的抽样分布的经验近似。\n\n4.\n为了构建名义置信水平为 $1-\\alpha$ 的双侧置信区间，我们使用百分位数法。这涉及找到排序后的自助统计量 $T_{(1)} \\le T_{(2)} \\le \\cdots \\le T_{(B)}$ 的适当分位数。置信区间的下界 $\\ell$ 是该分布的经验 $(\\alpha/2)$-分位数，上界 $u$ 是经验 $(1 - \\alpha/2)$-分位数。\n\n5.\n问题为计算任意概率水平 $u \\in [0,1]$ 的经验分位数 $Q(u)$ 提供了精确的定义。它使用次序统计量之间的线性插值。该过程涉及计算一个索引 $k = 1 + (B - 1)u$，并且如果 $1 < k < B$，则在值 $T_{(\\lfloor k \\rfloor)}$ 和 $T_{(\\lfloor k \\rfloor + 1)}$ 之间进行插值。这个特定规则对应于计算分位数的标准线性插值方法，例如在 `numpy.quantile` 函数中通过 `interpolation='linear'` 选项实现。使用此特定函数可确保遵循问题定义。\n\n6.\n为保证科学可复现性，用于重抽样的伪随机数生成器必须在每个测试用例中用特定的种子进行初始化。这确保了自助重抽样样本的序列是确定性的，并且结果可以被独立验证。\n\n接下来的实现将为提供的四个测试用例中的每一个执行此算法，计算指定的置信区间界限，并按要求将它们四舍五入到小数点后六位。对于特殊情况，如用例 4 中原始样本中的所有数据点都相同，任何自助重抽样样本也将由相同的值组成。因此，每个自助重抽样样本的中位数都将是这个相同的值，最终的置信区间将收缩为一个单点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required or permitted.\n\ndef solve():\n    \"\"\"\n    Computes bootstrap percentile confidence intervals for the median for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            'D': [-1.0, -0.8, -0.6, -0.5, -0.3, -0.1, 0.0, 0.2, 0.25, 0.35, 0.4, 0.5, 0.6, 0.9, 1.2, 1.5, 2.0, 3.0, 5.0],\n            'B': 20000,\n            'alpha': 0.10,\n            'seed': 202311\n        },\n        # Case 2\n        {\n            'D': [-1.0, -0.9, -0.9, -0.5, -0.2, -0.1, 0.0, 0.05],\n            'B': 15000,\n            'alpha': 0.20,\n            'seed': 7\n        },\n        # Case 3\n        {\n            'D': [-1.0, -1.0, -0.5, -0.5, 0.0, 0.0, 0.4, 0.4, 0.4, 1.0, 1.0, 2.5],\n            'B': 30000,\n            'alpha': 0.05,\n            'seed': 12345\n        },\n        # Case 4\n        {\n            'D': [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],\n            'B': 10000,\n            'alpha': 0.10,\n            'seed': 99\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case.\n        D = np.array(case['D'])\n        B = case['B']\n        alpha = case['alpha']\n        seed = case['seed']\n        n = len(D)\n\n        # 1. Initialize the pseudo-random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # 2. Generate B bootstrap resamples and compute the median for each.\n        # Pre-allocate array for efficiency.\n        bootstrap_medians = np.zeros(B)\n        for i in range(B):\n            # Draw a bootstrap resample of size n with replacement.\n            resample = rng.choice(D, size=n, replace=True)\n            # Compute the median of the resample.\n            bootstrap_medians[i] = np.median(resample)\n\n        # 3. Sort the bootstrap medians to prepare for quantile calculation.\n        bootstrap_medians.sort()\n\n        # 4. Compute the lower and upper quantiles for the confidence interval.\n        # The problem's quantile definition matches numpy's 'linear' interpolation.\n        p_lower = alpha / 2.0\n        p_upper = 1.0 - alpha / 2.0\n\n        lower_bound = np.quantile(bootstrap_medians, p_lower, interpolation='linear')\n        upper_bound = np.quantile(bootstrap_medians, p_upper, interpolation='linear')\n\n        # 5. Round the results to six decimal places as required by the problem.\n        l_rounded = round(lower_bound, 6)\n        u_rounded = round(upper_bound, 6)\n        \n        results.append([l_rounded, u_rounded])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with numeric values rounded to 6 decimal places.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```"}, {"introduction": "自助法虽然功能强大，但并非万能灵药，其应用依赖于关键假设。这个思想实验旨在探讨其中一个核心假设——数据是独立同分布的（i.i.d.）。通过分析一个常见的自回归 $\\text{AR}(1)$ 模型，你将理解为什么将标准的独立同分布自助法直接应用于具有序列相关性的数据会得出错误的结论，这对于在金融等领域正确使用该方法至关重要。[@problem_id:2377555]", "id": "2377555", "problem": "您观察到一个单变量时间序列 $\\{y_t\\}_{t=0}^{T}$，它由1阶自回归模型 $\\text{AR}(1)$ 生成，具体如下：\n$$\ny_t = \\beta\\, y_{t-1} + \\epsilon_t,\\quad t=1,\\dots,T,\n$$\n其中 $|\\beta|<1$，$\\{\\epsilon_t\\}$ 是独立同分布 (i.i.d.) 的，满足 $\\mathbb{E}[\\epsilon_t]=0$，$\\mathbb{V}\\mathrm{ar}(\\epsilon_t)=\\sigma^2 \\in (0,\\infty)$，且具有有限的四阶矩。您通过将 $y_t$ 对 $y_{t-1}$ 进行回归，使用普通最小二乘法 (OLS) 来估计 $\\beta$。一位同事提出了一个“标准非参数i.i.d.自助法”，过程如下：从 $\\{y_1,\\dots,y_T\\}$ 中有放回地抽样，生成一个自助序列 $\\{y_t^{\\ast}\\}_{t=1}^{T}$，然后通过将 $y_t^{\\ast}$ 对 $y_{t-1}^{\\ast}$ 进行回归，计算出自助估计量 $\\hat{\\beta}^{\\ast}$。该同事计划使用 $\\hat{\\beta}^{\\ast}$ 的经验分布来构建 $\\beta$ 的置信区间。\n\n哪个选项最能解释为什么这个自助法程序未能为 $\\beta$ 提供渐近有效的推断？\n\nA. 对 $\\{y_t\\}$ 的i.i.d.重抽样破坏了序列相关性和递归关系 $y_t=\\beta y_{t-1}+\\epsilon_t$，因此自助法世界没有复制决定OLS估计量抽样分布的联合依赖结构；故而该自助法近似是不相合的。\n\nB. 失败的原因仅仅是因为 $\\{\\epsilon_t\\}$ 需要是高斯分布的；如果 $\\epsilon_t\\sim \\mathcal{N}(0,\\sigma^2)$，则i.i.d.自助法对于 $\\hat{\\beta}$ 将是精确的。\n\nC. 在 $\\text{AR}(1)$ 模型中，$\\beta$ 的OLS估计量是超相合的，因此没有自助法可以近似其抽样分布。\n\nD. 该程序在非常小的样本中可能不准确，但对于大的 $T$，i.i.d.自助法会变得有效，因为依赖性变得可以忽略，并且打乱顺序的序列近似了原始过程。", "solution": "对问题陈述进行验证。\n\n步骤1：提取已知条件\n-   观察数据是单变量时间序列 $\\{y_t\\}_{t=0}^{T}$。\n-   数据生成过程 (DGP) 是1阶自回归模型 $\\text{AR}(1)$：$y_t = \\beta\\, y_{t-1} + \\epsilon_t$，其中 $t=1,\\dots,T$。\n-   参数 $\\beta$ 受 $|\\beta|<1$ 约束，这确保了过程是平稳的。\n-   误差项 $\\{\\epsilon_t\\}$ 是独立同分布 (i.i.d.) 的，满足 $\\mathbb{E}[\\epsilon_t]=0$，$\\mathbb{V}\\mathrm{ar}(\\epsilon_t)=\\sigma^2 \\in (0,\\infty)$，且具有有限的四阶矩。\n-   参数 $\\beta$ 通过将 $y_t$ 对 $y_{t-1}$ 进行回归，使用普通最小二乘法 (OLS) 估计量 $\\hat{\\beta}$ 来估计。\n-   一个被提出的自助法程序被描述为“标准非参数i.i.d.自助法”：\n    1.  通过从观察数据 $\\{y_1,\\dots,y_T\\}$ 中有放回地抽样，生成一个自助序列 $\\{y_t^{\\ast}\\}_{t=1}^{T}$。\n    2.  通过将 $y_t^{\\ast}$ 对 $y_{t-1}^{\\ast}$ 进行回归，计算出自助估计量 $\\hat{\\beta}^{\\ast}$。\n    3.  $\\hat{\\beta}^{\\ast}$ 的经验分布将被用于构建 $\\beta$ 的置信区间。\n-   问题询问该自助法程序为何未能为 $\\beta$ 提供渐近有效的推断。\n\n步骤2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题涉及时间序列计量经济学中的标准概念：$\\text{AR}(1)$ 模型、OLS估计和自助法重抽样。该模型及其性质是该领域的基础。问题关乎统计方法的正确应用。设定在科学上是合理的。\n-   **提法恰当：** 问题陈述清晰。它指明了模型、估计量以及所提出的推断程序，并要求对该程序为何无效进行具体诊断。在针对相关数据的自助法理论中，存在一个唯一且正确的解释。\n-   **客观性：** 问题以客观、技术性的语言表述，没有歧义或主观内容。\n-   **自洽且一致：** 提供了所有必要信息。给出了平稳性条件 $|\\beta|<1$，并且误差项的性质是渐近分析的标准。没有矛盾之处。\n\n步骤3：结论与行动\n问题陈述有效。这是一个在计量经济学中提法良好的问题。我将继续进行完整的推导和选项分析。\n\n自助法的核心原则是，自助法数据生成过程必须模仿真实数据生成过程。估计量的抽样分布由样本数据的联合概率分布决定。为了使一个自助法程序有效，自助样本与原始样本之间的关系必须复制原始样本与真实总体或过程之间的关系。\n\n真实数据生成过程是一个 $\\text{AR}(1)$ 模型：\n$$\ny_t = \\beta y_{t-1} + \\epsilon_t\n$$\n这个方程定义了序列 $\\{y_t\\}$ 的时间依赖结构。$y_t$ 的值直接且因果地依赖于其紧邻的前一个值 $y_{t-1}$。这种序列相关性是该过程的定义性特征。$\\beta$ 的OLS估计量是\n$$\n\\hat{\\beta} = \\frac{\\sum_{t=1}^T y_t y_{t-1}}{\\sum_{t=1}^T y_{t-1}^2}\n$$\n$\\hat{\\beta}$ 的抽样分布（具体来说，是 $\\sqrt{T}(\\hat{\\beta} - \\beta)$ 的分布）是这种序列相关性的结果。\n\n现在，考虑所提出的自助法程序。它通过从原始观测值 $\\{y_1, \\dots, y_T\\}$ 中有放回地抽样来创建一个自助样本 $\\{y_t^{\\ast}\\}_{t=1}^T$。这是为i.i.d.数据设计的标准非参数自助法。这种重抽样方案的关键后果是原始数据的时间顺序被破坏了。在自助样本中，$y_t^{\\ast}$ 的值是从 $\\{y_1, \\dots, y_T\\}$ 中的一个随机抽取，而 $y_{t-1}^{\\ast}$ 的值是来自同一集合的另一次独立的随机抽取。因此，在 $y_t^{\\ast}$ 和 $y_{t-1}^{\\ast}$ 之间没有类似于原始 $\\text{AR}(1)$ 结构的系统性关系。\n\n在自助法世界中，数据对 $(y_t^{\\ast}, y_{t-1}^{\\ast})$ 由从原始数据的经验分布函数中进行的两次独立抽取组成。两个这样的独立变量之间的“真实”回归系数为零（假设 $\\mathbb{E}[y_t]=0$）。因此，自助估计量\n$$\n\\hat{\\beta}^{\\ast} = \\frac{\\sum_{t=1}^T y_t^{\\ast} y_{t-1}^{\\ast}}{\\sum_{t=1}^T (y_{t-1}^{\\ast})^2}\n$$\n不会收敛到一个与 $\\beta$ 相关的量。相反，它的分布将以 $0$ 为中心。由于 $\\hat{\\beta}^{\\ast}$ 的分布不能近似 $\\hat{\\beta}$ 的分布，该自助法程序是不相合的，并且未能提供有效的推断。\n\n用于自回归模型的正确自助法程序，如残差自助法或移动块自助法，是专门为保持时间序列的依赖结构而设计的。所提出的i.i.d.自助法失败的原因恰恰是它忽略了这种结构。\n\n现在，我们来评估每个选项：\n\nA. 对 $\\{y_t\\}$ 的i.i.d.重抽样破坏了序列相关性和递归关系 $y_t=\\beta y_{t-1}+\\epsilon_t$，因此自助法世界没有复制决定OLS估计量抽样分布的联合依赖结构；故而该自助法近似是不相合的。\n该陈述准确地诊断了根本性缺陷。自助法的有效性取决于能否复制DGP的性质。对于时间序列，这包括依赖结构。i.i.d.重抽样方案将数据视为独立的，而实际上它们并非独立，从而破坏了模型旨在捕捉的核心结构。这导致了不相合的自助法。\n**结论：正确。**\n\nB. 失败的原因仅仅是因为 $\\{\\epsilon_t\\}$ 需要是高斯分布的；如果 $\\epsilon_t\\sim \\mathcal{N}(0,\\sigma^2)$，则i.i.d.自助法对于 $\\hat{\\beta}$ 将是精确的。\n这是不正确的。失败是由于破坏了依赖结构，这个问题与误差项 $\\{\\epsilon_t\\}$ 的分布形式无关。假设高斯误差并不能纠正i.i.d.重抽样 $\\{y_t\\}$ 破坏了自回归动态这一事实。无论误差是高斯分布还是遵循其他某种分布，问题都依然存在。\n**结论：不正确。**\n\nC. 在 $\\text{AR}(1)$ 模型中，$\\beta$ 的OLS估计量是超相合的，因此没有自助法可以近似其抽样分布。\n这个陈述在两方面是事实不正确的。首先，对于一个平稳的 $\\text{AR}(1)$ 过程，其中 $|\\beta|<1$，OLS估计量 $\\hat{\\beta}$ 是 $\\sqrt{T}$-相合的，而不是超相合的。超相合性（以 $T$ 的速率收敛）发生在单位根情况，即 $\\beta=1$ 时。问题明确说明了 $|\\beta|<1$。其次，“没有自助法可以近似”一个超相合估计量的分布这种说法过于绝对，并且通常是错误的；可以为这种情况设计专门的自助法。\n**结论：不正确。**\n\nD. 该程序在非常小的样本中可能不准确，但对于大的 $T$，i.i.d.自助法会变得有效，因为依赖性变得可以忽略，并且打乱顺序的序列近似了原始过程。\n这与事实恰好相反。这个自助法程序的失败是渐近的。随着样本量 $T$ 的增长，不相合性变得更明显，而不是更不明显。自助估计量 $\\hat{\\beta}^{\\ast}$ 的分布将收敛到一个以 $0$ 或接近 $0$ 为中心的分布，而实际估计量 $\\hat{\\beta}$ 的抽样分布则以真实参数 $\\beta$ 为中心。在 $\\beta \\neq 0$ 的平稳 $\\text{AR}(1)$ 过程中，依赖性是一个定义性特征，并不会随着 $T$ 的增加而变得可以忽略。打乱序列顺序恰恰是绝对不能做的。\n**结论：不正确。**\n\n对于所提出的自助法程序失败的唯一正确和精确的解释由选项A提供。", "answer": "$$\\boxed{A}$$"}, {"introduction": "在实践中，一个常见的问题是：“需要多少次自助抽样才足够？”。自助法本身是一个蒙特卡洛模拟过程，其结果会因随机抽样而存在变异。本练习将超越单次自助法分析，通过量化自助法重复次数 $B$ 如何影响置信区间端点的稳定性，帮助你直观地理解计算成本与自助法估计精度之间的权衡。[@problem_id:2377512]", "id": "2377512", "problem": "考虑单一资产的独立同分布 (i.i.d.) 每日对数回报率。设一个已实现样本记为 $\\{X_i\\}_{i=1}^n$。定义样本均值 $\\hat{\\mu} = \\frac{1}{n}\\sum_{i=1}^n X_i$。对于给定的自助法 (bootstrap) 重复次数 $B$，通过从已实现样本中有放回地重复抽取 $n$ 个观测值，并为每个重抽样样本计算均值，来定义 $\\hat{\\mu}$ 的自助法抽样分布。置信水平为 $0.95$ 的双侧置信区间由 $\\hat{\\mu}$ 的自助法分布在水平 $0.025$ 和 $0.975$ 处的经验分位数定义，使用顺序统计量之间的线性插值。将这些端点记为 $L(B)$（下限）和 $U(B)$（上限）。\n\n为量化端点相对于 $B$ 的稳定性，考虑对整个自助法过程进行 $\\mathcal{R}$ 次独立重复，每次重复使用相同的已实现样本，但使用不同的随机种子；将第 $j \\in \\{1,\\dots,\\mathcal{R}\\}$ 次重复中的端点标记为 $\\ell_j(B)$ 和 $u_j(B)$。将稳定性度量定义为总体标准差\n$$\ns_\\ell(B) = \\left(\\frac{1}{\\mathcal{R}}\\sum_{j=1}^{\\mathcal{R}}\\left(\\ell_j(B) - \\bar{\\ell}(B)\\right)^2\\right)^{1/2},\\quad\n\\bar{\\ell}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=1}^{\\mathcal{R}} \\ell_j(B),\n$$\n和\n$$\ns_u(B) = \\left(\\frac{1}{\\mathcal{R}}\\sum_{j=1}^{\\mathcal{R}}\\left(u_j(B) - \\bar{u}(B)\\right)^2\\right)^{1/2},\\quad\n\\bar{u}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=1}^{\\mathcal{R}} u_j(B).\n$$\n\n为保证可复现性，每个测试用例的已实现样本必须如下文规定合成生成，并且在该测试用例的所有 $\\mathcal{R}$ 次重复中保持不变地重复使用。在每次重复 $j \\in \\{0,1,\\dots,\\mathcal{R}-1\\}$ 中，自助法过程必须使用一个伪随机种子，其值等于给定的基础种子加上 $j$。生成已实现样本时，需严格使用提供的样本种子。所有伪随机数生成必须基于一个现代伪随机数生成器并使用给定的整数种子。\n\n回报模型：\n- 高斯回报：$X_i \\sim \\mathcal{N}(\\mu,\\sigma^2)$。\n- 厚尾回报：$X_i = \\mu + \\sigma \\sqrt{\\frac{\\nu - 2}{\\nu}}\\, T_{\\nu}$，其中 $T_{\\nu}$ 服从自由度为 $\\nu > 2$、单位尺度的 Student’s $t$ 分布，使得 $\\mathrm{Var}(X_i)$ 等于 $\\sigma^2$。\n\n关注的统计量：\n- 参数是平均回报 $\\mu$，统计量是样本均值 $\\hat{\\mu}$。\n\n置信区间：\n- 端点是 $\\hat{\\mu}$ 的自助法分布在水平 $0.025$ 和 $0.975$ 处的经验分位数，采用顺序统计量之间的线性插值。\n\n稳定性度量：\n- 报告每个测试用例中如上定义的 $s_\\ell(B)$ 和 $s_u(B)$，四舍五入至 $6$ 位小数。\n\n测试套件：\n对于每个测试用例，参数列表为 $(\\text{dist}, n, \\mu, \\sigma, \\nu, B, \\mathcal{R}, \\text{sample\\_seed}, \\text{bootstrap\\_base\\_seed})$；当 $\\text{dist}=\\text{N}$ 时，不使用条目 $\\nu$。\n1. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 25,\\, 32,\\, 20231101,\\, 770000)$。\n2. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 200,\\, 32,\\, 20231101,\\, 770100)$。\n3. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 1000,\\, 32,\\, 20231101,\\, 770200)$。\n4. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 2000,\\, 32,\\, 20231101,\\, 770300)$。\n5. $(\\text{N},\\, 30,\\, 0.0005,\\, 0.01,\\, -,\\, 200,\\, 32,\\, 20231111,\\, 880100)$。\n6. $(\\text{T},\\, 252,\\, 0.0005,\\, 0.02,\\, 3,\\, 1000,\\, 32,\\, 20231221,\\, 990100)$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素都是一个双元素列表 $[s_\\ell(B), s_u(B)]$，与测试用例的顺序相同，每个值四舍五入到 $6$ 位小数。例如，三个用例的有效输出应如下所示：$[[0.001234,0.001987],[0.000456,0.000765],[0.000123,0.000321]]$。\n\n不涉及物理单位。所有数值结果必须是浮点数。", "solution": "该问题提出了一个计算统计学中有效且定义明确的任务，具体涉及自助法置信区间稳定性的分析。我将提供一个系统的解决方案。\n\n问题的核心是量化自助法置信区间端点的变异性。这种变异性源于自助法过程本身是一个依赖于随机种子的随机过程。通过使用不同的种子多次重复整个自助法过程，我们可以观察区间端点的分布并衡量其稳定性，而标准差是衡量稳定性的一个自然度量。\n\n每个测试用例的总体流程如下：\n1.  合成生成一个大小为 $n$ 的资产对数回报率的已实现样本 $\\{X_i\\}_{i=1}^n$。该样本使用指定的 `sample_seed` 生成一次，并且在给定测试用例的后续所有步骤中保持不变。\n2.  对自助法置信区间估计执行 $\\mathcal{R}$ 次独立重复。对于每次重复 $j \\in \\{0, 1, \\dots, \\mathcal{R}-1\\}$：\n    a.  将伪随机数生成器 (PRNG) 的种子设置为 `bootstrap_base_seed` $+ j$。这确保了 $\\mathcal{R}$ 次重复中的每一次在统计上是独立的，但在计算上是可复现的。\n    b.  生成 $B$ 个自助法样本。每个自助法样本通过从原始已实现样本 $\\{X_i\\}_{i=1}^n$ 中有放回地抽取 $n$ 个观测值来创建。\n    c.  对于 $B$ 个自助法样本中的每一个，计算其样本均值。这 $B$ 个均值的集合构成了统计量 $\\hat{\\mu}$ 的经验自助法分布。\n    d.  从这个经验分布中，确定双侧 $95\\%$ 置信区间。问题指定下限和上限端点，记为 $\\ell_j(B)$ 和 $u_j(B)$，分别是水平 $q_{low} = 0.025$ 和 $q_{high} = 0.975$ 处的经验分位数。如果分位数落在有序数据点之间，则使用线性插值来估计。\n3.  完成所有 $\\mathcal{R}$ 次重复后，我们将得到两组数据：$\\{\\ell_j(B)\\}_{j=0}^{\\mathcal{R}-1}$ 和 $\\{u_j(B)\\}_{j=0}^{\\mathcal{R}-1}$。\n4.  最后，计算这些端点的稳定性。问题将稳定性度量定义为这两组端点的总体标准差。将下限端点的集合设为 $\\boldsymbol{\\ell} = (\\ell_0(B), \\dots, \\ell_{\\mathcal{R}-1}(B))$，上限端点的集合设为 $\\boldsymbol{u} = (u_0(B), \\dots, u_{\\mathcal{R}-1}(B))$。均值为 $\\bar{\\ell}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1} \\ell_j(B)$ 和 $\\bar{u}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1} u_j(B)$。稳定性度量则为：\n$$\ns_\\ell(B) = \\sqrt{\\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1}\\left(\\ell_j(B) - \\bar{\\ell}(B)\\right)^2}\n$$\n$$\ns_u(B) = \\sqrt{\\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1}\\left(u_j(B) - \\bar{u}(B)\\right)^2}\n$$\n这对应于使用除数 $\\mathcal{R}$（而非 $\\mathcal{R}-1$）进行标准差计算。\n\n已实现样本的生成取决于指定的分布。\n- 对于高斯回报，$X_i \\sim \\mathcal{N}(\\mu, \\sigma^2)$，我们从均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布中抽样。\n- 对于厚尾回报，$X_i = \\mu + \\sigma \\sqrt{\\frac{\\nu - 2}{\\nu}}\\, T_{\\nu}$，其中 $T_{\\nu}$ 服从自由度为 $\\nu$ 的标准 Student's t 分布。选择此公式是为了在 $\\nu > 2$ 的条件下，使得 $\\mathrm{E}[X_i] = \\mu$ 且 $\\mathrm{Var}(X_i) = \\sigma^2$。\n\n在计算上，实现将遵循这些步骤。为了确保指定的可复现性，将使用一个现代伪随机数生成器，具体为 `numpy.random.PCG64`，进行所有随机数生成。带有线性插值的分位数计算由 `numpy.quantile` 以其默认的 `method='linear'` 方法处理。总体标准差使用 `numpy.std` 并在 `ddof=0` 的设置下计算。整个过程被封装在一个函数中，该函数遍历提供的测试套件，为每个用例计算配对 $(s_\\ell(B), s_u(B))$，并根据严格要求格式化输出。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import t\n\ndef compute_stability_for_case(dist, n, mu, sigma, nu, B, R, sample_seed, bootstrap_base_seed):\n    \"\"\"\n    Computes the stability of bootstrap confidence interval endpoints for a single test case.\n\n    Args:\n        dist (str): Distribution type ('N' for Gaussian, 'T' for Student's-t).\n        n (int): Size of the realized sample.\n        mu (float): Mean of the return distribution.\n        sigma (float): Standard deviation of the return distribution.\n        nu (int): Degrees of freedom for the Student's-t distribution.\n        B (int): Number of bootstrap replications.\n        R (int): Number of independent repetitions of the bootstrap procedure.\n        sample_seed (int): Seed for generating the realized sample.\n        bootstrap_base_seed (int): Base seed for the bootstrap procedure repetitions.\n\n    Returns:\n        list: A list containing [s_l, s_u], the stability measures for the lower and upper\n              confidence interval endpoints, rounded to 6 decimals.\n    \"\"\"\n    # Step 1: Generate the realized sample\n    rng_sample = np.random.Generator(np.random.PCG64(sample_seed))\n    \n    if dist == 'N':\n        realized_sample = rng_sample.normal(loc=mu, scale=sigma, size=n)\n    elif dist == 'T':\n        # Generate standard Student's t-distributed random variables\n        t_samples = t.rvs(df=nu, size=n, random_state=rng_sample)\n        # Scale to match mean mu and variance sigma^2\n        scaling_factor = sigma * np.sqrt((nu - 2) / nu)\n        realized_sample = mu + scaling_factor * t_samples\n    else:\n        raise ValueError(\"Invalid distribution type specified.\")\n\n    lower_endpoints = []\n    upper_endpoints = []\n\n    # Step 2: Outer loop for R independent repetitions\n    for j in range(R):\n        current_seed = bootstrap_base_seed + j\n        rng_bootstrap = np.random.Generator(np.random.PCG64(current_seed))\n\n        # Perform B bootstrap resamples efficiently\n        # Generate all indices for B resamples at once\n        bootstrap_indices = rng_bootstrap.choice(n, size=(B, n), replace=True)\n        \n        # Create bootstrap samples and compute their means\n        bootstrap_samples = realized_sample[bootstrap_indices]\n        bootstrap_means = bootstrap_samples.mean(axis=1)\n\n        # Step 2d: Calculate confidence interval endpoints\n        q_low, q_high = np.quantile(bootstrap_means, [0.025, 0.975])\n        \n        lower_endpoints.append(q_low)\n        upper_endpoints.append(q_high)\n\n    # Step 4: Calculate stability measures (population standard deviation)\n    s_l = np.std(lower_endpoints, ddof=0)\n    s_u = np.std(upper_endpoints, ddof=0)\n\n    return [round(s_l, 6), round(s_u, 6)]\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # (dist, n, mu, sigma, nu, B, R, sample_seed, bootstrap_base_seed)\n        ('N', 252, 0.0005, 0.01, None, 25, 32, 20231101, 770000),\n        ('N', 252, 0.0005, 0.01, None, 200, 32, 20231101, 770100),\n        ('N', 252, 0.0005, 0.01, None, 1000, 32, 20231101, 770200),\n        ('N', 252, 0.0005, 0.01, None, 2000, 32, 20231101, 770300),\n        ('N', 30, 0.0005, 0.01, None, 200, 32, 20231111, 880100),\n        ('T', 252, 0.0005, 0.02, 3, 1000, 32, 20231221, 990100),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_stability_for_case(*case)\n        results.append(result)\n\n    # Format the final output string exactly as required, without spaces after commas.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"}]}