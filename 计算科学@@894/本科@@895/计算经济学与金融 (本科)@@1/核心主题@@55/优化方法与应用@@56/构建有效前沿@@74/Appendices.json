{"hands_on_practices": [{"introduction": "有效前沿为投资者提供了一系列风险和回报的最佳组合，但这引出了一个关键问题：投资者应该选择哪一个组合？这个选择最终取决于个人的风险偏好，这在经济学中通常通过效用函数来量化。本练习将运用 Robert Merton 的经典投资组合理论，为具有特定风险厌恶系数的投资者找到其独一无二的最优投资组合，从而将有效前沿的几何概念与效用最大化的经济学原理联系起来。[@problem_id:2383572]", "id": "2383572", "problem": "一位具有恒定相对风险厌恶 (CRRA) 偏好的投资者，其关于期末财富的效用函数为 $U(W) = \\frac{W^{1-\\gamma}}{1-\\gamma}$，风险厌恶系数为 $\\gamma = 3$。该投资者在长度为 $T = 1$ 的时间范围内以连续时间方式进行操作，初始财富为 $W_{0} > 0$，并且可以投资于两种风险资产和一种无风险资产。无风险资产以连续复利率 $r = 0.02$ 增长。风险资产遵循相关的几何布朗运动 (GBM) 动态过程：\n$$\n\\frac{dS_{i}(t)}{S_{i}(t)} = \\mu_{i}\\,dt + \\sigma_{i}\\,dB_{i}(t), \\quad i \\in \\{1,2\\},\n$$\n其中 $B_{1}(t)$ 和 $B_{2}(t)$ 是标准布朗运动，瞬时相关性为 $\\rho = 0.25$。参数如下：\n- 预期收益率 $\\mu_{1} = 0.06$ 和 $\\mu_{2} = 0.09$，\n- 波动率 $\\sigma_{1} = 0.2$ 和 $\\sigma_{2} = 0.3$，\n- 相关系数 $\\rho = 0.25$，\n- 无风险利率 $r = 0.02$，\n- 风险厌恶系数 $\\gamma = 3$。\n\n投资者在 $[0,1]$ 区间内选择风险资产的恒定投资组合权重 $w = (w_{1}, w_{2})$，并将剩余部分 $1 - w_{1} - w_{2}$ 投资于无风险资产。假设没有卖空或借贷限制。\n\n确定能够最大化 $\\mathbb{E}[U(W_{1})]$ 的最优风险资产权重向量 $w^{\\star} = (w_{1}^{\\star}, w_{2}^{\\star})$。请以精确值的形式表示最终答案。无需四舍五入。", "solution": "该问题已经过验证，是一个提法明确、有科学依据的量化金融问题。这是 Merton 投资组合理论的一个标准应用。我将继续进行解答。\n\n投资者的目标是最大化期末财富的期望效用 $\\mathbb{E}[U(W_{T})]$，其效用函数为幂效用函数 (CRRA)，形式为 $U(W) = \\frac{W^{1-\\gamma}}{1-\\gamma}$，相对风险厌恶系数为 $\\gamma$。假设投资机会集是恒定的。在这个连续时间框架中，对风险资产的最优配置（用向量 $w^{\\star}$ 表示）是一个常数，由 Merton 投资组合法则给出：\n$$ w^{\\star} = \\frac{1}{\\gamma} \\Sigma^{-1} (\\mu - r \\mathbf{1}) $$\n这里，$w^{\\star}$ 是风险资产最优权重的列向量，$\\gamma$ 是风险厌恶系数，$\\Sigma$ 是风险资产收益的协方差矩阵，$\\mu$ 是风险资产的预期收益向量，$r$ 是无风险利率，$\\mathbf{1}$ 是一个维度合适且所有元素为1的列向量。\n\n问题中给出的参数是：\n- 风险厌恶系数: $\\gamma = 3$\n- 无风险利率: $r = 0.02$\n- 预期收益向量: $\\mu = \\begin{pmatrix} \\mu_{1} \\\\ \\mu_{2} \\end{pmatrix} = \\begin{pmatrix} 0.06 \\\\ 0.09 \\end{pmatrix}$\n- 波动率: $\\sigma_{1} = 0.2$, $\\sigma_{2} = 0.3$\n- 相关系数: $\\rho = 0.25$\n\n首先，我们计算超额收益向量（风险溢价）$\\mu - r \\mathbf{1}$：\n$$ \\mu - r \\mathbf{1} = \\begin{pmatrix} 0.06 - 0.02 \\\\ 0.09 - 0.02 \\end{pmatrix} = \\begin{pmatrix} 0.04 \\\\ 0.07 \\end{pmatrix} $$\n\n接下来，我们构建风险资产收益的协方差矩阵 $\\Sigma$。$\\Sigma$ 的元素为 $\\Sigma_{ij} = \\sigma_i \\sigma_j \\rho_{ij}$，其中 $\\rho_{11} = \\rho_{22} = 1$ 且 $\\rho_{12} = \\rho_{21} = \\rho = 0.25$。\n对角线元素是方差：\n$$ \\Sigma_{11} = \\sigma_{1}^{2} = (0.2)^{2} = 0.04 $$\n$$ \\Sigma_{22} = \\sigma_{2}^{2} = (0.3)^{2} = 0.09 $$\n非对角线元素是协方差：\n$$ \\Sigma_{12} = \\Sigma_{21} = \\sigma_{1} \\sigma_{2} \\rho = (0.2)(0.3)(0.25) = (0.06)(0.25) = 0.015 $$\n因此，协方差矩阵为：\n$$ \\Sigma = \\begin{pmatrix} 0.04 & 0.015 \\\\ 0.015 & 0.09 \\end{pmatrix} $$\n\n为应用该公式，我们需要 $\\Sigma$ 的逆矩阵。对于一个 $2 \\times 2$ 矩阵 $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$，其逆矩阵由 $\\frac{1}{ad-bc} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}$ 给出。\n首先，我们计算 $\\Sigma$ 的行列式：\n$$ \\det(\\Sigma) = (0.04)(0.09) - (0.015)(0.015) = 0.0036 - 0.000225 = 0.003375 $$\n那么，逆矩阵 $\\Sigma^{-1}$ 为：\n$$ \\Sigma^{-1} = \\frac{1}{0.003375} \\begin{pmatrix} 0.09 & -0.015 \\\\ -0.015 & 0.04 \\end{pmatrix} $$\n\n现在，我们将所有部分代入 Merton 公式，求最优权重向量 $w^{\\star} = \\begin{pmatrix} w_{1}^{\\star} \\\\ w_{2}^{\\star} \\end{pmatrix}$：\n$$ w^{\\star} = \\frac{1}{3} \\left( \\frac{1}{0.003375} \\begin{pmatrix} 0.09 & -0.015 \\\\ -0.015 & 0.04 \\end{pmatrix} \\right) \\begin{pmatrix} 0.04 \\\\ 0.07 \\end{pmatrix} $$\n让我们先计算乘积 $\\Sigma^{-1} (\\mu - r \\mathbf{1})$：\n$$ \\Sigma^{-1} (\\mu - r \\mathbf{1}) = \\frac{1}{0.003375} \\begin{pmatrix} (0.09)(0.04) - (0.015)(0.07) \\\\ -(0.015)(0.04) + (0.04)(0.07) \\end{pmatrix} $$\n$$ \\Sigma^{-1} (\\mu - r \\mathbf{1}) = \\frac{1}{0.003375} \\begin{pmatrix} 0.0036 - 0.00105 \\\\ -0.0006 + 0.0028 \\end{pmatrix} = \\frac{1}{0.003375} \\begin{pmatrix} 0.00255 \\\\ 0.0022 \\end{pmatrix} $$\n现在我们计入风险厌恶项 $\\frac{1}{\\gamma} = \\frac{1}{3}$：\n$$ w^{\\star} = \\frac{1}{3} \\begin{pmatrix} \\frac{0.00255}{0.003375} \\\\ \\frac{0.0022}{0.003375} \\end{pmatrix} = \\begin{pmatrix} \\frac{0.00255}{0.010125} \\\\ \\frac{0.0022}{0.010125} \\end{pmatrix} $$\n为了得到精确值，我们将它们转换为分数：\n$$ w_{1}^{\\star} = \\frac{0.00255}{0.010125} = \\frac{2550}{10125} $$\n为了简化这个分数，我们找到分子和分母的最大公约数。\n$$ \\frac{2550}{10125} = \\frac{2 \\times 3 \\times 5^{2} \\times 17}{3^{4} \\times 5^{3}} = \\frac{2 \\times 17}{3^{3} \\times 5} = \\frac{34}{27 \\times 5} = \\frac{34}{135} $$\n对于第二个权重：\n$$ w_{2}^{\\star} = \\frac{0.0022}{0.010125} = \\frac{2200}{10125} $$\n简化这个分数：\n$$ \\frac{2200}{10125} = \\frac{2^{3} \\times 5^{2} \\times 11}{3^{4} \\times 5^{3}} = \\frac{2^{3} \\times 11}{3^{4} \\times 5} = \\frac{8 \\times 11}{81 \\times 5} = \\frac{88}{405} $$\n所以，最优权重向量是 $w^{\\star} = \\begin{pmatrix} \\frac{34}{135} \\\\ \\frac{88}{405} \\end{pmatrix}$。这对应于将大约 $25.2\\%$ 的资金投资于资产1，将 $21.7\\%$ 的资金投资于资产2。剩余的部分 $1 - \\frac{34}{135} - \\frac{88}{405} = 1 - \\frac{102}{405} - \\frac{88}{405} = 1 - \\frac{190}{405} = \\frac{215}{405} = \\frac{43}{81} \\approx 53.1\\%$，投资于无风险资产。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{34}{135} & \\frac{88}{405}\n\\end{pmatrix}\n}\n$$"}, {"introduction": "在现实世界的投资组合管理中，投资者除了追求风险调整后的最高回报外，通常还面临额外的投资限制或目标。例如，基金经理可能需要控制其投资组合对整体市场波动的敏感度，即投资组合的贝塔（$β$）系数。这个动手实践要求您在一个更复杂的约束优化框架下，求解在满足全投资和目标贝塔值双重约束下的最小方差投资组合。通过编写代码解决这个问题，您将掌握使用拉格朗日乘数法处理多约束二次规划的核心技能，这是计算金融领域的一项基本能力。[@problem_id:2383619]", "id": "2383619", "problem": "编写一个完整、可运行的程序，为每个指定的测试用例，计算在满足两个等式约束条件下的最小方差投资组合：投资组合相对于市场的贝塔值等于 $1$，以及满足全投资预算约束（权重之和为 $1$）。请使用以下基本定义和事实作为您推理和算法设计的起点。\n\n- 对于 $N$ 个风险资产，其收益向量为 $R \\in \\mathbb{R}^N$，协方差矩阵为对称正定的 $\\Sigma \\in \\mathbb{R}^{N \\times N}$，市场收益为 $R_m$，则一个权重向量为 $w \\in \\mathbb{R}^N$ 的投资组合的方差为 $w^{\\top} \\Sigma w$。\n- 对于每个资产 $i$，其相对于市场的贝塔值为 $\\beta_i = \\frac{\\operatorname{Cov}(R_i, R_m)}{\\operatorname{Var}(R_m)}$。给定向量 $c \\in \\mathbb{R}^N$，其元素为 $c_i = \\operatorname{Cov}(R_i, R_m)$，以及市场方差 $\\sigma_m^2 = \\operatorname{Var}(R_m)$，则资产贝塔向量为 $\\beta = c / \\sigma_m^2$（逐元素相除）。\n- 投资组合的贝塔值为 $\\beta_p = \\beta^{\\top} w$。\n\n您的任务是为每个测试实例计算：\n- 一个投资组合权重向量 $w \\in \\mathbb{R}^N$，它在满足约束 $1^{\\top} w = 1$ 和 $\\beta^{\\top} w = 1$ 的条件下，最小化 $w^{\\top} \\Sigma w$。其中 $1$ 表示 $N$ 维全一向量。\n- 最终的投资组合方差 $w^{\\top} \\Sigma w$。\n- 实现的投资组合贝塔值 $\\beta^{\\top} w$。\n- 权重之和 $1^{\\top} w$。\n\n可行性、退化情况要求及边界案例：\n- 如果两个约束是线性无关的（即，两个列向量 $1$ 和 $\\beta$ 线性无关），则求解此双约束最小方差问题。\n- 如果两个约束是线性相关的，则存在两种子情况：\n    - 如果对于某个标量 $k$，有 $\\beta = k \\cdot 1$ 且 $k = 1$，那么贝塔约束与预算约束是相同的。在这种情况下，仅求解满足 $1^{\\top} w = 1$ 约束的最小方差投资组合。\n    - 如果对于某个标量 $k$，有 $\\beta = k \\cdot 1$ 且 $k \\neq 1$，那么方程组 $1^{\\top} w = 1$ 和 $\\beta^{\\top} w = 1$ 是不可行的。在这种情况下，为该测试用例返回一个空列表。\n\n数值细节：\n- 对于每个测试用例，返回一个列表，其中包含资产权重 $w_1, \\dots, w_N$，后跟投资组合方差 $w^{\\top} \\Sigma w$、实现的投资组合贝塔值 $\\beta^{\\top} w$ 和权重之和 $1^{\\top} w$。将报告的每个数字四舍五入到 $6$ 位小数。\n- 如果一个测试用例是不可行的（如上文定义），则为该测试用例返回一个空列表。\n- 不涉及角度。没有物理单位。所有数值量都应视为纯数。\n- 使用 $10^{-10}$ 的数值容差来评估线性相关性和可行性的一致性。\n\n在程序中实现的测试套件（每个测试用例提供 $\\Sigma$、$c$ 和 $\\sigma_m^2$；在内部计算 $\\beta = c / \\sigma_m^2$）：\n1. 标准情形，$N=3$：\n   - $\\Sigma = \\begin{bmatrix} 0.04 & 0.006 & 0.004 \\\\ 0.006 & 0.09 & 0.018 \\\\ 0.004 & 0.018 & 0.16 \\end{bmatrix}$，\n   - $c = \\begin{bmatrix} 0.02 \\\\ 0.03 \\\\ 0.04 \\end{bmatrix}$，\n   - $\\sigma_m^2 = 0.05$。\n2. 退化但可行（约束线性相关且一致），$N=3$：\n   - $\\Sigma = \\begin{bmatrix} 0.01 & 0.002 & 0.0015 \\\\ 0.002 & 0.02 & 0.003 \\\\ 0.0015 & 0.003 & 0.03 \\end{bmatrix}$，\n   - $c = \\begin{bmatrix} 0.02 \\\\ 0.02 \\\\ 0.02 \\end{bmatrix}$，\n   - $\\sigma_m^2 = 0.02$。\n3. 退化且不可行（约束线性相关但不一致），$N=3$：\n   - $\\Sigma = \\begin{bmatrix} 0.06 & 0.01 & 0.008 \\\\ 0.01 & 0.08 & 0.012 \\\\ 0.008 & 0.012 & 0.1 \\end{bmatrix}$，\n   - $c = \\begin{bmatrix} 0.03 \\\\ 0.03 \\\\ 0.03 \\end{bmatrix}$，\n   - $\\sigma_m^2 = 0.025$。\n4. 通用情形 $N=4$：\n   - $\\Sigma = \\begin{bmatrix} 0.05 & 0.01 & 0.005 & 0.004 \\\\ 0.01 & 0.07 & 0.011 & 0.006 \\\\ 0.005 & 0.011 & 0.09 & 0.012 \\\\ 0.004 & 0.006 & 0.012 & 0.11 \\end{bmatrix}$，\n   - $c = \\begin{bmatrix} 0.03 \\\\ 0.025 \\\\ 0.02 \\\\ 0.015 \\end{bmatrix}$，\n   - $\\sigma_m^2 = 0.06$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，其中每个元素是以下两者之一：\n    - 一个包含 $N+3$ 个浮点数的列表：$[w_1,\\dots,w_N,\\, w^{\\top}\\Sigma w,\\, \\beta^{\\top}w,\\, 1^{\\top}w]$，四舍五入到 $6$ 位小数，或\n    - 一个空列表（如果不可行）。\n- 例如，一个包含两个可行案例的有效整体输出结构可能如下所示：[[0.2,0.3,0.5,0.012345,1.0,1.0],[...]]。", "solution": "所提出的问题是一个带约束的二次优化任务，这是计算金融学中的一个基本问题。目标是找到投资组合的权重向量 $w \\in \\mathbb{R}^N$，以最小化由二次型 $w^{\\top} \\Sigma w$ 给出的投资组合方差，同时满足两个线性等式约束。协方差矩阵 $\\Sigma \\in \\mathbb{R}^{N \\times N}$ 被指定为对称正定的，这确保了目标函数是严格凸函数，从而拥有唯一的最小值。\n\n该优化问题可以正式表述为：\n$$\n\\begin{aligned}\n& \\underset{w}{\\text{minimize}}\n& & w^{\\top} \\Sigma w \\\\\n& \\text{subject to}\n& & \\mathbf{1}^{\\top} w = 1 \\\\\n& & & \\beta^{\\top} w = 1\n\\end{aligned}\n$$\n其中 $\\mathbf{1}$ 是 $N$ 维全一向量，$\\beta$ 是资产贝塔向量。\n\n解决此类问题的标准且严谨的方法是拉格朗日乘数法。我们构造拉格朗日函数 $L(w, \\lambda_1, \\lambda_2)$：\n$$\nL(w, \\lambda_1, \\lambda_2) = w^{\\top} \\Sigma w - \\lambda_1 (\\mathbf{1}^{\\top} w - 1) - \\lambda_2 (\\beta^{\\top} w - 1)\n$$\n这里，$\\lambda_1$ 和 $\\lambda_2$ 分别是与全投资约束和目标贝塔约束相关联的拉格朗日乘数。为求得最优的 $w$，我们通过将 $L$ 对 $w$、$\\lambda_1$ 和 $\\lambda_2$ 的偏导数设为零来推导一阶必要条件。\n\n对向量 $w$ 的偏导数为：\n$$\n\\frac{\\partial L}{\\partial w} = 2 \\Sigma w - \\lambda_1 \\mathbf{1} - \\lambda_2 \\beta = 0\n$$\n由于 $\\Sigma$ 是正定的，因此它是可逆的。我们可以解出 $w$：\n$$\nw = \\frac{1}{2} \\Sigma^{-1} (\\lambda_1 \\mathbf{1} + \\lambda_2 \\beta)\n$$\n剩下的一阶条件只是恢复了原始约束：\n$$\n\\frac{\\partial L}{\\partial \\lambda_1} = -(\\mathbf{1}^{\\top} w - 1) = 0 \\implies \\mathbf{1}^{\\top} w = 1\n$$\n$$\n\\frac{\\partial L}{\\partial \\lambda_2} = -(\\beta^{\\top} w - 1) = 0 \\implies \\beta^{\\top} w = 1\n$$\n我们将 $w$ 的表达式代入这两个约束中，以构建一个关于 $\\lambda_1$ 和 $\\lambda_2$ 的线性方程组。\n\n代入第一个约束：\n$$\n\\mathbf{1}^{\\top} \\left( \\frac{1}{2} \\Sigma^{-1} (\\lambda_1 \\mathbf{1} + \\lambda_2 \\beta) \\right) = 1 \\implies \\lambda_1 (\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}) + \\lambda_2 (\\mathbf{1}^{\\top} \\Sigma^{-1} \\beta) = 2\n$$\n代入第二个约束：\n$$\n\\beta^{\\top} \\left( \\frac{1}{2} \\Sigma^{-1} (\\lambda_1 \\mathbf{1} + \\lambda_2 \\beta) \\right) = 1 \\implies \\lambda_1 (\\beta^{\\top} \\Sigma^{-1} \\mathbf{1}) + \\lambda_2 (\\beta^{\\top} \\Sigma^{-1} \\beta) = 2\n$$\n让我们定义标量 $A$、$B$ 和 $C$ 来简化表示法：\n$$\nA = \\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1} \\quad ; \\quad B = \\mathbf{1}^{\\top} \\Sigma^{-1} \\beta \\quad ; \\quad C = \\beta^{\\top} \\Sigma^{-1} \\beta\n$$\n注意，由于 $\\Sigma^{-1}$ 是对称的，我们有 $B = \\beta^{\\top} \\Sigma^{-1} \\mathbf{1}$。关于乘数的方程组变为：\n$$\n\\begin{pmatrix} A & B \\\\ B & C \\end{pmatrix} \\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}\n$$\n系数矩阵的行列式为 $D = AC - B^2$。根据由 $\\Sigma^{-1}$ 定义的内积的柯西-施瓦茨不等式，该行列式为零当且仅当约束向量 $\\mathbf{1}$ 和 $\\beta$ 线性相关。\n\n情况1：线性无关约束 ($D \\neq 0$)。\n该方程组对 $(\\lambda_1, \\lambda_2)$ 有唯一解，可以使用克莱姆法则或矩阵求逆法找到：\n$$\n\\lambda_1 = \\frac{2(C - B)}{AC - B^2} \\quad ; \\quad \\lambda_2 = \\frac{2(A - B)}{AC - B^2}\n$$\n有了这些值，最优权重向量 $w$ 就被唯一确定了。\n\n情况2：线性相关约束 ($D \\approx 0$)。\n这当且仅当对于某个标量 $k$ 存在 $\\beta = k \\cdot \\mathbf{1}$ 时发生。约束变为：\n$$\n\\mathbf{1}^{\\top} w = 1\n$$\n$$\n(k \\cdot \\mathbf{1})^{\\top} w = 1 \\implies k (\\mathbf{1}^{\\top} w) = 1\n$$\n将第一个约束代入第二个约束得到 $k(1) = 1$，这意味着 $k=1$。\n- 子情况2a：可行 ($k = 1$)。如果每个资产的贝塔值都为 $1$，则两个约束是相同的。问题退化为仅在 $\\mathbf{1}^{\\top} w = 1$ 的约束下最小化 $w^{\\top} \\Sigma w$。拉格朗日函数为 $L(w, \\lambda) = w^{\\top} \\Sigma w - \\lambda(\\mathbf{1}^{\\top} w - 1)$。一阶条件 $\\frac{\\partial L}{\\partial w} = 2 \\Sigma w - \\lambda \\mathbf{1} = 0$ 给出 $w = \\frac{\\lambda}{2} \\Sigma^{-1} \\mathbf{1}$。代入约束条件得到 $\\frac{\\lambda}{2} (\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}) = 1$，因此 $\\frac{\\lambda}{2} = \\frac{1}{\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}}$。最优权重为：\n  $$\n  w = \\frac{\\Sigma^{-1} \\mathbf{1}}{\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}}\n  $$\n- 子情况2b：不可行 ($k \\neq 1$)。约束是矛盾的。没有解存在。问题不可行。\n\n计算算法直接遵循此分析框架：\n1.  对于每个测试用例，计算贝塔向量 $\\beta = c / \\sigma_m^2$。\n2.  检查 $\\mathbf{1}$ 和 $\\beta$ 的线性相关性。这通过测试 $\\beta$ 的所有元素是否在指定的 $10^{-10}$ 数值容差内等于一个常数 $k$ 来完成。\n3.  如果它们是线性相关的：\n    a. 检查 $k$ 是否与约束一致，即 $|k - 1| < 10^{-10}$。\n    b. 如果一致，使用派生的公式解决单约束问题。\n    c. 如果不一致，问题是不可行的。\n4.  如果它们是线性无关的，求解 $2 \\times 2$ 方程组以获得 $\\lambda_1, \\lambda_2$，并计算权重 $w$。\n5.  对于任何可行的解，计算投资组合方差 $w^{\\top} \\Sigma w$、实现的贝塔值 $\\beta^{\\top} w$ 和权重之和 $\\mathbf{1}^{\\top} w$。后两者可用于验证约束是否满足。\n6.  按要求将所有数值结果格式化为 $6$ 位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum-variance portfolio under beta and budget constraints.\n    \"\"\"\n    \n    # Numerical tolerance for floating point comparisons.\n    TOL = 1e-10\n\n    test_cases = [\n        {\n            # Happy path, N=3\n            \"Sigma\": np.array([\n                [0.04, 0.006, 0.004],\n                [0.006, 0.09, 0.018],\n                [0.004, 0.018, 0.16]\n            ]),\n            \"c\": np.array([0.02, 0.03, 0.04]),\n            \"sigma_m_sq\": 0.05\n        },\n        {\n            # Degenerate but feasible, N=3\n            \"Sigma\": np.array([\n                [0.01, 0.002, 0.0015],\n                [0.002, 0.02, 0.003],\n                [0.0015, 0.003, 0.03]\n            ]),\n            \"c\": np.array([0.02, 0.02, 0.02]),\n            \"sigma_m_sq\": 0.02\n        },\n        {\n            # Degenerate and infeasible, N=3\n            \"Sigma\": np.array([\n                [0.06, 0.01, 0.008],\n                [0.01, 0.08, 0.012],\n                [0.008, 0.012, 0.1]\n            ]),\n            \"c\": np.array([0.03, 0.03, 0.03]),\n            \"sigma_m_sq\": 0.025\n        },\n        {\n            # General N=4\n            \"Sigma\": np.array([\n                [0.05, 0.01, 0.005, 0.004],\n                [0.01, 0.07, 0.011, 0.006],\n                [0.005, 0.011, 0.09, 0.012],\n                [0.004, 0.006, 0.012, 0.11]\n            ]),\n            \"c\": np.array([0.03, 0.025, 0.02, 0.015]),\n            \"sigma_m_sq\": 0.06\n        }\n    ]\n\n    results_for_print = []\n\n    for case in test_cases:\n        Sigma = case[\"Sigma\"]\n        c = case[\"c\"]\n        sigma_m_sq = case[\"sigma_m_sq\"]\n        N = Sigma.shape[0]\n\n        beta = c / sigma_m_sq\n        ones = np.ones(N)\n\n        # Check for linear dependence: beta = k * 1\n        # This is true if all elements of beta are the same.\n        is_dependent = np.allclose(beta, beta[0], atol=TOL, rtol=TOL)\n\n        w = None\n        if is_dependent:\n            k = beta[0]\n            # Check for feasibility: k must equal 1\n            if np.isclose(k, 1.0, atol=TOL):\n                # Constraints are redundant and feasible. Solve single-constraint problem.\n                # min w'Sw s.t. 1'w = 1\n                Sigma_inv = np.linalg.inv(Sigma)\n                numerator = Sigma_inv @ ones\n                denominator = ones.T @ numerator\n                w = numerator / denominator\n            else:\n                # Constraints are contradictory. Infeasible.\n                results_for_print.append(\"[]\")\n                continue\n        else:\n            # Constraints are linearly independent. Solve two-constraint problem.\n            Sigma_inv = np.linalg.inv(Sigma)\n            \n            # Define scalars for the 2x2 system\n            A = ones.T @ Sigma_inv @ ones\n            B = ones.T @ Sigma_inv @ beta\n            C = beta.T @ Sigma_inv @ beta\n\n            # Solve for Lagrange multipliers lambda1, lambda2\n            matrix_D = A * C - B * B\n            if abs(matrix_D) < TOL:\n                # This should not be reached due to the initial check but is a safeguard.\n                results_for_print.append(\"[]\")\n                continue\n\n            # System is [A, B; B, C][l1; l2] = [2; 2]\n            lambda1 = 2 * (C - B) / matrix_D\n            lambda2 = 2 * (A - B) / matrix_D\n\n            # Compute weights\n            w = 0.5 * (Sigma_inv @ (lambda1 * ones + lambda2 * beta))\n\n        if w is not None:\n            # Calculate final portfolio characteristics\n            portfolio_variance = w.T @ Sigma @ w\n            portfolio_beta = beta.T @ w\n            portfolio_weight_sum = np.sum(w)\n            \n            # Prepare result list and round all numbers\n            final_list = list(w) + [portfolio_variance, portfolio_beta, portfolio_weight_sum]\n            rounded_list = [f\"{x:.6f}\" for x in final_list]\n            results_for_print.append(f\"[{','.join(rounded_list)}]\")\n\n    # Print the final result string in the required format\n    print(f\"[{','.join(results_for_print)}]\")\n\nsolve()\n```"}, {"introduction": "构建有效前沿的标准模型通常假定所有可能的投资组合构成一个凸集，这意味着任意两个可行投资组合的线性组合仍然是可行的。然而，在现实中，由于法规、伦理或策略上的限制，投资可行集可能出现“空洞”，从而变为非凸集。这个高级实践将引导您通过计算的方式，探索这种非凸约束对有效前沿结构可能产生的惊人影响。您会发现，当可行集出现断裂时，有效前沿本身也可能不再是连续的，从而挑战我们基于标准理论建立的直觉，并突显出计算方法在分析复杂金融问题中的强大能力。[@problem_id:2384354]", "id": "2384354", "problem": "设有一个包含三种风险资产的单周期均值-方差投资组合选择问题。设期望总回报率（以每单位投资的小数表示）由向量 $r = (0.20, 0.06, 0.04)$ 给出，回报率的协方差矩阵为对称矩阵\n$$\n\\Sigma \\;=\\;\n\\begin{pmatrix}\n0.0625 & 0.005 & 0.002 \\\\\n0.005 & 0.010 & 0.002 \\\\\n0.002 & 0.002 & 0.0064\n\\end{pmatrix}.\n$$\n一个投资组合是一个权重向量 $w = (w_1,w_2,w_3)$，对于每个 $i \\in \\{1,2,3\\}$ 满足 $w_i \\ge 0$ 且 $\\sum_{i=1}^3 w_i = 1$。对于任何可行的 $w$，期望回报为 $\\mu(w) = r^\\top w$，方差为 $\\sigma^2(w) = w^\\top \\Sigma \\, w$。\n\n考虑一个额外的非凸约束，它在预算集中引入了一个“空洞”：存在参数 $\\alpha,\\beta$ 满足 $0 \\le \\alpha \\le \\beta \\le 1$，使得可行的投资组合必须满足析取条件 $w_1 \\le \\alpha$ 或 $w_1 \\ge \\beta$。对于给定的 $\\alpha,\\beta$，将有效前沿定义为：在所有可行的 $w$ 中，能够达到给定目标期望回报 $\\mu^\\star$ 的方差最小化投资组合的集合。其中，目标期望回报被限制在下文描述的可行范围上的一个网格内。\n\n对于每个参数对 $(\\alpha,\\beta)$，按如下方式定义可行的目标回报范围。考虑通过取由 $w_1 \\le \\alpha$ 和 $w_1 \\ge \\beta$ 定义的两个凸子集的角点的并集得到的极端可行角点投资组合，即满足 $0 \\le \\alpha \\le \\beta \\le 1$ 的投资组合，其 $(w_1,w_2,w_3) \\in \\{(0,1,0),(0,0,1),(\\alpha,1-\\alpha,0),(\\alpha,0,1-\\alpha),(\\beta,1-\\beta,0),(\\beta,0,1-\\beta),(1,0,0)\\}$。设 $\\mu_{\\min}$ 为这些投资组合上 $\\mu(w)$ 的最小值，$\\mu_{\\max}$ 为这些投资组合上 $\\mu(w)$ 的最大值。考虑以下线性间隔的目标回报网格\n$$\n\\{\\mu^\\star_k : k = 0,1,\\dots,60\\}, \\quad \\mu^\\star_k \\;=\\; \\mu_{\\min} + \\frac{k}{60}\\,(\\mu_{\\max}-\\mu_{\\min}).\n$$\n\n对于每个 $\\mu^\\star_k$，如果存在一个可行的 $w$（即 $w_i \\ge 0$, $\\sum_i w_i = 1$, 且 $w_1 \\le \\alpha$ 或 $w_1 \\ge \\beta$）使得 $|\\mu(w) - \\mu^\\star_k| \\le \\varepsilon$，其中 $\\varepsilon = 10^{-6}$，则该目标被视为可行。在所有满足此目标的投资组合中，$\\mu^\\star_k$ 处的有效方差是 $\\sigma^2(w)$ 的最小值。\n\n定义有效前沿是不连通的，如果当扫描有序网格 $\\{\\mu^\\star_k\\}_{k=0}^{60}$ 时，有效方差有定义（即目标可行）的索引 $k$ 的集合可以分解为至少两个非空、不相交的、最大的连续块。否则，有效前沿是连通的。\n\n您的任务是编写一个完整的程序，对于下面指定的每个测试用例，根据上述定义判断有效前沿是否为不连通的。程序必须使用上面给定的固定 $r$ 和 $\\Sigma$，并且必须强制执行非负性和预算约束。\n\n测试套件（每个测试用例是一对 $(\\alpha,\\beta)$）：\n- 案例 1：$(\\alpha,\\beta) = (0.20, 0.80)$。\n- 案例 2：$(\\alpha,\\beta) = (0.00, 0.00)$。\n- 案例 3：$(\\alpha,\\beta) = (0.49, 0.51)$。\n- 案例 4：$(\\alpha,\\beta) = (0.30, 0.70)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表（例如，“[True,False,True,False]”），每个布尔值按顺序对应于案例1到4，并指示在该案例的非凸约束下，有效前沿是否为不连通的（True）或连通的（False）。不应打印任何其他文本。计算中的所有数值都没有单位，应作为小数（而非百分比）处理。", "solution": "问题陈述经过严格审查，被认定是有效的。它提出了一个计算金融领域中定义明确的问题，特别是在均值-方差投资组合优化方面。给定的条件是完整的、数学上一致的，并且在已确立的金融经济理论中有科学依据。协方差矩阵 $\\Sigma$ 是对称的，其所有主子式均为正（$M_1 = 0.0625$, $M_2 = 0.0006$, $M_3 \\approx 3.59 \\times 10^{-6}$），根据 Sylvester 判据，这证实了 $\\Sigma$ 是正定的。这保证了目标函数，即投资组合方差 $\\sigma^2(w) = w^\\top \\Sigma w$，是严格凸的，从而确保任何凸约束下的方差最小化问题都有唯一解。任务是确定在非凸约束下有效前沿的一个属性——不连通性——这是一个可通过编程验证的问题。\n\n问题的核心是，对于一个目标期望回报网格 $\\{\\mu^\\star_k\\}$，确定哪些目标是可行的。如果存在一个投资组合 $w$ 满足所有给定约束，并达到一个期望回报 $\\mu(w)$ 使得 $|\\mu(w) - \\mu^\\star_k| \\le \\varepsilon$，则目标 $\\mu^\\star_k$ 是可行的。如果与可行目标对应的索引 $k$ 的集合不是单个连续块，则有效前沿被认为是不连通的。\n\n主要困难来自于投资组合权重的非凸约束：$w_1 \\le \\alpha$ 或 $w_1 \\ge \\beta$。这个约束将总的可行投资组合集合（我们称之为 $F$）定义为两个不相交的凸集（多胞体）的并集：\n$S_1 = \\{ w \\in \\mathbb{R}^3 \\mid \\sum_{i=1}^3 w_i = 1, w_i \\ge 0 \\text{ for } i=1,2,3, \\text{ and } w_1 \\le \\alpha \\}$\n$S_2 = \\{ w \\in \\mathbb{R}^3 \\mid \\sum_{i=1}^3 w_i = 1, w_i \\ge 0 \\text{ for } i=1,2,3, \\text{ and } w_1 \\ge \\beta \\}$\n因此，$F = S_1 \\cup S_2$。\n\n要确定一个目标回报 $\\mu^\\star_k$ 是否可行，我们必须确认是否存在任何投资组合 $w \\in F$ 满足回报条件 $|\\mu(w) - \\mu^\\star_k| \\le \\varepsilon$。由于 $F = S_1 \\cup S_2$，这等价于检查以下两个条件中至少有一个成立：\n1. 存在一个投资组合 $w^{(1)} \\in S_1$，使得 $|\\mu(w^{(1)}) - \\mu^\\star_k| \\le \\varepsilon$。\n2. 存在一个投资组合 $w^{(2)} \\in S_2$，使得 $|\\mu(w^{(2)}) - \\mu^\\star_k| \\le \\varepsilon$。\n\n问题要求找到有效方差，即给定目标回报下的最小方差。这表明可以将可行性检查构建成一个优化问题。对于每个目标回报 $\\mu^\\star_k$，我们可以求解两个独立的二次规划（QP）问题：\n**问题 P1：**\n$$ \\min_{w} \\quad w^\\top \\Sigma w $$\n$$ \\text{subject to} \\quad w \\in S_1, \\quad |\\mu(w) - \\mu^\\star_k| \\le \\varepsilon $$\n**问题 P2：**\n$$ \\min_{w} \\quad w^\\top \\Sigma w $$\n$$ \\text{subject to} \\quad w \\in S_2, \\quad |\\mu(w) - \\mu^\\star_k| \\le \\varepsilon $$\n\n一个目标回报 $\\mu^\\star_k$ 是可行的，当且仅当这两个 QP 问题中至少有一个存在可行解。可以使用数值 QP 求解器，例如序列最小二乘规划（SLSQP）算法。如果求解器成功为 P1 或 P2 找到解，则目标 $\\mu^\\star_k$ 是可行的。如果两个求解器都未能找到解（这通常表示相应子问题的可行集为空），则 $\\mu^\\star_k$ 是不可行的。\n\n对于每个测试用例 $(\\alpha, \\beta)$，整体算法按以下步骤进行：\n1.  **构建回报网格**：首先，计算七个指定角点投资组合的期望回报 $\\mu(w) = r^\\top w$。这些值的最小值 $\\mu_{\\min}$ 和最大值 $\\mu_{\\max}$ 定义了目标回报网格的范围。然后通过线性插值构建包含$61$个点的网格 $\\{\\mu^\\star_k\\}_{k=0}^{60}$。\n2.  **检查每个目标的可行性**：对于网格中的每个 $\\mu^\\star_k$，求解 QP 问题 P1 和 P2。将约束编码以供数值求解器使用。如果 P1 或 P2 有解，则布尔标志 `is_feasible[k]` 设为 `True`，否则设为 `False`。\n3.  **分析连通性**：在为所有 $k \\in \\{0, \\dots, 60\\}$ 填充 `is_feasible` 数组后，我们分析其结构。如果数组不包含任何 `True` 值，则前沿是平凡连通的。否则，我们找到第一个 `True` 条目和最后一个 `True` 条目的索引。如果这两个索引（含）之间的所有条目都为 `True`，则可行回报集形成单个连续块，前沿是连通的。如果在第一个和最后一个 `True` 条目之间至少有一个 `False` 条目，则存在间隙，前沿被声明为不连通的。\n\n将此过程系统地应用于测试套件中的每个 $(\\alpha, \\beta)$ 对，以生成最终的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the mean-variance portfolio problem with a non-convex constraint for multiple test cases.\n    \"\"\"\n    # Problem constants\n    R_VEC = np.array([0.20, 0.06, 0.04])\n    _T = R_VEC.T\n    SIGMA = np.array([\n        [0.0625, 0.005, 0.002],\n        [0.005, 0.010, 0.002],\n        [0.002, 0.002, 0.0064]\n    ])\n    RETURN_TOLERANCE_EPSILON = 1e-6\n    GRID_POINTS = 60\n\n    test_cases = [\n        (0.20, 0.80),\n        (0.00, 0.00),\n        (0.49, 0.51),\n        (0.30, 0.70)\n    ]\n\n    results = []\n\n    for alpha, beta in test_cases:\n        # Step 1: Define the feasible target-return range from corner portfolios\n        corner_portfolios = set()\n        # The set automatically handles duplicates, e.g., when alpha=0 or beta=0\n        if 1 - alpha >= 0:\n            corner_portfolios.add((alpha, 1 - alpha, 0))\n            corner_portfolios.add((alpha, 0, 1 - alpha))\n        if 1 - beta >= 0:\n            corner_portfolios.add((beta, 1 - beta, 0))\n            corner_portfolios.add((beta, 0, 1 - beta))\n        \n        corner_portfolios.add((0, 1, 0))\n        corner_portfolios.add((0, 0, 1))\n        corner_portfolios.add((1, 0, 0))\n        \n        corner_returns = [R_VEC @ np.array(w) for w in corner_portfolios]\n        \n        mu_min = min(corner_returns)\n        mu_max = max(corner_returns)\n        \n        mu_grid = np.linspace(mu_min, mu_max, GRID_POINTS + 1)\n\n        # Step 2: For each target return, check if a feasible portfolio exists\n        is_feasible_on_grid = []\n        \n        # Objective function for QP: variance\n        objective_func = lambda w: w.T @ SIGMA @ w\n        # Standard bounds w_i >= 0\n        bounds = [(0, None), (0, None), (0, None)]\n        # Standard constraint sum(w_i) = 1\n        sum_constraint = {'type': 'eq', 'fun': lambda w: np.sum(w) - 1}\n\n        for mu_star in mu_grid:\n            k_is_feasible = False\n            \n            # Constraints for return target mu_star with tolerance\n            return_constraints = [\n                {'type': 'ineq', 'fun': lambda w, mu=mu_star: mu + RETURN_TOLERANCE_EPSILON - R_VEC @ w},\n                {'type': 'ineq', 'fun': lambda w, mu=mu_star: R_VEC @ w - (mu - RETURN_TOLERANCE_EPSILON)}\n            ]\n\n            # Sub-problem 1: w_1 <= alpha\n            cons1 = [sum_constraint] + return_constraints + [{'type': 'ineq', 'fun': lambda w: alpha - w[0]}]\n            # Feasible initial guess for S1\n            x0_1 = np.array([alpha/2.0, (1.0-alpha/2.0)/2.0, (1.0-alpha/2.0)/2.0])\n            res1 = minimize(objective_func, x0_1, method='SLSQP', bounds=bounds, constraints=cons1, tol=1e-9)\n            if res1.success:\n                k_is_feasible = True\n\n            # Sub-problem 2: w_1 >= beta\n            if not k_is_feasible:\n                cons2 = [sum_constraint] + return_constraints + [{'type': 'ineq', 'fun': lambda w: w[0] - beta}]\n                # Feasible initial guess for S2\n                x0_2 = np.array([beta, (1.0 - beta) / 2.0, (1.0 - beta) / 2.0]) if beta < 1 else np.array([1.0, 0.0, 0.0])\n                res2 = minimize(objective_func, x0_2, method='SLSQP', bounds=bounds, constraints=cons2, tol=1e-9)\n                if res2.success:\n                    k_is_feasible = True\n            \n            is_feasible_on_grid.append(k_is_feasible)\n\n        # Step 3: Analyze the feasibility array for disjointness\n        is_feasible_np = np.array(is_feasible_on_grid)\n        \n        if not np.any(is_feasible_np):\n            # No feasible points found, so a single (empty) block. Connected.\n            is_disjoint = False\n        else:\n            first_true = np.argmax(is_feasible_np)\n            last_true = len(is_feasible_np) - 1 - np.argmax(is_feasible_np[::-1])\n            # Check if all elements between the first and last 'True' are also 'True'\n            is_connected = np.all(is_feasible_np[first_true : last_true + 1])\n            is_disjoint = not is_connected\n            \n        results.append(is_disjoint)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}