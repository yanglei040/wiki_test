{"hands_on_practices": [{"introduction": "我们首先将一个基本的消费者选择问题——从一系列不可分割的商品中进行选择——构建为一个经典的计算机科学问题：0/1背包问题。这个练习在经济理论和组合优化之间架起了一座桥梁，展示了如何使用动态规划来形式化并解决离散选择模型 [@problem_id:2384164]。掌握这种联系对于处理各种资源分配问题至关重要。", "id": "2384164", "problem": "给定一个包含不可分商品的离散时间消费者选择问题。消费者面临一组有限的商品，索引为 $i \\in \\{1,\\dots,n\\}$。每种商品可以不购买，也可以购买一个单位。消费者有一个非负、可加可分的效用指数，由向量 $u \\in \\mathbb{R}_{\\ge 0}^{n}$ 表示，其中 $u_i$ 是获得一个单位商品 $i$ 的效用；同时，商品价格为非负的，由向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 表示，其中 $p_i$ 是一个单位商品 $i$ 的价格。消费者拥有预算 $M \\in \\mathbb{R}_{\\ge 0}$。决策变量为 $x_i \\in \\{0,1\\}$（对每个 $i$），表示是否购买商品 $i$。消费者寻求在预算约束下最大化总效用。\n\n根据基础微观经济学原理，消费者问题是在资源约束下最大化效用函数。在商品效用可加和商品不可分的条件下，这变成了一个组合优化问题。你的任务是：\n\n- 从效用最大化和预算集的定义出发，引入二元决策变量和线性预算约束，推导出此离散消费者选择问题的精确数学公式。使用一个有效的整数规划来表达该问题。\n- 解释该公式为何是0-1背包问题的一个实例，其中效用扮演价值的角色，价格扮演重量的角色，预算则是背包的容量。\n- 设计并实现一个精确算法，将该问题作为整数规划问题求解。你必须给出一个总效用的精确最大化解。你可以使用一种有原则的算法，例如带有分数背包上界的“分支定界”方案，或是一种伪多项式时间的动态规划，确保对所有提供的测试用例都正确。从基本原理出发，清晰地解释算法逻辑。\n\n你的程序必须实现一个求解器，并将其应用于以下测试用例集。每个实例由一个效用向量 $u$、一个价格向量 $p$ 和一个预算 $M$ 指定：\n\n- 测试 $1$ (一般情况): $u = [9,6,7,3]$, $p = [4,3,5,2]$, $M = 7$。\n- 测试 $2$ (零预算边界): $u = [5,4]$, $p = [1,2]$, $M = 0$。\n- 测试 $3$ (零价格商品): $u = [4,10,2]$, $p = [0,5,3]$, $M = 5$。\n- 测试 $4$ (单位货币效用相等，但最优总效用唯一): $u = [6,6,5]$, $p = [4,4,5]$, $M = 8$。\n- 测试 $5$ (存在被支配项): $u = [8,7,6,9]$, $p = [5,6,4,7]$, $M = 9$。\n- 测试 $6$ (预算超过总成本，全选): $u = [3,5,2]$, $p = [1,2,1]$, $M = 10$。\n\n覆盖性设计：\n- 测试 $1$ 是一个标准的非平凡实例。\n- 测试 $2$ 检查 $M = 0$ 的边界情况。\n- 测试 $3$ 检查零价格商品的处理。\n- 测试 $4$ 检查在效用-价格比率相等的情况下，总效用最优解是否唯一的行为。\n- 测试 $5$ 包含一个被支配选项，以验证剪枝的正确性。\n- 测试 $6$ 检查容量占优的情况，此时最优选择是购买所有商品。\n\n假设：\n- 所有效用项满足 $u_i \\ge 0$。\n- 所有价格满足 $p_i \\ge 0$，除非另有说明，否则至少有一个 $p_i > 0$。\n- 如果任何商品满足 $p_i = 0$ 且 $u_i > 0$，那么将这些商品的 $x_i$ 设为 $1$ 总是理性的。\n\n你的程序应该为每个测试用例计算可实现的最大总效用，并将其作为一个整数。你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $[a_1,a_2,\\dots,a_6]$，其中 $a_j$ 是测试 $j$ 的最大总效用，按上述顺序排列。不涉及物理单位或角度单位。将每个数字表示为整数。此问题中不使用百分比。", "solution": "在可加可分效用函数和预算约束下的离散消费者选择问题，是微观经济学理论中的一个经典模型，也是组合优化学中的一个基本问题。我们将首先验证问题陈述，然后推导其数学公式，将其与一个已知的问题结构联系起来，最后设计并实现一个正确且精确的算法。\n\n**问题公式化**\n\n消费者的目标是在预算约束下，最大化从一系列商品中获得的总效用。设商品集合由 $i \\in \\{1, \\dots, n\\}$ 索引。对于每种商品 $i$，消费者做出一个二元决策，由变量 $x_i$ 表示，其中 $x_i = 1$ 表示购买该商品， $x_i = 0$ 表示不购买。\n效用是可加可分的，这意味着总效用是所购买单个商品效用的总和。给定一个效用向量 $u = (u_1, u_2, \\dots, u_n)$，总效用表示为以下线性函数：\n$$\nU(x) = \\sum_{i=1}^{n} u_i x_i\n$$\n消费者面临预算约束。给定一个价格向量 $p = (p_1, p_2, \\dots, p_n)$ 和总预算 $M$，总支出不得超过预算。这表示为以下线性不等式：\n$$\n\\sum_{i=1}^{n} p_i x_i \\le M\n$$\n结合目标函数、预算约束和决策变量的二元性质，我们得到以下整数线性规划 (ILP) 公式：\n$$\n\\begin{aligned}\n\\text{maximize} \\quad & \\sum_{i=1}^{n} u_i x_i \\\\\n\\text{subject to} \\quad & \\sum_{i=1}^{n} p_i x_i \\le M \\\\\n& x_i \\in \\{0, 1\\}, \\quad \\forall i \\in \\{1, \\dots, n\\}\n\\end{aligned}\n$$\n该公式精确地描述了所述的消费者优化问题。如题目所述，所有参数（$u_i$、$p_i$、$M$）都是非负实数。\n\n**与0-1背包问题的关系**\n\n推导出的整数线性规划在结构上与经典的0-1背包问题相同。0-1背包问题是一个组合优化问题，其定义如下：给定一组物品，每个物品都有一个价值和一个重量，确定要将哪些物品放入一个集合（一个“背包”）中，以使总价值最大化，同时满足总重量不超过给定容量的约束。\n\n其形式上的映射是直接且明确的：\n-   消费者的商品对应于背包问题中的*物品*。\n-   商品 $i$ 的效用 $u_i$ 对应于物品 $i$ 的*价值*。\n-   商品 $i$ 的价格 $p_i$ 对应于物品 $i$ 的*重量*。\n-   消费者的预算 $M$ 对应于背包的*容量*。\n-   决策变量 $x_i$（购买与否）等同于决定是否将一个物品放入背包。\n\n因此，解决消费者效用最大化问题等同于解决一个0-1背包问题的实例。已知该问题是NP-难的，这意味着没有已知的算法可以在关于物品数量和输入表示所需比特数的多项式时间内解决它。然而，它可以通过动态规划得到一个伪多项式时间的解。\n\n**算法设计：动态规划**\n\n我们将构建一个动态规划算法来找到精确的最优效用。该算法依赖于最优性原理：问题的最优解可以由其子问题的最优解构造而成。\n\n首先，我们处理零价格商品的特殊情况。根据问题的假设，如果一个商品 $i$ 的价格 $p_i=0$ 且效用 $u_i > 0$，那么获取它总是最优的，因为它在不消耗预算的情况下提供正效用。因此，我们可以预处理商品列表。我们将所有此类零价格商品的效用相加，以建立一个 `base_utility`，然后使用原始预算 $M$ 解决剩余的正价格商品问题。\n\n令剩余的商品（价格 $p_i>0$）从 $1$ 到 $n'$ 索引。子问题定义为：使用前 $i$ 个商品（$1 \\le i \\le n'$）的子集，在预算为 $w$（$0 \\le w \\le M$）的情况下可获得的最大效用。令 $dp[i][w]$ 表示此解的值。\n\n递推关系通过考虑第 $i$ 个商品（效用 $u_i$，价格 $p_i$）推导得出：\n1.  **不包含商品 $i$**：最大效用与使用前 $i-1$ 个商品在预算 $w$ 下可达到的效用相同。此值为 $dp[i-1][w]$。\n2.  **包含商品 $i$**：这仅在商品价格 $p_i$ 不超过当前预算 $w$ 时才可能。如果包含，它将为效用贡献 $u_i$，剩余的预算 $w - p_i$ 可用于前 $i-1$ 个商品的最优选择。这种情况下的总效用是 $u_i + dp[i-1][w-p_i]$。\n\n最优选择是这两个选项中的最大值。因此，递推关系为：\n$$\ndp[i][w] = \\begin{cases}\ndp[i-1][w] & \\text{if } p_i > w \\\\\n\\max(dp[i-1][w], u_i + dp[i-1][w-p_i]) & \\text{if } p_i \\le w\n\\end{cases}\n$$\n基本情况是对于所有 $w$，都有 $dp[0][w] = 0$，因为从零个商品中无法获得任何效用。\n\n这种二维动态规划公式的时间复杂度为 $O(n'M)$，空间复杂度为 $O(n'M)$。通过观察到第 $i$ 行的计算仅依赖于第 $i-1$ 行，可以将空间复杂度优化到 $O(M)$。通过使用一个一维数组 `dp[w]`，并将预算 `w` 从 $M$ 向下迭代到 $p_i$，我们可以防止在同一个商品处理步骤中多次使用商品 $i$ 的信息。对于大小为 $M+1$ 的单个数组 `dp`，优化后的递推关系是：\n\n对于从 $1$ 到 $n'$ 的每个商品 $i$：\n对于从 $M$ 向下到 $p_i$ 的每个预算 $w$：\n$$\ndp[w] = \\max(dp[w], u_i + dp[w-p_i])\n$$\n子问题的最终解是 $dp[M]$。总的最大效用是这个值加上来自零价格商品的 `base_utility`。由于问题的测试用例涉及整数价格和预算，这种动态规划方法是适用且高效的。实现将遵循这种空间优化的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the discrete consumer choice problem for a suite of test cases.\n    This problem is equivalent to the 0-1 knapsack problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (general case)\n        {'u': [9, 6, 7, 3], 'p': [4, 3, 5, 2], 'M': 7},\n        # Test 2 (zero budget boundary)\n        {'u': [5, 4], 'p': [1, 2], 'M': 0},\n        # Test 3 (zero-price item)\n        {'u': [4, 10, 2], 'p': [0, 5, 3], 'M': 5},\n        # Test 4 (tie in per-dollar utilities, unique optimal utility)\n        {'u': [6, 6, 5], 'p': [4, 4, 5], 'M': 8},\n        # Test 5 (dominated item present)\n        {'u': [8, 7, 6, 9], 'p': [5, 6, 4, 7], 'M': 9},\n        # Test 6 (budget exceeds total cost, take all)\n        {'u': [3, 5, 2], 'p': [1, 2, 1], 'M': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        utilities = case['u']\n        prices = case['p']\n        budget = case['M']\n        \n        n = len(utilities)\n        base_utility = 0\n        \n        # Preprocessing step for zero-price items\n        positive_price_items = []\n        for i in range(n):\n            if prices[i] == 0:\n                if utilities[i] > 0:\n                    base_utility += utilities[i]\n            else:\n                # We only consider items that could potentially fit in the budget\n                if prices[i] <= budget:\n                    positive_price_items.append({'u': utilities[i], 'p': prices[i]})\n\n        # If budget is 0, no items with positive price can be bought.\n        if budget == 0:\n            results.append(base_utility)\n            continue\n\n        # Dynamic Programming solution for the 0-1 Knapsack problem\n        # dp[w] stores the maximum utility for a budget of w.\n        # The budget is treated as an integer quantity.\n        dp = np.zeros(budget + 1, dtype=int)\n        \n        for item in positive_price_items:\n            utility = item['u']\n            price = item['p']\n            # Iterate backwards to use each item at most once\n            for w in range(budget, price - 1, -1):\n                dp[w] = max(dp[w], utility + dp[w - price])\n                \n        max_utility = dp[budget] + base_utility\n        results.append(int(max_utility))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "接下来，我们将探讨一个具有完全互补偏好的场景，其效用函数为 Leontief 形式的 $U = \\min(ax, by)$，其中一种商品只能以整数数量获得。这项练习要求你调整处理 Leontief 商品的标准分析方法，以适应混合离散-连续选择环境 [@problem_id:2384153]。你将学习如何将关于偏好结构的经济直觉与有针对性的计算搜索相结合，从而找到最优点。", "id": "2384153", "problem": "考虑一个消费者选择两种非负数量的商品，商品 $x$ 和商品 $y$，以在线性预算约束下最大化其效用。其效用函数为 Leontief（完全互补品）形式，由 $U(x,y)=\\min(a x, b y)$ 给出，其中 $a>0$ 和 $b>0$ 为固定参数。商品 $x$ 的价格为 $p_x>0$，商品 $y$ 的价格为 $p_y>0$。收入为 $m\\ge 0$。选择集受到预算约束 $p_x x + p_y y \\le m$、$x \\ge 0$ 以及商品 $y$ 必须以离散整数单位 $y \\in \\{0,1,2,\\dots\\}$ 进行选择的可用性限制。消费者寻求选择 $(x,y)$ 以最大化 $U(x,y)$。\n\n在所有效用最大化的商品组合中，选择能够达到最大效用且 $y$ 为最小整数的那个组合。对于选定的 $y$，选择能够达到所选效用并满足预算约束的最小非负实数值 $x$。\n\n所有变量均无单位。不涉及角度或物理单位。\n\n您的程序必须根据上述约束和选择规则，为下面的每个参数集计算效用最大化的商品组合 $(x^\\star,y^\\star)$ 和相应的最大效用 $U^\\star=U(x^\\star,y^\\star)$。每个参数集所需的输出是一个三元组 $[x^\\star,y^\\star,U^\\star]$。\n\n请为以下参数集测试套件提供结果，每个参数集指定为 $(a,b,p_x,p_y,m)$：\n- $(a,b,p_x,p_y,m) = (\\, \\$1\\$,\\, \\$1\\$,\\, \\$2\\$,\\, \\$3\\$,\\, \\$20\\$ \\,)$\n- $(a,b,p_x,p_y,m) = (\\, \\$2\\$,\\, \\$1\\$,\\, \\$3\\$,\\, \\$5\\$,\\, \\$11\\$ \\,)$\n- $(a,b,p_x,p_y,m) = (\\, \\$1.5\\$,\\, \\$2\\$,\\, \\$1\\$,\\, \\$10\\$,\\, \\$7\\$ \\,)$\n- $(a,b,p_x,p_y,m) = (\\, \\$2\\$,\\, \\$1\\$,\\, \\$3\\$,\\, \\$4\\$,\\, \\$9.5\\$ \\,)$\n- $(a,b,p_x,p_y,m) = (\\, \\$3\\$,\\, \\$5\\$,\\, \\$2\\$,\\, \\$7\\$,\\, \\$100\\$ \\,)$\n\n最终输出格式：\n- 对于每个参数集，输出一个三元组 $[x^\\star,y^\\star,U^\\star]$，其中 $x^\\star$ 和 $U^\\star$ 是四舍五入到六位小数的实数，$y^\\star$ 是一个整数。\n- 将所有参数集的结果聚合为单行，形式为用方括号括起来的逗号分隔列表，不含空格。例如：$[[\\!x^\\star_1,y^\\star_1,U^\\star_1],[\\!x^\\star_2,y^\\star_2,U^\\star_2],\\dots]$。", "solution": "所提出的问题是微观经济学领域中的一个约束效用最大化问题。该问题定义明确、数学上一致，并以成熟的经济学理论为基础。效用函数为 Leontief 形式，$U(x,y)=\\min(ax, by)$，代表完全互补品。消费者的选择受到预算约束 $p_x x + p_y y \\le m$ 和混合变量约束的限制，其中商品 $x$ 是一个连续非负变量 ($x \\ge 0$)，商品 $y$ 是一个离散非负整数 ($y \\in \\{0,1,2,\\dots\\}$)。目标是找到满足这些约束以及一套特定决胜规则的商品组合 $(x^\\star, y^\\star)$ 和相应的最大效用 $U^\\star$。\n\n分析始于 Leontief 效用函数的性质。为了最大化效用，理性的消费者绝不会选择 $ax \\neq by$ 的商品组合。例如，如果 $ax > by$，效用完全由 $by$ 项决定。消费者可以减少 $x$ 的消费而不会损失任何效用，从而节省收入。这笔节省下来的收入可以重新分配以增加两种商品的消费，从而达到一个严格更高的效用水平。因此，任何具有正效用的最优组合都必须满足条件 $ax = by$。这个关系定义了扩展路径，最优组合必须位于该路径上。由此，我们推导出商品的最优比例为 $x = \\frac{b}{a}y$。\n\n$y$ 必须为整数的约束将问题转化为一个混合整数优化问题。我们不能再简单地求解方程组 $ax = by$ 和 $p_x x + p_y y = m$。相反，我们必须评估每个可行的整数 $y$ 值所能带来的最大可能效用。\n\n一个整数选择 $y$（我们称之为 $y_k$）是可行的，当且仅当其成本不超过总收入，即 $p_y y_k \\le m$。这意味着 $y$ 的可行整数集合是有限的，由 $y_k \\in \\{0, 1, 2, \\dots, \\lfloor \\frac{m}{p_y} \\rfloor \\}$ 给出。对于任何这样的可行 $y_k$，消费者将通过把所有剩余收入分配给商品 $x$ 来最大化效用。可以购买的 $x$ 的最大数量是 $x_{max} = \\frac{m - p_y y_k}{p_x}$。这个组合 $(x_{max}, y_k)$ 的效用是 $U_k = U(x_{max}, y_k) = \\min(a \\cdot x_{max}, b \\cdot y_k)$。\n\n我们的目标是从可行集合中找到使函数 $U_k$ 最大化的整数 $y_k$。为指导此搜索，我们考虑一个类似的问题，其中 $y$ 是一个连续变量。当 $\\min$ 函数的两个参数相等时，效用 $U(y) = \\min(a \\frac{m - p_y y}{p_x}, by)$ 达到最大值：$a \\frac{m - p_y y}{p_x} = by$。求解 $y$ 可得连续最优值 $y_{cont}^* = \\frac{am}{b p_x + a p_y}$。\n\n函数 $g(y) = by$ 是关于 $y$ 的增函数，而函数 $f(y) = a \\frac{m - p_y y}{p_x}$ 是关于 $y$ 的减函数。因此，函数 $\\min(f(y), g(y))$ 是拟凹的，在 $y < y_{cont}^*$ 时递增，在 $y > y_{cont}^*$ 时递减。因此，整数 $y$ 的最大效用必定出现在包含连续最优值的两个整数之一处：$y_1 = \\lfloor y_{cont}^* \\rfloor$ 或 $y_2 = \\lceil y_{cont}^* \\rceil = y_1 + 1$。\n\n求解算法如下：\n$1$. 计算连续最优值 $y_{cont}^* = \\frac{am}{b p_x + a p_y}$。\n$2$. 第一个整数候选值是 $y_1 = \\lfloor y_{cont}^* \\rfloor$。我们计算相应的最大效用 $U_1 = \\min\\left(a \\frac{m - p_y y_1}{p_x}, b y_1\\right)$。\n$3$. 第二个整数候选值是 $y_2 = y_1 + 1$。我们必须首先通过检查 $p_y y_2 \\le m$ 来验证其可行性。如果可行，我们计算其效用 $U_2 = \\min\\left(a \\frac{m - p_y y_2}{p_x}, b y_2\\right)$。\n$4$. 然后我们确定最优整数 $y^\\star$ 和最大效用 $U^\\star$。最大效用为 $U^\\star = \\max(U_1, U_2)$（如果 $y_2$ 不可行，则仅为 $U_1$）。问题指定了一个决胜规则：如果多个组合产生相同的最大效用，我们必须选择具有最小整数 $y^\\star$ 的那个。因此：\n    - 如果 $U_2 > U_1$，我们选择 $y^\\star = y_2$ 和 $U^\\star = U_2$。\n    - 否则（如果 $U_1 \\ge U_2$ 或 $y_2$ 不可行），我们选择 $y^\\star = y_1$ 和 $U^\\star = U_1$。\n$5$. 最后，我们必须确定 $x^\\star$ 的值。第二个决胜规则规定，对于选定的 $y^\\star$，我们必须选择能达到效用 $U^\\star$ 并满足预算约束的最小非负值 $x$。要达到效用 $U^\\star$，我们需要 $\\min(ax, by^\\star) \\ge U^\\^\\star$。这意味着 $ax \\ge U^\\star$ 和 $by^\\star \\ge U^\\star$。条件 $ax \\ge U^\\star$ 给出 $x \\ge U^\\star/a$。满足此条件的最小非负 $x$ 正是 $x^\\star = U^\\star/a$。根据 $U^\\star$ 的定义，这个 $x^\\star$ 的选择保证是预算可行的。\n\n这个过程根据问题的规定，提供了唯一的效用最大化组合 $(x^\\star, y^\\star)$ 和相关的效用 $U^\\star$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the utility maximization problem for a series of test cases.\n    The utility function is Leontief U(x,y) = min(ax, by), with y being discrete.\n    \"\"\"\n    # Define the test cases from the problem statement as (a, b, p_x, p_y, m).\n    test_cases = [\n        (1.0, 1.0, 2.0, 3.0, 20.0),\n        (2.0, 1.0, 3.0, 5.0, 11.0),\n        (1.5, 2.0, 1.0, 10.0, 7.0),\n        (2.0, 1.0, 3.0, 4.0, 9.5),\n        (3.0, 5.0, 2.0, 7.0, 100.0),\n    ]\n\n    results_as_strings = []\n    for a, b, px, py, m in test_cases:\n        # Handle the trivial case of zero income.\n        if m <= 0:\n            x_star, y_star, U_star = 0.0, 0, 0.0\n        else:\n            # Calculate the optimal 'y' as if it were a continuous variable.\n            # This is the point where the two components of the utility function,\n            # scaled by the budget, would be equal.\n            # y_cont_star = (a * m) / (b * p_x + a * p_y)\n            y_cont_star = (a * m) / (b * px + a * py)\n            \n            # The optimal integer y must be one of the two integers surrounding y_cont_star.\n            # Candidate 1: floor(y_cont_star)\n            y1 = int(np.floor(y_cont_star))\n            \n            # Calculate the maximum utility achievable with y1.\n            # This assumes all remaining budget is spent on x.\n            xmax1 = (m - py * y1) / px\n            U1 = min(a * xmax1, b * y1)\n            \n            # Initialize the optimal choice with the results from y1.\n            y_star = y1\n            U_star = U1\n            \n            # Candidate 2: ceil(y_cont_star) = y1 + 1\n            y2 = y1 + 1\n            \n            # Check if y2 is affordable within the budget.\n            if py * y2 <= m:\n                # If affordable, calculate its corresponding maximum utility.\n                xmax2 = (m - py * y2) / px\n                U2 = min(a * xmax2, b * y2)\n                \n                # Update the optimal choice if y2 yields a strictly higher utility.\n                # If utilities are equal, the tie-breaking rule requires choosing the\n                # smaller y, which is y1, so we do nothing in case of a tie.\n                if U2 > U1:\n                    y_star = y2\n                    U_star = U2\n            \n            # The final optimal value of x is determined by the utility level U_star.\n            # To get utility U_star, we must have ax >= U_star, so the smallest x is U_star / a.\n            if a > 0:\n                x_star = U_star / a\n            else: # Should not happen based on problem constraints (a>0)\n                x_star = 0.0\n\n        # Format the result triple [x*, y*, U*] as a string.\n        res_str = f\"[{x_star:.6f},{y_star},{U_star:.6f}]\"\n        results_as_strings.append(res_str)\n        \n    # Aggregate all result strings into the final required output format.\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "最后，我们将解决一个高度现实的问题：在包含分级定价和数据上限的方案中选择移动数据套餐。这个练习将我们从简单的线性预算约束推广到在真实市场中非常常见的分段线性约束 [@problem_id:2384169]。你将需要在每个定价层级内应用一阶优化条件，并设计一个算法来系统性地评估所有候选点和方案，以找到全局效用最大值。", "id": "2384169", "problem": "一个单一的代表性消费者选择移动数据套餐和数据使用量，以在预算约束下最大化其效用，该预算约束包含固定的订阅费、分级单价和一个硬性数据上限。该消费者拥有外生收入 $I \\in \\mathbb{R}_{++}$，其效用来源于数据使用量 $x \\in \\mathbb{R}_{+}$ 和复合标准商品 $y \\in \\mathbb{R}_{+}$。效用函数为\n$$\nu(x,y) \\;=\\; a \\,\\ln(x + s) \\;+\\; b \\,\\ln(y),\n$$\n其中 $a \\in \\mathbb{R}_{++}$ 和 $b \\in \\mathbb{R}_{++}$ 是偏好权重，$s \\in \\mathbb{R}_{++}$ 是一个小的平滑常数，以确保 $\\ln(x+s)$ 在 $x=0$ 时有定义。\n\n一个移动数据套餐 $j$ 由固定费用 $F_j \\in \\mathbb{R}_{+}$、硬性上限 $C_j \\in \\mathbb{R}_{+}$ 和一个具有断点的有限分级价格表定义\n$$\n0 \\;=\\; b_{j,0} \\;<\\; b_{j,1} \\;<\\; \\cdots \\;<\\; b_{j,K_j} \\;=\\; C_j,\n$$\n以及相应的单位价格 $p_{j,1},\\dots,p_{j,K_j} \\in \\mathbb{R}_{+}$，其中对于第 $k$ 级 $k \\in \\{1,\\dots,K_j\\}$，当使用量 $x \\in (b_{j,k-1}, b_{j,k}]$ 时，边际价格为 $p_{j,k}$。使用量为 $x$ 时的总数据支出是分段线性函数\n$$\n\\operatorname{Cost}_j(x) \\;=\\; \\sum_{k=1}^{K_j} p_{j,k} \\,\\max\\!\\left(\\min\\!\\left(x - b_{j,k-1},\\, b_{j,k}-b_{j,k-1}\\right),\\, 0\\right).\n$$\n套餐 $j$ 下的预算约束为\n$$\ny \\;=\\; I \\;-\\; F_j \\;-\\; \\operatorname{Cost}_j(x),\n$$\n由于对数项的存在，可行性要求为 $y \\in \\mathbb{R}_{++}$，并且由于硬性上限，数据使用量约束为 $0 \\le x \\le C_j$。消费者也可以选择“无套餐”的外部选项，用索引 $-1$ 表示，此时 $x=0$, $y=I$，效用为 $u(0,I)=a\\ln(s)+b\\ln(I)$。\n\n您的任务是计算最大化效用的最优套餐选择和数据使用量。该问题必须从第一性原理推导，并实现为一个完整的程序来解决一个固定的测试集。\n\n推导和算法设计的基础：\n- 效用最大化原则：选择 $(x,y)$ 以在线性预算约束和非负约束下最大化 $u(x,y)$。\n- 对数的凹性意味着，当 $a>0, b>0, s>0$ 时，$u(x,y)$ 在 $(x,y)$ 上是严格凹的。\n- 分段线性定价意味着，对于一个给定的套餐，$(x,y)$ 中的预算边界是分段线性的。\n- 带有拉格朗日乘子的 Kuhn–Tucker 条件对于刻画凹规划中的最优解是有效的。\n\n在套餐 $j$ 的任何价格等级 $k$ 内，边际价格是恒定的，对于 $x \\in (b_{j,k-1}, b_{j,k}]$，边际价格为 $p_{j,k}$。设截至 $b_{j,k-1}$ 的累计成本为\n$$\nS_{j,k-1} \\;=\\; \\sum_{i=1}^{k-1} p_{j,i}\\,\\left(b_{j,i} - b_{j,i-1}\\right),\n$$\n并定义\n$$\nA_{j,k} \\;=\\; I \\;-\\; F_j \\;-\\; S_{j,k-1} \\;+\\; p_{j,k}\\,b_{j,k-1}.\n$$\n假设在级别 $k$ 内存在内部解（即 $b_{j,k-1} < x < b_{j,k}$ 且 $y>0$），一阶最优性条件意味着\n$$\n\\frac{a}{x+s} \\;=\\; \\lambda\\,p_{j,k}, \n\\qquad \n\\frac{b}{y} \\;=\\; \\lambda,\n\\qquad \ny \\;=\\; A_{j,k} \\;-\\; p_{j,k}\\,x,\n$$\n这些条件结合起来，得到候选的内部解\n$$\nx^{\\star}_{j,k} \\;=\\; \\frac{\\frac{A_{j,k}}{p_{j,k}} \\;-\\; \\frac{b}{a}\\,s}{1 \\;+\\; \\frac{b}{a}}, \n\\qquad \ny^{\\star}_{j,k} \\;=\\; A_{j,k} \\;-\\; p_{j,k}\\,x^{\\star}_{j,k}.\n$$\n该候选解仅在 $b_{j,k-1} < x^{\\star}_{j,k} < b_{j,k}$ 且 $y^{\\star}_{j,k} > 0$ 时有效。否则，该级别的最优解位于边界上（$x=b_{j,k-1}$ 或 $x=b_{j,k}$）。对于一个给定的套餐，全局最优解是在以下各点评估的效用最大值：\n- 所有可行的内部候选解 $x^{\\star}_{j,k}$。\n- 所有分级边界 $x \\in \\{0, b_{j,1},\\dots,b_{j,K_j}\\}$，且满足 $y>0$。\n最后，在所有套餐和外部选项中，选择效用最高的选项。\n\n实现一个程序，对下面的每个测试用例，计算：\n- 所选套餐的索引（外部选项为 $-1$，否则为该测试用例中基于 $0$ 的套餐索引）。\n- 最优数据使用量 $x^{\\star}$。\n- 最优剩余资金 $y^{\\star}$。\n- 达到的效用 $u^{\\star}$。\n\n除了套餐索引是整数外，所有数值结果都必须以实数形式打印。为便于评估，在最终输出中将 $x^{\\star}$、$y^{\\star}$ 和 $u^{\\star}$ 四舍五入到 $6$ 位小数。您的程序应生成单行输出，包含一个以逗号分隔的列表，用方括号括起来（例如，$[r_1,r_2,\\dots]$），其中每个 $r_i$ 是相应测试用例的 $[\\text{plan\\_index}, x^{\\star}, y^{\\star}, u^{\\star}]$ 的 Python 列表表示。\n\n测试集：\n对于每个案例，元组列出了 $(I, a, b, s)$，然后是套餐集。每个套餐被指定为 $(F, C, \\text{tiers})$，其中 $\\text{tiers}$ 是一个 $(\\text{upper\\_breakpoint}, \\text{price})$ 对的序列，其断点严格递增并以数据上限结束。\n\n- 案例 1：$(I, a, b, s) = (\\,100,\\, 0.6,\\, 0.4,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0：$(F, C, \\text{tiers}) = (\\,10,\\, 50,\\, [\\,(10,\\, 2.0),\\, (30,\\, 1.0),\\, (50,\\, 3.0)\\,]\\,)$。\n  - 套餐 1：$(F, C, \\text{tiers}) = (\\,25,\\, 120,\\, [\\,(60,\\, 0.8),\\, (120,\\, 1.5)\\,]\\,)$。\n- 案例 2：$(I, a, b, s) = (\\,8,\\, 0.5,\\, 0.5,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0：$(F, C, \\text{tiers}) = (\\,10,\\, 20,\\, [\\,(10,\\, 1.5),\\, (20,\\, 2.0)\\,]\\,)$。\n  - 套餐 1：$(F, C, \\text{tiers}) = (\\,15,\\, 100,\\, [\\,(50,\\, 1.0),\\, (100,\\, 1.0)\\,]\\,)$。\n- 案例 3：$(I, a, b, s) = (\\,60,\\, 0.9,\\, 0.1,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0：$(F, C, \\text{tiers}) = (\\,5,\\, 5,\\, [\\,(5,\\, 1.0)\\,]\\,)$。\n  - 套餐 1：$(F, C, \\text{tiers}) = (\\,5,\\, 100,\\, [\\,(100,\\, 10.0)\\,]\\,)$。\n- 案例 4：$(I, a, b, s) = (\\,40,\\, 0.6,\\, 0.4,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0：$(F, C, \\text{tiers}) = (\\,0,\\, 20,\\, [\\,(10,\\, 0.5),\\, (20,\\, 5.0)\\,]\\,)$。\n  - 套餐 1：$(F, C, \\text{tiers}) = (\\,5,\\, 20,\\, [\\,(20,\\, 1.5)\\,]\\,)$。\n- 案例 5：$(I, a, b, s) = (\\,50,\\, 0.3,\\, 0.7,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0：$(F, C, \\text{tiers}) = (\\,45,\\, 100,\\, [\\,(100,\\, 0.1)\\,]\\,)$。\n  - 套餐 1：$(F, C, \\text{tiers}) = (\\,5,\\, 30,\\, [\\,(15,\\, 3.0),\\, (30,\\, 5.0)\\,]\\,)$。\n\n您的程序必须为每个案例计算最优选择并输出单行：\n- 该行必须是按案例划分的结果的 Python 列表字面量，其中每个案例结果的格式为 $[\\text{plan\\_index}, x^{\\star}, y^{\\star}, u^{\\star}]$，并且 $x^{\\star}$、$y^{\\star}$ 和 $u^{\\star}$ 四舍五入到 $6$ 位小数。", "solution": "用户要求解决一个涉及复杂预算约束的消费者效用最大化问题。我将首先验证问题陈述，如果有效，则继续进行基于原则的推导和算法求解。\n\n### 步骤 1：提取已知条件\n\n- **效用函数**：$u(x,y) = a \\ln(x + s) + b \\ln(y)$，其中数据使用量为 $x \\in \\mathbb{R}_{+}$，标准商品为 $y \\in \\mathbb{R}_{+}$。\n- **参数**：收入 $I \\in \\mathbb{R}_{++}$，偏好权重 $a, b \\in \\mathbb{R}_{++}$，以及平滑常数 $s \\in \\mathbb{R}_{++}$。\n- **套餐定义**：一个套餐 $j$ 由固定费用 $F_j \\in \\mathbb{R}_{+}$、硬性上限 $C_j \\in \\mathbb{R}_{+}$ 和一个具有断点 $0 = b_{j,0} < b_{j,1} < \\cdots < b_{j,K_j} = C_j$ 及相应边际价格 $p_{j,k} \\in \\mathbb{R}_{++}$（适用于使用量 $x \\in (b_{j,k-1}, b_{j,k}]$）的分级价格表定义。\n- **成本函数**：$\\operatorname{Cost}_j(x) = \\sum_{k=1}^{K_j} p_{j,k} \\max(\\min(x - b_{j,k-1}, b_{j,k}-b_{j,k-1}), 0)$。\n- **预算约束**：$y = I - F_j - \\operatorname{Cost}_j(x)$，受限于 $y > 0$ 和 $0 \\le x \\le C_j$。\n- **外部选项**：一个索引为 $-1$ 的选项，产生 $x=0$，$y=I$，效用为 $u(-1) = a\\ln(s) + b\\ln(I)$。\n- **优化策略提示**：一个套餐的全局最优解是通过比较在所有分级边界 $\\{0, b_{j,1}, \\dots, b_{j,K_j}\\}$ 和所有从每个级别的一阶条件导出的有效内部候选解 $x^{\\star}_{j,k}$ 处的效用而找到的。\n- **内部候选解公式**：对于级别 $k$，候选解为 $x^{\\star}_{j,k} = \\frac{\\frac{A_{j,k}}{p_{j,k}} - \\frac{b}{a}s}{1 + \\frac{b}{a}}$，其中 $A_{j,k} = I - F_j - \\sum_{i=1}^{k-1} p_{j,i}(b_{j,i} - b_{j,i-1}) + p_{j,k}b_{j,k-1}$。\n- **测试集**：提供了五个测试用例，包含所有参数的具体数值。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n对问题进行严格验证。\n\n1.  **科学依据**：该问题是微观经济学消费者理论中的一个标准练习。效用函数是 Cobb-Douglas 形式的一种变体，它是严格拟凹的。预算约束是分段线性的，这是现实世界定价方案中的一个常见特征。使用一阶（Kuhn-Tucker）条件的优化方法是解决此类问题的正确且标准的方法。该问题在根本上是合理的。\n2.  **适定性**：效用函数 $u(x,y)$ 在其定义域 $\\mathbb{R}_{++} \\times \\mathbb{R}_{++}$ 上是连续且严格凹的。对于每个套餐 $j$，可行的消费束 $(x,y)$ 集合构成一个凸集。由于 $\\ln(y)$ 项的存在，要求 $y>0$ 意味着可行集不是闭集，但 $y$ 的 Inada 条件（当 $y$ 趋近于零时，$y$ 的边际效用趋近于无穷大）确保任何最优解都必须有 $y^* > 0$。因此，由于严格凹性，最优解存在且唯一。该问题是适定的。\n3.  **客观性**：所有术语都经过了数学上的精确定义。问题陈述客观，没有歧义或主观内容。\n4.  **完整性**：为每个测试用例提供了所有必需的数据（$I, a, b, s$ 和套餐结构）。问题是自洽的。所提供的公式在数学上是一致的。\n5.  **结构与可行性**：问题结构是合乎逻辑的。它要求在一个由几个线性段组成的域上找到一个函数的最大值。所提出的检查段内部和边界（拐点）的方法是为给定套餐寻找全局最优解的完整方法。参数在现实的数值范围内。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。这是一个定义明确、可解决的计算经济学问题。我现在将提供一个完整的解决方案。\n\n### 基于原则的解决方案设计\n\n问题是在一个由分段线性成本函数定义的预算集上最大化一个严格凹的效用函数 $u(x,y)$。消费者的最优解通过一个两阶段过程找到：首先，对于每个可用的套餐 $j$，找到最优消费束 $(x_j^*, y_j^*)$ 和相应的最大效用 $u_j^*$；其次，比较所有套餐和外部选项的这些效用，以确定全局最优解。\n\n**阶段 1：求解单个套餐 $j$**\n\n对于一个给定的套餐 $j$，预算集为 $\\{(x,y) | y = I - F_j - \\operatorname{Cost}_j(x), 0 \\le x \\le C_j, y > 0 \\}$。总成本函数 $\\operatorname{Cost}_j(x)$ 是连续且分段线性的，在分级断点 $b_{j,k}$ 处有拐点。因此，$(x,y)$ 空间中的预算边界也是分段线性的。\n\n一个凹函数在此类集合上的最大值必须位于以下两种位置之一：\n1.  **一个拐点**：这些是对应于分级边界处数据使用量的点，$x \\in \\{b_{j,0}, b_{j,1}, \\dots, b_{j,K_j}\\}$。\n2.  **一个线性段的内部点**：在给定的级别 $k$ 内，对于 $x \\in (b_{j,k-1}, b_{j,k})$，数据的边际价格恒定为 $p_{j,k}$。预算约束变为线性：$y = A_{j,k} - p_{j,k}x$。该段内的最优解（如果存在）通过求解拉格朗日函数的一阶条件得到，从而得出问题陈述中给出的候选解 $x_{j,k}^{\\star}$。\n\n求解单个套餐 $j$ 的算法如下：\n\n1.  **汇集候选点**：创建一个最优数据使用量 $x$ 的候选值集合。\n    -   将所有分级边界添加到此集合中：$\\{0, b_{j,1}, \\dots, b_{j,K_j}\\}$。注意 $b_{j,0}=0$ 且 $b_{j,K_j}=C_j$。\n    -   对于每个级别 $k \\in \\{1, \\dots, K_j\\}$：\n        -   计算线性预算段的参数：恒定价格 $p_{j,k}$ 和有效收入截距 $A_{j,k}$。\n        -   使用公式计算内部候选解 $x_{j,k}^{\\star}$：\n            $$\n            x^{\\star}_{j,k} = \\frac{(a/p_{j,k}) A_{j,k} - b s}{a+b}\n            $$\n        -   如果此候选解严格位于该级别的界限内，即 $b_{j,k-1} < x_{j,k}^{\\star} < b_{j,k}$，则将其添加到候选点集合中。\n\n2.  **评估候选点**：遍历唯一的候选点集合 $x_{cand}$。\n    -   对于每个 $x_{cand}$，计算总支出 $\\operatorname{Cost}_j(x_{cand})$ 和标准商品的剩余收入 $y_{cand} = I - F_j - \\operatorname{Cost}_j(x_{cand})$。\n    -   检查可行性：只有当固定费用可负担 ($I > F_j$) 且所选消费束产生的标准商品数量为正 ($y_{cand} > 0$) 时，该套餐才是可行的。效用函数中的 $\\ln(y)$ 项已经强制执行了这一点；任何 $y_{cand} \\le 0$ 的候选解都会被隐式拒绝，因为它产生的效用为 $-\\infty$。\n    -   如果可行 ($y_{cand} > 0$)，计算效用 $u(x_{cand}, y_{cand}) = a \\ln(x_{cand} + s) + b \\ln(y_{cand})$。\n\n3.  **确定套餐最优解**：套餐 $j$ 的最优束 $(x_j^*, y_j^*)$ 是产生最高效用的可行候选对 $(x_{cand}, y_{cand})$。该套餐的最大效用为 $u_j^*$。\n\n**阶段 2：全局优化**\n\n1.  **建立基准**：计算“无套餐”外部选项的效用，其中 $x_{-1}^*=0$，$y_{-1}^*=I$。效用为 $u_{-1}^* = a \\ln(s) + b \\ln(I)$。这作为初始的最佳情况。\n\n2.  **迭代与比较**：对于每个套餐 $j=0, 1, \\dots$，执行阶段 1 以找到其最优效用 $u_j^*$。将其与迄今为止找到的当前最高效用进行比较。如果 $u_j^*$ 更大，则套餐 $j$ 成为新的最佳选择，并记录其最优束 $(x_j^*, y_j^*)$ 和效用 $u_j^*$。\n\n3.  **最终结果**：评估所有套餐后，记录的最佳选择即为消费者的全局最优解。最终输出包括此最优套餐的索引（或外部选项的 $-1$）、最优数据使用量 $x^*$、最优标准商品消费量 $y^*$ 和最大化效用 $u^*$。\n\n这种系统性搜索保证能找到全局最大值，因为它考虑了具有分段线性边界的凹规划问题所有可能的最优解类型。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer utility maximization problem for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"params\": (100, 0.6, 0.4, 0.1),\n            \"plans\": [\n                (10, 50, [(10, 2.0), (30, 1.0), (50, 3.0)]),\n                (25, 120, [(60, 0.8), (120, 1.5)]),\n            ],\n        },\n        # Case 2\n        {\n            \"params\": (8, 0.5, 0.5, 0.1),\n            \"plans\": [\n                (10, 20, [(10, 1.5), (20, 2.0)]),\n                (15, 100, [(50, 1.0), (100, 1.0)]),\n            ],\n        },\n        # Case 3\n        {\n            \"params\": (60, 0.9, 0.1, 0.1),\n            \"plans\": [\n                (5, 5, [(5, 1.0)]),\n                (5, 100, [(100, 10.0)]),\n            ],\n        },\n        # Case 4\n        {\n            \"params\": (40, 0.6, 0.4, 0.1),\n            \"plans\": [\n                (0, 20, [(10, 0.5), (20, 5.0)]),\n                (5, 20, [(20, 1.5)]),\n            ],\n        },\n        # Case 5\n        {\n            \"params\": (50, 0.3, 0.7, 0.1),\n            \"plans\": [\n                (45, 100, [(100, 0.1)]),\n                (5, 30, [(15, 3.0), (30, 5.0)]),\n            ],\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        I, a, b, s = case[\"params\"]\n        plans = case[\"plans\"]\n\n        # Initialize with the outside option (\"no plan\")\n        best_option = {\n            \"plan_index\": -1,\n            \"x\": 0.0,\n            \"y\": I,\n            \"u\": a * np.log(s) + b * np.log(I),\n        }\n\n        for j, plan_spec in enumerate(plans):\n            F, C, tiers = plan_spec\n\n            if I < F:\n                continue  # Fixed fee is unaffordable\n\n            breakpoints = [0.0] + [t[0] for t in tiers]\n            prices = [t[1] for t in tiers]\n\n            # --- Stage 1: Find best option for this plan ---\n            \n            # 1. Assemble candidate points for x\n            candidate_x = set(breakpoints)\n\n            cumulative_cost_at_prev_breakpoint = 0.0\n            for k in range(len(prices)):\n                p_k = prices[k]\n                b_prev = breakpoints[k]\n                b_curr = breakpoints[k+1]\n\n                # S_{j,k-1} from problem description\n                S_prev = cumulative_cost_at_prev_breakpoint\n                # A_{j,k} from problem description\n                A_k = I - F - S_prev + p_k * b_prev\n\n                # Calculate interior candidate x_star\n                # Using formula: x_star = (a*A/p - b*s)/(a+b)\n                if p_k > 0:\n                    numerator = a * A_k / p_k - b * s\n                    if numerator > 0:\n                        x_star = numerator / (a + b)\n                        if b_prev < x_star < b_curr:\n                            candidate_x.add(x_star)\n                \n                # Update cumulative cost for the next tier\n                cumulative_cost_at_prev_breakpoint += p_k * (b_curr - b_prev)\n\n            plan_best_u = -np.inf\n            plan_best_x = 0.0\n            plan_best_y = 0.0\n\n            # 2. Evaluate all candidates\n            for x_cand in sorted(list(candidate_x)):\n                \n                # Calculate cost for x_cand\n                cost = 0.0\n                x_remaining = x_cand\n                for k in range(len(prices)):\n                    tier_start = breakpoints[k]\n                    tier_end = breakpoints[k+1]\n                    tier_price = prices[k]\n\n                    if x_remaining <= 0:\n                        break\n                    \n                    usage_in_tier = min(x_remaining, tier_end - tier_start)\n                    cost += usage_in_tier * tier_price\n                    x_remaining -= usage_in_tier\n                \n                y_cand = I - F - cost\n                \n                # Check feasibility and calculate utility\n                if y_cand > 0:\n                    u_cand = a * np.log(x_cand + s) + b * np.log(y_cand)\n                    if u_cand > plan_best_u:\n                        plan_best_u = u_cand\n                        plan_best_x = x_cand\n                        plan_best_y = y_cand\n\n            # --- Stage 2: Compare plan's best with overall best ---\n            if plan_best_u > best_option[\"u\"]:\n                best_option = {\n                    \"plan_index\": j,\n                    \"x\": plan_best_x,\n                    \"y\": plan_best_y,\n                    \"u\": plan_best_u,\n                }\n\n        results.append([\n            best_option[\"plan_index\"],\n            round(best_option[\"x\"], 6),\n            round(best_option[\"y\"], 6),\n            round(best_option[\"u\"], 6),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}