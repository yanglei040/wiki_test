{"hands_on_practices": [{"introduction": "在基础微观经济学中，我们通常假设价格是恒定的，从而得到一条线性的预算线。然而，现实世界中的定价策略要复杂得多。本练习将探讨“买一送一”等促销活动如何改变预算约束的形状，使其变为非线性。通过精确推导这种分段预算集，您将锻炼仔细分析和建模现实世界经济情境的能力。[@problem_id:2378669]", "id": "2378669", "problem": "一位消费者选择两种完全可分商品，$x_1$ 和 $x_2$ 的数量，面临非负价格 $p_1$ 和 $p_2$ 以及货币收入 $m$。预算集是在该商店公布的定价规则下，总支出不超过 $m$ 的所有非负商品组合的集合。商店对商品 $x_1$ 提供买一送一（BOGO）促销，但有上限：对于购买的每单位 $x_1$，在最多支付 $K$ 单位的范围内，消费者有权免费获得等量的额外 $x_1$。超过此上限后，额外的 $x_1$ 单位不再产生免费单位，所有后续单位都必须按公布价格 $p_1$ 支付。假设两种商品都是完全可分的，因此促销活动按比例适用。\n\n仅从预算集的定义和所描述的促销活动出发，推导预算集横轴截距（即当 $x_2=0$ 时可获得的最大 $x_1$）作为 $m$、$p_1$ 和 $K$ 的函数表达式。然后，当 $p_1 = 4$，$p_2 = 5$，$m = 90$，$K = 8$ 时，对该截距进行数值计算。提供截距的最终数值。无需四舍五入。", "solution": "在尝试任何解答之前，我们先对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 商品：两种完全可分的商品，$x_1$ 和 $x_2$。\n- 价格：非负价格 $p_1$ 和 $p_2$。\n- 收入：货币收入 $m$。\n- 预算集：总支出不超过 $m$ 的非负商品组合 $(x_1, x_2)$ 的集合。\n- 促销：商品 $x_1$ 享受买一送一（BOGO）优惠。每购买一单位 $x_1$，即可免费获赠等量商品。\n- 促销上限：BOGO促销适用于最多支付 $K$ 单位的 $x_1$。超出部分，所有后续单位的 $x_1$ 必须以价格 $p_1$ 购买。\n- 可分性：对于完全可分的商品，促销按比例适用。\n- 目标1：推导预算集横轴截距（当 $x_2=0$ 时的最大 $x_1$）作为 $m$、$p_1$ 和 $K$ 的函数表达式。\n- 目标2：为 $p_1 = 4$，$p_2 = 5$，$m = 90$，$K = 8$ 计算该截距的数值。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它描述了一个非线性预算约束，这是微观经济学消费者理论中的一个标准课题。问题设置清晰，内部一致，并包含了推导出唯一解所需的所有必要信息。语言精确，没有主观看法。因此，该问题被认定为**有效**。\n\n**步骤3：结论与行动**\n问题有效。将提供完整解答。\n\n目标是求出当商品 $x_2$ 的数量为零（即 $x_2 = 0$）时，可获得商品 $x_1$ 的最大数量。这就是预算集的横轴截距。商品的总支出不能超过收入 $m$。当 $x_2=0$ 时，全部收入 $m$ 都可以用于购买商品 $x_1$。因此，我们必须确定用支出 $m$ 可以获得的最大 $x_1$ 数量。\n\n首先，我们将获得第一种商品总量 $x_1$ 所需的支出 $E_1(x_1)$ 进行形式化。定价规则是分段的。\n\n第1部分：BOGO促销机制\n促销活动规定，每支付一单位 $x_1$ 的费用，即可免费获得一单位。这意味着要获得总量为 $x_1$ 的商品，消费者只需支付 $x_1/2$ 单位的费用。因此，成本为 $E_1(x_1) = p_1 \\cdot \\frac{x_1}{2}$。\n此促销活动在支付的单位数量不超过 $K$ 时有效。支付的单位数量为 $x_1/2$。因此，此定价规则适用于 $x_1/2 \\le K$，即 $0 \\le x_1 \\le 2K$。\n\n第2部分：标准定价机制\n如果消费者希望获得超过 $2K$ 单位的 $x_1$，他们必须首先用完BOGO促销的额度。获得前 $2K$ 单位 $x_1$ 的成本是支付 $K$ 单位的成本，即 $p_1 K$。\n对于任何超过 $2K$ 的数量，即 $x_1 > 2K$，额外的单位 $(x_1 - 2K)$ 必须按标准价格 $p_1$ 支付。这些额外单位的支出为 $p_1 (x_1 - 2K)$。\n获得数量 $x_1 > 2K$ 的总支出是前 $2K$ 单位的成本与额外单位成本之和：\n$$E_1(x_1) = p_1 K + p_1 (x_1 - 2K) = p_1 K + p_1 x_1 - 2p_1 K = p_1 x_1 - p_1 K = p_1 (x_1 - K)$$\n\n结合这两个部分，获得 $x_1$ 的支出函数为：\n$$ E_1(x_1) = \\begin{cases} \\frac{p_1 x_1}{2} & \\text{若 } 0 \\le x_1 \\le 2K \\\\ p_1(x_1 - K) & \\text{若 } x_1 > 2K \\end{cases} $$\n\n为了找到横轴截距，我们将总支出设为等于收入 $m$（因为 $x_2=0$），然后求解 $x_1$。解取决于 $m$ 相对于用完BOGO促销额度所需支出 $p_1 K$ 的值。\n\n情况A：$m \\le p_1 K$\n如果收入不足以支付 $K$ 单位的费用，消费者将完全在BOGO促销机制内操作。通过将此机制下的支出设为等于 $m$，可以找到 $x_1$ 的最大数量：\n$$\\frac{p_1 x_1}{2} = m$$\n$$x_1 = \\frac{2m}{p_1}$$\n我们必须验证此结果是否与条件 $x_1 \\le 2K$ 一致。\n由于 $m \\le p_1 K$，我们有 $\\frac{m}{p_1} \\le K$，因此 $\\frac{2m}{p_1} \\le 2K$。条件得到满足。\n\n情况B：$m > p_1 K$\n如果收入大于用完促销额度的成本，消费者将获得超过 $2K$ 单位的 $x_1$。支出由函数的第二部分给出：\n$$p_1(x_1 - K) = m$$\n$$x_1 - K = \\frac{m}{p_1}$$\n$$x_1 = K + \\frac{m}{p_1}$$\n我们必须验证此结果是否与条件 $x_1 > 2K$ 一致。\n由于 $m > p_1 K$，我们有 $\\frac{m}{p_1} > K$，这意味着 $K + \\frac{m}{p_1} > K+K = 2K$。条件得到满足。\n\n横轴截距 $x_{1, \\text{intercept}}$ 的通用表达式为：\n$$ x_{1, \\text{intercept}} = \\begin{cases} \\frac{2m}{p_1} & \\text{若 } m \\le p_1 K \\\\ K + \\frac{m}{p_1} & \\text{若 } m > p_1 K \\end{cases} $$\n问题的第一个部分到此结束。\n\n对于第二部分，我们必须使用给定的数值计算此截距：$p_1 = 4$，$p_2 = 5$，$m = 90$，以及 $K = 8$。$p_2$ 的值与此计算无关。\n首先，我们通过比较 $m$ 和 $p_1 K$ 来确定适用哪种情况：\n$$m = 90$$\n$$p_1 K = 4 \\times 8 = 32$$\n由于 $90 > 32$，我们有 $m > p_1 K$，这对应于情况B。\n截距的公式是 $x_{1, \\text{intercept}} = K + \\frac{m}{p_1}$。\n代入数值：\n$$x_{1, \\text{intercept}} = 8 + \\frac{90}{4}$$\n$$x_{1, \\text{intercept}} = 8 + 22.5$$\n$$x_{1, \\text{intercept}} = 30.5$$\n可获得商品 $x_1$ 的最大数量是 $30.5$。", "answer": "$$\\boxed{30.5}$$"}, {"introduction": "预算约束不仅适用于商品购买，也适用于时间分配等更广泛的决策。本练习将研究劳动-闲暇选择，其中个人的预算来自其时间禀赋和工资率。我们还将引入一个现实中的关键因素——累进税制，它会产生一个“扭折”或分段线性的预算线。这个练习将理论（效用最大化）与实践（应对不同税收等级）相结合，这是公共财政和个人经济决策中的一个核心挑战。[@problem_id:2378657]", "id": "2378657", "problem": "考虑一个代表性个体，在产生分段线性预算约束的累进所得税下做出劳动-休闲选择。时间是稀缺资源。该个体拥有固定的时间禀赋 $T$ 小时，选择劳动时间 $h \\in [0,T]$，消费 $c$，并享受休闲 $s = T - h$。（税前）工资率为每小时 $w$，且该个体拥有非劳动收入 $b$。该个体的偏好由柯布-道格拉斯（Cobb–Douglas）效用函数 $U(c,s) = c^{\\alpha} s^{1-\\alpha}$ 表示，其中 $\\alpha \\in (0,1)$。\n\n政府根据分级税率表对劳动收入征收累进税。设税前劳动收入为 $y = w h$。税收表由一系列收入级距阈值 $\\{K_0, K_1, \\dots, K_{N}\\}$（其中 $K_0 = 0$ 且 $K_{N} = +\\infty$）和相应的边际税率 $\\{t_1, t_2, \\dots, t_{N}\\}$ 定义，这些税率适用于阈值之间的收入增量。所有边际税率都必须以小数形式提供（例如，使用 $0.2$ 而不是 $20\\%$）。应缴税款的计算方式为：较低级距的累计税额加上当前级距内收入的边际税额。消费由 $c = b + y - \\mathcal{T}(y)$ 给出，其中 $\\mathcal{T}(y)$ 是根据税收表定义的收入 $y$ 所应缴的总税额。\n\n您的任务是：\n\n- 仅使用以下基本原理：(i) 预算约束的定义 $c = b + y - \\mathcal{T}(y)$，其中 $y = w h$，$\\mathcal{T}(y)$ 由分段边际税率和阈值定义；(ii) 休闲的定义 $s = T - h$；以及 (iii) 适用时，将休闲与消费之间的边际替代率等同于某个级距内的税后工资的内部最优解一阶条件。非内部最优解可能出现在拐点或端点 $h=0$ 或 $h=T$ 处。\n- 对于每个级距 $i \\in \\{1,\\dots,N\\}$，边际税率 $t_i$ 适用于 $y \\in [K_{i-1},K_i)$，应缴总税款可写为较低级距的税收总和加上 $t_i$ 乘以当前级距内的收入额。这意味着一个分段线性的预算约束，其在级距 $i$ 内的斜率等于税后工资 $w(1 - t_i)$。\n- 您的程序必须为每个测试用例确定效用最大化的劳动时间选择 $h^\\star \\in [0,T]$。这需要检查理论所暗示的所有候选解：(a) 每个级距内的内部解，其中一阶条件成立，前提是所隐含的收入 $y = w h$ 位于该级距的收入范围内；(b) 对应于阈值 $\\{K_1,\\dots,K_{N-1}\\}$ 且在时间禀赋内可达到的所有拐点，以及端点 $h=0$ 和 $h=T$。对于每个候选的 $h$，计算 $c = b + w h - \\mathcal{T}(w h)$、$s = T - h$ 和 $U(c,s) = c^{\\alpha} s^{1-\\alpha}$，然后选择使 $U(c,s)$ 最大化的候选解。\n- 所有输入均为纯数值；除了 $T$ 和 $h$ 的单位是小时外，没有其他物理单位。所有输出必须是数值。不涉及角度。百分比必须以小数形式提供。\n\n待实现的测试套件：\n\n提供以下五个测试用例；在每个用例中，$K$ 列出阈值，$t$ 列出相应的边际税率：\n\n- 用例 1：$T = 16$, $w = 25$, $b = 10$, $\\alpha = 0.4$, $K = [0, 200, 400, +\\infty)$, $t = [0.0, 0.2, 0.35]$.\n- 用例 2：$T = 24$, $w = 20$, $b = 300$, $\\alpha = 0.2$, $K = [0, 100, 200, +\\infty)$, $t = [0.5, 0.7, 0.9]$.\n- 用例 3：$T = 8$, $w = 30$, $b = 0$, $\\alpha = 0.5$, $K = [0, +\\infty)$, $t = [0.25]$.\n- 用例 4：$T = 6$, $w = 40$, $b = 0$, $\\alpha = 0.5$, $K = [0, 80, 120, +\\infty)$, $t = [0.0, 0.5, 0.6]$.\n- 用例 5：$T = 12$, $w = 15$, $b = 0$, $\\alpha = 0.9$, $K = [0, 60, 120, +\\infty)$, $t = [0.1, 0.2, 0.4]$.\n\n最终输出格式：\n\n- 对于每个测试用例，输出一个列表 $[h^\\star, c^\\star, s^\\star, U^\\star]$，其中 $h^\\star$、$c^\\star$、$s^\\star$ 和 $U^\\star$ 是精确到六位小数的浮点数。\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，格式为一个由逗号分隔的列表，并用方括号括起来，每个用例本身也表示为一个列表。例如：“[[h1,c1,s1,U1],[h2,c2,s2,U2],...]”，每个数字都精确到六位小数，无额外文本。", "solution": "我们从基本定义开始。个体选择劳动时间 $h \\in [0,T]$，休闲时间为 $s = T - h$，税前劳动收入为 $y = w h$，消费为 $c = b + y - \\mathcal{T}(y)$。偏好由柯布-道格拉斯（Cobb–Douglas）效用函数 $U(c,s) = c^{\\alpha} s^{1-\\alpha}$ 给出，参数 $\\alpha \\in (0,1)$。\n\n累进税表由阈值 $\\{K_0,\\dots,K_N\\}$（其中 $K_0 = 0$ 且 $K_N = +\\infty$）和级距边际税率 $\\{t_1,\\dots,t_N\\}$ 定义。在级距 $i$ 内，对于 $y \\in [K_{i-1}, K_i)$，总税额可以表示为\n$$\n\\mathcal{T}(y) \\;=\\; \\underbrace{\\sum_{j=1}^{i-1} t_j (K_j - K_{j-1})}_{\\text{截至 } K_{i-1} \\text{ 的累积税额}} \\;+\\; t_i \\, (y - K_{i-1}) \\;=\\; C_{i-1} + t_i y - t_i K_{i-1},\n$$\n其中 $C_{i-1} = \\sum_{j=1}^{i-1} t_j (K_j - K_{j-1})$ 是在较低阈值 $K_{i-1}$ 处的累积税额。因此，在级距 $i$ 内，\n$$\nc \\;=\\; b + y - \\mathcal{T}(y) \\;=\\; \\underbrace{b - C_{i-1} + t_i K_{i-1}}_{B_i} \\;+\\; (1 - t_i) y,\n$$\n这是 $y$（因此也是 $h$）的线性函数，其斜率等于级距 $i$ 内的税后工资，由 $w_i = w (1 - t_i)$ 给出。因此，对于级距 $i$ 内的 $y = w h$，\n$$\nc(h) \\;=\\; B_i + w_i h\n\\quad\\text{和}\\quad\ns(h) \\;=\\; T - h.\n$$\n\n对于给定级距 $i$ 内的内部解，一阶条件使边际替代率等于相关的税后工资：\n$$\n\\text{MRS}_{s,c} \\;=\\; \\frac{\\partial U/\\partial s}{\\partial U/\\partial c} \\;=\\; \\frac{(1-\\alpha)}{\\alpha} \\,\\frac{c}{s} \\;=\\; w_i.\n$$\n代入 $c = B_i + w_i h$ 和 $s = T - h$ 可得\n$$\n\\frac{(1-\\alpha)}{\\alpha}\\,\\frac{B_i + w_i h}{T - h} \\;=\\; w_i.\n$$\n求解 $h$ 可得到级距 $i$ 内的候选内部解：\n$$\nh_i^\\circ \\;=\\; \\alpha T \\;-\\; \\frac{1-\\alpha}{w_i}\\, B_i.\n$$\n这个 $h_i^\\circ$ 仅在可行时有效，即可行性意味着它满足 $0 \\le h_i^\\circ \\le T$ 且其隐含的收入 $y_i^\\circ = w h_i^\\circ$ 位于该级距的收入范围之内，即 $K_{i-1} \\le y_i^\\circ < K_i$。如果候选解不满足这些条件，则最优解不可能位于该级距的内部。\n\n除了内部候选解，最优解也可能出现在拐点处，因为预算约束的斜率在阈值 $\\{K_1,\\dots,K_{N-1}\\}$ 处发生变化。每个拐点对应劳动时间 $h_k = K_k / w$，前提是 $h_k \\le T$。端点 $h=0$ 和 $h=T$ 也是候选解。对于每个候选的 $h$，计算：\n- $y = w h$，\n- 根据税收表计算总税额 $\\mathcal{T}(y)$，\n- $c = b + y - \\mathcal{T}(y)$，\n- $s = T - h$，\n- $U(c,s) = c^{\\alpha} s^{1-\\alpha}$。\n\n在所有候选解中，选择使 $U(c,s)$ 最大化的 $h^\\star$。如果多个候选解产生的效用值在数值容差范围内相等，为了确定性，可以选择具有最小 $h$ 的候选解。\n\n算法设计：\n- 为每个级距 $i$ 预计算累积税额 $C_{i-1}$、常数 $B_i = b - C_{i-1} + t_i K_{i-1}$ 和税后工资 $w_i = w(1 - t_i)$。\n- 生成由以下部分组成的候选集：\n  - 内部候选解 $h_i^\\circ = \\alpha T - \\frac{1-\\alpha}{w_i} B_i$，限制条件为 $0 \\le h_i^\\circ \\le T$ 和 $K_{i-1} \\le w h_i^\\circ < K_i$。\n  - 对于所有阈值，拐点候选解为 $h_k = K_k / w$，且 $h_k \\le T$。\n  - 端点 $h=0$ 和 $h=T$。\n- 在所有候选解处评估 $U(c(h), s(h))$ 并选择最大化者。\n\n此过程独立应用于以下五个测试用例中的每一个：\n- 用例 1：$T = 16$, $w = 25$, $b = 10$, $\\alpha = 0.4$, $K = [0, 200, 400, +\\infty)$, $t = [0.0, 0.2, 0.35]$.\n- 用例 2：$T = 24$, $w = 20$, $b = 300$, $\\alpha = 0.2$, $K = [0, 100, 200, +\\infty)$, $t = [0.5, 0.7, 0.9]$.\n- 用例 3：$T = 8$, $w = 30$, $b = 0$, $\\alpha = 0.5$, $K = [0, +\\infty)$, $t = [0.25]$.\n- 用例 4：$T = 6$, $w = 40$, $b = 0$, $\\alpha = 0.5$, $K = [0, 80, 120, +\\infty)$, $t = [0.0, 0.5, 0.6]$.\n- 用例 5：$T = 12$, $w = 15$, $b = 0$, $\\alpha = 0.9$, $K = [0, 60, 120, +\\infty)$, $t = [0.1, 0.2, 0.4]$.\n\n程序实现了这种候选解评估方法，为每个用例计算最优的 $[h^\\star, c^\\star, s^\\star, U^\\star]$，将每个值四舍五入到恰好六位小数，并按照规定格式将结果打印为单行列表的列表。", "answer": "```python\nimport numpy as np\n\ndef compute_cumulative_tax_thresholds(K, t):\n    \"\"\"\n    Given thresholds K (length N+1 with K[0]=0, K[N]=inf) and marginal rates t (length N),\n    compute cumulative tax up to each lower threshold K[i] for bracket i (i from 0..N-1).\n    Returns list C where C[i] = cumulative tax up to K[i] (i.e., sum_{j< i} t[j]*(K[j+1]-K[j])).\n    \"\"\"\n    N = len(t)\n    C = [0.0] * (N + 1)\n    cum = 0.0\n    for i in range(1, N + 1):\n        # Tax in bracket i-1 fully applied up to K[i]\n        width = K[i] - K[i - 1]\n        if np.isfinite(width):\n            cum += t[i - 1] * width\n        else:\n            # Last width is infinite; do not add to cumulative because it's unbounded\n            cum += 0.0\n        C[i] = cum\n    return C\n\ndef total_tax(y, K, t):\n    \"\"\"\n    Compute total tax owed given income y, thresholds K, and marginal rates t.\n    \"\"\"\n    N = len(t)\n    tax = 0.0\n    remaining = y\n    for i in range(N):\n        lower = K[i]\n        upper = K[i + 1]\n        if remaining <= lower:\n            break\n        taxable = min(remaining, upper) - lower\n        if taxable > 0:\n            tax += t[i] * taxable\n    return tax\n\ndef evaluate_candidates(case):\n    T = float(case[\"T\"])\n    w = float(case[\"w\"])\n    b = float(case[\"b\"])\n    alpha = float(case[\"alpha\"])\n    # Ensure K and t are numpy arrays, last K can be inf\n    K = np.array(case[\"K\"], dtype=float)\n    t_rates = np.array(case[\"t\"], dtype=float)\n    N = len(t_rates)\n    # Precompute cumulative taxes at thresholds\n    C = compute_cumulative_tax_thresholds(K, t_rates)  # length N+1\n    # Generate candidates: endpoints\n    candidates = [0.0, T]\n    # Kinks: K[1..N-1]\n    for j in range(1, len(K) - 1):\n        h_kink = K[j] / w\n        if h_kink <= T + 1e-12:\n            candidates.append(max(0.0, min(T, h_kink)))\n    # Interior candidates within each bracket\n    for i in range(N):\n        lower = K[i]\n        upper = K[i + 1]\n        wi = w * (1.0 - t_rates[i])\n        # If after-tax wage is effectively zero, skip interior candidate\n        if wi <= 1e-12:\n            continue\n        Bi = b - C[i] + t_rates[i] * K[i]\n        h_int = alpha * T - (1.0 - alpha) * Bi / wi\n        # Feasibility: within [0,T] and income within bracket\n        if h_int < -1e-12 or h_int > T + 1e-12:\n            continue\n        y_int = w * h_int\n        lower_ok = y_int >= lower - 1e-9\n        upper_ok = (y_int < upper - 1e-9) or not np.isfinite(upper)\n        if lower_ok and upper_ok:\n            # Clamp to [0,T]\n            h_int = max(0.0, min(T, h_int))\n            candidates.append(h_int)\n    # Deduplicate candidates with tolerance\n    candidates_sorted = sorted(candidates)\n    uniq = []\n    for h in candidates_sorted:\n        if not uniq or abs(h - uniq[-1]) > 1e-9:\n            uniq.append(h)\n    # Evaluate utility and select best\n    best = None\n    best_tuple = None\n    for h in uniq:\n        y = w * h\n        tax = total_tax(y, K, t_rates)\n        c = b + y - tax\n        s = T - h\n        # Utility: c^alpha * s^(1-alpha); by convention, if c<=0 or s<=0, utility is 0\n        if c <= 0.0 or s <= 0.0:\n            U = 0.0\n        else:\n            U = (c ** alpha) * (s ** (1.0 - alpha))\n        # Select by utility, tie-break by smallest h\n        sel_key = (U, -h)  # since we want smallest h on tie, use -h with max\n        if (best is None) or (sel_key > best):\n            best = sel_key\n            best_tuple = (h, c, s, U)\n    # Round to six decimals\n    h_star, c_star, s_star, U_star = best_tuple\n    return [round(h_star, 6), round(c_star, 6), round(s_star, 6), round(U_star, 6)]\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\"T\": 16.0, \"w\": 25.0, \"b\": 10.0, \"alpha\": 0.4,\n         \"K\": [0.0, 200.0, 400.0, np.inf], \"t\": [0.0, 0.2, 0.35]},\n        # Case 2\n        {\"T\": 24.0, \"w\": 20.0, \"b\": 300.0, \"alpha\": 0.2,\n         \"K\": [0.0, 100.0, 200.0, np.inf], \"t\": [0.5, 0.7, 0.9]},\n        # Case 3\n        {\"T\": 8.0, \"w\": 30.0, \"b\": 0.0, \"alpha\": 0.5,\n         \"K\": [0.0, np.inf], \"t\": [0.25]},\n        # Case 4\n        {\"T\": 6.0, \"w\": 40.0, \"b\": 0.0, \"alpha\": 0.5,\n         \"K\": [0.0, 80.0, 120.0, np.inf], \"t\": [0.0, 0.5, 0.6]},\n        # Case 5\n        {\"T\": 12.0, \"w\": 15.0, \"b\": 0.0, \"alpha\": 0.9,\n         \"K\": [0.0, 60.0, 120.0, np.inf], \"t\": [0.1, 0.2, 0.4]},\n    ]\n    results = []\n    for case in test_cases:\n        results.append(evaluate_candidates(case))\n\n    # Format as a single-line list of lists with exactly six decimals\n    def fmt_num(x):\n        return f\"{x:.6f}\"\n\n    inner = []\n    for res in results:\n        inner.append(\"[\" + \",\" + \",\".join(fmt_num(v) for v in res)[1:] + \"]\" if False else \"[\" + \",\".join(fmt_num(v) for v in res) + \"]\")\n    output = \"[\" + \",\".join(inner) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "现代金融环境日益复杂，预算约束也需要考虑不确定性和风险。本练习将探讨一个前沿情景：消费者的部分购买力来自一种价格波动的加密货币资产。您需要根据一项“稳健偿付能力”规则来定义预算约束，这迫使您思考最坏情况下的结果，以及风险如何限制当前的借贷和消费决策。这个练习将预算约束的概念扩展到金融和风险管理领域。[@problem_id:2378611]", "id": "2378611", "problem": "一位消费者选择两种非负数量的商品，表示为 $x_1$ 和 $x_2$，其法币价格分别为 $p_1$ 和 $p_2$。该消费者在日期 $0$ 时拥有法币财富 $w_0$，并将在日期 $1$ 收到 $q$ 单位的加密货币。在日期 $1$ 时，该加密货币的法币汇率是不确定的，但属于一个已知的闭区间 $[E_{\\min}, E_{\\max}]$，其中 $E_{\\min} \\ge 0$。消费者不能在日期 $1$ 之前出售该加密货币。\n\n在日期 $0$，消费者可以借入一笔金额为 $b$ 的法币，该金额受外生上限 $B_{\\max} \\ge 0$ 的限制，并必须在日期 $1$ 偿还 $(1+r)b$，其中 $r \\ge 0$ 是利率。为了偿还债务，消费者可以在日期 $1$ 观察到实现的汇率 $E \\in [E_{\\min}, E_{\\max}]$ 后，出售任意数量 $z(E) \\in [0,q]$ 的加密货币。如果 $z(E) = 0$，则不支付任何交易费，法币收益为 $0$。如果 $z(E) &gt; 0$，交易所会征收税率为 $f \\in [0,1)$ 的从价费和一笔固定费用 $k \\ge 0$，因此在汇率为 $E$ 时出售 $z(E)$ 单位加密货币的法币收益为 $(1-f) E \\, z(E) - k$。\n\n贷款方施加了一个稳健的偿付能力要求：对于每一个 $E \\in [E_{\\min}, E_{\\max}]$，都必须存在一个选择 $z(E) \\in [0,q]$，使得在日期 $1$ 的出售净收益至少等于还款额 $(1+r)b$。形式上，对于所有的 $E \\in [E_{\\min}, E_{\\max}]$，存在一个 $z(E) \\in [0,q]$ 满足\n$$(1-f) E \\, z(E) - k \\cdot \\mathbf{1}_{\\{z(E) &gt; 0\\}} \\;\\ge\\; (1+r) b,$$\n其中 $\\mathbf{1}_{\\{\\cdot\\}}$ 是指示函数，如果其参数为真则等于 $1$，否则等于 $0$。\n\n在日期 $0$，消费者的预算集是所有满足\n$$p_1 x_1 + p_2 x_2 \\;\\le\\; w_0 + b,$$\n的 $(x_1,x_2)$ 的集合，其中 $x_1 \\ge 0$，$x_2 \\ge 0$，并且 $b \\in [0,B_{\\max}]$ 满足上述稳健偿付能力要求。\n\n任务。对于下面测试套件中的每个参数集，计算以下三个量：\n- 最大稳健可行借贷能力 $b_{\\max}$。\n- 所得预算线在 $x_1$ 轴上的截距 $x_1^{\\max}$（当 $x_2=0$ 时），即 $x_1^{\\max} = (w_0 + b_{\\max})/p_1$。\n- 所得预算线在 $x_2$ 轴上的截距 $x_2^{\\max}$（当 $x_1=0$ 时），即 $x_2^{\\max} = (w_0 + b_{\\max})/p_2$。\n\n将这三个量中的每一个都以小数形式报告，并四舍五入到小数点后六位。\n\n测试套件。每种情况都是一个元组 $(p_1,p_2,w_0,q,E_{\\min},E_{\\max},f,k,r,B_{\\max})$：\n- 情况 $1$：$(2.0,\\,3.0,\\,10.0,\\,5.0,\\,180.0,\\,220.0,\\,0.01,\\,5.0,\\,0.05,\\,1000.0)$。\n- 情况 $2$：$(1.5,\\,4.0,\\,20.0,\\,2.0,\\,5.555555555555556,\\,6.0,\\,0.1,\\,10.0,\\,0.1,\\,100.0)$。\n- 情况 $3$：$(5.0,\\,2.0,\\,0.0,\\,3.0,\\,100.0,\\,200.0,\\,0.0,\\,0.0,\\,0.2,\\,1000.0)$。\n- 情况 $4$：$(1.0,\\,1.0,\\,5.0,\\,10.0,\\,50.0,\\,60.0,\\,0.05,\\,0.0,\\,0.0,\\,100.0)$。\n- 情况 $5$：$(2.0,\\,2.0,\\,0.0,\\,1.0,\\,100.0,\\,150.0,\\,0.1,\\,5.0,\\,1.0,\\,1000.0)$。\n- 情况 $6$：$(3.0,\\,6.0,\\,7.0,\\,0.0,\\,100.0,\\,120.0,\\,0.2,\\,1.0,\\,0.3,\\,50.0)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于每种情况 $i$，输出列表 $[b_{\\max,i},x_{1,i}^{\\max},x_{2,i}^{\\max}]$，其中每个数字都四舍五入到小数点后六位。将六种情况的列表按照上述顺序合并为一个总列表，中间不含任何空格。例如，包含两个假设案例的输出应如下所示：$[[1.000000,2.000000,3.000000],[4.000000,5.000000,6.000000]]$。", "solution": "这个问题是在未来加密货币收入不确定但有界，并且贷款方要求对区间 $[E_{\\min}, E_{\\max}]$ 内的每一种汇率实现都具有稳健的偿付能力的情况下，确定日期 $0$ 的法币预算线。核心步骤依赖于稳健偿付能力约束下的可行性定义以及预算线的定义。\n\n首先，考虑稳健借贷约束。对于任何选定的贷款 $b \\in [0,B_{\\max}]$，偿付能力要求规定，对于每个 $E \\in [E_{\\min}, E_{\\max}]$，都存在一个出售数量 $z(E) \\in [0,q]$ 使得\n$$(1-f) E \\, z(E) - k \\cdot \\mathbf{1}_{\\{z(E) &gt; 0\\}} \\;\\ge\\; (1+r) b.$$\n让我们分析，在 $E$ 实现后可以选择 $z(E)$ 的情况下，对于所有的 $E$，可以保证用于偿还的最大法币金额是多少。\n\n固定 $E \\in [E_{\\min}, E_{\\max}]$。出售 $z \\in [0,q]$ 单位的收益函数为\n$$\\pi(E,z) \\;=\\; \\begin{cases}\n0, & z = 0,\\\\\n(1-f) E \\, z - k, & z \\in (0,q].\n\\end{cases}$$\n对于给定的 $E$，因为 $(1-f)E \\ge 0$，收益 $\\pi(E,z)$ 在 $(0,q]$ 上是关于 $z$ 非递减的。因此，以出售为前提，在该 $E$ 下的最大收益来自于出售全部持有量：\n$$\\max_{z \\in (0,q]} \\pi(E,z) \\;=\\; (1-f) E \\, q - k.$$\n然而，消费者也可以选择不出售，从而避免固定费用 $k$，获得收益 $0$。因此，在汇率 $E$ 下，通过在该 $E$ 下的最优出售决策可以保证的最大收益是\n$$\\Pi(E) \\;=\\; \\max\\!\\big(0,\\,(1-f) E \\, q - k\\big).$$\n\n贷款方要求还款额 $(1+r) b$ 不超过在任何 $E \\in [E_{\\min}, E_{\\max}]$ 下，根据该 $E$ 的最优出售决策所能获得的收益。这导出了稳健界限\n$$(1+r) b \\;\\le\\; \\inf_{E \\in [E_{\\min}, E_{\\max}]} \\Pi(E).$$\n因为 $\\Pi(E)$ 是关于 $E$ 非递减的（因为 $(1-f) E \\, q - k$ 是非递减的，且与 $0$ 取最大值的操作保持了单调性），所以在 $[E_{\\min}, E_{\\max}]$ 上的下确界在 $E_{\\min}$ 处取得：\n$$\\inf_{E \\in [E_{\\min}, E_{\\max}]} \\Pi(E) \\;=\\; \\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big).$$\n因此，与稳健偿付能力和外生上限一致的最大 $b$ 是\n$$b_{\\max} \\;=\\; \\min\\!\\left(B_{\\max},\\; \\frac{\\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big)}{1+r}\\right).$$\n\n接下来，日期 $0$ 的预算集由标准线性支出约束定义\n$$p_1 x_1 + p_2 x_2 \\;\\le\\; w_0 + b,$$\n其中 $b \\in [0,b_{\\max}]$ 且 $x_1 \\ge 0$，$x_2 \\ge 0$。预算集的外包络线是当 $b = b_{\\max}$ 时得到的预算线。通过将另一种商品的消费设为零，我们得到该线在 $x_1$ 轴和 $x_2$ 轴上的截距为\n$$x_1^{\\max} \\;=\\; \\frac{w_0 + b_{\\max}}{p_1}, \\qquad x_2^{\\max} \\;=\\; \\frac{w_0 + b_{\\max}}{p_2}.$$\n\n因此，每种情况的计算都从第一性原理出发，步骤如下：\n1. 计算最坏情况下的保证收益 $\\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big)$。\n2. 将其除以 $(1+r)$ 得到还款所隐含的借贷上限，并与 $B_{\\max}$ 取最小值，得到 $b_{\\max}$。\n3. 计算 $x_1^{\\max} = (w_0 + b_{\\max})/p_1$ 和 $x_2^{\\max} = (w_0 + b_{\\max})/p_2$。\n\n将这些步骤应用于每个测试案例，并将所有报告的数字四舍五入到小数点后六位，即可得出规范所要求的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef robust_borrowing_capacity(p1, p2, w0, q, E_min, E_max, f, k, r, B_max):\n    \"\"\"\n    Compute b_max = min(B_max, max(0, (1-f)*E_min*q - k) / (1+r))\n    Then compute axis intercepts:\n      x1_max = (w0 + b_max)/p1\n      x2_max = (w0 + b_max)/p2\n    \"\"\"\n    # Worst-case guaranteed proceeds at E_min given optimal choice of z(E)\n    proceeds_low = (1.0 - f) * E_min * q - k\n    guaranteed = proceeds_low if proceeds_low > 0.0 else 0.0\n    denom = 1.0 + r\n    # Guard against any numerical issues (denom should be > 0 given r >= 0 in problem)\n    if denom <= 0.0:\n        # Fallback: if denom is zero or negative (not in provided tests), set borrowing bound to 0\n        b_bound = 0.0\n    else:\n        b_bound = guaranteed / denom\n    b_max = b_bound if b_bound <= B_max else B_max\n    # Axis intercepts\n    x1_max = (w0 + b_max) / p1\n    x2_max = (w0 + b_max) / p2\n    return b_max, x1_max, x2_max\n\ndef fmt6(x):\n    # Format with exactly 6 digits after the decimal, avoiding \"-0.000000\"\n    if abs(x) < 0.0000005:\n        x = 0.0\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (p1, p2, w0, q, E_min, E_max, f, k, r, B_max)\n    test_cases = [\n        (2.0, 3.0, 10.0, 5.0, 180.0, 220.0, 0.01, 5.0, 0.05, 1000.0),            # Case 1\n        (1.5, 4.0, 20.0, 2.0, 5.555555555555556, 6.0, 0.1, 10.0, 0.1, 100.0),    # Case 2\n        (5.0, 2.0, 0.0, 3.0, 100.0, 200.0, 0.0, 0.0, 0.2, 1000.0),               # Case 3\n        (1.0, 1.0, 5.0, 10.0, 50.0, 60.0, 0.05, 0.0, 0.0, 100.0),                # Case 4\n        (2.0, 2.0, 0.0, 1.0, 100.0, 150.0, 0.1, 5.0, 1.0, 1000.0),               # Case 5\n        (3.0, 6.0, 7.0, 0.0, 100.0, 120.0, 0.2, 1.0, 0.3, 50.0),                 # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        p1, p2, w0, q, E_min, E_max, f, k, r, B_max = case\n        b_max, x1_max, x2_max = robust_borrowing_capacity(p1, p2, w0, q, E_min, E_max, f, k, r, B_max)\n        results.append((b_max, x1_max, x2_max))\n\n    # Build output string with no spaces and six decimals per number\n    inner_lists = []\n    for b, x1, x2 in results:\n        inner = f\"[{fmt6(b)},{fmt6(x1)},{fmt6(x2)}]\"\n        inner_lists.append(inner)\n    output = f\"[{','.join(inner_lists)}]\"\n    # Final print statement in the exact required format.\n    print(output)\n\nsolve()\n```"}]}