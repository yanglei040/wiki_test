{"hands_on_practices": [{"introduction": "债券估值是应用现值原理的一个典型场景，但真实世界的金融工具往往比教科书模型更复杂。本练习模拟了一种阶梯式息票债券的定价，其核心挑战在于一个非线性的税收规则：适用于息票的税率会根据息票金额的大小而变化。通过解决这个问题，你将学会如何细致地分析每个时期的现金流，并准确地将现实世界的约束（如税法）整合到标准估值模型中。[@problem_id:2395387]", "id": "2395387", "problem": "一位投资者正在评估一只阶梯式息票债券，其面值为 $F = 1{,}000$，到期期限为 $N = 6$ 年。其息票安排如下：在第 $t = 1, 2, 3$ 年，年息票率为面值的 $0.03$，而在第 $t = 4, 5, 6$ 年，年息票率为面值的 $0.07$。息票税仅适用于息票支付，并在收到时根据当期息票金额 $C$ 按阶梯函数征收：\n$$\n\\tau(C) = \n\\begin{cases}\n0.10, & \\text{若 } 0 \\le C \\le 40, \\\\\n0.20, & \\text{若 } 40 < C \\le 60, \\\\\n0.35, & \\text{若 } C > 60.\n\\end{cases}\n$$\n到期时的本金偿还是免税的。投资者使用固定的有效年收益率 $y = 0.06$ 对现金流进行贴现。请通过以收益率 $y$ 对税后息票现金流和免税的本金偿还进行贴现，计算该债券的现值 (PV)，以美元计。将您的答案四舍五入到四位有效数字。最终金额以美元表示。", "solution": "该问题已经过验证，被认定为有效。这是一个在计算金融领域中定义明确的问题，它基于现值分析的既定原则，并包含了求解所需的所有必要且一致的信息。\n\n债券的现值 ($PV$) 是其未来所有现金流的总和，每笔现金流都贴现至时间 $t=0$ 的价值。现金流由定期的税后息票支付和最终的本金偿还组成。现值的通用公式为：\n$$\nPV = \\sum_{t=1}^{N} \\frac{CF_t}{(1+y)^t}\n$$\n其中 $CF_t$ 是在第 $t$ 年末收到的总现金流，$N$ 是到期年限，$y$ 是用于贴现的年有效收益率。\n\n首先，我们必须确定每年的现金流。该债券的面值为 $F = \\$1{,}000$，到期期限为 $N = 6$ 年。贴现收益率为 $y = 0.06$。\n\n步骤 1：计算第 $t = 1, 2, 3$ 年的息票支付和税后现金流。\n年息票率给定为 $0.03$。息票金额 $C_1$ 为：\n$$\nC_1 = 0.03 \\times F = 0.03 \\times 1000 = 30\n$$\n为了求得税后现金流，我们应用给定的税收函数 $\\tau(C)$：\n$$\n\\tau(C) = \n\\begin{cases}\n0.10, & \\text{若 } 0 \\le C \\le 40 \\\\\n0.20, & \\text{若 } 40 < C \\le 60 \\\\\n0.35, & \\text{若 } C > 60\n\\end{cases}\n$$\n对于 $C_1 = 30$，税率为 $\\tau(30) = 0.10$。\n前三年中每年的税后现金流 $CF_1$ 为：\n$$\nCF_1 = C_1 \\times (1 - \\tau(C_1)) = 30 \\times (1 - 0.10) = 30 \\times 0.90 = \\$27\n$$\n\n步骤 2：计算第 $t = 4, 5, 6$ 年的息票支付和税后现金流。\n年息票率给定为 $0.07$。息票金额 $C_2$ 为：\n$$\nC_2 = 0.07 \\times F = 0.07 \\times 1000 = 70\n$$\n对于 $C_2 = 70$，税率为 $\\tau(70) = 0.35$。\n后三年中每年来自息票的税后现金流 $CF_2$ 为：\n$$\nCF_2 = C_2 \\times (1 - \\tau(C_2)) = 70 \\times (1 - 0.35) = 70 \\times 0.65 = \\$45.50\n$$\n\n步骤 3：确定总现金流序列。\n在时间 $t$ 的现金流由税后息票组成。在到期时 ($t=6$)，现金流还包括免税的本金偿还 $F = 1000$。\n总现金流 ($CF_t$) 序列如下：\n- 对于 $t = 1, 2, 3$：$CF_t = \\$27$\n- 对于 $t = 4, 5$：$CF_t = \\$45.50$\n- 对于 $t = 6$：$CF_6 = (\\text{税后息票}) + (\\text{本金}) = 45.50 + 1000 = \\$1045.50$\n\n步骤 4：计算现值。\n现值是所有贴现后现金流的总和：\n$$\nPV = \\frac{27}{(1+0.06)^1} + \\frac{27}{(1+0.06)^2} + \\frac{27}{(1+0.06)^3} + \\frac{45.5}{(1+0.06)^4} + \\frac{45.5}{(1+0.06)^5} + \\frac{1045.5}{(1+0.06)^6}\n$$\n此计算可以通过将两组息票支付和最终的本金支付分开来组织。\n$PV$ 可以表示为所有六次税后息票的现值与本金的现值之和：\n$$\nPV = \\left( \\sum_{t=1}^{3} \\frac{27}{(1.06)^t} + \\sum_{t=4}^{6} \\frac{45.5}{(1.06)^t} \\right) + \\frac{1000}{(1.06)^6}\n$$\n我们使用普通年金的现值公式，$PV_A = P \\times \\frac{1 - (1+y)^{-n}}{y}$，其中 $P$ 是每期支付额。令 $a_{\\overline{n}|y} = \\frac{1 - (1+y)^{-n}}{y}$。\n\n前三次息票的现值为：\n$$\nPV_{\\text{coupons}, 1-3} = 27 \\times a_{\\overline{3}|0.06} = 27 \\times \\frac{1 - (1.06)^{-3}}{0.06} \\approx 27 \\times 2.673012 = 72.171324\n$$\n第 4, 5, 6 年的息票现值是一个递延年金。其价值可以通过一个6年期年金和一个3年期年金的差值求得：\n$$\nPV_{\\text{coupons}, 4-6} = 45.5 \\times (a_{\\overline{6}|0.06} - a_{\\overline{3}|0.06})\n$$\n$a_{\\overline{6}|0.06} = \\frac{1 - (1.06)^{-6}}{0.06} \\approx 4.917324$\n$$\nPV_{\\text{coupons}, 4-6} \\approx 45.5 \\times (4.917324 - 2.673012) = 45.5 \\times 2.244312 = 102.116196\n$$\n所有税后息票的总现值为：\n$$\nPV_{\\text{coupons}} \\approx 72.171324 + 102.116196 = 174.28752\n$$\n本金偿还的现值为：\n$$\nPV_{\\text{principal}} = \\frac{1000}{(1.06)^6} \\approx 1000 \\times 0.70496054 = 704.96054\n$$\n债券的总现值是这些组成部分的总和：\n$$\nPV = PV_{\\text{coupons}} + PV_{\\text{principal}} \\approx 174.28752 + 704.96054 = 879.24806\n$$\n题目要求答案四舍五入到四位有效数字。计算出的值为 $879.24806$。前四位有效数字是 8, 7, 9, 2。第五位数字是 4，因此我们舍去。\n$$\nPV \\approx 879.2\n$$\n债券的现值以美元表示。", "answer": "$$\n\\boxed{879.2}\n$$"}, {"introduction": "许多金融合同中的现金流并非固定不变，而是取决于特定条件的满足。这个练习要求你编写程序来评估一个“或有年金”，其支付与公司的季度利润挂钩，这让你从手动计算转向算法思维。你将学习如何将金融逻辑（例如，支付条件和时变利率）转化为代码，从而构建一个能够处理更真实、更复杂场景的估值工具。[@problem_id:2395348]", "id": "2395348", "problem": "你需要编写一个完整、可运行的程序，用于计算一种或有年金的现值。该年金的期末付款在未满足指定条件时将被跳过。该条件为：公司季度利润必须达到或超过给定的阈值，才会在该季度末支付固定款项；否则，该季度的付款将被跳過。所有付款均在每季度末发生。所有利率必须以小数形式处理（不带百分号）。假设对于每个时期 $t$，单期总回报满足 $1 + r_t > 0$。程序不得要求任何用户输入。\n\n基本原理。请使用以下基础：确定性、离散复利和无套利条件下的货币时间价值。具体而言，一笔现值金额 $v$ 以每期无风险利率 $r_1, r_2, \\dots, r_t$ 进行投资和复利计算，在 $t$ 个时期后将累积为 $v \\cdot \\prod_{i=1}^{t} (1 + r_i)$。請以此为基础，推导如何用现值来衡量未来日期的现金流。\n\n问题设定。对于一个 $N$ 个季度的有限期限，给定以下信息：\n- 一个固定的季度末支付金额 $A$（以货币单位计）。\n- 一个利润序列 $\\{P_t\\}_{t=1}^{N}$，其中 $P_t$ 是在第 $t$ 季度观察到的利润。\n- 一个阈值 $\\theta$（单位与 $\\{P_t\\}$ 相同）。当且仅当 $P_t \\ge \\theta$ 时，第 $t$ 季度的付款才会发生；否则，该季度的付款将被跳過。\n- 一个确定的每季度无风险利率序列 $\\{r_t\\}_{t=1}^{N}$（均以小数而非百分比表示）。\n\n你的任务是计算在时间 $t = 0$ 时该年金的现值。该年金在每个满足 $P_t \\ge \\theta$ 条件的季度 $t$ 末支付 $A$，否则支付 $0$，并使用给定的利率期限结构 $\\{r_t\\}$进行折现。\n\n覆盖范围与测试套件。请实现你的程序，为以下每个参数集计算现值。在所有情况下，支付条件均使用包含等于关系的规则 $P_t \\ge \\theta$，且支付发生在每个季度 $t \\in \\{1,2,\\dots,N\\}$ 的末尾。\n\n- 测试用例 $1$（正常路径，恒定正利率，混合支付/跳过）：\n  - $A = 100$\n  - $\\theta = 2.5$\n  - $\\{P_t\\}_{t=1}^{5} = [3, 2, 4, 1, 5]$\n  - $\\{r_t\\}_{t=1}^{5} = [0.01, 0.01, 0.01, 0.01, 0.01]$\n- 测试用例 $2$（边界情况：零利率，等于阈值触发支付）：\n  - $A = 50$\n  - $\\theta = 2$\n  - $\\{P_t\\}_{t=1}^{3} = [2, 2, 2]$\n  - $\\{r_t\\}_{t=1}^{3} = [0.0, 0.0, 0.0]$\n- 测试用例 $3$（从未支付）：\n  - $A = 500$\n  - $\\theta = 10$\n  - $\\{P_t\\}_{t=1}^{4} = [1, 1, 1, 1]$\n  - $\\{r_t\\}_{t=1}^{4} = [0.05, 0.05, 0.05, 0.05]$\n- 测试用例 $4$（时变利率，包括一个小的负利率，多次支付）：\n  - $A = 123.45$\n  - $\\theta = 2$\n  - $\\{P_t\\}_{t=1}^{6} = [5, 0, 3, 2, 2, 10]$\n  - $\\{r_t\\}_{t=1}^{6} = [0.02, 0.03, -0.005, 0.01, 0.0, 0.04]$\n- 测试用例 $5$（全部支付，中等正利率，等于阈值）：\n  - $A = 200$\n  - $\\theta = 10$\n  - $\\{P_t\\}_{t=1}^{2} = [10, 10]$\n  - $\\{r_t\\}_{t=1}^{2} = [0.05, 0.05]$\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个数值结果四舍五入到六位小数。例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。程序必须按顺序计算并打印上述每个测试用例的一个现值。不應打印任何其他文本。", "solution": "问题陈述已经过分析并被确定为有效。它基于金融数学原理，具有科学依据，问题设定适定，包含所有必要数据和无歧义的条件，并且表述客观。该问题ตาม所述是可解的。\n\n任务是计算一个或有年金在 $N$ 個季度的有限期限内的现值（$PV$）。当且仅当公司在该季度 $t$ 的利润 $P_t$ 大于或等于指定阈值 $\\theta$ 时，该年金才会在季度末支付金额 $A$。估值必须考虑到一个确定性但可能随时间变化的每季度无风险利率序列 $\\{r_t\\}_{t=1}^{N}$。\n\n此计算的基本原则是现值的可加性。现金流序列的总现值是每个单独现金流现值的总和。\n\n首先，我们形式化在每个季度 $t \\in \\{1, 2, \\dots, N\\}$ 末发生的现金流 $C_t$。根据问题的或有規則，现金流要么是 $A$ 要么是 $0$。这可以用指示函数 $I(\\cdot)$ 进行数学表达，当其参数为真时取值为 $1$，否则取值为 $0$。\n\n$$C_t = A \\cdot I(P_t \\ge \\theta)$$\n\n接下来，我们必须确定每个現金流 $C_t$ 的现值。问题指定了使用单期利率期限结构 $\\{r_t\\}$ 的离散复利框架。在时间 $t$ 的未来值，我们称之为 $FV_t$，通过以下公式与其在时间 $t=0$ 的现值 $PV_0$ 相关联：\n\n$$FV_t = PV_0 \\cdot \\prod_{i=1}^{t} (1 + r_i)$$\n\n该公式描述了一笔现值金额如何随时间累积价值。要找到在未来时间 $t$ 收到的现金流 $C_t$ 的现值，我们必须逆转此过程，这一过程被称为折现。通过重排公式，$C_t$ 的现值为：\n\n$$PV(C_t) = \\frac{C_t}{\\prod_{i=1}^{t} (1 + r_i)}$$\n\n分母中的项 $\\prod_{i=1}^{t} (1 + r_i)$ 是到时间 $t$ 为止的累积因子。其倒数 $D_t = 1 / \\prod_{i=1}^{t} (1 + r_i)$ 是时间 $t$ 的折现因子。问题陳述 $1 + r_t > 0$ 对所有 $t$ 均成立，这确保了折现因子始终是有明确定义且为正。\n\n根据价值可加性原则，整个或有年金的总现值是从 $t=1$ 到 $N$ 每个季度现金流现值的总和：\n\n$$PV_{total} = \\sum_{t=1}^{N} PV(C_t) = \\sum_{t=1}^{N} C_t \\cdot D_t$$\n\n代入我们对 $C_t$ 和 $D_t$ 的表达式，我们得到所需现值的完整公式：\n\n$$PV_{total} = \\sum_{t=1}^{N} \\left( A \\cdot I(P_t \\ge \\theta) \\cdot \\frac{1}{\\prod_{i=1}^{t} (1 + r_i)} \\right)$$\n\n为了在算法上实现此计算，我们对每个测试用例按以下步骤进行：\n1.  将利润和利率序列表示为数组 $\\{P_t\\}_{t=1}^{N}$ 和 $\\{r_t\\}_{t=1}^{N}$。\n2.  首先，我们确定或有现金流序列。对于从 $1$到 $N$ 的每个 $t$，我们检查是否 $P_t \\ge \\theta$。如果为真，现金流为 $A$；否则为 $0$。这将生成一个现金流序列 $\\{C_t\\}_{t=1}^{N}$。\n3.  接下来，我们计算折现因子的期限结构。每个时期 $t$ 的折现因子取决于总回报 $(1 + r_i)$ 的累积乘积。令 $Z_t = \\prod_{i=1}^{t} (1 + r_i)$ 为累积因子。这可以通过迭代计算得出，其中 $Z_t = Z_{t-1} \\cdot (1 + r_t)$，初始值为 $Z_0=1$。那么折现因子为 $D_t = 1/Z_t$。\n4.  对于每个季度 $t$，我们将现金流 $C_t$ 乘以相应的折现因子 $D_t$ 来计算折现后的现金流。\n5.  最后，我们将所有 $N$ 个季度的折现现金流相加，以获得总现值。\n\n此过程基于资产估值的第一性原理，将应用于每个给定的测试用例，以产生最终的数值解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the present value of a contingent annuity for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {'A': 100, 'theta': 2.5, 'P_t': [3, 2, 4, 1, 5], 'r_t': [0.01, 0.01, 0.01, 0.01, 0.01]},\n        # Test case 2\n        {'A': 50, 'theta': 2, 'P_t': [2, 2, 2], 'r_t': [0.0, 0.0, 0.0]},\n        # Test case 3\n        {'A': 500, 'theta': 10, 'P_t': [1, 1, 1, 1], 'r_t': [0.05, 0.05, 0.05, 0.05]},\n        # Test case 4\n        {'A': 123.45, 'theta': 2, 'P_t': [5, 0, 3, 2, 2, 10], 'r_t': [0.02, 0.03, -0.005, 0.01, 0.0, 0.04]},\n        # Test case 5\n        {'A': 200, 'theta': 10, 'P_t': [10, 10], 'r_t': [0.05, 0.05]}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current test case\n        A = case['A']\n        theta = case['theta']\n        P_t = np.array(case['P_t'])\n        r_t = np.array(case['r_t'])\n\n        # Step 1: Determine the contingent cash flows for each period.\n        # The cash flow is 'A' if P_t >= theta, and 0 otherwise.\n        # This is achieved by creating a boolean mask and multiplying by A.\n        payment_occurs_mask = (P_t >= theta)\n        cash_flows = A * payment_occurs_mask\n\n        # Step 2: Calculate the discount factor for each period.\n        # The discount factor for period t is 1 / product(1+r_i) for i from 1 to t.\n        \n        # Gross returns for each period (1 + r_t)\n        gross_returns = 1 + r_t\n        \n        # Cumulative product of gross returns gives the denominator of the discount factor.\n        # np.cumprod([g1, g2, g3]) yields [g1, g1*g2, g1*g2*g3]\n        discount_denominators = np.cumprod(gross_returns)\n        \n        # Step 3: Calculate the present value of each cash flow\n        discounted_cash_flows = cash_flows / discount_denominators\n        \n        # Step 4: Sum the present values of all cash flows to get the total PV\n        total_pv = np.sum(discounted_cash_flows)\n        \n        # Format the result to six decimal places and append to the list\n        results.append(f\"{total_pv:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "最成熟的估值模型将公司视为一个动态演化的实体，而不仅仅是固定现金流的来源。这个终极练习将估值提升到了一个动态层面：你将对一家公司的价值进行建模，其盈利和股息会根据其自身的再投资决策而随时间演变。通过实施一个递归函数，你将探索公司增长战略、未来盈利和当前价值之间的强大反馈循环，从而深入理解企业估值的核心。[@problem_id:2395318]", "id": "2395318", "problem": "一家公司在以 $t \\in \\{0,1,2,\\dots\\}$ 为索引的离散时间内产生收益。设时间 $t$ 的收益为 $Y_t \\ge 0$ (以货币单位计)。在每个时间点 $t$，公司支付的股息 $D_t$ 等于未进行再投资的收益部分，即 $D_t = (1-g_t) Y_t$，其中 $g_t \\in [0,1]$ 是时间 $t$ 的再投资率。再投资金额为 $I_t = g_t Y_t$。新投资的回报不是恒定的：由于时间 $t$ 的再投资，下一期收益的增量比例收益由回报函数 $r(Y_t) = \\dfrac{a}{1 + b Y_t}$ 给出，其中 $a > 0$ 和 $b \\ge 0$ 是参数。收益根据递归关系 $Y_{t+1} = Y_t \\bigl(1 + r(Y_t) g_t \\bigr)$ 演变。公司的现值 (PV) 是以一个恒定的要求回报率 $R > 0$（以小数而非百分比表示）折现的股息折现总和，\n$$\n\\text{PV}(Y_0) = \\sum_{t=0}^{\\infty} \\beta^t D_t,\n$$\n其中 $\\beta = \\dfrac{1}{1+R}$。您必须使用一个递归计算来近似 $\\text{PV}(Y_0)$。当下一个折现股息贡献的绝对值低于容差 $\\varepsilon > 0$（即 $\\beta^t |D_t| < \\varepsilon$）时，或者当达到硬性期限 $H \\in \\mathbb{N}$ 时，以先发生者为准，计算停止。所有比率必须以小数形式提供和解释。每个测试用例的最终答案必须是与 $Y_0$ 相同货币单位的现值，并四舍五入到 $6$ 位小数。\n\n实现一个完整、可运行的程序，该程序定义并使用一个与上述描述一致的递归函数，为以下测试套件中的每组参数计算 $\\text{PV}(Y_0)$。在每种情况下，如果提供的再投资序列 $[g_0,g_1,\\dots,g_{L-1}]$ 的长度为 $L$，那么对于所有 $t \\ge L$，使用 $g_t = g_{L-1}$。\n\n测试套件：\n- 案例 $1$ (一般情况，非恒定再投资): $Y_0 = 100.0$, $R = 0.08$, $a = 0.25$, $b = 0.01$, $[g_0,g_1,g_2] = [0.4,0.35,0.3]$, $H = 500$, $\\varepsilon = 10^{-12}$。\n- 案例 $2$ (完全再投资边界情况): $Y_0 = 50.0$, $R = 0.10$, $a = 0.30$, $b = 0.02$, $[g_0] = [1.0]$, $H = 500$, $\\varepsilon = 10^{-12}$。\n- 案例 $3$ (低再投资与快速递减的回报): $Y_0 = 120.0$, $R = 0.05$, $a = 0.20$, $b = 0.05$, $[g_0] = [0.05]$, $H = 500$, $\\varepsilon = 10^{-12}$。\n- 案例 $4$ (随时间变化的再投资趋近于零): $Y_0 = 80.0$, $R = 0.12$, $a = 0.40$, $b = 0.03$, $[g_0,g_1,g_2,g_3] = [0.6,0.2,0.1,0.0]$, $H = 500$, $\\varepsilon = 10^{-12}$。\n\n您的程序必须生成单行输出，其中包含按上述顺序列出的案例结果，形式为一个逗号分隔的四个四舍五入的现值列表，并用方括号括起来。输出必须只包含四个四舍五入到 $6$ 位小数的浮点数，且不含任何附加文本。", "solution": "问题陈述已经过评估并被确定为有效。它具有科学依据、问题设定良好且客观。为获得唯一的确定性解所需的所有数据和条件均已提供。该问题是计算金融学中的一个标准练习，具体涉及使用具有非恒定增长的股息折现模型对公司进行估值。它没有违反任何指定的无效标准。因此，我们可以继续进行求解。\n\n目标是根据公司未来的股息流计算其现值 $\\text{PV}$。基本原则是，一项资产的价值是其预期未来现金流折算到现在的总和。对于一个在每个离散时间段 $t \\in \\{0, 1, 2, \\dots\\}$ 支付股息 $D_t$ 的公司，其现值由下式给出：\n$$\n\\text{PV}(Y_0) = \\sum_{t=0}^{\\infty} \\beta^t D_t\n$$\n其中 $Y_0$ 是初始收益，$D_t = (1-g_t)Y_t$ 是时间 $t$ 的股息，$g_t$ 是再投资率，而 $\\beta = \\frac{1}{1+R}$ 是对应于要求回报率 $R$ 的折现因子。\n\n收益 $Y_t$ 根据以下递推关系演变：\n$$\nY_{t+1} = Y_t \\left(1 + r(Y_t) g_t\\right)\n$$\n其中新投资的回报由 $r(Y_t) = \\frac{a}{1 + b Y_t}$ 给出。\n\n$\\text{PV}(Y_0)$ 的无穷求和在计算上是不可行的。因此，我们必须用一个有限和来近似它。求和根据两个条件被截断：一个最大时间期限 $H$ 和一个容差 $\\varepsilon$。如果 $t \\ge H$ 或者该时期的折现股息项 $\\beta^t D_t$ 小于 $\\varepsilon$，计算将在时间 $t$ 停止。\n\n为了形式化所需的递归计算，我们定义一个函数 $V(t, Y_t, \\beta_p)$，它计算从时间 $t$ 开始的折现股息之和，其中 $Y_t$ 是时间 $t$ 的收益，$\\beta_p = \\beta^t$ 是时期 $t$ 的折现因子。总现值即为 $V(0, Y_0, 1)$。\n\n时间 $t$ 的股息是 $D_t = (1-g_t)Y_t$。这个单期股息对总现值的贡献是 $\\Delta \\text{PV}_t = \\beta_p D_t$。\n\n递归结构基于以下逻辑：从时间 $t$ 开始的总价值等于时间 $t$ 的股息价值加上从时间 $t+1$ 开始的总价值。\n$$\nV(t, Y_t, \\beta_p) = \\Delta \\text{PV}_t + V(t+1, Y_{t+1}, \\beta_p \\cdot \\beta)\n$$\n这个递推关系必须包含终止条件。如果满足条件，递归将终止，并且不再增加任何价值。这引出了递归步骤的以下精确定义：\n\n$V(t, Y_t, \\beta_p) = \\begin{cases} 0 & \\text{如果 } t \\ge H \\text{ 或 } \\beta_p (1-g_t)Y_t < \\varepsilon \\\\ \\beta_p (1-g_t)Y_t + V(t+1, Y_{t+1}, \\beta_p \\cdot \\beta) & \\text{否则} \\end{cases}$\n\n其中 $Y_{t+1}$ 由 $Y_t$ 和 $g_t$ 计算得出。对于任何时间 $t$，再投资率 $g_t$ 由提供的序列 $[g_0, g_1, \\dots, g_{L-1}]$ 通过以下规则确定：如果 $t < L$，$g_t$ 是序列的第 $t$ 个元素；否则，$g_t = g_{L-1}$。这可以通过访问序列中索引为 $\\min(t, L-1)$ 的元素来实现。\n\n递归的基准情形是返回 $0$ 的条件。递归步骤计算当前项，并加上对下一个时间步的调用结果。为一组给定参数计算总现值的初始调用是 $V(0, Y_0, 1.0)$。这个结构为该问题提供了一个完整的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to set a higher recursion limit for problems involving deep recursion,\n# though the default of 1000 is sufficient for H=500.\nsys.setrecursionlimit(2000)\n\ndef compute_pv_recursive(t, current_y, current_beta_power, params):\n    \"\"\"\n    Recursively computes the Present Value of dividends from time t onwards.\n\n    Args:\n        t (int): The current time step.\n        current_y (float): The earnings at time t.\n        current_beta_power (float): The discount factor for time t, beta^t.\n        params (dict): A dictionary containing all model parameters.\n\n    Returns:\n        float: The Present Value of the dividend stream from time t onwards.\n    \"\"\"\n    # Unpack parameters\n    a = params['a']\n    b = params['b']\n    g_sequence = params['g_sequence']\n    H = params['H']\n    epsilon = params['epsilon']\n    beta = params['beta']\n    \n    # Termination condition 1: Hard horizon\n    if t >= H:\n        return 0.0\n\n    # Determine the reinvestment fraction g_t\n    g_sequence_len = len(g_sequence)\n    if t < g_sequence_len:\n        g_t = g_sequence[t]\n    else:\n        g_t = g_sequence[-1]\n\n    # Calculate dividend D_t\n    d_t = (1.0 - g_t) * current_y\n    \n    # Calculate the discounted dividend term\n    term = current_beta_power * d_t\n\n    # Termination condition 2: Tolerance\n    # Since Y_t >= 0 and g_t <= 1, D_t is non-negative. So |D_t| = D_t.\n    if term < epsilon:\n        return 0.0\n\n    # Calculate return on investment r(Y_t)\n    r_t = a / (1.0 + b * current_y)\n\n    # Calculate earnings for the next period Y_{t+1}\n    next_y = current_y * (1.0 + r_t * g_t)\n\n    # Recursive step\n    return term + compute_pv_recursive(t + 1, next_y, current_beta_power * beta, params)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {'Y0': 100.0, 'R': 0.08, 'a': 0.25, 'b': 0.01, 'g_sequence': [0.4, 0.35, 0.3], 'H': 500, 'epsilon': 1e-12},\n        {'Y0': 50.0, 'R': 0.10, 'a': 0.30, 'b': 0.02, 'g_sequence': [1.0], 'H': 500, 'epsilon': 1e-12},\n        {'Y0': 120.0, 'R': 0.05, 'a': 0.20, 'b': 0.05, 'g_sequence': [0.05], 'H': 500, 'epsilon': 1e-12},\n        {'Y0': 80.0, 'R': 0.12, 'a': 0.40, 'b': 0.03, 'g_sequence': [0.6, 0.2, 0.1, 0.0], 'H': 500, 'epsilon': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initial parameters for the recursive calculation\n        t0 = 0\n        y0 = case['Y0']\n        beta = 1.0 / (1.0 + case['R'])\n        \n        # Add beta to the parameters dictionary to pass to the recursive function\n        case['beta'] = beta\n\n        # Initial call to the recursive function\n        pv = compute_pv_recursive(t0, y0, 1.0, case)\n        \n        # Round result to 6 decimal places\n        results.append(round(pv, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}