{"hands_on_practices": [{"introduction": "本次实践深入探讨了多样化的核心原则：增加投资组合中的资产数量如何系统性地降低其特有风险。通过一个正式的模型，您将发现资产数量与可消除的可分散风险量之间存在一个惊人简单而强大的关系。这个练习为“需要多少只股票才能实现多样化？”这个古老的问题提供了一个量化的答案 [@problem_id:2420248]。", "id": "2420248", "problem": "给定一个有限股票集合内的可分散风险的形式化模型。考虑一个由 $i \\in \\{1,\\dots,K\\}$ 索引的包含 $K$ 项资产的集合。每项资产 $i$ 都有一个特质方差 $d_i$（即该资产特质回报部分的方差）。假设各项资产的特质冲击相互独立，且独立于任何系统性部分。对于任意子集 $S \\subset \\{1,\\dots,K\\}$，其中 $|S| = N$，在 $S$ 上构建的等权重投资组合中，对于 $i \\in S$，权重为 $w_i = 1/N$。将该投资组合的可分散风险（特质方差贡献）定义为\n$$\nV_{\\text{idio}}(S) = \\sum_{i \\in S} w_i^2 d_i.\n$$\n将集合中单个资产的基准可分散风险定义为横截面均值\n$$\n\\bar d = \\frac{1}{K} \\sum_{i=1}^{K} d_i.\n$$\n对于给定的 $N$，一个等权重的 $N$ 资产投资组合的剩余可分散风险比例，是在规模为 $N$ 的子集 $S$ 的均匀随机选择下的期望值，定义为\n$$\nR(N) = \\mathbb{E}\\left[ \\frac{V_{\\text{idio}}(S)}{\\bar d} \\right],\n$$\n其中，期望是针对所有规模为 $N$ 的子集 $S$ 的均匀分布计算的。\n\n您的任务是：对于下述每个股票集合，实证确定所需的最小资产数量 $N$，使得在期望意义上，至少 $95\\%$ 的可分散风险被消除，即满足 $1 - R(N) \\ge 0.95$，等价于 $R(N) \\le 0.05$。如果在 $1 \\le N \\le K$ 的范围内不存在这样的 $N$，则输出 $-1$。所有比例必须以小数形式表示（例如，使用 $0.95$ 而不是百分号）。\n\n测试套件：\n\n- 案例 A：$K = 25$，特质方差\n  $(\\, $0.0289$, $0.0225$, $0.0361$, $0.0196$, $0.0400$, $0.0256$, $0.0324$, $0.0169$, $0.0484$, $0.0276$, $0.0304$, $0.0216$, $0.0336$, $0.0180$, $0.0450$, $0.0240$, $0.0260$, $0.0290$, $0.0310$, $0.0340$, $0.0380$, $0.0420$, $0.0460$, $0.0500$, $0.0550$ \\,)$，目标消除比例 $0.95$。\n\n- 案例 B：$K = 20$，特质方差\n  $(\\, $0.0200$, $0.0225$, $0.0256$, $0.0289$, $0.0324$, $0.0361$, $0.0400$, $0.0441$, $0.0484$, $0.0529$, $0.0196$, $0.0216$, $0.0230$, $0.0260$, $0.0290$, $0.0330$, $0.0370$, $0.0410$, $0.0450$, $0.0490$ \\,)$，目标消除比例 $0.95$。\n\n- 案例 C：$K = 19$，特质方差\n  $(\\, $0.0180$, $0.0190$, $0.0200$, $0.0210$, $0.0220$, $0.0230$, $0.0240$, $0.0250$, $0.0260$, $0.0270$, $0.0280$, $0.0290$, $0.0300$, $0.0310$, $0.0320$, $0.0330$, $0.0340$, $0.0350$, $0.0360$ \\,)$，目标消除比例 $0.95$。\n\n- 案例 D：$K = 30$，特质方差\n  $(\\, $0.0150$, $0.0160$, $0.0170$, $0.0180$, $0.0190$, $0.0200$, $0.0210$, $0.0220$, $0.0230$, $0.0240$, $0.0250$, $0.0260$, $0.0270$, $0.0280$, $0.0290$, $0.0300$, $0.0310$, $0.0320$, $0.0330$, $0.0340$, $0.0350$, $0.0360$, $0.0370$, $0.0380$, $0.0390$, $0.0400$, $0.0410$, $0.0420$, $0.0430$, $0.0440$ \\,)$，目标消除比例 $0.95$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如， $[\\,\\text{resultA},\\text{resultB},\\text{resultC},\\text{resultD}\\,]$）。每个结果必须是整数。如果对于给定的集合没有 $N$ 满足要求，则使用 $-1$。", "solution": "问题陈述是连贯的，并且基于成熟的金融理论。一个解析解是可能的，并且将被推导出来。目标是确定在 $1 \\le N \\le K$ 的约束下，将期望的可分散风险降低到指定水平所需的最小资产数量 $N$。\n\n风险消除的条件为 $1 - R(N) \\ge 0.95$，这等价于剩余可分散风险比例 $R(N)$ 小于或等于 $0.05$。目标是找到满足 $R(N) \\le 0.05$ 和约束条件 $1 \\le N \\le K$ 的最小整数 $N$。\n\n剩余风险比例定义为：\n$$\nR(N) = \\mathbb{E}\\left[ \\frac{V_{\\text{idio}}(S)}{\\bar d} \\right]\n$$\n其中，对于一个规模为 $N$ 的子集 $S$ 上的等权重投资组合（权重为 $w_i = 1/N$），投资组合的特质方差 $V_{\\text{idio}}(S)$ 为：\n$$\nV_{\\text{idio}}(S) = \\sum_{i \\in S} w_i^2 d_i = \\sum_{i \\in S} \\left(\\frac{1}{N}\\right)^2 d_i = \\frac{1}{N^2} \\sum_{i \\in S} d_i\n$$\n基准风险 $\\bar d = \\frac{1}{K} \\sum_{i=1}^{K} d_i$ 对于给定的资产集合是一个常数。因此，我们可以将它和其他常数移到期望算子之外：\n$$\nR(N) = \\frac{1}{\\bar d} \\mathbb{E}[V_{\\text{idio}}(S)] = \\frac{1}{N^2 \\bar d} \\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right]\n$$\n为了计算期望 $\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right]$，我们使用期望的线性性质。设 $\\mathbf{1}_{j \\in S}$ 为一个指示随机变量，如果资产 $j$ 在随机选择的投资组合 $S$ 中，则其值为 $1$，否则为 $0$。该和可以写成对整个 $K$ 个资产集合的求和：\n$$\n\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right] = \\mathbb{E}\\left[ \\sum_{j=1}^{K} d_j \\mathbf{1}_{j \\in S} \\right] = \\sum_{j=1}^{K} d_j \\mathbb{E}[\\mathbf{1}_{j \\in S}]\n$$\n期望 $\\mathbb{E}[\\mathbf{1}_{j \\in S}]$ 是任何特定资产 $j$ 被包含在从均匀随机选择的规模为 $N$ 的子集 $S$ 中的概率。此类子集的总数为 $\\binom{K}{N}$。要构造一个包含资产 $j$ 的子集，我们必须从剩下的 $K-1$ 个资产中选择其余的 $N-1$ 个资产，这有 $\\binom{K-1}{N-1}$ 种方法。因此，概率为：\n$$\nP(j \\in S) = \\frac{\\binom{K-1}{N-1}}{\\binom{K}{N}} = \\frac{(K-1)!}{(N-1)!(K-N)!} \\cdot \\frac{N!(K-N)!}{K!} = \\frac{N}{K}\n$$\n这个概率对于所有资产都是相同的。将此代入和的期望中：\n$$\n\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right] = \\sum_{j=1}^{K} d_j \\left(\\frac{N}{K}\\right) = \\frac{N}{K} \\sum_{j=1}^{K} d_j\n$$\n回顾平均特质方差的定义 $\\bar d = \\frac{1}{K} \\sum_{j=1}^{K} d_j$，我们有 $\\sum_{j=1}^{K} d_j = K \\bar d$。因此：\n$$\n\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right] = \\frac{N}{K} (K \\bar d) = N \\bar d\n$$\n现在我们将此结果代回 $R(N)$ 的表达式中：\n$$\nR(N) = \\frac{1}{N^2 \\bar d} (N \\bar d) = \\frac{1}{N}\n$$\n此推导得出了基本结果 $R(N) = 1/N$。一个关键的观察是，只要平均值 $\\bar d$ 非零，这个结果与特质方差 $\\{d_i\\}_{i=1}^K$ 的具体值或分布无关。因此，所提供的这些方差的数值数据与确定期望风险比例无关。\n\n问题要求找到最小整数 $N$ 使得 $R(N) \\le 0.05$。应用我们的结果：\n$$\n\\frac{1}{N} \\le 0.05\n$$\n解此不等式得 $N$：\n$$\nN \\ge \\frac{1}{0.05} \\implies N \\ge 20\n$$\n满足此条件的最小整数 $N$ 是 $N=20$。此解仅在可以从给定集合中构建此规模的投资组合时有效，即 $N$ 必须小于或等于 $K$。\n\n最终的逻辑如下：\n\\begin{enumerate}\n    \\item 如果集合规模 $K$ 大于或等于 $20$，则所需的最小资产数量为 $N=20$。\n    \\item 如果 $K$ 小于 $20$，则无法构建一个包含 $20$ 个资产的投资组合，因此在允许的范围 $1 \\le N \\le K$ 内不存在满足条件的 $N$。这种情况下答案是 $-1$。\n\\end{enumerate}\n\n将此推理应用于指定的测试案例：\n\\begin{itemize}\n    \\item 案例 A：$K = 25$。由于 $25 \\ge 20$，所需的最小 $N$ 是 $20$。\n    \\item 案例 B：$K = 20$。由于 $20 \\ge 20$，所需的最小 $N$ 是 $20$。\n    \\item 案例 C：$K = 19$。由于 $19 < 20$，不存在有效的 $N$。结果是 $-1$。\n    \\item 案例 D：$K = 30$。由于 $30 \\ge 20$，所需的最小 $N$ 是 $20$。\n\\end{itemize}\n每个案例的解完全由 $K$ 相对于推导出的阈值 $20$ 的值决定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum number of assets N to achieve a target risk elimination level.\n\n    As derived in the solution, the expected remaining diversifiable risk fraction R(N)\n    for an N-asset equal-weight portfolio is R(N) = 1/N. This result is independent\n    of the specific idiosyncratic variances of the assets.\n\n    The problem requires finding the minimum integer N such that R(N) <= 0.05,\n    which simplifies to 1/N <= 0.05, or N >= 20.\n\n    The solution N must also be within the bounds of the asset universe, 1 <= N <= K.\n    Therefore, if K >= 20, the minimum N is 20. If K < 20, no such N exists.\n    \"\"\"\n\n    # The test cases are defined by the total number of assets, K.\n    # The lists of idiosyncratic variances are superfluous to the problem's solution.\n    # The target elimination of 0.95 (implying R(N) <= 0.05) is constant across all cases.\n    test_cases_K = [\n        25,  # Case A\n        20,  # Case B\n        19,  # Case C\n        30,  # Case D\n    ]\n\n    # The required risk elimination fraction is 0.95.\n    target_elimination = 0.95\n    # This implies the remaining risk fraction, R(N), must be <= 1 - 0.95.\n    max_remaining_fraction = 1.0 - target_elimination\n\n    # From R(N) = 1/N, we need 1/N <= max_remaining_fraction.\n    # This implies N >= 1/max_remaining_fraction.\n    # For max_remaining_fraction = 0.05, this means N >= 20.\n    min_N_required = int(np.ceil(1.0 / max_remaining_fraction))\n\n    results = []\n    for K in test_cases_K:\n        # Check if a portfolio of the required size can be formed.\n        if K >= min_N_required:\n            # If the universe is large enough, the minimum N is the calculated threshold.\n            result = min_N_required\n        else:\n            # If the universe is too small, no solution exists.\n            result = -1\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "传统的投资组合理论使用方差作为风险的主要度量，同等对待所有与均值的偏差。本练习通过引入半方差来挑战这一观念，半方差是一种仅关注低于特定目标的收益的下行风险度量。您将应用数值优化技术，基于这种更精细的风险定义来构建有效前沿，这是后现代投资组合理论中的一个关键概念 [@problem_id:2420250]。", "id": "2420250", "problem": "给定一个风险资产组合的样本月度回报率，您需要使用相对于指定阈值的下行偏差（半方差）作为风险度量，重新计算有效前沿。一个投资组合由权重 $w \\in \\mathbb{R}^N$ 表示，其中对所有 $i$ 都有 $w_i \\geq 0$ 且 $\\sum_{i=1}^N w_i = 1$。给定资产回报向量 $r_t \\in \\mathbb{R}^N$ 的时间序列 $\\{r_t\\}_{t=1}^T$，样本投资组合期望回报率为 $\\mu(w) = \\frac{1}{T} \\sum_{t=1}^T w^\\top r_t$。对于给定的阈值 $\\tau \\in \\mathbb{R}$，样本半方差为\n$$\n\\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max\\!\\left(0,\\, \\tau - w^\\top r_t \\right)^2,\n$$\n而下行偏差为 $d(w;\\tau) = \\sqrt{\\sigma_-^2(w;\\tau)}$。所有回报率都是无单位的，并以小数形式表示。\n\n您的任务是针对下方指定的每个测试用例，计算在所有满足 $w_i \\ge 0$、$\\sum_{i=1}^N w_i = 1$ 和 $\\mu(w) \\ge \\mu_{\\text{target}}$ 的投资组合 $w$ 上的最小下行偏差 $d^\\star(\\mu_{\\text{target}},\\tau)$。\n\n数据：有 $N=3$ 种资产和 $T=12$ 个月。每种资产的月度回报率如下：\n\n- 资产1：$[-0.01,\\ 0.005,\\ 0.012,\\ 0.007,\\ -0.004,\\ 0.009,\\ 0.011,\\ 0.006,\\ 0.003,\\ 0.008,\\ 0.010,\\ 0.007]$。\n- 资产2：$[-0.015,\\ 0.012,\\ 0.018,\\ 0.010,\\ -0.006,\\ 0.015,\\ 0.020,\\ 0.011,\\ 0.004,\\ 0.013,\\ 0.019,\\ 0.012]$。\n- 资产3：$[-0.03,\\ 0.025,\\ 0.035,\\ 0.020,\\ -0.015,\\ 0.028,\\ 0.038,\\ 0.022,\\ 0.010,\\ 0.030,\\ 0.036,\\ 0.024]$。\n\n设第 $t$ 个月的资产回报为从上述序列中提取的列向量 $r_t \\in \\mathbb{R}^3$。\n\n测试套件：为下列每对参数 $(\\mu_{\\text{target}},\\tau)$ 计算 $d^\\star(\\mu_{\\text{target}},\\tau)$：\n\n- 案例1：$(\\mu_{\\text{target}},\\tau) = (0.007,\\ 0.0)$。\n- 案例2：$(\\mu_{\\text{target}},\\tau) = (0.012,\\ 0.005)$。\n- 案例3：$(\\mu_{\\text{target}},\\tau) = (0.018,\\ 0.015)$。\n- 案例4：$(\\mu_{\\text{target}},\\tau) = (0.0185833333333,\\ 0.020)$。\n\n约定与要求：\n\n- 所有回报率均为小数；不要使用百分号。\n- 每个案例的最终答案必须是最小化后的下行偏差值 $d^\\star(\\mu_{\\text{target}},\\tau)$，每个值都表示为精确到小数点后 $6$ 位的小数。\n- 您的程序必须生成单行输出，其中包含按上述案例顺序排列的结果，格式为方括号内以逗号分隔的列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是案例 $i$ 的四舍五入后的小数值。\n- 您的程序必须是一个完整、可运行的程序，它根据上述定义和所提供的数据从头开始计算所需的值，并以确切要求的格式生成输出。不允许用户输入，也不得使用外部文件。", "solution": "该问题已经过分析，并被确定为有效。这是一个在计算金融领域中适定的、有科学依据的问题，没有任何歧义或矛盾。\n\n任务是对于一个包含 $N=3$ 种资产的投资组合，在给定的 $T=12$ 个时期的回报率时间序列下，找到最小的下行偏差。这需要为几个指定的参数集求解一个约束非线性优化问题。\n\n投资组合由权重向量 $w \\in \\mathbb{R}^N$ 定义，其中 $w_i$ 是资产 $i$ 的权重。投资组合权重的约束条件是：\n1. 非负性：$w_i \\ge 0$ 对于 $i=1, 2, \\dots, N$。这意味着不允许卖空。\n2. 完全投资：$\\sum_{i=1}^N w_i = 1$。全部资本都分配在这些资产中。\n\n样本投资组合期望回报率定义为 $\\mu(w) = \\frac{1}{T} \\sum_{t=1}^T w^\\top r_t$，其中 $r_t \\in \\mathbb{R}^N$ 是在时间 $t$ 的资产回报向量。这可以简化为 $\\mu(w) = w^\\top \\bar{r}$，其中 $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^T r_t$ 是平均资产回报向量。\n\n风险度量是样本下行偏差 $d(w;\\tau) = \\sqrt{\\sigma_-^2(w;\\tau)}$，其中 $\\sigma_-^2(w;\\tau)$ 是相对于回报阈值 $\\tau$ 的样本半方差：\n$$\n\\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max\\!\\left(0,\\, \\tau - w^\\top r_t \\right)^2\n$$\n最小化下行偏差 $d(w;\\tau)$ 等价于最小化半方差 $\\sigma_-^2(w;\\tau)$，因为平方根函数对于非负值是严格单调的。这避免了在优化目标中处理平方根，从而简化了问题。\n\n对于每个由参数对 $(\\mu_{\\text{target}}, \\tau)$ 定义的测试用例，我们必须解决以下优化问题：\n$$\n\\begin{aligned}\n\\underset{w}{\\text{最小化}} \\quad & \\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max(0, \\tau - w^\\top r_t)^2 \\\\\n\\text{约束条件} \\quad & w \\in \\mathbb{R}^N \\\\\n& \\sum_{i=1}^N w_i = 1 \\\\\n& w_i \\ge 0, \\quad \\text{对于 } i=1, \\dots, N \\\\\n& \\mu(w) \\ge \\mu_{\\text{target}}\n\\end{aligned}\n$$\n这是一个凸优化问题，因为目标函数 $\\sigma_-^2(w;\\tau)$ 是 $w$ 的凸函数，并且约束条件定义了一个凸可行集（一个多胞体）。因此，找到的任何局部最小值也是全局最小值。\n\n该问题将使用序列最小二乘规划（SLSQP）算法进行数值求解，该算法非常适用于约束非线性优化。实现将使用 Python 中的 `scipy.optimize.minimize` 函数。求解器的输入包括：\n- 目标函数，它为给定的权重向量 $w$ 计算 $\\sigma_-^2(w;\\tau)$。\n- 约束集：一个关于权重总和的等式约束，一个关于最小目标回报的不等式约束，以及关于权重非负性的边界。\n- 权重 $w$ 的初始猜测值，一个标准的做法是选择等权重投资组合，即 $w_i = 1/N$。\n\n每个案例的最终答案 $d^\\star(\\mu_{\\text{target}},\\tau)$，是通过对优化器返回的最小化半方差取平方根得到的。所提供的资产回报数据和测试用例参数将被用来计算所要求的四个值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Computes the minimum downside deviation for a portfolio of assets\n    subject to a target return constraint.\n    \"\"\"\n    # Define asset return data\n    asset1_returns = np.array([-0.01, 0.005, 0.012, 0.007, -0.004, 0.009, 0.011, 0.006, 0.003, 0.008, 0.010, 0.007])\n    asset2_returns = np.array([-0.015, 0.012, 0.018, 0.010, -0.006, 0.015, 0.020, 0.011, 0.004, 0.013, 0.019, 0.012])\n    asset3_returns = np.array([-0.03, 0.025, 0.035, 0.020, -0.015, 0.028, 0.038, 0.022, 0.010, 0.030, 0.036, 0.024])\n\n    # Combine into a single matrix R of shape (T, N)\n    returns_matrix = np.vstack([asset1_returns, asset2_returns, asset3_returns]).T\n    \n    T, N = returns_matrix.shape\n    mean_asset_returns = np.mean(returns_matrix, axis=0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.007, 0.0),\n        (0.012, 0.005),\n        (0.018, 0.015),\n        (0.0185833333333, 0.020),\n    ]\n\n    results = []\n    for mu_target, tau in test_cases:\n        # Define the objective function (semi-variance) to be minimized.\n        # w: portfolio weights (optimization variable)\n        # R: matrix of asset returns\n        # T_val: number of time periods\n        # tau_val: downside deviation threshold\n        def objective_func(w, R, T_val, tau_val):\n            portfolio_returns = R @ w\n            downside_diffs = np.maximum(0, tau_val - portfolio_returns)\n            semi_variance = np.sum(downside_diffs**2) / T_val\n            return semi_variance\n\n        # Define constraints for the optimization\n        constraints = [\n            # Constraint 1: Sum of weights must be 1 (fully invested)\n            {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},\n            # Constraint 2: Portfolio expected return must meet or exceed target\n            {'type': 'ineq', 'fun': lambda w: w @ mean_asset_returns - mu_target}\n        ]\n\n        # Define bounds for the weights (w_i >= 0, no short selling)\n        bounds = [(0, None) for _ in range(N)]\n\n        # Initial guess for the weights (equal weighting)\n        w0 = np.ones(N) / N\n\n        # Perform the optimization using SLSQP\n        opt_result = minimize(\n            objective_func,\n            w0,\n            args=(returns_matrix, T, tau),\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            tol=1e-12  # Set a tight tolerance for accuracy\n        )\n\n        # The result from the optimizer is the minimized semi-variance\n        min_semi_variance = opt_result.fun\n        \n        # The required answer is the downside deviation (sqrt of semi-variance)\n        min_downside_deviation = np.sqrt(min_semi_variance)\n        \n        results.append(min_downside_deviation)\n\n    # Format the results as specified: a comma-separated list of decimals\n    # rounded to 6 places, enclosed in square brackets.\n    output_str = '[' + ','.join([f\"{r:.6f}\" for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "最优投资组合不是一成不变的；它们必须定期进行再平衡，而这一过程会产生实际的交易成本。这项高级实践超越了简单的均值-方差优化，引入了一个现实的、非线性的交易成本函数。通过实现一个基于梯度的优化算法，您将在向理论最优投资组合移动与实现该移动所需成本之间进行权衡 [@problem_id:2420328]。", "id": "2420328", "problem": "给定一个单周期投资组合再平衡问题，包含 $N$ 种资产、一个初始权重向量 $\\mathbf{w}^{0} \\in \\mathbb{R}^{N}$、一个期望收益向量 $\\boldsymbol{\\mu} \\in \\mathbb{R}^{N}$ 和一个对称正定协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{N \\times N}$。风险规避参数 $\\gamma \\in \\mathbb{R}_{+}$ 在均值-方差优化 (MVO) 目标中权衡期望收益与风险，且投资组合权重必须满足预算约束 $\\sum_{i=1}^{N} w_{i} = 1$。允许卖空，因此除了预算约束外，对 $\\mathbf{w}$ 没有不等式边界。再平衡会产生非线性交易成本，其函数为 $C(\\Delta \\mathbf{w}) = k \\sum_{i=1}^{N} |\\Delta w_{i}|^{1.5}$，其中系数 $k \\in \\mathbb{R}_{+}$，$\\Delta \\mathbf{w} = \\mathbf{w} - \\mathbf{w}^{0}$。所有答案都必须表示为不带单位的纯数字。\n\n您必须仅从期望收益、方差和给定交易成本函数的定义出发，不使用本问题陈述提供的任何快捷公式，完成以下任务：\n\n- 在预算约束下，将再平衡问题表述为净效用期望的最大化问题，使用平衡了期望收益和方差的基本 MVO 目标，并减去给定的交易成本。\n- 推导目标函数关于 $\\mathbf{w}$ 的梯度，并论证目标函数的凹性和可行集的凸性。\n- 设计一种计算方法，通过依赖梯度和投影算子的迭代法来解决该约束优化问题，其中投影算子在每一步强制执行预算约束 $\\sum_{i=1}^{N} w_{i} = 1$。确保非线性成本项的数值稳定性，并为您的线搜索或步长策略提供理由。\n\n您的程序必须实现此方法，并为以下每个测试用例计算最优的交易后权重向量 $\\mathbf{w}^{\\star}$。在所有案例中，请使用提供的确切数字。当给定数组或矩阵时，请完全按照规定使用。对于所有案例，预算约束均为 $\\sum_{i=1}^{N} w_{i} = 1$ 且允许卖空。\n\n测试套件：\n\n- 案例 $1$（具有非零交易成本的一般凹目标）：\n  - $N = 4$\n  - $\\boldsymbol{\\mu} = [0.08, 0.12, 0.10, 0.07]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.04, 0.09, 0.0625, 0.0324])$\n  - $\\gamma = 5.0$\n  - $k = 0.01$\n  - $\\mathbf{w}^{0} = [0.25, 0.25, 0.25, 0.25]$\n\n- 案例 $2$（交易成本为零的边界情况）：\n  - $N = 4$\n  - $\\boldsymbol{\\mu} = [0.08, 0.12, 0.10, 0.07]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.04, 0.09, 0.0625, 0.0324])$\n  - $\\gamma = 5.0$\n  - $k = 0.0$\n  - $\\mathbf{w}^{0} = [0.25, 0.25, 0.25, 0.25]$\n\n- 案例 $3$（高交易成本抑制再平衡）：\n  - $N = 4$\n  - $\\boldsymbol{\\mu} = [0.08, 0.12, 0.10, 0.07]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.04, 0.09, 0.0625, 0.0324])$\n  - $\\gamma = 5.0$\n  - $k = 10.0$\n  - $\\mathbf{w}^{0} = [0.10, 0.50, 0.20, 0.20]$\n\n- 案例 $4$（不同维度和参数）：\n  - $N = 3$\n  - $\\boldsymbol{\\mu} = [0.15, 0.05, 0.09]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.1225, 0.0225, 0.04])$\n  - $\\gamma = 8.0$\n  - $k = 0.02$\n  - $\\mathbf{w}^{0} = [0.20, 0.60, 0.20]$\n\n要求的最终输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 每个结果都必须是一个内部浮点数列表，表示相应测试用例的最优权重 $\\mathbf{w}^{\\star}$，其顺序与上面列出的案例顺序相同。\n- 将每个权重四舍五入到 $6$ 位小数。\n- 例如，输出的形状必须类似于 $[[w_{1,1}, w_{1,2}, \\dots],[w_{2,1}, \\dots],\\dots]$，并且程序必须只打印包含此列表的一行。\n\n您的程序必须是完全自包含的，不需要用户输入，并且只能使用标准库以及指定的允许库。答案是浮点数列表。此问题不涉及百分比、物理单位或角度单位。数学模型必须完全按照陈述实现，并且优化必须对每个案例强制执行 $\\sum_{i=1}^{N} w_{i} = 1$。", "solution": "该问题陈述经过严格验证，被认为是有效的。它基于现代投资组合理论和凸优化的原理，具有科学依据，是适定的，保证有唯一解，并且客观地陈述了所有必要的参数。\n\n该问题要求对一个单周期投资组合再平衡问题进行建模和求解，这是一个计算金融领域中的可形式化问题。所有数据都是自洽且一致的。\n\n问题在于找到最优的投资组合权重向量 $\\mathbf{w}^{\\star} \\in \\mathbb{R}^{N}$，该向量在考虑了期望收益、风险和交易成本后，能够最大化投资者的净效用。\n\n首先，我们构建优化问题。我们旨在最大化的投资者效用函数包含三个组成部分：投资组合的期望收益、对投资组合风险（方差）的惩罚，以及因再平衡而产生的交易成本。\n\n1.  **投资组合期望收益**：给定 $N$ 种资产的期望收益向量 $\\boldsymbol{\\mu} \\in \\mathbb{R}^{N}$ 和一个投资组合权重向量 $\\mathbf{w} \\in \\mathbb{R}^{N}$，期望收益是权重的线性函数：\n    $$ E[R_p] = \\mathbf{w}^T \\boldsymbol{\\mu} = \\sum_{i=1}^{N} w_i \\mu_i $$\n\n2.  **投资组合风险（方差）**：给定资产收益的协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{N \\times N}$，投资组合方差是权重的二次函数：\n    $$ \\text{Var}(R_p) = \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w} $$\n    均值-方差优化 (MVO) 的目标函数会对该方差进行惩罚，惩罚程度由风险规避参数 $\\gamma > 0$ 调节。为方便数学处理，我们采用标准形式，使用一个 $\\frac{1}{2}$ 的因子，得到风险惩罚项为 $\\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}$。\n\n3.  **交易成本**：从初始投资组合 $\\mathbf{w}^0$ 再平衡到新的投资组合 $\\mathbf{w}$ 会产生费用。权重变化为 $\\Delta \\mathbf{w} = \\mathbf{w} - \\mathbf{w}^0$。指定的成本函数是非线性的：\n    $$ C(\\Delta \\mathbf{w}) = k \\sum_{i=1}^{N} |\\Delta w_{i}|^{1.5} = k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5} $$\n    其中 $k > 0$ 是交易成本系数。\n\n要最大化的总目标函数 $f(\\mathbf{w})$ 是期望收益减去风险惩罚和交易成本：\n$$ f(\\mathbf{w}) = \\mathbf{w}^T \\boldsymbol{\\mu} - \\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w} - k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5} $$\n该最大化问题受制于预算约束，该约束要求权重之和为1：\n$$ \\sum_{i=1}^{N} w_i = 1 \\quad \\text{或，用向量表示法，} \\quad \\mathbf{1}^T \\mathbf{w} = 1 $$\n因此，完整的优化问题是：\n$$ \\underset{\\mathbf{w} \\in \\mathbb{R}^N}{\\text{maximize}} \\quad f(\\mathbf{w}) \\quad \\text{subject to} \\quad \\mathbf{1}^T \\mathbf{w} = 1 $$\n\n接下来，我们分析该问题的性质。由约束 $\\mathbf{1}^T \\mathbf{w} = 1$ 定义的可行集是 $\\mathbb{R}^N$ 中的一个仿射超平面，它是一个闭凸集。\n对于目标函数 $f(\\mathbf{w})$，我们通过检查其组成部分来分析其凹性。\n-   项 $\\mathbf{w}^T \\boldsymbol{\\mu}$ 是关于 $\\mathbf{w}$ 的线性项，因此它既是凹函数也是凸函数。\n-   项 $-\\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}$ 是一个二次型。由于给定 $\\boldsymbol{\\Sigma}$ 为正定矩阵且 $\\gamma > 0$，矩阵 $-\\frac{\\gamma}{2}\\boldsymbol{\\Sigma}$ 是负定的。这意味着该项是关于 $\\mathbf{w}$ 的严格凹函数。\n-   交易成本项是 $-k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5}$。对于 $x \\in \\mathbb{R}$，函数 $\\phi(x) = |x|^{1.5}$ 是一个凸函数。其二阶导数 $\\phi''(x) = 0.75 |x|^{-0.5}$ 在其定义域内是非负的。凸函数的和是凸函数，所以 $\\sum_{i=1}^{N} |w_i - w_i^0|^{1.5}$ 是凸函数。乘以 $-k$（其中 $k \\ge 0$）使得项 $-k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5}$ 成为一个凹函数。\n\n目标函数 $f(\\mathbf{w})$ 是一个线性函数（凹）、一个严格凹函数和一个凹函数的和。一个严格凹函数与其他凹函数之和是严格凹的。因此，$f(\\mathbf{w})$ 是一个严格凹函数。在一个闭的、非空的、凸的集合上最大化一个严格凹函数，其解是唯一的。\n\n为了通过计算解决此问题，我们按照要求设计一个基于投影梯度上升法的迭代算法。该方法在目标函数梯度的方向上迭代地前进一步，然后将得到的点投影回可行集上。\n\n需要目标函数的梯度 $\\nabla f(\\mathbf{w})$。我们逐项计算它：\n-   $\\nabla (\\mathbf{w}^T \\boldsymbol{\\mu}) = \\boldsymbol{\\mu}$\n-   $\\nabla (-\\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}) = -\\gamma \\boldsymbol{\\Sigma} \\mathbf{w}$ （利用 $\\boldsymbol{\\Sigma}$ 的对称性）\n-   对于成本项，我们求关于 $w_i$ 的偏导数：\n    $$ \\frac{\\partial}{\\partial w_i} \\left( -k \\sum_{j=1}^{N} |w_j - w_j^0|^{1.5} \\right) = -k \\frac{d}{d w_i} |w_i - w_i^0|^{1.5} $$\n    令 $u = w_i - w_i^0$。$|u|^{1.5}$ 关于 $u$ 的导数是 $1.5 \\cdot \\text{sgn}(u) \\cdot |u|^{0.5}$，它对于所有 $u \\in \\mathbb{R}$ 都是良定义且连续的。\n    因此，成本项的梯度是一个向量，其分量为 $-1.5k \\cdot \\text{sgn}(w_i - w_i^0) \\cdot |w_i - w_i^0|^{0.5}$。\n\n综合这些，完整的梯度是：\n$$ \\nabla f(\\mathbf{w}) = \\boldsymbol{\\mu} - \\gamma \\boldsymbol{\\Sigma} \\mathbf{w} - 1.5 k \\cdot \\mathbf{v}(\\mathbf{w}) $$\n其中 $\\mathbf{v}(\\mathbf{w})$ 是一个向量，其第 $i$ 个分量是 $v_i = \\text{sgn}(w_i - w_i^0) \\sqrt{|w_i - w_i^0|}$。在数值计算中，我们通过注意到导数为 $0$ 来处理 $w_i - w_i^0 = 0$ 的情况。\n\n投影梯度上升算法的步骤如下：\n1.  初始化权重 $\\mathbf{w}^{(0)}$，确保其满足预算约束（例如，$\\mathbf{w}^{(0)} = \\mathbf{w}^0$）。令 $t=0$。\n2.  重复直至收敛：\n    a.  计算梯度：$\\mathbf{g}^{(t)} = \\nabla f(\\mathbf{w}^{(t)})$。\n    b.  执行更新步骤：$\\mathbf{w}_{\\text{temp}}^{(t+1)} = \\mathbf{w}^{(t)} + \\alpha_t \\mathbf{g}^{(t)}$，其中 $\\alpha_t > 0$ 是步长。\n    c.  投影回可行集：$\\mathbf{w}^{(t+1)} = P(\\mathbf{w}_{\\text{temp}}^{(t+1)})$。将一个点 $\\mathbf{y}$ 投影到超平面 $\\mathbf{1}^T\\mathbf{w}=1$ 上的投影 $P(\\mathbf{y})$ 由以下公式给出：\n        $$ P(\\mathbf{y}) = \\mathbf{y} + \\left( \\frac{1 - \\mathbf{1}^T \\mathbf{y}}{N} \\right) \\mathbf{1} $$\n        该公式是通过最小化欧几里得距离 $||\\mathbf{w} - \\mathbf{y}||_2$（受限于 $\\mathbf{1}^T\\mathbf{w}=1$）推导出来的。\n    d.  增加 $t$。\n\n步长 $\\alpha_t$ 对收敛至关重要。一个固定的、小的步长可能有效，但效率低下。我们将使用回溯线搜索在每次迭代中确定一个合适的 $\\alpha_t$。此方法确保目标函数有足够的增加，并提供稳健的收敛性。从 $\\alpha$ 的一个初始猜测值开始，我们迭代地减小它（例如，乘以一个因子 $\\beta \\in (0,1)$），直到满足 Armijo-Goldstein 条件：\n$$ f(\\mathbf{w}^{(t+1)}) \\ge f(\\mathbf{w}^{(t)}) + c \\cdot (\\mathbf{g}^{(t)})^T (\\mathbf{w}^{(t+1)} - \\mathbf{w}^{(t)}) $$\n其中常数 $c \\in (0,1)$。\n\n当迭代之间的权重向量变化可忽略不计时，即对于一个很小的容差 $\\epsilon$，满足 $||\\mathbf{w}^{(t+1)} - \\mathbf{w}^{(t)}||_2 < \\epsilon$ 时，算法终止。\n\n为了数值稳定性，项 $\\sqrt{|w_i - w_i^0|}$ 被实现为 `np.sqrt(np.abs(w_i - w_i^0))`，以防止浮点运算可能导致平方根函数接收到负参数的任何问题。NumPy 中的 `np.sign` 函数能正确处理参数为零的情况。\n\n以下 Python 代码实现了这种带回溯线搜索的投影梯度上升算法，用以为每个给定的测试用例求解最优权重向量 $\\mathbf{w}^{\\star}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of portfolio rebalancing problems using\n    the Projected Gradient Ascent method with backtracking line search.\n    \"\"\"\n\n    def compute_objective(w, mu, Sigma, gamma, k, w0):\n        \"\"\"Computes the value of the objective function.\"\"\"\n        expected_return = w.T @ mu\n        risk_penalty = 0.5 * gamma * w.T @ Sigma @ w\n        delta_w = w - w0\n        transaction_cost = k * np.sum(np.abs(delta_w)**1.5)\n        return expected_return - risk_penalty - transaction_cost\n\n    def compute_gradient(w, mu, Sigma, gamma, k, w0):\n        \"\"\"Computes the gradient of the objective function.\"\"\"\n        delta_w = w - w0\n        # The derivative of |x|^1.5 is 1.5 * sgn(x) * |x|^0.5.\n        # np.sign(0) is 0, which is correct for the derivative at x=0.\n        grad_cost_term = 1.5 * k * np.sign(delta_w) * np.sqrt(np.abs(delta_w))\n        grad = mu - gamma * Sigma @ w - grad_cost_term\n        return grad\n\n    def project(y):\n        \"\"\"Projects a vector y onto the budget constraint hyperplane sum(w)=1.\"\"\"\n        N = len(y)\n        return y + (1 - np.sum(y)) / N * np.ones(N)\n\n    def optimize_portfolio(mu, Sigma, gamma, k, w0):\n        \"\"\"\n        Performs Projected Gradient Ascent to find the optimal portfolio.\n        \"\"\"\n        N = len(mu)\n        w = w0.copy()\n\n        # Hyperparameters for the optimization algorithm\n        max_iter = 50000\n        tolerance = 1e-12\n        alpha_init = 1.0  # Initial step size for backtracking\n        beta = 0.5      # Backtracking line search factor\n        c = 1e-4        # Armijo condition constant\n\n        for i in range(max_iter):\n            f_w = compute_objective(w, mu, Sigma, gamma, k, w0)\n            grad = compute_gradient(w, mu, Sigma, gamma, k, w0)\n            \n            alpha = alpha_init\n            while True:\n                w_temp = w + alpha * grad\n                w_new = project(w_temp)\n                \n                f_w_new = compute_objective(w_new, mu, Sigma, gamma, k, w0)\n                \n                # Armijo condition for sufficient increase\n                # Note: For maximization, we check f_new >= f_old + ...\n                if f_w_new >= f_w + c * np.dot(grad, w_new - w):\n                    break\n                \n                alpha *= beta\n                if alpha < 1e-15: # Prevent infinitely small step size\n                    break\n\n            # Convergence check\n            if np.linalg.norm(w_new - w) < tolerance:\n                w = w_new\n                break\n            \n            w = w_new\n        \n        return w\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 4,\n            \"mu\": np.array([0.08, 0.12, 0.10, 0.07]),\n            \"Sigma\": np.diag([0.04, 0.09, 0.0625, 0.0324]),\n            \"gamma\": 5.0,\n            \"k\": 0.01,\n            \"w0\": np.array([0.25, 0.25, 0.25, 0.25])\n        },\n        {\n            \"N\": 4,\n            \"mu\": np.array([0.08, 0.12, 0.10, 0.07]),\n            \"Sigma\": np.diag([0.04, 0.09, 0.0625, 0.0324]),\n            \"gamma\": 5.0,\n            \"k\": 0.0,\n            \"w0\": np.array([0.25, 0.25, 0.25, 0.25])\n        },\n        {\n            \"N\": 4,\n            \"mu\": np.array([0.08, 0.12, 0.10, 0.07]),\n            \"Sigma\": np.diag([0.04, 0.09, 0.0625, 0.0324]),\n            \"gamma\": 5.0,\n            \"k\": 10.0,\n            \"w0\": np.array([0.10, 0.50, 0.20, 0.20])\n        },\n        {\n            \"N\": 3,\n            \"mu\": np.array([0.15, 0.05, 0.09]),\n            \"Sigma\": np.diag([0.1225, 0.0225, 0.04]),\n            \"gamma\": 8.0,\n            \"k\": 0.02,\n            \"w0\": np.array([0.20, 0.60, 0.20])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        w_star = optimize_portfolio(\n            case[\"mu\"], case[\"Sigma\"], case[\"gamma\"], case[\"k\"], case[\"w0\"]\n        )\n        # Round each weight to 6 decimal places and convert to list\n        rounded_weights = np.round(w_star, 6).tolist()\n        results.append(rounded_weights)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) and join is tricky for lists of lists.\n    # We build the string representation manually.\n    result_str = \",\".join([str(res) for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"}]}