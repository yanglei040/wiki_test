{"hands_on_practices": [{"introduction": "预期效用理论不仅适用于金融投资，它还能为现实世界中复杂的决策提供清晰的分析框架。本练习将理论应用于法律领域，探讨原告在接受确定的和解金与面对不确定的庭审结果之间的抉择。通过推导使原告对两种选择无差异的和解金额 $S^{\\\\ast}$，你将亲身体验如何运用确定性等价的核心概念，将主观偏好和风险量化为客观的决策依据 [@problem_id:2391038]。", "id": "2391038", "problem": "一位拥有初始财富 $W>0$ 的原告面临一个抉择：是接受一笔确定的和解金，还是提起诉讼。根据期望效用理论（EUT），原告使用一个恒定相对风险厌恶（CRRA）效用函数 $u(x)=\\frac{x^{1-\\gamma}}{1-\\gamma}$ 来评估结果，其中风险厌恶系数 $\\gamma>0$ 且 $\\gamma\\neq 1$，定义域为 $x>0$。\n\n如果原告接受金额为 $S\\geq 0$ 的和解，原告将产生一笔与和解相关的成本 $K_{S}\\geq 0$，并以确定的最终财富 $W+S-K_{S}$ 告终。如果原告提起诉讼，法院有 $p\\in(0,1)$ 的概率判给总计 $D>0$ 的损害赔偿，否则判为零。律师通过风险代理费获得报酬，费率为判赔总额的 $c\\in(0,1)$。因此，如果原告胜诉，原告将收到净损害赔偿 $(1-c)D$。提起诉讼会产生一笔由原告承担的诉讼成本 $K_{T}\\geq 0$，无论结果如何，这笔费用都需支付。因此，在诉讼情况下，原告的最终财富有 $p$ 的概率为 $W-K_T+(1-c)D$，有 $1-p$ 的概率为 $W-K_T$。\n\n假设所有相关的最终财富水平都严格为正：$W-K_{T}>0$，$W-K_{T}+(1-c)D>0$ 和 $W+S-K_{S}>0$。\n\n设 $S^{\\ast}$ 为在期望效用最大化原则下，使原告在接受和解与提起诉讼之间无差异的和解金额。请推导 $S^{\\ast}$ 关于参数 $W$、$\\gamma$、$p$、$D$、$c$、$K_{S}$ 和 $K_{T}$ 的闭式表达式。您的最终答案必须是一个单一的解析表达式。请勿进行近似。", "solution": "在尝试任何求解之前，需对问题陈述进行验证。\n\n逐字提取已知条件：\n- 初始财富：$W > 0$。\n- 效用函数：$u(x) = \\frac{x^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma > 0$，$\\gamma \\neq 1$，定义域为 $x > 0$。\n- 和解金额：$S \\geq 0$。\n- 和解成本：$K_S \\geq 0$。\n- 接受和解后的最终财富：$W + S - K_S$。\n- 庭审胜诉概率：$p \\in (0,1)$。\n- 总损害赔偿：$D > 0$。\n- 风险代理费率：$c \\in (0,1)$。\n- 净损害赔偿：$(1-c)D$。\n- 诉讼成本：$K_T \\geq 0$。\n- 庭审胜诉后的最终财富：$W - K_T + (1-c)D$。\n- 庭审败诉后的最终财富：$W - K_T$。\n- 正值假设：$W - K_T > 0$，$W - K_T + (1-c)D > 0$，以及 $W + S - K_S > 0$。\n- 目标：推导无差异和解金额 $S^{\\ast}$ 的闭式表达式。\n\n该问题在科学上基于期望效用理论，这是经济学中的一个基础概念。这是一个适定的问题，所有必要的参数和约束都已定义，可以得到唯一解。其语言客观而精确。所有假设，如最终财富状态为正值，都已明确说明，以确保效用函数是良定义的。因此，该问题是有效的。我们可以开始推导。\n\n核心原则是，如果从确定选项（和解）中获得的效用等于从不确定选项（诉讼）中获得的期望效用，则原告对这两个选项无差异。\n\n设 $S^{\\ast}$ 为使原告无差异的和解金额。接受此和解的最终财富是一个确定的数额，我们记为 $W_{S^{\\ast}}$。\n$$\nW_{S^{\\ast}} = W + S^{\\ast} - K_S\n$$\n这个确定结果的效用是 $u(W_{S^{\\ast}})$。\n\n如果原告提起诉讼，其结果是一场博弈。设胜诉时的最终财富为 $W_{win}$，败诉时的最终财富为 $W_{lose}$。\n$$\nW_{win} = W - K_T + (1-c)D\n$$\n$$\nW_{lose} = W - K_T\n$$\n胜诉的概率是 $p$，败诉的概率是 $1-p$。诉讼的期望效用，记为 $E[u(\\text{Trial})]$，是各种可能结果效用的概率加权平均值。\n$$\nE[u(\\text{Trial})] = p \\cdot u(W_{win}) + (1-p) \\cdot u(W_{lose})\n$$\n因此，无差异条件为：\n$$\nu(W_{S^{\\ast}}) = E[u(\\text{Trial})]\n$$\n将指定的 CRRA 效用函数 $u(x) = \\frac{x^{1-\\gamma}}{1-\\gamma}$ 代入无差异条件，得到：\n$$\n\\frac{(W_{S^{\\ast}})^{1-\\gamma}}{1-\\gamma} = p \\frac{(W_{win})^{1-\\gamma}}{1-\\gamma} + (1-p) \\frac{(W_{lose})^{1-\\gamma}}{1-\\gamma}\n$$\n由于问题陈述 $\\gamma \\neq 1$，分母 $(1-\\gamma)$ 非零，可以从所有项中约去。\n$$\n(W_{S^{\\ast}})^{1-\\gamma} = p (W_{win})^{1-\\gamma} + (1-p) (W_{lose})^{1-\\gamma}\n$$\n这个方程定义了确定性等价关系。$W_{S^{\\ast}}$ 项是诉讼博弈的确定性等价财富，并根据与和解相关的成本进行了调整。为了解出 $W_{S^{\\ast}}$，我们将方程两边同时取 $\\frac{1}{1-\\gamma}$ 次方。\n$$\nW_{S^{\\ast}} = \\left[ p (W_{win})^{1-\\gamma} + (1-p) (W_{lose})^{1-\\gamma} \\right]^{\\frac{1}{1-\\gamma}}\n$$\n现在，我们代入 $W_{S^{\\ast}}$、$W_{win}$ 和 $W_{lose}$ 的表达式：\n$$\nW + S^{\\ast} - K_S = \\left[ p (W - K_T + (1-c)D)^{1-\\gamma} + (1-p) (W - K_T)^{1-\\gamma} \\right]^{\\frac{1}{1-\\gamma}}\n$$\n最后一步是通过代数方法分离出 $S^{\\ast}$。这是一个简单的移项。\n$$\nS^{\\ast} = \\left[ p(W - K_T + (1-c)D)^{1-\\gamma} + (1-p)(W - K_T)^{1-\\gamma} \\right]^{\\frac{1}{1-\\gamma}} - W + K_S\n$$\n这个表达式给出了无差异和解金额 $S^{\\ast}$ 作为给定参数函数的闭式表达式。所有最终财富状态都严格为正的假设确保了所有取幂的项都是正的，从而使表达式是良定义的。", "answer": "$$\n\\boxed{\\left[ p(W - K_T + (1-c)D)^{1-\\gamma} + (1-p)(W - K_T)^{1-\\gamma} \\right]^{\\frac{1}{1-\\gamma}} - W + K_S}\n$$"}, {"introduction": "在真实世界的决策中，我们考量的往往不仅是金钱收益。这个练习将预期效用理论扩展到一个更复杂的场景：一位农民在选择作物时，既要考虑利润，又要顾及作物对气候变化的“韧性”。通过构建一个同时包含风险规避和环境考量的效用函数，并编写程序来求解最优选择，你将学会如何定制和应用预期效用模型来解决包含多重目标的实际优化问题 [@problem_id:2391045]。", "id": "2391045", "problem": "考虑一个由 $c \\in \\{1,2,\\dots,C\\}$ 索引的有限作物集合和一个由 $s \\in \\{1,2,\\dots,S\\}$ 索引的有限气候状态集合。每种气候状态 $s$ 发生的概率为 $p_s$，其中 $\\sum_{s=1}^{S} p_s = 1$，并且具有一个不利严重性参数 $k_s \\in [0,1]$。一种作物 $c$ 具有基础产量 $y_c > 0$、恢复力参数 $\\rho_c \\in [0,1]$ 和生产成本 $C_c \\ge 0$。市场价格为 $P > 0$。在气候状态 $s$ 下，作物 $c$ 的实现产量因子为 $1 - k_s(1 - \\rho_c)$，因此作物 $c$ 在状态 $s$ 下的状态依存利润为\n$$\nx_{c,s} \\;=\\; P \\, y_c \\, \\bigl(1 - k_s(1 - \\rho_c)\\bigr) \\;-\\; C_c.\n$$\n在下文的参数化设置中，假设对于所有作物 $c$ 和状态 $s$ 都有 $x_{c,s} > 0$。\n\n农民使用期望效用评估作物选择，其状态依赖效用函数同时包含了利润和作物恢复力。令 $\\gamma \\ge 0$ 表示恒定相对风险厌恶 (CRRA) 系数，令 $\\eta \\ge 0$ 作为恢复力贡献的权重。当 $\\gamma \\ne 1$ 时，作物 $c$ 在状态 $s$ 下的单一状态效用定义为\n$$\nu(x_{c,s},\\rho_c) \\;=\\; \\frac{x_{c,s}^{\\,1-\\gamma}}{1-\\gamma} \\;+\\; \\eta \\,\\ln\\!\\bigl(1+\\rho_c\\bigr),\n$$\n作物 $c$ 的期望效用定义为\n$$\n\\mathrm{EU}_c \\;=\\; \\sum_{s=1}^{S} p_s \\, u(x_{c,s},\\rho_c).\n$$\n决策问题是选择 $c^\\star \\in \\arg\\max_{c \\in \\{1,\\dots,C\\}} \\mathrm{EU}_c$。如果两种或多种作物的期望效用完全相等，则在最大化者中选择最小的索引 $c$。\n\n您的任务是编写一个完整的程序，针对以下每个独立的测试用例，返回在给定参数下使期望效用最大化的作物的 1-based 索引。\n\n测试套件：\n- 测试用例 A (基准线，两种气候状态)：\n  - $P = 250$, $\\gamma = 0.5$, $\\eta = 50$。\n  - 气候：$S=2$，概率 $(p_1,p_2) = (0.7, 0.3)$，严重性 $(k_1,k_2) = (0.0, 0.4)$。\n  - 作物：$C=3$。\n    - $c=1$：$y_1 = 4.0$, $C_1 = 400$, $\\rho_1 = 0.2$。\n    - $c=2$：$y_2 = 3.5$, $C_2 = 320$, $\\rho_2 = 0.6$。\n    - $c=3$：$y_3 = 3.8$, $C_3 = 360$, $\\rho_3 = 0.4$。\n- 测试用例 B (风险中性，忽略恢复力)：\n  - $P = 200$, $\\gamma = 0.0$, $\\eta = 0.0$。\n  - 气候：$S=2$，概率 $(p_1,p_2) = (0.4, 0.6)$，严重性 $(k_1,k_2) = (0.0, 0.5)$。\n  - 作物：$C=3$。\n    - $c=1$：$y_1 = 5.0$, $C_1 = 700$, $\\rho_1 = 0.9$。\n    - $c=2$：$y_2 = 4.0$, $C_2 = 400$, $\\rho_2 = 0.2$。\n    - $c=3$：$y_3 = 4.5$, $C_3 = 550$, $\\rho_3 = 0.5$。\n- 测试用例 C (单一状态，高风险厌恶，重视恢复力)：\n  - $P = 300$, $\\gamma = 2.0$, $\\eta = 20.0$。\n  - 气候：$S=1$，概率 $(p_1) = (1.0)$，严重性 $(k_1) = (0.7)$。\n  - 作物：$C=3$。\n    - $c=1$：$y_1 = 3.0$, $C_1 = 200$, $\\rho_1 = 0.0$。\n    - $c=2$：$y_2 = 3.4$, $C_2 = 180$, $\\rho_2 = 0.5$。\n    - $c=3$：$y_3 = 2.8$, $C_3 = 150$, $\\rho_3 = 0.9$。\n- 测试用例 D (人为构造的平局情况)：\n  - $P = 100$, $\\gamma = 0.8$, $\\eta = 10.0$。\n  - 气候：$S=2$，概率 $(p_1,p_2) = (0.5, 0.5)$，严重性 $(k_1,k_2) = (0.0, 0.2)$。\n  - 作物：$C=3$。\n    - $c=1$：$y_1 = 2.0$, $C_1 = 50$, $\\rho_1 = 0.3$。\n    - $c=2$：$y_2 = 2.0$, $C_2 = 50$, $\\rho_2 = 0.3$。\n    - $c=3$：$y_3 = 1.8$, $C_3 = 60$, $\\rho_3 = 0.1$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含四个测试用例所选作物的索引，格式为由方括号括起来的逗号分隔列表，例如 $[c_A,c_B,c_C,c_D]$，其中每个 $c_\\cdot$ 是一个 $\\{1,2,3\\}$ 中的整数，对应于在指定平局打破规则下实现最大化的作物。", "solution": "该问题已经过验证，被认为是有效的。它在科学上基于期望效用理论，问题设定良好，有明确的目标，并通过平局打破规则保证了唯一解，同时指定了所有必要的参数和定义。该问题是不确定性下决策理论的一个直接应用。\n\n决策者的目标是从有限集合 $\\{1, 2, \\dots, C\\}$ 中选择一个作物 $c$，以最大化期望效用。作物 $c$ 的期望效用，表示为 $\\mathrm{EU}_c$，是在一组气候状态 $s \\in \\{1, 2, \\dots, S\\}$ 上定义的，每个状态以概率 $p_s$ 发生。\n\n对于 $\\gamma \\ne 1$，作物 $c$ 在状态 $s$ 下的单一状态效用函数为：\n$$\nu(x_{c,s},\\rho_c) = \\frac{x_{c,s}^{\\,1-\\gamma}}{1-\\gamma} + \\eta \\,\\ln(1+\\rho_c)\n$$\n其中 $x_{c,s}$ 是状态依存利润，$\\rho_c$ 是作物的恢复力，$\\gamma$ 是恒定相对风险厌恶系数，$\\eta$ 是恢复力对效用贡献的权重。利润 $x_{c,s}$ 由以下公式确定：\n$$\nx_{c,s} = P \\, y_c \\, \\bigl(1 - k_s(1 - \\rho_c)\\bigr) - C_c\n$$\n其中 $P$ 是市场价格，$y_c$ 是基础产量，$k_s$ 是状态严重性，$C_c$ 是生产成本。问题陈述保证 $x_{c,s} > 0$。\n\n作物 $c$ 的期望效用是单一状态效用的概率加权和：\n$$\n\\mathrm{EU}_c = \\sum_{s=1}^{S} p_s \\, u(x_{c,s},\\rho_c) = \\sum_{s=1}^{S} p_s \\left( \\frac{x_{c,s}^{\\,1-\\gamma}}{1-\\gamma} + \\eta \\,\\ln(1+\\rho_c) \\right)\n$$\n由于对于给定的作物 $c$，项 $\\eta \\,\\ln(1+\\rho_c)$ 在所有状态 $s$ 中是恒定的，我们可以简化表达式：\n$$\n\\mathrm{EU}_c = \\left( \\sum_{s=1}^{S} p_s \\frac{x_{c,s}^{\\,1-\\gamma}}{1-\\gamma} \\right) + \\eta \\,\\ln(1+\\rho_c) \\left( \\sum_{s=1}^{S} p_s \\right)\n$$\n考虑到 $\\sum_{s=1}^{S} p_s = 1$，该表达式可简化为：\n$$\n\\mathrm{EU}_c = \\left( \\sum_{s=1}^{S} p_s \\frac{x_{c,s}^{\\,1-\\gamma}}{1-\\gamma} \\right) + \\eta \\,\\ln(1+\\rho_c)\n$$\n这种形式在计算上更高效。最优作物 $c^\\star$是使该值最大化的作物，平局则通过选择最小的作物索引来打破。\n\n我们现在将此过程应用于每个测试用例。\n\n测试用例 A：$P = 250$, $\\gamma = 0.5$, $\\eta = 50$。\n气候状态：$S=2$，概率 $(p_1, p_2) = (0.7, 0.3)$，严重性 $(k_1, k_2) = (0.0, 0.4)$。\n效用以 $1-\\gamma = 0.5$ 计算。\n\n作物 1：$y_1=4.0$, $C_1=400$, $\\rho_1=0.2$。\n$x_{1,1} = 250 \\cdot 4.0 \\cdot (1 - 0.0(1-0.2)) - 400 = 600$。\n$x_{1,2} = 250 \\cdot 4.0 \\cdot (1 - 0.4(1-0.2)) - 400 = 280$。\n$\\mathrm{EU}_1 = \\left( 0.7 \\frac{600^{0.5}}{0.5} + 0.3 \\frac{280^{0.5}}{0.5} \\right) + 50 \\ln(1+0.2) \\approx 53.448$。\n\n作物 2：$y_2=3.5$, $C_2=320$, $\\rho_2=0.6$。\n$x_{2,1} = 250 \\cdot 3.5 \\cdot (1 - 0.0(1-0.6)) - 320 = 555$。\n$x_{2,2} = 250 \\cdot 3.5 \\cdot (1 - 0.4(1-0.6)) - 320 = 415$。\n$\\mathrm{EU}_2 = \\left( 0.7 \\frac{555^{0.5}}{0.5} + 0.3 \\frac{415^{0.5}}{0.5} \\right) + 50 \\ln(1+0.6) \\approx 68.704$。\n\n作物 3：$y_3=3.8$, $C_3=360$, $\\rho_3=0.4$。\n$x_{3,1} = 250 \\cdot 3.8 \\cdot (1 - 0.0(1-0.4)) - 360 = 590$。\n$x_{3,2} = 250 \\cdot 3.8 \\cdot (1 - 0.4(1-0.4)) - 360 = 362$。\n$\\mathrm{EU}_3 = \\left( 0.7 \\frac{590^{0.5}}{0.5} + 0.3 \\frac{362^{0.5}}{0.5} \\right) + 50 \\ln(1+0.4) \\approx 62.247$。\n\n比较：$\\mathrm{EU}_2 > \\mathrm{EU}_3 > \\mathrm{EU}_1$。最优选择是 $c^\\star = 2$。\n\n测试用例 B：$P = 200$, $\\gamma = 0.0$, $\\eta = 0.0$。\n这里 $\\gamma=0$ 且 $\\eta=0$。效用函数简化为 $u(x_{c,s}) = x_{c,s}$，目标是最大化期望利润 $\\mathrm{E}[x_c] = \\sum_{s=1}^S p_s x_{c,s}$。\n气候状态：$S=2$，概率 $(p_1, p_2) = (0.4, 0.6)$，严重性 $(k_1, k_2) = (0.0, 0.5)$。\n\n作物 1：$y_1=5.0$, $C_1=700$, $\\rho_1=0.9$。\n$x_{1,1} = 200 \\cdot 5.0 \\cdot (1) - 700 = 300$。\n$x_{1,2} = 200 \\cdot 5.0 \\cdot (1 - 0.5(1-0.9)) - 700 = 250$。\n$\\mathrm{EU}_1 = 0.4 \\cdot 300 + 0.6 \\cdot 250 = 120 + 150 = 270$。\n\n作物 2：$y_2=4.0$, $C_2=400$, $\\rho_2=0.2$。\n$x_{2,1} = 200 \\cdot 4.0 \\cdot (1) - 400 = 400$。\n$x_{2,2} = 200 \\cdot 4.0 \\cdot (1 - 0.5(1-0.2)) - 400 = 80$。\n$\\mathrm{EU}_2 = 0.4 \\cdot 400 + 0.6 \\cdot 80 = 160 + 48 = 208$。\n\n作物 3：$y_3=4.5$, $C_3=550$, $\\rho_3=0.5$。\n$x_{3,1} = 200 \\cdot 4.5 \\cdot (1) - 550 = 350$。\n$x_{3,2} = 200 \\cdot 4.5 \\cdot (1 - 0.5(1-0.5)) - 550 = 125$。\n$\\mathrm{EU}_3 = 0.4 \\cdot 350 + 0.6 \\cdot 125 = 140 + 75 = 215$。\n\n比较：$\\mathrm{EU}_1 > \\mathrm{EU}_3 > \\mathrm{EU}_2$。最优选择是 $c^\\star = 1$。\n\n测试用例 C：$P = 300$, $\\gamma = 2.0$, $\\eta = 20.0$。\n气候状态：$S=1$，概率 $(p_1) = (1.0)$，严重性 $(k_1) = (0.7)$。\n这是一个确定性情况。$\\mathrm{EU}_c$ 就是 $u(x_{c,1}, \\rho_c)$。\n效用以 $1-\\gamma = -1$ 计算，因此 $u(x, \\rho) = -x^{-1} + \\eta \\ln(1+\\rho)$。\n\n作物 1：$y_1=3.0$, $C_1=200$, $\\rho_1=0.0$。\n$x_{1,1} = 300 \\cdot 3.0 \\cdot (1 - 0.7(1-0.0)) - 200 = 70$。\n$\\mathrm{EU}_1 = -1/70 + 20 \\ln(1.0) \\approx -0.01429$。\n\n作物 2：$y_2=3.4$, $C_2=180$, $\\rho_2=0.5$。\n$x_{2,1} = 300 \\cdot 3.4 \\cdot (1 - 0.7(1-0.5)) - 180 = 483$。\n$\\mathrm{EU}_2 = -1/483 + 20 \\ln(1.5) \\approx 8.1073$。\n\n作物 3：$y_3=2.8$, $C_3=150$, $\\rho_3=0.9$。\n$x_{3,1} = 300 \\cdot 2.8 \\cdot (1 - 0.7(1-0.9)) - 150 = 631.2$。\n$\\mathrm{EU}_3 = -1/631.2 + 20 \\ln(1.9) \\approx 12.8354$。\n\n比较：$\\mathrm{EU}_3 > \\mathrm{EU}_2 > \\mathrm{EU}_1$。最优选择是 $c^\\star = 3$。\n\n测试用例 D：$P = 100$, $\\gamma = 0.8$, $\\eta = 10.0$。\n气候状态：$S=2$，概率 $(p_1,p_2) = (0.5, 0.5)$，严重性 $(k_1,k_2) = (0.0, 0.2)$。\n效用以 $1-\\gamma = 0.2$ 计算。\n\n作物 1 和 2 是相同的：$y=2.0$, $C=50$, $\\rho=0.3$。它们将具有相同的期望效用。\n$x_{\\cdot,1} = 100 \\cdot 2.0 \\cdot (1) - 50 = 150$。\n$x_{\\cdot,2} = 100 \\cdot 2.0 \\cdot (1 - 0.2(1-0.3)) - 50 = 122$。\n$\\mathrm{EU}_{1,2} = \\left( 0.5 \\frac{150^{0.2}}{0.2} + 0.5 \\frac{122^{0.2}}{0.2} \\right) + 10 \\ln(1+0.3) \\approx 15.9661$。\n\n作物 3：$y_3=1.8$, $C_3=60$, $\\rho_3=0.1$。\n$x_{3,1} = 100 \\cdot 1.8 \\cdot (1) - 60 = 120$。\n$x_{3,2} = 100 \\cdot 1.8 \\cdot (1 - 0.2(1-0.1)) - 60 = 87.6$。\n$\\mathrm{EU}_3 = \\left( 0.5 \\frac{120^{0.2}}{0.2} + 0.5 \\frac{87.6^{0.2}}{0.2} \\right) + 10 \\ln(1+0.1) \\approx 13.5806$。\n\n比较：$\\mathrm{EU}_1 = \\mathrm{EU}_2 > \\mathrm{EU}_3$。最大化效用的作物是 1 和 2。平局打破规则要求选择最小的索引。最优选择是 $c^\\star = 1$。\n\n最终结果：\n- 测试用例 A：$c^\\star = 2$\n- 测试用例 B：$c^\\star = 1$\n- 测试用例 C：$c^\\star = 3$\n- 测试用例 D：$c^\\star = 1$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_optimal_crop(P, gamma, eta, climate, crops):\n    \"\"\"\n    Calculates the optimal crop based on expected utility maximization.\n\n    Args:\n        P (float): Market price.\n        gamma (float): CRRA coefficient.\n        eta (float): Resilience weight in utility.\n        climate (dict): Dictionary with climate state probabilities 'p' and severities 'k'.\n        crops (list): A list of dictionaries, where each dictionary defines a crop's\n                      parameters 'y' (yield), 'C' (cost), and 'rho' (resilience).\n\n    Returns:\n        int: The 1-based index of the optimal crop.\n    \"\"\"\n    num_crops = len(crops)\n    expected_utilities = np.zeros(num_crops)\n\n    p_s = np.array(climate['p'])\n    k_s = np.array(climate['k'])\n\n    for c_idx, crop_data in enumerate(crops):\n        y_c = crop_data['y']\n        C_c = crop_data['C']\n        rho_c = crop_data['rho']\n\n        # Calculate state-contingent profits x_{c,s} as a numpy array\n        # x_cs = P * y_c * (1 - k_s * (1 - rho_c)) - C_c\n        x_cs = P * y_c * (1 - k_s * (1 - rho_c)) - C_c\n\n        # The expected utility is separable into a profit component and a resilience component.\n        # EU_c = E[u(profit)] + u(resilience)\n        # This is derived from EU_c = sum(p_s * (u_profit_s + u_resilience))\n        # which simplifies to sum(p_s * u_profit_s) + u_resilience * sum(p_s)\n        # and since sum(p_s) = 1, it becomes E[u(profit)] + u(resilience).\n\n        # Calculate the expected utility from profit\n        if gamma == 0.0:\n            # For gamma = 0, u(x) = x, so EU is expected profit.\n            profit_utility_part = np.sum(p_s * x_cs)\n        else:\n            # For gamma != 1 (as per problem), u(x) = x^(1-gamma) / (1-gamma).\n            # The problem guarantees x_cs > 0.\n            profit_utility_part = np.sum(p_s * (np.power(x_cs, 1 - gamma) / (1 - gamma)))\n\n        # Calculate the utility from resilience\n        resilience_utility_part = eta * np.log(1 + rho_c)\n\n        expected_utilities[c_idx] = profit_utility_part + resilience_utility_part\n\n    # Find the crop with the maximum EU.\n    # np.argmax() returns the index of the first occurrence of the maximum value,\n    # which correctly implements the specified tie-breaking rule (select smallest index).\n    # Add 1 to convert from 0-based to 1-based index.\n    optimal_crop_index = np.argmax(expected_utilities) + 1\n    \n    return optimal_crop_index\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the crop selection problem.\n    \"\"\"\n    test_cases = [\n        # Test case A: baseline\n        {\n            \"P\": 250.0, \"gamma\": 0.5, \"eta\": 50.0,\n            \"climate\": {\"p\": [0.7, 0.3], \"k\": [0.0, 0.4]},\n            \"crops\": [\n                {\"y\": 4.0, \"C\": 400.0, \"rho\": 0.2},\n                {\"y\": 3.5, \"C\": 320.0, \"rho\": 0.6},\n                {\"y\": 3.8, \"C\": 360.0, \"rho\": 0.4}\n            ]\n        },\n        # Test case B: risk-neutral, resilience ignored\n        {\n            \"P\": 200.0, \"gamma\": 0.0, \"eta\": 0.0,\n            \"climate\": {\"p\": [0.4, 0.6], \"k\": [0.0, 0.5]},\n            \"crops\": [\n                {\"y\": 5.0, \"C\": 700.0, \"rho\": 0.9},\n                {\"y\": 4.0, \"C\": 400.0, \"rho\": 0.2},\n                {\"y\": 4.5, \"C\": 550.0, \"rho\": 0.5}\n            ]\n        },\n        # Test case C: single-state, high risk aversion\n        {\n            \"P\": 300.0, \"gamma\": 2.0, \"eta\": 20.0,\n            \"climate\": {\"p\": [1.0], \"k\": [0.7]},\n            \"crops\": [\n                {\"y\": 3.0, \"C\": 200.0, \"rho\": 0.0},\n                {\"y\": 3.4, \"C\": 180.0, \"rho\": 0.5},\n                {\"y\": 2.8, \"C\": 150.0, \"rho\": 0.9}\n            ]\n        },\n        # Test case D: tie case by construction\n        {\n            \"P\": 100.0, \"gamma\": 0.8, \"eta\": 10.0,\n            \"climate\": {\"p\": [0.5, 0.5], \"k\": [0.0, 0.2]},\n            \"crops\": [\n                {\"y\": 2.0, \"C\": 50.0, \"rho\": 0.3},\n                {\"y\": 2.0, \"C\": 50.0, \"rho\": 0.3},\n                {\"y\": 1.8, \"C\": 60.0, \"rho\": 0.1}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_optimal_crop(\n            case[\"P\"], case[\"gamma\"], case[\"eta\"], case[\"climate\"], case[\"crops\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "在掌握了针对特定场景求解预期效用的方法后，我们来挑战一个更具普适性的任务：构建一个通用的确定性等价计算器。对于许多复杂的效用函数，我们无法轻易得到其解析反函数，因此数值方法成为不可或缺的工具。这个练习要求你编写一个程序，它能为任意给定的效用函数和离散概率分布，通过数值根查找算法精确地计算出确定性等价，这将极大提升你作为计算经济学家的核心技能 [@problem_id:2391058]。", "id": "2391058", "problem": "您的任务是编写一个完整、可运行的程序，用于根据期望效用理论计算离散财富博弈的确定性等价。该程序必须定义一个函数，该函数接受一个代表效用函数的任意 Python 可调用对象以及一个关于财富结果的离散概率分布，并返回确定性等价。\n\n其科学基础是期望效用公理和确定性等价的定义：\n- 设随机财富 $W$ 取离散值 $\\{w_i\\}_{i=1}^n$，其相应概率为 $\\{p_i\\}_{i=1}^n$，其中 $p_i \\ge 0$ 且 $\\sum_{i=1}^n p_i = 1$。\n- 设 $u(\\cdot)$ 为一个严格递增的连续效用函数。\n- 期望效用为 $E[u(W)] = \\sum_{i=1}^n p_i \\, u(w_i)$。\n- 确定性等价 $\\mathrm{CE}$ 定义为满足 $u(\\mathrm{CE}) = E[u(W)]$ 的唯一实数。\n\n编程要求：\n- 实现一个函数，其输入为：\n  - 一个 Python 函数句柄 $u(w)$，可实现为接受标量 $w$ 并返回标量 $u(w)$ 的可调用对象。\n  - 一个包含实数的财富值列表或 NumPy 数组 $W = [w_1, \\dots, w_n]$。\n  - 一个包含非负实数的权重列表或 NumPy 数组 $p = [p_1, \\dots, p_n]$。\n- 验证与归一化：\n  - 验证 $p$ 的所有元素均为非负，且至少有一个元素为严格正数。\n  - 如果 $\\sum_i p_i \\neq 1$，则对该向量进行归一化，使其和为 $1$。\n  - 验证 $W$ 和 $p$ 具有相同的长度 $n$。\n- 计算：\n  - 计算 $E[u(W)] = \\sum_{i=1}^n p_i \\, u(w_i)$。\n  - 在 $u(\\cdot)$ 是严格递增且连续的既定假设下，使用鲁棒的、在区间 $[ \\min_i w_i, \\max_i w_i ]$ 上的有界根查找方法，以 $10^{-9}$ 的绝对容差求解 $u(c) - E[u(W)] = 0$ 的唯一解 $\\mathrm{CE}$。如果 $u(\\min_i w_i) = E[u(W)]$ 或 $u(\\max_i w_i) = E[u(W)]$，则返回相应的边界值作为确定性等价。\n- 数值单位：无需报告物理单位。所有输出应为实数。\n- 输出格式：您的程序应生成单行输出，其中包含以下测试套件的确定性等价，格式为用方括号括起来的逗号分隔列表，每个数字四舍五入到 $6$ 位小数。\n\n测试套件（每项定义了 $u(\\cdot)$、$W$ 和 $p$）。请确保所有数字都严格按照所写方式处理：\n- 测试 $1$ (风险中性): $u(w) = w$, $W = [0.0, 100.0]$, $p = [0.5, 0.5]$。\n- 测试 $2$ (恒定相对风险规避，参数 $\\gamma = 2$): 当 $w > 0$ 时，$u(w) = \\dfrac{w^{1-\\gamma}}{1-\\gamma}$，当 $\\gamma = 2$ 时，该式等于 $-\\dfrac{1}{w}$。使用 $W = [50.0, 150.0]$，$p = [0.3, 0.7]$。\n- 测试 $3$ (恒定绝对风险规避，参数 $a = 0.05$): 对于所有实数 $w$，$u(w) = -\\exp(-a w)$。使用 $W = [-50.0, 50.0]$，$p = [0.5, 0.5]$。\n- 测试 $4$ (退化分布，对数效用): 当 $w > 0$ 时，$u(w) = \\ln(w)$。使用 $W = [80.0]$，$p = [1.0]$。\n- 测试 $5$ (平方根效用，使用未归一化的权重): 当 $w \\ge 0$ 时，$u(w) = \\sqrt{w}$。使用 $W = [25.0, 100.0, 400.0]$，$p = [1.0, 1.0, 2.0]$。\n\n最终输出规范：\n- 程序应按所列顺序计算五个测试中的每一个的确定性等价，并以 Python 风格的列表形式在单行上输出它们：\n  - 将每个确定性等价四舍五入到 $6$ 位小数。\n  - 确切的所需格式为单行：\n  - 格式示例：$\\texttt{[x\\_1,x\\_2,x\\_3,x\\_4,x\\_5]}$，其中 $x_i$ 是四舍五入后的数字，不含额外文本。", "solution": "问题陈述已经过严格验证。\n\n**第一步：提取已知条件**\n- **主题**：期望效用理论，确定性等价。\n- **定义**：\n  - 离散随机财富变量 $W$ 取值为 $\\{w_i\\}_{i=1}^n$，其概率为 $\\{p_i\\}_{i=1}^n$。\n  - 约束条件：$p_i \\ge 0$ 且 $\\sum_{i=1}^n p_i = 1$。\n  - 效用函数 $u(\\cdot)$ 是严格递增且连续的。\n  - 期望效用：$E[u(W)] = \\sum_{i=1}^n p_i \\, u(w_i)$。\n  - 确定性等价 ($\\mathrm{CE}$): 满足 $u(\\mathrm{CE}) = E[u(W)]$ 的值。\n- **编程要求**：\n  - 函数必须接受一个可调用的效用函数 $u$、一个财富列表/数组 $W$ 和一个权重列表/数组 $p$。\n  - **验证**：\n    - 所有 $p_i$ 必须为非负数。\n    - 至少一个 $p_i$ 必须为严格正数。\n    - 如果向量 $p$ 的和不为 $1$，则必须对其进行归一化。\n    - $W$ 和 $p$ 必须具有相同的长度。\n  - **计算**：\n    - 通过求解 $u(c) - E[u(W)] = 0$ 来找到 $\\mathrm{CE}$。\n    - 在区间 $[\\min_i w_i, \\max_i w_i]$ 上使用有界根查找方法。\n    - 使用 $10^{-9}$ 的绝对容差。\n    - 处理 $\\mathrm{CE}$ 位于区间边界的情况。\n- **测试套件**：\n  - **测试 $1$**：$u(w) = w$，$W = [0.0, 100.0]$，$p = [0.5, 0.5]$。\n  - **测试 $2$**：$u(w) = \\frac{w^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma = 2$ (因此 $u(w) = -w^{-1}$)，$W = [50.0, 150.0]$，$p = [0.3, 0.7]$。\n  - **测试 $3$**：$u(w) = -\\exp(-a w)$，其中 $a = 0.05$，$W = [-50.0, 50.0]$，$p = [0.5, 0.5]$。\n  - **测试 $4$**：$u(w) = \\ln(w)$，$W = [80.0]$，$p = [1.0]$。\n  - **测试 $5$**：$u(w) = \\sqrt{w}$，$W = [25.0, 100.0, 400.0]$，$p = [1.0, 1.0, 2.0]$。\n- **输出格式**：单行，用方括号括起来的逗号分隔列表，每个值四舍五入到 $6$ 位小数。\n\n**第二步：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估：\n- **科学依据**：该问题基于 von Neumann-Morgenstern 期望效用理论，这是经济学、金融学和决策理论中的一个基本概念。所提供的定义和效用函数均为标准形式。\n- **适定性**：该问题是适定的。效用函数 $u(\\cdot)$ 严格递增且连续的先验假设保证了唯一确定性等价 $\\mathrm{CE}$ 的存在。设待求解的函数为 $f(c) = u(c) - E[u(W)]$。期望效用 $E[u(W)]$ 是值 $\\{u(w_i)\\}$ 的凸组合。鉴于 $u$ 是严格递增的，对于所有 $i$，我们有 $u(\\min(W)) \\le u(w_i) \\le u(\\max(W))$。因此，$u(\\min(W)) \\le E[u(W)] \\le u(\\max(W))$。这意味着 $f(\\min(W)) \\le 0$ 且 $f(\\max(W)) \\ge 0$。根据介值定理，区间 $[\\min(W), \\max(W)]$ 内必定存在一个根。$u(\\cdot)$ 的严格单调性确保了该根是唯一的。\n- **客观性**：该问题使用精确、客观的数学和计算语言进行陈述。\n- **缺陷**：未发现与科学谬误、不完整性、矛盾或歧义相关的缺陷。该问题是计算经济学中的一个标准、可形式化的练习。\n\n**第三步：结论与行动**\n该问题是**有效的**。将构建一个解决方案。\n\n**基于原则的设计**\n\n任务是为给定的财富结果离散博弈找到确定性等价 $\\mathrm{CE}$。博弈由一组可能的财富结果 $W = \\{w_1, w_2, \\dots, w_n\\}$ 及其相应的概率 $P_s = \\{p_1, p_2, \\dots, p_n\\}$ 定义。问题陈述允许使用未归一化的权重，我们首先将其归一化为一个有效的概率分布 $\\tilde{P} = \\{\\tilde{p}_1, \\tilde{p}_2, \\dots, \\tilde{p}_n\\}$，其中 $\\tilde{p}_i = p_i / \\sum_{j=1}^n p_j$。\n\n问题的核心在于期望效用理论。对于给定的效用函数 $u(w)$（它量化了个体对某一财富水平 $w$ 的偏好），博弈的期望效用是每个可能结果效用的加权平均值：\n$$\nE[u(W)] = \\sum_{i=1}^n \\tilde{p}_i u(w_i)\n$$\n确定性等价 $\\mathrm{CE}$ 是指能提供与博弈期望效用相同效用水平的确定性财富量。它由以下方程形式化定义：\n$$\nu(\\mathrm{CE}) = E[u(W)]\n$$\n如果逆效用函数 $u^{-1}(\\cdot)$ 已知且易于计算，则可以直接求得 $\\mathrm{CE}$：\n$$\n\\mathrm{CE} = u^{-1}(E[u(W)])\n$$\n然而，对于许多效用函数，其逆函数要么没有封闭解析形式，要么计算上不方便。问题强制要求使用更通用的数值方法：求根。我们定义一个函数 $g(c)$，其根即为所需的确定性等价：\n$$\ng(c) = u(c) - E[u(W)] = 0\n$$\n问题规定 $u(\\cdot)$ 是严格递增且连续的。这保证了 $g(c)$ 也是严格递增且连续的。如验证阶段所确认，在由最小和最大可能财富结果定义的闭区间 $[\\min(W), \\max(W)]$ 内，保证存在一个唯一的根满足 $g(c)=0$。\n\n这种结构使得问题适合使用有界根查找算法，例如 Brent's method，该方法既鲁棒又高效。算法将系统地缩小搜索区间 $[a, b]$（其中 $g(a)$ 和 $g(b)$ 符号相反），直到在指定的容差内找到根。\n\n因此，计算流程如下：\n1.  **输入验证与归一化**：给定输入 $u$、$W$ 和 $p$，首先确保它们是有效的。将 $W$ 和 $p$ 转换为数值数组。检查长度是否一致。确认 $p$ 中的概率是非负的，且其和为正值。然后，对 $p$ 进行归一化以创建一个真实的概率向量 $\\tilde{p}$。\n2.  **处理退化情况**：如果博弈只有一个可能的结果（即 $\\min(W) = \\max(W)$），那么它不是一个博弈，而是一个确定的结果。确定性等价就是这个值。\n3.  **计算期望效用**：计算 $E[u(W)] = \\sum_i \\tilde{p}_i u(w_i)$。这是一个简单的点积运算。\n4.  **数值求解**：a. 定义搜索区间为 $[\\min(W), \\max(W)]$。 b. 定义目标函数 $g(c) = u(c) - E[u(W)]$。 c. 处理平凡边界解：如果在一个很小的机器精度范围内 $g(\\min(W)) \\approx 0$ 或 $g(\\max(W)) \\approx 0$，则相应的边界即为解。 d. 使用数值求解器，例如 `scipy.optimize.brentq`，在区间内找到 $g(c)$ 的根，并达到 $10^{-9}$ 的所需绝对容差。\n\n这种结构化的方法保证了一个正确且鲁棒的实现，它遵循了期望效用理论和数值分析的既定原则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute their certainty equivalents.\n    \"\"\"\n\n    def calculate_certainty_equivalent(u, W, p):\n        \"\"\"\n        Computes the certainty equivalent for a discrete wealth lottery.\n\n        Args:\n            u (callable): A strictly increasing and continuous utility function.\n            W (list or np.ndarray): A list of wealth outcomes.\n            p (list or np.ndarray): A list of corresponding non-negative weights.\n\n        Returns:\n            float: The certainty equivalent.\n        \"\"\"\n        # 1. Input Validation and Normalization\n        try:\n            W_arr = np.asarray(W, dtype=float)\n            p_arr = np.asarray(p, dtype=float)\n        except Exception as e:\n            raise TypeError(f\"Inputs W and p must be convertible to numeric arrays. Error: {e}\")\n\n        if W_arr.ndim != 1 or p_arr.ndim != 1:\n            raise ValueError(\"Inputs W and p must be 1-dimensional arrays.\")\n        \n        if len(W_arr) != len(p_arr):\n            raise ValueError(\"Wealth outcomes (W) and weights (p) must have the same length.\")\n\n        if np.any(p_arr < 0):\n            raise ValueError(\"All probability weights in p must be non-negative.\")\n\n        p_sum = np.sum(p_arr)\n        if p_sum <= 0:\n            raise ValueError(\"The sum of probability weights must be strictly positive.\")\n\n        # Normalize probabilities\n        p_norm = p_arr / p_sum\n\n        # 2. Handle Degenerate Case\n        w_min, w_max = np.min(W_arr), np.max(W_arr)\n        if np.isclose(w_min, w_max):\n            return w_min\n\n        # 3. Compute Expected Utility\n        u_values = np.array([u(w) for w in W_arr])\n        expected_utility = np.dot(p_norm, u_values)\n\n        # 4. Numerical Solution\n        # Define the objective function for the root-finder\n        def g(c):\n            return u(c) - expected_utility\n\n        # The root is guaranteed to be in [w_min, w_max] because u is monotonic.\n        # Check boundary solutions as per problem spec\n        if np.isclose(g(w_min), 0.0):\n            return w_min\n        if np.isclose(g(w_max), 0.0):\n            return w_max\n        \n        # Use Brent's method for robust root-finding\n        try:\n            # xtol is the absolute tolerance on the root\n            ce = brentq(g, w_min, w_max, xtol=1e-9)\n        except ValueError:\n            # This should not happen if u is strictly increasing\n            raise RuntimeError(\n                \"Root-finding failed. The bracket [min(W), max(W)] might be invalid, \"\n                \"which implies the utility function is not strictly increasing.\"\n            )\n\n        return ce\n\n    # Define utility functions for the test suite\n    u1 = lambda w: w\n    \n    gamma = 2.0\n    u2 = lambda w: (w**(1.0 - gamma)) / (1.0 - gamma) if w > 0 else -np.inf\n\n    a = 0.05\n    u3 = lambda w: -np.exp(-a * w)\n    \n    u4 = lambda w: np.log(w) if w > 0 else -np.inf\n    \n    u5 = lambda w: np.sqrt(w) if w >= 0 else -np.inf\n\n    # Test suite from the problem description\n    test_cases = [\n        (u1, [0.0, 100.0], [0.5, 0.5]),\n        (u2, [50.0, 150.0], [0.3, 0.7]),\n        (u3, [-50.0, 50.0], [0.5, 0.5]),\n        (u4, [80.0], [1.0]),\n        (u5, [25.0, 100.0, 400.0], [1.0, 1.0, 2.0]),\n    ]\n\n    results = []\n    for u_func, W, p in test_cases:\n        ce = calculate_certainty_equivalent(u_func, W, p)\n        results.append(f\"{ce:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}