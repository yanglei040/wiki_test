{"hands_on_practices": [{"introduction": "1231243我们经常使用标准的年金公式来计算未来现金流的现值，该公式假设利率在整个周期内是恒定的。然而，在现实世界中，利率会随时间波动。这个练习旨在挑战你超越固定的公式，将贴现的第一性原理应用到利率结构随时间变动的动态场景中[@problem_id:2444469]。通过解决这个问题，你将学会如何处理可变利率，这是从基础估值理论迈向更高级金融建模的重要一步。", "id": "2444469", "problem": "一个项目在 $n$ 年内每年年末支付一笔固定的现金流 $A$ 美元，其中 $A = 12{,}000$ 且 $n = 6$。经济具有一个确定的期限结构，由适用于从第 $k-1$ 年到第 $k$ 年期间的一年期实际利率 $r_k$ 描述，其中 $k \\in \\{1,2,3,4,5,6\\}$。假设采用与这些特定时期实际利率相一致的离散复利，并且现金流在每个时期末收到。利率如下：\n- $r_1 = 0.030$\n- $r_2 = 0.033$\n- $r_3 = 0.036$\n- $r_4 = 0.038$\n- $r_5 = 0.041$\n- $r_6 = 0.043$\n\n计算此年金在时间点 $0$ 的现值。将您的答案四舍五入到四位有效数字。以美元表示最终结果。", "solution": "首先对问题陈述进行验证。\n\n按陈述提取给定条件：\n- 固定的年度现金流，$A = 12000$ 美元。\n- 支付次数，$n = 6$ 年。\n- 现金流时间：$n$ 年内每年年末。\n- 利率的期限结构由适用于从第 $k-1$ 年到第 $k$ 年期间的一年期实际利率 $r_k$ 给出。\n- $r_1 = 0.030$\n- $r_2 = 0.033$\n- $r_3 = 0.036$\n- $r_4 = 0.038$\n- $r_5 = 0.041$\n- $r_6 = 0.043$\n- 复利是离散的。\n- 目标是计算在时间 $t=0$ 的现值 $PV$。\n- 最终答案必须四舍五入到四位有效数字，并以美元表示。\n\n该问题被确定为有效。它在科学上基于金融数学的原理，特别是货币的时间价值。这是一个适定问题，为唯一解提供了所有必要的数据，其术语客观明确。没有矛盾、缺失数据或违反科学原理的地方。我们着手求解。\n\n一系列现金流的现值 ($PV$) 是每笔单独现金流贴现值的总和。在未来某个时间收到的现金流，使用相应期间的通行利率贴现到其在时间 $t=0$ 的价值。\n\n在本题中，在每年年末 $k$ 收到一笔固定现金流 $A$，其中 $k \\in \\{1, 2, 3, 4, 5, 6\\}$。贴现率不是恒定的；它遵循一个特定的期限结构。一年期实际利率 $r_j$ 适用于从第 $j-1$ 年到第 $j$ 年的区间。\n\n为了求出在第 $k$ 年末收到的一笔现金流 $A$ 的现值，我们必须使用相应的一年期利率将其逐年贴现回来。第 $k$ 年现金流的贴现因子是各个一年期贴现因子的乘积。\n\n第 $k=1$ 年现金流的现值为：\n$$ PV_1 = \\frac{A}{1+r_1} $$\n第 $k=2$ 年现金流的现值为：\n$$ PV_2 = \\frac{A}{(1+r_1)(1+r_2)} $$\n推广开来，第 $k$ 年现金流的现值由下式给出：\n$$ PV_k = \\frac{A}{\\prod_{j=1}^{k} (1+r_j)} $$\n该年金的总现值是所有 $n$ 笔现金流现值的总和：\n$$ PV = \\sum_{k=1}^{n} PV_k = \\sum_{k=1}^{n} \\frac{A}{\\prod_{j=1}^{k} (1+r_j)} $$\n给定 $A=12000$ 和 $n=6$，我们可以写出完整的表达式：\n$$ PV = A \\left( \\frac{1}{1+r_1} + \\frac{1}{(1+r_1)(1+r_2)} + \\dots + \\frac{1}{\\prod_{j=1}^{6} (1+r_j)} \\right) $$\n让我们定义累积贴现项 $D_k = \\prod_{j=1}^{k} (1+r_j)$。公式变为：\n$$ PV = A \\sum_{k=1}^{6} \\frac{1}{D_k} $$\n我们现在代入给定的利率来计算每个 $D_k$：\n- $r_1=0.030 \\implies D_1 = 1+0.030 = 1.030$\n- $r_2=0.033 \\implies D_2 = D_1 \\times (1+0.033) = 1.030 \\times 1.033 = 1.06399$\n- $r_3=0.036 \\implies D_3 = D_2 \\times (1+0.036) = 1.06399 \\times 1.036 = 1.10230564$\n- $r_4=0.038 \\implies D_4 = D_3 \\times (1+0.038) = 1.10230564 \\times 1.038 = 1.14419325432$\n- $r_5=0.041 \\implies D_5 = D_4 \\times (1+0.041) = 1.14419325432 \\times 1.041 = 1.19110517774712$\n- $r_6=0.043 \\implies D_6 = D_5 \\times (1+0.043) = 1.19110517774712 \\times 1.043 = 1.2423227003902556$\n\n现在我们计算贴现因子之和，$\\sum_{k=1}^{6} \\frac{1}{D_k}$：\n$$ \\sum_{k=1}^{6} \\frac{1}{D_k} = \\frac{1}{1.030} + \\frac{1}{1.06399} + \\frac{1}{1.10230564} + \\frac{1}{1.14419325432} + \\frac{1}{1.19110517774712} + \\frac{1}{1.2423227003902556} $$\n$$ \\approx 0.97087379 + 0.93985846 + 0.90718532 + 0.87397753 + 0.83953959 + 0.80494899 $$\n将这些值相加得到：\n$$ \\sum_{k=1}^{6} \\frac{1}{D_k} \\approx 5.33638366 $$\n现在，我们计算总现值：\n$$ PV = 12000 \\times 5.33638366 \\approx 64036.60396 $$\n题目要求将答案四舍五入到四位有效数字。$64036.60396$ 的前四位有效数字是 $6$、$4$、$0$ 和 $3$。第五位数字是 $6$，大于或等于 $5$，所以我们对第四位有效数字进行进位。值 $3$ 变成 $4$。\n$$ PV \\approx 64040 $$\n用标准科学记数法表示，这是 $6.404 \\times 10^4$。结果以美元为单位。", "answer": "$$ \\boxed{6.404 \\times 10^4} $$"}, {"introduction": "金融领域中一些最重要的问题，例如计算债券的到期收益率（$YTM$），并没有简单的封闭解。本练习将理论与实践相结合，要求你实现一种数值求根算法来解决这个问题[@problem_id:2377925]。这是一个经典的例子，展示了计算方法在解决真实金融问题中的必要性，也是将金融概念转化为可执行代码的绝佳实践。", "id": "2377925", "problem": "您将实现一个区间求根算法，用以计算附息债券和零息债券的到期收益率（YTM）。YTM是指一个名义年利率（按每年特定频率复利），它使得所有未来现金流的现值等于当前市场价格。此任务必须被构建为一个关于单个未知数的标量求根问题，使用区间法求解一个连续函数，并从第一性原理出发进行论证。\n\n基础原理：\n- 货币时间价值：未来现金流的现值等于其金额乘以一个适当的折现因子，该折现因子由名义年收益率、复利频率和所经过的时间推导得出。\n- 连续性与单调性：对于一系列以名义年收益率（每年固定次数复利）折现的严格为正的现金流，其现值是关于该收益率的一个连续且严格递减的函数。\n- 介值定理 (IVT)：如果一个定义在闭区间上的连续函数在两个端点处的函数值符号相反，那么它在该区间内至少有一个根。\n\n将标量函数定义如下。设名义年收益率为未知数 $y$。设复利频率为每年 $m$ 次支付，其中 $m \\in \\mathbb{N}$，并假设 $m T \\in \\mathbb{N}$，因此总期数为整数。对于一个票面价值为 $F$、年票面利率为 $c$（以年化小数表示）、到期时间为 $T$ 年、当前市场价格为 $P$ 的债券，将 $f(y)$ 定义为所有未来息票支付和赎回金额的现值（使用名义年收益率 $y$ 和复利频率 $m$ 进行折现）与观测价格 $P$ 之间的差额。到期收益率是满足 $f(y) = 0$ 且符合金融可行性条件 $1 + y/m > 0$ 的任何 $y$。\n\n您的程序必须：\n- 实现一种求根的区间法（例如，二分法或试位法），该方法仅使用函数求值和区间端点，并保证对存在符号变化的连续函数收敛，而不依赖导数信息。您必须使用一个固定的初始区间 $[y_{\\min}, y_{\\max}] = [-0.99, 3.0]$，并对每个测试用例验证 $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$。如果初始区间未能跨越一个根，您必须在保持可行性条件 $1 + y/m > 0$ 的同时保守地扩展区间，直到找到符号变化或达到合理的扩展限制。\n- 对于每支债券，通过使用名义年收益率 $y$ 和每年 $m$ 次复利所隐含的每期利率对每笔现金流进行折现，并对所有现金流在其各自的期数索引上求和，来计算现值。每期折现因子必须强制执行金融可行性条件 $1 + y/m > 0$。\n- 使用一个停止准则，确保区间法的绝对宽度小于或等于指定的容差 $\\varepsilon$，或者中点处的函数绝对值小于或等于指定的容差 $\\delta$。使用 $\\varepsilon = 10^{-12}$ 和 $\\delta = 10^{-12}$，并且每次求根最多进行 $10{,}000$ 次迭代。\n- 结果以年化小数为单位（不带百分号）。不涉及角度。货币价值采用任意一致的单位；无需货币符号。\n\n测试套件：\n对于每个案例，参数按上述约定以 $(F, c, m, T, P)$ 的形式给出。假设 $m T \\in \\mathbb{N}$。\n\n- 案例 $1$（一般附息债券，折价发行）：$(F=\\$1000, c=0.05, m=2, T=5, P=\\$950)$。\n- 案例 $2$（零息债券，正收益率）：$(F=\\$1000, c=0.0, m=1, T=3, P=\\$850)$。\n- 案例 $3$（平价债券，一致性检验）：$(F=\\$1000, c=0.04, m=2, T=7, P=\\$1000)$。\n- 案例 $4$（零息债券，负收益率）：$(F=\\$1000, c=0.0, m=1, T=1, P=\\$1005)$。\n\n答案规范：\n- 对于每个测试用例，将YTM输出为一个年化小数形式的浮点数，并精确到 $10$ 位小数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，并按案例$1$至$4$的顺序排列。例如，输出格式必须与 $[y_1,y_2,y_3,y_4]$ 完全一样，其中每个 $y_k$ 都四舍五入到 $10$ 位小数。", "solution": "问题陈述已经过严格验证。所有给定信息均已提取，并根据科学合理性、完整性和客观性标准进行了核查。该问题是良定的，植根于成熟的金融数学，不含任何歧义、矛盾或事实错误。为测试用例提供的参数在物理上和金融上都是合理的。因此，该问题被视为有效，并将提供解决方案。\n\n中心任务是确定一组债券的到期收益率（YTM），用 $y$ 表示。YTM是使债券未来现金流的现值等于其当前市场价格的名义年利率。这是一个关于收益率 $y$ 的标量函数的求根问题。\n\n首先，我们必须从第一性原理构建这个函数。设一支债券的票面价值为 $F$，年票面利率为 $c$，到期时间为 $T$ 年，息票复利频率为每年 $m$ 次。问题规定总期数 $N = mT$ 是一个整数。\n\n债券的总现金流包括两个部分：定期支付的息票和票面价值的最终赎回。\n年息票总额为 $cF$。由于每年支付 $m$ 次，每次息票支付额为 $C = \\frac{cF}{m}$。这些支付发生在每个期末，总共有 $N = mT$ 期。\n在最后一期 $N$ 的期末，票面价值 $F$ 也被返还。\n因此，在第 $k \\in \\{1, 2, \\dots, N-1\\}$ 期末的现金流为 $C_k = C$，而在最后一期 $N$ 的现金流为 $C_N = C + F$。\n\n货币时间价值原理指出，未来的现金流必须经过折现才能得到其现值。设 $y$ 为名义年收益率。每期收益率为 $r = \\frac{y}{m}$。第 $k$ 期现金流的折现因子是 $(1+r)^{-k} = (1 + y/m)^{-k}$。金融可行性的一个关键条件是折现率必须有明确定义，这要求 $1 + y/m > 0$。\n\n所有未来现金流的总现值 $\\text{PV}(y)$ 是每笔现金流折现值的总和：\n$$ \\text{PV}(y) = \\sum_{k=1}^{N} \\frac{C_k}{(1 + y/m)^k} $$\n代入附息债券（$c>0$）的具体现金流：\n$$ \\text{PV}(y) = \\left( \\sum_{k=1}^{N} \\frac{C}{(1+y/m)^k} \\right) + \\frac{F}{(1+y/m)^N} $$\n其中 $C = \\frac{cF}{m}$ 且 $N=mT$。对于零息债券（$c=0$），息票支付为零，公式简化为单笔一次性总付的现值：\n$$ \\text{PV}(y) = \\frac{F}{(1+y/m)^N} $$\n问题将待解函数 $f(y)$ 定义为现金流现值与市场价格 $P$ 之间的差额：\n$$ f(y) = \\text{PV}(y) - P = 0 $$\n对于任何正现金流集合，函数 $\\text{PV}(y)$ 在其可行域 $y > -m$ 上是关于 $y$ 的一个连续且严格递减的函数。因此，$f(y)$ 也是一个连续且严格递减的函数。这种单调性保证了如果根存在，它就是唯一的。\n\n区间内根的存在性由介值定理（IVT）保证，该定理指出，对于一个闭区间 $[a, b]$ 上的连续函数，如果 $f(a)$ 和 $f(b)$ 符号相反，则必定存在至少一个值 $y^* \\in (a, b)$ 使得 $f(y^*) = 0$。这是区间求根方法的理论基础。\n\n我们将实现二分法，这是一种鲁棒且简单的区间算法，不需要导数信息。其收敛性得到保证，尽管收敛速度是线性的，但这对于所要求的精度是可以接受的。\n\n该算法流程如下：\n$1$. 初始化搜索区间。问题指定了初始区间 $[a, b] = [y_{\\min}, y_{\\max}] = [-0.99, 3.0]$。我们必须验证该区间是否有效，即 $f(a) \\cdot f(b) \\le 0$。鉴于 $f(y)$ 是单调递减的，我们期望 $f(a) > 0$ 且 $f(b) < 0$。如果此条件不成立，则必须扩展该区间。由于当 $y \\to -m^+$ 时 $f(y) \\to \\infty$，而当 $y \\to \\infty$ 时 $f(y) \\to -P < 0$，因此保证存在满足介值定理条件的区间。扩展逻辑将在 $f(b)>0$ 时增加 $b$，在 $f(a)<0$ 时减小 $a$（朝 $-m$ 的方向）。对于指定的测试用例，初始区间 $[-0.99, 3.0]$ 是充分的，无需扩展。\n\n$2$. 迭代直至满足停止准则。在每次迭代中：\n   a. 计算当前区间的中点：$y_{\\text{mid}} = a + \\frac{b-a}{2}$。这种计算方式比 $(a+b)/2$ 更佳，可以避免处理大数值时潜在的浮点溢出。\n   b. 计算中点处的函数值 $f(y_{\\text{mid}})$。\n   c. 检查停止准则。如果区间宽度足够小，即 $|b-a| \\le \\varepsilon = 10^{-12}$，或者中点处的函数值接近于零，即 $|f(y_{\\text{mid}})| \\le \\delta = 10^{-12}$，则过程终止。同时，强制执行最大迭代次数（$10,000$次）以防止无限循环。\n   d. 更新区间。根据 $f(y_{\\text{mid}})$ 的符号，舍弃保证不包含根的那一半区间。如果 $f(y_{\\text{mid}})$ 与 $f(a)$ 的符号相同，则新区间变为 $[y_{\\text{mid}}, b]$。否则，新区间变为 $[a, y_{\\text{mid}}]$。正如我们所确立的，$f(a)>0$ 是预期情况，因此如果 $f(y_{\\text{mid}})>0$，根就位于 $[y_{\\text{mid}},b]$ 中，我们便设置 $a = y_{\\text{mid}}$。如果 $f(y_{\\text{mid}})<0$，根就位于 $[a, y_{\\text{mid}}]$ 中，我们便设置 $b = y_{\\text{mid}}$。\n\n$3$. 最终结果是最后计算区间的中点，它以有保证的误差界逼近根 $y^*$。\n\n该方法将应用于每个测试用例，以计算相应的YTM。计算使用浮点运算执行，最终结果按要求四舍五入到 $10$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as per problem specification\nTOLERANCE_EPSILON = 1e-12\nTOLERANCE_DELTA = 1e-12\nMAX_ITERATIONS = 10000\nINITIAL_BRACKET = [-0.99, 3.0]\n\ndef calculate_f_y(y, F, c, m, T, P):\n    \"\"\"\n    Calculates the value of the price-yield function f(y) = PV(y) - P.\n    \n    Args:\n        y (float): The nominal annual yield (YTM).\n        F (float): Face value of the bond.\n        c (float): Annual coupon rate (decimal).\n        m (int): Compounding frequency per year.\n        T (int): Maturity in years.\n        P (float): Current market price.\n\n    Returns:\n        float: The value of f(y).\n    \"\"\"\n    # Financial feasibility condition: 1 + y/m > 0\n    if 1.0 + y / m <= 0:\n        return float('inf')  # Return a large positive value for infeasible yields\n\n    num_periods = int(m * T)\n    coupon_per_period = c * F / m\n\n    present_value = 0.0\n    \n    # The term (1 + y/m) is used repeatedly\n    discount_base = 1.0 + y / m\n    \n    # Calculate present value of coupon payments using direct summation\n    if c > 0:\n        for k in range(1, num_periods + 1):\n            present_value += coupon_per_period / (discount_base ** k)\n\n    # Add present value of face value redemption\n    present_value += F / (discount_base ** num_periods)\n    \n    return present_value - P\n\ndef find_ytm(params):\n    \"\"\"\n    Computes the Yield-to-Maturity (YTM) for a bond using the bisection method.\n\n    Args:\n        params (tuple): A tuple containing bond parameters (F, c, m, T, P).\n\n    Returns:\n        float: The calculated YTM.\n    \"\"\"\n    F, c, m, T, P = params\n    \n    a, b = INITIAL_BRACKET[0], INITIAL_BRACKET[1]\n    \n    fa = calculate_f_y(a, F, c, m, T, P)\n    fb = calculate_f_y(b, F, c, m, T, P)\n    \n    # Bracket expansion logic as required by the problem statement.\n    # Note: For the given test cases, the initial bracket is sufficient.\n    # This logic is included for robustness as per the directive.\n    expansion_limit = 20\n    expand_iter = 0\n    while fa * fb > 0 and expand_iter < expansion_limit:\n        # f(y) is monotonically decreasing.\n        # If both are positive, root is to the right of b.\n        if fa > 0 and fb > 0:\n            b *= 2.0\n        # If both are negative, root is to the left of a.\n        elif fa < 0 and fb < 0:\n            # Conservatively move 'a' towards the theoretical limit -m\n            a = (a - m) / 2.0\n            if a <= -m: # Ensure feasibility\n                a = -m + 1e-9\n        else: # One or both are zero, which is a root\n            return a if fa == 0 else b\n\n        fa = calculate_f_y(a, F, c, m, T, P)\n        fb = calculate_f_y(b, F, c, m, T, P)\n        expand_iter += 1\n\n    if fa * fb > 0:\n        raise ValueError(f\"Failed to find a bracketing interval for params: {params}\")\n\n    # Ensure fa is positive and fb is negative to simplify bisection logic\n    if fa < 0:\n        a, b = b, a\n        fa, fb = fb, fa\n\n    # Bisection method implementation\n    for _ in range(MAX_ITERATIONS):\n        mid = a + (b - a) / 2.0\n        f_mid = calculate_f_y(mid, F, c, m, T, P)\n        \n        # Check stopping criteria\n        if (b - a) <= TOLERANCE_EPSILON or abs(f_mid) <= TOLERANCE_DELTA:\n            return mid\n        \n        # Update bracket\n        if f_mid > 0:  # Root is in the right half [mid, b]\n            a = mid\n            fa = f_mid\n        else:  # Root is in the left half [a, mid]\n            b = mid\n            fb = f_mid\n            \n    # If max iterations is reached, return the best estimate.\n    return a + (b - a) / 2.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite: (F, c, m, T, P)\n    test_cases = [\n        (1000.0, 0.05, 2, 5.0, 950.0),    # Case 1: General coupon bond, discount\n        (1000.0, 0.0, 1, 3.0, 850.0),    # Case 2: Zero-coupon, positive yield\n        (1000.0, 0.04, 2, 7.0, 1000.0),   # Case 3: Par bond, consistency check\n        (1000.0, 0.0, 1, 1.0, 1005.0)     # Case 4: Zero-coupon, negative yield\n    ]\n\n    results = []\n    for case in test_cases:\n        ytm = find_ytm(case)\n        # Format to 10 decimal places as required\n        results.append(f\"{ytm:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```"}, {"introduction": "即使我们拥有一个正确的数学公式，计算机在进行有限精度运算时也可能产生不准确的结果。本练习探讨了标准年金公式在利率 $r$ 趋近于零时的数值不稳定性问题[@problem_id:2444517]。通过实现并比较泰勒级数近似等方法，你将学习如何构建一个在各种条件下都表现稳健的函数，这对于任何有志于成为计算金融专业人士的人来说都是一项至关重要的技能。", "id": "2444517", "problem": "给定在离散复利下的定额年金现值，它由以下函数定义，其中 $Pmt$ 为每期支付额，$r$ 为每期实际利率（以小数表示），$n \\in \\mathbb{N}$ 为整数期支付次数：\n$$\nPV(Pmt,r,n) \\;=\\; Pmt \\times \\begin{cases}\n\\dfrac{1 - (1+r)^{-n}}{r}, & r \\neq 0,\\\n$$6pt]\nn, & r = 0.\n\\end{cases}\n$$\n该函数可通过极限连续扩展至 $r=0$ 的情况，其极限值等于 $Pmt \\times n$。当在有限精度下进行算术运算时，请考虑在 $r \\to 0$ 时计算 $PV(Pmt,r,n)$ 的数值稳定性。\n\n您的任务是实现 $PV(Pmt,r,n)$ 的两种数值近似方法，并将它们与 $PV(Pmt,r,n)$ 的数学精确值（在实数算术中，$r=0$ 的情况通过极限解释）进行比较。这两种近似方法是：\n\n- 当 $r \\neq 0$ 时的直接公式：\n$$\nPV_{\\text{naive}}(Pmt,r,n) \\;=\\; Pmt \\times \\frac{1 - (1+r)^{-n}}{r},\n$$\n约定 $PV_{\\text{naive}}(Pmt,0,n) = Pmt \\times n$。\n\n- 以 $r=0$ 为中心的泰勒级数近似，截断至 $r^4$ 项。定义\n$$\nA_4(r,n) \\;=\\; n \\;-\\; \\frac{n(n+1)}{2}\\,r \\;+\\; \\frac{n(n+1)(n+2)}{6}\\,r^2 \\;-\\; \\frac{n(n+1)(n+2)(n+3)}{24}\\,r^3 \\;+\\; \\frac{n(n+1)(n+2)(n+3)(n+4)}{120}\\,r^4,\n$$\n并设\n$$\nPV_{\\text{series4}}(Pmt,r,n) \\;=\\; Pmt \\times \\begin{cases}\nA_4(r,n), & r \\neq 0,\\\n$$6pt]\nn, & r = 0.\n\\end{cases}\n$$\n\n对于下面的每个测试用例，计算如上定义的数学精确值 $PV(Pmt,r,n)$（解释为一个实值函数，其中 $r=0$ 的情况由极限给出），然后计算绝对误差\n$$\nE_{\\text{naive}} \\;=\\; \\big| PV_{\\text{naive}}(Pmt,r,n) \\;-\\; PV(Pmt,r,n) \\big|,\n\\qquad\nE_{\\text{series4}} \\;=\\; \\big| PV_{\\text{series4}}(Pmt,r,n) \\;-\\; PV(Pmt,r,n) \\big|.\n$$\n同时报告一个布尔值，用于表明截断的泰勒级数是否比直接公式产生更小的绝对误差，即 $E_{\\text{series4}} < E_{\\text{naive}}$ 是否成立。\n\n所有利率必须以小数形式提供和解释（例如，$r=0.05$ 意为百分之五）。没有物理单位；支付额和现值都是纯数。您的程序必须生成四舍五入到12位小数的浮点数结果。\n\n使用以下参数三元组 $(Pmt, r, n)$ 的测试套件：\n\n- 测试 1：$(100.0,\\; 0.05,\\; 30)$。\n- 测试 2：$(100.0,\\; 10^{-8},\\; 360)$。\n- 测试 3：$(100.0,\\; 0,\\; 360)$。\n- 测试 4：$(100.0,\\; -10^{-8},\\; 360)$。\n- 测试 5：$(1000.0,\\; 10^{-4},\\; 10000)$。\n- 测试 6：$(250.0,\\; 10^{-12},\\; 100)$。\n- 测试 7：$(500.0,\\; 0.15,\\; 10)$。\n\n要求的最终输出格式：包含一个列表的单行，每个测试用例对应一个条目，并保持测试顺序。每个条目必须是 $[E_{\\text{naive}}, E_{\\text{series4}}, \\text{series\\_better}]$ 形式的列表，其中前两个部分是四舍五入到12位小数的浮点数，第三个部分是一个布尔值，用于表明 $E_{\\text{series4}} < E_{\\text{naive}}$ 是否成立。该列表必须打印为无空格的单行，例如：\n$$\n\\text{[[0.000000000000,0.000000000000,True],[\\dots],[\\dots],\\dots]}\n$$", "solution": "首先验证用户的问题，以确保其在科学上是合理的、良构的且客观的。\n\n### 第一步：提取已知条件\n- **定额年金的现值函数**：\n$$\nPV(Pmt,r,n) \\;=\\; Pmt \\times \\begin{cases}\n\\dfrac{1 - (1+r)^{-n}}{r}, & r \\neq 0,\\\n$$6pt]\nn, & r = 0.\n\\end{cases}\n$$\n其中 $Pmt$ 是每期支付额，$r$ 是每期实际利率，而 $n \\in \\mathbb{N}$ 是支付次数。\n\n- **朴素近似**：\n$$\nPV_{\\text{naive}}(Pmt,r,n) \\;=\\; Pmt \\times \\frac{1 - (1+r)^{-n}}{r}, \\quad (\\text{约定 } PV_{\\text{naive}}(Pmt,0,n) = Pmt \\times n)\n$$\n\n- **四阶泰勒级数近似**：\n$$\nPV_{\\text{series4}}(Pmt,r,n) \\;=\\; Pmt \\times A_4(r,n), \\quad (\\text{约定 } PV_{\\text{series4}}(Pmt,0,n) = Pmt \\times n)\n$$\n其中年金因子近似值 $A_4(r,n)$ 由下式给出：\n$$\nA_4(r,n) \\;=\\; n \\;-\\; \\frac{n(n+1)}{2}\\,r \\;+\\; \\frac{n(n+1)(n+2)}{6}\\,r^2 \\;-\\; \\frac{n(n+1)(n+2)(n+3)}{24}\\,r^3 \\;+\\; \\frac{n(n+1)(n+2)(n+3)(n+4)}{120}\\,r^4\n$$\n\n- **误差度量**：\n$$\nE_{\\text{naive}} \\;=\\; \\big| PV_{\\text{naive}}(Pmt,r,n) \\;-\\; PV(Pmt,r,n) \\big|\n$$\n$$\nE_{\\text{series4}} \\;=\\; \\big| PV_{\\text{series4}}(Pmt,r,n) \\;-\\; PV(Pmt,r,n) \\big|\n$$\n\n- **比较**：一个布尔值，用于表明是否 $E_{\\text{series4}} < E_{\\text{naive}}$。\n\n- **测试用例**：由七个参数三元组 $(Pmt, r, n)$ 组成的测试套件：\n  1. $(100.0,\\; 0.05,\\; 30)$\n  2. $(100.0,\\; 10^{-8},\\; 360)$\n  3. $(100.0,\\; 0,\\; 360)$\n  4. $(100.0,\\; -10^{-8},\\; 360)$\n  5. $(1000.0,\\; 10^{-4},\\; 10000)$\n  6. $(250.0,\\; 10^{-12},\\; 100)$\n  7. $(500.0,\\; 0.15,\\; 10)$\n\n- **格式化**：结果必须是四舍五入到12位小数的浮点数。输出必须是 $[E_{\\text{naive}}, E_{\\text{series4}}, \\text{series\\_better}]$ 形式的列表的单行列表。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于年金现值的标准金融公式。问题的核心是，在计算利率 $r$ 接近零时的该公式时，会遇到数值不稳定性（灾难性抵消）问题。这是数值分析中的一个经典且易于理解的课题。使用泰勒级数展开作为一种补救措施是标准且正确的技术。所提供的泰勒级数系数在数学上是正确的，它们源自年金因子 $(1-(1+r)^{-n})/r$ 的麦克劳林级数。因此，该问题在科学和数学上都是合理的。\n- **良构性**：该问题是良构的。所有函数、变量和目标都得到了清晰明确的定义。提供了测试用例，并精确指定了预期的输出格式，确保存在唯一且可验证的解。\n- **客观性**：问题陈述是客观的，不含任何主观或推测性内容。它提出了一个纯粹的形式化计算任务。\n- **完整性与一致性**：该问题是自洽的。所有必要的公式和数据均已提供。不存在矛盾之处。\n\n### 第三步：结论与行动\n问题是有效的。将提供一个解决方案。\n\n### 基于原则的设计\n该解决方案基于数值分析的原理进行设计，以解决金融公式在有限精度算术中的不稳定性问题。\n\n1.  **灾难性抵消问题**：“朴素”的年金现值因子公式 $A(r,n) = \\frac{1 - (1+r)^{-n}}{r}$ 在 $r \\to 0$ 时数值上不稳定。在浮点算术中，当 $r$ 非常小时，$(1+r)$ 非常接近于 $1$，因此 $(1+r)^{-n}$ 也非常接近于 $1$。分子中的减法 $1 - (1+r)^{-n}$ 涉及两个几乎相等的数。这种被称为灾难性抵消的运算会导致相对精度的巨大损失，从而产生不准确的结果。\n\n2.  **建立高精度基准**：为了量化朴素公式的误差，必须高精度地计算一个“真实值”或基准值，在问题中表示为 $PV(Pmt,r,n)$。这可以通过对表达式进行代数重构以避免有问题的减法来实现。使用恒等式 $x = \\exp(\\ln x)$，以及用于 $\\ln(1+x)$ 的 `log1p(x)` 和用于 $e^x - 1$ 的 `expm1(x)`，我们可以将年金因子 $A(r,n)$ 重写为：\n    $$\n    A(r,n) = \\frac{1 - (1+r)^{-n}}{r} = \\frac{1 - \\exp(-n \\ln(1+r))}{r} = \\frac{-(\\exp(-n \\ln(1+r)) - 1)}{r}\n    $$\n    这个表达式可以使用 `numpy.log1p` 和 `numpy.expm1` 函数精确计算，这些函数是为在自变量很小时保持高精度而专门设计的。这种稳定的计算可作为我们的 `PV_exact`。\n\n3.  **泰勒级数近似**：除了重构之外，另一种方法是在问题点附近近似该函数。对于 $r \\approx 0$，年金因子 $A(r,n)$ 可以用其麦克劳林（$r=0$ 处的泰勒级数）展开式来近似。问题提供了此展开式截断至四阶项的形式，即 $A_4(r,n)$。这种多项式近似避免了近似相等项的减法，并有望在 $r$ 值非常接近零时具有很高的精度。此方法的误差 $E_{\\text{series4}}$ 是一个截断误差，其大小取决于级数中首个被忽略项的大小。\n\n4.  **算法实现**：对于每个测试用例 $(Pmt, r, n)$，算法按以下方式进行：\n    -   首先处理 $r=0$ 的特殊情况。根据问题定义，$PV_{\\text{exact}}$、$PV_{\\text{naive}}$ 和 $PV_{\\text{series4}}$ 均等于 $Pmt \\times n$。因此，两个误差都是 $0.0$，并且比较 $E_{\\text{series4}} < E_{\\text{naive}}$ 的结果为 `False`。\n    -   对于 $r \\neq 0$：\n        a.  使用稳定的 `log1p`/`expm1` 公式计算 `PV_exact`。\n        b.  使用直接公式计算 `PV_naive`。\n        c.  通过计算提供的多项式 $A_4(r,n)$ 来计算 `PV_series4`。为提高数值稳定性和效率，使用霍纳法来计算多项式。多项式的系数通过递归计算以避免处理大数，例如 $c_k = c_{k-1} \\times (-(n+k)/ (k+1))$。\n        d.  计算绝对误差 $E_{\\text{naive}} = |PV_{\\text{naive}} - PV_{\\text{exact}}|$ 和 $E_{\\text{series4}} = |PV_{\\text{series4}} - PV_{\\text{exact}}|$。\n        e.  确定布尔值 $E_{\\text{series4}} < E_{\\text{naive}}$。\n    -   最终的数值结果在添加到最终输出列表之前，会被格式化为12位小数的定点数。这确保了与指定输出格式的符合性。\n这种方法系统地评估和比较了不同计算方法的数值属性，展示了计算科学中的一个基本概念。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the numerical errors of two approximations for the\n    present value of an annuity, demonstrating the effects of catastrophic\n    cancellation for interest rates near zero.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 0.05, 30),\n        (100.0, 1e-8, 360),\n        (100.0, 0.0, 360),\n        (100.0, -1e-8, 360),\n        (1000.0, 1e-4, 10000),\n        (250.0, 1e-12, 100),\n        (500.0, 0.15, 10),\n    ]\n\n    all_results = []\n    for Pmt, r, n in test_cases:\n        # The case r=0 is defined specifically.\n        if r == 0.0:\n            e_naive = 0.0\n            e_series4 = 0.0\n            # 0.0 < 0.0 is False.\n            series_better = False\n            all_results.append([e_naive, e_series4, series_better])\n            continue\n\n        # Convert n to float for calculations to ensure float arithmetic throughout.\n        n_f = float(n)\n\n        # 1. Calculate PV_exact (high-precision benchmark).\n        # This uses numerically stable functions to avoid cancellation error.\n        # PV = Pmt * (1 - (1+r)^-n) / r = Pmt * -(exp(-n*log(1+r)) - 1) / r\n        pv_exact = Pmt * (-np.expm1(-n_f * np.log1p(r))) / r\n\n        # 2. Calculate PV_naive using the direct formula.\n        # This is prone to catastrophic cancellation for small r.\n        pv_naive = Pmt * (1.0 - (1.0 + r)**(-n_f)) / r\n\n        # 3. Calculate PV_series4 using the Taylor expansion.\n        # This is an approximation whose accuracy depends on r and the order of truncation.\n        # Coefficients are calculated recursively for stability.\n        c0 = n_f\n        c1 = -n_f * (n_f + 1.0) / 2.0\n        c2 = -c1 * (n_f + 2.0) / 3.0\n        c3 = -c2 * (n_f + 3.0) / 4.0\n        c4 = -c3 * (n_f + 4.0) / 5.0\n        \n        # Evaluate polynomial using Horner's method for efficiency and stability.\n        a4 = c0 + r * (c1 + r * (c2 + r * (c3 + r * c4)))\n        pv_series4 = Pmt * a4\n\n        # 4. Calculate absolute errors.\n        e_naive = abs(pv_naive - pv_exact)\n        e_series4 = abs(pv_series4 - pv_exact)\n        \n        # 5. Compare errors.\n        series_better = e_series4 < e_naive\n\n        all_results.append([e_naive, e_series4, series_better])\n\n    # Final print statement in the exact required format.\n    output_parts = []\n    for e_n, e_s, better in all_results:\n        # Format the float values to 12 decimal places, fixed-point notation.\n        part = f\"[{e_n:.12f},{e_s:.12f},{str(better)}]\"\n        output_parts.append(part)\n    \n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```"}]}