{"hands_on_practices": [{"introduction": "将无差异曲线的抽象概念转化为具体的计算任务是一项核心技能。本练习将指导您数值化地追踪由常数替代弹性（CES）效用函数 $U(x,y) = (ax^{\\rho} + by^{\\rho})^{1/\\rho}$ 定义的无差异曲线。通过这个过程，您将亲手计算并验证边际替代率（Marginal Rate of Substitution, MRS）递减这一关键经济学原理，从而加深对偏好几何形态的理解。[@problem_id:2401500]", "id": "2401500", "problem": "考虑两种商品的恒定替代弹性 (CES) 效用函数，定义为 $U(x,y) = \\left(a x^{\\rho} + b y^{\\rho}\\right)^{1/\\rho}$，其中参数 $a&gt;0$，$b&gt;0$ 且 $\\rho \\neq 0$。在效用水平 $U_0&gt;0$ 上的无差异曲线是集合 $\\{(x,y): U(x,y)=U_0, x&gt;0, y&gt;0\\}$。您的任务是编写一个完整的、可运行的程序，该程序针对每组指定的参数集以及无差异曲线正定义域中的两个给定 $x$ 值，在该无差异曲线上生成相应的 $y$ 值，并评估边际替代率 (MRS) 在沿曲线的这两点之间是否严格递减。\n\n使用的定义：\n- 效用水平为 $U_0$ 的无差异曲线由 $U(x,y)=U_0$ 隐式给出，其中 $x&gt;0$ 且 $y&gt;0$。\n- 边际替代率 (MRS) 定义为 $\\text{MRS}(x,y) = \\dfrac{\\partial U/\\partial x}{\\partial U/\\partial y}$。\n\n对于下方的每个测试用例，执行以下操作：\n1. 给定 $(a,b,\\rho,U_0)$ 和属于效用水平 $U_0$ 的无差异曲线定义域内的两个正 $x$ 值 $(x_1,x_2)$，计算满足 $U(x_i,y_i)=U_0$（其中 $i \\in \\{1,2\\}$）的唯一正 $y$ 值 $(y_1,y_2)$。\n2. 使用上述定义计算 $\\text{MRS}(x_1,y_1)$ 和 $\\text{MRS}(x_2,y_2)$，并返回一个布尔值，该值指示 $\\text{MRS}(x_1,y_1) &gt; \\text{MRS}(x_2,y_2)$ 是否成立，即当 $x$ 沿同一无差异曲线从 $x_1$ 增加到 $x_2$ 时，MRS 是否严格递减。\n\n测试套件：\n- 用例 $1$：$a=0.6$, $b=0.4$, $\\rho=-1.0$, $U_0=1.0$, $x_1=0.61$, $x_2=0.8$。\n- 用例 $2$：$a=0.6$, $b=0.4$, $\\rho=0.5$, $U_0=1.0$, $x_1=0.5$, $x_2=2.7$。\n- 用例 $3$：$a=0.6$, $b=0.4$, $\\rho=2.0$, $U_0=1.0$, $x_1=0.3$, $x_2=1.2$。\n\n要求：\n- 在整个过程中，假设 $x&gt;0$ 且 $y&gt;0$。对于每个用例，所提供的 $x_1$ 和 $x_2$ 均位于允许的定义域内，在该域中存在唯一的正 $y$ 解来满足 $U(x,y)=U_0$。\n- 对于每个测试用例，返回一个列表 $[y_1,y_2,\\text{decreasing}]$，其中 $y_1$ 和 $y_2$ 是四舍五入到 $6$ 位小数的浮点数，当且仅当 $\\text{MRS}(x_1,y_1) &gt; \\text{MRS}(x_2,y_2)$ 时，$\\text{decreasing}$ 是一个等于 $\\text{True}$ 的布尔值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个条目，顺序与上面列出的一致。每个条目本身也应是一个用方括号括起来的逗号分隔列表。例如，最终输出格式必须类似于这样的一行：\n  \"[[y1_case1,y2_case1,decreasing_case1],[y1_case2,y2_case2,decreasing_case2],[y1_case3,y2_case3,decreasing_case3]]\"\n- 不涉及物理单位。", "solution": "给定恒定替代弹性 (CES) 效用函数 $U(x,y) = \\left(a x^{\\rho} + b y^{\\rho}\\right)^{1/\\rho}$，其中 $a&gt;0$，$b&gt;0$ 且 $\\rho \\neq 0$。在效用水平 $U_0&gt;0$ 上的无差异曲线由满足 $U(x,y)=U_0$ 的点集 $(x,y)$ 定义，其中 $x&gt;0$ 且 $y&gt;0$。\n\n第1步：求解无差异曲线。固定 $U_0&gt;0$。方程 $U(x,y)=U_0$ 意味着\n$$\n\\left(a x^{\\rho} + b y^{\\rho}\\right)^{1/\\rho} = U_0 \\quad \\Longleftrightarrow \\quad a x^{\\rho} + b y^{\\rho} = U_0^{\\rho}.\n$$\n求解 $y^{\\rho}$ 可得\n$$\ny^{\\rho} = \\frac{U_0^{\\rho} - a x^{\\rho}}{b}.\n$$\n在维持 $x&gt;0$、$y&gt;0$ 以及所提供 $x$ 值的可接受性的假设下，等式右侧为正，因此 $y$ 的唯一正解为\n$$\ny(x) = \\left(\\frac{U_0^{\\rho} - a x^{\\rho}}{b}\\right)^{1/\\rho}.\n$$\n\n第2步：边际替代率 (MRS)。根据定义，\n$$\n\\text{MRS}(x,y) = \\frac{\\partial U/\\partial x}{\\partial U/\\partial y}.\n$$\n设 $S(x,y) = a x^{\\rho} + b y^{\\rho}$。则 $U(x,y) = S(x,y)^{1/\\rho}$。使用链式法则，\n$$\n\\frac{\\partial U}{\\partial x} = \\frac{1}{\\rho} S^{1/\\rho - 1} \\cdot a \\rho x^{\\rho - 1} = a x^{\\rho - 1} S^{1/\\rho - 1},\n$$\n$$\n\\frac{\\partial U}{\\partial y} = \\frac{1}{\\rho} S^{1/\\rho - 1} \\cdot b \\rho y^{\\rho - 1} = b y^{\\rho - 1} S^{1/\\rho - 1}.\n$$\n因此，边际替代率可简化为\n$$\n\\text{MRS}(x,y) = \\frac{a x^{\\rho - 1}}{b y^{\\rho - 1}} = \\frac{a}{b} \\left(\\frac{x}{y}\\right)^{\\rho - 1}.\n$$\n\n第3步：应用于测试套件。对于每个用例，我们使用以下公式计算 $y_1 = y(x_1)$ 和 $y_2 = y(x_2)$\n$$\ny(x) = \\left(\\frac{U_0^{\\rho} - a x^{\\rho}}{b}\\right)^{1/\\rho},\n$$\n然后计算 $\\text{MRS}(x_i,y_i) = \\dfrac{a}{b} \\left(\\dfrac{x_i}{y_i}\\right)^{\\rho - 1}$（$i \\in \\{1,2\\}$）。最后，我们构成布尔值 $\\text{decreasing} = \\left[\\text{MRS}(x_1,y_1) &gt; \\text{MRS}(x_2,y_2)\\right]$。根据要求，下述数值四舍五入到 $6$ 位小数。\n\n- 用例 $1$：$a=0.6$, $b=0.4$, $\\rho=-1.0$, $U_0=1.0$, $x_1=0.61$, $x_2=0.8$。\n  - $y_1 = \\left(\\dfrac{1.0^{-1.0} - 0.6 \\cdot 0.61^{-1.0}}{0.4}\\right)^{-1} = \\dfrac{0.4 \\cdot 0.61}{0.61 - 0.6} = 24.4 \\rightarrow 24.400000$。\n  - $y_2 = \\left(\\dfrac{1.0^{-1.0} - 0.6 \\cdot 0.8^{-1.0}}{0.4}\\right)^{-1} = \\dfrac{0.4 \\cdot 0.8}{0.8 - 0.6} = 1.6 \\rightarrow 1.600000$。\n  - $\\text{MRS}(x_1,y_1) = \\dfrac{0.6}{0.4} \\left(\\dfrac{0.61}{24.4}\\right)^{-2}$，$\\text{MRS}(x_2,y_2) = \\dfrac{0.6}{0.4} \\left(\\dfrac{0.8}{1.6}\\right)^{-2}$。由于 $\\left(\\dfrac{0.61}{24.4}\\right)^{-2} \\gg \\left(\\dfrac{0.8}{1.6}\\right)^{-2}$，我们得到严格递减：$\\text{decreasing}=\\text{True}$。\n\n- 用例 $2$：$a=0.6$, $b=0.4$, $\\rho=0.5$, $U_0=1.0$, $x_1=0.5$, $x_2=2.7$。\n  - $y_1 = \\left(\\dfrac{1.0^{0.5} - 0.6 \\cdot 0.5^{0.5}}{0.4}\\right)^{2} \\approx 2.071067811865475 \\rightarrow 2.071068$。\n  - $y_2 = \\left(\\dfrac{1.0^{0.5} - 0.6 \\cdot 2.7^{0.5}}{0.4}\\right)^{2} \\approx 0.001242456 \\rightarrow 0.001242$。\n  - $\\text{MRS}(x_1,y_1) = \\dfrac{0.6}{0.4} \\left(\\dfrac{0.5}{2.071068}\\right)^{-0.5}$，$\\text{MRS}(x_2,y_2) = \\dfrac{0.6}{0.4} \\left(\\dfrac{2.7}{0.001242}\\right)^{-0.5}$。数值上，$\\text{MRS}(x_1,y_1) &gt; \\text{MRS}(x_2,y_2)$，因此 $\\text{decreasing}=\\text{True}$。\n\n- 用例 $3$：$a=0.6$, $b=0.4$, $\\rho=2.0$, $U_0=1.0$, $x_1=0.3$, $x_2=1.2$。\n  - $y_1 = \\left(\\dfrac{1.0^{2.0} - 0.6 \\cdot 0.3^{2.0}}{0.4}\\right)^{0.5} = \\sqrt{\\dfrac{1 - 0.054}{0.4}} = \\sqrt{2.365} \\approx 1.5378556 \\rightarrow 1.537856$。\n  - $y_2 = \\left(\\dfrac{1.0^{2.0} - 0.6 \\cdot 1.2^{2.0}}{0.4}\\right)^{0.5} = \\sqrt{\\dfrac{1 - 0.864}{0.4}} = \\sqrt{0.34} \\approx 0.583095 \\rightarrow 0.583095$。\n  - $\\text{MRS}(x_1,y_1) = \\dfrac{0.6}{0.4} \\left(\\dfrac{0.3}{1.537856}\\right)^{1}$，$\\text{MRS}(x_2,y_2) = \\dfrac{0.6}{0.4} \\left(\\dfrac{1.2}{0.583095}\\right)^{1}$。此处 $\\text{MRS}(x_1,y_1) &lt; \\text{MRS}(x_2,y_2)$，因此 $\\text{decreasing}=\\text{False}$。\n\n因此，每个用例的预期列表（$y$ 值四舍五入到 6 位小数并附有布尔标志）如下：\n- 用例 $1$：$[24.400000, 1.600000, \\text{True}]$。\n- 用例 $2$：$[2.071068, 0.001242, \\text{True}]$。\n- 用例 $3$：$[1.537856, 0.583095, \\text{False}]$。\n\n程序应将这三个用例的结果以单行输出，形式为方括号括起来的逗号分隔列表，其中每个用例的结果本身也是一个用方括号括起来的逗号分隔列表，顺序与上述用例相同。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef compute_y(a, b, rho, U0, x):\n    # Compute y on the indifference curve U(x,y)=U0 with y>0\n    base = (U0**rho - a * (x**rho)) / b\n    if base <= 0:\n        # Domain violation; for given test suite this should not occur.\n        return float('nan')\n    y = base ** (1.0 / rho)\n    return y\n\ndef mrs(a, b, rho, x, y):\n    # MRS = MU_x / MU_y = (a/b) * (x/y)^(rho - 1)\n    return (a / b) * ((x / y) ** (rho - 1.0))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (a, b, rho, U0, x1, x2)\n    test_cases = [\n        (0.6, 0.4, -1.0, 1.0, 0.61, 0.8),\n        (0.6, 0.4,  0.5, 1.0, 0.5,  2.7),\n        (0.6, 0.4,  2.0, 1.0, 0.3,  1.2),\n    ]\n\n    case_outputs = []\n    for a, b, rho, U0, x1, x2 in test_cases:\n        y1 = compute_y(a, b, rho, U0, x1)\n        y2 = compute_y(a, b, rho, U0, x2)\n\n        # Compute MRS at both points\n        mrs1 = mrs(a, b, rho, x1, y1)\n        mrs2 = mrs(a, b, rho, x2, y2)\n        decreasing = mrs1 > mrs2\n\n        # Format y-values to 6 decimal places\n        y1_str = f\"{y1:.6f}\"\n        y2_str = f\"{y2:.6f}\"\n        case_str = f\"[{y1_str},{y2_str},{decreasing}]\"\n        case_outputs.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(case_outputs)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "理解边际替代率（MRS）是求解消费者最优选择问题的关键。这个实践将挑战您为一个复杂的效用函数求解经典的相切条件——即无差异曲线与预算线相切的点，其条件为 $MRS_{xy} = p_x / p_y$。这项任务展示了在现实世界的应用中，解析解往往是不可行的，因此数值方法变得至关重要。[@problem_id:2401479]", "id": "2401479", "problem": "考虑一个消费者选择两种商品的组合，其数量由 $x$ 和 $y$ 表示，面临严格为正的价格 $p_x$ 和 $p_y$ 及收入 $m &gt; 0$。其偏好由以下效用函数表示\n$$\nu(x,y) \\;=\\; a_1 \\ln(x) \\;+\\; a_2 \\ln(y) \\;+\\; b_1 \\sqrt{x} \\;+\\; b_2 \\sqrt{y} \\;+\\; c \\left(\\theta x^{\\rho} + (1-\\theta) y^{\\rho}\\right)^{\\tfrac{1}{\\rho}},\n$$\n其中 $a_1,a_2,b_1,b_2,c,\\theta,\\rho$ 是满足 $a_1 &gt; 0$, $a_2 &gt; 0$, $b_1 \\ge 0$, $b_2 \\ge 0$, $c \\ge 0$, $0 &lt; \\theta &lt; 1$ 及 $0 &lt; \\rho &lt; 1$ 的参数。假设 $x &gt; 0$ 且 $y &gt; 0$。消费者的预算集由线性约束 $p_x x + p_y y \\le m$ 定义，且单调性偏好意味着预算约束在最优点是紧绷的，因此有 $p_x x + p_y y = m$。\n\n商品 $x$ 对商品 $y$ 的边际替代率定义为 $MRS_{xy} = MU_x / MU_y$，其中 $MU_x$ 和 $MU_y$ 分别是关于 $x$ 和 $y$ 的边际效用。一个内部最优点满足条件 $MRS_{xy} = p_x/p_y$ 和 $p_x x + p_y y = m$。\n\n您的任务是通过求解由边际替代率等于价格比以及紧绷的预算约束所构成的方程组，为下方测试套件中的每组参数计算出唯一的内部最优组合 $(x^\\star, y^\\star)$。解答必须满足 $x^\\star &gt; 0$ 和 $y^\\star &gt; 0$。\n\n测试套件（每个测试是一个有序元组 $(a_1,a_2,b_1,b_2,c,\\theta,\\rho,p_x,p_y,m)$）：\n- 测试 $1$：$(0.9, 1.1, 0.7, 0.8, 0.6, 0.35, 0.5, 2.0, 1.5, 12.0)$\n- 测试 $2$：$(1.0, 1.0, 0.5, 0.5, 0.9, 0.6, 0.4, 5.0, 1.0, 10.0)$\n- 测试 $3$：$(0.8, 1.2, 0.6, 0.9, 0.7, 0.4, 0.7, 1.2, 1.3, 100.0)$\n- 测试 $4$：$(1.5, 0.7, 0.4, 0.6, 0.5, 0.5, 0.6, 3.0, 2.0, 5.0)$\n\n答案规格：\n- 对于每个测试，输出四舍五入到 $6$ 位小数的数组 $[x^\\star,y^\\star]$。\n- 将所有测试的结果聚合为单行，形式为不含空格的列表的列表，并按测试顺序排列。例如，对于 $4$ 个测试，一个有效的输出格式是 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$，其中每个 $x_i$ 和 $y_i$ 是一个四舍五入到 $6$ 位小数的浮点数。", "solution": "所呈现的问题是微观经济学理论中一个经典的效用最大化问题。消费者寻求选择一个由两种商品组成的组合，其数量表示为 $x > 0$ 和 $y > 0$，以便在线性预算约束下最大化给定的效用函数。该问题定义明确，具有科学依据，并为获得唯一解提供了所有必要信息。\n\n消费者的最优化问题是：\n$$\n\\max_{x,y} \\; u(x,y) \\quad \\text{subject to} \\quad p_x x + p_y y \\le m\n$$\n效用函数由以下公式给出：\n$$\nu(x,y) = a_1 \\ln(x) + a_2 \\ln(y) + b_1 \\sqrt{x} + b_2 \\sqrt{y} + c \\left(\\theta x^{\\rho} + (1-\\theta) y^{\\rho}\\right)^{\\frac{1}{\\rho}}\n$$\n给定参数 $a_1 > 0$ 和 $a_2 > 0$，对数项确保了当 $x$ 或 $y$ 趋近于零时，边际效用趋近于无穷大。这保证了任何最优解都必须是内部解，即 $x^\\star > 0$ 且 $y^\\star > 0$。对于内部解，预算约束将是紧绷的，即 $p_x x + p_y y = m$。\n\n内部最优点的条件有两个：\n$1$. 必须满足预算约束：$p_x x + p_y y = m$。\n$2$. 无差异曲线的斜率必须等于预算线的斜率。这是相切条件，表示为边际替代率（$MRS_{xy}$）与价格比相等：\n$$\nMRS_{xy} = \\frac{MU_x}{MU_y} = \\frac{p_x}{p_y}\n$$\n其中 $MU_x = \\frac{\\partial u}{\\partial x}$ 和 $MU_y = \\frac{\\partial u}{\\partial y}$ 分别是商品 $x$ 和商品 $y$ 的边际效用。\n\n首先，我们必须通过对效用函数 $u(x,y)$ 求偏导数来推导边际效用。\n关于 $x$ 的边际效用是：\n$$\nMU_x = \\frac{\\partial u}{\\partial x} = \\frac{a_1}{x} + \\frac{b_1}{2\\sqrt{x}} + c \\theta \\left(\\theta x^{\\rho} + (1-\\theta) y^{\\rho}\\right)^{\\frac{1-\\rho}{\\rho}} x^{\\rho-1}\n$$\n关于 $y$ 的边际效用是：\n$$\nMU_y = \\frac{\\partial u}{\\partial y} = \\frac{a_2}{y} + \\frac{b_2}{2\\sqrt{y}} + c (1-\\theta) \\left(\\theta x^{\\rho} + (1-\\theta) y^{\\rho}\\right)^{\\frac{1-\\rho}{\\rho}} y^{\\rho-1}\n$$\n最优性条件构成了一个包含两个未知数 $x$ 和 $y$ 的非线性方程组：\n$$\n\\begin{cases}\np_y \\left( \\frac{a_1}{x} + \\frac{b_1}{2\\sqrt{x}} + c \\theta (\\dots)^{\\frac{1-\\rho}{\\rho}} x^{\\rho-1} \\right) = p_x \\left( \\frac{a_2}{y} + \\frac{b_2}{2\\sqrt{y}} + c (1-\\theta) (\\dots)^{\\frac{1-\\rho}{\\rho}} y^{\\rho-1} \\right) \\\\\np_x x + p_y y = m\n\\end{cases}\n$$\n由于这些方程的复杂性，解析解是难以处理的。因此，需要采用数值方法。\n\n该系统可以简化为单变量的求根问题。根据预算约束，我们将 $y$ 表示为 $x$ 的函数：\n$$\ny(x) = \\frac{m - p_x x}{p_y}\n$$\n对于内部解，我们要求 $x > 0$ 和 $y > 0$。条件 $y > 0$ 意味着 $m - p_x x > 0$，即 $x < m/p_x$。因此，$x$ 的搜索空间是开区间 $(0, m/p_x)$。\n\n通过将 $y(x)$ 代入整理后的相切条件 $p_y MU_x - p_x MU_y = 0$，我们得到了一个只含 $x$ 的方程：\n$$\nf(x) = p_y \\cdot MU_x(x, y(x)) - p_x \\cdot MU_y(x, y(x)) = 0\n$$\n我们必须在区间 $(0, m/p_x)$ 内找到 $f(x)$ 的根。让我们来考察 $f(x)$ 在区间边界处的行为。\n当 $x \\to 0^+$ 时，$MU_x$ 中的项 $\\frac{a_1}{x}$ 和 $\\frac{b_1}{2\\sqrt{x}}$ 趋于 $+\\infty$，而 $MU_y$ 保持有限。因此，$f(x) \\to +\\infty$。\n当 $x \\to (m/p_x)^-$ 时，$y(x) \\to 0^+$。$MU_y$ 中的项 $\\frac{a_2}{y}$ 和 $\\frac{b_2}{2\\sqrt{y}}$ 趋于 $+\\infty$，而 $MU_x$ 保持有限。因此，$f(x) \\to -\\infty$。\n\n由于 $f(x)$ 在区间 $(0, m/p_x)$ 上是连续的，并且其在边界处的值符号相反，根据介值定理，可以保证在该区间内至少存在一个根 $x^\\star$。所提供的效用函数是严格拟凹的，这确保了该根是唯一的。\n\n找到唯一最优组合 $(x^\\star, y^\\star)$ 的算法如下：\n$1$. 对于每个测试用例，根据给定的常数 $(a_1, a_2, b_1, b_2, c, \\theta, \\rho, p_x, p_y, m)$ 定义如上所述的函数 $f(x)$。\n$2$. 为 $x$ 建立一个搜索区间，例如 $[\\epsilon, m/p_x - \\epsilon]$，其中 $\\epsilon$ 是一个很小的正数（例如 $10^{-9}$），以避免在边界处出现数值不稳定性。\n$3$. 采用一个稳健的一维求根算法，如 Brent 方法，来求解 $f(x) = 0$ 以得到 $x^\\star$。`scipy.optimize.brentq` 函数适合此任务，因为它保证在区间端点函数值符号相反的情况下找到一个根。\n$4$. 一旦找到最优值 $x^\\star$，使用预算约束计算相应的商品 $y$ 的最优数量：$y^\\star = (m - p_x x^\\star) / p_y$。\n$5$. 所得的数组 $(x^\\star, y^\\star)$ 即为唯一的消费最优组合。\n$6$. 对于每个测试用例，将计算出的值四舍五入到 $6$ 位小数，并聚合成指定的输出格式。\n将实施此程序来为所有提供的测试用例求解最优组合。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the optimal consumption bundle (x*, y*) for a given utility function\n    and budget constraint by numerically solving the system of first-order conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.9, 1.1, 0.7, 0.8, 0.6, 0.35, 0.5, 2.0, 1.5, 12.0),\n        (1.0, 1.0, 0.5, 0.5, 0.9, 0.6, 0.4, 5.0, 1.0, 10.0),\n        (0.8, 1.2, 0.6, 0.9, 0.7, 0.4, 0.7, 1.2, 1.3, 100.0),\n        (1.5, 0.7, 0.4, 0.6, 0.5, 0.5, 0.6, 3.0, 2.0, 5.0)\n    ]\n\n    results = []\n    for params in test_cases:\n        a1, a2, b1, b2, c, theta, rho, px, py, m = params\n\n        def objective_function(x):\n            \"\"\"\n            This function represents the rearranged tangency condition: p_y*MU_x - p_x*MU_y = 0.\n            We solve for the root of this function to find the optimal x.\n            The variable y is substituted using the budget constraint y = (m - px*x) / py.\n            \"\"\"\n            # Ensure x is within the valid domain (0, m/px)\n            if x <= 1e-12:\n                # If x is near zero, MUx dominates, so f(x) -> +inf\n                return np.inf\n            \n            y = (m - px * x) / py\n            \n            if y <= 1e-12:\n                # If y is near zero, MUy dominates, so f(x) -> -inf\n                return -np.inf\n\n            # Calculate Marginal Utility of x (MU_x)\n            mu_x_term1 = a1 / x\n            mu_x_term2 = b1 / (2 * np.sqrt(x))\n            if c > 0:\n                Z = theta * x**rho + (1 - theta) * y**rho\n                mu_x_term3 = c * theta * (Z**((1 - rho) / rho)) * (x**(rho - 1))\n            else:\n                mu_x_term3 = 0.0\n            mu_x = mu_x_term1 + mu_x_term2 + mu_x_term3\n\n            # Calculate Marginal Utility of y (MU_y)\n            mu_y_term1 = a2 / y\n            mu_y_term2 = b2 / (2 * np.sqrt(y))\n            if c > 0:\n                # Z is the same and already computed if c > 0\n                mu_y_term3 = c * (1 - theta) * (Z**((1 - rho) / rho)) * (y**(rho - 1))\n            else:\n                mu_y_term3 = 0.0\n            mu_y = mu_y_term1 + mu_y_term2 + mu_y_term3\n\n            return py * mu_x - px * mu_y\n\n        # The search for optimal x must be in the interval (0, m/px) to ensure x > 0 and y > 0.\n        # We use a small epsilon to avoid division by zero or other numerical issues at the boundaries.\n        lower_bound = 1e-9\n        upper_bound = m / px - 1e-9\n        \n        # Use Brent's method to find the root of the objective function.\n        # This gives us the optimal quantity of good x.\n        optimal_x = brentq(objective_function, lower_bound, upper_bound)\n        \n        # Calculate the optimal quantity of good y from the budget constraint.\n        optimal_y = (m - px * optimal_x) / py\n\n        # Append the rounded results to the list.\n        results.append([round(optimal_x, 6), round(optimal_y, 6)])\n\n    # Format the final output string to match the specified format: [[x1,y1],[x2,y2],...] with no spaces.\n    final_output_str = f\"[{','.join(map(str, results))}]\".replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```"}, {"introduction": "让我们超越标准教科书中的例子，进行一次高级探索。虽然我们通常将无差异曲线画成细线，但某些更现实的偏好（如满足或饱和点）可能导致“厚”的无差异区域。这项计算实践将让您学习如何通过数值方法识别和量化这些效用“平台”，从而深化您对消费者理论背后假设的认识。[@problem_id:2401541]", "id": "2401541", "problem": "考虑一个消费者选择由两种非负商品组成的商品束，表示为坐标 $(x,y)\\in\\mathbb{R}_{+}^{2}$。偏好由一个效用函数 $u:\\mathbb{R}_{+}^{2}\\to\\mathbb{R}$ 表示，对于一个效用水平 $u_{0}\\in\\mathbb{R}$，在水平 $u_{0}$ 上的无差异集是集合 $\\{(x,y)\\in\\mathbb{R}_{+}^{2}:u(x,y)=u_{0}\\}$。如果一个无差异集在 $\\mathbb{R}^{2}$ 中有非空内部，或者等价地说，其二维勒贝格测度严格为正，则称该无差异集是厚的。当偏好不满足局部非饱和性，或当效用呈现平台区时，可能会出现厚的无差异集，这在非严格凸的偏好中很常见。\n\n你的任务是，在一个有界域和一个有限网格上，计算无差异集面积的近似值（解释为二维勒贝格测度），并判断该无差异集是否是厚的。使用以下关于定义域和网格的定义：\n\n- 定义域：$D=[0,2]\\times[0,2]$。\n- 均匀网格间距：在两个坐标轴上均为 $\\Delta=0.02$，从而在每个轴上生成位于 $\\{0,\\Delta,2\\Delta,\\ldots,2\\}$ 的网格顶点。\n\n对于给定的效用 $u$ 和目标水平 $u_{0}$，在每个网格顶点 $(x_{i},y_{j})$ 上定义网格顶点评估值 $U_{ij}=u(x_{i},y_{j})$。对于每个网格单元格（其四个顶点为 $(x_{i},y_{j})$、 $(x_{i+1},y_{j})$、 $(x_{i},y_{j+1})$、 $(x_{i+1},y_{j+1})$ 的轴对齐正方形），定义无差异单元格指示函数如下\n$$\n\\mathbb{I}_{ij}=\\begin{cases}\n1 & \\text{若 }U_{ij}=u_{0},\\ U_{i+1,j}=u_{0},\\ U_{i,j+1}=u_{0},\\ U_{i+1,j+1}=u_{0},\\\\\n0 & \\text{其他情况}.\n\\end{cases}\n$$\n令面积估计量为\n$$\n\\widehat{A}(u,u_{0};D,\\Delta)=\\left(\\sum_{i,j}\\mathbb{I}_{ij}\\right)\\cdot \\Delta^{2},\n$$\n并定义厚度指示器\n$$\nT(u,u_{0};D,\\Delta)=\\begin{cases}\n1 & \\text{若 }\\widehat{A}(u,u_{0};D,\\Delta)>0,\\\\\n0 & \\text{若 }\\widehat{A}(u,u_{0};D,\\Delta)=0.\n\\end{cases}\n$$\n\n测试套件。对于以下四个效用设定和目标水平，使用上面定义的共同定义域 $D$ 和网格间距 $\\Delta$ 来计算配对 $(\\widehat{A},T)$：\n\n- 案例 1：$u_{1}(x,y)=\\min\\{\\sqrt{x}+\\sqrt{y},\\,2\\}$，目标水平为 $u_{0}=2$。\n- 案例 2：$u_{2}(x,y)=\\sqrt{x}+\\sqrt{y}$，目标水平为 $u_{0}=2$。\n- 案例 3：$u_{3}(x,y)=\\min\\{x,y\\}$，目标水平为 $u_{0}=1$。\n- 案例 4：$u_{4}(x,y)=\\min\\{1,x\\}+\\min\\{1,y\\}$，目标水平为 $u_{0}=2$。\n\n答案规格与格式。对于每个案例，返回两个输出：估计面积 $\\widehat{A}$ 和厚度指示器 $T$。将每个 $\\widehat{A}$ 表示为四舍五入到6位小数的浮点数，将每个 $T$ 表示为整数（$0$ 或 $1$）。你的程序应产生单行输出，其中包含按顺序连接的四个案例的结果，格式为一个由方括号括起来的逗号分隔列表，即\n$$\n[\\widehat{A}_{1},T_{1},\\widehat{A}_{2},T_{2},\\widehat{A}_{3},T_{3},\\widehat{A}_{4},T_{4}],\n$$\n其中下标表示从1到4的案例索引。", "solution": "对问题陈述进行验证。\n\n**第 1 步：提取给定条件**\n- **定义域**：$D=[0,2]\\times[0,2]$。\n- **网格间距**：$\\Delta=0.02$。\n- **网格**：在 $D$ 上的一个均匀网格，顶点为 $(x_i, y_j) = (i\\Delta, j\\Delta)$，其中整数 $i, j$ 满足 $0 \\le i\\Delta \\le 2$ 和 $0 \\le j\\Delta \\le 2$。\n- **效用评估值**：$U_{ij}=u(x_{i},y_{j})$。\n- **无差异单元格指示函数**：如果单元格 $(i,j)$ 所有四个顶点的效用均等于 $u_0$，则 $\\mathbb{I}_{ij}=1$；否则为 $0$。\n- **面积估计量**：$\\widehat{A}(u,u_{0};D,\\Delta)=\\left(\\sum_{i,j}\\mathbb{I}_{ij}\\right)\\cdot \\Delta^{2}$。\n- **厚度指示器**：如果 $\\widehat{A}>0$，则 $T=1$；否则 $T=0$。\n- **测试案例**：\n    1. $u_{1}(x,y)=\\min\\{\\sqrt{x}+\\sqrt{y},\\,2\\}$，目标水平为 $u_{0}=2$。\n    2. $u_{2}(x,y)=\\sqrt{x}+\\sqrt{y}$，目标水平为 $u_{0}=2$。\n    3. $u_{3}(x,y)=\\min\\{x,y\\}$，目标水平为 $u_{0}=1$。\n    4. $u_{4}(x,y)=\\min\\{1,x\\}+\\min\\{1,y\\}$，目标水平为 $u_{0}=2$。\n\n**第 2 步：使用提取的给定条件进行验证**\n根据所需标准对问题进行评估。\n- **科学性**：该问题基于微观经济学理论（效用函数、无差异集）和数值方法（基于网格的近似）中的既有概念。厚无差异集的概念是经济分析中的一个有效研究课题。\n- **良构性**：该问题在数学和算法上是良定义的。所有参数、函数和计算过程都得到了明确的规定。所提供的算法确定了一个唯一的解。\n- **客观性**：语言精确，无主观论断。\n\n**第 3 步：结论与行动**\n该问题被认定为**有效**。它是自洽的、科学上合理的和良构的。将提供一个解决方案。\n\n**方法论**\n\n任务是实现一个数值算法，在一个离散网格上估算无差异集“厚”部分的面积。问题的核心在于识别出那些在所有四个顶点上，给定效用函数 $u(x,y)$ 都恒等于目标值 $u_0$ 的网格单元格。\n\n首先，我们建立计算网格。定义域为 $D=[0,2]\\times[0,2]$，间距为 $\\Delta=0.02$。这定义了一组网格点 $(x_i, y_j)$，其中 $x_i=i\\Delta$ 和 $y_j=j\\Delta$。由于 $2/\\Delta = 100$，索引 $i$ 和 $j$ 的范围是从 $0$ 到 $100$。这创建了一个 $101 \\times 101$ 的顶点网格，该网格又定义了一个 $100 \\times 100$ 的单元格网格。一个单元格 $(i,j)$（其中 $i,j$ 从 $0$ 到 $99$）是以 $(x_i, y_j), (x_{i+1}, y_j), (x_i, y_{j+1}), (x_{i+1}, y_{j+1})$ 为顶点的正方形。\n\n对于四个测试案例中的每一个，执行以下步骤：\n1.  在网格的每个顶点上评估效用函数 $u(x,y)$，创建一个 $101 \\times 101$ 的效用值矩阵 $U$。\n2.  我们遍历 $100 \\times 100$ 个单元格中的每一个。对于每个单元格 $(i,j)$，我们检查其四个角点顶点——$U_{i,j}, U_{i+1,j}, U_{i,j+1}, U_{i+1,j+1}$——的效用值是否全部等于目标效用 $u_0$。考虑到一些效用函数的分段性质和特定的网格选择，问题指定了精确的相等性检查，这是合适的。\n3.  满足此条件的单元格数量（我们称之为 $N_{thick}$）被计数。这对应于 $\\sum_{i,j}\\mathbb{I}_{ij}$。\n4.  面积估计量计算为 $\\widehat{A} = N_{thick} \\cdot \\Delta^2$。\n5.  厚度指示器 $T$ 在 $\\widehat{A} > 0$ 时设为 $1$，否则设为 $0$。\n\n该过程应用于每个案例。\n\n**案例 1：$u_{1}(x,y)=\\min\\{\\sqrt{x}+\\sqrt{y},\\,2\\}$，目标水平为 $u_{0}=2$。**\n条件 $u_1(x,y)=2$ 成立当且仅当 $\\sqrt{x}+\\sqrt{y} \\ge 2$。函数 $f(x,y)=\\sqrt{x}+\\sqrt{y}$ 在 $x,y > 0$ 时对两个参数都是严格递增的。因此，如果该条件对于一个单元格的左下角顶点 $(x_i, y_j)$ 成立，即 $\\sqrt{x_i}+\\sqrt{y_j} \\ge 2$，那么它对其余三个顶点也必然成立，因为它们的坐标更大。因此，一个单元格 $(i,j)$ 对面积有贡献，当且仅当 $\\sqrt{i\\Delta}+\\sqrt{j\\Delta} \\ge 2$。\n我们必须计算满足此条件的整数对 $(i,j)$ 的数量，其中 $i,j \\in \\{0, \\dots, 99\\}$。直接计算显示有 $N_{thick} = 1573$ 个单元格。\n估计面积为 $\\widehat{A}_1 = 1573 \\cdot (0.02)^2 = 1573 \\cdot 0.0004 = 0.6292$。\n由于 $\\widehat{A}_1 > 0$，厚度指示器为 $T_1 = 1$。\n\n**案例 2：$u_{2}(x,y)=\\sqrt{x}+\\sqrt{y}$，目标水平为 $u_{0}=2$。**\n无差异集由 $\\sqrt{x}+\\sqrt{y}=2$ 定义。函数 $u_2(x,y)$ 在 $x,y > 0$ 时是严格凹的。一个严格凹函数在任何具有非空内部的集合上都不可能为常数。从几何上看，等值集是一条严格凸的曲线。一个正方形的四个不同顶点不可能都位于这样一条曲线上。虽然某些网格点可能恰好位于这条曲线上（例如，$(1,1)$，即 $(x_{50}, y_{50})$），但没有一个网格*单元格*的所有四个顶点都位于该曲线上。因此，$N_{thick} = 0$。\n估计面积为 $\\widehat{A}_2 = 0$。\n厚度指示器为 $T_2 = 0$。\n\n**案例 3：$u_{3}(x,y)=\\min\\{x,y\\}$，目标水平为 $u_{0}=1$。**\n无差异集由 $\\min\\{x,y\\}=1$ 定义。该条件在（$x=1$ 且 $y \\ge 1$）或（$y=1$ 且 $x \\ge 1$）时成立。这个集合形成一条不可导的L形曲线。它是一个一维对象，其二维勒贝格测度为零。对网格单元格的分析表明，没有任何单元格可以在所有四个顶点上都满足该条件。对于任何单元格 $(i,j)$，如果假设其顶点满足条件，就会产生矛盾。例如，考虑一个其顶点跨越直线 $x=1$ 的单元格，即 $x_i < 1$ 且 $x_{i+1} \\ge 1$。要使条件 $\\min\\{x_i, y_j\\}=1$ 成立，我们需要 $x_i=1$ 且 $y_j \\ge 1$ 或 $y_j=1$ 且 $x_i \\ge 1$。这两者都与 $x_i < 1$ 相矛盾。对于任何其他单元格配置，都会出现类似的矛盾。因此，$N_{thick} = 0$。\n估计面积为 $\\widehat{A}_3 = 0$。\n厚度指示器为 $T_3 = 0$。\n\n**案例 4：$u_{4}(x,y)=\\min\\{1,x\\}+\\min\\{1,y\\}$，目标水平为 $u_{0}=2$。**\n条件 $u_4(x,y)=2$ 要求和中的两项都等于 $1$。这意味着 $\\min\\{1,x\\}=1$ 且 $\\min\\{1,y\\}=1$，这等价于 $x \\ge 1$ 且 $y \\ge 1$。\n这个效用函数有一个恒定的平台区。在我们的定义域 $D=[0,2]\\times[0,2]$ 内，这个区域是正方形 $[1,2]\\times[1,2]$。\n一个单元格 $(i,j)$ 对面积有贡献，如果它的所有四个顶点都位于这个正方形内。由于单调性，这等价于其左下角顶点 $(x_i, y_j)$ 位于该正方形内。条件是 $x_i \\ge 1$ 且 $y_j \\ge 1$。\n$i\\Delta \\ge 1 \\implies i \\cdot 0.02 \\ge 1 \\implies i \\ge 50$。\n$j\\Delta \\ge 1 \\implies j \\cdot 0.02 \\ge 1 \\implies j \\ge 50$。\n单元格索引 $i, j$ 的范围是从 $0$ 到 $99$。因此，我们需要计算 $i \\in [50, 99]$ 且 $j \\in [50, 99]$ 的单元格数量。$i$ 的取值数量为 $99 - 50 + 1 = 50$，对于 $j$ 也是如此。\n$N_{thick} = 50 \\times 50 = 2500$。\n估计面积为 $\\widehat{A}_4 = 2500 \\cdot (0.02)^2 = 2500 \\cdot 0.0004 = 1.0$。\n由于 $\\widehat{A}_4 > 0$，厚度指示器为 $T_4 = 1$。\n\n总之，四个案例计算出的配对 $(\\widehat{A}, T)$ 如下：\n1. $(0.6292, 1)$\n2. $(0.0, 0)$\n3. $(0.0, 0)$\n4. $(1.0, 1)$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the estimated area (A_hat) and thickness indicator (T) for\n    indifference sets of four different utility functions on a specified grid.\n    \"\"\"\n    # Define grid parameters\n    delta = 0.02\n    domain_max = 2.0\n    num_points = int(domain_max / delta) + 1\n\n    # Create grid coordinates. Use `indexing='ij'` for intuitive matrix representation\n    # where U[i, j] corresponds to u(x[i], y[j]).\n    x = np.linspace(0, domain_max, num_points)\n    y = np.linspace(0, domain_max, num_points)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # Define the four utility functions using numpy for vectorization\n    def u1(x, y):\n        # Using np.sqrt ensures it's applied element-wise to arrays\n        return np.minimum(np.sqrt(x) + np.sqrt(y), 2.0)\n    \n    def u2(x, y):\n        return np.sqrt(x) + np.sqrt(y)\n\n    def u3(x, y):\n        return np.minimum(x, y)\n\n    def u4(x, y):\n        # Satiation at 1 for each good\n        return np.minimum(1.0, x) + np.minimum(1.0, y)\n\n    # Define the test cases as a list of (function, target_utility) tuples\n    test_cases = [\n        (u1, 2.0),\n        (u2, 2.0),\n        (u3, 1.0),\n        (u4, 2.0)\n    ]\n    \n    results = []\n    \n    # Process each test case\n    for u_func, u0 in test_cases:\n        # Evaluate the utility function on the entire grid\n        U = u_func(xx, yy)\n        \n        # Identify \"thick\" cells. A cell is thick if the utility at all four\n        # corners equals the target utility u0.\n        # We perform an element-wise check for each of the four corners of all cells.\n        \n        # U[:-1, :-1] -> values at bottom-left corners (i, j)\n        # U[1:, :-1]  -> values at bottom-right corners (i+1, j)\n        # U[:-1, 1:]  -> values at top-left corners (i, j+1)\n        # U[1:, 1:]   -> values at top-right corners (i+1, j+1)\n        \n        is_thick_cell = (\n            (U[:-1, :-1] == u0) &\n            (U[1:, :-1] == u0) &\n            (U[:-1, 1:] == u0) &\n            (U[1:, 1:] == u0)\n        )\n        \n        # Count the number of thick cells\n        num_thick_cells = np.sum(is_thick_cell)\n        \n        # Calculate the area estimator A_hat\n        area_hat = num_thick_cells * (delta**2)\n        \n        # Determine the thickness indicator T\n        T = 1 if area_hat > 0 else 0\n        \n        # Append formatted results to the list\n        results.append(f\"{area_hat:.6f}\")\n        results.append(str(T))\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}