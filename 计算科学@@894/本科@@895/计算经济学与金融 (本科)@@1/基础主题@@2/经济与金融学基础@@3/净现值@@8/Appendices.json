{"hands_on_practices": [{"introduction": "现实世界中的投资项目很少有简单、统一的现金流。本练习通过一个农场向再生农业转型的假设情景，训练您处理复杂现金流模式。您需要将该项目的现金流分解为不同的组成部分，如年金和增长型永续年金，从而练习将净现值（$NPV$）的基本原理应用于多阶段、多层面的投资机会评估中 [@problem_id:2413633]。", "id": "2413633", "problem": "一家多元化的谷物农场正在考虑从传统耕作方式永久转型为再生农业。请仅使用以下数据，评估与继续传统经营相比，该转型的增量净现值 (NPV)。除非另有说明，所有现金流均以实际价值计算，以美元 (USD) 为单位，并在每年年末发生。适用的经风险调整的恒定真实年贴现率为 $r=0.07$，采用离散复利。\n\n数据：\n- 在时间 $t=0$ 时，农场产生一笔即时转型支出 $\\$220{,}000$。\n- 在过渡期内，由于产量损失和再培训，增量净现金流（相对于继续传统经营）为负：\n  - 第 $t=1$ 年末：$-\\$90{,}000$，\n  - 第 $t=2$ 年末：$-\\$50{,}000$。\n- 从第 $t=3$ 年末起，由于价格溢价和投入成本降低，农场实现了永久性的增量净经营现金流。第 $t=3$ 年末的增量净现金流为 $\\$95{,}000$，并且此后以每年 $g=0.025$ 的恒定真实增长率永久增长。\n- 此外，从第 $t=4$ 年末开始，一直持续到第 $t=13$ 年末（共计 $10$ 笔付款），农场每年收到以实际价值计算的增量碳信用收入 $\\$12{,}000$。\n\n假设没有其他增量效应（例如，无残值，税费已包含在给定的净现金流中，且无额外营运资本需求）。计算在 $t=0$ 时该转型的增量净现值 (NPV)。以美元 (USD) 表示最终答案，并四舍五入至四位有效数字。", "solution": "所给问题是资本预算中的一个标准练习，这是计算金融学中的一个主题。该问题阐述清晰，内部逻辑一致，并包含了得出唯一解所需的所有信息。我们将开始计算净现值 (NPV)。\n\n一项投资的净现值 (NPV) 是其增量现金流以指定贴现率折现后的现值之和。对于离散的、期末现金流，其公式为：\n$$\n\\text{NPV} = \\sum_{t=0}^{\\infty} \\frac{CF_t}{(1+r)^t}\n$$\n其中 $CF_t$ 代表第 $t$ 年末的净现金流，$r$ 是恒定的真实年贴现率，给定为 $r=0.07$。分析在时间 $t=0$ 进行。\n\n该项目的增量现金流可以分为四个不同的组成部分进行分析：\n1.  $t=0$ 时的初始投资支出。\n2.  第 $t=1$ 年和 $t=2$ 年的过渡期净现金流。\n3.  从第 $t=3$ 年开始的增长型永续经营现金流。\n4.  从第 $t=4$ 年到第 $t=13$ 年的有限期碳信用收入年金。\n\n我们将分别计算每个组成部分的现值，然后将它们相加得到总 NPV。\n\n组成部分 1：初始支出\n问题陈述了一笔 $220,000$ 的即时转型支出。这是一笔在 $t=0$ 时的现金流出，因此 $CF_0 = -220,000$。其现值就是其本身：\n$$\nPV_0 = -220,000\n$$\n\n组成部分 2：过渡期现金流\n项目在最初两年产生净现金流出：$CF_1 = -90,000$ 和 $CF_2 = -50,000$。这两笔现金流的现值是通过将每笔折现到 $t=0$ 来计算的：\n$$\nPV_{trans} = \\frac{CF_1}{(1+r)^1} + \\frac{CF_2}{(1+r)^2} = \\frac{-90,000}{1+0.07} + \\frac{-50,000}{(1+0.07)^2}\n$$\n\n组成部分 3：增长型永续经营现金流\n从第 $t=3$ 年起，该项目产生一笔永续的经营现金流。在 $t=3$ 时的第一笔现金流是 $CF_{op,3} = 95,000$，之后以每年 $g=0.025$ 的恒定增长率增长。增长型永续年金的现值可以在第一笔现金流发生前一期进行计算。因此，我们首先计算这笔现金流在 $t=2$ 时的价值：\n$$\nV_{op, t=2} = \\frac{CF_{op,3}}{r-g}\n$$\n该公式适用，因为贴现率 $r=0.07$ 大于增长率 $g=0.025$。\n为了求得在 $t=0$ 时的现值，我们必须将 $V_{op, t=2}$ 向后折现两年：\n$$\nPV_{op} = \\frac{V_{op, t=2}}{(1+r)^2} = \\frac{1}{(1+r)^2} \\left( \\frac{CF_{op,3}}{r-g} \\right) = \\frac{95,000}{(1+0.07)^2 (0.07 - 0.025)}\n$$\n\n组成部分 4：碳信用年金\n农场从第 $t=4$ 年末到第 $t=13$ 年末每年收到一笔 $A=12,000$ 的年金。这构成了一系列共 $N=13-4+1=10$ 笔的付款。普通年金的现值是在其第一笔付款前一期计算的。因此，我们首先计算这笔年金在 $t=3$ 时的价值：\n$$\nV_{cc, t=3} = A \\left( \\frac{1 - (1+r)^{-N}}{r} \\right) = 12,000 \\left( \\frac{1 - (1+0.07)^{-10}}{0.07} \\right)\n$$\n然后将这个在 $t=3$ 时的价值折现回 $t=0$：\n$$\nPV_{cc} = \\frac{V_{cc, t=3}}{(1+r)^3} = \\frac{1}{(1+0.07)^3} \\left[ 12,000 \\left( \\frac{1 - (1+0.07)^{-10}}{0.07} \\right) \\right]\n$$\n\n总净现值\n总 NPV 是所有组成部分现值的代数和：\n$$\n\\text{NPV} = PV_0 + PV_{trans} + PV_{op} + PV_{cc}\n$$\n代入表达式：\n$$\n\\text{NPV} = -220,000 + \\left(\\frac{-90,000}{1.07} + \\frac{-50,000}{1.07^2}\\right) + \\frac{95,000}{(1.07)^2(0.045)} + \\frac{12,000}{(1.07)^3} \\left( \\frac{1 - (1.07)^{-10}}{0.07} \\right)\n$$\n我们现在计算每一项的数值：\n$$\nPV_0 = -220,000\n$$\n$$\nPV_{trans} = -84,112.1495... - 43,671.9364... = -127,784.086...\n$$\n$$\nPV_{op} = \\frac{95,000}{1.1449 \\times 0.045} = \\frac{95,000}{0.0515205} = 1,843,941.130...\n$$\n$$\nPV_{cc} = \\frac{12,000}{1.225043...} \\left( \\frac{1 - 0.508349...}{0.07} \\right) = 9795.59... \\times 7.02358... = 68,799.801...\n$$\n将这些值相加：\n$$\n\\text{NPV} = -220,000 - 127,784.086 + 1,843,941.130 + 68,799.801 = 1,564,956.845\n$$\n问题要求最终答案四舍五入到四位有效数字。计算出的值为 $1,564,956.845$。前四位有效数字是 $1, 5, 6, 4$。第五位是 $9$，所以我们将第四位的 $4$ 向上取整为 $5$。结果值为 $1,565,000$。按要求以科学记数法表示，即为 $1.565 \\times 10^6$。", "answer": "$$\\boxed{1.565 \\times 10^{6}}$$"}, {"introduction": "确定性的现金流预测在现实中几乎不存在，因为未来充满了不确定性。本练习将带您从计算单一的 $NPV$ 点估计，进入到使用蒙特卡洛模拟进行全面风险分析的领域。通过将初始投资（$C_0$）和现金流增长率（$g$）等关键参数视为随机变量，您将学习如何生成项目 $NPV$ 的完整概率分布，从而能够进行更丰富的评估，并量化项目的预期价值与潜在风险 [@problem_id:2413588]。", "id": "2413588", "problem": "您的任务是编写一个完整、可运行的程序，使用蒙特卡洛模拟来估计一个项目在不确定性下的净现值 (NPV) 的概率分布。\n\n该项目在有限的期限内，其初始投资和现金流的恒定增长率均存在不确定性。您的程序必须模拟这些不确定参数的抽样，根据基本的贴现现金流定义为每次抽样计算得出的 NPV，然后针对一小组参数集，使用指定的统计数据来总结模拟出的 NPV 分布。\n\n假设采用以下经济模型和定义：\n- 一个项目的净现值 (NPV) 定义如下：其在时间 $t=0$ 的初始投资为 $C_0$，贴现率 $r$ 为常数，现金流增长率 $g$ 为常数，在时间 $t=1$ 的初始单期现金流为 $F_1$，以及有限期限为 $T$ 个时期，则\n$$\n\\mathrm{NPV} \\;=\\; -\\,C_0 \\;+\\; \\sum_{t=1}^{T} \\frac{F_1\\,(1+g)^{t-1}}{(1+r)^t}.\n$$\n- 初始投资 $C_0$ 为严格正值，并被建模为对数正态随机变量，$ \\ln C_0 \\sim \\mathcal{N}(\\mu_C, \\sigma_C^2)$，其参数 $(\\mu_C,\\sigma_C)$ 在每个测试用例中给出。\n- 现金流增长率 $g$ 被建模为截断正态随机变量，其下界为 $-1$（以使 $1+g \\ge 0$）且无上界，截断前的均值为 $\\mu_g$，标准差为 $\\sigma_g$；即 $g \\sim \\mathcal{N}(\\mu_g,\\sigma_g^2)$，截断于区间 $[-1,\\infty)$。\n- 贴现率 $r$ 是确定性的，并且严格大于或等于 $0$。\n- 所有利率和概率必须以小数形式表示，而不是百分比。\n\n对于下方的每个测试用例，您的程序必须：\n1. 根据上述指定的分布，使用提供的种子以确保可复现性，生成 $K$ 次关于 $(C_0,g)$ 的独立同分布抽样。\n2. 对每次抽样，使用上述定义计算相应的 $\\mathrm{NPV}$。\n3. 计算模拟出的 $\\mathrm{NPV}$ 分布的以下汇总统计量：\n   - 样本均值，\n   - 样本标准差，定义为离差平方的样本均值的平方根（即使用除数 $K$），\n   - $\\mathrm{NPV} > 0$ 的经验概率，\n   - 水平为 $\\alpha = 0.05$ 的风险价值 (VaR)，定义为经验 $\\alpha$-分位数，其计算方法为：将 $K$ 个模拟值排序，并在相邻顺序统计量之间，于分数索引 $(K-1)\\alpha$ 处进行线性插值。\n4. 将这四个统计量均四舍五入到 $4$ 位小数。\n\n蒙特卡洛配置和可复现性要求：\n- 每个测试用例使用 $K = 200000$ 次模拟抽样。\n- 每个测试用例使用指定的种子。如果一个伪随机数生成器对每个独立流需要一个单独的种子，则对该测试用例的所有随机抽样均使用提供的种子。\n\n测试套件：\n- 测试用例 $1$（正常路径）：\n  - 期限 $T = 10$，\n  - 贴现率 $r = 0.08$，\n  - $t=1$ 时的单期现金流：$F_1 = 100$，\n  - 对数正态分布参数：$\\mu_C = \\ln(850)$, $\\sigma_C = 0.1$，\n  - $g$ 的截断正态分布参数：$\\mu_g = 0.03$, $\\sigma_g = 0.05$，\n  - 种子 $s_1 = 13579$。\n- 测试用例 $2$（单周期和零贴现率的边界条件）：\n  - 期限 $T = 1$，\n  - 贴现率 $r = 0$，\n  - $t=1$ 时的单期现金流：$F_1 = 100$，\n  - 对数正态分布参数：$\\mu_C = \\ln(100)$, $\\sigma_C = 0$，\n  - $g$ 的截断正态分布参数：$\\mu_g = 0$, $\\sigma_g = 0.1$，\n  - 种子 $s_2 = 24680$。\n- 测试用例 $3$（高贴现率，长期限）：\n  - 期限 $T = 20$，\n  - 贴现率 $r = 0.20$，\n  - $t=1$ 时的单期现金流：$F_1 = 80$，\n  - 对数正态分布参数：$\\mu_C = \\ln(500)$, $\\sigma_C = 0.2$，\n  - $g$ 的截断正态分布参数：$\\mu_g = 0.04$, $\\sigma_g = 0.02$，\n  - 种子 $s_3 = 11223$。\n- 测试用例 $4$（负平均增长，大离差）：\n  - 期限 $T = 5$，\n  - 贴现率 $r = 0.05$，\n  - $t=1$ 时的单期现金流：$F_1 = 120$，\n  - 对数正态分布参数：$\\mu_C = \\ln(300)$, $\\sigma_C = 0.5$，\n  - $g$ 的截断正态分布参数：$\\mu_g = -0.20$, $\\sigma_g = 0.30$，\n  - 种子 $s_4 = 33445$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是列表 $[\\text{均值}, \\text{标准差}, \\text{正值概率}, \\text{VaR}_{0.05}]$，每个值都四舍五入到 $4$ 位小数。因此，总体输出必须是按测试用例顺序排列的列表的列表。例如，输出必须看起来像\n\"[ [m1,s1,p1,v1], [m2,s2,p2,v2], [m3,s3,p3,v3], [m4,s4,p4,v4] ]\"\n但不含逗号后的空格且无额外文本。具体来说，您的程序必须严格按照以下格式打印单行：\n\"[[m1,s1,p1,v1],[m2,s2,p2,v2],[m3,s3,p3,v3],[m4,s4,p4,v4]]\"。", "solution": "该问题是有效的，因为它在科学上基于标准的金融经济学理论，问题陈述清晰且提供了所有必要信息，并且其表述是客观的。任务是通过蒙特卡洛模拟来估计项目净现值 ($NPV$) 的概率分布，这是计算金融学中的一种标准技术。\n\n解决方案的实施是基于所提供模型进行数值模拟。该方法的核心是为不确定参数生成大量随机情景，然后为每个情景计算项目的 $NPV$。由此得到的 $NPV$ 值集合可作为来自真实底层 $NPV$ 分布的经验样本，我们可以从中计算所需的汇总统计量。\n\n净现值定义为：\n$$\n\\mathrm{NPV} \\;=\\; -\\,C_0 \\;+\\; \\sum_{t=1}^{T} \\frac{F_1\\,(1+g)^{t-1}}{(1+r)^t}\n$$\n参数 $T$、$r$ 和 $F_1$ 对每个测试用例都是确定性的。初始成本 $C_0$ 和增长率 $g$ 是随机变量。\n\n每个测试用例的模拟包括以下步骤：\n1.  **随机变量生成**：使用指定的种子初始化一个随机数生成器以确保可复现性。我们为 $C_0$ 和 $g$ 生成 $K=200000$ 次独立抽样。\n    -   初始投资 $C_0$ 服从对数正态分布，即 $\\ln C_0 \\sim \\mathcal{N}(\\mu_C, \\sigma_C^2)$。我们可以生成 $K$ 个标准正态变量 $Z_i \\sim \\mathcal{N}(0, 1)$（其中 $i=1, \\dots, K$），然后将每次 $C_0$ 的抽样计算为 $C_{0,i} = \\exp(\\mu_C + \\sigma_C Z_i)$。这可以直接使用 `numpy.random.Generator.lognormal` 函数完成，该函数将底层正态分布的均值 $\\mu_C$ 和标准差 $\\sigma_C$ 作为参数。\n    -   增长率 $g$ 从一个截断于区间 $[-1, \\infty)$ 的正态分布 $\\mathcal{N}(\\mu_g, \\sigma_g^2)$ 中抽取。这确保了现金流的增长率不低于 $-100\\%$。为此，我们使用 `scipy.stats.truncnorm` 类。底层标准正态变量的标准边界 $a$ 和 $b$ 计算为 $a = (-1 - \\mu_g) / \\sigma_g$ 和 $b = \\infty$。然后，使用指定的位置参数 $\\mu_g$ 和尺度参数 $\\sigma_g$ 抽取 $K$ 个随机变量。\n\n2.  **NPV 计算**：为了高效地为所有 $K$ 个情景计算 $NPV$，我们采用向量化操作。设 $\\mathbf{g}$ 为增长率的 $K$ 次抽样的向量，$\\mathbf{C_0}$ 为初始成本的 $K$ 次抽样的向量。计算每个情景的未来现金流现值 ($PVCF$)。求和项 $\\sum_{t=1}^{T} \\dots$ 对所有抽样同时进行计算。\n    -   创建一个时间向量 $\\mathbf{t} = [1, 2, \\dots, T]$。\n    -   计算一个贴现因子向量 $\\mathbf{d} = [(1+r)^{-1}, (1+r)^{-2}, \\dots, (1+r)^{-T}]$。\n    -   构建一个大小为 $K \\times T$ 的增长因子矩阵 $\\mathbf{G}$，其中每个元素 $G_{i,t} = (1+g_i)^{t-1}$。这是通过将形状为 $(K,)$ 的向量 $\\mathbf{g}$ 和形状为 $(T,)$ 的时间索引向量进行广播，以形成一个形状为 $(K, T)$ 的矩阵来实现的。\n    -   每次抽样 $i$ 的现金流现值是通过对贴现后的现金流按时间求和来计算的。所有 $K$ 次抽样的 $PVCF$ 向量计算如下：\n        $$ \\mathbf{PVCF}_{i} = \\sum_{t=1}^{T} F_1 \\cdot (1+g_i)^{t-1} \\cdot (1+r)^{-t} $$\n        在 `NumPy` 中，这可以通过广播一次性高效地为所有抽样进行计算：`(F_1 * growth_factors * discount_factors).sum(axis=1)`。\n    -   最后，通过逐元素减去初始成本得到 $NPV$ 值的向量：$\\mathbf{NPV} = \\mathbf{PVCF} - \\mathbf{C_0}$。\n\n3.  **统计分析**：从得到的包含 $K$ 个模拟值的向量 $\\mathbf{NPV}$ 中，计算以下统计量：\n    -   **均值**：样本均值，$\\frac{1}{K}\\sum_{i=1}^{K} \\mathrm{NPV}_i$，使用 `numpy.mean()` 计算。\n    -   **标准差**：使用 $K$ 作为除数的样本标准差，$\\sqrt{\\frac{1}{K}\\sum_{i=1}^{K} (\\mathrm{NPV}_i - \\overline{\\mathrm{NPV}})^2}$，使用 `numpy.std()` 并采用默认的 `ddof=0` 进行计算。\n    -   **NPV 为正的概率**：$\\mathrm{NPV}_i > 0$ 的抽样所占的比例，计算方式为 `numpy.mean(NPV_draws > 0)`。\n    -   **风险价值 (VaR)**：$5\\%$ 的 VaR 是模拟出的 $NPV$ 分布的经验 $0.05$-分位数。其计算方法是：对 $\\mathbf{NPV}$ 向量进行排序，并使用线性插值法找到在分数索引 $(K-1) \\times 0.05$ 处的值。`numpy.quantile()` 函数（当 $q=0.05$ 时）实现了这一定义。\n\n4.  **格式化**：将每个测试用例计算出的四个统计量四舍五入到 $4$ 位小数，并格式化为指定的无空格的列表的列表的字符串表示形式。\n\n这种结构化方法确保了正确性、可复现性和计算效率。该实现正确处理了边界条件，例如测试用例 $2$ 中的确定性情况，其中 $T=1$，$r=0$ 和 $\\sigma_C=0$ 必须产生 $0$ 的 $NPV$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import truncnorm\n\ndef calculate_npv_stats(T, r, F1, mu_C, sigma_C, mu_g, sigma_g, K, seed):\n    \"\"\"\n    Simulates NPV distribution and computes summary statistics for one test case.\n    \"\"\"\n    # 1. Set up random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # 2. Generate K random draws for the stochastic variables C0 and g.\n    # C0 is drawn from a lognormal distribution.\n    if sigma_C > 0:\n        C0_draws = rng.lognormal(mean=mu_C, sigma=sigma_C, size=K)\n    else:  # Deterministic case if sigma_C is 0\n        C0_draws = np.full(K, np.exp(mu_C), dtype=np.float64)\n\n    # g is drawn from a truncated normal distribution.\n    if sigma_g > 0:\n        a_std = (-1.0 - mu_g) / sigma_g\n        b_std = np.inf\n        # Use random_state for reproducibility with SciPy\n        g_draws = truncnorm.rvs(a=a_std, b=b_std, loc=mu_g, scale=sigma_g, size=K, random_state=rng)\n    else: # Deterministic case if sigma_g is 0\n        g_draws = np.full(K, mu_g, dtype=np.float64)\n\n    # 3. Calculate NPV for each of the K draws using vectorization.\n    # Time vector t = [1, 2, ..., T]\n    t = np.arange(1, T + 1, dtype=np.float64)\n\n    # Discount factors for each time period\n    discount_factors = (1.0 + r) ** -t\n\n    # Growth factors for each draw over time (K x T matrix)\n    # This uses broadcasting: g_draws (K,) and t (T,) -> (K, T)\n    growth_factors = (1.0 + g_draws[:, np.newaxis]) ** (t - 1)\n\n    # Present Value of Cash Flows for each draw (sum over time)\n    # F1 * growth_factors * discount_factors also uses broadcasting\n    PVCF_draws = (F1 * growth_factors * discount_factors).sum(axis=1)\n\n    # Net Present Value for each draw\n    NPV_draws = PVCF_draws - C0_draws\n\n    # 4. Compute the required summary statistics.\n    mean_npv = np.mean(NPV_draws)\n    \n    # Standard deviation with divisor K (ddof=0 is the default)\n    std_npv = np.std(NPV_draws)\n    \n    # Empirical probability that NPV > 0\n    prob_positive = np.mean(NPV_draws > 0)\n    \n    # Value-at-Risk at alpha=0.05\n    # np.quantile uses linear interpolation by default at index (K-1)*alpha\n    var_05 = np.quantile(NPV_draws, 0.05)\n\n    # 5. Round results to 4 decimal places.\n    return [\n        round(mean_npv, 4),\n        round(std_npv, 4),\n        round(prob_positive, 4),\n        round(var_05, 4)\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Monte Carlo simulation configuration\n    K = 200000\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T, r, F1, mu_C, sigma_C, mu_g, sigma_g, seed\n        (10, 0.08, 100, np.log(850), 0.1, 0.03, 0.05, 13579),\n        (1, 0.00, 100, np.log(100), 0.0, 0.0, 0.1, 24680),\n        (20, 0.20, 80, np.log(500), 0.2, 0.04, 0.02, 11223),\n        (5, 0.05, 120, np.log(300), 0.5, -0.20, 0.30, 33445)\n    ]\n\n    results = []\n    for case in test_cases:\n        T, r, F1, mu_C, sigma_C, mu_g, sigma_g, seed = case\n        result_list = calculate_npv_stats(T, r, F1, mu_C, sigma_C, mu_g, sigma_g, K, seed)\n        results.append(result_list)\n\n    # Final print statement in the exact required format.\n    # Example: [[m1,s1,p1,v1],[m2,s2,p2,v2]]\n    # Using str().replace() is a robust way to get the format without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"}, {"introduction": "企业通常面临资源限制，无法投资于所有看似有利可图的项目。本练习将决策重点从评估单个项目，提升到在预算约束下选择最优的*项目组合*。您将学习如何将这一资本预算问题构建为一个经典的0-1整数规划模型（也称为“背包问题”），并利用优化方法来确定哪个项目组合能够为公司创造最大的总净现值 [@problem_id:2413667]。", "id": "2413667", "problem": "您将处理一个资本预算选择问题，该问题必须基于净现值 (NPV) 表达为一个二元（0-1）整数规划模型。现有 $n$ 个候选项目，索引为 $i \\in \\{1,2,\\ldots,n\\}$。项目 $i$ 有一个确定性现金流 $(c_{i,0},c_{i,1},\\ldots,c_{i,T_i})$，其中 $c_{i,0} < 0$ 代表在时间 $t=0$ 的初始投资，$c_{i,t}$（对于 $t \\ge 1$）发生在第 $t$ 期期末。存在一个通用的每期贴现率 $r \\ge 0$，以小数形式表示（例如，$0.05$），以及一个单一的资本预算 $B \\ge 0$，该预算约束了在时间 $t=0$ 时的初始投资总额。定义决策变量 $x_i \\in \\{0,1\\}$，其中如果项目 $i$ 被采纳，则 $x_i=1$，否则 $x_i=0$。项目 $i$ 的净现值为\n$$\n\\text{NPV}_i(r) \\equiv \\sum_{t=0}^{T_i} \\frac{c_{i,t}}{(1+r)^t}.\n$$\n令 $I_i \\equiv -c_{i,0} > 0$ 表示项目 $i$ 的初始投资。构建以下 0-1 整数规划：\n$$\n\\max_{x_1,\\ldots,x_n} \\ \\sum_{i=1}^n \\text{NPV}_i(r)\\, x_i\n$$\n约束条件为\n$$\n\\sum_{i=1}^n I_i \\, x_i \\le B, \\quad x_i \\in \\{0,1\\} \\ \\text{for all } i.\n$$\n编写一个程序，对于下方的每个测试用例，计算上述整数规划的最优目标值，即在所有可行项目组合中的最大总净现值。所有利率必须作为小数处理。要求的输出是实数。将每个最优总净现值四舍五入到 $4$ 位小数。\n\n测试套件：\n- 测试用例 $1$：\n  - 贴现率 $r = 0.08$。\n  - 预算 $B = 100$。\n  - 项目现金流 $(c_{i,0},c_{i,1},c_{i,2})$：\n    - 项目 $1$：$(-40, 20, 30)$。\n    - 项目 $2$：$(-50, 0, 60)$。\n    - 项目 $3$：$(-30, 15, 18)$。\n    - 项目 $4$：$(-20, 8, 15)$。\n- 测试用例 $2$：\n  - 贴现率 $r = 0.05$。\n  - 预算 $B = 0$。\n  - 项目现金流 $(c_{i,0},c_{i,1},c_{i,2})$：\n    - 项目 $1$：$(-10, 6, 6)$。\n    - 项目 $2$：$(-8, 4, 5)$。\n    - 项目 $3$：$(-5, 2, 3)$。\n- 测试用例 $3$：\n  - 贴现率 $r = 0.05$。\n  - 预算 $B = 30$。\n  - 项目现金流 $(c_{i,0},c_{i,1},c_{i,2})$：\n    - 项目 $1$：$(-10, 6, 6)$。\n    - 项目 $2$：$(-15, 9, 9)$。\n    - 项目 $3$：$(-5, 3, 3)$。\n- 测试用例 $4$：\n  - 贴现率 $r = 0.07$。\n  - 预算 $B = 22$。\n  - 项目现金流 $(c_{i,0},c_{i,1},c_{i,2})$：\n    - 项目 $1$：$(-10, 4, 4)$。\n    - 项目 $2$：$(-12, 5, 5)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[a,b,c,d]$），列表中的每个条目是按上述顺序列出的相应测试用例的四舍五入后的最优总净现值。每个数字必须精确到 $4$ 位小数，并以小数形式书写（例如，$0.0000$）。", "solution": "首先将对问题的科学性和逻辑一致性进行验证。\n\n**问题验证**\n\n**第一步：提取已知信息**\n\n- **决策变量**：$x_i \\in \\{0,1\\}$，对于 $i \\in \\{1, 2, \\ldots, n\\}$，其中如果项目 $i$ 被选择，则 $x_i=1$，否则 $x_i=0$。\n- **项目数据**：对于每个项目 $i$，有一个确定性现金流 $(c_{i,0}, c_{i,1}, \\ldots, c_{i,T_i})$。\n- **初始投资**：$I_i \\equiv -c_{i,0} > 0$。\n- **贴现率**：一个通用的每期利率 $r \\ge 0$。\n- **预算约束**：一个单一的资本预算 $B \\ge 0$。\n- **净现值 (NPV)**：项目 $i$ 的 NPV 定义为 $\\text{NPV}_i(r) \\equiv \\sum_{t=0}^{T_i} \\frac{c_{i,t}}{(1+r)^t}$。\n- **目标函数**：最大化总净现值，$\\max_{x_1,\\ldots,x_n} \\sum_{i=1}^n \\text{NPV}_i(r)\\, x_i$。\n- **约束条件**：总初始投资不得超过预算，$\\sum_{i=1}^n I_i \\, x_i \\le B$。\n- **测试用例**：提供了四个具体的问题实例，每个实例都有贴现率 $r$、预算 $B$ 和一组项目及其现金流。\n- **输出要求**：每个测试用例的最优目标值，四舍五入到 $4$ 位小数。\n\n**第二步：使用提取的已知信息进行验证**\n\n1.  **科学依据**：该问题是公司金融和运筹学中，在单期资本约束下进行资本预算的标准模型。净现值概念是金融学中用于评估跨期投资价值的基本原则。将其构建为二元整数规划是一种规范的做法。该问题在科学上是合理的。\n\n2.  **良构性**：该问题是组合优化中一个著名问题——0/1 背包问题的一个实例。对于每个测试用例中给定的参数（有限的项目集、明确的预算和确定性现金流），存在且可以确定一个唯一的最优解。该问题是良构的。\n\n3.  **客观性**：问题陈述由精确的数学定义和客观数据构成。没有主观、模糊或基于观点的陈述。\n\n4.  **完整性**：为每个测试用例提供了所有必要信息（贴现率、预算、现金流）。该模型是自洽的，不需要外部信息。\n\n**第三步：结论与行动**\n\n问题有效。这是一个源自计算金融学的清晰、自洽且科学合理的问题。将提供一个解决方案。\n\n**求解方法**\n\n所呈现的是一个经典的资本预算选择问题，可以建模为一个二元整数规划，具体来说是 0/1 背包问题。任务是选择一个项目组合，在满足预算约束的前提下，最大化总净现值 (NPV)。\n\n对于每个项目 $i$，我们有一个“价值”，即其 $\\text{NPV}_i$，和一个“重量”，即其初始投资 $I_i$。预算 $B$ 充当背包的“容量”。其数学模型为：\n$$\n\\max_{x} \\ \\sum_{i=1}^n \\text{NPV}_i(r)\\, x_i\n$$\n约束条件为\n$$\n\\sum_{i=1}^n I_i \\, x_i \\le B, \\quad x_i \\in \\{0,1\\} \\ \\text{for all } i \\in \\{1, \\ldots, n\\}.\n$$\n此类问题被归类为混合整数线性规划（MILP），因为决策变量被限制为整数值（在本例中为二元）。虽然该问题通常是 NP-难的，但所提供的测试用例项目数量很少（$n \\le 4$），使其在计算上是可行的。一个通用的 MILP 求解器是完成此项任务最鲁棒和合适的工具。\n\n我们将使用 SciPy 库中的 `scipy.optimize.milp` 函数。该函数设计用于求解最小化问题。为了解决我们的最大化问题，我们将最小化目标函数的相反数：\n$$\n\\min_{x} \\ \\sum_{i=1}^n (-\\text{NPV}_i(r))\\, x_i\n$$\n每个测试用例的步骤如下：\n\n1.  **参数计算**：对于每个项目 $i$，使用以下公式计算其初始投资 $I_i = -c_{i,0}$ 和其净现值 $\\text{NPV}_i(r)$：\n    $$\n    \\text{NPV}_i(r) = \\sum_{t=0}^{T_i} \\frac{c_{i,t}}{(1+r)^t}\n    $$\n2.  **求解器配置**：为 `scipy.optimize.milp` 配置输入：\n    -   **目标系数 (`c`)**：一个向量，其中第 $i$ 个元素是 $-\\text{NPV}_i(r)$。\n    -   **约束条件**：一个单一的线性不等式约束，$\\sum_{i=1}^n I_i x_i \\le B$。这由一个约束矩阵 $A = [[I_1, I_2, \\ldots, I_n]]$ 和一个上界 $B$ 来表示。\n    -   **变量边界**：每个变量 $x_i$ 的界限在 $0$ 和 $1$ 之间。\n    -   **整数性**：所有变量 $x_i$ 都被指定为整数。\n3.  **执行与结果解释**：求解器将找到最优向量 $x^*$，它最小化负的总 NPV。求解器的结果 `res.fun` 是最小目标值。因此，我们原始问题的最大总 NPV 是 `-res.fun`。\n4.  **最终格式化**：按要求将每个测试用例计算出的最优总 NPV 四舍五入到 $4$ 位小数。在所有项目 NPV 均为负值，或预算为零而投资成本为正的情况下，最优操作是不选择任何项目，从而得到总 NPV 为 $0$。\n\n这种系统化的方法确保了正确性，并遵循了计算优化的标准实践。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import milp, LinearConstraint, Bounds\n\ndef solve():\n    \"\"\"\n    Solves a series of capital budgeting problems formulated as 0/1 knapsack problems.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"r\": 0.08,\n            \"B\": 100,\n            \"projects\": [\n                (-40, 20, 30),\n                (-50, 0, 60),\n                (-30, 15, 18),\n                (-20, 8, 15),\n            ]\n        },\n        {\n            \"r\": 0.05,\n            \"B\": 0,\n            \"projects\": [\n                (-10, 6, 6),\n                (-8, 4, 5),\n                (-5, 2, 3),\n            ]\n        },\n        {\n            \"r\": 0.05,\n            \"B\": 30,\n            \"projects\": [\n                (-10, 6, 6),\n                (-15, 9, 9),\n                (-5, 3, 3),\n            ]\n        },\n        {\n            \"r\": 0.07,\n            \"B\": 22,\n            \"projects\": [\n                (-10, 4, 4),\n                (-12, 5, 5),\n            ]\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        r = case[\"r\"]\n        B = case[\"B\"]\n        projects_cash_flows = case[\"projects\"]\n        \n        n_projects = len(projects_cash_flows)\n        \n        if n_projects == 0:\n            results.append(0.0)\n            continue\n\n        npvs = []\n        investments = []\n\n        for cash_flows in projects_cash_flows:\n            # Calculate initial investment\n            investment = -cash_flows[0]\n            investments.append(investment)\n            \n            # Calculate NPV\n            current_npv = 0.0\n            for t, cash_flow in enumerate(cash_flows):\n                current_npv += cash_flow / ((1 + r)**t)\n            npvs.append(current_npv)\n\n        # The scipy.optimize.milp solver minimizes an objective function.\n        # To maximize sum(npv * x), we minimize sum(-npv * x).\n        c = -np.array(npvs)\n\n        # The constraint is sum(investment * x) <= B.\n        A = np.array(investments).reshape(1, n_projects)\n        # The constraint is one-sided: <= B. We set lower bound to -inf.\n        b_l = -np.inf \n        b_u = B\n        constraints = LinearConstraint(A, b_l, b_u)\n\n        # The variables x_i are binary (0 or 1).\n        integrality = np.ones(n_projects)\n        bounds = Bounds(lb=0, ub=1)\n\n        # Solve the mixed-integer linear program\n        res = milp(c=c, constraints=constraints, integrality=integrality, bounds=bounds)\n\n        optimal_total_npv = 0.0\n        if res.success:\n            # The result from the solver is the minimum of the negative NPVs.\n            # To get the maximum NPV, we negate the result.\n            optimal_total_npv = -res.fun\n\n        # A result of -0.0 can occur, ensuring it is formatted as 0.0000\n        if abs(optimal_total_npv) < 1e-9:\n             optimal_total_npv = 0.0\n             \n        results.append(f\"{optimal_total_npv:.4f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}