{"hands_on_practices": [{"introduction": "永续年金的理念不仅局限于金融领域，它本质上是求解无限几何级数的强大数学工具。本练习旨在通过一个物理场景拓宽你对该模型的理解。我们将使用永续年金的框架来估算一个太阳能发电场在其整个生命周期内的总能量输出，其中每年的能量产出因电池板性能的物理衰减而减少 [@problem_id:2371754]。这个练习将帮助你认识到，核心的数学原理可以应用于截然不同的领域，从而加深对概念本质的掌握。", "id": "2371754", "problem": "一个公用事业规模的太阳能光伏设施的铭牌容量为 $100$ 兆瓦。其容量因子为 $0.25$，一个非闰年有 $8760$ 小时。光伏组件每年经历 $0.5\\%$ 的恒定比例衰减，这种衰减导致其后每年的发电量相较于前一年在乘法上减少。假设该设施在这些条件下无限期运行，没有容量增加、退役、维护冲击或外部约束。\n\n使用一个永续年金式模型，在该模型中，年度能量输出流在所述的衰减过程中无限持续，确定未来所有年份产生的累计总能量。以兆瓦时 (MWh) 为单位表示您的答案，并将结果四舍五入到四位有效数字。", "solution": "首先必须验证问题陈述的科学合理性、适定性和客观性。\n\n**步骤 1：提取已知条件**\n- 铭牌容量: $100$ 兆瓦\n- 容量因子: $0.25$\n- 非闰年小时数: $8760$\n- 比例衰减率: 每年 $0.5$ 百分比\n- 衰减效应: 后续每年的产能量相对于前一年发生乘法性减少。\n- 运营时限: 无限期。\n- 模型类型: 永续年金式模型。\n- 要求输出: 以兆瓦时 (MWh) 为单位的总累计能量，四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据。铭牌容量、容量因子和年衰减率是电力系统工程和可再生能源金融领域的标准指标。给定的数值是现实的；$0.25$ 的容量因子对于许多地区的太阳能光伏发电是典型的，而 $0.5\\%$ 的年衰减率是现代晶硅组件的一个标准假设。该问题是适定的，它描述了一个公比的绝对值小于一的无穷几何级数，这保证了级数收敛到一个唯一的有限和。语言是客观和精确的。使用永续模型是一种理想化处理，但它被明确说明为一种模型假设，并且是估算长期累积效应的有效数学方法。因此，该问题被认定为有效。\n\n**步骤 3：结论与行动**\n问题有效。现在将推导完整解法。\n\n该问题要求计算一个经受恒定比例衰减的太阳能设施在无限时间范围内产生的总能量。这等效于求一个无穷几何级数的和。\n\n首先，我们确定第一年运营产生的能量，记为 $E_1$。能量输出是平均功率与运行时间的乘积。平均功率是铭牌容量乘以容量因子。\n\n设 $C$ 为铭牌容量，$f$ 为容量因子，$T$ 为一年中的小时数。\n第一年产生的能量由下式给出：\n$$E_1 = C \\times f \\times T$$\n代入给定值：\n$$C = 100 \\text{ MW}$$\n$$f = 0.25$$\n$$T = 8760 \\text{ h}$$\n因此，\n$$E_1 = 100 \\text{ MW} \\times 0.25 \\times 8760 \\text{ h} = 25 \\text{ MW} \\times 8760 \\text{ h} = 219000 \\text{ MWh}$$\n\n问题陈述，能量输出每年经历 $d = 0.5\\%$ 的恒定比例衰减。这意味着任何给定年份产生的能量都是前一年产生能量的一个恒定分数。设这个恒定的乘法因子为 $r$。\n$$d = 0.5\\% = 0.005$$\n因子 $r$ 为：\n$$r = 1 - d = 1 - 0.005 = 0.995$$\n\n年度产能量流形成一个几何序列：\n- 第 1 年: $E_1 = 219000 \\text{ MWh}$\n- 第 2 年: $E_2 = E_1 \\times r$\n- 第 3 年: $E_3 = E_2 \\times r = E_1 \\times r^2$\n- 第 $n$ 年: $E_n = E_1 \\times r^{n-1}$\n\n未来所有年份产生的累计总能量 $E_{\\text{total}}$ 是这个无穷几何级数的和：\n$$E_{\\text{total}} = \\sum_{n=1}^{\\infty} E_n = \\sum_{n=1}^{\\infty} E_1 \\times r^{n-1}$$\n无穷几何级数的求和公式为：\n$$S = \\frac{a}{1-r}$$\n其中 $a$ 是首项，$r$ 是公比。此公式仅在 $|r| < 1$ 时有效。在本问题中，首项是 $a = E_1$，公比是 $r = 0.995$。由于 $|0.995| < 1$，级数收敛，我们可以应用该公式。\n\n$$E_{\\text{total}} = \\frac{E_1}{1-r}$$\n代入 $E_1$ 和 $r$ 的值：\n$$E_{\\text{total}} = \\frac{219000}{1 - 0.995} = \\frac{219000}{0.005}$$\n这等效于：\n$$E_{\\text{total}} = 219000 \\times \\frac{1}{0.005} = 219000 \\times 200$$\n$$E_{\\text{total}} = 43800000 \\text{ MWh}$$\n\n问题要求答案四舍五入到四位有效数字。计算出的值为 $43,800,000$。四位最高有效数字是 $4$、$3$、$8$ 和 $0$。为了用四位有效数字的标准科学记数法表示，我们写作：\n$$E_{\\text{total}} = 4.380 \\times 10^7$$\n这是该设施在指定的衰减模型下，在其无限运营寿命内产生的累计总能量。", "answer": "$$\\boxed{4.380 \\times 10^7}$$"}, {"introduction": "在现实世界中，资产的现金流很少保持恒定不变，它们通常会随时间增长并且充满不确定性。这个练习引入了一种更复杂的永续年金模型，其支付遵循带漂移的随机游走过程，即平均而言，现金流会算术增长。要为这种资产定价，我们必须先计算出未来每个时期的期望现金流 $\\mathbb{E}[C_{t}]$，然后将这个期望流折现到当前 [@problem_id:2371756]。这项实践是连接简单确定性模型与复杂随机模型的桥梁，它能训练你如何在现值框架下处理期望值，并推导出增长型永续年金的估值公式。", "id": "2371756", "problem": "一个永续年金提供了一系列随机的年度现金支付 $\\{C_{t}\\}_{t \\geq 1}$，其初始水平 $C_{0}$ 在时间 $t=0$ 时观测到。现金流过程遵循一个带漂移的随机游走：\n$$\nC_{t+1} \\;=\\; C_{t} \\;+\\; \\mu \\;+\\; \\varepsilon_{t+1}, \\quad t \\geq 0,\n$$\n其中 $\\{\\varepsilon_{t}\\}$ 是独立同分布 (i.i.d.) 的冲击，满足 $\\mathbb{E}[\\varepsilon_{t}] = 0$ 和有限方差，而 $\\mu$ 是一个恒定的漂移项。假设投资者是风险中性的，且每期的随机贴现因子是确定性的，由 $(1+r)^{-1}$ 给出，其中 $r>0$ 是一个恒定的贴现率。该资产在时间 $0$ 的价格 $P_{0}$ 等于未来现金流的预期贴现总和：\n$$\nP_{0} \\;=\\; \\sum_{t=1}^{\\infty} \\frac{\\mathbb{E}[C_{t}]}{(1+r)^{t}}.\n$$\n假设 $P_{0} = 120$，$C_{0} = 5$ 且 $\\mu = 0.2$，所有量都以相同的货币单位表示，时间单位为年。在这些假设下，求出能使观测价格合理化的隐含贴现率 $r$。请将最终答案表示为一个小数（不带百分号），并四舍五入到 $4$ 位有效数字。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件\n-   现金流过程：$C_{t+1} = C_{t} + \\mu + \\varepsilon_{t+1}$，对于 $t \\geq 0$。\n-   初始现金流水平：$C_{0}$。\n-   冲击：$\\{\\varepsilon_{t}\\}$ 是独立同分布的，且 $\\mathbb{E}[\\varepsilon_{t}] = 0$。\n-   漂移：$\\mu$ 是一个常数。\n-   贴现率：$r > 0$ 是一个常数。\n-   定价公式：$P_{0} = \\sum_{t=1}^{\\infty} \\frac{\\mathbb{E}[C_{t}]}{(1+r)^{t}}$。\n-   数值：$P_{0} = 120$，$C_{0} = 5$，$\\mu = 0.2$。\n\n步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题使用了现金流的标准随机游走模型和风险中性定价框架，这两者都是金融经济学中的基本概念。该模型具有科学合理性。\n-   **适定性**：该问题提供了足够的信息来确定未知变量 $r$。定价公式涉及一个无穷级数，当 $r > 0$（问题中已指明此条件）时，其收敛性得到保证。该结构导出一个可解的代数方程。\n-   **客观性**：该问题以精确的、量化的术语陈述，没有任何主观或模棱两可的语言。\n\n步骤 3：结论与行动\n该问题是有效的，因为它具有科学依据、适定性和客观性。将推导求解过程。\n\n资产在时间 $0$ 的价格 $P_{0}$ 是未来预期现金流的现值，以恒定贴现率 $r$ 进行贴现。公式如下：\n$$\nP_{0} = \\sum_{t=1}^{\\infty} \\frac{\\mathbb{E}[C_{t}]}{(1+r)^{t}}\n$$\n首先，我们必须确定在时间 $t$ 的现金流的期望值 $\\mathbb{E}[C_{t}]$。现金流过程由以下递推关系给出：\n$$\nC_{t+1} = C_{t} + \\mu + \\varepsilon_{t+1}\n$$\n基于时间 $t=0$ 的信息取条件期望，并使用迭代期望定律，我们求出期望值。对于 $t=1$：\n$$\n\\mathbb{E}[C_{1}] = \\mathbb{E}[C_{0} + \\mu + \\varepsilon_{1}]\n$$\n由于 $C_{0}$ 是在 $t=0$ 时观测到的，它是一个已知的常数。冲击 $\\varepsilon_{1}$ 的期望为零。因此：\n$$\n\\mathbb{E}[C_{1}] = C_{0} + \\mu\n$$\n对于 $t=2$：\n$$\n\\mathbb{E}[C_{2}] = \\mathbb{E}[C_{1} + \\mu + \\varepsilon_{2}] = \\mathbb{E}[C_{1}] + \\mu = (C_{0} + \\mu) + \\mu = C_{0} + 2\\mu\n$$\n通过归纳法，未来任一时间 $t \\geq 1$ 的预期现金流是一个等差数列：\n$$\n\\mathbb{E}[C_{t}] = C_{0} + t\\mu\n$$\n将此表达式代入 $P_{0}$ 的定价公式：\n$$\nP_{0} = \\sum_{t=1}^{\\infty} \\frac{C_{0} + t\\mu}{(1+r)^{t}}\n$$\n我们可以将这个求和分成两部分：\n$$\nP_{0} = C_{0} \\sum_{t=1}^{\\infty} \\left(\\frac{1}{1+r}\\right)^{t} + \\mu \\sum_{t=1}^{\\infty} t \\left(\\frac{1}{1+r}\\right)^{t}\n$$\n第一项求和是一个标准的几何级数，代表支付恒定金额 $1$ 的永续年金的现值。其值为：\n$$\n\\sum_{t=1}^{\\infty} \\left(\\frac{1}{1+r}\\right)^{t} = \\frac{1/(1+r)}{1 - 1/(1+r)} = \\frac{1}{r}\n$$\n第二项求和是一个算术-几何级数。其值可以通过考虑几何级数的导数来求得。设 $x = (1+r)^{-1}$。该求和为 $\\sum_{t=1}^{\\infty} t x^{t}$。已知此和为 $\\frac{x}{(1-x)^2}$。代入 $x = (1+r)^{-1}$：\n$$\n\\sum_{t=1}^{\\infty} t \\left(\\frac{1}{1+r}\\right)^{t} = \\frac{1/(1+r)}{\\left(1 - \\frac{1}{1+r}\\right)^{2}} = \\frac{1/(1+r)}{(r/(1+r))^{2}} = \\frac{1+r}{r^{2}}\n$$\n这是永续年金的现值，其支付额每个时期增长 $1$ 个单位，从 $t=1$ 时支付 $1$ 开始。\n结合这些结果，我们得到 $P_{0}$ 的表达式：\n$$\nP_{0} = C_{0}\\left(\\frac{1}{r}\\right) + \\mu\\left(\\frac{1+r}{r^{2}}\\right) = \\frac{C_{0}}{r} + \\frac{\\mu}{r^{2}} + \\frac{\\mu}{r} = \\frac{C_{0}+\\mu}{r} + \\frac{\\mu}{r^{2}}\n$$\n该公式代表一个等差增长永续年金的现值，其首次支付为 $\\mathbb{E}[C_1] = C_0+\\mu$，支付的增长额为 $\\mu$。\n现在，我们代入给定的数值：$P_{0}=120$，$C_{0}=5$ 和 $\\mu=0.2$。\n$$\n120 = \\frac{5 + 0.2}{r} + \\frac{0.2}{r^{2}}\n$$\n$$\n120 = \\frac{5.2}{r} + \\frac{0.2}{r^{2}}\n$$\n为了解出 $r$，我们将整个方程乘以 $r^{2}$（这是允许的，因为 $r>0$ 意味着 $r \\neq 0$）：\n$$\n120r^{2} = 5.2r + 0.2\n$$\n整理各项得到一个关于 $r$ 的二次方程：\n$$\n120r^{2} - 5.2r - 0.2 = 0\n$$\n我们使用二次公式 $r = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来解这个方程，其中 $a=120$，$b=-5.2$，$c=-0.2$。\n$$\nr = \\frac{-(-5.2) \\pm \\sqrt{(-5.2)^{2} - 4(120)(-0.2)}}{2(120)}\n$$\n$$\nr = \\frac{5.2 \\pm \\sqrt{27.04 + 96}}{240}\n$$\n$$\nr = \\frac{5.2 \\pm \\sqrt{123.04}}{240}\n$$\n$r$ 的两个潜在解是：\n$$\nr_{1} = \\frac{5.2 + \\sqrt{123.04}}{240} \\quad \\text{和} \\quad r_{2} = \\frac{5.2 - \\sqrt{123.04}}{240}\n$$\n由于 $\\sqrt{123.04} \\approx 11.09$，第二个根 $r_{2}$ 将是负数。问题陈述指明贴现率 $r$ 必须为正，因此我们只考虑正根 $r_{1}$。\n$$\nr = \\frac{5.2 + \\sqrt{123.04}}{240} \\approx \\frac{5.2 + 11.09234}{240} \\approx \\frac{16.29234}{240} \\approx 0.06788475\n$$\n问题要求答案四舍五入到 $4$ 位有效数字。\n$$\nr \\approx 0.06788\n$$", "answer": "$$\n\\boxed{0.06788}\n$$"}, {"introduction": "尽管标准年金公式十分有用，但许多金融产品的现金流结构复杂且具有条件性，无法套用这些简洁的公式。本练习要求你为一个结构性产品计算内部收益率 ($IRR$)，该产品的现金支付与外部经济变量（通货膨胀率）挂钩 [@problem_id:2371722]。由于不存在简单的解析解，你必须回归 $IRR$ 的根本定义——即令所有现金流的净现值 ($NPV$) 为零的贴现率——并利用数值方法来求解。这项实践揭示了分析公式在现实应用中的局限性，并强调了计算方法在现代金融中的核心作用。", "id": "2371722", "problem": "要求您实现一个完整的程序，用于计算一个结构化产品的内部收益率（IRR）。该产品基于一个国家通货膨胀率的实际路径来支付有条件的票息。该程序必须仅依赖以下基本概念：通过恒定利率进行现值贴现的货币时间价值，以及将现金流现值总和等同于零的利率定义为内部收益率。不得假定使用任何其他快捷方式或现成公式。\n\n单个产品实例由输入元组 $\\left(P, C, L, U, T, g, \\{i_t\\}_{t=1}^{T}\\right)$ 定义，其中 $P$ 是在时间 $t=0$ 投资的初始本金， $C$ 是固定的年度票息金额， $L$ 和 $U$ 是通胀区间的下限和上限， $T$ 是以年为单位的到期期限， $g$ 是到期本金保证比例， $\\{i_t\\}$ 是已实现的年度通货膨胀率序列，以小数表示（而非百分比）。该结构化产品的现金流如下：\n- 在时间 $t=0$，投资者支付初始流出 $-P$。\n- 对于每一年 $t \\in \\{1,2,\\dots,T\\}$，当且仅当通货膨胀率 $i_t$ 满足 $L \\le i_t \\le U$ 时，支付金额为 $C$ 的票息；否则，该年度的票息为 $0$。\n- 在到期时间 $t=T$，除了按上述方式确定的任何票息外，无论通胀路径如何，投资者都会收到一笔等于 $gP$ 的到期保证回报。\n\n对于每个输入元组，将内部收益率（IRR）（表示为 $r$）定义为贴现率（以小数表示），使得所有现金流以利率 $r$ 贴现至时间 $t=0$ 后的总和为零。您的程序必须为每个指定的测试用例计算出这个 $r$。所有利率（通胀率、IRR）都必须以小数表示（例如，使用 $0.03$ 而不是 $3\\%$）。不涉及任何物理单位。\n\n测试套件：\n为以下五个案例中的每一个计算 IRR $r$。在每个案例中，通胀区间应包含边界值，即当通胀率 $i_t$ 等于 $L$ 或 $U$ 时，当年有资格获得票息。所有标量输入均为实数，所有通胀序列均为实值列表。\n\n- 案例 1（混合区间内和区间外年份）：\n  - $P = 1000$, $C = 50$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 1.0$, $\\{i_t\\}_{t=1}^{5} = [0.03, 0.01, 0.025, 0.04, 0.033]$。\n- 案例 2（边界值触发每年票息）：\n  - $P = 1000$, $C = 40$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 1.0$, $\\{i_t\\}_{t=1}^{5} = [0.02, 0.035, 0.035, 0.02, 0.025]$。\n- 案例 3（从未支付票息，到期返还全部本金）：\n  - $P = 1000$, $C = 60$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 1.0$, $\\{i_t\\}_{t=1}^{5} = [0.05, 0.05, 0.05, 0.05, 0.05]$。\n- 案例 4（从未支付票息，到期返还部分本金）：\n  - $P = 1000$, $C = 50$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 0.9$, $\\{i_t\\}_{t=1}^{5} = [0.05, 0.05, 0.05, 0.05, 0.05]$。\n- 案例 5（一年期产品，支付票息，返还全部本金）：\n  - $P = 1000$, $C = 100$, $L = 0.02$, $U = 0.035$, $T = 1$, $g = 1.0$, $\\{i_t\\}_{t=1}^{1} = [0.025]$。\n\n程序要求：\n- 对于每个案例，根据上述定义构建现金流序列，使用给定的通胀路径和边界来确定哪些票息会被支付。\n- 按上述定义计算 IRR $r$。解必须通过数值方法计算；不应假定通常情况下存在精确的代数简化方法。\n- 数值输出规范：对于每个案例，将 IRR 输出为四舍五入到 $8$ 位小数的浮点数。将所有五个案例的结果汇总到一行，作为用方括号括起来的逗号分隔列表，例如 $[r_1, r_2, r_3, r_4, r_5]$，其中每个 $r_k$ 都四舍五入到 $8$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[0.01234567,0.00000000,-0.01234567,0.03456789,0.10000000]$）。不允许有任何其他输出。", "solution": "所呈现的问题是计算金融学中一个明确定义的练习。它要求计算一种结构化金融产品的内部收益率（IRR），该产品的现金流取决于一个外部经济变量——通货膨胀率。所有参数和条件都已足够清晰和精确地指定，从而能够得到唯一且可验证的解。该问题在科学上基于货币时间价值的基本原则。\n\n验证步骤如下：\n1.  **提取已知条件**：所有输入参数 $(P, C, L, U, T, g, \\{i_t\\}_{t=1}^{T})$、现金流规则、IRR 的定义以及测试数据都已明确陈述且自成体系。\n2.  **验证**：该问题在科学上是合理的，它依赖于贴现现金流分析这一既定的金融概念。问题是适定的，因为所描述的现金流（一次初始流出，随后是一系列非负流入）通常会产生唯一的实值 IRR。问题陈述客观且无歧义。它可以形式化为一个精确的数学方程，并与计算金融学中的年金和永续年金主题直接相关。\n3.  **结论**：该问题有效。将构建一个解决方案。\n\n问题的核心是找到内部收益率，我们将其表示为 $r$。根据定义，$r$ 是使结构化产品所有现金流的净现值（NPV）等于零的特定贴现率。\n\n首先，我们必须根据提供的参数构建现金流序列 $\\{CF_t\\}_{t=0}^{T}$。\n设 $P$ 为初始本金， $C$ 为年度票息， $L$ 和 $U$ 为通胀区间的下限和上限， $T$ 为以年为单位的到期期限， $g$ 为到期本金保证比例， $\\{i_t\\}_{t=1}^{T}$ 为已实现的年度通货膨胀率序列。\n\n现金流的确定方式如下：\n- 在时间 $t=0$，存在一笔初始投资，即流出 $P$。因此，$CF_0 = -P$。\n- 对于随后的每一年 $t$，其中 $t \\in \\{1, 2, \\dots, T\\}$，我们必须确定是否支付票息。设 $c_t$ 为时间 $t$ 的票息支付。支付条件是当年的通货膨胀率 $i_t$ 落在指定的区间内，包含其边界。\n$$\nc_t =\n\\begin{cases}\nC & \\text{若 } L \\le i_t \\le U \\\\\n0 & \\text{否则}\n\\end{cases}\n$$\n- 对于每一年 $t \\in \\{1, 2, \\dots, T-1\\}$ 的现金流就是该年的票息支付：$CF_t = c_t$。\n- 在到期年份 $t=T$，现金流同时包括该年的票息 $c_T$ 和到期保证本金支付 $gP$。\n$$\nCF_T = c_T + gP\n$$\n\n在建立了完整的现金流序列 $\\{CF_t\\}_{t=0}^{T}$ 之后，我们可以将净现值定义为贴现率 $r$ 的函数：\n$$\n\\text{NPV}(r) = \\sum_{t=0}^{T} \\frac{CF_t}{(1+r)^t}\n$$\n根据定义，IRR 是解方程 $\\text{NPV}(r) = 0$ 的利率 $r$：\n$$\n\\sum_{t=0}^{T} \\frac{CF_t}{(1+r)^t} = 0\n$$\n代入 $CF_0 = -P$，我们可以将其重写为：\n$$\n-P + \\sum_{t=1}^{T} \\frac{CF_t}{(1+r)^t} = 0 \\quad \\implies \\quad P = \\sum_{t=1}^{T} \\frac{CF_t}{(1+r)^t}\n$$\n该方程是关于变量 $v = (1+r)^{-1}$ 的一个 $T$ 次多项式。当 $T > 4$ 时，其根没有通用的代数解。因此，我们必须采用数值求根算法来求解 $r$。\n\n解决此问题的步骤如下：\n1.  对于由元组 $(P, C, L, U, T, g, \\{i_t\\}_{t=1}^{T})$ 定义的每个测试用例：\n    a. 根据上述规则构建现金流向量 $CF = [CF_0, CF_1, \\dots, CF_T]$。\n    b. 定义目标函数 $f(r) = \\text{NPV}(r)$，我们需要求解 $f(r)=0$。\n    c. 利用数值求解器找到 $f(r)$ 的根。`scipy.optimize.newton` 函数实现了割线法（牛顿法的一种变体），是完成此任务的合适且稳健的选择。提供一个初始猜测值，例如 $r_0 = 0.1$ 来启动迭代过程。\n2.  然后根据要求，将每个案例计算出的 $r$ 值四舍五入到 8 位小数。\n3.  最终结果被汇总成一个格式化的字符串。\n\n此方法仅依赖于 IRR 的基本定义和通用的数值求解器，遵守了问题陈述的所有约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Computes the Internal Rate of Return (IRR) for a structured product\n    across several test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mixed in-band and out-of-band years)\n        {'P': 1000, 'C': 50, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 1.0, 'i_t': [0.03, 0.01, 0.025, 0.04, 0.033]},\n        # Case 2 (boundary inclusions trigger coupons every year)\n        {'P': 1000, 'C': 40, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 1.0, 'i_t': [0.02, 0.035, 0.035, 0.02, 0.025]},\n        # Case 3 (no coupons ever, full principal returned at maturity)\n        {'P': 1000, 'C': 60, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 1.0, 'i_t': [0.05, 0.05, 0.05, 0.05, 0.05]},\n        # Case 4 (no coupons ever, partial principal returned at maturity)\n        {'P': 1000, 'C': 50, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 0.9, 'i_t': [0.05, 0.05, 0.05, 0.05, 0.05]},\n        # Case 5 (one-year product, coupon paid, full principal returned)\n        {'P': 1000, 'C': 100, 'L': 0.02, 'U': 0.035, 'T': 1, 'g': 1.0, 'i_t': [0.025]},\n    ]\n\n    def npv_function(r, cash_flows):\n        \"\"\"\n        Calculates the Net Present Value for a given discount rate r and\n        a sequence of cash flows.\n        \"\"\"\n        times = np.arange(len(cash_flows))\n        return np.sum(cash_flows / ((1 + r)**times))\n\n    def compute_irr_for_case(params):\n        \"\"\"\n        Calculates the IRR for a single structured product instance.\n        \"\"\"\n        P, C, L, U, T, g, inflation_rates = \\\n            params['P'], params['C'], params['L'], params['U'], \\\n            params['T'], params['g'], params['i_t']\n\n        # Construct the cash flow sequence\n        cash_flows = np.zeros(T + 1)\n        cash_flows[0] = -P\n\n        for t in range(1, T + 1):\n            # Inflation rates list is 0-indexed, time t is 1-indexed\n            inflation_t = inflation_rates[t - 1]\n            coupon = 0\n            if L <= inflation_t <= U:\n                coupon = C\n            cash_flows[t] = coupon\n        \n        # Add the terminal principal guarantee at maturity\n        cash_flows[T] += g * P\n        \n        # Use a numerical solver (secant method) to find the root of the NPV function\n        # An initial guess of 0.1 (10%) is provided.\n        try:\n            irr = newton(npv_function, x0=0.1, args=(cash_flows,))\n        except RuntimeError:\n            # In cases where the function is very flat (like IRR=0),\n            # a different starting guess might be needed.\n            try:\n                irr = newton(npv_function, x0=0.0, args=(cash_flows,))\n            except RuntimeError:\n                 # Should not happen for these well-behaved cases\n                 irr = np.nan\n\n        return irr\n\n    results = []\n    for case in test_cases:\n        result = compute_irr_for_case(case)\n        results.append(result)\n\n    # Format each result to 8 decimal places and join into the final string\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}