{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。第一个练习将经济学中的一个基本概念——消费者剩余——与辛普森法则相结合。通过计算价格下降带来的消费者福利，你将练习使用辛普森法则来求解由不同函数形式（如二次、指数和逻辑函数）描述的需求曲线下的面积。这个练习旨在加深你对定积分作为“曲线下面积”的直观理解，并熟练掌握一维辛普森法则的基本实现。[@problem_id:2430268]", "id": "2430268", "problem": "一位区域规划师试图量化一条新高速公路所创造的每日消费者剩余，这条新公路降低了出行者面临的广义出行价格（以美元/次出行计）。设 $Q(p)$ 表示作为广义价格 $p$（美元/次出行）的函数的出行需求。根据微观经济学的定义，价格下降带来的消费者剩余是需求曲线下方、新旧价格之间的面积。从 Riemann 积分的定义出发，并且考虑到当 $p_1 &lt; p_0$ 时，价格从 $p_0$ 降至 $p_1$ 的消费者剩余变化等于 $Q(p)$ 对 $p$ 的定积分，这一收益可以写为 $Q(p)$ 在区间 $[p_1, p_0]$ 上的定积分。在不使用任何数值积分快捷公式的情况下，请实现具有偶数个子区间的复合 Simpson 法则，为几种符合经济学原理的需求设定近似计算此积分。\n\n您的任务是编写一个程序，该程序：\n- 对以下每个测试用例，使用具有偶数个子区间的复合 Simpson 法则来近似计算 $Q(p)$ 在 $[p_1,p_0]$ 上的积分。\n- 报告每种情况下产生的每日消费者剩余（以美元计），表示为四舍五入到 $6$ 位小数的浮点数。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[$x_1,x_2,x_3$]”）。\n\n假设需求设定和参数值如下（所有 $p$ 的单位为美元/次出行，$Q$ 的单位为次出行/天，结果必须以美元/天报告）：\n\n- 测试用例 $1$（二次需求；常规“理想路径”）：\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$\n  - 初始广义价格 $p_0 = 12$，新广义价格 $p_1 = 9$\n  - 子区间数量 $n = 100$（确保 $n$ 为偶数）\n\n- 测试用例 $2$（指数需求；非线性曲率）：\n  - $Q(p) = A e^{-k p}$\n  - $A = 100000$, $k = 0.15$\n  - $p_0 = 12$, $p_1 = 8$\n  - $n = 200$\n\n- 测试用例 $3$（逻辑斯谛需求；饱和/市场规模限制）：\n  - $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$\n  - $N = 150000$, $k = 0.5$, $\\bar{p} = 10$\n  - $p_0 = 14$, $p_1 = 10$\n  - $n = 400$\n\n- 测试用例 $4$（价格变化极小的二次需求；边界附近的数值稳定性）：\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$\n  - $p_0 = 10.00$, $p_1 = 9.99$\n  - $n = 10$\n\n要求：\n- 对每个测试，使用指定的 $n$ 在 $[p_1,p_0]$ 上通过复合 Simpson 法则实现积分近似。\n- 将每个最终数值答案以美元/天表示，四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试用例 $1$ 到 $4$ 的顺序排列（例如，“[$r_1,r_2,r_3,r_4$]”）。", "solution": "问题陈述已经过严格审查，并被确定为**有效**。它在科学上基于成熟的微观经济学原理和微积分，问题设定良好，包含所有必要信息和一致的约束条件，并以客观、明确的语言进行阐述。任务是使用指定的数值方法来近似一个代表消费者剩余的定积分，这是计算科学中的一个标准问题。\n\n核心原理是计算因价格从初始价格 $p_0$ 下降到新的、更低的价格 $p_1$ 而产生的消费者剩余变化（$\\Delta CS$）。在微观经济学中，这被定义为需求曲线 $Q(p)$ 下方、这两个价格之间的面积。在数学上，这表示为需求函数在价格区间上的定积分：\n\n$$ \\Delta CS = \\int_{p_1}^{p_0} Q(p) \\, dp $$\n\n该问题要求使用复合 Simpson 法则来近似计算该积分，而不借助预先存在的数值积分库函数。Simpson 法则是一种用于近似计算函数 $f(x)$ 在区间 $[a, b]$ 上的定积分的数值方法。该法则的复合版本将区间 $[a, b]$ 分成偶数个宽度相等的子区间，记为 $n$，每个子区间的宽度为 $h$。\n\n该算法按以下步骤进行：\n1.  **定义积分参数**：对于每个测试用例，积分区间为 $[a, b] = [p_1, p_0]$。子区间的数量 $n$ 已给出，并且是一个偶数。\n\n2.  **计算子区间宽度**：每个子区间的宽度 $h$ 计算如下：\n    $$ h = \\frac{b - a}{n} = \\frac{p_0 - p_1}{n} $$\n\n3.  **建立分割点**：区间 $[p_1, p_0]$ 被 $n+1$ 个点分割成 $n$ 个子区间。为避免与初始价格 $p_0$ 和 $p_1$ 混淆，将这些点表示为 $x_k$。\n    $$ x_k = p_1 + k \\cdot h, \\quad \\text{for } k = 0, 1, 2, \\ldots, n $$\n    注意，$x_0 = p_1$ 且 $x_n = p_0$。\n\n4.  **应用复合 Simpson 法则**：积分的复合 Simpson 法则近似值 $S_n$ 的公式为：\n    $$ S_n = \\frac{h}{3} \\left[ Q(x_0) + 4\\sum_{k=1}^{n/2} Q(x_{2k-1}) + 2\\sum_{k=1}^{n/2-1} Q(x_{2k}) + Q(x_n) \\right] $$\n    该公式通过对函数 $Q(p)$ 在分割点 $x_k$ 处的值进行加权求和来构建近似值。端点（$x_0$ 和 $x_n$）的权重为 $1$。奇数索引的内部点（$x_1, x_3, \\ldots, x_{n-1}$）的权重为 $4$。偶数索引的内部点（$x_2, x_4, \\ldots, x_{n-2}$）的权重为 $2$。\n\n5.  **为每个测试用例实现**：将此数值积分过程应用于四个指定的测试用例中的每一个。\n\n    -   **测试用例 $1$**：\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$，其中 $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$。\n        -   在 $p_1 = 9$ 到 $p_0 = 12$ 上进行积分，使用 $n = 100$ 个子区间。\n        -   由于 $Q(p)$ 是一个次数为 $2$（小于 $4$）的多项式，Simpson 法则将提供积分的精确值。\n\n    -   **测试用例 $2$**：\n        -   $Q(p) = A e^{-k p}$，其中 $A = 100000$, $k = 0.15$。\n        -   在 $p_1 = 8$ 到 $p_0 = 12$ 上进行积分，使用 $n = 200$ 个子区间。\n\n    -   **测试用例 $3$**：\n        -   $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$，其中 $N = 150000$, $k = 0.5$, $\\bar{p} = 10$。\n        -   在 $p_1 = 10$ 到 $p_0 = 14$ 上进行积分，使用 $n = 400$ 个子区间。\n\n    -   **测试用例 $4$**：\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$，其中 $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$。\n        -   在 $p_1 = 9.99$ 到 $p_0 = 10.00$ 上进行积分，使用 $n = 10$ 个子区间。\n        -   与用例 1 一样，结果将是解析精确的。\n\n每个用例的最终计算值都四舍五入到 $6$ 位小数，以表示每日消费者剩余（以美元计）。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer surplus problem for four different demand specifications\n    using a from-scratch implementation of the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_integrator(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of func from a to b by the\n        composite Simpson's rule, using n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be even.\")\n\n        h = (b - a) / n\n        x_points = np.linspace(a, b, n + 1)\n        y_points = func(x_points)\n\n        # Simpson's rule: (h/3) * [y0 + 4y1 + 2y2 + 4y3 + ... + 4y_{n-1} + yn]\n        # This is implemented by summing endpoints, odd interior points, and even interior points.\n        integral = (h / 3) * (\n            y_points[0] + \n            y_points[-1] + \n            4 * np.sum(y_points[1:-1:2]) + \n            2 * np.sum(y_points[2:-1:2])\n        )\n        \n        return integral\n\n    # Define the demand functions for each test case\n    def q_case1(p):\n        alpha, beta, gamma = 120000, 4000, 100\n        return alpha - beta * p - gamma * p**2\n\n    def q_case2(p):\n        A, k = 100000, 0.15\n        return A * np.exp(-k * p)\n\n    def q_case3(p):\n        N, k, p_bar = 150000, 0.5, 10\n        return N / (1 + np.exp(k * (p - p_bar)))\n\n    def q_case4(p):\n        alpha, beta, gamma = 80000, 5000, 50\n        return alpha - beta * p - gamma * p**2\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {'func': q_case1, 'p1': 9, 'p0': 12, 'n': 100},\n        {'func': q_case2, 'p1': 8, 'p0': 12, 'n': 200},\n        {'func': q_case3, 'p1': 10, 'p0': 14, 'n': 400},\n        {'func': q_case4, 'p1': 9.99, 'p0': 10.00, 'n': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        # The integral for consumer surplus is from the new price (p1) to the old price (p0)\n        consumer_surplus = simpson_integrator(\n            case['func'], \n            case['p1'], \n            case['p0'], \n            case['n']\n        )\n        # Round the result to 6 decimal places and format as a string\n        results.append(f\"{consumer_surplus:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "真实的金融模型往往比简单的平滑函数更复杂。本练习模拟了一个更为现实的场景：评估攻读工商管理硕士（MBA）学位的净现值（$NPV$）。其挑战在于，现金流函数是分段定义的，在项目期间和毕业后的形式完全不同。这个练习将教会你一个至关重要的数值技巧：通过在不连续点分割积分区间，将复杂问题分解为多个可管理的子问题，从而精确地应用辛普森法则。[@problem_id:2430272]", "id": "2430272", "problem": "您的任务是计算攻读工商管理硕士 (MBA) 项目所带来的增量收益的净现值，该问题被建模为一个连续时间现金流问题。净现值定义为：MBA 毕业后的薪资路径与未攻读 MBA 的反事实薪资路径之差，减去项目期间的学费支付后，所得到的现值积分。所有时间均以年为单位，所有货币价值均以美元计。您必须使用复合 Simpson 法则进行数值积分。\n\n设攻读 MBA 前的薪资路径建模为指数增长函数 $s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$，其中 $A$ 是时间 $t=0$ 时的初始薪资，$g_{\\text{pre}}$ 是攻读 MBA 前的薪资增长率。MBA 毕业后的薪资路径是分段的：在长度为 $L$ 的项目期间，年收入可能为固定金额 $s_{\\text{prog}}$；在时间 $t=L$ 毕业后，薪资从水平 $B$ 开始，并以增长率 $g_{\\text{post}}$ 增长，即对于 $t \\ge L$，有 $s_{\\text{post}}(t) = B \\exp(g_{\\text{post}}(t - L))$。学费在项目期间 $[0,L)$ 以恒定速率 $\\tau$ 作为连续流出支付，其他时间为零。连续复利贴现率为 $r \\ge 0$。\n\n将增量现金流定义为\n$$\n\\Delta(t) = s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t),\n$$\n其中\n$$\ns_{\\text{post}}(t) = \n\\begin{cases}\ns_{\\text{prog}}, & 0 \\le t < L,\\\\\nB \\exp\\!\\big(g_{\\text{post}}(t - L)\\big), & t \\ge L,\n\\end{cases}\n\\qquad\n\\text{tuition}(t) =\n\\begin{cases}\n\\tau, & 0 \\le t < L,\\\\\n0, & t \\ge L,\n\\end{cases}\n\\qquad\ns_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t).\n$$\n在时间区间 $[0,T]$ 上的净现值为\n$$\n\\text{NPV} = \\int_{0}^{T} e^{- r t}\\, \\Delta(t)\\, dt.\n$$\n\n实现一个程序，该程序：\n- 在每个光滑子区间上，使用偶数个子区间 $n$ 的复合 Simpson 法则来近似计算该积分。为处理项目边界 $t=L$ 处的分段定义，需在 $t=L$ 处将积分拆分，并分别在 $[0,L]$ 和 $[L,T]$ 上应用 Simpson 法则（忽略任何零长度的段）。使用总共 $n_{\\text{total}}=4096$ 个子区间的基准，并为每个分段分配偶数个子区间，使得 $n_1 + n_2 = n_{\\text{total}}$，其中用于 $[0,L]$ 的 $n_1$ 和用于 $[L,T]$ 的 $n_2$ 均为偶数（当段长度为正时，根据需要进行调整以确保两者都至少为 2）。\n- 使用美元作为货币单位、年作为时间单位，计算以下每个测试用例的净现值。最终结果以美元表示，四舍五入到两位小数。\n\n测试套件（参数以 $(A, g_{\\text{pre}}, L, B, g_{\\text{post}}, s_{\\text{prog}}, \\tau, r, T)$ 形式给出）：\n- 案例 $1$（一般长时程）：$(\\$80{,}000,\\; 0.02,\\; 2,\\; \\$120{,}000,\\; 0.03,\\; \\$10{,}000,\\; \\$60{,}000,\\; 0.05,\\; 40)$。\n- 案例 $2$（边界情况，项目长度 L=0）：$(\\$85{,}000,\\; 0.02,\\; 0,\\; \\$110{,}000,\\; 0.025,\\; \\$0,\\; \\$0,\\; 0.05,\\; 35)$。\n- 案例 $3$（贴现率 r=0）：$(\\$70{,}000,\\; 0.03,\\; 1.5,\\; \\$95{,}000,\\; 0.035,\\; \\$0,\\; \\$50{,}000,\\; 0,\\; 30)$。\n- 案例 $4$（时程等于项目长度 T=L）：$(\\$90{,}000,\\; 0.02,\\; 2,\\; \\$150{,}000,\\; 0.03,\\; \\$5{,}000,\\; \\$80{,}000,\\; 0.04,\\; 2)$。\n\n输出要求：\n- 您的程序应生成单行输出，其中包含按上述案例顺序排列的四个净现值，形式为逗号分隔的列表，并用方括号括起来，例如 $[\\text{npv}_1,\\text{npv}_2,\\text{npv}_3,\\text{npv}_4]$。\n- 每个值必须以美元为单位，并四舍五入到两位小数。\n\n角度单位不适用。所有指数函数均使用自然指数。所有利率 $g_{\\text{pre}}$、$g_{\\text{post}}$ 和 $r$ 均为年率（连续复利）。请遵循在 $t=L$ 处的拆分策略，并在每个段上使用偶数个子区间，以确保科学真实性和数值稳定性。", "solution": "所提出的问题是计算金融学中的一个有效练习。它以净现值分析原理为科学基础，所有必需参数和明确目标使其成为一个适定问题，并且其组成部分在数学和经济学上都是合理的。我们将着手推导解决方案。\n\n目标是计算在时间范围 $[0, T]$ 内，投资 MBA 项目所产生的增量现金流的净现值 (${\\text{NPV}}$)。这需要使用复合 Simpson 法则对一个定积分进行数值评估。\n\n在时间 $t$ 的增量现金流（记为 $\\Delta(t)$）是 MBA 毕业后薪资、攻读 MBA 前薪资和学费成本之间的差额。这些函数定义如下：\n- 攻读 MBA 前的薪资：$s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$\n- MBA 毕业后的薪资：$s_{\\text{post}}(t) = \\begin{cases} s_{\\text{prog}}, & 0 \\le t < L \\\\ B \\exp(g_{\\text{post}}(t-L)), & t \\ge L \\end{cases}$\n- 学费：$\\text{tuition}(t) = \\begin{cases} \\tau, & 0 \\le t < L \\\\ 0, & t \\ge L \\end{cases}$\n\n净现值是在时间范围 $[0, T]$ 上对折现后的增量现金流进行的积分：\n$$\n\\text{NPV} = \\int_{0}^{T} e^{-rt} \\Delta(t) \\,dt = \\int_{0}^{T} e^{-rt} [s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t)] \\,dt\n$$\n其中 $r$ 是连续复利贴现率。\n\n由于 $s_{\\text{post}}(t)$ 和 $\\text{tuition}(t)$ 的分段定义，被积函数在点 $t=L$ 处不连续，该点标志着 MBA 项目的结束。对该积分的严格评估要求在这个不连续点将其拆分：\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} \\Delta(t) \\,dt + \\int_{L}^{T} e^{-rt} \\Delta(t) \\,dt\n$$\n将每个区间的相应定义代入，得到两个独立的积分：\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} (s_{\\text{prog}} - \\tau - A e^{g_{\\text{pre}}t}) \\,dt + \\int_{L}^{T} e^{-rt} (B e^{g_{\\text{post}}(t-L)} - A e^{g_{\\text{pre}}t}) \\,dt\n$$\n我们将第一个积分记为 $\\text{NPV}_1$，第二个记为 $\\text{NPV}_2$。$\\text{NPV} = \\text{NPV}_1 + \\text{NPV}_2$。这些积分将进行数值近似计算。\n\n指定的数值方法是复合 Simpson 法则。对于一个积分 $\\int_a^b f(x) \\,dx$，当其区间被划分为偶数个子区间 $n$ 时，其近似值由下式给出：\n$$\n\\int_a^b f(x) \\,dx \\approx \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} f(x_{2i}) + f(x_n) \\right]\n$$\n其中 $h = (b-a)/n$ 是步长，$x_i = a+ih$ 是求值点。该法则要求 $n$ 是一个偶数，且 $n \\ge 2$。\n\n问题规定总共使用 $n_{\\text{total}} = 4096$ 个子区间，分配到两个积分段 $[0, L]$ 和 $[L, T]$ 上。设第一个积分的子区间数量为 $n_1$，第二个为 $n_2$，使得 $n_1 + n_2 = n_{\\text{total}}$。$n_1$ 和 $n_2$ 都必须是偶数。一种合乎逻辑且系统化的方法是按每个积分段的长度比例来分配这些子区间。\n\n$n_1$ 和 $n_2$ 的分配算法如下：\n$1$。处理边界情况：\n    - 如果 $L \\le 0$，则在 $[0, L]$ 上的第一个积分为零。我们设置 $n_1 = 0$ 和 $n_2 = n_{\\text{total}}$。积分仅在 $[0, T]$ 上执行。\n    - 如果 $T \\le L$，则在 $[L, T]$ 上的第二个积分为零。我们设置 $n_1 = n_{\\text{total}}$ 和 $n_2 = 0$。积分仅在 $[0, L]$ 上执行。\n$2$。对于一般情况 $0 < L < T$：\n    - 计算第一个区间的比例分配：$n_{1, \\text{prop}} = n_{\\text{total}} \\times \\frac{L}{T}$。\n    - 将该值四舍五入到最近的偶数。一个稳健的方法是 $n_1 = 2 \\times \\text{round}(n_{1, \\text{prop}}/2)$。\n    - 应用保障措施以确保 $n_1$ 和 $n_2$ 至少为 2（如果它们对应的区间长度为正）。如果计算得出 $n_1 < 2$，我们设置 $n_1=2$。如果得出 $n_1 > n_{\\text{total}}-2$，我们设置 $n_1 = n_{\\text{total}}-2$。\n    - 那么第二个区间的分配为 $n_2 = n_{\\text{total}} - n_1$。根据构造，如果 $n_{\\text{total}}$ 和 $n_1$ 是偶数，那么 $n_2$ 也将是偶数。\n\n该实现将包含一个执行 Simpson 法则的函数和一个遍历所提供测试用例的主过程。对于每个案例，它将：\n- 根据具体参数定义两个被积函数。\n- 根据分配算法确定子区间计数 $n_1$ 和 $n_2$。\n- 对两个积分中的每一个调用 Simpson 法则函数（如果区间长度为正）。\n- 将结果相加得到总 $\\text{NPV}$。\n- 按要求将最终值四舍五入到两位小数。\n\n这种结构化的方法确保了经济模型的分段特性被数值积分正确处理，从而提供了一个科学上合理且计算上稳健的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net present value of enrolling in an MBA program \n    for a series of test cases using the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_rule(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of a function from a to b\n        using the composite Simpson's rule with n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even and positive).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n == 0 or a == b:\n            return 0.0\n        \n        if n < 2 or n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be a positive even integer.\")\n\n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = func(x)\n\n        # Simpson's rule formula\n        # S = y[0] + y[-1] + 4 * sum(odd indices) + 2 * sum(even indices)\n        integral = h / 3.0 * (y[0] + y[-1] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]))\n        \n        return integral\n\n    # Define the test cases from the problem statement.\n    # Parameters: (A, g_pre, L, B, g_post, s_prog, tau, r, T)\n    test_cases = [\n        (80000, 0.02, 2, 120000, 0.03, 10000, 60000, 0.05, 40),\n        (85000, 0.02, 0, 110000, 0.025, 0, 0, 0.05, 35),\n        (70000, 0.03, 1.5, 95000, 0.035, 0, 50000, 0, 30),\n        (90000, 0.02, 2, 150000, 0.03, 5000, 80000, 0.04, 2),\n    ]\n\n    results = []\n    n_total = 4096\n\n    for case in test_cases:\n        A, g_pre, L, B, g_post, s_prog, tau, r, T = case\n\n        # Define the two integrands corresponding to the two time periods\n        \n        # Integrand for the period during the MBA program: [0, L]\n        # Delta(t) = s_prog - s_pre(t) - tuition(t)\n        integrand1 = lambda t: np.exp(-r * t) * (s_prog - tau - A * np.exp(g_pre * t))\n\n        # Integrand for the period after graduation: [L, T]\n        # Delta(t) = s_post(t) - s_pre(t)\n        integrand2 = lambda t: np.exp(-r * t) * (B * np.exp(g_post * (t - L)) - A * np.exp(g_pre * t))\n\n        # Allocate subintervals n1 and n2\n        n1, n2 = 0, 0\n        if L <= 0:\n            # First interval has zero or negative length\n            n1 = 0\n            n2 = n_total\n            # Adjust integration range for the second part\n            L_eff = 0\n            T_eff = T\n        elif T <= L:\n            # Second interval has zero or negative length\n            n1 = n_total\n            n2 = 0\n            L_eff = L\n            T_eff = L\n        else: # 0 < L < T\n            # Proportional allocation\n            n1_prop = n_total * L / T\n            # Round to nearest even integer\n            n1 = int(round(n1_prop / 2.0) * 2)\n            \n            # Safeguard to ensure n1 and n2 are at least 2\n            if n1 < 2:\n                n1 = 2\n            if n_total - n1 < 2:\n                n1 = n_total - 2\n            \n            n2 = n_total - n1\n            L_eff = L\n            T_eff = T\n\n        # Calculate NPV for the first period [0, L]\n        npv1 = 0.0\n        if n1 > 0:\n            npv1 = simpson_rule(integrand1, 0, L_eff, n1)\n\n        # Calculate NPV for the second period [L, T]\n        # For L=0 case, this integral is over [0,T]\n        npv2 = 0.0\n        if n2 > 0:\n            npv2 = simpson_rule(integrand2, L_eff, T_eff, n2)\n\n        # Total NPV is the sum of the two parts\n        total_npv = npv1 + npv2\n        results.append(total_npv)\n\n    # Final print statement in the exact required format.\n    # Round to two decimal places for currency representation.\n    print(f\"[{','.join([f'{res:.2f}' for res in results])}]\")\n\nsolve()\n```"}, {"introduction": "金融中的许多问题本质上是多维的，例如在投资组合中考虑多种相关资产。这个高级练习将带你进入多维数值积分的领域，计算一个包含两种相关资产的投资组合的预期效用。你将需要把一维的辛普森法则扩展到二维空间，以处理由二元学生-$t$分布描述的复杂联合概率密度函数。这个练习不仅能让你掌握更高阶的数值技术，还能让你体会到数值方法在解决现代金融复杂模型中的强大威力。[@problem_id:2430205]", "id": "2430205", "problem": "一个投资组合包含$2$种风险资产，其简单收益率分别由$r_1$和$r_2$表示。$(r_1,r_2)$的联合概率密度函数(PDF)被指定为二元学生t分布(bivariate Student-$t$ distribution)，其自由度为$\\,\\nu>2\\,$，位置向量为$\\mu=\\begin{bmatrix}\\mu_1\\\\ \\mu_2\\end{bmatrix}$，尺度参数为$s_1>0$和$s_2>0$，线性相关系数为$\\rho \\in(-1,1)$。令协方差形式的尺度矩阵为\n$$\n\\Sigma \\;=\\; \\begin{bmatrix}\ns_1^2 & \\rho\\, s_1 s_2\\\\\n\\rho\\, s_1 s_2 & s_2^2\n\\end{bmatrix},\n\\quad\n|\\Sigma| \\;=\\; s_1^2 s_2^2 (1-\\rho^2),\n\\quad\n\\Sigma^{-1} \\;=\\; \\frac{1}{(1-\\rho^2)}\\begin{bmatrix}\n1/s_1^2 & -\\rho/(s_1 s_2)\\\\\n-\\rho/(s_1 s_2) & 1/s_2^2\n\\end{bmatrix}.\n$$\n对于$d=2$维，其联合PDF为\n$$\nf(r_1,r_2) \\;=\\; \\frac{\\Gamma\\!\\left(\\tfrac{\\nu+d}{2}\\right)}{\\Gamma\\!\\left(\\tfrac{\\nu}{2}\\right)\\,(\\nu\\pi)^{d/2}\\,|\\Sigma|^{1/2}}\n\\left(1 + \\frac{1}{\\nu}\\,(x^\\top \\Sigma^{-1} x)\\right)^{-\\tfrac{\\nu+d}{2}},\n\\quad\nx \\;=\\; \\begin{bmatrix} r_1-\\mu_1 \\\\ r_2-\\mu_2 \\end{bmatrix},\n\\quad d=2,\n$$\n即，\n$$\nf(r_1,r_2) \\;=\\; \\frac{\\Gamma\\!\\left(\\tfrac{\\nu+2}{2}\\right)}{\\Gamma\\!\\left(\\tfrac{\\nu}{2}\\right)\\,\\nu\\pi\\, s_1 s_2 \\sqrt{1-\\rho^2}}\\,\n\\left(1 + \\frac{1}{\\nu}\\,\\frac{(r_1-\\mu_1)^2/s_1^2 - 2\\rho\\,(r_1-\\mu_1)(r_2-\\mu_2)/(s_1 s_2) + (r_2-\\mu_2)^2/s_2^2}{1-\\rho^2}\\right)^{-\\tfrac{\\nu+2}{2}}.\n$$\n\n设初始财富为$W_0>0$，投资组合权重为$w_1$和$w_2$。期末财富为\n$$\nW(r_1,r_2) \\;=\\; W_0\\,\\big(1 + w_1 r_1 + w_2 r_2\\big).\n$$\n偏好由常数绝对风险厌恶(CARA)效用函数给出\n$$\nU(W) \\;=\\; -\\exp(-a\\,W),\n$$\n其中绝对风险厌恶参数为$a\\ge 0$。期望效用由以下积分定义\n$$\n\\mathbb{E}[U(W)] \\;=\\; \\int_{-\\infty}^{\\infty}\\!\\int_{-\\infty}^{\\infty} U\\!\\big(W(r_1,r_2)\\big)\\, f(r_1,r_2)\\, \\mathrm{d}r_1\\,\\mathrm{d}r_2.\n$$\n\n为了进行数值评估，将定义域限制在矩形区域\n$$\n\\mathcal{R} \\;=\\; \\big[\\mu_1 - K\\,s_1,\\; \\mu_1 + K\\,s_1\\big]\\;\\times\\;\\big[\\mu_2 - K\\,s_2,\\; \\mu_2 + K\\,s_2\\big],\n$$\n并近似计算\n$$\n\\int_{\\mathcal{R}} U\\!\\big(W(r_1,r_2)\\big)\\, f(r_1,r_2)\\, \\mathrm{d}r_1\\,\\mathrm{d}r_2,\n$$\n该值可作为$\\mathbb{E}[U(W)]$的近似值。\n\n测试套件。对于以下每种情况，使用给定的参数，其中$n_x$和$n_y$分别是沿$r_1$轴和$r_2$轴的相等子区间的数量。所有的$n_x$和$n_y$都是偶数。\n\n- 情况1（一般情况）：$\\nu=6$, $\\mu_1=0.05$, $\\mu_2=0.02$, $s_1=0.20$, $s_2=0.15$, $\\rho=0.3$, $W_0=1.0$, $w_1=0.6$, $w_2=0.4$, $a=3.0$, $K=12$, $n_x=200$, $n_y=200$.\n- 情况2（独立）：$\\nu=7$, $\\mu_1=0.04$, $\\mu_2=0.03$, $s_1=0.25$, $s_2=0.25$, $\\rho=0.0$, $W_0=1.0$, $w_1=0.5$, $w_2=0.5$, $a=1.5$, $K=12$, $n_x=180$, $n_y=180$.\n- 情况3（负相关，厚尾）：$\\nu=5$, $\\mu_1=0.01$, $\\mu_2=0.00$, $s_1=0.30$, $s_2=0.20$, $\\rho=-0.7$, $W_0=1.0$, $w_1=0.8$, $w_2=0.2$, $a=2.5$, $K=14$, $n_x=220$, $n_y=220$.\n- 情况4（风险中性基准）：$\\nu=6$, $\\mu_1=0.00$, $\\mu_2=0.00$, $s_1=0.20$, $s_2=0.20$, $\\rho=0.5$, $W_0=1.0$, $w_1=0.3$, $w_2=0.7$, $a=0.0$, $K=16$, $n_x=200$, $n_y=200$.\n\n程序输出要求。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为上述四种情况的数值近似值，每个数值四舍五入到$8$位小数，并按情况1到4的顺序排列（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$）。不应打印任何其他文本。", "solution": "问题陈述已经过严谨分析，并被确定为有效。它在科学上是合理的、良构的，并为得出唯一且有意义的解提供了所有必要的数据和定义。该问题要求对一个投资组合的期望效用进行数值近似，该投资组合的资产收益率服从二元学生t分布。我们将提供详细的解法。\n\n目标是计算期望效用，其由以下积分定义：\n$$\n\\mathbb{E}[U(W)] \\;=\\; \\int_{-\\infty}^{\\infty}\\!\\int_{-\\infty}^{\\infty} U\\!\\big(W(r_1,r_2)\\big)\\, f(r_1,r_2)\\, \\mathrm{d}r_1\\,\\mathrm{d}r_2\n$$\n问题指明，通过将积分域限制在一个有限矩形$\\mathcal{R}$内来近似该积分，该矩形由下式给出：\n$$\n\\mathcal{R} \\;=\\; \\big[r_{1,\\min}, r_{1,\\max}\\big]\\;\\times\\;\\big[r_{2,\\min}, r_{2,\\max}\\big] \\;=\\; \\big[\\mu_1 - K\\,s_1,\\; \\mu_1 + K\\,s_1\\big]\\;\\times\\;\\big[\\mu_2 - K\\,s_2,\\; \\mu_2 + K\\,s_2\\big]\n$$\n待积分的函数，我们称之为$g(r_1, r_2)$，是效用函数$U(W)$与概率密度函数(PDF) $f(r_1, r_2)$的乘积。\n\n期末财富$W(r_1, r_2)$是资产收益率$r_1$和$r_2$的线性函数：\n$$\nW(r_1,r_2) \\;=\\; W_0\\,\\big(1 + w_1 r_1 + w_2 r_2\\big)\n$$\n效用函数为常数绝对风险厌恶(CARA)形式：\n$$\nU(W) \\;=\\; -\\exp(-a\\,W)\n$$\n代入财富的表达式，效用为：\n$$\nU(W(r_1, r_2)) \\;=\\; -\\exp\\Big(-a W_0 (1 + w_1 r_1 + w_2 r_2)\\Big)\n$$\n收益率的联合PDF是二元学生t分布：\n$$\nf(r_1,r_2) \\;=\\; C \\cdot \\left(1 + \\frac{1}{\\nu(1-\\rho^2)}\\left[\\left(\\frac{r_1-\\mu_1}{s_1}\\right)^2 - 2\\rho\\left(\\frac{r_1-\\mu_1}{s_1}\\right)\\left(\\frac{r_2-\\mu_2}{s_2}\\right) + \\left(\\frac{r_2-\\mu_2}{s_2}\\right)^2\\right]\\right)^{-\\frac{\\nu+2}{2}}\n$$\n其中归一化常数$C$为：\n$$\nC \\;=\\; \\frac{\\Gamma\\!\\left(\\frac{\\nu+2}{2}\\right)}{\\Gamma\\!\\left(\\frac{\\nu}{2}\\right)\\,\\nu\\pi\\, s_1 s_2 \\sqrt{1-\\rho^2}}\n$$\n因此，被积函数为 $g(r_1, r_2) = U(W(r_1, r_2)) \\cdot f(r_1, r_2)$。\n\n为近似积分 $\\int_{\\mathcal{R}} g(r_1, r_2) \\, \\mathrm{d}r_1 \\mathrm{d}r_2$，我们采用二维辛普森法则(two-dimensional Simpson's rule)，这是合适的，因为子区间的数量$n_x$和$n_y$被指定为偶数。\n\n首先，我们将积分域离散化。区间$[r_{1,\\min}, r_{1,\\max}]$和$[r_{2,\\min}, r_{2,\\max}]$分别被划分为$n_x$和$n_y$个等宽的子区间。步长为：\n$$\nh_1 = \\frac{r_{1,\\max} - r_{1,\\min}}{n_x} = \\frac{2 K s_1}{n_x}\n\\quad \\text{和} \\quad\nh_2 = \\frac{r_{2,\\max} - r_{2,\\min}}{n_y} = \\frac{2 K s_2}{n_y}\n$$\n这将创建一个点网格$(r_{1,i}, r_{2,j})$，其中$r_{1,i} = r_{1,\\min} + i h_1$（对于 $i \\in \\{0, 1, \\dots, n_x\\}$）以及$r_{2,j} = r_{2,\\min} + j h_2$（对于 $j \\in \\{0, 1, \\dots, n_y\\}$）。\n\n二维积分的辛普森法则是对一维法则的扩展。其近似公式为：\n$$\nI \\approx \\frac{h_1 h_2}{9} \\sum_{i=0}^{n_x} \\sum_{j=0}^{n_y} w_{i,j} g(r_{1,i}, r_{2,j})\n$$\n权重$w_{i,j}$是一维辛普森权重的乘积。对于$n$个子区间（$n$为偶数），一维权重向量为$(1, 4, 2, 4, \\dots, 2, 4, 1)$。令$w^{(1)}$为$r_1$维度的权重向量（长度为$n_x+1$），$w^{(2)}$为$r_2$维度的权重向量（长度为$n_y+1$）。那么，条目为$w_{i,j}$的权重矩阵$W$的构造方式为$w_{i,j} = w_i^{(1)} w_j^{(2)}$。\n\n每个测试用例的算法如下：\n1.  使用给定的参数$\\mu_1, \\mu_2, s_1, s_2, K$定义积分边界$r_{1,\\min}, r_{1,\\max}, r_{2,\\min}, r_{2,\\max}$。\n2.  生成两个网格点向量，一个用于$r_1$（大小为$n_x+1$），一个用于$r_2$（大小为$n_y+1$）。\n3.  从这些向量创建一个二维网格(mesh grid)，以表示所有的$(r_{1,i}, r_{2,j})$点。\n4.  在网格上的每个点评估被积函数$g(r_1, r_2)$。这包括两个主要子步骤：\n    a. 计算PDF值$f(r_{1,i}, r_{2,j})$。常数因子需要使用`scipy.special`库中的伽玛函数$\\Gamma(z)$。\n    b. 计算效用值$U(W(r_{1,i}, r_{2,j}))$。\n    c. 将PDF值和效用值逐元素相乘，形成被积函数值的矩阵。\n5.  为$r_1$和$r_2$维度构建辛普森权重向量。\n6.  通过计算两个权重向量的外积来形成二维权重矩阵。\n7.  计算被积函数矩阵和权重矩阵逐元素乘积的总和。\n8.  将此总和乘以因子$\\frac{h_1 h_2}{9}$，以获得积分的最终数值。\n\n一个需要特别考虑的是情况4，其中风险厌恶参数$a=0$。在这种情况下，效用函数变为常数：\n$$\nU(W) = -\\exp(-0 \\cdot W) = -1\n$$\n期望效用积分简化为：\n$$\n\\mathbb{E}[U(W)] \\approx \\int_{\\mathcal{R}} (-1) \\cdot f(r_1, r_2) \\, \\mathrm{d}r_1 \\mathrm{d}r_2 = - \\int_{\\mathcal{R}} f(r_1, r_2) \\, \\mathrm{d}r_1 \\mathrm{d}r_2\n$$\n这是积分矩形$\\mathcal{R}$内包含的总概率质量的负值。由于$K=16$很大，这个矩形覆盖了概率分布的绝大部分，因此结果应该非常接近$-1$。这可作为对实现方法的有效性检查。", "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    # Test cases as defined in the problem statement.\n    # Each tuple contains: (nu, mu1, mu2, s1, s2, rho, W0, w1, w2, a, K, nx, ny)\n    test_cases = [\n        (6.0, 0.05, 0.02, 0.20, 0.15, 0.3, 1.0, 0.6, 0.4, 3.0, 12, 200, 200),\n        (7.0, 0.04, 0.03, 0.25, 0.25, 0.0, 1.0, 0.5, 0.5, 1.5, 12, 180, 180),\n        (5.0, 0.01, 0.00, 0.30, 0.20, -0.7, 1.0, 0.8, 0.2, 2.5, 14, 220, 220),\n        (6.0, 0.00, 0.00, 0.20, 0.20, 0.5, 1.0, 0.3, 0.7, 0.0, 16, 200, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_expected_utility(*case)\n        results.append(f\"{result:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_expected_utility(nu, mu1, mu2, s1, s2, rho, W0, w1, w2, a, K, nx, ny):\n    \"\"\"\n    Calculates the expected utility for a single set of parameters using 2D Simpson's rule.\n    \"\"\"\n    # 1. Define integration domain\n    r1_min, r1_max = mu1 - K * s1, mu1 + K * s1\n    r2_min, r2_max = mu2 - K * s2, mu2 + K * s2\n\n    h1 = (r1_max - r1_min) / nx\n    h2 = (r2_max - r2_min) / ny\n\n    # 2. Create grid of points\n    r1_vals = np.linspace(r1_min, r1_max, nx + 1)\n    r2_vals = np.linspace(r2_min, r2_max, ny + 1)\n    R1, R2 = np.meshgrid(r1_vals, r2_vals, indexing='xy')\n\n    # 3. Calculate integrand values on the grid\n    \n    # 3a. Bivariate Student-t PDF f(r1, r2)\n    # Normalization constant\n    const_C = gamma((nu + 2) / 2) / (gamma(nu / 2) * nu * np.pi * s1 * s2 * np.sqrt(1 - rho**2))\n    \n    # Standardized variables\n    z1 = (R1 - mu1) / s1\n    z2 = (R2 - mu2) / s2\n    \n    # Quadratic form in the exponent\n    quad_form = (z1**2 - 2 * rho * z1 * z2 + z2**2) / (1 - rho**2)\n    \n    pdf_vals = const_C * (1 + quad_form / nu)**(- (nu + 2) / 2)\n\n    # 3b. CARA Utility U(W(r1, r2))\n    terminal_wealth = W0 * (1 + w1 * R1 + w2 * R2)\n    utility_vals = -np.exp(-a * terminal_wealth)\n\n    # 3c. Integrand g = U * f\n    integrand_vals = utility_vals * pdf_vals\n\n    # 4. Construct Simpson's weights\n    weights_x = np.ones(nx + 1)\n    weights_x[1:-1:2] = 4\n    weights_x[2:-1:2] = 2\n\n    weights_y = np.ones(ny + 1)\n    weights_y[1:-1:2] = 4\n    weights_y[2:-1:2] = 2\n    \n    # 5. Create 2D weight matrix\n    # meshgrid with 'xy' indexing makes R1, R2 have shape (ny+1, nx+1)\n    # The weight matrix must match this shape.\n    weight_matrix = np.outer(weights_y, weights_x)\n\n    # 6. Apply 2D Simpson's rule formula\n    integral_val = (h1 * h2 / 9.0) * np.sum(integrand_vals * weight_matrix)\n\n    return integral_val\n\nsolve()\n```"}]}