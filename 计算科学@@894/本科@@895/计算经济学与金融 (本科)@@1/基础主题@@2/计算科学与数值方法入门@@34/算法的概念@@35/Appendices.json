{"hands_on_practices": [{"introduction": "经济学中的许多决策涉及在多个冲突目标之间进行权衡。这个练习将指导你把一个复杂的个人决策过程——比如在超市购物——形式化为一个精确的、可执行的算法。通过构建一个多目标优化模型，你将学习如何量化和解决在预算限制下平衡成本、营养和个人偏好等因素的挑战，这是将经济理论转化为计算模型的关键一步 [@problem_id:2438877]。", "id": "2438877", "problem": "您的任务是在计算经济学和金融学的背景下，将一个风格化的消费者多属性选择问题建模为一个多目标优化问题，从而形式化算法这一概念，然后实现一个确定性算法，对小规模实例进行精确求解。消费者考虑超市中的商品，每种商品都具有一个属性向量 $[cost,\\, nutrition,\\, preference]$。消费者选择一个商品篮，该选择由一个二进制决策向量 $x \\in \\{0,1\\}^n$ 表示，并受预算约束的限制。\n\n建模基础：\n1. 预算约束下的理性选择：一个商品篮 $x$ 是可行的，当且仅当 $\\sum_{i=1}^n p_i x_i \\le B$，其中 $p_i$ 是商品 $i$ 的成本，$B$ 是预算。\n2. 多目标优化与帕累托支配：定义目标向量 $f(x) = [cost(x),\\, -nutrition(x),\\, -preference(x)]$，使得所有分量都最小化。一个可行商品篮 $x$ 被另一个可行商品篮 $y$ 帕累托支配，当且仅当 $f(y) \\le f(x)$ 按分量成立，且至少存在一个严格不等式。一个可行商品篮是帕累托有效的（非支配的），当且仅当没有其他可行商品篮能对其构成帕累托支配。\n3. 标量化（加权和）作为算法选择规则：在获得帕累托有效集后，通过最大化经过尺度归一化后的属性得分的加权和，来挑选单个商品篮。\n\n需实现的算法规范：\n给定一个测试用例，包含：\n- 一个商品列表，其属性为 $(p_i,\\, n_i,\\, s_i)$，其中 $i = 1,\\dots,n$，\n- 一个预算 $B$，\n- 一个非负权重向量 $w = (w_1,w_2,w_3)$，满足 $w_1 + w_2 + w_3 = 1$，分别对应于对可负担性、营养和偏好的重视程度，\n\n您的算法必须确定性地执行以下步骤：\n1. 枚举所有满足 $\\sum_{i=1}^n p_i x_i \\le B$ 的商品篮 $x \\in \\{0,1\\}^n$，生成可行集 $\\mathcal{F}$。\n2. 计算关于最小化 $[cost(x),\\, -nutrition(x),\\, -preference(x)]$ 的帕累托有效子集 $\\mathcal{P} \\subseteq \\mathcal{F}$。\n3. 对于每个可行商品篮 $x \\in \\mathcal{F}$，定义收益向量 $g(x) = [-cost(x),\\, nutrition(x),\\, preference(x)]$。对每个分量 $j \\in \\{1,2,3\\}$，计算 $m_j = \\min_{x \\in \\mathcal{F}} g_j(x)$ 和 $M_j = \\max_{x \\in \\mathcal{F}} g_j(x)$。定义归一化得分\n$$\nz_j(x) = \n\\begin{cases}\n0 & \\text{if } M_j = m_j, \\\\\n\\dfrac{g_j(x) - m_j}{M_j - m_j} & \\text{otherwise}.\n\\end{cases}\n$$\n然后计算加权和\n$$\nW(x) = w_1 z_1(x) + w_2 z_2(x) + w_3 z_3(x).\n$$\n4. 从 $\\mathcal{P}$ 中选择最大化 $W(x)$ 的单个商品篮 $\\hat{x}$。为保证唯一的确定性结果，当 $|W(x) - W(y)| \\le \\varepsilon$（其中 $\\varepsilon = 10^{-9}$）时，应用以下严格的平局打破规则：在得分持平的商品篮中，选择 $cost(x)$ 最小的一个；若仍然持平，选择 $nutrition(x)$ 最大的一个；若仍然持平，选择 $preference(x)$ 最大的一个；若仍然持平，选择所选商品索引排序列表字典序最小的一个。\n\n您的程序必须实现此算法，并为下面的每个测试用例生成选定的商品篮。用商品篮中所含商品索引的排序列表表示一个商品篮，使用从零开始的索引，即商品索引为 $0,1,\\dots,n-1$。如果选定的商品篮为空，则为该测试用例输出一个空列表 $[]$。\n\n角度单位不适用。不使用物理单位；所有数字均为无量纲数。\n\n测试套件：\n您的程序需要解决以下五个测试用例。对于每个用例，输入包括商品属性列表 $[p_i, n_i, s_i]$、预算 $B$ 和权重向量 $w = [w_1,w_2,w_3]$。\n\n- 测试用例 1：\n  - 商品：$[[3.5,\\, 6,\\, 7],\\ [2.0,\\, 4,\\, 5],\\ [5.0,\\, 9,\\, 6],\\ [4.0,\\, 5,\\, 8],\\ [1.5,\\, 3,\\, 3]]$。\n  - 预算：$B = 10.0$。\n  - 权重：$w = [0.4,\\, 0.4,\\, 0.2]$。\n- 测试用例 2：\n  - 商品：$[[1.0,\\, 2,\\, 2],\\ [1.0,\\, 2,\\, 2],\\ [2.0,\\, 3,\\, 5]]$。\n  - 预算：$B = 2.0$。\n  - 权重：$w = [0.2,\\, 0.3,\\, 0.5]$。\n- 测试用例 3：\n  - 商品：$[[2.0,\\, 10,\\, 0],\\ [3.0,\\, 0,\\, 10]]$。\n  - 预算：$B = 0.0$。\n  - 权重：$w = [\\tfrac{1}{3},\\, \\tfrac{1}{3},\\, \\tfrac{1}{3}]$。\n- 测试用例 4：\n  - 商品：$[[1.0,\\, 1,\\, 1],\\ [2.0,\\, 2,\\, 2],\\ [3.0,\\, 3,\\, 2],\\ [4.0,\\, 4,\\, 5]]$。\n  - 预算：$B = 10.0$。\n  - 权重：$w = [0.1,\\, 0.3,\\, 0.6]$。\n- 测试用例 5（用于测试确定性平局打破规则的显式平局）：\n  - 商品：$[[1.0,\\, 1,\\, 0],\\ [1.0,\\, 0,\\, 1]]$。\n  - 预算：$B = 1.0$。\n  - 权重：$w = [0.0,\\, 0.5,\\, 0.5]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个元素是对应测试用例的所选索引的排序列表。例如，包含三个测试用例的输出可能如下所示：$[[0,2],[1],[]]$。\n\n您的任务：编写一个完整、可运行的程序，该程序为给定的测试套件精确实现上述算法，并按指定的确切格式打印单行输出。", "solution": "该问题陈述经过严格验证，并被确定为有效。它在科学上基于微观经济学理论和多目标优化的既定原则，定义和约束条件完备且一致，表述清晰，属于适定问题，并以客观、形式化的语言表达。算法任务明确，确保了对于给定的测试用例可以计算出唯一的、确定性的解。因此，我们可以着手推导和实现解决方案。\n\n该问题要求实现一个确定性算法，以模拟消费者的多属性选择。此过程被形式化为一个多目标优化问题，通过首先确定帕累托有效解集，然后使用标量化的加权和方法选择单个最优商品篮来解决。该算法必须是精确的，并将依赖于穷举枚举，考虑到所提供测试用例中商品集的规模较小，这在计算上是可行的。\n\n方法步骤执行如下：\n\n1.  **生成可行集**：\n    对于一个给定的包含 $n$ 个商品的集合，存在 $2^n$ 个可能的商品篮。一个商品篮由一个二进制决策向量 $x \\in \\{0, 1\\}^n$ 表示，其中如果商品 $i$ 被包含在内，则 $x_i=1$，否则 $x_i=0$。对于每个可能的商品篮，其总成本计算为 $cost(x) = \\sum_{i=1}^n p_i x_i$。如果一个商品篮的成本不超过预算 $B$，则它被认为是可行的。所有此类可行商品篮的集合表示为 $\\mathcal{F}$。\n    $$ \\mathcal{F} = \\left\\{ x \\in \\{0,1\\}^n \\mid \\sum_{i=1}^n p_i x_i \\le B \\right\\} $$\n    计算并存储每个商品篮 $x$ 的属性，即总成本 $cost(x)$、总营养 $nutrition(x) = \\sum_{i=1}^n n_i x_i$ 和总偏好 $preference(x) = \\sum_{i=1}^n s_i x_i$。\n\n2.  **确定帕累托有效集**：\n    优化是针对目标向量 $f(x) = [cost(x), -nutrition(x), -preference(x)]$ 进行的，其中所有分量都要求最小化。一个可行商品篮 $x \\in \\mathcal{F}$ 被另一个可行商品篮 $y \\in \\mathcal{F}$ 帕累托支配，如果 $f(y)$ 在所有目标上均优于或等于 $f(x)$，并且至少在一个目标上严格优于 $f(x)$。形式上，如果对于所有 $j \\in \\{1, 2, 3\\}$ 都有 $f_j(y) \\le f_j(x)$ 且 $f(y) \\ne f(x)$，则 $y$ 支配 $x$。\n    帕累托有效集 $\\mathcal{P}$ 由所有不被任何其他可行商品篮帕累托支配的可行商品篮组成。\n    $$ \\mathcal{P} = \\{x \\in \\mathcal{F} \\mid \\nexists y \\in \\mathcal{F} \\text{ such that } y \\text{ Pareto-dominates } x\\} $$\n    此集合通过遍历 $\\mathcal{F}$ 中的所有商品篮对，并剔除任何被发现受支配的商品篮来构建。\n\n3.  **标量化与评分**：\n    为了从帕累托有效集 $\\mathcal{P}$ 中选择单个商品篮，应用了加权和方法。首先，为每个可行商品篮 $x \\in \\mathcal{F}$ 定义一个收益向量 $g(x) = [-cost(x), nutrition(x), preference(x)]$。然后将此向量的分量归一化到一个共同的尺度，通常是 $[0, 1]$。对于每个分量 $j \\in \\{1, 2, 3\\}$，在整个可行集 $\\mathcal{F}$ 上找到最小值 $m_j$ 和最大值 $M_j$：\n    $$ m_j = \\min_{x \\in \\mathcal{F}} g_j(x), \\quad M_j = \\max_{x \\in \\mathcal{F}} g_j(x) $$\n    商品篮 $x$ 的分量 $j$ 的归一化得分则为：\n    $$ z_j(x) = \\begin{cases} 0 & \\text{if } M_j = m_j \\\\ \\frac{g_j(x) - m_j}{M_j - m_j} & \\text{otherwise} \\end{cases} $$\n    使用给定的权重 $w = (w_1, w_2, w_3)$，为每个商品篮计算一个最终的标量得分 $W(x)$：\n    $$ W(x) = \\sum_{j=1}^3 w_j z_j(x) $$\n\n4.  **选择最优商品篮**：\n    最后一步是从帕累托有效集 $\\mathcal{P}$ 中选择最大化加权得分 $W(x)$ 的单个商品篮 $\\hat{x}$。为确保唯一和确定性的结果，应用了严格的平局打破规则。首先，构建一个候选集，包含 $\\mathcal{P}$ 中所有加权得分与在 $\\mathcal{P}$ 中找到的最大得分之差在容差 $\\varepsilon = 10^{-9}$ 以内的商品篮。如果此集合包含多个商品篮，则通过选择具有以下特征的商品篮来解决平局：\n    1.  最小的 $cost(x)$。\n    2.  如果仍然持平，则选择最大的 $nutrition(x)$。\n    3.  如果仍然持平，则选择最大的 $preference(x)$。\n    4.  如果仍然持平，则选择其排序后的商品索引列表在字典序上最小的商品篮。\n\n这个完整、确定性的程序保证了对于任何有效输入，都能选择一个唯一的、明确定义的最优商品篮，满足问题的所有约束。实现将忠实地执行这些步骤。", "answer": "```python\nimport numpy as np\nimport math\n\nclass Basket:\n    \"\"\"A class to represent a basket of items and its attributes.\"\"\"\n    def __init__(self, indices, cost, nutrition, preference):\n        self.indices = tuple(sorted(indices))\n        self.cost = cost\n        self.nutrition = nutrition\n        self.preference = preference\n        self.score = 0.0\n\n    def __repr__(self):\n        return f\"Basket(indices={self.indices}, cost={self.cost}, nutr={self.nutrition}, pref={self.preference})\"\n\ndef solve_case(items_list, budget, weights):\n    \"\"\"\n    Solves a single test case according to the problem specification.\n    \"\"\"\n    items = np.array(items_list)\n    n = items.shape[0]\n\n    # Step 1: Enumerate all feasible baskets\n    feasible_baskets = []\n    for i in range(2**n):\n        indices = [j for j in range(n) if (i >> j) & 1]\n        \n        if not indices:\n            basket_attrs = np.zeros(3)\n        else:\n            basket_attrs = items[indices, :].sum(axis=0)\n\n        cost, nutrition, preference = basket_attrs[0], basket_attrs[1], basket_attrs[2]\n\n        if cost <= budget:\n            feasible_baskets.append(Basket(indices, cost, nutrition, preference))\n\n    if not feasible_baskets:\n        return []\n\n    # Step 2: Compute the Pareto-efficient subset\n    pareto_set = []\n    for b1 in feasible_baskets:\n        is_dominated = False\n        f1 = np.array([b1.cost, -b1.nutrition, -b1.preference])\n        for b2 in feasible_baskets:\n            if b1 is b2:\n                continue\n            f2 = np.array([b2.cost, -b2.nutrition, -b2.preference])\n            if np.all(f2 <= f1) and np.any(f2 < f1):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_set.append(b1)\n\n    if not pareto_set:\n        # This case implies an empty feasible set, but with B>=0, the empty basket is always feasible.\n        # If such a case arises, the empty basket is the logical choice.\n        return []\n\n    # Step 3: Compute weighted scores\n    g_vectors = np.array([[-b.cost, b.nutrition, b.preference] for b in feasible_baskets])\n    \n    m = np.min(g_vectors, axis=0) if g_vectors.size > 0 else np.zeros(3)\n    M = np.max(g_vectors, axis=0) if g_vectors.size > 0 else np.zeros(3)\n    \n    deltas = M - m\n    \n    for b in pareto_set:\n        g_b = np.array([-b.cost, b.nutrition, b.preference])\n        z_b = np.zeros(3)\n        for j in range(3):\n            if deltas[j] != 0:\n                z_b[j] = (g_b[j] - m[j]) / deltas[j]\n        \n        b.score = np.dot(weights, z_b)\n\n    # Step 4: Select the single best basket from the Pareto set\n    if not pareto_set: # Should not happen if feasible_baskets is not empty\n        return []\n\n    max_score = -float('inf')\n    for b in pareto_set:\n        if b.score > max_score:\n            max_score = b.score\n            \n    epsilon = 1e-9\n    candidates = [b for b in pareto_set if abs(b.score - max_score) <= epsilon]\n\n    if len(candidates) == 1:\n        return list(candidates[0].indices)\n\n    # Apply tie-breaking rules by sorting\n    candidates.sort(key=lambda b: (b.cost, -b.nutrition, -b.preference, b.indices))\n    \n    return list(candidates[0].indices)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (\n            [[3.5, 6, 7], [2.0, 4, 5], [5.0, 9, 6], [4.0, 5, 8], [1.5, 3, 3]],\n            10.0,\n            [0.4, 0.4, 0.2]\n        ),\n        (\n            [[1.0, 2, 2], [1.0, 2, 2], [2.0, 3, 5]],\n            2.0,\n            [0.2, 0.3, 0.5]\n        ),\n        (\n            [[2.0, 10, 0], [3.0, 0, 10]],\n            0.0,\n            [1/3, 1/3, 1/3]\n        ),\n        (\n            [[1.0, 1, 1], [2.0, 2, 2], [3.0, 3, 2], [4.0, 4, 5]],\n            10.0,\n            [0.1, 0.3, 0.6]\n        ),\n        (\n            [[1.0, 1, 0], [1.0, 0, 1]],\n            1.0,\n            [0.0, 0.5, 0.5]\n        )\n    ]\n\n    results = []\n    for items, budget, weights in test_cases:\n        result = solve_case(items, budget, weights)\n        results.append(result)\n\n    # Format output as a single string\n    result_str_list = []\n    for res in results:\n        # Custom formatting to avoid spaces after commas in lists\n        result_str_list.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output = f\"[{','.join(result_str_list)}]\"\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "在设计算法时，我们常常面临简单启发式方法与更复杂但保证最优解的方法之间的选择。这个实践探讨了在一个跨期资源开采问题中，“短视”的贪心算法与“远见”的最优动态规划策略之间的差异 [@problem_id:2438788]。通过比较这两种算法的净现值 ($NPV$) 结果，你将亲身体会到算法策略如何深刻影响经济成果，并理解在序贯决策中“向前看”的重要性。", "id": "2438788", "problem": "考虑一个受计算经济学和金融学启发的有限期界资源开采问题。一家公司拥有一座包含不可再生资源的矿山。时间是离散的，有 $T$ 个时期，由 $t \\in \\{1,\\dots,T\\}$ 索引。公司在每个时期选择开采量 $x_t$，该选择受库存约束和各时期的运营能力限制。设初始库存为 $S \\ge 0$。设各时期的能力上限为 $u_t \\ge 0$。设矿石品位（一个作用于收入的乘法因子）为 $c_t \\ge 0$。设固定产出价格为 $p \\ge 0$。设各时期的凸性开采成本是二次的，参数为 $a > 0$。设跨期贴现因子为 $\\beta \\in (0,1]$。利润以贴现单位计算。\n\n在时期 $t$ 开采 $x_t$ 的各时期瞬时净收益由以下凹函数给出\n$$\nb_t(x_t) \\equiv p\\,c_t\\,x_t - \\frac{a}{2}\\,x_t^2,\n$$\n总贴现净现值 (NPV) 为\n$$\n\\sum_{t=1}^T \\beta^{t-1}\\, b_t(x_t).\n$$\n\n可行性约束为\n$$\n0 \\le x_t \\le u_t \\quad \\text{对所有 } t, \\qquad \\sum_{t=1}^T x_t \\le S.\n$$\n\n你的任务是实现并比较两种算法：\n\n- 一种短视的贪心算法：在每个时期 $t$，该算法选择 $x_t$ 以最大化当前时期的 $b_t(x_t)$，且仅受瞬时约束 $0 \\le x_t \\le \\min\\{u_t, s_t\\}$ 的限制，其中 $s_t$ 是在做出时期 $t$ 决策之前的剩余库存。贪心算法忽略了超出当前库存可行性之外的对未来时期的任何影响。选择 $x_t$ 后，通过 $s_{t+1} = s_t - x_t$ 更新剩余库存，初始库存为 $s_1 = S$。\n- 一种基于贝尔曼最优性原理的最优动态规划 (DP) 解法，该解法在所有约束条件下最大化总贴现净现值。你可以通过任何等价于求解该有限期界 DP 问题的正确算法来计算此最优解。\n\n对两种算法，计算贴现净现值\n$$\nV \\equiv \\sum_{t=1}^T \\beta^{t-1}\\, \\left(p\\,c_t\\,x_t - \\frac{a}{2}\\,x_t^2\\right).\n$$\n\n实现一个程序，对于以下测试套件，为每个参数集返回一个三元组，该三元组由最优 NPV、贪心 NPV 和一个相等性指标组成。如果两个 NPV 之间的绝对差最多为 $10^{-6}$，则该指标定义为 $1$，否则为 $0$。所有浮点数输出必须四舍五入到 6 位小数。\n\n测试套件（每个案例是一个元组 $\\left(T,\\ \\beta,\\ p,\\ a,\\ S,\\ \\mathbf{c},\\ \\mathbf{u}\\right)$，其中 $\\mathbf{c}=(c_1,\\dots,c_T)$ 且 $\\mathbf{u}=(u_1,\\dots,u_T)$）：\n\n- 案例 1：$T=4$, $\\beta=0.95$, $p=2.0$, $a=2.0$, $S=6.0$, $\\mathbf{c}=(1.0,\\ 1.5,\\ 1.2,\\ 1.1)$, $\\mathbf{u}=(5.0,\\ 5.0,\\ 5.0,\\ 5.0)$。\n- 案例 2：$T=3$, $\\beta=0.98$, $p=1.0$, $a=1.0$, $S=3.0$, $\\mathbf{c}=(1.0,\\ 2.0,\\ 5.0)$, $\\mathbf{u}=(10.0,\\ 10.0,\\ 10.0)$。\n- 案例 3：$T=3$, $\\beta=0.5$, $p=1.0$, $a=1.0$, $S=3.0$, $\\mathbf{c}=(5.0,\\ 2.0,\\ 1.0)$, $\\mathbf{u}=(10.0,\\ 10.0,\\ 10.0)$。\n- 案例 4：$T=4$, $\\beta=0.99$, $p=1.0$, $a=1.0$, $S=1.5$, $\\mathbf{c}=(2.0,\\ 2.0,\\ 10.0,\\ 2.0)$, $\\mathbf{u}=(10.0,\\ 10.0,\\ 1.0,\\ 10.0)$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序将所有测试案例的结果展开：对于案例 $i$，依次追加最优 NPV、贪心 NPV、然后是相等性指标（按此顺序），所有数值均按指定要求四舍五入。例如，输出必须如下所示\n$$\n[\\text{opt}_1,\\ \\text{greedy}_1,\\ \\text{eq}_1,\\ \\text{opt}_2,\\ \\text{greedy}_2,\\ \\text{eq}_2,\\ \\dots].\n$$", "solution": "首先对问题陈述进行严格的验证程序。\n\n**步骤 1：提取的既定条件**\n- **时间期界**：离散， $T$ 个时期， $t \\in \\{1,\\dots,T\\}$。\n- **决策变量**：开采量 $x_t$。\n- **参数**：初始库存 $S \\ge 0$，各时期能力 $u_t \\ge 0$，矿石品位 $c_t \\ge 0$，产出价格 $p \\ge 0$，成本参数 $a > 0$，贴现因子 $\\beta \\in (0,1]$。\n- **目标函数**：最大化总贴现净现值 (NPV)，$V = \\sum_{t=1}^T \\beta^{t-1}\\, b_t(x_t)$，其中各时期净收益为 $b_t(x_t) \\equiv p\\,c_t\\,x_t - \\frac{a}{2}\\,x_t^2$。\n- **约束**：\n    1. 能力：对所有 $t$，$0 \\le x_t \\le u_t$。\n    2. 库存：$\\sum_{t=1}^T x_t \\le S$。\n- **算法**：\n    1. **贪心算法**：在每个时期 $t$，选择 $x_t$ 以最大化 $b_t(x_t)$，约束条件为 $0 \\le x_t \\le \\min\\{u_t, s_t\\}$，其中 $s_t$ 是剩余库存。\n    2. **最优算法**：一个动态规划解法或等价方法，以在所有约束下最大化总贴现 NPV。\n- **输出要求**：对每个测试案例，提供一个三元组：（最优 NPV，贪心 NPV，相等性指标）。如果绝对差 $\\le 10^{-6}$，则指标为 $1$，否则为 $0$。输出必须四舍五入到 6 位小数。提供了测试案例。\n\n**步骤 2：验证**\n- **科学依据**：该问题是一个典型的有限期界资源开采模型，是计算经济学和资源经济学中的一个基本主题。该模型基于已确立的经济学原理。它是有效的。\n- **适定性**：目标函数 $\\sum \\beta^{t-1} (p c_t x_t - \\frac{a}{2} x_t^2)$ 是关于向量 $\\mathbf{x} = (x_1, \\dots, x_T)$ 的严格凹函数，因为 $a>0$ 且 $\\beta>0$。由线性不等式定义的可行集是凸且紧致的。在一个非空、紧致、凸集上最大化一个严格凹函数，其解是唯一的。该问题是适定的。\n- **客观且完整**：该问题使用精确的数学语言进行描述，并为给定的测试案例提供了所有必要的数据。它是有效的。\n\n**步骤 3：结论**\n该问题是有效的。我们继续进行求解。\n\n该问题要求实现并比较两种用于资源开采问题的算法。\n\n**贪心算法**\n贪心算法是短视的。在每个时期 $t$，它仅在当前约束下最大化当前时期的收益 $b_t(x_t) = p c_t x_t - \\frac{a}{2} x_t^2$。函数 $b_t(x_t)$ 是一个开口向下的抛物线。其无约束最大值可以通过将其关于 $x_t$ 的导数设为零来找到：\n$$\n\\frac{d b_t(x_t)}{d x_t} = p c_t - a x_t = 0 \\implies x_t^* = \\frac{p c_t}{a}\n$$\n贪心决策者在时期 $t$ 面临的约束是能力上限 $u_t$ 和剩余库存 $s_t$。因此，选择必须满足 $0 \\le x_t \\le \\min\\{u_t, s_t\\}$。由于 $p, c_t, a$ 是非负的，所以 $x_t^* \\ge 0$。因此，贪心选择 $x_t^g$ 是无约束最优解 $x_t^*$ 在可行区间上的投影：\n$$\nx_t^g = \\min\\left(\\frac{p c_t}{a}, u_t, s_t\\right)\n$$\n该算法通过从 $t=1$ 到 $T$ 进行迭代，计算 $x_t^g$，并用 $s_{t+1} = s_t - x_t^g$ 更新剩余库存，初始库存为 $s_1 = S$。然后使用得到的开采路径 $\\{x_t^g\\}_{t=1}^T$ 计算总 NPV。\n\n**最优算法**\n该问题是一个凸优化问题，具体来说是一个二次规划 (QP) 问题，因为其目标是二次的，约束是线性的。虽然可以用通用 QP 求解器求解，但通过分析 Karush-Kuhn-Tucker (KKT) 条件可以得到一种更有效的方法。\n\n该优化问题的拉格朗日函数是：\n$$\n\\mathcal{L}(\\mathbf{x}, \\lambda, \\boldsymbol{\\mu}, \\boldsymbol{\\nu}) = \\sum_{t=1}^T \\beta^{t-1}\\left(p c_t x_t - \\frac{a}{2} x_t^2\\right) - \\lambda\\left(\\sum_{t=1}^T x_t - S\\right) - \\sum_{t=1}^T \\mu_t(x_t - u_t) - \\sum_{t=1}^T \\nu_t(-x_t)\n$$\n其中 $\\lambda \\ge 0$、$\\mu_t \\ge 0$ 和 $\\nu_t \\ge 0$ 分别是总库存、各时期能力上限和各时期非负性约束的拉格朗日乘子。\n\n关于 $x_t$ 的平稳性一阶条件是：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x_t} = \\beta^{t-1}(p c_t - a x_t) - \\lambda - \\mu_t + \\nu_t = 0\n$$\n互补松弛条件意味着如果 $0 < x_t < u_t$，则 $\\mu_t = \\nu_t = 0$。在这种内部解情形下，最优开采量 $x_t$ 满足：\n$$\n\\beta^{t-1}(p c_t - a x_t) = \\lambda \\implies p c_t - a x_t = \\lambda \\beta^{-(t-1)} \\implies x_t = \\frac{p c_t - \\lambda \\beta^{-(t-1)}}{a}\n$$\n$\\lambda$ 项是资源库存 $S$ 的影子价格。该条件表明，在所有开采量为正且不处于边界的时期，贴现的边际开采利润必须等于这个影子价格。\n考虑边界条件（$x_t=0$ 或 $x_t=u_t$），对于给定的 $\\lambda$，最优开采量 $x_t^*$ 为：\n$$\nx_t^*(\\lambda) = \\text{max}\\left(0, \\min\\left(\\frac{p c_t - \\lambda \\beta^{-(t-1)}}{a}, u_t\\right)\\right)\n$$\n设 $X(\\lambda) = \\sum_{t=1}^T x_t^*(\\lambda)$。函数 $X(\\lambda)$ 是关于 $\\lambda$ 的连续非增函数。$\\lambda$ 的正确值由总库存约束和互补松弛条件 $\\lambda(\\sum_{t=1}^T x_t^* - S) = 0$ 确定。\n\n寻找最优路径的算法如下：\n1.  假设库存约束不具约束力（对应于设置影子价格 $\\lambda=0$），计算总开采量。令其为 $X(0) = \\sum_t \\max(0, \\min(\\frac{p c_t}{a}, u_t))$。\n2.  如果 $X(0) \\le S$，则相对于其有利可图的开采机会，资源并不稀缺。最优解在 $\\lambda^*=0$ 时获得，且对所有 $t$ 都有 $x_t^* = x_t^*(0)$。\n3.  如果 $X(0) > S$，则库存约束具有约束力，要求 $\\lambda^* > 0$。我们必须找到满足市场出清条件 $X(\\lambda^*) = S$ 的唯一的 $\\lambda^* > 0$。这是一个求解方程 $g(\\lambda) = X(\\lambda) - S = 0$ 的一维求根问题。二分法或牛顿族方法（例如 Brent 法）可以高效地找到 $\\lambda^*$。$\\lambda$ 的搜索区间是 $[0, \\lambda_{max}]$，其中 $\\lambda_{max} = \\max_t(p c_t \\beta^{t-1})$ 是一个确保所有 $x_t=0$ 的上界。\n4.  一旦找到 $\\lambda^*$，就可以确定最优开采路径 $\\{x_t^*(\\lambda^*)\\}_{t=1}^T$，并可计算出最优 NPV。\n\n对于此问题结构，这种基于 KKT 的方法优于通用 QP 求解器。实现将使用 Brent 法进行求根，因为它既稳健又高效。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves a series of finite-horizon resource extraction problems using both a greedy\n    and an optimal algorithm, then compares the results.\n    \"\"\"\n\n    test_cases = [\n        (4, 0.95, 2.0, 2.0, 6.0, np.array([1.0, 1.5, 1.2, 1.1]), np.array([5.0, 5.0, 5.0, 5.0])),\n        (3, 0.98, 1.0, 1.0, 3.0, np.array([1.0, 2.0, 5.0]), np.array([10.0, 10.0, 10.0])),\n        (3, 0.5, 1.0, 1.0, 3.0, np.array([5.0, 2.0, 1.0]), np.array([10.0, 10.0, 10.0])),\n        (4, 0.99, 1.0, 1.0, 1.5, np.array([2.0, 2.0, 10.0, 2.0]), np.array([10.0, 10.0, 1.0, 10.0])),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T, beta, p, a, S, c, u = case\n        \n        # --- Greedy Algorithm ---\n        x_g = np.zeros(T)\n        s_rem = S\n        for t in range(T):\n            x_unconstrained = p * c[t] / a\n            x_g[t] = np.clip(x_unconstrained, 0, min(u[t], s_rem))\n            s_rem -= x_g[t]\n\n        # --- Optimal Algorithm ---\n        betas = beta ** np.arange(T)\n        \n        def get_x_opt(lam, T, p, a, beta, c, u):\n            \"\"\"Computes optimal extraction path for a given lambda.\"\"\"\n            beta_inv_powers = beta ** (-np.arange(T))\n            numerators = p * c - lam * beta_inv_powers\n            x_unbounded = numerators / a\n            return np.clip(x_unbounded, 0, u)\n\n        # Check if resource constraint is binding\n        x_opt_lam0 = get_x_opt(0, T, p, a, beta, c, u)\n        \n        if np.sum(x_opt_lam0) <= S:\n            lam_opt = 0.0\n            x_opt = x_opt_lam0\n        else:\n            # Resource constraint is binding, find lambda > 0\n            # Define the function whose root we want to find\n            def total_extraction_diff(lam):\n                return np.sum(get_x_opt(lam, T, p, a, beta, c, u)) - S\n            \n            # Find a safe upper bound for lambda search\n            # Any lambda larger than this will result in all xt <= 0\n            lam_upper_bound = np.max(p * c * (beta ** np.arange(T))) + 1.0\n\n            try:\n                lam_opt = brentq(total_extraction_diff, 0, lam_upper_bound, xtol=1e-12, rtol=1e-12)\n            except ValueError:\n                # Fallback if signs are not different, though theoretically they should be\n                lam_opt = 0.0 # Should not happen with this problem structure\n            \n            x_opt = get_x_opt(lam_opt, T, p, a, beta, c, u)\n\n        # --- NPV Calculation ---\n        def calculate_npv(x_path, T, beta, p, c, a):\n            npv = 0.0\n            for t in range(T):\n                benefit = p * c[t] * x_path[t] - (a / 2) * x_path[t]**2\n                npv += (beta**t) * benefit\n            return npv\n\n        greedy_npv = calculate_npv(x_g, T, beta, p, c, a)\n        optimal_npv = calculate_npv(x_opt, T, beta, p, c, a)\n\n        # --- Formatting and Appending Results ---\n        optimal_npv_rounded = round(optimal_npv, 6)\n        greedy_npv_rounded = round(greedy_npv, 6)\n        \n        eq_indicator = 1 if abs(optimal_npv - greedy_npv) <= 1e-6 else 0\n        \n        results.extend([f\"{optimal_npv_rounded:.6f}\", f\"{greedy_npv_rounded:.6f}\", eq_indicator])\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "简单的确定性规则一定会导致简单的、可预测的结果吗？这个练习将挑战这一直觉，展示一个由单一算法交易者主导的理想化市场模型。你将通过模拟发现，一个基于最近价格历史的简单交易规则，如何通过市场反馈循环引发复杂的、甚至是混沌的价格动态 [@problem_id:2438789]。这个练习揭示了计算经济学中的一个核心概念——涌现性，并强调了理解非线性动态在金融市场中的重要性。", "id": "2438789", "problem": "考虑一个风格化的资产市场，其中有一个确定性的、纯粹的算法交易者，其在时间 $t$ 的订单流（记为 $x_t$）仅取决于最近两次观测到的价格。令 $P_t$ 表示时间 $t$ 的价格，并将单步收益率定义为 $r_t = P_t - P_{t-1}$。该交易者遵循以下规则\n$$\nx_t = \\gamma \\, \\big(P_{t-1}-P_{t-2}\\big)\\left(1 - \\frac{P_{t-1}-P_{t-2}}{R_{\\max}}\\right),\n$$\n其中 $\\gamma &gt; 0$ 是一个响应参数，$R_{\\max} &gt; 0$ 设定了一个收益率尺度。价格影响机制对订单流是线性的：\n$$\nP_t = P_{t-1} + \\mu \\, x_t,\n$$\n其中 $\\mu &gt; 0$ 是市场影响参数。不存在随机性或外部干预。初始条件为 $P_{-1}$ 和 $P_0$，它们决定了初始收益率 $r_0 = P_0 - P_{-1}$。定义归一化收益率 $y_t = r_t / R_{\\max}$。\n\n任务：\n1) 对于下面测试套件中的每一组参数，从给定的初始条件开始，模拟上述规则所蕴含的确定性动力学。使用 $y_t$ 的轨迹，根据以下定义计算一维收益率映射的最大 Lyapunov 指数 $\\lambda$\n$$\n\\lambda = \\lim_{T \\to \\infty} \\frac{1}{T} \\sum_{t=1}^{T} \\ln \\left| \\frac{\\partial y_t}{\\partial y_{t-1}} \\right|,\n$$\n该计算沿给定算法和市场影响所生成的确定性轨迹进行，并理解任何有限时间的计算都是对此极限的近似。您不得引入任何随机性。使用提供的有限时间范围来近似该极限：丢弃前 $T_{\\mathrm{burn}}$ 步作为瞬态，然后对随后的 $T_{\\mathrm{eval}}$ 步进行平均。\n2) 对于每组参数，输出估计的最大 Lyapunov 指数，形式为一个实数。\n\n测试套件（每个元组为 $(\\mu,\\gamma,R_{\\max},P_{-1},P_0,T_{\\mathrm{burn}},T_{\\mathrm{eval}})$）：\n- 情况A: $(1.0,\\, 2.5,\\, 1.0,\\, 0.0,\\, 0.4,\\, 1000,\\, 5000)$\n- 情况B: $(1.0,\\, 3.2,\\, 1.0,\\, 0.0,\\, 0.4,\\, 1000,\\, 5000)$\n- 情况C: $(1.0,\\, 3.569945,\\, 1.0,\\, 0.0,\\, 0.4,\\, 1000,\\, 5000)$\n- 情况D: $(1.0,\\, 3.9,\\, 1.0,\\, 0.0,\\, 0.4,\\, 1000,\\, 5000)$\n- 情况E: $(1.0,\\, 4.0,\\, 1.0,\\, 0.0,\\, 0.4,\\, 1000,\\, 5000)$\n\n答案规格：\n- 对于每种情况，答案必须是表示估计的最大 Lyapunov 指数的单个实数（浮点数）。\n- 您的程序应生成单行输出，其中按顺序包含情况 A 到 E 的结果，格式为方括号内以逗号分隔的列表（例如 $[x_1,x_2,x_3,x_4,x_5]$），其中每个 $x_i$ 四舍五入到四位小数。", "solution": "所述问题具有科学依据、提法恰当且客观。所有必需的参数、初始条件和控制方程均已给出，构成了一个自洽且一致的数学问题。该模型虽然是风格化的，但它是确定性基于代理的市场模型的有效表示，并且使用 Lyapunov 指数对其进行分析是动力系统研究中的标准技术。其中不存在矛盾或模糊之处。因此，我们可以着手求解。\n\n该问题要求计算描述在算法交易者影响下的资产价格动力学系统的最大 Lyapunov 指数。任务的核心是首先建立支配系统演化的一维映射，然后应用 Lyapunov 指数的定义。\n\n让我们将时间 $t$ 的收益率定义为 $r_t = P_t - P_{t-1}$。价格影响机制由 $P_t = P_{t-1} + \\mu \\, x_t$ 给出，其中 $\\mu > 0$ 是市场影响参数，$x_t$ 是交易者的订单流。由此，我们可以直接用订单流来表示收益率：\n$$\nr_t = (P_{t-1} + \\mu \\, x_t) - P_{t-1} = \\mu \\, x_t\n$$\n\n订单流 $x_t$ 由以下规则确定：\n$$\nx_t = \\gamma \\, \\big(P_{t-1}-P_{t-2}\\big)\\left(1 - \\frac{P_{t-1}-P_{t-2}}{R_{\\max}}\\right)\n$$\n其中 $\\gamma > 0$ 是一个响应参数，$R_{\\max} > 0$ 是一个收益率尺度。认识到 $P_{t-1} - P_{t-2} = r_{t-1}$，我们可以将订单流重写为先前收益率的函数：\n$$\nx_t = \\gamma \\, r_{t-1}\\left(1 - \\frac{r_{t-1}}{R_{\\max}}\\right)\n$$\n\n将这个 $x_t$ 的表达式代入我们的 $r_t$ 方程，得到收益率的递推关系：\n$$\nr_t = \\mu \\gamma \\, r_{t-1}\\left(1 - \\frac{r_{t-1}}{R_{\\max}}\\right)\n$$\n\n问题要求基于归一化收益率 $y_t = r_t / R_{\\max}$ 进行分析。为了导出 $y_t$ 的映射，我们将整个递推关系除以 $R_{\\max}$：\n$$\n\\frac{r_t}{R_{\\max}} = \\mu \\gamma \\, \\frac{r_{t-1}}{R_{\\max}}\\left(1 - \\frac{r_{t-1}}{R_{\\max}}\\right)\n$$\n这个方程揭示了一个微妙之处。让我们仔细地进行代换。\n$$\ny_t = \\mu \\gamma \\, y_{t-1} \\left(1 - y_{t-1}\\right)\n$$\n这个推导是正确的。让我们再验证一次：\n$$\n\\frac{r_t}{R_{\\max}} = \\frac{1}{R_{\\max}} \\left[ \\mu \\gamma r_{t-1} - \\frac{\\mu \\gamma}{R_{\\max}} r_{t-1}^2 \\right] = \\mu \\gamma \\left(\\frac{r_{t-1}}{R_{\\max}}\\right) - \\frac{\\mu \\gamma}{R_{\\max}^2} (r_{t-1})^2 = \\mu \\gamma y_{t-1} - \\mu \\gamma \\left(\\frac{r_{t-1}}{R_{\\max}}\\right)^2 = \\mu \\gamma y_{t-1} - \\mu \\gamma y_{t-1}^2\n$$\n结果是 $y_t = \\mu \\gamma y_{t-1}(1-y_{t-1})$。这是标准的 logistic 映射，$y_t = f(y_{t-1})$，其中映射函数为 $f(y) = k y (1-y)$，控制参数 $k$ 是市场影响和交易者响应参数的乘积，$k = \\mu \\gamma$。\n\n一维映射的最大 Lyapunov 指数 $\\lambda$ 由下式给出：\n$$\n\\lambda = \\lim_{T \\to \\infty} \\frac{1}{T} \\sum_{t=1}^{T} \\ln \\left| \\frac{\\partial y_t}{\\partial y_{t-1}} \\right| = \\lim_{T \\to \\infty} \\frac{1}{T} \\sum_{t=1}^{T} \\ln \\left| f'(y_{t-1}) \\right|\n$$\n其中映射函数的导数为 $f'(y) = \\frac{d}{dy}[k y(1-y)] = k - 2ky$。该求和是在系统轨迹 $\\{y_0, y_1, y_2, \\dots\\}$ 上进行求值的。\n\n我们将按照规定，数值地近似这个极限。对于每组参数，我们执行以下步骤：\n1.  计算控制参数 $k = \\mu \\gamma$。\n2.  确定初始归一化收益率 $y_0 = (P_0 - P_{-1}) / R_{\\max}$。\n3.  从 $y_0$ 开始，模拟轨迹进行 $T_{\\mathrm{burn}} + T_{\\mathrm{eval}}$ 次迭代。丢弃前 $T_{\\mathrm{burn}}$ 次迭代，以使系统稳定到其吸引子上。\n4.  对于随后的 $T_{\\mathrm{eval}}$ 次迭代，我们计算映射导数绝对值的对数之和。Lyapunov 指数是这些值的平均值：\n    $$\n    \\lambda \\approx \\frac{1}{T_{\\mathrm{eval}}} \\sum_{t=T_{\\mathrm{burn}}}^{T_{\\mathrm{burn}}+T_{\\mathrm{eval}}-1} \\ln \\left| k - 2k y_t \\right|\n    $$\n    此处的求和是针对吸引子上的点 $y_t$ 进行的。\n\n对每个测试用例实施此程序，以获得估计的 Lyapunov 指数。所有情况的初始条件均为 $y_0 = (0.4 - 0.0) / 1.0 = 0.4$。参数 $k = \\mu\\gamma$ 在不同情况中有所变化，导致 logistic 映射出现不同的动力学区域（稳定不动点、周期循环和混沌），这将反映在 $\\lambda$ 的符号和大小上。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the Lyapunov exponent for a stylized\n    asset market model, which reduces to the logistic map.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (mu, gamma, R_max, P_m1, P_0, T_burn, T_eval)\n        (1.0, 2.5, 1.0, 0.0, 0.4, 1000, 5000),\n        (1.0, 3.2, 1.0, 0.0, 0.4, 1000, 5000),\n        (1.0, 3.569945, 1.0, 0.0, 0.4, 1000, 5000),\n        (1.0, 3.9, 1.0, 0.0, 0.4, 1000, 5000),\n        (1.0, 4.0, 1.0, 0.0, 0.4, 1000, 5000),\n    ]\n\n    results = []\n    for case in test_cases:\n        mu, gamma, R_max, P_m1, P_0, T_burn, T_eval = case\n\n        # Step 1: Calculate the control parameter k of the logistic map.\n        # The dynamics of the normalized return y_t = r_t / R_max follow\n        # the logistic map y_t = k * y_{t-1} * (1 - y_{t-1}),\n        # where k = mu * gamma.\n        k = mu * gamma\n\n        # Step 2: Calculate the initial normalized return y_0.\n        r_0 = P_0 - P_m1\n        y_0 = r_0 / R_max\n\n        # The state of the system is given by the normalized return y.\n        y = y_0\n        \n        # Step 3: Simulate the system.\n        log_deriv_sum = 0.0\n        \n        # The total number of iterations is the sum of burn-in and evaluation periods.\n        num_iterations = T_burn + T_eval\n\n        for t in range(num_iterations):\n            # The derivative of the map f(y) = k*y*(1-y) is f'(y) = k - 2*k*y.\n            # We evaluate ln|f'(y_t)| for t >= T_burn.\n            if t >= T_burn:\n                # The derivative value depends on the current state y.\n                # A potential issue is y=0.5, which makes the derivative zero\n                # and its logarithm negative infinity. With floating point arithmetic,\n                # an exact hit is highly improbable.\n                deriv_val = k - 2.0 * k * y\n                log_deriv_sum += np.log(np.abs(deriv_val))\n            \n            # Update the state to the next time step using the logistic map.\n            y = k * y * (1.0 - y)\n\n        # Step 4: Calculate the Lyapunov exponent as the average of the log-derivatives.\n        if T_eval > 0:\n            lyapunov_exp = log_deriv_sum / T_eval\n        else:\n            lyapunov_exp = 0.0 # Define as 0 if T_eval is 0.\n        \n        results.append(lyapunov_exp)\n\n    # Final print statement in the exact required format.\n    # The results are rounded to four decimal places.\n    formatted_results = [f\"{res:.4f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}