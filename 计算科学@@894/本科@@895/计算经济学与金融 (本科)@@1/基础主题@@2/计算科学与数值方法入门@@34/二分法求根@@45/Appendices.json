{"hands_on_practices": [{"introduction": "作为我们动手实践的第一步，我们将把二分法应用到宏观经济学的一个基石模型——索洛增长模型中。我们的目标是计算稳态人均资本存量（steady-state capital per worker），这是一个典型的求根问题。这个练习将帮助你对一个性质良好的经济学函数，首次实现基础的二分法算法，为你后续更复杂的应用打下坚实的基础 [@problem_id:2437951]。", "id": "2437951", "problem": "考虑一个确定性的人均形式索洛增长模型，其人均生产函数 $f(k)$ 是一个满足 $f(0)=0$ 的严格递增凹函数。人均资本的非负稳态 $k^\\ast$ 满足以下不动点方程：\n$$\ns\\, f(k^\\ast) - (\\delta + n)\\, k^\\ast = 0,\n$$\n其中 $s \\in (0,1)$ 是恒定储蓄率，$\\delta \\in (0,1)$ 是折旧率，而 $n \\ge 0$ 是外生人口增长率。在此问题的所有测试用例中，生产函数均为柯布-道格拉斯形式：\n$$\nf(k) = A\\, k^{\\alpha},\n$$\n其参数为 $A>0$ 和 $\\alpha \\in (0,1)$。\n\n定义函数\n$$\ng(k) = s\\, f(k) - (\\delta + n)\\, k.\n$$\n对于下方的每组参数集，在指定的闭区间 $[k_{\\min}, k_{\\max}]$ 内，函数 $g(k)$ 至少存在一个根 $k^\\ast \\ge 0$。您的任务是计算 $g(k)$ 在给定区间内的一个根 $k^\\ast$，该根满足以下任一终止条件：(i) 区间绝对宽度至多为 $\\varepsilon_x = 10^{-12}$，或 (ii) 函数绝对值满足 $|g(k^\\ast)| \\le \\varepsilon_f = 10^{-12}$。以下所有输入均为无单位量。储蓄率、折旧率和人口增长率均以小数（而非百分比）形式给出。\n\n测试套件（每个用例为一个元组 $(A,\\alpha,s,\\delta,n,k_{\\min},k_{\\max})$）：\n- 用例 1: $(1.0,\\, 0.33,\\, 0.25,\\, 0.08,\\, 0.02,\\, 10^{-6},\\, 10.0)$。\n- 用例 2: $(0.5,\\, 0.5,\\, 0.3,\\, 0.04,\\, 0.01,\\, 10^{-6},\\, 9.0)$。\n- 用例 3: $(1.0,\\, 0.4,\\, 0.0,\\, 0.05,\\, 0.01,\\, 0.0,\\, 5.0)$。\n- 用例 4: $(1.0,\\, 0.5,\\, 0.005,\\, 0.05,\\, 0.01,\\, 10^{-8},\\, 1.0)$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含按测试套件顺序排列的四个计算出的稳态资本水平，格式为方括号括起的、无空格的逗号分隔列表。\n- 每个值必须以浮点数形式打印，小数点后恰好保留 $8$ 位数字。\n- 例如，要求的格式形如 [$x_1,x_2,x_3,x_4$]，其中每个 $x_i$ 都四舍五入到小数点后 8 位。", "solution": "该问题要求在确定性 Solow 增长模型中，计算由 $k^\\ast$ 表示的非负人均稳态资本。该模型由人均柯布-道格拉斯生产函数 $f(k) = A k^\\alpha$ 定义。\n\n首先，有必要对问题陈述进行验证。\n\n**步骤 1：提取的已知信息**\n-   人均资本稳态 $k^\\ast$ 是满足方程 $s\\, f(k^\\ast) - (\\delta + n)\\, k^\\ast = 0$ 的一个不动点。\n-   参数包括储蓄率 $s \\in (0,1)$、折旧率 $\\delta \\in (0,1)$ 和人口增长率 $n \\ge 0$。\n-   生产函数具体为 $f(k) = A\\, k^{\\alpha}$，其中生产率参数 $A>0$，资本产出弹性 $\\alpha \\in (0,1)$。函数 $f(k)$ 严格递增、是凹函数，并满足 $f(0)=0$。\n-   任务是在指定区间 $[k_{\\min}, k_{\\max}]$ 内找到函数 $g(k) = s\\, f(k) - (\\delta + n)\\, k$ 的一个根。\n-   数值方法的终止条件是区间宽度至多为 $\\varepsilon_x = 10^{-12}$ 或函数绝对值大小至多为 $\\varepsilon_f = 10^{-12}$。\n-   测试用例以元组 $(A,\\alpha,s,\\delta,n,k_{\\min},k_{\\max})$ 的形式给出：\n    1.  $(1.0,\\, 0.33,\\, 0.25,\\, 0.08,\\, 0.02,\\, 10^{-6},\\, 10.0)$\n    2.  $(0.5,\\, 0.5,\\, 0.3,\\, 0.04,\\, 0.01,\\, 10^{-6},\\, 9.0)$\n    3.  $(1.0,\\, 0.4,\\, 0.0,\\, 0.05,\\, 0.01,\\, 0.0,\\, 5.0)$\n    4.  $(1.0,\\, 0.5,\\, 0.005,\\, 0.05,\\, 0.01,\\, 10^{-8},\\, 1.0)$\n\n**步骤 2：验证**\n该问题具有科学依据，因为它涉及标准的 Solow-Swan 新古典增长模型，这是宏观经济学中的一个基本概念。其数学表述是正确的。问题是客观且适定的。\n\n存在一个次要的不一致之处：一般性描述指出 $s \\in (0,1)$，而测试用例 3 指定了 $s=0.0$。这不是一个严重缺陷。对于 $s=0$ 这种极限情况，该模型仍然完全有效且具有经济学意义。它代表一个没有储蓄的经济体，其资本存量必将折旧至零。测试用例的具体参数必须优先于一般性描述。该问题仍然可解。\n\n函数 $g(k) = s A k^\\alpha - (\\delta+n)k$ 有两个潜在的非负根。\n1.  平凡稳态，$k=0$。这始终是一个根，因为根据约定，当 $\\alpha > 0$ 时 $0^\\alpha = 0$，所以有 $g(0) = s A (0)^\\alpha - (\\delta+n)(0) = 0$。\n2.  非平凡正稳态。对于 $k>0$ 的情况，我们可以求解 $s A k^{\\alpha-1} - (\\delta+n) = 0$。这可以得出 $k^{\\alpha-1} = \\frac{\\delta+n}{sA}$。由于 $\\alpha \\in (0,1)$，指数 $1-\\alpha$ 为正。因此，唯一的正根是：\n    $$\n    k^\\ast = \\left( \\frac{sA}{\\delta+n} \\right)^{\\frac{1}{1-\\alpha}}\n    $$\n    这个正稳态存在的充要条件是 $s > 0$。如果 $s=0$，则唯一的非负根是 $k=0$。\n\n$g(k)$ 的二阶导数是 $g''(k) = s A \\alpha (\\alpha-1) k^{\\alpha-2}$。已知 $s \\ge 0$，$A>0$，$\\alpha \\in (0,1)$，我们有对于所有 $k>0$ 都有 $g''(k) \\le 0$，这意味着 $g(k)$ 是一个凹函数。一个凹函数与横轴最多相交两次。这证实了最多只存在一个正根。\n\n问题要求在给定区间内找到根，这提示我们需要使用数值求根算法。二分法是一个合适且稳健的选择，因为问题陈述保证了对于每个用例，在给定的区间 $[k_{\\min}, k_{\\max}]$ 内都存在一个根，并且函数 $g(k)$ 是连续的。为保证该方法收敛，区间端点的函数值必须异号，即 $g(k_{\\min}) \\cdot g(k_{\\max}) < 0$。让我们为那些根不在边界上的用例验证这一点。\n-   用例 1：$k^\\ast \\approx 4.41 \\in [10^{-6}, 10.0]$。$g(10^{-6}) > 0$ 且 $g(10.0) < 0$。条件成立。\n-   用例 4：$k^\\ast \\approx 0.00694 \\in [10^{-8}, 1.0]$。$g(10^{-8}) > 0$ 且 $g(1.0) < 0$。条件成立。\n-   用例 2 和 3 的根位于区间边界之一。二分法的稳健实现必须在开始迭代过程之前，首先检查端点本身是否为根。\n\n**步骤 3：结论与行动**\n问题被认为是有效的。将提供一个解决方案。\n\n**求解方法**\n我们将实现二分法来寻找函数 $g(k) = sAk^\\alpha - (\\delta+n)k$ 在区间 $[a, b] = [k_{\\min}, k_{\\max}]$ 上的根。给定的容差为 $\\varepsilon_x = 10^{-12}$ 和 $\\varepsilon_f = 10^{-12}$。\n\n算法按以下步骤进行：\n1.  对于一组给定的参数 $(A, \\alpha, s, \\delta, n)$，定义函数 $g(k)$。\n2.  设置初始区间端点 $a = k_{\\min}$ 和 $b = k_{\\max}$。\n3.  计算 $g(a)$ 和 $g(b)$。如果 $|g(a)| \\le \\varepsilon_f$，则根为 $a$。如果 $|g(b)| \\le \\varepsilon_f$，则根为 $b$。在这些情况下，算法终止。\n4.  开始二分循环。使用最大迭代次数（例如 100 次）作为安全保障。\n5.  在每次迭代中，计算中点 $c = a + (b-a)/2$。\n6.  计算 $g_c = g(c)$。\n7.  检查终止条件：如果 $(b-a) \\le \\varepsilon_x$ 或 $|g_c| \\le \\varepsilon_f$，算法终止并返回 $c$作为根。\n8.  更新区间：令 $g_a = g(a)$。如果 $g_a \\cdot g_c < 0$，根位于 $[a, c]$ 内，因此我们设置 $b=c$。否则，根必定位于 $[c, b]$ 内，因此我们设置 $a=c$。\n9.  从步骤 5 开始重复，直到满足某个终止条件。\n\n此过程将应用于提供的四个测试用例中的每一个。对于用例 3，其中 $s=0$ 且 $k_{\\min}=0$，我们有 $g(k_{\\min})=g(0)=0$。算法将在初始检查中正确识别出 $k_{\\min}=0$ 为根。对于用例 2，其根位于 $k_{\\max}=9.0$，算法也将在初始检查中识别出这一点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state capital per worker for the Solow growth model\n    using the bisection method for different parameter sets.\n    \"\"\"\n\n    test_cases = [\n        # (A, alpha, s, delta, n, k_min, k_max)\n        (1.0, 0.33, 0.25, 0.08, 0.02, 1e-6, 10.0),\n        (0.5, 0.5, 0.3, 0.04, 0.01, 1e-6, 9.0),\n        (1.0, 0.4, 0.0, 0.05, 0.01, 0.0, 5.0),\n        (1.0, 0.5, 0.005, 0.05, 0.01, 1e-8, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        root = bisection_solver(*case)\n        results.append(root)\n\n    # Format the final output string as required.\n    output_str = f\"[{','.join([f'{r:.8f}' for r in results])}]\"\n    print(output_str)\n\ndef bisection_solver(A, alpha, s, delta, n, k_min, k_max):\n    \"\"\"\n    Finds a root of the Solow steady-state equation using the bisection method.\n\n    The function to find a root for is g(k) = s * A * k**alpha - (delta + n) * k.\n    \"\"\"\n    \n    eps_x = 1e-12\n    eps_f = 1e-12\n    max_iter = 100\n\n    # Define the function g(k) whose root we are seeking.\n    break_even_rate = delta + n\n    g = lambda k: s * A * k**alpha - break_even_rate * k\n\n    a = k_min\n    b = k_max\n\n    g_a = g(a)\n    if abs(g_a) <= eps_f:\n        return a\n    \n    g_b = g(b)\n    if abs(g_b) <= eps_f:\n        return b\n    \n    # Standard bisection method requires g(a) and g(b) to have opposite signs.\n    # The problem setup ensures this or that one endpoint is the root.\n    if g_a * g_b > 0:\n        # This state should not be reached with the given valid problem cases.\n        # It indicates an issue with the interval.\n        raise ValueError(\"Bisection method precondition failed: g(a) * g(b) > 0.\")\n        \n    c = a # Initialize c\n    for _ in range(max_iter):\n        c = a + (b - a) / 2\n        g_c = g(c)\n\n        # Check termination criteria\n        if (b - a) <= eps_x or abs(g_c) <= eps_f:\n            return c\n\n        if g_a * g_c < 0:\n            b = c\n        else:\n            a = c\n            g_a = g(a) # Update g_a for the new interval [a, b]\n            \n    return c\n\nsolve()\n```"}, {"introduction": "在掌握了二分法的基础实现后，理解其局限性与编写稳健的代码至关重要。本练习将引导我们探讨在金融计算中一个常见的陷阱：当搜索区间包含奇点时，算法可能会失效。通过分析债券定价公式中的定义域问题，你将学会重视算法背后的数学假设，例如函数的连续性，并编写出更能应对现实世界复杂情况的稳健程序 [@problem_id:2437948]。", "id": "2437948", "problem": "一位固定收益分析师通过求解使错误定价函数为零的利率 $r$ 来计算常规付息债券的到期收益率 (YTM)\n$$f(r) \\equiv \\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t} - P_{\\text{mkt}},$$\n其中 $T \\in \\mathbb{N}$ 是以期数为单位的到期时间，现金流满足 $C_t \\ge 0$ 且 $C_T > 0$，而 $P_{\\text{mkt}} > 0$ 是观测到的市场价格。该分析师计划在初始区间 $[a,b]$ 上使用二分法。考虑初始区间选择不当并包含点 $r=-1$ 的情况，即 $a < -1 < b$。\n\n哪个陈述最能描述将会发生什么，以及在这种情况下应如何使算法变得稳健？\n\nA. 只要 $f(a)f(b) < 0$，二分法仍然会收敛，因为即使 $f$ 在 $r=-1$ 处未定义，符号变化也足够了。不需要特殊处理。\n\nB. 二分法可能会失败或返回无意义的结果，因为 $f(r)$ 在 $r=-1$ 处未定义，并且在 $[a,b]$ 上不连续；跨越 $r=-1$ 的符号变化并不意味着存在根。稳健性要求强制执行定义域 $r>-1$（例如，通过使用 $x=\\log(1+r)$ 重新参数化，从而 $r=e^x-1$，并在 $x$ 中确定区间），并在完全位于可行域内的区间验证一个有效的括号区间，即满足 $f(a)f(b)<0$。\n\nC. 二分法只会受到数值溢出的影响；使用更小的中点容差并忽略任何非数值的求值，足以在 $[a,b]$ 包含 $-1$ 的情况下保持收敛性。\n\nD. 因为债券价格是关于 $r$ 的单调函数，任何初始区间 $[a,b]$ 最终都会引导二分法找到 YTM；如果遇到 $r=-1$，浮点运算会自动跳过它，因此无需更改。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n\n问题为债券的到期收益率 (YTM) $r$ 定义了一个错误定价函数：\n$$f(r) \\equiv \\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t} - P_{\\text{mkt}}$$\n参数和条件如下：\n- 到期时间: $T \\in \\mathbb{N}$\n- 现金流: 对于 $t=1, \\dots, T-1$，$C_t \\ge 0$，且 $C_T > 0$\n- 市场价格: $P_{\\text{mkt}} > 0$\n- 数值方法: 二分法\n- 搜索的初始区间: $[a,b]$\n- 考虑的特定场景: 区间包含 $r=-1$，使得 $a < -1 < b$。\n\n问题要求描述二分法算法的结果，以及如何使实现变得稳健。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题在固定收益分析和数值方法领域具有科学依据。债券现值的公式是标准的。使用像二分法这样的求根算法来寻找 YTM 是计算金融学中的一个常见应用。\n\n问题的关键在于对函数 $f(r)$ 和二分法要求的分析。二分法在两个条件下保证收敛到一个根：\n1. 函数 $f$ 必须在闭区间 $[a,b]$ 上是连续的。\n2. 函数在端点的值必须异号，即 $f(a)f(b) < 0$。\n\n问题陈述指引我们检查区间为 $[a,b]$ 且 $a < -1 < b$ 的情况。我们来考察函数 $f(r)$ 在 $r=-1$ 这一点的情况。求和式中每一项的分母是 $(1+r)^t$。当 $r=-1$ 时，对于任何 $t \\ge 1$，这个分母都变为 $(1-1)^t = 0^t = 0$。由于给定 $C_T > 0$（以及其他 $C_t \\ge 0$），求和式中至少有一项会尝试除以零。因此，函数 $f(r)$ 在 $r=-1$ 处有一条垂直渐近线，并且在任何包含此点的区间上都是不连续的。\n\n因此，该问题是适定的、完整的，并且没有矛盾。它设置了一个有效但有问题的场景，以测试对数值算法理论基础的理解。该问题不是不适定的、模糊的或琐碎的。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。它就二分法的局限性提出了一个清晰且可分析的场景。我将继续推导解答并评估各个选项。\n\n**解答推导**\n\n指导二分法的基本原理是介值定理 (IVT)。介值定理指出，对于一个在闭区间 $[a,b]$ 上连续的函数 $f$，如果 $f(a)$ 和 $f(b)$ 异号，则在 $(a,b)$ 中必然存在至少一点 $c$，使得 $f(c)=0$。\n\n在给定场景中，区间为 $[a,b]$ 且 $a < -1 < b$。函数 $f(r)$ 在 $r=-1$ 处不连续。因此，介值定理的主要假设被违反了。因此，即使 $f(a)f(b) < 0$，我们也无法断定在 $(a,b)$ 中存在根。符号变化可能发生在 $r=-1$ 的奇点两侧。例如，当 $r \\to -1^+$ 时，求和项 $\\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t}$ 趋于 $+\\infty$（因为 $C_t \\ge 0$ 且至少有一个 $C_t > 0$），所以 $f(r) \\to +\\infty$。当 $r \\to -1^-$ 时，项 $(1+r)^t$ 的符号将根据 $t$ 是偶数还是奇数而交替变化，但其绝对值仍会发散。这种不连续性意味着符号变化并不表示存在根。\n\n二分法算法通过计算中点 $c_k = (a_k+b_k)/2$ 并求值 $f(c_k)$ 来进行。如果初始区间 $[a,b]$ 包含 $-1$，中点序列最终可能会尝试在 $r=-1$ 或非常接近该点的位置求值 $f(r)$。这将导致一个致命错误（除以零）或数值溢出（一个非常大的浮点数），从而导致算法失败。基于 $f(c_k)$ 的符号来缩小区间的逻辑会失效，因为求值本身已经受到了破坏。\n\n要创建一个稳健的算法，必须遵守函数 $f(r)$ 的定义域。从金融角度看，折现因子 $1+r$ 必须为正，这意味着 $r > -1$。$-100\\%$ 或更低的收益率在经济上是无意义的，因为它意味着正的未来现金流具有无穷大或负的现值。YTM 的搜索必须被限制在定义域 $r \\in (-1, \\infty)$ 内。\n\n因此，一个稳健的程序必须：\n1.  确保选择的初始搜索区间 $[a,b]$ 满足 $a > -1$。\n2.  验证在这个定义域内找到了一个有效的括号区间，即对于 $-1 < a < b$，有 $f(a)f(b) < 0$。\n\n一种强制执行定义域约束的更精巧的技术是重新参数化问题。令 $x = \\log(1+r)$。这将定义域 $r \\in (-1, \\infty)$ 映射到整个实数轴 $x \\in (-\\infty, \\infty)$。逆变换是 $r = e^x - 1$。函数变为：\n$$g(x) = f(e^x-1) = \\sum_{t=1}^{T} \\frac{C_t}{(1+(e^x-1))^t} - P_{\\text{mkt}} = \\sum_{t=1}^{T} C_t e^{-xt} - P_{\\text{mkt}}$$\n这个函数 $g(x)$ 对于所有 $x \\in \\mathbb{R}$ 都是连续且良态的。二分法可以应用于任何实数区间 $[x_a, x_b]$ 上的 $g(x)$，而没有奇点的风险。一旦找到 $g(x)$ 的根 $x^*$，相应的收益率可以通过 $r^* = e^{x^*} - 1$ 求得。\n\n**逐项分析选项**\n\nA. 二分法仍然会收敛只要 $f(a)f(b) < 0$，因为即使 $f$ 在 $r=-1$ 处未定义，符号变化也足够了。不需要特殊处理。\n这个陈述根本上是错误的。二分法的收敛保证关键依赖于函数的连续性，而在这里该条件被违反了。跨越奇点的符号变化并不意味着存在根，并且当在奇点附近求值时，该算法很容易失败。\n**结论：错误**\n\nB. 二分法可能会失败或返回无意义的结果，因为 $f(r)$ 在 $r=-1$ 处未定义，并且在 $[a,b]$ 上不连续；跨越 $r=-1$ 的符号变化并不意味着存在根。稳健性要求强制执行定义域 $r>-1$（例如，通过使用 $x=\\log(1+r)$ 重新参数化，从而 $r=e^x-1$，并在 $x$ 中确定区间），并在完全位于可行域内的区间验证一个有效的括号区间，即满足 $f(a)f(b)<0$。\n这个陈述正确地指出了数学上的失败：连续性的缺失使二分法的前提无效。它正确地诊断出符号变化是不够的。它正确地指出了收益率的有效定义域 $r > -1$。它提出了一种通过重新参数化来确保稳健性的有效且标准的方法，并正确地陈述了需要在有效定义域内找到一个合适的括号区间的必要性。这个分析是完整和准确的。\n**结论：正确**\n\nC. 二分法只会受到数值溢出的影响；使用更小的中点容差并忽略任何非数值的求值，足以在 $[a,b]$ 包含 $-1$ 的情况下保持收敛性。\n这是错误的。问题是一个根本的数学不连续性问题，而不仅仅是数值精度问题。“忽略非数值求值”不是一个连贯的策略；如果函数无法在中点求值，算法就无法决定如何继续。改变容差并不能修复奇点。\n**结论：错误**\n\nD. 因为债券价格是关于 $r$ 的单调函数，任何初始区间 $[a,b]$ 最终都会引导二分法找到 YTM；如果遇到 $r=-1$，浮点运算会自动跳过它，因此无需更改。\n这是错误的。尽管在 $r > -1$ 的范围内，债券价格函数是单调的，但这个性质并不能让二分法克服其搜索区间内的奇点。关于浮点运算会“跳过”失败点的断言是荒谬的。像除以零这样的操作会引发异常或返回像 `Inf` 或 `NaN` 这样的 IEEE 754 特殊值，这将破坏算法的控制流。\n**结论：错误**", "answer": "$$\\boxed{B}$$"}, {"introduction": "现在，让我们将通过前面练习所打磨的技能，应用于固定收益证券分析中的一个核心实际问题。这个练习要求你计算可赎回债券的赎回收益率（Yield-to-Call, YTC），这是金融分析师的一项常规任务。通过解决这个问题，你将在一个全新的、真实的金融场景中，再次巩固和应用二分法，从而深刻体会到这一数值方法的实用性与通用性 [@problem_id:2437995]。", "id": "2437995", "problem": "你的任务是计算可赎回固定息票债券的年度名义赎回收益率 (YTC)，具体方法是使用二分法数值求解债券定价不动点方程。请使用纯数学术语进行推导，并考虑以下基本原理：当以正确的收益率进行贴现时，未来确定性现金流的现值等于观察到的市场价格。对于一只确定将在未来特定数量的付息期后被赎回的可赎回债券，其现金流包括到赎回日为止的定期息票，以及在赎回日支付的一笔最终合并款项，该款项等于最后一期息票加上赎回价格。假设不存在违约风险、采用确定性贴现，并且除了指定的离散复利外，不考虑其他计息天数约定。\n\n各量定义：\n- 令 $P$ 表示观察到的债券价格。\n- 令 $M$ 表示债券的面值。\n- 令 $\\kappa$ 表示年票面利率（以小数形式表示）。\n- 令 $m$ 表示每年的付息次数（一个整数）。\n- 令 $n$ 表示到赎回日为止的付息期数（一个整数）。\n- 令 $K$ 表示在赎回日收到的赎回价格。\n- 令 $y$ 表示年名义YTC，复利频率为 $m$（以小数形式表示）。\n- 令 $C$ 表示每期息票，由 $C = \\frac{\\kappa}{m} M$ 给出。\n- 令 $r$ 表示每期收益率，由 $r = \\frac{y}{m}$ 给出。\n- 令 $D_t(y)$ 表示第 $t$ 期的贴现因子，由 $D_t(y) = \\left(1 + \\frac{y}{m}\\right)^{-t}$ 给出。\n\n基本定价关系：\nYTC $y$ 是通过将现金流的现值与价格 $P$ 相等来隐式定义的：\n$$\nP = \\sum_{t=1}^{n-1} C \\cdot D_t(y) \\;+\\; \\big(C + K\\big)\\cdot D_n(y).\n$$\n等价地，定义函数\n$$\nf(y) = \\sum_{t=1}^{n-1} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} + \\frac{C + K}{\\left(1 + \\frac{y}{m}\\right)^n} - P,\n$$\n并求解 $y$ 使得 $f(y) = 0$。\n\n算法要求：\n- 实现二分法，在区间 $[y_{\\min}, y_{\\max}]$ 上求解 $f(y) = 0$，其中 $y_{\\min} > -m$ 以确保 $1 + \\frac{y}{m} > 0$。在迭代前，确保 $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$。\n- 使用一个终止规则：当 $y$ 的区间宽度最多为 $\\varepsilon$ 或对于给定的容差 $\\varepsilon$ 有 $|f(y)| \\le \\varepsilon$ 时，算法终止。\n- 使用最大迭代次数以防止无限循环。\n\n角度单位不适用。不涉及物理单位。所有利率必须以小数表示，不得使用百分号。\n\n测试套件：\n计算以下三种情况的YTC。每种情况由 $(M, \\kappa, m, n, K, P)$ 独立参数化：\n\n- 情况 A（单周期边界检查）：\n  - $M = 1000$, $\\kappa = 0.06$, $m = 2$, $n = 1$, $K = 1010$, $P = 1000$。\n- 情况 B（面值平价的理想路径）：\n  - $M = 1000$, $\\kappa = 0.06$, $m = 2$, $n = 10$, $K = 1000$, $P = 1000$。\n- 情况 C（零息票边缘案例）：\n  - $M = 1000$, $\\kappa = 0.00$, $m = 2$, $n = 4$, $K = 1000$, $P = 822.7024747919322$。\n\n数值设置：\n- 使用 $y_{\\min} = -0.90$, $y_{\\max} = 1.00$，$容差 \\varepsilon = 10^{-12}$，以及最大迭代次数 $100000$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，包含三个计算出的YTC值，四舍五入到8位小数，格式为用方括号括起来的逗号分隔列表，例如 $[0.01234567,0.07654321,0.00000000]$。", "solution": "所提出的问题是计算金融领域一个定义明确的练习，特别是关于债券赎回收益率的数值确定。任务是求解一个源自现金流贴现原理的非线性方程的根。这是数值方法的标准应用。该问题是有效的，因为它在科学上基于既定的金融理论，数学上一致，规范完整，并且是客观的。\n\n问题的核心是求解方程 $f(y) = 0$ 以得到年名义赎回收益率 $y$。函数 $f(y)$ 代表债券未来现金流的现值 ($PV$) 与其观察到的市场价格 $P$ 之间的差额。现金流包括 $n$ 笔息票支付和一笔最终的赎回价格 $K$ 的支付。\n\n定价方程如下：\n$$\nP = \\sum_{t=1}^{n-1} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} + \\frac{C + K}{\\left(1 + \\frac{y}{m}\\right)^n}\n$$\n其中 $C$ 是每期息票支付，$C = \\frac{\\kappa}{m} M$，$m$ 是每年的付息次数，$n$ 是到赎回日为止的付息期数。因此，待求解的函数是 $f(y) = PV(y) - P$，其中 $PV(y)$ 是方程的右侧。\n\n为了提高计算效率，我们可以认识到，贴现后息票的总和是一个几何级数。现值的一个更标准且等价的表示法是：\n$$\nPV(y) = \\sum_{t=1}^{n} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} + \\frac{K}{\\left(1 + \\frac{y}{m}\\right)^n}\n$$\n求和项是普通年金的现值，它有闭式表达式。令 $r = y/m$ 为每期贴现率，则该和为 $\\frac{C}{r}\\left(1 - (1+r)^{-n}\\right)$。因此，函数 $f(y)$ 可以写为：\n$$\nf(y) = \\frac{C}{y/m}\\left(1 - \\left(1+\\frac{y}{m}\\right)^{-n}\\right) + K\\left(1+\\frac{y}{m}\\right)^{-n} - P\n$$\n此公式在 $y \\neq 0$ 时有效。在 $y = 0$ 的特殊情况下，我们必须计算第一项的极限。当 $r \\to 0$ 时，对项 $\\frac{1-(1+r)^{-n}}{r}$ 使用 L'Hôpital's rule，我们发现极限为 $n$。因此，对于 $y = 0$，函数为：\n$$\nf(0) = C \\cdot n + K - P\n$$\n现值关于 $y$ 的导数是：\n$$\n\\frac{d(PV)}{dy} = \\sum_{t=1}^{n-1} C \\cdot \\frac{-t}{m}\\left(1+\\frac{y}{m}\\right)^{-t-1} + (C+K) \\cdot \\frac{-n}{m}\\left(1+\\frac{y}{m}\\right)^{-n-1}\n$$\n由于所有现金流（$C, K$）都是非负的，且参数 $t, n, m$ 都是正数，该导数对于有效域内（$y > -m$）的任何 $y$ 都是严格为负的。这证明了 $f(y)$ 是一个关于 $y$ 的严格单调递减函数。这个性质至关重要，因为它保证了如果在一个给定区间内存在一个根，这个根是唯一的。因此，二分法是寻找此根的一个合适且稳健的选择。\n\n二分法是一种迭代求根算法，它作用于一个区间 $[a, b]$，在该区间上函数 $f$ 在端点处具有相反的符号，即 $f(a) \\cdot f(b) \\le 0$。介值定理（Intermediate Value Theorem）保证了在 $[a, b]$ 中至少存在一个根。该算法按以下步骤进行：\n\n$1$. 用 $[y_{\\min}, y_{\\max}]$ 初始化搜索区间。验证 $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$。对于此问题，给定的区间是 $[-0.90, 1.00]$。\n\n$2$. 开始迭代，最多进行 $100000$ 次迭代。\n\n$3$. 在每次迭代中，计算区间的中点 $y_{mid} = \\frac{y_{\\min} + y_{\\max}}{2}$。\n\n$4$. 计算函数在中点的值 $f(y_{mid})$。\n\n$5$. 检查终止标准：\n    - 如果区间宽度 $(y_{\\max} - y_{\\min})$ 小于或等于容差 $\\varepsilon = 10^{-12}$。\n    - 或者如果函数在中点的绝对值 $|f(y_{mid})|$ 小于或等于容差 $\\varepsilon = 10^{-12}$。\n    - 如果任一条件满足，算法终止，并将 $y_{mid}$ 作为近似根。\n\n$6$. 如果未满足终止标准，则更新区间。由于 $f(y)$ 是单调递减的：\n    - 如果 $f(y_{mid}) > 0$，根必定位于区间的上半部分。我们设置 $y_{\\min} = y_{mid}$。\n    - 如果 $f(y_{mid}) < 0$，根必定位于区间的下半部分。我们设置 $y_{\\max} = y_{mid}$。\n    - 如果 $f(y_{mid}) = 0$，则找到了精确根，我们可以终止。\n\n$7$. 从第3步开始重复。\n\n该算法将被实现并应用于提供的三个测试案例中的每一个。对于每种情况，参数 $(M, \\kappa, m, n, K, P)$ 定义了函数 $f(y)$ 的一个特定实例。实现将使用现值的数值稳定且高效的闭式表达式，并对 $y=0$ 的情况进行特殊处理。\n\n三种情况的参数是：\n- 情况 A: $(M, \\kappa, m, n, K, P) = (1000, 0.06, 2, 1, 1010, 1000)$。\n- 情况 B: $(M, \\kappa, m, n, K, P) = (1000, 0.06, 2, 10, 1000, 1000)$。\n- 情况 C: $(M, \\kappa, m, n, K, P) = (1000, 0.00, 2, 4, 1000, 822.7024747919322)$。\n\n数值设置为 $y_{\\min} = -0.90$, $y_{\\max} = 1.00$，$ \\varepsilon = 10^{-12}$，以及最大迭代次数 = $100000$。每种情况最终计算出的收益率将按要求四舍五入到8位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Yield-to-Call (YTC) for callable bonds using the bisection method.\n    \"\"\"\n\n    def bisection(f, a, b, tol=1e-12, max_iter=100000):\n        \"\"\"\n        Finds the root of a function f within the interval [a, b] using the bisection method.\n\n        Args:\n            f (callable): The function for which to find a root.\n            a (float): The lower bound of the interval.\n            b (float): The upper bound of the interval.\n            tol (float): The tolerance for stopping criteria.\n            max_iter (int): The maximum number of iterations.\n\n        Returns:\n            float: The approximate root, or None if the method fails.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb > 0:\n            # This check is important, but for the given monotonic function and\n            # wide interval, it is expected to hold for all test cases.\n            return None\n\n        for _ in range(max_iter):\n            c = (a + b) / 2\n            fc = f(c)\n\n            # Stopping criteria\n            if (b - a) <= tol or abs(fc) <= tol:\n                return c\n\n            # Update interval\n            # Since the function is monotonically decreasing, we can use a simpler check\n            # if fa * fc < 0:\n            if fc > 0: # Root is in the upper half\n                a = c\n                # fa = fc # Not needed because we only compare fc to 0\n            else: # Root is in the lower half (or fc is 0)\n                b = c\n                # fb = fc\n        \n        return (a + b) / 2 # Return the best estimate after max_iter\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (M, kappa, m, n, K, P)\n        (1000, 0.06, 2, 1, 1010, 1000),\n        # Case B:\n        (1000, 0.06, 2, 10, 1000, 1000),\n        # Case C:\n        (1000, 0.00, 2, 4, 1000, 822.7024747919322),\n    ]\n\n    # Numerical settings\n    y_min = -0.90\n    y_max = 1.00\n    tolerance = 1e-12\n    max_iterations = 100000\n\n    results = []\n    for case in test_cases:\n        M, kappa, m, n, K, P = case\n        C = (kappa / m) * M\n\n        def f_ytc(y):\n            \"\"\"\n            The function f(y) = PV(y) - P whose root we are seeking.\n            \"\"\"\n            if m + y <= 0:  # Avoid division by zero or negative base in power for 1+y/m\n                return np.inf # Return a large number to guide the search away\n\n            if abs(y) < 1e-12: # Handle the case y -> 0\n                # Using L'Hopital's rule, the PV limit is C*n + K\n                pv = C * n + K\n            else:\n                r = y / m\n                # Use the closed-form expression for annuity present value\n                pv_coupons = (C / r) * (1 - (1 + r)**-n)\n                pv_principal = K * (1 + r)**-n\n                pv = pv_coupons + pv_principal\n            \n            return pv - P\n\n        # Solve for YTC using the bisection method\n        ytc = bisection(f_ytc, y_min, y_max, tol=tolerance, max_iter=max_iterations)\n        results.append(ytc)\n\n    # Format the results as specified\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}