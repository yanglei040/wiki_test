{"hands_on_practices": [{"introduction": "估算需求曲线是微观经济学中的一项基本任务。然而，当天真地将普通最小二乘法（OLS）应用于市场均衡数据时，我们可能会遇到一个被称为“内生性”的严重问题。这个练习 [@problem_id:2395000] 不仅要求你计算线性需求曲线的系数，更重要的是，它促使你批判性地思考当解释变量（价格）和被解释变量（数量）由一个相互作用的系统同时决定时，OLS 估计量为何可能会产生偏差。", "id": "2395000", "problem": "一个同质商品的竞争性市场在 $5$ 个时期内被观测到。对于每个时期 $t \\in \\{1,2,3,4,5\\}$，你观测到均衡价格 $P_t$（货币单位/单位）和均衡数量 $Q_t$（千单位）。你希望使用普通最小二乘法（OLS）来通过线性函数 $Q(P) = \\alpha + \\beta P$ 逼近需求曲线 $Q(P)$，该方法旨在最小化样本的残差平方和。观测到的数据为：\n$\\{(P_t,Q_t)\\}_{t=1}^5 = \\{(2,118),(4,110),(6,97),(8,89),(10,78)\\}$。\n哪个选项正确报告了基于这些数据得到的线性需求曲线的 OLS 估计值 $(\\alpha,\\beta)$，并给出了一个有效的经济统计学理由，解释为什么从均衡市场数据中估计时 OLS 很可能是有偏的？\n\nA. $\\hat{\\alpha} = 128.7$，$\\hat{\\beta} = -5.05$；OLS 很可能是有偏的，因为价格在市场均衡中是内生的：未观测到的需求冲击在移动 $Q$ 的同时也会影响市场出清价格 $P$，从而导致 $P$ 与回归误差项之间产生相关性。一个外生的成本转移变量可以作为工具变量来解决这个问题。\n\nB. $\\hat{\\alpha} = 98.4$，$\\hat{\\beta} = -5.05$；OLS 是无偏的，因为高斯-马尔可夫条件只要求误差项的均值为零，而不管其与 $P$ 的关系如何。\n\nC. $\\hat{\\alpha} = 128.7$，$\\hat{\\beta} = -5.05$；OLS 很可能是无偏的，因为价格 $P$ 是由计量经济学家选择的，因此不可能与回归误差项相关。\n\nD. $\\hat{\\alpha} = 128.7$，$\\hat{\\beta} = -4.00$；只有当 $Q$ 存在测量误差时，OLS 才会有偏，并且如果 $Q$ 被完美测量，偏误就会消失。", "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n### 第一步：提取已知信息\n- 背景是一个同质商品的竞争性市场。\n- 观测期包含 $n=5$ 个时期，索引为 $t \\in \\{1,2,3,4,5\\}$。\n- 对于每个时期，观测数据是均衡价格 $P_t$ 和均衡数量 $Q_t$。\n- 数据集为 $\\{(P_t,Q_t)\\}_{t=1}^5 = \\{(2,118),(4,110),(6,97),(8,89),(10,78)\\}$。\n- 目标是使用线性函数 $Q(P) = \\alpha + \\beta P$ 来逼近需求曲线 $Q(P)$。\n- 估计方法是普通最小二乘法（OLS），旨在最小化残差平方和。\n- 次要目标是为 OLS 估计中潜在的偏误提供一个有效的经济统计学理由。\n\n### 第二步：使用提取的已知信息进行验证\n1.  **科学或事实合理性**：该问题基于标准的微观经济学理论（供给和需求均衡）和计量经济学方法（需求函数的 OLS 估计）。在此背景下的联立性偏误概念是计量经济学中的一个经典主题。该问题在科学和事实上是合理的。\n2.  **无法形式化或不相关**：该问题是一个标准的、可形式化的计量经济学量化练习。它直接关系到在应用经济学背景下使用最小二乘法进行函数逼近的课题。\n3.  **不完整或矛盾的设置**：该问题提供了计算 OLS 估计值所需的所有必要数据和方法说明。有 $n=5$ 个观测值和 $k=2$ 个待估参数。由于回归量 $P_t$ 的值不完全相同，因此存在唯一的 OLS 解。该设置是完整和一致的。\n4.  **不切实际或不可行**：数据是数值，市场情景是标准的教科书案例。没有不切实际或不可行的条件。\n5.  **不适定或结构不良**：该问题是适定的且结构清晰。它要求进行一项特定的计算和一段特定的理论推理。所用术语是标准的且无歧义的。\n6.  **超出科学可验证范围**：计算可以通过算术进行验证，经济推理可以对照已建立的计量经济学原理进行验证。\n\n### 第三步：结论与行动\n问题陈述**有效**。将推导解答。\n\n### 解答推导\n线性回归模型指定为 $Q_t = \\alpha + \\beta P_t + \\epsilon_t$，其中 $\\epsilon_t$ 是误差项。$\\beta$ 和 $\\alpha$ 的 OLS 估计量由以下公式给出：\n$$ \\hat{\\beta} = \\frac{\\sum_{t=1}^n (P_t - \\bar{P})(Q_t - \\bar{Q})}{\\sum_{t=1}^n (P_t - \\bar{P})^2} $$\n$$ \\hat{\\alpha} = \\bar{Q} - \\hat{\\beta} \\bar{P} $$\n其中 $n=5$ 是观测数量，$\\bar{P}$ 是价格的样本均值，$\\bar{Q}$ 是数量的样本均值。\n\n首先，我们从数据 $\\{(2,118),(4,110),(6,97),(8,89),(10,78)\\}$ 计算必要的汇总统计量。\n\n1.  **计算样本均值：**\n    $$ \\sum_{t=1}^5 P_t = 2 + 4 + 6 + 8 + 10 = 30 $$\n    $$ \\bar{P} = \\frac{30}{5} = 6 $$\n    $$ \\sum_{t=1}^5 Q_t = 118 + 110 + 97 + 89 + 78 = 492 $$\n    $$ \\bar{Q} = \\frac{492}{5} = 98.4 $$\n\n2.  **计算 $P_t$ 的离差平方和：**\n    $$ \\sum_{t=1}^5 (P_t - \\bar{P})^2 = (2-6)^2 + (4-6)^2 + (6-6)^2 + (8-6)^2 + (10-6)^2 $$\n    $$ = (-4)^2 + (-2)^2 + 0^2 + 2^2 + 4^2 = 16 + 4 + 0 + 4 + 16 = 40 $$\n\n3.  **计算离差的交叉乘积之和：**\n    $$ \\sum_{t=1}^5 (P_t - \\bar{P})(Q_t - \\bar{Q}) = (2-6)(118-98.4) + (4-6)(110-98.4) + (6-6)(97-98.4) + (8-6)(89-98.4) + (10-6)(78-98.4) $$\n    $$ = (-4)(19.6) + (-2)(11.6) + (0)(-1.4) + (2)(-9.4) + (4)(-20.4) $$\n    $$ = -78.4 - 23.2 - 0 - 18.8 - 81.6 = -202 $$\n\n4.  **计算 OLS 估计值 $\\hat{\\beta}$ 和 $\\hat{\\alpha}$：**\n    $$ \\hat{\\beta} = \\frac{-202}{40} = -5.05 $$\n    $$ \\hat{\\alpha} = \\bar{Q} - \\hat{\\beta} \\bar{P} = 98.4 - (-5.05)(6) = 98.4 + 30.3 = 128.7 $$\n\nOLS 估计值为 $\\hat{\\alpha} = 128.7$ 和 $\\hat{\\beta} = -5.05$。\n\n接下来，我们评估关于偏误的理由。数据代表市场*均衡*。在竞争性市场中，均衡价格 $P_t$ 和数量 $Q_t$ 由供给曲线和需求曲线的交点同时决定。\n设结构模型为：\n- 需求：$Q_t^d = \\alpha + \\beta P_t + u_t$\n- 供给：$Q_t^s = \\gamma + \\delta P_t + v_t$\n- 均衡：$Q_t^d = Q_t^s = Q_t$\n\n项 $u_t$ 代表未观测到的需求冲击（例如，消费者品味、收入的变化），而 $v_t$ 代表未观测到的供给冲击（例如，投入成本、技术的变化）。\n当我们使用 OLS 估计需求方程 $Q_t = \\alpha + \\beta P_t + \\epsilon_t$ 时，回归误差项 $\\epsilon_t$ 等同于需求冲击 $u_t$。\n然而，均衡价格 $P_t$ 是通过令需求等于供给来决定的：\n$$ \\alpha + \\beta P_t + u_t = \\gamma + \\delta P_t + v_t $$\n求解 $P_t$ 得出：\n$$ P_t = \\frac{\\gamma - \\alpha}{\\beta - \\delta} + \\frac{v_t - u_t}{\\beta - \\delta} $$\n这个表达式表明，回归量 $P_t$ 是误差项 $u_t$ 的函数。这违反了 OLS 的外生性假设，该假设要求回归量与误差项不相关，即 $\\text{Cov}(P_t, u_t)=0$。这里，假设 $\\text{Cov}(u_t, v_t)=0$：\n$$ \\text{Cov}(P_t, u_t) = \\text{Cov}\\left(\\frac{v_t - u_t}{\\beta - \\delta}, u_t\\right) = \\frac{-\\text{Var}(u_t)}{\\beta - \\delta} $$\n由于 $\\text{Var}(u_t) > 0$，并且我们预期 $\\beta < 0$（需求斜率）和 $\\delta > 0$（供给斜率），分母 $\\beta - \\delta$ 为负。因此，$\\text{Cov}(P_t, u_t) > 0$。回归量和误差项之间的这种相关性导致 OLS 估计量有偏且不一致。这个问题被称为联立性偏误或内生性偏误。价格是一个内生变量。为了获得一致的估计，必须使用诸如工具变量法（IV）之类的方法，使用一个与价格相关但与需求冲击不相关的工具变量（例如，外生成本转移变量）。\n\n### 逐项分析\n\n**A. $\\hat{\\alpha} = 128.7$，$\\hat{\\beta} = -5.05$；OLS 很可能是有偏的，因为价格在市场均衡中是内生的：未观测到的需求冲击在移动 $Q$ 的同时也会影响市场出清价格 $P$，从而导致 $P$ 与回归误差项之间产生相关性。一个外生的成本转移变量可以作为工具变量来解决这个问题。**\n计算出的 $\\hat{\\alpha}$ 和 $\\hat{\\beta}$ 估计值是正确的。所提供的理由是对这种情况下联立性偏误的精确和正确的解释。它正确地指出了价格是内生的，未观测到的冲击在联立方程系统中的作用，以及由此产生的回归量和误差项之间的相关性。建议的解决方法，即使用像成本转移变量这样的工具变量，是标准的计量经济学方法。\n**结论：正确。**\n\n**B. $\\hat{\\alpha} = 98.4$，$\\hat{\\beta} = -5.05$；OLS 是无偏的，因为高斯-马尔可夫条件只要求误差项的均值为零，而不管其与 $P$ 的关系如何。**\n$\\hat{\\alpha} = 98.4$ 的值是错误的；它是 $\\bar{Q}$ 的值。其理由存在根本性缺陷。对于无偏性而言，一个关键的高斯-马尔可夫假设是回归量的外生性，即 $E[\\epsilon_t | P_t] = 0$，这意味着 $\\text{Cov}(P_t, \\epsilon_t) = 0$。关于误差项和回归量之间关系无关的说法是错误的，并且表明对计量经济学原理有严重的误解。\n**结论：错误。**\n\n**C. $\\hat{\\alpha} = 128.7$，$\\hat{\\beta} = -5.05$；OLS 很可能是无偏的，因为价格 $P$ 是由计量经济学家选择的，因此不可能与回归误差项相关。**\n数值估计是正确的。然而，其理由与问题陈述在事实上不一致。问题指明数据是从*市场均衡*中*观测*到的，而不是在计量经济学家设定价格的受控实验中生成的。在观测性研究中，价格由市场力量决定，是内生的，如上所述。\n**结论：错误。**\n\n**D. $\\hat{\\alpha} = 128.7$，$\\hat{\\beta} = -4.00$；只有当 $Q$ 存在测量误差时，OLS 才会有偏，并且如果 $Q$ 被完美测量，偏误就会消失。**\n$\\hat{\\beta} = -4.00$ 的值是错误的。其理由也是错误的。首先，即使数据被完美测量，联立性也会导致偏误。其次，声称偏误*仅*由 $Q$ 的测量误差引起是错误的。第三，在经典的变量误差模型的标准假设下，因变量（$Q$）的测量误差会增加估计量的方差但不会导致偏误，而回归量（$P$）的测量误差确实会导致偏误（衰减偏误）。该理由在多个点上都混乱且不正确。\n**结论：错误。**", "answer": "$$\\boxed{A}$$"}, {"introduction": "从一个警示性的例子转向一个完整的应用，我们现在将使用函数逼近来探索一个经典的公共经济学概念：拉弗曲线。在这个练习 [@problem_id:2395010] 中，你将从带有噪声的模拟数据中拟合一个多项式来表示税收收入与税率之间的关系。此任务的核心不仅是拟合模型，还包括使用交叉验证来选择最佳模型复杂度，并利用最终的近似函数来确定能使税收收入最大化的税率。", "id": "2395010", "problem": "考虑一个经济体，其中政府税收是平均税率的函数。设税率由 $t \\in [0,1]$ 表示（以小数而非百分比表示），并假设我们观察到由一个结构形式生成的、在不同税率下带有噪声的税收样本。您的任务是使用普通最小二乘法（OLS）拟合二次或三次多项式，以近似未知的拉弗曲线（税收作为税率的函数），然后使用拟合的近似值计算单位区间上使税收最大化的税率。\n\n从以下基本原理开始：\n- 给定样本对 $\\{(t_i, y_i)\\}_{i=1}^n$，一个 $d$ 次多项式为 $p_d(t) = \\sum_{j=0}^{d} \\beta_j t^j$。普通最小二乘法（OLS）通过最小化残差平方和 $\\sum_{i=1}^{n} (y_i - p_d(t_i))^2$ 来估计系数。\n- 模型选择可以通过 $K$ 折交叉验证来执行，该方法评估样本外预测误差，并选择具有最低平均验证误差的阶数 $d$。\n\n您的程序必须：\n1. 对每个测试用例，按如下方式模拟数据 $(t_i, y_i)$。抽取 $n$ 个独立税率 $t_i \\sim \\text{Uniform}[0,1]$。生成噪声 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。通过 $R_{\\text{true}}(t) = A \\cdot t \\cdot (1 - t)^k$ 定义真实税收函数。然后设置 $y_i = R_{\\text{true}}(t_i) + \\varepsilon_i$。所有随机性必须按照测试套件中的规定进行确定性播种。\n2. 对每个候选阶数 $d \\in \\{2,3\\}$，使用模拟数据通过 OLS 拟合 $p_d(t)$。\n3. 使用 $K$ 折交叉验证（$K=5$ 折，使用给定种子随机打乱）选择具有最低平均验证均方误差的阶数 $d$。如果出现平局，则优先选择较低的阶数。\n4. 在完整数据集上重新拟合所选阶数，以获得最终系数 $\\hat{\\beta}_j$。\n5. 通过在闭区间 $[0,1]$ 上最大化拟合的多项式 $p_d(t)$ 来计算估计的税收最大化税率 $\\hat{t}^\\star$。即，通过求解 $p_d'(t)=0$ 找到所有位于 $[0,1]$ 内的实数临界点，在这些点以及端点 $t=0$ 和 $t=1$ 处评估 $p_d(t)$，并将 $\\hat{t}^\\star$ 设置为最大值点。然后计算估计的最大税收 $\\hat{R}^\\star = p_d(\\hat{t}^\\star)$。\n6. 本问题不涉及角度。所有税率表示为 $[0,1]$ 内的小数，所有税收表示为不带百分号的实数。\n\n使用以下测试套件。对于每个用例，对所有随机操作（包括数据生成和折叠 shuffling）使用提供的种子，抽取 $n$ 个点，使用噪声标准差 $\\sigma$ 以及数据生成过程 $R_{\\text{true}}(t) = A \\cdot t \\cdot (1 - t)^k$ 的参数 $A$ 和 $k$：\n- 用例 1：种子 $42$，$n=40$，$\\sigma=0.005$，$A=1.0$，$k=1$。\n- 用例 2：种子 $123$，$n=50$，$\\sigma=0.01$，$A=1.0$，$k=2$。\n- 用例 3：种子 $7$，$n=25$，$\\sigma=0.05$，$A=1.0$，$k=2$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的列表，该列表包含三个子列表，每个子列表对应一个测试用例，顺序与上述相同。每个子列表必须为 $[d,\\ \\hat{t}^\\star,\\ \\hat{R}^\\star]$ 的形式，其中 $d$ 是所选的阶数（一个在 $\\{2,3\\}$ 内的整数），而 $\\hat{t}^\\star$ 和 $\\hat{R}^\\star$ 四舍五入到恰好六位小数。例如：$[[2,0.500000,0.250000],[3,0.333333,0.197531],[2,0.480000,0.210000]]$。", "solution": "根据指定标准对问题进行验证。\n\n**第 1 步：提取已知条件**\n- **定义域**：税率 $t \\in [0,1]$。\n- **数据**：样本对 $\\{(t_i, y_i)\\}_{i=1}^n$。\n- **模型**：$d$ 次多项式，$p_d(t) = \\sum_{j=0}^{d} \\beta_j t^j$。\n- **估计方法**：普通最小二乘法（OLS），通过最小化残差平方和 $\\sum_{i=1}^{n} (y_i - p_d(t_i))^2$。\n- **模型选择**：$K$ 折交叉验证，$K=5$。选择具有最低平均验证误差的阶数 $d$。候选阶数为 $d \\in \\{2,3\\}$。平局时选择较低的阶数。\n- **数据生成过程**：\n    - $t_i \\sim \\text{Uniform}[0,1]$。\n    - 噪声 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n    - 真实税收函数 $R_{\\text{true}}(t) = A \\cdot t \\cdot (1 - t)^k$。\n    - 观测税收样本 $y_i = R_{\\text{true}}(t_i) + \\varepsilon_i$。\n- **优化**：通过在区间 $[0,1]$ 上最大化拟合的多项式 $p_d(t)$ 来找到使税收最大化的税率 $\\hat{t}^\\star$。估计的最大税收为 $\\hat{R}^\\star = p_d(\\hat{t}^\\star)$。\n- **测试用例**：\n    - 用例 1：种子=$42$，$n=40$，$\\sigma=0.005$，$A=1.0$，$k=1$。\n    - 用例 2：种子=$123$，$n=50$，$\\sigma=0.01$，$A=1.0$，$k=2$。\n    - 用例 3：种子=$7$，$n=25$，$\\sigma=0.05$，$A=1.0$，$k=2$。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据**：该问题具有科学依据。它提出了计量经济学和统计学中的一个标准任务：从带噪声的数据中进行函数近似。使用多项式回归、普通最小二乘法和交叉验证进行模型选择是基础且成熟的方法。拉弗曲线是经济学中的一个有效概念，所选的函数形式是一个数学上易于处理的模型。\n- **适定性**：该问题是适定的。所有必要的参数、数据生成过程和算法步骤都已明确定义。目标清晰，并且在给定确定性种子的情况下，每个测试用例都会产生唯一的计算结果。\n- **客观性**：问题陈述是客观的，使用了精确的数学和统计语言，没有主观或含糊不清的术语。\n\n**第 3 步：结论与行动**\n该问题有效。这是一个在应用统计学中定义明确的计算练习。将提供一个解决方案。\n\n---\n\n该问题要求我们从一组带噪声的观测数据中，近似一个表示税收与税率关系的未知函数。我们将使用多项式回归，并通过 $K$ 折交叉验证从候选集 $\\{2, 3\\}$ 中选择最优的多项式阶数。随后，我们将在有效定义域 $[0,1]$ 上找到使估计税收函数最大化的税率。\n\n**1. 数据生成**\n对于每个测试用例，我们都给定一个用于伪随机数生成器的种子、样本数量 $n$、噪声标准差 $\\sigma$ 以及真实税收函数的参数 $A$ 和 $k$。数据点 $(t_i, y_i)$（其中 $i=1, \\dots, n$）的生成方式如下：\n- 税率 $t_i$ 从区间 $[0, 1]$ 上的均匀分布中抽取，即 $t_i \\sim \\text{U}[0, 1]$。\n- 相应的真实税收使用 $R_{\\text{true}}(t_i) = A \\cdot t_i \\cdot (1 - t_i)^k$ 计算。\n- 噪声项 $\\varepsilon_i$ 从均值为 $0$、方差为 $\\sigma^2$ 的正态分布中抽取，即 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。\n- 观测到的税收为 $y_i = R_{\\text{true}}(t_i) + \\varepsilon_i$。\n\n**2. 通过普通最小二乘法（OLS）进行多项式回归**\n我们试图用一个 $d$ 次多项式 $p_d(t) = \\sum_{j=0}^{d} \\beta_j t^j$来近似真实函数。其系数 $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\dots, \\beta_d]^T$ 通过最小化残差平方和（SSR）来估计：\n$$\n\\text{SSR}(\\boldsymbol{\\beta}) = \\sum_{i=1}^{n} (y_i - p_d(t_i))^2\n$$\n这是一个线性最小二乘问题。设 $\\mathbf{y} = [y_1, \\dots, y_n]^T$ 为观测税收向量。设 $\\mathbf{X}$ 为 $n \\times (d+1)$ 的设计矩阵，对于多项式拟合，它是一个范德蒙矩阵：\n$$\n\\mathbf{X} =\n\\begin{pmatrix}\n1 & t_1 & t_1^2 & \\dots & t_1^d \\\\\n1 & t_2 & t_2^2 & \\dots & t_2^d \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & t_n & t_n^2 & \\dots & t_n^d\n\\end{pmatrix}\n$$\n问题是最小化 $||\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}||_2^2$。其解 $\\hat{\\boldsymbol{\\beta}}$ 由正规方程组给出：\n$$\n(\\mathbf{X}^T \\mathbf{X})\\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y}\n$$\n假设 $\\mathbf{X}^T \\mathbf{X}$ 可逆，则 OLS 估计值为 $\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$。在计算上，通常使用如 QR 分解等方法高效求解，这也是数值库通常采用的实现方式。\n\n**3. 通过 $K$ 折交叉验证进行模型选择**\n为了在二次（$d=2$）和三次（$d=3$）模型之间进行选择，我们使用 $K$ 折交叉验证（$K=5$）。该技术提供了模型样本外预测误差的估计，有助于防止过拟合。\n对于每个候选阶数 $d$，流程如下：\n1. 将包含 $n$ 个样本的数据集随机打乱，并分割成 $K=5$ 个大小几乎相等的互斥子集（折）。\n2. 对每一折 $k \\in \\{1, 2, 3, 4, 5\\}$：\n   a. 第 $k$ 折被指定为验证集。其余的 $K-1$ 折合并构成训练集。\n   b. 在训练集上使用 OLS 拟合一个 $d$ 次多项式，得到系数 $\\hat{\\boldsymbol{\\beta}}^{(k)}$。\n   c. 在验证集上计算均方误差（MSE）：$MSE_k = \\frac{1}{|N_k|} \\sum_{i \\in \\text{fold } k} (y_i - p_d(t_i; \\hat{\\boldsymbol{\\beta}}^{(k)}))^2$，其中 $|N_k|$ 是第 $k$ 折中的样本数。\n3. 阶数 $d$ 的交叉验证分数为这些 MSE 的平均值：$CV(d) = \\frac{1}{K} \\sum_{k=1}^{K} MSE_k$。\n最优阶数 $d^\\star$ 被选为最小化该分数的阶数：$d^\\star = \\arg\\min_{d \\in \\{2,3\\}} CV(d)$。如果 $CV(2) = CV(3)$，我们选择更简单的模型，即 $d^\\star=2$。\n\n**4. 所选模型的优化**\n一旦选定最优阶数 $d^\\star$，就在整个数据集上重新拟合多项式模型，以获得最终的系数向量 $\\hat{\\boldsymbol{\\beta}}$。我们将最终的估计税收函数表示为 $p_{d^\\star}(t)$。\n\n下一步是在闭区间 $[0, 1]$上找到使该函数最大化的税率 $\\hat{t}^\\star$。根据极值定理，闭区间上的连续函数必能达到其最大值和最小值。最大值点必须位于区间的端点（$t=0$ 或 $t=1$）或导数 $p'_{d^\\star}(t)$ 为零的内部临界点。\n\n该多项式的导数为 $p'_{d^\\star}(t) = \\sum_{j=1}^{d^\\star} j \\hat{\\beta}_j t^{j-1}$。\n- 如果 $d^\\star=2$，导数为 $p'_2(t) = \\hat{\\beta}_1 + 2\\hat{\\beta}_2 t$。令其为零得到一个临界点：$t_c = -\\frac{\\hat{\\beta}_1}{2\\hat{\\beta}_2}$。\n- 如果 $d^\\star=3$，导数为 $p'_3(t) = \\hat{\\beta}_1 + 2\\hat{\\beta}_2 t + 3\\hat{\\beta}_3 t^2$。这是一个二次方程。其根可以通过二次公式求得，最多可产生两个实数临界点。\n\n最大值点 $\\hat{t}^\\star$ 的候选值集合包括端点 $\\{0, 1\\}$ 以及落在区间 $[0, 1]$ 内的任何实数临界点。我们在每个候选点上评估 $p_{d^\\star}(t)$。产生最高税收的 $t$ 值即为估计的最优税率 $\\hat{t}^\\star$。\n$$\n\\hat{t}^\\star = \\arg\\max_{t \\in \\text{candidates}} p_{d^\\star}(t)\n$$\n然后，估计的最大税收为 $\\hat{R}^\\star = p_{d^\\star}(\\hat{t}^\\star)$。对每个测试用例都遵循此程序以生成最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Laffer curve approximation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (seed, n, sigma, A, k)\n        (42, 40, 0.005, 1.0, 1),\n        (123, 50, 0.01, 1.0, 2),\n        (7, 25, 0.05, 1.0, 2),\n    ]\n\n    all_results = []\n    \n    for seed, n, sigma, A, k_param in test_cases:\n        # Set all sources of randomness for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Simulate data\n        t = rng.uniform(0, 1, n)\n        true_revenue = A * t * (1 - t)**k_param\n        noise = rng.normal(0, sigma, n)\n        y = true_revenue + noise\n\n        # 2. & 3. Model selection using 5-fold cross-validation\n        K = 5\n        indices = np.arange(n)\n        rng.shuffle(indices)\n        folds = np.array_split(indices, K)\n        \n        candidate_degrees = [2, 3]\n        cv_errors = {}\n\n        for d in candidate_degrees:\n            fold_mses = []\n            for k_fold_idx in range(K):\n                val_indices = folds[k_fold_idx]\n                train_indices = np.concatenate([folds[i] for i in range(K) if i != k_fold_idx])\n\n                t_train, y_train = t[train_indices], y[train_indices]\n                t_val, y_val = t[val_indices], y[val_indices]\n\n                # Fit model on training data\n                X_train = np.vander(t_train, d + 1, increasing=True)\n                coeffs, _, _, _ = np.linalg.lstsq(X_train, y_train, rcond=None)\n\n                # Evaluate on validation data\n                X_val = np.vander(t_val, d + 1, increasing=True)\n                y_pred_val = X_val @ coeffs\n                mse = np.mean((y_val - y_pred_val)**2)\n                fold_mses.append(mse)\n            \n            cv_errors[d] = np.mean(fold_mses)\n\n        # Select the best degree, preferring the lower degree in case of a tie\n        if cv_errors[2] <= cv_errors[3]:\n            d_star = 2\n        else:\n            d_star = 3\n\n        # 4. Refit the chosen model on the full dataset\n        X_full = np.vander(t, d_star + 1, increasing=True)\n        # beta has shape (d_star + 1,) where beta[j] is the coefficient for t^j\n        beta, _, _, _ = np.linalg.lstsq(X_full, y, rcond=None)\n\n        # 5. Compute the estimated revenue-maximizing tax rate\n        \n        # Derivative coefficients: p'(t) = sum_{j=1 to d} j * beta[j] * t^(j-1)\n        # np.roots expects coefficients in descending power order\n        # For p'(t) = c_0*t^(d-1) + ... + c_{d-1}, coeffs are [c_0, ..., c_{d-1}]\n        # c_m = (m+1)*beta[m+1] in our notation.\n        # So for np.roots, we need [(d_star)*beta[d_star], (d_star-1)*beta[d_star-1], ..., 1*beta[1]]\n        deriv_coeffs = [j * beta[j] for j in range(d_star, 0, -1)]\n        critical_points = np.roots(deriv_coeffs)\n        \n        # Candidate points for the maximum on [0, 1]\n        candidate_t = [0.0, 1.0]\n        for root in critical_points:\n            # Filter for real roots within the interval [0, 1]\n            if np.isreal(root) and 0.0 <= root.real <= 1.0:\n                candidate_t.append(root.real)\n        \n        candidate_t = np.unique(candidate_t)\n\n        # Evaluate the polynomial at candidate points to find the maximum\n        # np.polyval expects coefficients in descending power order [beta_d, ..., beta_0]\n        poly_coeffs_desc = beta[::-1]\n        candidate_R = np.polyval(poly_coeffs_desc, candidate_t)\n        \n        max_idx = np.argmax(candidate_R)\n        t_star = candidate_t[max_idx]\n        R_star = candidate_R[max_idx]\n\n        all_results.append(\n            f\"[{d_star},{t_star:.6f},{R_star:.6f}]\"\n        )\n        \n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"}, {"introduction": "函数逼近的威力在金融工程领域得到了充分的体现，尤其是在衍生品定价和风险管理中。这个练习 [@problem_id:2394969] 将引导你使用最小二乘法来创建一个复杂期权定价函数（Black-Scholes 模型）的多项式近似。这个练习的真正亮点在于，一旦我们有了这个易于处理的近似函数，我们就可以通过对其进行微分来估算期权的“希腊字母”（如 $\\Delta$ 和 $\\Gamma$），这些量对于对冲风险至关重要。", "id": "2394969", "problem": "您的任务是，将欧式看涨期权的价格函数近似为标的资产水平的单变量函数，然后通过微分该近似函数来计算敏感性指标（“希腊字母”）。\n\n对于一个欧式看涨期权，其标的资产水平为 $S$、行权价为 $K$、连续复利无风险利率为 $r$（以小数表示）、波动率为 $\\sigma$（以小数表示）、到期时间为 $T$（以年为单位），根据 Black–Scholes 模型，其价格为\n$$\nC(S) \\;=\\; S\\,\\Phi(d_1) \\;-\\; K\\,e^{-r T}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1 \\;=\\; \\frac{\\ln(S/K) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right) T}{\\sigma\\sqrt{T}}, \n\\qquad\nd_2 \\;=\\; d_1 \\;-\\; \\sigma\\sqrt{T},\n$$\n$\\Phi(\\cdot)$ 是标准正态分布的累积分布函数，$\\ln(\\cdot)$ 表示自然对数。期权的 Delta 和 Gamma 分别是价格对 $S$ 的一阶和二阶偏导数：\n$$\n\\Delta(S) \\;=\\; \\frac{\\partial C}{\\partial S}(S), \n\\qquad\n\\Gamma(S) \\;=\\; \\frac{\\partial^2 C}{\\partial S^2}(S).\n$$\n在 Black–Scholes 模型下，其解析公式为\n$$\n\\Delta_{\\mathrm{BS}}(S) \\;=\\; \\Phi(d_1), \n\\qquad\n\\Gamma_{\\mathrm{BS}}(S) \\;=\\; \\frac{\\phi(d_1)}{S\\,\\sigma\\,\\sqrt{T}},\n$$\n其中 $\\phi(\\cdot)$ 是标准正态概率密度函数。\n\n您的任务是，对每个指定的参数集，在给定的 $S$ 区间上使用采样点，为定价函数 $C(S)$ 构建一个 $m$ 次的最小二乘多项式近似。然后，通过对该多项式求一阶和二阶导数，计算指定评估点上的近似 Delta 和 Gamma，并最终报告这些近似值相对于 Black–Scholes 解析 Delta 和 Gamma 的绝对误差。\n\n对于每个测试用例：\n- 在闭区间 $[S_{\\min}, S_{\\max}]$ 上构建一个包含 $n$ 个点的等距网格 $\\{S_i\\}_{i=1}^n$。\n- 使用上面的 Black–Scholes 公式计算每个网格点上的确切价格 $y_i = C(S_i)$。\n- 令 $\\mathcal{P}_m$ 表示 $S$ 的次数至多为 $m$ 的多项式集合。计算最小二乘多项式逼近 $\\hat{C}_m \\in \\mathcal{P}_m$，使得 $\\sum_{i=1}^n \\left(y_i - \\hat{C}_m(S_i)\\right)^2$ 在 $\\hat{C}_m$ 的系数上最小化。\n- 对 $\\hat{C}_m$ 关于 $S$ 求导，以获得 $\\widehat{\\Delta}_m(S) = \\frac{\\mathrm{d}}{\\mathrm{d}S}\\hat{C}_m(S)$ 和 $\\widehat{\\Gamma}_m(S) = \\frac{\\mathrm{d}^2}{\\mathrm{d}S^2}\\hat{C}_m(S)$。\n- 在评估点 $S_0$ 处，计算绝对误差 $|\\widehat{\\Delta}_m(S_0) - \\Delta_{\\mathrm{BS}}(S_0)|$ 和 $|\\widehat{\\Gamma}_m(S_0) - \\Gamma_{\\mathrm{BS}}(S_0)|$。\n\n设计细节：\n- 所有利率和波动率必须按小数处理（例如，年化利率 $2\\%$ 输入并使用时为 $0.02$）。\n- 不涉及物理单位。此问题中没有角度。不要使用百分号表示任何答案。\n- 程序的最终输出必须是单行文本，包含一个由方括号括起来的逗号分隔的结果列表。每个测试用例贡献一个包含两个浮点数的内部列表，顺序为 $[\\text{DeltaError}, \\text{GammaError}]$，每个浮点数四舍五入到六位小数。例如，一个包含两个测试用例的输出应如下所示：$[[0.000123,0.045678],[0.000010,0.000200]]$。\n\n测试套件（每个项目指定了 $(K, r, \\sigma, T, S_{\\min}, S_{\\max}, n, m, S_0)$）：\n- 案例 A: $(100,\\, 0.02,\\, 0.2,\\, 0.5,\\, 50,\\, 150,\\, 101,\\, 5,\\, 100)$。\n- 案例 B: $(100,\\, 0.01,\\, 0.25,\\, 1.0,\\, 80,\\, 200,\\, 121,\\, 6,\\, 180)$。\n- 案例 C: $(100,\\, 0.03,\\, 0.05,\\, 1.0,\\, 80,\\, 120,\\, 81,\\, 5,\\, 100)$。\n- 案例 D: $(100,\\, 0.00,\\, 0.3,\\, 0.01,\\, 80,\\, 120,\\, 81,\\, 5,\\, 100)$。\n- 案例 E: $(120,\\, 0.02,\\, 0.2,\\, 1.0,\\, 60,\\, 120,\\, 121,\\, 5,\\, 60)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的结果列表，每个元素是对应于测试用例 A 到 E 的内部列表 $[\\text{DeltaError}, \\text{GammaError}]$，每个浮点数四舍五入到六位小数。", "solution": "所述问题已经过严格验证。它要求使用多项式最小二乘拟合来数值逼近欧式看涨期权的价格函数及其一阶和二阶导数——Delta 和 Gamma。其理论基础是作为数理金融学基本概念的 Black-Scholes 模型，以及作为数值分析标准工具的最小二乘法。所有参数、约束和目标都得到了充分明确和精确的说明。所提供的测试用例完全在模型和数值方法的有效域内。未发现任何科学或逻辑上的矛盾、歧义或信息缺失。因此，该问题被认为是有效、适定且具有科学依据的。我们可以着手构建解决方案。\n\n目标是将欧式看涨期权的 Black-Scholes 价格函数 $C(S)$ 近似为标的资产价格 $S$ 的一个多项式。该价格由以下公式给出：\n$$\nC(S) = S\\,\\Phi(d_1) - K\\,e^{-r T}\\,\\Phi(d_2)\n$$\n其中 $K$ 是行权价，$r$ 是无风险利率，$T$ 是到期时间，$\\sigma$ 是波动率，而 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)。$d_1$ 和 $d_2$ 的定义如下：\n$$\nd_1 = \\frac{\\ln(S/K) + \\left(r + \\frac{1}{2}\\sigma^2\\right) T}{\\sigma\\sqrt{T}}, \\quad d_2 = d_1 - \\sigma\\sqrt{T}\n$$\n问题要求我们生成一组包含 $n$ 个采样点的集合 $(S_i, y_i)$，其中网格 $\\{S_i\\}_{i=1}^n$ 在区间 $[S_{\\min}, S_{\\max}]$ 上等距分布，且 $y_i = C(S_i)$。然后我们寻找一个次数至多为 $m$ 的多项式 $\\hat{C}_m(S)$，\n$$\n\\hat{C}_m(S) = \\sum_{j=0}^{m} p_j S^{m-j}\n$$\n使得残差平方和 $L = \\sum_{i=1}^n (y_i - \\hat{C}_m(S_i))^2$ 最小化。这是一个经典的线性最小二乘问题。系数向量 $\\mathbf{p} = [p_0, p_1, \\dots, p_m]^T$ 可以通过求解正规方程 $(\\mathbf{X}^T \\mathbf{X})\\mathbf{p} = \\mathbf{X}^T \\mathbf{y}$ 得到，其中 $\\mathbf{y}$ 是价格 $y_i$ 的向量，$\\mathbf{X}$ 是设计矩阵，其元素为 $X_{ij} = S_i^{m-j}$。通常采用数值稳定的算法（如基于 QR 分解的算法）来求解该系统。\n\n一旦确定了逼近多项式 $\\hat{C}_m(S)$ 的系数，我们就可以方便地计算其导数，以近似期权的敏感性指标，即“希腊字母”。Delta ($\\Delta = \\frac{\\partial C}{\\partial S}$) 是对 $S$ 的一阶导数，Gamma ($\\Gamma = \\frac{\\partial^2 C}{\\partial S^2}$) 是二阶导数。这些指标的多项式近似为：\n$$\n\\widehat{\\Delta}_m(S) = \\frac{\\mathrm{d}}{\\mathrm{d}S}\\hat{C}_m(S) = \\sum_{j=0}^{m-1} (m-j) p_j S^{m-j-1}\n$$\n$$\n\\widehat{\\Gamma}_m(S) = \\frac{\\mathrm{d}^2}{\\mathrm{d}S^2}\\hat{C}_m(S) = \\sum_{j=0}^{m-2} (m-j)(m-j-1) p_j S^{m-j-2}\n$$\n然后在指定的点 $S_0$ 处计算这些近似的希腊字母。\n\n这些近似值的准确性通过与从 Black-Scholes 模型导出的 Delta 和 Gamma 解析公式进行比较来评估：\n$$\n\\Delta_{\\mathrm{BS}}(S) = \\Phi(d_1)\n$$\n$$\n\\Gamma_{\\mathrm{BS}}(S) = \\frac{\\phi(d_1)}{S\\,\\sigma\\,\\sqrt{T}}\n$$\n其中 $\\phi(\\cdot)$ 是标准正态分布的概率密度函数 (PDF)。绝对误差在评估点 $S_0$ 处计算：\n$$\n\\text{DeltaError} = |\\widehat{\\Delta}_m(S_0) - \\Delta_{\\mathrm{BS}}(S_0)|\n$$\n$$\n\\text{GammaError} = |\\widehat{\\Gamma}_m(S_0) - \\Gamma_{\\mathrm{BS}}(S_0)|\n$$\n每个测试用例的计算过程包括以下步骤：生成资产价格网格，计算这些点上的确切期权价格，拟合多项式，对其求导，在 $S_0$ 处评估近似和解析的希腊字母，最后计算绝对误差。将使用标准的数值库来处理正态分布函数以及多项式拟合和微分，以确保准确性和数值稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# language: Python\n# version: 3.12\n# libraries:\n#     - name: numpy\n#       version: 1.23.5\n#     - name: scipy\n#       version: 1.11.4\n\ndef black_scholes_call(S, K, T, r, sigma):\n    \"\"\"\n    Calculates the Black-Scholes price for a European call option.\n    Note: S can be a numpy array.\n    \"\"\"\n    # Ensure S is a float array to avoid potential type issues\n    S = np.asarray(S, dtype=float)\n    \n    # Handle the case where S is very close to zero\n    S[S < 1e-9] = 1e-9\n\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef black_scholes_delta(S, K, T, r, sigma):\n    \"\"\"\n    Calculates the analytical Black-Scholes Delta for a European call option.\n    \"\"\"\n    S = float(S)\n    if S < 1e-9:\n        S = 1e-9\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    return norm.cdf(d1)\n\ndef black_scholes_gamma(S, K, T, r, sigma):\n    \"\"\"\n    Calculates the analytical Black-Scholes Gamma for a European call option.\n    \"\"\"\n    S = float(S)\n    if S < 1e-9:\n        S = 1e-9\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    pdf_d1 = norm.pdf(d1)\n    return pdf_d1 / (S * sigma * np.sqrt(T))\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and generate the final output.\n    \"\"\"\n    # Test cases: (K, r, sigma, T, S_min, S_max, n, m, S0)\n    test_cases = [\n        (100, 0.02, 0.2, 0.5, 50, 150, 101, 5, 100),\n        (100, 0.01, 0.25, 1.0, 80, 200, 121, 6, 180),\n        (100, 0.03, 0.05, 1.0, 80, 120, 81, 5, 100),\n        (100, 0.00, 0.3, 0.01, 80, 120, 81, 5, 100),\n        (120, 0.02, 0.2, 1.0, 60, 120, 121, 5, 60),\n    ]\n\n    results = []\n    for case in test_cases:\n        K, r, sigma, T, S_min, S_max, n, m, S0 = case\n\n        # 1. Construct the grid and evaluate exact prices\n        S_grid = np.linspace(S_min, S_max, n)\n        y_grid = black_scholes_call(S_grid, K, T, r, sigma)\n\n        # 2. Compute the least-squares polynomial approximant\n        # np.polyfit returns coefficients in descending order of power\n        coeffs = np.polyfit(S_grid, y_grid, m)\n        \n        # 3. Differentiate the polynomial to get Greeks approximations\n        # np.poly1d creates a polynomial object from coefficients\n        C_poly = np.poly1d(coeffs)\n        Delta_poly = C_poly.deriv(1)\n        Gamma_poly = C_poly.deriv(2)\n\n        # 4. Evaluate approximated Greeks at the evaluation point S0\n        delta_approx = Delta_poly(S0)\n        gamma_approx = Gamma_poly(S0)\n\n        # 5. Evaluate analytical Greeks at S0\n        delta_exact = black_scholes_delta(S0, K, T, r, sigma)\n        gamma_exact = black_scholes_gamma(S0, K, T, r, sigma)\n\n        # 6. Compute absolute errors\n        delta_error = abs(delta_approx - delta_exact)\n        gamma_error = abs(gamma_approx - gamma_exact)\n        \n        results.append([delta_error, gamma_error])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f'[{d_err:.6f},{g_err:.6f}]' for d_err, g_err in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}