{"hands_on_practices": [{"introduction": "要真正掌握一种算法的精髓，没有什么能比手动计算和推演更有效了。本练习将引导你直接比较割线法与你可能更熟悉的二分法。通过亲手计算两种方法的前几次迭代，你将直观地感受到它们逼近根的不同方式，并初步理解割线法通常具有更快收敛速度的原因 [@problem_id:2199000]。", "id": "2199000", "problem": "求函数根的两种常见数值方法是二分法和割线法。考虑多项式函数 $p(x) = x^3 - 4x + 1$。我们感兴趣的是求出该多项式的最大实根，已知该根位于区间 $[1, 2]$ 内。\n\n你的任务是比较两种方法前几次迭代的结果。\n\n首先，使用二分法，从区间 $[a_0, b_0] = [1, 2]$ 开始，进行两次迭代来求根的近似值。将此近似值记为 $x_B$。\n\n其次，使用割线法，从初始猜测值 $x_0 = 1$ 和 $x_1 = 2$ 开始，进行两次迭代来求根的近似值。将此近似值记为 $x_S$。\n\n计算这两个近似值之间的绝对差 $|x_B - x_S|$。你的最终答案需四舍五入到四位有效数字。", "solution": "给定多项式 $p(x)=x^{3}-4x+1$，且其最大实根位于区间 $[1,2]$ 内。首先，我们从 $[a_{0},b_{0}]=[1,2]$ 开始，应用两次二分法迭代；然后从 $x_{0}=1$, $x_{1}=2$ 开始，应用两次割线法迭代。最后，我们计算两个近似值之间的绝对差。\n\n二分法：\n- 计算端点处的值：$p(1)=1-4+1=-2<0$ 且 $p(2)=8-8+1=1>0$，因此在 $[1,2]$ 内存在一个根。\n- 迭代 1：中点 $m_{1}=\\frac{1+2}{2}=\\frac{3}{2}$。则\n$$\np\\!\\left(\\frac{3}{2}\\right)=\\left(\\frac{3}{2}\\right)^{3}-4\\cdot\\frac{3}{2}+1=\\frac{27}{8}-6+1=\\frac{27}{8}-\\frac{40}{8}=-\\frac{13}{8}<0.\n$$\n由于 $p(m_{1})<0$ 且 $p(2)>0$，新区间为 $[a_{1},b_{1}]=\\left[\\frac{3}{2},2\\right]$。\n- 迭代 2：中点 $m_{2}=\\frac{\\frac{3}{2}+2}{2}=\\frac{7}{4}$。则\n$$\np\\!\\left(\\frac{7}{4}\\right)=\\left(\\frac{7}{4}\\right)^{3}-4\\cdot\\frac{7}{4}+1=\\frac{343}{64}-7+1=\\frac{343}{64}-6=\\frac{343-384}{64}=-\\frac{41}{64}<0.\n$$\n同样，$p(m_{2})<0$ 且 $p(2)>0$，因此两次迭代后二分法的近似值为\n$$\nx_{B}=m_{2}=\\frac{7}{4}.\n$$\n\n割线法：\n使用更新公式 $x_{k+1}=x_{k}-p(x_{k})\\frac{x_{k}-x_{k-1}}{p(x_{k})-p(x_{k-1})}$。\n- 当 $x_{0}=1$，$x_{1}=2$ 时，我们有 $p(1)=-2$，$p(2)=1$。第一次更新得到\n$$\nx_{2}=2-1\\cdot\\frac{2-1}{1-(-2)}=2-\\frac{1}{3}=\\frac{5}{3}.\n$$\n计算\n$$\np\\!\\left(\\frac{5}{3}\\right)=\\left(\\frac{5}{3}\\right)^{3}-4\\cdot\\frac{5}{3}+1=\\frac{125}{27}-\\frac{20}{3}+1=\\frac{125-180+27}{27}=-\\frac{28}{27}.\n$$\n- 第二次更新使用 $x_{1}=2$，$x_{2}=\\frac{5}{3}$：\n$$\nx_{3}=\\frac{5}{3}-\\left(-\\frac{28}{27}\\right)\\frac{\\frac{5}{3}-2}{-\\frac{28}{27}-1}\n=\\frac{5}{3}-\\left(-\\frac{28}{27}\\right)\\frac{-\\frac{1}{3}}{-\\frac{55}{27}}\n=\\frac{5}{3}-\\frac{28}{81}\\cdot\\frac{27}{-55}\n=\\frac{5}{3}-\\left(-\\frac{28}{165}\\right)\n=\\frac{5}{3}+\\frac{28}{165}\n=\\frac{275}{165}+\\frac{28}{165}\n=\\frac{303}{165}\n=\\frac{101}{55}.\n$$\n因此，两次迭代后割线法的近似值为\n$$\nx_{S}=\\frac{101}{55}.\n$$\n\n绝对差与四舍五入：\n计算\n$$\n|x_{B}-x_{S}|=\\left|\\frac{7}{4}-\\frac{101}{55}\\right|=\\left|\\frac{385-404}{220}\\right|=\\frac{19}{220}.\n$$\n换算成小数，$\\frac{19}{220}=0.0863636\\ldots$，四舍五入到四位有效数字为 $0.08636$。", "answer": "$$\\boxed{0.08636}$$"}, {"introduction": "理论只有在应用于真实世界时才显示出其真正的价值。在本次实践中，你将从抽象的数学函数转向一个核心的金融问题：计算债券的到期收益率 ($YTM$)。你将通过编程实现割线法，寻找使债券理论价格与其市场价格相等的收益率，这是金融分析中的一项基本而重要的任务 [@problem_id:2443656]。", "id": "2443656", "problem": "给定一系列固定息票债券，其特征由面值 $F$、年息票率 $q$（以年化小数表示）、付息频率 $m$（每年支付次数）、到期时间 $T$（以年为单位）以及观测到的市场价格 $P$ 确定。设年化到期收益率 $y$（以年化小数表示，每年复利 $m$ 次）满足以下定价恒等式\n$$\nP \\;=\\; \\sum_{t=1}^{N} \\frac{qF/m}{\\left(1 + \\frac{y}{m}\\right)^t} \\;+\\; \\frac{F}{\\left(1 + \\frac{y}{m}\\right)^N},\n$$\n其中 $N = mT$ 是总付息期数，并约定所有现金流在每期期末发生。\n\n定义求根目标函数\n$$\nf(y) \\;=\\; \\sum_{t=1}^{N} \\frac{qF/m}{\\left(1 + \\frac{y}{m}\\right)^t} \\;+\\; \\frac{F}{\\left(1 + \\frac{y}{m}\\right)^N} \\;-\\; P,\n$$\n并假设该函数仅对满足 $1 + \\frac{y}{m} > 0$ 的 $y$ 值进行求值。对于下方的每组参数，计算一个值 $\\hat{y}$，使得 $f(\\hat{y}) = 0$，并满足以下数值容差：绝对残差容差为 $\\varepsilon_f = 10^{-12}$，绝对收益率容差为 $\\varepsilon_y = 10^{-12}$。每个实例还提供一个用于 $y$ 的初始搜索区间 $[L,U]$，其中 $L < U$。\n\n您的程序必须为测试套件中的每组参数求解方程 $f(y) = 0$，在其对应的区间 $[L,U]$ 内开始搜索，并遵守以下全局限制：每个实例最多进行 $N_{\\max} = 100$ 次函数求值，以及在整个搜索过程中保持定义域约束 $1 + \\frac{y}{m} > 0$。以年化小数形式报告每个 $\\hat{y}$，并将每个值四舍五入到10位小数。\n\n测试套件（每个元组为 $(F, q, m, T, P, L, U)$）：\n- 案例 $1$：$(1000.0, 0.05, 2, 5.0, 950.0, 0.0, 0.2)$\n- 案例 $2$：$(1000.0, 0.0, 2, 3.0, 850.0, 0.0, 0.2)$\n- 案例 $3$：$(1000.0, 0.08, 1, 10.0, 1100.0, 0.0, 0.15)$\n- 案例 $4$：$(1000.0, 0.03, 4, 2.0, 1000.0, -0.02, 0.2)$\n- 案例 $5$：$(1000.0, 0.01, 2, 5.0, 1060.0, -0.1, 0.1)$\n\n最终输出格式：您的程序应生成一行输出，其中包含5个结果，以逗号分隔的列表形式置于方括号内，顺序与上述案例相同，并四舍五入到10位小数，例如 $[\\hat{y}_1,\\hat{y}_2,\\hat{y}_3,\\hat{y}_4,\\hat{y}_5]$，其中每个 $\\hat{y}_i$ 均为年化小数。", "solution": "问题陈述已经过严格的验证过程，并被确定为有效。它在科学上基于金融数学的基本原理，特别是应用于固定收益证券的货币时间价值理论。该问题是适定的、客观的，并为确定债券的到期收益率提供了一套完整且一致的数据和约束。\n\n核心任务是找到目标函数 $f(y)$ 的根，该函数代表在给定收益率 $y$ 下债券的理论价格与其观测到的市场价格 $P$ 之间的差额。理论价格是所有未来现金流（息票和面值）的现值之和。\n\n目标函数给定为：\n$$\nf(y) \\;=\\; \\left( \\sum_{t=1}^{N} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} \\;+\\; \\frac{F}{\\left(1 + \\frac{y}{m}\\right)^N} \\right) \\;-\\; P\n$$\n其中 $C = qF/m$ 是每期支付的息票额，而 $N=mT$ 是总付息期数。用于计算贴现后息票总和的表达式是一个几何级数，可以表示为计算效率更高的封闭形式。设 $i = y/m$ 为每期收益率。息票流的现值（即普通年金）由下式给出：\n$$\nPV_{\\text{coupons}} = C \\cdot \\frac{1 - (1+i)^{-N}}{i}\n$$\n此公式对任何 $i \\neq 0$ 均有效。对于 $y=0$（因此 $i=0$）的特殊情况，价格通过简单求和计算，因为贴现因子为 $1$：\n$$\nP(y=0) = \\sum_{t=1}^{N} C + F = NC + F\n$$\n因此，完整的目标函数为：\n$$\nf(y) = \\begin{cases} \\left( C \\frac{1 - (1+i)^{-N}}{i} + F(1+i)^{-N} \\right) - P & \\text{若 } y \\neq 0 \\\\ (NC + F) - P & \\text{若 } y = 0 \\end{cases}\n$$\n问题是找到 $\\hat{y}$ 使得 $f(\\hat{y}) = 0$。债券价格关于收益率的导数 $P'(y)$，对于所有有效收益率（$1+y/m > 0$）都是严格为负的，这意味着 $f(y)$ 是一个严格单调递减函数。此性质保证了如果根存在，则它是唯一的。\n\n解决此求根问题的一个合适的数值算法是割线法。它是一种迭代开放法，使用一系列割线来逼近函数的根。给定两个初始近似值 $y_{k-1}$ 和 $y_k$，下一个近似值 $y_{k+1}$ 计算为通过点 $(y_{k-1}, f(y_{k-1}))$ 和 $(y_k, f(y_k))$ 的直线的根：\n$$\ny_{k+1} = y_k - f(y_k) \\frac{y_k - y_{k-1}}{f(y_k) - f(y_k-1)}\n$$\n迭代从两个初始猜测值开始，为此使用提供的区间边界 $[L, U]$（即 $y_0 = L, y_1 = U$）。此过程将持续到解收敛为止，收敛由两个条件确定：\n1.  当前估计值处的函数绝对值小于残差容差：$|f(\\hat{y})| < \\varepsilon_f = 10^{-12}$。\n2.  连续两次估计值之间的绝对差小于收益率容差：$|y_{k+1} - y_k| < \\varepsilon_y = 10^{-12}$。\n\n该算法还必须遵守最多 $N_{\\max} = 100$ 次函数求值的预算。初始点 $y_0$ 和 $y_1$ 需要两次求值，为迭代过程留下了98次。割线法每次迭代需要一次新的函数求值，因此对于此类良态问题，此预算足以确保收敛。实现将处理 $y \\approx 0$ 的特殊情况，以避免年金公式中的数值不稳定性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to compute bond yields for a suite of test cases.\n    \"\"\"\n\n    def build_objective_function(F, q, m, T, P):\n        \"\"\"\n        Creates the objective function f(y) = Price(y) - P for a given bond.\n        \n        Args:\n            F (float): Face value.\n            q (float): Annual coupon rate (decimal).\n            m (int): Coupon frequency per year.\n            T (float): Time to maturity in years.\n            P (float): Market price.\n        \n        Returns:\n            A function that takes a yield y and returns the value of f(y).\n        \"\"\"\n        N = m * T\n        C = q * F / m\n\n        # Handle zero-coupon bond as a separate, simpler case.\n        if q == 0.0:\n            def objective_func_zero_coupon(y):\n                if 1 + y / m <= 0:\n                    return np.inf  # Invalid domain\n                i = y / m\n                if abs(i) < 1e-12: # y is close to 0\n                    price = F\n                else:\n                    price = F / ((1 + i)**N)\n                return price - P\n            return objective_func_zero_coupon\n\n        # Handle coupon-bearing bond.\n        def objective_func(y):\n            if 1 + y / m <= 0:\n                return np.inf # Invalid domain\n\n            i = y / m\n            \n            # Use Taylor expansion limit for i near 0 to avoid numerical instability\n            if abs(i) < 1e-9:\n                price = N * C + F\n            else:\n                pv_coupons = C / i * (1 - (1 + i)**(-N))\n                pv_face = F / ((1 + i)**N)\n                price = pv_coupons + pv_face\n            \n            return price - P\n        \n        return objective_func\n\n    def solve_ytm_secant(f, y0, y1, tol_f, tol_y, max_evals):\n        \"\"\"\n        Finds the root of a function using the secant method.\n        \n        Args:\n            f (function): The function for which to find a root.\n            y0, y1 (float): Initial guesses for the root.\n            tol_f (float): Absolute residual tolerance.\n            tol_y (float): Absolute step tolerance.\n            max_evals (int): Maximum number of function evaluations.\n            \n        Returns:\n            The estimated root, or None if not converged.\n        \"\"\"\n        fy0 = f(y0)\n        fy1 = f(y1)\n        num_evals = 2\n\n        if abs(fy0) < tol_f:\n            return y0\n        if abs(fy1) < tol_f:\n            return y1\n\n        for _ in range(max_evals - 2):\n            if abs(fy1 - fy0) < 1e-15: # Denominator is too small\n                break\n\n            # Secant step\n            y_next = y1 - fy1 * (y1 - y0) / (fy1 - fy0)\n\n            if abs(y_next - y1) < tol_y:\n                return y_next\n\n            y0, y1 = y1, y_next\n            fy0, fy1 = fy1, f(y1)\n            num_evals += 1\n\n            if abs(fy1) < tol_f:\n                return y1\n        \n        return y1 # Return the best guess upon reaching max iterations\n\n    # Test suite: (F, q, m, T, P, L, U)\n    test_cases = [\n        (1000.0, 0.05, 2, 5.0, 950.0, 0.0, 0.2),\n        (1000.0, 0.0, 2, 3.0, 850.0, 0.0, 0.2),\n        (1000.0, 0.08, 1, 10.0, 1100.0, 0.0, 0.15),\n        (1000.0, 0.03, 4, 2.0, 1000.0, -0.02, 0.2),\n        (1000.0, 0.01, 2, 5.0, 1060.0, -0.1, 0.1)\n    ]\n    \n    # Tolerances and limits\n    eps_f = 1e-12\n    eps_y = 1e-12\n    N_max = 100\n    \n    results = []\n    for case in test_cases:\n        F, q, m, T, P, L, U = case\n        \n        # Build the specific objective function for this case\n        f = build_objective_function(F, q, m, T, P)\n        \n        # Solve for the yield to maturity\n        y_hat = solve_ytm_secant(f, L, U, eps_f, eps_y, N_max)\n        \n        # Round to 10 decimal places as required\n        results.append(round(y_hat, 10))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"}, {"introduction": "标准的割线法虽然收敛速度快，但缺乏如二分法那样的收敛保证，有时可能会失败。这个高级练习将挑战你构建一个更优越的、有界的求解器，它集两种方法的优点于一身。你将设计一个混合算法，它优先使用割线法来加速收敛，但同时包含安全检查机制，在必要时回退到二分法，以确保根始终被锁定在有效区间内，从而创建一个适用于各种复杂金融问题的稳健工具 [@problem_id:2443706]。", "id": "2443706", "problem": "给定一些来自计算经济学和金融学的连续实值函数，每个函数都定义在一个闭区间上，且在区间端点处的函数值异号。对于每个函数，要求仅通过函数求值（不使用导数）的方式，计算出给定区间内的一个实数根 $x^\\star$。直到终止，该算法的每一次迭代都必须满足以下所有性质：(i) 所有的函数求值都必须在当前的根区间 $\\left[a,b\\right]$ 内进行；(ii) 该区间必须始终包含一个根，即始终满足 $f(a)\\cdot f(b)\\le 0$；(iii) 试探点的序列必须通过一个规则来选择，该规则可以在保持根区间性质的前提下，利用最多三个先前已求值点的信息。当当前根区间的宽度满足 $\\lvert b-a\\rvert \\le \\varepsilon_x$ 或当前近似值的函数值满足 $\\lvert f(x)\\rvert \\le \\varepsilon_f$ 时，程序必须终止。其中 $\\varepsilon_x=\\varepsilon_f=10^{-10}$。每个测试实例最多使用 $100$ 次迭代。如果提前满足终止条件，则立即返回。返回的近似值必须位于最终的根区间内。\n\n定义以下求根实例的测试套件。每个实例指定一个函数 $f(x)$、一个满足 $f(a)\\cdot f(b)\\le 0$ 的区间 $\\left[a,b\\right]$ 以及任何所需参数。\n\n测试用例A（具有恒定弹性需求和线性供给的市场出清价格）：\n- 变量：价格 $p$。\n- 需求：$D(p)=A\\,p^{-\\eta}$，其中 $A=120$ 且 $\\eta=1.5$。\n- 供给：$S(p)=c_0+c_1 p$，其中 $c_0=10$ 且 $c_1=2$。\n- 超额需求：$f(p)=D(p)-S(p)=A\\,p^{-\\eta}-(c_0+c_1 p)$。\n- 区间：$[a,b]=[1,20]$。\n\n测试用例B（根据等息债券价格计算到期收益率）：\n- 变量：收益率 $y$。\n- 每期票息：$C=5$，面值：$F=100$，到期期数：$T=10$，观测价格：$P=95$。\n- 现值函数：$\\mathrm{PV}(y)=\\sum_{t=1}^{T}\\dfrac{C}{(1+y)^t}+\\dfrac{F}{(1+y)^T}$。\n- 求根函数：$f(y)=\\mathrm{PV}(y)-P$。\n- 区间：$[a,b]=[0,0.2]$。\n\n测试用例C（根据Black–Scholes–Merton看涨期权价格计算隐含波动率）：\n- 变量：波动率 $\\sigma$。\n- 标的资产价格：$S=100$，行权价：$K=100$，连续复利无风险利率：$r=0.02$，到期时间（年）：$\\tau=1$，观测到的看涨期权价格：$C_{\\text{mkt}}=10$。\n- Black–Scholes–Merton看涨期权价格：$C(\\sigma)=S\\,N(d_1)-K e^{-r\\tau} N(d_2)$，其中 $d_1=\\dfrac{\\ln(S/K)+(r+\\tfrac{1}{2}\\sigma^2)\\tau}{\\sigma\\sqrt{\\tau}}$，$d_2=d_1-\\sigma\\sqrt{\\tau}$，且 $N(\\cdot)$ 是标准正态累积分布函数（CDF）。\n- 求根函数：$f(\\sigma)=C(\\sigma)-C_{\\text{mkt}}$。\n- 区间：$[a,b]=[0.01,1.0]$。\n\n测试用例D（零息债券收益率方程中的边界根）：\n- 变量：收益率 $y$。\n- 面值：$F=100$，到期期数：$T=5$，参考收益率：$y_0=0.04$，观测价格：$P=F/(1+y_0)^T$。\n- 现值函数：$\\mathrm{PV}(y)=\\dfrac{F}{(1+y)^T}$。\n- 求根函数：$f(y)=\\mathrm{PV}(y)-P$。\n- 区间：$[a,b]=[0.04,0.20]$。\n\n你的程序必须使用同一个通用求解器按A、B、C、D的顺序评估所有四个测试用例，并生成单行输出。该输出包含四个根的数值近似值，形式为逗号分隔的列表，并用方括号括起，例如 $[x_A,x_B,x_C,x_D]$。每个 $x$ 都应以浮点数形式打印。不涉及角度。答案中没有物理单位。输出必须严格按照所描述的格式显示在单行上。", "solution": "该问题已经过验证，并被确定为 **有效**。它具有科学依据、提法得当、客观，并为一个数值任务提供了完整、无矛盾的规范。该问题要求为解决几个来自计算经济学和金融学的明确定义问题，实现一类特定的求根算法。\n\n算法的要求如下：\n1.  它必须是一种区间法，确保根始终位于两点 $a$ 和 $b$ 之间，满足 $f(a) \\cdot f(b) \\le 0$。\n2.  所有的函数求值都必须在当前的根区间内进行。\n3.  它必须使用基于最多三个先前点的插值来加速收敛，但如果插值点不理想，则退回到一种安全的方法。\n4.  它必须只使用函数求值，不使用导数。\n5.  当区间宽度的容差 $\\varepsilon_x = 10^{-10}$ 或函数值的容差 $\\varepsilon_f = 10^{-10}$ 中任意一个满足时，必须终止。\n\n这些约束描述了一种稳健的混合求根算法。标准的割线法不能保证迭代点始终位于根区间内。因此，需要一种更复杂的方法。指定的性质是由 Dekker 和 Brent 开发的那些方法的典型特征，这些方法将快速的开放方法（如割线法或逆二次插值）与安全的封闭方法（二分法）相结合。\n\n这里实现的算法是 Dekker 方法的一个变体，该方法是 Brent 方法的直接前身。它满足所有问题约束。\n\n**算法设计：Dekker-Brent 方法**\n\n该方法的核心是维护一个根区间 $[a, b]$ 和一个约定，即 $b$ 代表根 $x^{\\star}$ 的当前最佳近似值。因此，在每一步中，我们都确保 $|f(b)| \\le |f(a)|$。\n\n1.  **初始化**：给定区间 $[a, b]$ 且 $f(a)f(b) \\le 0$，我们计算 $f(a)$ 和 $f(b)$。如果任一端点在容差 $\\varepsilon_f$ 内是根，则终止。否则，我们通过在必要时交换 $a$ 和 $b$ 来建立不变量 $|f(b)| \\le |f(a)|$。点 $c=a$ 被存储为*上一个*最佳猜测值。\n\n2.  **迭代**：主循环包括生成并评估一个新的试探点 $x_{\\text{next}}$，以缩小根区间 $[a, b]$。\n\n3.  **试探点生成**：\n    *   **插值步骤（割线法）**：使用割线法计算一个试探点 $s$，该方法通过两个最近的最佳猜测值（当前最佳猜测值 $(b, f(b))$ 和上一个最佳猜测值 $(c, f(c))$）构建一条直线。公式为：\n        $$ s = b - f(b) \\frac{b - c}{f(b) - f(c)} $$\n        此步骤使用两个先前的点（$b$ 和 $c$）来实现超线性收敛。\n    *   **二分步骤**：一个有保证但较慢的备用方法是二分中点 $m = (a+b)/2$。\n\n4.  **混合策略**：每一步都需要做出一个关键决策。为确保收敛并满足函数求值必须在根区间内的约束，只有当快速的割线步骤 $s$ 是“合理的”时才接受它。Dekker 方法的一个核心、简单而有效的条件是，仅当 $s$ 位于当前最佳猜测值 $b$ 和二分中点 $m$ 之间时才接受它。如果此条件不满足，我们就不信任插值，并默认使用安全的二分点 $m$。这确保了 $x_{\\text{next}}$ 始终在当前根区间 $[a, b]$ 内。\n\n5.  **根区间更新**：在评估 $f(x_{\\text{next}})$ 后，更新根区间。如果 $f(a)$ 和 $f(x_{\\text{next}})$ 异号，则新的根区间变为 $[a, x_{\\text{next}}]$；否则，变为 $[x_{\\text{next}}, b]$。然后重新标记这些点以维持 $b$ 是最佳猜测值的不变量，并重复该过程。\n\n6.  **终止**：如果根区间宽度 $|b-a|$ 小于或等于 $\\varepsilon_x$ 或最佳猜测值的函数值 $|f(b)|$ 小于或等于 $\\varepsilon_f$，则循环终止。\n\n**测试用例实现**\n\n四个测试用例被实现为 Python 函数。\n- 对于测试用例 B（到期收益率），通过直接求和来计算现值，以在收益率值接近零时保持数值稳定性和正确性。\n- 对于测试用例 C（隐含波动率），需要标准正态累积分布函数 $N(x)$。它是通过 Python 标准库 `math` 中可用的误差函数 $\\mathrm{erf}(x)$ 来实现的，关系式为 $N(x) = \\frac{1}{2}(1 + \\mathrm{erf}(x/\\sqrt{2}))$。\n- 对于测试用例 D，根恰好位于初始区间的边界上。求解器在第一次检查时正确识别出这一点，并立即用正确答案终止。\n\n这种稳健的、基于原则的设计确保了对所有指定测试用例的根进行正确而高效的计算。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    The output is a single line with comma-separated roots in a list format.\n    \"\"\"\n    # Define global constants for the solver.\n    EPS_X = 1e-10\n    EPS_F = 1e-10\n    MAX_ITER = 100\n\n    def dekker_brent_solver(f, a, b, eps_x, eps_f, max_iter):\n        \"\"\"\n        A robust root-finding algorithm based on Dekker's and Brent's methods.\n        It combines a fast interpolation step (secant method) with a safe\n        fallback (bisection method) to guarantee convergence while ensuring the\n        root remains bracketed.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb > 0:\n            raise ValueError(\"Root not bracketed in initial interval [a, b].\")\n\n        # Check if endpoints are already the root within tolerance.\n        if abs(fa) <= eps_f:\n            return a\n        if abs(fb) <= eps_f:\n            return b\n\n        # Convention: 'b' is always the current best guess for the root.\n        # 'a' is the contrapoint, ensuring f(a) and f(b) have opposite signs.\n        if abs(fa) < abs(fb):\n            a, b = b, a\n            fa, fb = fb, fa\n        \n        # 'c' is the previous best guess, used for the secant step.\n        c = a\n        fc = fa\n        \n        for _ in range(max_iter):\n            # Check for termination on either interval width or function value.\n            if abs(b - a) <= eps_x or abs(fb) <= eps_f:\n                return b\n\n            s = None\n            # Propose a new point 's' using the secant method (linear interpolation).\n            # This step uses the current best guess (b) and previous best guess (c).\n            if abs(fb - fc) > 1e-15:  # Avoid division by zero or large floating-point errors.\n                s = b - fb * (b - c) / (fb - fc)\n\n            # The bisection midpoint serves as a safe fallback.\n            m = (a + b) / 2\n            \n            # Hybrid strategy: Accept the secant step 's' only if it's reasonable.\n            # \"Reasonable\" means it falls strictly between 'b' and the bisection point 'm'.\n            # This ensures the new point is inside the bracket and promotes convergence.\n            is_secant_step_acceptable = False\n            if s is not None:\n                # The order of b and m is not known, so check both cases.\n                if (b < m and s > b and s < m) or (b > m and s < b and s > m):\n                    is_secant_step_acceptable = True\n\n            if is_secant_step_acceptable:\n                x_next = s\n            else:\n                # If interpolation is untrustworthy, fall back to bisection.\n                x_next = m\n            \n            f_next = f(x_next)\n\n            # Update state for the next iteration: the old 'b' becomes the new 'c'.\n            c, fc = b, fb\n\n            # Update the bracketing interval based on the sign of f_next.\n            if fa * f_next < 0:\n                b, fb = x_next, f_next\n            else:\n                a, fa = x_next, f_next\n\n            # Maintain the invariant that 'b' is the best guess so far (|f(b)| is minimal).\n            if abs(fa) < abs(fb):\n                a, b = b, a\n                fa, fb = fb, fa\n        \n        # If max iterations are reached, return the best approximation found.\n        return b\n\n    # --- Test Case Definitions ---\n\n    # Test Case A: Market-clearing price\n    def f_A(p):\n        A, eta, c0, c1 = 120.0, 1.5, 10.0, 2.0\n        if p <= 0: return float('inf')\n        return A * p**(-eta) - (c0 + c1 * p)\n    \n    # Test Case B: Yield to maturity\n    def f_B(y):\n        C, F, T, P = 5.0, 100.0, 10, 95.0\n        if y <= -1: return float('inf')\n        one_plus_y = 1.0 + y\n        # Direct summation is robust against numerical issues near y=0.\n        terms = [C / (one_plus_y**t) for t in range(1, T + 1)]\n        pv = np.sum(terms) + F / (one_plus_y**T)\n        return pv - P\n    \n    # Test Case C: Implied volatility\n    def f_C(sigma):\n        S, K, r, tau, C_mkt = 100.0, 100.0, 0.02, 1.0, 10.0\n        if sigma <= 0: return -C_mkt # C(0) = 0, so f(0) = -C_mkt\n\n        # Standard Normal CDF N(x) using math.erf from the standard library\n        def N(x):\n            return 0.5 * (1.0 + math.erf(x / math.sqrt(2.0)))\n        \n        d1 = (math.log(S / K) + (r + 0.5 * sigma**2) * tau) / (sigma * math.sqrt(tau))\n        d2 = d1 - sigma * math.sqrt(tau)\n        call_price = S * N(d1) - K * math.exp(-r * tau) * N(d2)\n        return call_price - C_mkt\n\n    # Test Case D: Boundary root\n    F_D, T_D, y0_D = 100.0, 5, 0.04\n    P_D = F_D / (1.0 + y0_D)**T_D\n    def f_D(y):\n        if y <= -1: return float('inf')\n        return F_D / (1.0 + y)**T_D - P_D\n\n    test_cases = [\n        {'func': f_A, 'a': 1.0, 'b': 20.0},\n        {'func': f_B, 'a': 0.0, 'b': 0.2},\n        {'func': f_C, 'a': 0.01, 'b': 1.0},\n        {'func': f_D, 'a': 0.04, 'b': 0.20},\n    ]\n\n    results = []\n    for case in test_cases:\n        root = dekker_brent_solver(case['func'], case['a'], case['b'], EPS_X, EPS_F, MAX_ITER)\n        results.append(root)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}