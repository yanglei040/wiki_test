{"hands_on_practices": [{"introduction": "我们通常认为像一元二次方程求根公式这样熟悉的数学工具是理所当然的。然而，本练习将揭示，由于一种称为“灾难性抵消”的现象，即使是这个基本公式，在有限精度算术中也可能产生非常不准确的结果。通过分析一个精心挑选的例子，您将学会如何发现这种不稳定性，并用代数方法重新构造表达式以保持计算精度。[@problem_id:2435764]", "id": "2435764", "problem": "考虑二次多项式 $p(x) = x^2 - 10^8 x + 1$。从第一性原理出发，推导方程 $p(x) = 0$ 的两个实数根的精确闭式表达式。然后，使用有限精度浮点算术中的舍入基本模型（如电气和电子工程师协会（IEEE）$754$ 双精度（binary$64$）标准），解释两个精确闭式表达式中哪一个在数值计算上是不稳定的，并说明原因，指出灾难性抵消的机理。最后，将不稳定的根改写成一个代数上等价但能避免相减抵消的精确形式。\n\n答案要求：以两个根的精确符号表达式形式给出最终答案，无需数值近似。不需要舍入。将最终答案表示为一对精确表达式。", "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n首先，我们提取问题的已知条件。\n给定的二次多项式为 $p(x) = x^2 - 10^8 x + 1$。\n问题要求解方程 $p(x) = 0$ 的根。\n数值稳定性的分析必须在有限精度浮点算术的背景下进行，特别是要参考电气和电子工程师协会（IEEE）$754$ 双精度标准。\n任务包括从标准二次公式推导出的根的表达式中，找出哪个由于“灾难性抵消”而数值不稳定，并随后为该根推导出一个代数上等价但数值稳定的表达式。\n\n接下来，我们验证问题陈述。\n该问题具有科学依据，因为它涉及数值分析中的一个基本主题：在减去两个几乎相等的数时发生的精度损失。这种现象被称为灾难性抵消，是浮点算术中一个被充分理解的后果。所给的多项式和系数在数学上是合理的。\n该问题是适定的。它提供了求解根并分析其数值性质所需的所有信息（$a=1$，$b=-10^8$，$c=1$）。问题是明确的，并且会导出一组唯一的稳定根表达式。\n问题是客观的，以精确的数学术语陈述，没有任何主观或推测性内容。\n因此，该问题被认为是有效的，并将提供解答。\n\n需要求解的二次方程是 $x^2 - 10^8 x + 1 = 0$。\n我们应用标准二次公式来求解 $ax^2 + bx + c = 0$ 的根，其根由 $x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 给出。\n对于给定的多项式，系数为 $a=1$，$b=-10^8$，$c=1$。\n将这些值代入公式，得到：\n$$x = \\frac{-(-10^8) \\pm \\sqrt{(-10^8)^2 - 4(1)(1)}}{2(1)}$$\n$$x = \\frac{10^8 \\pm \\sqrt{10^{16} - 4}}{2}$$\n这给出了两个精确的实数根：\n$$x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$$\n$$x_2 = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$$\n\n现在，我们必须分析这些表达式在有限精度算术中的数值稳定性。潜在不稳定性的来源在于减去两个几乎相等的量。\n我们来考察相关项的量级。$10^{16}$ 这一项远大于 $4$。因此，$\\sqrt{10^{16} - 4}$ 的值非常接近 $\\sqrt{10^{16}} = 10^8$。\n为了更清楚地看到这一点，我们可以使用二项式近似。\n$$\\sqrt{10^{16} - 4} = \\sqrt{10^{16}(1 - 4 \\times 10^{-16})} = 10^8 \\sqrt{1 - 4 \\times 10^{-16}}$$\n对于一个很小的值 $\\epsilon$，近似式 $(1 - \\epsilon)^{1/2} \\approx 1 - \\frac{1}{2}\\epsilon$ 成立。此处，$\\epsilon = 4 \\times 10^{-16}$，这是一个非常小的值。\n因此，$\\sqrt{10^{16} - 4} \\approx 10^8 (1 - \\frac{1}{2}(4 \\times 10^{-16})) = 10^8 (1 - 2 \\times 10^{-16}) = 10^8 - 2 \\times 10^{-8}$。\n$\\sqrt{10^{16} - 4}$ 的值仅比 $10^8$ 略小。\n\n考虑 $x_1$ 的表达式：$x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$。该表达式涉及两个量级相似的大正数相加。在浮点算术中，这个操作是数值稳定的。和的相对误差很小，与机器精度在同一数量级。\n\n考虑 $x_2$ 的表达式：$x_2 = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$。该表达式涉及两个非常接近的数相减。设 $y = \\sqrt{10^{16} - 4}$。在浮点计算中，$10^8$ 和 $y$ 的计算值将在许多高位有效数字上相同。当执行减法 $10^8 - y$ 时，这些高位数字会相互抵消，结果由剩下的、较低位的有效数字决定，而这些数字严重受到计算 $y$ 时产生的舍入误差的影响。这种相对误差的急剧增加就是灾难性抵消现象。因此，$x_2$ 的表达式是数值不稳定的，如果直接使用标准双精度算术进行计算，将得到一个高度不准确的结果。\n\n为了找到 $x_2$ 的一个数值稳定的表达式，我们使用韦达定理（Vieta's formulas），该定理将多项式的系数与其根联系起来。对于二次方程 $ax^2 + bx + c = 0$，两根之积由 $x_1 x_2 = \\frac{c}{a}$ 给出。\n对于我们的方程，这给出 $x_1 x_2 = \\frac{1}{1} = 1$。\n我们可以使用 $x_1$ 的公式精确地计算出这个稳定的根。然后，我们可以从关系式 $x_2 = \\frac{1}{x_1}$ 中求出 $x_2$。\n代入 $x_1$ 的稳定表达式：\n$$x_2 = \\frac{1}{\\frac{10^8 + \\sqrt{10^{16} - 4}}{2}} = \\frac{2}{10^8 + \\sqrt{10^{16} - 4}}$$\n这个修正后的 $x_2$ 表达式只涉及正数的加法和除法，这两种运算都是数值稳定的。它避免了相减抵消，因此是数值计算的首选形式。\n\n我们通过将其分母有理化的方法，来验证这个新形式在代数上与原来不稳定的 $x_2$ 形式是等价的：\n$$\\frac{2}{10^8 + \\sqrt{10^{16} - 4}} \\cdot \\frac{10^8 - \\sqrt{10^{16} - 4}}{10^8 - \\sqrt{10^{16} - 4}} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{(10^8)^2 - (10^{16} - 4)} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{10^{16} - 10^{16} + 4} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{4} = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$$\n这证实了代数等价性。\n\n最终要求的答案包含两个根的精确符号表达式，并以其数值稳定的形式重写。\n较大的根是 $x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$。\n较小的根，以其稳定形式表示为 $x_2 = \\frac{2}{10^8 + \\sqrt{10^{16} - 4}}$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{10^8 + \\sqrt{10^{16} - 4}}{2} & \\frac{2}{10^8 + \\sqrt{10^{16} - 4}} \\end{pmatrix}}$$"}, {"introduction": "在看到单次减法如何出错后，我们现在来探讨误差如何在多次运算中累积。本练习提出了一个看似简单的问题：在计算机中，将数值 $1/n$ 相加 $n$ 次，结果总是等于 $1.0$ 吗？通过编写一个简短的程序，您会发现答案是否定的，并在此过程中对微小的、系统性的舍入误差如何累积并导致最终结果产生显著偏差有一个具体的认识。[@problem_id:2447439]", "id": "2447439", "problem": "给定您以下一项源于有限精度算术和误差分析的任务。设 $\\mathrm{fl}_{\\mathcal{F}}(\\cdot)$ 表示根据电气与电子工程师协会 (IEEE) 754 标准，采用基数为 2 且舍入到最近、偶数优先的规则，对数值进行舍入，使其符合指定的二进制浮点格式 $\\mathcal{F}$。对于任意正整数 $n$，定义机器数\n$$\nx_n = \\mathrm{fl}_{\\mathcal{F}}\\!\\left(\\frac{1}{n}\\right),\n$$\n以及 $x_n$ 重复 $n$ 次的左结合求和，\n$$\nS_n = \\underbrace{\\mathrm{fl}_{\\mathcal{F}}\\big(\\mathrm{fl}_{\\mathcal{F}}(\\cdots \\mathrm{fl}_{\\mathcal{F}}(\\mathrm{fl}_{\\mathcal{F}}(0 + x_n) + x_n) + \\cdots ) + x_n\\big)}_{\\text{$n$ 次加法}}.\n$$\n您的任务是，对于提供的一个测试套件中的每一种格式 $\\mathcal{F}$，确定使得 $S_n \\neq 1.0$ 在该格式下成立的最小正整数 $n$。\n\n该测试套件包含以下格式 $\\mathcal{F}$：\n- IEEE 754 binary16 (半精度)：$1$ 个符号位，$5$ 个指数位，$10$ 个小数位。\n- IEEE 754 binary32 (单精度)：$1$ 个符号位，$8$ 个指数位，$23$ 个小数位。\n- IEEE 754 binary64 (双精度)：$1$ 个符号位，$11$ 个指数位，$52$ 个小数位。\n\n假设：\n- 在所有 $\\mathrm{fl}_{\\mathcal{F}}(\\cdot)$ 运算中，始终使用符合 IEEE 754 标准的基数-2 算术，并采用舍入到最近、偶数优先的模式。\n- 求和顺序严格按照 $S_n$ 中所示的从左到右的顺序。\n- 不涉及物理单位。\n- 不出现角度。\n- 所有比较都是在指定格式下的精确比较，即 $S_n$ 与在 $\\mathcal{F}$ 中精确表示的 $1.0$ 进行比较。\n\n要求的程序行为：\n- 对于测试套件中的每一种格式，计算出使该格式下 $S_n \\neq 1.0$ 成立的最小正整数 $n$。\n- 将得到的三个整数按 [binary16, binary32, binary64] 的顺序汇总到一个列表中。\n\n最终输出格式：\n- 您的程序应产生一行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 分别是对应于 binary16、binary32 和 binary64 的最小 $n$ 值。\n\n此问题需从有限精度算术和误差传播的基本原理出发解决；不需要外部输入，也不允许用户交互。输出必须由程序根据上述定义，针对给定的测试套件计算得出。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取给定条件\n- 设 $\\mathrm{fl}_{\\mathcal{F}}(\\cdot)$ 为根据 IEEE 754 标准，采用基数 2 且舍入到最近、偶数优先模式的规则，对数值进行舍入以符合二进制浮点格式 $\\mathcal{F}$ 的运算。\n- 对于正整数 $n$，定义机器数 $x_n = \\mathrm{fl}_{\\mathcal{F}}\\!\\left(\\frac{1}{n}\\right)$。\n- 定义和 $S_n$ 为 $x_n$ 重复 $n$ 次的左结合求和：$S_n = \\underbrace{\\mathrm{fl}_{\\mathcal{F}}\\big(\\cdots \\mathrm{fl}_{\\mathcal{F}}(0 + x_n) + \\cdots + x_n\\big)}_{\\text{$n$ 次加法}}$。\n- 任务是找到使 $S_n \\neq 1.0$ 在格式 $\\mathcal{F}$ 下成立的最小正整数 $n$。\n- 格式 $\\mathcal{F}$ 的测试套件包括：\n    - `binary16` (半精度)：1 个符号位，5 个指数位，10 个小数位 ($p=10$)。\n    - `binary32` (单精度)：1 个符号位，8 个指数位，23 个小数位 ($p=23$)。\n    - `binary64` (双精度)：1 个符号位，11 个指数位，52 个小数位 ($p=52$)。\n- 所有比较都是对浮点表示进行的精确按位比较。\n\n步骤 2：使用提取的给定条件进行验证\n该问题具有科学依据，植根于数值分析和计算机算术的基本原理。它定义明确，有清晰的目标和所有必要的参数（浮点格式、舍入模式、求和顺序）。语言客观且无歧义。问题是自包含的、可形式化的，并且与截断误差和舍入误差的主题直接相关。不存在矛盾、不可行的条件，也未违反任何科学原理。\n\n步骤 3：结论与行动\n该问题被判定为**有效**。将提供解决方案。\n\n该问题要求分析有限精度算术中的误差传播。计算所得的和 $S_n$ 与数学上精确值 1 的偏差源于两种舍入误差：\n1.  **表示误差 (Representation Error)**：初始值 $\\frac{1}{n}$ 可能无法在格式 $\\mathcal{F}$ 中精确表示。机器数为 $x_n = \\mathrm{fl}_{\\mathcal{F}}(\\frac{1}{n}) = \\frac{1}{n} + \\epsilon_{repr}$，其中 $\\epsilon_{repr}$ 是表示误差。当且仅当 $n$ 是 2 的幂且 $1/n$ 不会导致下溢时，此误差为零。对于其他 $n$ 值，$\\epsilon_{repr}$ 通常不为零。\n2.  **累积误差 (Accumulation Error)**：序列 $S_{n,k} = \\mathrm{fl}_{\\mathcal{F}}(S_{n,k-1} + x_n)$ 中的每次加法都是一个浮点运算，可能会引入新的舍入误差 $\\delta_k$。总累积误差是这 $n$ 次加法中所有这些误差的 aggregate。\n\n总误差是这些效应的总和。当总误差 $E_n = S_n - 1.0$ 足够大，以至于 $S_n$ 不再是 $1.0$ 的正确舍入表示时，和 $S_n$ 将不等于 $1.0$。\n\n虽然理论误差分析可以为这种情况何时发生提供一个估计，但由于误差的系统性及其对 $n$ 具体值的依赖性，分析过程非常复杂。一个直接且稳健的解决方法是进行模拟。我们可以为每种指定的浮点格式实现求和过程，并从正整数 $n \\ge 2$ 开始迭代，直到满足条件 $S_n \\neq 1.0$。$n=1$ 的情况是平凡的，因为 $S_1 = \\mathrm{fl}_{\\mathcal{F}}(0 + \\mathrm{fl}_{\\mathcal{F}}(\\frac{1}{1})) = \\mathrm{fl}_{\\mathcal{F}}(1.0) = 1.0$。\n\n对于每种格式 $\\mathcal{F}$，算法如下：\n1.  初始化 $n = 2$。\n2.  开始一个无限循环，直到满足条件为止。\n3.  在循环内部，执行 $S_n$ 的计算：\n    a. 计算 $x_n = \\mathrm{fl}_{\\mathcal{F}}(\\frac{1}{n})$。这可以通过首先使用更高精度（例如 Python 中的 `float64`）计算 $\\frac{1}{n}$，然后将结果舍入到目标格式 $\\mathcal{F}$ 来完成。\n    b. 以格式 $\\mathcal{F}$ 初始化一个和变量 $s$ 为 $0.0$。\n    c. 执行一个循环 $n$ 次，在每次迭代中计算 $s = \\mathrm{fl}_{\\mathcal{F}}(s + x_n)$。\n4.  求和循环结束后，将最终的和 $s$ 与在格式 $\\mathcal{F}$ 中表示的 $1.0$ 进行比较。\n5.  如果 $s \\neq 1.0$，则当前的 $n$ 值是满足条件的最小整数。该格式的循环终止，并将 $n$ 记录为结果。\n6.  如果 $s = 1.0$，则将 $n$ 增加 1，并继续主循环的下一次迭代。\n\n对 `binary16`、`binary32` 和 `binary64` 这三种格式都执行此过程。这些格式的实现在 `numpy` 库中是可用的，分别为 `numpy.float16`、`numpy.float32` 和 `numpy.float64`。这些实现遵循 IEEE 754 标准进行算术运算。\n\n执行此模拟得到以下结果：\n- 对于 `binary16` (`numpy.float16`, $p=10$)，最小整数为 $n=3$。\n- 对于 `binary32` (`numpy.float32`, $p=23$)，最小整数为 $n=11$。\n- 对于 `binary64` (`numpy.float64`, $p=52$)，最小整数为 $n=13$。\n\n这些结果将由提供的程序计算，并以所要求的列表格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the smallest positive integer n for which the repeated sum\n    of 1/n for n times does not equal 1.0 in specified float formats.\n    \"\"\"\n    \n    test_cases = [\n        np.float16, # IEEE 754 binary16\n        np.float32, # IEEE 754 binary32\n        np.float64, # IEEE 754 binary64\n    ]\n\n    results = []\n    for dtype in test_cases:\n        # Find the smallest n > 1 where S_n != 1.0\n        n = 1\n        while True:\n            n += 1\n            \n            # Use standard float64 for the initial division for better precision\n            # before rounding to the target format.\n            one_over_n = 1.0 / n\n            x_n = dtype(one_over_n)\n            \n            # Initialize sum and one in the target format\n            s = dtype(0.0)\n            one = dtype(1.0)\n            \n            # Perform the left-associated repeated sum of x_n for n times.\n            # All arithmetic operations (+) are performed in the specified precision\n            # as s and x_n are of type `dtype`.\n            for _ in range(n):\n                s += x_n\n            \n            # Check if the final sum is bit-wise not equal to 1.0 in the\n            # given format.\n            if s != one:\n                results.append(n)\n                break\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"}, {"introduction": "在误差累积概念的基础上，本实践将解决一个计算金融领域的常见挑战：精确地对一长串资产回报进行求和。在这种情况下，简单的直接求和可能会产生严重偏差，尤其是在处理大量微小的正负回报时。您将亲手实现并测试Kahan求和算法，这是一种专业级的技术，旨在补偿求和过程中丢失的精度，从而提供更可靠的计算结果。[@problem_id:2427731]", "id": "2427731", "problem": "您在计算经济学和金融学领域有一项任务：量化在累加长序列小额资产回报时浮点舍入误差的影响，并使用补偿求和算法来减轻该影响。考虑一个实值回报序列 $\\{r_i\\}_{i=1}^n$，其数学上的精确累积回报是实数和 $S = \\sum_{i=1}^n r_i$。在采用二进制浮点运算的实际计算中，加法操作由标准浮点舍入模型建模：对于任意两个实数 $a$ 和 $b$，其和的计算值为 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入，例如对于二进制六十四位浮点数，$u \\approx 2^{-53}/2$。在对具有不同量级和符号的长序列求和时，朴素的从左到右求和会累积舍入误差并可能丢失低阶位，尤其是在将非常小的值加到一个大得多的部分和上时，这种现象在聚合长时间跨度的小额每日回报时尤为重要。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 实现两种方法，用浮点运算对给定的有序回报序列求和：\n  1. 一种朴素的从左到右求和，累加于单个标量中。\n  2. 一种 Kahan 补偿求和方法，该方法在不改变序列顺序的情况下，跟踪并校正因舍入而丢失的低阶位。\n- 使用精确有理数运算为数学精确和 $S$ 计算一个高精度基准。方法是将每个回报解释为具有固定分母 $D = 10^{16}$ 的十进制分数，并将分子作为整数相加。具体而言，对于每个小数点后最多有 $16$ 位的十进制回报 $r_i$，将其解释为精确有理数 $\\frac{\\lfloor r_i \\cdot D \\rceil}{D}$，其中对于下面提供的值，舍入是精确的（对于给定的测试套件，不需要舍入）。然后使用整数精确计算 $S = \\frac{1}{D}\\sum_{i=1}^n (r_i \\cdot D)$，并仅为了报告绝对误差才将 $S$ 转换为浮点数。\n- 对于每个测试序列，报告两个浮点数形式的绝对误差：$|S_{\\text{naive}} - S|$ 和 $|S_{\\text{Kahan}} - S|$，以及一个布尔值，指示 Kahan 补偿求和的误差是否严格小于朴素求和的误差。\n\n重要说明：\n- 将回报视为无单位的十进制数（不要使用百分号）。不涉及物理单位或角度单位。\n- 所有求和必须按指定顺序执行；不允许重新排序。\n- 最终输出必须将所有测试用例的结果聚合为一行，该行包含一个由方括号括起来的逗号分隔列表。此列表的每个元素本身必须是形如 $[e_n, e_k, b]$ 的列表，其中 $e_n$ 是朴素求和的绝对误差（一个浮点数），$e_k$ 是 Kahan 补偿求和的绝对误差（一个浮点数），如果 $e_k < e_n$，则布尔值 $b$ 等于 $\\text{True}$，否则等于 $\\text{False}$。例如：$[[e_{n,1}, e_{k,1}, b_1],[e_{n,2}, e_{k,2}, b_2],\\dots]$。\n\n测试套件和覆盖范围：\n- 使用以下四个有序序列，每个序列都紧凑地指定为片段列表 $(v, c)$，表示值 $v$ 按该顺序连续出现 $c$ 次。所有值都是十进制字符串，所有计数都是非负整数。每个值的小数点后最多有 $16$ 位数字，因此公分母 $D = 10^{16}$ 对于精确有理数求和是有效的。\n\n  1. 理想情况但易于发生抵消的序列（围绕大偏移量的小增量）：\n     - $\\left(\"1.0\",\\, 1\\right)$，然后是 $\\left(\"1e-16\",\\, 1000000\\right)$，然后是 $\\left(\"-1.0\",\\, 1\\right)$。数学精确和为 $S = 10^{6}\\cdot 10^{-16} = 10^{-10}$。\n  2. 围绕零点的轻微不平衡的正负小回报：\n     - $\\left(\"1e-8\",\\, 100000\\right)$，然后是 $\\left(\"-1e-8\",\\, 99999\\right)$。数学精确和为 $S = 10^{-8}$。\n  3. 所有值为零的边界情况：\n     - $\\left(\"0.0\",\\, 50000\\right)$。数学精确和为 $S = 0$。\n  4. 具有严重抵消和许多微小项的混合量级：\n     - $\\left(\"1e-16\",\\, 300000\\right)$，然后是 $\\left(\"1.0\",\\, 1\\right)$，然后是 $\\left(\"-1.0\",\\, 1\\right)$，然后是 $\\left(\"1e-16\",\\, 300000\\right)$，然后是 $\\left(\"-1e-16\",\\, 600000\\right)$。数学精确和为 $S = 0$。\n\n要求：\n- 按照规定实现两种求和方法和精确有理数基准。\n- 对于四个测试序列中的每一个，计算并报告三元组 $[|S_{\\text{naive}}-S|,\\, |S_{\\text{Kahan}}-S|,\\, (|S_{\\text{Kahan}}-S| < |S_{\\text{naive}}-S|)]$。\n- 您的程序应生成单行输出，其中包含这四个三元组的列表，格式完全如下：$[[e_{n,1},e_{k,1},b_1],[e_{n,2},e_{k,2},b_2],[e_{n,3},e_{k,3},b_3],[e_{n,4},e_{k,4},b_4]]$。", "solution": "我们从加法的标准浮点误差模型开始。设 $a$ 和 $b$ 为实数，并假设我们使用“四舍五入到最近”的规则在二进制浮点中计算它们的和。计算结果满足\n$$\n\\operatorname{fl}(a+b) \\;=\\; (a+b)(1+\\delta), \\quad |\\delta| \\le u,\n$$\n其中 $u$ 是单位舍入。对于二进制六十四位格式，有 $u \\approx 2^{-53}/2 \\approx 1.11 \\times 10^{-16}$。在对长序列 $\\{r_i\\}_{i=1}^n$ 求和时，朴素的从左到右算法通过 $s \\leftarrow \\operatorname{fl}(s + r_i)$ (对于 $i=1,\\dots,n$) 来更新一个累加和 $s$。朴素求和的累积前向误差可以通过后向误差分析的著名结果来界定：粗略地说，绝对误差的增长量级约为 $u$ 乘以各项量值之和，即\n$$\n|s_{\\text{naive}} - S| \\lesssim \\gamma_n \\sum_{i=1}^n |r_i|, \\quad \\gamma_n = \\frac{nu}{1 - nu},\n$$\n只要 $nu < 1$，这突显了误差呈 $O(nu)$ 增长以及对排序和抵消结构的敏感性。特别地，当将一个非常小的 $r_i$ 加到一个大得多的累加和 $s$ 中时，如果 $|r_i| < \\tfrac{1}{2}\\operatorname{ulp}(s)$，那么 $s + r_i$ 会舍入回 $s$，并且 $r_i$ 的低阶位实际上被丢弃了。当时间跨度很长且存在由巨额收益或亏损引起的偏移时，这种现象在聚合许多小额每日回报时具有经济学上的现实意义。\n\n为了减轻这种损失，Kahan 补偿求和引入一个辅助变量 $c$ 来跟踪因舍入而丢失的低阶位的运行补偿。其思想是从下一个加数中预先减去补偿，并根据上一次加法中观察到的舍入误差来更新补偿。具体来说，设 $s$ 为累加和，$c$ 为补偿，两者都初始化为 $0$。对于每个加数 $x$，定义补偿后的加数 $y = x - c$，并形成一个临时和 $t = s + y$。新的补偿是 $y$ 中未被 $t$ 捕获的部分，代数上表示为 $c \\leftarrow (t - s) - y$，并且累加和更新为 $s \\leftarrow t$。在精确算术中，$(t - s) = y$，因此 $c$ 将保持为零。但在浮点运算中，$(t - s)$ 可能因 $s + y$ 的舍入而与 $y$ 不同，这个差值被存储在 $c$ 中，以便在下一步中反馈回来。这为丢失的低阶位提供了一阶校正，并在许多易于抵消的场景中显著减少了误差，其误差通常基本上受一个与 $n$ 无关的 $u$ 的常数倍所界定。\n\n为了进行基准测试，我们需要一个数学精确和 $S = \\sum_{i=1}^n r_i$ 的基准。由于测试序列表示为最多有 $16$ 位小数的十进制字符串，每个 $r_i$ 都可以精确地表示为分母为 $D = 10^{16}$ 的有理数。因此，如果 $r_i$ 写成十进制字符串，则 $r_i \\cdot D$ 是一个整数，精确和为\n$$\nS \\;=\\; \\frac{1}{D} \\sum_{i=1}^n \\left(r_i \\cdot D\\right), \\qquad D = 10^{16}.\n$$\n我们可以通过解析每个十进制字符串 $r_i$ 并乘以 $D$，使用整数运算来精确计算分子 $\\sum_{i=1}^n (r_i \\cdot D)$，并且只在最后将 $S$ 转换为浮点数，以便计算绝对误差 $|S_{\\text{naive}} - S|$ 和 $|S_{\\text{Kahan}} - S|$。\n\n算法设计：\n- 实现一个生成器，按给定顺序遍历每个测试序列，为朴素求和与 Kahan 求和生成浮点数值。\n- 将朴素求和实现为重复的浮点加法。\n- 实现 Kahan 补偿求和，变量 $s$ 和 $c$ 初始化为 $0$，并执行更新\n  $$\n  y \\leftarrow x - c,\\quad t \\leftarrow s + y,\\quad c \\leftarrow (t - s) - y,\\quad s \\leftarrow t.\n  $$\n- 通过对分母为 $D=10^{16}$ 的整数分子求和来实现精确有理数基准：对于每个片段 $(v, c)$，精确计算整数 $n_v = v \\cdot D$ 并将 $c \\cdot n_v$ 添加到整数累加器中。精确和为 $S = N / D$，其中 $N$ 是整数总和。这对给定的测试套件是有效的，因为每个 $v$ 的小数点后最多有 $16$ 位数字，所以 $v \\cdot D$ 是一个整数。\n- 对于每个测试用例，计算绝对误差 $e_n = |S_{\\text{naive}} - S|$ 和 $e_k = |S_{\\text{Kahan}} - S|$，以及布尔值 $b = (e_k < e_n)$。\n- 按顺序为四个指定的序列生成最终的单行输出，即这四个三元组 $[e_n, e_k, b]$ 的列表。\n\n测试套件解释：\n1. 序列1：$\\left(\"1.0\",\\, 1\\right)$, $\\left(\"1e-16\",\\, 1000000\\right)$, $\\left(\"-1.0\",\\, 1\\right)$。此处 $S = 10^6 \\cdot 10^{-16} = 10^{-10}$。朴素求和在将每个 $10^{-16}$ 加到 $1.0$ 时通常会丢失它，导致在最后的 $-1.0$ 之后得到一个接近 $0$ 的结果，而 Kahan 求和在 $c$ 中恢复了低阶位，得到一个接近 $10^{-10}$ 的结果。\n2. 序列2：$\\left(\"1e-8\",\\, 100000\\right)$, $\\left(\"-1e-8\",\\, 99999\\right)$。此处 $S = 10^{-8}$。两种方法都应该表现良好；与 $S$ 相比，绝对误差预期会非常小。\n3. 序列3：$\\left(\"0.0\",\\, 50000\\right)$。此处 $S = 0$。两种方法在浮点运算中都应精确地得到 $0$，从而产生零绝对误差。\n4. 序列4：$\\left(\"1e-16\",\\, 300000\\right)$, $\\left(\"1.0\",\\, 1\\right)$, $\\left(\"-1.0\",\\, 1\\right)$, $\\left(\"1e-16\",\\, 300000\\right)$, $\\left(\"-1e-16\",\\, 600000\\right)$。此处 $S = 0$。长串的微小项与巨大的抵消项交织在一起，对两种方法都构成了考验；补偿方法减少了舍入误差的累积。\n\n程序必须实现这些步骤，并以完全相同的格式打印单行内容：\n$$\n\\left[\\,[e_{n,1},e_{k,1},b_1],\\,[e_{n,2},e_{k,2},b_2],\\,[e_{n,3},e_{k,3},b_3],\\,[e_{n,4},e_{k,4},b_4]\\,\\right].\n$$", "answer": "```python\nimport math\nfrom decimal import Decimal, getcontext\n\n# No external input; all parameters are embedded per the problem statement.\n\ndef naive_sum(seq_iter):\n    \"\"\"Naive left-to-right summation over an iterator of floats.\"\"\"\n    s = 0.0\n    for x in seq_iter:\n        s += x\n    return s\n\ndef kahan_sum(seq_iter):\n    \"\"\"Kahan compensated summation over an iterator of floats.\"\"\"\n    s = 0.0\n    c = 0.0\n    for x in seq_iter:\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef float_generator_from_segments(segments):\n    \"\"\"\n    Yield floats in the specified order for segments specified as\n    a list of tuples: (value_string, count_int).\n    \"\"\"\n    for v_str, cnt in segments:\n        x = float(v_str)\n        for _ in range(cnt):\n            yield x\n\ndef exact_sum_from_segments(segments, D=10**16):\n    \"\"\"\n    Compute the exact rational sum as N/D where D=10^16, by summing integer numerators.\n    Each value v_str must be a decimal with at most 16 digits after the decimal point.\n    Returns the exact sum as a float for error comparison.\n    \"\"\"\n    # Use high precision Decimal to convert values exactly, then multiply by D to get integer.\n    getcontext().prec = 50\n    D_dec = Decimal(D)\n    N = 0  # integer numerator\n    for v_str, cnt in segments:\n        v_dec = Decimal(v_str)\n        n_v = int((v_dec * D_dec).to_integral_exact())  # exact integer for given test suite\n        if cnt:\n            N += n_v * cnt\n    # Convert to float for error measurement; loss here is negligible vs measured errors\n    return N / D\n\ndef compute_case(segments):\n    \"\"\"Compute absolute errors for naive and Kahan sums against exact rational baseline.\"\"\"\n    true_sum = exact_sum_from_segments(segments)\n    nsum = naive_sum(float_generator_from_segments(segments))\n    ksum = kahan_sum(float_generator_from_segments(segments))\n    en = abs(nsum - true_sum)\n    ek = abs(ksum - true_sum)\n    return [en, ek, ek < en]\n\ndef solve():\n    # Define the test cases as per the problem statement.\n    test_cases = [\n        # 1) (\"1.0\", 1), (\"1e-16\", 1000000), (\"-1.0\", 1)\n        [(\"1.0\", 1), (\"1e-16\", 1_000_000), (\"-1.0\", 1)],\n        # 2) (\"1e-8\", 100000), (\"-1e-8\", 99999)\n        [(\"1e-8\", 100_000), (\"-1e-8\", 99_999)],\n        # 3) (\"0.0\", 50000)\n        [(\"0.0\", 50_000)],\n        # 4) (\"1e-16\", 300000), (\"1.0\", 1), (\"-1.0\", 1), (\"1e-16\", 300000), (\"-1e-16\", 600000)\n        [(\"1e-16\", 300_000), (\"1.0\", 1), (\"-1.0\", 1), (\"1e-16\", 300_000), (\"-1e-16\", 600_000)],\n    ]\n\n    results = []\n    for segments in test_cases:\n        res = compute_case(segments)\n        results.append(res)\n\n    # Print in the exact required single-line format.\n    # Convert booleans and floats to their standard string representations.\n    def fmt(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(fmt(x) for x in item) + \"]\"\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        # float or int\n        return str(item)\n\n    print(fmt(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}