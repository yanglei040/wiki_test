{"hands_on_practices": [{"introduction": "在我们进入复杂的算法分析之前，让我们从一个核心的金融场景开始，直观地理解“条件作用”这一概念。在金融建模中，我们依赖的输入参数，如公司的贝塔系数 $(\\beta)$，通常是带有不确定性的估计值。这个练习将通过一个资本资产定价模型 (CAPM) 和永续增长模型的估值案例，来量化一个微小的贝塔 $(\\beta)$ 测量误差如何被放大，最终导致项目净现值 (NPV) 的巨大变化，甚至颠覆投资决策。通过这个计算，您将亲身体会到为何理解一个问题的内在敏感性（即其“条件数”）是任何数值分析的第一步。[@problem_id:2370897]", "id": "2370897", "problem": "一家公司考虑一个全股权项目，在时间 $t=0$ 时需要一笔初始投资 $I = 199$。该项目预计将从时间 $t=1$ 开始产生一笔等于 $C_{1} = 1$ 的自由现金流，此后每期以 $g = 0.06$ 的恒定增长率永久增长。该公司使用资本资产定价模型 (CAPM) 对现金流进行折现，其中股权成本为 $r(\\beta) = r_{f} + \\beta\\big(E[R_{m}] - r_{f}\\big)$。无风险利率为 $r_{f} = 0.02$，市场风险溢价为 $E[R_{m}] - r_{f} = 0.05$。该公司的真实贝塔系数为 $\\beta^{\\ast} = 0.9$。\n\n投资规则是：如果使用测算的贝塔系数 $\\widehat{\\beta}$ 计算出的净现值为非负，则接受该项目，否则拒绝。如果基于 $\\widehat{\\beta}$ 的决策与使用真实 $\\beta^{\\ast}$ 做出的决策不同，则会发生错误决策。\n\n计算导致决策从在真实 $\\beta^{\\ast}$ 下的接受翻转为在使用 $\\widehat{\\beta}$ 时的拒绝的最小贝塔系数绝对估计误差 $|\\widehat{\\beta} - \\beta^{\\ast}|$。请用精确分数形式提供答案。", "solution": "必须首先验证问题陈述的科学合理性、良定性和客观性。\n\n**步骤1：提取已知条件**\n- 初始投资：$I = 199$\n- 时间t=1时的初始现金流：$C_{1} = 1$\n- 现金流的恒定增长率：$g = 0.06$\n- 股权成本模型 (CAPM)：$r(\\beta) = r_{f} + \\beta\\big(E[R_{m}] - r_{f}\\big)$\n- 无风险利率：$r_{f} = 0.02$\n- 市场风险溢价：$E[R_{m}] - r_{f} = 0.05$\n- 真实项目贝塔系数：$\\beta^{\\ast} = 0.9$\n- 测算的项目贝塔系数：$\\widehat{\\beta}$\n- 投资规则：如果净现值 $NPV(\\widehat{\\beta}) \\ge 0$ 则接受，否则拒绝。\n- 如果使用 $\\widehat{\\beta}$ 的结果与使用 $\\beta^{\\ast}$ 的结果不同，则发生错误决策。\n- 目标是找到导致决策从接受翻转为拒绝的最小绝对估计误差 $|\\widehat{\\beta} - \\beta^{\\ast}|$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题基于公司金融中标准且完善的原则：用于估值的增长永续模型（戈登增长模型）和用于确定折现率的资本资产定价模型 (CAPM)。所提供的数据是自洽且内部一致的。永续年金公式要求折现率 $r$ 大于增长率 $g$。使用真实贝塔系数 $\\beta^{\\ast} = 0.9$，折现率为 $r(\\beta^{\\ast}) = 0.02 + 0.9(0.05) = 0.02 + 0.045 = 0.065$。该值大于增长率 $g=0.06$，因此估值是良定的。因此，该问题具有科学依据且是良定的。语言客观、定量。未发现任何瑕疵。\n\n**步骤3：结论与行动**\n该问题有效。现在将提供完整的解题过程。\n\n**解题推导**\n\n对于一个有初始投资 $I$，从 $C_1$ 开始并以增长率 $g$ 永久增长的现金流流项目，其净现值 (NPV) 由增长永续年金公式给出：\n$$\nNPV = \\frac{C_1}{r - g} - I\n$$\n其中 $r$ 是适用的折现率。该公式仅在 $r > g$ 时有效。\n\n折现率 $r$ 是股权成本，由资本资产定价模型 (CAPM) 决定，是项目贝塔系数 $\\beta$ 的函数：\n$$\nr(\\beta) = r_{f} + \\beta\\big(E[R_{m}] - r_{f}\\big)\n$$\n代入给定值，我们有：\n$$\nr(\\beta) = 0.02 + \\beta(0.05)\n$$\n因此，NPV 作为 $\\beta$ 的函数为：\n$$\nNPV(\\beta) = \\frac{C_1}{r_f + \\beta(E[R_m] - r_f) - g} - I = \\frac{1}{0.02 + 0.05\\beta - 0.06} - 199 = \\frac{1}{0.05\\beta - 0.04} - 199\n$$\n\n首先，我们使用真实贝塔系数 $\\beta^{\\ast} = 0.9$ 来确定正确的投资决策。\n真实的折现率为：\n$$\nr(\\beta^{\\ast}) = r(0.9) = 0.02 + 0.9(0.05) = 0.02 + 0.045 = 0.065\n$$\n由于 $r(\\beta^{\\ast}) = 0.065 > g = 0.06$，估值有效。在真实贝塔系数下的 NPV 为：\n$$\nNPV(\\beta^{\\ast}) = \\frac{1}{0.065 - 0.06} - 199 = \\frac{1}{0.005} - 199 = 200 - 199 = 1\n$$\n由于 $NPV(\\beta^{\\ast}) = 1 > 0$，正确的决策是**接受**该项目。\n\n问题要求的是能够将此决策翻转为**拒绝**的最小估计误差 $|\\widehat{\\beta} - \\beta^{\\ast}|$。当计算出的 NPV 为负值时，即 $NPV(\\widehat{\\beta}) < 0$，会发生拒绝。决策在边界 $NPV(\\widehat{\\beta}) = 0$ 处翻转。我们来求解使此等式成立的临界贝塔系数 $\\widehat{\\beta}_{crit}$。\n$$\nNPV(\\widehat{\\beta}_{crit}) = \\frac{1}{r(\\widehat{\\beta}_{crit}) - g} - I = 0\n$$\n$$\n\\frac{1}{r(\\widehat{\\beta}_{crit}) - 0.06} = 199\n$$\n$$\nr(\\widehat{\\beta}_{crit}) - 0.06 = \\frac{1}{199}\n$$\n$$\nr(\\widehat{\\beta}_{crit}) = 0.06 + \\frac{1}{199}\n$$\n现在，我们代入 $r(\\widehat{\\beta}_{crit})$ 的 CAPM 公式：\n$$\n0.02 + 0.05\\widehat{\\beta}_{crit} = 0.06 + \\frac{1}{199}\n$$\n求解 $\\widehat{\\beta}_{crit}$：\n$$\n0.05\\widehat{\\beta}_{crit} = 0.06 - 0.02 + \\frac{1}{199} = 0.04 + \\frac{1}{199}\n$$\n$$\n\\widehat{\\beta}_{crit} = \\frac{0.04 + \\frac{1}{199}}{0.05} = \\frac{0.04}{0.05} + \\frac{1}{199 \\times 0.05} = \\frac{4}{5} + \\frac{1}{9.95} = \\frac{4}{5} + \\frac{1}{199/20} = \\frac{4}{5} + \\frac{20}{199}\n$$\n为了合并这些分数，我们找一个公分母：\n$$\n\\widehat{\\beta}_{crit} = \\frac{4 \\times 199 + 20 \\times 5}{5 \\times 199} = \\frac{796 + 100}{995} = \\frac{896}{995}\n$$\n$NPV(\\beta)$ 函数，$NPV(\\beta) = \\frac{1}{0.05\\beta - 0.04} - 199$，在 $\\beta > 0.04/0.05 = 0.8$ 的区间内是 $\\beta$ 的递减函数。由于 $\\beta^{\\ast} = 0.9 > 0.8$，我们处于一个更高的贝塔系数会导致更低的 NPV 的区域。\n正确的决策是接受 ($NPV > 0$)。要翻转为拒绝 ($NPV < 0$)，需要估计的贝塔系数 $\\widehat{\\beta}$ 大于临界贝塔系数 $\\widehat{\\beta}_{crit}$。\n由于 $NPV(\\beta^{\\ast}) > 0$ 且 $NPV(\\widehat{\\beta}_{crit}) = 0$，并且 NPV 是 $\\beta$ 的递减函数，因此必然有 $\\widehat{\\beta}_{crit} > \\beta^{\\ast}$。\n我们来验证一下：$\\widehat{\\beta}_{crit} = \\frac{896}{995} \\approx 0.9005025$ 且 $\\beta^{\\ast} = 0.9$。确实，$\\widehat{\\beta}_{crit} > \\beta^{\\ast}$。\n\n导致决策翻转的最小绝对估计误差 $|\\widehat{\\beta} - \\beta^{\\ast}|$ 是临界贝塔系数与真实贝塔系数之差。对于任何大于此值的误差，如果误差为正 ($\\widehat{\\beta} > \\beta^{\\ast}$)，则会发生拒绝。\n$$\n|\\widehat{\\beta}_{crit} - \\beta^{\\ast}| = \\widehat{\\beta}_{crit} - \\beta^{\\ast} = \\frac{896}{995} - 0.9 = \\frac{896}{995} - \\frac{9}{10}\n$$\n我们使用公分母 $9950$ 计算差值：\n$$\n\\frac{896 \\times 10}{9950} - \\frac{9 \\times 995}{9950} = \\frac{8960 - 8955}{9950} = \\frac{5}{9950}\n$$\n将分子和分母同时除以 $5$ 来化简该分数：\n$$\n\\frac{5 \\div 5}{9950 \\div 5} = \\frac{1}{1990}\n$$\n因此，导致决策从接受翻转为拒绝的最小贝塔系数绝对估计误差为 $\\frac{1}{1990}$。", "answer": "$$\n\\boxed{\\frac{1}{1990}}\n$$"}, {"introduction": "上一个练习揭示了问题本身的敏感性。现在，我们转向另一个关键概念：算法稳定性。一个问题可能本身是良性的（即“良态的”），但一个糟糕的算法选择却可能导致灾难性的结果。这个实践将通过求解一个被巧妙构建的、代表无套利均衡方程的 $2 \\times 2$ 线性系统 $A(\\varepsilon)x=b$ 来展示这一点。您将分别使用带主元选择和不带主元选择的高斯消元法来求解同一个良态系统，并观察两者在数值精度上的巨大差异。这个练习的核心目的是清晰地分离问题条件作用和算法稳定性这两个概念，让您深刻理解一个看似微不足道的算法细节（如行交换）为何是保证数值计算结果可靠性的生命线。[@problem_id:2370924]", "id": "2370924", "problem": "考虑一个线性方程组，该方程组编码了一个具有较小比例扭曲的摩擦市场中两个合成投资组合之间的成对无套利平衡。设未知向量为 $x \\in \\mathbb{R}^{2}$，对于给定的参数 $\\varepsilon \\in (0,1)$，定义系数矩阵和右侧向量如下\n$$\nA(\\varepsilon) \\equiv \\begin{bmatrix}\n\\varepsilon & 1 \\\\\n1 & 1\n\\end{bmatrix}, \\qquad \nb \\equiv \\begin{bmatrix}\n1 \\\\\n2\n\\end{bmatrix}.\n$$\n该系统可以解释为一组线性的无套利一致性方程，它将两个复制策略与一个仅出现在第一个方程中的小摩擦参数 $\\varepsilon$ 联系起来。这些方程是无量纲的，不需要物理单位。\n\n定义关于欧几里得范数的谱条件数如下\n$$\n\\kappa_{2}\\!\\left(A(\\varepsilon)\\right) \\equiv \\|A(\\varepsilon)\\|_{2}\\,\\|A(\\varepsilon)^{-1}\\|_{2}.\n$$\n\n定义解 $x$ 的两个计算近似值如下：\n1. $x_{\\mathrm{np}}(\\varepsilon)$ 是通过三角分解求解 $A(\\varepsilon)\\,x=b$ 的结果，该分解在每一步都保持行序固定（无行交换）。\n2. $x_{\\mathrm{pp}}(\\varepsilon)$ 是通过三角分解求解 $A(\\varepsilon)\\,x=b$ 的结果，该分解在每个消元步骤中，在活动子矩阵内对行进行重排，以使当前列的主元具有最大绝对值（允许在列内进行行交换）。\n\n设精确解记为 $x^{\\star}(\\varepsilon)$，并定义任意近似值 $y \\in \\mathbb{R}^{2}$ 的相对误差如下\n$$\n\\mathcal{E}(y;\\varepsilon) \\equiv \\frac{\\|y - x^{\\star}(\\varepsilon)\\|_{2}}{\\|x^{\\star}(\\varepsilon)\\|_{2}}.\n$$\n\n对于每个指定的测试用例值 $\\varepsilon$，您的程序必须计算三元组\n$$\n\\left(\\kappa_{2}\\!\\left(A(\\varepsilon)\\right), \\ \\mathcal{E}\\!\\left(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon\\right), \\ \\mathcal{E}\\!\\left(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon\\right)\\right),\n$$\n然后评估布尔值\n$$\nS(\\varepsilon) \\equiv \\Big(\\kappa_{2}\\!\\left(A(\\varepsilon)\\right) \\leq 10\\Big) \\ \\wedge \\ \\Big(\\mathcal{E}\\!\\left(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon\\right) \\geq 10^{-3}\\Big) \\ \\wedge \\ \\Big(\\mathcal{E}\\!\\left(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon\\right) \\leq 10^{-12}\\Big).\n$$\n其预期解释是，$S(\\varepsilon)$为真当且仅当系统是良态的，同时固定行序的消元法产生较大的向前误差，而进行行交换的消元法保持高精度。\n\n测试套件：\n- $\\varepsilon = 10^{-16}$\n- $\\varepsilon = 10^{-12}$\n- $\\varepsilon = 10^{-8}$\n- $\\varepsilon = 10^{-4}$\n- $\\varepsilon = 10^{-1}$\n\n答案规格：\n- 对于上面按序列出的每个测试用例，计算定义的 $S(\\varepsilon)$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_{1},r_{2},r_{3},r_{4},r_{5}]$，其中每个 $r_{i}$ 是对应于第 $i$ 个测试用例的 $S(\\varepsilon)$ 的字面标记 True 或 False。\n\n所有计算必须使用标准双精度浮点算法进行。此任务不涉及角度和物理单位，也不需要百分比；任何比率都应以纯小数形式报告。", "solution": "提交分析的问题陈述被认为是有效的。这是一个适定、有科学依据的数值线性代数问题，其表述客观而精确。所有必要的数据、定义和约束都已提供，不存在内部矛盾或逻辑缺陷。该问题要求分析算法稳定性，这是计算科学中的一个基本概念。我们将着手解决此问题。\n\n目标是研究在参数 $\\varepsilon$ 取不同小值时，求解线性系统 $A(\\varepsilon)x = b$ 的数值稳定性。具体来说，我们必须比较两种基于三角分解的方法的准确性：一种保持固定行序（不进行主元选择的高斯消元法），另一种则通过重排行来使用最大绝对值的主元（带部分主元选择的高斯消元法）。\n\n首先，让我们确定精确解 $x^{\\star}(\\varepsilon)$，数值近似解将与之进行比较。矩阵 $A(\\varepsilon)$ 由下式给出\n$$\nA(\\varepsilon) = \\begin{bmatrix} \\varepsilon & 1 \\\\ 1 & 1 \\end{bmatrix}.\n$$\n其行列式为 $\\det(A(\\varepsilon)) = \\varepsilon \\cdot 1 - 1 \\cdot 1 = \\varepsilon - 1$。由于问题指定 $\\varepsilon \\in (0,1)$，行列式非零，因此矩阵始终可逆。其逆矩阵是\n$$\nA(\\varepsilon)^{-1} = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} 1 & -1 \\\\ -1 & \\varepsilon \\end{bmatrix}.\n$$\n因此，精确解 $x^{\\star}(\\varepsilon) = A(\\varepsilon)^{-1}b$ 为\n$$\nx^{\\star}(\\varepsilon) = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} 1 & -1 \\\\ -1 & \\varepsilon \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} 1 - 2 \\\\ -1 + 2\\varepsilon \\end{bmatrix} = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} -1 \\\\ -1 + 2\\varepsilon \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{1-\\varepsilon} \\\\ \\frac{1-2\\varepsilon}{1-\\varepsilon} \\end{bmatrix}.\n$$\n当 $\\varepsilon \\to 0$ 时，精确解趋向于 $x^{\\star}(0) = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。对于较小的 $\\varepsilon$，解本身是良态的。\n\n接下来，我们分析问题的条件。谱条件数 $\\kappa_{2}(A(\\varepsilon))$ 衡量解 $x$ 对 $A$ 或 $b$ 中扰动的敏感度。对于 $\\varepsilon \\to 0$，矩阵 $A(\\varepsilon)$ 趋向于 $A(0) = \\begin{bmatrix} 0 & 1 \\\\ 1 & 1 \\end{bmatrix}$。$A(0)$ 的奇异值是 $A(0)^T A(0) = \\begin{bmatrix} 1 & 1 \\\\ 1 & 2 \\end{bmatrix}$ 的特征值的平方根。该矩阵的特征值为 $\\lambda = (3 \\pm \\sqrt{5})/2$。奇异值为 $\\sigma_{\\max} = \\sqrt{(3 + \\sqrt{5})/2}$ 和 $\\sigma_{\\min} = \\sqrt{(3 - \\sqrt{5})/2}$。条件数为\n$$\n\\kappa_{2}(A(0)) = \\frac{\\sigma_{\\max}}{\\sigma_{\\min}} = \\frac{\\sqrt{3+\\sqrt{5}}}{\\sqrt{3-\\sqrt{5}}} = \\frac{3+\\sqrt{5}}{2} \\approx 2.618.\n$$\n这是一个很小的数，表明对于较小的 $\\varepsilon$，矩阵 $A(\\varepsilon)$ 是良态的。该问题本身对小扰动不敏感。因此，对于所有测试值 $\\varepsilon$，$S(\\varepsilon)$ 中的第一个条件 $\\kappa_{2}(A(\\varepsilon)) \\leq 10$ 都将得到满足。因此，计算解中的任何大误差都必定源于所用算法的不稳定性，而非问题本身的病态性。\n\n现在我们来分析第一种数值方法 $x_{\\mathrm{np}}(\\varepsilon)$，它对应于不进行主元选择的高斯消元法。我们对 $A(\\varepsilon)$ 进行 LU 分解，即 $A(\\varepsilon) = LU$。\n$$\nA(\\varepsilon) = \\begin{bmatrix} \\varepsilon & 1 \\\\ 1 & 1 \\end{bmatrix}.\n$$\n为消去元素 $a_{21}=1$，我们使用乘子 $m_{21} = a_{21}/a_{11} = 1/\\varepsilon$。得到的上三角矩阵 $U$ 是\n$$\nU = \\begin{bmatrix} \\varepsilon & 1 \\\\ 0 & 1 - 1/\\varepsilon \\end{bmatrix}.\n$$\n下三角矩阵 $L$ 是\n$$\nL = \\begin{bmatrix} 1 & 0 \\\\ 1/\\varepsilon & 1 \\end{bmatrix}.\n$$\n对于一个很小的 $\\varepsilon$（例如 $\\varepsilon \\approx 10^{-16}$），乘子 $1/\\varepsilon$ 会变得极大。在标准双精度浮点运算中（其机器 $\\varepsilon$ 约为 $2.2 \\times 10^{-16}$），计算项 $\\mathrm{fl}(1 - 1/\\varepsilon)$ 会遭受灾难性抵消。与 $1/\\varepsilon$ 相比，数字 $1$ 微不足道，所以结果就是 $\\mathrm{fl}(-1/\\varepsilon)$。\n该系统通过前向替换 $Ly=b$ 和后向替换 $Ux=y$ 求解。\n求解 $Ly=b$：\n$y_1 = b_1 = 1$。\n$(1/\\varepsilon)y_1 + y_2 = b_2 \\implies y_2 = 2 - 1/\\varepsilon$。\n在浮点运算中，$\\mathrm{fl}(y_2) = \\mathrm{fl}(2 - 1/\\varepsilon) \\approx -1/\\varepsilon$。\n求解 $Ux=y$：\n计算出的 $U$ 矩阵的 $(2,2)$ 元素是 $\\tilde{u}_{22} = \\mathrm{fl}(1-1/\\varepsilon) \\approx -1/\\varepsilon$。\n$\\tilde{u}_{22} x_2 = \\tilde{y}_2 \\implies (-1/\\varepsilon) x_2 \\approx -1/\\varepsilon \\implies x_2 \\approx 1$。\n$\\varepsilon x_1 + x_2 = y_1 \\implies \\varepsilon x_1 + 1 \\approx 1 \\implies \\varepsilon x_1 \\approx 0 \\implies x_1 \\approx 0$。\n计算出的解是 $x_{\\mathrm{np}}(\\varepsilon) \\approx \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$。\n将其与小 $\\varepsilon$ 的精确解 $x^{\\star}(\\varepsilon) \\approx \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$ 比较，误差是巨大的。相对误差为\n$$\n\\mathcal{E}(x_{\\mathrm{np}};\\varepsilon) = \\frac{\\|x_{\\mathrm{np}} - x^{\\star}(\\varepsilon)\\|_{2}}{\\|x^{\\star}(\\varepsilon)\\|_{2}} \\approx \\frac{\\|\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} - \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\|_{2}}{\\|\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\|_{2}} = \\frac{\\|\\begin{bmatrix} -1 \\\\ 0 \\end{bmatrix}\\|_{2}}{\\sqrt{1^2+1^2}} = \\frac{1}{\\sqrt{2}} \\approx 0.707.\n$$\n这是一个非常大的误差，远超 $10^{-3}$。这说明了当遇到小主元时，不进行主元选择的高斯消元法的数值不稳定性。对于任何足够小以至于引起这种浮点行为的 $\\varepsilon$，这一点都成立。只有当 $\\varepsilon$ 足够大，以至于 $1/\\varepsilon$ 不大时，这种不稳定性才会消失。对于 $\\varepsilon = 10^{-1}$，乘子是 $10$，计算 $1-10=-9$ 在浮点运算中是精确的。在这种情况下，无主元消元法是准确的。因此，条件 $\\mathcal{E}(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon) \\geq 10^{-3}$ 对小 $\\varepsilon$ 为真，但对 $\\varepsilon = 10^{-1}$ 为假。\n\n现在，我们分析第二种方法 $x_{\\mathrm{pp}}(\\varepsilon)$，它对应于带部分主元选择的高斯消元法。在每一步中，交换行以确保主元（对角线元素）在其所在列的活动子矩阵中是最大的。\n对于 $A(\\varepsilon) = \\begin{bmatrix} \\varepsilon & 1 \\\\ 1 & 1 \\end{bmatrix}$ 和 $\\varepsilon \\in (0,1)$，我们有 $|a_{21}| = 1 > |\\varepsilon| = |a_{11}|$。因此，我们必须交换第 1 行和第 2 行。这等价于乘以一个置换矩阵 $P = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}$。系统变为 $PAx=Pb$。\n$$\nPA = \\begin{bmatrix} 1 & 1 \\\\ \\varepsilon & 1 \\end{bmatrix}, \\quad Pb = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix}.\n$$\n现在我们对这个新系统进行消元。乘子是 $m_{21} = \\varepsilon/1 = \\varepsilon$。由于 $|\\varepsilon|<1$，乘子很小，这是一个稳定消元步骤的标志。\n上三角矩阵 $U$ 变为\n$$\nU = \\begin{bmatrix} 1 & 1 \\\\ 0 & 1-\\varepsilon \\end{bmatrix}.\n$$\n运算过程是 $y_1=2$， $y_2=1-2\\varepsilon$，然后 $(1-\\varepsilon)x_2 = 1-2\\varepsilon \\implies x_2 = (1-2\\varepsilon)/(1-\\varepsilon)$，并且 $x_1+x_2=2 \\implies x_1=2-x_2 = 1/(1-\\varepsilon)$。计算出的解与精确解的解析形式相同。由于所有运算都涉及良态算术（没有两个几乎相等的大数相减），浮点计算将非常精确。相对误差 $\\mathcal{E}(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon)$ 将在机器 $\\varepsilon$ 的数量级（约 $10^{-16}$），从而满足所有测试用例的条件 $\\mathcal{E}(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon) \\leq 10^{-12}$。\n\n总结来说，对于 $\\varepsilon \\in \\{10^{-16}, 10^{-12}, 10^{-8}, 10^{-4}\\}$：\n1.  $\\kappa_{2}(A(\\varepsilon)) \\leq 10$ 为 `True`。\n2.  $\\mathcal{E}(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon) \\geq 10^{-3}$ 由于不稳定性为 `True`。\n3.  $\\mathcal{E}(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon) \\leq 10^{-12}$ 由于稳定性为 `True`。\n因此，$S(\\varepsilon)$ 的值为 `True`。\n\n对于 $\\varepsilon=10^{-1}$：\n1.  $\\kappa_{2}(A(0.1)) \\leq 10$ 为 `True`。\n2.  $\\mathcal{E}(x_{\\mathrm{np}}(0.1);\\varepsilon) \\geq 10^{-3}$ 为 `False`，因为乘子 $1/0.1=10$ 不够大，不会引起显著的浮点误差，计算是准确的。\n3.  $\\mathcal{E}(x_{\\mathrm{pp}}(0.1);\\varepsilon) \\leq 10^{-12}$ 为 `True`。\n由于第二个条件为假，$S(0.1)$ 的值为 `False`。\n\n程序将实现这些计算并证实这一推理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The problem can be solved with numpy; scipy is not strictly necessary but is permitted.\n\ndef solve():\n    \"\"\"\n    Solves the specified problem by analyzing the numerical stability of solving\n    a linear system with and without pivoting.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1e-16,\n        1e-12,\n        1e-8,\n        1e-4,\n        1e-1,\n    ]\n\n    results = []\n    \n    for eps in test_cases:\n        # Define the matrix A and vector b for the current epsilon\n        A = np.array([[eps, 1.0], [1.0, 1.0]], dtype=np.float64)\n        b = np.array([1.0, 2.0], dtype=np.float64)\n\n        # --- 1. Calculate the 'exact' solution x_star ---\n        # Using the analytical formula derived from the problem.\n        # This gives a high-precision reference for error calculation.\n        x_star = np.array([1.0 / (1.0 - eps), (1.0 - 2.0 * eps) / (1.0 - eps)], dtype=np.float64)\n\n        # --- 2. Calculate the condition number kappa_2 ---\n        kappa_2 = np.linalg.cond(A, 2)\n\n        # --- 3. Calculate the solution with no pivoting (x_np) ---\n        # This requires manually implementing Gaussian elimination without row swaps.\n        def solve_no_pivot(mat_A, vec_b):\n            n = len(vec_b)\n            A_np = mat_A.copy()\n            b_np = vec_b.copy()\n\n            # Forward elimination to create an upper triangular matrix\n            # This is a 2x2 specific implementation for simplicity and clarity.\n            if A_np[0, 0] == 0:\n                # This case isn't hit for eps > 0 but is a necessary check\n                # for a general algorithm. A zero pivot without pivoting fails.\n                return np.array([np.nan, np.nan])\n            \n            m = A_np[1, 0] / A_np[0, 0]\n            A_np[1, :] -= m * A_np[0, :]\n            b_np[1] -= m * b_np[0]\n            \n            # Backward substitution\n            x = np.zeros(n, dtype=np.float64)\n            if A_np[1, 1] == 0:\n                # Another fail condition, singular matrix after elimination.\n                return np.array([np.nan, np.nan])\n                \n            x[1] = b_np[1] / A_np[1, 1]\n            x[0] = (b_np[0] - A_np[0, 1] * x[1]) / A_np[0, 0]\n            \n            return x\n\n        x_np = solve_no_pivot(A, b)\n        \n        # --- 4. Calculate the solution with partial pivoting (x_pp) ---\n        # np.linalg.solve uses LAPACK routines which employ partial pivoting by default.\n        x_pp = np.linalg.solve(A, b)\n\n        # --- 5. Calculate relative errors ---\n        norm_x_star = np.linalg.norm(x_star, 2)\n        if norm_x_star == 0:\n             # Avoid division by zero, though not relevant for this problem.\n            rel_error_np = np.linalg.norm(x_np - x_star, 2)\n            rel_error_pp = np.linalg.norm(x_pp - x_star, 2)\n        else:\n            rel_error_np = np.linalg.norm(x_np - x_star, 2) / norm_x_star\n            rel_error_pp = np.linalg.norm(x_pp - x_star, 2) / norm_x_star\n            \n        # --- 6. Evaluate the boolean condition S(epsilon) ---\n        S = (kappa_2 <= 10.0) and (rel_error_np >= 1e-3) and (rel_error_pp <= 1e-12)\n        results.append(S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "我们已经看到，一个不稳定的算法可以毁掉一个良态问题。那么，当我们用最稳定、最可靠的算法去处理一个本身就极度敏感（即“病态的”）问题时，会发生什么呢？这个练习将通过求解以“病态”著称的希尔伯特矩阵 $(\\text{Hilbert matrix})$ 构成的线性系统来回答这个问题。您将使用标准的、经过优化的数值库函数（本质上是稳定的）来求解，并观察解的“前向误差”如何随着矩阵维数的增加而急剧恶化，尽管“后向误差”始终保持在机器精度水平。这个实践是一个重要的警示，它揭示了即使是最好的算法也无法克服问题固有的病态性，从而教导我们在进行计算金融分析时，必须对数值结果保持批判性思维，并始终警惕潜在的病态问题。[@problem_id:2421700]", "id": "2421700", "problem": "要求您编写一个完整、可运行的程序，以演示在使用 Hilbert 矩阵求解线性系统时的数值稳定性和不稳定性。一个尺寸为 $n$ 的 Hilbert 矩阵，记为 $H_n$，是一个 $n \\times n$ 的矩阵，其元素为 $H_{ij} = \\dfrac{1}{i + j - 1}$，其中 $1 \\le i, j \\le n$。该矩阵是对称正定的，但它也是出了名的病态矩阵，这意味着微小的扰动（例如，浮点运算带来的舍入误差）可能会导致线性系统计算解的巨大变化。\n\n基本依据和定义：考虑线性系统 $A x = b$，其中 $A$ 为非奇异矩阵。对于解 $x$，以下概念是基础。\n- 前向相对误差为 $\\dfrac{\\lVert \\hat{x} - x \\rVert_2}{\\lVert x \\rVert_2}$。\n- 后向误差（一种常见的归一化选择）为 $\\dfrac{\\lVert A \\hat{x} - b \\rVert_2}{\\lVert A \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}$。\n- 2-范数条件数为 $\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2$。\n\n用作起点的经过充分检验的事实：\n- 在符合 Institute of Electrical and Electronics Engineers (IEEE) $754$ 标准的浮点运算中，稳定的直接求解器（例如，标准库中实现的带部分主元的高斯消元法）通常是后向稳定的：计算解 $\\hat{x}$ 是某个邻近系统 $(A + \\Delta A)\\hat{x} = b$ 的精确解，其中 $\\dfrac{\\lVert \\Delta A \\rVert_2}{\\lVert A \\rVert_2}$ 与单位舍入误差 $u$ （对于双精度，约为 $2^{-53} \\approx 1.11 \\times 10^{-16}$）同量级。\n- 对于小扰动，前向误差的界与条件数成正比：$\\dfrac{\\lVert \\hat{x} - x \\rVert_2}{\\lVert x \\rVert_2} \\lesssim \\kappa_2(A) \\cdot \\dfrac{\\lVert \\Delta A \\rVert_2}{\\lVert A \\rVert_2}$。\n\n任务：实现一个程序，对于指定测试集中的每个 $n$，构造 Hilbert 矩阵 $H_n$，选择一个已知的精确解 $x_\\text{true}$，构造 $b = H_n x_\\text{true}$，在双精度下对系统进行数值求解以获得 $\\hat{x}$，并报告：\n- 前向相对误差 $\\dfrac{\\lVert \\hat{x} - x_\\text{true} \\rVert_2}{\\lVert x_\\text{true} \\rVert_2}$，\n- 归一化后向误差 $\\dfrac{\\lVert H_n \\hat{x} - b \\rVert_2}{\\lVert H_n \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}$，\n- 2-范数条件数 $\\kappa_2(H_n)$。\n\n精确解的选择：使用 $x_\\text{true}$，其元素为 $x_i = (-1)^{i-1}$，$i = 1, \\dots, n$，因此 $x_\\text{true}$ 的元素为 $\\{+1, -1, +1, -1, \\dots\\}$。\n\n数值环境：使用双精度浮点运算。不允许使用随机数。不涉及角度。没有物理单位。\n\n测试集：按顺序对 $n \\in \\{2, 5, 8, 12, 14\\}$ 运行您的程序。这些案例覆盖了基准小尺寸（$n = 2$）、典型的良态中小规模情况（$n = 5$）、明显病态的中等规模情况（$n = 8$）以及两个愈发极端的病态情况（$n = 12$ 和 $n = 14$）。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果。结果是一个用方括号括起来的逗号分隔列表，每个测试用例以 $[n,\\ \\text{forward\\_error},\\ \\text{backward\\_error},\\ \\kappa_2]$ 形式的内部列表报告。输出中任何地方都不能有空格。例如，总体结构必须是 $[[n_1,\\text{forward\\_error}_1,\\text{backward\\_error}_1,\\kappa_{2,1}],[n_2,\\text{forward\\_error}_2,\\text{backward\\_error}_2,\\kappa_{2,2}],\\dots]$。所有数值都应打印为十进制浮点数（可接受科学记数法）。程序不得读取任何输入。", "solution": "所述问题是数值线性代数中的一个标准但基础的练习，是计算科学的基石。其目的是经验性地展示算法的稳定性与问题条件之间的关键区别。在继续之前，需要进行严格的验证。\n\n该问题要求分析线性系统 $H_n x = b$，其中 $H_n$ 是尺寸为 $n$ 的 Hilbert 矩阵。所有给定条件都已明确陈述：$H_n$ 的定义为 $H_{ij} = (i+j-1)^{-1}$，精确解向量 $x_\\text{true}$ 的选择，向量 $b$ 的构造过程，要使用的数值方法（双精度运算，标准线性求解器），以及要报告的精确量：前向相对误差、归一化后向误差和 2-范数条件数。矩阵尺寸的测试集 $n \\in \\{2, 5, 8, 12, 14\\}$ 也已指定。\n\n问题陈述具有科学依据，借鉴了矩阵分析和数值稳定性理论的既定原则。它是适定的，提供了一套完整且一致的指令，可以导出一个唯一的、可验证的计算结果。其语言客观且明确。因此，问题被认定为有效，并将给出解答。\n\n核心概念是数学问题的条件。如果输入数据的微小相对变化能导致输出解的巨大相对变化，则称该问题是病态的。对于线性系统 $Ax=b$，解 $x$ 对 $A$ 和 $b$ 中扰动的敏感度由矩阵 $A$ 的条件数来衡量，对于 2-范数，其定义为：\n$$\n\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2\n$$\n大的条件数意味着一个病态问题。Hilbert 矩阵是出了名的病态，其 $\\kappa_2(H_n)$ 随 $n$ 呈指数增长。\n\n如果一个解决问题的算法不会引入超出问题条件所固有的显著额外误差，那么它就是数值稳定的。一个后向稳定的算法，例如带部分主元的高斯消元法（像 `numpy.linalg.solve` 这样的标准库求解器的基础），其计算出的解 $\\hat{x}$ 是一个轻微扰动问题的精确解：\n$$\n(A + \\Delta A)\\hat{x} = b, \\quad \\text{where} \\quad \\frac{\\lVert \\Delta A \\rVert_2}{\\lVert A \\rVert_2} \\approx u\n$$\n在这里，$u$ 是单位舍入误差，或称机器精度（对于 IEEE $754$ 双精度， $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$）。小的后向误差是此属性的一种体现。问题定义了一个特定的归一化后向误差：\n$$\nE_b = \\frac{\\lVert A \\hat{x} - b \\rVert_2}{\\lVert A \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}\n$$\n这个量衡量了残差 $A\\hat{x}-b$ 相对于问题规模的大小。对于一个后向稳定的算法，我们期望 $E_b$ 很小，与 $u$ 同量级。\n\n相比之下，前向相对误差衡量了解本身的差异：\n$$\nE_f = \\frac{\\lVert \\hat{x} - x_\\text{true} \\rVert_2}{\\lVert x_\\text{true} \\rVert_2}\n$$\n连接这些量的基本关系近似由下式给出：\n$$\nE_f \\lesssim \\kappa_2(A) \\cdot (\\text{backward error})\n$$\n这个不等式表明，即使使用后向稳定的算法（小的后向误差），如果问题是病态的（大的 $\\kappa_2(A)$），计算解中的前向误差也可能大到不可接受。Hilbert 矩阵为这一现象提供了一个经典案例研究。\n\n对于测试集 $\\{2, 5, 8, 12, 14\\}$ 中的每个 $n$，要实现的计算流程如下：\n$1$. 构造 $n \\times n$ 的 Hilbert 矩阵 $H_n$，其元素为 $H_{ij} = (i+j-1)^{-1}$，$i,j \\in \\{1, \\dots, n\\}$。\n$2$. 构造尺寸为 $n$ 的真实解向量 $x_\\text{true}$，其元素为 $(x_\\text{true})_i = (-1)^{i-1}$，$i \\in \\{1, \\dots, n\\}$。\n$3$. 计算右端向量 $b = H_n x_\\text{true}$。此计算在双精度下进行，其结果是数值测试的参考右端项。\n$4$. 数值求解线性系统 $H_n x = b$ 以获得计算解 $\\hat{x}$。这将使用标准的、稳定的直接求解器完成。\n$5$. 计算三个所需的诊断量：\n    a. 2-范数条件数，$\\kappa_2(H_n)$。\n    b. 前向相对误差，$E_f = \\frac{\\lVert \\hat{x} - x_\\text{true} \\rVert_2}{\\lVert x_\\text{true} \\rVert_2}$。\n    c. 归一化后向误差，$E_b = \\frac{\\lVert H_n \\hat{x} - b \\rVert_2}{\\lVert H_n \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}$。\n$6$. 收集并报告结果 $[n, E_f, E_b, \\kappa_2(H_n)]$。\n\n预期行为：随着 $n$ 的增加，$\\kappa_2(H_n)$ 将会极快地增长。归一化后向误差 $E_b$ 将保持很小，接近机器精度，从而证实求解器的稳定性。因此，前向误差 $E_f$ 将会急剧增长，大致与乘积 $\\kappa_2(H_n) \\cdot u$ 的趋势一致。对于 $n=12$ 和 $n=14$，条件数将非常大，以至于 $\\kappa_2(H_n) \\cdot u \\gg 1$，这表明该矩阵是数值奇异的，并且计算出的解 $\\hat{x}$ 预计将不具有任何正确的有效数字。本程序将精确地展示这一行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Demonstrates numerical stability and instability when solving a linear system\n    with a Hilbert matrix for various sizes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [2, 5, 8, 12, 14]\n\n    results = []\n    for n in test_cases:\n        # Construct the Hilbert matrix H_n.\n        # scipy.linalg.hilbert uses 1-based indexing in its definition,\n        # which matches the problem statement.\n        H = linalg.hilbert(n)\n\n        # Construct the known exact solution x_true with entries (-1)^(i-1).\n        # For 0-based array indexing, this is (-1)^i.\n        x_true = np.array([(-1)**i for i in range(n)])\n\n        # Construct the right-hand side vector b = H_n * x_true.\n        # This is performed in standard double-precision floating-point arithmetic.\n        b = H @ x_true\n\n        # Solve the system H_n * x = b numerically to obtain the computed solution x_hat.\n        # numpy.linalg.solve is a backward stable direct solver.\n        x_hat = np.linalg.solve(H, b)\n\n        # Calculate the 2-norm condition number of H_n.\n        # This is kappa_2(H_n) = ||H_n||_2 * ||H_n^-1||_2.\n        cond_num = np.linalg.cond(H, p=2)\n\n        # Calculate the forward relative error: ||x_hat - x_true||_2 / ||x_true||_2.\n        norm_x_true = np.linalg.norm(x_true, ord=2)\n        norm_error_x = np.linalg.norm(x_hat - x_true, ord=2)\n        forward_error = norm_error_x / norm_x_true\n\n        # Calculate the normalized backward error:\n        # ||H_n * x_hat - b||_2 / (||H_n||_2 * ||x_hat||_2 + ||b||_2).\n        residual_vec = H @ x_hat - b\n        norm_residual = np.linalg.norm(residual_vec, ord=2)\n        norm_H = np.linalg.norm(H, ord=2)\n        norm_x_hat = np.linalg.norm(x_hat, ord=2)\n        norm_b = np.linalg.norm(b, ord=2)\n        backward_error = norm_residual / (norm_H * norm_x_hat + norm_b)\n        \n        # Store the results for the current n.\n        results.append([n, forward_error, backward_error, cond_num])\n\n    # Format the final output string exactly as required.\n    # Each sublist is formatted as \"[n,ferr,berr,cond]\" with no spaces.\n    str_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    \n    # All sublist strings are joined by commas and enclosed in brackets.\n    final_output_str = f\"[{','.join(str_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n\n```"}]}