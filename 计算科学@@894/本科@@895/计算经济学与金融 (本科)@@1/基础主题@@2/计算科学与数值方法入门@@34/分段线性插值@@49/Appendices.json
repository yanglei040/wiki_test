{"hands_on_practices": [{"introduction": "这个练习将分段线性插值应用于资本预算中的一个核心问题：估算内部收益率（$IRR$）。通过在已知净现值（$NPV$）的离散利率点之间进行插值，你将能够近似求解使 $NPV$ 为零的利率。通过将插值结果与真实 $IRR$ 进行比较，你将对插值误差及其在金融决策中的实际影响有更深刻的理解。[@problem_id:2419227]", "id": "2419227", "problem": "在计算经济学和计算金融学的资本预算中，一个具有现金流序列 $\\{C_{0}, C_{1}, \\dots, C_{T}\\}$ 的确定性项目，以贴现率 $r$ 贴现后的净现值 (NPV) 由以下基本现值关系定义：\n$$\n\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{T} \\frac{C_{t}}{(1+r)^{t}}.\n$$\n内部收益率 (IRR) 定义为满足 $\\mathrm{NPV}(r^{\\ast})=0$ 的唯一实数 $r^{\\ast}$（如果存在）。\n\n考虑一个单期项目，其在时间 $t=0$ 的现金流为 $C_{0}=-100$，在时间 $t=1$ 的现金流为 $C_{1}=103.5$。假设一位分析师仅在一组离散利率 $r \\in \\{0.01,0.02,\\dots,0.10\\}$ 上计算该项目的 $\\mathrm{NPV}(r)$，然后使用 $\\mathrm{NPV}(r)$ 在相邻网格点之间的分段线性插值来估算IRR。\n\n仅使用框定 $\\mathrm{NPV}(r)$ 符号变化的两个连续网格利率，构建该区间上 $\\mathrm{NPV}(r)$ 的线性插值函数，并求解插值得到的IRR。接着，从第一性原理精确计算真实的IRR。最后，将插值IRR与真实IRR之间的绝对差值以单一数字报告。请将最终答案表示为一个精确分数（无四舍五入）。百分比必须表示为小数或分数，不得使用百分号。", "solution": "在尝试任何解答之前，对问题陈述进行严格验证。\n\n步骤1：提取已知条件\n-   净现值 (NPV) 定义： $\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{T} \\frac{C_{t}}{(1+r)^{t}}$\n-   内部收益率 (IRR) 定义：满足 $\\mathrm{NPV}(r^{\\ast}) = 0$ 的唯一实数 $r^{\\ast}$。\n-   项目现金流：$t=0$ 时，$C_{0}=-100$；$t=1$ 时，$C_{1}=103.5$。\n-   项目期限：$T=1$。\n-   用于插值的离散利率集合：$r \\in \\{0.01, 0.02, \\dots, 0.10\\}$。\n-   任务1：使用框定 $\\mathrm{NPV}(r)$ 符号变化的两个连续网格利率之间的分段线性插值来估算IRR ($r_{\\text{interp}}$)。\n-   任务2：精确计算真实IRR ($r_{\\text{true}}$)。\n-   任务3：将绝对差值 $|r_{\\text{interp}} - r_{\\text{true}}|$ 报告为精确分数。\n\n步骤2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n-   **科学依据**：NPV、IRR和线性插值的概念在金融学和数值分析中是标准且成熟的。其前提在事实上和数学上都是合理的。\n-   **适定性**：问题提供了所有必要的数据和一个清晰、无歧义的目标。存在唯一解，并且可以从所提供的信息中推导出来。\n-   **客观性**：问题以精确、正式的语言陈述，没有主观性或歧义。\n\n步骤3：结论与行动\n该问题是有效的。它是自洽的、有科学依据的并且是适定的。将推导解答。\n\n对于给定的单期项目，其NPV为：\n$$\n\\mathrm{NPV}(r) = C_{0} + \\frac{C_{1}}{1+r} = -100 + \\frac{103.5}{1+r}\n$$\n\n第一步是确定执行线性插值的区间。我们必须在指定的网格点上评估 $\\mathrm{NPV}(r)$，以找到两个连续的利率 $r_{1}$ 和 $r_{2}$，使得 $\\mathrm{NPV}(r_{1})$ 和 $\\mathrm{NPV}(r_{2})$ 的符号相反。对于 $r > -1$，函数 $\\mathrm{NPV}(r)$ 是 $r$ 的单调递减函数。\n\n让我们在网格点上进行评估：\n$\\mathrm{NPV}(0.01) = -100 + \\frac{103.5}{1.01} \\approx 2.475 > 0$\n$\\mathrm{NPV}(0.02) = -100 + \\frac{103.5}{1.02} \\approx 1.471 > 0$\n$\\mathrm{NPV}(0.03) = -100 + \\frac{103.5}{1.03} = -100 + \\frac{10350}{103} = \\frac{-10300 + 10350}{103} = \\frac{50}{103} > 0$\n$\\mathrm{NPV}(0.04) = -100 + \\frac{103.5}{1.04} = -100 + \\frac{10350}{104} = \\frac{-10400 + 10350}{104} = -\\frac{50}{104} < 0$\n\n符号变化发生在区间 $[0.03, 0.04]$ 内。因此，我们使用点 $(r_{1}, \\mathrm{NPV}(r_{1}))$ 和 $(r_{2}, \\mathrm{NPV}(r_{2}))$，其中 $r_{1} = 0.03$ 且 $r_{2} = 0.04$。相应的NPV值为 $\\mathrm{NPV}(r_{1}) = \\frac{50}{103}$ 和 $\\mathrm{NPV}(r_{2}) = -\\frac{50}{104}$。\n\n我们构建一个经过这两点的线性插值函数 $L(r)$。插值得到的IRR，我们记作 $r_{\\text{interp}}$，是该线性函数的根，即 $L(r_{\\text{interp}}) = 0$。使用线性插值公式（或割线法）：\n$$\nr_{\\text{interp}} = r_{1} - \\mathrm{NPV}(r_{1}) \\frac{r_{2} - r_{1}}{\\mathrm{NPV}(r_{2}) - \\mathrm{NPV}(r_{1})}\n$$\n代入已知值：\n$$\nr_{\\text{interp}} = 0.03 - \\left(\\frac{50}{103}\\right) \\frac{0.04 - 0.03}{\\left(-\\frac{50}{104}\\right) - \\left(\\frac{50}{103}\\right)} = 0.03 - \\left(\\frac{50}{103}\\right) \\frac{0.01}{-50 \\left(\\frac{1}{104} + \\frac{1}{103}\\right)}\n$$\n$$\nr_{\\text{interp}} = 0.03 + \\frac{1}{103} \\frac{0.01}{\\frac{103+104}{104 \\cdot 103}} = 0.03 + \\frac{0.01}{103} \\frac{104 \\cdot 103}{207} = 0.03 + 0.01 \\cdot \\frac{104}{207}\n$$\n表示为分数：\n$$\nr_{\\text{interp}} = \\frac{3}{100} + \\frac{1}{100} \\cdot \\frac{104}{207} = \\frac{1}{100} \\left( 3 + \\frac{104}{207} \\right) = \\frac{1}{100} \\left( \\frac{3 \\cdot 207 + 104}{207} \\right)\n$$\n$$\nr_{\\text{interp}} = \\frac{1}{100} \\left( \\frac{621 + 104}{207} \\right) = \\frac{725}{20700}\n$$\n这个分数可以化简。分子和分母都可以被 $25$ 整除：\n$$\nr_{\\text{interp}} = \\frac{725 \\div 25}{20700 \\div 25} = \\frac{29}{828}\n$$\n接下来，我们通过设置 $\\mathrm{NPV}(r_{\\text{true}})=0$ 来计算真实IRR, $r_{\\text{true}}$：\n$$\n-100 + \\frac{103.5}{1+r_{\\text{true}}} = 0\n$$\n$$\n\\frac{103.5}{1+r_{\\text{true}}} = 100\n$$\n$$\n1+r_{\\text{true}} = \\frac{103.5}{100} = 1.035\n$$\n$$\nr_{\\text{true}} = 1.035 - 1 = 0.035\n$$\n作为精确分数：\n$$\nr_{\\text{true}} = \\frac{35}{1000} = \\frac{7}{200}\n$$\n最后，我们计算插值IRR与真实IRR之间的绝对差值：\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{29}{828} - \\frac{7}{200} \\right|\n$$\n为了对分数进行减法运算，我们找到一个公分母。质因数分解为 $828 = 2^{2} \\cdot 3^{2} \\cdot 23$ 和 $200 = 2^{3} \\cdot 5^{2}$。最小公倍数是 $2^{3} \\cdot 3^{2} \\cdot 5^{2} \\cdot 23 = 8 \\cdot 9 \\cdot 25 \\cdot 23 = 41400$。\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{29 \\cdot 50}{828 \\cdot 50} - \\frac{7 \\cdot 207}{200 \\cdot 207} \\right| = \\left| \\frac{1450}{41400} - \\frac{1449}{41400} \\right|\n$$\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{1450 - 1449}{41400} \\right| = \\frac{1}{41400}\n$$\n这就是所要求的以精确分数表示的绝对差值。", "answer": "$$\n\\boxed{\\frac{1}{41400}}\n$$"}, {"introduction": "这个实践超越了简单的数值近似，旨在揭示分段线性插值在金融建模中的一个更深层次的特性。你将独立地对看涨和看跌期权价格进行插值，并检验插值后的价格是否仍然满足无套利的核心原则——买卖权平价关系。这个练习阐明了一个关键概念：如果输入数据本身是无套利的，线性插值方法可以保持这种一致性，这对于构建稳健的定价模型至关重要。[@problem_id:2419232]", "id": "2419232", "problem": "一个量化研究团队需要为一个风险引擎中使用的欧式期权曲面计算不同行权价上的期权价值。他们决定对看涨期权和看跌期权分别在行权价上使用分段线性插值法。考虑一个单一到期日，其市场输入如下：\n\n- 标的现货价格 $S_0 = 100$ （货币单位）。\n- 到期时间 $T = 0.5$ （年）。\n- 连续复利无风险利率 $r = 0$ （每年）。\n- 连续股息率 $q = 0$ （每年）。\n- 在行权价 $K_1 = 95$ 和 $K_2 = 105$ 处观测到的中间价：\n  - 看涨期权价格：$C(95) = 9$，$C(105) = 4$。\n  - 看跌期权价格：$P(95) = 4$，$P(105) = 9$。\n\n使用在行权价 $K$ 上的分段线性插值，独立地对看涨期权和看跌期权进行插值，以得到目标行权价 $K^{\\ast} = 100$ 处的 $C_{\\text{lin}}(K^{\\ast})$ 和 $P_{\\text{lin}}(K^{\\ast})$。然后计算看跌-看涨期权平价残差\n$$\nR \\equiv \\bigl(C_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast})\\bigr) - \\bigl(S_0 \\exp(-q T) - K^{\\ast} \\exp(-r T)\\bigr).\n$$\n以货币单位报告 $R$ 的值，结果为一个实数。无需四舍五入。", "solution": "该问题要求在对看涨和看跌期权价格进行分段线性插值后，计算看跌-看涨期权平价残差。首先，必须严格验证问题陈述的有效性。\n\n**问题验证**\n给定的条件逐条列出如下：\n- 标的现货价格 $S_0 = 100$。\n- 到期时间 $T = 0.5$。\n- 连续复利无风险利率 $r = 0$。\n- 连续股息率 $q = 0$。\n- 在行权价 $K_1 = 95$ 和 $K_2 = 105$ 处观测到的中间价。\n- 看涨期权价格：$C(95) = 9$，$C(105) = 4$。\n- 看跌期权价格：$P(95) = 4$，$P(105) = 9$。\n- 目标行权价 $K^{\\ast} = 100$。\n\n欧式期权的看跌-看涨期权平价关系是金融学中的一个基本原则，其表达式为：\n$$C(K) - P(K) = S_0 \\exp(-qT) - K \\exp(-rT)$$\n给定参数 $r = 0$ 和 $q = 0$，该关系简化为：\n$$C(K) - P(K) = S_0 - K$$\n一个关键步骤是检查所提供的市场数据是否与此原则一致。\n在行权价 $K_1 = 95$ 处：\n等式左边为 $C(95) - P(95) = 9 - 4 = 5$。\n等式右边为 $S_0 - K_1 = 100 - 95 = 5$。\n数值一致。\n\n在行权价 $K_2 = 105$ 处：\n等式左边为 $C(105) - P(105) = 4 - 9 = -5$。\n等式右边为 $S_0 - K_2 = 100 - 105 = -5$。\n数值一致。\n\n该问题具有科学依据，因为它基于标准的金融工程原理和内部一致的数据。问题提法得当、客观且完整。因此，该问题是有效的，我们将继续进行求解。\n\n**求解推导**\n指定的方法是对看涨和看跌期权价格在行权价 $K$ 上独立进行分段线性插值。对于一个在点 $x_1$ 和 $x_2$ 处值已知的函数 $f(x)$，其在中间点 $x$ 的线性插值由以下公式给出：\n$$f(x) = f(x_1) + (x - x_1) \\frac{f(x_2) - f(x_1)}{x_2 - x_1}$$\n\n首先，我们应用此公式在目标行权价 $K^{\\ast} = 100$ 处对看涨期权价格 $C(K)$ 进行插值。已知数据点为 $(K_1, C(K_1)) = (95, 9)$ 和 $(K_2, C(K_2)) = (105, 4)$。\n$$\nC_{\\text{lin}}(K^{\\ast}) = C(K_1) + (K^{\\ast} - K_1) \\frac{C(K_2) - C(K_1)}{K_2 - K_1}\n$$\n代入数值：\n$$\nC_{\\text{lin}}(100) = 9 + (100 - 95) \\frac{4 - 9}{105 - 95} = 9 + (5) \\frac{-5}{10} = 9 - 2.5 = 6.5\n$$\n\n接下来，我们对看跌期权价格 $P(K)$ 执行相同的插值。已知数据点为 $(K_1, P(K_1)) = (95, 4)$ 和 $(K_2, P(K_2)) = (105, 9)$。\n$$\nP_{\\text{lin}}(K^{\\ast}) = P(K_1) + (K^{\\ast} - K_1) \\frac{P(K_2) - P(K_1)}{K_2 - K_1}\n$$\n代入数值：\n$$\nP_{\\text{lin}}(100) = 4 + (100 - 95) \\frac{9 - 4}{105 - 95} = 4 + (5) \\frac{5}{10} = 4 + 2.5 = 6.5\n$$\n\n最后一步是计算看跌-看涨期权平价残差 $R$，其定义如问题陈述所示：\n$$\nR \\equiv \\bigl(C_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast})\\bigr) - \\bigl(S_0 \\exp(-q T) - K^{\\ast} \\exp(-r T)\\bigr)\n$$\n我们已得到插值 $C_{\\text{lin}}(100) = 6.5$ 和 $P_{\\text{lin}}(100) = 6.5$。残差的第一项是：\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = 6.5 - 6.5 = 0\n$$\n第二项，即在 $K^{\\ast}$ 处由看跌-看涨期权平价关系得出的理论价格差，是：\n$$\nS_0 \\exp(-q T) - K^{\\ast} \\exp(-r T) = 100 \\exp(-0 \\cdot 0.5) - 100 \\exp(-0 \\cdot 0.5) = 100 \\cdot 1 - 100 \\cdot 1 = 0\n$$\n将这些结果代入 $R$ 的定义中：\n$$\nR = 0 - 0 = 0\n$$\n\n这个结果并非由所选特定数值偶然造成。它说明了线性算子的一个普遍性质。由于插值是一种线性运算，而看跌-看涨期权平价检验是价格的线性泛函，因此如果该性质在端点成立，那么它对插值也同样成立。\n设插值权重为 $w = \\frac{K^{\\ast} - K_1}{K_2 - K_1}$。插值后的价格为：\n$$\nC_{\\text{lin}}(K^{\\ast}) = (1-w) C(K_1) + w C(K_2)\n$$\n$$\nP_{\\text{lin}}(K^{\\ast}) = (1-w) P(K_1) + w P(K_2)\n$$\n插值后价格的差是端点处价格差的线性组合：\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = (1-w) [C(K_1) - P(K_1)] + w [C(K_2) - P(K_2)]\n$$\n鉴于端点满足平价关系，$C(K) - P(K) = S_0 \\exp(-qT) - K \\exp(-rT)$，我们代入此关系：\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = (1-w)[S_0 e^{-qT} - K_1 e^{-rT}] + w[S_0 e^{-qT} - K_2 e^{-rT}]\n$$\n$$\n= S_0 e^{-qT} - [(1-w)K_1 + wK_2]e^{-rT}\n$$\n根据线性插值的定义，$K^{\\ast} = (1-w)K_1 + wK_2$。因此，\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = S_0 e^{-qT} - K^{\\ast}e^{-rT}\n$$\n这表明，如果用于插值的输入数据是无套利的（即满足看跌-看涨期权平价关系），那么插值后的价格集合在同样意义上也是无套利的。因此，残差 $R$ 必须恒等于零。数值计算证实了这一普遍的理论结果。", "answer": "$$\\boxed{0}$$"}, {"introduction": "这项编码挑战将你置于一个真实的量化金融场景中，你需要根据离散的市场数据构建一个连续的波动率微笑曲线。你将使用分段线性插值方法来构建波动率曲面，并利用它来为期权定价，然后通过计算蝶式价差来检验模型是否存在套利机会。这个实践将让你了解插值方法的选择如何可能引入模型缺陷，并锻炼你通过数值方法验证模型内部一致性的能力。[@problem_id:2419249]", "id": "2419249", "problem": "考虑一个具有现货价格 $S_0$、到期时间 $T$（以年为单位）、连续复利无风险利率 $r$ 和连续股息率 $\\delta$ 的单一到期日欧式看涨期权市场。波动率微笑通过指定一组有限的行权价-波动率节点 $\\{(K_i,\\sigma_i)\\}_{i=1}^m$ 来定义，其中行权价严格递增 $K_1 &lt; K_2 &lt; \\cdots &lt; K_m$，且对应的 Black–Scholes–Merton (BSM) 隐含波动率 $\\sigma_i &gt; 0$。对于满足 $K_1 \\le K \\le K_m$ 的任意行权价 $K$，通过在节点上进行分段线性插值来定义隐含波动率函数 $\\sigma(K)$：\n- 对于 $K \\in [K_i, K_{i+1}]$，$\\sigma(K)$ 是在 $[K_i, K_{i+1}]$ 上满足 $\\sigma(K_i)=\\sigma_i$ 和 $\\sigma(K_{i+1})=\\sigma_{i+1}$ 的唯一仿射函数。\n无需进行外插，因为所有用于评估的行权价都将位于 $[K_1,K_m]$ 区间内。\n\n对于任意行权价 $K$ 和波动率 $\\sigma(K)$，在零利率和零股息率的条件下，BSM 欧式看涨期权价格定义为\n$$\nC(K) \\equiv S_0 \\, \\Phi(d_1) - K \\, \\Phi(d_2),\n$$\n其中\n$$\nd_1 \\equiv \\frac{\\ln(S_0/K) + \\tfrac{1}{2}\\sigma(K)^2 T}{\\sigma(K)\\sqrt{T}}, \n\\quad\nd_2 \\equiv d_1 - \\sigma(K)\\sqrt{T},\n$$\n且 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。在无套利设定下，作为行权价函数的看涨期权价格是凸函数，这意味着对于任何等间距的三个行权价 $K-h$、$K$、$K+h$（其中 $h&gt;0$），蝶式价差价格\n$$\nB(K;h) \\equiv C(K-h) - 2\\,C(K) + C(K+h)\n$$\n必须为非负。负值表示违反了蝶式价差价格必须为正的无套利条件（等价于在某个行权价上存在负的风险中性密度）。\n\n编写一个程序，针对以下每个测试用例，通过在提供的节点上进行分段线性插值来构造 $\\sigma(K)$，在等间距行权价网格上计算 $C(K)$，评估内部网格点上的离散蝶式价差价格，并返回找到的最小蝶式价差价格。\n\n对所有测试用例使用以下固定市场输入：\n- $S_0 = 100$，\n- $T = 1$（以年为单位），\n- $r = 0$，\n- $\\delta = 0$。\n\n对于每个测试用例：\n1. 令 $K_{\\min} \\equiv K_1$ 和 $K_{\\max} \\equiv K_m$。\n2. 构造一个包含 $N=81$ 个点的等间距行权价网格 $\\{K_j\\}_{j=0}^{N-1}$，覆盖 $[K_{\\min},K_{\\max}]$ 区间（含端点），使得 $K_0 = K_{\\min}$，$K_{N-1}=K_{\\max}$，并且对于所有 $j$，$K_{j+1}-K_j$ 为常数。\n3. 使用 BSM 公式计算所有 $j=0,\\dots,N-1$ 的 $C(K_j)$，其中 $\\sigma(K_j)$ 由分段线性插值定义。\n4. 对于每个内部索引 $j=1,\\dots,N-2$，计算离散蝶式价差价格\n$$\nB_j \\equiv C(K_{j-1}) - 2\\,C(K_j) + C(K_{j+1}).\n$$\n5. 报告最小蝶式价差价格\n$$\nb_{\\min} \\equiv \\min_{1 \\le j \\le N-2} B_j.\n$$\n返回四舍五入到六位小数的 $b_{\\min}$。\n\n测试套件（每个用例提供节点对 $\\{(K_i,\\sigma_i)\\}$）：\n- 用例 A（平坦微笑，一般正常路径）：$(K,\\sigma)$ 节点\n  $$\n  \\{(70,0.20),(85,0.20),(100,0.20),(115,0.20),(130,0.20)\\}.\n  $$\n- 用例 B（旨在违反无套利条件的尖峰微笑）：$(K,\\sigma)$ 节点\n  $$\n  \\{(70,0.15),(85,0.15),(100,0.90),(115,0.15),(130,0.15)\\}.\n  $$\n- 用例 C（最少节点覆盖边界且非均匀的微笑）：$(K,\\sigma)$ 节点\n  $$\n  \\{(80,0.18),(100,0.20),(120,0.22)\\}.\n  $$\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含三个结果 $[b_{\\min}^{(A)}, b_{\\min}^{(B)}, b_{\\min}^{(C)}]$，形式为用方括号括起来的逗号分隔列表，每个值都四舍五入到六位小数（例如，“[0.012345,-0.001234,0.000000]”）。", "solution": "所提出的问题是计算金融领域一个适定且有科学依据的练习，具体涉及期权市场中无套利条件的验证。所有必要的参数和定义都已提供，任务是实现一个明确指定的数值算法。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n需要测试的核心原理是欧式看涨期权价格相对于行权价的凸性。在一个无套利市场中，看涨期权价格函数 $C(K)$ 必须是关于行权价 $K$ 的凸函数。这意味着其二阶导数 $\\frac{\\partial^2 C}{\\partial K^2}$ 必须为非负。这个二阶导数通过 Breeden-Litzenberger 公式与标的资产在到期日 $T$ 的价格的风险中性概率密度函数直接相关：$\\frac{\\partial^2 C}{\\partial K^2} = e^{rT} p(S_T = K)$。该导数的负值将意味着负概率，这是存在套利机会的明确信号。\n\n二阶导数的一个离散近似是蝶式价差，其定义是针对三个行权价 $K-h$、$K$ 和 $K+h$（其中 $h>0$）：\n$$ B(K;h) \\equiv C(K-h) - 2C(K) + C(K+h) $$\n无套利条件要求 $B(K;h) \\ge 0$。该问题要求我们在一个离散的行权价网格上，针对指定的波动率微笑检查此条件。\n\n步骤如下：\n\n1.  **模型和参数设置**：给定固定的市场参数：现货价格 $S_0 = 100$，到期时间 $T = 1$ 年，无风险利率 $r = 0$，股息率 $\\delta = 0$。在这些条件下，Black-Scholes-Merton (BSM) 欧式看涨期权价格为：\n    $$ C(K) = S_0 \\Phi(d_1) - K \\Phi(d_2) $$\n    其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数，而项 $d_1$ 和 $d_2$ 为：\n    $$ d_1 = \\frac{\\ln(S_0/K) + \\frac{1}{2}\\sigma(K)^2 T}{\\sigma(K)\\sqrt{T}} $$\n    $$ d_2 = d_1 - \\sigma(K)\\sqrt{T} $$\n    隐含波动率 $\\sigma(K)$ 不是常数，而是行权价 $K$ 的函数。\n\n2.  **隐含波动率插值**：对于每个测试用例，波动率微笑由一组节点 $\\{(K_i, \\sigma_i)\\}_{i=1}^m$ 定义。对于范围 $[K_1, K_m]$ 内的任何行权价 $K$，$\\sigma(K)$ 的值由分段线性插值确定。如果 $K$ 落在区间 $[K_i, K_{i+1}]$ 内，其波动率由以下仿射函数给出：\n    $$ \\sigma(K) = \\sigma_i + \\frac{\\sigma_{i+1} - \\sigma_i}{K_{i+1} - K_i} (K - K_i) $$\n\n3.  **数值评估网格**：对于每个用例，我们定义一个评估范围 $[K_{\\min}, K_{\\max}]$，其中 $K_{\\min} = K_1$ 且 $K_{\\max} = K_m$。在此范围内构造一个包含 $N=81$ 个行权价的等间距网格 $\\{K_j\\}_{j=0}^{N-1}$，其中 $K_0=K_{\\min}$ 且 $K_{N-1}=K_{\\max}$。\n\n4.  **看涨期权价格和蝶式价差的计算**：我们对每个测试用例按顺序进行一系列计算：\n    a. 对于网格上的每个行权价 $K_j$，我们首先使用分段线性插值函数计算相应的隐含波动率 $\\sigma(K_j)$。\n    b. 使用这个 $\\sigma(K_j)$，我们计算 BSM 看涨期权价格 $C(K_j)$。这将得到一个看涨期权价格向量 $\\{C(K_j)\\}_{j=0}^{N-1}$。\n    c. 对于网格的每个内部点（索引 $j$ 从 $1$ 到 $N-2$），我们计算离散蝶式价差价格：\n       $$ B_j = C(K_{j-1}) - 2C(K_j) + C(K_{j+1}) $$\n    \n5.  **套利检测**：最后一步是找到所有计算出的蝶式价差中的最小值：\n    $$ b_{\\min} = \\min_{1 \\le j \\le N-2} B_j $$\n    $b_{\\min}$ 的负值表示违反了无套利条件，表明给定的波动率微笑与一个有效的风险中性密度不一致。对于用例 A（平坦微笑），我们预期 $b_{\\min} \\ge 0$，因为标准 BSM 模型是无套利的。对于用例 B（尖峰微笑），已知波动率函数中的极端凸性可能导致看涨期权价格函数的非凸性，因此我们可能会发现 $b_{\\min} < 0$。用例 C 提出了一个更现实的、倾斜的微笑，其无套利性必须通过数值方式进行验证。\n\n该实现将利用 `scipy.interpolate.interp1d` 来实现波动率函数，利用 `scipy.stats.norm.cdf` 来实现函数 $\\Phi$。所有的向量和矩阵运算将由 `numpy` 处理以提高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Computes the minimum butterfly spread price for different volatility smiles\n    to check for arbitrage.\n    \"\"\"\n    # Fixed market inputs for all test cases\n    S0 = 100.0\n    T = 1.0\n    # r = 0, delta = 0 are implicitly used in the simplified BSM formula.\n\n    # Grid parameters\n    N = 81\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: flat smile\n        [\n            (70.0, 0.20), (85.0, 0.20), (100.0, 0.20), (115.0, 0.20), (130.0, 0.20)\n        ],\n        # Case B: spiky smile\n        [\n            (70.0, 0.15), (85.0, 0.15), (100.0, 0.90), (115.0, 0.15), (130.0, 0.15)\n        ],\n        # Case C: sloped smile\n        [\n            (80.0, 0.18), (100.0, 0.20), (120.0, 0.22)\n        ],\n    ]\n\n    def bsm_call_price(K, sigma_K):\n        \"\"\"\n        Calculates the BSM European call price for r=0, delta=0.\n        K and sigma_K can be numpy arrays.\n        \"\"\"\n        # Handle cases where sigma_K might be zero or K is zero to avoid division by zero or log(0)\n        # However, problem constraints (sigma_i > 0, K_i > 0) make this unlikely\n        # for interpolated values. Add a small epsilon for robustness.\n        epsilon = 1e-12\n        sigma_K = np.maximum(sigma_K, epsilon)\n        K = np.maximum(K, epsilon)\n\n        d1 = (np.log(S0 / K) + 0.5 * sigma_K**2 * T) / (sigma_K * np.sqrt(T))\n        d2 = d1 - sigma_K * np.sqrt(T)\n        \n        price = S0 * norm.cdf(d1) - K * norm.cdf(d2)\n        return price\n\n    results = []\n    for nodes in test_cases:\n        # 1. Unpack nodes and create interpolator for sigma(K)\n        strikes_nodes, vols_nodes = zip(*nodes)\n        \n        # Use scipy's linear interpolation. fill_value is not needed as we\n        # stay within the bounds defined by the nodes.\n        sigma_func = interp1d(\n            strikes_nodes, vols_nodes, kind='linear', bounds_error=True\n        )\n\n        # 2. Construct the equally spaced strike grid\n        K_min = strikes_nodes[0]\n        K_max = strikes_nodes[-1]\n        K_grid = np.linspace(K_min, K_max, N)\n\n        # 3. Compute C(K_j) for all j\n        # First, compute interpolated volatilities on the grid\n        sigma_grid = sigma_func(K_grid)\n        # Then, compute call prices on the grid\n        C_grid = bsm_call_price(K_grid, sigma_grid)\n        \n        # 4. Compute discrete butterfly spread prices\n        # B_j = C(K_{j-1}) - 2*C(K_j) + C(K_{j+1})\n        # This can be vectorized using numpy slicing\n        butterfly_spreads = C_grid[:-2] - 2 * C_grid[1:-1] + C_grid[2:]\n\n        # 5. Report the minimum butterfly spread price\n        b_min = np.min(butterfly_spreads)\n        \n        # Round to six decimal places as required\n        results.append(round(b_min, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}