{"hands_on_practices": [{"introduction": "金融时间序列数据常常存在缺失，例如股票在交易暂停期间。本练习将展示拉格朗日插值最基本的应用：使用一个一次多项式（即一条直线）来估算两个已知数据点之间缺失的价格路径。这是一种简单而强大的技术，可以从离散数据中创建一个连续且合理的模型。[@problem_id:2405262]", "id": "2405262", "problem": "一只单名股票在时间戳 $\\tau_{0}$ 和 $\\tau_{1}$ 之间暂停交易。在 $\\tau_{0}$ 时刻暂停交易前的最后一笔交易成交价为 $p(\\tau_{0}) = \\$\\,103.64$，在 $\\tau_{1}$ 时刻恢复交易后的第一笔交易成交价为 $p(\\tau_{1}) = \\$\\,98.92$。假设在暂停交易期间没有发生拆股、派息或公司行动，并且暂停期间的潜在价格路径由一个与观测到的端点价格相匹配的最低次唯一多项式建模。\n\n定义 $t$ 为自 $\\tau_{0}$ 以来的流逝时间（以秒为单位），因此 $t = 0$ 对应于 $\\tau_{0}$，$t = \\Delta$ 对应于 $\\tau_{1}$。假设暂停交易时长为 $\\Delta = 900$ 秒。在上述建模假设下，计算暂停交易开始后 $t^{\\ast} = 540$ 秒时的估算潜在价格。\n\n将您的答案四舍五入到 $4$ 位有效数字。以美元（USD）表示您的答案。", "solution": "在尝试任何解答之前，对问题陈述进行严格验证。\n\n步骤 1：提取已知条件\n- 暂停交易开始时间：$\\tau_{0}$\n- 暂停交易结束时间：$\\tau_{1}$\n- 暂停交易开始时价格：$p(\\tau_{0}) = 103.64$\n- 暂停交易结束时价格：$p(\\tau_{1}) = 98.92$\n- 建模假设：潜在价格路径由与观测到的端点价格相匹配的最低次唯一多项式建模。\n- 时间坐标定义：$t$ 是自 $\\tau_{0}$ 以来的流逝时间（以秒为单位），因此 $t=0$ 对应于 $\\tau_{0}$，$t=\\Delta$ 对应于 $\\tau_{1}$。\n- 暂停交易持续时间：$\\Delta = 900$ 秒。\n- 价格估算的目标时间：$t^{\\ast} = 540$ 秒。\n\n步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，提法明确，且客观。它提出了一个应用于简化金融模型的数值插值标准问题。核心指令——使用“最低次唯一多项式”来寻找价格——具有精确的数学意义。对于两个给定的数据点，这对应于一个一次的唯一多项式，也就是一条直线。计算所需的所有数据均已提供，不存在内部矛盾或歧义。因此，该问题被视为有效。\n\n步骤 3：结论与行动\n问题有效。现在推导解答。\n\n该问题要求估算在交易暂停期间的潜在股票价格。主导的建模假设是，我们记为 $P(t)$ 的价格路径是由一个连接暂停区间边界处观测价格的最低次唯一多项式来描述的。\n\n在时间-价格坐标系 $(t, P(t))$ 中，我们有两个给定的数据点：\n1.  在暂停交易开始时，$t_0 = 0$，价格为 $P(t_0) = P(0) = 103.64$。\n2.  在暂停交易结束时，$t_1 = \\Delta = 900$，价格为 $P(t_1) = P(900) = 98.92$。\n\n一个通过 $n$ 个不同点的唯一多项式的次数最多为 $n-1$。在这种情况下，我们有 $n=2$ 个点：$(t_0, P(t_0))$ 和 $(t_1, P(t_1))$。因此，最低次多项式的次数为 $2-1 = 1$。这是一个线性函数。\n\n对于两点 $(x_0, y_0)$ 和 $(x_1, y_1)$，拉格朗日插值多项式的一般形式提供了所需的唯一线性函数：\n$$ P(t) = y_0 \\frac{t-x_1}{x_0-x_1} + y_1 \\frac{t-x_0}{x_1-x_0} $$\n这种构造确保了 $P(x_0)=y_0$ 和 $P(x_1)=y_1$。\n\n代入我们的具体值，其中自变量是时间 $t$：\n- $(x_0, y_0) = (t_0, P(t_0)) = (0, 103.64)$\n- $(x_1, y_1) = (t_1, P(t_1)) = (900, 98.92)$\n\n潜在价格路径的多项式为：\n$$ P(t) = 103.64 \\cdot \\frac{t-900}{0-900} + 98.92 \\cdot \\frac{t-0}{900-0} $$\n简化此表达式可得到线性插值公式：\n$$ P(t) = 103.64 \\left( \\frac{900-t}{900} \\right) + 98.92 \\left( \\frac{t}{900} \\right) $$\n这可以写成：\n$$ P(t) = 103.64 \\left( 1 - \\frac{t}{900} \\right) + 98.92 \\left( \\frac{t}{900} \\right) $$\n我们需要计算在目标时间 $t^{\\ast} = 540$ 秒时的估算价格。我们将 $t = 540$ 代入多项式表达式中：\n$$ P(540) = 103.64 \\left( 1 - \\frac{540}{900} \\right) + 98.92 \\left( \\frac{540}{900} \\right) $$\n首先，我们简化分数项：\n$$ \\frac{540}{900} = \\frac{54}{90} = \\frac{6 \\times 9}{10 \\times 9} = \\frac{6}{10} = 0.6 $$\n现在，我们将这个值代回到 $P(540)$ 的方程中：\n$$ P(540) = 103.64 (1 - 0.6) + 98.92 (0.6) $$\n$$ P(540) = 103.64 (0.4) + 98.92 (0.6) $$\n进行乘法运算：\n$$ 103.64 \\times 0.4 = 41.456 $$\n$$ 98.92 \\times 0.6 = 59.352 $$\n将这些乘积相加得到精确的估算价格：\n$$ P(540) = 41.456 + 59.352 = 100.808 $$\n问题要求答案四舍五入到 $4$ 位有效数字。计算出的值为 $100.808$。前四位有效数字是 $1$、$0$、$0$ 和 $8$。第五位有效数字是 $0$，小于 $5$。因此，我们不对最后一位有效数字进行进位。\n结果价格，四舍五入到 $4$ 位有效数字后，是 $100.8$。", "answer": "$$\n\\boxed{100.8}\n$$"}, {"introduction": "当我们收集到更多数据时，便可以构建更复杂的模型。本练习超越了简单的直线拟合，利用三个数据点构建一个二次（二阶）插值多项式，从而用一条更灵活的曲线来模拟公司的现金余额。这个练习不仅涉及构建多项式，还要求应用微积分知识来找出模型的最小值，这在金融和经济优化中是一项常见且至关重要的任务。[@problem_id:2405264]", "id": "2405264", "problem": "一家公司的现金余额 $B(t)$（以百万美元 (USD) 为单位）在一个标准的 $13$ 周财政季度内的三个不同时间点上被观测。在季度初（$t=0$ 周），余额为 $9.5$。在季度中（$t=6.5$ 周），余额为 $6.2$。在季度末（$t=13$ 周），余额为 $11.3$。假设在该季度内，余额 $B(t)$ 平滑变化，并且可以由一个与这三个观测值完全相符的、关于 $t$ 的二次多项式来精确表示。\n\n在此二次模型下，确定区间 $[0,13]$ 内余额达到其最小值的时间 $t_{\\min}$（单位为周）。只需提供以周为单位的 $t_{\\min}$ 的数值，并将答案保留四位有效数字。", "solution": "这个问题将首先经过严格的验证。\n\n步骤 1：提取已知条件\n题目陈述中提供的已知条件如下：\n- 一家公司的现金余额用 $B(t)$ 表示，单位为百万美元。\n- 时间 $t$ 的单位为周。\n- 财政季度为 $13$ 周长，因此 $t$ 的关注区间为 $[0, 13]$。\n- 在 $t=0$ 周时，余额为 $B(0) = 9.5$。\n- 在 $t=6.5$ 周时，余额为 $B(6.5) = 6.2$。\n- 在 $t=13$ 周时，余额为 $B(13) = 11.3$。\n- 函数 $B(t)$ 被假设为关于 $t$ 的二次多项式。\n- 目标是找到在 $[0,13]$ 区间内余额达到最小的时间 $t_{\\min}$。\n- $t_{\\min}$ 的最终答案必须是一个四舍五入到四位有效数字的数值。\n\n步骤 2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估：\n- **科学依据**：该问题是一个数学建模练习。使用多项式对有限数据集进行插值是数值分析和应用数学中的一种标准和基本技术。它没有违反任何科学原理。\n- **适定性**：该问题提供了三个不同的数据点 $(t, B(t))$，这三个点唯一确定一个次数最多为二的多项式。一个二次函数有一个唯一的极值点（顶点），可以通过解析方法求得。题目要求在指定的闭区间内找到最小值对应的时间。该问题是适定的，并且有唯一解。\n- **客观性**：问题陈述由客观、可量化的数据和一个清晰、明确的建模假设（“可以由一个二次多项式精确表示”）组成。没有主观或基于意见的语言。\n\n该问题没有表现出任何可导致其无效的缺陷。它在数学上是合理的、完整的和明确的。\n\n步骤 3：结论与行动\n问题被判定为**有效**。将推导解答。\n\n余额 $B(t)$ 由以下形式的二次多项式建模：\n$$B(t) = at^2 + bt + c$$\n其中 $a$、$b$ 和 $c$ 是待定常数。我们使用给定的三个数据点建立一个线性方程组。\n\n数据点是 $(t_0, B_0) = (0, 9.5)$、$(t_1, B_1) = (6.5, 6.2)$ 和 $(t_2, B_2) = (13, 11.3)$。\n\n1.  对于点 $(0, 9.5)$：\n    $$B(0) = a(0)^2 + b(0) + c = 9.5$$\n    这立即得出 $c = 9.5$。\n\n2.  对于点 $(6.5, 6.2)$：\n    $$B(6.5) = a(6.5)^2 + b(6.5) + 9.5 = 6.2$$\n    $$a(42.25) + b(6.5) = 6.2 - 9.5$$\n    $$42.25a + 6.5b = -3.3$$\n    在计算上使用分数更有利。$t_1 = 6.5 = \\frac{13}{2}$，所以 $t_1^2 = \\frac{169}{4} = 42.25$。\n    $$\\frac{169}{4}a + \\frac{13}{2}b = -\\frac{33}{10}$$\n\n3.  对于点 $(13, 11.3)$：\n    $$B(13) = a(13)^2 + b(13) + 9.5 = 11.3$$\n    $$a(169) + b(13) = 11.3 - 9.5$$\n    $$169a + 13b = 1.8$$\n    使用分数，$1.8 = \\frac{18}{10} = \\frac{9}{5}$。\n    $$169a + 13b = \\frac{9}{5}$$\n\n我们现在得到一个关于 $a$ 和 $b$ 的二元线性方程组：\n(I) $\\frac{169}{4}a + \\frac{13}{2}b = -\\frac{33}{10}$\n(II) $169a + 13b = \\frac{9}{5}$\n\n从方程 (II) 两边同乘以 $\\frac{1}{13}$：\n$$13a + b = \\frac{9}{5 \\times 13} = \\frac{9}{65}$$\n所以，$b = \\frac{9}{65} - 13a$。\n\n让我们给方程 (I) 两边同乘以 $4$：\n$$169a + 26b = -\\frac{33 \\times 4}{10} = -\\frac{132}{10} = -\\frac{66}{5}$$\n这是方程 (I')。\n从方程 (II) 两边同乘以 $2$：\n$$338a + 26b = \\frac{18}{5}$$\n这是方程 (II')。\n\n用 (II') 减去 (I')：\n$$(338a - 169a) + (26b - 26b) = \\frac{18}{5} - (-\\frac{66}{5})$$\n$$169a = \\frac{18 + 66}{5} = \\frac{84}{5}$$\n$$a = \\frac{84}{5 \\times 169} = \\frac{84}{845}$$\n\n现在，我们使用 $169a + 13b = \\frac{9}{5}$ 来求 $b$：\n$$169\\left(\\frac{84}{845}\\right) + 13b = \\frac{9}{5}$$\n$$\\frac{169 \\times 84}{5 \\times 169} + 13b = \\frac{9}{5}$$\n$$\\frac{84}{5} + 13b = \\frac{9}{5}$$\n$$13b = \\frac{9}{5} - \\frac{84}{5} = -\\frac{75}{5} = -15$$\n$$b = -\\frac{15}{13}$$\n\n因此，二次多项式是：\n$$B(t) = \\frac{84}{845}t^2 - \\frac{15}{13}t + 9.5$$\n为了找到余额达到最小值的时间 $t_{\\min}$，我们必须求出这条抛物线的顶点。抛物线 $y = at^2+bt+c$ 的顶点的时间坐标由 $t = -\\frac{b}{2a}$ 给出。由于系数 $a = \\frac{84}{845} > 0$，抛物线开口向上，其顶点对应于全局最小值。\n\n$$t_{\\min} = -\\frac{-\\frac{15}{13}}{2 \\left(\\frac{84}{845}\\right)} = \\frac{\\frac{15}{13}}{\\frac{168}{845}}$$\n注意到 $845 = 5 \\times 169 = 5 \\times 13^2$，我们可以简化：\n$$t_{\\min} = \\frac{15}{13} \\times \\frac{845}{168} = \\frac{15}{13} \\times \\frac{5 \\times 13^2}{168} = \\frac{15 \\times 5 \\times 13}{168} = \\frac{975}{168}$$\n为了化简分数，我们求分子和分母的最大公约数。两者都可以被 $3$ 整除：\n$975 = 3 \\times 325$\n$168 = 3 \\times 56$\n$$t_{\\min} = \\frac{325}{56}$$\n现在我们计算数值：\n$$t_{\\min} = \\frac{325}{56} \\approx 5.8035714...$$\n计算出的时间 $t_{\\min}$ 在指定的区间 $[0, 13]$ 内。\n题目要求答案保留四位有效数字。前四位有效数字是 $5$、$8$、$0$ 和 $3$。第五位数字是 $5$，因此需要将最后一位有效数字向上取整。\n因此，$t_{\\min} \\approx 5.804$。", "answer": "$$\\boxed{5.804}$$"}, {"introduction": "一个常见的误解是“更多的数据和更高阶的多项式总能带来更好的模型”。这个计算练习揭示了多项式插值的一个关键陷阱——龙格现象 (Runge phenomenon)，即使用等距节点的高阶多项式可能会剧烈振荡，产生不可靠的结果。通过一个重要的金融实例——隐含波动率微笑的建模，您将亲眼见证这种不稳定性，并发现使用切比雪夫 (Chebyshev) 节点创建非常稳定和精确的高阶近似的强大威力。[@problem_id:2405227]", "id": "2405227", "problem": "考虑在有界区间上，将隐含波动率微笑近似为标准化对数货币性函数的问题。设真实的隐含波动率函数为平滑映射 $\\sigma:[-1,1]\\to\\mathbb{R}_{+}$，其定义为\n$$\n\\sigma(x)=a+\\frac{b}{1+c x^{2}}+\\frac{d\\,x}{1+e x^{2}},\n$$\n参数值为 $a=0.20$、$b=0.25$、$c=25$、$d=-0.10$ 和 $e=4$。该函数代表了一个具有中央峰值和轻微负偏斜的形式化波动率微笑，并且对于所有 $x\\in[-1,1]$，满足 $\\sigma(x)&gt;0$。\n\n对于一个整数多项式次数 $n\\ge 0$，在 $[-1,1]$ 上定义 $m=n+1$ 个插值节点 $\\{x_i\\}_{i=0}^{m-1}$，构建相应的函数值 $y_i=\\sigma(x_i)$，并形成满足所有 $i$ 都有 $p(x_i)=y_i$ 的唯一 $n$ 次 Lagrange 插值多项式 $p(x)$。考虑两种不同的节点选择：\n- 等距节点：$x_i=-1+\\dfrac{2i}{m-1}$，其中 $i\\in\\{0,1,\\dots,m-1\\}$。\n- 第一类 Chebyshev 节点：$x_i=\\cos\\!\\left(\\dfrac{2i+1}{2m}\\pi\\right)$，其中 $i\\in\\{0,1,\\dots,m-1\\}$。\n\n在 $[-1,1]$ 上的一个大小为 $N=2001$ 的均匀评估网格 $\\mathcal{G}$ 上评估其稳定性和准确性，即 $\\mathcal{G}=\\left\\{-1+\\dfrac{2j}{N-1}:j\\in\\{0,1,\\dots,N-1\\}\\right\\}$。对每个次数 $n$ 和每种节点选择，计算：\n- 均方根误差 (RMSE)，定义为 $\\sqrt{\\dfrac{1}{N}\\sum_{x\\in\\mathcal{G}}\\left(p(x)-\\sigma(x)\\right)^{2}}$。\n- 最大绝对误差，定义为 $\\max_{x\\in\\mathcal{G}}\\left|p(x)-\\sigma(x)\\right|$。\n- 网格上插值结果为非正值的数量，定义为 $\\#\\{x\\in\\mathcal{G}:p(x)\\le 0\\}$。\n\n对于下方的每个测试用例，按顺序报告以下五个量：\n$F$、$C_{\\text{equi}}$、$C_{\\text{cheb}}$、$E_{\\text{equi}}$、$E_{\\text{cheb}}$，其中\n- $F$ 是改进因子 $F=\\dfrac{\\text{RMSE}_{\\text{equi}}}{\\text{RMSE}_{\\text{cheb}}}$，\n- $C_{\\text{equi}}$ 是使用等距节点的插值多项式结果为非正值的网格点整数数量，\n- $C_{\\text{cheb}}$ 是使用 Chebyshev 节点的插值多项式结果为非正值的网格点整数数量，\n- $E_{\\text{equi}}$ 是使用等距节点的插值多项式的最大绝对误差，\n- $E_{\\text{cheb}}$ 是使用 Chebyshev 节点的插值多项式的最大绝对误差。\n\n所有浮点数输出必须四舍五入到 $6$ 位小数。所有整数输出必须是精确整数。\n\n测试套件：\n- 用例 A (有明显改进的理想情况)：$n=16$。\n- 用例 B (中等次数)：$n=8$。\n- 用例 C (挑战稳定性的极高次数)：$n=24$。\n- 用例 D (低次数边界情况)：$n=2$。\n\n您的程序应生成单行输出，其中包含按 A、B、C、D 顺序排列的测试用例结果。结果聚合为一个 Python 风格的列表，其中每个元素是包含五个值的列表，浮点数四舍五入到 $6$ 位小数，整数不进行四舍五入。程序不得读取任何输入，并且除了这单行输出外，不得产生任何额外文本。", "solution": "问题陈述已经过严格评估，并被确定为 **有效的**。这是一个在数值分析领域中适定、有科学依据且客观的问题，应用于计算金融中的一个标准模型。所有必要的参数和定义均已提供，不存在内部矛盾或违反科学原理之处。因此，我们可以着手推导解决方案。\n\n目标是分析 Lagrange 多项式插值在区间 $[-1, 1]$ 上近似形式化隐含波动率函数 $\\sigma(x)$ 的性能。我们将比较两种不同插值节点选择（等距节点和 Chebyshev 节点）下的性能。\n\n真实的函数由下式给出\n$$\n\\sigma(x) = a + \\frac{b}{1+c x^{2}} + \\frac{d\\,x}{1+e x^{2}}\n$$\n其中常数参数为 $a=0.20$、$b=0.25$、$c=25$、$d=-0.10$ 和 $e=4$。该函数在定义域 $x \\in [-1, 1]$ 上是平滑且严格为正的。\n\n对于给定的多项式次数 $n$，我们构建一个次数至多为 $n$ 的插值多项式 $p(x)$，它穿过一组 $m=n+1$ 个点 $\\{ (x_i, y_i) \\}_{i=0}^{m-1}$，其中 $y_i = \\sigma(x_i)$。这样的多项式的唯一性是得到保证的。\n\n插值节点 $\\{x_i\\}$ 的两种选择是：\n1. **等距节点**：定义为 $x_i = -1 + \\frac{2i}{m-1}$，其中 $i \\in \\{0, 1, \\dots, m-1\\}$。尽管构造简单，但已知在这些节点上进行多项式插值对于高次是不稳定的，会导致在区间端点附近出现剧烈振荡。这就是有充分记载的 Runge 现象。\n2. **第一类 Chebyshev 节点**：它们被定义为 $m$ 次 Chebyshev 多项式 $T_m(x)$ 的根，由 $x_i = \\cos\\left(\\frac{2i+1}{2m}\\pi\\right)$ 给出，其中 $i \\in \\{0, 1, \\dots, m-1\\}$。这些节点更密集地聚集在端点 $x = \\pm 1$ 附近，这一特性可以被证明在所有可能的节点选择中能最小化最大插值误差，并能减轻 Runge 现象，从而产生更稳定和准确的近似。\n\n对每个由次数 $n$ 定义的测试用例，解决该问题的算法步骤如下：\n\n首先，我们定义一个精细的均匀评估网格 $\\mathcal{G} = \\left\\{-1+\\frac{2j}{N-1}:j \\in \\{0, 1, \\dots, N-1\\}\\right\\}$，其中有 $N=2001$ 个点。\n\n对于两种节点类型（等距和 Chebyshev）中的每一种：\n- 我们生成 $m=n+1$ 个插值节点 $\\{x_i\\}$。\n- 我们计算相应的函数值 $y_i = \\sigma(x_i)$。\n- 我们构建 Lagrange 插值多项式 $p(x)$。为了计算的稳定性和效率，我们使用插值多项式的重心形式。`scipy.interpolate.BarycentricInterpolator` 类很适合此目的。\n- 我们在网格 $\\mathcal{G}$ 的所有点上评估所得多项式 $p(x)$ 和真实函数 $\\sigma(x)$。\n- 基于这些评估值，我们计算三个指标：\n    - 均方根误差 (RMSE)：$\\sqrt{\\frac{1}{N}\\sum_{x\\in\\mathcal{G}}\\left(p(x)-\\sigma(x)\\right)^{2}}$。\n    - 最大绝对误差：$E = \\max_{x\\in\\mathcal{G}}\\left|p(x)-\\sigma(x)\\right|$。\n    - 非正值计数：$C = \\#\\{x\\in\\mathcal{G}:p(x)\\le 0\\}$。这个指标尤其重要，因为波动率必须为正，而非正的插值结果是模型不稳定和失效的明确信号。\n\n最后，对于对应于次数 $n \\in \\{16, 8, 24, 2\\}$ 的每个测试用例，我们计算所需的五个量：\n- 改进因子 $F = \\frac{\\text{RMSE}_{\\text{equi}}}{\\text{RMSE}_{\\text{cheb}}}$。\n- 两种节点选择的非正值计数 $C_{\\text{equi}}$ 和 $C_{\\text{cheb}}$。\n- 两种节点选择的最大绝对误差 $E_{\\text{equi}}$ 和 $E_{\\text{cheb}}$。\n\n浮点数结果（$F$、$E_{\\text{equi}}$、$E_{\\text{cheb}}$）四舍五入到 $6$ 位小数，而整数计数（$C_{\\text{equi}}$、$C_{\\text{cheb}}$）则按原样报告。最终输出是所有测试用例的这些五元列表的集合，并按指定的 A、B、C、D 顺序呈现。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for all test cases and prints the result.\n    \"\"\"\n    # Parameters for the volatility function sigma(x)\n    A = 0.20\n    B = 0.25\n    C = 25\n    D = -0.10\n    E = 4\n    \n    # Size of the evaluation grid\n    N_GRID = 2001\n\n    def sigma(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates the ground-truth implied volatility function.\n        Vectorized to operate on NumPy arrays.\n        \"\"\"\n        return A + B / (1 + C * x**2) + D * x / (1 + E * x**2)\n\n    def compute_metrics(n: int, node_type: str) -> tuple[float, float, int]:\n        \"\"\"\n        Computes interpolation errors and stability metrics for a given degree and node type.\n        \n        Args:\n            n: The polynomial degree.\n            node_type: A string, either 'equispaced' or 'chebyshev'.\n            \n        Returns:\n            A tuple containing (rmse, max_absolute_error, nonpositive_count).\n        \"\"\"\n        m = n + 1\n\n        # 1. Generate interpolation nodes\n        if node_type == 'equispaced':\n            interp_nodes = np.linspace(-1, 1, m)\n        elif node_type == 'chebyshev':\n            i = np.arange(m)\n            interp_nodes = np.cos((2 * i + 1) * np.pi / (2 * m))\n        else:\n            raise ValueError(\"Unknown node type specified.\")\n\n        # 2. Compute function values at nodes\n        interp_values = sigma(interp_nodes)\n\n        # 3. Construct the barycentric interpolator\n        poly = BarycentricInterpolator(interp_nodes, interp_values)\n\n        # 4. Define evaluation grid and evaluate the interpolant and true function\n        eval_grid = np.linspace(-1, 1, N_GRID)\n        p_vals = poly(eval_grid)\n        sigma_vals = sigma(eval_grid)\n\n        # 5. Compute performance and stability metrics\n        errors = p_vals - sigma_vals\n        rmse = np.sqrt(np.mean(errors**2))\n        max_abs_error = np.max(np.abs(errors))\n        nonpositive_count = np.sum(p_vals <= 0)\n\n        return rmse, max_abs_error, int(nonpositive_count)\n\n    # Test cases are defined by the polynomial degree n. Order: A, B, C, D.\n    test_cases_n = [16, 8, 24, 2]\n    \n    all_results = []\n\n    for n in test_cases_n:\n        # Compute metrics for equispaced nodes\n        rmse_equi, max_err_equi, count_equi = compute_metrics(n, 'equispaced')\n        \n        # Compute metrics for Chebyshev nodes\n        rmse_cheb, max_err_cheb, count_cheb = compute_metrics(n, 'chebyshev')\n\n        # Calculate improvement factor. Handle case where denominator is zero.\n        if rmse_cheb > 0:\n            improvement_factor = rmse_equi / rmse_cheb\n        else:\n            improvement_factor = 1.0 if rmse_equi == 0 else float('inf')\n\n        # Assemble the results for the current test case, rounding floats\n        # Order: F, C_equi, C_cheb, E_equi, E_cheb\n        case_result = [\n            round(improvement_factor, 6),\n            count_equi,\n            count_cheb,\n            round(max_err_equi, 6),\n            round(max_err_cheb, 6)\n        ]\n        all_results.append(case_result)\n    \n    # Format the final output string as a list of lists, without spaces.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```"}]}