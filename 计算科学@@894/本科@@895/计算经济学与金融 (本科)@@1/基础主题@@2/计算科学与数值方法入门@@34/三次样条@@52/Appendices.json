{"hands_on_practices": [{"introduction": "要真正理解三次样条，我们必须首先掌握其平滑曲线是如何构建的。这个初始练习聚焦于最基本的步骤：计算内部节点处的二阶导数。这个值通常用 $M_i$ 表示，是控制样条曲率的关键参数，求解它是整个插值过程的核心。[@problem_id:2164958]", "id": "2164958", "problem": "一个函数 $S(x)$ 是一个用于插值一组数据点的自然三次样条。根据定义，三次样条是一个由三次多项式组成的分段函数，并且它及其一阶和二阶导数都是连续的。“自然”三次样条具有一个额外的性质，即其二阶导数在插值区间的两个端点处为零。\n\n考虑一个自然三次样条 $S(x)$，它穿过以下三个数据点：$(x_0, y_0) = (0, 0)$，$(x_1, y_1) = (1, 1)$ 和 $(x_2, y_2) = (2, 0)$。\n\n计算该样条在 $x=1$ 处的二阶导数值，记作 $S''(1)$。", "solution": "令 $x_{0}=0$，$x_{1}=1$，$x_{2}=2$ 且 $y_{0}=0$，$y_{1}=1$，$y_{2}=0$。对于自然三次样条，其在节点处的二阶导数 $M_{i}=S''(x_{i})$ 满足 $M_{0}=0$ 和 $M_{2}=0$，并且内部方程为\n$$\nh_{i-1}M_{i-1}+2(h_{i-1}+h_{i})M_{i}+h_{i}M_{i+1}\n=6\\left(\\frac{y_{i+1}-y_{i}}{h_{i}}-\\frac{y_{i}-y_{i-1}}{h_{i-1}}\\right),\n$$\n对 $i=1,\\ldots,n-1$ 成立，其中 $h_{i}=x_{i+1}-x_{i}$。此处 $h_{0}=x_{1}-x_{0}=1$ 且 $h_{1}=x_{2}-x_{1}=1$，并且在 $i=1$ 处有一个单一的内部方程：\n$$\n1\\cdot M_{0}+2(1+1)M_{1}+1\\cdot M_{2}\n=6\\left(\\frac{y_{2}-y_{1}}{1}-\\frac{y_{1}-y_{0}}{1}\\right).\n$$\n代入 $M_{0}=0$，$M_{2}=0$，$y_{2}-y_{1}=0-1=-1$ 以及 $y_{1}-y_{0}=1-0=1$ 可得\n$$\n4M_{1}=6(-1-1)=6(-2)=-12,\n$$\n因此\n$$\nM_{1}=-3.\n$$\n所以 $S''(1)=M_{1}=-3$。", "answer": "$$\\boxed{-3}$$"}, {"introduction": "样条的数学属性，例如其导数的连续性，不仅仅是抽象的要求；它们具有至关重要的现实世界意义，尤其是在金融领域。本实践探讨了当这些属性被违反时会发生什么，具体研究了收益率曲线模型中一阶导数连续性 ($C^1$) 的缺失如何导致经济上不合理的瞬时远期利率。这个练习突显了为什么平滑性是金融模型中一个理想且通常是必要的特征。[@problem_id:2386597]", "id": "2386597", "problem": "您正在使用一个分段三次函数来拟合连续复利零息收益率的期限结构。该函数意在作为期限域 $[0,2]$（单位：年）上的一个三次样条，且在 $t=1$ 处有一个单一节点。考虑以下定义的候选函数 $S:[0,2]\\to \\mathbb{R}$：\n$$\nS(t)=\n\\begin{cases}\nt^3, & t\\in[0,1],\\\\\nt^3 + (t-1), & t\\in(1,2].\n\\end{cases}\n$$\n将 $y(t)\\equiv S(t)$ 解释为期限为 $t>0$ 的连续复利零利率（年化）。与 $y(t)$ 相关的贴现函数 $D(t)$ 定义为\n$$\nD(t) \\equiv \\exp\\!\\Big(-\\int_0^t f(u)\\,du\\Big),\n$$\n其中 $f(t)$ 是瞬时远期利率，而连续复利零利率定义为\n$$\ny(t) \\equiv -\\frac{1}{t}\\ln D(t), \\quad t>0.\n$$\n哪个选项正确地描述了 $S(t)$ 在节点处的光滑性，以及根据上述定义由 $y(t)$ 构建出的隐含瞬时远期利率曲线 $f(t)$ 的经济含义？\n\nA. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。隐含的 $f(t)$ 在 $t=1$ 处有一个跳跃间断点，其幅度等于 $y(t)$ 在 $t=1$ 处的单侧导数之差，此处为一个大小为 $1$ 的向上跳跃，这意味着在没有已知离散事件的情况下，边际贴现率在 $t=1$ 处出现了一个突然的、经济上不合理的尖峰。\n\nB. $S(t)$ 在 $t=1$ 处是 $C^1$ 连续但不是 $C^2$ 连续的。隐含的 $f(t)$ 在 $t=1$ 处是连续的，但表现出一个尖点，因此边际贴现率没有突变。\n\nC. $S(t)$ 在 $t=1$ 处不满足 $C^0$ 连续性，因此 $D(t)$ 在 $t=1$ 处不连续，违反了无套利条件，且 $f(t)$ 在 $t=1$ 处没有良好定义。\n\nD. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。然而，由于 $y(t)$ 通过积分映射到 $D(t)$，隐含的 $f(t)$ 在 $t=1$ 处保持连续；$y(t)$ 中的任何尖点都被平滑掉，对 $f(t)$ 的不连续性没有影响。\n\nE. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。隐含的 $f(t)$ 在 $t=1$ 处包含一个狄拉克δ函数 $\\delta$ 的贡献，但没有跳跃；积分关系将非光滑性转化为 $f(t)$ 中的一个脉冲而不是一个阶跃。", "solution": "在尝试任何解答之前，必须首先验证问题陈述的科学性和逻辑一致性。\n\n问题提供了以下定义和函数：\n一个用于零息收益率期限结构的候选函数 $S(t)$，定义在域 $t \\in [0,2]$ 上，在 $t=1$ 处有一个节点：\n$$\nS(t)=\n\\begin{cases}\nS_1(t) = t^3, & t\\in[0,1],\\\\\nS_2(t) = t^3 + (t-1), & t\\in(1,2].\n\\end{cases}\n$$\n连续复利零利率与此函数等同：$y(t) \\equiv S(t)$。\n贴现函数 $D(t)$ 根据瞬时远期利率 $f(t)$ 定义：\n$$\nD(t) \\equiv \\exp\\!\\Big(-\\int_0^t f(u)\\,du\\Big)\n$$\n零利率 $y(t)$ 与贴现函数 $D(t)$ 的关系如下：\n$$\ny(t) \\equiv -\\frac{1}{t}\\ln D(t), \\quad t>0.\n$$\n问题要求描述 $S(t)$ 在节点 $t=1$ 处的光滑性，以及隐含的瞬时远期利率曲线 $f(t)$ 的经济含义。\n\n所提供的定义在利率理论中是标准的。根据 $y(t)$ 的定义，我们可以写出 $\\ln D(t) = -t \\cdot y(t)$。将此代入 $D(t)$ 的定义并取对数，得到 $-t \\cdot y(t) = -\\int_0^t f(u) du$，即 $t \\cdot y(t) = \\int_0^t f(u) du$。\n为了从零利率 $y(t)$ 求出瞬时远期利率 $f(t)$，我们使用微积分基本定理对该关系式关于 $t$ 求导：\n$$\n\\frac{d}{dt} [t \\cdot y(t)] = f(t)\n$$\n使用乘法法则，得到基本关系式：\n$$\nf(t) = y(t) + t \\cdot y'(t)\n$$\n该问题定义明确，陈述客观，并且科学地基于标准的金融数学。函数 $S(t)$ 是一个简单的分段多项式，适合进行形式化分析。由 $S(t)$ 产生的收益率大小（例如，$S(1) = 1$ 或 $100\\%$）在真实世界经济中并不典型，但这并不影响问题的数学结构，该问题是一个分析函数性质的形式化练习。该问题是有效的。\n\n我们开始解答。\n\n首先，我们分析 $S(t)$ 在节点 $t=1$ 处的光滑性。\n函数定义为 $S(t) = y(t)$。\n对于 $t \\in [0,1]$，$S_1(t) = t^3$。\n对于 $t \\in (1,2]$，$S_2(t) = t^3 + t - 1$。\n\n我们评估函数的连续性，即 $C^0$ 连续性。我们计算在 $t=1$ 处的左极限和右极限：\n$$\n\\lim_{t \\to 1^-} S(t) = \\lim_{t \\to 1^-} t^3 = 1^3 = 1\n$$\n$$\n\\lim_{t \\to 1^+} S(t) = \\lim_{t \\to 1^+} (t^3 + t - 1) = 1^3 + 1 - 1 = 1\n$$\n在节点处的值为 $S(1) = 1^3 = 1$。由于左极限、右极限和函数值都等于 $1$，函数 $S(t)$ 在 $t=1$ 处是连续的。它是 $C^0$ 连续的。\n\n接下来，我们评估一阶导数的连续性，即 $C^1$ 连续性。我们首先求出 $S(t)$ 各分段的导数：\n对于 $t \\in [0,1)$，$S'(t) = S_1'(t) = \\frac{d}{dt}(t^3) = 3t^2$。\n对于 $t \\in (1,2]$，$S'(t) = S_2'(t) = \\frac{d}{dt}(t^3 + t - 1) = 3t^2 + 1$。\n\n现在，我们计算导数在 $t=1$ 处的左极限和右极限：\n$$\nS'(1^-) = \\lim_{t \\to 1^-} S'(t) = \\lim_{t \\to 1^-} 3t^2 = 3(1)^2 = 3\n$$\n$$\nS'(1^+) = \\lim_{t \\to 1^+} S'(t) = \\lim_{t \\to 1^+} (3t^2 + 1) = 3(1)^2 + 1 = 4\n$$\n由于 $S'(1^-) \\neq S'(1^+)$，一阶导数 $S'(t)$ 在 $t=1$ 处不连续。因此，函数 $S(t)$ 在 $t=1$ 处不是 $C^1$ 连续的。\n总之，$S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。\n\n第二，我们分析隐含的瞬时远期利率曲线 $f(t)$。\n使用推导出的关系式 $f(t) = y(t) + t \\cdot y'(t)$ 并代入 $y(t) = S(t)$，我们求出 $f(t)$ 的表达式。\n对于 $t \\in [0,1)$:\n$$\nf(t) = S(t) + t \\cdot S'(t) = t^3 + t \\cdot (3t^2) = t^3 + 3t^4\n$$\n该公式的推导一定有误。让我们重新推导 $f(t)$。\n$f(t) = \\frac{d}{dt}[t \\cdot y(t)]$.\n对于 $t \\in [0,1)$：$y(t) = t^3$。乘积为 $t \\cdot y(t) = t \\cdot t^3 = t^4$。\n则 $f(t) = \\frac{d}{dt}(t^4) = 4t^3$。\n\n对于 $t \\in (1,2]$：$y(t) = t^3 + t - 1$。乘积为 $t \\cdot y(t) = t(t^3 + t - 1) = t^4 + t^2 - t$。\n则 $f(t) = \\frac{d}{dt}(t^4 + t^2 - t) = 4t^3 + 2t - 1$。\n\n所以瞬时远期利率由以下分段函数给出：\n$$\nf(t)=\n\\begin{cases}\n4t^3, & t\\in[0,1),\\\\\n4t^3 + 2t - 1, & t\\in(1,2].\n\\end{cases}\n$$\n我们检查 $f(t)$ 在 $t=1$ 处的连续性：\n$$\n\\lim_{t \\to 1^-} f(t) = \\lim_{t \\to 1^-} 4t^3 = 4(1)^3 = 4\n$$\n$$\n\\lim_{t \\to 1^+} f(t) = \\lim_{t \\to 1^+} (4t^3 + 2t - 1) = 4(1)^3 + 2(1) - 1 = 4 + 2 - 1 = 5\n$$\n由于极限不相等，$f(t)$ 在 $t=1$ 处有一个跳跃间断点。跳跃的幅度为 $\\Delta f |_1 = \\lim_{t \\to 1^+} f(t) - \\lim_{t \\to 1^-} f(t) = 5 - 4 = 1$。这是一个向上跳跃。\n\n让我们将这个跳跃与 $y(t)$ 的性质联系起来。\n$f(t)$ 在节点 $t_k$ 处的跳跃由 $f(t_k^+) - f(t_k^-)$ 给出。\n使用 $f(t) = y(t) + t y'(t)$:\n$\\lim_{t \\to t_k^+} f(t) = \\lim_{t \\to t_k^+} (y(t) + t y'(t)) = y(t_k) + t_k y'(t_k^+)$ 因为 $y(t)$ 是连续的。\n$\\lim_{t \\to t_k^-} f(t) = \\lim_{t \\to t_k^-} (y(t) + t y'(t)) = y(t_k) + t_k y'(t_k^-)$。\n跳跃为 $ (y(t_k) + t_k y'(t_k^+)) - (y(t_k) + t_k y'(t_k^-)) = t_k (y'(t_k^+) - y'(t_k^-))$。\n项 $y'(t_k^+) - y'(t_k^-)$ 是收益率曲线 $y(t)$ 的导数在节点处的跳跃。\n在我们的问题中，$t_k=1$。$y'(t)$ 的跳跃为 $y'(1^+) - y'(1^-) = 4-3=1$。\n因此，$f(t)$ 的跳跃为 $1 \\cdot (4-3) = 1$。这与我们的直接计算相符。\n\n其经济含义是，瞬时远期利率（代表在未来时间 $t$ 借贷的边际利率）经历了一个突然的、离散的跳跃。在一个正常运作的市场中，如果某个特定期限没有已知的重大经济事件或公告，那么这种特性被认为是高度人为且经济上不合理的。这表明收益率曲线模型的选择存在缺陷。\n\n现在我们评估每个选项。\n\nA. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。隐含的 $f(t)$ 在 $t=1$ 处有一个跳跃间断点，其幅度等于 $y(t)$ 在 $t=1$ 处的单侧导数之差，此处为一个大小为 $1$ 的向上跳跃，这意味着在没有已知离散事件的情况下，边际贴现率在 $t=1$ 处出现了一个突然的、经济上不合理的尖峰。\n- “$S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。” 正确，如前所推导。\n- “隐含的 $f(t)$ 在 $t=1$ 处有一个跳跃间断点。” 正确。\n- “其幅度等于 $y(t)$ 在 $t=1$ 处的单侧导数之差。” 正确。$f(t)$ 的跳跃为 $1$。$y'(t)$ 的跳跃为 $y'(1^+) - y'(1^-) = 4-3=1$。因为节点在 $t=1$，所以幅度相等。\n- “此处为一个大小为 $1$ 的向上跳跃。” 正确，我们计算出跳跃为 $5-4=1$。\n- “这意味着... 一个突然的、经济上不合理的尖峰...”。正确，这是标准的经济解释。\n这个陈述完全正确。\n\nB. $S(t)$ 在 $t=1$ 处是 $C^1$ 连续但不是 $C^2$ 连续的。隐含的 $f(t)$ 在 $t=1$ 处是连续的，但表现出一个尖点，因此边际贴现率没有突变。\n- “$S(t)$ 在 $t=1$ 处是 $C^1$ 连续但不是 $C^2$ 连续的。” 不正确。我们证明了 $S(t)$ 不是 $C^1$ 连续的。\n\nC. $S(t)$ 在 $t=1$ 处不满足 $C^0$ 连续性，因此 $D(t)$ 在 $t=1$ 处不连续，违反了无套利条件，且 $f(t)$ 在 $t=1$ 处没有良好定义。\n- “$S(t)$ 在 $t=1$ 处不满足 $C^0$ 连续性。” 不正确。我们证明了 $S(t)$ 是 $C^0$ 连续的。\n\nD. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。然而，由于 $y(t)$ 通过积分映射到 $D(t)$，隐含的 $f(t)$ 在 $t=1$ 处保持连续；$y(t)$ 中的任何尖点都被平滑掉，对 $f(t)$ 的不连续性没有影响。\n- “$S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。” 正确。\n- “由于 $y(t)$ 通过积分映射到 $D(t)$，因此隐含的 $f(t)$ 保持连续”。前提混乱，结论错误。从 $y(t)$ 到 $f(t)$ 的映射是通过微分，$f(t) = \\frac{d}{dt}[t \\cdot y(t)]$，而不是积分。微分不会使函数平滑；通常会使其更不平滑。我们已明确证明 $f(t)$ 是不连续的。不正确。\n\nE. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。隐含的 $f(t)$ 在 $t=1$ 处包含一个狄拉克δ函数 $\\delta$ 的贡献，但没有跳跃；积分关系将非光滑性转化为 $f(t)$ 中的一个脉冲而不是一个阶跃。\n- “$S(t)$ 在 $t=1$ 处是 $C^0$ 连续但不是 $C^1$ 连续的。” 正确。\n- “隐含的 $f(t)$ 在 $t=1$ 处包含一个狄拉克δ函数 $\\delta$ 的贡献。” 不正确。如果被微分的函数 $t \\cdot y(t)$ 具有跳跃间断点，$f(t)$ 中才会出现狄拉克δ函数的贡献。在这里，$t \\cdot y(t)$ 是连续的，但有一个尖点（不可微点）。它的导数有一个跳跃间断点，而不是狄拉克δ函数。\n- “但没有跳跃”。不正确。我们证明了它有跳跃。\n\n基于这一严谨的分析，只有选项 A 是正确的。", "answer": "$$\\boxed{A}$$"}, {"introduction": "虽然许多函数都可以插值一组数据点，但并非所有函数都适合实际应用。这个计算练习将三次样条与高次多项式进行对比，以展示一个经典问题——龙格现象（Runge phenomenon），即多项式插值在数据点之间可能出现剧烈振荡。通过比较两种方法的准确性，您将对为什么三次样条通常是拟合金融数据（如隐含波动率微笑）的更优选择获得实践性的理解。[@problem_id:2386520]", "id": "2386520", "problem": "考虑一个将标准化对数货币性 $k$ 映射到隐含波动率水平的函数 $v(k)$，其定义为\n$$\nv(k) \\equiv \\alpha + \\frac{\\beta}{1 + \\gamma k^2},\n$$\n参数为 $\\alpha = 0.2$，$\\beta = 0.1$ 和 $\\gamma = 25$。对于给定的整数 $n \\ge 2$，在闭区间 $[-1,1]$ 上定义一个包含 $n$ 个等距节点的数据集，节点为 $k_i = -1 + \\frac{2(i-1)}{n-1}$（其中 $i \\in \\{1,2,\\dots,n\\}$），观测值为 $y_i = v(k_i)$。\n\n对于每个指定的 $n$，考虑根据同一数据集 $\\{(k_i,y_i)\\}_{i=1}^n$ 构建的两种插值函数：\n1. $p_n(k)$ 是次数至多为 $n-1$ 的唯一多项式插值函数，满足对于所有 $i \\in \\{1,2,\\dots,n\\}$ 都有 $p_n(k_i) = y_i$。\n2. $s_n(k)$ 是自然三次样条插值函数，其样条节点为 $\\{k_i\\}_{i=1}^n$，满足对于所有 $i \\in \\{1,2,\\dots,n\\}$ 都有 $s_n(k_i) = y_i$，在 $[-1,1]$ 上二阶连续可导，在连续的节点之间为分段三次函数，并满足自然边界条件 $s_n''(-1) = 0$ 和 $s_n''(1) = 0$。\n\n对于一个包含在 $[-1,1]$ 内的评估网格 $\\{x_j\\}_{j=1}^m$，将近似函数 $a(k)$ 对 $v(k)$ 的均方根误差（RMSE）定义为\n$$\n\\mathrm{RMSE}(a) \\equiv \\left( \\frac{1}{m} \\sum_{j=1}^m \\left[a(x_j) - v(x_j)\\right]^2 \\right)^{1/2},\n$$\n以及最大绝对误差定义为\n$$\n\\mathrm{MAX}(a) \\equiv \\max_{1 \\le j \\le m} \\left|a(x_j) - v(x_j)\\right|.\n$$\n\n使用以上定义，评估以下四个测试用例：\n\n- 用例 A（一般情况）：$n = 9$，评估网格大小 $m = 1001$，包含 $[-1,1]$ 上的等距点。\n- 用例 B（一般情况）：$n = 17$，评估网格大小 $m = 1001$，包含 $[-1,1]$ 上的等距点。\n- 用例 C（高阶边界压力测试）：$n = 25$，评估网格大小 $m = 1001$，包含 $[-1,1]$ 上的等距点。\n- 用例 D（插值恒等性检验）：$n = 17$，评估网格恰好由 $n$ 个节点组成，即 $m = n$ 且 $\\{x_j\\}_{j=1}^m = \\{k_i\\}_{i=1}^n$。\n\n对于每个用例，按以下顺序计算四个量：\n1. $\\mathrm{RMSE}(p_n)$,\n2. $\\mathrm{RMSE}(s_n)$,\n3. $\\mathrm{MAX}(p_n)$,\n4. $\\mathrm{MAX}(s_n)$.\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个由逗号分隔的列表，该列表由四个为一组的子列表组成（每个测试用例对应一个），并用方括号括起来。具体来说，输出必须是\n$$\n\\left[\\left[r_1,r_2,r_3,r_4\\right],\\left[r_1',r_2',r_3',r_4'\\right],\\left[r_1'',r_2'',r_3'',r_4''\\right],\\left[r_1''',r_2''',r_3''',r_4'''\\right]\\right],\n$$\n其中每个 $r_\\cdot$ 是一个实数，四个内部列表按前述顺序分别对应于用例 A、B、C 和 D。所有数值结果必须表示为不带单位的实数。输出必须严格按照指定格式显示在单行上，例如 $[ [\\cdots], [\\cdots], [\\cdots], [\\cdots] ]$，但不得包含任何额外的解释性文本，也不得包含任何百分号或角度单位。", "solution": "问题陈述已经过严格验证，并被确定为是完善的。它在数值分析领域具有科学依据，是适定的、客观的，并包含获得唯一解所需的所有信息。不存在不一致、矛盾或模糊之处。因此，我们可以着手求解。\n\n该问题要求对两种插值方案——全局多项式插值和分段三次样条插值——在逼近给定函数方面的性能进行比较分析。待逼近的函数模拟了一条隐含波动率曲线，定义如下：\n$$\nv(k) \\equiv \\alpha + \\frac{\\beta}{1 + \\gamma k^2}\n$$\n参数给定为 $\\alpha = 0.2$，$\\beta = 0.1$ 和 $\\gamma = 25$。这是一个有理函数，在整个实数轴上是无穷次可导的（$C^\\infty$）。然而，其到复平面的解析延拓在 $k = \\pm i/\\sqrt{\\gamma} = \\pm i/5 = \\pm 0.2i$ 处有极点。这些极点与插值区间 $[-1, 1]$ 的邻近程度是影响多项式插值函数收敛特性的一个关键因素。\n\n对于给定的节点数 $n$，我们得到一个数据集 $\\{(k_i, y_i)\\}_{i=1}^n$，其中节点 $k_i = -1 + \\frac{2(i-1)}{n-1}$ 在 $[-1, 1]$ 上等距分布，其值为 $y_i = v(k_i)$。\n\n第一种近似函数 $p_n(k)$ 是次数至多为 $n-1$ 的唯一插值多项式。为了使这样的多项式存在且唯一，$k_i$ 必须互不相同，这一点由其定义保证。尽管唯一解存在，但在逼近理论中一个公认的结论是，对于像 $v(k)$ 这样在实区间附近有奇点的函数，在等距节点上进行高次多项式插值会导致大幅振荡，尤其在端点附近。这种现象被称为 Runge 现象。为了计算该多项式，我们将采用一种数值上稳定的方法，即重心插值公式，它优于构建和求解用于单项式系数的病态范德蒙德系统。\n\n第二种近似函数 $s_n(k)$ 是自然三次样条。该方法在每个子区间 $[k_i, k_{i+1}]$ 上构造一个分段三次多项式。为保证光滑性，样条函数被要求在整个区间 $[-1, 1]$ 上是二阶连续可导的（$C^2$）。这是通过强制相邻分段三次函数在内部节点处的函数值、一阶导数和二阶导数相匹配来实现的。该系统通过“自然”边界条件 $s_n''(-1) = 0$ 和 $s_n''(1) = 0$ 来闭合。这种设置导出了一个用于求解节点处二阶导数的良态三对角线性方程组，该方程组可以被高效且稳定地求解。对于数据拟合和插值，三次样条通常更为优越，因为它们避免了高次多项式的振荡行为。\n\n每种插值函数 $a(k) \\in \\{p_n(k), s_n(k)\\}$ 的性能通过在离散网格 $\\{x_j\\}_{j=1}^m$ 上评估的两种误差度量来量化：\n1.  均方根误差：$\\mathrm{RMSE}(a) = \\left( \\frac{1}{m} \\sum_{j=1}^m [a(x_j) - v(x_j)]^2 \\right)^{1/2}$\n2.  最大绝对误差：$\\mathrm{MAX}(a) = \\max_{1 \\le j \\le m} |a(x_j) - v(x_j)|$\n\n每个测试用例的计算流程如下：\n1.  对于给定的 $n$，建立包含 $n$ 个插值节点的集合 $\\{k_i\\}$，并计算相应的值 $\\{y_i = v(k_i)\\}$。\n2.  使用重心形式从数据集 $\\{(k_i, y_i)\\}$ 构建多项式插值函数 $p_n(k)$。\n3.  从相同的数据集构建自然三次样条函数 $s_n(k)$，并施加条件 $s_n''(-1) = s_n''(1) = 0$。\n4.  按照测试用例的规定定义评估网格 $\\{x_j\\}_{j=1}^m$。\n5.  在评估网格上计算 $v(x_j)$、$p_n(x_j)$ 和 $s_n(x_j)$ 的值。\n6.  计算多项式插值和样条插值的误差向量。\n7.  计算四个所需的度量指标：$\\mathrm{RMSE}(p_n)$、$\\mathrm{RMSE}(s_n)$、$\\mathrm{MAX}(p_n)$ 和 $\\mathrm{MAX}(s_n)$。\n\n对于用例 C，由于节点数较多（$n=25$），我们预计会观察到显著的 Runge 现象，从而导致 $p_{25}(k)$ 产生较大的误差。相反，样条插值的误差应随着 $n$ 的增加而减小。用例 D 作为一项基本的正确性检验：由于评估网格与插值节点重合，根据插值的定义 $a(k_i) = y_i = v(k_i)$，两种插值函数的误差都必须为零（或在机器精度范围内）。以下程序实现了这一流程。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator, CubicSpline\n\ndef solve():\n    \"\"\"\n    Computes and compares errors for polynomial and cubic spline interpolants.\n    \"\"\"\n    # Define parameters for the function v(k)\n    alpha = 0.2\n    beta = 0.1\n    gamma = 25.0\n\n    def v(k: np.ndarray) -> np.ndarray:\n        \"\"\"\n        The target function to be interpolated.\n        v(k) = alpha + beta / (1 + gamma * k^2)\n        \"\"\"\n        return alpha + beta / (1.0 + gamma * np.power(k, 2))\n\n    # Define the four test cases from the problem statement\n    # Each tuple is (n, m, grid_type)\n    # grid_type 'equidistant': m points on [-1, 1]\n    # grid_type 'nodes': m=n points, evaluation grid is the interpolation nodes\n    test_cases = [\n        (9, 1001, 'equidistant'),    # Case A\n        (17, 1001, 'equidistant'),   # Case B\n        (25, 1001, 'equidistant'),   # Case C\n        (17, 17, 'nodes'),           # Case D\n    ]\n\n    all_results = []\n    \n    for n, m, grid_type in test_cases:\n        # Step 1: Generate interpolation data\n        # n equally spaced nodes on the closed interval [-1, 1]\n        k_nodes = np.linspace(-1.0, 1.0, n)\n        # Observed values y_i = v(k_i)\n        y_nodes = v(k_nodes)\n\n        # Step 2: Construct the interpolants\n        # p_n(k): unique polynomial interpolant of degree at most n-1\n        # Using Barycentric form for numerical stability\n        p_n = BarycentricInterpolator(k_nodes, y_nodes)\n\n        # s_n(k): natural cubic spline interpolant\n        # bc_type='natural' sets the second derivatives at endpoints to zero\n        s_n = CubicSpline(k_nodes, y_nodes, bc_type='natural')\n\n        # Step 3: Define the evaluation grid\n        if grid_type == 'equidistant':\n            x_grid = np.linspace(-1.0, 1.0, m)\n        elif grid_type == 'nodes':\n            x_grid = k_nodes\n        else:\n            raise ValueError(\"Invalid grid_type specified.\")\n\n        # Step 4: Evaluate the true function and interpolants on the grid\n        v_true = v(x_grid)\n        p_n_vals = p_n(x_grid)\n        s_n_vals = s_n(x_grid)\n        \n        # Step 5: Compute errors\n        errors_p = p_n_vals - v_true\n        errors_s = s_n_vals - v_true\n\n        # Step 6: Calculate the required error metrics\n        # RMSE\n        rmse_p = np.sqrt(np.mean(np.square(errors_p)))\n        rmse_s = np.sqrt(np.mean(np.square(errors_s)))\n        \n        # MAX\n        max_p = np.max(np.abs(errors_p))\n        max_s = np.max(np.abs(errors_s))\n\n        # Store the four computed quantities for the current case\n        case_results = [rmse_p, rmse_s, max_p, max_s]\n        all_results.append(case_results)\n\n    # Final Output Formatting:\n    # Build a list of strings, where each string represents an inner list, e.g., \"[r1,r2,r3,r4]\"\n    results_as_strings = [\n        f\"[{','.join(map(str, res))}]\" for res in all_results\n    ]\n    \n    # Join the list of strings with commas and enclose in the outermost brackets\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"}]}