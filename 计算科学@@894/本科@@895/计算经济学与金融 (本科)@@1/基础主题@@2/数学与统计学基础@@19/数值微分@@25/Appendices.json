{"hands_on_practices": [{"introduction": "在数值金融中，我们经常需要从离散数据点估算变化率。这个练习是您进入数值微分世界的第一步。我们将比较三种基本方法——前向、后向和中心差分——来近似一个平滑函数的导数，让您亲身体验它们在精度上的差异，并理解为什么中心差分通常是首选方法。[@problem_id:2191753]", "id": "2191753", "problem": "考虑函数 $f(x) = x \\exp(-x)$。我们希望在点 $x_0 = 1$ 处近似其导数 $f'(x)$。近似的质量由其绝对误差来衡量，绝对误差定义为近似值与导数真实值之间的绝对差。\n\n您需要比较三种常见的用于近似导数的有限差分公式：\n1.  **向前差分近似 (Forward Difference Approximation)**：$D_f(x_0, h) = \\frac{f(x_0+h) - f(x_0)}{h}$\n2.  **向后差分近似 (Backward Difference Approximation)**：$D_b(x_0, h) = \\frac{f(x_0) - f(x_0-h)}{h}$\n3.  **中心差分近似 (Central Difference Approximation)**：$D_c(x_0, h) = \\frac{f(x_0+h) - f(x_0-h)}{2h}$\n\n设 $E_f$、$E_b$ 和 $E_c$ 分别是当步长 $h = 0.1$ 时，对应于向前、向后和中心差分近似的绝对误差。\n\n计算比值 $R = \\frac{E_f + E_b}{E_c}$ 的值。将您的最终答案保留三位有效数字。", "solution": "我们从函数 $f(x) = x \\exp(-x)$ 开始。其导数可以通过乘法法则求得：\n$$\nf'(x) = \\exp(-x) + x \\frac{d}{dx}\\big(\\exp(-x)\\big) = \\exp(-x) - x \\exp(-x) = \\exp(-x)\\,(1 - x).\n$$\n在 $x_{0} = 1$ 处，这得到\n$$\nf'(1) = \\exp(-1)\\,(1 - 1) = 0.\n$$\n因此，对于任何有限差分近似 $D$，在 $x_{0}=1$ 处的绝对误差就是近似值的绝对值：\n$$\nE_{f} = |D_{f}(1,h)|,\\quad E_{b} = |D_{b}(1,h)|,\\quad E_{c} = |D_{c}(1,h)|.\n$$\n\n当 $h = 0.1$ 时，使用 $f(x) = x \\exp(-x)$ 计算三个有限差分：\n- 向前差分：\n$$\nD_{f}(1,h) = \\frac{f(1+h) - f(1)}{h} = \\frac{(1.1)\\exp(-1.1) - \\exp(-1)}{0.1}.\n$$\n- 向后差分：\n$$\nD_{b}(1,h) = \\frac{f(1) - f(1-h)}{h} = \\frac{\\exp(-1) - (0.9)\\exp(-0.9)}{0.1}.\n$$\n- 中心差分：\n$$\nD_{c}(1,h) = \\frac{f(1+h) - f(1-h)}{2h} = \\frac{(1.1)\\exp(-1.1) - (0.9)\\exp(-0.9)}{0.2}.\n$$\n\n通过 $\\exp(-1.1) = \\exp(-1)\\exp(-0.1)$ 和 $\\exp(-0.9) = \\exp(-1)\\exp(0.1)$ 提取公因子 $\\exp(-1)$。定义 $t = \\exp(0.1)$，因此 $\\exp(-0.1) = 1/t$。那么\n$$\nD_{f}(1,h) = \\frac{\\exp(-1)}{0.1}\\left(1.1\\,\\frac{1}{t} - 1 \\right),\\quad\nD_{b}(1,h) = \\frac{\\exp(-1)}{0.1}\\left(1 - 0.9\\,t \\right),\n$$\n$$\nD_{c}(1,h) = \\frac{\\exp(-1)}{0.2}\\left(1.1\\,\\frac{1}{t} - 0.9\\,t \\right).\n$$\n设\n$$\nA = 1.1\\,\\frac{1}{t} - 1,\\quad B = 1 - 0.9\\,t,\\quad C = 1.1\\,\\frac{1}{t} - 0.9\\,t.\n$$\n那么\n$$\nE_{f} = \\frac{\\exp(-1)}{0.1}\\,|A|,\\quad E_{b} = \\frac{\\exp(-1)}{0.1}\\,|B|,\\quad E_{c} = \\frac{\\exp(-1)}{0.2}\\,|C|.\n$$\n因此，比值简化为\n$$\nR = \\frac{E_{f} + E_{b}}{E_{c}} = \\frac{\\frac{\\exp(-1)}{0.1}(|A|+|B|)}{\\frac{\\exp(-1)}{0.2}|C|} = 2\\,\\frac{|A|+|B|}{|C|}.\n$$\n\n在数值上，当 $t = \\exp(0.1) \\approx 1.1051701859880927$ 且 $1/t = \\exp(-0.1) \\approx 0.9048374180359596$时，\n$$\nA = 1.1\\cdot 0.9048374180359596 - 1 \\approx -0.00467884016044447,\\quad |A| \\approx 0.00467884016044447,\n$$\n$$\nB = 1 - 0.9\\cdot 1.1051701859880927 \\approx 0.00534683261071661,\\quad |B| \\approx 0.00534683261071661,\n$$\n$$\nC = 1.1\\cdot 0.9048374180359596 - 0.9\\cdot 1.1051701859880927 \\approx 0.000667992450272143,\\quad |C| \\approx 0.000667992450272143.\n$$\n因此，\n$$\nR = 2\\,\\frac{0.00467884016044447 + 0.00534683261071661}{0.000667992450272143} \\approx \\frac{0.02005134554232216}{0.000667992450272143} \\approx 30.0173.\n$$\n保留三位有效数字，\n$$\nR \\approx 30.0.\n$$", "answer": "$$\\boxed{30.0}$$"}, {"introduction": "理论函数通常是平滑的，但金融模型充满了“拐点”或不平滑的点，例如期权到期时的支付函数。本练习将探讨当函数不可微时，我们的数值微分工具会发生什么。通过分析一个欧式看涨期权的支付函数，您将了解数值导数在这些关键点附近的行为，这是一个在风险管理和衍生品定价中至关重要的实践洞察。[@problem_id:2415141]", "id": "2415141", "problem": "考虑金融经济学中的分段线性收益函数，该函数由欧式看涨期权到期收益定义，其形式为 $f(x) = \\max(x - K, 0)$，其中 $x$ 表示标的价格，$K$ 为行权价。这个函数处处连续，但在 $x = K$ 处不可微。取 $K = 100$。对于一个点 $x$ 和一个正步长 $h$，根据导数作为差商极限的第一性原理，定义以下三种有限差商：左（后向）差分 $L(x;h) = \\dfrac{f(x) - f(x - h)}{h}$，对称（中心）差分 $D(x;h) = \\dfrac{f(x + h) - f(x - h)}{2h}$，以及右（前向）差分 $R(x;h) = \\dfrac{f(x + h) - f(x)}{h}$。您的任务是实现一个程序，使用指定的 $f(x)$ 和 $K$ 对以下每个测试用例计算 $L(x;h)$、$D(x;h)$ 和 $R(x;h)$。\n\n使用以下包含数对 $(x,h)$ 的测试套件：\n- $(x,h) = (90.0, 0.1)$\n- $(x,h) = (110.0, 0.1)$\n- $(x,h) = (100.0, 0.1)$\n- $(x,h) = (99.99, 0.1)$\n- $(x,h) = (100.01, 0.1)$\n- $(x,h) = (100.0, 10^{-6})$\n- $(x,h) = (99.999999, 10^{-8})$\n- $(x,h) = (100.000001, 10^{-8})$\n\n对每个测试用例，计算并记录三个浮点数 $L(x;h)$、$D(x;h)$ 和 $R(x;h)$。将报告的每个浮点数四舍五入到 $8$ 位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按给定顺序连接测试用例的三元组得到，即输出\n$[L(x_1;h_1), D(x_1;h_1), R(x_1;h_1), L(x_2;h_2), D(x_2;h_2), R(x_2;h_2), \\ldots, L(x_8;h_8), D(x_8;h_8), R(x_8;h_8)]$。\n\n最终输出必须是此格式的单行。不涉及任何物理单位或角度；所有报告的量均为纯数。每个报告的单个值都必须是四舍五入到 $8$ 位小数的浮点数。", "solution": "问题陈述是有效的。它提出了一个适定的计算任务，植根于数值分析和金融数学的基本原理。该问题是自洽的、客观的且科学上合理的。我们将以严谨的方式进行求解。\n\n该问题要求对欧式看涨期权收益函数 $f(x)$ 计算三种有限差商，该函数定义为：\n$$f(x) = \\max(x - K, 0)$$\n其中 $x$ 是标的资产的价格，$K$ 是行权价。对于本问题，给定 $K = 100$。该函数对于所有 $x \\in \\mathbb{R}$ 都是连续的。然而，它在 $x = K$ 这个单点上不可微。其解析导数 $f'(x)$ 在存在的情况下是一个阶跃函数：\n$$\nf'(x) = \n\\begin{cases} \n0 & \\text{if } x < K \\\\\n1 & \\text{if } x > K \n\\end{cases}\n$$\n在 $x=K$ 处，左导数为 $0$，右导数为 $1$。\n\n需要计算的三种有限差分格式为：\n1.  **左（后向）差分**：$L(x;h) = \\dfrac{f(x) - f(x - h)}{h}$\n2.  **对称（中心）差分**：$D(x;h) = \\dfrac{f(x + h) - f(x - h)}{2h}$\n3.  **右（前向）差分**：$R(x;h) = \\dfrac{f(x + h) - f(x)}{h}$\n\n我们现在将为 $8$ 个测试用例中的每一个计算三元组 $(L(x;h), D(x;h), R(x;h))$。分析将根据求值区间 $[x-h, x+h]$ 相对于 $K=100$ 处折点的位置进行组织。\n\n**情况组 1：求值区间完全位于折点左侧 ($x+h \\le K$)**\n在此区域中，$f(x-h) = f(x) = f(x+h) = 0$。\n- **测试用例 1: $(x,h) = (90.0, 0.1)$**：此处，$x-h=89.9$，$x=90.0$，$x+h=90.1$。所有点均小于 $100$。\n  $L = \\frac{0-0}{0.1} = 0$, $D = \\frac{0-0}{0.2} = 0$, $R = \\frac{0-0}{0.1} = 0$。\n  结果: $(0.0, 0.0, 0.0)$。\n- **测试用例 7: $(x,h) = (99.999999, 10^{-8})$**：此处，$x=100-10^{-6}$ 且 $h=10^{-8}$。\n  $x+h = 100 - 10^{-6} + 10^{-8} = 100 - 0.99 \\times 10^{-6} = 99.99999901 < 100$。\n  所有求值点都小于或等于 $100$，函数值为 $0$。\n  $L = \\frac{0-0}{10^{-8}} = 0$, $D = \\frac{0-0}{2 \\times 10^{-8}} = 0$, $R = \\frac{0-0}{10^{-8}} = 0$。\n  结果: $(0.0, 0.0, 0.0)$。\n\n**情况组 2：求值区间完全位于折点右侧 ($x-h > K$)**\n在此区域中，$f(z) = z - K$，是一个斜率为 $1$ 的线性函数。有限差分公式应当能精确地还原这个斜率。\n- **测试用例 2: $(x,h) = (110.0, 0.1)$**：此处，$x-h=109.9 > 100$。\n  $f(x)=10$, $f(x-h)=9.9$, $f(x+h)=10.1$。\n  $L = \\frac{10-9.9}{0.1} = 1$, $D = \\frac{10.1-9.9}{0.2} = 1$, $R = \\frac{10.1-10}{0.1} = 1$。\n  结果: $(1.0, 1.0, 1.0)$。\n- **测试用例 8: $(x,h) = (100.000001, 10^{-8})$**：此处，$x=100+10^{-6}$ 且 $h=10^{-8}$。\n  $x-h = 100 + 10^{-6} - 10^{-8} = 100 + 0.99 \\times 10^{-6} > 100$。\n  函数为 $f(z) = z-100$。\n  $L = \\frac{f(x)-f(x-h)}{h} = \\frac{(x-100)-((x-h)-100)}{h} = \\frac{h}{h} = 1$。\n  $R = \\frac{f(x+h)-f(x)}{h} = \\frac{((x+h)-100)-(x-100)}{h} = \\frac{h}{h} = 1$。\n  $D = \\frac{f(x+h)-f(x-h)}{2h} = \\frac{((x+h)-100)-((x-h)-100)}{2h} = \\frac{2h}{2h} = 1$。\n  结果: $(1.0, 1.0, 1.0)$。\n\n**情况组 3：求值区间跨越折点 ($x-h < K < x+h$)**\n这是最具启发性的情况，因为不可微性会影响近似值。\n- **测试用例 3: $(x,h) = (100.0, 0.1)$** 和 **测试用例 6: $(x,h) = (100.0, 10^{-6})$**：\n  此处，$x=K=100$。\n  $f(x) = f(100) = 0$。\n  由于 $100-h < 100$，因此 $f(x-h) = f(100-h) = 0$。\n  由于 $100+h > 100$，因此 $f(x+h) = f(100+h) = (100+h)-100 = h$。\n  $L = \\frac{0-0}{h} = 0$。这近似于左导数。\n  $R = \\frac{h-0}{h} = 1$。这近似于右导数。\n  $D = \\frac{h-0}{2h} = 0.5$。这是左导数和右导数的平均值。\n  对于这两种情况，结果都是：$(0.0, 0.5, 1.0)$。\n\n- **测试用例 4: $(x,h) = (99.99, 0.1)$**：区间是 $[99.89, 100.09]$。\n  由于 $x < K$，所以 $f(x)=0$。由于 $x-h < K$，所以 $f(x-h)=0$。\n  由于 $x+h = 100.09 > K$，所以 $f(x+h) = 100.09 - 100 = 0.09$。\n  $L = \\frac{0-0}{0.1} = 0$。\n  $R = \\frac{0.09-0}{0.1} = 0.9$。\n  $D = \\frac{0.09-0}{2 \\times 0.1} = 0.45$。\n  结果: $(0.0, 0.45, 0.9)$。\n\n- **测试用例 5: $(x,h) = (100.01, 0.1)$**：区间是 $[99.91, 100.11]$。\n  由于 $x-h = 99.91 < K$，所以 $f(x-h)=0$。\n  由于 $x = 100.01 > K$，所以 $f(x)=100.01-100=0.01$。\n  由于 $x+h = 100.11 > K$，所以 $f(x+h)=100.11-100=0.11$。\n  $L = \\frac{0.01-0}{0.1} = 0.1$。\n  $R = \\frac{0.11-0.01}{0.1} = 1$。\n  $D = \\frac{0.11-0}{2 \\times 0.1} = 0.55$。\n  结果: $(0.1, 0.55, 1.0)$。\n\n**结果摘要**\n在最终格式化之前，为每个测试用例计算出的 $(L, D, R)$ 值为：\n1.  $(90.0, 0.1) \\rightarrow (0.0, 0.0, 0.0)$\n2.  $(110.0, 0.1) \\rightarrow (1.0, 1.0, 1.0)$\n3.  $(100.0, 0.1) \\rightarrow (0.0, 0.5, 1.0)$\n4.  $(99.99, 0.1) \\rightarrow (0.0, 0.45, 0.9)$\n5.  $(100.01, 0.1) \\rightarrow (0.1, 0.55, 1.0)$\n6.  $(100.0, 10^{-6}) \\rightarrow (0.0, 0.5, 1.0)$\n7.  $(99.999999, 10^{-8}) \\rightarrow (0.0, 0.0, 0.0)$\n8.  $(100.000001, 10^{-8}) \\rightarrow (1.0, 1.0, 1.0)$\n\n以下程序实现了这一逻辑，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates left, central, and right finite difference quotients for the\n    European call option payoff function f(x) = max(x - K, 0).\n    \"\"\"\n    # Define the strike price constant.\n    K = 100.0\n\n    def f(x_val):\n        \"\"\"\n        Calculates the European call option payoff.\n        Args:\n            x_val (float or np.ndarray): The underlying price(s).\n        Returns:\n            float or np.ndarray: The payoff(s).\n        \"\"\"\n        return np.maximum(x_val - K, 0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (90.0, 0.1),\n        (110.0, 0.1),\n        (100.0, 0.1),\n        (99.99, 0.1),\n        (100.01, 0.1),\n        (100.0, 1e-6),\n        (99.999999, 1e-8),\n        (100.000001, 1e-8),\n    ]\n\n    results = []\n    for x, h in test_cases:\n        # Evaluate the function at the required points.\n        fx = f(x)\n        fx_minus_h = f(x - h)\n        fx_plus_h = f(x + h)\n\n        # Calculate the three finite difference quotients.\n        # L(x;h) = (f(x) - f(x - h)) / h\n        L = (fx - fx_minus_h) / h\n        \n        # D(x;h) = (f(x + h) - f(x - h)) / (2 * h)\n        D = (fx_plus_h - fx_minus_h) / (2 * h)\n        \n        # R(x;h) = (f(x + h) - f(x)) / h\n        R = (fx_plus_h - fx) / h\n\n        # Append the formatted results to the list.\n        # The problem requires rounding each float to 8 decimal places.\n        # Using f-string formatting for precise output.\n        results.append(f\"{L:.8f}\")\n        results.append(f\"{D:.8f}\")\n        results.append(f\"{R:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "选择合适的步长 $h$ 是数值微分中的一个核心挑战，它体现了截断误差和舍入误差之间的根本权衡。过大的 $h$ 会导致近似不准确，而过小的 $h$ 会放大计算机浮点运算的误差。本练习模拟了一个真实世界的场景：通过经验性地寻找最小化总误差的步长，来为计算期权敏感性指标“Vega”确定最佳的 $h$ 值。[@problem_id:2415200]", "id": "2415200", "problem": "考虑一个在 Black–Scholes 框架下定价的、基于不支付股息资产的欧式看涨期权。设现货价格为 $S_0$，行权价为 $K$，连续复利无风险利率为 $r$，到期时间为 $T$，波动率为 $\\sigma$。Black–Scholes 看涨期权价格为\n$$\nC(S_0,K,r,T,\\sigma)=S_0\\,\\Phi(d_1)-K e^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1=\\frac{\\ln\\!\\left(\\frac{S_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}},\\quad d_2=d_1-\\sigma\\sqrt{T},\n$$\n且 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。该看涨期权的解析 Vega 是期权价格关于 $\\sigma$ 的偏导数，由下式给出\n$$\n\\text{Vega}(S_0,K,r,T,\\sigma)=\\frac{\\partial C}{\\partial \\sigma}=S_0 \\sqrt{T}\\,\\varphi(d_1),\n$$\n其中 $\\varphi(\\cdot)$ 是标准正态概率密度函数。\n\n对于给定的参数向量 $(S_0,K,r,T,\\sigma)$，我们通过对波动率应用对称差商来定义 Vega 的一个数值估计量，\n$$\n\\widehat{\\text{Vega}}(h)=\\frac{C(S_0,K,r,T,\\sigma+h)-C(S_0,K,r,T,\\sigma-h)}{2h},\n$$\n步长 $h>0$ 且满足 $\\sigma-h>0$。对于给定的 $(S_0,K,r,T,\\sigma)$ 和一个候选步长集合\n$$\n\\mathcal{H}=\\{10^{-12},10^{-11},10^{-10},10^{-9},10^{-8},10^{-7},10^{-6},10^{-5},10^{-4},10^{-3},10^{-2}\\},\n$$\n考虑其容许子集\n$$\n\\mathcal{H}_{\\text{adm}}=\\{h\\in\\mathcal{H}\\,:\\,0<h<\\sigma/2\\}.\n$$\n定义在步长 $h\\in\\mathcal{H}_{\\text{adm}}$ 下的总误差为绝对误差\n$$\nE(h)=\\left|\\widehat{\\text{Vega}}(h)-\\text{Vega}(S_0,K,r,T,\\sigma)\\right|.\n$$\n您的任务是，对于每个指定的测试用例，确定步长 $h^\\star\\in\\mathcal{H}_{\\text{adm}}$，该步长能够经验性地使 $E(h)$ 最小化。如果存在多个最小值点，选择其中能够达到最小误差的最大的 $h$。\n\n使用以下平价附近的测试用例集：\n1. $(S_0,K,r,T,\\sigma)=(100,100,0.01,1.0,0.2)$。\n2. $(S_0,K,r,T,\\sigma)=(100,100,0.01,0.01,0.2)$。\n3. $(S_0,K,r,T,\\sigma)=(100,102,0.02,0.5,0.05)$。\n4. $(S_0,K,r,T,\\sigma)=(100,100,0.03,2.0,0.6)$。\n\n所有量均为无量纲的金融参数，因此不需要物理单位。不涉及角度。每个测试用例的最终答案必须以浮点数形式返回。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[h_1,h_2,h_3,h_4]$），其中每个 $h_i$ 是测试用例 $i$ 所选的步长 $h^\\star$。", "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于 Black-Scholes 期权定价理论和数值分析原理。问题定义良好，包含了所有必要的参数、公式以及一个清晰、明确的目标。问题没有矛盾和主观论断。因此，将提供一个解决方案。\n\n任务是为期权 Vega 的数值估计找到最优步长 $h^\\star$。Vega 是期权价格关于波动率 $\\sigma$ 的一阶偏导数。数值估计使用对称差商进行。最优步长 $h^\\star$ 定义为给定离散集 $\\mathcal{H}_{\\text{adm}}$ 中，能使 Vega 的数值估计值与解析值之间的绝对误差最小化的那个值。\n\n对于由参数集 $(S_0, K, r, T, \\sigma)$ 定义的每个测试用例，方法如下：\n\n1.  **解析 Vega 计算**：首先，使用提供的解析公式计算 Vega 的精确值：\n    $$ \\text{Vega}(S_0,K,r,T,\\sigma) = S_0 \\sqrt{T}\\,\\varphi(d_1) $$\n    其中 $\\varphi(\\cdot)$ 是标准正态分布的概率密度函数（PDF），而 $d_1$ 由下式给出：\n    $$ d_1=\\frac{\\ln(S_0/K)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}} $$\n    该解析值作为比较数值估计值的基准。\n\n2.  **数值估计与误差计算**：对于容许集 $\\mathcal{H}_{\\text{adm}}$ 中的每个步长 $h$，我们使用对称差商计算 Vega 的数值近似值，记为 $\\widehat{\\text{Vega}}(h)$：\n    $$ \\widehat{\\text{Vega}}(h)=\\frac{C(S_0,K,r,T,\\sigma+h)-C(S_0,K,r,T,\\sigma-h)}{2h} $$\n    这里，$C(\\cdot)$ 是 Black-Scholes 看涨期权价格函数：\n    $$ C(S_0,K,r,T,\\sigma)=S_0\\,\\Phi(d_1)-K e^{-rT}\\,\\Phi(d_2) $$\n    其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数（CDF），且 $d_2 = d_1 - \\sigma\\sqrt{T}$。然后计算每个 $h$ 对应的绝对误差为：\n    $$ E(h)=\\left|\\widehat{\\text{Vega}}(h)-\\text{Vega}(S_0,K,r,T,\\sigma)\\right| $$\n\n3.  **最优步长选择**：候选步长集合由 $\\mathcal{H} = \\{10^{-12}, 10^{-11}, \\dots, 10^{-2}\\}$ 给出。容许集 $\\mathcal{H}_{\\text{adm}}$ 定义为 $\\{h\\in\\mathcal{H}\\,:\\,0<h<\\sigma/2\\}$。对于所有给定的测试用例，条件 $h < \\sigma/2$ 对所有 $h \\in \\mathcal{H}$ 都成立，因此 $\\mathcal{H}_{\\text{adm}} = \\mathcal{H}$。我们计算每个 $h \\in \\mathcal{H}$ 的误差 $E(h)$。然后，我们确定最小误差 $E_{\\min} = \\min_{h \\in \\mathcal{H}} E(h)$。最优步长 $h^\\star$ 是所有产生此最小误差的步长中最大的那个 $h$ 值。\n\n这个过程反映了数值微分中的一个基本权衡。总误差 $E(h)$ 是由两个相反来源的误差复合而成的：\n- **截断误差**：这是有限差分近似固有的误差。对于对称差商，其阶数为 $O(h^2)$。随着 $h$ 变小，该误差减小。\n- **舍入误差**：该误差源于浮点运算的有限精度，特别是在减去两个几乎相等的值（$C(\\sigma+h)$ 和 $C(\\sigma-h)$）时发生的灾难性抵消，以及随后除以一个很小的 $h$。该误差分量大致与 $\\epsilon_{mach}/h$ 成正比，其中 $\\epsilon_{mach}$ 是机器精度。随着 $h$ 变小，该误差增大。\n\n这两种误差之和导致总误差曲线在以对数尺度绘制与 $h$ 的关系时通常呈 U 形。在离散集 $\\mathcal{H}$ 上进行的经验性搜索使我们能够找到最接近该曲线底部的步长，这代表了截断误差和舍入误差之间的最优平衡。\n\n实现将包含一个主函数，该函数遍历每个测试用例。对于每个用例，它将计算所有候选步长的误差，确定最小误差，并根据指定的平局决胜规则选择相应的最优步长。将使用 `scipy.stats.norm` 中所需的函数来评估标准正态 CDF（$\\Phi$）和 PDF（$\\varphi$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# from scipy import ...\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 100.0, 0.01, 1.0, 0.2),\n        (100.0, 100.0, 0.01, 0.01, 0.2),\n        (100.0, 102.0, 0.02, 0.5, 0.05),\n        (100.0, 100.0, 0.03, 2.0, 0.6),\n    ]\n\n    # Candidate set of step sizes H\n    H = [10**-12, 10**-11, 10**-10, 10**-9, 10**-8, 10**-7,\n         10**-6, 10**-5, 10**-4, 10**-3, 10**-2]\n\n    # Function to calculate Black-Scholes call price\n    def black_scholes_call(S0, K, r, T, sigma):\n        # Handle edge cases for sigma and T to avoid mathematical errors\n        if sigma <= 0 or T <= 0:\n            # If T > 0 and sigma = 0, the option price is deterministic.\n            # If T = 0, the option price is its intrinsic value.\n            return max(0.0, S0 - K * np.exp(-r * T))\n            \n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    # Function to calculate analytical Vega\n    def analytical_vega(S0, K, r, T, sigma):\n        # Vega is zero if T=0 or sigma=0\n        if sigma <= 0 or T <= 0:\n            return 0.0\n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        vega = S0 * np.sqrt(T) * norm.pdf(d1)\n        return vega\n\n    optimal_h_results = []\n\n    for case in test_cases:\n        S0, K, r, T, sigma = case\n\n        # Determine the admissible set of step sizes.\n        # For all test cases provided, sigma/2 is greater than the largest h_cand in H,\n        # so the admissible set is the full set H.\n        H_adm = [h for h in H if 0 < h < sigma / 2.0]\n\n        # Calculate the true analytical Vega to use as a benchmark\n        true_vega = analytical_vega(S0, K, r, T, sigma)\n\n        errors_with_h = []\n        for h in H_adm:\n            # Calculate numerical Vega using symmetric difference quotient\n            C_plus = black_scholes_call(S0, K, r, T, sigma + h)\n            C_minus = black_scholes_call(S0, K, r, T, sigma - h)\n            numerical_vega = (C_plus - C_minus) / (2.0 * h)\n            \n            # Calculate the absolute error\n            error = abs(numerical_vega - true_vega)\n            errors_with_h.append((error, h))\n\n        # Find the minimum error among all step sizes\n        min_error = min(e for e, h in errors_with_h)\n\n        # Find all step sizes that achieve this minimum error\n        minimizing_hs = [h for e, h in errors_with_h if e == min_error]\n\n        # Select the largest h among the minimizers as per the tie-breaking rule\n        optimal_h = max(minimizing_hs)\n        optimal_h_results.append(optimal_h)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, optimal_h_results))}]\")\n\nsolve()\n```"}]}