{"hands_on_practices": [{"introduction": "本章节的第一个练习将为你运用摄动法打下坚实的实践基础。你将探索两种常见的模型线性化方法——直接对变量（如资本存量 $k_t$）进行线性化，以及对其对数 $\\log(k_t)$ 进行线性化。通过比较这两种方法的结果，你将更深刻地理解一阶近似的本质。本练习旨在巩固你对线性化过程的掌握，并展示这两种方法在一阶近似下的等价性，这是任何实践者都必须理解的关键概念。[@problem_id:2418943]", "id": "2418943", "problem": "考虑具有 Cobb-Douglas 技术和外生生产率的随机 Solow 增长模型：\n- 资本根据 $k_{t+1} = s \\, a_t \\, k_t^{\\alpha} + (1-\\delta) k_t$ 演化，其中 $k_t > 0$ 是资本存量，$s \\in (0,1)$ 是储蓄率，$\\alpha \\in (0,1)$ 是资本的产出弹性，$\\delta \\in (0,1)$ 是折旧率。\n- 生产率满足 $a_t = \\exp(z_t)$，其中对数生产率服从一个自回归过程 $z_t = (1-\\rho)\\,\\bar z + \\rho\\, z_{t-1} + \\sigma \\varepsilon_t$，这里 $|\\rho| &lt; 1$, $\\sigma \\ge 0$，且 $\\varepsilon_t$ 是一个均值为 $0$、单位方差的独立同分布 (i.i.d.) 新息。\n- 令确定性稳态为 $(\\bar k, \\bar z)$，其中 $\\bar a = \\exp(\\bar z)$，$\\bar k$ 解出方程 $\\bar k = s \\bar a \\bar k^{\\alpha} + (1-\\delta)\\bar k$。\n\n你需要围绕确定性稳态，比较两种一阶扰动方法下资本的脉冲响应函数：\n- 水平值线性化：对变量 $(k_t, z_t)$ 进行线性化。\n- 对数线性化：对 $(\\log k_t, z_t)$ 进行线性化，并使用一阶映射 $k_t \\approx \\bar k (1 + \\hat k_t)$ 报告资本的水平值响应，其中 $\\hat k_t = \\log(k_t) - \\log(\\bar k)$。\n\n通过设置在 $t=0$ 时 $\\varepsilon_0 = 1$ 且对于所有 $t \\ge 1$ 有 $\\varepsilon_t = 0$，并给定初始条件 $k_0 = \\bar k$ 和 $z_{-1} = \\bar z$，来定义对一个单位标准差生产率冲击的脉冲响应。在两种方法下，构建 $k_t$ 在有限期界 $t=0,1,\\dots,H$ 内的脉冲响应，并保持近似阶数固定为一阶。对于下方的每一组参数，计算在 $t=0,1,\\dots,H$ 范围内，两种资本水平值响应之间的最大绝对差。\n\n测试集（每行为一个独立案例，按所列顺序进行评估）：\n- 案例 A (正常路径)：$\\alpha = 0.35$, $\\delta = 0.08$, $s = 0.25$, $\\rho = 0.90$, $\\sigma = 0.01$, $\\bar z = 0$, $H = 20$。\n- 案例 B (低折旧)：$\\alpha = 0.33$, $\\delta = 0.01$, $s = 0.15$, $\\rho = 0.80$, $\\sigma = 0.02$, $\\bar z = 0$, $H = 30$。\n- 案例 C (无持续性)：$\\alpha = 0.40$, $\\delta = 0.12$, $s = 0.30$, $\\rho = 0$, $\\sigma = 0.05$, $\\bar z = 0$, $H = 15$。\n- 案例 D (高持续性)：$\\alpha = 0.30$, $\\delta = 0.05$, $s = 0.20$, $\\rho = 0.99$, $\\sigma = 0.005$, $\\bar z = 0$, $H = 40$。\n- 案例 E (零冲击规模)：$\\alpha = 0.33$, $\\delta = 0.10$, $s = 0.20$, $\\rho = 0.95$, $\\sigma = 0$, $\\bar z = 0$, $H = 20$。\n\n你的程序必须：\n- 根据模型定义和参数，从第一性原理计算 $\\bar k$。\n- 构建水平值和对数形式的一阶扰动动态。\n- 对于每个案例，在指定的期界内模拟两种方法下 $k_t$ 的脉冲响应，并计算在 $t=0,1,\\dots,H$ 上的最大绝对差。\n- 输出一行，其中包含一个用方括号括起来的、以逗号分隔的最大值列表，顺序为 A 到 E。每个值必须是四舍五入到 $12$ 位小数的浮点数。例如，包含三个案例的输出应形如 $[x_1,x_2,x_3]$，且不含空格。\n\n不涉及物理单位。不出现角度。任何地方都不得使用百分比；所有值均为实数。", "solution": "用户提供的问题陈述已经过严格验证，被认为是有效的。它具有科学依据，问题设定良好、客观，并包含推导出唯一解所需的所有必要信息。我们现在开始给出一个完整的、有理有据的解答。\n\n该问题要求比较两种用于求解随机 Solow 增长模型的一阶扰动方法。分析的核心在于推导两种方法的线性化动态过程，模拟资本对生产率冲击的脉冲响应，并计算两条所得资本路径之间的最大绝对差。\n\n首先，我们定义模型方程：\n1.  资本积累：$k_{t+1} = s \\, a_t \\, k_t^{\\alpha} + (1-\\delta) k_t$，其中 $a_t = \\exp(z_t)$。\n2.  对数生产率过程：$z_t = (1-\\rho)\\,\\bar z + \\rho\\, z_{t-1} + \\sigma \\varepsilon_t$。\n\n我们来确定确定性稳态 $(\\bar k, \\bar z)$。在此状态下，没有冲击（$\\varepsilon_t = 0$），因此对所有 $t$ 都有 $z_t = \\bar z$。资本存量是恒定的，$k_t = k_{t+1} = \\bar k$。稳态由以下方程定义：\n$$\n\\bar k = s \\, \\exp(\\bar z) \\, \\bar k^{\\alpha} + (1-\\delta) \\bar k\n$$\n令 $\\bar a = \\exp(\\bar z)$，我们简化方程：\n$$\n\\delta \\bar k = s \\bar a \\bar k^{\\alpha}\n$$\n由于 $k_t > 0$，我们知道 $\\bar k > 0$。我们可以用 $\\bar k^{\\alpha}$ 去除：\n$$\n\\delta \\bar k^{1-\\alpha} = s \\bar a\n$$\n解出 $\\bar k$ 得到稳态资本存量：\n$$\n\\bar k = \\left(\\frac{s \\bar a}{\\delta}\\right)^{\\frac{1}{1-\\alpha}}\n$$\n\n接下来，我们分析扰动方法。令偏离稳态的量用波浪号表示，例如 $\\tilde k_t = k_t - \\bar k$ 和 $\\tilde z_t = z_t - \\bar z$。$\\tilde z_t$ 的外生过程可以通过从 $z_t$ 的方程中减去 $\\bar z$ 来得到：\n$$\nz_t - \\bar z = (1-\\rho)\\bar z + \\rho z_{t-1} + \\sigma \\varepsilon_t - \\bar z = \\rho(z_{t-1} - \\bar z) + \\sigma \\varepsilon_t\n$$\n$$\n\\tilde z_t = \\rho \\tilde z_{t-1} + \\sigma \\varepsilon_t\n$$\n给定初始条件 $z_{-1} = \\bar z$（即 $\\tilde z_{-1}=0$）和一次性冲击 $\\varepsilon_0 = 1$（即当 $t \\ge 1$ 时 $\\varepsilon_t=0$），$\\tilde z_t$ 的路径为：\n$$\n\\tilde z_0 = \\rho \\tilde z_{-1} + \\sigma \\varepsilon_0 = \\sigma\n$$\n$$\n\\tilde z_1 = \\rho \\tilde z_0 + \\sigma \\varepsilon_1 = \\rho \\sigma\n$$\n$$\n\\tilde z_t = \\rho^t \\sigma \\quad \\text{for } t \\ge 0\n$$\n\n**1. 水平值线性化**\n\n我们在稳态 $(\\bar k, \\bar z)$ 附近对资本积累方程 $k_{t+1} = f(k_t, z_t)$ 进行线性化。一阶泰勒展开给出：\n$$\nk_{t+1} - \\bar k \\approx \\frac{\\partial f}{\\partial k_t}\\bigg|_{(\\bar k, \\bar z)} (k_t - \\bar k) + \\frac{\\partial f}{\\partial z_t}\\bigg|_{(\\bar k, \\bar z)} (z_t - \\bar z)\n$$\n$$\n\\tilde k_{t+1} \\approx J_k \\tilde k_t + J_z \\tilde z_t\n$$\n所需的偏导数为：\n$$\nJ_k = \\frac{\\partial f}{\\partial k_t}\\bigg|_{(\\bar k, \\bar z)} = s \\bar a \\alpha \\bar k^{\\alpha-1} + (1-\\delta)\n$$\n使用稳态条件 $s \\bar a = \\delta \\bar k^{1-\\alpha}$，我们有：\n$$\nJ_k = (\\delta \\bar k^{1-\\alpha}) \\alpha \\bar k^{\\alpha-1} + (1-\\delta) = \\alpha \\delta + 1 - \\delta = 1 - \\delta(1-\\alpha)\n$$\n$$\nJ_z = \\frac{\\partial f}{\\partial z_t}\\bigg|_{(\\bar k, \\bar z)} = s \\exp(z_t) k_t^\\alpha \\bigg|_{(\\bar k, \\bar z)} = s \\bar a \\bar k^\\alpha\n$$\n再次使用稳态条件 $\\delta \\bar k = s \\bar a \\bar k^\\alpha$：\n$$\nJ_z = \\delta \\bar k\n$$\n因此，水平值线性化系统为：\n$$\n\\tilde k_{t+1}^{\\text{level}} = (1 - \\delta(1-\\alpha)) \\tilde k_t^{\\text{level}} + (\\delta \\bar k) \\tilde z_t\n$$\n资本的水平值脉冲响应，记作 $k_t^{\\text{level}}$，是 $k_t^{\\text{level}} = \\bar k + \\tilde k_t^{\\text{level}}$。\n\n**2. 对数线性化**\n\n我们根据对数偏离稳态的方式对模型进行线性化。令 $\\hat k_t = \\log(k_t) - \\log(\\bar k)$。用于线性化的状态变量是 $(\\log k_t, z_t)$。资本积累方程不能轻易地取对数。因此，我们直接对函数 $k_{t+1}(\\log k_t, z_t)$ 进行线性化。一个更稳健的方法是在稳态附近对以下隐函数进行线性化：\n$$\n\\log(k_{t+1}) = \\log\\left(s \\exp(z_t) k_t^\\alpha + (1-\\delta)k_t\\right)\n$$\n令 $x_t = \\log k_t$。$\\hat k_{t+1} = \\log(k_{t+1}) - \\log(\\bar k)$ 的线性化方程为：\n$$\n\\hat k_{t+1} \\approx \\frac{\\partial \\log(k_{t+1})}{\\partial x_t}\\bigg|_{SS} \\hat k_t + \\frac{\\partial \\log(k_{t+1})}{\\partial z_t}\\bigg|_{SS} \\tilde z_t\n$$\n导数是：\n$$\n\\frac{\\partial \\log(k_{t+1})}{\\partial x_t} = \\frac{1}{k_{t+1}} \\frac{\\partial k_{t+1}}{\\partial x_t} = \\frac{1}{k_{t+1}} \\frac{\\partial}{\\partial x_t}\\left(s e^{z_t} e^{\\alpha x_t} + (1-\\delta)e^{x_t}\\right) = \\frac{s e^{z_t} \\alpha e^{\\alpha x_t} + (1-\\delta)e^{x_t}}{s e^{z_t} e^{\\alpha x_t} + (1-\\delta)e^{x_t}}\n$$\n在稳态 ($x_t=\\log \\bar k, z_t=\\bar z, k_{t+1}=\\bar k$) 处求值，这变为：\n$$\n\\frac{s \\bar a \\alpha \\bar k^\\alpha + (1-\\delta)\\bar k}{s \\bar a \\bar k^\\alpha + (1-\\delta)\\bar k} = \\frac{\\alpha(\\delta \\bar k) + (1-\\delta)\\bar k}{\\bar k} = \\alpha\\delta + 1 - \\delta = 1 - \\delta(1-\\alpha)\n$$\n对于 $z_t$：\n$$\n\\frac{\\partial \\log(k_{t+1})}{\\partial z_t} = \\frac{1}{k_{t+1}} \\frac{\\partial k_{t+1}}{\\partial z_t} = \\frac{s e^{z_t} k_t^\\alpha}{k_{t+1}}\n$$\n在稳态处求值，这为：\n$$\n\\frac{s \\bar a \\bar k^\\alpha}{\\bar k} = \\frac{\\delta \\bar k}{\\bar k} = \\delta\n$$\n对数线性化动态为：\n$$\n\\hat k_{t+1}^{\\text{log}} = (1 - \\delta(1-\\alpha)) \\hat k_t^{\\text{log}} + \\delta \\tilde z_t\n$$\n问题要求使用一阶近似 $k_t \\approx \\bar k(1 + \\hat k_t)$ 将其转换回水平值。所以，$k_t^{\\text{log}} = \\bar k(1 + \\hat k_t^{\\text{log}})$。\n\n**3. 脉冲响应的比较**\n\n我们必须对 $t=0, 1, \\dots, H$ 比较两条路径 $k_t^{\\text{level}}$ 和 $k_t^{\\text{log}}$。\n初始条件为 $k_0 = \\bar k$ 和 $z_{-1} = \\bar z$。这意味着：\n- $k_0^{\\text{level}} = \\bar k$，所以 $\\tilde k_0^{\\text{level}} = 0$。\n- 对于对数线性化情况，$\\log(k_0) = \\log(\\bar k)$，所以 $\\hat k_0^{\\text{log}} = 0$。因此 $k_0^{\\text{log}} = \\bar k(1+0) = \\bar k$。\n在 $t=0$ 时，差值 $|k_0^{\\text{level}} - k_0^{\\text{log}}|$ 为 $0$。\n\n我们来考察 $t \\ge 1$ 时的关系。\n水平值偏差的路径由 $\\tilde k_{t+1}^{\\text{level}} = (1 - \\delta(1-\\alpha)) \\tilde k_t^{\\text{level}} + (\\delta \\bar k) \\tilde z_t$ 给出。\n对数值偏差的路径为 $\\hat k_{t+1}^{\\text{log}} = (1 - \\delta(1-\\alpha)) \\hat k_t^{\\text{log}} + \\delta \\tilde z_t$。\n\n我们定义一个缩放后的对数值偏差 $Y_t = \\bar k \\hat k_t^{\\text{log}}$。$Y_t$ 的演化过程是：\n$$\nY_{t+1} = \\bar k \\hat k_{t+1}^{\\text{log}} = \\bar k \\left( (1 - \\delta(1-\\alpha)) \\hat k_t^{\\text{log}} + \\delta \\tilde z_t \\right)\n$$\n$$\nY_{t+1} = (1 - \\delta(1-\\alpha)) (\\bar k \\hat k_t^{\\text{log}}) + (\\bar k \\delta) \\tilde z_t\n$$\n$$\nY_{t+1} = (1 - \\delta(1-\\alpha)) Y_t + (\\delta \\bar k) \\tilde z_t\n$$\n$Y_t$ 的这个递推关系与 $\\tilde k_t^{\\text{level}}$ 的递推关系是相同的。初始条件也相同：\n- $\\tilde k_0^{\\text{level}} = 0$。\n- $Y_0 = \\bar k \\hat k_0^{\\text{log}} = \\bar k \\cdot 0 = 0$。\n\n由于序列 $\\left\\{\\tilde k_t^{\\text{level}}\\right\\}$ 和 $\\left\\{Y_t\\right\\}$ 都由相同的线性递推关系生成，并从相同的初始条件开始，因此它们对于所有 $t$ 都必须是相同的。\n$$\n\\tilde k_t^{\\text{level}} = Y_t = \\bar k \\hat k_t^{\\text{log}} \\quad \\forall t \\ge 0\n$$\n现在我们计算两条资本路径之间的差值：\n$$\nk_t^{\\text{level}} - k_t^{\\text{log}} = (\\bar k + \\tilde k_t^{\\text{level}}) - \\bar k(1 + \\hat k_t^{\\text{log}}) = \\bar k + \\tilde k_t^{\\text{level}} - \\bar k - \\bar k \\hat k_t^{\\text{log}} = \\tilde k_t^{\\text{level}} - \\bar k \\hat k_t^{\\text{log}}\n$$\n根据我们上面的证明，这个差值对于所有 $t \\ge 0$ 恒为零。\n$$\nk_t^{\\text{level}} - k_t^{\\text{log}} = 0 \\quad \\forall t \\ge 0\n$$\n因此，在期界 $t=0, 1, \\dots, H$ 内的最大绝对差也为 $0$。这一结果表明，当对数线性化通过其自身的一阶近似转换回水平值时，水平值线性化和对数线性化在一阶上是等价的。这对于任何给定的有效参数集都成立。数值实现将计算路径及其差异，其结果应在机器精度范围内为零。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute difference between capital impulse responses\n    from levels-linearization and log-linearization for the stochastic Solow model.\n    \"\"\"\n    # Test suite: (alpha, delta, s, rho, sigma, z_bar, H)\n    test_cases = [\n        (0.35, 0.08, 0.25, 0.90, 0.01, 0.0, 20),   # Case A\n        (0.33, 0.01, 0.15, 0.80, 0.02, 0.0, 30),   # Case B\n        (0.40, 0.12, 0.30, 0.0, 0.05, 0.0, 15),    # Case C\n        (0.30, 0.05, 0.20, 0.99, 0.005, 0.0, 40),  # Case D\n        (0.33, 0.10, 0.20, 0.95, 0.0, 0.0, 20),    # Case E\n    ]\n\n    max_diffs = []\n\n    for case in test_cases:\n        alpha, delta, s, rho, sigma, z_bar, H = case\n        \n        # 1. Compute steady state\n        a_bar = np.exp(z_bar)\n        # Handle alpha=1 edge case to avoid division by zero, though not in test cases\n        if abs(1.0 - alpha) < 1e-12:\n            # This case is not economically standard and not in test suite.\n            # A placeholder, though it won't be reached.\n            k_bar = 1.0 \n        else:\n            k_bar = (s * a_bar / delta) ** (1.0 / (1.0 - alpha))\n\n        # 2. Simulate the exogenous shock process z_t\n        # Path of z_tilde_t = z_t - z_bar\n        z_tilde_path = np.zeros(H + 1)\n        if sigma != 0:\n            for t in range(H + 1):\n                z_tilde_path[t] = (rho ** t) * sigma\n        \n        # 3. Simulate impulse responses for both methods\n        \n        # Levels linearization\n        k_level_path = np.zeros(H + 1)\n        k_tilde_level_path = np.zeros(H + 1)\n        \n        # Log-linearization\n        k_log_path = np.zeros(H + 1)\n        k_hat_log_path = np.zeros(H + 1)\n\n        # Initial conditions at t=0\n        # k_0 = k_bar implies k_tilde_0 = 0 and k_hat_0 = 0\n        k_level_path[0] = k_bar\n        k_log_path[0] = k_bar\n\n        # Coefficients for the recurrence relations\n        coeff_k = 1.0 - delta * (1.0 - alpha)\n        coeff_z_level = delta * k_bar\n        coeff_z_log = delta\n\n        # Iterate from t=0 to H-1 to find states at t=1..H\n        for t in range(H):\n            # Levels-linearization update\n            k_tilde_level_path[t+1] = coeff_k * k_tilde_level_path[t] + coeff_z_level * z_tilde_path[t]\n            k_level_path[t+1] = k_bar + k_tilde_level_path[t+1]\n\n            # Log-linearization update\n            k_hat_log_path[t+1] = coeff_k * k_hat_log_path[t] + coeff_z_log * z_tilde_path[t]\n            k_log_path[t+1] = k_bar * (1.0 + k_hat_log_path[t+1])\n\n        # 4. Compute the maximum absolute difference\n        abs_diff = np.abs(k_level_path - k_log_path)\n        max_abs_diff = np.max(abs_diff)\n        \n        max_diffs.append(f\"{max_abs_diff:.12f}\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(max_diffs)}]\")\n\nsolve()\n```"}, {"introduction": "应用摄动法时，一个常见的陷阱是围绕错误的稳态点进行模型展开。本练习被设计成一次“法证”调查，旨在揭示当这一基本步骤出错时会发生什么。通过刻意围绕一个不正确的点来线性化一个标准的真实商业周期（RBC）模型，你将学会如何识别由此产生的病态行为（如爆发性动态），并理解为何正确的稳态计算是有效动态分析的不可动摇的基石。[@problem_id:2418938]", "id": "2418938", "problem": "考虑一个标准的单部门真实商业周期（RBC）模型，该模型具有非弹性劳动和对数效用。时间是离散的。代表性家庭在资源约束下最大化其期望折现效用，而企业则使用柯布-道格拉斯技术进行生产。结构性环境如下：\n- 偏好：$\\sum_{t=0}^{\\infty} \\beta^{t} \\log(c_{t})$，其中折现因子 $\\beta \\in (0,1)$。\n- 技术：$y_{t} = \\exp(z_{t}) k_{t}^{\\alpha}$，其中资本份额 $\\alpha \\in (0,1)$。\n- 资本积累与资源可行性：$c_{t} + k_{t+1} = (1-\\delta) k_{t} + y_{t}$，其中折旧率 $\\delta \\in (0,1)$。\n- 生产率冲击：$z_{t+1} = \\rho z_{t} + \\sigma \\varepsilon_{t+1}$，其中 $|\\rho|<1$，$\\sigma>0$ 且 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$。\n\n基本的均衡一阶条件为：\n- 欧拉方程：$\\dfrac{1}{c_{t}} = \\beta \\, \\mathbb{E}_{t} \\left[ \\dfrac{1}{c_{t+1}} \\left( \\alpha \\exp(z_{t+1}) k_{t+1}^{\\alpha-1} + 1 - \\delta \\right) \\right]$。\n- 资源可行性：$c_{t} + k_{t+1} - (1-\\delta)k_{t} - \\exp(z_{t}) k_{t}^{\\alpha} = 0$。\n\n令预定内生变量向量为 $x_{t} = k_{t}$，非预定内生（跳跃）变量向量为 $y_{t} = c_{t}$，外生状态向量为 $z_{t}$（标量）。将欧拉方程残差和资源可行性残差在变量 $(x_{t+1},y_{t+1},x_{t},y_{t},z_{t+1},z_{t})$ 处求值并堆叠，定义在时刻 $t$ 的均衡残差向量 $f(\\cdot)$。\n\n围绕稳态的一阶扰动需要在满足稳态条件的点附近对均衡条件进行线性化。在本练习中，您需要实现一个朴素的一阶扰动，该扰动忽略常数残差，并围绕可能不满足稳态条件的错误“伪稳态”进行线性化。其目的是通过计算所得的脉冲响应函数（IRF）和稳定性质，来说明当展开点不正确时可能出现的病态问题。\n\n需要实现的任务：\n1. 对于给定的展开点 $(\\bar{x},\\bar{y},\\bar{z}) = (\\bar{k},\\bar{c},0)$ 及其“下一期”对应点 $(\\bar{x}^{+},\\bar{y}^{+},\\bar{z}^{+}) = (\\bar{k},\\bar{c},0)$，使用中心有限差分法数值计算 $f$ 的雅可比矩阵块：\n   - $f_{x^{+}} = \\frac{\\partial f}{\\partial x_{t+1}}(\\bar{\\cdot})$, $f_{y^{+}} = \\frac{\\partial f}{\\partial y_{t+1}}(\\bar{\\cdot})$, $f_{x} = \\frac{\\partial f}{\\partial x_{t}}(\\bar{\\cdot})$, $f_{y} = \\frac{\\partial f}{\\partial y_{t}}(\\bar{\\cdot})$, $f_{z} = \\frac{\\partial f}{\\partial z_{t}}(\\bar{\\cdot})$, $f_{z^{+}} = \\frac{\\partial f}{\\partial z_{t+1}}(\\bar{\\cdot})$。\n   使用与被扰动变量的大小成比例的步长，以避免数值下溢，并确保在扰动中 $y$ 保持严格为正。\n2. 通过其条件期望合并 $z_{t+1}$ 项，构建（关于偏离展开点的离差的）线性化期望系统：\n   - 令 $F_{x^{+}} = f_{x^{+}}$, $F_{y^{+}} = f_{y^{+}}$, $F_{x} = f_{x}$, $F_{y} = f_{y}$ 且 $F_{z} = f_{z} + f_{z^{+}} \\rho$。\n   - 线性化均衡为 $F_{x^{+}} x_{t+1} + F_{y^{+}} y_{t+1} + F_{x} x_{t} + F_{y} y_{t} + F_{z} z_{t} = 0$，其中期望通过政策函数应用于 $y_{t+1}$。\n3. 假设朴素一阶解具有线性政策函数（忽略在非解点进行线性化所引起的任何常数项）：\n   - $x_{t+1} = p \\, x_{t} + q \\, z_{t}$，\n   - $y_{t} = r \\, x_{t} + s \\, z_{t}$，\n   - 因此 $\\mathbb{E}_{t} y_{t+1} = r \\, x_{t+1} + s \\, \\rho \\, z_{t}$。\n   施加条件，使得线性化系统中每个方程里 $x_{t}$ 和 $z_{t}$ 的系数都恒等于零，从而得到两个向量条件。从 $x_{t}$ 的系数条件中求解 $(p,r)$，然后从 $z_{t}$ 的系数条件中求解 $(q,s)$。对 $(p,r)$ 使用鲁棒的数值求根器，对 $(q,s)$ 使用线性求解器。如果求解器未能收敛到有限解，则将该情况视为“无有效解”。\n4. 使用求得的 $(p,q,r,s)$，计算 $(x_{t},y_{t})$ 对 $t=0$ 时大小为 $\\Delta z_{0} = \\sigma$ 的一次性初始外生状态偏离的脉冲响应函数（IRF）。其中 $x_{0}=0$，且对于 $t \\ge 0$ 有 $z_{t+1} = \\rho z_{t}$ 并且无后续冲击。也就是说，设 $z_{0} = \\sigma$，然后迭代：\n   - $y_{t} = r \\, x_{t} + s \\, z_{t}$，\n   - $x_{t+1} = p \\, x_{t} + q \\, z_{t}$，\n   - $z_{t+1} = \\rho \\, z_{t}$，\n   在有限期界 $T$ 内，对 $t = 0,1,\\dots,T-1$ 进行上述迭代。\n5. 使用以下定量指标诊断“病态问题”：\n   - 稳定性标志：如果 $|p| < 1$ 则设为 $1$，否则设为 $0$。\n   - 消费即期响应的符号一致性标志：当 $\\Delta z_{0} > 0$ 时，如果 $y_{0} \\ge 0$ 则设为 $1$，否则设为 $0$。\n   - 发散标志：计算期界内各期的欧几里得范数 $\\| (x_{t},y_{t}) \\|$；如果求解器失败，或 $|p| \\ge 1$，或比率 $\\max_{t \\in \\{T-5,\\dots,T-1\\}} \\| (x_{t},y_{t}) \\| \\big/ \\max_{t \\in \\{0,\\dots,4\\}} \\| (x_{t},y_{t}) \\|$ 超过 $100$，则设为 $1$，否则设为 $0$。\n\n参数值：\n- $\\beta = 0.96$, $\\alpha = 0.36$, $\\delta = 0.08$, $\\rho = 0.90$, $\\sigma = 0.01$, $T = 40$。\n- 正确的稳态（展开点）满足 $1 = \\beta \\left( \\alpha \\bar{k}^{\\alpha-1} + 1 - \\delta \\right)$，因此 $\\bar{k} = \\left( \\dfrac{\\alpha}{\\beta^{-1} - 1 + \\delta} \\right)^{\\frac{1}{1-\\alpha}}$，$\\bar{y} = \\bar{k}^{\\alpha}$，$\\bar{c} = \\bar{y} - \\delta \\bar{k}$，且 $\\bar{z} = 0$。\n\n展开点测试集（围绕每个点进行“朴素”线性化，将其视为稳态）：\n- 情况 A（正确的展开点）：根据上述公式计算的 $(\\bar{k}, \\bar{c}, 0)$。\n- 情况 B（不正确但资源一致）：$(\\tilde{k}, \\tilde{c}, 0)$，其中 $\\tilde{k} = 0.5 \\, \\bar{k}$ 且 $\\tilde{c} = \\tilde{k}^{\\alpha} - \\delta \\tilde{k}$。\n- 情况 C（不正确且资源不一致）：$(\\hat{k}, \\hat{c}, 0)$，其中 $\\hat{k} = 5.0 \\, \\bar{k}$ 且 $\\hat{c} = 0.2 \\, \\bar{c}$。\n\n您的程序必须：\n- 数值计算雅可比矩阵，使用所述方法求解 $(p,q,r,s)$，对每种情况在一次性初始偏离 $\\Delta z_{0} = \\sigma$ 下模拟脉冲响应函数，并按顺序计算每种情况的三个标志：稳定性标志、符号一致性标志、发散标志。\n- 生成一行输出，其中包含所有结果，形式为用方括号括起来的逗号分隔列表，顺序为：情况 A 的标志，后跟情况 B 的标志，再后跟情况 C 的标志。例如，输出格式必须与以下完全一样：$[a_{1},a_{2},a_{3},b_{1},b_{2},b_{3},c_{1},c_{2},c_{3}]$，其中每个 $a_{i}$、$b_{i}$、$c_{i}$ 都是整数 $0$ 或 $1$。\n\n不涉及物理单位或角度单位。所有数值输出都必须精确地表示为整数 $0$ 或 $1$，而不是小数。", "solution": "该问题要求对一个标准的真实商业周期（RBC）模型实现并评估一阶扰动方法。该问题的独特之处在于，它指示围绕不一定是模型真实确定性稳态的点进行线性化（扰动）。这是一个教学练习，旨在演示因展开点不正确而产生的病态问题，而这种错误在实际应用中很常见。我的回答将展示解决此问题的系统性步骤，并遵循指定的数值方法。\n\n首先，必须明确定义经济环境的结构方程。在给定的偏好、技术和约束下，代表性家庭的问题得出两个基本的一阶条件，这两个条件必须在所有时刻 $t$ 的均衡状态下成立：\n1.  欧拉方程，它决定了跨期消费-储蓄的权衡：\n    $$ \\dfrac{1}{c_{t}} = \\beta \\, \\mathbb{E}_{t} \\left[ \\dfrac{1}{c_{t+1}} \\left( \\alpha \\exp(z_{t+1}) k_{t+1}^{\\alpha-1} + 1 - \\delta \\right) \\right] $$\n2.  资源约束，确保市场出清：\n    $$ c_{t} + k_{t+1} = (1-\\delta) k_{t} + \\exp(z_{t}) k_{t}^{\\alpha} $$\n\n这两个方程构成一个非线性随机差分方程组。为使用扰动法求解该系统，我们首先将其表示为一个残差函数向量 $f$，该向量在均衡时必须等于零。令状态向量划分为预定变量 $x_t = k_t$、非预定（跳跃）变量 $y_t = c_t$ 和外生冲击 $z_t$。该系统可以抽象地写为：\n$$ \\mathbb{E}_t [f(x_{t+1}, y_{t+1}, x_t, y_t, z_{t+1}, z_t)] = 0 $$\n具体来说，$f$ 的两个分量是：\n$$ f_1 = \\dfrac{1}{y_{t}} - \\beta \\dfrac{1}{y_{t+1}} \\left( \\alpha \\exp(z_{t+1}) x_{t+1}^{\\alpha-1} + 1 - \\delta \\right) $$\n$$ f_2 = y_{t} + x_{t+1} - (1-\\delta)x_{t} - \\exp(z_{t}) x_{t}^{\\alpha} $$\n注意，期望算子在稍后阶段处理。\n\n一阶扰动通过在指定的展开点 $(\\bar{x}, \\bar{y}, \\bar{z})$ 附近对该系统进行一阶泰勒级数展开来近似解。一个关键的细节是，扰动理论的正确应用要求此展开点是一个稳态，即当 $\\bar{z}=0$ 时，该点满足 $f(\\bar{x}, \\bar{y}, \\bar{x}, \\bar{y}, \\bar{z}, \\bar{z}) = 0$。该问题指示我们“朴素地”进行处理，即忽略当此条件不满足时产生的常数项。因此，线性化系统近似为：\n$$ F_{x^{+}} \\hat{x}_{t+1} + F_{y^{+}} \\mathbb{E}_{t} \\hat{y}_{t+1} + F_{x} \\hat{x}_{t} + F_{y} \\hat{y}_{t} + F_{z^{+}} \\mathbb{E}_{t} \\hat{z}_{t+1} + F_{z} \\hat{z}_{t} = 0 $$\n其中 $\\hat{v} = v - \\bar{v}$ 表示对展开点的偏离，矩阵 $F_{v}$ 是 $f$ 相对于变量 $v$ 在展开点处求值的雅可比矩阵。根据问题要求，这些雅可比矩阵使用中心有限差分格式进行数值计算。\n\n冲击过程 $z_{t+1} = \\rho z_t + \\sigma \\varepsilon_{t+1}$ 的自回归性质意味着 $\\mathbb{E}_t[\\hat{z}_{t+1}] = \\rho \\hat{z}_t$。代入此式可将冲击项合并为一项：\n$$ F_{x^{+}} \\hat{x}_{t+1} + F_{y^{+}} \\mathbb{E}_{t} \\hat{y}_{t+1} + F_{x} \\hat{x}_{t} + F_{y} \\hat{y}_{t} + (F_{z} + F_{z^{+}}\\rho) \\hat{z}_{t} = 0 $$\n\n$\\mathbb{E}_{t} \\hat{y}_{t+1}$ 项是内生且未知的。为求解该系统，我们假设离差具有线性政策函数：\n$$ \\hat{x}_{t+1} = p \\hat{x}_{t} + q \\hat{z}_{t} $$\n$$ \\hat{y}_{t} = r \\hat{x}_{t} + s \\hat{z}_{t} $$\n这意味着未来跳跃变量的期望遵循以下规则：\n$$ \\mathbb{E}_{t} \\hat{y}_{t+1} = \\mathbb{E}_{t} [r \\hat{x}_{t+1} + s \\hat{z}_{t+1}] = r \\hat{x}_{t+1} + s (\\rho \\hat{z}_t) = r(p \\hat{x}_{t} + q \\hat{z}_{t}) + s \\rho \\hat{z}_t $$\n\n将这些政策规则代入线性化系统，并按独立状态变量 $\\hat{x}_t$ 和 $\\hat{z}_t$ 对各项进行分组，得到两个条件，因为该方程必须对任何状态实现都成立：\n1.  $\\hat{x}_t$ 的系数：$F_{x^{+}}p + F_{y^{+}}rp + F_x + F_y r = 0$\n2.  $\\hat{z}_t$ 的系数：$F_{x^{+}}q + F_{y^{+}}(rq + s\\rho) + F_y s + (F_z + F_{z^{+}}\\rho) = 0$\n\n第一个是由两个方程组成的方程组，由于乘积项 $rp$ 的存在，它对于两个未知数 $(p,r)$ 是非线性的。它必须通过数值方法求解，例如使用鲁棒的求根算法。第二个是关于 $(q,s)$ 的线性系统，一旦 $(p,r)$ 已知，便可直接求解。\n\n一旦确定了政策函数系数 $(p,q,r,s)$，我们就可以评估所得“解”的性质。数值求解器未能找到有限实数解是病态的第一个指标。如果找到解，我们根据三个标准对其进行评估：\n1.  **稳定性**：一个稳定的动态系统要求内生状态变量不会因暂时性冲击而发散。对于本模型，这对应于条件 $|\\,p\\,| < 1$。\n2.  **符号一致性**：标准经济学理论表明，正的生产率冲击（$\\Delta z_0 > 0$）应导致消费增加，即 $y_0 \\ge 0$。初始响应为 $\\hat{y}_0 = r \\hat{x}_0 + s \\hat{z}_0 = s \\sigma$。鉴于 $\\sigma>0$，这简化为检查 $s \\ge 0$ 是否成立。\n3.  **发散**：这是一个复合标志。如果求解器失败、稳定性条件 $|\\,p\\,| \\ge 1$ 满足，或者模拟的脉冲响应函数（IRF）显示出发散行为，则该标志被触发。发散行为通过比较模拟期界末端状态向量的范数与期初范数的比值来定量测量。\n\n该实现将把这整个过程应用于三个不同的展开点：正确的稳态（情况 A）、一个不正确但资源一致的点（情况 B），以及一个违反所有稳态条件的不正确的点（情况 C）。这将定量地证明，只有围绕真实稳态的线性化才能产生一个一致的动态系统。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef process_case(expansion_point, params):\n    \"\"\"\n    Computes Jacobians, solves for policy functions, and evaluates pathologies for a given expansion point.\n    \"\"\"\n    # Unpack parameters\n    beta, alpha, delta, rho, sigma, T = params\n    k_bar, c_bar, z_bar = expansion_point\n\n    # Ensure expansion point itself is valid for calculation (c>0)\n    if c_bar <= 0:\n        # Cannot proceed, mark as total failure\n        return 0, 0, 1\n\n    # 1. Define the residual functions for the two equilibrium conditions\n    def f_residuals(xp, yp, x, y, zp, z):\n        # xp=k_{t+1}, yp=c_{t+1}, x=k_t, y=c_t, zp=z_{t+1}, z=z_t\n        if yp <= 0:\n            return np.array([1e12, 1e12]) # Return large penalty if consumption is non-positive\n        \n        # Euler equation residual\n        f1 = 1.0 / y - beta / yp * (alpha * np.exp(zp) * xp**(alpha - 1) + 1.0 - delta)\n        # Resource constraint residual\n        f2 = y + xp - (1.0 - delta) * x - np.exp(z) * x**alpha\n        return np.array([f1, f2])\n\n    # 2. Compute Jacobians numerically via central finite differences\n    def compute_jacobians(eval_point):\n        k_eval, c_eval, z_eval = eval_point\n        vars_base = [k_eval, c_eval, k_eval, c_eval, z_eval, z_eval]\n        jacobians = {}\n        var_names = ['xp', 'yp', 'x', 'y', 'zp', 'z']\n        \n        for i, name in enumerate(var_names):\n            # Scaled step size to handle variables of different magnitudes\n            h = 1e-6 * np.abs(vars_base[i]) + 1e-8\n            \n            vars_plus = list(vars_base)\n            vars_plus[i] += h\n            f_plus = f_residuals(*vars_plus)\n\n            vars_minus = list(vars_base)\n            vars_minus[i] -= h\n            f_minus = f_residuals(*vars_minus)\n            \n            jacobians[name] = (f_plus - f_minus) / (2.0 * h)\n            \n        return (jacobians['xp'], jacobians['yp'], jacobians['x'],\n                jacobians['y'], jacobians['zp'], jacobians['z'])\n\n    f_xp, f_yp, f_x, f_y, f_zp, f_z = compute_jacobians(expansion_point)\n\n    # 3. Solve for policy function coefficients (p, r, q, s)\n    p, q, r, s = None, None, None, None\n    solver_success = False\n    \n    # Define the nonlinear system for (p, r)\n    def pol_sys_pr(pr_vec):\n        p_val, r_val = pr_vec\n        # Eq1: Coefficient on x_t from Euler residual must be zero\n        eq1 = f_xp[0] * p_val + f_yp[0] * r_val * p_val + f_x[0] + f_y[0] * r_val\n        # Eq2: Coefficient on x_t from Resource residual must be zero\n        eq2 = f_xp[1] * p_val + f_yp[1] * r_val * p_val + f_x[1] + f_y[1] * r_val\n        return [eq1, eq2]\n    \n    # Solve for (p,r) using a numerical root finder\n    initial_guess_pr = [0.95, 0.5]\n    sol_pr = root(pol_sys_pr, initial_guess_pr, method='hybr', options={'xtol': 1e-9})\n    \n    if sol_pr.success and np.all(np.isfinite(sol_pr.x)):\n        p, r = sol_pr.x\n        \n        # Once (p,r) are found, solve the linear system for (q,s)\n        Fz_eff = f_z + f_zp * rho\n        \n        A = np.zeros((2, 2))\n        A[:, 0] = f_xp + f_yp * r      # Coefficient on q\n        A[:, 1] = f_y + f_yp * rho    # Coefficient on s\n        \n        b = -Fz_eff\n        \n        try:\n            # Check if matrix A is singular\n            if np.linalg.det(A) == 0:\n                solver_success = False\n            else:\n                q, s = np.linalg.solve(A, b)\n                if np.all(np.isfinite([q, s])):\n                    solver_success = True\n        except np.linalg.LinAlgError:\n            solver_success = False\n\n    # 4. Diagnose pathologies and compute flags\n    divergence_flag = 0\n    if not solver_success:\n        divergence_flag = 1\n        stability_flag = 0\n        sign_consistency_flag = 0\n        return stability_flag, sign_consistency_flag, divergence_flag\n\n    stability_flag = 1 if np.abs(p) < 1.0 else 0\n    sign_consistency_flag = 1 if s >= 0.0 else 0\n    \n    if np.abs(p) >= 1.0:\n        divergence_flag = 1\n\n    # Simulate IRF to check for long-term divergence only if not already flagged\n    if divergence_flag == 0:\n        x_irf = np.zeros(T)\n        y_irf = np.zeros(T)\n        z_irf = np.zeros(T)\n        \n        z_irf[0] = sigma\n        # x_irf[0] is 0 by problem specification\n\n        for t in range(T - 1):\n            y_irf[t] = r * x_irf[t] + s * z_irf[t]\n            x_irf[t+1] = p * x_irf[t] + q * z_irf[t]\n            z_irf[t+1] = rho * z_irf[t]\n        y_irf[T-1] = r * x_irf[T-1] + s * z_irf[T-1]\n\n        norms = np.sqrt(x_irf**2 + y_irf**2)\n        \n        max_early = np.max(norms[0:5])\n        max_late = np.max(norms[T-5:T])\n        \n        # If initial impact is virtually zero, system is stable, so avoid division by zero\n        if max_early > 1e-12:\n            if max_late / max_early > 100.0:\n                divergence_flag = 1\n    \n    return stability_flag, sign_consistency_flag, divergence_flag\n\n\ndef solve():\n    # Structural parameters of the RBC model\n    beta = 0.96\n    alpha = 0.36\n    delta = 0.08\n    rho = 0.90\n    sigma = 0.01\n    T = 40\n    params = (beta, alpha, delta, rho, sigma, T)\n\n    # Calculate the correct steady state (for Case A and as a reference)\n    k_bar = (alpha / (1.0/beta - 1.0 + delta))**(1.0 / (1.0 - alpha))\n    c_bar = k_bar**alpha - delta * k_bar\n    z_bar = 0.0\n    \n    # Define the three test cases as expansion points (k, c, z)\n    test_cases = [\n        # Case A: Correct expansion point\n        (k_bar, c_bar, z_bar),\n        # Case B: Incorrect but resource-consistent point\n        (0.5 * k_bar, (0.5 * k_bar)**alpha - delta * (0.5 * k_bar), z_bar),\n        # Case C: Incorrect and resource-inconsistent point\n        (5.0 * k_bar, 0.2 * c_bar, z_bar)\n    ]\n\n    all_results = []\n    for expansion_point in test_cases:\n        flags = process_case(expansion_point, params)\n        all_results.extend(flags)\n        \n    # Format and print the final output as a single-line list\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"}, {"introduction": "当我们从线性近似转向更高阶的解时，二阶解的实施带来了新的挑战。本练习揭示了一个关键问题：对资本 $k_t$ 的二阶策略函数进行直接模拟可能导致人为的不稳定性，因为它未能遵守近似的阶数。你将实现并比较一个直接模拟和一个“剪枝”（pruning）或“阶数一致”（order-consistent）的模拟，从而掌握一项确保高阶解的稳定性和准确性的重要技术。[@problem_id:2418999]", "id": "2418999", "problem": "考虑一个关于资本对其非随机稳态的偏离（记为 $k_t$）的单变量二阶扰动策略函数。在稳态附近的二阶近似形式如下\n$$\nk_{t+1} \\;=\\; h\\,k_t \\;+\\; r\\,\\sigma\\,\\varepsilon_{t+1} \\;+\\; \\tfrac{1}{2}H\\,k_t^2 \\;+\\; \\tfrac{1}{2}M\\,(\\sigma\\,\\varepsilon_{t+1})^2 \\;+\\; N\\,k_t\\,(\\sigma\\,\\varepsilon_{t+1}),\n$$\n其中 $h$、$r$、$H$、$M$ 和 $N$ 是实值系数，$\\sigma \\ge 0$ 是冲击规模，$\\varepsilon_{t}$ 是独立同分布的标准正态冲击，满足 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$。\n\n在长度为 $T$ 的有限期界内，使用初始条件 $k_0 = 0$ 实现两种模拟方法：\n\n1. 对近似式进行直接迭代：\n$$\n\\text{for } t = 0,1,\\dots,T-1:\\quad k_{t+1}^{\\text{dir}} \\;=\\; h\\,k_t^{\\text{dir}} \\;+\\; r\\,\\sigma\\,\\varepsilon_{t+1} \\;+\\; \\tfrac{1}{2}H\\,(k_t^{\\text{dir}})^2 \\;+\\; \\tfrac{1}{2}M\\,(\\sigma\\,\\varepsilon_{t+1})^2 \\;+\\; N\\,k_t^{\\text{dir}}\\,(\\sigma\\,\\varepsilon_{t+1}).\n$$\n\n2. 阶数一致性模拟，通过分离一阶和二阶分量来强制截断至二阶：\n$$\nz_{t+1} \\;=\\; h\\,z_t \\;+\\; r\\,\\sigma\\,\\varepsilon_{t+1},\n$$\n$$\nw_{t+1} \\;=\\; H\\,z_t^2 \\;+\\; M\\,(\\sigma\\,\\varepsilon_{t+1})^2 \\;+\\; 2\\,N\\,z_t\\,(\\sigma\\,\\varepsilon_{t+1}),\n$$\n$$\nk_{t+1}^{\\text{oc}} \\;=\\; z_{t+1} \\;+\\; \\tfrac{1}{2}w_{t+1},\n$$\n其中 $z_0 = 0$ 且 $w_0 = 0$。\n\n为保证数值可复现性，使用固定的随机种子 $s = 2025$ 生成序列 $\\{\\varepsilon_t\\}_{t=1}^T$，并使 $\\varepsilon_t$ 为来自标准正态分布的独立同分布抽样。定义一个数值界限 $B = 10^6$。如果一条模拟路径 $\\{k_t\\}_{t=0}^T$ 在任何时候达到了非有限值（非数值或无穷大），或者 $\\max_{0 \\le t \\le T} |k_t| > B$，则称其为“发散的”；否则称其为“有界的”。\n\n您的任务是编写一个程序，对下方测试套件中的每一组参数，为两种模拟生成相同的冲击序列，并判断是否直接迭代产生了发散路径而阶数一致性模拟保持有界。对于每组参数 $i$，当且仅当直接迭代发散且阶数一致性模拟保持有界时，输出整数 $1$；否则输出整数 $0$。\n\n测试套件（每行列出 $(h,r,H,M,N,\\sigma,T)$）：\n- A例（旨在暴露直接迭代下发散性的一般情况）：$(0.95,\\,0.8,\\,1.2,\\,0.8,\\,0.6,\\,0.6,\\,20000)$\n- B例（无随机性的边界情况）：$(0.95,\\,0.8,\\,1.2,\\,0.8,\\,0.6,\\,0.0,\\,1000)$\n- C例（具有弱非线性的近线性情况）：$(0.90,\\,0.3,\\,0.05,\\,0.02,\\,0.01,\\,0.2,\\,5000)$\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的整数结果列表。例如，包含三个案例的输出必须形如“[x1,x2,x3]”，其中 $x_i \\in \\{0,1\\}$。", "solution": "问题陈述已经过验证，被认定为有效。它在计算经济学领域具有科学依据，特别是关于动态随机模型的扰动方法的数值实现。该问题是良构的，提供了所有必要的方程、参数、初始条件以及一个清晰、客观的评估标准。它没有歧义、矛盾和事实错误。因此，我们可以着手提供解决方案。\n\n这个问题的核心在于模拟一个源自二阶泰勒近似的动态系统时，两种方法之间的区别。这些方法之间的差异并非无足轻重；它关系到模拟的数值稳定性和理论一致性。严谨的分析揭示了为何一种方法可能失败而另一种方法能够成功。\n\n代表资本对其稳态偏离的状态变量 $k_t$ 的模型由以下二阶近似给出：\n$$\nk_{t+1} = h\\,k_t + r\\,\\sigma\\,\\varepsilon_{t+1} + \\frac{1}{2}H\\,k_t^2 + \\frac{1}{2}M\\,(\\sigma\\,\\varepsilon_{t+1})^2 + N\\,k_t\\,(\\sigma\\,\\varepsilon_{t+1})\n$$\n其中 $k_0 = 0$ 且 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$。\n\n第一种模拟方法，称为“直接迭代法”，通过递归实现该方程：\n$$\nk_{t+1}^{\\text{dir}} = h\\,k_t^{\\text{dir}} + r\\,\\sigma\\,\\varepsilon_{t+1} + \\frac{1}{2}H\\,(k_t^{\\text{dir}})^2 + \\frac{1}{2}M\\,(\\sigma\\,\\varepsilon_{t+1})^2 + N\\,k_t^{\\text{dir}}\\,(\\sigma\\,\\varepsilon_{t+1})\n$$\n这种方法看似直接，但包含一个根本性缺陷。最初的近似是一个在二阶截断的泰勒级数。这意味着任何三阶或更高阶的项都已被舍弃。在直接迭代中，状态变量 $k_t^{\\text{dir}}$ 本身包含了从前期累积而来的一阶和二阶项。当这个变量在项 $\\frac{1}{2}H\\,(k_t^{\\text{dir}})^2$ 中被平方时，会产生虚假的三阶和四阶项，并被反馈回系统中。例如，如果从概念上将 $k_t^{\\text{dir}}$ 分解为其一阶分量 $k_t^{(1)}$ 和二阶分量 $k_t^{(2)}$，那么 $(k_t^{\\text{dir}})^2 = (k_t^{(1)} + k_t^{(2)})^2 = (k_t^{(1)})^2 + 2k_t^{(1)}k_t^{(2)} + (k_t^{(2)})^2$。项 $2k_t^{(1)}k_t^{(2)}$ 是三阶的，而 $(k_t^{(2)})^2$ 是四阶的。这些项与原始近似不一致，并且会累积起来，导致爆发性的、非平稳的行为，这是模拟方法造成的假象，而非模型的内在属性。当持续性参数 $h$ 接近 $1$ 且二次反馈系数 $H$ 较大时，这种不稳定性尤为显著。\n\n第二种方法，即“阶数一致性模拟”或“剪枝模拟”，被明确设计用以防止这种由高阶项引起的污染。它在每一步都保持了二阶近似的完整性。这是通过分离解的一阶和二阶分量的演化过程来实现的。\n一阶分量 $z_t$ 遵循模型的线性部分：\n$$\nz_{t+1} = h\\,z_t + r\\,\\sigma\\,\\varepsilon_{t+1}\n$$\n二阶修正项 $w_{t+1}$ 仅使用非线性项中的一阶状态 $z_t$ 来计算：\n$$\nw_{t+1} = H\\,z_t^2 + M\\,(\\sigma\\,\\varepsilon_{t+1})^2 + 2\\,N\\,z_t\\,(\\sigma\\,\\varepsilon_{t+1})\n$$\n然后，完整的二阶状态被组合而成：\n$$\nk_{t+1}^{\\text{oc}} = z_{t+1} + \\frac{1}{2}w_{t+1}\n$$\n根据其构造，该过程确保了任何高于二阶的项都不会被引入到 $k_t^{\\text{oc}}$ 的动态过程中。只要原始动态系统是局部稳定的，该模拟路径就能与底层的泰勒近似保持一致，从而提供一个稳定且理论上正确的轨迹。\n\n任务是针对给定的一组参数 $(h, r, H, M, N, \\sigma, T)$，实施这两种模拟方案，并使用固定的随机种子 $s = 2025$ 为两种模拟生成相同的冲击序列 $\\{\\varepsilon_t\\}_{t=1}^T$。如果一条路径变为非有限值或其绝对值超过界限 $B = 10^6$，则该路径是“发散的”。我们必须识别出直接迭代发散而阶数一致性模拟保持有界的情况。\n\n算法流程如下：\n$1$. 使用指定的种子 $s = 2025$ 初始化随机数生成器。\n$2$. 对于测试套件中提供的每一组参数：\n    a. 提取参数 $h, r, H, M, N, \\sigma$ 和期界 $T$。\n    b. 生成一个长度为 $T$ 的标准正态随机冲击序列。该序列将用于两种模拟，以确保公平比较。\n    c. 执行直接迭代模拟。初始化 $k_0^{\\text{dir}} = 0.0$。对于从 $0$ 到 $T-1$ 的每个时间步 $t$，计算 $k_{t+1}^{\\text{dir}}$。每次计算后，检查 `not isfinite`$(k_{t+1}^{\\text{dir}})$ 是否为真或 $|k_{t+1}^{\\text{dir}}| > B$ 是否成立。如果满足条件，则将此路径标记为发散，并终止该方法的模拟。\n    d. 执行阶数一致性模拟。初始化 $z_0 = 0.0$。对于从 $0$ 到 $T-1$ 的每个时间步 $t$，计算 $z_{t+1}$、$w_{t+1}$，并随后计算 $k_{t+1}^{\\text{oc}}$。使用与上述相同的标准检查是否发散。如果发生发散，则将此路径标记为发散并终止。\n    e. 在两种模拟都完成后，评估条件：直接迭代路径是否被标记为发散“且”阶数一致性路径“未”被标记为发散？如果为真，则此测试案例的结果为 $1$。否则，结果为 $0$。\n$3$. 收集所有测试案例的结果，并将它们格式化为指定的输出字符串。\n此过程将正确诊断出朴素直接迭代法中固有的数值不稳定性，以及阶数一致性方法的稳健性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating two different perturbation methods and comparing their stability.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (h, r, H, M, N, sigma, T)\n    test_cases = [\n        (0.95, 0.8, 1.2, 0.8, 0.6, 0.6, 20000),  # Case A\n        (0.95, 0.8, 1.2, 0.8, 0.6, 0.0, 1000),   # Case B\n        (0.90, 0.3, 0.05, 0.02, 0.01, 0.2, 5000),  # Case C\n    ]\n\n    # Parameters for simulation.\n    seed = 2025\n    bound = 1e6\n\n    # Initialize the random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    results = []\n\n    for h, r, H, M, N, sigma, T in test_cases:\n        # Generate the same shock sequence for both simulations for a fair comparison.\n        shocks = rng.standard_normal(T)\n        \n        # --- Simulation 1: Direct Iteration ---\n        direct_diverged = False\n        k_dir = 0.0\n        for t in range(T):\n            eps = shocks[t]\n            sigma_eps = sigma * eps\n            \n            # Direct iteration formula\n            k_dir_next = (h * k_dir + r * sigma_eps +\n                          0.5 * H * k_dir**2 +\n                          0.5 * M * sigma_eps**2 +\n                          N * k_dir * sigma_eps)\n\n            # Check for divergence\n            if not np.isfinite(k_dir_next) or abs(k_dir_next) > bound:\n                direct_diverged = True\n                break\n            \n            k_dir = k_dir_next\n\n        # --- Simulation 2: Order-Consistent Iteration ---\n        oc_diverged = False\n        z = 0.0\n        for t in range(T):\n            eps = shocks[t]\n            sigma_eps = sigma * eps\n            \n            # First-order component\n            z_next = h * z + r * sigma_eps\n            \n            # Second-order correction\n            w_next = H * z**2 + M * sigma_eps**2 + 2 * N * z * sigma_eps\n            \n            # Assembled state\n            k_oc_next = z_next + 0.5 * w_next\n            \n            # Check for divergence\n            if not np.isfinite(k_oc_next) or abs(k_oc_next) > bound:\n                oc_diverged = True\n                break\n            \n            z = z_next\n            \n        # --- Evaluate the condition ---\n        # Output 1 if direct diverges and order-consistent remains bounded; otherwise 0.\n        if direct_diverged and not oc_diverged:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"}]}