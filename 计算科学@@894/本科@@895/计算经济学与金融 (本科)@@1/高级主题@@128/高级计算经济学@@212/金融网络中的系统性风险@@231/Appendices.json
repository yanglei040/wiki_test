{"hands_on_practices": [{"introduction": "这项练习旨在介绍量化系统性风险这一关键概念。我们通常从单个机构的角度考虑风险，但金融网络结构本身也是一个主要风险来源。本练习要求你构建一个“金融脆弱性”指数，该指数是一个综合性指标，它将银行的财务健康状况（杠杆率 $L_i$）与网络的拓扑属性（聚类系数 $C$）结合起来 [@problem_id:2435773]。通过计算该指数，你将亲身体验如何将节点层面的数据与网络层面的结构融合，从而得出一个用于评估系统脆弱性的、有意义的单一指标。", "id": "2435773", "problem": "一个金融系统由一个包含 $5$ 家银行（标记为 $A,B,C,D,E$）的无向网络表示，其中两家银行之间的无向边表示存在双边风险暴露关系。其边集为 $\\{AB,AC,BC,BD,CD,DE\\}$。每家银行 $i$ 的总资产 $A_i$ 和权益 $E_i$ 如下：\n- 银行 $A$：$A_A=100$， $E_A=10$。\n- 银行 $B$：$A_B=150$， $E_B=12.5$。\n- 银行 $C$：$A_C=120$， $E_C=15$。\n- 银行 $D$：$A_D=80$， $E_D=8$。\n- 银行 $E$：$A_E=50$， $E_E=10$。\n\n定义以下基本要素：\n1. 一个无向简单图的全局聚类系数 $C$（传递性）定义为 $C = \\dfrac{3 T}{W}$，其中 $T$ 是图中三角形的数量，$W$ 是连通三元组的数量。连通三元组是指一个无序的、由三个不同顶点构成的组合，其中至少有两条边共享一个公共顶点。\n2. 银行 $i$ 的节点杠杆率为 $L_i = \\dfrac{A_i}{E_i}$。总杠杆率是资产加权平均杠杆率\n$$\n\\bar{L} = \\sum_{i \\in \\{A,B,C,D,E\\}} \\omega_i L_i, \\quad \\text{其中 } \\omega_i = \\dfrac{A_i}{\\sum_{j \\in \\{A,B,C,D,E\\}} A_j}。\n$$\n\n一个“金融脆弱性”指数 $B$ 将通过结合拓扑结构和杠杆率，并遵循以下校准协议来构建。首先，定义线性归一化指标\n$$\nx_C = \\dfrac{C - C_{\\mathrm{S}}}{C_{\\mathrm{R}} - C_{\\mathrm{S}}}, \\qquad x_L = \\dfrac{\\bar{L} - \\bar{L}_{\\mathrm{S}}}{\\bar{L}_{\\mathrm{R}} - \\bar{L}_{\\mathrm{S}}},\n$$\n这两个指标是相对于两个锚定状态进行归一化的：“安全”锚点 $(C_{\\mathrm{S}}, \\bar{L}_{\\mathrm{S}}) = (0, 5)$ 和“风险”锚点 $(C_{\\mathrm{R}}, \\bar{L}_{\\mathrm{R}}) = (0.6, 15)$。\n\n设\n$$\nB = \\gamma + \\lambda \\big( w x_L + (1-w) x_C \\big),\n$$\n其中杠杆率的权重是聚类系数的两倍，因此 $w = \\dfrac{2}{3}$。常数 $\\gamma$ 和 $\\lambda$ 由校准条件决定，即在安全锚点处 $B=0.2$，在风险锚点处 $B=0.8$。\n\n请使用这些定义和校准方法，计算给定网络的脆弱性指数 $B$。将最终结果四舍五入至四位有效数字。答案以纯数字形式表示，不带单位。", "solution": "该问题定义明确、内容自洽，并与网络科学和金融建模的原理一致。所有必要的数据和定义均已提供，可以得出一个唯一的解。因此，我将开始系统地计算金融脆弱性指数 $B$。\n\n计算过程分为五个连续的步骤：(1) 计算网络的全局聚类系数 $C$；(2) 计算系统的总杠杆率 $\\bar{L}$；(3) 对这两个指标进行归一化；(4) 校准脆弱性指数公式；(5) 计算 $B$ 的最终值。\n\n首先，我们分析网络拓扑结构，以求得全局聚类系数 $C = \\frac{3T}{W}$。网络由 $N=5$ 个顶点（银行）$\\{A, B, C, D, E\\}$ 和边集 $\\{AB, AC, BC, BD, CD, DE\\}$ 组成。\n$T$ 是三角形的数量（即3个顶点的完全子图）。通过检查边集：\n-   顶点集 $\\{A, B, C\\}$ 构成一个三角形，因为边 $AB$, $AC$, $BC$ 都存在。\n-   顶点集 $\\{B, C, D\\}$ 构成一个三角形，因为边 $BC$, $BD$, $CD$ 都存在。\n其他任何三个顶点的组合都不能构成三角形。因此，三角形的数量为 $T=2$。\n\n$W$ 是连通三元组的数量，即长度为2的路径的数量。以顶点 $v$ 为中心的此类路径数量由 $\\binom{d(v)}{2}$ 给出，其中 $d(v)$ 是顶点 $v$ 的度。我们首先计算所有顶点的度：\n-   $d(A) = 2$ (连接到 $B, C$)\n-   $d(B) = 3$ (连接到 $A, C, D$)\n-   $d(C) = 3$ (连接到 $A, B, D$)\n-   $d(D) = 3$ (连接到 $B, C, E$)\n-   $d(E) = 1$ (连接到 $D$)\n连通三元组的总数是对所有顶点求和的结果：\n$$W = \\sum_{i \\in \\{A,B,C,D,E\\}} \\binom{d(i)}{2} = \\binom{2}{2} + \\binom{3}{2} + \\binom{3}{2} + \\binom{3}{2} + \\binom{1}{2}$$\n$$W = 1 + 3 + 3 + 3 + 0 = 10$$\n现在，我们可以计算全局聚类系数：\n$$C = \\frac{3T}{W} = \\frac{3 \\times 2}{10} = \\frac{6}{10} = 0.6$$\n\n第二步，我们计算总杠杆率 $\\bar{L}$。首先，我们计算每家银行的杠杆率 $L_i = \\frac{A_i}{E_i}$：\n-   $L_A = \\frac{A_A}{E_A} = \\frac{100}{10} = 10$\n-   $L_B = \\frac{A_B}{E_B} = \\frac{150}{12.5} = 12$\n-   $L_C = \\frac{A_C}{E_C} = \\frac{120}{15} = 8$\n-   $L_D = \\frac{A_D}{E_D} = \\frac{80}{8} = 10$\n-   $L_E = \\frac{A_E}{E_E} = \\frac{50}{10} = 5$\n接下来，我们确定资产加权平均值。系统中的总资产为：\n$$\\sum_{j} A_j = A_A + A_B + A_C + A_D + A_E = 100 + 150 + 120 + 80 + 50 = 500$$\n权重 $\\omega_i = \\frac{A_i}{\\sum_j A_j}$ 为：\n-   $\\omega_A = \\frac{100}{500} = 0.2$\n-   $\\omega_B = \\frac{150}{500} = 0.3$\n-   $\\omega_C = \\frac{120}{500} = 0.24$\n-   $\\omega_D = \\frac{80}{500} = 0.16$\n-   $\\omega_E = \\frac{50}{500} = 0.1$\n总杠杆率 $\\bar{L}$ 是加权和：\n$$\\bar{L} = \\sum_{i} \\omega_i L_i = (0.2)(10) + (0.3)(12) + (0.24)(8) + (0.16)(10) + (0.1)(5)$$\n$$\\bar{L} = 2.0 + 3.6 + 1.92 + 1.6 + 0.5 = 9.62$$\n\n第三步，我们使用给定的锚定状态——“安全”锚点 $(C_{\\mathrm{S}}, \\bar{L}_{\\mathrm{S}}) = (0, 5)$ 和“风险”锚点 $(C_{\\mathrm{R}}, \\bar{L}_{\\mathrm{R}}) = (0.6, 15)$，对计算出的值 $C$ 和 $\\bar{L}$ 进行归一化。\n归一化的聚类指标为：\n$$x_C = \\frac{C - C_{\\mathrm{S}}}{C_{\\mathrm{R}} - C_{\\mathrm{S}}} = \\frac{0.6 - 0}{0.6 - 0} = 1$$\n归一化的杠杆率指标为：\n$$x_L = \\frac{\\bar{L} - \\bar{L}_{\\mathrm{S}}}{\\bar{L}_{\\mathrm{R}} - \\bar{L}_{\\mathrm{S}}} = \\frac{9.62 - 5}{15 - 5} = \\frac{4.62}{10} = 0.462$$\n\n第四步，我们使用边界条件来校准脆弱性指数 $B = \\gamma + \\lambda(w x_L + (1-w) x_C)$。\n在安全锚点处，$(x_C, x_L)=(0,0)$ 且 $B=0.2$。代入这些值可得：\n$$0.2 = \\gamma + \\lambda(w \\cdot 0 + (1-w) \\cdot 0) \\implies \\gamma = 0.2$$\n在风险锚点处，$(x_C, x_L)=(1,1)$ 且 $B=0.8$。代入这些值可得：\n$$0.8 = \\gamma + \\lambda(w \\cdot 1 + (1-w) \\cdot 1) = \\gamma + \\lambda$$\n使用 $\\gamma = 0.2$，我们求解 $\\lambda$:\n$$0.8 = 0.2 + \\lambda \\implies \\lambda = 0.6$$\n校准后的脆弱性指数公式为 $B = 0.2 + 0.6(w x_L + (1-w) x_C)$。\n\n第五步，我们计算给定网络的 $B$ 的最终值。我们使用计算出的归一化值 $x_C=1$ 和 $x_L=0.462$，以及指定的权重 $w = \\frac{2}{3}$。\n$$B = 0.2 + 0.6 \\left( \\left(\\frac{2}{3}\\right) x_L + \\left(1-\\frac{2}{3}\\right) x_C \\right)$$\n$$B = 0.2 + 0.6 \\left( \\left(\\frac{2}{3}\\right)(0.462) + \\left(\\frac{1}{3}\\right)(1) \\right)$$\n$$B = 0.2 + 0.6 \\left( \\frac{2 \\times 0.462 + 1}{3} \\right)$$\n$$B = 0.2 + 0.2 (0.924 + 1)$$\n$$B = 0.2 + 0.2 (1.924)$$\n$$B = 0.2 + 0.3848 = 0.5848$$\n问题要求结果四舍五入到四位有效数字。计算值 $0.5848$ 已有四位有效数字。", "answer": "$$\n\\boxed{0.5848}\n$$"}, {"introduction": "本练习将从静态测量转向动态分析，模拟金融困境如何在网络中蔓延。我们将探讨“监管套利”这一概念，即银行将业务转移到监管较少的“影子银行”部门以规避监管。在这个动手编程练习中，你将为一个违约级联过程建模，并亲眼见证，当负债在更脆弱的影子银行层中所占比例增加时，一个微小的初始冲击如何被急剧放大，将一个局部问题演变成一场全面的系统性危机 [@problem_id:2435816]。", "id": "2435816", "problem": "给定一个程式化的银行间网络，该网络有两个债务层，分别代表受监管层和影子（不受监管）层。银行可以将其一部分银行间总债务通过影子层重新路由，而影子层由于违约回收率较低而更为脆弱。该金融系统根据资产负债表恒等式和一个带有违约损失的离散时间违约级联进行确定性演化。\n\n基本基础：\n- 对于每家银行 $i$，权益由会计恒等式定义：$q_i = A_i - P_i$，其中 $A_i$ 是总资产，$P_i$ 是总负债。有限责任意味着当 $q_i < 0$ 时发生违约。\n- 银行间债务由一个负债矩阵 $\\mathbf{L} \\in \\mathbb{R}_+^{N \\times N}$ 表示，其中条目 $L_{ij}$ 表示银行 $i$ 欠银行 $j$ 金额为 $L_{ij}$。对于每家银行 $i$，银行间总负债为 $\\bar{p}_i = \\sum_{j=1}^N L_{ij}$，银行间总资产为 $\\sum_{k=1}^N L_{ki}$。\n- 外部资产 $e_i \\ge 0$ 受到一个外生的、确定性的冲击量 $\\Delta_i \\ge 0$，产生冲击后的外部资产 $e_i - \\Delta_i$。\n- 违约损失率（LGD）以确定性方式建模：当借方违约时，每个贷方就其违约敞口实现一个固定的回收率。受监管层的回收率为 $r_R \\in [0,1]$，影子层的回收率为 $r_S \\in [0,1]$，且 $r_S < r_R$。相应的 LGD 值为 $1 - r_R$ 和 $1 - r_S$。\n\n分层结构与监管套利：\n- 对于给定的转移比例 $s \\in [0,1]$，每笔双边总债务被分解为受监管层中的 $L_{ij}^{(R)} = (1-s) L_{ij}$ 和影子层中的 $L_{ij}^{(S)} = s L_{ij}$。\n- 当银行 $j$ 违约时，任何对 $j$ 有敞口的贷方 $i$ 将确定性地损失\n$$\n\\text{loss}_{i \\leftarrow j}(s) = (1-r_R) L_{j i}^{(R)} + (1-r_S) L_{j i}^{(S)} = \\big( (1-s)(1-r_R) + s(1-r_S) \\big) L_{j i}.\n$$\n定义有效损失乘数\n$$\nm(s) = (1-s)(1-r_R) + s(1-r_S).\n$$\n\n传染机制（离散时间级联）：\n- 第 0 步：计算每家银行 $i$ 的初始冲击后权益，\n$$\nq_i^{(0)} = \\big(e_i - \\Delta_i\\big) + \\sum_{k=1}^N L_{k i} - \\sum_{j=1}^N L_{i j}.\n$$\n任何 $q_i^{(0)} < 0$ 的银行 $i$ 在第 0 步违约。\n- 第 $t \\ge 1$ 步：对于在第 $t-1$ 步新违约的每个借方 $j$，将每个贷方 $i$ 的权益减少 $\\text{loss}_{i \\leftarrow j}(s) = m(s) L_{j i}$。如果此减少导致某个有偿付能力的银行 $i$ 的 $q_i^{(t)} < 0$，则银行 $i$ 成为第 $t$ 步的新违约者。每个借方仅在其首次违约时触发一次损失。迭代直至没有新的违约发生。\n\n您的任务：\n- 针对下述固定的网络和参数值，实现此确定性级联算法。\n- 对于每个测试用例，输出最终违约银行的总数，结果为一个非负整数。\n\n固定的网络和回收率：\n- 银行数量：$N = 3$。\n- 银行间负债矩阵 $\\mathbf{L}$，行代表借方，列代表贷方：\n$$\n\\mathbf{L} =\n\\begin{bmatrix}\n0 & 70 & 0 \\\\\n0 & 0 & 80 \\\\\n30 & 0 & 0\n\\end{bmatrix}.\n$$\n- 外部资产向量：\n$$\n\\mathbf{e} = \\begin{bmatrix} 60 \\\\ 30 \\\\ 5 \\end{bmatrix}.\n$$\n- 受监管层回收率 $r_R = 0.9$，影子层回收率 $r_S = 0.2$。\n\n测试套件：\n每个测试用例指定了转移比例 $s$ 和外部冲击向量 $\\boldsymbol{\\Delta}$。所有的 $s$ 值均为 $[0,1]$ 内的小数，$\\boldsymbol{\\Delta}$ 的所有分量均为非负实数。\n\n- 测试 1：$s = 0.0$，$\\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 2：$s = 0.3$，$\\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 3：$s = 0.5$，$\\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 4：$s = 1.0$，$\\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 5：$s = 0.8$，$\\boldsymbol{\\Delta} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n\n程序要求：\n- 编写一个完整、可运行的程序，使用上述级联机制和固定数据，为每个测试用例计算最终的违约数量。不允许存在随机性。\n- 最终输出格式：您的程序应生成单行输出，包含以方括号括起来、用逗号分隔的结果列表，例如 $[x_1,x_2,\\dots,x_5]$，其中每个 $x_k$是按上述顺序列出的测试 $k$ 的整数违约数量。", "solution": "所提出的问题是计算金融学中一个关于系统性风险在程式化的多层银行间网络中传播的适定（well-posed）练习。所有必要的参数和动态都以足够的清晰度和数学严谨性给出。因此，该问题是成立的，并且可以推导出确定性解。\n\n问题的核心在于追踪在初始冲击和随后的传染效应下银行权益的演变。该系统由 $N$ 家银行、它们的银行间债务以及它们持有的外部资产所定义。金融结构由每家银行 $i$ 的基本资产负债表恒等式决定：\n$$\nq_i = A_i - P_i\n$$\n其中 $q_i$ 是权益，$A_i$ 是总资产，$P_i$ 是总负债。根据有限责任原则，如果一家银行的权益变为负数，即 $q_i < 0$，则该银行被视为违约。\n\n银行 $i$ 的总资产 $A_i$ 由其外部资产 $e_i$ 和其银行间资产 $\\bar{a}_i$（即对其他银行的债权）组成。总负债 $P_i$ 是其银行间负债 $\\bar{p}_i$（即对其他银行的债务）。银行间敞口被编码在负债矩阵 $\\mathbf{L}$ 中，其中 $L_{ij}$ 代表银行 $i$ 欠银行 $j$ 的金额。\n因此，对于每家银行 $i$，我们可以写出：\n- 银行间总负债：$\\bar{p}_i = \\sum_{j=1}^N L_{ij}$\n- 银行间总资产：$\\bar{a}_i = \\sum_{k=1}^N L_{ki}$\n\n因此，银行 $i$ 的初始冲击前权益为：\n$$\nq_{i, \\text{pre-shock}} = e_i + \\bar{a}_i - \\bar{p}_i\n$$\n\n对于给定的 $N=3$ 的网络：\n- 负债矩阵：$\\mathbf{L} = \\begin{bmatrix} 0 & 70 & 0 \\\\ 0 & 0 & 80 \\\\ 30 & 0 & 0 \\end{bmatrix}$\n- 外部资产：$\\mathbf{e} = \\begin{bmatrix} 60 \\\\ 30 \\\\ 5 \\end{bmatrix}$\n\n我们首先通过对 $\\mathbf{L}$ 的行求和来计算银行间总负债向量 $\\bar{\\mathbf{p}}$：\n$$\n\\bar{\\mathbf{p}} = \\begin{bmatrix} 0+70+0 \\\\ 0+0+80 \\\\ 30+0+0 \\end{bmatrix} = \\begin{bmatrix} 70 \\\\ 80 \\\\ 30 \\end{bmatrix}\n$$\n接下来，我们通过对 $\\mathbf{L}$ 的列求和来计算银行间总资产向量 $\\bar{\\mathbf{a}}$：\n$$\n\\bar{\\mathbf{a}} = \\begin{bmatrix} 0+0+30 \\\\ 70+0+0 \\\\ 0+80+0 \\end{bmatrix} = \\begin{bmatrix} 30 \\\\ 70 \\\\ 80 \\end{bmatrix}\n$$\n初始冲击前权益向量 $\\mathbf{q}_{\\text{pre-shock}}$ 为：\n$$\n\\mathbf{q}_{\\text{pre-shock}} = \\mathbf{e} + \\bar{\\mathbf{a}} - \\bar{\\mathbf{p}} = \\begin{bmatrix} 60 \\\\ 30 \\\\ 5 \\end{bmatrix} + \\begin{bmatrix} 30 \\\\ 70 \\\\ 80 \\end{bmatrix} - \\begin{bmatrix} 70 \\\\ 80 \\\\ 30 \\end{bmatrix} = \\begin{bmatrix} 20 \\\\ 20 \\\\ 55 \\end{bmatrix}\n$$\n所有银行初始时都有偿付能力。传染过程始于对外部资产的一个外生冲击 $\\boldsymbol{\\Delta}$。\n\n传染机制关键取决于违约损失率，该损失率由受监管层（$r_R=0.9$）和影子层（$r_S=0.2$）的回收率决定。转移到影子层的债务比例为 $s$。当一家银行违约时，其贷方会产生损失。损失被有效损失乘数 $m(s)$ 放大：\n$$\nm(s) = (1-s)(1-r_R) + s(1-r_S) = (1-s)(1-0.9) + s(1-0.2) = 0.1(1-s) + 0.8s = 0.1 + 0.7s\n$$\n级联以离散时间步进行。\n\n**第 0 步：初始冲击**\n初始冲击后权益向量 $\\mathbf{q}^{(0)}$ 计算如下：\n$$\n\\mathbf{q}^{(0)} = \\mathbf{q}_{\\text{pre-shock}} - \\boldsymbol{\\Delta}\n$$\n任何 $q_i^{(0)} < 0$ 的银行 $i$ 被宣告违约。\n\n**第 $t \\ge 1$ 步：传染**\n如果一组银行 $D_{t-1}$ 在第 $t-1$ 步新违约，那么对于每个未违约的银行 $i$，其权益被更新以反映这些新违约带来的损失：\n$$\nq_i^{(t)} = q_i^{(t-1)} - \\sum_{j \\in D_{t-1}} m(s) L_{ji}\n$$\n任何 $q_i^{(t)}$ 降至零以下的银行 $i$ 成为第 $t$ 步的新违约者。该过程被迭代直至在某一步中没有新的违约发生。\n\n我们现在对每个测试用例进行求解。\n\n**测试用例 1：** $s = 0.0$，$\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(0.0) = 0.1 + 0.7(0.0) = 0.1$。\n- 第 0 步：$\\mathbf{q}^{(0)} = [20, 20, 55]^T - [55, 0, 0]^T = [-35, 20, 55]^T$。银行 1（$q_1^{(0)} = -35 < 0$）违约。违约集合：$\\{1\\}$。\n- 第 1 步：银行 1 欠银行 2 金额为 $L_{12} = 70$。\n  - 银行 2 的损失：$m(0.0) \\times L_{12} = 0.1 \\times 70 = 7$。\n  - 银行 2 的权益：$q_2^{(1)} = q_2^{(0)} - 7 = 20 - 7 = 13$。银行 2 保持偿付能力。\n- 无更多违约。级联终止。\n- 总违约数：$1$。\n\n**测试用例 2：** $s = 0.3$，$\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(0.3) = 0.1 + 0.7(0.3) = 0.1 + 0.21 = 0.31$。\n- 第 0 步：$\\mathbf{q}^{(0)} = [-35, 20, 55]^T$。银行 1 违约。违约集合：$\\{1\\}$。\n- 第 1 步：银行 1 的违约开始传播。\n  - 银行 2 的损失：$m(0.3) \\times L_{12} = 0.31 \\times 70 = 21.7$。\n  - 银行 2 的权益：$q_2^{(1)} = 20 - 21.7 = -1.7$。银行 2（$q_2^{(1)} < 0$）违约。违约集合：$\\{1, 2\\}$。\n- 第 2 步：银行 2 的违约开始传播。银行 2 欠银行 3 金额为 $L_{23} = 80$。\n  - 银行 3 的损失：$m(0.3) \\times L_{23} = 0.31 \\times 80 = 24.8$。\n  - 银行 3 的权益：$q_3^{(2)} = q_3^{(0)} - 24.8 = 55 - 24.8 = 30.2$。银行 3 保持偿付能力。\n- 无更多违约。级联终止。\n- 总违约数：$2$。\n\n**测试用例 3：** $s = 0.5$，$\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(0.5) = 0.1 + 0.7(0.5) = 0.1 + 0.35 = 0.45$。\n- 第 0 步：$\\mathbf{q}^{(0)} = [-35, 20, 55]^T$。银行 1 违约。违约集合：$\\{1\\}$。\n- 第 1 步：银行 1 的违约开始传播。\n  - 银行 2 的损失：$m(0.5) \\times L_{12} = 0.45 \\times 70 = 31.5$。\n  - 银行 2 的权益：$q_2^{(1)} = 20 - 31.5 = -11.5$。银行 2 违约。违约集合：$\\{1, 2\\}$。\n- 第 2 步：银行 2 的违约开始传播。\n  - 银行 3 的损失：$m(0.5) \\times L_{23} = 0.45 \\times 80 = 36$。\n  - 银行 3 的权益：$q_3^{(2)} = 55 - 36 = 19$。银行 3 保持偿付能力。\n- 无更多违约。\n- 总违约数：$2$。\n\n**测试用例 4：** $s = 1.0$，$\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(1.0) = 0.1 + 0.7(1.0) = 0.8$。\n- 第 0 步：$\\mathbf{q}^{(0)} = [-35, 20, 55]^T$。银行 1 违约。违约集合：$\\{1\\}$。\n- 第 1 步：银行 1 违约。\n  - 银行 2 的损失：$m(1.0) \\times L_{12} = 0.8 \\times 70 = 56$。\n  - 银行 2 的权益：$q_2^{(1)} = 20 - 56 = -36$。银行 2 违约。违约集合：$\\{1, 2\\}$。\n- 第 2 步：银行 2 违约。\n  - 银行 3 的损失：$m(1.0) \\times L_{23} = 0.8 \\times 80 = 64$。\n  - 银行 3 的权益：$q_3^{(2)} = 55 - 64 = -9$。银行 3 违约。违约集合：$\\{1, 2, 3\\}$。\n- 第 3 步：银行 3 的违约开始传播。银行 3 欠银行 1 金额为 $L_{31}=30$。由于银行 1 已经违约，这不影响违约者集合。\n- 整个系统已经崩溃。\n- 总违约数：$3$。\n\n**测试用例 5：** $s = 0.8$，$\\boldsymbol{\\Delta} = [0, 0, 0]^T$\n- 损失乘数：$m(0.8) = 0.1 + 0.7(0.8) = 0.66$。\n- 第 0 步：$\\mathbf{q}^{(0)} = \\mathbf{q}_{\\text{pre-shock}} - [0, 0, 0]^T = [20, 20, 55]^T$。\n- 所有初始权益均为正。没有初始违约。\n- 级联未被触发。\n- 总违约数：$0$。\n\n该分析展示了一个关键现象：随着金融系统将债务转移到一个监管更少、更脆弱的“影子”层（即 $s$ 增加），其对初始冲击的韧性会恶化。一个在 $s=0.0$ 时被控制住的冲击，在中间 $s$ 值时导致了部分级联，而在 $s=1.0$ 时导致了全面的系统性崩溃。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the number of defaulted banks in a stylized interbank network\n    for a given set of test cases.\n    \"\"\"\n\n    # Fixed network parameters\n    # L_ij means bank i (row) owes bank j (column)\n    L = np.array([\n        [0.0, 70.0, 0.0],\n        [0.0, 0.0, 80.0],\n        [30.0, 0.0, 0.0]\n    ])\n    e = np.array([60.0, 30.0, 5.0])\n    r_R = 0.9\n    r_S = 0.2\n    N = 3\n\n    # Test cases: (shift fraction s, shock vector Delta)\n    test_cases = [\n        (0.0, np.array([55.0, 0.0, 0.0])),\n        (0.3, np.array([55.0, 0.0, 0.0])),\n        (0.5, np.array([55.0, 0.0, 0.0])),\n        (1.0, np.array([55.0, 0.0, 0.0])),\n        (0.8, np.array([0.0, 0.0, 0.0]))\n    ]\n\n    results = []\n\n    # Calculate fixed network properties once\n    p_bar = np.sum(L, axis=1)  # Total interbank liabilities (row sums)\n    a_bar = np.sum(L, axis=0)  # Total interbank assets (column sums)\n    q_pre_shock = e + a_bar - p_bar\n\n    for s, Delta in test_cases:\n        # Effective loss multiplier for the current s\n        m_s = (1 - s) * (1 - r_R) + s * (1 - r_S)\n\n        # Step 0: Initial shock and defaults\n        q = q_pre_shock - Delta\n        \n        # Sets to track defaulted banks\n        # Bank indices are 1-based, numpy arrays are 0-based\n        defaulted_banks = set(np.where(q < 0)[0] + 1)\n        newly_defaulted = defaulted_banks.copy()\n        \n        # Iterative contagion process\n        while newly_defaulted:\n            # Banks that defaulted in the previous wave trigger new losses\n            current_wave_defaulters = newly_defaulted.copy()\n            newly_defaulted.clear()\n            \n            for j_defaulter in current_wave_defaulters:\n                # Propagate losses to creditors of the defaulted bank j_defaulter\n                # A bank i is a creditor if L[j-1, i-1] > 0\n                for i_creditor in range(1, N + 1):\n                    # Continue if creditor is already defaulted\n                    if i_creditor in defaulted_banks:\n                        continue\n                    \n                    # Calculate loss for creditor i from defaulter j\n                    # L is indexed by (borrower, creditor)\n                    loss = m_s * L[j_defaulter - 1, i_creditor - 1]\n                    \n                    if loss > 0:\n                        # Update equity of the creditor\n                        q[i_creditor - 1] -= loss\n                        \n                        # Check if the creditor defaults\n                        if q[i_creditor - 1] < 0:\n                            defaulted_banks.add(i_creditor)\n                            newly_defaulted.add(i_creditor)\n        \n        # The result for this case is the total number of defaulted banks\n        results.append(len(defaulted_banks))\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "在理解了系统性风险的衡量方式及其传播机制后，我们转向一个关键的政策问题：如何干预以防止系统崩溃？这项练习将让你扮演监管者的角色，负责稳定整个金融系统。你将使用经典的 Eisenberg-Noe 金融清算模型，来计算在初始冲击后，确保所有机构都能履行其支付义务所需的最低资本注入额 $\\Delta C_{\\min}$ [@problem_id:2435808]。这个实践提供了一种强大的量化方法，用于评估清偿能力和设计高效、有针对性的干预措施，以维护金融稳定。", "id": "2435808", "problem": "考虑一个由 $n$ 个机构组成的金融体系，其由一个有向加权负债网络表示。设 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为名义负债矩阵，其中 $L_{ij}$ 是机构 $i$ 对机构 $j$ 的债务。定义总名义负债向量 $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$ 如下：\n$$\n\\bar{p}_i \\equiv \\sum_{j=1}^{n} L_{ij}.\n$$\n定义相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 如下：\n$$\n\\Pi_{ij} \\equiv \n\\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{if } \\bar{p}_i > 0, \\\\\n0, & \\text{if } \\bar{p}_i = 0,\n\\end{cases}\n$$\n使得 $\\Pi$ 的每一行之和最多为 $1$。设 $x \\in \\mathbb{R}_{\\ge 0}^{n}$ 为遭受任何冲击之前的外部资产向量。\n\n对指定节点 $i \\in \\{1,\\dots,n\\}$ 施加大小为 $S_0 \\ge 0$ 的初始冲击，会将其外部资产减少至 $x_i' = \\max\\{x_i - S_0, 0\\}$，而对于所有 $k \\ne i$，其外部资产保持 $x_k' = x_k$ 不变。然后，可以向受冲击的节点 $i$ 单独注入一笔非负资本 $\\Delta C \\ge 0$，得到注资后的外部资产 $x_i'' = x_i' + \\Delta C$，而对于所有 $k \\ne i$，其外部资产为 $x_k'' = x_k'$。\n\n支付根据 Eisenberg–Noe 定点模型进行清算：一个清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 必须满足\n$$\np = \\min\\left\\{\\bar{p},\\, \\Pi^\\top p + x''\\right\\},\n$$\n其中最小值为逐元素取值， $x''$ 是注资后的外部资产向量。\n\n定义“稳定网络”为所有机构全额偿付，即清算支付等于总名义负债：$p = \\bar{p}$。换句话说，稳定化要求在给定的冲击和仅对节点 $i$ 应用资本注入的情况下，所有机构的全额偿付在 Eisenberg–Noe 模型下是可行的。\n\n任务。对于下方的每个测试用例，计算在对指定节点 $i$ 施加大小为 $S_0$ 的初始冲击后，为稳定网络所需的最小资本注入 $\\Delta C_{\\min}$（与 $x$ 和 $L$ 使用相同的资本单位）。如果仅对节点 $i$ 注入任何有限非负资本 $\\Delta C$ 都无法实现所有机构的全额偿付，则该测试用例返回数值 $-1.0$。\n\n您的程序必须生成单行输出，其中包含所有结果，形式为方括号括起来的逗号分隔列表，每个数字都精确到 $6$ 位小数。例如，四个结果的有效输出形式为 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 都显示到 $6$ 位小数。\n\n使用以下测试套件。在每个案例中，网络大小为 $n = 3$。\n\n测试用例 1（一般情况）：\n- 受冲击的节点索引：$i = 1$（使用基于 $1$ 的索引；您的程序内部可以使用基于 $0$ 的索引，但必须遵循此处给出的数据）。\n- 初始冲击：$S_0 = 1.5$。\n- 负债矩阵：\n$$\nL = \\begin{bmatrix}\n0 & 2 & 0 \\\\\n0 & 0 & 1 \\\\\n1 & 0 & 0\n\\end{bmatrix}.\n$$\n- 外部资产：\n$$\nx = \\begin{bmatrix}\n2 \\\\\n1 \\\\\n0.5\n\\end{bmatrix}.\n$$\n\n测试用例 2（冲击后已稳定，需要零注入）：\n- 受冲击的节点索引：$i = 1$。\n- 初始冲击：$S_0 = 0.2$。\n- 负债矩阵：\n$$\nL = \\begin{bmatrix}\n0 & 2 & 0 \\\\\n0 & 0 & 1 \\\\\n1 & 0 & 0\n\\end{bmatrix}.\n$$\n- 外部资产：\n$$\nx = \\begin{bmatrix}\n2 \\\\\n1 \\\\\n0.5\n\\end{bmatrix}.\n$$\n\n测试用例 3（仅在受冲击节点注入无法稳定）：\n- 受冲击的节点索引：$i = 3$。\n- 初始冲击：$S_0 = 0$。\n- 负债矩阵：\n$$\nL = \\begin{bmatrix}\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n0 & 0 & 0\n\\end{bmatrix}.\n$$\n- 外部资产：\n$$\nx = \\begin{bmatrix}\n0.1 \\\\\n0.1 \\\\\n0.1\n\\end{bmatrix}.\n$$\n\n测试用例 4（零负债节点受冲击的边界情况）：\n- 受冲击的节点索引：$i = 1$。\n- 初始冲击：$S_0 = 10.0$。\n- 负债矩阵：\n$$\nL = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n1 & 0 & 0 \\\\\n0 & 1 & 0\n\\end{bmatrix}.\n$$\n- 外部资产：\n$$\nx = \\begin{bmatrix}\n0.5 \\\\\n0.5 \\\\\n1.0\n\\end{bmatrix}.\n$$\n\n最终输出格式要求。您的程序应生成单行输出，其中包含测试用例 1 到 4 的结果，按顺序排列为方括号括起来的逗号分隔列表，每个值都精确到 6 位小数，例如\n$$\n[\\Delta C_{\\min}^{(1)},\\Delta C_{\\min}^{(2)},\\Delta C_{\\min}^{(3)},\\Delta C_{\\min}^{(4)}].\n$$\n如果仅在受冲击节点注入无法实现稳定，则该案例打印 $-1.000000$。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取给定信息\n- 机构数量为 $n$。\n- 名义负债矩阵为 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $L_{ij}$ 是机构 $i$ 对 $j$ 的债务。\n- 总名义负债向量为 $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$，定义为 $\\bar{p}_i \\equiv \\sum_{j=1}^{n} L_{ij}$。\n- 相对负债矩阵为 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，定义为当 $\\bar{p}_i > 0$ 时 $\\Pi_{ij} \\equiv L_{ij}/\\bar{p}_i$，当 $\\bar{p}_i = 0$ 时 $\\Pi_{ij} = 0$。\n- 外部资产向量为 $x \\in \\mathbb{R}_{\\ge 0}^{n}$。\n- 大小为 $S_0 \\ge 0$ 的初始冲击施加于指定节点 $i$。\n- 冲击后的外部资产向量 $x'$ 定义为 $x_i' = \\max\\{x_i - S_0, 0\\}$ 且对于 $k \\ne i$ 有 $x_k' = x_k$。\n- 一笔资本注入 $\\Delta C \\ge 0$ 分配给受冲击的节点 $i$。\n- 注资后的外部资产向量 $x''$ 定义为 $x_i'' = x_i' + \\Delta C$ 且对于 $k \\ne i$ 有 $x_k'' = x_k'$。\n- 清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 满足定点方程 $p = \\min\\left\\{\\bar{p},\\, \\Pi^\\top p + x''\\right\\}$。\n- 网络稳定定义为所有机构全额偿付的条件，即 $p = \\bar{p}$。\n- 任务是找到稳定网络所需的最小资本注入 $\\Delta C_{\\min}$。如果仅在节点 $i$ 注入无法实现稳定，则该值为 $-1.0$。\n- 提供了四个测试用例，包含 $n$、$L$、$x$、$i$ 和 $S_0$ 的具体值。\n\n步骤 2：使用提取的信息进行验证\n- **科学依据**：该问题基于 Eisenberg–Noe 金融清算模型，该模型是计算经济学中系统性风险分析的基石。该模型在数学上是严谨的并被广泛接受。在此框架内，各项前提在事实上是合理的。\n- **适定性**：该问题要求在一组线性不等式的约束下，求一个非负量 $\\Delta C$ 的最小值。这种结构是适定的。解的存在性和唯一性条件由问题的约束明确定义。\n- **客观性**：所有术语都经过数学上的精确定义。指令清晰明确，没有主观性语言。\n- **完整性和一致性**：问题提供了构建解决方案所需的所有必要数据（$L, x, i, S_0$）和定义。内部没有矛盾。\n\n步骤 3：结论与行动\n问题是有效的。它是在一个公认的经济模型背景下的一个定义明确的数学练习。现在将构建一个解决方案。\n\n问题的核心是确定实现网络稳定所需的最小非负资本注入 $\\Delta C_{\\min}$。稳定被定义为清算支付向量 $p$ 等于总名义负债向量 $\\bar{p}$，即 $p = \\bar{p}$。\n\n清算过程由以下定点方程控制：\n$$\np = \\min\\left\\{\\bar{p}, \\Pi^\\top p + x''\\right\\}\n$$\n其中最小值为逐元素取值。为了实现稳定，必须有 $p = \\bar{p}$。将此条件代入方程可得：\n$$\n\\bar{p} = \\min\\left\\{\\bar{p}, \\Pi^\\top \\bar{p} + x''\\right\\}\n$$\n该等式成立的充要条件是，对于每个机构 $k \\in \\{1, \\dots, n\\}$，以下不等式都得到满足：\n$$\n\\bar{p}_k \\le (\\Pi^\\top \\bar{p})_k + x''_k\n$$\n这个由 $n$ 个线性不等式组成的系统表示了每个机构的总可用资金（来自其他机构的收款，$\\Pi^\\top \\bar{p}$，加上其自身的注资后外部资产，$x''$）足以覆盖其总名义负债 $\\bar{p}$ 的条件。我们展开矩阵-向量乘积项：\n$$\n(\\Pi^\\top \\bar{p})_k = \\sum_{j=1}^{n} (\\Pi^\\top)_{kj} \\bar{p}_j = \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j\n$$\n注资后的外部资产向量 $x''$ 取决于初始冲击 $S_0$ 和资本注入 $\\Delta C$，两者都作用于单个节点 $i$。 $x''$ 的分量为：\n$$\nx''_k = \\begin{cases}\n\\max\\{x_i - S_0, 0\\} + \\Delta C, & \\text{if } k=i \\\\\nx_k, & \\text{if } k \\ne i \\text{ and } k \\text{ is not the shocked node}\n\\end{cases}\n$$\n更准确地说，冲击作用于节点 $i$，之后向同一节点 $i$ 注入资本。设受冲击节点的索引为 $i_{shock}$。\n那么对于任意节点 $k$：\n$$\nx'_k = \\begin{cases}\n\\max\\{x_{i_{shock}} - S_0, 0\\}, & \\text{if } k=i_{shock} \\\\\nx_k, & \\text{if } k \\ne i_{shock}\n\\end{cases}\n$$\n注资后的资产为：\n$$\nx''_k = \\begin{cases}\nx'_{i_{shock}} + \\Delta C, & \\text{if } k=i_{shock} \\\\\nx'_k, & \\text{if } k \\ne i_{shock}\n\\end{cases}\n$$\n我们将此代入我们的不等式系统。\n\n对于任意节点 $k \\ne i_{shock}$，稳定性条件为：\n$$\n\\bar{p}_k \\le \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j + x'_k = \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j + x_k\n$$\n这个条件与冲击 $S_0$ 和注入 $\\Delta C$ 无关。让我们为每个节点 $k$ 定义其注资前的“偿付能力缺口”为：\n$$\nG_k = \\bar{p}_k - \\left( \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j + x'_k \\right)\n$$\n为了能仅通过向节点 $i_{shock}$ 注入资本来实现稳定，所有其他节点 $k \\ne i_{shock}$ 必须自身具备偿付能力。也就是说，对于所有 $k \\ne i_{shock}$，必须有 $G_k \\le 0$。如果存在任何 $k \\ne i_{shock}$ 使得 $G_k > 0$，那么向节点 $i_{shock}$ 注入任何数量的资本都无法弥补节点 $k$ 的资金缺口。在这种情况下，无法实现稳定，结果为 $-1.0$。\n\n对于受冲击的节点 $k = i_{shock}$，稳定性条件为：\n$$\n\\bar{p}_{i_{shock}} \\le \\sum_{j=1}^{n} \\Pi_{j,i_{shock}} \\bar{p}_j + x''_{i_{shock}}\n$$\n代入 $x''_{i_{shock}} = x'_{i_{shock}} + \\Delta C$：\n$$\n\\bar{p}_{i_{shock}} \\le \\sum_{j=1}^{n} \\Pi_{j,i_{shock}} \\bar{p}_j + x'_{i_{shock}} + \\Delta C\n$$\n我们可以重新整理这个不等式来求解所需的注入 $\\Delta C$：\n$$\n\\Delta C \\ge \\bar{p}_{i_{shock}} - \\left( \\sum_{j=1}^{n} \\Pi_{j,i_{shock}} \\bar{p}_j + x'_{i_{shock}} \\right) = G_{i_{shock}}\n$$\n由于资本注入必须是非负的（$\\Delta C \\ge 0$），所需的最小资本注入为 $\\Delta C_{\\min} = \\max\\{0, G_{i_{shock}}\\}$。\n\n完整的算法如下：\n1.  给定 $L$、$x$、$i_{shock}$（基于 1）和 $S_0$。将 $i_{shock}$ 转换为基于 0 的索引。\n2.  从 $L$ 计算总名义负债向量 $\\bar{p}$：$\\bar{p}_i = \\sum_j L_{ij}$。\n3.  计算相对负债矩阵 $\\Pi$。对于每一行 $i$：如果 $\\bar{p}_i > 0$，则 $\\Pi_{ij} = L_{ij} / \\bar{p}_i$；否则 $\\Pi_{ij} = 0$。\n4.  计算冲击后的外部资产向量 $x'$。令 $i_{idx} = i_{shock} - 1$。\n    - $x'_{i_{idx}} = \\max\\{x_{i_{idx}} - S_0, 0\\}$。\n    - 对于所有 $k \\ne i_{idx}$，$x'_k = x_k$。\n5.  计算假设全额偿付下，来自其他机构的总预期收款向量：$v = \\Pi^\\top \\bar{p}$。\n6.  对于每个机构 $k=0, \\dots, n-1$，计算偿付能力缺口 $G_k = \\bar{p}_k - (v_k + x'_k)$。\n7.  检查不可能性。对于每个 $k \\ne i_{idx}$，如果 $G_k > 0$，则无法实现稳定。返回 $-1.0$。\n8.  如果步骤 7 的检查通过，计算所需的最小注入量：$\\Delta C_{\\min} = \\max\\{0, G_{i_{idx}}\\}$。返回这个值。\n\n这个流程正确地处理了问题陈述的所有方面。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum capital injection to stabilize a financial network\n    for a series of test cases.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {\n            \"shocked_node_idx\": 1,\n            \"S0\": 1.5,\n            \"L\": np.array([\n                [0, 2, 0],\n                [0, 0, 1],\n                [1, 0, 0]\n            ]),\n            \"x\": np.array([2, 1, 0.5])\n        },\n        {\n            \"shocked_node_idx\": 1,\n            \"S0\": 0.2,\n            \"L\": np.array([\n                [0, 2, 0],\n                [0, 0, 1],\n                [1, 0, 0]\n            ]),\n            \"x\": np.array([2, 1, 0.5])\n        },\n        {\n            \"shocked_node_idx\": 3,\n            \"S0\": 0.0,\n            \"L\": np.array([\n                [0, 1, 0],\n                [0, 0, 1],\n                [0, 0, 0]\n            ]),\n            \"x\": np.array([0.1, 0.1, 0.1])\n        },\n        {\n            \"shocked_node_idx\": 1,\n            \"S0\": 10.0,\n            \"L\": np.array([\n                [0, 0, 0],\n                [1, 0, 0],\n                [0, 1, 0]\n            ]),\n            \"x\": np.array([0.5, 0.5, 1.0])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        x = case[\"x\"]\n        # Convert 1-based shocked_node_idx to 0-based index\n        shocked_node_idx_0based = case[\"shocked_node_idx\"] - 1\n        S0 = case[\"S0\"]\n        n = L.shape[0]\n\n        # Step 2: Compute total nominal liabilities p_bar\n        p_bar = np.sum(L, axis=1)\n\n        # Step 3: Compute relative liability matrix Pi\n        Pi = np.zeros_like(L, dtype=float)\n        # Use np.divide to handle division by zero where p_bar_i is 0\n        non_zero_liabilities = p_bar > 1e-12 # Use tolerance for float comparison\n        Pi[non_zero_liabilities] = np.divide(\n            L[non_zero_liabilities], \n            p_bar[non_zero_liabilities, np.newaxis]\n        )\n\n        # Step 4: Compute post-shock external asset vector x_prime\n        x_prime = x.copy().astype(float)\n        x_prime[shocked_node_idx_0based] = np.maximum(\n            x[shocked_node_idx_0based] - S0, 0\n        )\n\n        # Step 5: Compute expected incoming payments v = Pi^T * p_bar\n        v = Pi.T @ p_bar\n\n        # Step 6: Compute solvency gaps G_k\n        # G_k = p_bar_k - (v_k + x_prime_k)\n        gaps = p_bar - (v + x_prime)\n\n        # Step 7: Check for impossibility\n        is_impossible = False\n        for k in range(n):\n            if k != shocked_node_idx_0based:\n                # If any non-shocked node has a positive gap, stabilization is impossible.\n                # A small tolerance is used for floating point comparisons.\n                if gaps[k] > 1e-9:\n                    is_impossible = True\n                    break\n        \n        if is_impossible:\n            results.append(-1.0)\n            continue\n\n        # Step 8: Calculate minimum injection for the shocked node\n        # delta_C_min = max(0, G_{i_shock})\n        delta_C_min = np.maximum(0.0, gaps[shocked_node_idx_0based])\n        results.append(delta_C_min)\n\n    # Format the final output according to problem specification\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}