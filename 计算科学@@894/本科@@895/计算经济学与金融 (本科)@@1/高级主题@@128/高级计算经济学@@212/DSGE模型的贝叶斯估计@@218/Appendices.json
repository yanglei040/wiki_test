{"hands_on_practices": [{"introduction": "在分析贝叶斯估计的结果之前，诊断马尔可夫链蒙特卡洛（MCMC）采样器的性能至关重要。接受率是采样器效率的主要指标；过高或过低的接受率都可能预示着提议分布存在问题。这个练习 [@problem_id:2375892] 提供了编写脚本以自动检查这一关键统计数据的动手实践，这是任何MCMC方法实践者的基本技能。", "id": "2375892", "problem": "在动态随机一般均衡 (DSGE) 模型的贝叶斯估计中，使用马尔可夫链蒙特卡洛 (MCMC) 抽样来近似模型参数的后验分布。每个 MCMC 步骤或者接受一个提议的移动，或者拒绝它。设第 $t$ 次迭代的接受指示符为 $A_t \\in \\{0,1\\}$，其中 $A_t = 1$ 表示接受，$A_t = 0$ 表示拒绝。长期平均接受概率为 $\\alpha = \\mathbb{E}[A_t]$。在预烧期后达到平稳性的条件下，根据可用抽样计算出的样本接受率是一系列伯努利随机变量的样本均值，它是 $\\alpha$ 的一个无偏估计量。\n\n你需要编写一个程序，为固定的测试套件中的每个链计算预烧期后的接受率，并在该接受率低于 $0.10$ 或高于 $0.50$ 时标记该链。形式上，对于一个总迭代次数为 $T$、预烧期长度为 $T_b$（非负整数）、接受指示符为 $\\{A_1,\\dots,A_T\\}$ 的链，定义可用抽样数为 $n = T - T_b$。如果 $n \\le 0$，则必须标记该链。否则，计算样本接受率\n$$\n\\hat{\\alpha} \\;=\\; \\frac{1}{n}\\sum_{t=T_b+1}^{T} A_t.\n$$\n如果 $\\hat{\\alpha} < 0.10$ 或 $\\hat{\\alpha} > 0.50$，则标记该链。在边界值 $0.10$ 和 $0.50$ 处相等的情况不应被标记。\n\n你的程序必须硬编码并评估以下链的测试套件。每个链由其预烧期长度和其完整的接受指示符序列 $\\{A_t\\}_{t=1}^T$ 指定：\n- 链 1：$T=20$，$T_b=5$，$\\{A_t\\} = [$ $0$, $1$, $0$, $0$, $1$, $1$, $0$, $0$, $1$, $0$, $0$, $0$, $1$, $0$, $0$, $1$, $0$, $0$, $1$, $0$ $]$。\n- 链 2：$T=20$，$T_b=0$，$\\{A_t\\} = [$ $1$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$ $]$。\n- 链 3：$T=10$，$T_b=2$，$\\{A_t\\} = [$ $0$, $1$, $1$, $1$, $0$, $1$, $1$, $0$, $1$, $1$ $]$。\n- 链 4：$T=10$，$T_b=0$，$\\{A_t\\} = [$ $1$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$ $]$。\n- 链 5：$T=8$，$T_b=0$，$\\{A_t\\} = [$ $1$, $0$, $1$, $0$, $1$, $0$, $1$, $0$ $]$。\n- 链 6：$T=5$，$T_b=5$，$\\{A_t\\} = [$ $0$, $1$, $0$, $1$, $0$ $]$。\n\n为覆盖性而设计：\n- 链 1 代表一个典型情况，其预烧期后的接受率在 $0.10$ 和 $0.50$ 之间。\n- 链 2 是一个低于 $0.10$ 的低接受率情况。\n- 链 3 是一个高于 $0.50$ 的高接受率情况。\n- 链 4 是一个恰好为 $0.10$ 的边界情况。\n- 链 5 是一个恰好为 $0.50$ 的边界情况。\n- 链 6 的可用抽样数为零 ($n = 0$)。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按链1到链6的顺序排列结果，并用布尔值指示每个链是否被标记。例如，包含六个链的输出应类似于 [$\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6$]。本问题不涉及物理单位。所有阈值都是小数（而不是百分比），且不涉及角度。", "solution": "问题陈述经确认为具有科学依据、定义明确且客观。它提出了在计算经济学中使用的马尔可夫链蒙特卡洛 (MCMC) 方法背景下的一个标准诊断任务。定义、公式和测试数据是完整的、一致的，并允许一个唯一的、可验证的解。\n\n目标是分析一组 MCMC 接受指示符序列 $\\{A_t\\}$，以根据其预烧期后的接受率来确定是否应标记它们。该过程是确定性的，并遵循一套明确的规则。\n\n对于每个总迭代次数为 $T$、预烧期为 $T_b$ 的链，我们首先使用以下公式计算可用（预烧期后）抽样数 $n$：\n$$\nn = T - T_b\n$$\n标记一个链的第一个规则是，如果可用抽样数非正，即 $n \\le 0$。\n\n如果 $n > 0$，我们继续计算样本接受率 $\\hat{\\alpha}$。该接受率是可用抽样中接受指示符的均值，由以下公式给出：\n$$\n\\hat{\\alpha} = \\frac{1}{n}\\sum_{t=T_b+1}^{T} A_t\n$$\n第二套标记规则适用于此接受率。如果一个链的样本接受率在推荐范围 $[0.10, 0.50]$ 之外，则该链被标记。具体来说，如果 $\\hat{\\alpha} < 0.10$ 或 $\\hat{\\alpha} > 0.50$，则标记该链。边界值 $0.10$ 和 $0.50$ 被认为是可接受的，不会导致标记。\n\n现在我们将此过程应用于六个指定的链中的每一个。\n\n对于链 1：\n- 参数：$T = 20$，$T_b = 5$。\n- 可用抽样数：$n = 20 - 5 = 15$。由于 $n > 0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=6}^{20}$。接受的总数是 $\\sum_{t=6}^{20} A_t = 1+0+0+1+0+0+0+1+0+0+1+0+0+1+0 = 5$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{5}{15} = \\frac{1}{3} \\approx 0.333$。\n- 条件检查：$0.10 < 0.333 < 0.50$。该接受率在可接受范围内。\n- 结论：不标记。\n\n对于链 2：\n- 参数：$T = 20$，$T_b = 0$。\n- 可用抽样数：$n = 20 - 0 = 20$。由于 $n > 0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=1}^{20}$。接受的总数是 $\\sum_{t=1}^{20} A_t = 1$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{1}{20} = 0.05$。\n- 条件检查：$\\hat{\\alpha} < 0.10$。接受率过低。\n- 结论：标记。\n\n对于链 3：\n- 参数：$T = 10$，$T_b = 2$。\n- 可用抽样数：$n = 10 - 2 = 8$。由于 $n > 0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=3}^{10}$。接受的总数是 $\\sum_{t=3}^{10} A_t = 1+1+0+1+1+0+1+1 = 6$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{6}{8} = 0.75$。\n- 条件检查：$\\hat{\\alpha} > 0.50$。接受率过高。\n- 结论：标记。\n\n对于链 4：\n- 参数：$T = 10$，$T_b = 0$。\n- 可用抽样数：$n = 10 - 0 = 10$。由于 $n > 0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=1}^{10}$。接受的总数是 $\\sum_{t=1}^{10} A_t = 1$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{1}{10} = 0.10$。\n- 条件检查：接受率恰好在下边界上。根据规则，相等不会触发标记。\n- 结论：不标记。\n\n对于链 5：\n- 参数：$T = 8$，$T_b = 0$。\n- 可用抽样数：$n = 8 - 0 = 8$。由于 $n > 0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=1}^{8}$。接受的总数是 $\\sum_{t=1}^{8} A_t = 1+0+1+0+1+0+1+0 = 4$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{4}{8} = 0.50$。\n- 条件检查：接受率恰好在上边界上。根据规则，相等不会触发标记。\n- 结论：不标记。\n\n对于链 6：\n- 参数：$T = 5$，$T_b = 5$。\n- 可用抽样数：$n = 5 - 5 = 0$。\n- 条件检查：由于 $n \\le 0$，该链被立即标记，无需计算接受率。\n- 结论：标记。\n\n总之，各链的标记结果如下：链1（不标记）、链2（标记）、链3（标记）、链4（不标记）、链5（不标记）和链6（标记）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes post-burn-in acceptance rates for a suite of MCMC chains\n    and flags them according to specified criteria.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (burn-in_length, acceptance_indicator_sequence)\n    test_cases = [\n        (5, [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]),\n        (0, [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        (2, [0, 1, 1, 1, 0, 1, 1, 0, 1, 1]),\n        (0, [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        (0, [1, 0, 1, 0, 1, 0, 1, 0]),\n        (5, [0, 1, 0, 1, 0])\n    ]\n\n    results = []\n    # Lower and upper bounds for the acceptance rate\n    LOWER_BOUND = 0.10\n    UPPER_BOUND = 0.50\n\n    for tb, at_sequence in test_cases:\n        # Total number of iterations\n        t_total = len(at_sequence)\n        \n        # Number of usable draws\n        n_usable = t_total - tb\n        \n        flagged = False\n        if n_usable <= 0:\n            # Flag if there are no usable draws\n            flagged = True\n        else:\n            # Extract the post-burn-in sequence\n            post_burn_in_a = at_sequence[tb:]\n            \n            # Count the number of acceptances\n            num_acceptances = sum(post_burn_in_a)\n            \n            # Compute the sample acceptance rate\n            # In Python 3, '/' performs float division by default.\n            acceptance_rate = num_acceptances / n_usable\n            \n            # Check if the rate is outside the acceptable range\n            # Equality with the boundaries is not flagged.\n            if acceptance_rate < LOWER_BOUND or acceptance_rate > UPPER_BOUND:\n                flagged = True\n        \n        results.append(flagged)\n\n    # Final print statement in the exact required format.\n    # The str() function for booleans returns 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "贝叶斯DSGE模型估计的核心是MCMC算法，它从后验分布中生成样本。这项实践 [@problem_id:2375844] 通过让你为两个相关的参数实现一个“块” Metropolis-Hastings 更新步骤，从而揭开了这个过程的神秘面纱。通过对变换、提议和接受/拒绝逻辑进行编码，你将对采样器如何探索参数空间获得具体的理解。", "id": "2375844", "problem": "要求您在动态随机一般均衡 (DSGE) 模型的情境下，针对两个高度负相关的结构性参数（具体为价格和工资的 Calvo 粘性参数），实现一次成块 Metropolis–Hastings (MH) 更新。设这两个参数分别表示为 $\\xi_p \\in (0,1)$（价格粘性）和 $\\xi_w \\in (0,1)$（工资粘性）。您将在一个缩减形式的设定下工作，其中似然由一个简约的线性高斯系统定义，该系统近似于一个新凯恩斯主义区块。目标是在一个变换后的无约束空间中计算一个成块提议，并使用 Bayes 定理和 Metropolis–Hastings 接受准则来决定是否接受该提议。\n\n使用的基本原理：\n- Bayes 定理：对于数据 $Y$、先验 $p(\\theta)$ 和似然 $p(Y \\mid \\theta)$，后验分布为 $p(\\theta \\mid Y) \\propto p(Y \\mid \\theta) p(\\theta)$。\n- 采用对称提议的 Metropolis–Hastings 算法：给定当前状态 $\\theta$，从一个满足 $q(\\theta' \\mid \\theta) = q(\\theta \\mid \\theta')$ 的提议密度 $q(\\cdot \\mid \\theta)$ 中提议 $\\theta'$，接受概率为 $\\alpha = \\min\\{1, \\frac{p(\\theta' \\mid Y)}{p(\\theta \\mid Y)}\\}$。\n- 仿射变换和雅可比行列式：当从有约束变量变换到无约束变量时，目标密度要么必须在变换后的空间中表示，要么在基测度未变换的情况下必须包含雅可比行列式。\n\n模型和数据：\n- 参数：$\\theta = (\\xi_p, \\xi_w)$，其中 $\\xi_p \\in (0,1)$ 且 $\\xi_w \\in (0,1)$。\n- 通过 logit 映射变换到无约束参数：$\\psi = (\\psi_p, \\psi_w)$，其中对于 $j \\in \\{p, w\\}$，$\\psi_j = \\log\\left(\\frac{\\xi_j}{1-\\xi_j}\\right)$。逆 logit (logistic) 函数为 $\\xi_j = \\frac{1}{1 + e^{-\\psi_j}}$。\n- 从 $(\\xi_p,\\xi_w)$ 到线性高斯系数的缩减形式映射：\n  - 定义 $b(\\xi_p,\\xi_w) = (1 - \\xi_p)(1 - \\xi_w)$。\n  - 设定 $\\rho(\\theta) = 0.6 - 0.5 \\, b(\\xi_p,\\xi_w)$ 且 $\\alpha(\\theta) = 0.5 \\, b(\\xi_p,\\xi_w)$。\n- 可观测变量：产出缺口 $\\{y_t\\}_{t=1}^T$ 和通货膨胀 $\\{{\\pi_t}\\}_{t=1}^T$，给定初始值 $y_0$。\n- 条件高斯似然：\n  - 状态方程：$y_t \\mid y_{t-1}, \\theta \\sim \\mathcal{N}(\\rho(\\theta)\\, y_{t-1}, \\sigma_y^2)$。\n  - 观测方程：$\\pi_t \\mid y_t, \\theta \\sim \\mathcal{N}(\\alpha(\\theta)\\, y_t, \\sigma_\\pi^2)$。\n  - 假设在时间 $t$ 上以及两个高斯新息之间条件独立。\n- 变换空间中的先验：$\\psi \\sim \\mathcal{N}(\\mu_\\psi, \\Sigma_\\psi)$，其中 $\\mu_\\psi = (0,0)$ 且 $\\Sigma_\\psi = \\mathrm{diag}(1,1)$。\n- 在 $\\psi$-空间中操作，因此 MH 的目标密度正比于 $p(Y \\mid \\theta(\\psi)) \\cdot \\phi(\\psi; \\mu_\\psi, \\Sigma_\\psi)$，其中 $\\phi$ 是 $\\psi$ 的高斯密度。因为基测度是 $d\\psi$，所以不需要雅可比行列式。\n\n数据（请精确使用这些值）：\n- 时间范围：$T = 12$。\n- 初始条件：$y_0 = 0$。\n- 产出缺口序列 $\\{y_t\\}_{t=1}^{12}$：\n  $[\\,0.050,\\;0.041,\\;0.028,\\;0.022,\\;0.018,\\;0.015,\\;0.013,\\;0.012,\\;0.010,\\;0.007,\\;0.005,\\;0.004\\,]$。\n- 通货膨胀序列 $\\{\\pi_t\\}_{t=1}^{12}$：\n  $[\\,0.020,\\;0.018,\\;0.017,\\;0.016,\\;0.015,\\;0.013,\\;0.012,\\;0.011,\\;0.010,\\;0.0090,\\;0.0085,\\;0.0080\\,]$。\n- 似然标准差：$\\sigma_y = 0.05$ 和 $\\sigma_\\pi = 0.02$。\n\n变换空间中的成块提议：\n- 给定当前 $\\psi$，提议 $\\psi' = \\psi + L z$，其中 $L$ 是指定的提议协方差矩阵 $S$ 的下三角 Cholesky 因子（因此有 $S = L L^\\top$），并且 $z \\sim \\mathcal{N}(0,I_2)$。因为该提议是 $\\psi$ 空间中的一个加性高斯随机游走，所以它是对称的。为保证可复现性，您不能生成随机数；相反，对于每个测试用例，都会给您一个标准正态向量 $z$ 以供直接使用。\n- 通过逐分量应用逆 logit 函数来计算 $\\theta' = \\theta(\\psi')$。\n\n接受规则：\n- 在 $\\psi$-空间中计算对数后验：$\\log \\pi(\\psi \\mid Y) = \\log p(Y \\mid \\theta(\\psi)) + \\log \\phi(\\psi; \\mu_\\psi, \\Sigma_\\psi) + C$，其中 $C$ 是任何与 $\\psi$ 无关的常数。可以舍弃当前状态和提议状态共有的任何加性常数。如果需要，可以使用不含归一化常数的高斯对数密度形式，因为它们在 Metropolis–Hastings 比率中会被抵消。\n- 因为提议在 $\\psi$-空间中是对称的，所以接受概率为\n  $\\alpha = \\min\\{1, \\exp\\big( \\log \\pi(\\psi' \\mid Y) - \\log \\pi(\\psi \\mid Y) \\big)\\}$.\n- 如果 $u < \\alpha$ 则接受，其中 $u \\in (0,1)$ 是为每个测试用例提供的一个确定性值。\n\n测试套件：\n为以下四个独立的测试用例各实现一次成块 MH 更新。对于每个测试用例，会给出当前参数 $(\\xi_p,\\xi_w)$、$2 \\times 2$ 的提议协方差矩阵 $S$、标准正态向量 $z$ 以及均匀分布比较值 $u$。\n\n- 案例 1（理想路径，强负相关）：\n  - 当前 $(\\xi_p,\\xi_w) = (\\,0.85,\\;0.80\\,)$。\n  - 提议协方差 $S = \\begin{bmatrix} 0.0625 & -0.05625 \\\\ -0.05625 & 0.0625 \\end{bmatrix}$。\n  - 标准正态 $z = (\\,0.5,\\;-1.0\\,)$。\n  - 比较值 $u = 0.3$。\n\n- 案例 2（单维度接近边界）：\n  - 当前 $(\\xi_p,\\xi_w) = (\\,0.98,\\;0.05\\,)$。\n  - 提议协方差 $S = \\begin{bmatrix} 0.0225 & -0.02025 \\\\ -0.02025 & 0.0225 \\end{bmatrix}$。\n  - 标准正态 $z = (\\,1.0,\\;0.5\\,)$。\n  - 比较值 $u = 0.6$。\n\n- 案例 3（不相关的小步长）：\n  - 当前 $(\\xi_p,\\xi_w) = (\\,0.60,\\;0.60\\,)$。\n  - 提议协方差 $S = \\begin{bmatrix} 0.0016 & 0 \\\\ 0 & 0.0016 \\end{bmatrix}$。\n  - 标准正态 $z = (\\, -0.2,\\;0.3\\,)$。\n  - 比较值 $u = 0.1$。\n\n- 案例 4（各向异性，极强负相关）：\n  - 当前 $(\\xi_p,\\xi_w) = (\\,0.90,\\;0.70\\,)$。\n  - 提议协方差 $S = \\begin{bmatrix} 0.1225 & -0.0665 \\\\ -0.0665 & 0.04 \\end{bmatrix}$。\n  - 标准正态 $z = (\\,0.3,\\;-0.4\\,)$。\n  - 比较值 $u = 0.4$。\n\n实现细节和输出要求：\n- 精确按照规定使用 logit 和逆 logit 变换。\n- 对每个案例，使用 $S$ 的 Cholesky 分解来构造提议增量 $L z$。\n- 精确按照所述的模型方程计算对数似然：\n  - 对于 $t = 1,\\dots,T$，在 $y_0 = 0$ 的情况下，加上\n    $-\\frac{1}{2} \\frac{(y_t - \\rho(\\theta) y_{t-1})^2}{\\sigma_y^2}$ 和\n    $-\\frac{1}{2} \\frac{(\\pi_t - \\alpha(\\theta) y_t)^2}{\\sigma_\\pi^2}$。\n- 对于对数先验，使用 $\\psi \\sim \\mathcal{N}((0,0), I_2)$ 并舍弃当前状态和提议状态共有的常数，即加上 $-\\frac{1}{2} \\lVert \\psi \\rVert^2$。\n- 对每个案例，计算接受指示符，如果接受则定义为 $1$，如果拒绝则定义为 $0$。\n- 您的程序应生成单行输出，其中包含按四个案例顺序排列的结果，格式为方括号内用逗号分隔的列表，例如 $[1,0,1,1]$。\n\n本问题不涉及物理单位或角度。所有返回值均为整数（$0$ 或 $1$）。", "solution": "所提出的问题要求为一个程式化的动态随机一般均衡 (DSGE) 模型的两个结构参数实现一次成块 Metropolis-Hastings (MH) 更新。该问题具有科学依据，数学上是适定的，并为确定性计算提供了所有必要组成部分。因此，该问题是有效的。我们现在开始求解。\n\n目标是决定是否接受或拒绝为参数向量 $\\theta = (\\xi_p, \\xi_w)$（分别代表价格和工资粘性）提议的新状态。MH 算法提供了一种从目标概率分布中抽样的方法，在贝叶斯情境下，该目标分布即后验分布 $p(\\theta \\mid Y)$。\n\n首先，我们处理参数约束。参数 $\\xi_p$ 和 $\\xi_w$ 定义在开区间 $(0, 1)$ 上。为了执行无约束优化或抽样，标准做法是将其变换到一个无约束空间 $\\mathbb{R}^2$ 中。问题指定了 logit 变换：\n$$\n\\psi_j = \\log\\left(\\frac{\\xi_j}{1-\\xi_j}\\right) \\quad \\text{for } j \\in \\{p, w\\}\n$$\n向量 $\\psi = (\\psi_p, \\psi_w)$ 现在位于 $\\mathbb{R}^2$ 中。从无约束空间映射回有约束空间的逆变换是 logistic (或逆 logit) 函数：\n$$\n\\xi_j = \\frac{1}{1 + e^{-\\psi_j}}\n$$\n我们将在 $\\psi$-空间中进行 MH 更新。\n\nMH 算法的核心在于接受概率，该概率取决于提议状态的目标密度与当前状态的目标密度之比。在我们的贝叶斯框架中，目标密度是参数的后验密度 $p(\\psi \\mid Y)$。根据 Bayes 定理，该密度正比于似然和先验的乘积：\n$$\np(\\psi \\mid Y) \\propto p(Y \\mid \\theta(\\psi)) p(\\psi)\n$$\n此处，$p(Y \\mid \\theta(\\psi))$ 是给定参数时观测数据 $Y$ 的似然，而 $p(\\psi)$ 是变换后参数的先验分布。问题指出 $\\psi$ 的先验是一个标准的二元正态分布，$\\psi \\sim \\mathcal{N}(0, I_2)$，其中 $I_2$ 是 $2 \\times 2$ 的单位矩阵。由于先验是直接在 $\\psi$ 上指定的，因此后验密度表达式中不需要因变量变换而产生的雅可比行列式。\n\n在计算上，处理后验密度的对数形式更为稳定和方便：\n$$\n\\log p(\\psi \\mid Y) = \\log p(Y \\mid \\theta(\\psi)) + \\log p(\\psi) + C\n$$\n其中 $C$ 是一个不依赖于 $\\psi$ 的归一化常数，可以忽略，因为它在 MH 接受比率中会被抵消。\n\n忽略常数项，对数先验密度为：\n$$\n\\log p(\\psi) \\propto -\\frac{1}{2} \\psi^\\top (I_2)^{-1} \\psi = -\\frac{1}{2} (\\psi_p^2 + \\psi_w^2) = -\\frac{1}{2} \\lVert \\psi \\rVert^2\n$$\n\n对数似然函数 $\\log p(Y \\mid \\theta(\\psi))$ 是从指定的线性高斯状态空间模型推导出来的。数据由产出缺口 $\\{y_t\\}_{t=1}^T$ 和通货膨胀 $\\{\\pi_t\\}_{t=1}^T$ 的时间序列组成。该模型为：\n$$\ny_t \\mid y_{t-1}, \\theta \\sim \\mathcal{N}(\\rho(\\theta)\\, y_{t-1}, \\sigma_y^2)\n$$\n$$\n\\pi_t \\mid y_t, \\theta \\sim \\mathcal{N}(\\alpha(\\theta)\\, y_t, \\sigma_\\pi^2)\n$$\n系数 $\\rho(\\theta)$ 和 $\\alpha(\\theta)$ 通过中间变量 $b(\\xi_p, \\xi_w) = (1 - \\xi_p)(1 - \\xi_w)$ 依赖于结构参数 $\\theta = (\\xi_p, \\xi_w)$：\n$$\n\\rho(\\theta) = 0.6 - 0.5 \\cdot b(\\xi_p, \\xi_w)\n$$\n$$\n\\alpha(\\theta) = 0.5 \\cdot b(\\xi_p, \\xi_w)\n$$\n假设新息条件独立，总对数似然是在时间范围 $T=12$ 内各个对数密度的总和。再次，舍去相对于 $\\theta$ 为常数的项：\n$$\n\\log p(Y \\mid \\theta) \\propto \\sum_{t=1}^{T} \\left[ -\\frac{(y_t - \\rho(\\theta) y_{t-1})^2}{2\\sigma_y^2} - \\frac{(\\pi_t - \\alpha(\\theta) y_t)^2}{2\\sigma_\\pi^2} \\right]\n$$\n初始条件为 $y_0=0$。给定了 $\\{y_t\\}_{t=1}^{12}$ 和 $\\{\\pi_t\\}_{t=1}^{12}$ 的数据序列，以及标准差 $\\sigma_y=0.05$ 和 $\\sigma_\\pi=0.02$。\n\n对每个测试用例，成块 MH 更新按以下步骤进行：\n1.  **初始化**：从有约束空间中的当前参数 $\\theta_{\\text{curr}} = (\\xi_{p, \\text{curr}}, \\xi_{w, \\text{curr}})$ 开始。\n2.  **变换**：将 $\\theta_{\\text{curr}}$ 转换为无约束空间：$\\psi_{\\text{curr}} = (\\text{logit}(\\xi_{p, \\text{curr}}), \\text{logit}(\\xi_{w, \\text{curr}}))$。\n3.  **提议生成**：使用对称随机游走生成一个提议 $\\psi_{\\text{prop}}$：\n    $$\n    \\psi_{\\text{prop}} = \\psi_{\\text{curr}} + L z\n    $$\n    此处，$S$ 是提议协方差矩阵，$L$ 是其下三角 Cholesky 因子 ($S = LL^\\top$)，$z \\sim \\mathcal{N}(0, I_2)$ 是一个标准正态随机变量向量。为保证可复现性，每个用例都提供了一个特定的向量 $z$。\n4.  **密度评估**：通过将当前状态和提议状态各自的对数先验和对数似然值相加，计算它们的未归一化对数后验密度，即 $\\log \\pi(\\psi_{\\text{curr}} \\mid Y)$ 和 $\\log \\pi(\\psi_{\\text{prop}} \\mid Y)$。\n5.  **接受决策**：该提议是对称的，因此 Hastings 校正项为 1。接受概率 $\\alpha$ 为：\n    $$\n    \\alpha = \\min\\left(1, \\frac{p(\\psi_{\\text{prop}} \\mid Y)}{p(\\psi_{\\text{curr}} \\mid Y)}\\right) = \\min\\left(1, \\exp\\left[\\log p(\\psi_{\\text{prop}} \\mid Y) - \\log p(\\psi_{\\text{curr}} \\mid Y)\\right]\\right)\n    $$\n    如果给定的均匀随机变量 $u \\in (0,1)$ 满足 $u < \\alpha$，则接受该提议。每个用例的结果是一个指示变量：如果接受则为 $1$，如果拒绝则为 $0$。\n\n对四个指定的测试用例中的每一个都执行此程序。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a single blocked Metropolis-Hastings update for four test cases\n    in a simplified DSGE model context.\n    \"\"\"\n    \n    # --- Data and Model Constants ---\n    T = 12\n    y0 = 0.0\n    y_data = np.array([0.050, 0.041, 0.028, 0.022, 0.018, 0.015, 0.013, 0.012, 0.010, 0.007, 0.005, 0.004])\n    pi_data = np.array([0.020, 0.018, 0.017, 0.016, 0.015, 0.013, 0.012, 0.011, 0.010, 0.0090, 0.0085, 0.0080])\n    sigma_y = 0.05\n    sigma_pi = 0.02\n    \n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"xi_curr\": np.array([0.85, 0.80]),\n            \"S\": np.array([[0.0625, -0.05625], [-0.05625, 0.0625]]),\n            \"z\": np.array([0.5, -1.0]),\n            \"u\": 0.3\n        },\n        {\n            \"xi_curr\": np.array([0.98, 0.05]),\n            \"S\": np.array([[0.0225, -0.02025], [-0.02025, 0.0225]]),\n            \"z\": np.array([1.0, 0.5]),\n            \"u\": 0.6\n        },\n        {\n            \"xi_curr\": np.array([0.60, 0.60]),\n            \"S\": np.array([[0.0016, 0.0], [0.0, 0.0016]]),\n            \"z\": np.array([-0.2, 0.3]),\n            \"u\": 0.1\n        },\n        {\n            \"xi_curr\": np.array([0.90, 0.70]),\n            \"S\": np.array([[0.1225, -0.0665], [-0.0665, 0.04]]),\n            \"z\": np.array([0.3, -0.4]),\n            \"u\": 0.4\n        }\n    ]\n\n    # --- Helper Functions ---\n    def logit(xi):\n        return np.log(xi / (1.0 - xi))\n\n    def inv_logit(psi):\n        return 1.0 / (1.0 + np.exp(-psi))\n\n    def calculate_log_posterior(psi):\n        # 1. Transform back to constrained parameter space\n        xi = inv_logit(psi)\n        xi_p, xi_w = xi[0], xi[1]\n        \n        # Check for invalid xi values that might arise from extreme psi\n        # The problem statement ensures xi is in (0,1)\n        if not (0 < xi_p < 1 and 0 < xi_w < 1):\n            return -np.inf # Log posterior is -infinity if parameters are out of bounds\n\n        # 2. Calculate log-prior density (up to a constant)\n        # Prior psi ~ N(0, I)\n        log_prior = -0.5 * np.sum(psi**2)\n\n        # 3. Calculate log-likelihood (up to a constant)\n        b = (1.0 - xi_p) * (1.0 - xi_w)\n        rho = 0.6 - 0.5 * b\n        alpha_param = 0.5 * b\n        \n        log_likelihood = 0.0\n        y_prev = y0\n        \n        for t in range(T):\n            # State equation likelihood term\n            log_likelihood -= 0.5 * ((y_data[t] - rho * y_prev)**2) / (sigma_y**2)\n            # Measurement equation likelihood term\n            log_likelihood -= 0.5 * ((pi_data[t] - alpha_param * y_data[t])**2) / (sigma_pi**2)\n            y_prev = y_data[t]\n\n        return log_prior + log_likelihood\n\n    results = []\n    for case in test_cases:\n        xi_curr = case[\"xi_curr\"]\n        S = case[\"S\"]\n        z = case[\"z\"]\n        u = case[\"u\"]\n\n        # 1. Transform current parameters to unconstrained space\n        psi_curr = logit(xi_curr)\n        \n        # 2. Calculate log posterior of the current state\n        log_post_curr = calculate_log_posterior(psi_curr)\n\n        # 3. Generate proposal\n        try:\n            L = np.linalg.cholesky(S)\n        except np.linalg.LinAlgError:\n            # Handle cases where S is not positive-definite, although problem states they are\n            results.append(0) # Reject if proposal mechanism fails\n            continue\n            \n        psi_prop = psi_curr + L @ z\n        \n        # 4. Calculate log posterior of the proposed state\n        log_post_prop = calculate_log_posterior(psi_prop)\n\n        # 5. Acceptance decision\n        log_r = log_post_prop - log_post_curr\n        \n        # Avoid overflow/underflow issues, though unlikely here\n        if np.isneginf(log_r):\n            acceptance_prob = 0.0\n        else:\n            acceptance_prob = min(1.0, np.exp(log_r))\n\n        accepted = 1 if u < acceptance_prob else 0\n        results.append(accepted)\n\n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "一旦获得了一组可靠的后验样本，最后一步就是将它们转化为有意义的经济分析。通常，我们感兴趣的是模型参数的函数，例如冲击的半衰期，它衡量了冲击的持续性。本练习 [@problem_id:2375884] 指导你完成获取持续性参数的后验样本，通过变换计算相应的半衰期，并构建一个可信集来量化其不确定性的整个过程。", "id": "2375884", "problem": "给定一个线性化的动态随机一般均衡 (DSGE) 模型，其中对数生产率过程服从一个一阶自回归，$a_t = \\rho a_{t-1} + \\varepsilon_t$，其中 $|\\rho| < 1$ 且 $\\varepsilon_t$ 是一个独立同分布的新息项。假设一个马尔可夫链蒙特卡洛 (MCMC) 方法已为持久性参数 $\\rho$ 生成了后验抽取值。对于一个给定的 $\\rho$ 值，其中 $0 < \\rho < 1$，将生产率冲击的半衰期 $h$ 定义为唯一的数 $h > 0$，使得滞后 $h$ 期的协方差与滞后 0 期的方差之比等于 $1/2$，即满足以下条件的唯一 $h$：\n$$\n\\frac{\\mathbb{E}[a_t a_{t+h}]}{\\mathbb{E}[a_t^2]} = \\frac{1}{2}.\n$$\n只有满足 $0 < \\rho < 1$ 的抽取值才可用于计算半衰期。任何满足 $\\rho \\le 0$ 或 $\\rho \\ge 1$ 的抽取值都必须从计算中排除。\n\n对于以下三个测试案例中的每一个，将给定的有限集视为 $\\rho$ 的全部 MCMC 输出，并计算半衰期 $h$ 的等尾 $0.90$ 可信集，以模型周期为单位。等尾 $0.90$ 可信集是一个闭区间，其下端点是 $h$ 的 $0.05$ 后验分位数，上端点是 $h$ 的 $0.95$ 后验分位数。将每个端点报告为四舍五入到六位小数的实数。\n\n测试套件（每个集合都是 $\\rho$ 的一个完整的后验抽取值集合）：\n- 案例 1： $\\{\\,0.83,\\,0.85,\\,0.86,\\,0.87,\\,0.88,\\,0.89,\\,0.90,\\,0.91,\\,0.92,\\,0.93,\\,0.94,\\,0.95,\\,0.96,\\,0.97\\,\\}$。\n- 案例 2： $\\{\\,0.50,\\,0.55,\\,0.60,\\,0.65,\\,0.70,\\,0.75,\\,0.80\\,\\}$。\n- 案例 3： $\\{\\,{-0.20},\\,0.0001,\\,0.30,\\,0.60,\\,0.80,\\,0.95,\\,0.99,\\,0.999,\\,1.05\\,\\}$。\n\n您的程序应生成单行输出，其中按顺序包含三个可信集，每个可信集为一个双元素列表 $[L,U]$，$L$ 为下端点，$U$ 为上端点，所有数值均四舍五入到六位小数，并汇总为一个由逗号分隔且用方括号括起来的列表。例如，要求的输出格式为\n[ [L1,U1], [L2,U2], [L3,U3] ]\n但除了列表分隔符隐式产生的空格外，不含其他空格；具体而言，精确打印单行，格式如下：\n\"[[L1,U1],[L2,U2],[L3,U3]]\"。\n所有半衰期值都应以模型周期为单位，表示为四舍五入到六位小数的实数。", "solution": "该问题陈述已经过严格验证，被确定为具有科学依据、良定且客观的。它提出了贝叶斯计量经济学中的一个标准任务，没有任何逻辑或事实上的不一致之处。因此，我们可以继续推导解决方案。\n\n该问题要求基于一阶自回归过程 $a_t = \\rho a_{t-1} + \\varepsilon_t$ 中持久性参数 $\\rho$ 的后验样本，计算生产率冲击半衰期 $h$ 的 $0.90$ 等尾可信集。\n\n首先，我们必须建立半衰期 $h$ 和持久性参数 $\\rho$ 之间的函数关系。该过程被假设为平稳的，这由条件 $|\\rho| < 1$ 保证。新息项 $\\varepsilon_t$ 是独立同分布的，满足 $\\mathbb{E}[\\varepsilon_t] = 0$ 和 $\\mathbb{E}[\\varepsilon_t^2] = \\sigma_\\varepsilon^2$。\n\n过程 $a_t$ 的方差，记为 $\\text{Var}(a_t) = \\mathbb{E}[a_t^2] = \\gamma_0$，由于平稳性而不随时间变化。我们推导如下：\n$$\n\\text{Var}(a_t) = \\text{Var}(\\rho a_{t-1} + \\varepsilon_t)\n$$\n由于 $a_{t-1}$ 由过去的的新息项 $\\{\\varepsilon_{t-1}, \\varepsilon_{t-2}, \\dots\\}$ 决定，它与当期的新息项 $\\varepsilon_t$ 不相关。因此：\n$$\n\\text{Var}(a_t) = \\rho^2 \\text{Var}(a_{t-1}) + \\text{Var}(\\varepsilon_t)\n$$\n$$\n\\gamma_0 = \\rho^2 \\gamma_0 + \\sigma_\\varepsilon^2\n$$\n解出 $\\gamma_0$ 可得无条件方差：\n$$\n\\gamma_0 = \\mathbb{E}[a_t^2] = \\frac{\\sigma_\\varepsilon^2}{1 - \\rho^2}\n$$\n接下来，我们求滞后 $h$ 期的自协方差，定义为 $\\gamma_h = \\mathbb{E}[a_t a_{t+h}]$。通过将 AR($1$) 过程向前迭代 $h$ 步，我们可以用 $a_t$ 和后续的冲击来表示 $a_{t+h}$：\n$$\na_{t+h} = \\rho^h a_t + \\sum_{j=0}^{h-1} \\rho^j \\varepsilon_{t+h-j}\n$$\n于是自协方差为：\n$$\n\\mathbb{E}[a_t a_{t+h}] = \\mathbb{E}\\left[ a_t \\left( \\rho^h a_t + \\sum_{j=0}^{h-1} \\rho^j \\varepsilon_{t+h-j} \\right) \\right] = \\rho^h \\mathbb{E}[a_t^2] + \\mathbb{E}\\left[ a_t \\sum_{j=0}^{h-1} \\rho^j \\varepsilon_{t+h-j} \\right]\n$$\n第二项为零，因为对于任何 $k > 0$，$\\mathbb{E}[a_t \\varepsilon_{t+k}] = 0$。因此，自协方差函数为：\n$$\n\\gamma_h = \\mathbb{E}[a_t a_{t+h}] = \\rho^h \\mathbb{E}[a_t^2] = \\rho^h \\gamma_0\n$$\n半衰期 $h$ 被定义为自相关函数 $\\frac{\\gamma_h}{\\gamma_0}$ 等于 $\\frac{1}{2}$ 时的滞后期：\n$$\n\\frac{\\mathbb{E}[a_t a_{t+h}]}{\\mathbb{E}[a_t^2]} = \\frac{\\rho^h \\gamma_0}{\\gamma_0} = \\rho^h = \\frac{1}{2}\n$$\n为解出 $h$，我们取自然对数。问题将可接受的抽取值限制在 $0 < \\rho < 1$，这确保了 $\\ln(\\rho)$ 是有定义的且为负数。\n$$\n\\ln(\\rho^h) = \\ln\\left(\\frac{1}{2}\\right)\n$$\n$$\nh \\ln(\\rho) = -\\ln(2)\n$$\n$$\nh(\\rho) = -\\frac{\\ln(2)}{\\ln(\\rho)} = \\frac{\\ln(2)}{\\ln(1/\\rho)}\n$$\n此方程提供了从给定的持久性参数 $\\rho$ 到其对应半衰期 $h$ 的确定性转换。\n\n寻找 $h$ 的 $0.90$ 可信集的计算步骤如下：\n1.  对于每个测试案例，收集 $\\rho$ 的后验抽取值。\n2.  筛选抽取值，只保留满足可接受条件 $0 < \\rho < 1$ 的值。\n3.  对于每个有效的抽取值 $\\rho_i$，计算相应的半衰期 $h_i = h(\\rho_i)$。这样就得到了 $h$ 的一个后验样本。\n4.  对半衰期值的样本进行排序：$h_{(1)} \\le h_{(2)} \\le \\dots \\le h_{(N)}$，其中 $N$ 是有效抽取值的数量。\n5.  计算此排序后样本的 $0.05$ 和 $0.95$ 分位数，以找到可信集的下端点 $L$ 和上端点 $U$。我们使用标准的分位数线性插值法。对于大小为 $N$ 的样本，分位数 $q$ 的索引计算为 $i = q(N-1)$。然后分位数的值在索引为 $\\lfloor i \\rfloor$ 和 $\\lceil i \\rceil$ 的数据点之间进行线性插值。\n6.  报告区间 $[L, U]$，两个端点都四舍五入到六位小数。\n\n我们现在将此程序应用于指定的三个测试案例。\n\n**案例 1：**\n后验抽取集为 $\\{\\,0.83,\\,0.85,\\,0.86,\\,0.87,\\,0.88,\\,0.89,\\,0.90,\\,0.91,\\,0.92,\\,0.93,\\,0.94,\\,0.95,\\,0.96,\\,0.97\\,\\}$。\n所有 $N=14$ 个抽取值都在有效范围 $(0, 1)$ 内。我们将每个 $\\rho_i$ 转换为 $h_i$。$h$ 值的（已排序）样本为：\n$\\{3.719917, 4.265104, 4.591418, 4.957243, 5.369516, 5.836894, 6.369335, 6.979596, 7.684634, 8.506669, 11.205601, 13.513406, 16.979511, 22.756834\\}$。\n样本大小为 $N=14$。\n对于下界 $L$（分位数 $q=0.05$）：索引 $i = 0.05 \\times (14-1) = 0.65$。该值在第1个和第2个元素（$h_{(1)}$ 和 $h_{(2)}$）之间进行插值。\n$L = (1-0.65)h_{(1)} + 0.65h_{(2)} = 0.35(3.719917) + 0.65(4.265104) = 4.074289$。\n对于上界 $U$（分位数 $q=0.95$）：索引 $i = 0.95 \\times (14-1) = 12.35$。该值在第13个和第14个元素（$h_{(13)}$ 和 $h_{(14)}$）之间进行插值。\n$U = (1-0.35)h_{(13)} + 0.35h_{(14)} = 0.65(16.979511) + 0.35(22.756834) = 19.001574$。\n可信集为 $[4.074289, 19.001574]$。\n\n**案例 2：**\n后验抽取集为 $\\{\\,0.50,\\,0.55,\\,0.60,\\,0.65,\\,0.70,\\,0.75,\\,0.80\\,\\}$。\n所有 $N=7$ 个抽取值均有效。转换后的 $h$ 值样本为：\n$\\{1.000000, 1.158504, 1.356919, 1.609438, 1.943360, 2.409421, 3.106278\\}$。\n样本大小为 $N=7$。\n对于 $L$（分位数 $q=0.05$）：索引 $i = 0.05 \\times (7-1) = 0.3$。\n$L = (1-0.3)h_{(1)} + 0.3h_{(2)} = 0.7(1.000000) + 0.3(1.158504) = 1.047551$。\n对于 $U$（分位数 $q=0.95$）：索引 $i = 0.95 \\times (7-1) = 5.7$。\n$U = (1-0.7)h_{(6)} + 0.7h_{(7)} = 0.3(2.409421) + 0.7(3.106278) = 2.897221$。\n可信集为 $[1.047551, 2.897221]$。\n\n**案例 3：**\n后验抽取集为 $\\{\\,{-0.20},\\,0.0001,\\,0.30,\\,0.60,\\,0.80,\\,0.95,\\,0.99,\\,0.999,\\,1.05\\,\\}$。\n我们必须筛选这些抽取值。抽取值 $\\rho = -0.20$ (因为 $\\rho \\le 0$) 和 $\\rho = 1.05$ (因为 $\\rho \\ge 1$) 是不可接受的，必须排除。\n有效的抽取值为 $\\{\\,0.0001,\\,0.30,\\,0.60,\\,0.80,\\,0.95,\\,0.99,\\,0.999\\,\\}$。\n有效抽取值的数量为 $N=7$。转换后的 $h$ 值样本为：\n$\\{0.075257, 0.575716, 1.356919, 3.106278, 13.513406, 68.967564, 692.800490\\}$。\n样本大小为 $N=7$。\n对于 $L$（分位数 $q=0.05$）：索引 $i = 0.05 \\times (7-1) = 0.3$。\n$L = (1-0.3)h_{(1)} + 0.3h_{(2)} = 0.7(0.075257) + 0.3(0.575716) = 0.225395$。\n对于 $U$（分位数 $q=0.95$）：索引 $i = 0.95 \\times (7-1) = 5.7$。\n$U = (1-0.7)h_{(6)} + 0.7h_{(7)} = 0.3(68.967564) + 0.7(692.800490) = 505.650612$。\n可信集为 $[0.225395, 505.650612]$。\n\n最终结果四舍五入到六位小数后为：\n- 案例 1： $[4.074289, 19.001574]$\n- 案例 2： $[1.047551, 2.897221]$\n- 案例 3： $[0.225395, 505.650612]$", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the 0.90 equal-tailed credible set for the half-life h\n    of an AR(1) process based on MCMC draws for the persistence parameter rho.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        [0.83, 0.85, 0.86, 0.87, 0.88, 0.89, 0.90, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97],\n        # Case 2\n        [0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80],\n        # Case 3\n        [-0.20, 0.0001, 0.30, 0.60, 0.80, 0.95, 0.99, 0.999, 1.05],\n    ]\n\n    results = []\n    \n    # Pre-calculated constant for efficiency\n    ln2 = np.log(2)\n\n    for case_rhos in test_cases:\n        # Convert to numpy array for vectorized operations\n        rhos = np.array(case_rhos)\n        \n        # 1. Filter: Retain only admissible draws where 0 < rho < 1\n        valid_rhos = rhos[(rhos > 0) & (rhos < 1)]\n        \n        # 2. Transform: Compute half-life for each valid rho.\n        # The formula is h = ln(2) / -ln(rho)\n        half_lives = ln2 / -np.log(valid_rhos)\n        \n        # The MCMC draws are not necessarily sorted, but the rho values provided\n        # in the problem are, which means the half_lives will also be sorted\n        # as the transformation is monotonic. np.quantile does not require\n        # pre-sorting, but it is a good practice to be aware of.\n        \n        # 3. Quantiles: Compute the 0.05 and 0.95 quantiles to get the\n        # equal-tailed 0.90 credible set.\n        # The 'linear' interpolation method is the standard and default.\n        quantiles = np.quantile(half_lives, [0.05, 0.95], interpolation='linear')\n        \n        # 4. Format: Round the endpoints to six decimal places.\n        lower_bound = round(quantiles[0], 6)\n        upper_bound = round(quantiles[1], 6)\n        \n        results.append([lower_bound, upper_bound])\n\n    # Final print statement must be in the exact required format: [[L1,U1],[L2,U2],[L3,U3]]\n    # We construct the string manually to avoid extra spaces from standard list-to-string conversion.\n    formatted_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(output_string)\n\nsolve()\n```"}]}