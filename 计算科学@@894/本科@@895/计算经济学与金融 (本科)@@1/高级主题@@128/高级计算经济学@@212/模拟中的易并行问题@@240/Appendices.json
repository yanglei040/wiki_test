{"hands_on_practices": [{"introduction": "经济建模中的一项常见任务是理解模型的长期均衡（或稳态）如何随着关键参数的变化而改变。这个过程被称为参数扫描或敏感性分析，是“易并行问题”的一个典型例子，因为每个参数集的分析都是完全独立的。我们将通过一个标准的宏观经济增长模型来探索这一点，通过对贴现因子 $\\beta$ 和折旧率 $\\delta$ 进行参数扫描，来计算并分析稳态资本存量如何响应这些变化 [@problem_id:2390013]。", "id": "2390013", "problem": "考虑一个确定性的、无限期界的代表性代理人经济，其中单一商品用于消费和投资。时间是离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。代表性家庭对消费序列 $\\{c_t\\}_{t=0}^{\\infty}$ 的偏好由预期贴现总和 $\\sum_{t=0}^{\\infty} \\beta^t u(c_t)$ 给出，其中 $\\beta \\in (0,1)$ 是主观贴现因子， $u(\\cdot)$ 是一个严格递增、严格凹且二次连续可微的效用函数。假设为恒定相对风险厌恶（CRRA）效用函数，其系数为 $\\sigma > 0$，即当 $\\sigma \\neq 1$ 时，$u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，当 $\\sigma = 1$ 时，$u(c) = \\log c$。生产是竞争性的，单个厂商采用柯布-道格拉斯生产技术 $y_t = A k_t^{\\alpha} n_t^{1-\\alpha}$，其中 $A = 1$，$\\alpha \\in (0,1)$，劳动供给是无弹性的 $n_t \\equiv 1$，以及物质资本为 $k_t$。资本以 $\\delta \\in [0,1]$ 的速率折旧。竞争性要素价格等于边际产出：资本租赁率为 $r_t = \\alpha k_t^{\\alpha - 1}$，工资为 $w_t = (1 - \\alpha) k_t^{\\alpha}$。以人均形式表示，家庭的时期预算约束为 $c_t + k_{t+1} = (1 - \\delta) k_t + r_t k_t + w_t$，其中 $k_{t+1} \\ge 0$ 且 $c_t \\ge 0$。假设不存在人口增长或技术增长。\n\n仅从这些原始要素和定义出发，并仅使用第一性原理（例如家庭的跨期最优性条件和竞争均衡条件），在无外生增长的假设下，推导出刻画唯一正稳态资本存量 $K$ 的稳态条件，将其表示为参数 $\\alpha$、$\\beta$ 和 $\\delta$ 的函数。然后，实现一个程序，使用该稳态条件，在保持 $\\alpha$ 固定的情况下，为一组参数对 $(\\beta,\\delta)$ 计算 $K$。\n\n你的实现应利用每个 $(\\beta,\\delta)$ 对都可以独立于其他对进行评估这一事实，这使得该计算成为模拟中的一个易并行问题。但是，你的程序必须顺序且确定性地执行，不要求任何用户输入。\n\n对所有计算使用以下参数化：\n- 资本份额：$\\alpha = 0.36$。\n- 生产率：$A = 1$。\n- 劳动：$n_t \\equiv 1$。\n- 风险厌恶参数 $\\sigma$ 是任意但固定且严格为正的；根据上述假设，你的最终稳态表达式不得依赖于 $\\sigma$。\n\n测试套件（为每对参数计算稳态资本存量 $K$）：\n- 案例 1：$(\\beta,\\delta) = (0.96,0.08)$。\n- 案例 2：$(\\beta,\\delta) = (0.96,0.00)$。\n- 案例 3：$(\\beta,\\delta) = (0.96,1.00)$。\n- 案例 4：$(\\beta,\\delta) = (0.99,0.08)$。\n- 案例 5：$(\\beta,\\delta) = (0.90,0.08)$。\n- 案例 6：$(\\beta,\\delta) = (0.99,0.01)$。\n- 案例 7：$(\\beta,\\delta) = (0.95,0.20)$。\n- 案例 8：$(\\beta,\\delta) = (0.999,0.50)$。\n\n科学真实性与可行性条件：\n- 假设对于有效的参数对，存在具有严格为正的稳态资本 $K > 0$ 的内部解。\n- 如果推导出的稳态条件对某个参数对意味着 $K$ 为非正或未定义（例如，由于你推导的表达式中出现非正分母），你的程序应为该情况返回一个非数值（Not-a-Number）。\n\n数值和输出要求：\n- 将所有数值答案表示为无单位的实数。\n- 将报告的每个稳态资本 $K$ 四舍五入到 $6$ 位小数。\n- 你的程序应生成单行输出，其中包含测试套件的结果，按顺序排列，形式为用方括号括起来的逗号分隔列表，不含空格。例如：\"[k1,k2,k3,k4,k5,k6,k7,k8]\"。", "solution": "问题陈述经评估有效。这是现代宏观经济理论中的一个标准的、良态的问题，具体来说是新古典增长模型的分析。所有必需的参数、函数形式和均衡条件都已提供，不存在内部矛盾或科学不准确之处。我们开始进行推导。\n\n目标是为代表性代理人经济推导稳态资本存量，记为 $K$。该推导分三步进行：首先，建立家庭的跨期最优性条件（欧拉方程）；其次，应用所有的人均变量都保持不变的稳态条件；第三，解出得到的关于 $K$ 的代数方程。\n\n首先，我们建立家庭的动态最优化问题。家庭选择消费序列 $\\{c_t\\}_{t=0}^{\\infty}$ 和资本序列 $\\{k_{t+1}\\}_{t=0}^{\\infty}$ 来最大化其终生效用 $\\sum_{t=0}^{\\infty} \\beta^t u(c_t)$，并受一系列预算约束的限制。时期 $t$ 的预算约束是 $c_t + k_{t+1} = (1 - \\delta) k_t + r_t k_t + w_t$。\n\n在竞争均衡中，要素价格等于其边际产出。给定柯布-道格拉斯生产函数 $y_t = k_t^{\\alpha}$（因为 $A=1$ 且 $n_t=1$），资本租赁率是 $r_t = \\frac{\\partial y_t}{\\partial k_t} = \\alpha k_t^{\\alpha-1}$，工资率是 $w_t = y_t - r_t k_t = k_t^\\alpha - (\\alpha k_t^{\\alpha-1})k_t = (1-\\alpha)k_t^\\alpha$。将这些代入家庭的预算约束，得到 $c_t + k_{t+1} = (1 - \\delta) k_t + (\\alpha k_t^{\\alpha-1})k_t + (1-\\alpha)k_t^\\alpha = (1 - \\delta)k_t + \\alpha k_t^\\alpha + (1 - \\alpha)k_t^\\alpha = k_t^\\alpha + (1 - \\delta)k_t$。这就是经济的总体资源约束。\n\n家庭的问题可以用动态规划来解决。贝尔曼方程是：\n$$V(k_t) = \\max_{k_{t+1}} \\left\\{ u(k_t^\\alpha + (1-\\delta)k_t - k_{t+1}) + \\beta V(k_{t+1}) \\right\\}$$\n关于选择变量 $k_{t+1}$ 的一阶条件是：\n$$-u'(c_t) \\cdot 1 + \\beta V'(k_{t+1}) = 0 \\implies u'(c_t) = \\beta V'(k_{t+1})$$\n通过对贝尔曼方程关于状态变量 $k_t$ 求导得到的包络条件是：\n$$V'(k_t) = u'(c_t) \\left( \\frac{\\partial y_t}{\\partial k_t} + 1 - \\delta \\right) = u'(c_t) (\\alpha k_t^{\\alpha-1} + 1 - \\delta)$$\n将包络条件向前推一期得到：\n$$V'(k_{t+1}) = u'(c_{t+1}) (\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta)$$\n将这个 $V'(k_{t+1})$ 的表达式代回一阶条件，得到欧拉方程：\n$$u'(c_t) = \\beta u'(c_{t+1}) (\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta)$$\n对于指定的恒定相对风险厌恶（CRRA）效用函数 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$（或当 $\\sigma=1$ 时 $u(c)=\\log c$），边际效用为 $u'(c) = c^{-\\sigma}$。欧拉方程变为：\n$$c_t^{-\\sigma} = \\beta c_{t+1}^{-\\sigma} (\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta)$$\n\n其次，我们应用稳态条件。在没有外生增长的稳态下，所有的人均变量都不随时间变化。因此，对于所有 $t$，$k_t = k_{t+1} = K$ 且 $c_t = c_{t+1} = C$。将这些条件应用于欧拉方程，我们得到：\n$$C^{-\\sigma} = \\beta C^{-\\sigma} (\\alpha K^{\\alpha-1} + 1 - \\delta)$$\n由于我们假设一个具有严格为正的消费 $C > 0$ 的内部解，我们可以将两边同除以 $C^{-\\sigma}$：\n$$1 = \\beta (\\alpha K^{\\alpha-1} + 1 - \\delta)$$\n这就是刻画稳态资本存量 $K$ 的基本条件。注意，风险厌恶参数 $\\sigma$ 已经消掉了，正如问题陈述所要求的那样。\n\n第三，我们解这个代数方程以求出 $K$。\n$$\\frac{1}{\\beta} = \\alpha K^{\\alpha-1} + 1 - \\delta$$\n整理各项以分离出 $K$：\n$$\\alpha K^{\\alpha-1} = \\frac{1}{\\beta} - (1 - \\delta) = \\frac{1 - \\beta(1-\\delta)}{\\beta} = \\frac{1 - \\beta + \\beta\\delta}{\\beta}$$\n$$K^{\\alpha-1} = \\frac{1 - \\beta + \\beta\\delta}{\\alpha\\beta}$$\n为了解出 $K$，我们将两边同时取 $\\frac{1}{\\alpha-1}$ 次幂。这等价于对底数取倒数，然后取 $\\frac{1}{1-\\alpha}$ 次幂：\n$$K = \\left( \\frac{\\alpha\\beta}{1 - \\beta + \\beta\\delta} \\right)^{\\frac{1}{1-\\alpha}}$$\n这就是唯一的正稳态资本存量的最终表达式。\n\n为进行计算，我们使用给定的固定参数 $\\alpha = 0.36$。因此，指数为 $\\frac{1}{1 - 0.36} = \\frac{1}{0.64} = 1.5625$。幂运算的底数是 $\\frac{\\alpha\\beta}{1 - \\beta + \\beta\\delta}$。为了使 $K$ 是一个正实数，底数必须为正。给定 $\\alpha \\in (0,1)$ 和 $\\beta \\in (0,1)$，分子 $\\alpha\\beta$ 始终为正。分母是 $(1-\\beta) + \\beta\\delta$。由于 $1-\\beta > 0$ 且 $\\beta\\delta \\ge 0$（对于 $\\delta \\in [0,1]$），分母始终严格为正。因此，对于测试套件中提供的所有有效参数对，稳态资本存量 $K$ 都是正且良定的，预计不会出现非数值结果。\n\n实现过程将对每一组指定的 $(\\beta, \\delta)$ 对应用此公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state capital stock for a neoclassical growth model\n    for a given set of parameters.\n    \"\"\"\n    \n    # Fixed parameters from the problem statement.\n    # Capital share in production.\n    alpha = 0.36\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (beta, delta).\n    test_cases = [\n        (0.96, 0.08),   # Case 1\n        (0.96, 0.00),   # Case 2\n        (0.96, 1.00),   # Case 3\n        (0.99, 0.08),   # Case 4\n        (0.90, 0.08),   # Case 5\n        (0.99, 0.01),   # Case 6\n        (0.95, 0.20),   # Case 7\n        (0.999, 0.50),  # Case 8\n    ]\n\n    results = []\n    \n    # The exponent in the final expression for the steady-state capital stock K.\n    exponent = 1.0 / (1.0 - alpha)\n\n    # Iterate through each parameter set (beta, delta)\n    for beta, delta in test_cases:\n        # The steady-state capital stock K is given by the formula:\n        # K = ( (alpha * beta) / (1 - beta + beta * delta) ) ^ (1 / (1 - alpha))\n        \n        # Calculate the denominator of the base.\n        denominator = 1.0 - beta + beta * delta\n        \n        # As reasoned in the solution, the denominator for the given parameter ranges\n        # is always positive. Thus, we do not need to explicitly handle division by zero\n        # or non-positive bases.\n        \n        # Calculate the base of the exponentiation.\n        base = (alpha * beta) / denominator\n        \n        # Calculate the steady-state capital stock K.\n        k_steady_state = np.power(base, exponent)\n        \n        # Round the result to 6 decimal places as required.\n        result_rounded = round(k_steady_state, 6)\n        \n        results.append(result_rounded)\n\n    # Format the final output string as a comma-separated list in brackets.\n    # The map(str, ...) ensures each number is converted to a string before joining.\n    # No spaces are included between the elements, as per the output format requirement.\n    output_string = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\n# Execute the main function.\nsolve()\n```"}, {"introduction": "从确定性模型转向更复杂的随机模型后，我们可以探索政策分析的强大工具。许多现代经济学问题，特别是关于政策评估的问题，最好使用能够解释个体异质性和随机冲击的基于代理人的模型（Agent-Based Models）来解决。本练习将演示如何使用蒙特卡洛模拟——一项经典的易并行任务——来估计全民基本收入（UBI）政策对多样化代理人群体平均劳动供给的影响 [@problem_id:2390040]。", "id": "2390040", "problem": "考虑一个简单的基于代理人的劳动供给模型，该模型旨在对全民基本收入（UBI）和劳动收入税率进行一次尴尬并行的参数扫描。每个代理人选择劳动供给以最大化其静态效用，同时受线性预算约束和外生收入部分的影响。经济环境、分布和决策问题定义如下。\n\n- 每个代理人的决策变量是劳动供给 $l \\in [0,1]$。\n- 对于给定的全民基本收入（UBI）金额 $y \\ge 0$ 和税率 $\\tau \\in [0,1]$（以小数而非百分比表示），具有生产率 $w_i > 0$ 和负效用参数 $\\phi_i > 0$ 的代理人 $i$ 的消费为 $c$，时期效用为：\n  - 预算约束：$c = (1 - \\tau)\\, w_i\\, l + y + \\varepsilon$。\n  - 效用：$U_i(l; y,\\tau,w_i,\\phi_i,\\varepsilon) = \\log(c) - \\frac{\\phi_i}{2}\\, l^2$。\n- 异质性生产率 $w_i$ 和负效用参数 $\\phi_i$ 在代理人之间是异质的，并且是从对数正态分布中独立同分布地抽取的，其基础正态分布的参数分别为 $(\\mu_w,\\sigma_w)$ 和 $(\\mu_\\phi,\\sigma_\\phi)$。具体来说，$w_i \\sim \\operatorname{Lognormal}(\\mu_w,\\sigma_w^2)$ 且 $\\phi_i \\sim \\operatorname{Lognormal}(\\mu_\\phi,\\sigma_\\phi^2)$。\n- 非劳动收入的冲击 $\\varepsilon$ 在代理人和模拟重复实验中是独立同分布的，其中 $\\varepsilon \\sim \\operatorname{Exponential}(\\lambda)$，其均值 $\\mathbb{E}[\\varepsilon] = 1/\\lambda$ 严格为正。\n\n对于任何给定的配对 $(y,\\tau)$，将代理人的优化问题定义为：选择 $l \\in [0,1]$ 以最大化 $U_i(l; y,\\tau,w_i,\\phi_i,\\varepsilon)$。\n\n蒙特卡洛实验规范：\n- 代理人数量：$N = 10000$。\n- 每个代理人的冲击重复模拟次数：$K = 16$。\n- 分布参数：$\\mu_w = 0$, $\\sigma_w = 0.5$；$\\mu_\\phi = 0$, $\\sigma_\\phi = 0.5$。\n- 指数分布冲击的均值：$\\mathbb{E}[\\varepsilon] = m_\\varepsilon = 0.5$（因此 $\\lambda = 1/m_\\varepsilon$）。\n- 将每个 $(y,\\tau)$ 配对独立处理，因此参数扫描是尴尬并行的。为每个配对使用独立的随机数生成器种子，以使结果可复现且独立于评估顺序。使用基础种子 $12345$，对于第 $j$ 个测试用例（从零开始的索引），使用种子 $12345 + j$。\n\n任务：\n- 对于下面测试套件中的每个 $(y,\\tau)$ 配对，模拟上述经济体并计算期望劳动供给 $\\mathbb{E}[l^\\star(y,\\tau)]$，其中 $l^\\star(y,\\tau)$ 表示在给定 $(y,\\tau)$、代理人类型 $(w_i,\\phi_i)$ 和抽取的 $\\varepsilon$ 的情况下的最优劳动供给。该期望是通过蒙特卡洛实验，在 $N$ 个代理人和 $K$ 次冲击中取平均值来近似的，代表了代理人异质性和冲击的联合分布。\n- 对于每个代理人和每次冲击抽取，在 $l \\in [0,1]$ 上精确求解效用最大化问题；不要对 $l$ 进行离散化。如果存在内部解，则使用它；否则，比较边界 $l=0$ 和 $l=1$ 处的目标函数值，并选择最大化值。\n\n测试套件（UBI $y$ 和税率 $\\tau$ 的参数扫描）：\n1. $(y,\\tau) = (0.0, 0.0)$\n2. $(y,\\tau) = (0.0, 1.0)$\n3. $(y,\\tau) = (1.0, 0.0)$\n4. $(y,\\tau) = (1.0, 0.5)$\n5. $(y,\\tau) = (2.0, 0.8)$\n6. $(y,\\tau) = (3.0, 0.0)$\n7. $(y,\\tau) = (0.0, 0.8)$\n\n最终输出格式：\n- 您的程序必须生成一行包含 Python 风格的列表，其中包含上述测试用例按所列顺序的 $\\mathbb{E}[l^\\star(y,\\tau)]$ 的蒙特卡洛估计值。每个值必须四舍五入到恰好 $6$ 位小数。例如，一个有效的输出看起来像：\n  - $[\\dots]$ 其中每个条目在小数点后恰好有 $6$ 位数字。\n- 不涉及物理单位或角度。税率必须作为小数处理，而不是百分比。\n\n实现约束：\n- 参数扫描必须以尴尬并行的方式处理：每个 $(y,\\tau)$ 用例都使用其自己的随机种子独立计算。程序必须完全自包含，不需要用户输入。", "solution": "该问题将首先经过严格的验证过程。\n\n### 步骤 1：提取已知信息\n问题陈述提供了以下定义和参数：\n\n- **代理人决策问题**：\n    - 决策变量：劳动供给 $l \\in [0,1]$。\n    - 预算约束：$c = (1 - \\tau)\\, w_i\\, l + y + \\varepsilon$。\n    - 效用函数：$U_i(l; y,\\tau,w_i,\\phi_i,\\varepsilon) = \\log(c) - \\frac{\\phi_i}{2}\\, l^2$。\n    - 政策变量：全民基本收入（UBI）$y \\ge 0$，税率 $\\tau \\in [0,1]$。\n    - 代理人特定参数：生产率 $w_i > 0$，劳动负效用参数 $\\phi_i > 0$。\n    - 外生冲击：非劳动收入冲击 $\\varepsilon$。\n\n- **随机环境**：\n    - 生产率分布：$w_i \\sim \\operatorname{Lognormal}(\\mu_w, \\sigma_w^2)$，其中 $\\mu_w = 0, \\sigma_w = 0.5$。\n    - 负效用参数分布：$\\phi_i \\sim \\operatorname{Lognormal}(\\mu_\\phi, \\sigma_\\phi^2)$，其中 $\\mu_\\phi = 0, \\sigma_\\phi = 0.5$。\n    - 冲击分布：$\\varepsilon \\sim \\operatorname{Exponential}(\\lambda)$，均值 $\\mathbb{E}[\\varepsilon] = m_\\varepsilon = 0.5$，意味着 $\\lambda = 1/m_\\varepsilon = 2$。\n\n- **蒙特卡洛实验规范**：\n    - 代理人数量：$N = 10000$。\n    - 每个代理人的冲击重复模拟次数：$K = 16$。\n    - 随机数生成：基础种子为 $12345$。对于第 $j$ 个测试用例（0-索引），种子为 $12345 + j$。\n\n- **任务**：\n    - 对于每个给定的 $(y, \\tau)$ 配对，计算期望最优劳动供给 $\\mathbb{E}[l^\\star(y,\\tau)]$。\n    - 期望通过 $N \\times K$ 次模拟的样本均值来近似。\n    - $l$ 的优化问题必须在连续域 $[0,1]$ 上解析求解。\n\n- **测试套件**：\n    1. $(y,\\tau) = (0.0, 0.0)$\n    2. $(y,\\tau) = (0.0, 1.0)$\n    3. $(y,\\tau) = (1.0, 0.0)$\n    4. $(y,\\tau) = (1.0, 0.5)$\n    5. $(y,\\tau) = (2.0, 0.8)$\n    6. $(y,\\tau) = (3.0, 0.0)$\n    7. $(y,\\tau) = (0.0, 0.8)$\n\n### 步骤 2：使用提取的已知信息进行验证\n根据既定标准对问题进行有效性评估。\n\n- **科学基础**：该模型是微观经济学理论中一个标准的、尽管简化的静态劳动供给模型。对消费使用对数效用，对劳动使用二次负效用是一种常见且易于理解的范式（例如，King-Plosser-Rebelo 偏好）。选择的分布（对数正态分布用于持久性异质性，指数分布用于冲击）在计算经济学中是标准的。该问题牢固地植根于已建立的经济学原理。\n\n- **适定性**：代理人的优化问题是在一个紧集 $l \\in [0,1]$ 上最大化一个连续的效用函数。为了使 $\\log(c)$ 有定义，其参数 $c$ 必须为正。给定 $w_i > 0$, $\\phi_i > 0$, $y \\ge 0$, $\\tau \\in [0,1]$, $l \\in [0,1]$，并且 $\\varepsilon$ 是从指数分布中抽取的（因此 $\\varepsilon \\ge 0$），消费 $c = (1-\\tau)w_i l + y + \\varepsilon$ 是一系列非负项之和。由于 $w_i$ 和 $\\varepsilon$ 是从连续分布中抽取的，它们恰好为零的概率为零。因此，几乎可以肯定 $c > 0$，这使得对数函数有明确定义。效用函数 $U(l)$ 在 $l$上是严格凹的，因为它是一个凹函数（$\\log(c)$，是 $l$ 的线性函数的凹函数）和另一个凹函数（$-\\frac{\\phi_i}{2}l^2$）的和。在一个紧凸集上最大化一个严格凹函数，会有一个唯一解。因此，该问题是适定的。\n\n- **目标明确**：问题以数学精度进行了规定。所有术语都有定义，参数被赋予了明确的值。没有主观或含糊不清的语言。\n\n该问题没有表现出任何诸如科学上不健全、不完整、矛盾或不可行等缺陷。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将开发一个解决方案。\n\n### 求解推导\n\n问题的核心是通过求解以下优化问题，为每组参数 $(y, \\tau, w_i, \\phi_i, \\varepsilon)$ 找到最优劳动供给 $l^\\star$：\n$$\n\\max_{l \\in [0,1]} U(l) = \\log((1-\\tau)w_i l + y + \\varepsilon) - \\frac{\\phi_i}{2}l^2\n$$\n\n为求内部解，我们计算效用函数关于 $l$ 的一阶导数并令其为零。这是一阶条件（FOC）。\n令 $W_i \\equiv (1-\\tau)w_i$ 为税后工资率，令 $Y_{i} \\equiv y + \\varepsilon$ 为非劳动收入部分。效用函数变为 $U(l) = \\log(W_i l + Y_i) - \\frac{\\phi_i}{2}l^2$。一阶条件为：\n$$\n\\frac{\\partial U}{\\partial l} = \\frac{W_i}{W_i l + Y_i} - \\phi_i l = 0\n$$\n这假设存在内部解 $l \\in (0,1)$。重新整理各项得：\n$$\n\\frac{W_i}{W_i l + Y_i} = \\phi_i l\n$$\n$$\nW_i = \\phi_i l (W_i l + Y_i)\n$$\n$$\nW_i = \\phi_i W_i l^2 + \\phi_i Y_i l\n$$\n这可以写成一个关于 $l$ 的二次方程：\n$$\n(\\phi_i W_i) l^2 + (\\phi_i Y_i) l - W_i = 0\n$$\n这是 $al^2 + bl + c = 0$ 的形式，其中系数为 $a = \\phi_i W_i$，$b = \\phi_i Y_i$，$c = -W_i$。\n\n当 $\\tau=1$ 时会出现一个特殊情况。在这种情况下，$W_i = (1-1)w_i = 0$。二次方程的系数变得不确定。我们必须回到一阶条件。如果 $W_i=0$，一阶条件简化为 $-\\phi_i l = 0$，这意味着 $l=0$。这很直观：如果劳动收入被征收 $100\\%$ 的税，就没有工作的动机。因此，对于 $\\tau=1$，最优劳动供给是 $l^\\star = 0$。\n\n对于 $\\tau < 1$，我们有 $W_i > 0$（因为 $w_i > 0$）。我们可以使用二次公式求解关于 $l$ 的二次方程：\n$$\nl_{int} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{-\\phi_i Y_i \\pm \\sqrt{(\\phi_i Y_i)^2 - 4(\\phi_i W_i)(-W_i)}}{2\\phi_i W_i}\n$$\n$$\nl_{int} = \\frac{-\\phi_i Y_i \\pm \\sqrt{\\phi_i^2 Y_i^2 + 4\\phi_i W_i^2}}{2\\phi_i W_i}\n$$\n因为劳动供给 $l$ 不能为负，我们必须取正根：\n$$\nl_{int} = \\frac{-\\phi_i Y_i + \\sqrt{\\phi_i^2 Y_i^2 + 4\\phi_i W_i^2}}{2\\phi_i W_i}\n$$\n为获得更好的数值稳定性，该公式可以简化为：\n$$\nl_{int} = -\\frac{Y_i}{2W_i} + \\sqrt{\\left(\\frac{Y_i}{2W_i}\\right)^2 + \\frac{1}{\\phi_i}}\n$$\n这个值 $l_{int}$ 代表无约束最优劳动供给。然而，选择被限制在区间 $[0,1]$ 内。效用函数是严格凹的，这意味着有约束最优解 $l^\\star$ 只需将无约束最优解截断到可行区间即可获得：\n- 如果 $l_{int} < 0$，函数在 $[0,1]$ 上递减，所以 $l^\\star = 0$。\n- 如果 $l_{int} > 1$，函数在 $[0,1]$ 上递增，所以 $l^\\star = 1$。\n- 如果 $0 \\le l_{int} \\le 1$，无约束最优解是可行的，所以 $l^\\star = l_{int}$。\n\n这可以简洁地表示为 $l^\\star = \\max(0, \\min(l_{int}, 1))$。\n\n### 蒙特卡洛模拟算法\n对于每个测试用例 $(y, \\tau)$，期望劳动供给 $\\mathbb{E}[l^\\star]$ 通过大量模拟代理人和冲击的样本均值来近似。对于索引为 $j$ 的每个测试用例 $(y_j, \\tau_j)$ 的过程如下：\n\n1.  **设置种子**：使用种子 $12345 + j$ 初始化随机数生成器，以确保不同测试用例之间的可复现性和独立性。\n2.  **生成异质性**：从 $\\operatorname{Lognormal}(\\mu_w, \\sigma_w^2)$ 中抽取 $N = 10000$ 个独立的代理人生产率值 $\\{w_i\\}_{i=1}^N$。从 $\\operatorname{Lognormal}(\\mu_\\phi, \\sigma_\\phi^2)$ 中抽取 $N = 10000$ 个独立的负效用参数值 $\\{\\phi_i\\}_{i=1}^N$。\n3.  **生成冲击**：对于每个代理人 $i$，从 $\\operatorname{Exponential}(\\lambda)$ 中抽取 $K = 16$ 个独立的收入冲击值 $\\{\\varepsilon_{ik}\\}_{k=1}^K$。这总共会产生 $N \\times K$ 次冲击。\n4.  **计算最优劳动**：对于 $N \\times K$ 个 $(w_i, \\phi_i, \\varepsilon_{ik})$ 组合中的每一个：\n    *   如果 $\\tau_j = 1$，设置 $l^\\star_{ik} = 0$。\n    *   如果 $\\tau_j < 1$，计算 $W_i = (1-\\tau_j)w_i$ 和 $Y_{ik} = y_j + \\varepsilon_{ik}$。然后使用推导出的公式计算无约束最优解 $l_{int}$。最后，找到有约束最优解 $l^\\star_{ik} = \\max(0, \\min(l_{int}, 1))$。\n5.  **估计期望**：计算所有计算出的最优劳动供给值的样本均值：\n$$\n\\mathbb{E}[l^\\star(y_j, \\tau_j)] \\approx \\frac{1}{N \\cdot K} \\sum_{i=1}^{N} \\sum_{k=1}^{K} l^\\star_{ik}\n$$\n对测试套件中的每个 $(y, \\tau)$ 配对重复此过程。使用 `numpy` 的向量化实现对于此任务非常高效，因为它通过对随机数数组进行操作，避免了对代理人和冲击的显式循环。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the expected labor supply in an agent-based model\n    across a parameter sweep of UBI (y) and tax rate (tau).\n    \"\"\"\n\n    # Monte Carlo experiment specification\n    N_AGENTS = 10000\n    K_SHOCKS = 16\n    \n    # Distribution parameters\n    MU_W, SIGMA_W = 0.0, 0.5\n    MU_PHI, SIGMA_PHI = 0.0, 0.5\n    MEAN_EPSILON = 0.5  # This is the scale parameter 1/lambda for np.random.exponential\n    \n    BASE_SEED = 12345\n\n    # Test suite of (y, tau) pairs\n    test_cases = [\n        (0.0, 0.0),  # case 0\n        (0.0, 1.0),  # case 1\n        (1.0, 0.0),  # case 2\n        (1.0, 0.5),  # case 3\n        (2.0, 0.8),  # case 4\n        (3.0, 0.0),  # case 5\n        (0.0, 0.8),  # case 6\n    ]\n\n    results = []\n\n    for j, (y, tau) in enumerate(test_cases):\n        # Set seed for reproducibility for this specific test case\n        seed = BASE_SEED + j\n        rng = np.random.default_rng(seed)\n\n        # Generate agent heterogeneity parameters (w_i, phi_i)\n        # w_i ~ Lognormal(mu_w, sigma_w^2)\n        w = rng.lognormal(mean=MU_W, sigma=SIGMA_W, size=N_AGENTS)\n        # phi_i ~ Lognormal(mu_phi, sigma_phi^2)\n        phi = rng.lognormal(mean=MU_PHI, sigma=SIGMA_PHI, size=N_AGENTS)\n\n        # Handle the special case of 100% tax rate\n        if tau == 1.0:\n            # If labor income is taxed at 100%, optimal labor is always 0.\n            expected_l_star = 0.0\n        else:\n            # Generate idiosyncratic shocks for each agent and replication\n            # epsilon ~ Exponential(lambda) where mean = 1/lambda\n            # Scale parameter for numpy's exponential is the mean.\n            epsilon = rng.exponential(scale=MEAN_EPSILON, size=(N_AGENTS, K_SHOCKS))\n\n            # Reshape 1D agent-specific arrays to (N_AGENTS, 1) for broadcasting\n            w_bc = w.reshape(-1, 1)\n            phi_bc = phi.reshape(-1, 1)\n\n            # Calculate parameters for the utility maximization problem\n            # W is post-tax wage rate\n            W = (1.0 - tau) * w_bc\n            # Y is non-labor income\n            Y = y + epsilon\n            \n            # Using the simplified and numerically stable formula for the interior solution:\n            # l_int = -Y/(2W) + sqrt((Y/(2W))^2 + 1/phi)\n            Z = Y / (2.0 * W)\n            phi_inv = 1.0 / phi_bc\n            \n            # The calculation is vectorized across all agents and shocks\n            l_int = -Z + np.sqrt(Z**2 + phi_inv)\n            \n            # The optimal labor supply l_star must be in [0, 1].\n            # We clamp the interior solution to this interval.\n            l_star = np.clip(l_int, 0.0, 1.0)\n            \n            # The expectation is the mean over all N_AGENTS*K_SHOCKS simulations\n            expected_l_star = np.mean(l_star)\n        \n        results.append(expected_l_star)\n\n    # Format the results to exactly 6 decimal places as strings\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Print the final output in the required format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "在前两个实践的基础上，我们进一步挑战一个动态交互系统。著名的“牛鞭效应”描述了需求波动在供应链中向上游传递时被逐级放大的现象。通过模拟来测试不同的管理策略（例如预测方法）是一种有效的研究手段，而这类针对不同策略的模拟通常可以并行运行。在这个实践中，我们将对一个多级供应链进行独立模拟，以探究零售商采用的不同预测规则如何影响整个系统的稳定性 [@problem_id:2389983]。", "id": "2389983", "problem": "编写一个完整、可运行的程序，模拟在几种可选的零售商预测规则下，一个串行、多级供应链中的牛鞭效应。该供应链有 $4$ 个梯队，由 $e \\in \\{0,1,2,3\\}$ 索引，其中 $e=0$ 为零售商，$e=1$ 为批发商，$e=2$ 为分销商，$e=3$ 为工厂。时间以周期 $t=1,2,\\dots,T$ 离散。每个梯队均采用周期性盘点、基础库存策略。所有梯队的提前期均为确定性的且相同，即对所有 $e$ 都有 $L_e=L$，其中 $L=2$ 个周期。\n\n每个周期，外生客户需求 $D_t$ 到达零售商 ($e=0$)。外生需求过程是独立同分布的，服从均值为 $\\lambda$ 的泊松分布，即 $D_t \\sim \\text{Poisson}(\\lambda)$ 且 $\\lambda=20$。使用以种子 $20240501$ 初始化的伪随机数生成器，生成一个在所有测试案例中重复使用的单一需求实现 $\\{D_t\\}_{t=1}^T$。所有其他梯队 $e \\ge 1$ 在周期 $t$ 面临的需求，是其紧邻的下游梯队在同一周期下的订单，即 $X_{e,t} = Q_{e-1,t}$，而零售商的观测需求定义为 $X_{0,t} = D_t$。\n\n在每个周期 $t$ 内，事件按以下顺序发生，并按从下游到上游（从 $e=0$ 到 $e=3$）的顺序处理：\n- 发往梯队 $e$ 的、由该梯队在 $L$ 个周期前订购的货物，在周期初到达并计入现有库存。具体来说，在周期 $t$ 到达梯队 $e$ 的数量等于其自身的订单 $Q_{e,t-L}$（如果 $t-L \\ge 1$），否则为 $0$。没有产能限制或供应短缺；到货量等于计划数量。\n- 梯队 $e$ 观测其周期 $t$ 的需求 $X_{e,t}$，对于 $e=0$ 该需求等于 $D_t$，对于 $e \\ge 1$ 则等于 $Q_{e-1,t}$。需求从现有库存中满足；任何未满足的需求都将完全欠交并结转至后续周期。\n- 每个梯队根据刚刚观测到的 $X_{e,t}$ 更新其对平均需求的预测。\n- 每个梯队计算其基础库存目标 $S_{e,t}$ 并下达订单 $Q_{e,t}$，使其库存头寸等于该目标，同时订单量需非负。库存头寸为 $IP_{e,t} = \\text{on\\_hand}_{e,t} + \\text{on\\_order}_{e,t} - \\text{backorders}_{e,t}$。目标为 $S_{e,t} = L \\cdot F_{e,t}$，其中 $F_{e,t}$ 是对未来一个周期的平均需求的当前预测。下达的订单为 $Q_{e,t}=\\max\\{0,\\, S_{e,t} - IP_{e,t}\\}$。订单 $Q_{e,t}$ 将在 $L$ 个周期后，即在周期 $t+L$ 的开始时到达梯队 $e$。\n\n所有梯队开始时现有库存和欠交量均为零，且管道为空（没有已下达但未到货的订单）。所有 $e$ 的预测值初始化为 $F_{e,0}=\\lambda$。对于指数平滑法，在观测到 $X_{e,t}$ 之后、计算 $Q_{e,t}$ 之前，更新遵循 $F_{e,t} \\leftarrow \\alpha \\cdot X_{e,t} + (1-\\alpha)\\cdot F_{e,t-1}$。对于窗口长度为 $k$ 的移动平均法，在观测到 $X_{e,t}$ 之后，预测值是该梯队最近 $\\min\\{k,t\\}$ 个观测需求的算术平均值，即 $F_{e,t}=\\frac{1}{m}\\sum_{j=0}^{m-1} X_{e,t-j}$，其中 $m=\\min\\{k,t\\}$。\n\n在不同测试案例中，仅有零售商的预测方法不同；所有上游梯队 $e \\ge 1$ 均使用指数平滑法，平滑参数为 $\\alpha_{\\text{up}}=0.5$。零售商的可选预测方法定义了测试套件。使用总时长为 $T=3000$ 个周期，并在计算统计数据时舍弃最初 $B=500$ 个周期的预热期数据。对于每个测试案例，为每个梯队 $e \\in \\{0,1,2,3\\}$ 计算牛鞭比率\n$$\nB_e \\;=\\;\\frac{\\operatorname{Var}\\left(Q_{e,t}\\,:\\,t=B+1,\\dots,T\\right)}{\\operatorname{Var}\\left(D_t\\,:\\,t=B+1,\\dots,T\\right)},\n$$\n其中方差是分母为 $n-1$ 的无偏样本方差。\n\n测试套件（每项指定零售商的预测规则及其参数）：\n- 案例1：移动平均法，窗口 $k=5$。\n- 案例2：移动平均法，窗口 $k=1$。\n- 案例3：指数平滑法，$\\alpha=0.2$。\n- 案例4：指数平滑法，$\\alpha=0.9$。\n\n你的程序必须：\n- 使用种子 $20240501$ 生成一个单一的外生需求路径 $\\{D_t\\}_{t=1}^T$，并在所有案例中重复使用。\n- 对每个测试案例，按规定运行仿真并计算向量 $\\left[B_0,B_1,B_2,B_3\\right]$。\n- 将每个牛鞭比率四舍五入到 $4$ 位小数。\n\n最终输出格式：你的程序应生成单行输出，包含一个以逗号分隔的列表的列表，不含空格。其中每个内部列表按上述顺序对应一个测试案例，并包含 $e=0,1,2,3$ 的四个四舍五入后的牛鞭比率。例如，打印的行必须如下所示：\n[[b00,b01,b02,b03],[b10,b11,b12,b13],[b20,b21,b22,b23],[b30,b31,b32,b33]]\n其中 $b_{ij}$ 是四舍五入到4位小数的十进制数。", "solution": "牛鞭效应量化了供应链中订单变异性向上游逐级放大的现象。在采用周期性盘点、订货至S策略以及确定性提前期的情况下，每个梯队的基本状态包括现有库存、欠交订单以及由其过去订单产生的计划到货管道。外生随机性是零售商的客户需求 $D_t$，此处指定为 $D_t \\sim \\text{Poisson}(\\lambda)$ 且 $\\lambda=20$。\n\n我们建立了 $4$ 个由 $e \\in \\{0,1,2,3\\}$ 索引的梯队，其提前期相同，为 $L_e=L=2$。在周期 $t$ 内，处理过程从下游向上游进行，以确保上游梯队将其紧邻下游梯队在同一周期内下的订单作为自身需求来观测。具体来说，$X_{0,t}=D_t$，而对于 $e \\ge 1$，$X_{e,t}=Q_{e-1,t}$。该顺序使每个周期产生一系列明确定义的事件：\n1. 到货：如果 $t-L \\ge 1$，数量为 $Q_{e,t-L}$ 的货物到达梯队 $e$，这反映了确定性的提前期 $L$。这些到货被添加到现有库存中。由于供应不受限制且等于计划到货量，上游的产能或拥堵不会干扰动态过程，从而隔离了预测的信息效应。\n2. 需求实现与满足：梯队 $e$ 观测到 $X_{e,t}$。它会尽可能地用现有库存满足需求，任何短缺都会被欠交。设 $\\text{on\\_hand}_{e,t}$ 和 $\\text{backorders}_{e,t}$ 表示周期 $t$ 订货前的状态，并设 $x=X_{e,t}$ 为实现的需求，则满足量为 $\\min\\{\\text{on\\_hand}_{e,t},x\\}$，欠交增量为 $x-\\min\\{\\text{on\\_hand}_{e,t},x\\}$。\n3. 预测更新：每个梯队维持一个对平均需求的预测 $F_{e,t}$。对于平滑参数为 $\\alpha \\in (0,1]$ 的指数平滑法，\n$$\nF_{e,t}\\leftarrow \\alpha X_{e,t} + (1-\\alpha)F_{e,t-1}.\n$$\n对于窗口为 $k \\in \\mathbb{N}$ 的移动平均法，在观测到 $X_{e,t}$ 之后，预测值为\n$$\nF_{e,t} \\;=\\; \\frac{1}{m}\\sum_{j=0}^{m-1} X_{e,t-j},\\quad m=\\min\\{k,t\\}.\n$$\n初始预测为 $F_{e,0}=\\lambda$。在不同测试案例中，只有零售商的预测方法会变化；所有上游梯队都使用指数平滑法，其参数为 $\\alpha_{\\text{up}}=0.5$。\n4. 订货至S决策：库存头寸为\n$$\nIP_{e,t} \\;=\\; \\text{on\\_hand}_{e,t} + \\text{on\\_order}_{e,t} - \\text{backorders}_{e,t},\n$$\n其中 $\\text{on\\_order}_{e,t}$ 是梯队 $e$ 未来 $L$ 个周期内计划到货的总和。基础库存目标是\n$$\nS_{e,t} \\;=\\; L \\cdot F_{e,t},\n$$\n这是没有安全库存时的预期提前期需求。下达的订单是\n$$\nQ_{e,t} \\;=\\; \\max\\{0,\\; S_{e,t} - IP_{e,t}\\}.\n$$\n该订单被添加到梯队 $e$ 管道的末端，并将在 $L$ 个周期后到达。\n\n所有梯队开始时管道为空、现有库存为零、欠交量为零。通过在从总时长 $T=3000$ 个周期中计算统计数据时，丢弃前 $B=500$ 个周期的数据，可以减轻由空初始条件引起的初始瞬态效应。所有测试案例都使用相同的外生需求路径 $\\{D_t\\}_{t=1}^T$，以隔离零售商预测规则的影响。\n\n为衡量牛鞭效应，我们为每个梯队 $e$ 计算订单序列 $\\{Q_{e,t}\\}_{t=B+1}^T$ 的无偏样本方差，并将其除以外生客户需求 $\\{D_t\\}_{t=B+1}^T$ 的无偏样本方差：\n$$\nB_e \\;=\\;\\frac{\\operatorname{Var}\\left(Q_{e,t}\\,:\\,t=B+1,\\dots,T\\right)}{\\operatorname{Var}\\left(D_t\\,:\\,t=B+1,\\dots,T\\right)}.\n$$\n分子和分母都使用分母为 $n-1$ 的标准无偏估计量。$B_e>1$ 的值表示梯队 $e$ 的变异性相对于外生客户需求有所放大，这是牛鞭效应的标志。更平滑的预测（例如，较小 $\\alpha$ 值的指数平滑法或较大 $k$ 值的移动平均法）通常会减少订单变异性，而反应更灵敏的预测（例如，$k=1$ 的移动平均法或接近 $1$ 的 $\\alpha$ 值的指数平滑法）则倾向于增加订单变异性，从而增加牛鞭比率，尤其是在上游。\n\n该程序精确地实现了上述动态系统，使用种子 $20240501$ 生成了指定的需求路径，使用相同的外生路径独立地模拟每个测试案例，为每个案例计算了 $e=0,1,2,3$ 的四个牛鞭比率，将每个比率四舍五入到 $4$ 位小数，并以所需格式打印包含结果列表的单行：\n[[b00,b01,b02,b03],[b10,b11,b12,b13],[b20,b21,b22,b23],[b30,b31,b32,b33]]。\n每个测试案例都与其他案例无关，因此可以单独评估，无需案例间的交互，这反映了该任务的易于并行的性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(demand_path, method, param, T, burn_in, L, lam, alpha_up):\n    \"\"\"\n    Simulate the 4-echelon supply chain for one retailer forecasting case.\n    demand_path: numpy array of length T with exogenous customer demand for the retailer.\n    method: 'MA' or 'ES' for retailer's forecasting method.\n    param: window k for MA (int) or alpha for ES (float).\n    Returns list of 4 bullwhip ratios [B0, B1, B2, B3].\n    \"\"\"\n    E = 4  # number of echelons: 0=retailer,1=wholesaler,2=distributor,3=factory\n    orders = np.zeros((E, T), dtype=float)\n    on_hand = np.zeros(E, dtype=float)\n    backorders = np.zeros(E, dtype=float)\n    # Pipelines: each is a list of length L storing scheduled arrivals for future periods\n    pipelines = [([0.0] * L) for _ in range(E)]\n    # Forecasts initialized to lambda\n    forecasts = np.full(E, float(lam), dtype=float)\n    # Moving average buffers per echelon (retailer may use MA; upstream use ES)\n    ma_buffers = [[] for _ in range(E)]\n\n    for t in range(T):\n        downstream_order = None  # will hold Q_{e-1,t} as demand for echelon e\n        for e in range(E):\n            # 1) Arrivals\n            if L > 0:\n                arrival = pipelines[e].pop(0)\n                on_hand[e] += arrival\n            else:\n                arrival = 0.0\n\n            # 2) Demand observed for echelon e\n            if e == 0:\n                x = float(demand_path[t])\n            else:\n                x = float(downstream_order) if downstream_order is not None else 0.0\n\n            # Fulfill demand from on-hand; backorder any unmet\n            fulfilled = min(on_hand[e], x)\n            on_hand[e] -= fulfilled\n            unmet = x - fulfilled\n            backorders[e] += unmet\n\n            # 3) Forecast update\n            if e == 0:\n                if method == 'MA':\n                    k = int(param)\n                    # Update buffer with latest observation\n                    ma_buffers[e].append(x)\n                    # Keep only last k\n                    if len(ma_buffers[e]) > k:\n                        ma_buffers[e] = ma_buffers[e][-k:]\n                    # Forecast is mean of available buffer\n                    if len(ma_buffers[e]) > 0:\n                        forecasts[e] = float(sum(ma_buffers[e]) / len(ma_buffers[e]))\n                    else:\n                        forecasts[e] = float(lam)\n                elif method == 'ES':\n                    alpha = float(param)\n                    forecasts[e] = alpha * x + (1.0 - alpha) * forecasts[e]\n                else:\n                    raise ValueError(\"Unknown method\")\n            else:\n                # Upstream echelons use exponential smoothing with fixed alpha_up\n                alpha = float(alpha_up)\n                forecasts[e] = alpha * x + (1.0 - alpha) * forecasts[e]\n\n            # 4) Order-up-to decision\n            on_order = sum(pipelines[e]) if L > 0 else 0.0\n            inventory_position = on_hand[e] + on_order - backorders[e]\n            S_target = L * forecasts[e]\n            q = S_target - inventory_position\n            if q < 0.0:\n                q = 0.0\n            orders[e, t] = q\n\n            # Schedule arrival after L periods\n            if L > 0:\n                pipelines[e].append(q)\n\n            # Set demand for next upstream echelon within same period\n            downstream_order = q\n\n    # Compute bullwhip ratios using unbiased sample variance after burn-in\n    mask = np.arange(T) >= burn_in\n    var_D = np.var(demand_path[mask], ddof=1)\n    # Guard against zero variance (should not happen with Poisson)\n    if var_D <= 0.0:\n        var_D = np.nan\n\n    bullwhip = []\n    for e in range(E):\n        var_Q = np.var(orders[e, mask], ddof=1)\n        ratio = var_Q / var_D if np.isfinite(var_D) and var_D > 0 else float('nan')\n        bullwhip.append(ratio)\n\n    return bullwhip\n\n\ndef solve():\n    # Parameters as specified in the problem statement\n    T = 3000\n    burn_in = 500\n    L = 2\n    lam = 20\n    seed = 20240501\n    alpha_up = 0.5  # upstream echelons' exponential smoothing parameter\n\n    # Generate a single exogenous demand path reused across all test cases\n    rng = np.random.default_rng(seed)\n    demand_path = rng.poisson(lam=lam, size=T).astype(float)\n\n    # Define test cases: (method, parameter)\n    test_cases = [\n        ('MA', 5),     # Case 1: Moving average k=5\n        ('MA', 1),     # Case 2: Moving average k=1\n        ('ES', 0.2),   # Case 3: Exponential smoothing alpha=0.2\n        ('ES', 0.9),   # Case 4: Exponential smoothing alpha=0.9\n    ]\n\n    results = []\n    for method, param in test_cases:\n        ratios = simulate_case(demand_path, method, param, T, burn_in, L, lam, alpha_up)\n        # Round to 4 decimals\n        rounded = [float(f\"{r:.4f}\") for r in ratios]\n        results.append(rounded)\n\n    # Print single-line output in required format without spaces\n    # Construct string like [[b00,b01,b02,b03],[b10,...],...]\n    inner_lists = []\n    for row in results:\n        inner = \",\".join(f\"{x:.4f}\" for x in row)\n        inner_lists.append(f\"[{inner}]\")\n    output = \"[\" + \",\".join(inner_lists) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}