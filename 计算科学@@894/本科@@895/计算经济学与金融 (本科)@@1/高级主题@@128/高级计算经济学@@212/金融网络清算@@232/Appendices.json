{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节的第一个练习将引导你分析债务“折扣”（haircut）对金融系统清算结果的影响。这个练习旨在通过一个具体的参数化场景，让你熟练运用 Eisenberg-Noe 模型的清算算法，并深入理解银行间负债的微小变化如何传导至整个网络 [@problem_id:2392822]。通过求解不同折扣率 $\\alpha$ 下的清算支付向量，你将能更好地把握金融网络的内在联动性。", "id": "2392822", "problem": "考虑一个包含 $2$ 家银行（索引为 $i \\in \\{1,2\\}$）和一个社会节点的 Eisenberg–Noe 金融网络。设外部资产为 $x = (x_{1}, x_{2}) = (2, 1)$。名义银行间负债由矩阵 $L$ 给出，其元素为 $L_{12} = 1$ 和 $L_{21} = 2$（且 $L_{11} = L_{22} = 0$）。每家银行还对社会有负债：$l_{10} = 1$ 和 $l_{20} = 1$。一个参数为 $\\alpha$（其中 $0 < \\alpha < 1$）的统一削减仅应用于银行间负债，因此银行间负债变为 $(1-\\alpha) L$，而 $l_{10}$、$l_{20}$ 和 $x$ 保持不变。\n\n对于每家银行 $i \\in \\{1,2\\}$，削减后的名义总负债为\n$$\\bar{p}_{1}(\\alpha) = (1 - \\alpha)L_{12} + l_{10}, \\quad \\bar{p}_{2}(\\alpha) = (1 - \\alpha)L_{21} + l_{20}.$$\n定义相对负债矩阵 $\\Pi(\\alpha)$，对于银行间链接（$j \\in \\{1,2\\}$），其元素为 $\\Pi_{ij}(\\alpha) = \\frac{L'_{ij}(\\alpha)}{\\bar{p}_{i}(\\alpha)}$；对于对社会节点的链接，其元素为 $\\Pi_{i0}(\\alpha) = \\frac{l_{i0}}{\\bar{p}_{i}(\\alpha)}$，其中 $L'(\\alpha) = (1 - \\alpha)L$，并且当 $i=1$ 时 $l_{i0} = l_{10}$，当 $i=2$ 时 $l_{i0} = l_{20}$。Eisenberg–Noe 清算支付向量 $p^{*}(\\alpha) \\in \\mathbb{R}^{2}_{+}$ 是满足有限责任和按比例分配原则的任意不动点，即\n$$p^{*}(\\alpha) = \\min\\big(\\bar{p}(\\alpha), \\, x + \\Pi(\\alpha)^{\\top} p^{*}(\\alpha)\\big),$$\n其中最小值为按分量取值。\n\n请显式计算 $p^{*}(\\alpha)$ 作为 $\\alpha$ 的函数。将最终答案表示为关于 $\\alpha$ 的 $1 \\times 2$ 行向量。无需四舍五入。", "solution": "在尝试任何解答之前，需对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 银行数量：$2$，索引为 $i \\in \\{1, 2\\}$。\n- 外部资产向量：$x = (x_1, x_2) = (2, 1)$。\n- 名义银行间负债矩阵：$L$，其中 $L_{12} = 1$, $L_{21} = 2$，且 $L_{11} = L_{22} = 0$。\n- 对社会负债：$l_{10} = 1$, $l_{20} = 1$。\n- 削减参数：$\\alpha$，其中 $0 < \\alpha < 1$。\n- 削减后银行间负债：$L'(\\alpha) = (1-\\alpha)L$。\n- 名义总负债向量 $\\bar{p}(\\alpha) = (\\bar{p}_1(\\alpha), \\bar{p}_2(\\alpha))$：\n  $\\bar{p}_1(\\alpha) = (1 - \\alpha)L_{12} + l_{10}$\n  $\\bar{p}_2(\\alpha) = (1 - \\alpha)L_{21} + l_{20}$\n- 相对负债矩阵 $\\Pi(\\alpha)$：对于银行间链接（$j \\in \\{1,2\\}$），$\\Pi_{ij}(\\alpha) = \\frac{L'_{ij}(\\alpha)}{\\bar{p}_i(\\alpha)}$；对于对社会节点的链接，$\\Pi_{i0}(\\alpha) = \\frac{l_{i0}}{\\bar{p}_i(\\alpha)}$。\n- 清算支付向量 $p^*(\\alpha)$，是以下方程的一个不动点：\n  $p^*(\\alpha) = \\min\\big(\\bar{p}(\\alpha), \\, x + \\Pi(\\alpha)^{\\top} p^*(\\alpha)\\big)$，其中最小值为按分量取值。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法恰当且客观。这是金融网络清算领域的一个标准练习，基于已确立的 Eisenberg-Noe 模型。解答所需的所有数据和定义均已提供，并且它们内部一致。未违反任何科学原理、数学逻辑或事实准确性。该问题是可形式化和可解的。\n\n**结论**\n问题被视为有效。将构建解答。\n\n**求解过程**\n任务是找到清算支付向量 $p^*(\\alpha) = \\begin{pmatrix} p_1^*(\\alpha) \\\\ p_2^*(\\alpha) \\end{pmatrix}$，使其成为给定方程的一个不动点。\n\n首先，我们将模型的各组成部分用给定参数 $\\alpha$ 表示。\n外部资产向量为 $x = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。\n每家银行的名义总负债为：\n$\\bar{p}_1(\\alpha) = (1-\\alpha)L_{12} + l_{10} = (1-\\alpha)(1) + 1 = 2-\\alpha$。\n$\\bar{p}_2(\\alpha) = (1-\\alpha)L_{21} + l_{20} = (1-\\alpha)(2) + 1 = 3-2\\alpha$。\n因此，名义总负债向量为 $\\bar{p}(\\alpha) = \\begin{pmatrix} 2-\\alpha \\\\ 3-2\\alpha \\end{pmatrix}$。\n\n银行 $i$ 从系统中获得的收入是向量 $\\Pi(\\alpha)^{\\top} p^*(\\alpha)$ 的第 $i$ 个分量。该分量是从其他银行收到的、按相对负债加权的付款之和。银行 $i$ 从银行 $j$ 获得的收入为 $p_j^*(\\alpha) \\frac{L'_{ji}(\\alpha)}{\\bar{p}_j(\\alpha)}$。\n设 $\\hat{\\Pi}(\\alpha)$ 表示相对负债矩阵的银行间部分，其元素为 $\\hat{\\Pi}_{ij}(\\alpha) = \\frac{(1-\\alpha)L_{ij}}{\\bar{p}_i(\\alpha)}$。\n那么银行间收入向量为 $\\hat{\\Pi}(\\alpha)^{\\top}p^*(\\alpha)$。矩阵 $\\hat{\\Pi}(\\alpha)$ 为：\n$$ \\hat{\\Pi}(\\alpha) = \\begin{pmatrix} \\frac{(1-\\alpha)L_{11}}{\\bar{p}_1(\\alpha)} & \\frac{(1-\\alpha)L_{12}}{\\bar{p}_1(\\alpha)} \\\\ \\frac{(1-\\alpha)L_{21}}{\\bar{p}_2(\\alpha)} & \\frac{(1-\\alpha)L_{22}}{\\bar{p}_2(\\alpha)} \\end{pmatrix} = \\begin{pmatrix} 0 & \\frac{1-\\alpha}{2-\\alpha} \\\\ \\frac{2(1-\\alpha)}{3-2\\alpha} & 0 \\end{pmatrix} $$\n其转置为：\n$$ \\hat{\\Pi}(\\alpha)^{\\top} = \\begin{pmatrix} 0 & \\frac{2(1-\\alpha)}{3-2\\alpha} \\\\ \\frac{1-\\alpha}{2-\\alpha} & 0 \\end{pmatrix} $$\n不动点方程可以对每个分量 $p_i^* = p_i^*(\\alpha)$ 写出：\n$$p_1^* = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}p_2^*\\right)$$\n$$p_2^* = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}p_1^*\\right)$$\n\nEisenberg-Noe 清算向量的规范解是映射 $F(p) = \\min(\\bar{p}, x + \\hat{\\Pi}^{\\top} p)$ 的最大不动点。这可以使用虚拟违约算法找到，该算法从初始猜测 $p^{(0)} = \\bar{p}(\\alpha)$ 开始，并进行迭代 $p^{(k+1)} = F(p^{(k)})$。\n\n让我们初始化迭代：\n$p^{(0)} = \\bar{p}(\\alpha) = \\begin{pmatrix} 2-\\alpha \\\\ 3-2\\alpha \\end{pmatrix}$。\n\n计算第一次迭代 $p^{(1)}$：\n$$ p_1^{(1)} = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}p_2^{(0)}\\right) = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}(3-2\\alpha)\\right) $$\n$$ p_1^{(1)} = \\min(2-\\alpha, 2 + 2(1-\\alpha)) = \\min(2-\\alpha, 4-2\\alpha) $$\n对于给定范围 $0 < \\alpha < 1$，我们有 $2-\\alpha > 1$ 和 $4-2\\alpha > 2$。此外，由于 $2 > \\alpha$，因此 $2-\\alpha < 4-2\\alpha$。于是，$p_1^{(1)} = 2-\\alpha$。\n\n$$ p_2^{(1)} = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}p_1^{(0)}\\right) = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}(2-\\alpha)\\right) $$\n$$ p_2^{(1)} = \\min(3-2\\alpha, 1 + (1-\\alpha)) = \\min(3-2\\alpha, 2-\\alpha) $$\n对于 $0 < \\alpha < 1$，由于 $\\alpha < 1$，我们有 $2-\\alpha < 3-2\\alpha$。于是，$p_2^{(1)} = 2-\\alpha$。\n\n因此，第一次迭代得出 $p^{(1)} = \\begin{pmatrix} 2-\\alpha \\\\ 2-\\alpha \\end{pmatrix}$。\n\n现在，我们使用 $p^{(1)}$ 来计算第二次迭代 $p^{(2)}$：\n$$ p_1^{(2)} = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}p_2^{(1)}\\right) = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)(2-\\alpha)}{3-2\\alpha}\\right) $$\n在范围 $0 < \\alpha < 1$ 内，项 $\\frac{2(1-\\alpha)(2-\\alpha)}{3-2\\alpha}$ 是严格为正的。因此，$2-\\alpha < 2 + \\frac{2(1-\\alpha)(2-\\alpha)}{3-2\\alpha}$。这意味着 $p_1^{(2)} = 2-\\alpha$。\n\n$$ p_2^{(2)} = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}p_1^{(1)}\\right) = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}(2-\\alpha)\\right) $$\n$$ p_2^{(2)} = \\min(3-2\\alpha, 2-\\alpha) $$\n和之前一样，对于 $0 < \\alpha < 1$，我们有 $2-\\alpha < 3-2\\alpha$。这意味着 $p_2^{(2)} = 2-\\alpha$。\n\n第二次迭代得出 $p^{(2)} = \\begin{pmatrix} 2-\\alpha \\\\ 2-\\alpha \\end{pmatrix}$。\n由于 $p^{(2)} = p^{(1)}$，算法已收敛到一个不动点。\n这个向量 $p^*(\\alpha) = \\begin{pmatrix} 2-\\alpha \\\\ 2-\\alpha \\end{pmatrix}$ 就是清算向量。\n\n该解对应于银行1有偿付能力（$p_1^*(\\alpha) = \\bar{p}_1(\\alpha) = 2-\\alpha$）而银行2违约（对于 $\\alpha < 1$，$p_2^*(\\alpha) = 2-\\alpha < 3-2\\alpha = \\bar{p}_2(\\alpha)$）的情形。", "answer": "$$ \\boxed{ \\begin{pmatrix} 2 - \\alpha & 2 - \\alpha \\end{pmatrix} } $$"}, {"introduction": "掌握了基本的清算计算后，下一个练习将我们带入一个更具现实意义的政策比较情境：有限责任与延伸责任制度的差异。这两种法律制度对银行的行为和系统性风险有着深远的影响。本练习通过一个假设的三家银行网络，让你量化分析在不同责任制度下，清算支付、违约状况乃至银行净值会发生怎样的变化 [@problem_id:2392864]。这个实践不仅能加深你对模型应用的理解，还能启发你思考法律框架在金融稳定中的关键作用。", "id": "2392864", "problem": "考虑一个符合 Eisenberg–Noe 清算模型的银行间网络。该网络中有 $3$ 家银行，分别标记为 $A$、$B$ 和 $C$（索引 $i \\in \\{1,2,3\\}$ 分别对应 $A,B,C$）。设外部禀赋向量为 $x=(0.2,\\,0.2,\\,0)$，总名义负债向量为 $\\bar p=(2,\\,1.5,\\,1)$。相对负债矩阵 $\\Pi$（行索引代表债务人，列索引代表债权人）的非零项如下：$\\Pi_{1,2}=0.5$，$\\Pi_{1,0}=0.5$（节点 $0$ 代表社会），$\\Pi_{2,3}=1$ 以及 $\\Pi_{3,1}=1$。在无破产成本的有限责任制度下，一个清算支付向量 $p \\in \\mathbb{R}_+^3$ 满足，对于每个 $i \\in \\{1,2,3\\}$：\n$$\np_i \\;=\\; \\min\\big\\{\\bar p_i,\\; x_i \\;+\\; \\sum_{j=1}^3 \\Pi_{j i}\\, p_j \\big\\}.\n$$\n现在假设法律规则变更为扩展责任，具体含义如下：每家银行 $i$ 的所有者被要求注入一笔外生给定的外部财富 $u_i$ 以弥补资金缺口，其中 $u=(0.4,\\,0.1,\\,0)$。在扩展责任制度下，公司内部的可用资源变为 $x_i+u_i+\\sum_{j=1}^3 \\Pi_{j i} p_j$，并且清算支付向量 $p \\in \\mathbb{R}_+^3$ 满足：\n$$\np_i \\;=\\; \\min\\big\\{\\bar p_i,\\; x_i \\;+\\; u_i \\;+\\; \\sum_{j=1}^3 \\Pi_{j i}\\, p_j \\big\\}.\n$$\n定义银行 $i$ 的“违约”为 $p_i < \\bar p_i$。定义清算结果中银行 $i$ 的权益在有限责任下为 $e_i = x_i + \\sum_{j=1}^3 \\Pi_{j i} p_j - p_i$，在扩展责任下为 $e_i^{\\mathrm{ext}} = x_i + u_i + \\sum_{j=1}^3 \\Pi_{j i} p_j^{\\mathrm{ext}} - p_i^{\\mathrm{ext}}$（其中 $p^{\\mathrm{ext}}$ 表示扩展责任下的清算支付）。对社会支付的总额等于 $\\Pi_{1,0}\\, p_1 + \\Pi_{2,0}\\, p_2 + \\Pi_{3,0}\\, p_3$。\n\n关于将法律规则从有限责任变更为扩展责任对清算结果的影响，以下哪些陈述是正确的？选择所有适用项。\n\nA. 在 $u=(0.4,\\,0.1,\\,0)$ 的扩展责任下，清算支付为 $p^{\\mathrm{ext}}=(1.6,\\,1.1,\\,1.0)$，因此银行 $C$ 有偿付能力，而银行 $A$ 和 $B$ 仍处于违约状态。\n\nB. 从有限责任转变为扩展责任时，对社会支付的总额弱递减。\n\nC. 在此案例中，从有限责任转变为扩展责任时，清算支付按分量弱递增，且违约集合弱收缩。\n\nD. 在此案例中，从有限责任转变为扩展责任时，每家银行的权益都弱递增。", "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n提供的明确数据如下：\n-   银行数量：$3$ 家，索引为 $i \\in \\{1,2,3\\}$，分别对应银行 $A, B, C$。\n-   外部禀赋向量：$x=(0.2,\\,0.2,\\,0)$。\n-   总名义负债向量：$\\bar p=(2,\\,1.5,\\,1)$。\n-   相对负债矩阵 $\\Pi$ 的非零项：$\\Pi_{1,2}=0.5$, $\\Pi_{1,0}=0.5$, $\\Pi_{2,3}=1$ 以及 $\\Pi_{3,1}=1$。所有其他项默认为零。\n-   有限责任下的清算条件：$p_i = \\min\\big\\{\\bar p_i,\\; x_i \\;+\\; \\sum_{j=1}^3 \\Pi_{j i}\\, p_j \\big\\}$。\n-   扩展责任下的外生外部财富：$u=(0.4,\\,0.1,\\,0)$。\n-   扩展责任下的清算条件：$p_i^{\\mathrm{ext}} = \\min\\big\\{\\bar p_i,\\; x_i \\;+\\; u_i \\;+\\; \\sum_{j=1}^3 \\Pi_{j i}\\, p_j^{\\mathrm{ext}} \\big\\}$。\n-   违约的定义：如果 $p_i < \\bar p_i$，则银行 $i$ 违约。\n-   权益的定义（有限责任）：$e_i = x_i + \\sum_{j=1}^3 \\Pi_{j i} p_j - p_i$。\n-   权益的定义（扩展责任）：$e_i^{\\mathrm{ext}} = x_i + u_i + \\sum_{j=1}^3 \\Pi_{j i} p_j^{\\mathrm{ext}} - p_i^{\\mathrm{ext}}$。\n-   对社会支付总额的定义：$\\Pi_{1,0}\\, p_1 + \\Pi_{2,0}\\, p_2 + \\Pi_{3,0}\\, p_3$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n该问题是 Eisenberg–Noe (2001) 金融清算模型的直接应用，该模型是计算金融学中一个标准且成熟的框架。\n-   **科学依据**：该模型在其领域内具有科学合理性。\n-   **适定性**：清算向量的存在性和唯一性是该模型的一个已知理论结果。方程组是适定的。\n-   **客观性与清晰度**：术语定义精确，数据是定量的且无歧义。\n-   **一致性**：对于每个债务银行 $i$，负债矩阵 $\\Pi$ 的行和为 $1$。对于银行 $1$：$\\Pi_{1,2}+\\Pi_{1,0} = 0.5+0.5=1$。对于银行 $2$：$\\Pi_{2,3}=1$。对于银行 $3$：$\\Pi_{3,1}=1$。数据内部一致。\n-   **完备性**：确定清算向量所需的所有信息均已提供。\n\n**步骤3：结论与行动**\n\n问题陈述具有科学依据、适定且内部一致。因此，该问题是**有效的**。我们开始求解。\n\n### 求解推导\n\n首先，我们建立银行间负债的具体方程组。项 $\\sum_{j=1}^3 \\Pi_{j i}\\, p_j$ 代表从其他银行流入银行 $i$ 的总资金。矩阵 $\\Pi$ 的行代表债务人，列代表债权人，因此流入银行 $i$ 的资金由 $\\Pi$ 的第 $i$ 列给出。\n银行间负债网络如下：\n-   银行 $C$（债务人 $3$）欠银行 $A$（债权人 $1$）：$\\Pi_{3,1}=1$。\n-   银行 $A$（债务人 $1$）欠银行 $B$（债权人 $2$）：$\\Pi_{1,2}=0.5$。\n-   银行 $B$（债务人 $2$）欠银行 $C$（债权人 $3$）：$\\Pi_{2,3}=1$。\n\n在有限责任下，每家银行 $i$ 的可用资源为 $A_i(p) = x_i + \\sum_{j=1}^3 \\Pi_{ji} p_j$。\n清算方程组为：\n$p_1 = \\min\\{\\bar p_1, x_1 + \\Pi_{3,1} p_3\\} = \\min\\{2, 0.2 + p_3\\}$\n$p_2 = \\min\\{\\bar p_2, x_2 + \\Pi_{1,2} p_1\\} = \\min\\{1.5, 0.2 + 0.5 p_1\\}$\n$p_3 = \\min\\{\\bar p_3, x_3 + \\Pi_{2,3} p_2\\} = \\min\\{1, p_2\\}$\n\n**1. 有限责任下的清算支付（$p$）**\n\n我们求解清算向量 $p$。一个常用的方法是首先假设一个违约集合。让我们假设所有银行都违约，即对所有 $i$ 都有 $p_i < \\bar p_i$。在这种情况下，每家银行支付其所有可用资源：\n$p_1 = 0.2 + p_3$\n$p_2 = 0.2 + 0.5 p_1$\n$p_3 = p_2$\n\n将 $p_3=p_2$ 代入第一个方程，得到 $p_1 = 0.2 + p_2$。再将此结果代入第二个方程，得出：\n$p_2 = 0.2 + 0.5(0.2 + p_2) = 0.2 + 0.1 + 0.5 p_2 = 0.3 + 0.5 p_2$\n$0.5 p_2 = 0.3 \\implies p_2 = 0.6$\n由此，我们得到 $p_3 = p_2 = 0.6$ 以及 $p_1 = 0.2 + p_3 = 0.2 + 0.6 = 0.8$。\n候选解为 $p = (0.8, 0.6, 0.6)$。我们必须验证所有银行都违约的初始假设：\n-   银行 $A$：$p_1=0.8 < \\bar p_1=2$。违约成立。\n-   银行 $B$：$p_2=0.6 < \\bar p_2=1.5$。违约成立。\n-   银行 $C$：$p_3=0.6 < \\bar p_3=1$。违约成立。\n假设成立。因此，有限责任下的清算向量为 $p=(0.8, 0.6, 0.6)$。\n\n**2. 扩展责任下的清算支付（$p^{\\mathrm{ext}}$）**\n\n在扩展责任下，可用资源为 $A_i^{\\mathrm{ext}}(p^{\\mathrm{ext}}) = x_i + u_i + \\sum_{j=1}^3 \\Pi_{ji} p_j^{\\mathrm{ext}}$。\n禀赋变为 $x+u = (0.2+0.4, 0.2+0.1, 0+0) = (0.6, 0.3, 0)$。\n方程组为：\n$p_1^{\\mathrm{ext}} = \\min\\{2, 0.6 + p_3^{\\mathrm{ext}}\\}$\n$p_2^{\\mathrm{ext}} = \\min\\{1.5, 0.3 + 0.5 p_1^{\\mathrm{ext}}\\}$\n$p_3^{\\mathrm{ext}} = \\min\\{1, p_2^{\\mathrm{ext}}\\}$\n\n假设所有银行都违约：\n$p_1^{\\mathrm{ext}} = 0.6 + p_3^{\\mathrm{ext}}$\n$p_2^{\\mathrm{ext}} = 0.3 + 0.5 p_1^{\\mathrm{ext}}$\n$p_3^{\\mathrm{ext}} = p_2^{\\mathrm{ext}}$\n解这个线性方程组：$p_1^{\\mathrm{ext}} = 0.6 + p_2^{\\mathrm{ext}}$。代入第二个方程：\n$p_2^{\\mathrm{ext}} = 0.3 + 0.5(0.6 + p_2^{\\mathrm{ext}}) = 0.3 + 0.3 + 0.5 p_2^{\\mathrm{ext}} = 0.6 + 0.5 p_2^{\\mathrm{ext}}$\n$0.5 p_2^{\\mathrm{ext}} = 0.6 \\implies p_2^{\\mathrm{ext}} = 1.2$。\n则 $p_3^{\\mathrm{ext}} = 1.2$ 且 $p_1^{\\mathrm{ext}} = 0.6 + 1.2 = 1.8$。\n候选解为 $p^{\\mathrm{ext}} = (1.8, 1.2, 1.2)$。我们检查一致性：\n-   银行 $A$：$p_1^{\\mathrm{ext}} = 1.8 < \\bar p_1 = 2$。一致。\n-   银行 $B$：$p_2^{\\mathrm{ext}} = 1.2 < \\bar p_2 = 1.5$。一致。\n-   银行 $C$：$p_3^{\\mathrm{ext}} = 1.2 > \\bar p_3 = 1$。不一致。\n银行 $C$ 违约的假设是错误的。银行 $C$ 必定有偿付能力，意味着 $p_3^{\\mathrm{ext}} = \\bar p_3 = 1$。\n\n我们以 $p_3^{\\mathrm{ext}} = 1$ 重新求解。\n$p_1^{\\mathrm{ext}} = \\min\\{2, 0.6 + p_3^{\\mathrm{ext}}\\} = \\min\\{2, 0.6 + 1\\} = \\min\\{2, 1.6\\} = 1.6$。\n$p_2^{\\mathrm{ext}} = \\min\\{1.5, 0.3 + 0.5 p_1^{\\mathrm{ext}}\\} = \\min\\{1.5, 0.3 + 0.5(1.6)\\} = \\min\\{1.5, 0.3+0.8\\} = \\min\\{1.5, 1.1\\} = 1.1$。\n最后，我们必须检查银行 $C$ 的一致性：\n$p_3^{\\mathrm{ext}} = \\min\\{1, p_2^{\\mathrm{ext}}\\} = \\min\\{1, 1.1\\} = 1$。这与我们的假设相符。\n扩展责任下的清算向量为 $p^{\\mathrm{ext}}=(1.6, 1.1, 1.0)$。\n\n### 逐项分析\n\n**A. 在 $u=(0.4,\\,0.1,\\,0)$ 的扩展责任下，清算支付为 $p^{\\mathrm{ext}}=(1.6,\\,1.1,\\,1.0)$，因此银行 $C$ 有偿付能力，而银行 $A$ 和 $B$ 仍处于违约状态。**\n\n我们推导出的清算向量是 $p^{\\mathrm{ext}}=(1.6,\\,1.1,\\,1.0)$，与陈述中的值相符。\n我们对照 $\\bar p=(2,\\,1.5,\\,1)$ 检查偿付能力状态：\n-   银行 $A$ ($i=1$)：$p_1^{\\mathrm{ext}} = 1.6 < \\bar p_1 = 2$。该银行处于违约状态。\n-   银行 $B$ ($i=2$)：$p_2^{\\mathrm{ext}} = 1.1 < \\bar p_2 = 1.5$。该银行处于违约状态。\n-   银行 $C$ ($i=3$)：$p_3^{\\mathrm{ext}} = 1.0 = \\bar p_3 = 1$。该银行有偿付能力。\n银行 $C$ 有偿付能力而银行 $A$ 和 $B$ 违约的结论是正确的。\n对A的判断：**正确**。\n\n**B. 从有限责任转变为扩展责任时，对社会支付的总额弱递减。**\n\n对社会支付的总额是 $S = \\Pi_{1,0} p_1 + \\Pi_{2,0} p_2 + \\Pi_{3,0} p_3$。根据问题陈述，$\\Pi_{1,0}=0.5$ 且 $\\Pi_{2,0}=\\Pi_{3,0}=0$。因此，$S = 0.5 p_1$。\n-   在有限责任下：$p_1 = 0.8$。支付额为 $S_{LL} = 0.5 \\times 0.8 = 0.4$。\n-   在扩展责任下：$p_1^{\\mathrm{ext}} = 1.6$。支付额为 $S_{EL} = 0.5 \\times 1.6 = 0.8$。\n对社会的支付从 $0.4$ 增加到 $0.8$。该陈述声称其弱递减。\n对B的判断：**不正确**。\n\n**C. 在此案例中，从有限责任转变为扩展责任时，清算支付按分量弱递增，且违约集合弱收缩。**\n\n第一部分：按分量支付增加。\n我们比较 $p=(0.8, 0.6, 0.6)$ 和 $p^{\\mathrm{ext}}=(1.6, 1.1, 1.0)$。\n$p_1^{\\mathrm{ext}} = 1.6 > p_1 = 0.8$。\n$p_2^{\\mathrm{ext}} = 1.1 > p_2 = 0.6$。\n$p_3^{\\mathrm{ext}} = 1.0 > p_3 = 0.6$。\n支付向量的每个分量都严格增加，这满足弱递增的条件（$p^{\\mathrm{ext}} \\ge p$）。\n\n第二部分：违约集合收缩。\n违约集合 $D$ 为 $\\{i \\mid p_i < \\bar p_i\\}$。\n-   在有限责任下：所有银行都违约，因此 $D_{LL} = \\{1, 2, 3\\}$。\n-   在扩展责任下：银行 $A$（$1$）和 $B$（$2$）违约，但银行 $C$（$3$）变得有偿付能力。因此 $D_{EL} = \\{1, 2\\}$。\n违约集合弱收缩的条件意味着 $D_{EL} \\subseteq D_{LL}$。此处，$\\{1, 2\\} \\subset \\{1, 2, 3\\}$，因此该集合严格收缩。这满足弱收缩的条件。\n陈述的两个部分都为真。\n对C的判断：**正确**。\n\n**D. 在此案例中，从有限责任转变为扩展责任时，每家银行的权益都弱递增。**\n\n我们计算两种情况下的权益。如果一家银行 $i$ 违约，它会支付其所有可用现金，因此其权益为 $0$。\n有限责任下的权益（$e_i$）：\n-   所有银行都违约。因此，$e_1 = e_2 = e_3 = 0$。\n$e_1 = x_1 + \\Pi_{31}p_3 - p_1 = 0.2 + 0.6 - 0.8 = 0$。\n$e_2 = x_2 + \\Pi_{12}p_1 - p_2 = 0.2 + 0.5(0.8) - 0.6 = 0.2 + 0.4 - 0.6 = 0$。\n$e_3 = x_3 + \\Pi_{23}p_2 - p_3 = 0 + 0.6 - 0.6 = 0$。\n所以 $e=(0,0,0)$。\n\n扩展责任下的权益（$e_i^{\\mathrm{ext}}$）：\n-   银行 $A$ 和 $B$ 违约。因此，$e_1^{\\mathrm{ext}} = 0$ 且 $e_2^{\\mathrm{ext}} = 0$。\n-   银行 $C$ 有偿付能力。其权益是其可用资源减去其支付：\n$e_3^{\\mathrm{ext}} = (x_3 + u_3 + \\Pi_{23} p_2^{\\mathrm{ext}}) - p_3^{\\mathrm{ext}} = (0 + 0 + 1 \\times 1.1) - 1.0 = 1.1 - 1.0 = 0.1$。\n所以 $e^{\\mathrm{ext}}=(0, 0, 0.1)$。\n\n比较：\n-   $e_1^{\\mathrm{ext}} = 0$ 且 $e_1 = 0$。所以 $e_1^{\\mathrm{ext}} \\ge e_1$。\n-   $e_2^{\\mathrm{ext}} = 0$ 且 $e_2 = 0$。所以 $e_2^{\\mathrm{ext}} \\ge e_2$。\n-   $e_3^{\\mathrm{ext}} = 0.1$ 且 $e_3 = 0$。所以 $e_3^{\\mathrm{ext}} \\ge e_3$。\n每家银行的权益都弱递增。\n对D的判断：**正确**。", "answer": "$$\\boxed{ACD}$$"}, {"introduction": "最后一个练习将挑战你运用编程能力，去探索一个反直觉但至关重要的网络现象。在金融危机中，一个常见的政策辩论是“救助谁”：是规模最大的银行（“大到不能倒”）还是连接性最强的银行（“关联性太大而不能倒”）？本练习要求你通过编写代码来模拟对不同银行进行救助的效果，并用数据证明，救助一个规模较小但处于网络核心位置的银行，有时比救助最大的银行更能有效稳定整个系统 [@problem_id:2392815]。这个计算实验将让你直观地看到，在复杂网络中，系统重要性并不仅仅由规模决定。", "id": "2392815", "problem": "给定一个金融系统，其中有 $n$ 家银行，该系统在 Eisenberg–Noe (EN) 框架下进行表示。每家银行 $i \\in \\{1,\\dots,n\\}$ 对所有债权人（包括银行间和外部债权人）都有一笔总名义负债 $\\bar{p}_i \\ge 0$。设 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为银行间名义负债矩阵，其中 $L_{ij}$ 表示银行 $i$ 欠银行 $j$ 的名义金额。定义相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 如下：\n$$\n\\pi_{ij} = \\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{if } \\bar{p}_i > 0,\\\\\n0, & \\text{if } \\bar{p}_i = 0.\n\\end{cases}\n$$\n设 $x \\in \\mathbb{R}_{\\ge 0}^n$ 表示外部资产（禀赋）向量。Eisenberg–Noe 清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^n$ 定义为求解以下方程的最大不动点，该方程按分量表示为：\n$$\np_i = \\min\\left\\{\\bar{p}_i,\\ x_i + \\sum_{j=1}^n \\pi_{ji} p_j\\right\\} \\quad \\text{for all } i \\in \\{1,\\dots,n\\},\n$$\n或以向量形式表示为：\n$$\np = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\},\n$$\n其中最小值为按分量取值。考虑一个定向救助政策，该政策将一笔非负预算 $b$ 注入单家银行 $k$，这被模型化为将 $b$ 加入 $x_k$ 同时保持所有其他 $x_i$ 不变。\n\n对于下方的每个测试用例，你必须计算差值\n$$\n\\Delta = \\left(\\sum_{i=1}^n p_i^{(\\text{small})}\\right) - \\left(\\sum_{i=1}^n p_i^{(\\text{large})}\\right),\n$$\n其中，$p^{(\\text{small})}$ 是将全部预算 $b$ 注入到指定的规模较小、连接性更强的银行时的清算支付向量，而 $p^{(\\text{large})}$ 是将全部预算 $b$ 注入到按总名义负债 $\\bar{p}_i$ 衡量的最大银行时的清算支付向量。在每个测试中，都明确给出了最大银行和规模较小、连接性更强的银行的索引。你的程序必须为该测试套件生成 $\\Delta$ 值的列表，并将结果四舍五入到六位小数。\n\n所有输入均为无量纲的货币量，不涉及物理单位。\n\n测试套件：\n- 测试用例 $1$：\n    - $n = 4$.\n    - $\\bar{p} = (\\,$$10$$,$$6$$,$$6$$,$$6$$\\,)$.\n    - $x = (\\,$$1$$,$$1$$,$$1$$,$$1$$\\,)$.\n    - $L = \\begin{pmatrix}\n    $$0$$ & $$0$$ & $$0$$ & $$0$$\\\\\n    $$0$$ & $$0$$ & $$3$$ & $$3$$\\\\\n    $$1$$ & $$0$$ & $$0$$ & $$0$$\\\\\n    $$1$$ & $$0$$ & $$0$$ & $$0$$\n    \\end{pmatrix}$.\n    - 预算 $b = $$2$$.\n    - 最大银行的索引 $i_{\\text{large}} = $$0$$.\n    - 规模较小、连接性更强的银行的索引 $i_{\\text{small}} = $$1$$.\n- 测试用例 $2$：\n    - $n = 3$.\n    - $\\bar{p} = (\\,$$5$$,$$4$$,$$4$$\\,)$.\n    - $x = (\\,$$0.5$$,$$0.5$$,$$0.5$$\\,)$.\n    - $L = \\begin{pmatrix}\n    $$0$$ & $$0$$ & $$0$$\\\\\n    $$0$$ & $$0$$ & $$2$$\\\\\n    $$0$$ & $$1$$ & $$0$$\n    \\end{pmatrix}$.\n    - 预算 $b = $$0$$.\n    - 最大银行的索引 $i_{\\text{large}} = $$0$$.\n    - 规模较小、连接性更强的银行的索引 $i_{\\text{small}} = $$1$$.\n- 测试用例 $3$：\n    - $n = 3$.\n    - $\\bar{p} = (\\,$$8$$,$$3$$,$$3$$\\,)$.\n    - $x = (\\,$$1$$,$$0.5$$,$$0.5$$\\,)$.\n    - $L = \\begin{pmatrix}\n    $$0$$ & $$3$$ & $$3$$\\\\\n    $$0$$ & $$0$$ & $$0$$\\\\\n    $$0$$ & $$0$$ & $$0$$\n    \\end{pmatrix}$.\n    - 预算 $b = $$2$$.\n    - 最大银行的索引 $i_{\\text{large}} = $$0$$.\n    - 规模较小、连接性更强的银行的索引 $i_{\\text{small}} = $$1$$.\n\n你的程序应输出单行结果，其中包含一个用方括号括起来、以逗号分隔的列表，列表中的每个条目是对应测试用例的 $\\Delta$ 值，四舍五入到六位小数（例如，$[\\,\\delta_1,\\delta_2,\\delta_3\\,]$）。", "solution": "问题陈述已经过评估并被认定为有效。该问题是自洽的，其科学基础是已建立的 Eisenberg-Noe 金融网络清算模型，并且在数学上是适定的。得出唯一解所需的所有数据均已提供，且不存在内部矛盾。\n\n核心任务是计算 Eisenberg-Noe 清算支付向量 $p$，该向量被定义为以下方程的最大不动点：\n$$\np = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\}\n$$\n其中最小值为按分量取值。向量 $\\bar{p}$ 代表总名义负债，$x$ 是外部资产向量，$\\Pi$ 是相对银行间负债矩阵。\n\n为求解该问题，我们定义一个算子 $F: \\mathbb{R}^n \\to \\mathbb{R}^n$ 如下：\n$$\nF(p) = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\}\n$$\n对清算向量 $p$ 的搜索被限制在紧集 $[0, \\bar{p}]$ 内，该集合是一个超矩形 $\\{p \\in \\mathbb{R}^n \\mid 0 \\le p_i \\le \\bar{p}_i \\text{ for all } i\\}$。这个集合在赋予了分量级偏序关系后，构成一个完备格。\n\n算子 $F(p)$ 在这个格上是单调的。也就是说，如果按分量比较有 $p^{(a)} \\le p^{(b)}$，那么由于 $\\Pi^\\top$ 的所有项都是非负的，则有 $x + \\Pi^\\top p^{(a)} \\le x + \\Pi^\\top p^{(b)}$。因此，$F(p^{(a)}) = \\min\\{\\bar{p}, x + \\Pi^\\top p^{(a)}\\} \\le \\min\\{\\bar{p}, x + \\Pi^\\top p^{(b)}\\} = F(p^{(b)})$。\n\n根据 Tarski 不动点定理，任何在完备格上的单调函数都拥有一个不动点集，该不动点集本身也是一个非空完备格。这保证了最大不动点的存在性。这个最大不动点可以通过一个简单的迭代算法找到。我们用格中的最大元素 $p^{(0)} = \\bar{p}$ 来初始化迭代。序列则通过以下方式生成：\n$$\np^{(k+1)} = F(p^{(k)}) = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p^{(k)}\\right\\}\n$$\n由于 $p^{(1)} = F(p^{(0)}) \\le p^{(0)}$ 并且 $F$ 是单调的，序列 $\\{p^{(k)}\\}_{k \\ge 0}$ 是非增的，且有下界零向量。因此，它保证会收敛到一个不动点，并且由于迭代从格的顶端开始，它将收敛到最大不动点。\n\n为每个测试用例求解问题的总体步骤如下：\n\n1.  给定参数 $n, \\bar{p}, x, L, b, i_{\\text{large}}, i_{\\text{small}}$，首先根据其定义计算相对负债矩阵 $\\Pi$：\n    $$\n    \\pi_{ij} = \\begin{cases}\n    \\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{if } \\bar{p}_i > 0,\\\\\n    0, & \\text{if } \\bar{p}_i = 0.\n    \\end{cases}\n    $$\n2.  根据救助目标，为外部资产向量定义两种情景。设 $e_k$ 为标准基向量，其在索引 $k$ 处为 1，其他位置为 0。\n    -   对规模较小的银行进行救助：$x^{(\\text{small})} = x + b \\cdot e_{i_{\\text{small}}}$。\n    -   对规模最大的银行进行救助：$x^{(\\text{large})} = x + b \\cdot e_{i_{\\text{large}}}$。\n3.  对每种情景，计算相应的清算向量：\n    -   通过从 $p = \\bar{p}$ 开始迭代 $p \\gets \\min\\{\\bar{p}, x^{(\\text{small})} + \\Pi^\\top p\\}$ 来计算 $p^{(\\text{small})}$，直到向量 $p$ 收敛。\n    -   通过从 $p = \\bar{p}$ 开始迭代 $p \\gets \\min\\{\\bar{p}, x^{(\\text{large})} + \\Pi^\\top p\\}$ 来计算 $p^{(\\text{large})}$，直到向量 $p$ 收敛。\n4.  对每个得出的清算向量，计算其支付总额：\n    $$\n    S_{\\text{small}} = \\sum_{i=1}^n p_i^{(\\text{small})} \\quad \\text{and} \\quad S_{\\text{large}} = \\sum_{i=1}^n p_i^{(\\text{large})}\n    $$\n5.  最后，计算所需的差值 $\\Delta = S_{\\text{small}} - S_{\\text{large}}$。\n\n这个结构化、有理论依据的算法将被实现，用以为每个指定的测试用例找到数值解。迭代的收敛准则是当连续向量之间的变化可以忽略不计时，例如，当差值的上确界范数 $\\|p^{(k+1)} - p^{(k)}\\|_\\infty$ 小于一个很小的容差 $\\epsilon > 0$ 时。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_clearing_vector(p_bar: np.ndarray, x: np.ndarray, Pi: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Eisenberg-Noe clearing payments vector.\n\n    This function finds the greatest fixed point of the equation:\n    p = min(p_bar, x + Pi.T @ p)\n    using a convergent iterative method starting from p = p_bar.\n\n    Args:\n        p_bar: Vector of total nominal liabilities.\n        x: Vector of external assets.\n        Pi: Relative liabilities matrix.\n\n    Returns:\n        The clearing payments vector p.\n    \"\"\"\n    n = len(p_bar)\n    # Initialize with the maximal element of the lattice [0, p_bar].\n    p = p_bar.copy()\n    \n    # Iterate until convergence.\n    # The sequence is non-increasing and bounded below, so it must converge.\n    for _ in range(1000):  # A sufficiently large number of iterations for convergence\n        p_prev = p.copy()\n        p = np.minimum(p_bar, x + Pi.T @ p_prev)\n        # Check for convergence using a small tolerance.\n        if np.allclose(p, p_prev, rtol=1e-12, atol=1e-12):\n            break\n            \n    return p\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 4,\n            \"p_bar\": np.array([10.0, 6.0, 6.0, 6.0]),\n            \"x\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"L\": np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 3.0, 3.0],\n                [1.0, 0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0, 0.0]\n            ]),\n            \"b\": 2.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n        # Test case 2\n        {\n            \"n\": 3,\n            \"p_bar\": np.array([5.0, 4.0, 4.0]),\n            \"x\": np.array([0.5, 0.5, 0.5]),\n            \"L\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 2.0],\n                [0.0, 1.0, 0.0]\n            ]),\n            \"b\": 0.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n        # Test case 3\n        {\n            \"n\": 3,\n            \"p_bar\": np.array([8.0, 3.0, 3.0]),\n            \"x\": np.array([1.0, 0.5, 0.5]),\n            \"L\": np.array([\n                [0.0, 3.0, 3.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0]\n            ]),\n            \"b\": 2.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        p_bar = case[\"p_bar\"]\n        x = case[\"x\"]\n        L = case[\"L\"]\n        b = case[\"b\"]\n        i_large = case[\"i_large\"]\n        i_small = case[\"i_small\"]\n\n        # Calculate the relative liabilities matrix Pi\n        Pi = np.zeros((n, n))\n        for i in range(n):\n            if p_bar[i] > 0:\n                Pi[i, :] = L[i, :] / p_bar[i]\n\n        # Scenario 1: Bailout injected into the smaller bank\n        x_small = x.copy()\n        x_small[i_small] += b\n        p_small = compute_clearing_vector(p_bar, x_small, Pi)\n        total_payments_small = np.sum(p_small)\n\n        # Scenario 2: Bailout injected into the largest bank\n        x_large = x.copy()\n        x_large[i_large] += b\n        p_large = compute_clearing_vector(p_bar, x_large, Pi)\n        total_payments_large = np.sum(p_large)\n        \n        # Calculate the difference delta\n        delta = total_payments_small - total_payments_large\n        results.append(f\"{delta:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}