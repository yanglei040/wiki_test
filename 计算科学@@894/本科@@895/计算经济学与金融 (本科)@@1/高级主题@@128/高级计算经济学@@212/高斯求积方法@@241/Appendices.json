{"hands_on_practices": [{"introduction": "高斯求积在金融中最直接的应用之一是对数正态世界中期权定价的期望计算。该练习使用高斯-埃尔米特求积法，这是对正态分布进行积分的自然选择。通过比较普通看涨期权（平滑支付）和数字看涨期权（不连续支付）的收敛速度，本练习将实际展示高斯求积法的一个关键特性：其效率与被积函数的平滑度密切相关。[@problem_id:2396797]", "id": "2396797", "problem": "考虑一个在风险中性测度下具有恒定无风险利率的无摩擦市场。设 $S_0 \\in \\mathbb{R}_{+}$, $K \\in \\mathbb{R}_{+}$, $r \\in \\mathbb{R}$, $\\sigma \\in \\mathbb{R}_{+}$ 及 $T \\in \\mathbb{R}_{+}$ 为固定参数。终端资产价格 $S_T$ 被建模为对数正态分布，其表达式为\n$$\nS_T \\;=\\; S_0 \\exp\\!\\big( (r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T}\\, Z \\big),\n$$\n其中 $Z \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。定义两种欧式支付：一种是支付为 $\\max\\{S_T - K, 0\\}$ 的普通看涨期权（vanilla call），另一种是支付为 $\\mathbf{1}\\{S_T > K\\}$ 的数字看涨期权（digital call）。在时间 $0$ 的无套利价格由风险中性期望给出：\n$$\nC \\;=\\; e^{-rT}\\,\\mathbb{E}\\!\\left[\\max\\{S_T - K,0\\}\\right],\\qquad D \\;=\\; e^{-rT}\\,\\mathbb{E}\\!\\left[\\mathbf{1}\\{S_T > K\\}\\right].\n$$\n对于数值近似，您必须通过在 $n \\in \\{4,8,16,32,64\\}$ 的有限确定性节点集上评估关于 $Z$ 的函数，将每个期望近似为关于标准正态分布的积分，并计算相对于精确解析值的绝对估值误差。$C$ 和 $D$ 的精确解析值是使用相同参数 $S_0$, $K$, $r$, $\\sigma$ 和 $T$ 通过封闭形式的 Black–Scholes 公式获得的值。\n\n给定以下参数集测试套件：\n- 测试用例1：$(S_0, K, r, \\sigma, T) = (100, 100, 0.03, 0.2, 1)$。\n- 测试用例2：$(S_0, K, r, \\sigma, T) = (100, 140, 0.03, 0.2, 1)$。\n- 测试用例3：$(S_0, K, r, \\sigma, T) = (100, 100, 0.03, 0.2, 0.01)$。\n\n对于每个测试用例、每个 $n \\in \\{4,8,16,32,64\\}$ 以及每种支付（普通看涨期权和数字看涨期权），计算数值近似价格与精确解析价格之间的绝对误差。您的程序必须按如下方式将所有结果汇总到单行输出中。对于按 $1,2,3$ 顺序排列的每个测试用例，首先按 $n$ 的升序列出 $n = 4, 8, 16, 32, 64$ 时普通看涨期权的 $5$ 个绝对误差，然后列出相同 $n$ 值下数字看涨期权的 $5$ 个绝对误差。将这三个测试用例的序列连接成一个单一列表。\n\n最终输出格式：您的程序应生成单行内容，其中包含一个浮点数列表，该列表按指定的确切顺序排列，用方括号括起来，各项之间用逗号分隔，例如 $[a_1,a_2,\\dots,a_{30}]$。", "solution": "所提出的问题是有效的。这是一个适定且有科学依据的计算金融学问题，需要将标准数值方法应用于一个典型模型。我将提供一个完整的解决方案。\n\n任务是使用数值积分法计算欧式普通看涨期权和欧式数字看涨期权的价格，并根据精确的 Black-Scholes 解析公式评估该方法的准确性。\n\n在风险中性框架中，衍生证券在时间 $t=0$ 的价格是其未来支付的贴现期望值。对于在时间 $T$ 的支付，如果该支付是终端资产价格 $S_T$ 的函数，则其价格 $V_0$ 由下式给出：\n$$\nV_0 = e^{-rT} \\mathbb{E}^{\\mathbb{Q}} [ \\text{Payoff}(S_T) ]\n$$\n其中 $r$ 是恒定无风险利率，$T$ 是到期时间，期望 $\\mathbb{E}^{\\mathbb{Q}}$ 是在风险中性测度 $\\mathbb{Q}$ 下计算的。终端资产价格 $S_T$ 被建模为对数正态随机变量：\n$$\nS_T = S_0 \\exp\\left( \\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T} Z \\right)\n$$\n其中 $Z$ 是一个标准正态随机变量，$Z \\sim \\mathcal{N}(0,1)$。\n\n该期望可以表示为关于标准正态概率密度函数 $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}$ 的积分。\n对于一个通用的支付函数 $P(S_T)$，其期望为：\n$$\n\\mathbb{E}^{\\mathbb{Q}}[P(S_T)] = \\int_{-\\infty}^{\\infty} P(S_T(z)) \\phi(z) dz\n$$\n其中 $S_T(z)$ 是作为随机变量 $Z$ 的实现值 $z$ 的函数的终端价格。\n\n对于普通看涨期权，其支付为 $\\max\\{S_T - K, 0\\}$，其价格 $C$ 为：\n$$\nC = e^{-rT} \\int_{-\\infty}^{\\infty} \\max\\{S_T(z) - K, 0\\} \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz\n$$\n对于数字看涨期权，其支付为 $\\mathbf{1}\\{S_T > K\\}$，其价格 $D$ 为：\n$$\nD = e^{-rT} \\int_{-\\infty}^{\\infty} \\mathbf{1}\\{S_T(z) > K\\} \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz\n$$\n\n为了对这些积分进行数值近似，我们采用 Gauss-Hermite 求积法。该方法专为形如 $\\int_{-\\infty}^{\\infty} e^{-x^2} g(x) dx$ 的积分设计。$n$ 点求积法则由下式给出：\n$$\n\\int_{-\\infty}^{\\infty} e^{-x^2} g(x) dx \\approx \\sum_{i=1}^n w_i g(x_i)\n$$\n其中 $x_i$ 是 $n$ 阶物理学家 Hermite 多项式 $H_n(x)$ 的根（节点），$w_i$ 是相关的权重。\n\n我们的积分涉及权重函数 $\\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}$，而不是 $e^{-x^2}$。因此需要进行变量替换。设 $z = \\sqrt{2}x$，这意味着 $dz = \\sqrt{2}dx$。项 $\\phi(z)dz$ 的变换如下：\n$$\n\\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz = \\frac{1}{\\sqrt{2\\pi}} e^{-(\\sqrt{2}x)^2/2} (\\sqrt{2}dx) = \\frac{\\sqrt{2}}{\\sqrt{2\\pi}} e^{-x^2} dx = \\frac{1}{\\sqrt{\\pi}} e^{-x^2} dx\n$$\n因此，对于函数 $f(z)$，该积分变为：\n$$\n\\int_{-\\infty}^{\\infty} f(z) \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz = \\int_{-\\infty}^{\\infty} f(\\sqrt{2}x) \\frac{1}{\\sqrt{\\pi}} e^{-x^2} dx = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} f(\\sqrt{2}x) e^{-x^2} dx\n$$\n应用 Gauss-Hermite 求积法则，我们得到近似值：\n$$\n\\mathbb{E}[f(Z)] \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^n w_i f(\\sqrt{2}x_i)\n$$\n其中 $(x_i, w_i)$ 是标准的 $n$ 点 Gauss-Hermite 节点和权重。\n\n对于给定的节点数 $n$，期权价格的数值近似值 $C_n$ 和 $D_n$ 为：\n$$\nC_n = \\frac{e^{-rT}}{\\sqrt{\\pi}} \\sum_{i=1}^n w_i \\max\\{S_T(\\sqrt{2}x_i) - K, 0\\}\n$$\n$$\nD_n = \\frac{e^{-rT}}{\\sqrt{\\pi}} \\sum_{i=1}^n w_i \\mathbf{1}\\{S_T(\\sqrt{2}x_i) > K\\}\n$$\n\n为了进行基准测试，我们使用 Black-Scholes 公式提供的精确解析解。我们定义项 $d_1$ 和 $d_2$：\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_2 = d_1 - \\sigma\\sqrt{T} = \\frac{\\ln(S_0/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n普通看涨期权的精确价格 $C_{BS}$ 为：\n$$\nC_{BS} = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2)\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数（CDF）。\n\n数字看涨期权的精确价格 $D_{BS}$ 对应于期权以价内状态结束的贴现概率，即 $\\mathbb{P}(S_T > K)$。该概率为 $\\Phi(d_2)$。因此：\n$$\nD_{BS} = e^{-rT} \\Phi(d_2)\n$$\n\n对于给定的 $n$，绝对估值误差计算为数值近似值与解析值之间的绝对差：\n$$\n\\epsilon_C(n) = |C_n - C_{BS}|\n$$\n$$\n\\epsilon_D(n) = |D_n - D_{BS}|\n$$\n\n该算法对每个测试用例按以下步骤进行：\n1. 使用所提供的参数计算解析价格 $C_{BS}$ 和 $D_{BS}$。\n2. 对于每个指定的节点数 $n \\in \\{4, 8, 16, 32, 64\\}$：\n    a. 获取 $n$ 点 Gauss-Hermite 节点 $\\{x_i\\}$ 和权重 $\\{w_i\\}$。\n    b. 计算标准正态积分对应的节点 $\\{z_i = \\sqrt{2}x_i\\}$。\n    c. 在这些节点上评估终端价格 $\\{S_T(z_i)\\}$。\n    d. 在每个节点上计算两种期权类型的支付。\n    e. 通过执行加权求和并乘以 $e^{-rT}/\\sqrt{\\pi}$ 来计算数值近似价格 $C_n$ 和 $D_n$。\n    f. 计算绝对误差 $\\epsilon_C(n)$ 和 $\\epsilon_D(n)$。\n3. 按照问题陈述中的规定收集并排序误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes absolute errors in option pricing using Gauss-Hermite quadrature\n    against analytical Black-Scholes formulas for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, K, r, sigma, T)\n        (100.0, 100.0, 0.03, 0.2, 1.0),\n        (100.0, 140.0, 0.03, 0.2, 1.0),\n        (100.0, 100.0, 0.03, 0.2, 0.01),\n    ]\n\n    # Number of quadrature points to test\n    n_values = [4, 8, 16, 32, 64]\n\n    # List to store all computed errors in the required order\n    all_results = []\n\n    def black_scholes_call(S0, K, r, sigma, T):\n        \"\"\"Analytical Black-Scholes price for a European vanilla call.\"\"\"\n        if T == 0:\n            return np.maximum(S0 - K, 0)\n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    def black_scholes_digital_call(K, r, sigma, T, d2):\n        \"\"\"Analytical Black-Scholes price for a European digital call.\"\"\"\n        if T == 0:\n            return 1.0 if S0 > K else 0.0\n        price = np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    for S0, K, r, sigma, T in test_cases:\n        # Calculate d2 once, as it's used in both analytical formulas\n        if T > 0:\n            d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        else:\n            d2 = np.inf if S0 > K else -np.inf # Edge case an T=0\n\n        # 1. Calculate analytical benchmark prices\n        C_bs = black_scholes_call(S0, K, r, sigma, T)\n        D_bs = black_scholes_digital_call(K, r, sigma, T, d2)\n        \n        call_errors_case = []\n        digital_errors_case = []\n\n        # 2. Loop through number of quadrature nodes\n        for n in n_values:\n            # a. Get Gauss-Hermite nodes and weights\n            x_i_herm, w_i_herm = np.polynomial.hermite.hermgauss(n)\n            \n            # b. Change of variables for standard normal integral N(0,1)\n            # z ~ N(0,1), integral is against (1/sqrt(2pi)) * exp(-z^2/2)\n            # We use x for Hermite integral, against exp(-x^2)\n            # Change of variables: z = sqrt(2)*x => dz = sqrt(2)*dx\n            # (1/sqrt(2pi))exp(-z^2/2)dz = (1/sqrt(pi))exp(-x^2)dx\n            # So, our integral approx is (1/sqrt(pi)) * sum(w_i * f(sqrt(2)*x_i))\n            z_nodes = np.sqrt(2.0) * x_i_herm\n            \n            # c. Evaluate terminal price at each node\n            drift = (r - 0.5 * sigma**2) * T\n            diffusion = sigma * np.sqrt(T) * z_nodes\n            S_T_nodes = S0 * np.exp(drift + diffusion)\n            \n            # d. Compute payoffs at each node\n            call_payoff = np.maximum(S_T_nodes - K, 0)\n            digital_payoff = (S_T_nodes > K).astype(float)\n            \n            # e. Calculate numerical prices\n            # The scaling factor is exp(-rT)/sqrt(pi)\n            scale_factor = np.exp(-r * T) / np.sqrt(np.pi)\n            C_n = scale_factor * np.sum(w_i_herm * call_payoff)\n            D_n = scale_factor * np.sum(w_i_herm * digital_payoff)\n            \n            # f. Compute and store absolute errors\n            call_errors_case.append(abs(C_n - C_bs))\n            digital_errors_case.append(abs(D_n - D_bs))\n            \n        # 3. Collect and order results for this test case\n        all_results.extend(call_errors_case)\n        all_results.extend(digital_errors_case)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"}, {"introduction": "在了解了非平滑性会如何降低收敛速度之后，我们现在来处理一种在行权价点上连续但不可微的支付函数。这种支付结构在奇异期权中很常见，对数值积分方法提出了挑战。本练习介绍了一种强大的技术——分段高斯求积法，它通过在问题点分割积分域，在每个子域上恢复快速收敛，从而确保估值准确性。[@problem_id:2396765]", "id": "2396765", "problem": "要求您在一个风险中性的对数正态资产定价环境中使用分段高斯求积方法，对一个具有不可微支付的或有债权进行稳健的数值估值。考虑一个标的资产，其初始水平为 $S_0$，连续复利无风险利率为 $r$，波动率为 $\\sigma$，到期日为 $T$。在 Black–Scholes 模型的标准无套利假设下，到期日 $T$ 的资产价格 $S_T$ 服从对数正态分布，其形式为：\n- $S_T = S_0 \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T}\\, Z\\right)$，\n- $Z \\sim \\mathcal{N}(0,1)$ 且 $Z$ 与 $S_0$ 相互独立。\n\n设支付函数为 $f(S_T) = \\lvert S_T - K \\rvert^{1/2}$，其中 $K$ 为一个固定的行权价。在时间 $t=0$ 的无套利价值是贴现后的风险中性期望：\n$$\nV(S_0,K,r,\\sigma,T) = e^{-rT}\\,\\mathbb{E}\\left[\\lvert S_T - K \\rvert^{1/2}\\right].\n$$\n\n您的任务是：\n- 从风险中性估值原理和 Black–Scholes 假设下 $S_T$ 的对数正态性出发。将期望公式化为一个关于标准正态变量 $Z$（其密度为 $\\varphi(z)$）的积分，并确保该积分对于 $S_T = K$ 处的不可微点是适定的。\n- 通过条件 $S_T(z^\\star) = K$ 识别出被积函数中出现不可微性的唯一奇点 $z^\\star$（如果存在）。解释该点如何划分变量 $z$ 的积分域。\n- 针对标准正态变量 $Z$，在一个截断的对称区间 $[-L,L]$ 上，基于 Gauss–Legendre 法则开发一种分段高斯求积方法，并在 $z^\\star$ 处分割该区间。使用一个从标准 Gauss–Legendre 节点（位于 $[-1,1]$上）到每个子区间的映射。您的设计必须讨论截断水平 $L$ 的选择，以控制 $[-L,L]$ 之外由 $\\lvert S_T - K \\rvert^{1/2}$ 产生的尾部误差。\n- 实现数值近似\n$$\nV \\approx e^{-rT}\\int_{-L}^{L} \\lvert S_0 \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T}\\, z\\right) - K \\rvert^{1/2} \\, \\varphi(z)\\, dz,\n$$\n使用分段 Gauss–Legendre 求积法，当 $z^\\star \\in (-L,L)$ 时，在 $z^\\star$ 处分割积分；否则，在整个区间 $[-L,L]$ 上应用单个 Gauss–Legendre 求积。此处，$\\varphi(z)$ 表示标准正态密度。您必须从 $[-1,1]$ 上的节点和权重出发，实现用于任意有限区间 $[a,b]$ 的通用 Gauss–Legendre 映射公式，并且您的程序必须根据第一性原理正确处理 $\\sigma = 0$ 和 $T = 0$ 的边界情况。\n- 程序必须是完全自包含的。不要读取任何输入。仅使用下面指定的参数，并打印所需的输出。\n\n参数约定和单位：\n- 所有利率和波动率都应视为无量纲小数（例如，$r = 0.05$ 表示每年 $0.05$，而不是 $5$ 百分比）。\n- 不存在角度；任何地方都不要使用度或弧度。\n- 在此问题中，货币量是无单位的；将值报告为纯数字。\n\n您的实现必须使用以下测试套件。对于每种情况，使用您的分段 Gauss–Legendre 方法计算近似值 $V$，截断水平 $L = 8$，左子区间使用 $n_{\\text{left}} = 64$ 个节点，右子区间使用 $n_{\\text{right}} = 64$ 个节点（如果由于分割点位于 $[-L,L]$ 之外而导致某个子区间为空，则在整个 $[-L,L]$ 区间上应用包含 $n_{\\text{left}} + n_{\\text{right}}$ 个节点的单个 Gauss–Legendre 法则）：\n\n- 情况 1：$(S_0, K, r, \\sigma, T) = (100, 100, 0.02, 0.2, 1)$。\n- 情况 2：$(S_0, K, r, \\sigma, T) = (100, 20, 0.01, 0.3, 1.5)$。\n- 情况 3：$(S_0, K, r, \\sigma, T) = (100, 100, 0.0, 0.25, 10^{-6})$。\n- 情况 4：$(S_0, K, r, \\sigma, T) = (80, 120, 0.03, 1.0, 2.0)$。\n- 情况 5：$(S_0, K, r, \\sigma, T) = (100, 100, 0.05, 0.05, 1.0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。该列表必须按照上述五种情况的顺序排列，并且每个值必须四舍五入到恰好 $10$ 位小数。例如，一个有效的输出行应如下所示：\n$[v_1,v_2,v_3,v_4,v_5]$\n其中每个 $v_i$ 是一个小数点后恰好有 $10$ 位数字的浮点数。", "solution": "所述问题是有效的。它是一个计算金融学中的适定问题，基于标准的 Black-Scholes 资产定价模型。该问题是客观、自包含的，并提供了唯一数值解所需的所有数据和定义。核心任务涉及对一个具有非标准支付函数 $f(S_T) = \\lvert S_T - K \\rvert^{1/2}$ 的欧式或有债权进行估值，该函数引入了一个不可微性。所规定的数值方法，即分段高斯求积，是处理此类被积函数以确保数值精度的恰当且标准的技术。不存在科学或逻辑上的矛盾。\n\n我们从第一性原理出发，给出一个完整的解。\n\n**1. 估值问题的积分表述**\n\n或有债权的无套利价值 $V$ 是其支付的贴现风险中性期望：\n$$\nV = e^{-rT} \\mathbb{E}\\left[ f(S_T) \\right] = e^{-rT} \\mathbb{E}\\left[ \\lvert S_T - K \\rvert^{1/2} \\right]\n$$\n在 Black-Scholes 模型的假设下，到期资产价格 $S_T$ 由下式给出\n$$\nS_T = S_0 \\exp\\left( (r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T} Z \\right)\n$$\n其中 $Z$ 是一个标准正态随机变量，$Z \\sim \\mathcal{N}(0,1)$。期望可以写成关于 $Z$ 的概率密度函数 $\\varphi(z)$ 的积分，其中 $\\varphi(z) = \\frac{1}{\\sqrt{2\\pi}}e^{-z^2/2}$。令 $h(z)$ 为变量 $z$ 的被积函数：\n$$\nh(z) = \\left| S_0 \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T} z\\right) - K \\right|^{1/2} \\varphi(z)\n$$\n则该债权的价值为\n$$\nV = e^{-rT} \\int_{-\\infty}^{\\infty} h(z) dz\n$$\n\n**2. 被积函数与不可微性分析**\n\n函数 $h(z)$ 在绝对值函数的参数为零处不可微。该点对应于 $S_T = K$。函数 $g(x) = |x|^{1/2}$ 的导数为 $g'(x) = \\frac{1}{2\\sqrt{|x|}}\\text{sgn}(x)$，在 $x=0$ 处未定义。如果天真地在整个定义域上应用，导数中的这个奇点会显著降低标准数值积分方法（如高斯求积）的收敛速度。\n\n为了用积分变量 $z$ 来定位这个点，我们令 $S_T(z) = K$：\n$$\nS_0 \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T} z\\right) = K\n$$\n在 $\\sigma > 0$ 和 $T > 0$ 的条件下，解出 $z$：\n$$\n(r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T} z = \\ln(K/S_0)\n$$\n$$\n\\sigma \\sqrt{T} z = \\ln(K/S_0) - (r - \\tfrac{1}{2}\\sigma^2)T\n$$\n这给出了一个唯一的不可微点，我们记为 $z^\\star$：\n$$\nz^\\star = \\frac{\\ln(K/S_0) - (r - \\tfrac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}\n$$\n该表达式等价于标准 Black-Scholes 期权定价公式中的 $-d_2$。为使问题非平凡，我们假设 $S_0 > 0$ 和 $K > 0$。\n\n**3. 分段高斯求积方法**\n\n为了获得积分的精确数值近似，我们采用两步策略：域截断和分段求积。\n\n首先，我们将无限积分域 $(-\\infty, \\infty)$ 截断为一个有限的对称区间 $[-L, L]$。标准正态密度 $\\varphi(z)$ 随着 $|z| \\to \\infty$ 而迅速衰减。按照问题指定选择 $L=8$ 可确保尾部被忽略的概率质量约为 $2\\Phi(-8) \\approx 1.24 \\times 10^{-15}$，对于大多数金融应用而言可以忽略不计。因此，该债权的价值近似为：\n$$\nV \\approx e^{-rT} \\int_{-L}^{L} h(z) dz\n$$\n\n其次，为处理 $z^\\star$ 处的不可微性，我们在此点划分积分区间 $[-L, L]$。如果 $z^\\star \\in (-L, L)$，则积分被分成两部分：\n$$\n\\int_{-L}^{L} h(z) dz = \\int_{-L}^{z^\\star} h(z) dz + \\int_{z^\\star}^{L} h(z) dz\n$$\n在每个子区间 $[-L, z^\\star]$ 和 $[z^\\star, L]$ 上，被积函数是无限可微的。这种光滑性使得 Gauss-Legendre 求积能够达到其特有的指数收敛速度。\n\n如果 $z^\\star \\notin (-L, L)$，则被积函数在整个区间 $[-L, L]$ 上是光滑的，可以在整个区间上应用单个 Gauss-Legendre 求积法则。\n\nGauss-Legendre 求积将标准区间 $[-1,1]$ 上的积分近似为一个加权和：\n$$\n\\int_{-1}^{1} f(x) dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n其中 $x_i$ 是节点（第 $n$ 阶 Legendre 多项式的根），$w_i$ 是相应的权重。为了将其应用于通用区间 $[a,b]$，我们使用线性变换 $z(x) = \\frac{b-a}{2} x + \\frac{a+b}{2}$，其雅可比为 $dz/dx = \\frac{b-a}{2}$。积分变为：\n$$\n\\int_{a}^{b} h(z) dz = \\int_{-1}^{1} h\\left(\\frac{b-a}{2}x + \\frac{a+b}{2}\\right) \\frac{b-a}{2} dx \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i h\\left(\\frac{b-a}{2}x_i + \\frac{a+b}{2}\\right)\n$$\n该公式将以指定的节点数（$n_{\\text{left}}=64$ 和 $n_{\\text{right}}=64$）应用于每个子区间。\n\n**4. 奇异情况处理**\n\n问题要求处理 $\\sigma=0$ 或 $T=0$ 的情况。在任一情况下，随机项 $\\sigma\\sqrt{T}Z$ 消失。到期资产价格 $S_T$ 变为确定性的：\n$$\nS_T = S_0 \\exp(rT)\n$$\n由于期望变得平凡，估值积分坍缩为：\n$$\n\\mathbb{E}\\left[ \\lvert S_T - K \\rvert^{1/2} \\right] = \\lvert S_0 e^{rT} - K \\rvert^{1/2}\n$$\n该债权的价值随后由一个简单的闭式表达式给出：\n$$\nV = e^{-rT} \\lvert S_0 e^{rT} - K \\rvert^{1/2}\n$$\n我们的实现必须正确识别这些情况并应用此公式，从而绕过数值积分。\n\n**5. 算法摘要**\n\n对于一组给定的参数 $(S_0, K, r, \\sigma, T)$：\n1. 检查奇异情况：如果 $T \\approx 0$ 或 $\\sigma \\approx 0$，使用确定性公式计算 $V$。\n2. 否则，定义完整被积函数 $h(z) = \\left| S_T(z) - K \\right|^{1/2} \\varphi(z)$。\n3. 计算分割点 $z^\\star$。\n4. 设置截断水平 $L=8$。\n5. 如果 $z^\\star \\in (-L, L)$：\n    a. 在 $[-L, z^\\star]$ 上应用具有 $n_{\\text{left}}=64$ 个节点的 Gauss-Legendre 求积。\n    b. 在 $[z^\\star, L]$ 上应用具有 $n_{\\text{right}}=64$ 个节点的 Gauss-Legendre 求积。\n    c. 总积分为 (a) 和 (b) 的结果之和。\n6. 如果 $z^\\star \\notin (-L, L)$：\n    a. 在单个区间 $[-L, L]$ 上应用具有 $n=n_{\\text{left}} + n_{\\text{right}} = 128$ 个节点的 Gauss-Legendre 求积。\n7. 最终价值为 $V = e^{-rT} \\times (\\text{总积分})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the value of a contingent claim with a non-differentiable payoff\n    using piecewise Gaussian quadrature, as specified in the problem statement.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100, 100, 0.02, 0.2, 1.0),\n        (100, 20, 0.01, 0.3, 1.5),\n        (100, 100, 0.0, 0.25, 1e-6),\n        (80, 120, 0.03, 1.0, 2.0),\n        (100, 100, 0.05, 0.05, 1.0),\n    ]\n\n    L = 8.0\n    n_left = 64\n    n_right = 64\n    \n    results = []\n\n    def gauss_legendre_quad(func, a, b, n):\n        \"\"\"\n        Performs Gauss-Legendre quadrature of a function 'func' over [a, b] using 'n' nodes.\n        Handles the case where a = b, returning 0.\n        \"\"\"\n        if np.isclose(a, b):\n            return 0.0\n        \n        nodes, weights = roots_legendre(n)\n        \n        # Map nodes from [-1, 1] to [a, b]\n        mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (a + b)\n        \n        # Evaluate the function at the mapped nodes\n        func_values = func(mapped_nodes)\n        \n        # Calculate the integral using the quadrature formula\n        integral = 0.5 * (b - a) * np.sum(weights * func_values)\n        \n        return integral\n\n    for case in test_cases:\n        S0, K, r, sigma, T = case\n\n        # Handle degenerate cases: deterministic asset price\n        if np.isclose(T, 0.0) or np.isclose(sigma, 0.0):\n            S_T = S0 * np.exp(r * T)\n            payoff = np.sqrt(np.abs(S_T - K))\n            value = np.exp(-r * T) * payoff\n            results.append(value)\n            continue\n            \n        # Define the integrand h(z) = |S_T(z) - K|^(1/2) * phi(z)\n        # where phi(z) is the standard normal PDF.\n        sqrt_T = np.sqrt(T)\n        drift = (r - 0.5 * sigma**2) * T\n        def integrand(z):\n            S_T = S0 * np.exp(drift + sigma * sqrt_T * z)\n            payoff_sqrt = np.sqrt(np.abs(S_T - K))\n            phi_z = (1.0 / np.sqrt(2.0 * np.pi)) * np.exp(-0.5 * z**2)\n            return payoff_sqrt * phi_z\n\n        # Find the non-differentiable point z_star\n        # where S_T(z_star) = K\n        #\n        # Note: We must ensure K/S0 > 0, which is true for all test cases.\n        # Catches potential warnings for log(0) if K is 0, though not in test data.\n        if K <= 0 or S0 <= 0:\n            # Fallback for ill-posed inputs not in test data\n            z_star = np.nan \n        else:\n            numerator = np.log(K / S0) - drift\n            denominator = sigma * sqrt_T\n            z_star = numerator / denominator\n\n        # Perform numerical integration\n        total_integral = 0.0\n        if -L < z_star < L:\n            # Piecewise quadrature: split at the singularity point\n            integral_left = gauss_legendre_quad(integrand, -L, z_star, n_left)\n            integral_right = gauss_legendre_quad(integrand, z_star, L, n_right)\n            total_integral = integral_left + integral_right\n        else:\n            # Singularity is outside the integration domain; use a single rule\n            total_integral = gauss_legendre_quad(integrand, -L, L, n_left + n_right)\n\n        # Discount the expected payoff to get the final value\n        value = np.exp(-r * T) * total_integral\n        results.append(value)\n\n    # Format the final output string as required\n    output_str = f\"[{','.join([f'{v:.10f}' for v in results])}]\"\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "许多金融模型涉及对非标准概率分布（如对数正态分布）的期望。本练习超越了直接使用高斯-埃尔米特等现成规则的范畴，教授了一项更基本的技能：通过变量变换，将标准的高斯-勒让德积分规则改造为一个针对特定概率测度的定制求积规则。掌握这种技术使您能够将高斯求积的强大功能应用于更广泛的金融工程问题。[@problem_id:2396760]", "id": "2396760", "problem": "考虑一个严格正随机变量 $X$，其定义为 $X=\\exp(\\mu+\\sigma Z)$，其中 $Z$ 是一个标准正态随机变量，$\\mu\\in\\mathbb{R}$ 且 $\\sigma&gt;0$。对于一个可测函数 $g:\\mathbb{R}_{+}\\to\\mathbb{R}$，其期望 $\\mathbb{E}[g(X)]$ 由 $\\int_{0}^{\\infty} g(x) f_{X}(x)\\,\\mathrm{d}x$ 给出，其中 $f_{X}$ 是由 $(\\mu,\\sigma)$ 导出的对数正态分布的概率密度函数。你的任务是通过变换区间 $[-1,1]$ 上的标准高斯-勒让德（Gauss–Legendre）积分法则，为 $\\mathbb{E}[g(X)]$ 构造一个数值积分法则。该新法则需要针对 $X$ 的分布进行积分，并将测度变换的效果体现在变换后的节点和权重中。\n\n你编写的程序必须对以下每个测试用例计算 $\\mathbb{E}[g(X)]$ 的数值近似值，并精确使用来自区间 $[-1,1]$ 上的标准高斯-勒让德积分法则的 $n=96$ 个节点：\n\n- 测试用例 1：$\\mu=0$, $\\sigma=0.25$, $g(x)=x$。\n- 测试用例 2：$\\mu=0.1$, $\\sigma=0.5$, $g(x)=x^{2}$。\n- 测试用例 3：$\\mu=-0.2$, $\\sigma=0.3$, $g(x)=\\ln(x)$。\n- 测试用例 4：$\\mu=0.05$, $\\sigma=0.6$, $g(x)=\\max(x-K,0)$，其中 $K=\\exp(\\mu)$。\n- 测试用例 5：$\\mu=0$, $\\sigma=10^{-6}$, $g(x)=x$。\n\n所有角度（若有）均须以弧度为单位。本问题不涉及任何物理单位。在报告数值时，每个近似值必须四舍五入到小数点后 $12$ 位。\n\n你的程序应生成单行输出，其中包含用方括号括起来并以逗号分隔的结果列表。顺序必须与上述测试用例一致，因此要求的格式是 $[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4},\\text{result}_{5}]$，其中每个 $\\text{result}_{i}$ 是一个四舍五入到小数点后 $12$ 位的浮点数。不应打印任何额外的文本或格式。", "solution": "所述问题是有效的。其科学基础在于数学金融学和数值分析理论，具体涉及对数正态分布随机变量的函数的期望及其通过高斯积分法的计算。该问题是适定、客观的，并包含推导唯一解所需的所有必要信息。我们将继续处理。\n\n目标是计算期望 $\\mathbb{E}[g(X)]$，其中随机变量 $X$ 服从对数正态分布，定义为 $X = \\exp(\\mu + \\sigma Z)$，且 $Z$ 是一个标准正态随机变量，$Z \\sim N(0,1)$。该期望由以下积分给出：\n$$ \\mathbb{E}[g(X)] = \\int_{0}^{\\infty} g(x) f_X(x) \\,dx $$\n其中 $f_X(x)$ 是对数正态分布的概率密度函数 (PDF)。进行数值评估的一条更直接的路径，是利用其底层的标准正态变量 $Z$ 来表示该期望。随机变量函数的期望定义为：\n$$ \\mathbb{E}[h(Z)] = \\int_{-\\infty}^{\\infty} h(z) f_Z(z) \\,dz $$\n其中 $f_Z(z) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-z^2/2)$ 是标准正态分布的概率密度函数。\n将 $X = \\exp(\\mu + \\sigma Z)$ 代入 $\\mathbb{E}[g(X)]$，我们得到：\n$$ \\mathbb{E}[g(X)] = \\mathbb{E}[g(\\exp(\\mu + \\sigma Z))] = \\int_{-\\infty}^{\\infty} g(\\exp(\\mu + \\sigma z)) \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} \\,dz $$\n此积分是在无穷域 $(-\\infty, \\infty)$ 上的。问题要求使用标准的、定义在有限区间 $[-1, 1]$ 上的高斯-勒让德（Gauss-Legendre）积分法则来对其进行近似。要使用该法则，我们必须将积分变量变换到这个区间上。\n\n一种标准且稳健的技术是逆变换采样法，也称为分位数函数法。令 $\\Phi(z)$ 为标准正态分布的累积分布函数 (CDF)。我们进行变量替换 $u = \\Phi(z)$。此变换将定义域 $z \\in (-\\infty, \\infty)$ 映射到 $u \\in (0, 1)$。其逆变换为 $z = \\Phi^{-1}(u)$，其中 $\\Phi^{-1}$ 是标准正态分布的分位数函数（或称 probit 函数）。其微分为 $du = \\Phi'(z) dz = \\phi(z) dz = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz$。\n\n将这些代入期望积分中，可得：\n$$ \\mathbb{E}[g(X)] = \\int_{0}^{1} g(\\exp(\\mu + \\sigma \\Phi^{-1}(u))) \\,du $$\n现在积分区间为有限区间 $(0, 1)$。为了应用在 $[-1, 1]$ 上的高斯-勒让德积分法则，我们对积分变量进行最后一次线性变换。令 $u = \\frac{t+1}{2}$，它将 $t \\in [-1, 1]$ 映射到 $u \\in [0, 1]$。其微分为 $du = \\frac{1}{2} dt$。积分变为：\n$$ \\mathbb{E}[g(X)] = \\int_{-1}^{1} g\\left(\\exp\\left(\\mu + \\sigma \\Phi^{-1}\\left(\\frac{t+1}{2}\\right)\\right)\\right) \\frac{1}{2} \\,dt $$\n该积分现在是 $\\int_{-1}^{1} F(t) dt$ 的标准形式，适用于高斯-勒让德积分法，其中被积函数为\n$$ F(t) = \\frac{1}{2} g\\left(\\exp\\left(\\mu + \\sigma \\Phi^{-1}\\left(\\frac{t+1}{2}\\right)\\right)\\right) $$\n积分 $\\int_{-1}^{1} F(t) dt$ 的 $n$ 点高斯-勒让德积分近似由 $\\sum_{i=1}^{n} w_i F(t_i)$ 给出，其中 $\\{t_i\\}_{i=1}^n$ 是节点（$n$ 阶勒让德多项式的根），而 $\\{w_i\\}_{i=1}^n$ 是相应的权重。\n因此，$\\mathbb{E}[g(X)]$ 的数值近似为：\n$$ \\mathbb{E}[g(X)] \\approx \\sum_{i=1}^{n} w_i \\left[ \\frac{1}{2} g\\left(\\exp\\left(\\mu + \\sigma \\Phi^{-1}\\left(\\frac{t_i+1}{2}\\right)\\right)\\right) \\right] $$\n其中根据题目要求 $n=96$。节点 $t_i$ 和权重 $w_i$ 可从标准数值库中获得。分位数函数 $\\Phi^{-1}$ 也是一个标准的特殊函数。\n\n该方法按要求构建了一个积分法则。我们可以定义变换后的节点 $\\tilde{x}_i$ 和变换后的权重 $\\tilde{w}_i$ 来直接近似 $\\int_0^\\infty g(x) f_X(x) dx$。令变换后的节点为 $\\tilde{x}_i = \\exp\\left(\\mu + \\sigma \\Phi^{-1}\\left(\\frac{t_i+1}{2}\\right)\\right)$，对应的权重为 $\\tilde{w}_i = w_i/2$。那么近似值即为 $\\sum_{i=1}^{n} \\tilde{w}_i g(\\tilde{x}_i)$。这展示了测度变换是如何被纳入构建过程中的。\n\n计算步骤如下：\n1.  获取区间 $[-1, 1]$ 上的 $n=96$ 个标准高斯-勒让德节点 $t_i$ 和权重 $w_i$。\n2.  对由参数 $\\mu$、$\\sigma$ 和函数 $g(x)$ 指定的每个测试用例：\n3.  对于每个节点 $t_i$：\n    a. 将节点变换到均匀域 $[0, 1]$：$u_i = (t_i+1)/2$。\n    b. 计算标准正态分位数：$z_i = \\Phi^{-1}(u_i)$。\n    c. 计算对数正态变量的值：$x_i = \\exp(\\mu + \\sigma z_i)$。\n    d. 评估函数值：$g(x_i)$。\n4.  计算最终总和：$\\text{结果} = \\frac{1}{2} \\sum_{i=1}^{n} w_i g(x_i)$。\n5.  将结果四舍五入到小数点后 $12$ 位。\n\n将为所有指定的测试用例实现此算法。\n\n- **测试用例 1**：$\\mu=0$, $\\sigma=0.25$, $g(x)=x$。解析解：$\\mathbb{E}[X] = \\exp(\\mu+\\sigma^2/2) = \\exp(0.03125) \\approx 1.031735515784$。\n- **测试用例 2**：$\\mu=0.1$, $\\sigma=0.5$, $g(x)=x^2$。解析解：$\\mathbb{E}[X^2] = \\exp(2\\mu+2\\sigma^2) = \\exp(0.7) \\approx 2.013752707470$。\n- **测试用例 3**：$\\mu=-0.2$, $\\sigma=0.3$, $g(x)=\\ln(x)$。解析解：$\\mathbb{E}[\\ln(X)] = \\mathbb{E}[\\mu+\\sigma Z] = \\mu = -0.2$。\n- **测试用例 4**：$\\mu=0.05$, $\\sigma=0.6$, $g(x)=\\max(x-K,0)$，其中 $K=\\exp(\\mu)$。这类似于欧式看涨期权的支付。解析值为 $e^{\\mu+\\sigma^2/2}\\Phi(\\sigma) - K\\Phi(0) \\approx 0.387819650393$。\n- **测试用例 5**：$\\mu=0$, $\\sigma=10^{-6}$, $g(x)=x$。这测试了 $\\sigma$ 很小时的数值稳定性。解析解是 $\\mathbb{E}[X] = \\exp(0.5 \\times 10^{-12}) \\approx 1.0 + 0.5 \\times 10^{-12}$。四舍五入到小数点后12位，结果为 $1.000000000001$。\n\n该实现将使用 `numpy` 进行向量化计算，并使用 `scipy.special` 中的 `roots_legendre` 和逆标准正态累积分布函数 `ndtri`。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, ndtri\n\ndef solve():\n    \"\"\"\n    Computes numerical approximations of E[g(X)] for a lognormal variable X\n    using a transformed Gauss-Legendre quadrature rule.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple contains: (mu, sigma, g_function, K)\n    # K is None if not applicable.\n    test_cases = [\n        (0.0, 0.25, lambda x, k: x, None),\n        (0.1, 0.5, lambda x, k: x**2, None),\n        (-0.2, 0.3, lambda x, k: np.log(x), None),\n        (0.05, 0.6, lambda x, k: np.maximum(x - k, 0), 'exp_mu'),\n        (0.0, 1e-6, lambda x, k: x, None)\n    ]\n    \n    n = 96  # Number of quadrature nodes as specified\n\n    # Get standard Gauss-Legendre nodes and weights for the interval [-1, 1]\n    t_nodes, l_weights = roots_legendre(n)\n\n    results = []\n    \n    for case in test_cases:\n        mu, sigma, g_func, k_spec = case\n        \n        # Determine the value of K if specified\n        K = None\n        if k_spec == 'exp_mu':\n            K = np.exp(mu)\n\n        # Vectorized calculation of the quadrature sum\n        # 1. Transform nodes from [-1, 1] to [0, 1] for CDF argument\n        u_nodes = (t_nodes + 1) / 2.0\n        \n        # 2. Compute standard normal quantiles (probit function)\n        # Add small epsilon to avoid u=0 or u=1 which result in inf\n        epsilon = 1e-16\n        u_nodes = np.clip(u_nodes, epsilon, 1 - epsilon)\n        z_nodes = ndtri(u_nodes)\n        \n        # 3. Compute the values of the lognormal variable at the transformed nodes\n        x_values = np.exp(mu + sigma * z_nodes)\n        \n        # 4. Evaluate the function g(x) for all x values\n        g_values = g_func(x_values, K)\n        \n        # 5. Compute the integral approximation using the quadrature rule\n        # The integral is transformed to 1/2 * integral on [-1, 1] dt\n        integral_approx = 0.5 * np.sum(l_weights * g_values)\n        \n        results.append(integral_approx)\n\n    # Format the final output as specified\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}