{"hands_on_practices": [{"introduction": "本“动手实践”章节旨在通过一系列精心设计的计算问题，帮助您将理论知识付诸实践。这些练习将引导您从基本的传染机制逐步过渡到更复杂的经济模型。我们的第一个练习将帮助您掌握冲击在网络中传播的基础知识，这是理解所有传染模型的第一步。\n\n我们将金融冲击的扩散想象成一个线性动力系统，其动态可以通过简单的矩阵迭代 $s_{t+1} = A^{\\top} s_t$ 来描述。通过编程实现这个基础模型，您将直观地体验冲击如何在网络中逐级传递，并学会量化系统性风险的两个基本指标：冲击的总质量和受困机构的数量。[@problem_id:2432984]", "id": "2432984", "problem": "考虑一个由 $n$ 家银行组成的银行间借贷网络，它由一个有向加权邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示，其中 $A_{ij}$ 是银行 $i$ 的一次冲击中传递给银行 $j$ 的部分。根据构造，对于每一行 $i$，$\\sum_{j=1}^{n} A_{ij} \\leq 1$。令 $s_t \\in \\mathbb{R}^n$表示在离散时间 $t \\in \\mathbb{N}_0$ 的非负冲击强度向量。冲击传播由以下线性递推关系定义：\n$$\ns_{t+1} = A^{\\top} s_t,\n$$\n给定初始条件 $s_0 \\in \\mathbb{R}^n_{\\ge 0}$。对于给定的非负阈值 $\\theta \\in \\mathbb{R}_{\\ge 0}$，将在时间 $T$ 陷入困境的银行数量定义为满足 $s_{T,i} \\ge \\theta$ 的索引 $i \\in \\{1,\\dots,n\\}$ 的数量。将在时间 $T$ 的总冲击质量定义为 1-范数 $\\lVert s_T \\rVert_1 = \\sum_{i=1}^n |s_{T,i}|$。\n\n您的任务是为下面指定的每个测试用例计算一个包含以下两项的数对：\n- 总冲击质量 $\\lVert s_T \\rVert_1$，使用标准四舍五入到小数点后 $6$ 位，以及\n- 在时间 $T$ 时，根据准则 $s_{T,i} \\ge \\theta$ 判定的陷入困境银行的整数数量。\n\n所有量都是无单位的。不涉及角度或百分比。\n\n测试套件：\n- 测试用例 $1$：\n  - $n = 6$。\n  - $A$ 的非零条目由三元组 $(i,j,w)$ 列表给出，表示 $A_{ij} = w$：\n    $$(0,1,0.5),\\ (0,2,0.3),\\ (1,2,0.4),\\ (1,3,0.4),\\ (2,3,0.6),\\ (3,4,0.5),\\ (4,5,0.3)。$$\n  - 初始冲击 $s_0 = [1,0,0,0,0,0]$。\n  - 期数 $T = 4$。\n  - 阈值 $\\theta = 0.15$。\n- 测试用例 $2$：\n  - $n = 4$。\n  - $A$ 的非零条目：\n    $$(0,1,1.0),\\ (1,2,1.0),\\ (2,3,1.0)。$$\n  - 初始冲击 $s_0 = [0,0,1,0]$。\n  - 期数 $T = 0$。\n  - 阈值 $\\theta = 0.5$。\n- 测试用例 $3$：\n  - $n = 3$。\n  - $A$ 没有非零条目。\n  - 初始冲击 $s_0 = [0,0.8,0]$。\n  - 期数 $T = 3$。\n  - 阈值 $\\theta = 0.1$。\n- 测试用例 $4$：\n  - $n = 5$。\n  - $A$ 的非零条目：\n    $$(0,1,1.0),\\ (1,2,1.0),\\ (2,3,1.0),\\ (3,4,1.0),\\ (4,0,1.0)。$$\n  - 初始冲击 $s_0 = [1,0,0,0,0]$。\n  - 期数 $T = 5$。\n  - 阈值 $\\theta = 0.4$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身就是一个双元素列表 $[\\lVert s_T \\rVert_1,\\ \\text{count}]$。例如，四个测试用例的有效输出格式为\n$$\n[[x_1,c_1],[x_2,c_2],[x_3,c_3],[x_4,c_4]]\n$$\n其中每个 $x_k$ 是一个四舍五入到小数点后 6 位的浮点数，每个 $c_k$ 是一个整数。", "solution": "该问题陈述已经过验证，被认为是有效的。它具有科学依据、问题设定良好、客观且完整。它描述了一个标准的离散时间线性动力系统，用于模拟网络传播现象，例如金融传染。所有测试用例的参数均已提供且一致。\n\n该问题要求分析一个包含 $n$ 家银行的网络中的冲击传播模型。其动态由线性递推关系决定：\n$$ s_{t+1} = A^{\\top} s_t $$\n其中 $s_t \\in \\mathbb{R}^n$ 是时间 $t \\in \\mathbb{N}_0$ 的冲击强度向量，而 $A \\in \\mathbb{R}^{n \\times n}$ 是该网络的加权邻接矩阵。条目 $A_{ij}$ 表示从银行 $i$ 传递到银行 $j$ 的冲击比例。对于每一行 $i$ 的条件 $\\sum_{j=1}^{n} A_{ij} \\leq 1$ 确保了任何银行传播的总冲击不超过其接收到的冲击，从而保证系统中的总冲击质量 $\\lVert s_t \\rVert_1$ 是非递增的。\n\n给定初始冲击向量 $s_0$，系统在任何未来时间 $T \\in \\mathbb{N}_0$ 的状态都通过递归应用传播规则来确定。在时间 $T$ 的解由以下公式给出：\n$$ s_T = (A^{\\top})^T s_0 $$\n这可以通过算法计算，方法是：将向量 $s$ 初始化为 $s_0$，然后通过 $T$ 次矩阵向量乘法迭代更新它：$s \\leftarrow A^{\\top} s$。\n\n银行间网络由 $A$ 的非零条目列表指定，这意味着对于任何现实规模的网络（$n$ 很大），矩阵 $A$ 都是稀疏的。为了高效处理，必须使用稀疏矩阵数据结构和算法。所提供的三元组 $(i,j,w)$ 自然地以坐标（COO）格式定义了矩阵。为了高效地进行重复的矩阵向量乘法，最好将此矩阵转换为压缩稀疏行（CSR）或压缩稀疏列（CSC）等格式。对于稀疏矩阵，转置操作 $A^{\\top}$ 的计算成本很低。\n\n解决每个测试用例的算法如下：\n\n$1$。 **矩阵构造**：根据给定的三元组列表 $(i,j,w)$ 构造矩阵 $A$，其中 $A_{ij} = w$。我们使用稀疏矩阵表示，例如 `scipy.sparse` 库中的表示。鉴于测试用例中采用基于 0 的索引，我们构建一个 $n \\times n$ 的稀疏矩阵。\n\n$2$。 **迭代冲击传播**：我们用给定的 $s_0$ 初始化冲击向量 $s$。然后，我们模拟 $T$ 个时间步的传播。对于从 $0$ 到 $T-1$ 的每一步 $t$，我们通过计算 $s_{t+1} = A^{\\top} s_t$ 来更新冲击向量。如果 $T=0$，最终冲击向量就是 $s_0$。\n\n$3$。 **指标计算**：经过 $T$ 次迭代，我们得到最终冲击向量 $s_T$。从此向量中，我们计算两个量：\n    - 总冲击质量，即 $s_T$ 的 $L_1$-范数，$\\lVert s_T \\rVert_1 = \\sum_{i=1}^{n} |s_{T,i}|$。由于初始冲击 $s_0$ 是非负的，且 $A$ 的所有条目都是非负的，因此所有后续的冲击向量 $s_t$ 也将是非负的。因此，范数就是向量各分量的总和，$\\sum_{i=1}^{n} s_{T,i}$。然后将此值四舍五入到小数点后 6 位。\n    - 陷入困境的银行数量，即冲击强度 $s_{T,i}$ 达到或超过给定阈值 $\\theta$ 的索引 $i$ 的数量，即 $|\\{i \\in \\{1,\\dots,n\\} \\mid s_{T,i} \\ge \\theta\\}|$。\n\n$4$。 **输出格式化**：对于每个测试用例，将计算出的值对（四舍五入后的总冲击质量和陷入困境银行的整数数量）格式化为一个列表，并将所有测试用例的结果按要求汇总到一个列表的列表中。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix\n\ndef solve():\n    \"\"\"\n    Solves the shock propagation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6,\n            \"A_triples\": [(0, 1, 0.5), (0, 2, 0.3), (1, 2, 0.4), (1, 3, 0.4), (2, 3, 0.6), (3, 4, 0.5), (4, 5, 0.3)],\n            \"s0\": [1, 0, 0, 0, 0, 0],\n            \"T\": 4,\n            \"theta\": 0.15,\n        },\n        {\n            \"n\": 4,\n            \"A_triples\": [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)],\n            \"s0\": [0, 0, 1, 0],\n            \"T\": 0,\n            \"theta\": 0.5,\n        },\n        {\n            \"n\": 3,\n            \"A_triples\": [],\n            \"s0\": [0, 0.8, 0],\n            \"T\": 3,\n            \"theta\": 0.1,\n        },\n        {\n            \"n\": 5,\n            \"A_triples\": [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0), (3, 4, 1.0), (4, 0, 1.0)],\n            \"s0\": [1, 0, 0, 0, 0],\n            \"T\": 5,\n            \"theta\": 0.4,\n        }\n    ]\n\n    results_str_list = []\n    for case in test_cases:\n        n = case[\"n\"]\n        A_triples = case[\"A_triples\"]\n        s0 = case[\"s0\"]\n        T = case[\"T\"]\n        theta = case[\"theta\"]\n\n        # 1. Construct the sparse matrix A and its transpose A_T.\n        if not A_triples:\n            # If there are no non-zero entries, A is the zero matrix.\n            A = coo_matrix((n, n), dtype=float)\n        else:\n            rows, cols, data = zip(*A_triples)\n            A = coo_matrix((data, (rows, cols)), shape=(n, n), dtype=float)\n        \n        # Using CSC format for A.T is efficient for matrix-vector products.\n        A_T = A.T.tocsc()\n\n        # 2. Iteratively compute the shock propagation.\n        s = np.array(s0, dtype=float)\n        for _ in range(T):\n            s = A_T @ s\n        \n        s_T = s\n\n        # 3. Calculate total shock mass and the number of distressed banks.\n        # Since s0 >= 0 and A >= 0, s_T will be non-negative.\n        total_mass = np.sum(s_T)\n        distressed_count = np.sum(s_T >= theta)\n        \n        # 4. Format the result for the current test case.\n        # \"standard rounding\" is taken to be Python's built-in round.\n        rounded_mass = round(total_mass, 6)\n        \n        # Format the float to a string with 6 decimal places.\n        mass_str = f'{rounded_mass:.6f}'\n        \n        result_str = f'[{mass_str},{distressed_count}]'\n        results_str_list.append(result_str)\n\n    # 5. Print the final results in the required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"}, {"introduction": "在掌握了线性传播模型后，我们来探讨一个更接近现实的非线性现象：传染级联。许多复杂的系统都存在“引爆点”，即一个小扰动可能不会产生任何影响，也可能引发大规模的系统性崩溃。本练习将通过一个基于逾渗理论的阈值模型来帮助您理解这一概念。\n\n在这个模型中，一个机构的违约并非与其受到的冲击成正比，而是当其关联对手的违约数量达到一个关键阈值 $T$ 时才会发生。通过在不同拓扑结构（如路径图、星形图和网格图）的网络上进行模拟，您将深入理解网络连通性模式如何放大或抑制传染，这是系统性风险分析中的一个核心概念。[@problem_id:2426234]", "id": "2426234", "problem": "考虑一个在有限、简单、无向图上的传染过程，其灵感来源于应用于金融网络的渗流理论。设图表示为 $G = (V,E)$，其中 $|V| = N$。每个顶点代表一家银行，每条无向边代表一种双边风险暴露。银行的状态可以是稳健的（活跃）或失效的（非活跃）。传染过程以离散时间步演化，遵循同步阈值规则（一种自举渗流）：如果一个稳健顶点在当前时间步至少有 $T$ 个邻居处于失效状态，则它在下一个时间步会失效；失效的顶点将永远保持失效状态。该动态过程从一个指定的初始失效集合 $S_0 \\subseteq V$ 开始。\n\n基本原理和定义：\n- 状态是一个函数 $x: V \\to \\{0,1\\}$，如果顶点 $i$ 失效，则 $x(i) = 1$，否则 $x(i) = 0$。\n- 顶点 $i \\in V$ 的邻域是 $N(i) = \\{j \\in V : (i,j) \\in E\\}$。\n- 给定阈值 $T \\in \\mathbb{Z}$，同步更新规则为：对于每个顶点 $i \\in V$，\n$$\nx_{t+1}(i) = \\begin{cases}\n1, & \\text{如果 } x_t(i) = 1 \\text{ 或 } \\sum_{j \\in N(i)} x_t(j) \\ge T, \\\\\n0, & \\text{否则。}\n\\end{cases}\n$$\n- 当首次出现 $x_{t^\\star+1} = x_{t^\\star}$ 时，过程在时间 $t^\\star$ 停止，最终失效集合为 $S_\\infty = \\{ i \\in V : x_{t^\\star}(i) = 1 \\}$。最终失效比例为 $|S_\\infty|/N$。\n\n任务：\n- 实现一个程序，为每个指定的测试用例（图 $G$、阈值 $T$ 和初始失效集合 $S_0$）计算在上述定义的同步阈值动态过程下的最终失效比例 $|S_\\infty|/N$。任何测试用例中都没有随机性。仅使用所述规则，并在到达不动点时停止。\n\n算法要求：\n- 使用同步更新：所有顶点根据时间 $t$ 的状态评估其失效条件，并同时更新以产生时间 $t+1$ 的状态。\n- 图是简单且无向的；不包含自环或平行边。\n- 初始状态 $x_0$ 由 $S_0$ 定义：对于 $i \\in S_0$，有 $x_0(i)=1$，否则 $x_0(i)=0$。\n- 阈值为整数。如果 $T \\le 0$，则所有顶点在 $t=1$ 时失效。如果 $T$ 大于某个顶点的度，则该顶点除非在 $S_0$ 中，否则不会失效。\n\n测试套件：\n对以下6个案例中的每一个，计算最终失效比例 $|S_\\infty|/N$（四舍五入到6位小数）。在所有案例中，顶点都用从0开始的连续整数进行标记。\n\n- 案例1（路径图级联）：\n  - 图：具有 $N=5$ 个顶点的路径图，边集为 $\\{(0,1),(1,2),(2,3),(3,4)\\}$。\n  - 阈值：$T=1$。\n  - 初始失效集合：$S_0=\\{0\\}$。\n\n- 案例2（路径图被更高阈值阻塞）：\n  - 图：具有 $N=5$ 个顶点的路径图，边集为 $\\{(0,1),(1,2),(2,3),(3,4)\\}$。\n  - 阈值：$T=2$。\n  - 初始失效集合：$S_0=\\{2\\}$。\n\n- 案例3（中心为0的星形图）：\n  - 图：具有 $N=6$ 个顶点的星形图，边集为 $\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$。\n  - 阈值：$T=3$。\n  - 初始失效集合：$S_0=\\{1,2,3\\}$。\n\n- 案例4（具有4邻居连通性的网格图）：\n  - 图：$3\\times 3$ 的方形网格（$N=9$），具有4邻居邻接性。使用行主序索引：顶点 $(r,c)$（行 $r \\in \\{0,1,2\\}$，列 $c \\in \\{0,1,2\\}$）映射到索引 $i = 3r + c$。当且仅当两个顶点在同一行或同一列上相距一个单位距离时，它们是邻接的。\n  - 阈值：$T=2$。\n  - 初始失效集合：$S_0=\\{1,3\\}$。\n\n- 案例5（零阈值的三角形）：\n  - 图：具有 $N=3$ 个顶点的环形图（一个三角形），边集为 $\\{(0,1),(1,2),(2,0)\\}$。\n  - 阈值：$T=0$。\n  - 初始失效集合：$S_0=\\emptyset$。\n\n- 案例6（高阈值的环形图）：\n  - 图：具有 $N=4$ 个顶点的环形图，边集为 $\\{(0,1),(1,2),(2,3),(3,0)\\}$。\n  - 阈值：$T=3$。\n  - 初始失效集合：$S_0=\\{0,1,2\\}$。\n\n输出规范：\n- 对于每个测试用例，将最终失效比例 $|S_\\infty|/N$ 计算为一个四舍五入到6位小数的浮点数。\n- 您的程序应生成单行输出，其中包含按案例1到案例6顺序排列的结果，以逗号分隔并用方括号括起来，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_k$ 是案例 $k$ 的四舍五入值。\n- 不要读取任何输入。将测试套件嵌入程序中。输出必须是符合指定格式的单行文本。\n\n不涉及物理单位。不涉及角度。按规定将所有比例表示为四舍五入到6位的小数。", "solution": "所提出的问题是网络动力学领域一个定义明确的计算练习，具体是通过图上的自举渗流来模拟传染过程。在进行求解之前，有必要进行严格的验证。\n\n首先，从问题陈述中提取所有给定条件。\n该模型是一个在具有 $|V| = N$ 个顶点的有限、简单、无向图 $G=(V, E)$ 上的传染过程。顶点 $i \\in V$ 处于两种状态之一：稳健 ($x(i)=0$) 或失效 ($x(i)=1$)。动态过程以离散时间步 $t$ 演化，遵循同步阈值规则。如果一个稳健顶点 $i$ 在时间 $t$ 的失效邻居数量 $\\sum_{j \\in N(i)} x_t(j)$ 大于或等于阈值 $T$，则它在时间 $t+1$ 会失效。失效的顶点将保持失效状态。该过程从一个初始失效顶点集合 $S_0$ 开始，当达到不动点时终止，得到最终失效集合 $S_\\infty$。目标是计算最终失效比例 $|S_\\infty|/N$。问题提供了六个具体的测试用例，每个用例都由一个图、一个阈值 $T$ 和一个初始集合 $S_0$ 定义。\n\n接下来，根据所需标准对问题进行验证。\n1.  **科学上成立：** 该模型是一个标准的确定性阈值模型，是复杂网络、元胞自动机和统计物理学研究中的一个基本概念。它在数学上是合理的，并基于既定原则。该问题不含伪科学或猜想。\n2.  **适定性：** 该问题是适定的。状态空间是有限的，包含 $2^N$ 种可能的构型。动态过程是单调的，因为顶点一旦失效，就绝不会恢复到稳健状态。这确保了系统从任何初始条件出发，在至多 $N$ 个时间步内必然达到一个唯一的不动点。\n3.  **客观性：** 问题以精确、无歧义的数学语言陈述。所有术语，如“同步更新”、“邻域”和“阈值”，都有清晰的定义。\n4.  **完整性和一致性：** 每个测试用例都用所有必要的数据进行了完整指定：顶点数 $N$、边集 $E$、整数阈值 $T$ 和初始失效集合 $S_0$。规则是内部一致的。\n5.  **可行性：** 测试套件中的图很小，使得模拟在计算上微不足道且易于求解。\n\n结论是该问题是 **有效的**。它是一个清晰、自洽且可解的计算任务。现在可以构建解决方案了。\n\n解决方案的核心是模拟同步动态过程的算法。系统状态由一个二元向量 $\\mathbf{x} \\in \\{0, 1\\}^N$ 表示。图拓扑被编码在一个邻接矩阵 $A$ 中，这是一个 $N \\times N$ 的矩阵，如果顶点 $i$ 和 $j$ 之间存在边，则 $A_{ij}=1$，否则 $A_{ij}=0$。\n\n模拟算法按以下步骤进行：\n1.  **初始化**：根据给定的集合 $S_0$ 初始化时间 $t=0$ 时的状态向量，记为 $\\mathbf{x}_0$。对每个顶点 $i \\in V$，如果 $i \\in S_0$，则 $x_0(i) = 1$，否则 $x_0(i) = 0$。\n\n2.  **迭代**：系统状态被迭代更新，直到达到一个不动点。在每个时间步 $t$，状态 $\\mathbf{x}_{t+1}$ 根据 $\\mathbf{x}_t$ 计算得出。\n    a. 首先，必须计算每个顶点的失效邻居数量。这可以通过一次矩阵-向量乘法高效地为所有顶点同时完成。设 $\\mathbf{c}_t$ 是时间 $t$ 的失效邻居计数向量。那么，\n    $$\n    \\mathbf{c}_t = A \\cdot \\mathbf{x}_t\n    $$\n    $\\mathbf{c}_t$ 的第 $i$ 个分量，记为 $c_t(i)$，恰好是 $\\sum_{j \\in N(i)} x_t(j)$。\n\n    b. 根据同步更新规则，状态向量 $\\mathbf{x}_{t+1}$ 仅通过考虑时间 $t$ 的状态来确定。如果一个顶点 $i$ 在时间 $t$ 已经失效，或者它在时间 $t$ 是稳健的且其失效邻居数量达到了阈值，那么它将在下一步失效。对于每个顶点 $i$ 可表示为：\n    $$\n    x_{t+1}(i) = 1 \\quad \\text{if} \\quad (x_t(i) = 1) \\lor (x_t(i)=0 \\land c_t(i) \\ge T)\n    $$\n    等价地，可以识别出所有稳健顶点的集合 $\\{ i \\mid x_t(i)=0 \\}$，并从中找出满足 $c_t(i) \\ge T$ 的顶点子集。这些就是将要新失效的顶点。\n\n    c. 通过将这些新失效顶点对应的分量设置为1，来形成新的状态向量 $\\mathbf{x}_{t+1}$。\n\n3.  **终止**：迭代过程持续进行，直到状态不再改变，即当 $\\mathbf{x}_{t+1} = \\mathbf{x}_t$ 时。此时，系统已达到一个稳定不动点，$\\mathbf{x}_\\infty = \\mathbf{x}_t$。\n\n4.  **最终计算**：终止时，最终失效顶点的数量为 $|S_\\infty| = \\sum_{i=0}^{N-1} x_\\infty(i)$。所要求的最终失效比例是该总数除以总顶点数 $N$。\n\n该算法被实现并应用于六个测试用例中的每一个。对于每个用例，利用图结构构建邻接矩阵 $A$，并根据 $S_0$ 构建初始状态向量 $\\mathbf{x}_0$。模拟循环一直运行直到收敛，然后计算最终比例并按要求四舍五入到6位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, edges, T, S0):\n    \"\"\"\n    Simulates the synchronous threshold contagion process on a graph.\n\n    Args:\n        N (int): The number of vertices in the graph.\n        edges (list of tuples): The list of edges defining the graph.\n        T (int): The failure threshold.\n        S0 (set): The set of initially failed vertices.\n\n    Returns:\n        float: The final fraction of failed vertices.\n    \"\"\"\n    # 1. Build the adjacency matrix from the edge list.\n    adj_matrix = np.zeros((N, N), dtype=int)\n    for u, v in edges:\n        adj_matrix[u, v] = 1\n        adj_matrix[v, u] = 1\n\n    # 2. Initialize the state vector based on the initial failed set S0.\n    x = np.zeros(N, dtype=int)\n    if S0:\n        # The set S0 might be empty.\n        initial_indices = list(S0)\n        x[initial_indices] = 1\n\n    # 3. Run the simulation loop until a fixed point is reached.\n    while True:\n        # Store the current state to check for convergence later.\n        x_old = x.copy()\n        \n        # Calculate the number of failed neighbors for each vertex using a\n        # matrix-vector product. This is the core of the state evaluation.\n        failed_neighbors_count = adj_matrix @ x_old\n\n        # Identify solvent vertices that are to fail in this step.\n        # A vertex `i` fails if it is currently solvent (x_old[i] == 0) and\n        # its number of failed neighbors meets the threshold (failed_neighbors_count[i] >= T).\n        # This is a vectorized implementation of the synchronous update rule.\n        solvent_mask = (x_old == 0)\n        threshold_met_mask = (failed_neighbors_count >= T)\n        \n        # The new failures occur where both conditions are true.\n        newly_failed_mask = solvent_mask & threshold_met_mask\n        \n        # If there are no new failures, the system has reached a fixed point.\n        if not np.any(newly_failed_mask):\n            break\n            \n        # Update the state vector by setting the newly failed vertices to 1.\n        x[newly_failed_mask] = 1\n\n    # 4. Calculate the final failed fraction.\n    final_failed_count = np.sum(x)\n    return final_failed_count / N\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the contagion model.\n    \"\"\"\n    # Define the 6 test cases as specified in the problem statement.\n    # Each case is a tuple: (N, edges, T, S0)\n    \n    # Case 1: Path graph cascade\n    case1 = (5, [(0, 1), (1, 2), (2, 3), (3, 4)], 1, {0})\n    \n    # Case 2: Path graph blocked\n    case2 = (5, [(0, 1), (1, 2), (2, 3), (3, 4)], 2, {2})\n    \n    # Case 3: Star graph\n    case3 = (6, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], 3, {1, 2, 3})\n    \n    # Case 4: 3x3 grid graph\n    grid_edges = []\n    rows, cols = 3, 3\n    for r in range(rows):\n        for c in range(cols):\n            i = r * cols + c\n            # Horizontal connection to the right\n            if c < cols - 1:\n                grid_edges.append((i, i + 1))\n            # Vertical connection downwards\n            if r < rows - 1:\n                grid_edges.append((i, i + cols))\n    case4 = (9, grid_edges, 2, {1, 3})\n    \n    # Case 5: Triangle with zero threshold\n    case5 = (3, [(0, 1), (1, 2), (2, 0)], 0, set())\n    \n    # Case 6: Ring with high threshold\n    case6 = (4, [(0, 1), (1, 2), (2, 3), (3, 0)], 3, {0, 1, 2})\n\n    test_cases = [case1, case2, case3, case4, case5, case6]\n\n    results = []\n    for N, edges, T, S0 in test_cases:\n        fraction = run_simulation(N, edges, T, S0)\n        # Format the result to 6 decimal places as required.\n        results.append(f\"{fraction:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "前面的练习让我们熟悉了传染的抽象网络动力学，现在我们将这些概念应用于一个更加具体和经济意义明确的框架。银行在现实世界中是如何违约的？本练习将引导您使用金融系统风险领域的经典模型——Eisenberg–Noe 清算模型来回答这个问题。\n\n该模型不再将违约视为一个抽象状态，而是将其定义为银行资产不足以偿还其负债的经济后果，其中银行资产包括外部资产及其从其他银行收到的还款。您需要通过迭代计算找到系统的支付均衡点（一个不动点），并比较单一银行受冲击（个体性风险）与整个市场同受压力（共同性风险）两种情形下的系统稳定性。这个练习将让您亲身体验学者和监管机构评估系统性风险的真实方法。[@problem_id:2410802]", "id": "2410802", "problem": "给定一个由 $n$ 家银行组成的封闭金融网络，网络中包含名义银行间负债和外部资产。设名义负债矩阵为 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $L_{ij}$ 是银行 $i$ 欠银行 $j$ 的金额。定义银行 $i$ 的名义银行间总负债为 $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$，并定义一个向量 $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$，其元素为 $\\bar{p}_i$。设相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 由 $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$（如果 $\\bar{p}_i > 0$）和 $\\Pi_{ij} = 0$（如果 $\\bar{p}_i = 0$）给出。设 $x \\in \\mathbb{R}_{\\ge 0}^{n}$ 是外部（非银行间）资产向量。\n\n考虑两种应用于外部资产的冲击情景：\n- 对单一银行 $k \\in \\{1,\\dots,n\\}$ 的特定冲击，冲击幅度为 $s_{\\mathrm{id}} \\in [0,1]$（以小数而非百分比表示）：冲击后的外部资产为 $x^{\\mathrm{id}}$，其中 $x^{\\mathrm{id}}_k = (1 - s_{\\mathrm{id}})\\, x_k$，且对于所有 $i \\ne k$，$x^{\\mathrm{id}}_i = x_i$。\n- 共同（相关）压力，幅度为 $s_{\\mathrm{com}} \\in [0,1]$（以小数而非百分比表示）：冲击后的外部资产为 $x^{\\mathrm{com}}$，其中对于所有 $i$，$x^{\\mathrm{com}}_i = (1 - s_{\\mathrm{com}})\\, x_i$。\n\n假设在 Eisenberg–Noe (EN) 清算机制的意义下，实行有限责任下的按比例偿付。对于给定的冲击后外部资产向量 $x' \\in \\{x^{\\mathrm{id}}, x^{\\mathrm{com}}\\}$，清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 必须满足\n$$\np = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big),\n$$\n其中最小值为逐元素取值。如果 $p_i < \\bar{p}_i$，则称银行 $i$ 违约。设违约银行数量为 $D(x') = \\sum_{i=1}^n \\mathbf{1}\\{p_i < \\bar{p}_i\\}$，未偿付负债总额为 $U(x') = \\sum_{i=1}^n (\\bar{p}_i - p_i)$。\n\n您的任务是，为下方的每个测试用例，计算在两种情景下的指标对：违约银行数量和未偿付负债总额。每个测试用例需返回一个列表 $[D(x^{\\mathrm{id}}), D(x^{\\mathrm{com}}), U(x^{\\mathrm{id}}), U(x^{\\mathrm{com}})]$，其中未偿付负债 $U(\\cdot)$ 必须四舍五入到六位小数。\n\n所有货币金额单位一致，为任意单位（无需单位转换）。冲击幅度必须视为 $[0,1]$ 范围内的小数。\n\n测试套件（每个测试用例指定 $n$, $L$, $x$, $k$, $s_{\\mathrm{id}}$, $s_{\\mathrm{com}}$）：\n\n- 测试用例 1：\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0 & 2 & 1 & 2 \\\\\n1 & 0 & 1 & 2 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 2 & 0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 1,\\quad\ns_{\\mathrm{id}} = 0.6,\\quad\ns_{\\mathrm{com}} = 0.3.\n$$\n\n- 测试用例 2（基准线，无冲击）：\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0 & 2 & 1 & 2 \\\\\n1 & 0 & 1 & 2 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 2 & 0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 3,\\quad\ns_{\\mathrm{id}} = 0.0,\\quad\ns_{\\mathrm{com}} = 0.0.\n$$\n\n- 测试用例 3（严重压力比较）：\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0 & 2 & 1 & 2 \\\\\n1 & 0 & 1 & 2 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 2 & 0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 2,\\quad\ns_{\\mathrm{id}} = 0.9,\\quad\ns_{\\mathrm{com}} = 0.75.\n$$\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个以逗号分隔的列表，并用方括号括起来，其中每个元素是对应一个测试用例的列表。例如，一个有效的结构是\n$[[D_1^{\\mathrm{id}}, D_1^{\\mathrm{com}}, U_1^{\\mathrm{id}}, U_1^{\\mathrm{com}}],[D_2^{\\mathrm{id}}, D_2^{\\mathrm{com}}, U_2^{\\mathrm{id}}, U_2^{\\mathrm{com}}],\\dots]$。", "solution": "对问题进行验证。\n\n**第 1 步：提取已知条件**\n\n-   银行数量：$n$。\n-   名义负债矩阵：$L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $L_{ij}$ 是银行 $i$ 欠银行 $j$ 的金额。\n-   银行 $i$ 的名义银行间总负债：$\\bar{p}_i = \\sum_{j=1}^n L_{ij}$。向量形式为：$\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$。\n-   相对负债矩阵：$\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$（如果 $\\bar{p}_i > 0$），且 $\\Pi_{ij} = 0$（如果 $\\bar{p}_i = 0$）。\n-   外部资产向量：$x \\in \\mathbb{R}_{\\ge 0}^{n}$。\n-   特定冲击：影响单一银行 $k \\in \\{1,\\dots,n\\}$，幅度为 $s_{\\mathrm{id}} \\in [0,1]$。冲击后的资产为 $x^{\\mathrm{id}}$，其中 $x^{\\mathrm{id}}_k = (1 - s_{\\mathrm{id}})\\, x_k$，且对于 $i \\ne k$，$x^{\\mathrm{id}}_i = x_i$。\n-   共同冲击：影响所有银行，幅度为 $s_{\\mathrm{com}} \\in [0,1]$。冲击后的资产为 $x^{\\mathrm{com}}$，其中对于所有 $i$，$x^{\\mathrm{com}}_i = (1 - s_{\\mathrm{com}})\\, x_i$。\n-   清算支付向量：$p \\in \\mathbb{R}_{\\ge 0}^{n}$ 是不动点方程 $p = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)$ 的一个解，其中 $x'$ 是冲击后的资产向量。\n-   违约条件：如果银行 $i$ 的实际支付 $p_i$ 小于其名义负债 $\\bar{p}_i$，则该银行违约。\n-   待计算的指标：\n    1.  违约银行数量：$D(x') = \\sum_{i=1}^n \\mathbf{1}\\{p_i < \\bar{p}_i\\}$。\n    2.  未偿付负债总额：$U(x') = \\sum_{i=1}^n (\\bar{p}_i - p_i)$。$U(\\cdot)$ 必须四舍五入到六位小数。\n-   任务：为每个由（$n$、$L$、$x$、$k$、$s_{\\mathrm{id}}$、$s_{\\mathrm{com}}$）定义的测试用例，计算四元素列表 $[D(x^{\\mathrm{id}}), D(x^{\\mathrm{com}}), U(x^{\\mathrm{id}}), U(x^{\\mathrm{com}})]$。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n-   **科学依据**：问题描述了一个经典的金融传染模型，特别是 Eisenberg–Noe (2001) 的清算系统。这是计算金融学和经济学中用于分析银行间网络系统性风险的一个基础且科学严谨的模型。其前提在事实上是合理的，并基于已确立的经济学理论。\n-   **良定性**：问题的核心是找到清算向量 $p$ 作为方程 $p = f(p) = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)$ 的不动点。函数 $f$ 是在完备格 $[0, \\bar{p}] = \\{ p \\in \\mathbb{R}^n \\mid 0 \\le p_i \\le \\bar{p}_i \\text{ for all } i \\}$ 上的一个单调函数。根据 Tarski 不动点定理，不动点必然存在。Eisenberg 和 Noe 证明了最大不动点是具有经济意义的清算向量。这可以通过迭代过程 $p^{(m+1)} = f(p^{(m)})$ 来找到，从 $p^{(0)} = \\bar{p}$ 开始。这个序列是不增且有下界的，因此保证收敛。该问题是良定的。\n-   **客观性**：问题采用了精确的数学定义和客观的语言进行表述。没有主观或模棱两可的术语。\n-   **完整性**：为每个测试用例提供了所有必要的数据和参数（$L$、$x$、$k$、$s_{\\mathrm{id}}$、$s_{\\mathrm{com}}$）。模型和指标已完全指定。\n\n**第 3 步：结论与行动**\n\n该问题具有科学依据、良定性、客观性和完整性。因此，它被判定为**有效**。将提供一个解决方案。\n\n**解题方法**\n\n该问题要求在两种冲击情景下计算金融网络的违约统计数据。解决方案遵循 Eisenberg–Noe 模型。对于每个测试用例和每种冲击情景，执行以下步骤：\n\n1.  **系统设定**：根据给定的名义负债矩阵 $L$，我们首先计算总名义负债向量 $\\bar{p}$。每个元素 $\\bar{p}_i$ 是 $L$ 矩阵第 $i$ 行的和：\n    $$\n    \\bar{p}_i = \\sum_{j=1}^{n} L_{ij}\n    $$\n    接下来，我们计算相对负债矩阵 $\\Pi$，其中每个元素 $\\Pi_{ij}$ 代表银行 $i$ 的总债务中欠银行 $j$ 的部分所占的比例：\n    $$\n    \\Pi_{ij} = \\begin{cases} L_{ij} / \\bar{p}_i & \\text{if } \\bar{p}_i > 0 \\\\ 0 & \\text{if } \\bar{p}_i = 0 \\end{cases}\n    $$\n\n2.  **冲击应用**：我们确定每种情景下冲击后的外部资产向量 $x'$。\n    -   对于施加于银行 $k$、幅度为 $s_{\\mathrm{id}}$ 的特定冲击，资产向量 $x^{\\mathrm{id}}$ 为：\n        $$\n        x^{\\mathrm{id}}_i = \\begin{cases} (1 - s_{\\mathrm{id}}) x_k & \\text{if } i = k \\\\ x_i & \\text{if } i \\ne k \\end{cases}\n        $$\n    -   对于幅度为 $s_{\\mathrm{com}}$ 的共同冲击，资产向量 $x^{\\mathrm{com}}$ 为：\n        $$\n        x^{\\mathrm{com}} = (1 - s_{\\mathrm{com}}) x\n        $$\n\n3.  **清算向量计算**：核心任务是找到清算支付向量 $p$，它是以下迭代映射的最大不动点：\n    $$\n    p = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)\n    $$\n    这个不动点通过迭代找到。我们以最乐观的假设 $p^{(0)} = \\bar{p}$（所有银行都打算全额偿还其债务）来初始化支付向量。然后我们迭代以下更新规则直到收敛，即直到 $p^{(m+1)} = p^{(m)}$：\n    $$\n    p^{(m+1)} = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p^{(m)}\\,\\big)\n    $$\n    项 $\\Pi^{\\top}p^{(m)}$ 代表每家银行收到的银行间资产向量，假设其他银行根据 $p^{(m)}$ 进行支付。银行 $i$ 的可用资金总额是其冲击后的外部资产 $x'_i$ 加上其银行间应收款。支付 $p_i$ 的上限是其名义总负债 $\\bar{p}_i$。向量序列 $\\{p^{(m)}\\}_{m=0}^\\infty$ 是不增的，并以零向量为下界，保证收敛到最大不动点。\n\n4.  **指标计算**：一旦获得收敛的清算向量 $p$，我们计算所需的指标：\n    -   **违约数量（$D$）**：如果银行 $i$ 的支付 $p_i$ 严格小于其债务 $\\bar{p}_i$，则该银行违约。我们计算这类银行的数量。\n        $$\n        D(x') = \\sum_{i=1}^{n} \\mathbf{1}\\{p_i < \\bar{p}_i\\}\n        $$\n        在实现中，使用一个小的数值容差来稳健地处理浮点数比较。\n    -   **未偿付负债总额（$U$）**：这是整个系统的总缺口，计算为所有银行的名义负债与实际支付之差的总和。\n        $$\n        U(x') = \\sum_{i=1}^{n} (\\bar{p}_i - p_i)\n        $$\n    然后按要求将 $U(x')$ 的值四舍五入到六位小数。\n\n此程序将应用于每个测试用例的特定冲击和共同冲击两种情景，以生成最终的四元素结果向量。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         1, 0.6, 0.3),\n        # Test case 2 (baseline, no shock)\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         3, 0.0, 0.0),\n        # Test case 3 (severe stress comparison)\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         2, 0.9, 0.75),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, L, x, k, s_id, s_com = case\n        result = compute_for_case(n, L, x, k, s_id, s_com)\n        results.append(result)\n\n    # Format the final output as a string representation of a list of lists.\n    # e.g., [[val1, val2], [val3, val4]]\n    # Using map(str, ...) handles the inner lists correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_for_case(n, L, x, k, s_id, s_com):\n    \"\"\"\n    Computes the required metrics for a single test case.\n    \"\"\"\n    # Step 1: System Specification\n    p_bar = L.sum(axis=1)\n    \n    # Calculate relative liabilities matrix Pi, handling division by zero for banks with no liabilities.\n    Pi = np.divide(L, p_bar[:, np.newaxis], out=np.zeros_like(L, dtype=float), where=(p_bar[:, np.newaxis] != 0))\n    Pi_T = Pi.T\n\n    # --- Idiosyncratic Shock Scenario ---\n    # Step 2: Apply idiosyncratic shock\n    x_id = x.copy()\n    if k is not None:\n        # Note: problem uses 1-based indexing for k, Python uses 0-based.\n        x_id[k - 1] *= (1 - s_id)\n    \n    # Steps 3 & 4: Compute clearing vector and metrics\n    D_id, U_id = find_clearing_vector_and_metrics(p_bar, Pi_T, x_id)\n\n    # --- Common Shock Scenario ---\n    # Step 2: Apply common shock\n    x_com = x * (1 - s_com)\n    \n    # Steps 3 & 4: Compute clearing vector and metrics\n    D_com, U_com = find_clearing_vector_and_metrics(p_bar, Pi_T, x_com)\n\n    return [D_id, D_com, round(U_id, 6), round(U_com, 6)]\n\n\ndef find_clearing_vector_and_metrics(p_bar, Pi_T, x_shocked, max_iter=100, tol=1e-12):\n    \"\"\"\n    Computes the Eisenberg-Noe clearing vector and derived metrics.\n    \n    Args:\n        p_bar (np.ndarray): Vector of total nominal liabilities.\n        Pi_T (np.ndarray): Transposed relative liabilities matrix.\n        x_shocked (np.ndarray): Post-shock external asset vector.\n        max_iter (int): Maximum number of iterations for the fixed-point solver.\n        tol (float): Tolerance for default detection and convergence.\n        \n    Returns:\n        tuple[int, float]: A tuple containing the number of defaults (D) and \n                           aggregate unpaid liabilities (U).\n    \"\"\"\n    # Step 3: Clearing Vector Computation (Iterative Fixed-Point Method)\n    p = p_bar.copy()  # Initialize with optimistic p(0) = p_bar\n\n    for _ in range(max_iter):\n        p_old = p\n        \n        # Calculate incoming interbank payments\n        interbank_assets = Pi_T @ p_old\n        \n        # Calculate total available assets and update payments\n        p = np.minimum(p_bar, x_shocked + interbank_assets)\n        \n        # Check for convergence\n        if np.allclose(p, p_old, atol=tol, rtol=0):\n            break\n\n    # Step 4: Metrics Calculation\n    # Number of defaults D: count banks where payment is less than liability\n    # Use a tolerance to avoid floating-point inaccuracies.\n    defaults = (p_bar - p) > tol\n    num_defaults = int(np.sum(defaults))\n    \n    # Aggregate unpaid liabilities U: sum of shortfalls across all banks\n    unpaid_liabilities = float(np.sum(p_bar - p))\n    \n    return num_defaults, unpaid_liabilities\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}