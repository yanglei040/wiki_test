{"hands_on_practices": [{"introduction": "小世界网络结合了高集群化和短路径长度的特点，深刻影响着经济和金融系统中的信息流动。本练习通过一个确定性的思想实验，让您将一个由多个孤立区域组成的规则网络，通过逐步添加“捷径”贸易协定，转变为一个整合的小世界网络。通过亲手计算聚类系数 ($C$) 和平均路径长度 ($L$) 等关键指标，您将深入理解仅需少数长程连接便能显著改变网络全局特性的核心原理。[@problem_id:2431664]", "id": "2431664", "problem": "您需要形式化并解决以下判定问题：一个模块化贸易网络（一种风格化的区域化世界经济）在添加国际捷径贸易协定后，何时会成为一个小世界网络。该网络由 $M$ 个不相交的区域组成。每个区域包含 $n$ 个经济体（节点），这些节点排列在一个环形晶格上，其中每个节点都连接到其同一区域内两侧最近的 $k$ 个邻居（因此每个节点在其区域内的度为 $2k$）。从这个没有跨区域连接的区域内基线开始，您可以添加无向的国际捷徑，每条捷径连接一个区域中的一个节点到另一个不同区域中的一个节点。您必须确定，为满足下面定义的小世界准则，需要添加的此类捷径的最小数量，并使用指定的构造性策略，该策略消除了随机性并确保了唯一答案。\n\n基本设定与定义：\n- 设 $G$ 为一个包含 $N = M \\cdot n$ 个节点的简单无向图，其邻接关系由 $A$ 编码。节点 $i$ 的度为 $d_i$。\n- 平均局部聚类系数 $C$ 是每个节点邻居之間已实现链接比例的算术平均值：对于节点 $i$，如果 $d_i \\lt 2$，则设 $C_i = 0$；否则，$C_i = \\dfrac{2 t_i}{d_i(d_i - 1)}$，其中 $t_i$ 是节点 $i$ 的邻居之间的边数。则 $C = \\dfrac{1}{N} \\sum_{i=1}^N C_i$。\n- 平均最短路径长度 $L$ 是在同一连通分量中所有不同的无序节点对的图距离 $d(i,j)$ 的平均值，即 $L = \\dfrac{2}{N(N-1)} \\sum_{1 \\le i \\lt j \\le N} d(i,j)$，仅当 $G$ 是连通图时有定义。\n- 参考随机网络是具有相同节点数 $N$ 和相同期望边数 $E$ 的 Erdős–Rényi 模型。其连接概率为 $p = \\dfrac{2E}{N(N-1)}$，其期望聚类系数为 $C_{\\text{rand}} = p$。对于足够大的 $N$ 和平均度 $z = \\dfrac{2E}{N}$（其中 $z \\gt 1$），期望平均最短路径长度可以很好地近似为 $L_{\\text{rand}} \\approx \\dfrac{\\ln N}{\\ln z}$。这些都是广泛使用、经过充分检验的用于基准测试小世界结构的近似值。\n- 定义 $\\gamma = \\dfrac{C}{C_{\\text{rand}}}$ 及 $\\lambda = \\dfrac{L}{L_{\\text{rand}}}$。\n\n需要达成的小世界准则：\n- 如果网络同时满足 $\\gamma \\ge g_{\\min}$ 和 $\\lambda \\le \\ell_{\\max}$，则该网络被判定为小世界网络。其中 $g_{\\min}$ 和 $\\ell_{\\max}$ 是给定的阈值，且 $g_{\\min} \\gt 1$，$\\ell_{\\max}$ 接近 $1$。\n\n捷径放置策略（确定性与构造性）：\n- 从 $M$ 个区域性环形晶格的不相交并集开始（没有国际边）。\n- 迭代地一次添加一条国际捷径，并 L 记录已添加的数量。在每次迭代中：\n  1. 如果图不连通，则添加一条捷径，连接字典序最小的连通分量中的最小索引节点与下一个字典序最小的连通分量中的最小索引节点。此步骤在迭代中重复，直到图变为连通。这保证了在添加了恰好 $C-1$ 条捷径后图是连通的，其中 $C$ 是该次迭代时的连通分量数量。\n  2. 如果图是连通的，计算所有节点对之间的最短路径距离。在所有属于不同区域且尚不相邻的无序节点对 $(i,j)$ 中，选择具有最大图距离的节点对。若出现相同距离，则选择字典序最小的节点对。添加这条国际捷径并继续。\n- 每次添加捷径后，重新计算 $C$、$L$、$C_{\\text{rand}}$、$L_{\\text{rand}}$、$\\gamma$ 和 $\\lambda$。当小世界准则首次满足时立即停止。\n\n目标：\n- 对每个测试用例，计算（在上述策略下）为使网络首次满足 $\\gamma \\ge g_{\\min}$ 和 $\\lambda \\le \\ell_{\\max}$ 所需添加的捷径的最小数量。\n- 如果即使在添加了所有可能的国际捷径（即，来自不同区域的每对节点都已通过边连接）之后，准则仍无法满足，则为该测试用例返回 $-1$。\n\n输入模型与单位：\n- 无外部输入；您的程序必须按照规定实现构造和评估过程。不存在物理单位。所有角度（若有）应视为弧度，尽管在此问题中未直接出现。\n\n测试套件与参数：\n- 案例 1：$M = 4$，$n = 12$，$k = 2$，$g_{\\min} = 1.5$，$_max} = 1.3$。\n- 案例 2：$M = 3$，$n = 16$，$k = 2$，$g_{\\min} = 1.5$，$_max} = 1.25$。\n- 案例 3：$M = 5$，$n = 8$，$k = 2$，$g_{\\min} = 1.5$，$_max} = 1.3$。\n- 案例 4：$M = 2$，$n = 24$，$k = 3$，$g_{\\min} = 1.5$，$_max} = 1.25$。\n\n输出规范：\n- 您的程序应产生单行输出，包含测试用例的结果。结果为一个逗号分隔的列表，并用方括号括起来，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个整数，代表测试用例 $i$ 所需的国际捷径的最小数量（如果无法达成则为 $-1$）。", "solution": "问题陈述已通过验证。\n\n### 步骤 1: 提取给定信息\n- **网络结构**:\n    - $M$: 不相交区域的数量。\n    - $n$: 每个区域的经济体（节点）数量。\n    - 总节点数 $N = M \\cdot n$。\n    - 每个区域是一个环形晶格，其中每个节点连接到其两侧最近的 $k$ 个邻居。初始区域内度为 $2k$。\n    - 最初，区域之间没有连接。\n- **网络度量指标**:\n    - $A$: 简单无向图 $G$ 的邻接矩阵。\n    - $d_i$: 节点 $i$ 的度。\n    - 局部聚类系数: 对于 $d_i \\ge 2$，$C_i = \\dfrac{2 t_i}{d_i(d_i - 1)}$，其中 $t_i$ 是 $i$ 的邻居之间的边数。如果 $d_i < 2$，$C_i=0$。\n    - 平均局部聚类系数: $C = \\dfrac{1}{N} \\sum_{i=1}^N C_i$。\n    - 平均最短路径长度: $L = \\dfrac{2}{N(N-1)} \\sum_{1 \\le i \\lt j \\le N} d(i,j)$，为连通图定义。\n- **参考网络 (Erdős–Rényi)**:\n    - 相同的节点数 $N$ 和边数 $E$。\n    - 期望聚类系数: $C_{\\text{rand}} = p = \\dfrac{2E}{N(N-1)}$。\n    - 近似的期望平均最短路径长度: $L_{\\text{rand}} \\approx \\dfrac{\\ln N}{\\ln z}$，其中平均度 $z = \\dfrac{2E}{N} > 1$。\n- **小世界准则**:\n    - $\\gamma = \\dfrac{C}{C_{\\text{rand}}} \\ge g_{\\min}$ 且 $\\lambda = \\dfrac{L}{L_{\\text{rand}}} \\le \\ell_{\\max}$。\n- **捷径放置策略 (确定性)**:\n    - 从 $M$ 个不相交的环形晶格开始。\n    - 迭代地添加一条无向国际捷径。\n    - **若图不连通**: 连接字典序最小的连通分量中的最小索引节点与下一个字典序最小的连通分量中的最小索引节点。\n    - **若图连通**: 计算所有节点对之间的最短路径。在来自不同区域且不相邻的节点对 $(i, j)$ 中，添加一条捷径连接具有最大图距离的节点对。通过选择字典序最小的节点对来解决平局情况。\n- **目标**:\n    - 找到首次满足小世界准则所需的最少捷径数量。\n    - 如果添加所有可能的国际捷径后仍无法满足准则，则返回 $-1$。\n- **测试用例**:\n    - 案例 1：$M = 4$, $n = 12$, $k = 2$, $g_{\\min} = 1.5$, $\\ell_{\\max} = 1.3$。\n    - 案例 2：$M = 3$, $n = 16$, $k = 2$, $g_{\\min} = 1.5$, $\\ell_{\\max} = 1.25$。\n    - 案例 3：$M = 5$, $n = 8$, $k = 2$, $g_{\\min} = 1.5$, $\\ell_{\\max} = 1.3$。\n    - 案例 4：$M = 2$, $n = 24$, $k = 3$, $g_{\\min} = 1.5$, $\\ell_{\\max} = 1.25$。\n\n### 步骤 2: 使用提取的信息进行验证\n该问题根据既定标准进行有效性评估。\n\n1.  **科学依据**：该问题坚实地植根于网络科学领域，这是计算社会科学和STEM中一个成熟的学科。所有概念——环形晶格、聚类系数、最短路径长度、Erdős–Rényi 随机图和 Watts-Strogatz 小世界模型——都是标准且严格定义的。$L_{\\text{rand}}$ 和 $C_{\\text{rand}}$ 的近似值是文献中的标准方法。该问题不包含任何伪科学或事实错误。\n\n2.  **适定性**：该问题是适定的。目标是找到构造过程中所需步骤的最小数量。过程本身完全是确定性的，由一个清晰、明确的捷径放置策略和显式的平局解决规则定义。这保证了对于给定的参数集，添加捷径的序列和最终结果是唯一的。终止条件也是精确的。\n\n3.  **客观性**：问题以精确、定量和无偏见的语言陈述。所有定义都是形式化的。成功标准是客观的数学不等式。\n\n4.  **完整性**：问题是自洽的。所有必要的参数（$M, n, k, g_{\\min}, \\ell_{\\max}$）和定义都已提供。不需要外部信息。\n\n5.  **一致性与可行性**：设置是逻辑一致的。初始状态是一组不相交的图。迭代规则描述了如何修改图。计算 $L$ 的条件（图的连通性）被正确地指出。测试用例中的参数是合理的，没有立即出现任何矛盾或不可行性。\n\n### 步骤 3: 结论与行动\n此问题被判定为**有效**。这是一个基于既定科学原理的、定义明确的计算问题。将提供一个解决方案。\n\n### 解决方案\n该问题要求我们模拟一个网络演化的确定性过程，并确定网络首次满足指定小世界准则的时间点。解决方案是程序性的，严格遵循指定的规则。\n\n**1. 图的初始化**\n首先，我们构建初始图。总节点数为 $N = M \\cdot n$。我们可以使用一个 $N \\times N$ 的邻接矩阵（表示为 $A$）来表示图。节点索引从 $0$ 到 $N-1$，其中索引为 $i$ 的节点属于区域 $\\lfloor i/n \\rfloor$，其局部索引为 $i \\pmod n$。\n初始图由 $M$ 个不相交的环形晶格组成。对于每个区域 $r \\in \\{0, \\dots, M-1\\}$ 和该区域内的每个节点 $i$，我们建立与其两侧最近的 $k$ 个邻居的边。具体来说，全局索引为 $u = r \\cdot n + i$ 的节点与节点 $v = r \\cdot n + ((i \\pm s) \\pmod n)$ 相连，其中 $s \\in \\{1, \\dots, k\\}$。\n\n**2. 迭代添加捷径**\n我们通过一个循环进行，每次迭代添加一条捷径并检查小世界准则。设 `num_shortcuts` 为已添加边的计数，初始化为 $0$。\n\n在每一步，我们必须首先评估图的连通性。这可以通过广度优先搜索（BFS）或深度优先搜索（DFS）来识别连通分量。\n\n- **若图不连通**（多于一个分量）：策略规定添加一条边以连接两个分量。这些分量按其最小节点索引进行字典序排序。在第一个分量的最小索引节点和第二个分量的最小索引节点之间添加一条捷径。\n\n- **若图连通**：策略规定添加一条“长程”捷径。这需要计算所有节点对之间的最短路径（APSP）。对于此问题中的图规模，时间复杂度为 $O(N^3)$ 的 Floyd-Warshall 算法是合适的。计算出距离矩阵 $D$ 后，我们识别所有候选对 $(i, j)$ 的集合，使得 $i$ 和 $j$ 位于不同区域且尚未通过边连接。在这些候选中，我们选择具有最大最短路径距离 $d(i, j)$ 的一对。距离上的任何平局都通过选择字典序最小的对 $(i, j)$（其中 $i < j$）来解决。在这选定的两个节点之间添加一条捷徑。如果不存在这样的候选对，则意味着所有区域间的连接都已建立。\n\n在确定要连接的节点对 $(u, v)$ 后，我们更新邻接矩阵（$A_{uv} = A_{vu} = 1$）并增加 `num_shortcuts`。\n\n**3. 准则评估**\n每次添加捷径后，我们评估小世界准则。这仅在图连通时才有意义，因为 $L$ 的定义要求图是连通的。\n\n- **连通性检查**：我们必须首先验证图是否连通。如果不连通，则准则无法满足，我们继续下一次迭代。\n\n- **指标计算**：如果图是连통的，我们计算当前图状态所需的度量指标。\n    - **总边数 $E$**：邻接矩阵中所有元素之和的一半。\n    - **平均聚类系数 $C$**：我们遍历每个节点 $i$。找到其邻居集合，并计算它们之间存在的边数 $t_i$。对于度为 $d_i \\ge 2$ 的节点，局部聚类系数为 $C_i = 2t_i / (d_i(d_i-1))$。平均值 $C$ 是所有 $C_i$ 的均值。\n    - **平均最短路径长度 $L$**：使用为当前图计算的APSP矩阵，我们对所有 $\\binom{N}{2}$ 个不同节点对的距离求和，然后除以这个总对数。\n    - **参考指标 $C_{\\text{rand}}$ 和 $L_{\\text{rand}}$**：这些是使用强制性公式计算的：$z = 2E/N$，$C_{\\text{rand}} = z/(N-1)$，以及 $L_{\\text{rand}} = \\ln(N)/\\ln(z)$。在计算 $\\ln(z)$ 之前，必须确保 $z > 1$。\n\n- **条件检查**：最后，我们计算比率 $\\gamma = C/C_{\\text{rand}}$ 和 $\\lambda = L/L_{\\text{rand}}$。如果 $\\gamma \\ge g_{\\min}$ 且 $\\lambda \\le \\ell_{\\max}$，则过程终止。`num_shortcuts` 的当前值就是解。\n\n**4. 终止条件**\n迭代过程通过以下两种方式之一终止：\n1. 小世界准则被满足，返回捷径的数量。\n2. 循环完成了所有可能的区域间捷径添加，但仍未满足准则。在连通阶段，当不同区域之间不再有不相邻的节点对时，就会检测到这种情况。在这种情况下，返回 $-1$。\n\n对每个测试用例实施这个完整的确定性算法，以找到所需的结果。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # M, n, k, g_min, l_max\n        (4, 12, 2, 1.5, 1.3),\n        (3, 16, 2, 1.5, 1.25),\n        (5, 8, 2, 1.5, 1.3),\n        (2, 24, 3, 1.5, 1.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, n, k, g_min, l_max = case\n        result = _solve_one_case(M, n, k, g_min, l_max)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_one_case(M, n, k, g_min, l_max):\n    \"\"\"\n    Solves a single instance of the problem.\n    \"\"\"\n    N = M * n\n\n    # 1. Build initial adjacency matrix for M disjoint ring lattices\n    adj = np.zeros((N, N), dtype=int)\n    for r in range(M):\n        base_idx = r * n\n        for i in range(n):\n            u = base_idx + i\n            for s in range(1, k + 1):\n                v1 = base_idx + ((i + s) % n)\n                v2 = base_idx + ((i - s + n) % n)\n                adj[u, v1] = 1\n                adj[u, v2] = 1\n\n    num_shortcuts = 0\n    max_possible_shortcuts = (M * (M - 1) // 2) * (n * n)\n\n    while num_shortcuts <= max_possible_shortcuts:\n        # A. Determine which shortcut to add based on the policy\n        components = _find_components(adj, N)\n        u, v = -1, -1\n\n        if len(components) > 1:\n            # Policy for disconnected graphs\n            sorted_components = sorted([sorted(list(c)) for c in components])\n            u, v = sorted_components[0][0], sorted_components[1][0]\n        else:\n            # Policy for connected graphs\n            dist = _floyd_warshall(adj, N)\n            \n            candidate_pairs = []\n            for i in range(N):\n                for j in range(i + 1, N):\n                    if (i // n) != (j // n) and adj[i, j] == 0:\n                        candidate_pairs.append((i, j))\n            \n            if not candidate_pairs:\n                return -1 # No more shortcuts can be added\n\n            max_d = -np.inf\n            best_pairs = []\n            for i_p, j_p in candidate_pairs:\n                d = dist[i_p, j_p]\n                if d > max_d:\n                    max_d = d\n                    best_pairs = [(i_p, j_p)]\n                elif d == max_d:\n                    best_pairs.append((i_p, j_p))\n            \n            # Tie-break by lexicographically smallest pair\n            u, v = min(best_pairs)\n\n        # B. Add the shortcut\n        adj[u, v] = 1\n        adj[v, u] = 1\n        num_shortcuts += 1\n\n        # C. Evaluate the small-world criterion\n        # Only check if graph is connected, which is a prerequisite for L\n        post_add_components = _find_components(adj, N)\n        if len(post_add_components) > 1:\n            continue\n\n        # --- Graph is connected, proceed with metric calculations ---\n        C = _calculate_C(adj, N)\n        \n        current_dist = _floyd_warshall(adj, N)\n        \n        # Check for disconnected sub-pockets (should not happen with find_components check)\n        if np.isinf(current_dist).any():\n            continue\n            \n        L = current_dist[np.triu_indices(N, k=1)].mean()\n\n        num_edges = np.sum(adj) // 2\n        avg_degree = 2 * num_edges / N\n\n        if avg_degree <= 1.0:\n            continue\n\n        C_rand = avg_degree / (N - 1)\n        L_rand = np.log(N) / np.log(avg_degree)\n        \n        if C_rand == 0 or L_rand == 0:\n            continue\n\n        gamma = C / C_rand\n        lambda_val = L / L_rand\n\n        if gamma >= g_min and lambda_val <= l_max:\n            return num_shortcuts\n            \n    return -1\n\n\ndef _find_components(adj, N):\n    \"\"\"Finds connected components using BFS.\"\"\"\n    visited = set()\n    components = []\n    for i in range(N):\n        if i not in visited:\n            component = set()\n            q = deque([i])\n            visited.add(i)\n            while q:\n                u = q.popleft()\n                component.add(u)\n                neighbors = np.where(adj[u] == 1)[0]\n                for v in neighbors:\n                    if v not in visited:\n                        visited.add(v)\n                        q.append(v)\n            components.append(component)\n    return components\n\ndef _floyd_warshall(adj, N):\n    \"\"\"Computes all-pairs shortest paths using Floyd-Warshall.\"\"\"\n    dist = np.full((N, N), np.inf)\n    np.fill_diagonal(dist, 0)\n    for i in range(N):\n        for j in range(N):\n            if adj[i, j] == 1:\n                dist[i, j] = 1\n    \n    for k_fw in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dist[i, k_fw] + dist[k_fw, j] < dist[i, j]:\n                    dist[i, j] = dist[i, k_fw] + dist[k_fw, j]\n    return dist\n\ndef _calculate_C(adj, N):\n    \"\"\"Calculates the average local clustering coefficient.\"\"\"\n    local_C = []\n    degrees = np.sum(adj, axis=1)\n    for i in range(N):\n        d_i = degrees[i]\n        if d_i < 2:\n            local_C.append(0.0)\n            continue\n        \n        neighbors = np.where(adj[i] == 1)[0]\n        t_i = 0\n        subgraph = adj[np.ix_(neighbors, neighbors)]\n        t_i = np.sum(subgraph) // 2\n        \n        C_i = (2 * t_i) / (d_i * (d_i - 1))\n        local_C.append(C_i)\n        \n    return np.mean(local_C)\n\nif __name__ == \"__main__\":\n    solve()\n\n```"}, {"introduction": "网络结构如何影响市场效率？这个实践练习将引导您通过编程模拟来回答这个问题，在 Watts-Strogatz 模型构建的交易者网络上，探索信念传播的动态过程。您将实现一个经典的 DeGroot 锚定模型，并亲眼见证增加网络中的“捷径”（即提高重连概率 $p$）如何显著加快市场价格向基本价值收敛的速度。这个练习有力地揭示了网络拓扑结构与信息传播效率之间的深刻联系。[@problem_id:2431703]", "id": "2431703", "problem": "考虑一个由$N$个交易者组成的市场，其信息网络通过Watts–Strogatz小世界模型构建。该网络首先初始化为一个度为偶数$k$的规则环形格网络（每个节点与其两侧最近的$k/2$个邻居相连），然后每条右侧边以概率$p$独立地重连到一个均匀选择的非邻居节点，重连过程排除自环和重复边，最终生成一个无向简单图。设$A \\in \\{0,1\\}^{N \\times N}$表示所得图的邻接矩阵，并设$D \\in \\mathbb{R}^{N \\times N}$为节点度的对角矩阵。定义行随机的社会影响矩阵为$W = D^{-1} A$。\n\n在离散时间$t \\in \\{0,1,2,\\dots\\}$，每个交易者$i \\in \\{1,\\dots,N\\}$对资产的基本价值$F \\in \\mathbb{R}$持有一个信念$x_i(t)$。时间$t$的市场价格是简单平均值$P(t) = \\frac{1}{N} \\sum_{i=1}^N x_i(t)$。信念通过DeGroot锚定动态模型进行更新：\n$$\n\\mathbf{x}(t+1) = (1-\\alpha) W \\mathbf{x}(t) + \\alpha F \\mathbf{1},\n$$\n其中$\\alpha \\in [0,1]$是公共信号锚定权重，$\\mathbf{1}$是$N$维全一向量。初始信念是异质的，由以下方式抽取：\n$$\nx_i(0) = F + \\Delta + \\xi_i,\\quad \\xi_i \\sim \\mathcal{N}(0,\\sigma^2) \\text{ independently across } i,\n$$\n其中给定了$\\Delta \\in \\mathbb{R}$和$\\sigma > 0$。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 根据上述描述，为给定的$N$、$k$和$p$构建Watts–Strogatz网络。\n- 根据更新方程，将信念向量$\\mathbf{x}(t)$演化至多$T_{\\max}$步。\n- 计算市场价格到基本价值的$\\varepsilon$-收敛的首次到达时间，\n$$\n\\tau = \\min\\{t \\in \\{1,2,\\dots,T_{\\max}\\} : |P(t) - F| \\le \\varepsilon \\},\n$$\n并约定如果在$T_{\\max}$之前不存在这样的$t$，则$\\tau = T_{\\max}$。\n- 每个测试用例使用固定的伪随机数生成器种子以确保可复现性。该种子必须同时影响重连的随机性和初始的$\\xi_i$。\n\n在所有测试用例中，对非网络参数使用以下固定配置：基本价值$F = 100.0$，初始偏移$\\Delta = 5.0$，噪声标准差$\\sigma = 1.0$。收敛容差$\\varepsilon$按每个用例指定。本问题不使用角度。所有量均为无量纲，因此不需要物理单位。所有时间索引均为整数。\n\n实现并评估以下参数值$(N,k,p,\\alpha,\\varepsilon,T_{\\max},\\text{seed})$的测试套件：\n- 用例 1: $(150,\\,4,\\,0.0,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- 用例 2: $(150,\\,4,\\,0.05,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- 用例 3: $(150,\\,4,\\,0.2,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- 用例 4: $(150,\\,4,\\,1.0,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- 用例 5 (边界情况，无锚定): $(150,\\,4,\\,0.2,\\,0.0,\\,10^{-3},\\,5000,\\,1)$\n- 用例 6 (更稀疏的基础格网): $(150,\\,2,\\,0.5,\\,0.05,\\,10^{-3},\\,5000,\\,2)$\n\n您的程序应输出单行内容，其中包含六个得到的首次到达时间$\\tau$的列表，格式为方括号括起来的逗号分隔列表（例如，$\\,[\\tau_1,\\tau_2,\\dots,\\tau_6]\\,$）。最终输出必须是整数。不应打印任何其他文本。", "solution": "该问题陈述经过了严格验证，被认为是有效的。它在科学上基于网络科学和计算经济学的既有模型，问题设定良好，目标明确，信息充分，并以客观、无歧义的语言表述。任务是模拟Watts-Strogatz网络上的信念传播动态，并计算价格收敛的首次到达时间。我们着手提供解决方案。\n\n解决方案分为三个主要部分：1) Watts-Strogatz网络的构建，2) DeGroot信念动态模型的表述与分析，以及3) 实现数值模拟以计算首次到达时间$\\tau$。\n\n**1. Watts–Strogatz网络构建**\n\n$N$个交易者的网络根据所述的特定Watts-Strogatz过程构建。\n\n首先，创建一个初始的规则环形格网络。节点集合为$V = \\{0, 1, \\dots, N-1\\}$。每个节点$i \\in V$与其$k$个最近邻居相连，其中$k$是一个偶数。具体来说，每个节点$i$与节点$(i \\pm j) \\pmod N$（其中$j \\in \\{1, \\dots, k/2\\}$）相连。这会创建一个无向图，其中每个节点的度都是$k$。这个初始格网络的邻接矩阵$A^{(0)}$的元素$A^{(0)}_{ij} = 1$（如果节点$j$是$i$的$k$个最近邻居之一），否则$A^{(0)}_{ij} = 0$。\n\n其次，应用重连过程。问题明确指出“每条右侧边独立地重连”。我们将“右侧”边集定义为形式为$(i, (i+j) \\pmod N)$的边，其中$i \\in \\{0, \\dots, N-1\\}$，$j \\in \\{1, \\dots, k/2\\}$。这样的有向对有$N \\times (k/2)$个，对应于格网络中的$N \\times (k/2)$条无向边。对每条这样的边，比如说$(u,v)$，进行一个随机决策。边$(u,v)$以概率$p$被重连。重连操作包括移除边$(u,v)$并添加一条新边$(u,w)$，其中新的目标节点$w$从所有不是$u$且尚未与$u$相连的节点中均匀随机选择。这个过程确保不会创建自环（$u=w$）或$u$和$w$之间的多重边。最终的图保持为无向图，因此如果我们添加了边$(u,w)$，我们也必须考虑边$(w,u)$。\n\n最终的邻接矩阵$A \\in \\{0,1\\}^{N \\times N}$表示所得简单无向图的连通性。使用指定种子的伪随机数生成器确保了网络结构的可复现性。\n\n**2. DeGroot信念动态模型**\n\n交易者信念的演化由一个带锚定项的DeGroot模型控制。令$\\mathbf{x}(t) = [x_1(t), \\dots, x_N(t)]^T$为离散时间$t$的信念向量。\n\n社会影响矩阵$W$定义为$W = D^{-1} A$，其中$A$是网络构建得到的邻接矩阵，$D$是节点度的对角矩阵，$D_{ii} = \\text{deg}(i) = \\sum_{j=0}^{N-1} A_{ij}$。元素$W_{ij} = A_{ij} / \\text{deg}(i)$表示交易者$j$对交易者$i$的影响力。如果$\\text{deg}(i) = 0$，则$W$的第$i$行为全零。$W$是一个行随机矩阵，意味着其行和为1（除非度为0）。\n\n信念更新方程由下式给出：\n$$\n\\mathbf{x}(t+1) = (1-\\alpha) W \\mathbf{x}(t) + \\alpha F \\mathbf{1}\n$$\n其中，$\\alpha \\in [0,1]$是向公共信号$F \\in \\mathbb{R}$的锚定权重，$\\mathbf{1}$是$N$维全一向量。该方程描述了作用于交易者信念的两种相互竞争的力量：来自其邻居的社会影响（由$(1-\\alpha)$缩放）和朝向基本价值$F$的锚定拉力（由$\\alpha$缩放）。\n\n当$\\alpha > 0$时，系统存在唯一的平衡点$\\mathbf{x}^*$。在平衡状态下，$\\mathbf{x}^* = (1-\\alpha) W \\mathbf{x}^* + \\alpha F \\mathbf{1}$。对于一个连通图，对应于特征值1的$W$的唯一特征向量是$\\mathbf{1}$。系统会收敛到一个共识，因此$\\mathbf{x}^* = c \\mathbf{1}$，其中$c$为某个常数。将此代入平衡方程得到$c \\mathbf{1} = (1-\\alpha) c W \\mathbf{1} + \\alpha F \\mathbf{1} = (1-\\alpha) c \\mathbf{1} + \\alpha F \\mathbf{1}$。化简后得到$\\alpha c = \\alpha F$，对于$\\alpha > 0$，这意味着$c=F$。因此，所有信念以及它们的平均值（市场价格$P(t)$）都将收敛到基本价值$F$。\n\n在$\\alpha=0$的特殊情况下，方程变为$\\mathbf{x}(t+1) = W \\mathbf{x}(t)$。系统仍然会收敛到一个共识值$c$，但$c$的值由初始条件和网络结构决定。具体来说，$c = \\sum_i \\pi_i x_i(0)$，其中$\\pi$是图上随机游走的平稳分布，由$\\pi_i = \\text{deg}(i) / \\sum_j \\text{deg}(j)$给出。给定初始信念$x_i(0) = F + \\Delta + \\xi_i$，共识值将约等于$F+\\Delta$，当$\\Delta \\neq 0$时，这不等于$F$。因此，收敛条件$|P(t) - F| \\le \\varepsilon$预计不会被满足。\n\n**3. 数值模拟与首次到达时间**\n\n任务是计算首次到达时间$\\tau$，定义为：\n$$\n\\tau = \\min\\{t \\in \\{1, 2, \\dots, T_{\\max}\\} : |P(t) - F| \\le \\varepsilon \\}\n$$\n如果在$t=T_{\\max}$之前条件未被满足，则$\\tau = T_{\\max}$。\n\n每个测试用例的模拟算法如下：\n1. 设置伪随机数生成器种子以保证可复现性。\n2. 为给定的参数$N$、$k$和$p$构建Watts-Strogatz网络的邻接矩阵$A$。\n3. 计算度矩阵$D$和影响矩阵$W = D^{-1} A$。注意处理任何孤立节点（度为0）的除零问题。\n4. 初始化信念向量$\\mathbf{x}(0)$。对每个$i$，$x_i(0) = F + \\Delta + \\xi_i$，其中$\\xi_i$是从正态分布$\\mathcal{N}(0, \\sigma^2)$中的独立抽取。固定的模型参数为$F=100.0$，$\\Delta=5.0$和$\\sigma=1.0$。\n5. 从时间步$t=1$到$T_{\\max}$迭代模拟：\n    a. 更新信念向量：$\\mathbf{x}(t) = (1-\\alpha) W \\mathbf{x}(t-1) + \\alpha F \\mathbf{1}$。\n    b. 计算市场价格：$P(t) = \\frac{1}{N} \\sum_{i=0}^{N-1} x_i(t)$。\n    c. 检查收敛性：如果$|P(t) - F| \\le \\varepsilon$，将当前时间步$t$记录为$\\tau$并终止该用例的模拟。\n6. 如果循环完成仍未满足收敛准则，则设置$\\tau = T_{\\max}$。\n\n对每个指定的测试用例执行此过程，以生成所需的首次到达时间列表。", "answer": "```python\nimport numpy as np\n\ndef construct_watts_strogatz(N, k, p, rng):\n    \"\"\"\n    Constructs a Watts-Strogatz small-world network.\n\n    Args:\n        N (int): Number of nodes.\n        k (int): Even integer for the degree of each node in the initial lattice.\n        p (float): Rewiring probability.\n        rng (np.random.Generator): Random number generator for reproducibility.\n\n    Returns:\n        np.ndarray: The N x N adjacency matrix of the graph.\n    \"\"\"\n    if k % 2 != 0 or k >= N:\n        raise ValueError(\"k must be an even integer and less than N.\")\n\n    A = np.zeros((N, N), dtype=np.int8)\n    \n    # 1. Create the initial regular ring lattice\n    edges_to_rewire = []\n    for i in range(N):\n        for j in range(1, k // 2 + 1):\n            neighbor = (i + j) % N\n            A[i, neighbor] = 1\n            A[neighbor, i] = 1\n            # \"right-side\" edges are defined as (i, i+j)\n            edges_to_rewire.append((i, neighbor))\n\n    # 2. Rewire edges\n    for u, v in edges_to_rewire:\n        if rng.random() < p:\n            # Find a a suitable node 'w' to rewire to\n            # 'w' cannot be 'u' or an existing neighbor of 'u'\n            current_neighbors = np.where(A[u, :] == 1)[0]\n            possible_targets = np.setdiff1d(np.arange(N), np.append(current_neighbors, u))\n\n            if len(possible_targets) > 0:\n                w = rng.choice(possible_targets)\n                \n                # Remove old edge (u, v)\n                A[u, v] = 0\n                A[v, u] = 0\n                \n                # Add new edge (u, w)\n                A[u, w] = 1\n                A[w, u] = 1\n    \n    return A\n\ndef simulate_convergence(N, k, p, alpha, epsilon, T_max, seed):\n    \"\"\"\n    Simulates belief dynamics on a Watts-Strogatz network and finds the convergence time.\n\n    Args:\n        N (int): Number of traders.\n        k (int): Lattice degree.\n        p (float): Rewiring probability.\n        alpha (float): Anchoring weight.\n        epsilon (float): Convergence tolerance.\n        T_max (int): Maximum simulation steps.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        int: The hitting time tau.\n    \"\"\"\n    # Fixed parameters from the problem description\n    F = 100.0\n    DELTA = 5.0\n    SIGMA = 1.0\n    \n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # 1. Construct the network\n    A = construct_watts_strogatz(N, k, p, rng)\n\n    # 2. Set up the belief dynamics matrices\n    degrees = A.sum(axis=1)\n    # Handle isolated nodes (degree=0) by keeping their row as all zeros\n    W = np.divide(A, degrees[:, np.newaxis], out=np.zeros_like(A, dtype=float), where=degrees[:, np.newaxis] != 0)\n    \n    one_vector = np.ones(N)\n    \n    # 3. Initialize beliefs\n    xi = rng.normal(0, SIGMA, N)\n    x = F + DELTA + xi\n\n    # 4. Run simulation\n    for t in range(1, T_max + 1):\n        # Update beliefs\n        x = (1 - alpha) * (W @ x) + alpha * F * one_vector\n        \n        # Calculate market price\n        P_t = np.mean(x)\n        \n        # Check for convergence\n        if abs(P_t - F) <= epsilon:\n            return t\n            \n    # If convergence is not reached by T_max\n    return T_max\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases: (N, k, p, alpha, epsilon, T_max, seed)\n    test_cases = [\n        (150, 4, 0.0, 0.05, 1e-3, 5000, 1),\n        (150, 4, 0.05, 0.05, 1e-3, 5000, 1),\n        (150, 4, 0.2, 0.05, 1e-3, 5000, 1),\n        (150, 4, 1.0, 0.05, 1e-3, 5000, 1),\n        (150, 4, 0.2, 0.0, 1e-3, 5000, 1),\n        (150, 2, 0.5, 0.05, 1e-3, 5000, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        tau = simulate_convergence(*case)\n        results.append(tau)\n\n    # Print output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "与结构相对均匀的小世界网络不同，许多现实世界网络呈现出高度的异质性，其特征是“富者愈富”的动态。本练习是一个概念性的实践，要求您运用 Barabási-Albert 模型的两大核心机制——增长和优先连接——来分析学术引用网络的结构。通过这个思想实验，您将推导出为何网络中会自然涌现出少数拥有大量连接的“枢纽”节点，而大多数节点则连接甚少，这是理解无标度网络形成和特性的关键一步。[@problem_id:1471182]", "id": "1471182", "problem": "Barabási-Albert (BA) 模型是一种著名的用于生成随机无标度网络的算法。这些网络通过两种主要机制构建：增长和优先连接。该过程始于一个由少量相互连接的节点组成的小网络。然后，在每个时间步，一个新节点被添加到网络中。这个新节点会与一个现有节点建立连接（一条边），选择哪个现有节点的概率与该节点已有的连接数成正比。这种“富者愈富”的现象被称为优先连接。\n\n考虑一个学术引文网络，它可以用 BA 框架来建模。在这个情境下，研究论文是节点，一篇新论文对一篇已有论文的引用是一条有向边。新研究文章的持续发表构成了网络的增长。优先连接机制反映了研究人员倾向于引用那些已经积累了大量引用的有影响力的论文。\n\nBA 模型预测，最终生成的网络将是“无标度的”，这意味着其度分布遵循 $P(k) \\propto k^{-\\gamma}$ 形式的幂律，其中 $P(k)$ 是网络中度为 $k$（即被引次数）的节点所占的比例，而 $\\gamma$ 是一个正常数。\n\n根据 Barabási-Albert 模型的基本原理和预测结果，以下哪个陈述最准确地描述了一个大规模学术引文网络的长期结构？\n\nA. 引用数将遵循钟形曲线分布，其中大多数论文的引用数接近网络平均值，而引用数极高或极低的论文非常罕见。\nB. 网络将由少数极具影响力的“枢纽”论文主导，这些论文积累了不成比例的大量引用，而绝大多数论文几乎没有或根本没有被引用。\nC. 随着时间的推移，网络中的每篇论文都将以大致相等且恒定的速率获得新的引用，导致随着网络的增长，引用分布相对均匀。\nD. 网络将自然演化到一个引用均匀分布的状态，因为新论文会优先引用知名度较低的作品以增加其可见性。\nE. 网络将由许多小的、孤立的论文簇组成，一篇典型的论文只引用其所在小社群内的少数几篇其他论文，并被它们引用。", "solution": "我们通过 Barabási-Albert 优先连接规则来对网络增长进行建模。在每个时间步，一个新节点进入并与现有节点创建 $m$ 条边，选择现有节点 $i$ 的概率与其当前度 $k_{i}(t)$ 成正比。连接概率为\n$$\n\\Pi_{i}(t)=\\frac{k_{i}(t)}{\\sum_{j}k_{j}(t)}.\n$$\n在标准的无向 BA 模型中，总度为 $\\sum_{j}k_{j}(t)=2mt$，因为每个新增节点贡献 $m$ 条新边，而每条边使总度增加 $2$。在连续近似中，节点 $i$ 的度的期望增长率为\n$$\n\\frac{dk_{i}}{dt}=m\\Pi_{i}(t)=m\\frac{k_{i}(t)}{2mt}=\\frac{k_{i}(t)}{2t}.\n$$\n求解这个微分方程可得\n$$\n\\frac{dk_{i}}{k_{i}}=\\frac{dt}{2t}\\quad\\Longrightarrow\\quad \\ln k_{i}(t)=\\frac{1}{2}\\ln t + C,\n$$\n因此\n$$\nk_{i}(t)=A\\,t^{1/2}.\n$$\n如果节点 $i$ 在时间 $t_{i}$ 进入网络，初始度为 $k_{i}(t_{i})=m$，则 $A=m\\,t_{i}^{-1/2}$，得出\n$$\nk_{i}(t)=m\\left(\\frac{t}{t_{i}}\\right)^{1/2}.\n$$\n为获得度分布，我们考虑一个节点在时间 $t$ 的度至少为 $k$ 的概率。这对应于其进入时间不晚于由上述关系设定的阈值：\n$$\nk_{i}(t)\\ge k \\;\\Longleftrightarrow\\; t_{i}\\le \\frac{m^{2}t}{k^{2}}.\n$$\n假设节点在 $\\{1,\\dots,t\\}$ 上的到达时间是均匀分布的，则累积分布的尺度关系为\n$$\n\\Pr\\{k_{i}(t)\\ge k\\}\\propto \\frac{m^{2}t/k^{2}}{t}=\\frac{m^{2}}{k^{2}},\n$$\n对 $k$ 求导得到稳态度分布\n$$\nP(k)\\propto k^{-3}.\n$$\n因此，BA 模型产生了一个幂律（无标度）度分布 $P(k)\\propto k^{-\\gamma}$，该分布具有重尾；在标准情况下，$\\gamma=3$。重尾幂律意味着度的取值没有特征尺度，方差可能很大，少数节点（枢纽）积累了不成比例的大量边，而大多数节点的度很低。\n\n将此解释应用于通过优先连接（应用于引用）建模的学术引文网络，其长期结构表现为少数被高度引用的枢纽论文和大量引用很少的论文。评估各个选项：\n- 选项 A 描述的是一种钟形曲线（近似高斯）分布，大多数节点接近平均值，这与重尾幂律 $P(k)\\propto k^{-\\gamma}$ 相矛盾。\n- 选项 B 符合幂律所预测的由枢纽主导的重尾结构。\n- 选项 C 假设引用的累积是均匀的，这与优先连接动态 $\\frac{dk_{i}}{dt}\\propto k_{i}$ 相矛盾。\n- 选项 D 假定优先引用知名度较低的作品，这与优先连接的机制恰好相反。\n- 选项 E 断言存在许多小的孤立簇；而 BA 过程产生的是一个具有显著枢纽的连通网络，而不是碎裂成孤立的小社群。\n\n因此，最准确的描述是选项 B。", "answer": "$$\\boxed{B}$$"}]}