{"hands_on_practices": [{"introduction": "要掌握谢林模型，没有什么比亲手构建一个仿真实验更好的方法了。此练习将引导您将谢林模型的核心动态概念化为马尔可夫链过程——这是统计物理学中一个强大的工具。通过实现这个模型，您将亲身体验简单的个体偏好如何出人意料地导致宏观层面的隔离现象，这是一个经典的涌现行为案例。[@problem_id:2411695]", "id": "2411695", "problem": "您将使用统计物理学的语言，将 Schelling 的居住隔离模型建模为一个在二维周期性方形晶格上的时间齐次马尔可夫链。晶格的线性尺寸为 $N$，格点由整数坐标 $(i,j)$ 索引，其中 $i \\in \\{0,\\dots,N-1\\}$ 且 $j \\in \\{0,\\dots,N-1\\}$，并具有周期性边界条件。每个格点带有一个状态 $s_{i,j} \\in \\{-1,0,+1\\}$，其中 $s_{i,j}=+1$ 表示 A 组的一个代理人，$s_{i,j}=-1$ 表示 B 组的一个代理人，而 $s_{i,j}=0$ 表示一个空格点。\n\n定义格点 $(i,j)$ 的半径为 $r$ 的摩尔邻域为所有满足 $\\Delta i,\\Delta j \\in \\{-r,\\dots,r\\}$ 且 $(\\Delta i,\\Delta j) \\neq (0,0)$ 的格点 $(i+\\Delta i \\bmod N, j+\\Delta j \\bmod N)$。对于任意被占据的格点 $(i,j)$（其状态 $s_{i,j} \\in \\{-1,+1\\}$），将其邻域中被占据的邻居数量定义为“被占据邻居计数” $n_{i,j}^{\\mathrm{occ}}$，并将这些被占据的邻居中状态与 $s_{i,j}$ 相同的邻居数量定义为“同类邻居计数” $n_{i,j}^{\\mathrm{like}}$。满意度分数为\n$$\n\\phi_{i,j} =\n\\begin{cases}\n\\frac{n_{i,j}^{\\mathrm{like}}}{n_{i,j}^{\\mathrm{occ}}}, &amp; \\text{若 } n_{i,j}^{\\mathrm{occ}} &gt; 0,\\\\\n1, &amp; \\text{若 } n_{i,j}^{\\mathrm{occ}} = 0,\n\\end{cases}\n$$\n如果 $\\phi_{i,j} \\ge \\tau$，则称一个被占据的格点在阈值 $\\tau \\in [0,1]$ 下是满意的。空格点没有满意度值。\n\n状态空间是由指定比例决定的、具有固定数量的 $+1$、$ -1$ 和 $0$ 的所有构型的集合。该马尔可夫链按如下方式在离散时间内进行转移。在每一步，如果至少有一个被占据的格点不满意，则从所有不满意的被占据格点中均匀随机选择一个，并从所有空格点中均匀随机选择一个，然后将被选中的代理人移动到被选中的空格点（该代理人原来的格点变为空）。如果没有被占据的格点不满意，则链保持在当前状态。这就定义了一个在具有周期性边界条件的有限状态空间上的时间齐次马尔可夫链。当所有被占据的格点都满意时（对于此转移核而言，这是一个吸收构型），或者当达到指定的最大步数 $S_{\\max}$ 时，过程终止。\n\n初始化是在固定数量的约束下随机进行的：给定 $N$、空格点比例 $f_{\\mathrm{empty}} \\in [0,1)$ 以及被占据格点中 $+1$ 类型的比例 $f_{+} \\in [0,1]$，总格点数为 $N^2$，空格点数为 $N^2 f_{\\mathrm{empty}}$，在 $N^2(1-f_{\\mathrm{empty}})$ 个被占据的格点中，$N^2(1-f_{\\mathrm{empty}}) f_{+}$ 为 $+1$ 类型，其余为 $-1$ 类型。假设对于指定的测试用例，所有这些计数都是整数。初始构型是通过将这些计数的代理人和空格点无偏地、均匀随机地放置在晶格上构建的。\n\n对于下面的每个测试用例，使用给定的邻域半径 $r$、满意度阈值 $\\tau$ 和最大步数 $S_{\\max}$，从指定的随机初始条件开始模拟该链。令 $T$ 为终止前执行的移动次数（因此，如果初始构型已经是吸收态，则 $T=0$；如果在达到吸收态之前达到步数上限，则 $T=S_{\\max}$）。令 $\\bar{\\phi}$ 为终止时的平均满意度分数，定义为所有被占据格点 $(i,j)$ 上 $\\phi_{i,j}$ 的算术平均值。报告 $\\bar{\\phi}$，结果四舍五入到三位小数。\n\n您的程序必须为以下测试套件生成结果。在每种情况下，为了可复现性，请使用给定的种子进行独立的伪随机初始化和随机选择。\n\n- 情况 1：$N=20$, $f_{\\mathrm{empty}}=0.1$, $f_{+}=0.5$, $\\tau=0.5$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=1$。\n- 情况 2：$N=15$, $f_{\\mathrm{empty}}=0.2$, $f_{+}=0.5$, $\\tau=0$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=2$。\n- 情况 3：$N=20$, $f_{\\mathrm{empty}}=0.2$, $f_{+}=0.5$, $\\tau=0.9$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=3$。\n- 情况 4：$N=5$, $f_{\\mathrm{empty}}=0.2$, $f_{+}=0.5$, $\\tau=0.6$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=4$。\n\n最终输出格式：您的程序应生成单行内容，其中包含一个方括号括起来的逗号分隔列表。列表中的每个元素是一个测试用例的结果对 $[T,\\bar{\\phi}]$，其中 $\\bar{\\phi}$ 四舍五入到三位小数。例如，一个包含两个假设结果的有效输出将如下所示：“[[$1$, $0.750$],[$200$, $0.643$]]”。不得有任何额外文本。所有报告的 $\\bar{\\phi}$ 值必须四舍五入到三位小数，且 $T$ 必须是整数。", "solution": "该问题是有效的。它提出了一个定义明确的计算任务，该任务基于公认的 Schelling 隔离模型，并使用在晶格上的时间齐次马尔可夫链在统计物理学框架内进行表述。所有参数、初始条件和动力学过程都得到了明确无误的规定。\n\n解决方案需要模拟此马尔可夫链。其方法论的核心概述如下。\n\n**1. 系统状态与初始化**\n系统状态是线性尺寸为 $N$ 的 `$2$` 维方形晶格上的一个构型。这由一个具有周期性边界条件的 $N \\times N$ 矩阵 $\\mathbf{S}$ 表示。每个格点 $(i,j)$ 都有一个状态 $s_{i,j} \\in \\{-1, 0, +1\\}$，其中 `$+1$` 和 `$-1$` 表示两种不同类型的代理人，而 `$0$` 表示一个空格点。\n\n初始构型是随机生成的，但每种类型的格点数量是固定的。给定总格点数 $N^2$、空格点比例 $f_{\\mathrm{empty}}$ 和被占据格点中的 $+1$ 类型比例 $f_{+}$，各项计数如下：\n- 空格点数：$N_{\\mathrm{empty}} = \\lfloor N^2 f_{\\mathrm{empty}} \\rfloor$\n- 被占据格点数：$N_{\\mathrm{occ}} = N^2 - N_{\\mathrm{empty}}$\n- `$+1$` 类型代理人数：$N_{+} = \\lfloor N_{\\mathrm{occ}} f_{+} \\rfloor$\n- `$-1$` 类型代理人数：$N_{-} = N_{\\mathrm{occ}} - N_{+}$\n\n创建一个包含指定数量的 `$+1$`、`$-1$` 和 `$0$` 值的一维数组。使用提供的伪随机种子将此数组打乱，然后重塑为 $N \\times N$ 矩阵 $\\mathbf{S}$，从而确保代理人的均匀随机放置。\n\n**2. 代理人满意度与邻域分析**\n动力学由代理人的不满意度驱动。位于被占据格点 $(i,j)$ 的代理人的满意度，由满意度分数 $\\phi_{i,j}$ 量化。该值由其在半径为 $r$ 的摩尔邻域内的局部环境决定。对于每个代理人，我们必须计算其被占据的邻居数量 $n_{i,j}^{\\mathrm{occ}}$ 和其同类型邻居的数量 $n_{i,j}^{\\mathrm{like}}$。满意度分数的定义如下：\n$$\n\\phi_{i,j} =\n\\begin{cases}\n\\frac{n_{i,j}^{\\mathrm{like}}}{n_{i,j}^{\\mathrm{occ}}}, &amp; \\text{if } n_{i,j}^{\\mathrm{occ}} &gt; 0\\\\\n1, &amp; \\text{if } n_{i,j}^{\\mathrm{occ}} = 0\n\\end{cases}\n$$\n如果一个代理人的满意度分数低于给定的阈值，即 $\\phi_{i,j} < \\tau$，则该代理人被视为不满意。\n\n为了高效地同时计算所有格点的邻居数量，我们采用二维卷积。我们为被占据格点（$\\mathbf{M}_{\\mathrm{occ}}$）、`$+1$` 类型格点（$\\mathbf{M}_{+}$）和 `$-1$` 类型格点（$\\mathbf{M}_{-}$）定义二元指示矩阵。一个卷积核 $\\mathbf{K}$，即一个中心为 `$0$`、其余元素为 `$1$` 的 $(2r+1) \\times (2r+1)$ 矩阵，代表了邻域求和。然后，通过带周期性边界处理的卷积操作（用 $*$ 表示）可以得到邻居计数图：\n- 被占据邻居计数图：$\\mathbf{N}_{\\mathrm{occ}} = \\mathbf{M}_{\\mathrm{occ}} * \\mathbf{K}$\n- `$+1$` 类型邻居图：$\\mathbf{N}_{+} = \\mathbf{M}_{+} * \\mathbf{K}$\n- `$-1$` 类型邻居图：$\\mathbf{N}_{-} = \\mathbf{M}_{-} * \\mathbf{K}$\n根据这些图，每个格点的 $n_{i,j}^{\\mathrm{like}}$ 值由其自身类型决定，随后便可计算出 $\\phi_{i,j}$ 值的矩阵。\n\n**3. 马尔可夫链动力学**\n系统在离散时间步上演化。模拟最多进行 $S_{\\max}$ 步。在每一步中：\n1. 计算每个代理人的满意度。识别出所有不满意代理人的坐标集合。\n2. 如果该集合为空，则所有代理人都满意。系统已达到吸收态，模拟终止。记录下总移动次数 $T$。\n3. 如果存在不满意的代理人，则从各自的可用位置集合中均匀随机地选择 `$1$` 个不满意的代理人和 `$1$` 个空格点。\n4. 将所选代理人所在格点的状态与所选空格点的状态交换。这构成 `$1$` 次移动，步数计数器 $T$ 加一。\n5. 如果模拟在达到吸收态前运行了最大步数，则模拟终止，且 $T=S_{\\max}$。\n\n**4. 最终测量**\n终止时，计算最终的平均满意度分数 $\\bar{\\phi}$。这是最终网格构型中所有被占据格点上 $\\phi_{i,j}$ 的算术平均值。每个测试用例所需的输出是整数移动次数 $T$ 和四舍五入到 `$3$` 位小数的 $\\bar{\\phi}$ 值。该实现为问题中指定的每个测试用例执行这整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef run_simulation(N, f_empty, f_plus, tau, r, S_max, seed):\n    \"\"\"\n    Simulates Schelling's segregation model for a given set of parameters.\n\n    Args:\n        N (int): Linear size of the lattice.\n        f_empty (float): Fraction of empty sites.\n        f_plus (float): Fraction of +1 agents among occupied sites.\n        tau (float): Satisfaction threshold.\n        r (int): Radius of the Moore neighborhood.\n        S_max (int): Maximum number of simulation steps.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        tuple[int, float]: A tuple containing the number of moves (T)\n                           and the mean satisfaction (phi_bar).\n    \"\"\"\n    # 1. Initialization\n    rng = np.random.default_rng(seed)\n\n    N_total = N * N\n    N_empty = int(N_total * f_empty)\n    N_occ = N_total - N_empty\n    N_plus = int(N_occ * f_plus)\n    N_minus = N_occ - N_plus\n\n    # Create and shuffle the initial population on a 1D array\n    initial_flat_grid = np.array(\n        [1] * N_plus + [-1] * N_minus + [0] * N_empty, dtype=np.int8\n    )\n    rng.shuffle(initial_flat_grid)\n    grid = initial_flat_grid.reshape((N, N))\n\n    # Convolution kernel for Moore neighborhood\n    kernel = np.ones((2 * r + 1, 2 * r + 1), dtype=np.uint8)\n    kernel[r, r] = 0\n\n    T = 0\n    # 2. Main simulation loop\n    for _ in range(S_max):\n        occupied_mask = grid != 0\n        plus_mask = grid == 1\n        minus_mask = grid == -1\n\n        # Use convolution to find neighbor counts efficiently\n        n_occ_map = convolve2d(occupied_mask, kernel, mode=\"same\", boundary=\"wrap\")\n\n        # Calculate satisfaction for all agents\n        # Default phi to 1, for agents with 0 occupied neighbors\n        phi_map = np.ones_like(grid, dtype=float)\n        \n        # Identify sites where phi needs to be calculated (occupied with neighbors)\n        calc_phi_mask = occupied_mask & (n_occ_map > 0)\n\n        if np.any(calc_phi_mask):\n            n_plus_neighbors = convolve2d(plus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            n_minus_neighbors = convolve2d(minus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n\n            n_like_map = np.zeros_like(grid, dtype=int)\n            n_like_map[plus_mask] = n_plus_neighbors[plus_mask]\n            n_like_map[minus_mask] = n_minus_neighbors[minus_mask]\n            \n            # Use errstate to prevent warnings on potential division by zero,\n            # though the mask should already prevent this.\n            with np.errstate(divide='ignore', invalid='ignore'):\n                phi_map[calc_phi_mask] = n_like_map[calc_phi_mask] / n_occ_map[calc_phi_mask]\n\n        unsatisfied_mask = occupied_mask & (phi_map < tau)\n        unsatisfied_coords = np.argwhere(unsatisfied_mask)\n\n        # Check for termination (absorbing state)\n        if len(unsatisfied_coords) == 0:\n            break\n\n        # 3. Perform a move\n        T += 1\n        empty_coords = np.argwhere(grid == 0)\n\n        # Choose one unsatisfied agent and one empty site uniformly at random\n        u_idx = rng.choice(len(unsatisfied_coords))\n        e_idx = rng.choice(len(empty_coords))\n\n        u_coords = tuple(unsatisfied_coords[u_idx])\n        e_coords = tuple(empty_coords[e_idx])\n\n        # Swap the agent and the empty site\n        grid[e_coords], grid[u_coords] = grid[u_coords], grid[e_coords]\n\n    # 4. Final calculation of mean satisfaction\n    occupied_mask = grid != 0\n    num_occupied = np.sum(occupied_mask)\n\n    if num_occupied == 0:\n        mean_phi = 0.0 # Should not happen based on problem constraints\n    else:\n        # Recalculate phi_map for the final configuration\n        n_occ_map = convolve2d(occupied_mask, kernel, mode=\"same\", boundary=\"wrap\")\n        phi_map = np.ones_like(grid, dtype=float)\n        calc_phi_mask = occupied_mask & (n_occ_map > 0)\n\n        if np.any(calc_phi_mask):\n            plus_mask = grid == 1\n            minus_mask = grid == -1\n            n_plus_neighbors = convolve2d(plus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            n_minus_neighbors = convolve2d(minus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            \n            n_like_map = np.zeros_like(grid, dtype=int)\n            n_like_map[plus_mask] = n_plus_neighbors[plus_mask]\n            n_like_map[minus_mask] = n_minus_neighbors[minus_mask]\n\n            with np.errstate(divide='ignore', invalid='ignore'):\n                phi_map[calc_phi_mask] = n_like_map[calc_phi_mask] / n_occ_map[calc_phi_mask]\n\n        total_phi = np.sum(phi_map[occupied_mask])\n        mean_phi = total_phi / num_occupied\n\n    return T, mean_phi\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, f_empty, f_plus, tau, r, S_max, seed)\n        (20, 0.1, 0.5, 0.5, 1, 20000, 1),\n        (15, 0.2, 0.5, 0.0, 1, 20000, 2),\n        (20, 0.2, 0.5, 0.9, 1, 20000, 3),\n        (5, 0.2, 0.5, 0.6, 1, 20000, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, f_empty, f_plus, tau, r, S_max, seed = case\n        T, phi_bar = run_simulation(N, f_empty, f_plus, tau, r, S_max, seed)\n        results.append(f\"[{T}, {phi_bar:.3f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "现实世界中的社会景观并非完全同质；其中一些要素是固定的且具有影响力。本练习通过引入固定的“影响者”智能体来扩展基础模型，这些智能体在社区中扮演着“锚点”的角色。您的任务是分析这些固定点如何影响其他可移动智能体的行为并塑造最终的隔离格局，同时学习使用“锚定提升度”这一指标来量化它们的影响力。[@problem_id:2428488]", "id": "2428488", "problem": "请考虑一个在有限二维离散格网上的双类型谢林隔离模型，其中包含固定的“影响者”智能体。该格网是一个具有环形边界条件（双轴回绕）的 $n \\times n$ 网格。每个位置要么是一个空格（编码为 $0$），要么是一个类型 $1$ 的智能体（编码为 $1$），要么是一个类型 $2$ 的智能体（编码为 $2$）。一部分智能体是影响者：它们的类型和位置固定，从不移动；非影响者智能体可以移动。邻域是半径为 $1$ 的摩尔(Moore)类型，在环形几何下：每个单元格有 $8$ 个邻居（所有在环面上切比雪夫距离恰好为 $1$ 的单元格）。对于任何位于坐标 $(i,j)$ 且类型为 $s \\in \\{1,2\\}$ 的已占据单元格，定义其局部同类型比例为\n$$\nf_s(i,j) \\equiv \n\\begin{cases}\n\\frac{\\text{类型为 } s \\text{ 的已占据邻居数量}}{\\text{已占据邻居总数}}, & \\text{若已占据邻居总数} \\gt 0,\\\\\n1, & \\text{若已占据邻居总数} = 0.\n\\end{cases}\n$$\n如果一个智能体满足 $f_s(i,j) \\ge \\tau$，则该智能体是满意的，其中 $\\tau \\in [0,1]$ 是共同的容忍度。\n\n初始化：对于给定的整数 $N_1 \\ge 0$ 和 $N_2 \\ge 0$ 且 $N_1 + N_2 \\le n^2$，首先将所有影响者放置在它们指定的坐标上，并赋予其指定的类型（它们计入 $N_1$ 或 $N_2$ 的总数）。然后，按照行主序（行索引 $i$ 递增，若相同则按列索引 $j$ 递增）填充剩余的 $N_1 + N_2 - (\\text{影响者数量})$ 个非影响者智能体，跳过已被影响者占据的单元格。非影响者智能体按类型 $1,2,1,2,\\dots$ 交替放置，从类型 $1$ 开始，并受每种类型的剩余数量限制：当当前类型的剩余数量为零时，切换到另一种类型；继续此过程，直到所有需要的智能体都放置完毕。所有剩余的单元格为空。\n\n动力学：只有非影响者智能体可以移动。动力学过程以离散的扫描（由 $t = 1,2,\\dots$ 索引）进行，每次扫描都按行主序遍历所有网格坐标。在扫描期间，每当遇到位于 $(i,j)$ 的类型为 $s$ 的非影响者智能体时，计算其当前的 $f_s(i,j)$。如果 $f_s(i,j) \\ge \\tau$，它不移动。如果 $f_s(i,j) \\lt \\tau$，则将所有当前为空的单元格视为潜在的目标位置；对于每个空单元格，评估类型为 $s$ 的智能体如果被放置在该目标位置时会有的同类型比例，评估基于该智能体当前单元格 $(i,j)$ 已被清空的状态。该智能体选择使其比例最大化的目标位置；如果有多个最大化者，则选择字典序最小的坐标（最小的行，然后是最小的列）。当且仅当最大目标比例严格大于其当前的 $f_s(i,j)$ 时，该智能体才会移动。影响者从不移动。当所有坐标都处理完毕后，一次扫描结束；当完整的一次扫描中没有任何移动发生，或达到指定的最大扫描次数 $T_{\\max}$ 时，过程停止。\n\n终止后的隔离度量：令 $H$ 表示全局平均同质性，\n$$\nH \\equiv \\frac{1}{M}\\sum_{(i,j)\\ \\text{occupied}} f_{s(i,j)}(i,j),\n$$\n其中 $M$ 是已占据单元格的总数，$s(i,j)\\in\\{1,2\\}$ 是 $(i,j)$ 处的类型。对于每个类型为 $s_k$、位置为 $(i_k,j_k)$ 的影响者 $k$，以及给定的邻域半径 $r \\in \\mathbb{N}$，定义影响者的局部同类型份额 $L_k$ 为：在环面上与 $(i_k,j_k)$ 的切比雪夫距离最多为 $r$ 的范围内，类型为 $s_k$ 的已占据单元格所占的比例（分子和分母都包括影响者自身的单元格）。令 $G_{s}$ 为类型 $s$ 在所有已占据单元格中的全局份额，即\n$$\nG_s \\equiv \\frac{\\text{类型为 } s \\text{ 的已占据单元格数量}}{M}.\n$$\n定义影响者 $k$ 的锚定提升度为 $L_k - G_{s_k}$。对于下方的每个测试用例，将该测试用例的结果定义为其所有影响者的锚定提升度的算术平均值。如果一个测试用例没有影响者，则其结果定义为 $H$。\n\n请完全按照上述定义实现该模型，并计算每个测试用例的测试用例结果。所有邻域和半径计算都统一使用切比雪夫距离和环形回绕。所有坐标都是零索引的，行和列的取值范围为 $\\{0,1,\\dots,n-1\\}$。\n\n测试套件：\n- 用例A（一般情况）：$n=10$，容忍度 $\\tau=0.5$，最大扫描次数 $T_{\\max}=200$，半径 $r=2$，总数 $(N_1,N_2)=(45,45)$，影响者：两个类型 $1$ 的影响者，分别位于 $(0,0)$ 和 $(9,9)$。\n- 用例B（另一种类型的中心锚点）：$n=10$，容忍度 $\\tau=0.5$，最大扫描次数 $T_{\\max}=200$，半径 $r=2$，总数 $(N_1,N_2)=(45,45)$，影响者：两个类型 $2$ 的影响者，分别位于 $(5,5)$ 和 $(5,6)$。\n- 用例C（更高容忍度的边界）：$n=10$，容忍度 $\\tau=0.75$，最大扫描次数 $T_{\\max}=200$，半径 $r=2$，总数 $(N_1,N_2)=(50,40)$，影响者：一个类型 $1$ 的影响者位于 $(0,0)$，一个类型 $2$ 的影响者位于 $(0,9)$。\n- 用例D（无空位边缘情况）：$n=10$，容忍度 $\\tau=0.5$，最大扫描次数 $T_{\\max}=200$, 半径 $r=2$，总数 $(N_1,N_2)=(50,50)$，影响者：一个类型 $1$ 的影响者位于 $(5,5)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用例A到D的结果，按顺序排列为一个逗号分隔的四个实数列表，并用方括号括起来，每个数字四舍五入到小数点后恰好四位（例如，[$x_A$,$x_B$,$x_C$,$x_D$]）。", "solution": "该问题已经过验证。\n\n### 步骤1：提取已知条件\n- **格网:** $n \\times n$ 网格，具有环形边界条件。\n- **单元格状态:** 空（$0$）、类型1（$1$）、类型2（$2$）。\n- **智能体类型:** 可移动的非影响者和具有固定位置和类型的不可移动的影响者。\n- **邻域:** 摩尔(Moore)邻域，半径为 $1$，环形几何（$8$ 个邻居）。\n- **局部同类型比例 ($f_s(i,j)$):** 对于位于 $(i,j)$ 的类型为 $s$ 的智能体，其已占据邻居中类型为 $s$ 的比例。若无已占据邻居，则 $f_s(i,j) = 1$。\n- **满意度:** 若 $f_s(i,j) \\ge \\tau$，则智能体是满意的。\n- **初始化:** 首先放置影响者。然后，按行主序填充剩余的智能体（总数为 $N_1$, $N_2$），交替放置类型（$1,2,1,2,\\dots$），但若首选类型已用尽，则使用另一类型。\n- **动力学:** 扫描以行主序遍历网格。不满意的非影响者评估所有空单元格作为潜在目标位置。只有当某个目标位置能提供的假想同类型比例的最大值严格大于当前比例时，才会移动到该位置。目标位置的平局通过字典序解决。网格在单次扫描内是序贯更新的。\n- **终止条件:** 在一次扫描中无移动发生后，或在 $T_{\\max}$ 次扫描后停止。\n- **度量:**\n  - $H$: 全局平均同质性。\n  - $L_k$: 对于类型为 $s_k$ 的影响者 $k$，在其环形切比雪夫距离 $r$ 范围内的同类型智能体比例。\n  - $G_s$: 类型为 $s$ 的智能体的全局比例。\n  - 锚定提升度: $L_k - G_{s_k}$。\n- **测试用例结果:** 所有影响者的锚定提升度的算术平均值。若无影响者，结果为 $H$。\n- **测试用例:**\n  - A: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(45,45)$, 影响者: 两个类型 $1$ 在 $(0,0), (9,9)$。\n  - B: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(45,45)$, 影响者: 两个类型 $2$ 在 $(5,5), (5,6)$。\n  - C: $n=10, \\tau=0.75, T_{\\max}=200, r=2, (N_1,N_2)=(50,40)$, 影响者: 一个类型 $1$ 在 $(0,0)$，一个类型 $2$ 在 $(0,9)$。\n  - D: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(50,50)$, 影响者: 一个类型 $1$ 在 $(5,5)$。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据:** 该问题描述了谢林隔离模型的一个变体，这是计算社会科学中的一个经典模型。规则是标准模型的扩展，并且在科学上是连贯的。\n2.  **适定性:** 该问题是确定性的。初始化规则、智能体动力学和解决平局的程序都得到了明确规定，保证了系统从给定的初始状态演化是唯一的。终止是有保证的。\n3.  **客观性:** 问题以精确、数学化和算法化的术语表述，不含任何主观性。\n4.  **完整性:** 提供了所有必要的参数（$n$, $\\tau$, $N_1$, $N_2$, $T_{\\max}$, $r$, 影响者详情）。所有特殊情况（例如，零个已占据邻居、无空单元格）的规则在逻辑上与整体框架一致。\n5.  **结构:** 问题结构良好，提出了一个清晰的计算任务。\n\n### 步骤3：结论与行动\n该问题是有效的。其前提条件合理，规格说明完整且无歧义。我们着手构建一个解决方案。\n\n解决方案是所描述的基于智能体的模型的直接模拟。实现分为三个主要部分：网格初始化、智能体动力学模拟和最终隔离度量计算。\n\n**1. 网格初始化**\n\n$n \\times n$ 的格网由一个二维整数数组表示。一个并行的布尔数组用于标记影响者的位置。\n- 过程始于创建一个初始化为状态 $0$（空）的 $n \\times n$ 网格。\n- 影响者被放置在它们指定的坐标 $(i,j)$ 上，并赋予给定的类型 $s \\in \\{1,2\\}$。影响者标志数组中的相应条目被设置为 `true`。待放置的智能体总数 $N_1$ 和 $N_2$ 相应地递减。\n- 剩余的非影响者智能体通过按行主序（从 $(0,0)$到 $(n-1, n-1)$）遍历网格来放置在空闲单元格中。智能体类型通过遵循一个交替序列 $1, 2, 1, 2, \\dots$ 来分配。如果序列中指定类型的配额已用尽，则改为放置另一种类型。然后序列在下一个可用单元格上继续其交替。此过程一直持续到所有 $N_1$ 和 $N_2$ 智能体都放置在网格上。\n\n**2. 动力学模拟**\n\n模拟以离散的扫描进行，最多进行 $T_{\\max}$ 次。\n- 每次扫描包括按行主序对所有网格单元格 $(i,j)$ 进行一次遍历。\n- 在每个单元格，如果它包含类型为 $s$ 的非影响者智能体，则计算其局部同类型比例 $f_s(i,j)$。\n- 如果智能体不满意，即 $f_s(i,j) < \\tau$，则启动寻找新位置的搜索。\n  - 潜在目标位置的集合包括网格上所有当前为空的单元格。\n  - 对于每个潜在目标位置，计算一个假想的同类型比例。这是智能体移动到那里后将体验到的比例。计算是在一个假想的网格副本上进行的，该副本中智能体的原始单元格 $(i,j)$ 已被清空。\n  - 智能体识别出能产生最大假想比例的目标位置。平局通过选择字典序最小坐标的目标来解决。\n  - 只有当这个最大目标比例严格大于智能体当前的比例 $f_s(i,j)$ 时，才会执行移动。\n- 如果发生移动，网格会立即更新：智能体的类型被放置到新单元格中，其原始单元格变为空。这个更新后的网格状态将用于同一扫描中所有后续的智能体评估。\n- 如果一次完整的扫描结束后没有任何智能体移动，或者完成了 $T_{\\max}$ 次扫描，模拟将终止。\n\n**3. 度量计算**\n\n模拟终止后，从最终的网格配置计算出最终的测试用例结果。\n- 对于每个包含影响者的测试用例，结果是所有影响者的锚定提升度的算术平均值。\n- 类型为 $s_k$ 的影响者 $k$ 的锚定提升度为 $L_k - G_{s_k}$。\n- $G_{s_k}$ 是类型为 $s_k$ 的智能体的全局份额，由 $G_{s_k} = \\frac{N_{s_k}}{N_1 + N_2}$ 给出。\n- $L_k$ 是影响者的局部同类型份额。要计算它，我们考虑在影响者 $(i_k,j_k)$ 周围一个半径为 $r$ 的方形邻域，使用环形切比雪夫距离。$L_k$ 是此邻域内类型为 $s_k$ 的已占据单元格数量与同一邻域内已占据单元格总数的比率。影响者自身的单元格包含在这两个计数中。\n\n这个详细的算法流程确保了对模型规格的忠实实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Schelling segregation model for the provided test suite.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 45, 'N2': 45, \n         'influencers': [((0, 0), 1), ((9, 9), 1)]},\n        # Case B\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 45, 'N2': 45, \n         'influencers': [((5, 5), 2), ((5, 6), 2)]},\n        # Case C\n        {'n': 10, 'tau': 0.75, 'T_max': 200, 'r': 2, 'N1': 50, 'N2': 40, \n         'influencers': [((0, 0), 1), ((0, 9), 2)]},\n        # Case D\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 50, 'N2': 50, \n         'influencers': [((5, 5), 1)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    print(f\"[{','.join([f'{x:.4f}' for x in results])}]\")\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case from initialization to final metric calculation.\n    \"\"\"\n    n, N1, N2, tau, T_max, r = params['n'], params['N1'], params['N2'], params['tau'], params['T_max'], params['r']\n    influencers = params['influencers']\n\n    grid, is_influencer, influencer_info = initialize_grid(n, N1, N2, influencers)\n    final_grid = run_simulation(grid, is_influencer, n, tau, T_max)\n    metric = calculate_metrics(final_grid, N1, N2, influencer_info, n, r)\n    \n    return metric\n\ndef get_moore_neighbors(r, c, n):\n    \"\"\"Gets Moore neighborhood coordinates with toroidal boundary.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = (r + dr) % n, (c + dc) % n\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef calculate_homophily(grid, r, c, agent_type, n):\n    \"\"\"\n    Calculates the local same-type fraction for an agent of `agent_type` at (r,c).\n    \"\"\"\n    neighbors = get_moore_neighbors(r, c, n)\n    same_type_neighbors = 0\n    occupied_neighbors = 0\n    \n    for nr, nc in neighbors:\n        neighbor_type = grid[nr, nc]\n        if neighbor_type > 0:\n            occupied_neighbors += 1\n            if neighbor_type == agent_type:\n                same_type_neighbors += 1\n    \n    if occupied_neighbors == 0:\n        return 1.0\n    return same_type_neighbors / occupied_neighbors\n\ndef initialize_grid(n, N1, N2, influencers):\n    \"\"\"Initializes the grid according to the problem statement.\"\"\"\n    grid = np.zeros((n, n), dtype=int)\n    is_influencer = np.zeros((n, n), dtype=bool)\n    \n    rem_N1, rem_N2 = N1, N2\n    influencer_info = []\n\n    for pos, type in influencers:\n        grid[pos] = type\n        is_influencer[pos] = True\n        influencer_info.append((pos, type))\n        if type == 1:\n            rem_N1 -= 1\n        else:\n            rem_N2 -= 1\n            \n    next_type_in_sequence = 1\n    for r in range(n):\n        for c in range(n):\n            if rem_N1 == 0 and rem_N2 == 0:\n                break\n            if grid[r, c] == 0:\n                type_to_place = 0\n                if next_type_in_sequence == 1:\n                    if rem_N1 > 0:\n                        type_to_place = 1\n                    elif rem_N2 > 0:\n                        type_to_place = 2\n                else: \n                    if rem_N2 > 0:\n                        type_to_place = 2\n                    elif rem_N1 > 0:\n                        type_to_place = 1\n                \n                if type_to_place == 1:\n                    grid[r, c] = 1\n                    rem_N1 -= 1\n                elif type_to_place == 2:\n                    grid[r, c] = 2\n                    rem_N2 -= 1\n                \n                next_type_in_sequence = 3 - next_type_in_sequence\n        if rem_N1 == 0 and rem_N2 == 0:\n            break\n            \n    return grid, is_influencer, influencer_info\n\ndef run_simulation(grid, is_influencer, n, tau, T_max):\n    \"\"\"Runs the Schelling model simulation with sequential updates.\"\"\"\n    current_grid = grid.copy()\n    for _ in range(T_max):\n        moved_in_sweep = False\n        for r in range(n):\n            for c in range(n):\n                agent_type = current_grid[r, c]\n                if agent_type > 0 and not is_influencer[r, c]:\n                    current_f = calculate_homophily(current_grid, r, c, agent_type, n)\n                    \n                    if current_f < tau:\n                        empty_cells = list(zip(*np.where(current_grid == 0)))\n                        if not empty_cells:\n                            continue\n\n                        max_f = -1.0\n                        best_dest = None\n                        \n                        hypothetical_grid = current_grid.copy()\n                        hypothetical_grid[r, c] = 0\n\n                        for dest_r, dest_c in empty_cells:\n                            f_dest = calculate_homophily(hypothetical_grid, dest_r, dest_c, agent_type, n)\n                            if f_dest > max_f:\n                                max_f = f_dest\n                                best_dest = (dest_r, dest_c)\n                            elif f_dest == max_f:\n                                if (dest_r, dest_c) < best_dest:\n                                    best_dest = (dest_r, dest_c)\n                        \n                        if best_dest is not None and max_f > current_f:\n                            current_grid[best_dest] = agent_type\n                            current_grid[r, c] = 0\n                            moved_in_sweep = True\n                            \n        if not moved_in_sweep:\n            break\n            \n    return current_grid\n\ndef torus_chebyshev_dist(p1, p2, n):\n    \"\"\"Calculates Chebyshev distance on an n x n torus.\"\"\"\n    dr = abs(p1[0] - p2[0])\n    dc = abs(p1[1] - p2[1])\n    torus_dr = min(dr, n - dr)\n    torus_dc = min(dc, n - dc)\n    return max(torus_dr, torus_dc)\n\ndef calculate_metrics(final_grid, N1, N2, influencer_info, n, r):\n    \"\"\"Calculates the final test-case result (mean anchoring lift).\"\"\"\n    M = N1 + N2\n    if M == 0: return 0.0\n\n    if not influencer_info: # This case is not in the test suite but handled for completeness\n        total_homophily = 0.0\n        occupied_coords = np.argwhere(final_grid > 0)\n        for r_occ, c_occ in occupied_coords:\n            agent_type = final_grid[r_occ, c_occ]\n            total_homophily += calculate_homophily(final_grid, r_occ, c_occ, agent_type, n)\n        return total_homophily / M\n    \n    lifts = []\n    G1 = N1 / M\n    G2 = N2 / M\n    G_map = {1: G1, 2: G2}\n\n    for inf_pos, inf_type in influencer_info:\n        local_same_count = 0\n        local_total_count = 0\n        for r_cell in range(n):\n            for c_cell in range(n):\n                if torus_chebyshev_dist(inf_pos, (r_cell, c_cell), n) <= r:\n                    cell_type = final_grid[r_cell, c_cell]\n                    if cell_type > 0:\n                        local_total_count += 1\n                        if cell_type == inf_type:\n                            local_same_count += 1\n        \n        Lk = local_same_count / local_total_count if local_total_count > 0 else 0.0\n        Gs_k = G_map[inf_type]\n        lift = Lk - Gs_k\n        lifts.append(lift)\n        \n    return np.mean(lifts)\n\nsolve()\n\n```"}, {"introduction": "基于智能体的模型是探索不同行为假设的灵活工具。在此练习中，我们将从随机移动转向确定性的“最佳响应”动态，其中不满意的智能体会主动寻找最佳的可用位置。我们还将引入分阶段的人口增长，模拟一个不断发展的城市，以观察隔离动态在非静态环境下的演变过程。[@problem_id:2428508]", "id": "2428508", "problem": "考虑一个在有限方格网络上的双类型 Schelling 分隔模型。设网格为一个 $N \\times N$ 的单元格阵列。每个单元格要么是空置的（状态 $0$），要么被两种代理类型之一占据（类型 $A$ 为状态 $1$，类型 $B$ 为状态 $2$）。每个代理拥有相同的偏好阈值 $\\tau \\in [0,1]$，并根据其半径为1的 Moore 邻域（即周围的8个单元格，在边缘和角落处则较少）来评估满意度。位于 $(i,j)$ 位置的被占据单元格是满意的，如果其已占据邻居中同类型邻居的比例至少为 $\\tau$。如果该单元格没有已占据的邻居，则按约定视为满意。\n\n空置率在离散的阶段中变化，使得网格随时间逐渐填充：给定一个序列 $\\{\\rho_0,\\rho_1,\\dots,\\rho_K\\}$，其中对所有 $k$ 都有 $\\rho_{k+1} \\le \\rho_k$，阶段 $k$ 的目标空置单元格数量定义为 $V_k = \\left\\lfloor \\rho_k N^2 + \\tfrac{1}{2} \\right\\rfloor$。初始网格是空的（所有单元格均为空置），在阶段 $k$ 进行任何移动之前，需要新增的代理数量为 $\\Delta_k = V_{k-1} - V_k$（对于空网格，设 $V_{-1} := N^2$）。新代理以固定的人口构成比例到达：比例为 $p_A \\in [0,1]$ 的新代理是类型 $A$，比例为 $1 - p_A$ 的是类型 $B$。在每个阶段 $k$，新代理被确定性地按行主序添加到前 $\\Delta_k$ 个当前空置的单元格中，首先放置 $\\lfloor p_A \\Delta_k \\rfloor$ 个类型 $A$ 的代理，然后放置 $\\Delta_k - \\lfloor p_A \\Delta_k \\rfloor$ 个类型 $B$ 的代理，无论它们进入时的初始满意度如何。\n\n在阶段 $k$ 代理到达后，代理们可以根据以下序贯最优响应动态进行移动以提高满意度，该过程以扫描的形式重复。在一次扫描中，按行主序访问所有单元格。对于每个当前不满意的已占据单元格，按行主序搜索当前空置单元格列表，并将该代理移动到其到达后会满意的第一个空置单元格（评估时假定代理已离开当前单元格并占据候选单元格）。如果不存在这样的空置单元格，则该代理在本次扫描中不移动。每次成功的移动都会相应地更新空置单元格集合。持续执行扫描，直到 (i) 一次扫描完成且没有任何移动，或 (ii) 当前阶段的扫描次数达到给定的最大值 $M$。\n\n在最终阶段 $K$ 结束时，当代理到达和移动扫描完成后，计算分隔指数，其定义为平均局部同质性：\n$$\nS = \\frac{1}{|\\mathcal{O}|} \\sum_{(i,j)\\in\\mathcal{O}} h_{ij},\n\\quad h_{ij} =\n\\begin{cases}\n\\frac{\\text{位于 }(i,j)\\text{ 的同类型已占据邻居数量}}{\\text{位于 }(i,j)\\text{ 的总已占据邻居数量}}, & \\text{如果总已占据邻居数量} > 0,\\\\\n1, & \\text{如果总已占据邻居数量} = 0,\n\\end{cases}\n$$\n其中 $\\mathcal{O}$ 是被占据单元格的集合。值 $S$ 必须作为一个四舍五入到四位小数的实数报告。\n\n严格按照上述规定实现该动态过程，所有平局情况均通过行主序解决，所有计数均在 Moore 邻域上计算。任何步骤中都不能有随机性。\n\n您的程序必须解决以下测试套件。对于每个测试用例，程序应运行该模型并输出最终的分隔指数 $S$，四舍五入到四位小数。\n\n测试用例:\n1) $N = 10$, $\\{\\rho_k\\}_{k=0}^2 = \\{0.6, 0.4, 0.2\\}$, $\\tau = 0.3$, $p_A = 0.5$, $M = 200$.\n2) $N = 10$, $\\{\\rho_k\\}_{k=0}^2 = \\{0.6, 0.4, 0.2\\}$, $\\tau = 0.6$, $p_A = 0.5$, $M = 200$.\n3) $N = 8$, $\\{\\rho_k\\}_{k=0}^2 = \\{0.7, 0.5, 0.3\\}$, $\\tau = 0.0$, $p_A = 0.7$, $M = 200$.\n4) $N = 12$, $\\{\\rho_k\\}_{k=0}^2 = \\{0.8, 0.5, 0.2\\}$, $\\tau = 1.0$, $p_A = 0.5$, $M = 300$.\n\n最终输出格式：您的程序应生成单行输出，其中包含测试套件的结果，格式为方括号括起来的逗号分隔列表，顺序与上面列出的一致，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是对应的 $S$ 值，四舍五入到四位小数。列表前后不得有任何额外文本。不涉及物理单位或角度单位。所有分数都必须报告为按规定四舍五入后的小数。", "solution": "该问题要求在一个方格网络上实现一个确定性的、多阶段的 Schelling 分隔模型。问题陈述的有效性已得到确认，因为它在科学上基于成熟的基于代理的建模原则，是良定的，所有必要的参数和规则都得到了无歧义的定义，并且在算法上被明确规定以确保一个唯一的、可验证的解。\n\n解决方案是通过将指定的动态过程直接转换为计算算法来构建的。系统状态由一个 $N \\times N$ 矩阵表示，其中每个单元格可以是空置的（状态 $0$），或被类型 $A$（状态 $1$）或类型 $B$（状态 $2$）的代理占据。模拟通过一系列离散阶段 $k=0, 1, \\dots, K$ 进行。\n\n每个阶段 $k$ 包括两个阶段：代理添加和代理移动。\n\n1.  **代理添加**：在每个阶段，网格上的代理数量都会增加。目标空置单元格数量 $V_k$ 由空置率序列 $\\{\\rho_k\\}$ 决定，公式为 $V_k = \\left\\lfloor \\rho_k N^2 + \\tfrac{1}{2} \\right\\rfloor$。在阶段 $k$ 需要添加的新代理数量为 $\\Delta_k = V_{k-1} - V_k$，其中对于初始空网格，$V_{-1} = N^2$。这 $\\Delta_k$ 个代理包括 $\\lfloor p_A \\Delta_k \\rfloor$ 个类型 $A$ 的代理和其余类型 $B$ 的代理。它们被确定性地放置到按行主序找到的前 $\\Delta_k$ 个空置单元格中，所有类型 $A$ 的代理都在类型 $B$ 的代理之前放置。\n\n2.  **代理移动**：代理添加之后，会发生一个由代理对同质性的偏好驱动的动态重新安置过程。此过程被建模为一系列扫描。在单次扫描中，所有网格单元格都按行主序被访问。\n    - 位于位置 $(i,j)$ 的代理根据其 Moore 邻域（周围的8个单元格）的构成来评估其满意度。\n    - 代理的局部同质性 $h_{ij}$ 是其已占据邻居中同类型邻居的比例。如果一个代理没有已占据的邻居，则按约定视为满意。\n    - 如果代理的局部同质性 $h_{ij}$ 达到或超过全局偏好阈值 $\\tau$，即 $h_{ij} \\ge \\tau$，则该代理被视为满意。\n    - 如果一个代理不满意，它会搜索一个空置单元格进行移动。对目标空置单元格的搜索按行主序遍历所有当前空置单元格的列表。代理会移动到它能够满意的*第一个*空置单元格。这种假设的满意度是基于目标单元格的邻域构成来评估的。\n    - 每次移动都会立即执行，更新网格状态。然后，扫描从行主序中的下一个单元格继续进行。\n    - 当一次完整的扫描没有导致任何代理移动（表明达到稳定构型），或者达到最大扫描次数 $M$ 时，给定阶段的移动阶段即告终止。\n\n最终阶段 $K$ 完成后，计算全局分隔指数 $S$。该指数是最终网格构型中所有被占据单元格的平均局部同质性：\n$$S = \\frac{1}{|\\mathcal{O}|} \\sum_{(i,j)\\in\\mathcal{O}} h_{ij}$$\n其中 $\\mathcal{O}$ 是所有被占据单元格的集合。在此计算中，对于没有已占据邻居的代理，其同质性 $h_{ij}$ 定义为 $1$。最终的 $S$ 值报告为四舍五入到四位小数的数值。由于所有行动（包括平局处理）都有严格的排序规则，整个过程是确定性的。", "answer": "```python\nimport numpy as np\n\ndef custom_round(x):\n    \"\"\"\n    Rounds a number to the nearest integer according to the problem specification,\n    which is equivalent to floor(x + 0.5) for non-negative x.\n    \"\"\"\n    return int(x + 0.5)\n\ndef get_neighbor_stats(grid, agent_type, r, c):\n    \"\"\"\n    Calculates neighbor statistics for an agent of a given type at position (r, c).\n    \n    Args:\n        grid (np.array): The current state of the grid.\n        agent_type (int): The type of the agent (1 or 2).\n        r (int): The row coordinate.\n        c (int): The column coordinate.\n        \n    Returns:\n        tuple[int, int]: A tuple containing (same_type_neighbors, total_occupied_neighbors).\n    \"\"\"\n    N = grid.shape[0]\n    same_type_neighbors = 0\n    total_occupied_neighbors = 0\n    \n    # Iterate over the Moore neighborhood of radius 1\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            \n            nr, nc = r + dr, c + dc\n            \n            if 0 <= nr < N and 0 <= nc < N:\n                neighbor_state = grid[nr, nc]\n                if neighbor_state != 0:  # If the neighbor cell is occupied\n                    total_occupied_neighbors += 1\n                    if neighbor_state == agent_type:\n                        same_type_neighbors += 1\n                        \n    return same_type_neighbors, total_occupied_neighbors\n\ndef run_simulation(N, rhos, tau, p_A, M):\n    \"\"\"\n    Executes the full Schelling model simulation for one test case.\n    \"\"\"\n    grid = np.zeros((N, N), dtype=int)\n    V_prev = N * N\n\n    for rho_k in rhos:\n        # ===== 1. AGENT ADDITION PHASE =====\n        V_k = custom_round(rho_k * N * N)\n        delta_k = V_prev - V_k\n        V_prev = V_k\n\n        if delta_k > 0:\n            num_A = int(p_A * delta_k)\n            num_B = delta_k - num_A\n\n            # Find vacant cells in row-major order\n            vacant_cells = np.argwhere(grid == 0)\n            \n            # Place type A agents\n            for i in range(num_A):\n                r, c = vacant_cells[i]\n                grid[r, c] = 1\n            \n            # Place type B agents\n            for i in range(num_A, delta_k):\n                r, c = vacant_cells[i]\n                grid[r, c] = 2\n\n        # ===== 2. MOBILITY PHASE =====\n        for _ in range(M):\n            moved_in_sweep = False\n            \n            # Visit all cells in row-major order\n            for r_orig in range(N):\n                for c_orig in range(N):\n                    agent_type = grid[r_orig, c_orig]\n                    if agent_type == 0:\n                        continue\n\n                    # Check if the agent at (r_orig, c_orig) is satisfied\n                    same, total = get_neighbor_stats(grid, agent_type, r_orig, c_orig)\n                    \n                    # An agent is satisfied if it has no neighbors or if homophily >= tau.\n                    # same >= tau * total is used to avoid float division.\n                    is_satisfied = (total == 0) or (same >= tau * total)\n\n                    if not is_satisfied:\n                        # Agent is unsatisfied, so search for a new location.\n                        # Get a current list of vacant cells, sorted row-major.\n                        vacant_cells = np.argwhere(grid == 0)\n                        \n                        for r_new, c_new in vacant_cells:\n                            # Check if moving to (r_new, c_new) would be satisfactory.\n                            same_h, total_h = get_neighbor_stats(grid, agent_type, r_new, c_new)\n                            \n                            would_be_satisfied = (total_h == 0) or (same_h >= tau * total_h)\n                                \n                            if would_be_satisfied:\n                                # First suitable vacancy found, so move the agent.\n                                grid[r_new, c_new] = agent_type\n                                grid[r_orig, c_orig] = 0\n                                moved_in_sweep = True\n                                break  # Agent moved, stop searching for vacancies.\n\n            if not moved_in_sweep:\n                break  # Equilibrium for this stage is reached.\n\n    # ===== 3. FINAL SEGREGATION INDEX CALCULATION =====\n    occupied_cells = np.argwhere(grid > 0)\n    num_occupied = len(occupied_cells)\n\n    if num_occupied == 0:\n        return 0.0\n\n    total_homophily = 0.0\n    for r, c in occupied_cells:\n        agent_type = grid[r, c]\n        same, total = get_neighbor_stats(grid, agent_type, r, c)\n        \n        # Local homophily is 1 if agent has no neighbors.\n        homophily = 1.0 if total == 0 else same / total\n        total_homophily += homophily\n        \n    S = total_homophily / num_occupied\n    \n    return S\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # (N, {rho_k}, tau, p_A, M)\n        (10, [0.6, 0.4, 0.2], 0.3, 0.5, 200),\n        (10, [0.6, 0.4, 0.2], 0.6, 0.5, 200),\n        (8, [0.7, 0.5, 0.3], 0.0, 0.7, 200),\n        (12, [0.8, 0.5, 0.2], 1.0, 0.5, 300),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, rhos, tau, p_A, M = case\n        result = run_simulation(N, rhos, tau, p_A, M)\n        # Format the result to four decimal places as required.\n        results.append(f\"{result:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}