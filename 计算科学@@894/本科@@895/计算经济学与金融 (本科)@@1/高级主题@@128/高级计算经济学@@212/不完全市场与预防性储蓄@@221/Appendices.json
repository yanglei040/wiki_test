{"hands_on_practices": [{"introduction": "掌握预防性储蓄理论不仅需要理解其背后的“原因”，还需要了解如何“动手”求解这些模型。第一个练习将向您介绍内生网格法 (Endogenous Gridpoints Method, EGM)，这是一种求解消费-储蓄问题的强大而高效的技术。通过实施 EGM 来解决一个有限期生命周期模型 [@problem_id:2401169]，您将通过比较个体在风险环境和确定性环境下的选择，来直接量化预防性储蓄的大小。这个练习为您提供了一个具体衡量我们所研究行为的方法。", "id": "2401169", "problem": "考虑一个在不完全市场下、带有约束性借贷约束的有限期生命周期消费储蓄问题。时间由 $t \\in \\{1,\\dots,T\\}$ 索引，代理人面临个体特定的劳动收入风险，该风险遵循一个在有限收入状态集上的时间齐次马尔可夫链。状态变量是带入第 $t$ 期的资产持有量 $a_t$，控制变量是消费 $c_t$ 和下一期的资产 $a_{t+1}$。市场是不完全的，唯一的资产是总回报率为 $1+r$ 的无风险债券。存在一个硬性借贷约束 $a_{t+1} \\geq 0$，当最优选择会违反该约束时，该约束将生效。\n\n偏好是时间可分的，具有常相对风险厌恶（CRRA）特性，时期效用函数为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，其中 $\\sigma > 0, \\sigma \\neq 1$。代理人最大化期望折现效用 $\\mathbb{E}\\left[\\sum_{t=1}^{T} \\beta^{t-1} u(c_t)\\right]$，其中折现因子为 $\\beta \\in (0,1)$。每个时期的预算约束为 $c_t + a_{t+1} = (1+r)a_t + y_{s_t}$，其中 $y_{s_t}$ 是收入状态为 $s_t$ 时的劳动收入，而 $s_t$ 根据一个在有限状态空间上的已知转移矩阵 $P$ 演变。\n\n基本定义：\n- 时期 $t$ 的 Bellman 方程为 $V_t(a_t,s_t) = \\max_{c_t,a_{t+1} \\geq 0} \\left\\{ u(c_t) + \\beta \\mathbb{E}\\left[V_{t+1}(a_{t+1}, s_{t+1}) \\mid s_t \\right] \\right\\}$，约束条件为 $c_t + a_{t+1} = (1+r)a_t + y_{s_t}$。\n- 内部解的 Euler 条件为 $u'(c_t) = \\beta (1+r) \\mathbb{E}\\left[ u'(c_{t+1}) \\mid s_t \\right]$，借贷约束意味着 $a_{t+1} \\geq 0$ 的互补松弛条件。\n- 在最终期 $T$，无遗产条件意味着 $a_{T+1} = 0$，因此 $c_T = (1+r)a_T + y_{s_T}$，$V_T$ 可以直接计算。\n\n任务：实施内生网格法（EGM）来解决这个有限期问题，求解每个年龄 $t$ 和收入状态 $s_t$ 下的最优消费函数 $c_t(m_t, s_t)$，其中手头现金为 $m_t \\equiv (1+r) a_t + y_{s_t}$。您的实现必须：\n- 利用 Euler 条件和借贷约束为每个 $(t,s_t)$ 构建内生网格，而无需进行求根。\n- 当 Euler 条件所暗示的最优 $a_{t+1}$ 将为负时，通过施加 $c_t = m_t$ 来精确处理借贷约束 $a_{t+1} \\geq 0$。\n- 在计算期望值时，根据需要使用线性插值来评估 $c_{t+1}(m_{t+1}, s_{t+1})$。\n\n预防性储蓄基准：对于以下每个参数集，计算年龄 $t=1$ 时的“预防性储蓄”，其值为风险下的最优下一期资产与确定性等价的无风险基准下的最优下一期资产之差。具体而言：\n- 使用给定的 $y$ 和 $P$ 定义风险模型。\n- 通过将随机收入替换为确定性的恒定收入 $\\bar{y}$ 来定义确定性等价的无风险基准，该恒定收入等于 $P$ 的平稳分布下 $y$ 的无条件均值。即，找到满足 $\\pi P = \\pi$、$\\sum_i \\pi_i = 1$ 的平稳分布 $\\pi$，并设置 $\\bar{y} = \\sum_i \\pi_i y_i$。使用等于 $\\bar{y}$ 的单一收入状态以及相同的 $\\beta$、$\\sigma$、$r$、$T$ 和借贷约束来解决相同的生命周期问题。\n- 对于给定的初始资产 $a_1 = a_0$ 和初始收入状态 $s_1$，计算 $m_1 = (1+r)a_0 + y_{s_1}$ 并评估最优的第一期下一期资产 $a_2^{\\text{risk}} = m_1 - c_1^{\\text{risk}}(m_1,s_1)$ 和 $a_2^{\\text{det}} = \\bar{m}_1 - c_1^{\\text{det}}(\\bar{m}_1)$，其中 $\\bar{m}_1 = (1+r)a_0 + \\bar{y}$。将预防性储蓄报告为 $a_2^{\\text{risk}} - a_2^{\\text{det}}$。\n\n数值实现要求：\n- 对 $a_{t+1}$ 使用在 $[0, \\bar{a}]$ 上的一个包含 $N_a = 200$ 个点的均匀间隔网格，其中 $\\bar{a} = 50$。\n- 在期望计算中评估消费函数以及在任意 $m_t$ 处评估 $c_t(m_t, s_t)$ 时，使用线性插值。\n- 使用 $T = 10$。\n- 将每个报告的预防性储蓄四舍五入到6位小数。\n\n测试套件：\n为以下3个参数集计算预防性储蓄。在所有情况下，为每个参数集报告单个浮点数值 $a_2^{\\text{risk}} - a_2^{\\text{det}}$。\n\n- 案例1（理想路径）：\n  - $T = 10$, $\\beta = 0.96$, $\\sigma = 2.0$, $r = 0.02$,\n  - $y = [0.5, 1.5]$, $P = \\begin{bmatrix}0.9 & 0.1 \\\\ 0.1 & 0.9\\end{bmatrix}$,\n  - $a_0 = 0.0$, $s_1 = 2$ （高收入状态）。\n\n- 案例2（无风险边界）：\n  - $T = 10$, $\\beta = 0.96$, $\\sigma = 2.0$, $r = 0.02$,\n  - $y = [1.0, 1.0]$, $P = \\begin{bmatrix}0.9 & 0.1 \\\\ 0.1 & 0.9\\end{bmatrix}$,\n  - $a_0 = 0.0$, $s_1 = 2$。\n\n- 案例3（高风险，高审慎）：\n  - $T = 10$, $\\beta = 0.98$, $\\sigma = 3.0$, $r = 0.01$,\n  - $y = [0.1, 1.9]$, $P = \\begin{bmatrix}0.95 & 0.05 \\\\ 0.05 & 0.95\\end{bmatrix}$,\n  - $a_0 = 0.0$, $s_1 = 2$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含3个案例的结果，格式为逗号分隔的列表并用方括号括起来，例如 $[x_1,x_2,x_3]$，其中每个 $x_i$ 是一个对应于上述顺序案例 $i$ 的、四舍五入到6位小数的浮点数。", "solution": "该问题要求使用内生网格法（EGM）解决收入不确定性下的有限期生命周期消费储蓄模型。我们的任务是为三种不同的参数设置计算生命周期开始时的预防性储蓄水平。\n\n代理人的问题是最大化期望终生效用，其表达式为：\n$$\n\\mathbb{E}\\left[\\sum_{t=1}^{T} \\beta^{t-1} \\frac{c_t^{1-\\sigma}}{1-\\sigma}\\right]\n$$\n并受一系列预算约束：\n$$\nc_t + a_{t+1} = (1+r)a_t + y_{s_t}\n$$\n以及一个借贷约束 $a_{t+1} \\geq 0$ 的限制。在这里，$c_t$ 是时期 $t$ 的消费，$a_t$ 是时期 $t$ 开始时的资产水平，$y_{s_t}$ 是依赖于随机状态 $s_t$ 的劳动收入，$r$ 是无风险利率，$\\beta$ 是折现因子，$\\sigma$ 是相对风险厌恶系数。收入状态 $s_t$ 遵循一个具有转移矩阵 $P$ 的时间齐次马尔可夫链。\n\n该问题通过从最终期 $T$ 开始的逆向归纳法求解。\n\n**时期 T（最终期）：**\n由于没有时期 $T+1$，代理人没有储蓄的动机。无遗产动机意味着 $a_{T+1} = 0$。因此，代理人会消费掉所有可用资源。时期 $T$ 的手头现金为 $m_T = (1+r)a_T + y_{s_T}$。最优消费策略是：\n$$\nc_T(m_T, s_T) = m_T\n$$\n这个策略对所有收入状态 $s_T$ 都是相同的。消费的边际效用为 $u'(c_T) = c_T^{-\\sigma} = m_T^{-\\sigma}$。\n\n**时期 t < T（通过 EGM 的递归解法）：**\n对于任何时期 $t < T$，我们假设已经找到了时期 $t+1$ 的策略 $c_{t+1}(m_{t+1}, s_{t+1})$，然后求解最优消费策略 $c_t(m_t, s_t)$。EGM 方法的工作原理如下：\n\n1.  **下一期资产的外生网格：** 我们为代理人选择的下一期资产 $a_{t+1}$ 定义一个离散点网格。设此网格为 $A' = \\{a'_0, a'_1, \\dots, a'_{N_a-1}\\}$，其中 $a'_0=0$ 且 $a'_{N_a-1}=\\bar{a}$。\n\n2.  **期望计算：** 对于网格中的每个点 $a' \\in A'$ 和每个当前收入状态 $s_t$，我们使用跨期 Euler 方程，其内部解为 $u'(c_t) = \\beta (1+r) \\mathbb{E}[u'(c_{t+1}) | s_t]$。我们首先计算期望项。对于给定的 $a_{t+1} = a'$ 选择，下一期的手头现金将是 $m_{t+1} = (1+r)a' + y_{s_{t+1}}$。期望边际效用为：\n    $$\n    \\mathbb{E}[u'(c_{t+1}) | s_t] = \\sum_{s_{t+1}} P(s_t, s_{t+1}) u'(c_{t+1}((1+r)a' + y_{s_{t+1}}, s_{t+1}))\n    $$\n    其中 $P(s_t, s_{t+1})$ 是从状态 $s_t$ 到 $s_{t+1}$ 的转移概率。函数 $c_{t+1}(\\cdot, s_{t+1})$ 是从逆向归纳的前一步中得知的，并使用线性插值进行评估。\n\n3.  **内生消费：** 在为每个 $a' \\in A'$ 计算出期望项后，我们可以通过对边际效用函数 $u'(c) = c^{-\\sigma}$ 求逆来找到相应的当期消费 $c_t$：\n    $$\n    c_t = \\left( \\beta (1+r) \\mathbb{E}[u'(c_{t+1}) | s_t] \\right)^{-1/\\sigma}\n    $$\n    这一步为我们提供了一组内生消费值，每个 $a' \\in A'$ 对应一个。\n\n4.  **内生手头现金网格：** 使用预算约束 $m_t = c_t + a_{t+1}$，我们可以找到与每对 $(c_t, a')$ 相对应的手头现金水平 $m_t$。这将创建一个手头现金点的内生网格：\n    $$\n    m_t = c_t + a'\n    $$\n    现在我们有了满足 Euler 方程的 $(m_t, c_t)$ 对。\n\n5.  **处理借贷约束：** 上述过程描述了未受借贷约束的代理人的最优策略。如果代理人的最优无约束选择是 $a_{t+1} < 0$，则借贷约束 $a_{t+1} \\geq 0$ 将生效。这样的代理人将转而选择 $a_{t+1}=0$ 并消费掉所有手头现金，即 $c_t=m_t$。EGM 方法优雅地处理了这种情况。我们外生网格的第一个点是 $a'_0 = 0$。其对应的内生点是 $(m_t(a'_0), c_t(a'_0))$。根据预算约束，$m_t(a'_0) = c_t(a'_0) + 0 = c_t(a'_0)$。这个点位于 $c_t=m_t$ 这条线上。对于任何手头现金 $m < m_t(a'_0)$ 的代理人，他们受到借贷约束，其策略为 $c_t=m_t$。\n    为了构建单一的策略函数，我们将约束区域和非约束区域结合起来。我们使用计算出的内生 $(m_t, c_t)$ 对，并在其前面加上点 $(0,0)$，来构成一个用于插值的网格。由于点 $(m_t(a'_0), c_t(a'_0))$ 等价于 $(c_t(a'_0), c_t(a'_0))$，在 $(0,0)$ 和这个点之间的线性插值可以正确地恢复出约束区域的 $c_t=m_t$ 策略。然后，使用完整的有序对 `(m, c)` 集合为消费函数 $c_t(m_t, s_t)$ 创建一个线性插值函数。\n\n对于每个收入状态 $s_t$，这个过程从 $t=T-1$ 向后重复至 $t=1$。\n\n**预防性储蓄计算：**\n预防性储蓄是由于未来收入不确定性而进行的额外储蓄。它被计算为风险模型和基准确定性模型下最优储蓄的差额。\n\n1.  **风险模型解法：** 我们使用给定的随机收入过程（$y$, $P$）按上文所述求解模型。这将得出策略函数 $c_1^{\\text{risk}}(m_1, s_1)$。对于给定的初始资产 $a_0$ 和初始状态 $s_1$，我们找到手头现金 $m_1 = (1+r)a_0 + y_{s_1}$，然后是最优消费 $c_1^{\\text{risk}}(m_1, s_1)$，最后是最优下一期资产 $a_2^{\\text{risk}} = m_1 - c_1^{\\text{risk}}(m_1, s_1)$。\n\n2.  **确定性模型解法：**\n    a. 我们首先计算马尔可夫链的平稳分布 $\\pi$，它是满足 $\\pi P = \\pi$ 和 $\\sum_i \\pi_i = 1$ 的唯一向量。这可以通过计算 $P^T$ 对应于特征值 $1$ 的特征向量来找到。\n    b. 然后我们计算无条件平均收入 $\\bar{y} = \\sum_i \\pi_i y_i$。\n    c. 我们用一个等于 $\\bar{y}$ 的确定性、恒定收入流重新求解模型。这等同于一个具有单一收入状态和转移概率为 $1$ 的模型。这将得出策略函数 $c_1^{\\text{det}}(m_1)$。\n    d. 对于相同的初始资产 $a_0$，我们找到手头现金 $\\bar{m}_1 = (1+r)a_0 + \\bar{y}$，然后是最优消费 $c_1^{\\text{det}}(\\bar{m}_1)$，最后是资产 $a_2^{\\text{det}} = \\bar{m}_1 - c_1^{\\text{det}}(\\bar{m}_1)$。\n\n3.  **预防性储蓄：** 最终的度量是差值：$a_2^{\\text{risk}} - a_2^{\\text{det}}$。为三个测试案例中的每一个计算该值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef compute_stationary_dist(P):\n    \"\"\"\n    Computes the stationary distribution of a Markov chain given its transition matrix P.\n    \"\"\"\n    n_states = P.shape[0]\n    # We are looking for a vector pi such that pi * P = pi and sum(pi) = 1.\n    # This is equivalent to finding the eigenvector of P.T for the eigenvalue 1.\n    evals, evecs = np.linalg.eig(P.T)\n    # Find the eigenvector corresponding to the eigenvalue closest to 1\n    idx = np.argmin(np.abs(evals - 1.0))\n    pi = evecs[:, idx].real\n    # Normalize to ensure it's a probability distribution\n    pi /= pi.sum()\n    return pi\n\ndef solve_lifecycle_egm(T, beta, sigma, r, y, P, a_max, n_a):\n    \"\"\"\n    Solves the finite-horizon lifecycle model using the Endogenous Gridpoints Method.\n    \"\"\"\n    n_income_states = len(y)\n    a_grid = np.linspace(0, a_max, n_a)\n    \n    # This will store the consumption policy functions for each period and state\n    policy_functions = [[None] * n_income_states for _ in range(T)]\n\n    # Period T: Consume all cash-on-hand\n    for s_idx in range(n_income_states):\n        # c(m) = m. We create an interpolant for this.\n        # Grid for m can be anything, but should cover expected range.\n        m_T_grid = np.linspace(0, a_max * (1 + r) + np.max(y), 100)\n        c_T_grid = m_T_grid\n        policy_functions[T-1][s_idx] = interp1d(\n            m_T_grid, c_T_grid,\n            kind='linear', bounds_error=False, fill_value=(0.0, m_T_grid[-1])\n        )\n\n    # Backward induction from T-1 to 1\n    for t in range(T - 2, -1, -1):\n        for s_idx in range(n_income_states):\n            # 1. Calculate expected marginal utility for each point in a_grid\n            \n            # E_u_prime will store the expectation\n            E_u_prime = np.zeros(n_a)\n            \n            # Loop over possible next-period states\n            for s_next_idx in range(n_income_states):\n                # Cash on hand tomorrow if we save a_grid today\n                m_next = (1 + r) * a_grid + y[s_next_idx]\n                \n                # Get tomorrow's consumption function\n                c_func_next = policy_functions[t+1][s_next_idx]\n                \n                # Consumption choice tomorrow\n                c_next = c_func_next(m_next)\n\n                # Avoid division by zero if consumption is zero\n                c_next[c_next <= 0] = 1e-9\n\n                # Marginal utility tomorrow\n                mu_prime_next = c_next**(-sigma)\n                \n                # Add to expectation, weighted by transition probability\n                prob = P[s_idx, s_next_idx]\n                E_u_prime += prob * mu_prime_next\n\n            # 2. Invert Euler equation to find endogenous consumption grid\n            c_endog = (beta * (1 + r) * E_u_prime)**(-1/sigma)\n\n            # 3. Find endogenous cash-on-hand grid\n            m_endog = a_grid + c_endog\n            \n            # 4. Handle borrowing constraint and create interpolant\n            # The first point corresponds to a' = 0.\n            # For m < m_endog[0], agent is constrained, so c = m.\n            # We prepend (0,0) to the grid. Interpolation between (0,0) and \n            # (m_endog[0], c_endog[0]) will be c=m because m_endog[0] = c_endog[0] + a_grid[0] = c_endog[0].\n            \n            # Sort grids by m_endog to ensure monotonicity for interpolation\n            sort_indices = np.argsort(m_endog)\n            m_endog_sorted = m_endog[sort_indices]\n            c_endog_sorted = c_endog[sort_indices]\n\n            m_policy_grid = np.concatenate(([0.0], m_endog_sorted))\n            c_policy_grid = np.concatenate(([0.0], c_endog_sorted))\n\n            policy_functions[t][s_idx] = interp1d(\n                m_policy_grid, c_policy_grid,\n                kind='linear', bounds_error=False,\n                fill_value=(0.0, m_policy_grid[-1]) # Extrapolate c=m for large m\n            )\n\n    return policy_functions\n\n\ndef solve():\n    test_cases = [\n        {\n            \"T\": 10, \"beta\": 0.96, \"sigma\": 2.0, \"r\": 0.02,\n            \"y\": np.array([0.5, 1.5]), \"P\": np.array([[0.9, 0.1], [0.1, 0.9]]),\n            \"a0\": 0.0, \"s1_idx\": 1\n        },\n        {\n            \"T\": 10, \"beta\": 0.96, \"sigma\": 2.0, \"r\": 0.02,\n            \"y\": np.array([1.0, 1.0]), \"P\": np.array([[0.9, 0.1], [0.1, 0.9]]),\n            \"a0\": 0.0, \"s1_idx\": 1\n        },\n        {\n            \"T\": 10, \"beta\": 0.98, \"sigma\": 3.0, \"r\": 0.01,\n            \"y\": np.array([0.1, 1.9]), \"P\": np.array([[0.95, 0.05], [0.05, 0.95]]),\n            \"a0\": 0.0, \"s1_idx\": 1\n        }\n    ]\n\n    # Global numerical parameters\n    n_a = 200\n    a_max = 50.0\n\n    results = []\n\n    for case in test_cases:\n        # 1. Solve the risky model\n        policy_risk = solve_lifecycle_egm(\n            case[\"T\"], case[\"beta\"], case[\"sigma\"], case[\"r\"],\n            case[\"y\"], case[\"P\"], a_max, n_a\n        )\n        # Calculate optimal saving under risk\n        m1_risk = (1 + case[\"r\"]) * case[\"a0\"] + case[\"y\"][case[\"s1_idx\"]]\n        c1_risk = policy_risk[0][case[\"s1_idx\"]](m1_risk)\n        a2_risk = m1_risk - c1_risk\n\n        # 2. Solve the certainty-equivalent model\n        # Find stationary distribution and mean income\n        pi = compute_stationary_dist(case[\"P\"])\n        y_bar = np.dot(pi, case[\"y\"])\n        \n        # Define deterministic model parameters\n        y_det = np.array([y_bar])\n        P_det = np.array([[1.0]])\n        \n        policy_det = solve_lifecycle_egm(\n            case[\"T\"], case[\"beta\"], case[\"sigma\"], case[\"r\"],\n            y_det, P_det, a_max, n_a\n        )\n        # Calculate optimal saving under certainty\n        m1_det = (1 + case[\"r\"]) * case[\"a0\"] + y_bar\n        c1_det = policy_det[0][0](m1_det)\n        a2_det = m1_det - c1_det\n        \n        # 3. Compute precautionary saving\n        precautionary_saving = a2_risk - a2_det\n        results.append(round(precautionary_saving, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}