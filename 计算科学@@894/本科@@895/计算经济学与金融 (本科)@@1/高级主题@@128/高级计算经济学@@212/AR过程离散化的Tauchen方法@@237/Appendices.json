{"hands_on_practices": [{"introduction": "本节练习将指导您从头开始为标准的一阶自回归（$AR(1)$）过程实现经典的 Tauchen 方法。这是掌握该方法的基础。通过亲手构建状态网格和转移矩阵，并计算关键的统计矩（如均值、方差和自相关系数），您将深入理解离散化近似的内在机制。此练习 [@problem_id:2436547] 的核心目标是评估近似的准确性，这对于理解任何数值方法中精度与计算成本之间的权衡至关重要。", "id": "2436547", "problem": "考虑由随机差分方程 $z_{t+1} = \\rho z_t + \\varepsilon_{t+1}$ 定义的一阶自回归 (AR) 过程，其中 $\\varepsilon_{t}$ 是独立同分布的高斯随机变量，均值为 $0$，方差为 $\\sigma_{\\varepsilon}^2$。当 $|\\rho| &lt; 1$ 时，该过程是协方差平稳的，其无条件方差为 $\\sigma_z^2 = \\sigma_{\\varepsilon}^2 / (1 - \\rho^2)$，无条件均值为 $0$。目标是使用 Tauchen 方法将此连续状态过程近似为一个有限状态马尔可夫链，并研究当持续性参数为负值（特别是 $\\rho = -0.5$）时该方法的性能。\n\n实现一个程序，对于给定的参数 $(\\rho, \\sigma_{\\varepsilon}, N, m)$：\n- 在 $[-m \\sigma_z, m \\sigma_z]$ 上构建一个均匀间隔的网格 $\\{z_1, \\ldots, z_N\\}$，其中 $\\sigma_z = \\sigma_{\\varepsilon}/\\sqrt{1-\\rho^2}$。\n- 使用 Tauchen 方法构建转移概率矩阵 $P \\in \\mathbb{R}^{N \\times N}$：将每个网格点视为一个区间的中心，使用中点定义区间边界，并通过对给定 $z_t$ 时 $z_{t+1}$ 的高斯条件分布在这些区间上进行积分来计算转移概率。使用标准正态累积分布函数 (CDF)。\n- 计算马尔可夫链的平稳分布 $\\pi$，该分布是满足 $\\pi = \\pi P$ 和 $\\sum_{i=1}^N \\pi_i = 1$ 的不变分布。\n- 使用 $\\pi$ 和 $P$，计算：\n  1. 近似的无条件均值 $\\mu_{\\text{disc}} = \\sum_{i=1}^N \\pi_i z_i$。\n  2. 近似的无条件方差 $\\sigma_{\\text{disc}}^2 = \\sum_{i=1}^N \\pi_i (z_i - \\mu_{\\text{disc}})^2$。\n  3. 隐含的一阶自相关 $\\rho_{\\text{disc}}$，定义为当 $z_t$ 从马尔可夫链的平稳分布中抽取时，$z_t$ 和 $z_{t+1}$ 之间的相关性。通过协方差 $\\operatorname{Cov}(z_t, z_{t+1}) = \\sum_{i=1}^N \\pi_i z_i \\left(\\sum_{j=1}^N P_{ij} z_j\\right) - \\mu_{\\text{disc}}^2$ 除以 $\\sigma_{\\text{disc}}^2$ 来计算。\n\n对于每个测试用例，报告以下三个定量诊断指标：\n- 绝对均值误差 $|\\mu_{\\text{disc}} - 0|$。\n- 相对方差误差 $\\left|\\sigma_{\\text{disc}}^2 - \\sigma_z^2\\right| / \\sigma_z^2$。\n- 绝对自相关误差 $|\\rho_{\\text{disc}} - \\rho|$。\n\n您可以不加证明地假设以下基本前提：\n- 高斯分布的性质，包括标准正态累积分布函数 (CDF)。\n- 当 $|\\rho| &lt; 1$ 时，AR(1) 过程的平稳方差公式 $\\sigma_z^2 = \\sigma_{\\varepsilon}^2/(1-\\rho^2)$。\n- 遍历的有限状态马尔可夫链的不变分布的存在性与唯一性。\n\n测试套件：\n在以下参数集 $(\\rho, \\sigma_{\\varepsilon}, N, m)$ 上评估您的实现：\n- 用例 1（理想路径）：$(\\rho, \\sigma_{\\varepsilon}, N, m) = (-0.5, 0.2, 9, 3)$。\n- 用例 2（高负值持续性）：$(\\rho, \\sigma_{\\varepsilon}, N, m) = (-0.95, 0.2, 21, 4)$。\n- 用例 3（小新息方差）：$(\\rho, \\sigma_{\\varepsilon}, N, m) = (-0.5, 0.001, 7, 3)$。\n- 用例 4（粗糙网格）：$(\\rho, \\sigma_{\\varepsilon}, N, m) = (-0.5, 0.2, 3, 3)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例应产生一个包含三个浮点数的列表 $[e_{\\mu}, e_{\\sigma^2}, e_{\\rho}]$，其中 $e_{\\mu}$ 是绝对均值误差，$e_{\\sigma^2}$ 是相对方差误差，$e_{\\rho}$ 是绝对自相关误差。按测试套件的相同顺序将它们聚合到一个列表中。打印所有浮点数并保留六位小数。例如，输出应如下所示：\n[[e_mu_1,e_var_1,e_rho_1],[e_mu_2,e_var_2,e_rho_2],[e_mu_3,e_var_3,e_rho_3],[e_mu_4,e_var_4,e_rho_4]]", "solution": "问题陈述已经过严格验证。所有规范均被认为具有科学依据、在数学上是一致的并且是适定的。因此，该问题被认定为**有效的**。我们接下来将提供一个完整的解决方案。\n\n目标是使用 Tauchen 提出的方法对一个连续状态的一阶自回归过程 AR($1$) 进行离散化。该过程由随机差分方程定义：\n$$ z_{t+1} = \\rho z_t + \\varepsilon_{t+1} $$\n其中 $\\varepsilon_t$ 是服从均值为 $0$、方差为 $\\sigma_{\\varepsilon}^2$ 的正态分布的独立同分布随机变量，记作 $\\varepsilon_{t} \\sim \\mathcal{N}(0, \\sigma_{\\varepsilon}^2)$。为使过程协方差平稳，持续性参数必须满足 $|\\rho| &lt; 1$。在此条件下，该过程的无条件均值为 $E[z_t] = 0$，无条件方差为 $\\sigma_z^2 = \\sigma_{\\varepsilon}^2 / (1 - \\rho^2)$。\n\n解决方案分五步构建：网格生成、转移矩阵构建、平稳分布的确定、离散过程统计量的计算，以及最后的误差度量计算。\n\n**步骤 1：网格构建**\n变量 $z$ 的连续状态空间由一个有限的离散网格来近似。给定网格点数 $N$ 和一个缩放因子 $m$，我们构建一个均匀间隔的网格 $Z = \\{z_1, z_2, \\ldots, z_N\\}$。\n首先，计算连续过程的无条件标准差：\n$$ \\sigma_z = \\sqrt{\\frac{\\sigma_{\\varepsilon}^2}{1 - \\rho^2}} $$\n网格覆盖区间 $[-m \\sigma_z, m \\sigma_z]$。网格的端点是 $z_1 = -m \\sigma_z$ 和 $z_N = m \\sigma_z$。对于 $N &gt; 1$，相邻网格点之间的恒定步长为：\n$$ \\Delta z = \\frac{z_N - z_1}{N-1} = \\frac{2 m \\sigma_z}{N-1} $$\n如果 $N=1$，网格只包含一个点 $z_1=0$。\n\n**步骤 2：转移矩阵构建**\n离散化过程的动态由一个 $N \\times N$ 的马尔可夫转移矩阵 $P$ 描述。元素 $P_{ij}$ 表示在时间 $t$ 从状态 $z_i$ 转移到时间 $t+1$ 状态 $z_j$ 的概率。\n给定 $z_t = z_i$，$z_{t+1}$ 的条件分布是均值为 $\\rho z_i$、方差为 $\\sigma_{\\varepsilon}^2$ 的正态分布，即 $z_{t+1} | (z_t = z_i) \\sim \\mathcal{N}(\\rho z_i, \\sigma_{\\varepsilon}^2)$。\nTauchen 方法定义了一组 $N$ 个区间，其中每个网格点 $z_j$ 是一个区间的中心。这些区间的边界是相邻网格点的中点。概率 $P_{ij}$ 是条件正态密度在对应于区间 $j$ 的范围上的积分。\n区间定义如下：\n- 区间 1： $(-\\infty, z_1 + \\Delta z/2]$\n- 对于 $j \\in \\{2, \\ldots, N-1\\}$ 的区间 $j$： $(z_j - \\Delta z/2, z_j + \\Delta z/2]$\n- 区间 $N$： $(z_N - \\Delta z/2, \\infty)$\n\n设 $\\Phi(\\cdot)$ 为标准正态分布 $\\mathcal{N}(0,1)$ 的累积分布函数 (CDF)。通过将区间边界标准化并使用 CDF 来计算转移概率：\n$$\nP_{ij} = \\mathbb{P}(z_{t+1} \\in \\text{bin}_j | z_t = z_i) =\n\\begin{cases}\n\\Phi\\left(\\frac{(z_1 + \\Delta z/2) - \\rho z_i}{\\sigma_{\\varepsilon}}\\right) & \\text{for } j=1 \\\\\n\\Phi\\left(\\frac{(z_j + \\Delta z/2) - \\rho z_i}{\\sigma_{\\varepsilon}}\\right) - \\Phi\\left(\\frac{(z_j - \\Delta z/2) - \\rho z_i}{\\sigma_{\\varepsilon}}\\right) & \\text{for } 1 &lt; j &lt; N \\\\\n1 - \\Phi\\left(\\frac{(z_N - \\Delta z/2) - \\rho z_i}{\\sigma_{\\varepsilon}}\\right) & \\text{for } j=N\n\\end{cases}\n$$\n这种构造确保了对于任何初始状态 $z_i$，转移到所有可能的下一状态的概率之和为 1，即 $\\sum_{j=1}^N P_{ij} = 1$。\n\n**步骤 3：平稳分布**\n马尔可夫链的平稳分布是一个概率向量 $\\pi = (\\pi_1, \\pi_2, \\ldots, \\pi_N)$，它在转移矩阵作用下保持不变。它必须满足两个条件：\n$$ \\pi P = \\pi \\quad \\text{和} \\quad \\sum_{i=1}^N \\pi_i = 1 $$\n这意味着 $\\pi$ 是 $P$ 对应于特征值 $\\lambda = 1$ 的左特征向量。等价地，其转置 $\\pi^T$ 是转置矩阵 $P^T$ 对应于特征值 $\\lambda=1$ 的右特征向量：\n$$ P^T \\pi^T = \\pi^T $$\n对于一个由该方法产生的行为良好（遍历）的马尔可夫链，保证存在唯一的平稳分布。可以通过数值方法计算 $P^T$ 的特征系统，找到与最接近 $1$ 的特征值相关联的特征向量，并将其归一化以使其元素之和为 $1$。\n\n**步骤 4：离散化过程的近似矩**\n使用平稳分布 $\\pi$ 和网格 $Z$，我们计算近似过程的统计矩。\n- **无条件均值**：过程在其平稳状态下的均值是网格上的期望值，由平稳概率加权。\n  $$ \\mu_{\\text{disc}} = E[z] = \\sum_{i=1}^N \\pi_i z_i = \\pi \\cdot Z $$\n- **无条件方差**：\n  $$ \\sigma_{\\text{disc}}^2 = E[(z-\\mu_{\\text{disc}})^2] = \\sum_{i=1}^N \\pi_i (z_i - \\mu_{\\text{disc}})^2 = \\left(\\sum_{i=1}^N \\pi_i z_i^2\\right) - \\mu_{\\text{disc}}^2 $$\n- **一阶自相关**：自相关 $\\rho_{\\text{disc}}$ 是当过程处于平稳状态时 $z_t$ 和 $z_{t+1}$ 之间的相关性。它定义为 $\\rho_{\\text{disc}} = \\operatorname{Cov}(z_t, z_{t+1}) / \\sigma_{\\text{disc}}^2$。协方差由下式给出：\n  $$ \\operatorname{Cov}(z_t, z_{t+1}) = E[z_t z_{t+1}] - E[z_t]E[z_{t+1}] $$\n  根据平稳性，$E[z_t] = E[z_{t+1}] = \\mu_{\\text{disc}}$。项 $E[z_t z_{t+1}]$ 使用全期望定律计算：\n  $$ E[z_t z_{t+1}] = E_{z_t} [z_t E[z_{t+1}|z_t]] = \\sum_{i=1}^N \\pi_i z_i \\left( \\sum_{j=1}^N P_{ij} z_j \\right) $$\n  因此，协方差为：\n  $$ \\operatorname{Cov}(z_t, z_{t+1}) = \\left(\\sum_{i=1}^N \\pi_i z_i \\sum_{j=1}^N P_{ij} z_j\\right) - \\mu_{\\text{disc}}^2 $$\n  而自相关为：\n  $$ \\rho_{\\text{disc}} = \\frac{\\operatorname{Cov}(z_t, z_{t+1})}{\\sigma_{\\text{disc}}^2} $$\n\n**步骤 5：误差度量**\n离散化的准确性是通过将马尔可夫链近似的矩与连续 AR($1$) 过程的理论对应值进行比较来评估的。\n- **绝对均值误差**：$e_{\\mu} = |\\mu_{\\text{disc}} - 0| = |\\mu_{\\text{disc}}|$。\n- **相对方差误差**：$e_{\\sigma^2} = \\frac{|\\sigma_{\\text{disc}}^2 - \\sigma_z^2|}{\\sigma_z^2}$。\n- **绝对自相关误差**：$e_{\\rho} = |\\rho_{\\text{disc}} - \\rho|$。\n这三个度量指标量化了 Tauchen 方法在给定参数化下的性能。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path): (rho, sigma_e, N, m)\n        (-0.5, 0.2, 9, 3),\n        # Case 2 (high-magnitude negative persistence): (rho, sigma_e, N, m)\n        (-0.95, 0.2, 21, 4),\n        # Case 3 (small innovation variance): (rho, sigma_e, N, m)\n        (-0.5, 0.001, 7, 3),\n        # Case 4 (coarse grid): (rho, sigma_e, N, m)\n        (-0.5, 0.2, 3, 3),\n    ]\n\n    results = []\n    for params in test_cases:\n        rho, sigma_e, N, m = params\n        \n        # --- Step 1: Grid Construction ---\n        # Theoretical unconditional variance and standard deviation\n        sigma_z_sq = sigma_e**2 / (1 - rho**2)\n        sigma_z = np.sqrt(sigma_z_sq)\n        \n        # Create an evenly spaced grid\n        if N > 1:\n            z_grid = np.linspace(-m * sigma_z, m * sigma_z, N)\n            delta_z = z_grid[1] - z_grid[0]\n        else: # N=1 is a special case\n            z_grid = np.array([0.0])\n            delta_z = 0.0\n\n        # --- Step 2: Transition Matrix Construction ---\n        P = np.zeros((N, N))\n        for i in range(N):\n            mu_cond = rho * z_grid[i]\n            \n            # Handle bin probabilities\n            if N > 1:\n                # Bin 1: (-inf, z_1 + delta_z/2]\n                upper_bound_1 = z_grid[0] + delta_z / 2\n                P[i, 0] = norm.cdf((upper_bound_1 - mu_cond) / sigma_e)\n                \n                # Bin N: (z_{N-1} + delta_z/2, inf)\n                lower_bound_N = z_grid[N-1] - delta_z / 2\n                P[i, N-1] = 1 - norm.cdf((lower_bound_N - mu_cond) / sigma_e)\n                \n                # Bins 2 to N-1\n                for j in range(1, N - 1):\n                    lower_bound_j = z_grid[j] - delta_z / 2\n                    upper_bound_j = z_grid[j] + delta_z / 2\n                    P[i, j] = norm.cdf((upper_bound_j - mu_cond) / sigma_e) - \\\n                              norm.cdf((lower_bound_j - mu_cond) / sigma_e)\n            else: # N=1 case, P is just [[1.0]]\n                 P[i, 0] = 1.0\n\n        # --- Step 3: Stationary Distribution ---\n        # Find the eigenvector of P.T with eigenvalue 1\n        eigvals, eigvecs = np.linalg.eig(P.T)\n        idx = np.argmin(np.abs(eigvals - 1.0))\n        pi_vec = eigvecs[:, idx].real\n        # Normalize to get a probability distribution\n        pi = pi_vec / pi_vec.sum()\n\n        # --- Step 4: Calculation of Diagnostic Statistics ---\n        # Approximate unconditional mean\n        mu_disc = np.dot(pi, z_grid)\n        \n        # Approximate unconditional variance\n        var_disc = np.dot(pi, (z_grid - mu_disc)**2)\n\n        # Approximate first-order autocorrelation\n        # E[z' | z] = sum_j(P_ij * z_j) for each i\n        expected_z_next = P @ z_grid\n        # E[z * z'] = sum_i(pi_i * z_i * E[z' | z=z_i])\n        E_z_z_next = np.dot(pi * z_grid, expected_z_next)\n        \n        cov_disc = E_z_z_next - mu_disc**2\n        \n        if var_disc == 0:\n            rho_disc = 0.0 # Avoid division by zero if variance is zero\n        else:\n            rho_disc = cov_disc / var_disc\n\n        # --- Step 5: Error Metrics ---\n        # Absolute mean error\n        e_mu = np.abs(mu_disc)\n        \n        # Relative variance error\n        e_var = np.abs(var_disc - sigma_z_sq) / sigma_z_sq\n        \n        # Absolute autocorrelation error\n        e_rho = np.abs(rho_disc - rho)\n        \n        results.append([e_mu, e_var, e_rho])\n\n    # Final print statement in the exact required format.\n    result_strings = [f\"[{r[0]:.6f},{r[1]:.6f},{r[2]:.6f}]\" for r in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"}, {"introduction": "在掌握了基本的 Tauchen 方法之后，下一个练习将提出一个更深层次的挑战，以巩固您的理解。我们将“反向工程”该过程：给定一个由 Tauchen 方法生成的离散马尔可夫链（即状态网格和转移矩阵），您的任务是反向推断出其所近似的原始 $AR(1)$ 过程的参数 $\\rho$ 和 $\\sigma_{\\epsilon}$。这个练习 [@problem_id:2436597] 迫使我们思考转移矩阵究竟蕴含了哪些关于原始连续过程的信息，特别是它如何编码了条件均值和条件方差的关键属性。", "id": "2436597", "problem": "实现一个完整、可运行的程序，对零均值的一阶高斯自回归过程（AR(1)）执行“逆”Tauchen方法。假设连续时间的数据生成过程是一个带高斯新息的一阶自回归（AR）模型，定义为 $z_{t+1} = \\rho z_t + \\epsilon_t$，其中 $\\epsilon_t \\sim \\mathcal{N}(0,\\sigma_{\\epsilon}^2)$ 且 $|\\rho|<1$。Tauchen离散化方法基于高斯新息和线性条件期望的假设，在一个网格上构建一个有限状态马尔可夫链近似。在正向Tauchen方法中，通过在区间 $\\left[-m \\cdot \\sigma_z, m \\cdot \\sigma_z\\right]$ 上的等距点定义一个包含 $N$ 个节点的对称网格，其中 $\\sigma_z = \\sigma_{\\epsilon}/\\sqrt{1-\\rho^2}$ 是 $z_t$ 的平稳标准差，并且转移概率是通过在网格中点之间的区间边界处计算标准正态累积分布函数得到的。\n\n你的任务是实现逆向问题：给定一个由某个类似Tauchen的方案为未知的 $\\rho$ 和 $\\sigma_{\\epsilon}$ 生成的状态网格和转移矩阵，估计 $\\rho$ 和 $\\sigma_{\\epsilon}$。你的估计器必须仅基于带高斯新息的AR(1)的定义属性，特别是其条件期望是当前状态的线性函数，以及其条件方差在所有状态下是恒定的，以及马尔可夫链转移矩阵如何编码给定当前网格状态下，下一网格状态的条件分布。不要假设可以使用任何估计器的现成公式；相反，应通过将马尔可夫链所蕴含的条件矩与连续AR(1)过程的条件矩相关联，从第一性原理推导出一个相合估计量。\n\n为了使任务具体且可测试，你的程序必须同时实现：\n- 一个正向Tauchen生成器，对于给定的参数 $(\\rho,\\sigma_{\\epsilon},N,m)$，它会构建一个在 $\\left[-m \\cdot \\sigma_z, m \\cdot \\sigma_z\\right]$ 上的对称等距网格 $\\{z_j\\}_{j=1}^N$ 和一个转移矩阵 $P \\in \\mathbb{R}^{N \\times N}$。其中条目 $P_{ij}$ 等于当期状态为第 $i$ 个网格点时，下一期状态落入第 $j$ 个网格单元的概率。该概率通过对均值为 $\\rho z_i$、标准差为 $\\sigma_{\\epsilon}$ 的高斯分布在由相邻网格点中点定义的区间上积分计算得出，最低和最高的区间分别延伸至 $-\\infty$ 和 $+\\infty$。使用标准正态累积分布函数进行这些积分。\n- 一个逆向Tauchen估计器，它以 $(\\{z_j\\}_{j=1}^N, P)$ 为输入，并通过利用马尔可夫链的条件矩与连续AR(1)过程的条件矩之间的关系，输出估计值 $(\\widehat{\\rho},\\widehat{\\sigma}_{\\epsilon})$。\n\n你的程序必须执行以下测试套件。对于每组参数，首先使用你的正向Tauchen实现生成 $(\\{z_j\\},P)$，然后应用你的逆向估计器来恢复 $(\\widehat{\\rho},\\widehat{\\sigma}_{\\epsilon})$。使用以下测试用例：\n- 测试用例 $1$：$(\\rho,\\sigma_{\\epsilon},N,m) = (0.9, 0.1, 7, 3.0)$。\n- 测试用例 $2$：$(\\rho,\\sigma_{\\epsilon},N,m) = (0.0, 0.2, 5, 3.0)$。\n- 测试用例 $3$：$(\\rho,\\sigma_{\\epsilon},N,m) = (0.99, 0.05, 11, 3.5)$。\n- 测试用例 $4$：$(\\rho,\\sigma_{\\epsilon},N,m) = (-0.5, 0.15, 9, 3.0)$。\n\n最终输出格式要求：\n- 你的程序应产生单行输出，其中包含一个扁平的浮点数列表，按顺序包含每个测试用例的估计值，格式为 $[\\widehat{\\rho}_1,\\widehat{\\sigma}_{\\epsilon,1},\\widehat{\\rho}_2,\\widehat{\\sigma}_{\\epsilon,2},\\widehat{\\rho}_3,\\widehat{\\sigma}_{\\epsilon,3},\\widehat{\\rho}_4,\\widehat{\\sigma}_{\\epsilon,4}]$。\n- 每个浮点数必须精确到小数点后 $6$ 位。\n- 不应打印任何额外文本。\n\n此处不涉及任何角度（如有）。不涉及任何物理单位。唯一的数值要求是所有打印的浮点数必须四舍五入到小数点后 $6$ 位。输出必须是单行：一个如上所述的、用方括号括起来的、以逗号分隔的列表。", "solution": "提交审议的问题陈述是有效的。它具有科学依据，定义明确，客观且内部一致。它描述了量化经济学领域中的一个具体计算任务：对连续时间随机过程进行离散化，并随后从离散化近似中估计出底层过程的参数。任务是首先为高斯AR(1)过程实现标准的Tauchen方法，然后推导并实现一个“逆”过程，从得到的离散状态网格和转移矩阵中估计过程参数 $(\\rho, \\sigma_{\\epsilon})$。这是数值方法和计量经济学中的一个标准问题。\n\n我现在将提供完整的推导和解决方案。该解决方案分为两部分：首先是正向Tauchen离散化的形式化构建，其次是从第一性原理推导逆向问题的估计器。\n\n设连续时间的数据生成过程为一个零均值的一阶自回归过程（AR(1)）：\n$$z_{t+1} = \\rho z_t + \\epsilon_t$$\n其中新息项 $\\epsilon_t$ 是一个独立同分布的随机变量，服从均值为零、方差为 $\\sigma_{\\epsilon}^2$ 的正态分布，记为 $\\epsilon_t \\sim \\mathcal{N}(0, \\sigma_{\\epsilon}^2)$。为保证平稳性，持续性参数 $\\rho$ 满足 $|\\rho| < 1$。过程 $z_t$ 的无条件方差是 $\\sigma_z^2 = \\text{Var}(z_t) = \\sigma_{\\epsilon}^2 / (1-\\rho^2)$。\n\n**第1部分：正向Tauchen方法**\n\n正向Tauchen方法构建一个有限状态马尔可夫链来近似连续AR(1)过程。这包括定义一个离散状态空间（一个网格）和一个转移概率矩阵。\n\n1.  **状态网格构建：**\n    状态空间是一个由 $N$个点组成的对称网格，记为 $\\{z_j\\}_{j=1}^N$。该网格的构建旨在覆盖该过程特定倍数的无条件标准差。\n    -   平稳标准差为 $\\sigma_z = \\sigma_{\\epsilon} / \\sqrt{1-\\rho^2}$。\n    -   网格覆盖区间 $[-m\\sigma_z, m\\sigma_z]$，其中 $m$ 是一个缩放参数。\n    -   $N$ 个网格点是等距的。最大值和最小值分别为 $z_N = m\\sigma_z$ 和 $z_1 = -m\\sigma_z$。\n    -   网格点可以使用线性空间函数生成：\n        $$z_j \\quad \\text{对于 } j=1, \\dots, N \\quad \\text{由 } \\text{linspace}(-m\\sigma_z, m\\sigma_z, N) \\text{ 给出}$$\n\n2.  **转移矩阵构建：**\n    转移矩阵 $P \\in \\mathbb{R}^{N \\times N}$ 提供了从状态 $z_i$ 转移到状态 $z_j$ 的概率 $P_{ij}$。这些概率是通过对 $z_{t+1}$ 的条件密度在与每个网格点 $z_j$ 相关联的区间（bins）上积分来计算的。\n    -   给定 $z_t = z_i$，下一状态 $z_{t+1}$ 服从正态分布：\n        $$z_{t+1} | z_t=z_i \\sim \\mathcal{N}(\\rho z_i, \\sigma_{\\epsilon}^2)$$\n    -   区间边界定义为相邻网格点之间的中点。设 $\\Delta z = z_{j+1} - z_j$ 为恒定步长。$z_j$ 和 $z_{j+1}$ 之间的中点是 $b_j = z_j + \\Delta z / 2$，对于 $j=1, \\dots, N-1$。\n    -   区间定义如下：\n        -   区间 1：$(-\\infty, b_1]$\n        -   区间 j：$(b_{j-1}, b_j]$，对于 $j=2, \\dots, N-1$\n        -   区间 N：$(b_{N-1}, +\\infty)$\n    -   转移概率 $P_{ij}$ 是在给定 $z_t = z_i$ 的条件下，$z_{t+1}$ 落入区间 $j$ 的概率。设 $\\Phi(\\cdot)$ 为标准正态分布 $\\mathcal{N}(0,1)$ 的累积分布函数（CDF）。\n        $$P(z_{t+1} \\le x | z_t=z_i) = P(\\rho z_i + \\epsilon_t \\le x) = P\\left(\\frac{\\epsilon_t}{\\sigma_\\epsilon} \\le \\frac{x-\\rho z_i}{\\sigma_\\epsilon}\\right) = \\Phi\\left(\\frac{x-\\rho z_i}{\\sigma_\\epsilon}\\right)$$\n    -   因此，转移矩阵的元素为：\n        -   对于 $j=1$：\n            $$P_{i1} = P(z_{t+1} \\in \\text{Bin } 1 | z_t=z_i) = \\Phi\\left(\\frac{b_1 - \\rho z_i}{\\sigma_\\epsilon}\\right)$$\n        -   对于 $j=2, \\dots, N-1$：\n            $$P_{ij} = P(z_{t+1} \\in \\text{Bin } j | z_t=z_i) = \\Phi\\left(\\frac{b_j - \\rho z_i}{\\sigma_\\epsilon}\\right) - \\Phi\\left(\\frac{b_{j-1} - \\rho z_i}{\\sigma_\\epsilon}\\right)$$\n        -   对于 $j=N$：\n            $$P_{iN} = P(z_{t+1} \\in \\text{Bin } N | z_t=z_i) = 1 - \\Phi\\left(\\frac{b_{N-1} - \\rho z_i}{\\sigma_\\epsilon}\\right)$$\n\n**第2部分：逆向Tauchen方法（估计器推导）**\n\n逆向问题是在给定网格 $\\mathbf{z} = [z_1, \\dots, z_N]^T$ 和转移矩阵 $P$ 的情况下，估计参数 $(\\rho, \\sigma_{\\epsilon})$。该推导依赖于将AR(1)过程的理论条件矩与马尔可夫链近似的经验对应值相等。\n\n1.  **AR(1)过程的基本矩条件：**\n    -   **条件期望：** 给定当前状态 $z_t$，下一状态的期望是线性的：\n        $$E[z_{t+1} | z_t] = E[\\rho z_t + \\epsilon_t | z_t] = \\rho z_t + E[\\epsilon_t] = \\rho z_t$$\n    -   **条件方差：** 给定当前状态 $z_t$，下一状态的方差是恒定的：\n        $$\\text{Var}(z_{t+1} | z_t) = \\text{Var}(\\rho z_t + \\epsilon_t | z_t) = \\text{Var}(\\epsilon_t) = \\sigma_{\\epsilon}^2$$\n\n2.  **估计 $\\rho$：**\n    马尔可夫链近似提供了下一网格状态的条件概率分布。对于每个当前状态 $z_i$，我们可以计算下一状态的期望值 $E[z'|z=z_i]$：\n    $$E[z'|z=z_i] = \\sum_{j=1}^N z_j P_{ij}$$\n    我们将其视为真实条件期望的近似：$E[z'|z=z_i] \\approx E[z_{t+1}|z_t=z_i] = \\rho z_i$。这给了我们一个包含 $N$ 个方程的方程组：\n    $$\\sum_{j=1}^N z_j P_{ij} \\approx \\rho z_i \\quad \\text{对于 } i=1, \\dots, N$$\n    这是一个关于未知数 $\\rho$ 的超定线性系统。解决这个问题的一个自然方法是普通最小二乘法（OLS）。设 $Y_i = \\sum_{j=1}^N z_j P_{ij}$ 和 $X_i = z_i$。我们拟合模型 $Y_i = \\rho X_i + \\text{误差}$。通过原点的回归的OLS估计器是：\n    $$\\widehat{\\rho} = \\frac{\\sum_{i=1}^N X_i Y_i}{\\sum_{i=1}^N X_i^2} = \\frac{\\sum_{i=1}^N z_i \\left(\\sum_{j=1}^N z_j P_{ij}\\right)}{\\sum_{i=1}^N z_i^2}$$\n    用向量表示法，设条件期望向量为 $\\mathbf{E_z} = P\\mathbf{z}$。那么估计器是：\n    $$\\widehat{\\rho} = \\frac{\\mathbf{z}^T \\mathbf{E_z}}{\\mathbf{z}^T \\mathbf{z}} = \\frac{\\mathbf{z}^T P \\mathbf{z}}{\\mathbf{z}^T \\mathbf{z}}$$\n\n3.  **估计 $\\sigma_{\\epsilon}$**\n    该过程的条件方差是恒定的，为 $\\sigma_{\\epsilon}^2$。对于马尔可夫链中的每个状态 $z_i$，我们可以计算下一状态的条件方差 $\\text{Var}(z'|z=z_i)$：\n    $$\\text{Var}(z'|z=z_i) = E[(z')^2|z=z_i] - (E[z'|z=z_i])^2$$\n    其中条件二阶矩为 $E[(z')^2|z=z_i] = \\sum_{j=1}^N z_j^2 P_{ij}$。\n    这 $N$ 个计算出的条件方差中的每一个，$V_i = \\text{Var}(z'|z=z_i)$，都是对真实恒定方差 $\\sigma_{\\epsilon}^2$ 的估计。通过对这些单个方差估计值求平均，可以形成 $\\sigma_{\\epsilon}^2$ 的一个相合估计量：\n    $$\\widehat{\\sigma}_{\\epsilon}^2 = \\frac{1}{N} \\sum_{i=1}^N \\text{Var}(z'|z=z_i) = \\frac{1}{N} \\sum_{i=1}^N \\left[ \\left(\\sum_{j=1}^N z_j^2 P_{ij}\\right) - \\left(\\sum_{j=1}^N z_j P_{ij}\\right)^2 \\right]$$\n    那么，新息标准差的估计器就是其平方根：\n    $$\\widehat{\\sigma}_{\\epsilon} = \\sqrt{\\widehat{\\sigma}_{\\epsilon}^2}$$\n    这样就完成了逆向Tauchen问题估计器的推导。实现将遵循这些推导出的公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite for the reverse Tauchen method.\n    It first generates a discrete Markov approximation (grid and transition matrix)\n    for a given AR(1) process using the forward Tauchen method. Then, it uses\n    the reverse Tauchen method to estimate the original AR(1) parameters.\n    \"\"\"\n\n    def forward_tauchen(rho, sigma_eps, N, m):\n        \"\"\"\n        Generates a state grid and transition matrix for an AR(1) process\n        using Tauchen's method.\n\n        Args:\n            rho (float): The persistence parameter of the AR(1) process.\n            sigma_eps (float): The standard deviation of the innovation term.\n            N (int): The number of grid points.\n            m (float): The number of standard deviations the grid should span.\n\n        Returns:\n            tuple: A tuple containing:\n                - z_grid (np.ndarray): The state grid.\n                - P (np.ndarray): The transition matrix.\n        \"\"\"\n        # Step 1: Create the state grid\n        # Unconditional standard deviation of the process z\n        if abs(rho) >= 1.0:\n            raise ValueError(\"rho must be less than 1 for stationarity.\")\n            \n        sigma_z = sigma_eps / np.sqrt(1 - rho**2)\n        z_max = m * sigma_z\n        z_grid = np.linspace(-z_max, z_max, N)\n\n        # Step 2: Create the transition matrix\n        P = np.zeros((N, N))\n        step = z_grid[1] - z_grid[0]\n        \n        # Define bin boundaries as midpoints between grid points\n        midpoints = z_grid[:-1] + step / 2\n\n        for i in range(N):\n            # Conditional mean of z_{t+1} given z_t = z_grid[i]\n            mu_z_prime = rho * z_grid[i]\n            \n            # Probability for the first bin (-inf, midpoint_1]\n            z_val = (midpoints[0] - mu_z_prime) / sigma_eps\n            P[i, 0] = norm.cdf(z_val)\n            \n            # Probabilities for the middle bins (midpoint_{j-1}, midpoint_j]\n            for j in range(1, N - 1):\n                z_val_upper = (midpoints[j] - mu_z_prime) / sigma_eps\n                z_val_lower = (midpoints[j-1] - mu_z_prime) / sigma_eps\n                P[i, j] = norm.cdf(z_val_upper) - norm.cdf(z_val_lower)\n            \n            # Probability for the last bin (midpoint_{N-1}, +inf)\n            z_val = (midpoints[-1] - mu_z_prime) / sigma_eps\n            P[i, N - 1] = 1 - norm.cdf(z_val)\n            \n        return z_grid, P\n\n    def reverse_tauchen(z_grid, P):\n        \"\"\"\n        Estimates the parameters of an AR(1) process from its Tauchen\n        discretization.\n\n        Args:\n            z_grid (np.ndarray): The state grid.\n            P (np.ndarray): The transition matrix.\n\n        Returns:\n            tuple: A tuple containing the estimated parameters:\n                - rho_hat (float): Estimated persistence parameter.\n                - sigma_eps_hat (float): Estimated standard deviation of innovation.\n        \"\"\"\n        # Step 1: Estimate rho using OLS on E[z'|z] = rho*z\n        # Conditional expectation of the next state: E[z'|z] = P @ z\n        cond_exp = P @ z_grid\n        \n        # OLS estimator for regression through the origin: (z' * E[z'|z]) / (z' * z)\n        rho_hat = (z_grid @ cond_exp) / (z_grid @ z_grid)\n        \n        # Step 2: Estimate sigma_epsilon\n        # Conditional second moment: E[(z')^2|z] = P @ (z^2)\n        z_grid_sq = z_grid**2\n        cond_sec_moment = P @ z_grid_sq\n        \n        # Conditional variance: Var(z'|z) = E[(z')^2|z] - (E[z'|z])^2\n        cond_var = cond_sec_moment - cond_exp**2\n        \n        # sigma_eps^2 is the constant conditional variance, so we average\n        # the estimates from each state.\n        sigma_eps_sq_hat = np.mean(cond_var)\n        sigma_eps_hat = np.sqrt(sigma_eps_sq_hat)\n        \n        return rho_hat, sigma_eps_hat\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.9, 0.1, 7, 3.0),\n        (0.0, 0.2, 5, 3.0),\n        (0.99, 0.05, 11, 3.5),\n        (-0.5, 0.15, 9, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, sigma_eps, N, m = case\n        \n        # Generate the discrete approximation\n        z, P = forward_tauchen(rho, sigma_eps, N, m)\n        \n        # Estimate the parameters from the approximation\n        rho_hat, sigma_eps_hat = reverse_tauchen(z, P)\n        \n        results.append(rho_hat)\n        results.append(sigma_eps_hat)\n\n    # Format the results for the final print statement\n    formatted_results = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "最后，我们将把 Tauchen 方法的应用从简单的一阶模型推广到更复杂、更现实的高阶过程。本练习要求您为一个二阶自回归（$AR(2)$）过程实现离散化。这需要将思维从标量状态转向向量状态，并将 Tauchen 方法的核心逻辑应用于多维空间。通过完成这个练习 [@problem_id:2436526]，您将学会如何处理高阶动态模型，并理解该方法在解决更复杂的经济和金融模型时的强大功能和普适性。", "id": "2436526", "problem": "给定一个均值为零的高斯二阶自回归 (AR) 过程，表示为二阶自回归 (AR)，由以下递归式定义：\n$$\ny_t = \\rho_1 y_{t-1} + \\rho_2 y_{t-2} + \\epsilon_t,\n$$\n其中 $\\epsilon_t \\sim \\mathcal{N}(0,\\sigma_\\epsilon^2)$ 在时间 $t$ 上独立同分布，且参数 $(\\rho_1,\\rho_2)$ 确保了平稳分布的存在。定义二维状态向量 $x_t = \\begin{bmatrix} y_t \\\\ y_{t-1} \\end{bmatrix}$ 并考虑其一阶马尔可夫表示：\n$$\nx_{t+1} = A x_t + B \\epsilon_{t+1}, \\quad A = \\begin{bmatrix} \\rho_1 & \\rho_2 \\\\ 1 & 0 \\end{bmatrix}, \\quad B = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}.\n$$\n通过在 $y$ 维度上使用一个包含 $N$ 个节点的均匀网格来构造一个有限状态时齐马尔可夫链，以近似 $x_t$ 的动态过程。该网格以 $0$ 为中心对称分布，范围为 $y_t$ 平稳标准差的 $\\pm m$ 倍。$y$ 维度上的网格由向量 $Y = (y_1,\\dots,y_N)$ 表示，其中 $y_1 < \\cdots < y_N$，$y_1=-m\\,\\sigma_y$ 且 $y_N=+m\\,\\sigma_y$，$\\sigma_y$ 是 $y_t$ 的平稳标准差，内部节点等距分布。完整的状态空间是笛卡尔积 $S = Y \\times Y$，状态表示为有序对 $(y_i,y_j)$。\n\n对于任意当前状态 $(y_i,y_j)$，$y_{t+1}$ 的条件分布是高斯分布，其条件均值为 $\\mu_{i,j}=\\rho_1 y_i + \\rho_2 y_j$，条件标准差为 $\\sigma_\\epsilon$。通过中点为 $Y$ 定义区间边界：\n$$\nb_k = \\frac{y_k+y_{k+1}}{2} \\quad \\text{for } k=1,\\dots,N-1,\\quad b_0=-\\infty,\\quad b_N=+\\infty.\n$$\n将从 $(y_i,y_j)$ 到 $(y_k,y_i)$ 的一步转移概率定义为，在均值为 $\\mu_{i,j}$、标准差为 $\\sigma_\\epsilon$ 的高斯定律下，$y_{t+1}$ 落入区间 $(b_{k-1},b_k]$ 的概率。从 $(y_i,y_j)$ 到任何 $\\ell \\ne i$ 的 $(y_k,y_\\ell)$ 的所有其他转移概率均为零。这定义了一个在 $S$ 上的时齐马尔可夫转移核，它完全由 $(\\rho_1,\\rho_2,\\sigma_\\epsilon,N,m)$ 决定。\n\n针对下方测试套件中的每一组参数，计算所构造的马尔可夫链的以下两个标量诊断指标：\n- 任意行和与 $1$ 的最大绝对偏差，定义为\n$$\n\\Delta_{\\text{row}} = \\max_{(i,j)} \\left| \\sum_{k=1}^N p_{(i,j)\\to (y_k,y_i)} - 1 \\right|.\n$$\n- 所有状态下条件期望近似值的最大绝对误差，定义为\n$$\n\\Delta_{\\mathbb{E}} = \\max_{(i,j)} \\left| \\sum_{k=1}^N y_k \\, p_{(i,j)\\to (y_k,y_i)} - \\mu_{i,j} \\right|.\n$$\n\n$x_t$ 的平稳协方差矩阵是离散时间李雅普诺夫方程的唯一对称正定解 $\\Sigma$：\n$$\n\\Sigma = A \\Sigma A^\\top + \\sigma_\\epsilon^2\\, B B^\\top,\n$$\n并且 $y_t$ 的平稳方差等于 $\\Sigma$ 的 $(1,1)$ 元素，即 $\\sigma_y=\\sqrt{\\Sigma_{11}}$。使用这个 $\\sigma_y$ 来定义网格 $Y$。\n\n测试套件（每个案例提供 $(\\rho_1,\\rho_2,\\sigma_\\epsilon,N,m)$）：\n- 案例 1：$(0.5,\\,0.2,\\,0.1,\\,7,\\,3)$。\n- 案例 2：$(1.8,\\,-0.81,\\,0.05,\\,9,\\,4)$。\n- 案例 3：$(0.0,\\,0.0,\\,1.0,\\,5,\\,3)$。\n- 案例 4：$(0.0,\\,0.5,\\,0.2,\\,3,\\,3)$。\n\n对于每个测试案例，您的程序必须计算出数对 $[\\Delta_{\\text{row}},\\Delta_{\\mathbb{E}}]$，作为一个包含两个实数的列表。最终输出必须是单行，包含按测试案例顺序排列的这些数对的列表，不含空格，例如\n$$\n[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]].\n$$\n不涉及物理单位。所有角度（如果出现）在此处不适用。所有输出都必须是标准十进制表示的数值实数。程序不得读取任何输入，并且必须以指定格式精确打印一行。", "solution": "该问题要求构建并分析一个有限状态马尔可夫链，用以近似一个连续状态的二阶自回归过程 AR(2)。这是计算经济学和应用宏观经济学中的一个标准问题，它通过使用向量自回归 (VAR) 表示，将 Tauchen (1986) 提出的用于 AR(1) 过程的方法推广到更高阶的情况。目标是计算两个特定的诊断指标，以衡量该近似在多种参数化下的质量。该问题是适定的、科学上合理的，并且在计算上是可行的。\n\nAR(2) 过程由下式给出：\n$$y_t = \\rho_1 y_{t-1} + \\rho_2 y_{t-2} + \\epsilon_t, \\quad \\epsilon_t \\sim \\mathcal{N}(0, \\sigma_\\epsilon^2)$$\n其状态空间表示为 $x_{t+1} = A x_t + B \\epsilon_{t+1}$，其中 $x_t = \\begin{bmatrix} y_t \\\\ y_{t-1} \\end{bmatrix}$，$A = \\begin{bmatrix} \\rho_1 & \\rho_2 \\\\ 1 & 0 \\end{bmatrix}$，以及 $B = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n\n对于给定的每一组参数 $(\\rho_1, \\rho_2, \\sigma_\\epsilon, N, m)$，求解过程分为四个逻辑步骤。\n\n第一步：计算平稳方差\n第一步是确定过程 $y_t$ 的平稳标准差，记作 $\\sigma_y$。这对于定义状态空间的网格是必需的。状态向量 $x_t$ 的平稳无条件协方差矩阵，记作 $\\Sigma = \\text{Cov}(x_t, x_t^\\top)$，是离散时间李雅普诺夫方程的对称正定解：\n$$\\Sigma = A \\Sigma A^\\top + Q$$\n其中 $Q = \\sigma_\\epsilon^2 B B^\\top = \\begin{bmatrix} \\sigma_\\epsilon^2 & 0 \\\\ 0 & 0 \\end{bmatrix}$。$y_t$ 的平稳方差是 $\\Sigma$ 的 $(1,1)$ 元素，即 $\\sigma_y^2 = \\Sigma_{11}$。我们数值求解这个矩阵方程以得到 $\\Sigma$，然后计算 $\\sigma_y = \\sqrt{\\Sigma_{11}}$。对于给定的参数集，$(\\rho_1, \\rho_2)$ 上的平稳性条件得到满足，确保了 $\\Sigma$ 的唯一解存在。\n\n第二步：构建状态空间网格\n过程的连续状态空间通过一个离散网格来近似。$y$ 维度的网格，记作 $Y$，包含 $N$ 个点，围绕 $0$ 对称，并覆盖区间 $[-m\\sigma_y, m\\sigma_y]$。网格点是等距的。向量 $Y = (y_1, \\dots, y_N)$ 的构建方式使得 $y_1 = -m\\sigma_y$ 且 $y_N = m\\sigma_y$。马尔可夫链的完整状态空间 $S$ 是笛卡尔积 $S = Y \\times Y$，包含 $N^2$ 个形如 $(y_i, y_j)$ 的状态，其中 $y_i, y_j \\in Y$。\n\n第三步：计算转移概率\n离散马尔可夫链的转移概率必须近似于原始 AR(2) 过程的转移动态。问题指定了一种特定的离散化方案。给定当前状态为 $(y_t, y_{t-1}) = (y_i, y_j)$，下一期的值 $y_{t+1}$ 服从正态分布，其条件均值为 $\\mu_{i,j} = \\rho_1 y_i + \\rho_2 y_j$，标准差为 $\\sigma_\\epsilon$。\n状态向量从 $x_t = (y_i, y_j)$ 演化到 $x_{t+1} = (y_{t+1}, y_i)$。新状态必须是 $(y_k, y_i)$ 的形式，其中某个 $y_k \\in Y$。此转移的概率 $p_{(y_i,y_j) \\to (y_k,y_i)}$ 是 $y_{t+1}$ 落入与网格点 $y_k$ 关联的区间的概率。这些区间（或箱）由相邻网格点的中点定义：\n$$b_k = \\frac{y_k + y_{k+1}}{2} \\quad \\text{for } k=1, \\dots, N-1$$\n外部边界设置为 $b_0 = -\\infty$ 和 $b_N = +\\infty$。第 $k$ 个区间是 $(b_{k-1}, b_k]$。\n因此，转移概率由条件正态分布的累积分布函数 (CDF) 给出：\n$$p_{(y_i,y_j) \\to (y_k,y_i)} = P(b_{k-1} < y_{t+1} \\le b_k \\mid y_t=y_i, y_{t-1}=y_j)$$\n$$= \\Phi\\left(\\frac{b_k - \\mu_{i,j}}{\\sigma_\\epsilon}\\right) - \\Phi\\left(\\frac{b_{k-1} - \\mu_{i,j}}{\\sigma_\\epsilon}\\right)$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布 $\\mathcal{N}(0,1)$ 的 CDF。对于一个给定的源状态 $(y_i, y_j)$，我们为 $k=1, \\dots, N$ 计算这 $N$ 个概率。转移到任何非 $(y_k, y_i)$ 形式的状态的概率为 0。\n\n第四步：计算诊断指标\n最后，我们计算两个指定的诊断指标，用以衡量离散化的准确性。我们遍历所有 $N^2$ 个初始状态 $(y_i, y_j) \\in S$。\n第一个诊断指标 $\\Delta_{\\text{row}}$ 衡量从单个状态出发的转移概率之和与 1 的最大偏差。\n$$\\Delta_{\\text{row}} = \\max_{(i,j)} \\left| \\left( \\sum_{k=1}^N p_{(y_i,y_j)\\to (y_k,y_i)} \\right) - 1 \\right|$$\n理论上，这个和是一个伸缩级数，其值等于 $\\Phi(\\infty) - \\Phi(-\\infty) = 1$。因此，$\\Delta_{\\text{row}}$ 仅因浮点精度限制而可能不为零。\n\n第二个诊断指标 $\\Delta_{\\mathbb{E}}$ 衡量近似条件期望的最大绝对误差。从状态 $(y_i, y_j)$ 出发的近似条件期望是 $\\sum_{k=1}^N y_k \\, p_{(y_i,y_j)\\to(y_k,y_i)}$。真实的条件期望是 $\\mu_{i,j} = \\rho_1 y_i + \\rho_2 y_j$。误差则为：\n$$\\Delta_{\\mathbb{E}} = \\max_{(i,j)} \\left| \\sum_{k=1}^N y_k \\, p_{(y_i,y_j)\\to (y_k,y_i)} - \\mu_{i,j} \\right|$$\n该指标量化了离散化过程在多大程度上保留了原始过程动态的一阶矩。较小的 $\\Delta_{\\mathbb{E}}$ 表示更好的近似。\n\n以下程序为每个测试案例实现了此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_discrete_lyapunov\nfrom scipy.stats import norm\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (rho1, rho2, sigma_eps, N, m)\n        (0.5, 0.2, 0.1, 7, 3),\n        (1.8, -0.81, 0.05, 9, 4),\n        (0.0, 0.0, 1.0, 5, 3),\n        (0.0, 0.5, 0.2, 3, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho1, rho2, sigma_eps, N, m = case\n\n        # Step 1: Compute stationary variance\n        A = np.array([[rho1, rho2], [1.0, 0.0]])\n        B = np.array([[1.0], [0.0]])\n        Q = (sigma_eps**2) * (B @ B.T)\n        \n        Sigma = solve_discrete_lyapunov(A, Q)\n        sigma_y = np.sqrt(Sigma[0, 0])\n\n        # Step 2: Construct the state space grid\n        y_grid = np.linspace(-m * sigma_y, m * sigma_y, N)\n\n        # Step 3: Define bin boundaries\n        step = y_grid[1] - y_grid[0]\n        bin_boundaries_mid = y_grid[:-1] + step / 2.0\n        # Full boundaries for CDF calculation\n        b = np.concatenate(([-np.inf], bin_boundaries_mid, [np.inf]))\n\n        # Step 4: Compute diagnostics\n        max_row_dev = 0.0\n        max_exp_err = 0.0\n\n        for i in range(N):\n            for j in range(N):\n                y_i = y_grid[i]\n                y_j = y_grid[j]\n                \n                # Conditional mean\n                mu_ij = rho1 * y_i + rho2 * y_j\n                \n                # Compute transition probabilities\n                cdf_at_bins = norm.cdf((b - mu_ij) / sigma_eps)\n                probs = np.diff(cdf_at_bins)\n\n                # Diagnostic 1: Row sum deviation\n                row_sum = np.sum(probs)\n                row_dev = abs(row_sum - 1.0)\n                if row_dev > max_row_dev:\n                    max_row_dev = row_dev\n                \n                # Diagnostic 2: Conditional expectation error\n                approx_exp = np.sum(y_grid * probs)\n                exp_err = abs(approx_exp - mu_ij)\n                if exp_err > max_exp_err:\n                    max_exp_err = exp_err\n                    \n        results.append([max_row_dev, max_exp_err])\n\n    # Final print statement in the exact required format.\n    # Format each pair as [val1,val2] and join them with commas.\n    pair_strs = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(pair_strs)}]\")\n\nsolve()\n\n```"}]}