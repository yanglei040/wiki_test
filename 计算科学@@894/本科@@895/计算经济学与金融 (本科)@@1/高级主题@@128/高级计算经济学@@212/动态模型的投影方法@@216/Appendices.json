{"hands_on_practices": [{"introduction": "在我们着手构建求解器之前，理解如何衡量一个近似解的“好坏”至关重要。本练习的核心是“欧拉方程残差”（Euler equation residual）这一概念，它是我们评估近似策略函数准确性的关键指标。通过为一个给定的策略函数计算其在整个状态空间上的误差，我们将学会如何量化和验证投影方法的求解质量。[@problem_id:2422834]", "id": "2422834", "problem": "考虑具有恒定相对风险厌恶（CRRA）偏好和柯布-道格拉斯生产函数的确定性新古典增长模型。设代表性行为人对消费的偏好由时期效用函数 $u(c)$ 给出，其中\n$$\nu(c) =\n\\begin{cases}\n\\dfrac{c^{1-\\sigma}}{1-\\sigma}, & \\text{若 } \\sigma \\neq 1, \\\\\n\\ln(c), & \\text{若 } \\sigma = 1,\n\\end{cases}\n$$\n$\\sigma > 0$ 是相对风险厌恶系数。资本 $k$ 的演化遵循\n$$\nk' = A k^{\\alpha} + (1-\\delta) k - c,\n$$\n其中 $A > 0$ 是全要素生产率，$\\alpha \\in (0,1)$ 是资本在生产中的份额，$\\delta \\in (0,1)$ 是折旧率。在此确定性设置中，刻画最优策略的欧拉方程为\n$$\nu'(c(k)) = \\beta \\, u'(c(k')) \\left( A \\alpha (k')^{\\alpha - 1} + 1 - \\delta \\right),\n$$\n其边际效用由下式给出\n$$\nu'(c) =\n\\begin{cases}\nc^{-\\sigma}, & \\text{若 } \\sigma \\neq 1, \\\\\n\\dfrac{1}{c}, & \\text{若 } \\sigma = 1.\n\\end{cases}\n$$\n\n假设给定一个近似消费策略函数 $\\hat{c}(k)$，该函数是先前通过在资本域 $[k_{\\min}, k_{\\max}]$ 上使用最高3次的 Chebyshev 多项式进行投影法得到的。定义从资本 $k \\in [k_{\\min}, k_{\\max}]$ 到 Chebyshev 域 $x \\in [-1,1]$ 的仿射变换为\n$$\nx(k) = \\frac{2 k - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.\n$$\n设前四个第一类 Chebyshev 多项式为\n$$\nT_0(x) = 1,\\quad T_1(x) = x,\\quad T_2(x) = 2x^2 - 1,\\quad T_3(x) = 4x^3 - 3x.\n$$\n近似消费策略为\n$$\n\\hat{c}(k) = \\theta_0 T_0(x(k)) + \\theta_1 T_1(x(k)) + \\theta_2 T_2(x(k)) + \\theta_3 T_3(x(k)),\n$$\n其系数向量 $\\boldsymbol{\\theta} = (\\theta_0,\\theta_1,\\theta_2,\\theta_3)$ 对每组参数集是特定的。对于任何给定的 $k$，定义隐含的下一期资本\n$$\nk'(k) = A k^{\\alpha} + (1-\\delta) k - \\hat{c}(k),\n$$\n并定义在 $k$ 处的欧拉方程绝对残差为\n$$\n\\left| u'(\\hat{c}(k)) - \\beta \\, u'(\\hat{c}(k'(k))) \\left( A \\alpha (k'(k))^{\\alpha - 1} + 1 - \\delta \\right) \\right|.\n$$\n您的任务是，对于下面的每个参数集，在一个横跨 $[k_{\\min}, k_{\\max}]$ 的 $N_{\\text{fine}}$ 个点的精细均匀网格上计算最大欧拉方程绝对残差。请使用一个包含两个端点的网格。答案没有物理单位。\n\n测试套件（每个案例指定 $(A,\\alpha,\\beta,\\delta,\\sigma)$、域 $[k_{\\min},k_{\\max}]$、系数向量 $\\boldsymbol{\\theta}$ 和 $N_{\\text{fine}}$）：\n\n- 案例1（基准，内部解）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 2.0)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.75, 0.35, 0.02, -0.01)$，$N_{\\text{fine}} = 2001$。\n\n- 案例2（更高的风险厌恶）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 5.0)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.70, 0.32, 0.00, 0.00)$，$N_{\\text{fine}} = 2001$。\n\n- 案例3（更高的折旧和更低的耐心）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.92, 0.15, 2.0)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.65, 0.28, 0.03, 0.00)$，$N_{\\text{fine}} = 2001$。\n\n- 案例4（近对数效用）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 1.01)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.74, 0.34, 0.01, 0.02)$，$N_{\\text{fine}} = 2001$。\n\n- 案例5（对数效用边界情况）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 1.0)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.72, 0.33, 0.01, 0.00)$，$N_{\\text{fine}} = 2001$。\n\n对于每个案例，计算精细网格上的最大欧拉方程绝对残差。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”）。将每个结果报告为一个浮点数，不带任何百分号，且没有特定的舍入要求。", "solution": "提交的问题陈述是一个定义明确的计算经济学练习。它具有科学依据，内部一致，并包含了进行计算所需的所有信息。任务是通过计算在指定域上的最大欧拉方程残差，来评估一个预先计算的确定性新古典增长模型近似策略函数的准确性。我将着手解决此问题。\n\n目标是计算最大欧拉方程绝对残差，其定义为\n$$\n\\text{Res}(k) = \\left| u'(\\hat{c}(k)) - \\beta \\, u'(\\hat{c}(k'(k))) \\left( A \\alpha (k'(k))^{\\alpha - 1} + 1 - \\delta \\right) \\right|,\n$$\n对于一组资本网格点 $k \\in [k_{\\min}, k_{\\max}]$。消费的策略函数 $\\hat{c}(k)$ 使用前四个第一类 Chebyshev 多项式 $T_n(x)$ 的线性组合来近似。\n\n每个测试案例的计算步骤如下：\n\n1.  **建立资本网格**：在区间 $[k_{\\min}, k_{\\max}]$ 上构建一个包含 $N_{\\text{fine}}$ 个资本水平的均匀网格，记为 $\\{k_i\\}_{i=1}^{N_{\\text{fine}}}$。该网格包含端点。\n\n2.  **评估当前消费 $\\hat{c}(k)$**：对于网格上的每个资本水平 $k_i$，我们首先使用仿射变换将其映射到 Chebyshev 域 $x_i = x(k_i) \\in [-1,1]$：\n    $$\n    x(k_i) = \\frac{2 k_i - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.\n    $$\n    然后，通过评估具有给定系数向量 $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1, \\theta_2, \\theta_3)$ 的 Chebyshev 多项式展开式来计算近似消费 $\\hat{c}(k_i)$：\n    $$\n    \\hat{c}(k_i) = \\sum_{j=0}^{3} \\theta_j T_j(x(k_i)).\n    $$\n    基多项式为 $T_0(x) = 1$，$T_1(x) = x$，$T_2(x) = 2x^2 - 1$ 和 $T_3(x) = 4x^3 - 3x$。\n\n3.  **确定下一期资本 $k'$**：使用资本的运动法则，为每个 $k_i$ 计算隐含的下一期资本存量 $k'_i = k'(k_i)$：\n    $$\n    k'_i = A k_i^{\\alpha} + (1-\\delta) k_i - \\hat{c}(k_i).\n    $$\n\n4.  **评估下一期消费 $\\hat{c}(k')$**：下一期的消费 $\\hat{c}(k'_i)$ 是通过将相同的近似策略函数应用于所得到的资本存量 $k'_i$ 来确定的。这涉及将每个 $k'_i$ 映射到其对应的 Chebyshev 域值 $x'_i = x(k'_i)$，并评估多项式展开式：\n    $$\n    \\hat{c}(k'_i) = \\sum_{j=0}^{3} \\theta_j T_j(x(k'_i)).\n    $$\n    请注意，不保证 $k'_i$ 在原始近似域 $[k_{\\min}, k_{\\max}]$ 内。在这种情况下，多项式提供的是外插值。\n\n5.  **计算边际效用**：消费的边际效用 $u'(c)$ 是针对当前和下一期的消费进行评估的。该函数取决于相对风险厌恶系数 $\\sigma$：\n    $$\n    u'(c) =\n    \\begin{cases}\n    c^{-\\sigma}, & \\text{若 } \\sigma \\neq 1, \\\\\n    c^{-1}, & \\text{若 } \\sigma = 1.\n    \\end{cases}\n    $$\n    我们为网格上的所有点计算 $u'(\\hat{c}(k_i))$ 和 $u'(\\hat{c}(k'_i))$。\n\n6.  **计算欧拉方程残差**：对于每个网格点 $k_i$，计算并比较欧拉方程的两边。左手边（LHS）是 $u'(\\hat{c}(k_i))$。右手边（RHS）是\n    $$\n    \\text{RHS}_i = \\beta \\, u'(\\hat{c}(k'_i)) \\left( A \\alpha (k'_i)^{\\alpha - 1} + 1 - \\delta \\right).\n    $$\n    项 $A \\alpha (k'_i)^{\\alpha - 1} + 1 - \\delta$ 代表下一期资本的总回报。在 $k_i$ 处的绝对残差是 $\\text{Res}(k_i) = |\\text{LHS}_i - \\text{RHS}_i|$。\n\n7.  **找到最大残差**：在计算了所有 $i=1, \\dots, N_{\\text{fine}}$ 的残差 $\\text{Res}(k_i)$ 后，确定最大值：\n    $$\n    \\max_{i} \\text{Res}(k_i).\n    $$\n这个最大值量化了近似策略函数在满足模型最优性条件方面在指定网格上的最大误差。整个过程使用向量化数值运算以提高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute Euler equation residual for several parameterizations\n    of the neoclassical growth model, given an approximate consumption policy function\n    represented by Chebyshev polynomials.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (A, alpha, beta, delta, sigma), [k_min, k_max], theta, N_fine\n        ( (1.0, 0.33, 0.96, 0.08, 2.0), [0.5, 3.0], [0.75, 0.35, 0.02, -0.01], 2001 ),\n        # Case 2\n        ( (1.0, 0.33, 0.96, 0.08, 5.0), [0.5, 3.0], [0.70, 0.32, 0.00, 0.00], 2001 ),\n        # Case 3\n        ( (1.0, 0.33, 0.92, 0.15, 2.0), [0.5, 3.0], [0.65, 0.28, 0.03, 0.00], 2001 ),\n        # Case 4\n        ( (1.0, 0.33, 0.96, 0.08, 1.01), [0.5, 3.0], [0.74, 0.34, 0.01, 0.02], 2001 ),\n        # Case 5\n        ( (1.0, 0.33, 0.96, 0.08, 1.0), [0.5, 3.0], [0.72, 0.33, 0.01, 0.00], 2001 )\n    ]\n\n    results = []\n\n    def evaluate_chebyshev_policy(k, k_min, k_max, theta_coeffs):\n        \"\"\"\n        Evaluates the consumption policy approximated by Chebyshev polynomials.\n        It is vectorized to operate on an array of capital levels k.\n        \"\"\"\n        # Map capital k from [k_min, k_max] to x in [-1, 1]\n        x = (2 * k - (k_min + k_max)) / (k_max - k_min)\n        \n        # Chebyshev polynomials T0, T1, T2, T3\n        T0 = np.ones_like(x)\n        T1 = x\n        T2 = 2 * x**2 - 1\n        T3 = 4 * x**3 - 3 * x\n        \n        # Form the basis matrix (N x 4)\n        chebyshev_basis = np.vstack([T0, T1, T2, T3]).T\n        \n        # Calculate consumption c_hat using matrix-vector product\n        c_hat = chebyshev_basis @ theta_coeffs\n        return c_hat\n\n    for case in test_cases:\n        params, k_domain, theta_list, N_fine = case\n        A, alpha, beta, delta, sigma = params\n        k_min, k_max = k_domain\n        theta = np.array(theta_list)\n\n        # 1. Create the capital grid\n        k_grid = np.linspace(k_min, k_max, N_fine)\n        \n        # 2. Evaluate current consumption on the grid\n        c_k = evaluate_chebyshev_policy(k_grid, k_min, k_max, theta)\n        \n        # 3. Determine next-period capital\n        k_prime = A * k_grid**alpha + (1 - delta) * k_grid - c_k\n        \n        # 4. Evaluate next-period consumption\n        c_k_prime = evaluate_chebyshev_policy(k_prime, k_min, k_max, theta)\n        \n        # 5. Calculate marginal utilities\n        if sigma == 1.0:\n            mu_k = 1.0 / c_k\n            mu_k_prime = 1.0 / c_k_prime\n        else:\n            mu_k = c_k**(-sigma)\n            mu_k_prime = c_k_prime**(-sigma)\n\n        # 6. Calculate the RHS of the Euler equation\n        # Marginal product of capital in the next period\n        mpk_prime = A * alpha * k_prime**(alpha - 1) + 1 - delta\n        \n        # Full RHS\n        euler_rhs = beta * mu_k_prime * mpk_prime\n        \n        # 7. Calculate the absolute residuals\n        residuals = np.abs(mu_k - euler_rhs)\n        \n        # 8. Find the maximum residual and store it\n        max_residual = np.max(residuals)\n        results.append(max_residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "现在我们知道如何检验一个解，下一步便是从头开始构建一个求解器。本练习将指导您为一个标准增长模型实现一个完整的配置点求解器（collocation solver）。您将接触并应用“自动微分”这项现代计算技术，以优雅地处理牛顿法（Newton's method）所需的复杂导数计算，从而掌握一套功能强大的动态模型求解工具。[@problem_id:2422824]", "id": "2422824", "problem": "您的任务是使用多项式策略近似，通过投影和配置法，并结合自动微分，实现并求解一个确定性的单状态新古典增长模型。数值目标是近似满足跨期最优性条件的最优策略，并报告在多个参数集下，评估网格上的最大欧拉方程残差。您的程序必须是一个完整、可运行的程序，并能产生指定的单行输出。\n\n模型与基本原理：\n- 代表性代理人选择消费 $c_t$ 和下一期资本 $k_{t+1}$，以最大化时期效用的贴现总和\n$$\\sum_{t=0}^{\\infty} \\beta^t u(c_t),$$\n并遵循以下资源运动定律\n$$c_t + k_{t+1} = f(k_t) + (1-\\delta)\\,k_t,$$\n其中生产函数为 $f(k) = A\\,k^{\\alpha}$，贴现因子 $\\beta \\in (0,1)$，资本份额 $\\alpha \\in (0,1)$，折旧率 $\\delta \\in (0,1)$，生产率 $A > 0$。偏好为恒定相对风险厌恶（CRRA）形式，其参数 $\\gamma > 0$，具体如下\n$$u(c) = \n\\begin{cases}\n\\frac{c^{1-\\gamma}}{1-\\gamma}, & \\gamma \\neq 1,\\\\\n\\ln(c), & \\gamma = 1,\n\\end{cases}\n\\quad\\text{即}\\quad\nu'(c) = \n\\begin{cases}\nc^{-\\gamma}, & \\gamma \\neq 1,\\\\\n\\frac{1}{c}, & \\gamma = 1.\n\\end{cases}$$\n- 内部解的跨期最优性（欧拉）条件是\n$$u'(c_t) = \\beta\\,u'(c_{t+1})\\left(f'(k_{t+1}) + 1 - \\delta\\right),$$\n其中 $f'(k) = \\alpha A k^{\\alpha - 1}$。\n\n策略表示与投影设置：\n- 定义可用资源为 $R(k) = f(k)+(1-\\delta)k$。\n- 将策略参数化为一个平滑的储蓄份额 $s(k) \\in (0,1)$，并设定\n$$k' = s(k)\\,R(k), \\quad c = (1-s(k))\\,R(k).$$\n- 令 $x(k)$ 为一个仿射映射，它将 $k \\in [k_{\\min},k_{\\max}]$ 映射到 $[-1,1]$：\n$$x(k) = \\frac{2k - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.$$\n- 用一个 $n-1$ 阶的截断切比雪夫级数来近似储蓄份额的 logit：\n$$\\phi(k) \\equiv \\log\\left(\\frac{s(k)}{1 - s(k)}\\right) \\approx \\sum_{j=0}^{n-1} a_j\\,T_j(x(k)),$$\n然后通过 logistic 映射 $\\sigma(z) = \\frac{1}{1+e^{-z}}$ 得到 $s(k) = \\sigma(\\phi(k))$。\n- 配置：选择 $n$ 个切比雪夫节点 $x_i = \\cos\\left(\\frac{2i-1}{2n}\\pi\\right)$（$i=1,\\dots,n$），并通过 $x \\mapsto k$ 将它们映射到资本网格点 $k_i$。强制 $n$ 个欧拉方程残差在这 $n$ 个节点上为零，由此定义残差向量 $R(a)\\in\\mathbb{R}^n$：\n$$R_i(a) = u'\\big(c(k_i;a)\\big) - \\beta\\,u'\\big(c(k'_i;a)\\big)\\left(f'(k'_i)+1-\\delta\\right), \\quad k'_i = s(k_i;a)\\,R(k_i), \\quad c(k_i;a) = R(k_i) - k'_i,$$\n$$c(k'_i;a) = R(k'_i) - s(k'_i;a)\\,R(k'_i).$$\n此处 $a = (a_0,\\dots,a_{n-1})$ 是未知系数。\n\n自动微分要求：\n- 为实现一个稳定且精确的牛顿求解器来解非线性系统 $R(a) = 0$，请使用自动微分计算雅可比矩阵 $\\frac{\\partial R}{\\partial a}(a)$。您可以通过实现前向模式对偶数来达到此目的，以使代码保持自包含，并且不依赖于允许库之外的外部软件包。\n\n数值规格以确保真实性和可复现性：\n- 对于每个参数集，计算由稳态欧拉条件所隐含的稳态资本水平 $k^{\\ast}$\n$$f'(k^{\\ast}) + 1 - \\delta = \\frac{1}{\\beta}, \\quad\\text{即}\\quad \\alpha A (k^{\\ast})^{\\alpha - 1} = \\frac{1}{\\beta} - 1 + \\delta,$$\n并将近似区间设为 $[k_{\\min},k_{\\max}] = [\\zeta_1 k^{\\ast},\\, \\zeta_2 k^{\\ast}]$，其中 $\\zeta_1 = 0.7$ 且 $\\zeta_2 = 1.3$。\n- 使用 $n = 7$ 个切比雪夫基函数和 $n = 7$ 个配置节点。\n- 使用与稳态储蓄份额 $s^{\\ast} = \\frac{k^{\\ast}}{R(k^{\\ast})}$ 相对应的恒定 logit 来初始化系数，即设 $a_0 = \\log\\left(\\frac{s^{\\ast}}{1-s^{\\ast}}\\right)$ 且对于 $j \\ge 1$ 设 $a_j = 0$。\n\n测试套件：\n实现您的求解器，并通过计算下面每个参数集在 $[k_{\\min},k_{\\max}]$ 区间上 $M = 80$ 个等距点的评估网格上的最大绝对欧拉残差，来评估投影解的质量：\n$$\\max_{k \\in \\mathcal{G}} \\left| u'\\big(c(k;a)\\big) - \\beta\\,u'\\big(c(k';a)\\big)\\left(f'(k')+1-\\delta\\right) \\right|,$$\n其中 $\\mathcal{G}$ 是均匀网格，且 $k' = s(k;a)R(k)$, $c(k;a)=R(k)-k'$, $c(k';a)=R(k')-s(k';a)R(k')$ 如上所述。将每个测试用例的最大值报告为一个浮点数。\n\n参数集如下：\n- 案例 A（基准）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.33,\\,0.96,\\,0.08,\\,2.0,\\,1.0)$。\n- 案例 B（有耐心）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.36,\\,0.99,\\,0.025,\\,2.0,\\,1.0)$。\n- 案例 C（高折旧和高风险厌恶）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.40,\\,0.95,\\,0.15,\\,3.0,\\,1.0)$。\n- 案例 D（对数效用）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.33,\\,0.97,\\,0.08,\\,1.0,\\,1.0)$。\n\n算法要求：\n- 使用带回溯线搜索的牛顿法求解系数向量 $a$ 以解决 $R(a) = 0$。当残差向量的无穷范数低于 $\\varepsilon = 10^{-8}$ 或达到最大迭代次数 $I_{\\max} = 50$ 时终止。\n- 通过前向模式对偶数计算雅可比矩阵 $\\frac{\\partial R}{\\partial a}(a)$，对切比雪夫递推关系 $T_0(x)=1$, $T_1(x)=x$, $T_{j+1}(x) = 2xT_j(x) - T_{j-1}(x)$ 及所有下游计算（包括 $k'$, $c$, $c'$）进行微分。\n- 在求解牛顿步时，如果雅可比矩阵是奇异或病态的，您可以使用最小二乘步。\n\n最终输出格式：\n- 对于给定的 A-D 四个案例，您的程序应按顺序生成单行输出，其中包含四个最大残差值，格式为逗号分隔的列表并用方括号括起，例如，「[vA,vB,vC,vD]」。每个条目必须是浮点数。\n\n不涉及物理单位或角度单位。将所有最终数值表示为不带百分号的普通浮点数。程序必须是自包含的，且不需要任何用户输入或外部文件。唯一允许的库是执行环境中声明的 Python 标准库、NumPy 和 SciPy。", "solution": "所提出的问题是计算经济学中一个标准的、定义明确的练习：使用投影法对确定性新古典增长模型进行数值求解。问题的所有组成部分——经济模型、近似架构和数值算法——都基于已建立且科学合理​​的原则。问题是自包含的、内部一致的，并且事实的可靠性、适定性和客观性都得到满足，使得该问题适合进行完整求解。\n\n我们从模型的基本最优性条件——欧拉方程——开始，它连接了跨时期的边际效用：\n$$\nu'(c_t) = \\beta\\,u'(c_{t+1})\\left(f'(k_{t+1}) + 1 - \\delta\\right)\n$$\n在这里，$c_t$ 是在时间 $t$ 的消费，$k_t$ 是资本存量，$\\beta$ 是贴现因子，$\\delta$ 是资本折旧率。效用函数是恒定相对风险厌恶（CRRA）形式，$u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$（如果 $\\gamma=1$ 则为 $\\ln(c)$），其边际效用恒为 $u'(c) = c^{-\\gamma}$。生产函数是柯布-道格拉斯形式，$f(k) = Ak^{\\alpha}$，其边际产品为 $f'(k) = \\alpha A k^{\\alpha-1}$。\n\n目标是找到最优策略函数，它为任何给定的当前资本存量 $k_t$ 决定下一期的资本 $k_{t+1}$。我们将此函数表示为 $k_{t+1} = g(k_t)$。投影法使用一个已知的、参数化的函数形式来近似这个未知函数 $g(k)$。该问题通过储蓄份额 $s(k) \\in (0,1)$ 指定了一种数值稳定的参数化方法，使得：\n$$\nk_{t+1} = s(k_t) R(k_t) \\quad \\text{和} \\quad c_t = (1-s(k_t))R(k_t)\n$$\n其中 $R(k) = f(k) + (1-\\delta)k$ 代表可从生产和未折旧资本中获得的总资源。这种表述通过构造确保了资源约束得到满足。\n\n为了便于在无界范围上进行近似，储蓄份额 $s(k)$ 使用 logit 函数进行转换，$\\phi(k) = \\log\\left(\\frac{s(k)}{1-s(k)}\\right)$。这个转换后的策略函数 $\\phi(k)$ 由一个截断的 $n$ 项第一类切比雪夫多项式 $T_j(x)$ 级数来近似：\n$$\n\\phi(k; a) \\approx \\sum_{j=0}^{n-1} a_j T_j(x(k))\n$$\n其中 $a = (a_0, \\dots, a_{n-1})$ 是待确定的未知系数向量。变量 $x(k)$ 是一个仿射变换，它将资本近似域 $[k_{\\min}, k_{\\max}]$ 映射到切比雪夫多项式的定义域 $[-1, 1]$。给定系数 $a$，储蓄份额可以通过逆 logit（logistic）函数恢复，$s(k;a) = \\frac{1}{1+e^{-\\phi(k;a)}}$。\n\n投影法的核心是通过要求欧拉方程在一组 $n$ 个特定点（称为配置节点）上精确成立来确定系数 $a$。该问题指定这些节点为切比雪夫多项式 $T_n(x)$ 的 $n$ 个根，并映射回资本域 $[k_{\\min}, k_{\\max}]$。这为 $n$ 个未知系数创建了一个包含 $n$ 个非线性方程的方程组。对于每个配置节点 $k_i$，我们定义一个残差函数 $E_i(a)$：\n$$\nE_i(a) = u'(c_i) - \\beta u'(c'_i)(f'(k'_i) + 1 - \\delta) = 0\n$$\n其中 $c_i = c(k_i; a)$，$k'_i = k(k_i; a)$，以及 $c'_i = c(k'_i; a)$。目标是找到解开系统 $E(a) = 0$ 的向量 $a$。\n\n该系统使用牛顿法求解，这是一种迭代算法，需要计算雅可比矩阵 $J(a) = \\frac{\\partial E}{\\partial a}(a)$。矩阵项 $J_{ij}$ 是第 $i$ 个残差相对于第 $j$ 个系数的偏导数。系数的更新规则是：\n$$\na_{new} = a_{old} - J(a_{old})^{-1} E(a_{old})\n$$\n问题要求雅可比矩阵通过前向模式自动微分（AD）计算。这是通过实现一个对偶数系统来实现的。一个对偶数 $z = v + \\dot{v}\\epsilon$ 有一个值部分 $v$ 和一个导数部分 $\\dot{v}$，并具有属性 $\\epsilon^2 = 0$。所有数学运算和函数都被重载，以根据微积分法则传播导数。例如，对于函数 $h(z)$，我们有 $h(v + \\dot{v}\\epsilon) = h(v) + h'(v)\\dot{v}\\epsilon$。为了计算雅可比矩阵的第 $j$ 列，我们将系数向量初始化为 $a_k = a_k^{\\text{val}} + \\delta_{kj}\\epsilon$（其中 $\\delta_{kj}$ 是克罗内克 δ），并计算整个残差向量 $E$。第 $i$ 个结果对偶数的导数部分 $\\dot{E_i}$，恰好就是雅可比矩阵元素 $J_{ij}$。\n\n牛顿法通过回溯线搜索得到增强，以确保稳健收敛。如果一个完整的牛顿步没有减小残差向量的范数，步长将被连续减小。求解器会一直迭代，直到残差向量的无穷范数低于指定的容差 $\\varepsilon = 10^{-8}$。\n\n一旦找到最优系数向量 $a^*$，近似的质量将通过在跨越近似区间 $[k_{\\min}, k_{\\max}]$ 的 $M=80$ 个点的细网格上计算最大绝对欧拉方程残差来评估。该值将作为每个参数集的最终可报告指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# ---- Automatic Differentiation: Dual Number Implementation ----\nclass Dual:\n    \"\"\"\n    A class for forward-mode automatic differentiation.\n    A Dual number z = val + der * epsilon, where epsilon^2 = 0.\n    \"\"\"\n    def __init__(self, val, der=0.0):\n        self.val = val\n        self.der = der\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val + other.val, self.der + other.der)\n        return Dual(self.val + other, self.der)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val - other.val, self.der - other.der)\n        return Dual(self.val - other, self.der)\n\n    def __rsub__(self, other):\n        return Dual(other - self.val, -self.der)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val * other.val, self.der * other.val + self.val * other.der)\n        return Dual(self.val * other, self.der * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            val = self.val / other.val\n            der = (self.der * other.val - self.val * other.der) / (other.val**2)\n            return Dual(val, der)\n        return Dual(self.val / other, self.der / other)\n\n    def __rtruediv__(self, other):\n        val = other / self.val\n        der = (-other * self.der) / (self.val**2)\n        return Dual(val, der)\n\n    def __pow__(self, power):\n        val = self.val ** power\n        der = power * (self.val ** (power - 1)) * self.der\n        return Dual(val, der)\n\n    def __neg__(self):\n        return Dual(-self.val, -self.der)\n\n    def __repr__(self):\n        return f\"Dual(val={self.val}, der={self.der})\"\n\ndef dual_exp(d):\n    if isinstance(d, Dual):\n        val = np.exp(d.val)\n        return Dual(val, val * d.der)\n    return np.exp(d)\n\ndef dual_pow(base, exp):\n    if isinstance(base, Dual):\n        return base ** exp\n    return base ** exp\n\n\n# ---- Model and Numerical Method Implementation ----\n\ndef chebyshev_poly_vals(x, n):\n    \"\"\"Evaluates the first n Chebyshev polynomials T_0, ..., T_{n-1} at x.\"\"\"\n    if n == 0:\n        return []\n    \n    T = [1.0, x] if not isinstance(x, Dual) else [Dual(1.0), x]\n    \n    for _ in range(n - 2):\n        T.append(2.0 * x * T[-1] - T[-2])\n    return T[:n]\n\ndef evaluate_policy(k, coeffs, params):\n    \"\"\"\n    Given capital k and coefficients a, computes c and k'.\n    This function handles both float and Dual types.\n    \"\"\"\n    alpha, _, delta, _, A, k_min, k_max, n = params\n    \n    is_dual = isinstance(coeffs[0], Dual) or isinstance(k, Dual)\n\n    # 1. Map k to x in [-1, 1]\n    x = (2.0 * k - (k_min + k_max)) / (k_max - k_min)\n\n    # 2. Evaluate Chebyshev basis\n    T_vals = chebyshev_poly_vals(x, n)\n    \n    # 3. Compute logit of savings share phi = sum(a_j * T_j(x))\n    phi = Dual(0.0) if is_dual else 0.0\n    for i in range(n):\n        phi += coeffs[i] * T_vals[i]\n\n    # 4. Compute savings share s = 1 / (1 + exp(-phi))\n    s = 1.0 / (1.0 + dual_exp(-phi))\n\n    # 5. Compute resources R(k), next-period capital k', and consumption c\n    R_k = A * dual_pow(k, alpha) + (1.0 - delta) * k\n    k_prime = s * R_k\n    c = (1.0 - s) * R_k\n\n    return c, k_prime\n\ndef calculate_residuals(coeffs, k_nodes, params):\n    \"\"\"\n    Calculates the Euler equation residuals at the given capital nodes.\n    Handles both float and Dual coefficients.\n    \"\"\"\n    alpha, beta, delta, gamma, A, _, _, _ = params\n    is_dual_input = isinstance(coeffs[0], Dual)\n    residuals = []\n\n    for k_node in k_nodes:\n        # Get c and k' at the current node k\n        c, k_prime = evaluate_policy(k_node, coeffs, params)\n        \n        # Get c' at the future capital level k'\n        c_prime, _ = evaluate_policy(k_prime, coeffs, params)\n\n        # Marginal utility and marginal product\n        u_prime_c = dual_pow(c, -gamma)\n        u_prime_c_prime = dual_pow(c_prime, -gamma)\n        f_prime_k_prime = alpha * A * dual_pow(k_prime, alpha - 1)\n        \n        # Euler residual\n        res = u_prime_c - beta * u_prime_c_prime * (f_prime_k_prime + 1.0 - delta)\n        residuals.append(res)\n    \n    if not is_dual_input:\n        return np.array([r for r in residuals])\n    return residuals\n\ndef solve_for_case(case_params):\n    \"\"\"\n    Solves the model for a single set of parameters.\n    \"\"\"\n    alpha, beta, delta, gamma, A = case_params\n    n, M, tol, max_iter = 7, 80, 1e-8, 50\n\n    # 1. Steady state capital\n    k_ss_numerator = alpha * A\n    k_ss_denominator = 1.0 / beta - 1.0 + delta\n    k_ss = (k_ss_numerator / k_ss_denominator) ** (1.0 / (1.0 - alpha))\n\n    # 2. Grid and state space\n    k_min, k_max = 0.7 * k_ss, 1.3 * k_ss\n    params = (alpha, beta, delta, gamma, A, k_min, k_max, n)\n    \n    # Collocation nodes (zeros of T_n)\n    chebyshev_zeros = np.cos((2 * np.arange(1, n + 1) - 1) * np.pi / (2 * n))\n    k_nodes = (k_min + k_max) / 2.0 + (k_max - k_min) / 2.0 * chebyshev_zeros\n    \n    # 3. Initial guess for coefficients 'a'\n    R_k_ss = A * k_ss**alpha + (1.0 - delta) * k_ss\n    s_ss = k_ss / R_k_ss\n    a = np.zeros(n)\n    a[0] = np.log(s_ss / (1.0 - s_ss))\n\n    # 4. Newton's method solver\n    for i in range(max_iter):\n        # Calculate residuals R(a)\n        R_val = calculate_residuals(a, k_nodes, params)\n        \n        res_norm = np.linalg.norm(R_val, np.inf)\n        if res_norm < tol:\n            break\n\n        # Calculate Jacobian J(a) using Automatic Differentiation\n        J = np.zeros((n, n))\n        for j in range(n):\n            a_dual = [Dual(val, 1.0 if idx == j else 0.0) for idx, val in enumerate(a)]\n            R_dual = calculate_residuals(a_dual, k_nodes, params)\n            J[:, j] = [res.der for res in R_dual]\n        \n        # Solve Newton step using least squares for robustness\n        delta_a = np.linalg.lstsq(J, -R_val, rcond=None)[0]\n        \n        # Backtracking line search\n        lambda_ = 1.0\n        for _ in range(10): # At most 10 backtracking steps\n            a_new = a + lambda_ * delta_a\n            R_new = calculate_residuals(a_new, k_nodes, params)\n            if np.linalg.norm(R_new, np.inf) < res_norm:\n                a = a_new\n                break\n            lambda_ *= 0.5\n        else: # If line search fails, take the small step and hope for the best\n            a = a + lambda_ * delta_a\n\n    # 5. Evaluate solution quality on a fine grid\n    eval_grid = np.linspace(k_min, k_max, M)\n    final_residuals = calculate_residuals(a, eval_grid, params)\n    max_abs_residual = np.max(np.abs(final_residuals))\n    \n    return max_abs_residual\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.33, 0.96, 0.08, 2.0, 1.0),   # Case A (baseline)\n        (0.36, 0.99, 0.025, 2.0, 1.0),  # Case B (patient)\n        (0.40, 0.95, 0.15, 3.0, 1.0),   # Case C (high depreciation and risk aversion)\n        (0.33, 0.97, 0.08, 1.0, 1.0),   # Case D (log utility)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_for_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"}, {"introduction": "真实的经济模型常常包含标准教科书案例所忽略的复杂性。这项高级练习将挑战您去求解一个生产率冲击服从非标准双峰分布的模型。您将探索数值积分（求积）方案的选择如何影响解的准确性，从而突显出根据模型的具体假设来精心设计数值方法的重要性。[@problem_id:2422848]", "id": "2422848", "problem": "考虑一个真实商业周期（RBC）经济体，其劳动力供给无弹性，除了生产率之外，资本是唯一的状变量，具有幂效用函数和 Cobb-Douglas 生产函数。生产率是乘性的和随机的。Bellman 方程的表述导出了可以由欧拉方程和资源约束概括的一阶最优性条件。令 $k_t$ 表示资本，$s_t$ 表示生产率的对数，$z_t = \\exp(s_t)$ 表示生产率。偏好由 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ 给出，其中风险厌恶参数 $\\gamma \\gt 0$，生产遵循 $y_t = z_t k_t^{\\alpha}$，其中资本折旧率为 $\\delta \\in (0,1)$，资本份额为 $\\alpha \\in (0,1)$。欧拉方程和资源约束为\n$$\nu'(c_t) = \\beta \\mathbb{E}\\left[u'(c_{t+1})\\left(\\alpha z_{t+1} k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right],\n\\quad\nc_t + k_{t+1} = z_t k_t^{\\alpha} + (1-\\delta)k_t,\n$$\n其中 $\\beta \\in (0,1)$ 是贴现因子，期望是关于生产率的运动定律计算的。\n\n与标准设定不同，假设 $s_t$ 是独立同分布（i.i.d.）的，服从一个双峰正态混合分布：\n$$\ns_t \\sim p \\cdot \\mathcal{N}(\\mu_1,\\sigma_1^2) + (1-p)\\cdot \\mathcal{N}(\\mu_2,\\sigma_2^2),\n$$\n混合权重为 $p \\in (0,1)$，分量参数为 $\\mu_1,\\mu_2 \\in \\mathbb{R}$ 和 $\\sigma_1,\\sigma_2 \\gt 0$。该过程随时间是独立同分布的。\n\n你的任务是为由下式定义的最优储蓄率策略 $\\phi(k,s) \\in (0,1)$ 构建一个投影法解：\n$$\nk' = \\phi(k,s)\\left(z k^{\\alpha} + (1-\\delta)k\\right),\n\\quad\nc = \\left(1-\\phi(k,s)\\right)\\left(z k^{\\alpha} + (1-\\delta)k\\right),\n$$\n使用 $(k,s)$ 中的张量积 Chebyshev 多项式基，并通过配置法（collocation）最小化欧拉方程残差。在 $(k,s)$ 处的欧拉残差为\n$$\n\\mathcal{R}(k,s;\\theta) \\equiv u'(c(k,s;\\theta)) - \\beta\\, \\mathbb{E}\\left[u'(c'(k,s;\\theta,s'))\\left(\\alpha \\exp(s') k'(k,s;\\theta)^{\\alpha-1} + 1-\\delta\\right)\\right],\n$$\n其中 $\\theta$ 是基系数，$k' = \\phi(k,s;\\theta)\\left(\\exp(s)k^{\\alpha} + (1-\\delta)k\\right)$，以及 $c' = \\left(1-\\phi(k',s';\\theta)\\right)\\left(\\exp(s')k'^{\\alpha} + (1-\\delta)k'\\right)$。\n\n为计算期望，使用 Gaussian–Hermite 求积法（阶数见下文）。考虑两种针对 $s'$ 分布的求积方案：\n- 一种简化的单正态方案，该方案用一个单一正态分布 $\\mathcal{N}(\\mu_{\\text{mix}},\\sigma_{\\text{mix}}^2)$ 来近似混合分布，其均值和方差与混合分布的均值和方差相匹配。在此近似下，通过变量替换 $s' = \\mu_{\\text{mix}} + \\sqrt{2}\\,\\sigma_{\\text{mix}} x$ 并相应调整权重，使用 Gaussian–Hermite 求积法计算 $\\mathbb{E}[g(s')]$。\n- 一种混合校正方案，该方案计算 $\\mathbb{E}[g(s')]$ 的方式为：$p$ 乘以在 $\\mathcal{N}(\\mu_1,\\sigma_1^2)$ 下的 Gaussian–Hermite 求积结果，加上 $(1-p)$ 乘以在 $\\mathcal{N}(\\mu_2,\\sigma_2^2)$ 下的 Gaussian–Hermite 求积结果。\n\n你必须：\n- 将投影基指定为在 $k$ 上最高 $d_k$ 阶、在 $s$ 上最高 $d_s$ 阶的 Chebyshev 多项式的张量积。在计算 Chebyshev 多项式之前，将 $k$ 和 $s$ 的定义域仿射映射到 $[-1,1]$。使用 $d_k = 3$ 和 $d_s = 2$。\n- 将策略参数化为 $\\phi(k,s;\\theta) = \\sigma\\!\\left(B(k,s)^{\\top}\\theta\\right)$，其中 $B(k,s)$ 是基向量，$\\sigma(\\cdot)$ 是 logistic sigmoid 函数，映射到 $(0,1)$。这强制了对所有 $(k,s)$，可行性条件 $c \\in (0, z k^{\\alpha} + (1-\\delta)k)$ 均成立。\n- 选择一个矩形配置网格，作为 $k$ 和 $s$ 中 Chebyshev 节点的张量积，节点数分别为 $N_k=7$ 和 $N_s=5$。\n- 在由混合分布所蕴含的生产率无条件均值 $\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)]$ 下，计算确定性稳态资本 $k^{\\star}$，并将 $k$ 的定义域设为 $[0.75\\,k^{\\star}, 1.25\\,k^{\\star}]$。将 $s$ 的定义域设为 $[\\min(\\mu_1 - 3\\sigma_1, \\mu_2 - 3\\sigma_2), \\max(\\mu_1 + 3\\sigma_1, \\mu_2 + 3\\sigma_2)]$。\n- 通过对配置节点上的欧拉残差进行非线性最小二乘法求解基系数 $\\theta$。此操作需执行两次：一次在残差定义中使用简化的单正态求积法，另一次使用混合校正求积法。\n- 在一个更精细的矩形网格（大小为 $N_k^{\\text{val}}=13 \\times N_s^{\\text{val}}=9$，Chebyshev 节点映射到相同定义域）上验证每个解，计算使用真实的混合校正求积法评估的欧拉残差的上确界范数。\n\n使用以下固定的结构参数：$\\alpha = 0.33$，$\\beta = 0.96$，$\\delta = 0.08$，$\\gamma = 2.0$。对期望的计算使用 $N_q = 7$ 阶的 Gaussian–Hermite 求积法。\n\n测试套件。为以下三个独立案例求解该问题（所有其他参数如上所述）：\n- 案例 A（平衡双峰）：$p = 0.5$, $\\mu_1 = -0.1$, $\\sigma_1 = 0.05$, $\\mu_2 = 0.1$, $\\sigma_2 = 0.05$。\n- 案例 B（非对称且更分离）：$p = 0.7$, $\\mu_1 = -0.2$, $\\sigma_1 = 0.08$, $\\mu_2 = 0.2$, $\\sigma_2 = 0.08$。\n- 案例 C（退化为单峰）：$p = 0.4$, $\\mu_1 = 0.0$, $\\sigma_1 = 0.07$, $\\mu_2 = 0.0$, $\\sigma_2 = 0.07$。\n\n对于每个案例，在使用两种求积方案求解策略后，在验证网格上计算：\n- $r_{\\text{mix}}$：使用混合校正求积法评估混合校正策略所得的欧拉残差的上确界范数。\n- $r_{\\text{naive}\\to \\text{true}}$：使用混合校正求积法评估简化求积策略所得的欧拉残差的上确界范数。\n- $\\Delta r \\equiv r_{\\text{naive}\\to \\text{true}} - r_{\\text{mix}}$。\n\n你的程序应生成单行输出，包含一个逗号分隔的列表，用方括号括起，顺序如下\n$$\n\\left[r_{\\text{mix}}^{(A)},\\; r_{\\text{naive}\\to \\text{true}}^{(A)},\\; \\Delta r^{(A)},\\; r_{\\text{mix}}^{(B)},\\; r_{\\text{naive}\\to \\text{true}}^{(B)},\\; \\Delta r^{(B)},\\; r_{\\text{mix}}^{(C)},\\; r_{\\text{naive}\\to \\text{true}}^{(C)},\\; \\Delta r^{(C)}\\right].\n$$\n所有数字都是无单位的实数值。不涉及角度或百分比。\n\n最终答案必须是一个完整的、可运行的程序，该程序实现了上述规范，并严格按照要求格式打印一行输出。不要求任何用户输入。", "solution": "所提出的问题是计算经济学中一个适定（well-posed）的练习，要求应用投影法来求解一个动态随机一般均衡模型。其参数定义清晰，科学基础在真实商业周期理论框架内是合理的，并且指定的数值方法是标准的、适合该任务的。因此，该问题是有效的，并将构建一个解。\n\n目标是在一个随机增长模型中，为最优的消费-储蓄策略寻找一个近似解。经济的动态由跨期欧拉方程决定，该方程将牺牲一单位当前消费的边际效用成本，与由此产生的未来消费的预期贴现边际效用收益相等同。经济的状态由资本存量 $k$ 和生产率的对数 $s$ 描述。\n\n控制性的泛函方程是欧拉方程：\n$$\nu'(c_t) = \\beta \\mathbb{E}_t\\left[u'(c_{t+1})\\left(\\alpha z_{t+1} k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right]\n$$\n其中 $u'(c) = c^{-\\gamma}$ 是消费的边际效用，$\\beta$ 是贴现因子，$\\alpha$ 是生产中的资本份额，$\\delta$ 是资本折旧率，$z_{t+1} = \\exp(s_{t+1})$ 是未来的生产率水平。期望 $\\mathbb{E}_t[\\cdot]$ 是对未来生产率冲击 $s_{t+1}$ 的分布计算的。资本的运动定律由资源约束 $c_t + k_{t+1} = z_t k_t^{\\alpha} + (1-\\delta)k_t$ 决定。\n\n问题的核心在于，对于策略函数——消费 $c(k,s)$ 和下一期资本 $k'(k,s)$——不存在解析解。因此我们采用数值近似方法。\n\n**1. 策略函数近似**\n\n我们近似最优储蓄率策略 $\\phi(k,s)$，它决定了可用资源中用于储蓄的比例。下一期资本和当期消费的策略函数则为：\n$$\nk'(k,s) = \\phi(k,s) \\left( \\exp(s) k^{\\alpha} + (1-\\delta)k \\right)\n$$\n$$\nc(k,s) = (1-\\phi(k,s)) \\left( \\exp(s) k^{\\alpha} + (1-\\delta)k \\right)\n$$\n储蓄率必须位于区间 $(0,1)$ 内，以确保消费和投资均为正。我们通过使用 logistic sigmoid 函数 $\\sigma(x) = (1+e^{-x})^{-1}$ 对策略进行参数化来强制执行此约束：\n$$\n\\phi(k,s; \\theta) = \\sigma\\left(\\sum_{i=0}^{d_k} \\sum_{j=0}^{d_s} \\theta_{ij} T_i(\\hat{k}) T_j(\\hat{s})\\right)\n$$\n这里，$\\{T_i\\}$ 和 $\\{T_j\\}$ 是第一类 Chebyshev 多项式。状态变量 $(k,s)$被线性映射到定义多项式的规范域 $[-1,1]$ 上的 $(\\hat{k}, \\hat{s})$。系数集合 $\\{\\theta_{ij}\\}$ 是待确定的参数。阶数被指定为 $d_k=3$ 和 $d_s=2$，从而得到 $(3+1)(2+1)=12$ 个基函数和相应的系数 $\\theta$。\n\n**2. 状态空间和配置网格**\n\n近似是在状态变量的有界域上执行的。\n- 资本 $k$ 的定义域以确定性稳态资本存量 $k^{\\star}$ 为中心。这个稳态是通过假设生产率固定在其无条件均值 $\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)]$ 并且所有状态变量恒定不变来找到的。求解稳态欧拉方程 $1 = \\beta (\\alpha \\mathbb{E}[z] (k^{\\star})^{\\alpha-1} + 1 - \\delta)$ 得到：\n$$\nk^{\\star} = \\left( \\frac{\\alpha \\mathbb{E}[z]}{\\frac{1}{\\beta} - 1 + \\delta} \\right)^{\\frac{1}{1-\\alpha}}\n$$\n期望 $\\mathbb{E}[z]$ 是关于为 $s$ 指定的正态混合分布计算的：\n$$\n\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)] = p \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_1,\\sigma_1^2)}[\\exp(s)] + (1-p) \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_2,\\sigma_2^2)}[\\exp(s)] = p e^{\\mu_1 + \\sigma_1^2/2} + (1-p) e^{\\mu_2 + \\sigma_2^2/2}\n$$\n$k$ 的定义域随后被设为 $[0.75 k^{\\star}, 1.25 k^{\\star}]$。\n- 生产率冲击 $s$ 的定义域被设定为覆盖其大部分概率质量：$[\\min(\\mu_1 - 3\\sigma_1, \\mu_2 - 3\\sigma_2), \\max(\\mu_1 + 3\\sigma_1, \\mu_2 + 3\\sigma_2)]$。\n\n为了求解系数 $\\theta$，我们使用配置法。我们在定义域内的一组离散点（配置节点）上强制执行欧拉方程。这些节点被选为 Chebyshev 多项式根的张量积，具体为一个 $N_k=7$ 点的资本网格和一个 $N_s=5$ 点的对数生产率网格。\n\n**3. 欧拉方程残差与求解**\n\n近似的策略函数 $\\phi(k,s;\\theta)$ 不会精确满足欧拉方程。我们将欧拉方程残差 $\\mathcal{R}(k,s;\\theta)$ 定义为方程左右两边的差：\n$$\n\\mathcal{R}(k,s;\\theta) \\equiv c(k,s;\\theta)^{-\\gamma} - \\beta \\mathbb{E}\\left[c'(k,s;\\theta,s')^{-\\gamma}\\left(\\alpha \\exp(s') k'(k,s;\\theta)^{\\alpha-1} + 1-\\delta\\right)\\right]\n$$\n选择系数 $\\theta$ 以最小化在配置节点集合上的残差平方和。这是一个非线性最小二乘问题：$\\min_{\\theta} \\sum_{i,j} [\\mathcal{R}(k_i, s_j; \\theta)]^2$。\n\n**4. 期望的数值求积**\n\n一项核心任务是期望项的数值评估。问题要求比较两种方案，这两种方案都基于 $N_q=7$ 点的 Gaussian-Hermite 求积法。对于一个通用函数 $g(s')$，在正态分布 $s' \\sim \\mathcal{N}(\\mu, \\sigma^2)$ 下的期望近似为：\n$$\n\\mathbb{E}[g(s')] = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} g(\\mu + \\sqrt{2}\\sigma x) e^{-x^2} dx \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{j=1}^{N_q} w_j g(\\mu + \\sqrt{2}\\sigma x_j)\n$$\n其中 $(x_j, w_j)$ 是标准的 Gaussian-Hermite 求积节点和权重。\n\n- **简化的单正态方案：** 将 $s'$ 的双峰混合分布用一个具有匹配均值和方差的单一正态分布 $\\mathcal{N}(\\mu_{\\text{mix}}, \\sigma_{\\text{mix}}^2)$ 来近似。\n    - $\\mu_{\\text{mix}} = p\\mu_1 + (1-p)\\mu_2$\n    - $\\sigma_{\\text{mix}}^2 = [p\\sigma_1^2 + (1-p)\\sigma_2^2] + p(1-p)(\\mu_1-\\mu_2)^2$\n    然后使用上述公式和参数 $(\\mu_{\\text{mix}}, \\sigma_{\\text{mix}})$ 计算期望。\n\n- **混合校正方案：** 直接使用混合分布的定义来计算期望：\n    $$\n    \\mathbb{E}[g(s')] = p \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_1,\\sigma_1^2)}[g(s')] + (1-p) \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_2,\\sigma_2^2)}[g(s')]\n    $$\n    右侧的两个期望项分别使用各自的 Gaussian-Hermite 求积法进行评估，一个以 $\\mu_1$ 为中心、以 $\\sigma_1$ 为尺度，另一个以 $\\mu_2$ 为中心、以 $\\sigma_2$ 为尺度。\n\n**5. 验证**\n\n我们获得两组系数：通过使用简化求积法求解得到的 $\\theta_{\\text{naive}}$，和通过使用混合校正求积法求解得到的 $\\theta_{\\text{mix}}$。这些解的质量通过在更精细的验证网格（$N_k^{\\text{val}}=13 \\times N_s^{\\text{val}}=9$）上评估欧拉残差的上确界范数来衡量。关键的是，对于两种策略，这个验证残差都是使用精确的**混合校正求积法**来计算的。这个过程隔离了在求解阶段由简化近似所引入的误差。需要报告的量是：\n- $r_{\\text{mix}}$：策略 $\\phi(k,s;\\theta_{\\text{mix}})$ 残差的上确界范数，作为我们的基准。\n- $r_{\\text{naive}\\to\\text{true}}$：策略 $\\phi(k,s;\\theta_{\\text{naive}})$ 残差的上确界范数，显示了当被正确评估时，简化策略的误差。\n- $\\Delta r = r_{\\text{naive}\\to\\text{true}} - r_{\\text{mix}}$：可归因于简化近似方法的超额误差。\n\n这个严谨的过程允许我们对两种处理此类模型中混合分布的求积方案进行定量比较。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.special import expit, logit\nfrom numpy.polynomial import chebyshev, hermite\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    # Fixed structural parameters\n    alpha = 0.33\n    beta = 0.96\n    delta = 0.08\n    gamma = 2.0\n\n    # Numerical approximation parameters\n    d_k = 3\n    d_s = 2\n    N_k = 7\n    N_s = 5\n    N_q = 7\n    N_k_val = 13\n    N_s_val = 9\n\n    test_cases = [\n        # Case A: balanced bimodality\n        {'p': 0.5, 'mu1': -0.1, 'sigma1': 0.05, 'mu2': 0.1, 'sigma2': 0.05},\n        # Case B: asymmetric and more separated\n        {'p': 0.7, 'mu1': -0.2, 'sigma1': 0.08, 'mu2': 0.2, 'sigma2': 0.08},\n        # Case C: degenerate to unimodal\n        {'p': 0.4, 'mu1': 0.0, 'sigma1': 0.07, 'mu2': 0.0, 'sigma2': 0.07},\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        params = {\n            'alpha': alpha, 'beta': beta, 'delta': delta, 'gamma': gamma,\n            **case_params\n        }\n        \n        # Unpack degrees and grid sizes\n        degrees = (d_k, d_s)\n        collocation_grid_sizes = (N_k, N_s)\n        validation_grid_sizes = (N_k_val, N_s_val)\n\n        r_mix, r_naive_to_true, delta_r = solve_case(\n            params, degrees, collocation_grid_sizes, validation_grid_sizes, N_q\n        )\n        all_results.extend([r_mix, r_naive_to_true, delta_r])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef solve_case(params, degrees, collocation_grid_sizes, validation_grid_sizes, N_q):\n    \"\"\"\n    Solves for and validates policies for a single parameter case.\n    \"\"\"\n    # 1. State-space domain\n    k_domain, s_domain = calculate_domains(params)\n\n    # 2. Quadrature nodes and weights for expectation\n    # hermgauss returns nodes/weights for integral with weight e^(-x^2)\n    q_nodes, q_weights = hermite.hermgauss(N_q)\n    q_weights /= np.sqrt(np.pi)  # Adjust for standard normal probability measure\n    \n    # 3. Collocation grid\n    collocation_grid = create_chebyshev_grid(collocation_grid_sizes, k_domain, s_domain)\n\n    # 4. Initial guess for theta (based on deterministic steady state)\n    theta0 = get_initial_theta(params, degrees, k_domain)\n\n    # Arguments for the solver\n    solver_args = (params, degrees, k_domain, s_domain, collocation_grid, q_nodes, q_weights)\n\n    # 5. Solve for theta_mix\n    res_mix = least_squares(\n        euler_residuals, theta0, args=(*solver_args, 'mixture_correct'),\n        method='lm', jac='2-point'\n    )\n    theta_mix = res_mix.x\n\n    # 6. Solve for theta_naive\n    res_naive = least_squares(\n        euler_residuals, theta0, args=(*solver_args, 'naive'),\n        method='lm', jac='2-point'\n    )\n    theta_naive = res_naive.x\n\n    # 7. Validation\n    validation_grid = create_chebyshev_grid(validation_grid_sizes, k_domain, s_domain)\n    val_args = (params, degrees, k_domain, s_domain, validation_grid, q_nodes, q_weights)\n\n    # Evaluate mixture-correct policy with mixture-correct quadrature\n    residuals_mix = euler_residuals(theta_mix, *val_args, 'mixture_correct')\n    r_mix = np.max(np.abs(residuals_mix))\n\n    # Evaluate naive policy with mixture-correct quadrature\n    residuals_naive_true = euler_residuals(theta_naive, *val_args, 'mixture_correct')\n    r_naive_to_true = np.max(np.abs(residuals_naive_true))\n\n    delta_r = r_naive_to_true - r_mix\n\n    return r_mix, r_naive_to_true, delta_r\n\ndef calculate_domains(params):\n    \"\"\"Calculates the state-space domains for k and s.\"\"\"\n    p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n    alpha, beta, delta = params['alpha'], params['beta'], params['delta']\n    \n    # Unconditional mean of productivity z = exp(s)\n    expected_z = p * np.exp(mu1 + s1**2 / 2) + (1 - p) * np.exp(mu2 + s2**2 / 2)\n    \n    # Deterministic steady-state capital k_star\n    k_star = ((alpha * expected_z) / (1 / beta - 1 + delta))**(1 / (1 - alpha))\n    k_domain = [0.75 * k_star, 1.25 * k_star]\n    \n    # Domain for s\n    s_min = min(mu1 - 3 * s1, mu2 - 3 * s2)\n    s_max = max(mu1 + 3 * s1, mu2 + 3 * s2)\n    s_domain = [s_min, s_max]\n    \n    return k_domain, s_domain\n\ndef get_initial_theta(params, degrees, k_domain):\n    \"\"\"Computes an informed initial guess for theta.\"\"\"\n    p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n    alpha, beta, delta = params['alpha'], params['beta'], params['delta']\n    \n    expected_z = p * np.exp(mu1 + s1**2 / 2) + (1 - p) * np.exp(mu2 + s2**2 / 2)\n    k_star = ((alpha * expected_z) / (1 / beta - 1 + delta))**(1 / (1 - alpha))\n    y_star = expected_z * k_star**alpha\n    phi_star = k_star / (y_star + (1 - delta) * k_star)\n    \n    d_k, d_s = degrees\n    num_coeffs = (d_k + 1) * (d_s + 1)\n    theta0 = np.zeros(num_coeffs)\n    theta0[0] = logit(phi_star)\n    return theta0\n\ndef cheb_transform(x, domain):\n    \"\"\"Maps points from a domain to [-1, 1].\"\"\"\n    return 2 * (x - domain[0]) / (domain[1] - domain[0]) - 1\n\ndef cheb_basis_tensor(k_hat, s_hat, degrees):\n    \"\"\"Computes a tensor product Chebyshev basis matrix.\"\"\"\n    d_k, d_s = degrees\n    basis_k = chebyshev.chebvander(k_hat, d_k)\n    basis_s = chebyshev.chebvander(s_hat, d_s)\n    # Reshape for broadcasting and then combine\n    # B[i, j, :] is the basis vector for grid point (i, j)\n    B = basis_k[:, np.newaxis, :] * basis_s[np.newaxis, :, :]\n    # Reshape B to be (Nk * Ns, N_coeffs)\n    return B.reshape(-1, (d_k + 1) * (d_s + 1))\n\n\ndef create_chebyshev_grid(grid_sizes, k_domain, s_domain):\n    \"\"\"Creates a tensor product grid of Chebyshev nodes.\"\"\"\n    N_k, N_s = grid_sizes\n    # Use chebpts1 for nodes including endpoints - common in collocation\n    k_nodes_hat = chebyshev.chebpts1(N_k) # in [-1, 1]\n    s_nodes_hat = chebyshev.chebpts1(N_s) # in [-1, 1]\n    \n    k_grid = (k_nodes_hat + 1) / 2 * (k_domain[1] - k_domain[0]) + k_domain[0]\n    s_grid = (s_nodes_hat + 1) / 2 * (s_domain[1] - s_domain[0]) + s_domain[0]\n    \n    return k_grid, s_grid\n\ndef get_policy(k, s, theta, params, degrees, k_domain, s_domain):\n    \"\"\"Computes policy (phi), consumption (c), and next-period capital (k_prime).\"\"\"\n    k_hat = cheb_transform(k, k_domain)\n    s_hat = cheb_transform(s, s_domain)\n    \n    d_k, d_s = degrees\n    basis_k = chebyshev.chebvander(k_hat.flatten(), d_k)\n    basis_s = chebyshev.chebvander(s_hat.flatten(), d_s)\n    \n    # Manual tensor product broadcasting\n    flat_basis_tensor = (basis_k[:, :, np.newaxis] * basis_s[:, np.newaxis, :]).reshape(len(k.flatten()), -1)\n    \n    # Savings rate\n    phi = expit(flat_basis_tensor @ theta).reshape(k.shape)\n\n    z = np.exp(s)\n    resources = z * k**params['alpha'] + (1 - params['delta']) * k\n    \n    c = (1 - phi) * resources\n    k_prime = phi * resources\n    \n    return c, k_prime\n\ndef euler_residuals(theta, params, degrees, k_domain, s_domain, grid, q_nodes, q_weights, quadrature_scheme):\n    \"\"\"\n    Computes the Euler equation residuals over a grid.\n    Vectorized for efficiency.\n    \"\"\"\n    k_grid, s_grid = grid\n    K, S = np.meshgrid(k_grid, s_grid, indexing='ij')\n\n    alpha, beta, delta, gamma = params['alpha'], params['beta'], params['delta'], params['gamma']\n\n    # Current period values\n    c_t, k_prime = get_policy(K, S, theta, params, degrees, k_domain, s_domain)\n    marginal_utility_t = c_t**(-gamma)\n\n    # Expected future values\n    def get_integrand(s_prime_nodes):\n        # s_prime_nodes is a vector of quadrature points for s'\n        # k_prime is an Nk x Ns matrix\n        # Need to evaluate policy at all (k_prime, s_prime) pairs\n        num_q_nodes = len(s_prime_nodes)\n        \n        # Reshape for broadcasting\n        k_prime_flat = k_prime.flatten() # (Nk*Ns)\n        k_prime_rep = np.tile(k_prime_flat, (num_q_nodes, 1)).T # (Nk*Ns, Nq)\n        s_prime_rep = np.tile(s_prime_nodes, (len(k_prime_flat), 1)) # (Nk*Ns, Nq)\n        \n        c_prime, _ = get_policy(k_prime_rep, s_prime_rep, theta, params, degrees, k_domain, s_domain)\n        \n        marginal_utility_prime = c_prime**(-gamma)\n        \n        mpk_prime = alpha * np.exp(s_prime_rep) * k_prime_rep**(alpha - 1) + (1 - delta)\n        \n        return (marginal_utility_prime * mpk_prime).reshape(K.shape[0], K.shape[1], -1)\n\n    if quadrature_scheme == 'mixture_correct':\n        p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n        \n        s_prime_nodes1 = mu1 + np.sqrt(2) * s1 * q_nodes\n        integrand1 = get_integrand(s_prime_nodes1)\n        E1 = np.sum(integrand1 * q_weights, axis=2)\n        \n        s_prime_nodes2 = mu2 + np.sqrt(2) * s2 * q_nodes\n        integrand2 = get_integrand(s_prime_nodes2)\n        E2 = np.sum(integrand2 * q_weights, axis=2)\n        \n        E_term = p * E1 + (1 - p) * E2\n        \n    elif quadrature_scheme == 'naive':\n        p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n        mu_mix = p * mu1 + (1 - p) * mu2\n        var_mix = p * s1**2 + (1 - p) * s2**2 + p * (1 - p) * (mu1 - mu2)**2\n        s_mix = np.sqrt(var_mix)\n        \n        s_prime_nodes_mix = mu_mix + np.sqrt(2) * s_mix * q_nodes\n        integrand_mix = get_integrand(s_prime_nodes_mix)\n        E_term = np.sum(integrand_mix * q_weights, axis=2)\n\n    else:\n        raise ValueError(\"Invalid quadrature scheme.\")\n\n    residuals = marginal_utility_t - beta * E_term\n    return residuals.flatten()\n\n\nif __name__ == '__main__':\n    solve()\n\n```"}]}