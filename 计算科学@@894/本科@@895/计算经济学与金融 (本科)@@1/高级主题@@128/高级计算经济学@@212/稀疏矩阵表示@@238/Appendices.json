{"hands_on_practices": [{"introduction": "理论是基础，但真正的理解源于实践。本练习将带你深入探究稀疏矩阵最核心的优势——内存效率，通过在一个典型的投资组合优化场景中，量化分析并比较 DOK（键字典）和 CSR（压缩稀疏行）这两种格式的内存占用。这个实践将帮助你把抽象的数据结构知识，转化为对存储成本进行具体计算和权衡的能力。[@problem_id:2432973]", "id": "2432973", "problem": "在计算经济学和金融学中，您正在为一个带有行业限制的长仓投资组合选择问题建立线性约束模型。现有 $N$ 种资产和 $S$ 个行业。每种资产都恰好属于一个行业。设 $x \\in \\mathbb{R}^{N}$ 表示资产决策变量，$y \\in \\mathbb{R}^{S}$ 表示二元行业使用指示符。投资组合持有的资产不超过 $k$ 个行业的约束，由一个具有以下结构的稀疏线性系统表示：\n1. 对于每个行业 $s \\in \\{1,\\dots,S\\}$，约束为\n$$\\sum_{i \\in \\text{sector}(s)} 1 \\cdot x_i - M \\cdot y_s \\le 0,$$\n其中 $M$ 是任意正常数，且每种资产 $i$ 恰好以系数 $1$ 出现在一个这样的总和中。\n2. 对活跃行业数量的上限约束，\n$$\\sum_{s=1}^{S} 1 \\cdot y_s \\le k.$$\n将这些约束组合成一个单一的稀疏约束矩阵 $A \\in \\mathbb{R}^{(S+1)\\times (N+S)}$，该矩阵作用于串联向量 $(x,y) \\in \\mathbb{R}^{N+S}$，其右端向量 $b \\in \\mathbb{R}^{S+1}$ 仅在最后一个条目中包含 $k$。在这些条件下，$A$ 中的非零条目数为\n$$\\mathrm{nnz} = N + 2S,$$\n因为对于 $x$，在 $S$ 个行业行中有 $N$ 个单位系数；在这些相同的行中，对于 $y$ 变量有 $S$ 个系数；在最后一行中，对于 $y$ 变量有 $S$ 个单位系数。\n\n您将比较矩阵 $A$ 及其右端向量 $b$ 的两种稀疏表示的内存使用情况（以字节为单位）：\n- 键字典 (Dictionary of Keys, DOK)：将每个非零条目存储为一个三元组 $(\\text{row}, \\text{col}, \\text{value})$，其中索引使用 $64$ 位有符号整数，值使用 $64$ 位浮点数。同时，将右端向量 $b$ 存储为 $64$ 位浮点数条目。假设除了这些基本字段外没有额外的开销。\n- 压缩稀疏行 (Compressed Sparse Row, CSR)：为 $A$ 存储三个数组：数据数组（长度为 $\\mathrm{nnz}$ 的 $64$ 位浮点数）、列索引数组（长度为 $\\mathrm{nnz}$ 的 $64$ 位有符号整数）和行指针数组（长度为 $(S+1)+1$ 的 $64$ 位有符号整数）。同时，将右端向量 $b$ 存储为 $64$ 位浮点数条目。\n\n所有索引字段每个条目使用 $8$ 字节，所有浮点字段每个条目也使用 $8$ 字节。$M$ 的大小不影响内存使用。$k$ 的值只影响 $b$ 中一个条目的数值，因此不改变存储条目的数量。\n\n任务：对于每个测试用例 $(N,S,k)$，根据上述模型计算键字典 (DOK) 和压缩稀疏行 (CSR) 表示所需的精确总内存（以字节为单位），包括 $b$ 的存储。然后，为每个测试用例计算比率\n$$r = \\frac{\\text{bytes}_{\\mathrm{DOK}}}{\\text{bytes}_{\\mathrm{CSR}}},$$\n该比率为无量纲。报告每个 $r$ 值，四舍五入到三位小数。\n\n测试集（每个元组为 $(N,S,k)$，其中 $N \\in \\mathbb{Z}_{\\ge 0}$, $S \\in \\mathbb{Z}_{\\ge 1}$, $k \\in \\{0,1,\\dots,S\\}$）：\n- $(500, 10, 3)$\n- $(10000, 100, 5)$\n- $(0, 8, 0)$\n- $(1000, 1, 1)$\n- $(50, 200, 5)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如，`\"[r_1,r_2,r_3,r_4,r_5]\"`，其中每个 $r_j$ 均按要求四舍五入到三位小数。", "solution": "所提出的问题定义明确，具有科学依据，并包含唯一解所需的所有信息。我们将系统地推导指定稀疏矩阵表示的内存需求。\n\n问题要求比较线性约束系统 $Ax \\le b$ 的键字典 (Dictionary of Keys, DOK) 和压缩稀疏行 (Compressed Sparse Row, CSR) 格式之间的内存使用情况。该系统由 $N$ 种资产和 $S$ 个行业定义。约束矩阵 $A$ 的维度为 $(S+1) \\times (N+S)$，右端向量 $b$ 的维度为 $S+1$。$A$ 中的非零条目数由 $\\mathrm{nnz} = N + 2S$ 给出。所有索引字段都存储为 $64$ 位（$8$ 字节）整数，所有值字段都存储为 $64$ 位（$8$ 字节）浮点数。\n\n首先，我们计算键字典 (DOK) 表示所需的总内存，记为 $\\text{bytes}_{\\mathrm{DOK}}$。在 DOK 格式中，矩阵 $A$ 的每个非零条目（共 $\\mathrm{nnz}$ 个）都存储为一个三元组 $(\\text{row}, \\text{col}, \\text{value})$。该三元组的每个分量所需内存为：行索引 $8$ 字节，列索引 $8$ 字节，值 $8$ 字节。因此，存储一个非零条目所需的内存为 $8 + 8 + 8 = 24$ 字节。矩阵 $A$ 的总内存是非零条目数与每个条目内存的乘积：\n$$ \\text{Mem}_{\\mathrm{DOK}}(A) = \\mathrm{nnz} \\times 24 = (N + 2S) \\times 24 = 24N + 48S $$\n右端向量 $b$ 有 $S+1$ 个条目，每个条目都是一个 $8$ 字节的浮点数。其内存占用为：\n$$ \\text{Mem}(b) = (S+1) \\times 8 = 8S + 8 $$\nDOK 表示的总内存是矩阵 $A$ 和向量 $b$ 的内存之和：\n$$ \\text{bytes}_{\\mathrm{DOK}} = \\text{Mem}_{\\mathrm{DOK}}(A) + \\text{Mem}(b) = (24N + 48S) + (8S + 8) = 24N + 56S + 8 $$\n\n接下来，我们计算压缩稀疏行 (CSR) 表示的总内存，记为 $\\text{bytes}_{\\mathrm{CSR}}$。矩阵 $A$ 的 CSR 格式由三个数组组成：用于存储值的 `data` 数组、`column indices`（列索引）数组和 `row pointer`（行指针）数组。`data` 数组存储 $\\mathrm{nnz}$ 个非零值，`column indices` 数组存储这些值各自的列索引。这两个数组的长度均为 $\\mathrm{nnz}$，并使用 $8$ 字节的元素（分别为 $64$ 位浮点数和 $64$ 位整数）。`row pointer` 数组指定了每行在其他两个数组中的起始位置；其长度为行数加一，即 $(S+1)+1 = S+2$，其元素为 $8$ 字节整数。$A$ 在 CSR 格式下的内存为：\n$$ \\text{Mem}_{\\mathrm{CSR}}(A) = \\underbrace{(N+2S) \\times 8}_{\\text{data}} + \\underbrace{(N+2S) \\times 8}_{\\text{indices}} + \\underbrace{(S+2) \\times 8}_{\\text{row pointer}} $$\n$$ \\text{Mem}_{\\mathrm{CSR}}(A) = 16(N+2S) + 8(S+2) = 16N + 32S + 8S + 16 = 16N + 40S + 16 $$\n向量 $b$ 的存储方式与前一种情况相同，需要 $\\text{Mem}(b) = 8S + 8$ 字节。CSR 表示的总内存是矩阵 $A$ 和向量 $b$ 的内存之和：\n$$ \\text{bytes}_{\\mathrm{CSR}} = \\text{Mem}_{\\mathrm{CSR}}(A) + \\text{Mem}(b) = (16N + 40S + 16) + (8S + 8) = 16N + 48S + 24 $$\n\n最后，我们计算比率 $r = \\frac{\\text{bytes}_{\\mathrm{DOK}}}{\\text{bytes}_{\\mathrm{CSR}}}$。代入推导出的表达式：\n$$ r = \\frac{24N + 56S + 8}{16N + 48S + 24} $$\n该表达式可以通过分子分母同除以最大公约数 $8$ 来简化：\n$$ r = \\frac{3N + 7S + 1}{2N + 6S + 3} $$\n这个最终公式用于计算每个测试用例所需的比率。正如问题中所述，$k$ 和 $M$ 参数确实对内存计算没有影响。比率 $r$ 仅取决于资产数量 $N$ 和行业数量 $S$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the ratio of memory usage between DOK and CSR sparse representations\n    for a series of test cases based on a portfolio optimization problem.\n    \"\"\"\n    test_cases = [\n        # Each tuple is (N, S, k)\n        (500, 10, 3),\n        (10000, 100, 5),\n        (0, 8, 0),\n        (1000, 1, 1),\n        (50, 200, 5)\n    ]\n\n    results = []\n    for case in test_cases:\n        N, S, k = case  # The parameter k is not used in the memory calculation.\n\n        # Derived formula for the ratio r = bytes_DOK / bytes_CSR\n        # r = (24*N + 56*S + 8) / (16*N + 48*S + 24)\n        # Simplified formula by dividing numerator and denominator by 8:\n        # r = (3*N + 7*S + 1) / (2*N + 6*S + 3)\n        numerator = 3 * N + 7 * S + 1\n        denominator = 2 * N + 6 * S + 3\n        \n        # Based on problem constraints (N>=0, S>=1), the denominator is always positive.\n        # min denominator: 2*0 + 6*1 + 3 = 9. So no division by zero check is needed.\n        ratio = numerator / denominator\n        \n        # Format the result to three decimal places.\n        results.append(f\"{ratio:.3f}\")\n\n    # Print the final output in the specified format: \"[r1,r2,r3,r4,r5]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "在现实世界的金融分析中，模型需要不断演化，例如在投资组合中加入新的资产。此练习模拟了这一动态过程，要求你为一个已有的协方差矩阵添加新的资产，并在此过程中利用 LIL（列表的列表）格式的优势。通过实践，你将体会到 LIL 格式为何是增量构建或修改稀疏矩阵的理想选择，并理解“为任务选择正确工具”这一核心计算思维。[@problem_id:2432991]", "id": "2432991", "problem": "您将获得一个以列表的列表 (List of Lists, LIL) 格式存储的、关于交易资产的预先存在的稀疏协方差矩阵。LIL 是一种稀疏矩阵存储格式，它为每一行保存一个列索引列表及对应的非零值。设预先存在的协方差矩阵表示为 $\\Sigma \\in \\mathbb{R}^{n \\times n}$，代表 $n$ 个现有资产。您的任务是添加 $k$ 个新资产。为此，您将获得交叉协方差块 $C \\in \\mathbb{R}^{n \\times k}$ 和新资产内部的协方差块 $D \\in \\mathbb{R}^{k \\times k}$。增广协方差矩阵 $S \\in \\mathbb{R}^{(n+k) \\times (n+k)}$ 分块定义如下：\n$$\nS \\;=\\; \\begin{bmatrix}\n\\Sigma & C \\\\\nC^{\\top} & D\n\\end{bmatrix}.\n$$\n所有矩阵均为实值矩阵。您必须仅使用所提供的 $\\Sigma$、$C$ 和 $D$ 的非零条目，将 $S$ 构建为 LIL (List of Lists) 格式的稀疏矩阵。每个输入矩阵块都由一个三元组 $(i,j,v)$ 列表指定，表示第 $i$ 行第 $j$ 列的条目等于 $v$，索引从零开始。为 $\\Sigma$ 提供的三元组明确地包含了所有非零条目（包括其对称项），为 $D$ 提供的三元组也明确地包含了所有非零条目（包括其对称项）。为 $C$ 提供的三元组仅指定 $C$ 的非零条目（而不指定 $C^{\\top}$ 的）。\n\n对于下方的每个测试用例，请根据给定的 $\\Sigma$、$C$ 和 $D$ 构建 $S$，并计算以下三个输出：\n- 您构建的 $S$（转换为密集数组）与通过 $\\Sigma$、$C$ 和 $D$ 分块密集组装的矩阵之间的差值的弗罗贝尼乌斯范数，记为 $f = \\lVert S_{\\text{sparse}} - S_{\\text{dense}} \\rVert_{F}$。\n- 一个布尔值 $b$，指示 $S$ 是否严格对称，即 $S = S^{\\top}$ 是否逐项成立。\n- 整数 $m$，等于 $S$ 中存储的非零条目数量。\n\n您的程序必须为每个测试用例实现这些计算，并生成单行输出。该输出包含所有测试用例的结果列表，格式为方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个形如 $[f,b,m]$ 的列表。最终输出的格式必须类似于 $[[f_1,b_1,m_1],[f_2,b_2,m_2],\\dots]$，所有值需按照下面测试用例的顺序列出。\n\n测试套件：\n- 测试用例 $1$：\n  - $n = 4$, $k = 3$。\n  - $\\Sigma$ 的非零三元组：\n    $(0,0,4)$, $(1,1,5)$, $(2,2,6)$, $(3,3,7)$, $(0,1,1)$, $(1,0,1)$, $(1,2,2)$, $(2,1,2)$, $(2,3,3)$, $(3,2,3)$。\n  - $C$ 的非零三元组：\n    $(0,0,1)$, $(1,1,2)$, $(2,2,3)$, $(3,0,-1)$。\n  - $D$ 的非零三元组：\n    $(0,0,2)$, $(1,1,3)$, $(2,2,4)$, $(0,1,1)$, $(1,0,1)$, $(1,2,1)$, $(2,1,1)$。\n- 测试用例 $2$：\n  - $n = 3$, $k = 0$。\n  - $\\Sigma$ 的非零三元组：\n    $(0,0,2)$, $(1,1,3)$, $(2,2,4)$, $(0,2,1)$, $(2,0,1)$。\n  - $C$ 和 $D$ 没有条目。\n- 测试用例 $3$：\n  - $n = 0$, $k = 2$。\n  - $\\Sigma$ 没有条目。\n  - $C$ 没有条目。\n  - $D$ 的非零三元组：\n    $(0,0,5)$, $(1,1,6)$, $(0,1,2)$, $(1,0,2)$。\n- 测试用例 $4$：\n  - $n = 5$, $k = 2$。\n  - $\\Sigma$ 的非零三元组：\n    $(0,0,10)$, $(1,1,20)$, $(2,2,30)$, $(3,3,40)$, $(4,4,50)$。\n  - $C$ 的非零三元组：\n    $(4,1,7)$。\n  - $D$ 的非零三元组：\n    $(0,0,8)$, $(1,1,9)$。\n\n您的程序不得读取任何输入，且必须将测试套件内置于代码中。最终输出必须是一个单行字符串，表示一个包含四个列表的列表，每个测试用例对应一个列表。每个内部列表按顺序包含弗罗贝尼乌斯范数 $f$（浮点数）、对称性标志 $b$（布尔值）和非零条目数 $m$（整数）。不涉及任何物理单位，所有结果均为无量纲数和布尔值。", "solution": "该问题要求从一个预先存在的稀疏协方差矩阵 $\\Sigma \\in \\mathbb{R}^{n \\times n}$ 和 $k$ 个新资产的协方差块（即交叉协方差 $C \\in \\mathbb{R}^{n \\times k}$ 和内部协方差 $D \\in \\mathbb{R}^{k \\times k}$）构建一个增广稀疏协方差矩阵 $S \\in \\mathbb{R}^{(n+k) \\times (n+k)}$。该增广矩阵的块结构定义如下：\n$$\nS \\;=\\; \\begin{bmatrix}\n\\Sigma & C \\\\\nC^{\\top} & D\n\\end{bmatrix}\n$$\n输入矩阵以代表其非零条目的三元组 $(i, j, v)$ 列表形式提供。任务是使用列表的列表 (LIL) 格式构建稀疏矩阵 $S$，然后计算用于验证和分析的三个量：构建误差的弗罗贝尼乌斯范数 $f$、对称性布尔标志 $b$ 以及非零条目计数 $m$。\n\n这个问题在计算上是良定义的，并基于线性代数和数值分析的原理。构建矩阵 $S$ 的过程是确定性的，并基于所提供的块结构。其分步方法如下。\n\n首先，初始化一个维度为 $(n+k) \\times (n+k)$ 的空稀疏矩阵 $S$。如题目所述，LIL 格式因其能高效地支持元素的增量插入，非常适合此构建阶段。`scipy.sparse.lil_matrix` 类提供了此功能。\n\n填充 $S$ 的过程是通过将每个输入块的局部索引映射到增广矩阵中对应的全局索引来完成的。\n- 对于为 $\\Sigma$ 块提供的每个非零元素 $(i, j, v)$，将 $S$ 的第 $i$ 行第 $j$ 列的条目设为值 $v$。索引 $(i, j)$ 的范围是 $[0, n-1] \\times [0, n-1]$。\n- 对于为 $C$ 块提供的每个非零元素 $(i, j, v)$，需要在 $S$ 中设置两个条目。将元素 $S_{i, n+j}$ 设为 $v$，以填充右上方的 $C$ 块。同时，为确保协方差矩阵的对称性，也应将 $C^{\\top}$ 块中的对应元素 $S_{n+j, i}$ 设为 $v$。索引范围为 $(i, j) \\in [0, n-1] \\times [0, k-1]$。\n- 对于为 $D$ 块提供的每个非零元素 $(i, j, v)$，将条目 $S_{n+i, n+j}$ 设为 $v$。索引 $(i, j)$ 的范围是 $[0, k-1] \\times [0, k-1]$。\n\n在构建稀疏矩阵（我们记为 $S_{\\text{sparse}}$）后，计算指定的度量指标。\n\n1.  弗罗贝尼乌斯范数 $f = \\lVert S_{\\text{sparse}} - S_{\\text{dense}} \\rVert_{F}$ 是衡量稀疏构建准确性的指标。为计算此值，需使用 `numpy.ndarray` 创建一个密集的参考矩阵 $S_{\\text{dense}}$。该矩阵使用与 $S_{\\text{sparse}}$ 相同的逻辑进行填充。然后，使用 `.toarray()` 方法将稀疏矩阵转换为密集数组，再计算差分矩阵的弗罗贝尼乌斯范数。$f=0.0$ 的结果表明构建完全准确。\n\n2.  对称性属性 $b$ 通过检查 $S = S^{\\top}$ 是否成立来评估。为 $\\Sigma$ 和 $D$ 提供的三元组是明确对称的，而通过 $C$ 构建 $C^{\\top}$ 块确保了非对角块的对称性。这种构建方法应产生一个对称矩阵 $S$。在计算上，可通过计算稀疏矩阵与其转置之差来验证这一点。为实现高效运算，首先将 LIL 矩阵转换为压缩稀疏行 (CSR) 格式。当且仅当 $S$ 是对称的，结果差分矩阵 $(S_{\\text{csr}} - S_{\\text{csr}}^{\\top})$ 中的非零元素数量才恰好为 $0$。布尔值 $b$ 即为此检查的结果。\n\n3.  存储的非零条目数 $m$ 是稀疏矩阵的一个基本属性。该值可通过其 `.nnz` 属性直接从构建的稀疏矩阵对象中获取。该计数应等于输入块非零条目数的总和，同时要考虑到 $C$ 和 $C^{\\top}$ 是从同一源三元组填充的，这实际上使来自 $C$ 的贡献加倍。具体而言，$m = \\text{nnz}(\\Sigma) + 2 \\cdot \\text{nnz}(C) + \\text{nnz}(D)$，前提是假设没有因重叠而使零条目变为非零。\n\n实现将对问题陈述中提供的每个测试用例遵循此逻辑。每个用例的结果 $[f, b, m]$ 将被收集并按要求格式化为单个字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\n\ndef solve():\n    \"\"\"\n    Solves the augmented sparse covariance matrix problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 4, \"k\": 3,\n            \"sigma\": [\n                (0, 0, 4), (1, 1, 5), (2, 2, 6), (3, 3, 7), (0, 1, 1), \n                (1, 0, 1), (1, 2, 2), (2, 1, 2), (2, 3, 3), (3, 2, 3)\n            ],\n            \"c\": [(0, 0, 1), (1, 1, 2), (2, 2, 3), (3, 0, -1)],\n            \"d\": [\n                (0, 0, 2), (1, 1, 3), (2, 2, 4), (0, 1, 1), \n                (1, 0, 1), (1, 2, 1), (2, 1, 1)\n            ],\n        },\n        {\n            \"n\": 3, \"k\": 0,\n            \"sigma\": [(0, 0, 2), (1, 1, 3), (2, 2, 4), (0, 2, 1), (2, 0, 1)],\n            \"c\": [],\n            \"d\": [],\n        },\n        {\n            \"n\": 0, \"k\": 2,\n            \"sigma\": [],\n            \"c\": [],\n            \"d\": [(0, 0, 5), (1, 1, 6), (0, 1, 2), (1, 0, 2)],\n        },\n        {\n            \"n\": 5, \"k\": 2,\n            \"sigma\": [(0, 0, 10), (1, 1, 20), (2, 2, 30), (3, 3, 40), (4, 4, 50)],\n            \"c\": [(4, 1, 7)],\n            \"d\": [(0, 0, 8), (1, 1, 9)],\n        },\n    ]\n\n    def process_case(n, k, sigma_triplets, c_triplets, d_triplets):\n        \"\"\"\n        Constructs the augmented sparse matrix and computes the required metrics.\n        \n        Args:\n            n (int): Number of existing assets.\n            k (int): Number of new assets.\n            sigma_triplets (list): Nonzero entries of Sigma.\n            c_triplets (list): Nonzero entries of C.\n            d_triplets (list): Nonzero entries of D.\n            \n        Returns:\n            list: A list containing [f, b, m].\n        \"\"\"\n        dim = n + k\n\n        # Initialize sparse LIL matrix and dense NumPy array\n        S_sparse = lil_matrix((dim, dim), dtype=np.float64)\n        S_dense = np.zeros((dim, dim), dtype=np.float64)\n\n        # Populate Sigma block\n        for r, c, v in sigma_triplets:\n            S_sparse[r, c] = v\n            S_dense[r, c] = v\n\n        # Populate C and C.T blocks\n        for r, c, v in c_triplets:\n            S_sparse[r, n + c] = v      # C block\n            S_sparse[n + c, r] = v      # C.T block\n            S_dense[r, n + c] = v\n            S_dense[n + c, r] = v\n\n        # Populate D block\n        for r, c, v in d_triplets:\n            S_sparse[n + r, n + c] = v\n            S_dense[n + r, n + c] = v\n\n        # Metric f: Frobenius norm of the difference\n        f = np.linalg.norm(S_sparse.toarray() - S_dense, 'fro')\n\n        # Metric b: Symmetry check\n        # Convert to CSR for efficient arithmetic\n        S_csr = S_sparse.tocsr()\n        b = (S_csr - S_csr.T).nnz == 0\n\n        # Metric m: Number of stored nonzero entries\n        m = S_sparse.nnz\n\n        return [f, b, m]\n\n    results = []\n    for case in test_cases:\n        result = process_case(\n            case[\"n\"], case[\"k\"], case[\"sigma\"], case[\"c\"], case[\"d\"]\n        )\n        results.append(result)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res in results:\n        f, b, m = res\n        b_str = 'true' if b else 'false'\n        formatted_results.append(f'[{f},{b_str},{m}]')\n    \n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    print(final_output_str)\n\nsolve()\n```"}, {"introduction": "掌握了稀疏矩阵的表示和构建方法后，我们来看其最终的应用目标：解决大规模的计算问题。本练习将稀疏矩阵技术应用于网络科学，要求你通过求解一个大型稀疏线性系统 $(I - \\alpha A^{\\top})x = \\mathbf{1}$，来计算供应链网络中各节点的卡茨中心性。这个实践完美展示了稀疏矩阵的威力——它使得对复杂经济系统进行建模和分析成为可能，让我们能从庞大的数据中高效地提取关键洞见。[@problem_id:2432966]", "id": "2432966", "problem": "您会得到由邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示的有向加权供应链网络，其中 $A_{ij}$ 是从公司 $i$ 到公司 $j$ 的权重。公司的卡茨中心性 (Katz centrality) $x \\in \\mathbb{R}^{n}$ 被定义为以下线性系统的唯一解：\n$$\n\\left(I - \\alpha A^{\\top}\\right) x = \\mathbf{1},\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵，$\\alpha \\in \\mathbb{R}$ 满足 $\\alpha \\ge 0$，$A^{\\top}$ 是 $A$ 的转置，$\\mathbf{1}$ 是 $n$ 维的全1向量。如果 $\\alpha < 1/\\rho(A)$（其中 $\\rho(A)$ 是 $A$ 的谱半径），则解的存在性和唯一性得到保证。\n\n您的任务是编写一个完整、可运行的程序，为几个指定的稀疏网络计算卡茨中心性向量 $x$。节点由从 $0$ 到 $n-1$ 的整数标记。每个网络由一个元组 $(n,\\ \\text{边列表},\\ \\alpha)$ 指定，其中边列表是一组三元组 $(i,j,w)$，其中 $i,j \\in \\{0,\\dots,n-1\\}$ 且 $w \\in \\mathbb{R}$，表示一条从 $i$ 到 $j$ 的权重为 $w$ 的有向边。邻接矩阵 $A$ 由这些边定义，任何未列出的条目都为零。\n\n计算下面每种情况的 $x$，并报告每个向量，其中每个分量都四舍五入到 $6$ 位小数。\n\n测试套件：\n- 案例1（通用无环供应链，正常路径）：\n  - $n = 4$\n  - 边：$(0,1,0.2)$, $(0,2,0.1)$, $(1,2,0.3)$, $(1,3,0.4)$, $(2,3,0.5)$\n  - $\\alpha = 0.85$\n- 案例2（边界条件 $\\alpha = 0$）：\n  - $n = 3$\n  - 边：$(0,1,1)$, $(1,2,1)$, $(2,0,1)$\n  - $\\alpha = 0$\n- 案例3（接近可逆性边界但可行）：\n  - $n = 3$\n  - 边：$(0,1,1)$, $(1,2,1)$, $(2,0,1)$\n  - $\\alpha = 0.99$\n- 案例4（边缘情况：零矩阵）：\n  - $n = 5$\n  - 边：无\n  - $\\alpha = 0.7$\n\n数值精度要求：每个解向量的每个分量相对于真实解的绝对误差必须小于 $10^{-6}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含解向量的列表（每个测试案例一个）。该列表是一个用方括号括起来的、由逗号分隔的单一列表，其中每个向量本身也是一个用方括号括起来的、由逗号分隔的列表，每个数字都是一个小数点后恰好有 $6$ 位的小数。外部列表中的向量顺序必须与上面列出的测试案例的顺序相匹配。", "solution": "所提出的问题是线性代数在网络分析中的一个直接应用。我们的任务是为一系列网络计算卡茨中心性向量 $x$。中心性向量 $x$ 被定义为以下线性系统的解：\n$$\n\\left(I - \\alpha A^{\\top}\\right) x = \\mathbf{1}\n$$\n在此，$I$ 是 $n \\times n$ 的单位矩阵，$A$ 是网络的邻接矩阵，$\\alpha$ 是一个非负的标量衰减因子，$\\mathbf{1}$ 是 $n$ 维的全1向量。矩阵 $A^{\\top}$ 是 $A$ 的转置。在条件 $\\alpha < 1/\\rho(A)$ 下，可以保证存在唯一的非负解 $x$ ，其中 $\\rho(A)$ 是 $A$ 的谱半径。题目说明保证了所有测试案例都满足此条件。\n\n任务的核心是求解这个线性方程组，可以表示为 $M x = b$，其中系数矩阵是 $M = I - \\alpha A^{\\top}$，右侧向量是 $b = \\mathbf{1}$。\n\n网络被描述为稀疏的，这意味着邻接矩阵 $A$ 包含绝大多数的零条目。为了计算效率，必须使用为稀疏矩阵设计的数据结构，而不是密集的 $n \\times n$ 数组。Python中的 `scipy.sparse` 库提供了必要的工具。\n\n对于每个测试案例 $(n, \\text{边列表}, \\alpha)$，算法按以下步骤进行：\n\n1.  **构建矩阵 $M = I - \\alpha A^{\\top}$**：\n    *   首先，我们以稀疏格式构建邻接矩阵的转置矩阵 $A^{\\top}$。输入的边列表以三元组 $(i, j, w)$ 的形式提供 $A$ 的条目，这对应于矩阵元素 $A_{ij} = w$。因此，对于转置矩阵 $A^{\\top}$，这对应于元素 $(A^{\\top})_{ji} = w$。我们可以通过向稀疏矩阵构造函数（例如 `scipy.sparse.coo_matrix`）提供行索引、列索引和数据值的列表来高效地组合 $A^{\\top}$。\n    *   使用像 `scipy.sparse.identity(n)` 这样的函数来构造大小为 $n \\times n$ 的单位矩阵 $I$。\n    *   然后，矩阵 $M$ 通过稀疏矩阵运算 $I - \\alpha \\cdot A^{\\top}$ 计算得出。`SciPy` 为其稀疏矩阵格式正确处理标量乘法和减法。\n\n2.  **构建向量 $b$**：\n    *   向量 $b = \\mathbf{1}$ 是一个 $n$ 维向量，其中每个分量都是 $1$。这可以使用 `numpy.ones(n)` 创建。\n\n3.  **求解线性系统 $M x = b$**：\n    *   准备好稀疏矩阵 $M$ 和密集向量 $b$ 后，我们使用专门的稀疏线性求解器来求解 $x$。`scipy.sparse.linalg.spsolve(M, b)` 函数就是为此目的设计的。它采用高效的数值方法（例如基于稀疏矩阵LU分解的直接方法），避免了反转密集矩阵时高昂的内存和计算成本。\n\n4.  **处理特殊情况**：\n    *   考虑边界条件是有益的。\n    *   对于案例2，其中 $\\alpha=0$，方程简化为 $(I - 0 \\cdot A^{\\top}) x = \\mathbf{1}$，即 $I x = \\mathbf{1}$。解显然是 $x = \\mathbf{1}$。\n    *   对于案例4，其中边列表为空，邻接矩阵 $A$ 是零矩阵。因此，$A^{\\top}$ 也是零矩阵。方程变为 $(I - \\alpha \\cdot 0) x = \\mathbf{1}$，这同样是 $I x = \\mathbf{1}$ 并得出 $x = \\mathbf{1}$，无论 $\\alpha$ 的值是多少。\n    *   在这两种情况下，稀疏求解器的计算机制都是不必要的，结果可以直接给出。我们的实现将识别这些简单情况。\n\n对于一般情况，如案例1和案例3，需要完整的数值计算过程。对于案例1，矩阵 $A$ 是无环的，导致 $A^{\\top}$ 是一个幂零矩阵。矩阵 $M = I - \\alpha A^{\\top}$ 是下三角矩阵，该系统可以通过前向替换进行解析求解，为数值结果提供良好的检验。对于案例3，给定该特定矩阵的 $\\rho(A)=1$ 时，$\\alpha=0.99$ 接近稳定边界。矩阵 $M$ 变得接近奇异，但问题仍然是适定的，数值求解器将产生一个有效的解，我们通过解析推导得出对所有 $i$ 都有 $x_i = 1/(1-\\alpha) = 100$。\n\n实现将遵循这一逻辑，处理每个测试案例，计算向量 $x$，并将输出格式化为指定的 $6$ 位小数精度。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the Katz centrality problem for a batch of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: General acyclic supply chain\n        {'n': 4, 'edges': [(0, 1, 0.2), (0, 2, 0.1), (1, 2, 0.3), (1, 3, 0.4), (2, 3, 0.5)], 'alpha': 0.85},\n        # Case 2: Boundary at alpha = 0\n        {'n': 3, 'edges': [(0, 1, 1), (1, 2, 1), (2, 0, 1)], 'alpha': 0},\n        # Case 3: Near the invertibility boundary\n        {'n': 3, 'edges': [(0, 1, 1), (1, 2, 1), (2, 0, 1)], 'alpha': 0.99},\n        # Case 4: Zero matrix\n        {'n': 5, 'edges': [], 'alpha': 0.7},\n    ]\n\n    all_results_str = []\n\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        alpha = case['alpha']\n\n        # The Katz centrality vector is the solution x to the linear system\n        # (I - alpha * A_transpose) * x = 1\n        # where 1 is a vector of ones.\n\n        # Handle trivial cases for efficiency and correctness.\n        # If alpha is 0 or there are no edges (A is zero matrix),\n        # the equation becomes I*x = 1, so x is a vector of ones.\n        if alpha == 0 or not edges:\n            x = np.ones(n)\n        else:\n            # Construct the transpose of the adjacency matrix A in sparse format.\n            # For an edge (i, j, w) in A, A[i,j] = w.\n            # In A_transpose, this becomes A_transpose[j,i] = w.\n            row_indices = [j for i, j, w in edges]\n            col_indices = [i for i, j, w in edges]\n            data = [w for i, j, w in edges]\n\n            # Use Coordinate (COO) format for easy construction, then convert to\n            # Compressed Sparse Row (CSR) for efficient arithmetic and solving.\n            A_transpose = coo_matrix((data, (row_indices, col_indices)), shape=(n, n)).asformat('csr')\n\n            # Create the identity matrix in sparse CSR format.\n            I = identity(n, format='csr')\n\n            # Form the coefficient matrix M = I - alpha * A_transpose.\n            M = I - alpha * A_transpose\n\n            # The right-hand side vector `b` is a vector of ones.\n            b = np.ones(n)\n\n            # Solve the sparse linear system Mx = b.\n            x = spsolve(M, b)\n\n        # Format the resulting vector according to the problem specification.\n        # Each component is rounded to 6 decimal places.\n        formatted_x = [f\"{val:.6f}\" for val in x]\n        all_results_str.append(f\"[{','.join(formatted_x)}]\")\n\n    # Print the final result in the exact single-line format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"}]}