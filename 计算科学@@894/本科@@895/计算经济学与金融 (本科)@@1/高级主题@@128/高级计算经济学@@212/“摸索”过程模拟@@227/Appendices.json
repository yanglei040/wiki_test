{"hands_on_practices": [{"introduction": "本实践旨在探究消费者偏好如何影响市场价格的动态调整过程。我们将使用恒定替代弹性（CES）效用函数，这是一个比柯布-道格拉斯效用函数更具一般性的模型，通过模拟和比较高替代弹性与低替代弹性情况下的收敛速度，你将亲身体验消费者在商品间转换的难易程度（由参数 $\\sigma$ 衡量）如何影响整个市场达到均衡的效率。[@problem_id:2436189]", "id": "2436189", "problem": "实现并分析一个离散时间试探过程 (tâtonnement process)。该过程应用于一个纯交换经济中，此经济包含两种商品和两位消费者，且消费者的偏好遵循恒定替代弹性 (Constant Elasticity of Substitution, CES) 效用。您的目标是比较替代弹性参数在低值与高值情况下的收敛速度。请用纯数学术语进行研究，所有量均为无量纲。您所编写的程序必须是一个完全可运行的脚本，并且根据执行环境的许可，仅使用 Python 标准库以及 NumPy 和 SciPy。\n\n考虑由 $i \\in \\{1,2\\}$ 索引的两位消费者和由 $j \\in \\{1,2\\}$ 索引的两种商品。每位消费者 $i$ 拥有一个 CES 效用函数，其替代弹性为 $\\sigma > 0$, $\\sigma \\neq 1$，由下式给出\n$$\nU_i(x_{i1},x_{i2};\\sigma) \\;=\\; \\left(\\alpha_i \\, x_{i1}^{\\rho} \\;+\\; (1-\\alpha_i)\\, x_{i2}^{\\rho}\\right)^{\\frac{1}{\\rho}},\n\\quad \\text{其中} \\quad \\rho \\;=\\; \\frac{\\sigma - 1}{\\sigma},\n$$\n其中权重 $\\alpha_i \\in (0,1)$。如果 $\\sigma = 1$，则将 $U_i$ 解释为 Cobb–Douglas 极限形式。\n\n每位消费者 $i$ 拥有一个禀赋向量 $e_i \\in \\mathbb{R}^2_{+}$，并面临价格 $p \\in \\mathbb{R}^2_{++}$。预算集由 $p \\cdot x_i \\leq p \\cdot e_i$ 定义，其中 $m_i = p \\cdot e_i$ 是收入。设总超额需求为\n$$\nz(p;\\sigma) \\;=\\; \\sum_{i=1}^{2} x_i(p;\\sigma, m_i) \\;-\\; \\sum_{i=1}^{2} e_i,\n\\quad \\text{其中} \\quad m_i \\;=\\; p \\cdot e_i.\n$$\n您必须通过效用最大化问题来计算马歇尔（未补偿）需求 $x_i(p;\\sigma,m_i)$\n$$\n\\max_{x_i \\ge 0}\\; U_i(x_{i1},x_{i2};\\sigma) \\quad \\text{受制于} \\quad p \\cdot x_i \\le m_i,\n$$\n并在您的解推导过程中使用基本原理。\n\n模拟一个离散时间试探过程，该过程沿超额需求方向调整价格，同时确保价格为正和规模不变性。使用带单纯形归一化的指数化更新：\n$$\n\\tilde{p}_{t+1} \\;=\\; p_t \\odot \\exp\\!\\left(\\eta \\, z(p_t;\\sigma)\\right),\n\\qquad\np_{t+1} \\;=\\; \\frac{\\tilde{p}_{t+1}}{\\mathbf{1}^\\top \\tilde{p}_{t+1}},\n$$\n其中 $\\odot$ 表示逐分量乘法，$\\exp(\\cdot)$ 逐分量应用，$\\eta > 0$ 是一个步长，$\\mathbf{1}$ 是全一向量。从一个严格正的价格向量 $p_0$ 开始初始化，并重新归一化以满足 $\\mathbf{1}^\\top p_0 = 1$。在每次迭代 $t$ 中，计算 $z(p_t;\\sigma)$。当最小的 $t$ 满足\n$$\n\\max_{j \\in \\{1,2\\}} \\left| z_j(p_t;\\sigma) \\right| \\;\\le\\; \\varepsilon,\n$$\n时停止，或者当达到最大迭代次数时停止。返回收敛前所用的迭代次数，如果未收敛，则返回最大迭代次数。\n\n使用以下固定的经济参数：\n- 消费者权重：$\\alpha_1 = 0.7$, $\\alpha_2 = 0.3$。\n- 禀赋：$e_1 = (1.2,\\, 0.3)$, $e_2 = (0.2,\\, 1.1)$。\n- 收敛容差：$\\varepsilon = 10^{-8}$。\n- 最大迭代次数：$100000$。\n- 每一步的价格归一化：$\\mathbf{1}^\\top p_t = 1$。\n\n测试集：\n为以下参数集 $(\\sigma,\\eta,p_0)$ 实现并运行模拟：\n- 情况 1：$(\\sigma,\\eta,p_0) = (0.5,\\, 0.10,\\, (0.5,\\, 0.5))$。\n- 情况 2：$(\\sigma,\\eta,p_0) = (5.0,\\, 0.10,\\, (0.5,\\, 0.5))$。\n- 情况 3：$(\\sigma,\\eta,p_0) = (0.5,\\, 0.05,\\, (0.9,\\, 0.1))$。\n- 情况 4：$(\\sigma,\\eta,p_0) = (5.0,\\, 0.05,\\, (0.9,\\, 0.1))$。\n\n对于每种情况，计算满足停止准则所需的整数迭代次数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：`\"[123,456,789,1011]\"`），结果按情况 1 到情况 4 的顺序排列。\n\n您的代码必须是一个完整的、可运行的程序，其在内部执行所有计算，并且只打印指定的最终输出行。", "solution": "该问题要求在一个包含两位消费者、两种商品的纯交换经济中，实现并分析一个 Walrasian 试探过程。消费者的偏好由恒定替代弹性 (CES) 效用函数描述。我们的主要任务是首先从基本原理推导出必要的经济学函数，然后构建一个离散时间模拟，以找出在不同参数化条件下价格向量收敛到均衡所需的迭代次数。\n\n首先，我们必须为一个拥有 CES 效用函数的消费者 $i$ 推导出其马歇尔需求函数。效用最大化问题 (UMP) 表述为：\n$$\n\\max_{x_{i1}, x_{i2} \\ge 0} \\; U_i(x_{i1}, x_{i2};\\sigma) = \\left(\\alpha_i x_{i1}^{\\rho} + (1-\\alpha_i) x_{i2}^{\\rho}\\right)^{1/\\rho}\n$$\n受制于预算约束：\n$$\np_1 x_{i1} + p_2 x_{i2} \\le m_i\n$$\n其中 $p = (p_1, p_2)$ 是严格正的价格向量，$m_i$ 是消费者的收入，且 $\\rho = (\\sigma - 1)/\\sigma$。由于指定的效用函数对其参数是严格递增的，因此在最优点，预算约束将以等式形式成立：$p_1 x_{i1} + p_2 x_{i2} = m_i$。\n\n为了解决 UMP，在计算上，最大化单调变换 $U_i^\\rho$ 会更方便，因为这可以简化求导。这个修改后问题对应的拉格朗日函数是：\n$$\n\\mathcal{L}(x_{i1}, x_{i2}, \\lambda) = \\alpha_i x_{i1}^{\\rho} + (1-\\alpha_i) x_{i2}^{\\rho} - \\lambda (p_1 x_{i1} + p_2 x_{i2} - m_i)\n$$\n关于 $x_{i1}$ 和 $x_{i2}$ 的一阶条件（假设为内部解，$x_{i1}>0, x_{i2}>0$）是：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x_{i1}} = \\rho \\alpha_i x_{i1}^{\\rho - 1} - \\lambda p_1 = 0\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x_{i2}} = \\rho (1-\\alpha_i) x_{i2}^{\\rho - 1} - \\lambda p_2 = 0\n$$\n我们可以通过将第一个方程除以第二个方程来消去拉格朗日乘子 $\\lambda$：\n$$\n\\frac{\\alpha_i}{(1-\\alpha_i)} \\left(\\frac{x_{i1}}{x_{i2}}\\right)^{\\rho-1} = \\frac{p_1}{p_2}\n$$\n解出商品消费的比率：\n$$\n\\frac{x_{i1}}{x_{i2}} = \\left( \\frac{p_1}{p_2} \\frac{1-\\alpha_i}{\\alpha_i} \\right)^{\\frac{1}{\\rho-1}}\n$$\n使用定义 $\\rho = (\\sigma - 1)/\\sigma$，我们得到 $\\rho - 1 = -1/\\sigma$。因此，上述表达式中的指数变为 $1/(\\rho-1) = -\\sigma$。这样，关系式为：\n$$\nx_{i1} = x_{i2} \\left( \\frac{p_1}{p_2} \\right)^{-\\sigma} \\left( \\frac{\\alpha_i}{1-\\alpha_i} \\right)^{\\sigma}\n$$\n将 $x_{i1}$ 的这个表达式代入预算约束 $p_1 x_{i1} + p_2 x_{i2} = m_i$ 使我们能够解出 $x_{i2}$，并随后解出 $x_{i1}$。这个过程得出了 CES 效用设定下的标准马歇尔需求函数。对于商品 $j \\in \\{1,2\\}$，消费者 $i$ 的需求是：\n$$\nx_{i1}(p, m_i; \\sigma) = m_i \\frac{\\alpha_i^{\\sigma} p_1^{-\\sigma}}{\\alpha_i^{\\sigma} p_1^{1-\\sigma} + (1-\\alpha_i)^{\\sigma} p_2^{1-\\sigma}}\n$$\n$$\nx_{i2}(p, m_i; \\sigma) = m_i \\frac{(1-\\alpha_i)^{\\sigma} p_2^{-\\sigma}}{\\alpha_i^{\\sigma} p_1^{1-\\sigma} + (1-\\alpha_i)^{\\sigma} p_2^{1-\\sigma}}\n$$\n对于所有的 $p \\in \\mathbb{R}_{++}^2$ 和 $\\sigma > 0$，这些表达式都是良定义的。\n\n试探过程的模拟是一个迭代算法。给定总禀赋 $E = \\sum_{i=1}^2 e_i$。该过程按迭代 $t=0, 1, 2, \\dots$ 进行，如下所示：\n1.  用一个严格正的价格向量 $p_0$进行初始化，并将其归一化，使其分量之和为1。\n2.  在每次迭代 $t$ 中，给定当前价格向量 $p_t=(p_{t,1}, p_{t,2})$：\n    a. 为每位消费者 $i$ 计算收入 $m_{i,t}$：$m_{i,t} = p_t \\cdot e_i = p_{t,1} e_{i1} + p_{t,2} e_{i2}$。\n    b. 使用推导出的公式为每位消费者计算需求向量 $x_{i}(p_t, m_{i,t}; \\sigma)$。\n    c. 计算总需求向量 $X_t = \\sum_{i=1}^2 x_{i}(p_t, m_{i,t}; \\sigma)$。\n    d. 计算总超额需求向量 $z(p_t; \\sigma) = X_t - E$。根据 Walras 定律，必有 $p_t \\cdot z(p_t; \\sigma) = 0$。\n3.  检查收敛性。如果超额需求向量的无穷范数低于容差 $\\varepsilon$：$\\max_j |z_j(p_t; \\sigma)| \\le \\varepsilon$，则过程终止。如果满足此条件，则将收敛所需的迭代次数记录为 $t$。\n4.  如果系统尚未收敛，则更新价格向量。使用指数更新规则逐分量计算一个中间的、未归一化的价格向量 $\\tilde{p}_{t+1}$：\n    $$\n    \\tilde{p}_{t+1, j} = p_{t,j} \\exp(\\eta \\, z_j(p_t; \\sigma)) \\quad \\text{对于 } j \\in \\{1,2\\}\n    $$\n    其中 $\\eta > 0$ 是一个固定的步长参数。此更新规则确保新的价格向量保持严格为正。\n5.  下一次迭代的新价格向量 $p_{t+1}$ 是通过将 $\\tilde{p}_{t+1}$ 归一化到标准单纯形上得到的：\n    $$\n    p_{t+1} = \\frac{\\tilde{p}_{t+1}}{\\mathbf{1}^\\top \\tilde{p}_{t+1}} = \\frac{\\tilde{p}_{t+1}}{\\tilde{p}_{t+1,1} + \\tilde{p}_{t+1,2}}\n    $$\n6.  然后，过程从步骤 2 开始重复，并将索引 $t$ 递增。如果迭代次数达到指定的最大值 $100000$，模拟将停止并报告此最大值，表示在分配的步数内未实现收敛。\n\n所提供的数值实现将精确地编码此算法。利用 NumPy 库的向量和矩阵运算来高效计算收入、需求和超额需求。经济体的固定参数 ($\\alpha_i, e_i$) 和模拟参数 $(\\sigma, \\eta, p_0, \\varepsilon, \\text{max\\_iter})$ 均按问题陈述中的规定进行定义。对四个测试用例中的每一个都执行模拟，并收集收敛所需的迭代次数以用于最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the simulation for all test cases.\n    \"\"\"\n\n    # --- Fixed Economy and Simulation Parameters ---\n    # Consumer preference weights (alpha_1, alpha_2)\n    ALPHA = np.array([0.7, 0.3])\n    # Consumer endowments e_i = (e_i1, e_i2)\n    ENDOWMENTS = np.array([[1.2, 0.3], [0.2, 1.1]])\n    # Convergence tolerance\n    EPSILON = 1e-8\n    # Maximum number of iterations\n    MAX_ITER = 100000\n    # Aggregate endowments E = (E_1, E_2)\n    E_AGG = np.sum(ENDOWMENTS, axis=0)\n\n    # --- Test Cases ---\n    # Each case is a tuple: (sigma, eta, p0)\n    test_cases = [\n        (0.5, 0.10, (0.5, 0.5)),\n        (5.0, 0.10, (0.5, 0.5)),\n        (0.5, 0.05, (0.9, 0.1)),\n        (5.0, 0.05, (0.9, 0.1)),\n    ]\n\n    def calculate_excess_demand(p, sigma):\n        \"\"\"\n        Calculates the aggregate excess demand vector for a given price vector and elasticity.\n\n        Args:\n            p (np.ndarray): Price vector of shape (2,).\n            sigma (float): Elasticity of substitution.\n\n        Returns:\n            np.ndarray: Aggregate excess demand vector of shape (2,).\n        \"\"\"\n        # Calculate incomes for each consumer: m_i = p . e_i\n        # ENDOWMENTS is (2, 2), p is (2,). Result is a (2,) vector of incomes.\n        incomes = ENDOWMENTS @ p\n\n        # Prepare matrices for vectorized demand calculation.\n        # alpha_matrix[i, j] is the weight consumer i gives to good j.\n        alpha_matrix = np.array([ALPHA, 1 - ALPHA]).T\n\n        # Numerator term: alpha_ij^sigma * p_j^(-sigma)\n        p_pow_neg_sigma = p**(-sigma)       # element-wise power\n        alpha_pow_sigma = alpha_matrix**sigma # element-wise power\n        numerators = alpha_pow_sigma * p_pow_neg_sigma # broadcasting (2,2) * (2,)\n\n        # Denominator term: D_i = sum_j alpha_ij^sigma * p_j^(1-sigma)\n        p_pow_1_minus_sigma = p**(1 - sigma)\n        # Using dot product with ones vector for summation over j\n        denominators = (alpha_pow_sigma * p_pow_1_minus_sigma) @ np.ones(2)\n\n        # Calculate Marshallian demands: x_ij = m_i * Numerator_ij / Denominator_i\n        # Use np.newaxis to align dimensions for broadcasting correctly.\n        demands = (incomes[:, np.newaxis] * numerators) / denominators[:, np.newaxis]\n\n        # Aggregate demand and excess demand\n        X_agg = np.sum(demands, axis=0)\n        z = X_agg - E_AGG\n        \n        return z\n\n    def run_simulation(sigma, eta, p0):\n        \"\"\"\n        Runs the tâtonnement process simulation for a given parameter set.\n\n        Args:\n            sigma (float): Elasticity of substitution.\n            eta (float): Step size for price updates.\n            p0 (tuple): Initial price vector.\n\n        Returns:\n            int: Number of iterations to converge, or MAX_ITER if not converged.\n        \"\"\"\n        # Initialize and normalize the price vector.\n        p = np.array(p0, dtype=np.float64)\n        p /= np.sum(p)\n\n        for t in range(MAX_ITER):\n            # Calculate excess demand at current price p_t\n            z = calculate_excess_demand(p, sigma)\n\n            # Check for convergence\n            if np.max(np.abs(z)) <= EPSILON:\n                return t\n\n            # Update prices using the exponential rule\n            p_tilde = p * np.exp(eta * z)\n            \n            # Normalize to get the price vector for the next iteration\n            p = p_tilde / np.sum(p_tilde)\n        \n        # After MAX_ITER iterations, check for convergence one last time.\n        z = calculate_excess_demand(p, sigma)\n        if np.max(np.abs(z)) <= EPSILON:\n            return MAX_ITER\n\n        # If the loop finishes without converging, return MAX_ITER.\n        return MAX_ITER\n\n    # Execute simulation for all test cases and collect results.\n    results = []\n    for sigma_val, eta_val, p0_val in test_cases:\n        iterations = run_simulation(sigma_val, eta_val, p0_val)\n        results.append(iterations)\n\n    # Print results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "在经典的瓦尔拉斯模型中，价格会立即对任何微小的供需失衡做出反应，然而，在现实世界中，价格调整往往存在“粘性”。本练习引入了一个价格粘性阈值 $\\delta$，要求价格只有在超额需求足够大时才会变动。通过这个模拟，你能够研究这种常见的市场摩擦如何影响价格的动态路径以及最终的均衡状态。[@problem_id:2436152]", "id": "2436152", "problem": "考虑一个有 $I = 2$ 个代理人和 $G = 3$ 种商品的纯交换经济。每个代理人 $i \\in \\{1,2\\}$ 对这些商品拥有一个柯布-道格拉斯效用函数，其指数 $\\alpha_{ig}$ 满足 $\\sum_{g=1}^{3} \\alpha_{ig} = 1$ 且对于所有 $g$ 都有 $\\alpha_{ig} \\in (0,1)$。代理人 $i$ 的禀赋为一个严格为正的商品向量 $\\mathbf{e}_i \\in \\mathbb{R}_{++}^{3}$。设总禀赋为 $\\mathbf{E} = \\sum_{i=1}^{2} \\mathbf{e}_i$。价格由一个严格为正的向量 $\\mathbf{p} \\in \\mathbb{R}_{++}^{3}$ 表示，其中第一种商品用作计价物，因此始终有 $p_1 \\equiv 1$。\n\n给定价格向量 $\\mathbf{p}$，代理人 $i$ 的收入为 $m_i(\\mathbf{p}) = \\mathbf{p} \\cdot \\mathbf{e}_i$。对于柯布-道格拉斯偏好，代理人 $i$ 对商品 $g$ 的个人需求为 $x_{ig}(\\mathbf{p}) = \\alpha_{ig} \\, m_i(\\mathbf{p}) / p_g$。商品 $g$ 的总需求为 $X_g(\\mathbf{p}) = \\sum_{i=1}^{2} x_{ig}(\\mathbf{p})$，超额需求为 $Z_g(\\mathbf{p}) = X_g(\\mathbf{p}) - E_g$。市场出清要求在均衡价格 $\\mathbf{p}^*$ 下，对所有商品 $g$ 都有 $Z_g(\\mathbf{p}^*) = 0$，并以 $p_1^* = 1$ 作为归一化条件。\n\n您将模拟一个具有价格粘性的离散时间 tâtonnement (价格调整) 过程。设 $t \\in \\{0,1,2,\\dots\\}$ 为迭代的索引。对于给定的步长 $\\gamma > 0$ 和粘性阈值 $\\delta \\ge 0$，价格按如下方式更新：\n- 计价物价格是固定的：对于所有 $t$，$p_1^{t+1} = 1$。\n- 对于每种非计价物商品 $g \\in \\{2,3\\}$，\n  - 如果 $\\lvert Z_g(\\mathbf{p}^t) \\rvert > \\delta$，那么\n    $$\n    p_g^{t+1} = \\max\\{\\varepsilon, \\, p_g^t \\, (1 + \\gamma \\, Z_g(\\mathbf{p}^t))\\},\n    $$\n    其中 $\\varepsilon > 0$ 是一个用于确保价格为正的小常数。\n  - 否则，$p_g^{t+1} = p_g^t$ (由于粘性，价格不变)。\n当满足 $\\max_{g \\in \\{1,2,3\\}} \\lvert Z_g(\\mathbf{p}^t) \\rvert \\le \\tau$ 时，即宣布收敛，其中 $\\tau > 0$ 是一个容差。如果在 $T_{\\max}$ 次迭代内未达到收敛，则过程停止并宣布未收敛。\n\n使用以下校准的经济体参数：\n- 柯布-道格拉斯指数：\n  - 代理人 $1$：$(\\alpha_{11}, \\alpha_{12}, \\alpha_{13}) = (0.5, 0.3, 0.2)$。\n  - 代理人 $2$：$(\\alpha_{21}, \\alpha_{22}, \\alpha_{23}) = (0.2, 0.4, 0.4)$。\n- 禀赋：\n  - 代理人 $1$：$\\mathbf{e}_1 = (1.0, 0.5, 0.5)$。\n  - 代理人 $2$：$\\mathbf{e}_2 = (0.5, 1.0, 0.5)$。\n- 总禀赋：$\\mathbf{E} = (1.5, 1.5, 1.0)$。\n- 所有模拟的固定参数：正值下限 $\\varepsilon = 10^{-8}$，收敛容差 $\\tau = 10^{-6}$。\n- 初始价格向量 $\\mathbf{p}^0$ 总是设定为 $p_1^0 = 1$。\n\n为以下测试用例集实现模拟。每个测试用例是一个具有明确值的元组 $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0)$：\n- 案例 $\\mathrm{A}$ (基准，无粘性)：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 0.0, 5000, [1.0, 1.0, 1.0])$。\n- 案例 $\\mathrm{B}$ (中度粘性，非均衡起点)：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.15, 0.1, 5000, [1.0, 0.7, 1.3])$。\n- 案例 $\\mathrm{C}$ (高度粘性，实际冻结)：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 1.0, 10, [1.0, 1.0, 1.0])$。\n- 案例 $\\mathrm{D}$ (在等式边界上的粘性)：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 0.2, 10, [1.0, 1.0, 1.0])$。\n\n对您的程序的要求：\n- 在每次迭代中，根据基本面精确计算上述定义的 $Z_g(\\mathbf{p})$。\n- 严格按照规定应用粘性 tâtonnement 规则，当严格不等式 $\\lvert Z_g \\rvert > \\delta$ 成立时触发更新。\n- 始终保持 $p_1 \\equiv 1$。\n- 如果满足收敛条件 $\\max_g \\lvert Z_g(\\mathbf{p}^t) \\rvert \\le \\tau$，则提前停止。\n- 对于每个测试用例，生成格式为 $[N, B, [p_1, p_2, p_3]]$ 的结果，其中：\n  - $N$ 是实际执行的迭代次数（介于 $0$ 和 $T_{\\max}$ 之间）的整数。\n  - $B$ 是一个布尔值，如果宣布收敛则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n  - $[p_1, p_2, p_3]$ 是四舍五入到六位小数的最终价格向量。\n- 最终输出格式：您的程序应生成单行输出，其中包含按案例 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$、$\\mathrm{D}$ 顺序排列的结果，形式为方括号括起来的逗号分隔列表。例如，它应类似于 $[[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]]]$，并用实际的数值和布尔结果替换。", "solution": "该问题是有效的。这是一个在计算经济学中定义明确的练习，它基于一般均衡理论和动力系统数值模拟的既定原则。所有参数、方程和条件都已足够精确地指定，可以构建一个唯一的、可验证的解决方案。\n\n该问题要求在一个纯交换经济中模拟一个离散时间的 tâtonnement 价格调整过程。该经济体由 $I=2$ 个代理人和 $G=3$ 种商品组成。解决方案的核心是实现一个迭代算法，该算法根据市场超额需求来更新价格，直到达到均衡或超过最大迭代次数。\n\n首先，我们建立经济模型的基本方程。每个代理人 $i \\in \\{1, 2\\}$ 具有柯布-道格拉斯偏好，由效用函数 $U_i(\\mathbf{x}_i) = \\prod_{g=1}^3 x_{ig}^{\\alpha_{ig}}$ 描述，其中 $\\mathbf{x}_i = (x_{i1}, x_{i2}, x_{i3})$ 是消费束，$\\boldsymbol{\\alpha}_i = (\\alpha_{i1}, \\alpha_{i2}, \\alpha_{i3})$ 是效用份额参数。代理人拥有商品禀赋向量 $\\mathbf{e}_i = (e_{i1}, e_{i2}, e_{i3})$。\n\n给定价格向量 $\\mathbf{p} = (p_1, p_2, p_3)$，代理人 $i$ 的收入（或财富）来自其禀赋：\n$$\nm_i(\\mathbf{p}) = \\mathbf{p} \\cdot \\mathbf{e}_i = \\sum_{g=1}^{3} p_g e_{ig}\n$$\n柯布-道格拉斯效用函数的一个关键特性是，代理人 $i$ 会将其收入的固定比例 $\\alpha_{ig}$ 分配给每种商品 $g$。由此得出个人需求函数：\n$$\nx_{ig}(\\mathbf{p}) = \\frac{\\alpha_{ig} m_i(\\mathbf{p})}{p_g}\n$$\n每种商品 $g$ 的总需求是所有代理人个人需求的总和：\n$$\nX_g(\\mathbf{p}) = \\sum_{i=1}^{2} x_{ig}(\\mathbf{p})\n$$\n经济中每种商品的总量由总禀赋 $\\mathbf{E} = \\mathbf{e}_1 + \\mathbf{e}_2$ 固定。商品 $g$ 的超额需求，记为 $Z_g(\\mathbf{p})$，是需求量与可供量之间的差额：\n$$\nZ_g(\\mathbf{p}) = X_g(\\mathbf{p}) - E_g\n$$\n问题指定了以下经济参数：\n- 效用指数：代理人 $1$ 为 $\\boldsymbol{\\alpha}_1 = (0.5, 0.3, 0.2)$，代理人 $2$ 为 $\\boldsymbol{\\alpha}_2 = (0.2, 0.4, 0.4)$。\n- 禀赋：代理人 $1$ 为 $\\mathbf{e}_1 = (1.0, 0.5, 0.5)$，代理人 $2$ 为 $\\mathbf{e}_2 = (0.5, 1.0, 0.5)$。\n- 总禀赋：$\\mathbf{E} = \\mathbf{e}_1 + \\mathbf{e}_2 = (1.5, 1.5, 1.0)$。\n\n模拟遵循一个离散时间的 tâtonnement 过程，由 $t \\in \\{0, 1, 2, \\dots\\}$ 索引。商品1的价格被归一化作为计价物，即对所有 $t$ 都有 $p_1^t \\equiv 1$。非计价物商品 $p_2$ 和 $p_3$ 的价格根据它们各自的超额需求进行调整，但带有一个“粘性”条件。\n\n算法流程如下：\n1.  **初始化**：在迭代 $t=0$ 时，从给定的初始价格向量 $\\mathbf{p}^0$ 开始。\n2.  **迭代循环**：对于 $t = 0, 1, \\dots, T_{\\max}$：\n    a. **计算状态**：对所有商品 $g \\in \\{1, 2, 3\\}$，计算代理人收入 $m_i(\\mathbf{p}^t)$、总需求 $X_g(\\mathbf{p}^t)$ 和超额需求 $Z_g(\\mathbf{p}^t)$。\n    b. **检查收敛**：如果 $\\max_{g} |Z_g(\\mathbf{p}^t)| \\le \\tau$，其中 $\\tau = 10^{-6}$ 是容差，则过程已收敛。模拟终止，报告当前迭代次数 $t$、收敛状态 `True` 和最终价格向量 $\\mathbf{p}^t$。\n    c. **检查迭代限制**：如果 $t$ 达到 $T_{\\max}$，模拟停止。报告最终状态，迭代次数为 $T_{\\max}$，收敛状态由步骤 (b) 中的最终检查确定。\n    d. **价格更新**：如果过程未终止，则计算下一个价格向量 $\\mathbf{p}^{t+1}$。计价物价格是固定的：$p_1^{t+1} = 1$。对于每个非计价物商品 $g \\in \\{2, 3\\}$，价格根据粘性规则更新：\n       $$\n       p_g^{t+1} =\n       \\begin{cases}\n       \\max\\{\\varepsilon, p_g^t (1 + \\gamma Z_g(\\mathbf{p}^t))\\} & \\text{if } |Z_g(\\mathbf{p}^t)| > \\delta \\\\\n       p_g^t & \\text{if } |Z_g(\\mathbf{p}^t)| \\le \\delta\n       \\end{cases}\n       $$\n       在这里，$\\gamma$ 是调整速度，$\\delta$ 是粘性阈值，而 $\\varepsilon = 10^{-8}$ 是一个确保价格保持严格为正的下限。\n    e. **推进**：设置 $\\mathbf{p}^t \\leftarrow \\mathbf{p}^{t+1}$，增加迭代计数器，并从步骤 (a) 重复。\n\n此算法将使用 Python 和 `numpy` 库来实现，以进行高效的向量和矩阵运算。该程序将对四个指定的测试用例执行模拟，每个用例具有不同的参数集 $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0)$，并按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the tâtonnement process simulations for all test cases.\n    \"\"\"\n    \n    # Calibrated economy parameters\n    alphas = np.array([\n        [0.5, 0.3, 0.2],  # Agent 1\n        [0.2, 0.4, 0.4]   # Agent 2\n    ])\n    \n    endowments = np.array([\n        [1.0, 0.5, 0.5],  # Agent 1\n        [0.5, 1.0, 0.5]   # Agent 2\n    ])\n    \n    agg_endowment = np.sum(endowments, axis=0)\n    \n    # Fixed simulation parameters\n    epsilon = 1e-8\n    tau = 1e-6\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: baseline, no stickiness\n        (0.2, 0.0, 5000, np.array([1.0, 1.0, 1.0])),\n        # Case B: moderate stickiness, off-equilibrium start\n        (0.15, 0.1, 5000, np.array([1.0, 0.7, 1.3])),\n        # Case C: high stickiness, effectively frozen\n        (0.2, 1.0, 10, np.array([1.0, 1.0, 1.0])),\n        # Case D: boundary stickiness at equality\n        (0.2, 0.2, 10, np.array([1.0, 1.0, 1.0])),\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma, delta, T_max, p0 = case\n        \n        # Run the simulation for the current case\n        N, B, p_final = simulate_tatonnement(\n            gamma, delta, T_max, p0, \n            alphas, endowments, agg_endowment, \n            epsilon, tau\n        )\n        \n        # Round final prices to 6 decimal places\n        p_final_rounded = np.round(p_final, 6).tolist()\n        \n        results.append([N, B, p_final_rounded])\n\n    # Final print statement in the exact required format.\n    # The replace(\" \", \"\") call ensures the output matches the dense format.\n    print(str(results).replace(\" \", \"\"))\n\ndef simulate_tatonnement(gamma, delta, T_max, p0, alphas, endowments, agg_endowment, epsilon, tau):\n    \"\"\"\n    Simulates the sticky tâtonnement process for a single case.\n    \n    Returns:\n        N (int): Number of iterations performed.\n        converged (bool): True if convergence was achieved, False otherwise.\n        p (np.ndarray): The final price vector.\n    \"\"\"\n    p = p0.copy()\n    N = 0\n    converged = False\n\n    while N <= T_max:\n        # Step 1: Calculate incomes m_i(p) = p . e_i\n        incomes = np.dot(endowments, p)\n        \n        # Step 2: Calculate individual demands x_ig(p) = alpha_ig * m_i(p) / p_g\n        # We need to handle division by p_g carefully.\n        # income_per_price matrix: (I x G)\n        income_matrix = np.tile(incomes, (alphas.shape[1], 1)).T\n        demands = alphas * income_matrix / p\n        \n        # Step 3: Calculate aggregate and excess demands\n        agg_demand = np.sum(demands, axis=0)\n        excess_demand = agg_demand - agg_endowment\n        \n        # Step 4: Check for convergence\n        if np.max(np.abs(excess_demand)) <= tau:\n            converged = True\n            break\n        \n        # Step 5: Check for maximum iterations\n        if N == T_max:\n            break\n        \n        # Step 6: Update prices for the next iteration\n        p_next = p.copy()\n        \n        # Update for non-numeraire goods (g=2, 3), indices 1, 2\n        for g_idx in [1, 2]:\n            if abs(excess_demand[g_idx]) > delta:\n                p_next[g_idx] = max(epsilon, p[g_idx] * (1 + gamma * excess_demand[g_idx]))\n        \n        p = p_next\n        N += 1\n        \n    return N, converged, p\n\nsolve()\n\n```"}, {"introduction": "前面的练习遵循了瓦尔拉斯“摸索”过程的核心假设，即在找到均衡价格之前不发生任何交易。本练习将打破这一设定，引入一个非瓦尔拉斯框架，在该框架中，即使市场尚未出清，也允许进行有限的、按比例分配的交易。通过模拟这个禀赋随时间演变的动态过程，你将探索一个更接近真实市场运行机制的模型，并理解非均衡交易如何影响最终的市场结果。[@problem_id:2436167]", "id": "2436167", "problem": "给定一个双商品、双代理人的纯交换经济。时间是离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。有两种商品，标记为 $g \\in \\{1,2\\}$，以及两个代理人，标记为 $i \\in \\{A,B\\}$。在每个时间点 $t$，会公布一个严格为正的价格向量 $p_t = (p_{t,1}, p_{t,2}) \\in \\mathbb{R}_{++}^2$，之后代理人根据其当前禀赋和公布的价格形成需求。如果市场未能出清，该过程允许发生有限的配给交易，随之进行新一轮的价格公布。\n\n基本模型组成部分：\n\n1) 偏好与需求。每个代理人 $i$ 对两种商品的效用为柯布-道格拉斯效用函数，参数为 $\\alpha_i \\in (0,1)$：\n$$\nu_i(x_{i,1}, x_{i,2}) = x_{i,1}^{\\alpha_i} x_{i,2}^{1-\\alpha_i}.\n$$\n给定价格 $p_t$和禀赋 $e_{i}(t) = (e_{i,1}(t), e_{i,2}(t)) \\in \\mathbb{R}_{+}^2$，预算为 $m_i(t) = p_{t,1} e_{i,1}(t) + p_{t,2} e_{i,2}(t)$。代理人 $i$ 在时间 $t$ 的柯布-道格拉斯需求为：\n$$\nd_{i,1}(t) = \\frac{\\alpha_i \\, m_i(t)}{p_{t,1}}, \\qquad d_{i,2}(t) = \\frac{(1-\\alpha_i) \\, m_i(t)}{p_{t,2}}.\n$$\n定义商品 $g$ 的总需求为 $D_g(t) = \\sum_{i \\in \\{A,B\\}} d_{i,g}(t)$。定义总禀赋（总供给）为 $S_g(t) = \\sum_{i \\in \\{A,B\\}} e_{i,g}(t)$。总超额需求为\n$$\nz_g(t) = D_g(t) - S_g(t).\n$$\n\n2) 在下一次价格公布前的有限配给交易。对于每种商品 $g \\in \\{1,2\\}$，定义每个代理人的净期望交易量 $n_{i,g}(t) = d_{i,g}(t) - e_{i,g}(t)$。设商品 $g$ 的买方和卖方集合为\n$$\n\\mathcal{B}_g(t) = \\{ i : n_{i,g}(t) > 0 \\}, \\quad \\mathcal{S}_g(t) = \\{ i : n_{i,g}(t) < 0 \\}.\n$$\n定义商品 $g$ 的总期望购买量和总期望销售量为\n$$\nB_g(t) = \\sum_{i \\in \\mathcal{B}_g(t)} n_{i,g}(t), \\qquad S_g^{\\text{tot}}(t) = \\sum_{i \\in \\mathcal{S}_g(t)} \\big( -n_{i,g}(t) \\big).\n$$\n令 $\\rho \\in [0,1]$ 为一个固定的“每轮交易限额”。在时间 $t$ 实际交易的商品 $g$ 的数量为短边乘以该限额：\n$$\nT_g(t) = \\rho \\cdot \\min\\big( B_g(t), \\, S_g^{\\text{tot}}(t) \\big).\n$$\n交易根据市场上各方提交的数量按比例进行配给：\n- 对于每个买方 $i \\in \\mathcal{B}_g(t)$，获得的商品 $g$ 的数量为\n$$\nq_{i,g}(t) = \\begin{cases}\nT_g(t) \\cdot \\dfrac{n_{i,g}(t)}{B_g(t)} & \\text{if } B_g(t) > 0, \\\\\n0 & \\text{if } B_g(t) = 0,\n\\end{cases}\n$$\n对于每个卖方 $i \\in \\mathcal{S}_g(t)$，交割的商品 $g$ 的数量为\n$$\ns_{i,g}(t) = \\begin{cases}\nT_g(t) \\cdot \\dfrac{-n_{i,g}(t)}{S_g^{\\text{tot}}(t)} & \\text{if } S_g^{\\text{tot}}(t) > 0, \\\\\n0 & \\text{if } S_g^{\\text{tot}}(t) = 0.\n\\end{cases}\n$$\n禀赋根据商品守恒进行更新：\n$$\ne_{i,g}(t+1) = e_{i,g}(t) + q_{i,g}(t) - s_{i,g}(t).\n$$\n注意，对于每种商品 $g$，都有 $S_g(t+1) = \\sum_i e_{i,g}(t+1) = S_g(t)$。\n\n3) 价格调整（试探过程）。令 $\\eta > 0$ 为给定的步长参数。价格根据以下规则演变\n$$\np_{t+1,g} = p_{t,g} \\cdot \\exp\\!\\left( \\eta \\cdot \\frac{z_g(t)}{S_g(t)} \\right), \\quad g \\in \\{1,2\\}.\n$$\n然后通过将商品2固定为计价物来对价格进行归一化：\n$$\n\\tilde{p}_{t+1,g} = \\frac{p_{t+1,g}}{p_{t+1,2}}, \\quad \\text{因此 } \\tilde{p}_{t+1,2} = 1.\n$$\n为简化符号，将 $\\tilde{p}_{t+1}$ 重标记为 $p_{t+1}$。\n\n4) 收敛与终止。当\n$$\n\\max\\{ |z_1(t)|, |z_2(t)| \\} \\le \\varepsilon\n$$\n对于给定的容差 $\\varepsilon > 0$ 成立，或达到最大迭代次数 $T_{\\max}$ 时，过程终止。终止时，报告商品1的归一化价格，即在 $p_{t,2} = 1$ 时的 $p_{t,1}$。\n\n任务。实现一个程序，模拟上述非瓦尔拉斯、配给交易的试探过程，并为下面的每个测试套件中的参数集返回商品1的最终归一化价格。所有数值都是无量纲的。\n\n测试套件。对于每种情况，输入包括\n- 柯布-道格拉斯参数 $(\\alpha_A,\\alpha_B)$，\n- 初始禀赋 $e_A(0) = (e_{A,1}(0), e_{A,2}(0))$，$e_B(0) = (e_{B,1}(0), e_{B,2}(0))$，\n- 初始价格 $p_0 = (p_{0,1}, p_{0,2})$，\n- 步长参数 $\\eta$，交易限额 $\\rho$，容差 $\\varepsilon$，以及最大迭代次数 $T_{\\max}$。\n\n指定并解决以下四种情况：\n\n- 情况1（理想情况）：$(\\alpha_A,\\alpha_B) = (0.5, 0.5)$，$e_A(0) = (1, 0)$，$e_B(0) = (0, 1)$，$p_0 = (2, 1)$，$\\eta = 0.2$，$\\rho = 0.5$，$\\varepsilon = 10^{-8}$，$T_{\\max} = 10000$。\n- 情况2（边界情况：初始出清价格）：$(\\alpha_A,\\alpha_B) = (0.5, 0.5)$，$e_A(0) = (1, 0)$，$e_B(0) = (0, 1)$，$p_0 = (1, 1)$，$\\eta = 0.2$，$\\rho = 0.7$，$\\varepsilon = 10^{-10}$，$T_{\\max} = 10000$。\n- 情况3（边缘情况：价格公布之间不允许交易）：$(\\alpha_A,\\alpha_B) = (0.5, 0.5)$，$e_A(0) = (1, 0)$，$e_B(0) = (0, 1)$，$p_0 = (3, 1)$，$\\eta = 0.3$，$\\rho = 0$，$\\varepsilon = 10^{-8}$，$T_{\\max} = 10000$。\n- 情况4（非对称偏好和禀赋）：$(\\alpha_A,\\alpha_B) = (0.8, 0.2)$，$e_A(0) = (2, 0.5)$，$e_B(0) = (0.5, 1)$，$p_0 = (0.4, 1)$，$\\eta = 0.2$，$\\rho = 1$，$\\varepsilon = 10^{-8}$，$T_{\\max} = 20000$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每种情况，输出商品1的最终归一化价格，四舍五入到六位小数。例如，一个包含四种情况的输出应如下所示\n$$\n[\\text{p1\\_case1},\\text{p1\\_case2},\\text{p1\\_case3},\\text{p1\\_case4}],\n$$\n其中每个条目都是一个小数点后有六位数字的十进制数。", "solution": "该问题经过严格验证，被认为是有效的。它提出了一个来自计算经济学领域的、定义清晰、科学可靠且计算上可行的非瓦尔拉斯试探过程模型。所有参数、方程和条件都得到了明确的规定，没有歧义，构成了一个自洽且一致的系统。该问题要求在几种参数化设置下对该系统进行数值模拟，这是科学计算中的一项标准任务。\n\n解决方案要求实现一个离散时间模拟，该模拟迭代更新禀赋和价格，直到市场接近均衡。算法过程如下。\n\n令时间由 $t \\in \\{0, 1, 2, \\ldots\\}$ 索引。时间 $t$ 的系统状态由价格向量 $p_t = (p_{t,1}, p_{t,2})$ 和两个代理人 $i \\in \\{A, B\\}$ 对两种商品 $g \\in \\{1, 2\\}$ 的禀赋矩阵描述，记为 $e(t) = \\{e_{i,g}(t)\\}$。模拟从初始条件 $p_0$ 和 $e(0)$ 开始。每种商品的总禀赋 $S_g = \\sum_{i} e_{i,g}(t)$ 在时间上是恒定的，此特性被称为商品守恒，是纯交换模型的内在属性。\n\n从 $0$ 到 $T_{\\max}-1$ 的每个时间步 $t$ 的模拟循环包括以下计算序列：\n\n1.  **需求和超额需求计算**：给定当前价格 $p_t$ 和当前禀赋 $e(t)$，我们首先计算每个代理人 $i$ 的预算：\n    $$\n    m_i(t) = \\sum_{g=1}^{2} p_{t,g} e_{i,g}(t) = p_t \\cdot e_i(t).\n    $$\n    代理人 $i$ 对每种商品 $g$ 的需求是通过最大化其柯布-道格拉斯效用函数 $u_i(x_{i,1}, x_{i,2}) = x_{i,1}^{\\alpha_i} x_{i,2}^{1-\\alpha_i}$ 并在其预算约束下得到的。这产生了以下需求函数：\n    $$\n    d_{i,1}(t) = \\frac{\\alpha_i m_i(t)}{p_{t,1}} \\quad \\text{和} \\quad d_{i,2}(t) = \\frac{(1-\\alpha_i) m_i(t)}{p_{t,2}}.\n    $$\n    每种商品 $g$ 的总需求是个人需求的总和，$D_g(t) = \\sum_i d_{i,g}(t)$。商品 $g$ 的总超额需求，记为 $z_g(t)$，是总需求与总供给（总禀赋）之间的差额：\n    $$\n    z_g(t) = D_g(t) - S_g.\n    $$\n    作为一致性检查，瓦尔拉斯定律必须成立：$\\sum_g p_{t,g} z_g(t) = 0$。\n\n2.  **收敛检查**：如果市场足够接近均衡，模拟将终止。这是通过检查两种商品的总超额需求幅度是否低于指定的容差 $\\varepsilon > 0$ 来确定的：\n    $$\n    \\max\\left( |z_1(t)|, |z_2(t)| \\right) \\le \\varepsilon.\n    $$\n    如果满足此条件，过程停止，当前商品1的归一化价格 $p_{t,1}$ 即为结果。\n\n3.  **配给交易和禀赋更新**：如果市场尚未出清，则会发生非均衡交易。这种交易受因子 $\\rho \\in [0,1]$ 限制，并在市场的短边进行配给。\n    - 首先，我们确定每个代理人对每种商品的净期望交易量：$n_{i,g}(t) = d_{i,g}(t) - e_{i,g}(t)$。\n    - 对于每种商品 $g$，我们计算总期望购买量 $B_g(t) = \\sum_{i: n_{i,g}(t)>0} n_{i,g}(t)$ 和总期望销售量 $S_g^{\\text{tot}}(t) = \\sum_{i: n_{i,g}(t)<0} (-n_{i,g}(t))$。\n    - 实际交易的商品 $g$ 的数量为 $T_g(t) = \\rho \\cdot \\min(B_g(t), S_g^{\\text{tot}}(t))$。\n    - 买方 $i$ 获得的数量 $q_{i,g}(t)$ 和卖方 $j$ 交出的数量 $s_{j,g}(t)$ 与他们的期望交易量成正比。对于买方 $i$，$q_{i,g}(t) = T_g(t) \\cdot n_{i,g}(t) / B_g(t)$（如果 $B_g(t)>0$），对于卖方 $j$，$s_{j,g}(t) = T_g(t) \\cdot (-n_{j,g}(t)) / S_g^{\\text{tot}}(t)$（如果 $S_g^{\\text{tot}}(t)>0$）。\n    - 然后根据这些交易更新下一时期 $t+1$ 的禀赋：\n    $$\n    e_{i,g}(t+1) = e_{i,g}(t) + q_{i,g}(t) - s_{i,g}(t).\n    $$\n    如果 $\\rho=0$，则没有交易发生，对所有 $i,g,t$ 都有 $e_{i,g}(t+1) = e_{i,g}(t)$。\n\n4.  **价格更新**：下一时期的价格根据当前时期的超额需求进行调整。商品 $g$ 的未归一化价格使用指数规则更新：\n    $$\n    p'_{t+1,g} = p_{t,g} \\cdot \\exp\\left( \\eta \\cdot \\frac{z_g(t)}{S_g} \\right).\n    $$\n    此规则提高了超额需求为正的商品的价格，并降低了超额需求为负的商品的价格，确保价格保持为正。步长 $\\eta>0$ 控制调整速度。\n\n5.  **价格归一化**：为防止价格发散并确定一个记账单位，价格向量被归一化。选择商品2作为计价物，意味着其价格被设为1。时期 $t+1$ 的价格为：\n    $$\n    p_{t+1,1} = \\frac{p'_{t+1,1}}{p'_{t+1,2}} \\quad \\text{和} \\quad p_{t+1,2} = 1.\n    $$\n    这样就完成了一次迭代。模拟使用更新后的禀赋 $e(t+1)$ 和价格 $p_{t+1}$ 继续进行。如果在 $T_{\\max}$ 次迭代内未达到收敛标准，循环终止并报告最终计算出的价格 $p_{T_{\\max},1}$。\n\n整个过程被封装在一个数值算法中，并应用于四个指定的测试用例，以确定商品1的最终均衡或近均衡价格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(alpha_A, alpha_B, e_A_0, e_B_0, p_0, eta, rho, eps, T_max):\n    \"\"\"\n    Simulates the non-Walrasian tâtonnement process for a single case.\n\n    Args:\n        alpha_A (float): Cobb-Douglas parameter for agent A.\n        alpha_B (float): Cobb-Douglas parameter for agent B.\n        e_A_0 (tuple): Initial endowment for agent A (good 1, good 2).\n        e_B_0 (tuple): Initial endowment for agent B (good 1, good 2).\n        p_0 (tuple): Initial prices (p1, p2).\n        eta (float): Price adjustment step parameter.\n        rho (float): Per-round trade limit.\n        eps (float): Convergence tolerance.\n        T_max (int): Maximum number of iterations.\n\n    Returns:\n        float: The final normalized price of good 1.\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    alphas = np.array([alpha_A, alpha_B])\n    endowments = np.array([e_A_0, e_B_0], dtype=np.float64)\n    prices = np.array(p_0, dtype=np.float64)\n\n    # Aggregate supply (total endowment) is constant throughout the simulation\n    S_total = np.sum(endowments, axis=0)\n\n    for _ in range(T_max):\n        # Step 1: Calculate Demands and Excess Demands\n        # Budgets: m_i = p . e_i\n        budgets = np.dot(endowments, prices)\n        \n        # Demands: d_i,g\n        demands = np.zeros_like(endowments)\n        # Agent A's demands\n        demands[0, 0] = alphas[0] * budgets[0] / prices[0]\n        demands[0, 1] = (1 - alphas[0]) * budgets[0] / prices[1]\n        # Agent B's demands\n        demands[1, 0] = alphas[1] * budgets[1] / prices[0]\n        demands[1, 1] = (1 - alphas[1]) * budgets[1] / prices[1]\n        \n        # Aggregate Demand and Excess Demand\n        D_total = np.sum(demands, axis=0)\n        z = D_total - S_total\n\n        # Step 2: Check for Convergence\n        if np.max(np.abs(z)) <= eps:\n            return prices[0]\n\n        # Step 3: Rationed Trade and Endowment Update\n        # This step is skipped if rho is 0, as no trade occurs.\n        if rho > 0:\n            net_desired_trades = demands - endowments\n            e_next = endowments.copy()\n\n            for g in range(2):  # For each good\n                n_g = net_desired_trades[:, g]\n                \n                # Identify buyers and sellers\n                buyers_mask = n_g > 1e-12 # Use a small tolerance for floating point\n                sellers_mask = n_g < -1e-12\n\n                # Total desired purchases and sales\n                B_g = np.sum(n_g[buyers_mask])\n                S_g_tot = -np.sum(n_g[sellers_mask])\n\n                if B_g > 0 and S_g_tot > 0:\n                    # Actual quantity of good g traded\n                    T_g = rho * min(B_g, S_g_tot)\n                    \n                    # Rationed quantities and endowment updates\n                    # For buyers of good g\n                    q_ig = T_g * (n_g[buyers_mask] / B_g)\n                    e_next[buyers_mask, g] += q_ig\n                    \n                    # For sellers of good g\n                    s_ig = T_g * (-n_g[sellers_mask] / S_g_tot)\n                    e_next[sellers_mask, g] -= s_ig\n            \n            endowments = e_next\n        \n        # Step 4 & 5: Price Update and Normalization\n        # Update unnormalized prices\n        # Protect against division by zero if S_total[g] is somehow 0\n        update_ratios = np.divide(z, S_total, out=np.zeros_like(z), where=S_total!=0)\n        p_next_unnormalized = prices * np.exp(eta * update_ratios)\n        \n        # Normalize prices using good 2 as numeraire\n        if p_next_unnormalized[1] > 0:\n            prices = p_next_unnormalized / p_next_unnormalized[1]\n        # If p_next_unnormalized[1] hits zero, stop to avoid errors\n        else:\n            break\n            \n    return prices[0]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path\n        # (alpha_A, alpha_B), e_A(0), e_B(0), p_0, eta, rho, eps, T_max\n        (0.5, 0.5, (1.0, 0.0), (0.0, 1.0), (2.0, 1.0), 0.2, 0.5, 1e-8, 10000),\n        # Case 2: Boundary (initially clearing prices)\n        (0.5, 0.5, (1.0, 0.0), (0.0, 1.0), (1.0, 1.0), 0.2, 0.7, 1e-10, 10000),\n        # Case 3: Edge (no trade allowed)\n        (0.5, 0.5, (1.0, 0.0), (0.0, 1.0), (3.0, 1.0), 0.3, 0.0, 1e-8, 10000),\n        # Case 4: Asymmetric preferences and endowments\n        (0.8, 0.2, (2.0, 0.5), (0.5, 1.0), (0.4, 1.0), 0.2, 1.0, 1e-8, 20000),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha_A, alpha_B, e_A_0, e_B_0, p_0, eta, rho, eps, T_max = case\n        result = solve_case(alpha_A, alpha_B, e_A_0, e_B_0, p_0, eta, rho, eps, T_max)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}