{"hands_on_practices": [{"introduction": "在我们投入资源进行并行化之前，理解其潜在的性能收益上限至关重要。阿姆达尔定律（Amdahl's Law）为我们提供了评估这种理论极限的基本框架，它揭示了任何计算任务中固有的顺序部分将最终成为性能瓶颈。本练习通过一个来自中央银行压力测试的现实场景，让你亲手计算这一速度提升的上限，从而深化对并行计算局限性的理解。[@problem_id:2417876]", "id": "2417876", "problem": "一家中央银行运行一个大规模的宏观金融压力测试流程，该流程包含 $2$ 个阶段：一个严格串行的数据收集和清理阶段，以及一个可以在独立场景间以可忽略的开销完美并行化的蒙特卡洛模拟阶段。在单核基准上，模拟阶段占总运行时间的 $0.99$。设加速比为单核运行时间与在一台拥有 $N$ 个相同核心的机器上的运行时间之比，其中只有模拟阶段被并行化，而串行阶段保持严格串行。在 $N \\to \\infty$ 的极限情况下，相对于单核基准的理论最大加速比是多少？请以无单位的精确数字形式提供答案。", "solution": "在尝试任何解答之前，将对所述问题进行验证。\n\n首先，我们逐字提取给定的信息。\n1.  该过程包括 $2$ 个阶段：一个严格串行的数据收集阶段和一个可完美并行化的蒙特卡洛模拟阶段。\n2.  可并行化的模拟阶段占总单核运行时间的分数是 $0.99$。设此分数为 $P$。因此，$P = 0.99$。\n3.  加速比 $S(N)$ 定义为单核运行时间与在一台拥有 $N$ 个相同核心的机器上的运行时间之比。\n4.  目标是求出当核心数 $N$ 趋于无穷大时，理论上的最大加速比。\n\n其次，我们验证该问题。该问题是 Amdahl's Law 的直接应用，这是并行计算中的一个基本概念。所描述的场景是科学和工程领域（包括计算金融）中计算流程的一个经典且现实的模型。该问题是自洽的、有科学依据的、且是适定的。所有术语都有明确定义，没有信息缺失或矛盾。因此，该问题被认为是有效的，并将制定解决方案。\n\n解决方案遵循 Amdahl's Law 的原则。设 $T_1$ 为单核上的总运行时间。这个总时间可以分解为一个串行部分和一个可并行化部分。\n\n任务中严格串行的部分占比为 $1 - P$。这部分所花费的时间是 $T_{seq} = (1 - P) T_1$。\n任务中可并行化的部分占比为 $P$。这部分在单核上所花费的时间是 $T_{par} = P T_1$。\n\n根据问题陈述，$P = 0.99$。\n因此，串行部分的占比是 $1 - P = 1 - 0.99 = 0.01$。\n\n当任务在具有 $N$ 个核心的系统上运行时，任务的串行部分保持不变，耗时 $T_{seq}$。而可并行化部分则分布在 $N$ 个核心上。假设是开销可忽略的完美并行化，这部分的时间变为 $\\frac{T_{par}}{N}$。\n\n在 $N$ 个核心上的总运行时间 $T(N)$ 是这两个部分执行时间的总和：\n$$T(N) = T_{seq} + \\frac{T_{par}}{N} = (1 - P) T_1 + \\frac{P T_1}{N}$$\n\n加速比 $S(N)$ 定义为单核运行时间与 $N$ 核运行时间之比：\n$$S(N) = \\frac{T_1}{T(N)} = \\frac{T_1}{(1 - P) T_1 + \\frac{P T_1}{N}}$$\n\n项 $T_1$ 是分子和分母中的公因子，可以消去，这是符合预期的，因为加速比是一个相对度量：\n$$S(N) = \\frac{1}{(1 - P) + \\frac{P}{N}}$$\n\n问题要求的是理论最大加速比，这在核心数 $N$ 趋于无穷大的极限情况下实现。我们必须评估 $S(N)$ 在 $N \\to \\infty$ 时的极限。\n$$S_{max} = \\lim_{N \\to \\infty} S(N) = \\lim_{N \\to \\infty} \\frac{1}{(1 - P) + \\frac{P}{N}}$$\n\n当 $N \\to \\infty$ 时，项 $\\frac{P}{N}$ 趋近于 $0$，因为 $P$ 是一个有限常数。\n$$\\lim_{N \\to \\infty} \\frac{P}{N} = 0$$\n\n因此，加速比函数的极限是：\n$$S_{max} = \\frac{1}{(1 - P) + 0} = \\frac{1}{1 - P}$$\n\n这个结果是 Amdahl's Law 的核心论述：最大加速比受代码串行部分的限制。\n\n将给定值 $P = 0.99$ 代入最大加速比的表达式中：\n$$S_{max} = \\frac{1}{1 - 0.99} = \\frac{1}{0.01}$$\n\n计算此表达式得出最终答案。\n$$S_{max} = 100$$\n这是给定流程的理论最大加速比，无论在某一点之后增加多少处理器都无法超越。性能的根本瓶颈在于必须串行完成的 $1\\%$ 的工作。", "answer": "$$\n\\boxed{100}\n$$"}, {"introduction": "将模型并行化不仅仅是为了追求速度，更关键的是要确保并行实现能够忠实地反映原始模型的逻辑。本练习以经典的古诺（Cournot）双头垄断模型为例，展示了如果未能正确同步“同时决策”这一行为，将如何导致错误的模拟结果，实际上是模拟了一个完全不同的序贯博弈场景。通过对比同步与非同步两种情况，本练习凸显了像“栅栏”（barrier）这样的同步原语在保证模型正确性方面的核心作用。[@problem_id:2417917]", "id": "2417917", "problem": "要求您编写一个完整的、可运行的程序，该程序使用两个独立的线程，在离散的时间步长中对一个 Cournot 双寡头垄断模型进行建模，其中两家公司同时选择产量。程序必须证明，为了将索引为 $t \\in \\{0,1,2,\\dots\\}$ 的离散时间步长正确地建模为同步决策，需要使用屏障同步，以确保两家公司在步骤 $t$ 从同一状态进行更新，并将其更新同步提交到步骤 $t+1$。您将比较一个使用屏障的同步模拟与一个有意设计的、不施加同步读取约束的非同步序贯更新模拟，并突显后者中的建模错误。\n\n将使用的基本核心定义：\n- 设逆需求函数为 $P(Q) = a - b Q$，其中 $a > 0, b > 0$，总产量为 $Q = q_1 + q_2$，公司 $i$ 的恒定边际成本为 $c_i \\ge 0$。公司 $i$ 的利润为 $\\pi_i(q_i,q_j) = \\left(P(q_i+q_j) - c_i\\right) q_i$。\n- 在 Cournot 竞争中，在任意时间步长 $t$，每家公司 $i$ 会选择 $q_i^{t+1}$，以在给定竞争对手在时间 $t$ 的产量的情况下最大化其利润。存在非负约束 $q_i^{t+1} \\ge 0$。\n- 离散时间同步博弈所预期的步进更新是，两家公司仅使用步骤 $t$ 的信息来计算 $q_i^{t+1}$，然后原子性地提交 $q^{t+1}$。这要求线程之间进行屏障同步，以确保两家公司都读取相同的过去状态，并且它们的写入操作在离散时间边界上同步提交。\n- 相反，如果没有屏障来强制同步读取和提交，一个线程可以提前更新，而另一个线程可能会读取一个部分更新的状态，从而违反了在 $t$ 和 $t+1$ 边界上同步决策的预期模型。\n\n您的程序必须：\n1. 从第一性原理出发，通过最大化 $\\pi_i(q_i,q_j)$（在 $q_i \\ge 0$ 的约束下）推导并实现公司 $i$ 针对 $q_j$ 的唯一最优反应 $BR_i(q_j)$。在所有更新中使用推导出的 $BR_i(q_j)$。\n2. 从给定的初始产量 $(q_1^0,q_2^0)$ 开始，为 $T$ 个离散步骤实现双线程模拟：\n   - 带屏障的同步模拟：两个线程代表两家公司。在每个步骤 $t$，两者都仅使用 $(q_1^t,q_2^t)$ 计算 $q_i^{t+1} = BR_i(q_j^t)$，并在屏障处原子性地提交对 $(q_1^{t+1},q_2^{t+1})$，以便两者都从步骤 $t$ 读取完全相同的状态。\n   - 不带屏障的非同步序贯模拟：两个线程代表两家公司，但不协调同步读取。在每个步骤内，强制执行一个确定性的序贯更新顺序：公司1首先使用 $q_2^t$ 进行更新，并立即写入 $q_1^{t+1}$；然后公司2读取这个已更新的 $q_1^{t+1}$ 并写入 $q_2^{t+1}$。这种构造有意违反了同步决策，以说明在没有屏障的情况下出现的建模错误。\n3. 通过在非负约束下求解 Cournot 均衡，计算静态 Nash 均衡 $(q_1^\\star,q_2^\\star)$。如果无约束均衡对两个 $i$ 都得出 $q_i^\\star \\ge 0$，则使用内部解。如果一个无约束的 $q_i^\\star$ 为负，则通过将该 $q_i^\\star = 0$ 来强制执行角点解，并重新计算另一家公司对这个零产量的最优反应；如果两者都为负，则设置 $(q_1^\\star,q_2^\\star) = (0,0)$。\n4. 对每个测试用例，从指定的初始状态开始，为指定的步数 $T$ 运行两种模拟。然后计算并报告：\n   - 步骤 $T$ 时同步和非同步最终产量之间的最大绝对差：\n     $$ d = \\max\\left\\{ \\left| q_1^{T,\\mathrm{sync}} - q_1^{T,\\mathrm{unsync}} \\right|, \\left| q_2^{T,\\mathrm{sync}} - q_2^{T,\\mathrm{unsync}} \\right| \\right\\}. $$\n   - 同步最终状态相对于静态均衡的误差的欧几里得范数：\n     $$ e_{\\mathrm{sync}} = \\sqrt{\\left(q_1^{T,\\mathrm{sync}} - q_1^\\star\\right)^2 + \\left(q_2^{T,\\mathrm{sync}} - q_2^\\star\\right)^2}. $$\n   - 非同步最终状态相对于静态均衡的误差的欧几里得范数：\n     $$ e_{\\mathrm{unsync}} = \\sqrt{\\left(q_1^{T,\\mathrm{unsync}} - q_1^\\star\\right)^2 + \\left(q_2^{T,\\mathrm{unsync}} - q_2^\\star\\right)^2}. $$\n\n用于覆盖不同方面的测试套件：\n- 案例A（正常路径；对称成本；单步差异最明显）：$a = 100$, $b = 1$, $c_1 = 10$, $c_2 = 10$, $T = 1$, 初始 $(q_1^0,q_2^0) = (0,0)$。\n- 案例B（非对称成本；多步；内部均衡）：$a = 90$, $b = 1.5$, $c_1 = 10$, $c_2 = 30$, $T = 5$, 初始 $(q_1^0,q_2^0) = (0,0)$。\n- 案例C（一个公司的非负约束生效的边界情况）：$a = 40$, $b = 2$, $c_1 = 50$, $c_2 = 4$, $T = 3$, 初始 $(q_1^0,q_2^0) = (0,0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，每个内部列表对应一个测试用例，并按该确切顺序包含三个浮点值 $[d, e_{\\mathrm{sync}}, e_{\\mathrm{unsync}}]$。输出必须以以下格式打印为单行：\n  \"[[d_A,e_sync_A,e_unsync_A],[d_B,e_sync_B,e_unsync_B],[d_C,e_sync_C,e_unsync_C]]\"\n  其中每个浮点数应以小数点后六位的定点形式呈现。不应打印任何额外文本。\n不涉及物理单位。所有角度（如有）均不适用。所有比率必须以小数表示。", "solution": "问题陈述经过验证，确认为有效。它在已建立的经济学理论（Cournot 竞争）和计算科学（并行同步）方面具有科学依据。该问题是适定的，为获得唯一、可验证的解决方案提供了所有必要的参数和定义。没有矛盾、歧义或事实错误。因此，我们可以进行形式化的求解。\n\n问题的核心是为一个离散时间的 Cournot 双寡头垄断建模。首先，我们必须推导出每家公司的最优反应函数，该函数定义了其在给定竞争对手产量的情况下的最优产量选择。\n\n公司 $i$ 的利润 $\\pi_i$ 由其收入减去其成本给出：\n$$ \\pi_i(q_i, q_j) = P(Q)q_i - c_i q_i $$\n其中 $Q = q_i + q_j$，逆需求函数为 $P(Q) = a - b Q$，$c_i$ 是恒定边际成本。代入需求函数，我们得到：\n$$ \\pi_i(q_i, q_j) = (a - b(q_i + q_j) - c_i)q_i = aq_i - bq_i^2 - bq_j q_i - c_i q_i $$\n为了找到使该利润最大化的产量 $q_i$，我们对其关于 $q_i$ 求一阶偏导数并将其设为零，这是一阶最大化条件：\n$$ \\frac{\\partial \\pi_i}{\\partial q_i} = a - 2bq_i - bq_j - c_i = 0 $$\n解出 $q_i$ 得到无约束的反应函数：\n$$ 2bq_i = a - c_i - bq_j \\implies q_i = \\frac{a - c_i - bq_j}{2b} $$\n最大化的二阶条件得到满足，因为 $\\frac{\\partial^2 \\pi_i}{\\partial q_i^2} = -2b < 0$ (由于给定 $b > 0$)。然而，公司不能生产负数量的产量，因此我们必须强制执行非负约束 $q_i \\ge 0$。因此，最优反应函数 $BR_i(q_j)$ 是：\n$$ BR_i(q_j) = \\max\\left\\{0, \\frac{a - c_i - bq_j}{2b}\\right\\} $$\n\n接下来，我们确定静态 Cournot-Nash 均衡 $(q_1^\\star, q_2^\\star)$，这是一种稳定状态，在此状态下，任何一家公司都没有单方面改变其产量的动机。这发生在两家公司同时处于其最优反应曲线上时，即 $q_1^\\star = BR_1(q_2^\\star)$ 且 $q_2^\\star = BR_2(q_1^\\star)$。\n假设存在一个内部解，其中 $q_1^\\star > 0$ 且 $q_2^\\star > 0$，我们求解以下线性方程组：\n$$ q_1^\\star = \\frac{a - c_1 - bq_2^\\star}{2b} $$\n$$ q_2^\\star = \\frac{a - c_2 - bq_1^\\star}{2b} $$\n将 $q_2^\\star$ 的表达式代入第一个方程并解出 $q_1^\\star$，可得：\n$$ q_1^\\star = \\frac{a - 2c_1 + c_2}{3b} $$\n根据对称性，公司2的均衡产量为：\n$$ q_2^\\star = \\frac{a - 2c_2 + c_1}{3b} $$\n如果这些公式对某家公司得出了负产量，例如 $q_i^\\star < 0$，其均衡产量必须在边界上，即 $q_i^\\star = 0$。另一家公司 $j$ 则会对这个零产量做出反应：$q_j^\\star = BR_j(0) = \\max\\{0, (a-c_j)/(2b)\\}$。如果两个无约束产量均为负，则均衡为 $(q_1^\\star, q_2^\\star) = (0,0)$。\n\n该问题要求比较两种在 $T$ 个时间步长内、从初始状态 $(q_1^0, q_2^0)$ 开始的动态模拟模型。两种模型都使用两个线程实现，每个线程代表一家公司。\n\n1. **同步模拟**：这正确地模拟了 Cournot 竞争在离散时间中的同步行动性质。在每个步骤 $t$，两家公司都必须基于*相同*的信息来决定其在步骤 $t+1$ 的产量，这个信息就是市场在时间 $t$ 的状态，即 $(q_1^t, q_2^t)$。\n$$ q_1^{t+1} = BR_1(q_2^t) $$\n$$ q_2^{t+1} = BR_2(q_1^t) $$\n为了在多线程程序中强制执行这一点，必须使用同步屏障。线程们根据时间 $t$ 的共享状态计算它们的下一个产量。然后它们在一个屏障处等待。在所有线程都到达屏障后，步骤 $t+1$ 的新产量将被提交到共享状态。这确保了没有线程可以在计算其自身的 $t+1$ 值时读取到步骤 $t+1$ 的部分更新状态。这是求解线性系统的 Jacobi 方法的计算模拟。\n\n2. **非同步序贯模拟**：此模拟通过省略同步屏障来有意引入建模错误。它强制采用一种确定性的更新顺序：公司1首先更新，公司2随后更新。\n$$ q_1^{t+1} = BR_1(q_2^t) $$\n$$ q_2^{t+1} = BR_2(q_1^{t+1}) $$\n在这里，公司2对步骤 $t+1$ 的决策是基于公司1在步骤 $t+1$ 的产量，而不是 $t$ 的产量。这违反了同步行动的原则。它模拟了一种序贯行动的动态，其中在每个时间步内，公司1是领导者，公司2是跟随者。这对应于 Gauss-Seidel 方法。该模拟的轨迹与同步模拟的轨迹之间的差异，突显了在模拟并行或同步事件中正确同步的至关重要性。\n\n程序将实现这两种模拟，为给定的测试用例计算指定的指标（$d$、$e_{\\mathrm{sync}}$、$e_{\\mathrm{unsync}}$），并展示由非同步情况下的建模错误所引起的发散。同步模型的实现将使用 `threading` 模块和一个 `Barrier` 来正确地模拟同步读取然后同步提交的逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport threading\nfrom collections import namedtuple\n\n# Define data structure for problem parameters\nCaseParams = namedtuple('CaseParams', ['a', 'b', 'c1', 'c2', 'T', 'q0'])\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path, symmetric costs\n        CaseParams(a=100.0, b=1.0, c1=10.0, c2=10.0, T=1, q0=np.array([0.0, 0.0])),\n        # Case B: Asymmetric costs, multiple steps\n        CaseParams(a=90.0, b=1.5, c1=10.0, c2=30.0, T=5, q0=np.array([0.0, 0.0])),\n        # Case C: Boundary case, non-negativity constraint binding\n        CaseParams(a=40.0, b=2.0, c1=50.0, c2=4.0, T=3, q0=np.array([0.0, 0.0])),\n    ]\n\n    results = []\n    for params in test_cases:\n        results.append(solve_case(params))\n\n    # Format the final output string as specified\n    formatted_results = [\n        f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef best_response(q_other, a, b, c):\n    \"\"\"\n    Calculates the best response for a firm given the other's quantity.\n    BR_i(q_j) = max(0, (a - c_i - b*q_j) / (2*b))\n    \"\"\"\n    num = a - c - b * q_other\n    den = 2.0 * b\n    return max(0.0, num / den)\n\ndef calculate_nash_equilibrium(params):\n    \"\"\"\n    Calculates the static Cournot-Nash equilibrium quantities.\n    Handles both interior and corner solutions.\n    \"\"\"\n    a, b, c1, c2 = params.a, params.b, params.c1, params.c2\n    \n    # Calculate unconstrained interior solution\n    q1_star_unconstrained = (a - 2.0 * c1 + c2) / (3.0 * b)\n    q2_star_unconstrained = (a - 2.0 * c2 + c1) / (3.0 * b)\n\n    if q1_star_unconstrained >= 0 and q2_star_unconstrained >= 0:\n        return np.array([q1_star_unconstrained, q2_star_unconstrained])\n    \n    # Handle corner solutions\n    q1_star, q2_star = 0.0, 0.0\n    if q1_star_unconstrained < 0 and q2_star_unconstrained < 0:\n        # If both would be negative, both produce 0\n        q1_star, q2_star = 0.0, 0.0\n    elif q1_star_unconstrained < 0:\n        # Firm 1 is non-competitive, check firm 2's monopoly power\n        q1_star = 0.0\n        q2_star = best_response(0.0, a, b, c2)\n    elif q2_star_unconstrained < 0:\n        # Firm 2 is non-competitive, check firm 1's monopoly power\n        q2_star = 0.0\n        q1_star = best_response(0.0, a, b, c1)\n\n    return np.array([q1_star, q2_star])\n\ndef simulate_synchronized(params):\n    \"\"\"\n    Performs the synchronous simulation using two threads and a barrier.\n    This correctly models simultaneous moves.\n    \"\"\"\n    q_state = [params.q0.copy(), np.zeros(2)] # Double buffer for current and next state\n    read_idx, write_idx = 0, 1\n    \n    barrier = threading.Barrier(2)\n\n    def firm_worker(firm_id):\n        nonlocal read_idx, write_idx\n        my_c = params.c1 if firm_id == 0 else params.c2\n        other_firm_id = 1 - firm_id\n\n        for _ in range(params.T):\n            # Read from the same state (t)\n            q_other = q_state[read_idx][other_firm_id]\n            \n            # Compute own next quantity for state (t+1)\n            my_next_q = best_response(q_other, params.a, params.b, my_c)\n            q_state[write_idx][firm_id] = my_next_q\n            \n            # Wait at barrier for other firm to finish its calculation\n            barrier.wait()\n            \n            # One thread swaps buffers for the next iteration\n            if firm_id == 0:\n                read_idx, write_idx = write_idx, read_idx\n            \n            # Second barrier to ensure buffers are swapped before next read starts\n            barrier.wait()\n\n    thread1 = threading.Thread(target=firm_worker, args=(0,))\n    thread2 = threading.Thread(target=firm_worker, args=(1,))\n    \n    thread1.start()\n    thread2.start()\n    \n    thread1.join()\n    thread2.join()\n    \n    return q_state[read_idx]\n\ndef simulate_unsynchronized(params):\n    \"\"\"\n    Performs the unsynchronized sequential simulation.\n    This demonstrates the modeling error from lack of synchronization.\n    \"\"\"\n    q = params.q0.copy()\n    a, b, c1, c2, T = params.a, params.b, params.c1, params.c2, params.T\n    \n    for _ in range(T):\n        # Firm 1 updates first, based on q from step t\n        q1_next = best_response(q[1], a, b, c1)\n        q[0] = q1_next\n        \n        # Firm 2 updates second, based on the *new* q1 from step t+1\n        q2_next = best_response(q[0], a, b, c2)\n        q[1] = q2_next\n        \n    return q\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single test case: calculates equilibrium, runs simulations,\n    and computes the required output metrics.\n    \"\"\"\n    q_star = calculate_nash_equilibrium(params)\n    \n    q_sync_final = simulate_synchronized(params)\n    q_unsync_final = simulate_unsynchronized(params)\n\n    # Calculate metrics\n    d = np.max(np.abs(q_sync_final - q_unsync_final))\n    e_sync = np.linalg.norm(q_sync_final - q_star)\n    e_unsync = np.linalg.norm(q_unsync_final - q_star)\n    \n    return d, e_sync, e_unsync\n\n# Run the solver\nsolve()\n\n```"}, {"introduction": "即便一个问题已经被正确地并行化，其性能有时仍会因硬件的运作方式（特别是CPU缓存）而意外受损。本练习将引导你探索一个微妙的性能陷阱——“伪共享”（false sharing），即当多个处理器核心更新位于同一缓存行（cache line）的不同数据时，会因缓存一致性协议而相互干扰，导致性能下降。通过一个简化的模型，你将能够量化由伪共享引起的性能衰减，从而学会在高性能计算中关注数据布局的重要性。[@problem_id:2417854]", "id": "2417854", "problem": "我们给出了一个关于一维住户网格并行模拟中“伪共享”问题的简化第一性原理模型。总共有 $N$ 个住户，索引为 $h_0,h_1,\\dots,h_{N-1}$，并在内存中连续排列。内存系统使用的缓存行每个可以精确容纳 $L$ 个住户，因此住户 $h_i$ 的缓存行标识符为 $\\ell(i)=\\left\\lfloor i/L \\right\\rfloor$。存在 $K$ 个相同的工作单元（可理解为中央处理器(CPU)的核心），时间以离散的轮次 $r\\in\\{0,1,\\dots,R-1\\}$ 推进，其中 $R=\\lceil N/K \\rceil$。在每个轮次 $r$ 中，每个工作单元 $k\\in\\{0,1,\\dots,K-1\\}$ 最多更新一个住户，具体为索引 $i=k+rK$ 的住户（如果 $i&lt;N$）；否则，该工作单元在本轮次中处于空闲状态。\n\n每次住户更新都是一次单独的写入操作。单次写入的基础时间为 $c&gt;0$。如果在同一轮次 $r$ 中，多个工作单元更新了映射到同一缓存行的住户，缓存一致性将导致如下额外延迟。对于任何轮次 $r$ 和任何缓存行 $x$，我们将 $m_x(r)$ 定义为在轮次 $r$ 中，目标住户的 $\\ell(i)=x$ 的更新次数。轮次 $r$ 的实际运行时长为\n$$\nt_r \\;=\\; c \\;+\\; p\\cdot\\big(\\max_{x} m_x(r) - 1\\big),\n$$\n我们约定，如果一个轮次中没有活动的工作单元，则该轮次不发生。在这种交错调度下，执行过程模拟的总实际运行时长为\n$$\nT_{\\mathrm{interleaved}} \\;=\\; \\sum_{r=0}^{R-1} t_r.\n$$\n\n作为对比，我们考虑一种无冲突的填充布局情景，其中住户在内存中通过填充进行布局，以确保任意两个同时更新的住户都不会共享同一个缓存行（实际上是每个缓存行一个住户）。在相同的索引调度下，每个至少有一个活动工作单元的轮次的时长恰好为 $c$，因此\n$$\nT_{\\mathrm{padded}} \\;=\\; R\\cdot c.\n$$\n\n定义减速因子为\n$$\nS \\;=\\; \\frac{T_{\\mathrm{interleaved}}}{T_{\\mathrm{padded}}}.\n$$\n\n您的任务是实现一个程序，为每个指定的测试用例计算如上定义的减速因子 $S$。\n\n测试套件：\n- 用例 1: $(N,K,L,c,p) = ($16$,$2$,$2$,$1.0$,$0.5$)$.\n- 用例 2: $(N,K,L,c,p) = ($16$,$2$,$1$,$1.0$,$10.0$)$.\n- 用例 3: $(N,K,L,c,p) = ($17$,$1$,$8$,$1.0$,$2.0$)$.\n- 用例 4: $(N,K,L,c,p) = ($100$,$4$,$4$,$2.0$,$0.0$)$.\n- 用例 5: $(N,K,L,c,p) = ($32$,$4$,$4$,$1.0$,$1.0$)$.\n\n答案规格：\n- 对于每个用例，以十进制数形式输出减速因子 $S$。\n- 您的程序应生成单行输出，其中包含所有用例的结果，格式为方括号括起来的逗号分隔列表，顺序与上述用例一致，且每个数字精确到小数点后三位（例如，[$1.000$,$1.500$]）。", "solution": "我们对问题陈述进行了审查，并确认其是有效的。该问题在科学上基于并行计算的原理，特别是缓存一致性系统中的“伪共享”概念。这是一个适定的问题，所有变量、常数和函数关系都有明确的定义，从而允许存在一个唯一且稳定的解。其语言客观，设定内部一致且完备。\n\n目标是计算减速因子 $S$，其定义为交错并行调度下的总执行时间 $T_{\\text{interleaved}}$ 与无冲突的填充调度下的总执行时间 $T_{\\text{padded}}$ 之比。\n$$\nS = \\frac{T_{\\text{interleaved}}}{T_{\\text{padded}}}\n$$\n计算过程是，对于一组给定的参数 $(N, K, L, c, p)$，分别确定 $T_{\\text{padded}}$ 和 $T_{\\text{interleaved}}$。其中 $N$ 是住户数量， $K$ 是工作单元数量， $L$ 是缓存行大小（以住户数量计），$c$ 是基础写入成本，而 $p$ 是冲突惩罚系数。\n\n首先，我们计算填充布局下的总时间 $T_{\\text{padded}}$。模拟以离散的轮次 $r$ 进行。使用 $K$ 个工作单元处理所有 $N$ 个住户所需的总轮次数为 $R = \\lceil N/K \\rceil$。在填充布局中，伪共享被消除，因此每个至少有一个活动工作单元的轮次耗时为一个恒定的时间 $c$。可以证明，对于所有轮次 $r \\in \\{0, 1, \\dots, R-1\\}$，至少工作单元 $k=0$ 是活动的，因为其目标索引 $i=rK$ 满足 $rK < (\\lceil N/K \\rceil)K$，这意味着 $rK \\le (N/K)K = N$，并且当 $r < N/K$ 时，严格不等式成立。对于最后一个轮次 $r=R-1$，我们有 $(R-1)K < N$，所以工作单元0始终是活动的。因此，所有 $R$ 个轮次都是活动的，总时间为：\n$$\nT_{\\text{padded}} = R \\cdot c\n$$\n\n接下来，我们计算交错布局下的总时间 $T_{\\text{interleaved}}$。该时间是每个单独轮次时长 $t_r$ 的总和：\n$$\nT_{\\text{interleaved}} = \\sum_{r=0}^{R-1} t_r\n$$\n单个轮次 $r$ 的时长取决于同时访问同一缓存行的最大工作单元数量。该时长由下式给出：\n$$\nt_r = c + p \\cdot \\left(\\max_{x} m_x(r) - 1\\right)\n$$\n其中 $m_x(r)$ 是在第 $r$ 轮中对位于缓存行 $x$ 上的住户的更新次数。为了计算 $t_r$，我们必须首先找到 $\\max_{x} m_x(r)$。\n\n对于从0到 $R-1$ 的每个轮次 $r$，算法如下：\n1.  确定本轮次中更新的住户索引集合。对于每个工作单元 $k \\in \\{0, 1, \\dots, K-1\\}$，其目标索引为 $i = k + rK$。只有当 $i < N$ 时才会发生更新。\n2.  对于每个此类活动索引 $i$，确定其缓存行标识符 $\\ell(i) = \\lfloor i/L \\rfloor$。\n3.  计算每个唯一的缓存行标识符出现的次数。这将为本轮次中访问的所有缓存行 $x$ 提供 $m_x(r)$ 的值。\n4.  确定最大计数值 $\\max_{x} m_x(r)$。我们将其记为 $M_r$。\n5.  计算轮次时长 $t_r = c + p \\cdot (M_r - 1)$。\n6.  将所有轮次的这些时长相加以获得 $T_{\\text{interleaved}}$。\n\n最后，使用两个总时间的比率计算减速因子 $S$。对问题中指定的每个测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test cases and print the results.\n    \"\"\"\n    # Test suite as defined in the problem statement.\n    test_cases = [\n        # (N, K, L, c, p)\n        (16, 2, 2, 1.0, 0.5),\n        (16, 2, 1, 1.0, 10.0),\n        (17, 1, 8, 1.0, 2.0),\n        (100, 4, 4, 2.0, 0.0),\n        (32, 4, 4, 1.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for each case\n        N, K, L, c, p = case\n        # Calculate the slowdown factor\n        result = calculate_slowdown(N, K, L, c, p)\n        # Format the result to three decimal places as a string.\n        results.append(f\"{result:.3f}\")\n\n    # Print the final list of results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_slowdown(N, K, L, c, p):\n    \"\"\"\n    Computes the slowdown factor S for a given set of parameters.\n\n    Args:\n        N (int): Total number of households.\n        K (int): Number of workers.\n        L (int): Number of households per cache line.\n        c (float): Base time for a single write.\n        p (float): Penalty coefficient for cache conflicts.\n\n    Returns:\n        float: The slowdown factor S.\n    \"\"\"\n    # The total number of rounds, R, is the ceiling of N/K.\n    R = int(np.ceil(N / K))\n\n    # The total time for the padded, conflict-free layout is R * c.\n    # As established in the analysis, every round from 0 to R-1 has at least one\n    # active worker, so all R rounds take time c.\n    T_padded = R * c\n\n    # Calculate the total time for the interleaved layout by summing round durations.\n    T_interleaved = 0.0\n    for r in range(R):\n        # Determine the household indices accessed by all workers in this round.\n        indices_this_round = []\n        for k in range(K):\n            idx = k + r * K\n            if idx < N:\n                indices_this_round.append(idx)\n        \n        # A round r < R always has at least one active worker, so this list is not empty.\n        \n        # Map each household index to its corresponding cache line ID.\n        cache_lines_this_round = [idx // L for idx in indices_this_round]\n        \n        # Count the number of updates for each unique cache line to find the maximum contention.\n        # This corresponds to finding max_x m_x(r).\n        # np.unique with return_counts is an efficient method for this.\n        _, counts = np.unique(cache_lines_this_round, return_counts=True)\n        max_updates_on_a_line = np.max(counts)\n            \n        # Calculate the duration of the current round, t_r.\n        # The penalty is proportional to the number of excess workers on the most contended cache line.\n        t_r = c + p * (max_updates_on_a_line - 1)\n        T_interleaved += t_r\n    \n    # The slowdown factor S is the ratio of the two total times.\n    # Division by zero is not a risk as c > 0 and N > 0, which implies R > 0 and T_padded > 0.\n    slowdown = T_interleaved / T_padded\n    \n    return slowdown\n\n# Execute the main function to run the simulation and print the output.\nsolve()\n```"}]}