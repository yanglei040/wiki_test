{"hands_on_practices": [{"introduction": "动态模型的一个经典应用是生命周期消费储蓄问题。这个练习将基本模型扩展到包含遗赠动机，这改变了生命最后一期的优化问题，要求我们相应地调整内生网格法（EGM）的终点条件。通过完成这个练习 [@problem_id:2440058]，你将掌握在有限期界模型中应用 EGM 的完整流程，并学会如何使用该模型进行比较静态分析——在此案例中，是理解留下遗产的愿望如何影响储蓄行为，这是一项核心的经济学技能。", "id": "2440058", "problem": "您的任务是为一个在生命终点具有遗赠动机的有限期界、确定性生命周期消费储蓄模型，实现内生网格法（EGM）。代理人生活 $T$ 个消费期，由 $t \\in \\{0,1,\\ldots,T-1\\}$ 索引。他面临预算约束 $c_t + a_{t+1} = R a_t + y_t$，其中 $a_{t+1} \\ge \\underline{a}$，且初始资产 $a_0$ 已给定。偏好由以下公式给出：\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T),\n$$\n其中当 $\\gamma \\ne 1$ 时，$u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，而 $\\phi(a)$ 捕捉了遗赠动机。您将分析遗赠动机如何在整个生命周期中影响储蓄。\n\n基本基础和核心定义：\n- 当期预算约束为 $c_t + a_{t+1} = R a_t + y_t$，其中 $R$ 是总利率因子，$y_t$ 是外生收入。\n- 借贷约束为 $a_{t+1} \\ge \\underline{a}$，其中 $\\underline{a} \\in \\mathbb{R}$。\n- 代理人的目标是选择 $\\{c_t,a_{t+1}\\}_{t=0}^{T-1}$ 来最大化 $\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)$，并受限于各项约束。\n- 在内部解选择和无不确定性的情况下，一阶条件（欧拉方程）为：\n  - 对于 $t \\in \\{0,1,\\ldots,T-2\\}$：$u'(c_t) = \\beta R u'(c_{t+1})$。\n  - 在 $t = T-1$ 且有终期遗赠 $\\phi(a_T)$ 的情况下：$u'(c_{T-1}) = \\beta \\phi'(a_T)$。\n- 通过为每个 $t$ 选择一个关于 $a_{t+1}$ 的网格，使用边际效用函数 $u'(\\cdot)$ 的逆函数从欧拉方程计算出 $c_t$，然后为手头现金 $m_t = a_{t+1} + c_t$ 构建内生网格，从而定义内生网格法的映射。当欧拉方程所隐含的选择会违反借贷约束时，通过强制执行 $a_{t+1} = \\underline{a}$ 来处理该约束。\n\n待实现的模型设定：\n- 偏好：\n  - $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma > 0$ 且 $\\gamma \\ne 1$。\n  - $\\phi(a) = \\kappa \\cdot \\frac{(a + b)^{1-\\nu} - b^{1-\\nu}}{1-\\nu}$，其中 $\\nu > 0$，$\\kappa \\ge 0$ 且 $b > 0$；因此 $\\phi'(a) = \\kappa \\cdot (a+b)^{-\\nu}$。\n- 技术与收入：\n  - 总利率因子 $R > 0$ 在所有 $t$ 中保持不变。\n  - 确定性收入序列 $\\{y_t\\}_{t=0}^{T-1}$ 已给定。\n- 约束：\n  - 借贷限额 $\\underline{a}$ 是固定的，并满足 $\\underline{a} \\le 0$；在下方的测试套件中，它将被设为 $\\underline{a} = 0$。\n- 期界与时序:\n  - 共有 $T$ 个消费期。遗赠项 $\\beta^{T} \\phi(a_T)$ 取决于在 $t = T-1$ 期选择的 $a_T$；在 $t = T-1$ 之后的终期日期没有消费。\n\n算法任务：\n- 使用内生网格法，通过逆向归纳法，在每个 $t$ 期的 $a_{t+1}$ 网格上计算策略函数 $\\{c_t(m_t)\\}_{t=0}^{T-1}$。\n- 在 $t = T-1$ 期，使用欧拉条件 $u'(c_{T-1}) = \\beta \\phi'(a_T)$，从一个 $a_T$ 的网格计算出内生的 $m_{T-1} = a_T + c_{T-1}$。如果 $\\kappa = 0$ 以至于 $\\phi'(a_T) = 0$，则内部解欧拉方程不成立，此时借贷约束生效：$a_T = \\underline{a}$ 且 $c_{T-1} = m_{T-1} - \\underline{a}$。\n- 对于 $t \\le T-2$，给定 $c_{t+1}(\\cdot)$，为每个网格点 $a_{t+1}$ 计算下一期的资源 $m_{t+1} = R a_{t+1} + y_{t+1}$，并使用 $u'(c_t) = \\beta R u'(c_{t+1}(m_{t+1}))$ 来得到 $c_t$，从而得到 $m_t = a_{t+1} + c_t$。根据需要，通过对较低的 $m_t$ 值强制执行 $a_{t+1} = \\underline{a}$ 来处理借贷约束。\n\n模拟与分析：\n- 在计算出策略函数后，从 $a_0$ 和给定的收入序列开始，模拟资产和消费的生命周期路径，以获得 $\\{a_{t+1}\\}_{t=0}^{T-1}$ 和 $\\{c_t\\}_{t=0}^{T-1}$。将第 $t$ 期的储蓄定义为 $a_{t+1}$。\n- 对于下方测试套件中的每一组参数，报告整个生命周期的平均储蓄，\n$$\n\\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1},\n$$\n结果为一个实数。\n\n测试套件：\n在所有测试中使用以下共同元素：\n- 期界 $T = 5$。\n- 利率因子 $R = 1.03$。\n- 贴现因子 $\\beta$ 将按下面指定的方式在不同测试案例中变化。\n- 消费的相对风险厌恶系数 $\\gamma = 2$。\n- 遗赠曲率 $\\nu = 2$。\n- 遗赠平移 $b = 0.01$。\n- 借贷限额 $\\underline{a} = 0$。\n- 初始资产 $a_0 = 0$。\n- 确定性收入序列 $\\{y_t\\}_{t=0}^{4} = \\{1.0, 1.0, 0.8, 0.6, 0.5\\}$。\n\n定义四个测试案例，它们在遗赠强度 $\\kappa$ 和跨期贴现因子 $\\beta$ 上有所不同：\n1. 案例 A（基准，无遗赠）：$\\kappa = 0.0$，$\\beta = 0.96$。\n2. 案例 B（中度遗赠）：$\\kappa = 0.5$，$\\beta = 0.96$。\n3. 案例 C（强遗赠）：$\\kappa = 2.0$，$\\beta = 0.96$。\n4. 案例 D（中度遗赠，更不耐）：$\\kappa = 0.5$，$\\beta = 0.90$。\n\n数值要求：\n- 实现内生网格法时，在 $[\\underline{a}, a_{\\max}]$ 区间上为 $a_{t+1}$ 设置一个至少包含 $200$ 个均匀分布点的网格，其中 $a_{\\max}$ 应足够大以避免最优选择被截断。在您的程序中，选择一个固定的 $a_{\\max}$，该值对于所有测试案例在数值上都是足够的。\n- 使用线性插值来评估网格外的 $c_{t+1}(m_{t+1})$。\n- 当 $m_{t+1}$ 或 $m_t$ 低于欧拉方程所隐含的最小内生手头现金值时，施加借贷约束 $a_{t+1} = \\underline{a}$，使得 $c_t = m_t - \\underline{a}$。\n\n最终输出规范：\n- 对于每个测试案例，计算如上定义的 $\\bar{s}$，并按顺序 $[\\bar{s}_A, \\bar{s}_B, \\bar{s}_C, \\bar{s}_D]$ 返回这四个实数的列表。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$）。不应打印任何额外文本。\n- 此问题不涉及物理单位。所有数值输出必须是十进制表示的实数。", "solution": "用户提供了一个来自计算经济学领域的、科学上有效且定义明确的问题。任务是使用内生网格法（EGM）求解一个有限期界、确定性的生命周期消费储蓄模型，并分析遗赠动机对储蓄的影响。我将提供一个完整的解法。\n\n代理人的目标是最大化其生命周期效用，由下式给出：\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)\n$$\n消费效用是恒定相对风险厌恶（CRRA）形式，$u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，这意味着边际效用为 $u'(c) = c^{-\\gamma}$。因此，逆边际效用函数为 $(u')^{-1}(x) = x^{-1/\\gamma}$。遗赠动机由终期价值函数 $\\phi(a_T)$ 捕捉，其边际效用为 $\\phi'(a_T) = \\kappa (a_T+b)^{-\\nu}$。\n\n代理人在每个时期 $t$ 面临预算约束：$c_t + a_{t+1} = R a_t + y_t$，其中 $m_t = R a_t + y_t$ 是手头现金。存在借贷限额 $a_{t+1} \\ge \\underline{a}$。\n\n该问题通过使用内生网格法的逆向归纳法来求解。该方法的核心是利用一阶条件（欧拉方程）从生命终点向起点逆向构建消费的策略函数 $c_t(m_t)$。\n\n欧拉方程为：\n1.  对于时期 $t \\in \\{0, 1, \\ldots, T-2\\}$：$u'(c_t) = \\beta R u'(c_{t+1})$。\n2.  对于最后一个消费期 $t = T-1$：$u'(c_{T-1}) = \\beta \\phi'(a_T)$。\n\n求解过程分为三个主要阶段：构建最终时期的策略函数，逆向迭代构建所有之前时期的策略函数，以及正向模拟以找到生命周期路径和平均储蓄。\n\n**1. 终期 ($t=T-1$) 的策略函数**\n\nEGM 从决策后状态的外生网格开始。对于时期 $t=T-1$，这是一个关于生命终点资产的网格，$\\{a_{T,i}\\}_{i=1}^N$，覆盖区间 $[\\underline{a}, a_{\\max}]$。\n\n- **有遗赠动机的情况 ($\\kappa > 0$)：**\n  使用终期欧拉方程 $u'(c_{T-1}) = \\beta \\phi'(a_T)$。代入函数形式，我们得到 $c_{T-1}^{-\\gamma} = \\beta \\kappa (a_T+b)^{-\\nu}$。为我们网格上的每个点 $a_{T,i}$ 求解消费 $c_{T-1}$：\n  $$\n  c_{T-1,i} = \\left( \\beta \\kappa (a_{T,i}+b)^{-\\nu} \\right)^{-1/\\gamma}\n  $$\n  在已知 $c_{T-1,i}$ 和 $a_{T,i}$ 的情况下，我们在一个内生网格上找到对应的决策前状态（手头现金）：$m_{T-1,i} = a_{T,i} + c_{T-1,i}$。这就给出了一组点对 $(m_{T-1,i}, c_{T-1,i})$，定义了无约束代理人的消费策略。\n\n- **无遗赠动机的情况 ($\\kappa = 0$)：**\n  如果 $\\kappa=0$，则 $\\phi'(a_T)=0$。欧拉方程 $c_{T-1}^{-\\gamma} = 0$ 会意味着无限消费，这是不可行的。代理人的最优选择是消费掉所有可用资源，达到借贷限额。因此，$a_T = \\underline{a}$，策略函数简化为 $c_{T-1}(m_{T-1}) = m_{T-1} - \\underline{a}$。\n\n**2. 终期前各时期 ($t < T-1$) 的策略函数**\n\n我们从 $t=T-2$ 逆向迭代到 $t=0$。对于每个时期 $t$，我们假设下一期的策略函数 $c_{t+1}(m_{t+1})$ 是已知的（由上一步计算出的网格表示）。\n\n1.  从一个关于储蓄的外生网格 $\\{a_{t+1,i}\\}_{i=1}^N$ 开始，该网格在 $[\\underline{a}, a_{\\max}]$ 上。\n2.  对于每个网格点 $a_{t+1,i}$，计算下一期的手头现金：$m_{t+1,i} = R a_{t+1,i} + y_{t+1}$。\n3.  对已知的策略函数 $c_{t+1}(m_{t+1,i})$ 进行求值，以找到下一期的消费 $c_{t+1,i}$。这是通过对为 $t+1$ 期存储的策略网格进行线性插值来完成的。\n4.  使用跨期欧拉方程 $u'(c_t) = \\beta R u'(c_{t+1})$，逆向求解当期消费 $c_{t,i}$。对于 CRRA 效用，这可以很好地简化为：\n    $$\n    c_{t,i}^{-\\gamma} = \\beta R c_{t+1,i}^{-\\gamma} \\implies c_{t,i} = (\\beta R)^{-1/\\gamma} c_{t+1,i}\n    $$\n5.  构建手头现金的内生网格：$m_{t,i} = a_{t+1,i} + c_{t,i}$。\n    这就得到了定义了 $t$ 期无约束代理人策略的点对 $(m_{t,i}, c_{t,i})$。\n\n**3. 处理借贷约束**\n\nEGM 过程自然地生成了无约束选择的策略。对于手头现金较少的代理人，借贷约束 $a_{t+1} \\ge \\underline{a}$ 将会生效。他们的消费为 $c_t = m_t - \\underline{a}$。\nEGM 网格从 $a_{t+1,1} = \\underline{a}$ 开始。这对应于一个点 $(m_{t,1}, c_{t,1})$，该点构成了约束区域和非约束区域之间的“拐点”。策略在该点是连续的。为了创建一个完整的数值策略函数，我们将点 $(\\underline{a}, 0)$ 添加到由 EGM 生成的网格 $(m_{t,i}, c_{t,i})$ 的前面。由于 $m_{t,1} = \\underline{a} + c_{t,1}$，在 $(\\underline{a}, 0)$ 和 $(m_{t,1}, c_{t,1})$ 之间进行线性插值，可以正确地再现约束区域内的线性策略 $c_t = m_t - \\underline{a}$。\n\n**4. 模拟与平均储蓄计算**\n\n在计算出所有策略函数 $\\{c_t(m_t)\\}_{t=0}^{T-1}$ 后，我们正向模拟代理人的生命周期路径。\n1.  从初始资产 $a_0$ 开始。\n2.  对于 $t = 0, \\ldots, T-1$：\n    -   计算手头现金：$m_t = R a_t + y_t$。\n    -   通过在存储的策略网格上进行插值来确定消费：$c_t = c_t(m_t)$。\n    -   根据预算约束确定下一期的资产：$a_{t+1} = m_t - c_t$。\n3.  模拟得出储蓄路径 $\\{a_1, a_2, \\ldots, a_T\\}$。最终的度量指标是这些值的平均值：\n    $$\n    \\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1}\n    $$\n该实现将对指定的四个测试案例中的每一个执行这些步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the life-cycle model for all test cases and print the results.\n    \"\"\"\n    \n    # Define common parameters across all test cases\n    T = 5\n    R = 1.03\n    gamma = 2.0\n    nu = 2.0\n    b = 0.01\n    underline_a = 0.0\n    a0 = 0.0\n    income = np.array([1.0, 1.0, 0.8, 0.6, 0.5])\n    \n    # Numerical parameters for the Endogenous Grid Method\n    grid_size = 200\n    a_max = 20.0\n    \n    # Define the four test cases by varying bequest strength (kappa) and discount factor (beta)\n    test_cases = [\n        # (kappa, beta)\n        (0.0, 0.96),  # Case A: No bequest motive\n        (0.5, 0.96),  # Case B: Moderate bequest motive\n        (2.0, 0.96),  # Case C: Strong bequest motive\n        (0.5, 0.90),  # Case D: Moderate bequest, more impatient\n    ]\n\n    results = []\n    # Solve the model for each case and store the average savings\n    for kappa, beta in test_cases:\n        avg_savings = solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, \n                                     grid_size, a_max, kappa, beta)\n        results.append(avg_savings)\n\n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, grid_size, a_max, kappa, beta):\n    \"\"\"\n    Solves the life-cycle model for a single set of parameters using EGM.\n\n    Returns:\n        float: The average savings over the agent's life-cycle.\n    \"\"\"\n    # Exogenous grid for post-decision assets (a_{t+1})\n    a_grid = np.linspace(underline_a, a_max, grid_size)\n    \n    # Dictionary to store the computed policy functions (m_grid, c_grid) for each period\n    policy_functions = {}\n    \n    # --- Backward Induction: Solve for policy functions from T-1 to 0 ---\n    \n    # Period t = T-1 (the final consumption period)\n    t = T - 1\n    if kappa == 0.0:\n        # No bequest motive: agent consumes everything, so a_T = underline_a.\n        # The policy is c_{T-1} = m_{T-1} - underline_a.\n        # We represent this linear policy on a grid for consistency with other periods.\n        # A simple two-point grid is sufficient for linear interpolation.\n        m_grid_t = np.array([underline_a, a_max * R + np.max(income)])\n        c_grid_t = m_grid_t - underline_a\n    else:\n        # With bequest motive, use the terminal Euler equation: u'(c_{T-1}) = beta * phi'(a_T)\n        # Here, a_grid represents the grid for a_T.\n        a_T = a_grid\n        phi_p = kappa * (a_T + b)**(-nu)\n        # Avoid division by zero or negative base if phi_p <= 0\n        c_endo_t = np.full_like(a_T, 1e-10) # a small positive value for consumption\n        positive_phi_p_mask = phi_p > 0\n        c_endo_t[positive_phi_p_mask] = (beta * phi_p[positive_phi_p_mask])**(-1.0 / gamma)\n\n        # Compute the endogenous grid for cash-on-hand: m_{T-1} = a_T + c_{T-1}\n        m_endo_t = a_T + c_endo_t\n\n        # Combine with the borrowing-constrained region to form the full policy function.\n        # The constrained policy c = m - underline_a is represented by the point (underline_a, 0).\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n    policy_functions[t] = (m_grid_t, c_grid_t)\n    \n    # Periods t = T-2 down to 0\n    for t in range(T - 2, -1, -1):\n        m_grid_t_plus_1, c_grid_t_plus_1 = policy_functions[t + 1]\n        \n        # Here, a_grid represents the grid for a_{t+1}\n        a_t_plus_1 = a_grid\n        \n        # 1. Calculate next-period cash-on-hand for each point on the a_{t+1} grid\n        m_t_plus_1 = R * a_t_plus_1 + income[t + 1]\n        \n        # 2. Interpolate on the next-period policy function to find c_{t+1}\n        c_t_plus_1 = np.interp(m_t_plus_1, m_grid_t_plus_1, c_grid_t_plus_1)\n        \n        # 3. Use the intertemporal Euler equation to find current consumption c_t\n        # For CRRA utility, this simplifies to c_t = (beta * R)^(-1/gamma) * c_{t+1}\n        c_endo_t = (beta * R)**(-1.0 / gamma) * c_t_plus_1\n        \n        # 4. Compute the endogenous grid for cash-on-hand m_t\n        m_endo_t = a_t_plus_1 + c_endo_t\n        \n        # Add the borrowing-constrained region\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n        policy_functions[t] = (m_grid_t, c_grid_t)\n        \n    # --- Forward Simulation: Calculate the life-cycle path of assets ---\n    \n    a_path = np.zeros(T + 1)\n    a_path[0] = a0\n    \n    for t in range(T):\n        # Calculate current period's cash-on-hand\n        m_t = R * a_path[t] + income[t]\n        \n        # Get the policy function for the current period\n        m_grid_t, c_grid_t = policy_functions[t]\n        \n        # Evaluate the policy function to get consumption\n        c_t = np.interp(m_t, m_grid_t, c_grid_t)\n        \n        # Calculate next period's assets from the budget constraint\n        a_path[t + 1] = m_t - c_t\n        \n    # The problem defines savings as {a_1, ..., a_T}.\n    # Calculate the average of these savings.\n    avg_savings = np.mean(a_path[1:])\n    \n    return avg_savings\n\n# Execute the main function when the script is run\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "在为一个完整模型成功实施 EGM 之后，本练习邀请我们深入探究该方法本身的一个独特特性：内生网格点并非均匀分布。这个练习 [@problem_id:2440072] 探索了网格的非均匀性与经济学中“审慎储蓄”概念之间的关系，因为网格的密度反映了值函数的曲率，而曲率又受到不确定性和风险规避的影响。通过量化这种“聚集”效应，你将更深刻地理解为何 EGM 如此高效：它自动在状态空间中策略函数变化最剧烈、最需要精确度的区域放置更多的网格点，从而巧妙地连接了数值实现与经济理论。", "id": "2440072", "problem": "在内生网格法的设定下，考虑一个包含借贷约束的两期消费储蓄问题，其中存在离散的异质性暂时收入冲击。偏好由恒定相对风险厌恶效用函数 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ 给出，其中 $c > 0$ 且 $\\gamma > 0$。总利率因子为 $R = 1 + r$（其中 $r \\ge 0$），折现因子为 $\\beta \\in (0,1)$，并且下一期资产满足借贷约束 $a' \\ge 0$。设当期资产为 $a$，当期市场资源为 $m = R a + y \\epsilon$，其中 $y > 0$ 是一个固定的收入规模参数，$\\epsilon$ 是一个暂时收入冲击。\n\n问题包含两个时期，$t = T-1$ 和 $t = T$。在终期 $t = T$，代理人消费其全部可用资源，因此 $c_T(m_T) = m_T$。在时期 $t = T-1$，对于内点选择，其一阶条件将当期边际效用与下一期折现后的期望边际效用相等：\n$$\nu'\\!\\left(c_{T-1}\\right) = \\beta R \\,\\mathbb{E}\\left[u'\\!\\left(c_T(m_T')\\right)\\right] = \\beta R \\,\\mathbb{E}\\left[(m_T')^{-\\gamma}\\right],\n$$\n其中 $m_T' = R a' + y \\epsilon$。对于一个给定的、在 $[0,\\bar{a}]$ 上等距分布的下一期资产非负网格 $\\{a'_i\\}_{i=1}^{N}$，我们将当期资源的相应内生网格点集合定义为\n$$\nm_i = c_{T-1}(a'_i) + a'_i, \\quad \\text{where} \\quad c_{T-1}(a'_i) = \\left(\\beta R \\sum_{j=1}^{J} \\pi_j \\left(R a'_i + y \\epsilon_j\\right)^{-\\gamma}\\right)^{-1/\\gamma}.\n$$\n此处，$\\{\\epsilon_j\\}_{j=1}^{J}$ 和 $\\{\\pi_j\\}_{j=1}^{J}$ 分别是冲击 $\\epsilon$ 的有限支撑集及其对应的概率（满足 $\\sum_{j=1}^{J}\\pi_j = 1$ 和 $\\epsilon_j > 0$）。在给定外生的 $a'$ 均匀网格的情况下，集合 $\\{m_i\\}_{i=1}^{N}$ 构成由一阶条件和预算约束导出的当期资源的内生网格。\n\n对于一个给定的参数集，聚集指数 $\\kappa$ 的定义如下。将内生网格点 $\\{m_i\\}$ 按升序排序（在给定假设下，它们是严格递增的），构造最近邻间距 $\\Delta_i = m_{i+1} - m_i$，其中 $i = 1,\\dots,N-1$。设 $q = 0.10$，令 $K = \\max\\{1,\\lfloor q (N-1)\\rfloor\\}$。定义低端尾部的平均间距为 $\\overline{\\Delta}_{\\text{low}} = \\frac{1}{K}\\sum_{i=1}^{K}\\Delta_i$，高端尾部的平均间距为 $\\overline{\\Delta}_{\\text{high}} = \\frac{1}{K}\\sum_{i=N- K}^{N-1}\\Delta_i$。最后\n$$\n\\kappa = \\frac{\\overline{\\Delta}_{\\text{low}}}{\\overline{\\Delta}_{\\text{high}}}.\n$$\n当 $\\kappa \\in (0,1)$ 时，表示内生网格点在资源空间的低端更为密集地聚集。\n\n您的任务是编写一个程序，对下方测试套件中的每一组参数，按照上述描述为时期 $t = T-1$ 构造内生网格 $\\{m_i\\}_{i=1}^{N}$，计算聚集指数 $\\kappa$，并报告其值。\n\n除非另有说明，所有案例都使用以下通用模型设定：$y = 1$，$N = 500$，$\\bar{a} = 10$，以及在 $[0,\\bar{a}]$ 上的 $a'$ 均匀网格。对于每组参数，冲击分布是离散的，其支撑集 $\\{\\epsilon_j\\}$ 和概率 $\\{\\pi_j\\}$ 均已明确指定。\n\n测试套件（每行为一个独立的测试案例，按输出顺序排列）：\n1. $\\beta = 0.96$， $r = 0.04$， $\\gamma = 2.0$，冲击支撑集 $\\{\\epsilon_j\\} = \\{0.8, 1.0, 1.2\\}$，概率为 $\\{\\pi_j\\} = \\{0.25, 0.50, 0.25\\}$。\n2. $\\beta = 0.96$， $r = 0.04$， $\\gamma = 2.0$，冲击支撑集 $\\{\\epsilon_j\\} = \\{1.0\\}$，概率为 $\\{\\pi_j\\} = \\{1.0\\}$。\n3. $\\beta = 0.96$， $r = 0.04$， $\\gamma = 2.0$，冲击支撑集 $\\{\\epsilon_j\\} = \\{0.2, 1.0, 2.2\\}$，概率为 $\\{\\pi_j\\} = \\{0.25, 0.50, 0.25\\}$。\n4. $\\beta = 0.96$， $r = 0.04$， $\\gamma = 5.0$，冲击支撑集 $\\{\\epsilon_j\\} = \\{0.8, 1.0, 1.2\\}$，概率为 $\\{\\pi_j\\} = \\{0.25, 0.50, 0.25\\}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与测试套件相同，每个 $\\kappa$ 值四舍五入到六位小数（例如，$[0.123456,0.234567,0.345678,0.456789]$）。不涉及物理单位。不使用角度。所有报告的值必须是十进制形式的实数，而不是百分比。", "solution": "提交分析的问题陈述被认为是有效的。它具有科学依据，是适定的、客观且内部一致的。它描述了计算经济学中的一个标准问题——使用经典数值方法“内生网格法”(EGM) 求解一个两期消费储蓄模型。任务是为生成的市场资源内生网格计算一个定义明确的“聚集指数”$\\kappa$。所有参数、函数形式和计算步骤都以足够高的精确度被指定，从而可以得到一个唯一且可验证的解。\n\n求解过程如下。该模型包含一个具有恒定相对风险厌恶 (CRRA) 偏好的代理人，其效用函数为 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，该代理人在两个时期（$t=T-1$ 和 $t=T$）内做出决策。在终期 $t=T$，代理人消费其全部可用资源，因此消费为 $c_T(m_T) = m_T$。\n\n在时期 $t=T-1$，代理人选择消费 $c_{T-1}$ 和下一期资产 $a'$ 以最大化其效用，并受预算约束 $c_{T-1} + a' = m_{T-1}$ 的限制，其中 $m_{T-1}$ 是当期市场资源。对于内点解，其一阶条件（或称欧拉方程）为：\n$$\nu'(c_{T-1}) = \\beta R \\, \\mathbb{E}[u'(c_T)]\n$$\n其中 $\\beta$ 是折现因子，$R$ 是总利率因子。代入 CRRA 边际效用函数 $u'(c) = c^{-\\gamma}$ 和终期消费规则 $c_T = m_T = R a' + y\\epsilon$，可得：\n$$\nc_{T-1}^{-\\gamma} = \\beta R \\, \\mathbb{E}[(R a' + y\\epsilon)^{-\\gamma}]\n$$\n该期望是针对暂时收入冲击 $\\epsilon$ 的离散分布计算的，其支撑集为 $\\{\\epsilon_j\\}_{j=1}^{J}$，概率为 $\\{\\pi_j\\}_{j=1}^{J}$。因此，期望项是一个加权和：\n$$\n\\mathbb{E}[(R a' + y\\epsilon)^{-\\gamma}] = \\sum_{j=1}^{J} \\pi_j (R a' + y \\epsilon_j)^{-\\gamma}\n$$\n内生网格法避免了在状态变量 $m_{T-1}$ 的每个网格点上求解欧拉方程的根。相反，该方法首先为选择变量（即下一期资产 $a'$）定义一个外生的、在区间 $[0, \\bar{a}]$ 上均匀间隔的网格。设该网格为 $\\mathcal{A}' = \\{a'_i\\}_{i=1}^{N}$。\n\n对于 $\\mathcal{A}'$ 中的每个点 $a'_i$，我们可以直接计算欧拉方程的右侧。这使我们能够解出使得 $a'_i$ 成为最优选择的当期消费水平 $c_{T-1}(a'_i)$：\n$$\nc_{T-1}(a'_i) = \\left( \\beta R \\sum_{j=1}^{J} \\pi_j (R a'_i + y \\epsilon_j)^{-\\gamma} \\right)^{-1/\\gamma}\n$$\n在已知最优消费 $c_{T-1}(a'_i)$ 和储蓄 $a'_i$ 的情况下，可以从预算约束中反解出对应的当期市场资源水平 $m_i$：\n$$\nm_i = c_{T-1}(a'_i) + a'_i\n$$\n点集 $\\mathcal{M} = \\{m_i\\}_{i=1}^{N}$ 构成了内生网格。这些是代理人会从外生网格 $\\mathcal{A}'$ 中选择某个储蓄水平作为其最优选择时的特定资源水平。在给定假设下，从 $a'_i$ 到 $m_i$ 的映射函数是严格递增的，因此得到的网格 $\\mathcal{M}$ 是有序的。\n\n最后一步是计算聚集指数 $\\kappa$。该指数用于量化内生网格点的间距。首先，计算最近邻间距：$\\Delta_i = m_{i+1} - m_i$，其中 $i=1, \\dots, N-1$。我们定义一个分位数 $q=0.10$，并确定低端和高端尾部的网格间距数量为 $K = \\max\\{1, \\lfloor q (N-1) \\rfloor\\}$。低端尾部的平均间距是 $\\overline{\\Delta}_{\\text{low}} = \\frac{1}{K}\\sum_{i=1}^{K}\\Delta_i$，高端尾部的平均间距是 $\\overline{\\Delta}_{\\text{high}} = \\frac{1}{K}\\sum_{i=N-K}^{N-1}\\Delta_i$。聚集指数是这两个平均值的比率：\n$$\n\\kappa = \\frac{\\overline{\\Delta}_{\\text{low}}}{\\overline{\\Delta}_{\\text{high}}}\n$$\n$\\kappa < 1$ 的值表示网格点在市场资源的较低水平上更密集地聚集，这是预防性动机下的典型结果。\n\n计算实现将为提供的每个参数集执行此系列操作。为了提高效率，我们利用 NumPy 进行向量化计算。通用参数为 $y=1$，$N=500$ 和 $\\bar{a}=10$。每个测试案例使用指定的 $\\beta$、$r$、$\\gamma$ 值以及冲击分布 $\\{\\epsilon_j, \\pi_j\\}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_kappa(beta, r, gamma, epsilons, probabilities, y, N, a_bar, q):\n    \"\"\"\n    Calculates the clustering index kappa for a two-period consumption-savings model.\n\n    This function implements the Endogenous Grid Method (EGM) to construct an\n    endogenous grid of market resources and then computes a clustering index\n    based on the spacing of the grid points.\n\n    Args:\n        beta (float): The discount factor.\n        r (float): The net interest rate.\n        gamma (float): The coefficient of relative risk aversion.\n        epsilons (list[float]): The support of the discrete income shock.\n        probabilities (list[float]): The probabilities for the income shocks.\n        y (float): The income scale factor.\n        N (int): The number of points in the asset grid.\n        a_bar (float): The maximum value for the asset grid.\n        q (float): The quantile used for calculating the tail size K.\n\n    Returns:\n        float: The computed clustering index kappa.\n    \"\"\"\n    # 1. Define constants and exogenous grid for next-period assets a'\n    R = 1.0 + r\n    a_prime_grid = np.linspace(0.0, a_bar, N)\n\n    # 2. Vectorized calculation of expected marginal utility\n    # Reshape arrays for broadcasting to create matrices of shape (N, J)\n    # where J is the number of shock points.\n    epsilons_reshaped = np.array(epsilons)[np.newaxis, :]       # Shape (1, J)\n    probabilities_reshaped = np.array(probabilities)[np.newaxis, :]  # Shape (1, J)\n    a_prime_reshaped = a_prime_grid[:, np.newaxis]             # Shape (N, 1)\n\n    # Matrix of next-period market resources: m' = R*a' + y*epsilon\n    # Resulting shape is (N, J) due to broadcasting.\n    m_prime_matrix = R * a_prime_reshaped + y * epsilons_reshaped\n    \n    # Matrix of next-period marginal utilities: u'(m') = (m')^(-gamma)\n    marginal_utility_matrix = m_prime_matrix**(-gamma)\n\n    # Expected next-period marginal utility, weighting by probabilities.\n    # The sum is over the shock dimension (axis=1), resulting in shape (N,).\n    expected_marginal_utility = np.sum(marginal_utility_matrix * probabilities_reshaped, axis=1)\n\n    # 3. Invert the Euler equation to find current-period consumption c\n    # c = (beta * R * E[u'(m')])^(-1/gamma)\n    c_grid = (beta * R * expected_marginal_utility)**(-1.0 / gamma)\n\n    # 4. Construct the endogenous grid for current-period resources m\n    # m = c + a'\n    m_grid = c_grid + a_prime_grid\n\n    # 5. Calculate the clustering index kappa\n    # The problem statement guarantees m_grid is strictly increasing.\n    spacings = np.diff(m_grid)\n    \n    # Number of spacings is N-1\n    num_spacings = N - 1\n    \n    # Determine the number of spacings in the lower and upper tails\n    K = int(max(1.0, np.floor(q * num_spacings)))\n    \n    # Calculate the mean spacing in the lower and upper tails\n    mean_delta_low = np.mean(spacings[:K])\n    mean_delta_high = np.mean(spacings[-K:])\n\n    # The clustering index is the ratio of these means\n    kappa = mean_delta_low / mean_delta_high\n    \n    return kappa\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Common modeling parameters for all test cases\n    y = 1.0\n    N = 500\n    a_bar = 10.0\n    q = 0.10\n\n    # Test suite with parameters for each case\n    test_cases = [\n        {'beta': 0.96, 'r': 0.04, 'gamma': 2.0, 'epsilons': [0.8, 1.0, 1.2], 'probabilities': [0.25, 0.50, 0.25]},\n        {'beta': 0.96, 'r': 0.04, 'gamma': 2.0, 'epsilons': [1.0], 'probabilities': [1.0]},\n        {'beta': 0.96, 'r': 0.04, 'gamma': 2.0, 'epsilons': [0.2, 1.0, 2.2], 'probabilities': [0.25, 0.50, 0.25]},\n        {'beta': 0.96, 'r': 0.04, 'gamma': 5.0, 'epsilons': [0.8, 1.0, 1.2], 'probabilities': [0.25, 0.50, 0.25]},\n    ]\n\n    results = []\n    # Loop through each test case, calculate kappa, and store the result\n    for case in test_cases:\n        kappa = calculate_kappa(\n            beta=case['beta'],\n            r=case['r'],\n            gamma=case['gamma'],\n            epsilons=case['epsilons'],\n            probabilities=case['probabilities'],\n            y=y,\n            N=N,\n            a_bar=a_bar,\n            q=q\n        )\n        results.append(kappa)\n\n    # Format the list of results into the required string format\n    # Each result is rounded to six decimal places.\n    formatted_results = [f'{res:.6f}' for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```"}, {"introduction": "最后一个练习通过解决一个更复杂、更现实的模型，展示了 EGM 框架的灵活性和强大功能，即在标准的消费储蓄模型中加入内生的劳动供给选择。解决这个问题 [@problem_id:2440090] 需要同时处理跨期（消费 $c_t$ 与储蓄 $a_{t+1}$）和期内（消费 $c_t$ 与劳动 $l_t$）的权衡。这要求你对一阶条件有扎实的掌握，并且关键在于运用包络定理将值函数的导数与边际效用联系起来，这正是 EGM 方法简洁性的核心。这个高级练习将巩固你对 EGM 理论基础的理解，并使你具备将该方法应用于现代宏观经济研究中更广泛的动态经济模型的能力。", "id": "2440090", "problem": "考虑一个代表性代理人，他/她求解一个带有期内劳动选择的无限期界确定性消费-储蓄问题。时间是离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。期初财富为 $a_t \\in [\\underline{a},\\overline{a}]$。代理人在每个时期选择消费 $c_t \\ge 0$、下一期的资产 $a_{t+1} \\ge \\underline{a}$ 和劳动供给 $l_t \\in [0,\\overline{l}]$。\n\n偏好由下式给出：\n$$\n\\sum_{t=0}^{\\infty} \\beta^t \\left( \\frac{c_t^{1-\\sigma}-1}{1-\\sigma} - \\chi \\frac{l_t^{1+\\varphi}}{1+\\varphi} \\right),\n$$\n其中 $\\beta \\in (0,1)$ 是贴现因子，$\\sigma > 0$ 是相对风险规避系数，$\\chi > 0$ 用于衡量劳动的负效用，$\\varphi > 0$ 是 Frisch 弹性参数。预算约束为：\n$$\nc_t + a_{t+1} = R a_t + w l_t,\n$$\n其中 $R > 0$ 是总回报因子，$w > 0$ 是工资率，两者都随时间保持不变。借贷约束为 $a_{t+1} \\ge \\underline{a}$，其中 $\\underline{a} \\in \\mathbb{R}$；劳动边界为 $0 \\le l_t \\le \\overline{l}$，其中 $\\overline{l} > 0$。\n\n您的任务是实施内生网格法 (Endogenous Grid Method, EGM)，利用财富边际价值的包络定理，计算作为期初财富函数的稳态消费策略函数。您必须从基本的动态规划原理和一阶条件出发，并且不能假定任何“捷径”公式为已知。具体来说：\n\n- 从 Bellman 方程以及由拉格朗日公式推导出的基本 Euler 条件和期内最优性条件开始。\n- 使用包络定理，将期初财富的边际价值用期内边际效用和总回报来表示，并利用此关系构建内生网格映射，以避免在内部区域对消费进行求根运算。\n- 通过在借贷约束 $a_{t+1} \\ge \\underline{a}$ 生效时求解期内静态问题来正确处理该约束。在该受约束区域，您必须使用期内一阶条件和预算约束，在给定 $a_t$ 和 $a_{t+1}=\\underline{a}$ 的情况下确定 $(c_t,l_t)$ 对；如果期内条件在 $[0,\\overline{l}]$ 内没有内部解，您必须将 $l_t$ 设置为 $[0,\\overline{l}]$ 中最近的边界值，并从预算约束中反解出 $c_t$。\n- 当 $l_t$ 是内部解时，期内条件为\n$$\nu_c(c_t,l_t) \\cdot w = v_l(c_t,l_t),\n$$\n其中 $u_c(c_t,l_t) = \\frac{\\partial}{\\partial c} \\left( \\frac{c^{1-\\sigma}-1}{1-\\sigma} - \\chi \\frac{l^{1+\\varphi}}{1+\\varphi} \\right) = c^{-\\sigma}$ 且 $v_l(c_t,l_t) = \\frac{\\partial}{\\partial l} \\left( \\chi \\frac{l^{1+\\varphi}}{1+\\varphi} \\right) = \\chi l^{\\varphi}$。\n\n在离散资产网格上实施一个迭代 EGM 算法来计算稳态消费策略。然后，通过报告资产网格上的最大 Euler 方程残差来评估数值解的质量：\n- 在 $a_{t+1} > \\underline{a}$ 且 $l_t \\in (0,\\overline{l})$ 的内部点，计算下式的绝对值：\n$$\nu_c(c_t,l_t) - \\beta R \\, u_c(c_{t+1},l_{t+1}).\n$$\n- 在借贷约束生效的点，计算下式的非负部分作为不等式残差：\n$$\nu_c(c_t,l_t) - \\beta R \\, u_c(c_{t+1},l_{t+1}).\n$$\n通过取资产网格上的最大值来汇总残差。\n\n测试套件。您的程序必须运行 EGM 求解器，并为以下每个参数集报告最大 Euler 残差（一个实数）。所有参数都是无量纲的。在所有案例中，请使用相同的资产网格和收敛容差。四个参数集如下：\n\n- 案例 $1$：$\\beta = 0.96$, $\\sigma = 2.0$, $\\chi = 1.0$, $\\varphi = 1.0$, $R = 1.03$, $w = 1.0$, $\\underline{a} = 0.0$, $\\overline{a} = 20.0$, $\\overline{l} = 1.0$。\n- 案例 $2$：$\\beta = 0.96$, $\\sigma = 2.0$, $\\chi = 3.0$, $\\varphi = 1.0$, $R = 1.03$, $w = 1.0$, $\\underline{a} = 0.0$, $\\overline{a} = 20.0$, $\\overline{l} = 1.0$。\n- 案例 $3$：$\\beta = 0.96$, $\\sigma = 2.0$, $\\chi = 1.0$, $\\varphi = 1.0$, $R = 1.04$, $w = 0.5$, $\\underline{a} = 0.0$, $\\overline{a} = 20.0$, $\\overline{l} = 1.0$。\n- 案例 $4$：$\\beta = 0.96$, $\\sigma = 2.0$, $\\chi = 0.2$, $\\varphi = 1.0$, $R = 1.02$, $w = 1.0$, $\\underline{a} = 0.0$, $\\overline{a} = 20.0$, $\\overline{l} = 1.0$。\n\n数值和算法要求：\n- 对 $a$ 使用在 $[\\underline{a},\\overline{a}]$ 上的至少有 $200$ 个点的均匀网格，对 $a'$ 使用在 $[\\underline{a},\\overline{a}]$ 上的至少有 $200$ 个点的均匀网格。\n- 对消费策略使用不动点迭代，收敛容差在上确界范数下不大于 $10^{-8}$。\n- 必要时，对借贷约束下的期内条件使用稳健的求根方法，仅限使用如在 $[0,\\overline{l}]$ 上的二分法等简单方法。\n- 为避免除以零，在计算边际效用时，对消费强制施加一个不大于 $10^{-8}$ 的严格正下界。\n\n最终输出格式。您的程序应生成单行输出，其中包含上述案例的四个最大 Euler 残差，形式为用方括号括起来的逗号分隔列表，每个残差四舍五入到恰好 $6$ 位小数，顺序与上面列出的案例顺序一致（例如，$[0.000123,0.000456,0.000789,0.000012]$）。不应打印任何其他文本。", "solution": "该问题要求计算一个带有内生劳动供给的无限期界消费-储蓄模型的稳态消费策略。指定的方法是内生网格法 (EGM)，该方法以其效率和稳定性而闻名。该解法将从动态规划的第一性原理推导得出。\n\n代理人的问题是求解 Bellman 方程：\n$$\nV(a_t) = \\max_{c_t, l_t, a_{t+1}} \\left\\{ \\frac{c_t^{1-\\sigma}-1}{1-\\sigma} - \\chi \\frac{l_t^{1+\\varphi}}{1+\\varphi} + \\beta V(a_{t+1}) \\right\\}\n$$\n受预算约束 $c_t + a_{t+1} = R a_t + w l_t$ 以及约束条件 $c_t \\ge 0$、$a_{t+1} \\ge \\underline{a}$ 和 $l_t \\in [0, \\overline{l}]$ 的限制。我们将单期效用函数表示为 $u(c_t, l_t) = \\frac{c_t^{1-\\sigma}-1}{1-\\sigma} - \\chi \\frac{l_t^{1+\\varphi}}{1+\\varphi}$。\n\n首先，我们通过建立时期-$t$ 问题的拉格朗日量来推导内部解的必要一阶条件 (FOCs)：\n$$\n\\mathcal{L} = u(c_t, l_t) + \\beta V(a_{t+1}) - \\lambda_t (c_t + a_{t+1} - R a_t - w l_t)\n$$\n相对于控制变量 $c_t$、$l_t$ 和 $a_{t+1}$ 的一阶条件是：\n$1$. $\\frac{\\partial \\mathcal{L}}{\\partial c_t} = u_c(c_t, l_t) - \\lambda_t = 0 \\implies c_t^{-\\sigma} = \\lambda_t$\n$2$. $\\frac{\\partial \\mathcal{L}}{\\partial l_t} = u_l(c_t, l_t) + \\lambda_t w = 0 \\implies -\\chi l_t^{\\varphi} + \\lambda_t w = 0$\n$3$. $\\frac{\\partial \\mathcal{L}}{\\partial a_{t+1}} = \\beta V'(a_{t+1}) - \\lambda_t = 0$\n\n结合条件 ($1$) 和 ($2$) 得到期内最优性条件，它将单一时期内的消费和劳动联系起来：\n$$\nc_t^{-\\sigma} w = \\chi l_t^{\\varphi}\n$$\n这个方程意味着对于给定的消费水平，存在一个最优劳动供给 $l_t^*(c_t)$。考虑到劳动供给的边界， $l_t$ 的策略是：\n$$\nl_t(c_t) = \\min\\left( \\left( \\frac{w}{\\chi} c_t^{-\\sigma} \\right)^{1/\\varphi}, \\overline{l} \\right)\n$$\n因为劳动不能为负。\n\n接下来，我们使用包络定理来寻找价值函数的导数 $V'(a_t)$:\n$$\nV'(a_t) = \\frac{\\partial \\mathcal{L}}{\\partial a_t} \\bigg|_{\\text{optimal choices}} = \\lambda_t R\n$$\n代入 $\\lambda_t = u_c(c_t, l_t) = c_t^{-\\sigma}$ 得到包络条件：\n$$\nV'(a_t) = R c_t^{-\\sigma}\n$$\n将时间指数前推一期，我们得到 $V'(a_{t+1}) = R c_{t+1}^{-\\sigma}$。\n最后，将 FOC ($3$) 与包络条件结合，得到跨期 Euler 方程：\n$$\n\\lambda_t = \\beta V'(a_{t+1}) \\implies c_t^{-\\sigma} = \\beta R c_{t+1}^{-\\sigma}\n$$\n这个方程是 EGM 算法的基础。\n\nEGM 算法通过迭代来寻找稳态消费策略函数 $c(a)$ 的不动点。设 $c_k(a)$ 为第 $k$ 次迭代时策略函数的猜测值。\n\n**步骤 1：EGM 回溯步骤（无约束的代理人）**\n我们不是固定当期资产 $a_t$ 来寻找最优的 $c_t$，而是固定下一期的资产 $a_{t+1}$ 来寻找对应的 $a_t$ 和 $c_t$。我们为 $a_{t+1}$ 选择一个网格点集，即预定义的外生资产网格 $A_{grid}$。\n对于 $A_{grid}$ 中的每个 $a_{t+1}$：\n- 我们使用当前的策略猜测值找到对应的下一期消费：$c_{t+1} = c_k(a_{t+1})$。\n- 我们使用 Euler 方程找到导致此选择的当期消费 $c_t$：\n$$\nc_t^{-\\sigma} = \\beta R (c_k(a_{t+1}))^{-\\sigma} \\implies c_t = (\\beta R)^{-1/\\sigma} c_k(a_{t+1})\n$$\n- 在确定了 $c_t$ 之后，我们从期内条件中找到对应的最优劳动供给 $l_t$：\n$$\nl_t = \\min\\left( \\left( \\frac{w}{\\chi} c_t^{-\\sigma} \\right)^{1/\\varphi}, \\overline{l} \\right)\n$$\n- 最后，我们使用预算约束找到与这些选择一致的当期资产水平 $a_t$。这个 $a_t$ 水平构成了我们的“内生网格”：\n$$\na_t = \\frac{1}{R} (c_t + a_{t+1} - w l_t)\n$$\n这个过程为我们提供了一系列位于新策略函数 $c_{k+1}$ 上的点对 $(a_t, c_t)$。\n\n**步骤 2：插值**\n$a_t$ 值的内生网格将与我们预定义的外生网格 $A_{grid}$ 不匹配。为了在 $A_{grid}$ 上获得策略函数 $c_{k+1}(a)$，我们对步骤 1 中计算出的点对 $(a_t, c_t)$ 集合进行线性插值。\n\n**步骤 3：处理借贷约束**\n上述 EGM 过程仅适用于对 $a_{t+1}$ 做出内部选择的代理人。资产持有量非常低 ($a_t$) 的代理人将受到约束，被迫选择 $a_{t+1} = \\underline{a}$。这发生在资产水平 $a_t$ 低于步骤 1 中计算的内生网格最低点（该点对应于选择 $a_{t+1}=\\underline{a}$）时。对于这些受约束的代理人，我们必须直接求解他们的优化问题。\n对于给定的 $a_t$，我们设定 $a_{t+1} = \\underline{a}$。代理人的问题简化为在预算约束下最大化效用的静态 $l_t$ 选择，此时预算约束决定了消费：$c_t = R a_t + w l_t - \\underline{a}$。\n问题是：\n$$\n\\max_{l_t \\in [0, \\overline{l}]} \\left\\{ u(R a_t + w l_t - \\underline{a}, l_t) \\right\\}\n$$\n$l_t$ 内部解的一阶条件是：\n$$\n(R a_t + w l_t - \\underline{a})^{-\\sigma} w = \\chi l_t^{\\varphi}\n$$\n这是一个关于 $l_t$ 的非线性方程，可以使用像二分法这样的求根算法来求解。解必须遵守边界 $[0, \\overline{l}]$ 和消费必须为正的约束。如果方程在 $(0, \\overline{l})$ 内没有解，最优解则位于边界之一。一旦找到最优的 $l_t$，相应的 $c_t$ 就由预算约束确定。\n\n**步骤 4：迭代与收敛**\n我们将受约束区域的策略函数（步骤 3）和无约束区域的策略函数（步骤 2）结合起来，形成完整的新策略猜测值 $c_{k+1}(a)$。然后我们计算在网格 $A_{grid}$ 上 $c_{k+1}(a)$ 和 $c_k(a)$ 之间的最大绝对差。如果这个差值低于指定的容差，则算法收敛。否则，我们设置 $c_k \\leftarrow c_{k+1}$ 并从步骤 1 开始重复。\n\n**步骤 5：Euler 方程残差计算**\n收敛到稳态策略 $c(a)$ 后，我们通过计算 Euler 方程残差来评估其准确性。对于网格上的每个 $a_t$，我们计算：\n- 当期选择：$c_t = c(a_t)$ และ $l_t = l(c_t)$。\n- 下一期资产：$a_{t+1} = R a_t + w l_t - c_t$。\n- 下一期选择：$c_{t+1} = c(a_{t+1})$（使用插值）和 $l_{t+1} = l(c_{t+1})$。\n然后残差计算如下：\n- 如果 $a_{t+1} > \\underline{a}$（无约束），则为 $|c_t^{-\\sigma} - \\beta R c_{t+1}^{-\\sigma}|$。\n- 如果 $a_{t+1} \\le \\underline{a}$（受约束），则为 $\\max(0, c_t^{-\\sigma} - \\beta R c_{t+1}^{-\\sigma})$。\n在整个资产网格 $A_{grid}$ 上的这些残差的最大值将作为最终的准确性度量报告。<answer>```python\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Main function to solve the consumption-savings problem for four test cases\n    and print the formatted results.\n    \"\"\"\n\n    def _bisection(f, a, b, tol=1e-10, max_iter=100):\n        \"\"\"A simple bisection root-finder.\"\"\"\n        fa = f(a)\n        for _ in range(max_iter):\n            mid = a + 0.5 * (b - a)\n            if (b - a) * 0.5 < tol:\n                return mid\n            fmid = f(mid)\n            if np.sign(fmid) == np.sign(fa):\n                a = mid\n                fa = fmid\n            else:\n                b = mid\n        return (a + b) / 2.0\n\n    def _solve_l_constrained(a_t, params):\n        \"\"\"\n        Solves for the optimal labor supply l_t for a borrowing-constrained agent.\n        The choice of next-period asset is fixed at a_min.\n        \"\"\"\n        beta, sigma, chi, phi, R, w, a_min, a_max, l_max = params\n        c_min_val = 1e-8\n\n        def foc_l(l, current_a):\n            \"\"\"The first-order condition for labor choice.\"\"\"\n            cons = R * current_a + w * l - a_min\n            if cons <= 0:\n                return 1e12  # Effectively infinite marginal utility of consumption\n            \n            marginal_utility_c = cons**(-sigma)\n            \n            if l <= 0:\n                # With phi > 0, marginal disutility of labor at l=0 is 0.\n                marginal_disutility_l = 0\n            else:\n                marginal_disutility_l = chi * l**phi\n            \n            return marginal_utility_c * w - marginal_disutility_l\n\n        # Check consumption at l=0. If not positive, agent must work.\n        cons_at_zero_l = R * a_t - a_min\n        if cons_at_zero_l <= c_min_val:\n            # Agent must work to survive (c > 0). Find the minimum required labor.\n            l_lower_bound = (a_min - R * a_t + c_min_val) / w if w > 0 else l_max\n            l_search_min = min(max(0, l_lower_bound), l_max)\n\n            if l_search_min >= l_max:\n                return l_max\n\n            # If FOC is positive at l_max, l_max is the solution.\n            if foc_l(l_max, a_t) >= 0:\n                return l_max\n            \n            # Otherwise, find the root between the minimum required labor and l_max.\n            return _bisection(lambda l: foc_l(l, a_t), l_search_min, l_max)\n        else:\n            # Agent can survive without working. Interior solution for l is possible.\n            # If FOC is negative at l=0, l=0 is optimal.\n            if foc_l(0, a_t) <= 0:\n                return 0.0\n            \n            # If FOC is positive at l_max, l_max is optimal.\n            if foc_l(l_max, a_t) >= 0:\n                return l_max\n                \n            # Otherwise, find interior solution between 0 and l_max.\n            return _bisection(lambda l: foc_l(l, a_t), 0.0, l_max)\n\n    def compute_policy_and_residual(params):\n        \"\"\"\n        Computes the stationary policy functions and the max Euler residual\n        for a given set of parameters.\n        \"\"\"\n        beta, sigma, chi, phi, R, w, a_min, a_max, l_max = params\n        \n        # Numerical parameters\n        N_a = 200\n        tol = 1e-9\n        c_min_val = 1e-8\n\n        # Grids\n        a_grid = np.linspace(a_min, a_max, N_a)\n        \n        # Initial guess for consumption policy\n        c_policy = (R - 1) * a_grid + w * l_max / 2  # A simple guess\n\n        # Policy function iteration loop\n        max_iter = 1000\n        for it in range(max_iter):\n            c_old = c_policy.copy()\n            c_interp = interp1d(a_grid, c_old, kind='linear', fill_value='extrapolate')\n\n            # EGM Step for unconstrained region\n            a_prime_grid = a_grid  # Choices for a_t+1 are on the grid\n            c_prime = c_interp(a_prime_grid)\n            c_prime = np.maximum(c_min_val, c_prime)\n            \n            mu_prime = c_prime**(-sigma)\n            mu_curr = beta * R * mu_prime\n            c_endog = mu_curr**(-1.0/sigma)\n            \n            l_endog = (w/chi * c_endog**(-sigma))**(1.0/phi)\n            l_endog = np.minimum(l_endog, l_max)\n            \n            a_endog = (c_endog + a_prime_grid - w * l_endog) / R\n\n            # Combine constrained and unconstrained regions\n            c_policy = np.zeros_like(a_grid)\n            \n            # Identify constrained region\n            a_bind_threshold = a_endog[0]\n            constrained_mask = a_grid < a_bind_threshold\n\n            # Solve for constrained agents\n            a_constrained = a_grid[constrained_mask]\n            l_constrained = np.array([_solve_l_constrained(a, params) for a in a_constrained])\n            c_constrained = R * a_constrained + w * l_constrained - a_min\n            c_policy[constrained_mask] = c_constrained\n\n            # Interpolate for unconstrained agents\n            unconstrained_mask = ~constrained_mask\n            if np.any(unconstrained_mask):\n                c_unconstrained_interp = interp1d(a_endog, c_endog, kind='linear', fill_value='extrapolate')\n                c_policy[unconstrained_mask] = c_unconstrained_interp(a_grid[unconstrained_mask])\n            \n            c_policy = np.maximum(c_min_val, c_policy)\n\n            # Check for convergence\n            diff = np.max(np.abs(c_policy - c_old))\n            if diff < tol:\n                break\n\n        # Post-convergence: Calculate Euler residuals\n        c_final_interp = interp1d(a_grid, c_policy, kind='linear', fill_value='extrapolate')\n        \n        c_t = c_policy\n        l_t = (w/chi * np.maximum(c_t, c_min_val)**(-sigma))**(1.0/phi)\n        l_t = np.minimum(l_t, l_max)\n\n        a_t_plus_1 = R * a_grid + w * l_t - c_t\n        \n        c_t_plus_1 = c_final_interp(a_t_plus_1)\n        c_t_plus_1 = np.maximum(c_min_val, c_t_plus_1)\n        \n        mu_t = np.maximum(c_t, c_min_val)**(-sigma)\n        mu_t_plus_1 = np.maximum(c_t_plus_1, c_min_val)**(-sigma)\n\n        residuals = np.zeros_like(a_grid)\n        \n        # Unconstrained residuals\n        unc_mask = a_t_plus_1 > a_min\n        residuals[unc_mask] = np.abs(mu_t[unc_mask] - beta * R * mu_t_plus_1[unc_mask])\n\n        # Constrained residuals\n        cons_mask = ~unc_mask\n        residuals[cons_mask] = np.maximum(0, mu_t[cons_mask] - beta * R * mu_t_plus_1[cons_mask])\n\n        return np.max(residuals)\n\n    # Test cases from the problem statement\n    test_cases = [\n        (0.96, 2.0, 1.0, 1.0, 1.03, 1.0, 0.0, 20.0, 1.0),\n        (0.96, 2.0, 3.0, 1.0, 1.03, 1.0, 0.0, 20.0, 1.0),\n        (0.96, 2.0, 1.0, 1.0, 1.04, 0.5, 0.0, 20.0, 1.0),\n        (0.96, 2.0, 0.2, 1.0, 1.02, 1.0, 0.0, 20.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        max_residual = compute_policy_and_residual(case)\n        results.append(max_residual)\n\n    # Format and print the final output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```</answer>", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Main function to solve the consumption-savings problem for four test cases\n    and print the formatted results.\n    \"\"\"\n\n    def _bisection(f, a, b, tol=1e-10, max_iter=100):\n        \"\"\"A simple bisection root-finder.\"\"\"\n        fa = f(a)\n        for _ in range(max_iter):\n            mid = a + 0.5 * (b - a)\n            if (b - a) * 0.5 < tol:\n                return mid\n            fmid = f(mid)\n            if np.sign(fmid) == np.sign(fa):\n                a = mid\n                fa = fmid\n            else:\n                b = mid\n        return (a + b) / 2.0\n\n    def _solve_l_constrained(a_t, params):\n        \"\"\"\n        Solves for the optimal labor supply l_t for a borrowing-constrained agent.\n        The choice of next-period asset is fixed at a_min.\n        \"\"\"\n        beta, sigma, chi, phi, R, w, a_min, a_max, l_max = params\n        c_min_val = 1e-8\n\n        def foc_l(l, current_a):\n            \"\"\"The first-order condition for labor choice.\"\"\"\n            cons = R * current_a + w * l - a_min\n            if cons <= 0:\n                return 1e12  # Effectively infinite marginal utility of consumption\n            \n            marginal_utility_c = cons**(-sigma)\n            \n            if l <= 0:\n                # With phi > 0, marginal disutility of labor at l=0 is 0.\n                marginal_disutility_l = 0\n            else:\n                marginal_disutility_l = chi * l**phi\n            \n            return marginal_utility_c * w - marginal_disutility_l\n\n        # Check consumption at l=0. If not positive, agent must work.\n        cons_at_zero_l = R * a_t - a_min\n        if cons_at_zero_l <= c_min_val:\n            # Agent must work to survive (c > 0). Find the minimum required labor.\n            l_lower_bound = (a_min - R * a_t + c_min_val) / w if w > 0 else l_max\n            l_search_min = min(max(0, l_lower_bound), l_max)\n\n            if l_search_min >= l_max:\n                return l_max\n\n            # If FOC is positive at l_max, l_max is the solution.\n            if foc_l(l_max, a_t) >= 0:\n                return l_max\n            \n            # Otherwise, find the root between the minimum required labor and l_max.\n            return _bisection(lambda l: foc_l(l, a_t), l_search_min, l_max)\n        else:\n            # Agent can survive without working. Interior solution for l is possible.\n            # If FOC is negative at l=0, l=0 is optimal.\n            if foc_l(0, a_t) <= 0:\n                return 0.0\n            \n            # If FOC is positive at l_max, l_max is optimal.\n            if foc_l(l_max, a_t) >= 0:\n                return l_max\n                \n            # Otherwise, find interior solution between 0 and l_max.\n            return _bisection(lambda l: foc_l(l, a_t), 0.0, l_max)\n\n    def compute_policy_and_residual(params):\n        \"\"\"\n        Computes the stationary policy functions and the max Euler residual\n        for a given set of parameters.\n        \"\"\"\n        beta, sigma, chi, phi, R, w, a_min, a_max, l_max = params\n        \n        # Numerical parameters\n        N_a = 200\n        tol = 1e-9\n        c_min_val = 1e-8\n\n        # Grids\n        a_grid = np.linspace(a_min, a_max, N_a)\n        \n        # Initial guess for consumption policy\n        c_policy = (R - 1) * a_grid + w * l_max / 2  # A simple guess\n\n        # Policy function iteration loop\n        max_iter = 1000\n        for it in range(max_iter):\n            c_old = c_policy.copy()\n            c_interp = interp1d(a_grid, c_old, kind='linear', fill_value='extrapolate')\n\n            # EGM Step for unconstrained region\n            a_prime_grid = a_grid  # Choices for a_t+1 are on the grid\n            c_prime = c_interp(a_prime_grid)\n            c_prime = np.maximum(c_min_val, c_prime)\n            \n            mu_prime = c_prime**(-sigma)\n            mu_curr = beta * R * mu_prime\n            c_endog = mu_curr**(-1.0/sigma)\n            \n            l_endog = (w/chi * c_endog**(-sigma))**(1.0/phi)\n            l_endog = np.minimum(l_endog, l_max)\n            \n            a_endog = (c_endog + a_prime_grid - w * l_endog) / R\n\n            # Combine constrained and unconstrained regions\n            c_policy = np.zeros_like(a_grid)\n            \n            # Identify constrained region\n            a_bind_threshold = a_endog[0]\n            constrained_mask = a_grid < a_bind_threshold\n\n            # Solve for constrained agents\n            a_constrained = a_grid[constrained_mask]\n            l_constrained = np.array([_solve_l_constrained(a, params) for a in a_constrained])\n            c_constrained = R * a_constrained + w * l_constrained - a_min\n            c_policy[constrained_mask] = c_constrained\n\n            # Interpolate for unconstrained agents\n            unconstrained_mask = ~constrained_mask\n            if np.any(unconstrained_mask):\n                c_unconstrained_interp = interp1d(a_endog, c_endog, kind='linear', fill_value='extrapolate')\n                c_policy[unconstrained_mask] = c_unconstrained_interp(a_grid[unconstrained_mask])\n            \n            c_policy = np.maximum(c_min_val, c_policy)\n\n            # Check for convergence\n            diff = np.max(np.abs(c_policy - c_old))\n            if diff < tol:\n                break\n\n        # Post-convergence: Calculate Euler residuals\n        c_final_interp = interp1d(a_grid, c_policy, kind='linear', fill_value='extrapolate')\n        \n        c_t = c_policy\n        l_t = (w/chi * np.maximum(c_t, c_min_val)**(-sigma))**(1.0/phi)\n        l_t = np.minimum(l_t, l_max)\n\n        a_t_plus_1 = R * a_grid + w * l_t - c_t\n        \n        c_t_plus_1 = c_final_interp(a_t_plus_1)\n        c_t_plus_1 = np.maximum(c_min_val, c_t_plus_1)\n        \n        mu_t = np.maximum(c_t, c_min_val)**(-sigma)\n        mu_t_plus_1 = np.maximum(c_t_plus_1, c_min_val)**(-sigma)\n\n        residuals = np.zeros_like(a_grid)\n        \n        # Unconstrained residuals\n        unc_mask = a_t_plus_1 > a_min\n        residuals[unc_mask] = np.abs(mu_t[unc_mask] - beta * R * mu_t_plus_1[unc_mask])\n\n        # Constrained residuals\n        cons_mask = ~unc_mask\n        residuals[cons_mask] = np.maximum(0, mu_t[cons_mask] - beta * R * mu_t_plus_1[cons_mask])\n\n        return np.max(residuals)\n\n    # Test cases from the problem statement\n    test_cases = [\n        (0.96, 2.0, 1.0, 1.0, 1.03, 1.0, 0.0, 20.0, 1.0),\n        (0.96, 2.0, 3.0, 1.0, 1.03, 1.0, 0.0, 20.0, 1.0),\n        (0.96, 2.0, 1.0, 1.0, 1.04, 0.5, 0.0, 20.0, 1.0),\n        (0.96, 2.0, 0.2, 1.0, 1.02, 1.0, 0.0, 20.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        max_residual = compute_policy_and_residual(case)\n        results.append(max_residual)\n\n    # Format and print the final output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}