{"hands_on_practices": [{"introduction": "在经济学中，我们常常需要从微观层面（如单个公司）的行为汇总出宏观总览。这个练习将向您展示，一个看似复杂的多维积分问题，有时可以通过巧妙的解析方法解决。通过利用对数正态分布的矩生成函数（MGF），您可以将问题简化为一个精确的解析表达式，这突显了在投入计算之前首先寻求理论捷径的重要性[@problem_id:2415557]。", "id": "2415557", "problem": "一个由大量异质性企业组成的连续统一体根据企业级生产函数 $y(z,k)=z^{\\alpha}k^{\\beta}$ 生产产出，其中 $z>0$ 是企业生产率，$k>0$ 是企业资本。在该模型的稳态均衡中，$(\\ln Z,\\ln K)$ 的联合分布是二元正态分布，其均值向量为 $\\mu=\\begin{bmatrix}\\mu_z\\\\ \\mu_k\\end{bmatrix}$，协方差矩阵为 $\\Sigma=\\begin{bmatrix}\\sigma_z^2 & \\rho\\,\\sigma_z\\sigma_k\\\\ \\rho\\,\\sigma_z\\sigma_k & \\sigma_k^2\\end{bmatrix}$，其中 $\\sigma_z>0$，$\\sigma_k>0$，且 $-1&lt;\\rho&lt;1$。定义 $Z=\\exp(X_z)$ 和 $K=\\exp(X_k)$，其中 $(X_z,X_k)\\sim \\mathcal{N}(\\mu,\\Sigma)$。总产出是期望\n$$\nY=\\mathbb{E}\\!\\left[Z^{\\alpha}K^{\\beta}\\right]\n=\\iint_{\\mathbb{R}^2}\\exp(\\alpha x+\\beta y)\\,\\phi(x,y;\\mu,\\Sigma)\\,dx\\,dy,\n$$\n其中二元正态密度为\n$$\n\\phi(x,y;\\mu,\\Sigma)=\\frac{1}{2\\pi\\sqrt{\\det\\Sigma}}\\exp\\!\\left(-\\tfrac{1}{2}\\begin{bmatrix}x-\\mu_z & y-\\mu_k\\end{bmatrix}\\Sigma^{-1}\\begin{bmatrix}x-\\mu_z\\\\ y-\\mu_k\\end{bmatrix}\\right).\n$$\n\n您的任务是为下面的测试组中的每个参数集计算 $Y$。所有量都是无量纲的。您的程序必须独立处理每个测试用例，并返回四舍五入到六位小数的浮点数形式的总产出。\n\n测试组 (每个测试用例为 $(\\alpha,\\beta,\\mu_z,\\mu_k,\\sigma_z,\\sigma_k,\\rho)$):\n- 用例 1: $(0.3,0.6,0.1,0.2,0.3,0.4,0.3)$\n- 用例 2: $(0.5,0.4,0.0,0.0,10^{-6},10^{-6},0.0)$\n- 用例 3: $(0.4,0.5,0.1,-0.1,0.5,0.6,0.0)$\n- 用例 4: $(0.2,0.79,0.0,0.0,0.8,0.9,0.95)$\n- 用例 5: $(0.45,0.5,-0.2,0.3,1.0,1.0,-0.8)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表 (例如，$[r_1,r_2,r_3,r_4,r_5]$)，其中每个 $r_i$ 是对应测试用例计算出的 $Y$，四舍五入到六位小数。不应打印任何其他文本。", "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，是良置的、客观的。它提出了一个经济学理论中的标准问题，涉及在企业异质性具有分布假设的情况下，对企业级产出进行加总。我将继续提供解答。\n\n问题要求计算总产出 $Y$，其定义为企业级生产函数 $y(Z,K) = Z^{\\alpha}K^{\\beta}$ 在企业生产率 $Z$ 和资本 $K$ 的联合分布上的期望。\n\n给定条件如下：\n- 生产函数: $y(Z,K) = Z^{\\alpha}K^{\\beta}$\n- 对数正态分布: 指定了 $(\\ln Z, \\ln K)$ 服从二元正态分布。令 $X_z = \\ln Z$ 和 $X_k = \\ln K$。那么随机向量 $\\begin{bmatrix} X_z \\\\ X_k \\end{bmatrix}$ 服从二元正态分布 $\\mathcal{N}(\\mu, \\Sigma)$。\n- 均值向量为 $\\mu = \\begin{bmatrix} \\mu_z \\\\ \\mu_k \\end{bmatrix}$。\n- 协方差矩阵为 $\\Sigma = \\begin{bmatrix} \\sigma_z^2 & \\rho\\,\\sigma_z\\sigma_k\\\\ \\rho\\,\\sigma_z\\sigma_k & \\sigma_k^2 \\end{bmatrix}$。\n\n总产出 $Y$ 是期望：\n$$\nY = \\mathbb{E}\\left[Z^{\\alpha}K^{\\beta}\\right]\n$$\n通过代入 $Z = \\exp(X_z)$ 和 $K = \\exp(X_k)$，表达式变为：\n$$\nY = \\mathbb{E}\\left[\\left(\\exp(X_z)\\right)^{\\alpha}\\left(\\exp(X_k)\\right)^{\\beta}\\right] = \\mathbb{E}\\left[\\exp(\\alpha X_z + \\beta X_k)\\right]\n$$\n这个期望恰好是二元正态随机向量 $X = \\begin{bmatrix} X_z \\\\ X_k \\end{bmatrix}$ 的矩生成函数 (MGF)，在点 $t = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}$ 处求值。\n\n问题中给出的定义积分，\n$$\nY=\\iint_{\\mathbb{R}^2}\\exp(\\alpha x+\\beta y)\\,\\phi(x,y;\\mu,\\Sigma)\\,dx\\,dy\n$$\n是正确的，但代表了一种朴素的计算路径。当存在闭式解析解时，数值积分是不必要的，并且在计算上较差。严谨的方法是利用多元正态分布的性质。\n\n对于一个一般的 $d$ 维正态随机向量 $X \\sim \\mathcal{N}(\\mu, \\Sigma)$，其 MGF 由以下公式给出：\n$$\nM_X(t) = \\mathbb{E}\\left[\\exp(t^T X)\\right] = \\exp\\left(t^T \\mu + \\frac{1}{2} t^T \\Sigma t\\right)\n$$\n在我们的二维情况下，我们有 $t = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}$，$\\mu = \\begin{bmatrix} \\mu_z \\\\ \\mu_k \\end{bmatrix}$，和 $\\Sigma = \\begin{bmatrix} \\sigma_z^2 & \\rho\\sigma_z\\sigma_k \\\\ \\rho\\sigma_z\\sigma_k & \\sigma_k^2 \\end{bmatrix}$。\n\n我们现在计算 MGF 指数中的两项。\n第一项是线性项：\n$$\nt^T \\mu = \\begin{bmatrix} \\alpha & \\beta \\end{bmatrix} \\begin{bmatrix} \\mu_z \\\\ \\mu_k \\end{bmatrix} = \\alpha\\mu_z + \\beta\\mu_k\n$$\n第二项是二次项：\n$$\nt^T \\Sigma t = \\begin{bmatrix} \\alpha & \\beta \\end{bmatrix} \\begin{bmatrix} \\sigma_z^2 & \\rho\\sigma_z\\sigma_k \\\\ \\rho\\sigma_z\\sigma_k & \\sigma_k^2 \\end{bmatrix} \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}\n$$\n进行矩阵乘法得到：\n$$\nt^T \\Sigma t = \\begin{bmatrix} \\alpha & \\beta \\end{bmatrix} \\begin{bmatrix} \\alpha\\sigma_z^2 + \\beta\\rho\\sigma_z\\sigma_k \\\\ \\alpha\\rho\\sigma_z\\sigma_k + \\beta\\sigma_k^2 \\end{bmatrix}\n$$\n$$\nt^T \\Sigma t = \\alpha(\\alpha\\sigma_z^2 + \\beta\\rho\\sigma_z\\sigma_k) + \\beta(\\alpha\\rho\\sigma_z\\sigma_k + \\beta\\sigma_k^2)\n$$\n$$\nt^T \\Sigma t = \\alpha^2\\sigma_z^2 + \\alpha\\beta\\rho\\sigma_z\\sigma_k + \\alpha\\beta\\rho\\sigma_z\\sigma_k + \\beta^2\\sigma_k^2\n$$\n$$\nt^T \\Sigma t = \\alpha^2\\sigma_z^2 + \\beta^2\\sigma_k^2 + 2\\alpha\\beta\\rho\\sigma_z\\sigma_k\n$$\n将这些项代回 MGF 公式，我们得到总产出 $Y$ 的解析表达式：\n$$\nY = \\exp\\left( (\\alpha\\mu_z + \\beta\\mu_k) + \\frac{1}{2}(\\alpha^2\\sigma_z^2 + \\beta^2\\sigma_k^2 + 2\\alpha\\beta\\rho\\sigma_z\\sigma_k) \\right)\n$$\n该公式是精确的，避免了数值积分的复杂性和潜在的不准确性。实现将为每个提供的参数集评估此闭式表达式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aggregate output Y for several parameter sets based on an\n    analytical formula for the expectation of a function of two correlated\n    log-normal random variables.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, beta, mu_z, mu_k, sigma_z, sigma_k, rho)\n    test_cases = [\n        (0.3, 0.6, 0.1, 0.2, 0.3, 0.4, 0.3),\n        (0.5, 0.4, 0.0, 0.0, 1e-6, 1e-6, 0.0),\n        (0.4, 0.5, 0.1, -0.1, 0.5, 0.6, 0.0),\n        (0.2, 0.79, 0.0, 0.0, 0.8, 0.9, 0.95),\n        (0.45, 0.5, -0.2, 0.3, 1.0, 1.0, -0.8),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, beta, mu_z, mu_k, sigma_z, sigma_k, rho = case\n\n        # The aggregate output Y is the moment-generating function of the\n        # bivariate normal vector (ln Z, ln K) evaluated at t = (alpha, beta).\n        # Y = exp(t' * mu + 0.5 * t' * Sigma * t)\n        \n        # Linear term: t' * mu\n        linear_term = alpha * mu_z + beta * mu_k\n        \n        # Quadratic term: t' * Sigma * t\n        quadratic_term = (alpha**2 * sigma_z**2 \n                          + beta**2 * sigma_k**2 \n                          + 2 * alpha * beta * rho * sigma_z * sigma_k)\n        \n        # Combine terms in the exponent and calculate Y\n        exponent = linear_term + 0.5 * quadratic_term\n        y_aggregate = np.exp(exponent)\n        \n        # Append the result rounded to six decimal places\n        results.append(round(y_aggregate, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "金融衍生品的定价常常归结为计算其在多个相关风险因子上的期望收益。当解析解不存在时，确定性积分方法，如高斯-埃尔米特正交积分法（Gauss-Hermite quadrature），为中低维度问题提供了强大而精确的工具。本练习将指导您应用此方法，通过关键的 Cholesky 分解处理风险因子之间的相关性，从而为复杂的金融工具定价[@problem_id:2415537]。", "id": "2415537", "problem": "考虑一种衍生证券，其在到期时间 $T$ 支付的金额为 $g(I)$，其中 $I$ 是在 $[0,T]$ 区间上一个具有 $d$ 个子区间的均匀分区下，随机波动率平方的时间积分，因此\n$$\nI \\equiv \\sum_{i=1}^{d} \\exp\\left(2 X_i\\right)\\,\\Delta t,\\quad \\Delta t \\equiv \\frac{T}{d}.\n$$\n对数波动率向量 $\\mathbf{X} = (X_1,\\dots,X_d)^\\top$ 在风险中性测度下被建模为一个相关的多元高斯向量，其均值向量为 $\\boldsymbol{\\mu} = (m,\\dots,m)^\\top$，协方差矩阵 $\\mathbf{C}$ 由下式给出\n$$\n\\mathbf{X} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C}),\\quad \\mathbf{C}_{ij} = s^2\\,\\rho^{|i-j|}\\ \\text{for}\\ i,j \\in \\{1,\\dots,d\\},\n$$\n其中波动率的波动率参数为 $s > 0$，时间自相关参数为 $\\rho \\in (-1,1)$。该衍生品的收益为关于积分方差的看涨期权，\n$$\ng(I) = \\max(I - K, 0),\n$$\n行权价为 $K > 0$。在时间 $0$，风险中性测度下，以连续复利无风险利率 $r$ 计算的无套利价格为\n$$\nV_0 = e^{-rT}\\,\\mathbb{E}\\big[g(I)\\big],\n$$\n其中期望是根据 $\\mathbf{X}$ 的联合分布计算的。\n\n您的任务是编写一个完整的程序，通过使用确定性乘积 Gauss–Hermite 求积法，数值计算 $d$ 维期望 $\\mathbb{E}[g(I)]$，从而得到 $V_0$。请从以下基本原理出发：\n- 风险中性定价原理 $V_0 = e^{-rT}\\,\\mathbb{E}[\\text{payoff}]$。\n- 多元正态分布的定义以及独立标准正态变量的仿射变换。\n- 一维经典 Gauss–Hermite 求积法则及其到多维的张量积扩展。\n您必须推导出适当的变量变换，将关于多元正态分布的期望转化为适用于乘积 Gauss–Hermite 求积法的形式，首先针对独立标准正态情况，然后通过仿射变换处理相关情况。请勿使用蒙特卡洛或准蒙特卡洛方法；仅使用 $d$ 维的确定性 Gauss–Hermite 求积法。\n\n精度和数值稳定性要求：\n- 精确地按规定构建协方差矩阵 $\\mathbf{C}$。\n- 使用 Cholesky 分解将独立标准正态变量映射到与 $\\mathbf{C}$ 一致的相关正态变量。\n- 实现每维 $q$ 个节点的 $d$ 维乘积 Gauss–Hermite 求积法，并确保权重和节点针对标准正态分布下的期望进行了正确缩放。\n- 为指定的测试套件计算出数值稳定的 $V_0$ 值。\n\n输入和输出格式：\n- 无外部输入；您的程序必须硬编码以下测试套件，计算相应的价格，并打印一行包含以逗号分隔的价格列表，格式为 Python 风格的列表，按测试用例的顺序排列，每个数字都以定点表示法的小数形式输出。\n\n测试套件：\n- 案例 A (一维基准)：\n  - $d = 1$，$T = 1.0$，$r = 0.02$，$m = -1.0$，$s = 0.5$，$\\rho = 0.0$，$K = 0.5$，$q = 50$。\n- 案例 B (二维，弱相关)：\n  - $d = 2$，$T = 1.0$，$r = 0.01$，$m = -1.0$，$s = 0.6$，$\\rho = 0.3$，$K = 0.8$，$q = 12$。\n- 案例 C (三维，更强相关性和更长的时间范围)：\n  - $d = 3$，$T = 2.0$，$r = 0.03$，$m = -1.2$，$s = 0.7$，$\\rho = 0.5$，$K = 1.0$，$q = 8$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[xA,xB,xC]”），其中 $xA$、$xB$ 和 $xC$ 分别是案例 A、B 和 C 的价格，每个价格都精确到小数点后 $10$ 位打印。", "solution": "该问题要求计算一个欧式衍生证券的无套利价格 $V_0$。该价格由基本的风险中性估值公式确定：\n$$\nV_0 = e^{-rT}\\,\\mathbb{E}\\big[g(I)\\big]\n$$\n其中 $r$ 是连续复利无风险利率，$T$ 是到期时间，$g(I) = \\max(I - K, 0)$ 是收益函数，它依赖于积分平方波动率的代理变量 $I$。行权价为 $K$。\n\n积分方差代理变量 $I$ 被定义为离散时间网格上的一个和：\n$$\nI = \\sum_{i=1}^{d} \\exp\\left(2 X_i\\right)\\,\\Delta t, \\quad \\text{with } \\Delta t = \\frac{T}{d}\n$$\n对数波动率向量 $\\mathbf{X} = (X_1, \\dots, X_d)^\\top$ 被建模为多元正态随机变量，$\\mathbf{X} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C})$。其均值向量为 $\\boldsymbol{\\mu} = (m, \\dots, m)^\\top$，协方差矩阵是一个 Toeplitz 矩阵，其元素由 $\\mathbf{C}_{ij} = s^2 \\rho^{|i-j|}$ 给出，参数 $s > 0$ 且 $\\rho \\in (-1, 1)$。\n\n任务的核心是数值计算 $d$ 维期望 $\\mathbb{E}[g(I)]$。该期望是关于多元正态概率密度函数 $p(\\mathbf{x}; \\boldsymbol{\\mu}, \\mathbf{C})$ 在 $\\mathbb{R}^d$ 上的积分：\n$$\n\\mathbb{E}[g(I)] = \\int_{\\mathbb{R}^d} g(I(\\mathbf{x})) \\, p(\\mathbf{x}; \\boldsymbol{\\mu}, \\mathbf{C}) \\, d\\mathbf{x}\n$$\n我们被要求使用确定性乘积 Gauss-Hermite 求积法，这需要将积分变换为此方法适用的形式。\n\n经典的一维 Gauss-Hermite 求积法则旨在逼近以权重函数 $e^{-y^2}$ 加权的积分：\n$$\n\\int_{-\\infty}^{\\infty} f(y) e^{-y^2} dy \\approx \\sum_{k=1}^{q} w_k f(y_k)\n$$\n其中 $y_k$ 是 $q$ 个节点（Hermite 多项式 $H_q(y)$ 的根），$w_k$ 是对应的权重。为了计算关于标准正态变量 $Z \\sim \\mathcal{N}(0, 1)$（其概率密度函数为 $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}}e^{-z^2/2}$）的期望，我们进行变量替换 $z = \\sqrt{2}y$。期望积分变为：\n$$\n\\mathbb{E}[h(Z)] = \\int_{-\\infty}^{\\infty} h(z) \\frac{e^{-z^2/2}}{\\sqrt{2\\pi}} dz = \\int_{-\\infty}^{\\infty} h(\\sqrt{2}y) \\frac{e^{-y^2}}{\\sqrt{2\\pi}} \\sqrt{2}dy = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} h(\\sqrt{2}y) e^{-y^2} dy\n$$\n应用求积法则得到近似值：\n$$\n\\mathbb{E}[h(Z)] \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{k=1}^{q} w_k h(\\sqrt{2}y_k)\n$$\n这可以通过定义缩放后的节点 $\\tilde{z}_k = \\sqrt{2}y_k$ 和缩放后的权重 $\\tilde{w}_k = w_k / \\sqrt{\\pi}$ 来更紧凑地表示，从而得到：\n$$\n\\mathbb{E}[h(Z)] \\approx \\sum_{k=1}^{q} \\tilde{w}_k h(\\tilde{z}_k)\n$$\n对于一个由独立标准正态变量组成的 $d$ 维向量 $\\mathbf{Z} = (Z_1, \\dots, Z_d)^\\top$，其期望通过对所有 $q^d$ 个网格点上的一维法则进行张量积来近似：\n$$\n\\mathbb{E}[H(\\mathbf{Z})] \\approx \\sum_{k_1=1}^q \\cdots \\sum_{k_d=1}^q H(\\tilde{z}_{k_1}, \\dots, \\tilde{z}_{k_d}) \\prod_{i=1}^d \\tilde{w}_{k_i}\n$$\n对数波动率向量 $\\mathbf{X}$ 是相关的，而非标准正态分布。因此，我们必须将积分域从 $\\mathbf{X} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C})$ 变换到 $\\mathbf{Z} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I})$。这通过仿射变换实现：\n$$\n\\mathbf{X} = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z}\n$$\n其中 $\\mathbf{L}$ 是一个满足 $\\mathbf{L}\\mathbf{L}^\\top = \\mathbf{C}$ 的矩阵。这样的矩阵 $\\mathbf{L}$ 可以通过对对称正定协方差矩阵 $\\mathbf{C}$ 进行 Cholesky 分解找到。然后，关于 $\\mathbf{X}$ 的期望被重写为关于 $\\mathbf{Z}$ 的等价期望：\n$$\n\\mathbb{E}_{\\mathbf{X}}[g(I(\\mathbf{X}))] = \\mathbb{E}_{\\mathbf{Z}}[g(I(\\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z}))]\n$$\n这个变换后的期望现在具有适用于乘积 Gauss-Hermite 求积法的形式。令新的被积函数为 $H(\\mathbf{Z}) = g(I(\\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z}))$。该期望由以下和式近似：\n$$\n\\mathbb{E}[g(I)] \\approx \\sum_{k_1, \\dots, k_d \\in \\{1,\\dots,q\\}} \\left( H(\\tilde{z}_{k_1}, \\dots, \\tilde{z}_{k_d}) \\prod_{i=1}^d \\tilde{w}_{k_i} \\right)\n$$\n总的算法执行步骤如下：\n1.  对每个测试用例，收集参数：$d, T, r, m, s, \\rho, K, q$。\n2.  构建 $d \\times d$ 的协方差矩阵 $\\mathbf{C}$（其元素为 $\\mathbf{C}_{ij} = s^2 \\rho^{|i-j|}$）和均值向量 $\\boldsymbol{\\mu}$。\n3.  对 $\\mathbf{C}$ 进行 Cholesky 分解以求得矩阵 $\\mathbf{L}$。\n4.  生成 $q$ 个一维 Gauss-Hermite 节点 $y_k$ 和权重 $w_k$。\n5.  对它们进行缩放，以获得适用于标准正态分布的节点 $\\tilde{z}_k = \\sqrt{2} y_k$ 和权重 $\\tilde{w}_k = w_k/\\sqrt{\\pi}$。\n6.  通过对缩放后的一维节点进行笛卡尔积，构建一个包含 $q^d$ 个节点的 $d$ 维网格。类似地，计算网格上每个点的权重乘积。\n7.  对于 $q^d$ 个网格点中的每一个 $\\mathbf{z}_{\\mathbf{k}}$：\n    a. 将标准正态节点变换到相关的对数波动率空间：$\\mathbf{x}_{\\mathbf{k}} = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{z}_{\\mathbf{k}}$。\n    b. 计算积分方差：$I_{\\mathbf{k}} = (T/d)\\sum_{i=1}^d \\exp(2 (\\mathbf{x}_{\\mathbf{k}})_i)$。\n    c. 评估收益：$g(I_{\\mathbf{k}}) = \\max(I_{\\mathbf{k}} - K, 0)$。\n    d. 将收益乘以对应的权重乘积 $W_{\\mathbf{k}} = \\prod_{i=1}^d \\tilde{w}_{k_i}$，并加到一个累加和中。\n8.  最终的和近似于 $\\mathbb{E}[g(I)]$。衍生品价格则是 $V_0 = e^{-rT}$ 乘以这个和。为提高效率，此过程以向量化方式实现。", "answer": "```python\nimport numpy as np\n\ndef compute_price(d, T, r, m, s, rho, K, q):\n    \"\"\"\n    Computes the derivative price V0 using d-dimensional Gauss-Hermite quadrature.\n\n    Args:\n        d (int): Dimension of the log-volatility vector.\n        T (float): Time to maturity.\n        r (float): Risk-free interest rate.\n        m (float): Mean of the log-volatility components.\n        s (float): Volatility-of-volatility parameter.\n        rho (float): Autocorrelation parameter.\n        K (float): Strike price.\n        q (int): Number of quadrature nodes per dimension.\n\n    Returns:\n        float: The computed arbitrage-free price V0.\n    \"\"\"\n    # Step 1: Construct mean vector and covariance matrix\n    mu = np.full(d, m)\n    indices = np.arange(d)\n    # Using broadcasting to create the Toeplitz covariance matrix efficiently\n    C = s**2 * rho**(np.abs(indices[:, np.newaxis] - indices))\n    \n    # Step 2: Perform Cholesky decomposition of the covariance matrix\n    # L is a lower-triangular matrix such that C = L @ L.T\n    try:\n        L = np.linalg.cholesky(C)\n    except np.linalg.LinAlgError:\n        # This should not happen for valid parameters rho in (-1, 1)\n        # but is good practice for numerical stability.\n        raise ValueError(\"Covariance matrix is not positive-definite.\")\n\n    # Step 3: Generate and scale 1D Gauss-Hermite nodes and weights\n    nodes_hermite, weights_hermite = np.polynomial.hermite.hermgauss(q)\n    # Scale nodes and weights for integration against the standard normal PDF\n    nodes_std_normal = nodes_hermite * np.sqrt(2.0)\n    weights_std_normal = weights_hermite / np.sqrt(np.pi)\n\n    # Step 4: Create d-dimensional grid of nodes and product weights\n    # The meshgrid approach creates all combinations of nodes for a vectorized calculation.\n    # It returns a list of d-dimensional arrays.\n    node_grids = np.meshgrid(*[nodes_std_normal for _ in range(d)])\n    # We stack the raveled grids to get an array of shape (q**d, d) where each row is a point.\n    z_vectors = np.stack([grid.ravel() for grid in node_grids], axis=1)\n    \n    # Similarly, create product weights for each point\n    weight_grids = np.meshgrid(*[weights_std_normal for _ in range(d)])\n    w_products = np.prod(np.stack([grid.ravel() for grid in weight_grids], axis=1), axis=1)\n    \n    # Step 5: Vectorized computation of the expectation\n    # Transform standard normal nodes z to correlated log-volatility nodes x\n    # z_vectors.T has shape (d, q**d). L @ z_vectors.T has shape (d, q**d).\n    # After transposing back, we have (q**d, d). Add mean vector mu.\n    x_vectors = mu + (L @ z_vectors.T).T\n    \n    # Calculate integrated variance I for all points\n    delta_t = T / d\n    I_values = delta_t * np.sum(np.exp(2.0 * x_vectors), axis=1)\n    \n    # Calculate payoffs for all points\n    payoffs = np.maximum(I_values - K, 0.0)\n    \n    # Step 6: Compute the expectation as the dot product of payoffs and weights\n    expectation = np.dot(payoffs, w_products)\n    \n    # Step 7: Discount the expectation to get the final price\n    price = np.exp(-r * T) * expectation\n    \n    return price\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite defined in the problem statement\n    test_cases = [\n        # Case A: 1D baseline\n        {'d': 1, 'T': 1.0, 'r': 0.02, 'm': -1.0, 's': 0.5, 'rho': 0.0, 'K': 0.5, 'q': 50},\n        # Case B: 2D, weak correlation\n        {'d': 2, 'T': 1.0, 'r': 0.01, 'm': -1.0, 's': 0.6, 'rho': 0.3, 'K': 0.8, 'q': 12},\n        # Case C: 3D, stronger correlation\n        {'d': 3, 'T': 2.0, 'r': 0.03, 'm': -1.2, 's': 0.7, 'rho': 0.5, 'K': 1.0, 'q': 8},\n    ]\n\n    results = []\n    for case in test_cases:\n        price = compute_price(**case)\n        # Format the result to 10 decimal places in fixed-point notation\n        results.append(f\"{price:.10f}\")\n\n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "当问题维度变得很高时，确定性积分方法会因“维度灾难”而失效，此时我们转向基于采样的方法。拟蒙特卡洛（Quasi-Monte Carlo, QMC）方法，如使用索博尔（Sobol）序列，通常比标准蒙特卡洛（Monte Carlo）方法收敛得更快。然而，本练习是一个重要的警示：您将构建一个在经济学上貌似合理的情景，其中看似优越的 QMC 方法的表现反而不如标准蒙特卡洛方法，这强调了深入理解计算工具内在机理而非盲目应用的重要性[@problem_id:2415504]。", "id": "2415504", "problem": "考虑一个期望收益的积分，该收益取决于 $d$ 个独立的风险因子，这些风险因子被建模为一个由独立 Uniform$([0,1])$ 随机变量组成的向量 $U=(U_{1},\\dots,U_{d})$。对于整数 $m \\ge 1$，定义样本大小为 $N=2^{m}$。令 $p=2^{-(m+1)}$ 且 $\\tau=1-p=1-2^{-(m+1)}$。在 $[0,1]^{d}$ 上定义以下两个收益函数：\n\n1. 病态但在经济学上合理的极端触发式数字收益（可解释为仅当至少一个时期表现出极端正向冲击时才支付的票息）：\n$$\ng_{d,m}(u) \\;=\\; \\mathbf{1}\\Big\\{\\max_{1 \\le i \\le d} u_{i} \\ge \\tau\\Big\\}.\n$$\n\n2. 平滑的基准收益：\n$$\nh_{d}(u) \\;=\\; \\exp\\Big(-\\sum_{i=1}^{d} u_{i}\\Big).\n$$\n\n对于每种收益，目标是在 Uniform$([0,1])$ 因子下的风险中性期望值，即\n$$\nG(d,m) \\;=\\; \\mathbb{E}\\big[g_{d,m}(U)\\big] \\;=\\; 1 - \\big(1 - p\\big)^{d} \\quad\\text{with}\\quad p=2^{-(m+1)},\n$$\n和\n$$\nH(d) \\;=\\; \\mathbb{E}\\big[h_{d}(U)\\big] \\;=\\; \\prod_{i=1}^{d} \\int_{0}^{1} e^{-u_{i}} \\, du_{i} \\;=\\; \\big(1 - e^{-1}\\big)^{d}.\n$$\n\n您将使用相同的样本大小 $N=2^{m}$ 实现这两个期望值的两种估计量：\n\n- 一个基于 $d$ 维 Sobol 以 2 为底数的数字网格的前 $2^{m}$ 个点的低偏差估计量。\n- 一个基于 $d$ 维空间中 $N$ 个独立同分布的 Uniform$([0,1])$ 点的标准蒙特卡洛估计量。\n\n对于下述每个测试用例，计算两种估计量相对于相应精确值（$G(d,m)$ 或 $H(d)$）的绝对误差，并返回一个布尔值，指示基于 Sobol 的绝对误差是否严格大于标准蒙特卡洛的绝对误差。\n\n测试套件（每一项是一个元组，指定要积分的收益类型、维度 $d$ 以及定义 $N=2^{m}$ 的指数 $m$）：\n\n- 用例 1：$\\big(\\text{数字类型},\\, d=100,\\, m=10\\big)$，用于评估 $G(100,10)$。\n- 用例 2：$\\big(\\text{平滑类型},\\, d=20,\\, m=10\\big)$，用于评估 $H(20)$。\n- 用例 3：$\\big(\\text{数字类型},\\, d=1,\\, m=10\\big)$，用于评估 $G(1,10)$。\n\n您的程序必须生成单行输出，其中包含按测试套件顺序排列的结果，格式为方括号内的逗号分隔列表，例如 $[\\text{true},\\text{false},\\text{true}]$，但需使用相应编程语言的规范布尔字面量。\n\n不涉及物理单位。如果出现任何角度，则必须以弧度为单位，但此处不需要。每个测试用例的最终输出是如上所述的布尔值。不要读取任何输入；请逐字使用上面给定的测试套件。", "solution": "我们首先形式化被估量及其精确值，然后从第一性原理出发设计两种基于抽样的估计量。令 $U=(U_{1},\\dots,U_{d})$，其分量独立同分布，且均服从 Uniform$([0,1])$ 分布。\n\n对于极端触发式数字收益 $g_{d,m}$，\n$$\ng_{d,m}(u) = \\mathbf{1}\\Big\\{\\max_{1 \\le i \\le d} u_{i} \\ge \\tau\\Big\\}, \\quad \\tau = 1 - p, \\quad p=2^{-(m+1)}.\n$$\n其精确期望是至少一个坐标超过阈值 $\\tau$ 的概率：\n$$\nG(d,m) = \\mathbb{E}[g_{d,m}(U)] = \\mathbb{P}\\Big(\\max_{1 \\le i \\le d} U_{i} \\ge \\tau\\Big) = 1 - \\mathbb{P}\\Big(\\max_{1 \\le i \\le d} U_{i} < \\tau\\Big).\n$$\n由于 $U_{i}$ 是独立同分布的，\n$$\n\\mathbb{P}\\Big(\\max_{1 \\le i \\le d} U_{i} < \\tau\\Big) = \\prod_{i=1}^{d} \\mathbb{P}(U_{i} < \\tau) = \\tau^{d} = \\big(1 - p\\big)^{d},\n$$\n因此\n$$\nG(d,m) = 1 - \\big(1 - p\\big)^{d}, \\quad p=2^{-(m+1)}.\n$$\n\n对于平滑收益 $h_{d}$，\n$$\nh_{d}(u) = \\exp\\Big(-\\sum_{i=1}^{d} u_{i}\\Big) = \\prod_{i=1}^{d} e^{-u_{i}}.\n$$\n利用独立性和 Fubini 定理，\n$$\nH(d) = \\mathbb{E}[h_{d}(U)] = \\prod_{i=1}^{d} \\int_{0}^{1} e^{-u_{i}} \\, du_{i} = \\big(1 - e^{-1}\\big)^{d}.\n$$\n\n我们考虑两种使用相同样本大小 $N=2^{m}$ 的积分法则：\n\n1. 基于 Sobol 的估计量。一个位于 $d$ 维空间中、以 2 为底数的 Sobol 数字网格，是一组在 $[0,1)^{d}$ 中具有低偏差特性的确定性点集，包含 $N$ 个点。将这些点记为 $\\{x^{(n)}\\}_{n=1}^{N}$。该估计量为\n$$\n\\widehat{I}_{\\text{Sob}} = \\frac{1}{N} \\sum_{n=1}^{N} f\\big(x^{(n)}\\big),\n$$\n其中 $f$ 是 $g_{d,m}$ 或 $h_{d}$。当精确使用由 2 的幂次法则生成的 $N=2^{m}$ 个点时， $x^{(n)}$ 的每个坐标都是一个最多有 $m$ 位的二进制小数，这意味着 $\\max_{1 \\le n \\le N,\\, 1 \\le i \\le d} x^{(n)}_{i} \\le 1 - 2^{-m}$。对于数字收益的阈值 $\\tau = 1 - 2^{-(m+1)}$，我们有 $1 - 2^{-m} < \\tau$，因此对所有 $n$ 都有 $g_{d,m}(x^{(n)})=0$。所以，对于 $g_{d,m}$，\n$$\n\\widehat{G}_{\\text{Sob}} = 0, \\quad \\big|\\widehat{G}_{\\text{Sob}} - G(d,m)\\big| = G(d,m) = 1 - \\big(1 - 2^{-(m+1)}\\big)^{d}.\n$$\n这种选择表现出确定性的低估，显示出一种病态的低劣表现。\n\n对于平滑收益 $h_{d}$，不会发生这种退化现象。与独立抽样相比，低偏差抽样通常会减少积分误差，尽管不能保证对每个问题都如此；其估计量是无此退化现象的相同均值。\n\n2. 标准蒙特卡洛估计量。从 Uniform$([0,1])^{d}$ 中抽取 $N$ 个独立同分布的样本 $\\{U^{(n)}\\}_{n=1}^{N}$，并计算\n$$\n\\widehat{I}_{\\text{MC}} = \\frac{1}{N} \\sum_{n=1}^{N} f\\big(U^{(n)}\\big).\n$$\n对于 $g_{d,m}$，每个加数都是一个成功概率为 $q = G(d,m)$ 的伯努利随机变量。该估计量是无偏的，其方差为\n$$\n\\mathbb{V}\\big[\\widehat{G}_{\\text{MC}}\\big] = \\frac{q(1-q)}{N}.\n$$\n对于 $p=2^{-(m+1)}$ 且 $d$ 中等大小的特定选择，当 $p$ 很小时，有 $q = 1 - (1-p)^{d} \\approx d\\,p$，因此预期其典型绝对误差的量级为 $\\sqrt{q(1-q)/N}$。相比之下，在 $N=2^{m}$ 时，用于 $g_{d,m}$ 的 Sobol 估计量产生一个等于 $q$ 本身的确定性绝对误差，这个误差可能远大于同样 $N$ 值下的蒙特卡洛抽样误差。\n\n算法设计。对于每个测试用例，我们计算精确值（数字收益为 $G(d,m)$，平滑收益为 $H(d)$）。然后我们计算两个估计值：(i) 基于 $d$ 维 Sobol 数字网格前 $2^{m}$ 个点的 Sobol 均值；(ii) 基于 $N=2^{m}$ 个独立样本的标准蒙特卡洛均值。然后我们报告基于 Sobol 的绝对误差是否严格大于标准蒙特卡洛的绝对误差。该测试套件包括：一个旨在触发 Sobol 法则的确定性低估的中等高维病态数字用例；一个用于评估在良态被积函数上典型行为的平滑用例；以及一个在一维情况下说明同样退化现象的最基本维度的边界数字用例。最终程序按测试套件的顺序打印一个布尔值列表。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import qmc\n\ndef digital_payoff_any_tail(samples: np.ndarray, tau: float) -> np.ndarray:\n    \"\"\"\n    Pathological but economically plausible digital payoff:\n    pays 1 if any coordinate exceeds tau, else 0.\n    samples: array of shape (N, d)\n    tau: threshold in (0,1)\n    Returns: array of shape (N,) with 0/1 values.\n    \"\"\"\n    return (samples.max(axis=1) >= tau).astype(float)\n\ndef smooth_payoff(samples: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Smooth benchmark payoff: exp(-sum_i u_i).\n    samples: array of shape (N, d)\n    Returns: array of shape (N,) with positive real values.\n    \"\"\"\n    return np.exp(-samples.sum(axis=1))\n\ndef exact_digital_expectation(d: int, m: int) -> float:\n    p = 2.0 ** (-(m + 1))\n    return 1.0 - (1.0 - p) ** d\n\ndef exact_smooth_expectation(d: int) -> float:\n    return (1.0 - np.exp(-1.0)) ** d\n\ndef sobol_estimate(d: int, m: int, which: str) -> float:\n    \"\"\"\n    Compute Sobol-based estimate using N=2^m points.\n    which: 'digital' or 'smooth'\n    \"\"\"\n    N = 2 ** m\n    engine = qmc.Sobol(d, scramble=False)\n    # Generate exactly 2^m points using the power-of-two method\n    samples = engine.random_base2(m)\n    if which == 'digital':\n        tau = 1.0 - 2.0 ** (-(m + 1))\n        vals = digital_payoff_any_tail(samples, tau)\n    elif which == 'smooth':\n        vals = smooth_payoff(samples)\n    else:\n        raise ValueError(\"Unknown payoff type.\")\n    return float(vals.mean())\n\ndef mc_estimate(d: int, m: int, which: str, seed: int) -> float:\n    \"\"\"\n    Compute standard Monte Carlo estimate with N=2^m IID uniforms.\n    which: 'digital' or 'smooth'\n    \"\"\"\n    N = 2 ** m\n    rng = np.random.default_rng(seed)\n    samples = rng.random((N, d))\n    if which == 'digital':\n        tau = 1.0 - 2.0 ** (-(m + 1))\n        vals = digital_payoff_any_tail(samples, tau)\n    elif which == 'smooth':\n        vals = smooth_payoff(samples)\n    else:\n        raise ValueError(\"Unknown payoff type.\")\n    return float(vals.mean())\n\ndef solve():\n    # Test suite: (which, d, m)\n    test_cases = [\n        (\"digital\", 100, 10),  # Pathological case\n        (\"smooth\", 20, 10),    # Smooth benchmark\n        (\"digital\", 1, 10),    # Boundary digital case\n    ]\n\n    results = []\n    # Use distinct seeds for MC to ensure deterministic but independent sampling per case\n    base_seed = 1234567\n    for idx, (which, d, m) in enumerate(test_cases):\n        # Exact value\n        if which == \"digital\":\n            exact = exact_digital_expectation(d, m)\n        else:\n            exact = exact_smooth_expectation(d)\n\n        # Sobol estimate\n        est_sobol = sobol_estimate(d, m, which)\n        err_sobol = abs(est_sobol - exact)\n\n        # MC estimate\n        est_mc = mc_estimate(d, m, which, seed=base_seed + 1000 * (idx + 1))\n        err_mc = abs(est_mc - exact)\n\n        # Compare absolute errors: True if Sobol performs worse\n        results.append(err_sobol > err_mc)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}