{"hands_on_practices": [{"introduction": "这个练习将指导你构建一个经典的人工证券市场模型，它通常被称为Brock-Hommes模型。你将模拟一个包含两种主要交易者类型的市场：依据资产基本价值 $v$ 交易的基本面分析者，以及追随价格趋势的图表分析者（或称技术分析者）。通过实现一个基于历史盈利表现的策略切换机制 [@problem_id:2372798]，你将亲手揭示市场价格动态、交易者群体构成和整体波动性之间复杂的反馈循环，这是理解市场内生动态的核心。", "id": "2372798", "problem": "构建一个人工股票市场 (ASM)，其中包含两种代表性策略：“基本面投资者”和“技术分析者”，时间为离散的，由 $t \\in \\{0,1,\\dots,T\\}$ 索引。设资产价格为 $p_t \\in \\mathbb{R}$，恒定的基本价值为 $v \\in \\mathbb{R}$。在时间 $t$，使用基本面策略和技术分析策略的代理人比例分别为 $w^F_t \\in [0,1]$ 和 $w^C_t \\in [0,1]$，且对于所有 $t$ 都有 $w^F_t + w^C_t = 1$。设 $p_{-1} = p_0$。\n\n在时间 $t$ 的个体（标准化）需求由以下公式给出：\n- 基本面投资者需求：$d^F_t = \\beta_F \\left( v - p_t \\right)$。\n- 技术分析者（趋势跟随）需求：$d^C_t = \\beta_C \\left( p_t - p_{t-1} \\right)$。\n\n总超额需求为 $ED_t = w^F_t d^F_t + w^C_t d^C_t$。做市商根据以下规则调整价格：\n$$\np_{t+1} = p_t + \\alpha \\, ED_t,\n$$\n其中 $\\alpha \\in \\mathbb{R}_{\\ge 0}$ 是价格影响参数。\n\n定义策略 $s \\in \\{F,C\\}$ 在时间 $t$ 的单期已实现利润为：\n$$\n\\pi^s_t = d^s_t \\left(p_{t+1} - p_t\\right) - \\frac{c}{2} \\left(d^s_t\\right)^2,\n$$\n其中 $c \\in \\mathbb{R}_{\\ge 0}$ 是一个交易成本参数。令 $U^s_t$ 为策略 $s$在时间 $t$ 的绩效得分，初始化为 $U^F_0 = 0$ 和 $U^C_0 = 0$，并通过指数平滑更新得分：\n$$\nU^s_{t+1} = (1 - \\delta) U^s_t + \\delta \\, \\pi^s_t,\n$$\n其中平滑参数为 $\\delta \\in (0,1]$。\n\n代理人根据具有选择强度 $\\gamma \\in \\mathbb{R}_{\\ge 0}$ 的多项式 logit（离散选择）规则转换策略：\n$$\nw^F_{t+1} = \\frac{\\exp\\left(\\gamma U^F_{t+1}\\right)}{\\exp\\left(\\gamma U^F_{t+1}\\right) + \\exp\\left(\\gamma U^C_{t+1}\\right)}, \\quad\nw^C_{t+1} = 1 - w^F_{t+1}.\n$$\n\n对于每次模拟，定义 $t \\in \\{1,\\dots,T\\}$ 的收益序列为 $r_t = p_t - p_{t-1}$，其波动率定义为标准差：\n$$\n\\sigma = \\sqrt{\\frac{1}{T} \\sum_{t=1}^{T} \\left( r_t - \\bar{r} \\right)^2},\n$$\n其中 $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^{T} r_t$。\n\n您的任务是精确实现上述模型，并为下面测试套件中的每个参数集计算包含以下各项的元组：\n- 最终价格 $p_T$，\n- 最终技术分析者比例 $w^C_T$，\n- 波动率 $\\sigma$。\n\n所有初始条件为 $p_{-1} = p_0$，$U^F_0 = 0$，$U^C_0 = 0$，并且每个测试用例都会给出初始权重 $w^F_0$（其中 $w^C_0 = 1 - w^F_0$）。所有输出都必须是实数。\n\n测试套件（请按所列顺序精确使用这四个参数集）：\n- 情况 1：$T = 50$, $v = 1.0$, $p_0 = 0.8$, $\\alpha = 0.4$, $\\beta_F = 1.0$, $\\beta_C = 1.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 2.0$, $w^F_0 = 0.5$。\n- 情况 2：$T = 50$, $v = 1.0$, $p_0 = 0.2$, $\\alpha = 0.5$, $\\beta_F = 1.0$, $\\beta_C = 0.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 2.0$, $w^F_0 = 1.0$。\n- 情况 3：$T = 30$, $v = 1.0$, $p_0 = 0.5$, $\\alpha = 0.0$, $\\beta_F = 1.0$, $\\beta_C = 1.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 3.0$, $w^F_0 = 0.5$。\n- 情况 4：$T = 80$, $v = 1.0$, $p_0 = 1.2$, $\\alpha = 0.3$, $\\beta_F = 0.8$, $\\beta_C = 1.2$, $c = 0.05$, $\\delta = 0.3$, $\\gamma = 5.0$, $w^F_0 = 0.5$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个情况 $i \\in \\{1,2,3,4\\}$，按顺序附加三个数字 $(p_T, w^C_T, \\sigma)$。因此，最终输出必须是以下形式\n$[p_T^{(1)}, w^{C,(1)}_T, \\sigma^{(1)}, p_T^{(2)}, w^{C,(2)}_T, \\sigma^{(2)}, p_T^{(3)}, w^{C,(3)}_T, \\sigma^{(3)}, p_T^{(4)}, w^{C,(4)}_T, \\sigma^{(4)}]$。\n\n所有数值答案都是无单位的实数，必须以原始十进制值的形式报告。不涉及角度或物理单位。不要包含百分号；将 $[0,1]$ 区间内的分数表示为小数。", "solution": "该问题陈述已经过严格评估，并被确定为有效。它构成了计算经济学领域中一个适定问题，特别是关于人工股票市场（ASM）的模拟。该模型是基于已建立的 Brock-Hommes 框架的离散时间动态系统。获得唯一数值解所需的所有模型方程、参数和初始条件都已明确给出。该问题具有科学依据、内部一致且客观。我现在将开始构建解决方案。\n\n该模型是一个耦合的非线性差分方程组。系统在任何给定时间 $t$ 的状态可由变量向量 $(p_t, p_{t-1}, U^F_t, U^C_t, w^F_t)$ 指定。给定时间 $t$ 的状态，时间 $t+1$ 的状态是唯一确定的。因此，求解方法是直接数值模拟，从时间 $t=0$ 向前步进到 $T$。\n\n让我们定义状态变量及其初始化：\n- 价格历史：一个数组，用于存储 $t \\in \\{0, 1, \\dots, T\\}$ 的 $p_t$。我们已知 $p_0$ 和条件 $p_{-1} = p_0$。\n- 基本面投资者比例历史：一个用于存储 $w^F_t$ 的数组。我们已知 $w^F_0$。\n- 绩效得分历史：用于存储 $U^F_t$ 和 $U^C_t$ 的数组。我们已知初始条件 $U^F_0 = 0$ 和 $U^C_0 = 0$。\n\n模拟通过从 $t=0$ 到 $T-1$ 的循环进行。在每次迭代 $t$ 中，我们根据时间 $t$ 的状态（以及价格的时间 $t-1$ 状态）计算时间 $t+1$ 的状态。操作顺序如下：\n\n1.  **计算个体需求**：在时间 $t$，确定两类代理人的需求。\n    - 基本面投资者需求取决于当前价格 $p_t$ 与基本价值 $v$ 的偏差：\n    $$\n    d^F_t = \\beta_F (v - p_t)\n    $$\n    - 技术分析者需求基于最近的价格趋势 $(p_t - p_{t-1})$：\n    $$\n    d^C_t = \\beta_C (p_t - p_{t-1})\n    $$\n    对于初始步骤 $t=0$，我们使用条件 $p_{-1} = p_0$，这导致 $d^C_0 = 0$。\n\n2.  **计算总超额需求**：总超额需求 $ED_t$ 是个体需求的加权平均，使用时间 $t$ 的群体比例 $w^F_t$ 和 $w^C_t = 1 - w^F_t$：\n    $$\n    ED_t = w^F_t d^F_t + w^C_t d^C_t\n    $$\n\n3.  **更新价格**：做市商根据超额需求按比例调整价格，由价格影响参数 $\\alpha$ 控制：\n    $$\n    p_{t+1} = p_t + \\alpha ED_t\n    $$\n\n4.  **计算已实现利润**：一旦确定了下一期的价格 $p_{t+1}$，就可以计算每种策略 $s \\in \\{F,C\\}$ 的单期利润 $\\pi^s_t$。利润包括所持头寸的资本收益，减去二次交易成本：\n    $$\n    \\pi^s_t = d^s_t (p_{t+1} - p_t) - \\frac{c}{2} (d^s_t)^2\n    $$\n    注意，价格变化项可以替换为 $(p_{t+1} - p_t) = \\alpha ED_t$。\n\n5.  **更新绩效得分**：绩效得分 $U^s_t$ 代表了每种策略的感知适应度，它通过过去利润的指数平滑平均值进行更新。参数 $\\delta$ 控制着代理人的“记忆”：\n    $$\n    U^s_{t+1} = (1 - \\delta) U^s_t + \\delta \\pi^s_t\n    $$\n\n6.  **更新策略比例**：代理人根据更新后的绩效得分为下一期重新评估他们的策略选择。在时间 $t+1$ 选择基本面策略的代理人比例由离散选择（多项式 logit）概率给出，其中 $\\gamma$ 是选择强度参数：\n    $$\n    w^F_{t+1} = \\frac{\\exp(\\gamma U^F_{t+1})}{\\exp(\\gamma U^F_{t+1}) + \\exp(\\gamma U^C_{t+1})} = \\frac{1}{1 + \\exp\\left(\\gamma (U^C_{t+1} - U^F_{t+1})\\right)}\n    $$\n    第二种形式在数值稳定性上更可取，因为它减轻了当指数为大的正数时发生浮点溢出的风险。技术分析者比例就是 $w^C_{t+1} = 1 - w^F_{t+1}$。\n\n此循环运行 $T$ 次迭代，生成截至时间 $T$ 的所有状态变量的时间序列。\n\n模拟完成后，计算最终的输出量：\n- 最终价格为 $p_T$。\n- 最终技术分析者比例为 $w^C_T = 1 - w^F_T$。\n- 波动率 $\\sigma$ 是根据 $t \\in \\{1, \\dots, T\\}$ 的收益序列 $r_t = p_t - p_{t-1}$ 计算的。这涉及计算平均收益 $\\bar{r}$，然后计算收益的总体标准差：\n$$\n\\sigma = \\sqrt{\\frac{1}{T} \\sum_{t=1}^{T} (r_t - \\bar{r})^2}\n$$\n将对四个指定的参数集中的每一个执行此过程，以产生最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(T, v, p0, alpha, beta_F, beta_C, c, delta, gamma, wF0):\n    \"\"\"\n    Simulates the Artificial Stock Market model for a given set of parameters.\n    \"\"\"\n    # Initialize arrays to store time series data\n    p = np.zeros(T + 1)\n    wF = np.zeros(T + 1)\n    UF = np.zeros(T + 1)\n    UC = np.zeros(T + 1)\n\n    # Set initial conditions at t=0\n    p[0] = p0\n    wF[0] = wF0\n    # UF[0] and UC[0] are initialized to 0 by np.zeros\n\n    # Main simulation loop from t=0 to T-1\n    for t in range(T):\n        # Retrieve current state variables for time t\n        p_t = p[t]\n        p_tm1 = p[t-1] if t > 0 else p[0]  # Condition: p_{-1} = p_0\n\n        wF_t = wF[t]\n        wC_t = 1.0 - wF_t\n        \n        UF_t = UF[t]\n        UC_t = UC[t]\n        \n        # Step 1: Calculate individual demands\n        dF_t = beta_F * (v - p_t)\n        dC_t = beta_C * (p_t - p_tm1)\n        \n        # Step 2: Calculate aggregate excess demand\n        ED_t = wF_t * dF_t + wC_t * dC_t\n        \n        # Step 3: Update price\n        p_tp1 = p_t + alpha * ED_t\n        p[t+1] = p_tp1\n        \n        # Step 4: Calculate realized profits\n        price_change = p_tp1 - p_t\n        profitF_t = dF_t * price_change - (c / 2.0) * dF_t**2\n        profitC_t = dC_t * price_change - (c / 2.0) * dC_t**2\n        \n        # Step 5: Update performance scores\n        UF_tp1 = (1.0 - delta) * UF_t + delta * profitF_t\n        UC_tp1 = (1.0 - delta) * UC_t + delta * profitC_t\n        UF[t+1] = UF_tp1\n        UC[t+1] = UC_tp1\n        \n        # Step 6: Update strategy fractions (with numerical stability)\n        diff_U = gamma * (UC_tp1 - UF_tp1)\n        \n        # Handle potential overflow in np.exp()\n        if diff_U > 700:\n            wF_tp1 = 0.0\n        else:\n            wF_tp1 = 1.0 / (1.0 + np.exp(diff_U))\n        \n        wF[t+1] = wF_tp1\n\n    # After the loop, calculate final results\n    p_T = p[T]\n    wF_T = wF[T]\n    wC_T = 1.0 - wF_T\n    \n    # Calculate volatility of returns\n    if T > 0:\n        returns = p[1:] - p[:-1]\n        sigma = np.std(returns)\n    else:  # Edge case where T=0, though not in test suite\n        sigma = 0.0\n\n    return p_T, wC_T, sigma\n\ndef solve():\n    \"\"\"\n    Runs the simulations for all test cases and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'T': 50, 'v': 1.0, 'p0': 0.8, 'alpha': 0.4, 'beta_F': 1.0, 'beta_C': 1.0, 'c': 0.1, 'delta': 0.5, 'gamma': 2.0, 'wF0': 0.5},\n        # Case 2\n        {'T': 50, 'v': 1.0, 'p0': 0.2, 'alpha': 0.5, 'beta_F': 1.0, 'beta_C': 0.0, 'c': 0.1, 'delta': 0.5, 'gamma': 2.0, 'wF0': 1.0},\n        # Case 3\n        {'T': 30, 'v': 1.0, 'p0': 0.5, 'alpha': 0.0, 'beta_F': 1.0, 'beta_C': 1.0, 'c': 0.1, 'delta': 0.5, 'gamma': 3.0, 'wF0': 0.5},\n        # Case 4\n        {'T': 80, 'v': 1.0, 'p0': 1.2, 'alpha': 0.3, 'beta_F': 0.8, 'beta_C': 1.2, 'c': 0.05, 'delta': 0.3, 'gamma': 5.0, 'wF0': 0.5},\n    ]\n\n    results = []\n    for params in test_cases:\n        p_T, wC_T, sigma = run_simulation(**params)\n        results.extend([p_T, wC_T, sigma])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "人工证券市场不仅能模拟价格动态，还能作为检验行为金融学理论的“虚拟实验室”。本练习将引导你将一个著名的认知偏差——处置效应——编码到代理人的交易决策中 [@problem_id:2372828]。通过模拟代理人更倾向于卖出盈利资产（实现收益）而非亏损资产（实现亏损）的行为，你将学习如何通过计算已实现收益比例（PGR）和已实现亏损比例（PLR）来量化这种效应，并理解它如何影响市场活动。", "id": "2372828", "problem": "您将构建一个最小化的人工股票市场 (ASM)，该市场通过使卖出概率依赖于当前持有的头寸是处于盈利还是亏损状态，从而引入处置效应。该 ASM 包含一种风险资产，其价格过程如所述，以及一个风险中性的代理人，该代理人最多可以持有一股。目标是通过蒙特卡洛模拟，根据指定的参数集，从第一性原理计算处置效应度量指标，并以精确的格式报告结果。\n\n基本原理和定义：\n- 资产价格过程是一个乘性二项式随机游走：在每个离散时间步 $t \\in \\{0,1,\\dots,T-1\\}$，价格 $P_t$ 移动到 $P_{t+1} = P_t \\cdot U_t$，其中 $U_t \\in \\{1+\\mu, 1-\\mu\\}$，$\\Pr[U_t = 1+\\mu] = q$ 且 $\\Pr[U_t = 1-\\mu] = 1-q$。参数满足 $0 < \\mu < 1$ 和 $0 < q < 1$，以确保价格严格为正且概率定义明确。\n- 代理人遵循一个简单的依赖状态的交易规则：\n  - 如果代理人在时间 $t$ 未持有股票，她会以概率 $p_{\\text{buy}} \\in (0,1)$ 按当前价格 $P_t$ 购买一股。如果她购买，则入场价格记录为 $P_{\\text{entry}} = P_t$。\n  - 如果代理人在时间 $t$ 持有一股，定义未实现收益为 $r_t = (P_t - P_{\\text{entry}})/P_{\\text{entry}}$。卖出概率为 $p_{\\text{sell}}(r_t) = p_g$（如果 $r_t > 0$）和 $p_{\\text{sell}}(r_t) = p_\\ell$（如果 $r_t < 0$），其中 $p_g, p_\\ell \\in [0,1]$。如果 $r_t = 0$，则在该步骤不发生卖出。当 $p_g > p_\\ell$ 时（即卖出盈利股比卖出亏损股更果断），这就体现了处置效应。\n- 为了从经验上量化处置效应，使用成熟的“已实现vs账面”方法。在整个模拟过程中，追踪代理人持股期间的四个计数：\n  - $G_{\\text{real}}$：处于未实现收益状态的头寸被卖出的次数（已实现收益）。\n  - $G_{\\text{paper}}$：处于未实现收益状态的头寸未被卖出的次数（账面收益）。\n  - $L_{\\text{real}}$：处于未实现亏损状态的头寸被卖出的次数（已实现亏损）。\n  - $L_{\\text{paper}}$：处于未实现亏损状态的头寸未被卖出的次数（账面亏损）。\n  然后计算已实现收益比例 (PGR) 和已实现损失比例 (PLR) 如下：$$\\text{PGR} = \\frac{G_{\\text{real}}}{G_{\\text{real}} + G_{\\text{paper}}}, \\quad \\text{PLR} = \\frac{L_{\\text{real}}}{L_{\\text{real}} + L_{\\text{paper}}},$$ 约定如果分母为 $0$，则相应的比例设置为 $0$。处置效应的度量指标为 $\\text{DE} = \\text{PGR} - \\text{PLR}$。\n\n任务：\n- 基于上述定义以及价格变动和交易决策的伯努利试验的独立性，推导出一个正确的模拟程序，该程序能够根据大数定律产生对 $\\text{PGR}$、$\\text{PLR}$ 和 $\\text{DE}$ 的一致估计。请论证用于从观测频率估计条件概率的计数逻辑的合理性。\n- 实现一个完整的、确定性的（使用种子的）程序，该程序：\n  - 初始化 $P_0 = 100$（以任意货币单位计）。\n  - 根据上述规则，演化价格和单个代理人的头寸，共计 $T$ 个步骤。\n  - 精确地按照定义计数 $G_{\\text{real}}, G_{\\text{paper}}, L_{\\text{real}}, L_{\\text{paper}}$，然后为每个参数集计算 $\\text{PGR}$、$\\text{PLR}$ 和 $\\text{DE}$。\n  - 每个测试用例使用固定的随机种子以确保可复现性。\n\n重要的实现细节：\n- 在一个时间步 $t$ 内，决策序列是：如果持股，根据 $r_t$ 决定是否卖出；然后，如果在卖出决策后不持股，则允许以概率 $p_{\\text{buy}}$ 进行买入决策；最后，将价格更新为 $P_{t+1}$。如果 $r_t = 0$，则不卖出，并且该步骤不计为盈利或亏损。\n- 代理人在任何时候最多只能持有一股。\n\n测试套件：\n对以下四个参数集运行程序，每个参数集由 $(T, q, \\mu, p_{\\text{buy}}, p_g, p_\\ell, s)$ 定义，其中 $s$ 是伪随机数生成器的整数种子。\n- 案例 1：$(T=\\;30000,\\; q=\\;0.5,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.2,\\; p_\\ell=\\;0.2,\\; s=\\;7)$。对称的卖出倾向应产生接近 $0$ 的 $\\text{DE}$。\n- 案例 2：$(T=\\;30000,\\; q=\\;0.5,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.6,\\; p_\\ell=\\;0.05,\\; s=\\;11)$。当 $p_g > p_\\ell$ 时，强的处置效应应产生 $\\text{DE} > 0$。\n- 案例 3：$(T=\\;30000,\\; q=\\;0.5,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.02,\\; p_\\ell=\\;0.6,\\; s=\\;13)$。反向处置效应应产生 $\\text{DE} < 0$。\n- 案例 4：$(T=\\;30000,\\; q=\\;0.6,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.4,\\; p_\\ell=\\;0.2,\\; s=\\;17)$。具有向上漂移和中等处置效应。\n\n答案规格和输出格式：\n- 对于每个案例，计算 $\\text{DE}$ 作为一个浮点数，四舍五入到 $6$ 位小数。\n- 您的程序应产生单行输出，其中包含四个结果，格式为逗号分隔的列表，并用方括号括起来（例如，$[\\text{DE}_1,\\text{DE}_2,\\text{DE}_3,\\text{DE}_4]$）。\n- 本问题不涉及物理单位或角度；所有报告的量均为无单位实数。", "solution": "我们从乘性二项式模型的基本设定以及通过已实现收益比例 (PGR) 和已实现损失比例 (PLR) 定义的处置效应出发。价格过程是一个序列 $\\{P_t\\}_{t=0}^{T}$，其中 $P_{t+1} = P_t \\cdot U_t$，$U_t \\in \\{1+\\mu,1-\\mu\\}$，$\\Pr[U_t = 1+\\mu] = q$，且 $\\Pr[U_t = 1-\\mu] = 1-q$。这是一个在伯努利方案下的独立同分布的乘性冲击序列，当 $0 < \\mu < 1$ 时，由于 $1-\\mu > 0$，保证了价格的正性。\n\n代理人在时间 $t$ 的行为取决于当前的持股状态和未实现收益 $r_t = (P_t - P_{\\text{entry}})/P_{\\text{entry}}$ 的符号。卖出概率是一个分段定义的函数 $p_{\\text{sell}}(r_t)$：如果 $r_t > 0$，则 $p_{\\text{sell}}(r_t) = p_g$；如果 $r_t < 0$，则 $p_{\\text{sell}}(r_t) = p_\\ell$。如果 $r_t = 0$，规则将该步骤的卖出概率设为 $0$，因此不发生卖出。如果在时间 $t$ 未持股，代理人以概率 $p_{\\text{buy}}$ 购买。所有这些行为都被建模为独立的伯努利试验，这与行为规则引出随机转换的标准代理人基模型一致。\n\n为了从模拟中估计 PGR 和 PLR，我们依赖于基于频率的条件概率估计，其合理性由大数定律保证。具体来说，对于盈利状态，在代理人持有头寸且存在盈利的时刻定义指示事件。设 $X_t^{G}$ 为时间 $t$ 头寸处于盈利状态且被实现（卖出）的指示事件，设 $Y_t^{G}$ 为时间 $t$ 头寸处于盈利状态但未被卖出（持有）的指示事件。然后我们计数\n$$G_{\\text{real}} = \\sum_{t=0}^{T-1} X_t^{G}, \\quad G_{\\text{paper}} = \\sum_{t=0}^{T-1} Y_t^{G}.$$\n在伯努利决策条件于盈利状态下独立且平稳的假设下，经验比例\n$$\\widehat{\\text{PGR}} = \\frac{G_{\\text{real}}}{G_{\\text{real}} + G_{\\text{paper}}}$$\n随着 $T \\to \\infty$ 收敛于盈利状态下的真实条件卖出概率。类似地，对于亏损状态，定义 $X_t^{L}$ 为时间 $t$ 亏损状态被实现（卖出）的指示事件，定义 $Y_t^{L}$ 为亏损状态未被卖出的指示事件，得到\n$$L_{\\text{real}} = \\sum_{t=0}^{T-1} X_t^{L}, \\quad L_{\\text{paper}} = \\sum_{t=0}^{T-1} Y_t^{L}, \\quad \\widehat{\\text{PLR}} = \\frac{L_{\\text{real}}}{L_{\\text{real}} + L_{\\text{paper}}}.$$\n处置效应的度量指标则为\n$$\\widehat{\\text{DE}} = \\widehat{\\text{PGR}} - \\widehat{\\text{PLR}}.$$\n\n算法设计：\n- 初始化 $P_0 = 100$ 且代理人不持股。如果发生购买，设置 $P_{\\text{entry}} = P_t$。\n- 对于每个时间步 $t \\in \\{0,1,\\dots,T-1\\}$：\n  - 如果持股，计算 $r_t = (P_t - P_{\\text{entry}})/P_{\\text{entry}}$。\n    - 如果 $r_t > 0$，进行一次伯努利$(p_g)$试验来决定是否卖出。如果卖出，则 $G_{\\text{real}}$ 增加 1，并将持股状态设为 false；如果未卖出，则 $G_{\\text{paper}}$ 增加 1，并继续持股。\n    - 如果 $r_t < 0$，进行一次伯努利$(p_\\ell)$试验来决定是否卖出。如果卖出，则 $L_{\\text{real}}$ 增加 1，并将持股状态设为 false；如果未卖出，则 $L_{\\text{paper}}$ 增加 1。\n    - 如果 $r_t = 0$，则该步骤既不计数也不卖出。\n  - 如果在卖出决策后不持股，则进行一次伯努利$(p_{\\text{buy}})$试验来决定是否以价格 $P_t$ 买入；如果发生购买，则设置 $P_{\\text{entry}} = P_t$。\n  - 通过从 $\\{1+\\mu, 1-\\mu\\}$ 中分别以概率 $q$ 和 $1-q$ 抽样 $U_t$ 来更新价格，并设置 $P_{t+1} = P_t U_t$。\n- 在 $T$ 步之后，使用上述计数公式计算 $\\widehat{\\text{PGR}}$、$\\widehat{\\text{PLR}}$ 和 $\\widehat{\\text{DE}}$。如果 $G_{\\text{real}} + G_{\\text{paper}} = 0$，则设置 $\\widehat{\\text{PGR}} = 0$。如果 $L_{\\text{real}} + L_{\\text{paper}} = 0$，则设置 $\\widehat{\\text{PLR}} = 0$。\n\n基本原理说明：\n- 二项式模型是一个经过良好检验的价格动态离散化方法，它能在较粗糙的层面上捕捉漂移和波动性，同时在 $0 < \\mu < 1$ 的条件下确保价格为正。\n- 代理人的决策被建模为以 $r_t$ 符号为条件的伯努利试验，这为处置效应提供了一个可解释且易于处理的机制，其中 $p_g > p_\\ell$ 编码了更高的卖出盈利股的倾向。\n- 频率估计量 $\\widehat{\\text{PGR}}$ 和 $\\widehat{\\text{PLR}}$ 是经验条件概率。在独立性假设和基础过程的遍历性下，大数定律确保了当 $T$ 增大时，它们会收敛到其理论值。\n- 计数方案与定义完全匹配：代理人持有且处于盈利（或亏损）状态的每一步都对分母有贡献；其中发生卖出的那些步骤则对分子有贡献。\n\n边界情况与约定：\n- 如果 $r_t = 0$，则不发生卖出，也不添加计数，以防止分类上的模糊不清。\n- 如果 PGR 或 PLR 中的分母为零，则相应的比例设为零，以避免除以零，并反映在该类别中未观察到机会。\n- 由于模拟是随机的，固定种子可确保输出的可复现性。\n\n计算方面的考虑：\n- 每个测试用例的算法运行时间为 $\\mathcal{O}(T)$，除了计数器外，内存消耗为常数。对于 $T = 30000$ 和四个案例，运行时间是适度的。\n\n最终输出：\n- 对于四个指定的案例中的每一个，输出处置效应 $\\widehat{\\text{DE}}$，四舍五入到 6 位小数。\n- 程序必须以精确的格式 $[\\widehat{\\text{DE}}_1,\\widehat{\\text{DE}}_2,\\widehat{\\text{DE}}_3,\\widehat{\\text{DE}}_4]$ 打印单行结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(T, q, mu, p_buy, p_gain, p_loss, seed, P0=100.0):\n    rng = np.random.default_rng(seed)\n    P = float(P0)\n    holding = False\n    entry_price = None\n\n    g_realized = 0\n    g_paper = 0\n    l_realized = 0\n    l_paper = 0\n\n    for _ in range(T):\n        # If holding, decide whether to sell based on unrealized gain/loss\n        if holding:\n            r = (P - entry_price) / entry_price\n            if r > 0.0:\n                # Gain state\n                if rng.random() < p_gain:\n                    g_realized += 1\n                    holding = False\n                    entry_price = None\n                else:\n                    g_paper += 1\n            elif r < 0.0:\n                # Loss state\n                if rng.random() < p_loss:\n                    l_realized += 1\n                    holding = False\n                    entry_price = None\n                else:\n                    l_paper += 1\n            else:\n                # Exactly break-even: do nothing, do not count\n                pass\n\n        # If not holding after potential sale, possibly buy\n        if not holding:\n            if rng.random() < p_buy:\n                holding = True\n                entry_price = P\n\n        # Update price via binomial move\n        if rng.random() < q:\n            P *= (1.0 + mu)\n        else:\n            P *= (1.0 - mu)\n\n    # Compute PGR and PLR with zero-denominator safeguards\n    denom_g = g_realized + g_paper\n    denom_l = l_realized + l_paper\n    pgr = (g_realized / denom_g) if denom_g > 0 else 0.0\n    plr = (l_realized / denom_l) if denom_l > 0 else 0.0\n    de = pgr - plr\n    return de\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each tuple: (T, q, mu, p_buy, p_g, p_l, seed)\n    test_cases = [\n        (30000, 0.5, 0.01, 0.5, 0.2, 0.2, 7),    # Case 1\n        (30000, 0.5, 0.01, 0.5, 0.6, 0.05, 11),  # Case 2\n        (30000, 0.5, 0.01, 0.5, 0.02, 0.6, 13),  # Case 3\n        (30000, 0.6, 0.01, 0.5, 0.4, 0.2, 17),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        T, q, mu, p_buy, p_g, p_l, seed = case\n        de = simulate_case(T, q, mu, p_buy, p_g, p_l, seed)\n        results.append(f\"{de:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "代理人如何学习和适应不断变化的环境是代理人基模型中的一个核心议题。这个练习将让你深入探究代理人的“大脑”，比较三种不同的学习算法在面对环境突变时的表现 [@problem_id:2372759]。通过在一个股息过程发生结构性变化的市场中模拟和评估递减增益、常数增益和卡尔曼滤波器等学习规则，你将理解不同学习机制在追踪非平稳基本价值时的速度和准确性差异。", "id": "2372759", "problem": "给定一个离散时间的人工股票市场，其中只有一种单期资产，该资产在下一期支付随机股息，然后以零价格赎回。时间由 $t \\in \\{0,1,2,\\dots,T\\}$ 索引。总无风险利率为 $R = 1 + r$，其中 $r$ 为常数。根据无套利原理，对于只在下一期支付股息且之后价值为零的单期资产，其在时间 $t$ 的价格为\n$$\np_t \\;=\\; \\frac{\\mathbb{E}_t[d_{t+1}]}{R}.\n$$\n股息由一个潜在均值加上噪声的过程生成\n$$\nd_t \\;=\\; \\mu_t \\;+\\; \\varepsilon_t,\n$$\n其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 对所有 $t$ 均为独立同分布 (i.i.d.)，$\\mu_t$ 是一个分段常数均值，在已知的转换时间 $T^\\star$ 发生一次性机制转换，\n$$\n\\mu_t \\;=\\; \n\\begin{cases}\n\\mu_0, & t < T^\\star,\\\\\n\\mu_1, & t \\ge T^\\star.\n\\end{cases}\n$$\n代理人无法直接观测到 $\\mu_t$。相反，每个代理人 $j$ 维持一个对 $\\mu_t$ 的估计 $m_t^{(j)}$，该估计仅使用观测到的股息进行在线更新。所有代理人的初始条件为 $m_0^{(j)} = \\mu_0$。定义每个代理人的价格预测为 $p_t^{(j)} = m_t^{(j)}/R$，并定义新机制下的基本价格为 $p^\\star = \\mu_1/R$。\n\n考虑三种学习规则，在观测到 $d_t$ 后应用更新以产生 $m_{t+1}^{(j)}$：\n\n1. 递减增益样本均值（代理人 A）：\n$$\nm_{t+1}^{(A)} \\;=\\; m_t^{(A)} \\;+\\; \\frac{1}{t+1}\\,\\big(d_t - m_t^{(A)}\\big).\n$$\n\n2. 恒定增益指数平滑（代理人 B），增益为 $g \\in (0,1)$：\n$$\nm_{t+1}^{(B)} \\;=\\; m_t^{(B)} \\;+\\; g\\,\\big(d_t - m_t^{(B)}\\big).\n$$\n\n3. 卡尔曼滤波器 (KF) 追踪器（代理人 C），用于随机游走的潜在均值，其过程方差为 $q > 0$，观测方差为 $r_{\\text{var}} = \\sigma^2$。设时间 $t$ 的后验方差为 $P_t$。初始化 $m_0^{(C)} = \\mu_0$ 和 $P_0 > 0$，在观测到 $d_t$ 后的更新为\n$$\n\\begin{aligned}\nP_t^- &= P_t + q,\\\\\nK_t &= \\frac{P_t^-}{P_t^- + r_{\\text{var}}},\\\\\nm_{t+1}^{(C)} &= m_t^{(C)} + K_t \\big(d_t - m_t^{(C)}\\big),\\\\\nP_{t+1} &= (1 - K_t) P_t^-.\n\\end{aligned}\n$$\n\n对于每个代理人 $j \\in \\{A,B,C\\}$，将适应新机制的延迟定义为最小的非负整数 $\\tau^{(j)}$，使得\n$$\n\\left|p_s^{(j)} - p^\\star\\right| \\le \\epsilon_p \\quad \\text{对于所有 } s \\in \\{T^\\star + \\tau^{(j)},\\, T^\\star + \\tau^{(j)} + 1,\\, \\dots,\\, T^\\star + \\tau^{(j)} + K - 1\\},\n$$\n并附加要求 $T^\\star + \\tau^{(j)} + K - 1 \\le T$。如果在此约束下不存在这样的 $\\tau^{(j)}$，则设 $\\tau^{(j)} = -1$。所有时间都以整数周期计算。\n\n噪声必须使用指定种子生成为方差为 $\\sigma^2$ 的高斯噪声，以确保可复现性。股息序列必须在 $t \\in \\{0,1,\\dots,T-1\\}$上进行仿真，并且代理人的估计必须使用按时间顺序实现的股息进行在线更新，从 $m_0^{(j)} = \\mu_0$ 开始。\n\n测试套件。对于下面的每一组参数，运行一次仿真并以整数形式报告 $\\tau^{(A)},\\tau^{(B)},\\tau^{(C)}$。\n\n- 案例 1（理想路径）：\n  - $T = 800$, $T^\\star = 400$, $\\mu_0 = 0.0$, $\\mu_1 = 1.0$, $\\sigma = 0.1$, $r = 0.01$, $\\epsilon_p = 0.02$, $K = 10$, $\\text{seed} = 20231102$,\n  - 恒定增益：$g = 0.05$,\n  - 卡尔曼滤波器：$q = 0.001$, $P_0 = 0.1$。\n\n- 案例 2（高噪声）：\n  - $T = 800$, $T^\\star = 400$, $\\mu_0 = 0.0$, $\\mu_1 = 1.0$, $\\sigma = 0.5$, $r = 0.01$, $\\epsilon_p = 0.2$, $K = 5$, $\\text{seed} = 7$,\n  - 恒定增益：$g = 0.15$,\n  - 卡尔曼滤波器：$q = 0.08$, $P_0 = 0.5$。\n\n- 案例 3（小幅度机制转换）：\n  - $T = 800$, $T^\\star = 400$, $\\mu_0 = 0.0$, $\\mu_1 = 0.2$, $\\sigma = 0.1$, $r = 0.01$, $\\epsilon_p = 0.01$, $K = 8$, $\\text{seed} = 4242$,\n  - 恒定增益：$g = 0.03$,\n  - 卡尔曼滤波器：$q = 0.001$, $P_0 = 0.1$。\n\n答案规格。您的程序必须产生单行输出，包含一个按以下顺序排列的逗号分隔的扁平列表：\n$$\n[\\tau^{(A)}_{\\text{case }1},\\, \\tau^{(B)}_{\\text{case }1},\\, \\tau^{(C)}_{\\text{case }1},\\, \\tau^{(A)}_{\\text{case }2},\\, \\tau^{(B)}_{\\text{case }2},\\, \\tau^{(C)}_{\\text{case }2},\\, \\tau^{(A)}_{\\text{case }3},\\, \\tau^{(B)}_{\\text{case }3},\\, \\tau^{(C)}_{\\text{case }3}].\n$$\n所有报告的值必须是整数。不涉及物理单位。不使用角度。不得使用百分比；容差是如上指定的绝对实数。给定所提供的种子，程序必须是完全确定性的，并且不得读取任何输入。", "solution": "问题陈述已经过分析并被确定为有效。这是一个在基于代理人的计算经济学领域内适定的计算问题，其基础是金融经济学和统计估计理论的既定原则。定义精确，参数完整，目标明确，从而可以得到唯一且可验证的解。我们将采用系统、分步的方法来求解。\n\n该问题要求仿真一个人工股票市场，以评估三种不同的学习代理人在基础股息过程发生结构性断裂后的适应速度。任务的核心是实现指定的学习算法，并计算收敛速度的度量，即适应延迟 $\\tau^{(j)}$。\n\n首先，我们建立仿真环境。时间范围是离散的，由 $t \\in \\{0, 1, \\dots, T\\}$ 索引。单一资产的基本价值由随机股息过程 $d_t$ 驱动。该过程定义为：\n$$\nd_t = \\mu_t + \\varepsilon_t\n$$\n其中 $\\varepsilon_t$ 是一个独立同分布的高斯噪声项，均值为 $0$，方差为 $\\sigma^2$，即 $\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$。潜在均值 $\\mu_t$ 是分段常数，在已知的时刻 $T^\\star$ 经历一次单一的、永久性的机制转换：\n$$\n\\mu_t = \n\\begin{cases}\n\\mu_0, & t < T^\\star \\\\\n\\mu_1, & t \\ge T^\\star\n\\end{cases}\n$$\n该资产是对下一期股息 $d_{t+1}$ 的单期求偿权。在风险中性的假设下，其在时间 $t$ 的价格是下一期股息的贴现期望值：\n$$\np_t = \\frac{\\mathbb{E}_t[d_{t+1}]}{R}\n$$\n其中 $R = 1+r$ 是恒定的总无风险利率。由于 $\\mathbb{E}_t[d_{t+1}] = \\mathbb{E}_t[\\mu_{t+1} + \\varepsilon_{t+1}] = \\mathbb{E}_t[\\mu_{t+1}]$，价格取决于对未来均值的期望。代理人无法直接观测到 $\\mu_t$，必须基于观测到的股息历史 $\\{d_0, d_1, \\dots, d_{t-1}\\}$ 形成一个估计 $m_t^{(j)}$。因此，一个代理人的价格预测为 $p_t^{(j)} = m_t^{(j)}/R$，这隐含地假设代理人对 $\\mu_{t+1}$ 的最佳估计是他们对 $\\mu_t$ 的最新估计。在新机制下的目标基本价格是 $p^\\star = \\mu_1/R$。\n\n仿真过程如下。首先，使用指定的随机种子为整个仿真时域生成股息路径 $\\{d_t\\}_{t=0}^{T-1}$ 的一个单一实现，以确保可复现性。然后，我们在 $t=0$ 时将每个代理人的状态初始化为 $m_0^{(j)} = \\mu_0$。接着，我们从 $t=0$ 迭代到 $t=T-1$，在每一步观测 $d_t$ 并根据各自的学习规则将代理人的估计从 $m_t^{(j)}$ 更新到 $m_{t+1}^{(j)}$。\n\n三种学习规则是：\n1.  **代理人 A (递减增益样本均值)：** 更新规则是\n    $$\n    m_{t+1}^{(A)} = m_t^{(A)} + \\gamma_t (d_t - m_t^{(A)}), \\quad \\text{增益为 } \\gamma_t = \\frac{1}{t+1}.\n    $$\n    这等价于截至时间 $t$ 所有观测到股息的样本均值的递推公式。增益 $\\gamma_t \\to 0$ 当 $t \\to \\infty$ 时，意味着代理人的记忆是无限的，其学习速度会越来越慢。在机制转换后，该代理人将非常缓慢地适应新的均值 $\\mu_1$。\n\n2.  **代理人 B (恒定增益指数平滑)：** 更新规则是\n    $$\n    m_{t+1}^{(B)} = m_t^{(B)} + g(d_t - m_t^{(B)}),\n    $$\n    其中增益 $g \\in (0,1)$ 是一个常数。这是一种指数加权移动平均滤波器。由于增益恒定，代理人会不断地对过去的数据进行折价，给予近期观测值更多的权重。这使得它能够适应均值的永久性变化，但估计值将永远存在噪声，因为它永远不会完全收敛。\n\n3.  **代理人 C (卡尔曼滤波器)：** 该代理人使用一个基于状态空间模型的最优线性滤波器，其中潜在均值 $\\mu_t$ 被假定遵循一个随机游走，$\\mu_t = \\mu_{t-1} + w_{t-1}$，其中 $w_t \\sim \\mathcal{N}(0,q)$，观测值为 $d_t = \\mu_t + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0, r_{\\text{var}}=\\sigma^2)$。如问题所述，更新方程将观测到 $d_t$ 之前的状态 $(m_t^{(C)}, P_t)$ 映射到更新后的状态 $(m_{t+1}^{(C)}, P_{t+1})$。这里，$m_t^{(C)}$ 代表代理人对 $\\mu_t$ 的估计，而 $P_t$ 是其相关的不确定性（方差），两者都在周期 $t$ 开始时可用。更新过程如下：\n    $$\n    \\begin{aligned}\n    P_t^- &= P_t + q \\quad \\text{(先验方差传播)} \\\\\n    K_t &= \\frac{P_t^-}{P_t^- + r_{\\text{var}}} \\quad \\text{(卡尔曼增益计算)} \\\\\n    m_{t+1}^{(C)} &= m_t^{(C)} + K_t (d_t - m_t^{(C)}) \\quad \\text{(均值估计更新)} \\\\\n    P_{t+1} &= (1 - K_t) P_t^- \\quad \\text{(方差估计更新)}\n    \\end{aligned}\n    $$\n    卡尔曼增益 $K_t$ 是自适应的；当不确定性 $P_t$ 高时，它较大；当滤波器对其估计有信心时，它较小。这使得在机制转换后（当预测误差变大并增加不确定性时）能够快速适应，并在收敛后能够稳定追踪。\n\n为所有代理人仿真出估计路径 $\\{m_t^{(j)}\\}_{t=0}^{T}$ 后，我们计算它们对应的价格预测 $\\{p_t^{(j)}\\}_{t=0}^{T}$。最后一步是计算每个代理人的适应延迟 $\\tau^{(j)}$。这被定义为最小的非负整数 $\\tau$，使得代理人的价格预测在一个从 $T^\\star+\\tau$ 开始的、长度为 $K$ 的连续时间块内，始终保持在新的基本价格 $p^\\star$ 的一个容差 $\\epsilon_p$ 范围内。即：\n$$\n\\left|p_s^{(j)} - p^\\star\\right| \\le \\epsilon_p \\quad \\text{对于所有 } s \\in \\{T^\\star + \\tau,\\, T^\\star + \\tau + 1,\\, \\dots,\\, T^\\star + \\tau + K - 1\\}.\n$$\n对 $\\tau$ 的搜索是从 $\\tau=0$ 开始迭代，直到可能的最大值，该最大值受 $T^\\star + \\tau + K - 1 \\le T$ 的约束。如果在此范围内找不到这样的 $\\tau$，则将其设置为 -1。一种计算上高效的方法是：首先生成一个布尔向量，指示每个时间步 $s$ 是否满足 $|p_s^{(j)} - p^\\star| \\le \\epsilon_p$。然后，可以使用一个大小为 $K$ 的滑动窗口，找到第一个从索引 $s \\ge T^\\star$ 开始且完全由 `True` 值组成的窗口。如果找到了这样一个起始索引为 $s_{\\text{found}}$ 的窗口，则延迟为 $\\tau = s_{\\text{found}} - T^\\star$。否则，延迟为 -1。\n\n实现将针对问题中指定的每个测试案例遵循此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"T\": 800, \"T_star\": 400, \"mu_0\": 0.0, \"mu_1\": 1.0, \"sigma\": 0.1, \"r\": 0.01,\n            \"epsilon_p\": 0.02, \"K\": 10, \"seed\": 20231102,\n            \"g\": 0.05, \"q\": 0.001, \"P_0\": 0.1\n        },\n        {\n            \"T\": 800, \"T_star\": 400, \"mu_0\": 0.0, \"mu_1\": 1.0, \"sigma\": 0.5, \"r\": 0.01,\n            \"epsilon_p\": 0.2, \"K\": 5, \"seed\": 7,\n            \"g\": 0.15, \"q\": 0.08, \"P_0\": 0.5\n        },\n        {\n            \"T\": 800, \"T_star\": 400, \"mu_0\": 0.0, \"mu_1\": 0.2, \"sigma\": 0.1, \"r\": 0.01,\n            \"epsilon_p\": 0.01, \"K\": 8, \"seed\": 4242,\n            \"g\": 0.03, \"q\": 0.001, \"P_0\": 0.1\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = run_simulation(params)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n    \"\"\"\n    T = params[\"T\"]\n    T_star = params[\"T_star\"]\n    mu_0 = params[\"mu_0\"]\n    mu_1 = params[\"mu_1\"]\n    sigma = params[\"sigma\"]\n    r = params[\"r\"]\n    epsilon_p = params[\"epsilon_p\"]\n    K = params[\"K\"]\n    seed = params[\"seed\"]\n    g = params[\"g\"]\n    q = params[\"q\"]\n    P_0 = params[\"P_0\"]\n\n    # Initialize random number generator\n    rng = np.random.default_rng(seed)\n\n    # Generate dividend process\n    mu = np.full(T, mu_0)\n    mu[T_star:] = mu_1\n    epsilon = rng.normal(0, sigma, size=T)\n    d = mu + epsilon\n\n    R = 1.0 + r\n    p_star = mu_1 / R\n\n    # Initialize agent estimates\n    m_A = np.zeros(T + 1)\n    m_B = np.zeros(T + 1)\n    m_C = np.zeros(T + 1)\n    P_C = np.zeros(T + 1)\n\n    m_A[0] = m_B[0] = m_C[0] = mu_0\n    P_C[0] = P_0\n    r_var = sigma**2\n\n    # Run simulation loop\n    for t in range(T):\n        # Agent A: Decreasing-gain\n        m_A[t+1] = m_A[t] + (1.0 / (t + 1.0)) * (d[t] - m_A[t])\n        \n        # Agent B: Constant-gain\n        m_B[t+1] = m_B[t] + g * (d[t] - m_B[t])\n        \n        # Agent C: Kalman filter\n        P_t_prior = P_C[t] + q\n        K_t = P_t_prior / (P_t_prior + r_var)\n        m_C[t+1] = m_C[t] + K_t * (d[t] - m_C[t])\n        P_C[t+1] = (1.0 - K_t) * P_t_prior\n\n    estimates = {\"A\": m_A, \"B\": m_B, \"C\": m_C}\n    taus = []\n\n    for agent_id in [\"A\", \"B\", \"C\"]:\n        m_hist = estimates[agent_id]\n        p_hist = m_hist / R\n        \n        is_converged = np.abs(p_hist - p_star) <= epsilon_p\n        \n        # Use sliding window to find first block of K converged periods\n        if len(is_converged) < K:\n            taus.append(-1)\n            continue\n            \n        windows = np.lib.stride_tricks.sliding_window_view(is_converged, window_shape=K)\n        all_true_windows = np.all(windows, axis=1)\n        \n        search_start_idx = T_star\n        if search_start_idx >= len(all_true_windows):\n            taus.append(-1)\n            continue\n\n        search_area = all_true_windows[search_start_idx:]\n        found_indices = np.where(search_area)[0]\n        \n        if len(found_indices) > 0:\n            # tau = s_found - T_star, where s_found = T_star + found_indices[0]\n            tau = found_indices[0]\n            taus.append(int(tau))\n        else:\n            taus.append(-1)\n            \n    return taus\n\nsolve()\n```"}]}