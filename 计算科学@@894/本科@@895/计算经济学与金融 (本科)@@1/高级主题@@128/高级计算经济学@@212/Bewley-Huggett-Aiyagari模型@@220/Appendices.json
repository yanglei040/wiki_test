{"hands_on_practices": [{"introduction": "在求解完整的Bewley-Huggett-Aiyagari模型之前，理解个体代理人的选择如何汇总以决定整个经济的财富分配是至关重要的。第一个练习通过直接给出最优策略规则来简化问题。你的任务是利用这个规则，为整个分布构建转移矩阵并计算其长期稳态，从而对支配异质代理人模型的运动定律建立直观理解。[@problem_id:2437609]", "id": "2437609", "problem": "考虑一个 Bewley-Huggett-Aiyagari 模型，其中有单位质量的事前同质行为人，他们面临特异性劳动收入风险，并通过在单一无风险资产中储蓄来进行自我保险。设特异性收入过程为一个两状态马尔可夫链 $z \\in \\{z_{L}, z_{H}\\}$，其转移概率由以下矩阵给出：\n$$\n\\begin{pmatrix}\n\\mathbb{P}(z' = z_{L} \\mid z = z_{L}) & \\mathbb{P}(z' = z_{H} \\mid z = z_{L}) \\\\\n\\mathbb{P}(z' = z_{L} \\mid z = z_{H}) & \\mathbb{P}(z' = z_{H} \\mid z = z_{H})\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{4}{5} & \\frac{1}{5} \\\\\n\\frac{1}{5} & \\frac{4}{5}\n\\end{pmatrix}.\n$$\n资产网格是离散的，包含两个点 $a \\in \\{a_{0}, a_{1}\\}$，且 $a_{0} < a_{1}$。假设最优的下一期资产策略（通过在给定价格下求解家庭问题得到）是一个确定性函数 $a' = g(a,z)$，其取值在网格上，并由以下给出：\n- $g(a_{0}, z_{L}) = a_{0}$，\n- $g(a_{0}, z_{H}) = a_{1}$，\n- $g(a_{1}, z_{L}) = a_{0}$，\n- $g(a_{1}, z_{H}) = a_{1}$。\n将联合状态定义为 $s = (a,z)$，并按以下顺序列举这 4 个状态：\n$$\ns_{1} = (a_{0}, z_{L}), \\quad s_{2} = (a_{0}, z_{H}), \\quad s_{3} = (a_{1}, z_{L}), \\quad s_{4} = (a_{1}, z_{H}).\n$$\n直方图（也称离散化）方法将平稳分布计算为该有限状态空间上横截面测度的线性运动法则的一个不动点。长面板模拟方法则模拟 $N$ 个行为人在 $T$ 个时期内的行为，舍弃初始的预烧期（burn-in），然后形成经验频率。\n\n下列哪个陈述是正确的？\n\nA. 通过直方图法计算的 $(s_{1}, s_{2}, s_{3}, s_{4})$ 上的平稳分布是\n$$\n\\pi = \\left(\\frac{2}{5}, \\frac{1}{10}, \\frac{1}{10}, \\frac{2}{5}\\right).\n$$\n\nB. 对于一个 $N$ 很大、$T$ 很大且舍弃了预烧期的长面板模拟，经验横截面状态频率几乎必然收敛到与选项 A 中相同的平稳分布。\n\nC. 在 $a = a_{1}$ 的状态上的平稳质量等于 $\\frac{1}{2}$。\n\nD. 如果面板在初始时精确地处于平稳分布，且策略 $g$ 如上所述是确定性的，那么再经过一个时期后，对于任何有限的 $N$，模拟的横截面分布都将保持完全相同。\n\nE. 直方图法引入了仅在 $N \\to \\infty$ 时才消失的抽样误差；相比之下，如果从平稳状态开始初始化，长模拟则没有抽样误差。", "solution": "对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- **模型**：Bewley-Huggett-Aiyagari。\n- **行为人**：单位质量，事前同质。\n- **收入过程**：关于 $z \\in \\{z_{L}, z_{H}\\}$ 的两状态马尔可夫链，其转移矩阵为\n$$\n\\mathbf{\\Pi}_{z} =\n\\begin{pmatrix}\n\\frac{4}{5} & \\frac{1}{5} \\\\\n\\frac{1}{5} & \\frac{4}{5}\n\\end{pmatrix}.\n$$\n- **资产网格**：离散的， $a \\in \\{a_{0}, a_{1}\\}$ 且 $a_{0} < a_{1}$。\n- **策略函数**：$a' = g(a,z)$ 由以下给出：\n  - $g(a_{0}, z_{L}) = a_{0}$\n  - $g(a_{0}, z_{H}) = a_{1}$\n  - $g(a_{1}, z_{L}) = a_{0}$\n  - $g(a_{1}, z_{H}) = a_{1}$\n- **状态空间**：联合状态为 $s = (a,z)$，列举如下：\n  $s_{1} = (a_{0}, z_{L})$, $s_{2} = (a_{0}, z_{H})$, $s_{3} = (a_{1}, z_{L})$, $s_{4} = (a_{1}, z_{H})$。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题定义明确且有科学依据。它呈现了一个计算经济学中使用的标准的、简化的异质行为人模型。分析横截面分布动态所需的所有组成部分——状态空间、收入过程和策略函数——都已明确给出且相互一致。确定性策略规则 $g(a,z)$ 和随机收入过程的组合，在联合状态空间 $S = \\{s_{1}, s_{2}, s_{3}, s_{4}\\}$ 上形成了一个定义明确的有限状态马尔可夫链。该链是不可约的，这保证了唯一平稳分布的存在性。因此，该问题是有效的。\n\n**第 3 步：结论与行动**\n问题有效。将推导解答。\n\n**推导**\n\n问题的核心是找到 4 个状态 $s = (a,z)$ 上的马尔可夫链的平稳分布 $\\pi$。这需要构建一个 $4 \\times 4$ 的转移矩阵 $\\mathbf{P}$，其中 $P_{ij} = \\mathbb{P}(s' = s_{j} \\mid s = s_{i})$。处于状态 $s = (a,z)$ 的行为人会转移到一个新的资产状态 $a' = g(a,z)$，以及一个根据转移概率 $\\mathbf{\\Pi}_{z}$ 抽取的新收入状态 $z'$。\n\n我们来构建 $\\mathbf{P}$ 的行向量：\n1.  从 $s_{1}=(a_{0}, z_{L})$ 出发：下一期的资产状态是 $a' = g(a_{0}, z_{L}) = a_{0}$。收入状态 $z'$ 以 $\\frac{4}{5}$ 的概率变为 $z_{L}$，以 $\\frac{1}{5}$ 的概率变为 $z_{H}$。因此，下一期的状态以 $\\frac{4}{5}$ 的概率是 $s_{1}=(a_{0}, z_{L})$，以 $\\frac{1}{5}$ 的概率是 $s_{2}=(a_{0}, z_{H})$。$\\mathbf{P}$ 的第一行是 $(\\frac{4}{5}, \\frac{1}{5}, 0, 0)$。\n2.  从 $s_{2}=(a_{0}, z_{H})$ 出发：下一期的资产状态是 $a' = g(a_{0}, z_{H}) = a_{1}$。收入状态 $z'$ 以 $\\frac{1}{5}$ 的概率变为 $z_{L}$，以 $\\frac{4}{5}$ 的概率变为 $z_{H}$。因此，下一期的状态以 $\\frac{1}{5}$ 的概率是 $s_{3}=(a_{1}, z_{L})$，以 $\\frac{4}{5}$ 的概率是 $s_{4}=(a_{1}, z_{H})$。$\\mathbf{P}$ 的第二行是 $(0, 0, \\frac{1}{5}, \\frac{4}{5})$。\n3.  从 $s_{3}=(a_{1}, z_{L})$ 出发：下一期的资产状态是 $a' = g(a_{1}, z_{L}) = a_{0}$。收入状态 $z'$ 以 $\\frac{4}{5}$ 的概率变为 $z_{L}$，以 $\\frac{1}{5}$ 的概率变为 $z_{H}$。因此，下一期的状态以 $\\frac{4}{5}$ 的概率是 $s_{1}=(a_{0}, z_{L})$，以 $\\frac{1}{5}$ 的概率是 $s_{2}=(a_{0}, z_{H})$。$\\mathbf{P}$ 的第三行是 $(\\frac{4}{5}, \\frac{1}{5}, 0, 0)$。\n4.  从 $s_{4}=(a_{1}, z_{H})$ 出发：下一期的资产状态是 $a' = g(a_{1}, z_{H}) = a_{1}$。收入状态 $z'$ 以 $\\frac{1}{5}$ 的概率变为 $z_{L}$，以 $\\frac{4}{5}$ 的概率变为 $z_{H}$。因此，下一期的状态以 $\\frac{1}{5}$ 的概率是 $s_{3}=(a_{1}, z_{L})$，以 $\\frac{4}{5}$ 的概率是 $s_{4}=(a_{1}, z_{H})$。$\\mathbf{P}$ 的第四行是 $(0, 0, \\frac{1}{5}, \\frac{4}{5})$。\n\n转移矩阵为：\n$$\n\\mathbf{P} =\n\\begin{pmatrix}\n\\frac{4}{5} & \\frac{1}{5} & 0 & 0 \\\\\n0 & 0 & \\frac{1}{5} & \\frac{4}{5} \\\\\n\\frac{4}{5} & \\frac{1}{5} & 0 & 0 \\\\\n0 & 0 & \\frac{1}{5} & \\frac{4}{5}\n\\end{pmatrix}\n$$\n平稳分布 $\\pi = (\\pi_{1}, \\pi_{2}, \\pi_{3}, \\pi_{4})$ 是 $\\mathbf{P}$ 对应于特征值 1 的左特征向量，满足 $\\pi \\mathbf{P} = \\pi$ 和 $\\sum_{i=1}^{4} \\pi_{i} = 1$。这得到了一个线性方程组：\n$$\n\\pi_{1} = \\frac{4}{5}\\pi_{1} + \\frac{4}{5}\\pi_{3} \\\\\n\\pi_{2} = \\frac{1}{5}\\pi_{1} + \\frac{1}{5}\\pi_{3} \\\\\n\\pi_{3} = \\frac{1}{5}\\pi_{2} + \\frac{1}{5}\\pi_{4} \\\\\n\\pi_{4} = \\frac{4}{5}\\pi_{2} + \\frac{4}{5}\\pi_{4}\n$$\n由第一个方程，$\\frac{1}{5}\\pi_{1} = \\frac{4}{5}\\pi_{3}$，这意味着 $\\pi_{1} = 4\\pi_{3}$。\n由第四个方程，$\\frac{1}{5}\\pi_{4} = \\frac{4}{5}\\pi_{2}$，这意味着 $\\pi_{4} = 4\\pi_{2}$。\n将 $\\pi_{1} = 4\\pi_{3}$ 代入第二个方程，得到 $\\pi_{2} = \\frac{1}{5}(4\\pi_{3}) + \\frac{1}{5}\\pi_{3} = \\pi_{3}$。\n因此我们有以下关系：$\\pi_{2} = \\pi_{3}$，$\\pi_{1} = 4\\pi_{3} = 4\\pi_{2}$，以及 $\\pi_{4} = 4\\pi_{2}$。\n使用归一化条件 $\\pi_{1} + \\pi_{2} + \\pi_{3} + \\pi_{4} = 1$：\n$$\n4\\pi_{2} + \\pi_{2} + \\pi_{2} + 4\\pi_{2} = 1 \\\\\n10\\pi_{2} = 1 \\implies \\pi_{2} = \\frac{1}{10}\n$$\n由此，我们求得其他分量：\n$\\pi_{1} = 4 \\cdot \\frac{1}{10} = \\frac{4}{10} = \\frac{2}{5}$\n$\\pi_{3} = \\frac{1}{10}$\n$\\pi_{4} = 4 \\cdot \\frac{1}{10} = \\frac{4}{10} = \\frac{2}{5}$\n平稳分布为 $\\pi = (\\frac{2}{5}, \\frac{1}{10}, \\frac{1}{10}, \\frac{2}{5})$。\n\n**逐项分析**\n\nA. 通过直方图法计算的 $(s_{1}, s_{2}, s_{3}, s_{4})$ 上的平稳分布是 $\\pi = \\left(\\frac{2}{5}, \\frac{1}{10}, \\frac{1}{10}, \\frac{2}{5}\\right)$。\n这个陈述是**正确的**。上述计算对应于直方图方法，它精确地得出了这个分布。\n\nB. 对于一个 $N$ 很大、$T$ 很大且舍弃了预烧期的长面板模拟，经验横截面状态频率几乎必然收敛到与选项 A 中相同的平稳分布。\n这个陈述是**正确的**。所构建的马尔可夫链是有限且不可约的，这意味着它是遍历的。马尔可夫链的遍历定理保证了对于大量的行为人 $N$ 和长时序 $T$，模拟中状态的经验分布将几乎必然收敛到唯一的平稳分布 $\\pi$。\n\nC. 在 $a = a_{1}$ 的状态上的平稳质量等于 $\\frac{1}{2}$。\n这个陈述是**正确的**。对应于资产水平 $a_1$ 的状态是 $s_3 = (a_1, z_L)$ 和 $s_4 = (a_1, z_H)$。这些状态上的总平稳概率质量为 $\\pi_{3} + \\pi_{4} = \\frac{1}{10} + \\frac{2}{5} = \\frac{1}{10} + \\frac{4}{10} = \\frac{5}{10} = \\frac{1}{2}$。\n\nD. 如果面板在初始时精确地处于平稳分布，且策略 $g$ 如上所述是确定性的，那么再经过一个时期后，对于任何有限的 $N$，模拟的横截面分布都将保持完全相同。\n这个陈述是**不正确的**。设行为人数量为 $N$。如果系统初始化时每个状态 $i$ 有 $N_{i} = N\\pi_{i}$ 个行为人，那么转移到状态 $j$ 的行为人数量是一系列伯努利随机变量的和。对于任何有限的 $N$，由于抽样变异，这个实现的数量几乎必然会与其期望值不同。大数定律意味着实现的分布仅在 $N \\to \\infty$ 时才收敛于平稳分布。对于有限的 $N$，分布不会保持*完全*相同。\n\nE. 直方图法引入了仅在 $N \\to \\infty$ 时才消失的抽样误差；相比之下，如果从平稳状态开始初始化，长模拟则没有抽样误差。\n这个陈述是**不正确的**。它从根本上错误地描述了误差的来源。直方图法是针对给定网格的一种确定性数值程序；它的误差是*离散化误差*（来自对连续状态空间的近似）和数值求解器误差，而不是与行为人数量 $N$ 相关的抽样误差。任何具有有限数量行为人 $N$ 的模拟，无论如何初始化，在每个时期都内在地包含*抽样误差*，因为横截面的演变是一个随机过程。", "answer": "$$\\boxed{ABC}$$"}, {"introduction": "这些模型真正的力量在于它们能够分析经济政策不仅对总量，也对整个财富和福利分配的影响。本实践超越了静态分析，要求你首先求解家庭的最优储蓄策略，然后模拟在失业救济金发生永久性变化后，经济从一个稳态到另一个稳态的完整转型过程。你将编写一个完整的程序来追踪总资产的动态路径，这是现代宏观经济分析中的一项核心技能。[@problem_id:2437637]", "id": "2437637", "problem": "考虑一个标准的异质性代理人非完备市场经济，其精神源于 Bewley-Huggett-Aiyagari 模型，其中包含单位质量的无限生命期家庭，他们面临异质性的就业风险，但没有总体冲击。时间是离散的。每个家庭都最大化其期望终身效用，其偏好为恒定相对风险规避（CRRA）偏好，由 $E_{0}\\left[\\sum_{t=0}^{\\infty} \\beta^{t} u(c_{t})\\right]$ 给出，其中当 $\\sigma \\neq 1$ 时，$u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，贴现因子 $\\beta \\in (0,1)$，消费 $c \\ge 0$。家庭拥有资产 $a \\in \\mathcal{A} = [a_{\\min}, a_{\\max}]$，并受到借贷约束 $a^{\\prime} \\ge a_{\\min}$ 且 $a_{\\min} \\ge 0$。每个时期的预算约束为 $c + a^{\\prime} = (1+r) a + y(z)$，其中 $r$ 是外生的真实利率，就业状态 $z \\in \\{0,1\\}$ 服从一个双状态马尔可夫链，其转移矩阵为 $P = \\begin{bmatrix} \\Pr(z^{\\prime}=0 \\mid z=0) & \\Pr(z^{\\prime}=1 \\mid z=0) \\\\ \\Pr(z^{\\prime}=0 \\mid z=1) & \\Pr(z^{\\prime}=1 \\mid z=1) \\end{bmatrix}$。劳动收入在就业时为 $y(1) = w$，失业时为 $y(0) = b$。其中 $w$ 是外生工资，而 $b$ 是由政策决定的失业救济金。价格 $(r,w)$ 是固定的，没有总生产或资本市场出清来决定价格；研究重点纯粹是局部均衡下的分布动态。\n\n令单个家庭的动态规划问题为贝尔曼方程\n$$\nV(a,z) = \\max_{a^{\\prime} \\in \\mathcal{A},\\, a^{\\prime} \\ge a_{\\min}} \\left\\{ u\\left((1+r)a + y(z) - a^{\\prime}\\right) + \\beta \\sum_{z^{\\prime} \\in \\{0,1\\}} P_{z z^{\\prime}} V(a^{\\prime}, z^{\\prime}) \\right\\}.\n$$\n令 $\\pi(a,z)$ 表示一个最优平稳策略，它将 $(a,z)$ 映射到下一期的资产 $a^{\\prime}$。给定一个离散化的资产网格 $\\{a_{i}\\}_{i=1}^{N_{a}}$ 和就业状态 $\\{0,1\\}$，最优策略 $\\pi$ 在大小为 $2 N_{a}$ 的有限状态空间 $\\{(a_{i},z)\\}$ 上引出一个马尔可夫转移核 $Q$。$Q$ 的每一行包含从当前状态 $(a_{i},z)$ 转移到下一状态 $(a_{j},z^{\\prime})$ 的转移概率，这些概率由最优的下一期资产选择 $a_{j} = \\pi(a_{i},z)$ 和就业转移概率 $P_{z z^{\\prime}}$ 给出。平稳分布 $\\mu^{\\star}$ 是一个满足 $\\mu^{\\star} = \\mu^{\\star} Q$ 的不变测度。\n\n假设经济体最初处于失业救济金水平为 $b_{0}$ 的平稳状态，其对应的最优平稳策略为 $\\pi_{0}$，转移核为 $Q_{0}$，以及在 $(a,z)$ 上的横截面平稳分布为 $\\mu_{0}$。在 $t=0$ 时刻，失业救济金发生了一次未预料到的、永久性的增加，从 $b_{0}$ 增加到 $b_{1} > 0$。在 $b_{1}$ 水平下，令新的最优策略为 $\\pi_{1}$，新的转移核为 $Q_{1}$，新的平稳分布为 $\\mu_{1}^{\\star}$。政策变更后，横截面分布遵循确定性的运动定律 $\\mu_{t+1} = \\mu_{t} Q_{1}$（对于 $t \\ge 0$），从 $t=0$ 时的 $\\mu_{0}$ 开始。定义时刻 $t$ 的总资产为 $A_{t} = \\sum_{i,z} \\mu_{t}(a_{i},z) \\cdot a_{i}$，新的平稳总资产为 $A_{\\infty} = \\sum_{i,z} \\mu_{1}^{\\star}(a_{i},z) \\cdot a_{i}$。\n\n你的任务是编写一个完整的、可运行的程序，该程序能够：\n- 通过在离散网格上求解贝尔曼方程，解决给定救济金 $b$ 下的家庭问题，以获得最优策略 $\\pi$ 和引出的转移核 $Q$。\n- 通过在有限状态空间上对分布进行前向迭代，计算给定转移核 $Q$ 下的平稳分布 $\\mu^{\\star}$。\n- 计算在 $Q_{1}$ 下从 $\\mu_{0}$ 开始的分布的转移路径，并追踪 $A_{t}$。\n- 对于下方的每个测试用例，返回三个量：满足给定容差 $\\varepsilon$ 的条件 $\\frac{|A_{\\tau} - A_{\\infty}|}{\\max\\{1, |A_{\\infty}|\\}} \\le \\varepsilon$ 的最小非负整数时间 $\\tau$，初始总资产 $A_{0}$，以及新的平稳总资产 $A_{\\infty}$。\n\n除非另有说明，所有测试用例均使用以下固定参数：$\\beta = 0.96$，$\\sigma = 2.0$，$r = 0.01$，$w = 1.0$，$P = \\begin{bmatrix} 0.70 & 0.30 \\\\ 0.05 & 0.95 \\end{bmatrix}$，其中行对应于按 $(0,1)$ 排序的 $z \\in \\{0,1\\}$，资产网格 $\\{a_{i}\\}_{i=1}^{N_{a}}$ 在 $[a_{\\min}, a_{\\max}]$ 上线性间隔，其中 $a_{\\min} = 0.0$ 且 $a_{\\max} = 50.0$，且就业收入映射为 $y(1) = w, y(0) = b$。每个测试用例使用指定的 $N_{a}$。在计算效用时，强制要求可行性 $c = (1+r)a + y(z) - a^{\\prime} \\ge 0$，并将 $c \\le 0$ 视为不可行，其效用为 $-\\infty$。在资产网格上使用值函数迭代（VFI）或任何数值上正确的基于收缩的方法；插值不是必需的，但如果您选择使用也是允许的。对于给定核 $Q$ 下的平稳分布，向前迭代一个分布，直到在sup范数下的收敛误差小于一个小的容差。\n\n将转移时间的收敛容差定义为相对度量 $\\frac{|A_{t} - A_{\\infty}|}{\\max\\{1, |A_{\\infty}|\\}}$ 下的 $\\varepsilon = 10^{-6}$。如果 $b_{1} = b_{0}$，根据构造，转移时间应为 $\\tau = 0$。在搜索 $\\tau$ 时，使用最大期限 $T_{\\max} = 2000$ 个时期；如果到 $T_{\\max}$ 时仍未满足条件，则返回 $\\tau = T_{\\max}$。\n\n测试套件。您的程序必须为以下三个参数集中的每一个计算三元组 $(\\tau, A_{0}, A_{\\infty})$：\n- 测试用例1（基准增加）：$b_{0} = 0.10$, $b_{1} = 0.20$, $N_{a} = 80$。\n- 测试用例2（无变化边界情况）：$b_{0} = 0.15$, $b_{1} = 0.15$, $N_{a} = 80$。\n- 测试用例3（大幅增加）：$b_{0} = 0.05$, $b_{1} = 0.40$, $N_{a} = 80$。\n\n答案规范和最终输出格式：\n- 对于每个测试用例，输出整数 $\\tau$ 以及四舍五入到六位小数的浮点数 $A_{0}$ 和 $A_{\\infty}$。\n- 将所有测试用例的结果汇总到程序打印的一行中，格式为方括号括起来的逗号分隔列表，顺序为 $[\\tau_{1}, A_{0,1}, A_{\\infty,1}, \\tau_{2}, A_{0,2}, A_{\\infty,2}, \\tau_{3}, A_{0,3}, A_{\\infty,3}]$，不含空格。\n- 本问题不涉及物理单位。也不涉及角度。不要显示百分比；如果出现任何比率，必须表示为小数，并遵守对 $A_{0}$ 和 $A_{\\infty}$ 的四舍五入指令。\n\n科学真实性、基础依据和推导期望：从动态规划、由最优平稳策略引出的离散状态空间上的马尔可夫链以及有限马尔可夫链的不变测度的基本定义出发构建您的解决方案。不要使用任何非从这些基础推导而来的快捷公式。确保所有数值程序（网格离散化、用于值函数的基于收缩的不动点迭代、用于分布的前向迭代）都以科学上合理且自洽的方式实现。", "solution": "此问题被评估为有效。它构成了一个适定且标准的计算经济学练习，基于已建立的 Bewley-Huggett-Aiyagari 框架。任务是分析失业救济金永久性变化带来的分布性和总体性后果。解决方案需要解决家庭的动态规划问题，确定财富和就业的引致马尔可夫过程，并模拟经济向新稳态的过渡。该方法将按如下方式进行数值实现。\n\n首先，我们定义离散化的状态空间。家庭的连续状态是其资产持有量 $a$ 和其就业状况 $z$。资产空间 $\\mathcal{A} = [a_{\\min}, a_{\\max}]$ 被离散化为一个包含 $N_a$ 个点的网格 $\\{a_i\\}_{i=1}^{N_a}$，这些点是线性间隔的。就业状态 $z$ 是离散的，$z \\in \\{0, 1\\}$。因此，我们数值问题的完整状态空间是有限集 $S = \\{a_i\\}_{i=1}^{N_a} \\times \\{0, 1\\}$，包含 $2 N_a$ 个不同的状态。我们可以用一个有序对 $(a_i, z)$ 来表示一个状态。\n\n模型的核心是家庭的优化问题，我们使用值函数迭代（VFI）来解决。对于处于状态 $(a,z)$ 的家庭，其贝尔曼方程由下式给出：\n$$ V(a,z) = \\max_{a' \\ge a_{\\min}} \\left\\{ u(c) + \\beta \\sum_{z' \\in \\{0,1\\}} P_{zz'} V(a', z') \\right\\} $$\n受制于预算约束 $c + a' = (1+r)a + y(z)$ 以及消费的非负约束 $c \\ge 0$。效用函数为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$。\n为了在我们的离散网格上求解此问题，我们对值函数进行迭代，该函数表示为一个大小为 $2 \\times N_a$ 的矩阵 $V$。从一个初始猜测 $V_0$ 开始，我们迭代 $V_{k+1} = T(V_k)$，其中 $T$ 是贝尔曼算子。对于每个状态 $(a_i, z)$，该算子为：\n$$ (T V)(a_i, z) = \\max_{j \\in \\{1,...,N_a\\}} \\left\\{ u\\left((1+r)a_i + y(z) - a_j\\right) + \\beta \\sum_{z' \\in \\{0,1\\}} P_{zz'} V_k(a_j, z') \\right\\} $$\n我们必须强制执行消费 $c = (1+r)a_i + y(z) - a_j$ 必须为正的约束；否则，效用被视为 $-\\infty$，使得该 $a_j$ 的选择不可行。迭代持续进行，直到值函数收敛，即当连续迭代值之差的上确界范数 $\\|V_{k+1} - V_k\\|_{\\infty}$ 小于一个小的容差时。此过程产生收敛的值函数 $V^{\\star}$ 和一个最优策略函数 $\\pi(a_i, z) = a_j$，该函数将每个状态 $(a_i, z)$ 映射到一个最优的下期资产选择 $a_j$。这通过向量化得以高效实现。\n\n最优策略 $\\pi$ 和外生就业转移矩阵 $P$ 共同在离散状态空间 $S$ 上定义了一个时间齐次马尔可夫链。我们构造一个 $2N_a \\times 2N_a$ 的转移矩阵 $Q$。设状态排序为：前 $N_a$ 个索引对应状态 $(a_i, 0)$（$i=1,\\dots,N_a$），接下来的 $N_a$ 个索引对应状态 $(a_i, 1)$。元素 $Q_{(i,z), (k,z')}$ 给出了从状态 $(a_i, z)$ 转移到状态 $(a_k, z')$ 的概率。只有当状态 $(a_i, z)$ 的策略指定下一期选择 $a_k$ 时，此概率才为非零。形式上：\n$$ Q_{(a_i,z), (a_k,z')} = \\begin{cases} P_{zz'} & \\text{如果 } \\pi(a_i,z) = a_k \\\\ 0 & \\text{否则} \\end{cases} $$\n这个矩阵 $Q$ 描述了单个家庭在状态空间上的运动定律。\n\n给定转移矩阵 $Q$，家庭的横截面分布 $\\mu$ 按照 $\\mu_{t+1} = \\mu_t Q$ 演化，其中 $\\mu_t$ 是一个大小为 $2N_a$ 的行向量，表示在时刻 $t$ 处于每个状态的家庭质量。平稳分布 $\\mu^{\\star}$ 是此映射的一个不动点，满足 $\\mu^{\\star} = \\mu^{\\star} Q$。由于底层的冲击过程是遍历的，且家庭进行预防性储蓄，这个马尔可夫链也是遍历的，从而保证了唯一平稳分布的存在。我们通过前向迭代计算 $\\mu^{\\star}$：从一个任意的初始分布（例如，均匀分布）开始，我们重复应用更新规则 $\\mu_{k+1} = \\mu_k Q$，直到 $\\|\\mu_{k+1} - \\mu_k\\|_{\\infty}$ 小于收敛容差。\n\n问题要求我们分析一个政策转移。我们首先计算与失业救济金水平 $b_0$ 相对应的初始平稳状态。这包括找到 $b_0$ 下的最优策略 $\\pi_0$、转移核 $Q_0$ 和平稳分布 $\\mu_0$。从 $\\mu_0$，我们计算初始总资产 $A_0 = \\sum_{i=1}^{N_a} \\sum_{z \\in \\{0,1\\}} \\mu_0(a_i, z) \\cdot a_i$。\n接下来，我们计算新救济金水平 $b_1$ 的新平稳状态。这将产生新的转移核 $Q_1$ 和新的平稳分布 $\\mu_1^{\\star}$，并从中计算出新的长期总资产 $A_{\\infty} = \\sum_{i=1}^{N_a} \\sum_{z \\in \\{0,1\\}} \\mu_1^{\\star}(a_i, z) \\cdot a_i$。\n\n最后，我们模拟转移路径。经济在 $t=0$ 时刻从分布 $\\mu_0$ 开始。政策变为 $b_1$ 意味着动态现在由 $Q_1$ 控制。分布按 $\\mu_{t+1} = \\mu_t Q_1$ 演化。我们逐期模拟此路径，在每一步计算总资产 $A_t = \\sum_{i,z} \\mu_t(a_i, z) \\cdot a_i$。我们追踪时间 $t$ 并在满足收敛准则时停止，找到最小的非负整数 $\\tau$ 使得 $\\frac{|A_{\\tau} - A_{\\infty}|}{\\max\\{1, |A_{\\infty}|\\}} \\le \\varepsilon$。如果在最大期限 $T_{max}$ 内未满足此条件，我们设置 $\\tau=T_{\\max}$。每个测试用例的最终输出是三元组 $(\\tau, A_0, A_{\\infty})$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    def solve_economy(b, Na, params):\n        \"\"\"\n        Solves the household problem and computes the transition kernel for a given benefit level 'b'.\n        \"\"\"\n        beta, sigma, r, w, P, a_min, a_max = params\n        a_grid = np.linspace(a_min, a_max, Na)\n        y = np.array([b, w])\n\n        # Value Function Iteration\n        v = np.zeros((2, Na))\n        policy_idx = np.zeros((2, Na), dtype=int)\n        vfi_tol = 1e-8\n        max_iter_vfi = 2000\n        \n        for k in range(max_iter_vfi):\n            v_old = v.copy()\n            expected_v = P @ v_old # E[V(a', z') | z] = P_z . V(a',:)\n\n            for z in range(2): # 0: unemployed, 1: employed\n                # Vectorized calculation over current assets a_i\n                cash_on_hand = (1 + r) * a_grid + y[z]\n                \n                # consumption_matrix[i, j] = consumption if current asset is a_i and next asset is a_j\n                consumption_matrix = cash_on_hand.reshape(-1, 1) - a_grid.reshape(1, -1)\n                \n                utility_matrix = np.full((Na, Na), -np.inf)\n                feasible = consumption_matrix > 0\n                utility_matrix[feasible] = (consumption_matrix[feasible]**(1 - sigma)) / (1 - sigma)\n\n                # Bellman RHS for each (i, j) pair\n                # continuation_value[j] = beta * E[V(a_j, z') | z]\n                continuation_value = beta * expected_v[z, :]\n                value_matrix = utility_matrix + continuation_value.reshape(1, -1)\n                \n                v[z, :] = np.max(value_matrix, axis=1)\n                policy_idx[z, :] = np.argmax(value_matrix, axis=1)\n\n            if np.max(np.abs(v - v_old)) < vfi_tol:\n                break\n        \n        # Construct transition matrix Q\n        num_states = 2 * Na\n        Q = np.zeros((num_states, num_states))\n        for z in range(2):\n            for i in range(Na):\n                current_state_idx = z * Na + i\n                next_asset_idx = policy_idx[z, i]\n                \n                # Transition to unemployed state with next asset\n                next_state_unemp_idx = 0 * Na + next_asset_idx\n                Q[current_state_idx, next_state_unemp_idx] = P[z, 0]\n                \n                # Transition to employed state with next asset\n                next_state_emp_idx = 1 * Na + next_asset_idx\n                Q[current_state_idx, next_state_emp_idx] = P[z, 1]\n                \n        return Q, a_grid\n\n    def compute_stationary_distribution(Q, Na):\n        \"\"\"\n        Computes the stationary distribution for a given transition matrix Q.\n        \"\"\"\n        num_states = 2 * Na\n        mu = np.ones(num_states) / num_states\n        dist_tol = 1e-12\n        max_iter_dist = 5000\n\n        for _ in range(max_iter_dist):\n            mu_new = mu @ Q\n            if np.max(np.abs(mu_new - mu)) < dist_tol:\n                return mu_new\n            mu = mu_new\n        return mu\n\n    def run_case(b0, b1, Na):\n        \"\"\"\n        Runs a single test case scenario.\n        \"\"\"\n        # Fixed parameters\n        beta = 0.96\n        sigma = 2.0\n        r = 0.01\n        w = 1.0\n        P = np.array([[0.70, 0.30], [0.05, 0.95]])\n        a_min = 0.0\n        a_max = 50.0\n        params = (beta, sigma, r, w, P, a_min, a_max)\n        \n        # Transition path parameters\n        eps_tau = 1e-6\n        T_max = 2000\n\n        # --- Initial Steady State (b0) ---\n        Q0, a_grid = solve_economy(b0, Na, params)\n        mu0 = compute_stationary_distribution(Q0, Na)\n        full_asset_vector = np.tile(a_grid, 2)\n        A0 = np.dot(mu0, full_asset_vector)\n\n        # --- Handle no-change case ---\n        if b0 == b1:\n            A_inf = A0\n            tau = 0\n            return tau, A0, A_inf\n            \n        # --- New Steady State (b1) ---\n        Q1, _ = solve_economy(b1, Na, params)\n        mu1_star = compute_stationary_distribution(Q1, Na)\n        A_inf = np.dot(mu1_star, full_asset_vector)\n        \n        # --- Transition Path ---\n        mu_t = mu0\n        tau = T_max\n        denominator = max(1.0, abs(A_inf))\n\n        for t in range(T_max + 1):\n            A_t = np.dot(mu_t, full_asset_vector)\n            if abs(A_t - A_inf) / denominator <= eps_tau:\n                tau = t\n                break\n            mu_t = mu_t @ Q1\n\n        return tau, A0, A_inf\n\n    # Define test cases\n    test_cases = [\n        {'b0': 0.10, 'b1': 0.20, 'Na': 80},  # Test case 1\n        {'b0': 0.15, 'b1': 0.15, 'Na': 80},  # Test case 2\n        {'b0': 0.05, 'b1': 0.40, 'Na': 80},  # Test case 3\n    ]\n\n    all_results = []\n    for case in test_cases:\n        tau, A0, A_inf = run_case(case['b0'], case['b1'], case['Na'])\n        all_results.append(tau)\n        all_results.append(f\"{A0:.6f}\")\n        all_results.append(f\"{A_inf:.6f}\")\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"}, {"introduction": "现实世界中的家庭通常会以多种类型的资产进行储蓄，但在我们的模型中增加更多的连续状态变量会导致“维度灾难”，使得计算变得异常困难。这个高级练习挑战你求解一个包含两种资产选择的模型，并介绍一项关键的专业技能：验证数值解的准确性。通过计算欧拉方程残差，你将学会如何判断你计算出的策略是否是真实最优解的一个良好近似。[@problem_id:2437584]", "id": "2437584", "problem": "请考虑一个Bewley-Huggett-Aiyagari类型的异质性代理人、不完全市场经济，其中存在两种连续的资产头寸。一个家庭面临个体性劳动收入风险，并在满足一系列预算约束和借贷限制的前提下，最大化其消费的贴现期望效用。时间是离散的。偏好表现为恒定相对风险规避（CRRA）。形式上，家庭求解以下问题：\n$$\n\\max_{\\{c_t,a_{1,t+1},a_{2,t+1}\\}_{t=0}^{\\infty}} \\ \\mathbb{E}_0 \\sum_{t=0}^{\\infty} \\beta^t \\, u(c_t),\n$$\n其中，当 $\\sigma \\neq 1$ 时，$u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$；当 $\\sigma = 1$ 时，$u(c) = \\log(c)$。预算约束为\n$$\nc_t + a_{1,t+1} + a_{2,t+1} = (1+r_1) a_{1,t} + (1+r_2) a_{2,t} + w z_t,\n$$\n借贷约束为\n$$\na_{1,t+1} \\ge a_{\\min}, \\quad a_{2,t+1} \\ge a_{\\min}.\n$$\n劳动生产率 $z_t$ 遵循一个时间同质的、有限状态的马尔可夫链，该链在集合 $\\mathcal{Z} = \\{z^1, \\ldots, z^M\\}$ 上，其转移矩阵为 $\\Pi = [\\pi_{ij}]_{i,j=1}^M$，其中 $\\pi_{ij} = \\mathbb{P}(z_{t+1} = z^j \\mid z_t = z^i)$ 且对于每个 $i$ 都有 $\\sum_{j=1}^M \\pi_{ij} = 1$。状态向量为 $(a_1,a_2,z) \\in \\mathcal{A}_1 \\times \\mathcal{A}_2 \\times \\mathcal{Z}$，其中 $\\mathcal{A}_1$ 和 $\\mathcal{A}_2$ 是 $\\mathbb{R}$ 的紧子集，下界为 $a_{\\min}$。\n\n设值函数由贝尔曼方程定义：\n$$\nV(a_1,a_2,z) = \\max_{a_1' \\ge a_{\\min}, \\, a_2' \\ge a_{\\min}} \\left\\{ u\\left((1+r_1)a_1 + (1+r_2)a_2 + w z - a_1' - a_2' \\right) + \\beta \\sum_{z' \\in \\mathcal{Z}} \\pi(z,z') \\, V(a_1',a_2',z') \\right\\},\n$$\n其中 $\\pi(z,z')$ 表示从 $z$ 到 $z'$ 的转移概率。\n\n定义稳态的单期前瞻策略函数 $(g_1,g_2)$，该函数将当前状态 $(a_1,a_2,z)$ 映射到下一期资产 $(a_1',a_2')$。给定这样的策略函数，当期消费定义为\n$$\nc(a_1,a_2,z) = (1+r_1)a_1 + (1+r_2)a_2 + w z - g_1(a_1,a_2,z) - g_2(a_1,a_2,z),\n$$\n以及取决于实现值 $z'$ 的下一期消费定义为\n$$\nc'(z'; a_1,a_2,z) = (1+r_1) g_1(a_1,a_2,z) + (1+r_2) g_2(a_1,a_2,z) + w z' - g_1(g_1(a_1,a_2,z), g_2(a_1,a_2,z), z') - g_2(g_1(a_1,a_2,z), g_2(a_1,a_2,z), z').\n$$\n\n对于内部选择（意味着两个策略选择都严格高于借贷限制），欧拉方程要求\n$$\nu'\\!\\left(c(a_1,a_2,z)\\right) = \\beta (1+r_1) \\, \\mathbb{E}\\left[ u'\\!\\left(c'(z'; a_1,a_2,z)\\right) \\,\\middle|\\, z \\right],\n$$\n$$\nu'\\!\\left(c(a_1,a_2,z)\\right) = \\beta (1+r_2) \\, \\mathbb{E}\\left[ u'\\!\\left(c'(z'; a_1,a_2,z)\\right) \\,\\middle|\\, z \\right],\n$$\n其中，当 $\\sigma \\neq 1$ 时，$u'(c) = c^{-\\sigma}$；当 $\\sigma = 1$ 时，$u'(c) = 1/c$。当某项资产的借贷约束为紧约束时，相应的欧拉方程变为不等式，以 $\\ge$ 成立。\n\n您的任务是，对于下面测试套件中的每一组参数，计算在离散化状态空间上的最大绝对内部欧拉残差。其定义如下。设 $\\mathcal{G}_1 \\subset \\mathcal{A}_1$ 和 $\\mathcal{G}_2 \\subset \\mathcal{A}_2$ 分别是包含 $N_1$ 和 $N_2$ 个点的均匀网格，且都包含下界 $a_{\\min}$。将可行选择 $(a_1',a_2')$ 限制在这些网格上。使用在上述离散选择限制下，由贝尔曼问题导出的稳态最优策略。对于网格上的每个状态 $(a_1,a_2,z)$，如果最优选择在网格上是严格内部的（不等于 $a_{\\min}$ 且不等于网格上端点），并且当期消费和所有可能的下一期消费都严格为正，则定义两个残差如下：\n$$\nR_1(a_1,a_2,z) = u'\\!\\left(c(a_1,a_2,z)\\right) - \\beta (1+r_1)\\sum_{z' \\in \\mathcal{Z}} \\pi(z,z') \\, u'\\!\\left(c'(z'; a_1,a_2,z)\\right),\n$$\n$$\nR_2(a_1,a_2,z) = u'\\!\\left(c(a_1,a_2,z)\\right) - \\beta (1+r_2)\\sum_{z' \\in \\mathcal{Z}} \\pi(z,z') \\, u'\\!\\left(c'(z'; a_1,a_2,z)\\right).\n$$\n报告标量值\n$$\n\\max \\left\\{ \\left| R_1(a_1,a_2,z) \\right|, \\left| R_2(a_1,a_2,z) \\right| \\ \\text{遍及所有满足内部选择和严格正消费条件的网格状态} \\right\\}.\n$$\n如果没有任何网格状态满足这些内部和正值条件，则报告数值 $0.0$。\n\n测试套件。对于以下三种情况，所有参数均为自然单位，无需报告物理单位。所有数字必须被视为实数。对每种情况，在指定的网格上计算稳态最优策略，然后计算如上定义的最大绝对内部欧拉残差：\n\n- 情况 A (理想路径):\n  - 偏好: $\\beta = 0.96$, $\\sigma = 2.0$。\n  - 回报率和工资: $r_1 = 0.02$, $r_2 = 0.04$, $w = 1.0$。\n  - 收入过程: $\\mathcal{Z} = \\{0.5, 1.0, 1.5\\}$，转移矩阵为\n    $$\n    \\Pi =\n    \\begin{bmatrix}\n    0.50 & 0.30 & 0.20 \\\\\n    0.20 & 0.50 & 0.30 \\\\\n    0.20 & 0.30 & 0.50\n    \\end{bmatrix}.\n    $$\n  - 资产网格: $a_{\\min} = 0.0$，上界 $a_{1,\\max} = a_{2,\\max} = 8.0$，使用含 $N_1 = 10$ 和 $N_2 = 10$ 个点的均匀网格。\n\n- 情况 B (低回报率和更强的曲率，测试潜在的边界选择):\n  - 偏好: $\\beta = 0.94$, $\\sigma = 3.0$。\n  - 回报率和工资: $r_1 = 0.00$, $r_2 = 0.005$, $w = 1.0$。\n  - 收入过程: $\\mathcal{Z} = \\{0.5, 1.0\\}$，转移矩阵为\n    $$\n    \\Pi =\n    \\begin{bmatrix}\n    0.70 & 0.30 \\\\\n    0.30 & 0.70\n    \\end{bmatrix}.\n    $$\n  - 资产网格: $a_{\\min} = 0.0$，上界 $a_{1,\\max} = a_{2,\\max} = 6.0$，使用含 $N_1 = 8$ 和 $N_2 = 8$ 个点的均匀网格。\n\n- 情况 C (退化的收入风险，测试双资产下的确定性动态):\n  - 偏好: $\\beta = 0.95$, $\\sigma = 1.5$。\n  - 回报率和工资: $r_1 = 0.03$, $r_2 = 0.03$, $w = 1.0$。\n  - 收入过程: $\\mathcal{Z} = \\{1.0\\}$，转移矩阵为 $\\Pi = [1.0]$。\n  - 资产网格: $a_{\\min} = 0.0$，上界 $a_{1,\\max} = a_{2,\\max} = 10.0$，使用含 $N_1 = 12$ 和 $N_2 = 12$ 个点的均匀网格。\n\n需要遵循的计算和数值约定：\n- 为了优化的目的，将任何候选消费 $c \\le 0$ 视为不可行，其效用为 $-\\infty$。在实现中，这可以表示为一个非常大的负回报，任何可行选择都优于它。\n- 在计算欧拉残差时，仅包括那些当期消费和所有相关的下一期消费都严格为正的状态。\n- 为保证数值稳定性，在残差中对非常小但为正的消费值计算 $u'$ 时，只要能保持其严格为正，将其裁剪到一个小的正数下界是可以接受的。\n\n您的程序应生成单行输出，其中包含按顺序排列的情况 A、B 和 C 的结果，形式为一个由方括号括起来、包含三个浮点数的逗号分隔列表，每个浮点数四舍五入到六位小数。例如，输出格式必须与以下完全一样：\n$$\n[\\text{residual\\_A},\\text{residual\\_B},\\text{residual\\_C}],\n$$\n其中每个占位符是一个四舍五入到六位小数的实数。", "solution": "所提出的问题是要求解决并分析一个计算宏观经济学领域的标准经济模型。这是 Bewley-Huggett-Aiyagari 模型的一个变体，扩展到包含两个不同的资产头寸。任务是找到家庭储蓄和消费的稳态最优策略，然后通过计算整个状态空间上的最大欧拉方程残差来量化此计算策略的准确性。\n\n在进行求解之前，需要对问题陈述进行严格的验证。\n\n**问题验证**\n\n**第1步：提取给定信息**\n问题提供了一个完整的家庭动态规划问题的形式化描述，包括：\n- 家庭的目标函数，即最大化贴现 CRRA 效用的期望总和，$\\mathbb{E}_0 \\sum_{t=0}^{\\infty} \\beta^t \\, u(c_t)$，其中 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$ 或 $u(c) = \\log(c)$。\n- 序贯预算约束：$c_t + a_{1,t+1} + a_{2,t+1} = (1+r_1) a_{1,t} + (1+r_2) a_{2,t} + w z_t$。\n- 借贷限制：$a_{1,t+1} \\ge a_{\\min}, a_{2,t+1} \\ge a_{\\min}$。\n- 劳动生产率 $z_t$ 的随机过程，被指定为一个有限状态马尔可夫链。\n- 对应的贝尔曼泛函方程，用于描述值函数 $V(a_1,a_2,z)$。\n- 刻画最优内部解特征的欧拉方程的定义。\n- 在离散化的状态和选择空间上对欧拉残差 $R_1$ 和 $R_2$ 的精确定义。\n- 一个明确的任务：计算在所有最优选择为内部选择且所有相关消费（当期和未来）均为严格正值的网格状态中，最大的绝对欧拉残差。\n- 提供了三个不同的、完全参数化的测试用例（A、B、C），指定了 $\\beta$、$\\sigma$、$r_1, r_2, w$、收入过程（$\\mathcal{Z}, \\Pi$）以及资产网格结构（$a_{\\min}, a_{1,\\max}, a_{2,\\max}, N_1, N_2$）的所有必要值。\n\n**第2步：使用提取的信息进行验证**\n- **科学依据**：该模型是宏观经济学中一个典型的异质性代理人模型。所有方程和概念都是标准的，并且在理论上是健全的。测试用例中提供的参数值在学术文献中使用的常规范围之内。转移矩阵是有效的随机矩阵。该模型具有充分的科学依据。\n- **适定性**：该问题被表述为一个贴现动态规划问题。给定 $\\beta \\in (0,1)$ 和一个有界的回报函数（通过紧凑的状态空间和借贷约束实现），贝尔曼算子是一个压缩映射。标准定理（例如，Blackwell 充分条件）保证了值函数 $V$ 存在一个唯一的稳定不动点，以及一个相关的稳态最优策略函数。根据该策略计算残差的任务是明确定义的。\n- **客观性和完整性**：问题以客观的数学语言陈述。计算解决方案所需的所有参数、约束和定义都已明确提供。对“内部”选择的定义以及对非正消费的处理方式进行了规定，消除了模糊性。问题是自洽且完整的。\n\n**第3步：结论和行动**\n问题被判定为**有效**。这是一个适定、有科学依据且完全指定的计算经济学问题。我现在将提供完整的计算解决方案。\n\n**求解方法论**\n\n该解决方案需要找到贝尔曼方程的不动点，这是通过在状态空间的离散化版本上使用值函数迭代（VFI）的数值方法来完成的。\n\n1.  **离散化**：将连续的状态变量 $a_1$ 和 $a_2$ 离散化为均匀网格 $\\mathcal{G}_1$ 和 $\\mathcal{G}_2$，分别包含 $N_1$ 和 $N_2$ 个点，范围覆盖 $[a_{\\min}, a_{1,\\max}]$ 和 $[a_{\\min}, a_{2,\\max}]$。数值问题的完整状态空间是这些网格与离散冲击集合 $\\mathcal{Z}$ 的笛卡尔积，即 $\\mathcal{G}_1 \\times \\mathcal{G}_2 \\times \\mathcal{Z}$。\n\n2.  **值函数迭代 (VFI)**：我们在值函数上进行迭代，该函数表示为一个三维数组 $V(i, j, m)$，其中 $i, j, m$ 分别是 $a_1, a_2, z$ 网格的索引。从一个初始猜测 $V_0$ 开始，我们迭代贝尔曼算子 $V_{k+1} = T(V_k)$：\n    $$\n    V_{k+1}(a_{1,i}, a_{2,j}, z_m) = \\max_{p,q} \\left\\{ u\\left(y_{i,j,m} - a_{1,p}' - a_{2,q}' \\right) + \\beta \\sum_{m'=1}^M \\pi_{m,m'} \\, V_k(a_{1,p}', a_{2,q}', z_{m'}) \\right\\}\n    $$\n    其中 $y_{i,j,m} = (1+r_1)a_{1,i} + (1+r_2)a_{2,j} + w z_m$ 是手头现金，最大化操作是在所有选择的网格索引 $(p,q)$ 上进行的。迭代持续进行，直到值函数收敛，即对于某个小容差 $\\epsilon$，满足 $\\max |V_{k+1} - V_k| < \\epsilon$。在最后一次迭代中，我们为每个状态 $(i,j,m)$ 存储达到最大值的索引 $(p^*, q^*)$。这些存储的索引构成了离散的最优策略函数，$g_1(i, j, m) = p^*$ 和 $g_2(i, j, m) = q^*$。\n\n3.  **欧拉残差计算**：在获得收敛的值函数和相应的稳态策略函数后，我们着手计算欧拉残差。我们遍历网格上的每一个状态 $(a_{1,i}, a_{2,j}, z_m)$：\n    - 我们从策略函数中检索最优的下一期资产选择 $(a'_{1,p^*}, a'_{2,q^*})$。\n    - 我们检查这些选择是否是**内部的**，即 $0 < p^* < N_1-1$ 和 $0 < q^* < N_2-1$。\n    - 如果是内部选择，我们计算当期消费 $c$ 并检查其是否严格为正。\n    - 如果 $c > 0$，我们接着计算所有可能的下一期状态下的消费 $c'(z_{m'})$，并检查它们是否都严格为正。这需要找到从状态 $(a'_{1,p^*}, a'_{2,q^*}, z_{m'})$ 出发的最优选择，我们可以从我们计算出的策略函数中查找。\n    - 只有当所有这些条件（内部性和所有消费的正值性）都满足时，我们才计算边际效用 $u'(c)$ 和 $u'(c'(z_{m'}))$。\n    - 然后我们通过取期望值 $E[u'(c')] = \\sum_{m'} \\pi_{m, m'} u'(c'(z_{m'}))$ 来计算欧拉方程的右侧。\n    - 最后，使用它们的定义计算残差 $R_1$ 和 $R_2$。记录在所有有效状态中找到的最大绝对值。如果没有状态满足条件，则结果为 $0.0$。\n\n此程序被系统地应用于问题陈述中指定的三个测试用例中的每一个。", "answer": "```python\nimport numpy as np\n\ndef _solve_case(beta, sigma, r1, r2, w, z_grid, pi_matrix, a_min, a_max1, a_max2, n1, n2):\n    \"\"\"\n    Solves the two-asset Bewley-Huggett-Aiyagari model for one parameter case.\n    \"\"\"\n    # 1. Setup Grids and Utility Functions\n    a1_grid = np.linspace(a_min, a_max1, n1)\n    a2_grid = np.linspace(a_min, a_max2, n2)\n    m_shocks = len(z_grid)\n\n    def u_func(c):\n        # Using a small positive number to avoid log(0) or division by zero,\n        # but the main logic handles infeasible states (c<=0).\n        c_safe = np.maximum(c, 1e-12)\n        if sigma == 1.0:\n            val = np.log(c_safe)\n        else:\n            val = (c_safe**(1 - sigma)) / (1 - sigma)\n        # Infeasible consumption yields -infinity utility.\n        if isinstance(val, np.ndarray):\n            val[c <= 0] = -np.inf\n        elif c <= 0:\n            val = -np.inf\n        return val\n\n    def du_func(c):\n        c_safe = np.maximum(c, 1e-12)\n        return c_safe**(-sigma)\n\n    # 2. Value Function Iteration\n    V = np.zeros((n1, n2, m_shocks))\n    policy_idx1 = np.zeros((n1, n2, m_shocks), dtype=np.int32)\n    policy_idx2 = np.zeros((n1, n2, m_shocks), dtype=np.int32)\n\n    max_iter = 1000\n    tol = 1e-7\n\n    # Precompute grid of total savings choices\n    total_savings_choices = a1_grid[:, None] + a2_grid[None, :]\n\n    for it in range(max_iter):\n        V_old = V.copy()\n        \n        # Precompute the expected continuation value for each choice (p,q) and current shock m.\n        # V has shape (n1, n2, m_shocks), pi_matrix.T has shape (m_shocks, m_shocks).\n        # The matmul op broadcasts over the first two dimensions of V.\n        EV = beta * np.matmul(V, pi_matrix.T)\n\n        for i in range(n1):\n            for j in range(n2):\n                for m in range(m_shocks):\n                    cash_on_hand = (1 + r1) * a1_grid[i] + (1 + r2) * a2_grid[j] + w * z_grid[m]\n                    consumption_candidates = cash_on_hand - total_savings_choices\n                    \n                    value_candidates = u_func(consumption_candidates) + EV[:, :, m]\n                    \n                    # Find maximum value and corresponding choice indices\n                    best_idx_flat = np.argmax(value_candidates)\n                    p_star, q_star = np.unravel_index(best_idx_flat, (n1, n2))\n                    \n                    V[i, j, m] = value_candidates[p_star, q_star]\n                    policy_idx1[i, j, m] = p_star\n                    policy_idx2[i, j, m] = q_star\n        \n        error = np.max(np.abs(V - V_old))\n        if error < tol:\n            break\n\n    # 3. Euler Residual Calculation\n    max_residual = 0.0\n    \n    for i in range(n1):\n        for j in range(n2):\n            for m in range(m_shocks):\n                p_star = policy_idx1[i, j, m]\n                q_star = policy_idx2[i, j, m]\n                \n                # Condition 1: Check if the choice is strictly interior on the grids.\n                if not (0 < p_star < n1 - 1 and 0 < q_star < n2 - 1):\n                    continue\n                \n                a1_prime = a1_grid[p_star]\n                a2_prime = a2_grid[q_star]\n                \n                # Condition 2: Check if current consumption is strictly positive.\n                c_current = (1 + r1) * a1_grid[i] + (1 + r2) * a2_grid[j] + w * z_grid[m] - a1_prime - a2_prime\n                if c_current <= 0:\n                    continue\n                    \n                # Condition 3: Check if all possible next-period consumptions are strictly positive.\n                c_prime_list = []\n                all_c_prime_positive = True\n                for m_prime in range(m_shocks):\n                    # Optimal policy from state (a1_prime, a2_prime, z_prime), where indices are (p_star, q_star, m_prime)\n                    p_double_star = policy_idx1[p_star, q_star, m_prime]\n                    q_double_star = policy_idx2[p_star, q_star, m_prime]\n                    \n                    a1_double_prime = a1_grid[p_double_star]\n                    a2_double_prime = a2_grid[q_double_star]\n                    \n                    c_prime = (1 + r1) * a1_prime + (1 + r2) * a2_prime + w * z_grid[m_prime] - a1_double_prime - a2_double_prime\n                    \n                    if c_prime <= 0:\n                        all_c_prime_positive = False\n                        break\n                    c_prime_list.append(c_prime)\n                \n                if not all_c_prime_positive:\n                    continue\n                \n                # If all conditions are met, calculate residuals.\n                du_current = du_func(c_current)\n                du_prime_values = du_func(np.array(c_prime_list))\n                expected_du_prime = np.dot(pi_matrix[m, :], du_prime_values)\n                \n                R1 = du_current - beta * (1 + r1) * expected_du_prime\n                R2 = du_current - beta * (1 + r2) * expected_du_prime\n                \n                max_residual = max(max_residual, abs(R1), abs(R2))\n                \n    return max_residual\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the max Euler residual for each.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"beta\": 0.96, \"sigma\": 2.0, \"r1\": 0.02, \"r2\": 0.04, \"w\": 1.0,\n            \"z_grid\": np.array([0.5, 1.0, 1.5]),\n            \"pi_matrix\": np.array([[0.50, 0.30, 0.20], [0.20, 0.50, 0.30], [0.20, 0.30, 0.50]]),\n            \"a_min\": 0.0, \"a_max1\": 8.0, \"a_max2\": 8.0, \"n1\": 10, \"n2\": 10\n        },\n        # Case B\n        {\n            \"beta\": 0.94, \"sigma\": 3.0, \"r1\": 0.00, \"r2\": 0.005, \"w\": 1.0,\n            \"z_grid\": np.array([0.5, 1.0]),\n            \"pi_matrix\": np.array([[0.70, 0.30], [0.30, 0.70]]),\n            \"a_min\": 0.0, \"a_max1\": 6.0, \"a_max2\": 6.0, \"n1\": 8, \"n2\": 8\n        },\n        # Case C\n        {\n            \"beta\": 0.95, \"sigma\": 1.5, \"r1\": 0.03, \"r2\": 0.03, \"w\": 1.0,\n            \"z_grid\": np.array([1.0]),\n            \"pi_matrix\": np.array([[1.0]]),\n            \"a_min\": 0.0, \"a_max1\": 10.0, \"a_max2\": 10.0, \"n1\": 12, \"n2\": 12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_case(**case)\n        results.append(result)\n\n    # Format the output as a comma-separated list of floats with 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}