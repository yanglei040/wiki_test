{"hands_on_practices": [{"introduction": "Krusell-Smith 算法的一个核心特征是，经济主体需要对宏观总量变量形成预测。本练习 [@problem_id:2441773] 提供了一种剖析总体预测误差的直接方法，将其分解到不同经济群体（如财富五分位数）的贡献。通过这个实践，你将更深刻地理解异质性如何导致实际与感知运动定律的偏离，而这正是该算法学习动态的核心。", "id": "2441773", "problem": "考虑一个异质代理人设定，其中财富分布被有限划分为五个由五等分位数索引的不相交组。设日期 $t$ 的总资本为 $K_t > 0$。每个五等分数组 $i \\in \\{1,2,3,4,5\\}$ 持有时刻 $t$ 的资本份额 $s_{i,t}$，满足 $s_{i,t} \\ge 0$ 和 $\\sum_{i=1}^{5} s_{i,t} = 1$，并通过一个已实现的资本累积总因子 $r_{i,t} > 0$ 将其资本累积至日期 $t+1$。因此，下一期的实际总资本为\n$$\nK_{t+1}^{actual} \\equiv \\sum_{i=1}^{5} K_{i,t+1} = \\sum_{i=1}^{5} s_{i,t}\\, r_{i,t}\\, K_t = K_t \\sum_{i=1}^{5} s_{i,t}\\, r_{i,t}.\n$$\n假设总资本的对数线性预测运动法则形式如下\n$$\n\\log K_{t+1}^{forecast} = a_0 + a_1 \\log K_t + a_2 z_t,\n$$\n其中 $a_0, a_1, a_2 \\in \\mathbb{R}$ 是给定的常数，$z_t \\in \\mathbb{R}$ 是日期 $t$ 给定的标量总冲击。定义隐含的预测总因子\n$$\nG_t^{forecast} \\equiv \\frac{K_{t+1}^{forecast}}{K_t} = \\exp\\!\\big(a_0 + (a_1 - 1)\\log K_t + a_2 z_t\\big).\n$$\n该运动法则的预测误差为\n$$\n\\varepsilon_t \\equiv K_{t+1}^{actual} - K_{t+1}^{forecast}.\n$$\n定义第 $i$ 个五等分位数对预测误差的贡献为\n$$\nc_{i,t} \\equiv K_{i,t+1} - s_{i,t}\\, K_t\\, G_t^{forecast} = K_t\\, s_{i,t}\\, \\big(r_{i,t} - G_t^{forecast}\\big),\n$$\n因此，根据构造，$\\sum_{i=1}^{5} c_{i,t} = \\varepsilon_t$ 成立。\n\n根据以上定义，编写一个程序，为下面测试套件中的每一组参数，计算五等分位数贡献列表 $\\big[c_{1,t}, c_{2,t}, c_{3,t}, c_{4,t}, c_{5,t}\\big]$。\n\n所有量都是没有物理单位的纯数。\n\n测试套件（每行指定 $\\big(K_t, a_0, a_1, a_2, z_t, \\{s_{i,t}\\}_{i=1}^{5}, \\{r_{i,t}\\}_{i=1}^{5}\\big)$）：\n\n- 情况 A（一般情况）：\n  - $K_t = 100.0$, $a_0 = 0.0$, $a_1 = 1.0$, $a_2 = 0.01$, $z_t = 1.0$,\n  - $\\{s_{i,t}\\} = [0.10,\\, 0.15,\\, 0.20,\\, 0.25,\\, 0.30]$,\n  - $\\{r_{i,t}\\} = [1.05,\\, 1.03,\\, 1.02,\\, 1.01,\\, 1.00]$.\n\n- 情况 B（通过构造使预测误差为零）：\n  - $K_t = 250.0$, $a_0 = 0.0$, $a_1 = 1.0$, $a_2 = 0.0$, $z_t = 0.0$,\n  - $\\{s_{i,t}\\} = [0.05,\\, 0.10,\\, 0.15,\\, 0.30,\\, 0.40]$,\n  - $\\{r_{i,t}\\} = [1.0,\\, 1.0,\\, 1.0,\\, 1.0,\\, 1.0]$.\n\n- 情况 C（零份额和负冲击的边界情况）：\n  - $K_t = 80.0$, $a_0 = 0.02$, $a_1 = 0.98$, $a_2 = -0.005$, $z_t = -1.0$,\n  - $\\{s_{i,t}\\} = [0.0,\\, 0.20,\\, 0.30,\\, 0.25,\\, 0.25]$,\n  - $\\{r_{i,t}\\} = [1.04,\\, 0.99,\\, 1.01,\\, 1.00,\\, 1.02]$.\n\n输出规范：\n- 对于每种情况，输出列表 $\\big[c_{1,t}, c_{2,t}, c_{3,t}, c_{4,t}, c_{5,t}\\big]$，四舍五入到六位小数。\n- 按 A、B、C 的顺序将三种情况的结果汇总到一个列表中。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格，其每个元素本身是包含五个四舍五入到六位小数的数字的方括号列表（例如，“[[x11,x12,x13,x14,x15],[x21,x22,x23,x24,x25],[x31,x32,x33,x34,x35]]”）。", "solution": "在尝试任何解决方案之前，所述问题都经过了严格的验证。\n\n**第1步：提取给定信息**\n\n问题提供了以下定义、变量和关系：\n- 时刻 $t$ 的总资本：$K_t > 0$。\n- 五等分位数数量：$5$。\n- 时刻 $t$ 第 $i$ 个五等分位数的资本份额：$s_{i,t}$，其中 $s_{i,t} \\ge 0$ 且 $\\sum_{i=1}^{5} s_{i,t} = 1$。\n- 时刻 $t$ 第 $i$ 个五等分位数的已实现资本累积总因子：$r_{i,t} > 0$。\n- 下一期实际总资本：$K_{t+1}^{\\text{actual}} = K_t \\sum_{i=1}^{5} s_{i,t}\\, r_{i,t}$。\n- 总资本的对数线性预测运动法则：$\\log K_{t+1}^{\\text{forecast}} = a_0 + a_1 \\log K_t + a_2 z_t$。\n- 运动法则的系数：$a_0, a_1, a_2 \\in \\mathbb{R}$。\n- 时刻 $t$ 的总冲击：$z_t \\in \\mathbb{R}$。\n- 隐含的预测总因子：$G_t^{\\text{forecast}} = \\frac{K_{t+1}^{\\text{forecast}}}{K_t} = \\exp\\!\\big(a_0 + (a_1 - 1)\\log K_t + a_2 z_t\\big)$。\n- 预测误差：$\\varepsilon_t = K_{t+1}^{\\text{actual}} - K_{t+1}^{\\text{forecast}}$。\n- 第 $i$ 个五等分位数对预测误差的贡献：$c_{i,t} = K_t\\, s_{i,t}\\, \\big(r_{i,t} - G_t^{\\text{forecast}}\\big)$。\n\n提供了三个测试用例，其中包含参数集 $\\big(K_t, a_0, a_1, a_2, z_t, \\{s_{i,t}\\}_{i=1}^{5}, \\{r_{i,t}\\}_{i=1}^{5}\\big)$ 的具体值。\n\n**第2步：使用提取的给定信息进行验证**\n\n根据所需标准对问题进行评估：\n- **科学依据**：该问题设置在异质代理人宏观经济模型的背景下，特别与 Krusell-Smith 算法相关，该算法是计算经济学中的一个标准工具。其数学形式化基于已建立的经济建模原则。它没有违反任何科学或数学定律。\n- **适定性**：该问题是一个直接的计算任务。对于每个测试用例，都提供了所有必需的参数，并明确给出了目标量 $c_{i,t}$ 的公式。计算过程为每个五等分位数带来唯一、稳定且有意义的数值结果。\n- **客观性**：问题以精确、无歧义的数学语言陈述。没有主观、基于观点或无法形式化的内容。所用术语均为该领域的标准术语。\n- **完整性与一致性**：设定是自洽的。各项定义彼此一致，例如，正确地指出了 $\\sum_{i=1}^{5} c_{i,t} = \\varepsilon_t$。为每个测试用例提供的数据足以执行所需的计算。所有情况都满足条件 $\\sum s_{i,t}=1$。\n\n**第3步：结论与行动**\n\n问题定义明确，有科学依据，并且计算上是可行的。判定为**有效**。将提供一个解决方案。\n\n目标是为所提供的三组参数中的每一组计算五等分位数对预测误差的贡献列表 $\\big[c_{1,t}, c_{2,t}, c_{3,t}, c_{4,t}, c_{5,t}\\big]$。该过程是所提供定义的直接应用。\n\n对于每组参数，计算分两个阶段进行：\n1.  使用以下公式计算隐含的预测总因子 $G_t^{\\text{forecast}}$：\n    $$\n    G_t^{\\text{forecast}} = \\exp\\!\\big(a_0 + (a_1 - 1)\\log K_t + a_2 z_t\\big)\n    $$\n2.  对于每个五等分位数 $i \\in \\{1,2,3,4,5\\}$，使用以下公式计算其对预测误差的贡献 $c_{i,t}$：\n    $$\n    c_{i,t} = K_t\\, s_{i,t}\\, \\big(r_{i,t} - G_t^{\\text{forecast}}\\big)\n    $$\n\n现在将此过程应用于每个测试用例。\n\n**情况A：**\n给定参数：$K_t = 100.0$, $a_0 = 0.0$, $a_1 = 1.0$, $a_2 = 0.01$, $z_t = 1.0$, $\\{s_{i,t}\\} = [0.10, 0.15, 0.20, 0.25, 0.30]$，以及 $\\{r_{i,t}\\} = [1.05, 1.03, 1.02, 1.01, 1.00]$。\n首先，计算 $G_t^{\\text{forecast}}$：\n$$\nG_t^{\\text{forecast}} = \\exp\\big(0.0 + (1.0 - 1.0)\\log(100.0) + 0.01 \\cdot 1.0\\big) = \\exp(0.01) \\approx 1.01005017\n$$\n接下来，计算每个五等分位数的 $c_{i,t}$：\n- $c_{1,t} = 100.0 \\cdot 0.10 \\cdot (1.05 - 1.01005017) \\approx 0.399498$\n- $c_{2,t} = 100.0 \\cdot 0.15 \\cdot (1.03 - 1.01005017) \\approx 0.299248$\n- $c_{3,t} = 100.0 \\cdot 0.20 \\cdot (1.02 - 1.01005017) \\approx 0.198997$\n- $c_{4,t} = 100.0 \\cdot 0.25 \\cdot (1.01 - 1.01005017) \\approx -0.001254$\n- $c_{5,t} = 100.0 \\cdot 0.30 \\cdot (1.00 - 1.01005017) \\approx -0.301505$\n结果列表四舍五入到六位小数后为 $[0.399498, 0.299248, 0.198997, -0.001254, -0.301505]$。\n\n**情况B：**\n给定参数：$K_t = 250.0$, $a_0 = 0.0$, $a_1 = 1.0$, $a_2 = 0.0$, $z_t = 0.0$, $\\{s_{i,t}\\} = [0.05, 0.10, 0.15, 0.30, 0.40]$，以及 $\\{r_{i,t}\\} = [1.0, 1.0, 1.0, 1.0, 1.0]$。\n首先，计算 $G_t^{\\text{forecast}}$：\n$$\nG_t^{\\text{forecast}} = \\exp\\big(0.0 + (1.0 - 1.0)\\log(250.0) + 0.0 \\cdot 0.0\\big) = \\exp(0.0) = 1.0\n$$\n由于对于所有 $i$ 都有 $r_{i,t} = 1.0$ 并且 $G_t^{\\text{forecast}} = 1.0$，因此对于所有五等分位数，$(r_{i,t} - G_t^{\\text{forecast}})$ 项恒等于零。\n因此，对于所有 $i \\in \\{1,2,3,4,5\\}$，$c_{i,t} = 0.0$。\n结果列表为 $[0.000000, 0.000000, 0.000000, 0.000000, 0.000000]$。\n\n**情况C：**\n给定参数：$K_t = 80.0$, $a_0 = 0.02$, $a_1 = 0.98$, $a_2 = -0.005$, $z_t = -1.0$, $\\{s_{i,t}\\} = [0.0, 0.20, 0.30, 0.25, 0.25]$，以及 $\\{r_{i,t}\\} = [1.04, 0.99, 1.01, 1.00, 1.02]$。\n首先，计算 $G_t^{\\text{forecast}}$：\n$$\nG_t^{\\text{forecast}} = \\exp\\big(0.02 + (0.98 - 1.0)\\log(80.0) + (-0.005) \\cdot (-1.0)\\big) = \\exp\\big(0.025 - 0.02\\log(80.0)\\big) \\approx 0.939281\n$$\n接下来，计算每个五等分位数的 $c_{i,t}$：\n- $c_{1,t} = 80.0 \\cdot 0.0 \\cdot (1.04 - 0.939281) = 0.000000$\n- $c_{2,t} = 80.0 \\cdot 0.20 \\cdot (0.99 - 0.939281) \\approx 0.811498$\n- $c_{3,t} = 80.0 \\cdot 0.30 \\cdot (1.01 - 0.939281) \\approx 1.697247$\n- $c_{4,t} = 80.0 \\cdot 0.25 \\cdot (1.00 - 0.939281) \\approx 1.214373$\n- $c_{5,t} = 80.0 \\cdot 0.25 \\cdot (1.02 - 0.939281) \\approx 1.614373$\n结果列表四舍五入到六位小数后为 $[0.000000, 0.811498, 1.697247, 1.214373, 1.614373]$。\n\n最终的程序会将这些结果整合为指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes quintile contributions to the forecast error for a heterogeneous-agent model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (K_t, a_0, a_1, a_2, z_t, {s_i,t}, {r_i,t})\n        (100.0, 0.0, 1.0, 0.01, 1.0,\n         np.array([0.10, 0.15, 0.20, 0.25, 0.30]),\n         np.array([1.05, 1.03, 1.02, 1.01, 1.00])),\n\n        # Case B: (K_t, a_0, a_1, a_2, z_t, {s_i,t}, {r_i,t})\n        (250.0, 0.0, 1.0, 0.0, 0.0,\n         np.array([0.05, 0.10, 0.15, 0.30, 0.40]),\n         np.array([1.0, 1.0, 1.0, 1.0, 1.0])),\n\n        # Case C: (K_t, a_0, a_1, a_2, z_t, {s_i,t}, {r_i,t})\n        (80.0, 0.02, 0.98, -0.005, -1.0,\n         np.array([0.0, 0.20, 0.30, 0.25, 0.25]),\n         np.array([1.04, 0.99, 1.01, 1.00, 1.02])),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Unpack parameters for the current case\n        K_t, a0, a1, a2, z_t, s_it, r_it = case\n\n        # Step 1: Compute the implied forecast gross factor, G_t^forecast.\n        # G_t^forecast = exp(a0 + (a1 - 1)*log(K_t) + a2*z_t)\n        log_K_t = np.log(K_t)\n        G_t_forecast = np.exp(a0 + (a1 - 1) * log_K_t + a2 * z_t)\n\n        # Step 2: Compute the contribution of each quintile to the forecast error.\n        # c_i,t = K_t * s_i,t * (r_i,t - G_t^forecast)\n        c_it = K_t * s_it * (r_it - G_t_forecast)\n        \n        all_results.append(c_it)\n\n    # Format the output as specified: a list of lists, with numbers rounded\n    # to six decimal places, no spaces.\n    case_results_str = []\n    for result_list in all_results:\n        # Format each number to '.6f' and join into a string \"[n1,n2,...]\"\n        formatted_numbers = [f\"{x:.6f}\" for x in result_list]\n        case_str = f\"[{','.join(formatted_numbers)}]\"\n        case_results_str.append(case_str)\n\n    # Final print statement in the exact required format.\n    # Example: [[x1,x2],[y1,y2]]\n    final_output_str = f\"[{','.join(case_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"}, {"introduction": "Krusell-Smith 框架的应用不限于仅含单一资产的简单储蓄问题。本练习 [@problem_id:2441752] 将模型扩展到一个更丰富的金融环境中，其中经济主体可以选择由多种风险资产构成的投资组合。通过实施一个需要主体预测整个预期收益向量的模拟，你将学会如何调整算法以处理多维预测问题，并探索其在资产定价中的应用。", "id": "2441752", "problem": "考虑一个离散时间经济，其中居住着单位质量的同质代理人，他们对下一期消费具有恒定绝对风险厌恶（CARA）偏好，其效用函数为 $u(c) = -\\exp(-\\gamma c)$，其中 $\\gamma > 0$ 是绝对风险厌恶系数。时间由 $t \\in \\{0,1,2,\\dots\\}$ 索引。在时间 $t$ 的总体状态是数对 $(K_t, z_t)$，其中 $K_t \\in \\mathbb{R}_{+}$ 是总体财富，$z_t \\in \\{-1, +1\\}$ 是一个总体冲击。\n\n经济中存在一种无风险资产，其总回报率为 $R_f > 1$，以及 $N \\in \\mathbb{N}$ 种风险资产。设风险资产 $i \\in \\{1,\\dots,N\\}$ 在时间 $t$ 的简单回报率为 $R_{i,t}$。风险回报向量 $\\mathbf{R}_t = (R_{1,t},\\dots,R_{N,t})^\\top$ 的条件期望为 $\\boldsymbol{\\mu}_t = \\mathbb{E}[\\mathbf{R}_t \\mid K_t, z_t]$，并拥有一个时不变的对角协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1^2,\\dots,\\sigma_N^2)$，其中对所有 $i$ 都有 $\\sigma_i > 0$。假设条件期望具有以下线性状态依赖结构，并服从正态冲击结构：\n- 对于每种风险资产 $i$，其条件期望为\n$$\n\\mu_{i}(K_t,z_t) \\equiv \\mathbb{E}[R_{i,t} \\mid K_t, z_t] \\;=\\; \\alpha_i + b_i \\log(K_t) + c_i z_t,\n$$\n其中 $\\alpha_i \\in \\mathbb{R}$，$b_i \\in \\mathbb{R}$ 和 $c_i \\in \\mathbb{R}$ 是常数。\n- 已实现的风险回报满足\n$$\nR_{i,t} \\;=\\; \\mu_{i}(K_t,z_t) + \\varepsilon_{i,t},\n$$\n其中 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0,\\sigma_i^2)$ 在 $i$ 和 $t$ 上独立，并且与 $(K_t,z_t)$ 独立。\n\n总体冲击 $z_t$ 遵循一个由下式定义的两状态马尔可夫链\n$$\n\\mathbb{P}(z_{t+1} = z_t \\mid z_t) \\;=\\; p, \\quad \\mathbb{P}(z_{t+1} = -z_t \\mid z_t) \\;=\\; 1-p,\n$$\n其中 $p \\in (0,1)$ 是常数。\n\n每个代理人进入时期 $t$ 时拥有财富 $W_t = K_t$，选择一个风险资产的美元头寸向量 $\\boldsymbol{\\theta}_t \\in \\mathbb{R}^N$，并将其余财富 $W_t - \\mathbf{1}^\\top \\boldsymbol{\\theta}_t$ 投资于无风险资产，其中 $\\mathbf{1}$ 是元素全为1的向量。下一期的财富为\n$$\nW_{t+1} \\;=\\; \\boldsymbol{\\theta}_t^\\top \\mathbf{R}_t \\;+\\; \\left(W_t - \\mathbf{1}^\\top \\boldsymbol{\\theta}_t\\right) R_f \\;=\\; W_t R_f \\;+\\; \\boldsymbol{\\theta}_t^\\top \\left(\\mathbf{R}_t - R_f \\mathbf{1}\\right).\n$$\n代理人选择 $\\boldsymbol{\\theta}_t$ 以最大化 $\\mathbb{E}\\left[ u(W_{t+1}) \\mid K_t, z_t, W_t \\right]$。\n\n给定 CARA-正态结构，最优风险资产美元需求为\n$$\n\\boldsymbol{\\theta}_t^\\ast \\;=\\; \\frac{1}{\\gamma} \\boldsymbol{\\Sigma}^{-1} \\left( \\boldsymbol{\\mu}_t - R_f \\mathbf{1} \\right),\n$$\n该需求与 $W_t$ 无关。\n\n将预期回报向量的预测法则定义为映射\n$$\n\\mathbf{f}(K_t,z_t) \\;=\\; \\big(a_1 + b_1^{(f)} \\log K_t + c_1^{(f)} z_t,\\;\\dots,\\;a_N + b_N^{(f)} \\log K_t + c_N^{(f)} z_t \\big)^\\top,\n$$\n其中未知系数 $(a_i, b_i^{(f)}, c_i^{(f)})$ 对每种资产 $i$ 都有待确定。\n\n任务。对于下面测试套件中的每个参数集，执行以下操作：\n1. 从给定的初始状态 $(K_0, z_0)$ 开始，使用最优需求 $\\boldsymbol{\\theta}_t^\\ast$ 和上述指定的数据生成过程，模拟经济的一条路径 $\\{(K_t, z_t, \\mathbf{R}_t)\\}_{t=0}^{T-1}$。在回报过程中使用真实的条件期望参数 $(\\alpha_i, b_i, c_i)$。在每个时间 $t$，为每种资产 $i$ 记录三元组 $(\\log K_t, z_t, R_{i,t})$。\n2. 对每种资产 $i$，确定使离差平方和最小的系数三元组 $(\\widehat{a}_i, \\widehat{b}_i, \\widehat{c}_i)$：\n$$\n\\sum_{t=B}^{T-1} \\left( R_{i,t} - a_i - b_i \\log K_t - c_i z_t \\right)^2,\n$$\n其中 $B \\in \\mathbb{N}$ 是一个要舍弃的预烧期。\n3. 对每个参数集，报告估计系数的连接列表 $(\\widehat{a}_1,\\widehat{b}_1,\\widehat{c}_1,\\dots,\\widehat{a}_N,\\widehat{b}_N,\\widehat{c}_N)$。\n\n所有标量值都应表示为小数。没有物理单位。不涉及角度。不要使用百分号。\n\n测试套件。对于每种情况，使用指定参数和固定的随机种子进行单路径模拟。在所有情况下，都使用对角协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1^2,\\dots,\\sigma_N^2)$ 并舍弃 $B$ 个初始观测值。\n\n- 情况 A (基准, $N=2$):\n    - $N = 2$, $R_f = 1.01$, $\\gamma = 5.0$, $p = 0.9$, $T = 400$, $B = 50$, $K_0 = 100.0$, $z_0 = +1$。\n    - $(\\alpha_1,\\alpha_2) = (1.03, 1.015)$。\n    - $(b_1,b_2) = (-0.02, 0.01)$。\n    - $(c_1,c_2) = (0.01, 0.02)$。\n    - $(\\sigma_1,\\sigma_2) = (0.02, 0.03)$。\n    - 随机种子 $= 123$。\n\n- 情况 B (三种资产，其中一种资产与 $\\log K_t$ 无关，另一种与 $z_t$ 无关, $N=3$):\n    - $N = 3$, $R_f = 1.005$, $\\gamma = 3.0$, $p = 0.6$, $T = 400$, $B = 50$, $K_0 = 80.0$, $z_0 = +1$。\n    - $(\\alpha_1,\\alpha_2,\\alpha_3) = (1.02, 1.025, 1.015)$。\n    - $(b_1,b_2,b_3) = (0.0, -0.015, 0.02)$。\n    - $(c_1,c_2,c_3) = (0.015, 0.0, -0.01)$。\n    - $(\\sigma_1,\\sigma_2,\\sigma_3) = (0.025, 0.02, 0.03)$。\n    - 随机种子 $= 456$。\n\n- 情况 C (边界情况，风险厌恶程度非常高，且两种资产均不依赖于 $z_t$, $N=2$):\n    - $N = 2$, $R_f = 1.008$, $\\gamma = 50.0$, $p = 0.5$, $T = 400$, $B = 50$, $K_0 = 120.0$, $z_0 = +1$。\n    - $(\\alpha_1,\\alpha_2) = (1.015, 1.02)$。\n    - $(b_1,b_2) = (0.005, -0.005)$。\n    - $(c_1,c_2) = (0.0, 0.0)$。\n    - $(\\sigma_1,\\sigma_2) = (0.015, 0.015)$。\n    - 随机种子 $= 789$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。通过按顺序连接情况 A、情况 B、然后是情况 C 的估计系数来构建此行。在每个情况内部，按 $(\\widehat{a}_1,\\widehat{b}_1,\\widehat{c}_1,\\dots,\\widehat{a}_N,\\widehat{b}_N,\\widehat{c}_N)$ 的顺序列出。每个系数必须四舍五入到小数点后六位。例如，输出必须看起来像\n$[\\widehat{a}_1,\\widehat{b}_1,\\widehat{c}_1,\\dots,\\widehat{a}_N,\\widehat{b}_N,\\widehat{c}_N,\\dots,\\text{情况B的系数},\\dots,\\text{情况C的系数}]$。", "solution": "该问题是有效且适定的。这是计算经济学中的一个标准练习，涉及模拟一个宏观经济模型并执行统计估计。任务分为两个主要部分：首先，基于真实的数据生成过程，模拟经济的动态路径；其次，使用模拟数据估计预期资产回报预测规则的参数。这个过程类似于 Krusell-Smith 算法中学习过程的一次迭代，其中代理人更新他们对总体变量运动法则的信念。\n\n解决方案按以下步骤进行。对于每个给定的参数集，我们执行一个两阶段程序。\n\n**阶段 1：模拟**\n\n我们模拟经济在 $T$ 个时期内的一条路径。在时间 $t$ 的经济状态由数对 $(K_t, z_t)$ 描述，分别代表总体财富和总体冲击。\n\n1.  **初始化**：模拟从 $t=0$ 开始，使用给定的初始状态 $(K_0, z_0)$ 和指定的随机种子以确保可复现性。我们将记录 $t \\in \\{0, 1, \\dots, T-1\\}$ 期间 $(\\log K_t, z_t, \\mathbf{R}_t)$ 的时间序列。\n\n2.  **状态演化**：对于从 $0$ 到 $T-1$ 的每个时期 $t$，给定当前状态 $(K_t, z_t)$：\n    \n    a.  **条件预期回报**：根据真实的运动法则，计算每种资产 $i \\in \\{1,\\dots,N\\}$ 的条件预期回报向量 $\\boldsymbol{\\mu}_t$：\n        $$\n        \\mu_{i,t} = \\alpha_i + b_i \\log(K_t) + c_i z_t\n        $$\n    \n    b.  **最优投资组合选择**：代表性代理人对 $N$ 种风险资产的最优美元配置 $\\boldsymbol{\\theta}_t^*$ 由具有正态分布回报的 CARA 效用的一阶条件确定：\n        $$\n        \\boldsymbol{\\theta}_t^* = \\frac{1}{\\gamma} \\boldsymbol{\\Sigma}^{-1} (\\boldsymbol{\\mu}_t - R_f \\mathbf{1})\n        $$\n        由于协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1^2, \\dots, \\sigma_N^2)$ 是对角矩阵，其逆矩阵为 $\\boldsymbol{\\Sigma}^{-1} = \\mathrm{diag}(1/\\sigma_1^2, \\dots, 1/\\sigma_N^2)$。因此，每种资产 $i$ 的配置为：\n        $$\n        \\theta_{i,t}^* = \\frac{1}{\\gamma \\sigma_i^2} (\\mu_{i,t} - R_f)\n        $$\n    \n    c.  **已实现的回报**：通过向条件期望中添加随机冲击来生成已实现的回报 $\\mathbf{R}_t$。对每种资产 $i$，我们抽取一个独立的冲击 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0, \\sigma_i^2)$，已实现的回报为：\n        $$\n        R_{i,t} = \\mu_{i,t} + \\varepsilon_{i,t}\n        $$\n\n    d.  **财富与冲击更新**：确定下一时期的状态变量 $(K_{t+1}, z_{t+1})$。\n        -   总体财富根据代表性代理人的预算约束演化：\n            $$\n            K_{t+1} = W_{t+1} = K_t R_f + (\\boldsymbol{\\theta}_t^*)^\\top (\\mathbf{R}_t - R_f \\mathbf{1})\n            $$\n        -   总体冲击 $z_t$ 根据指定的两状态马尔可夫链进行转移。我们抽取一个随机变量 $u \\sim U(0,1)$。如果 $u < p$，则 $z_{t+1} = z_t$；否则，$z_{t+1} = -z_t$。\n\n模拟循环重复 $T$ 次以生成完整的时间序列。\n\n**阶段 2：估计**\n\n生成数据后，我们估计代理人对预期回报的线性预测规则的系数。对于每种资产 $i \\in \\{1, \\dots, N\\}$，我们要找到使残差平方和最小的系数三元组 $(\\widehat{a}_i, \\widehat{b}_i, \\widehat{c}_i)$：\n$$\n\\sum_{t=B}^{T-1} (R_{i,t} - a_i - b_i \\log K_t - c_i z_t)^2\n$$\n这是一个标准的普通最小二乘法（OLS）问题。最初的 $B$ 个观测值被舍弃，以减轻初始条件的影响。\n\n1.  **数据准备**：对于每种资产 $i$，因变量是已实现回报的向量 $\\mathbf{y}_i = (R_{i,B}, \\dots, R_{i,T-1})^\\top$。自变量被组织成一个大小为 $(T-B) \\times 3$ 的设计矩阵 $\\mathbf{X}$，其中第 $j$ 行（对应于时间 $t = B+j-1$）是 $[1, \\log K_t, z_t]$。\n\n2.  **OLS 估计**：通过求解正规方程来找到估计系数的向量 $\\boldsymbol{\\beta}_i = (\\widehat{a}_i, \\widehat{b}_i, \\widehat{c}_i)^\\top$：\n    $$\n    \\widehat{\\boldsymbol{\\beta}}_i = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}_i\n    $$\n    在数值上，这是使用标准的线性最小二乘法求解器实现的。\n\n对每个测试案例中的每种资产执行此过程。然后将得到的系数向量连接起来并按要求格式化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through each case, runs the simulation and estimation,\n    collects the results, and prints them in the specified format.\n    \"\"\"\n\n    def run_case(params):\n        \"\"\"\n        Runs the simulation and OLS estimation for a single parameter set.\n\n        Args:\n            params (tuple): A tuple containing all parameters for a single case.\n\n        Returns:\n            list: A flat list of estimated coefficients (a_i, b_i, c_i) for all assets.\n        \"\"\"\n        (N, R_f, gamma, p, T, B, K_0, z_0, \n         alphas, bs, cs, sigmas, seed) = params\n        \n        # Initialize random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Arrays to store time series data\n        logK_series = np.zeros(T)\n        z_series = np.zeros(T)\n        R_series = np.zeros((N, T))\n\n        # Initial state\n        K_current = K_0\n        z_current = z_0\n        \n        # Pre-calculate constants that do not change in the loop\n        sigma_sq_inv = 1 / (sigmas**2)\n        ones_vec = np.ones(N)\n\n        # Simulation loop for T periods\n        for t in range(T):\n            logK_current = np.log(K_current)\n            \n            # Store current log-capital and shock state\n            logK_series[t] = logK_current\n            z_series[t] = z_current\n\n            # 1. Calculate conditional expected returns mu_t\n            # mu_i(K_t, z_t) = alpha_i + b_i * log(K_t) + c_i * z_t\n            mu_t = alphas + bs * logK_current + cs * z_current\n\n            # 2. Calculate optimal risky asset holdings theta_t\n            # theta_t* = (1/gamma) * Sigma^-1 * (mu_t - R_f * 1)\n            theta_t = (1 / gamma) * sigma_sq_inv * (mu_t - R_f * ones_vec)\n\n            # 3. Generate realized returns R_t\n            # R_i,t = mu_i,t + epsilon_i,t where epsilon_i,t ~ N(0, sigma_i^2)\n            epsilons = rng.normal(0, sigmas)\n            R_t = mu_t + epsilons\n            R_series[:, t] = R_t\n            \n            # 4. Update aggregate wealth to K_{t+1}\n            # K_{t+1} = K_t * R_f + theta_t' * (R_t - R_f * 1)\n            excess_returns = R_t - R_f * ones_vec\n            K_next = K_current * R_f + np.dot(theta_t, excess_returns)\n            K_current = K_next\n\n            # 5. Update aggregate shock z_{t+1}\n            if rng.uniform(0, 1) < p:\n                z_next = z_current\n            else:\n                z_next = -z_current\n            z_current = z_next\n\n        # Perform OLS estimation\n        # Discard the first B (burn-in) observations\n        num_obs = T - B\n        \n        # Construct the design matrix X = [1, logK, z]\n        X = np.ones((num_obs, 3))\n        X[:, 1] = logK_series[B:T]\n        X[:, 2] = z_series[B:T]\n\n        all_coeffs = []\n        for i in range(N):\n            # The dependent variable y_i is the time series of returns for asset i\n            y_i = R_series[i, B:T]\n            \n            # Solve the least squares problem: X * beta = y_i\n            # numpy.linalg.lstsq returns (coefficients, residuals, rank, singular_values)\n            coeffs = np.linalg.lstsq(X, y_i, rcond=None)[0]\n            all_coeffs.extend(coeffs.tolist())\n        \n        return all_coeffs\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (baseline, N=2)\n        (\n            2, 1.01, 5.0, 0.9, 400, 50, 100.0, 1,\n            np.array([1.03, 1.015]), np.array([-0.02, 0.01]),\n            np.array([0.01, 0.02]), np.array([0.02, 0.03]),\n            123\n        ),\n        # Case B (three assets with one asset independent of logK and one of z, N=3)\n        (\n            3, 1.005, 3.0, 0.6, 400, 50, 80.0, 1,\n            np.array([1.02, 1.025, 1.015]), np.array([0.0, -0.015, 0.02]),\n            np.array([0.015, 0.0, -0.01]), np.array([0.025, 0.02, 0.03]),\n            456\n        ),\n        # Case C (boundary with high risk aversion, N=2)\n        (\n            2, 1.008, 50.0, 0.5, 400, 50, 120.0, 1,\n            np.array([1.015, 1.02]), np.array([0.005, -0.005]),\n            np.array([0.0, 0.0]), np.array([0.015, 0.015]),\n            789\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = run_case(case)\n        results.extend(case_results)\n\n    # Format and print the final results as a single comma-separated list\n    # enclosed in square brackets, with each number rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "Krusell-Smith 算法的标准实现通常假设一个简单的线性预测规则，但这可能无法捕捉复杂的非线性经济动态。这项高级练习 [@problem_id:2441747] 挑战你超越这一假设，通过使用高斯过程（Gaussian Process）实现一个灵活的非参数预测器。通过在各种合成数据集上将其性能与标准线性模型进行比较，你将对计算宏观经济学的前沿以及预测模型设定的关键作用获得宝贵的见解。", "id": "2441747", "problem": "考虑一个以总量资本为状态变量的异质性代理人经济体。在 Krusell–Smith 算法中，代理人通过一个预测规则来近似下一期总量资本的未知总量运动规律。令 $t$ 时刻的总量状态为 $s_t = (K_t, z_t)$，其中 $K_t \\in \\mathbb{R}_+$ 是总量资本，$z_t \\in \\{0,1\\}$ 是一个遵循两状态马尔可夫链的总量生产率机制。未知的总量运动规律是一个可测函数 $G:\\mathbb{R}_+ \\times \\{0,1\\} \\to \\mathbb{R}_+$，使得 $K_{t+1} = G(K_t, z_t) + \\varepsilon_t$，其中 $\\varepsilon_t$ 是一个均值为零、方差有限的独立同分布新息。\n\n您将研究一个基于高斯过程（GP）的非参数预测规则，相对于经典 Krusell–Smith 算法中使用的线性普通最小二乘法（OLS）基准，是否能在 $G$ 中发现非线性或机制转换的总量动态。您必须从基本原理出发实现这两种预测器，并在由四个明确指定的数据生成过程（DGP）为 $G$ 生成的合成数据上对它们进行评估。您的程序必须输出一个布尔值列表，每个 DGP 对应一个布尔值，用于指示 GP 是否既提高了样本外预测准确性，又在 $K_t$到 $K_{t+1}$ 的隐含映射中揭示了非线性曲率或依赖于机制的斜率。\n\n基础理论：\n- 在 Krusell–Smith 算法中，代理人通过预测规则 $F(K_t, z_t)$ 形成对 $K_{t+1}$ 的预期，并不断更新此规则，直到它与模拟的总量结果一致。OLS 基准使用线性设定。结合了平方指数核的高斯过程先验产生了一个非参数后验均值预测器，该预测器在由核诱导的函数空间中最小化均方误差。\n- 普通最小二乘法（OLS）选择系数以最小化残差平方和。具有零均值先验和正定核 $k(\\cdot,\\cdot)$ 的高斯过程（GP）回归，对于训练输入 $X \\in \\mathbb{R}^{n \\times d}$ 和目标 $y \\in \\mathbb{R}^n$，在新输入 $x_\\star$ 处的后验均值为 $m(x_\\star) = k(x_\\star, X)\\left[K(X,X)+\\sigma_n^2 I\\right]^{-1}y$，其中 $K(X,X)$ 是 Gram 矩阵，其元素为 $k(x_i,x_j)$，$\\sigma_n^2$ 是观测噪声方差，$I$ 是单位矩阵。\n\n您的任务：\n- 通过模拟 $T$ 个时期的 $(K_t, z_t)$ 来生成数据，其中 $K_{t+1} = \\min\\{\\max\\{G(K_t, z_t) + \\varepsilon_t, K_{\\min}\\}, K_{\\max}\\}$，$K_{\\min} = 2$ 和 $K_{\\max} = 18$ 是为确保数值稳定性而设的裁剪边界。总量冲击 $z_t$ 是一个两状态马尔可夫链，转移概率为 $p_{00} = \\mathbb{P}(z_{t+1}=0 \\mid z_t=0) = 0.9$ 和 $p_{11} = \\mathbb{P}(z_{t+1}=1 \\mid z_t=1) = 0.9$，且 $p_{01} = 1 - p_{00}$，$p_{10} = 1 - p_{11}$。在 $K_0 = 8$ 和 $z_0 = 1$ 处初始化。从 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma_\\varepsilon^2)$ 中抽取。\n- 将模拟样本分割成大小为 $T_{\\text{train}}$ 的训练集和大小为 $T_{\\text{test}}$ 的测试集（时间上连续）。在训练集上拟合两个预测规则：\n  - 一个线性 OLS 预测器 $F_{\\text{lin}}(K,z) = \\beta_0 + \\beta_1 K + \\beta_2 z$，其系数通过最小化训练均方误差来估计。\n  - 一个具有零均值先验和平方指数核的 GP 预测器\n    $$k(x,x') = \\sigma_f^2 \\exp\\left(-\\tfrac{1}{2}\\sum_{j=1}^2 \\left(\\frac{x_j - x'_j}{\\ell_j}\\right)^2\\right),$$\n    其中 $x = [K, z]^\\top$，超参数固定为 $\\sigma_f = 1$，$K$ 维度的 $\\ell_1 = 2.5$，$z$ 维度的 $\\ell_2 = 0.5$，以及观测噪声标准差 $\\sigma_n = 0.05$。在训练和测试输入上都使用 GP 后验均值预测器。\n- 计算测试集上的样本外均方误差：\n  $$\\text{MSE}_{\\text{lin}} = \\frac{1}{T_{\\text{test}}}\\sum_{t=1}^{T_{\\text{test}}} \\left(K_{t+1}^{\\text{test}} - F_{\\text{lin}}(K_t^{\\text{test}}, z_t^{\\text{test}})\\right)^2,$$\n  $$\\text{MSE}_{\\text{gp}} = \\frac{1}{T_{\\text{test}}}\\sum_{t=1}^{T_{\\text{test}}} \\left(K_{t+1}^{\\text{test}} - F_{\\text{gp}}(K_t^{\\text{test}}, z_t^{\\text{test}})\\right)^2,$$\n  以及相对改进\n  $$\\Delta = \\frac{\\text{MSE}_{\\text{lin}} - \\text{MSE}_{\\text{gp}}}{\\text{MSE}_{\\text{lin}}}.$$\n- 通过在 $[K_{\\min}, K_{\\max}]$ 上一个包含 $N = 50$ 个点的均匀网格 $\\{K_i\\}_{i=1}^N$ 上评估 GP 预测器来诊断非线性和机制依赖性，步长为 $h = (K_{\\max}-K_{\\min})/(N-1)$。对于每个机制 $z \\in \\{0,1\\}$：\n  - 计算离散二阶导数\n    $$D^{(2)}_i(z) = \\frac{F_{\\text{gp}}(K_{i+1}, z) - 2 F_{\\text{gp}}(K_i, z) + F_{\\text{gp}}(K_{i-1}, z)}{h^2}, \\quad i = 2,\\dots, N-1,$$\n    并定义曲率度量 $C = \\max_{z \\in \\{0,1\\}}\\max_{2 \\le i \\le N-1} \\left|D^{(2)}_i(z)\\right|$。\n  - 计算离散一阶导数\n    $$D^{(1)}_i(z) = \\frac{F_{\\text{gp}}(K_{i+1}, z) - F_{\\text{gp}}(K_{i-1}, z)}{2 h}, \\quad i = 2,\\dots, N-1,$$\n    并定义依赖于机制的斜率差距 $S = \\max_{2 \\le i \\le N-1} \\left|D^{(1)}_i(1) - D^{(1)}_i(0)\\right|.$\n- 决策规则：当且仅当 $\\Delta \\ge \\tau_\\Delta$ 并且 $C \\ge \\tau_C$ 或 $S \\ge \\tau_S$ 时，宣布非参数预测规则“发现了一个非线性或机制转换的总量动态”，阈值为 $\\tau_\\Delta = 0.05$，$\\tau_C = 0.002$ 和 $\\tau_S = 0.05$。\n\n测试套件：\n- 使用以下四个 $G(K,z)$ 的 DGP、模拟长度和噪声水平。所有常数和系数均为实数。\n  1. 案例 L (线性“理想路径”)：$G(K,z) = a_0 + a_1 K + a_2 z$，$a_0 = 0.5$，$a_1 = 0.92$，$a_2 = 0.1$，新息标准差 $\\sigma_\\varepsilon = 0.03$，$T_{\\text{train}} = 200$，$T_{\\text{test}} = 400$。\n  2. 案例 N (凹非线性)：$G(K,z) = a_0 + a_1 K + a_3 K^2 + a_2 z$，$a_0 = 0.5$，$a_1 = 0.95$，$a_3 = -0.002$，$a_2 = 0.1$，$\\sigma_\\varepsilon = 0.03$，$T_{\\text{train}} = 200$，$T_{\\text{test}} = 400$。\n  3. 案例 R (机制转换斜率)：$G(K,z) = a_0 + (a_1 + a_4 z) K + a_2 z$，$a_0 = 0.5$，$a_1 = 0.90$，$a_4 = 0.10$，$a_2 = 0.1$，$\\sigma_\\varepsilon = 0.03$，$T_{\\text{train}} = 200$，$T_{\\text{test}} = 400$。\n  4. 案例 B (边界/高噪声线性)：与案例 L 相同，但 $\\sigma_\\varepsilon = 0.50$，$T_{\\text{train}} = 150$，$T_{\\text{test}} = 300$。\n\n实现细节：\n- 使用固定的随机种子以确保可复现性。\n- 仅在回归量 $[1, K, z]$上拟合 OLS。不要在 OLS 基准中包含交互项。\n- 使用具有指定固定超参数 $\\sigma_f = 1$，$\\ell_1 = 2.5$，$\\ell_2 = 0.5$ 和 $\\sigma_n = 0.05$ 的 GP 后验均值。\n\n您的程序应生成单行输出，其中包含与案例 L、N、R 和 B 相对应的四个布尔结果，按此顺序排列，形式为逗号分隔的列表并用方括号括起（例如，“[False,True,True,False]”）。不允许有其他输出。", "solution": "目标是在 Krusell-Smith 风格的宏观经济模型背景下，评估和比较一个线性普通最小二乘法（OLS）预测规则与一个非参数高斯过程（GP）预测规则的性能。该比较基于样本外预测准确性以及预测器在资本总量运动规律中检测特定动态特征的能力，即非线性曲率和机制转换斜率。\n\n该方法涉及一系列计算实验。对于四个不同的数据生成过程（DGP）中的每一个，我们首先模拟总量资本 $K_t$ 和总量生产率冲击 $z_t$ 的时间序列。然后将此模拟数据划分为一个训练集和一个后续的测试集。OLS 和 GP 模型都用训练数据进行拟合。然后，在测试集上评估它们的预测性能。最后，分析拟合的 GP 模型以诊断其学习到的函数形式的非线性和机制依赖性。一个综合规则根据预测改进和结构特征检测的阈值，来确定 GP 是否成功“发现”了潜在的动态。\n\n令总量状态为 $s_t = (K_t, z_t)$，其中 $K_t \\in \\mathbb{R}_+$ 是总量资本，$z_t \\in \\{0,1\\}$ 是一个生产率冲击。冲击 $z_t$ 遵循一个两状态对称马尔可夫链，其转移矩阵为\n$$ P = \\begin{pmatrix} p_{00} & p_{01} \\\\ p_{10} & p_{11} \\end{pmatrix} = \\begin{pmatrix} 0.9 & 0.1 \\\\ 0.1 & 0.9 \\end{pmatrix} $$\n总量资本的数据根据以下运动规律顺序生成\n$$ K_{t+1} = \\min \\{ \\max \\{ G(K_t, z_t) + \\varepsilon_t, K_{\\min} \\}, K_{\\max} \\} $$\n其中 $G(K_t, z_t)$ 是特定的 DGP，$\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma_\\varepsilon^2)$ 是一个高斯新息，$K_{\\min}=2$ 和 $K_{\\max}=18$ 是反射边界。我们模拟一个总长度为 $T = T_{\\text{train}} + T_{\\text{test}}$ 的时间序列，从初始条件 $K_0 = 8$ 和 $z_0 = 1$ 开始。$(K_t, z_t, K_{t+1})$ 的前 $T_{\\text{train}}$ 个观测值构成训练集，随后的 $T_{\\text{test}}$ 个观测值构成测试集。\n\n我们指定并拟合两个预测模型：\n\n1.  **线性 OLS 预测器**：预测规则被假定为在资本和冲击指示变量上是线性的，\n    $$ F_{\\text{lin}}(K, z) = \\beta_0 + \\beta_1 K + \\beta_2 z $$\n    系数向量 $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2]^\\top$ 使用训练数据 $\\{(K_t, z_t), K_{t+1}\\}_{t=0}^{T_{\\text{train}}-1}$ 通过 OLS 进行估计。这通过求解标准正规方程 $\\boldsymbol{\\beta} = (X^\\top X)^{-1} X^\\top \\mathbf{y}$ 实现，其中 $X$ 是设计矩阵，行向量为 $[1, K_t, z_t]$，$\\mathbf{y}$ 是目标值 $K_{t+1}$ 的向量。\n\n2.  **高斯过程 (GP) 预测器**：这种非参数方法将未知函数 $G$ 建模为从一个 GP 先验中的一次抽样。后验预测均值提供了预测 $F_{\\text{gp}}(K,z)$。使用零均值先验和平方指数核，在新输入 $x_\\star = [K_\\star, z_\\star]^\\top$ 处的预测由下式给出\n    $$ F_{\\text{gp}}(x_\\star) = \\mathbf{k}(x_\\star, X)^\\top [ \\mathbf{K}(X,X) + \\sigma_n^2 I ]^{-1} \\mathbf{y} $$\n    其中 $X$ 和 $\\mathbf{y}$ 分别是训练输入和目标。核函数是\n    $$ k(x, x') = \\sigma_f^2 \\exp\\left(-\\frac{1}{2}\\sum_{j=1}^{2} \\left(\\frac{x_j - x'_j}{\\ell_j}\\right)^2\\right) $$\n    具有固定的超参数：振幅 $\\sigma_f=1$，资本的长度尺度 $\\ell_1=2.5$，冲击的长度尺度 $\\ell_2=0.5$，以及观测噪声标准差 $\\sigma_n=0.05$。$\\mathbf{K}(X,X)$ 是所有训练输入对之间核函数值的 Gram 矩阵，$\\mathbf{k}(x_\\star, X)$ 是测试点 $x_\\star$ 和每个训练输入之间核函数值的向量。\n\n评估分两个阶段进行。首先，我们通过计算两个模型的均方误差（MSE）来衡量在测试集上的预测准确性，记为 $\\text{MSE}_{\\text{lin}}$ 和 $\\text{MSE}_{\\text{gp}}$。GP 相对于 OLS 的相对改进由 $\\Delta = (\\text{MSE}_{\\text{lin}} - \\text{MSE}_{\\text{gp}}) / \\text{MSE}_{\\text{lin}}$ 量化。\n\n其次，我们通过在从 $K_{\\min}$ 到 $K_{\\max}$ 的一个包含 $N=50$ 个点的精细资本水平网格 $\\{K_i\\}_{i=1}^{N}$ 上，针对每个机制 $z \\in \\{0,1\\}$ 评估学习到的 GP 函数 $F_{\\text{gp}}$ 的结构。我们使用中心有限差分来近似导数。\n-   曲率由 $C = \\max_{z, i} |D_i^{(2)}(z)|$ 衡量，其中 $D_i^{(2)}(z)$ 是 $F_{\\text{gp}}$ 在机制 $z$ 下关于 $K$ 在网格点 $K_i$ 处的二阶导数。一个大的 $C$ 值表示显著的非线性。\n-   依赖于机制的斜率差距由 $S = \\max_i |D_i^{(1)}(1) - D_i^{(1)}(0)|$ 衡量，其中 $D_i^{(1)}(z)$ 是 $F_{\\text{gp}}$ 关于 $K$ 的一阶导数（斜率）。一个大的 $S$ 值表示资本的边际效应（MEC）依赖于总量冲击 $z$，这是机制转换模型中的一个特征。\n\n最终的决策规则是，当且仅当其预测改进和其检测到的结构特征都超过指定阈值时，GP“发现了一个非线性或机制转换的总量动态”：$\\Delta \\ge \\tau_\\Delta=0.05$ 并且 ($C \\ge \\tau_C=0.002$ 或 $S \\ge \\tau_S=0.05$)。整个过程对对应于线性、非线性、机制转换和高噪声线性情况的四个不同 DGP 执行。", "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of simulations.\n    np.random.seed(42)\n\n    # Define the four test cases as per the problem statement.\n    test_cases = [\n        {\n            'name': 'L',\n            'dgp': lambda K, z: 0.5 + 0.92 * K + 0.1 * z,\n            'sigma_eps': 0.03, 'T_train': 200, 'T_test': 400\n        },\n        {\n            'name': 'N',\n            'dgp': lambda K, z: 0.5 + 0.95 * K - 0.002 * K**2 + 0.1 * z,\n            'sigma_eps': 0.03, 'T_train': 200, 'T_test': 400\n        },\n        {\n            'name': 'R',\n            'dgp': lambda K, z: 0.5 + (0.90 + 0.10 * z) * K + 0.1 * z,\n            'sigma_eps': 0.03, 'T_train': 200, 'T_test': 400\n        },\n        {\n            'name': 'B',\n            'dgp': lambda K, z: 0.5 + 0.92 * K + 0.1 * z,\n            'sigma_eps': 0.50, 'T_train': 150, 'T_test': 300\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Simulate data according to the DGP and parameters for the case.\n        K, z = simulate_data(case['dgp'], case['T_train'], case['T_test'], case['sigma_eps'])\n        \n        # 2. Split the simulated data into training and test sets.\n        T_total = case['T_train'] + case['T_test']\n        X_train = np.vstack((K[:case['T_train']], z[:case['T_train']])).T\n        y_train = K[1:case['T_train'] + 1]\n        \n        X_test = np.vstack((K[case['T_train']:T_total], z[case['T_train']:T_total])).T\n        y_test = K[case['T_train'] + 1:T_total + 1]\n\n        # 3. Fit the OLS forecaster and predict on the test set.\n        y_pred_ols = fit_predict_ols(X_train, y_train, X_test)\n\n        # 4. Fit the GP forecaster and predict on the test set.\n        gp_params = {'sigma_f': 1.0, 'l1': 2.5, 'l2': 0.5, 'sigma_n': 0.05}\n        alpha, X_train_fit = fit_gp(X_train, y_train, gp_params)\n        y_pred_gp = predict_gp(X_test, X_train_fit, alpha, gp_params)\n\n        # 5. Calculate the evaluation and diagnostic metrics.\n        delta, C, S = calculate_metrics(y_test, y_pred_ols, y_pred_gp, X_train_fit, alpha, gp_params)\n\n        # 6. Apply the decision rule to determine the outcome for the case.\n        tau_delta, tau_C, tau_S = 0.05, 0.002, 0.05\n        decision = (delta >= tau_delta) and ((C >= tau_C) or (S >= tau_S))\n        results.append(decision)\n\n    # Print the final list of boolean results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_data(dgp_func, T_train, T_test, sigma_eps):\n    \"\"\"\n    Simulates time series for aggregate capital (K) and productivity shock (z).\n    \"\"\"\n    K_min, K_max = 2.0, 18.0\n    p00, p11 = 0.9, 0.9\n    K0, z0 = 8.0, 1.0\n    T_total = T_train + T_test\n    \n    K = np.zeros(T_total + 1)\n    z = np.zeros(T_total)\n    \n    K[0] = K0\n    current_z = z0\n    \n    for t in range(T_total):\n        z[t] = current_z\n        \n        # Evolve the Markov state for the shock z.\n        rand_val = np.random.rand()\n        if current_z == 0:\n            next_z = 0 if rand_val < p00 else 1\n        else:\n            next_z = 1 if rand_val < p11 else 0\n        \n        # Evolve the aggregate capital K.\n        Gt = dgp_func(K[t], z[t])\n        epsilon_t = np.random.normal(0, sigma_eps)\n        K[t+1] = np.clip(Gt + epsilon_t, K_min, K_max)\n        \n        current_z = next_z\n        \n    return K, z\n\ndef fit_predict_ols(X_train, y_train, X_test):\n    \"\"\"\n    Fits a linear OLS model and makes predictions.\n    \"\"\"\n    # Add a constant term (intercept) to the design matrices.\n    X_train_ols = np.hstack([np.ones((X_train.shape[0], 1)), X_train])\n    X_test_ols = np.hstack([np.ones((X_test.shape[0], 1)), X_test])\n    \n    # Fit OLS coefficients using np.linalg.lstsq for numerical stability.\n    beta, _, _, _ = np.linalg.lstsq(X_train_ols, y_train, rcond=None)\n    \n    # Predict on the test set.\n    y_pred = X_test_ols @ beta\n    return y_pred\n\ndef squared_exponential_kernel(X1, X2, sigma_f, l1, l2):\n    \"\"\"\n    Computes the squared-exponential kernel matrix between two sets of points.\n    \"\"\"\n    length_scales = np.array([l1, l2])\n    X1_scaled = X1 / length_scales\n    X2_scaled = X2 / length_scales\n    \n    # Use scipy's cdist for efficient computation of pairwise squared Euclidean distances.\n    sq_dist = cdist(X1_scaled, X2_scaled, 'sqeuclidean')\n    \n    return sigma_f**2 * np.exp(-0.5 * sq_dist)\n\ndef fit_gp(X_train, y_train, gp_params):\n    \"\"\"\n    Fits a Gaussian Process model.\n    This involves computing the alpha vector for making future predictions.\n    \"\"\"\n    sigma_f = gp_params['sigma_f']\n    l1 = gp_params['l1']\n    l2 = gp_params['l2']\n    sigma_n = gp_params['sigma_n']\n    \n    K_train = squared_exponential_kernel(X_train, X_train, sigma_f, l1, l2)\n    K_noisy = K_train + sigma_n**2 * np.identity(X_train.shape[0])\n    \n    # Solve (K + sigma_n^2 * I) * alpha = y to find alpha.\n    # np.linalg.solve is preferred over inverting the matrix.\n    alpha = np.linalg.solve(K_noisy, y_train)\n    \n    return alpha, X_train\n\ndef predict_gp(X_test, X_train, alpha, gp_params):\n    \"\"\"\n    Makes predictions using a fitted GP model.\n    \"\"\"\n    sigma_f = gp_params['sigma_f']\n    l1 = gp_params['l1']\n    l2 = gp_params['l2']\n    \n    K_test_train = squared_exponential_kernel(X_test, X_train, sigma_f, l1, l2)\n    y_pred = K_test_train @ alpha\n    return y_pred\n\ndef calculate_metrics(y_test, y_pred_ols, y_pred_gp, X_train, alpha, gp_params):\n    \"\"\"\n    Calculates the relative MSE improvement (Delta), curvature (C), and slope gap (S).\n    \"\"\"\n    # Calculate MSEs and the relative improvement Delta.\n    mse_lin = np.mean((y_test - y_pred_ols)**2)\n    mse_gp = np.mean((y_test - y_pred_gp)**2)\n    delta = (mse_lin - mse_gp) / mse_lin if mse_lin > 0 else 0.0\n\n    # For diagnostics, create a grid of K values.\n    K_min, K_max = 2.0, 18.0\n    N = 50\n    h = (K_max - K_min) / (N - 1)\n    K_grid = np.linspace(K_min, K_max, N)\n\n    # Predict with the GP on the grid for both regimes z=0 and z=1.\n    X_grid_z0 = np.vstack((K_grid, np.zeros(N))).T\n    F_gp_z0 = predict_gp(X_grid_z0, X_train, alpha, gp_params)\n    \n    X_grid_z1 = np.vstack((K_grid, np.ones(N))).T\n    F_gp_z1 = predict_gp(X_grid_z1, X_train, alpha, gp_params)\n\n    # Compute curvature C using a second-order central finite difference.\n    D2_z0 = (F_gp_z0[2:] - 2*F_gp_z0[1:-1] + F_gp_z0[:-2]) / h**2\n    D2_z1 = (F_gp_z1[2:] - 2*F_gp_z1[1:-1] + F_gp_z1[:-2]) / h**2\n    C = max(np.max(np.abs(D2_z0)), np.max(np.abs(D2_z1)))\n    \n    # Compute slope gap S using a first-order central finite difference.\n    D1_z0 = (F_gp_z0[2:] - F_gp_z0[:-2]) / (2*h)\n    D1_z1 = (F_gp_z1[2:] - F_gp_z1[:-2]) / (2*h)\n    S = np.max(np.abs(D1_z1 - D1_z0))\n    \n    return delta, C, S\n\nif __name__ == '__main__':\n    solve()\n```"}]}