{"hands_on_practices": [{"introduction": "在资本资产定价模型（CAPM）的实践应用中，通过普通最小二乘法（OLS）回归估计的 $\\beta$ 值可能存在系统性偏差。一个常见的原因是“非同步交易”或“稀疏交易”问题，即资产的交易频率远低于市场指数的更新频率，导致日收益率之间出现伪相关性，通常会低估真实的 $\\beta$。该练习将引导你实现 Dimson 回归，通过在模型中引入市场收益率的领先和滞后项，来有效修正这种偏差。[@problem_id:2390296] 这种方法是金融计量学中处理真实世界数据问题的实用技术，对于准确评估非流动性资产的系统性风险至关重要。", "id": "2390296", "problem": "给定一个针对交易不活跃资产的线性回报模型，该模型通过包含市场回报的一期滞后项和领先项，来考虑资产与市场之间的非同步交易。对于时间指数 $t \\in \\{1,2,\\ldots,T\\}$，该模型为\n$$\nR_{i,t} \\;=\\; \\alpha_i \\;+\\; \\beta_{-1} R_{m,t-1} \\;+\\; \\beta_{0} R_{m,t} \\;+\\; \\beta_{+1} R_{m,t+1} \\;+\\; \\varepsilon_t,\n$$\n其中 $R_{i,t}$ 是资产回报，$R_{m,t}$ 是市场回报，两者均以小数形式表示。未知参数是截距 $\\alpha_i$ 和三个斜率系数 $\\beta_{-1}$、$\\beta_{0}$ 和 $\\beta_{+1}$。Dimson beta 定义为总和 $\\beta_{-1} + \\beta_{0} + \\beta_{+1}$。假设参数是通过最小化在所有回归变量都有定义的时间指数集合（即 $t \\in \\{2,3,\\ldots,T-1\\}$）上的残差平方和来估计的。所有回报均以小数形式给出（例如，百分之一的回报是 $0.01$，而不是 $1$ 或 $1\\%$）。\n\n你的任务是，对于下面的每个测试用例，使用上述普通最小二乘法定义来估计 $\\alpha_i$ 和 Dimson beta $\\beta_{-1} + \\beta_{0} + \\beta_{+1}$，其目标是最小化\n$$\n\\sum_{t=2}^{T-1} \\Big(R_{i,t} - \\alpha_i - \\beta_{-1} R_{m,t-1} - \\beta_{0} R_{m,t} - \\beta_{+1} R_{m,t+1}\\Big)^2.\n$$\n\n在每个测试用例的估计中，仅使用指数 $t \\in \\{2,3,\\ldots,T-1\\}$。此指数范围之外的数据不应对目标函数有任何贡献。\n\n测试套件：\n- 测试用例 $1$（一般情况，中等长度）：令 $T=8$。市场回报序列 $R_{m,1:T}$ 为 $\\{0.018,\\,-0.012,\\,0.031,\\,0.004,\\,-0.023,\\,0.009,\\,0.042,\\,-0.035\\}$。资产回报序列 $R_{i,1:T}$ 为 $\\{0.00000,\\,-0.01185,\\,0.03200,\\,0.01710,\\,-0.02415,\\,-0.00065,\\,0.05520,\\,0.00000\\}$。\n- 测试用例 $2$（足以估计所有参数的边界长度）：令 $T=6$。市场回报序列 $R_{m,1:T}$ 为 $\\{0.014,\\,-0.025,\\,0.019,\\,-0.006,\\,0.037,\\,-0.011\\}$。资产回报序列 $R_{i,1:T}$ 为 $\\{0.00000,\\,-0.00450,\\,-0.01150,\\,-0.01100,\\,0.00050,\\,0.00000\\}$。\n- 测试用例 $3$（数据生成关系中仅存在截距）：令 $T=7$。市场回报序列 $R_{m,1:T}$ 为 $\\{0.005,\\,-0.008,\\,0.013,\\,-0.021,\\,0.017,\\,0.002,\\,-0.009\\}$。资产回报序列 $R_{i,1:T}$ 为 $\\{0.00240,\\,0.00240,\\,0.00240,\\,0.00240,\\,0.00240,\\,0.00240,\\,0.00240\\}$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例应贡献一个包含估计截距 $\\alpha_i$ 和估计 Dimson beta $\\beta_{-1} + \\beta_{0} + \\beta_{+1}$ 的数对，并按此顺序排列。\n- 每个浮点数必须四舍五入到恰好 $6$ 位小数，并以定点表示法打印。\n- 具体来说，输出必须具有以下形式\n$[[\\widehat{\\alpha}_1,\\widehat{\\beta}^{\\text{Dimson}}_1],[\\widehat{\\alpha}_2,\\widehat{\\beta}^{\\text{Dimson}}_2],[\\widehat{\\alpha}_3,\\widehat{\\beta}^{\\text{Dimson}}_3]]$\n行内无任何空格。\n\n每个测试用例的答案必须是指定格式的一对浮点数，且聚合输出必须是如上所述的单行。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个计算金融学中定义明确的问题，基于成熟的计量经济学原理，并提供了所有必要的数据和定义。\n\n该问题要求使用普通最小二乘法（OLS）估计线性回归模型的参数。该模型考虑了非同步交易，其具体形式如下：\n$$\nR_{i,t} = \\alpha_i + \\beta_{-1} R_{m,t-1} + \\beta_{0} R_{m,t} + \\beta_{+1} R_{m,t+1} + \\varepsilon_t\n$$\n其中 $R_{i,t}$ 是资产 $i$ 在时间 $t$ 的回报，$R_{m,t}$ 是市场在时间 $t$ 的回报，而 $\\varepsilon_t$ 是一个随机误差项。需要估计的参数是截距 $\\alpha_i$ 和斜率系数 $\\beta_{-1}$、$\\beta_{0}$ 和 $\\beta_{+1}$。\n\n估计是基于在时间指数 $t \\in \\{2, 3, \\ldots, T-1\\}$ 上最小化残差平方和（SSR）。这对应于标准的 OLS 过程。该问题可以用矩阵形式表示为：\n$$\n\\mathbf{y} = \\mathbf{X}\\mathbf{b} + \\mathbf{e}\n$$\n参数向量 $\\mathbf{b}$ 的 OLS 估计量 $\\hat{\\mathbf{b}}$ 是使残差向量的平方范数 $\\|\\mathbf{y} - \\mathbf{X}\\mathbf{b}\\|^2$ 最小化的向量。\n\n对于每个总时间序列长度为 $T$ 的测试用例，我们使用所有回归变量都可用的数据（即 $t \\in \\{2, 3, \\ldots, T-1\\}$）来构建向量和矩阵。这为回归提供了 $N = T-2$ 个观测值。\n\n因变量向量 $\\mathbf{y}$ 是从时间 $t=2$ 到 $t=T-1$ 的资产回报的列向量：\n$$\n\\mathbf{y} = \\begin{pmatrix} R_{i,2} \\\\ R_{i,3} \\\\ \\vdots \\\\ R_{i,T-1} \\end{pmatrix}\n$$\n该向量的维度为 $(T-2) \\times 1$。\n\n参数向量 $\\mathbf{b}$ 包含未知系数：\n$$\n\\mathbf{b} = \\begin{pmatrix} \\alpha_i \\\\ \\beta_{-1} \\\\ \\beta_{0} \\\\ \\beta_{+1} \\end{pmatrix}\n$$\n该向量的维度为 $4 \\times 1$。\n\n设计矩阵 $\\mathbf{X}$ 由回归变量构成。它包含一列用于截距 $\\alpha_i$ 的 1，以及用于滞后、同期和领先的市场回报（$R_{m,t-1}, R_{m,t}, R_{m,t+1}$）的列。每一行对应一个特定的时间 $t$：\n$$\n\\mathbf{X} = \\begin{pmatrix}\n1 & R_{m,1} & R_{m,2} & R_{m,3} \\\\\n1 & R_{m,2} & R_{m,3} & R_{m,4} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & R_{m,T-2} & R_{m,T-1} & R_{m,T}\n\\end{pmatrix}\n$$\n该矩阵的维度为 $(T-2) \\times 4$。\n\nOLS 估计值 $\\hat{\\mathbf{b}}$ 由正规方程组的解给出：\n$$\n\\hat{\\mathbf{b}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n$$\n如果矩阵 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的，则存在唯一解，这要求观测值数量 $N = T-2$ 至少等于参数数量 $k=4$，并且 $\\mathbf{X}$ 的列是线性无关的。所有测试用例都满足条件 $T-2 \\ge 4$：对于 $T=8$，有 $N=6$；对于 $T=6$，有 $N=4$；对于 $T=7$，有 $N=5$。\n\n一旦参数向量 $\\hat{\\mathbf{b}} = [\\hat{\\alpha}_i, \\hat{\\beta}_{-1}, \\hat{\\beta}_{0}, \\hat{\\beta}_{+1}]^T$ 被估计出来，就可以计算所需的输出：\n$1$. 估计的截距是向量的第一个元素：$\\hat{\\alpha}_i = \\hat{\\mathbf{b}}_1$。\n$2$. 估计的 Dimson beta 是估计的斜率系数之和：$\\hat{\\beta}^{\\text{Dimson}} = \\hat{\\beta}_{-1} + \\hat{\\beta}_{0} + \\hat{\\beta}_{+1} = \\hat{\\mathbf{b}}_2 + \\hat{\\mathbf{b}}_3 + \\hat{\\mathbf{b}}_4$。\n\n算法流程如下：\n对于每个测试用例：\n$1$. 给定时间序列 $R_{m,1:T}$ 和 $R_{i,1:T}$，从 $t \\in \\{2, \\ldots, T-1\\}$ 的 $R_{i,t}$ 构建向量 $\\mathbf{y}$。\n$2$. 构建矩阵 $\\mathbf{X}$，其中对应于时间 $t$ 的每一行是 $[1, R_{m,t-1}, R_{m,t}, R_{m,t+1}]$。\n$3$. 求解线性最小二乘问题以找到 $\\hat{\\mathbf{b}}$。最好使用数值稳定的算法来完成，例如基于 QR 分解的算法，该算法已在标准数值库中实现。\n$4$. 从结果向量 $\\hat{\\mathbf{b}}$ 中提取 $\\hat{\\alpha}_i$ 并计算 $\\hat{\\beta}^{\\text{Dimson}}$。\n$5$. 按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Dimson-beta estimation problem for a set of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": 8,\n            \"Rm\": [0.018, -0.012, 0.031, 0.004, -0.023, 0.009, 0.042, -0.035],\n            \"Ri\": [0.00000, -0.01185, 0.03200, 0.01710, -0.02415, -0.00065, 0.05520, 0.00000]\n        },\n        {\n            \"T\": 6,\n            \"Rm\": [0.014, -0.025, 0.019, -0.006, 0.037, -0.011],\n            \"Ri\": [0.00000, -0.00450, -0.01150, -0.01100, 0.00050, 0.00000]\n        },\n        {\n            \"T\": 7,\n            \"Rm\": [0.005, -0.008, 0.013, -0.021, 0.017, 0.002, -0.009],\n            \"Ri\": [0.00240, 0.00240, 0.00240, 0.00240, 0.00240, 0.00240, 0.00240]\n        }\n    ]\n\n    results_as_strings = []\n    \n    for case in test_cases:\n        T = case[\"T\"]\n        Rm = np.array(case[\"Rm\"])\n        Ri = np.array(case[\"Ri\"])\n        \n        # The regression is run over indices t from 2 to T-1.\n        # This corresponds to 0-based array indices from 1 to T-2.\n        \n        # Dependent variable vector y from Ri_t for t in {2, ..., T-1}\n        # Array indices: Ri[1], ..., Ri[T-2]\n        y = Ri[1:T-1]\n        \n        # Design matrix X\n        # For each t in {2, ..., T-1}, the regressors are 1, R_m,t-1, R_m,t, R_m,t+1\n        # which corresponds to array indices Rm[t-2], Rm[t-1], Rm[t].\n        X_rows = []\n        for t_idx in range(1, T - 1): # Corresponds to t = 2, ..., T-1\n            # t = t_idx + 1\n            # R_m,t-1 -> Rm[t-2] -> Rm[t_idx-1]\n            # R_m,t   -> Rm[t-1] -> Rm[t_idx]\n            # R_m,t+1 -> Rm[t]   -> Rm[t_idx+1]\n            row = [1.0, Rm[t_idx - 1], Rm[t_idx], Rm[t_idx + 1]]\n            X_rows.append(row)\n        \n        X = np.array(X_rows)\n        \n        # Solve the ordinary least squares problem y = Xb + e for b\n        # np.linalg.lstsq is numerically stable for this task.\n        coeffs, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # The coefficients are [alpha_i, beta_-1, beta_0, beta_+1]\n        alpha_i = coeffs[0]\n        dimson_beta = coeffs[1] + coeffs[2] + coeffs[3]\n        \n        # Format the result pair as a string and add to the list\n        pair_str = f\"[{alpha_i:.6f},{dimson_beta:.6f}]\"\n        results_as_strings.append(pair_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"}, {"introduction": "准确估计 $\\beta$ 固然重要，但其最终目的是为了检验资产定价理论。资本资产定价模型（CAPM）的核心预测是，资产的预期超额收益与其市场 $\\beta$ 呈线性关系，即证券市场线（SML）的成立。这个动手实践将指导你从零开始实现经典的 Fama-MacBeth 两步回归法，以实证检验 CAPM 的这一关键预测。[@problem_id:2390281] 通过首先进行时间序列回归估计贝塔，然后进行横截面回归检验贝塔的定价能力，你将亲身体验从理论到实证的完整研究过程，这是现代金融实证研究的基石。", "id": "2390281", "problem": "要求您从第一性原理出发，使用 Fama 和 MacBeth 两步回归程序，对资本资产定价模型 (CAPM) 的证券市场线进行完整且可复现的实证检验。整个过程完全使用由明确定义的单因子数据生成过程所产生的模拟收益率，并为每个测试用例使用固定的伪随机种子以确保确定性。所有收益率必须以小数表示，而非百分比。\n\n定义以下对象。对于每个资产指数 $i \\in \\{1,\\dots,N\\}$ 和时间指数 $t \\in \\{1,\\dots,T\\}$，令 $R_{i,t}^{e}$ 表示资产相对于无风险利率的超额收益率，令 $F_{t}$ 表示市场超额收益率。数据生成过程为\n$$\nR_{i,t}^{e} \\;=\\; \\alpha_{i} \\;+\\; \\beta_{i} \\, F_{t} \\;+\\; \\varepsilon_{i,t},\n$$\n其中 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0,\\sigma_{e,i}^{2})$ 在 $i$ 和 $t$ 上独立同分布，且 $F_{t} \\sim \\mathcal{N}(\\mu_{M},\\sigma_{M}^{2})$ 在 $t$ 上独立同分布。无风险利率设为零，因此超额收益率与原始收益率一致。CAPM 证券市场线假设对所有 $i$ 都有 $\\alpha_{i}=0$，并指出横截面上的预期超额收益率是 $\\beta_{i}$ 的线性函数，截距为零，斜率等于 $\\mathbb{E}[F_{t}]$。\n\n请为每个测试用例精确实现以下定义：\n1. 使用前 $W$ 个时期的数据，通过对时间序列回归进行普通最小二乘估计，为每个资产 $i$ 估算 $\\widehat{\\beta}_{i}$\n$$\nR_{i,t}^{e} \\;=\\; a_{i} \\;+\\; b_{i} \\, F_{t} \\;+\\; u_{i,t}, \\quad t=1,\\dots,W,\n$$\n并设 $\\widehat{\\beta}_{i} \\equiv b_{i}$。\n2. 对每个时期 $t = W\\!+\\!1,\\dots,T$，对所有资产进行横截面回归\n$$\nR_{i,t}^{e} \\;=\\; \\gamma_{0,t} \\;+\\; \\gamma_{1,t} \\, \\widehat{\\beta}_{i} \\;+\\; \\eta_{i,t},\n$$\n以获得时期 $t$ 的估计值 $\\widehat{\\gamma}_{0,t}$ 和 $\\widehat{\\gamma}_{1,t}$。\n3. 令 $T_{\\text{cs}} \\equiv T - W$。计算横截面参数的时间序列平均值，\n$$\n\\bar{\\gamma}_{0} \\;=\\; \\frac{1}{T_{\\text{cs}}} \\sum_{t=W+1}^{T} \\widehat{\\gamma}_{0,t}, \n\\qquad\n\\bar{\\gamma}_{1} \\;=\\; \\frac{1}{T_{\\text{cs}}} \\sum_{t=W+1}^{T} \\widehat{\\gamma}_{1,t}.\n$$\n4. 使用横截面估计值的时间序列变异性计算 Fama and MacBeth 标准误，\n$$\n\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j}) \\;=\\; \\frac{s(\\widehat{\\gamma}_{j,\\cdot})}{\\sqrt{T_{\\text{cs}}}}, \n\\quad j \\in \\{0,1\\},\n$$\n其中 $s(\\widehat{\\gamma}_{j,\\cdot})$ 是 $\\{\\widehat{\\gamma}_{j,t}\\}_{t=W+1}^{T}$ 的样本标准差，计算时分母为 $T_{\\text{cs}}-1$。然后构建 $t$ 统计量，\n$$\nt(\\bar{\\gamma}_{j}) \\;=\\; \\frac{\\bar{\\gamma}_{j}}{\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j})}, \n\\quad j \\in \\{0,1\\}.\n$$\n\n您的程序必须模拟数据并对以下三个测试用例中的每一个执行上述计算。在所有情况下，请勿转换或重新缩放输入；须完全按照所提供的值使用。下面给出的所有数字均以小数单位表示。\n\n测试套件 (每个项目符号为一个测试用例)：\n- 案例 A (CAPM 成立，存在中等程度的异质性噪声):\n  • $N=6$, $T=120$, $W=60$。\n  • 真实 beta 值: $(\\beta_{1},\\dots,\\beta_{6}) = (0.6, 0.8, 1.0, 1.2, 1.4, 1.6)$。\n  • 异质性标准差: $(\\sigma_{e,1},\\dots,\\sigma_{e,6}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02)$。\n  • 市场参数: $\\mu_{M}=0.006$, $\\sigma_{M}=0.04$。\n  • 共同截距: 对所有 $i$，$\\alpha_{i}=0$。\n  • 随机种子: $12345$。\n- 案例 B (因共同的非零截距而违背证券市场线):\n  • $N=6$, $T=120$, $W=60$。\n  • 真实 beta 值: $(\\beta_{1},\\dots,\\beta_{6}) = (0.6, 0.8, 1.0, 1.2, 1.4, 1.6)$。\n  • 异质性标准差: $(\\sigma_{e,1},\\dots,\\sigma_{e,6}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02)$。\n  • 市场参数: $\\mu_{M}=0.006$, $\\sigma_{M}=0.04$。\n  • 共同截距: 对所有 $i$，$\\alpha_{i}=0.002$。\n  • 随机种子: $67890$。\n- 案例 C (更短的估计窗口和更高的异质性噪声):\n  • $N=4$, $T=90$, $W=24$。\n  • 真实 beta 值: $(\\beta_{1},\\dots,\\beta_{4}) = (0.5, 1.0, 1.5, 2.0)$。\n  • 异质性标准差: $(\\sigma_{e,1},\\dots,\\sigma_{e,4}) = (0.06, 0.05, 0.04, 0.03)$。\n  • 市场参数: $\\mu_{M}=0.005$, $\\sigma_{M}=0.05$。\n  • 共同截距: 对所有 $i$，$\\alpha_{i}=0$。\n  • 随机种子: $24680$。\n\n对于每个案例，计算四元组\n$$\n\\left[ \\bar{\\gamma}_{0},\\; \\bar{\\gamma}_{1},\\; t(\\bar{\\gamma}_{0}),\\; t(\\bar{\\gamma}_{1}) \\right],\n$$\n并将每个条目四舍五入到 $6$ 位小数。\n\n您的程序应生成单行输出，其中包含这三个四元组的结果，以逗号分隔列表的形式呈现，并用方括号括起来，例如\n$[\\,[x_{A},y_{A},z_{A},w_{A}],\\,[x_{B},y_{B},z_{B},w_{B}],\\,[x_{C},y_{C},z_{C},w_{C}]\\,]$,\n其中每个符号代表按上述规定四舍五入后的小数。不允许有任何其他输出。", "solution": "资本资产定价模型 (CAPM) 假设预期超额收益率与市场风险暴露之间存在线性关系，此关系由证券市场线 (Security Market Line) 所描述。正式地，对于超额收益率为 $R_{i,t}^{e}$ 的资产 $i$ 和市场超额收益率 $F_{t}$，该模型表明\n$$\n\\mathbb{E}[R_{i,t}^{e}] \\;=\\; \\beta_{i} \\,\\mathbb{E}[F_{t}],\n$$\n这等价于因子表达式中\n$$\nR_{i,t}^{e} \\;=\\; \\alpha_{i} \\;+\\; \\beta_{i} \\, F_{t} \\;+\\; \\varepsilon_{i,t}\n$$\n截距项 $\\alpha_{i}$对所有 $i$ 均为零的条件。\n\nFama and MacBeth (两步法) 首先估计风险暴露，然后在横截面上对它们进行定价。其原理是将时间序列的风险估计与横截面的定价分离，并利用横截面斜率和截距的时间序列变异性来构建标准误。\n\n分步推导：\n\n1. beta 的时间序列估计。对每个资产 $i$，考虑在初始窗口 $t=1,\\dots,W$ 上的回归，\n$$\nR_{i,t}^{e} \\;=\\; a_{i} \\;+\\; b_{i} \\, F_{t} \\;+\\; u_{i,t}.\n$$\n普通最小二乘 (OLS) 估计量 $b_{i}$ 解决以下问题\n$$\n\\min_{(a_{i},b_{i})} \\sum_{t=1}^{W} \\left(R_{i,t}^{e} - a_{i} - b_{i} F_{t}\\right)^{2},\n$$\n导出正规方程组，\n$$\n\\begin{bmatrix}\nW & \\sum_{t=1}^{W} F_{t} \\\\\n\\sum_{t=1}^{W} F_{t} & \\sum_{t=1}^{W} F_{t}^{2}\n\\end{bmatrix}\n\\begin{bmatrix}\na_{i} \\\\\nb_{i}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\n\\sum_{t=1}^{W} R_{i,t}^{e} \\\\\n\\sum_{t=1}^{W} F_{t} R_{i,t}^{e}\n\\end{bmatrix}.\n$$\n求解可得 $b_{i} \\equiv \\widehat{\\beta}_{i}$，即资产 $i$ 的估计市场风险暴露。这是第一性原理的 OLS 解：$b_{i}$ 是将 $R_{i,t}^{e}$ 线性投影到 $F_{t}$ 和一个常数上所得的斜率系数。\n\n2. 每个时期的横截面定价。对每个 $t=W+1,\\dots,T$，我们将集合 $\\{\\widehat{\\beta}_{i}\\}_{i=1}^{N}$ 视为固定回归量，并对所有资产进行横截面 OLS 回归，\n$$\nR_{i,t}^{e} \\;=\\; \\gamma_{0,t} \\;+\\; \\gamma_{1,t} \\, \\widehat{\\beta}_{i} \\;+\\; \\eta_{i,t}.\n$$\n对 $i$ 进行堆叠可得 $y_{t} = X \\gamma_{t} + \\eta_{t}$，其中 $y_{t}$ 是收益率 $R_{i,t}^{e}$ 的 $N \\times 1$ 向量，$X$ 是一个 $N \\times 2$ 矩阵，其第一列为 1，第二列为 $\\widehat{\\beta}$，且 $\\gamma_{t} = (\\gamma_{0,t},\\gamma_{1,t})^{\\top}$。OLS 估计量为\n$$\n\\widehat{\\gamma}_{t} \\;=\\; (X^{\\top}X)^{-1} X^{\\top} y_{t},\n$$\n得到时期 $t$ 的 $\\widehat{\\gamma}_{0,t}$ (截距) 和 $\\widehat{\\gamma}_{1,t}$ (斜率)。\n\n3. 时间序列聚合与标准误。对于 $T_{\\text{cs}} = T - W$ 个横截面，定义样本均值\n$$\n\\bar{\\gamma}_{j} \\;=\\; \\frac{1}{T_{\\text{cs}}} \\sum_{t=W+1}^{T} \\widehat{\\gamma}_{j,t}, \\quad j \\in \\{0,1\\}.\n$$\nFama and MacBeth 标准误使用逐期估计值的时间序列离散度：\n$$\n\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j}) \\;=\\; \\frac{s(\\widehat{\\gamma}_{j,\\cdot})}{\\sqrt{T_{\\text{cs}}}},\n$$\n其中 $s(\\widehat{\\gamma}_{j,\\cdot})$ 是样本标准差\n$$\ns(\\widehat{\\gamma}_{j,\\cdot}) \\;=\\; \\sqrt{\\frac{1}{T_{\\text{cs}}-1} \\sum_{t=W+1}^{T} \\left(\\widehat{\\gamma}_{j,t} - \\bar{\\gamma}_{j}\\right)^{2}}.\n$$\n$t$ 统计量则为\n$$\nt(\\bar{\\gamma}_{j}) \\;=\\; \\frac{\\bar{\\gamma}_{j}}{\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j})}.\n$$\n\n在 CAPM 下的解释：\n- 如果 CAPM 在数据生成过程中成立，那么对于所有 $i$ 都有 $\\alpha_{i} = 0$，这意味着 $\\bar{\\gamma}_{0}$ 应接近于零，并且对于足够大的 $T_{\\text{cs}}$，$t(\\bar{\\gamma}_{0})$ 在统计上应不显著异于零。\n- 斜率 $\\bar{\\gamma}_{1}$ 应接近 $\\mathbb{E}[F_{t}] = \\mu_{M}$，而 $t(\\bar{\\gamma}_{1})$ 应能表明 beta 风险的平均价格在统计上是否显著异于零。\n\n模拟设计与可复现性：\n- 对每个案例，使用指定的种子独立生成抽样 $F_{t} \\sim \\mathcal{N}(\\mu_{M},\\sigma_{M}^{2})$ 和 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0,\\sigma_{e,i}^{2})$。\n- 超额收益率通过 $R_{i,t}^{e} = \\alpha_{i} + \\beta_{i} F_{t} + \\varepsilon_{i,t}$（$t=1,\\dots,T$）构建。\n- 从前 $W$ 个时期估计出的相同 $\\widehat{\\beta}_{i}$ 将被用作所有后续横截面回归的回归量。\n\n基于原理的算法实现：\n- 为每个资产的时间序列 OLS 构建设计矩阵，其列为 $(\\mathbf{1}, F_{1:W})$，并使用线性代数求解正规方程组以获得 $\\widehat{\\beta}_{i}$。\n- 构建横截面设计矩阵，其列为 $(\\mathbf{1}, \\widehat{\\beta})$，并在每个 $t=W+1,\\dots,T$ 将 $R_{\\cdot,t}^{e}$ 对其进行回归，以获得 $\\widehat{\\gamma}_{0,t}$ 和 $\\widehat{\\gamma}_{1,t}$。\n- 聚合计算 $\\bar{\\gamma}_{0}$、$\\bar{\\gamma}_{1}$ 及其定义的 $t$ 统计量。\n- 将每个报告的数字四舍五入到 6 位小数，以匹配所需的输出精度。\n\n最终输出是三个四元组的列表，每个案例一个，\n$$\n\\left[ \\left[\\bar{\\gamma}_{0}^{A},\\bar{\\gamma}_{1}^{A}, t(\\bar{\\gamma}_{0}^{A}), t(\\bar{\\gamma}_{1}^{A})\\right], \\left[\\bar{\\gamma}_{0}^{B},\\bar{\\gamma}_{1}^{B}, t(\\bar{\\gamma}_{0}^{B}), t(\\bar{\\gamma}_{1}^{B})\\right], \\left[\\bar{\\gamma}_{0}^{C},\\bar{\\gamma}_{1}^{C}, t(\\bar{\\gamma}_{0}^{C}), t(\\bar{\\gamma}_{1}^{C})\\right] \\right],\n$$\n打印在单行上，其中上标 $A$、$B$ 和 $C$ 为测试案例的索引。给定种子和参数，输出是确定性的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_beta_time_series(R_excess, F, W):\n    \"\"\"\n    Estimate beta_i for each asset i using OLS on the first W periods:\n    R_i,t^e = a_i + b_i * F_t + u_i,t\n    Returns array of shape (N,) with beta estimates b_i.\n    \"\"\"\n    N = R_excess.shape[0]\n    X = np.column_stack([np.ones(W), F[:W]])\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    betas_hat = np.empty(N)\n    for i in range(N):\n        y = R_excess[i, :W]\n        coef = XtX_inv @ (X.T @ y)\n        betas_hat[i] = coef[1]\n    return betas_hat\n\ndef cross_sectional_gammas(R_excess, betas_hat, start_t):\n    \"\"\"\n    For each t from start_t to T-1, run cross-sectional OLS:\n    R_i,t^e = gamma0_t + gamma1_t * betas_hat_i + eta_i,t\n    Returns arrays gamma0 (Tcs,), gamma1 (Tcs,)\n    \"\"\"\n    N, T = R_excess.shape\n    Tcs = T - start_t\n    ones = np.ones(N)\n    X = np.column_stack([ones, betas_hat])  # shape (N, 2)\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    gamma0 = np.empty(Tcs)\n    gamma1 = np.empty(Tcs)\n    idx = 0\n    for t in range(start_t, T):\n        y = R_excess[:, t]\n        gamma = XtX_inv @ (X.T @ y)\n        gamma0[idx] = gamma[0]\n        gamma1[idx] = gamma[1]\n        idx += 1\n    return gamma0, gamma1\n\ndef fm_summary_stats(gamma_series):\n    \"\"\"\n    Given a 1-D array of period-by-period gammas (length Tcs),\n    return (mean, t_stat) using FM time-series standard error.\n    \"\"\"\n    Tcs = gamma_series.shape[0]\n    mean_val = float(np.mean(gamma_series))\n    # sample standard deviation with ddof=1\n    if Tcs > 1:\n        sd = float(np.std(gamma_series, ddof=1))\n        se = sd / np.sqrt(Tcs)\n        t_stat = mean_val / se if se > 0 else 0.0\n    else:\n        # Degenerate case; define t-stat as 0\n        t_stat = 0.0\n    return mean_val, t_stat\n\ndef simulate_case(N, T, W, betas_true, sigmas_e, mu_M, sigma_M, alpha_common, seed):\n    \"\"\"\n    Simulate factor and returns according to:\n    R_i,t^e = alpha_common + beta_i * F_t + eps_i,t\n    with F_t ~ N(mu_M, sigma_M^2), eps_i,t ~ N(0, sigma_e_i^2).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    F = rng.normal(loc=mu_M, scale=sigma_M, size=T)\n    R_excess = np.empty((N, T))\n    betas_true = np.asarray(betas_true, dtype=float)\n    sigmas_e = np.asarray(sigmas_e, dtype=float)\n    for i in range(N):\n        eps = rng.normal(loc=0.0, scale=sigmas_e[i], size=T)\n        R_excess[i, :] = alpha_common + betas_true[i] * F + eps\n    return R_excess, F\n\ndef run_case(N, T, W, betas_true, sigmas_e, mu_M, sigma_M, alpha_common, seed):\n    R_excess, F = simulate_case(N, T, W, betas_true, sigmas_e, mu_M, sigma_M, alpha_common, seed)\n    betas_hat = estimate_beta_time_series(R_excess, F, W)\n    gamma0_series, gamma1_series = cross_sectional_gammas(R_excess, betas_hat, W)\n    g0_mean, g0_t = fm_summary_stats(gamma0_series)\n    g1_mean, g1_t = fm_summary_stats(gamma1_series)\n    # Round to 6 decimals as required\n    return [round(g0_mean, 6), round(g1_mean, 6), round(g0_t, 6), round(g1_t, 6)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            \"N\": 6,\n            \"T\": 120,\n            \"W\": 60,\n            \"betas_true\": [0.6, 0.8, 1.0, 1.2, 1.4, 1.6],\n            \"sigmas_e\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n            \"mu_M\": 0.006,\n            \"sigma_M\": 0.04,\n            \"alpha_common\": 0.0,\n            \"seed\": 12345,\n        },\n        # Case B\n        {\n            \"N\": 6,\n            \"T\": 120,\n            \"W\": 60,\n            \"betas_true\": [0.6, 0.8, 1.0, 1.2, 1.4, 1.6],\n            \"sigmas_e\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n            \"mu_M\": 0.006,\n            \"sigma_M\": 0.04,\n            \"alpha_common\": 0.002,\n            \"seed\": 67890,\n        },\n        # Case C\n        {\n            \"N\": 4,\n            \"T\": 90,\n            \"W\": 24,\n            \"betas_true\": [0.5, 1.0, 1.5, 2.0],\n            \"sigmas_e\": [0.06, 0.05, 0.04, 0.03],\n            \"mu_M\": 0.005,\n            \"sigma_M\": 0.05,\n            \"alpha_common\": 0.0,\n            \"seed\": 24680,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_case(\n            N=case[\"N\"],\n            T=case[\"T\"],\n            W=case[\"W\"],\n            betas_true=case[\"betas_true\"],\n            sigmas_e=case[\"sigmas_e\"],\n            mu_M=case[\"mu_M\"],\n            sigma_M=case[\"sigma_M\"],\n            alpha_common=case[\"alpha_common\"],\n            seed=case[\"seed\"],\n        )\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Format as a single line: [[a,b,c,d],[a,b,c,d],[a,b,c,d]]\n    print(\"[\" + \",\".join(\"[\" + \",\".join(f\"{x:.6f}\" for x in arr) + \"]\" for arr in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "我们通过回归得到的 $\\beta$ 估值是一个点估计，但其不确定性有多大？经典的 OLS 方法给出的置信区间依赖于回归残差独立同分布（IID）的严格假设，而这在常表现出序列相关的金融时间序列中往往不成立。本练习将教你使用移动块自举法（Moving Block Bootstrap），这是一种强大的非参数技术，用于在存在时间序列依赖性的情况下构建更可靠的 $\\beta$ 置信区间。[@problem_id:2390356] 掌握这种稳健的统计推断方法，能够让你在面对不完全符合理想假设的真实数据时，对自己的估计结果给出更准确的评估。", "id": "2390356", "problem": "给定成对的超额收益时间序列 $\\{(r_{i,t}, r_{m,t})\\}_{t=1}^{T}$，其中 $r_{i,t}$ 是单个资产在时间 $t$ 的超额收益，$r_{m,t}$ 是基准市场投资组合在时间 $t$ 的超额收益。假设存在一个形式为 $r_{i,t} = \\alpha + \\beta r_{m,t} + \\varepsilon_t$ 的线性定价关系，其中 $\\mathbb{E}[\\varepsilon_t \\mid r_{m,1},\\dots,r_{m,T}] = 0$。$(\\alpha,\\beta)$ 的经典普通最小二乘法 (OLS) 估计量被定义为残差平方和 $\\sum_{t=1}^{T} \\left(r_{i,t} - \\alpha - \\beta r_{m,t}\\right)^2$ 的最小化者。然而，当收益率存在序列相关时，独立同分布 (IID) 的假设不成立，基于 IID 渐近理论的 $\\beta$ 的经典置信区间可能会产生误导。块自举法通过重抽样连续的数据块，可以更好地保留时间依赖性。\n\n你的任务是编写一个完整、可运行的程序，该程序使用循环包裹的方式实现移动块自举法 (MBB)，以构建 $\\beta$ 的双边置信区间。该程序必须定义并使用一个函数，该函数接收收益率数组和参数，通过拼接固定长度的连续索引块来生成自举样本，为每个自举样本计算 OLS 斜率 $\\hat{\\beta}$，然后返回作为置信区间端点的经验分位数。所有收益率必须以小数形式处理（例如，百分之一应写作 $0.01$，而不是带百分号的 $1$）。不涉及角度。没有物理单位。你必须实现以下内容：\n\n- 一个函数，给定数组 $\\{r_{i,t}\\}_{t=1}^{T}$ 和 $\\{r_{m,t}\\}_{t=1}^{T}$，通过最小化 $\\sum_{t=1}^{T} \\left(r_{i,t} - \\alpha - \\beta r_{m,t}\\right)^2$ 来计算 OLS 估计量 $(\\hat{\\alpha}, \\hat{\\beta})$。\n- 一个移动块自举法（带循环包裹）过程，其块长度为 $L \\in \\mathbb{N}$，自举复制次数为 $B \\in \\mathbb{N}$：\n  1. 令 $K = \\lceil T/L \\rceil$。\n  2. 对于每个自举复制 $b \\in \\{1,\\dots,B\\}$：\n     - 从 $\\{1,\\dots,T\\}$ 中独立且均匀地抽取 $K$ 个起始索引 $s_1,\\dots,s_K$。\n     - 通过拼接 $K$ 个长度为 $L$ 的连续索引块来形成一个自举索引序列，每个块从 $s_j$ 开始，如果需要则对 $T$ 进行取模环绕，然后截取前 $T$ 个索引。\n     - 使用这些索引来选择成对的收益率，并从重抽样的配对中计算 OLS 斜率 $\\hat{\\beta}^{(b)}$。\n  3. 对于目标覆盖概率 $c \\in (0,1)$，用 $q_{\\ell}$ 和 $q_{u}$ 表示 $\\{\\hat{\\beta}^{(b)}\\}_{b=1}^{B}$ 在概率 $p_{\\ell} = \\frac{1-c}{2}$ 和 $p_{u} = 1 - \\frac{1-c}{2}$ 处的经验下分位数和上分位数。\n  4. 当分位数落在样本点之间时，使用顺序统计量之间的线性插值。\n- 你的函数必须返回有序对 $(q_{\\ell}, q_{u})$。\n\n程序必须使用一阶自回归动态为其自身生成合成测试数据，并为每个案例使用固定的伪随机种子以确保可复现性。对于每个测试用例，将市场模拟为 $r_{m,t} = \\phi_m r_{m,t-1} + \\eta_t$，其中 $\\eta_t \\sim \\mathcal{N}(0,\\sigma_m^2)$，并将特质成分模拟为 $u_t = \\phi_u u_{t-1} + \\xi_t$，其中 $\\xi_t \\sim \\mathcal{N}(0,\\sigma_u^2)$，两者都从 $0$ 开始初始化。然后设置 $r_{i,t} = \\alpha_{\\text{true}} + \\beta_{\\text{true}} r_{m,t} + u_t$。所有模拟都必须使用下方指定的种子和参数执行，并且所有生成的收益率都必须作为小数处理。\n\n实现你的函数并将其应用于以下测试套件。每个测试用例指定 $(T, \\phi_m, \\phi_u, \\sigma_m, \\sigma_u, \\alpha_{\\text{true}}, \\beta_{\\text{true}}, \\text{seed}_{\\text{data}}, \\text{seed}_{\\text{boot}}, L, B, c)$:\n\n- 测试用例 1（中度序列相关的正常路径）：$(T=\\;200,\\; \\phi_m=\\;0.3,\\; \\phi_u=\\;0.4,\\; \\sigma_m=\\;0.02,\\; \\sigma_u=\\;0.02,\\; \\alpha_{\\text{true}}=\\;0.001,\\; \\beta_{\\text{true}}=\\;1.2,\\; \\text{seed}_{\\text{data}}=\\;12345,\\; \\text{seed}_{\\text{boot}}=\\;54321,\\; L=\\;10,\\; B=\\;1000,\\; c=\\;0.95)$。\n- 测试用例 2（短序列边界）：$(T=\\;40,\\; \\phi_m=\\;0.5,\\; \\phi_u=\\;0.5,\\; \\sigma_m=\\;0.03,\\; \\sigma_u=\\;0.03,\\; \\alpha_{\\text{true}}=\\;-0.0005,\\; \\beta_{\\text{true}}=\\;0.8,\\; \\text{seed}_{\\text{data}}=\\;24680,\\; \\text{seed}_{\\text{boot}}=\\;13579,\\; L=\\;8,\\; B=\\;1000,\\; c=\\;0.90)$。\n- 测试用例 3（$L=T$ 的退化边缘情况）：$(T=\\;60,\\; \\phi_m=\\;0.0,\\; \\phi_u=\\;0.3,\\; \\sigma_m=\\;0.025,\\; \\sigma_u=\\;0.025,\\; \\alpha_{\\text{true}}=\\;0.0,\\; \\beta_{\\text{true}}=\\;-0.3,\\; \\text{seed}_{\\text{data}}=\\;2023,\\; \\text{seed}_{\\text{boot}}=\\;2024,\\; L=\\;60,\\; B=\\;1000,\\; c=\\;0.95)$。\n- 测试用例 4（块长度 $L=1$ 作为 IID 自举法基准）：$(T=\\;120,\\; \\phi_m=\\;0.7,\\; \\phi_u=\\;0.7,\\; \\sigma_m=\\;0.02,\\; \\sigma_u=\\;0.02,\\; \\alpha_{\\text{true}}=\\;0.002,\\; \\beta_{\\text{true}}=\\;1.0,\\; \\text{seed}_{\\text{data}}=\\;777,\\; \\text{seed}_{\\text{boot}}=\\;888,\\; L=\\;1,\\; B=\\;1000,\\; c=\\;0.95)$。\n\n附加要求和约定：\n- 分位数必须使用顺序统计量之间的线性插值计算。\n- 如果 $L > T$，则用 $\\min(L, T)$ 替换 $L$；如果 $L < 1$，则用 $1$ 替换 $L$。\n- 在给定指定种子的情况下，所有计算都必须是确定性的。\n- 报告的置信区间端点需四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来，顺序为 $[q_{\\ell}^{(1)}, q_{u}^{(1)}, q_{\\ell}^{(2)}, q_{u}^{(2)}, q_{\\ell}^{(3)}, q_{u}^{(3)}, q_{\\ell}^{(4)}, q_{u}^{(4)}]$，其中上标表示测试用例编号。\n\n你的实现必须是自包含的，并且不需要任何用户输入。", "solution": "问题陈述经审阅后被认定为有效。它在科学上基于金融计量经济学的既定原则，特别是单因素资产定价模型和用于时间序列的自举重抽样技术。该问题是良构的，为数据生成和统计估计提供了一套完整且一致的指令、模型和参数。目标以数学精度陈述，没有歧义或主观论断。任务是使用移动块自举法（MBB）为线性模型的贝塔（beta）系数构建置信区间，以处理金融收益中的序列相关性，这是一种标准且合适的方法。\n\n解决方案分四个阶段进行：推导普通最小二乘法（OLS）估计量，指定合成数据生成过程，实现移动块自举算法，以及根据自举分布构建置信区间。\n\n首先，我们考虑线性模型 $r_{i,t} = \\alpha + \\beta r_{m,t} + \\varepsilon_t$ 中参数 $(\\alpha, \\beta)$ 的 OLS 估计。OLS 估计量 $(\\hat{\\alpha}, \\hat{\\beta})$ 是使残差平方和 $S(\\alpha, \\beta) = \\sum_{t=1}^{T} (r_{i,t} - \\alpha - \\beta r_{m,t})^2$ 最小化的值。一阶条件 $\\frac{\\partial S}{\\partial \\alpha} = 0$ 和 $\\frac{\\partial S}{\\partial \\beta} = 0$ 导出正规方程。解这些方程得到斜率系数 $\\hat{\\beta}$ 的著名公式：\n$$\n\\hat{\\beta} = \\frac{\\sum_{t=1}^{T} (r_{m,t} - \\bar{r}_m)(r_{i,t} - \\bar{r}_i)}{\\sum_{t=1}^{T} (r_{m,t} - \\bar{r}_m)^2} = \\frac{\\widehat{\\text{Cov}}(r_m, r_i)}{\\widehat{\\text{Var}}(r_m)}\n$$\n其中 $\\bar{r}_m = \\frac{1}{T}\\sum_{t=1}^{T} r_{m,t}$ 和 $\\bar{r}_i = \\frac{1}{T}\\sum_{t=1}^{T} r_{i,t}$ 分别是市场和资产超额收益的样本均值。截距估计量则由 $\\hat{\\alpha} = \\bar{r}_i - \\hat{\\beta} \\bar{r}_m$ 给出。我们将实现一个函数来根据此公式计算 $\\hat{\\beta}$。\n\n其次，问题要求生成具有已知属性的合成数据以测试该过程。市场超额收益 $\\{r_{m,t}\\}$ 由一个一阶自回归过程，或称 $AR(1)$ 过程生成：\n$$\nr_{m,t} = \\phi_m r_{m,t-1} + \\eta_t, \\quad \\eta_t \\sim \\mathcal{N}(0, \\sigma_m^2)\n$$\n初始条件为 $r_{m,0} = 0$。特质成分 $\\{u_t\\}$ 也遵循一个 $AR(1)$ 过程：\n$$\nu_t = \\phi_u u_{t-1} + \\xi_t, \\quad \\xi_t \\sim \\mathcal{N}(0, \\sigma_u^2)\n$$\n初始条件为 $u_0 = 0$。然后使用真实参数 $\\alpha_{\\text{true}}$ 和 $\\beta_{\\text{true}}$ 构建资产的超额收益 $\\{r_{i,t}\\}$：\n$$\nr_{i,t} = \\alpha_{\\text{true}} + \\beta_{\\text{true}} r_{m,t} + u_t\n$$\n每个测试用例都指定了参数 $(\\phi_m, \\phi_u, \\sigma_m, \\sigma_u, \\alpha_{\\text{true}}, \\beta_{\\text{true}})$ 和随机生成器种子，确保了可复现性。非零自相关系数 $\\phi_m$ 和 $\\phi_u$ 的存在引入了序列依赖，这为使用块自举法提供了理由。\n\n第三，我们实现带循环包裹的移动块自举法（MBB）。此方法旨在通过重抽样连续观测数据块而非单个数据点来保留时间序列的时间依赖结构。算法如下：\n1.  给定长度为 $T$ 的原始时间序列和指定的块长度 $L$，我们首先通过设置 $L = \\max(1, \\min(L,T))$ 来处理边界条件。\n2.  要抽样的块数 $K$ 由 $K = \\lceil T/L \\rceil$ 决定。\n3.  对于 $B$ 个自举复制中的每一个：\n    a.  从 $\\{1, \\dots, T\\}$ 上的均匀分布中有放回地抽取一组 $K$ 个起始索引 $\\{s_1, \\dots, s_K\\}$。在零索引的编程环境中，这对应于从 $\\{0, \\dots, T-1\\}$ 中抽样。\n    b.  对于每个起始索引 $s_j$，形成一个长度为 $L$ 的连续索引块。应用循环包裹，因此块中的索引 $k$ 计算为 $(s_j + k' - 1) \\pmod T$，其中 $k' \\in \\{1,\\dots,L\\}$。\n    c.  将 $K$ 个块拼接起来，形成一个长度为 $K \\times L$ 的新索引序列。然后将此序列截断为原始样本长度 $T$。\n    d.  使用这个新的索引序列从原始数据集中重抽样收益率对 $(r_{i,t}, r_{m,t})$，创建一个自举样本 $\\{ (r_{i,t}^*, r_{m,t}^*) \\}_{t=1}^T$。\n    e.  为该自举样本计算 OLS 估计量 $\\hat{\\beta}^{(b)}$。\n4.  此过程产生一个估计量的经验分布 $\\{\\hat{\\beta}^{(b)}\\}_{b=1}^{B}$。\n\n第四，该经验分布用于构建 $\\beta$ 的双边置信区间。对于给定的置信水平 $c$，我们寻找下分位数和上分位数的概率 $p_{\\ell} = (1-c)/2$ 和 $p_{u} = 1 - p_{\\ell}$。置信区间的端点 $(q_{\\ell}, q_{u})$ 是自举分布 $\\{\\hat{\\beta}^{(b)}\\}$ 对应于这些概率的经验分位数。问题指定使用线性插值来计算当这些分位数落在样本的两个有序值之间时的值。这是构建百分位数自举置信区间的标准方法。\n\n最终的程序将整合这四个组成部分，处理每个指定的测试用例，并以要求的格式输出结果置信区间。", "answer": "```python\nimport numpy as np\n\ndef _generate_data(T, phi_m, phi_u, sigma_m, sigma_u, alpha_true, beta_true, seed_data):\n    \"\"\"\n    Generates synthetic time series data for asset and market returns.\n    \"\"\"\n    rng = np.random.default_rng(seed_data)\n    \n    # Generate market returns (r_m) from an AR(1) process\n    eta = rng.normal(0, sigma_m, T)\n    r_m = np.zeros(T)\n    if T > 0:\n        r_m[0] = eta[0]\n        for t in range(1, T):\n            r_m[t] = phi_m * r_m[t-1] + eta[t]\n            \n    # Generate idiosyncratic component (u) from an AR(1) process\n    xi = rng.normal(0, sigma_u, T)\n    u = np.zeros(T)\n    if T > 0:\n        u[0] = xi[0]\n        for t in range(1, T):\n            u[t] = phi_u * u[t-1] + xi[t]\n            \n    # Generate asset returns (r_i)\n    r_i = alpha_true + beta_true * r_m + u\n    \n    return r_i, r_m\n\ndef _ols_beta(y, x):\n    \"\"\"\n    Computes the OLS estimator for the slope coefficient beta.\n    y = dependent variable (r_i)\n    x = independent variable (r_m)\n    \"\"\"\n    if len(x) < 2:\n        return np.nan\n        \n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n    \n    covariance = np.sum((x - x_mean) * (y - y_mean))\n    variance = np.sum((x - x_mean)**2)\n    \n    # Avoid division by zero if regressor is constant\n    if np.isclose(variance, 0):\n        return np.nan\n        \n    return covariance / variance\n\ndef moving_block_bootstrap(r_i, r_m, L, B, c, seed_boot):\n    \"\"\"\n    Implements the Moving Block Bootstrap to find a confidence interval for beta.\n    \"\"\"\n    T = len(r_i)\n    \n    # Handle constraints on block length L\n    L = int(np.maximum(1, np.minimum(L, T)))\n    \n    # Number of blocks to sample\n    K = int(np.ceil(T / L))\n    \n    boot_rng = np.random.default_rng(seed_boot)\n    beta_hats_b = np.zeros(B)\n    \n    time_indices = np.arange(T)\n    \n    for b in range(B):\n        # Sample K starting indices for the blocks\n        start_indices = boot_rng.integers(0, T, size=K)\n        \n        # Form bootstrap index sequence by concatenating blocks with circular wrapping\n        block_list = [(start_indices[k] + np.arange(L)) % T for k in range(K)]\n        bootstrap_indices = np.concatenate(block_list)[:T]\n        \n        # Create bootstrap samples\n        r_i_b = r_i[bootstrap_indices]\n        r_m_b = r_m[bootstrap_indices]\n        \n        # Compute OLS beta for the bootstrap sample\n        beta_hats_b[b] = _ols_beta(r_i_b, r_m_b)\n        \n    # Calculate quantile probabilities\n    p_lower = (1.0 - c) / 2.0\n    p_upper = 1.0 - p_lower\n    \n    # Compute empirical quantiles with linear interpolation\n    q_lower = np.quantile(beta_hats_b, p_lower, method='linear')\n    q_upper = np.quantile(beta_hats_b, p_upper, method='linear')\n    \n    return q_lower, q_upper\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (T, phi_m, phi_u, sigma_m, sigma_u, alpha_true, beta_true, seed_data, seed_boot, L, B, c)\n        (200, 0.3, 0.4, 0.02, 0.02, 0.001, 1.2, 12345, 54321, 10, 1000, 0.95),\n        (40, 0.5, 0.5, 0.03, 0.03, -0.0005, 0.8, 24680, 13579, 8, 1000, 0.90),\n        (60, 0.0, 0.3, 0.025, 0.025, 0.0, -0.3, 2023, 2024, 60, 1000, 0.95),\n        (120, 0.7, 0.7, 0.02, 0.02, 0.002, 1.0, 777, 888, 1, 1000, 0.95),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        T, phi_m, phi_u, sigma_m, sigma_u, alpha_true, beta_true, seed_data, seed_boot, L, B, c = params\n        \n        # Generate data\n        r_i, r_m = _generate_data(T, phi_m, phi_u, sigma_m, sigma_u, alpha_true, beta_true, seed_data)\n        \n        # Run bootstrap and get confidence interval\n        q_l, q_u = moving_block_bootstrap(r_i, r_m, L, B, c, seed_boot)\n        \n        # Append results, rounded to 6 decimal places\n        all_results.append(round(q_l, 6))\n        all_results.append(round(q_u, 6))\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"}]}