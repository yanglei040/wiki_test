{"hands_on_practices": [{"introduction": "理解一个概率分布的最佳方式之一就是亲手实践。本练习将引导你掌握从广义帕累托分布（GPD）中生成随机样本的基本技能，这需要使用逆变换采样法。更重要的是，你将学习如何通过比较样本的经验分位数与理论分位数来验证生成数据的正确性，这是任何模拟分析中的关键步骤。通过这个过程，你将对GPD的形状参数 $\\xi$、尺度参数 $\\beta$ 和位置参数 $\\mu$ 的作用建立起直观的认识。[@problem_id:2397442]", "id": "2397442", "problem": "一家金融机构使用广义帕累托分布 (GPD) 对超过一个高阈值的超额损失进行建模。设 $X$ 服从一个 GPD，其形状参数为 $\\xi \\in \\mathbb{R}$，尺度参数为 $\\beta \\in (0,\\infty)$，位置参数为 $\\mu \\in \\mathbb{R}$。其累积分布函数定义如下\n- 对于 $\\xi \\neq 0$，\n$$\nF(x;\\xi,\\beta,\\mu) \\;=\\; 1 - \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi}\n\\quad \\text{对应于} \\quad\n\\begin{cases}\nx \\ge \\mu & \\text{当 } \\xi \\ge 0, \\\\\n\\mu \\le x \\le \\mu - \\beta/\\xi & \\text{当 } \\xi < 0,\n\\end{cases}\n$$\n- 对于 $\\xi = 0$，\n$$\nF(x;0,\\beta,\\mu) \\;=\\; 1 - \\exp\\!\\left(-\\frac{x-\\mu}{\\beta}\\right)\n\\quad \\text{对应于} \\quad x \\ge \\mu.\n$$\n\n您必须编写一个完整的程序，该程序能为多个参数集从上述 GPD 中生成独立同分布的随机变量，然后通过在一个固定的概率网格上比较经验分位数与理论分位数来评估生成的样本。所有计算都应能使用指定的种子进行复现。不允许使用外部数据或用户输入。\n\n定义与要求：\n- 设 $U$ 表示一个服从 $(0,1)$ 上标准连续均匀分布的随机变量。分位数函数 $F^{-1}(p;\\xi,\\beta,\\mu)$ 对于 $p \\in (0,1)$ 定义为其支撑集上 $F(\\cdot;\\xi,\\beta,\\mu)$ 的反函数。\n- 对于给定的概率 $p \\in (0,1)$，有限样本 $x_{1},\\dots,x_{n}$ 的经验 $p$-分位数定义如下：将样本按非递减顺序排序得到 $x_{(1)} \\le \\dots \\le x_{(n)}$，设置 $s = (n-1)p$，令 $i = \\lfloor s \\rfloor + 1$ 和 $j = \\lceil s \\rceil + 1$ 为 $\\{1,\\dots,n\\}$ 中的整数索引，并令 $\\lambda = s - \\lfloor s \\rfloor$。经验分位数为\n$$\nQ_{\\text{emp}}(p) \\;=\\; (1-\\lambda)\\,x_{(i)} + \\lambda\\,x_{(j)}.\n$$\n- 构建一个分位数网格 $\\mathcal{P} = \\{0.01, 0.02, \\dots, 0.99\\}$ 和一个中心网格 $\\mathcal{P}_{\\text{central}} = \\{0.05, 0.10, \\dots, 0.95\\}$。\n- 对于给定的参数集和大小为 $n$ 的样本，计算向量 $\\mathbf{Q}_{\\text{th}} = \\big(F^{-1}(p;\\xi,\\beta,\\mu)\\big)_{p \\in \\mathcal{P}}$ 和 $\\mathbf{Q}_{\\text{emp}} = \\big(Q_{\\text{emp}}(p)\\big)_{p \\in \\mathcal{P}}$。使用这些向量，计算：\n    1. $\\mathbf{Q}_{\\text{th}}$ 和 $\\mathbf{Q}_{\\text{emp}}$ 之间的决定系数 $R^{2}$，定义为两个向量的皮尔逊相关系数的平方。\n    2. 通过普通最小二乘法拟合的线性模型 $Q_{\\text{emp}} \\approx a + b\\,Q_{\\text{th}}$ 中的最小二乘斜率 $b$ 和截距 $a$。\n    3. 中心网格上的最大绝对偏差，按尺度参数归一化，即 $\\Delta_{\\max} = \\max_{p \\in \\mathcal{P}_{\\text{central}}} \\big|Q_{\\text{emp}}(p) - F^{-1}(p;\\xi,\\beta,\\mu)\\big|/\\beta$。\n    4. 对于 $\\xi < 0$，支撑集的上界为 $x_{\\max} = \\mu - \\beta/\\xi$。定义支撑集检查为 $\\mathbf{1}\\{\\max_{k} x_{k} \\le x_{\\max}\\}$，其中 $x_{k}$ 是采样值，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。对于 $\\xi \\ge 0$，此检查自动满足。\n\n每个参数集的验收标准：\n- $R^{2} \\ge 0.9995$,\n- $|b - 1| \\le 0.02$,\n- $|a| \\le 0.05\\,\\beta$,\n- $\\Delta_{\\max} \\le 0.12$,\n- 支撑集检查通过。\n\n对于每个参数集，输出一个布尔值，指示是否所有验收标准都同时满足。\n\n测试套件：\n- 案例 1：$(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.25,\\,1.40,\\,0.00,\\,120000,\\,1729)$。\n- 案例 2：$(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.00,\\,2.20,\\,0.50,\\,150000,\\,41041)$。\n- 案例 3：$(\\xi,\\beta,\\mu,n,\\text{seed}) = (-0.35,\\,1.10,\\,{-0.30},\\,120000,\\,271828)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述案例顺序排列的结果，格式为方括号括起来的逗号分隔列表，例如 $[\\text{True},\\text{False},\\text{True}]$，其中每个条目都是一个布尔值。", "solution": "对所述问题进行了严格的验证。\n\n**步骤 1：提取给定信息**\n- **分布**：广义帕累托分布 (GPD)，其形状参数为 $\\xi \\in \\mathbb{R}$，尺度参数为 $\\beta \\in (0,\\infty)$，位置参数为 $\\mu \\in \\mathbb{R}$。\n- **累积分布函数 (CDF)**：\n  - 对于 $\\xi \\neq 0$：$F(x;\\xi,\\beta,\\mu) = 1 - \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi}$，其支撑集在 $\\xi \\ge 0$ 时为 $x \\ge \\mu$，在 $\\xi < 0$ 时为 $\\mu \\le x \\le \\mu - \\beta/\\xi$。\n  - 对于 $\\xi = 0$：$F(x;0,\\beta,\\mu) = 1 - \\exp\\left(-\\frac{x-\\mu}{\\beta}\\right)$，其支撑集为 $x \\ge \\mu$。\n- **分位数函数**：$F^{-1}(p;\\xi,\\beta,\\mu)$ 定义为对于 $p \\in (0,1)$ 的 CDF 的反函数。\n- **经验分位数**：对于一个已排序的样本 $x_{(1)} \\le \\dots \\le x_{(n)}$，经验 $p$-分位数为 $Q_{\\text{emp}}(p) = (1-\\lambda)\\,x_{(i)} + \\lambda\\,x_{(j)}$，其中 $s = (n-1)p$，$i = \\lfloor s \\rfloor + 1$，$j = \\lceil s \\rceil + 1$，以及 $\\lambda = s - \\lfloor s \\rfloor$。\n- **概率网格**：$\\mathcal{P} = \\{0.01, 0.02, \\dots, 0.99\\}$ 和 $\\mathcal{P}_{\\text{central}} = \\{0.05, 0.10, \\dots, 0.95\\}$。\n- **评估所需的指标**：\n    1. 理论分位数 $\\mathbf{Q}_{\\text{th}}$ 和经验分位数 $\\mathbf{Q}_{\\text{emp}}$ 在网格 $\\mathcal{P}$ 上的决定系数 $R^{2}$。\n    2. 线性模型 $Q_{\\text{emp}} \\approx a + b\\,Q_{\\text{th}}$ 中的最小二乘斜率 $b$ 和截距 $a$。\n    3. 最大归一化绝对偏差 $\\Delta_{\\max} = \\max_{p \\in \\mathcal{P}_{\\text{central}}} \\big|Q_{\\text{emp}}(p) - F^{-1}(p)\\big|/\\beta$。\n    4. 支撑集检查：对于 $\\xi < 0$，指示函数 $\\mathbf{1}\\{\\max_{k} x_{k} \\le \\mu - \\beta/\\xi\\}$；对于 $\\xi \\ge 0$，此项默认满足。\n- **验收标准**：\n    1. $R^{2} \\ge 0.9995$\n    2. $|b - 1| \\le 0.02$\n    3. $|a| \\le 0.05\\,\\beta$\n    4. $\\Delta_{\\max} \\le 0.12$\n    5. 支撑集检查必须通过。\n- **测试用例**：\n    1. $(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.25, 1.40, 0.00, 120000, 1729)$\n    2. $(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.00, 2.20, 0.50, 150000, 41041)$\n    3. $(\\xi,\\beta,\\mu,n,\\text{seed}) = (-0.35, 1.10, -0.30, 120000, 271828)$\n\n**步骤2：问题陈述的验证**\n根据所需标准对问题进行评估。\n- **科学依据**：该问题基于极值理论和计算统计学的原理。GPD 是这些领域的标准模型。所有定义，包括 CDF 和统计指标，都是标准且正确的。\n- **适定性**：该问题是适定的。它要求实现一个基于指定种子的伪随机数生成的确定性算法。这确保了存在唯一且可验证的解。所有必要的信息都已提供。\n- **客观性**：该问题以精确的数学和算法术语陈述，没有主观性或模糊性。定义、测试用例和验收标准都得到了完整而清晰的规定。\n\n**步骤 3：结论与行动**\n该问题是有效的。这是计算统计学中一个定义明确的练习，要求实现随机变量生成、分位数分析和统计验证。将提供一个完整的解决方案。\n\n**方法论**\n解决方案将基于逆变换采样法的原理来构建。对于一个具有 CDF $F(x)$ 的连续随机变量，其分位数函数为 $F^{-1}(p)$。如果 $U$ 是一个服从 $(0,1)$ 上标准均匀分布的随机变量，那么随机变量 $X = F^{-1}(U)$ 的 CDF 就是 $F(x)$。\n\n首先，我们推导 GPD 的分位数函数 $F^{-1}(p)$。\n令 $p = F(x)$。我们求解 $x$。\n\n情况 1：$\\xi \\neq 0$\n$$ p = 1 - \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi} $$\n$$ 1-p = \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi} $$\n$$ (1-p)^{-\\xi} = 1 + \\xi \\frac{x-\\mu}{\\beta} $$\n$$ (1-p)^{-\\xi} - 1 = \\xi \\frac{x-\\mu}{\\beta} $$\n$$ x - \\mu = \\frac{\\beta}{\\xi} \\left( (1-p)^{-\\xi} - 1 \\right) $$\n因此，分位数函数为：\n$$ F^{-1}(p;\\xi,\\beta,\\mu) = \\mu + \\frac{\\beta}{\\xi} \\left( (1-p)^{-\\xi} - 1 \\right) $$\n\n情况 2：$\\xi = 0$\n这对应于尺度参数为 $\\beta$、位置参数为 $\\mu$ 的指数分布。\n$$ p = 1 - \\exp\\left(-\\frac{x-\\mu}{\\beta}\\right) $$\n$$ 1-p = \\exp\\left(-\\frac{x-\\mu}{\\beta}\\right) $$\n$$ \\ln(1-p) = -\\frac{x-\\mu}{\\beta} $$\n$$ x - \\mu = -\\beta \\ln(1-p) $$\n因此，分位数函数为：\n$$ F^{-1}(p;0,\\beta,\\mu) = \\mu - \\beta \\ln(1-p) $$\n\n对于每个测试用例，程序将按以下步骤进行：\n1.  为可复现性设置随机数生成器种子。\n2.  从标准均匀分布 $U(0,1)$ 中生成大小为 $n$ 的样本。\n3.  根据 $\\xi$ 的值，使用上面推导出的适当的分位数函数将此样本转换为 GPD 样本。\n4.  构建概率网格 $\\mathcal{P}$ 和 $\\mathcal{P}_{\\text{central}}$。\n5.  通过将分位数函数应用于网格 $\\mathcal{P}$ 中的概率，计算理论分位数向量 $\\mathbf{Q}_{\\text{th}}$。\n6.  根据生成的样本为同一网格 $\\mathcal{P}$ 计算经验分位数向量 $\\mathbf{Q}_{\\text{emp}}$。所提供的 $Q_{\\text{emp}}(p)$ 公式对应于标准的线性插值法，该方法在数值库中可用。\n7.  计算四个指定的指标：\n    a. $R^2$：计算为 $\\mathbf{Q}_{\\text{th}}$ 和 $\\mathbf{Q}_{\\text{emp}}$ 之间皮尔逊相关系数的平方。\n    b. $a, b$：从 $\\mathbf{Q}_{\\text{emp}}$ 对 $\\mathbf{Q}_{\\text{th}}$ 的普通最小二乘线性回归中获得。\n    c. $\\Delta_{\\max}$：通过找到中心网格 $\\mathcal{P}_{\\text{central}}$ 上经验分位数和理论分位数之间的最大绝对差，并用 $\\beta$ 进行归一化来计算。\n    d. 支撑集检查：对于 $\\xi < 0$，确认所有生成的变量都小于或等于支撑集的理论上界 $x_{\\max} = \\mu - \\beta/\\xi$。\n8.  最后，验证是否满足所有五个验收标准。每个测试用例的结果是单个布尔值。\n最终输出是这些布尔结果按指定列表格式的聚合。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Validates GPD random variate generation against theoretical properties\n    for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (xi, beta, mu, n, seed)\n        (0.25, 1.40, 0.00, 120000, 1729),\n        (0.00, 2.20, 0.50, 150000, 41041),\n        (-0.35, 1.10, -0.30, 120000, 271828),\n    ]\n\n    results = []\n    \n    # Define probability grids\n    # P = {0.01, ..., 0.99}\n    p_grid = np.linspace(0.01, 0.99, 99)\n    # P_central = {0.05, ..., 0.95}\n    p_central = np.linspace(0.05, 0.95, 19)\n\n    def gpd_quantile(p, xi, beta, mu):\n        \"\"\"Computes the theoretical quantile for the GPD.\"\"\"\n        if xi == 0:\n            # Handle the case for xi = 0 (Exponential distribution)\n            return mu - beta * np.log(1 - p)\n        else:\n            # Handle the case for xi != 0\n            # Expression ( (1-p)**(-xi) - 1 ) / xi can be written using expm1 for numerical stability\n            # for small xi, as expm1(y)/y -> 1 as y->0.\n            # Here y = -xi * log(1-p).\n            return mu + beta * (np.power(1 - p, -xi) - 1) / xi\n\n    for case in test_cases:\n        xi, beta, mu, n, seed = case\n        \n        # 1. Generate random variates using inverse transform sampling\n        np.random.seed(seed)\n        uniform_samples = np.random.uniform(size=n)\n        gpd_samples = gpd_quantile(uniform_samples, xi, beta, mu)\n\n        # 2. Compute theoretical and empirical quantiles\n        q_th = gpd_quantile(p_grid, xi, beta, mu)\n        q_emp = np.quantile(gpd_samples, p_grid, method='linear')\n\n        # 3. Calculate metrics and perform checks\n        \n        # Metric 1: R^2\n        pearson_r, _ = stats.pearsonr(q_th, q_emp)\n        r_squared = pearson_r**2\n        check1 = r_squared >= 0.9995\n\n        # Metric 2: OLS slope and intercept\n        lin_reg = stats.linregress(x=q_th, y=q_emp)\n        b, a = lin_reg.slope, lin_reg.intercept\n        check2 = abs(b - 1) <= 0.02\n        check3 = abs(a) <= 0.05 * beta\n\n        # Metric 3: Maximum absolute deviation on the central grid\n        q_th_central = gpd_quantile(p_central, xi, beta, mu)\n        q_emp_central = np.quantile(gpd_samples, p_central, method='linear')\n        delta_max = np.max(np.abs(q_emp_central - q_th_central)) / beta\n        check4 = delta_max <= 0.12\n\n        # Metric 4: Support upper endpoint check\n        if xi < 0:\n            support_upper_bound = mu - beta / xi\n            check5 = np.max(gpd_samples) <= support_upper_bound\n        else:\n            # For xi >= 0, the support is unbounded above, so the check is satisfied\n            check5 = True\n\n        # Combine all checks\n        all_criteria_met = all([check1, check2, check3, check4, check5])\n        results.append(all_criteria_met)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "掌握了GPD的基础知识后，我们可以将其作为一个强大的统计推断工具。这个练习将探讨GPD与指数分布之间的特殊联系，这在许多模型中是一种常见的假设。通过检验GPD的形状参数 $\\xi$ 是否为零，我们能有效地判断一个分布的尾部是否呈指数形式。此练习将利用一个受现实世界启发的场景（比特币区块发现时间）和核心的统计方法——似然比检验（Likelihood-Ratio Test），来展示如何应用GPD进行假设检验。[@problem_id:2397475]", "id": "2397475", "problem": "要求您设计并实现一个程序，该程序针对代表比特币区块发现的到达间隔时间合成样本，通过拟合广义帕累托分布 (GPD) 并检验 GPD 形状参数是否为零，来评估高阈值超额分布是否与指数模型一致。该场景依赖以下基本建模基础：在一个强度恒定的齐次泊松过程中，到达间隔时间呈指数分布；对于一个足够高的阈值，超额量的分布可通过广义帕累托分布 (GPD)进行建模。指数分布的情况对应于形状参数为零的 GPD。您必须使用此基础来推导适当的基于似然的推断。\n\n每个测试用例需实现的任务：\n- 根据指定的数据生成过程，生成一个大小为 $n$ 的非负到达间隔时间的独立同分布樣本。两种可能的数据生成过程是：\n  - 均值为 $m$ 的指数分布。\n  - 形状参数为 $\\xi$ 且尺度参数为 $\\beta$ 的广义帕累托分布 (GPD)。\n- 计算经验阈值 $u$ 作为样本的 $q$-分位数，其中给定了 $q \\in (0,1)$。\n- 构建超额量 $Y = \\{X_i - u : X_i > u\\}$。\n- 通过最大似然估计 (MLE) 将 GPD 拟合到 $Y$（位置参数固定为零），并记录估计的形状参数 $\\hat{\\xi}$。\n- 使用似然比检验 (LRT)，在显著性水平 $\\alpha$ 下，检验原假设 $H_0\\!:\\, \\xi = 0$ 与双边备择假设 $H_1\\!:\\, \\xi \\neq 0$。从具有一自由度的渐近卡方分布计算 p 值。\n- 对于每个测试用例，生成三元组 $[\\hat{\\xi}, \\text{p\\_value}, \\text{reject}]$，其中 $\\hat{\\xi}$ 和 $\\text{p\\_value}$ 是浮点数，而 $\\text{reject}$ 是一个布尔值，如果原假设在水平 $\\alpha$ 下被拒绝，则为 true，否则为 false。\n\n重要的实现和输出细节：\n- 您的代码必须是完全确定性的。使用给定的种子初始化随机数生成器，并可复现地抽取所有随机样本。\n- 单位：在合成数据中，到达间隔时间可解释为以秒为单位，但您无需报告任何带单位的量。所有要求的输出都是无量纲的。\n- 最终输出必须是单行文本，包含一个列表的列表，每个内部列表对应一个测试用例，形式为 $[\\hat{\\xi}, \\text{p\\_value}, \\text{reject}]$。整个输出必须严格按照单个 Python 风格的列表字面量打印，例如 $[[x_1, p_1, \\text{True}], [x_2, p_2, \\text{False}], \\ldots]$。在打印输出中，将浮点数 $\\hat{\\xi}$ 和 $\\text{p\\_value}$ 四舍五入到 $6$ 位小数。\n\n需实现和评估的测试套件：\n- 用例 1：种子 = $12345$，分布 = 均值为 $m = 600$ 的指数分布，样本大小 $n = 5000$，阈值分位数 $q = 0.80$，显著性水平 $\\alpha = 0.05$。\n- 用例 2：种子 = $54321$，分布 = $\\xi = 0.25$ 且 $\\beta = 600$ 的 GPD，样本大小 $n = 5000$，阈值分位数 $q = 0.80$，显著性水平 $\\alpha = 0.05$。\n- 用例 3：种子 = $20231105$，分布 = $\\xi = 0.05$ 且 $\\beta = 600$ 的 GPD，样本大小 $n = 6000$，阈值分位数 $q = 0.85$，显著性水平 $\\alpha = 0.05$。\n- 用例 4：种子 = $314159$，分布 = 均值为 $m = 600$ 的指数分布，样本大小 $n = 3000$，阈值分位数 $q = 0.98$，显著性水平 $\\alpha = 0.05$。\n\n您的程序应生成单行输出，其中包含一个 Python 风格的列表的列表，按上述四个用例的顺序给出结果，例如：\n$[[\\hat{\\xi}_1,\\text{p\\_value}_1,\\text{reject}_1],[\\hat{\\xi}_2,\\text{p\\_value}_2,\\text{reject}_2],[\\hat{\\xi}_3,\\text{p\\_value}_3,\\text{reject}_3],[\\hat{\\xi}_4,\\text{p\\_value}_4,\\text{reject}_4]]$。", "solution": "该问题要求实现一个统计程序，以验证一个到达间隔时间数据集是否与指数分布一致。该方法论植根于极值理论 (EVT)，特别是超阈值峰值 (POT) 方法。其核心原理是，对于一大类随机变量，超过一个足够高阈值的数值的分布可以由广义帕累托分布 (GPD) 来近似。GPD 的一个特例，即形状参数 $\\xi$ 等于零时，对应于指数分布。我们将利用这一事实来构建一个假设检验。\n\n每个测试用例的步骤如下：\n$1$。根据指定的参数生成到达间隔时间的合成样本。\n$2$。根据经验将一个高阈值 $u$确定为样本的一个分位数。\n$3$。收集超过此阈值的超额量，$Y = X_i - u$。\n$4$。使用最大似然估计 (MLE) 将 GPD 拟合到这些超额量上。\n$5$。进行似然比检验 (LRT) 以检验原假设 $H_0: \\xi = 0$ 与备择假设 $H_1: \\xi \\neq 0$。\n\n让我们首先建立理论基础。\n\n**1. 广义帕累托分布 (GPD)**\nGPD 是一个双参数分布族，用于对其他分布的尾部进行建模。在位置参数固定为零的情况下，其对于观测值 $y$ 的概率密度函数 (PDF) $f(y; \\xi, \\beta)$ 由下式给出：\n$$\nf(y; \\xi, \\beta) =\n\\begin{cases}\n\\frac{1}{\\beta} \\left(1 + \\frac{\\xi y}{\\beta}\\right)^{-\\frac{1}{\\xi}-1} & \\text{if } \\xi \\neq 0 \\\\\n\\frac{1}{\\beta} \\exp\\left(-\\frac{y}{\\beta}\\right) & \\text{if } \\xi = 0\n\\end{cases}\n$$\n其中 $\\xi$ 是形状参数，$\\beta > 0$ 是尺度参数。当 $\\xi \\ge 0$ 时，支撑集为 $y \\ge 0$；当 $\\xi < 0$ 时，支撑集为 $0 \\le y \\le -\\beta/\\xi$。$\\xi=0$ 的情况恰好是均值为 $\\beta$ 的指数分布。这种关系是我们检验的基石。\n\n**2. 最大似然估计 (MLE)**\n给定一个包含 $N_u$ 个超额量的样本 $Y = \\{y_1, y_2, \\dots, y_{N_u}\\}$，对数似然函数 $\\ell(\\xi, \\beta | Y)$ 是每个观测值的对数概率密度函数之和：\n$$ \\ell(\\xi, \\beta | Y) = \\sum_{i=1}^{N_u} \\ln f(y_i; \\xi, \\beta) $$\n对于 $\\xi \\neq 0$，该函数为：\n$$ \\ell(\\xi, \\beta) = -N_u \\ln \\beta - \\left(\\frac{1}{\\xi} + 1\\right) \\sum_{i=1}^{N_u} \\ln\\left(1 + \\frac{\\xi y_i}{\\beta}\\right) $$\n最大似然估计 $(\\hat{\\xi}, \\hat{\\beta})$ 是使该函数最大化的参数值。这是一个我们将使用计算库解决的数值优化问题。\n\n**3. 似然比检验 (LRT)**\n我们希望检验原假设 $H_0: \\xi = 0$ 与双边备择 hipótese $H_1: \\xi \\neq 0$。LRT 统计量 $\\Lambda$ 定义为无约束模型的最大对数似然与由原假设约束的模型的最大对数似然之差的两倍：\n$$ \\Lambda = 2 \\left( \\sup_{\\xi, \\beta} \\ell(\\xi, \\beta | Y) - \\sup_{\\beta} \\ell(0, \\beta | Y) \\right) $$\n第一项 $\\sup_{\\xi, \\beta} \\ell(\\xi, \\beta | Y) = \\ell(\\hat{\\xi}, \\hat{\\beta} | Y)$ 是在无约束 MLEs $(\\hat{\\xi}, \\hat{\\beta})$ 处求值的对数似然。\n\n第二项 $\\sup_{\\beta} \\ell(0, \\beta | Y)$ 是在 $H_0$（即 $\\xi=0$）下的模型的对数似然。这是一个指数模型。对数似然函数为：\n$$ \\ell(0, \\beta | Y) = -N_u \\ln \\beta - \\frac{1}{\\beta} \\sum_{i=1}^{N_u} y_i $$\n在 $H_0$ 下 $\\beta$ 的 MLE，记为 $\\hat{\\beta}_0$，通过将其关于 $\\beta$ 的导数设为零得到，结果为超额量的样本均值：\n$$ \\hat{\\beta}_0 = \\frac{1}{N_u} \\sum_{i=1}^{N_u} y_i = \\bar{y} $$\n因此，约束下的最大对数似然为 $\\ell(0, \\hat{\\beta}_0 | Y)$。\n\n根据 Wilks 定理，在原假设下，LRT 统计量 $\\Lambda$ 渐近服从卡方分布，其自由度等于在 $H_0$ 下固定的参数数量。在我们的情况中，固定了一个参数（$\\xi$），所以 $\\Lambda \\sim \\chi^2_1$。\n\n检验的 p 值是在假设 $H_0$ 为真的前提下，观测到至少与计算出的检验统计量一样极端的统计量的概率：\n$$ \\text{p-value} = P(\\chi^2_1 \\ge \\Lambda) $$\n如果 p 值小于指定的显著性水平 $\\alpha$，我们拒绝原假设 $H_0$，并断定数据与指数尾部模型不一致。\n\n**算法与实现**\n\n每个测试用例的计算过程如下：\n$1$。**可复现性**：为确保确定性结果，对每个用例使用指定的种子初始化随机数生成器。我们使用 `numpy.random.default_rng`。\n$2$。**数据生成**：\n   - 对于均值为 $m$ 的指数分布，我们使用 `rng.exponential(scale=m, size=n)` 生成 $n$ 个样本。\n   - 对于形状为 $\\xi$、尺度为 $\\beta$ 的 GPD，我们使用 `scipy.stats.genpareto.rvs(c=xi, scale=beta, size=n, random_state=rng)` 生成 $n$ 个样本。\n$3$。**阈值处理**：使用 `numpy.quantile` 计算生成样本 $X$ 的第 $q$ 个分位数作为经验阈值 $u$。然后通过取所有大于 $u$ 的 $X_i$ 并减去阈值来形成超额样本 $Y$，即 $Y=\\{X_i - u | X_i > u\\}$。\n$4$。**无约束 MLE**：通过数值最大化对数似然函数，从样本 $Y$ 中估计 GPD 参数 $(\\hat{\\xi}, \\hat{\\beta})$。我们使用 `scipy.stats.genpareto.fit(Y, floc=0)` 来执行此操作，将位置参数固定为 $0$。这将产生无约束估计 $\\hat{\\xi}$ 和 $\\hat{\\beta}$。\n$5$。**约束 MLE**：在 $H_0: \\xi=0$ 下，分布是指数分布。尺度参数的 MLE $\\hat{\\beta}_0$ 是 $Y$ 的样本均值，通过 `numpy.mean(Y)` 计算。\n$6$。**LRT 计算**：\n   - 使用估计的参数计算无约束对数似然 $\\ell(\\hat{\\xi}, \\hat{\\beta})$：$\\sum \\ln f(y_i; \\hat{\\xi}, \\hat{\\beta})$。\n   - 类似地计算约束对数似然 $\\ell(0, \\hat{\\beta}_0)$：$\\sum \\ln f(y_i; 0, \\hat{\\beta}_0)$。\n   - 检验统计量为 $\\Lambda = 2(\\ell(\\hat{\\xi}, \\hat{\\beta}) - \\ell(0, \\hat{\\beta}_0))$。为了处理可能导致小的负值的数值不准确性，我们取 $\\max(0, \\Lambda)$。\n$7$。**P 值和决策**：P 值是根据 $\\chi^2_1$ 分布的生存函数 `scipy.stats.chi2.sf(\\Lambda, df=1)` 计算的。如果 $\\text{p-value} < \\alpha$，则拒绝原假设。\n$8$。**输出格式化**：收集每个用例产生的三元组 $[\\hat{\\xi}, \\text{p-value}, \\text{reject}]$。浮点值被格式化为 6 位小数，并按要求组装成最终的字符串表示形式。\n\n这种严谨的、由理论驱动的方法确保了对所述问题有一个正确且可复现的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and produce the final output.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'case_id': 1, 'seed': 12345, 'dist': 'exponential', 'params': {'m': 600}, 'n': 5000, 'q': 0.80, 'alpha': 0.05},\n        {'case_id': 2, 'seed': 54321, 'dist': 'gpd', 'params': {'xi': 0.25, 'beta': 600}, 'n': 5000, 'q': 0.80, 'alpha': 0.05},\n        {'case_id': 3, 'seed': 20231105, 'dist': 'gpd', 'params': {'xi': 0.05, 'beta': 600}, 'n': 6000, 'q': 0.85, 'alpha': 0.05},\n        {'case_id': 4, 'seed': 314159, 'dist': 'exponential', 'params': {'m': 600}, 'n': 3000, 'q': 0.98, 'alpha': 0.05},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Initialize RNG for reproducibility\n        rng = np.random.default_rng(case['seed'])\n\n        # Step 2: Generate sample data\n        if case['dist'] == 'exponential':\n            m = case['params']['m']\n            sample_X = rng.exponential(scale=m, size=case['n'])\n        elif case['dist'] == 'gpd':\n            xi, beta = case['params']['xi'], case['params']['beta']\n            # Use scipy's GPD generator, passing the numpy RNG\n            sample_X = stats.genpareto.rvs(c=xi, scale=beta, size=case['n'], random_state=rng)\n\n        # Step 3: Compute threshold and form exceedances\n        u = np.quantile(sample_X, case['q'])\n        exceedances = sample_X[sample_X > u]\n        sample_Y = exceedances - u\n        \n        # Guard against cases with no exceedances\n        if len(sample_Y) == 0:\n            results.append([float('nan'), float('nan'), False])\n            continue\n            \n        # Step 4: Fit GPD to Y (unrestricted model)\n        # floc=0 fixes the location parameter to 0\n        xi_hat, _, beta_hat = stats.genpareto.fit(sample_Y, floc=0)\n\n        # Step 5: Calculate unrestricted log-likelihood\n        log_lik_unrestricted = np.sum(stats.genpareto.logpdf(sample_Y, c=xi_hat, scale=beta_hat, loc=0))\n\n        # Step 6: Fit GPD under H0: xi=0 (restricted model - exponential)\n        # For exponential dist, the MLE of scale is the mean\n        beta_hat_h0 = np.mean(sample_Y)\n        \n        # Step 7: Calculate restricted log-likelihood\n        # GPD with c=0 is exponential\n        log_lik_restricted = np.sum(stats.genpareto.logpdf(sample_Y, c=0, scale=beta_hat_h0, loc=0))\n\n        # Step 8: Compute the Likelihood-Ratio Test statistic\n        lrt_statistic = 2 * (log_lik_unrestricted - log_lik_restricted)\n        # LRT statistic must be non-negative. Small negative values can arise from numerical precision issues.\n        lrt_statistic = max(0, lrt_statistic)\n\n        # Step 9: Compute p-value from chi-square distribution with 1 dof\n        p_value = stats.chi2.sf(lrt_statistic, df=1)\n\n        # Step 10: Decide whether to reject H0\n        reject_h0 = p_value < case['alpha']\n\n        results.append([xi_hat, p_value, reject_h0])\n\n    # Final print statement in the exact required format.\n    # Format each inner list into a string, then join them.\n    formatted_results = []\n    for res in results:\n        xi_str = f\"{res[0]:.6f}\"\n        pval_str = f\"{res[1]:.6f}\"\n        reject_str = str(res[2]) # Converts True to 'True', False to 'False'\n        formatted_results.append(f\"[{xi_str},{pval_str},{reject_str}]\")\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "广义帕累托分布是现代金融风险管理，特别是极值事件建模的基石。最后一个练习将展示正确设定GPD形状参数 $\\xi$ 的极端重要性。通过比较在正确模型与错误设定模型下计算出的预期短缺（Expected Shortfall，一项关键的风险度量），你将亲手量化低估尾部风险所带来的危险。这个练习突显了模型参数的微小差异如何导致风险评估的巨大偏差，强调了在实践中进行严谨模型选择的必要性。[@problem_id:2391806]", "id": "2391806", "problem": "一位风险经理使用超阈值峰值（Peaks-Over-Threshold）框架对投资组合损失的超额部分进行建模。设投资组合损失为随机变量 $L$，并设 $u$ 为一个固定阈值。定义超额损失为 $Y=L-u$，条件是 $L>u$。假设在 $L>u$ 的条件下，超额损失 $Y$ 服从广义帕累托分布（Generalized Pareto Distribution, GPD），其形状参数为 $\\xi$，尺度参数为 $\\beta>0$。$Y$ 的累积分布函数为\n$$F_Y(y)=1-\\left(1+\\frac{\\xi y}{\\beta}\\right)^{-1/\\xi}\\quad\\text{对于 }\\xi\\neq 0,\\ y\\ge 0,\\ 1+\\frac{\\xi y}{\\beta}>0,$$\n以及\n$$F_Y(y)=1-\\exp\\left(-\\frac{y}{\\beta}\\right)\\quad\\text{对于 }\\xi=0,\\ y\\ge 0.$$\n令 $p_u=\\mathbb{P}(L>u)$ 表示超额概率。对于一个无条件概率水平 $\\alpha\\in(0,1)$ 且 $\\alpha>1-p_u$，将风险价值（Value at Risk, VaR）定义为 $\\mathrm{VaR}_\\alpha$，即 $L$ 的 $\\alpha$-分位数。将预期短缺（Expected Shortfall, ES）定义为 $\\mathrm{ES}_\\alpha=\\mathbb{E}[L\\mid L>\\mathrm{VaR}_\\alpha]$，只要其为有限值。\n\n假设真实的尾部是 Fréchet 类型，具有 $\\xi=\\xi_{\\text{true}}>0$ 和 $\\xi_{\\text{true}}<1$（因此 $\\mathrm{ES}_\\alpha$ 是有限的），但一位分析师通过强制设定 $\\xi=0$ 将尾部错误地指定为 Gumbel 类型，同时使用相同的 $u$、$p_u$ 和 $\\beta$。\n\n对于下方的每个测试用例，计算错误设定比率\n$$R=\\frac{\\mathrm{ES}_\\alpha^{\\text{mis}}}{\\mathrm{ES}_\\alpha^{\\text{true}}},$$\n其中 $\\mathrm{ES}_\\alpha^{\\text{true}}$ 是在真实的 $\\xi_{\\text{true}}>0$ 下计算的，而 $\\mathrm{ES}_\\alpha^{\\text{mis}}$ 是在错误设定的 $\\xi=0$ 下计算的，两者都使用相同的 $u$、$p_u$ 和 $\\beta$。所有计算都应遵循上述定义以及广义帕累托分布和条件超额损失的标准性质。将每个 $R$ 表达为保留6位小数的十进制数。\n\n测试套件（每个元组为 $(u,p_u,\\beta,\\xi_{\\text{true}},\\alpha)$）：\n- 用例 1：$(1.0,0.05,1.5,0.3,0.99)$\n- 用例 2：$(1.0,0.10,0.7,0.05,0.98)$\n- 用例 3：$(0.5,0.02,1.0,0.9,0.999)$\n- 用例 4：$(2.0,0.01,0.8,0.4,0.995)$\n\n您的程序必须生成单行输出，其中包含所有用例的结果，形式为逗号分隔的列表并用方括号括起（例如 $[r_1,r_2,r_3,r_4]$），顺序与测试套件相同，每个 $r_i$ 保留6位小数。", "solution": "该问题要求计算预期短缺（ES）风险度量的错误设定比率。这是一个量化风险管理中的标准问题，需要严格应用极值理论（EVT）中的定义。我们应首先验证问题的陈述，然后着手推导必要的公式。\n\n验证步骤确认了该问题在科学上是合理的、提法得当且客观的。\n按要求逐字提取给定条件：\n- 投资组合损失是随机变量 $L$。\n- 阈值是 $u$。\n- 超额损失是在 $L>u$ 条件下的 $Y=L-u$。\n- $Y$ 的分布是广义帕累托（GPD）分布，形状参数为 $\\xi$，尺度参数为 $\\beta>0$。\n- 当 $\\xi\\neq 0$ 时，$Y$ 的累积分布函数为：$F_Y(y)=1-\\left(1+\\frac{\\xi y}{\\beta}\\right)^{-1/\\xi}$。\n- 当 $\\xi=0$ 时，$Y$ 的累积分布函数为：$F_Y(y)=1-\\exp\\left(-\\frac{y}{\\beta}\\right)$。\n- 超额概率是 $p_u=\\mathbb{P}(L>u)$。\n- 风险价值是 $\\mathrm{VaR}_\\alpha$，即 $L$ 对于 $\\alpha \\in (0,1)$ 且 $\\alpha > 1-p_u$ 的 $\\alpha$-分位数。\n- 预期短缺是 $\\mathrm{ES}_\\alpha=\\mathbb{E}[L\\mid L>\\mathrm{VaR}_\\alpha]$。\n- 真实模型具有 Fréchet 类型的尾部，$\\xi=\\xi_{\\text{true}} \\in (0,1)$。\n- 错误设定的模型具有 Gumbel 类型的尾部，$\\xi=0$。\n- 参数 $u$、$p_u$ 和 $\\beta$ 保持不变。\n- 任务是计算比率 $R=\\frac{\\mathrm{ES}_\\alpha^{\\text{mis}}}{\\mathrm{ES}_\\alpha^{\\text{true}}}$。\n- 测试用例以元组 $(u, p_u, \\beta, \\xi_{\\text{true}}, \\alpha)$ 的形式提供。\n\n问题是有效的。它是超阈值峰值（POT）方法论的标准应用，建立在公认的数学和统计学原理之上。所有定义和条件都是标准的、完整的且一致的。条件 $\\alpha > 1-p_u$ 确保了 $\\mathrm{VaR}_\\alpha > u$，将分位数置于由 GPD 建模的尾部区域。条件 $\\xi_{\\text{true}} < 1$ 确保了 GPD 的一阶矩以及预期短缺是有限的。我们继续进行求解。\n\n推导分三步进行：首先，我们推导 $\\mathrm{VaR}_\\alpha$ 的一般表达式；其次，我们推导 $\\mathrm{ES}_\\alpha$ 的一般表达式；第三，我们将这些表达式特殊化，用于真实模型和错误设定模型，并构造比率。\n\n**1. 风险价值（$\\mathrm{VaR}_\\alpha$）的推导**\n\nPOT 模型将 $L$ 的无条件尾部与超额损失 $Y$ 的条件分布联系起来。对于任何损失水平 $l > u$，$L$ 的尾部概率由下式给出：\n$$ \\mathbb{P}(L > l) = \\mathbb{P}(L > l \\mid L > u) \\cdot \\mathbb{P}(L > u) $$\n这可以用超额损失 $Y = L - u$ 及其生存函数 $S_Y(y) = 1 - F_Y(y)$ 来表示：\n$$ \\mathbb{P}(L > l) = \\mathbb{P}(Y > l - u) \\cdot p_u = S_Y(l-u) \\cdot p_u $$\n根据定义，$\\mathrm{VaR}_\\alpha$ 是使得 $\\mathbb{P}(L > \\mathrm{VaR}_\\alpha) = 1-\\alpha$ 的值。我们有：\n$$ 1-\\alpha = S_Y(\\mathrm{VaR}_\\alpha - u) \\cdot p_u $$\n$$ S_Y(\\mathrm{VaR}_\\alpha - u) = \\frac{1-\\alpha}{p_u} $$\n令 $y_\\alpha = \\mathrm{VaR}_\\alpha - u$。值 $y_\\alpha$ 是对应于概率 $q = 1 - \\frac{1-\\alpha}{p_u}$ 的 GPD 分位数。GPD 的逆累积分布函数（分位数函数）$F_Y^{-1}(q) = y$ 为：\n$$ y = \\begin{cases} \\frac{\\beta}{\\xi}\\left((1-q)^{-\\xi} - 1\\right) & \\text{若 } \\xi \\neq 0 \\\\ -\\beta \\ln(1-q) & \\text{若 } \\xi = 0 \\end{cases} $$\n代入 $1-q = \\frac{1-\\alpha}{p_u}$ 得到 $y_\\alpha$ 的表达式：\n$$ y_\\alpha = \\begin{cases} \\frac{\\beta}{\\xi}\\left(\\left(\\frac{1-\\alpha}{p_u}\\right)^{-\\xi} - 1\\right) = \\frac{\\beta}{\\xi}\\left(\\left(\\frac{p_u}{1-\\alpha}\\right)^{\\xi} - 1\\right) & \\text{若 } \\xi \\neq 0 \\\\ -\\beta \\ln\\left(\\frac{1-\\alpha}{p_u}\\right) = \\beta \\ln\\left(\\frac{p_u}{1-\\alpha}\\right) & \\text{若 } \\xi = 0 \\end{cases} $$\n最后，由于 $\\mathrm{VaR}_\\alpha = u + y_\\alpha$，我们得到了 $\\mathrm{VaR}_\\alpha$ 的公式。\n\n**2. 预期短缺（$\\mathrm{ES}_\\alpha$）的推导**\n\n$\\mathrm{ES}_\\alpha$ 被定义为条件期望 $\\mathbb{E}[L \\mid L > \\mathrm{VaR}_\\alpha]$。由于 $\\mathrm{VaR}_\\alpha > u$，条件 $L > \\mathrm{VaR}_\\alpha$ 意味着 $L > u$。因此，我们可以将 $L$ 表示为 $u+Y$：\n$$ \\mathrm{ES}_\\alpha = \\mathbb{E}[u+Y \\mid u+Y > \\mathrm{VaR}_\\alpha] = u + \\mathbb{E}[Y \\mid Y > \\mathrm{VaR}_\\alpha - u] = u + \\mathbb{E}[Y \\mid Y > y_\\alpha]$$\n条件期望 $\\mathbb{E}[Y \\mid Y > y_\\alpha]$ 可以使用 GPD 的平均超额函数 $e(z) = \\mathbb{E}[Y-z \\mid Y > z]$ 来表示。\n$$ \\mathbb{E}[Y \\mid Y > y_\\alpha] = y_\\alpha + \\mathbb{E}[Y-y_\\alpha \\mid Y > y_\\alpha] = y_\\alpha + e(y_\\alpha) $$\n因此，$\\mathrm{ES}_\\alpha = u + y_\\alpha + e(y_\\alpha) = \\mathrm{VaR}_\\alpha + e(\\mathrm{VaR}_\\alpha - u)$。对于 $\\xi < 1$ 的 GPD，其平均超额函数为：\n$$ e(z) = \\frac{\\beta + \\xi z}{1-\\xi} $$\n对于 $\\xi=0$ 的特殊情况（指数分布），此式简化为 $e(z) = \\beta$，这与无记忆性相符。\n将此代入 $\\mathrm{ES}_\\alpha$ 的表达式中：\n$$ \\mathrm{ES}_\\alpha = \\mathrm{VaR}_\\alpha + \\frac{\\beta + \\xi(\\mathrm{VaR}_\\alpha - u)}{1-\\xi} $$\n通过代入已推导出的 $\\mathrm{VaR}_\\alpha - u = y_\\alpha$ 的形式，可以得到一个简化的表达式：\n$$ \\mathrm{ES}_\\alpha = \\mathrm{VaR}_\\alpha + \\frac{\\beta + \\xi y_\\alpha}{1-\\xi} $$\n\n**3. 真实模型和错误设定模型的具体化**\n\n我们现在将这些通用公式应用于两种情景。令 $Z = \\frac{p_u}{1-\\alpha}$。\n\n_真实模型：_ $\\xi = \\xi_{\\text{true}} \\in (0, 1)$\n$$ \\mathrm{VaR}_\\alpha^{\\text{true}} = u + \\frac{\\beta}{\\xi_{\\text{true}}}\\left(Z^{\\xi_{\\text{true}}} - 1\\right) $$\n$$ \\mathrm{ES}_\\alpha^{\\text{true}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta + \\xi_{\\text{true}}(\\mathrm{VaR}_\\alpha^{\\text{true}} - u)}{1-\\xi_{\\text{true}}} $$\n代入 $\\mathrm{VaR}_\\alpha^{\\text{true}} - u$：\n$$ \\mathrm{ES}_\\alpha^{\\text{true}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta + \\xi_{\\text{true}}\\left(\\frac{\\beta}{\\xi_{\\text{true}}}\\left(Z^{\\xi_{\\text{true}}} - 1\\right)\\right)}{1-\\xi_{\\text{true}}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta + \\beta(Z^{\\xi_{\\text{true}}} - 1)}{1-\\xi_{\\text{true}}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta Z^{\\xi_{\\text{true}}}}{1-\\xi_{\\text{true}}} $$\n\n_错误设定的模型：_ $\\xi = 0$\n$$ \\mathrm{VaR}_\\alpha^{\\text{mis}} = u + \\beta \\ln(Z) $$\n$$ \\mathrm{ES}_\\alpha^{\\text{mis}} = \\mathrm{VaR}_\\alpha^{\\text{mis}} + \\frac{\\beta + 0 \\cdot (\\mathrm{VaR}_\\alpha^{\\text{mis}} - u)}{1-0} = \\mathrm{VaR}_\\alpha^{\\text{mis}} + \\beta $$\n\n因此，错误设定比率 $R$ 为：\n$$ R = \\frac{\\mathrm{ES}_\\alpha^{\\text{mis}}}{\\mathrm{ES}_\\alpha^{\\text{true}}} = \\frac{u + \\beta \\ln\\left(\\frac{p_u}{1-\\alpha}\\right) + \\beta}{u + \\frac{\\beta}{\\xi_{\\text{true}}}\\left(\\left(\\frac{p_u}{1-\\alpha}\\right)^{\\xi_{\\text{true}}} - 1\\right) + \\frac{\\beta \\left(\\frac{p_u}{1-\\alpha}\\right)^{\\xi_{\\text{true}}}}{1-\\xi_{\\text{true}}}} $$\n这些公式被用于实现，以计算每个测试用例所需的比率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the misspecification ratio R = ES_mis / ES_true for several test cases.\n    \"\"\"\n    # Test cases: (u, p_u, beta, xi_true, alpha)\n    test_cases = [\n        (1.0, 0.05, 1.5, 0.3, 0.99),\n        (1.0, 0.10, 0.7, 0.05, 0.98),\n        (0.5, 0.02, 1.0, 0.9, 0.999),\n        (2.0, 0.01, 0.8, 0.4, 0.995)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        u, p_u, beta, xi_true, alpha = case\n        \n        # Helper term Z\n        z_factor = p_u / (1 - alpha)\n\n        # --- True Model Calculation (xi = xi_true > 0) ---\n        \n        # Power term for true model\n        z_pow_xi = np.power(z_factor, xi_true)\n        \n        # VaR_true\n        var_true = u + (beta / xi_true) * (z_pow_xi - 1)\n        \n        # ES_true\n        # The formula derived is ES_true = VaR_true + (beta * Z^xi_true) / (1 - xi_true)\n        es_true = var_true + (beta * z_pow_xi) / (1 - xi_true)\n\n        # --- Misspecified Model Calculation (xi = 0) ---\n        \n        # VaR_mis\n        # The formula is VaR_mis = u + beta * log(Z)\n        var_mis = u + beta * np.log(z_factor)\n\n        # ES_mis\n        # The formula is ES_mis = VaR_mis + beta\n        es_mis = var_mis + beta\n        \n        # --- Ratio Calculation ---\n        ratio = es_mis / es_true\n        results.append(f\"{ratio:.6f}\") # Format to 6 decimal places\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}