{"hands_on_practices": [{"introduction": "在掌握了分块最大值法之后，我们转向另一种在数据利用上更高效的方法——超阈值峰值法（Peak-Over-Threshold, POT）。与BMM每个区块只取一个最大值不同，POT方法利用了所有超过某个高阈值的数据点，因此在数据有限时能提供更稳健的估计。在这个练习中[@problem_id:2391805]，你将应用广义帕累托分布（Generalized Pareto Distribution, GPD）来为网站延迟的极端峰值建模，并估算在特定业务场景下发生灾难性故障的概率，这是一个现代运营风险管理中的典型应用。", "id": "2391805", "problem": "您将处理一个来自某大型在线零售商的操作风险管理场景。在销售高峰期，网站延迟的峰值可能会引发级联故障，从而构成灾难性中断。极值理论 (EVT) 认为，在极限情况下，超过一个足够高阈值的超出量可以很好地用广义帕累托分布 (GPD) 来建模。您的任务是编写一个完整的程序，利用这一原理，从合成的延迟数据中估计尾部指数（即 GPD 形状参数），并计算在有限事件期间，假设请求是独立的情况下，至少发生一次灾难性故障的概率。\n\n基本原理：\n- 在超阈值峰值框架中，对于一个足够高的阈值 $u$，超过 $u$ 的超出量的分布作为一个极限定理收敛于广义帕累托分布 (GPD)。\n- 尾部指数是 GPD 的形状参数，通常用 $\\xi$ 表示。\n- 独立性下的稀有事件定律意味着，如果单次请求的灾难性故障概率为 $p$，那么在 $N$ 次独立请求中至少发生一次灾难性故障的概率是 $1-(1-p)^N$。\n\n您的程序必须为每个测试用例执行以下操作：\n1. 使用一个双组分混合模型，生成一个大小为 $n$ 的网站延迟观测值（单位：毫秒）的合成数据集：\n   - 以概率 $p_{\\text{tail}}$，从一个最小值为 $x_m$、形状为 $\\alpha$ 的帕累托尾部进行抽样，使用变换 $X_{\\text{tail}} = x_m \\cdot (1 + P)$，其中 $P$ 服从形状为 $\\alpha$、支撑集在 $(0,\\infty)$ 上的标准帕累托分布。\n   - 以概率 $1-p_{\\text{tail}}$，从一个对数位置参数为 $\\mu$、对数尺度参数为 $\\sigma$ 的对数正态分布中抽样，得到 $X_{\\text{base}} \\sim \\text{Lognormal}(\\mu,\\sigma)$，其支撑集在 $(0,\\infty)$ 上。\n   - 以概率 $p_{\\text{tail}}$ 将抽样结果组合为 $X = X_{\\text{tail}}$，以概率 $1-p_{\\text{tail}}$ 组合为 $X = X_{\\text{base}}$。\n2. 选择样本中水平为 $q_u$ 的经验分位数作为高阈值 $u$。\n3. 对于所有满足 $X > u$ 的观测值，形成超出量 $Y = X - u$，并使用最大似然估计法估计这些超出量的 GPD 参数（形状 $\\xi$ 和尺度 $\\beta$），同时强制 GPD 的位置参数为 $0$。\n4. 将超过 $u$ 的尾部概率估计为 $p_u = k/n$，其中 $k$ 是超出量的数量。\n5. 对于一个灾难性延迟阈值 $z$（其中 $z > u$），通过 GPD 尾部近似与经验超出率相结合来近似延迟超过 $z$ 的概率。使用 $p_z \\approx p_u$ 乘以超过 $u$ 的条件尾部概率，并通过其连续极限来处理 $\\xi = 0$ 的特殊情况。\n6. 使用独立性假设，计算一个包含 $N$ 次独立请求的事件中，至少发生一次灾难性故障的概率。\n7. 将这个最终概率以浮点数形式报告，并四舍五入到六位小数。\n\n不涉及角度单位。延迟输入数据的单位是毫秒，但要求的输出是概率，因此无单位。您必须用小数表示最终的概率结果。\n\n测试套件：\n请为以下三组参数集提供结果。对于每种情况，请应用给定的精确值。\n\n- 情况 A:\n  - 随机种子 $= 202311$\n  - $n = 50000$\n  - $p_{\\text{tail}} = 0.15$\n  - 帕累托形状 $\\alpha = 2.0$\n  - 帕累托最小值 $x_m = 150$\n  - 对数正态 $\\mu = 3.7$\n  - 对数正态 $\\sigma = 0.35$\n  - 阈值分位数 $q_u = 0.95$\n  - 灾难性阈值 $z = 1000$\n  - 事件大小 $N = 200000$\n- 情况 B:\n  - 随机种子 $= 7$\n  - $n = 80000$\n  - $p_{\\text{tail}} = 0.05$\n  - 帕累托形状 $\\alpha = 1.4$\n  - 帕累托最小值 $x_m = 200$\n  - 对数正态 $\\mu = 3.5$\n  - 对数正态 $\\sigma = 0.5$\n  - 阈值分位数 $q_u = 0.97$\n  - 灾难性阈值 $z = 1500$\n  - 事件大小 $N = 1000000$\n- 情况 C:\n  - 随机种子 $= 4242$\n  - $n = 60000$\n  - $p_{\\text{tail}} = 0.10$\n  - 帕累托形状 $\\alpha = 3.5$\n  - 帕累托最小值 $x_m = 120$\n  - 对数正态 $\\mu = 3.6$\n  - 对数正态 $\\sigma = 0.4$\n  - 阈值分位数 $q_u = 0.90$\n  - 灾难性阈值 $z = 800$\n  - 事件大小 $N = 100000$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三种情况的概率，形式为用方括号括起来的逗号分隔列表，每个概率都四舍五入到六位小数。例如，格式必须与 $[r_1,r_2,r_3]$ 完全一样，其中每个 $r_i$ 是一个小数点后有六位数的小数。", "solution": "该问题陈述被认为是有效的。它提出了一个基于极值理论的、在量化风险管理领域中定义明确且具有科学依据的问题。唯一、可验证的解决方案所需的所有必要组件均已提供。我们接下来进行解决方案的推导和实现。\n\n核心任务是通过对延迟分布的尾部进行建模，来估计网站发生灾难性延迟事件的概率。该方法论遵循超阈值峰值 (POT) 框架的原则。\n\n1.  **合成数据生成**\n    延迟数据 $X$ 是从一个大小为 $n$ 的双组分混合模型中合成的。该模型同时捕捉了典型行为和极端事件。\n    -   '基础'组分，从对数正态分布 $X_{\\text{base}} \\sim \\text{Lognormal}(\\mu, \\sigma)$ 中抽取，代表了大部分的延迟观测值。对数正态分布常用于为具有正偏度的非负量建模。\n    -   '尾部'组分，代表极端延迟，从帕累托分布中抽取。问题指定其生成方式为 $X_{\\text{tail}} = x_m \\cdot (1 + P)$，其中 $P$ 是一个形状为 $\\alpha$、支撑集在 $(0, \\infty)$ 上的标准帕累托变量。支撑集在 $(0, \\infty)$ 上的标准帕累托分布可解释为尺度参数 $\\lambda=1$ 的洛马克斯 (Lomax) 分布。此分布的一个变量 $P$ 可以通过逆变换采样生成，即 $P = U^{-1/\\alpha} - 1$，其中 $U \\sim \\text{Uniform}(0,1)$。将此代入 $X_{\\text{tail}}$ 的表达式中，得到 $X_{\\text{tail}} = x_m (1 + (U^{-1/\\alpha} - 1)) = x_m U^{-1/\\alpha}$。这是从一个最小值为 $x_m$、形状参数为 $\\alpha$ 的 I 型帕累托分布中生成变量的公式。这种解释既是标准的，也是自洽的。\n    每个样本以概率 $p_{\\text{tail}}$ 从尾部组分中抽取，以概率 $1 - p_{\\text{tail}}$ 从基础组分中抽取。\n\n2.  **阈值选择与超出量**\n    POT 方法需要定义一个高阈值 $u$ 来将极端事件与大部分数据分离开。我们选择合成数据集在高概率水平 $q_u$ 处的经验分位数作为 $u$。超过此阈值的观测值 $X_i$ 产生超出量，定义为 $Y_i = X_i - u$。\n\n3.  **广义帕累托分布 (GPD) 拟合**\n    根据 Pickands–Balkema–de Haan 定理，对于一个足够高的阈值 $u$，超出量 $Y = X - u$ 的分布收敛于一个广义帕累托分布 (GPD)。GPD 的累积分布函数 (CDF) 如下：\n    $$ G_{\\xi, \\beta}(y) = \\begin{cases} 1 - \\left(1 + \\frac{\\xi y}{\\beta}\\right)^{-1/\\xi} & \\text{if } \\xi \\neq 0 \\\\ 1 - \\exp(-y/\\beta) & \\text{if } \\xi = 0 \\end{cases} $$\n    对于 $y > 0$。其参数为形状参数 $\\xi$（尾部指数）和尺度参数 $\\beta > 0$。根据超出量的定义，位置参数固定为 $0$。\n    参数 $(\\xi, \\beta)$ 是通过对观测到的超出量最大化 GPD 的对数似然函数来估计的。这是一个数值优化问题，可以通过使用成熟的库函数（如 `scipy.stats.genpareto.fit`）可靠地解决，该函数实现了最大似然估计 (MLE)。\n\n4.  **极值事件概率估计**\n    单个延迟 $X$ 超过灾难性阈值 $z$ （其中 $z > u$）的概率记为 $p_z = P(X > z)$。使用全概率公式，我们将其分解为：\n    $$ p_z = P(X > z | X > u) \\cdot P(X > u) $$\n    -   项 $P(X > u)$ 是从数据中经验估计的。设在总共 $n$ 个观测值中，有 $k$ 个超过 $u$。那么，$P(X > u) \\approx p_u = k/n$。\n    -   条件概率 $P(X > z | X > u)$ 是指超出量 $Y = X-u$ 大于 $z-u$ 的概率。这个概率由拟合的 GPD 的生存函数 $S_{\\text{GPD}}(y) = 1 - G_{\\text{GPD}}(y)$ 在 $y = z-u$ 处的值给出。\n    $$ P(X > z | X > u) = S_{\\text{GPD}}(z-u) = \\left(1 + \\frac{\\hat{\\xi} (z-u)}{\\hat{\\beta}}\\right)^{-1/\\hat{\\xi}} $$\n    其中 $\\hat{\\xi}$ 和 $\\hat{\\beta}$ 是 GPD 参数的最大似然估计值。$\\xi=0$ 的情况通过其连续极限处理，得到一个指数生存函数。\n    将这些结合起来，得到 $p_z$ 的最终估计值：\n    $$ p_z \\approx \\frac{k}{n} \\left(1 + \\frac{\\hat{\\xi} (z-u)}{\\hat{\\beta}}\\right)^{-1/\\hat{\\xi}} $$\n\n5.  **聚合风险概率**\n    最终关注的量是在一个包含 $N$ 次独立请求的事件中，至少发生一次灾难性故障的概率。如果单次故障的概率是 $p_z$，那么在 $N$ 次试验中没有发生故障的概率是 $(1 - p_z)^N$。因此，至少发生一次故障的概率是：\n    $$ P(\\text{at least one}) = 1 - (1 - p_z)^N $$\n    对于较小的 $p_z$，直接计算此表达式可能会导致数值精度损失。通过使用对数和指数减一函数可以实现更稳定的计算：$P(\\text{at least one}) = -\\text{expm1}(N \\cdot \\text{log1p}(-p_z))$。这样可以避免灾难性抵消并保持精度。最终结果按要求四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import genpareto\n\ndef run_case(seed, n, p_tail, alpha, xm, mu, sigma, q_u, z, N):\n    \"\"\"\n    Solves a single test case for catastrophic failure probability estimation.\n    \"\"\"\n    # Step 1: Generate synthetic dataset from a two-component mixture model.\n    rng = np.random.default_rng(seed)\n    \n    # Determine which samples come from the tail vs. the base distribution.\n    is_tail = rng.random(size=n) < p_tail\n    n_tail = np.sum(is_tail)\n    n_base = n - n_tail\n\n    # Generate Pareto tail data using inverse transform sampling.\n    # The generation rule X_tail = xm * (1 + P) where P is standard Pareto on (0,inf)\n    # simplifies to sampling from a Pareto Type I distribution with minimum xm.\n    uniform_samples = rng.random(size=n_tail)\n    data_tail = xm / (uniform_samples**(1/alpha))\n\n    # Generate Lognormal base data.\n    data_base = rng.lognormal(mean=mu, sigma=sigma, size=n_base)\n\n    # Combine into a single dataset.\n    data = np.empty(n, dtype=float)\n    data[is_tail] = data_tail\n    data[~is_tail] = data_base\n\n    # Step 2: Choose a high threshold 'u' as an empirical quantile.\n    u = np.quantile(data, q_u)\n\n    # Step 3: Form exceedances and fit the Generalized Pareto Distribution (GPD).\n    exceedances = data[data > u] - u\n    \n    if len(exceedances) == 0:\n        # If there are no exceedances, the probability of an even more extreme event is zero.\n        return 0.0\n\n    # Use scipy's robust Maximum Likelihood Estimation for GPD parameters (xi, beta).\n    # 'floc=0' enforces the location parameter to be 0, as per the definition of exceedances.\n    # The fit returns (shape, location, scale) which correspond to (xi, 0, beta).\n    xi, _, beta = genpareto.fit(exceedances, floc=0)\n\n    # Step 4: Estimate the empirical probability of exceeding the threshold u.\n    k = len(exceedances)\n    p_u = k / n\n\n    # Step 5: Approximate the probability of a single latency exceeding z.\n    # p_z = P(X > z) = P(X > u) * P(X > z | X > u)\n    # The conditional probability is calculated using the GPD survival function.\n    # The problem statement ensures z > u, so (z - u) > 0.\n    y_z = z - u\n    prob_cond_exceed_z = genpareto.sf(y_z, c=xi, scale=beta, loc=0)\n    p_z = p_u * prob_cond_exceed_z\n\n    # Step 6: Compute the probability of at least one catastrophic failure in N requests.\n    # The calculation uses numerically stable functions to avoid precision loss.\n    # P(at least one) = 1 - (1 - p_z)^N = -expm1(N * log1p(-p_z))\n    if p_z >= 1.0:\n        # If a single event is guaranteed to be catastrophic, so is any sequence of events.\n        prob_final = 1.0\n    elif p_z <= 0.0:\n        prob_final = 0.0\n    else:\n        prob_final = -np.expm1(N * np.log1p(-p_z))\n\n    return prob_final\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        (202311, 50000, 0.15, 2.0, 150, 3.7, 0.35, 0.95, 1000, 200000),\n        # Case B\n        (7, 80000, 0.05, 1.4, 200, 3.5, 0.5, 0.97, 1500, 1000000),\n        # Case C\n        (4242, 60000, 0.10, 3.5, 120, 3.6, 0.4, 0.90, 800, 100000),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Execute the main logic for one case.\n        final_probability = run_case(*case)\n        # Format the result to six decimal places.\n        results.append(f\"{final_probability:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "现实世界中的金融风险往往不是孤立出现的，因此，理解多个极端事件同时发生的概率对于全面的风险管理至关重要。最后一个练习将带领你从单变量分析扩展到多变量极值理论的领域[@problem_id:2391764]。本练习将介绍Copula函数，这是一种强大的工具，用于对不同风险因子尾部之间的依赖结构进行建模。你将运用一个具体的Copula模型（Gumbel-Hougaard），结合之前所学的GPD边际分布模型，来计算类似石油价格冲击和股市大跌等两种极端市场事件同时发生的联合概率。", "id": "2391764", "problem": "您的任务是使用多元极值理论实现一个程序，计算两个金融风险事件的联合尾部概率。设 $X$ 表示单日石油现货价格的跳跃，单位为美元/桶（右尾，大的正向变动），设 $Y$ 表示单日股指损失的幅度，单位为百分点（右尾，以绝对百分点表示的大额损失，不带百分号）。目标是在以下模型假设下，对指定的阈值 $x^\\star$（单位：美元）和 $y^\\star$（单位：百分点），计算概率 $\\mathbb{P}(X > x^\\star, Y > y^\\star)$。\n\n模型规格：\n- 边际尾部：对于 $X$ 和 $Y$，在各自的固定阈值 $u_X$ 和 $u_Y$ 之上，使用带有广义帕累托分布 (GPD) 的超阈值模型。对于 $X$，在 $X > u_X$ 的条件下，定义超出量 $Z_X = X - u_X$。对于 $Y$，在 $Y > u_Y$ 的条件下，定义超出量 $Z_Y = Y - u_Y$。GPD 超出量的条件生存函数为\n  $$ \\mathbb{P}(Z > z \\mid Z \\ge 0) = \\begin{cases}\n  \\left(1 + \\dfrac{\\xi z}{\\beta}\\right)^{-1/\\xi}, & \\xi \\ne 0, \\, 1 + \\dfrac{\\xi z}{\\beta} > 0, \\\\\n  \\exp\\!\\left(-\\dfrac{z}{\\beta}\\right), & \\xi = 0,\n  \\end{cases} $$\n  其中 $\\beta > 0$ 是尺度参数，$\\xi$ 是形状参数。对于 $\\xi < 0$，支撑集有上界 $z < -\\beta/\\xi$；超出此界限，尾部概率为零。在任意 $t \\ge u$ 处的无条件尾部概率为\n  $$ \\mathbb{P}(X > t) = \\mathbb{P}(X > u_X) \\cdot \\mathbb{P}(Z_X > t - u_X \\mid X > u_X), \\quad \\mathbb{P}(Y > t) = \\mathbb{P}(Y > u_Y) \\cdot \\mathbb{P}(Z_Y > t - u_Y \\mid Y > u_Y). $$\n  量 $\\mathbb{P}(X > u_X)$ 和 $\\mathbb{P}(Y > u_Y)$ 作为输入给出。\n- 相关性结构：$(X,Y)$ 的联合分布由一个参数为 $\\theta \\ge 1$ 的 Gumbel–Hougaard 形式的极值 copula 指定：\n  $$ C(u,v) = \\exp\\!\\left(-\\left((-\\ln u)^{\\theta} + (-\\ln v)^{\\theta}\\right)^{1/\\theta}\\right), \\quad u,v \\in (0,1]. $$\n- 联合尾部概率：对于任意阈值 $x^\\star \\ge u_X$ 和 $y^\\star \\ge u_Y$，以及边际分布函数 $F_X$ 和 $F_Y$，联合尾部概率满足\n  $$ \\mathbb{P}(X > x^\\star, Y > y^\\star) = 1 - F_X(x^\\star) - F_Y(y^\\star) + C(F_X(x^\\star), F_Y(y^\\star)). $$\n\n全局阈值：\n- 石油价格跳跃阈值 $u_X = 10$ 美元。\n- 股票损失阈值 $u_Y = 2$ 百分点。\n\n您的任务：\n- 对于下方的每个测试用例，计算 $\\mathbb{P}(X > x^\\star, Y > y^\\star)$ 的值，结果为小数。\n- 如果一个阈值 $t$ 超过了由负形状参数 $\\xi < 0$ 所隐含的有限上端点（即，$t - u \\ge -\\beta/\\xi$），则相应的边际尾部概率为零。\n- 所有结果必须以小数形式表示（不带百分号），并四舍五入到六位小数。\n\n测试套件（每行指定 $(\\beta_X, \\xi_X, p_{X0}, \\beta_Y, \\xi_Y, p_{Y0}, \\theta, x^\\star, y^\\star)$，其中 $p_{X0} = \\mathbb{P}(X > u_X)$ 且 $p_{Y0} = \\mathbb{P}(Y > u_Y)$）：\n1. $(\\beta_X = 8, \\, \\xi_X = 0.2, \\, p_{X0} = 0.05, \\, \\beta_Y = 1.5, \\, \\xi_Y = 0.1, \\, p_{Y0} = 0.10, \\, \\theta = 2, \\, x^\\star = 20, \\, y^\\star = 5)$\n2. $(\\beta_X = 5, \\, \\xi_X = 0, \\, p_{X0} = 0.02, \\, \\beta_Y = 1.2, \\, \\xi_Y = 0.2, \\, p_{Y0} = 0.04, \\, \\theta = 1, \\, x^\\star = 25, \\, y^\\star = 3)$\n3. $(\\beta_X = 10, \\, \\xi_X = 0.3, \\, p_{X0} = 0.03, \\, \\beta_Y = 2.0, \\, \\xi_Y = 0.3, \\, p_{Y0} = 0.08, \\, \\theta = 10, \\, x^\\star = 10, \\, y^\\star = 2)$\n4. $(\\beta_X = 6, \\, \\xi_X = 0.2, \\, p_{X0} = 0.04, \\, \\beta_Y = 1.5, \\, \\xi_Y = -0.2, \\, p_{Y0} = 0.03, \\, \\theta = 1.5, \\, x^\\star = 20, \\, y^\\star = 10)$\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，\"[r1,r2,r3,r4]\"），结果顺序与测试用例相同。每个 $r_i$ 必须是一个四舍五入到六位小数的浮点数。", "solution": "问题陈述已经过评估并被确定为有效。它在科学上基于多元极值理论的既定原则，这是计算金融学中用于风险管理的一种标准方法。该问题提法恰当，提供了所有必要的定义、参数和一个清晰、客观的计算目标。它是自洽的，没有矛盾或歧义。因此，将提供一个解决方案。\n\n目标是计算代表金融风险事件的两个随机变量 $X$ 和 $Y$ 的联合尾部概率 $\\mathbb{P}(X > x^\\star, Y > y^\\star)$。问题指定了边际尾部模型及其相关性结构。解决方案是通过系统地应用所提供的公式得出的。\n\n基于容斥原理和 copula 的定义，联合尾部概率的基本公式如下：\n$$ \\mathbb{P}(X > x^\\star, Y > y^\\star) = 1 - F_X(x^\\star) - F_Y(y^\\star) + C(F_X(x^\\star), F_Y(y^\\star)) $$\n其中 $F_X$ 和 $F_Y$ 分别是 $X$ 和 $Y$ 的边际累积分布函数 (CDF)，而 $C(u,v)$ 是它们的 copula。\n\n计算此概率的过程包括三个主要步骤：\n1. 计算 $X$ 的边际 CDF 值 $F_X(x^\\star)$。\n2. 计算 $Y$ 的边际 CDF 值 $F_Y(y^\\star)$。\n3. 将这些值代入 copula 函数，然后代入主要的联合概率公式。\n\n**步骤 1 & 2：计算边际 CDF**\n\nCDF 通过 $F(t) = 1 - \\mathbb{P}(X > t)$ 与生存函数（或尾部概率）相关。问题为任何大于或等于高阈值 $u$ 的阈值 $t$ 提供了无条件尾部概率模型。对于变量 $X$，此模型为：\n$$ \\mathbb{P}(X > t) = \\mathbb{P}(X > u_X) \\cdot \\mathbb{P}(Z_X > t - u_X \\mid X > u_X) $$\n其中 $u_X = 10$ 是 $X$ 的固定阈值。设 $p_{X0} = \\mathbb{P}(X > u_X)$ 为给定的超过此阈值的概率。项 $\\mathbb{P}(Z_X > t - u_X \\mid X > u_X)$ 是超出量 $Z_X = X - u_X$ 对阈值 $u_X$ 的生存函数。此超出量由广义帕累托分布 (GPD) 建模。\n\n对于一个服从 GPD 分布、尺度参数为 $\\beta > 0$、形状参数为 $\\xi$ 的随机变量 $Z$，其超出量 $z > 0$ 的生存函数为：\n$$ S_{GPD}(z; \\beta, \\xi) = \\mathbb{P}(Z > z \\mid Z \\ge 0) = \\begin{cases}\n\\left(1 + \\dfrac{\\xi z}{\\beta}\\right)^{-1/\\xi}, & \\text{if } \\xi \\ne 0 \\\\\n\\exp\\left(-\\dfrac{z}{\\beta}\\right), & \\text{if } \\xi = 0\n\\end{cases} $$\n此公式对满足 $1 + \\xi z / \\beta > 0$ 的 $z$ 有效。如果 $\\xi < 0$，分布在 $z_{max} = -\\beta/\\xi$ 处有一个有限上端点。对于任何超出量 $z \\ge z_{max}$，生存概率为 $0$。\n\n因此，对于给定的阈值 $x^\\star \\ge u_X$，我们首先计算超出量 $z_X = x^\\star - u_X$。然后我们找到条件生存概率 $S_{GPD}(z_X; \\beta_X, \\xi_X)$。$X$ 的无条件尾部概率为：\n$$ \\mathbb{P}(X > x^\\star) = p_{X0} \\cdot S_{GPD}(z_X; \\beta_X, \\xi_X) $$\n最后，边际 CDF 值为 $F_X(x^\\star) = 1 - \\mathbb{P}(X > x^\\star)$。\n\n对变量 $Y$ 采用完全相同的程序，使用其特定参数 $(\\beta_Y, \\xi_Y, p_{Y0})$ 和相对于 $u_Y = 2$ 的阈值 $y^\\star$。\n\n**步骤 3：计算联合概率**\n\n边际分布之间的相关性由参数为 $\\theta \\ge 1$ 的 Gumbel-Hougaard copula 建模：\n$$ C(u,v) = \\exp\\left(-\\left((-\\ln u)^{\\theta} + (-\\ln v)^{\\theta}\\right)^{1/\\theta}\\right) $$\n其中 $u = F_X(x^\\star)$ 和 $v = F_Y(y^\\star)$ 是前面步骤中计算的边际 CDF 值。\n\n解决每个测试用例的算法如下：\n1. 对于给定的一组参数 $(\\beta_X, \\xi_X, p_{X0}, \\beta_Y, \\xi_Y, p_{Y0}, \\theta, x^\\star, y^\\star)$ 和全局阈值 $u_X=10, u_Y=2$:\n2. 计算 $X$ 的超出量：$z_X = x^\\star - u_X$。\n3. 计算 $z_X$ 的 GPD 生存概率 $S_{GPD,X}$，并考虑 $\\xi_X = 0$ 和 $\\xi_X < 0$ 的情况。\n4. 计算 $X$ 的无条件尾部概率：$S_X = p_{X0} \\cdot S_{GPD,X}$。\n5. 计算 $X$ 的边际 CDF：$F_X = 1 - S_X$。\n6. 对变量 $Y$ 重复步骤 2-5，以找到 $F_Y = 1 - p_{Y0} \\cdot S_{GPD}(y^\\star - u_Y; \\beta_Y, \\xi_Y)$。\n7. 如果 $F_X=1$ 或 $F_Y=1$，则联合尾部概率 $\\mathbb{P}(X > x^\\star, Y > y^\\star)$ 为 $0$，因为事件 $(X > x^\\star, Y > y^\\star)$ 是一个概率为零的事件的子集。\n8. 否则，使用 Gumbel-Hougaard 公式计算 copula 值 $C(F_X, F_Y)$。\n9. 计算最终的联合尾部概率：$P_{joint} = 1 - F_X - F_Y + C(F_X, F_Y)$。\n10. 按要求将结果四舍五入到六位小数。\n\n此过程严谨地结合了指定的边际尾部模型和相关性模型，以得出所需风险度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the joint tail probability of two financial risk events\n    using multivariate extreme value theory.\n    \"\"\"\n\n    # Global thresholds for the models.\n    u_X = 10.0  # USD\n    u_Y = 2.0   # percentage points\n\n    # Test cases: (beta_X, xi_X, p_X0, beta_Y, xi_Y, p_Y0, theta, x_star, y_star)\n    test_cases = [\n        (8.0, 0.2, 0.05, 1.5, 0.1, 0.10, 2.0, 20.0, 5.0),\n        (5.0, 0.0, 0.02, 1.2, 0.2, 0.04, 1.0, 25.0, 3.0),\n        (10.0, 0.3, 0.03, 2.0, 0.3, 0.08, 10.0, 10.0, 2.0),\n        (6.0, 0.2, 0.04, 1.5, -0.2, 0.03, 1.5, 20.0, 10.0),\n    ]\n\n    def gpd_survival(z, beta, xi):\n        \"\"\"\n        Calculates the survival function P(Z > z) for a GPD.\n        \"\"\"\n        # Excess z must be non-negative as z = t - u, and problem states t >= u.\n        if z < 0:\n            return 1.0\n\n        # Case 1: xi < 0 (distribution has a finite upper endpoint)\n        if xi < 0:\n            upper_endpoint = -beta / xi\n            if z >= upper_endpoint:\n                return 0.0\n        \n        # Case 2: xi = 0 (Exponential distribution)\n        if xi == 0.0:\n            return np.exp(-z / beta)\n\n        # Case 3: xi != 0 (General GPD case)\n        # The check for xi < 0 above ensures base > 0 for valid z.\n        base = 1.0 + xi * z / beta\n        return base**(-1.0 / xi)\n\n    results = []\n    for case in test_cases:\n        beta_X, xi_X, p_X0, beta_Y, xi_Y, p_Y0, theta, x_star, y_star = case\n\n        # --- Calculate marginal probability for X ---\n        if x_star < u_X:\n            # Per problem, x_star >= u_X, but handle for robustness\n            S_X = 1.0\n        else:\n            z_X = x_star - u_X\n            cond_surv_X = gpd_survival(z_X, beta_X, xi_X)\n            S_X = p_X0 * cond_surv_X\n        F_X = 1.0 - S_X\n\n        # --- Calculate marginal probability for Y ---\n        if y_star < u_Y:\n            # Per problem, y_star >= u_Y, but handle for robustness\n            S_Y = 1.0\n        else:\n            z_Y = y_star - u_Y\n            cond_surv_Y = gpd_survival(z_Y, beta_Y, xi_Y)\n            S_Y = p_Y0 * cond_surv_Y\n        F_Y = 1.0 - S_Y\n\n        # If one of the marginal tail probabilities is zero, the joint probability is zero.\n        if S_X == 0.0 or S_Y == 0.0:\n            joint_tail_prob = 0.0\n        else:\n            # --- Calculate Gumbel-Hougaard copula value ---\n            # Handles special cases of independence (theta=1) and comonotonicity (theta->inf)\n            term_u = (-np.log(F_X))**theta\n            term_v = (-np.log(F_Y))**theta\n            copula_val = np.exp(-((term_u + term_v)**(1.0 / theta)))\n\n            # --- Calculate joint tail probability ---\n            # P(X > x, Y > y) = 1 - F_X(x) - F_Y(y) + C(F_X(x), F_Y(y))\n            joint_tail_prob = 1.0 - F_X - F_Y + copula_val\n        \n        results.append(round(joint_tail_prob, 6))\n\n    # Final print statement in the exact required format.\n    # The output format requires string representations of floats, rounded.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"}]}