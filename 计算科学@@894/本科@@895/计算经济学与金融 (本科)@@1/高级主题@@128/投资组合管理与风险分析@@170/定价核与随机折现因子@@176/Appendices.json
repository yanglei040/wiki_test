{"hands_on_practices": [{"introduction": "金融学中的一个主要挑战是“股权溢价之谜”，即历史上股票的回报率远高于标准经济模型的预测。本练习将探讨一个由经济学家 Rietz 和 Barro 提出的有力解释：罕见但严重的经济灾难所扮演的角色。通过在一个包含灾难风险的模型中分析性地计算资产价格，你将亲身体会到，仅仅是灾难的可能性就如何极大地改变了随机折现因子与资产收益的协方差，从而产生一个符合现实的股权溢价。[@problem_id:2421399]", "id": "2421399", "problem": "考虑一个具有恒定相对风险厌恶 (CRRA) 效用的代表性代理人禀赋经济。令总消费为 $\\{C_t\\}_{t \\ge 0}$，并将消费总增长率定义为 $g_{t+1} = \\frac{C_{t+1}}{C_t}$。代理人的随机折现因子 (SDF) 由 $m_{t+1} = \\beta \\, g_{t+1}^{-\\gamma}$ 给出，其中 $\\beta \\in (0,1)$ 是主观折现因子，$\\gamma \\gt 0$ 是相对风险厌恶系数。消费增长遵循一个罕见灾难混合过程：\n$$\n\\log g_{t+1} = \\mu + \\sigma \\,\\varepsilon_{t+1} + \\ln(1-b)\\, J_{t+1},\n$$\n其中 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$, $J_{t+1} \\sim \\text{Bernoulli}(p)$，且 $(\\varepsilon_{t+1}, J_{t+1})$ 跨时间独立且相互独立。参数 $b \\in (0,1)$ 是灾难期间消费的比例性下降幅度，而 $p \\in [0,1]$ 是在给定时期内发生灾难的概率。参数 $\\mu \\in \\mathbb{R}$ 和 $\\sigma \\ge 0$ 控制消费增长的对数正态部分。\n\n考虑两种由基本定价方程 $P_t = \\mathbb{E}_t[m_{t+1} X_{t+1}]$ 定价的单期资产，其中 $X_{t+1}$ 是下一期的回报：\n- 一种无风险的单期纯贴现债券，其总回报率为 $R_f$，满足 $\\mathbb{E}[m_{t+1}] \\, R_f = 1$。\n- 一种风险“股权”求偿权，其单期回报为 $X_{t+1} = g_{t+1}$。其在t日的价格为 $P_e = \\mathbb{E}[m_{t+1} g_{t+1}]$，其单期总回报率为 $R_e = \\frac{g_{t+1}}{P_e}$。将预期股权回报定义为 $\\mathbb{E}[R_e]$，股权溢价定义为 $\\mathbb{E}[R_e] - R_f$。\n\n仅使用上述定义和为 $g_{t+1}$ 指定的概率结构，为测试套件中的每个参数集计算浮点数三元组 $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$。\n\n测试套件（每个元组为 $(\\beta, \\gamma, \\mu, \\sigma, p, b)$）：\n- 情况 A（无灾难基准）：$(0.99, 4.0, 0.005, 0.02, 0.0, 0.3)$。\n- 情况 B（罕见中度灾难）：$(0.99, 4.0, 0.005, 0.02, 0.01, 0.3)$。\n- 情况 C（罕见严重灾难）：$(0.99, 4.0, 0.005, 0.02, 0.01, 0.5)$。\n- 情况 D（无扩散风险的灾难）：$(0.99, 4.0, 0.005, 0.0, 0.02, 0.4)$。\n- 情况 E（罕见中度灾难下更高的风险厌恶）：$(0.99, 8.0, 0.005, 0.02, 0.01, 0.3)$。\n\n你的程序必须生成单行输出，其中包含五个情况的结果，格式为一个由逗号分隔的包含五个内部列表的列表，每个内部列表按顺序包含三个浮点数 $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$。该行必须没有空格，并且必须用方括号括起来。例如，所需的格式为 $[[x_{1,1},x_{1,2},x_{1,3}],[x_{2,1},x_{2,2},x_{2,3}],[x_{3,1},x_{3,2},x_{3,3}],[x_{4,1},x_{4,2},x_{4,3}],[x_{5,1},x_{5,2},x_{5,3}]]$，其中每个 $x_{i,j}$ 都是一个浮点数。", "solution": "问题陈述经过了严格验证，并被证实是有效的。该问题在科学上植根于已确立的宏观经济和金融理论，特别是包含代表性代理人、CRRA效用以及消费增长的罕见灾难过程的资产定价框架。这个问题是适定的，所有必要的参数和分布都已定义，确保可以计算出唯一且有意义的解。其语言是客观且在数学上是精确的。\n\n求解过程是通过推导必要的解析表达式来进行的。问题的核心是计算涉及消费总增长率 $g_{t+1}$ 的各种期望值。对数消费增长过程由下式给出：\n$$ \\log g_{t+1} = \\mu + \\sigma \\varepsilon_{t+1} + \\ln(1-b) J_{t+1} $$\n其中 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$ 和 $J_{t+1} \\sim \\text{Bernoulli}(p)$ 是独立的。我们可以将 $g_{t+1}$ 写成两个独立随机变量的乘积：\n$$ g_{t+1} = \\exp(\\mu + \\sigma \\varepsilon_{t+1}) \\cdot (1-b)^{J_{t+1}} $$\n令 $Z = \\exp(\\mu + \\sigma \\varepsilon_{t+1})$ 和 $V = (1-b)^{J_{t+1}}$。变量 $Z$ 服从对数正态分布，其中 $\\log Z \\sim \\mathcal{N}(\\mu, \\sigma^2)$。变量 $V$ 以概率 $p$ 取值 $1-b$，以概率 $1-p$ 取值 $1$。\n\n解决问题的关键是推导出 $g_{t+1}$ 的k阶矩的通用公式，即 $\\mathbb{E}[g_{t+1}^k]$。由于 $Z$ 和 $V$ 的独立性，我们有：\n$$ \\mathbb{E}[g_{t+1}^k] = \\mathbb{E}[Z^k V^k] = \\mathbb{E}[Z^k] \\mathbb{E}[V^k] $$\n$Z^k$ 的期望是对数正态分布的一个标准结果：\n$$ \\mathbb{E}[Z^k] = \\mathbb{E}[\\exp(k(\\mu + \\sigma \\varepsilon_{t+1}))] = \\exp(k\\mu + \\frac{1}{2} k^2 \\sigma^2) $$\n$V^k$ 的期望从其离散分布中计算得出：\n$$ \\mathbb{E}[V^k] = \\mathbb{E}[((1-b)^{J_{t+1}})^k] = (1-p) \\cdot (1-b)^{k \\cdot 0} + p \\cdot (1-b)^{k \\cdot 1} = (1-p) + p(1-b)^k $$\n结合这些结果，我们得到 $g_{t+1}$ 的通用矩生成公式：\n$$ \\mathbb{E}[g_{t+1}^k] = \\exp(k\\mu + \\frac{1}{2} k^2 \\sigma^2) \\left[ (1-p) + p(1-b)^k \\right] $$\n现在我们应用此公式来推导我们感兴趣的量。\n\n1.  **无风险总回报率 ($R_f$)**\n    无风险利率由方程 $1 = \\mathbb{E}[m_{t+1}] R_f$ 定义。因此，$R_f = 1 / \\mathbb{E}[m_{t+1}]$。\n    随机折现因子 (SDF) 是 $m_{t+1} = \\beta g_{t+1}^{-\\gamma}$。其期望为：\n    $$ \\mathbb{E}[m_{t+1}] = \\beta \\mathbb{E}[g_{t+1}^{-\\gamma}] $$\n    使用我们的通用公式，令 $k = -\\gamma$：\n    $$ \\mathbb{E}[g_{t+1}^{-\\gamma}] = \\exp(-\\gamma\\mu + \\frac{1}{2} \\gamma^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{-\\gamma} \\right] $$\n    因此，无风险利率由下式给出：\n    $$ R_f = \\frac{1}{\\beta \\exp(-\\gamma\\mu + \\frac{1}{2} \\gamma^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{-\\gamma} \\right]} $$\n\n2.  **预期股权总回报率 ($\\mathbb{E}[R_e]$)**\n    股权求偿权的回报为 $X_{t+1} = g_{t+1}$。其在时间 $t$ 的价格为 $P_e = \\mathbb{E}[m_{t+1} X_{t+1}]$。\n    $$ P_e = \\mathbb{E}[\\beta g_{t+1}^{-\\gamma} g_{t+1}] = \\beta \\mathbb{E}[g_{t+1}^{1-\\gamma}] $$\n    使用通用公式，令 $k = 1-\\gamma$：\n    $$ \\mathbb{E}[g_{t+1}^{1-\\gamma}] = \\exp((1-\\gamma)\\mu + \\frac{1}{2} (1-\\gamma)^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{1-\\gamma} \\right] $$\n    股权的总回报率为 $R_e = g_{t+1} / P_e$。其期望为：\n    $$ \\mathbb{E}[R_e] = \\frac{\\mathbb{E}[g_{t+1}]}{P_e} = \\frac{\\mathbb{E}[g_{t+1}]}{\\beta \\mathbb{E}[g_{t+1}^{1-\\gamma}]} $$\n    项 $\\mathbb{E}[g_{t+1}]$ 通过在通用公式中设置 $k=1$ 得到：\n    $$ \\mathbb{E}[g_{t+1}] = \\exp(\\mu + \\frac{1}{2} \\sigma^2) \\left[ (1-p) + p(1-b) \\right] = \\exp(\\mu + \\frac{1}{2} \\sigma^2) (1-pb) $$\n    将期望的表达式代入，我们得到预期股权回报的公式。\n\n3.  **股权溢价 ($\\mathbb{E}[R_e] - R_f$)**\n    股权溢价是预期股权总回报率与无风险总回报率之差：\n    $$ \\text{Equity Premium} = \\mathbb{E}[R_e] - R_f $$\n    这可直接从前面推导出的两个量计算得出。\n\n这些公式被用于计算测试套件中提供的每个参数集所需的三元组 $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rare-disaster asset pricing model for the given test cases.\n    \"\"\"\n    \n    # Test Suite: tuples of (beta, gamma, mu, sigma, p, b)\n    test_cases = [\n        # Case A (no disasters baseline)\n        (0.99, 4.0, 0.005, 0.02, 0.0, 0.3),\n        # Case B (rare moderate disasters)\n        (0.99, 4.0, 0.005, 0.02, 0.01, 0.3),\n        # Case C (rare severe disasters)\n        (0.99, 4.0, 0.005, 0.02, 0.01, 0.5),\n        # Case D (disasters without diffusive risk)\n        (0.99, 4.0, 0.005, 0.0, 0.02, 0.4),\n        # Case E (higher risk aversion with rare moderate disasters)\n        (0.99, 8.0, 0.005, 0.02, 0.01, 0.3),\n    ]\n\n    all_results = []\n\n    def _calculate_moment(k, mu, sigma, p, b):\n        \"\"\"\n        Calculates the k-th moment of the gross consumption growth, E[g^k].\n        \"\"\"\n        lognormal_term = np.exp(k * mu + 0.5 * (k * sigma)**2)\n        disaster_term = (1 - p) + p * ((1 - b)**k)\n        return lognormal_term * disaster_term\n\n    for case in test_cases:\n        beta, gamma, mu, sigma, p, b = case\n\n        # 1. Calculate the Risk-Free Gross Return (Rf)\n        # E[m] = beta * E[g^(-gamma)]\n        e_g_neg_gamma = _calculate_moment(-gamma, mu, sigma, p, b)\n        e_m = beta * e_g_neg_gamma\n        r_f = 1.0 / e_m\n\n        # 2. Calculate the Expected Equity Gross Return (E[Re])\n        # E[Re] = E[g] / P_e, where P_e = beta * E[g^(1-gamma)]\n        \n        # E[g] = E[g^1]\n        e_g = _calculate_moment(1.0, mu, sigma, p, b)\n        \n        # E[g^(1-gamma)]\n        e_g_one_minus_gamma = _calculate_moment(1.0 - gamma, mu, sigma, p, b)\n        \n        # Price of equity, P_e\n        p_e = beta * e_g_one_minus_gamma\n        \n        # E[Re]\n        e_r_e = e_g / p_e\n\n        # 3. Calculate the Equity Premium (EP)\n        equity_premium = e_r_e - r_f\n        \n        result_triplet = [r_f, e_r_e, equity_premium]\n        all_results.append(result_triplet)\n\n    # Format the final output string as required, with no spaces.\n    final_output = str(all_results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "理论为我们提供了基础，但任何资产定价模型的最终检验标准是其解释真实世界数据的能力。在这个实践中，我们将从纯理论转向实证金融的核心任务：在不同的竞争模型之间进行“赛马”比较。你将通过计算它们的均方根定价误差（一个关键的模型评估指标），来实施并比较两种主流模型——基于消费的SDF和线性因子SDF——的表现，这正是实证资产定价中的一项基本技能。[@problem_id:2421338]", "id": "2421338", "problem": "给定一个小型的、人工构建的资产总回报率、可交易因子超额回报率、恒定无风险总回报率和总体消费增长率的面板数据，均为月度频率。您的任务是，从第一性原理出发，计算由两种不同的随机折现因子（SDF）设定在一个包含三个行业投资组合的横截面上所隐含的定价误差，并比较它们的均方根定价误差。所有回报率均为无量纲的总回报率，不涉及物理单位。\n\n$T=8$ 个连续月份的数据：\n- 无风险总回报率（在所有时间 $t$ 上恒定）：$R_{f} = 1.0025$。\n- 可交易因子超额回报率（两个因子），对于 $t=1,\\dots,8$：\n  - 因子 $1$：$\\{0.012,\\,0.005,\\,-0.010,\\,0.018,\\,-0.004,\\,0.009,\\,0.002,\\,0.015\\}$。\n  - 因子 $2$：$\\{0.008,\\,-0.006,\\,0.004,\\,0.011,\\,-0.003,\\,0.007,\\,-0.002,\\,0.010\\}$。\n  将 $f_{t} \\in \\mathbb{R}^{2}$ 表示为月份 $t$ 的两个因子超额回报率的向量。\n- 三个行业投资组合的总回报率，对于 $t=1,\\dots,8$：\n  - 行业 $1$：$\\{1.015,\\,1.010,\\,0.995,\\,1.022,\\,1.000,\\,1.013,\\,1.005,\\,1.020\\}$。\n  - 行业 $2$：$\\{1.012,\\,1.008,\\,0.992,\\,1.018,\\,0.998,\\,1.009,\\,1.004,\\,1.017\\}$。\n  - 行业 $3$：$\\{1.018,\\,1.012,\\,0.997,\\,1.025,\\,1.003,\\,1.016,\\,1.006,\\,1.022\\}$。\n  将 $R_{i,t}$ 表示为行业 $i \\in \\{1,2,3\\}$ 在月份 $t$ 的总回报率。\n- 总体消费增长率（总增长率），对于 $t=1,\\dots,8$：$\\{1.003,\\,1.004,\\,0.999,\\,1.005,\\,1.001,\\,1.004,\\,1.002,\\,1.006\\}$。\n  记为 $g_{t} = C_{t}/C_{t-1}$。\n\n考虑两种SDF设定：\n1. 基于消费的幂效用SDF：对于给定的折现因子 $\\beta$ 和相对风险厌恶系数 $\\gamma$，SDF为 $m^{C}_{t} = \\beta \\cdot g_{t}^{-\\gamma}$。使用 $\\beta = 0.99$ 以及下面测试套件中指定的三个 $\\gamma$ 值。\n2. 基于线性因子的SDF：$m^{F}_{t} = a - b^{\\top} f_{t}$，其中 $a \\in \\mathbb{R}$ 且 $b \\in \\mathbb{R}^{2}$。假设这两个因子是可交易的因子模拟投资组合相对于无风险资产的超额回报。使用样本均值作为经验期望，对（恒定的）无风险资产和可交易因子施加资产定价欧拉方程：$\\mathbb{E}[m^{F}_{t}] \\cdot R_{f} = 1$ 和 $\\mathbb{E}[m^{F}_{t} f_{t}] = 0$。\n\n对于每种SDF设定和每个行业 $i \\in \\{1,2,3\\}$，将定价误差定义为样本均值欧拉方程偏差：\n$$\n\\epsilon_{i} = \\frac{1}{T} \\sum_{t=1}^{T} m_{t} R_{i,t} - 1.\n$$\n对于每种SDF设定，计算三个行业的均方根定价误差：\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} \\epsilon_{i}^{2}}.\n$$\n\n测试套件（为基于消费的SDF提供了三个参数集，而基于因子的SDF由数据和 $R_{f}$ 固定）：\n- 情况 1：$\\gamma = 0.0$。\n- 情况 2：$\\gamma = 2.0$。\n- 情况 3：$\\gamma = 6.0$。\n在所有情况下，均使用 $\\beta = 0.99$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个项目的列表，每个项目对应上述顺序的一个测试用例。每个项目必须是一个包含两个浮点数的列表 $[\\text{RMSPE}^{C}, \\text{RMSPE}^{F}]$，其中 $\\text{RMSPE}^{C}$ 是该情况下基于消费的SDF的均方根定价误差，$\\text{RMSPE}^{F}$ 是基于因子的SDF的对应值（后者不依赖于 $\\gamma$）。\n- 将每个浮点数四舍五入到小数点后恰好六位。\n- 因此，总输出必须采用以下形式：\n$$\n[[x_{1},y_{1}],[x_{2},y_{2}],[x_{3},y_{3}]],\n$$\n其中每个 $x_{k}$ 和 $y_{k}$ 是小数点后恰好有六位的小数，并且除了构成有效列表所必需的字符或空格外，没有其他任何字符。", "solution": "所提出的问题是实证资产定价领域一个定义明确的练习，要求计算和比较两种经典的随机折现因子（SDF）模型的定价误差。所提供的数据和定义是完整的、科学上合理的且内部一致。这是一个有效的问题。我们将着手解决。\n\n资产定价的核心是欧拉方程，它指出对于任何具有总回报率 $R_t$ 的可交易资产，以下关系成立：\n$$\n1 = \\mathbb{E}[m_t R_t]\n$$\n其中 $m_t$ 是随机折现因子。在实践中， $m_t$ 的模型并不能完美地为所有资产定价。与此方程的偏差，即定价误差，是衡量模型性能的一个指标。对于一组具有回报率 $R_{i,t}$ 的 $N$ 个测试资产，资产 $i$ 的定价误差使用欧拉方程的样本类比来定义：\n$$\n\\epsilon_i = \\frac{1}{T} \\sum_{t=1}^{T} m_t R_{i,t} - 1\n$$\n一个常见的总体性能度量是在测试资产间的均方根定价误差（RMSPE）：\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\epsilon_i^2}\n$$\n在这个问题中，我们使用 $N=3$ 个行业投资组合的横截面数据来评估两种特定的 $m_t$ 模型。\n\n**1. 基于消费的SDF ($m^C_t$)**\n\n这个模型植根于具有幂效用的代表性代理人的消费决策，将SDF指定为：\n$$\nm^C_t = \\beta \\left(\\frac{C_t}{C_{t-1}}\\right)^{-\\gamma} = \\beta g_t^{-\\gamma}\n$$\n这里，$\\beta$ 是代理人的主观时间折现因子，$g_t$ 是总体消费的增长率，$\\gamma$ 是相对风险厌恶系数。问题给出了参数 $\\beta=0.99$ 和 $T=8$，以及消费增长率 $g_t$ 和行业回报率 $R_{i,t}$ 的时间序列。任务要求针对三个不同的风险厌恶值 $\\gamma \\in \\{0.0, 2.0, 6.0\\}$ 来评估该模型。\n\n对于每个给定的 $\\gamma$，流程如下：\na. 计算 $t=1, \\dots, 8$ 的SDF时间序列 $m^C_t$。\nb. 对于三个行业投资组合中的每一个 ($i=1,2,3$)，计算定价误差 $\\epsilon_i^C = \\frac{1}{T} \\sum_{t=1}^{T} m^C_t R_{i,t} - 1$。\nc. 计算 $\\text{RMSPE}^C = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^C)^2}$。\n\n**2. 基于线性因子的SDF ($m^F_t$)**\n\n该模型假定SDF是一组可交易因子超额回报率 $f_t \\in \\mathbb{R}^K$ 的线性函数。这里，$K=2$。\n$$\nm^F_t = a - b^\\top f_t\n$$\n标量参数 $a$ 和向量 $b \\in \\mathbb{R}^2$ 并非预先给定。相反，它们是通过强制模型必须正确定价用于构建其自身的资产来确定的。这些资产是无风险资产（具有恒定的总回报率 $R_f$）和因子模拟投资组合本身（具有超额回报率 $f_t$）。\n\n使用样本矩作为期望的估计量来表示的定价条件是：\n1. 对于无风险资产：$\\mathbb{E}[m^F_t] R_f = 1 \\implies \\left(\\frac{1}{T} \\sum_{t=1}^{T} m^F_t\\right) R_f = 1$。\n2. 对于因子超额回报率：$\\mathbb{E}[m^F_t f_t] = \\vec{0} \\implies \\frac{1}{T} \\sum_{t=1}^{T} m^F_t f_t = \\vec{0}$。\n\n将 $m^F_t$ 的定义代入这些条件，得到一个关于 $a$ 和 $b$ 的方程组。设 $\\bar{f} = \\frac{1}{T}\\sum_t f_t$ 为因子的样本均值，$\\overline{ff^\\top} = \\frac{1}{T}\\sum_t f_t f_t^\\top$ 为二阶矩矩阵。\n\n由条件1得：\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) = \\frac{1}{R_f} \\implies a - b^\\top \\bar{f} = \\frac{1}{R_f} \\quad (*).\n$$\n由条件2得：\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) f_t = \\vec{0} \\implies a \\bar{f} - \\overline{ff^\\top} b = \\vec{0} \\quad (**).\n$$\n从 $(*)$ 式，我们得到 $a = \\frac{1}{R_f} + b^\\top \\bar{f}$。将其代入 $(**)$ 式：\n$$\n\\left(\\frac{1}{R_f} + b^\\top \\bar{f}\\right) \\bar{f} - \\overline{ff^\\top} b = \\vec{0}\n$$\n$$\n\\frac{1}{R_f}\\bar{f} + (\\bar{f} \\bar{f}^\\top) b - \\overline{ff^\\top} b = \\vec{0}\n$$\n整理以求解 $b$：\n$$\n(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top) b = \\frac{1}{R_f} \\bar{f}\n$$\n项 $(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top)$ 正是因子的样本协方差矩阵 $\\Sigma_{ff}$。因此，我们得到了一个关于向量 $b$ 的线性系统：\n$$\n\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}\n$$\n假设 $\\Sigma_{ff}$ 是可逆的，就可以解出 $b$。在确定 $b$ 之后，通过方程 $(*)$ 求得 $a$。\n\n因子模型的流程如下：\na. 根据给定的因子数据 $f_t$ 计算样本均值向量 $\\bar{f}$ 和样本协方差矩阵 $\\Sigma_{ff}$。\nb. 解线性系统 $\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}$ 以获得因子载荷向量 $b$。\nc. 计算截距 $a = \\frac{1}{R_f} + b^\\top \\bar{f}$。\nd. 构建SDF时间序列 $m^F_t = a - b^\\top f_t$（对于 $t=1, \\dots, 8$）。\ne. 对于三个行业投资组合中的每一个 ($i=1,2,3$)，计算定价误差 $\\epsilon_i^F = \\frac{1}{T} \\sum_{t=1}^{T} m^F_t R_{i,t} - 1$。\nf. 计算 $\\text{RMSPE}^F = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^F)^2}$。由于因子模型的参数不依赖于 $\\gamma$，该值在所有三种测试情况下都将相同。\n\n最终输出将列出每个指定 $\\gamma$ 值对应的 $[\\text{RMSPE}^C, \\text{RMSPE}^F]$ 对。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the Root Mean Squared Pricing Errors (RMSPE)\n    for a consumption-based SDF and a linear factor-based SDF.\n    \"\"\"\n    \n    # 1. Define Givens from the problem statement\n    \n    # Constants and parameters\n    T = 8\n    R_f = 1.0025\n    beta = 0.99\n    gammas = [0.0, 2.0, 6.0]\n\n    # Time series data as numpy arrays\n    # Factor excess returns, shape (T, 2)\n    factors = np.array([\n        [0.012, 0.008],\n        [0.005, -0.006],\n        [-0.010, 0.004],\n        [0.018, 0.011],\n        [-0.004, -0.003],\n        [0.009, 0.007],\n        [0.002, -0.002],\n        [0.015, 0.010]\n    ])\n\n    # Industry portfolio gross returns, shape (T, 3)\n    industry_returns = np.array([\n        [1.015, 1.012, 1.018],\n        [1.010, 1.008, 1.012],\n        [0.995, 0.992, 0.997],\n        [1.022, 1.018, 1.025],\n        [1.000, 0.998, 1.003],\n        [1.013, 1.009, 1.016],\n        [1.005, 1.004, 1.006],\n        [1.020, 1.017, 1.022]\n    ])\n\n    # Aggregate consumption growth, shape (T,)\n    cons_growth = np.array([1.003, 1.004, 0.999, 1.005, 1.001, 1.004, 1.002, 1.006])\n\n    def calculate_rmspe(m, R):\n        \"\"\"\n        Calculates the RMSPE given an SDF vector and a matrix of asset returns.\n        \n        Args:\n            m (np.ndarray): The SDF time series, shape (T,).\n            R (np.ndarray): The asset returns time series, shape (T, N_assets).\n            \n        Returns:\n            float: The root mean squared pricing error.\n        \"\"\"\n        # Reshape m to (T, 1) for broadcasting\n        m_reshaped = m[:, np.newaxis]\n        \n        # Calculate pricing products m*R for each asset and time point\n        pricing_products = m_reshaped * R\n        \n        # Compute sample mean of m*R for each asset\n        mean_pricing_products = np.mean(pricing_products, axis=0)\n        \n        # Calculate pricing errors (alpha)\n        pricing_errors = mean_pricing_products - 1.0\n        \n        # Calculate root mean squared pricing error\n        rmspe = np.sqrt(np.mean(pricing_errors**2))\n        \n        return rmspe\n\n    # 2. Compute parameters and RMSPE for the Linear Factor-Based SDF\n    \n    # Sample mean of factor excess returns\n    f_mean = np.mean(factors, axis=0)\n    \n    # Sample covariance matrix of factors (ddof=0 for population formula 1/T)\n    f_cov = np.cov(factors, rowvar=False, ddof=0)\n    \n    # Solve the system Sigma_ff * b = (1/R_f) * f_mean for b\n    b = np.linalg.solve(f_cov, f_mean / R_f)\n    \n    # Calculate the intercept a\n    a = 1.0 / R_f + np.dot(b, f_mean)\n    \n    # Construct the SDF time series for the factor model\n    m_factor = a - factors @ b\n    \n    # Calculate the RMSPE for the factor model\n    rmspe_factor = calculate_rmspe(m_factor, industry_returns)\n\n    # 3. Compute RMSPE for the Consumption-Based SDF for each gamma\n    \n    results = []\n    for gamma in gammas:\n        # Construct the SDF time series for the consumption model\n        m_consumption = beta * (cons_growth ** (-gamma))\n        \n        # Calculate the RMSPE for the consumption model\n        rmspe_consumption = calculate_rmspe(m_consumption, industry_returns)\n        \n        # Store the pair of results for this case\n        results.append([rmspe_consumption, rmspe_factor])\n\n    # 4. Format and print the final output\n    \n    formatted_results = []\n    for res_pair in results:\n        # Format each number to exactly six decimal places\n        formatted_pair = f'[{res_pair[0]:.6f},{res_pair[1]:.6f}]'\n        formatted_results.append(formatted_pair)\n        \n    # Join the formatted pairs into the final string\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"}, {"introduction": "一个优秀的资产定价模型，除了要能匹配平均回报率，还应与其潜在的经济假设相一致。基于效用的代表性代理人模型预测，随机折现因子（SDF）应随着总体财富的增加而单调递减。然而，部分实证研究发现了违反此规则的现象，这一现象被称为“定价核之谜”。本练习让你能够直接探究这个谜题，通过从资产回报中估计SDF并系统地检验其单调性，从而更深入地理解如何检验金融模型的理论根基。[@problem_id:2421410]", "id": "2421410", "problem": "您的任务是研究所谓的定价核之谜（pricing kernel puzzle），具体方法是检验一个根据经验估算的随机折现因子（也称为定价核）是否如具有凹效用的代表性代理人模型所预测的那样，随总财富单调递减。您必须实现一个完整的程序，根据合成的资产收益率估算随机折现因子，然后针对提供的一套测试用例评估其相对于总财富的单调性。\n\n首先从基本的跨期资产定价条件出发：对于每种总回报率为 $R_i$ 的资产 $i$，存在一个随机折现因子 $m$，使得样本欧拉方程成立：\n$$\n\\mathbb{E}[\\,m R_i\\,] = 1,\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示在有限数量的等可能状态下的经验期望。\n\n在一个具有 $S$ 个状态的有限状态经济中，设 $m$ 由长度为 $S$ 的向量 $m = (m_1,\\dots,m_S)^\\top$ 表示，$N$ 种资产的收益率由一个 $S \\times N$ 矩阵 $R$ 给出，其 $(s,i)$ 项为 $R_{s,i}$。在所有状态概率相等（即对所有 $s$ 都有 $p_s = 1/S$）的情况下，对所有 $i \\in \\{1,\\dots,N\\}$ 的欧拉方程可以写成线性系统\n$$\n\\frac{1}{S} R^\\top m = \\mathbf{1}_N,\n$$\n其中 $\\mathbf{1}_N$ 是长度为 $N$ 的全一向量。在所有满足此系统的 $m$ 中，将经验估算量定义为具有最小欧几里得范数的向量：\n$$\n\\text{寻找 } m \\text{ 以最小化 } \\|m\\|_2 \\text{，约束条件为 } \\frac{1}{S} R^\\top m = \\mathbf{1}_N.\n$$\n\n您的程序必须：\n1. 对于下方的每个测试用例，使用以下构造方法，从一个目标随机折现因子 $m^{\\star}$ 确定性地构建一个收益率矩阵 $R$。固定 $S = 4$ 和 $N = 4$，并设 $\\epsilon = 0.45$。令 $\\mathbf{1}_4$ 为4维全一向量。定义四个方向向量 $v_j \\in \\mathbb{R}^4$，这些向量在标准点积下与 $m^{\\star}$ 正交，即对于所有 $j \\in \\{1,2,3,4\\}$，都有 $m^{\\star \\top} v_j = 0$。使用：\n   - $v_1 = (1,\\; -m^{\\star}_1/m^{\\star}_2,\\; 0,\\; 0)^\\top$，\n   - $v_2 = (1,\\; 0,\\; -m^{\\star}_1/m^{\\star}_3,\\; 0)^\\top$，\n   - $v_3 = (1,\\; 0,\\; 0,\\; -m^{\\star}_1/m^{\\star}_4)^\\top$，\n   - $v_4 = (0,\\; 1,\\; -m^{\\star}_2/m^{\\star}_3,\\; 0)^\\top$。\n   将每个收益率列构造为\n   $$\n   R_{:,j} = \\mathbf{1}_4 + \\epsilon\\, v_j.\n   $$\n   这保证了对所有 $j$ 都有 $m^{\\star \\top} R_{:,j} = \\sum_{s=1}^4 m^{\\star}_s$。施加归一化条件 $\\sum_{s=1}^4 m^{\\star}_s = 4$，使得对每个 $j$ 都有 $m^{\\star \\top} R_{:,j} = 4$，这使得 $m^{\\star}$ 成为状态概率相等的欧拉方程的一个可行解。\n\n2. 给定 $R$，计算线性系统 $\\frac{1}{4} R^\\top m = \\mathbf{1}_4$ 的最小范数解 $\\hat m$。\n\n3. 对于每个测试用例中提供的总财富向量 $W \\in \\mathbb{R}^4$，按如下方式评估单调性。理论预测是随机折现因子随总财富递减。定义可比较状态对的集合\n   $$\n   \\mathcal{P} = \\{(i,j) \\in \\{1,2,3,4\\}^2 \\;|\\; i \\neq j, \\; W_i > W_j\\}.\n   $$\n   如果一个对 $(i,j) \\in \\mathcal{P}$ 满足 $\\hat m_i \\ge \\hat m_j$，则称之为一个违规。令 $V$ 为违规数量，$T = |\\mathcal{P}|$ 为可比较对的数量。违规率定义为分数 $V/T$。使用数值容差 $\\tau = 10^{-10}$，因此不等式 $\\hat m_i \\ge \\hat m_j$ 被解释为 $\\hat m_i - \\hat m_j \\ge -\\tau$。\n\n4. 对于每个测试用例，计算并报告违规率，结果为一个实数。最终输出必须是单行文本，包含所有测试用例的违规率列表，按顺序排列，并用方括号括起来，以逗号分隔，例如 $[0.0,0.5,0.0]$。打印时，将每个违规率四舍五入到恰好六位小数。\n\n测试套件：\n- 情况A（与递增财富一致的严格递减目标随机折现因子）：\n  - 财富：$W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$。\n  - 目标：$m^{\\star} = (1.4,\\; 1.1,\\; 0.8,\\; 0.7)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n- 情况B（意味着非单调性的驼峰形目标）：\n  - 财富：$W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$。\n  - 目标：$m^{\\star} = (1.0,\\; 1.5,\\; 0.9,\\; 0.6)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n- 情况C（财富中存在相等值；可比较对排除财富相等的状态）：\n  - 财富：$W = (1.0,\\; 1.0,\\; 1.2,\\; 1.3)^\\top$。\n  - 目标：$m^{\\star} = (1.1,\\; 1.3,\\; 0.9,\\; 0.7)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n- 情况D（带有局部反转的近单调）：\n  - 财富：$W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$。\n  - 目标：$m^{\\star} = (1.2,\\; 0.98,\\; 1.0,\\; 0.82)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n\n您的程序应生成单行输出，其中包含按A、B、C、D顺序排列的四个违规率，格式为逗号分隔的列表并用方括号括起来。不允许有其他输出。所有计算都是无量纲的，不涉及任何物理单位或角度。", "solution": "在尝试任何解答之前，需对问题陈述进行严格验证。一个问题必须是自洽的、科学上合理的且逻辑上一致的。\n\n首先，我们提取陈述中给出的信息和约束。\n给定信息：\n1.  **资产定价框架**：基本的样本欧拉方程为 $\\mathbb{E}[\\,m R_i\\,] = 1$，适用于每种资产 $i$，其中 $m$ 是随机折现因子（SDF），$R_i$ 是总回报率。\n2.  **有限状态模型**：有 $S$ 个状态和 $N$ 种资产。状态概率是均匀的，$p_s = 1/S$。收益率由一个 $S \\times N$ 矩阵 $R$ 给出。SDF 是一个向量 $m \\in \\mathbb{R}^S$。欧拉方程构成一个线性系统：$\\frac{1}{S} R^\\top m = \\mathbf{1}_N$。\n3.  **SDF 估算器**：经验 SDF 估算器 $\\hat m$ 定义为线性系统的最小欧几里得范数解：最小化 $\\|m\\|_2$，约束条件为 $\\frac{1}{S} R^\\top m = \\mathbf{1}_N$。\n4.  **问题参数**：模型指定 $S=4$ 个状态和 $N=4$ 种资产。\n5.  **收益率矩阵构建**：收益率矩阵 $R$ 是从一个满足归一化条件 $\\sum_{s=1}^4 m^{\\star}_s = 4$ 的目标 SDF $m^\\star \\in \\mathbb{R}^4$ 构建的。$R$ 的列由 $R_{:,j} = \\mathbf{1}_4 + \\epsilon v_j$ 给出，其中 $j \\in \\{1,2,3,4\\}$，$\\epsilon = 0.45$，且向量 $v_j$ 被构造成与 $m^\\star$ 正交（$m^{\\star \\top} v_j = 0$）：\n    -   $v_1 = (1,\\; -m^{\\star}_1/m^{\\star}_2,\\; 0,\\; 0)^\\top$\n    -   $v_2 = (1,\\; 0,\\; -m^{\\star}_1/m^{\\star}_3,\\; 0)^\\top$\n    -   $v_3 = (1,\\; 0,\\; 0,\\; -m^{\\star}_1/m^{\\star}_4)^\\top$\n    -   $v_4 = (0,\\; 1,\\; -m^{\\star}_2/m^{\\star}_3,\\; 0)^\\top$\n6.  **单调性检验**：将估算的 SDF $\\hat m$ 与总财富向量 $W \\in \\mathbb{R}^4$ 进行单调性检验。\n    -   可比较状态对的集合为 $\\mathcal{P} = \\{(i,j) \\in \\{1,2,3,4\\}^2 \\;|\\; i \\neq j, \\; W_i > W_j\\}$。\n    -   对于一个对 $(i,j) \\in \\mathcal{P}$，如果 $\\hat m_i \\ge \\hat m_j$，则发生违规。\n    -   检查的数值容差为 $\\tau = 10^{-10}$，因此如果 $\\hat m_i - \\hat m_j \\ge -\\tau$，则记录一次违规。\n    -   违规率是 $V/T$，其中 $V$ 是违规计数，$T=|\\mathcal{P}|$。\n7.  **测试套件**：\n    -   情况 A: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.4,\\; 1.1,\\; 0.8,\\; 0.7)^\\top$。\n    -   情况 B: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.0,\\; 1.5,\\; 0.9,\\; 0.6)^\\top$。\n    -   情况 C: $W = (1.0,\\; 1.0,\\; 1.2,\\; 1.3)^\\top$, $m^{\\star} = (1.1,\\; 1.3,\\; 0.9,\\; 0.7)^\\top$。\n    -   情况 D: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.2,\\; 0.98,\\; 1.0,\\; 0.82)^\\top$。\n\n基于以上给定信息的验证证实，该问题在资产定价理论上具有科学依据，是客观且适定的。收益率矩阵 $R$ 的构造保证了关于 $m$ 的线性系统是一致的，因为目标 $m^\\star$ 是一个可行解。这确保了唯一的最小范数解的存在。所有需要的数据和定义都已提供。该问题被视为有效。我们继续进行解答。\n\n问题的核心是解决以下约束优化问题：\n$$\n\\text{最小化 } \\frac{1}{2} m^\\top m \\quad \\text{约束条件为} \\quad A m = b\n$$\n其中 $A = \\frac{1}{S} R^\\top$ 是一个 $N \\times S$ 矩阵，$m \\in \\mathbb{R}^S$，$b = \\mathbf{1}_N \\in \\mathbb{R}^N$。对于此问题，我们有 $S=N=4$。\n\n一致线性系统 $Am=b$ 的唯一最小范数解由 $\\hat m = A^\\dagger b$ 给出，其中 $A^\\dagger$ 是 $A$ 的 Moore-Penrose 伪逆。这个线性代数的结果提供了一种直接计算估算 SDF $\\hat m$ 的方法。\n\n每个测试用例的步骤如下：\n\n1.  **构建收益率矩阵 $R$**：\n    对于给定的测试用例及其目标 SDF $m^\\star = (m^\\star_1, m^\\star_2, m^\\star_3, m^\\star_4)^\\top$，我们首先根据指定公式构造四个辅助向量 $v_1, v_2, v_3, v_4 \\in \\mathbb{R}^4$。所有测试用例中 $m^\\star$ 的分量都非零，因此 $v_j$ 的定义是明确的。然后我们形成 $4 \\times 4$ 矩阵 $V = [v_1, v_2, v_3, v_4]$，其列是这些向量。接着组装 $4 \\times 4$ 的收益率矩阵 $R$。$R$ 的第 $j$ 列是 $R_{:,j} = \\mathbf{1}_4 + \\epsilon v_j$，其中 $\\mathbf{1}_4$ 是全一向量，$\\epsilon = 0.45$。这可以紧凑地写为 $R = J + \\epsilon V$，其中 $J$ 是 $4 \\times 4$ 的全一矩阵。\n\n2.  **估算随机折现因子 $\\hat m$**：\n    构造好 $R$ 后，我们形成矩阵 $A = \\frac{1}{4}R^\\top$。待解系统是 $Am = \\mathbf{1}_4$。我们计算 Moore-Penrose 伪逆 $A^\\dagger$，然后找到估算的 SDF 为 $\\hat m = A^\\dagger \\mathbf{1}_4$。必须强调的是，最小范数解 $\\hat m$ 通常不等于目标向量 $m^\\star$。向量 $m^\\star$ 只是解的仿射子空间中的一个点，而 $\\hat m$ 是该子空间中唯一离原点最近的元素。\n\n3.  **评估单调性并计算违规率**：\n    给定财富向量 $W = (W_1, W_2, W_3, W_4)^\\top$ 和估算的 SDF $\\hat m = (\\hat m_1, \\hat m_2, \\hat m_3, \\hat m_4)^\\top$，我们必须评估 $\\hat m$ 是否是 $W$ 的递减函数。我们遍历所有不同的状态索引对 $(i, j)$，其中 $i,j \\in \\{1, 2, 3, 4\\}$。\n    -   我们首先计算可比较对的总数 $T$。如果 $W_i > W_j$，则对 $(i, j)$ 是可比较的。我们找到所有这样的有序对。\n    -   _请注意，在实现中我们使用基于0的索引，因此我们比较的是 $W_i$ 和 $W_j$，其中 $i,j \\in \\{0, 1, 2, 3\\}$。_\n    -   对于每个满足 $W_i > W_j$ 的可比较对，我们检查是否存在单调性违规。当 SDF 不严格递减时，即 $\\hat m_i \\ge \\hat m_j$，定义为一次违规。我们使用提供的数值容差 $\\tau = 10^{-10}$ 来实现这个检查，即 $\\hat m_i - \\hat m_j \\ge -\\tau$。\n    -   我们计算此类违规的总数 $V$。\n    -   违规率是比率 $V/T$。如果 $T=0$，则比率为 $0$。\n\n整个过程被封装在一个程序中，该程序为每个测试用例计算并报告违规率，四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pricing kernel puzzle problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Strictly decreasing target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.4, 1.1, 0.8, 0.7]),\n        },\n        # Case B: Hump-shaped target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.0, 1.5, 0.9, 0.6]),\n        },\n        # Case C: Ties in wealth\n        {\n            \"W\": np.array([1.0, 1.0, 1.2, 1.3]),\n            \"m_star\": np.array([1.1, 1.3, 0.9, 0.7]),\n        },\n        # Case D: Near-monotone target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.2, 0.98, 1.0, 0.82]),\n        },\n    ]\n\n    results = []\n    \n    # Constants from the problem statement\n    S = 4\n    N = 4\n    epsilon = 0.45\n    tau = 1e-10\n\n    for case in test_cases:\n        W = case[\"W\"]\n        m_star = case[\"m_star\"]\n\n        # 1. Construct the returns matrix R\n        # Define the orthogonal vectors v_j\n        # Indices are 0-based for array access.\n        v1 = np.array([1.0, -m_star[0] / m_star[1], 0.0, 0.0])\n        v2 = np.array([1.0, 0.0, -m_star[0] / m_star[2], 0.0])\n        v3 = np.array([1.0, 0.0, 0.0, -m_star[0] / m_star[3]])\n        v4 = np.array([0.0, 1.0, -m_star[1] / m_star[2], 0.0])\n        \n        # Stack vectors into a matrix V\n        V = np.column_stack([v1, v2, v3, v4])\n        \n        # Construct R = J + epsilon * V, where J is a matrix of ones\n        R = np.ones((S, N)) + epsilon * V\n\n        # 2. Compute the minimum-norm SDF estimator m_hat\n        # System is (1/S) * R^T * m = 1_N\n        A = (1 / S) * R.T\n        b = np.ones(N)\n        \n        # The minimum-norm solution is m_hat = A_pinv * b\n        A_pinv = np.linalg.pinv(A)\n        m_hat = A_pinv @ b\n\n        # 3. Evaluate monotonicity and compute violation rate\n        num_comparable_pairs = 0\n        num_violations = 0\n        \n        for i in range(S):\n            for j in range(S):\n                if i == j:\n                    continue\n                \n                # A pair is comparable if wealth levels are different\n                if W[i] > W[j]:\n                    num_comparable_pairs += 1\n                    # A violation occurs if SDF is not strictly decreasing\n                    if m_hat[i] - m_hat[j] >= -tau:\n                        num_violations += 1\n        \n        if num_comparable_pairs == 0:\n            violation_rate = 0.0\n        else:\n            violation_rate = num_violations / num_comparable_pairs\n            \n        results.append(f\"{violation_rate:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}