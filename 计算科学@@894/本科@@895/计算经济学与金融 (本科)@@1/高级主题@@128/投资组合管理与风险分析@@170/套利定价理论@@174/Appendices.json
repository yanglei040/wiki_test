{"hands_on_practices": [{"introduction": "套利定价理论 (APT) 模型的基础是资产收益与系统性风险因子之间的线性关系。应用该理论的第一步是估计每项资产的因子载荷，即贝塔系数（$\\\\beta$）。本练习将引导你完成这一过程，并带有一个关键的现实考量：金融数据常包含极端事件，即“肥尾”现象，这会扭曲普通最小二乘法 (OLS) 等标准估计方法的结果。你将通过比较 OLS 与一种稳健回归技术，亲身体验在存在异常值时如何获得更可靠的贝塔估计。[@problem_id:2372129]", "id": "2372129", "problem": "考虑套利定价理论 (APT) 的线性多因子表示，其中对于每个资产指数 $i \\in \\{1,\\dots,N\\}$ 和时间指数 $t \\in \\{1,\\dots,T\\}$，收益率 $R_{i,t}$ 满足\n$$\nR_{i,t} \\;=\\; a_i \\;+\\; \\sum_{k=1}^{K} b_{i k}\\, f_{k,t} \\;+\\; \\varepsilon_{i,t}.\n$$\n假设存在以下数据生成过程。\n- 所有截距项满足 $a_i = 0$。\n- 因子载荷满足 $b_{i k} \\sim \\mathcal{N}(0,1)$，并在 $i$ 和 $k$ 上相互独立。\n- 因子满足 $f_{k,t} \\sim \\mathcal{N}(0,1)$，在 $k$ 和 $t$ 上相互独立，并且与所有其他随机元素独立。\n- 特定风险误差是肥尾的。令 $z_{i,t}$ 为自由度为 $\\nu$ 的独立同分布 (i.i.d.) 标准学生t分布变量，当 $\\nu>2$ 时，其通常方差为 $\\nu/(\\nu-2)$。定义单位方差变换 $e_{i,t} = \\sqrt{\\frac{\\nu-2}{\\nu}}\\, z_{i,t}$，使得 $\\mathrm{Var}(e_{i,t}) = 1$。设误差标准差为 $\\sigma_{\\varepsilon} = 0.5$，并设置 $\\varepsilon_{i,t} = \\sigma_{\\varepsilon} e_{i,t}$。\n\n对于每个资产 $i$，考虑基于 $T$ 个观测值 $\\{(R_{i,t}, f_{1,t},\\dots,f_{K,t})\\}_{t=1}^{T}$ 和一个截距项，通过两种估计器来估计 $K$ 维因子载荷向量 $(b_{i1},\\dots,b_{iK})$。令 $X_t = (1, f_{1,t}, \\dots, f_{K,t})$ 且 $\\theta_i = (a_i, b_{i1},\\dots,b_{iK})$。\n- 普通最小二乘 (OLS) 估计器是以下目标函数的最小化器\n$$\n\\sum_{t=1}^{T} \\left(R_{i,t} - X_t \\theta_i\\right)^2.\n$$\n- Huber 稳健估计器是以下目标函数的最小化器\n$$\n\\sum_{t=1}^{T} \\rho_{\\kappa}\\!\\left(R_{i,t} - X_t \\theta_i\\right),\n$$\n其中带阈值 $\\kappa$ 的 Huber 损失为\n$$\n\\rho_{\\kappa}(u) \\;=\\; \\begin{cases}\n\\frac{1}{2}u^2, & \\text{若 } |u| \\le \\kappa,\\\n$$6pt]\n\\kappa\\left(|u| - \\frac{1}{2}\\kappa\\right), & \\text{若 } |u| > \\kappa,\n\\end{cases}\n$$\n其中 $\\kappa = c\\,\\sigma_{\\varepsilon}$ 且 $c = 1.345$。\n\n对于每种估计器，将所有资产和因子上的因子载荷估计值的均方根误差 (RMSE) 定义为\n$$\n\\mathrm{RMSE} \\;=\\; \\sqrt{\\frac{1}{N K} \\sum_{i=1}^{N} \\sum_{k=1}^{K} \\left(\\widehat{b}_{i k} - b_{i k}\\right)^2},\n$$\n其中 $\\widehat{b}_{ik}$ 是资产 $i$ 和因子 $k$ 的估计因子载荷（不包括截距项）。\n\n模拟协议和测试套件：\n- 使用一个固定的基准伪随机种子 $s = 20231105$。对于测试用例索引 $j \\in \\{0,1,2,3\\}$，在为该测试用例生成所有随机元素之前，将伪随机种子设置为 $s+j$。\n- 对于下面的每个测试用例，从模型中生成一个模拟面板数据 $\\{R_{i,t}\\}$，并计算 OLS 估计器和 Huber 稳健估计器的 RMSE。对于该测试用例，输出布尔指标\n$$\nI_j \\;=\\; \\mathbf{1}\\!\\left\\{\\mathrm{RMSE}_{\\text{robust}} < \\mathrm{RMSE}_{\\text{OLS}}\\right\\}.\n$$\n\n测试套件（每个测试用例指定为 $(N, K, T, \\nu)$）：\n1. $(50, 3, 250, 30)$。\n2. $(50, 3, 250, 3)$。\n3. $(50, 3, 60, 4)$。\n4. $(200, 5, 250, 3)$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序与测试套件一致，即 $[I_0,I_1,I_2,I_3]$（例如，`[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]`）。不应打印任何其他文本。", "solution": "该问题陈述已经过严格验证，并被认为是有效的。它在科学上基于金融计量经济学的原理，特别是套利定价理论（APT），并提出了一个适定、客观且完整的计算任务。所有参数、分布和程序都以足够的精度进行了定义，以确保解决方案的唯一性和可复现性。\n\n该任务旨在比较 APT 模型中因子载荷的两种估计器的性能：普通最小二乘法（OLS）和使用 Huber 损失函数的稳健 M-估计器。此比较将通过模拟研究，在模型的不同参数化下进行，特别是关于特定风险误差分布的尾部厚度。\n\n资产收益率模型由下式给出\n$$\nR_{i,t} \\;=\\; a_i \\;+\\; \\sum_{k=1}^{K} b_{i k}\\, f_{k,t} \\;+\\; \\varepsilon_{i,t}\n$$\n其中 $a_i$ 是截距项，$b_{ik}$ 是因子载荷，$f_{k,t}$ 是系统性因子，而 $\\varepsilon_{i,t}$ 是特定风险误差。数据生成过程的参数指定为：$a_i = 0$，$b_{i k} \\sim \\mathcal{N}(0,1)$，以及 $f_{k,t} \\sim \\mathcal{N}(0,1)$。\n\n该模型的一个关键特征是特定风险误差 $\\varepsilon_{i,t}$ 的分布。这些误差被指定为肥尾分布，遵循一个经过缩放的学生t分布。具体来说，$\\varepsilon_{i,t} = \\sigma_{\\varepsilon} e_{i,t}$，其中 $\\sigma_{\\varepsilon} = 0.5$，而 $e_{i,t}$ 是自由度为 $\\nu$ 的标准学生t分布变量 $z_{i,t}$ 的一个变换，$e_{i,t} = \\sqrt{(\\nu-2)/\\nu} \\, z_{i,t}$。对于 $\\nu > 2$，此变换确保 $\\mathrm{Var}(e_{i,t}) = 1$，因此 $\\mathrm{Var}(\\varepsilon_{i,t}) = \\sigma_{\\varepsilon}^2$。自由度参数 $\\nu$ 控制误差分布的尾部厚度；较小的 $\\nu$ 值对应于更重的尾部和更高的观测到极端值（离群点）的概率。\n\n对于每个资产 $i$，参数向量 $\\theta_i = (a_i, b_{i1},\\dots,b_{iK})^T$ 使用 $T$ 个时间序列观测值进行估计。资产 $i$ 的回归模型是 $R_i = X \\theta_i + \\varepsilon_i$，其中 $R_i$ 是 $T \\times 1$ 的收益率向量，$X$ 是 $T \\times (K+1)$ 的设计矩阵，其列为 $(1, f_{1,\\cdot}, \\dots, f_{K,\\cdot})$，$\\varepsilon_i$ 是 $T \\times 1$ 的误差向量。\n\n两种估计器是：\n1.  **普通最小二乘法 (OLS)**：此估计器最小化残差平方和 $\\sum_{t=1}^{T} (R_{i,t} - X_t \\theta_i)^2$。其解析解由 $\\widehat{\\theta}_{i,\\text{OLS}} = (X^T X)^{-1} X^T R_i$ 给出。尽管在 Gauss-Markov 假设下（由于误差是独立且同方差的，这些假设在此成立），OLS 是最佳线性无偏估计器，但当误差分布不是正态分布而是肥尾分布时，由于其对大残差的敏感性，其效率会显著下降。\n\n2.  **Huber 稳健估计器**：此 M-估计器最小化 Huber 损失之和 $\\sum_{t=1}^{T} \\rho_{\\kappa}(R_{i,t} - X_t \\theta_i)$。Huber 损失函数 $\\rho_{\\kappa}(u)$ 在参数较小（$|u| \\le \\kappa$）时是二次的，在参数较大（$|u| > \\kappa$）时是线性的。这种混合特性使得该估计器在处理小残差观测值时表现得像 OLS，但会减少大残差观测值（离群点）的影响，从而提供稳健性。阈值设定为 $\\kappa = c\\,\\sigma_{\\varepsilon} = 1.345 \\times 0.5 = 0.6725$。这个凸目标函数的最小化没有解析解，需要进行数值优化。像 BFGS 这样的拟牛顿法是完成此任务的合适算法。\n\n估计器的性能通过因子载荷估计值 $\\widehat{b}_{ik}$ 的均方根误差 (RMSE) 进行评估，其定义为：\n$$\n\\mathrm{RMSE} \\;=\\; \\sqrt{\\frac{1}{N K} \\sum_{i=1}^{N} \\sum_{k=1}^{K} \\left(\\widehat{b}_{i k} - b_{i k}\\right)^2}\n$$\n对于每个测试用例，我们计算一个布尔指标 $I_j = \\mathbf{1}\\{\\mathrm{RMSE}_{\\text{robust}} < \\mathrm{RMSE}_{\\text{OLS}}\\}$。我们预期当误差分布具有重尾（$\\nu$ 较小）时，稳健估计器的性能将优于 OLS（即产生更小的 RMSE），而当误差接近正态分布（$\\nu$ 较大）时，OLS 可能略有优势。\n\n解决方案通过实施指定的模拟协议来进行。对于每个测试用例，所有随机元素都基于一个固定的种子生成。然后，对于 $N$ 个资产中的每一个，计算因子载荷的 OLS 估计和 Huber 估计。Huber 估计是使用 `scipy.optimize` 库中的 `minimize` 函数执行的。在收集所有资产的估计值后，计算并比较各自的 RMSE 以确定布尔指标。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating asset returns from an APT model\n    and comparing the performance of OLS and Huber robust regression estimators.\n    \"\"\"\n    \n    # Simulation protocol parameters\n    base_seed = 20231105\n    c = 1.345\n    sigma_eps = 0.5\n    kappa = c * sigma_eps\n\n    test_cases = [\n        (50, 3, 250, 30),  # Case j=0\n        (50, 3, 250, 3),   # Case j=1\n        (50, 3, 60, 4),    # Case j=2\n        (200, 5, 250, 3),  # Case j=3\n    ]\n\n    results = []\n\n    def huber_loss(u, k):\n        \"\"\"Vectorized Huber loss function.\"\"\"\n        abs_u = np.abs(u)\n        is_small = abs_u <= k\n        \n        quadratic_loss = 0.5 * u[is_small]**2\n        linear_loss = k * (abs_u[~is_small] - 0.5 * k)\n        \n        loss = np.zeros_like(u)\n        loss[is_small] = quadratic_loss\n        loss[~is_small] = linear_loss\n        \n        return loss\n\n    def huber_objective(theta, X, y, k):\n        \"\"\"Objective function for Huber regression.\"\"\"\n        residuals = y - X @ theta\n        return np.sum(huber_loss(residuals, k))\n\n    for j, (N, K, T, nu) in enumerate(test_cases):\n        # Set the seed for reproducibility for the current test case\n        np.random.seed(base_seed + j)\n\n        # 1. Generate data from the specified DGP\n        # True factor loadings b_ik ~ N(0,1)\n        b_true = np.random.randn(N, K)\n        \n        # Factors f_kt ~ N(0,1)\n        factors = np.random.randn(K, T)\n        \n        # Idiosyncratic errors e_it with heavy tails\n        # z_it ~ Student's t with nu degrees of freedom\n        z = np.random.standard_t(df=nu, size=(N, T))\n        # Scale z to have unit variance\n        e = z * np.sqrt((nu - 2) / nu)\n        # Scale by error standard deviation\n        eps = sigma_eps * e\n        \n        # Generate asset returns R = b*f + eps (since a_i=0)\n        # R is an N x T matrix\n        R = b_true @ factors + eps\n\n        # 2. Prepare for estimation\n        # Design matrix X is T x (K+1), common for all assets\n        X = np.hstack([np.ones((T, 1)), factors.T])\n        \n        # Matrices to store estimated factor loadings (excluding intercept)\n        b_hat_ols = np.zeros((N, K))\n        b_hat_huber = np.zeros((N, K))\n\n        # 3. Estimate parameters for each asset\n        for i in range(N):\n            R_i = R[i, :]  # Returns for asset i (T x 1)\n            \n            # OLS Estimation\n            # theta_ols = (X'X)^-1 X'R_i\n            try:\n                theta_ols = np.linalg.solve(X.T @ X, X.T @ R_i)\n            except np.linalg.LinAlgError:\n                # Use pseudo-inverse if X'X is singular, though unlikely\n                theta_ols = np.linalg.pinv(X) @ R_i\n            \n            b_hat_ols[i, :] = theta_ols[1:]\n            \n            # Huber Robust Estimation\n            # Use OLS estimate as a starting point for the optimization\n            res = minimize(\n                fun=huber_objective,\n                x0=theta_ols,\n                args=(X, R_i, kappa),\n                method='BFGS',\n                options={'gtol': 1e-6}\n            )\n            theta_huber = res.x\n            b_hat_huber[i, :] = theta_huber[1:]\n\n        # 4. Calculate RMSE for factor loadings\n        rmse_ols = np.sqrt(np.mean((b_hat_ols - b_true)**2))\n        rmse_huber = np.sqrt(np.mean((b_hat_huber - b_true)**2))\n        \n        # 5. Compare RMSEs and store the boolean indicator\n        results.append(rmse_huber < rmse_ols)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "掌握了如何估计单一资产对各因子的敏感度（即贝塔系数）之后，下一个合理的问题是：与这些因子相关联的市场价格，或者说风险溢价（$\\\\lambda$），究竟是多少？本练习将介绍著名的 Fama-MacBeth 两步回归法，这是一种从大量资产的横截面数据中估计这些因子风险溢价的标准方法。通过实现该方法的滚动窗口版本，你不仅将估计出风险溢价，还将探索这些风险价格如何随时间变化，这是金融市场的一个关键动态。[@problem_id:2372104]", "id": "2372104", "problem": "您的任务是在套利定价理论（Arbitrage Pricing Theory, APT）的框架下，实现一个时变因子风险溢价的滚动估计量。该理论正式名称为套利定价理论 (APT)。考虑一个针对 $N$ 个资产在 $T$ 个时间周期内的线性 $K$ 因子模型。对于每个资产 $i \\in \\{1,\\dots,N\\}$ 和时间 $t \\in \\{1,\\dots,T\\}$，其超额收益过程定义为\n$$\nr_{i,t} \\;=\\; \\boldsymbol{\\beta}_{i}^{\\top}\\boldsymbol{f}_{t} \\;+\\; \\varepsilon_{i,t},\n$$\n其中 $\\boldsymbol{\\beta}_{i} \\in \\mathbb{R}^{K}$ 是资产 $i$ 的因子载荷的（不随时变的）向量，$\\boldsymbol{f}_{t} \\in \\mathbb{R}^{K}$ 是时间 $t$ 的因子实现值向量，其期望 $\\mathbb{E}[\\boldsymbol{f}_{t}] = \\boldsymbol{\\lambda}$（因子风险溢价向量），而 $\\varepsilon_{i,t}$ 是特质噪声，其期望 $\\mathbb{E}[\\varepsilon_{i,t}] = 0$，且在各资产间相互独立，并独立于 $\\boldsymbol{f}_{t}$。\n\n您必须使用如下定义的滚动窗口程序来估计与第三个因子（解释为高减低因子，记作 $\\mathrm{HML}$）相关的风险溢价的时间序列 $\\{\\widehat{\\lambda}_{\\mathrm{HML}}(t)\\}$。固定一个窗口长度 $W$。对于每个时间 $t \\in \\{W, W+1, \\dots, T-1\\}$：\n1. 通过求解最小二乘问题，为每个资产 $i$ 估计因子载荷 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)$\n$$\n\\widehat{\\boldsymbol{\\beta}}_{i}(t) \\;=\\; \\arg\\min_{\\boldsymbol{b} \\in \\mathbb{R}^{K}} \\sum_{\\tau = t-W}^{t-1} \\left(r_{i,\\tau} \\;-\\; \\boldsymbol{b}^{\\top}\\boldsymbol{f}_{\\tau}\\right)^{2}.\n$$\n2. 通过求解横截面最小二乘问题，估计时间 $t$ 的因子风险溢价\n$$\n\\widehat{\\boldsymbol{\\lambda}}(t) \\;=\\; \\arg\\min_{\\boldsymbol{\\theta} \\in \\mathbb{R}^{K}} \\sum_{i = 1}^{N} \\left(r_{i,t} \\;-\\; \\widehat{\\boldsymbol{\\beta}}_{i}(t)^{\\top}\\boldsymbol{\\theta}\\right)^{2}.\n$$\n3. 将 $\\mathrm{HML}$ 溢价估计值记录为 $\\widehat{\\lambda}_{\\mathrm{HML}}(t)$，即 $\\widehat{\\boldsymbol{\\lambda}}(t)$ 的第三个分量。\n\n所有收益和溢价都必须作为纯小数处理（例如，0.01 代表百分之一的小数形式）。不涉及物理单位。不涉及角度。不得使用百分比；请以小数形式表示数量。\n\n您不会得到经验数据。相反，您必须根据下面测试套件中指定的参数，按照上述模型模拟数据。对于每个测试用例，请执行以下操作：\n- 各资产和各因子的因子载荷 $\\boldsymbol{\\beta}_{i}$ 独立模拟为高斯分布抽样，其均值和标准差在测试用例中指定。\n- 因子实现值 $\\boldsymbol{f}_{t}$ 模拟为独立的多元正态分布抽样，其均值 $\\boldsymbol{\\lambda}$ 和对角协方差在测试用例中指定。\n- 特质冲击 $\\varepsilon_{i,t}$ 模拟为独立的的高斯分布抽样，其均值为 $0$，标准差 $\\sigma_{\\varepsilon}$ 在测试用例中指定。\n- 完全按照上述定义构建收益 $r_{i,t}$。\n- 应用滚动估计得到时间序列 $\\{\\widehat{\\lambda}_{\\mathrm{HML}}(t)\\}_{t=W}^{T-1}$。\n- 对每个测试用例，计算 $\\mathrm{HML}$ 溢价估计值的时间序列平均值，\n$$\n\\overline{\\lambda}_{\\mathrm{HML}} \\;=\\; \\frac{1}{T-W}\\sum_{t=W}^{T-1} \\widehat{\\lambda}_{\\mathrm{HML}}(t),\n$$\n并四舍五入到六位小数。\n\n测试套件：\n使用 $K = 3$ 个因子，顺序为 $\\mathrm{MKT}$、$\\mathrm{SMB}$、$\\mathrm{HML}$，因此 $\\mathrm{HML}$ 的索引为 $3$。在所有情况下，将收益视为小数。\n\n- 案例 A（理想路径，数十年样本）：\n  - $N = 40$，$T = 480$，$W = 120$，随机种子 $= 202311$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.005, 0.002, 0.004]$。\n  - 因子协方差对角线 $= [0.03^{2}, 0.02^{2}, 0.025^{2}]$。\n  - 特质标准差 $\\sigma_{\\varepsilon} = 0.04$。\n  - 因子载荷均值 $[\\mu_{\\beta,\\mathrm{MKT}}, \\mu_{\\beta,\\mathrm{SMB}}, \\mu_{\\beta,\\mathrm{HML}}] = [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $[\\sigma_{\\beta,\\mathrm{MKT}}, \\sigma_{\\beta,\\mathrm{SMB}}, \\sigma_{\\beta,\\mathrm{HML}}] = [0.3, 0.2, 0.25]$。\n\n- 案例 B（较短窗口，较高波动性）：\n  - $N = 25$，$T = 240$，$W = 24$，随机种子 $= 202312$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.006, 0.001, 0.004]$。\n  - 因子协方差对角线 $= [0.05^{2}, 0.025^{2}, 0.035^{2}]$。\n  - 特质标准差 $\\sigma_{\\varepsilon} = 0.06$。\n  - 因子载荷均值 $= [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $= [0.3, 0.2, 0.25]$。\n\n- 案例 C（零 $\\mathrm{HML}$ 溢价）：\n  - $N = 35$，$T = 360$，$W = 36$，随机种子 $= 202313$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.004, 0.002, 0.0]$。\n  - 因子协方差对角线 $= [0.03^{2}, 0.02^{2}, 0.025^{2}]$。\n  - 特质标准差 $\\sigma_{\\varepsilon} = 0.04$。\n  - 因子载荷均值 $= [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $= [0.3, 0.2, 0.25]$。\n\n- 案例 D（横截面接近识别边界）：\n  - $N = 4$，$T = 120$，$W = 36$，随机种子 $= 202314$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.005, 0.003, 0.003]$。\n  - 因子协方差对角线 $= [0.02^{2}, 0.015^{2}, 0.02^{2}]$。\n  - 特质标准差 $\\sigma_{\\varepsilon} = 0.03$。\n  - 因子载荷均值 $= [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $= [0.3, 0.2, 0.25]$。\n\n所需最终输出格式：\n您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表的结果，每个元素是对应测试用例的 $\\overline{\\lambda}_{\\mathrm{HML}}$ 值，顺序为 A、B、C、D。每个值必须四舍五入到六位小数。例如：”[0.003950,0.004210,-0.000015,0.003120]”。", "solution": "该问题陈述已经过验证，被认为是可接受的。这是一个在计算金融学领域中定义明确的问题，基于成熟的计量经济学方法。它要求在一个模拟的套利定价理论（APT）框架中，实施一种滚动两步回归（通常称为 Fama-MacBeth 过程）来估计因子风险溢价。模拟参数和估计步骤的说明清晰严谨，足以得出一个唯一且可验证的解。\n\n该问题的核心是从一个线性因子模型中估计时变因子风险溢价 $\\{\\widehat{\\boldsymbol{\\lambda}}(t)\\}$。资产 $i$ 在时间 $t$ 的模型由下式给出：\n$$\nr_{i,t} \\;=\\; \\boldsymbol{\\beta}_{i}^{\\top}\\boldsymbol{f}_{t} \\;+\\; \\varepsilon_{i,t}\n$$\n其中 $\\boldsymbol{\\beta}_{i} \\in \\mathbb{R}^{K}$ 是时间不变的因子载荷，$\\boldsymbol{f}_{t} \\in \\mathbb{R}^{K}$ 是因子实现值，$\\varepsilon_{i,t}$ 是特质噪声。该过程涉及在滚动窗口上执行的两个连续阶段的普通最小二乘法（OLS）估计。\n\n首先，我们必须根据指定的随机过程生成数据。对于给定的具有 $N$ 个资产、$T$ 个时间周期和 $K=3$ 个因子的测试用例，我们按以下步骤操作：\n\n1.  **因子载荷模拟**：生成因子载荷矩阵 $\\boldsymbol{\\beta} \\in \\mathbb{R}^{N \\times K}$。该矩阵的每一列 $k \\in \\{1, 2, 3\\}$（对应一个因子）均从独立的每个资产 $i=1, \\dots, N$ 的正态分布中抽取，即 $\\boldsymbol{\\beta}_{i,k} \\sim \\mathcal{N}(\\mu_{\\beta,k}, \\sigma_{\\beta,k}^2)$。\n\n2.  **因子实现值模拟**：生成因子实现值矩阵 $\\mathbf{F} \\in \\mathbb{R}^{T \\times K}$。每一行 $\\boldsymbol{f}_{t}^{\\top}$ 都是从一个多元正态分布中独立抽取的，即 $\\boldsymbol{f}_{t} \\sim \\mathcal{N}(\\boldsymbol{\\lambda}, \\boldsymbol{\\Sigma}_{f})$，其中 $\\boldsymbol{\\lambda}$ 是真实因子溢价向量，$\\boldsymbol{\\Sigma}_{f}$ 是指定的对角协方差矩阵。\n\n3.  **特质冲击模拟**：生成特质冲击矩阵 $\\mathbf{E} \\in \\mathbb{R}^{T \\times N}$。每个元素 $\\varepsilon_{i,t}$ 都是从均值为 $0$、标准差为 $\\sigma_{\\varepsilon}$ 的正态分布中独立抽取的，即 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0, \\sigma_{\\varepsilon}^2)$。\n\n4.  **资产收益构建**：通过组合模拟的各分量，根据模型构建资产收益矩阵 $\\mathbf{R} \\in \\mathbb{R}^{T \\times N}$：\n    $$\n    \\mathbf{R} = \\mathbf{F}\\boldsymbol{\\beta}^{\\top} + \\mathbf{E}\n    $$\n    这里，$\\mathbf{R}$ 的第 $(t,i)$ 个元素是 $r_{i,t}$。\n\n有了模拟数据后，我们实施滚动的两步估计。对于从 $W$ 到 $T-1$ 的每个时间步 $t$：\n\n**第一阶段：时间序列回归**\n对于每个资产 $i \\in \\{1,\\dots,N\\}$，我们使用长度为 $W$ 的前一个窗口的数据（即从时间 $\\tau = t-W$ 到 $t-1$）来估计其因子载荷 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)$。这是将资产收益对因子实现值进行的 OLS 回归。对于所有资产，以矩阵形式表示，令 $\\mathbf{R}_{\\text{win},t} \\in \\mathbb{R}^{W \\times N}$ 为窗口内所有资产的收益矩阵，$\\mathbf{F}_{\\text{win},t} \\in \\mathbb{R}^{W \\times K}$ 为因子实现值矩阵。我们求解估计载荷矩阵 $\\widehat{\\mathbf{B}}(t) \\in \\mathbb{R}^{K \\times N}$：\n$$\n\\mathbf{R}_{\\text{win},t} = \\mathbf{F}_{\\text{win},t} \\widehat{\\mathbf{B}}(t) + \\text{误差矩阵}\n$$\nOLS 解为 $\\widehat{\\mathbf{B}}(t) = (\\mathbf{F}_{\\text{win},t}^{\\top} \\mathbf{F}_{\\text{win},t})^{-1} \\mathbf{F}_{\\text{win},t}^{\\top} \\mathbf{R}_{\\text{win},t}$。为保证数值稳定性，这通常使用诸如 QR 分解之类的方法来求解，例如在 `numpy.linalg.lstsq` 中实现的。结果是一个矩阵，其第 $i$ 列是 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)$。\n\n**第二阶段：横截面回归**\n在时间 $t$，我们使用第一阶段估计的载荷 $\\widehat{\\mathbf{B}}(t)$ 来估计因子风险溢价 $\\widehat{\\boldsymbol{\\lambda}}(t) \\in \\mathbb{R}^{K}$。这是在时间 $t$ 对所有资产收益与其相应估计载荷进行的单次横截面 OLS 回归。令 $\\mathbf{r}_{t} \\in \\mathbb{R}^{N}$ 为时间 $t$ 的资产收益向量，并令 $\\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t} \\in \\mathbb{R}^{N \\times K}$ 为第一阶段矩阵的转置，即 $\\widehat{\\mathbf{B}}(t)^{\\top}$，使其第 $i$ 行为 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)^{\\top}$。我们求解 $\\widehat{\\boldsymbol{\\lambda}}(t)$：\n$$\n\\mathbf{r}_{t} = \\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t} \\widehat{\\boldsymbol{\\lambda}}(t) + \\text{误差向量}\n$$\nOLS 解为 $\\widehat{\\boldsymbol{\\lambda}}(t) = (\\widehatboldsymbol{\\beta}}_{\\text{CS},t}^{\\top} \\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t})^{-1} \\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t}^{\\top} \\mathbf{r}_{t}$。同样，使用数值稳定的求解器。\n\n从得到的向量 $\\widehat{\\boldsymbol{\\lambda}}(t)$ 中，我们提取第三个分量，即对应于 $\\mathrm{HML}$ 因子溢价的 $\\widehat{\\lambda}_{\\mathrm{HML}}(t)$。对 $[W, T-1]$ 范围内的所有 $t$ 重复此过程。\n\n最后，$\\mathrm{HML}$ 平均溢价的总体估计值计算为所收集估计值的时间序列均值：\n$$\n\\overline{\\lambda}_{\\mathrm{HML}} \\;=\\; \\frac{1}{T-W}\\sum_{t=W}^{T-1} \\widehat{\\lambda}_{\\mathrm{HML}}(t)\n$$\n实现将封装此逻辑，通过带种子的生成器确保随机数生成的可复现性，并使用高效的线性代数例程进行 OLS 估计。每个测试用例的最终结果将按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef estimate_hml_premium_average(\n    N: int, T: int, W: int, seed: int,\n    lambda_true: np.ndarray, factor_cov_diag: np.ndarray,\n    sigma_eps: float, beta_means: np.ndarray, beta_stds: np.ndarray\n) -> float:\n    \"\"\"\n    Simulates data and computes the time-series average of the estimated HML factor premium.\n\n    This function implements a rolling two-pass regression (Fama-MacBeth) procedure.\n    \"\"\"\n    # Use a seeded random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n    \n    # The number of factors K is implicitly 3 from the input array dimensions.\n    K = len(lambda_true)\n\n    # 1. Simulate data according to the APT model.\n    # 1a. Factor loadings (betas): N x K matrix. Time-invariant.\n    beta_true = rng.normal(loc=beta_means, scale=beta_stds, size=(N, K))\n\n    # 1b. Factor realizations: T x K matrix.\n    factor_cov = np.diag(factor_cov_diag)\n    factors = rng.multivariate_normal(mean=lambda_true, cov=factor_cov, size=T)\n\n    # 1c. Idiosyncratic shocks: T x N matrix.\n    epsilon = rng.normal(loc=0.0, scale=sigma_eps, size=(T, N))\n    \n    # 1d. Asset excess returns: T x N matrix.\n    # The equation is r_it = beta_i' * f_t + eps_it.\n    # In matrix form: R = F @ B.T + E\n    returns = factors @ beta_true.T + epsilon\n\n    hml_premium_estimates = []\n\n    # 2. Perform rolling estimation for t from W to T-1.\n    for t in range(W, T):\n        # Define the time window for the first-pass regression.\n        window_start = t - W\n        window_end = t\n\n        # --- Stage 1: Time-series regressions to estimate betas ---\n        # For each asset, regress its return history on factor history.\n        # X: factor realizations in the window (W x K)\n        # Y: asset returns in the window (W x N)\n        X_ts = factors[window_start:window_end, :]\n        Y_ts = returns[window_start:window_end, :]\n        \n        # np.linalg.lstsq solves aX = b. Here a=X_ts, b=Y_ts.\n        # The solution X is a (K x N) matrix of estimated betas.\n        # Each column is the beta vector for one asset.\n        beta_hat_matrix = np.linalg.lstsq(X_ts, Y_ts, rcond=None)[0]\n        \n        # We need an (N x K) matrix for the second stage, where each row is a beta vector.\n        beta_hats_for_cs = beta_hat_matrix.T\n\n        # --- Stage 2: Cross-sectional regression to estimate risk premia ---\n        # At time t, regress asset returns on their estimated betas.\n        # X: estimated betas across assets (N x K)\n        # y: asset returns at time t (N x 1)\n        X_cs = beta_hats_for_cs\n        y_cs = returns[t, :]\n        \n        # Solves X_cs @ lambda_hat = y_cs for lambda_hat.\n        # The solution is the (K x 1) vector of estimated factor premia at time t.\n        lambda_hat_t = np.linalg.lstsq(X_cs, y_cs, rcond=None)[0]\n\n        # The HML factor is the third factor (index 2).\n        hml_premium_t = lambda_hat_t[2]\n        hml_premium_estimates.append(hml_premium_t)\n\n    # 3. Calculate the time-series average of the HML premium estimates.\n    average_hml_premium = np.mean(hml_premium_estimates)\n    \n    return average_hml_premium\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the estimation for each, printing the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 40, \"T\": 480, \"W\": 120, \"seed\": 202311,\n            \"lambda_true\": np.array([0.005, 0.002, 0.004]),\n            \"factor_cov_diag\": np.array([0.03**2, 0.02**2, 0.025**2]),\n            \"sigma_eps\": 0.04,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        },\n        {\n            \"N\": 25, \"T\": 240, \"W\": 24, \"seed\": 202312,\n            \"lambda_true\": np.array([0.006, 0.001, 0.004]),\n            \"factor_cov_diag\": np.array([0.05**2, 0.025**2, 0.035**2]),\n            \"sigma_eps\": 0.06,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        },\n        {\n            \"N\": 35, \"T\": 360, \"W\": 36, \"seed\": 202313,\n            \"lambda_true\": np.array([0.004, 0.002, 0.0]),\n            \"factor_cov_diag\": np.array([0.03**2, 0.02**2, 0.025**2]),\n            \"sigma_eps\": 0.04,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        },\n        {\n            \"N\": 4, \"T\": 120, \"W\": 36, \"seed\": 202314,\n            \"lambda_true\": np.array([0.005, 0.003, 0.003]),\n            \"factor_cov_diag\": np.array([0.02**2, 0.015**2, 0.02**2]),\n            \"sigma_eps\": 0.03,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        avg_premium = estimate_hml_premium_average(**case_params)\n        # Round the final average to 6 decimal places and format.\n        results.append(f\"{avg_premium:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "像APT这样的因子模型的真正威力在于它们在投资组合构建中的应用。如果我们能够衡量因子风险，我们是否也能管理它们？本实践挑战你构建一个“纯因子”投资组合——一个旨在对单一目标因子具有精确的单位敞口，同时对所有其他因子保持中性，并最小化其自身方差的投资组合。这是量化金融中用于分离风险因子、进行对冲和构建复杂投资策略的核心技术。你将使用二次优化来找到最优的投资组合权重，将因子投资理论直接转化为一个可行的、可实施的解决方案。[@problem_id:2372091]", "id": "2372091", "problem": "设计一个程序，该程序根据套利定价理论（Arbitrage Pricing Theory, APT）的原理，通过二次优化从头构建一个“纯因子”投资组合。对于每个测试用例，会给定一个因子载荷矩阵 $B \\in \\mathbb{R}^{N \\times K}$，一个对称正定资产收益协方差矩阵 $\\Sigma \\in \\mathbb{R}^{N \\times N}$，以及一个目标因子索引 $j \\in \\{1,\\dots,K\\}$。任务是计算投资组合权重 $w \\in \\mathbb{R}^{N}$，该权重在满足对目标因子实现单位暴露、对所有其他因子实现零暴露以及零投资（美元中性）的约束条件下，最小化投资组合的方差。\n\n形式上，对于每个测试用例，求解以下优化问题：\n最小化投资组合方差\n$$\n\\min_{w \\in \\mathbb{R}^{N}} \\; w^{\\top} \\Sigma \\, w\n$$\n受以下线性等式约束\n$$\nB^{\\top} w \\;=\\; e_j, \\quad \\mathbf{1}^{\\top} w \\;=\\; 0,\n$$\n其中 $e_j \\in \\mathbb{R}^{K}$ 是第 $j$ 个标准基向量（即在位置 $j$ 处为 $1$，其他位置为 $0$ 的向量），$\\mathbf{1} \\in \\mathbb{R}^{N}$ 表示全1向量。所有量纲均为无单位；任何“百分比”都必须以小数形式表示。\n\n您的程序必须为每个测试用例生成三个诊断指标：\n- 最大绝对因子暴露偏差\n$$\n\\epsilon_{\\text{fac}} \\;=\\; \\max_{1 \\le k \\le K} \\left| \\left(B^{\\top} w\\right)_k - (e_j)_k \\right|.\n$$\n- 绝对净投资额\n$$\n\\epsilon_{\\text{net}} \\;=\\; \\left| \\mathbf{1}^{\\top} w \\right|.\n$$\n- 实现的最小方差\n$$\nv \\;=\\; w^{\\top} \\Sigma \\, w.\n$$\n\n您每个测试用例的输出必须是列表 $[\\epsilon_{\\text{fac}}, \\epsilon_{\\text{net}}, v]$，其中每个值都四舍五入到 $8$ 位小数。\n\n测试套件。请精确使用以下三个测试用例：\n\n测试用例 A（正常情况）：\n- $N = 5$, $K = 2$, $j = 1$。\n- 因子载荷\n$$\nB \\;=\\;\n\\begin{bmatrix}\n0.5 & 1.0 \\\\\n1.2 & -0.3 \\\\\n-0.7 & 0.8 \\\\\n0.0 & -0.5 \\\\\n0.9 & 0.2\n\\end{bmatrix}.\n$$\n- 协方差（对角、正定）\n$$\n\\Sigma \\;=\\; \\mathrm{diag}\\!\\left(0.04, \\; 0.09, \\; 0.025, \\; 0.16, \\; 0.0625\\right).\n$$\n\n测试用例 B（边界情况：$N = K+1$，有唯一可行解）：\n- $N = 3$, $K = 2$, $j = 1$。\n- 因子载荷\n$$\nB \\;=\\;\n\\begin{bmatrix}\n1.0 & 0.0 \\\\\n0.5 & 1.0 \\\\\n-0.5 & 0.5\n\\end{bmatrix}.\n$$\n- 协方差（对角、正定）\n$$\n\\Sigma \\;=\\; \\mathrm{diag}\\!\\left(0.01, \\; 0.02, \\; 0.03\\right).\n$$\n\n测试用例 C（病态但正定的协方差）：\n- $N = 8$, $K = 3$, $j = 1$。\n- 因子载荷\n$$\nB \\;=\\;\n\\begin{bmatrix}\n0.2 & -0.1 & 0.3 \\\\\n1.1 & 0.4 & -0.2 \\\\\n-0.3 & 0.9 & 0.5 \\\\\n0.0 & -0.2 & 0.1 \\\\\n0.7 & 0.0 & -0.4 \\\\\n-0.6 & 0.3 & 0.2 \\\\\n0.4 & -0.5 & 0.0 \\\\\n0.8 & 0.1 & 0.6\n\\end{bmatrix}.\n$$\n- 协方差由以下公式定义\n$$\n\\Sigma \\;=\\; D \\;+\\; 0.001 \\cdot \\mathbf{1}\\mathbf{1}^{\\top},\n$$\n其中 $D = \\mathrm{diag}\\!\\left(0.04, \\; 0.01, \\; 0.09, \\; 0.0025, \\; 0.0225, \\; 0.01, \\; 0.04, \\; 0.0025\\right)$ 且 $\\mathbf{1}\\mathbf{1}^{\\top}$ 是 $N \\times N$ 的全1矩阵。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个逗号分隔的列表，该列表由三个元素的列表组成，每个内部列表按 A、B、C 的顺序对应一个测试用例。每个数字必须四舍五入到 $8$ 位小数。例如，输出格式必须为\n$$\n\\texttt{[[a\\_1,a\\_2,a\\_3],[b\\_1,b\\_2,b\\_3],[c\\_1,c\\_2,c\\_3]]}\n$$\n不带任何额外文本，其中每个符号代表一个如上所述的十进制数。", "solution": "所提出的问题是一个有约束的二次优化任务，这是计算金融学中的一个基本问题，特别是在套利定价理论（APT）背景下的投资组合构建中。目标是找到一个投资组合权重向量 $w$，它在满足一系列线性约束的条件下，最小化风险（以投资组合方差量化）。这些线性约束定义了投资组合对系统性风险因子的暴露及其净投资。\n\n该问题可正式表述如下。找到投资组合权重向量 $w \\in \\mathbb{R}^{N}$，求解：\n$$\n\\min_{w} f(w) = \\frac{1}{2} w^{\\top} \\Sigma w\n$$\n受以下线性等式约束：\n$$\nB^{\\top} w = e_j\n$$\n$$\n\\mathbf{1}^{\\top} w = 0\n$$\n在这里，$w$ 是资产权重的 $N \\times 1$ 向量，$\\Sigma$ 是资产收益的 $N \\times N$ 对称正定协方差矩阵，$B$ 是因子载荷的 $N \\times K$ 矩阵，$\\mathbf{1}$ 是全1的 $N \\times 1$ 向量，$e_j$ 是第 $j$ 个位置为 $1$、其他位置为零的 $K \\times 1$ 标准基向量。因子 $\\frac{1}{2}$ 是为了数学上的便利而引入的，它不改变最小值的位置。\n\n这些约束可以合并成一个单一的矩阵方程 $C w = d$，其中 $C$ 是一个 $(K+1) \\times N$ 矩阵，$d$ 是一个 $(K+1) \\times 1$ 向量：\n$$\nC = \\begin{bmatrix} B^{\\top} \\\\ \\mathbf{1}^{\\top} \\end{bmatrix}, \\quad d = \\begin{bmatrix} e_j \\\\ 0 \\end{bmatrix}\n$$\n因此，该问题是一个标准的等式约束二次规划问题。由于协方差矩阵 $\\Sigma$ 是正定的，目标函数 $f(w)$是严格凸的。这一性质与约束的线性特性相结合，保证了只要约束系统可行且 $C$ 的行是线性独立的，就存在唯一的全局最小值。\n\n为了找到解析解，我们采用拉格朗日乘子法。该问题的拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}(w, \\lambda) = \\frac{1}{2} w^{\\top} \\Sigma w + \\lambda^{\\top} (d - Cw)\n$$\n其中 $\\lambda$ 是拉格朗日乘子的 $(K+1) \\times 1$ 向量。一阶最优性必要条件要求拉格朗日函数对 $w$ 和 $\\lambda$ 的梯度为零。\n\n对 $w$ 的梯度为：\n$$\n\\nabla_w \\mathcal{L} = \\Sigma w - C^{\\top} \\lambda = 0\n$$\n由于 $\\Sigma$ 是正定的，它是可逆的。因此，我们可以用 $\\lambda$ 来表示 $w$：\n$$\nw = \\Sigma^{-1} C^{\\top} \\lambda\n$$\n对 $\\lambda$ 的梯度只是恢复了线性约束：\n$$\n\\nabla_\\lambda \\mathcal{L} = d - Cw = 0 \\implies Cw = d\n$$\n将 $w$ 的表达式代入约束方程，得到：\n$$\nC (\\Sigma^{-1} C^{\\top} \\lambda) = d\n$$\n这可以写成关于拉格朗日乘子 $\\lambda$ 的线性系统：\n$$\n(C \\Sigma^{-1} C^{\\top}) \\lambda = d\n$$\n矩阵 $M = C \\Sigma^{-1} C^{\\top}$ 是一个 $(K+1) \\times (K+1)$ 矩阵。鉴于 $\\Sigma^{-1}$ 是正定的，且我们假设约束矩阵 $C$ 具有行满秩（即其行是线性独立的），矩阵 $M$ 也是正定的，因此是可逆的。我们可以解出 $\\lambda$：\n$$\n\\lambda = (C \\Sigma^{-1} C^{\\top})^{-1} d\n$$\n最后，将这个 $\\lambda$ 的表达式代回 $w$ 的方程中，就得到了最优投资组合权重的解析解：\n$$\nw = \\Sigma^{-1} C^{\\top} (C \\Sigma^{-1} C^{\\top})^{-1} d\n$$\n一个特殊情况是当 $N = K+1$ 时，如测试用例 B 所示。此时，约束矩阵 $C$ 是方阵。如果它是可逆的，系统 $Cw=d$ 有唯一解 $w=C^{-1}d$。这个唯一的可行点根据定义就是最小值。通用公式正确地退化到这种情况，因为 $w = \\Sigma^{-1} C^{\\top} (C^{\\top})^{-1} \\Sigma C^{-1} d = C^{-1}d$。\n\n计算步骤如下：\n$1$. 对于每个测试用例，构建矩阵 $B$、$\\Sigma$ 以及参数 $N$、 $K$、 $j$。\n$2$. 构建复合约束矩阵 $C$ 和目标向量 $d$。注意，问题指定 $j$ 是 1-indexed 的，在进行数组操作时必须将其转换为 0-indexed。\n$3$. 计算协方差矩阵的逆矩阵 $\\Sigma^{-1}$。\n$4$. 构建矩阵 $M = C \\Sigma^{-1} C^{\\top}$。\n$5$. 求解线性系统 $M \\lambda = d$ 以得到向量 $\\lambda$。使用线性求解器在数值上优于显式计算 $M$ 的逆矩阵。\n$6$. 计算最优权重向量 $w = \\Sigma^{-1} C^{\\top} \\lambda$。\n$7$. 使用计算出的 $w$，计算三个所需的诊断量：\n    - 最大绝对因子暴露偏差：$\\epsilon_{\\text{fac}} = \\max_{k} |(B^{\\top} w)_k - (e_j)_k|$。\n    - 绝对净投资额：$\\epsilon_{\\text{net}} = |\\mathbf{1}^{\\top} w|$。\n    - 最小投资组合方差：$v = w^{\\top} \\Sigma w$。\n\n$\\epsilon_{\\text{fac}}$ 和 $\\epsilon_{\\text{net}}$ 的数值结果应接近机器精度，这确认了实现在满足约束方面的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_single_case(B, Sigma, j, N, K):\n    \"\"\"\n    Solves the quadratic optimization problem for a single test case.\n\n    Args:\n        B (np.ndarray): Factor loading matrix (N x K).\n        Sigma (np.ndarray): Asset return covariance matrix (N x N).\n        j (int): 1-based index of the target factor.\n        N (int): Number of assets.\n        K (int): Number of factors.\n\n    Returns:\n        list: A list containing [eps_fac, eps_net, variance].\n    \"\"\"\n    # Convert 1-based target factor index to 0-based\n    target_idx = j - 1\n\n    # Construct the constraint matrix C of size (K+1) x N\n    C_mat = np.vstack([B.T, np.ones(N)])\n\n    # Construct the constraint target vector d of size (K+1)\n    d_vec = np.zeros(K + 1)\n    d_vec[target_idx] = 1.0\n\n    # Since Sigma is positive definite, its inverse exists.\n    Sigma_inv = np.linalg.inv(Sigma)\n\n    # Form the matrix for the linear system for Lagrange multipliers.\n    # M = C * Sigma_inv * C.T, which is of size (K+1) x (K+1).\n    M = C_mat @ Sigma_inv @ C_mat.T\n\n    # Solve the system M * lambda = d for the Lagrange multipliers lambda.\n    # This is numerically more stable than computing inv(M).\n    try:\n        lambda_vec = np.linalg.solve(M, d_vec)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse if M is singular, though not expected\n        # for valid problems.\n        lambda_vec = np.linalg.pinv(M) @ d_vec\n\n    # Calculate the optimal portfolio weights w = Sigma_inv * C.T * lambda\n    w = Sigma_inv @ C_mat.T @ lambda_vec\n\n    # --- Calculate Diagnostics ---\n\n    # 1. Maximum absolute factor exposure deviation (eps_fac)\n    ej_vec = np.zeros(K)\n    ej_vec[target_idx] = 1.0\n    factor_exposures = B.T @ w\n    eps_fac = np.max(np.abs(factor_exposures - ej_vec))\n\n    # 2. Absolute net investment (eps_net)\n    net_investment = np.sum(w)\n    eps_net = np.abs(net_investment)\n\n    # 3. Achieved minimum variance (v)\n    variance = w.T @ Sigma @ w\n\n    return [eps_fac, eps_net, variance]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver, and print results.\n    \"\"\"\n    # Test case A (happy path)\n    B_A = np.array([\n        [0.5, 1.0], [1.2, -0.3], [-0.7, 0.8], [0.0, -0.5], [0.9, 0.2]\n    ])\n    Sigma_A = np.diag([0.04, 0.09, 0.025, 0.16, 0.0625])\n    N_A, K_A, j_A = 5, 2, 1\n\n    # Test case B (boundary: N = K+1)\n    B_B = np.array([[1.0, 0.0], [0.5, 1.0], [-0.5, 0.5]])\n    Sigma_B = np.diag([0.01, 0.02, 0.03])\n    N_B, K_B, j_B = 3, 2, 1\n\n    # Test case C (ill-conditioned covariance)\n    B_C = np.array([\n        [0.2, -0.1, 0.3], [1.1, 0.4, -0.2], [-0.3, 0.9, 0.5],\n        [0.0, -0.2, 0.1], [0.7, 0.0, -0.4], [-0.6, 0.3, 0.2],\n        [0.4, -0.5, 0.0], [0.8, 0.1, 0.6]\n    ])\n    N_C, K_C, j_C = 8, 3, 1\n    D_C = np.diag([0.04, 0.01, 0.09, 0.0025, 0.0225, 0.01, 0.04, 0.0025])\n    ones_mat_C = np.ones((N_C, N_C))\n    Sigma_C = D_C + 0.001 * ones_mat_C\n\n    test_cases = [\n        (B_A, Sigma_A, j_A, N_A, K_A),\n        (B_B, Sigma_B, j_B, N_B, K_B),\n        (B_C, Sigma_C, j_C, N_C, K_C),\n    ]\n\n    results = []\n    for case in test_cases:\n        B, Sigma, j, N, K = case\n        res = solve_single_case(B, Sigma, j, N, K)\n        results.append(res)\n\n    # Format the final output string as per requirements\n    formatted_results = []\n    for res_list in results:\n        # Format each number to 8 decimal places\n        formatted_list = [f\"{val:.8f}\" for val in res_list]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"}]}