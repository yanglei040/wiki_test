{"hands_on_practices": [{"introduction": "理论学习之后，最重要的就是动手实践。本练习将指导你从头开始，使用历史模拟法为一个包含多个相关联资产的投资组合计算风险价值（VaR）。通过这个实践 [@problem_id:2390037]，你将掌握如何利用 Cholesky 分解来生成符合特定协方差结构的多维资产收益数据，并应用经验分位数法来估算投资组合的 VaR，这是量化风险管理中的一项核心技能。", "id": "2390037", "problem": "给定一个由 $N=10$ 种资产组成的投资组合。设投资组合的权重向量为 $\\mathbf{w} \\in \\mathbb{R}^{10}$，过去 $T$ 天的历史回报率为矩阵 $\\mathbf{R} \\in \\mathbb{R}^{T \\times 10}$，其第 $t$ 行为 $\\mathbf{r}_t^\\top$。每日投资组合回报率为 $R^p_t = \\sum_{i=1}^{10} w_i r_{t,i}$，每日投资组合损失为 $L_t = - R^p_t$。对于一个损失随机变量 $L$，$99\\%$ 风险价值（Value at Risk, VaR）定义为满足 $\\mathbb{P}(L \\le v) \\ge 0.99$ 的最小数值 $v$。在历史模拟法下，使用样本 $\\{L_t\\}_{t=1}^T$ 的经验分布来替代 $L$ 的真实分布。使用经验分布函数，将经验 $p$-分位数定义为索引 $k = \\lceil p \\cdot T \\rceil$ 处的顺序统计量（使用基于1的索引），即，将 $\\{L_t\\}$ 按非降序排列得到 $L_{(1)} \\le \\cdots \\le L_{(T)}$，并设 $\\widehat{q}_p = L_{(k)}$，其中 $k = \\lceil p \\cdot T \\rceil$。那么，$99\\%$ VaR 的历史模拟估计值为 $\\widehat{\\mathrm{VaR}}_{0.99} = \\widehat{q}_{0.99}$。所有输出必须以小数形式报告（例如，报告 $0.025$ 而不是 $2.5\\%$）。\n\n为了确保生成一个能够捕捉跨资产相关性、科学上可靠且可复现的数据集，请按以下方式构建历史回报率。设各资产的每日波动率向量为 $\\boldsymbol{\\sigma} = (\\sigma_1,\\ldots,\\sigma_{10})$，其中对于 $i \\in \\{1,\\ldots,10\\}$，$\\sigma_i = 0.01 + 0.002 \\cdot (i-1)$。定义相关系数矩阵 $\\mathbf{C} \\in \\mathbb{R}^{10 \\times 10}$ 为 $C_{ij} = \\rho^{|i-j|}$，其中 $\\rho = 0.6$；并定义协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathbf{D} \\mathbf{C} \\mathbf{D}$，其中 $\\mathbf{D} = \\mathrm{diag}(\\boldsymbol{\\sigma})$。对于给定的 $T$，通过抽取一个具有独立同分布标准正态元素的矩阵 $\\mathbf{Z} \\in \\mathbb{R}^{T \\times 10}$，然后设置 $\\mathbf{R} = \\mathbf{Z} \\mathbf{L}^\\top$ 来生成历史样本，其中 $\\mathbf{L}$ 是 $\\boldsymbol{\\Sigma}$ 的下三角 Cholesky 分解因子，满足 $\\boldsymbol{\\Sigma} = \\mathbf{L} \\mathbf{L}^\\top$。每次生成数据集时，使用固定的伪随机种子 $12345$。此过程会生成具有指定协方差的相关资产回报率，作为历史模拟的历史样本。本任务不涉及角度。不适用任何物理单位；所有损失均报告为无单位的小数。\n\n实现一个程序，根据上述经验顺序统计量的定义，为以下每个测试案例计算 $\\widehat{\\mathrm{VaR}}_{0.99}$。在所有案例中，使用指定的生成方法和固定的种子 $12345$ 来为指定的 $T$ 生成 $\\mathbf{R}$ 矩阵。\n\n测试套件：\n- 案例 A（一般情况）：$T = 1000$，权重 $w_i = 1/10$ 对所有 $i \\in \\{1,\\ldots,10\\}$ 成立。\n- 案例 B（集中极端情况）：$T = 500$，权重 $w_1 = 1$ 且对于所有 $i \\in \\{2,\\ldots,10\\}$ 都有 $w_i = 0$。\n- 案例 C（风险平价风格情况）：$T = 252$，权重由 $w_i \\propto 1/\\sigma_i$ 给出，对所有 $i \\in \\{1,\\ldots,10\\}$ 成立，并进行归一化以使 $\\sum_{i=1}^{10} w_i = 1$。\n\n算法要求：\n- 使用如上定义的经验分位数，其中 $k = \\lceil 0.99 \\cdot T \\rceil$（无插值）。\n- 对于每个案例，根据生成的回报率和指定的权重计算损失序列 $\\{L_t\\}_{t=1}^T$，然后计算 $\\widehat{\\mathrm{VaR}}_{0.99}$。\n- 将每个最终的 $\\widehat{\\mathrm{VaR}}_{0.99}$ 四舍五入到 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含案例 A、B 和 C 的三个四舍五入后的结果，按顺序排列，以逗号分隔并用方括号括起来。例如，输出必须类似 $[x_A,x_B,x_C]$，其中每个 $x$ 都精确显示到 $6$ 位小数。", "solution": "该问题定义明确、科学上可靠且内部一致。我们将进行正式求解。\n\n目标是在三种不同情景下，为一个由 $N=10$ 种资产组成的投资组合计算 $99\\%$ 风险价值（$\\mathrm{VaR}_{0.99}$）。计算将使用历史模拟法，其中历史数据是根据一个指定的统计模型综合生成的。\n\n**1. 资产回报率的综合生成**\n\n模拟的核心是生成一个 $T \\times N$ 的历史回报率矩阵 $\\mathbf{R}$，其中 $T$ 是天数，$N=10$ 是资产数量。回报率被建模为从一个均值为零、协方差矩阵为 $\\boldsymbol{\\Sigma}$ 的多元正态分布中抽取的样本。这种协方差结构对于捕捉资产价格变动之间的相互依赖关系至关重要。\n\n首先，我们定义协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{10 \\times 10}$ 的组成部分。\n各资产的每日波动率向量为 $\\boldsymbol{\\sigma} = (\\sigma_1, \\sigma_2, \\dots, \\sigma_{10})^\\top$，其中第 $i$ 种资产的波动率由以下公式给出：\n$$\n\\sigma_i = 0.01 + 0.002 \\cdot (i-1) \\quad \\text{for } i \\in \\{1, 2, \\dots, 10\\}\n$$\n这产生了一系列波动率，从 $\\sigma_1 = 0.01$ 开始，增加到 $\\sigma_{10} = 0.028$。这些波动率构成了矩阵 $\\mathbf{D} = \\mathrm{diag}(\\boldsymbol{\\sigma})$ 的对角线。\n\n接下来，相关性结构由一个矩阵 $\\mathbf{C} \\in \\mathbb{R}^{10 \\times 10}$ 定义，其中资产 $i$ 和资产 $j$ 之间的相关性为：\n$$\nC_{ij} = \\rho^{|i-j|}\n$$\n参数 $\\rho$ 给定为 $0.6$。这种结构意味着指数上更接近的资产相关性更强。\n\n协方差矩阵 $\\boldsymbol{\\Sigma}$ 随之组合而成：\n$$\n\\boldsymbol{\\Sigma} = \\mathbf{D} \\mathbf{C} \\mathbf{D}\n$$\n为了生成相关的随机变量，我们使用 $\\boldsymbol{\\Sigma}$ 的 Cholesky 分解。我们找到一个下三角矩阵 $\\mathbf{L}$，使得 $\\boldsymbol{\\Sigma} = \\mathbf{L} \\mathbf{L}^\\top$。\n\n历史回报率矩阵 $\\mathbf{R}$ 的生成过程是：首先创建一个由独立同分布的标准正态随机变量（$\\mathcal{N}(0,1)$）组成的矩阵 $\\mathbf{Z} \\in \\mathbb{R}^{T \\times 10}$，然后通过以下变换得到相关的回报率：\n$$\n\\mathbf{R} = \\mathbf{Z} \\mathbf{L}^\\top\n$$\n$\\mathbf{R}$ 的每一行 $\\mathbf{r}_t^\\top$ 是一个随机向量，代表 $10$ 种资产的每日回报率，这些向量是从 $\\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$ 中抽取的。为保证可复现性，每次数据生成过程都使用固定的种子 $12345$ 来初始化伪随机数生成器。\n\n**2. 用于风险价值（$\\mathrm{VaR}$）计算的历史模拟法**\n\n给定一个投资组合权重向量 $\\mathbf{w} = (w_1, w_2, \\dots, w_{10})^\\top$，投资组合的每日回报率 $R^p_t$ 是各资产回报率的加权和：\n$$\nR^p_t = \\mathbf{r}_t^\\top \\mathbf{w} = \\sum_{i=1}^{10} w_i r_{t,i}\n$$\n相应的每日投资组合损失定义为回报率的负数：$L_t = -R^p_t$。该计算对从 $1$ 到 $T$ 的每一天 $t$ 都进行，从而得到一个历史损失样本 $\\{L_t\\}_{t=1}^T$。\n\n历史模拟法通过该损失样本的经验分布来估计 $\\mathrm{VaR}$。损失分布的 $p$-分位数是通过从排序后的损失数据中找到一个特定值来估计的。我们将损失按非降序排列：\n$$\nL_{(1)} \\le L_{(2)} \\le \\cdots \\le L_{(T)}\n$$\n问题指定经验 $p$-分位数 $\\widehat{q}_p$ 为第 $k$ 个顺序统计量 $L_{(k)}$，其中索引 $k$ 由以下公式给出：\n$$\nk = \\lceil p \\cdot T \\rceil\n$$\n这是一个基于 1 的索引。对于 $99\\%$ $\\mathrm{VaR}$，我们设置 $p=0.99$，因此历史估计值为：\n$$\n\\widehat{\\mathrm{VaR}}_{0.99} = L_{(k)} \\quad \\text{with} \\quad k = \\lceil 0.99 \\cdot T \\rceil\n$$\n\n**3. 应用于测试案例**\n\n我们现在将此方法应用于三个指定的测试案例。协方差矩阵 $\\boldsymbol{\\Sigma}$ 及其 Cholesky 分解因子 $\\mathbf{L}$ 对所有案例都是通用的，因为它们仅取决于 $N=10$ 和固定的参数 $\\boldsymbol{\\sigma}$ 和 $\\rho$。\n\n**案例 A：一般情况**\n-   时间周期：$T = 1000$。\n-   投资组合权重：一个等权重投资组合，$w_i = 1/10 = 0.1$ 对所有 $i$ 成立。\n-   $\\mathrm{VaR}$ 索引：$k = \\lceil 0.99 \\cdot 1000 \\rceil = \\lceil 990 \\rceil = 990$。\n-   步骤：\n    1.  使用种子 $12345$ 生成 $\\mathbf{R} \\in \\mathbb{R}^{1000 \\times 10}$。\n    2.  使用 $\\mathbf{w} = (0.1, \\dots, 0.1)^\\top$ 计算损失序列 $\\{L_t\\}_{t=1}^{1000}$。\n    3.  对损失进行排序，并选择第 $990$ 个值 $L_{(990)}$。\n\n**案例 B：集中极端情况**\n-   时间周期：$T = 500$。\n-   投资组合权重：一个完全集中于第一种资产的投资组合，$\\mathbf{w} = (1, 0, \\dots, 0)^\\top$。\n-   $\\mathrm{VaR}$ 索引：$k = \\lceil 0.99 \\cdot 500 \\rceil = \\lceil 495 \\rceil = 495$。\n-   步骤：\n    1.  使用种子 $12345$ 生成 $\\mathbf{R} \\in \\mathbb{R}^{500 \\times 10}$。\n    2.  计算损失序列 $\\{L_t\\}_{t=1}^{500}$。此处，$L_t = -r_{t,1}$。\n    3.  对损失进行排序，并选择第 $495$ 个值 $L_{(495)}$。\n\n**案例 C：风险平价风格情况**\n-   时间周期：$T = 252$（约等于一个交易年）。\n-   投资组合权重：权重与资产波动率成反比，$w_i \\propto 1/\\sigma_i$。这是一种受“风险平价”启发的配置方式，其中波动性较低的资产获得更高的权重。权重必须归一化以使其总和为 $1$：\n    $$\n    w_i = \\frac{1/\\sigma_i}{\\sum_{j=1}^{10} (1/\\sigma_j)}\n    $$\n-   $\\mathrm{VaR}$ 索引：$k = \\lceil 0.99 \\cdot 252 \\rceil = \\lceil 249.48 \\rceil = 250$。\n-   步骤：\n    1.  计算归一化后的权重 $\\mathbf{w}$。\n    2.  使用种子 $12345$ 生成 $\\mathbf{R} \\in \\mathbb{R}^{252 \\times 10}$。\n    3.  使用计算出的 $\\mathbf{w}$ 计算损失序列 $\\{L_t\\}_{t=1}^{252}$。\n    4.  对损失进行排序，并选择第 $250$ 个值 $L_{(250)}$。\n\n对于每个案例，计算出的 $\\widehat{\\mathrm{VaR}}_{0.99}$ 将按要求四舍五入到 $6$ 位小数。实现将使用基于 0 的数组索引，因此在基于 1 的系统中的索引 $k$ 处的值对应于代码中索引为 $k-1$ 的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef generate_returns(T, N, sigma_vec, corr_matrix, seed):\n    \"\"\"\n    Generates a matrix of correlated asset returns.\n\n    Args:\n        T (int): Number of time periods (days).\n        N (int): Number of assets.\n        sigma_vec (np.ndarray): Vector of asset volatilities.\n        corr_matrix (np.ndarray): Asset correlation matrix.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        np.ndarray: A T x N matrix of simulated daily returns.\n    \"\"\"\n    # Construct the covariance matrix: Sigma = D * C * D\n    D = np.diag(sigma_vec)\n    cov_matrix = D @ corr_matrix @ D\n\n    # Perform Cholesky decomposition: Sigma = L * L^T\n    # numpy.linalg.cholesky returns the lower-triangular matrix L.\n    L = np.linalg.cholesky(cov_matrix)\n\n    # Generate independent standard normal random variables\n    rng = np.random.default_rng(seed)\n    Z = rng.standard_normal((T, N))\n\n    # Generate correlated returns: R = Z * L^T\n    R = Z @ L.T\n    return R\n\ndef calculate_var(T, weights, returns):\n    \"\"\"\n    Calculates the 99% Value at Risk using historical simulation.\n\n    Args:\n        T (int): Number of time periods.\n        weights (np.ndarray): Portfolio weights vector.\n        returns (np.ndarray): Matrix of historical returns.\n\n    Returns:\n        float: The 99% VaR, rounded to 6 decimal places.\n    \"\"\"\n    # Calculate daily portfolio returns: Rp_t = R_t^T * w\n    portfolio_returns = returns @ weights\n    \n    # Calculate daily portfolio losses: L_t = -Rp_t\n    losses = -portfolio_returns\n    \n    # Sort losses in non-decreasing order\n    sorted_losses = np.sort(losses)\n    \n    # Calculate the index k for the 99% empirical quantile\n    # k = ceil(p * T), with 1-based indexing\n    p = 0.99\n    k = math.ceil(p * T)\n    \n    # Get the VaR value. Index is k-1 due to 0-based indexing in Python.\n    var_99 = sorted_losses[k - 1]\n    \n    return round(var_99, 6)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the three test cases.\n    \"\"\"\n    N = 10\n    rho = 0.6\n    \n    # Define asset volatilities\n    sigma_vec = np.array([0.01 + 0.002 * (i - 1) for i in range(1, N + 1)])\n    \n    # Define correlation matrix\n    indices = np.arange(N)\n    corr_matrix = rho ** np.abs(indices - indices[:, np.newaxis])\n    \n    # Fixed seed for all data generation\n    seed = 12345\n    \n    # Define test cases\n    test_cases = [\n        {'name': 'A', 'T': 1000, 'weights_def': 'equal'},\n        {'name': 'B', 'T': 500, 'weights_def': 'concentrated'},\n        {'name': 'C', 'T': 252, 'weights_def': 'risk-parity'}\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        T = case['T']\n        \n        # Generate returns for the specific T\n        returns = generate_returns(T, N, sigma_vec, corr_matrix, seed)\n        \n        # Define weights for the case\n        weights = np.zeros(N)\n        if case['weights_def'] == 'equal':\n            weights = np.full(N, 1.0 / N)\n        elif case['weights_def'] == 'concentrated':\n            weights[0] = 1.0\n        elif case['weights_def'] == 'risk-parity':\n            inv_sigma = 1.0 / sigma_vec\n            weights = inv_sigma / np.sum(inv_sigma)\n        \n        # Calculate VaR for the case\n        var_result = calculate_var(T, weights, returns)\n        results.append(var_result)\n\n    # Format the final output string as [x_A,x_B,x_C]\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n\n```"}, {"introduction": "一个理想的风险度量应该鼓励分散化，即投资组合的总风险不应超过其各组成部分风险之和（$\\rho(A+B) \\le \\rho(A) + \\rho(B)$）。这个性质被称为次可加性（subadditivity），但风险价值（VaR）在某些情况下会违反此原则。这个练习 [@problem_id:2412240] 设计了一个思想实验，通过构建特定的损失分布，让你用代码亲自验证 VaR 的这一理论缺陷，从而深刻理解为什么 VaR 可能在特定场景下误导风险管理决策。", "id": "2412240", "problem": "构建一个独立的程序，从第一性原理出发，计算在明确定义的案例中风险价值（Value-at-Risk, VaR）是否具有次可加性。设损失为一个实值随机变量。对于一个累积分布函数为 $F_X(x)$ 的损失随机变量 $X$ 和一个水平 $\\\\alpha \\\\in (0,1)$，将水平为 $\\\\alpha$ 的风险价值定义为\n$$\n\\\\operatorname{VaR}_{\\\\alpha}(X) = \\\\inf\\\\{x \\\\in \\\\mathbb{R} : F_X(x) \\\\ge \\\\alpha\\\\}.\n$$\n给定来自 $X$ 的一个独立同分布样本 $L_1,\\\\dots,L_n$，定义经验分布函数 $F_n(x) = \\\\frac{1}{n} \\\\sum_{i=1}^n \\\\mathbf{1}\\\\{L_i \\\\le x\\\\}$ 和经验风险价值估计量\n$$\n\\\\widehat{\\\\operatorname{VaR}}_{\\\\alpha}(X) = \\\\inf\\\\{x \\\\in \\\\mathbb{R} : F_n(x) \\\\ge \\\\alpha\\\\}.\n$$\n对下述每个测试案例，考虑两个损失随机变量 $A$ 和 $B$，并定义投资组合损失 $P = A + B$。对每个测试案例 $j$，计算布尔结果\n$$\nI_j = \\\\big[\\\\widehat{\\\\operatorname{VaR}}_{\\\\alpha}(P) > \\\\widehat{\\\\operatorname{VaR}}_{\\\\alpha}(A) + \\\\widehat{\\\\operatorname{VaR}}_{\\\\alpha}(B)\\\\big].\n$$\n所有案例均使用相同的样本量 $n$ 和固定的伪随机种子 $s$。所有概率都应解释为 $[0,1]$ 内的小数。不涉及物理单位。\n\n您的程序必须实现以下测试套件。在所有案例中，抽样数量为 $n = \\\\;400{,}000$，伪随机种子为 $s = \\\\;20231407$。所有伯努利事件和标准正态变量都必须根据指定的依赖结构进行抽样。\n\n- 测试案例1（独立，罕见大额损失）：$\\\\alpha = \\\\;0.95$。资产A有 $0.03$ 的概率发生 $10$ 的损失，否则损失为 $0$。资产B具有相同的分布。$A$ 和 $B$ 是独立的。\n- 测试案例2（独立，不对称罕见损失）：$\\\\alpha = \\\\;0.975$。资产A有 $0.02$ 的概率发生 $8$ 的损失，否则损失为 $0$。资产B有 $0.02$ 的概率发生 $12$ 的损失，否则损失为 $0$。$A$ 和 $B$ 是独立的。\n- 测试案例3（同单调罕见损失）：$\\\\alpha = \\\\;0.95$。资产A有 $0.03$ 的概率发生 $10$ 的损失，否则损失为 $0$。资产B具有相同的边缘分布。依赖关系是同单调的：存在一个在 $[0,1]$ 上的均匀分布变量 $U$，当且仅当 $U < 0.03$ 时，$A$ 和 $B$ 均等于其损失水平，否则二者均为 $0$。\n- 测试案例4（相关高斯损失）：$\\\\alpha = \\\\;0.99$。资产A服从均值为 $0$、标准差为 $1$ 的高斯分布。资产B服从均值为 $0$、标准差为 $1.2$ 的高斯分布。$A$ 和 $B$ 之间的相关系数为 $0.6$。\n- 测试案例5（完全负相关高斯损失）：$\\\\alpha = \\\\;0.99$。资产A服从均值为 $0$、标准差为 $1$ 的高斯分布。资产B几乎必然地等于 $-A$（完全负相关），因此投资组合损失恒为 $0$。\n\n对每个案例，生成完全符合所述分布和依赖关系的 $n$ 对抽样 $(A_i,B_i)$。使用上述 $\\\\widehat{\\\\operatorname{VaR}}_{\\\\alpha}$ 的定义，计算 $A$、$B$ 和 $P = A+B$ 在指定水平 $\\\\alpha$ 下的经验风险价值。然后按定义计算 $I_j$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[true,false,true,true,false]\"），但使用大写的 Python 布尔字面量。即，确切的输出格式必须是 \"[result1,result2,result3,result4,result5]\"，其中每个结果为 \"True\" 或 \"False\"。", "solution": "该问题要求对风险价值（$\\operatorname{VaR}$）度量的次可加性进行计算研究。如果对于任意两个损失随机变量 $X$ 和 $Y$，不等式 $\\rho(X+Y) \\le \\rho(X) + \\rho(Y)$ 均成立，则风险度量 $\\rho$ 被定义为次可加的。该性质将分散化原则形式化：合并后投资组合的风险不应大于其各组成部分风险之和。风险价值是一种广泛使用的风险度量，但它并不是 Artzner 等人 (1999) 意义上的一致性风险度量，这恰恰因为它可能不满足次可加性。本练习通过具体的、构造出的例子来证明这一点。\n\n任务是为五个不同的测试案例计算不等式 $\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)$ 的布尔结果，其中 $A$ 和 $B$ 是损失随机变量，$P=A+B$ 是投资组合损失，而 $\\widehat{\\operatorname{VaR}}_{\\alpha}$ 是在置信水平 $\\alpha$ 下的经验风险价值估计量。\n\n经验 $\\operatorname{VaR}$ 定义为 $\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_n(x) \\ge \\alpha\\}$，其中 $F_n(x)$ 是来自大小为 $n$ 的样本的经验累积分布函数。对于一个损失样本 $L_1, \\dots, L_n$，设排序后的样本为 $L_{(1)} \\le L_{(2)} \\le \\dots \\le L_{(n)}$。经验CDF $F_n(x)$ 是一个阶跃函数，在每个数据点处跳跃 $1/n$。条件 $F_n(x) \\ge \\alpha$ 等价于说至少有 $n\\alpha$ 个样本点小于或等于 $x$。这意味着 $x$ 必须至少与第 $\\lceil n\\alpha \\rceil$ 个顺序统计量一样大。因此，经验VaR恰好是该顺序统计量的值：\n$$\n\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = L_{(\\lceil n\\alpha \\rceil)}\n$$\n我们对每个测试案例的一般流程如下：\n1.  使用固定种子 $s = 20231407$ 初始化一个伪随机数生成器。\n2.  根据指定的边缘分布和依赖结构，生成一个大小为 $n = 400,000$ 的成对抽样样本 $(A_i, B_i)$，其中 $i=1, \\dots, n$。\n3.  创建投资组合损失样本 $P_i = A_i + B_i$。\n4.  对于三个样本 $\\{A_i\\}$、$\\{B_i\\}$ 和 $\\{P_i\\}$ 中的每一个，计算指定水平 $\\alpha$ 下的经验 $\\operatorname{VaR}$。这包括对样本进行排序，并在索引 $k-1$ 处（使用从0开始的索引）选择元素，其中 $k = \\lceil n\\alpha \\rceil$。\n5.  评估布尔表达式 $I_j = [\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)]$。\n\n每个案例的具体生成方法如下：\n\n测试案例1（独立，罕见大额损失）：$\\\\alpha = 0.95$。$A$ 和 $B$ 的损失是从伯努利分布中抽取的，表示有 $p=0.03$ 的概率发生 $10$ 的损失，否则为 $0$。通过使用两个独立的均匀随机数流 $U_A$ 和 $U_B$ 来为 $A$ 和 $B$ 生成样本，从而对独立性进行建模。对于每个 $i \\in \\{1, \\dots, n\\}$，$A_i=10$ 如果 $U_{A,i} < 0.03$，否则 $A_i=0$；对 $B_i$ 使用 $U_{B,i}$ 也类似。VaR计算的索引为 $k = \\lceil 400,000 \\times 0.95 \\rceil = 380,000$。\n\n测试案例2（独立，不对称罕见损失）：$\\\\alpha = 0.975$。此案例在结构上与第一个相似，但参数不对称。资产A有 $0.02$ 的概率发生 $8$ 的损失，资产B有 $0.02$ 的概率发生 $12$ 的损失。独立性再次通过独立的随机数流来建模。VaR索引为 $k = \\lceil 400,000 \\times 0.975 \\rceil = 390,000$。\n\n测试案例3（同单调罕见损失）：$\\\\alpha = 0.95$。$A$ 和 $B$ 的边缘分布与案例1相同。然而，其依赖关系是同单调的。这通过使用单一的均匀随机数流 $U$ 来建模。对于每个 $i \\in \\{1, \\dots, n\\}$，如果 $U_i < 0.03$，则 $A_i$ 和 $B_i$ 都设为 $10$，否则都为 $0$。这代表了尾部事件中的完全正相关性。VaR索引为 $k = \\lceil 400,000 \\times 0.95 \\rceil = 380,000$。\n\n测试案例4（相关高斯损失）：$\\\\alpha = 0.99$。$A \\sim \\mathcal{N}(0, 1^2)$ และ $B \\sim \\mathcal{N}(0, 1.2^2)$，相关系数 $\\rho(A, B) = 0.6$。我们从此二元正态分布中生成成对样本。这可以通过首先生成独立标准正态变量对 $(Z_{1,i}, Z_{2,i})$，然后应用对应于协方差矩阵 $\\Sigma$ 的 Cholesky 分解的线性变换来实现：\n$$\n\\Sigma = \\begin{pmatrix} \\sigma_A^2 & \\rho \\sigma_A \\sigma_B \\\\ \\rho \\sigma_A \\sigma_B & \\sigma_B^2 \\end{pmatrix} = \\begin{pmatrix} 1 & 0.72 \\\\ 0.72 & 1.44 \\end{pmatrix}\n$$\n一个更简单、等价的构造是 $A_i = Z_{1,i}$ 和 $B_i = \\sigma_B (\\rho Z_{1,i} + \\sqrt{1-\\rho^2} Z_{2,i})$。VaR索引为 $k = \\lceil 400,000 \\times 0.99 \\rceil = 396,000$。对于像多元正态分布这样的椭圆分布，已知VaR是次可加的。\n\n测试案例5（完全负相关高斯损失）：$\\\\alpha = 0.99$。资产 $A \\sim \\mathcal{N}(0, 1^2)$ 且 $B = -A$。这是一个完全对冲的案例。我们为 $A$ 生成一个标准正态变量样本，并将 $B$ 的样本设置为其按元素取反。投资组合损失对所有结果均为 $P = A+B = 0$。因此，其经验 $\\widehat{\\operatorname{VaR}}_{\\alpha}(P)$ 必须为 $0$。VaR索引为 $k = \\lceil 400,000 \\times 0.99 \\rceil = 396,000$。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes whether Value-at-Risk (VaR) is subadditive in five specific cases.\n    \"\"\"\n    \n    # Global parameters\n    N_SAMPLES = 400_000\n    SEED = 20231407\n    \n    # Initialize a single random number generator for all simulations\n    rng = np.random.default_rng(SEED)\n\n    test_cases = [\n        # Case 1: Independent, rare large losses\n        {\n            \"alpha\": 0.95,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"dep\": \"independent\"\n        },\n        # Case 2: Independent, asymmetric rare losses\n        {\n            \"alpha\": 0.975,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 8.0, \"p\": 0.02},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 12.0, \"p\": 0.02},\n            \"dep\": \"independent\"\n        },\n        # Case 3: Comonotonic rare losses\n        {\n            \"alpha\": 0.95,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"dep\": \"comonotonic\"\n        },\n        # Case 4: Correlated Gaussian losses\n        {\n            \"alpha\": 0.99,\n            \"A\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"B\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.2},\n            \"dep\": \"correlated\", \"rho\": 0.6\n        },\n        # Case 5: Perfectly negatively dependent Gaussian losses\n        {\n            \"alpha\": 0.99,\n            \"A\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"B\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"dep\": \"negatively_dependent\"\n        }\n    ]\n\n    results = []\n\n    def get_empirical_var(samples, alpha):\n        \"\"\"\n        Calculates the empirical Value-at-Risk.\n        Defined as the k-th order statistic, where k = ceil(n*alpha).\n        \"\"\"\n        n = len(samples)\n        k = math.ceil(n * alpha)\n        # Using k-1 for 0-based indexing\n        sorted_samples = np.sort(samples)\n        return sorted_samples[k - 1]\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        \n        # --- Generate samples for A and B based on the case ---\n        if case[\"dep\"] == \"independent\":\n            u_a = rng.random(size=N_SAMPLES)\n            u_b = rng.random(size=N_SAMPLES)\n            params_a = case[\"A\"]\n            samples_a = np.where(u_a < params_a[\"p\"], params_a[\"loss\"], 0.0)\n            params_b = case[\"B\"]\n            samples_b = np.where(u_b < params_b[\"p\"], params_b[\"loss\"], 0.0)\n\n        elif case[\"dep\"] == \"comonotonic\":\n            u = rng.random(size=N_SAMPLES)\n            params_a = case[\"A\"]\n            samples_a = np.where(u < params_a[\"p\"], params_a[\"loss\"], 0.0)\n            params_b = case[\"B\"]\n            samples_b = np.where(u < params_b[\"p\"], params_b[\"loss\"], 0.0)\n\n        elif case[\"dep\"] == \"correlated\":\n            params_a = case[\"A\"]\n            params_b = case[\"B\"]\n            rho = case[\"rho\"]\n            \n            mean = [params_a[\"mean\"], params_b[\"mean\"]]\n            cov = [[params_a[\"std\"]**2, rho * params_a[\"std\"] * params_b[\"std\"]],\n                   [rho * params_a[\"std\"] * params_b[\"std\"], params_b[\"std\"]**2]]\n            \n            samples = rng.multivariate_normal(mean, cov, size=N_SAMPLES)\n            samples_a = samples[:, 0]\n            samples_b = samples[:, 1]\n            \n        elif case[\"dep\"] == \"negatively_dependent\":\n            params_a = case[\"A\"]\n            samples_a = rng.normal(loc=params_a[\"mean\"], scale=params_a[\"std\"], size=N_SAMPLES)\n            samples_b = -samples_a\n        \n        # --- Create portfolio samples ---\n        samples_p = samples_a + samples_b\n        \n        # --- Calculate VaR for A, B, and Portfolio P ---\n        var_a = get_empirical_var(samples_a, alpha)\n        var_b = get_empirical_var(samples_b, alpha)\n        var_p = get_empirical_var(samples_p, alpha)\n        \n        # --- Check for subadditivity violation ---\n        is_violated = var_p > (var_a + var_b)\n        results.append(is_violated)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "风险价值（VaR）告诉我们“在一定置信水平下我们最多会损失多少”，但它没有回答“如果发生极端事件，平均损失会有多大？” 这个问题。为了弥补 VaR 的不足，期望损失（Expected Shortfall, ES）应运而生。在本练习 [@problem_id:2390682] 中，你将通过模拟具有不同“肥尾”特征（通过学生 $t$ 分布的自由度 $\\nu$ 控制）的资产收益来同时估算 VaR 和 ES，直观地比较这两种风险度量在捕捉尾部风险时的表现差异。", "id": "2390682", "problem": "构建一个完整、可运行的程序，该程序针对一个由 $M$ 种资产组成的固定等权重投资组合，在每种资产的回报都服从具有不同自由度的学生t分布的情况下，估计并比较置信水平为 $0.95$ 时的风险价值 (VaR) 和期望亏损 (ES)。所有回报均解释为无量纲的十进制回报。\n\n设 $R_{i}$ 表示在单一情景中资产 $i$ 的回报，其中 $i \\in \\{1,\\dots,M\\}$。对于给定的自由度参数 $\\nu$，假设 $R_{i} = s(\\nu)\\,T_{i}$，其中 $T_{i}$ 服从自由度为 $\\nu$、单位尺度的学生t分布，而 $s(\\nu)$ 是缩放因子\n$$\ns(\\nu) \\equiv \\sqrt{\\frac{\\nu - 2}{\\nu}},\n$$\n这确保了当 $\\nu > 2$ 时 $\\operatorname{Var}(R_{i}) = 1$。定义一个情景中的等权重投资组合回报为\n$$\nR_{p} \\equiv \\frac{1}{M}\\sum_{i=1}^{M} R_{i},\n$$\n以及相应的投资组合亏损为\n$$\nL \\equiv -R_{p}.\n$$\n\n定义置信水平为 $\\alpha \\in (0,1)$ 时的风险价值 (VaR) 为\n$$\n\\operatorname{VaR}_{\\alpha}(L) \\equiv \\inf\\{x \\in \\mathbb{R} : \\mathbb{P}(L \\le x) \\ge \\alpha \\},\n$$\n以及期望亏损 (ES)，也称为条件风险价值，为\n$$\n\\operatorname{ES}_{\\alpha}(L) \\equiv \\mathbb{E}\\!\\left[\\,L \\,\\middle|\\, L \\ge \\operatorname{VaR}_{\\alpha}(L)\\right].\n$$\n\n您的程序必须：\n- 针对每个指定的 $\\nu$，使用上述构造方法生成 $N$ 个独立的向量 $(R_{1},\\dots,R_{M})$ 情景，其中 $T_{i}$ 在资产 $i$ 之间以及情景之间均独立，并在每个情景中计算相关的投资组合亏损 $L$。\n- 使用模拟得到的 $L$ 的经验分布来计算 $\\operatorname{VaR}_{\\alpha}(L)$ 和 $\\operatorname{ES}_{\\alpha}(L)$ 的经验估计量，其中经验 $\\operatorname{VaR}_{\\alpha}(L)$ 是对应于索引 $k \\equiv \\lceil \\alpha N \\rceil$ 的顺序统计量，而经验 $\\operatorname{ES}_{\\alpha}(L)$ 是所有大于或等于该经验 $\\operatorname{VaR}_{\\alpha}(L)$ 的模拟亏损的样本均值。\n\n测试套件和使用的参数：\n- 资产数量：$M = 10$。\n- 置信水平：$\\alpha = 0.95$。\n- 每个测试的情景数量：$N = 100000$。\n- 随机数生成器种子必须固定为 $123456$。\n- 待测试的自由度（每个都是一个独立的测试用例）：$\\nu \\in \\{2.2,\\,3.0,\\,5.0,\\,30.0,\\,100.0\\}$。\n\n您的程序应生成单行输出，其中包含所有测试用例汇总结果的Python列表字面量。对于每个测试用例，返回一个包含两个浮点数 $[\\widehat{\\operatorname{VaR}}_{0.95},\\widehat{\\operatorname{ES}}_{0.95}]$ 的列表，数值以十进制形式表示（非百分比）。按照上面给出的 $\\nu$ 值列表的顺序汇总这 $5$ 个测试用例。因此，最终输出格式必须是形如\n[[v_1,e_1],[v_2,e_2],[v_3,e_3],[v_4,e_4],[v_5,e_5]]\n的单行，其中每个 $v_j$ 和 $e_j$ 是对应 $\\nu$ 的 $\\operatorname{VaR}_{0.95}$ 和 $\\operatorname{ES}_{0.95}$ 的经验估计值，表示为浮点数。", "solution": "该任务是构建一个程序，用于估计一个等权重投资组合的风险价值 ($\\operatorname{VaR}$) 和期望亏损 ($\\operatorname{ES}$)。构成投资组合的资产回报被建模为独立同分布的随机变量，服从经过缩放的学生t分布。该估计需要针对自由度参数 $\\nu$ 的几个不同值进行。\n\n在开始解决问题之前，必须对问题陈述进行严格的验证。\n\n**问题验证**\n\n**第一步：提取已知条件**\n- 投资组合构成：等权重，包含 $M = 10$ 种资产。\n- 资产回报：$R_i$ 对于 $i \\in \\{1,\\dots,M\\}$ 是独立同分布 (i.i.d.) 的。\n- 回报分布模型：$R_i = s(\\nu) T_i$，其中 $T_i$ 是一个服从自由度为 $\\nu$、单位尺度的学生t分布的随机变量。\n- 缩放因子：$s(\\nu) = \\sqrt{\\frac{\\nu - 2}{\\nu}}$，定义于 $\\nu > 2$。这确保了 $\\operatorname{Var}(R_i) = 1$。\n- 投资组合回报：$R_p = \\frac{1}{M}\\sum_{i=1}^{M} R_i$。\n- 投资组合亏损：$L = -R_p$。\n- 风险价值定义：$\\operatorname{VaR}_{\\alpha}(L) = \\inf\\{x \\in \\mathbb{R} : \\mathbb{P}(L \\le x) \\ge \\alpha \\}$。\n- 期望亏损定义：$\\operatorname{ES}_{\\alpha}(L) = \\mathbb{E}[L \\mid L \\ge \\operatorname{VaR}_{\\alpha}(L)]$。\n- 模拟参数：情景数量 $N = 100000$；置信水平 $\\alpha = 0.95$；随机数生成器种子固定为 $123456$。\n- 测试用例：自由度 $\\nu \\in \\{2.2, 3.0, 5.0, 30.0, 100.0\\}$。\n- 经验估计量：\n    - $\\widehat{\\operatorname{VaR}}_{\\alpha}(L)$ 是对应于索引 $k = \\lceil \\alpha N \\rceil$ 的顺序统计量。\n    - $\\widehat{\\operatorname{ES}}_{\\alpha}(L)$ 是所有大于或等于经验 $\\operatorname{VaR}$ 的模拟亏损的样本均值。\n- 输出格式：代表Python列表的列表的单行：`[[v_1,e_1],[v_2,e_2],...,[v_5,e_5]]`。\n\n**第二步：使用提取的已知条件进行验证**\n1.  **科学和事实的合理性**：该问题在科学上是合理的。使用学生t分布来模拟重尾金融回报是量化金融中的一种标准技术。$\\operatorname{VaR}$ 和 $\\operatorname{ES}$ 的定义是教科书中的定义。缩放因子 $s(\\nu)$ 的公式是正确的，确保了当 $\\nu > 2$ 时资产回报的单位方差，因为 $\\operatorname{Var}(T_i) = \\frac{\\nu}{\\nu-2}$。从 $2.2$ 开始的 $\\nu$ 的测试用例都满足这个条件。\n2.  **良定性**：该问题是良定的。它提供了所有必要的参数（$M, \\alpha, N$, 种子, $\\nu$ 的测试值），明确定义了模型，并指定了要使用的确切估计量。这确保了可以获得唯一的数值结果。\n3.  **客观性**：问题陈述使用精确、客观、形式化的数学语言表达，没有任何主观或模棱两可的陈述。\n4.  **完整性与一致性**：问题是自洽的且内部一致。所有必需的定义和数据都已提供。不存在矛盾。\n5.  **可行性**：指定的计算（$5$ 个测试用例，每个用例包含 $M=10$ 种资产的 $N=100000$ 个情景）对于现代硬件和标准科学库来说在计算上是可行的。\n\n**结论与行动**\n问题陈述是**有效的**，因为它基于科学、良定、客观、完整且计算上可行。我们现在将继续推导和实现解决方案。\n\n**解法推导**\n\n问题的核心是执行蒙特卡洛模拟，以估计投资组合亏损 $L$ 的风险度量。$L$ 的分布继承自资产回报 $R_i$ 的属性。\n\n**1. 投资组合亏损的属性**\n资产 $i$ 的回报 $R_i$ 的均值为 $\\mathbb{E}[R_i] = 0$（当 $\\nu > 1$ 时），方差为 $\\operatorname{Var}(R_i) = 1$（当 $\\nu > 2$ 时）。投资组合回报为 $R_p = \\frac{1}{M}\\sum_{i=1}^{M} R_i$。由于资产回报的独立同分布特性，投资组合回报的期望和方差为：\n$$\n\\mathbb{E}[R_p] = \\mathbb{E}\\left[\\frac{1}{M}\\sum_{i=1}^{M} R_i\\right] = \\frac{1}{M}\\sum_{i=1}^{M} \\mathbb{E}[R_i] = 0\n$$\n$$\n\\operatorname{Var}(R_p) = \\operatorname{Var}\\left(\\frac{1}{M}\\sum_{i=1}^{M} R_i\\right) = \\frac{1}{M^2}\\sum_{i=1}^{M} \\operatorname{Var}(R_i) = \\frac{M}{M^2} = \\frac{1}{M}\n$$\n投资组合亏损定义为 $L = -R_p$。因此，其统计属性为 $\\mathbb{E}[L] = 0$ 和 $\\operatorname{Var}(L) = \\frac{1}{M}$。对于本问题，$M=10$，所以 $\\operatorname{Var}(L) = 0.1$。$L$ 的分布是经过缩放的t分布变量之和，没有简单的封闭形式，这使得使用模拟成为必要。\n\n**2. 蒙特卡洛模拟算法**\n对于每个给定的 $\\nu$ 值，$\\nu \\in \\{2.2, 3.0, 5.0, 30.0, 100.0\\}$，执行以下过程：\n\na. **随机变量生成**：生成一个 $N \\times M$ 的矩阵 $\\mathbf{T}$，其中 $N = 100000$ 且 $M=10$。每个元素 $T_{ki}$（对于情景 $k$ 和资产 $i$）都是从自由度为 $\\nu$ 的标准学生t分布中独立抽取的。固定的种子 $123456$ 确保了可复现性。\n\nb. **回报计算**：计算缩放因子 $s(\\nu) = \\sqrt{(\\nu - 2)/\\nu}$。然后，通过逐元素相乘构建资产回报矩阵 $\\mathbf{R}$：$\\mathbf{R} = s(\\nu) \\mathbf{T}$。\n\nc. **投资组合亏损计算**：对于每个情景 $k=1, \\dots, N$，计算投资组合回报 $R_{p,k} = \\frac{1}{M}\\sum_{i=1}^{M} R_{ki}$。这可以通过计算 $\\mathbf{R}$ 矩阵每行的均值来实现。相应的投资组合亏损由向量 $\\mathbf{L}$ 给出，其中 $L_k = -R_{p,k}$。\n\n**3. VaR 和 ES 的经验估计**\n使用生成的包含 $N$ 个投资组合亏损样本的向量 $\\mathbf{L}$：\n\na. **VaR 估计**：将向量 $\\mathbf{L}$ 按非递减顺序排序，得到顺序统计量 $L_{(1)} \\le L_{(2)} \\le \\dots \\le L_{(N)}$。置信水平为 $\\alpha = 0.95$ 时的经验 $\\operatorname{VaR}$ 是第 $k$ 个顺序统计量，其中索引 $k$ 由下式给出：\n$$\nk = \\lceil \\alpha N \\rceil = \\lceil 0.95 \\times 100000 \\rceil = 95000\n$$\n在一个从零开始索引的数组中，这对应于索引为 $k-1 = 94999$ 的元素。因此，$\\widehat{\\operatorname{VaR}}_{0.95} = L_{(95000)}$。\n\nb. **ES 估计**：经验 $\\operatorname{ES}$ 定义为所有大于或等于估计的 $\\operatorname{VaR}$ 的模拟亏损的样本均值。\n$$\n\\widehat{\\operatorname{ES}}_{0.95} = \\frac{\\sum_{k=1}^{N} L_k \\cdot \\mathbf{1}_{\\{L_k \\ge \\widehat{\\operatorname{VaR}}_{0.95}\\}}}{\\sum_{k=1}^{N} \\mathbf{1}_{\\{L_k \\ge \\widehat{\\operatorname{VaR}}_{0.95}\\}}}\n$$\n其中 $\\mathbf{1}_{\\{\\cdot\\}}$ 是指示函数。这通过筛选原始亏损向量 $\\mathbf{L}$ 中所有满足条件的数值，然后计算它们的算术平均值来实现。\n\n当 $\\nu \\to \\infty$ 时，学生t分布收敛于标准正态分布。因此，对于大的 $\\nu$，我们期望结果会接近于高斯投资组合亏损 $L \\sim \\mathcal{N}(0, 1/M)$ 的理论值。当 $M=10$ 和 $\\alpha=0.95$ 时，这些理论值为 $\\operatorname{VaR}_{0.95} = \\frac{1}{\\sqrt{10}} \\Phi^{-1}(0.95) \\approx 0.5202$ 和 $\\operatorname{ES}_{0.95} = \\frac{1}{\\sqrt{10}} \\frac{\\phi(\\Phi^{-1}(0.95))}{1-0.95} \\approx 0.6521$，其中 $\\Phi$ 和 $\\phi$ 分别是标准正态的累积分布函数(CDF)和概率密度函数(PDF)。对于较小的 $\\nu$，t分布的更肥的尾部应导致 $\\operatorname{VaR}$ 和 $\\operatorname{ES}$ 的值都更高。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Estimates and compares Value at Risk (VaR) and Expected Shortfall (ES)\n    for an equally weighted portfolio with asset returns following a scaled\n    Student's t-distribution with varying degrees of freedom.\n    \"\"\"\n    \n    # Define the test cases and parameters from the problem statement.\n    M = 10  # Number of assets\n    alpha = 0.95  # Confidence level\n    N = 100000  # Number of scenarios\n    seed = 123456  # Random number generator seed\n    \n    test_cases = [\n        2.2,\n        3.0,\n        5.0,\n        30.0,\n        100.0,\n    ]\n\n    # Initialize a random number generator with the specified seed for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    results = []\n    \n    for nu in test_cases:\n        # Main logic to calculate the result for one case goes here.\n\n        # 1. Generate N x M matrix of random variates from Student's t-distribution.\n        # The random_state parameter is passed the generator instance to ensure it is used.\n        T_matrix = t.rvs(df=nu, size=(N, M), random_state=rng)\n\n        # 2. Calculate the scaling factor s(nu) to ensure Var(R_i) = 1.\n        # This is valid for nu > 2, which holds for all test cases.\n        s_nu = np.sqrt((nu - 2) / nu)\n        \n        # 3. Scale the random variates to get the asset returns matrix R.\n        R_matrix = s_nu * T_matrix\n\n        # 4. Compute the equally weighted portfolio return for each scenario.\n        # This is the mean of each row (axis=1).\n        R_p_vector = np.mean(R_matrix, axis=1)\n\n        # 5. Compute the portfolio loss L = -R_p.\n        L_vector = -R_p_vector\n\n        # 6. Estimate VaR at confidence level alpha.\n        # First, sort the losses in ascending order.\n        L_sorted = np.sort(L_vector)\n        \n        # The index for VaR is k = ceil(alpha*N).\n        # In 0-based Python indexing, this corresponds to index k-1.\n        k_index = int(np.ceil(alpha * N)) - 1\n        var_estimate = L_sorted[k_index]\n\n        # 7. Estimate ES at confidence level alpha.\n        # ES is the sample average of all losses greater than or equal to the empirical VaR.\n        # This is implemented by boolean indexing on the original loss vector.\n        es_estimate = np.mean(L_vector[L_vector >= var_estimate])\n        \n        # Append the [VaR, ES] pair for the current test case.\n        results.append([var_estimate, es_estimate])\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists, e.g., [[v1, e1], [v2, e2]].\n    # The str() function on a list provides the correct formatting for each inner list.\n    # The ','.join() method combines these strings with a comma separator.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}