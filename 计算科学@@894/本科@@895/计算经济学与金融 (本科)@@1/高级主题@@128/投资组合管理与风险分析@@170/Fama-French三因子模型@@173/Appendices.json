{"hands_on_practices": [{"introduction": "法马-佛伦奇三因子模型为何通常被视为对经典资本资产定价模型 (CAPM) 的改进？这个动手实践将引导您通过检验两种模型的残差来探索这一核心问题。我们将通过一个模拟场景，其中的资产收益由三因子模型驱动，您将运用统计检验来判断三因子模型的残差是否比设定存在偏差的 CAPM 残差更接近“白噪声”（即纯粹的随机干扰），从而直观地理解遗漏变量偏差 (omitted variable bias) 的影响。[@problem_id:2448010]", "id": "2448010", "problem": "考虑一个单一资产的超额收益序列，该序列由一个带有白噪声扰动的线性因子模型建模。设市场因子、规模因子和价值因子分别表示为 $M_t$、$\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$。对于每个时间指数 $t \\in \\{1,2,\\dots,T\\}$，资产的超额收益 $R_t^{e}$ 由下式生成：\n$$\nR_t^{e} \\;=\\; \\alpha \\;+\\; \\beta_M M_t \\;+\\; \\beta_S \\mathrm{SMB}_t \\;+\\; \\beta_H \\mathrm{HML}_t \\;+\\; \\varepsilon_t,\n$$\n其中扰动项 $\\{\\varepsilon_t\\}$ 是一个白噪声过程：$\\mathbb{E}[\\varepsilon_t]=0$，$\\operatorname{Var}(\\varepsilon_t)=\\sigma_{\\varepsilon}^2$，且对于 $t\\neq s$ 有 $\\operatorname{Cov}(\\varepsilon_t,\\varepsilon_s)=0$。\n\n因子 $(M_t,\\mathrm{SMB}_t,\\mathrm{HML}_t)$ 服从独立的、具有高斯新息和零初始条件的一阶自回归过程：\n$$\nM_t \\;=\\; \\phi_M M_{t-1} \\;+\\; \\eta_{M,t}, \\quad \\mathrm{SMB}_t \\;=\\; \\phi_S \\mathrm{SMB}_{t-1} \\;+\\; \\eta_{S,t}, \\quad \\mathrm{HML}_t \\;=\\; \\phi_H \\mathrm{HML}_{t-1} \\;+\\; \\eta_{H,t},\n$$\n$M_0=\\mathrm{SMB}_0=\\mathrm{HML}_0=0$，其中 $\\{\\eta_{M,t}\\}$、$\\{\\eta_{S,t}\\}$ 和 $\\{\\eta_{H,t}\\}$ 是相互独立的独立同分布高斯随机变量序列，各自的均值为 0，方差的选择使得每个因子过程的平稳方差为 1。即，对于 $f \\in \\{M,S,H\\}$，新息方差满足 $\\operatorname{Var}(\\eta_{f,t})=1-\\phi_f^2$。\n\n对于 $\\{(R_t^{e},M_t,\\mathrm{SMB}_t,\\mathrm{HML}_t)\\}_{t=1}^T$ 的一个给定实现，考虑两种带截距项的线性回归：\n(1) 资本资产定价模型 (CAPM)：$R_t^{e}$ 对 $\\{1,M_t\\}$ 的回归，以及\n(2) Fama-French 三因子模型：$R_t^{e}$ 对 $\\{1,M_t,\\mathrm{SMB}_t,\\mathrm{HML}_t\\}$ 的回归。\n两者都通过最小二乘法进行估计，即最小化残差平方和，从而产生残差序列 $\\{e^{\\mathrm{CAPM}}_t\\}_{t=1}^T$ 和 $\\{e^{\\mathrm{FF3}}_t\\}_{t=1}^T$。\n\n对于一个残差序列 $\\{e_t\\}_{t=1}^T$，其滞后 $k$ 阶的样本自相关定义为\n$$\n\\hat{r}_k \\;=\\; \\frac{\\sum_{t=k+1}^{T} (e_t - \\bar{e})(e_{t-k} - \\bar{e})}{\\sum_{t=1}^{T} (e_t - \\bar{e})^2}, \\quad \\text{其中 } \\bar{e}=\\frac{1}{T}\\sum_{t=1}^{T} e_t.\n$$\n最大滞后阶数为 $m$ 的 Ljung-Box q检验统计量定义为\n$$\nQ(m) \\;=\\; T(T+2)\\sum_{k=1}^{m} \\frac{\\hat{r}_k^2}{T-k}.\n$$\n在残差是白噪声的原假设下，$Q(m)$ 的参考分布取为自由度为 $m$ 的卡方分布。对于一个给定的残差序列，其白噪声检验的 p 值为 $p = 1 - F_{\\chi^2_m}(Q(m))$，其中 $F_{\\chi^2_m}$ 表示自由度为 $m$ 的卡方分布的累积分布函数。如果一组残差的 Ljung-Box p 值严格大于另一组，则定义该组残差比另一组更“白”。\n\n为了保证可复现性，使用一个固定的随机种子，根据上述设定生成因子过程和资产收益。然后，对于下述每个测试用例，估计两种回归模型，并计算在指定最大滞后阶数下的 Ljung-Box p 值。对于每个测试用例，如果 Fama-French 三因子模型的残差比 CAPM 模型的残差更“白”，则输出布尔值 true，否则输出 false。\n\n所有用例中使用的全局模拟参数：\n- 因子自回归系数：$\\phi_M=0.6$, $\\phi_S=0.5$, $\\phi_H=0.4$。\n- 初始条件：$M_0=\\mathrm{SMB}_0=\\mathrm{HML}_0=0$。\n\n测试套件（四个用例），每个用例由 $(T, \\beta_M, \\beta_S, \\beta_H, \\sigma_{\\varepsilon}, m)$ 指定：\n- 用例 1：$(T=\\;600,\\;\\beta_M=\\;0.9,\\;\\beta_S=\\;0.5,\\;\\beta_H=\\;-0.3,\\;\\sigma_{\\varepsilon}=\\;0.5,\\;m=\\;10)$。\n- 用例 2：$(T=\\;600,\\;\\beta_M=\\;1.1,\\;\\beta_S=\\;0.0,\\;\\beta_H=\\;0.0,\\;\\sigma_{\\varepsilon}=\\;0.5,\\;m=\\;10)$。\n- 用例 3：$(T=\\;120,\\;\\beta_M=\\;0.0,\\;\\beta_S=\\;0.8,\\;\\beta_H=\\;0.8,\\;\\sigma_{\\varepsilon}=\\;0.5,\\;m=\\;10)$。\n- 用例 4：$(T=\\;60,\\;\\beta_M=\\;0.0,\\;\\beta_S=\\;0.0,\\;\\beta_H=\\;0.0,\\;\\sigma_{\\varepsilon}=\\;1.0,\\;m=\\;10)$。\n\n随机性与复用规则：\n- 使用长度为 $T_{\\max}$ 的单一共同因子过程实现，其中 $T_{\\max}$ 是测试用例中最大的 $T$。对于每个用例，使用每个因子的前 $T$ 个观测值。使用固定且明确指定的随机种子，以使该实现是唯一确定的。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个按测试用例顺序排列的、用方括号括起来的、以逗号分隔的四个布尔值列表，例如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False}]$。\n- 不涉及物理单位。不涉及角度。如果需要任何分数，应表示为小数，但此处要求的输出仅为布尔值。", "solution": "所提出的问题是金融计量经济学中一个定义明确的模拟练习。它的科学基础是线性因子模型理论和模型诊断，特别是关于遗漏变量偏差及其通过回归残差的序列相关性检验进行检测的问题。该问题是完整、一致且客观陈述的，因此是一个有效的问题。我们将着手对其进行求解。\n\n此处所考察的基本原理是模型的正确设定。资产超额收益 $R_t^{e}$ 的数据生成过程 (DGP) 由 Fama-French 三因子模型和一个附加的白噪声扰动项 $\\{\\varepsilon_t\\}$ 给出：\n$$\nR_t^{e} \\;=\\; \\alpha \\;+\\; \\beta_M M_t \\;+\\; \\beta_S \\mathrm{SMB}_t \\;+\\; \\beta_H \\mathrm{HML}_t \\;+\\; \\varepsilon_t\n$$\n因子本身，即 $\\{M_t\\}$、$\\{\\mathrm{SMB}_t\\}$ 和 $\\{\\mathrm{HML}_t\\}$，并非白噪声，而是表现出时间依赖性，因为它们被建模为一阶自回归 (AR($1$)) 过程。\n\n当我们通过将 $R_t^e$ 仅对一个常数项和市场因子 $M_t$ 进行回归来估计资本资产定价模型 (CAPM) 时，如果真实系数 $\\beta_S$ 或 $\\beta_H$ 不为零，我们就会引入设定误差。遗漏因子 $\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 的影响被 CAPM 模型的残差项所吸收。设估计的 CAPM 模型为 $\\hat{R}_t^e = \\hat{a}_{\\mathrm{CAPM}} + \\hat{b}_M M_t$。其残差 $e_t^{\\mathrm{CAPM}} = R_t^e - \\hat{R}_t^e$ 将近似于：\n$$\ne_t^{\\mathrm{CAPM}} \\approx (\\alpha - \\hat{a}_{\\mathrm{CAPM}}) + (\\beta_M - \\hat{b}_M) M_t + \\beta_S \\mathrm{SMB}_t + \\beta_H \\mathrm{HML}_t + \\varepsilon_t\n$$\n由于 $\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 是序列相关的，这种自相关结构会传递到 CAPM 的残差中，导致它们偏离白噪声。\n\n相反，估计 Fama-French 三因子模型与 DGP 是一致的。这个正确设定模型的残差 $e_t^{\\mathrm{FF3}}$ 将是真实新息 $\\varepsilon_t$ 的一致估计量，而新息被规定为白噪声。\n\nLjung-Box 检验是用于检验自相关性的一个正式统计检验。其检验统计量 $Q(m)$ 汇集了前 $m$ 个样本自相关系数的平方。在序列是白噪声的原假设下，$Q(m)$ 近似服从自由度为 $m$ 的卡方随机变量分布。一个较低的 p 值表示拒绝原假设，表明存在显著的序列相关性。\n\n因此，当 $\\beta_S$ 或 $\\beta_H$ 非零时，我们预期对设定错误的 CAPM 残差应用 Ljung-Box 检验将得到一个较低的 p 值（检测到自相关性）。而对 FF3 残差的检验应得到一个较高的 p 值（未能检测到自相关性）。问题将 p 值严格更大的残差定义为更“白”的残差，因此我们预计在 CAPM 模型设定错误的情况下，FF3 残差将比 CAPM 残差更“白”。\n\n在 CAPM 是真实模型的情况下（即 $\\beta_S = \\beta_H = 0$），两个残差序列都应近似为白噪声，p 值的任何差异都源于有限样本的估计方差。\n\n解决该问题的算法如下：\n1. **设置**：为了保证可复现性，使用一个固定的随机种子（$42$）。定义全局参数（$\\phi_M=0.6$, $\\phi_S=0.5$, $\\phi_H=0.4$）。DGP 中的截距项 $\\alpha$ 不失一般性地设为 $0$，因为带截距项的普通最小二乘法对此类平移是不变的。\n\n2. **因子生成**：将因子过程 ($M_t, \\mathrm{SMB}_t, \\mathrm{HML}_t$) 生成为 $T_{\\max}=600$ 个周期的 AR($1$) 序列，$T_{\\max}$ 是测试套件所需的最大长度。对于每个因子 $f \\in \\{M,S,H\\}$，设置新息方差为 $\\sigma^2_{\\eta,f} = 1 - \\phi_f^2$，以确保因子的平稳方差为 $1$。初始条件为 $M_0=\\mathrm{SMB}_0=\\mathrm{HML}_0=0$。\n\n3. **迭代分析**：我们遍历四个测试用例中的每一个。对于一个给定的用例，其参数为 $(T, \\beta_M, \\beta_S, \\beta_H, \\sigma_{\\varepsilon}, m)$:\n    a. 我们选择已生成的因子序列的前 $T$ 个观测值。\n    b. 使用特定用例的 $\\beta$ 参数和一组新的高斯白噪声误差 $\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma_{\\varepsilon}^2)$ 来合成资产收益序列 $R_t^e$。\n    c. 使用普通最小二乘法 (OLS) 估计两个模型：\n        i. CAPM：$R_t^e$ 对一个常数项和 $M_t$ 进行回归。\n        ii. FF3：$R_t^e$ 对一个常数项、$M_t$、$\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 进行回归。\n    d. 为每个模型计算残差向量 $e^{\\mathrm{CAPM}}$ 和 $e^{\\mathrm{FF3}}$。\n    e. 使用所提供的样本自相关 $\\hat{r}_k$ 和 $Q(m)$ 统计量的公式，并以 $\\chi^2_m$ 为参考分布，为两个残差序列计算 Ljung-Box p 值。\n    f. 通过条件 $p_{\\mathrm{FF3}} > p_{\\mathrm{CAPM}}$ 确定一个布尔结果。\n\n4. **最终输出**：将包含四个布尔结果的列表按指定格式进行格式化并打印。\n\n该实现将使用 `numpy` 进行数组计算和通过 `numpy.linalg.lstsq` 进行 OLS 估计，并使用 `scipy.stats.chi2.cdf` 来计算卡方累积分布函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating asset returns, estimating CAPM and FF3 models,\n    and comparing the whiteness of their residuals using the Ljung-Box test.\n    \"\"\"\n    # Define global simulation parameters and random seed for reproducibility.\n    SEED = 42\n    rng = np.random.default_rng(SEED)\n    \n    phi_M = 0.6\n    phi_S = 0.5\n    phi_H = 0.4\n    alpha = 0.0  # Assumed value, does not affect residuals with intercept.\n\n    # Define the test suite.\n    test_cases = [\n        # (T, beta_M, beta_S, beta_H, sigma_eps, m)\n        (600, 0.9, 0.5, -0.3, 0.5, 10),\n        (600, 1.1, 0.0, 0.0, 0.5, 10),\n        (120, 0.0, 0.8, 0.8, 0.5, 10),\n        (60, 0.0, 0.0, 0.0, 1.0, 10),\n    ]\n\n    T_max = max(case[0] for case in test_cases)\n\n    def generate_ar1(T, phi, rng_gen):\n        \"\"\"Generates an AR(1) process of length T with stationary variance 1.\"\"\"\n        sigma_eta = np.sqrt(1 - phi**2)\n        eta = rng_gen.normal(loc=0.0, scale=sigma_eta, size=T)\n        process = np.zeros(T)\n        # Process starts at t=1 with F_0 = 0.\n        # F_1 = phi * F_0 + eta_1 = eta_1.\n        if T > 0:\n            process[0] = eta[0]\n            for t in range(1, T):\n                process[t] = phi * process[t-1] + eta[t]\n        return process\n\n    # Generate a single common realization of factor processes.\n    M_full = generate_ar1(T_max, phi_M, rng)\n    SMB_full = generate_ar1(T_max, phi_S, rng)\n    HML_full = generate_ar1(T_max, phi_H, rng)\n    \n    def ljung_box_p_value(residuals, m):\n        \"\"\"Computes the Ljung-Box Q-statistic and its p-value.\"\"\"\n        T = len(residuals)\n        e_bar = np.mean(residuals) # Should be ~0 for OLS with intercept\n        e_demeaned = residuals - e_bar\n        \n        denominator = np.sum(e_demeaned**2)\n        if denominator < 1e-12:  # Avoid division by zero\n            return 1.0  # No variation means no autocorrelation.\n\n        q_terms = []\n        for k in range(1, m + 1):\n            numerator_k = np.sum(e_demeaned[k:] * e_demeaned[:-k])\n            r_k = numerator_k / denominator\n            q_terms.append(r_k**2 / (T - k))\n            \n        Q_m = T * (T + 2) * np.sum(q_terms)\n        \n        # p-value from chi-square distribution with m degrees of freedom.\n        p_val = 1.0 - chi2.cdf(Q_m, df=m)\n        return p_val\n\n    results = []\n    for case in test_cases:\n        T, beta_M, beta_S, beta_H, sigma_eps, m = case\n\n        # Use the first T observations of the common factor series.\n        M_t = M_full[:T]\n        SMB_t = SMB_full[:T]\n        HML_t = HML_full[:T]\n\n        # Generate asset returns for the current case.\n        epsilon = rng.normal(loc=0.0, scale=sigma_eps, size=T)\n        R_e = alpha + beta_M * M_t + beta_S * SMB_t + beta_H * HML_t + epsilon\n\n        # (1) Estimate CAPM and get residuals.\n        X_capm = np.vstack([np.ones(T), M_t]).T\n        beta_hat_capm = np.linalg.lstsq(X_capm, R_e, rcond=None)[0]\n        e_capm = R_e - X_capm @ beta_hat_capm\n        \n        # (2) Estimate Fama-French 3-factor model and get residuals.\n        X_ff3 = np.vstack([np.ones(T), M_t, SMB_t, HML_t]).T\n        beta_hat_ff3 = np.linalg.lstsq(X_ff3, R_e, rcond=None)[0]\n        e_ff3 = R_e - X_ff3 @ beta_hat_ff3\n\n        # Compute Ljung-Box p-values for both residual series.\n        p_val_capm = ljung_box_p_value(e_capm, m)\n        p_val_ff3 = ljung_box_p_value(e_ff3, m)\n\n        # Compare p-values to determine which residual set is \"whiter\".\n        is_ff3_whiter = p_val_ff3 > p_val_capm\n        results.append(is_ff3_whiter)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "金融研究的前沿正在不断探索超越规模 (SMB) 和价值 (HML) 的新因子。当我们识别出一个有潜力的新特征，例如环境、社会和治理 (ESG) 评分时，如何将其构建成一个可检验、可投资的因子？本练习将指导您完成构建“因子模拟投资组合” (factor-mimicking portfolio) 的关键过程，这是一种将非交易特征转化为可交易风险因子的标准方法，同时确保其对市场、规模和价值等现有因子保持风险中性。[@problem_id:2392242]", "id": "2392242", "problem": "给定一组横截面资产及其与 Fama-French 三因子模型 (FF3) 和一个新特征相关的敞口。Fama-French 三因子模型 (FF3) 包含市场因子 (Market factor)、小市值减大市值因子 (Small-Minus-Big, SMB) 和高账面市值比减低账面市值比因子 (High-Minus-Low, HML)。这个新特征是环境、社会和治理 (Environmental, Social, and Governance, ESG) 评分。您的任务是使用给定的资产超额收益面板数据，在特定的线性敞口约束下，为 ESG 特征构建最小方差因子模拟投资组合。\n\n假设有 $N=6$ 种资产和 $T=10$ 个时间周期。设 $R \\in \\mathbb{R}^{T \\times N}$ 表示以小数形式表示的资产超额收益矩阵，其中第 $t$ 行包含第 $t$ 期的 $N$ 种资产的超额收益。$R$ 的数据如下：\n- 第 1 行：$(0.012, 0.008, 0.015, 0.005, 0.010, 0.011)$\n- 第 2 行：$(-0.020, -0.015, -0.018, -0.022, -0.017, -0.019)$\n- 第 3 行：$(0.025, 0.020, 0.028, 0.018, 0.022, 0.024)$\n- 第 4 行：$(0.005, 0.007, 0.004, 0.009, 0.006, 0.005)$\n- 第 5 行：$(0.030, 0.026, 0.033, 0.021, 0.027, 0.029)$\n- 第 6 行：$(-0.010, -0.012, -0.009, -0.013, -0.011, -0.010)$\n- 第 7 行：$(0.018, 0.014, 0.020, 0.012, 0.016, 0.017)$\n- 第 8 行：$(-0.005, -0.006, -0.004, -0.007, -0.005, -0.005)$\n- 第 9 行：$(0.022, 0.019, 0.024, 0.016, 0.020, 0.021)$\n- 第 10 行：$(0.003, 0.004, 0.002, 0.005, 0.003, 0.003)$\n\n设 $\\Sigma \\in \\mathbb{R}^{N \\times N}$ 表示资产超额收益的协方差矩阵，其计算方法为总体协方差估计量：\n$$\n\\Sigma \\;=\\; \\frac{1}{T} \\sum_{t=1}^{T} \\left( r_t - \\bar{r} \\right)\\left( r_t - \\bar{r} \\right)^{\\top},\n$$\n其中 $r_t \\in \\mathbb{R}^{N}$ 是 $R$ 的第 $t$ 行，$\\bar{r} \\in \\mathbb{R}^{N}$ 是各资产收益的时间序列均值向量。\n\n此外，还给出了每种资产对 FF3 因子和 ESG 特征的敞口向量。设 $f^{\\text{MKT}}, f^{\\text{SMB}}, f^{\\text{HML}}, f^{\\text{ESG}} \\in \\mathbb{R}^{N}$ 表示每种资产的敞口：\n- $f^{\\text{MKT}} = (1.10, 0.90, 1.20, 0.80, 1.00, 1.05)$\n- $f^{\\text{SMB}} = (-0.30, 0.50, -0.20, 0.70, 0.10, -0.40)$\n- $f^{\\text{HML}} = (0.60, -0.20, 0.40, -0.50, 0.00, 0.30)$\n- $f^{\\text{ESG}} = (0.80, 0.20, -0.40, 1.10, -0.60, 0.30)$\n\n因子模拟投资组合是一个投资组合权重向量 $w \\in \\mathbb{R}^{N}$，其选择旨在最小化投资组合方差，同时满足线性敞口约束。形式上，对于给定的约束矩阵 $A \\in \\mathbb{R}^{K \\times N}$ 和目标敞口向量 $b \\in \\mathbb{R}^{K}$，权重 $w$ 求解以下问题：\n$$\n\\min_{w \\in \\mathbb{R}^{N}} \\; w^{\\top}\\Sigma w \\quad \\text{subject to} \\quad A w = b.\n$$\n\n考虑以下四个测试用例，每个用例都指定了一组约束。设 $\\mathbf{1} \\in \\mathbb{R}^{N}$ 表示全为 1 的向量。\n\n- 测试用例 1 (自融资，对 FF3 中性，单位 ESG 敞口)：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 0$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = 1$。\n- 测试用例 2 (自融资，对 FF3 中性，负单位 ESG 敞口)：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 0$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = -1$。\n- 测试用例 3 (完全投资，对 FF3 中性，0.5 ESG 敞口)：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 1$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = 0.5$。\n- 测试用例 4 (自融资，对 FF3 中性，零 ESG 敞口；边界情况)：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 0$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = 0$。\n\n对于每个测试用例，计算最小方差因子模拟投资组合 $w$ 并将投资组合方差 $v = w^{\\top} \\Sigma w$ 报告为实数。收益输入为小数（无单位），报告的 $v$ 也必须是无单位的。\n\n您的程序应生成单行输出，其中包含按测试用例 1 到 4 顺序排列的结果，格式为方括号内以逗号分隔的列表，例如：“[v1,v2,v3,v4]”。", "solution": "所提问题是量化金融中的一个标准练习：在一组线性约束下构建最小方差因子模拟投资组合。这是一个典型的有约束二次优化问题。\n\n该问题定义如下：\n$$ \\min_{w \\in \\mathbb{R}^{N}} \\; v = w^{\\top}\\Sigma w $$\n满足以下线性等式约束：\n$$ A w = b $$\n其中 $w \\in \\mathbb{R}^{N}$ 是投资组合权重向量，$\\Sigma \\in \\mathbb{R}^{N \\times N}$ 是资产超额收益的协方差矩阵， $A \\in \\mathbb{R}^{K \\times N}$ 是约束系数（因子敞口）矩阵， $b \\in \\mathbb{R}^{K}$ 是目标敞口向量。这里，资产数量为 $N=6$，约束数量为 $K=5$。\n\n该问题的解是使用拉格朗日乘数法系统地推导出来的。拉格朗日函数 $\\mathcal{L}$ 的形式如下：\n$$ \\mathcal{L}(w, \\lambda) = w^{\\top}\\Sigma w - \\lambda^{\\top}(Aw - b) $$\n其中 $\\lambda \\in \\mathbb{R}^{K}$ 是拉格朗日乘数向量。\n\n求得最小值的必要一阶条件是通过将拉格朗日函数关于 $w$ 的梯度设为零来找到的：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial w} = 2\\Sigma w - A^{\\top}\\lambda = \\mathbf{0} $$\n假设协方差矩阵 $\\Sigma$ 是可逆的，我们可以解出 $w$：\n$$ w = \\frac{1}{2} \\Sigma^{-1} A^{\\top} \\lambda $$\n为了求出 $\\lambda$，我们将 $w$ 的这个表达式代入约束方程 $Aw=b$：\n$$ A \\left( \\frac{1}{2} \\Sigma^{-1} A^{\\top} \\lambda \\right) = b $$\n$$ \\left( A \\Sigma^{-1} A^{\\top} \\right) \\lambda = 2b $$\n只要 $\\Sigma$ 是正定的且 $A$ 是行满秩的，矩阵 $A \\Sigma^{-1} A^{\\top}$ 就是可逆的。在这个问题中，这两个条件都满足。因此, 我们可以解出 $\\lambda$：\n$$ \\lambda = 2 \\left( A \\Sigma^{-1} A^{\\top} \\right)^{-1} b $$\n将 $\\lambda$ 代回到 $w$ 的方程中，得到最优权重向量 $w^{\\star}$：\n$$ w^{\\star} = \\Sigma^{-1} A^{\\top} \\left( A \\Sigma^{-1} A^{\\top} \\right)^{-1} b $$\n最小投资组合方差 $v$ 则由 $v = (w^{\\star})^{\\top}\\Sigma w^{\\star}$ 给出。通过代入 $w^{\\star}$ 的表达式，我们得到一个更直接的方差公式：\n$$ v = \\left( \\Sigma^{-1}A^{\\top}(A\\Sigma^{-1}A^{\\top})^{-1}b \\right)^{\\top} \\Sigma \\left( \\Sigma^{-1}A^{\\top}(A\\Sigma^{-1}A^{\\top})^{-1}b \\right) $$\n$$ v = b^{\\top} \\left( (A\\Sigma^{-1}A^{\\top})^{-1} \\right)^{\\top} (A\\Sigma^{-1})^{\\top} \\Sigma \\Sigma^{-1} A^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} b $$\n$$ v = b^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} A \\Sigma^{-1} A^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} b $$\n$$ v = b^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} b $$\n这个最终表达式在计算上是高效的，并将用于求解每个测试用例中的方差。\n\n计算过程如下：\n$1$. 资产超额收益协方差矩阵 $\\Sigma \\in \\mathbb{R}^{6 \\times 6}$ 是根据所提供的数据矩阵 $R \\in \\mathbb{R}^{10 \\times 6}$ 使用指定的总体协方差公式计算的：$\\Sigma = \\frac{1}{T} \\sum_{t=1}^{T} ( r_t - \\bar{r} )( r_t - \\bar{r} )^{\\top}$，其中 $T=10$ 是时间周期数，$r_t$ 是时间点 $t$ 的收益向量，$\\bar{r}$ 是每种资产收益的时间序列均值。\n\n$2$. 约束矩阵 $A \\in \\mathbb{R}^{5 \\times 6}$ 是通过将全 1 向量 $\\mathbf{1}$ 和因子敞口向量 $f^{\\text{MKT}}$、$f^{\\text{SMB}}$、$f^{\\text{HML}}$ 和 $f^{\\text{ESG}}$ 作为其行堆叠而成的：\n$$ A = \\begin{pmatrix} \\mathbf{1}^{\\top} \\\\ (f^{\\text{MKT}})^{\\top} \\\\ (f^{\\text{SMB}})^{\\top} \\\\ (f^{\\text{HML}})^{\\top} \\\\ (f^{\\text{ESG}})^{\\top} \\end{pmatrix} $$\n\n$3$. 对四个测试用例中的每一个，都定义了相应的目标敞口向量 $b \\in \\mathbb{R}^{5}$。\n\n$4$. 计算核心矩阵 $M = (A\\Sigma^{-1}A^{\\top})^{-1}$。\n\n$5$. 每个用例的最小方差计算为 $v = b^{\\top}Mb$。\n\n测试用例的评估过程如下：\n- 对于测试用例 1，$b_1 = [0, 0, 0, 0, 1]^{\\top}$。方差为 $v_1 = b_1^{\\top}Mb_1$。\n- 对于测试用例 2，$b_2 = [0, 0, 0, 0, -1]^{\\top}$。由于 $b_2 = -b_1$，方差为 $v_2 = (-b_1)^{\\top}M(-b_1) = b_1^{\\top}Mb_1 = v_1$。用例 1 和 2 的方差必须相同。\n- 对于测试用例 3，$b_3 = [1, 0, 0, 0, 0.5]^{\\top}$。方差为 $v_3 = b_3^{\\top}Mb_3$。\n- 对于测试用例 4，$b_4 = [0, 0, 0, 0, 0]^{\\top}$。目标向量是零向量。这直接意味着方差为 $v_4 = \\mathbf{0}^{\\top}M\\mathbf{0} = 0$。最优投资组合就是 $w^{\\star} = \\mathbf{0}$，其方差为零，并满足齐次约束 $A w = \\mathbf{0}$。\n\n下面的实现以数值方式执行这些计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes minimum-variance factor-mimicking portfolio variances for four test cases.\n    \"\"\"\n    # Number of assets N and time periods T\n    N = 6\n    T = 10\n\n    # Data from the problem statement\n    # Asset excess returns matrix R in decimal form\n    R = np.array([\n        [0.012, 0.008, 0.015, 0.005, 0.010, 0.011],\n        [-0.020, -0.015, -0.018, -0.022, -0.017, -0.019],\n        [0.025, 0.020, 0.028, 0.018, 0.022, 0.024],\n        [0.005, 0.007, 0.004, 0.009, 0.006, 0.005],\n        [0.030, 0.026, 0.033, 0.021, 0.027, 0.029],\n        [-0.010, -0.012, -0.009, -0.013, -0.011, -0.010],\n        [0.018, 0.014, 0.020, 0.012, 0.016, 0.017],\n        [-0.005, -0.006, -0.004, -0.007, -0.005, -0.005],\n        [0.022, 0.019, 0.024, 0.016, 0.020, 0.021],\n        [0.003, 0.004, 0.002, 0.005, 0.003, 0.003]\n    ])\n\n    # Factor exposure vectors\n    f_mkt = np.array([1.10, 0.90, 1.20, 0.80, 1.00, 1.05])\n    f_smb = np.array([-0.30, 0.50, -0.20, 0.70, 0.10, -0.40])\n    f_hml = np.array([0.60, -0.20, 0.40, -0.50, 0.00, 0.30])\n    f_esg = np.array([0.80, 0.20, -0.40, 1.10, -0.60, 0.30])\n\n    # Step 1: Compute the population covariance matrix Sigma.\n    # The problem asks for the population covariance estimator, which corresponds\n    # to using a divisor of T (ddof=0 in numpy.cov).\n    Sigma = np.cov(R, rowvar=False, ddof=0)\n\n    # Step 2: Construct the constraint matrix A.\n    # The rows of A are the constraint vectors.\n    ones_vec = np.ones(N)\n    A = np.vstack([ones_vec, f_mkt, f_smb, f_hml, f_esg])\n\n    # Step 3: Compute the core matrix M = (A * Sigma_inv * A^T)^-1.\n    try:\n        Sigma_inv = np.linalg.inv(Sigma)\n        M = np.linalg.inv(A @ Sigma_inv @ A.T)\n    except np.linalg.LinAlgError as e:\n        # This case should not be reached given the problem data.\n        print(f\"Error during matrix inversion: {e}\")\n        return\n\n    # Step 4: Define the target exposure vectors 'b' for each test case.\n    test_cases = [\n        # Case 1: self-financing, FF3-neutral, unit ESG exposure\n        {\"b\": np.array([0., 0., 0., 0., 1.])},\n        # Case 2: self-financing, FF3-neutral, negative unit ESG exposure\n        {\"b\": np.array([0., 0., 0., 0., -1.])},\n        # Case 3: fully invested, FF3-neutral, half ESG exposure\n        {\"b\": np.array([1., 0., 0., 0., 0.5])},\n        # Case 4: self-financing, FF3-neutral, zero ESG exposure (boundary case)\n        {\"b\": np.array([0., 0., 0., 0., 0.])}\n    ]\n\n    results = []\n    # Step 5: Calculate the minimum variance for each test case.\n    for case in test_cases:\n        b = case[\"b\"]\n        variance = b.T @ M @ b\n        results.append(variance)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "标准法马-佛伦奇模型的一个核心假设是因子风险溢价（如 $\\lambda_{SMB}$ 和 $\\lambda_{HML}$）是恒定不变的。然而在现实中，经济周期和市场情绪的变化可能导致这些溢价发生改变。本项高级练习将挑战您构建一个更贴近现实的动态模型，其中因子溢价会根据潜在的经济“状态”进行转换。您将学习并实践汉密尔顿滤波器 (Hamilton filter)，这是一种处理隐马尔可夫模型 (Hidden Markov Model) 的强大工具，用于推断潜在状态并评估该动态模型的表现。[@problem_id:2392227]", "id": "2392227", "problem": "给定一份关于预期收益的双状态区制转移（regime-switching）Fama-French三因子模型的公式。对于单个资产，其对市场（market）、Small Minus Big (SMB) 和 High Minus Low (HML) 因子的因子暴露（factor exposures）分别为 $\\beta_{M}$、$\\beta_{S}$ 和 $\\beta_{H}$，其条件预期超额收益被假定依赖于经济的潜在状态 $S_t \\in \\{1,2\\}$，这种依赖通过 SMB 和 HML 因子的状态依赖因子溢价（state-dependent factor premia）来实现。具体而言，在每个时间点 $t$，观测到的超额收益 $r_t$ 被建模为\n$$\nr_t \\mid S_t=s \\sim \\mathcal{N}\\left(\\mu_s, \\sigma^2\\right), \\quad s \\in \\{1,2\\},\n$$\n其条件均值为\n$$\n\\mu_s \\;=\\; \\beta_{M}\\,\\lambda_{M} \\;+\\; \\beta_{S}\\,\\lambda_{SMB}^{(s)} \\;+\\; \\beta_{H}\\,\\lambda_{HML}^{(s)},\n$$\n其中 $\\lambda_{M}$ 是市场溢价，而 $\\lambda_{SMB}^{(s)}$ 和 $\\lambda_{HML}^{(s)}$ 是 SMB 和 HML 因子的状态依赖因子溢价。潜在状态 $\\{S_t\\}$ 服从一个时间同质的一阶马尔可夫链（time-homogeneous first-order Markov chain），其转移矩阵为\n$$\nP \\;=\\; \n\\begin{bmatrix}\np_{11} & p_{12} \\\\\np_{21} & p_{22}\n\\end{bmatrix},\n\\quad \\text{其中 } p_{ij} = \\mathbb{P}(S_t=j \\mid S_{t-1}=i), \\; p_{12}=1-p_{11}, \\; p_{21}=1-p_{22}.\n$$\n设初始状态分布为 $\\pi_0 = \\big(\\mathbb{P}(S_0=1), \\mathbb{P}(S_0=2)\\big)$。\n\n您的任务是为每个给定的测试用例计算：\n- 在指定模型下，观测序列 $\\{r_t\\}_{t=1}^{T}$ 的总对数似然（total log-likelihood），以及\n- 滤波概率（filtered probability）$\\mathbb{P}(S_T=1 \\mid r_1,\\dots,r_T)$。\n\n所有收益均为以小数形式表示的超额收益。高斯似然必须使用指定的方差 $\\sigma^2$ 通过精确的概率密度函数进行计算。结果必须以实数形式报告，并四舍五入到六位小数。\n\n测试套件：\n- 测试用例 A:\n  - 参数：\n    - $\\beta_{M} = 1.1$, $\\beta_{S} = 0.4$, $\\beta_{H} = -0.2$.\n    - $\\lambda_{M} = 0.006$.\n    - $\\lambda_{SMB}^{(1)} = 0.004$, $\\lambda_{HML}^{(1)} = 0.002$; $\\lambda_{SMB}^{(2)} = -0.001$, $\\lambda_{HML}^{(2)} = 0.005$.\n    - $\\sigma = 0.01$.\n    - $P = \\begin{bmatrix} 0.9 & 0.1 \\\\ 0.2 & 0.8 \\end{bmatrix}$.\n    - $\\pi_0 = \\big(2/3,\\, 1/3\\big)$.\n  - 观测值（小数）： $[\\,0.006,\\,0.009,\\,0.004,\\,0.007,\\,0.005,\\,0.008\\,]$.\n- 测试用例 B:\n  - 参数：\n    - $\\beta_{M} = 0.9$, $\\beta_{S} = 0.7$, $\\beta_{H} = 0.3$.\n    - $\\lambda_{M} = 0.005$.\n    - $\\lambda_{SMB}^{(1)} = 0.003$, $\\lambda_{HML}^{(1)} = 0.001$; $\\lambda_{SMB}^{(2)} = -0.002$, $\\lambda_{HML}^{(2)} = -0.001$.\n    - $\\sigma = 0.008$.\n    - $P = \\begin{bmatrix} 0.99 & 0.01 \\\\ 0.02 & 0.98 \\end{bmatrix}$.\n    - $\\pi_0 = \\big(2/3,\\,1/3\\big)$.\n  - 观测值（小数）： $[\\,0.0065,\\,0.0072,\\,0.0023,\\,0.0030,\\,0.0068\\,]$.\n- 测试用例 C (状态均值相等的边缘情况):\n  - 参数：\n    - $\\beta_{M} = 1.0$, $\\beta_{S} = 0.5$, $\\beta_{H} = 0.5$.\n    - $\\lambda_{M} = 0.004$.\n    - $\\lambda_{SMB}^{(1)} = 0.002$, $\\lambda_{HML}^{(1)} = 0.001$; $\\lambda_{SMB}^{(2)} = 0.002$, $\\lambda_{HML}^{(2)} = 0.001$.\n    - $\\sigma = 0.012$.\n    - $P = \\begin{bmatrix} 0.6 & 0.4 \\\\ 0.3 & 0.7 \\end{bmatrix}$.\n    - $\\pi_0 = \\big(3/7,\\,4/7\\big)$.\n  - 观测值（小数）： $[\\,0.0040,\\,0.0060,\\,0.0050,\\,0.0070\\,]$.\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个列表，每个测试用例对应一个条目。\n- 每个条目必须是一个包含两个元素的列表，其中包括：\n  - 总对数似然（四舍五入到六位小数），以及\n  - 滤波概率 $\\mathbb{P}(S_T=1 \\mid r_1,\\dots,r_T)$（四舍五入到六位小数）。\n- 确切的字符串格式必须是：\n  - $[\\,[\\ell_A, p_A],\\,[\\ell_B, p_B],\\,[\\ell_C, p_C]\\,]$，其中 $\\ell_\\cdot$ 和 $p_\\cdot$ 分别是测试用例 A、B 和 C 的相应四舍五入值。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如 $[[\\ell_A,p_A],[\\ell_B,p_B],[\\ell_C,p_C]]$。", "solution": "该问题要求为一个由双状态区制转移 Fama-French 模型生成的资产收益序列计算总对数似然和最终的滤波状态概率。这是一个隐马尔可夫模型（Hidden Markov Model, HMM）的经典应用，其标准解决方法是前向-后向算法中的前向传递（forward-pass），通常称为汉密尔顿滤波器（Hamilton filter）。\n\n模型具体规定如下：\n在时间 $t$ 观测到的超额收益，记为 $r_t$，来自一个高斯分布，其参数取决于一个潜在状态 $S_t \\in \\{1, 2\\}$。\n$$\nr_t \\mid S_t=s \\sim \\mathcal{N}(\\mu_s, \\sigma^2)\n$$\n状态依赖均值 $\\mu_s$ 是三个因子的线性函数，其中 SMB 和 HML 因子具有状态依赖的溢价：\n$$\n\\mu_s = \\beta_{M}\\lambda_{M} + \\beta_{S}\\lambda_{SMB}^{(s)} + \\beta_{H}\\lambda_{HML}^{(s)}\n$$\n潜在状态序列 $\\{S_t\\}$ 是一个具有给定转移矩阵 $P$ 和状态 $S_0$ 初始状态分布 $\\pi_0$ 的一阶马尔可夫链。观测数据从 $t=1$ 到 $t=T$。\n\n目标是计算总对数似然 $\\mathcal{L} = \\log \\mathbb{P}(r_1, \\dots, r_T)$ 和滤波概率 $\\mathbb{P}(S_T=1 \\mid r_1, \\dots, r_T)$。这可以通过递归计算滤波概率 $\\pi_{t|t} = (\\mathbb{P}(S_t=1 \\mid \\mathcal{F}_t), \\mathbb{P}(S_t=2 \\mid \\mathcal{F}_t))$ 来完成，其中 $\\mathcal{F}_t = \\{r_1, \\dots, r_t\\}$ 是截至时间 $t$ 的信息集。\n\n汉密尔顿滤波器算法对 $t = 1, \\dots, T$ 进行迭代：\n\n1.  **初始化**：过程从 $t=1$ 开始。在观测到 $r_1$ 之前，我们需要状态 $S_1$ 的概率分布。这是在 $t=1$ 时的预测概率，以 $t=0$ 时的信息为条件（就观测而言，此时没有信息）。问题指定了 $S_0$ 的分布为 $\\pi_0$。因此，$S_1$ 的预测概率向量为 $\\pi_{1|0} = \\pi_0 P$，其中 $P$ 是转移矩阵。对于递归的第一步，我们使用 $\\pi_{0|0} = \\pi_0$。\n\n2.  **递归步骤 ($t=1, \\dots, T$)**：给定上一步的滤波概率，$\\pi_{t-1|t-1} = (\\mathbb{P}(S_{t-1}=1 \\mid \\mathcal{F}_{t-1}), \\mathbb{P}(S_{t-1}=2 \\mid \\mathcal{F}_{t-1}))$，我们执行两个操作：预测和更新。\n\n    a.  **预测步骤**：我们使用马尔可夫属性预测时间 $t$ 的状态概率：\n        $$\n        \\pi_{t|t-1} = \\pi_{t-1|t-1} P\n        $$\n        其中 $\\pi_{t|t-1}(j) = \\mathbb{P}(S_t=j \\mid \\mathcal{F}_{t-1})$。\n\n    b.  **更新步骤**：观测到 $r_t$ 后，我们使用贝叶斯定理更新我们对状态 $S_t$ 的信念。\n        首先，我们计算观测值 $r_t$ 在每个状态 $s \\in \\{1, 2\\}$ 下的条件概率密度，我们将其记为 $\\eta_s(r_t)$：\n        $$\n        \\eta_s(r_t) = f(r_t \\mid S_t=s) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(r_t - \\mu_s)^2}{2\\sigma^2}\\right)\n        $$\n        给定过去的观测值 $\\mathcal{F}_{t-1}$，观测到 $r_t$ 的边际似然（marginal likelihood）是这些密度的加权平均，权重由预测概率给出：\n        $$\n        f(r_t \\mid \\mathcal{F}_{t-1}) = \\sum_{s=1}^{2} f(r_t \\mid S_t=s) \\mathbb{P}(S_t=s \\mid \\mathcal{F}_{t-1}) = \\sum_{s=1}^{2} \\eta_s(r_t) \\pi_{t|t-1}(s)\n        $$\n        整个序列的对数似然是每个时间步的这些边际似然的对数之和：\n        $$\n        \\mathcal{L} = \\sum_{t=1}^{T} \\log f(r_t \\mid \\mathcal{F}_{t-1})\n        $$\n        最后，通过使用来自 $r_t$ 的信息更新预测概率来计算滤波概率向量 $\\pi_{t|t}$：\n        $$\n        \\pi_{t|t}(s) = \\mathbb{P}(S_t=s \\mid \\mathcal{F}_t) = \\frac{f(r_t \\mid S_t=s) \\mathbb{P}(S_t=s \\mid \\mathcal{F}_{t-1})}{f(r_t \\mid \\mathcal{F}_{t-1})} = \\frac{\\eta_s(r_t) \\pi_{t|t-1}(s)}{\\sum_{k=1}^{2} \\eta_k(r_t) \\pi_{t|t-1}(k)}\n        $$\n\n此递归过程应用于 $t=1, \\dots, T$。在最后一步 $t=T$ 之后，累加和即为总对数似然 $\\mathcal{L}$，最终的滤波概率向量为 $\\pi_{T|T}$。问题要求此向量的第一个分量，即 $\\mathbb{P}(S_T=1 \\mid \\mathcal{F}_T)$。\n\n对于测试用例 C，我们注意到状态依赖均值是相同的，即 $\\mu_1 = \\mu_2$。这意味着条件密度对于任何 $r_t$ 也都是相同的，即 $\\eta_1(r_t) = \\eta_2(r_t)$。因此，观测值 $r_t$ 没有提供任何可以区分状态的信息。更新步骤简化为 $\\pi_{t|t}(s) = \\pi_{t|t-1}(s)$。因此，滤波概率的演变完全遵循马尔可夫链的动态：$\\pi_{t|t} = \\pi_{t-1|t-1} P$。由于给定的初始分布 $\\pi_0 = (3/7, 4/7)$ 是给定转移矩阵 $P$ 的平稳分布（stationary distribution），因此对于所有 $t$ 都有 $\\pi_{t|t} = \\pi_0$。所以，最终的滤波概率 $\\mathbb{P}(S_T=1 \\mid \\mathcal{F}_T)$ 必须是 $3/7$。对数似然则是在单一均值 $\\mu = \\mu_1 = \\mu_2$ 处求值的对数密度之和。\n\n实现将对每个测试用例遵循此逻辑，计算状态依赖均值，然后遍历观测值以执行滤波器递归。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the regime-switching Fama-French model problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"betas\": (1.1, 0.4, -0.2), # (beta_M, beta_S, beta_H)\n            \"lambda_M\": 0.006,\n            \"lambda_s1\": (0.004, 0.002), # (lambda_SMB_1, lambda_HML_1)\n            \"lambda_s2\": (-0.001, 0.005), # (lambda_SMB_2, lambda_HML_2)\n            \"sigma\": 0.01,\n            \"P\": np.array([[0.9, 0.1], [0.2, 0.8]]),\n            \"pi0\": np.array([2/3, 1/3]),\n            \"observations\": [0.006, 0.009, 0.004, 0.007, 0.005, 0.008]\n        },\n        {\n            \"betas\": (0.9, 0.7, 0.3),\n            \"lambda_M\": 0.005,\n            \"lambda_s1\": (0.003, 0.001),\n            \"lambda_s2\": (-0.002, -0.001),\n            \"sigma\": 0.008,\n            \"P\": np.array([[0.99, 0.01], [0.02, 0.98]]),\n            \"pi0\": np.array([2/3, 1/3]),\n            \"observations\": [0.0065, 0.0072, 0.0023, 0.0030, 0.0068]\n        },\n        {\n            \"betas\": (1.0, 0.5, 0.5),\n            \"lambda_M\": 0.004,\n            \"lambda_s1\": (0.002, 0.001),\n            \"lambda_s2\": (0.002, 0.001),\n            \"sigma\": 0.012,\n            \"P\": np.array([[0.6, 0.4], [0.3, 0.7]]),\n            \"pi0\": np.array([3/7, 4/7]),\n            \"observations\": [0.0040, 0.0060, 0.0050, 0.0070]\n        }\n    ]\n\n    def run_filter(case):\n        \"\"\"\n        Implements the Hamilton filter for a single test case.\n        \"\"\"\n        beta_m, beta_s, beta_h = case[\"betas\"]\n        lambda_m = case[\"lambda_M\"]\n        lambda_smb1, lambda_hml1 = case[\"lambda_s1\"]\n        lambda_smb2, lambda_hml2 = case[\"lambda_s2\"]\n        sigma = case[\"sigma\"]\n        P = case[\"P\"]\n        pi0 = case[\"pi0\"]\n        observations = case[\"observations\"]\n\n        # Calculate state-dependent means\n        mu1 = beta_m * lambda_m + beta_s * lambda_smb1 + beta_h * lambda_hml1\n        mu2 = beta_m * lambda_m + beta_s * lambda_smb2 + beta_h * lambda_hml2\n        \n        mus = np.array([mu1, mu2])\n\n        total_log_likelihood = 0.0\n        # Initialize filtered probability with pi0 (for state S_0)\n        filtered_prob = pi0\n\n        for r_t in observations:\n            # Prediction step: P(S_t | F_{t-1}) = P(S_{t-1} | F_{t-1}) * P\n            predicted_prob = filtered_prob @ P\n            \n            # Likelihood of observation r_t in each state\n            # eta_s = P(r_t | S_t=s)\n            emission_likelihoods = norm.pdf(r_t, loc=mus, scale=sigma)\n            \n            # Marginal likelihood of observation r_t\n            # f(r_t | F_{t-1})\n            marginal_likelihood = np.dot(predicted_prob, emission_likelihoods)\n            \n            # Update total log-likelihood\n            total_log_likelihood += np.log(marginal_likelihood)\n            \n            # Update step: P(S_t | F_t)\n            # using Bayes' rule: P(S_t | r_t, F_{t-1}) approx P(S_t | F_t)\n            numerator = predicted_prob * emission_likelihoods\n            filtered_prob = numerator / marginal_likelihood\n        \n        final_filtered_prob_s1 = filtered_prob[0]\n        \n        return [round(total_log_likelihood, 6), round(final_filtered_prob_s1, 6)]\n\n    results = []\n    for case in test_cases:\n        results.append(run_filter(case))\n\n    # Format the output string to match the required format exactly.\n    # The format [l,p] should not have spaces after the comma.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"}]}