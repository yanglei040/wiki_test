{"hands_on_practices": [{"introduction": "经验金融学的基石是将理论模型转化为可检验的估计值，而资本资产定价模型（CAPM）正是一个典型范例。本练习将引导您从第一性原理出发，亲手实现CAPM中alpha（$\\\\alpha$）和beta（$\\\\beta$）的普通最小二乘法（OLS）估计。通过手动编写求解过程，您将不再仅仅依赖现成的函数库，从而对统计估计的工作原理获得更深刻、更直观的理解。[@problem_id:2378983]", "id": "2378983", "problem": "给定一个资产、市场和无风险利率的多个时间序列数据样本。对于每个样本，假设资本资产定价模型 (CAPM) 成立，其形式为\n$$\nr_{i,t} - r_{f,t} = \\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right) + \\varepsilon_t,\n$$\n其中周期由 $t = 1, \\ldots, T$ 索引，$r_{i,t}$ 是资产收益率，$r_{m,t}$ 是市场收益率，$r_{f,t}$ 是无风险收益率，$\\alpha$ 是截距，$\\beta$ 是市场超额收益率的斜率，$\\varepsilon_t$ 是残差。所有收益率均以小数形式提供，而非百分比。\n\n您的任务是为每个样本计算一对参数 $(\\hat{\\alpha}, \\hat{\\beta})$，以最小化残差平方和\n$$\n\\sum_{t=1}^{T} \\left[\\left(r_{i,t} - r_{f,t}\\right) - \\left(\\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right)\\right)\\right]^2.\n$$\n\n请使用以下测试套件。对于每个测试用例，$r_i$ 表示资产收益率序列，$r_m$ 表示市场收益率序列，$r_f$ 表示无风险收益率序列。每个序列都是一个长度为 $T$ 的有序列表。\n\n- 测试用例 1 (一般情况, $T=5$):\n  - $r_m = [\\,0.012,\\, 0.018,\\, -0.005,\\, 0.010,\\, 0.022\\,]$\n  - $r_f = [\\,0.002,\\, 0.002,\\, 0.002,\\, 0.0025,\\, 0.0025\\,]$\n  - $r_i = [\\,0.015,\\, 0.0222,\\, -0.0054,\\, 0.0125,\\, 0.0269\\,]$\n\n- 测试用例 2 (观测值最少的边界情况, $T=2$):\n  - $r_m = [\\,0.02,\\, 0.05\\,]$\n  - $r_f = [\\,0.0,\\, 0.0\\,]$\n  - $r_i = [\\,0.07,\\, 0.16\\,]$\n\n- 测试用例 3 (零截距，变化的无风险利率, $T=4$):\n  - $r_m = [\\,0.01,\\, 0.00,\\, 0.03,\\, -0.02\\,]$\n  - $r_f = [\\,0.002,\\, 0.002,\\, 0.0025,\\, 0.0015\\,]$\n  - $r_i = [\\,0.014,\\, -0.001,\\, 0.04375,\\, -0.03075\\,]$\n\n- 测试用例 4 (负截距和负斜率, $T=3$):\n  - $r_m = [\\,0.015,\\, -0.010,\\, 0.005\\,]$\n  - $r_f = [\\,0.001,\\, 0.0015,\\, 0.001\\,]$\n  - $r_i = [\\,-0.008,\\, 0.00525,\\, -0.003\\,]$\n\n对于每个测试用例，请使用上述标准计算估计值 $(\\hat{\\alpha}, \\hat{\\beta})$。所有收益率和结果都表示为小数（无百分号）。您的程序应生成单行输出，其中包含四个测试用例的结果，形式为列表的列表，每个内部列表包含 $[\\hat{\\alpha}, \\hat{\\beta}]$，四舍五入到六位小数，并按测试用例的顺序排列。确切要求的输出格式是：\n$$\n[[\\hat{\\alpha}_1,\\hat{\\beta}_1],[\\hat{\\alpha}_2,\\hat{\\beta}_2],[\\hat{\\alpha}_3,\\hat{\\beta}_3],[\\hat{\\alpha}_4,\\hat{\\beta}_4]]\n$$\n打印在单行上，值和列表之间用逗号分隔，每个浮点数精确显示小数点后六位。", "solution": "所提出的问题是计量经济学中的一个标准练习，要求使用普通最小二乘法 (OLS) 估计资本资产定价模型 (CAPM) 的参数。我将首先根据要求的协议验证问题陈述。\n\n### 步骤 1：提取给定条件\n\n问题提供了以下内容：\n\n- CAPM 方程：\n$$\nr_{i,t} - r_{f,t} = \\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right) + \\varepsilon_t\n$$\n其中 $t = 1, \\ldots, T$。变量定义为资产收益率 ($r_{i,t}$)、市场收益率 ($r_{m,t}$)、无风险收益率 ($r_{f,t}$)、截距 ($\\alpha$)、斜率 ($\\beta$) 和残差 ($\\varepsilon_t$)。\n\n- 需要最小化的目标函数是残差平方和 (SSR)：\n$$\n\\sum_{t=1}^{T} \\left[\\left(r_{i,t} - r_{f,t}\\right) - \\left(\\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right)\\right)\\right]^2\n$$\n\n- 四个测试用例，包含 $r_m$、$r_f$ และ $r_i$ 的时间序列数据：\n  - 测试用例 1 ($T=5$):\n    - $r_m = [\\,0.012,\\, 0.018,\\, -0.005,\\, 0.010,\\, 0.022\\,]$\n    - $r_f = [\\,0.002,\\, 0.002,\\, 0.002,\\, 0.0025,\\, 0.0025\\,]$\n    - $r_i = [\\,0.015,\\, 0.0222,\\, -0.0054,\\, 0.0125,\\, 0.0269\\,]$\n  - 测试用例 2 ($T=2$):\n    - $r_m = [\\,0.02,\\, 0.05\\,]$\n    - $r_f = [\\,0.0,\\, 0.0\\,]$\n    - $r_i = [\\,0.07,\\, 0.16\\,]$\n  - 测试用例 3 ($T=4$):\n    - $r_m = [\\,0.01,\\, 0.00,\\, 0.03,\\, -0.02\\,]$\n    - $r_f = [\\,0.002,\\, 0.002,\\, 0.0025,\\, 0.0015\\,]$\n    - $r_i = [\\,0.014,\\, -0.001,\\, 0.04375,\\, -0.03075\\,]$\n  - 测试用例 4 ($T=3$):\n    - $r_m = [\\,0.015,\\, -0.010,\\, 0.005\\,]$\n    - $r_f = [\\,0.001,\\, 0.0015,\\, 0.001\\,]$\n    - $r_i = [\\,-0.008,\\, 0.00525,\\, -0.003\\,]$\n\n- 要求的输出是一个单行字符串，表示一个列表的列表，每个内部列表包含估计的参数 $[\\hat{\\alpha}, \\hat{\\beta}]$，四舍五入到六位小数。\n\n### 步骤 2：使用提取的给定条件进行验证\n\n该问题根据既定标准进行验证。\n\n- **科学基础扎实**：该问题是线性回归这一基本统计方法在金融经济学基石模型 CAPM 上的应用。它在科学上是合理的，并且是该领域的经典范例。\n- **适定性**：问题是找到最小化平方和的参数，这定义了一个标准的普通最小二乘法 (OLS) 估计。当且仅当自变量（市场超额收益）不为常数时，$(\\hat{\\alpha}, \\hat{\\beta})$ 存在唯一解。对于所有给定的测试用例，市场超额收益序列都存在变动，因此确保了唯一解的存在。$T=2$ 的情况（测试用例 2）是一个边界条件，其中两个参数由两个数据点精确确定，这是一个定义明确的数学问题。\n- **客观性**：问题是用精确的数学方程和客观的数值数据来表述的。没有主观或模糊的陈述。\n- **不完整或矛盾的设定**：问题是自洽的。所有必要的数据和定义都已提供。没有矛盾之处。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。这是一个清晰、一致且适定的问题，其基础是成熟的金融和统计理论。我现在将继续进行求解。\n\n### 解题推导\n\n问题是通过最小化残差平方和来找到参数 $\\hat{\\alpha}$ 和 $\\hat{\\beta}$。这是普通最小二乘法 (OLS) 的经典应用。让我们将超额资产收益定义为 $y_t = r_{i,t} - r_{f,t}$，将超额市场收益定义为 $x_t = r_{m,t} - r_{f,t}$。模型简化为简单的线性回归：\n$$\ny_t = \\alpha + \\beta x_t + \\varepsilon_t\n$$\n目标是最小化残差平方和 $S(\\alpha, \\beta)$：\n$$\nS(\\alpha, \\beta) = \\sum_{t=1}^{T} \\varepsilon_t^2 = \\sum_{t=1}^{T} (y_t - \\alpha - \\beta x_t)^2\n$$\n为了找到最小值，我们对 $S$ 分别求关于 $\\alpha$ 和 $\\beta$ 的一阶偏导数，并令它们为零。\n\n关于 $\\alpha$ 的偏导数：\n$$\n\\frac{\\partial S}{\\partial \\alpha} = \\sum_{t=1}^{T} 2(y_t - \\alpha - \\beta x_t)(-1) = -2 \\left( \\sum_{t=1}^{T} y_t - T\\alpha - \\beta \\sum_{t=1}^{T} x_t \\right) = 0\n$$\n这简化为第一个正规方程：\n$$\n\\sum_{t=1}^{T} y_t = T\\hat{\\alpha} + \\hat{\\beta} \\sum_{t=1}^{T} x_t\n$$\n两边除以 $T$，我们得到 $\\bar{y} = \\hat{\\alpha} + \\hat{\\beta}\\bar{x}$，其中 $\\bar{y}$ 和 $\\bar{x}$ 分别是 $y_t$ 和 $x_t$ 的样本均值。这使我们能将 $\\hat{\\alpha}$ 表示为：\n$$\n\\hat{\\alpha} = \\bar{y} - \\hat{\\beta}\\bar{x}\n$$\n\n关于 $\\beta$ 的偏导数：\n$$\n\\frac{\\partial S}{\\partial \\beta} = \\sum_{t=1}^{T} 2(y_t - \\alpha - \\beta x_t)(-x_t) = -2 \\left( \\sum_{t=1}^{T} x_t y_t - \\alpha \\sum_{t=1}^{T} x_t - \\beta \\sum_{t=1}^{T} x_t^2 \\right) = 0\n$$\n这简化为第二个正规方程：\n$$\n\\sum_{t=1}^{T} x_t y_t = \\hat{\\alpha} \\sum_{t=1}^{T} x_t + \\hat{\\beta} \\sum_{t=1}^{T} x_t^2\n$$\n将 $\\hat{\\alpha}$ 的表达式代入第二个正规方程：\n$$\n\\sum x_t y_t = (\\bar{y} - \\hat{\\beta}\\bar{x}) \\sum x_t + \\hat{\\beta} \\sum x_t^2\n$$\n$$\n\\sum x_t y_t = \\bar{y} \\sum x_t - \\hat{\\beta}\\bar{x} \\sum x_t + \\hat{\\beta} \\sum x_t^2\n$$\n重新整理以求解 $\\hat{\\beta}$：\n$$\n\\hat{\\beta} \\left( \\sum x_t^2 - \\bar{x} \\sum x_t \\right) = \\sum x_t y_t - \\bar{y} \\sum x_t\n$$\n使用 $\\sum x_t = T\\bar{x}$，我们有：\n$$\n\\hat{\\beta} \\left( \\sum x_t^2 - T\\bar{x}^2 \\right) = \\sum x_t y_t - T\\bar{x}\\bar{y}\n$$\n括号中的项分别是样本方差和协方差的分子（没有乘以 $1/T$ 或 $1/(T-1)$ 的缩放因子）。具体来说，$\\sum(x_t-\\bar{x})^2 = \\sum x_t^2 - T\\bar{x}^2$ 和 $\\sum(x_t-\\bar{x})(y_t-\\bar{y}) = \\sum x_t y_t - T\\bar{x}\\bar{y}$。因此，$\\beta$ 的估计量由著名的公式给出：\n$$\n\\hat{\\beta} = \\frac{\\sum_{t=1}^{T} (x_t - \\bar{x})(y_t - \\bar{y})}{\\sum_{t=1}^{T} (x_t - \\bar{x})^2} = \\frac{\\text{Cov}(x, y)}{\\text{Var}(x)}\n$$\n该算法将首先为每个测试用例计算序列 $x_t$ 和 $y_t$。然后，计算样本均值 $\\bar{x}$ 和 $\\bar{y}$。最后，使用协方差-方差公式计算 $\\hat{\\beta}$，并使用其与均值和 $\\hat{\\beta}$ 的关系找到 $\\hat{\\alpha}$。此过程将应用于所有四个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the CAPM parameters alpha and beta for multiple test cases\n    using Ordinary Least Squares (OLS).\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (general case, T=5)\n        {\n            'r_m': np.array([0.012, 0.018, -0.005, 0.010, 0.022]),\n            'r_f': np.array([0.002, 0.002, 0.002, 0.0025, 0.0025]),\n            'r_i': np.array([0.015, 0.0222, -0.0054, 0.0125, 0.0269])\n        },\n        # Test Case 2 (boundary with minimal observations, T=2)\n        {\n            'r_m': np.array([0.02, 0.05]),\n            'r_f': np.array([0.0, 0.0]),\n            'r_i': np.array([0.07, 0.16])\n        },\n        # Test Case 3 (zero intercept, varying risk-free rate, T=4)\n        {\n            'r_m': np.array([0.01, 0.00, 0.03, -0.02]),\n            'r_f': np.array([0.002, 0.002, 0.0025, 0.0015]),\n            'r_i': np.array([0.014, -0.001, 0.04375, -0.03075])\n        },\n        # Test Case 4 (negative intercept and slope, T=3)\n        {\n            'r_m': np.array([0.015, -0.010, 0.005]),\n            'r_f': np.array([0.001, 0.0015, 0.001]),\n            'r_i': np.array([-0.008, 0.00525, -0.003])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        r_m, r_f, r_i = case['r_m'], case['r_f'], case['r_i']\n\n        # Calculate excess returns\n        # y_t = r_i,t - r_f,t (dependent variable)\n        y = r_i - r_f\n        # x_t = r_m,t - r_f,t (independent variable)\n        x = r_m - r_f\n\n        # Calculate sample means\n        x_bar = np.mean(x)\n        y_bar = np.mean(y)\n\n        # Calculate the OLS estimator for beta (slope)\n        # beta_hat = Cov(x, y) / Var(x)\n        # Numerator: sum of cross-products of deviations from mean\n        numerator = np.sum((x - x_bar) * (y - y_bar))\n        # Denominator: sum of squared deviations from mean for x\n        denominator = np.sum((x - x_bar)**2)\n        \n        # Handle the edge case of T=2 where the fit is perfect but division by zero could occur if x values were identical.\n        # The problem validation confirmed this is not an issue for the given test cases.\n        beta_hat = numerator / denominator\n\n        # Calculate the OLS estimator for alpha (intercept)\n        # alpha_hat = y_bar - beta_hat * x_bar\n        alpha_hat = y_bar - beta_hat * x_bar\n\n        results.append([alpha_hat, beta_hat])\n\n    # Format the final output string exactly as required.\n    # The format [v1,v2] does not have a space after the comma.\n    # Using f-strings with a format specifier ensures exactly six decimal places.\n    formatted_results = []\n    for alpha, beta in results:\n        formatted_results.append(f\"[{alpha:.6f},{beta:.6f}]\")\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"}, {"introduction": "尽管OLS是一种强大的工具，但其有效性依赖于几个关键假设，例如误差项中不存在自相关。在金融时间序列中，这一假设常常被违背。本练习模拟了CAPM残差存在自相关的数据，要求您运用统计检验来发现这一问题，并通过计算Newey-West稳健标准误来进行修正。这项实践将使您掌握关键的计量经济学技能，以便在模型的理想化假设难以满足时，仍能对真实的金融数据进行稳健分析。[@problem_id:2378979]", "id": "2378979", "problem": "您的任务是通过估计单个资产的截距和斜率参数并评估残差的自相关性，来评估资本资产定价模型 (CAPM) 的有效性。考虑由 CAPM 方程定义的超额收益模型\n$$\ny_t = \\alpha + \\beta m_t + \\varepsilon_t,\n$$\n其中 $y_t$ 是资产在时间 $t$ 的超额收益，$m_t$ 是市场在时间 $t$ 的超额收益，$\\alpha$ 是截距，$\\beta$ 是市场载荷，而 $\\varepsilon_t$ 是误差项。所有收益率必须以小数形式解释。\n\n对于下文指定的每个测试用例，您必须模拟 $\\{m_t\\}_{t=1}^T$ 和 $\\{\\varepsilon_t\\}_{t=1}^T$ 的过程，构建 $\\{y_t\\}_{t=1}^T$，然后：\n1. 使用一个包含一列1和观测到的 $m_t$ 的 $T \\times 2$ 回归变量矩阵 $X$，通过普通最小二乘法估计 $\\alpha$ 和 $\\beta$。\n2. 基于样本残差自相关系数 $\\{\\hat{r}_k\\}_{k=1}^h$，使用具有 $h$ 个自由度的大样本卡方检验，检验残差 $\\{\\hat{\\varepsilon}_t\\}$ 在滞后 $h$ 期内不具有自相关的原假设。\n3. 计算 $\\alpha$ 和 $\\beta$ 的常规普通最小二乘法标准误。\n4. 使用 Bartlett 核和截断滞后期 $L$，计算 $\\alpha$ 和 $\\beta$ 的 Newey–West 异方差自相关稳健标准误。\n\n所有模拟都必须为每个测试用例使用带有指定种子的确定性伪随机数生成器。对于每个测试用例，根据以下通用数据生成过程进行模拟。市场超额收益 $\\{m_t\\}$ 服从\n$$\nm_t = \\mu_m + \\phi_m m_{t-1} + \\sigma_m z_t, \\quad m_0 = 0,\n$$\n而异质性成分 $\\{u_t\\}$ 服从\n$$\nu_t = \\rho\\, u_{t-1} + \\sigma_\\varepsilon w_t, \\quad u_0 = 0,\n$$\n其中 $z_t$ 和 $w_t$ 是独立同分布的标准正态冲击，在时间 $t$ 上和序列之间均独立。CAPM 误差指定为\n$$\n\\varepsilon_t =\n\\begin{cases}\nu_t, & \\text{如果 } \\kappa = 0,\\\\\n\\left(1 + \\kappa \\lvert m_t \\rvert \\right) u_t, & \\text{如果 } \\kappa > 0.\n\\end{cases}\n$$\n观测到的资产超额收益则为 $y_t = \\alpha + \\beta m_t + \\varepsilon_t$。在所有测试用例中，无风险利率恒为零。\n\n为保证可复现性，冲击的生成顺序必须固定：对于从 1 到 $T$ 的每个 $t$，首先抽取 $z_t$ 来更新 $m_t$，然后抽取 $w_t$ 来更新 $u_t$，最后构成 $\\varepsilon_t$ 和 $y_t$。在生成任何冲击之前，必须使用每个测试用例中指定的精确种子来初始化伪随机数生成器，并且所有随机数的抽取都必须按所述顺序使用该单一生成器。\n\n使用以下参数值的测试套件，这些参数值共同检验了典型、边界和极端情况下的行为。在每种情况下，所有参数都是小数单位的标量，且 $\\mu_m = 0$。\n\n- 情况 A (理想路径，无残差自相关): $T = 500$, $\\alpha = 0.001$, $\\beta = 1.2$, $\\phi_m = 0.1$, $\\sigma_m = 0.04$, $\\rho = 0$, $\\sigma_\\varepsilon = 0.02$, $\\kappa = 0$, $h = 4$, $L = 4$, 种子 $= 20240514$。\n- 情况 B (强残差自相关): $T = 500$, $\\alpha = 0.001$, $\\beta = 1.2$, $\\phi_m = 0.1$, $\\sigma_m = 0.04$, $\\rho = 0.6$, $\\sigma_\\varepsilon = 0.02$, $\\kappa = 0$, $h = 4$, $L = 4$, 种子 $= 20240515$。\n- 情况 C (小样本，中等程度自相关): $T = 60$, $\\alpha = 0.001$, $\\beta = 1.2$, $\\phi_m = 0.2$, $\\sigma_m = 0.05$, $\\rho = 0.5$, $\\sigma_\\varepsilon = 0.02$, $\\kappa = 0$, $h = 4$, $L = 4$, 种子 $= 20240516$。\n- 情况 D (异方差和自相关误差): $T = 500$, $\\alpha = 0.001$, $\\beta = 1.2$, $\\phi_m = 0.1$, $\\sigma_m = 0.04$, $\\rho = 0.3$, $\\sigma_\\varepsilon = 0.02$, $\\kappa = 0.8$, $h = 4$, $L = 4$, 种子 $= 20240517$。\n\n您的程序必须为每种情况计算并按此确切顺序输出以下七个值：估计的 $\\alpha$，估计的 $\\beta$，$\\alpha$ 的普通最小二乘法标准误，$\\beta$ 的普通最小二乘法标准误，$\\alpha$ 的 Newey–West 标准误，$\\beta$ 的 Newey–West 标准误，以及一个布尔值，该值表明在 $0.05$ 的显著性水平下，滞后 $h$ 期内无自相关的原假设是否被拒绝。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个列表，按上述顺序包含相应测试用例的结果，所有浮点值均四舍五入到六位小数。例如，总体格式必须为\n$$\n\\left[ [\\alpha_1,\\beta_1,se^{\\mathrm{OLS}}_{\\alpha,1},se^{\\mathrm{OLS}}_{\\beta,1},se^{\\mathrm{NW}}_{\\alpha,1},se^{\\mathrm{NW}}_{\\beta,1},\\mathrm{Reject}_1], \\ldots \\right].\n$$", "solution": "所提出的问题是计算计量经济学中一个形式完备的练习，具体涉及资本资产定价模型 (CAPM) 的估计。它要求在关于误差结构的不同假设下模拟金融时间序列数据，然后估计模型参数并对估计量的属性进行严格评估。该问题在科学上是合理的，说明详尽且客观。我们将遵循原理给出一个详细的解决方案。\n\nCAPM 指定了资产超额收益 $y_t$ 与市场超额收益 $m_t$ 之间的线性关系：\n$$\ny_t = \\alpha + \\beta m_t + \\varepsilon_t\n$$\n其中 $t = 1, \\dots, T$ 是时间索引。参数 $\\alpha$ 是资产的“阿尔法”，代表无法被市场解释的超额收益。参数 $\\beta$ 是“贝塔”，衡量资产对市场变动的敏感度。$\\varepsilon_t$ 项是异质性误差。\n\n首要任务是根据所提供的数据生成过程 (DGP) 模拟时间序列 $\\{y_t\\}_{t=1}^T$ 和 $\\{m_t\\}_{t=1}^T$。对于每个测试用例，我们必须严格遵守指定的参数和随机数生成器种子。\n\n市场超额收益 $\\{m_t\\}$ 由一个一阶自回归过程 AR(1) 生成：\n$$\nm_t = \\phi_m m_{t-1} + \\sigma_m z_t, \\quad \\text{with } m_0 = 0\n$$\n其中 $\\{z_t\\}$ 是一个独立同分布 (i.i.d.) 的标准正态随机变量序列。\n\nCAPM 误差项 $\\{\\varepsilon_t\\}$ 由一个基础 AR(1) 过程 $\\{u_t\\}$ 构建：\n$$\nu_t = \\rho u_{t-1} + \\sigma_\\varepsilon w_t, \\quad \\text{with } u_0 = 0\n$$\n其中 $\\{w_t\\}$ 是另一个独立同分布的标准正态序列，且独立于 $\\{z_t\\}$。$\\varepsilon_t$ 的结构允许条件异方差：\n$$\n\\varepsilon_t =\n\\begin{cases}\nu_t, & \\text{如果 } \\kappa = 0 \\text{ (同方差)},\\\\\n\\left(1 + \\kappa \\lvert m_t \\rvert \\right) u_t, & \\text{如果 } \\kappa > 0 \\text{ (异方差)}.\n\\end{cases}\n$$\n当 $\\kappa > 0$ 时，误差项的方差取决于市场收益的绝对值，这是金融数据中的一个共同特征。\n\n利用模拟出的数据，我们执行以下估计和检验。\n\n**1. 普通最小二乘法 (OLS) 估计**\n我们使用 OLS 估计参数 $\\alpha$ 和 $\\beta$。我们定义参数向量 $\\theta = [\\alpha, \\beta]^T$，因变量向量 $y = [y_1, \\dots, y_T]^T$，以及回归变量矩阵 $X$。$X$ 是一个 $T \\times 2$ 的矩阵，包含一列 1 和一列市场收益 $\\{m_t\\}$。\n$$\nX = \\begin{bmatrix} 1 & m_1 \\\\ 1 & m_2 \\\\ \\vdots & \\vdots \\\\ 1 & m_T \\end{bmatrix}\n$$\nOLS 估计量 $\\hat{\\theta} = [\\hat{\\alpha}, \\hat{\\beta}]^T$ 由以下著名公式给出：\n$$\n\\hat{\\theta} = (X^T X)^{-1} X^T y\n$$\n\n**2. OLS 标准误**\n在经典 OLS 假设（包括同方差且无自相关的误差，即 $\\mathbb{E}[\\varepsilon \\varepsilon^T | X] = \\sigma^2 I_T$）下，估计量 $\\hat{\\theta}$ 的协方差矩阵为：\n$$\n\\text{Var}_{\\text{OLS}}(\\hat{\\theta}) = \\sigma^2 (X^T X)^{-1}\n$$\n误差方差 $\\sigma^2$ 是未知的，通过残差 $\\hat{\\varepsilon}_t = y_t - \\hat{\\alpha} - \\hat{\\beta} m_t$ 进行估计。$\\sigma^2$ 的无偏估计量为：\n$$\n\\hat{\\sigma}^2 = \\frac{1}{T-k} \\sum_{t=1}^T \\hat{\\varepsilon}_t^2\n$$\n其中 $k=2$ 是回归变量的数量。估计的协方差矩阵则为 $\\widehat{\\text{Var}}_{\\text{OLS}}(\\hat{\\theta}) = \\hat{\\sigma}^2 (X^T X)^{-1}$。$\\hat{\\alpha}$ 和 $\\hat{\\beta}$ 的标准误是该矩阵对角线元素的平方根。\n\n**3. 残差自相关性检验**\n为检验无自相关假设的有效性，我们使用基于残差样本自相关系数的大样本检验。我们将采用 Ljung-Box Q 检验。原假设为 $H_0: r_1 = r_2 = \\dots = r_h = 0$，其中 $r_k$ 是滞后 $k$ 期的总体自相关系数。检验统计量为：\n$$\nQ = T(T+2) \\sum_{k=1}^h \\frac{\\hat{r}_k^2}{T-k}\n$$\n其中 $\\hat{r}_k$ 是滞后 $k$ 期的残差样本自相关系数。在原假设下，$Q$ 服从自由度为 $h$ 的卡方分布，即 $Q \\sim \\chi^2(h)$。如果计算出的 $Q$ 统计量超过 $\\chi^2(h)$ 分布的第 95 百分位数，我们就在 $0.05$ 的显著性水平上拒绝 $H_0$。\n\n**4. Newey–West (HAC) 标准误**\n当误差 $\\{\\varepsilon_t\\}$ 存在异方差和/或自相关时，OLS 标准误是不一致的。我们必须使用异方差和自相关稳健 (HAC) 协方差矩阵估计量。Newey-West 估计量是一个常用选择。$\\hat{\\theta}$ 的 HAC 协方差矩阵具有“三明治”形式：\n$$\n\\text{Var}_{\\text{NW}}(\\hat{\\theta}) = (X^T X)^{-1} \\hat{S} (X^T X)^{-1}\n$$\n此处，$\\hat{S}$ 是得分向量 $g_t = X_t \\varepsilon_t$ 的长期方差的估计量，其中 $X_t = [1, m_t]^T$。$\\hat{S}$ 的 Newey-West 估计量为：\n$$\n\\hat{S} = \\sum_{t=1}^T g_t g_t^T + \\sum_{j=1}^L w_j \\sum_{t=j+1}^T (g_t g_{t-j}^T + g_{t-j} g_t^T)\n$$\n其中 $g_t = X_t \\hat{\\varepsilon}_t$。问题指定了 Bartlett 核，其权重 $w_j$ 由 $w_j = 1 - \\frac{j}{L+1}$ 给出，而 $L$ 是截断滞后期。$\\hat{\\alpha}$ 和 $\\hat{\\beta}$ 的 Newey-West 标准误是最终得到的 $\\widehat{\\text{Var}}_{\\text{NW}}(\\hat{\\theta})$ 矩阵对角线元素的平方根。\n\n以下 Python 程序为每个指定的测试用例实现了这一完整过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.stats\n\ndef process_case(T, alpha, beta, phi_m, sigma_m, rho, sigma_eps, kappa, h, L, seed):\n    \"\"\"\n    Simulates time series data, estimates CAPM parameters, and computes standard errors.\n\n    Args:\n        T (int): Number of time periods.\n        alpha (float): True alpha.\n        beta (float): True beta.\n        phi_m (float): AR(1) coefficient for market return.\n        sigma_m (float): Volatility of market return shock.\n        rho (float): AR(1) coefficient for idiosyncratic error component.\n        sigma_eps (float): Volatility of idiosyncratic error shock.\n        kappa (float): Heteroskedasticity parameter.\n        h (int): Lag length for autocorrelation test.\n        L (int): Truncation lag for Newey-West estimator.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing estimated alpha, beta, OLS standard errors,\n              Newey-West standard errors, and autocorrelation test result.\n    \"\"\"\n    # 1. Data Generation\n    rng = np.random.default_rng(seed)\n    \n    m = np.zeros(T)\n    u = np.zeros(T)\n    eps = np.zeros(T)\n    y = np.zeros(T)\n\n    m_prev = 0.0\n    u_prev = 0.0\n    mu_m = 0.0 # As specified in the problem\n\n    for t in range(T):\n        z_t = rng.standard_normal()\n        w_t = rng.standard_normal()\n\n        # Market return process\n        m[t] = mu_m + phi_m * m_prev + sigma_m * z_t\n        m_prev = m[t]\n\n        # Idiosyncratic component process\n        u[t] = rho * u_prev + sigma_eps * w_t\n        u_prev = u[t]\n\n        # CAPM error term\n        if kappa == 0:\n            eps[t] = u[t]\n        else:\n            eps[t] = (1 + kappa * np.abs(m[t])) * u[t]\n        \n        # Asset excess return\n        y[t] = alpha + beta * m[t] + eps[t]\n\n    # 2. OLS Estimation\n    X = np.vstack([np.ones(T), m]).T\n    k = X.shape[1]\n    \n    try:\n        XTX_inv = np.linalg.inv(X.T @ X)\n    except np.linalg.LinAlgError:\n        # Handle cases of perfect multicollinearity, though unlikely here\n        return [np.nan] * 7\n\n    theta_hat = XTX_inv @ X.T @ y\n    alpha_hat, beta_hat = theta_hat[0], theta_hat[1]\n\n    # 3. OLS Standard Errors\n    residuals = y - X @ theta_hat\n    sigma2_hat = np.sum(residuals**2) / (T - k)\n    var_cov_ols = sigma2_hat * XTX_inv\n    se_alpha_ols = np.sqrt(var_cov_ols[0, 0])\n    se_beta_ols = np.sqrt(var_cov_ols[1, 1])\n\n    # 4. Residual Autocorrelation Test (Ljung-Box)\n    res_var = np.sum(residuals**2) / T\n    q_stat = 0.0\n    for j in range(1, h + 1):\n        # Sample autocovariance at lag j\n        res_acov_j = np.sum(residuals[j:] * residuals[:-j]) / T\n        # Sample autocorrelation at lag j\n        res_acor_j = res_acov_j / res_var\n        q_stat += (res_acor_j**2) / (T - j)\n        \n    q_stat *= T * (T + 2)\n    \n    chi2_crit_val = scipy.stats.chi2.ppf(0.95, df=h)\n    reject_h0 = q_stat > chi2_crit_val\n\n    # 5. Newey-West HAC Standard Errors\n    g = X * residuals[:, np.newaxis]  # T x k matrix of scores\n    \n    S_hat = g.T @ g\n    \n    for j in range(1, L + 1):\n        weight = 1.0 - j / (L + 1.0)\n        gamma_j = g[j:].T @ g[:-j]\n        S_hat += weight * (gamma_j + gamma_j.T)\n        \n    var_cov_nw = XTX_inv @ S_hat @ XTX_inv\n    se_alpha_nw = np.sqrt(var_cov_nw[0, 0])\n    se_beta_nw = np.sqrt(var_cov_nw[1, 1])\n\n    # 6. Collate and return results\n    return [alpha_hat, beta_hat, se_alpha_ols, se_beta_ols, se_alpha_nw, se_beta_nw, reject_h0]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # T, alpha, beta, phi_m, sigma_m, rho, sigma_eps, kappa, h, L, seed\n        (500, 0.001, 1.2, 0.1, 0.04, 0.0, 0.02, 0.0, 4, 4, 20240514), # Case A\n        (500, 0.001, 1.2, 0.1, 0.04, 0.6, 0.02, 0.0, 4, 4, 20240515), # Case B\n        (60, 0.001, 1.2, 0.2, 0.05, 0.5, 0.02, 0.0, 4, 4, 20240516),  # Case C\n        (500, 0.001, 1.2, 0.1, 0.04, 0.3, 0.02, 0.8, 4, 4, 20240517), # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Format output string without extra spaces, rounding floats to 6 places\n    list_of_strings = []\n    for res_list in results:\n        inner_str_list = []\n        for item in res_list:\n            if isinstance(item, (float, np.floating)):\n                inner_str_list.append(f\"{item:.6f}\")\n            else:\n                inner_str_list.append(str(item))\n        inner_str = ','.join(inner_str_list)\n        list_of_strings.append(f\"[{inner_str}]\")\n    \n    final_output_str = f\"[{','.join(list_of_strings)}]\"\n    print(final_output_str)\n\nsolve()\n```"}, {"introduction": "产生点估计和置信区间的频率派方法并非进行统计推断的唯一途径。贝叶斯框架为融合先验知识和描述不确定性提供了一种强大的替代方案。这项高级实践将挑战您使用贝叶斯回归来估计CAPM参数，并将得到的后验分布与我们所熟悉的频率派置信区间进行比较。通过接触这两种范式，您将对统计推断产生更为细致的理解，并领会如何运用不同的哲学方法来分析同一个模型。[@problem_id:2379015]", "id": "2379015", "problem": "您需要从第一性原理出发，实现一个完整的计算流程，使用频率派和贝叶斯两种方法来估计资本资产定价模型 (CAPM) 的斜率参数，然后将斜率的后验分布与频率派的置信区间进行比较。单个资产超额收益的资本资产定价模型 (CAPM) 可以写成一个线性回归：对于每个时间指数 $t \\in \\{1,\\dots,n\\}$，资产超额收益 $y_t$ 满足 $y_t = \\alpha + \\beta x_t + \\varepsilon_t$，其中 $x_t$ 是市场超额收益，$\\alpha$ 是截距，$\\beta$ 是斜率 (系统性风险)，$\\varepsilon_t$ 是独立同分布的误差，满足 $E[\\varepsilon_t]=0$ 和 $Var(\\varepsilon_t)=\\sigma^2$。您将需要：\n- 通过普通最小二乘法 (OLS) 估计 $\\beta$，并使用具有 $n-2$ 自由度的有限样本 $t$ 分布构建双侧 $95$ 置信区间。\n- 在使用共轭正态-逆伽马 (NIG) 先验的贝叶斯回归下估计 $\\beta$。令 $\\theta = (\\alpha,\\beta)'$。先验指定为 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_0, d_0)$ 且 $\\theta \\mid \\sigma^2 \\sim \\mathcal{N}(b_0,\\ \\sigma^2 V_0)$，其中 $b_0 \\in \\mathbb{R}^2$ 且 $V_0 \\in \\mathbb{R}^{2 \\times 2}$ 是正定矩阵。使用贝叶斯定理、高斯似然和此共轭先验来获得后验分布，然后进行边缘化以获得 $\\beta$ 的后验分布。\n- 计算 $\\beta$ 落在频率派 $95\\%$ 置信区间内的后验概率。将此概率表示为 $[0,1]$ 范围内的小数。\n\n您的程序必须：\n1) 针对下面列出的每个测试用例，在 CAPM 数据生成过程下模拟数据 $(x_t,y_t)$，每个用例使用固定的伪随机种子以保证可复现性。具体来说，对于 $t=1,\\dots,n$，独立地生成 $x_t \\sim \\mathcal{N}(\\mu_x,\\sigma_x)$ 和独立地生成 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$，然后设置 $y_t = \\alpha + \\beta x_t + \\sigma \\varepsilon_t$。本问题中没有物理单位。\n2) 对于每个用例，计算：\n   - 使用具有 $n-2$ 自由度的 $t$ 分布和同方差性下的精确有限样本 OLS 标准误，计算 $\\beta$ 的 OLS 估计值及其双侧 $95\\%$ 置信区间。\n   - 在正态-逆伽马先验下得到 $\\beta$ 的贝叶斯后验。使用贝叶斯定理对高斯线性模型所隐含的共轭更新。然后，从后验中获得 $\\beta$ 的边缘分布，并计算 $\\beta$ 落在 OLS 置信区间内的后验概率。\n3) 针对三个测试用例，输出一行内容，该行包含一个列表，内含三个浮点数，分别等于上述三个后验概率，并按测试用例的顺序排列。将每个浮点数四舍五入到小数点后 $6$ 位。最后一行必须严格采用 $[p_1,p_2,p_3]$ 的格式，其中每个 $p_i$ 是小数点后有 $6$ 位数字的小数，且无多余空格。\n\n您可以假定的基本原理：\n- 带有高斯误差的线性回归在同方差性条件下，其 OLS 估计量即为最大似然估计量，并且系数的线性组合在有限样本中具有基于 $t$ 分布的精确抽样分布。\n- 对于带有正态-逆伽马先验的高斯线性模型，贝叶斯定理会产生一个正态-逆伽马后验，在积分掉 $\\sigma^2$ 后，系数的边缘分布为多元学生-$t$ 分布。\n\n测试套件：\n- 用例 $1$ (理想路径，弱先验，中等样本): 种子 $=12345$, $n=60$, 真实 $\\alpha=0.002$, 真实 $\\beta=1.1$, $\\sigma=0.04$, $\\mu_x=0.006$, $\\sigma_x=0.045$, $b_0=\\begin{bmatrix}0\\\\ 1.0\\end{bmatrix}$, $V_0=\\text{diag}(10^6,10^6)$, $a_0=10^{-6}$, $d_0=10^{-6}$。\n- 用例 $2$ (小样本，强先验): 种子 $=2024$, $n=8$, 真实 $\\alpha=0.001$, 真实 $\\beta=0.8$, $\\sigma=0.05$, $\\mu_x=0.004$, $\\sigma_x=0.05$, $b_0=\\begin{bmatrix}0\\\\ 1.0\\end{bmatrix}$, $V_0=\\text{diag}(0.01,0.01)$, $a_0=5$, $d_0=0.002$。\n- 用例 $3$ (较高噪声，中等强度先验): 种子 $=777$, $n=40$, 真实 $\\alpha=0.0$, 真实 $\\beta=1.3$, $\\sigma=0.08$, $\\mu_x=0.005$, $\\sigma_x=0.06$, $b_0=\\begin{bmatrix}0\\\\ 1.2\\end{bmatrix}$, $V_0=\\text{diag}(0.1,0.1)$, $a_0=3$, $d_0=0.0064$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表内是三个后验概率，每个概率四舍五入到小数点后 6 位，无多余空格，例如：$[0.952381,0.843211,0.901337]$。", "solution": "本问题要求对资本资产定价模型 (CAPM) 的斜率参数 $\\beta$ 进行频率派估计和贝叶斯估计的比较分析。问题定义清晰，科学上合理，并提供了所有必要信息。我们将以严谨的、分步的方式进行求解。\n\nCAPM 被表述为一个基于市场超额收益 $x_t$ 来解释资产超额收益 $y_t$ 的简单线性回归模型：\n$$y_t = \\alpha + \\beta x_t + \\varepsilon_t, \\quad t=1, \\dots, n$$\n其中 $\\varepsilon_t$ 是独立同分布的误差项，满足 $E[\\varepsilon_t]=0$ 和 $Var(\\varepsilon_t)=\\sigma^2$。用矩阵表示为 $y = X\\theta + \\varepsilon$，其中 $y$ 是一个 $n \\times 1$ 的收益向量，$X$ 是一个 $n \\times 2$ 的设计矩阵，第一列为全1，第二列为 $x_t$ 的值，$\\theta = (\\alpha, \\beta)'$ 是 $2 \\times 1$ 的参数向量。\n\n针对每个测试用例，解决方案包括三个阶段：\n1.  根据指定的数据生成过程模拟数据 $(x_t, y_t)$。\n2.  使用普通最小二乘法 (OLS) 估计 $\\beta$ 并推导其 $95\\%$ 置信区间。\n3.  使用带有共轭正态-逆伽马先验的贝叶斯方法估计 $\\beta$，找到 $\\beta$ 的边缘后验分布，然后计算 $\\beta$ 落在 OLS 置信区间内的后验概率。\n\n**步骤 1：数据生成**\n\n对于每个测试用例，我们使用提供的随机数生成器种子以确保可复现性。我们从正态分布 $x_t \\sim \\mathcal{N}(\\mu_x, \\sigma_x^2)$ 中生成 $n$ 个独立样本作为市场超额收益 $x_t$。然后，我们生成 $n$ 个独立的标准正态新息 $z_t \\sim \\mathcal{N}(0, 1)$。接着，使用真实的模型参数 ($\\alpha_{\\text{true}}, \\beta_{\\text{true}}, \\sigma_{\\text{true}}$) 构建资产超额收益 $y_t$：\n$$y_t = \\alpha_{\\text{true}} + \\beta_{\\text{true}} x_t + \\sigma_{\\text{true}} z_t$$\n这确保了误差项 $\\varepsilon_t = \\sigma_{\\text{true}} z_t$ 满足模型假设，特别是 $E[\\varepsilon_t]=0$ 和 $Var(\\varepsilon_t) = \\sigma_{\\text{true}}^2 Var(z_t) = \\sigma_{\\text{true}}^2$。\n\n**步骤 2：频率派估计 (普通最小二乘法)**\n\n给定数据 $(y, X)$ 并假设误差为高斯分布，OLS 估计量提供了 $\\theta$ 的最大似然估计：\n$$\\hat{\\theta}_{OLS} = (X'X)^{-1}X'y$$\n这给出了估计值 $\\hat{\\alpha}$ 和 $\\hat{\\beta}$。误差方差 $\\sigma^2$ 的一个无偏估计量是：\n$$\\hat{\\sigma}^2 = \\frac{e'e}{n-2}$$\n其中 $e = y - X\\hat{\\theta}_{OLS}$ 是残差向量。OLS 估计量的协方差矩阵估计为：\n$$\\widehat{Var}(\\hat{\\theta}_{OLS}) = \\hat{\\sigma}^2(X'X)^{-1}$$\n$\\hat{\\beta}$ 的标准误是该矩阵第二个对角元素的平方根：\n$$se(\\hat{\\beta}) = \\sqrt{[\\widehat{Var}(\\hat{\\theta}_{OLS})]_{2,2}}$$\n在模型假设下，$\\frac{\\hat{\\beta} - \\beta}{se(\\hat{\\beta})}$ 服从自由度为 $n-2$ 的学生 $t$ 分布。这允许构建一个精确的有限样本置信区间。$\\beta$ 的双侧 $95\\%$ 置信区间由下式给出：\n$$CI_{95\\%} = \\left[ \\hat{\\beta} - t_{n-2, 0.975} \\cdot se(\\hat{\\beta}), \\quad \\hat{\\beta} + t_{n-2, 0.975} \\cdot se(\\hat{\\beta}) \\right]$$\n其中 $t_{n-2, 0.975}$ 是自由度为 $n-2$ 的 $t$ 分布的上临界值，其使得上尾概率为 $2.5\\%$。\n\n**步骤 3：贝叶斯估计与最终概率**\n\n贝叶斯框架包含了关于参数的先验信念，这些信念通过贝叶斯定理用数据进行更新。指定的先验是 $(\\theta, \\sigma^2)$ 的正态-逆伽马 (NIG) 分布，它是高斯线性模型的共轭先验。这意味着后验分布也将属于 NIG 族。\n\n先验指定为：\n$$p(\\theta, \\sigma^2) = p(\\theta | \\sigma^2) p(\\sigma^2)$$\n$$\\sigma^2 \\sim \\text{Inverse-Gamma}(a_0, d_0)$$\n$$\\theta | \\sigma^2 \\sim \\mathcal{N}(b_0, \\sigma^2 V_0)$$\n其中 $a_0, d_0, b_0, V_0$ 是超参数。\n\n数据的似然由下式给出：\n$$p(y|X, \\theta, \\sigma^2) \\propto (\\sigma^2)^{-n/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(y-X\\theta)'(y-X\\theta)\\right)$$\n应用贝叶斯定理，后验 $p(\\theta, \\sigma^2 | y, X) \\propto p(y|X, \\theta, \\sigma^2) p(\\theta, \\sigma^2)$ 是一个具有更新后参数 $(a_n, d_n, b_n, V_n)$ 的正态-逆伽马分布：\n$$a_n = a_0 + \\frac{n}{2}$$\n$$V_n = (V_0^{-1} + X'X)^{-1}$$\n$$b_n = V_n(V_0^{-1}b_0 + X'y)$$\n$$d_n = d_0 + \\frac{1}{2}\\left(y'y + b_0'V_0^{-1}b_0 - b_n'(V_0^{-1} + X'X)b_n\\right)$$\n\n为了与 $\\beta$ 的频率派结果进行比较，我们必须找到其边缘后验分布。从联合后验中对 $\\sigma^2$进行积分，可以得到 $\\theta$ 的多元学生 $t$ 分布：\n$$\\theta | y, X \\sim t_{2a_n}\\left(b_n, \\frac{d_n}{a_n}V_n\\right)$$\n因此，斜率参数 $\\beta$（$\\theta$ 的第二个分量）的边缘后验是一个广义学生 $t$ 分布。其标准化形式是一个标准学生 $t$ 变量：\n$$\\frac{\\beta - [b_n]_2}{\\sqrt{\\frac{d_n}{a_n}[V_n]_{2,2}}} \\sim t_{2a_n}$$\n令 $\\mu_\\beta = [b_n]_2$ 为后验位置（均值），$s_\\beta = \\sqrt{\\frac{d_n}{a_n}[V_n]_{2,2}}$ 为后验尺度，$\\nu_\\beta = 2a_n$ 为自由度。\n\n最后的任务是计算 $\\beta$ 落在频率派 $95\\%$ 置信区间 $[CI_{low}, CI_{high}]$ 内的后验概率。这可以使用标准学生 $t$ 分布的累积分布函数 (CDF) $F_{t_{\\nu_\\beta}}$ 来计算：\n$$P(\\beta \\in [CI_{low}, CI_{high}] | y, X) = F_{t_{\\nu_\\beta}}\\left(\\frac{CI_{high} - \\mu_\\beta}{s_\\beta}\\right) - F_{t_{\\nu_\\beta}}\\left(\\frac{CI_{low} - \\mu_\\beta}{s_\\beta}\\right)$$\n\n该过程对指定的三个测试用例中的每一个都进行实施，产生三个概率，这些概率构成了最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Main function to run the CAPM estimation pipeline for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"seed\": 12345, \"n\": 60, \"true_alpha\": 0.002, \"true_beta\": 1.1, \"sigma\": 0.04,\n            \"mu_x\": 0.006, \"sigma_x\": 0.045,\n            \"b0\": np.array([[0.0], [1.0]]), \"V0\": np.diag([1e6, 1e6]), \"a0\": 1e-6, \"d0\": 1e-6\n        },\n        {\n            \"name\": \"Case 2\",\n            \"seed\": 2024, \"n\": 8, \"true_alpha\": 0.001, \"true_beta\": 0.8, \"sigma\": 0.05,\n            \"mu_x\": 0.004, \"sigma_x\": 0.05,\n            \"b0\": np.array([[0.0], [1.0]]), \"V0\": np.diag([0.01, 0.01]), \"a0\": 5.0, \"d0\": 0.002\n        },\n        {\n            \"name\": \"Case 3\",\n            \"seed\": 777, \"n\": 40, \"true_alpha\": 0.0, \"true_beta\": 1.3, \"sigma\": 0.08,\n            \"mu_x\": 0.005, \"sigma_x\": 0.06,\n            \"b0\": np.array([[0.0], [1.2]]), \"V0\": np.diag([0.1, 0.1]), \"a0\": 3.0, \"d0\": 0.0064\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = frequentist_vs_bayesian_capm(**case)\n        results.append(f\"{p:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef frequentist_vs_bayesian_capm(name, seed, n, true_alpha, true_beta, sigma, mu_x, sigma_x, b0, V0, a0, d0):\n    \"\"\"\n    Executes the full pipeline for a single test case.\n    1. Simulates data.\n    2. Performs OLS estimation and computes the confidence interval for beta.\n    3. Performs Bayesian estimation and computes the posterior probability of beta\n       lying in the OLS confidence interval.\n    \"\"\"\n    # 1. Simulate data\n    rng = np.random.default_rng(seed)\n    x = rng.normal(mu_x, sigma_x, n)\n    eps = rng.normal(0, 1, n)\n    y = true_alpha + true_beta * x + sigma * eps\n\n    # Reshape for matrix operations\n    y = y.reshape(-1, 1)\n    X = np.vstack([np.ones(n), x]).T\n\n    # 2. Frequentist (OLS) Estimation\n    # OLS coefficient estimates: theta_hat = (X'X)^-1 * X'y\n    XTX = X.T @ X\n    XTX_inv = np.linalg.inv(XTX)\n    XTY = X.T @ y\n    theta_hat = XTX_inv @ XTY\n    beta_hat = theta_hat[1, 0]\n\n    # OLS variance estimate and standard errors\n    residuals = y - X @ theta_hat\n    sigma2_hat = (residuals.T @ residuals) / (n - 2)\n    cov_theta_hat = sigma2_hat[0, 0] * XTX_inv\n    se_beta = np.sqrt(cov_theta_hat[1, 1])\n\n    # 95% Confidence Interval for beta\n    df_ols = n - 2\n    t_crit = t.ppf(0.975, df=df_ols)\n    ci_low = beta_hat - t_crit * se_beta\n    ci_high = beta_hat + t_crit * se_beta\n\n    # 3. Bayesian Estimation\n    # Posterior parameters for Normal-Inverse-Gamma\n    V0_inv = np.linalg.inv(V0)\n    Vn_inv = V0_inv + XTX\n    Vn = np.linalg.inv(Vn_inv)\n    bn = Vn @ (V0_inv @ b0 + XTY)\n    \n    an = a0 + n / 2.0\n    \n    # Use the more direct formula for dn\n    # dn = d0 + 0.5 * (y'y + b0'V0_inv*b0 - bn'Vn_inv*bn)\n    term1 = y.T @ y\n    term2 = b0.T @ V0_inv @ b0\n    term3 = bn.T @ Vn_inv @ bn\n    dn = d0 + 0.5 * (term1 + term2 - term3)\n    dn = dn[0, 0] # Ensure scalar\n\n    # Marginal posterior for beta (Student-t)\n    df_bayes = 2 * an\n    # Location (mean) of beta's posterior\n    _mu_beta_post = bn[1, 0]\n    # Scale of beta's posterior\n    _s2_beta_post_scaled = (dn / an) * Vn[1, 1]\n    _s_beta_post = np.sqrt(_s2_beta_post_scaled)\n\n    # Calculate posterior probability of beta being in the OLS CI\n    z_low = (ci_low - _mu_beta_post) / _s_beta_post\n    z_high = (ci_high - _mu_beta_post) / _s_beta_post\n    \n    prob = t.cdf(z_high, df=df_bayes) - t.cdf(z_low, df=df_bayes)\n\n    return prob\n\nif __name__ == '__main__':\n    solve()\n```"}]}