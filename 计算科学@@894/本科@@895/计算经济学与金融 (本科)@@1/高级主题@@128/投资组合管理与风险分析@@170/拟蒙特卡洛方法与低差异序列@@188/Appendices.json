{"hands_on_practices": [{"introduction": "要理解准蒙特卡洛（QMC）方法的优势，最好的起点是将其与我们熟悉的工具进行直接比较。这个练习将让你通过编码，对比蒙特卡洛（MC）、QMC 和简单的确定性格子方法在数值积分任务中的表现。通过在一个精心选择的高频周期函数上进行测试，你将亲眼见证 QMC 相对于 MC 更快的收敛速度，并揭示确定性格子方法在处理特定结构函数时可能出现的“共振”失效问题 [@problem_id:2424669]。", "id": "2424669", "problem": "考虑定义在 $[0,1]^2$ 上的二元函数 $f:[0,1]^2 \\to \\mathbb{R}$，$f(x,y)=\\cos(20\\pi x)+\\cos(20\\pi y)$，其中余弦函数的参数以弧度为单位。目标是数值近似计算积分\n$$I=\\int_0^1\\int_0^1 f(x,y)\\,dx\\,dy,$$\n比较三种估计量产生的绝对积分误差，并报告一组指定样本量的结果。\n\n对于给定的样本量 $N\\in\\mathbb{N}$，定义以下三种 $I$ 的估计量：\n- 蒙特卡洛（MC, Monte Carlo）：抽取 $N$ 个独立样本 $(X_i,Y_i)$，其中 $(X_i,Y_i)\\sim \\text{Uniform}([0,1]^2)$，并使用估计量\n$$\\widehat{I}_{\\text{MC},N}=\\frac{1}{N}\\sum_{i=1}^N f(X_i,Y_i)。$$\n- 拟蒙特卡洛（QMC, Quasi-Monte Carlo）：使用来自 $[0,1]^2$ 上二维 Sobol 低差异序列（不加扰）的前 $N$ 个点 $(u_i,v_i)$，并使用估计量\n$$\\widehat{I}_{\\text{QMC},N}=\\frac{1}{N}\\sum_{i=1}^N f(u_i,v_i)。$$\n- 均匀网格上的二维黎曼和：假设 $N=n^2$ 且 $n\\in\\mathbb{N}$，构建一个由左端点节点组成的均匀 $n\\times n$ 网格\n$$\\Big\\{\\Big(\\frac{i}{n},\\frac{j}{n}\\Big): i=0,1,\\dots,n-1,\\; j=0,1,\\dots,n-1\\Big\\}。$$\n使用估计量\n$$\\widehat{I}_{\\text{Grid},N}=\\frac{1}{n^2}\\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} f\\Big(\\frac{i}{n},\\frac{j}{n}\\Big)。$$\n\n您的程序必须：\n- 使用由 $f$ 在 $[0,1]^2$ 上的定义所确定的 $I$ 的精确值来计算误差。\n- 对于蒙特卡洛方法，使用固定的伪随机种子 $2025$ 以保证可复现性。\n- 对于拟蒙特卡洛方法，使用不加扰的二维 Sobol 序列，从索引 $0$ 开始，按顺序取前 $N$ 个点。\n- 对于基于网格的黎曼和，仅当 $N$ 是一个完全平方数时才应用它。\n\n对于测试集中的每个 $N$，计算绝对误差\n$$E_{\\text{MC}}(N)=\\big|\\widehat{I}_{\\text{MC},N}-I\\big|,\\quad E_{\\text{QMC}}(N)=\\big|\\widehat{I}_{\\text{QMC},N}-I\\big|,\\quad E_{\\text{Grid}}(N)=\\big|\\widehat{I}_{\\text{Grid},N}-I\\big|。$$\n\n测试集：\n- $N\\in\\{1,4,25,100,400\\}$，对于网格估计量，这对应于网格尺寸 $n\\in\\{1,2,5,10,20\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表的列表形式的结果。每个内部列表对应测试集中的一个 $N$（按 $N\\in[1,4,25,100,400]$ 的顺序），并包含按 $[E_{\\text{MC}}(N),E_{\\text{QMC}}(N),E_{\\text{Grid}}(N)]$ 固定顺序排列的三个误差。\n- 每个浮点数必须精确打印到小数点后 $8$ 位。\n- 打印的行中不得包含任何空格。\n- 因此，输出形式为单行上的 Python 风格的列表嵌套列表，所有条目均格式化为 $8$ 位小数。", "solution": "所述问题具有科学依据、良定、客观且完整。这是一个计算数学中的标准练习，旨在比较蒙特卡洛、拟蒙特卡洛和确定性网格数值积分方法的性能。所有提供的信息对于得出唯一解都是充分且一致的。因此，该问题是有效的。\n\n目标是对于函数 $f(x,y)=\\cos(20\\pi x)+\\cos(20\\pi y)$，计算积分 $I = \\int_0^1\\int_0^1 f(x,y)\\,dx\\,dy$ 的三种不同数值估计量的绝对积分误差。\n\n首先，我们必须确定积分 $I$ 的精确值。根据积分的线性性，我们可以将积分分离：\n$$I = \\int_0^1\\int_0^1 \\left(\\cos(20\\pi x)+\\cos(20\\pi y)\\right)\\,dx\\,dy = \\int_0^1\\int_0^1 \\cos(20\\pi x)\\,dx\\,dy + \\int_0^1\\int_0^1 \\cos(20\\pi y)\\,dx\\,dy$$\n我们来计算第一项：\n$$ \\int_0^1\\int_0^1 \\cos(20\\pi x)\\,dx\\,dy = \\int_0^1 \\left[ \\frac{\\sin(20\\pi x)}{20\\pi} \\right]_{x=0}^{x=1} \\,dy = \\int_0^1 \\left( \\frac{\\sin(20\\pi \\cdot 1) - \\sin(20\\pi \\cdot 0)}{20\\pi} \\right) \\,dy $$\n由于 $\\sin(20\\pi) = 0$ 且 $\\sin(0) = 0$，内层积分的结果为 $0$。因此，整个第一项为 $\\int_0^1 0 \\,dy = 0$。\n根据对称性，第二项也为零：\n$$ \\int_0^1\\int_0^1 \\cos(20\\pi y)\\,dx\\,dy = \\int_0^1 \\cos(20\\pi y) \\left[ x \\right]_{x=0}^{x=1} \\,dy = \\int_0^1 \\cos(20\\pi y) \\,dy = \\left[ \\frac{\\sin(20\\pi y)}{20\\pi} \\right]_{y=0}^{y=1} = 0 $$\n因此，积分的精确值为 $I = 0 + 0 = 0$。任何估计量 $\\widehat{I}$ 的绝对误差因此就是其绝对值 $E = |\\widehat{I} - I| = |\\widehat{I}|$。\n\n求解过程包括对集合 $\\{1, 4, 25, 100, 400\\}$ 中的每个样本量 $N$ 实现这三种估计量。\n\n1.  **蒙特卡洛（MC）估计量：** 对于每个 $N$，我们生成 $N$ 个在单位正方形 $[0,1]^2$ 中均匀分布的独立随机点 $(X_i, Y_i)$。使用固定种子 $2025$ 的伪随机数生成器以确保可复现性。估计值是函数在这些点上的值的样本均值：\n    $$\\widehat{I}_{\\text{MC},N}=\\frac{1}{N}\\sum_{i=1}^N f(X_i,Y_i)$$\n\n2.  **拟蒙特卡洛（QMC）估计量：** 对于每个 $N$，我们使用二维 Sobol 低差异序列的前 $N$ 个点 $(u_i,v_i)$。这些点是确定性生成的，旨在比伪随机点更均匀地覆盖单位正方形。为确保对每个测试用例都使用“前 $N$ 个点”，我们生成一个所需最大长度（$N=400$）的序列，并对每个 $N$ 使用该序列的相应前缀。估计值是样本均值：\n    $$\\widehat{I}_{\\text{QMC},N}=\\frac{1}{N}\\sum_{i=1}^N f(u_i,v_i)$$\n\n3.  **基于网格的黎曼和估计量：** 该方法应用于 $N=n^2$ 的情况，其中 $n \\in \\{1, 2, 5, 10, 20\\}$。构建一个由点 $(\\frac{i}{n}, \\frac{j}{n})$（其中 $i,j \\in \\{0, 1, \\dots, n-1\\}$）组成的均匀 $n \\times n$ 网格。估计值是函数在该网格上的值的均值：\n    $$\\widehat{I}_{\\text{Grid},N}=\\frac{1}{n^2}\\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} f\\Big(\\frac{i}{n},\\frac{j}{n}\\Big)$$\n    重要的是要分析这个估计量对于给定函数的行为。求和可以简化为：\n    $$\\widehat{I}_{\\text{Grid},N} = \\frac{1}{n^2} \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} \\left( \\cos\\left(\\frac{20\\pi i}{n}\\right) + \\cos\\left(\\frac{20\\pi j}{n}\\right) \\right) = \\frac{2}{n}\\sum_{k=0}^{n-1} \\cos\\left(\\frac{20\\pi k}{n}\\right)$$\n    如果 $10/n$ 是一个整数，那么项 $20\\pi/n$ 就是 $2\\pi$ 的倍数。这对于 $n \\in \\{1, 2, 5, 10\\}$ 成立。对于这些值，每一项 $\\cos(20\\pi k/n) = \\cos(2\\pi \\cdot (\\text{整数}) \\cdot k) = 1$。和为 $n$，估计量变为 $\\widehat{I}_{\\text{Grid},N} = \\frac{2}{n} \\cdot n = 2$。误差为 $|\\widehat{I}_{\\text{Grid},N}| = 2$。\n    对于 $n=20$，参数为 $\\cos(\\pi k)$，求和 $\\sum_{k=0}^{19} \\cos(\\pi k) = 1-1+1-1+\\dots+1-1=0$。估计量及其误差均为 $0$。这个特定的函数选择突显了一种共振现象，即均匀网格的性能可能极差或极好，这取决于它与函数周期性的对齐情况。\n\n程序为每个 $N$ 计算这三种估计值，计算绝对误差，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import qmc\n\ndef solve():\n    \"\"\"\n    Computes and compares absolute integration errors for MC, QMC, and Grid estimators.\n    \"\"\"\n    # The exact value of the integral is I=0.\n    I_exact = 0.0\n\n    # Define the bivariate function to be integrated.\n    def f(x, y):\n        \"\"\"\n        Calculates f(x,y) = cos(20*pi*x) + cos(20*pi*y).\n        x and y can be scalars or numpy arrays.\n        \"\"\"\n        return np.cos(20 * np.pi * x) + np.cos(20 * np.pi * y)\n\n    # Define the test suite for sample sizes N.\n    test_cases = [\n        (1, 1),\n        (4, 2),\n        (25, 5),\n        (100, 10),\n        (400, 20),\n    ]\n\n    seed = 2025\n    rng = np.random.default_rng(seed)\n\n    # Pre-generate all required Sobol points to ensure \"first N\" rule is followed.\n    max_N = test_cases[-1][0]\n    sobol_engine = qmc.Sobol(d=2, scramble=False)\n    all_qmc_points = sobol_engine.random(max_N)\n\n    results = []\n    for N, n in test_cases:\n        # --- 1. Monte Carlo (MC) Estimator ---\n        # Generate N fresh random points for each N.\n        mc_points = rng.random((N, 2))\n        f_values_mc = f(mc_points[:, 0], mc_points[:, 1])\n        I_hat_mc = np.mean(f_values_mc)\n        error_mc = np.abs(I_hat_mc - I_exact)\n\n        # --- 2. Quasi-Monte Carlo (QMC) Estimator ---\n        # Use the first N points from the pre-generated sequence.\n        qmc_points = all_qmc_points[:N]\n        f_values_qmc = f(qmc_points[:, 0], qmc_points[:, 1])\n        I_hat_qmc = np.mean(f_values_qmc)\n        error_qmc = np.abs(I_hat_qmc - I_exact)\n\n        # --- 3. Grid-based Riemann Sum Estimator ---\n        # Generate an n x n grid of left-endpoints.\n        grid_coords = np.arange(n) / n\n        x_grid, y_grid = np.meshgrid(grid_coords, grid_coords)\n        f_values_grid = f(x_grid, y_grid)\n        I_hat_grid = np.mean(f_values_grid)\n        error_grid = np.abs(I_hat_grid - I_exact)\n\n        results.append([error_mc, error_qmc, error_grid])\n\n    # Format the output string according to the specified rules:\n    # A list of lists, with each number formatted to 8 decimal places,\n    # and no spaces in the entire output string.\n    formatted_rows = [\n        f\"[{','.join([f'{err:.8f}' for err in row])}]\"\n        for row in results\n    ]\n    final_output = f\"[{','.join(formatted_rows)}]\"\n\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "在见识了 QMC 的威力后，我们必须探索其应用的边界。QMC 的卓越性能并非无条件的，它尤其依赖于一个被称为“有效维度”的概念。本次实践通过一个巧妙的变量旋转实验，向你展示当一个函数的主要变化方向与坐标轴不一致时，QMC 的优势会如何减弱 [@problem_id:2424673]。这个练习将帮助你理解为何在实际应用中，识别并利用问题的低有效维度结构是成功运用 QMC 的关键。", "id": "2424673", "problem": "您将执行一个基于模拟的积分任务，该任务在一个与计算经济学和金融学相关的场景中，比较标准蒙特卡洛方法和拟蒙特卡洛方法。考虑一个被积函数在多元标准正态分布下的期望，并检验变量的正交旋转如何改变被积函数的轴对齐性，以及当函数是轴对齐时，这种旋转如何消除拟蒙特卡洛方法的典型优势。\n\n设 $d \\in \\mathbb{N}$ 为维度，设 $\\boldsymbol{Z} \\sim \\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 为一个 $d$ 维标准正态随机向量，并设 $\\mathbf{Q} \\in \\mathbb{R}^{d \\times d}$ 为一个满足 $\\mathbf{Q}^\\top \\mathbf{Q} = \\mathbf{I}_d$ 的正交矩阵。定义被积函数\n$$\nf_{\\lambda,\\mathbf{Q}}(\\boldsymbol{z}) = \\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{z})_1\\right),\n$$\n其中 $(\\mathbf{Q}\\boldsymbol{z})_1$ 表示旋转后向量 $\\mathbf{Q}\\boldsymbol{z}$ 的第一个分量，$\\lambda \\in \\mathbb{R}$ 是一个固定的标量。由于多元正态分布在正交变换下是不变的，我们关注的积分为\n$$\nI(\\lambda) = \\mathbb{E}\\!\\left[f_{\\lambda,\\mathbf{Q}}(\\boldsymbol{Z})\\right] = \\mathbb{E}\\!\\left[\\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{Z})_1\\right)\\right] = \\exp\\!\\left(\\tfrac{1}{2}\\lambda^2\\right),\n$$\n该积分不依赖于 $\\mathbf{Q}$。\n\n您的任务是编写一个完整、可运行的程序，以实证方式比较以下两种方法的绝对积分误差：\n- 使用 Sobol 低差异序列，通过标准正态累积分布函数的反函数将其映射到独立标准正态坐标的拟蒙特卡洛方法，以及\n- 使用独立伪随机标准正态抽样的标准蒙特卡洛方法，\n\n针对不同的旋转和混合坐标的正交矩阵 $\\mathbf{Q}$。对标准蒙特卡洛方法使用固定的种子以确保可复现性。对 Sobol 序列使用加扰和固定种子，以避免在进行标准正态反函数映射时出现 $0$ 和 $1$ 的边界问题。\n\n您可以依赖的基本定义包括：期望作为积分的定义，$\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 在正交变换下的不变性，以及通过累积分布函数的反函数将均匀随机变量映射到正态随机变量。除这些之外，不要假设任何未经证明的捷径。\n\n实现要求：\n- 使用 Sobol 序列在 $[0,1]^d$ 中生成 $n$ 个样本点，使用固定的种子对其进行加扰，然后通过标准正态累积分布函数的反函数将它们逐坐标变换到 $\\mathbb{R}^d$，以获得拟蒙特卡洛样本。独立地，使用带有固定种子的伪随机数生成器生成 $n$ 个独立的 $d$ 维标准正态样本。\n- 将正交变换 $\\mathbf{Q}$ 应用于每个 $d$ 维样本，并计算 $f_{\\lambda,\\mathbf{Q}}$。\n- 用每种方法下的样本均值来估计 $I(\\lambda)$，并计算相对于精确值 $\\exp\\!\\left(\\tfrac{1}{2}\\lambda^2\\right)$ 的绝对误差。\n- 对于每个测试用例，报告一个定义为如下的比率\n$$\nr = \\frac{\\left|\\widehat{I}_{\\mathrm{QMC}} - I(\\lambda)\\right|}{\\max\\!\\left(\\left|\\widehat{I}_{\\mathrm{MC}} - I(\\lambda)\\right|, \\varepsilon\\right)},\n$$\n其中 $\\varepsilon = 10^{-16}$ 以避免除以零。比率 $r < 1$ 表明在该测试中拟蒙特卡洛方法优于标准蒙特卡洛方法；比率 $r > 1$ 则表明相反情况。角度（如果出现）必须以弧度为单位进行解释。\n\n要使用的正交矩阵：\n- 对于前两个坐标中按角度 $\\theta$ 的平面旋转，通过将 $2 \\times 2$ 旋转矩阵\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta\\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}\n$$\n嵌入到 $\\mathbf{Q}$ 的左上角块，并将其余对角线元素设为 $1$、非对角线元素设为 $0$ 来定义 $\\mathbf{Q}$。\n- 对于一个在第一个输出坐标中均匀混合所有坐标的 Householder 反射，取 $\\boldsymbol{v} = \\tfrac{1}{\\sqrt{d}}(1,1,\\dots,1)^\\top \\in \\mathbb{R}^d$ 并定义\n$$\n\\mathbf{Q} = \\mathbf{I}_d - 2 \\,\\boldsymbol{u}\\boldsymbol{u}^\\top, \\quad \\boldsymbol{u} = \\frac{\\boldsymbol{e}_1 - \\boldsymbol{v}}{\\lVert \\boldsymbol{e}_1 - \\boldsymbol{v}\\rVert_2},\n$$\n其中 $\\boldsymbol{e}_1$ 是第一个标准基向量。这种选择确保了 $(\\mathbf{Q}\\boldsymbol{z})_1 = \\boldsymbol{v}^\\top \\boldsymbol{z}$，因此被积函数依赖于所有坐标的等权重线性组合。\n\n固定参数：\n- 使用 $\\lambda = 0.5$。\n- 使用标准蒙特卡洛种子 $42$。\n- 使用 Sobol 加扰种子 $7$。\n\n测试套件：\n- 案例 1：$d = 8$, $n = 4096$，平面旋转，$\\theta = 0$（轴对齐）。\n- 案例 2：$d = 8$, $n = 4096$，平面旋转，$\\theta = \\pi/4$（混合两个坐标）。\n- 案例 3：$d = 32$, $n = 4096$，Householder 反射，$\\boldsymbol{v} = \\tfrac{1}{\\sqrt{d}}(1,\\dots,1)^\\top$（在第一个输出中最大程度地混合所有坐标）。\n- 案例 4：$d = 8$, $n = 64$，平面旋转，$\\theta = 0$（小样本量边界情况）。\n- 案例 5：$d = 8$, $n = 64$，平面旋转，$\\theta = \\pi/4$（小样本量且带混合）。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含上述案例的比率 $r$，格式为方括号括起来的逗号分隔列表，顺序与测试用例相同，每个比率四舍五入到 $6$ 位小数（例如，$\\left[0.123456,0.654321\\right]$）。不应打印任何额外文本。", "solution": "问题陈述已经过验证，被认为是有效的。它有科学依据，定义明确，并包含唯一、可复现解所需的所有必要信息。其所基于的数学前提，特别是积分的解析值和指定正交变换的性质，是正确的。该任务是一个标准的数值实验，旨在比较拟蒙特卡洛和标准蒙特卡洛积分的性能，这是计算数学及其在金融领域应用中的一个经典问题。因此，我们将着手提供解决方案。\n\n目标是计算在使用拟蒙特卡洛（QMC）方法和标准蒙特卡洛（MC）方法估计一个函数在多元标准正态分布下的期望时，两种方法绝对误差的比率。我们关注的积分为\n$$\nI(\\lambda) = \\mathbb{E}_{\\boldsymbol{Z} \\sim \\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)}\\!\\left[f_{\\lambda,\\mathbf{Q}}(\\boldsymbol{Z})\\right] = \\mathbb{E}\\!\\left[\\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{Z})_1\\right)\\right]\n$$\n其中 $\\boldsymbol{Z}$ 是一个 $d$ 维标准正态随机向量，$\\mathbf{Q}$ 是一个 $d \\times d$ 的正交矩阵，$(\\mathbf{Q}\\boldsymbol{Z})_1$ 是变换后向量的第一个分量。由于多元标准正态分布在正交变换下是不变的，向量 $\\boldsymbol{Y} = \\mathbf{Q}\\boldsymbol{Z}$ 也服从 $\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 分布。因此，它的第一个分量 $Y_1 = (\\mathbf{Q}\\boldsymbol{Z})_1$ 是一个标准正态随机变量，$Y_1 \\sim \\mathcal{N}(0, 1)$。因此，该期望是标准正态变量的矩生成函数在 $\\lambda$ 处的值，其具有已知的闭式解：\n$$\nI(\\lambda) = \\mathbb{E}\\!\\left[\\exp(\\lambda Y_1)\\right] = \\exp\\!\\left(\\tfrac{1}{2}\\lambda^2\\right)\n$$\n这个值作为计算积分误差的基准真相。对于给定参数 $\\lambda = 0.5$，精确值为 $I(0.5) = \\exp\\!\\left(\\tfrac{1}{2}(0.5)^2\\right) = \\exp(0.125)$。\n\n该期望通过在 $n$ 个点上用样本均值近似积分来进行数值估计：\n$$\n\\widehat{I} = \\frac{1}{n} \\sum_{i=1}^{n} \\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{z}_i)_1\\right)\n$$\n这种近似的有效性取决于样本点 $\\boldsymbol{z}_i$ 的选择。我们比较两种生成这些点的方法。\n\n首先，标准蒙特卡洛（MC）方法使用伪随机数生成器从目标分布 $\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 中生成 $n$ 个独立同分布的样本 $\\boldsymbol{z}_i$。固定的种子确保了可复现性。\n\n其次，拟蒙特卡洛（QMC）方法旨在通过使用确定性的、比伪随机点更均匀地覆盖积分域的低差异序列来改善收敛性。在这里，我们使用 Sobol 序列在 $d$ 维单位超立方体 $[0,1]^d$ 中生成 $n$ 个点。使用固定的种子对这些点进行加扰，以改善其统计特性。然后，通过标准正态分布的累积分布函数（CDF）的反函数（也称为概率单位函数），将这些均匀点 $u_{i,j}$ 的每个坐标转换为标准正态坐标 $z_{i,j}$：$z_{i,j} = \\Phi^{-1}(u_{i,j})$。\n\n这个问题的核心部分是分析被积函数的结构对 QMC 性能的影响。被积函数 $f_{\\lambda,\\mathbf{Q}}(\\boldsymbol{z})$ 仅通过线性组合 $(\\mathbf{Q}\\boldsymbol{z})_1 = \\sum_{j=1}^d Q_{1j} z_j$ 依赖于 $\\boldsymbol{z}$。QMC 的有效性通常在函数最重要维度与低差异序列的前几个轴对齐时最高。通过应用正交变换 $\\mathbf{Q}$，我们改变了这种对齐方式。\n\n我们考虑两种类型的正交矩阵：\n1.  平面旋转，它混合了前两个坐标。当旋转角度 $\\theta=0$ 时，$\\mathbf{Q}=\\mathbf{I}_d$，被积函数变为 $\\exp(\\lambda z_1)$，仅依赖于第一个坐标。这对 QMC 来说是一个理想的“轴对齐”情况。随着 $\\theta$ 增加到 $\\pi/4$，被积函数变为依赖于 $z_1$ 和 $z_2$ 的等权重混合，这通常会降低 QMC 的性能。该矩阵为 $\\mathbf{Q} = \\begin{pmatrix} \\mathbf{R}(\\theta) & \\mathbf{0} \\\\ \\mathbf{0} & \\mathbf{I}_{d-2} \\end{pmatrix}$，其中 $\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}$。\n\n2.  旨在最大程度混合所有坐标的 Householder 反射。该矩阵由 $\\mathbf{Q} = \\mathbf{I}_d - 2 \\boldsymbol{u}\\boldsymbol{u}^\\top$ 给出，其中 $\\boldsymbol{u} = \\frac{\\boldsymbol{e}_1 - \\boldsymbol{v}}{\\lVert \\boldsymbol{e}_1 - \\boldsymbol{v}\\rVert_2}$ 且 $\\boldsymbol{v} = \\frac{1}{\\sqrt{d}}(1, \\dots, 1)^\\top$。构造此变换使得 $\\mathbf{Q}$ 将 $\\boldsymbol{e}_1$ 映射到 $\\boldsymbol{v}$。由于 $\\mathbf{Q}$ 是对称且正交的（$\\mathbf{Q}^\\top = \\mathbf{Q} = \\mathbf{Q}^{-1}$），因此可得 $(\\mathbf{Q}\\boldsymbol{z})_1 = \\boldsymbol{e}_1^\\top \\mathbf{Q} \\boldsymbol{z} = (\\mathbf{Q}^\\top \\boldsymbol{e}_1)^\\top \\boldsymbol{z} = (\\mathbf{Q} \\boldsymbol{e}_1)^\\top \\boldsymbol{z} = \\boldsymbol{v}^\\top \\boldsymbol{z}$。被积函数变为 $\\exp\\!\\left(\\frac{\\lambda}{\\sqrt{d}}\\sum_{j=1}^d z_j\\right)$，等权重地依赖于所有 $d$ 个坐标。这对标准 QMC 来说代表了一种最坏情况，因为有效维度很高。\n\n对于由 $(d, n, \\mathbf{Q})$ 定义的每个测试用例，计算过程如下：\n1.  设置参数：$\\lambda=0.5$，MC 种子 $42$，Sobol 加扰种子 $7$。\n2.  构建指定的 $d \\times d$ 正交矩阵 $\\mathbf{Q}$。\n3.  使用 MC 方法生成 $n$ 个标准正态样本 $\\boldsymbol{Z}_{MC}$。\n4.  使用基于 Sobol 的 QMC 方法生成 $n$ 个标准正态样本 $\\boldsymbol{Z}_{QMC}$。\n5.  对于每个样本集，计算旋转后的向量 $\\boldsymbol{Y} = (\\mathbf{Q}\\boldsymbol{Z}^\\top)^\\top$，这可以实现为 $\\boldsymbol{Z} @ \\mathbf{Q}^\\top$。\n6.  提取旋转后向量的第一个分量 $(\\boldsymbol{Y})_1$。\n7.  对所有样本计算被积函数值，并计算样本均值 $\\widehat{I}_{MC}$ 和 $\\widehat{I}_{QMC}$。\n8.  计算绝对误差：$E_{MC} = |\\widehat{I}_{MC} - I(\\lambda)|$ 和 $E_{QMC} = |\\widehat{I}_{QMC} - I(\\lambda)|$。\n9.  计算性能比率 $r = E_{QMC} / \\max(E_{MC}, \\varepsilon)$，其中 $\\varepsilon = 10^{-16}$。\n\n所有测试用例的结果将被汇编并以要求的格式呈现。比率 $r$ 量化了 QMC 的相对性能：$r < 1$ 表示 QMC 在该配置下更优，而 $r > 1$ 表示 MC 更优。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import qmc, norm\n\ndef solve():\n    \"\"\"\n    Compares the performance of quasi-Monte Carlo (QMC) and standard Monte Carlo (MC)\n    for integrating a function under a multivariate standard normal distribution,\n    subject to various orthogonal transformations.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    lambda_val = 0.5\n    mc_seed = 42\n    sobol_scramble_seed = 7\n    epsilon = 1e-16\n\n    # --- Analytical Solution ---\n    # The true value of the integral E[exp(lambda * (QZ)_1)]\n    I_true = np.exp(0.5 * lambda_val**2)\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: d=8, n=4096, planar rotation, theta=0 (axis-aligned)\n        {'d': 8, 'n': 4096, 'q_type': 'planar', 'theta': 0.0},\n        # Case 2: d=8, n=4096, planar rotation, theta=pi/4 (mixes 2 coords)\n        {'d': 8, 'n': 4096, 'q_type': 'planar', 'theta': np.pi / 4},\n        # Case 3: d=32, n=4096, Householder reflection (mixes all coords)\n        {'d': 32, 'n': 4096, 'q_type': 'householder', 'theta': None},\n        # Case 4: d=8, n=64, planar rotation, theta=0 (small sample)\n        {'d': 8, 'n': 64, 'q_type': 'planar', 'theta': 0.0},\n        # Case 5: d=8, n=64, planar rotation, theta=pi/4 (small sample with mixing)\n        {'d': 8, 'n': 64, 'q_type': 'planar', 'theta': np.pi / 4},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        d = case['d']\n        n = case['n']\n        q_type = case['q_type']\n        theta = case['theta']\n\n        # --- Construct Orthogonal Matrix Q ---\n        if q_type == 'planar':\n            Q = np.identity(d)\n            if d >= 2:\n                c, s = np.cos(theta), np.sin(theta)\n                R = np.array([[c, -s], [s, c]])\n                Q[:2, :2] = R\n        elif q_type == 'householder':\n            v = np.ones(d) / np.sqrt(d)\n            e1 = np.zeros(d)\n            e1[0] = 1.0\n            u_vec = e1 - v\n            norm_u = np.linalg.norm(u_vec)\n            if norm_u > 0:\n                u_vec /= norm_u\n            u_outer_u = np.outer(u_vec, u_vec)\n            Q = np.identity(d) - 2 * u_outer_u\n        else:\n            raise ValueError(f\"Unknown matrix type: {q_type}\")\n\n        # --- Generate Samples ---\n        # Standard Monte Carlo (MC) samples\n        rng_mc = np.random.default_rng(seed=mc_seed)\n        Z_mc = rng_mc.standard_normal(size=(n, d))\n\n        # Quasi-Monte Carlo (QMC) samples\n        sampler_qmc = qmc.Sobol(d=d, scramble=True, seed=sobol_scramble_seed)\n        U_qmc = sampler_qmc.random(n=n)\n        Z_qmc = norm.ppf(U_qmc)\n\n        # --- Define integrand function ---\n        def evaluate_integrand(Z, Q_matrix, lam):\n            # Q is (d, d), Z is (n, d). We want Q*z for each row z in Z.\n            # This is equivalent to (Q @ Z.T).T or Z @ Q.T\n            # Then we take the first component of each resulting vector.\n            Y1 = (Z @ Q_matrix.T)[:, 0]\n            return np.exp(lam * Y1)\n\n        # --- Estimate Integrals ---\n        f_vals_mc = evaluate_integrand(Z_mc, Q, lambda_val)\n        I_hat_mc = np.mean(f_vals_mc)\n\n        f_vals_qmc = evaluate_integrand(Z_qmc, Q, lambda_val)\n        I_hat_qmc = np.mean(f_vals_qmc)\n\n        # --- Compute Errors and Ratio ---\n        err_mc = np.abs(I_hat_mc - I_true)\n        err_qmc = np.abs(I_hat_qmc - I_true)\n\n        ratio = err_qmc / np.maximum(err_mc, epsilon)\n        results.append(ratio)\n\n    # --- Format and Print Final Output ---\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "面对具有不连续性或奇异性的复杂函数，经典 QMC 方法的性能可能会下降。为了应对这些挑战，研究者们发展了随机化准蒙特卡洛（RQMC）方法，它巧妙地将低差异序列的均匀性与随机化的优点结合起来。在这个高级实践中，你将实现并测试 Owen 加扰（Owen's scrambling），一种先进的 RQMC 技术，并验证它在处理金融计算中常见的不连续收益函数时，如何显著优于未加扰的 Sobol' 序列 [@problem_id:2424700]。", "id": "2424700", "problem": "您必须编写一个完整、可运行的程序，用于比较 Owen 加扰的 Sobol' 序列和未加扰的 Sobol' 序列在估计一个在计算经济学和金融学中至关重要的不连续被积函数的积分时的性能。考虑积分\n$$\nI(d,\\tau) \\;=\\; \\int_{[0,1]^d} \\mathbf{1}\\!\\left\\{\\sum_{i=1}^{d} u_i \\ge \\tau \\right\\} \\, \\mathrm{d}\\boldsymbol{u},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，$d \\in \\mathbb{N}$ 是维度，$\\tau \\in \\mathbb{R}$ 是一个阈值。该积分表示 $d$ 个独立的 Uniform$(0,1)$ 随机变量之和超过 $\\tau$ 的概率，这是一种原型不连续收益，与资产定价中的数字收益以及计算经济学和金融学中的风险度量相关。其精确值为\n$$\nI(d,\\tau) \\;=\\; 1 - F_{\\mathrm{IH}}(\\tau; d),\n$$\n其中 $F_{\\mathrm{IH}}(\\cdot; d)$ 是参数为 $d$ 的 Irwin–Hall 分布的累积分布函数，由下式给出：\n$$\nF_{\\mathrm{IH}}(x; d) \\;=\\;\n\\begin{cases}\n0, & x \\le 0,\\\n$$4pt]\n\\dfrac{1}{d!}\\displaystyle\\sum_{k=0}^{\\lfloor x \\rfloor} (-1)^k \\binom{d}{k} (x - k)^d, & 0 < x < d,\\\n$$10pt]\n1, & x \\ge d.\n\\end{cases}\n$$\n\n对于给定的 $d$、$\\tau$ 以及样本量 $N \\in \\mathbb{N}$，定义拟蒙特卡洛估计量为：\n$$\n\\widehat{I}_N \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} \\mathbf{1}\\!\\left\\{\\sum_{i=1}^{d} u_{n,i} \\ge \\tau \\right\\},\n$$\n其中 $\\{\\boldsymbol{u}_n\\}_{n=1}^{N} \\subset [0,1]^d$ 是一个 Sobol' 低差异序列的前 $N$ 个点。令 $m$ 为满足 $2^m \\ge N$ 的最小整数。在下文所有情况中，均使用来自 $d$ 维、大小为 $2^m$ 的 Sobol' 数字网格的前 $N$ 个点。\n\n您的程序必须为每个测试用例计算：\n1. 使用未加扰的 Sobol' 序列计算一个未加扰的估计值 $\\widehat{I}_N^{\\mathrm{uns}}$ 及其绝对误差：\n$$\ne_{\\mathrm{uns}} \\;=\\; \\left| \\widehat{I}_N^{\\mathrm{uns}} - I(d,\\tau) \\right|.\n$$\n2. 使用 Owen 加扰的 Sobol' 序列计算 $R$ 个独立的随机化估计值 $\\widehat{I}_{N,r}^{\\mathrm{scr}}$（$r \\in \\{1,\\dots,R\\}$），每个估计值都使用其自身的独立随机化，并记录其绝对误差：\n$$\ne_{\\mathrm{scr},r} \\;=\\; \\left| \\widehat{I}_{N,r}^{\\mathrm{scr}} - I(d,\\tau) \\right|.\n$$\n对每个测试用例，定义性能比\n$$\n\\rho \\;=\\; \\frac{e_{\\mathrm{uns}}}{\\operatorname{median}\\{ e_{\\mathrm{scr},1},\\dots,e_{\\mathrm{scr},R} \\}},\n$$\n这样，$\\rho > 1$ 在数值上便能证明，对于此不连续被积函数，Owen 加扰估计量比未加扰估计量获得了更小的典型绝对误差。\n\n使用以下参数值测试套件，其中 $S$ 是基础种子，$R$ 是独立 Owen 加扰的重复次数。对于第 $r$ 次加扰重复，使用种子 $S + r - 1$。对于下面的每个元组 $\\left(d,\\tau,N,R,S\\right)$，计算相应的 $\\rho$：\n- 测试用例 1: $\\left(d,\\tau,N,R,S\\right) = \\left(5,\\,2.5,\\,4093,\\,64,\\,13579\\right)$。\n- 测试用例 2: $\\left(d,\\tau,N,R,S\\right) = \\left(10,\\,5.0,\\,16384,\\,32,\\,24680\\right)$。\n- 测试用例 3: $\\left(d,\\tau,N,R,S\\right) = \\left(12,\\,9.0,\\,32767,\\,16,\\,112233\\right)$。\n\n您的程序必须：\n- 使用上面给出的 Irwin–Hall 累积分布函数 $F_{\\mathrm{IH}}(\\tau; d)$ 来精确计算 $I(d,\\tau)$。\n- 对于每个测试用例，无论是未加扰序列还是独立 Owen 加扰序列，都使用来自 $d$ 维、大小为 $2^m$ 的 Sobol' 数字网格的前 $N$ 个点。\n- 对每个测试用例，生成上文定义的性能比 $\\rho$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的比率，格式为方括号内以逗号分隔的列表，并按上述测试用例的顺序排列。每个比率必须四舍五入到小数点后恰好 $6$ 位数字。例如，形式为 $\\left[\\rho_1,\\rho_2,\\rho_3\\right]$ 的输出必须打印为单行，如 `[1.234000,0.987650,1.500000]`。", "solution": "所提出的问题是拟蒙特卡洛（QMC）方法领域内一个有效的数值实验，具体应用于一个具有计算金融特征的典型问题。它要求比较标准 Sobol' 序列与 Owen 加扰的 Sobol' 序列在对一个不连续函数进行积分时的性能。该问题是良构的、有科学依据的，并且所有参数和定义都足够清晰，从而能够得出一个唯一且可验证的解。我们将着手推导和实现该解决方案。\n\n核心目标是计算性能比 $\\rho$，它量化了对于一个特定的不连续积分，Owen 加扰相对于未加扰序列所带来的性能提升。该比率定义为：\n$$\n\\rho \\;=\\; \\frac{e_{\\mathrm{uns}}}{\\operatorname{median}\\{ e_{\\mathrm{scr},1},\\dots,e_{\\mathrm{scr},R} \\}},\n$$\n其中 $e_{\\mathrm{uns}}$ 是使用未加扰 Sobol' 序列的估计量的绝对误差，而 $\\{ e_{\\mathrm{scr},r} \\}_{r=1}^R$ 是使用 Owen 加扰的 Sobol' 序列进行 $R$ 次独立重复所得的一组绝对误差。$\\rho > 1$ 的值表明加扰序列具有更优越的性能，因为它实现了更小的中位数误差。\n\n详细步骤如下：\n\n**步骤 1：计算精确积分值**\n\n待估计的积分是\n$$\nI(d,\\tau) \\;=\\; \\int_{[0,1]^d} \\mathbf{1}\\!\\left\\{\\sum_{i=1}^{d} u_i \\ge \\tau \\right\\} \\, \\mathrm{d}\\boldsymbol{u}.\n$$\n这表示概率 $P(\\sum_{i=1}^d U_i \\ge \\tau)$，其中 $U_i \\sim \\text{Uniform}(0,1)$ 是独立的随机变量。和 $\\sum_{i=1}^d U_i$ 服从参数为 $d$ 的 Irwin–Hall 分布。该积分的精确值由该分布的生存函数给出：\n$$\nI(d,\\tau) \\;=\\; 1 - F_{\\mathrm{IH}}(\\tau; d),\n$$\n其中 $F_{\\mathrm{IH}}(x; d)$ 是问题描述中提供的累积分布函数（CDF）。为了计算它，我们必须实现一个计算 $F_{\\mathrm{IH}}(x;d)$ 的函数。对于给定的值 $x = \\tau$ 和参数 $d$，该函数是分段定义的。非平凡的情况是 $0 < x < d$：\n$$\nF_{\\mathrm{IH}}(x; d) \\;=\\; \\frac{1}{d!}\\sum_{k=0}^{\\lfloor x \\rfloor} (-1)^k \\binom{d}{k} (x - k)^d.\n$$\n这个和式涉及阶乘、二项式系数和幂，这些都是标准的数学函数。例如，对于测试用例 $(d, \\tau) = (5, 2.5)$，我们发现 $I(5, 2.5) = 1 - F_{\\mathrm{IH}}(2.5; 5) = 1 - 0.5 = 0.5$，这是由 Irwin-Hall 分布围绕其均值 $d/2 = 2.5$ 的对称性得出的。对于其他情况，需要直接对公式进行求值。\n\n**步骤 2：实现拟蒙特卡洛估计量**\n\n使用点集 $\\{\\boldsymbol{u}_n\\}_{n=1}^{N}$ 对 $I(d,\\tau)$ 的 QMC 估计量为\n$$\n\\widehat{I}_N \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f(\\boldsymbol{u}_n),\n$$\n其中被积函数是指示函数 $f(\\boldsymbol{u}) = \\mathbf{1}\\{\\sum_{i=1}^{d} u_i \\ge \\tau\\}$。计算过程包括对每个点 $\\boldsymbol{u}_n$ 的分量求和，检查其和是否大于或等于 $\\tau$，然后对所有 $N$ 个点的二元检查结果求平均值。\n\n我们必须计算两种类型的估计值：\n\n1.  **未加扰估计值 ($\\widehat{I}_N^{\\mathrm{uns}}$):** 我们生成一个 $d$ 维 Sobol' 序列的前 $N$ 个点，不进行任何加扰。这些点用于计算估计值 $\\widehat{I}_N^{\\mathrm{uns}}$。然后计算绝对误差 $e_{\\mathrm{uns}} = |\\widehat{I}_N^{\\mathrm{uns}} - I(d, \\tau)|$。Sobol' 序列生成器通过设置 `scramble=False` 来配置。\n\n2.  **加扰估计值 ($\\widehat{I}_{N,r}^{\\mathrm{scr}}$):** 我们执行 $R$ 次独立重复。对于每次重复 $r \\in \\{1, \\dots, R\\}$，我们从一个启用了 Owen 加扰的 $d$ 维 Sobol' 序列生成一组新的 $N$ 个点。关键在于，每次重复必须在统计上是独立的。这通过为每次重复的加扰矩阵的随机数生成器设置不同的种子来实现。问题指定对第 $r$ 次重复使用种子 $S + r - 1$。对于这 $R$ 个点集中的每一个，我们计算一个估计值 $\\widehat{I}_{N,r}^{\\mathrm{scr}}$ 及其对应的绝对误差 $e_{\\mathrm{scr},r} = |\\widehat{I}_{N,r}^{\\mathrm{scr}} - I(d, \\tau)|$。此过程产生一个包含 $R$ 个误差的样本 $\\{e_{\\mathrm{scr},1}, \\dots, e_{\\mathrm{scr},R}\\}$。\n\n**步骤 3：计算性能比**\n\n有了未加扰误差 $e_{\\mathrm{uns}}$ 和 $R$ 个加扰误差的样本 $\\{e_{\\mathrm{scr},r}\\}$，我们就可以评估加扰估计量的典型性能。加扰误差的中位数 $\\operatorname{median}\\{e_{\\mathrm{scr},r}\\}$，为随机化 QMC 方法的误差分布的中心趋势提供了一个稳健的度量。最终的性能比 $\\rho$ 是通过将未加扰方法的单个确定性误差除以这个中位数误差来计算的。\n\n**步骤 4：单个测试用例的算法流程**\n对于每个元组 $(d, \\tau, N, R, S)$：\n1.  计算精确积分值 $I_{\\mathrm{exact}} = 1 - F_{\\mathrm{IH}}(\\tau; d)$。\n2.  生成一个 $d$ 维的包含 $N$ 个点的未加扰 Sobol' 序列。\n3.  计算估计值 $\\widehat{I}_N^{\\mathrm{uns}}$ 和误差 $e_{\\mathrm{uns}} = |\\widehat{I}_N^{\\mathrm{uns}} - I_{\\mathrm{exact}}|$。\n4.  初始化一个空列表 `errors_scr` 用于存放加扰误差。\n5.  从 1 到 R 循环 $r$：\n    a.  将随机化种子设置为 $S + r - 1$。\n    b.  生成一个 $d$ 维的包含 $N$ 个点的 Owen 加扰 Sobol' 序列。\n    c.  计算估计值 $\\widehat{I}_{N,r}^{\\mathrm{scr}}$ 和误差 $e_{\\mathrm{scr},r} = |\\widehat{I}_{N,r}^{\\mathrm{scr}} - I_{\\mathrm{exact}}|$。\n    d.  将 $e_{\\mathrm{scr},r}$ 附加到 `errors_scr`。\n6.  计算加扰误差的中位数：$m_e = \\operatorname{median}(\\text{errors\\_scr})$。\n7.  计算性能比 $\\rho = e_{\\mathrm{uns}} / m_e$。\n8.  存储结果 $\\rho$，并格式化为 6 位小数。\n\n对所有提供的测试用例重复此整个过程。最终输出是计算出的比率的有序列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import qmc\nfrom scipy.special import comb\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that executes the comparison for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (d, tau, N, R, S)\n        (5, 2.5, 4093, 64, 13579),\n        (10, 5.0, 16384, 32, 24680),\n        (12, 9.0, 32767, 16, 112233),\n    ]\n\n    results = []\n    \n    for d, tau, N, R, S in test_cases:\n        # Step 1: Compute the exact integral value using the Irwin-Hall CDF\n        exact_integral_value = 1.0 - irwin_hall_cdf(tau, d)\n\n        # Step 2.1: Compute the unscrambled QMC estimate and its error\n        # Initialize an unscrambled Sobol' sequence generator\n        sampler_unscrambled = qmc.Sobol(d=d, scramble=False)\n        points_unscrambled = sampler_unscrambled.random(n=N)\n        \n        # Compute the estimate\n        integrand_values = (np.sum(points_unscrambled, axis=1) >= tau)\n        i_hat_unscrambled = np.mean(integrand_values)\n\n        # Compute the absolute error\n        e_unscrambled = np.abs(i_hat_unscrambled - exact_integral_value)\n\n        # Step 2.2: Compute R independent scrambled QMC estimates and their errors\n        scrambled_errors = []\n        for r in range(1, R + 1):\n            seed = S + r - 1\n            \n            # Initialize an Owen-scrambled Sobol' sequence generator with a unique seed\n            sampler_scrambled = qmc.Sobol(d=d, scramble=True, seed=seed)\n            points_scrambled = sampler_scrambled.random(n=N)\n            \n            # Compute the estimate\n            integrand_values_scr = (np.sum(points_scrambled, axis=1) >= tau)\n            i_hat_scrambled = np.mean(integrand_values_scr)\n            \n            # Compute and store the absolute error\n            e_scrambled = np.abs(i_hat_scrambled - exact_integral_value)\n            scrambled_errors.append(e_scrambled)\n\n        # Step 3: Calculate the performance ratio\n        median_scrambled_error = np.median(scrambled_errors)\n        \n        # Avoid division by zero, though highly unlikely in this context.\n        if median_scrambled_error == 0:\n            # If median error is 0, scrambling is perfect. \n            # If unscrambled is also 0, ratio is 1. Otherwise, ratio is effectively infinite.\n            # We assign a large number or handle as per problem specific but here we assume it won't happen.\n            rho = np.inf if e_unscrambled > 0 else 1.0\n        else:\n            rho = e_unscrambled / median_scrambled_error\n        \n        results.append(f\"{rho:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n\ndef irwin_hall_cdf(x, d):\n    \"\"\"\n    Computes the Irwin-Hall cumulative distribution function F_IH(x; d).\n    \n    Args:\n        x (float): The value at which to evaluate the CDF.\n        d (int): The parameter of the distribution (number of uniform variables).\n    \n    Returns:\n        float: The value of the CDF.\n    \"\"\"\n    if x <= 0:\n        return 0.0\n    if x >= d:\n        return 1.0\n    \n    # Formula for 0 < x < d\n    total_sum = 0.0\n    k_max = math.floor(x)\n    \n    for k in range(k_max + 1):\n        # Calculate (-1)^k * C(d, k) * (x - k)^d\n        term = ((-1)**k) * comb(d, k, exact=True) * ((x - k)**d)\n        total_sum += term\n        \n    return total_sum / math.factorial(d)\n\n\nif __name__ == '__main__':\n    solve()\n```"}]}