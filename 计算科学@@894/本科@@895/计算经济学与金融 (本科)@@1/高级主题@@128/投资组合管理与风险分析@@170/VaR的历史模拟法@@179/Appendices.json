{"hands_on_practices": [{"introduction": "我们将从基础开始，学习如何为包含多种相关资产的投资组合计算在险价值（$VaR$）。本练习使用一个可控的合成数据集，旨在让你专注于投资组合损失计算和历史模拟分位数方法的核心机制，而无需处理真实数据的噪音。通过这个练习 [@problem_id:2390037]，你将掌握构建多元化投资组合风险度量的基本技能，并探索不同权重分配方案对风险的影响。", "id": "2390037", "problem": "给定一个包含 $N=10$ 种资产的投资组合。设投资组合权重向量为 $\\mathbf{w} \\in \\mathbb{R}^{10}$，过去 $T$ 天的历史收益率矩阵为 $\\mathbf{R} \\in \\mathbb{R}^{T \\times 10}$，其第 $t$ 行为 $\\mathbf{r}_t^\\top$。每日投资组合收益率为 $R^p_t = \\sum_{i=1}^{10} w_i r_{t,i}$，每日投资组合亏损为 $L_t = - R^p_t$。$99\\%$ 风险价值（Value at Risk, VaR）对于一个亏损随机变量 $L$ 定义为满足 $\\mathbb{P}(L \\le v) \\ge 0.99$ 的最小数值 $v$。在历史模拟法下，使用样本 $\\{L_t\\}_{t=1}^T$ 的经验分布来替代 $L$ 的真实分布。使用经验分布函数，将经验 $p$-分位数定义为索引 $k = \\lceil p \\cdot T \\rceil$ 处的顺序统计量（使用基于 1 的索引），即将 $\\{L_t\\}$ 按非递减顺序排序得到 $L_{(1)} \\le \\cdots \\le L_{(T)}$，并设 $\\widehat{q}_p = L_{(k)}$，其中 $k = \\lceil p \\cdot T \\rceil$。那么，$99\\%$ VaR 的历史模拟估计值为 $\\widehat{\\mathrm{VaR}}_{0.99} = \\widehat{q}_{0.99}$。所有输出都必须以小数形式报告（例如，报告 $0.025$ 而不是 $2.5\\%$）。\n\n为了确保数据集科学合理、可复现，并能捕捉跨资产相关性，按如下方式构建历史收益率。设各资产的每日波动率向量为 $\\boldsymbol{\\sigma} = (\\sigma_1,\\ldots,\\sigma_{10})$，其中对于 $i \\in \\{1,\\ldots,10\\}$，$\\sigma_i = 0.01 + 0.002 \\cdot (i-1)$。定义相关系数矩阵 $\\mathbf{C} \\in \\mathbb{R}^{10 \\times 10}$，其元素为 $C_{ij} = \\rho^{|i-j|}$，其中 $\\rho = 0.6$。再定义协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathbf{D} \\mathbf{C} \\mathbf{D}$，其中 $\\mathbf{D} = \\mathrm{diag}(\\boldsymbol{\\sigma})$。对于给定的 $T$，通过抽取一个元素为独立同分布标准正态随机变量的矩阵 $\\mathbf{Z} \\in \\mathbb{R}^{T \\times 10}$ 来生成历史样本，然后令 $\\mathbf{R} = \\mathbf{Z} \\mathbf{L}^\\top$。其中 $\\mathbf{L}$ 是 $\\boldsymbol{\\Sigma}$ 的下三角 Cholesky 因子，满足 $\\boldsymbol{\\Sigma} = \\mathbf{L} \\mathbf{L}^\\top$。每次生成数据集时，使用固定的伪随机种子 $12345$。此过程会生成具有指定协方差的相关资产收益率，作为历史模拟法所需历史样本。本任务不涉及角度。不适用任何物理单位；所有亏损均以无单位的小数报告。\n\n实现一个程序，根据上述经验顺序统计量的定义，为以下每个测试用例计算 $\\widehat{\\mathrm{VaR}}_{0.99}$。在所有用例中，均使用指定的生成方法和固定的种子 $12345$ 来为指定的 $T$ 生成 $\\mathbf{R}$ 矩阵。\n\n测试套件：\n- 用例 A（一般情况）：$T = 1000$，权重对所有 $i \\in \\{1,\\ldots,10\\}$ 均为 $w_i = 1/10$。\n- 用例 B（集中度极端情况）：$T = 500$，权重为 $w_1 = 1$ 且对所有 $i \\in \\{2,\\ldots,10\\}$ 均为 $w_i = 0$。\n- 用例 C（风险平价风格情况）：$T = 252$，权重由 $w_i \\propto 1/\\sigma_i$ 给出，其中 $i \\in \\{1,\\ldots,10\\}$，并进行归一化以使 $\\sum_{i=1}^{10} w_i = 1$。\n\n算法要求：\n- 使用如上定义的经验分位数，其中 $k = \\lceil 0.99 \\cdot T \\rceil$（无插值）。\n- 对于每个用例，根据生成的收益率和指定的权重计算亏损序列 $\\{L_t\\}_{t=1}^T$，然后计算 $\\widehat{\\mathrm{VaR}}_{0.99}$。\n- 将每个最终的 $\\widehat{\\mathrm{VaR}}_{0.99}$ 四舍五入到 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用例 A、B 和 C 的三个四舍五入后的结果，并按此顺序排列。输出形式为一个由逗号分隔的列表，并用方括号括起来。例如，输出必须类似于 $[x_A,x_B,x_C]$，其中每个 $x$ 都精确到 $6$ 位小数。", "solution": "该问题定义明确、科学合理且内部一致。我们将着手提供一个正式的解决方案。\n\n目标是计算一个包含 $N=10$ 种资产的投资组合在三种不同情景下的 $99\\%$ 风险价值（$\\mathrm{VaR}_{0.99}$）。计算将采用历史模拟法，其中历史数据是根据指定的统计模型综合生成的。\n\n**1. 资产收益率的综合生成**\n\n模拟的核心是生成一个 $T \\times N$ 的历史收益率矩阵 $\\mathbf{R}$，其中 $T$ 是天数，$N=10$ 是资产数量。收益率被建模为从一个均值为零、协方差矩阵为 $\\boldsymbol{\\Sigma}$ 的多元正态分布中的抽样。该协方差结构对于捕捉资产价格变动之间的相互依赖关系至关重要。\n\n首先，我们定义协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{10 \\times 10}$ 的组成部分。\n各资产的每日波动率向量为 $\\boldsymbol{\\sigma} = (\\sigma_1, \\sigma_2, \\dots, \\sigma_{10})^\\top$，其中第 $i$ 种资产的波动率由以下公式给出：\n$$\n\\sigma_i = 0.01 + 0.002 \\cdot (i-1) \\quad \\text{for } i \\in \\{1, 2, \\dots, 10\\}\n$$\n这会产生一系列波动率，从 $\\sigma_1 = 0.01$ 开始，递增至 $\\sigma_{10} = 0.028$。这些波动率构成矩阵 $\\mathbf{D} = \\mathrm{diag}(\\boldsymbol{\\sigma})$ 的对角线。\n\n接下来，相关性结构由一个矩阵 $\\mathbf{C} \\in \\mathbb{R}^{10 \\times 10}$ 定义，其中资产 $i$ 和资产 $j$ 之间的相关性为：\n$$\nC_{ij} = \\rho^{|i-j|}\n$$\n参数 $\\rho$ 给定为 $0.6$。这种结构意味着索引上更接近的资产相关性更强。\n\n协方差矩阵 $\\boldsymbol{\\Sigma}$ 则按如下方式构成：\n$$\n\\boldsymbol{\\Sigma} = \\mathbf{D} \\mathbf{C} \\mathbf{D}\n$$\n为了生成相关的随机变量，我们使用 $\\boldsymbol{\\Sigma}$ 的 Cholesky 分解。我们找到一个下三角矩阵 $\\mathbf{L}$，使得 $\\boldsymbol{\\Sigma} = \\mathbf{L} \\mathbf{L}^\\top$。\n\n历史收益率矩阵 $\\mathbf{R}$ 是通过首先创建一个由独立同分布的标准正态随机变量 ($\\mathcal{N}(0,1)$) 组成的矩阵 $\\mathbf{Z} \\in \\mathbb{R}^{T \\times 10}$ 来生成的。然后通过以下变换得到相关的收益率：\n$$\n\\mathbf{R} = \\mathbf{Z} \\mathbf{L}^\\top\n$$\n$\\mathbf{R}$ 的每一行 $\\mathbf{r}_t^\\top$ 都是一个随机向量，代表这 10 种资产的每日收益率，这些向量抽样自 $\\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$。为了保证可复现性，对于每个数据生成过程，伪随机数生成器都使用固定的种子 $12345$ 进行初始化。\n\n**2. 用于风险价值（$\\mathrm{VaR}$）计算的历史模拟法**\n\n给定一个投资组合权重向量 $\\mathbf{w} = (w_1, w_2, \\dots, w_{10})^\\top$，投资组合的每日收益率 $R^p_t$ 是单个资产收益率的加权和：\n$$\nR^p_t = \\mathbf{r}_t^\\top \\mathbf{w} = \\sum_{i=1}^{10} w_i r_{t,i}\n$$\n相应的每日投资组合亏损定义为收益率的负值：$L_t = -R^p_t$。对从 $1$ 到 $T$ 的每一天 $t$ 都执行此计算，从而得到一个历史亏损样本 $\\{L_t\\}_{t=1}^T$。\n\n历史模拟法通过该亏损样本的经验分布来估计 $\\mathrm{VaR}$。亏损分布的 $p$-分位数是通过从排序后的亏损数据中找到一个特定值来估计的。我们将亏损按非递减顺序排序：\n$$\nL_{(1)} \\le L_{(2)} \\le \\cdots \\le L_{(T)}\n$$\n问题规定，经验 $p$-分位数 $\\widehat{q}_p$ 是第 $k$ 个顺序统计量 $L_{(k)}$，其中索引 $k$ 由以下公式给出：\n$$\nk = \\lceil p \\cdot T \\rceil\n$$\n这是一个基于 1 的索引。对于 $99\\%$ $\\mathrm{VaR}$，我们设 $p=0.99$，因此历史估计值为：\n$$\n\\widehat{\\mathrm{VaR}}_{0.99} = L_{(k)} \\quad \\text{with} \\quad k = \\lceil 0.99 \\cdot T \\rceil\n$$\n\n**3. 在测试用例中的应用**\n\n我们现在将此方法应用于三个指定的测试用例。协方差矩阵 $\\boldsymbol{\\Sigma}$ 及其 Cholesky 因子 $\\mathbf{L}$ 对所有用例都是通用的，因为它们仅依赖于 $N=10$ 以及固定的参数 $\\boldsymbol{\\sigma}$ 和 $\\rho$。\n\n**用例 A：一般情况**\n-   时间周期：$T = 1000$。\n-   投资组合权重：一个等权重投资组合，$w_i = 1/10 = 0.1$ 对所有 $i$ 均成立。\n-   $\\mathrm{VaR}$ 索引：$k = \\lceil 0.99 \\cdot 1000 \\rceil = \\lceil 990 \\rceil = 990$。\n-   步骤：\n    1.  使用种子 $12345$ 生成 $\\mathbf{R} \\in \\mathbb{R}^{1000 \\times 10}$。\n    2.  使用 $\\mathbf{w} = (0.1, \\dots, 0.1)^\\top$ 计算亏损序列 $\\{L_t\\}_{t=1}^{1000}$。\n    3.  对亏损进行排序并选择第 $990$ 个值 $L_{(990)}$。\n\n**用例 B：集中度极端情况**\n-   时间周期：$T = 500$。\n-   投资组合权重：一个完全集中于第一种资产的投资组合，$\\mathbf{w} = (1, 0, \\dots, 0)^\\top$。\n-   $\\mathrm{VaR}$ 索引：$k = \\lceil 0.99 \\cdot 500 \\rceil = \\lceil 495 \\rceil = 495$。\n-   步骤：\n    1.  使用种子 $12345$ 生成 $\\mathbf{R} \\in \\mathbb{R}^{500 \\times 10}$。\n    2.  计算亏损序列 $\\{L_t\\}_{t=1}^{500}$。此处，$L_t = -r_{t,1}$。\n    3.  对亏损进行排序并选择第 $495$ 个值 $L_{(495)}$。\n\n**用例 C：风险平价风格情况**\n-   时间周期：$T = 252$（近似一个交易年）。\n-   投资组合权重：权重与资产波动率成反比，$w_i \\propto 1/\\sigma_i$。这是一种受“风险平价”启发的配置方式，波动率较低的资产获得更高的权重。权重必须进行归一化，使其总和为 1：\n    $$\n    w_i = \\frac{1/\\sigma_i}{\\sum_{j=1}^{10} (1/\\sigma_j)}\n    $$\n-   $\\mathrm{VaR}$ 索引：$k = \\lceil 0.99 \\cdot 252 \\rceil = \\lceil 249.48 \\rceil = 250$。\n-   步骤：\n    1.  计算归一化后的权重 $\\mathbf{w}$。\n    2.  使用种子 $12345$ 生成 $\\mathbf{R} \\in \\mathbb{R}^{252 \\times 10}$。\n    3.  使用计算出的 $\\mathbf{w}$ 计算亏损序列 $\\{L_t\\}_{t=1}^{252}$。\n    4.  对亏损进行排序并选择第 $250$ 个值 $L_{(250)}$。\n\n对于每个用例，计算出的 $\\widehat{\\mathrm{VaR}}_{0.99}$ 将按要求四舍五入到 6 位小数。代码实现将使用基于 0 的数组索引，因此在基于 1 的系统中索引为 $k$ 的值对应于代码中索引为 $k-1$ 的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef generate_returns(T, N, sigma_vec, corr_matrix, seed):\n    \"\"\"\n    Generates a matrix of correlated asset returns.\n\n    Args:\n        T (int): Number of time periods (days).\n        N (int): Number of assets.\n        sigma_vec (np.ndarray): Vector of asset volatilities.\n        corr_matrix (np.ndarray): Asset correlation matrix.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        np.ndarray: A T x N matrix of simulated daily returns.\n    \"\"\"\n    # Construct the covariance matrix: Sigma = D * C * D\n    D = np.diag(sigma_vec)\n    cov_matrix = D @ corr_matrix @ D\n\n    # Perform Cholesky decomposition: Sigma = L * L^T\n    # numpy.linalg.cholesky returns the lower-triangular matrix L.\n    L = np.linalg.cholesky(cov_matrix)\n\n    # Generate independent standard normal random variables\n    rng = np.random.default_rng(seed)\n    Z = rng.standard_normal((T, N))\n\n    # Generate correlated returns: R = Z * L^T\n    R = Z @ L.T\n    return R\n\ndef calculate_var(T, weights, returns):\n    \"\"\"\n    Calculates the 99% Value at Risk using historical simulation.\n\n    Args:\n        T (int): Number of time periods.\n        weights (np.ndarray): Portfolio weights vector.\n        returns (np.ndarray): Matrix of historical returns.\n\n    Returns:\n        float: The 99% VaR, rounded to 6 decimal places.\n    \"\"\"\n    # Calculate daily portfolio returns: Rp_t = R_t^T * w\n    portfolio_returns = returns @ weights\n    \n    # Calculate daily portfolio losses: L_t = -Rp_t\n    losses = -portfolio_returns\n    \n    # Sort losses in non-decreasing order\n    sorted_losses = np.sort(losses)\n    \n    # Calculate the index k for the 99% empirical quantile\n    # k = ceil(p * T), with 1-based indexing\n    p = 0.99\n    k = math.ceil(p * T)\n    \n    # Get the VaR value. Index is k-1 due to 0-based indexing in Python.\n    var_99 = sorted_losses[k - 1]\n    \n    return round(var_99, 6)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the three test cases.\n    \"\"\"\n    N = 10\n    rho = 0.6\n    \n    # Define asset volatilities\n    sigma_vec = np.array([0.01 + 0.002 * (i - 1) for i in range(1, N + 1)])\n    \n    # Define correlation matrix\n    indices = np.arange(N)\n    corr_matrix = rho ** np.abs(indices - indices[:, np.newaxis])\n    \n    # Fixed seed for all data generation\n    seed = 12345\n    \n    # Define test cases\n    test_cases = [\n        {'name': 'A', 'T': 1000, 'weights_def': 'equal'},\n        {'name': 'B', 'T': 500, 'weights_def': 'concentrated'},\n        {'name': 'C', 'T': 252, 'weights_def': 'risk-parity'}\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        T = case['T']\n        \n        # Generate returns for the specific T\n        returns = generate_returns(T, N, sigma_vec, corr_matrix, seed)\n        \n        # Define weights for the case\n        weights = np.zeros(N)\n        if case['weights_def'] == 'equal':\n            weights = np.full(N, 1.0 / N)\n        elif case['weights_def'] == 'concentrated':\n            weights[0] = 1.0\n        elif case['weights_def'] == 'risk-parity':\n            inv_sigma = 1.0 / sigma_vec\n            weights = inv_sigma / np.sum(inv_sigma)\n        \n        # Calculate VaR for the case\n        var_result = calculate_var(T, weights, returns)\n        results.append(var_result)\n\n    # Format the final output string as [x_A,x_B,x_C]\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n\n```"}, {"introduction": "在掌握了基本计算方法后，我们将理论与实践相结合。真实的金融数据中充满了复杂情况，例如股票分割，如果不进行适当处理，这些事件会扭曲风险计算结果。本实践 [@problem_id:2400150] 聚焦于数据调整这一关键步骤，演示如何在应用历史模拟法之前，通过调整历史价格来构建具有经济意义的回报序列，从而强调数据预处理在金融建模中的重要性。", "id": "2400150", "problem": "给定一个由少量股票组成的投资组合，其在长度为 $T$ 天的有限回溯期内的每日收盘价已知。其中一只股票在回溯期内的一个已知生效日进行了2比1的股票拆分，这意味着在拆分日 $t_s$，记录的收盘价会机械地减半，而持股数量则翻倍。为了衡量风险，您必须使用以下基本定义和要求，为指定的投资组合计算置信水平为 $0.95$ 的单日历史模拟法 (HS) 风险价值 (VaR)。\n\n定义和要求：\n- 假设有 $N$ 种资产。令 $P^{(i)}_t$ 表示资产 $i$ 在日期 $t$ 的记录（未调整）收盘价，其中 $t \\in \\{0,1,\\dots,T\\}$ 且 $i \\in \\{1,\\dots,N\\}$。令 $h_i$ 表示当前（在日期 $T$）持有的资产 $i$ 的股份数量。\n- 资产 $i$ 在日期 $t_s$ 发生的2比1拆分定义如下：在日期 $t_s$ 的记录价格反映了此次拆分，而 $t &lt; t_s$ 的记录价格则未反映。为了构建排除拆分机械效应、具有经济可比性的相对价格，定义调整后价格 $\\tilde{P}^{(i)}_t$ 为\n$$\n\\tilde{P}^{(i)}_t \\;=\\;\n\\begin{cases}\nP^{(i)}_t / s, & \\text{如果 } t &lt; t_s \\text{ 且资产 } i \\text{ 在 } t_s \\text{ 以因子 } s \\text{ 进行拆分}, \\\\\nP^{(i)}_t, & \\text{其他情况},\n\\end{cases}\n$$\n对于2比1的拆分，$s = 2$。如果一项资产没有发生拆分，则对所有 $t$ 都有 $\\tilde{P}^{(i)}_t = P^{(i)}_t$。\n- 对于每一天 $t \\in \\{1,\\dots,T\\}$，使用调整后价格定义资产 $i$ 在第 $t$ 天的简单收益率：\n$$\nR^{(i)}_t \\;=\\; \\frac{\\tilde{P}^{(i)}_t}{\\tilde{P}^{(i)}_{t-1}} - 1.\n$$\n- 令日期 $T$ 的当前调整后价格向量为 $\\tilde{\\mathbf{P}}_T = (\\tilde{P}^{(1)}_T,\\dots,\\tilde{P}^{(N)}_T)$。在历史情景 $t \\in \\{1,\\dots,T\\}$ 下，投资组合的单日损益 (P&amp;L) 为\n$$\n\\Pi_t \\;=\\; \\sum_{i=1}^N h_i \\, \\tilde{P}^{(i)}_T \\, R^{(i)}_t.\n$$\n- 令 $\\{\\Pi_t\\}_{t=1}^T$ 为单日损益情景的经验样本。置信水平 $\\alpha = 0.95$ 的单日历史模拟法VaR为正数\n$$\n\\mathrm{VaR}_{\\alpha} \\;=\\; - Q_p(\\{\\Pi_t\\}),\n$$\n其中 $p = 1 - \\alpha = 0.05$ 且 $Q_p$ 表示由下式定义的左连续经验分位数\n$$\nQ_p(\\{\\Pi_t\\}) \\;=\\; \\Pi_{(k)}, \\quad \\text{其中 } k = \\left\\lceil p \\, T \\right\\rceil,\n$$\n且 $\\Pi_{(1)} \\le \\Pi_{(2)} \\le \\dots \\le \\Pi_{(T)}$ 是样本的顺序统计量。如果 $\\left\\lceil p T \\right\\rceil &lt; 1$，则取 $k = 1$。\n- 所有VaR值必须以与输入价格相同的货币单位（例如，美元）表示，四舍五入到两位小数，并以十进制数形式呈现（不加百分号）。\n\n测试套件：\n对于下方的每个测试用例，请根据上述定义计算置信水平 $\\alpha = 0.95$ 的单日历史模拟法VaR。\n\n- 测试用例 1：\n  - 资产数量 $N = 2$，回溯期长度 $T = 7$。\n  - 资产1在 $t = 0,\\dots,7$ 的记录价格 $P^{(1)}_t$：$[98.0,\\,101.0,\\,99.0,\\,100.0,\\,50.0,\\,51.0,\\,50.5,\\,52.0]$。\n  - 资产2在 $t = 0,\\dots,7$ 的记录价格 $P^{(2)}_t$：$[50.0,\\,49.5,\\,50.5,\\,51.0,\\,50.8,\\,51.4,\\,51.2,\\,52.0]$。\n  - 资产1在日期 $t_s = 4$（即 $t=3$ 和 $t=4$ 之间）发生2比1拆分，因此资产1的 $s=2$，资产2无拆分。\n  - 持股数量：$h_1 = 200$, $h_2 = 100$。\n  - 输出：一个浮点数，表示以货币单位计价并四舍五入到两位小数的VaR。\n\n- 测试用例 2：\n  - 资产数量 $N = 1$，回溯期长度 $T = 4$。\n  - 资产1在 $t = 0,\\dots,4$ 的记录价格 $P^{(1)}_t$：$[120.0,\\,60.0,\\,61.2,\\,60.0,\\,62.4]$。\n  - 资产1在日期 $t_s = 1$ 发生2比1拆分，因此资产1的 $s=2$。\n  - 持股数量：$h_1 = 80$。\n  - 输出：一个浮点数，表示以货币单位计价并四舍五入到两位小数的VaR。\n\n- 测试用例 3：\n  - 资产数量 $N = 3$，回溯期长度 $T = 5$。\n  - 资产1在 $t = 0,\\dots,5$ 的记录价格 $P^{(1)}_t$：$[40.0,\\,41.2,\\,40.8,\\,41.0,\\,41.5,\\,41.0]$。\n  - 资产2在 $t = 0,\\dots,5$ 的记录价格 $P^{(2)}_t$：$[200.0,\\,198.0,\\,199.0,\\,201.0,\\,202.0,\\,200.0]$。\n  - 资产3在 $t = 0,\\dots,5$ 的记录价格 $P^{(3)}_t$：$[10.0,\\,10.1,\\,10.2,\\,10.2,\\,10.1,\\,10.2]$。\n  - 本案例中无任何资产发生拆分。\n  - 持股数量：$h_1 = 100$, $h_2 = 10$, $h_3 = 0$。\n  - 输出：一个浮点数，表示以货币单位计价并四舍五入到两位小数的VaR。\n\n- 测试用例 4：\n  - 资产数量 $N = 2$，回溯期长度 $T = 5$。\n  - 资产1在 $t = 0,\\dots,5$ 的记录价格 $P^{(1)}_t$：$[100.0,\\,102.0,\\,101.0,\\,103.0,\\,104.0,\\,52.0]$。\n  - 资产2在 $t = 0,\\dots,5$ 的记录价格 $P^{(2)}_t$：$[30.0,\\,30.3,\\,29.7,\\,30.0,\\,30.6,\\,30.9]$。\n  - 资产1在日期 $t_s = 5$ 发生2比1拆分，因此资产1的 $s=2$，资产2无拆分。\n  - 持股数量：$h_1 = 150$, $h_2 = 200$。\n  - 输出：一个浮点数，表示以货币单位计价并四舍五入到两位小数的VaR。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试用例1到4的顺序相同，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_j$ 是要求计算并四舍五入到两位小数的VaR。", "solution": "经分析，提交的问题陈述被确定为**有效的**。它在科学上基于金融风险管理的既定原则，特别是用于风险价值 (VaR) 计算的历史模拟 (HS) 方法。该问题是良构的，提供了一套完整且一致的定义、数据和约束，从而能够得出一个唯一且可验证的解。所有术语都经过了精确的数学定义，并且数值示例在物理上和经济上都是合理的。\n\n解决方案通过实施指定的算法来推进，这是一种标准的行业方法。历史模拟法的核心原则是，通过将当前投资组合置于一组历史市场价格变动中，来估计投资组合潜在的单日损益 (P&L) 分布。然后，VaR被确定为该模拟损益分布的一个特定的低端分位数，代表一个在高置信水平下预计不会被超过的潜在损失。\n\n该方法的一个关键先决条件是创建具有经济意义的资产收益率历史。诸如股票拆分之类的公司行为会导致价格水平的机械性变动，这些变动不反映资产标的经济价值的任何变化。为防止这些扭曲污染历史收益率数据，必须进行价格调整。\n\n问题定义了每种资产 $i$ 的调整后价格序列 $\\tilde{P}^{(i)}_t$。对于在日期 $t_s$ 进行 $s$ 比 $1$ 股票拆分的资产，拆分前记录的历史价格 $P^{(i)}_t$（其中 $t < t_s$）将除以拆分因子 $s$。对于2比1的拆分，$s=2$。在拆分日及之后的价格不作调整。用数学术语表示：\n$$\n\\tilde{P}^{(i)}_t =\n\\begin{cases}\nP^{(i)}_t / s, & \\text{如果 } t < t_s \\text{ 且资产 } i \\text{ 在 } t_s \\text{ 以因子 } s \\text{ 进行拆分}, \\\\\nP^{(i)}_t, & \\text{其他情况}。\n\\end{cases}\n$$\n对于没有拆分的资产，所有 $t$ 都有 $\\tilde{P}^{(i)}_t = P^{(i)}_t$。\n\n根据这个一致的调整后价格序列，计算回溯期 $t \\in \\{1, \\dots, T\\}$ 内每种资产 $i$ 的历史简单收益率：\n$$\nR^{(i)}_t = \\frac{\\tilde{P}^{(i)}_t}{\\tilde{P}^{(i)}_{t-1}} - 1.\n$$\n这些收益率代表了价值的真实历史百分比变化。\n\n下一步是生成损益情景。历史情景 $t$ 的损益是通过将历史收益率 $R^{(i)}_t$ 应用于每项持仓的当前市值来计算的。资产 $i$ 持仓的当前价值为 $V_i = h_i \\, P^{(i)}_T$，其中 $h_i$ 是股份数量，$P^{(i)}_T$ 是最后记录的价格。请注意，根据定义，时间 $T$ 的调整后价格 $\\tilde{P}^{(i)}_T$ 总是等于记录价格 $P^{(i)}_T$，因为 $T \\not< t_s$。情景 $t$ 的投资组合损益是所有 $N$ 种资产的损益贡献之和：\n$$\n\\Pi_t = \\sum_{i=1}^N V_i \\, R^{(i)}_t = \\sum_{i=1}^N h_i \\, P^{(i)}_T \\, R^{(i)}_t.\n$$\n对回溯期内的每一天 $t \\in \\{1, \\dots, T\\}$ 进行此计算，从而得到一个包含 $T$ 个潜在损益值的经验样本 $\\{\\Pi_t\\}_{t=1}^T$。\n\n最后，从这个损益分布中提取风险价值。问题将置信水平 $\\alpha = 0.95$ 的单日历史模拟法VaR定义为损益样本的 $p$-分位数的负值，其中 $p = 1 - \\alpha = 0.05$。分位数 $Q_p(\\{\\Pi_t\\})$ 的求解方法是首先将损益样本按升序排序，得到顺序统计量 $\\Pi_{(1)} \\le \\Pi_{(2)} \\le \\dots \\le \\Pi_{(T)}$。然后，分位数是这个排序后样本的第 $k$ 个元素：\n$$\nQ_p(\\{\\Pi_t\\}) = \\Pi_{(k)}, \\quad \\text{其中 } k = \\lceil p T \\rceil.\n$$\n问题指定，如果 $\\lceil p T \\rceil < 1$，则取 $k=1$。VaR随后报告为一个代表损失的正值：\n$$\n\\mathrm{VaR}_{\\alpha} = -Q_p(\\{\\Pi_t\\}).\n$$\n以下是测试用例1的详细计算，用以说明此方法的应用。其余案例通过相同的逻辑求解。\n\n**测试用例1详细计算：**\n- **已知：** $N=2$, $T=7$, $\\alpha=0.95$, $p=0.05$。资产1在 $t_s=4$ 发生2比1拆分 ($s=2$)。\n- **持股数量：** $h_1 = 200$, $h_2 = 100$。\n- **价格：**\n  - $P^{(1)} = [98.0, 101.0, 99.0, 100.0, 50.0, 51.0, 50.5, 52.0]$，其中 $t=0, \\dots, 7$。\n  - $P^{(2)} = [50.0, 49.5, 50.5, 51.0, 50.8, 51.4, 51.2, 52.0]$，其中 $t=0, \\dots, 7$。\n\n1.  **价格调整：** 资产1在 $t \\in \\{0, 1, 2, 3\\}$ 的价格除以 $s=2$。\n    - $\\tilde{P}^{(1)} = [98/2, 101/2, 99/2, 100/2, 50.0, 51.0, 50.5, 52.0] = [49.0, 50.5, 49.5, 50.0, 50.0, 51.0, 50.5, 52.0]$。\n    - 资产2无拆分：$\\tilde{P}^{(2)} = P^{(2)}$。\n\n2.  **收益率计算 ($t=1, \\dots, 7$)：**\n    - $R^{(1)} \\approx [0.03061, -0.01980, 0.01010, 0.00000, 0.02000, -0.00980, 0.02970]$。\n    - $R^{(2)} \\approx [-0.01000, 0.02020, 0.00990, -0.00392, 0.01181, -0.00389, 0.01563]$。\n\n3.  **损益计算：**\n    - 当前价值：$V_1 = h_1 P^{(1)}_7 = 200 \\times 52.0 = 10400$。$V_2 = h_2 P^{(2)}_7 = 100 \\times 52.0 = 5200$。\n    - $\\Pi_t = 10400 \\cdot R^{(1)}_t + 5200 \\cdot R^{(2)}_t$。\n    - $\\{\\Pi_t\\}_{t=1}^7 \\approx [266.37, -100.89, 156.54, -20.39, 269.42, -122.19, 390.16]$。\n\n4.  **VaR计算：**\n    - 排序后的损益：$\\{\\Pi_{(t)}\\}_{t=1}^7 \\approx [-122.19, -100.89, -20.39, 156.54, 266.37, 269.42, 390.16]$。\n    - 索引计算：$k = \\lceil pT \\rceil = \\lceil 0.05 \\times 7 \\rceil = \\lceil 0.35 \\rceil = 1$。\n    - 分位数：$Q_{0.05}(\\{\\Pi_t\\}) = \\Pi_{(1)} \\approx -122.19$。\n    - VaR：$\\mathrm{VaR}_{0.95} = - (-122.19) = 122.19$。四舍五入到两位小数后，VaR为 $122.19$。\n\n其他测试用例的计算遵循相同的程序，得出最终的合并结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_var(prices_unadjusted, holdings, splits, T, alpha):\n    \"\"\"\n    Computes the one-day Historical Simulation VaR for a given portfolio.\n\n    Args:\n        prices_unadjusted (list of list of floats): A list where each element is a list of\n            unadjusted closing prices for an asset, from t=0 to T.\n        holdings (list of floats): Number of shares held for each asset.\n        splits (dict): A dictionary mapping asset index (0-based) to a tuple\n            (split_date, split_factor).\n        T (int): The lookback period in days for calculating returns.\n        alpha (float): The confidence level for VaR.\n\n    Returns:\n        float: The calculated VaR, rounded to 2 decimal places.\n    \"\"\"\n    N = len(holdings)\n    p = 1.0 - alpha\n\n    # Step 1: Adjust prices for stock splits\n    prices_adjusted = []\n    for i in range(N):\n        p_asset = np.array(prices_unadjusted[i], dtype=float)\n        if i in splits:\n            t_s, s = splits[i]\n            # Prices before the split date are adjusted.\n            # a_s is 1-based index in problem, convert to 0-based\n            if t_s > 0:\n                p_asset[:t_s] /= s\n        prices_adjusted.append(p_asset)\n\n    prices_adjusted = np.array(prices_adjusted)\n\n    # Step 2: Calculate historical simple returns\n    # prices_adjusted is N x (T+1). Returns will be N x T.\n    # returns[:, t] corresponds to R_{t+1}\n    returns = prices_adjusted[:, 1:] / prices_adjusted[:, :-1] - 1\n\n    # Step 3: Calculate portfolio P&L scenarios\n    # Get current prices (at time T)\n    current_prices = prices_adjusted[:, -1]\n    \n    # Calculate current values of holdings\n    current_values = np.array(holdings) * current_prices\n    \n    # Calculate P&L for each historical day t = 1..T\n    # The shape of returns.T is T x N. The shape of current_values is N.\n    # The dot product for each row of returns.T gives the P&L for that day.\n    pnl_scenarios = returns.T.dot(current_values)\n\n    # Step 4: Calculate VaR from the P&L distribution\n    # Sort P&L scenarios in ascending order\n    sorted_pnl = np.sort(pnl_scenarios)\n\n    # Calculate the index k for the quantile\n    # Per problem: k = ceil(p*T). If < 1, take k=1.\n    k = int(np.ceil(p * T))\n    if k < 1:\n        k = 1\n    \n    # Get the quantile. In a 0-indexed array, this is element k-1.\n    quantile = sorted_pnl[k - 1]\n\n    # VaR is the negative of the quantile, representing a loss\n    var = -quantile\n    \n    return var\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases from the problem statement.\n    \"\"\"\n    test_cases = [\n        {\n            \"prices\": [\n                [98.0, 101.0, 99.0, 100.0, 50.0, 51.0, 50.5, 52.0],\n                [50.0, 49.5, 50.5, 51.0, 50.8, 51.4, 51.2, 52.0]\n            ],\n            \"holdings\": [200, 100],\n            \"splits\": {0: (4, 2)},  # Asset 1 (index 0) splits at t=4\n            \"T\": 7,\n            \"alpha\": 0.95\n        },\n        {\n            \"prices\": [\n                [120.0, 60.0, 61.2, 60.0, 62.4]\n            ],\n            \"holdings\": [80],\n            \"splits\": {0: (1, 2)},  # Asset 1 (index 0) splits at t=1\n            \"T\": 4,\n            \"alpha\": 0.95\n        },\n        {\n            \"prices\": [\n                [40.0, 41.2, 40.8, 41.0, 41.5, 41.0],\n                [200.0, 198.0, 199.0, 201.0, 202.0, 200.0],\n                [10.0, 10.1, 10.2, 10.2, 10.1, 10.2]\n            ],\n            \"holdings\": [100, 10, 0],\n            \"splits\": {}, # No splits\n            \"T\": 5,\n            \"alpha\": 0.95\n        },\n        {\n            \"prices\": [\n                [100.0, 102.0, 101.0, 103.0, 104.0, 52.0],\n                [30.0, 30.3, 29.7, 30.0, 30.6, 30.9]\n            ],\n            \"holdings\": [150, 200],\n            \"splits\": {0: (5, 2)},  # Asset 1 (index 0) splits at t=5\n            \"T\": 5,\n            \"alpha\": 0.95\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_var(\n            case[\"prices\"],\n            case[\"holdings\"],\n            case[\"splits\"],\n            case[\"T\"],\n            case[\"alpha\"]\n        )\n        results.append(result)\n\n    # Format output to ensure two decimal places are always shown\n    formatted_results = [f'{r:.2f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "标准历史模拟法的一个著名弱点是它对市场波动的变化反应迟缓。为了解决这个问题，本高级练习 [@problem_id:2400188] 介绍了一种强大的增强模型：滤波历史模拟 (Filtered Historical Simulation, $FHS$)。这种混合方法将 $GARCH$ 模型的波动率预测能力与历史数据的非参数优势相结合，让你学会构建一个更具动态性和稳健性的 $VaR$ 模型。", "id": "2400188", "problem": "给定若干每日对数回报率的有限序列以及一个阶为 $(1,1)$ 的广义自回归条件异方差（GARCH）模型的参数值。对于每个序列和参数集，为一个当前价值等于一个货币单位的投资组合，计算在指定尾部概率下的向前一步滤波历史模拟法风险价值（VaR）。将每个VaR报告为一个以货币单位表示的非负实数。\n\n对于单位价值的投资组合，在尾部概率 $\\alpha$ 下的滤波历史模拟法VaR定义如下。设观测到的对数回报率为 $\\{r_0,\\dots,r_{T-1}\\}$，其中 $T \\geq 1$。设条件方差根据GARCH$(1,1)$递归式演化\n$$\n\\sigma_{i+1}^2 \\;=\\; \\omega \\;+\\; \\alpha \\, r_i^2 \\;+\\; \\beta \\, \\sigma_i^2 \\quad \\text{for } i=0,1,\\dots,T-1,\n$$\n初始方差为 $\\sigma_0^2 = s_0$，其中 $\\omega \\ge 0$、$\\alpha \\ge 0$、$\\beta \\ge 0$ 且 $\\alpha + \\beta < 1$。通过下式定义滤波（标准化）回报率\n$$\nz_i \\;=\\; \\frac{r_i}{\\sigma_i} \\quad \\text{for } i=0,1,\\dots,T-1,\n$$\n其中 $\\sigma_i = \\sqrt{\\sigma_i^2}$。向前一步的条件标准差为 $\\sigma_T = \\sqrt{\\sigma_T^2}$，其中 $\\sigma_T^2$ 通过上述递归式获得。构建下一日回报率的缩放情景集为\n$$\n\\{\\tilde{r}_i\\}_{i=0}^{T-1}, \\quad \\text{where } \\tilde{r}_i = \\sigma_T \\, z_i.\n$$\n令 $N = T$ 表示情景数量。将情景按非递减顺序排序，得到 $\\tilde{r}_{(1)} \\le \\tilde{r}_{(2)} \\le \\dots \\le \\tilde{r}_{(N)}$。通过最近秩规则定义经验下$\\alpha$分位数\n$$\nk \\;=\\; \\max\\{1, \\lceil \\alpha N \\rceil\\}, \\qquad q_\\alpha \\;=\\; \\tilde{r}_{(k)}.\n$$\n对于单位价值的投资组合，在尾部概率 $\\alpha$ 下的滤波历史模拟法 VaR 为\n$$\nV_\\alpha \\;=\\; -\\, q_\\alpha.\n$$\n以货币单位报告 $V_\\alpha$，表示为一个四舍五入到六位小数的实数。\n\n使用上述定义为以下每个测试用例计算 $V_\\alpha$。所有对数回报率均为无量纲（每日对数回报率），所有VaR输出必须以每单位投资组合价值的货币单位表示，并四舍五入到六位小数。尾部概率必须以小数形式表示。\n\n测试套件：\n\n- 测试用例A（一般情况）：\n  - 回报率 $\\{r_i\\}_{i=0}^{39}$：\n    $0.0042$, $-0.0061$, $0.0015$, $0.0023$, $-0.0038$, $0.0095$, $-0.0123$, $0.0071$, $-0.0022$, $0.0009$, $-0.0047$, $0.0033$, $0.0028$, $-0.0019$, $0.0056$, $-0.0082$, $0.0104$, $-0.0067$, $0.0011$, $-0.0026$, $0.0039$, $-0.0041$, $0.0062$, $-0.0008$, $0.0017$, $-0.0059$, $0.0044$, $-0.0031$, $0.0021$, $-0.0075$, $0.0089$, $-0.0064$, $0.0005$, $0.0012$, $-0.0029$, $0.0031$, $-0.0045$, $0.0026$, $-0.0014$, $0.0020$。\n  - 参数：$\\omega = 0.000001$, $\\alpha = 0.07$, $\\beta = 0.92$, $s_0 = 0.0001$。\n  - 尾部概率：$\\alpha = 0.05$。\n\n- 测试用例B（小样本，边界最近秩）：\n  - 回报率 $\\{r_i\\}_{i=0}^{11}$：\n    $-0.0020$, $0.0015$, $-0.0010$, $0.0007$, $-0.0035$, $0.0021$, $-0.0009$, $0.0012$, $-0.0048$, $0.0004$, $0.0009$, $-0.0022$。\n  - 参数：$\\omega = 0.000002$, $\\alpha = 0.10$, $\\beta = 0.85$, $s_0 = 0.00008$。\n  - 尾部概率：$\\alpha = 0.10$。\n\n- 测试用例C（高波动率聚集，极值尾部）：\n  - 回报率 $\\{r_i\\}_{i=0}^{29}$：\n    $0.0150$, $-0.0220$, $0.0080$, $-0.0120$, $0.0060$, $-0.0180$, $0.0110$, $-0.0090$, $0.0050$, $-0.0130$, $0.0170$, $-0.0210$, $0.0090$, $-0.0140$, $0.0070$, $-0.0190$, $0.0120$, $-0.0110$, $0.0060$, $-0.0160$, $0.0180$, $-0.0240$, $0.0100$, $-0.0200$, $0.0080$, $-0.0150$, $0.0070$, $-0.0170$, $0.0130$, $-0.0180$。\n  - 参数：$\\omega = 0.000005$, $\\alpha = 0.08$, $\\beta = 0.91$, $s_0 = 0.0002$。\n  - 尾部概率：$\\alpha = 0.01$。\n\n- 测试用例D（低波动率，平滑动态）：\n  - 回报率 $\\{r_i\\}_{i=0}^{19}$：\n    $0.0004$, $-0.0006$, $0.0003$, $-0.0002$, $0.0005$, $-0.0004$, $0.0006$, $-0.0003$, $0.0002$, $-0.0005$, $0.0004$, $-0.0001$, $0.0003$, $-0.0002$, $0.0001$, $-0.0004$, $0.0005$, $-0.0002$, $0.0003$, $-0.0003$。\n  - 参数：$\\omega = 0.0000005$, $\\alpha = 0.05$, $\\beta = 0.90$, $s_0 = 0.00003$。\n  - 尾部概率：$\\alpha = 0.05$。\n\n您的程序必须按A、B、C、D的顺序为每个测试用例计算 $V_\\alpha$，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $\\texttt{[v_A,v_B,v_C,v_D]}$。每个值必须四舍五入到六位小数。", "solution": "该问题被确定为有效。它在科学上是合理的，提法明确，并提供了计算所要求数量的所有必要信息。任务是使用GARCH($1$,$1$)模型对波动率进行建模，为几个对数回报率时间序列计算向前一步的滤波历史模拟法风险价值（VaR）。\n\n该方法遵循问题陈述中提供的精确定义。设 $T$ 个观测对数回报率的集合为 $\\{r_i\\}_{i=0}^{T-1}$。条件方差 $\\sigma_i^2$ 使用GARCH($1$,$1$)过程进行建模。为避免与GARCH参数 $\\alpha$ 混淆，用于VaR计算的尾部概率将表示为 $\\alpha_{\\text{tail}}$。条件方差的递归从初始值 $\\sigma_0^2 = s_0$ 开始，按如下方式进行：\n$$\n\\sigma_{i+1}^2 \\;=\\; \\omega \\;+\\; \\alpha \\, r_i^2 \\;+\\; \\beta \\, \\sigma_i^2 \\quad \\text{for } i=0,1,\\dots,T-1\n$$\n参数 $\\omega$、$\\alpha$ 和 $\\beta$ 是给定的常数，满足 $\\omega \\ge 0$、$\\alpha \\ge 0$、$\\beta \\ge 0$ 以及 $\\alpha + \\beta < 1$，这确保了方差的非负性和过程的平稳性。\n\n在每一步 $i$，通过将观测到的对数回报率 $r_i$ 除以条件标准差 $\\sigma_i = \\sqrt{\\sigma_i^2}$，来计算标准化（或滤波）回报率 $z_i$：\n$$\nz_i \\;=\\; \\frac{r_i}{\\sigma_i}\n$$\n对从 $i=0$到 $i=T-1$ 的所有 $T$ 个回报率重复此过程，从而得到一系列标准化回报率 $\\{z_i\\}_{i=0}^{T-1}$ 和向前一步的条件方差预测 $\\sigma_T^2$。相应的标准差为 $\\sigma_T = \\sqrt{\\sigma_T^2}$。\n\n滤波历史模拟法的核心是通过将当前的波动率预测与标准化回报率的历史分布相结合，来构建下一日回报率的一组情景。通过使用向前一步的波动率预测 $\\sigma_T$ 对历史滤波回报率 $\\{z_i\\}$ 进行重新缩放，生成情景 $\\{\\tilde{r}_i\\}_{i=0}^{T-1}$：\n$$\n\\tilde{r}_i = \\sigma_T \\, z_i\n$$\n这将为潜在的下一日回报率创建 $N=T$ 个情景。\n\n为了找到VaR，将这 $N$ 个情景按非递减顺序排序，形成有序集 $\\{\\tilde{r}_{(1)}, \\tilde{r}_{(2)}, \\dots, \\tilde{r}_{(N)}\\}$。此经验分布的下$\\alpha_{\\text{tail}}$分位数 $q_{\\alpha_{\\text{tail}}}$ 使用最近秩法找到。秩指数 $k$ 计算如下：\n$$\nk \\;=\\; \\max\\{1, \\lceil \\alpha_{\\text{tail}} N \\rceil\\}\n$$\n分位数即为排序后情景中的第 $k$ 个元素：\n$$\nq_\\alpha \\;=\\; \\tilde{r}_{(k)}\n$$\n最后，对于价值为 1 货币单位的投资组合，在 $\\alpha_{\\text{tail}}$ 置信水平下的一日风险价值是该分位数的负值：\n$$\nV_{\\alpha_{\\text{tail}}} \\;=\\; -\\, q_\\alpha\n$$\n结果以货币单位报告为一个非负数，四舍五入到六位小数。该过程按规定应用于每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the one-day-ahead filtered historical simulation VaR for multiple test cases.\n    \"\"\"\n\n    def calculate_fhs_var(returns, omega, alpha_garch, beta, s0, alpha_tail):\n        \"\"\"\n        Calculates the Filtered Historical Simulation VaR using a GARCH(1,1) model.\n\n        Args:\n            returns (list): Sequence of daily log-returns.\n            omega (float): GARCH(1,1) omega parameter.\n            alpha_garch (float): GARCH(1,1) alpha parameter.\n            beta (float): GARCH(1,1) beta parameter.\n            s0 (float): Initial variance, sigma_0^2.\n            alpha_tail (float): Tail probability for VaR calculation.\n\n        Returns:\n            float: The calculated VaR, rounded to six decimal places.\n        \"\"\"\n        T = len(returns)\n        returns_arr = np.array(returns, dtype=float)\n\n        # Array to store conditional variances sigma_i^2\n        variances = np.zeros(T + 1)\n        variances[0] = s0\n\n        # Array to store standardized returns z_i\n        std_returns = np.zeros(T)\n\n        # GARCH filtering loop\n        for i in range(T):\n            sigma_i_sq = variances[i]\n            r_i = returns_arr[i]\n\n            # sigma_i is guaranteed to be positive due to omega >= 0, alpha >= 0, beta >= 0 and s0 > 0.\n            sigma_i = np.sqrt(sigma_i_sq)\n            \n            std_returns[i] = r_i / sigma_i\n\n            variances[i+1] = omega + alpha_garch * (r_i**2) + beta * sigma_i_sq\n\n        # One-step-ahead volatility forecast\n        sigma_T_sq = variances[T]\n        sigma_T = np.sqrt(sigma_T_sq)\n\n        # Generate scaled scenarios\n        scaled_scenarios = sigma_T * std_returns\n\n        # Sort scenarios to find the quantile\n        scaled_scenarios.sort()\n\n        # Calculate quantile using the nearest-rank rule\n        N = T\n        # k is the 1-based rank\n        k = int(max(1, np.ceil(alpha_tail * N)))\n        # q_alpha is the k-th smallest scenario (using 0-based index k-1)\n        q_alpha = scaled_scenarios[k - 1]\n\n        # VaR is the negative of the quantile\n        var_alpha = -q_alpha\n\n        return var_alpha\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"returns\": [\n                0.0042, -0.0061, 0.0015, 0.0023, -0.0038, 0.0095, -0.0123, 0.0071, -0.0022, 0.0009, \n                -0.0047, 0.0033, 0.0028, -0.0019, 0.0056, -0.0082, 0.0104, -0.0067, 0.0011, -0.0026, \n                0.0039, -0.0041, 0.0062, -0.0008, 0.0017, -0.0059, 0.0044, -0.0031, 0.0021, -0.0075, \n                0.0089, -0.0064, 0.0005, 0.0012, -0.0029, 0.0031, -0.0045, 0.0026, -0.0014, 0.0020\n            ],\n            \"params\": {\"omega\": 0.000001, \"alpha_garch\": 0.07, \"beta\": 0.92, \"s0\": 0.0001},\n            \"alpha_tail\": 0.05\n        },\n        {\n            \"returns\": [\n                -0.0020, 0.0015, -0.0010, 0.0007, -0.0035, 0.0021, -0.0009, 0.0012, -0.0048, 0.0004, \n                0.0009, -0.0022\n            ],\n            \"params\": {\"omega\": 0.000002, \"alpha_garch\": 0.10, \"beta\": 0.85, \"s0\": 0.00008},\n            \"alpha_tail\": 0.10\n        },\n        {\n            \"returns\": [\n                0.0150, -0.0220, 0.0080, -0.0120, 0.0060, -0.0180, 0.0110, -0.0090, 0.0050, -0.0130, \n                0.0170, -0.0210, 0.0090, -0.0140, 0.0070, -0.0190, 0.0120, -0.0110, 0.0060, -0.0160, \n                0.0180, -0.0240, 0.0100, -0.0200, 0.0080, -0.0150, 0.0070, -0.0170, 0.0130, -0.0180\n            ],\n            \"params\": {\"omega\": 0.000005, \"alpha_garch\": 0.08, \"beta\": 0.91, \"s0\": 0.0002},\n            \"alpha_tail\": 0.01\n        },\n        {\n            \"returns\": [\n                0.0004, -0.0006, 0.0003, -0.0002, 0.0005, -0.0004, 0.0006, -0.0003, 0.0002, -0.0005, \n                0.0004, -0.0001, 0.0003, -0.0002, 0.0001, -0.0004, 0.0005, -0.0002, 0.0003, -0.0003\n            ],\n            \"params\": {\"omega\": 0.0000005, \"alpha_garch\": 0.05, \"beta\": 0.90, \"s0\": 0.00003},\n            \"alpha_tail\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        var_result = calculate_fhs_var(case[\"returns\"], **case[\"params\"], alpha_tail=case[\"alpha_tail\"])\n        # Format the result to exactly six decimal places\n        results.append(f\"{var_result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}