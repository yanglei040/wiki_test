{"hands_on_practices": [{"introduction": "在金融实践中，资产收益并非完全随机，其波动往往可以由一些系统性经济因子来解释。本练习将引导你将线性因子模型（如 Fama-French 模型）整合到条件风险价值（CVaR）优化框架中 [@problem_id:2382483]。你将学习如何基于因子收益构建资产的收益情景，然后在满足最低预期收益要求的同时，最小化投资组合的尾部风险。这项实践练习旨在连接理论因子模型与实际的投资组合风险管理，为构建和优化基于宏观经济驱动因素的投资组合提供坚实的基础。", "id": "2382483", "problem": "实现一个完整的程序，从基本原理出发解决以下优化问题。\n\n给定一个资产收益的线性因子模型。有 $n = 4$ 种资产和 $k = 3$ 个系统性因子。在情景 $s \\in \\{1,\\dots,S\\}$（其中 $S=12$）下，资产收益被建模为\n$$\nr_{i,s} = \\boldsymbol{b}_i^{\\top} \\boldsymbol{f}_s + e_{i,s},\n$$\n其中 $\\boldsymbol{b}_i \\in \\mathbb{R}^k$ 是资产 $i$ 的因子载荷向量，$\\boldsymbol{f}_s \\in \\mathbb{R}^k$ 是情景 $s$ 下的因子收益向量，而 $e_{i,s} \\in \\mathbb{R}$ 是情景 $s$ 下资产 $i$ 的特异性残差。预期因子收益向量为 $\\boldsymbol{\\mu}_f \\in \\mathbb{R}^k$，并且对于所有的 $i,s$，都有 $\\mathbb{E}[e_{i,s}] = 0$。投资组合权重向量为 $\\boldsymbol{w} \\in \\mathbb{R}^n$，受限于只做多和全额投资约束：\n$$\n\\sum_{i=1}^n w_i = 1,\\quad w_i \\ge 0 \\text{ for all } i.\n$$\n情景 $s$ 下的投资组合收益为\n$$\nr_{p,s} = \\sum_{i=1}^n w_i r_{i,s},\n$$\n投资组合的预期收益为\n$$\n\\mathbb{E}[r_p] = \\sum_{i=1}^n w_i \\mathbb{E}[r_i] = \\sum_{i=1}^n w_i \\boldsymbol{b}_i^{\\top} \\boldsymbol{\\mu}_f.\n$$\n将情景 $s$ 下的投资组合损失定义为 $L_s = -r_{p,s}$。对于一个置信水平 $\\alpha \\in (0,1)$，水平为 $\\alpha$ 的在险价值 (VaR) 是 $\\{L_s\\}_{s=1}^S$ 的 $\\alpha$-分位数，而水平为 $\\alpha$ 的条件在险价值 (CVaR) 是损失超过 VaR 时的条件期望损失：\n$$\n\\text{CVaR}_\\alpha(L) = \\mathbb{E}[L \\mid L \\ge \\text{VaR}_\\alpha(L)].\n$$\n您的任务是，对于每个给定的测试用例 $(\\alpha, r_{\\min})$，计算在所有满足约束条件和最低预期收益要求\n$$\n\\mathbb{E}[r_p] \\ge r_{\\min}\n$$\n的可行 $\\boldsymbol{w}$ 中，可能的最小 $\\text{CVaR}_\\alpha(L)$。\n使用以下数据，这些数据必须被视为精确值：\n\n- 资产数量 $n = 4$，因子数量 $k = 3$，情景数量 $S = 12$。\n\n- 因子载荷矩阵 $\\mathbf{B} \\in \\mathbb{R}^{n \\times k}$，其行向量为 $\\boldsymbol{b}_i^{\\top}$：\n$$\n\\mathbf{B} =\n\\begin{bmatrix}\n1.1 & 0.3 & 0.2 \\\\\n0.9 & 0.1 & -0.1 \\\\\n1.4 & -0.2 & 0.5 \\\\\n0.7 & 0.5 & 0.0\n\\end{bmatrix}.\n$$\n\n- 预期因子收益向量 $\\boldsymbol{\\mu}_f \\in \\mathbb{R}^k$：\n$$\n\\boldsymbol{\\mu}_f = \\begin{bmatrix} 0.004 \\\\ 0.003 \\\\ 0.002 \\end{bmatrix}.\n$$\n\n- 因子收益情景矩阵 $\\mathbf{F} \\in \\mathbb{R}^{S \\times k}$，其行向量为 $\\boldsymbol{f}_s^{\\top}$，$s=1,\\dots,12$：\n$$\n\\mathbf{F} =\n\\begin{bmatrix}\n0.015 & 0.010 & 0.005 \\\\\n-0.020 & -0.015 & -0.010 \\\\\n0.025 & 0.005 & 0.000 \\\\\n0.010 & -0.005 & 0.004 \\\\\n-0.030 & 0.020 & -0.005 \\\\\n0.005 & 0.000 & 0.007 \\\\\n0.018 & -0.012 & 0.003 \\\\\n-0.012 & 0.018 & 0.006 \\\\\n0.022 & 0.012 & -0.004 \\\\\n-0.015 & -0.008 & 0.002 \\\\\n0.008 & 0.006 & -0.006 \\\\\n-0.005 & 0.004 & 0.009\n\\end{bmatrix}.\n$$\n\n- 特异性残差矩阵 $\\mathbf{E} \\in \\mathbb{R}^{S \\times n}$，其元素 $e_{i,s}$ 排列成 $s=1,\\dots,12$ 行和 $i=1,\\dots,4$ 列：\n$$\n\\mathbf{E} =\n\\begin{bmatrix}\n0.0010 & -0.0010 & 0.0005 & -0.0005 \\\\\n-0.0020 & 0.0010 & -0.0005 & 0.0005 \\\\\n0.0000 & -0.0020 & 0.0010 & -0.0010 \\\\\n0.0010 & 0.0010 & -0.0010 & 0.0010 \\\\\n-0.0010 & 0.0020 & 0.0000 & 0.0000 \\\\\n0.0000 & -0.0010 & 0.0005 & -0.0005 \\\\\n0.0020 & 0.0000 & -0.0005 & 0.0005 \\\\\n-0.0010 & -0.0020 & 0.0010 & -0.0010 \\\\\n0.0010 & 0.0010 & -0.0010 & 0.0010 \\\\\n-0.0010 & 0.0000 & 0.0000 & 0.0000 \\\\\n0.0000 & 0.0010 & 0.0005 & -0.0005 \\\\\n0.0010 & -0.0010 & -0.0005 & 0.0005\n\\end{bmatrix}.\n$$\n\n对于每个测试用例 $(\\alpha, r_{\\min})$，构建情景资产收益矩阵 $\\mathbf{R} \\in \\mathbb{R}^{S \\times n}$ 如下：\n$$\n\\mathbf{R} = \\mathbf{F} \\mathbf{B}^{\\top} + \\mathbf{E},\n$$\n计算 $r_{p,s} = \\sum_{i=1}^n w_i R_{s,i}$，定义 $L_s = - r_{p,s}$，并找出在所有满足约束条件和 $\\mathbb{E}[r_p] \\ge r_{\\min}$ 的 $\\boldsymbol{w}$ 中可实现的最小 $\\text{CVaR}_\\alpha(L)$。\n\n测试套件（四个测试用例），每个用例包含 $(\\alpha, r_{\\min})$：\n- 用例 1：$(0.95,\\ 0.003)$。\n- 用例 2：$(0.99,\\ 0.000)$。\n- 用例 3：$(0.90,\\ 0.004)$。\n- 用例 4：$(0.95,\\ 0.006)$。\n\n您的程序应为每个用例计算最小化的 $\\text{CVaR}_\\alpha(L)$，结果为一个实数。最终输出格式必须是单行，包含一个用方括号括起来的逗号分隔列表，结果顺序与测试用例的顺序相同（例如，$[x_1,x_2,x_3,x_4]$）。不需要单位。所有数值答案必须以十进制小数形式打印。", "solution": "用户提供了一个明确定义的计算金融问题。任务是找到在满足一组约束条件下的资产投资组合的最小条件在险价值 (CVaR)。这是一个经典的投资组合优化问题，可以被表述和求解为线性规划 (LP)。\n\n### 步骤 1：问题验证\n\n第一步是验证问题陈述。\n\n**提取的已知条件：**\n- **模型参数**：资产数量 $n = 4$，因子数量 $k = 3$，情景数量 $S = 12$。\n- **资产收益模型**：$r_{i,s} = \\boldsymbol{b}_i^{\\top} \\boldsymbol{f}_s + e_{i,s}$。\n- **数据矩阵和向量**：因子载荷矩阵 $\\mathbf{B} \\in \\mathbb{R}^{4 \\times 3}$，预期因子收益向量 $\\boldsymbol{\\mu}_f \\in \\mathbb{R}^3$，因子收益情景矩阵 $\\mathbf{F} \\in \\mathbb{R}^{12 \\times 3}$，以及特异性残差矩阵 $\\mathbf{E} \\in \\mathbb{R}^{12 \\times 4}$。所有数值均已提供。\n- **投资组合约束**：只做多（对于 $i=1,\\dots,n$，$w_i \\ge 0$）和全额投资（$\\sum_{i=1}^n w_i = 1$）。\n- **目标**：最小化 $\\text{CVaR}_\\alpha(L)$，其中 $L_s = -r_{p,s} = -\\sum_{i=1}^n w_i r_{i,s}$ 是情景 $s$ 下的投资组合损失。\n- **业绩约束**：投资组合的预期收益 $\\mathbb{E}[r_p] = \\sum_{i=1}^n w_i \\boldsymbol{b}_i^{\\top} \\boldsymbol{\\mu}_f$ 必须满足 $\\mathbb{E}[r_p] \\ge r_{\\min}$。\n- **测试用例**：提供了四对 $(\\alpha, r_{\\min})$ 用于计算。\n\n**验证结论：**\n该问题是**有效的**。\n1.  **科学基础**：该问题基于标准的资产收益线性因子模型，并使用了条件在险价值 (CVaR)，这是现代投资组合理论中一种一致且被广泛接受的风险度量。最小化 CVaR 是金融工程中的一个基本任务。\n2.  **适定性**：该问题被构建为一个凸优化问题，具体来说是一个线性规划。约束条件为投资组合权重定义了一个非空、凸且紧的可行集。目标函数是线性的。因此，存在唯一且稳定的解。所有必要的数据都已提供。\n3.  **客观性**：问题陈述使用了精确、无歧义的数学术语，不含任何主观或推测性内容。\n\n该问题是合理的，可以使用已建立的数学方法来解决。\n\n### 步骤 2：基于基本原理的线性规划解法\n\n问题的核心是基于一个包含 $S$ 个离散情景的集合来最小化 CVaR。这可以被表述为一个线性规划。\n\n**A. 金融数据预处理**\n\n首先，我们从给定数据中计算两个关键量：\n1.  预期资产收益向量 $\\boldsymbol{\\mu}_r \\in \\mathbb{R}^n$。由于 $\\mathbb{E}[e_{i,s}]=0$，资产 $i$ 的预期收益为 $\\mathbb{E}[r_i] = \\boldsymbol{b}_i^{\\top} \\boldsymbol{\\mu}_f$。用矩阵表示为：\n    $$\n    \\boldsymbol{\\mu}_r = \\mathbf{B} \\boldsymbol{\\mu}_f\n    $$\n2.  基于情景的资产收益矩阵 $\\mathbf{R} \\in \\mathbb{R}^{S \\times n}$。元素 $R_{s,i}$ 是资产 $i$ 在情景 $s$ 下的收益。用矩阵表示为：\n    $$\n    \\mathbf{R} = \\mathbf{F} \\mathbf{B}^{\\top} + \\mathbf{E}\n    $$\n    投资组合在情景 $s$ 下的收益由 $r_{p,s} = \\boldsymbol{R}_s^{\\top} \\boldsymbol{w}$ 给出，其中 $\\boldsymbol{R}_s^{\\top}$ 是矩阵 $\\mathbf{R}$ 的第 $s$ 行。投资组合损失为 $L_s = -r_{p,s}$。\n\n**B. CVaR 最小化的线性规划表述**\n\n对于一组具有相等概率 $1/S$ 的 $S$ 个情景，置信水平为 $\\alpha$ 的 CVaR 可以通过求解以下优化问题找到：\n$$\n\\text{CVaR}_\\alpha(L) = \\min_{\\zeta \\in \\mathbb{R}} \\left( \\zeta + \\frac{1}{S(1-\\alpha)} \\sum_{s=1}^S \\max(0, L_s - \\zeta) \\right)\n$$\n在这里，$\\zeta$ 是一个优化变量，对应于在险价值 (VaR)。为了使该问题适用于线性规划求解器，我们引入一个辅助变量向量 $\\boldsymbol{z} \\in \\mathbb{R}^S$，其中每个 $z_s$ 代表超过 $\\zeta$ 的损失，即 $z_s \\ge \\max(0, L_s - \\zeta)$。\n\n我们的目标是通过选择投资组合权重 $\\boldsymbol{w}$ 来最小化 CVaR。完整的优化问题包括找到最优的 $\\boldsymbol{w}$、$\\zeta$ 和 $\\boldsymbol{z}$。该问题变为：\n\n$$\n\\min_{\\boldsymbol{w}, \\zeta, \\boldsymbol{z}} \\quad \\zeta + \\frac{1}{S(1-\\alpha)} \\sum_{s=1}^S z_s\n$$\n受限于以下线性约束：\n\n1.  **超额损失约束**：对于每个情景 $s=1, \\dots, S$，变量 $z_s$ 必须捕捉超过 $\\zeta$ 的损失：\n    $$\n    z_s \\ge L_s - \\zeta \\implies z_s \\ge -(\\mathbf{R}_s^{\\top} \\boldsymbol{w}) - \\zeta\n    $$\n    这等价于：$-\\boldsymbol{R}_s^{\\top} \\boldsymbol{w} - \\zeta - z_s \\le 0$。\n2.  **超额损失的非负性**：\n    $$\n    z_s \\ge 0\n    $$\n3.  **全额投资约束**：权重之和必须为 1。\n    $$\n    \\sum_{i=1}^n w_i = 1\n    $$\n4.  **只做多约束**：所有投资组合权重必须为非负。\n    $$\n    w_i \\ge 0 \\quad \\text{for } i=1, \\dots, n\n    $$\n5.  **最低预期收益约束**：投资组合的预期收益必须满足指定的最低要求。\n    $$\n    \\mathbb{E}[r_p] = \\boldsymbol{\\mu}_r^{\\top} \\boldsymbol{w} \\ge r_{\\min}\n    $$\n    这等价于：$-\\boldsymbol{\\mu}_r^{\\top} \\boldsymbol{w} \\le -r_{\\min}$。\n\n**C. 标准线性规划形式**\n\n这个问题可以被转换成标准线性规划形式 $\\min \\boldsymbol{c}^{\\top}\\boldsymbol{x}$，约束条件为 $\\mathbf{A}_{ub}\\boldsymbol{x} \\le \\boldsymbol{b}_{ub}$ 和 $\\mathbf{A}_{eq}\\boldsymbol{x} = \\boldsymbol{b}_{eq}$，并对 $\\boldsymbol{x}$ 有边界限制。\n\n-   **决策变量向量**：我们定义一个决策变量的单一向量 $\\boldsymbol{x} \\in \\mathbb{R}^{n+1+S}$：\n    $$\n    \\boldsymbol{x} = [\\boldsymbol{w}^{\\top}, \\zeta, \\boldsymbol{z}^{\\top}]^{\\top} = [w_1, \\dots, w_n, \\zeta, z_1, \\dots, z_S]^{\\top}\n    $$\n-   **目标函数向量**：向量 $\\boldsymbol{c} \\in \\mathbb{R}^{n+1+S}$ 定义了目标函数：\n    $$\n    \\boldsymbol{c} = [0, \\dots, 0, 1, \\frac{1}{S(1-\\alpha)}, \\dots, \\frac{1}{S(1-\\alpha)}]^{\\top}\n    $$\n    （其中有 $n$ 个初始零）。\n-   **等式约束**：全额投资约束是唯一的等式：$\\mathbf{A}_{eq}\\boldsymbol{x} = \\boldsymbol{b}_{eq}$，其中：\n    $$\n    \\mathbf{A}_{eq} = [\\underbrace{1, \\dots, 1}_{n}, \\underbrace{0, \\dots, 0}_{1+S}] \\quad \\text{and} \\quad \\boldsymbol{b}_{eq} = [1]\n    $$\n-   **不等式约束**：关于超额损失和最低回报的约束构成了不等式 $\\mathbf{A}_{ub}\\boldsymbol{x} \\le \\boldsymbol{b}_{ub}$。矩阵 $\\mathbf{A}_{ub} \\in \\mathbb{R}^{(S+1) \\times (n+1+S)}$ 和向量 $\\boldsymbol{b}_{ub} \\in \\mathbb{R}^{S+1}$ 的结构如下：\n    - 对于行 $s=1, \\dots, S$（来自约束 1）：\n      $$\n      (\\mathbf{A}_{ub})_{s,j} = \\begin{cases} -R_{s,j} & 1 \\le j \\le n \\\\ -1 & j = n+1 \\\\ -1 & j = n+1+s \\\\ 0 & \\text{otherwise} \\end{cases}, \\quad (\\boldsymbol{b}_{ub})_s = 0\n      $$\n    - 对于行 $S+1$（来自约束 5）：\n      $$\n      (\\mathbf{A}_{ub})_{S+1,j} = \\begin{cases} -(\\boldsymbol{\\mu}_r)_j & 1 \\le j \\le n \\\\ 0 & \\text{otherwise} \\end{cases}, \\quad (\\boldsymbol{b}_{ub})_{S+1} = -r_{\\min}\n      $$\n-   **边界**：对 $\\boldsymbol{w}$ 和 $\\boldsymbol{z}$ 的非负约束作为变量的边界进行处理：\n    - $0 \\le w_i \\le 1$ 对于 $i=1, \\dots, n$。（上限 1 是隐含的，但对求解器有帮助）。\n    - $-\\infty < \\zeta < \\infty$（无界）。\n    - $z_s \\ge 0$ 对于 $s=1, \\dots, S$。\n\n通过这种表述，可以使用像 `scipy.optimize.linprog` 这样的标准线性规划求解器来找到最优解向量 $\\boldsymbol{x}^*$。最小 CVaR 值即为最优目标函数值 $\\boldsymbol{c}^{\\top}\\boldsymbol{x}^*$。对每个测试用例重复此过程。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the CVaR optimization problem for a series of test cases.\n    \"\"\"\n    # Define given constants and data\n    n = 4  # number of assets\n    k = 3  # number of factors\n    S = 12 # number of scenarios\n\n    B = np.array([\n        [1.1, 0.3, 0.2],\n        [0.9, 0.1, -0.1],\n        [1.4, -0.2, 0.5],\n        [0.7, 0.5, 0.0]\n    ])\n\n    mu_f = np.array([0.004, 0.003, 0.002])\n\n    F = np.array([\n        [0.015, 0.010, 0.005],\n        [-0.020, -0.015, -0.010],\n        [0.025, 0.005, 0.000],\n        [0.010, -0.005, 0.004],\n        [-0.030, 0.020, -0.005],\n        [0.005, 0.000, 0.007],\n        [0.018, -0.012, 0.003],\n        [-0.012, 0.018, 0.006],\n        [0.022, 0.012, -0.004],\n        [-0.015, -0.008, 0.002],\n        [0.008, 0.006, -0.006],\n        [-0.005, 0.004, 0.009]\n    ])\n\n    E = np.array([\n        [0.0010, -0.0010, 0.0005, -0.0005],\n        [-0.0020, 0.0010, -0.0005, 0.0005],\n        [0.0000, -0.0020, 0.0010, -0.0010],\n        [0.0010, 0.0010, -0.0010, 0.0010],\n        [-0.0010, 0.0020, 0.0000, 0.0000],\n        [0.0000, -0.0010, 0.0005, -0.0005],\n        [0.0020, 0.0000, -0.0005, 0.0005],\n        [-0.0010, -0.0020, 0.0010, -0.0010],\n        [0.0010, 0.0010, -0.0010, 0.0010],\n        [-0.0010, 0.0000, 0.0000, 0.0000],\n        [0.0000, 0.0010, 0.0005, -0.0005],\n        [0.0010, -0.0010, -0.0005, 0.0005]\n    ])\n\n    # Test cases: (alpha, r_min)\n    test_cases = [\n        (0.95, 0.003),\n        (0.99, 0.000),\n        (0.90, 0.004),\n        (0.95, 0.006)\n    ]\n\n    # Preprocessing: Calculate scenario returns and expected returns\n    # R has shape (S, n)\n    R = F @ B.T + E\n    # mu_r has shape (n,)\n    mu_r = B @ mu_f\n\n    results = []\n    for alpha, r_min in test_cases:\n        # Formulate the Linear Program for CVaR minimization\n        # Decision variables x = [w_1, ..., w_n, zeta, z_1, ..., z_S]\n        # Total number of variables is n + 1 + S\n        n_vars = n + 1 + S\n\n        # Objective function: min (zeta + 1/(S*(1-alpha)) * sum(z_s))\n        c = np.zeros(n_vars)\n        c[n] = 1.0  # Coefficient for zeta\n        c[n + 1:] = 1.0 / (S * (1 - alpha)) # Coefficients for z_s\n\n        # Inequality constraints: A_ub * x <= b_ub\n        # S constraints for z_s >= -r_p,s - zeta and 1 for E[r_p] >= r_min\n        A_ub = np.zeros((S + 1, n_vars))\n        b_ub = np.zeros(S + 1)\n\n        # Constraints: -r_p,s - zeta - z_s <= 0  for s = 1,...,S\n        # - (sum_i R_si * w_i) - zeta - z_s <= 0\n        for s in range(S):\n            A_ub[s, :n] = -R[s, :]  # Coefficients for w_i\n            A_ub[s, n] = -1.0       # Coefficient for zeta\n            A_ub[s, n + 1 + s] = -1.0 # Coefficient for z_s\n        \n        # Minimum expected return constraint: E[r_p] >= r_min\n        # -E[r_p] <= -r_min => -mu_r.T @ w <= -r_min\n        A_ub[S, :n] = -mu_r\n        b_ub[S] = -r_min\n        \n        # Equality constraints: A_eq * x = b_eq\n        # Full investment constraint: sum(w_i) = 1\n        A_eq = np.zeros((1, n_vars))\n        A_eq[0, :n] = 1.0\n        b_eq = np.array([1.0])\n\n        # Bounds for variables\n        w_bounds = (0, 1) # Weights are between 0 and 1\n        zeta_bounds = (None, None) # Zeta is unbounded\n        z_bounds = (0, None) # z_s are non-negative\n\n        bounds = [w_bounds] * n + [zeta_bounds] + [z_bounds] * S\n\n        # Solve the linear program\n        res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success:\n            min_cvar = res.fun\n            results.append(f\"{min_cvar:.10f}\")\n        else:\n            # Handle cases where optimization may fail, though not expected here\n            results.append(\"Error\")\n\n    # Format and print the final output\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "在构建了基本的优化模型后，理解真实世界的交易规则（如投资约束）如何影响最终结果至关重要。本练习将直接对比两种常见的投资组合构建情景：一种是禁止卖空的“只做多”投资组合，另一种是允许卖空和使用杠杆的灵活投资组合 [@problem_id:2382531]。通过这项实践，你将深入理解投资约束如何改变可行投资集以及最终的风险收益状况，并锻炼修改线性规划模型以适应不同约束条件的能力。", "id": "2382531", "problem": "考虑一个有限场景的投资组合优化问题，旨在最小化在给定置信水平下投资组合损失的经验条件风险价值（CVaR）。现有 $n$ 种风险资产和 $N$ 个总简单回报率场景。设 $\\mathbf{r}_i \\in \\mathbb{R}^n$ 表示场景 $i \\in \\{1,\\dots,N\\}$ 中的资产回报向量，设 $\\mathbf{w} \\in \\mathbb{R}^n$ 表示投资组合权重，并满足全投资预算约束 $\\sum_{j=1}^n w_j = 1$。场景 $i$ 中的投资组合损失为 $\\ell_i(\\mathbf{w}) = - \\mathbf{r}_i^\\top \\mathbf{w}$。对于置信水平 $\\alpha \\in (0,1)$，损失的经验CVaR定义为\n$$\n\\operatorname{CVaR}_\\alpha(\\mathbf{w}) \\;=\\; \\min_{t \\in \\mathbb{R}} \\left\\{ t \\;+\\; \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N \\big(\\ell_i(\\mathbf{w}) - t\\big)_+ \\right\\},\n$$\n其中 $(x)_+ = \\max\\{x,0\\}$。预期回报约束要求投资组合的场景平均回报至少达到目标值 $\\mu_{\\min}$，即 $\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i^\\top \\mathbf{w} \\ge \\mu_{\\min}$。\n\n您必须比较两种机制：\n- 禁止卖空：对所有 $j \\in \\{1,\\dots,n\\}$，$w_j \\ge 0$。\n- 允许带杠杆的卖空：对于给定的 $L \\ge 1$，总杠杆约束 $\\sum_{j=1}^n |w_j| \\le L$ 成立，且 $w_j$ 可为负。\n\n使用以下数据，$N = 12$ 个场景，$n = 4$ 种资产。场景回报矩阵 $\\mathbf{R} \\in \\mathbb{R}^{12 \\times 4}$ 如下所示\n$$\n\\mathbf{R} \\;=\\;\n\\begin{bmatrix}\n0.01 & 0.005 & -0.02 & 0.002 \\\\\n0.015 & -0.01 & 0.03 & 0.003 \\\\\n-0.02 & 0.018 & 0.025 & 0.0025 \\\\\n0.005 & 0.004 & -0.015 & 0.002 \\\\\n0.012 & -0.005 & 0.022 & 0.003 \\\\\n-0.015 & 0.02 & -0.018 & 0.0025 \\\\\n0.008 & 0.001 & 0.027 & 0.002 \\\\\n0.004 & 0.003 & -0.012 & 0.003 \\\\\n0.02 & -0.012 & 0.019 & 0.0025 \\\\\n-0.01 & 0.017 & -0.014 & 0.002 \\\\\n0.006 & -0.004 & 0.021 & 0.003 \\\\\n0.007 & 0.009 & -0.016 & 0.0025\n\\end{bmatrix}.\n$$\n\n对于下方的每个测试用例，计算在指定约束下最小化 $\\operatorname{CVaR}_\\alpha(\\mathbf{w})$ 的最优权重 $\\mathbf{w}^\\star$，并报告 $\\mathbf{w}^\\star$ 以及相应的最优CVaR值。\n\n测试套件：\n- 测试 $1$ (标准情况)：$\\alpha = 0.95$，$\\mu_{\\min} = 0.003$，禁止卖空。\n- 测试 $2$ (与杠杆比较)：$\\alpha = 0.95$，$\\mu_{\\min} = 0.003$，允许卖空，总杠杆 $L = 1.5$。\n- 测试 $3$ (严格尾部边缘情况)：$\\alpha = 0.99$，$\\mu_{\\min} = 0.0038$，允许卖空，总杠杆 $L = 2.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个含三个元素的列表，每个元素是包含 $5$ 个浮点数的列表：$4$ 个最优权重，后跟最优CVaR值。数字必须四舍五入到 $6$ 位小数。该行必须是方括号括起来的逗号分隔列表，例如 $[\\,[x_1,x_2,x_3,x_4,c]\\, , \\, [\\dots] \\, , \\, [\\dots]\\,]$，其中每个 $x_k$ 和 $c$ 都是四舍五入到 $6$ 位小数的浮点数。\n- 不应打印任何其他文本。", "solution": "所提问题是在条件风险价值（CVaR）框架下的一个适定的投资组合优化任务。它在科学上基于成熟的金融工程原理，在数学上是一致的。所有必要的参数和数据都已提供，不存在歧义或矛盾。因此，该问题是有效的，我们可以着手求解。\n\n目标是最小化投资组合损失的经验CVaR，即 $\\operatorname{CVaR}_\\alpha(\\mathbf{w})$，并服从一系列关于投资组合权重 $\\mathbf{w} \\in \\mathbb{R}^n$ 的约束。该投资组合包含 $n=4$ 种资产，在 $N=12$ 个历史场景下进行评估。这些场景的总简单回报率由矩阵 $\\mathbf{R} \\in \\mathbb{R}^{12 \\times 4}$ 给出。设 $\\mathbf{r}_i \\in \\mathbb{R}^n$ 为场景 $i$ 中资产回报的列向量，对应于 $\\mathbf{R}$ 的第 $i$ 行的转置。场景 $i$ 中的投资组合损失定义为 $\\ell_i(\\mathbf{w}) = - \\mathbf{r}_i^\\top \\mathbf{w}$。\n\n问题是求解：\n$$\n\\min_{\\mathbf{w}} \\operatorname{CVaR}_\\alpha(\\mathbf{w})\n$$\n并服从特定问题的约束。$\\operatorname{CVaR}_\\alpha(\\mathbf{w})$ 的定义如下：\n$$\n\\operatorname{CVaR}_\\alpha(\\mathbf{w}) \\;=\\; \\min_{t \\in \\mathbb{R}} \\left\\{ t \\;+\\; \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N \\big(\\ell_i(\\mathbf{w}) - t\\big)_+ \\right\\}\n$$\n其中 $(x)_+ = \\max\\{x,0\\}$。\n\n这个嵌套的最小化问题可以重构为一个关于 $\\mathbf{w}$ 和辅助变量 $t \\in \\mathbb{R}$ 的联合最小化问题：\n$$\n\\min_{\\mathbf{w}, t} \\left\\{ t \\;+\\; \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N \\big(-\\mathbf{r}_i^\\top \\mathbf{w} - t\\big)_+ \\right\\}\n$$\n项 $(\\cdot)_+$ 是非线性的。为了创建一个计算上易于处理的问题，特别是线性规划（LP），我们引入一个辅助变量向量 $\\mathbf{u} = [u_1, \\dots, u_N]^\\top$，其中每个 $u_i$ 代表场景 $i$ 中超过风险价值（VaR）（由 $t$ 代理）的超额损失。我们要求 $u_i \\ge (-\\mathbf{r}_i^\\top \\mathbf{w} - t)$ 且 $u_i \\ge 0$。最小化目标将确保 $u_i$ 取可能的最​​小值，即 $u_i = \\max(-\\mathbf{r}_i^\\top \\mathbf{w} - t, 0)$。\n\n因此，该优化问题转化为以下LP：\n$$\n\\begin{array}{ll}\n\\underset{\\mathbf{w}, t, \\mathbf{u}}{\\text{minimize}} & t + \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N u_i \\\\\n\\text{subject to} & u_i + \\mathbf{r}_i^\\top \\mathbf{w} + t \\ge 0, \\quad \\forall i \\in \\{1, \\dots, N\\} \\\\\n& u_i \\ge 0, \\quad \\forall i \\in \\{1, \\dots, N\\} \\\\\n& \\text{以及关于 } \\mathbf{w} \\text{ 的其他投资组合约束}\n\\end{array}\n$$\n决策变量是权重向量 $\\mathbf{w} \\in \\mathbb{R}^n$、VaR代理变量 $t \\in \\mathbb{R}$ 和超额损失变量 $\\mathbf{u} \\in \\mathbb{R}^N$。\n\n投资组合约束为：\n1. 全投资（预算约束）：$\\sum_{j=1}^n w_j = \\mathbf{1}^\\top \\mathbf{w} = 1$。\n2. 最小预期回报：$\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i^\\top \\mathbf{w} \\ge \\mu_{\\min}$。这等价于 $\\bar{\\mathbf{r}}^\\top \\mathbf{w} \\ge \\mu_{\\min}$，其中 $\\bar{\\mathbf{r}} = \\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i$ 是场景平均回报向量。\n\n我们分析指定的两种机制。\n\n**机制1：禁止卖空**\n在此机制下，权重必须为非负。LP的完整约束集为：\n$$\n\\begin{array}{ll}\n\\underset{\\mathbf{w}, t, \\mathbf{u}}{\\text{minimize}} & t + \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N u_i \\\\\n\\text{subject to} & -\\mathbf{r}_i^\\top \\mathbf{w} - t - u_i \\le 0, \\quad i=1, \\dots, N \\\\\n& -\\bar{\\mathbf{r}}^\\top \\mathbf{w} \\le -\\mu_{\\min} \\\\\n& \\mathbf{1}^\\top \\mathbf{w} = 1 \\\\\n& w_j \\ge 0, \\quad j=1, \\dots, n \\\\\n& u_i \\ge 0, \\quad i=1, \\dots, N\n\\end{array}\n$$\n这是一个标准的LP形式，可通过单纯形法或内点法等算法求解。优化变量为 $[\\mathbf{w}^\\top, t, \\mathbf{u}^\\top]^\\top$。\n\n**机制2：允许带杠杆的卖空**\n这里，权重 $w_j$ 可以为负。$\\mathbf{w}$ 上的非负约束被替换为总杠杆约束：$\\sum_{j=1}^n |w_j| \\le L$。绝对值函数是非线性的。我们通过将每个权重 $w_j$ 分解为其正部和负部来线性化它：$w_j = w_j^+ - w_j^-$，其中 $w_j^+ \\ge 0$ 且 $w_j^- \\ge 0$。于是绝对值变为 $|w_j| = w_j^+ + w_j^-$。\n\n投资组合权重向量变为 $\\mathbf{w} = \\mathbf{w}^+ - \\mathbf{w}^-$，其中 $\\mathbf{w}^+, \\mathbf{w}^- \\in \\mathbb{R}^n$ 是非负变量的向量。此机制的LP是关于变量 $\\mathbf{w}^+, \\mathbf{w}^-, t, \\mathbf{u}$ 构建的：\n$$\n\\begin{array}{ll}\n\\underset{\\mathbf{w}^+, \\mathbf{w}^-, t, \\mathbf{u}}{\\text{minimize}} & t + \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N u_i \\\\\n\\text{subject to} & -\\mathbf{r}_i^\\top (\\mathbf{w}^+ - \\mathbf{w}^-) - t - u_i \\le 0, \\quad i=1, \\dots, N \\\\\n& -\\bar{\\mathbf{r}}^\\top (\\mathbf{w}^+ - \\mathbf{w}^-) \\le -\\mu_{\\min} \\\\\n& \\mathbf{1}^\\top (\\mathbf{w}^+ - \\mathbf{w}^-) = 1 \\\\\n& \\mathbf{1}^\\top (\\mathbf{w}^+ + \\mathbf{w}^-) \\le L \\\\\n& w_j^+ \\ge 0, w_j^- \\ge 0, \\quad j=1, \\dots, n \\\\\n& u_i \\ge 0, \\quad i=1, \\dots, N\n\\end{array}\n$$\n优化变量向量为 $[\\mathbf{w}^{+ \\top}, \\mathbf{w}^{- \\top}, t, \\mathbf{u}^\\top]^\\top$。一旦找到最优的 $\\mathbf{w}^{+ \\star}$ 和 $\\mathbf{w}^{- \\star}$，最优投资组合权重可恢复为 $\\mathbf{w}^\\star = \\mathbf{w}^{+ \\star} - \\mathbf{w}^{- \\star}$。\n\n对于每个测试用例，将构建并求解相应的LP。将报告最优权重 $\\mathbf{w}^\\star$ 和最优目标值（即最小 $\\operatorname{CVaR}_\\alpha$）。\n\n所有测试用例均使用以下数据：$n=4$，$N=12$ 和回报矩阵 $\\mathbf{R}$。\n平均回报向量为 $\\bar{\\mathbf{r}} = [0.004333, 0.004667, 0.004917, 0.0025]^\\top$。\n\n**测试用例1**：$\\alpha = 0.95$，$\\mu_{\\min} = 0.003$，禁止卖空。\n这使用机制1的公式。目标函数中的常数因子为 $1 / ((1-0.95) \\cdot 12) = 1/0.6 = 5/3$。\n\n**测试用例2**：$\\alpha = 0.95$，$\\mu_{\\min} = 0.003$，允许卖空，$L = 1.5$。\n这使用机制2的公式。因子同样为 $5/3$。\n\n**测试用例3**：$\\alpha = 0.99$，$\\mu_{\\min} = 0.0038$，允许卖空，$L = 2.0$。\n这使用机制2的公式。因子为 $1 / ((1-0.99) \\cdot 12) = 1/0.12 = 25/3$。\n\n每种情况的解将使用数值LP求解器计算。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_cvar_optimization(R, alpha, mu_min, L=None, short_selling_prohibited=True):\n    \"\"\"\n    Solves the CVaR optimization problem.\n    \"\"\"\n    N, n = R.shape\n    r_bar = R.mean(axis=0)\n    cvar_factor = 1 / ((1 - alpha) * N)\n\n    if short_selling_prohibited:\n        # Decision variables: x = [w_1, ..., w_n, t, u_1, ..., u_N]\n        # Total variables: n + 1 + N\n        \n        # --- Objective function ---\n        # min t + cvar_factor * sum(u_i)\n        c = np.zeros(n + 1 + N)\n        c[n] = 1  # Coefficient for t\n        c[n + 1:] = cvar_factor  # Coefficients for u_i\n        \n        # --- Constraints ---\n        # A_ub * x <= b_ub\n        # A_eq * x == b_eq\n\n        # Inequality constraints:\n        # 1. -r_bar.T @ w <= -mu_min\n        # 2. -R @ w - t - u <= 0 --> -R @ w - t*1 - I @ u <= 0\n        A_ub = np.zeros((N + 1, n + 1 + N))\n        b_ub = np.zeros(N + 1)\n        \n        # Expected return constraint\n        A_ub[0, :n] = -r_bar\n        b_ub[0] = -mu_min\n\n        # CVaR constraints\n        A_ub[1:, :n] = -R\n        A_ub[1:, n] = -1\n        A_ub[1:, n + 1:] = -np.eye(N)\n        \n        # Equality constraints (budget):\n        # 1. sum(w_j) = 1\n        A_eq = np.zeros((1, n + 1 + N))\n        A_eq[0, :n] = 1\n        b_eq = np.array([1])\n        \n        # --- Bounds ---\n        # w_j >= 0, u_i >= 0, t is free\n        bounds = [(0, None)] * n + [(None, None)] + [(0, None)] * N\n        \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if not res.success:\n            raise RuntimeError(f\"Optimization failed: {res.message}\")\n        \n        w_opt = res.x[:n]\n        cvar_opt = res.fun\n        \n        return w_opt, cvar_opt\n        \n    else:  # Short-selling allowed with leverage\n        # Decision variables: x = [w_p_1, ..., w_p_n, w_m_1, ..., w_m_n, t, u_1, ..., u_N]\n        # Total variables: 2*n + 1 + N\n        \n        # --- Objective function ---\n        c = np.zeros(2 * n + 1 + N)\n        c[2 * n] = 1  # Coefficient for t\n        c[2 * n + 1:] = cvar_factor # Coefficients for u_i\n\n        # --- Constraints ---\n        # Inequality constraints:\n        # 1. Leverage: sum(w_p_j + w_m_j) <= L\n        # 2. Expected return: -r_bar.T @ (w_p - w_m) <= -mu_min\n        # 3. CVaR: -R @ (w_p - w_m) - t - u <= 0\n        A_ub = np.zeros((1 + 1 + N, 2 * n + 1 + N))\n        b_ub = np.zeros(1 + 1 + N)\n        \n        # Leverage constraint\n        A_ub[0, :2 * n] = 1\n        b_ub[0] = L\n\n        # Expected return constraint\n        A_ub[1, :n] = -r_bar\n        A_ub[1, n:2 * n] = r_bar\n        b_ub[1] = -mu_min\n\n        # CVaR constraints\n        A_ub[2:, :n] = -R\n        A_ub[2:, n:2 * n] = R\n        A_ub[2:, 2 * n] = -1\n        A_ub[2:, 2 * n + 1:] = -np.eye(N)\n        \n        # Equality constraints (budget):\n        # 1. sum(w_p_j - w_m_j) = 1\n        A_eq = np.zeros((1, 2 * n + 1 + N))\n        A_eq[0, :n] = 1\n        A_eq[0, n:2 * n] = -1\n        b_eq = np.array([1])\n        \n        # --- Bounds ---\n        # w_p_j >= 0, w_m_j >= 0, u_i >= 0, t is free\n        bounds = [(0, None)] * (2 * n) + [(None, None)] + [(0, None)] * N\n\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if not res.success:\n            raise RuntimeError(f\"Optimization failed: {res.message}\")\n\n        w_p = res.x[:n]\n        w_m = res.x[n:2 * n]\n        w_opt = w_p - w_m\n        cvar_opt = res.fun\n        \n        return w_opt, cvar_opt\n\n\ndef solve():\n    R = np.array([\n        [0.01, 0.005, -0.02, 0.002],\n        [0.015, -0.01, 0.03, 0.003],\n        [-0.02, 0.018, 0.025, 0.0025],\n        [0.005, 0.004, -0.015, 0.002],\n        [0.012, -0.005, 0.022, 0.003],\n        [-0.015, 0.02, -0.018, 0.0025],\n        [0.008, 0.001, 0.027, 0.002],\n        [0.004, 0.003, -0.012, 0.003],\n        [0.02, -0.012, 0.019, 0.0025],\n        [-0.01, 0.017, -0.014, 0.002],\n        [0.006, -0.004, 0.021, 0.003],\n        [0.007, 0.009, -0.016, 0.0025]\n    ])\n\n    test_cases = [\n        # alpha, mu_min, L, short_selling_prohibited\n        (0.95, 0.003, None, True),\n        (0.95, 0.003, 1.5, False),\n        (0.99, 0.0038, 2.0, False)\n    ]\n\n    results = []\n    for alpha, mu_min, L, ssp in test_cases:\n        w_opt, cvar_opt = solve_cvar_optimization(R, alpha, mu_min, L, ssp)\n        \n        # Round to 6 decimal places\n        result_list = [round(w, 6) for w in w_opt] + [round(cvar_opt, 6)]\n        results.append(result_list)\n    \n    # Format the output string precisely as required, without extra spaces\n    res_strings = [f\"[{','.join(f'{v:.6f}' for v in r)}]\" for r in results]\n    final_output = f\"[{','.join(res_strings)}]\"\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "前面的练习处理的都是线性收益资产，但对于像期权这样具有非线性回报的衍生品，我们该如何管理其风险呢？这个高级练习将带你应对优化衍生品投资组合的挑战 [@problem_id:2382528]。你需要分步解决这个问题：首先，为底层资产生成未来价格情景；其次，使用 Black-Scholes 模型为衍生品定价；最后，建立并求解 CVaR 优化问题来管理该投资组合复杂的非对称风险。这个综合性问题融合了计算金融中的多个核心概念，为你处理非线性金融工具的投资组合风险管理做好准备。", "id": "2382528", "problem": "给定一个投资组合选择问题，其中资产为欧式衍生品，其标的为单一风险资产，终端价格记为 $S_T$。每种衍生品的支付 $P(S_T)$ 是 $S_T$ 的非线性函数。目标是选择非负的投资组合权重 $w \\in \\mathbb{R}^J_{\\ge 0}$，以最小化在指定置信水平 $0 < \\alpha < 1$ 下投资组合损失的条件风险价值（CVaR），并满足将给定初始预算完全投资的预算约束。\n\n数据和建模假设如下。\n\n1. 在物理测度下，终端价格 $S_T$ 服从对数正态分布，该分布由一个正态变量 $Z \\sim \\mathcal{N}(0,1)$ 生成，参数为 $S_0 > 0$（当前价格）、$\\mu_p \\in \\mathbb{R}$（物理漂移率）、$\\sigma > 0$（波动率）和期限 $T > 0$：\n$$\nS_T = S_0 \\exp\\left( \\left(\\mu_p - \\tfrac{1}{2}\\sigma^2\\right) T + \\sigma \\sqrt{T}\\, Z \\right).\n$$\n为进行计算，必须使用通过等距概率网格 $u_i = \\tfrac{i - 0.5}{N}$（其中 $i = 1,2,\\dots,N$）生成的 $N$ 个场景来构建 $S_T$ 的经验分布。该网格通过标准正态累积分布函数的反函数 $\\Phi^{-1}$ 映射为 $z_i = \\Phi^{-1}(u_i)$，然后映射为\n$$\nS_T^{(i)} = S_0 \\exp\\left( \\left(\\mu_p - \\tfrac{1}{2}\\sigma^2\\right) T + \\sigma \\sqrt{T}\\, z_i \\right).\n$$\n\n2. 投资组合包含 $J$ 种衍生工具，其在到期日 $T$ 的支付定义如下，并按以下固定顺序排列。设 $K \\in \\mathbb{R}_{>0}$ 表示一个行权价参数。这些工具（及其支付函数和行权价）是：\n- 工具 1：行权价 $K = 90$ 的欧式看涨期权，支付 $P_1(S_T) = \\max(S_T - 90, 0)$。\n- 工具 2：行权价 $K = 100$ 的欧式看涨期权，支付 $P_2(S_T) = \\max(S_T - 100, 0)$。\n- 工具 3：行权价 $K = 110$ 的欧式看涨期权，支付 $P_3(S_T) = \\max(S_T - 110, 0)$。\n- 工具 4：行权价 $K = 90$ 的欧式看跌期权，支付 $P_4(S_T) = \\max(90 - S_T, 0)$。\n- 工具 5：行权价 $K = 100$ 的欧式看跌期权，支付 $P_5(S_T) = \\max(100 - S_T, 0)$。\n- 工具 6：行权价 $K = 110$ 的欧式看跌期权，支付 $P_6(S_T) = \\max(110 - S_T, 0)$。\n- 工具 7：行权价 $K = 100$ 的欧式数字看涨期权，支付 $P_7(S_T) = \\mathbf{1}_{\\{S_T > 100\\}}$。\n\n3. 对于 $j = 1,\\dots,7$，初始成本 $c_j$ 必须在 Black–Scholes 框架下计算，使用风险中性漂移率 $r$ 以及相同的波动率 $\\sigma$ 和到期日 $T$。具体来说，使用标准的 Black–Scholes 符号\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S_0}{K}\\right) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right) T}{\\sigma \\sqrt{T}}, \\quad\nd_2 = d_1 - \\sigma \\sqrt{T}, \\quad \\Phi(\\cdot) \\text{ 是标准正态累积分布函数},\n$$\n时间-$0$ 的价格为：\n- 欧式看涨期权：$c_{\\text{call}}(S_0,K,\\sigma,r,T) = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2)$。\n- 欧式看跌期权：$c_{\\text{put}}(S_0,K,\\sigma,r,T) = K e^{-rT} \\Phi(-d_2) - S_0 \\Phi(-d_1)$。\n- 欧式数字看涨期权：$c_{\\text{dig}}(S_0,K,\\sigma,r,T) = e^{-rT} \\Phi(d_2)$。\n\n4. 对于权重 $w \\in \\mathbb{R}^7_{\\ge 0}$，场景 $i$ 中的投资组合损失定义为\n$$\nL_i(w) = \\sum_{j=1}^{7} w_j \\left( c_j e^{rT} - P_j\\left(S_T^{(i)}\\right) \\right).\n$$\n此损失是在时间 $T$ 处度量的，方法是将初始成本按连续复利无风险利率 $r$ 复利计算至时间 $T$，然后减去实现的支付。\n\n5. 对于经验损失分布 $\\{L_i(w)\\}_{i=1}^N$，在水平 $\\alpha$ 上的条件风险价值定义为损失中最差的 $(1-\\alpha)$ 部分的平均值（即，超出风险价值的尾部均值），使用由 $N$ 个等可能场景导出的经验分布。如果 $(1-\\alpha)N$ 不是整数，则通过使用适当分数加权的标准尾部平均定义来解释该平均值。\n\n6. 优化问题是：\n- 决策变量： $w \\in \\mathbb{R}^7_{\\ge 0}$。\n- 目标：最小化经验损失分布 $\\{L_i(w)\\}_{i=1}^N$ 在水平 $\\alpha$ 上的 CVaR。\n- 约束：全额投资预算\n$$\n\\sum_{j=1}^{7} c_j w_j = B,\n$$\n以及非负性 $w_j \\ge 0$ สำหรับ $j = 1,\\dots,7$。\n\n您的任务是实现一个程序，对于下面的每个测试用例，构建 $N$ 个场景 $\\{S_T^{(i)}\\}_{i=1}^N$，计算衍生品价格 $\\{c_j\\}_{j=1}^7$，求解上述 CVaR 最小化问题，并输出与第 2 点中指定的工具顺序相对应的最优权重向量 $w^\\star$。\n\n测试套件。对于每个测试用-例，请使用指定的参数值：\n- 测试用例 1：$S_0 = 100$, $r = 0.02$, $T = 1$, $\\mu_p = 0.05$, $\\sigma = 0.2$, $\\alpha = 0.95$, $B = 10$, $N = 200$。\n- 测试用例 2：$S_0 = 100$, $r = 0.02$, $T = 1$, $\\mu_p = 0.02$, $\\sigma = 0.2$, $\\alpha = 0.99$, $B = 10$, $N = 200$。\n- 测试用例 3：$S_0 = 100$, $r = 0.02$, $T = 1$, $\\mu_p = 0.02$, $\\sigma = 0.01$, $\\alpha = 0.95$, $B = 10$, $N = 200$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的第 $k$ 个元素本身是一个包含 $7$ 个浮点数（四舍五入到 $6$ 位小数）的列表，给出测试用例 $k$ 在第 2 点中工具顺序下的最优权重。例如，三个测试的输出必须如下所示\n$$\n[[w_{1,1},w_{1,2},\\dots,w_{1,7}],[w_{2,1},\\dots,w_{2,7}],[w_{3,1},\\dots,w_{3,7}]].\n$$\n不得打印任何额外文本。所有数值答案必须是无量纲的实数。", "solution": "该问题已经过验证，被认为是科学上合理、提法得当且完整的。它是计算金融学中的一个标准问题，特别是在投资组合风险管理领域。所提供的模型、公式和参数是一致的，能够得到一个唯一且有意义的解。我们将着手推导和实现该解法。\n\n该问题要求最小化投资组合损失的条件风险价值（CVaR），并受到预算和投资组合权重非负性的约束。这可以被表述为一个线性规划（LP）问题，这是一个计算上易于处理的优化问题。\n\n设 $w \\in \\mathbb{R}^J_{\\ge 0}$ 为 $J=7$ 种工具的投资组合权重向量。在场景 $i \\in \\{1, \\dots, N\\}$ 中，投资组合的损失是权重的线性函数：\n$$\nL_i(w) = \\sum_{j=1}^{7} w_j \\left( c_j e^{rT} - P_j\\left(S_T^{(i)}\\right) \\right)\n$$\n其中 $c_j$ 是工具 $j$ 的初始成本，$r$ 是无风险利率，$T$ 是时间期限，$P_j(S_T^{(i)})$ 是在终端资产价格场景 $S_T^{(i)}$ 下工具 $j$ 的支付。初始成本由 Black-Scholes 模型在风险中性测度下确定，而终端价格场景 $S_T^{(i)}$ 则在物理测度下生成。这种区分是标准且恰当的。\n\n根据 Rockafellar 和 Uryasev 的研究，损失分布在置信水平 $\\alpha \\in (0, 1)$ 的 CVaR 可以通过求解以下优化问题得到：\n$$\n\\text{CVaR}_{\\alpha}(L(w)) = \\min_{v \\in \\mathbb{R}} \\left( v + \\frac{1}{1-\\alpha} \\mathbb{E}[\\max(L(w) - v, 0)] \\right)\n$$\n此处，$v$ 是一个辅助变量，代表水平 $\\alpha$ 的风险价值（VaR）。对于基于 $N$ 个等可能场景的经验分布，期望值被替换为平均值：\n$$\n\\text{CVaR}_{\\alpha}(\\{L_i(w)\\}) = \\min_{v \\in \\mathbb{R}} \\left( v + \\frac{1}{N(1-\\alpha)} \\sum_{i=1}^N \\max(L_i(w) - v, 0) \\right)\n$$\n完整的优化问题是关于 $w$ 和 $v$ 最小化该数量，并满足给定的约束条件。\n$$\n\\min_{w, v} \\quad v + \\frac{1}{N(1-\\alpha)} \\sum_{i=1}^N \\max(L_i(w) - v, 0)\n$$\n约束条件为：\n$$\n\\sum_{j=1}^{7} c_j w_j = B\n$$\n$$\nw_j \\ge 0 \\quad \\text{for } j=1, \\dots, 7\n$$\n由于 $\\max$ 函数的存在，这是一个凸但非线性的优化问题。可以通过引入 $N$ 个辅助变量 $u_i \\ge 0$ 将其转化为一个等价的线性规划问题，其中每个 $u_i$ 代表损失 $L_i(w)$ 超过 VaR $v$ 的亏空。即，$u_i \\ge L_i(w) - v$。\n\n等价的 LP 表述如下：\n- **决策变量**:\n  - $w \\in \\mathbb{R}^7$：投资组合权重。\n  - $v \\in \\mathbb{R}$：风险价值。\n  - $u \\in \\mathbb{R}^N$：每个场景的亏空变量。\n\n- **目标函数**:\n  最小化 $v + \\frac{1}{N(1-\\alpha)} \\sum_{i=1}^N u_i$。\n\n- **约束条件**:\n  1. 对于每个场景 $i=1, \\dots, N$，有 $L_i(w) - v - u_i \\le 0$。\n  2. $\\sum_{j=1}^{7} c_j w_j = B$ (预算约束)。\n  3. $w_j \\ge 0$ 对于 $j=1, \\dots, 7$ (权重非负性)。\n  4. $u_i \\ge 0$ 对于 $i=1, \\dots, N$ (亏空非负性)。\n\n由于 $L_i(w)$是 $w$ 的线性函数，第一个约束也是线性的。因此，整个问题是一个 LP。为实现该解法，我们为标准 LP 求解器构建矩阵。设优化变量向量为 $\\mathbf{x} = [w_1, \\dots, w_7, v, u_1, \\dots, u_N]^T$，其维度为 $J+1+N = 7+1+N$。\n\n1.  **场景生成**：对于每个测试用例，我们为终端价格 $S_T$ 生成 $N$ 个场景。我们首先创建一个等距概率网格 $p_i = (i - 0.5)/N$ (其中 $i=1, \\dots, N$)。标准正态变量为 $z_i = \\Phi^{-1}(p_i)$，其中 $\\Phi^{-1}$ 是标准正态 CDF 的反函数。然后，计算终端价格：\n    $$\n    S_T^{(i)} = S_0 \\exp\\left( \\left(\\mu_p - \\frac{1}{2}\\sigma^2\\right) T + \\sigma \\sqrt{T}\\, z_i \\right)\n    $$\n\n2.  **衍生品定价**：我们使用提供的 Black-Scholes 公式计算 $J=7$ 种衍生品的初始成本 $c_j$。这些公式需要参数 $S_0, T, r, \\sigma,$ 和各自的行权价 $K$。\n\n3.  **LP 构建**:\n    - **目标向量 $\\mathbf{c}_{\\text{LP}}$**：目标是最小化 $\\mathbf{c}_{\\text{LP}}^T \\mathbf{x}$。根据目标函数，该向量为：\n      $$\n      \\mathbf{c}_{\\text{LP}} = [\\underbrace{0, \\dots, 0}_{7 \\text{ 次}}, 1, \\underbrace{\\frac{1}{N(1-\\alpha)}, \\dots, \\frac{1}{N(1-\\alpha)}}_{N \\text{ 次}}]^T\n      $$\n    - **等式约束 $\\mathbf{A}_{\\text{eq}}\\mathbf{x} = \\mathbf{b}_{\\text{eq}}$**：这对应于预算约束。\n      $$\n      \\mathbf{A}_{\\text{eq}} = [c_1, \\dots, c_7, 0, 0, \\dots, 0] \\quad (\\text{一个 } 1 \\times (8+N) \\text{ 的矩阵})\n      $$\n      $$\n      \\mathbf{b}_{\\text{eq}} = [B]\n      $$\n    - **不等式约束 $\\mathbf{A}_{\\text{ub}}\\mathbf{x} \\le \\mathbf{b}_{\\text{ub}}$**：这些对应于 $N$ 个亏空约束 $L_i(w) - v - u_i \\le 0$。设 $\\mathbf{M}$ 是一个 $N \\times 7$ 的矩阵，其中 $M_{ij} = c_j e^{rT} - P_j(S_T^{(i)})$。那么 $L_i(w) = \\sum_j M_{ij} w_j$。这些约束可以写成矩阵形式。\n      - $\\mathbf{A}_{\\text{ub}}$ 的前 $7$ 列对应于 $w_j$ 的系数，构成矩阵 $\\mathbf{M}$。\n      - 第 $8$ 列，对应于 $v$，是一个 $-1$ 的向量。\n      - 最后 $N$ 列，对应于 $u_i$，构成矩阵 $- \\mathbf{I}_N$，其中 $\\mathbf{I}_N$ 是 $N \\times N$ 的单位矩阵。\n      $$\n      \\mathbf{A}_{\\text{ub}} = [\\mathbf{M} \\quad -\\mathbf{1}_{N \\times 1} \\quad -\\mathbf{I}_N] \\quad (\\text{一个 } N \\times (8+N) \\text{ 的矩阵})\n      $$\n      $$\n      \\mathbf{b}_{\\text{ub}} = \\mathbf{0}_{N \\times 1}\n      $$\n    - **边界**：变量受边界条件约束：$w_j \\ge 0$，$v$ 无限制，$u_i \\ge 0$。\n\n然后使用数值求解器求解此 LP。最优权重 $w^\\star$ 是所得解向量 $\\mathbf{x}^\\star$ 的前 $7$ 个元素。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.optimize import linprog\n\ndef black_scholes_pricer(S0, K, T, r, sigma, option_type):\n    \"\"\"\n    Calculates the time-0 price of European options using the Black-Scholes model.\n    \"\"\"\n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    \n    if option_type == 'call':\n        price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    elif option_type == 'put':\n        price = K * np.exp(-r * T) * norm.cdf(-d2) - S0 * norm.cdf(-d1)\n    elif option_type == 'digital_call':\n        price = np.exp(-r * T) * norm.cdf(d2)\n    else:\n        raise ValueError(\"Invalid option type. Must be 'call', 'put', or 'digital_call'.\")\n        \n    return price\n\ndef solve():\n    \"\"\"\n    Solves the CVaR optimization problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {'S0': 100, 'r': 0.02, 'T': 1, 'mu_p': 0.05, 'sigma': 0.2, 'alpha': 0.95, 'B': 10, 'N': 200},\n        {'S0': 100, 'r': 0.02, 'T': 1, 'mu_p': 0.02, 'sigma': 0.2, 'alpha': 0.99, 'B': 10, 'N': 200},\n        {'S0': 100, 'r': 0.02, 'T': 1, 'mu_p': 0.02, 'sigma': 0.01, 'alpha': 0.95, 'B': 10, 'N': 200},\n    ]\n\n    # Instrument definitions\n    J = 7\n    instrument_strikes = np.array([90, 100, 110, 90, 100, 110, 100], dtype=float)\n    instrument_types = ['call', 'call', 'call', 'put', 'put', 'put', 'digital_call']\n\n    final_results = []\n\n    for params in test_cases:\n        S0, r, T, mu_p, sigma, alpha, B, N = \\\n            params['S0'], params['r'], params['T'], params['mu_p'], \\\n            params['sigma'], params['alpha'], params['B'], params['N']\n\n        # Step 1: Scenario Generation\n        u = (np.arange(1, N + 1) - 0.5) / N\n        z = norm.ppf(u)\n        S_T = S0 * np.exp((mu_p - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * z)\n\n        # Step 2: Derivative Pricing\n        costs = np.array([\n            black_scholes_pricer(S0, K, T, r, sigma, opt_type)\n            for K, opt_type in zip(instrument_strikes, instrument_types)\n        ])\n\n        # Step 3: Calculate Payoffs for each scenario\n        payoffs = np.zeros((N, J))\n        payoffs[:, 0] = np.maximum(S_T - 90, 0)\n        payoffs[:, 1] = np.maximum(S_T - 100, 0)\n        payoffs[:, 2] = np.maximum(S_T - 110, 0)\n        payoffs[:, 3] = np.maximum(90 - S_T, 0)\n        payoffs[:, 4] = np.maximum(100 - S_T, 0)\n        payoffs[:, 5] = np.maximum(110 - S_T, 0)\n        payoffs[:, 6] = (S_T > 100).astype(float)\n\n        # Step 4: Construct the Linear Program\n        num_vars = J + 1 + N\n        \n        # Objective function vector\n        c_lp = np.zeros(num_vars)\n        c_lp[J] = 1.0  # Coefficient for v\n        c_lp[J + 1:] = 1.0 / (N * (1 - alpha)) # Coefficients for u_i\n\n        # Equality constraint (budget)\n        A_eq = np.zeros((1, num_vars))\n        A_eq[0, :J] = costs\n        b_eq = np.array([B])\n        \n        # Inequality constraints (loss vs VaR)\n        loss_matrix = costs * np.exp(r * T) - payoffs # Shape (N, J)\n        \n        A_ub = np.zeros((N, num_vars))\n        A_ub[:, :J] = loss_matrix\n        A_ub[:, J] = -1.0 # Coefficients for -v\n        A_ub[:, J + 1:] = -np.eye(N) # Coefficients for -u_i\n        b_ub = np.zeros(N)\n\n        # Bounds for variables\n        bounds = [(0, None)] * J + [(None, None)] + [(0, None)] * N\n\n        # Step 5: Solve the LP\n        res = linprog(c=c_lp, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        optimal_weights = res.x[:J]\n        \n        # Format results\n        formatted_weights = [f\"{w:.6f}\" for w in optimal_weights]\n        final_results.append(f\"[{','.join(formatted_weights)}]\")\n    \n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"}]}