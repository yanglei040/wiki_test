{"hands_on_practices": [{"introduction": "为真正掌握布莱克-斯科尔斯-默顿（Black-Scholes-Merton）模型，我们从一个旨在阐明风险中性定价核心原则的基础练习开始。这个问题要求你为一种“波士顿期权”定价，尽管名为期权，它本质上是在到期时强制交换的远期合约。通过解决这个问题，你将亲身体会到无套利价格如何仅仅是预期未来收益的现值，并且至关重要的是，你将理解为什么对于没有选择性的合约，波动率（$\\sigma$）是无关紧要的。[@problem_id:2438209]", "id": "2438209", "problem": "考虑一个满足 Black-Scholes-Merton (BSM) 假设的无摩擦市场，其中无风险利率 $r \\in \\mathbb{R}$ 为常数，标的资产不支付股息或具有恒定比例的连续股息率 $q \\ge 0$，且波动率 $\\sigma &gt; 0$ 为常数。令 $\\{S_t: t \\in [0,T]\\}$ 表示标的资产的价格过程，其中 $S_0 &gt; 0$，并令无风险货币市场账户为 $B_t = \\exp(r t)$，适用于所有 $t \\in [0,T]$。假设在风险中性概率测度下，资产价格遵循以下随机微分方程：\n$$\n\\mathrm{d}S_t = (r - q) S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t,\n$$\n其中 $\\{W_t\\}$ 是一个标准维纳过程（也称为标准布朗运动）。\n\n定义一份“波士顿期权”为这样一种合约：在到期时间 $T > 0$，无论终端资产价格 $S_T$ 为何，持有者都有义务收到一单位标的资产，并支付固定的执行价格 $K > 0$。换言之，该合约在时间 $T$ 的终端收益为净额 $S_T - K$。\n\n请确定此合约在时间 $0$ 的无套利价格，以 $S_0$、$K$、$r$、$q$ 和 $T$ 表示的单一、闭式解析表达式。请用最简形式表示您的答案。不需要数值近似或四舍五入。", "solution": "必须首先对问题陈述进行严格验证。\n\n步骤 1：提取已知条件\n- 市场模型：无摩擦，满足 Black-Scholes-Merton (BSM) 假设。\n- 无风险利率：恒定，$r \\in \\mathbb{R}$。\n- 股息率：恒定、成比例，$q \\ge 0$。\n- 波动率：恒定，$\\sigma > 0$。\n- 资产价格过程：$\\{S_t: t \\in [0,T]\\}$，初始价格 $S_0 > 0$。\n- 货币市场账户：$B_t = \\exp(r t)$。\n- 风险中性动态：在风险中性测度下，资产价格遵循以下随机微分方程 (SDE)：\n$$\n\\mathrm{d}S_t = (r - q) S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t\n$$\n其中 $\\{W_t\\}$ 是一个标准维纳过程。\n- 合约定义：一份“波士顿期权”在时间 $T > 0$ 到期。到期时，持有者有义务收到一单位资产并支付固定执行价 $K > 0$。\n- 终端收益：在时间 $T$ 的净收益为 $S_T - K$。\n- 目标：确定该合约在时间 $t=0$ 的无套利价格。\n\n步骤 2：使用提取的已知条件进行验证\n此问题根据既定标准进行验证。\n- **科学依据：** 该问题完全在用于衍生证券定价的标准且成熟的 Black-Scholes-Merton 框架内构建。所提供的 SDE 是在风险中性测度下具有连续股息率的资产的典范表述。它遵循金融数学的基本原理。\n- **适定性：** BSM 模型定价所需的所有必要参数（$S_0$、$K$、$r$、$q$、$T$、$\\sigma$）均已提供。目标陈述清晰，并且由于市场的完备性，该框架保证了唯一无套利价格的存在。术语“波士顿期权”通过其收益函数明确定义，避免了歧义。\n- **客观性：** 该问题使用精确、形式化的数学语言陈述，不含任何主观或基于意见的内容。\n\n步骤 3：结论与行动\n该问题在科学上是合理的、适定的且客观的。它不包含任何矛盾、缺失信息或逻辑缺陷。因此，该问题被判定为**有效**。我们着手求解。\n\n资产定价基本定理指出，衍生证券在时间 $t=0$ 的无套利价格（我们表示为 $V_0$）是其折现后未来收益的期望值，该期望值在风险中性概率测度 $Q$ 下计算。指定合约在时间 $T$ 的收益为 $S_T - K$。从时间 $T$ 到时间 $0$ 的折现因子是 $\\exp(-rT)$。\n\n因此，价格 $V_0$ 由下式给出：\n$$\nV_0 = E_Q[\\exp(-rT)(S_T - K)]\n$$\n根据期望的线性性质，我们可以将各项分开：\n$$\nV_0 = E_Q[\\exp(-rT)S_T] - E_Q[\\exp(-rT)K]\n$$\n由于 $K$ 和 $\\exp(-rT)$ 是常数（非随机的），第二项简化为：\n$$\nE_Q[\\exp(-rT)K] = K\\exp(-rT)\n$$\n第一项需要计算在风险中性测度下资产价格 $S_T$ 的期望值。我们已知 $S_t$ 的风险中性 SDE 为：\n$$\n\\mathrm{d}S_t = (r - q)S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t\n$$\n为了求解 $S_T$，我们考虑 $X_t = \\ln(S_t)$ 的过程。对函数 $f(S_t) = \\ln(S_t)$ 使用 Itô 引理，我们有：\n$$\n\\mathrm{d}X_t = \\frac{\\partial f}{\\partial S} \\mathrm{d}S_t + \\frac{1}{2} \\frac{\\partial^2 f}{\\partial S^2} (\\mathrm{d}S_t)^2\n$$\n其导数为 $\\frac{\\partial f}{\\partial S} = \\frac{1}{S_t}$ 和 $\\frac{\\partial^2 f}{\\partial S^2} = -\\frac{1}{S_t^2}$。二次变差项为 $(\\mathrm{d}S_t)^2 = (\\sigma S_t \\mathrm{d}W_t)^2 = \\sigma^2 S_t^2 \\mathrm{d}t$。将这些代入 Itô 引理的表达式中：\n$$\n\\mathrm{d}X_t = \\frac{1}{S_t}((r - q)S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t) + \\frac{1}{2} \\left(-\\frac{1}{S_t^2}\\right) (\\sigma^2 S_t^2 \\mathrm{d}t)\n$$\n$$\n\\mathrm{d}X_t = (r - q)\\,\\mathrm{d}t + \\sigma \\,\\mathrm{d}W_t - \\frac{1}{2}\\sigma^2\\,\\mathrm{d}t\n$$\n$$\n\\mathrm{d}X_t = \\left(r - q - \\frac{1}{2}\\sigma^2\\right)\\mathrm{d}t + \\sigma \\,\\mathrm{d}W_t\n$$\n从 $t=0$ 积分到 $t=T$：\n$$\n\\int_0^T \\mathrm{d}X_t = \\int_0^T \\left(r - q - \\frac{1}{2}\\sigma^2\\right)\\mathrm{d}t + \\int_0^T \\sigma \\,\\mathrm{d}W_t\n$$\n$$\nX_T - X_0 = \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma (W_T - W_0)\n$$\n由于 $X_t = \\ln(S_t)$ 且 $W_0=0$，我们有：\n$$\n\\ln(S_T) = \\ln(S_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T\n$$\n在测度 $Q$ 下，$W_T$ 是一个均值为 $0$、方差为 $T$ 的正态分布随机变量，即 $W_T \\sim N(0, T)$。因此，$\\ln(S_T)$ 是正态分布，其均值为 $\\mu = \\ln(S_0) + (r - q - \\frac{1}{2}\\sigma^2)T$，方差为 $\\nu^2 = \\sigma^2 T$。\n\n资产价格 $S_T$ 服从对数正态分布。一个对数正态随机变量 $Y$（其中 $\\ln(Y) \\sim N(\\mu, \\nu^2)$）的期望由 $E[Y] = \\exp(\\mu + \\frac{1}{2}\\nu^2)$ 给出。将此应用于 $S_T$：\n$$\nE_Q[S_T] = \\exp\\left(\\left(\\ln(S_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T\\right) + \\frac{1}{2}(\\sigma^2 T)\\right)\n$$\n$$\nE_Q[S_T] = \\exp\\left(\\ln(S_0) + rT - qT - \\frac{1}{2}\\sigma^2 T + \\frac{1}{2}\\sigma^2 T\\right)\n$$\n$$\nE_Q[S_T] = \\exp(\\ln(S_0) + (r - q)T) = \\exp(\\ln(S_0))\\exp((r-q)T)\n$$\n$$\nE_Q[S_T] = S_0 \\exp((r-q)T)\n$$\n这一结果证实了在风险中性测度下的预期未来价格即为远期价格。现在我们将此期望代回定价公式：\n$$\nV_0 = \\exp(-rT)E_Q[S_T] - K\\exp(-rT)\n$$\n$$\nV_0 = \\exp(-rT) \\left(S_0 \\exp((r-q)T)\\right) - K\\exp(-rT)\n$$\n化简表达式：\n$$\nV_0 = S_0 \\exp(-rT + (r-q)T) - K\\exp(-rT)\n$$\n$$\nV_0 = S_0 \\exp(-qT) - K\\exp(-rT)\n$$\n此表达式是时间 $t=0$ 的无套利价格。该合约实际上是一份具有预定交割价格 $K$ 的远期合约。其价值等于将收到的资产的现值，并经过放弃的股息调整（$S_0 \\exp(-qT)$），减去将支付的款项的现值（$K \\exp(-rT)$）。", "answer": "$$\n\\boxed{S_{0} \\exp(-qT) - K \\exp(-rT)}\n$$"}, {"introduction": "在掌握了基本原理之后，这项练习将挑战你为更复杂的“奇异”衍生品定价，特别是价差期权和现金或无价值期权。这些工具的收益具有不连续性，初看之下其估值似乎令人望而生畏。该练习展示了BSM框架的通用性，教你如何将复杂的收益分解为更简单、可管理的组成部分，并使用同样强大的风险中性预期逻辑对其进行定价。[@problem_id:2438273]", "id": "2438273", "problem": "考虑一个满足 Black-Scholes-Merton (BSM) 假设的无摩擦市场。设连续复利无风险利率为常数 $r \\ge 0$，且一只股票以恒定速率 $q \\ge 0$ 支付连续股息。在风险中性概率测度下，股票价格过程 $\\{S_t\\}_{t \\in [0,T]}$ 遵循如下随机微分方程\n$$\n\\mathrm{d}S_t = (r - q)\\,S_t\\,\\mathrm{d}t + \\sigma\\,S_t\\,\\mathrm{d}W_t,\n$$\n其中 $S_0 > 0$，波动率 $\\sigma > 0$，$W_t$ 为标准布朗运动。固定到期日 $T > 0$。设 $K_1 > 0$，$K_2 > 0$ 和 $A > 0$ 为给定常数。\n\n定义两种到期日为 T 的欧式或有债权：\n- 债权 $\\mathcal{C}_{\\text{cash}}$ 的支付为：若 $S_T > K_1$，则为 $A$；否则为 $0$。\n- 债权 $\\mathcal{C}_{\\text{gap}}$ 的支付为 $(S_T - K_2)\\,\\mathbf{1}_{\\{S_T > K_1\\}}$。\n\n假设 Black-Scholes-Merton 框架中通常的无套利和市场完备性条件成立。求 $\\mathcal{C}_{\\text{cash}}$ 和 $\\mathcal{C}_{\\text{gap}}$ 在 0 时刻的无套利价格的封闭解，用模型参数 $S_0$、$r$、$q$、$\\sigma$、$T$、$K_1$、$K_2$ 和 $A$ 表示。\n\n答案格式：请以一个 $1 \\times 2$ 行矩阵的形式提供最终答案，其中第一个条目为 $\\mathcal{C}_{\\text{cash}}$ 的价格，第二个条目为 $\\mathcal{C}_{\\text{gap}}$ 的价格。不要四舍五入。答案中不要包含任何单位。", "solution": "题干陈述通过验证。\n\n**步骤1：提取已知条件**\n- 市场假设：无摩擦，满足 Black-Scholes-Merton (BSM) 框架。\n- 连续复利无风险利率：常数 $r \\ge 0$。\n- 连续股息率：恒定速率 $q \\ge 0$。\n- 风险中性股票价格过程 $\\{S_t\\}_{t \\in [0,T]}$：$\\mathrm{d}S_t = (r - q)\\,S_t\\,\\mathrm{d}t + \\sigma\\,S_t\\,\\mathrm{d}W_t$。\n- 初始股票价格：$S_0 > 0$。\n- 波动率：$\\sigma > 0$。\n- $W_t$：标准布朗运动。\n- 到期日：$T > 0$。\n- 常数：$K_1 > 0$，$K_2 > 0$，$A > 0$。\n- 债权 $\\mathcal{C}_{\\text{cash}}$ 在 T 时刻的支付：若 $S_T > K_1$ 则为 $A$，否则为 0。即 $A \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}$。\n- 债权 $\\mathcal{C}_{\\text{gap}}$ 在 T 时刻的支付：$(S_T - K_2)\\,\\mathbf{1}_{\\{S_T > K_1\\}}$。\n- 经济假设：无套利和市场完备性。\n- 目标：求 $\\mathcal{C}_{\\text{cash}}$ 和 $\\mathcal{C}_{\\text{gap}}$ 的 0 时刻无套利价格。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是量化金融基本理论 Black-Scholes-Merton 模型的标准应用。该问题是适定的，因为 BSM 框架为计算具有给定支付结构的欧式衍生品的唯一价格提供了方法论。所有必要的参数均以符号形式给出，问题是自洽的，且没有内部矛盾。语言客观、精确。该问题不违反任何指定的无效标准。\n\n**步骤3：结论与行动**\n问题有效，可以求解。\n\n资产定价基本定理指出，在一个完备、无套利的市场中，到期日为 $T$、支付为 $\\Pi(S_T)$ 的欧式或有债权的 0 时刻价格 $V_0$ 是在风险中性概率测度 $\\mathbb{Q}$ 下支付的贴现期望值。\n$$\nV_0 = \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[\\Pi(S_T)]\n$$\n在 $\\mathbb{Q}$ 下，给定的股票价格 $S_t$ 的随机微分方程是一个几何布朗运动。该随机微分方程的解为：\n$$\nS_T = S_0 \\exp\\left( \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T \\right)\n$$\n其中在 $\\mathbb{Q}$ 下 $W_T \\sim N(0, T)$。我们可以写成 $W_T = \\sqrt{T}Z$，其中 Z 是一个标准正态随机变量，$Z \\sim N(0, 1)$。因此，$\\ln(S_T)$ 服从正态分布：\n$$\n\\ln(S_T) \\sim N\\left(\\ln(S_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T, \\sigma^2 T\\right)\n$$\n为方便起见，我们定义关于执行价格 $K_1$ 的标准 BSM 辅助变量 $d_1$ 和 $d_2$：\n$$\nd_1 = \\frac{\\ln(S_0/K_1) + (r - q + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_2 = \\frac{\\ln(S_0/K_1) + (r - q - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} = d_1 - \\sigma\\sqrt{T}\n$$\n令 $N(\\cdot)$ 表示标准正态分布的累积分布函数 (CDF)。\n\n**债权 $\\mathcal{C}_{\\text{cash}}$ 的价格**\n$\\mathcal{C}_{\\text{cash}}$ 的支付为 $\\Pi_{\\text{cash}} = A \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}$。这是一种现金或无价值看涨期权。其 0 时刻价格，记为 $V_{\\text{cash}}(0)$，为：\n$$\nV_{\\text{cash}}(0) = \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[A \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}] = A \\exp(-rT)\\,\\mathbb{Q}(S_T > K_1)\n$$\n我们必须计算概率 $\\mathbb{Q}(S_T > K_1)$。\n$$\n\\mathbb{Q}(S_T > K_1) = \\mathbb{Q}\\left( \\ln(S_T) > \\ln(K_1) \\right)\n$$\n$$\n= \\mathbb{Q}\\left( \\ln(S_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T}Z > \\ln(K_1) \\right)\n$$\n$$\n= \\mathbb{Q}\\left( \\sigma\\sqrt{T}Z > \\ln(K_1/S_0) - \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T \\right)\n$$\n$$\n= \\mathbb{Q}\\left( Z > -\\frac{\\ln(S_0/K_1) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}} \\right)\n$$\n概率的参数恰好是 $-d_2$。\n$$\n\\mathbb{Q}(S_T > K_1) = \\mathbb{Q}(Z > -d_2) = \\mathbb{Q}(Z \\le d_2) = N(d_2)\n$$\n因此，$\\mathcal{C}_{\\text{cash}}$ 的价格为：\n$$\nV_{\\text{cash}}(0) = A \\exp(-rT) N(d_2)\n$$\n\n**债权 $\\mathcal{C}_{\\text{gap}}$ 的价格**\n$\\mathcal{C}_{\\text{gap}}$ 的支付为 $\\Pi_{\\text{gap}} = (S_T - K_2)\\,\\mathbf{1}_{\\{S_T > K_1\\}}$。这是一种价差期权 (gap option)。其 0 时刻价格，记为 $V_{\\text{gap}}(0)$，可以通过期望的线性性质进行分解：\n$$\nV_{\\text{gap}}(0) = \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[(S_T - K_2)\\,\\mathbf{1}_{\\{S_T > K_1\\}}]\n$$\n$$\n= \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[S_T \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}] - K_2 \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[\\mathbf{1}_{\\{S_T > K_1\\}}]\n$$\n第二项与之前计算的现金或无价值看涨期权的价格直接相关：\n$$\nK_2 \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[\\mathbf{1}_{\\{S_T > K_1\\}}] = K_2 \\exp(-rT)\\,\\mathbb{Q}(S_T > K_1) = K_2 \\exp(-rT) N(d_2)\n$$\n第一项是在 $S_T > K_1$ 的条件下收到资产的风险中性期望的贴现值。这是资产或无价值看涨期权的价格。一个标准的结果是，该价格为 $S_0 \\exp(-qT) N(d_1)$。从形式上讲，这可以通过更换计价物为 $S_t \\exp(-qt)$ 或通过直接积分推导得出：\n$$\n\\mathbb{E}^{\\mathbb{Q}}[S_T \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}] = \\int_{-\\infty}^{\\infty} S_0 \\exp\\left( \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T}z \\right) \\cdot \\mathbf{1}_{\\{S_T > K_1\\}} \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{z^2}{2}\\right) dz\n$$\n条件 $S_T > K_1$ 对应于 $z > -d_2$。积分变为：\n$$\nS_0 \\exp\\left( (r-q)T \\right) \\int_{-d_2}^{\\infty} \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{1}{2}(z - \\sigma\\sqrt{T})^2\\right) dz\n$$\n使用换元 $y = z - \\sigma\\sqrt{T}$，积分下限变为 $-d_2 - \\sigma\\sqrt{T} = -(d_2 + \\sigma\\sqrt{T}) = -d_1$。该积分计算结果为 $N(d_1)$。\n$$\n\\mathbb{E}^{\\mathbb{Q}}[S_T \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}] = S_0 \\exp((r-q)T) N(d_1)\n$$\n将其贴现回 0 时刻，得到第一项的值：\n$$\n\\exp(-rT) \\left( S_0 \\exp((r-q)T) N(d_1) \\right) = S_0 \\exp(-qT) N(d_1)\n$$\n合并这两项，$\\mathcal{C}_{\\text{gap}}$ 的价格为：\n$$\nV_{\\text{gap}}(0) = S_0 \\exp(-qT) N(d_1) - K_2 \\exp(-rT) N(d_2)\n$$\n\n最终价格以给定的模型参数表示，其中 $d_1$、$d_2$ 和 $N(\\cdot)$ 的定义如上。", "answer": "$$\n\\boxed{\\begin{pmatrix} A \\exp(-rT) N\\left(\\frac{\\ln(S_0/K_1) + (r - q - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\\right) & S_0 \\exp(-qT) N\\left(\\frac{\\ln(S_0/K_1) + (r - q + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\\right) - K_2 \\exp(-rT) N\\left(\\frac{\\ln(S_0/K_1) + (r - q - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\\right) \\end{pmatrix}}\n$$"}, {"introduction": "我们最后的练习将从静态定价理论转向动态对冲的实践现实。这个计算练习要求你通过模拟delta对冲策略来衡量其有效性和局限性。通过比较在模型的理想条件下（几何布朗运动）与一个更现实、模型设定错误的流程下的对冲误差，你将对模型风险以及离散时间对冲不可避免的缺陷获得切实的理解，从而在理论模型与其实际应用之间架起一座桥梁。[@problem_id:2438266]", "id": "2438266", "problem": "构建一个独立的程序，用于计算和比较一个欧式看涨期权在两种不同的标的资产价格数据生成过程下的期末对冲误差。该对冲策略为delta中性、自融资的复制策略。第一个过程是几何布朗运动，第二个是通过对一个Ornstein-Uhlenbeck过程取指数得到的均值回归过程。所有利率和波动率都必须以小数形式表示。\n\n设标的资产价格表示为 $S_t$，执行价格为 $K$，连续复利无风险利率为 $r$，到期时间为 $T$。考虑一个收益为 $\\max(S_T - K, 0)$ 的欧式看涨期权。\n\n模型A（几何布朗运动）：价格过程 $S_t$ 遵循\n$$\n\\mathrm{d}S_t = (r - q)\\, S_t\\, \\mathrm{d}t + \\sigma\\, S_t\\, \\mathrm{d}W_t,\n$$\n其中连续股息率为 $q = 0$。模型B（指数Ornstein-Uhlenbeck）：定义 $X_t$ 如下\n$$\n\\mathrm{d}X_t = \\kappa\\,(\\theta - X_t)\\,\\mathrm{d}t + \\eta\\, \\mathrm{d}W_t,\n$$\n并设 $S_t = \\exp(X_t)$ 以确保价格为正。使用 $X_0 = \\ln(S_0)$ 并设 $\\theta = \\ln(S_0)$。\n\n对冲策略定义如下。在一个均匀时间网格上，于每个调仓时间 $t_i$（其中 $t_0 = 0$, $t_i = i\\,\\Delta t$, $i \\in \\{0,1,\\dots,N\\}$, 且 $\\Delta t = T/N$），构建一个delta中性、自融资的投资组合。该组合使用在几何布朗运动假设下（波动率参数为 $\\sigma$，股息率为 $q=0$）计算出的Black-Scholes-Merton delta。具体来说，令 $C_{\\text{BSM}}(S, K, r, \\sigma, \\tau)$ 表示剩余到期时间为 $\\tau$ 时的Black-Scholes-Merton价格，令 $\\Delta_{\\text{BSM}}(S, K, r, \\sigma, \\tau)$ 表示相应的delta值。在 $t_0$ 时刻，用现金 $B_0$ 和股票头寸 $\\Delta_0$ 初始化投资组合，其中 $\\Delta_0 = \\Delta_{\\text{BSM}}(S_0, K, r, \\sigma, T)$ 且 $B_0 = C_{\\text{BSM}}(S_0, K, r, \\sigma, T) - \\Delta_0 S_0$。在两次调仓之间，现金账户以利率 $r$ 计息。在每个调仓时间 $t_i$（其中 $i \\in \\{1,\\dots,N-1\\}$），通过买卖股票将股票头寸从 $\\Delta_{i-1}$ 调整至 $\\Delta_i = \\Delta_{\\text{BSM}}(S_{t_i}, K, r, \\sigma, T - t_i)$；现金账户会相应地进行扣款或存款，从而使该策略是自融资的。在到期日 $t_N = T$ 不进行调仓。期末投资组合价值为\n$$\nV_T = \\Delta_{N-1}\\, S_T + B_{N-1}\\, \\mathrm{e}^{r \\Delta t},\n$$\n期末对冲误差为\n$$\nE = V_T - \\max(S_T - K, 0).\n$$\n\n你的程序必须为每个指定的测试用例估算模型A和模型B下的均方根对冲误差。这需要以时间步长 $\\Delta t = T/N$ 模拟标的过程的 $M$ 条独立路径，沿每条路径执行所述的离散时间对冲策略，然后计算\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} E_m^2}.\n$$\n为使结果具有确定性且可测试，对于索引从0开始的测试用例 $i$，使用以种子 $s_i = 123456 + i$ 初始化的伪随机数生成器，并在每个测试用例中对模型A和模型B使用相同的标准正态冲击序列。所有利率和波动率都必须以小数形式表示。\n\n测试套件（三个用例，共同覆盖一个典型情况、一个粗粒度调仓边界情况和一个压力配置情况）。在每个用例中，指定 $(S_0, K, r, T, \\sigma, \\kappa, \\eta, N, M)$:\n- 用例 $0$（典型情况）：$S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 252$, $M = 20000$。\n- 用例 $1$（粗粒度调仓）：$S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 1$, $M = 20000$。\n- 用例 $2$（压力情况）：$S_0 = 100$, $K = 50$, $r = 0.02$, $T = 0.25$, $\\sigma = 0.4$, $\\kappa = 3.0$, $\\eta = 0.3$, $N = 13$, $M = 20000$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个以逗号分隔并用方括号括起来的结果列表。对于每个测试用例 $i \\in \\{0,1,2\\}$，报告一个双元素列表 $[\\text{RMSE}^{(A)}_i, \\text{RMSE}^{(B)}_i]$，其中 $\\text{RMSE}^{(A)}_i$ 是模型A下的均方根对冲误差，$\\text{RMSE}^{(B)}_i$ 是模型B下的均方根对冲误差。将报告的每个值四舍五入到6位小数。最终输出因此必须是如下所示的单行\n$$\n\\bigl[[\\text{RMSE}^{(A)}_0,\\ \\text{RMSE}^{(B)}_0],\\ [\\text{RMSE}^{(A)}_1,\\ \\text{RMSE}^{(B)}_1],\\ [\\text{RMSE}^{(A)}_2,\\ \\text{RMSE}^{(B)}_2]\\bigr].\n$$", "solution": "我们比较一个欧式看涨期权在两种不同标的数据生成过程下的离散时间delta对冲复制误差。该构建基于两个原则：Black-Scholes-Merton框架下的无套利定价和自融资delta对冲。\n\n首先，在Black-Scholes-Merton框架（Black-Scholes-Merton）下，当标的资产 $S_t$ 遵循连续股息率 $q = 0$ 的几何布朗运动时，\n$$\n\\mathrm{d}S_t = (r - q)\\, S_t\\, \\mathrm{d}t + \\sigma\\, S_t\\, \\mathrm{d}W_t,\n$$\n欧式看涨期权的无套利价格 $C_{\\text{BSM}}(S, K, r, \\sigma, \\tau)$（其中剩余到期时间为 $\\tau$）可以通过求解风险中性估值问题，或等价地，求解相关的偏微分方程得到。相应的delta是价格对标的资产的导数。具体公式如下：\n$$\nd_1 = \\frac{\\ln(S/K) + (r - q + \\tfrac{1}{2}\\sigma^2)\\tau}{\\sigma \\sqrt{\\tau}},\\quad d_2 = d_1 - \\sigma \\sqrt{\\tau},\n$$\n$$\nC_{\\text{BSM}}(S, K, r, \\sigma, \\tau) = \\mathrm{e}^{-q \\tau} S\\, \\Phi(d_1) - \\mathrm{e}^{-r \\tau} K\\, \\Phi(d_2),\n$$\n$$\n\\Delta_{\\text{BSM}}(S, K, r, \\sigma, \\tau) = \\mathrm{e}^{-q \\tau}\\, \\Phi(d_1),\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数，且此处 $q=0$。\n\n其次，考虑一个自融资、delta中性的投资组合，该组合初始时卖空一份看涨期权，并持有 $\\Delta_0 = \\Delta_{\\text{BSM}}(S_0, K, r, \\sigma, T)$ 份股票，现金为 $B_0 = C_{\\text{BSM}}(S_0, K, r, \\sigma, T) - \\Delta_0 S_0$。在网格 $t_i = i \\Delta t$（其中 $i \\in \\{0,1,\\dots,N\\}$ 且 $\\Delta t = T/N$）上，现金账户在两次调仓之间以利率 $r$ 计息，在时间 $t_i$ 从 $\\Delta_{i-1}$ 调仓至 $\\Delta_i$ 会使现金改变 $-(\\Delta_i - \\Delta_{i-1}) S_{t_i}$。由于 $q=0$，没有股息流。作为对连续时间自融资条件的离散时间近似，对于 $i \\in \\{1,2,\\dots,N-1\\}$，\n$$\nB_i = B_{i-1}\\, \\mathrm{e}^{r \\Delta t} - \\left(\\Delta_i - \\Delta_{i-1}\\right) S_{t_i}.\n$$\n在到期日 $t_N = T$ 不进行调仓。期末投资组合价值为\n$$\nV_T = \\Delta_{N-1} S_T + B_{N-1}\\, \\mathrm{e}^{r \\Delta t},\n$$\n期末对冲误差为\n$$\nE = V_T - \\max(S_T - K, 0).\n$$\n\n我们针对两种数据生成过程，在 $M$ 条样本路径上评估和比较其均方根误差：\n\n- 模型A（几何布朗运动）：模拟\n$$\nS_{t_{i+1}} = S_{t_i} \\exp\\left((r - q - \\tfrac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z_i\\right),\n$$\n其中 $q=0$，且 $Z_i$ 为独立标准正态冲击。\n\n- 模型B（指数Ornstein-Uhlenbeck）：模拟 $X_t$ 如下\n$$\nX_{t_{i+1}} = \\theta + (X_{t_i} - \\theta)\\, \\mathrm{e}^{-\\kappa \\Delta t} + \\eta\\, \\sqrt{\\frac{1 - \\mathrm{e}^{-2 \\kappa \\Delta t}}{2 \\kappa}}\\, Z_i,\n$$\n并设 $S_{t_i} = \\exp(X_{t_i})$。我们使用 $X_0 = \\ln(S_0)$ 和 $\\theta = \\ln(S_0)$，使得 $X_t$ 向初始对数价格均值回归。\n\n在给定的测试用例中，对两个模型使用相同的冲击序列 $Z_i$ 可以提高可比性。为了保证确定性，我们对于索引为 $i \\in \\{0,1,2\\}$ 的测试用例，使用种子 $s_i = 123456 + i$ 初始化伪随机数生成器。对于每条路径，我们执行离散对冲程序：在 $t_0$ 时刻，根据Black-Scholes-Merton价格和delta设置 $\\Delta_0$ 和 $B_0$；在每个区间内，现金以利率 $r$ 计息，用所选模型推进标的资产价格；在下一个网格时间 $t_i$（其中 $i \\in \\{1,\\dots,N-1\\}$），使用根据当前 $S_{t_i}$ 和剩余时间 $T - t_i$ 计算的Black-Scholes-Merton delta来更新 $\\Delta_i$，并通过 $-(\\Delta_i - \\Delta_{i-1}) S_{t_i}$ 调整现金。在到期时，计算 $V_T$ 和误差 $E$，然后计算均方根误差\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} E_m^2}.\n$$\n\n测试套件指定了三组参数：\n- 用例 $0$：$S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 252$, $M = 20000$，种子 $123456$。\n- 用例 $1$：$S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 1$, $M = 20000$，种子 $123457$。\n- 用例 $2$：$S_0 = 100$, $K = 50$, $r = 0.02$, $T = 0.25$, $\\sigma = 0.4$, $\\kappa = 3.0$, $\\eta = 0.3$, $N = 13$, $M = 20000$，种子 $123458$。\n\n最终程序必须输出单行内容，将三个用例的结果汇总为一个列表的列表\n$$\n\\bigl[[\\text{RMSE}^{(A)}_0,\\ \\text{RMSE}^{(B)}_0],\\ [\\text{RMSE}^{(A)}_1,\\ \\text{RMSE}^{(B)}_1],\\ [\\text{RMSE}^{(A)}_2,\\ \\text{RMSE}^{(B)}_2]\\bigr],\n$$\n每个浮点数四舍五入到6位小数。这种格式便于自动评估。其科学原理在于，在几何布朗运动和连续调仓的条件下，Black-Scholes-Merton delta对冲可以消除风险，而离散调仓会留下残余误差；在错误设定的动态过程（例如指数Ornstein-Uhlenbeck过程）下，Black-Scholes-Merton delta与模型不一致，复制误差通常更大，而本计算正是要量化这一事实。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import log, exp, sqrt, isfinite\nfrom scipy.stats import norm\n\ndef bs_price_delta(S, K, r, sigma, tau):\n    \"\"\"\n    Black-Scholes-Merton call price and delta with zero dividend yield.\n    Vectorized over S and tau (tau can be scalar).\n    \"\"\"\n    S = np.asarray(S, dtype=float)\n    tau = float(tau)\n    # Handle tau == 0 separately to avoid division by zero.\n    if tau <= 0.0:\n        # At maturity: price = max(S - K, 0), delta = 1_{S > K} with 0.5 at S==K\n        price = np.maximum(S - K, 0.0)\n        delta = np.where(S > K, 1.0, np.where(S < K, 0.0, 0.5))\n        return price, delta\n\n    # For tau > 0:\n    vol_sqrt_tau = sigma * sqrt(tau)\n    # Avoid log(0)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        d1 = (np.log(S / K) + (r + 0.5 * sigma * sigma) * tau) / vol_sqrt_tau\n    d2 = d1 - vol_sqrt_tau\n\n    Nd1 = norm.cdf(d1)\n    Nd2 = norm.cdf(d2)\n    price = S * Nd1 - K * exp(-r * tau) * Nd2\n    delta = Nd1\n    # Handle any NaNs due to S <= 0 (shouldn't occur in our simulations)\n    price = np.where(np.isfinite(price), price, 0.0)\n    delta = np.where(np.isfinite(delta), delta, 0.0)\n    return price, delta\n\ndef simulate_and_hedge_gbm(S0, K, r, sigma, T, N, Z):\n    \"\"\"\n    Simulate GBM paths and compute RMSE of terminal hedging error\n    for BSM delta-hedging with discrete rebalancing.\n    Z: array of shape (M, N) standard normals for increments.\n    \"\"\"\n    M, Ncols = Z.shape\n    assert Ncols == N, \"Z shape mismatch with N\"\n    dt = T / N\n    # Initialize\n    S = np.full(M, S0, dtype=float)\n    # Initial BSM price and delta\n    price0, delta = bs_price_delta(S, K, r, sigma, T)\n    cash = price0 - delta * S  # initial cash position\n\n    mu_dt = (r - 0.0 - 0.5 * sigma * sigma) * dt\n    vol_sqrt_dt = sigma * sqrt(dt)\n    erdt = exp(r * dt)\n\n    # Rebalance at times t=dt, 2dt, ..., (N-1)dt\n    for i in range(N):\n        # Accrue cash over dt\n        cash *= erdt\n        # Advance S over dt\n        S = S * np.exp(mu_dt + vol_sqrt_dt * Z[:, i])\n        # Rebalance at next grid time if not maturity\n        if i < N - 1:\n            tau_next = T - (i + 1) * dt\n            # Compute new delta at time t_{i+1}\n            _, delta_next = bs_price_delta(S, K, r, sigma, tau_next)\n            # Self-financing cash adjustment\n            cash -= (delta_next - delta) * S\n            delta = delta_next\n        # else: no rebalancing at maturity\n\n    # Terminal portfolio value and hedging error\n    V_T = delta * S + cash\n    payoff = np.maximum(S - K, 0.0)\n    error = V_T - payoff\n    rmse = float(np.sqrt(np.mean(error * error)))\n    return rmse\n\ndef simulate_and_hedge_expou(S0, K, r, sigma, T, N, Z, kappa, eta):\n    \"\"\"\n    Simulate exponential OU paths (X OU, S=exp(X)) and compute RMSE of\n    terminal hedging error for BSM delta-hedging with discrete rebalancing.\n    Z: array of shape (M, N) standard normals for increments.\n    \"\"\"\n    M, Ncols = Z.shape\n    assert Ncols == N, \"Z shape mismatch with N\"\n    dt = T / N\n    # Initialize\n    X = np.full(M, log(S0), dtype=float)\n    theta = log(S0)  # mean-reversion level for log-price\n    S = np.exp(X)\n\n    # Initial BSM price and delta based on initial S\n    price0, delta = bs_price_delta(S, K, r, sigma, T)\n    cash = price0 - delta * S  # initial cash position\n\n    erdt = exp(r * dt)\n    ekdt = exp(-kappa * dt)\n    # Exact OU increment variance term\n    var_term = (1.0 - exp(-2.0 * kappa * dt)) / (2.0 * kappa) if kappa > 0 else dt\n    std_ou = eta * sqrt(var_term)\n\n    for i in range(N):\n        # Accrue cash over dt\n        cash *= erdt\n        # Advance X with exact OU step, then S = exp(X)\n        X = theta + (X - theta) * ekdt + std_ou * Z[:, i]\n        S = np.exp(X)\n        if i < N - 1:\n            tau_next = T - (i + 1) * dt\n            _, delta_next = bs_price_delta(S, K, r, sigma, tau_next)\n            cash -= (delta_next - delta) * S\n            delta = delta_next\n\n    V_T = delta * S + cash\n    payoff = np.maximum(S - K, 0.0)\n    error = V_T - payoff\n    rmse = float(np.sqrt(np.mean(error * error)))\n    return rmse\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (S0, K, r, T, sigma, kappa, eta, N, M)\n    test_cases = [\n        (100.0, 100.0, 0.02, 1.0, 0.2, 1.0, 0.2, 252, 20000),   # Case 0\n        (100.0, 100.0, 0.02, 1.0, 0.2, 1.0, 0.2, 1,   20000),   # Case 1\n        (100.0, 50.0,  0.02, 0.25, 0.4, 3.0, 0.3, 13,  20000),  # Case 2\n    ]\n\n    results = []\n    for idx, case in enumerate(test_cases):\n        S0, K, r, T, sigma, kappa, eta, N, M = case\n        # Set deterministic seed per case\n        seed = 123456 + idx\n        rng = np.random.default_rng(seed)\n        Z = rng.standard_normal(size=(M, N))\n        # Model A: GBM\n        rmse_gbm = simulate_and_hedge_gbm(S0, K, r, sigma, T, N, Z)\n        # Model B: Exponential OU\n        rmse_expou = simulate_and_hedge_expou(S0, K, r, sigma, T, N, Z, kappa, eta)\n        # Round to 6 decimals as required\n        results.append([round(rmse_gbm, 6), round(rmse_expou, 6)])\n\n    # Format as a single-line nested list with comma-separated values.\n    # Ensure fixed 6 decimal places.\n    def format_results(res):\n        parts = []\n        for pair in res:\n            parts.append(f\"[{pair[0]:.6f},{pair[1]:.6f}]\")\n        return \"[\" + \",\".join(parts) + \"]\"\n\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}