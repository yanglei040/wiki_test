{"hands_on_practices": [{"introduction": "在实现任何算法之前，理解其性能特征至关重要，这在计算金融领域尤其如此。本练习通过分析 Longstaff-Schwartz 蒙特卡洛 (LSMC) 方法的计算复杂度，并将其与传统的有限差分法进行比较，来探讨这一问题。通过完成这项练习，您将对“维度灾难”以及为何像 LSMC 这样的蒙特卡洛方法在为高维期权定价时更具优势，有一个深刻的定量理解，这对于为给定的定价问题选择正确的数值工具有着至关重要的作用。[@problem_id:2442266]", "id": "2442266", "problem": "考虑使用两种不同的数值方法为具有二维状态变量的美式或有债权定价：Longstaff–Schwartz 蒙特卡洛方法 (LSMC) 和有限差分法。假设以下设置和约定。\n\n- 状态是二维的，并且有 $T$ 个离散的行权日。对于 Longstaff–Schwartz 蒙特卡洛方法 (LSMC)，模拟了 $M$ 条独立的样本路径，每条路径有 $T$ 个行权日。在到期前的每个行权日，执行一次最小二乘回归，使用两个状态变量中总次数最多为 $p$ 的多项式基来估计持续价值。该回归通过正规方程实现，即通过计算 $X^{\\top} X$ 和 $X^{\\top} y$ 形成方程组，然后在每个行权日通过高斯消元法求解。假设在最坏情况下，所有 $M$ 条路径在所有行权日都处于价内状态，并且对实数的每次算术运算计为单位成本。\n- 对于有限差分法，时间域被离散化为 $N_{t}$ 个步长，空间网格为 $G \\times G$。在每个时间步，通过投影逐次超松弛法 (PSOR) 求解一个投影线性互补条件来强制执行美式提前行权约束，每个时间步迭代 $I$ 次，其中 $I$ 不依赖于 $G$。每次 PSOR 迭代访问每个网格点一次，每个点的算术工作量为 $\\mathcal{O}(1)$。\n\n假设 $N_{t} = T$，因此两种方法使用相同数量的时间层级。忽略常数因子和低阶项。在随机存取机模型中进行计算，其中对于一个 $M \\times K$ 的设计矩阵，形成 $X^{\\top} X$ 的复杂度为 $\\mathcal{O}(M K^{2})$，形成 $X^{\\top} y$ 的复杂度为 $\\mathcal{O}(M K)$，通过高斯消元法求解一个稠密的 $K \\times K$ 线性系统的复杂度为 $\\mathcal{O}(K^{3})$。令 $K$ 表示由组合计数推断出的、两个变量中总次数最多为 $p$ 的多项式基函数的数量，包括常数项。\n\n将 $C_{\\mathrm{LSMC}}$ 和 $C_{\\mathrm{FD}}$ 分别定义为 LSMC 和有限差分法的首项算术运算计数（忽略常数因子）。在 $C_{\\mathrm{LSMC}}$ 中 $M K^{2}$ 支配 $K^{3}$ 和 $M$，且在 $C_{\\mathrm{FD}}$ 中 $I$ 被视为常数的渐进情况下，推导渐进比率\n$$\nR \\equiv \\frac{C_{\\mathrm{LSMC}}}{C_{\\mathrm{FD}}}\n$$\n并仅用 $M$、$p$ 和 $G$ 来完全简化它。\n\n请将您的最终答案表示为 $R$ 的单个闭式解析表达式。无需四舍五入。", "solution": "该问题要求推导用于美式或有债权定价的两种数值方法——Longstaff-Schwartz 蒙特卡洛 (LSMC) 方法和有限差分 (FD) 方法——的计算成本之比，$R \\equiv \\frac{C_{\\mathrm{LSMC}}}{C_{\\mathrm{FD}}}$。\n\n首先，我们确定 LSMC 方法的首项算术运算计数 $C_{\\mathrm{LSMC}}$。\nLSMC 算法从行权日 $T-1$ 向后推至 $1$。执行回归的时间步数为 $T-1$。\n在这些时间步中的每一步，都使用最小二乘回归来估计持续价值。回归的基由两个状态变量中总次数最多为 $p$ 的多项式组成。此类基函数的数量，记为 $K$，可以通过组合论证确定。不等式 $i_1 + i_2 \\le p$ 的非负整数解的数量等价于 $i_1 + i_2 + s = p$ 的非负整数解的数量，其中 $s$ 是一个松弛变量。这是一个经典的隔板法问题，解的数量由 $\\binom{p+d}{d}$ 给出，其中变量数量 $d=2$。\n因此，基函数的数量为：\n$$\nK = \\binom{p+2}{2} = \\frac{(p+2)!}{2!p!} = \\frac{(p+2)(p+1)}{2}\n$$\n回归是在 $M$ 条路径上执行的，因此设计矩阵 $X$ 的维度为 $M \\times K$。回归过程的成本被指定为形成 $X^{\\top}X$、形成 $X^{\\top}y$ 以及求解所得线性系统的成本之和。这些成本分别由 $\\mathcal{O}(M K^2)$、$\\mathcal{O}(M K)$ 和 $\\mathcal{O}(K^3)$ 给出。问题指出我们处于 $M K^2$ 项占主导地位的渐进机制下。因此，单个时间步的回归成本被视为与 $M K^2$ 成正比。\nLSMC 方法的总成本 $C_{\\mathrm{LSMC}}$ 是每个时间步的成本乘以时间步数 $T-1$。忽略常数因子和低阶项，首项复杂度为：\n$$\nC_{\\mathrm{LSMC}} \\propto (T-1) M K^2 \\sim T M K^2\n$$\n代入 $K$ 的表达式：\n$$\nC_{\\mathrm{LSMC}} = T M \\left( \\frac{(p+1)(p+2)}{2} \\right)^2\n$$\n根据问题中“忽略常数因子”的指示，我们将 $C_{\\mathrm{LSMC}}$ 定义为运算计数中的主导项，并将比例常数设为 $1$。\n\n接下来，我们确定有限差分 (FD) 方法的首项算术运算计数 $C_{\\mathrm{FD}}$。\nFD 方案也随时间向后进行。时间步数给定为 $N_t$，我们被指示设置 $N_t = T$。因此有 $T-1$ 个后向步骤。\n空间域是一个大小为 $G \\times G$ 的网格，包含 $G^2$ 个点。\n在每个时间步，通过投影逐次超松弛法 (PSOR) 求解一个投影线性互补问题来处理提前行权约束。此过程需要 $I$ 次迭代。每次迭代访问 $G^2$ 个网格点中的每一个，并对每个点执行 $\\mathcal{O}(1)$ 的工作量。因此，一次 PSOR 迭代的成本为 $\\mathcal{O}(G^2)$。每个时间步的总成本是每次迭代的成本乘以迭代次数 $I$，即 $\\mathcal{O}(I G^2)$。\n问题指出 $I$ 是一个常数。因此，每个时间步的首项成本与 $G^2$ 成正比。\nFD 方法的总成本 $C_{\\mathrm{FD}}$ 是每个时间步的成本乘以时间步数 $T-1$。\n$$\nC_{\\mathrm{FD}} \\propto (T-1) G^2 \\sim T G^2\n$$\n再次忽略常数因子（其中包括 $I$），我们将首项计数定义为：\n$$\nC_{\\mathrm{FD}} = T G^2\n$$\n\n最后，我们计算比率 $R \\equiv \\frac{C_{\\mathrm{LSMC}}}{C_{\\mathrm{FD}}}$。\n$$\nR = \\frac{T M \\left( \\frac{(p+1)(p+2)}{2} \\right)^2}{T G^2}\n$$\n分子和分母中的因子 $T$ 被约掉：\n$$\nR = \\frac{M \\left( \\frac{(p+1)(p+2)}{2} \\right)^2}{G^2}\n$$\n简化此表达式得到最终结果：\n$$\nR = \\frac{M (p+1)^2 (p+2)^2}{4 G^2}\n$$\n该表达式按要求给出了计算成本关于 $M$、$p$ 和 $G$ 的渐进比率。", "answer": "$$\n\\boxed{\\frac{M(p+1)^{2}(p+2)^{2}}{4G^{2}}}\n$$"}, {"introduction": "理解了 LSMC 的理论效率后，下一步便是着手实现。然而，一个看似正确的实现可能会隐藏着一些微妙但重大的错误。本练习将指导您通过编程实践，来揭示 LSMC 中一个众所周知的陷阱：样本内价格估计的过度乐观偏差。您将学会区分有偏差的样本内估计和更稳健的样本外估计，这是任何严谨的量化建模的基石，对于培养严谨的建模思维和验证习惯至关重要。[@problem_id:2442310]", "id": "2442310", "problem": "实现一个完整的程序，以量化和说明当模拟路径数量相对于回归中使用的基函数数量较少时，美式看跌期权的 Longstaff–Schwartz 蒙特卡洛 (LSMC) 价格估计中出现的正偏差。您的实现必须基于以下基本原理：在无套利和风险中性定价下，美式期权的价值等于所有停止时间的贴现期望收益的上确界，而带有条件期望的动态规划刻画了最优停止法则。在 LSMC 中，条件期望通过投影到状态函数的有限维基上进行近似，并使用模拟路径通过最小二乘法进行估计。\n\n您必须严格按照以下数学和算法术语进行操作：\n\n- 在风险中性概率测度下，通过几何布朗运动对动态进行建模：对于股价过程 $\\{S_t\\}_{t \\in [0,T]}$，使用随机微分方程 $\\mathrm{d}S_t = r S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t$ 的精确离散化，在具有 $M$ 个时间步的等距网格上模拟路径，其中 $r$ 是连续复利无风险利率，$\\sigma$ 是波动率，$\\{W_t\\}$ 是标准维纳过程。使用精确转移 $S_{t+\\Delta t} = S_t \\exp\\!\\left((r - \\tfrac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z\\right)$，其中 $Z \\sim \\mathcal{N}(0,1)$ 在时间和路径上独立。\n\n- 考虑一个行权价为 $K$ 的美式看跌期权，在任何行权时间 $t \\in [0,T]$ 的收益为 $\\max(K - S_t, 0)$。设时间网格为 $t_m = m \\Delta t$，其中 $\\Delta t = T/M$，且 $m \\in \\{0,1,\\dots,M\\}$。\n\n- 实现 Longstaff–Schwartz 算法，通过对形式为 $\\{\\phi_j(x)\\}_{j=0}^{d}$（其中 $\\phi_j(x) = x^j$）的多项式基进行最小二乘投影来估计继续价值，此处基函数应用于缩放后的状态 $x = S_t / K$，其中 $d$ 是多项式次数。在每个行权时间 $t_m$（不包括 $t_0$），将下一步的贴现已实现现金流对在当前价内状态下评估的基函数进行回归。使用不带正则化的普通最小二乘法。使用相同的模拟路径来估计回归系数并计算由此产生的行权策略和现金流，以获得样本内 LSMC 价格估计。\n\n- 为消除样本内（前视）偏差，请执行样本外评估，方法是将训练样本在每个时间步上拟合的回归系数应用于一组独立的模拟路径（具有相同的模型参数和时间网格），以确定行权决策和已实现的贴现现金流。这些贴现现金流的均值给出了期权价格的一个样本外下界估计。\n\n- 将给定配置的测得偏差定义为样本内估计与样本外下界估计之差。\n\n使用的参数值（所有数字必须与 $S_0$ 和 $K$ 采用相同的货币单位进行解释；不涉及物理单位）：\n- 初始股价 $S_0 = 100$。\n- 行权价 $K = 100$。\n- 无风险利率 $r = 0.06$。\n- 波动率 $\\sigma = 0.2$。\n- 到期日 $T = 1$。\n- 时间步数 $M = 50$（因此 $\\Delta t = T/M$）。\n- 为保证数值稳定性，如上所述，通过 $S_t/K$ 对基函数进行缩放。\n\n随机性与可复现性：\n- 对样本外（评估）模拟使用固定的伪随机种子，等于 $4444$。\n- 对于训练模拟，使用下面测试套件中为每个测试用例提供的种子。\n- 训练和样本外评估使用独立的随机数。\n\n行权时间约定：\n- 允许在时间点 $t_m$（其中 $m \\in \\{1,2,\\dots,M-1\\}$）上做出行权决策，并为在时间 0 进行估值再次贴现至 $t_0$。最后，在 $t_0$ 时，取贴现后的继续价值与即时行权价值 $\\max(K - S_0, 0)$ 的最大值，以确保样本内和样本外估计在 $t_0$ 时的美式行权权利的一致性。\n\n基函数规格：\n- 对于多项式次数 $d$，使用大小为 $d+1$ 的基，其单项式为 $\\{1, x, x^2, \\dots, x^d\\}$，其中 $x = S_t/K$。\n\n测试套件：\n为以下三种配置中的每一种计算测得的偏差（定义为样本内估计减去样本外估计），并使用指定的种子。在每种情况下，使用大小为 $N_{\\text{eval}} = 8000$ 条独立路径的样本外评估集。\n1. 情况 A（小样本，高复杂度）：训练路径 $N_{\\text{train}} = 120$，多项式次数 $d = 6$，训练种子 $111$。\n2. 情况 B（大样本，相同复杂度）：训练路径 $N_{\\text{train}} = 1000$，多项式次数 $d = 6$，训练种子 $222$。\n3. 情况 C（小样本，低复杂度）：训练路径 $N_{\\text{train}} = 120$，多项式次数 $d = 2$，训练种子 $333$。\n\n数值输出：\n- 对每种情况，计算标量偏差并四舍五入到 $4$ 位小数。\n- 您的程序应生成单行输出，包含三个四舍五入后的偏差，形式为用方括号括起来的逗号分隔列表（例如，“[0.1234,0.5678,0.9012]”）。\n\n覆盖设计：\n- 情况 A 探索了由于 $N_{\\text{train}}$ 较小而基函数相对较多可能导致的强正偏差。\n- 情况 B 作为一个“理想路径”，其中偏差应随着 $N_{\\text{train}}$ 的增加而变小。\n- 情况 C 作为一个对比的边缘情况，其中使用相同的小 $N_{\\text{train}}$ 但更少的基函数，以说明过拟合的减少。\n\n您的实现必须是完全自包含的，不需要用户输入，并严格遵守指定的输出格式。", "solution": "我们从风险中性概率测度下的基本无套利原则开始。设 $\\{S_t\\}_{t \\in [0,T]}$ 在风险中性测度下遵循几何布朗运动：\n$$\n\\mathrm{d}S_t = r S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t,\n$$\n其中 $r$ 为连续复利无风险利率，$\\sigma$ 为波动率，$\\{W_t\\}$ 为标准维纳过程。在离散化步长 $\\Delta t$ 上的精确转移为\n$$\nS_{t+\\Delta t} = S_t \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z\\right),\n$$\n其中 $Z \\sim \\mathcal{N}(0,1)$ 在时间和路径上独立。对于一个具有收益过程 $\\{g(S_t)\\}$ 的美式期权（这里对于看跌期权，$g(s) = \\max(K - s, 0)$），在时间 0 的无套利价格等于\n$$\nV_0 = \\sup_{\\tau \\in \\mathcal{T}} \\mathbb{E}^{\\mathbb{Q}}\\left[ e^{-r \\tau} g(S_{\\tau}) \\right],\n$$\n其中 $\\mathcal{T}$ 是取值于 $[0,T]$ 的关于由 $\\{S_t\\}$ 生成的信息流的停止时间集合，$\\mathbb{Q}$ 是风险中性测度。在离散时间网格 $t_m = m \\Delta t$，$m \\in \\{0,1,\\dots,M\\}$ 上，最优停止问题的动态规划递推式为\n$$\nV_m(S_{t_m}) = \\max\\left( g(S_{t_m}), \\, \\mathbb{E}^{\\mathbb{Q}}\\left[ e^{-r \\Delta t} V_{m+1}(S_{t_{m+1}}) \\mid S_{t_m} \\right] \\right),\n$$\n其终值条件为 $V_M(S_{t_M}) = g(S_{t_M})$。\n\nLongstaff–Schwartz 蒙特卡洛 (LSMC) 方法通过在状态（此处为 $S_{t_m}$）的基函数有限维线性张成空间上的 $L^2$-投影来近似条件期望 $\\mathbb{E}^{\\mathbb{Q}}\\left[ e^{-r \\Delta t} V_{m+1}(S_{t_{m+1}}) \\mid S_{t_m} \\right]$。具体来说，在每个时间步 $t_m$（不包括初始时间 $t_0$）估计回归模型\n$$\nY = \\beta_0 \\phi_0(X) + \\beta_1 \\phi_1(X) + \\cdots + \\beta_d \\phi_d(X) + \\varepsilon,\n$$\n其中 $X := S_{t_m}/K$ 是缩放后的状态，$Y := e^{-r \\Delta t} \\hat{V}_{m+1}$ 是在当前策略下，价内（即 $g(S_{t_m}) > 0$）模拟路径上从下一个时间步开始的贴现已实现现金流。基函数是单项式 $\\phi_j(x) = x^j$，其中 $j = 0,1,\\dots,d$。系数 $\\{\\beta_j\\}$ 通过对模拟的训练样本进行普通最小二乘法得到。那么，在时间 $t_m$ 的估计继续价值为\n$$\n\\widehat{C}_m(S_{t_m}) = \\sum_{j=0}^d \\widehat{\\beta}_j \\phi_j(S_{t_m}/K).\n$$\n对于价内状态，如果 $g(S_{t_m}) > \\widehat{C}_m(S_{t_m})$，估计的策略就在 $t_m$ 行权；否则，就继续持有。此反向归纳过程从 $t_{M-1}$ 向下进行到 $t_1$，每一步都将已实现的现金流贴现 $e^{-r \\Delta t}$。最后，在 $t_0$ 的估值会再贴现一次 $e^{-r \\Delta t}$，并与 $g(S_0)$ 取最大值以尊重 $t_0$ 的提前行权权利：\n$$\n\\widehat{V}_0 = \\max\\left(g(S_0), \\, e^{-r \\Delta t} \\cdot \\frac{1}{N} \\sum_{n=1}^N \\widehat{C}_0^{(n)} \\right),\n$$\n其中 $\\widehat{C}_0^{(n)}$ 表示在估计策略下路径上的贴现继续现金流。\n\n当路径数相对于基函数数量较少时的偏差机制：\n- 回归步骤使用来自同一模拟样本的含噪目标 $Y$ 来估计系数 $\\{\\widehat{\\beta}_j\\}$。当样本量 $N$ 相对于基维度 $d+1$ 较小时，回归倾向于对训练集上的 $Y$ 中的噪声进行过拟合，特别是因为回归是基于价内子集进行的，而这个子集在许多时间步上可能非常小。这在样本内减少了训练残差，人为地在对样本内估值有利的地方增加了估计的继续价值，并且关键地，它会影响行权决策，从而选择那些在样本内看起来更有利的路径结果。\n- 因为行权决策是基于比较 $g(S_{t_m})$ 和一个过拟合的 $\\widehat{C}_m(S_{t_m})$，决策边界可能会被扭曲以在样本内减少提前行权，从而增加在同一样本上测得的贴现已实现现金流。这在 LSMC 价格估计中引入了正的前视（或样本内）偏差。\n- 样本外评估将相同的回归系数应用于一组独立的路径。过拟合不会转移到新数据上；因此，该策略通常不会表现出同样的人为高估的继续价值。样本外估计是真实价格的一个有效的下界，并消除了样本内的乐观偏差，因此样本内和样本外估计之间的差异提供了对正偏差的经验度量。\n\n程序的算法设计：\n1. 使用给定的 $S_0, r, \\sigma, T, M$ 和固定的训练种子，通过精确离散化模拟训练路径 $\\{S^{\\text{train}}_{t_m}\\}$ 以保证可复现性。\n2. 训练的反向归纳：\n   - 在到期日 $t_M$ 将每条路径的现金流初始化为 $g(S^{\\text{train}}_{t_M})$。\n   - 对于 $m = M-1, M-2, \\dots, 1$：\n     - 将下一步的现金流贴现 $e^{-r \\Delta t}$。\n     - 识别价内路径，即 $g(S^{\\text{train}}_{t_m}) > 0$ 的路径。\n     - 仅使用价内路径，将贴现现金流对 $\\{\\phi_j(S^{\\text{train}}_{t_m}/K)\\}_{j=0}^d$ 进行回归，以获得 $\\{\\widehat{\\beta}_{m,j}\\}_{j=0}^d$。\n     - 使用这些系数计算所有训练路径的 $\\widehat{C}_m$，并在价内路径上当 $g(S^{\\text{train}}_{t_m}) > \\widehat{C}_m$ 时行权来更新现金流；否则，保留贴现现金流并继续。\n   - 在 $m=1$ 结束后，再次贴现到 $t_0$ 并取 $\\widehat{V}^{\\text{in}}_0 = \\max\\big(g(S_0), \\text{在 } t_0 \\text{ 时的贴现现金流的均值}\\big)$。\n   - 存储所有 $m \\in \\{1,\\dots,M-1\\}$ 的回归系数 $\\{\\widehat{\\beta}_{m,j}\\}$。\n3. 样本外评估：\n   - 使用固定的评估种子，模拟一个包含 $N_{\\text{eval}}$ 条路径的独立评估集 $\\{S^{\\text{eval}}_{t_m}\\}$。\n   - 在 $t_M$ 将评估现金流初始化为 $g(S^{\\text{eval}}_{t_M})$。\n   - 对于 $m = M-1, M-2, \\dots, 1$：\n     - 贴现 $e^{-r \\Delta t}$。\n     - 使用存储的 $\\{\\widehat{\\beta}_{m,j}\\}$ 来计算 $S^{\\text{eval}}_{t_m}$ 处的 $\\widehat{C}_m$。\n     - 在价内路径上当 $g(S^{\\text{eval}}_{t_m}) > \\widehat{C}_m$ 时行权，更新现金流；否则继续。\n   - 在 $m=1$ 结束后，再次贴现到 $t_0$ 并取 $\\widehat{V}^{\\text{out}}_0 = \\max\\big(g(S_0), \\text{在 } t_0 \\text{ 时的贴现现金流的均值}\\big)$。\n4. 测得的偏差为 $B = \\widehat{V}^{\\text{in}}_0 - \\widehat{V}^{\\text{out}}_0$，四舍五入到 4 位小数。\n\n测试集设计缘由：\n- 情况 A：$N_{\\text{train}} = 120$ 且次数 $d=6$ 意味着 $d+1=7$ 个基函数，相对于许多时间步上的价内样本量而言，这个数量是相当大的。我们预计会有一个显著的正偏差。\n- 情况 B：$N_{\\text{train}} = 1000$ 且次数 $d=6$ 相同，增加了样本量，应能减少过拟合；因此，测得的偏差应小于情况 A。\n- 情况 C：$N_{\\text{train}} = 120$ 且次数 $d=2$ 降低了模型相对于情况 A 的复杂度，尽管 $N_{\\text{train}}$ 同样小，但这会减轻过拟合，产生的偏差会小于情况 A。\n\n程序必须生成单行输出，包含一个按情况 A、B、C 顺序排列的三个偏差列表，每个偏差都四舍五入到 4 位小数并用逗号分隔。该输出简洁地量化了 $N_{\\text{train}}$ 与基维度之比对 LSMC 中样本内乐观偏差的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_gbm_paths(S0, r, sigma, T, M, N, rng):\n    dt = T / M\n    # Generate standard normal increments\n    Z = rng.standard_normal(size=(N, M))\n    drift = (r - 0.5 * sigma * sigma) * dt\n    vol = sigma * np.sqrt(dt)\n    # Log increments\n    log_increments = drift + vol * Z\n    # Cumulative sum along time, prepend zeros for t0\n    log_paths = np.concatenate(\n        [np.zeros((N, 1)), np.cumsum(log_increments, axis=1)], axis=1\n    )\n    S_paths = S0 * np.exp(log_paths)\n    return S_paths  # shape (N, M+1)\n\ndef payoff_put(S, K):\n    return np.maximum(K - S, 0.0)\n\ndef basis_matrix(S_scaled, degree):\n    # S_scaled: shape (n,) or (n,1), build [1, x, x^2, ..., x^degree]\n    x = S_scaled.reshape(-1)\n    # Use Vandermonde with increasing powers\n    return np.vander(x, N=degree+1, increasing=True)\n\ndef lsmc_train_and_coeffs(S_paths, K, r, T, M, degree):\n    \"\"\"\n    Train LSMC on given paths:\n    - Returns in-sample price and list of regression coefficients per time step m=1..M-1.\n    \"\"\"\n    N = S_paths.shape[0]\n    dt = T / M\n    disc = np.exp(-r * dt)\n\n    # Initialize cashflows at maturity\n    cf = payoff_put(S_paths[:, M], K).copy()\n\n    # Store coefficients for each time step m (1..M-1). We'll use None if regression is skipped.\n    coeffs = [None] * (M + 1)\n\n    # Backward induction from m = M-1 down to 1\n    for m in range(M-1, 0, -1):\n        # Discount cashflows to time m\n        cf *= disc\n\n        S_m = S_paths[:, m]\n        immediate = payoff_put(S_m, K)\n        itm_mask = immediate > 0.0\n        idx = np.where(itm_mask)[0]\n\n        if idx.size > 0:\n            # Regression on in-the-money paths only\n            X = basis_matrix(S_m[idx] / K, degree)\n            Y = cf[idx]\n            # Ordinary least squares (minimum-norm solution if underdetermined)\n            beta, *_ = np.linalg.lstsq(X, Y, rcond=None)\n            coeffs[m] = beta\n            # Continuation estimates for all paths at time m\n            X_all = basis_matrix(S_m / K, degree)\n            cont = X_all.dot(beta)\n            # Exercise decision for in-the-money paths\n            exercise = itm_mask & (immediate > cont)\n            # Update cashflows: for exercised paths, set to immediate payoff; others keep continuation cf\n            cf[exercise] = immediate[exercise]\n        else:\n            # No in-the-money paths; keep coeffs[m] as None and no exercise updates\n            coeffs[m] = np.zeros(degree+1, dtype=float)  # zero continuation\n\n    # Discount once more to time 0\n    cf0 = cf * disc\n    # Enforce American right at t=0\n    price_in_sample = max(payoff_put(np.array([S_paths[0, 0]]), K)[0], float(np.mean(cf0)))\n    return price_in_sample, coeffs\n\ndef lsmc_evaluate_oos(S_paths_eval, K, r, T, M, degree, coeffs):\n    \"\"\"\n    Apply stored regression coefficients to an independent evaluation set to compute out-of-sample price.\n    \"\"\"\n    N = S_paths_eval.shape[0]\n    dt = T / M\n    disc = np.exp(-r * dt)\n\n    cf = payoff_put(S_paths_eval[:, M], K).copy()\n\n    for m in range(M-1, 0, -1):\n        cf *= disc\n        S_m = S_paths_eval[:, m]\n        immediate = payoff_put(S_m, K)\n        itm_mask = immediate > 0.0\n\n        beta = coeffs[m]\n        if beta is None:\n            # No regression info; continuation is zero -> immediate exercise if in-the-money\n            exercise = itm_mask  # since cont = 0\n            cf[exercise] = immediate[exercise]\n        else:\n            X_all = basis_matrix(S_m / K, degree)\n            cont = X_all.dot(beta)\n            # Exercise decision for in-the-money paths\n            exercise = itm_mask & (immediate > cont)\n            cf[exercise] = immediate[exercise]\n\n    cf0 = cf * disc\n    price_oos = max(payoff_put(np.array([S_paths_eval[0, 0]]), K)[0], float(np.mean(cf0)))\n    return price_oos\n\ndef run_case(S0, K, r, sigma, T, M, degree, N_train, N_eval, seed_train, seed_eval):\n    rng_train = np.random.default_rng(seed_train)\n    rng_eval = np.random.default_rng(seed_eval)\n\n    # Simulate training and evaluation paths\n    S_train = simulate_gbm_paths(S0, r, sigma, T, M, N_train, rng_train)\n    S_eval = simulate_gbm_paths(S0, r, sigma, T, M, N_eval, rng_eval)\n\n    # Train LSMC and get in-sample price and coefficients\n    price_in, coeffs = lsmc_train_and_coeffs(S_train, K, r, T, M, degree)\n    # Evaluate out-of-sample lower bound\n    price_oos = lsmc_evaluate_oos(S_eval, K, r, T, M, degree, coeffs)\n\n    bias = price_in - price_oos\n    return bias\n\ndef solve():\n    # Model and grid parameters\n    S0 = 100.0\n    K = 100.0\n    r = 0.06\n    sigma = 0.2\n    T = 1.0\n    M = 50\n\n    # Evaluation (out-of-sample) set size and seed\n    N_eval = 8000\n    seed_eval = 4444\n\n    # Test cases: (N_train, degree, seed_train)\n    test_cases = [\n        (120, 6, 111),   # Case A: small N_train, high degree\n        (1000, 6, 222),  # Case B: larger N_train, same degree\n        (120, 2, 333),   # Case C: small N_train, low degree\n    ]\n\n    results = []\n    for N_train, degree, seed_train in test_cases:\n        bias = run_case(S0, K, r, sigma, T, M, degree, N_train, N_eval, seed_train, seed_eval)\n        results.append(bias)\n\n    # Round to 4 decimals and print in required format\n    formatted = \"[\" + \",\".join(f\"{x:.4f}\" for x in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "一个成功的 LSMC 实现需要做出多个关键决策，其中最核心的之一是为回归步骤选择合适的基函数。这个选择直接决定了持续价值近似的质量，并最终影响期权价格和行权策略的准确性。本练习旨在探讨与基函数选择相关的模型风险，您将使用同一组模拟路径，但应用两种不同的多项式族（简单单项式与拉盖尔多项式）来观察和量化由此产生的最优行权边界的变化。这项实践将让您对 LSMC 中的模型风险有更深入的理解，为在真实世界的应用中做出更明智、更稳健的建模决策打下基础。[@problem_id:2442309]", "id": "2442309", "problem": "考虑使用 Longstaff–Schwartz 算法（最小二乘蒙特卡罗，Longstaff–Schwartz algorithm）在风险中性测度下为美式看跌期权定价。标的资产价格过程被建模为几何布朗运动，其在风险中性概率测度下的风险中性动态由以下随机微分方程给出：$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t,$$ 其中 $S_t$ 是资产价格，$r$ 是连续复利无风险利率，$q$ 是连续股息率，$\\sigma$ 是波动率，$W_t$ 是标准布朗运动。该美式看跌期权的执行价格为 $K$，到期日为 $T$，在时间 $t$ 的支付由下式给出：$$\\max\\{K - S_t, 0\\}.$$ Longstaff–Schwartz 算法通过将折现后的已实现现金流投影到一组选定的关于当前状态的基函数族上，来近似每个执行时间的条件期望持有价值。基函数族的选择会产生近似误差，这会影响估计的最优停止策略，特别是估计的执行边界。您的任务是通过在相同的模拟路径上运行该算法两次（一次使用简单单项式，一次使用 Laguerre 多项式），然后比较在选定时间点上得出的估计边界，来量化估计的执行边界对基函数族的敏感性。\n\n您必须从风险中性估值和最优停止的首要原则出发，实现以下内容：\n\n1) 使用几何布朗运动的精确解，在均匀时间网格上模拟 $S_t$。对于大小为 $\\Delta t = T/N$ 的 $N$ 个时间步，每条路径的递推公式为：$$S_{t+\\Delta t} = S_t \\exp\\left(\\left(r - q - \\tfrac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\right),$$ 其中，$Z \\sim \\mathcal{N}(0,1)$ 是独立的标准正态分布随机抽取值。\n\n2) 为美式看跌期权实现 Longstaff–Schwartz 算法：\n   a) 在到期日 $t_N = T$ 时，将每条路径的现金流设置为其支付 $C_N = \\max\\{K - S_{t_N}, 0\\}$。\n   b) 从 $i = N-1, N-2, \\dots, 1$ 向后递推。首先，用单步折现因子 $\\exp(-r \\Delta t)$ 对现有现金流进行折现，以获得其在 $t_i$ 时的价值。在 $t_i$ 时处于价内（即满足 $\\max\\{K - S_{t_i}, 0\\} > 0$）的路径中，将折现后的现金流对关于缩放后状态 $x = S_{t_i}/K$ 的一组选定基函数族进行最小二乘回归。使用该回归为价内路径估计持有价值 $\\widehat{C}_{\\text{cont}}(S_{t_i})$。对于那些立即执行价值 $\\max\\{K - S_{t_i}, 0\\}$ 大于或等于估计的持有价值的价内路径，执行期权；否则，继续持有，并保持折现后的现金流不变。\n   c) 在反向归纳法于 $t_1$ 结束后，将剩余的现金流再折现一步至时间 $t_0$，以获得时间为 $0$ 的现值，并计算所有路径的平均值作为期权价格的估计。此价格不是此处的最终目标输出，但为了算法的内部一致性是必需的。\n\n3) 对于步骤 2b 中的回归，在相同的模拟路径上使用两种不同的基函数族：\n   a) 单项式：使用基向量 $$[1, x, x^2, x^3]$$ 其中 $x = S_{t_i}/K$。\n   b) Laguerre 多项式：使用前四个（物理学家版本的）Laguerre 多项式在 $x = S_{t_i}/K$ 处的值，即 $$L_0(x) = 1, \\; L_1(x) = 1 - x, \\; L_2(x) = 1 - 2x + \\tfrac{x^2}{2}, \\; L_3(x) = 1 - 3x + \\tfrac{3}{2}x^2 - \\tfrac{1}{6}x^3.$$ 用这些列构建回归设计矩阵。\n\n4) 在由到期期限的分数 $\\{1/4, 1/2, 3/4\\}$ 指定的三个内部执行时间点，按如下方式为每个基函数族估计执行边界。令 $t_i$ 为最接近 $T$ 的每个分数的时刻所对应的时间索引（四舍五入到 $\\{1, \\dots, N-1\\}$ 中的最近整数索引）。在时间 $t_i$，给定拟合的回归函数 $\\widehat{C}_{\\text{cont}}(S)$，定义函数 $$f(S) = (K - S) - \\widehat{C}_{\\text{cont}}(S).$$ 在区间 $[0, K]$ 上均匀离散化的 $M$ 个点的网格上，找到满足 $f(S) \\ge 0$ 的 $S$ 的上确界。如果存在索引 $j$ 使得 $f(S_j) \\ge 0$ 且 $f(S_{j+1}) < 0$，则在 $S_j$ 和 $S_{j+1}$ 之间进行线性插值以优化根的估计；否则，如果对于所有网格点都有 $f(S) \\ge 0$，则将边界设置为 $K$，如果对于所有网格点都有 $f(S) < 0$，则将边界设置为 $0$。这样就为每个基函数族在每个选定时间点定义了一个估计的执行边界 $\\widehat{S}^*_{\\text{family}}(t_i)$。\n\n5) 敏感性度量：对于每个测试用例，计算在三个选定时间点上，使用 Laguerre 基和单项式基获得的边界之间的最大绝对差：$$D = \\max_{t \\in \\{T/4, T/2, 3T/4\\}} \\left| \\widehat{S}^*_{\\text{Laguerre}}(t) - \\widehat{S}^*_{\\text{Monomials}}(t) \\right|.$$\n\n实现细节与约束：\n- 对每个测试用例，使用指定的 $N$ 个时间步和 $P$ 条独立路径（见下文）。在每个测试用例中，对两种基函数族使用相同的随机数种子和相同的模拟路径，以隔离基函数选择的影响。\n- 使用第 $1$ 项中概述的精确几何布朗运动离散化方法。\n- 通过数值稳定的方法使用最小二乘法。如果在某回归步骤中没有价内路径，则按惯例将该时间的边界估计（如果需要）定义为 $0$。如果至少有一条价内路径，则继续进行回归；如果矩阵是病态的，则使用使残差平方和最小化的最小二乘解。\n- 对于边界网格，在 $[0, K]$ 上使用 $M = 400$ 个均匀间隔点。\n- 所有利率和波动率都以小数形式表示（例如，百分之五表示为 $0.05$），不涉及物理单位。\n\n测试套件：\n提供以下三个测试用例的结果。在所有情况下，使用 $P = 8{,}192$ 条路径，边界网格大小 $M = 400$，以及指定的时间步数 $N$。\n\n1) 用例 A（均衡，中等波动率）：$S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0$, $\\sigma = 0.2$, $T = 1$, $N = 50$, 随机数种子 $= 12345$。\n2) 用例 B（价外起始，高波动率）：$S_0 = 90$, $K = 100$, $r = 0.03$, $q = 0$, $\\sigma = 0.5$, $T = 1$, $N = 50$, 随机数种子 $= 2023$。\n3) 用例 C（价内起始，低波动率，较短到期期限）：$S_0 = 110$, $K = 100$, $r = 0.01$, $q = 0$, $\\sigma = 0.1$, $T = 0.5$, $N = 40$, 随机数种子 $= 42$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试用例 A、B 和 C 的三个敏感性值 $D$，分别四舍五入到 $6$ 位小数，并以逗号分隔的列表形式放在方括号内，例如，$$[0.123456,0.234567,0.345678].$$", "solution": "对所述问题进行验证。\n\n**步骤 1：提取的已知条件**\n-   **资产动态**：在风险中性测度下，资产价格 $S_t$ 服从几何布朗运动：$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t$。其离散化由 $S_{t+\\Delta t} = S_t \\exp\\left(\\left(r - q - \\tfrac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\right)$ 给出，其中 $Z \\sim \\mathcal{N}(0,1)$。\n-   **期权细节**：美式看跌期权，执行价格为 $K$，到期日为 $T$，支付为 $\\max\\{K - S_t, 0\\}$。\n-   **算法**：将使用反向归纳法在大小为 $\\Delta t = T/N$ 的 $N$ 个时间步上实现 Longstaff-Schwartz 算法。\n-   **回归步骤**：通过对期权为“价内”($S_{t_i} < K$)的路径进行最小二乘回归来估计条件期望持有价值。回归的自变量是缩放后状态 $x = S_{t_i}/K$ 的基函数。\n-   **基函数族**：\n    1.  单项式：$[1, x, x^2, x^3]$。\n    2.  Laguerre 多项式：$[L_0(x), L_1(x), L_2(x), L_3(x)]$，其中 $L_0(x) = 1$，$L_1(x) = 1 - x$，$L_2(x) = 1 - 2x + \\tfrac{x^2}{2}$，$L_3(x) = 1 - 3x + \\tfrac{3}{2}x^2 - \\tfrac{1}{6}x^3$。\n-   **边界估计**：执行边界 $\\widehat{S}^*_{\\text{family}}(t_i)$ 将在最接近 $\\{T/4, T/2, 3T/4\\}$ 的时间索引 $t_i$ 处进行估计。这是通过在 $[0, K]$ 区间的 $M=400$ 个点的网格上找到 $f(S) = (K - S) - \\widehat{C}_{\\text{cont}}(S)$ 的根来完成的，并使用线性插值进行优化。\n-   **敏感性度量**：$D = \\max_{t \\in \\{T/4, T/2, 3T/4\\}} \\left| \\widehat{S}^*_{\\text{Laguerre}}(t) - \\widehat{S}^*_{\\text{Monomials}}(t) \\right|$。\n-   **数值参数**：$P = 8192$ 条路径，边界网格大小 $M = 400$。\n-   **测试用例**：\n    -   用例 A：$S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0$, $\\sigma = 0.2$, $T = 1$, $N = 50$, 种子 $= 12345$。\n    -   用例 B：$S_0 = 90$, $K = 100$, $r = 0.03$, $q = 0$, $\\sigma = 0.5$, $T = 1$, $N = 50$, 种子 $= 2023$。\n    -   用例 C：$S_0 = 110$, $K = 100$, $r = 0.01$, $q = 0$, $\\sigma = 0.1$, $T = 0.5$, $N = 40$, 种子 $= 42$。\n-   **输出格式**：一个包含三个测试用例的 $D$ 值的列表，每个值四舍五入到 $6$ 位小数。\n\n**步骤 2：验证**\n对该问题进行有效性评估。\n-   **科学基础**：该问题植根于金融工程的成熟理论，采用了 Black-Scholes-Merton 框架和用于美式期权定价的标准 Longstaff-Schwartz 算法。所有模型、方程和方法都是标准的，并且在事实上是健全的。\n-   **适定性**：该问题规定明确，没有歧义。所有必要的参数、边界条件和程序步骤都已明确提供，确保在给定随机种子的情况下，有一条唯一的路径通向确定的解决方案。\n-   **客观性**：该问题需要进行量化计算和比较，不含主观因素。\n\n**步骤 3：结论**\n该问题是有效的。它是量化金融中一个定义明确的计算任务。我现在将提供解决方案。\n\n该问题要求实现 Longstaff-Schwartz 算法，以分析美式看跌期权执行边界对基函数选择的敏感性。该解决方案从首要原则出发，逻辑地进行。\n\n**1. 资产路径的风险中性模拟**\n衍生品定价的基础是风险中性定价原则。我们在风险中性测度 $\\mathbb{Q}$ 下模拟标的资产价格 $S_t$ 的演变。其动态由随机微分方程描述：\n$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t^{\\mathbb{Q}}$$\n其中 $r$ 是无风险利率，$q$ 是股息率，$\\sigma$ 是波动率，$W_t^{\\mathbb{Q}}$ 是 $\\mathbb{Q}$ 下的标准布朗运动。该方程有精确解，允许在离散时间网格 $t_0, t_1, \\dots, t_N$（其中 $t_i = i \\Delta t$ 且 $\\Delta t = T/N$）上进行精确模拟。对于 $P$ 条路径中的每一条，我们按如下方式生成价格序列：\n$$S_{t_{i+1}} = S_{t_i} \\exp\\left(\\left(r - q - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_{i+1}\\right)$$\n此处，$\\{Z_i\\}_{i=1}^N$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的独立随机变量。为确保受控比较，两种基函数分析使用同一组 $P$ 条模拟路径。\n\n**2. Longstaff-Schwartz 算法：反向归纳与回归**\n美式期权在任何时间 $t$ 的价值是其立即执行价值与持有价值（持有期权的期望价值）中的较大者。这个最优停止问题通过动态规划和反向归纳法来解决。\n\n令 $C_i(S_{t_i})$ 为在给定状态 $S_{t_i}$ 下，期权在时间 $t_i$ 的价值。\n在到期日 $t_N = T$，期权价值就是其内在价值：\n$$C_N(S_{t_N}) = \\max(K - S_{t_N}, 0)$$\n然后我们从 $i = N-1$ 到 $1$ 向后递推。在每个时间 $t_i$，持有价值 $C_{\\text{cont}}(S_{t_i})$ 是在 $t_i$ 信息条件下，下一步期权价值的折现期望值：\n$$C_{\\text{cont}}(S_{t_i}) = \\mathbb{E}^{\\mathbb{Q}}\\left[e^{-r\\Delta t} C_{i+1}(S_{t_{i+1}}) \\mid S_{t_i}\\right]$$\nLongstaff-Schwartz 算法的核心创新是使用线性回归来近似这个条件期望。回归仅对“价内”($S_{t_i} < K$)的路径执行，因为对于价外路径，决策总是继续持有。对于这些价内路径，我们将折现后的未来现金流 $\\{e^{-r\\Delta t} C_{i+1}^{(j)}\\}$（其中 $j$ 是路径索引）对一组关于缩放后状态变量 $x = S_{t_i}/K$ 的基函数 $\\{f_k(S_{t_i}^{(j)}/K)\\}_{k=0}^d$ 进行回归。这产生一个估计的持有价值函数：\n$$\\widehat{C}_{\\text{cont}}(S_{t_i}) = \\sum_{k=0}^{d} \\beta_{i,k} f_k(S_{t_i}/K)$$\n系数 $\\boldsymbol{\\beta}_i = \\{\\beta_{i,k}\\}$ 通过最小化误差平方和来找到。我们按规定使用两种不同的基函数族：\n-   **单项式**：基为 $[1, x, x^2, x^3]$。\n-   **Laguerre 多项式**：基为 $[L_0(x), L_1(x), L_2(x), L_3(x)]$。\n一旦 $\\widehat{C}_{\\text{cont}}(S_{t_i})$ 被估计出来，就对每个价内路径应用最优停止法则：\n$$\n\\text{如果 } \\max(K - S_{t_i}, 0) \\geq \\widehat{C}_{\\text{cont}}(S_{t_i}), \\text{ 则执行；否则，继续持有。}\n$$\n如果执行是最优的，该路径在时间 $t_i$ 的现金流被设置为 $K - S_{t_i}$，并且该值在后续步骤中（折现后）向后传递。如果继续持有是最优的，则 $t_i$ 时的现金流是来自 $t_{i+1}$ 的折现现金流。这个过程定义了所有路径的现金流向量 $\\{C_i^{(j)}\\}$。\n\n**3. 执行边界的估计**\n执行边界 $S^*(t)$ 是期权持有人在立即执行和继续持有之间无差异的临界股票价格。这个无差异点由执行价值与持有价值相等来定义：\n$$K - S^*(t) = C_{\\text{cont}}(S^*(t), t)$$\n我们通过找到函数 $f(S) = (K - S) - \\widehat{C}_{\\text{cont}}(S)$ 的根来估计在指定时间 $t_i$ 的边界 $\\widehat{S}^*(t_i)$，其中 $\\widehat{C}_{\\text{cont}}(S)$ 是使用在步骤 $t_i$ 计算的回归系数 $\\boldsymbol{\\beta}_i$ 构建的。我们通过在区间 $[0, K]$ 上一个包含 $M=400$ 个点的精细网格上评估 $f(S)$ 来数值定位根。当在两个相邻网格点 $S_j$ 和 $S_{j+1}$ 之间检测到 $f(S)$ 的符号变化时，使用线性插值以高精度近似根。如果 $f(S) \\geq 0$ 遍及整个网格，边界设置为 $K$。如果 $f(S) < 0$ 处处成立，则设置为 $0$。\n\n**4. 敏感性分析**\n对每个测试用例，整个过程执行两次——一次使用单项式基函数，一次使用 Laguerre 基函数，都在相同的模拟资产路径集上进行。这隔离了基函数选择对估计执行边界的影响。对于每个指定的时间点 $t_i \\in \\{T/4, T/2, 3T/4\\}$，我们计算两个边界估计值 $\\widehat{S}^*_{\\text{Monomials}}(t_i)$ 和 $\\widehat{S}^*_{\\text{Laguerre}}(t_i)$。最终的敏感性度量 $D$ 是这三个时间点上这些估计值之间最大绝对差：\n$$D = \\max_{i \\in \\text{indices for } \\{T/4, T/2, 3T/4\\}} \\left| \\widehat{S}^*_{\\text{Laguerre}}(t_i) - \\widehat{S}^*_{\\text{Monomials}}(t_i) \\right|$$\n该度量量化了与 Longstaff-Schwartz 算法中基函数选择相关的模型风险。以下代码实现了这一完整方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_basis_functions(x, basis_type):\n    \"\"\"\n    Generates the design matrix for given states and basis type.\n\n    Args:\n        x (np.ndarray): Scaled asset prices (S/K).\n        basis_type (str): 'monomials' or 'laguerre'.\n\n    Returns:\n        np.ndarray: The design matrix (number of paths x number of basis functions).\n    \"\"\"\n    if basis_type == 'monomials':\n        return np.vstack([np.ones_like(x), x, x**2, x**3]).T\n    elif basis_type == 'laguerre':\n        L0 = np.ones_like(x)\n        L1 = 1.0 - x\n        L2 = 1.0 - 2.0 * x + 0.5 * x**2\n        L3 = 1.0 - 3.0 * x + 1.5 * x**2 - (1.0 / 6.0) * x**3\n        return np.vstack([L0, L1, L2, L3]).T\n    else:\n        raise ValueError(\"Unknown basis type specified.\")\n\ndef run_lsm_and_get_boundaries(S_paths, K, r, dt, N, M, basis_type, boundary_times_indices):\n    \"\"\"\n    Runs the Longstaff-Schwartz algorithm and computes exercise boundaries at specified times.\n\n    Args:\n        S_paths (np.ndarray): Simulated asset price paths.\n        K (float): Strike price.\n        r (float): Risk-free rate.\n        dt (float): Time step size.\n        N (int): Number of time steps.\n        M (int): Number of points in the boundary estimation grid.\n        basis_type (str): 'monomials' or 'laguerre'.\n        boundary_times_indices (set): Set of time indices to estimate the boundary.\n\n    Returns:\n        dict: A dictionary mapping time index to the estimated boundary value.\n    \"\"\"\n    P = S_paths.shape[0]\n    cash_flows = np.maximum(K - S_paths[:, -1], 0)\n    boundary_estimates = {}\n\n    for i in range(N - 1, 0, -1):\n        cash_flows *= np.exp(-r * dt)\n        S_t = S_paths[:, i]\n        itm_indices = np.where(S_t < K)[0]\n\n        if len(itm_indices) > 0:\n            X = get_basis_functions(S_t[itm_indices] / K, basis_type)\n            y = cash_flows[itm_indices]\n\n            try:\n                beta = np.linalg.lstsq(X, y, rcond=None)[0]\n            except np.linalg.LinAlgError:\n                # In case of a fatal error, which is unlikely with lstsq, \n                # we assume continuation value is 0 (or some other robust handling).\n                # This would mean exercising whenever in the money.\n                beta = np.zeros(X.shape[1])\n\n            if i in boundary_times_indices:\n                S_grid = np.linspace(1e-6, K, M)\n                x_grid = S_grid / K\n                basis_grid = get_basis_functions(x_grid, basis_type)\n                cont_val_grid = basis_grid @ beta\n                f_S = (K - S_grid) - cont_val_grid\n\n                positive_f = np.where(f_S >= 0)[0]\n                if len(positive_f) == 0:\n                    boundary = 0.0\n                elif len(positive_f) == M:\n                    boundary = K\n                else:\n                    root_idx = positive_f[-1]\n                    if root_idx + 1 < M:\n                        f1, f2 = f_S[root_idx], f_S[root_idx + 1]\n                        s1, s2 = S_grid[root_idx], S_grid[root_idx + 1]\n                        boundary = s1 - f1 * (s2 - s1) / (f2 - f1)\n                    else:\n                        boundary = K\n                boundary_estimates[i] = boundary\n\n            continuation_value = get_basis_functions(S_t[itm_indices] / K, basis_type) @ beta\n            exercise_value = K - S_t[itm_indices]\n            exercise_indices = itm_indices[exercise_value >= continuation_value]\n            cash_flows[exercise_indices] = K - S_t[exercise_indices]\n        \n        else:\n            if i in boundary_times_indices:\n                boundary_estimates[i] = 0.0\n\n    return boundary_estimates\n\ndef calculate_sensitivity(S0, K, r, q, sigma, T, N, P, M, seed):\n    \"\"\"\n    Calculates the sensitivity metric D for a single test case.\n\n    Args:\n        S0, K, r, q, sigma, T, N, P, M, seed: All problem parameters.\n\n    Returns:\n        float: The sensitivity metric D.\n    \"\"\"\n    np.random.seed(seed)\n    dt = T / N\n    S_paths = np.zeros((P, N + 1))\n    S_paths[:, 0] = S0\n    drift = (r - q - 0.5 * sigma**2) * dt\n    diffusion = sigma * np.sqrt(dt)\n\n    for i in range(1, N + 1):\n        Z = np.random.standard_normal(P)\n        S_paths[:, i] = S_paths[:, i-1] * np.exp(drift + diffusion * Z)\n\n    time_fractions = [0.25, 0.5, 0.75]\n    boundary_times_indices = {int(round(f * N)) for f in time_fractions}\n    boundary_times_indices = {max(1, min(N-1, idx)) for idx in boundary_times_indices}\n\n    boundaries_mono = run_lsm_and_get_boundaries(S_paths, K, r, dt, N, M, 'monomials', boundary_times_indices)\n    boundaries_laguerre = run_lsm_and_get_boundaries(S_paths, K, r, dt, N, M, 'laguerre', boundary_times_indices)\n    \n    differences = []\n    for idx in sorted(list(boundary_times_indices)):\n        b_mono = boundaries_mono.get(idx, 0.0)\n        b_lag = boundaries_laguerre.get(idx, 0.0)\n        differences.append(np.abs(b_lag - b_mono))\n        \n    return np.max(differences) if differences else 0.0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'S0': 100., 'K': 100., 'r': 0.05, 'q': 0., 'sigma': 0.2, 'T': 1.0, 'N': 50, 'seed': 12345},\n        {'S0': 90., 'K': 100., 'r': 0.03, 'q': 0., 'sigma': 0.5, 'T': 1.0, 'N': 50, 'seed': 2023},\n        {'S0': 110., 'K': 100., 'r': 0.01, 'q': 0., 'sigma': 0.1, 'T': 0.5, 'N': 40, 'seed': 42}\n    ]\n    common_params = {'P': 8192, 'M': 400}\n    \n    results = []\n    for case_params in test_cases:\n        params = {**case_params, **common_params}\n        D = calculate_sensitivity(**params)\n        results.append(D)\n        \n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"}]}