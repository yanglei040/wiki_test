{"hands_on_practices": [{"introduction": "本练习将指导您从零开始构建一个蒙特卡洛信用估值调整（CVA）计算引擎。通过模拟资产价格路径来估计未来的预期正风险敞口（$EPE(t)$），并将其与交易对手的违约概率相结合，您可以亲手实现CVA的核心定价逻辑。这项实践不仅能巩固您对随机过程和数值积分的理解，还将通过对比标量与向量化计算的性能，揭示高效计算在量化金融中的重要性 [@problem_id:2386203]。", "id": "2386203", "problem": "你的任务是为信用估值调整 (CVA) 构建一个小型、自包含的蒙特卡洛框架计算引擎，并比较两种计算后端：一种是使用显式循环的标量中央处理器 (CPU) 实现，另一种是使用数组编程来模拟图形处理器 (GPU) 批量并行执行的单指令多数据 (SIMD) 风格向量化后端。在无法进行实际图形处理器 (GPU) 执行的情况下，向量化是单指令多数据 (SIMD) 并行性的标准且可靠的代理，它能够实现本可卸载到 GPU 内核的相同算法结构。\n\n请从以下基本基础出发：\n- 在风险中性测度下，单一风险资产的即期价格过程由几何布朗运动 (GBM) 建模：$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t,$$ 其中 $S_t$ 是即期价格，$r$ 是连续复利无风险利率，$q$ 是连续股息率，$\\sigma$ 是波动率，$W_t$ 是标准布朗运动。\n- 在时间 $t$，一份到期日为 $T$、执行价为 $K$、连续股息率为 $q$ 的多头远期合约的价值为 $$V_t = S_t e^{-q (T - t)} - K e^{-r (T - t)}.$$\n- 在时间 $t$ 的未抵押风险敞口为 $$E_t = \\max(V_t, 0).$$\n- 在恒定风险率（违约强度）$\\lambda$ 和回收率 $R$ 的情况下，违约损失率为 $$\\text{LGD} = 1 - R,$$ 生存概率为 $$\\mathbb{S}(t) = e^{-\\lambda t}.$$ 风险中性违约密度为 $$f(t) = \\lambda e^{-\\lambda t}.$$\n- 独立性假设下的连续时间 CVA 为 $$\\text{CVA} = \\text{LGD} \\int_0^T D(0,t) \\, \\mathbb{E}[E_t] \\, f(t) \\, dt,$$ 其中 $$D(0,t) = e^{-r t}$$ 是折现因子，$$\\mathbb{E}[E_t]$$ 是预期风险敞口。\n\n任务：\n1) 使用均匀时间网格 $t_i = i \\Delta t$（其中 $i = 1, 2, \\dots, M$ 且 $\\Delta t = T/M$）和预期风险敞口的蒙特卡洛估计量，为 CVA 推导一个一致的离散时间估计量。你的推导必须从上述基本基础开始，不得依赖任何简化公式。\n2) 为该估计量实现两个后端：\n   - 一个使用对路径和时间进行显式嵌套循环的标量 CPU 后端。\n   - 一个通过对整个模拟状态数组同时应用相同操作来模拟 GPU 风格并行计算（即单指令多数据）的向量化后端。\n3) 两个后端使用相同的随机数，以确保任何差异都源于计算策略，而不是不同的随机抽样。\n4) 通过测量墙上时钟时间来对两个后端进行基准测试。你必须在内部计算时间，但你的程序的最终输出必须只包含下文要求的 CVA 值。\n5) 对每个测试用例，以与 $S_0$ 和 $K$ 相同的货币单位计算 CVA，并以浮点数形式返回。\n\n离散化和估计量设计约束：\n- 使用对数形式的 GBM 的 Euler–Maruyama 精确步长：$$S_{t+\\Delta t} = S_t \\exp\\!\\Big(\\big((r - q) - \\tfrac{1}{2}\\sigma^2\\big) \\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\Big),$$ 其中 $Z \\sim \\mathcal{N}(0,1)$ 在时间步和路径上相互独立。\n- 使用在右端点求值的黎曼和来近似积分：$$\\text{CVA} \\approx (1-R) \\sum_{i=1}^{M} e^{-r t_i} \\, \\widehat{\\mathbb{E}}[E_{t_i}] \\, \\lambda e^{-\\lambda t_i} \\, \\Delta t,$$ 其中 $\\widehat{\\mathbb{E}}[E_{t_i}]$ 是 $E_{t_i}$ 在所有模拟路径上的蒙特卡洛均值。\n- 所有概率和利率必须以小数形式表示（而非百分比）。\n\n测试套件：\n实现您的程序，为以下参数集计算 CVA。每个测试用例是一个元组 $(S_0, K, T, r, q, \\sigma, \\lambda, R, N, M, \\text{seed})$：\n- 用例 A (正常路径): $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 0.4, 20000, 50, 20240501)$\n- 用例 B (零风险率边界): $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.0, 0.4, 20000, 50, 20240501)$\n- 用例 C (完全回收边界): $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 1.0, 20000, 50, 20240501)$\n- 用例 D (确定性风险敞口检查): $(\\$100.0, \\$90.0, 1.0, 0.01, 0.0, 0.0, 0.05, 0.4, 5000, 50, 7)$\n\n实现要求：\n- 两个后端对每个测试用例使用相同的标准正态抽样矩阵，以便数值上的差异（如有）仅能归因于计算策略。\n- 内部测量并记录用例 A 的每个后端的运行时间。不应打印任何时间结果，但必须进行计算。\n- 对每个测试用例，仅输出由向量化后端计算的 CVA，四舍五入到六位小数。如果某个用例在数学上意味着 CVA 为零（例如，零风险率或零违约损失率），则该用例的输出在四舍五入后必须恰好为 $0.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的 CVA 结果，格式为方括号内以逗号分隔的列表，例如，$$[\\text{cva}_A,\\text{cva}_B,\\text{cva}_C,\\text{cva}_D],$$ 其中每个条目都是一个四舍五入到六位小数的浮点数。\n\n注释：\n- 没有物理单位；所有货币输出的单位与 $S_0$ 和 $K$ 相同。\n- 角度不适用。\n- 所有利率（$r$, $q$, $\\sigma$, $\\lambda$）和回收率 $R$ 必须以小数形式传递，而非百分比。", "solution": "所给问题是计算金融中一个定义明确的任务，要求推导和实现信用估值调整 (CVA) 的蒙特卡洛估计量。在进行求解之前，需要进行形式化验证。\n\n**问题验证**\n\n**第 1 步：提取给定信息**\n\n问题提供了以下明确信息：\n\n- **资产价格过程**：风险中性测度下的几何布朗运动 (GBM)：$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t$$ 其中 $S_t$ 是即期价格，$r$ 是无风险利率，$q$ 是股息率，$\\sigma$ 是波动率，$W_t$ 是标准布朗运动。\n- **合约估值**：多头远期合约的价值为 $$V_t = S_t e^{-q (T - t)} - K e^{-r (T - t)}$$ 其中 $T$ 是到期日，$K$ 是执行价。\n- **风险敞口定义**：未抵押风险敞口为 $$E_t = \\max(V_t, 0).$$\n- **违约模型**：恒定风险率 $\\lambda$，回收率 $R$，违约损失率 $\\text{LGD} = 1 - R$，生存概率 $\\mathbb{S}(t) = e^{-\\lambda t}$，以及风险中性违约密度 $f(t) = \\lambda e^{-\\lambda t}$。\n- **CVA 公式**：独立性假设下的连续时间 CVA 为 $$\\text{CVA} = \\text{LGD} \\int_0^T D(0,t) \\, \\mathbb{E}[E_t] \\, f(t) \\, dt,$$ 其中 $D(0,t) = e^{-r t}$ 是折现因子。\n- **离散化方案**：\n    - 时间网格：$t_i = i \\Delta t$，其中 $i = 1, 2, \\dots, M$ 且 $\\Delta t = T/M$。\n    - GBM 模拟步长：$$S_{t+\\Delta t} = S_t \\exp\\!\\Big(\\big((r - q) - \\tfrac{1}{2}\\sigma^2\\big) \\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\Big),$$ 其中 $Z \\sim \\mathcal{N}(0,1)$。\n    - CVA 估计量：$$\\text{CVA} \\approx (1-R) \\sum_{i=1}^{M} e^{-r t_i} \\, \\widehat{\\mathbb{E}}[E_{t_i}] \\, \\lambda e^{-\\lambda t_i} \\, \\Delta t,$$ 其中 $\\widehat{\\mathbb{E}}[E_{t_i}]$ 是 $E_{t_i}$ 的蒙特卡洛均值。\n- **测试套件**：四个参数集，每个都是一个元组 $(S_0, K, T, r, q, \\sigma, \\lambda, R, N, M, \\text{seed})$。\n    - A: $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 0.4, 20000, 50, 20240501)$\n    - B: $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.0, 0.4, 20000, 50, 20240501)$\n    - C: $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 1.0, 20000, 50, 20240501)$\n    - D: $(\\$100.0, \\$90.0, 1.0, 0.01, 0.0, 0.0, 0.05, 0.4, 5000, 50, 7)$\n\n**第 2 步：使用提取的给定信息进行验证**\n\n根据验证标准对问题进行评估。\n- **科学依据**：问题基于量化金融的标准基石模型（GBM、Merton 风格的违约模型）。所提供的公式正确且被广泛使用。该问题具有科学合理性。\n- **适定性**：问题结构清晰，包含所有必要的输入、一个指定的数值方法（具有定义的路径离散器和积分近似的蒙特卡洛方法）以及一个明确的目标。对于给定的随机种子，该过程会产生唯一的数值解。该问题是适定的。\n- **客观性**：所有定义都是数学的，所有输入都是数值的。语言精确且无主观性。该问题是客观的。\n- **其他缺陷**：问题陈述是自包含、一致且可行的。没有矛盾、歧义或依赖伪科学。该任务是计算经济学和金融学中的一个标准练习。\n\n**第 3 步：结论与行动**\n\n问题是 **有效的**。将构建一个解决方案。\n\n**解决方案：设计与实现**\n\n任务是为 CVA 推导一个离散估计量，并使用两种不同的计算范式（标量和向量化）来实现它。\n\n**1. 离散化和估计量推导**\n\n推导从给定的连续时间 CVA 公式开始：\n$$ \\text{CVA} = \\text{LGD} \\int_0^T D(0,t) \\, \\mathbb{E}[E_t] \\, f(t) \\, dt $$\n代入给定的 LGD、折现因子 $D(0,t)$ 和违约密度 $f(t)$ 的定义：\n$$ \\text{CVA} = (1-R) \\int_0^T e^{-rt} \\, \\mathbb{E}[E_t] \\, \\lambda e^{-\\lambda t} \\, dt $$\n问题要求使用在均匀时间网格上的右黎曼和来近似这个积分。区间 $[0, T]$ 被划分为 $M$ 个宽度为 $\\Delta t = T/M$ 的子区间 $[t_{i-1}, t_i]$，其中 $t_i = i \\Delta t$，$i = 1, \\dots, M$。积分通过在右端点 $t_i$ 对被积函数的值求和来近似：\n$$ \\int_0^T g(t) \\, dt \\approx \\sum_{i=1}^M g(t_i) \\Delta t $$\n将此应用于 CVA 积分，得到离散估计量：\n$$ \\text{CVA} \\approx (1-R) \\sum_{i=1}^{M} \\left( e^{-r t_i} \\, \\mathbb{E}[E_{t_i}] \\, \\lambda e^{-\\lambda t_i} \\right) \\Delta t $$\n这与问题陈述中指定的公式相符。下一步是使用具有 $N$ 条路径的蒙特卡洛模拟来估计未来预期风险敞口 $\\mathbb{E}[E_{t_i}]$。期望值被其样本均值估计量 $\\widehat{\\mathbb{E}}[E_{t_i}]$ 替代：\n$$ \\widehat{\\mathbb{E}}[E_{t_i}] = \\frac{1}{N} \\sum_{j=1}^{N} E_{t_i}^{(j)} $$\n其中 $E_{t_i}^{(j)}$ 是第 $j$ 条模拟路径在时间 $t_i$ 的风险敞口。风险敞口是模拟资产价格 $S_{t_i}^{(j)}$ 的函数：\n$$ E_{t_i}^{(j)} = \\max\\left( V_{t_i}^{(j)}, 0 \\right) = \\max\\left( S_{t_i}^{(j)} e^{-q (T - t_i)} - K e^{-r (T - t_i)}, 0 \\right) $$\n每条路径 $S^{(j)}$ 都是从 $S_{t_0}^{(j)}=S_0$ 开始，使用对数价格 SDE 的精确解逐步生成的：\n$$ S_{t_i}^{(j)} = S_{t_{i-1}}^{(j)} \\exp\\left( \\left( (r - q) - \\frac{1}{2}\\sigma^2 \\right) \\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z_{i,j} \\right) $$\n其中 $Z_{i,j}$ 是独立的标准正态随机变量。\n\n将这些部分组合起来，得到 CVA 估计量的完整计算公式。\n\n**2. 算法设计**\n\n基于推导出的估计量设计了两种计算后端。为了公平比较，两者都必须使用相同的基础标准正态抽样矩阵 $Z \\in \\mathbb{R}^{N \\times M}$。\n\n**标量 (CPU) 后端：**\n这种方法使用显式的嵌套循环，这是传统 CPU 编程的典型特征。\n\n1.  初始化一个大小为 $M$、元素全为零的数组 `expected_exposures`。\n2.  外层循环遍历每条路径 $j$，从 $1$ 到 $N$。\n3.  在外层循环内部，初始化路径的起始价格 `current_S = S_0`。\n4.  内层循环遍历每个时间步 $i$，从 $1$ 到 $M$。\n5.  在内层循环内部：\n    a. 检索随机正态抽样 $Z_{i,j}$。\n    b. 使用 GBM 步长公式从 `current_S` 计算下一个资产价格 $S_{t_i}$。\n    c. 计算该时间步的风险敞口 $E_{t_i}$。\n    d. 将此敞口加到该时间步的运行总和中：`expected_exposures[i-1] += E_{t_i}`。\n    e. 更新 `current_S = S_{t_i}`。\n6.  外层循环完成后，将 `expected_exposures` 的每个元素除以 $N$ 以完成平均。\n7.  使用现已计算出的 `expected_exposures` 数组，对离散积分近似的各项求和，以计算最终的 CVA 值。\n\n**向量化 (SIMD/GPU 风格) 后端：**\n这种方法利用数组编程一次性对整个向量或矩阵执行操作，模拟了像 GPU 这样的并行处理器的单指令多数据 (SIMD) 范式。\n\n1.  生成整个 $N \\times M$ 的标准正态抽样矩阵 $Z$。\n2.  初始化一个大小为 $N$ 的向量 `S_current`，所有元素设置为 $S_0$。\n3.  初始化一个大小为 $M$、元素全为零的结果向量 `cva_sum_terms`。\n4.  循环遍历每个时间步 $i$，从 $1$ 到 $M$。\n5.  在循环内部：\n    a. 获取当前步长的随机抽样列向量 $Z_{:, i-1}$。\n    b. 在单次操作中更新 $N$ 个资产价格的整个 `S_current` 向量。\n    c. 同时计算 $N$ 个远期合约价值的向量 $V_{t_i}$。\n    d. 计算所有路径的 $N$ 个风险敞口向量 $E_{t_i} = \\max(V_{t_i}, 0)$。\n    e. 计算此敞口向量的平均值以获得 $\\widehat{\\mathbb{E}}[E_{t_i}]$。\n    f. 计算 CVA 被积函数的第 $i$ 项并将其存储在 `cva_sum_terms[i-1]` 中。\n6.  循环结束后，通过对 `cva_sum_terms` 向量求和并乘以常数 $\\lambda$、$(1-R)$ 和 $\\Delta t$ 来计算最终的 CVA。\n\n这种向量化方法避免了对模拟路径的显式循环，代之以由 NumPy 等库提供的高度优化的低级数组操作。这通常会带来显著的性能提升。\n\n**3. 实现策略**\n\n解决方案将使用 Python 语言和 NumPy 库（特别用于向量化后端）来实现。对于每个测试用例，将为随机数生成器设定种子以确保可复现性。为某个用例生成的相同随机数矩阵将传递给标量和向量化函数，以确保输出的任何差异仅由浮点算术顺序引起，而性能差异则源于算法。用例 A 的两个后端的运行时间将通过 `time.perf_counter()` 进行测量，以满足基准测试要求，尽管这些时间不会成为最终打印输出的一部分。来自向量化后端的最终 CVA 值将按要求四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport time\n\ndef cva_scalar_cpu(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z):\n    \"\"\"\n    Computes CVA using a scalar (loopy) implementation.\n    \"\"\"\n    dt = T / M\n    \n    if lambda_c == 0.0 or R == 1.0:\n        return 0.0\n\n    # Calculate Expected Exposures\n    expected_exposures = [0.0] * M\n    for j in range(N):  # Loop over paths\n        S_curr = S0\n        for i in range(M):  # Loop over time steps\n            drift = (r - q - 0.5 * sigma**2) * dt\n            diffusion = sigma * np.sqrt(dt) * Z[j, i]\n            S_curr *= np.exp(drift + diffusion)\n            \n            t = (i + 1) * dt\n            forward_val = S_curr * np.exp(-q * (T - t)) - K * np.exp(-r * (T - t))\n            exposure = max(forward_val, 0.0)\n            \n            expected_exposures[i] += exposure\n\n    for i in range(M):\n        expected_exposures[i] /= N\n\n    # Calculate CVA\n    cva_sum = 0.0\n    for i in range(M):\n        t = (i + 1) * dt\n        discount = np.exp(-r * t)\n        default_prob_density = lambda_c * np.exp(-lambda_c * t)\n        cva_sum += discount * expected_exposures[i] * default_prob_density\n\n    cva = (1 - R) * cva_sum * dt\n    return cva\n\ndef cva_vectorized_simd(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z):\n    \"\"\"\n    Computes CVA using a vectorized (SIMD-style) implementation.\n    \"\"\"\n    dt = T / M\n    \n    if lambda_c == 0.0 or R == 1.0:\n        return 0.0\n\n    # Time grid\n    t = np.linspace(dt, T, M)\n    \n    # Generate asset price paths\n    S = np.zeros((N, M + 1))\n    S[:, 0] = S0\n    \n    drift = (r - q - 0.5 * sigma**2) * dt\n    diffusion = sigma * np.sqrt(dt)\n    \n    for i in range(M):\n        S[:, i + 1] = S[:, i] * np.exp(drift + diffusion * Z[:, i])\n    \n    S_paths = S[:, 1:] # Paths at t_1, ..., t_M\n    \n    # Calculate Exposures\n    forward_vals = S_paths * np.exp(-q * (T - t)) - K * np.exp(-r * (T - t))\n    exposures = np.maximum(forward_vals, 0)\n    \n    # Calculate Expected Exposures\n    expected_exposures = np.mean(exposures, axis=0)\n    \n    # Calculate CVA\n    discount = np.exp(-r * t)\n    default_prob_density = lambda_c * np.exp(-lambda_c * t)\n    integrand = (1 - R) * discount * expected_exposures * default_prob_density\n    \n    cva = np.sum(integrand) * dt\n    return cva\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and produce the final output.\n    \"\"\"\n    # (S0, K, T, r, q, sigma, lambda_c, R, N, M, seed)\n    test_cases = [\n        (100.0, 100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 0.4, 20000, 50, 20240501), # Case A\n        (100.0, 100.0, 1.0, 0.02, 0.0, 0.2, 0.0, 0.4, 20000, 50, 20240501),  # Case B\n        (100.0, 100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 1.0, 20000, 50, 20240501),  # Case C\n        (100.0, 90.0, 1.0, 0.01, 0.0, 0.0, 0.05, 0.4, 5000, 50, 7),         # Case D\n    ]\n\n    results = []\n\n    # Process Case A separately to perform the required benchmark timing.\n    S0, K, T, r, q, sigma, lambda_c, R, N, M, seed = test_cases[0]\n    rng = np.random.default_rng(seed)\n    Z = rng.standard_normal(size=(N, M))\n    \n    # Time scalar implementation for Case A (computation must occur, but result is not printed)\n    start_time_scalar = time.perf_counter()\n    _ = cva_scalar_cpu(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z)\n    end_time_scalar = time.perf_counter()\n    # scalar_time = end_time_scalar - start_time_scalar # For internal verification\n\n    # Time vectorized implementation for Case A and collect result\n    start_time_vec = time.perf_counter()\n    cva_A = cva_vectorized_simd(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z)\n    end_time_vec = time.perf_counter()\n    # vec_time = end_time_vec - start_time_vec # For internal verification\n    \n    results.append(round(cva_A, 6))\n\n    # Process remaining cases (B, C, D) using only the vectorized backend for output\n    for case in test_cases[1:]:\n        S0, K, T, r, q, sigma, lambda_c, R, N, M, seed = case\n        rng = np.random.default_rng(seed)\n        Z = rng.standard_normal(size=(N, M))\n        cva = cva_vectorized_simd(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z)\n        results.append(round(cva, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "在真实的交易环境中，金融机构需要实时评估新交易对投资组合风险的影响。本练习模拟了这一核心任务，要求您计算增加一笔新交易后产生的增量信用估值调整（$\\Delta CVA$）。您将通过此实践深入理解净额结算（netting）效应，以及由于风险敞口计算的非线性（$\\max(E, 0)$），新交易可能如何对冲或增加现有风险 [@problem_id:2386214]。", "id": "2386214", "problem": "考虑信用估值调整（CVA）的单一对手方情景。设时间由离散网格 $\\{t_1,\\dots,t_N\\}$ 表示，其中 $t_0=0$。设无风险连续复利率恒定为 $r$，对手方违约强度（风险率）恒定为 $\\lambda$，部分回收率为 $R$。定义生存函数为 $S(t)=\\exp(-\\lambda t)$，折现因子为 $D(t)=\\exp(-r t)$。设区间 $(t_{k-1},t_k]$ 上的增量违约概率为 $\\Delta \\mathrm{PD}_k=S(t_{k-1})-S(t_k)$，其中 $S(t_0)=1$。对于一个确定性的净额结算风险敞口路径，设现有投资组合在 $t_k$ 时刻的（取正前）风险敞口为 $E^{\\mathrm{old}}_k$，新增交易在 $t_k$ 时刻的（取正前）风险敞口为 $E^{\\mathrm{new}}_k$。$t_k$ 时刻的轧差后正风险敞口是对取正前的净风险敞口应用 $\\max(x,0)$ 函数。使用离散时间近似法，单边CVA为\n$$\n\\mathrm{CVA} = (1-R)\\sum_{k=1}^{N} D(t_k)\\,\\Big(\\max\\big(E_k,0\\big)\\Big)\\,\\Delta \\mathrm{PD}_k,\n$$\n其中 $E_k$ 表示在 $t_k$ 时刻的相关净风险敞口。因增加新交易而产生的增量CVA为\n$$\n\\Delta \\mathrm{CVA} = \\mathrm{CVA}\\big(\\max(E^{\\mathrm{old}}+E^{\\mathrm{new}},0)\\big) - \\mathrm{CVA}\\big(\\max(E^{\\mathrm{old}},0)\\big).\n$$\n所有利率 $r$ 和 $\\lambda$ 均为以小数表示的年化率，时间 $t_k$ 以年为单位，风险敞口 $E^{\\mathrm{old}}_k$ 和 $E^{\\mathrm{new}}_k$ 以任意货币单位表示，最终答案必须以相同货币单位的小数形式报告。\n\n任务：对以下每个测试用例，计算如上定义的 $\\Delta \\mathrm{CVA}$。请精确使用给定参数，并将所有数组视为按 $t_1,\\dots,t_N$ 排序。\n\n测试套件：\n- 测试用例 $1$（包含轧差效应的一般情况）：$r=0.02$，$\\lambda=0.03$，$R=0.4$，$[t_1,t_2,t_3,t_4]=[0.5,1.0,1.5,2.0]$，$[E^{\\mathrm{old}}_k]_{k=1}^4=[10,8,6,4]$，$[E^{\\mathrm{new}}_k]_{k=1}^4=[-3,-2,1,2]$。\n- 测试用例 $2$（边界情况：零风险率）：$r=0.02$，$\\lambda=0.0$，$R=0.4$，$[t_1,t_2,t_3,t_4]=[0.5,1.0,1.5,2.0]$，$[E^{\\mathrm{old}}_k]_{k=1}^4=[2,-1,4,-2]$，$[E^{\\mathrm{new}}_k]_{k=1}^4=[1,-3,2,0]$。\n- 测试用例 $3$（所有风险敞口严格为正，零无风险利率，零回收率）：$r=0.0$，$\\lambda=0.1$，$R=0.0$，$[t_1,t_2,t_3,t_4]=[0.25,0.5,0.75,1.0]$，$[E^{\\mathrm{old}}_k]_{k=1}^4=[5,5,5,5]$，$[E^{\\mathrm{new}}_k]_{k=1}^4=[2,2,2,2]$。\n- 测试用例 $4$（边界情况：完全回收）：$r=0.05$，$\\lambda=0.2$，$R=1.0$，$[t_1,t_2,t_3]=[1.0,2.0,3.0]$，$[E^{\\mathrm{old}}_k]_{k=1}^3=[-1,2,3]$，$[E^{\\mathrm{new}}_k]_{k=1}^3=[4,-1,1]$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例1到4的顺序排列，每个数字都精确四舍五入到小数点后六位（例如，[0.123456,-0.000001,1.000000]）。", "solution": "问题陈述已经过严格验证。经确认，该问题具有科学依据、提法恰当，且没有矛盾或歧义。所提供的信用估值调整（CVA）的定义和公式是量化金融中使用的标准（尽管是简化的）表示方法。已为指定的测试用例提供了所有必需的参数。因此，该问题被认定为 **有效**。我们接下来推导解决方案。\n\n目标是计算将一笔新交易添加至现有投资组合后所产生的增量CVA（$\\Delta \\mathrm{CVA}$）。$\\Delta \\mathrm{CVA}$ 定义为合并后投资组合的CVA与原始投资组合的CVA之差：\n$$\n\\Delta \\mathrm{CVA} = \\mathrm{CVA}(\\text{合并后}) - \\mathrm{CVA}(\\text{原始})\n$$\n\n对于给定的风险敞口概况，CVA使用离散时间近似公式计算：\n$$\n\\mathrm{CVA} = (1-R)\\sum_{k=1}^{N} D(t_k)\\,\\Big(\\max\\big(E_k,0\\big)\\Big)\\,\\Delta \\mathrm{PD}_k\n$$\n其中：\n- $R$ 是部分回收率。\n- $N$ 是时间步数。\n- $t_k$ 是第 $k$ 步的时间（以年为单位）。\n- $E_k$ 是在 $t_k$ 时刻的净风险敞口。\n- $D(t_k)$ 是在 $t_k$ 时刻的无风险折现因子。\n- $\\Delta \\mathrm{PD}_k$ 是时间区间 $(t_{k-1}, t_k]$ 内的增量违约概率。\n\n对于每个时间步 $k \\in \\{1, 2, \\dots, N\\}$，该公式的各组成部分计算如下：\n\n1.  **折现因子, $D(t_k)$**：这是在 $t_k$ 时刻将收到的一个货币单位的现值。在恒定的无风险利率 $r$ 下，其计算公式为：\n    $$\n    D(t_k) = \\exp(-r \\cdot t_k)\n    $$\n\n2.  **增量违约概率, $\\Delta \\mathrm{PD}_k$**：这是指在对手方存活至 $t_{k-1}$ 时刻的条件下，在区间 $(t_{k-1}, t_k]$ 内发生违约的概率。它由生存函数 $S(t) = \\exp(-\\lambda t)$ 推导而来，其中 $\\lambda$ 是恒定的风险率。我们定义 $t_0 = 0$。\n    $$\n    \\Delta \\mathrm{PD}_k = S(t_{k-1}) - S(t_k) = \\exp(-\\lambda \\cdot t_{k-1}) - \\exp(-\\lambda \\cdot t_k)\n    $$\n\n3.  **正风险敞口, $\\max\\big(E_k,0\\big)$**：CVA计算仅在风险敞口 $E_k$ 为正时适用，这意味着如果对手方违约，我们将遭受损失。对于原始投资组合，风险敞口为 $E_k^{\\mathrm{old}}$。对于合并后的投资组合，风险敞口是原始风险敞口和新交易风险敞口之和，即 $E_k^{\\mathrm{comb}} = E_k^{\\mathrm{old}} + E_k^{\\mathrm{new}}$，这反映了轧差效应。\n\n总体算法如下：\n\n首先，计算原始投资组合的CVA，即 $\\mathrm{CVA}^{\\mathrm{old}}$。\n$$\n\\mathrm{CVA}^{\\mathrm{old}} = (1-R)\\sum_{k=1}^{N} \\exp(-r t_k) \\cdot \\max\\big(E_k^{\\mathrm{old}}, 0\\big) \\cdot \\big(\\exp(-\\lambda t_{k-1}) - \\exp(-\\lambda t_k)\\big)\n$$\n\n其次，计算合并后投资组合的CVA，即 $\\mathrm{CVA}^{\\mathrm{comb}}$。每个时间步的合并风险敞口为 $E_k^{\\mathrm{comb}} = E_k^{\\mathrm{old}} + E_k^{\\mathrm{new}}$。\n$$\n\\mathrm{CVA}^{\\mathrm{comb}} = (1-R)\\sum_{k=1}^{N} \\exp(-r t_k) \\cdot \\max\\big(E_k^{\\mathrm{old}} + E_k^{\\mathrm{new}}, 0\\big) \\cdot \\big(\\exp(-\\lambda t_{k-1}) - \\exp(-\\lambda t_k)\\big)\n$$\n\n最后，增量CVA是二者之差：\n$$\n\\Delta \\mathrm{CVA} = \\mathrm{CVA}^{\\mathrm{comb}} - \\mathrm{CVA}^{\\mathrm{old}}\n$$\n\n此过程将应用于每个测试用例。测试套件中提供的边界条件可作为检验实现正确性的重要手段：\n- 如果 $\\lambda = 0$，则对所有 $k$ 都有 $\\Delta \\mathrm{PD}_k = 0$，这必然导致 $\\mathrm{CVA} = 0$ 和 $\\Delta \\mathrm{CVA} = 0$。\n- 如果 $R = 1$，则因子 $(1-R) = 0$，这也必然导致 $\\mathrm{CVA} = 0$ 和 $\\Delta \\mathrm{CVA} = 0$。\n\n为提高效率，实现中将利用向量化计算，即在单次操作中处理整个折现因子、违约概率和风险敞口数组。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the incremental Credit Valuation Adjustment (Delta CVA)\n    for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"r\": 0.02, \"lambda\": 0.03, \"R\": 0.4,\n            \"t\": [0.5, 1.0, 1.5, 2.0],\n            \"E_old\": [10, 8, 6, 4],\n            \"E_new\": [-3, -2, 1, 2]\n        },\n        {\n            \"r\": 0.02, \"lambda\": 0.0, \"R\": 0.4,\n            \"t\": [0.5, 1.0, 1.5, 2.0],\n            \"E_old\": [2, -1, 4, -2],\n            \"E_new\": [1, -3, 2, 0]\n        },\n        {\n            \"r\": 0.0, \"lambda\": 0.1, \"R\": 0.0,\n            \"t\": [0.25, 0.5, 0.75, 1.0],\n            \"E_old\": [5, 5, 5, 5],\n            \"E_new\": [2, 2, 2, 2]\n        },\n        {\n            \"r\": 0.05, \"lambda\": 0.2, \"R\": 1.0,\n            \"t\": [1.0, 2.0, 3.0],\n            \"E_old\": [-1, 2, 3],\n            \"E_new\": [4, -1, 1]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        r = case[\"r\"]\n        lam = case[\"lambda\"]\n        R = case[\"R\"]\n        t_k = np.array(case[\"t\"])\n        E_old_k = np.array(case[\"E_old\"])\n        E_new_k = np.array(case[\"E_new\"])\n\n        # Prepend t_0 = 0 to the time grid for calculating intervals.\n        t_prev_k = np.concatenate(([0], t_k[:-1]))\n\n        # Calculate discount factors D(t_k)\n        D_k = np.exp(-r * t_k)\n\n        # Calculate survival probabilities at t_k-1 and t_k\n        S_prev_k = np.exp(-lam * t_prev_k)\n        S_k = np.exp(-lam * t_k)\n        \n        # Calculate incremental default probabilities Delta_PD_k\n        delta_PD_k = S_prev_k - S_k\n\n        # Calculate the CVA contribution factor, common to both portfolios\n        cva_factor = (1 - R) * D_k * delta_PD_k\n\n        # --- CVA for the old portfolio ---\n        # Calculate positive exposure for the old portfolio\n        positive_E_old_k = np.maximum(E_old_k, 0)\n        # Sum the terms to get CVA_old\n        cva_old = np.sum(cva_factor * positive_E_old_k)\n\n        # --- CVA for the combined portfolio ---\n        # Calculate combined exposure\n        E_comb_k = E_old_k + E_new_k\n        # Calculate positive exposure for the combined portfolio\n        positive_E_comb_k = np.maximum(E_comb_k, 0)\n        # Sum the terms to get CVA_comb\n        cva_comb = np.sum(cva_factor * positive_E_comb_k)\n\n        # --- Incremental CVA ---\n        delta_cva = cva_comb - cva_old\n        results.append(delta_cva)\n\n    # Format the results to exactly six decimal places and print.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "信用估值调整（CVA）的准确性高度依赖于其输入参数的质量，尤其是交易对手的违约概率。本练习将传统的CVA框架与现代机器学习技术相结合，要求您使用逻辑回归模型预测的违约概率来驱动CVA计算。您将学习如何将一个经验模型输出的年度违约概率（$p_{\\text{ann}}$）转换为风险中性定价框架中所需的瞬时违约强度（$\\lambda$），从而搭建起连接数据科学与金融风险建模的桥梁 [@problem_id:2386252]。", "id": "2386252", "problem": "您的任务是计算一个投资组合的信用估值调整（CVA）。其中，交易对手的违约概率由一个基于公司特定特征训练的逻辑斯蒂回归（LR）模型导出。您的目标是首先从第一性原理出发进行推导，然后实现一个程序，在风险中性测度下计算投资组合的CVA，并假设敞口与违約相互独立，且为单边交易对手信用风险。\n\n假设与基础：\n- 在风险中性估值下，投资组合的信用估值调整（CVA）可以表示为在一定时间范围内，因交易对手违约而产生的贴现预期损失。令 $t \\in [0, T]$ 表示时间，$D(t)$ 为无风险贴现因子，$\\text{LGD}$ 为违约损失率，$E^{\\mathbb{Q}}[\\cdot]$ 为风险中性期望，$\\tau$ 为交易对手的随机违约时间。其一般定义为\n$$\n\\text{CVA} \\;=\\; E^{\\mathbb{Q}}\\!\\left[\\int_{0}^{T} D(t)\\,\\text{LGD}\\,\\max(V(t),0)\\,\\mathrm{d}\\mathbf{1}_{\\{\\tau \\le t\\}}\\right].\n$$\n- 公司的时点违约概率使用逻辑斯蒂回归建模。对于每个特征向量为 $x \\in \\mathbb{R}^{d}$ 的公司，令 LR 得分为 $z = \\beta_0 + \\sum_{i=1}^{d} \\beta_i x_i$。年度无条件违约概率为 $p_{\\text{ann}} = \\sigma(z)$，其中逻辑斯蒂 (sigmoid) 函数为 $\\sigma(u) = \\frac{1}{1 + e^{-u}}$。\n- 对于一个风险率为 $\\lambda$ 的恒定风险率模型，其生存函数为 $S(t) = e^{-\\lambda t}$，一年内的无条件违约概率与之相关，即 $p_{\\text{ann}} = 1 - e^{-\\lambda \\cdot 1}$。这意味着 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。\n- 对于一个离散的年度时间网格 $t_k = k$（$k = 1, \\dots, K$），在网格点上具有分段恒定的预期正敞口（EPE），以及一个固定的连续复利无风险利率 $r$，贴现因子为 $D(t_k) = e^{-r t_k}$。\n- 在恒定风险率 $\\lambda$ 下，区间 $(t_{k-1}, t_k]$ 内的边际违约概率为 $S(t_{k-1}) - S(t_k)$，其中 $S(0) = 1$。\n\n任务：\n1. 从风险中性CVA的一般定义和上述假设出发，推导年度网格上投资组合CVA的离散化表达式。您的推导必须清晰地展示如何结合违约可能性、贴现因子、预期正敞口（EPE）和违约损失率（LGD）。不要使用任何未经证明或未加解释的简化公式；从生存概率、风险率和风险中性期望的定义出发，推导每一步。\n2. 实现一个程序，该程序：\n   - 使用 LR 模型，通过 $p_{\\text{ann}} = \\sigma(\\beta_0 + \\sum_{i=1}^{d} \\beta_i x_i)$ 从特征和系数计算年度违约概率 $p_{\\text{ann}}$。\n   - 将 $p_{\\text{ann}}$ 转换为恒定风险率 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。\n   - 使用年度网格 $t_k = k$（其中 $k$ 等于公司的EPE点数）计算生存概率 $S(t_k) = e^{-\\lambda t_k}$ 和边际违约概率 $S(t_{k-1}) - S(t_k)$。\n   - 计算每家公司的CVA，即对所有 $k$ 的贴现预期损失贡献求和，然后对所有公司求和以获得投资组合的CVA。\n   - 实现数值稳定的逻辑斯蒂函数评估，并在应用对数变换前，将概率裁剪到开放区间 $(\\epsilon, 1-\\epsilon)$ 内，其中 $\\epsilon = 10^{-12}$。\n3. 使用以下测试套件。每个测试用例提供一个固定利率 $r$、一个截距项 $\\beta_0$、一个系数向量 $\\beta$，以及一个公司列表，每个公司都包含特征向量 $x$、违约损失率 $\\text{LGD}$ 和一个年度网格EPE向量。时间步长为一年，因此第 $k$ 个EPE条目对应于 $t_k = k$。\n   - 测试用例1（正常路径，多家公司，中等概率，5年期限）：\n     - $r = 0.02$,\n     - $\\beta_0 = -4.0$,\n     - $\\beta = [0.8, -0.5]$,\n     - 公司：\n       - 公司 A: $x = [1.2, 0.3]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [1.0, 0.9, 0.8, 0.7, 0.6]$.\n       - 公司 B: $x = [0.5, -0.1]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [0.5, 0.5, 0.5, 0.5, 0.5]$.\n       - 公司 C: $x = [-0.2, 1.5]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [0.2, 0.25, 0.3, 0.35, 0.4]$.\n   - 测试用例2（边界条件：零敞口意味着零CVA，3年期限）：\n     - $r = 0.01$,\n     - $\\beta_0 = -4.0$,\n     - $\\beta = [0.8, -0.5]$,\n     - 公司：\n       - 公司 D: $x = [0.0, 0.0]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [0.0, 0.0, 0.0]$.\n       - 公司 E: $x = [1.0, -1.0]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [0.0, 0.0, 0.0]$.\n   - 测试用例3（边缘覆盖：高低概率，异构LGD，零无风险利率，7年期限）：\n     - $r = 0.0$,\n     - $\\beta_0 = -1.0$,\n     - $\\beta = [1.5, 1.0]$,\n     - 公司：\n       - 公司 F: $x = [1.0, 1.0]$, $\\text{LGD} = 0.4$, $\\text{EPE} = [0.2, 0.4, 0.6, 0.8, 0.6, 0.4, 0.2]$.\n       - 公司 G: $x = [-2.0, -1.0]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4]$.\n4. 输出规格：\n   - 对于每个测试用例，计算一个单一的投资组合CVA值，作为浮点数。\n   - 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个数字必须四舍五入到 $6$ 位小数。例如：$[0.123456,0.000000,1.234568]$。\n5. 角度单位不适用。百分比必须表示为小数（例如，$\\text{LGD} = 0.6$ 表示 $60\\%$）。不需要物理单位；货币值被视为抽象的数值量。\n\n您的实现必须是自包含的，不需要任何输入，并严格遵循输出格式。任何偏离指定格式的行为都将被视为不正确。算法应具有足够的通用性以处理所列的测试套件。", "solution": "计算投资组合信用估值调整（CVA）的问题是有效的，因为它科学地基于金融工程的既定原则，其数据和假设完整一致，问题陈述清晰客观。以下是从第一性原理出发的推导，随后是解决方案的实现。\n\n推导始于CVA的一般风险中性定义。CVA代表交易对手信用风险的市场价值。对于单个交易对手，它是在交易对手违约时刻 $\\tau$ 发生的贴现损失的风险中性期望值。\n给出的定义是：\n$$ \\text{CVA} = E^{\\mathbb{Q}}\\!\\left[\\int_{0}^{T} D(t)\\,\\text{LGD}\\,\\max(V(t),0)\\,\\mathrm{d}\\mathbf{1}_{\\{\\tau \\le t\\}}\\right] $$\n其中 $E^{\\mathbb{Q}}[\\cdot]$ 是在风险中性测度 $\\mathbb{Q}$ 下的期望，$D(t)$ 是时间 $t$ 的无风险贴现因子，$\\text{LGD}$ 是违约损失率（一个固定比例），$V(t)$ 是与该交易对手的交易组合的市场价值，$\\tau$ 是随机违约时间。项 $\\max(V(t),0)$ 代表违约时的敞口，因为只有当投资组合对我们具有正价值时才会发生损失。该积分为一个斯蒂尔切斯积分，可以解释为在违约瞬间 $\\tau$（前提是 $\\tau \\le T$）对贴现损失进行求值。一个更标准的公式是：\n$$ \\text{CVA} = E^{\\mathbb{Q}}\\!\\left[ \\mathbf{1}_{\\{\\tau \\le T\\}} \\cdot D(\\tau) \\cdot \\text{LGD} \\cdot \\max(V(\\tau), 0) \\right] $$\n这表示CVA是损失的期望，从违约时间 $\\tau$ 贴现回来。为了评估这个期望，我们可以对所有可能的违约时间进行积分，并以其风险中性概率密度加权。令 $f_\\tau(t)$ 为违约时间 $\\tau$ 的概率密度函数（PDF）。则CVA为：\n$$ \\text{CVA} = \\int_{0}^{T} E^{\\mathbb{Q}}\\!\\left[ D(t) \\cdot \\text{LGD} \\cdot \\max(V(t), 0) \\mid \\tau=t \\right] f_\\tau(t) \\, \\mathrm{d}t $$\n一个关键假设是违约事件与驱动投资组合价值 $V(t)$ 的市场风险相互独立。这使我们能够分离期望：\n$$ E^{\\mathbb{Q}}\\!\\left[ D(t) \\cdot \\text{LGD} \\cdot \\max(V(t), 0) \\mid \\tau=t \\right] = D(t) \\cdot \\text{LGD} \\cdot E^{\\mathbb{Q}}\\!\\left[\\max(V(t), 0)\\right] $$\n项 $E^{\\mathbb{Q}}\\!\\left[\\max(V(t), 0)\\right]$ 是预期正敞口，记为 $\\text{EPE}(t)$。公式简化为：\n$$ \\text{CVA} = \\int_{0}^{T} D(t) \\cdot \\text{LGD} \\cdot \\text{EPE}(t) \\cdot f_\\tau(t) \\, \\mathrm{d}t $$\nPDF $f_\\tau(t)$ 与生存概率函数 $S(t) = P(\\tau > t)$ 的关系是 $f_\\tau(t) = -\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t}$。将其代入，我们得到：\n$$ \\text{CVA} = -\\int_{0}^{T} D(t) \\cdot \\text{LGD} \\cdot \\text{EPE}(t) \\cdot S'(t) \\, \\mathrm{d}t $$\n为了进行数值实现，我们将时间范围 $[0, T]$ 离散化为 $K$ 个区间 $(t_{k-1}, t_k]$，其中 $t_k = k$（$k=1, \\dots, K$），并且 $t_0=0$。该积分通过对这些区间的求和来近似：\n$$ \\text{CVA} \\approx \\sum_{k=1}^{K} \\int_{t_{k-1}}^{t_k} D(t) \\cdot \\text{LGD} \\cdot \\text{EPE}(t) \\cdot f_\\tau(t) \\, \\mathrm{d}t $$\n我们假设在每个小区间 $(t_{k-1}, t_k]$ 内，$D(t)$ 和 $\\text{EPE}(t)$ 两项近似为常数，并可以在区间末端进行求值，即 $D(t) \\approx D(t_k)$ และ $\\text{EPE}(t) \\approx \\text{EPE}(t_k)$。这是一个标准的一阶近似。\n$$ \\text{CVA} \\approx \\sum_{k=1}^{K} D(t_k) \\cdot \\text{LGD} \\cdot \\text{EPE}(t_k) \\int_{t_{k-1}}^{t_k} f_\\tau(t) \\, \\mathrm{d}t $$\nPDF在区间 $(t_{k-1}, t_k]$ 上的积分就是在此区间内违约的概率：\n$$ \\int_{t_{k-1}}^{t_k} f_\\tau(t) \\, \\mathrm{d}t = P(t_{k-1} < \\tau \\le t_k) = S(t_{k-1}) - S(t_k) $$\n此项是第 $k$ 期的边际违约概率。将其代入求和式，得到单个交易对手CVA的最终离散化公式：\n$$ \\text{CVA}_{\\text{firm}} \\approx \\text{LGD} \\sum_{k=1}^{K} D(t_k) \\cdot \\text{EPE}(t_k) \\cdot [S(t_{k-1}) - S(t_k)] $$\n投资组合CVA是每个独立交易对手的CVA之和，假设它们的违约是独立事件：\n$$ \\text{CVA}_{\\text{portfolio}} = \\sum_{j} \\text{CVA}_{\\text{firm } j} $$\n现在我们整合所提供的具体模型。违约过程由一个恒定风险率 $\\lambda$ 建模。生存函数为 $S(t) = e^{-\\lambda t}$。风险率 $\\lambda$ 从逻辑斯蒂回归模型的输出（即年度无条件违约概率 $p_{\\text{ann}}$）导出。其关系为 $p_{\\text{ann}} = P(\\tau \\le 1) = 1 - S(1) = 1 - e^{-\\lambda \\cdot 1}$。解出 $\\lambda$ 可得 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。年度概率 $p_{\\text{ann}}$ 由线性得分 $z = \\beta_0 + \\mathbf{x}^T \\boldsymbol{\\beta}$ 的sigmoid函数 $\\sigma(z)$ 给出：\n$$ p_{\\text{ann}} = \\sigma(z) = \\frac{1}{1+e^{-z}} $$\n对于连续复利利率 $r$，在时间 $t_k=k$ 的无风险贴现因子是 $D(t_k) = e^{-r t_k}$。综合所有组成部分，我们按如下方式计算单个公司的CVA：\n1.  计算得分 $z = \\beta_0 + \\sum_{i=1}^{d} \\beta_i x_i$。\n2.  使用数值稳定的实现计算年度违约概率 $p_{\\text{ann}} = \\sigma(z)$。将 $p_{\\text{ann}}$ 裁剪到 $(\\epsilon, 1-\\epsilon)$ 区间内，其中 $\\epsilon=10^{-12}$。\n3.  计算恒定风险率 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。\n4.  计算每个时间区间 $k=1, \\dots, K$ 的CVA贡献：\n    $$ \\text{CVA}_{\\text{firm}} = \\text{LGD} \\sum_{k=1}^{K} e^{-r k} \\cdot \\text{EPE}_k \\cdot (e^{-\\lambda (k-1)} - e^{-\\lambda k}) $$\n    其中 $\\text{EPE}_k$ 是给定的第 $k$ 年的预期正敞口。投资组合的总CVA是所有公司这些值的总和。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes portfolio CVA based on a logistic regression model for default probabilities.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"r\": 0.02,\n            \"beta0\": -4.0,\n            \"beta\": np.array([0.8, -0.5]),\n            \"firms\": [\n                {\"x\": np.array([1.2, 0.3]), \"lgd\": 0.6, \"epe\": np.array([1.0, 0.9, 0.8, 0.7, 0.6])},\n                {\"x\": np.array([0.5, -0.1]), \"lgd\": 0.6, \"epe\": np.array([0.5, 0.5, 0.5, 0.5, 0.5])},\n                {\"x\": np.array([-0.2, 1.5]), \"lgd\": 0.6, \"epe\": np.array([0.2, 0.25, 0.3, 0.35, 0.4])},\n            ]\n        },\n        # Test case 2\n        {\n            \"r\": 0.01,\n            \"beta0\": -4.0,\n            \"beta\": np.array([0.8, -0.5]),\n            \"firms\": [\n                {\"x\": np.array([0.0, 0.0]), \"lgd\": 0.6, \"epe\": np.array([0.0, 0.0, 0.0])},\n                {\"x\": np.array([1.0, -1.0]), \"lgd\": 0.6, \"epe\": np.array([0.0, 0.0, 0.0])},\n            ]\n        },\n        # Test case 3\n        {\n            \"r\": 0.0,\n            \"beta0\": -1.0,\n            \"beta\": np.array([1.5, 1.0]),\n            \"firms\": [\n                {\"x\": np.array([1.0, 1.0]), \"lgd\": 0.4, \"epe\": np.array([0.2, 0.4, 0.6, 0.8, 0.6, 0.4, 0.2])},\n                {\"x\": np.array([-2.0, -1.0]), \"lgd\": 0.6, \"epe\": np.array([1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4])},\n            ]\n        }\n    ]\n\n    results = []\n    \n    # Numerical precision for clipping\n    epsilon = 1e-12\n\n    def stable_sigmoid(z):\n        \"\"\"Numerically stable sigmoid function.\"\"\"\n        if z >= 0:\n            return 1.0 / (1.0 + np.exp(-z))\n        else:\n            # Use formulation exp(z) / (1 + exp(z)) to avoid overflow\n            exp_z = np.exp(z)\n            return exp_z / (1.0 + exp_z)\n\n    for case in test_cases:\n        r = case[\"r\"]\n        beta0 = case[\"beta0\"]\n        beta = case[\"beta\"]\n        firms = case[\"firms\"]\n        \n        portfolio_cva = 0.0\n        \n        for firm in firms:\n            x = firm[\"x\"]\n            lgd = firm[\"lgd\"]\n            epe = firm[\"epe\"]\n            \n            # 1. Compute LR score\n            z = beta0 + np.dot(beta, x)\n            \n            # 2. Compute annual default probability\n            p_ann = stable_sigmoid(z)\n            \n            # 3. Clip for numerical stability before log\n            p_ann_clipped = np.clip(p_ann, epsilon, 1.0 - epsilon)\n            \n            # 4. Convert to constant hazard rate\n            # If p_ann is 1, lambda would be inf. Clipping handles this.\n            hazard_rate_lambda = -np.log(1.0 - p_ann_clipped)\n            \n            firm_cva = 0.0\n            num_steps = len(epe)\n            \n            if num_steps == 0:\n                portfolio_cva += 0.0\n                continue\n                \n            # Time steps k = 1, 2, ..., K\n            k_steps = np.arange(1, num_steps + 1)\n            \n            # Discount factors D(t_k) = exp(-r*k)\n            discount_factors = np.exp(-r * k_steps)\n            \n            # Survival probabilities S(t_k) = exp(-lambda*k) and S(t_{k-1})\n            s_k_minus_1 = np.exp(-hazard_rate_lambda * (k_steps - 1))\n            s_k = np.exp(-hazard_rate_lambda * k_steps)\n            \n            # Marginal default probabilities in (t_{k-1}, t_k]\n            marginal_pd = s_k_minus_1 - s_k\n            \n            # Expected loss for each period\n            expected_loss_periods = epe * marginal_pd\n            \n            # Discounted expected loss for each period\n            discounted_el = discount_factors * expected_loss_periods\n            \n            # Sum over all periods and multiply by LGD for the firm's CVA\n            firm_cva = lgd * np.sum(discounted_el)\n            \n            portfolio_cva += firm_cva\n            \n        results.append(round(portfolio_cva, 6))\n\n    # Format the final output string\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```"}]}