{"hands_on_practices": [{"introduction": "理论上，Merton 模型为计算违约概率提供了一个清晰的公式。然而，在实际应用中，一个核心挑战是确定违约阈值 $F$，这个参数无法从财务报表中直接观测得到。本练习将通过几种常见且合理的启发式方法来定义 $F$，并计算相应的违约概率，从而让你亲身体验模型对输入参数的敏感性，并理解模型风险在信用评估中的重要性。[@problem_id:2435090]", "id": "2435090", "problem": "考虑一家公司，其总资产价值过程 $\\{V_t\\}_{t \\in [0,T]}$ 在风险中性测度下演化，遵循随机微分方程 $\\mathrm{d}V_t = (r - q) V_t \\, \\mathrm{d}t + \\sigma V_t \\, \\mathrm{d}W_t$ 所描述的几何布朗运动，其中 $V_0 > 0$ 为已知初始值，$r \\ge 0$ 是连续复利无风险利率，$q \\ge 0$ 是资产的连续派发收益率，$\\sigma > 0$ 是资产波动率，$T > 0$ 是时间跨度（以年为单位）。在 Merton 的结构化违约模型中，当且仅当 $V_T < F$ 时发生违约，其中 $F > 0$ 是一个与公司债务相关的、类似面值的违约阈值。\n\n您的任务是，对于几组参数集，计算在定义 $F$ 的不同常见启发式方法下，期限为 $T$ 时的风险中性违约概率，并量化计算出的违约概率对启发式方法选择的敏感性。对于每个参数集，您将获得以下输入：$V_0$、$\\sigma$、$r$、$q$、$T$、短期（流动）带息债务 $D_S$、长期带息债务 $D_L$、总负债 $L$，以及现金及等价物 $C$。您必须评估以下四种关于 $F$ 的启发式方法：\n\n- 启发式方法 $\\mathrm{H1}$（一半长期债务）：$F_1 = D_S + 0.5 \\, D_L$。\n- 启发式方法 $\\mathrm{H2}$（所有带息债务）：$F_2 = D_S + D_L$。\n- 启发式方法 $\\mathrm{H3}$（总负债）：$F_3 = L$。\n- 启发式方法 $\\mathrm{H4}$（有底线的净债务）：$F_4 = \\max\\{ D_S + D_L - C, \\, 1 \\}$，其中底线值 $1$ 确保了严格为正。\n\n对于每种启发式方法 $\\mathrm{Hi}$，计算模型所隐含的风险中性违约概率 $p_i = \\mathbb{Q}(V_T < F_i)$。然后，基于这四个 $p_i$ 值计算以下敏感性指标：\n- 绝对范围 $R_{\\mathrm{abs}} = \\max_i p_i - \\min_i p_i$。\n- 相对范围 $R_{\\mathrm{rel}} = R_{\\mathrm{abs}} / \\overline{p}$，其中 $\\overline{p}$ 是 $\\{p_1, p_2, p_3, p_4\\}$ 的算术平均值。\n\n所有概率和敏感性指标必须以小数形式表示（而非百分比）。\n\n请使用以下参数集测试套件。每个测试用例是一个元组 $(V_0,\\sigma,r,q,T,D_S,D_L,L,C)$：\n\n- 用例 $\\#1$：$(200.0, \\, 0.25, \\, 0.02, \\, 0.00, \\, 1.0, \\, 30.0, \\, 70.0, \\, 120.0, \\, 20.0)$。\n- 用例 $\\#2$：$(120.0, \\, 0.30, \\, 0.03, \\, 0.01, \\, 1.0, \\, 40.0, \\, 100.0, \\, 180.0, \\, 10.0)$。\n- 用例 $\\#3$：$(90.0, \\, 0.20, \\, 0.01, \\, 0.00, \\, 0.5, \\, 50.0, \\, 80.0, \\, 150.0, \\, 5.0)$。\n- 用例 $\\#4$：$(150.0, \\, 0.15, \\, 0.02, \\, 0.00, \\, 2.0, \\, 10.0, \\, 20.0, \\, 60.0, \\, 50.0)$。\n\n对于每个用例，您的程序必须输出一个包含六个浮点数的列表，顺序为 $[p_1, \\, p_2, \\, p_3, \\, p_4, \\, R_{\\mathrm{abs}}, \\, R_{\\mathrm{rel}}]$，其中每个浮点数四舍五入到 $6$ 位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有用例的结果，格式为列表的列表。外层列表必须恰好包含 $4$ 个内层列表，每个内层列表按上述顺序对应一个用例，并且每个内层列表必须恰好包含 $6$ 个四舍五入到 $6$ 位小数的浮点数。例如，打印的行必须类似于 $[[x_{11},x_{12},\\dots,x_{16}],[x_{21},\\dots,x_{26}],[x_{31},\\dots,x_{36}],[x_{41},\\dots,x_{46}]]$，不含多余的空格或文本。", "solution": "该问题要求在 Merton 模型框架下，使用几种定义违约壁垒的启发式方法来计算风险中性违约概率，并分析这些概率对启发式方法选择的敏感性。该问题提法清晰，科学上基于成熟的金融理论，并为获得唯一解提供了所有必要的数据。\n\n公司资产的价值 $V_t$ 在风险中性测度 $\\mathbb{Q}$ 下被建模为几何布朗运动：\n$$\n\\mathrm{d}V_t = (r - q) V_t \\, \\mathrm{d}t + \\sigma V_t \\, \\mathrm{d}W_t\n$$\n其中 $r$ 是无风险利率，$q$ 是连续股息收益率，$\\sigma$ 是资产波动率，$W_t$ 是标准维纳过程。在给定初始值 $V_0$ 的情况下，此随机微分方程在时间 $T$ 的资产价值解为\n$$\nV_T = V_0 \\exp\\left( \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T \\right)\n$$\n其中 $W_T = \\sqrt{T}Z$ 且 $Z$ 是一个标准正态随机变量，$Z \\sim N(0, 1)$。这意味着 $\\ln(V_T)$ 服从正态分布，其均值为 $\\mu = \\ln(V_0) + (r - q - \\frac{1}{2}\\sigma^2)T$，方差为 $\\sigma^2 T$。\n\n如果到期日 $T$ 的资产价值低于某个违约阈值 $F$，则发生违约。因此，风险中性违约概率 $p$ 由 $\\mathbb{Q}(V_T < F)$ 给出。为了计算这个概率，我们对对数正态变量进行标准化：\n$$\n\\begin{aligned}\np = \\mathbb{Q}(V_T < F) &= \\mathbb{Q}(\\ln(V_T) < \\ln(F)) \\\\\n&= \\mathbb{Q}\\left(\\frac{\\ln(V_T) - \\mu}{\\sigma\\sqrt{T}} < \\frac{\\ln(F) - \\mu}{\\sigma\\sqrt{T}}\\right) \\\\\n&= \\mathbb{Q}\\left(Z < \\frac{\\ln(F) - \\left(\\ln(V_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T\\right)}{\\sigma\\sqrt{T}}\\right) \\\\\n&= \\mathbb{Q}\\left(Z < \\frac{\\ln(F/V_0) - \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\right)\n\\end{aligned}\n$$\n该概率使用标准正态分布的累积分布函数（CDF）进行评估，记为 $\\Phi(\\cdot)$。在期权定价理论中，$\\Phi$ 的参数通常被认为是 Black-Scholes 模型 $d_2$ 参数的相反数。我们定义 $d_2$ 如下：\n$$\nd_2 = \\frac{\\ln(V_0/F) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n$$\n于是，违约概率由 $p = \\Phi(-d_2)$ 给出。\n\n问题指定了四种基于资产负债表数据定义违约阈值 $F$ 的启发式方法：短期债务 $D_S$、长期债务 $D_L$、总负债 $L$ 和现金 $C$。对于每种启发式方法 $\\mathrm{Hi}$，我们计算一个阈值 $F_i$ 和相应的违约概率 $p_i$。\n\n- 启发式方法 $\\mathrm{H1}$：$F_1 = D_S + 0.5 D_L$。违约概率为 $p_1 = \\Phi(-d_{2,1})$。\n- 启发式方法 $\\mathrm{H2}$：$F_2 = D_S + D_L$。违约概率为 $p_2 = \\Phi(-d_{2,2})$。\n- 启发式方法 $\\mathrm{H3}$：$F_3 = L$。违约概率为 $p_3 = \\Phi(-d_{2,3})$。\n- 启发式方法 $\\mathrm{H4}$：$F_4 = \\max\\{D_S + D_L - C, 1\\}$。违约概率为 $p_4 = \\Phi(-d_{2,4})$。\n\n对于每个测试用例，计算步骤如下：\n1.  根据输入参数 $(V_0, \\sigma, r, q, T, D_S, D_L, L, C)$，计算四个违约阈值 $F_1, F_2, F_3, F_4$。\n2.  对于每个阈值 $F_i$（其中 $i \\in \\{1, 2, 3, 4\\}$），计算相应的 $d_{2,i}$ 项：\n    $$\n    d_{2,i} = \\frac{\\ln(V_0/F_i) + (r - q - 0.5\\sigma^2)T}{\\sigma\\sqrt{T}}\n    $$\n3.  使用标准正态 CDF 的数值实现计算四个违约概率 $p_i = \\Phi(-d_{2,i})$。\n4.  获得概率集合 $\\{p_1, p_2, p_3, p_4\\}$ 后，计算两个敏感性指标：\n    -   绝对范围：$R_{\\mathrm{abs}} = \\max_i p_i - \\min_i p_i$。\n    -   相对范围：$R_{\\mathrm{rel}} = R_{\\mathrm{abs}} / \\overline{p}$，其中 $\\overline{p} = \\frac{1}{4}\\sum_{i=1}^{4} p_i$ 是算术平均值。由于 $V_0 > 0$、$F_i > 0$、$\\sigma > 0$ 和 $T > 0$，概率 $p_i = \\Phi(-d_{2,i})$ 始终严格为正，从而确保 $\\overline{p} > 0$ 且相对范围有明确定义。\n5.  将每个用例的结果汇总为一个包含六个值的列表：$[p_1, p_2, p_3, p_4, R_{\\mathrm{abs}}, R_{\\mathrm{rel}}]$，每个值四舍五入到 $6$ 位小数。对所有提供的测试用例重复此过程。\n\n科学计算库 `scipy.stats.norm` 提供了计算 $\\Phi(\\cdot)$ 所需的 `cdf` 函数。`numpy` 库则用于高效的数值和基于数组的计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes risk-neutral default probabilities and sensitivity metrics\n    for the Merton model under different default threshold heuristics.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (V0, sigma, r, q, T, DS, DL, L, C)\n    test_cases = [\n        (200.0, 0.25, 0.02, 0.00, 1.0, 30.0, 70.0, 120.0, 20.0),\n        (120.0, 0.30, 0.03, 0.01, 1.0, 40.0, 100.0, 180.0, 10.0),\n        (90.0, 0.20, 0.01, 0.00, 0.5, 50.0, 80.0, 150.0, 5.0),\n        (150.0, 0.15, 0.02, 0.00, 2.0, 10.0, 20.0, 60.0, 50.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        V0, sigma, r, q, T, DS, DL, L, C = case\n\n        # Heuristic 1: Half long-term debt\n        F1 = DS + 0.5 * DL\n        # Heuristic 2: All interest-bearing debt\n        F2 = DS + DL\n        # Heuristic 3: Total liabilities\n        F3 = L\n        # Heuristic 4: Net debt with floor\n        F4 = max(DS + DL - C, 1.0)\n        \n        # Array of default thresholds\n        F_arr = np.array([F1, F2, F3, F4])\n\n        # Common terms in the d2 formula\n        drift_term = (r - q - 0.5 * sigma**2) * T\n        stdev_term = sigma * np.sqrt(T)\n\n        # Calculate d2 for each heuristic in a vectorized way\n        # d2 = (ln(V0/F) + (r - q - 0.5*sigma^2)*T) / (sigma*sqrt(T))\n        d2_arr = (np.log(V0 / F_arr) + drift_term) / stdev_term\n        \n        # Calculate default probabilities: P(V_T < F) = N(-d2)\n        probs = norm.cdf(-d2_arr)\n\n        # Calculate sensitivity metrics\n        R_abs = np.max(probs) - np.min(probs)\n        mean_p = np.mean(probs)\n        \n        # Relative range, handle case of mean_p being zero to avoid division errors,\n        # though it's theoretically not possible with these model constraints.\n        R_rel = R_abs / mean_p if mean_p > 0 else 0.0\n        \n        # Combine all results for the current case\n        case_result = list(probs) + [R_abs, R_rel]\n\n        # Round to 6 decimal places as required\n        rounded_result = [round(x, 6) for x in case_result]\n        all_results.append(rounded_result)\n\n    # Format the final output string as a list of lists.\n    #\n    # This manual string construction ensures the output strictly matches\n    # the required format with no extra spaces.\n    # Ex: [[1.0,2.0],[3.0,4.0]]\n    list_of_lists_str = [\n        f\"[{','.join(map(str, res))}]\" \n        for res in all_results\n    ]\n    final_output_str = f\"[{','.join(list_of_lists_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"}, {"introduction": "在计算出一家公司的违约概率后，风险管理者往往更关心其随时间变化的驱动因素。本练习运用一阶泰勒展开，将违约概率的总变化分解为来自资产价值、资产波动率、杠杆水平和时间衰减等多个部分的贡献。通过实施这种敏感性分析，你将对信用风险的“希腊字母”（Greeks）建立更深刻的直觉，并掌握 Merton 框架下违约动态的核心驱动力。[@problem_id:2435102]", "id": "2435102", "problem": "请考虑由 Robert C. Merton 引入的违约结构模型。假设在风险中性测度下，一家公司的资产价值过程 $\\{V_t\\}_{t \\ge 0}$ 服从几何布朗运动，其中无风险利率 $r$ 和资产波动率 $\\sigma_V$ 为常数，因此到期日 $T$ 的终端资产价值呈对数正态分布。该公司有一笔单一的零息债务，面值为 $F$，于时间 $T$ 到期。当且仅当 $V_T < F$ 时，公司在 $T$ 时刻发生违约。在日历时间 $t$，剩余期限为 $\\tau = T - t$ 时，风险中性测度下的违约概率（PD）是在给定 $V_t = V$、$r$、$\\sigma_V$ 和 $\\tau$ 的条件下 $V_T < F$ 的概率，表示为 $[0,1]$ 区间内的小数（而非百分比）。\n\n设时间 $t$ 的初始参数向量为 $\\theta = (V, \\sigma_V, F, \\tau, r)$，并考虑一个微小的时间增量 $\\Delta t > 0$ 以及相应的参数微小变化量 $\\Delta V$、$\\Delta \\sigma_V$、$\\Delta F$。在时间 $t + \\Delta t$ 的新参数向量为 $\\theta' = (V + \\Delta V, \\sigma_V + \\Delta \\sigma_V, F + \\Delta F, \\tau - \\Delta t, r)$，其中 $\\tau - \\Delta t > 0$。将此短时间间隔内违约概率的精确变化定义为\n$$\n\\Delta \\text{PD}_{\\text{exact}} \\equiv \\text{PD}(V + \\Delta V, \\sigma_V + \\Delta \\sigma_V, F + \\Delta F, \\tau - \\Delta t, r) - \\text{PD}(V, \\sigma_V, F, \\tau, r).\n$$\n通过在初始参数 $\\theta$ 处计算 $\\text{PD}$ 的一阶微分，将 $\\Delta \\text{PD}_{\\text{exact}}$ 分解为由 $V$、$\\sigma_V$、$F$ 的变化以及时间流逝（时间衰减）引起的加性贡献项，从而产生四个贡献项 $C_V$、$C_{\\sigma}$、$C_F$ 和 $C_{\\text{time}}$，使得它们的和近似于 $\\Delta \\text{PD}_{\\text{exact}}$。将贡献项之和与精确变化之间的差值作为近似误差进行报告。\n\n假设违约概率 $\\text{PD}(V, \\sigma_V, F, \\tau, r)$ 是根据 $V_t$ 的风险中性动态所隐含的 $V_T$ 的对数正态分布以及违约事件 $\\{V_T < F\\}$ 直接计算得出的。所有结果必须表示为小数（而非百分比）。不涉及角度计算。\n\n您的程序必须为每个测试用例计算一个包含六个浮点数的列表：\n1. $\\Delta \\text{PD}_{\\text{exact}}$，\n2. $C_V$，\n3. $C_{\\sigma}$，\n4. $C_F$，\n5. $C_{\\text{time}}$，\n6. $\\left(C_V + C_{\\sigma} + C_F + C_{\\text{time}}\\right) - \\Delta \\text{PD}_{\\text{exact}}$，\n\n每个数值四舍五入到八位小数。将所有测试用例的结果汇总到一行输出中，该输出包含一个列表的列表，例如 \"[[...],[...],...]\"。\n\n使用以下参数值测试套件，每个测试用例为一个元组 $(V, \\sigma_V, F, \\tau, r, \\Delta V, \\Delta \\sigma_V, \\Delta F, \\Delta t)$：\n- 案例1（典型）：$(100.0, 0.25, 80.0, 1.0, 0.03, 0.5, 0.01, 0.2, 0.01)$。\n- 案例2（接近平价）：$(100.0, 0.30, 100.0, 0.5, 0.02, -1.0, -0.02, 0.0, 0.02)$。\n- 案例3（高杠杆）：$(70.0, 0.20, 100.0, 2.0, 0.05, 0.0, 0.03, -1.0, 0.1)$。\n- 案例4（短期限，纯时间衰减）：$(95.0, 0.35, 100.0, 0.05, 0.01, 0.0, 0.0, 0.0, 0.01)$。\n- 案例5（低波动率）：$(100.0, 0.05, 90.0, 1.5, 0.02, -0.5, 0.0, 0.0, 0.05)$。\n\n您的程序应生成单行输出，其中包含五个案例结果的逗号分隔列表，并用方括号括起来（例如 \"[[c1],[c2],[c3],[c4],[c5]]\"）。", "solution": "该问题要求在 Merton 模型框架内，对公司风险中性违约概率（PD）的变化进行分解。该分解基于对模型参数的一阶泰勒级数展开，这些参数包括：公司资产价值 $V$、资产波动率 $\\sigma_V$、债务面值 $F$ 和剩余期限 $\\tau$。\n\n首先，我们建立违约概率 $\\text{PD}$ 的公式。根据 Merton 模型，在风险中性测度 $\\mathbb{Q}$ 下，公司的资产价值 $V_t$ 服从几何布朗运动：\n$$\ndV_t = r V_t dt + \\sigma_V V_t dZ_t\n$$\n其中 $r$ 是恒定的无风险利率，$\\sigma_V$ 是恒定的资产波动率，$Z_t$ 是一个标准维纳过程。该随机微分方程的解给出了在时间 $t$ 的价值为 $V_t$ 的条件下，到期日 $T$ 的资产价值 $V_T$：\n$$\nV_T = V_t \\exp\\left( \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau + \\sigma_V \\sqrt{\\tau} Z \\right)\n$$\n其中 $\\tau = T - t$ 是剩余期限，$Z$ 是一个标准正态随机变量，$Z \\sim N(0, 1)$。\n\n当且仅当到期日的资产价值小于债务面值时，即 $V_T < F$，发生违约。此事件的概率为：\n$$\n\\text{PD} = \\mathbb{Q}(V_T < F | V_t = V) = \\mathbb{Q}\\left( V \\exp\\left( \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau + \\sigma_V \\sqrt{\\tau} Z \\right) < F \\right)\n$$\n在概率测度内的不等式两边取自然对数：\n$$\n\\ln(V) + \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau + \\sigma_V \\sqrt{\\tau} Z < \\ln(F)\n$$\n$$\n\\sigma_V \\sqrt{\\tau} Z < \\ln(F) - \\ln(V) - \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau\n$$\n$$\nZ < \\frac{\\ln(F/V) - \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau}{\\sigma_V \\sqrt{\\tau}} = - \\frac{\\ln(V/F) + \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau}{\\sigma_V \\sqrt{\\tau}}\n$$\n该表达式定义了标准违约距离指标的负值，即 $-d_2$，其中：\n$$\nd_2 = \\frac{\\ln(V/F) + \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau}{\\sigma_V \\sqrt{\\tau}}\n$$\n因此，违约概率由标准正态分布的累积分布函数（CDF）给出，即 $\\Phi(\\cdot)$：\n$$\n\\text{PD}(V, \\sigma_V, F, \\tau, r) = \\mathbb{Q}(Z < -d_2) = \\Phi(-d_2)\n$$\n问题要求计算精确变化 $\\Delta \\text{PD}_{\\text{exact}} = \\text{PD}(\\theta') - \\text{PD}(\\theta)$，并使用围绕初始参数向量 $\\theta = (V, \\sigma_V, F, \\tau, r)$ 的一阶泰勒展开来近似此变化。参数变化由 $(\\Delta V, \\Delta \\sigma_V, \\Delta F, -\\Delta t)$ 给出。一阶近似为：\n$$\n\\Delta \\text{PD}_{\\text{approx}} = \\frac{\\partial \\text{PD}}{\\partial V}\\Delta V + \\frac{\\partial \\text{PD}}{\\partial \\sigma_V}\\Delta \\sigma_V + \\frac{\\partial \\text{PD}}{\\partial F}\\Delta F + \\frac{\\partial \\text{PD}}{\\partial \\tau}(-\\Delta t)\n$$\n各个单项即为贡献项 $C_V$、$C_{\\sigma}$、$C_F$ 和 $C_{\\text{time}}$。为了计算这些项，我们必须求出 $\\text{PD}$ 对其各个参数的偏导数。使用链式法则，对于任何变量 $x$，我们有 $\\frac{\\partial \\text{PD}}{\\partial x} = \\frac{\\partial \\Phi(-d_2)}{\\partial x} = \\phi(-d_2) \\cdot \\left(-\\frac{\\partial d_2}{\\partial x}\\right)$，其中 $\\phi(\\cdot)$ 是标准正态概率密度函数（PDF）。由于 $\\phi(-z) = \\phi(z)$，这可以简化为 $\\frac{\\partial \\text{PD}}{\\partial x} = -\\phi(d_2) \\frac{\\partial d_2}{\\partial x}$。\n\n$d_2$ 的偏导数如下：\n1.  对 $V$ 求导：\n    $$\n    \\frac{\\partial d_2}{\\partial V} = \\frac{\\partial}{\\partial V} \\left( \\frac{\\ln V - \\ln F + (r - \\frac{1}{2}\\sigma_V^2)\\tau}{\\sigma_V \\sqrt{\\tau}} \\right) = \\frac{1}{V \\sigma_V \\sqrt{\\tau}}\n    $$\n    因此，对资产价值的敏感度为：\n    $$\n    C_V = \\frac{\\partial \\text{PD}}{\\partial V} \\Delta V = -\\frac{\\phi(d_2)}{V \\sigma_V \\sqrt{\\tau}} \\Delta V\n    $$\n2.  对 $F$ 求导：\n    $$\n    \\frac{\\partial d_2}{\\partial F} = \\frac{\\partial}{\\partial F} \\left( \\frac{\\ln V - \\ln F + (r - \\frac{1}{2}\\sigma_V^2)\\tau}{\\sigma_V \\sqrt{\\tau}} \\right) = -\\frac{1}{F \\sigma_V \\sqrt{\\tau}}\n    $$\n    对债务面值的敏感度为：\n    $$\n    C_F = \\frac{\\partial \\text{PD}}{\\partial F} \\Delta F = \\frac{\\phi(d_2)}{F \\sigma_V \\sqrt{\\tau}} \\Delta F\n    $$\n3.  对 $\\sigma_V$ 求导：\n    首先定义 $d_1 = d_2 + \\sigma_V \\sqrt{\\tau} = \\frac{\\ln(V/F) + (r + \\frac{1}{2}\\sigma_V^2)\\tau}{\\sigma_V \\sqrt{\\tau}}$ 会很有用。金融微积分中的一个标准结果是 $\\frac{\\partial d_2}{\\partial \\sigma_V} = -\\frac{d_1}{\\sigma_V}$。\n    因此，对资产波动率的敏感度为：\n    $$\n    C_{\\sigma} = \\frac{\\partial \\text{PD}}{\\partial \\sigma_V} \\Delta \\sigma_V = -\\phi(d_2) \\left( -\\frac{d_1}{\\sigma_V} \\right) \\Delta \\sigma_V = \\frac{\\phi(d_2) d_1}{\\sigma_V} \\Delta \\sigma_V\n    $$\n4.  对 $\\tau$ 求导：\n    $$\n    d_2 = \\frac{\\ln (V/F)}{\\sigma_V} \\tau^{-1/2} + \\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V} \\tau^{1/2}\n    $$\n    $$\n    \\frac{\\partial d_2}{\\partial \\tau} = -\\frac{1}{2}\\frac{\\ln (V/F)}{\\sigma_V} \\tau^{-3/2} + \\frac{1}{2}\\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V} \\tau^{-1/2} = \\frac{1}{2\\tau} \\left( -\\frac{\\ln(V/F)}{\\sigma_V\\sqrt{\\tau}} + \\frac{(r - \\frac{1}{2}\\sigma_V^2)\\tau}{\\sigma_V\\sqrt{\\tau}} \\right) = -\\frac{d_2}{2\\tau} + \\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V\\sqrt{\\tau}}\n    $$\n    时间衰减的贡献项为：\n    $$\n    C_{\\text{time}} = \\frac{\\partial \\text{PD}}{\\partial \\tau} (-\\Delta t) = -\\phi(d_2) \\left( -\\frac{d_2}{2\\tau} + \\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V\\sqrt{\\tau}} \\right) (-\\Delta t) = \\phi(d_2) \\left( -\\frac{d_2}{2\\tau} + \\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V\\sqrt{\\tau}} \\right) \\Delta t\n    $$\n所实现的算法将执行以下步骤：\n1.  对于每个测试用例，定义初始参数向量 $\\theta = (V, \\sigma_V, F, \\tau, r)$ 和变化量 $(\\Delta V, \\Delta \\sigma_V, \\Delta F, \\Delta t)$。\n2.  计算初始违约概率 $\\text{PD}(\\theta) = \\Phi(-d_2(\\theta))$。\n3.  定义新的参数向量 $\\theta' = (V+\\Delta V, \\sigma_V+\\Delta \\sigma_V, F+\\Delta F, \\tau-\\Delta t, r)$。\n4.  计算最终违约概率 $\\text{PD}(\\theta')$。\n5.  计算精确变化：$\\Delta \\text{PD}_{\\text{exact}} = \\text{PD}(\\theta') - \\text{PD}(\\theta)$。\n6.  在初始点 $\\theta$ 处计算偏导数 $\\frac{\\partial \\text{PD}}{\\partial V}$、$\\frac{\\partial \\text{PD}}{\\partial \\sigma_V}$、$\\frac{\\partial \\text{PD}}{\\partial F}$ 和 $\\frac{\\partial \\text{PD}}{\\partial \\tau}$。\n7.  使用推导出的公式计算四个贡献项 $C_V$、$C_{\\sigma}$、$C_F$ 和 $C_{\\text{time}}$。\n8.  计算近似误差为 $\\left(C_V + C_{\\sigma} + C_F + C_{\\text{time}}\\right) - \\Delta \\text{PD}_{\\text{exact}}$。\n所有计算将使用 `numpy` 和 `scipy.stats` 库中的函数以确保数值精度。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef calculate_pd_and_sensitivities(V, sigma_V, F, tau, r):\n    \"\"\"\n    Calculates the probability of default (PD) and its first-order partial derivatives\n    (sensitivities) with respect to V, sigma_V, F, and tau, based on the Merton model.\n\n    Args:\n        V (float): Firm's asset value.\n        sigma_V (float): Asset volatility.\n        F (float): Face value of debt.\n        tau (float): Time to maturity.\n        r (float): Risk-free rate.\n\n    Returns:\n        tuple: A tuple containing:\n            - pd (float): Probability of default.\n            - pd_V (float): Partial derivative of PD w.r.t. V.\n            - pd_sigma (float): Partial derivative of PD w.r.t. sigma_V.\n            - pd_F (float): Partial derivative of PD w.r.t. F.\n            - pd_tau (float): Partial derivative of PD w.r.t. tau.\n    \"\"\"\n    if tau <= 1e-9:\n        pd = 1.0 if V < F else 0.0\n        return pd, 0.0, 0.0, 0.0, 0.0\n\n    sqrt_tau = np.sqrt(tau)\n    sigma_sqrt_tau = sigma_V * sqrt_tau\n    \n    d1 = (np.log(V / F) + (r + 0.5 * sigma_V**2) * tau) / sigma_sqrt_tau\n    d2 = d1 - sigma_sqrt_tau\n    \n    pd = norm.cdf(-d2)\n    \n    pdf_d2 = norm.pdf(d2)\n    \n    pd_V = -pdf_d2 / (V * sigma_sqrt_tau)\n    \n    pd_sigma = pdf_d2 * d1 / sigma_V\n    \n    pd_F = pdf_d2 / (F * sigma_sqrt_tau)\n    \n    d2_tau_deriv = (r - 0.5 * sigma_V**2) / (sigma_V * sqrt_tau) - d2 / (2 * tau)\n    pd_tau = -pdf_d2 * d2_tau_deriv\n    \n    return pd, pd_V, pd_sigma, pd_F, pd_tau\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single test case for PD decomposition.\n\n    Args:\n        params (tuple): A tuple of parameters (V, sigma_V, F, tau, r, dV, d_sigma, dF, dt).\n\n    Returns:\n        list: A list of six floats rounded to eight decimal places.\n    \"\"\"\n    V, sigma_V, F, tau, r, dV, d_sigma, dF, dt = params\n\n    pd_initial, pd_V, pd_sigma, pd_F, pd_tau = calculate_pd_and_sensitivities(V, sigma_V, F, tau, r)\n    \n    C_V = pd_V * dV\n    C_sigma = pd_sigma * d_sigma\n    C_F = pd_F * dF\n    C_time = pd_tau * (-dt)\n    \n    V_new = V + dV\n    sigma_V_new = sigma_V + d_sigma\n    F_new = F + dF\n    tau_new = tau - dt\n    \n    pd_final = calculate_pd_and_sensitivities(V_new, sigma_V_new, F_new, tau_new, r)[0]\n    \n    delta_pd_exact = pd_final - pd_initial\n    \n    total_approximation = C_V + C_sigma + C_F + C_time\n    \n    approximation_error = total_approximation - delta_pd_exact\n    \n    return [\n        round(delta_pd_exact, 8),\n        round(C_V, 8),\n        round(C_sigma, 8),\n        round(C_F, 8),\n        round(C_time, 8),\n        round(approximation_error, 8)\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        # (V, sigma_V, F, tau, r, dV, d_sigma, dF, dt)\n        (100.0, 0.25, 80.0, 1.0, 0.03, 0.5, 0.01, 0.2, 0.01),\n        (100.0, 0.30, 100.0, 0.5, 0.02, -1.0, -0.02, 0.0, 0.02),\n        (70.0, 0.20, 100.0, 2.0, 0.05, 0.0, 0.03, -1.0, 0.1),\n        (95.0, 0.35, 100.0, 0.05, 0.01, 0.0, 0.0, 0.0, 0.01),\n        (100.0, 0.05, 90.0, 1.5, 0.02, -0.5, 0.0, 0.0, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        result_case = solve_case(case)\n        results.append(result_case)\n\n    case_strings = []\n    for res_list in results:\n        case_str = f\"[{','.join(map(str, res_list))}]\"\n        case_strings.append(case_str)\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "基础 Merton 模型假设公司只有在债务到期时才会发生违约，但这在现实中并非总是如此。本练习通过引入一个战略性提前违约的选择来扩展该模型，当公司的持续经营价值（股权价值减去运营成本）变为负数时，股东会理性地选择放弃公司。这个实践将引导你理解内生性违约决策，这是更高级结构化模型的关键特征，同时它也连接了或有要求权分析与战略性公司金融的理论。[@problem_id:2435122]", "id": "2435122", "problem": "考虑一家公司，其资本结构由单一类别的零息债券和股东持有的股权构成。该零息债券的面值为 $F$，到期日为 $T$ 时刻，股东享有有限责任。在风险中性测度下，公司资产价值 $V_t$ 服从几何布朗运动，其中无风险利率 $r$ 和波动率 $\\sigma$ 为常数，时间 $t \\in [0,T]$。在决策时刻 $t<T$，股东可以选择立即违约（策略性提前违约），或者继续经营直至 $T$ 时刻。如果股东在 $t$ 时刻立即违约，他们将获得 $0$。如果他们选择继续经营，则必须承担一个确定性的经营负担，该负担被建模为在 $[t,T]$ 时间段内单位时间为 $k$ 的恒定成本流，并且在风险中性定价下以利率 $r$ 进行贴现。假设在 $t$ 时刻违约时股权无回收价值，债券无中期付息，市场为无摩擦市场，并且在基准结构模型中（无策略性行为时）违约仅在 $T$ 时刻发生。\n\n根据 Merton 模型的结构化方法，在 $t$ 时刻的股权价值等于一项以公司资产为标的物的期权价值。在理性预期和风险中性定价的假设下，股东会将继续经营价值与立即违约价值进行比较。在 $t$ 时刻的继续经营价值，是指 $t$ 时刻股权的风险中性现值（由 Merton 框架所隐含）减去 $[t,T]$ 时间段内恒定成本流 $k$ 在 $t$ 时刻的现值。在 $t$ 时刻的立即违约价值为 $0$。股东仅在继续经营价值严格小于 $0$ 时选择在 $t$ 时刻提前违约；若二者相等，则股东持无差异态度，但为完成本任务，你必须选择继续经营。所有时间均以年为单位，所有利率（如 $r$）均须视为小数（例如，百分之五为 $0.05$），所有货币量（$V$、$F$、$k$）均须使用统一的货币单位。角度单位不适用。\n\n你的任务是编写一个完整的、可运行的程序。对于给定的一系列参数元组 $(V,F,r,\\sigma,t,T,k)$，程序需要根据以下规则为每个元组判断理性股东在 $t$ 时刻是选择立即违约（输出布尔值 $True$）还是继续经营（输出布尔值 $False$）：仅当继续经营价值 $<0$ 时提前违约，否则继续经营。在 $[t,T]$ 时间段内，利率为 $r$ 的恒定成本流 $k$ 在 $t$ 时刻的现值，必须根据第一性原理计算为 $r$、$k$、$t$ 和 $T$ 的函数；请注意，当 $r=0$ 时，该计算简化为一个极限情况。\n\n测试用例：\n- 案例 1： $(V,F,r,\\sigma,t,T,k) = (80,100,0.03,0.2,0,1,0)$。\n- 案例 2： $(V,F,r,\\sigma,t,T,k) = (60,100,0.05,0.25,0,1,20)$。\n- 案例 3： $(V,F,r,\\sigma,t,T,k) = (100,100,0.02,0.2,0.5,1.0,12.3)$。\n- 案例 4： $(V,F,r,\\sigma,t,T,k) = (90,100,0.0,0.3,0.0,1.5,5.0)$。\n- 案例 5： $(V,F,r,\\sigma,t,T,k) = (70,100,0.03,0.8,0.0,2.0,5.0)$。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，结果的顺序与测试用例相同，列表中的每个条目都是一个布尔值，表示对应案例下在 $t$ 时刻的最优决策。例如，输出格式必须为 $[result_1,result_2,result_3,result_4,result_5]$，其中每个 $result_i \\in \\{\\text{True},\\text{False}\\}$。", "solution": "所述问题是有效的。它在科学上基于金融经济学的既定原则，特别是 Merton 开创的信用风险结构模型。该问题是适定的，提供了所有必要的参数和明确的决策标准。它没有矛盾、主观陈述和非形式化元素。因此，我们可以直接进行求解。\n\n问题的核心是通过比较继续经营的价值与立即违约的价值，来确定股东在 $t$ 时刻的最优行动。立即违约的价值给定为 $0$。决策规则是当且仅当继续经营价值严格小于 $0$ 时违约。\n\n在 $t$ 时刻的继续经营价值，记为 $CV_t$，是股东在 $t$ 时刻的股权价值 $E_t$ 减去未来经营负担的现值，我们将其记为 $P_k(t,T)$。\n$$ CV_t = E_t - P_k(t,T) $$\n股东在 $t$ 时刻的最优行动是：如果 $CV_t < 0$，则违约；如果 $CV_t \\geq 0$，则继续经营。\n\n第一个组成部分，即股权价值 $E_t$，源自 Merton 模型。在此框架下，股权等同于一项以公司总资产价值 $V_t$ 为标的物的欧式看涨期权。该期权的执行价格是债券的面值 $F$，到期时间是距离债券到期的剩余时间 $\\tau = T-t$。此看涨期权的价值由 Black-Scholes-Merton 公式给出：\n$$ E_t = V_t N(d_1) - F e^{-r(T-t)} N(d_2) $$\n其中 $N(\\cdot)$ 是标准正态分布的累积分布函数（CDF），参数 $d_1$ 和 $d_2$ 定义如下：\n$$ d_1 = \\frac{\\ln(V_t/F) + (r + \\frac{1}{2}\\sigma^2)(T-t)}{\\sigma \\sqrt{T-t}} $$\n$$ d_2 = d_1 - \\sigma \\sqrt{T-t} = \\frac{\\ln(V_t/F) + (r - \\frac{1}{2}\\sigma^2)(T-t)}{\\sigma \\sqrt{T-t}} $$\n\n第二个组成部分是经营成本的现值 $P_k(t,T)$。公司在 $[t,T]$ 区间内承受单位时间为 $k$ 的恒定成本流。在风险中性定价下，该成本流在 $t$ 时刻的现值通过对贴现后的成本流进行积分计算得出：\n$$ P_k(t,T) = \\int_{t}^{T} k e^{-r(s-t)} ds $$\n该积分的求值取决于无风险利率 $r$。\n对于无风险利率不为零的情况，即 $r > 0$，该积分的计算结果为：\n$$ P_k(t,T) = \\frac{k}{r} \\left( 1 - e^{-r(T-t)} \\right) $$\n对于无风险利率为零的特殊情况，即 $r=0$，被积函数中的指数项变为 $1$，积分简化为：\n$$ P_k(t,T) = \\int_{t}^{T} k \\, ds = k(T-t) $$\n这个 $r=0$ 的结果也可以通过对 $r > 0$ 的表达式应用洛必达法则求 $r \\to 0$ 时的极限来验证。\n\n对于给定的一组参数 $(V, F, r, \\sigma, t, T, k)$，解决该问题的算法步骤如下：\n$1$. 计算到期时间 $\\tau = T-t$。\n$2$. 使用给定的值计算参数 $d_1$ 和 $d_2$。\n$3$. 使用数值库函数计算标准正态累积分布函数 $N(d_1)$ 和 $N(d_2)$。\n$4$. 使用 Black-Scholes-Merton 公式计算股权价值 $E_t$。\n$5$. 计算成本流的现值 $P_k(t,T)$，确保对于 $r=0$ 与 $r > 0$ 的情况使用正确的公式。\n$6$. 计算继续经营价值 $CV_t = E_t - P_k(t,T)$。\n$7$. 如果 $CV_t < 0$，返回 `True`（代表违约），否则返回 `False`（代表继续经营）。\n\n这个结构化的步骤被转化为一个 Python 程序，用于对指定的测试用例进行数值评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves for the optimal shareholder decision (default or continue) for\n    a series of test cases based on a modified Merton model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format: (V, F, r, sigma, t, T, k)\n    test_cases = [\n        (80, 100, 0.03, 0.2, 0, 1, 0),\n        (60, 100, 0.05, 0.25, 0, 1, 20),\n        (100, 100, 0.02, 0.2, 0.5, 1.0, 12.3),\n        (90, 100, 0.0, 0.3, 0.0, 1.5, 5.0),\n        (70, 100, 0.03, 0.8, 0.0, 2.0, 5.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        V, F, r, sigma, t, T, k = case\n        decision = should_default_early(V, F, r, sigma, t, T, k)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    # The str() of a Python boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef should_default_early(V, F, r, sigma, t, T, k):\n    \"\"\"\n    Determines if shareholders should default early based on continuation value.\n\n    Args:\n        V (float): Firm's asset value at time t.\n        F (float): Face value of zero-coupon debt.\n        r (float): Constant risk-free rate.\n        sigma (float): Constant volatility of asset value.\n        t (float): Decision time.\n        T (float): Debt maturity time.\n        k (float): Constant cost flow rate.\n\n    Returns:\n        bool: True if default is optimal, False if continuation is optimal.\n    \"\"\"\n    time_to_maturity = T - t\n\n    # In the problem, t < T, so time_to_maturity > 0.\n    # No need to handle time_to_maturity <= 0 edge cases.\n\n    # 1. Calculate Equity Value (E_t) using Black-Scholes-Merton formula\n    # The problem constraints ensure sigma > 0 and time_to_maturity > 0,\n    # so the denominator is non-zero.\n    \n    sigma_sqrt_tau = sigma * np.sqrt(time_to_maturity)\n    \n    # Check for V > 0 to avoid math domain error with log, which is a reasonable assumption.\n    if V <= 0:\n      # If asset value is zero, equity value is zero.\n      equity_value = 0.0\n    else:\n      d1 = (np.log(V / F) + (r + 0.5 * sigma**2) * time_to_maturity) / sigma_sqrt_tau\n      d2 = d1 - sigma_sqrt_tau\n      \n      N_d1 = norm.cdf(d1)\n      N_d2 = norm.cdf(d2)\n      \n      equity_value = V * N_d1 - F * np.exp(-r * time_to_maturity) * N_d2\n\n    # 2. Calculate Present Value of Costs (PV_costs)\n    if r == 0.0:\n        pv_costs = k * time_to_maturity\n    else:\n        pv_costs = (k / r) * (1 - np.exp(-r * time_to_maturity))\n\n    # 3. Calculate Continuation Value (CV_t)\n    continuation_value = equity_value - pv_costs\n\n    # 4. Decision Rule: Default if Continuation Value is strictly negative.\n    return continuation_value < 0\n\nsolve()\n```"}]}