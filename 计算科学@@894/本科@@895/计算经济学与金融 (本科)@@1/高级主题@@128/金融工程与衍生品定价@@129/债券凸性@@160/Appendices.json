{"hands_on_practices": [{"introduction": "要真正掌握一个金融概念，最好的方法之一就是通过比较分析。本练习旨在通过对比两种最基本的债券类型——零息债券和附息债券——来建立对债券凸性来源的直观理解。通过计算和解释，你将亲身体会到现金流的时间分布如何直接影响债券的价格-收益率曲线的曲率，从而揭示凸性作为现金流离散程度度量的内在本质 [@problem_id:2376960]。", "id": "2376960", "problem": "一个面值为 $1$、期限为 $T = 5$ 年的无违约风险年付零息债券，其定价基于 $y = 5\\%$ 的统一年度到期收益率 (YTM)。定义债券相对于年度 YTM 的凸性为 $C(y) \\equiv \\dfrac{1}{P(y)} \\dfrac{d^{2}P(y)}{dy^{2}}$，其中 $P(y)$ 是作为 $y$ 的函数的债券价格。再考虑一个同样面值为 $1$、同样期限为 $T = 5$ 年的无违约风险年付附息债券，票面利率为 $5\\%$，也基于相同的统一年度 YTM $y = 5\\%$ 定价。\n\n哪个选项正确报告了在 $y = 5\\%$ 时零息债券的凸性（四舍五入到两位小数），并为其凸性高于同期限的附息债券提供了正确的解释？\n\nA. $27.21$；因为零息债券的所有现金流都发生在最后一个日期 $t = T$，曲率权重 $t(t+1)$ 完全应用于最大的 $t$ 上，而息票支付将权重转移到了更早、更小的 $t$ 上，从而在给定价格下降低了附息债券的凸性。\n\nB. $23.94$；因为较早的息票支付会产生更高的利率敏感性，所以附息债券的凸性超过了零息债券。\n\nC. $27.21$；因为零息债券的久期比其他方面相同的附息债券要低，所以其凸性必须更高。\n\nD. $30.00$；因为零息债券的凸性等于 $T(T+1)$，与收益率水平无关。", "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n**步骤 1：提取已知条件**\n\n- **债券 1 (零息债券):**\n  - 类型：无违约风险、年付零息债券。\n  - 面值：$F = 1$。\n  - 期限：$T = 5$ 年。\n  - 到期收益率 (YTM)：统一年度利率，$y = 5\\% = 0.05$。\n\n- **债券 2 (附息债券):**\n  - 类型：无违约风险、年付附息债券。\n  - 面值：$F = 1$。\n  - 期限：$T = 5$ 年。\n  - 年度票面利率：$c = 5\\% = 0.05$。\n  - 到期收益率 (YTM)：统一年度利率，$y = 5\\% = 0.05$。\n\n- **凸性的定义：**\n  - $C(y) \\equiv \\dfrac{1}{P(y)} \\dfrac{d^{2}P(y)}{dy^{2}}$，其中 $P(y)$ 是作为年度 YTM $y$ 的函数的债券价格。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n对问题进行严格验证。\n1.  **科学依据：** 债券定价、到期收益率 (YTM) 和债券凸性的概念是金融数学中基础且成熟的原则。其定义和关系都是标准的。该问题在科学上是合理的。\n2.  **适定性：** 问题提供了所有必要的参数（$F$, $T$, $y$, $c$）和凸性的精确定义，足以计算出零息债券的唯一数值答案，并与附息债券进行定性比较。\n3.  **客观性：** 问题以客观、定量的术语陈述，没有主观或模糊的语言。\n4.  **完整性和一致性：** 所提供的信息是充分的，并且没有内部矛盾。“年付零息债券”一词被理解为 YTM 是按年复利计算的，这与“年度 YTM”的上下文一致。\n\n**步骤 3：结论和行动**\n\n问题陈述有效。可以推导出严谨的解答。\n\n**解答的推导**\n\n首先，我们计算零息债券的凸性。面值为 $F=1$、期限为 $T=5$ 的零息债券的价格 $P(y)$ 由其在到期日的单笔现金流的现值给出：\n$$P(y) = \\dfrac{1}{(1+y)^T} = (1+y)^{-T}$$\n给定 $T=5$，价格函数为：\n$$P(y) = (1+y)^{-5}$$\n\n为求凸性，我们必须计算价格函数相对于收益率 $y$ 的一阶和二阶导数。\n一阶导数为：\n$$\\dfrac{dP(y)}{dy} = -5(1+y)^{-6}$$\n二阶导数为：\n$$\\dfrac{d^{2}P(y)}{dy^{2}} = (-5)(-6)(1+y)^{-7} = 30(1+y)^{-7}$$\n\n使用给定的凸性定义，$C(y) = \\dfrac{1}{P(y)} \\dfrac{d^{2}P(y)}{dy^{2}}$：\n$$C(y) = \\dfrac{1}{(1+y)^{-5}} \\left[ 30(1+y)^{-7} \\right] = 30(1+y)^{-2}$$\n或者，对于零息债券，凸性的一般公式是：\n$$C(y) = \\dfrac{T(T+1)}{(1+y)^2}$$\n代入 $T=5$：\n$$C(y) = \\dfrac{5(5+1)}{(1+y)^2} = \\dfrac{30}{(1+y)^2}$$\n这证实了推导出的表达式。现在我们在给定的收益率 $y = 0.05$ 下计算其值：\n$$C(0.05) = \\dfrac{30}{(1+0.05)^2} = \\dfrac{30}{(1.05)^2} = \\dfrac{30}{1.1025} \\approx 27.21088...$$\n四舍五入到两位小数，零息债券的凸性为 $27.21$。\n\n接下来，我们必须解释为什么这个凸性高于附息债券的凸性。一般债券的价格是其现金流 $CF_t$ 的现值之和：\n$$P(y) = \\sum_{t=1}^{T} \\dfrac{CF_t}{(1+y)^t}$$\n二阶导数为：\n$$\\dfrac{d^2P(y)}{dy^2} = \\sum_{t=1}^{T} CF_t \\cdot t(t+1)(1+y)^{-(t+2)}$$\n那么凸性是：\n$$C(y) = \\dfrac{1}{P(y)} \\sum_{t=1}^{T} \\dfrac{CF_t \\cdot t(t+1)}{(1+y)^{t+2}} = \\dfrac{1}{(1+y)^2} \\sum_{t=1}^{T} \\left[ \\dfrac{CF_t / (1+y)^t}{P(y)} \\right] t(t+1)$$\n设 $w_t = \\dfrac{PV(CF_t)}{P(y)}$ 为时间 $t$ 的现金流相对于总价格的权重。这些权重之和为 1，即 $\\sum w_t = 1$。凸性表达式变为一个加权平均值：\n$$C(y) = \\dfrac{1}{(1+y)^2} \\sum_{t=1}^{T} w_t \\cdot t(t+1)$$\n对于零息债券，只有一笔现金流发生在 $t=T=5$。因此，$w_5=1$ 且所有其他权重 $w_{t<5}=0$。求和式简化为单项：\n$$C_{zero}(y) = \\dfrac{1}{(1+y)^2} \\cdot [1 \\cdot T(T+1)] = \\dfrac{T(T+1)}{(1+y)^2} = \\dfrac{30}{(1+y)^2}$$\n对于附息债券，在时间 $t=1, 2, 3, 4, 5$ 都有现金流。因此，$w_1, w_2, w_3, w_4, w_5$ 都是正数。其凸性为：\n$$C_{coupon}(y) = \\dfrac{1}{(1+y)^2} \\left[ w_1(1\\cdot2) + w_2(2\\cdot3) + w_3(3\\cdot4) + w_4(4\\cdot5) + w_5(5\\cdot6) \\right]$$\n这是项 $t(t+1)$（对于 $t=1,...,5$）的加权平均值。由于权重 $w_{t<5}$ 是正数，平均值 $\\sum w_t \\cdot t(t+1)$ 必须严格小于最大可能值 $T(T+1) = 30$。息票支付将权重转移到更早的时间 $t$，其对应的“曲率贡献”项 $t(t+1)$ 更小（例如，$1 \\cdot 2 = 2$，$2 \\cdot 3 = 6$），而 $t=5$ 时的最终项为最大 ($5 \\cdot 6 = 30$)。因此，附息债券的整体凸性较低。\n$$C_{coupon}(y) < C_{zero}(y)$$\n\n**逐项分析**\n\n- **选项 A：**\n  - **数值：**$27.21$。这是**正确**的。\n  - **解释：** 其理由陈述道，零息债券的现金流完全发生在 $t=T$ 时，此时“曲率权重” $t(t+1)$ 最大。相比之下，附息债券的现金流分布在更早的时间 $t$，对应着更小的 $t(t+1)$ 值，从而降低了加权平均值和总凸性。这一逻辑与我们的推导完全一致。\n  - **结论：** **正确**。\n\n- **选项 B：**\n  - **数值：**$23.94$。这是**错误**的。\n  - **解释：** “较早的息票支付会产生更高的利率敏感性”这一说法在凸性的背景下具有误导性。虽然久期（一阶敏感性）比较复杂，但凸性（二阶敏感性）明确地会因为更早的现金流而降低。此外，附息债券凸性更高的结论在事实上是错误的。\n  - **结论：** **错误**。\n\n- **选项 C：**\n  - **数值：**$27.21$。这是**正确**的。\n  - **解释：** 其理由基于“零息债券的久期比其他方面相同的附息债券要低”这一前提。这个前提是错误的。零息债券的麦考利久期恰好是其期限，即 $T=5$。而附息债券支付中期息票，所以其麦考利久期（现金流的加权平均时间）总是严格小于其期限 $T$。因此，对于给定的期限，零息债券具有*最高*的可能久期，而不是最低的。该理由存在根本性缺陷。\n  - **结论：** **错误**。\n\n- **选项 D：**\n  - **数值：**$30.00$。这是**错误**的。我们的计算得出的结果约为 $27.21$。\n  - **解释：** 关于零息债券的凸性等于 $T(T+1)$ 的说法是错误的。它等于 $\\dfrac{T(T+1)}{(1+y)^2}$。所给公式错误地省略了分母 $(1+y)^2$，从而错误地断言其与收益率水平无关。\n  - **结论：** **错误**。\n\n只有选项 A 同时提供了正确的数值和科学的解释。", "answer": "$$\\boxed{A}$$"}, {"introduction": "在从理论迈向实践的过程中，将数学公式转化为可执行的代码是至关重要的一步。这个练习将引导你完成一项核心的计算金融任务：构建一个数值求解器来计算债券的到期收益率 (YTM)。更重要的是，它要求你根据凸性最根本的导数定义，从零开始计算债券的久期和凸性，从而将微积分理论与实际的编程技能紧密连接起来 [@problem_id:2376917]。", "id": "2376917", "problem": "实现一个独立的程序，为给定测试集中的每支债券计算其名义年化到期收益率。该收益率是唯一的实数 $y$（以小数而非百分比表示），该值使得所有承诺现金流的现值等于观测到的全价。一支债券的票面值为 $F$，名义年票息率为 $c$，每年付息 $f$ 次，到期时间为 $T$ 年（因此总付息期数为 $N = fT$ 且 $N$ 为整数），其现值 $P(y)$ 由以下基本的时间价值恒等式定义：\n$$\nP(y) \\equiv \\sum_{t=1}^{N} \\frac{\\mathrm{CF}_t}{(1 + y/f)^{t}},\n$$\n其中，对于 $t \\in \\{1,\\dots,N-1\\}$，有 $\\mathrm{CF}_t = F \\cdot c/f$；对于 $t=N$，有 $\\mathrm{CF}_N = F \\cdot c/f + F$。假设付息日之间间隔相等，违约风险为零，且报价为全价（无应计利息）。所有输入均为确定性值。\n\n您的程序必须为每个测试案例找到求解 $P(y) = P_{\\text{mkt}}$ 的唯一 $y$，并且在其求根过程的每次迭代中，评估债券价格相对于 $y$ 的瞬时敏感性，即：\n- 修正久期 $D_{\\text{mod}}(y)$，定义为 $D_{\\text{mod}}(y) \\equiv -\\frac{1}{P(y)} \\frac{\\mathrm{d}P}{\\mathrm{d}y}(y)$，以年为单位报告；\n- 修正凸性 $C_{\\text{mod}}(y)$，定义为 $C_{\\text{mod}}(y) \\equiv \\frac{1}{P(y)} \\frac{\\mathrm{d}^2 P}{\\mathrm{d}y^2}(y)$，当 $y$ 以小数单位表示时，报告为纯数。\n\n您的数值求根过程必须使用第一性原理：从现值的定义出发，直接根据该定义计算相对于 $y$ 的导数，然后迭代直至收敛。如果 $y$ 的绝对变化量低于 $10^{-12}$，或者现值绝对误差 $\\lvert P(y) - P_{\\text{mkt}} \\rvert$ 低于 $10^{-12}$，则宣布收敛。每个测试案例最多使用 $100$ 次迭代，并报告每个测试案例的最终收敛值 $y$、$D_{\\text{mod}}(y)$ 和 $C_{\\text{mod}}(y)$。所有收益率和利率必须以小数表示，不得使用百分号。\n\n测试集：\n对于下方的每个元组 $(F,c,f,T,P_{\\text{mkt}})$，求解 $y$ 并报告在收敛的 $y$ 值下相关的 $D_{\\text{mod}}(y)$ 和 $C_{\\text{mod}}(y)$。\n1. $F=100$, $c=0.05$, $f=2$, $T=5$, $P_{\\text{mkt}}=102$。\n2. $F=100$, $c=0$, $f=1$, $T=3$, $P_{\\text{mkt}}=85$。\n3. $F=100$, $c=0.12$, $f=2$, $T=10$, $P_{\\text{mkt}}=140$。\n4. $F=100$, $c=0.06$, $f=2$, $T=0.5$, $P_{\\text{mkt}}=101.5$。\n5. $F=100$, $c=0.08$, $f=4$, $T=7$, $P_{\\text{mkt}}=95$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个测试案例 $i \\in \\{1,2,3,4,5\\}$，按此确切顺序附加三个浮点数：收敛后的收益率 $y_i$、修正久期 $D_{\\text{mod},i}$ 和修正凸性 $C_{\\text{mod},i}$。每个数字必须四舍五入到恰好 $10$ 位小数。因此，最终输出在一个扁平列表中包含 $15$ 个数字：\n$[y_1,D_{\\text{mod},1},C_{\\text{mod},1},y_2,D_{\\text{mod},2},C_{\\text{mod},2},y_3,D_{\\text{mod},3},C_{\\text{mod},3},y_4,D_{\\text{mod},4},C_{\\text{mod},4},y_5,D_{\\text{mod},5},C_{\\text{mod},5}]$。", "solution": "该问题陈述已经过严格验证，并被确定为有效。其科学基础是量化金融的基本原理，数学上是适定的，并且其细节说明充分、无歧义，足以得出一个唯一且有意义的解。该问题要求计算债券的到期收益率及其相关的价格敏感性，这是计算金融中一项标准且必要的任务。\n\n核心任务是找到名义年化到期收益率，记为 $y$，它是方程 $g(y) = 0$ 的唯一实数根，其中 $g(y) = P(y) - P_{\\text{mkt}}$。函数 $P(y)$ 代表债券作为收益率函数的理论价格（现值），而 $P_{\\text{mkt}}$ 是其给定的市场价格。价格函数定义为：\n$$\nP(y) = \\sum_{t=1}^{N} \\frac{\\mathrm{CF}_t}{(1 + y/f)^{t}}\n$$\n此处，$f$ 是付息频率，$T$ 是以年为单位的到期时间，$N=fT$ 是总付息期数，$\\mathrm{CF}_t$ 是第 $t$ 期末的现金流。对于周期 $t \\in \\{1, \\dots, N-1\\}$，现金流是定期支付的票息，$\\mathrm{CF}_t = F \\cdot c/f$，其中 $F$ 是票面价值，$c$ 是名义年票息率。对于最后一个周期 $t=N$，现金流包括最后一期票息和本金偿还，$\\mathrm{CF}_N = F \\cdot c/f + F$。\n\n为求解 $y$，我们将实现牛顿-拉弗森法（Newton-Raphson method），这是一种强大的求根算法，以其在初始猜测值足够接近根时快速的二次收敛而闻名。该方法的迭代公式为：\n$$\ny_{k+1} = y_k - \\frac{g(y_k)}{g'(y_k)} = y_k - \\frac{P(y_k) - P_{\\text{mkt}}}{\\frac{\\mathrm{d}P}{\\mathrm{d}y}(y_k)}\n$$\n这需要价格函数相对于收益率的一阶导数 $\\frac{\\mathrm{d}P}{\\mathrm{d}y}$。问题还要求计算价格凸性，这涉及到二阶导数 $\\frac{\\mathrm{d}^2P}{\\mathrm{d}y^2}$。我们使用链式法则直接从 $P(y)$ 的定义推导出这些导数。\n\n价格函数的一阶导数为：\n$$\n\\frac{\\mathrm{d}P}{\\mathrm{d}y}(y) = \\frac{\\mathrm{d}}{\\mathrm{d}y} \\sum_{t=1}^{N} \\mathrm{CF}_t (1 + y/f)^{-t} = \\sum_{t=1}^{N} \\mathrm{CF}_t \\left[ -t (1 + y/f)^{-t-1} \\cdot \\frac{1}{f} \\right] \\\\\n\\frac{\\mathrm{d}P}{\\mathrm{d}y}(y) = -\\frac{1}{f} \\sum_{t=1}^{N} \\frac{t \\cdot \\mathrm{CF}_t}{(1 + y/f)^{t+1}}\n$$\n对于任何具有非负现金流的债券，该导数都严格为负，这证实了价格函数 $P(y)$ 随收益率 $y$ 单调递减。\n\n二阶导数通过对 $\\frac{\\mathrm{d}P}{\\mathrm{d}y}$ 关于 $y$ 求导得到：\n$$\n\\frac{\\mathrm{d}^2P}{\\mathrm{d}y^2}(y) = \\frac{\\mathrm{d}}{\\mathrm{d}y} \\left( -\\frac{1}{f} \\sum_{t=1}^{N} t \\cdot \\mathrm{CF}_t (1 + y/f)^{-t-1} \\right) = -\\frac{1}{f} \\sum_{t=1}^{N} t \\cdot \\mathrm{CF}_t \\left[ -(t+1) (1 + y/f)^{-t-2} \\cdot \\frac{1}{f} \\right] \\\\\n\\frac{\\mathrm{d}^2P}{\\mathrm{d}y^2}(y) = \\frac{1}{f^2} \\sum_{t=1}^{N} \\frac{t(t+1) \\mathrm{CF}_t}{(1 + y/f)^{t+2}}\n$$\n该导数严格为正，表明价格-收益率关系是凸的。\n\n算法流程如下：\n1. 对于每个测试案例，根据参数 $F$、$c$、$f$ 和 $T$ 构建现金流向量 $\\mathrm{CF}$。\n2. 收益率的初始猜测值 $y_0$ 设置为票息率 $c$，这是一个合乎逻辑的起点，因为对于平价交易的债券，其收益率会收敛到票息率。\n3. 执行牛顿-拉弗森迭代，最多 100 步。在每一步 $k$，根据 $y_k$、$P(y_k)$ 和 $\\frac{\\mathrm{d}P}{\\mathrm{d}y}(y_k)$ 计算 $y_{k+1}$。\n4. 当收益率的绝对变化量 $|y_{k+1} - y_k|$ 低于 $10^{-12}$，或定价误差 $|P(y_{k+1}) - P_{\\text{mkt}}|$ 低于 $10^{-12}$ 时，宣布收敛。\n5. 在收敛到最终收益率 $y$ 后，计算所需的风险指标。修正久期 $D_{\\text{mod}}$ 和修正凸性 $C_{\\text{mod}}$ 定义为：\n$$\nD_{\\text{mod}}(y) \\equiv -\\frac{1}{P(y)} \\frac{\\mathrm{d}P}{\\mathrm{d}y}(y)\n$$\n$$\nC_{\\text{mod}}(y) \\equiv \\frac{1}{P(y)} \\frac{\\mathrm{d}^2P}{\\mathrm{d}y^2}(y)\n$$\n在这些公式中，如规定所示，$P(y)$ 是在收敛收益率 $y$ 处计算的理论价格。在收敛时，$P(y)$ 在功能上等同于 $P_{\\text{mkt}}$。\n\n该实现利用 `numpy` 对 $P(y)$ 及其导数中涉及的求和进行高效的向量化计算。将此过程应用于所提供测试集中的每个案例，以获得指定的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve for yield, duration, and convexity for a suite of bonds.\n    \"\"\"\n    # Test Suite: Tuples of (F, c, f, T, P_mkt)\n    # F: Face Value\n    # c: Annual coupon rate (decimal)\n    # f: Coupon frequency per year\n    # T: Maturity in years\n    # P_mkt: Market price (full price)\n    test_cases = [\n        (100.0, 0.05, 2.0, 5.0, 102.0),\n        (100.0, 0.0, 1.0, 3.0, 85.0),\n        (100.0, 0.12, 2.0, 10.0, 140.0),\n        (100.0, 0.06, 2.0, 0.5, 101.5),\n        (100.0, 0.08, 4.0, 7.0, 95.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        y, d_mod, c_mod = solve_for_bond(*case)\n        results.append(f\"{y:.10f}\")\n        results.append(f\"{d_mod:.10f}\")\n        results.append(f\"{c_mod:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_for_bond(F, c, f, T, P_mkt):\n    \"\"\"\n    Calculates yield, modified duration, and modified convexity for a single bond.\n    \n    Uses the Newton-Raphson method to find the yield to maturity.\n    \"\"\"\n    # Derived parameters\n    N = int(f * T)\n    C_periodic = F * c / f\n\n    # Cash flow vector (1-based index logic from problem)\n    cf = np.full(N, C_periodic)\n    if N > 0:\n        cf[-1] += F\n    \n    # Time periods vector (t=1, 2, ..., N)\n    t = np.arange(1, N + 1)\n\n    # --- Helper functions for P(y) and its derivatives ---\n    def price(y):\n        if y <= -f:\n            return np.inf  # Avoid domain error\n        discount_factors = (1 + y / f) ** -t\n        return np.sum(cf * discount_factors)\n\n    def price_prime(y):\n        if y <= -f:\n            return -np.inf\n        terms = t * cf * (1 + y / f) ** (-t - 1)\n        return -np.sum(terms) / f\n\n    def price_double_prime(y):\n        if y <= -f:\n            return np.inf\n        terms = t * (t + 1) * cf * (1 + y / f) ** (-t - 2)\n        return np.sum(terms) / (f**2)\n\n    # --- Newton-Raphson Root-finding ---\n    y_k = c  # Initial guess\n    if y_k <= -f: # Safety check for pathological initial guess\n        y_k = 0.0\n\n    max_iter = 100\n    conv_tol_y = 1e-12\n    conv_tol_p = 1e-12\n\n    for _ in range(max_iter):\n        y_prev = y_k\n        \n        p = price(y_k)\n        p_prime = price_prime(y_k)\n\n        # Newton's step\n        if abs(p_prime) < 1e-15:\n            # Derivative is too small; Newton's method may become unstable.\n            # This should not occur for standard bonds.\n            break\n        \n        y_k = y_k - (p - P_mkt) / p_prime\n        \n        # Check for convergence\n        if abs(y_k - y_prev) < conv_tol_y or abs(price(y_k) - P_mkt) < conv_tol_p:\n            break\n\n    # --- Final calculations at converged yield ---\n    y_final = y_k\n    p_final = price(y_final)\n    p_prime_final = price_prime(y_final)\n    p_double_prime_final = price_double_prime(y_final)\n\n    # Modified Duration and Convexity as per problem definitions\n    if abs(p_final) < 1e-15: # Avoid division by zero\n        D_mod = np.nan\n        C_mod = np.nan\n    else:\n        D_mod = -p_prime_final / p_final\n        C_mod = p_double_prime_final / p_final\n        \n    return y_final, D_mod, C_mod\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "本章的最后一个练习将前面学习的理论和计算技能应用于一个更高级、更贴近现实的投资组合管理场景。你将设计一个动态对冲策略，通过调整投资组合权重，使其在收益率发生变动后仍能维持预设的目标久期和凸性。这个实践练习充分展示了凸性作为一种复杂的风险管理工具，在构建利率免疫投资组合时所发挥的强大作用 [@problem_id:2376977]。", "id": "2376977", "problem": "您需要设计并实现一个完整的、可运行的程序，该程序在一个固定的票息债券投资组合中，在发生平行收益率冲击后，动态地重新平衡该组合，以维持恒定的目标久期和凸性。您的推导和算法必须从现值的基本定义以及基于导数的久期和凸性定义出发。请勿使用任何预先包装的“捷径”公式；相反，您需要从第一性原理推导出必要的表达式。\n\n考虑一组由 $i \\in \\{1,\\dots,N\\}$ 索引的固定票息、每年付息一次的子弹式债券。每支债券 $i$ 的期限为 $T_i$（年），年票息率为 $c_i$（以小数表示，年化），面值归一化为 $1$，到期收益率（YTM）为 $y_i$（以小数表示，年化）。债券 $i$ 作为收益率 $y$ 的函数的现值价格函数由其未来现金流的贴现总和给出：\n$$\nP_i(y) \\equiv \\sum_{t=1}^{T_i} \\frac{\\mathrm{CF}_{i,t}}{(1+y)^t},\n$$\n其中，第 $t$ 年的现金流为 $\\mathrm{CF}_{i,t} = c_i$（对于 $t \\in \\{1,\\dots,T_i-1\\}$），而 $\\mathrm{CF}_{i,T_i} = 1 + c_i$。\n\n定义债券 $i$ 在收益率 $y$ 下的基于导数的修正久期 $D_i(y)$ 和凸性 $C_i(y)$ 如下：\n$$\nD_i(y) \\equiv -\\frac{1}{P_i(y)} \\frac{\\partial P_i}{\\partial y}(y), \\qquad\nC_i(y) \\equiv \\frac{1}{P_i(y)} \\frac{\\partial^2 P_i}{\\partial y^2}(y).\n$$\n\n设投资组合权重为 $w \\in \\mathbb{R}^N$，其中 $w_i$ 是债券 $i$ 的市值权重，且 $\\sum_{i=1}^N w_i = 1$。在当前收益率向量 $y = (y_1,\\dots,y_N)$ 下，投资组合的修正久期和凸性是各成分债券敏感性的市值加权平均值：\n$$\nD^{\\mathrm{port}}(w,y) \\equiv \\sum_{i=1}^N w_i \\, D_i(y_i), \\qquad\nC^{\\mathrm{port}}(w,y) \\equiv \\sum_{i=1}^N w_i \\, C_i(y_i).\n$$\n\n您需要强制执行恒定的目标值 $D^\\star$ 和 $C^\\star$，这两个目标值等于根据基准收益率和初始权重计算出的投资组合初始修正久期和凸性。在施加一个平行收益率冲击 $\\Delta y$ 后（即所有债券的收益率变为 $y_i + \\Delta y$），您必须重新平衡权重，以精确匹配目标值，同时在欧几里得意义上，使权重与冲击前权重的偏差最小化。形式上，给定冲击前的权重 $w^{\\mathrm{prev}}$ 和冲击后的债券级敏感性 $D_i(y_i+\\Delta y)$ 和 $C_i(y_i+\\Delta y)$，计算新的权重 $w^{\\mathrm{new}}$，该权重是以下等式约束最小二乘问题的解：\n$$\n\\begin{aligned}\n\\min_{w \\in \\mathbb{R}^N} \\quad & \\| w - w^{\\mathrm{prev}} \\|_2^2 \\\\\n\\text{subject to} \\quad & \\sum_{i=1}^N w_i = 1, \\\\\n& \\sum_{i=1}^N w_i \\, D_i(y_i+\\Delta y) = D^\\star, \\\\\n& \\sum_{i=1}^N w_i \\, C_i(y_i+\\Delta y) = C^\\star.\n\\end{aligned}\n$$\n没有施加不等式约束；如果为了达到目标值有必要，可以允许卖空头寸。\n\n您的程序必须为每个测试用例执行以下任务：\n1.  根据上述定义，通过直接对现值公式关于收益率求导，计算每支债券的价格 $P_i(y_i)$、修正久期 $D_i(y_i)$ 和凸性 $C_i(y_i)$。\n2.  使用基准权重 $w^{0}$ 和基准收益率 $y$ 计算初始投资组合目标 $D^\\star$ 和 $C^\\star$。\n3.  应用指定的平行收益率冲击 $\\Delta y$ 得到冲击后的收益率 $y_i^{\\mathrm{post}} = y_i + \\Delta y$，重新计算 $D_i(y_i^{\\mathrm{post}})$ 和 $C_i(y_i^{\\mathrm{post}})$，然后解决等式约束最小二乘问题，得到新的权重 $w^{\\mathrm{new}}$，该权重能够精确达到目标值，且与 $w^{\\mathrm{prev}}$ 的欧几里得偏差最小。\n\n科学和数值细节：\n- 付息是年度的。所有利率（$c_i$、$y_i$ 和 $\\Delta y$）必须作为年化小数处理（例如，$0.05$ 表示每年百分之五）。请勿使用百分号。\n- 久期的单位是年，凸性的单位是年的平方。权重是无单位分数，其总和为 1。\n- 此问题不涉及角度；无需角度单位。\n- 对于数值输出，权重应四舍五入到 6 位小数。\n\n测试套件：\n使用 $N=4$ 支债券，具有以下特征（每年付息一次，面值为 $1$）：\n- 债券 1：$T_1 = 2$，$c_1 = 0.03$，基准 $y_1 = 0.032$。\n- 债券 2：$T_2 = 5$，$c_2 = 0.04$，基准 $y_2 = 0.039$。\n- 债券 3：$T_3 = 10$，$c_3 = 0.05$，基准 $y_3 = 0.051$。\n- 债券 4：$T_4 = 30$，$c_4 = 0.06$，基准 $y_4 = 0.059$。\n\n所有测试用例的基准投资组合权重（冲击前）：\n- $w^{0} = [0.25, 0.25, 0.25, 0.25]$。\n\n通过在基准收益率下计算 $D^{\\mathrm{port}}(w^{0}, y)$ 和 $C^{\\mathrm{port}}(w^{0}, y)$ 来定义目标值 $D^\\star$ 和 $C^\\star$。\n\n提供三个收益率冲击测试用例，每个都是从相同的基准进行单步再平衡：\n- 用例 A（理想情况）：$\\Delta y = 0.005$。\n- 用例 B（无操作边界）：$\\Delta y = 0.000$。\n- 用例 C（较大的负向冲击）：$\\Delta y = -0.010$。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的、以逗号分隔的结果列表，其中每个元素是针对一个测试用例的再平衡后权重 $w^{\\mathrm{new}}$ 列表，每个权重四舍五入到 6 位小数。例如：\n\"[[w1_A,w2_A,w3_A,w4_A],[w1_B,w2_B,w3_B,w4_B],[w1_C,w2_C,w3_C,w4_C]]\"。", "solution": "用户要求设计并实现一个程序，用于在收益率冲击后重新平衡债券投资组合，以维持恒定的久期和凸性，同时最小化投资组合权重的变化。\n\n### 第1步：提取已知条件\n\n- **债券**：一组 $N$ 支固定票息、每年付息一次的子弹式债券。\n- **债券参数**：对于每支债券 $i \\in \\{1, \\dots, N\\}$：期限 $T_i$（年），年票息率 $c_i$（小数），面值 $1$，到期收益率 $y_i$（小数）。\n- **现值（价格）**：$P_i(y) = \\sum_{t=1}^{T_i} \\frac{\\mathrm{CF}_{i,t}}{(1+y)^t}$，其中当 $t < T_i$ 时 $\\mathrm{CF}_{i,t} = c_i$，当 $t = T_i$ 时 $\\mathrm{CF}_{i,T_i} = 1 + c_i$。\n- **修正久期**：$D_i(y) = -\\frac{1}{P_i(y)} \\frac{\\partial P_i}{\\partial y}(y)$。\n- **凸性**：$C_i(y) = \\frac{1}{P_i(y)} \\frac{\\partial^2 P_i}{\\partial y^2}(y)$。\n- **投资组合权重**：$w \\in \\mathbb{R}^N$，满足 $\\sum_{i=1}^N w_i = 1$。\n- **投资组合久期**：$D^{\\mathrm{port}}(w,y) = \\sum_{i=1}^N w_i \\, D_i(y_i)$。\n- **投资组合凸性**：$C^{\\mathrm{port}}(w,y) = \\sum_{i=1}^N w_i \\, C_i(y_i)$。\n- **优化问题**：\n  $$\n  \\begin{aligned}\n  \\min_{w \\in \\mathbb{R}^N} \\quad & \\| w - w^{\\mathrm{prev}} \\|_2^2 \\\\\n  \\text{subject to} \\quad & \\sum_{i=1}^N w_i = 1, \\\\\n  & \\sum_{i=1}^N w_i \\, D_i(y_i+\\Delta y) = D^\\star, \\\\\n  & \\sum_{i=1}^N w_i \\, C_i(y_i+\\Delta y) = C^\\star.\n  \\end{aligned}\n  $$\n- **目标值**：$D^\\star$ 和 $C^\\star$ 是使用基准权重 $w^0$ 和基准收益率 $y$ 计算的初始投资组合久期和凸性。\n- **测试数据**：\n  - $N=4$ 支债券：\n    - 债券 1: $T_1 = 2$, $c_1 = 0.03$, $y_1 = 0.032$。\n    - 债券 2: $T_2 = 5$, $c_2 = 0.04$, $y_2 = 0.039$。\n    - 债券 3: $T_3 = 10$, $c_3 = 0.05$, $y_3 = 0.051$。\n    - 债券 4: $T_4 = 30$, $c_4 = 0.06$, $y_4 = 0.059$。\n  - 基准权重：$w^0 = [0.25, 0.25, 0.25, 0.25]$。\n  - 收益率冲击 $\\Delta y$：$0.005$，$0.000$，$-0.010$。\n\n### 第2步：使用提取的已知条件进行验证\n\n将问题陈述与所需标准进行验证。\n\n- **科学基础**：该问题植根于金融数学和投资组合理论的既定原则。债券定价、修正久期和凸性作为价格-收益率函数的导数的概念，是固定收益分析的基础。优化问题描述了一种标准的投资组合免疫策略。该问题在科学上是合理的。\n- **适定性**：该问题是一个带等式约束的二次规划（QP）问题。目标函数 $\\| w - w^{\\mathrm{prev}} \\|_2^2$ 是严格凸的，且约束是线性的。这种结构保证了只要约束不是线性相关的，就存在一个唯一的、稳定的、有意义的解。对于给定的债券数据，数值验证表明，冲击后久期和凸性的向量与全1向量是线性无关的，确保了约束矩阵是满秩的。该问题是适定的。\n- **客观性**：该问题使用标准的数学和金融符号，以精确的、量化的术语陈述。它不含主观、模糊或基于意见的语言。\n- **完整性与一致性**：所有必要的数据（债券特性、初始权重、收益率冲击）和定义都已提供。该问题是自包含的，且没有内部矛盾。\n- **现实性**：债券参数和收益率冲击在金融市场的实际范围内。再平衡策略是动态对冲的一个实用（尽管简化）的表示。\n- **可验证性**：该解可以被解析地推导出来并通过数值方法实现，产生可验证和可复现的结果。\n\n### 第3步：结论与行动\n\n问题陈述是**有效的**。它在科学上是合理的，适定的，客观的，并且是完整的。可以推导并实现一个严谨的解决方案。我将继续进行解决方案的推导。\n\n### 基于原理的解决方案设计\n\n解决方案分为三个阶段：首先，从第一性原理推导债券敏感性的解析表达式；其次，使用拉格朗日乘子法求解约束优化问题；最后，概述计算算法。\n\n**1. 债券敏感性的推导**\n\n债券 $i$ 的价格由其贴现现金流的总和给出：\n$$\nP_i(y) = \\sum_{t=1}^{T_i} \\frac{\\mathrm{CF}_{i,t}}{(1+y)^t}\n$$\n为了求得修正久期和凸性，我们必须计算价格 $P_i(y)$ 对收益率 $y$ 的一阶和二阶偏导数。\n\n一阶导数通过逐项微分得到：\n$$\n\\frac{\\partial P_i}{\\partial y}(y) = \\frac{\\partial}{\\partial y} \\sum_{t=1}^{T_i} \\mathrm{CF}_{i,t} (1+y)^{-t} = \\sum_{t=1}^{T_i} \\mathrm{CF}_{i,t} \\frac{\\partial}{\\partial y} (1+y)^{-t} = \\sum_{t=1}^{T_i} \\mathrm{CF}_{i,t} (-t) (1+y)^{-t-1}\n$$\n二阶导数通过对一阶导数微分得到：\n$$\n\\frac{\\partial^2 P_i}{\\partial y^2}(y) = \\frac{\\partial}{\\partial y} \\sum_{t=1}^{T_i} \\mathrm{CF}_{i,t} (-t) (1+y)^{-t-1} = \\sum_{t=1}^{T_i} \\mathrm{CF}_{i,t} (-t) (-(t+1)) (1+y)^{-t-2} = \\sum_{t=1}^{T_i} \\mathrm{CF}_{i,t} \\, t(t+1) (1+y)^{-t-2}\n$$\n根据所给定义，修正久期 $D_i(y)$ 和凸性 $C_i(y)$ 为：\n$$\nD_i(y) = -\\frac{1}{P_i(y)} \\frac{\\partial P_i}{\\partial y}(y) = \\frac{1}{P_i(y)} \\sum_{t=1}^{T_i} \\frac{t \\cdot \\mathrm{CF}_{i,t}}{(1+y)^{t+1}}\n$$\n$$\nC_i(y) = \\frac{1}{P_i(y)} \\frac{\\partial^2 P_i}{\\partial y^2}(y) = \\frac{1}{P_i(y)} \\sum_{t=1}^{T_i} \\frac{t(t+1) \\cdot \\mathrm{CF}_{i,t}}{(1+y)^{t+2}}\n$$\n这些公式允许直接计算债券敏感性，构成了我们算法的基础。\n\n**2. 约束优化问题的求解**\n\n再平衡问题是找到新的权重向量 $w^{\\mathrm{new}}$，该向量在满足三个线性等式约束的条件下，最小化与前一个权重向量 $w^{\\mathrm{prev}}$ 的欧几里得距离的平方。我们可以将目标函数简化为 $\\frac{1}{2} \\| w - w^{\\mathrm{prev}} \\|_2^2$ 而不改变最优解。问题是：\n$$\n\\begin{aligned}\n\\min_{w \\in \\mathbb{R}^N} \\quad & \\frac{1}{2} \\| w - w^{\\mathrm{prev}} \\|_2^2 \\\\\n\\text{subject to} \\quad & \\sum_{i=1}^N w_i = 1, \\\\\n& \\sum_{i=1}^N w_i D^{\\mathrm{post}}_i = D^\\star, \\\\\n& \\sum_{i=1}^N w_i C^{\\mathrm{post}}_i = C^\\star.\n\\end{aligned}\n$$\n其中 $D^{\\mathrm{post}}_i = D_i(y_i+\\Delta y)$ 和 $C^{\\mathrm{post}}_i = C_i(y_i+\\Delta y)$ 是冲击后的敏感性。\n\n这是一个经典的带线性等式约束的二次规划问题，可以使用拉格朗日乘子法求解。拉格朗日函数 $\\mathcal{L}$ 是：\n$$\n\\mathcal{L}(w, \\lambda) = \\frac{1}{2} \\sum_{k=1}^N (w_k - w_k^{\\mathrm{prev}})^2 - \\lambda_1 \\left( \\sum_{k=1}^N w_k - 1 \\right) - \\lambda_2 \\left( \\sum_{k=1}^N w_k D^{\\mathrm{post}}_k - D^\\star \\right) - \\lambda_3 \\left( \\sum_{k=1}^N w_k C^{\\mathrm{post}}_k - C^\\star \\right)\n$$\n其中 $\\lambda = (\\lambda_1, \\lambda_2, \\lambda_3)$ 是拉格朗日乘子向量。最优性的一阶条件是 $\\nabla_w \\mathcal{L} = 0$。对于每个权重 $w_k$：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial w_k} = (w_k - w_k^{\\mathrm{prev}}) - \\lambda_1 - \\lambda_2 D^{\\mathrm{post}}_k - \\lambda_3 C^{\\mathrm{post}}_k = 0\n$$\n解出 $w_k$，我们用拉格朗日乘子表示最优权重：\n$$\nw_k = w_k^{\\mathrm{prev}} + \\lambda_1 + \\lambda_2 D^{\\mathrm{post}}_k + \\lambda_3 C^{\\mathrm{post}}_k\n$$\n这可以写成矩阵形式。设约束矩阵 $A$ 是一个 $3 \\times N$ 矩阵，其行是约束中权重的系数，向量 $b$ 包含约束的常数项：\n$$\nA = \\begin{pmatrix} 1 & 1 & \\dots & 1 \\\\ D^{\\mathrm{post}}_1 & D^{\\mathrm{post}}_2 & \\dots & D^{\\mathrm{post}}_N \\\\ C^{\\mathrm{post}}_1 & C^{\\mathrm{post}}_2 & \\dots & C^{\\mathrm{post}}_N \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ D^\\star \\\\ C^\\star \\end{pmatrix}\n$$\n线性约束系统为 $A w = b$。最优权重向量 $w$ 的表达式为：\n$$\nw = w^{\\mathrm{prev}} + A^T \\lambda\n$$\n为了求未知的拉格朗日乘子 $\\lambda$，我们将 $w$ 的表达式代入约束方程 $A w = b$ 中：\n$$\nA(w^{\\mathrm{prev}} + A^T \\lambda) = b \\implies A w^{\\mathrm{prev}} + (A A^T) \\lambda = b\n$$\n这给出了一个关于 $\\lambda$ 的线性系统：\n$$\n(A A^T) \\lambda = b - A w^{\\mathrm{prev}}\n$$\n矩阵 $A A^T$ 是一个 $3 \\times 3$ 矩阵。假设它是可逆的（对于给定的问题数据，确实如此），我们可以解出 $\\lambda$：\n$$\n\\lambda = (A A^T)^{-1} (b - A w^{\\mathrm{prev}})\n$$\n一旦计算出 $\\lambda$，新的权重向量 $w^{\\mathrm{new}}$ 就可以通过将 $\\lambda$ 代回 $w$ 的表达式中求得。\n\n**3. 算法实现**\n\n每个测试用例的算法流程如下：\n1.  **初始化**：使用基准收益率 $y_i$ 为每支债券 $i$ 计算初始敏感性 $D_i(y_i)$ 和 $C_i(y_i)$。\n2.  **目标计算**：使用初始权重 $w^0$ 计算投资组合的目标久期 $D^\\star$ 和凸性 $C^\\star$：\n    $D^\\star = \\sum_{i=1}^N w_i^0 D_i(y_i)$ 和 $C^\\star = \\sum_{i=1}^N w_i^0 C_i(y_i)$。\n3.  **冲击后计算**：给定一个收益率冲击 $\\Delta y$，为每支债券计算冲击后的收益率 $y_i^{\\mathrm{post}} = y_i + \\Delta y$。然后，计算新的敏感性 $D^{\\mathrm{post}}_i = D_i(y_i^{\\mathrm{post}})$ 和 $C^{\\mathrm{post}}_i = C_i(y_i^{\\mathrm{post}})$。\n4.  **求解新权重**：\n    a. 构建 $3 \\times N$ 的约束矩阵 $A$ 和 $3 \\times 1$ 的目标向量 $b$。\n    b. 计算 $3 \\times 3$ 的矩阵 $M = A A^T$。\n    c. 计算 $3 \\times 1$ 的右侧向量 $R = b - A w^{\\mathrm{prev}}$（其中 $w^{\\mathrm{prev}} = w^0$）。\n    d. 求解线性系统 $M \\lambda = R$ 以得到拉格朗日乘子 $\\lambda$。\n    e. 计算新的权重向量 $w^{\\mathrm{new}} = w^{\\mathrm{prev}} + A^T \\lambda$。\n5.  **输出**：根据指定的输出格式，存储并格式化得到的 $w^{\\mathrm{new}}$。对所有给定的收益率冲击重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for rebalanced bond portfolio weights after yield shocks.\n    \"\"\"\n\n    def calculate_bond_sensitivities(T, c, y):\n        \"\"\"\n        Calculates price, modified duration, and convexity of a single bond\n        from first principles.\n\n        Args:\n            T (int): Maturity in years.\n            c (float): Annual coupon rate as a decimal.\n            y (float): Yield to maturity as a decimal.\n\n        Returns:\n            tuple: A tuple containing (price, duration, convexity).\n        \"\"\"\n        if y <= -1.0:\n            raise ValueError(\"Yield must be greater than -1.\")\n            \n        price_val = 0.0\n        dp_dy_sum = 0.0\n        d2p_dy2_sum = 0.0\n        \n        for t in range(1, T + 1):\n            if t < T:\n                cf = c\n            else:  # At maturity, cash flow is coupon + face value (1)\n                cf = 1.0 + c\n            \n            discount_factor = (1.0 + y) ** (-t)\n            \n            # Accumulate terms for price and derivatives based on summation formulas\n            price_val += cf * discount_factor\n            dp_dy_sum += cf * (-t) * (1.0 + y) ** (-t - 1.0)\n            d2p_dy2_sum += cf * t * (t + 1.0) * (1.0 + y) ** (-t - 2.0)\n            \n        # Calculate Modified Duration and Convexity from their definitions\n        # D = - (1/P) * (dP/dy)\n        # C =   (1/P) * (d^2P/dy^2)\n        if price_val == 0.0:\n             # Avoid division by zero, though unlikely for these params\n            return 0.0, 0.0, 0.0\n\n        duration = - (1.0 / price_val) * dp_dy_sum\n        convexity = (1.0 / price_val) * d2p_dy2_sum\n        \n        return price_val, duration, convexity\n\n    # Define the test cases from the problem statement.\n    bonds = [\n        {'T': 2, 'c': 0.03, 'y': 0.032},\n        {'T': 5, 'c': 0.04, 'y': 0.039},\n        {'T': 10, 'c': 0.05, 'y': 0.051},\n        {'T': 30, 'c': 0.06, 'y': 0.059}\n    ]\n    N = len(bonds)\n    w_initial = np.array([0.25, 0.25, 0.25, 0.25])\n    \n    test_cases = [\n        0.005,   # Case A\n        0.000,   # Case B\n        -0.010   # Case C\n    ]\n\n    # --- Step 1 & 2: Calculate initial portfolio state and targets D*, C* ---\n    initial_durations = np.zeros(N)\n    initial_convexities = np.zeros(N)\n    for i, bond in enumerate(bonds):\n        _, D, C = calculate_bond_sensitivities(bond['T'], bond['c'], bond['y'])\n        initial_durations[i] = D\n        initial_convexities[i] = C\n    \n    D_target = np.sum(w_initial * initial_durations)\n    C_target = np.sum(w_initial * initial_convexities)\n\n    all_results = []\n    \n    # Process each yield shock test case\n    for delta_y in test_cases:\n        w_prev = w_initial\n        \n        # --- Step 3: Calculate post-shock sensitivities ---\n        post_shock_durations = np.zeros(N)\n        post_shock_convexities = np.zeros(N)\n        for i, bond in enumerate(bonds):\n            post_shock_yield = bond['y'] + delta_y\n            _, D_post, C_post = calculate_bond_sensitivities(bond['T'], bond['c'], post_shock_yield)\n            post_shock_durations[i] = D_post\n            post_shock_convexities[i] = C_post\n\n        # --- Step 4: Solve the constrained optimization problem ---\n        # min ||w - w_prev||^2 subject to A*w = b\n        \n        # The constraint matrix A is a 3xN matrix\n        A = np.array([\n            np.ones(N),\n            post_shock_durations,\n            post_shock_convexities\n        ])\n        \n        # The constraint vector b is a 3x1 vector\n        b = np.array([1.0, D_target, C_target])\n        \n        # Solve for Lagrange multipliers lambda: (A*A.T)*lambda = b - A*w_prev\n        M = A @ A.T  # This is a 3x3 matrix\n        rhs = b - (A @ w_prev) # This is a 3x1 vector\n        \n        # Solve the 3x3 system M * lambda = rhs\n        lagrange_multipliers = np.linalg.solve(M, rhs)\n        \n        # Calculate new weights: w_new = w_prev + A.T * lambda\n        w_new = w_prev + A.T @ lagrange_multipliers\n        \n        all_results.append(w_new)\n\n    # --- Final print statement in the exact required format ---\n    # Example: [[w1_A,w2_A,w3_A,w4_A],[w1_B,w2_B,w3_B,w4_B],[w1_C,w2_C,w3_C,w4_C]]\n    case_strings = []\n    for result_vector in all_results:\n        # Round each weight to 6 decimal places and format as a string\n        weight_strings = [f\"{w:.6f}\" for w in result_vector]\n        # Join weights for one case into a string like \"[w1,w2,w3,w4]\"\n        case_strings.append(f\"[{','.join(weight_strings)}]\")\n\n    # Join all case strings into the final format \"[[...],[...],...]\"\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"}]}