{"hands_on_practices": [{"introduction": "在 Black-Scholes-Merton 模型的理想世界中，我们可以为期权希腊字母推导出精确的解析公式。然而，在现实世界的金融建模中，我们经常会遇到无法解析求解的模型，或者需要验证解析解的正确性，这时数值方法就变得至关重要。本实践旨在通过比较有限差分法与解析法计算希腊字母，帮助您掌握这两种核心技术，并深入理解数值计算中步长 $h$ 的选择对结果精度和稳定性的影响 [@problem_id:2416913]。", "id": "2416913", "problem": "您需要编写一个完整且可运行的程序，在 Black–Scholes–Merton 模型下（假设无风险利率为连续复利且无股息），评估欧式看涨期权的解析敏感度（Greeks），并随着扰动大小 $h$ 趋近于零，将其与对称有限差分近似值进行比较。请遵循以下定义和约定。\n\n考虑一个欧式看涨期权，其标的资产价格 $S&gt;0$，行权价格 $K&gt;0$，无风险利率 $r\\in\\mathbb{R}$（以年化小数表示），波动率 $\\sigma&gt;0$（以年化小数表示），以及到期时间 $T&gt;0$（以年为单位）。在 Black–Scholes–Merton 模型下，期权价格 $C(S,K,r,\\sigma,T)$ 有明确定义，我们关注的希腊字母（相对于其自然变量）是：\n- Delta $\\Delta := \\frac{\\partial C}{\\partial S}$，\n- Gamma $\\Gamma := \\frac{\\partial^2 C}{\\partial S^2}$，\n- Vega $\\mathcal{V} := \\frac{\\partial C}{\\partial \\sigma}$，\n- Theta $\\Theta := \\frac{\\partial C}{\\partial T}$，其中 $T$ 表示到期时间（请注意，这是关于 $T$ 的导数，而不是关于日历时间的导数），\n- Rho $\\mathrm{P} := \\frac{\\partial C}{\\partial r}$。\n\n您的程序必须：\n- 对于每个参数元组 $(S,K,r,\\sigma,T)$，使用无股息的 Black–Scholes–Merton 框架计算 $\\Delta$、$\\Gamma$、$\\mathcal{V}$、$\\Theta$ 和 $\\mathrm{P}$ 的解析值。\n- 对于每个希腊字母，以及对于集合 $\\mathcal{H} = \\{10^{-1},10^{-2},10^{-3},10^{-4},10^{-5},10^{-6}\\}$ 中的每个扰动大小 $h$，当其有明确定义时，使用中心差分格式计算其定义变量的对称有限差分近似值。要使用的中心差分是：\n  - 对于 $\\Delta$ 和 $\\Gamma$，将 $S$ 扰动 $\\pm h$，\n  - 对于 $\\mathcal{V}$，将 $\\sigma$ 扰动 $\\pm h$，\n  - 对于 $\\Theta$，将 $T$ 扰动 $\\pm h$，\n  - 对于 $\\mathrm{P}$，将 $r$ 扰动 $\\pm h$。\n- 强制执行定义域约束，以使受扰动的参数保持在其定义域内。具体来说，仅当相应的正向和负向扰动能使参数保持在其有效定义域内时，才对某个希腊字母使用给定的 $h\\in\\mathcal{H}$。有效定义域为 $S\\pm h&gt;0$、$\\sigma\\pm h&gt;0$、$T\\pm h&gt;0$，而对 $r\\pm h$ 没有限制。\n- 对于每个可接受的 $h$，计算有限差分近似值与其解析希腊字母之间的绝对相对误差。如果解析值恰好等于 $0$，则将误差定义为绝对差。对于每个希腊字母，找出使此误差最小化的 $h\\in\\mathcal{H}$（在满足定义域约束的可接受值中）。如果在某个测试用例中，某个特定希腊字母没有可接受的 $h$，则报告一个非数值（non-number）。\n\n测试套件。您的程序必须对以下参数元组 $(S,K,r,\\sigma,T)$ 进行上述评估：\n- 情况 A（一般情况）：$(S,K,r,\\sigma,T)=(100,100,0.05,0.2,1)$。\n- 情况 B（短期限）：$(S,K,r,\\sigma,T)=(100,100,0.05,0.2,0.01)$。\n- 情况 C（深度实值）：$(S,K,r,\\sigma,T)=(150,100,0.05,0.3,1.5)$。\n- 情况 D（深度虚值，低波动率）：$(S,K,r,\\sigma,T)=(50,100,0.01,0.05,2)$。\n\n所有利率和波动率必须按小数处理（例如，使用 $0.05$ 而不是 $5$），时间 $T$ 必须以年为单位。\n\n要求的最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个包含五个浮点数的列表，顺序为 $[\\Delta,\\Gamma,\\mathcal{V},\\Theta,\\mathrm{P}]$，分别代表每个希腊字母在上述标准下使误差最小化的扰动大小 $h\\in\\mathcal{H}$（如果不存在可接受的 $h$，则为非数值）。因此，总体输出必须是一个包含四个此类列表的列表，其顺序与情况 A 到 D 的顺序相同。例如，打印的结构必须类似于 $[[h\\_{\\Delta}^{(A)},h\\_{\\Gamma}^{(A)},h\\_{\\mathcal{V}}^{(A)},h\\_{\\Theta}^{(A)},h\\_{\\mathrm{P}}^{(A)}],[h\\_{\\Delta}^{(B)},\\dots],[h\\_{\\Delta}^{(C)},\\dots],[h\\_{\\Delta}^{(D)},\\dots]]$，并用数值替换。", "solution": "该问题要求在 Black-Scholes-Merton (BSM) 框架内，实现并比较计算欧式看涨期权敏感度（即“Greeks”）的解析方法和数值方法。该问题的有效性得到了肯定，因为它基于金融数学和数值分析的基本原理。它定义明确、客观，并包含获得唯一解所需的所有信息。\n\n解决方案分三个阶段进行。首先，我们介绍期权价格及其相关希腊字母的解析公式。其次，我们定义用于数值近似的有限差分格式。最后，我们详细说明比较这些方法并为每种情况确定最佳数值步长 $h$ 的算法。\n\n**1. Black-Scholes-Merton 模型**\n\n对于不支付股息的标的资产，其欧式看涨期权的价格 $C$ 由 BSM 公式给出：\n$$\nC(S, K, r, \\sigma, T) = S N(d_1) - K e^{-rT} N(d_2)\n$$\n其中参数为：\n- $S$：标的资产的当前价格 $(S>0)$\n- $K$：期权的行权价格 $(K>0)$\n- $r$：连续复利无风险利率\n- $\\sigma$：标的资产回报的波动率 $(\\sigma>0)$\n- $T$：到期时间，以年为单位 $(T>0)$\n\n函数 $N(\\cdot)$、$d_1$ 和 $d_2$ 定义如下：\n- $N(x)$：标准正态分布的累积分布函数（CDF），$N(x) = \\int_{-\\infty}^{x} \\phi(z) dz$，其中 $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}}e^{-z^2/2}$ 是概率密度函数（PDF）。\n- $d_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}$\n- $d_2 = d_1 - \\sigma \\sqrt{T} = \\frac{\\ln(S/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}$\n\n**2. Greeks 的解析公式**\n\nGreeks 是期权价格 $C$ 相对于其参数的偏导数。问题中指定的 Greeks 的解析公式如下：\n\n- **Delta ($\\Delta$):** 期权价格相对于标的资产价格 $S$ 的变化率。\n$$\n\\Delta = \\frac{\\partial C}{\\partial S} = N(d_1)\n$$\n\n- **Gamma ($\\Gamma$):** Delta 相对于 $S$ 的变化率。它是 $C$ 相对于 $S$ 的二阶偏导数。\n$$\n\\Gamma = \\frac{\\partial^2 C}{\\partial S^2} = \\frac{\\phi(d_1)}{S\\sigma\\sqrt{T}}\n$$\n\n- **Vega ($\\mathcal{V}$):** 期权价格相对于波动率 $\\sigma$ 的变化率。\n$$\n\\mathcal{V} = \\frac{\\partial C}{\\partial \\sigma} = S\\phi(d_1)\\sqrt{T}\n$$\n\n- **Theta ($\\Theta$):** 期权价格相对于到期时间 $T$ 的变化率。根据指定，这是 $\\frac{\\partial C}{\\partial T}$，其符号与衡量日历时间流逝敏感度的传统 Theta 定义相反。\n$$\n\\Theta = \\frac{\\partial C}{\\partial T} = \\frac{S\\phi(d_1)\\sigma}{2\\sqrt{T}} + r K e^{-rT} N(d_2)\n$$\n\n- **Rho ($\\mathrm{P}$):** 期权价格相对于无风险利率 $r$ 的变化率。\n$$\n\\mathrm{P} = \\frac{\\partial C}{\\partial r} = K T e^{-rT} N(d_2)\n$$\n\n**3. 有限差分近似**\n\n我们采用对称有限差分格式来近似求导。对于函数 $f(x)$ 和一个小的扰动 $h$：\n\n- 一阶导数由中心差分公式近似：\n$$\nf'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h} \\quad (\\text{误差 } O(h^2))\n$$\n\n- 二阶导数由以下公式近似：\n$$\nf''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2} \\quad (\\text{误差 } O(h^2))\n$$\n\n将这些应用于期权价格函数 $C(\\cdot)$，可得到以下 Greeks 的近似值：\n\n- **Delta:** $\\Delta_{\\text{FD}}(h) = \\frac{C(S+h, \\dots) - C(S-h, \\dots)}{2h}$\n- **Gamma:** $\\Gamma_{\\text{FD}}(h) = \\frac{C(S+h, \\dots) - 2C(S, \\dots) + C(S-h, \\dots)}{h^2}$\n- **Vega:** $\\mathcal{V}_{\\text{FD}}(h) = \\frac{C(\\dots, \\sigma+h, \\dots) - C(\\dots, \\sigma-h, \\dots)}{2h}$\n- **Theta:** $\\Theta_{\\text{FD}}(h) = \\frac{C(\\dots, T+h) - C(\\dots, T-h)}{2h}$\n- **Rho:** $\\mathrm{P}_{\\text{FD}}(h) = \\frac{C(\\dots, r+h, \\dots) - C(\\dots, r-h, \\dots)}{2h}$\n\n**4. 算法流程**\n\n目标是找到集合 $\\mathcal{H} = \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}, 10^{-5}, 10^{-6}\\}$ 中的扰动大小 $h$，以最小化每个 Greek 的近似误差。\n\n对于每个测试用例 $(S,K,r,\\sigma,T)$ 和每个希腊字母 $G \\in \\{\\Delta, \\Gamma, \\mathcal{V}, \\Theta, \\mathrm{P}\\}$ 的算法如下：\n\n1.  **计算解析值：** 使用第 2 节中的公式计算真实值 $G_{\\text{analytical}}$。\n2.  **迭代与评估：** 对于每个 $h \\in \\mathcal{H}$：\n    a. **验证定义域：** 检查扰动是否有效。对于变量 $x \\in \\{S, \\sigma, T\\}$ 及其定义域 $x>0$，条件是 $x-h > 0$。如果不满足此条件，则当前的 $h$ 不可接受，应跳过。对于 $r$ 没有定义域约束。\n    b. **计算数值近似值：** 如果 $h$ 是可接受的，使用第 3 节中的公式计算有限差分近似值 $G_{\\text{FD}}(h)$。\n    c. **计算误差：** 计算误差。如果 $|G_{\\text{analytical}}| > \\epsilon$（其中 $\\epsilon$ 是一个很小的容差，如 $10^{-15}$），则使用绝对相对误差：\n    $$\n    \\text{Error}(h) = \\left| \\frac{G_{\\text{FD}}(h) - G_{\\text{analytical}}}{G_{\\text{analytical}}} \\right|\n    $$\n    否则，如果 $G_{\\text{analytical}} \\approx 0$，则使用绝对误差以避免除以零：\n    $$\n    \\text{Error}(h) = |G_{\\text{FD}}(h) - G_{\\text{analytical}}|\n    $$\n    d. **追踪最小值：** 将 $\\text{Error}(h)$ 与迄今为止找到的最小误差进行比较。如果更小，则将 $h$ 存储为当前最优的扰动大小。\n3.  **报告结果：** 遍历所有 $h \\in \\mathcal{H}$ 后，存储的最优 $h$ 即为希腊字母 $G$ 的结果。如果没有可接受的 $h$，则结果为非数值 (NaN)。\n\n对所有五个希腊字母和问题陈述中提供的所有四个测试用例重复此过程。最终的实现将此逻辑封装在一个 Python 脚本中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Evaluates optimal finite-difference bump sizes for Black-Scholes-Merton Greeks.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (S, K, r, sigma, T)\n        (100.0, 100.0, 0.05, 0.20, 1.0),\n        # Case B\n        (100.0, 100.0, 0.05, 0.20, 0.01),\n        # Case C\n        (150.0, 100.0, 0.05, 0.30, 1.5),\n        # Case D\n        (50.0, 100.0, 0.01, 0.05, 2.0)\n    ]\n\n    H_SET = [1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6]\n    \n    def bsm_call_price(S, K, r, sigma, T):\n        \"\"\"Calculates the BSM price of a European call option.\"\"\"\n        # For T=0, the option price is its intrinsic value.\n        # Use a small tolerance for floating point comparisons.\n        if T < 1e-9:\n            return max(0.0, S - K)\n        \n        # If other parameters are non-positive, price is 0. This is enforced\n        # by the domain constraint checks on h, but is good practice.\n        if S <= 0 or K <= 0 or sigma <= 0:\n            return 0.0\n\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    def analytical_greeks(S, K, r, sigma, T):\n        \"\"\"Calculates the analytical values of BSM Greeks.\"\"\"\n        # As per problem, T > 0, so no need to handle T=0 case separately here.\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n\n        phi_d1 = norm.pdf(d1)\n        cdf_d1 = norm.cdf(d1)\n        cdf_d2 = norm.cdf(d2)\n\n        delta = cdf_d1\n        gamma = phi_d1 / (S * sigma * np.sqrt(T))\n        vega = S * phi_d1 * np.sqrt(T)\n        # As per problem, Theta is dC/dT (time-to-maturity), not dC/dt (calendar time).\n        theta = (S * phi_d1 * sigma) / (2 * np.sqrt(T)) + r * K * np.exp(-r * T) * cdf_d2\n        rho = K * T * np.exp(-r * T) * cdf_d2\n\n        return {\n            'delta': delta, \n            'gamma': gamma, \n            'vega': vega, \n            'theta': theta, \n            'rho': rho\n        }\n\n    all_results = []\n    for S, K, r, sigma, T in test_cases:\n        case_results = []\n        greeks_ana = analytical_greeks(S, K, r, sigma, T)\n\n        # --- Delta and Gamma ---\n        min_error_delta, optimal_h_delta = float('inf'), np.nan\n        min_error_gamma, optimal_h_gamma = float('inf'), np.nan\n        ana_delta = greeks_ana['delta']\n        ana_gamma = greeks_ana['gamma']\n        price_0 = bsm_call_price(S, K, r, sigma, T)\n        for h in H_SET:\n            if S - h > 0:\n                price_p = bsm_call_price(S + h, K, r, sigma, T)\n                price_m = bsm_call_price(S - h, K, r, sigma, T)\n                \n                # Delta\n                approx_delta = (price_p - price_m) / (2 * h)\n                error_delta = abs((approx_delta - ana_delta) / ana_delta) if abs(ana_delta) > 1e-15 else abs(approx_delta - ana_delta)\n                if error_delta < min_error_delta:\n                    min_error_delta = error_delta\n                    optimal_h_delta = h\n                \n                # Gamma\n                approx_gamma = (price_p - 2 * price_0 + price_m) / (h**2)\n                error_gamma = abs((approx_gamma - ana_gamma) / ana_gamma) if abs(ana_gamma) > 1e-15 else abs(approx_gamma - ana_gamma)\n                if error_gamma < min_error_gamma:\n                    min_error_gamma = error_gamma\n                    optimal_h_gamma = h\n        case_results.extend([optimal_h_delta, optimal_h_gamma])\n        \n        # --- Vega ---\n        min_error_vega, optimal_h_vega = float('inf'), np.nan\n        ana_vega = greeks_ana['vega']\n        for h in H_SET:\n            if sigma - h > 0:\n                approx_vega = (bsm_call_price(S, K, r, sigma + h, T) - bsm_call_price(S, K, r, sigma - h, T)) / (2 * h)\n                error_vega = abs((approx_vega - ana_vega) / ana_vega) if abs(ana_vega) > 1e-15 else abs(approx_vega - ana_vega)\n                if error_vega < min_error_vega:\n                    min_error_vega = error_vega\n                    optimal_h_vega = h\n        case_results.append(optimal_h_vega)\n        \n        # --- Theta ---\n        min_error_theta, optimal_h_theta = float('inf'), np.nan\n        ana_theta = greeks_ana['theta']\n        for h in H_SET:\n            if T - h > 0:\n                approx_theta = (bsm_call_price(S, K, r, sigma, T + h) - bsm_call_price(S, K, r, sigma, T - h)) / (2 * h)\n                error_theta = abs((approx_theta - ana_theta) / ana_theta) if abs(ana_theta) > 1e-15 else abs(approx_theta - ana_theta)\n                if error_theta < min_error_theta:\n                    min_error_theta = error_theta\n                    optimal_h_theta = h\n        case_results.append(optimal_h_theta)\n        \n        # --- Rho ---\n        min_error_rho, optimal_h_rho = float('inf'), np.nan\n        ana_rho = greeks_ana['rho']\n        for h in H_SET:\n            # No domain constraint for r\n            approx_rho = (bsm_call_price(S, K, r + h, sigma, T) - bsm_call_price(S, K, r - h, sigma, T)) / (2 * h)\n            error_rho = abs((approx_rho - ana_rho) / ana_rho) if abs(ana_rho) > 1e-15 else abs(approx_rho - ana_rho)\n            if error_rho < min_error_rho:\n                min_error_rho = error_rho\n                optimal_h_rho = h\n        case_results.append(optimal_h_rho)\n        \n        all_results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "掌握了希腊字母的计算方法后，下一步是运用它们来构建具有特定风险特征的投资组合。本练习将指导您设计一个经典的期权策略——日历价差，其目标是创建一个对波动率 $\\sigma$ 的微小平行移动免疫（即 $Vega$ 中性）的投资组合，同时从底层资产价格的波动中获利（即正 $Gamma$）。通过这个实践，您将学会如何主动管理和构建多维度风险敞口，这是期权交易和风险管理的核心技能之一 [@problem_id:2416880]。", "id": "2416880", "problem": "给定一个无摩擦市场，其中单一标的资产的价格表示为 $S$。欧式期权在 Black–Scholes 框架下进行定价，该框架包含连续复利无风险利率 $r$、连续股息率 $q$ 和恒定波动率 $\\sigma$。所有到期时间 $T$ 均以年为单位。所有利率和波动率必须以小数形式表示，而非百分比形式。\n\n考虑一个由两份欧式看涨期权构成的投资组合，这两份期权基于相同的标的资产，具有相同的行权价 $K$，但到期日不同，分别为 $T_1$ 和 $T_2$，且 $T_1 \\lt T_2$。投资组合的权重定义如下：短期看涨期权（到期日为 $T_1$）的头寸固定为 $w_1 = 1$（一个多头单位），而长期看涨期权（到期日为 $T_2$）的头寸为 $w_2$（一个实数，可以为负）。关于波动率期限结构的微小平行移动，该投资组合的 Vega 定义为当两个期权的波动率都发生相同微小变化时，投资组合价值相对于 $\\sigma$ 的导数。投资组合的 Gamma 定义为投资组合价值相对于 $S$ 的二阶导数。\n\n您的任务是，对于下方的每个测试案例，确定唯一的权重 $w_2$，使得在给定的 $S$ 下投资组合的 Vega 恰好为零（即，在当前即期价格下，对于波动率期限结构的微小平行移动是 Vega 中性的），然后计算在该 $S$ 下由此产生的净 Gamma 和净 Vega。如果一个投资组合在 $S$ 处的净 Gamma 为正，则称其为“做多波动率”。\n\n实现一个完整的程序，该程序：\n- 从第一性原理出发，在 Black–Scholes 模型下计算每个成分期权的 Vega 和 Gamma。\n- 在 $w_1 = 1$ 的情况下，确定唯一的 $w_2$，使得在给定的 $S$ 下投资组合的净 Vega 等于零。\n- 在给定的 $S$ 下，评估该投资组合最终的净 Gamma 和净 Vega。\n\n使用以下参数集测试套件，每个参数集以元组 $(S,K,r,q,\\sigma,T_1,T_2)$ 的形式提供：\n- 测试 $1$：$(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$100\\,,\\,\\$100\\,,\\,0.02\\,,\\,0.00\\,,\\,0.20\\,,\\,0.25\\,,\\,1.00\\,)$。\n- 测试 $2$：$(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$50\\,,\\,\\$50\\,,\\,0.01\\,,\\,0.03\\,,\\,0.35\\,,\\,0.10\\,,\\,0.60\\,)$。\n- 测试 $3$：$(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$200\\,,\\,\\$200\\,,\\,0.00\\,,\\,0.05\\,,\\,0.15\\,,\\,0.05\\,,\\,0.50\\,)$。\n\n所需的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的浮点数列表。对于每个测试案例，按顺序包含三个值：$w_2$、净 Gamma 和净 Vega。测试案例的顺序与上方所列一致。所有数字必须四舍五入到 $10$ 位小数。例如，整体结构必须为 $[w_{2,1},\\Gamma_1,\\text{Vega}_1,w_{2,2},\\Gamma_2,\\text{Vega}_2,w_{2,3},\\Gamma_3,\\text{Vega}_3]$ 的形式，其中条目之间用逗号分隔，且无多余空格或文本。", "solution": "所给出的问题陈述是有效的。它在已建立的 Black–Scholes 模型框架内具有科学依据，在数学上是适定的，并且以客观、无歧义的语言表述。所有必要的参数均已提供，不存在内部矛盾。因此，我们可以进行严谨的求解。\n\n该问题要求构建一个由两份欧式看涨期权组成的 Vega 中性投资组合，然后确定其净 Gamma。这些期权的定价和风险计量由 Black–Scholes 模型决定。一份欧式看涨期权 $C$ 的价值取决于标的资产价格 $S$、行权价 $K$、到期时间 $T$、无风险利率 $r$、连续股息率 $q$ 和波动率 $\\sigma$。\n\n该模型的核心围绕项 $d_1$ 和 $d_2$ 展开，定义如下：\n$$ d_1 = \\frac{\\ln(S/K) + (r - q + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\n期权的 Gamma ($\\Gamma$) 衡量期权的 Delta 随标的资产价格 $S$ 变化的速率，其公式为：\n$$ \\Gamma = \\frac{\\partial^2 C}{\\partial S^2} = \\frac{e^{-qT}\\phi(d_1)}{S\\sigma\\sqrt{T}} $$\n期权的 Vega ($\\mathcal{V}$) 衡量期权价值对波动率 $\\sigma$ 变化的敏感度，其公式为：\n$$ \\mathcal{V} = \\frac{\\partial C}{\\partial \\sigma} = S e^{-qT} \\sqrt{T} \\phi(d_1) $$\n在这些公式中，$\\phi(x)$ 表示标准正态分布的概率密度函数 (PDF)，$\\phi(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$。\n\n该投资组合由两份欧式看涨期权组成，它们基于相同的标的资产，具有共同的行权价 $K$，但到期日不同，分别为 $T_1$ 和 $T_2$，且 $T_1 < T_2$。短期期权（到期日为 $T_1$）的权重固定为 $w_1 = 1$。长期期权（到期日为 $T_2$）的权重为 $w_2$。\n\n投资组合的净 Gamma ($\\Gamma_P$) 和净 Vega ($\\mathcal{V}_P$) 是各期权希腊字母的线性组合：\n$$ \\Gamma_P = w_1\\Gamma_1 + w_2\\Gamma_2 $$\n$$ \\mathcal{V}_P = w_1\\mathcal{V}_1 + w_2\\mathcal{V}_2 $$\n此处，$(\\Gamma_1, \\mathcal{V}_1)$ 是到期日为 $T_1$ 的期权的希腊字母，而 $(\\Gamma_2, \\mathcal{V}_2)$ 是到期日为 $T_2$ 的期权的希腊字母。\n\n主要目标是使投资组合达到 Vega 中性，即将其净 Vega 设置为零。给定 $w_1 = 1$，我们施加以下条件：\n$$ \\mathcal{V}_P = 1 \\cdot \\mathcal{V}_1 + w_2\\mathcal{V}_2 = 0 $$\n对于任何 $T > 0$ 的欧式期权，其 Vega ($\\mathcal{V}$) 恒为正。由于 $T_1$ 和 $T_2$ 均为正，因此 $\\mathcal{V}_2 > 0$，我们可以唯一地解出权重 $w_2$：\n$$ w_2 = -\\frac{\\mathcal{V}_1}{\\mathcal{V}_2} $$\n这个权重 $w_2$ 代表为对冲一个多头单位的短期看涨期权的 Vega，必须做空的长期看涨期权的数量。\n\n一旦确定了 $w_2$，我们就可以计算这个 Vega 中性投资组合的净 Gamma：\n$$ \\Gamma_P = \\Gamma_1 + w_2\\Gamma_2 = \\Gamma_1 - \\left(\\frac{\\mathcal{V}_1}{\\mathcal{V}_2}\\right)\\Gamma_2 $$\n根据构造，该投资组合的净 Vega 定义上恰好为零。由于浮点精度限制，数值计算可能会得到一个接近零的值，这是一个预料之中的结果。\n\n算法流程如下：\n$1$. 对于测试套件中的每一组参数 $(S, K, r, q, \\sigma, T_1, T_2)$，我们将首先计算这两个期权各自的 Gamma 和 Vega。这包括计算各自的 $d_1$ 项，然后应用 $\\Gamma$ 和 $\\mathcal{V}$ 公式。\n$2$. 使用计算出的 Vega 值 $\\mathcal{V}_1$ 和 $\\mathcal{V}_2$，我们确定权重 $w_2 = -\\mathcal{V}_1 / \\mathcal{V}_2$。\n$3$. 接着，我们计算投资组合的净 Gamma，$\\Gamma_P = \\Gamma_1 + w_2\\Gamma_2$。\n$4$. 我们将计算由此产生的净 Vega，$\\mathcal{V}_P = \\mathcal{V}_1 + w_2\\mathcal{V}_2$，以确认其为零。\n$5$. 然后为每个测试案例存储三元组 $(w_2, \\Gamma_P, \\mathcal{V}_P)$。\n$6$. 最后，收集所有结果，按要求的精度进行格式化，并以指定的单行格式打印。\n此过程将通过一个独立的 Python 程序实现，利用 `numpy` 进行数值计算，并利用 `scipy.stats.norm` 计算标准正态分布的概率密度函数 (PDF)。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the weight w2 for a Vega-neutral portfolio of two European call options,\n    and the resulting portfolio's net Gamma and net Vega.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S, K, r, q, sigma, T1, T2)\n        (100.0, 100.0, 0.02, 0.00, 0.20, 0.25, 1.00),\n        (50.0, 50.0, 0.01, 0.03, 0.35, 0.10, 0.60),\n        (200.0, 200.0, 0.00, 0.05, 0.15, 0.05, 0.50),\n    ]\n\n    results = []\n\n    def calculate_greeks(S, K, T, r, q, sigma):\n        \"\"\"\n        Calculates the Gamma and Vega of a European call option using Black-Scholes formulas.\n\n        Args:\n            S (float): Spot price of the underlying asset.\n            K (float): Strike price of the option.\n            T (float): Time to maturity in years.\n            r (float): Risk-free interest rate (decimal).\n            q (float): Continuous dividend yield (decimal).\n            sigma (float): Volatility of the underlying asset (decimal).\n\n        Returns:\n            tuple: A tuple containing the option's Gamma and Vega.\n        \"\"\"\n        # Ensure T > 0 to avoid division by zero\n        if T <= 0:\n            return 0.0, 0.0\n\n        sigma_sqrt_T = sigma * np.sqrt(T)\n        \n        # d1 calculation\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma**2) * T) / sigma_sqrt_T\n        \n        # Standard normal probability density function (PDF)\n        phi_d1 = norm.pdf(d1)\n        \n        # Gamma formula\n        gamma = np.exp(-q * T) * phi_d1 / (S * sigma_sqrt_T)\n        \n        # Vega formula\n        vega = S * np.exp(-q * T) * np.sqrt(T) * phi_d1\n        \n        return gamma, vega\n\n    # Process each test case\n    for S, K, r, q, sigma, T1, T2 in test_cases:\n        # Calculate greeks for the short-dated option (T1)\n        gamma1, vega1 = calculate_greeks(S, K, T1, r, q, sigma)\n        \n        # Calculate greeks for the long-dated option (T2)\n        gamma2, vega2 = calculate_greeks(S, K, T2, r, q, sigma)\n        \n        # Determine weight w2 for Vega neutrality (w1 is fixed at 1)\n        # The equation is V_p = 1*vega1 + w2*vega2 = 0\n        w2 = -vega1 / vega2\n        \n        # Calculate the net Gamma of the portfolio\n        net_gamma = gamma1 + w2 * gamma2\n        \n        # Calculate the net Vega of the portfolio (should be zero by construction)\n        net_vega = vega1 + w2 * vega2\n        \n        # Append the results for the current test case\n        results.extend([w2, net_gamma, net_vega])\n\n    # Format the results to 10 decimal places and join into a single string\n    formatted_results = [f\"{x:.10f}\" for x in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "经典的 Black-Scholes 模型假定波动率 $\\sigma$ 是一个常数，但市场实践早已揭示了“波动率微笑”的存在，即具有相同到期日但不同执行价格的期权隐含着不同的波动率。这个练习要求您走出理想模型的舒适区，直面这一市场现实。您将通过编程量化使用单一平价（at-the-money）波动率与使用完整波动率微笑对期权进行定价和对冲时产生的误差，从而深刻体会模型选择在真实交易环境中的重要性及其对盈亏（PnL）的实际影响 [@problem_id:2416891]。", "id": "2416891", "problem": "给定一个包含单一标的资产和欧式看涨期权的市场。假设当标的资产遵循几何布朗运动时，一个欧式期权的唯一无套利价值等于其风险中性期望。此几何布朗运动的恒定波动率参数等于该期权输入的隐含波动率，使用连续复利无风险利率，且连续股息收益率为零。对于每个期权，将其敏感度（“希腊字母”）定义为其价值相对于所定义输入的相应偏导数：delta 是关于标的资产即期价格的偏导数，gamma 是关于标的资产即期价格的二阶偏导数，vega 是关于输入波动率的偏导数，theta 是关于到期时间的负偏导数，rho 是关于无风险利率的偏导数。考虑以下常见的近似做法：使用单一的平价隐含波动率计算所有行权价的期权价格和希腊字母，而不是使用依赖于行权价的隐含波动率微笑。\n\n标的资产的当前价格为 $S_0 = 100$，连续复利无风险利率为每年 $r = 0.02$，连续股息收益率为零，每个期权的到期时间为 $T = 0.5$ 年。行权价集合为 $K \\in \\{70,85,100,115,130\\}$。一个参数化的隐含波动率微笑通过以下公式将每个行权价 $K$ 映射到一个隐含波动率 $\\sigma(K)$：\n$$\n\\sigma(K) \\;=\\; a \\;+\\; b \\,\\ln\\!\\big(K/S_0\\big) \\;+\\; c \\,\\big(\\ln\\!\\big(K/S_0\\big)\\big)^2.\n$$\n对于每个测试用例，平价（ATM）隐含波动率为 $\\sigma_{\\text{ATM}} = \\sigma(S_0)$，并考虑两种估值和希腊字母计算方法：\n- 全微笑方法：对于每个 $K$，使用特定于该行权价的 $\\sigma(K)$。\n- 仅ATM方法：对于每个 $K$，对所有行权价均使用 $\\sigma_{\\text{ATM}}$。\n\n将任何期权在给定状态下的“真实”估值定义为：在上述几何布朗运动下，使用根据微笑曲线得出的该状态下特定于行权价的隐含波动率所计算出的唯一无套利价值。对于对冲，考虑一个单步delta对冲：在时间 $t=0$ 时，对于给定的 $K$，空头一份看涨期权，并买入 $\\Delta$ 单位的标的资产，其中 $\\Delta$ 是在 $t=0$ 时根据两种方法之一计算得出。在经历以下情景冲击后，平仓以计算对冲盈亏。\n\n每个测试用例的情景冲击是相同的：\n- 标的资产价格变为 $S_1 = S_0 \\times (1 + u)$，其中 $u = 0.01$。\n- 隐含波动率微笑曲线发生 $d v = 0.01$ 的平行移动，因此行权价 $K$ 处的新隐含波动率为 $\\sigma'(K) = \\sigma(K) + d v$。\n- 时间流逝 $\\Delta t = 1/252$ 年，因此到期时间变为 $T' = T - \\Delta t$。\n\n对于下述每个测试用例，针对固定的行权价集合 $K \\in \\{70,85,100,115,130\\}$ 执行以下操作：\n1. 计算在 $t=0$ 时，使用仅ATM方法相对于全微笑方法的均方根定价误差，即\n$$\n\\text{RMSE} \\;=\\; \\sqrt{\\frac{1}{5} \\sum_{K} \\big( V_{\\text{ATM}}(S_0,K,T,r,\\sigma_{\\text{ATM}}) - V_{\\text{smile}}(S_0,K,T,r,\\sigma(K)) \\big)^2 }.\n$$\n2. 计算每种对冲方法在情景冲击下的平均绝对delta对冲盈亏。对于给定的行权价 $K$，定义\n$$\n\\text{PnL}_{\\text{method}}(K) \\;=\\; V_{\\text{true}}(S_1,K,T',r,\\sigma'(K)) \\;-\\; V_{\\text{true}}(S_0,K,T,r,\\sigma(K)) \\;-\\; \\Delta_{\\text{method}}(S_0,K,T,r,\\cdot)\\,\\big(S_1 - S_0\\big),\n$$\n其中 $V_{\\text{true}}(\\cdot)$ 是在相应时间使用来自微笑曲线的特定于行权价的隐含波动率计算的“真实”估值，$\\Delta_{\\text{method}}$ 是在 $t=0$ 时根据仅ATM方法（对所有 $K$ 使用 $\\sigma_{\\text{ATM}}$）或全微笑方法（对每个 $K$ 使用 $\\sigma(K)$）计算的delta，点 $\\cdot$ 表示适用于该方法的隐含波动率输入。设\n$$\n\\overline{A}_{\\text{ATM}} \\;=\\; \\frac{1}{5} \\sum_{K} \\big|\\text{PnL}_{\\text{ATM}}(K)\\big|,\\qquad\n\\overline{A}_{\\text{smile}} \\;=\\; \\frac{1}{5} \\sum_{K} \\big|\\text{PnL}_{\\text{smile}}(K)\\big|.\n$$\n报告比率\n$$\nR \\;=\\; \\frac{\\overline{A}_{\\text{ATM}}}{\\overline{A}_{\\text{smile}}}.\n$$\n\n微笑曲线参数 $(a,b,c)$ 的测试套件：\n- 用例 1： $(a,b,c) = (0.2,\\,0.0,\\,0.0)$。\n- 用例 2： $(a,b,c) = (0.2,\\,-0.05,\\,0.0)$。\n- 用例 3： $(a,b,c) = (0.2,\\,-0.05,\\,0.15)$。\n\n您的程序必须按给定顺序为每个用例计算实数对 $[\\text{RMSE}, R]$。您的程序应生成单行输出，其中包含一个按上述用例排序的、用方括号括起来的逗号分隔列表。每个用例的结果本身也是一个用方括号括起来的双元素逗号分隔列表。例如，所需的输出格式为\n$[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$，\n其中 $x_i$ 和 $y_i$ 是用例 $i$ 所需的浮点数。不应打印任何额外文本。", "solution": "该问题是有效的。这是一个定义明确的量化金融问题，基于标准的 Black-Scholes-Merton 期权定价和对冲框架。所有参数、模型和计算过程都已明确无误地指定。\n\n解决方案要求评估当使用简化的波动率模型（恒定的平价波动率）而非更真实的、依赖于行权价的波动率微笑时，定价和对冲性能的下降情况。这将针对三种不同的微笑曲线参数化进行。\n\n分析的核心在于用于欧式看涨期权的 Black-Scholes-Merton (BSM) 模型。在问题陈述的假设（几何布朗运动、恒定无风险利率、无股息）下，欧式看涨期权的价格 $V_c$ 由下式给出：\n$$ V_c(S, K, T, r, \\sigma) = S N(d_1) - K e^{-rT} N(d_2) $$\n其中 $S$ 是标的资产的即期价格，$K$ 是行权价，$T$ 是以年为单位的到期时间，$r$ 是连续复利无风险利率，$\\sigma$ 是波动率。函数 $N(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)。$d_1$ 和 $d_2$ 两项定义如下：\n$$ d_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\n看涨期权的 delta ($\\Delta$) 代表期权价格对标的资产价格变化的敏感度，是 $V_c$ 对 $S$ 的一阶偏导数：\n$$ \\Delta = \\frac{\\partial V_c}{\\partial S} = N(d_1) $$\n这个量是构建delta中性对冲的核心。\n\n问题将参数化波动率微笑定义为行权价 $K$ 的函数：\n$$ \\sigma(K) \\;=\\; a \\;+\\; b \\,\\ln\\!\\big(K/S_0\\big) \\;+\\; c \\,\\big(\\ln\\!\\big(K/S_0\\big)\\big)^2. $$\n\n解决方案通过对三个测试用例 $(a,b,c)$ 中的每一个执行所需的计算来进行。\n\n**步骤 1：计算均方根定价误差 (RMSE)**\n\n在初始时间 $t=0$，我们有 $S_0 = 100$，$r = 0.02$，以及 $T = 0.5$。对于每个行权价 $K \\in \\{70, 85, 100, 115, 130\\}$：\n1.  使用给定的参数 $(a,b,c)$ 计算“全微笑”波动率 $\\sigma(K)$。相应的“真实”价格是 $V_{\\text{smile}}(S_0,K,T,r,\\sigma(K)) = V_c(S_0,K,T,r,\\sigma(K))$。\n2.  “仅ATM”波动率对所有行权价都是恒定的：$\\sigma_{\\text{ATM}} = \\sigma(S_0) = a$。近似价格是 $V_{\\text{ATM}}(S_0,K,T,r,\\sigma_{\\text{ATM}}) = V_c(S_0,K,T,r,a)$。\n3.  然后根据提供的公式，针对这五个行权价计算 RMSE：\n    $$ \\text{RMSE} \\;=\\; \\sqrt{\\frac{1}{5} \\sum_{K} \\big( V_{\\text{ATM}}(K) - V_{\\text{smile}}(K) \\big)^2 } $$\n\n**步骤 2：计算对冲性能比率 (R)**\n\n这一步分析了在特定的市场冲击下单步delta对冲的盈亏 (PnL)。\n在 $t=0$ 时的初始投资组合包括一份看涨期权的空头头寸和 $\\Delta$ 份标的资产的多头头寸，其中 $\\Delta$ 在 $t=0$ 时计算。该投资组合的价值为 $P_0 = \\Delta S_0 - V_0$。\n\n冲击之后，在时间 $t_1$ 时，新的市场状态为：\n-   标的资产价格：$S_1 = S_0 (1+u) = 100 \\times (1+0.01) = 101$。\n-   到期时间：$T' = T - \\Delta t = 0.5 - 1/252$。\n-   新的波动率微笑曲线：$\\sigma'(K) = \\sigma(K) + dv = \\sigma(K) + 0.01$。\n\n在 $t_1$ 时期权的“真实”价值是 $V_{\\text{true},1}(K) = V_c(S_1, K, T', r, \\sigma'(K))$。在 $t_1$ 时对冲投资组合的价值是 $P_1 = \\Delta S_1 - V_{\\text{true},1}(K)$。\n该期间的盈亏为 $P_1 - P_0 = (\\Delta S_1 - V_{\\text{true},1}(K)) - (\\Delta S_0 - V_0) = V_0 - V_{\\text{true},1}(K) + \\Delta(S_1 - S_0)$，这与问题中提供的公式符号相反。符号约定不影响平均绝对盈亏。我们将使用给定的公式：\n$$ \\text{PnL}(K) = V_{\\text{true},1}(K) - V_{0}(K) - \\Delta(K)(S_1 - S_0) $$\n其中 $V_0(K)$ 是 $t=0$ 时的“真实”价格，即 $V_{\\text{smile}}(K)$。\n\n比较两种不同的对冲策略：\n1.  **仅ATM对冲**：$\\Delta_{\\text{method}} = \\Delta_{\\text{ATM}}(K) = N(d_1)$，使用 $\\sigma_{\\text{ATM}} = a$ 计算得出。相应的盈亏为 $\\text{PnL}_{\\text{ATM}}(K)$。\n2.  **全微笑对冲**：$\\Delta_{\\text{method}} = \\Delta_{\\text{smile}}(K) = N(d_1)$，使用 $\\sigma(K)$ 计算得出。相应的盈亏为 $\\text{PnL}_{\\text{smile}}(K)$。\n\n对于每种策略，计算其平均绝对盈亏：\n$$ \\overline{A}_{\\text{ATM}} = \\frac{1}{5} \\sum_{K} |\\text{PnL}_{\\text{ATM}}(K)| \\quad \\text{and} \\quad \\overline{A}_{\\text{smile}} = \\frac{1}{5} \\sum_{K} |\\text{PnL}_{\\text{smile}}(K)| $$\n最后，确定比率 $R$：\n$$ R = \\frac{\\overline{A}_{\\text{ATM}}}{\\overline{A}_{\\text{smile}}} $$\n该比率量化了因使用简化的仅ATM波动率模型而导致的平均对冲误差的增加。$R=1$ 的值意味着性能没有差异，而 $R>1$ 则表明仅ATM模型在对冲方面表现较差。对于用例1，其中微笑曲线是平的（$b=c=0$），我们预期 $\\sigma(K) = \\sigma_{\\text{ATM}}$，这将导致 $\\text{RMSE}=0$ 和 $R=1$。\n\n该算法将使用 Python 实现，利用 `numpy` 进行高效的数组操作，并使用 `scipy.stats.norm` 计算标准正态CDF。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef bsm_call_price(S, K, T, r, sigma):\n    \"\"\"\n    Computes European call option price using the Black-Scholes-Merton model.\n    Vectorized to handle numpy arrays.\n    \"\"\"\n    # Defensive programming to avoid division by zero or log of non-positive\n    # This is important for very small T or sigma\n    d1 = np.full_like(S, np.inf, dtype=float)\n    d2 = np.full_like(S, np.inf, dtype=float)\n    \n    valid_mask = (sigma > 1e-9) & (T > 1e-9)\n    \n    sigma_sqrt_T = sigma[valid_mask] * np.sqrt(T)\n    d1[valid_mask] = (np.log(S[valid_mask] / K[valid_mask]) + (r + 0.5 * sigma[valid_mask]**2) * T) / sigma_sqrt_T\n    d2[valid_mask] = d1[valid_mask] - sigma_sqrt_T\n    \n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef bsm_call_delta(S, K, T, r, sigma):\n    \"\"\"\n    Computes European call option delta using the Black-Scholes-Merton model.\n    Vectorized to handle numpy arrays.\n    \"\"\"\n    # Defensive programming similar to price function\n    d1 = np.full_like(S, np.inf, dtype=float)\n    \n    valid_mask = (sigma > 1e-9) & (T > 1e-9)\n\n    sigma_sqrt_T = sigma[valid_mask] * np.sqrt(T)\n    d1[valid_mask] = (np.log(S[valid_mask] / K[valid_mask]) + (r + 0.5 * sigma[valid_mask]**2) * T) / sigma_sqrt_T\n    \n    delta = norm.cdf(d1)\n    return delta\n\ndef solve():\n    \"\"\"\n    Main solver function to compute RMSE and hedging performance ratio R\n    for the given test cases.\n    \"\"\"\n    # Market and scenario parameters\n    S0 = 100.0\n    r = 0.02\n    T0 = 0.5\n    strikes = np.array([70.0, 85.0, 100.0, 115.0, 130.0])\n    num_strikes = len(strikes)\n\n    u_shock = 0.01\n    dv_shock = 0.01\n    dt_shock = 1.0 / 252.0\n\n    # Post-shock state\n    S1 = S0 * (1.0 + u_shock)\n    T1 = T0 - dt_shock\n    delta_S = S1 - S0\n\n    # Test suite of smile parameters\n    test_cases = [\n        (0.2, 0.0, 0.0),    # Case 1: Flat smile\n        (0.2, -0.05, 0.0),  # Case 2: Linear smile (skew)\n        (0.2, -0.05, 0.15), # Case 3: Quadratic smile (skew and convexity)\n    ]\n\n    results = []\n    \n    # Broadcast S0 and T0 to match the shape of strikes for vectorized calculations\n    S0_vec = np.full_like(strikes, S0)\n    S1_vec = np.full_like(strikes, S1)\n\n    for a, b, c in test_cases:\n        # --- Time t=0 calculations ---\n        \n        # Volatility calculations\n        log_moneyness = np.log(strikes / S0)\n        sigma_smile_t0 = a + b * log_moneyness + c * log_moneyness**2\n        sigma_atm_t0 = a  # This is a scalar\n        sigma_atm_t0_vec = np.full_like(strikes, sigma_atm_t0)\n\n        # 1. Compute RMSE\n        v_smile_t0 = bsm_call_price(S0_vec, strikes, T0, r, sigma_smile_t0)\n        v_atm_t0 = bsm_call_price(S0_vec, strikes, T0, r, sigma_atm_t0_vec)\n        \n        rmse = np.sqrt(np.mean((v_atm_t0 - v_smile_t0)**2))\n        \n        # --- Hedging PnL calculations ---\n\n        # Deltas at t=0\n        delta_smile_t0 = bsm_call_delta(S0_vec, strikes, T0, r, sigma_smile_t0)\n        delta_atm_t0 = bsm_call_delta(S0_vec, strikes, T0, r, sigma_atm_t0_vec)\n\n        # \"True\" option value at t=1 (post-shock)\n        sigma_smile_t1 = sigma_smile_t0 + dv_shock\n        v_true_t1 = bsm_call_price(S1_vec, strikes, T1, r, sigma_smile_t1)\n        \n        # PnL for both hedging methods\n        # The true initial value is always the smile value\n        v_true_t0 = v_smile_t0 \n        \n        pnl_smile = v_true_t1 - v_true_t0 - delta_smile_t0 * delta_S\n        pnl_atm = v_true_t1 - v_true_t0 - delta_atm_t0 * delta_S\n        \n        # Average absolute PnLs\n        avg_abs_pnl_smile = np.mean(np.abs(pnl_smile))\n        avg_abs_pnl_atm = np.mean(np.abs(pnl_atm))\n\n        # 2. Compute Ratio R\n        # Handle the theoretical case of zero denominator, though unlikely here\n        if avg_abs_pnl_smile < 1e-12:\n            ratio_R = 1.0 if avg_abs_pnl_atm < 1e-12 else np.inf\n        else:\n            ratio_R = avg_abs_pnl_atm / avg_abs_pnl_smile\n            \n        results.append([rmse, ratio_R])\n    \n    # Format the output as specified: [[x1,y1],[x2,y2],[x3,y3]]\n    output_str = \"[\" + \",\".join([f\"[{x:.8f},{y:.8f}]\" for x, y in results]) + \"]\"\n    print(output_str)\n\n\nsolve()\n```"}]}