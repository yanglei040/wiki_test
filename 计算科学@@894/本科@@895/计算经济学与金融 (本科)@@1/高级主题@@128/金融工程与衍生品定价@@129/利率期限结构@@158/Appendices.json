{"hands_on_practices": [{"introduction": "理论模型是理解利率动态的基石。通过亲手实现一个经典的利率模型，如 Cox-Ingersoll-Ross (CIR) 模型，您将能直观地看到几个核心参数（如均值回归速度、长期均值和波动率）如何共同作用，从而生成我们在现实市场中观察到的各种收益率曲线形态。这项练习将抽象的随机过程理论与具体的市场现象（如曲线倒挂）联系起来，加深您对利率期限结构驱动因素的理解 [@problem_id:2436856]。", "id": "2436856", "problem": "给定以下关于风险中性测度下 Cox–Ingersoll–Ross (CIR) 短期利率模型的设定。短期利率过程由随机微分方程 $dr_t = \\kappa(\\theta - r_t) \\, dt + \\sigma \\sqrt{r_t} \\, dW_t$ 定义，其中 $r_t$ 是时间 $t$ 的短期利率，$\\kappa$ 是均值回归速度，$\\theta$ 是长期均值水平，$\\sigma$ 是波动率参数，$W_t$ 是标准维纳过程。假设该过程是良定义的，且参数满足模型的可容许性条件。\n\n在时间 $t=0$ 时，将给定的初始短期利率记为 $r_0$。对于任意到期日 $T > 0$（以年为单位），在时间 $T$ 到期的无违约风险零息债券在时间 $0$ 的价格，记为 $P(0,T)$，由风险中性定价公式定义\n$$\nP(0,T) = \\mathbb{E}\\left[ \\exp\\left( -\\int_0^T r_s \\, ds \\right) \\right],\n$$\n而相应的连续复利零息收益率为\n$$\ny(0,T) = -\\frac{1}{T}\\ln P(0,T).\n$$\n\n您的任务是，对于下面测试套件中的每一组参数，在指定的到期日 $T_i$（以年为单位）上生成收益率曲线 $\\{y(0,T_i)\\}_{i=1}^n$，并判断该曲线在此网格上是否为倒挂的。在网格 $\\{T_i\\}_{i=1}^n$ 上的倒挂收益率曲线意味着收益率在此网格上随到期日的增加而严格递减，即对于网格中每一对相邻的 $(T_i,T_{i+1})$，都有 $y(0,T_{i+1}) < y(0,T_i)$。\n\n所有收益率必须以小数形式表示的年化利率处理。到期日以年为单位。最终输出是布尔值，表示对于每组参数，收益率曲线在指定网格上是否为倒挂的。\n\n测试套件：\n- 到期日网格：$\\{T_i\\}_{i=1}^5 = [0.5, 1.0, 2.0, 5.0, 10.0]$ (年)。\n- 参数集 $(\\kappa,\\theta,\\sigma,r_0)$:\n    1. $(1.0,\\, 0.03,\\, 0.10,\\, 0.12)$\n    2. $(0.5,\\, 0.05,\\, 0.10,\\, 0.01)$\n    3. $(1.5,\\, 0.03,\\, 0.05,\\, 0.025)$\n    4. $(0.8,\\, 0.02,\\, \\sqrt{2 \\cdot 0.8 \\cdot 0.02},\\, 0.09)$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序与上述参数集相同。例如，一个有效的输出格式是 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$，其中每个 $\\text{result}_j$ 是 $\\text{True}$ 或 $\\text{False}$。", "solution": "提交分析的问题陈述被认为是有效的。它在科学上基于已建立的利率期限结构模型理论，特别是 Cox–Ingersoll–Ross (CIR) 模型。该问题是适定的，提供了所有必要的参数和定义，从而可以计算出唯一且有意义的解。所有给定的参数集都遵循 Feller 条件，$2\\kappa\\theta \\geq \\sigma^2$，确保短期利率过程保持非负。\n\n任务是确定对于几组参数，收益率曲线是否为倒挂的。如果在指定的到期日网格 $\\{T_i\\}_{i=1}^n$ 上，收益率 $y(0, T)$ 是到期日 $T$ 的一个严格递减函数，即对于网格中所有的相邻对，都有 $y(0,T_{i+1}) < y(0,T_i)$，那么该收益率曲线就被定义为倒挂的。\n\n解决方案始于 CIR 模型下零息债券价格 $P(0, T)$ 的解析公式。该模型将短期利率动态指定为：\n$$\ndr_t = \\kappa(\\theta - r_t) \\, dt + \\sigma \\sqrt{r_t} \\, dW_t\n$$\n对于此过程，在时间 $T$ 到期的债券在时间 $t=0$ 的价格由一个仿射期限结构模型给出：\n$$\nP(0, T) = A(0, T) e^{-B(0, T) r_0}\n$$\n其中 $r_0$ 是初始短期利率。函数 $A(0, T)$ 和 $B(0, T)$ 取决于模型参数 $(\\kappa, \\theta, \\sigma)$ 和到期时间 $T$。\n\n首先，我们定义一个辅助参数 $\\gamma$ 为：\n$$\n\\gamma = \\sqrt{\\kappa^2 + 2\\sigma^2}\n$$\n函数 $B(0, T)$ 则由下式给出：\n$$\nB(0, T) = \\frac{2(e^{\\gamma T} - 1)}{(\\gamma + \\kappa)(e^{\\gamma T} - 1) + 2\\gamma}\n$$\n而函数 $A(0, T)$ 由下式给出：\n$$\nA(0, T) = \\left[ \\frac{2\\gamma e^{(\\kappa + \\gamma)T/2}}{(\\gamma + \\kappa)(e^{\\gamma T} - 1) + 2\\gamma} \\right]^{\\frac{2\\kappa\\theta}{\\sigma^2}}\n$$\n连续复利收益率 $y(0, T)$ 定义为：\n$$\ny(0, T) = -\\frac{1}{T} \\ln P(0, T)\n$$\n代入 $P(0, T)$ 的表达式，我们得到收益率的公式：\n$$\ny(0, T) = -\\frac{1}{T} \\left( \\ln A(0, T) - B(0, T) r_0 \\right) = \\frac{B(0, T) r_0 - \\ln A(0, T)}{T}\n$$\n为了避免数值不稳定性，尤其是在 $T$ 很大时，最好直接使用 $A(0, T)$ 的对数形式：\n$$\n\\ln A(0, T) = \\frac{2\\kappa\\theta}{\\sigma^2} \\left[ \\ln(2\\gamma) + \\frac{(\\kappa + \\gamma)T}{2} - \\ln\\left( (\\gamma + \\kappa)(e^{\\gamma T} - 1) + 2\\gamma \\right) \\right]\n$$\n解决该问题的算法如下：\n1. 对于每组给定的参数 $(\\kappa, \\theta, \\sigma, r_0)$：\n2. 定义到期日网格 $T_{grid} = [0.5, 1.0, 2.0, 5.0, 10.0]$。\n3. 计算辅助参数 $\\gamma$。\n4. 对于网格中的每个到期日 $T_i$，使用 $B(0, T_i)$ 和 $\\ln A(0, T_i)$ 的公式计算收益率 $y(0, T_i)$。这会生成一个与到期日网格相对应的收益率向量。\n5. 检查这个收益率向量是否严格递减。这通过验证条件 $y(0, T_{i+1}) < y(0, T_i)$（对于 $i=1, \\dots, 4$）来实现。\n6. 如果条件对所有对都成立，则给定参数集的结果为 `True`；否则为 `False`。\n\n此过程是确定性的，并将对每个测试案例实施以产生最终输出。CIR 收益率曲线的形状主要由初始利率 $r_0$ 和长期均值利率 $\\theta$ 之间的关系决定。如果 $r_0$ 显著高于 $\\theta$，短期利率预期会下降，通常导致收益率曲线倒挂。相反，如果 $r_0 < \\theta$，则预期会出现向上倾斜的曲线。在指定网格上的最终检查为给定的离散到期日提供了明确的答案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates CIR model yield curves for several parameter sets and checks for inversion.\n    \"\"\"\n    # Define the maturity grid from the problem statement.\n    T_grid = np.array([0.5, 1.0, 2.0, 5.0, 10.0])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kappa, theta, sigma, r0)\n        (1.0, 0.03, 0.10, 0.12),\n        (0.5, 0.05, 0.10, 0.01),\n        (1.5, 0.03, 0.05, 0.025),\n        (0.8, 0.02, np.sqrt(2 * 0.8 * 0.02), 0.09)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        kappa, theta, sigma, r0 = case\n        \n        # Ensure Feller condition 2*kappa*theta >= sigma**2 holds, although problem statement guarantees it.\n        # This check is for robustness against division by zero if sigma is very small.\n        if sigma < 1e-9:\n            # Handle the case of zero volatility separately if needed. For this problem, not necessary.\n            # Simplified model dynamics would apply.\n            # This is a degenerate case and not in the test suite.\n            # Based on the formula, we need sigma**2 in the denominator for log_A.\n            # However, 2*kappa*theta/sigma**2 can be shown to have a well-defined limit as sigma -> 0.\n            # We assume sigma is not pathologically small.\n            pass\n\n        # 1. Calculate auxiliary parameter gamma\n        gamma = np.sqrt(kappa**2 + 2 * sigma**2)\n\n        # 2. Vectorized calculation for the entire maturity grid T\n        T = T_grid\n        \n        # Calculate term e^(gamma*T)\n        exp_gamma_T = np.exp(gamma * T)\n\n        # Common denominator for both A(0,T) and B(0,T)\n        common_denominator = (gamma + kappa) * (exp_gamma_T - 1) + 2 * gamma\n        \n        # 3. Calculate B(0, T)\n        B_0T = 2 * (exp_gamma_T - 1) / common_denominator\n        \n        # 4. Calculate log of A(0, T) to maintain numerical stability\n        exponent_log_A = 2 * kappa * theta / (sigma**2)\n        log_A_base_numerator = 2 * gamma * np.exp((kappa + gamma) * T / 2)\n        log_A_base = log_A_base_numerator / common_denominator\n        log_A_0T = exponent_log_A * np.log(log_A_base)\n        \n        # 5. Calculate log of bond price P(0, T)\n        log_P_0T = log_A_0T - B_0T * r0\n        \n        # 6. Calculate the yield curve y(0, T)\n        yield_curve = -log_P_0T / T\n        \n        # 7. Check if the yield curve is strictly inverted on the grid\n        # np.diff(x) calculates x[i+1] - x[i].\n        # For a strictly decreasing sequence, all differences must be negative.\n        is_inverted = np.all(np.diff(yield_curve) < 0)\n        \n        results.append(is_inverted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "传统的久期指标假设收益率曲线发生平行移动，这在现实中很少发生。为了更精确地衡量和管理利率风险，金融专业人士使用关键利率久期 (Key Rate Duration, KRD) 来分析非平行移动带来的影响。本次实践将指导您编写代码来计算一系列关键利率久期，从而让您掌握一种更精细的风险分解工具，理解不同期限的利率冲击如何对投资组合的价值产生差异化的影响 [@problem_id:2436810]。", "id": "2436810", "problem": "编写一个完整、可运行的程序，该程序在给定的期限结构下，计算一个固定收益现金流投资组合的关键利率久期 (KRDs)，并模拟指定的收益率曲线非平行移动所带来的影响。程序必须遵守以下定义和要求。\n\n定义与假设：\n- 投资组合由一组有限的带日期现金流 $\\{(t_i, C_i)\\}_{i=1}^N$ 定义，其中 $t_i$ 是从估值日期开始计算的时间（以年为单位），$C_i$ 是现金流量，其货币单位与最终输出相同。\n- 期限结构由一组关键期限 $\\{T_j\\}_{j=1}^M$（以年为单位）和相应的基准连续复利零利率 $\\{z_j\\}_{j=1}^M$（以小数形式表示）指定。\n- 对于任意期限 $t \\ge 0$，连续复利零利率 $z(t)$ 是通过对作为期限函数的零利率使用关键点 $\\{(T_j, z_j)\\}_{j=1}^M$ 进行线性插值得到的，并在区间 $[T_1, T_M]$ 之外进行水平外推。形式上，$z(t)$ 是在 $[T_1, T_M]$ 上满足所有 $j$ 均有 $z(T_j) = z_j$ 的唯一分段线性函数的值，并且当 $t \\le T_1$ 时 $z(t) = z(T_1)$，当 $t \\ge T_M$ 时 $z(t) = z(T_M)$。\n- 期限 $t$ 的折现因子为 $D(t) = \\exp(-z(t)\\, t)$，现值为 $P = \\sum_{i=1}^N C_i \\, D(t_i)$。\n- 相对于第 $k$ 个关键期限 $T_k$ 的关键利率久期 (KRD) 是一个无量纲的敏感度\n$$\\mathrm{KRD}_k \\equiv -\\frac{1}{P}\\,\\frac{\\partial P}{\\partial z_k},$$\n将通过对称有限差分法进行数值计算，差分幅度为 $\\delta$，且仅应用于第 $k$ 个关键利率，其余关键利率保持不变。具体来说，令 $P^{(+)}_k$ 为将关键利率向量 $\\{z_j\\}$ 替换为 $\\{z_j + \\delta \\cdot \\mathbf{1}_{\\{j=k\\}}\\}$ 后计算的现值，而 $P^{(-)}_k$ 为将 $\\{z_j - \\delta \\cdot \\mathbf{1}_{\\{j=k\\}}\\}$ 替换后计算的现值。则\n$$\\mathrm{KRD}_k = -\\frac{P^{(+)}_k - P^{(-)}_k}{2\\,P\\,\\delta}。$$\n- 非平行情景移动是一个向量 $\\{s_j\\}_{j=1}^M$（以小数形式表示），应用于关键利率，产生移动后的关键利率 $\\tilde z_j = z_j + s_j$。移动后的曲线 $\\tilde z(t)$ 通过与 $z(t)$ 相同的插值和外推规则得到。情景现值为 $\\tilde P = \\sum_{i=1}^N C_i \\exp(-\\tilde z(t_i)\\, t_i)$。要求的情景影响是货币价值变动 $\\Delta P = \\tilde P - P$。\n\n所有利率 $z_j$、移动量 $s_j$ 和变动幅度 $\\delta$ 都必须以小数形式指定（例如，$0.01$ 表示百分之一）。所有时间 $t_i$ 和 $T_j$ 都以年为单位。最终的货币价值影响 $\\Delta P$ 必须以与现金流 $C_i$ 相同的单位表示。不需要用户输入；程序必须使用下面提供的测试套件。\n\n测试套件：\n- 案例 A（一般情况）：\n  - 关键期限：$[0.5, 1.0, 2.0, 5.0, 10.0]$\n  - 基准零利率（连续复利）：$[0.02, 0.022, 0.025, 0.03, 0.035]$\n  - 投资组合现金流（时间，金额）：$\\{(1.0, 7.0), (2.0, 7.0), (3.0, 107.0), (4.0, 3.0), (5.0, 3.0), (6.0, 3.0), (7.0, 103.0)\\}$\n  - 用于 KRD 计算的变动幅度：$\\delta = 0.0001$\n  - 非平行情景移动：$[-0.0005, -0.0002, 0.0001, 0.0003, 0.0006]$\n- 案例 B（边界情况：零息集中）：\n  - 关键期限：$[1.0, 2.0, 3.0, 5.0]$\n  - 基准零利率（连续复利）：$[0.015, 0.02, 0.022, 0.025]$\n  - 投资组合现金流：$\\{(2.0, 100.0)\\}$\n  - 用于 KRD 计算的变动幅度：$\\delta = 0.0001$\n  - 非平行情景移动：$[0.0, 0.001, 0.0, 0.0]$\n- 案例 C（边缘情况：在第一个关键期限之前和最后一个关键期限之后外推）：\n  - 关键期限：$[0.5, 1.0, 3.0, 10.0]$\n  - 基准零利率（连续复利）：$[0.01, 0.012, 0.018, 0.028]$\n  - 投资组合现金流：$\\{(0.25, 1.0), (0.75, 1.0), (1.25, 1.0), (3.5, 2.0), (10.0, 2.0), (12.0, 105.0)\\}$\n  - 用于 KRD 计算的变动幅度：$\\delta = 0.0001$\n  - 非平行情景移动：$[-0.0001, 0.0002, 0.0005, -0.0002]$\n\n要求输出：\n- 对每个案例，计算：\n  - 按照所提供关键期限的顺序，计算关键利率久期向量 $[\\mathrm{KRD}_1, \\ldots, \\mathrm{KRD}_M]$。\n  - 情景影响 $\\Delta P$，以与现金流相同的货币单位的实数表示。\n- 程序必须生成单行输出，包含一个列表，其中每个条目对应一个案例。每个案例条目必须是一个列表，由 KRD 向量和单个 $\\Delta P$ 值连接而成。例如，输出格式必须与以下完全一样：\n  - $[[\\mathrm{KRD}^{(A)}_1,\\ldots,\\mathrm{KRD}^{(A)}_M,\\Delta P^{(A)}],[\\mathrm{KRD}^{(B)}_1,\\ldots,\\mathrm{KRD}^{(B)}_M,\\Delta P^{(B)}],[\\mathrm{KRD}^{(C)}_1,\\ldots,\\mathrm{KRD}^{(C)}_M,\\Delta P^{(C)}]]$\n打印在单行上，使用十进制表示。", "solution": "所提出的问题经过了严格的验证协议。\n\n### 第 1 步：提取给定信息\n\n以下信息已从问题陈述中逐字提取：\n- **投资组合定义**：一组带日期的现金流 $\\{(t_i, C_i)\\}_{i=1}^N$，其中 $t_i$ 是以年为单位的时间，$C_i$ 是现金流量。\n- **期限结构**：一组关键期限 $\\{T_j\\}_{j=1}^M$（以年为单位）和相应的基准连续复利零利率 $\\{z_j\\}_{j=1}^M$（以小数形式表示）。\n- **收益率曲线构建**：对于任意期限 $t \\ge 0$，连续复利零利率 $z(t)$ 通过对零利率 $\\{z_j\\}$ 作为期限 $\\{T_j\\}$ 的函数进行线性插值得到，并进行水平外推，使得当 $t \\le T_1$ 时 $z(t) = z(T_1)$，当 $t \\ge T_M$ 时 $z(t) = z(T_M)$。\n- **折现因子**：$D(t) = \\exp(-z(t)\\, t)$。\n- **现值 (PV)**：$P = \\sum_{i=1}^N C_i \\, D(t_i)$。\n- **关键利率久期 (KRD)**：定义为 $\\mathrm{KRD}_k \\equiv -\\frac{1}{P}\\,\\frac{\\partial P}{\\partial z_k}$。\n- **KRD 数值近似**：$\\mathrm{KRD}_k = -\\frac{P^{(+)}_k - P^{(-)}_k}{2\\,P\\,\\delta}$，其中 $P^{(+)}_k$ 和 $P^{(-)}_k$ 是通过将第 $k$ 个关键利率 $z_k$ 分别加上 $+\\delta$ 和减去 $-\\delta$ 计算得出的现值。\n- **非平行情景移动**：一个移动向量 $\\{s_j\\}_{j=1}^M$ 应用于关键利率，得到移动后的利率 $\\tilde z_j = z_j + s_j$。移动后的曲线 $\\tilde z(t)$ 使用相同的规则构建。\n- **情景影响**：现值的货币价值变动，$\\Delta P = \\tilde P - P$，其中 $\\tilde P$ 是在移动后曲线下的现值。\n- **测试案例**：\n    - **案例 A**：\n        - 关键期限：$[0.5, 1.0, 2.0, 5.0, 10.0]$\n        - 基准零利率：$[0.02, 0.022, 0.025, 0.03, 0.035]$\n        - 投资组合现金流：$\\{(1.0, 7.0), (2.0, 7.0), (3.0, 107.0), (4.0, 3.0), (5.0, 3.0), (6.0, 3.0), (7.0, 103.0)\\}$\n        - 变动幅度 $\\delta$：$0.0001$\n        - 情景移动：$[-0.0005, -0.0002, 0.0001, 0.0003, 0.0006]$\n    - **案例 B**：\n        - 关键期限：$[1.0, 2.0, 3.0, 5.0]$\n        - 基准零利率：$[0.015, 0.02, 0.022, 0.025]$\n        - 投资组合现金流：$\\{(2.0, 100.0)\\}$\n        - 变动幅度 $\\delta$：$0.0001$\n        - 情景移动：$[0.0, 0.001, 0.0, 0.0]$\n    - **案例 C**：\n        - 关键期限：$[0.5, 1.0, 3.0, 10.0]$\n        - 基准零利率：$[0.01, 0.012, 0.018, 0.028]$\n        - 投资组合现金流：$\\{(0.25, 1.0), (0.75, 1.0), (1.25, 1.0), (3.5, 2.0), (10.0, 2.0), (12.0, 105.0)\\}$\n        - 变动幅度 $\\delta$：$0.0001$\n        - 情景移动：$[-0.0001, 0.0002, 0.0005, -0.0002]$\n\n### 第 2 步：使用提取的给定信息进行验证\n\n对照有效性标准对问题进行审查。\n- **科学基础**：该问题采用了计算金融和固定收益分析中标准的、公认的概念，包括利率期限结构、现值计算、折现因子和关键利率久期。其数学形式是正确的。\n- **良定性**：所有必需的参数、函数和数值方法都有明确定义。通过插值和外推构建收益率曲线的方法是明确无误的。用于关键利率久期的有限差分格式有精确规定。每个测试案例的输入数据是完整的。可计算出唯一解。\n- **客观性**：语言是形式化和定量的，没有任何主观或模棱两可的术语。\n\n该问题未表现出任何已定义的缺陷：\n1.  它在科学上并非不健全；它遵循了既定的金融数学原理。\n2.  它并非不可形式化；它是一个标准的量化任务。\n3.  它并非不完整或矛盾；所有需要的数据都已提供。\n4.  它并非不切实际；这些数值对于市场数据是合理的。\n5.  它并非不适定 (ill-posed)；问题结构保证了唯一、稳定的解。\n6.  它并未超出科学可验证性范围；其结果可以被独立复现。\n\n### 第 3 步：结论与行动\n\n该问题是**有效的**。将开发一个解决方案。\n\n### 解决方案\n\n解决方案需要根据规范实现几个金融数学函数。解决问题的逻辑结构如下。\n\n**1. 收益率曲线构建**\n\n计算的基础是函数 $z(t)$，它为任何期限 $t$ 提供连续复利零利率。此函数是根据给定的关键期限 $\\{T_j\\}_{j=1}^M$ 和相应的关键利率 $\\{z_j\\}_{j=1}^M$ 构建的。问题指定了一个在区间 $[T_1, T_M]$ 上的分段线性函数，并在该范围之外进行水平外推。这意味着：\n$$\nz(t) = \\begin{cases} \nz_1 & \\text{if } t \\le T_1 \\\\\nz_j + (t - T_j) \\frac{z_{j+1} - z_j}{T_{j+1} - T_j} & \\text{if } T_j < t \\le T_{j+1} \\text{ for } 1 \\le j < M \\\\\nz_M & \\text{if } t > T_M \n\\end{cases}\n$$\n这种构建可以使用插值库高效实现，这些库能正确处理分段定义和边界条件。我们将定义一个函数，它接受一组现金流时间、关键期限和关键利率，并返回每个时间点对应的插值零利率。\n\n**2. 现值计算**\n\n投资组合的现值 ($PV$) 是其各笔现金流折现值的总和。对于一组现金流 $\\{(t_i, C_i)\\}_{i=1}^N$，现值 $P$ 由以下公式给出：\n$$\nP = \\sum_{i=1}^{N} C_i \\cdot D(t_i)\n$$\n其中 $D(t_i)$ 是期限 $t_i$ 的折现因子。折现因子由所构建的收益率曲线上的零利率 $z(t_i)$ 决定：\n$$\nD(t_i) = \\exp(-z(t_i) \\cdot t_i)\n$$\n我们将实现一个函数来计算这个总和。该函数将是所有后续计算的核心组件。\n\n**3. 关键利率久期 (KRD) 计算**\n\n关键利率久期 $\\mathrm{KRD}_k$ 衡量投资组合现值对第 $k$ 个关键利率 $z_k$ 微小变化的敏感度。问题指定了使用对称有限差分法的数值近似。公式为：\n$$\n\\mathrm{KRD}_k = -\\frac{P^{(+)}_k - P^{(-)}_k}{2 \\cdot P \\cdot \\delta}\n$$\n这里，$P$ 是基准现值。$P^{(+)}_k$ 是在将第 $k$ 个关键利率提高一个微小量 $\\delta$（即使用利率向量 $\\{z_1, \\dots, z_k + \\delta, \\dots, z_M\\}$）后重新计算的 PV。类似地，$P^{(-)}_k$ 是在将第 $k$ 个关键利率降低 $\\delta$（即使用 $\\{z_1, \\dots, z_k - \\delta, \\dots, z_M\\}$）后重新计算的 PV。对从 1 到 $M$ 的每个关键利率 $z_k$ 重复此过程。\n\n算法如下：\n- 计算基准投资组合现值 $P$。\n- 对于每个关键利率索引 $k \\in \\{1, \\dots, M\\}$：\n    - 构建“向上移动”的利率向量并计算 $P^{(+)}_k$。\n    - 构建“向下移动”的利率向量并计算 $P^{(-)}_k$。\n    - 使用公式计算 $\\mathrm{KRD}_k$。\n- 将所有 $\\mathrm{KRD}_k$ 值收集到一个结果向量中。\n\n**4. 情景影响分析**\n\n最后的任务是计算在指定的收益率曲线非平行移动下，投资组合价值的变化量 $\\Delta P$。将移动量 $\\{s_j\\}_{j=1}^M$ 应用于基准关键利率，以获得一组新的情景利率：\n$$\n\\tilde{z}_j = z_j + s_j \\quad \\text{for } j = 1, \\dots, M\n$$\n使用这组新的关键利率 $\\{\\tilde{z}_j\\}$，构建一条新的收益率曲线 $\\tilde{z}(t)$，并重新评估投资组合以求得情景现值 $\\tilde{P}$。\n$$\n\\tilde{P} = \\sum_{i=1}^{N} C_i \\cdot \\exp(-\\tilde{z}(t_i) \\cdot t_i)\n$$\n货币价值影响即为新旧现值之差：\n$$\n\\Delta P = \\tilde{P} - P\n$$\n计算过程首先计算基准值 $P$，然后计算情景值 $\\tilde{P}$，最后求两者之差。\n\n将构建一个单一程序，对问题陈述中提供的每个测试案例执行这些步骤，并根据指定的输出结构格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational finance problem for calculating Key Rate Durations\n    and scenario impacts for a fixed-income portfolio.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case A (general case)\",\n            \"key_maturities\": np.array([0.5, 1.0, 2.0, 5.0, 10.0]),\n            \"key_rates\": np.array([0.02, 0.022, 0.025, 0.03, 0.035]),\n            \"cash_flows\": np.array([(1.0, 7.0), (2.0, 7.0), (3.0, 107.0), (4.0, 3.0), (5.0, 3.0), (6.0, 3.0), (7.0, 103.0)]),\n            \"delta\": 0.0001,\n            \"scenario_shifts\": np.array([-0.0005, -0.0002, 0.0001, 0.0003, 0.0006])\n        },\n        {\n            \"name\": \"Case B (boundary case: zero-coupon concentration)\",\n            \"key_maturities\": np.array([1.0, 2.0, 3.0, 5.0]),\n            \"key_rates\": np.array([0.015, 0.02, 0.022, 0.025]),\n            \"cash_flows\": np.array([(2.0, 100.0)]),\n            \"delta\": 0.0001,\n            \"scenario_shifts\": np.array([0.0, 0.001, 0.0, 0.0])\n        },\n        {\n            \"name\": \"Case C (edge case: extrapolation before first key and beyond last key)\",\n            \"key_maturities\": np.array([0.5, 1.0, 3.0, 10.0]),\n            \"key_rates\": np.array([0.01, 0.012, 0.018, 0.028]),\n            \"cash_flows\": np.array([(0.25, 1.0), (0.75, 1.0), (1.25, 1.0), (3.5, 2.0), (10.0, 2.0), (12.0, 105.0)]),\n            \"delta\": 0.0001,\n            \"scenario_shifts\": np.array([-0.0001, 0.0002, 0.0005, -0.0002])\n        }\n    ]\n\n    def get_zero_rates(times, key_maturities, key_rates):\n        \"\"\"\n        Computes continuously compounded zero rates for given times using linear\n        interpolation and flat extrapolation on key rates.\n        \n        Args:\n            times (np.ndarray): Array of times t for which to find zero rates.\n            key_maturities (np.ndarray): The key maturities T_j of the term structure.\n            key_rates (np.ndarray): The key zero rates z_j of the term structure.\n        \n        Returns:\n            np.ndarray: Array of zero rates z(t) for each time in `times`.\n        \"\"\"\n        # numpy.interp handles linear interpolation and flat extrapolation as required.\n        # For t <= T_1, it uses z_1. For t >= T_M, it uses z_M.\n        return np.interp(times, key_maturities, key_rates)\n\n    def calculate_pv(cf_times, cf_amounts, key_maturities, key_rates):\n        \"\"\"\n        Calculates the present value of a portfolio of cash flows.\n\n        Args:\n            cf_times (np.ndarray): Times of cash flows.\n            cf_amounts (np.ndarray): Amounts of cash flows.\n            key_maturities (np.ndarray): The key maturities of the term structure.\n            key_rates (np.ndarray): The key zero rates of the term structure.\n\n        Returns:\n            float: The total present value of the portfolio.\n        \"\"\"\n        zero_rates = get_zero_rates(cf_times, key_maturities, key_rates)\n        discount_factors = np.exp(-zero_rates * cf_times)\n        present_values = cf_amounts * discount_factors\n        return np.sum(present_values)\n\n    all_results = []\n    for case in test_cases:\n        # Unpack case data\n        key_maturities = case[\"key_maturities\"]\n        base_rates = case[\"key_rates\"]\n        cash_flows = case[\"cash_flows\"]\n        cf_times = cash_flows[:, 0]\n        cf_amounts = cash_flows[:, 1]\n        delta = case[\"delta\"]\n        scenario_shifts = case[\"scenario_shifts\"]\n\n        # 1. Calculate base Present Value (P)\n        base_pv = calculate_pv(cf_times, cf_amounts, key_maturities, base_rates)\n\n        # 2. Calculate Key Rate Durations (KRDs)\n        krds = []\n        for i in range(len(key_maturities)):\n            # Positive bump\n            rates_plus = base_rates.copy()\n            rates_plus[i] += delta\n            pv_plus = calculate_pv(cf_times, cf_amounts, key_maturities, rates_plus)\n            \n            # Negative bump\n            rates_minus = base_rates.copy()\n            rates_minus[i] -= delta\n            pv_minus = calculate_pv(cf_times, cf_amounts, key_maturities, rates_minus)\n            \n            # KRD calculation\n            krd = - (pv_plus - pv_minus) / (2 * base_pv * delta)\n            krds.append(krd)\n\n        # 3. Calculate Scenario Impact (Delta P)\n        shifted_rates = base_rates + scenario_shifts\n        scenario_pv = calculate_pv(cf_times, cf_amounts, key_maturities, shifted_rates)\n        delta_p = scenario_pv - base_pv\n        \n        # 4. Consolidate results for the case\n        case_results = krds + [delta_p]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The str() function on a list provides the required '[...]' format.\n    # Joining these with commas and wrapping in outer brackets gives the final format.\n    print(f\"[{','.join(str(r) for r in all_results)}]\")\n\nsolve()\n```"}, {"introduction": "固定收益投资组合管理的核心任务之一是构建能够抵御利率波动的“免疫”组合。这不仅仅是简单地将久期降为零，更高级的策略还会考虑凸性，以在市场大幅波动时获得有利地位。在这个综合性练习中，您将运用优化技术来解决一个实际的投资组合构建问题：在满足特定预算和零美元久期约束的同时，最大化投资组合的美元凸性。这项实践将风险衡量理论与主动的投资组合管理策略无缝连接 [@problem_id:2436877]。", "id": "2436877", "problem": "设计并实现一个完整的程序。在给定离散的利率期限结构和一组有限的零息债券的情况下，该程序构建一个由这些债券组成的静态投资组合。该组合对于连续复利收益率曲线的平行移动具有零美元久期，并且在投资组合权重的箱形约束下，能够最大化每单位价格的美元凸性。\n\n请从固定收益分析中的以下基本定义开始：\n- 在连续复利即期利率为 $r(T)$ 的情况下，到期时间为 $T$ 年的零息债券的价格 $P(T)$ 为 $P(T) = \\exp(-r(T)\\,T)$。\n- 在所有连续复利利率上应用一个平行位移 $y$（以十进制单位表示）后，扰动后的价格为 $P_y(T) = \\exp(-(r(T)+y)\\,T)$。对于一个权重为 $w_i$（每种债券一个权重）、到期时间为 $T_i$、即期利率为 $r(T_i)$ 的投資組合，在位移 $y$ 下的组合价格为 $P_{\\text{port}}(y) = \\sum_i w_i\\, \\exp(-(r(T_i)+y)\\,T_i)$。\n- 将投资组合美元久期定义为 $-\\left.\\dfrac{dP_{\\text{port}}}{dy}\\right|_{y=0}$，将投资组合美元凸性定义为 $\\left.\\dfrac{d^2 P_{\\text{port}}}{dy^2}\\right|_{y=0}$。\n\n您的算法必须：\n- 使用上述定义，根据每种零息债券的到期时间 $T_i$ 和初始价格 $P_i = \\exp(-r(T_i)\\,T_i)$，推导出其美元久期和美元凸性的贡献表达式。\n- 对投资组合权重 $w_i$ 施加以下约束：\n  1) 单位价格预算约束：$\\sum_i w_i\\,P_i = 1$ (即，投资组合的单位价格为1个货币单位)。\n  2) 零美元久期：$-\\left.\\dfrac{dP_{\\text{port}}}{dy}\\right|_{y=0} = 0$。\n  3) 箱形约束：对所有 $i$ 成立，$w_{\\min} \\le w_i \\le w_{\\max}$。\n- 最大化每单位价格的美元凸性。在单位价格预算约束下，这等同于最大化投资组合本身的美元凸性。目标函数必须根据上述第一性原理，用 $w_i$、$T_i$ 和 $P_i$ 来表示。\n- 将此问题作为受线性等式约束和边界约束的优化问题来求解。所有利率必须解释为十进制数（而非百分比）。时间单位必須是年。最终优化后的凸性必须以“年”的平方为单位报告。\n\n实现要求：\n- 输入通过下面描述的测试套件硬编码；不读取外部输入。\n- 对于每个测试用例，计算以“年”的平方为单位的最优凸性值（浮点数）。将每个结果四舍五入到六位小数。\n\n测试套件：\n对于每个测试用例，输入是一个三元组：一个以年为单位的到期时间列表 $[T_1,\\dots,T_n]$，一个以十进制表示的连续复利即期利率列表 $[r(T_1),\\dots,r(T_n)]$，以及应用于所有 $w_i$ 的统一边界 $(w_{\\min}, w_{\\max})$。\n\n- 测试用例 1 (正常路径):\n  - $T = [1.0, 3.0, 10.0]$\n  - $r = [0.02, 0.025, 0.03]$\n  - $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$\n\n- 测试用例 2 (多个自由度，中等边界):\n  - $T = [0.5, 2.0, 5.0, 20.0]$\n  - $r = [0.015, 0.02, 0.028, 0.035]$\n  - $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$\n\n- 测试用例 3 (平坦曲线边缘案例):\n  - $T = [1.0, 2.0, 4.0]$\n  - $r = [0.02, 0.02, 0.02]$\n  - $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$\n\n- 测试用例 4 (短期和长期到期日混合):\n  - $T = [0.25, 7.0, 15.0]$\n  - $r = [0.01, 0.03, 0.035]$\n  - $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于上述四个测试用例，输出格式必须为“[c1,c2,c3,c4]”，其中每个 $c_k$ 是以“年”的平方为单位的优化凸性值，四舍五入到六位小数，无任何附加文本。", "solution": "首先应对问题陈述进行严格验证。\n\n## 问题验证\n\n### 步骤1：提取给定条件\n从问题描述中逐字提取给定条件：\n\n- **定义:**\n  - 零息债券价格：对于到期时间为 $T$ 和即期利率为 $r(T)$ 的债券，$P(T) = \\exp(-r(T)\\,T)$。\n  - 平行位移 $y$ 下的扰动价格：$P_y(T) = \\exp(-(r(T)+y)\\,T)$。\n  - 位移 $y$ 下的投资组合价格：$P_{\\text{port}}(y) = \\sum_i w_i\\, \\exp(-(r(T_i)+y)\\,T_i)$。\n  - 投资组合美元久期：$D_\\$ = -\\left.\\dfrac{dP_{\\text{port}}}{dy}\\right|_{y=0}$。\n  - 投资组合美元凸性：$C_\\$ = \\left.\\dfrac{d^2 P_{\\text{port}}}{dy^2}\\right|_{y=0}$。\n\n- **目标:**\n  - 最大化每单位价格的美元凸性。\n\n- **约束条件:**\n  1. 单位价格预算约束：$\\sum_i w_i\\,P_i = 1$，其中 $P_i = \\exp(-r(T_i)\\,T_i)$。\n  2. 零美元久期约束：$-\\left.\\dfrac{dP_{\\text{port}}}{dy}\\right|_{y=0} = 0$。\n  3. 权重上的箱形约束：对所有 $i$ 成立，$w_{\\min} \\le w_i \\le w_{\\max}$。\n\n- **测试套件数据:**\n  - 案例 1: $T = [1.0, 3.0, 10.0]$，$r = [0.02, 0.025, 0.03]$，$(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$。\n  - 案例 2: $T = [0.5, 2.0, 5.0, 20.0]$，$r = [0.015, 0.02, 0.028, 0.035]$，$(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$。\n  - 案例 3: $T = [1.0, 2.0, 4.0]$，$r = [0.02, 0.02, 0.02]$，$(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$。\n  - 案例 4: $T = [0.25, 7.0, 15.0]$，$r = [0.01, 0.03, 0.035]$，$(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$。\n\n### 步骤2：使用提取的给定条件进行验证\n根据所需标准对问题进行评估。\n\n- **科学依据：** 该问题牢固地植根于固定收益分析的原理。所提供的债券定价、美元久期和美元凸性的定义，是利率风险管理中使用的基于泰勒级数的标准近似。构建投资组合以满足特定风险（久期）和绩效（凸性）目标的总体任务是金融工程中的一个典型问题，通常称为投资组合免疫或对冲。该提法在数学上和金融上都是合理的。\n- **适定性：** 该问题是一个约束优化任务。如下所示，它可简化为线性规划（LP）问题。具有非空可行域（满足所有约束的权重集合 $\\mathbf{w}$）的LP问题保证有解。鉴于这些约束，可行域并非必然存在，但对于所提供的测试用例来说极有可能存在。问题的规定足够明确，可以得出一个唯一、稳定且有意义的解。\n- **客观性：** 问题陈述使用了精确、无歧义的数学和金融术语。没有主观或基于意见的陈述。\n\n该问题没有表现出任何列出的无效性缺陷。它在科学上是合理的，可形式化的，完整的，且结构良好。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将着手开发解决方案。\n\n## 解决方案推导与算法设计\n\n任务是构建一个零息债券投资组合，以最大化凸性，同时对收益率曲线的一阶平行移动免疫（即具有零美元久期）。投资组合的初始价格被约束为一个货币单位。\n\n### 目标函数和约束函数的推导\n\n我们首先从给定的投资组合价格在平行收益率曲线位移 $y$ 下的定义推导美元久期和美元凸性的表达式：\n$$P_{\\text{port}}(y) = \\sum_{i} w_i \\exp(-(r(T_i) + y)T_i)$$\n设 $P_i = \\exp(-r(T_i)T_i)$ 为第 $i$ 支债券的初始价格。该表达式可以重写为：\n$$P_{\\text{port}}(y) = \\sum_{i} w_i P_i \\exp(-yT_i)$$\n投资组合的价值是权重 $w_i$ 和收益率位移 $y$ 的函数。我们现在计算关于 $y$ 的所需导数，并在 $y=0$ 处求值。\n\n一阶导数为：\n$$\\frac{dP_{\\text{port}}}{dy} = \\frac{d}{dy} \\left( \\sum_{i} w_i P_i \\exp(-yT_i) \\right) = \\sum_{i} w_i P_i \\frac{d}{dy}(\\exp(-yT_i)) = \\sum_{i} w_i P_i (-T_i \\exp(-yT_i))$$\n在 $y=0$ 处求值：\n$$\\left.\\frac{dP_{\\text{port}}}{dy}\\right|_{y=0} = -\\sum_{i} w_i P_i T_i$$\n投资组合美元久期 $D_\\$$ 被定义为该数量的负值：\n$$D_\\$ = -\\left.\\frac{dP_{\\text{port}}}{dy}\\right|_{y=0} = \\sum_{i} w_i P_i T_i$$\n\n二阶导数为：\n$$\\frac{d^2P_{\\text{port}}}{dy^2} = \\frac{d}{dy} \\left( -\\sum_{i} w_i P_i T_i \\exp(-yT_i) \\right) = -\\sum_{i} w_i P_i T_i (-T_i \\exp(-yT_i)) = \\sum_{i} w_i P_i T_i^2 \\exp(-yT_i)$$\n在 $y=0$ 处求值：\n$$\\left.\\frac{d^2P_{\\text{port}}}{dy^2}\\right|_{y=0} = \\sum_{i} w_i P_i T_i^2$$\n投资组合美元凸性 $C_\\$$ 被定义为这个二阶导数：\n$$C_\\$ = \\left.\\frac{d^2P_{\\text{port}}}{dy^2}\\right|_{y=0} = \\sum_{i} w_i P_i T_i^2$$\n\n### 格式化为线性规划问题\n\n问题是找到权重向量 $\\mathbf{w} = [w_1, w_2, \\dots, w_n]^T$ 来解决以下优化问题：\n\n**最大化:**\n$$C_\\$ = \\sum_{i=1}^n w_i P_i T_i^2$$\n\n**约束条件:**\n1.  **单位价格：** $\\sum_{i=1}^n w_i P_i = 1$\n2.  **零美元久期：** $\\sum_{i=1}^n w_i P_i T_i = 0$\n3.  **箱形约束：** $w_{\\min} \\le w_i \\le w_{\\max}$ for $i=1, \\dots, n$\n\n这是一个线性规划（LP）问题。目标函数和所有约束都是决策变量 $w_i$ 的线性函数。我们将使用一个标准的LP求解器 `scipy.optimize.linprog`，它被设计用来解决最小化问题。为了最大化我们的目标函数 $C_\\$$，我们将最小化其负值 $-C_\\$$。\n\n`scipy.optimize.linprog` 的标准形式是：\n$\\min_{\\mathbf{w}} \\mathbf{c}^T \\mathbf{w}$ subject to $\\mathbf{A}_{\\text{eq}}\\mathbf{w} = \\mathbf{b}_{\\text{eq}}$ and $\\mathbf{l} \\le \\mathbf{w} \\le \\mathbf{u}$.\n\n将我们的问题与此形式匹配：\n- **决策变量** $\\mathbf{w}$：债券权重向量 $[w_1, \\dots, w_n]^T$。\n- **目标向量** $\\mathbf{c}$：为了最小化 $-C_\\$ = -\\sum_i w_i P_i T_i^2$，目标向量是 $\\mathbf{c} = [-P_1 T_1^2, -P_2 T_2^2, \\dots, -P_n T_n^2]^T$。\n- **等式约束矩阵** $\\mathbf{A}_{\\text{eq}}$：这是一个 $2 \\times n$ 矩阵，其中每一行对应一个等式约束。\n  - 第1行（单位价格）：$[P_1, P_2, \\dots, P_n]$\n  - 第2行（零久期）：$[P_1 T_1, P_2 T_2, \\dots, P_n T_n]$\n- **等式约束向量** $\\mathbf{b}_{\\text{eq}}$：这是一个长度为2的向量。\n  - $[1, 0]^T$\n- **边界**：箱形约束由 `bounds` 参数直接处理，该参数是每个 $w_i$ 的 ఒక $(w_{\\min}, w_{\\max})$ 元组序列。\n\n### 实现算法\n\n对于每个给定的测试用例（一组到期时间 $T_i$、即期利率 $r_i$ 和边界 $w_{\\min}, w_{\\max}$）：\n1.  对所有 $i$ 计算债券价格 $P_i = \\exp(-r_i T_i)$。\n2.  为最小化问题构造目标向量 $\\mathbf{c}$。对于每个债券 $i$，对应的元素是 $-P_i T_i^2$。\n3.  构造 $2 \\times n$ 的等式约束矩阵 $\\mathbf{A}_{\\text{eq}}$。第一行包含价格 $P_i$，第二行包含每单位的美元久期贡献 $P_i T_i$。\n4.  构造等式约束向量 $\\mathbf{b}_{\\text{eq}} = [1, 0]^T$。\n5.  将每个权重 $w_i$ 的边界定义为 $(w_{\\min}, w_{\\max})$。\n6.  使用 `scipy.optimize.linprog` 解决LP问题。优化的结果 `res.fun` 将是目标函数的最小值，即 $-\\max(C_\\$)$。\n7.  因此，最大凸性为 $-(\\text{res.fun})$。\n8.  按要求将最终的凸性值四舍五入到六位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves for the maximum portfolio convexity under duration and budget constraints\n    for a series of test cases.\n    \"\"\"\n    \n    # Test suite as per the problem description.\n    test_cases = [\n        {\n            \"T\": [1.0, 3.0, 10.0],\n            \"r\": [0.02, 0.025, 0.03],\n            \"bounds\": (-2.0, 2.0)\n        },\n        {\n            \"T\": [0.5, 2.0, 5.0, 20.0],\n            \"r\": [0.015, 0.02, 0.028, 0.035],\n            \"bounds\": (-2.0, 2.0)\n        },\n        {\n            \"T\": [1.0, 2.0, 4.0],\n            \"r\": [0.02, 0.02, 0.02],\n            \"bounds\": (-2.0, 2.0)\n        },\n        {\n            \"T\": [0.25, 7.0, 15.0],\n            \"r\": [0.01, 0.03, 0.035],\n            \"bounds\": (-2.0, 2.0)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Extract data for the current test case\n        T = np.array(case[\"T\"])\n        r = np.array(case[\"r\"])\n        w_min, w_max = case[\"bounds\"]\n        n = len(T)\n\n        # 1. Calculate bond prices from spot rates and maturities\n        # P_i = exp(-r_i * T_i)\n        P = np.exp(-r * T)\n\n        # 2. Formulate the Linear Programming problem\n        \n        # Objective function: Maximize sum(w_i * P_i * T_i^2)\n        # For a minimization solver, we minimize -sum(w_i * P_i * T_i^2).\n        # The objective vector c for linprog is [-P_1*T_1^2, -P_2*T_2^2, ...]\n        c_obj = -(P * T**2)\n\n        # Equality constraints: A_eq @ w = b_eq\n        # Constraint 1: sum(w_i * P_i) = 1 (unit price)\n        # Constraint 2: sum(w_i * P_i * T_i) = 0 (zero dollar duration)\n        A_eq = np.array([\n            P,        # Coefficients for the unit price constraint\n            P * T     # Coefficients for the zero dollar duration constraint\n        ])\n        b_eq = np.array([1, 0])\n\n        # Bounds for each weight w_i\n        bounds = [(w_min, w_max)] * n\n\n        # 3. Solve the LP problem\n        # The 'highs' method is robust and recommended for new applications.\n        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            # The solver returns the minimum value of the objective function.\n            # Since our objective was negated for minimization, the maximum\n            # convexity is the negative of the solver's result.\n            max_convexity = -res.fun\n            results.append(round(max_convexity, 6))\n        else:\n            # In case the optimization fails (e.g., infeasible problem),\n            # append NaN or handle as an error. For this problem, we assume\n            # a solution exists for all test cases.\n            results.append(np.nan)\n\n    # 4. Print the final results in the specified format\n    # Example format: [c1,c2,c3,c4]\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"}]}