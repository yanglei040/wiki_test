{"hands_on_practices": [{"introduction": "虽然基础模型提供了一个强大的起点，但在现实世界中为期权定价通常需要对其进行调整，以适应标的资产的特定特征。第一个实践将挑战你修改经典的二叉树框架，为一只支付离散股息的股票上的美式期权定价。通过实施该模型，你将在处理除息日股价调整方面获得动手经验，并了解这如何影响最优的提前行权决策，从而弥合教科书理论与实际应用之间的差距。[@problem_id:2420973]", "id": "2420973", "problem": "您必须编写一个完整的、可运行的程序，使用修正的二叉树模型为支付已知离散现金股利流的标的资产上的美式看涨期权定价。该模型考虑了除息日股价下跌的影响。模型以纯数学术语指定，必须严格按照陈述实现。\n\n其基础是在风险中性测度下的无套利原则以及用于描述标的资产派息前动态的 Cox–Ross–Rubinstein (CRR) 二叉树模型。时间被离散为 $N$ 个长度为 $\\Delta t = T/N$ 的等长步长。设连续复利无风险利率为 $r$，波动率为 $\\sigma$，初始价格为 $S_0$。定义乘法上涨和下跌因子以及风险中性概率如下：\n- $u = e^{\\sigma \\sqrt{\\Delta t}}$，\n- $d = 1/u$，\n- $p = \\dfrac{e^{r \\Delta t} - d}{u - d}$。\n\n为派息前过程构建一个重组股价网格：\n- $S_{\\text{base}}(j,i) = S_0 \\, u^i \\, d^{j-i}$，其中时间指数 $j \\in \\{0,1,\\dots,N\\}$，节点指数 $i \\in \\{0,1,\\dots,j\\}$。\n\n将每次离散股息作为在特定网格对齐的除息时间 $t_j = j \\Delta t$ 支付的外生现金金额 $D_j$ 纳入模型。若在时间 $\\tau$ 发生金额为 $D$ 的股息，它将通过 $j = \\operatorname{round}(\\tau/\\Delta t)$ 与网格对齐，并且只要 $0 \\le \\tau \\le T$，它就贡献给 $D_j$。在同一时间指数上的多个股息必须求和。在任何除息时间指数 $j$，该节点的可交易除息后股价为\n- $S_{\\text{eff}}(j,i) = \\max\\{ S_{\\text{base}}(j,i) - D_j, 0 \\}$，\n否则 $S_{\\text{eff}}(j,i) = S_{\\text{base}}(j,i)$。这模拟了除息瞬间的价格下跌，并强制股价非负。\n\n设 $V(j,i)$ 表示在时间指数 $j$ 和节点 $i$ 的美式看涨期权价值。将到期时的期末收益设置为\n- $V(N,i) = \\max\\{ S_{\\text{eff}}(N,i) - K, 0 \\}$，\n其中 $K$ 是行权价。对于反向归纳，对每个 $j = N-1, N-2, \\dots, 0$ 和 $i \\in \\{0,1,\\dots,j\\}$，使用折现因子 $e^{-r \\Delta t}$ 的单步风险中性估值计算持续价值：\n- $C(j,i) = e^{-r \\Delta t} \\left( p \\, V(j+1,i+1) + (1-p) \\, V(j+1,i) \\right)$。\n使用经除息调整后的股票计算在时间 $j$ 的立即行权价值：\n- $E(j,i) = \\max\\{ S_{\\text{eff}}(j,i) - K, 0 \\}$。\n然后通过以下方式强制执行提前行权：\n- $V(j,i) = \\max\\{ E(j,i), \\, C(j,i) \\}$。\n\n要求的输出是时间为 $0$ 时的价格 $V(0,0)$。\n\n您的程序必须实现上述内容，并为以下测试套件中的每个参数集计算价格。所有股息时间均以年为单位，并保证如上所述与二叉树网格精确对齐。任何严格大于 $T$ 的股息时间都必须被忽略。对于每种情况，输出一个四舍五入到六位小数的浮点数。\n\n测试套件（每一项是一个元组 $(S_0, K, r, \\sigma, T, N, \\text{dividends})$，其中 dividends 是 $(\\tau, D)$ 的列表）：\n\n- Case A (一般情况，多重股息): $(\\$100, \\$100, 0.05, 0.2, 1.0, 200, [ (0.5, \\$1.0), (0.75, \\$1.0) ])$。\n- Case B (无股息): $(\\$100, \\$100, 0.05, 0.2, 1.0, 200, [\\,])$。\n- Case C (到期后股息，应被忽略): $(\\$100, \\$100, 0.05, 0.2, 1.0, 200, [ (1.5, \\$2.0) ])$。\n- Case D (导致下跌后价格触底为零的大额股息): $(\\$50, \\$40, 0.01, 0.25, 0.5, 100, [ (0.25, \\$60.0) ])$。\n- Case E (到期日股息): $(\\$120, \\$100, 0.03, 0.15, 1.0, 200, [ (1.0, \\$5.0) ])$。\n- Case F (单步边界情况): $(\\$100, \\$90, 0.1, 0.3, 0.25, 1, [ (0.25, \\$2.0) ])$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如 $[x_1,x_2,\\dots,x_6]$），其中每个 $x_k$ 是对应案例的价格，四舍五入到六位小数，没有多余的空格。", "solution": "对提出的问题进行了严格验证。\n\n**步骤 1：提取已知条件**\n\n该问题为带有离散股息的股票上的美式看涨期权建模提供了以下数学定义和参数：\n-   到期时间 $T$，时间步数 $N$，时间步长 $\\Delta t = T/N$。\n-   初始股价 $S_0$，行权价 $K$。\n-   连续复利无风险利率 $r$，波动率 $\\sigma$。\n-   Cox-Ross-Rubinstein (CRR) 模型参数：上涨因子 $u = e^{\\sigma \\sqrt{\\Delta t}}$，下跌因子 $d = 1/u$，以及风险中性概率 $p = \\dfrac{e^{r \\Delta t} - d}{u - d}$。\n-   时间指数 $j \\in \\{0, 1, \\dots, N\\}$ 和节点指数 $i \\in \\{0, 1, \\dots, j\\}$ 处的基准股价：$S_{\\text{base}}(j,i) = S_0 \\, u^i \\, d^{j-i}$。\n-   股息处理：股息 $(D, \\tau)$ 被分配到时间指数 $j = \\operatorname{round}(\\tau/\\Delta t)$。同一指数 $j$ 上的所有股息被累加为总额 $D_j$。\n-   有效除息后股价：$S_{\\text{eff}}(j,i) = \\max\\{S_{\\text{base}}(j,i) - D_j, 0\\}$。如果在时间 $j$ 没有股息，则 $D_j=0$。\n-   到期时（时间 $N$）的期权价值：$V(N,i) = \\max\\{ S_{\\text{eff}}(N,i) - K, 0 \\}$。\n-   时间 $j$ 的持续价值：$C(j,i) = e^{-r \\Delta t} \\left( p \\cdot V(j+1,i+1) + (1-p) \\cdot V(j+1,i) \\right)$。\n-   时间 $j$ 的立即行权价值：$E(j,i) = \\max\\{ S_{\\text{eff}}(j,i) - K, 0 \\}$。\n-   美式期权价值递归：$V(j,i) = \\max\\{ E(j,i), C(j,i) \\}$。\n-   目标是计算初始期权价格 $V(0,0)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题指定了一个修正的二叉树模型来为美式期权定价，这是计算金融的基石。该框架源于风险中性世界中的基本无套利原则。从股价中减去股息现值的方法是标准的学术和行业实践。该问题具有科学合理性。\n-   **适定性**：该问题被表述为一个递归算法（反向归纳）。对于给定的输入参数集，该算法会为期权生成一个单一、唯一的价格。解的存在性和唯一性由问题的结构保证。\n-   **客观性与完整性**：该问题使用精确、无歧义的数学形式化表述。测试案例所需的所有参数和数据均已提供。该模型自成体系，不含主观因素。\n\n**步骤 3：结论与行动**\n\n该问题被判定为有效。它是金融工程中一个定义明确的标准问题。我将继续提供完整的解决方案。\n\n该解决方案通过在二叉晶格上进行反向归纳来构建。算法的核心是确定树中每个节点的期权价值，从到期时的终端节点开始，反向工作到时间 $t=0$ 的初始节点。\n\n首先，我们预处理所提供的股息流。使用一个按时间步 $j \\in \\{0, \\dots, N\\}$ 索引的一维数组来存储在每个离散时间点支付的总股息金额 $D_j$。对于在时间 $\\tau$ 支付的金额为 $D$ 的每个股息，我们计算其对应的时间指数 $j = \\operatorname{round}(\\tau/\\Delta t)$。如果 $\\tau \\le T$（即 $j \\le N$），则将金额 $D$ 加到总额 $D_j$ 中。\n\n反向归纳过程如下：\n\n1.  **到期时初始化（$j=N$）**：每个终端节点 $i \\in \\{0, \\dots, N\\}$ 的期权价值为其内在价值。用于此计算的股价必须是除息后价格。\n    -   基准（派息前）股价为 $S_{\\text{base}}(N,i) = S_0 u^i d^{N-i}$。\n    -   有效（除息后）股价为 $S_{\\text{eff}}(N,i) = \\max\\{ S_{\\text{base}}(N,i) - D_N, 0 \\}$。\n    -   期末期权价值为 $V(N,i) = \\max\\{ S_{\\text{eff}}(N,i) - K, 0 \\}$。\n    这些值存储在一个大小为 $N+1$ 的数组中。\n\n2.  **反向递归（$j = N-1, N-2, \\dots, 0$）**：对于每个时间步 $j$ 和每个节点 $i \\in \\{0, \\dots, j\\}$，期权价值 $V(j,i)$ 由无套利原则确定，该原则规定价值必须是其立即行权价值和其持续价值中的较大者。\n    -   **持续价值** $C(j,i)$ 是在风险中性测度下计算的下一时间步期权的折现期望值：\n        $$C(j,i) = e^{-r \\Delta t} \\left( p \\cdot V(j+1,i+1) + (1-p) \\cdot V(j+1,i) \\right)$$\n        这里，$V(j+1,i+1)$ 和 $V(j+1,i)$ 是在步骤 $j+1$ 已经计算出的期权价值。\n    -   **立即行权价值** $E(j,i)$ 是如果期权在此节点行权所获得的回报。这是使用该节点的除息后股价计算的：\n        $$E(j,i) = \\max\\{ S_{\\text{eff}}(j,i) - K, 0 \\} = \\max\\{ \\max\\{S_{\\text{base}}(j,i) - D_j, 0\\} - K, 0 \\}$$\n        其中 $S_{\\text{base}}(j,i) = S_0 u^i d^{j-i}$。\n    -   然后，美式期权价值是这两者中的最大值：\n        $$V(j,i) = \\max\\{ C(j,i), E(j,i) \\}$$\n    这个过程重复进行，从树的末端向后推导。一个大小为 $N+1$ 的数组足以进行计算，其中在每个步骤 $j$，步骤 $j+1$ 的值被步骤 $j$ 的新值覆盖。\n\n3.  **最终结果**：循环完成后，数组包含一个相关的单一值 $V(0,0)$，即时间 $t=0$ 时的美式期权价格。这是最终结果。\n\n对每个提供的测试案例实施此算法，以计算所需的期权价格。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def price_american_call_dividend_tree(S0, K, r, sigma, T, N, dividends):\n        \"\"\"\n        Prices an American call option on a stock with discrete dividends using a binomial tree.\n\n        Args:\n            S0 (float): Initial stock price.\n            K (float): Strike price.\n            r (float): Risk-free interest rate (continuously compounded).\n            sigma (float): Volatility.\n            T (float): Time to maturity in years.\n            N (int): Number of time steps in the binomial tree.\n            dividends (list): A list of tuples (tau, D), where tau is the dividend time in years\n                              and D is the dividend amount.\n\n        Returns:\n            float: The calculated price of the American call option.\n        \"\"\"\n        # 1. Parameter setup\n        dt = T / N\n        if sigma <= 0 or dt <= 0: # Handle edge cases\n             # For a single-step model where T=0, an immediate exercise check is all that's needed.\n             # This simple case is handled well by the general logic if dt is small but non-zero.\n             # If dt=0, we can evaluate only at t=0.\n             if T == 0:\n                 div_at_0 = sum(D for tau, D in dividends if tau == 0)\n                 return max(S0 - div_at_0 - K, 0)\n             else: # sigma=0, T>0\n                 # In a zero-volatility world, the stock price grows deterministically.\n                 # S(T) = S0 * exp(r*T) - sum of future value of dividends.\n                 fwd_price = S0 * np.exp(r * T)\n                 for tau, D in dividends:\n                     if 0 < tau <= T:\n                         fwd_price -= D * np.exp(r * (T - tau))\n                 payoff_at_T = max(fwd_price - K, 0)\n                 # Exercise value at t=0\n                 div_at_0 = sum(D for tau, D in dividends if tau == 0)\n                 exercise_at_0 = max(S0 - div_at_0 - K, 0)\n                 # Value is max of discounted payoff or immediate exercise\n                 return max(exercise_at_0, payoff_at_T * np.exp(-r*T))\n        \n        u = np.exp(sigma * np.sqrt(dt))\n        d = 1 / u\n        p = (np.exp(r * dt) - d) / (u - d)\n        discount = np.exp(-r * dt)\n\n        # 2. Process dividends into a time-step indexed array\n        # Problem guarantees dividend times align, so tau/dt will be an integer.\n        div_amounts = np.zeros(N + 1)\n        for tau, D in dividends:\n            if tau > T + 1e-9: # Ignore dividends after maturity, add tolerance\n                continue\n            j = int(round(tau / dt))\n            # Ensure index is within bounds, though problem guarantees it\n            if 0 <= j <= N:\n                div_amounts[j] += D\n\n        # 3. Initialize option values at maturity (j=N)\n        V = np.zeros(N + 1)\n        for i in range(N + 1):\n            s_base_N = S0 * (u**i) * (d**(N - i))\n            s_eff_N = max(s_base_N - div_amounts[N], 0)\n            V[i] = max(s_eff_N - K, 0)\n\n        # 4. Perform backward induction\n        for j in range(N - 1, -1, -1):\n            for i in range(j + 1):\n                # Calculate continuation value\n                continuation_value = discount * (p * V[i + 1] + (1 - p) * V[i])\n                \n                # Calculate immediate exercise value\n                s_base_j = S0 * (u**i) * (d**(j - i))\n                s_eff_j = max(s_base_j - div_amounts[j], 0)\n                exercise_value = max(s_eff_j - K, 0)\n                \n                # Update option value with early exercise decision\n                V[i] = max(continuation_value, exercise_value)\n\n        # 5. Return the option price at t=0\n        return V[0]\n\n    test_cases = [\n        # Case A (general, multiple dividends)\n        (100.0, 100.0, 0.05, 0.2, 1.0, 200, [(0.5, 1.0), (0.75, 1.0)]),\n        # Case B (no dividends)\n        (100.0, 100.0, 0.05, 0.2, 1.0, 200, []),\n        # Case C (dividend after maturity, should be ignored)\n        (100.0, 100.0, 0.05, 0.2, 1.0, 200, [(1.5, 2.0)]),\n        # Case D (large dividend causing post-drop floor at zero)\n        (50.0, 40.0, 0.01, 0.25, 0.5, 100, [(0.25, 60.0)]),\n        # Case E (dividend at maturity)\n        (120.0, 100.0, 0.03, 0.15, 1.0, 200, [(1.0, 5.0)]),\n        # Case F (single-step boundary)\n        (100.0, 90.0, 0.1, 0.3, 0.25, 1, [(0.25, 2.0)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, K, r, sigma, T, N, dividends = case\n        price = price_american_call_dividend_tree(S0, K, r, sigma, T, N, dividends)\n        results.append(round(price, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "金融工程经常会提出一些考验我们对估值原则理解的难题。本练习介绍了一种“自我参照”期权，这是一种有趣的金融工具，其行权价就是其自身未知的初始价格 $C_0$。你的任务是将这个看似循环定义的难题转化为一个定义明确的数学问题，并求解其唯一价格。这个实践突出了将问题表述为不动点方程并应用稳健的数值求根方法的能力，这是计算金融学中的一项关键技能。[@problem_id:2420984]", "id": "2420984", "problem": "要求您实现一个完整、可运行的程序，在 Black–Scholes 框架下计算一个自我参照欧式期权的 $0$ 时刻价格。该期权在时间 $T$ 的到期回报为 $\\max(0, S_T - C_0)$，其中 $S_T$ 是时间 $T$ 的标的价格，而 $C_0$ 是未知的 $0$ 时刻期权价格本身。模型假设为标准的 Black–Scholes 假设：无摩擦市场、无套利、恒定的无风险利率 $r$、零股息，以及在风险中性测度下，标的价格遵循几何布朗运动（GBM）。估值必须源自风险中性定价原则，即从无套利价格等于回报的贴现风险中性期望这一定义出发。您只能使用广泛接受、经过充分检验的事实作为基础，不得依赖未经证明或临时的公式。\n\n您的任务是：\n1. 从风险中性定价的定义出发，将此自我参照期权的定价问题表述为一个关于未知数 $C_0$ 的一维非线性方程。\n2. 通过引用单调性和无套利所蕴含的适当边界，解释在给定假设下为何存在唯一解。\n3. 设计一个稳健的数值算法来求解 $C_0$。您的算法必须：\n   - 适用于 $S_0 \\ge 0$，$r \\in \\mathbb{R}$，$\\sigma \\ge 0$ 和 $T \\ge 0$ 的一般参数值。\n   - 能处理 $\\sigma = 0$ 和 $T = 0$ 等边界情况，而不会出现除以零或未定义的操作。\n   - 使用一种保证收敛的区间法（例如，二分法）来求解非线性方程。\n4. 将算法实现在一个单一程序中。您可以将 Black–Scholes 模型下欧式看涨期权价格的标准闭式解以及标准正态累积分布函数（CDF）作为经过充分检验的事实来使用。如果您使用 CDF，应以数学术语明确定义它。\n\n使用以下测试套件。每个测试用例指定 $(S_0, r, \\sigma, T)$：\n- 测试 $1$：$(100, 0.02, 0.2, 1)$\n- 测试 $2$：$(100, 0.05, 0, 1)$\n- 测试 $3$：$(100, 0.05, 0.3, 0)$\n- 测试 $4$：$(50, 0.10, 1.0, 2)$\n- 测试 $5$：$(10, 0, 0.1, 5)$\n- 测试 $6$：$(1, 0, 0, 3)$\n\n您的程序的所需输出是一行包含六个测试的计算价格 $C_0$ 的列表，顺序与上面列出的一致，四舍五入到恰好 $8$ 位小数，且没有空格。例如，输出格式必须与 $[x_1,x_2,x_3,x_4,x_5,x_6]$ 完全一样，其中每个 $x_i$ 是一个格式化为恰好 $8$ 位小数的浮点数。\n\n不涉及物理单位。此任务中没有角度或百分比。\n\n您的程序必须是自包含的，不得要求任何用户输入，并必须遵守指定的执行环境。它在运行时必须以指定格式生成最终输出行。", "solution": "所提出的问题是确定一个自我参照欧式期权的 $0$ 时刻价格，记为 $C_0$。此期权在到期日 $T$ 的回报为 $\\max(0, S_T - C_0)$，其中 $S_T$ 是标的资产在时间 $T$ 的价格。这个问题定义明确，科学上合理，且处于标准的 Black-Scholes 框架之内。我们着手进行求解。\n\n无套利定价的基本原则规定，任何衍生证券的价格都是其未来回报在风险中性概率测度 $\\mathbb{Q}$ 下的贴现期望值。对于这个特定的期权，我们表示为：\n$$ C_0 = e^{-rT} \\mathbb{E}_{\\mathbb{Q}} \\left[ \\max(0, S_T - C_0) | \\mathcal{F}_0 \\right] $$\n其中 $r$ 是恒定的无风险利率，$T$ 是到期时间，$\\mathcal{F}_0$ 代表在时间 $t=0$ 时可用的信息。\n\n右侧的表达式恰好是行权价为 $K = C_0$ 的标准欧式看涨期权的 Black-Scholes 价格的定义。我们将 Black-Scholes 看涨期权价格表示为一个函数 $BS(S_t, K, r, \\sigma, \\tau)$，其中 $S_t$ 是时间 $t$ 的资产价格，$K$ 是行权价，$r$ 是无风险利率，$\\sigma$ 是波动率，$\\tau = T-t$ 是距离到期的时间。在时间 $t=0$ 时，我们有 $\\tau=T$。因此，该自我参照期权的定价关系变成一个关于 $C_0$ 的非线性方程：\n$$ C_0 = BS(S_0, C_0, r, \\sigma, T) $$\n\n为了求解 $C_0$，我们定义一个函数 $f(C)$，使得找到 $f(C)=0$ 的根即可得到期权价格：\n$$ f(C) = BS(S_0, C, r, \\sigma, T) - C $$\n欧式看涨期权的 Black-Scholes 公式由下式给出：\n$$ BS(S_0, K, r, \\sigma, T) = S_0 N(d_1) - K e^{-rT} N(d_2) $$\n其中 $N(x)$ 是标准正态分布的累积分布函数（CDF），\n$$ N(x) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} e^{-z^2/2} dz $$\n$d_1$ 和 $d_2$ 项为：\n$$ d_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} \\quad \\text{和} \\quad d_2 = d_1 - \\sigma\\sqrt{T} $$\n将 $K=C$ 代入这些表达式，我们得到函数 $f(C)$ 的完整形式。\n\n在设计数值算法之前，我们必须证明唯一解 $C_0$ 的存在性。\n首先，我们确定 $C_0$ 的界限。期权的回报 $\\max(0, S_T - C_0)$ 始终是非负的，所以其价格也必须是非负的，$C_0 \\ge 0$。该回报也严格小于 $S_T$（除非 $C_0 \\le 0$，但这对于一个非平凡期权是不可能的）。一个回报为 $S_T$ 的期权等同于持有标的资产（假设零股息），其价格为 $S_0$。根据优势原则，$C_0 < S_0$。因此，任何有效解都必须位于区间 $[0, S_0)$ 内。\n\n解的存在性可通过介值定理来证明。函数 $f(C)$ 在区间 $[0, S_0]$ 上是连续的，因为 Black-Scholes 价格函数相对于其行权价 $K$ 是连续的。我们在该区间的边界上计算 $f(C)$ 的值：\n1.  当 $C=0$ 时：行权价为零。一个零行权价的看涨期权是一种在到期时支付 $S_T$ 的金融工具。其 $0$ 时刻价格为 $S_0$。因此，$BS(S_0, 0, r, \\sigma, T) = S_0$。\n    $f(0) = BS(S_0, 0, r, \\sigma, T) - 0 = S_0$。对于 $S_0 > 0$ 的非平凡情况，我们有 $f(0) > 0$。\n2.  当 $C=S_0$ 时：行权价等于初始股票价格。\n    $f(S_0) = BS(S_0, S_0, r, \\sigma, T) - S_0$。看涨期权的价格总是严格小于标的资产的价格，即 $BS(S_t, K, \\dots) < S_t$，因为它只提供了对资产的或有索取权。因此，$BS(S_0, S_0, r, \\sigma, T) < S_0$，这意味着 $f(S_0) < 0$。\n\n由于 $f(C)$ 是连续的，并且 $f(0) > 0$ 和 $f(S_0) < 0$，因此在 $(0, S_0)$ 内必然存在至少一个根 $C_0$。\n\n解的唯一性通过证明 $f(C)$ 是一个严格单调函数来确立。我们考察它关于 $C$ 的导数：\n$$ f'(C) = \\frac{d}{dC} \\left( BS(S_0, C, r, \\sigma, T) \\right) - 1 $$\nBlack-Scholes 看涨期权价格对行权价 $K$ 的导数是金融数学中的一个标准结果：\n$$ \\frac{\\partial BS}{\\partial K} = -e^{-rT} N(d_2) $$\n用 $C$ 替换 $K$，我们得到 $f(C)$ 的导数：\n$$ f'(C) = -e^{-rT} N(d_2(C)) - 1 $$\n由于 $e^{-rT} > 0$ 且累积分布函数 $N(d_2)$ 的取值在 $[0, 1]$ 之间，项 $-e^{-rT}N(d_2(C))$ 始终是非正的。因此，$f'(C) \\le -1$，这意味着对于所有 $C>0$，$f'(C)$ 都是严格为负的。一个导数严格为负的函数是严格单调递减的。一个严格单调的函数最多与横轴相交一次。这一点，再加上存在性的证明，保证了存在唯一的解 $C_0$。\n\n寻找 $C_0$ 的数值算法必须处理存在闭式解的特定边界情况，从而避免诸如除以零之类的数值不稳定性。\n情况 1：$T=0$。立即到期。估值方程变为 $C_0 = \\max(0, S_0 - C_0)$。如果 $S_0 - C_0 \\le 0$，那么 $C_0=0$。这只在 $S_0=0$ 时才可能。如果 $S_0 - C_0 > 0$，那么 $C_0 = S_0 - C_0$，得到 $2C_0 = S_0$，所以 $C_0 = S_0/2$。这对任何 $S_0 > 0$ 都成立。解为 $C_0 = S_0/2$。\n\n情况 2：$\\sigma=0$ 且 $T>0$。资产价格确定性增长：$S_T = S_0 e^{rT}$。估值方程为：\n$$ C_0 = e^{-rT} \\max(0, S_0 e^{rT} - C_0) = \\max(0, S_0 - e^{-rT} C_0) $$\n和之前一样，对于 $S_0 > 0$，解必须为正，所以我们有 $C_0 = S_0 - e^{-rT} C_0$。\n求解 $C_0$ 得到 $C_0(1 + e^{-rT}) = S_0$，结果为 $C_0 = \\frac{S_0}{1 + e^{-rT}}$。\n\n一般情况：$T>0$ 且 $\\sigma>0$。我们使用二分法求解非线性方程 $f(C)=0$。鉴于我们已证明在一个已知区间内存在唯一根，此方法是稳健的且保证收敛。\n二分法算法流程如下：\n1.  初始化搜索区间（托架）为 $[a, b] = [0, S_0]$。我们已经证明了 $f(a) > 0$ 且 $f(b) < 0$。如果 Black-Scholes 公式的实现在 $K=0$ 时不够稳健，可以使用一个小的正数作为 $a$ 来避免数值问题，但一个正确的实现应当能正确处理 $K=0$ 的情况（价格为 $S_0$）。\n2.  迭代直到区间宽度 $(b-a)$ 小于预设的容差 $\\epsilon$：\n    a. 计算中点 $m = a + (b-a)/2$。\n    b. 计算 $f(m) = BS(S_0, m, r, \\sigma, T) - m$。\n    c. 如果 $f(m)$ 与 $f(a)$ 同号（即 $f(m)>0$），则根必在 $[m, b]$ 区间内。设置 $a=m$。\n    d. 否则，根在 $[a, m]$ 区间内。设置 $b=m$。\n3.  根 $C_0$ 的最终近似值是最后区间的中心点，即 $(a+b)/2$。\n\n此过程提供了一个在指定的 Black-Scholes 假设下计算自我参照期权价格的完整且稳健的方法。实现将遵循此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints the final result.\n    \"\"\"\n\n    test_cases = [\n        (100.0, 0.02, 0.2, 1.0),   # Test 1\n        (100.0, 0.05, 0.0, 1.0),   # Test 2\n        (100.0, 0.05, 0.3, 0.0),   # Test 3\n        (50.0, 0.10, 1.0, 2.0),    # Test 4\n        (10.0, 0.0, 0.1, 5.0),    # Test 5\n        (1.0, 0.0, 0.0, 3.0),     # Test 6\n    ]\n\n    results = []\n    for params in test_cases:\n        s0, r, sigma, t = params\n        price = compute_self_referential_option_price(s0, r, sigma, t)\n        results.append(f\"{price:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef black_scholes_call_price(s0, k, r, sigma, t):\n    \"\"\"\n    Computes the price of a European call option using the Black-Scholes formula.\n    Handles the edge case of t=0 or sigma=0, which should be pre-empted,\n    but provides a safe fallback.\n    \"\"\"\n    if t <= 0 or sigma <= 0:\n        # Payoff is deterministic: max(0, s0 - k)\n        return max(0.0, s0 - k)\n\n    # To avoid log(0) or division by zero for k=0\n    if k <= 1e-12:\n        return s0\n\n    d1 = (np.log(s0 / k) + (r + 0.5 * sigma**2) * t) / (sigma * np.sqrt(t))\n    d2 = d1 - sigma * np.sqrt(t)\n\n    price = s0 * norm.cdf(d1) - k * np.exp(-r * t) * norm.cdf(d2)\n    return price\n\ndef compute_self_referential_option_price(s0, r, sigma, t):\n    \"\"\"\n    Computes the time-0 price of the self-referential option.\n    The payoff is max(0, S_T - C_0), where C_0 is the price itself.\n    \"\"\"\n    # Trivial case: if S0 is 0, the option price is 0.\n    if s0 <= 0:\n        return 0.0\n\n    # Boundary case: T=0. The price is C0 = max(0, S0 - C0), which gives C0 = S0/2.\n    if t == 0:\n        return s0 / 2.0\n\n    # Boundary case: sigma=0. The price is C0 = S0 / (1 + exp(-r*T)).\n    if sigma == 0:\n        return s0 / (1.0 + np.exp(-r * t))\n\n    # General case: Solve C = BS(S0, C, r, sigma, T) using bisection.\n    # We are looking for the root of f(C) = BS(S0, C, ...) - C = 0.\n    def f(c):\n        if c <= 0:\n            # For C -> 0, BS price -> S0. Thus f(0) = S0.\n            return s0\n        return black_scholes_call_price(s0, c, r, sigma, t) - c\n\n    # The root C0 is guaranteed to be in [0, S0].\n    low = 0.0\n    high = s0\n\n    # Check signs at boundaries (as proved in theory)\n    # f(low) = f(0) = S0 > 0\n    # f(high) = f(S0) = BS(S0, S0, ...) - S0 < 0\n    # If for some reason f(high) is not negative (e.g., numerical precision),\n    # the bisection might fail. This is not expected for valid parameters.\n\n    tolerance = 1e-12\n    max_iterations = 100\n\n    for _ in range(max_iterations):\n        mid = low + (high - low) / 2.0\n        if mid == low or mid == high: # Precision limit reached\n            break\n            \n        f_mid = f(mid)\n\n        if f_mid == 0:\n            return mid\n        elif f(low) * f_mid < 0: # Root is in the lower half\n            high = mid\n        else: # Root is in the upper half\n            low = mid\n        \n        if (high - low) < tolerance:\n            break\n\n    return (low + high) / 2.0\n\nsolve()\n```"}, {"introduction": "我们的最终实践将进入高级奇异期权的领域，在这些期权中，持有人的行为直接决定了其收益。“护照期权”（Passport Option）给予持有人一本交易标的资产的“护照”，最终收益是由此产生的利润。为这种期权定价需要超越静态收益的范畴，进入动态随机控制的领域。本练习将指导你运用伊藤积分和凸性论证的原理来确定最优交易策略，并最终确定期权的公允价值。[@problem_id:2421058]", "id": "2421058", "problem": "考虑一份针对单一期货合约的欧式“护照期权”，其到期时间为 $T$。在风险中性测度下，期货价格过程 $\\{F_{t}\\}_{t \\in [0,T]}$ 服从一个漂移为零、波动率恒定的算术布朗运动：$dF_{t} = \\sigma \\, dW_{t}$，其中 $\\{W_{t}\\}$ 是一个标准布朗运动，$\\sigma > 0$ 是一个常数，且连续复利无风险利率为零。该期权的持有者初始财富为零，可以通过自融资策略动态地交易该期货合约，且无交易成本。令 $h_{t}$ 表示在时间 $t$ 持有的期货合约数量，其中 $h_{t}$ 相对于由 $\\{W_{t}\\}$ 生成的域流是循序可测的，并由一个已知的常数 $H > 0$ 一致有界，即对于所有 $t \\in [0,T]$ 都有 $|h_{t}| \\le H$。累计交易盈亏 (P&amp;L) 过程由 $X_{t} = \\int_{0}^{t} h_{u} \\, dF_{u}$ 给出，且 $X_{0} = 0$。期权的支付是终端盈亏的正数部分，即 $\\max\\{X_{T}, 0\\}$。\n\n请仅使用风险中性测度下的基础无套利估值、伊藤积分的性质以及基本的凸性论证，推导护照期权在时间 $0$ 的价格关于 $H$、$\\sigma$ 和 $T$ 的闭式表达式。请以单一解析表达式的形式给出最终答案。不需要数值近似，也不应进行任何四舍五入。", "solution": "分析问题陈述后，确认其有效。这是一个数学金融中的适定问题，基于标准的无套利定价理论和随机微积分。所有必需的参数均已提供，不存在内部矛盾或不符合科学原理的假设。现在我将开始推导解答。\n\n护照期权在时间 $0$ 的价格，记为 $V_0$，由其支付在所有容许交易策略下的风险中性期望的上确界给出。鉴于无风险利率 $r=0$，定价公式为：\n$$ V_0 = \\sup_{h \\in \\mathcal{A}} E\\left[ \\max\\{X_T, 0\\} \\right] $$\n此处，$X_T$ 是终端盈亏 (P&L)，而 $\\mathcal{A}$ 代表容许策略集。一个容许策略 $h = \\{h_t\\}_{t \\in [0,T]}$ 是相对于布朗运动 $\\{W_t\\}$ 生成的域流而言的循序可测过程，并受到约束 $|h_t| \\le H$ 的限制，其中 $H>0$ 为给定常数。\n\n盈亏过程由伊藤积分 $X_t = \\int_{0}^{t} h_u \\, dF_u$ 定义。利用指定的期货价格动态 $dF_t = \\sigma \\, dW_t$，终端盈亏为：\n$$ X_T = \\int_{0}^{T} h_u \\sigma \\, dW_u $$\n由于 $h_u$ 是有界的、循序可测的被积函数，过程 $X_t$ 是一个从 $X_0=0$ 开始的连续鞅。该过程的二次变分为：\n$$ \\langle X, X \\rangle_T = \\int_{0}^{T} (h_u \\sigma)^2 \\, du = \\sigma^2 \\int_{0}^{T} h_u^2 \\, du $$\n这类伊藤积分的一个基本性质是，$X_T$ 的概率分布与一个时间变换的布朗运动相同。具体来说，$X_T$ 与 $B_{\\langle X, X \\rangle_T}$ 同分布，其中 $B_t$ 是一个独立于由 $W_t$ 生成的域流的标准布朗运动。时间变换是二次变分 $\\langle X, X \\rangle_T$，它本身是一个依赖于策略 $h_t$ 的随机变量。\n\n支付的期望可以通过使用全期望定律来计算，首先对二次变分的值取条件：\n$$ E\\left[ \\max\\{X_T, 0\\} \\right] = E\\left[ E\\left[ \\max\\{B_{\\langle X, X \\rangle_T}, 0\\} \\mid \\mathcal{F}_T^W \\right] \\right] $$\n内层期望是关于布朗运动 $B$ 的分布来计算的。给定二次变分的值 $\\langle X, X \\rangle_T = v$，随机变量 $B_v$ 服从均值为 $0$、方差为 $v$ 的正态分布。一个随机变量 $Y \\sim N(0, v)$ 的正数部分的期望是一个标准结果：\n$$ E[\\max\\{Y, 0\\}] = \\int_0^\\infty y \\frac{1}{\\sqrt{2\\pi v}} \\exp\\left(-\\frac{y^2}{2v}\\right) dy = \\sqrt{\\frac{v}{2\\pi}} $$\n应用此结果，对于一个特定策略 $h$，期权的价值为：\n$$ V_h = E\\left[ \\sqrt{\\frac{\\langle X, X \\rangle_T}{2\\pi}} \\right] = \\frac{1}{\\sqrt{2\\pi}} E\\left[ \\sqrt{\\sigma^2 \\int_0^T h_u^2 \\, du} \\right] = \\frac{\\sigma}{\\sqrt{2\\pi}} E\\left[ \\sqrt{\\int_0^T h_u^2 \\, du} \\right] $$\n任务简化为在所有容许策略 $h$ 上找到该表达式的上确界：\n$$ V_0 = \\sup_{|h_t|\\le H} \\left( \\frac{\\sigma}{\\sqrt{2\\pi}} E\\left[ \\sqrt{\\int_0^T h_u^2 \\, du} \\right] \\right) $$\n令随机变量 $Z$ 定义为 $Z = \\int_0^T h_u^2 \\, du$。我们必须最大化 $E[\\sqrt{Z}]$。函数 $f(z) = \\sqrt{z}$ 在 $z > 0$ 上是严格凹函数。我们可以应用针对凹函数的琴生不等式：\n$$ E\\left[ \\sqrt{Z} \\right] \\le \\sqrt{E[Z]} $$\n我们现在求 $E[Z]$ 的一个上界：\n$$ E[Z] = E\\left[ \\int_0^T h_u^2 \\, du \\right] = \\int_0^T E[h_u^2] \\, du $$\n根据容许性约束 $|h_u| \\le H$，可以得出 $h_u^2 \\le H^2$。取期望，则 $E[h_u^2] \\le H^2$。因此：\n$$ E[Z] \\le \\int_0^T H^2 \\, du = H^2 T $$\n结合这些结果，可以得到期权价格的一个上界：\n$$ V_0 \\le \\frac{\\sigma}{\\sqrt{2\\pi}} \\sqrt{H^2 T} = \\frac{\\sigma H \\sqrt{T}}{\\sqrt{2\\pi}} $$\n如果我们能找到一个容许策略 $h_t$，使得琴生不等式中的等号成立，那么这个上界就可以达到。对于一个严格凹函数，这要求随机变量 $Z$ 几乎必然是一个常数。为了达到可能的最大值，这个常数必须等于其期望的上界，即 $H^2 T$。\n\n考虑确定性策略 $h_t = H$（对于所有 $t \\in [0, T]$）。该策略是容许的，因为它是常数（因此是循序可测的）并且满足边界条件 $|h_t| = H$。对于此策略，变量 $Z$ 为：\n$$ Z = \\int_0^T H^2 \\, du = H^2 T $$\n这个值是一个常数。因此，$E[\\sqrt{Z}] = \\sqrt{H^2 T} = H\\sqrt{T}$，且琴生不等式等号成立。\n对于这个特定策略，期权的价格是：\n$$ V_h = \\frac{\\sigma}{\\sqrt{2\\pi}} E[\\sqrt{H^2 T}] = \\frac{\\sigma H \\sqrt{T}}{\\sqrt{2\\pi}} $$\n这个值与推导出的上界相同。因此，该策略达到了上确界，护照期权在时间 $0$ 的价格就是这个值。对于期权持有者来说，最优行为是在期货合约中保持大小为 $H$（或 $-H$）的恒定头寸。", "answer": "$$\n\\boxed{H \\sigma \\sqrt{\\frac{T}{2\\pi}}}\n$$"}]}