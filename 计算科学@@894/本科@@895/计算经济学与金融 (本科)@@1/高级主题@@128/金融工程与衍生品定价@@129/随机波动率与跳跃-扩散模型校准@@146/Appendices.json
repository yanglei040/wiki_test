{"hands_on_practices": [{"introduction": "在深入研究复杂的优化技术之前，让我们从一个基础练习开始。这个练习旨在说明，在理想化的假设下，我们有时可以利用基本的统计原理直接推断模型参数。我们将使用一个简化的场景，在一个仿射期限结构模型中分离并估计跳跃强度和幅度，从而为这些参数的实际意义建立清晰的直觉。[@problem_id:2370067] 该练习的核心在于一个教学性的假设：在极短的时间内，市场冲击主要由跳跃驱动，这使我们能够直接从数据中识别其特征。", "id": "2370067", "problem": "给定风险中性测度下的单因子仿射跳跃短率模型，其中短率 $r_t$ 服从以下随机微分方程（SDE）\n$$\ndr_t \\;=\\; \\kappa \\,(\\theta - r_t)\\,dt \\;+\\; \\sigma\\, dW_t \\;+\\; J\\, dN_t,\n$$\n其中，均值回归速度为 $\\kappa &gt; 0$，长期水平为 $\\theta$，波动率为 $\\sigma \\ge 0$，标准维纳过程为 $W_t$，泊松跳跃过程为 $N_t$ 且其强度为常数 $\\lambda \\ge 0$。跳跃幅度 $J$ 是确定性的，等于一个常数 $\\mu_J$（以年化小数利率单位计）。对于在到期日 $\\tau$ 的连续复利零息收益率 $y(t,\\tau)$，该模型意味着一个仿射关系\n$$\ny(t,\\tau) \\;=\\; -\\frac{A(\\tau)}{\\tau} \\;+\\; \\frac{B(\\tau)}{\\tau}\\, r_t,\n$$\n其中 $B(\\tau) \\;=\\; \\frac{1 - e^{-\\kappa \\tau}}{\\kappa}$ 且 $A(\\tau)$ 是标准的 Vasicek 函数。在一个长度为 $\\Delta t$ 的极短区间内，假设到期日为 $\\tau$ 的收益率变化满足\n$$\n\\Delta y(t,\\tau) \\;=\\; \\frac{B(\\tau)}{\\tau} \\, \\Delta r_t,\n$$\n其中 $\\Delta r_t$ 表示该区间内短率的变化。在每个区间内，假设最多只能发生一次跳跃，扩散和漂移的贡献相对于跳跃可以忽略不计，并且跳跃幅度是确定性的 $\\mu_J$。因此，$\\Delta r_t$ 要么是 $0$（无跳跃），要么是 $\\mu_J$（一次跳跃）。令 $p = \\lambda \\Delta t$ 表示单个区间内发生一次跳跃的概率。\n\n您的任务是，根据在包含一次重大市场冲击的 $K$ 个日度区间内观测到的横截面收益率变化，校准跳跃强度 $\\lambda$（年化）和确定性跳跃幅度 $\\mu_J$（年化小数利率）。请使用上述 $\\Delta y$ 和 $\\Delta r$ 之间的已知关系以及所描述的模型假设，从数据中推断 $\\lambda$ 和 $\\mu_J$。\n\n使用以下固定参数和约定：\n- 到期日（年）：$\\{\\tau_i\\}_{i=1}^6 = \\{0.25,\\, 0.5,\\, 1.0,\\, 2.0,\\, 5.0,\\, 10.0\\}$。\n- 均值回归速度：$\\kappa = 0.3$（年化）。\n- 区间长度：$\\Delta t = \\frac{1}{252}$（年）。\n- 对于每个区间 $k$，载荷为 $L(\\tau_i) = \\frac{B(\\tau_i)}{\\tau_i}$，其中 $B(\\tau) = \\frac{1 - e^{-\\kappa \\tau}}{\\kappa}$。\n- 对于每个数据集，观测到的收益率变化向量 $\\{\\Delta y_k(\\tau_i)\\}_{i=1}^6$ 是由给定的短率增量 $\\{\\Delta r_k\\}$ 通过 $\\Delta y_k(\\tau_i) = L(\\tau_i)\\,\\Delta r_k$ 生成的。\n\n测试套件（三个数据集，涵盖不同情景）：\n1. 数据集 $\\mathbf{1}$（$K=5$ 天内发生冲击）：短率增量 $\\{\\Delta r_k\\}_{k=1}^5 = [0.0,\\, 0.0,\\, -0.015,\\, 0.0,\\, 0.0]$。\n2. 数据集 $\\mathbf{2}$（$K=4$ 天内无变化）：短率增量 $\\{\\Delta r_k\\}_{k=1}^4 = [0.0,\\, 0.0,\\, 0.0,\\, 0.0]$。\n3. 数据集 $\\mathbf{3}$（单日极端冲击，$K=1$）：短率增量 $\\{\\Delta r_k\\}_{k=1}^1 = [-0.02]$。\n\n对于每个数据集：\n- 使用载荷 $L(\\tau_i)$ 和给定的 $\\Delta r_k$ 构建收益率变化的横截面 $\\{\\Delta y_k(\\tau_i)\\}_{i=1}^6$。\n- 从这些收益率变化和模型关系中，估计跳跃强度 $\\lambda$（年化）和确定性跳跃幅度 $\\mu_J$（年化小数利率）。\n\n您的程序必须生成单行输出，其中包含一个由逗号分隔的三个元素的列表，每个元素本身是对应数据集的两个浮点数 $[\\lambda,\\mu_J]$ 组成的列表，两个数字都必须精确到六位小数。要求的最终输出格式为：\n$$\n[[\\lambda_1,\\mu_{J,1}],[\\lambda_2,\\mu_{J,2}],[\\lambda_3,\\mu_{J,3}]]\n$$\n例如，输出必须类似于 $[[a,b],[c,d],[e,f]]$，其中 $a,b,c,d,e,f$ 中的每一个都打印到六位小数。", "solution": "该问题已经过仔细审查并被认定为有效。这是一个针对特定随机模型的参数估计的明确定义的练习。数据生成过程（其中直接提供了底层的短率增量）将估计任务简化为统计定义的直接应用。我们接下来将进行求解。\n\n短率 $r_t$ 由以下随机微分方程建模：\n$$\ndr_t = \\kappa (\\theta - r_t)dt + \\sigma dW_t + J dN_t\n$$\n其中 $\\kappa$ 是均值回归速度，$\\theta$ 是长期均值，$\\sigma$ 是波动率，$W_t$ 是标准维纳过程，$N_t$ 是强度为常数 $\\lambda$ 的泊松过程。跳跃幅度 $J$ 是一个确定性常数，记为 $\\mu_J$。\n\n问题陈述，对于一个短时间区间 $\\Delta t$，短率的变化 $\\Delta r_t$ 可以通过仅考虑跳跃部分来近似，因为漂移和扩散被假设为可以忽略。此外，在任何区间 $\\Delta t$ 内最多只能发生一次跳跃。因此，短率的变化是二元的：\n$$\n\\Delta r_t =\n\\begin{cases}\n\\mu_J & \\text{如果发生跳跃} \\\\\n0 & \\text{如果没有发生跳跃}\n\\end{cases}\n$$\n单个区间内发生跳跃的概率由 $p = \\lambda \\Delta t$ 给出。\n\n到期日为 $\\tau$ 的零息收益率 $y(t,\\tau)$ 的变化通过仿射关系与短率变化相关联：\n$$\n\\Delta y(t,\\tau) = \\frac{B(\\tau)}{\\tau} \\Delta r_t = L(\\tau) \\Delta r_t\n$$\n其中载荷 $L(\\tau) = B(\\tau)/\\tau$ 是到期日 $\\tau$ 和参数 $\\kappa$ 的函数。\n\n任务是从给定的三个不同数据集的短率增量时间序列 $\\{\\Delta r_k\\}_{k=1}^K$ 中估计跳跃强度 $\\lambda$ 和跳跃幅度 $\\mu_J$。问题指示首先构建收益率变化，然后估计参数。然而，由于底层的短率增量 $\\Delta r_k$ 是直接提供的，并且关系 $\\Delta y_k(\\tau_i) = L(\\tau_i) \\Delta r_k$ 是精确的，任何从构建的 $\\Delta y_k(\\tau_i)$ 中估计 $\\Delta r_k$ 的尝试都只会复原所提供的 $\\Delta r_k$ 值。因此，问题简化为直接从序列 $\\{\\Delta r_k\\}_{k=1}^K$ 中估计 $(\\lambda, \\mu_J)$。\n\n估计逻辑如下：\n1. **跳跃幅度 $\\mu_J$ 的估计**：跳跃幅度 $\\mu_J$ 是确定性的。序列 $\\{\\Delta r_k\\}$ 中任何观测到的非零值都必须对应于一次跳跃，因此必须等于 $\\mu_J$。\n    - 如果非零增量的数量大于零，估计值 $\\hat{\\mu}_J$ 就是这些增量的唯一值。问题设置保证了每个数据集内的所有非零增量都是相同的，因为每个数据集只模拟一个跳跃事件。\n    - 如果没有非零增量（即没有观测到跳跃），参数 $\\mu_J$ 则无法从数据中进行统计识别。在这种情况下，一个标准且合乎逻辑的约定是将其估计值设为零，即 $\\hat{\\mu}_J = 0$，因为如果没有跳跃发生，其值是无关紧要的。\n\n2. **跳跃强度 $\\lambda$ 的估计**：在 $K$ 个区间中的任何一个区间观测到跳跃构成一次伯努利试验。设 $N_J$ 为观测到的跳跃总数，即序列 $\\{\\Delta r_k\\}_{k=1}^K$ 中非零元素的计数。单个区间内发生跳跃的概率 $p$ 的最大似然估计量是样本比例：\n$$\n\\hat{p} = \\frac{N_J}{K}\n$$\n根据关系 $p = \\lambda \\Delta t$，跳跃强度 $\\lambda$ 的估计量为：\n$$\n\\hat{\\lambda} = \\frac{\\hat{p}}{\\Delta t} = \\frac{N_J}{K \\Delta t}\n$$\n我们已知固定参数 $\\Delta t = 1/252$。\n\n我们现在将此方法应用于每个数据集。\n\n**数据集 1：**\n- 短率增量：$\\{\\Delta r_k\\}_{k=1}^5 = [0.0, 0.0, -0.015, 0.0, 0.0]$。\n- 区间数：$K = 5$。\n- 观测到的跳跃次数：$N_J = 1$。非零增量为 $-0.015$。\n- $\\mu_J$ 的估计：从单次观测到的跳跃中，我们直接确定跳跃幅度。\n$$\n\\hat{\\mu}_{J,1} = -0.015\n$$\n- $\\lambda$ 的估计：\n$$\n\\hat{\\lambda}_1 = \\frac{N_J}{K \\Delta t} = \\frac{1}{5 \\times (1/252)} = \\frac{252}{5} = 50.4\n$$\n\n**数据集 2：**\n- 短率增量：$\\{\\Delta r_k\\}_{k=1}^4 = [0.0, 0.0, 0.0, 0.0]$。\n- 区间数：$K = 4$。\n- 观测到的跳跃次数：$N_J = 0$。\n- $\\mu_J$ 的估计：没有观测到跳跃，因此 $\\mu_J$ 不可识别。我们应用约定。\n$$\n\\hat{\\mu}_{J,2} = 0.0\n$$\n- $\\lambda$ 的估计：\n$$\n\\hat{\\lambda}_2 = \\frac{N_J}{K \\Delta t} = \\frac{0}{4 \\times (1/252)} = 0.0\n$$\n\n**数据集 3：**\n- 短率增量：$\\{\\Delta r_k\\}_{k=1}^1 = [-0.02]$。\n- 区间数：$K = 1$。\n- 观测到的跳跃次数：$N_J = 1$。非零增量为 $-0.02$。\n- $\\mu_J$ 的估计：\n$$\n\\hat{\\mu}_{J,3} = -0.02\n$$\n- $\\lambda$ 的估计：\n$$\n\\hat{\\lambda}_3 = \\frac{N_J}{K \\Delta t} = \\frac{1}{1 \\times (1/252)} = 252.0\n$$\n\n总而言之，估计的参数为：\n- 对于数据集 $1$：$(\\hat{\\lambda}_1, \\hat{\\mu}_{J,1}) = (50.4, -0.015)$\n- 对于数据集 $2$：$(\\hat{\\lambda}_2, \\hat{\\mu}_{J,2}) = (0.0, 0.0)$\n- 对于数据集 $3$：$(\\hat{\\lambda}_3, \\hat{\\mu}_{J,3}) = (252.0, -0.02)$\n\n这些结果将按要求格式化为六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Estimates jump intensity (lambda) and jump magnitude (mu_J) for a one-factor\n    affine short-rate model with jumps, based on provided short-rate increments.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    delta_t = 1.0 / 252.0\n\n    # Test suite: three datasets of short-rate increments {delta_r_k}.\n    test_cases = [\n        [0.0, 0.0, -0.015, 0.0, 0.0],  # Dataset 1: K=5, one jump\n        [0.0, 0.0, 0.0, 0.0],         # Dataset 2: K=4, no jumps\n        [-0.02]                       # Dataset 3: K=1, one jump\n    ]\n\n    results = []\n    for dr_increments in test_cases:\n        # K is the total number of observation intervals in the dataset.\n        K = len(dr_increments)\n        \n        # We use a numpy array for efficient vectorized operations.\n        dr_array = np.array(dr_increments)\n        \n        # N_J is the number of observed jumps, counted as non-zero increments.\n        num_jumps = np.count_nonzero(dr_array)\n        \n        # Estimate lambda using the maximum likelihood estimator for a sequence of Bernoulli trials.\n        # lambda_hat = (N_J / K) / delta_t\n        if K > 0:\n            lambda_est = num_jumps / (K * delta_t)\n        else:\n            # This case will not be reached with the given test data.\n            lambda_est = 0.0\n\n        # Estimate mu_J, the deterministic jump magnitude.\n        if num_jumps > 0:\n            # If jumps are observed, mu_J is identified as the magnitude of these jumps.\n            # As mu_J is deterministic, all non-zero increments must be identical.\n            # We can take the first non-zero element.\n            mu_j_est = dr_array[dr_array != 0][0]\n        else:\n            # If no jumps are observed, mu_J is not statistically identifiable.\n            # We follow the standard convention of setting its estimate to 0,\n            # as its value is irrelevant in this scenario.\n            mu_j_est = 0.0\n            \n        results.append([lambda_est, mu_j_est])\n\n    # Format the final results into the required string format.\n    # The output is a list of lists, e.g., [[lambda1,mu_J1],[lambda2,mu_J2],...],\n    # with each float formatted to exactly six decimal places.\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    # The final print statement must produce only the required single-line output.\n    print(final_output_string)\n\nsolve()\n```"}, {"introduction": "本章的最后一项实践将探讨一个在现实世界中至关重要的高级课题：如何处理参数不稳定性，尤其是在市场数据稀疏的情况下。我们将使用Merton跳跃扩散模型，并引入吉洪诺夫正则化（Tikhonov regularization）这一强大技术，以获得稳定且具有经济学意义的参数估计。[@problem_id:2434399] 通过这个练习，你将学会构建一个稳健的校准程序，使其在面对噪声或不完整的市场数据时，依然能够得出可靠的结果。", "id": "2434399", "problem": "给定一个随机跳跃的跳跃-扩散模型下的欧式看涨期权定价模型，具体为 Merton 跳跃-扩散模型。在风险中性测度下，标的资产价格过程 $\\{S_t\\}_{t \\ge 0}$ 服从如下随机微分方程\n$$\n\\frac{\\,\\mathrm{d}S_t\\,}{S_{t^-}} \\;=\\; \\bigl(r - q - \\lambda k\\bigr)\\,\\mathrm{d}t \\;+\\; \\sigma\\,\\mathrm{d}W_t \\;+\\; (J - 1)\\,\\mathrm{d}N_t,\n$$\n其中 $r$ 是连续复利无风险利率（以小数形式表示），$q$ 是连续复利股息率（以小数形式表示），$\\sigma$ 是扩散波动率（以小数形式表示），$\\lambda$ 是跳跃强度（单位时间内的事件数），$N_t$ 是强度为 $\\lambda$ 的泊松过程，$J$ 是跳跃乘数，且 $\\ln J \\sim \\mathcal{N}(\\mu_J, \\delta_J^2)$。跳跃补偿项为 $k \\equiv \\mathbb{E}[J - 1] = \\exp\\!\\bigl(\\mu_J + \\tfrac{1}{2}\\delta_J^2\\bigr) - 1$。所有利率和波动率都必须按小数处理，而不是百分比。\n\n对于一个现货价为 $S$、行权价为 $K$、到期时间为 $T$（单位：年）、无风险利率为 $r$、股息率为 $q$ 的欧式看涨期权，其在该模型下的无套利价格可以写为 Black–Scholes 价格的泊松混合：\n$$\nC_{\\text{MJD}}(S,K,T;r,q;\\sigma,\\lambda,\\mu_J,\\delta_J) \\;=\\;\n\\sum_{n=0}^{\\infty} \\mathrm{e}^{-\\lambda T} \\frac{(\\lambda T)^n}{n!}\\;\nC_{\\text{BS}}\\!\\Bigl(S \\mathrm{e}^{n\\mu_J},K,T;\\; r - \\lambda k,\\; q,\\; \\sqrt{\\sigma^2 + \\tfrac{n\\,\\delta_J^2}{T}} \\Bigr),\n$$\n其中 $C_{\\text{BS}}$ 是带连续股息率 $q$ 的 Black–Scholes–Merton 价格，且 $k = \\exp(\\mu_J + \\tfrac{1}{2}\\delta_J^2) - 1$。Black–Scholes–Merton 看涨期权价格满足\n$$\nC_{\\text{BS}}(S,K,T;\\, r, q, \\sigma)\n=\nS\\,\\mathrm{e}^{-qT}\\,\\Phi(d_1) - K\\,\\mathrm{e}^{-rT}\\,\\Phi(d_2),\n\\quad\nd_1 = \\frac{\\ln(S/K) + (r - q + \\tfrac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}},\n\\quad\nd_2 = d_1 - \\sigma\\sqrt{T},\n$$\n其中 $\\Phi$ 表示标准正态累积分布函数。\n\n校准问题被设定为一个使用 Tikhonov 正则化的带正则项的非线性最小二乘问题。对于一组给定的市场期权观测价格 $\\{C_i^{\\text{mkt}}\\}_{i=1}^M$（对应行权价 $\\{K_i\\}_{i=1}^M$ 和共同的到期日 $T$），定义参数向量 $\\boldsymbol{\\theta} = [\\sigma,\\lambda,\\mu_J,\\delta_J]^\\top$ 和一个先验（参考）向量 $\\boldsymbol{\\theta}_0$。校准问题为\n$$\n\\min_{\\boldsymbol{\\theta}} \\;\\; \\sum_{i=1}^{M} \\bigl(C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\boldsymbol{\\theta}) - C_i^{\\text{mkt}}\\bigr)^2\n\\;+\\;\n\\alpha \\,\\bigl\\| \\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0 \\bigr\\|_2^2,\n$$\n其中 $\\alpha \\ge 0$ 是 Tikhonov 正则化强度。$\\boldsymbol{\\theta}$ 的各分量必须满足边界条件 $\\sigma \\in [0.01, 1.50]$，$\\lambda \\in [0.00, 2.00]$，$\\mu_J \\in [-0.50, 0.50]$，以及 $\\delta_J \\in [0.01, 1.00]$。\n\n您的任务是实现一个程序，针对下方的每个测试用例，从给定的“真实”参数出发，通过上述模型构造合成的市场价格（无噪声），然后通过求解优化问题来校准 $\\boldsymbol{\\theta}$，并报告校准后的模型价格与合成市场价格之间的均方根误差 (RMSE)。所有利率和波动率必须按小数处理和报告。不涉及角度。最终的数值结果必须以浮点数形式打印。\n\n测试套件：\n- 用例 1（一般情况）：\n  - $S = 100$, $r = 0.01$, $q = 0.00$, $T = 0.50$, 行权价 $K \\in \\{90, 100, 110\\}$。\n  - 真实参数 $\\boldsymbol{\\theta}^{\\star} = [0.20,\\, 0.30,\\, -0.10,\\, 0.20]$。\n  - 先验参数 $\\boldsymbol{\\theta}_0 = [0.18,\\, 0.10,\\, 0.00,\\, 0.25]$，正则化系数 $\\alpha = 10^{-4}$。\n- 用例 2（数据稀疏，欠定）：\n  - $S = 100$, $r = 0.00$, $q = 0.00$, $T = 0.50$, 行权价 $K \\in \\{90, 110\\}$。\n  - 真实参数 $\\boldsymbol{\\theta}^{\\star} = [0.18,\\, 0.40,\\, -0.05,\\, 0.25]$。\n  - 先验参数 $\\boldsymbol{\\theta}_0 = [0.20,\\, 0.20,\\, 0.00,\\, 0.20]$，正则化系数 $\\alpha = 10^{-2}$。\n- 用例 3（边界情况，无跳跃）：\n  - $S = 100$, $r = 0.01$, $q = 0.00$, $T = 1.00$, 行权价 $K \\in \\{80, 100, 120\\}$。\n  - 真实参数 $\\boldsymbol{\\theta}^{\\star} = [0.25,\\, 0.00,\\, 0.00,\\, 0.20]$。\n  - 先验参数 $\\boldsymbol{\\theta}_0 = [0.22,\\, 0.30,\\, -0.10,\\, 0.25]$，正则化系数 $\\alpha = 10^{-4}$。\n\n实现要求：\n- 直接使用上述定义，不假设任何此处未声明的额外公式。\n- 在计算 $C_{\\text{MJD}}$ 时，通过一个有限和来近似无限级数，以产生数值稳定且准确的值。\n- 对每个用例，通过在 $\\boldsymbol{\\theta}^{\\star}$ 和指定的 $(S,r,q,T,K_i)$ 处计算 $C_{\\text{MJD}}$ 来合成 $C_i^{\\text{mkt}}$，然后使用给定的先验和正则化来校准 $\\boldsymbol{\\theta}$。\n- 对每个用例，计算均方根误差 (RMSE)\n$$\n\\mathrm{RMSE} = \\sqrt{ \\frac{1}{M} \\sum_{i=1}^{M} \\bigl( C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\widehat{\\boldsymbol{\\theta}}) - C_i^{\\text{mkt}} \\bigr)^2 }.\n$$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用例 1、2 和 3 的三个 RMSE 值，按顺序排列，四舍五入到 6 位小数，并以逗号分隔列表的形式包含在中括号内。例如，一个有效的输出格式是\n$[x_1,x_2,x_3]$\n其中每个 $x_j$ 是一个四舍五入到 6 位小数的浮点数，且没有其他额外文本。", "solution": "该问题要求通过最小化一个带正则项的最小二乘目标函数，来校准 Merton 跳跃-扩散模型在一组稀疏期权价格上的参数。该目标函数是基于风险中性定价的基本原理和 Merton 模型的结构构建的。\n\n首先，在风险中性测度下，资产价格动态由以下公式给出\n$$\n\\frac{\\,\\mathrm{d}S_t\\,}{S_{t^-}} \\;=\\; \\bigl(r - q - \\lambda k\\bigr)\\,\\mathrm{d}t \\;+\\; \\sigma\\,\\mathrm{d}W_t \\;+\\; (J - 1)\\,\\mathrm{d}N_t,\n$$\n其中 $\\ln J \\sim \\mathcal{N}(\\mu_J,\\delta_J^2)$ 且 $k = \\exp(\\mu_J + \\tfrac{1}{2}\\delta_J^2) - 1$。通过从漂移项中减去 $\\lambda k$ 进行补偿，此设定确保了贴现后的价格过程是一个鞅。\n\n其次，欧式看涨期权在到期时的收益为 $\\max(S_T - K, 0)$。在时间 $t=0$ 的风险中性价格是贴现期望值\n$$\nC_{\\text{MJD}}(S,K,T;\\, r,q;\\boldsymbol{\\theta}) \\;=\\; \\mathrm{e}^{-rT}\\,\\mathbb{E}^{\\mathbb{Q}}\\bigl[(S_T - K)^+ \\,\\big|\\, S_0 = S \\bigr].\n$$\n通过以 $N_T = n$ 为条件，我们利用全期望定律以及跳跃时间和大小的独立性，将 $\\ln S_T$ 的分布写为正态分布的混合：当 $N_T=n$ 时，跳跃部分贡献了均值为 $n\\mu_J$、方差为 $n\\delta_J^2$ 的正态位移，而扩散部分贡献了方差为 $\\sigma^2 T$、漂移为 $r - q - \\lambda k$。因此，看涨期权价格可以表示为 Black–Scholes–Merton 价格的泊松加权和，\n$$\nC_{\\text{MJD}}(S,K,T;\\, r,q;\\sigma,\\lambda,\\mu_J,\\delta_J) \\;=\\;\n\\sum_{n=0}^{\\infty} \\mathrm{e}^{-\\lambda T} \\frac{(\\lambda T)^n}{n!}\\;\nC_{\\text{BS}}\\!\\Bigl(S \\mathrm{e}^{n\\mu_J},K,T;\\; r - \\lambda k,\\; q,\\; \\sqrt{\\sigma^2 + \\tfrac{n\\,\\delta_J^2}{T}} \\Bigr),\n$$\n其中 $k = \\exp(\\mu_J + \\tfrac{1}{2}\\delta_J^2) - 1$。带连续股息率的 Black–Scholes–Merton 公式为\n$$\nC_{\\text{BS}}(S,K,T;\\, r,q,\\sigma) = S\\,\\mathrm{e}^{-qT}\\,\\Phi(d_1) - K\\,\\mathrm{e}^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1 = \\frac{\\ln(S/K) + (r - q + \\tfrac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}},\n\\qquad\nd_2 = d_1 - \\sigma\\sqrt{T},\n$$\n且 $\\Phi$ 为标准正态累积分布函数。\n\n第三，校准过程构建一个参数向量 $\\boldsymbol{\\theta} = [\\sigma,\\lambda,\\mu_J,\\delta_J]^\\top$ 并最小化一个带正则项的残差平方和：\n$$\n\\min_{\\boldsymbol{\\theta}} \\;\\; \\sum_{i=1}^{M} \\bigl(C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\boldsymbol{\\theta}) - C_i^{\\text{mkt}}\\bigr)^2\n\\;+\\;\n\\alpha \\,\\bigl\\| \\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0 \\bigr\\|_2^2.\n$$\n这是一个 Tikhonov（岭）正则化项，强度为 $\\alpha \\ge 0$，惩罚矩阵为单位矩阵（因此惩罚是与先验 $\\boldsymbol{\\theta}_0$ 偏差的 $\\ell_2$ 范数）。正则化项的引入通过向先验值收缩来抑制稀疏数据环境下的不稳定解。\n\n第四，优化在物理和统计上合理的边界条件下执行：\n$$\n\\sigma \\in [0.01, 1.50],\\quad \\lambda \\in [0.00, 2.00],\\quad \\mu_J \\in [-0.50, 0.50],\\quad \\delta_J \\in [0.01, 1.00].\n$$\n这些边界强制尺度参数为正，并将跳跃幅度限制在与高等本科练习题一致的数值稳定范围内。\n\n第五，对于每个测试用例，通过在给定的真实参数 $\\boldsymbol{\\theta}^\\star$ 和 $(S,r,q,T,K_i)$ 处计算 $C_{\\text{MJD}}$ 来合成“市场”价格 $\\{C_i^{\\text{mkt}}\\}_{i=1}^M$。这确保了一个内部一致且无噪声的数据集，从而能够将校准精度的评估纯粹作为一个优化和正则化练习。\n\n第六，$C_{\\text{MJD}}$ 的无限级数通过截断计算。通过对足够多的泊松项求和来保证精度。一种实用的方法是求和至一个最大索引 $N_{\\max}$，该索引要足够大，以使对于当前参数范围，被忽略的尾部可以忽略不计。例如，使用 $N_{\\max}$ 作为固定上限和 $\\lambda T$ 的函数（如均值加几个标准差）中较大的一个，可以确保稳健的近似。\n\n第七，在为每个用例求解优化问题并获得 $\\widehat{\\boldsymbol{\\theta}}$ 后，均方根误差计算如下\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\bigl(C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\widehat{\\boldsymbol{\\theta}}) - C_i^{\\text{mkt}}\\bigr)^2}.\n$$\n因为合成数据是无噪声的且由同一模型生成，所以对于良构问题（用例 1 和用例 3），RMSE 值预计接近于 0；而在稀疏、欠定的情况（用例 2）下，正则化会影响解，RMSE 值预计为非零但很小。\n\n最后，程序将用例 1、2 和 3 的 RMSE 值汇总为一行，格式为 $[x_1,x_2,x_3]$，其中每个 $x_j$ 四舍五入到 6 位小数。所有利率和波动率均按小数使用和解释，不带百分号。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import log, sqrt, exp, erf\nfrom scipy.optimize import minimize\nfrom math import factorial\n\ndef std_norm_cdf(x: float) -> float:\n    # Standard normal CDF via error function\n    return 0.5 * (1.0 + erf(x / sqrt(2.0)))\n\ndef bs_call_price(S: float, K: float, r: float, q: float, sigma: float, T: float) -> float:\n    # Black-Scholes-Merton call with continuous dividend yield\n    if sigma <= 0.0 or T <= 0.0:\n        # In the limiting case, treat as forward intrinsic value\n        forward = S * np.exp(-q * T)\n        discK = K * np.exp(-r * T)\n        return max(forward - discK, 0.0)\n    vol_sqrt_T = sigma * sqrt(T)\n    d1 = (log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / vol_sqrt_T\n    d2 = d1 - vol_sqrt_T\n    return S * np.exp(-q * T) * std_norm_cdf(d1) - K * np.exp(-r * T) * std_norm_cdf(d2)\n\ndef merton_call_price(S: float, K: float, r: float, q: float, T: float,\n                      sigma: float, lam: float, mu_j: float, delta_j: float) -> float:\n    # Merton jump-diffusion call via Poisson mixture of BSM prices\n    # Compute jump compensator\n    k = np.exp(mu_j + 0.5 * (delta_j ** 2)) - 1.0\n    r_eff = r - lam * k\n    # Poisson mean\n    m = lam * T\n    # Choose truncation level: mean + 10 stddevs, but at least 50 terms\n    Nmax = max(50, int(np.ceil(m + 10.0 * sqrt(m + 1e-12))))\n    # Compute Poisson weights iteratively to avoid overflow\n    # Start with p0 = exp(-m)\n    p = np.exp(-m)\n    price = 0.0\n    for n in range(0, Nmax + 1):\n        # Effective sigma and shifted spot for the nth term\n        sigma_n_sq = sigma * sigma + (n * delta_j * delta_j) / max(T, 1e-16)\n        sigma_n = sqrt(max(sigma_n_sq, 1e-16))\n        S_n = S * np.exp(n * mu_j)\n        price += p * bs_call_price(S_n, K, r_eff, q, sigma_n, T)\n        # Update Poisson weight for next n\n        # p_{n+1} = p_n * m / (n + 1)\n        if n < Nmax:\n            p = p * (m / (n + 1.0))\n    return price\n\ndef synthesize_market_prices(S, r, q, T, Ks, theta_true):\n    sigma, lam, mu_j, delta_j = theta_true\n    prices = []\n    for K in Ks:\n        prices.append(merton_call_price(S, K, r, q, T, sigma, lam, mu_j, delta_j))\n    return np.array(prices, dtype=float)\n\ndef calibrate_case(S, r, q, T, Ks, market_prices, theta0, alpha):\n    Ks = np.array(Ks, dtype=float)\n    M = len(Ks)\n    theta0 = np.array(theta0, dtype=float)\n\n    # Bounds: sigma in [0.01, 1.50], lambda in [0.0, 2.0], mu in [-0.5, 0.5], delta in [0.01, 1.0]\n    bounds = [(0.01, 1.50), (0.0, 2.0), (-0.5, 0.5), (0.01, 1.0)]\n\n    def objective(theta):\n        sigma, lam, mu_j, delta_j = theta\n        model_prices = np.array(\n            [merton_call_price(S, K, r, q, T, sigma, lam, mu_j, delta_j) for K in Ks],\n            dtype=float\n        )\n        resid = model_prices - market_prices\n        data_term = float(np.dot(resid, resid))\n        reg = float(alpha) * float(np.dot(theta - theta0, theta - theta0))\n        return data_term + reg\n\n    # Use prior as initial guess\n    x0 = theta0.copy()\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds)\n    theta_hat = result.x\n    # Compute RMSE\n    model_prices_hat = np.array(\n        [merton_call_price(S, K, r, q, T, theta_hat[0], theta_hat[1], theta_hat[2], theta_hat[3]) for K in Ks],\n        dtype=float\n    )\n    rmse = float(np.sqrt(np.mean((model_prices_hat - market_prices) ** 2)))\n    return theta_hat, rmse\n\ndef solve():\n    # Define test cases as specified in the problem statement.\n\n    # Case 1: general case\n    S1, r1, q1, T1 = 100.0, 0.01, 0.0, 0.50\n    Ks1 = [90.0, 100.0, 110.0]\n    theta_true_1 = [0.20, 0.30, -0.10, 0.20]\n    theta0_1 = [0.18, 0.10, 0.00, 0.25]\n    alpha_1 = 1e-4\n    market1 = synthesize_market_prices(S1, r1, q1, T1, Ks1, theta_true_1)\n\n    # Case 2: sparse data\n    S2, r2, q2, T2 = 100.0, 0.00, 0.00, 0.50\n    Ks2 = [90.0, 110.0]\n    theta_true_2 = [0.18, 0.40, -0.05, 0.25]\n    theta0_2 = [0.20, 0.20, 0.00, 0.20]\n    alpha_2 = 1e-2\n    market2 = synthesize_market_prices(S2, r2, q2, T2, Ks2, theta_true_2)\n\n    # Case 3: no jumps\n    S3, r3, q3, T3 = 100.0, 0.01, 0.00, 1.00\n    Ks3 = [80.0, 100.0, 120.0]\n    theta_true_3 = [0.25, 0.00, 0.00, 0.20]\n    theta0_3 = [0.22, 0.30, -0.10, 0.25]\n    alpha_3 = 1e-4\n    market3 = synthesize_market_prices(S3, r3, q3, T3, Ks3, theta_true_3)\n\n    # Calibrate each case\n    _, rmse1 = calibrate_case(S1, r1, q1, T1, Ks1, market1, theta0_1, alpha_1)\n    _, rmse2 = calibrate_case(S2, r2, q2, T2, Ks2, market2, theta0_2, alpha_2)\n    _, rmse3 = calibrate_case(S3, r3, q3, T3, Ks3, market3, theta0_3, alpha_3)\n\n    results = [rmse1, rmse2, rmse3]\n    # Print in required format with 6 decimal places\n    print(f\"[{results[0]:.6f},{results[1]:.6f},{results[2]:.6f}]\")\n\nsolve()\n```"}]}