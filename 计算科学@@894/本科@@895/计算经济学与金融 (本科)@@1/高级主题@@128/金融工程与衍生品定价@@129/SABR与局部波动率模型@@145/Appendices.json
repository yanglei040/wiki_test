{"hands_on_practices": [{"introduction": "SABR模型最强大的功能之一是它能够灵活地控制波动率微笑的“斜率”或“偏度” (skew)。这个练习将带你通过动手实践来探索模型参数，特别是相关性参数 $\\rho$，如何影响波动率微笑的形态。你将使用金融计算中一种基础而强大的数值方法——有限差分法，来计算平价期权 (at-the-money) 附近的微笑斜率，从而直观地理解 $\\rho$ 与市场偏度之间的深刻联系。[@problem_id:2428125]", "id": "2428125", "problem": "给定随机 Alpha, Beta, Rho (SABR) 模型，用于描述风险中性测度下一个严格为正的远期价格过程 $F_t$：\n$$\n\\mathrm{d}F_t = \\alpha_t F_t^{\\beta} \\,\\mathrm{d}W_t^{(1)}, \\qquad \\mathrm{d}\\alpha_t = \\nu \\alpha_t \\,\\mathrm{d}W_t^{(2)}, \\qquad \\mathrm{d}\\langle W^{(1)}, W^{(2)}\\rangle_t = \\rho \\,\\mathrm{d}t,\n$$\n其参数为 $\\alpha_0 = \\alpha \\gt 0$，$\\beta \\in [0,1]$, $\\nu \\ge 0$, 以及相关性 $\\rho \\in (-1,1)$。考虑 SABR 模型下，一个到期日为 $T \\gt 0$、远期价格为 $F \\gt 0$、行权价为 $K \\gt 0$ 的欧式看涨期权的布莱克-斯科尔斯 (Black-Scholes, BS) 隐含波动率，其由 Hagan 等人的一阶渐近公式近似得出：\n- 对于一般情况 $K \\ne F$，定义\n$$\n\\log_{FK} = \\ln\\!\\left(\\frac{F}{K}\\right), \\quad \\phi = (F K)^{\\frac{1-\\beta}{2}}, \\quad z = \\frac{\\nu}{\\alpha} \\,\\phi\\, \\log_{FK}, \\quad x(z) = \\ln\\!\\left(\\frac{\\sqrt{1 - 2\\rho z + z^2} + z - \\rho}{1 - \\rho}\\right),\n$$\n以及隐含波动率的近似值为\n$$\n\\sigma_{\\text{BS}}(F,K,T;\\alpha,\\beta,\\rho,\\nu) \\approx \\frac{\\alpha}{\\phi} \\cdot \\frac{z}{x(z)} \\cdot \\left[ 1 + \\frac{(1-\\beta)^2}{24}\\,\\log_{FK}^2 + \\frac{(1-\\beta)^4}{1920}\\,\\log_{FK}^4 \\right] \\cdot \\left\\{ 1 + \\left[ \\frac{(1-\\beta)^2}{24}\\frac{\\alpha^2}{(F K)^{1-\\beta}} + \\frac{1}{4}\\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{(F K)^{\\frac{1-\\beta}{2}}} + \\frac{2-3\\rho^2}{24}\\nu^2 \\right] T \\right\\}.\n$$\n- 对于平价（At-the-money, $K=F$）情况，使用其连续极限\n$$\n\\sigma_{\\text{BS}}(F,F,T;\\alpha,\\beta,\\rho,\\nu) \\approx \\frac{\\alpha}{F^{1-\\beta}} \\cdot \\left\\{ 1 + \\left[ \\frac{(1-\\beta)^2}{24}\\frac{\\alpha^2}{F^{2(1-\\beta)}} + \\frac{1}{4}\\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{F^{1-\\beta}} + \\frac{2-3\\rho^2}{24}\\nu^2 \\right] T \\right\\}.\n$$\n所有波动率必须以小数形式表示（例如，$0.2$ 代表 $20$ 百分比），且所有输出必须为小数形式，不带任何百分号。\n\n您的任务是计算分析当相关性参数 $\\rho$ 趋近其极限值 $+1$ 和 $-1$ 时，SABR 波动率微笑曲线的行为。对于下文测试套件中的每一组参数，请计算隐含波动率微笑曲线在平价时相对于行权价的斜率，方法是围绕 $K=F$ 使用对称有限差分，行权价扰动为 $\\Delta K = 0.01\\,F$。具体来说，对于每个固定的 $\\rho$，斜率定义为\n$$\nS(F,\\alpha,\\beta,\\rho,\\nu,T) = \\frac{\\sigma_{\\text{BS}}(F,F+\\Delta K,T;\\alpha,\\beta,\\rho,\\nu) - \\sigma_{\\text{BS}}(F,F-\\Delta K,T;\\alpha,\\beta,\\rho,\\nu)}{2\\,\\Delta K}.\n$$\n您必须计算 $\\rho \\in \\{-0.999,\\,0.0,\\,0.999\\}$ 时 $S$ 的值。\n\n测试套件（三组参数），以 $(F,\\alpha,\\beta,\\nu,T)$ 的形式给出：\n1. $(100.0,\\,0.3,\\,0.5,\\,0.5,\\,1.0)$,\n2. $(100.0,\\,0.2,\\,0.7,\\,0.05,\\,1.0)$,\n3. $(100.0,\\,0.2,\\,0.0,\\,0.8,\\,2.0)$.\n\n您的程序必须按照上面列出的顺序，为每一组参数生成分别对应于 $\\rho=-0.999$、$\\rho=0.0$ 和 $\\rho=0.999$ 的三个斜率 $S$。按此顺序将所有九个结果汇总到一个扁平列表中。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表。该列表必须按所述顺序包含 $9$ 个浮点数，例如：\n\"[s1_neg,s1_zero,s1_pos,s2_neg,s2_zero,s2_pos,s3_neg,s3_zero,s3_pos]\".", "solution": "问题陈述经过严格审查，被认为是有效的。它具有科学依据，问题定义明确且客观。该问题是量化金融领域一个标准的计算练习，涉及著名的随机 Alpha, Beta, Rho (SABR) 模型和 Hagan 等人用于计算隐含波动率的渐近近似法。所提供的方程是正确的，参数在典型范围内，计算任务定义清晰可行。不存在矛盾、歧义或不成立的前提。\n\n任务是计算 SABR 隐含波动率微笑曲线在平价时相对于行权价 $K$ 的斜率。这个量通常被称为“偏斜”(skew)，是波动率曲面的一个关键特征。为此，规定了使用对称有限差分格式：\n$$\nS(F,\\alpha,\\beta,\\rho,\\nu,T) = \\frac{\\sigma_{\\text{BS}}(F,F+\\Delta K,T;\\alpha,\\beta,\\rho,\\nu) - \\sigma_{\\text{BS}}(F,F-\\Delta K,T;\\alpha,\\beta,\\rho,\\nu)}{2\\,\\Delta K}\n$$\n其中 $\\sigma_{\\text{BS}}(F,K,\\dots)$ 是 Hagan 等人关于布莱克-斯科尔斯隐含波动率的一阶近似。行权价扰动给定为 $\\Delta K = 0.01\\,F$。\n\n解决方案的核心是实现所提供的、针对 $K \\ne F$ 情况的 $\\sigma_{\\text{BS}}(F, K, \\dots)$ 公式。该公式由几个必须仔细计算的项组成：\n1. 主要的前置因子是 $\\frac{\\alpha}{\\phi}$，其中项 $\\phi = (F K)^{\\frac{1-\\beta}{2}}$ 通过由参数 $\\beta$ 决定的恒定方差弹性 (constant elasticity of variance, CEV) 骨架，捕捉了对远期价格 $F$ 和行权价 $K$ 的主要依赖关系。\n\n2. “对数正态骨架”调整项是 $\\frac{z}{x(z)}$，其中 $z = \\frac{\\nu}{\\alpha} \\,\\phi\\, \\ln\\left(\\frac{F}{K}\\right)$ 且 $x(z) = \\ln\\left(\\frac{\\sqrt{1 - 2\\rho z + z^2} + z - \\rho}{1 - \\rho}\\right)$。该项捕捉了由波动率的波动率参数 $\\nu$驱动的随机波动率过程的影响。对于接近远期价格的行权价（$K \\to F$），$z \\to 0$ 且此项趋近其极限值 $1$。\n\n3. 一个密度校正项，$\\left[ 1 + \\frac{(1-\\beta)^2}{24}\\,\\ln^2(F/K) + \\frac{(1-\\beta)^4}{1920}\\,\\ln^4(F/K) \\right]$，该项用于调整骨架参数 $\\beta$ 与 $1$（对数正态情况）的差异。\n\n4. 一个时间依赖的校正项，$\\left\\{ 1 + \\left[ \\frac{(1-\\beta)^2}{24}\\frac{\\alpha^2}{(F K)^{1-\\beta}} + \\frac{1}{4}\\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{(F K)^{\\frac{1-\\beta}{2}}} + \\frac{2-3\\rho^2}{24}\\nu^2 \\right] T \\right\\}$，提供了关于时间 $T$ 的一阶校正。\n\n该解决方案需要计算行权价为 $K_{+} = F + \\Delta K$ 和 $K_{-} = F - \\Delta K$ 时的波动率 $\\sigma_{\\text{BS}}$，然后计算相关性参数 $\\rho \\in \\{-0.999, 0.0, 0.999\\}$ 的 3 个值对应的斜率 $S$。对测试套件中提供的 3 组参数中的每一组，都重复此过程。\n\n相关性参数 $\\rho$ 是控制波动率微笑曲线斜率的主要因素。负的 $\\rho$（这在股票市场中很典型）意味着向下倾斜的微笑曲线，即较低行权价的波动率更高。正的 $\\rho$ 意味着向上倾斜的微笑曲线。当 $\\rho=0$ 时，微笑曲线在平价点周围更对称，其在平价时的斜率主要由 CEV 骨架的凸性驱动，这导致一个较小但通常非零的斜率。计算将展示这一典型行为。\n\n该实现使用 Python 完成，利用 NumPy 库进行稳健的浮点运算。提供的公式被直接转录到一个 Python 函数中。程序的主体部分遍历测试用例和指定的 $\\rho$ 值，以生成所需的 9 个斜率值，然后将它们汇总并格式化为最终所需的输出列表。对于 $z/x(z)$ 项，不需要特殊的数值处理，因为规定的行权价扰动 $\\Delta K = 0.01\\,F$ 足够大，可以避免在标准双精度算术中出现不稳定性。", "answer": "```python\nimport numpy as np\n\ndef sabr_implied_vol(F, K, T, alpha, beta, rho, nu):\n    \"\"\"\n    Computes the SABR implied volatility using the Hagan et al. 2002 first-order approximation.\n    This implementation handles the K != F case.\n    \"\"\"\n    \n    # Ensure K is positive to avoid mathematical domain errors.\n    if K <= 0:\n        return np.nan\n\n    log_FK = np.log(F / K)\n    \n    # For nu=0, the model collapses to CEV. The z/x(z) term becomes 1.\n    if np.isclose(nu, 0):\n        z = 0\n        z_over_x = 1.0\n    else:\n        phi = (F * K)**((1 - beta) / 2.0)\n        z = (nu / alpha) * phi * log_FK\n        \n        # Argument of the logarithm in x(z) can cause numerical issues if not handled carefully.\n        # Direct computation with numpy's float64 is generally sufficient for non-extreme parameters.\n        x_z_arg_num = np.sqrt(1 - 2*rho*z + z**2) + z - rho\n        x_z_arg_den = 1 - rho\n        \n        # To avoid log(0) for rho=1, or other issues, check argument positivity.\n        # For rho approaching 1, both num and den approach 0.\n        # For rho approaching -1, den approaches 2.\n        if x_z_arg_num <= 0 or x_z_arg_den <= 0:\n            # Handle pathological cases, though not expected with given test data.\n            # Using series expansion for z/x(z) is the robust way, but not required here.\n            # Fallback to limit for small z as a simple guard.\n             if np.isclose(z, 0.0):\n                z_over_x = 1.0\n             else:\n                return np.nan\n        else:\n            x_z = np.log(x_z_arg_num / x_z_arg_den)\n            # Handle the limit z/x(z) -> 1 as z -> 0\n            if np.isclose(z, 0.0):\n                z_over_x = 1.0\n            else:\n                z_over_x = z / x_z\n\n    # Main term without corrections\n    # phi is defined inside the 'else' block, so redefine for generality\n    phi = (F * K)**((1 - beta) / 2.0)\n    term_main = (alpha / phi) * z_over_x\n\n    # First correction term (log-space adjustment)\n    term_1_beta_sq = (1 - beta)**2\n    term_log_adj = 1.0 + (term_1_beta_sq / 24.0) * log_FK**2 + (term_1_beta_sq**2 / 1920.0) * log_FK**4\n    \n    # Second correction term (time-dependent adjustment)\n    fk_pow_1_beta = (F * K)**(1 - beta)\n    \n    term_T_adj_1 = (term_1_beta_sq / 24.0) * (alpha**2 / fk_pow_1_beta)\n    term_T_adj_2 = (rho * beta * nu * alpha) / (4.0 * phi)\n    term_T_adj_3 = ((2.0 - 3.0*rho**2) / 24.0) * nu**2\n    \n    term_T_adj = 1.0 + (term_T_adj_1 + term_T_adj_2 + term_T_adj_3) * T\n                       \n    vol = term_main * term_log_adj * term_T_adj\n    \n    return vol\n\ndef solve():\n    \"\"\"\n    Main solver function to compute the SABR smile slope for the given test cases.\n    \"\"\"\n    # Test cases: (F, alpha, beta, nu, T)\n    test_cases = [\n        (100.0, 0.3, 0.5, 0.5, 1.0),\n        (100.0, 0.2, 0.7, 0.05, 1.0),\n        (100.0, 0.2, 0.0, 0.8, 2.0),\n    ]\n    \n    rhos = [-0.999, 0.0, 0.999]\n    results = []\n    \n    for case in test_cases:\n        F, alpha, beta, nu, T = case\n        delta_K = 0.01 * F\n        K_plus = F + delta_K\n        K_minus = F - delta_K\n\n        for rho in rhos:\n            vol_plus = sabr_implied_vol(F, K_plus, T, alpha, beta, rho, nu)\n            vol_minus = sabr_implied_vol(F, K_minus, T, alpha, beta, rho, nu)\n            \n            # Symmetric finite difference for the slope\n            slope = (vol_plus - vol_minus) / (2.0 * delta_K)\n            results.append(slope)\n\n    # Format output as a comma-separated list in brackets.\n    output_str = \",\".join(map(lambda x: f\"{x:.10f}\", results))\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"}, {"introduction": "在上一个练习中，我们通过数值方法近似了波动率的斜率。现在，让我们深入一步，挑战推导其精确的解析表达式。这项任务要求你运用微积分知识，对SABR隐含波动率的近似公式进行求导，从而揭示模型背后的数学结构。完成这个练习不仅能让你更深刻地理解偏度，还能让你精确地看到模型参数 $\\rho$、$\\beta$ 和 $\\nu$ 是如何共同决定波动率微笑的具体形状。[@problem_id:2428115]", "id": "2428115", "problem": "给定风险中性测度下的远期价格过程的 Stochastic Alpha Beta Rho (SABR) 模型。对于到期时间 $T > 0$，远期价格过程 $F_t$ 及其波动率过程 $\\alpha_t$ 满足：\n$$\n\\mathrm{d}F_t = \\alpha_t F_t^{\\beta} \\,\\mathrm{d}W_t^{(1)}, \\qquad \\mathrm{d}\\alpha_t = \\nu \\alpha_t \\,\\mathrm{d}W_t^{(2)}, \\qquad \\mathrm{d}\\langle W^{(1)},W^{(2)}\\rangle_t = \\rho\\,\\mathrm{d}t,\n$$\n其中常数 $0 \\le \\beta \\le 1$, $\\nu \\ge 0$，相关性 $-1 &lt; \\rho &lt; 1$，以及初始条件 $F_0$ 和 $\\alpha_0 = \\alpha$。考虑与时间为0的远期价格 $F_0$ 相关联的 Black 隐含波动率函数 $\\sigma_{\\mathrm{imp}}(K,T)$。根据定义，它是唯一的非负 $\\sigma$，使得波动率为 $\\sigma$、执行价格为 $K$ 的 Black 公式计算出的价值与 SABR 模型下看涨期权在时间为0的价值相匹配。在本问题中，您将使用关于到期时间的标准一阶渐近近似来对 $\\sigma_{\\mathrm{imp}}(K,T)$ 建模，其定义如下。对于给定的参数 $(F_0,K,T,\\alpha,\\beta,\\rho,\\nu)$，定义\n$$\nz = \\frac{\\nu}{\\alpha}\\,(F_0 K)^{\\frac{1-\\beta}{2}} \\ln\\!\\left(\\frac{F_0}{K}\\right), \\qquad \n\\chi(z) = \\ln\\!\\left(\\frac{\\sqrt{1 - 2\\rho z + z^2} + z - \\rho}{1 - \\rho}\\right),\n$$\n以及\n$$\n\\sigma_{\\mathrm{imp}}(K,T) = \\frac{\\alpha}{(F_0 K)^{\\frac{1-\\beta}{2}}}\\,\\frac{z}{\\chi(z)}\\left[1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,(F_0 K)^{1-\\beta}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,(F_0 K)^{\\frac{1-\\beta}{2}}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\\right],\n$$\n约定当 $z = 0$ 时，比率 $z/\\chi(z)$ 根据连续性取值为 $1$。平价（at-the-money）偏斜（skew）定义为隐含波动率在平价点 $k=0$ 处对对数货币性（log-moneyness）$k = \\ln(K/F_0)$ 的导数：\n$$\nS(T;\\rho) = \\left.\\frac{\\partial \\sigma_{\\mathrm{imp}}(K,T)}{\\partial k}\\right|_{k=0}, \\quad \\text{其中 } k=\\ln\\!\\left(\\frac{K}{F_0}\\right).\n$$\n您的任务是使用上述 $\\sigma_{\\mathrm{imp}}(K,T)$ 的定义来计算 $S(T;\\rho)$，并分析其在不同到期时间下对相关性参数 $\\rho$ 的依赖性。\n\n使用以下基本参数值：远期价格 $F_0 = 100$，初始波动率水平 $\\alpha = 0.2$，弹性 $\\beta = 0.5$，以及波动率的波动率 $\\nu = 0.6$。将波动率及其导数视为无量纲量；所有数值输出必须以十进制数（而非百分比）表示。本问题中不出现角度。到期时间 $T$ 以年为单位。\n\n测试套件：\n- 考虑由 $\\rho \\in \\{-0.9, 0.0, 0.9\\}$ 和 $T \\in \\{0.25, 1.0, 5.0\\}$ 的笛卡尔积形成的九个测试用例，按以下顺序进行评估：\n$$\n(\\rho,T) \\in \\{(-0.9,0.25),\\,(-0.9,1.0),\\,(-0.9,5.0),\\,(0.0,0.25),\\,(0.0,1.0),\\,(0.0,5.0),\\,(0.9,0.25),\\,(0.9,1.0),\\,(0.9,5.0)\\}.\n$$\n\n要求输出：\n- 对于每个测试用例，计算平价偏斜 $S(T;\\rho)$，结果为实数。您的程序应生成单行输出，其中包含九个结果，以逗号分隔并用方括号括起来，顺序与上文完全一致。每个数字必须四舍五入到六位小数。例如，输出必须如下所示：\n$$\n[\\text{value}_1,\\text{value}_2,\\ldots,\\text{value}_9],\n$$\n该行中任何地方都不能有空格。\n\n不提供外部输入；所有参数均如上所述。您的实现必须是通用的，并且完全基于此处给出的数学定义和模型近似。测试套件的最终数值答案必须是四舍五入到六位小数的浮点数。", "solution": "问题陈述已经过验证，并被认定为有效。这是一个在计算金融领域中的适定问题，基于已建立的数学模型，并为获得唯一解提供了所有必要信息。我们将继续进行推导和计算。\n\n任务是计算隐含波动率的平价（at-the-money, ATM）偏斜，其定义为隐含波动率 $\\sigma_{\\mathrm{imp}}(K,T)$ 关于对数货币性 $k = \\ln(K/F_0)$ 的导数，并在 ATM 点 $k=0$（对应于 $K=F_0$）处求值。隐含波动率由一阶渐近近似给出：\n$$\n\\sigma_{\\mathrm{imp}}(K,T) = \\frac{\\alpha}{(F_0 K)^{\\frac{1-\\beta}{2}}}\\,\\frac{z}{\\chi(z)}\\left[1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,(F_0 K)^{1-\\beta}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,(F_0 K)^{\\frac{1-\\beta}{2}}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\\right]\n$$\n其中 $z = \\frac{\\nu}{\\alpha}(F_0 K)^{\\frac{1-\\beta}{2}} \\ln(F_0/K)$ 且 $\\chi(z) = \\ln\\left(\\frac{\\sqrt{1 - 2\\rho z + z^2} + z - \\rho}{1 - \\rho}\\right)$。\n\n我们必须计算 $S(T;\\rho) = \\left.\\frac{\\partial \\sigma_{\\mathrm{imp}}(K,T)}{\\partial k}\\right|_{k=0}$。首先，我们将所有量表示为对数货币性 $k = \\ln(K/F_0)$ 的函数。这意味着 $K = F_0 e^k$。\n\n变量 $z$ 可以用 $k$ 来表示：\n$$\n\\ln\\left(\\frac{F_0}{K}\\right) = \\ln\\left(\\frac{F_0}{F_0 e^k}\\right) = -k\n$$\n$$\n(F_0 K)^{\\frac{1-\\beta}{2}} = (F_0^2 e^k)^{\\frac{1-\\beta}{2}} = F_0^{1-\\beta} e^{k\\frac{1-\\beta}{2}}\n$$\n因此，\n$$\nz(k) = \\frac{\\nu}{\\alpha} F_0^{1-\\beta} e^{k\\frac{1-\\beta}{2}} (-k) = -k \\frac{\\nu}{\\alpha} F_0^{1-\\beta} e^{k\\frac{1-\\beta}{2}}\n$$\n当 $k \\to 0$ 时, $z \\to 0$。\n\n隐含波动率公式 $\\sigma_{\\mathrm{imp}}$ 可以看作是 $k$ 的三个函数的乘积：$\\sigma_{\\mathrm{imp}}(k) = A(k)B(k)C(k)$，其中：\n$$\nA(k) = \\frac{\\alpha}{(F_0 K)^{\\frac{1-\\beta}{2}}} = \\frac{\\alpha}{F_0^{1-\\beta} e^{k\\frac{1-\\beta}{2}}} = \\alpha F_0^{-(1-\\beta)} e^{-k\\frac{1-\\beta}{2}}\n$$\n$$\nB(k) = \\frac{z(k)}{\\chi(z(k))}\n$$\n$$\nC(k) = 1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,(F_0 K)^{1-\\beta}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,(F_0 K)^{\\frac{1-\\beta}{2}}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\n$$\n代入 $K = F_0 e^k$：\n$$\nC(k) = 1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,F_0^{2(1-\\beta)}e^{k(1-\\beta)}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,F_0^{1-\\beta}e^{k\\frac{1-\\beta}{2}}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\n$$\nATM 偏斜是该乘积在 $k=0$ 处的导数：\n$$\nS(T;\\rho) = \\left.\\frac{d\\sigma_{\\mathrm{imp}}}{dk}\\right|_{k=0} = A'(0)B(0)C(0) + A(0)B'(0)C(0) + A(0)B(0)C'(0)\n$$\n我们计算每一项及其在 $k=0$ 处的导数。\n\n1.  **项 $A(k)$ 及其导数：**\n    $$\n    A(0) = \\alpha F_0^{-(1-\\beta)} = \\frac{\\alpha}{F_0^{1-\\beta}}\n    $$\n    $$\n    A'(k) = \\alpha F_0^{-(1-\\beta)} \\left(-\\frac{1-\\beta}{2}\\right) e^{-k\\frac{1-\\beta}{2}} \\implies A'(0) = -\\frac{\\alpha(1-\\beta)}{2F_0^{1-\\beta}}\n    $$\n\n2.  **项 $B(k)$ 及其导数：**\n    对于极限 $z \\to 0$，我们展开 $\\chi(z)$：\n    $$\n    \\sqrt{1-2\\rho z+z^2} = 1 - \\rho z + \\frac{1-\\rho^2}{2} z^2 + O(z^3)\n    $$\n    $$\n    \\chi(z) = \\ln\\left(\\frac{1 - \\rho z + z - \\rho + O(z^2)}{1-\\rho}\\right) = \\ln\\left(\\frac{(1-\\rho) + (1-\\rho)z + O(z^2)}{1-\\rho}\\right) = \\ln(1 + z + O(z^2))\n    $$\n    使用 $\\ln(1+x)=x - x^2/2 + \\dots$，我们找到了 $\\chi(z)$ 的更精确展开式：\n    $$\n    \\chi(z) = z + \\frac{\\rho}{2} z^2 + O(z^3)\n    $$\n    因此，对于 $z \\to 0$：\n    $$\n    \\frac{z}{\\chi(z)} = \\frac{z}{z + \\frac{\\rho}{2} z^2 + O(z^3)} = \\frac{1}{1 + \\frac{\\rho}{2} z + O(z^2)} = 1 - \\frac{\\rho}{2} z + O(z^2)\n    $$\n    由此，我们得出 $B(0) = \\lim_{z\\to 0} \\frac{z}{\\chi(z)} = 1$，这与问题陈述一致。\n    导数 $B'(0)$ 使用链式法则计算：$B'(k) = \\frac{d B}{dz} \\frac{dz}{dk}$。\n    $$\n    \\left.\\frac{dB}{dz}\\right|_{z=0} = \\left.\\frac{d}{dz}\\left(1 - \\frac{\\rho}{2} z + O(z^2)\\right)\\right|_{z=0} = -\\frac{\\rho}{2}\n    $$\n    $$\n    \\frac{dz}{dk} = -\\frac{\\nu}{\\alpha}F_0^{1-\\beta} \\frac{d}{dk}\\left(k e^{k\\frac{1-\\beta}{2}}\\right) = -\\frac{\\nu}{\\alpha}F_0^{1-\\beta} \\left(e^{k\\frac{1-\\beta}{2}} + k \\frac{1-\\beta}{2} e^{k\\frac{1-\\beta}{2}}\\right)\n    $$\n    $$\n    \\left.\\frac{dz}{dk}\\right|_{k=0} = -\\frac{\\nu}{\\alpha} F_0^{1-\\beta}\n    $$\n    将这些结合起来得到：\n    $$\n    B'(0) = \\left.\\frac{dB}{dz}\\right|_{z=0} \\left.\\frac{dz}{dk}\\right|_{k=0} = \\left(-\\frac{\\rho}{2}\\right) \\left(-\\frac{\\nu}{\\alpha} F_0^{1-\\beta}\\right) = \\frac{\\rho \\nu F_0^{1-\\beta}}{2\\alpha}\n    $$\n\n3.  **项 $C(k)$ 及其导数：**\n    $$\n    C(0) = 1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,F_0^{2(1-\\beta)}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,F_0^{1-\\beta}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\n    $$\n    导数 $C'(k)$ 为：\n    $$\n    C'(k) = T \\left( \\frac{(1-\\beta)^2 \\alpha^2}{24 F_0^{2(1-\\beta)}} (-(1-\\beta))e^{-k(1-\\beta)} + \\frac{\\rho \\beta \\nu \\alpha}{4 F_0^{1-\\beta}} \\left(-\\frac{1-\\beta}{2}\\right)e^{-k\\frac{1-\\beta}{2}} \\right)\n    $$\n    在 $k=0$ 处：\n    $$\n    C'(0) = T \\left( -\\frac{(1-\\beta)^3 \\alpha^2}{24 F_0^{2(1-\\beta)}} - \\frac{\\rho \\beta \\nu \\alpha(1-\\beta)}{8 F_0^{1-\\beta}} \\right)\n    $$\n\n最后，我们组合导数 $S(T;\\rho) = A'(0)B(0)C(0) + A(0)B'(0)C(0) + A(0)B(0)C'(0)$：\n$$\nS(T;\\rho) = [A'(0) + A(0)B'(0)]C(0) + A(0)C'(0)\n$$\n第一项是 ATM 骨干偏斜（backbone skew）：\n$$\nS_0 = A'(0) + A(0)B'(0) = -\\frac{\\alpha(1-\\beta)}{2F_0^{1-\\beta}} + \\left(\\frac{\\alpha}{F_0^{1-\\beta}}\\right)\\left(\\frac{\\rho \\nu F_0^{1-\\beta}}{2\\alpha}\\right) = -\\frac{\\alpha(1-\\beta)}{2F_0^{1-\\beta}} + \\frac{\\rho \\nu}{2}\n$$\n那么，偏斜的完整表达式是：\n$S(T;\\rho) = S_0 C(0) + A(0) C'(0)$。代入 $S_0, C(0), A(0), C'(0)$ 的表达式：\n$$\nS(T;\\rho) = \\left(-\\frac{\\alpha(1-\\beta)}{2F_0^{1-\\beta}} + \\frac{\\rho \\nu}{2}\\right)\\left[1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,F_0^{2(1-\\beta)}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,F_0^{1-\\beta}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\\right] + \\frac{\\alpha}{F_0^{1-\\beta}} T \\left(-\\frac{(1-\\beta)^3 \\alpha^2}{24 F_0^{2(1-\\beta)}} - \\frac{\\rho \\beta \\nu \\alpha (1-\\beta)}{8 F_0^{1-\\beta}}\\right)\n$$\n这就是 ATM 偏斜的解析公式。我们将实现此公式来计算指定测试套件所需的值。\n基本参数为 $F_0 = 100$，$\\alpha = 0.2$，$\\beta = 0.5$，$\\nu = 0.6$。测试用例是 $\\rho \\in \\{-0.9, 0.0, 0.9\\}$ 和 $T \\in \\{0.25, 1.0, 5.0\\}$ 的笛卡尔积。\n计算过程通过将这些参数直接代入 $S(T;\\rho)$ 的最终公式来进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the at-the-money (ATM) skew for the SABR model based on a\n    first-order asymptotic approximation for the implied volatility.\n    \"\"\"\n\n    # Base parameter values\n    F0 = 100.0\n    alpha = 0.2\n    beta = 0.5\n    nu = 0.6\n\n    # Test suite from the problem statement\n    test_cases = [\n        (-0.9, 0.25), (-0.9, 1.0), (-0.9, 5.0),\n        (0.0, 0.25), (0.0, 1.0), (0.0, 5.0),\n        (0.9, 0.25), (0.9, 1.0), (0.9, 5.0)\n    ]\n\n    results = []\n    \n    # Pre-compute constants based on base parameters\n    one_minus_beta = 1.0 - beta\n    F0_pow_1_minus_beta = F0**one_minus_beta\n    F0_pow_2_1_minus_beta = F0**(2.0 * one_minus_beta)\n    \n    # Term A(0) from derivation\n    A_0 = alpha / F0_pow_1_minus_beta\n    \n    for case in test_cases:\n        rho, T = case\n\n        # --- Calculation based on the derived formula for S(T; rho) ---\n        \n        # S_0 = -alpha(1-beta)/(2*F0^(1-beta)) + rho*nu/2\n        # This is the ATM skew of the backbone volatility.\n        S_0 = -alpha * one_minus_beta / (2.0 * F0_pow_1_minus_beta) + rho * nu / 2.0\n\n        # Term C(0) from derivation\n        # C(0) = 1 + T * (term1 + term2 + term3)\n        c0_term1 = (one_minus_beta**2 * alpha**2) / (24.0 * F0_pow_2_1_minus_beta)\n        c0_term2 = (rho * beta * nu * alpha) / (4.0 * F0_pow_1_minus_beta)\n        c0_term3 = (2.0 - 3.0 * rho**2) * nu**2 / 24.0\n        C_0 = 1.0 + T * (c0_term1 + c0_term2 + c0_term3)\n        \n        # Term C'(0) from derivation\n        # C'(0) = T * (term1 + term2)\n        c_prime_0_term1 = -(one_minus_beta**3 * alpha**2) / (24.0 * F0_pow_2_1_minus_beta)\n        c_prime_0_term2 = -(rho * beta * nu * alpha * one_minus_beta) / (8.0 * F0_pow_1_minus_beta)\n        C_prime_0 = T * (c_prime_0_term1 + c_prime_0_term2)\n\n        # Final ATM skew S(T; rho) = S_0 * C(0) + A(0) * C'(0)\n        skew = S_0 * C_0 + A_0 * C_prime_0\n        \n        results.append(skew)\n\n    # Format the output as specified: comma-separated list in brackets,\n    # with each value rounded to six decimal places. No spaces.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "在真实市场中，波动率微笑的形态会随着期权到期日的不同而变化，这构成了波动率的“期限结构”。为了捕捉这一现象，标准SABR模型可以被扩展为包含随时间变化的参数。本练习将指导你实现一个更高级的时间依赖SABR模型，其中 $\\alpha(t)$、$\\rho(t)$ 和 $\\nu(t)$ 等关键参数都是时间的函数。通过这个实践，你将学会如何从构建单一的波动率微笑，迈向构建一个完整的波动率曲面，这是将理论模型应用于实际工作的关键一步。[@problem_id:2428083]", "id": "2428083", "problem": "给定一个具有时间依赖参数的对数正态随机Alpha Beta Rho (SABR)模型，其远期价格过程 $F_t$ 在风险中性测度下由以下系统定义：\n$$\n\\mathrm{d}F_t = \\alpha(t)\\, F_t^{\\beta}\\, \\mathrm{d}W^{(1)}_t,\\quad\n\\mathrm{d}\\alpha_t = \\nu(t)\\, \\alpha_t\\, \\mathrm{d}W^{(2)}_t,\\quad\n\\mathrm{d}\\langle W^{(1)}, W^{(2)}\\rangle_t = \\rho(t)\\, \\mathrm{d}t,\n$$\n其中 $0 \\le \\beta \\lt 1$ 是常数，而 $\\alpha(t) \\gt 0$、$\\nu(t) \\gt 0$ 和 $\\rho(t) \\in (-1,1)$ 是时间的确定性函数。假设利率和股息均为零，因此远期价格不随到期日变化，且等于初始远期价格 $F_0$。\n\n对于到期日 $T \\gt 0$，将有效参数定义为在 $T$ 时刻取值的时间依赖函数：\n$$\n\\alpha_T \\equiv \\alpha(T),\\quad \\rho_T \\equiv \\rho(T),\\quad \\nu_T \\equiv \\nu(T).\n$$\n\n对于给定的执行价 $K \\gt 0$ 和到期日 $T \\gt 0$，通过以下对数正态情况下的标准SABR主阶渐近公式来定义Black隐含波动率 $\\sigma_{\\mathrm{BS}}(F_0,K,T)$：\n$$\n\\sigma_{\\mathrm{BS}}(F_0,K,T) \\equiv \\frac{\\alpha_T}{(F_0 K)^{\\frac{1-\\beta}{2}} \\left( 1 + \\frac{(1-\\beta)^2}{24}\\,\\ln^2\\!\\frac{F_0}{K} + \\frac{(1-\\beta)^4}{1920}\\,\\ln^4\\!\\frac{F_0}{K} \\right)} \\cdot \\frac{\\zeta}{\\chi(\\zeta)} \\cdot \\left( 1 + T \\cdot \\left[ \\frac{(1-\\beta)^2}{24}\\,\\frac{\\alpha_T^2}{(F_0 K)^{1-\\beta}} + \\frac{\\rho_T\\,\\beta\\,\\nu_T\\,\\alpha_T}{4\\,(F_0 K)^{\\frac{1-\\beta}{2}}} + \\frac{2 - 3\\rho_T^2}{24}\\,\\nu_T^2 \\right] \\right),\n$$\n其中\n$$\n\\zeta \\equiv \\frac{\\nu_T}{\\alpha_T}\\,(F_0 K)^{\\frac{1-\\beta}{2}} \\ln\\!\\frac{F_0}{K},\\qquad\n\\chi(\\zeta) \\equiv \\ln\\!\\left(\\frac{\\sqrt{1 - 2\\rho_T \\zeta + \\zeta^2} + \\zeta - \\rho_T}{1 - \\rho_T}\\right),\n$$\n并约定在极限 $\\zeta \\to 0$ 的情况下，$\\zeta/\\chi(\\zeta)$ 解释为 $1$。\n\n您的任务是实现一个程序，使用以下对时间依赖SABR参数的参数化来为一组测试用例计算 $\\sigma_{\\mathrm{BS}}(F_0,K,T)$：\n$$\n\\alpha(t) = a_0 + a_1 t,\\quad \\rho(t) = \\tanh(b_0 + b_1 t),\\quad \\nu(t) = c_0\\, e^{-c_1 t} + c_2,\n$$\n其中常数为\n$$\nF_0 = 1.0,\\quad \\beta = 0.6,\\quad a_0 = 0.2,\\ a_1 = 0.02,\\quad b_0 = -0.5,\\ b_1 = 0.1,\\quad c_0 = 0.6,\\ c_1 = 1.0,\\ c_2 = 0.1.\n$$\n\n测试套件：\n- 案例1：$(K,T) = (1.0,\\,1.0)$。\n- 案例2：$(K,T) = (0.9,\\,0.1)$。\n- 案例3：$(K,T) = (1.2,\\,5.0)$。\n- 案例4：$(K,T) = (0.5,\\,2.0)$。\n- 案例5：$(K,T) = (1.0,\\,0.01)$。\n\n您的程序必须计算每个案例的 $\\sigma_{\\mathrm{BS}}(F_0,K,T)$ 值。将每个值报告为小数（无百分号），并四舍五入到恰好六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表，按测试案例1到5的顺序排列（例如，$[x_1,x_2,x_3,x_4,x_5]$）。", "solution": "所提出的问题要求使用一个源自时间依赖随机Alpha Beta Rho (SABR)模型的特定主阶渐近公式，来计算Black隐含波动率，记为 $\\sigma_{\\mathrm{BS}}(F_0,K,T)$。在进行求解之前，必须对问题陈述进行严格的验证。\n\n**问题验证**\n\n**第1步：提取的已知条件**\n- **模型：** 一个由以下随机微分方程定义的时间依赖SABR模型：\n$$\n\\mathrm{d}F_t = \\alpha(t)\\, F_t^{\\beta}\\, \\mathrm{d}W^{(1)}_t \\\\\n\\mathrm{d}\\alpha_t = \\nu(t)\\, \\alpha_t\\, \\mathrm{d}W^{(2)}_t \\\\\n\\mathrm{d}\\langle W^{(1)}, W^{(2)}\\rangle_t = \\rho(t)\\, \\mathrm{d}t\n$$\n- **参数与函数：**\n  - 常数： $0 \\le \\beta < 1$。\n  - 时间的确定性函数：$\\alpha(t) > 0$, $\\nu(t) > 0$, $\\rho(t) \\in (-1,1)$。\n  - 零利率和零股息。\n- **有效参数定义：** 问题将到期日 $T$ 的有效参数定义为时间依赖函数在 $t=T$ 时的瞬时值：$\\alpha_T \\equiv \\alpha(T)$, $\\rho_T \\equiv \\rho(T)$, and $\\nu_T \\equiv \\nu(T)$。\n- **隐含波动率公式：** 提供了一个关于 $\\sigma_{\\mathrm{BS}}(F_0,K,T)$ 的具体公式：\n$$\n\\sigma_{\\mathrm{BS}}(F_0,K,T) \\equiv \\frac{\\alpha_T}{(F_0 K)^{\\frac{1-\\beta}{2}} \\left( 1 + \\frac{(1-\\beta)^2}{24}\\,\\ln^2\\!\\frac{F_0}{K} + \\frac{(1-\\beta)^4}{1920}\\,\\ln^4\\!\\frac{F_0}{K} \\right)} \\cdot \\frac{\\zeta}{\\chi(\\zeta)} \\cdot \\left( 1 + T \\cdot \\left[ \\frac{(1-\\beta)^2}{24}\\,\\frac{\\alpha_T^2}{(F_0 K)^{1-\\beta}} + \\frac{\\rho_T\\,\\beta\\,\\nu_T\\,\\alpha_T}{4\\,(F_0 K)^{\\frac{1-\\beta}{2}}} + \\frac{2 - 3\\rho_T^2}{24}\\,\\nu_T^2 \\right] \\right)\n$$\n其中 $\\zeta \\equiv \\frac{\\nu_T}{\\alpha_T}\\,(F_0 K)^{\\frac{1-\\beta}{2}} \\ln\\!\\frac{F_0}{K}$ 且 $\\chi(\\zeta) \\equiv \\ln\\!\\left(\\frac{\\sqrt{1 - 2\\rho_T \\zeta + \\zeta^2} + \\zeta - \\rho_T}{1 - \\rho_T}\\right)$。\n- **特殊条件：** 对于平价情况（$K=F_0$），此时 $\\zeta \\to 0$，比率 $\\zeta/\\chi(\\zeta)$ 取值为 $1$。\n- **参数化：**\n  - $\\alpha(t) = a_0 + a_1 t$\n  - $\\rho(t) = \\tanh(b_0 + b_1 t)$\n  - $\\nu(t) = c_0\\, e^{-c_1 t} + c_2$\n- **常数：** $F_0 = 1.0$, $\\beta = 0.6$, $a_0 = 0.2$, $a_1 = 0.02$, $b_0 = -0.5$, $b_1 = 0.1$, $c_0 = 0.6$, $c_1 = 1.0$, $c_2 = 0.1$。\n- **测试用例：** $(K,T)$ 对：$(1.0, 1.0)$, $(0.9, 0.1)$, $(1.2, 5.0)$, $(0.5, 2.0)$, $(1.0, 0.01)$。\n\n**第2步：验证分析**\n- **科学依据：** 该问题基于SABR模型，这是计算金融中随机波动率建模的基石。所提供的 $\\sigma_{\\mathrm{BS}}$ 公式是一个已知的渐近展开（Hagan等人）。使用瞬时参数 $\\alpha(T), \\rho(T), \\nu(T)$ 而非时间平均参数，是问题陈述本身定义的一个特定简化。在问题范围内，这是一个有效的修改，并未违反基本原理。对于给定的常数，$\\alpha(t)$、$\\rho(t)$ 和 $\\nu(t)$ 的参数形式是合理的，并且对于所有 $t \\ge 0$ 满足必要的约束条件（$\\alpha>0, \\nu>0, |\\rho|<1$）。该问题在科学上是合理的。\n- **良定性与完备性：** 该问题是良定的。它为每个测试用例计算 $\\sigma_{\\mathrm{BS}}$ 的唯一值提供了所有必要的函数、常数和初始条件。对于 $K=F_0$ 的特殊情况，通过提供的极限 $\\lim_{\\zeta \\to 0} \\zeta/\\chi(\\zeta) = 1$ 进行了明确且正确的处理，这可以通过洛必达法则进行数学验证。没有矛盾或缺失的数据。\n- **客观性：** 问题陈述完全客观，由数学定义和计算任务组成。它不含主观或模棱两可的语言。\n\n**第3步：判定**\n该问题是**有效的**。它是一个在量化金融领域定义明确的计算练习。\n\n**求解方法**\n\n任务是为五对不同的 $(K,T)$ 计算函数 $\\sigma_{\\mathrm{BS}}(F_0,K,T)$。该过程是所提供公式的直接实现。\n\n**1. 有效参数的求值：**\n对于每个具有到期日 $T$ 的测试用例，我们首先通过将 $t=T$ 代入其各自的定义中来计算有效参数 $\\alpha_T$、$\\rho_T$ 和 $\\nu_T$：\n$$\n\\alpha_T = a_0 + a_1 T \\\\\n\\rho_T = \\tanh(b_0 + b_1 T) \\\\\n\\nu_T = c_0 e^{-c_1 T} + c_2\n$$\n常数 $a_0, a_1, b_0, b_1, c_0, c_1, c_2$ 是给定的。\n\n**2. 隐含波动率的计算：**\n计算根据期权是平价（$K=F_0$）还是非平价分为两种情况。\n\n**情况A：平价（ATM），$K = F_0$**\n在这种情况下，$F_0/K = 1$ 且 $\\ln(F_0/K) = 0$，这意味着 $\\zeta = 0$。问题明确指出使用极限 $\\lim_{\\zeta\\to0} \\frac{\\zeta}{\\chi(\\zeta)} = 1$。分母展开式中涉及 $\\ln(F_0/K)$ 的项消失。鉴于 $F_0=1.0$，$\\sigma_{\\mathrm{BS}}$ 的公式可大幅简化为：\n$$\n\\sigma_{\\mathrm{BS}}(1.0, 1.0, T) = \\alpha_T \\left( 1 + T \\cdot \\left[ \\frac{(1-\\beta)^2}{24}\\,\\alpha_T^2 + \\frac{\\rho_T\\,\\beta\\,\\nu_T\\,\\alpha_T}{4} + \\frac{2 - 3\\rho_T^2}{24}\\,\\nu_T^2 \\right] \\right)\n$$\n对于测试用例1和5，必须使用此简化表达式。\n\n**情况B：价外， $K \\neq F_0$**\n对于这些情况，我们必须计算完整的表达式。步骤如下：\n- 计算变量 $\\zeta$：\n$$\n\\zeta = \\frac{\\nu_T}{\\alpha_T}\\,(F_0 K)^{\\frac{1-\\beta}{2}} \\ln\\!\\frac{F_0}{K}\n$$\n- 计算函数 $\\chi(\\zeta)$：\n$$\n\\chi(\\zeta) = \\ln\\!\\left(\\frac{\\sqrt{1 - 2\\rho_T \\zeta + \\zeta^2} + \\zeta - \\rho_T}{1 - \\rho_T}\\right)\n$$\n对于 $|\\rho_T| < 1$，平方根下的项 $1 - 2\\rho_T \\zeta + \\zeta^2$ 保证为正，确保计算是良定的。\n- 将所有部分组装成 $\\sigma_{\\mathrm{BS}}(F_0,K,T)$ 的完整公式。每个项——主分数、$\\zeta/\\chi(\\zeta)$ 因子和时间依赖校正因子——将被依次计算并组合。\n\n实现将系统地将此逻辑应用于每个测试用例，将数值结果四舍五入到六位小数，并按规定格式化输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Black implied volatility using a time-dependent SABR model formula\n    for a given set of test cases.\n    \"\"\"\n\n    # --- Given Constants ---\n    F0 = 1.0\n    beta = 0.6\n    a0, a1 = 0.2, 0.02\n    b0, b1 = -0.5, 0.1\n    c0, c1, c2 = 0.6, 1.0, 0.1\n\n    # --- Test Suite ---\n    test_cases = [\n        (1.0, 1.0),   # Case 1\n        (0.9, 0.1),   # Case 2\n        (1.2, 5.0),   # Case 3\n        (0.5, 2.0),   # Case 4\n        (1.0, 0.01),  # Case 5\n    ]\n\n    results = []\n\n    for K, T in test_cases:\n        # Step 1: Evaluate effective parameters at maturity T\n        alpha_T = a0 + a1 * T\n        rho_T = np.tanh(b0 + b1 * T)\n        nu_T = c0 * np.exp(-c1 * T) + c2\n\n        # Step 2: Calculate implied volatility\n        # Using a small epsilon for floating point comparison of K and F0\n        if abs(K - F0) < 1e-9:\n            # At-the-money case (K = F0)\n            # The formula simplifies as ln(F0/K) = 0 and zeta/chi(zeta) -> 1\n            # Since F0 = 1.0, the formula is further simplified\n            term1 = ((1 - beta)**2 / 24) * alpha_T**2\n            term2 = (rho_T * beta * nu_T * alpha_T) / 4\n            term3 = ((2 - 3 * rho_T**2) / 24) * nu_T**2\n            \n            time_correction = 1 + T * (term1 + term2 + term3)\n            sigma_bs = alpha_T * time_correction\n\n        else:\n            # Off-the-money case (K != F0)\n            log_F0_K = np.log(F0 / K)\n            F0K_pow = (F0 * K)**((1 - beta) / 2.0)\n\n            # Calculate zeta\n            zeta = (nu_T / alpha_T) * F0K_pow * log_F0_K\n\n            # Calculate chi(zeta)\n            # The argument of sqrt, 1 - 2*rho*z + z^2, is always positive for |rho|<1\n            sqrt_term = np.sqrt(1 - 2 * rho_T * zeta + zeta**2)\n            chi_zeta_num = sqrt_term + zeta - rho_T\n            chi_zeta_den = 1 - rho_T\n            chi_zeta = np.log(chi_zeta_num / chi_zeta_den)\n\n            # Handle the case where chi_zeta is close to zero, though zeta is not\n            # In practice, for non-zero log_F0_K, zeta is non-zero, and chi_zeta should be too.\n            z_over_chi_z = zeta / chi_zeta\n            \n            # First part of the main formula (denominator)\n            denom_expansion = 1 + ((1 - beta)**2 / 24) * log_F0_K**2 + \\\n                              ((1 - beta)**4 / 1920) * log_F0_K**4\n            main_denom = F0K_pow * denom_expansion\n            \n            # Time-dependent correction term\n            term1_T = ((1 - beta)**2 / 24) * (alpha_T**2 / ((F0 * K)**(1 - beta)))\n            term2_T = (rho_T * beta * nu_T * alpha_T) / (4 * F0K_pow)\n            term3_T = ((2 - 3 * rho_T**2) / 24) * nu_T**2\n            time_correction = 1 + T * (term1_T + term2_T + term3_T)\n            \n            # Combine all parts\n            sigma_bs = (alpha_T / main_denom) * z_over_chi_z * time_correction\n\n        # Format result to exactly 6 decimal places\n        results.append(f\"{sigma_bs:.6f}\")\n\n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}