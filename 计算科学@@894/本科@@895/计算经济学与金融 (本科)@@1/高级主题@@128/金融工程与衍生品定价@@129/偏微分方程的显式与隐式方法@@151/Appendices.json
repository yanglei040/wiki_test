{"hands_on_practices": [{"introduction": "_本实践将带你超越教科书中均匀网格的理想情况，探索如何将显式有限差分法应用于更真实的场景。你将从第一性原理出发，推导非均匀网格下的稳定性条件，这对于保证数值解的可靠性至关重要。通过这个练习，你将深化对局部网格属性如何直接影响显式格式稳定性的理解。[@problem_id:2391401]", "id": "2391401", "problem": "您的任务是为 Black–Scholes 偏微分方程设计、分析并实现一种显式时间推进法，该方法需在行权价附近更密集的非均匀空间网格上运行。您的任务分为三个部分：(i) 对于到期时间的正向时间公式，在非均匀网格上推导一个稳定的显式有限差分格式；(ii) 推导一个用局部网格宽度表示的适应性稳定性条件；(iii) 实现一个完整、可运行的程序，在一小组测试用例上评估该方法，并以要求的格式打印结果。\n\n请从以下基础出发，这是计算金融在风险中性测度下的标准方法。令 $V(S,\\tau)$ 表示期权价值，它是标的资产价格 $S \\ge 0$ 和到期时间 $\\tau \\in [0,T]$ 的函数，其中波动率 $\\sigma > 0$，无风险利率 $r \\ge 0$，到期日 $T>0$。在将日历时间 $t$ 替换为到期时间 $\\tau = T - t$ 这一标准变量变换之后，欧式看涨期权的 Black–Scholes 方程为线性抛物型方程\n$$\n\\frac{\\partial V}{\\partial \\tau}(S,\\tau) \\;=\\; \\frac{1}{2}\\,\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2}(S,\\tau)\\;+\\; r S \\frac{\\partial V}{\\partial S}(S,\\tau)\\;-\\; r\\,V(S,\\tau),\n$$\n对于 $S \\in (0,S_{\\max})$ 和 $\\tau \\in (0,T]$，其初始条件（在 $\\tau=0$ 时的收益）为\n$$\nV(S,0) \\;=\\; \\max(S-K, 0),\n$$\n边界条件为\n$$\nV(0,\\tau) \\;=\\; 0,\\qquad V(S_{\\max},\\tau) \\;=\\; S_{\\max} - K\\,e^{-r \\tau},\n$$\n对于 $\\tau \\in [0,T]$，其中 $K>0$ 是行权价，$S_{\\max} > K$ 是对半无限域的一个足够大的截断。\n\n空间离散化。考虑一个严格递增的非均匀网格 $\\{S_i\\}_{i=0}^M$，其中 $S_0=0$，$S_M=S_{\\max}$，并且在 $S=K$ 周围有一个密集区域，构建方法如下。对于给定的细网格间距 $h_f>0$、粗网格间距 $h_c>0$ 和半宽度 $w>0$，定义中心带 $[K-w,K+w]$。网格在 $[0,K-w]$ 和 $[K+w,S_{\\max}]$ 上是分段均匀的，间距为 $h_c$；在 $[K-w,K+w]$ 上的间距为 $h_f$。在分段连接处进行调整，使得 $K-w$ 和 $K+w$ 都是网格节点。令 $h_{i-1} = S_i - S_{i-1}$ 和 $h_i = S_{i+1} - S_i$ 表示内部节点 $i \\in \\{1,\\dots,M-1\\}$ 的左右局部网格宽度。\n\n时间离散化与空间有限差分。在时间上使用步长为 $\\Delta \\tau > 0$ 的显式前向欧拉法。在非均匀网格上，内部节点的二阶导数通过标准的非均匀中心公式来近似：\n$$\n\\left.\\frac{\\partial^2 V}{\\partial S^2}\\right|_{S=S_i}\n\\;\\approx\\; \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}-V_i}{h_i} \\;-\\; \\frac{V_i - V_{i-1}}{h_{i-1}}\\right).\n$$\n一阶导数的近似采用与正向 $\\tau$ 方程中输运方向一致的迎风选择。因为正向方程中的对流项系数是 $+r S$，所以采用前向（下游）差分，\n$$\n\\left.\\frac{\\partial V}{\\partial S}\\right|_{S=S_i}\n\\;\\approx\\; \\frac{V_{i+1}-V_i}{h_i},\n$$\n以确保对于 $r \\ge 0$ 和 $S \\ge 0$ 时显式更新的单调性。那么内部节点的显式更新为\n$$\nV_i^{n+1} \\;=\\; V_i^n \\;+\\; \\Delta \\tau \\left[\n\\frac{1}{2}\\sigma^2 S_i^2 \\cdot \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n - V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right)\n\\;+\\; r S_i \\cdot \\frac{V_{i+1}^n - V_i^n}{h_i}\n\\;-\\; r V_i^n\n\\right],\n$$\n其中边界节点在每个时间层根据边界条件设置。此处 $V_i^n \\approx V(S_i, n\\,\\Delta \\tau)$。\n\n待推导的稳定性要求。对于非均匀网格上的显式方法，可以通过要求每个内部节点的更新是 $V_{i-1}^n$、$V_i^n$ 和 $V_{i+1}^n$ 的一个凸组合来强制实现稳定性和单调性，该组合具有非负权重，并且仅由反应项 $-r V$ 产生一个非负余项。请从第一性原理和上述离散系数出发，推导一个关于 $\\Delta \\tau$ 的充分局部约束，该约束保证每个内部节点 $i$ 的更新权重均为非负。将适应性稳定性边界表示为\n$$\n\\Delta \\tau \\;\\le\\; \\min_{i=1,\\dots,M-1} \\frac{1}{\\Lambda_i},\n$$\n其中 $\\Lambda_i$ 的显式公式是根据 $\\sigma$、$r$、$S_i$、$h_{i-1}$ 和 $h_i$ 从离散算子推导得出的。\n\n实现要求。将上述格式实现为一个完整、可运行的程序，该程序：\n- 根据 $h_f$、$h_c$ 和 $w$ 构建分段均匀的非均匀网格；\n- 根据您推导的 $\\Lambda_i$ 计算适应性稳定性边界 $\\Delta \\tau_{\\max}$；\n- 选择一个时间步长 $\\Delta \\tau = \\theta\\,\\Delta \\tau_{\\max}$，其中安全系数 $\\theta \\in (0,1)$，并从 $\\tau=0$ 推进到 $\\tau=T$；在实践中，设置步数 $N_\\tau = \\lceil T/(\\theta\\,\\Delta \\tau_{\\max}) \\rceil$，然后使用均匀步长 $\\Delta \\tau = T/N_\\tau$；\n- 在每个时间步施加边界条件，并在 $\\tau=0$ 时使用初始条件；\n- 对于给定的 $S_0$，通过在最终网格上进行分段线性插值，返回在 $S=S_0$ 处的期权价值。\n\n测试、单位和输出格式。使用以下测试套件。所有标量输入均为无量纲的标准金融参数；您必须按规定输出数值结果，不带任何单位。对于每个测试，计算指定的输出并按描述汇总到单行打印输出中。\n\n- 测试 A（行权价附近的准确性，“理想路径”）：$K=100$, $r=0.05$, $\\sigma=0.2$, $T=1.0$, $S_{\\max}=400$，中心带宽度 $w=20$，细网格间距 $h_f=1.0$，粗网格间距 $h_c=5.0$，安全系数 $\\theta=0.9$，评估点 $S_0=K$。输出您的数值价格与在 $S_0$ 处的 Black–Scholes 看涨期权解析价格之间的绝对误差，以浮点数形式。\n\n- 测试 B（在轻微违反边界时的稳定性检查）：使用与测试 A 相同的参数。根据您的稳定性公式计算 $\\Delta \\tau_{\\max}$，然后检查如果使用 $\\Delta \\tau = 1.05\\,\\Delta \\tau_{\\max}$，在每个内部节点处的显式更新权重是否保持非负。输出一个布尔值，指示在此较大步长下所有更新权重是否保持非负（对于正确的稳定性边界，此值应为 false）。\n\n- 测试 C（更密的中心网格和低于行权价的评估）：$K=100$, $r=0.05$, $\\sigma=0.2$, $T=0.5$, $S_{\\max}=400$, $w=30$, $h_f=0.5$, $h_c=5.0$, $\\theta=0.9$, 评估点 $S_0=80$。输出您的数值价格与在 $S_0$ 处的 Black–Scholes 看涨期权解析价格之间的绝对误差，以浮点数形式。\n\n- 测试 D（在更高波动率下报告的稳定性尺度）：$K=100$, $r=0.02$, $\\sigma=0.5$, $T=1.0$, $S_{\\max}=400$, $w=20$, $h_f=1.0$, $h_c=5.0$。根据您的稳定性公式计算 $\\Delta \\tau_{\\max}$，并以浮点数形式输出。\n\n最终输出格式。您的程序应产生单行输出，其中包含测试 A–D 的结果，形式为用方括号括起来的逗号分隔列表，并严格按照 [A_result,B_result,C_result,D_result] 的顺序。例如，打印的行必须如下所示\n\"[A_result,B_result,C_result,D_result]\"\n不含任何额外文本。所有数字必须以标准 Python 字符串形式打印，布尔值打印为 \"True\" 或 \"False\"。\n\n关于角度和单位的说明。不涉及任何角度量。所有输出必须是无量纲数。如果存在百分比，必须表示为小数，但此处没有要求。", "solution": "所述问题是在金融领域将数值方法应用于偏微分方程的一个适定的、有科学依据的练习。所有参数、方程和边界条件均已提供，任务定义明确。因此，该问题是有效的，我们着手提供一个完整的解决方案。\n\n该问题要求在非均匀空间网格上为 Black-Scholes 方程设计、分析并实现一个显式有限差分格式。解决方案按指定的任务分为三部分呈现。\n\n### 第 (i) 部分：显式有限差分格式\n\n控制方程是欧式期权价值 $V(S,\\tau)$ 的正向 Black-Scholes 偏微分方程，其中 S 是资产价格，$\\tau$ 是到期时间：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\,\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r\\,V\n$$\n它定义在域 $(S, \\tau) \\in (0, S_{\\max}) \\times (0, T]$ 上。在 $\\tau=0$ 时的初始条件是收益函数，对于看涨期权为 $V(S,0) = \\max(S-K, 0)$。边界条件是 $V(0, \\tau) = 0$ 和 $V(S_{\\max}, \\tau) = S_{\\max} - Ke^{-r\\tau}$。\n\n空间域 $[0, S_{\\max}]$ 使用非均匀网格 $\\{S_i\\}_{i=0}^M$ 进行离散化。在内部节点 $S_i$，局部网格宽度为 $h_{i-1} = S_i - S_{i-1}$ 和 $h_i = S_{i+1} - S_i$。时间域 $[0, T]$ 使用均匀步长 $\\Delta \\tau$ 进行离散化。令 $V_i^n \\approx V(S_i, n\\Delta \\tau)$。\n\n问题指定了特定的有限差分近似。时间导数使用显式前向欧拉法近似。空间导数近似如下：\n- 二阶导数（非均匀网格上的中心差分）：\n$$\n\\left.\\frac{\\partial^2 V}{\\partial S^2}\\right|_{S_i} \\approx \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n-V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right)\n$$\n- 一阶导数（前向差分，按规定）：\n$$\n\\left.\\frac{\\partial V}{\\partial S}\\right|_{S_i} \\approx \\frac{V_{i+1}^n-V_i^n}{h_i}\n$$\n将这些表达式代入偏微分方程，得到内部节点 $i \\in \\{1, \\dots, M-1\\}$ 的完全离散的显式更新方程：\n$$\n\\frac{V_i^{n+1} - V_i^n}{\\Delta \\tau} = \\frac{1}{2}\\sigma^2 S_i^2 \\left[ \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n-V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right) \\right] + r S_i \\left[ \\frac{V_{i+1}^n-V_i^n}{h_i} \\right] - rV_i^n\n$$\n整理得到 $V_i^{n+1}$，即为问题中所述格式的最终形式：\n$$\nV_i^{n+1} = V_i^n + \\Delta \\tau \\left[ \\frac{\\sigma^2 S_i^2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n - V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right) + \\frac{r S_i}{h_i} (V_{i+1}^n - V_i^n) - r V_i^n \\right]\n$$\n\n### 第 (ii) 部分：稳定性条件的推导\n\n为确保稳定性并防止非物理振荡，显式更新中的系数必须满足一定的正性条件。我们要求 $V_i^{n+1}$ 的更新是其邻点 $V_{i-1}^n$、$V_i^n$ 和 $V_{i+1}^n$ 的一个凸组合。为推导此条件，我们重组格式，将 $V_i^{n+1}$ 表示为时间层 $n$ 处值的线性组合：\n$$\nV_i^{n+1} = a_i V_{i-1}^n + b_i V_i^n + c_i V_{i+1}^n\n$$\n我们通过从更新方程中合并同类项来找到系数 $a_i$、$b_i$ 和 $c_i$：\n\n- $V_{i-1}^n$ 的系数：\n$$\na_i = \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_{i-1}(h_{i-1}+h_i)} \\right)\n$$\n由于 $\\sigma$、$S_i$、$h_{i-1}$ 和 $h_i$ 均为正，对于任何 $\\Delta \\tau > 0$，$a_i \\ge 0$。\n\n- $V_{i+1}^n$ 的系数：\n$$\nc_i = \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_i(h_{i-1}+h_i)} + \\frac{r S_i}{h_i} \\right)\n$$\n由于 $r \\ge 0$，对于任何 $\\Delta \\tau > 0$，$c_i \\ge 0$。\n\n- $V_i^n$ 的系数：\n$$\nb_i = 1 + \\Delta \\tau \\left[ -\\frac{\\sigma^2 S_i^2}{h_{i-1}+h_i}\\left(\\frac{1}{h_i} + \\frac{1}{h_{i-1}}\\right) - \\frac{r S_i}{h_i} - r \\right]\n$$\n简化括号中的项：\n$$\n-\\frac{\\sigma^2 S_i^2}{h_{i-1}+h_i}\\left(\\frac{h_{i-1}+h_i}{h_i h_{i-1}}\\right) - \\frac{r S_i}{h_i} - r = -\\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} - \\frac{r S_i}{h_i} - r\n$$\n所以，系数为：\n$$\nb_i = 1 - \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r \\right)\n$$\n为保证稳定性，我们必须强制要求 $b_i \\ge 0$。这导致了以下条件：\n$$\n1 \\ge \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r \\right)\n$$\n分离出 $\\Delta \\tau$ 得到每个内部节点 $S_i$ 处的局部稳定性约束：\n$$\n\\Delta \\tau \\le \\frac{1}{\\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r}\n$$\n这定义了问题陈述中的项 $\\Lambda_i$：\n$$\n\\Lambda_i = \\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r\n$$\n为确保整个网格的稳定性，时间步长 $\\Delta \\tau$ 必须对所有内部节点 $i \\in \\{1, \\dots, M-1\\}$ 满足此条件。因此，全局时间步长必须受最严格的局部条件限制：\n$$\n\\Delta \\tau \\le \\min_{i=1,\\dots,M-1} \\left( \\frac{1}{\\Lambda_i} \\right) = \\frac{1}{\\max_{i=1,\\dots,M-1} (\\Lambda_i)}\n$$\n至此，稳定性条件的推导完成。\n\n### 第 (iii) 部分：实现概要\n\n数值实现过程如下：\n1.  **网格构建**：一个函数根据参数 $K$、$S_{\\max}$、$w$、$h_f$ 和 $h_c$ 生成非均匀网格 $\\{S_i\\}_{i=0}^M$。该网格通过连接对应于 $[0, K-w]$、$[K-w, K+w]$ 和 $[K+w, S_{\\max}]$ 的三个分段均匀段来构建，并通过调整每个段中的点数来确保段边界是网格节点。\n2.  **稳定性边界**：通过首先对每个内部节点 $i=1, \\dots, M-1$ 使用推导出的公式和生成的网格间距 $h_{i-1}$ 和 $h_i$ 计算 $\\Lambda_i$ 来计算最大允许时间步长 $\\Delta \\tau_{\\max}$。然后，$\\Delta \\tau_{\\max} = 1 / \\max_i(\\Lambda_i)$。\n3.  **时间推进**：总时间步数设置为 $N_\\tau = \\lceil T/(\\theta \\cdot \\Delta \\tau_{\\max}) \\rceil$，其中 $\\theta$ 是一个安全系数。实际使用的时间步长为 $\\Delta \\tau = T/N_\\tau$。\n    - 模拟从 $\\tau=0$ 开始，初始条件为 $V_i^0 = \\max(S_i - K, 0)$。\n    - 在一个从 $n=0$ 到 $N_\\tau - 1$ 的循环中推进解：\n        - 在每一步 $n+1$，施加边界条件 $V_0^{n+1} = 0$ 和 $V_M^{n+1} = S_{\\max} - Ke^{-r((n+1)\\Delta\\tau)}$。\n        - 对于所有内部节点 $i$，使用第 (i) 部分推导的显式更新公式计算 $V_i^{n+1}$。\n4.  **结果评估**：在最后一个时间步之后，在到期日 $T$ 计算出的期权价值 $\\{V_i^{N_\\tau}\\}$ 在网格 $\\{S_i\\}$ 上是可用的。特定现货价格 $S_0$ 处的期权价值通过对这些最终数据进行分段线性插值获得。\n5.  **解析解**：为了计算误差，需要欧式看涨期权的 Black-Scholes 解析公式：\n    $$\n    C(S, \\tau) = S N(d_1) - K e^{-r\\tau} N(d_2)\n    $$\n    其中 $d_1 = \\frac{\\ln(S/K) + (r + \\sigma^2/2)\\tau}{\\sigma\\sqrt{\\tau}}$，$d_2 = d_1 - \\sigma\\sqrt{\\tau}$，$N(\\cdot)$ 是标准正态累积分布函数。\n提供的 Python 代码实现了此逻辑以解决测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\nimport math\n\ndef build_grid(K, S_max, w, h_f, h_c):\n    \"\"\"Constructs the piecewise-uniform non-uniform grid.\"\"\"\n    \n    # Region 1: [0, K-w] with spacing h_c\n    num_intervals_1 = max(1, round((K-w) / h_c))\n    grid1 = np.linspace(0, K-w, num=num_intervals_1 + 1)\n    \n    # Region 2: [K-w, K+w] with spacing h_f\n    num_intervals_2 = max(1, round(2 * w / h_f))\n    grid2 = np.linspace(K-w, K+w, num=num_intervals_2 + 1)\n    \n    # Region 3: [K+w, S_max] with spacing h_c\n    num_intervals_3 = max(1, round((S_max - (K+w)) / h_c))\n    grid3 = np.linspace(K+w, S_max, num=num_intervals_3 + 1)\n    \n    # Concatenate, removing duplicate points at boundaries\n    S = np.concatenate((grid1[:-1], grid2[:-1], grid3))\n    return S\n\ndef analytical_bs_call(S, K, T, r, sigma):\n    \"\"\"Computes the analytical Black-Scholes price for a European call.\"\"\"\n    if T == 0 or sigma == 0:\n        return np.maximum(S-K, 0)\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef solve_case(params):\n    \"\"\"\n    Solves one test case configuration for the Black-Scholes PDE.\n    This function encapsulates the logic for grid generation, stability calculation,\n    time marching, and result extraction.\n    \"\"\"\n    K = params['K']\n    r = params['r']\n    sigma = params['sigma']\n    T = params['T']\n    S_max = params['S_max']\n    w = params['w']\n    h_f = params['h_f']\n    h_c = params['h_c']\n    \n    # 1. Grid Construction\n    S = build_grid(K, S_max, w, h_f, h_c)\n    M = len(S) - 1\n\n    # 2. Stability Bound Calculation\n    lambda_vals = []\n    for i in range(1, M):\n        h_im1 = S[i] - S[i-1]\n        h_i = S[i+1] - S[i]\n        \n        # Guard against zero S_i or h_i\n        if S[i] < 1e-9 or h_i < 1e-9 or h_im1 < 1e-9:\n            continue\n\n        term1 = (sigma**2 * S[i]**2) / (h_i * h_im1)\n        term2 = (r * S[i]) / h_i\n        term3 = r\n        lambda_i = term1 + term2 + term3\n        lambda_vals.append(lambda_i)\n        \n    if not lambda_vals:\n        # This case should not be reached with valid parameters\n        raise ValueError(\"Could not compute stability condition.\")\n        \n    max_lambda = np.max(lambda_vals)\n    d_tau_max = 1.0 / max_lambda\n\n    # Handling different test case requirements\n    test_id = params['test_id']\n    if test_id == 'B':\n        d_tau_test = 1.05 * d_tau_max\n        all_non_negative = True\n        for i in range(1, M):\n            h_im1 = S[i] - S[i-1]\n            h_i = S[i+1] - S[i]\n            if S[i] < 1e-9 or h_i < 1e-9 or h_im1 < 1e-9: continue\n            \n            lambda_i = (sigma**2 * S[i]**2) / (h_i * h_im1) + (r * S[i]) / h_i + r\n            b_i = 1.0 - d_tau_test * lambda_i\n            if b_i < 0:\n                all_non_negative = False\n                break\n        return all_non_negative\n\n    if test_id == 'D':\n        return d_tau_max\n\n    # Common path for tests A and C\n    theta = params['theta']\n    S0_eval = params['S0_eval']\n\n    # 3. Time Marching\n    N_tau = math.ceil(T / (theta * d_tau_max))\n    d_tau = T / N_tau\n\n    V = np.maximum(S - K, 0.0) # Initial condition at tau=0\n\n    # Pre-calculate some coefficients\n    h_im1 = S[1:M] - S[0:M-1]\n    h_i = S[2:M+1] - S[1:M]\n    S_interior = S[1:M]\n    \n    alpha = (sigma**2 * S_interior**2) / (h_im1 * (h_im1 + h_i))\n    gamma = (sigma**2 * S_interior**2) / (h_i * (h_im1 + h_i)) + (r * S_interior) / h_i\n    beta = (sigma**2 * S_interior**2) / (h_i * h_im1) + (r * S_interior) / h_i + r\n    \n    for n in range(N_tau):\n        V_new = np.zeros_like(V)\n        \n        # Boundary conditions at tau_{n+1}\n        V_new[0] = 0.0\n        tau_np1 = (n + 1) * d_tau\n        V_new[M] = S_max - K * np.exp(-r * tau_np1)\n        \n        # Interior nodes update\n        V_im1 = V[0:M-1]\n        V_i = V[1:M]\n        V_ip1 = V[2:M+1]\n        \n        V_new[1:M] = V_i + d_tau * (alpha * V_im1 - beta * V_i + gamma * V_ip1)\n        \n        V = V_new\n\n    # 4. Result Evaluation\n    numerical_price = np.interp(S0_eval, S, V)\n    analytical_price = analytical_bs_call(S0_eval, K, T, r, sigma)\n    \n    return abs(numerical_price - analytical_price)\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    \n    test_cases = [\n        # Test A\n        {'test_id': 'A', 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S_max': 400,\n         'w': 20, 'h_f': 1.0, 'h_c': 5.0, 'theta': 0.9, 'S0_eval': 100},\n        # Test B\n        {'test_id': 'B', 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S_max': 400,\n         'w': 20, 'h_f': 1.0, 'h_c': 5.0},\n        # Test C\n        {'test_id': 'C', 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 0.5, 'S_max': 400,\n         'w': 30, 'h_f': 0.5, 'h_c': 5.0, 'theta': 0.9, 'S0_eval': 80},\n        # Test D\n        {'test_id': 'D', 'K': 100, 'r': 0.02, 'sigma': 0.5, 'T': 1.0, 'S_max': 400,\n         'w': 20, 'h_f': 1.0, 'h_c': 5.0}\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = solve_case(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "尽管无条件稳定，但广泛使用的 Crank-Nicolson 格式在处理像期权收益这样的非光滑初始条件时，可能会产生非物理的振荡。本练习将让你亲手观察这一现象，并实现一种名为 Rannacher 阻尼的标准修正方法。这一实践对于理解隐式方法的细微之处以及学习如何生成具有金融意义的可靠结果至关重要。[@problem_id:2391467]", "id": "2391467", "problem": "要求您为欧式看跌期权的 Black–Scholes 偏微分方程 (PDE) 实现两种无条件稳定的有限差分时间步进格式，并量化从到期日回退一步后在行权价附近可能出现的伪振荡。Black–Scholes PDE 为\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n对于资产价格 $S \\in [0,S_{\\max}]$ 和时间 $t \\in [0,T]$，一个欧式看跌期权的终端条件（在到期日 $t=T$ 时）为\n$$\nV(S,T) = \\max(K - S, 0).\n$$\n使用狄利克雷 (Dirichlet) 边界条件\n$$\nV(0,t) = K e^{-r (T-t)}, \\quad V(S_{\\max}, t) = 0.\n$$\n未知量是期权价值 $V(S,t)$；$S$ 是标的资产价格；$t$ 是日历时间；$T$ 是到期日；$\\sigma$ 是波动率（假定为常数）；$r$ 是恒定的无风险利率。\n\n您的程序必须：\n- 在均匀网格 $S_i = i\\,\\Delta S$（其中 $i \\in \\{0,1,\\dots,N\\}$，$ \\Delta S = S_{\\max}/N$ 且 $N \\in \\mathbb{N}$）上对空间域进行离散化。\n- 使用大小为 $\\Delta t = T/M$ 的 $M \\in \\mathbb{N}$ 个步长对时间进行均匀离散化，从 $t=T$ 向后步进到 $t = T - \\Delta t$（仅一步），以分离出到期日刚过的行为。\n\n为第一个后向步（从 $t=T$ 到 $t=T-\\Delta t$）实现并比较以下两种格式：\n\n1) Crank–Nicolson 格式（时间中心，二阶）：\n从算子形式 $\\partial_t V = -\\mathcal{A} V$ 开始，其中 $\\mathcal{A} V = \\frac{1}{2}\\sigma^2 S^2 V_{SS} + r S V_S - r V$。Crank–Nicolson 的更新公式为\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = \\left(I - \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^n,\n$$\n其中 $V^n(\\cdot) = V(\\cdot, t_n)$ 且 $t_{n+1} = t_n - \\Delta t$，这里 $t_n = T$。空间导数 $\\partial_S V$ 和 $\\partial_{SS} V$ 必须在内部节点 $i \\in \\{1,\\dots,N-1\\}$ 处使用中心差分进行近似：\n$$\nV_S(S_i) \\approx \\frac{V_{i+1}-V_{i-1}}{2\\Delta S}, \\quad V_{SS}(S_i) \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{\\Delta S^2}.\n$$\n\n2) Rannacher 阻尼 Crank–Nicolson：\n执行两次初始的全隐式（后向欧拉）半步，每步大小为 $\\Delta t/2$，之后不进行其他操作（因为此任务仅需要一个完整的 $\\Delta t$ 后向步）。一个半步的后向欧拉格式为\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+\\frac{1}{2}} = V^n, \\quad\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = V^{n+\\frac{1}{2}}.\n$$\n\n在两种格式中，通过在第一个和最后一个内部网格点适当地调整右侧项来强制施加狄利克雷边界条件。所产生的三对角线性系统必须被精确求解（例如，通过 Thomas 算法）。所有参数都是确定性的，并且设定为风险中性和无套利。\n\n伪振荡的检测与量化：\n- 对于欧式看跌期权，其精确定价是关于 $S$ 的单调非增函数。将给定时间层级上的离散前向差分定义为 $\\Delta V_i = V_{i+1} - V_i$。任何 $\\Delta V_i > 0$ 的情况都是一次单调性违背，与伪振荡一致。\n- 令 $i_K = \\left\\lfloor K/\\Delta S \\right\\rfloor$，并定义一个半宽为 $w \\in \\mathbb{N}$ 的对称行权价中心窗口，其索引为 $i \\in \\{\\max(0,i_K-w), \\dots, \\min(N-1,i_K+w)\\}$。在此窗口内，计算最大正斜率 $\\max\\{0, \\max_{i \\text{ in window}} \\Delta V_i\\}$，作为行权价附近过冲幅度的度量。\n\n要求的数值基础：\n- 使用来自 PDE 的线性微分算子 $\\mathcal{A}$ 和中心有限差分作为唯一的空间离散化工具。\n- 在您的实现或检查中，不要使用任何 Black–Scholes 解析定价公式。\n- 显式地组装三对角矩阵，并使用数值稳定的直接三对角求解器进行求解。\n\n测试套件：\n使用以下参数集。对于每种情况，使用两种格式计算从 $t=T$ 到 $t=T-\\Delta t$ 的一个完整后向时间步后的结果。所有情况的通用参数为 $K = 100$, $T = 1.0$, $S_{\\max} = 500$, $r = 0.05$, $\\sigma = 0.2$, 以及 $w = 5$。\n- 情况 A（粗时间步长）：$N = 200$, $M = 10$ (所以 $\\Delta t = 0.1$）。\n- 情况 B（中等时间步长）：$N = 400$, $M = 50$ (所以 $\\Delta t = 0.02$）。\n- 情况 C（细时间步长）：$N = 400$, $M = 200$ (所以 $\\Delta t = 0.005$）。\n\n对于每种情况，按以下顺序报告以下六个量：\n1) 在 $t=T-\\Delta t$ 时，Crank–Nicolson 格式在整个网格上的单调性违背的整数计数。\n2) 在 $t=T-\\Delta t$ 时，Crank–Nicolson 格式在行权价中心窗口内的单调性违背的整数计数。\n3) 在 $t=T-\\Delta t$ 时，Rannacher 阻尼格式在整个网格上的单调性违背的整数计数。\n4) 在 $t=T-\\Delta t$ 时，Rannacher 阻尼格式在行权价中心窗口内的单调性违背的整数计数。\n5) 在 $t=T-\\Delta t$ 时，Crank–Nicolson 格式在行权价中心窗口内的最大正离散斜率（一个非负实数）。\n6) 在 $t=T-\\Delta t$ 时，Rannacher 阻尼格式在行权价中心窗口内的最大正离散斜率（一个非负实数）。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个由三个列表组成的列表（每个案例一个），每个内部列表按上述顺序包含该案例的六个结果。输出必须严格遵循以下格式：\n$$\n\\text{[}[a_{1},a_{2},a_{3},a_{4},a_{5},a_{6}],[b_{1},b_{2},b_{3},b_{4},b_{5},b_{6}],[c_{1},c_{2},c_{3},c_{4},c_{5},c_{6}]\\text{]}\n$$\n所有数字均由逗号分隔，无额外空格，其中每个 $a_i$, $b_i$, 和 $c_i$ 都是一个数字。不涉及角度，也无需报告物理单位。所有数值量都应打印为普通数字；过冲幅度应打印为标准小数。", "solution": "问题陈述经评估有效。它描述了一个基于量化金融基石——Black-Scholes 偏微分方程 (PDE) 的适定数值分析任务。所有参数和方法都以足够的精度定义，以获得唯一且可验证的解。任务是实现并比较两种有限差分格式——Crank-Nicolson 格式和一种 Rannacher 阻尼变体，用以求解欧式看跌期权价格，并量化由非光滑终端条件引起的行权价附近的伪振荡。\n\n我们首先对 Black-Scholes PDE 的离散化进行形式化。该方程给出为\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n这可以写成算子形式 $\\frac{\\partial V}{\\partial t} + \\mathcal{A}V = 0$，或 $\\frac{\\partial V}{\\partial t} = -\\mathcal{A}V$，其中线性算子 $\\mathcal{A}$ 定义为\n$$\n\\mathcal{A}V := \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - rV\n$$\n我们将空间域 $S \\in [0, S_{\\max}]$ 离散化为 $N$ 个宽度为 $\\Delta S = S_{\\max}/N$ 的均匀区间，创建网格点 $S_i = i\\Delta S$，其中 $i \\in \\{0, 1, \\dots, N\\}$。在这些点上的解 $V(S_i, t)$ 记为 $V_i(t)$。在内部网格点 $S_i$（其中 $i \\in \\{1, \\dots, N-1\\}$）处，使用中心有限差分近似空间导数，作用于值向量 $V$ 上的算子 $\\mathcal{A}$ 可近似为：\n$$\n(\\mathcal{A}V)_i \\approx \\left(\\frac{\\sigma^2 S_i^2}{2\\Delta S^2} - \\frac{rS_i}{2\\Delta S}\\right)V_{i-1} + \\left(-\\frac{\\sigma^2 S_i^2}{\\Delta S^2} - r\\right)V_i + \\left(\\frac{\\sigma^2 S_i^2}{2\\Delta S^2} + \\frac{rS_i}{2\\Delta S}\\right)V_{i+1}\n$$\n代入 $S_i = i\\Delta S$，我们为第 $i$ 行的离散算子矩阵定义系数：\n$$\n\\begin{aligned}\n\\alpha_i &= \\frac{1}{2}\\sigma^2 i^2 - \\frac{1}{2}ri \\\\\n\\beta_i &= -\\sigma^2 i^2 - r \\\\\n\\gamma_i &= \\frac{1}{2}\\sigma^2 i^2 + \\frac{1}{2}ri\n\\end{aligned}\n$$\n使得 $(\\mathcal{A}V)_i \\approx \\alpha_i V_{i-1} + \\beta_i V_i + \\gamma_i V_{i+1}$。此公式对内部网格点 $i \\in \\{1, \\dots, N-1\\}$ 有效。\n\n时间步进以步长 $\\Delta t=T/M$ 从到期日 $T$ 向后进行。令 $V^n$ 表示在时间 $t_n = T$ 的期权价值，我们寻求在时间 $t_{n+1} = T - \\Delta t$ 的 $V^{n+1}$。\n\n首先，实现 Crank-Nicolson 格式。问题指定了更新规则：\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = \\left(I - \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^n\n$$\n对于每个内部节点 $i$，这转化为一个线性方程：\n$$\n\\left(\\frac{\\Delta t}{2}\\alpha_i\\right)V_{i-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{2}\\beta_i\\right)V_i^{n+1} + \\left(\\frac{\\Delta t}{2}\\gamma_i\\right)V_{i+1}^{n+1} = \\left(-\\frac{\\Delta t}{2}\\alpha_i\\right)V_{i-1}^{n} + \\left(1 - \\frac{\\Delta t}{2}\\beta_i\\right)V_i^{n} + \\left(-\\frac{\\Delta t}{2}\\gamma_i\\right)V_{i+1}^{n}\n$$\n这就为 $N-1$ 个未知内部值 $\\{V_1^{n+1}, \\dots, V_{N-1}^{n+1}\\}$ 构成了一个包含 $N-1$ 个线性方程的三对角系统。必须将已知的边界值 $V_0$ 和 $V_N$ 纳入考虑。狄利克雷边界条件是 $V(0, t) = K e^{-r(T-t)}$ 和 $V(S_{\\max}, t) = 0$。\n因此，$V_0^n = K$，$V_N^n = 0$，$V_0^{n+1} = Ke^{-r\\Delta t}$，以及 $V_N^{n+1} = 0$。\n对于第一个内部方程（$i=1$），涉及 $V_0^{n+1}$ 的项是已知的，并移至右侧。因此，第一个方程的右侧通过减去 $(\\frac{\\Delta t}{2}\\alpha_1)V_0^{n+1}$ 来进行修正。对于最后一个内部方程（$i=N-1$），涉及 $V_N^{n+1}$ 和 $V_N^n$ 的项为零，无需调整。\n\n其次，Rannacher 阻尼格式包括两个初始的全隐式（后向欧拉）步骤，每步大小为 $\\Delta t/2$ 的半步。我们只需要执行这两步来覆盖所需的大小为 $\\Delta t$ 的单个时间步。更新规则是：\n$$\n\\begin{aligned}\n\\text{Step 1: } \\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+\\frac{1}{2}} &= V^n \\\\\n\\text{Step 2: } \\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} &= V^{n+\\frac{1}{2}}\n\\end{aligned}\n$$\n其中 $V^{n+\\frac{1}{2}}$ 是在中间时间 $t = T - \\Delta t/2$ 的解。左侧的算子矩阵与 Crank-Nicolson 方法中使用的矩阵相同。\n对于步骤1，右侧是内部点的向量 $V^n$。在 $S=0$ 处的边界条件是 $V_0^{n+\\frac{1}{2}} = Ke^{-r\\Delta t/2}$。第一个方程（$i=1$）的右侧通过减去 $(\\frac{\\Delta t}{2}\\alpha_1)V_0^{n+\\frac{1}{2}}$ 进行调整。\n对于步骤2，右侧是在步骤1中计算出的向量 $V^{n+\\frac{1}{2}}$。在 $S=0$ 处的边界条件是 $V_0^{n+1} = Ke^{-r\\Delta t}$。第一个方程的右侧通过减去 $(\\frac{\\Delta t}{2}\\alpha_1)V_0^{n+1}$进行调整。\n在两种格式中，所得的三对角系统都使用 Thomas 算法求解，这是一种用于此类系统的直接且数值稳定的方法。\n\n最后，为了量化伪振荡，我们分析计算出的解 $V^{n+1}$。看跌期权的价值必须是资产价格 $S$ 的单调非增函数。因此，任何正的离散斜率 $\\Delta V_i = V_{i+1} - V_i > 0$ 都表示对该性质的违背，并且是数值伪振荡的特征。我们计算两个度量指标：整个网格上此类违背的总数，以及在以行权价 $K$ 为中心、半宽为 $w$ 的指定窗口内的计数。差分索引 $i$ 的窗口定义为 $i \\in \\{\\max(0, i_K-w), \\dots, \\min(N-1, i_K+w)\\}$，其中 $i_K = \\lfloor K/\\Delta S \\rfloor$。我们还计算最大正斜率 $\\max(0, \\max_{i \\text{ in window}} \\Delta V_i)$，作为行权价附近振荡幅度的度量。为每个测试案例计算这六个量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tridiagonal(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm.\n    a: sub-diagonal (length n-1)\n    b: main diagonal (length n)\n    c: super-diagonal (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n - 1)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    if n == 0:\n        return x\n    \n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n - 1):\n        denum = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / denum\n    for i in range(1, n):\n        denum = b[i] - a[i - 1] * c_prime[i - 1]\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / denum\n\n    # Backward substitution\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n\n    return x\n\ndef analyze_oscillations(values, N, dS, K, w):\n    \"\"\"\n    Analyzes the solution vector for monotonicity violations.\n    \"\"\"\n    diffs = np.diff(values)\n    \n    # Full grid analysis\n    full_grid_violations = np.sum(diffs > 0.0)\n\n    # Window analysis\n    i_K = int(np.floor(K / dS))\n    window_start = max(0, i_K - w)\n    window_end = min(N - 1, i_K + w)\n    \n    window_diffs = diffs[window_start : window_end + 1]\n    \n    window_violations = np.sum(window_diffs > 0.0)\n    max_overshoot = 0.0\n    if window_diffs.size > 0:\n        max_overshoot = np.max(window_diffs, initial=0.0)\n\n    return int(full_grid_violations), int(window_violations), float(max_overshoot)\n\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for the Black-Scholes PDE problem.\n    \"\"\"\n    N, M, K, T, S_max, r, sigma, w = case_params\n\n    # Grid setup\n    dt = T / M\n    dS = S_max / N\n    S = np.linspace(0, S_max, N + 1)\n\n    # Terminal condition V(S, T)\n    V_current = np.maximum(K - S, 0.0)\n\n    # Discretized operator coefficients\n    i = np.arange(1, N)\n    alpha = 0.5 * sigma**2 * i**2 - 0.5 * r * i\n    beta = -sigma**2 * i**2 - r\n    gamma = 0.5 * sigma**2 * i**2 + 0.5 * r * i\n\n    # --- 1. Crank-Nicolson Scheme ---\n    \n    # LHS matrix (I + dt/2 * A) diagonals\n    # System is defined for interior points [1, ..., N-1]\n    # Matrix size is (N-1) x (N-1)\n    a_LHS = 0.5 * dt * alpha[1:]          # sub-diagonal, length N-2\n    b_LHS = 1.0 + 0.5 * dt * beta         # main-diagonal, length N-1\n    c_LHS = 0.5 * dt * gamma[:-1]         # super-diagonal, length N-2\n\n    # RHS vector (I - dt/2 * A)V^n\n    V_int_current = V_current[1:N]\n    rhs_cn = (1.0 - 0.5 * dt * beta) * V_int_current\n    rhs_cn[1:] -= 0.5 * dt * alpha[1:] * V_current[1:N-1] # V_{i-1} term\n    rhs_cn[:-1] -= 0.5 * dt * gamma[:-1] * V_current[2:N] # V_{i+1} term\n    \n    # Boundary conditions for CN\n    v0_n = K\n    v0_n_plus_1 = K * np.exp(-r * dt)\n    \n    # Adjust RHS for BC: term with V_0_n\n    rhs_cn[0] -= 0.5 * dt * alpha[0] * v0_n\n    # Adjust RHS for BC: move known V_0_n+1 term from LHS\n    rhs_cn[0] -= 0.5 * dt * alpha[0] * v0_n_plus_1\n    \n    # Solve tridiagonal system for interior points\n    V_int_new_cn = solve_tridiagonal(a_LHS, b_LHS, c_LHS, rhs_cn)\n\n    # Assemble full solution vector\n    V_cn = np.zeros(N + 1)\n    V_cn[0] = v0_n_plus_1\n    V_cn[1:N] = V_int_new_cn\n    V_cn[N] = 0.0 # V(S_max, t) = 0\n\n    # Analyze oscillations\n    cn_full, cn_window, cn_max_slope = analyze_oscillations(V_cn, N, dS, K, w)\n\n    # --- 2. Rannacher Damping Scheme ---\n\n    # LHS matrix is the same as for CN\n    # This matrix is used for both half-steps\n    \n    # Step 1: V^n -> V^(n+1/2)\n    V_int_step1_rhs = V_int_current.copy()\n    v0_n_plus_half = K * np.exp(-r * dt * 0.5)\n    # Adjust RHS for BC: move known V_0_n+1/2 term from LHS\n    V_int_step1_rhs[0] -= 0.5 * dt * alpha[0] * v0_n_plus_half\n    \n    V_int_half = solve_tridiagonal(a_LHS, b_LHS, c_LHS, V_int_step1_rhs)\n\n    # Step 2: V^(n+1/2) -> V^(n+1)\n    V_int_step2_rhs = V_int_half.copy()\n    v0_n_plus_1 = K * np.exp(-r * dt)\n    # Adjust RHS for BC: move known V_0_n+1 term from LHS\n    V_int_step2_rhs[0] -= 0.5 * dt * alpha[0] * v0_n_plus_1\n    \n    V_int_new_rannacher = solve_tridiagonal(a_LHS, b_LHS, c_LHS, V_int_step2_rhs)\n\n    # Assemble full solution vector\n    V_rannacher = np.zeros(N + 1)\n    V_rannacher[0] = v0_n_plus_1\n    V_rannacher[1:N] = V_int_new_rannacher\n    V_rannacher[N] = 0.0\n\n    # Analyze oscillations\n    r_full, r_window, r_max_slope = analyze_oscillations(V_rannacher, N, dS, K, w)\n\n    return [cn_full, cn_window, r_full, r_window, cn_max_slope, r_max_slope]\n\ndef solve():\n    # Define parameters common to all cases\n    K = 100.0\n    T = 1.0\n    S_max = 500.0\n    r = 0.05\n    sigma = 0.2\n    w = 5\n    \n    # Define the test cases from the problem statement\n    test_cases_params = [\n        # (N, M)\n        (200, 10),  # Case A\n        (400, 50),  # Case B\n        (400, 200), # Case C\n    ]\n\n    results = []\n    for N, M in test_cases_params:\n        case_params = (N, M, K, T, S_max, r, sigma, w)\n        case_results = run_case(case_params)\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # e.g. [[1,2,3,4,5.0,6.0],[...],[...]]\n    formatted_results = [\n        \"[\" + \",\".join(map(str, res)) + \"]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "我们如何在不显著增加计算成本或改变基本算法的情况下，提高数值解的精度？本实践将介绍理查森外推法 (Richardson Extrapolation)，这是一种实现此目标的强大技术。通过组合两个不同时间步长下的解，你将构建一个更高阶的精确估计，这为你提升金融模型的精度提供了一个实用的工具。[@problem_id:2391443]", "id": "2391443", "problem": "考虑在风险中性定价原则下，一个针对无股息支付资产的欧式看涨期权的 Black–Scholes 偏微分方程 (PDE)。该资产的现货价格为 $S$，执行价格为 $K$，波动率为 $\\sigma$，连续复利无风险利率为 $r$，到期时间为 $T$。其价值函数 $V(S,t)$ 在 $0 < S < S_{\\max}$ 和 $0 \\le t < T$ 的范围内，满足以下后向抛物型偏微分方程：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其终端条件为 $V(S,T) = \\max(S - K, 0)$，对于欧式看涨期权，其边界条件如下：$V(0,t) = 0$，并且对于大的资产价格，有 $V(S_{\\max},t) = S_{\\max} - K e^{-r (T - t)}$。假设 $S_{\\max}$ 足够大，以确保该边界条件的准确性。\n\n您的任务是实现一个 Crank–Nicolson 有限差分求解器，在均匀的空间网格上将该 PDE 从 $t=T$ 到 $t=0$ 进行时间上的后向步进求解。对一阶和二阶导数使用空间中心差分。然后，通过在同一空间网格上计算两次 $t=0$ 时的解来进行时间上的 Richardson 外推法：一次使用时间步长 $\\Delta t = T/N$，另一次使用 $\\Delta t/2 = T/(2N)$，并将它们组合成一个更高阶的估计值。具体来说，如果 $p$ 表示该格式的时间精度阶数，则在任何固定空间点上的外推估计值为：\n$$\nV_{\\mathrm{Rich}} = V_{\\Delta t/2} + \\frac{V_{\\Delta t/2} - V_{\\Delta t}}{2^p - 1}.\n$$\n对于 Crank–Nicolson 方法，取 $p=2$。对于每种情况，报告在给定现货价格 $S_0$ 处的外推期权价值。\n\n作为对经过充分检验的公式的验证，您还需要使用相同的 $S_0$, $K$, $r$, $\\sigma$ 和 $T$ 参数，通过 Black–Scholes 解析解计算相应的欧式看涨期权价格。对于 $\\sigma = 0$ 的退化情况，使用风险中性极限 $V_{\\mathrm{BS}} = \\max(S_0 - K e^{-r T}, 0)$。对于 $\\sigma > 0$ 的情况，在 Black–Scholes 公式中使用标准的高斯累积分布函数。对于每种情况，报告 Richardson 外推有限差分估计值与 Black–Scholes 解析价格之间的绝对误差。\n\n实现要求：\n- 空间网格：在 $[0, S_{\\max}]$ 范围内对 $S$ 进行均匀划分，包含 $M$ 个子区间（即 $M+1$ 个网格点）。使用 $M \\ge 2$。\n- 时间步进：采用 Crank–Nicolson 隐式方法，以均匀步长从 $t=T$ 后向步进至 $t=0$。\n- 线性系统求解器：利用三对角结构，通过 Thomas 算法或等效的带状求解器进行求解。\n- 插值：通过在 $S$ 网格上进行线性插值，返回在 $t=0$ 和 $S_0$ 处的价格。\n- Richardson 外推法：将来自 $\\Delta t$ 和 $\\Delta t/2$ 的解与 $p=2$ 结合，公式为 $V_{\\mathrm{Rich}} = V_{\\Delta t/2} + \\frac{V_{\\Delta t/2} - V_{\\Delta t}}{3}$。\n- 单位：为便于计算，所有货币量均为名义值且无单位；将数值报告为浮点数。\n- 角度单位不适用。\n\n测试套件：\n实现您的程序以运行以下四个参数集，每个参数集指定为一个元组 $(S_0, K, r, \\sigma, T, S_{\\max}, M, N)$：\n1) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (100, 100, 0.05, 0.2, 1.0, 400, 200, 50)$。\n2) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (80, 100, 0.03, 0.25, 2.0, 400, 200, 80)$。\n3) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (120, 100, 0.0, 0.2, 0.25, 400, 200, 40)$。\n4) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (100, 100, 0.05, 0.0, 1.0, 400, 200, 40)$。\n\n对于每种情况 $i \\in \\{1,2,3,4\\}$，计算：\n- 在 $t=0$ 和 $S_0$ 处的 Richardson 外推 Crank–Nicolson 估计值 $V_{\\mathrm{Rich},i}$。\n- 绝对误差 $E_i = |V_{\\mathrm{Rich},i} - V_{\\mathrm{BS},i}|$，其中 $V_{\\mathrm{BS},i}$ 是相同参数下的 Black–Scholes 解析价格。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n[V_{\\mathrm{Rich},1}, E_1, V_{\\mathrm{Rich},2}, E_2, V_{\\mathrm{Rich},3}, E_3, V_{\\mathrm{Rich},4}, E_4].\n$$\n所有条目必须是浮点数。不应打印任何其他文本。", "solution": "所提出的问题是计算金融学中的一个标准练习，要求对欧式看涨期权的 Black–Scholes 偏微分方程 (PDE) 进行数值求解。该问题定义明确、科学上合理且内部一致。它明确了 PDE、终端和边界条件，以及所需的数值方法——结合 Richardson 外推的 Crank–Nicolson 方法。所有测试用例的参数均已提供，并且通过与解析解进行验证是一种标准且恰当的检验程序。因此，该问题被认为是**有效的**。\n\n我们接下来着手构建解决方案。Black–Scholes PDE 如下：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n这是一个后向抛物型 PDE。为便于数值计算，我们进行变量替换，将其转换为前向时间 $\\tau = T - t$。PDE 变换为：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\n我们对该方程从 $\\tau=0$ 到 $\\tau=T$ 进行求解。在 $t=T$ 时的终端条件变成了在 $\\tau=0$ 时的初始条件：\n$$\nV(S, \\tau=0) = \\max(S - K, 0)\n$$\n边界条件为：\n$$\nV(0, \\tau) = 0 \\quad \\text{and} \\quad V(S_{\\max}, \\tau) = S_{\\max} - K e^{-r\\tau}\n$$\n\n我们在均匀网格上对求解域进行离散化：\n- 空间网格：$S_i = i \\Delta S$，其中 $i = 0, 1, \\dots, M$，$\\Delta S = S_{\\max} / M$。\n- 时间网格：$\\tau_j = j \\Delta \\tau$，其中 $j = 0, 1, \\dots, N$，$\\Delta \\tau = T / N$。\n令 $V_i^j$ 表示 $V(S_i, \\tau_j)$ 的数值近似解。\n\n应用 Crank–Nicolson 方法，这是一种隐式有限差分格式，它对时间步 $j$ 和 $j+1$ 上的空间导数取平均：\n$$\n\\frac{V_i^{j+1} - V_i^j}{\\Delta \\tau} = \\frac{1}{2} \\left( \\mathcal{L}_h V_i^{j+1} + \\mathcal{L}_h V_i^j \\right)\n$$\n其中 $\\mathcal{L}_h$ 是使用中心差分法离散化的空间算子：\n$$\n\\mathcal{L}_h V_i = \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} - \\frac{r S_i}{2(2\\Delta S)}\\right)V_{i-1} + \\left(-\\frac{\\sigma^2 S_i^2}{(\\Delta S)^2} - r\\right)V_i + \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} + \\frac{r S_i}{2(2\\Delta S)}\\right)V_{i+1}\n$$\n代入 $S_i = i\\Delta S$，得到 $V_{i-1}$、$V_i$ 和 $V_{i+1}$ 的算子系数为：\n$$\n\\alpha_i = \\frac{1}{2}\\sigma^2 i^2 - \\frac{1}{2}ri, \\quad \\beta_i = -\\sigma^2 i^2 - r, \\quad \\gamma_i = \\frac{1}{2}\\sigma^2 i^2 + \\frac{1}{2}ri\n$$\n重新整理 Crank–Nicolson 格式，将未知值 $V^{j+1}$ 分离到左侧 (LHS)，已知值 $V^j$ 放在右侧 (RHS)：\n$$\n\\left(I - \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^{j+1} = \\left(I + \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^j\n$$\n这表示一个针对内部网格点 $i=1, \\dots, M-1$ 的线性方程组。该系统是三对角的：\n$$\na_i V_{i-1}^{j+1} + b_i V_i^{j+1} + c_i V_{i+1}^{j+1} = d_i\n$$\n其中 LHS 的系数为：\n$$\na_i = -\\frac{\\Delta \\tau}{2}\\alpha_i, \\quad b_i = 1 - \\frac{\\Delta \\tau}{2}\\beta_i, \\quad c_i = -\\frac{\\Delta \\tau}{2}\\gamma_i\n$$\nRHS 由时间步 $j$ 的已知值构成：\n$$\nd_i = \\frac{\\Delta \\tau}{2}\\alpha_i V_{i-1}^j + \\left(1 + \\frac{\\Delta \\tau}{2}\\beta_i\\right) V_i^j + \\frac{\\Delta \\tau}{2}\\gamma_i V_{i+1}^j\n$$\n边界条件 $V_0^{j+1}=0$ 和 $V_M^{j+1}=S_{\\max}-Ke^{-r\\tau_{j+1}}$ 被并入线性系统的第一个 ($i=1$) 和最后一个 ($i=M-1$) 方程中。由此产生的三对角系统可在每个时间步使用专门的算法（如 `scipy.linalg.solve_banded` 中可用的 Thomas 算法）进行高效求解。\n\n此过程从 $\\tau=0$ 迭代至 $\\tau=T$。最终的解向量 $V^N$ 给出 $t=0$ 时的期权价值。为找到特定现货价格 $S_0$ 处的价值，我们对最终的网格值使用线性插值。\n\n该过程运行两次：一次使用 $N$ 个时间步（步长 $\\Delta \\tau = T/N$），得到解 $V_{\\Delta \\tau}$；另一次使用 $2N$ 个时间步（步长 $\\Delta \\tau/2 = T/(2N)$），得到解 $V_{\\Delta \\tau/2}$。由于 Crank–Nicolson 方法的时间精度阶数为 $p=2$，我们应用 Richardson 外推法以获得一个更精确的估计：\n$$\nV_{\\mathrm{Rich}} = V_{\\Delta \\tau/2} + \\frac{V_{\\Delta \\tau/2} - V_{\\Delta \\tau}}{2^p - 1} = V_{\\Delta \\tau/2} + \\frac{V_{\\Delta \\tau/2} - V_{\\Delta \\tau}}{3}\n$$\n\n为了验证，将此数值结果与欧式看涨期权的 Black–Scholes 解析公式进行比较：\n$$\nV_{\\mathrm{BS}}(S, t) = S_0 N(d_1) - K e^{-r(T-t)} N(d_2)\n$$\n其中 $N(\\cdot)$ 是标准正态累积分布函数 (CDF)，且\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)(T-t)}{\\sigma\\sqrt{T-t}}, \\quad d_2 = d_1 - \\sigma\\sqrt{T-t}\n$$\n在零波动率 ($\\sigma=0$) 的情况下，该公式退化为风险中性折现收益：\n$$\nV_{\\mathrm{BS}}(S_0, t) = \\max(S_0 - K e^{-r(T-t)}, 0)\n$$\n在 $t=0$ 时的绝对误差 $E = |V_{\\mathrm{Rich}} - V_{\\mathrm{BS}}|$ 量化了我们数值实现的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erf\n\ndef black_scholes_analytical(S0, K, r, sigma, T):\n    \"\"\"\n    Computes the analytical Black-Scholes price for a European call option.\n    \"\"\"\n    if sigma == 0:\n        return np.maximum(S0 - K * np.exp(-r * T), 0)\n\n    def norm_cdf(x):\n        return 0.5 * (1 + erf(x / np.sqrt(2)))\n\n    if T == 0:\n        return np.maximum(S0 - K, 0)\n        \n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    \n    call_price = S0 * norm_cdf(d1) - K * np.exp(-r * T) * norm_cdf(d2)\n    return call_price\n\ndef run_crank_nicolson(S0, K, r, sigma, T, Smax, M, N_steps):\n    \"\"\"\n    Solves the Black-Scholes PDE using the Crank-Nicolson method.\n    \"\"\"\n    # Grid parameters\n    dt = T / N_steps\n    dS = Smax / M\n    S_vec = np.linspace(0, Smax, M + 1)\n    \n    # Grid of interior asset prices\n    i_vec = np.arange(1, M)\n\n    # Initial condition at t=T (tau=0)\n    V = np.maximum(S_vec - K, 0)\n    \n    # Coefficients for the tridiagonal system. These are constant in time.\n    # LHS matrix A = I - dt/2 * L_h\n    # where L_h is the discretized spatial operator\n    alpha = 0.5 * (sigma**2 * i_vec**2 - r * i_vec)\n    beta = -(sigma**2 * i_vec**2 + r)\n    gamma = 0.5 * (sigma**2 * i_vec**2 + r * i_vec)\n    \n    # LHS matrix elements\n    l = -0.5 * dt * alpha\n    d = 1 - 0.5 * dt * beta\n    u = -0.5 * dt * gamma\n\n    # Banded matrix format for scipy's solver: (l, u), (M-1)\n    # The matrix has 1 lower and 1 upper diagonal.\n    A_banded = np.zeros((3, M - 1))\n    A_banded[0, 1:] = u[:-1]\n    A_banded[1, :] = d\n    A_banded[2, :-1] = l[1:]\n    \n    # Time-stepping loop (forward in tau, backward in t)\n    for j in range(1, N_steps + 1):\n        tau = j * dt\n        \n        # RHS vector: B * V^j = (I + dt/2 * L_h) * V^j\n        # The elements of B are given by changing signs of off-diagonal elements of A\n        # and changing the main diagonal from (1-...) to (1+...).\n        rhs = (0.5 * dt * alpha) * V[:-2] + (1 + 0.5 * dt * beta) * V[1:-1] + (0.5 * dt * gamma) * V[2:]\n        \n        # Boundary conditions at time tau\n        # V(0, tau) = 0 is handled implicitly as V[0] = 0.\n        V_M_tau = Smax - K * np.exp(-r * tau)\n        \n        # Adjust RHS for the known boundary value at S_max\n        # The term u[-1] * V_M_tau from the LHS matrix is moved to the RHS.\n        rhs[-1] -= u[-1] * V_M_tau\n        \n        # Solve the tridiagonal system A*V_new = rhs\n        V_interior = solve_banded((1, 1), A_banded, rhs, check_finite=False)\n        \n        # Update V for the next time step\n        V[1:-1] = V_interior\n        V[-1] = V_M_tau # Dirichlet boundary condition at S_max\n\n    # Interpolate to find the price at S0\n    return np.interp(S0, S_vec, V)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate final output.\n    \"\"\"\n    test_cases = [\n        # (S0, K, r, sigma, T, Smax, M, N)\n        (100, 100, 0.05, 0.2, 1.0, 400, 200, 50),\n        (80, 100, 0.03, 0.25, 2.0, 400, 200, 80),\n        (120, 100, 0.0, 0.2, 0.25, 400, 200, 40),\n        (100, 100, 0.05, 0.0, 1.0, 400, 200, 40),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, K, r, sigma, T, Smax, M, N = case\n        \n        # Calculate numerical solution with N and 2*N time steps\n        V_N = run_crank_nicolson(S0, K, r, sigma, T, Smax, M, N)\n        V_2N = run_crank_nicolson(S0, K, r, sigma, T, Smax, M, 2 * N)\n        \n        # Richardson Extrapolation (p=2 for Crank-Nicolson)\n        # V_rich = V_2N + (V_2N - V_N) / (2^p - 1)\n        V_rich = V_2N + (V_2N - V_N) / 3.0\n        \n        # Calculate analytical solution for comparison\n        V_bs = black_scholes_analytical(S0, K, r, sigma, T)\n        \n        # Calculate absolute error\n        error = np.abs(V_rich - V_bs)\n        \n        results.extend([V_rich, error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}
