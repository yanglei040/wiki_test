{"hands_on_practices": [{"introduction": "真实的金融市场是多维度的，风险源自多个方面。本练习将引导您超越单因子模型，构建一个双因子仿射模型，以同时为利率收益率和股票市场波动的期限结构（VIX期货曲线）定价。您将实现两个经典的随机过程——Ornstein-Uhlenbeck过程用于利率，Cox-Ingersoll-Ross (CIR) 过程用于方差——并利用它们之间的独立性来简化校准过程 [@problem_id:2370052]。这个实践将展示仿射框架的强大扩展性，以及如何整合来自不同资产类别的数据来构建一个更全面的市场模型。", "id": "2370052", "problem": "您的任务是构建和校准一个联合仿射期限结构模型，该模型能同时为连续复利零息利率收益率和 Cboe 波动率指数 (VIX) 期货的期限结构定价。所有量都必须以年化单位的小数形式表示。例如，十分之二的年化收益率必须写作 $0.2$，百分之四的年化方差必须写作 $0.04$。本问题不涉及角度，因此不需要角度单位。\n\n该模型是在风险中性概率测度（记为 $\\mathbb{Q}$）下指定的。状态由两个独立的一维因子组成：一个用于利率的 Ornstein–Uhlenbeck 因子和一个用于股权方差的 Cox–Ingersoll–Ross 因子。动态过程如下：\n- 利率因子：$dx_t = k_x (\\theta_x - x_t)\\,dt + \\sigma_x\\,dW^{(1)}_t$，其中 $W^{(1)}$ 是一个标准布朗运动。\n- 瞬时利率：$r_t = \\delta_0 + x_t$。\n- 股权瞬时方差因子：$dv_t = k_v (\\theta_v - v_t)\\,dt + \\sigma_v \\sqrt{v_t}\\,dW^{(2)}_t$，其中 $W^{(2)}$ 是一个独立的标准布朗运动。\n\n假设 $W^{(1)}$ 和 $W^{(2)}$ 相互独立。待校准的参数向量为 $p = [k_x,\\theta_x,\\sigma_x,\\delta_0,x_0,k_v,\\theta_v,v_0]$，其中 $x_0 = x_t$ 和 $v_0 = v_t$ 是在时间 $t$ 的当前状态。所有代表利率、波动率或水平的参数都必须为非负，但 $x_0$ 可以为负。\n\n对于期限 $\\tau > 0$，零息债券的模型价格由其风险中性定价定义：\n$$\nP(t,t+\\tau) \\equiv \\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\exp\\!\\left(-\\int_t^{t+\\tau} r_s\\,ds\\right)\\Big|\\,x_t\\right],\n$$\n模型收益率定义为连续复利年化收益率\n$$\ny(\\tau) \\equiv -\\frac{1}{\\tau}\\,\\ln P(t,t+\\tau).\n$$\n\n对于一个在时间 $T \\ge 0$ 到期的 VIX 期货合约，设 VIX 时间窗口长度为 $\\Delta = 30/365$ 年。在本问题中，将 VIX 期货报价定义为在 $[T,T+\\Delta]$ 期间风险中性预期平均年化方差的平方根：\n$$\nF_{\\mathrm{VIX}}(T) \\equiv \\left(\\frac{1}{\\Delta}\\,\\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\int_T^{T+\\Delta} v_s\\,ds\\ \\Big|\\ v_t\\right]\\right)^{1/2}.\n$$\n所有的 $F_{\\mathrm{VIX}}(T)$ 都必须以小数（例如，$0.2$）表示，而不是百分比。\n\n您的程序必须从第一性原理出发，实现上述定价定义，推导任何必要的中间关系，并通过最小化每个下述测试用例的观测值与模型隐含量之间的平方差之和来校准参数向量 $p$。您必须仅使用本问题陈述中给出的模型、定义和数据。\n\n测试套件。对于每个测试用例，观测市场数据必须使用所提供的真实参数 $p^{\\mathrm{true}}$ 以及上述 $P(t,t+\\tau)$ 和 $F_{\\mathrm{VIX}}(T)$ 的定义从模型中精确生成（即数据是无噪声的）。然后，使用最小二乘法校准 $p$，从这些可观测值中恢复真实参数，同时需满足自然的非负性约束和合理的边界。对于每个测试用例，报告一个布尔值，当且仅当校准后的参数向量 $\\hat{p}$ 的所有分量都对容忍度向量 $\\varepsilon$ 满足 $|\\hat{p}_i - p^{\\mathrm{true}}_i| \\le \\varepsilon_i$ 时，该值为真。\n$$\n\\varepsilon = [0.05,\\ 0.005,\\ 0.005,\\ 0.002,\\ 0.005,\\ 0.10,\\ 0.005,\\ 0.010].\n$$\n\n在所有情况下均使用 $\\Delta = 30/365$ 年。每个测试的期限和真实参数如下：\n\n- 情况1（基准）：\n  - 收益率期限 $\\tau = [0.25,\\ 1.0,\\ 2.0,\\ 5.0,\\ 10.0]$ 年。\n  - VIX 期货期限 $T = [0.0,\\ 0.25,\\ 0.5,\\ 1.0]$ 年。\n  - 真实参数 $p^{\\mathrm{true}} = [0.6,\\ 0.02,\\ 0.02,\\ 0.01,\\ 0.015,\\ 1.5,\\ 0.04,\\ 0.05]$。\n\n- 情况2（低利率，低方差）：\n  - 收益率期限 $\\tau = [0.25,\\ 1.0,\\ 2.0,\\ 5.0,\\ 10.0]$ 年。\n  - VIX 期货期限 $T = [0.0,\\ 0.25,\\ 0.5,\\ 1.0]$ 年。\n  - 真实参数 $p^{\\mathrm{true}} = [0.5,\\ 0.01,\\ 0.01,\\ 0.0,\\ 0.005,\\ 2.0,\\ 0.02,\\ 0.015]$。\n\n- 情况3（慢均值回归，长端）：\n  - 收益率期限 $\\tau = [0.5,\\ 3.0,\\ 7.0,\\ 15.0,\\ 20.0]$ 年。\n  - VIX 期货期限 $T = [0.0,\\ 0.5,\\ 1.0,\\ 2.0]$ 年。\n  - 真实参数 $p^{\\mathrm{true}} = [0.2,\\ 0.03,\\ 0.015,\\ 0.005,\\ 0.025,\\ 0.8,\\ 0.06,\\ 0.08]$。\n\n您的程序必须：\n1. 对于每个测试用例，使用给定的 $p^{\\mathrm{true}}$ 从模型中精确生成观测收益率和 VIX 期货。\n2. 通过最小化该情况下模型隐含值与观测值（收益率和 VIX 期货）之间的平方偏差和来校准 $\\hat{p}$。\n3. 将绝对偏差 $|\\hat{p}_i - p^{\\mathrm{true}}_i|$ 与容忍度向量 $\\varepsilon$ 进行比较。\n4. 将三个布尔结果汇总到一个列表中。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个布尔结果，格式为逗号分隔的列表并用方括号括起来，例如，“[True,False,True]”。不应打印任何其他文本。所有利率、波动率和方差在整个过程中都必须作为年化小数处理。", "solution": "所提出的问题是在计算金融的既定框架内一个适定 (well-posed) 的校准任务。它要求构建和校准一个双因子仿射期限结构模型。状态变量包括一个用于利率因子的 Ornstein-Uhlenbeck (Vasicek) 过程和一个用于随机方差因子的 Cox-Ingersoll-Ross (CIR) 过程。该问题具有科学依据，内部一致，并包含获得唯一解所需的所有必要信息。因此，它被认为是有效的，并且下面提供了完整的解决方案。\n\n解决方案的核心在于推导出模型隐含的可观测量的解析闭式表达式：零息收益率曲线 $y(\\tau)$ 和 VIX 期货期限结构 $F_{\\mathrm{VIX}}(T)$。由于指定了基础布朗运动 $W^{(1)}_t$ 和 $W^{(2)}_t$ 的独立性，校准问题可以幸运地解耦为两个独立的、较小的优化问题。一个是从收益率数据中校准利率参数，另一个是从 VIX 期货数据中校准方差过程参数。\n\n**1. 利率模型和收益率曲线**\n\n瞬时利率 $r_t$ 定义为状态变量 $x_t$ 的仿射函数：\n$$\nr_t = \\delta_0 + x_t\n$$\n其中 $x_t$ 在风险中性测度 $\\mathbb{Q}$ 下遵循 Ornstein-Uhlenbeck 过程：\n$$\ndx_t = k_x (\\theta_x - x_t)\\,dt + \\sigma_x\\,dW^{(1)}_t\n$$\n这种结构是 Vasicek 模型的一个变体。在时间 $t+\\tau$ 到期的零息债券的价格由风险中性期望给出：\n$$\nP(t, t+\\tau) = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\exp\\!\\left(-\\int_t^{t+\\tau} r_s\\,ds\\right)\\Big|\\,x_t\\right] = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\exp\\!\\left(-\\int_t^{t+\\tau} (\\delta_0 + x_s)\\,ds\\right)\\Big|\\,x_t\\right]\n$$\n这可以分解为 $P(t, t+\\tau) = \\exp(-\\delta_0 \\tau) \\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\exp\\!\\left(-\\int_t^{t+\\tau} x_s\\,ds\\right)\\Big|\\,x_t\\right]$。\n对于仿射模型，债券价格呈指数-仿射形式。期望项是常数漂移为零的 Vasicek 模型中的标准债券价格，可以写成 $\\exp(A_x(\\tau) - B_x(\\tau)x_t)$。因此，完整的债券价格为：\n$$\nP(t, t+\\tau) = \\exp(A_x(\\tau) - \\delta_0 \\tau - B_x(\\tau)x_t)\n$$\n其中 $B_x(\\tau)$ 和 $A_x(\\tau)$ 是从 Feynman-Kac 定理推导出的 Riccati 型常微分方程的解。解为：\n$$\nB_x(\\tau) = \\frac{1 - e^{-k_x \\tau}}{k_x}\n$$\n$$\nA_x(\\tau) = (\\theta_x - \\frac{\\sigma_x^2}{2k_x^2})(B_x(\\tau) - \\tau) - \\frac{\\sigma_x^2}{4k_x}B_x^2(\\tau)\n$$\n然后根据其定义可以找到连续复利收益率 $y(\\tau)$：\n$$\ny(\\tau) = -\\frac{1}{\\tau} \\ln P(t, t+\\tau) = -\\frac{1}{\\tau} (A_x(\\tau) - \\delta_0 \\tau - B_x(\\tau)x_t) = \\frac{B_x(\\tau)}{\\tau}x_t - \\frac{A_x(\\tau)}{\\tau} + \\delta_0\n$$\n这为给定到期日 $\\tau$ 的收益率提供了一个闭式表达式，该表达式是参数 $\\{k_x, \\theta_x, \\sigma_x, \\delta_0\\}$ 和当前状态 $x_t$ 的函数。\n\n**2. 股权方差模型和 VIX 期货**\n\n瞬时方差 $v_t$ 由 CIR 过程控制：\n$$\ndv_t = k_v (\\theta_v - v_t)\\,dt + \\sigma_v \\sqrt{v_t}\\,dW^{(2)}_t\n$$\nVIX 期货报价 $F_{\\mathrm{VIX}}(T)$ 由预期的未来平均方差定义：\n$$\nF_{\\mathrm{VIX}}(T)^2 = \\frac{1}{\\Delta}\\,\\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\int_T^{T+\\Delta} v_s\\,ds\\ \\Big|\\ v_t\\right]\n$$\n根据期望的线性和 Fubini 定理，我们可以交换期望和积分算子：\n$$\n\\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\int_T^{T+\\Delta} v_s\\,ds\\ \\Big|\\ v_t\\right] = \\int_T^{T+\\Delta} \\mathbb{E}^{\\mathbb{Q}}[v_s | v_t]\\,ds\n$$\n对于 CIR 过程，未来状态的条件期望具有已知的闭式解：\n$$\n\\mathbb{E}^{\\mathbb{Q}}[v_s | v_t] = v_t e^{-k_v (s-t)} + \\theta_v (1 - e^{-k_v (s-t)})\n$$\n将此表达式从 $s=T$ 到 $s=T+\\Delta$（当前时间为 $t$）进行积分，得到预期的总方差：\n$$\n\\int_T^{T+\\Delta} \\mathbb{E}^{\\mathbb{Q}}[v_s | v_t]\\,ds = \\frac{v_t - \\theta_v}{k_v} (e^{-k_v (T-t)} - e^{-k_v (T+\\Delta-t)}) + \\theta_v \\Delta\n$$\n除以 $\\Delta$ 得到预期的平均方差。为简单起见，设 $t=0$，我们得到 VIX 期货值的平方：\n$$\nF_{\\mathrm{VIX}}(T)^2 = (v_0 - \\theta_v) e^{-k_v T} \\frac{1 - e^{-k_v \\Delta}}{k_v \\Delta} + \\theta_v\n$$\n值得注意的是，该表达式依赖于参数 $\\{k_v, \\theta_v\\}$ 和当前状态 $v_0$，但它与方差的波动率参数 $\\sigma_v$ 无关。这是一个关键的观察，因为它意味着 $\\sigma_v$ 无法仅从 VIX 期货数据中被识别出来，而通过将其从待校准的参数向量中排除，该问题的结构是正确的。\n\n**3. 校准程序**\n\n校准是通过最小化模型隐含值与观测的市场（在本例中为人工生成的）数据之间的平方误差和 (SSE) 来执行的。参数向量 $p = [k_x,\\theta_x,\\sigma_x,\\delta_0,x_0,k_v,\\theta_v,v_0]$ 的目标函数 $L(p)$ 是：\n$$\nL(p) = \\sum_{i} (y^{\\text{model}}(\\tau_i; p) - y^{\\text{obs}}(\\tau_i))^2 + \\sum_{j} (F^{\\text{model}}_{\\mathrm{VIX}}(T_j; p) - F^{\\text{obs}}_{\\mathrm{VIX}}(T_j))^2\n$$\n由于因子的独立性，该目标函数可以分离成两个部分：\n$$\nL(p) = L_x(k_x,\\theta_x,\\sigma_x,\\delta_0,x_0) + L_v(k_v,\\theta_v,v_0)\n$$\n这使我们能够执行两个独立的最小化过程：\n1.  使用收益率数据，通过最小化 $L_x$ 来校准 $p_x = [k_x,\\theta_x,\\sigma_x,\\delta_0,x_0]$。\n2.  使用 VIX 期货数据，通过最小化 $L_v$ 来校准 $p_v = [k_v,\\theta_v,v_0]$。\n\n最小化过程通过数值优化程序执行，特别是 L-BFGS-B 算法，该算法支持箱型约束。对参数的约束为：$k_x, \\sigma_x, k_v, v_0 \\ge \\epsilon > 0$（以保持数值稳定性）以及 $\\theta_x, \\delta_0, \\theta_v \\ge 0$。参数 $x_0$ 无约束。\n\n为了数值稳定性，当均值回归参数 $k_x$ 或 $k_v$ 趋近于零时，使用其相应的泰勒级数展开来评估函数，以避免灾难性抵消和除以零的错误。\n\n对于每个测试用例，程序首先使用提供的真实参数 $p^{\\mathrm{true}}$ 生成“观测”数据。然后，从一个通用的初始猜测值开始，运行两个校准程序以找到估计的参数向量 $\\hat{p}$。最后，它检查 $\\hat{p}$ 的每个分量与 $p^{\\mathrm{true}}$ 之间的绝对差是否在指定的容忍度向量 $\\varepsilon$ 范围内。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the affine term structure model calibration problem for the given test cases.\n    \"\"\"\n    \n    # Global constants\n    DELTA = 30.0 / 365.0\n    EPSILON = np.array([0.05, 0.005, 0.005, 0.002, 0.005, 0.10, 0.005, 0.010])\n\n    def yield_model(p_x, taus):\n        \"\"\"\n        Computes yields for the Vasicek-type model.\n        p_x: [k_x, theta_x, sigma_x, delta_0, x_0]\n        \"\"\"\n        k_x, theta_x, sigma_x, delta_0, x_0 = p_x\n        taus = np.asarray(taus, dtype=float)\n\n        # Handle k_x -> 0 case for numerical stability using a Taylor expansion\n        if abs(k_x) < 1e-8:\n            tau_sq = taus**2\n            yields = (x_0 + delta_0 \n                      - sigma_x**2 * tau_sq / 6.0\n                      - k_x * taus / 2.0 * (x_0 - theta_x))\n            return yields\n        \n        B_x = (1.0 - np.exp(-k_x * taus)) / k_x\n        A_x = ((theta_x - sigma_x**2 / (2.0 * k_x**2)) * (B_x - taus)\n               - (sigma_x**2 / (4.0 * k_x)) * B_x**2)\n        \n        log_p = A_x - delta_0 * taus - B_x * x_0\n        yields = -log_p / taus\n        return yields\n\n    def vix_futures_model(p_v, Ts):\n        \"\"\"\n        Computes VIX futures quotes for the CIR model.\n        p_v: [k_v, theta_v, v_0]\n        \"\"\"\n        k_v, theta_v, v_0 = p_v\n        Ts = np.asarray(Ts, dtype=float)\n\n        # Handle k_v -> 0 case for numerical stability\n        if abs(k_v) < 1e-8:\n            avg_var = v_0 - k_v * (v_0 - theta_v) * (Ts + DELTA / 2.0)\n            avg_var = np.maximum(avg_var, 0)\n            return np.sqrt(avg_var)\n        \n        factor = (1.0 - np.exp(-k_v * DELTA)) / (k_v * DELTA)\n        avg_var = (v_0 - theta_v) * np.exp(-k_v * Ts) * factor + theta_v\n        # Ensure variance is non-negative before taking the square root\n        avg_var = np.maximum(avg_var, 0)\n        \n        return np.sqrt(avg_var)\n\n    test_cases = [\n        {\n            \"tau_yields\": [0.25, 1.0, 2.0, 5.0, 10.0],\n            \"T_vix\": [0.0, 0.25, 0.5, 1.0],\n            \"p_true\": np.array([0.6, 0.02, 0.02, 0.01, 0.015, 1.5, 0.04, 0.05]),\n        },\n        {\n            \"tau_yields\": [0.25, 1.0, 2.0, 5.0, 10.0],\n            \"T_vix\": [0.0, 0.25, 0.5, 1.0],\n            \"p_true\": np.array([0.5, 0.01, 0.01, 0.0, 0.005, 2.0, 0.02, 0.015]),\n        },\n        {\n            \"tau_yields\": [0.5, 3.0, 7.0, 15.0, 20.0],\n            \"T_vix\": [0.0, 0.5, 1.0, 2.0],\n            \"p_true\": np.array([0.2, 0.03, 0.015, 0.005, 0.025, 0.8, 0.06, 0.08]),\n        },\n    ]\n\n    results = []\n    \n    # Define common initial guesses for the optimizers\n    p0_x = np.array([0.4, 0.025, 0.025, 0.01, 0.02])\n    p0_v = np.array([1.0, 0.05, 0.05])\n    \n    # Define bounds for parameters\n    bounds_x = [(1e-6, None), (0, None), (1e-6, None), (0, None), (None, None)]\n    bounds_v = [(1e-6, None), (0, None), (1e-6, None)]\n\n    for case in test_cases:\n        p_true = case[\"p_true\"]\n        tau_yields = case[\"tau_yields\"]\n        T_vix = case[\"T_vix\"]\n        \n        p_true_x = p_true[:5]\n        p_true_v = p_true[5:]\n        \n        # 1. Generate observed data from the true model\n        y_obs = yield_model(p_true_x, tau_yields)\n        f_obs = vix_futures_model(p_true_v, T_vix)\n        \n        # 2. Calibrate parameters\n        \n        # --- Interest rate part ---\n        def objective_x(p_x):\n            y_model = yield_model(p_x, tau_yields)\n            error = np.sum((y_model - y_obs)**2)\n            return error\n\n        res_x = minimize(objective_x, p0_x, method='L-BFGS-B', bounds=bounds_x, options={'ftol': 1e-12})\n        p_hat_x = res_x.x\n\n        # --- Variance part ---\n        def objective_v(p_v):\n            f_model = vix_futures_model(p_v, T_vix)\n            error = np.sum((f_model - f_obs)**2)\n            return error\n\n        res_v = minimize(objective_v, p0_v, method='L-BFGS-B', bounds=bounds_v, options={'ftol': 1e-12})\n        p_hat_v = res_v.x\n        \n        p_hat = np.concatenate((p_hat_x, p_hat_v))\n        \n        # 3. Check against tolerances\n        is_close = np.all(np.abs(p_hat - p_true) <= EPSILON)\n        results.append(is_close)\n\n    # 4. Print final result in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "模型校准的核心是定义一个“最佳拟合”的度量标准。虽然最小化平方误差是一种常见方法，但它并非唯一的选择。本练习介绍了一种基于信息论的强大替代方案：最小化模型所隐含的债券价格分布与经验分布之间的Kullback-Leibler (KL) 散度 [@problem_id:2370055]。通过将校准问题构建为一个 $D_{\\mathrm{KL}}$ 最小化任务，您将探索一种不同的优化目标，并理解其作为衡量两个概率分布之间“距离”的深刻含义。", "id": "2370055", "problem": "考虑一个单因子 Vasicek 类型的仿射期限结构模型 (ATSM)，用于描述风险中性短期利率过程，其中在风险中性测度下，短期利率 $r_t$ 的演化过程为 $dr_t = \\kappa(\\theta - r_t)\\,dt + \\sigma\\,dW_t$。模型参数包括均值回归速度 $\\kappa$、长期均值 $\\theta$、波动率 $\\sigma$ 以及初始短期利率 $r_0$。对于到期日 $T \\ge 0$，模型在时间 $0$ 隐含的零息债券价格由下式给出：\n$$\nP(0,T) = \\exp\\!\\big(A(T) - B(T)\\,r_0\\big),\n$$\n其中\n$$\nB(T) = \\frac{1 - e^{-\\kappa T}}{\\kappa},\n\\qquad\nA(T) = \\left(\\theta - \\frac{\\sigma^2}{2\\kappa^2}\\right)\\big(B(T) - T\\big) - \\frac{\\sigma^2}{4\\kappa}\\,B(T)^2,\n$$\n并约定当 $T=0$ 时，$B(0)=0$ 且 $A(0)=0$。对于一组有限的到期日 $\\{T_i\\}_{i=1}^n$（其中 $T_i \\ge 0$），通过对债券价格进行歸一化，定义在这些到期日上的模型隐含横截面分布：\n$$\nq_i(\\kappa,\\theta,\\sigma,r_0) = \\frac{P(0,T_i)}{\\sum_{j=1}^n P(0,T_j)} \\quad \\text{其中 } i=1,\\dots,n.\n$$\n设 $\\{p_i\\}_{i=1}^n$ 为对应相同到期日的经验横截面分布，满足 $p_i > 0$ 且 $\\sum_{i=1}^n p_i = 1$。定义从经验分布到模型隐含分布的 Kullback–Leibler (KL) 散度（使用自然对数）为：\n$$\nD_{\\mathrm{KL}}\\big(p \\,\\|\\, q(\\kappa,\\theta,\\sigma,r_0)\\big) \\;=\\; \\sum_{i=1}^n p_i \\,\\log\\!\\left(\\frac{p_i}{q_i(\\kappa,\\theta,\\sigma,r_0)}\\right).\n$$\n将校准问题表述为在约束条件 $\\kappa>0$ 和 $\\sigma>0$ 下，关于参数矢量 $(\\kappa,\\theta,\\sigma,r_0)$ 对 $D_{\\mathrm{KL}}$ 进行最小化。假定无套利和风险中性定价成立。本问题不涉及物理单位，也不涉及角度。\n\n测试套件。对于以下三种情况，分别指定了到期日 $\\{T_i\\}$ 和经验分布 $\\{p_i\\}$。在每种情况下，请精确使用给定的到期日（单位：年），并精确使用所提供的经验概率（其总和已为 1）：\n\n- 情况 1：\n  - 到期日：$\\{0.25,\\,0.5,\\,1.0,\\,2.0,\\,5.0,\\,10.0\\}$。\n  - 经验分布：$\\{0.27,\\,0.25,\\,0.20,\\,0.15,\\,0.08,\\,0.05\\}$。\n\n- 情况 2（包含零点边界到期日）：\n  - 到期日：$\\{0.0,\\,0.25,\\,0.5,\\,1.0,\\,4.0,\\,7.0\\}$。\n  - 经验分布：$\\{0.35,\\,0.25,\\,0.18,\\,0.12,\\,0.06,\\,0.04\\}$。\n\n- 情况 3（包含超长到期日）：\n  - 到期日：$\\{0.5,\\,1.0,\\,1.5,\\,2.0,\\,5.0,\\,15.0,\\,30.0\\}$。\n  - 经验分布：$\\{0.26,\\,0.21,\\,0.17,\\,0.14,\\,0.10,\\,0.07,\\,0.05\\}$。\n\n参数域。将搜索范围限制在以下符合经济学常理的集合内：\n$$\n\\kappa \\in [10^{-4},\\,5.0],\\quad \\theta \\in [-0.05,\\,0.15],\\quad \\sigma \\in [10^{-5},\\,0.2],\\quad r_0 \\in [-0.02,\\,0.2].\n$$\n\n要求输出。对于上述每种情况（按顺序），计算 $D_{\\mathrm{KL}}$ 在给定参数域上关于 $(\\kappa,\\theta,\\sigma,r_0)$ 的最小值。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个最小值都四舍五入到小数点后 10 位，例如 $\\big[\\text{result}_1,\\text{result}_2,\\text{result}_3\\big]$。", "solution": "所提出的问题是计算金融领域一个明确定义的任务。它要求将单因子 Vasicek 期限结构模型校准到经验观测数据。此校准问题被表述为一个数值优化问题，具体而言，是最小化模型隐含的概率分布与给定的经验分布之间的 Kullback-Leibler (KL) 散度。这是一种严谨的标准方法。我们将采用一种规范的解法。\n\n问题的核心是找到参数矢量 $\\mathbf{x} = (\\kappa, \\theta, \\sigma, r_0)$，以最小化目标函数 $D_{\\mathrm{KL}}(p \\,\\|\\, q(\\mathbf{x}))$。矢量 $\\mathbf{x}$ 包含 Vasicek 模型的参数：$\\kappa$（均值回归速度）、$\\theta$（长期均值）、$\\sigma$（波动率）和初始短期利率 $r_0$。优化是在这些参数的指定有界域上进行的。\n\n目标函数，即 KL 散度，由下式给出：\n$$\nD_{\\mathrm{KL}}\\big(p \\,\\|\\, q(\\mathbf{x})\\big) = \\sum_{i=1}^n p_i \\log\\left(\\frac{p_i}{q_i(\\mathbf{x})}\\right)\n$$\n其中 $\\{p_i\\}_{i=1}^n$ 是固定的经验分布，而 $\\{q_i(\\mathbf{x})\\}_{i=1}^n$ 是依赖于参数 $\\mathbf{x}$ 的模型隐含分布。模型隐含概率由一组到期日 $\\{T_i\\}_{i=1}^n$ 对应的零息债券价格 $P(0, T_i)$ 导出：\n$$\nq_i(\\mathbf{x}) = \\frac{P(0,T_i; \\mathbf{x})}{\\sum_{j=1}^n P(0,T_j; \\mathbf{x})}\n$$\n在 Vasicek 模型中，根据风险中性测度，债券价格是短期利率的指数仿射函数：\n$$\nP(0,T) = \\exp\\big(A(T) - B(T)r_0\\big)\n$$\n函数 $A(T)$ 和 $B(T)$ 本身也是模型参数的函数。具体来说，对于到期日 $T > 0$：\n$$\nB(T; \\kappa) = \\frac{1 - e^{-\\kappa T}}{\\kappa}\n$$\n$$\nA(T; \\kappa, \\theta, \\sigma) = \\left(\\theta - \\frac{\\sigma^2}{2\\kappa^2}\\right)\\big(B(T) - T\\big) - \\frac{\\sigma^2}{4\\kappa}\\,B(T)^2\n$$\n对于边界情况 $T=0$，使用约定 $A(0)=0$ 和 $B(0)=0$，这正确地导出了 $P(0,0)=1$。\n\n问题在于求解以下约束非线性优化问题：\n$$\n\\min_{\\mathbf{x} \\in \\mathcal{D}} D_{\\mathrm{KL}}(p \\,\\|\\, q(\\mathbf{x}))\n$$\n搜索域 $\\mathcal{D}$ 是由以下条件定义的超矩形：\n$\\kappa \\in [10^{-4}, 5.0]$, $\\theta \\in [-0.05, 0.15]$, $\\sigma \\in [10^{-5}, 0.2]$, and $r_0 \\in [-0.02, 0.2]$。\n\n目标函数是非线性的，其对参数的依赖关系复杂，可能导致一个具有多个局部最小值的函数形态。一个简单的基于梯度的局部优化器可能无法找到全局最小值。因此，全局优化算法是合适的选择。我们将使用 `scipy.optimize` 库提供的 `differential_evolution` 算法。这是一种基于群体的随机优化方法，对于在箱型约束域上寻找函数的全局最小值具有鲁棒性。\n\n为了数值稳定性，尤其是在处理指数函数时，使用对数是明智的做法。目标函数可以重写为：\n$$\nD_{\\mathrm{KL}} = \\sum_{i=1}^n p_i (\\log p_i - \\log q_i)\n$$\n其中 $\\log q_i$ 项计算为 $\\log q_i = \\log P(0,T_i) - \\log(\\sum_j P(0,T_j))$。如果直接计算，分母中的指数和在数值上是不稳定的。我们可以使用 log-sum-exp 稳定技巧：\n$$\n\\log\\left(\\sum_{j=1}^n P(0,T_j)\\right) = \\log\\left(\\sum_{j=1}^n \\exp\\big(\\log P(0,T_j)\\big)\\right)\n$$\n其中 $\\log P(0,T_j) = A(T_j) - B(T_j)r_0$。`scipy.special.logsumexp` 函数能够稳健地实现这一计算。\n\n实现将包含一个主函数，该函数将目标 $D_{\\mathrm{KL}}$ 定义为参数矢量 $\\mathbf{x}$ 的函数。此函数将与指定的参数边界一同传递给 `differential_evolution` 求解器。对三个测试案例中的每一个都重复此过程，并记录最小化的 KL 散度值。为了确保优化结果的可复现性，我们为随机数生成器使用了一个固定的种子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.special import logsumexp\n\ndef vasicek_bond_price_components(params, T_values):\n    \"\"\"\n    Calculates the A(T) and B(T) components for the Vasicek model bond price.\n    \n    Args:\n        params (list or np.ndarray): A list of parameters [kappa, theta, sigma, r0].\n            r0 is not used in this function but is part of the standard parameter vector.\n        T_values (np.ndarray): An array of maturities T.\n    \n    Returns:\n        (np.ndarray, np.ndarray): A tuple containing the A(T) and B(T) arrays.\n    \"\"\"\n    kappa, theta, sigma, _ = params\n    T_values = np.asarray(T_values, dtype=float)\n    \n    A_T = np.zeros_like(T_values)\n    B_T = np.zeros_like(T_values)\n    \n    # Isolate non-zero maturities to avoid division by zero in formulas.\n    # The convention for T=0 is A(0)=0, B(0)=0, which is handled by the initialization.\n    non_zero_T_mask = T_values > 1e-9\n\n    if np.any(non_zero_T_mask):\n        T = T_values[non_zero_T_mask]\n        \n        # The parameter domain for kappa is [1e-4, 5.0], so kappa is never zero.\n        # Direct computation of B(T) is safe.\n        exp_minus_kappa_T = np.exp(-kappa * T)\n        B_T_vals = (1.0 - exp_minus_kappa_T) / kappa\n        \n        # Calculate A(T) using the formula from the problem statement.\n        term_B_minus_T = B_T_vals - T\n        kappa_sq = kappa * kappa\n        sigma_sq = sigma * sigma\n        \n        A_T_vals = (theta - sigma_sq / (2.0 * kappa_sq)) * term_B_minus_T - \\\n                   (sigma_sq / (4.0 * kappa)) * (B_T_vals**2)\n        \n        # Assign calculated values to the corresponding positions in the arrays.\n        B_T[non_zero_T_mask] = B_T_vals\n        A_T[non_zero_T_mask] = A_T_vals\n        \n    return A_T, B_T\n\ndef kl_divergence_objective(params, T_values, p_dist):\n    \"\"\"\n    Objective function calculating the KL divergence for Vasicek model calibration.\n    \n    Args:\n        params (list or np.ndarray): A list of parameters [kappa, theta, sigma, r0].\n        T_values (np.ndarray): An array of maturities T.\n        p_dist (np.ndarray): The empirical probability distribution.\n        \n    Returns:\n        float: The KL divergence D_KL(p || q).\n    \"\"\"\n    kappa, theta, sigma, r0 = params\n    \n    # Calculate A(T) and B(T)\n    A_T, B_T = vasicek_bond_price_components(params, T_values)\n    \n    # Calculate the logarithm of bond prices\n    log_P_0_T = A_T - B_T * r0\n\n    # Handle potential numerical overflows from intermediate calculations\n    if np.any(np.isnan(log_P_0_T)) or np.any(np.isinf(log_P_0_T)):\n        return np.inf\n\n    # Calculate log of model-implied probabilities q_i using log-sum-exp for stability\n    log_S = logsumexp(log_P_0_T)\n    log_q_dist = log_P_0_T - log_S\n    \n    # Calculate KL divergence: D_KL(p || q) = sum(p_i * (log(p_i) - log(q_i)))\n    # The problem specifies p_i > 0, so log(p_dist) is safe.\n    kl_div = np.sum(p_dist * (np.log(p_dist) - log_q_dist))\n    \n    return kl_div\n\ndef solve():\n    \"\"\"\n    Main function to solve the calibration problem for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([0.25, 0.5, 1.0, 2.0, 5.0, 10.0]),\n            np.array([0.27, 0.25, 0.20, 0.15, 0.08, 0.05])\n        ),\n        (\n            np.array([0.0, 0.25, 0.5, 1.0, 4.0, 7.0]),\n            np.array([0.35, 0.25, 0.18, 0.12, 0.06, 0.04])\n        ),\n        (\n            np.array([0.5, 1.0, 1.5, 2.0, 5.0, 15.0, 30.0]),\n            np.array([0.26, 0.21, 0.17, 0.14, 0.10, 0.07, 0.05])\n        )\n    ]\n\n    # Define the parameter search domain (bounds for the optimizer)\n    bounds = [\n        (1e-4, 5.0),    # kappa\n        (-0.05, 0.15),  # theta\n        (1e-5, 0.2),    # sigma\n        (-0.02, 0.2)    # r0\n    ]\n\n    results = []\n    for maturities, emp_dist in test_cases:\n        # Define the objective function for the current case\n        objective_func = lambda p: kl_divergence_objective(p, maturities, emp_dist)\n        \n        # Perform global optimization using differential evolution to find the minimum KL divergence\n        # A seed is used for reproducibility of the stochastic optimization process.\n        result = differential_evolution(objective_func, bounds, seed=42)\n        \n        # The minimized value of the objective function\n        min_kl_divergence = result.fun\n        results.append(min_kl_divergence)\n\n    # Format the results to 10 decimal places as required.\n    results_str = [f\"{r:.10f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"}]}