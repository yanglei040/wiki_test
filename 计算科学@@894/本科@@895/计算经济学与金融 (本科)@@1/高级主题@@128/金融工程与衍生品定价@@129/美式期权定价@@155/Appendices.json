{"hands_on_practices": [{"introduction": "标准的二项树模型通常假设模型参数是恒定的，这在现实世界中往往是一种过度简化。本练习将挑战你调整该模型，以对一种价格受季节性和存储成本影响的商品进行定价。你将学习如何通过将这些因素建模为随时间变化的有效收益率 $q(t)$ 来将其纳入模型，这使得风险中性概率在每个时间步上都具有特殊性。[@problem_id:2420641]", "id": "2420641", "problem": "要求您以编程方式计算一份美式期权的价值，该期权以某种商品为标的，其现货价格过程受季节性和存储成本的影响。在风险中性测度下进行计算。该商品现货价格过程 $\\{S_t\\}_{t \\in [0,T]}$ 具有瞬时动态\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t,\n$$\n其中 $r$ 是连续复利无风险利率，$\\sigma$ 是波动率，而 $q(t)$ 是一个随时间变化的有效收益率。该有效收益率结合了一个确定性的季节性分量和一个被视为负连续股息率的存储成本：\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s.\n$$\n这里，$q_0$ 是基准便利收益率水平，$A$ 是季节性振幅，$\\phi$ 是相位（以弧度为单位），$s$ 是存储成本率。所有利率均以小数形式表示（年化），时间 $t$ 以年为单位，到期时间 $T$ 也以年为单位。\n\n对于数值估值，使用一个离散时间近似，即一个 $N$ 个等长步长的 Cox-Ross-Rubinstein 可重组二叉树模型，步长为 $\\Delta t = T/N$。上涨和下跌乘数分别为\n$$\nu = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = \\frac{1}{u},\n$$\n在对应于时间 $t_i = i \\Delta t$ 的第 $i \\in \\{0,1,\\dots,N-1\\}$ 步，单步风险中性概率为\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}.\n$$\n单步贴现因子为 $D = e^{-r \\Delta t}$。在时间 $0$ 的美式期权价值是在上述模型下，所有取值于网格 $\\{0, \\Delta t, 2 \\Delta t, \\dots, T\\}$ 上的停止时间 $\\tau$ 的贴现期望收益的上确界。对于看涨期权，收益函数为 $\\Pi(S) = \\max(S - K, 0)$；对于看跌期权，收益函数为 $\\Pi(S) = \\max(K - S, 0)$。\n\n请实现一个程序，为以下每个测试用例计算在时间 $0$ 的美式期权价值。所有输入均使用上述单位，其中 $\\phi$ 以弧度给出。每个用例的输出必须是单个实数（浮点数）。每个结果必须四舍五入到六位小数。\n\n测试套件：\n- 用例 1（因存储成本导致有效收益率在负值附近振荡，基准一年期）：\n  - $S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, 期权类型：看跌期权。\n  - $q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$。\n- 用例 2（极短到期日边界，单步树）：\n  - $S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, 期权类型：看跌期权。\n  - $q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$。\n- 用例 3（因存储成本和零无风险利率导致有效收益率为负的美式看涨期权）：\n  - $S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, 期权类型：看涨期权。\n  - $q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$。\n- 用例 4（因强便利收益率导致有效收益率为正，一年期）：\n  - $S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, 期权类型：看跌期权。\n  - $q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个价格都四舍五入到六位小数并以十进制数打印（例如，`[12.345678,9.876543,0.123456,4.000000]`）。不应打印任何其他文本。", "solution": "在尝试提供解决方案之前，我们对问题进行了验证。\n\n### 步骤1：提取给定信息\n\n现货价格过程 $\\{S_t\\}_{t \\in [0,T]}$ 服从以下随机微分方程：\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t\n$$\n其中 $r$ 是无风险利率，$\\sigma$ 是波动率，$q(t)$ 是随时间变化的有效收益率。\n\n有效收益率定义为：\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s\n$$\n其中 $q_0$ 是基准便利收益率，$A$ 是季节性振幅，$\\phi$ 是相位，$s$ 是存储成本率。\n\n数值方法是 Cox-Ross-Rubinstein (CRR) 二叉树模型，在周期 $T$ 内有 $N$ 步。\n- 时间步长：$\\Delta t = T/N$。\n- 上涨/下跌乘数：$u = e^{\\sigma \\sqrt{\\Delta t}}$，$d = 1/u$。\n- 在时间 $t_i = i \\Delta t$ 的单步风险中性概率：\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n$$\n- 单步贴现因子：$D = e^{-r \\Delta t}$。\n- 收益函数：看涨期权为 $\\Pi(S) = \\max(S - K, 0)$，看跌期权为 $\\Pi(S) = \\max(K - S, 0)$。\n\n测试用例：\n1.  **用例 1**：$S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, `期权类型: 看跌期权`。$q(t)$ 的参数：$q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$。\n2.  **用例 2**：$S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, `期权类型: 看跌期权`。$q(t)$ 的参数：$q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$。\n3.  **用例 3**：$S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, `期权类型: 看涨期权`。$q(t)$ 的参数：$q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$。\n4.  **用例 4**：$S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, `期权类型: 看跌期权`。$q(t)$ 的参数：$q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$。\n\n### 步骤2：使用提取的给定信息进行验证\n\n根据验证标准对问题进行评估。\n- **科学性**：所提供的模型是几何布朗运动的一个变体，具有随时间变化的漂移项，这是量化金融中为商品价格建模的标准框架。包含季节性和存储成本的有效收益率 $q(t)$ 的形式也是一种常规方法。数值估值方法，即二叉树，是计算金融中期权定价的基石。所有方程和概念都基于成熟的金融工程原理。\n- **适定性**：问题是适定的。每个测试用例的输入是完整且充分的，可以使用指定的算法计算出唯一的数值结果。带有随时间变化的股息率的 CRR 模型已知可以提供收敛于连续时间解的近似值。参数在合理范围内，确保风险中性概率 $p_i$ 满足无套利条件 $0 < p_i < 1$。\n- **客观性**：问题以精确、客观的数学和金融语言陈述。它提供了具体的测试用例，并要求数值输出，没有主观解释的余地。\n\n该问题未表现出任何缺陷，如科学不健全、不完整、矛盾或模糊性。这是一个计算经济学和金融学中标准且定义明确的问题。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。我们将提供解决方案。\n\n具有指定动态的商品美式期权的估值使用二叉格进行。基本原理是风险中性估值结合动态规划，以考虑提前行权的特性。美式期权在任何时间点的价格是其内在价值（来自立即行权）和其存续价值（来自持有期权）中的最大值。\n\n该算法通过在可重组二叉树上进行向后归纳来执行。\n\n1.  **模型离散化**：到期时间 $T$ 被划分为 $N$ 个长度为 $\\Delta t = T/N$ 的相等区间。商品价格 $S$ 的状态空间被离散化为一个二叉格。在时间 $t_i = i\\Delta t$，经历了 $j$ 次上涨和 $i-j$ 次下跌的节点 $(i, j)$ 上的价格由 $S_{i,j} = S_0 u^j d^{i-j}$ 给出。上涨和下跌乘数 $u$ 和 $d$ 由波动率 $\\sigma$ 和时间步长 $\\Delta t$ 根据 CRR 模型确定：\n    $$\n    u = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = e^{-\\sigma \\sqrt{\\Delta t}} = \\frac{1}{u}\n    $$\n    单步贴现因子是恒定的：$D = e^{-r \\Delta t}$。\n\n2.  **随时间变化的风险中性概率**：由于有效收益率 $q(t_i)$ 随时间变化，上涨的风险中性概率不是恒定的，而是取决于时间步 $i$。对于每个时间步 $t_i = i \\Delta t$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，有效收益率为：\n    $$\n    q(t_i) = q_0 + A \\cos(2\\pi t_i + \\phi) - s\n    $$\n    这产生了一个依赖于步长的风险中性概率 $p_i$，用于从 $t_i$ 到 $t_{i+1}$ 的转换：\n    $$\n    p_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n    $$\n\n3.  **向后归纳算法**：\n    - **到期日初始化（时间 $T$）**：在最后一个时间步 $N$，每个 $N+1$ 个节点上的期权价值就是其内在价值，由收益函数给出。令 $\\omega = 1$ 表示看涨期权，$\\omega = -1$ 表示看跌期权。节点 $(N,j)$ 上的价值 $V_{N,j}$ 是：\n      $$\n      V_{N,j} = \\max(\\omega \\cdot (S_{N,j} - K), 0) \\quad \\text{其中 } j = 0, 1, \\dots, N\n      $$\n      这些值存储在一个大小为 $N+1$ 的一维数组中。\n\n    - **迭代**：算法从时间步 $i = N-1$ 向后迭代到 $0$。在每一步 $i$，它计算所有节点 $j \\in \\{0, 1, \\dots, i\\}$ 的期权价值 $V_{i,j}$。\n      - 对于每个节点 $(i,j)$，存续价值 $C_{i,j}$ 是下一时间步期权的贴现期望值，使用风险中性概率 $p_i$ 计算：\n        $$\n        C_{i,j} = D \\cdot [p_i V_{i+1, j+1} + (1-p_i) V_{i+1, j}]\n        $$\n      - 内在价值 $I_{i,j}$ 是在节点 $(i,j)$ 行权时的价值：\n        $$\n        I_{i,j} = \\max(\\omega \\cdot (S_{i,j} - K), 0)\n        $$\n      - 此节点的美式期权价值是这两个价值中的最大值，反映了最优决策：\n        $$\n        V_{i,j} = \\max(I_{i,j}, C_{i,j})\n        $$\n      在实现中，一个表示第 $i+1$ 步期权价值的数组可以被就地更新，以存储第 $i$ 步的价值。\n\n    - **最终价值**：该过程在步骤 $i=0$ 处终止。单个值 $V_{0,0}$ 是在时间 $t=0$ 的美式期权价格。\n\n为每个测试用例实施此过程，以计算所需的期权价格。", "answer": "```python\nimport numpy as np\n\ndef calculate_american_option(S0, K, r, sigma, T, N, option_type, q_params):\n    \"\"\"\n    Computes the value of an American option on a commodity with seasonality.\n\n    Args:\n        S0 (float): Initial spot price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility.\n        T (float): Time to maturity in years.\n        N (int): Number of steps in the binomial tree.\n        option_type (str): 'call' or 'put'.\n        q_params (dict): Parameters for the effective yield q(t).\n                         Keys: 'q0', 'A', 'phi', 's'.\n\n    Returns:\n        float: The price of the American option at time 0.\n    \"\"\"\n    # Unpack parameters for q(t)\n    q0 = q_params['q0']\n    A = q_params['A']\n    phi = q_params['phi']\n    s = q_params['s']\n\n    # Step 1: Discretization and constant parameters\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n    discount_factor = np.exp(-r * dt)\n\n    # Step 2: Initialize option values at maturity (time T)\n    # Omega = 1 for call, -1 for put\n    omega = 1.0 if option_type == 'call' else -1.0\n    \n    # Create a vector for option values. This will be updated at each step.\n    # It stores values at step i+1, and is used to compute values at step i.\n    V = np.zeros(N + 1)\n    \n    # Asset prices at maturity\n    S_T = np.array([(S0 * u**j * d**(N - j)) for j in range(N + 1)])\n    \n    # Option payoff at maturity\n    V[:] = np.maximum(omega * (S_T - K), 0)\n\n    # Step 3: Backward induction\n    for i in range(N - 1, -1, -1):\n        # Calculate time-dependent risk-neutral probability for this step\n        ti = i * dt\n        q_ti = q0 + A * np.cos(2 * np.pi * ti + phi) - s\n        \n        # Risk-neutral probability for transition from t_i to t_{i+1}\n        p_i = (np.exp((r - q_ti) * dt) - d) / (u - d)\n        \n        # Stability check, should hold for reasonable parameters\n        if not (0 < p_i < 1):\n             # This indicates an arbitrage opportunity or unstable parameters.\n             # The problem parameters are well-behaved, so this is a safeguard.\n             # For some extreme parameters, one might need to adjust u,d,p.\n             # but here it is not necessary.\n             pass\n\n        # Calculate option values at time step i\n        for j in range(i + 1):\n            # Continuation value (if not exercised)\n            continuation_value = discount_factor * (p_i * V[j+1] + (1 - p_i) * V[j])\n            \n            # Stock price at this node (i, j)\n            S_ij = S0 * u**j * d**(i - j)\n            \n            # Intrinsic value (if exercised now)\n            intrinsic_value = np.maximum(omega * (S_ij - K), 0)\n            \n            # American option value is the max of exercising or holding\n            V[j] = np.maximum(intrinsic_value, continuation_value)\n            \n    # The final result is the option value at the root of the tree (t=0)\n    return round(V[0], 6)\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'S0': 100.0, 'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.03, 'phi': 0.0, 's': 0.02}},\n        # Case 2\n        {'S0': 80.0, 'K': 100.0, 'r': 0.01, 'sigma': 0.25, 'T': 1/365, 'N': 1, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.02, 'phi': np.pi/2, 's': 0.01}},\n        # Case 3\n        {'S0': 50.0, 'K': 40.0, 'r': 0.0, 'sigma': 0.3, 'T': 0.5, 'N': 300, 'option_type': 'call',\n         'q_params': {'q0': 0.0, 'A': 0.0, 'phi': 0.0, 's': 0.05}},\n        # Case 4\n        {'S0': 100.0, 'K': 90.0, 'r': 0.02, 'sigma': 0.25, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.07, 'A': 0.02, 'phi': np.pi, 's': 0.02}},\n    ]\n\n    results = []\n    for case in test_cases:\n        price = calculate_american_option(\n            S0=case['S0'],\n            K=case['K'],\n            r=case['r'],\n            sigma=case['sigma'],\n            T=case['T'],\n            N=case['N'],\n            option_type=case['option_type'],\n            q_params=case['q_params']\n        )\n        results.append(price)\n    \n    # Format the final output according to specification\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```"}, {"introduction": "恒定波动率的假设是简单模型中的一个主要简化。本练习引入了局部波动率 $\\sigma(S)$ 的概念，其中波动率本身取决于资产价格，这是在真实市场中观察到的一个特征（即“波动率微笑”）。实现这一模型需要构建一个非重组二项树，这让你能深入理解模型准确性与计算复杂性之间的权衡。[@problem_id:2420693]", "id": "2420693", "problem": "要求您设计并实现一个离散时间二项式模型，用于在瞬时（局部）波动率是股价的函数时，为美式看跌期权定价。该模型必须是自包含的，并基于风险中性测度下的无套利定价第一性原理。具体来说，考虑一个风险资产，其当前价格为 $S_0$，行权价为 $K$，连续复利无风险利率为 $r$（以小数形式表示），到期时间为 $T$（以年为单位），以及整数个时间步数 $N$。时间步长为 $\\Delta t = T / N$。无股息。该期权是美式看跌期权，意味着它可以在到期前（含到期日）的任何时间步被行权。\n\n基本原理和定义：二项式模型假设，在长度为 $\\Delta t$ 的单个时间步内，从任何股价为 $S$ 的节点出发，下一个股价将取两个值之一：一个“上涨”价格 $S \\cdot u(S)$ 或一个“下跌”价格 $S \\cdot d(S)$，其中 $u(S) > 1$ 且 $d(S) = 1/u(S) \\in (0,1)$。无套利风险中性定价原理要求，在风险中性测度下，股票在单个时间步内的期望回报等于 $e^{r \\Delta t}$。因此，在价格为 $S$ 的节点，上涨的风险中性概率是\n$$\np(S) = \\frac{e^{r \\Delta t} - d(S)}{u(S) - d(S)},\n$$\n而下跌的概率是 $1 - p(S)$。在价格为 $S$ 的节点进行美式提前行权，将产生立即收益 $\\max\\{K - S, 0\\}$；否则，其持有价值是下一步期权价值的贴现期望值。\n\n局部波动率设定：在股价为 $S$ 的节点处，上涨和下跌因子由局部波动率函数 $\\sigma(S)$ 通过以下公式确定：\n$$\nu(S) = e^{\\sigma(S)\\sqrt{\\Delta t}}, \\quad d(S) = \\frac{1}{u(S)}.\n$$\n为确保正值性以及对 $S$ 的简单、明确定义的依赖关系，请使用：\n$$\n\\sigma(S) = \\max\\left(\\sigma_{\\min}, \\ \\sigma_0 \\cdot \\left(1 + \\beta \\cdot \\left(\\frac{S}{K} - 1\\right)\\right)\\right),\n$$\n其中 $\\sigma_{\\min} > 0$ 是波动率下限，$\\sigma_0 > 0$ 是基准波动率水平，$\\beta$ 是一个无量纲斜率参数。由于 $u(S)$ 和 $d(S)$ 依赖于 $S$，生成的二项式树通常不重组。因此，您必须显式地构建完整的非重组二叉树。\n\n算法要求：\n1. 使用局部波动率规则构建具有 $N$ 层的非重组股价树，从 $S_0$ 开始，将每个节点根据其特定于节点的因子 $u(S)$ 和 $d(S)$ 扩展为两个子节点。记录每个节点对应的风险中性概率 $p(S)$。\n2. 在到期日（第 $N$ 层），将每个叶节点的期权价值初始化为内在价值 $\\max\\{K - S, 0\\}$。\n3. 从第 $N-1$ 层到第 $0$ 层执行向后归纳法：在股价为 $S$ 的节点，通过在概率 $p(S)$ 和 $1-p(S)$ 下贴现下一步的期权期望价值来计算持有价值，并将其与立即行权收益 $\\max\\{K - S, 0\\}$ 进行比较，取较大者。也就是说，在一个价格为 $S$ 的通用节点上，\n$$\nV(S) = \\max\\left(\\max\\{K - S, 0\\}, \\ e^{-r\\Delta t} \\cdot \\left(p(S) \\cdot V\\left(S \\cdot u(S)\\right) + (1 - p(S)) \\cdot V\\left(S \\cdot d(S)\\right)\\right)\\right).\n$$\n4. 将根节点价值 $V(S_0)$ 作为该参数集下的美式看跌期权价格进行报告。\n\n数值真实性与约束：您必须假设 $N$ 足够小，以确保显式构建非重组树在计算上是可行的。所有利率和波动率均以小数形式表示。时间以年为单位。不涉及角度。除了已指定的金融惯例，没有其他物理单位。下面的测试套件选择了科学上合理的参数，这些参数能保证 $0 < p(S) < 1$ 并确保数值稳定性。如果数值舍入误差导致概率略微超出 $[0,1]$ 区间，应将其局部地截断到 $[0,1]$ 区间内，以避免出现虚假的负概率。\n\n测试套件：您的程序必须为以下每个参数集对美式看跌期权进行定价。在每个元组中，参数按 $(S_0, K, r, T, N, \\sigma_0, \\beta, \\sigma_{\\min})$ 的顺序列出。\n- 情况 1：$(\\$100.0, \\$100.0, 0.05, 1.0, 10, 0.20, 0.40, 0.05)$。\n- 情况 2：$(\\$50.0, \\$100.0, 0.02, 1.0, 12, 0.25, -0.60, 0.05)$。\n- 情况 3：$(\\$120.0, \\$100.0, 0.00, 0.25, 8, 0.15, 0.00, 0.05)$。\n- 情况 4：$(\\$100.0, \\$100.0, 0.10, 0.5, 1, 0.30, 1.00, 0.05)$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是为情况 $i$ 计算的美式看跌期权价格。将每个 $x_i$ 四舍五入到恰好 $6$ 位小数。输出行中不得有多余的空格或其他文本。", "solution": "问题陈述已经过严格验证，并被确定为有效。它构成了计算金融领域一个适定问题，其基础是成熟的无套利衍生品定价第一性原理。所有定义、参数和算法要求都具有足够的清晰度和精确性，足以构建一个唯一且有意义的解决方案。\n\n该问题要求在局部波动率框架下对美式看跌期权进行定价。这是通过使用离散时间的非重组二项式树模型来完成的。解决方案的核心是构建此树，然后应用向后归纳法原理来找到期权的价值。\n\n该模型定义在 $N$ 个离散时间步上，每个步长为 $\\Delta t = T/N$。在树中任何股价为 $S$ 的给定节点，资产价格在下一个时间步可以上涨到 $S \\cdot u(S)$ 或下跌到 $S \\cdot d(S)$。移动因子 $u(S)$ 和 $d(S)$ 是通过局部波动率函数 $\\sigma(S)$ 实现的股价 $S$ 的函数：\n$$\nu(S) = e^{\\sigma(S)\\sqrt{\\Delta t}}, \\quad d(S) = \\frac{1}{u(S)} = e^{-\\sigma(S)\\sqrt{\\Delta t}}\n$$\n局部波动率 $\\sigma(S)$ 被指定为股票相对于行权价 $K$ 的价内/价外程度（moneyness）的函数：\n$$\n\\sigma(S) = \\max\\left(\\sigma_{\\min}, \\ \\sigma_0 \\cdot \\left(1 + \\beta \\cdot \\left(\\frac{S}{K} - 1\\right)\\right)\\right)\n$$\n这种状态依赖的波动率意味着二项式树不重组，因此有必要在每个时间层级 $i$ 显式构建并存储所有 $2^i$ 个节点。\n\n定价是在风险中性测度下进行的。价格上涨的风险中性概率 $p(S)$ 源于无套利条件，该条件规定资产的期望回报必须等于无风险回报 $e^{r\\Delta t}$。由此得出：\n$$\np(S) = \\frac{e^{r \\Delta t} - d(S)}{u(S) - d(S)}\n$$\n相应地，下跌的概率是 $1 - p(S)$。问题规范保证所选参数能使得 $0 < p(S) < 1$，但也建议将计算出的概率截断到区间 $[0, 1]$ 以确保数值稳定性。\n\n估值算法通过向后归纳法进行：\n1.  **正向树构建**：首先，构建一个完整的股价二叉树。从第 $i=0$ 层的初始价格 $S_0$ 开始，我们根据第 $i$ 层的 $2^i$ 个价格，迭代计算出第 $i+1$ 层的 $2^{i+1}$ 个后继价格。这个过程一直持续到第 $N$ 层，最终得到 $2^N$ 个终端股价。\n\n2.  **到期日估值**：在最后的时间步，即第 $N$ 层，$2^N$ 个节点中每个节点的期权价值由其行权时的内在价值决定：\n    $$\n    V_N(S) = \\max\\{K - S, 0\\}\n    $$\n\n3.  **向后归纳步骤**：然后算法从第 $i=N-1$ 层向后迭代到第 $i=0$ 层。在每个价格为 $S$ 的节点，期权价值 $V_i(S)$ 是立即行权价值和持有价值中的较大者。\n    - 立即行权价值是 $\\max\\{K - S, 0\\}$。\n    - 持有价值是期权在下一时间步的贴现期望价值，基于风险中性测度：\n      $$\n      \\text{Continuation Value} = e^{-r\\Delta t} \\left[ p(S) \\cdot V_{i+1}(S \\cdot u(S)) + (1 - p(S)) \\cdot V_{i+1}(S \\cdot d(S)) \\right]\n      $$\n      此处，$V_{i+1}(\\cdot)$ 是来自下一层的已知期权价值，这些价值已经计算得出。\n    - 因此，期权价值是：\n      $$\n      V_i(S) = \\max\\left(\\max\\{K - S, 0\\}, \\ e^{-r\\Delta t} \\left[ p(S) \\cdot V_{i+1,u} + (1 - p(S)) \\cdot V_{i+1,d} \\right] \\right)\n      $$\n\n4.  **期权价格**：向后迭代在第 $i=0$ 层结束，该层只包含价格为 $S_0$ 的根节点。为该节点计算出的价值 $V_0(S_0)$ 就是美式看跌期权的价格。实现将逐层执行此过程，以计算给定测试用例的价格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Parameters are ordered as: (S0, K, r, T, N, sigma0, beta, sigma_min)\n    test_cases = [\n        (100.0, 100.0, 0.05, 1.0, 10, 0.20, 0.40, 0.05),\n        (50.0, 100.0, 0.02, 1.0, 12, 0.25, -0.60, 0.05),\n        (120.0, 100.0, 0.00, 0.25, 8, 0.15, 0.00, 0.05),\n        (100.0, 100.0, 0.10, 0.5, 1, 0.30, 1.00, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = price_american_put_non_recombining(*case)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef price_american_put_non_recombining(S0, K, r, T, N, sigma0, beta, sigma_min):\n    \"\"\"\n    Prices an American put option using a non-recombining binomial tree\n    with local volatility.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (decimal).\n        T (float): Time to maturity (years).\n        N (int): Number of time steps.\n        sigma0 (float): Baseline volatility.\n        beta (float): Volatility slope parameter.\n        sigma_min (float): Volatility floor.\n\n    Returns:\n        float: The calculated price of the American put option.\n    \"\"\"\n    dt = T / N\n    discount_factor = np.exp(-r * dt)\n    exp_rdt = np.exp(r * dt)\n    sqrt_dt = np.sqrt(dt)\n\n    def get_sigma(S):\n        \"\"\"Calculates local volatility for a given stock price S.\"\"\"\n        return np.maximum(sigma_min, sigma0 * (1.0 + beta * (S / K - 1.0)))\n\n    # Step 1: Forward Pass - Build the stock price tree\n    # stock_tree[i] stores the list of stock prices at level i.\n    stock_tree = [[S0]]\n    for i in range(N):\n        prices_at_next_level = []\n        for S in stock_tree[i]:\n            sigma_S = get_sigma(S)\n            u = np.exp(sigma_S * sqrt_dt)\n            prices_at_next_level.append(S * u)\n            prices_at_next_level.append(S / u) # d = 1/u\n        stock_tree.append(prices_at_next_level)\n\n    # Step 2: Backward Pass - Calculate option values\n    # Initialize option values at maturity (level N).\n    option_values = [np.maximum(K - s, 0.0) for s in stock_tree[N]]\n    \n    # Iterate backwards from level N-1 down to 0.\n    for i in range(N - 1, -1, -1):\n        option_values_at_this_level = []\n        for j in range(len(stock_tree[i])):\n            S = stock_tree[i][j]\n            \n            # Option values from the successor nodes.\n            V_u = option_values[2 * j]\n            V_d = option_values[2 * j + 1]\n            \n            # Calculate node-specific parameters.\n            sigma_S = get_sigma(S)\n            u = np.exp(sigma_S * sqrt_dt)\n            d = 1.0 / u\n            \n            # Risk-neutral probability. Since sigma_S is guaranteed to be positive,\n            # u > d, so no division by zero will occur.\n            p = (exp_rdt - d) / (u - d)\n\n            # Clip probability to [0, 1] for numerical stability as per instructions.\n            p = np.maximum(0.0, np.minimum(1.0, p))\n\n            # Continuation value (value of holding the option).\n            continuation_value = discount_factor * (p * V_u + (1.0 - p) * V_d)\n            \n            # Exercise value (value of exercising the option now).\n            exercise_value = np.maximum(K - S, 0.0)\n            \n            # Option value is the maximum of holding vs. exercising.\n            node_value = np.maximum(continuation_value, exercise_value)\n            option_values_at_this_level.append(node_value)\n        \n        option_values = option_values_at_this_level\n            \n    # The final price is the single value at the root of the tree (level 0).\n    return option_values[0]\n\nsolve()\n```"}, {"introduction": "除了离散时间格架模型，美式期权定价还可以被表述为一个连续时间的自由边界问题，表示为一个偏微分不等式 (PDI)。这最后一个练习将指导你实现一个显式有限差分法 (FDM) 来数值求解这个 PDI。你还将研究数值稳定性的关键概念，这是任何显式时间步进方案的核心考量因素。[@problem_id:2420683]", "id": "2420683", "problem": "考虑一个不支付股息的标的资产，其现货价格 $S(t)$ 在风险中性测度下遵循几何布朗运动。另考虑一个执行价为 $K$、到期日为 $T$ 的美式看跌期权。从基本无套利原理和自融资复制投资组合的存在性出发，推导刻画美式期权无套利价值函数 $V(S,t)$ 的变分不等式。您的推导必须明确陈述扩散项和漂移项的微分算子、时间演化、提前行权（障碍）约束，以及连接它们的互补松弛结构。然后，将空间变量变换为对数价格 $x = \\ln S$，并用函数 $u(x,t) = V(e^{x},t)$ 表示该不等式，详细说明变换后算子中新的漂移和扩散系数。\n\n接下来，在对数价格变量 $x$ 中设计一种显式有限差分法，通过从到期日向后演化来数值计算美式看跌期权的价格。在空间上使用中心差分，在时间上使用前向欧拉法（在日历时间的意义上是后向的，从 $t=T$ 开始，步进到 $t=0$），并在每个时间步通过投影到障碍上来强制实施提前行权特性。指定并实现在 $x$ 上的狄利克雷边界条件，这些条件对于一个基于不支付股息的标的物的美式看跌期权应具有财务意义。\n\n为进行稳定性分析，请考虑在空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀对数价格网格上的显式格式。陈述一个关于 $\\Delta t$ 的、以 $\\Delta x$ 和波动率 $\\sigma$ 表示的充分的扩散主导稳定性条件，该条件确保使用中心空间差分的显式格式的数值稳定性，并解释为什么违反此条件会导致伪振荡或数值爆炸。\n\n您的程序必须实现上述方法，并运行以下测试套件。对于所有测试，除非另有说明，否则使用相同的空间域和网格：\n- 所有测试的通用设置：\n    - 期权类型：美式看跌期权。\n    - 股息率：$q = 0$。\n    - 价格空间域：$S_{\\min} = 10^{-4}$ 和 $S_{\\max} = 5K$。\n    - 对数价格域：$x_{\\min} = \\ln S_{\\min}$ 和 $x_{\\max} = \\ln S_{\\max}$。\n    - 空间区间数：$M = 400$ (因此 $\\Delta x = (x_{\\max} - x_{\\min})/M$)。\n    - 对于所有 $t \\in [0,T]$ 的边界条件：$V(S_{\\min},t) = K$ 和 $V(S_{\\max},t) = 0$。\n    - 在 $t=T$ 时的到期收益：$V(S,T) = \\max(K - S, 0)$。\n    - 每个时间步的美式约束：$V(S,t) \\leftarrow \\max(V(S,t), \\max(K - S, 0))$。\n    - 对数空间中的显式格式，空间上使用中心差分。\n\n- 用于稳定性分析的时间步长选择规则定义：\n    - 设基于扩散的充分条件为 $\\Delta t \\le \\Delta x^{2}/\\sigma^{2}$。定义界 $B = \\Delta x^{2}/\\sigma^{2}$。\n    - 对于给定的界 $B$ 和到期日 $T$，定义：\n        - 一个稳定的时间步数 $N_{\\text{stable}} = \\left\\lceil \\dfrac{T}{0.9 B} \\right\\rceil$，使得 $\\Delta t_{\\text{stable}} = T/N_{\\text{stable}} \\le 0.9 B$。\n        - 一个不稳定的时间步数 $N_{\\text{unstable}} = \\max\\left(1, \\left\\lfloor \\dfrac{T}{1.1 B} \\right\\rfloor \\right)$，使得 $\\Delta t_{\\text{unstable}} = T/N_{\\text{unstable}} \\ge 1.1 B$。\n\n- 测试用例：\n    1. 正常路径稳定性用例：\n        - 参数：$K = 100$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $S_{0} = 100$。\n        - 使用 $N_{\\text{stable}}$ 并计算在 $S_{0}$ 处的美式看跌期权价格。\n\n    2. 违反稳定性的用例：\n        - 参数与测试1相同。\n        - 使用 $N_{\\text{unstable}}$ 并计算在 $S_{0}$ 处的美式看跌期权价格。\n        - 同时报告是否违反了稳定性界限，即 $\\Delta t_{\\text{unstable}} > B$ 是否成立。\n\n    3. 接近边界的资产价格用例：\n        - 参数：$K = 100$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $S_{0} = 1$。\n        - 使用 $N_{\\text{stable}}$ 并计算在 $S_{0}$ 处的美式看跌期权价格。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。该列表必须按以下顺序排列：\n- 第一项：测试1计算出的价格（浮点数）。\n- 第二项：测试2计算出的价格（浮点数）。\n- 第三项：测试2的违规指示符，如果 $\\Delta t_{\\text{unstable}} > B$ 则为 $1$，否则为 $0$（整数）。\n- 第四项：测试3计算出的价格（浮点数）。\n\n不需要外部输入，也不涉及任何角度或物理单位。将所有数值输出表示为普通十进制数。代码必须是一个完整、可运行的程序，遵循指定的算法，并精确地以所要求的格式输出一行。", "solution": "该问题要求推导美式期权的主导变分不等式，将其变换到对数价格坐标系，设计用于其数值解的显式有限差分格式，并对所提出的格式进行稳定性分析。这些应在实现该方法以在几种情景下为美式看跌期权定价之前完成。\n\n首先，我们推导主导不支付股息股票上的美式期权价值 $V(S,t)$ 的变分不等式，该股票的价格 $S(t)$ 在风险中性测度下遵循几何布朗运动 $dS = rS dt + \\sigma S dW_t$，其中 $r$ 是无风险利率，$\\sigma$ 是波动率。通过做空一份期权并持有 $\\Delta$ 单位的标的资产来构建一个投资组合。该投资组合的价值为 $\\Pi = -V + \\Delta S$。其价值的变化为 $d\\Pi = -dV + \\Delta dS$。根据 Itô 引理，期权价值的变化为 $dV = \\frac{\\partial V}{\\partial t}dt + \\frac{\\partial V}{\\partial S}dS + \\frac{1}{2}\\frac{\\partial^2 V}{\\partial S^2}(dS)^2$。代入 $dS$ 和 $(dS)^2 = \\sigma^2 S^2 dt$，我们得到 $dV = (\\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2})dt + \\sigma S \\frac{\\partial V}{\\partial S}dW_t$。为消除投资组合的风险，我们选择 $\\Delta = \\frac{\\partial V}{\\partial S}$ (delta 对冲)。投资组合价值的变化变为完全确定的：$d\\Pi = -(\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2})dt$。这个无风险投资组合的回报不能提供套利机会。在期权未被行权的区域（持有区域），该投资组合必须恰好赚取无风险利率，即 $d\\Pi = r\\Pi dt = r(-V + S\\frac{\\partial V}{\\partial S})dt$。令两种 $d\\Pi$ 的表达式相等，得到 Black-Scholes 偏微分方程 (PDE)：$\\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - rV = 0$。\n\n对于美式期权，持有者有权在任何时间 $t \\in [0,T]$ 行权。这带来了两个关键条件。首先，期权的价值永远不能低于其立即行权的内在价值 $P(S,t)$，对于看跌期权即为 $\\max(K-S, 0)$。这是障碍约束：$V(S,t) \\ge P(S)$。其次，在持有区域 $V(S,t) > P(S)$，期权被持有，其价值根据 Black-Scholes 偏微分方程演化。然而，由于提前行权的权利，做空美式期权的投资组合的回报率必须不高于无风险利率，这可以防止买方套利。这导致了不等式：$\\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - rV \\le 0$。这个不等式在整个区域 $(S,t) \\in (0, \\infty) \\times [0, T)$ 都成立。\n\n这些条件构成一个互补松弛问题，它是一种变分不等式。该问题可总结如下：\n1. 障碍约束：$V(S,t) \\ge \\max(K-S, 0)$。\n2. PDE 不等式：$\\mathcal{L}V \\equiv \\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + rS\\frac{\\partial V}{\\partial S} - rV \\le 0$。\n3. 互补松弛性：$(V(S,t) - \\max(K-S, 0)) \\times (\\mathcal{L}V) = 0$。\n这意味着在持有区域 $V > P(S)$，必须有 $\\mathcal{L}V=0$。在行权区域 $V=P(S)$，必须有 $\\mathcal{L}V \\le 0$。漂移和扩散的微分算子是 $\\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2}{\\partial S^2} + rS\\frac{\\partial}{\\partial S}$。\n\n接下来，我们通过设置 $x = \\ln S$ (因此 $S = e^x$) 将问题变换到对数价格坐标。令 $u(x,t) = V(e^x, t)$。导数变换如下：\n$\\frac{\\partial V}{\\partial t} = \\frac{\\partial u}{\\partial t}$\n$\\frac{\\partial V}{\\partial S} = \\frac{\\partial u}{\\partial x} \\frac{\\partial x}{\\partial S} = \\frac{1}{S}\\frac{\\partial u}{\\partial x}$\n$\\frac{\\partial^2 V}{\\partial S^2} = \\frac{1}{S^2}(\\frac{\\partial^2 u}{\\partial x^2} - \\frac{\\partial u}{\\partial x})$\n将这些代入不等式 $\\mathcal{L}V \\le 0$ 中得到：\n$\\frac{\\partial u}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\left(\\frac{1}{S^2}(\\frac{\\partial^2 u}{\\partial x^2} - \\frac{\\partial u}{\\partial x})\\right) + rS \\left(\\frac{1}{S}\\frac{\\partial u}{\\partial x}\\right) - ru \\le 0$\n化简并组合各项，得到具有常系数的变换后不等式：\n$\\frac{\\partial u}{\\partial t} + (r - \\frac{1}{2}\\sigma^2) \\frac{\\partial u}{\\partial x} + \\frac{1}{2}\\sigma^2 \\frac{\\partial^2 u}{\\partial x^2} - ru \\le 0$\n新的漂移系数是 $(r - \\frac{1}{2}\\sigma^2)$，新的扩散系数是 $\\frac{1}{2}\\sigma^2$。障碍约束变为 $u(x,t) \\ge \\max(K-e^x, 0)$。\n\n为对此进行数值求解，我们设计一个显式有限差分法。我们用均匀网格对 $(x,t)$ 域进行离散化：$x_j = x_{\\min} + j\\Delta x$ (其中 $j=0, \\dots, M$) 和 $t_n = T - n\\Delta t$ (其中 $n=0, \\dots, N$)。令 $u_j^n \\approx u(x_j, t_n)$。我们从已知的终端条件 $u(x,T) = \\max(K-e^x, 0)$ 开始在时间上向后求解。\n时间导数使用反向时间中的前向差分来近似：$\\frac{\\partial u}{\\partial t} \\approx \\frac{u(t_n) - u(t_{n+1})}{\\Delta t} = \\frac{u_j^n - u_j^{n+1}}{\\Delta t}$。\n空间导数在时间层 $n$ 使用中心差分来近似：\n$\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x}$\n$\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}$\n将这些代入 PDE（暂时忽略不等式）可得到 $u_j^{n+1}$（前一个时间步 $t_{n+1} = t_n - \\Delta t$ 的值）的显式更新规则：\n$u_j^{n+1} = u_j^n - \\Delta t \\left[ (r - \\frac{1}{2}\\sigma^2) \\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x} + \\frac{1}{2}\\sigma^2 \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} - ru_j^n \\right]$\n这可以写成 $u_j^{n+1} = a u_{j-1}^n + b u_j^n + c u_{j+1}^n$，其中：\n$a = \\Delta t \\left( \\frac{\\sigma^2}{2(\\Delta x)^2} - \\frac{r - \\sigma^2/2}{2\\Delta x} \\right)$\n$b = 1 - \\Delta t \\left( \\frac{\\sigma^2}{(\\Delta x)^2} + r \\right)$\n$c = \\Delta t \\left( \\frac{\\sigma^2}{2(\\Delta x)^2} + \\frac{r - \\sigma^2/2}{2\\Delta x} \\right)$\n在计算出这个基于 PDE 的值后，我们必须强制实施美式提前行权约束：\n$u_j^{n+1} \\leftarrow \\max(u_j^{n+1}, \\max(K-e^{x_j}, 0))$\n\n问题指定了狄利克雷边界条件：$V(S_{\\min},t) = K$ 和 $V(S_{\\max},t) = 0$。这些条件具有财务意义。对于看跌期权，当 $S \\to S_{\\max}$ 时，其价值趋近于 $0$。当 $S \\to S_{\\min}$（非常小）时，该看跌期权是深度实值的。对于不付息股票，提前行使美式看跌期权通常是最佳选择。其价值则为 $K-S$。对于一个非常小的 $S_{\\min}$，$K-S_{\\min} \\approx K$。因此，所提供的边界条件是合理的近似。在对数空间中，这些条件是 $u(x_{\\min},t) = K$ 和 $u(x_{\\max},t)=0$。这些条件在每个时间步都应用。\n\n为保证显式格式的稳定性，更新规则中的所有系数 $a,b,c$ 都必须是非负的。最严格的条件通常来自系数 $b$：\n$b = 1 - \\Delta t \\left( \\frac{\\sigma^2}{(\\Delta x)^2} + r \\right) \\ge 0 \\implies \\Delta t \\le \\frac{1}{\\frac{\\sigma^2}{(\\Delta x)^2} + r}$\n一个更简单、此处要求使用的充分条件只考虑扩散项，因为它是最高阶导数，对不稳定性最敏感。这导出了扩散主导的稳定性条件：\n$\\Delta t \\le \\frac{(\\Delta x)^2}{\\sigma^2}$\n违反此条件会使系数 $b$ 为负。当 $b < 0$ 时，一个正值 $u_j^n$ 会对更新后的值 $u_j^{n+1}$ 产生负贡献。这会在解中引起伪的、非物理的振荡，随着计算在时间上向后进行，其幅度会增长。如果条件被严重违反，系数绝对值之和可能超过 1，导致数值爆炸，即解无界增长。", "answer": "```python\nimport numpy as np\nimport math\n\ndef price_american_put_fdm(K, r, sigma, T, S0, M, S_min_val, S_max_factor, N):\n    \"\"\"\n    Computes the American put option price using an explicit finite difference method.\n\n    Args:\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility of the underlying asset.\n        T (float): Time to maturity.\n        S0 (float): Initial stock price.\n        M (int): Number of spatial intervals.\n        S_min_val (float): Minimum value for the price domain S.\n        S_max_factor (float): Factor to determine S_max = S_max_factor * K.\n        N (int): Number of time steps.\n\n    Returns:\n        float: The price of the American put option at S0 and t=0.\n    \"\"\"\n    # 1. Setup grid\n    S_max = S_max_factor * K\n    x_min, x_max = np.log(S_min_val), np.log(S_max)\n    dx = (x_max - x_min) / M\n    dt = T / N\n\n    x_grid = np.linspace(x_min, x_max, M + 1)\n    S_grid = np.exp(x_grid)\n\n    # 2. Initial condition at maturity T (n=0)\n    V = np.maximum(K - S_grid, 0)\n\n    # 3. FDM coefficients\n    nu = r - 0.5 * sigma**2\n    \n    # Coefficients for the explicit scheme u_j^{n+1} = a*u_{j-1}^n + b*u_j^n + c*u_{j+1}^n\n    # Note: we are calculating V at previous time step (n+1 in backward time) from current (n)\n    a = dt * (0.5 * sigma**2 / dx**2 - nu / (2 * dx))\n    b = 1 - dt * (sigma**2 / dx**2 + r)\n    c = dt * (0.5 * sigma**2 / dx**2 + nu / (2 * dx))\n\n    # 4. Time-stepping loop (from T back to 0)\n    for _ in range(N):\n        V_old = V.copy()\n        \n        # Update interior points using the PDE\n        V[1:-1] = a * V_old[:-2] + b * V_old[1:-1] + c * V_old[2:]\n\n        # Apply boundary conditions\n        V[0] = K  # V(S_min, t) = K\n        V[-1] = 0 # V(S_max, t) = 0\n        \n        # Apply American option early exercise constraint\n        payoff = np.maximum(K - S_grid, 0)\n        V = np.maximum(V, payoff)\n\n    # 5. Interpolate to find price at S0\n    price_at_t0 = np.interp(S0, S_grid, V)\n    \n    return price_at_t0\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite.\n    \"\"\"\n    # Common settings from the problem statement\n    M = 400\n    S_min_val = 1e-4\n    S_max_factor = 5.0\n    \n    test_cases = [\n        # Test 1: Happy-path stability case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 100.0, 'case_type': 'stable'},\n        # Test 2: Violated stability case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 100.0, 'case_type': 'unstable'},\n        # Test 3: Near-boundary asset price case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 1.0, 'case_type': 'stable'}\n    ]\n\n    results = []\n\n    # Calculate stability parameters (only depends on K, sigma, M) for the first two tests\n    params1 = test_cases[0]\n    K1, sigma1, T1 = params1['K'], params1['sigma'], params1['T']\n    \n    S_max1 = S_max_factor * K1\n    x_min1 = np.log(S_min_val)\n    x_max1 = np.log(S_max1)\n    dx1 = (x_max1 - x_min1) / M\n    \n    # Diffusion-based stability bound B\n    B = dx1**2 / sigma1**2\n    \n    # Time step counts\n    N_stable = int(math.ceil(T1 / (0.9 * B)))\n    N_unstable = int(max(1, math.floor(T1 / (1.1 * B))))\n\n    # --- Test Case 1 ---\n    price1 = price_american_put_fdm(\n        K=params1['K'], r=params1['r'], sigma=params1['sigma'], T=params1['T'], S0=params1['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_stable\n    )\n    results.append(price1)\n    \n    # --- Test Case 2 ---\n    params2 = test_cases[1]\n    price2 = price_american_put_fdm(\n        K=params2['K'], r=params2['r'], sigma=params2['sigma'], T=params2['T'], S0=params2['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_unstable\n    )\n    results.append(price2)\n    \n    dt_unstable = params2['T'] / N_unstable\n    violation_indicator = 1 if dt_unstable > B else 0\n    results.append(violation_indicator)\n\n    # --- Test Case 3 ---\n    params3 = test_cases[2]\n    # Reuse N_stable as per problem description\n    price3 = price_american_put_fdm(\n        K=params3['K'], r=params3['r'], sigma=params3['sigma'], T=params3['T'], S0=params3['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_stable\n    )\n    results.append(price3)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}