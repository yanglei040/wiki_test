{"hands_on_practices": [{"introduction": "理论知识的真正掌握始于亲手实践。这个练习旨在通过从第一性原理出发，编写代码来计算债券的基本指标，从而巩固您对债券定价和久期概念的理解。您将直接应用贴现现金流模型来计算债券价格 $P$、麦考利久期 $D_{\\mathrm{Mac}}$ 和修正久期 $D_{\\mathrm{Mod}}$，这对于任何希望量化和管理利率风险的金融从业者来说都是一项基本功。通过这个练习[@problem_id:2377212]，您将把抽象的公式转化为可执行的算法，为更复杂的金融建模打下坚实的基础。", "id": "2377212", "problem": "您的任务是实现一个程序，根据第一性原理计算固定利率、离散复利付息债券的价格、Macaulay 久期和修正久期。请使用纯粹的现值方法和以下定义。\n\n一只固定利率债券具有面值 $F$、年票息率 $c$（以小数而非百分比表示）、到期收益率 $y$（以小数而非百分比表示）、每年付息次数 $m$（一个整数）和到期年限 $n$（一个整数）。票息支付按相等的时间间隔发生，每年 $m$ 次，第一次付款在时间 $t=\\frac{1}{m}$ 年，最后一次付款在时间 $t=n$ 年。结算在时间 $t=0$ 进行，紧邻一个付息日之前。请使用每年复利 $m$ 次的名义年收益率。\n\n定义支付期数为 $N = m \\cdot n$。定义每期票息为 $C = \\frac{F \\cdot c}{m}$。在第 $k$ 期（$k \\in \\{1,2,\\dots,N\\}$）的现金流，当 $k \\lt N$ 时为 $C$，当 $k = N$ 时为 $C + F$。每期贴现因子为 $d = \\frac{1}{1 + \\frac{y}{m}}$。第 $k$ 期现金流的现值为 $PV_k = \\text{CF}_k \\cdot d^{k}$，债券价格为：\n$$\nP = \\sum_{k=1}^{N} PV_k.\n$$\n令 $t_k = \\frac{k}{m}$ 表示第 $k$ 次现金流发生的时间（以年为单位）。Macaulay 久期（以年为单位）定义为：\n$$\nD_{\\mathrm{Mac}} = \\sum_{k=1}^{N} t_k \\cdot \\frac{PV_k}{P}.\n$$\n修正久期（以年为单位）定义为：\n$$\nD_{\\mathrm{Mod}} = \\frac{D_{\\mathrm{Mac}}}{1 + \\frac{y}{m}}.\n$$\n\n所有输出中，久期必须以年为单位，价格的货币单位必须与 $F$ 相同。票息率和收益率必须以小数形式提供和处理（例如，百分之五应为 $0.05$）。您的程序必须为每个测试用例计算三元组 $[P, D_{\\mathrm{Mac}}, D_{\\mathrm{Mod}}]$，其中每个值都四舍五入到恰好 $6$ 位小数。\n\n实现您的程序以评估以下涵盖多种情况的测试套件：\n- 案例 $1$（标准情况）：$F = 1000$, $c = 0.06$, $y = 0.05$, $m = 2$, $n = 5$。\n- 案例 $2$（零息债券）：$F = 1000$, $c = 0.0$, $y = 0.05$, $m = 1$, $n = 3$。\n- 案例 $3$（单期到期）：$F = 100$, $c = 0.08$, $y = 0.10$, $m = 1$, $n = 1$。\n- 案例 $4$（极低收益率，高票息，高频复利）：$F = 1000$, $c = 0.12$, $y = 0.0001$, $m = 12$, $n = 10$。\n- 案例 $5$（较长到期时间，季度付息）：$F = 100$, $c = 0.05$, $y = 0.07$, $m = 4$, $n = 7$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，格式如下：\n$$\n\\big[ [P_1,D_{\\mathrm{Mac},1},D_{\\mathrm{Mod},1}], [P_2,D_{\\mathrm{Mac},2},D_{\\mathrm{Mod},2}], \\dots, [P_5,D_{\\mathrm{Mac},5},D_{\\mathrm{Mod},5}] \\big]\n$$\n该行中任何地方都没有空格，且每个数值都四舍五入到恰好 $6$ 位小数。", "solution": "问题陈述经确认为具有科学依据、定义明确、客观且完整。它为计算债券价格和久期提供了一套精确、标准的金融定义。该任务是将这些定义直接应用于一组给定的参数。因此，解决方案是通过对所提供公式的直接算法实现而得出的。\n\n其方法是，对于由参数 $(F, c, y, m, n)$ 指定的每个测试用例，计算所需的三元组 $[P, D_{\\mathrm{Mac}}, D_{\\mathrm{Mod}}]$。这些参数分别代表面值 ($F$)、年票息率 ($c$)、年到期收益率 ($y$)、每年付息次数 ($m$) 和到期年限 ($n$)。\n\n计算过程执行如下：\n\n首先，我们确定用于周期性计算的基本参数。总付息期数为 $N = m \\cdot n$。每期票息支付额为 $C = \\frac{F \\cdot c}{m}$。与每年复利 $m$ 次的名义年收益率 $y$ 相一致的每期收益率为 $y_{\\mathrm{p}} = \\frac{y}{m}$。\n\n其次，我们构建现金流序列。对于从 $1$ 到 $N$ 的每个时期索引 $k$，在时间 $t_k = \\frac{k}{m}$ 年发生一笔现金流 $\\text{CF}_k$。除最后一期外，所有期间的现金流均为每期票息 $C$。对于最后一期 $k=N$，现金流还包括面值 $F$ 的偿还。因此：\n$$\n\\text{CF}_k =\n\\begin{cases}\nC & \\text{for } k \\in \\{1, 2, \\dots, N-1\\} \\\\\nC + F & \\text{for } k = N\n\\end{cases}\n$$\n\n第三，我们通过将每笔现金流贴现至时间 $t=0$ 来计算其现值。第 $k$ 期现金流的现值（记为 $PV_k$）由下式给出：\n$$\nPV_k = \\frac{\\text{CF}_k}{(1 + y_{\\mathrm{p}})^k}\n$$\n债券的价格 $P$ 是其所有未来现金流的现值之和：\n$$\nP = \\sum_{k=1}^{N} PV_k\n$$\n\n第四，我们计算 Macaulay 久期 $D_{\\mathrm{Mac}}$。这是现金流发生时间的加权平均值，其中权重是每笔现金流的现值与债券总价格的比率。它以年为单位进行度量。\n$$\nD_{\\mathrm{Mac}} = \\sum_{k=1}^{N} t_k \\cdot \\frac{PV_k}{P} = \\frac{1}{P} \\sum_{k=1}^{N} \\frac{k}{m} \\cdot PV_k\n$$\n\n第五，我们计算修正久期 $D_{\\mathrm{Mod}}$。这是衡量债券价格对收益率变化的敏感性的指标。它是通过对 Macaulay 久期根据收益率的复利频率进行调整而得出的：\n$$\nD_{\\mathrm{Mod}} = \\frac{D_{\\mathrm{Mac}}}{1 + y_{\\mathrm{p}}} = \\frac{D_{\\mathrm{Mac}}}{1 + \\frac{y}{m}}\n$$\n\n这整个过程通过算法实现。为提高效率，周期 $k$、时间 $t_k$、现金流 $\\text{CF}_k$ 和现值 $PV_k$ 的序列被生成为数值数组。计算 $P$ 和 $D_{\\mathrm{Mac}}$ 所需的求和作为向量运算执行。计算出的 $P$、$D_{\\mathrm{Mac}}$ 和 $D_{\\mathrm{Mod}}$ 的最终值按要求四舍五入到 $6$ 位小数。对所提供的 $5$ 个测试用例中的每一个都重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes bond price, Macaulay duration, and modified duration for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (F, c, y, m, n)\n    test_cases = [\n        # Case 1 (standard case)\n        (1000, 0.06, 0.05, 2, 5),\n        # Case 2 (zero-coupon bond)\n        (1000, 0.0, 0.05, 1, 3),\n        # Case 3 (single-period maturity)\n        (100, 0.08, 0.10, 1, 1),\n        # Case 4 (very low yield, high coupon, frequent compounding)\n        (1000, 0.12, 0.0001, 12, 10),\n        # Case 5 (longer maturity, quarterly payments)\n        (100, 0.05, 0.07, 4, 7),\n    ]\n\n    results = []\n    for case in test_cases:\n        F, c, y, m, n = case\n        result_triplet = compute_bond_metrics(F, c, y, m, n)\n        results.append(result_triplet)\n\n    # Format the final output string as specified.\n    # e.g., [[P1,DMac1,DMod1],[P2,DMac2,DMod2],...]\n    # with 6 decimal places and no spaces.\n    formatted_results = []\n    for triplet in results:\n        # Format each number in the triplet to exactly 6 decimal places.\n        formatted_triplet = [f\"{val:.6f}\" for val in triplet]\n        # Create the string representation of the inner list.\n        formatted_results.append(f\"[{','.join(formatted_triplet)}]\")\n    \n    # Join the inner list strings into the final output string.\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n\n    print(final_output_str)\n\ndef compute_bond_metrics(F, c, y, m, n):\n    \"\"\"\n    Calculates the price, Macaulay duration, and modified duration of a bond.\n\n    Args:\n        F (float): Face value of the bond.\n        c (float): Annual coupon rate (decimal).\n        y (float): Annual yield to maturity (decimal).\n        m (int): Number of coupon payments per year.\n        n (int): Years to maturity.\n\n    Returns:\n        list: A list containing [price, macaulay_duration, modified_duration].\n    \"\"\"\n    # 1. Calculate derived quantities\n    if n == 0 or m == 0:  # Handle case with no periods\n        return [F if n==0 else 0, 0, 0] # Or other appropriate handling for maturity at t=0\n        \n    N = m * n  # Total number of periods\n    C = (F * c) / m  # Coupon payment per period\n    y_period = y / m  # Yield per period\n\n    # 2. Generate calculation arrays using numpy for vectorized operations\n    # Array of period indices k = 1, 2, ..., N\n    k_periods = np.arange(1, N + 1)\n    \n    # Array of times for each cash flow in years, t_k = k/m\n    t_k_years = k_periods / m\n\n    # 3. Construct the cash flow stream\n    # All periods receive coupon C\n    cash_flows = np.full(N, C)\n    # The last period also receives the face value F\n    cash_flows[-1] += F\n\n    # 4. Calculate the present value (PV) of each cash flow\n    # Discount factors for each period: 1 / (1 + y_period)^k\n    discount_factors = (1 + y_period) ** -k_periods\n    # Present value of each cash flow: PV_k = CF_k * discount_factor_k\n    pv_cash_flows = cash_flows * discount_factors\n\n    # 5. Calculate the bond price (P)\n    # P = sum of all PV_k\n    price = np.sum(pv_cash_flows)\n\n    # Prevent division by zero if price is zero (e.g., y is infinite).\n    if price == 0:\n        return [0.0, 0.0, 0.0]\n\n    # 6. Calculate Macaulay Duration (D_Mac)\n    # D_Mac = (1/P) * sum(t_k * PV_k)\n    weighted_pvs = t_k_years * pv_cash_flows\n    macaulay_duration = np.sum(weighted_pvs) / price\n\n    # 7. Calculate Modified Duration (D_Mod)\n    # D_Mod = D_Mac / (1 + y_period)\n    modified_duration = macaulay_duration / (1 + y_period)\n\n    # 8. Return the raw (unrounded) triplet of results\n    return [price, macaulay_duration, modified_duration]\n\nsolve()\n```"}, {"introduction": "在掌握了久期的基本计算之后，我们可以通过一个思想实验来深入探索其内在含义。这个练习要求您通过数值模拟来证明，当息票率 $c$ 趋近于零时，附息债券的麦考利久期 $D(c,T)$ 会收敛于其到期时间 $T$。这个过程不仅能加深您对久期是现金流时间加权平均值的理解，还能清晰地揭示为何久期常被称作债券的“有效到期日”[@problem_id:2377198]。通过观察这种收敛行为，您将直观地看到附息债券与零息债券之间的内在联系。", "id": "2377198", "problem": "你将编写一个完整、可运行的程序，从第一性原理出发，数值上证明一个无违约风险的固定票息债券的麦考利久期（Macaulay duration），记为 $D(c,T)$，当其年票面利率 $c$ 趋近于 $0$ 时，将收敛于其到期时间 $T$（以年为单位）。请在离散时间、按年复利的设定下进行，并以下述假设和定义为基础。\n\n- 债券的面值为 $F$，到期时间为 $T$ 年，年票面利率为 $c$（以小数表示，非百分比），以及恒定的年到期收益率为 $y$（以小数表示，非百分比）。时间以年为单位。\n- 在按年复利的情况下，于时间 $t$ 年收到的现金流 $CF_t$ 的现值 (PV) 等于 $CF_t / (1+y)^t$。\n- 债券的价格 $P$ 是其所有现金流现值的总和。\n- 麦考利久期是所有现金流的现值加权平均时间。形式上，如果权重 $w_t$ 定义为 $w_t = \\text{PV}(CF_t)/P$，那么久期 $D = \\sum_{t=1}^{T} t \\, w_t$。\n\n请精确地实现以下要求。\n\n- 实现一个算法，为面值为 $F$、年票面利率为 $c$、到期时间为 $T$（整数年）、年收益率为 $y$ 的债券构建年度现金流表。每年的票息支付为 $c \\cdot F$。在到期日 $t = T$，现金流为 $c \\cdot F + F$；在中间年份 $t = 1, 2, \\ldots, T-1$，现金流为 $c \\cdot F$。\n- 使用现值的定义以及麦考利久期作为现值加权平均时间的定义，为给定的输入计算 $D(c,T)$。\n- 对于下面测试套件中的每一组参数，计算每个指定票面利率 $c$ 对应的绝对差值 $|T - D(c,T)|$，并将每个差值四舍五入到 $6$ 位小数。所有时间量均以年为单位。\n\n测试套件。对于每一行，输入包括 $(F, y, T)$ 以及一个按给定顺序进行评估的票面利率列表 $\\{c_i\\}$。所有利率均为小数，而非百分比，$T$ 的单位是年。\n\n- 测试用例 $1$：$(F, y, T) = (100, 0.05, 10)$，其中 $c \\in \\{0.10, 0.05, 0.01, 0.001, 0.0\\}$。\n- 测试用例 $2$：$(F, y, T) = (100, 0.08, 7)$，其中 $c \\in \\{0.12, 0.06, 0.01, 0.0\\}$。\n- 测试用例 $3$：$(F, y, T) = (100, 0.03, 1)$，其中 $c \\in \\{0.20, 0.01, 0.0\\}$。\n- 测试用例 $4$：$(F, y, T) = (100, 0.03, 30)$，其中 $c \\in \\{0.05, 0.01, 0.0\\}$。\n\n最终输出格式。\n\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。结果必须是四舍五入后的绝对差值 $|T - D(c,T)|$ 的扁平化列表，其顺序严格遵循测试套件的顺序：首先是测试用例1的所有差值（按其票面利率列表顺序），然后是测试用例2的所有差值（按其顺序），以此类推，直至测试用例3和4。\n- 所需格式示例（仅为说明）：$[x_1,x_2,\\ldots,x_n]$，其中每个 $x_i$ 是一个四舍五入到 $6$ 位小数的浮点数。", "solution": "问题陈述提出了一个计算金融学中的有效任务。它在科学上以债券估值原则为基础，定义和参数齐全，问题阐述清晰，表述客观。不存在不一致、模糊不清或事实错误之处。目标是数值上证明麦考利久期的一个基本性质：对于固定票息债券，当票面利率趋近于零时，其久期收敛于其到期时间。我们将着手解决此问题。\n\n需要研究的核心关系是麦考利久期 $D(c,T)$ 作为年票面利率 $c$ 和到期时间 $T$ 的函数的行为。问题定义了必要的组成部分，我们在此将其形式化。\n\n债券的特征包括其面值 $F$、以年为单位的到期时间 $T$、年票面利率 $c$ 以及现行的年到期收益率 $y$。该债券在离散时间点 $t = 1, 2, \\ldots, T$ 产生一系列现金流 $CF_t$。对于标准的固定票息债券，这些现金流为：\n$$\nCF_t =\n\\begin{cases}\nc \\cdot F & \\text{for } t = 1, 2, \\ldots, T-1 \\\\\nc \\cdot F + F & \\text{for } t = T\n\\end{cases}\n$$\n这些是每年的票息支付 $c \\cdot F$，外加在到期时偿还的面值 $F$。\n\n在货币时间价值原则下，假设年收益率 $y$ 恒定且按年复利，于时间 $t$ 收到的现金流 $CF_t$ 的现值 $PV(CF_t)$ 由下式给出：\n$$\nPV(CF_t) = \\frac{CF_t}{(1+y)^t}\n$$\n债券价格 $P$ 是其所有未来现金流的现值总和：\n$$\nP = \\sum_{t=1}^{T} PV(CF_t) = \\sum_{t=1}^{T} \\frac{CF_t}{(1+y)^t}\n$$\n麦考利久期 $D$ 定义为收到现金流的现值加权平均时间。每个时期 $t$ 的权重（记为 $w_t$）是该时期现金流占债券总价格的比例：\n$$\nw_t = \\frac{PV(CF_t)}{P}\n$$\n久期则是这些加权时间段的总和：\n$$\nD = \\sum_{t=1}^{T} t \\cdot w_t = \\frac{1}{P} \\sum_{t=1}^{T} t \\cdot PV(CF_t) = \\frac{\\sum_{t=1}^{T} \\frac{t \\cdot CF_t}{(1+y)^t}}{\\sum_{t=1}^{T} \\frac{CF_t}{(1+y)^t}}\n$$\n\n我们可以分析当 $c \\to 0$ 时 $D(c,T)$ 的极限行为。当票面利率 $c$ 趋近于零时，该债券转变为零息债券。对于零息债券，$c=0$，唯一非零的现金流是在到期时间 $T$ 时的面值 $F$。其现金流表变为：\n$$\nCF_t =\n\\begin{cases}\n0 & \\text{for } t = 1, 2, \\ldots, T-1 \\\\\nF & \\text{for } t = T\n\\end{cases}\n$$\n对于此特殊情况，债券价格 $P_0$ 仅仅是面值的现值：\n$$\nP_0 = \\frac{F}{(1+y)^T}\n$$\n此零息债券的麦考利久期 $D_0$ 计算如下：\n$$\nD_0 = \\frac{1}{P_0} \\sum_{t=1}^{T} t \\cdot PV(CF_t)\n$$\n由于只有 $t=T$ 的项非零，求和式简化为单项：\n$$\nD_0 = \\frac{1}{P_0} \\left( T \\cdot PV(CF_T) \\right) = \\frac{1}{P_0} \\left( T \\cdot \\frac{F}{(1+y)^T} \\right)\n$$\n代入 $P_0$ 的表达式，我们得到：\n$$\nD_0 = \\frac{1}{\\frac{F}{(1+y)^T}} \\left( T \\cdot \\frac{F}{(1+y)^T} \\right) = T\n$$\n这一分析结果证明，零息债券的麦考利久期恰好是其到期时间。因此，随着付息债券的票面利率 $c$ 减小，其现金流结构趋近于零息债券，其久期 $D(c,T)$ 必然收敛于 $T$。本数值任务就是计算绝对差值 $|T - D(c,T)|$，并观察当 $c$ 减小时，该差值向 $0$ 收敛的过程。\n\n执行此数值验证的算法如下：\n1.  对于一组给定的参数 $(F, y, T, c)$，构建一个时间向量 $\\mathbf{t} = [1, 2, \\ldots, T]$。\n2.  构建相应的现金流向量 $\\mathbf{CF}$。其中对于 $t \\in \\{1, \\ldots, T-1\\}$ 的每个元素 $CF_t$ 为 $c \\cdot F$，最终元素 $CF_T$ 为 $c \\cdot F + F$。\n3.  构建一个折现因子向量 $\\mathbf{df}$，其中每个元素 $df_t$ 是 $1 / (1+y)^t$。\n4.  通过逐元素相乘计算现金流的现值向量 $\\mathbf{PV}_{\\mathbf{CF}}$：$\\mathbf{PV}_{\\mathbf{CF}} = \\mathbf{CF} \\odot \\mathbf{df}$。\n5.  通过对 $\\mathbf{PV}_{\\mathbf{CF}}$ 的元素求和来计算债券价格 $P$。\n6.  计算久期公式的分子，即时间加权的现值之和。这可以计算为点积 $\\mathbf{t} \\cdot \\mathbf{PV}_{\\mathbf{CF}}$。\n7.  计算麦考利久期 $D = (\\mathbf{t} \\cdot \\mathbf{PV}_{\\mathbf{CF}}) / P$。\n8.  最后，计算绝对差值 $|T - D|$ 并按要求四舍五入到 $6$ 位小数。\n\n此过程将系统地应用于测试套件中指定的所有参数集。结果将被汇总到单个列表中作为最终输出。到期时间 $T=1$ 的特殊情况是一个有用的检验；在这种情况下，所有现金流都在 $t=1$ 时发生，因此久期必须恰好为 $1$，对于任何票面利率 $c$，差值 $|T-D|$ 都必须为 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite: Each entry is ((F, y, T), [c1, c2, ...])\n    # F: Face Value\n    # y: Annual yield to maturity (decimal)\n    # T: Maturity in years (integer)\n    # c: Annual coupon rate (decimal)\n    test_cases = [\n        ((100, 0.05, 10), [0.10, 0.05, 0.01, 0.001, 0.0]),\n        ((100, 0.08, 7), [0.12, 0.06, 0.01, 0.0]),\n        ((100, 0.03, 1), [0.20, 0.01, 0.0]),\n        ((100, 0.03, 30), [0.05, 0.01, 0.0])\n    ]\n\n    results = []\n    \n    for params, coupon_rates in test_cases:\n        F, y, T = params\n        for c in coupon_rates:\n            gap = compute_duration_gap(F, y, T, c)\n            results.append(gap)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_duration_gap(F: float, y: float, T: int, c: float) -> float:\n    \"\"\"\n    Computes the Macaulay duration of a bond and the absolute gap from its maturity.\n\n    Args:\n        F (float): Face value of the bond.\n        y (float): Annual yield to maturity (as a decimal).\n        T (int): Maturity of the bond in years.\n        c (float): Annual coupon rate (as a decimal).\n\n    Returns:\n        float: The absolute difference |T - D(c,T)|, rounded to 6 decimal places.\n    \"\"\"\n    if T <= 0:\n        # Duration is not well-defined for non-positive maturity.\n        return 0.0\n\n    # Step 1: Create a time vector from 1 to T.\n    # A vector of time periods t = 1, 2, ..., T.\n    times = np.arange(1, T + 1)\n\n    # Step 2: Construct the cash flow schedule.\n    # Coupon payments are c*F for each period.\n    cash_flows = np.full(T, c * F)\n    # Add the face value repayment at maturity (the last period).\n    cash_flows[-1] += F\n\n    # A check for the price being zero or negative (e.g., if y is very large and negative)\n    # to avoid division by zero. For y > -1, this is not an issue.\n    # denominator (1+y) must be > 0.\n    if 1 + y <= 0:\n        # Present value is undefined. Handle as a degenerate case.\n        # This case is not expected with problem data but is good practice.\n        return 0.0\n\n    # Step 3: Calculate the present value of each cash flow.\n    # Discount factors are 1 / (1+y)^t for each t.\n    discount_factors = 1 / ((1 + y) ** times)\n    pv_cash_flows = cash_flows * discount_factors\n\n    # Step 4: Calculate the bond's price.\n    price = np.sum(pv_cash_flows)\n    \n    # If the price is zero or negative, duration is undefined.\n    if price <= 0:\n        return 0.0\n    \n    # Step 5: Calculate Macaulay Duration.\n    # Numerator of the duration formula: sum of t * PV(CF_t)\n    weighted_times_sum = np.sum(times * pv_cash_flows)\n    \n    duration = weighted_times_sum / price\n    \n    # Step 6: Calculate the absolute gap |T - D| and round.\n    gap = np.abs(T - duration)\n    \n    return round(gap, 6)\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "将久期理论应用于实际的投资组合构建是金融工程中的核心任务之一。本练习将带您进入资产组合管理的实战场景：在一个给定的债券池中，构建一个成本最低且满足特定美元久期目标的投资组合[@problem_id:2377225]。您需要从久期的基本定义出发，推导出美元久期 $DD_i$，并将其作为约束条件构建一个线性规划问题。解决这个优化问题不仅能锻炼您的建模和算法思维，还能让您体验到金融专业人士如何运用久期这一工具来精确地管理和对冲投资组合的利率风险。", "id": "2377225", "problem": "给定一个固定的附息债券集合，您必须构建一个只做多的投资组合，以最小的初始成本达到目标久期。您必须从贴现现金流的现值和久期的时间加权性质等基本定义出发，然后推导出您需要的任何附加结构，包括一个数学上合理的优化公式。您的实现必须是自包含的，并直接根据输入参数计算债券价格和久期。\n\n使用的基本原理：\n- 在恒定到期收益率下贴现的一系列确定性现金流的现值。\n- 麦考利久期的时间加权平均定义。\n- 价格对收益率微小变化的一阶灵敏度，作为美元久期的含义。\n\n债券集合：\n- 所有债券的面值为 $F = 100$，每年付息频率为 $m = 2$ 次（半年一次）。\n- 对于债券 $i$，输入参数为年票面利率 $c_i$（以年化小数表示），到期收益率 $y_i$（以年化名义利率表示，每年复利 $m$ 次，以小数表示），以及到期时间 $T_i$（以年为单位）。在 $m T_i - 1$ 个时期内，每个时期的票息为 $c_i F / m$；在时间 $t = T_i$ 的最终现金流等于 $F + c_i F / m$。\n- 债券 $i$ 的价格 $P_i$ 是其现金流以收益率 $y_i$ 和复利频率 $m$ 贴现后的现值。\n- 债券 $i$ 的麦考利久期 $D^{\\text{Mac}}_i$（以年为单位）是现金流现值乘以 $t_k$ 的时间加权平均值除以价格，其中 $t_k = k/m$，对于 $k = 1,2,\\dots,m T_i$。\n\n投资组合构建与优化：\n- 决策变量是每种债券 $i$ 的非负数量（以面值 $F$ 的单位计）$n_i$，受限于每种债券的可用性约束 $0 \\le n_i \\le \\bar{n}_i$，其中 $\\bar{n}_i$ 是债券 $i$ 的最大可用单位数。\n- 将单位债券 $i$ 的美元久期定义为其价格对收益率 $y_i$ 微小并行变化的一阶灵敏度（以美元计）。您必须根据上述基本原理推导和计算此量。\n- 投资组合的总美元久期是所选单位的美元久期之和。\n- 投资组合构建问题是：在满足只做多和可用性约束的前提下，最小化初始成本（现值），同时达到或超过目标美元久期 $DD_{\\text{target}}$。\n\n您必须遵守的数学要求：\n1. 根据贴现现金流计算每支债券的价格 $P_i$：\n   - 对于 $k = 1,2,\\dots,m T_i - 1$，在时间 $t_k = k/m$ 的现金流为 $CF_{i,k} = c_i F / m$，贴现因子为 $(1 + y_i/m)^{-k}$。\n   - 对于 $k = m T_i$，在时间 $t_k=k/m$ 的现金流为 $CF_{i,k} = F + c_i F / m$，贴现因子为 $(1 + y_i/m)^{-k}$。\n   - 价格为 $P_i = \\sum_{k=1}^{m T_i} CF_{i,k} (1 + y_i/m)^{-k}$。\n2. 计算每支债券的麦考利久期 $D^{\\text{Mac}}_i$：\n   $$D^{\\text{Mac}}_i = \\frac{\\sum_{k=1}^{m T_i} t_k \\, CF_{i,k} \\, (1 + y_i/m)^{-k}}{P_i}, \\quad \\text{其中 } t_k = \\frac{k}{m}。$$\n3. 仅使用上述原理，推导并计算每支债券 $i$ 的单位美元久期，即 $P_i$ 对 $y_i$ 微小并行变化的美元灵敏度。您必须实现此计算，不得硬编码任何未从定义中推导出的封闭形式的快捷公式。\n4. 构建并求解优化问题：\n   - 决策向量 $n \\in \\mathbb{R}^N$，其中 $N$ 是债券数量。\n   - 目标：最小化 $\\sum_{i=1}^N P_i n_i$。\n   - 约束：$\\sum_{i=1}^N (\\text{债券 } i \\text{ 的单位美元久期}) \\cdot n_i \\ge DD_{\\text{target}}$。\n   - 边界：对所有 $i$，满足 $0 \\le n_i \\le \\bar{n}_i$。\n   - 如果问题不可行，则按下文规定返回一个哨兵值。\n\n测试套件：\n使用以下债券集合（所有债券的 $F = 100$ 且 $m = 2$）：\n- 债券 A：$c_A = 0.04$, $y_A = 0.05$, $T_A = 2$, $\\bar{n}_A = 50$。\n- 债券 B：$c_B = 0.06$, $y_B = 0.04$, $T_B = 5$, $\\bar{n}_B = 30$。\n- 债券 C：$c_C = 0.03$, $y_C = 0.05$, $T_C = 10$, $\\bar{n}_C = 40$。\n- 债券 D：$c_D = 0.00$, $y_D = 0.04$, $T_D = 3$, $\\bar{n}_D = 10$。\n\n在以下四个目标美元久期（以美元计）上评估您的算法：\n- 情况 1：$DD_{\\text{target}} = 0$。\n- 情况 2：$DD_{\\text{target}} = 500$。\n- 情况 3：$DD_{\\text{target}} = 30000$。\n- 情况 4：$DD_{\\text{target}} = 60000$。\n\n作答规范：\n- 对于每种情况，如果可行，则输出最小初始成本（一个浮点数），四舍五入到 $10^{-4}$（四位小数）。\n- 如果某种情况不可行（即，在边界条件下可获得的最大美元久期严格小于 $DD_{\\text{target}}$），则为该情况输出浮点数 $-1.0$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中 $r_j$ 是根据上述定义的情况 $j$ 的结果。", "solution": "所提出的问题是构建一个只做多的、成本最低的债券投资组合，以达到一个指定的目标总美元久期。解决方案必须从债券定价和久期的基本原理推导得出。该问题定义明确、科学上合理，并包含了获得唯一解所需的所有信息。我们继续进行推导和求解。\n\n首先，我们对债券价格进行形式化定义。债券是一系列确定性现金流。对于面值为 $F$、年票面利率为 $c_i$、到期年限为 $T_i$ 年、付息频率为 $m$ 的债券 $i$，在时间 $t_k = k/m$（其中 $k=1, 2, \\dots, m T_i$）的现金流记作 $CF_{i,k}$。对于付息期（$k < m T_i$），现金流是定期票息支付额 $CF_{i,k} = c_i F / m$。在到期日（$k = m T_i$），现金流包括最后一期票息和面值，$CF_{i, m T_i} = F + c_i F / m$。\n\n债券 $i$ 的价格（记作 $P_i$）是其现金流系列以每期到期收益率 $y_i/m$ 贴现后的现值。收益率 $y_i$ 以名义年利率给出，每年复利 $m$ 次。价格由以下公式给出：\n$$ P_i(y_i) = \\sum_{k=1}^{m T_i} CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} $$\n该公式直接计算了单位债券 $i$ 的成本。\n\n其次，我们必须推导债券的美元久期。问题将其定义为价格对收益率 $y_i$ 微小并行变化的一阶灵敏度。在数学上，这是价格相对于收益率的导数 $\\frac{dP_i}{dy_i}$。在金融学中，习惯上将美元久期定义为一个正量，代表收益率每增加一个单位所造成的美元损失。由于价格和收益率成反比关系，我们将单位债券 $i$ 的美元久期（记作 $DD_i$）定义为：\n$$ DD_i = -\\frac{dP_i}{dy_i} $$\n我们使用链式法则从价格公式中推导出这个导数：\n$$ \\frac{dP_i}{dy_i} = \\frac{d}{dy_i} \\sum_{k=1}^{m T_i} CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} = \\sum_{k=1}^{m T_i} CF_{i,k} \\frac{d}{dy_i} \\left(1 + \\frac{y_i}{m}\\right)^{-k} $$\n贴现因子项的导数为：\n$$ \\frac{d}{dy_i} \\left(1 + \\frac{y_i}{m}\\right)^{-k} = -k \\left(1 + \\frac{y_i}{m}\\right)^{-k-1} \\cdot \\frac{1}{m} $$\n将此代入 $\\frac{dP_i}{dy_i}$ 的表达式中，得到：\n$$ \\frac{dP_i}{dy_i} = \\sum_{k=1}^{m T_i} CF_{i,k} \\left( - \\frac{k}{m} \\right) \\left(1 + \\frac{y_i}{m}\\right)^{-k-1} $$\n$$ \\frac{dP_i}{dy_i} = - \\frac{1}{1 + y_i/m} \\sum_{k=1}^{m T_i} \\frac{k}{m} \\cdot CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} $$\n我们记第 $k$ 次现金流的时间为 $t_k = k/m$。表达式变为：\n$$ \\frac{dP_i}{dy_i} = - \\frac{1}{1 + y_i/m} \\sum_{k=1}^{m T_i} t_k \\cdot \\left[ CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} \\right] $$\n方括号中的项是第 $k$ 次现金流的现值。该和是麦考利久期公式的分子。按要求，我们计算麦考利久期 $D^{\\text{Mac}}_i$：\n$$ D^{\\text{Mac}}_i = \\frac{\\sum_{k=1}^{m T_i} t_k \\cdot PV(CF_{i,k})}{P_i} = \\frac{\\sum_{k=1}^{m T_i} t_k \\cdot CF_{i,k} (1 + y_i/m)^{-k}}{P_i} $$\n由此可见，$\\sum t_k \\cdot PV(CF_{i,k}) = D^{\\text{Mac}}_i \\cdot P_i$。将此代入我们的导数表达式中，我们得到价格灵敏度与麦考利久期之间的关系：\n$$ \\frac{dP_i}{dy_i} = - \\frac{D^{\\text{Mac}}_i \\cdot P_i}{1 + y_i/m} $$\n因此，单位债券 $i$ 的美元久期为：\n$$ DD_i = -\\frac{dP_i}{dy_i} = \\frac{D^{\\text{Mac}}_i \\cdot P_i}{1 + y_i/m} $$\n这个量也称为价格与修正久期的乘积，即 $P_i \\cdot D^{\\text{Mod}}_i$。我们的实现将计算 $\\sum t_k \\cdot PV(CF_{i,k})$，并直接用它来求得 $DD_i = \\frac{1}{1+y_i/m} \\sum t_k \\cdot PV(CF_{i,k})$，这在代数上是等价的，并且遵循了从第一性原理的推导。\n\n第三，我们构建优化问题。设 $n_i$ 是投资组合中持有的债券 $i$ 的数量（单位数）。决策变量是向量 $n = [n_1, n_2, \\dots, n_N]^T$ 的元素，其中 $N$ 是债券集合中的债券数量。目标是最小化投资组合的总初始成本，即各债券持有成本之和：\n$$ \\text{最小化 } \\quad C(n) = \\sum_{i=1}^N P_i n_i $$\n该最小化受若干约束条件限制。投资组合必须是只做多（$n_i \\ge 0$），每种债券的数量不能超过其可用量（$n_i \\le \\bar{n}_i$），且投资组合的总美元久期必须达到或超过目标 $DD_{\\text{target}}$。投资组合的美元久期是其各组成部分美元久期的总和：\n$$ \\sum_{i=1}^N DD_i n_i \\ge DD_{\\text{target}} $$\n完整的优化问题是一个线性规划（LP）：\n$$ \\begin{aligned}\n\\text{最小化} \\quad & \\sum_{i=1}^N P_i n_i \\\\\n\\text{约束于} \\quad & \\sum_{i=1}^N DD_i n_i \\ge DD_{\\text{target}} \\\\\n& 0 \\le n_i \\le \\bar{n}_i \\quad \\text{for } i = 1, \\dots, N\n\\end{aligned} $$\n\n这种特定形式的线性规划，被称为连续背包问题，可以通过贪心算法高效解决。其逻辑是首先从最具成本效益的来源“购买”美元久期。债券 $i$ 的成本效益是其价格与美元久期的比率，$R_i = P_i / DD_i$。比率越低，表示该久期来源越便宜。\n\n算法如下：\n1.  对于债券集合中的每支债券 $i$，计算其价格 $P_i$ 和美元久期 $DD_i$。\n2.  如果 $DD_{\\text{target}} \\le 0$，约束 $\\sum DD_i n_i \\ge DD_{\\text{target}}$ 在所有 $i$ 选择 $n_i=0$ 时满足（因为传统债券的 $DD_i > 0$）。因此最小成本为 $0$。\n3.  对于 $DD_{\\text{target}} > 0$，首先检查可行性。计算可用债券能提供的最大美元久期：$DD_{\\text{max\\_total}} = \\sum_{i=1}^N DD_i \\bar{n}_i$。如果 $DD_{\\text{target}} > DD_{\\text{max\\_total}}$，则问题不可行。\n4.  如果可行，则按成本效益比 $R_i = P_i / DD_i$ 的升序对债券进行排序。\n5.  遍历排好序的债券。对于每支债券 $i$，获取所需数量的久期，最多不超过该债券可提供的最大久期（$DD_i \\bar{n}_i$），直到满足目标久期 $DD_{\\text{target}}$。\n6.  总成本是每步所产生费用的总和。从债券 $i$ 获取数量为 $\\Delta DD$ 的久期的成本是 $\\Delta DD \\cdot R_i$。\n\n我们将此过程应用于给定的测试套件。债券集合由四支债券（A、B、C、D）组成，其 $F=100$ 且 $m=2$。首先，我们计算它们的属性：\n- 债券 A（$c=0.04, y=0.05, T=2, \\bar{n}=50$）：$P_A \\approx 98.1190$, $DD_A \\approx 185.8330$, $R_A \\approx 0.5280$。来自 A 的最大久期：$9291.65$。\n- 债券 B（$c=0.06, y=0.04, T=5, \\bar{n}=30$）：$P_B \\approx 108.9828$, $DD_B \\approx 485.4385$, $R_B \\approx 0.2245$。来自 B 的最大久期：$14563.16$。\n- 债券 C（$c=0.03, y=0.05, T=10, \\bar{n}=40$）：$P_C \\approx 84.4443$, $DD_C \\approx 683.7196$, $R_C \\approx 0.1235$。来自 C 的最大久期：$27348.78$。\n- 债券 D（$c=0.00, y=0.04, T=3, \\bar{n}=10$）：$P_D \\approx 88.7971$, $DD_D \\approx 261.1680$, $R_D \\approx 0.3400$。来自 D 的最大久期：$2611.68$。\n\n成本效益的顺序是 C、B、D、A。总可用久期约为 $53815.27$。\n\n情况 1：$DD_{\\text{target}} = 0$。最小成本为 $0$。\n\n情况 2：$DD_{\\text{target}} = 500$。此目标为正，且小于债券 C 可提供的最大久期。我们从债券 C 获取 $500$ 单位的久期。成本为 $500 \\cdot R_C \\approx 500 \\cdot 0.12351 = 61.7550$。\n\n情况 3：$DD_{\\text{target}} = 30000$。\n1.  从债券 C 获取所有可用久期：$27348.78$。成本为 $P_C \\cdot \\bar{n}_C \\approx 84.4443 \\cdot 40 = 3377.7706$。\n2.  还需久期：$30000 - 27348.78 = 2651.22$。\n3.  从下一个最便宜的来源，即债券 B 获取。成本为 $2651.22 \\cdot R_B \\approx 2651.22 \\cdot 0.22452 = 595.2974$。\n4.  总成本：$3377.7706 + 595.2974 = 3973.0680$。\n\n情况 4：$DD_{\\text{target}} = 60000$。总可用久期约为 $53815.27$，小于 $60000$。问题不可行。结果为 $-1.0$。\n\n实现将精确执行这些计算，并提供最终四舍五入的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_bond_properties(c, y, T, F=100, m=2):\n    \"\"\"\n    Calculates the price and dollar duration of a bond from first principles.\n\n    Args:\n        c (float): Annual coupon rate (decimal).\n        y (float): Nominal annual yield to maturity (decimal).\n        T (int): Maturity in years.\n        F (float): Face value.\n        m (int): Compounding/payment frequency per year.\n\n    Returns:\n        tuple[float, float]: A tuple containing the bond's price and dollar duration.\n    \"\"\"\n    if T <= 0:\n        return 0.0, 0.0\n\n    num_periods = int(m * T)\n    y_per = y / m\n    c_per = c * F / m\n\n    periods = np.arange(1, num_periods + 1)\n    \n    # Cash flows\n    cash_flows = np.full(num_periods, c_per)\n    cash_flows[-1] += F\n\n    # Discount factors\n    discount_factors = np.power(1 + y_per, -periods)\n\n    # Present value of cash flows\n    pv_cash_flows = cash_flows * discount_factors\n\n    # Price is the sum of PV of cash flows\n    price = np.sum(pv_cash_flows)\n\n    # For dollar duration, we need the sum of time-weighted PV of cash flows\n    # t_k = k/m\n    times = periods / m\n    weighted_pv_sum = np.sum(times * pv_cash_flows)\n\n    # Dollar Duration derived from first principles as -(dP/dy)\n    # dP/dy = - [1 / (1 + y/m)] * sum( t_k * PV(CF_k) )\n    # DD = -dP/dy = [1 / (1 + y/m)] * weighted_pv_sum\n    dollar_duration = weighted_pv_sum / (1 + y_per)\n\n    return price, dollar_duration\n\n\ndef solve():\n    \"\"\"\n    Solves the portfolio optimization problem for the given test cases.\n    \"\"\"\n    # Bond universe definition\n    # (c, y, T, n_bar, name)\n    bond_defs = [\n        (0.04, 0.05, 2, 50, 'A'),\n        (0.06, 0.04, 5, 30, 'B'),\n        (0.03, 0.05, 10, 40, 'C'),\n        (0.00, 0.04, 3, 10, 'D'),\n    ]\n\n    # Target dollar durations for each case\n    target_dds = [0, 500, 30000, 60000]\n\n    # Calculate properties for each bond\n    bonds = []\n    for c, y, T, n_bar, name in bond_defs:\n        price, dd = calculate_bond_properties(c, y, T)\n        if dd > 1e-9:  # Avoid division by zero for bonds with no duration\n            ratio = price / dd\n            bonds.append({\n                'name': name,\n                'price': price,\n                'dd': dd,\n                'n_bar': n_bar,\n                'ratio': ratio,\n            })\n\n    # Sort bonds by cost-effectiveness (price/dd ratio)\n    bonds.sort(key=lambda b: b['ratio'])\n\n    # Check for overall feasibility\n    total_available_dd = sum(b['dd'] * b['n_bar'] for b in bonds)\n\n    results = []\n    for dd_target in target_dds:\n        if dd_target <= 0:\n            results.append(0.0)\n            continue\n\n        if dd_target > total_available_dd:\n            results.append(-1.0)\n            continue\n\n        cost = 0.0\n        dd_to_go = dd_target\n\n        for bond in bonds:\n            if dd_to_go <= 1e-9: # Effectively zero\n                break\n\n            max_dd_from_bond = bond['dd'] * bond['n_bar']\n            dd_to_take = min(dd_to_go, max_dd_from_bond)\n            \n            # Cost to acquire this duration from this bond is dd_to_take * ratio\n            cost += dd_to_take * bond['ratio']\n            dd_to_go -= dd_to_take\n\n        results.append(round(cost, 4))\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}