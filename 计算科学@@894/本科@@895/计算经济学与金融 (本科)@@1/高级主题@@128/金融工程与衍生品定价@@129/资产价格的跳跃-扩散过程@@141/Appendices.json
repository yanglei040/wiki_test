{"hands_on_practices": [{"introduction": "在将跳跃-扩散模型应用于期权定价之前，我们首先需要推导出控制期权价格演变的数学方程。这个练习要求您运用针对跳跃-扩散过程的伊藤引理 (Itô's lemma) 和风险中性定价原理，为Merton模型下的欧式看涨期权价格推导其偏积分微分方程 (PIDE)。完成此推导不仅能加深您对模型数学结构的理解，还能揭示跳跃风险是如何在定价方程中通过一个积分项来体现的 [@problem_id:1282213]。", "id": "1282213", "problem": "一个量化分析团队正在为欧式看涨期权开发一个定价模型。他们认识到，标准的 Black-Scholes 模型假设资产价格连续变动，无法捕捉金融市场中观察到的突发性大幅价格冲击的风险。为了解决这个问题，他们决定使用 Merton 跳跃扩散过程来对标的资产价格 $S_t$ 进行建模。\n\n在风险中性概率测度下，资产价格动态由以下随机微分方程给出：\n$$\n\\frac{dS_t}{S_{t-}} = (r - \\lambda k) dt + \\sigma dW_t + (Y-1)dN_t\n$$\n其中：\n- $S_{t-}$ 是资产在时刻 $t$ 发生潜在跳跃前的价格。\n- $r$ 是恒定的无风险利率。\n- $\\sigma$ 是扩散部分的恒定波动率。\n- $W_t$ 是一个标准维纳过程。\n- $N_t$ 是一个强度为常数 $\\lambda > 0$ 的泊松过程，代表跳跃的到达。\n- $Y$ 是表示乘性跳跃大小的随机变量，即如果跳跃发生在时刻 $t$，价格将从 $S_{t-}$ 变动到 $S_t = Y S_{t-}$。跳跃大小相互独立，且与维纳过程无关。\n- 跳跃大小的自然对数 $\\ln(Y)$ 假设服从均值为 $\\mu_J$、方差为 $\\sigma_J^2$ 的正态分布。换言之，$\\ln(Y) \\sim N(\\mu_J, \\sigma_J^2)$。\n- $k$ 是预期的相对跳跃大小，定义为 $k = E[Y-1]$，其中期望是基于 $Y$ 的风险中性分布计算的。\n\n设 $C(S, t)$ 是该资产上的一份欧式看涨期权的价格，其执行价格为 $K$，到期时间为 $T$。您的任务是推导期权价格 $C(S, t)$ 在 $t < T$ 时必须满足的偏积分微分方程 (PIDE)。您的最终答案应该是完整的 PIDE，用 $C$ 及其偏导数、$S, t, r, \\sigma, \\lambda, \\mu_J$ 和 $\\sigma_J$ 来表示。", "solution": "在所述的风险中性动态下，\n$$\n\\frac{dS_{t}}{S_{t-}}=\\left(r-\\lambda k\\right)dt+\\sigma dW_{t}+(Y-1)dN_{t},\n$$\n其中 $k=E[Y-1]$，期权价格 $C(S,t)$ 是 $(S,t)$ 在 $t<T$ 时的函数。对 $f(S,t)=C(S,t)$ 应用跳跃扩散过程的 Itô 引理。对于一个包含扩散和复合泊松跳跃的过程，\n$$\ndC=C_{t}\\,dt+C_{S}\\,dS+\\frac{1}{2}C_{SS}\\,d[S^{c}]_{t}+\\left(C(S_{t-}+\\Delta S_{t},t)-C(S_{t-},t)-C_{S}(S_{t-},t)\\,\\Delta S_{t}\\right),\n$$\n其中 $d[S^{c}]_{t}=\\sigma^{2}S_{t}^{2}dt$ 是连续部分的二次变分，并且当跳跃发生时，$\\Delta S_{t}=S_{t}-S_{t-}=S_{t-}(Y-1)$。使用 $dS_{t}=S_{t-}\\left((r-\\lambda k)dt+\\sigma dW_{t}+(Y-1)dN_{t}\\right)$，我们得到\n$$\nC_{S}\\,dS_{t}=C_{S}\\left((r-\\lambda k)S\\,dt+\\sigma S\\,dW_{t}+S(Y-1)\\,dN_{t}\\right),\n$$\n并且跳跃修正项等于\n$$\n\\left(C(SY,t)-C(S,t)-C_{S}S(Y-1)\\right)dN_{t}.\n$$\n将这些项相加，线性跳跃项被抵消，因此跳跃的贡献变为\n$$\n\\left(C(SY,t)-C(S,t)\\right)dN_{t}.\n$$\n整理各项，\n$$\ndC=\\left(C_{t}+(r-\\lambda k)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}\\right)dt+\\sigma S C_{S}\\,dW_{t}+\\left(C(SY,t)-C(S,t)\\right)dN_{t}.\n$$\n\n在风险中性测度下，贴现后的期权价格是一个鞅。对于 $G(t)=\\exp(-rt)C(S_{t},t)$，\n$$\ndG=\\exp(-rt)\\left(dC-rC\\,dt\\right),\n$$\n因此其漂移项必须为零：\n$$\nC_{t}+(r-\\lambda k)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-rC+\\lambda\\,E\\!\\left[C(SY,t)-C(S,t)\\right]=0.\n$$\n因为 $\\ln(Y)\\sim N(\\mu_{J},\\sigma_{J}^{2})$，$Y$ 服从对数正态分布，其密度函数为\n$$\nf_{Y}(y)=\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right),\\quad y>0,\n$$\n且\n$$\nk=E[Y-1]=\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1.\n$$\n因此，期望可以写成积分形式，并且 $k$ 可以用 $\\mu_{J}$ 和 $\\sigma_{J}$ 表示，从而得到 PIDE (对于 $t<T$)：\n$$\nC_{t}+\\left(r-\\lambda\\left(\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1\\right)\\right)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-rC+\\lambda\\int_{0}^{\\infty}\\left[C(Sy,t)-C(S,t)\\right]\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right)dy=0.\n$$\n为完整起见，终端条件为 $C(S,T)=\\max(S-K,0)$，尽管它本身不是 PIDE 的一部分。", "answer": "$$\\boxed{C_{t}+\\left(r-\\lambda\\left(\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1\\right)\\right)S\\,C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-r\\,C+\\lambda\\int_{0}^{\\infty}\\left[C(Sy,t)-C(S,t)\\right]\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right)\\,dy=0}$$"}, {"introduction": "Merton模型的一个核心特征是它能生成比正态分布具有更厚尾部的收益率分布，从而更好地捕捉市场中的极端事件。这个练习将带您亲手实现Merton模型对数收益率的概率密度函数 (PDF) [@problem_id:2422076]。通过将一个由泊松概率加权的无限高斯混合级数转化为精确的数值计算，您将不仅掌握处理此类金融模型的关键编程技巧，还能直观地看到不同数量的跳跃如何共同塑造最终的收益率分布。", "id": "2422076", "problem": "考虑一个由 Merton 跳跃扩散模型描述的资产价格过程，其定义如下。设 $S_t$ 表示在时间 $t \\ge 0$ 的资产价格。在物理测度下，价格动态由以下随机微分方程（SDE）给出：\n$$\n\\frac{dS_t}{S_{t^-}} = \\mu \\, dt + \\sigma \\, dW_t + (J - 1) \\, dN_t,\n$$\n其中 $W_t$ 是一个标准布朗运动，$N_t$ 是一个强度为 $\\lambda > 0$ 且与 $W_t$ 独立的泊松过程，跳跃大小 $J$ 满足 $\\log J \\sim \\mathcal{N}(m, \\delta^2)$，其中 $\\delta \\ge 0$ 且 $m \\in \\mathbb{R}$。将期限 $T > 0$ 内的对数回报率定义为 $X_T = \\log(S_T/S_0)$。令 $\\kappa = \\mathbb{E}[J - 1] = \\exp\\!\\left(m + \\tfrac{1}{2}\\delta^2\\right) - 1$。\n\n从第一性原理出发，通过对区间 $[0,T]$ 内的跳跃次数进行条件化，可以得到 $X_T$ 的精确分布表示。设 $N_T \\sim \\text{Poisson}(\\lambda T)$。则\n$$\nX_T \\,\\big|\\, (N_T = n) \\sim \\mathcal{N}\\!\\left(\\left(\\mu - \\tfrac{1}{2}\\sigma^2 - \\lambda \\kappa\\right)T + n m,\\; \\sigma^2 T + n \\delta^2\\right),\n$$\n且无条件概率密度函数 $f_{X_T}(x)$ 是高斯密度的泊松加权无限混合：\n$$\nf_{X_T}(x) = \\sum_{n=0}^{\\infty} \\underbrace{e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}}_{\\text{Poisson weight}} \\cdot \\underbrace{\\frac{1}{\\sqrt{2\\pi(\\sigma^2 T + n\\delta^2)}} \\exp\\!\\left(-\\frac{\\left(x - \\left(\\mu - \\tfrac{1}{2}\\sigma^2 - \\lambda \\kappa\\right)T - n m\\right)^2}{2(\\sigma^2 T + n\\delta^2)}\\right)}_{\\text{Gaussian density at }x}.\n$$\n\n任务。对于下方的每一组参数，计算在指定的对数回报率点 $x$ 处的对数回报率密度 $f_{X_T}(x)$ 的值。您的程序输出的每个密度值的绝对误差不得超过 $10^{-10}$。所有量均为无量纲；将所有数值输出表示为浮点数。\n\n测试集。使用以下参数集，每组指定为 $(\\mu, \\sigma, \\lambda, m, \\delta, T; \\ \\text{网格 } \\{x\\})$：\n- 情况 A（一般跳跃扩散）：$(0.08, \\ 0.2, \\ 0.5, \\ -0.1, \\ 0.2, \\ 1.0; \\ \\{-0.2, \\ 0.0, \\ 0.2\\})$。\n- 情况 B（无跳跃边界，$\\lambda = 0$）：$(0.05, \\ 0.25, \\ 0.0, \\ 0.0, \\ 0.1, \\ 1.0; \\ \\{-0.2, \\ 0.0, \\ 0.2\\})$。\n- 情况 C（确定性跳跃大小，$\\delta = 0$）：$(0.06, \\ 0.15, \\ 1.2, \\ -0.05, \\ 0.0, \\ 0.5; \\ \\{-0.1, \\ 0.0, \\ 0.1\\})$。\n- 情况 D（短期限）：$(0.10, \\ 0.3, \\ 2.5, \\ -0.02, \\ 0.1, \\ 0.01; \\ \\{-0.02, \\ 0.0, \\ 0.02\\})$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是根据其网格排序的密度值内部列表。因此，最终输出必须是代表一个包含四个列表的列表的单行，按 A 到 D 的顺序排列，例如：\n\"[ [f_A(x1),f_A(x2),f_A(x3)], [f_B(x1),f_B(x2),f_B(x3)], [f_C(x1),f_C(x2),f_C(x3)], [f_D(x1),f_D(x2),f_D(x3)] ]\" 但其中不得包含任何空格，即 \"[[...],[...],[...],[...]]\"。", "solution": "该问题是有效的。这是一个在计算金融领域内提法恰当、有科学依据的问题，没有矛盾或含糊之处。任务是计算由 Merton 跳跃扩散模型控制的资产对数回报率的概率密度函数（PDF）的值。\n\n资产价格 $S_t$ 遵循以下随机微分方程：\n$$\n\\frac{dS_t}{S_{t^-}} = \\mu \\, dt + \\sigma \\, dW_t + (J - 1) \\, dN_t\n$$\n如问题所述，期限 $T$ 内的对数回报率（定义为 $X_T = \\log(S_T/S_0)$）的概率密度函数 $f_{X_T}(x)$ 由高斯密度的无限混合给出：\n$$\nf_{X_T}(x) = \\sum_{n=0}^{\\infty} \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)\n$$\n在此表达式中，$\\mathbb{P}(N_T=n) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}$ 是均值为 $\\lambda T$ 的泊松随机变量 $N_T$ 的概率质量函数，代表在区间 $[0, T]$ 内的跳跃次数。函数 $\\phi(x; \\mu_n, \\sigma_n^2)$ 是均值为 $\\mu_n$、方差为 $\\sigma_n^2$ 的正态分布的概率密度函数（PDF）。这个第 $n$ 个高斯分量的参数由以下公式给出：\n$$\n\\mu_n = \\left(\\mu - \\tfrac{1}{2}\\sigma^2 - \\lambda \\kappa\\right)T + n m\n$$\n$$\n\\sigma_n^2 = \\sigma^2 T + n \\delta^2\n$$\n其中跳跃补偿项 $\\kappa$ 定义为 $\\kappa = \\mathbb{E}[J - 1] = \\exp(m + \\tfrac{1}{2}\\delta^2) - 1$。\n\n核心任务是将这个无穷级数进行数值计算，达到 $10^{-10}$ 的绝对精度。由于该和不存在闭式解，我们必须采用数值近似方法，这涉及到截断级数。\n\n所实现的方法是对级数项 $T_n(x) = \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)$ 进行迭代求和。求和按 $n = 0, 1, 2, \\dots$ 进行，当后续项的贡献在数值上变得微不足道时终止。所有项 $T_n(x)$ 都是严格非负的。和的收敛速度很快，这是由泊松概率 $\\mathbb{P}(N_T=n)$ 随着 $n$ 增加而衰减所驱动的，特别是当 $n$ 的值大于均值 $\\lambda T$ 时。测试集中提供的参数值导致 $\\lambda T$ 的值很小（最多为 $0.6$），从而保证了非常快的收敛速度。\n\n对于每个参数集和评估点 $x$，算法流程如下：\n1.  首先，预先计算几个常数以优化计算循环：泊松均值 $\\Lambda = \\lambda T$、跳跃补偿项 $\\kappa$、条件均值的常数部分 $D = (\\mu - \\frac{1}{2}\\sigma^2 - \\lambda\\kappa)T$，以及条件方差的常数部分 $V = \\sigma^2 T$。\n2.  为了效率，$\\lambda = 0$（无跳跃）的特殊情况被单独处理。当 $\\lambda = 0$ 时，Merton 模型简化为几何布朗运动（GBM）模型。无穷和坍缩为其第一项（$n=0$），对数回报率密度变为单个高斯 PDF，即 $\\phi(x; (\\mu - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T)$。\n3.  对于 $\\lambda > 0$ 的一般情况，总密度 $f_{X_T}(x)$ 初始化为零，并迭代地对级数项求和。\n4.  循环遍历跳跃次数 $n=0, 1, 2, \\dots$：\n    a. 计算泊松概率 $\\mathbb{P}(N_T=n)$。为保持数值稳定性并避免计算大数的阶乘，此操作通过使用递推关系 $\\mathbb{P}(N_T=n) = \\mathbb{P}(N_T=n-1) \\cdot \\frac{\\Lambda}{n}$ 来完成，从基例 $\\mathbb{P}(N_T=0) = e^{-\\Lambda}$ 开始。\n    b. 计算第 $n$ 个高斯分量的均值 $\\mu_n = D + nm$ 和方差 $\\sigma_n^2 = V + n\\delta^2$。\n    c. 在点 $x$ 处评估相应高斯 PDF $\\phi(x; \\mu_n, \\sigma_n^2)$ 的值。这可以通过使用 SciPy 库中的 `scipy.stats.norm.pdf` 函数可靠地完成。\n    d. 计算级数的完整项 $T_n(x) = \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)$。\n    e. 如果计算出的项 $T_n(x)$ 低于 $10^{-16}$ 的绝对容差，则终止循环。该阈值远小于所要求的 $10^{-10}$ 的最终精度，确保级数的截断尾部不影响结果。为增加稳健性，此检查仅在 $n$ 超过泊松分布的众数（$n > \\Lambda$）后执行。\n    f. 如果未满足终止条件，则将项 $T_n(x)$ 加到 $f_{X_T}(x)$ 的运行总和中。\n5.  循环终止后，累积的和即为在 $x$ 处的最终密度值。\n\n此过程系统地应用于问题陈述中指定的所有参数集及其对应的评估网格。然后将得到的密度格式化为最终输出所需的嵌套列表结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, including test cases and output formatting.\n    \"\"\"\n\n    def compute_merton_pdf(params):\n        \"\"\"\n        Computes the Merton jump-diffusion model's log-return PDF for a given parameter set.\n        \"\"\"\n        mu, sigma, lam, m, delta, T, x_grid = params\n\n        # Handle the boundary case of no jumps (lambda=0), which is the Black-Scholes-Merton model.\n        if lam == 0.0:\n            drift = (mu - 0.5 * sigma**2) * T\n            variance = sigma**2 * T\n            \n            # The problem's constraints (sigma>0, T>0) ensure variance is positive.\n            std_dev = np.sqrt(variance)\n            return [norm.pdf(x, loc=drift, scale=std_dev) for x in x_grid]\n\n        # Pre-compute constants for the general jump-diffusion case (lambda > 0)\n        kappa = np.exp(m + 0.5 * delta**2) - 1\n        drift_base = (mu - 0.5 * sigma**2 - lam * kappa) * T\n        var_base = sigma**2 * T\n        lambda_T = lam * T\n\n        results = []\n        for x in x_grid:\n            total_pdf = 0.0\n            n = 0\n            \n            # Start with n=0 term: P(N_T=0) = exp(-lambda*T)\n            poisson_prob = np.exp(-lambda_T)\n\n            while True:\n                # Calculate mean and variance of the n-th Gaussian component\n                cond_mean = drift_base + n * m\n                cond_var = var_base + n * delta**2\n                \n                # The variance is always > 0 for test cases, so sqrt is safe\n                cond_std = np.sqrt(cond_var)\n\n                # Evaluate the density of the n-th Gaussian at point x\n                gaussian_pdf = norm.pdf(x, loc=cond_mean, scale=cond_std)\n                \n                # The term for this n in the infinite sum\n                term = poisson_prob * gaussian_pdf\n                \n                # Check for convergence. Stop when the term's contribution is negligible.\n                # An absolute tolerance on the term is sufficient here. 1e-16 is a safe\n                # margin for a required absolute error of 1e-10.\n                if term < 1e-16 and n > lambda_T:\n                    break\n                \n                total_pdf += term\n                \n                # Prepare for the next iteration\n                n += 1\n                # Update Poisson probability using the recurrence relation: P(k) = P(k-1) * lambda*T / k\n                poisson_prob = poisson_prob * lambda_T / n\n\n                # Safety break to prevent infinite loops with unusual parameters\n                if n > 300:\n                    break\n            \n            results.append(total_pdf)\n        \n        return results\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set: mu, sigma, lambda, m, delta, T, x_grid)\n        # Case A (general jump-diffusion)\n        (0.08, 0.2, 0.5, -0.1, 0.2, 1.0, [-0.2, 0.0, 0.2]),\n        # Case B (no jumps boundary, lambda = 0)\n        (0.05, 0.25, 0.0, 0.0, 0.1, 1.0, [-0.2, 0.0, 0.2]),\n        # Case C (deterministic jump size, delta = 0)\n        (0.06, 0.15, 1.2, -0.05, 0.0, 0.5, [-0.1, 0.0, 0.1]),\n        # Case D (short horizon)\n        (0.10, 0.3, 2.5, -0.02, 0.1, 0.01, [-0.02, 0.0, 0.02]),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        case_results = compute_merton_pdf(case_params)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    result_strings = []\n    for res_list in all_results:\n        # Convert each float in the inner list to its standard string representation.\n        inner_list_str = \"[\" + \",\".join(map(str, res_list)) + \"]\"\n        result_strings.append(inner_list_str)\n    \n    final_output = \"[\" + \",\".join(result_strings) + \"]\"\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "理论模型与市场现实之间的桥梁是校准——一个寻找能最佳拟合观测数据的模型参数的过程。在此实践中，您将扮演一位量化分析师，通过实施黄金分割搜索 (Golden-Section Search) 算法来校准Merton模型中的关键参数：跳跃强度 $\\lambda$ [@problem_id:2398577]。这个综合性练习不仅要求您实现期权定价公式，还要求您构建一个优化器，旨在最小化模型价格与市场价格之间的误差，从而将理论付诸于实际应用。", "id": "2398577", "problem": "编写一个完整、可运行的程序，该程序使用黄金分割搜索（Golden-Section Search, GSS）通过最小化模型价格与合成市场价格之间对价外欧式看涨期权的平方定价误差之和，来校准 Merton 跳跃扩散模型中的跳跃强度参数 $\\lambda$。您的程序必须从第一性原理实现定价模型和单变量优化器，且不得依赖任何外部优化器。\n\n基本原理：\n- 在风险中性测度下，执行价格为 $K$、到期日为 $T$ 的欧式看涨期权的价格由风险中性期望给出：$C = e^{-r T} \\mathbb{E}\\left[(S_T - K)^{+}\\right]$。\n- 在 Merton 跳跃扩散模型中，资产在风险中性测度下的动态过程为\n$$\n\\frac{dS_t}{S_{t^-}} = \\left(r - q - \\lambda k\\right)\\,dt + \\sigma\\, dW_t + (J - 1)\\, dN_t,\n$$\n其中 $r$ 是连续复利无风险利率， $q$ 是连续股息率，$\\sigma$ 是扩散波动率，$N_t$ 是强度为 $\\lambda$ 的泊松过程，$J$ 是跳跃幅度，且 $\\ln J \\sim \\mathcal{N}(\\mu_J,\\sigma_J^2)$。跳跃补偿项是 $k = \\mathbb{E}[J - 1] = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2} - 1$。\n- 以 $N_T = n$ 为条件可以得到对数正态分布的泊松混合形式，从而得出看涨期权价格的闭式混合表达式，即 Black–Scholes 项的加权和。\n\n需实现的定价模型：\n- 定义 $k = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2} - 1$，有效净漂移率 $b(\\lambda) = r - q - \\lambda k$，以及每次跳跃的缩放因子 $s_J = 1 + k = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2}$。\n- 对于每个非负整数 $n$，定义条件方差参数\n$$\n\\sigma_n = \\sqrt{\\sigma^2 + \\frac{n\\,\\sigma_J^2}{T}},\n$$\n和调整后的即期价格\n$$\nS_n = S_0\\, s_J^{\\,n}.\n$$\n- 泊松权重为\n$$\n\\pi_n(\\lambda) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}.\n$$\n- 具有有效净漂移率 $b(\\lambda)$ 的 Black–Scholes (BS) 看涨期权价格为\n$$\nC_{\\text{BS}}(S,K,r,q,\\sigma_n,T;b) = S\\,e^{-qT}\\,\\Phi(d_1) - K\\,e^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S}{K}\\right) + \\left(b + \\tfrac{1}{2}\\sigma_n^2\\right)T}{\\sigma_n \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma_n \\sqrt{T},\n$$\n而 $\\Phi(\\cdot)$ 是标准正态累积分布函数。\n- Merton 看涨期权价格为\n$$\nC_{\\text{Merton}}(\\lambda; S_0, K, r, q, \\sigma, \\mu_J, \\sigma_J, T) = \\sum_{n=0}^{\\infty} \\pi_n(\\lambda)\\, C_{\\text{BS}}(S_n, K, r, q, \\sigma_n, T; b(\\lambda)).\n$$\n- 对于数值实现，通过以下方式截断该无穷级数：\n  - 对 $n = 0,1,2,\\dots$ 进行求和，直到增量泊松权重 $\\pi_n(\\lambda)$ 低于 $10^{-12}$，或\n  - 达到硬性上限 $n_{\\max} = 50$，\n  以先发生者为准。\n\n校准目标：\n- 给定一组价外执行价格 $\\{K_i\\}_{i=1}^m$ 和相应的市场看涨期权价格 $\\{C^{\\text{mkt}}_i\\}_{i=1}^m$，定义目标函数\n$$\nJ(\\lambda) = \\sum_{i=1}^m \\left( C_{\\text{Merton}}(\\lambda; S_0, K_i, r, q, \\sigma, \\mu_J, \\sigma_J, T) - C^{\\text{mkt}}_i \\right)^2.\n$$\n- 使用黄金分割搜索在闭区间 $\\lambda \\in [0, 3]$ 上通过最小化 $J(\\lambda)$ 来校准 $\\lambda$。当区间长度小于 $10^{-6}$ 或达到 $200$ 次迭代后终止，以先到者为准。\n\n数值细节：\n- 使用 $\\Phi(x) = \\tfrac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\tfrac{x}{\\sqrt{2}}\\right)\\right)$。\n- 所有期权均为欧式看涨期权，测试套件中的所有执行价格均为严格价外：$K > S_0$。\n- 不得使用任何随机性；所有数值必须确定性地计算。\n\n测试套件：\n对于以下每个案例，首先通过使用指定的“真实”$\\lambda$ 和数值设置评估 Merton 价格来生成合成市场价格。然后，丢弃该真实值，并应用您的校准程序从合成市场价格中恢复 $\\widehat{\\lambda}$。\n\n- 案例 A (理想路径)：\n  - $S_0 = 100.0$, $r = 0.02$, $q = 0.0$, $T = 0.75$,\n  - $\\sigma = 0.20$, $\\mu_J = -0.10$, $\\sigma_J = 0.25$,\n  - 执行价格 $K \\in \\{105.0, 110.0, 120.0\\}$,\n  - 真实值 $\\lambda_{\\text{true}} = 0.60$。\n\n- 案例 B (边界情况，无跳跃)：\n  - $S_0 = 100.0$, $r = 0.01$, $q = 0.0$, $T = 1.00$,\n  - $\\sigma = 0.15$, $\\mu_J = -0.20$, $\\sigma_J = 0.30$,\n  - 执行价格 $K \\in \\{102.0, 110.0, 125.0\\}$,\n  - 真实值 $\\lambda_{\\text{true}} = 0.00$。\n\n- 案例 C (较高跳跃活动)：\n  - $S_0 = 100.0$, $r = 0.03$, $q = 0.0$, $T = 2.00$,\n  - $\\sigma = 0.18$, $\\mu_J = 0.05$, $\\sigma_J = 0.20$,\n  - 执行价格 $K \\in \\{105.0, 115.0, 130.0, 150.0\\}$,\n  - 真实值 $\\lambda_{\\text{true}} = 1.20$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个案例的校准后强度，形式为方括号括起来的逗号分隔列表，每个值按 A、B、C 的顺序四舍五入到六位小数。例如，输出必须类似于\n$$\n[\\widehat{\\lambda}_A,\\widehat{\\lambda}_B,\\widehat{\\lambda}_C],\n$$\n其中每个 $\\widehat{\\lambda}$ 都四舍五入到 $6$ 位小数（无单位）。", "solution": "该问题已经过严格验证，被认为是有效的。其表述在科学上基于 Merton 跳跃扩散模型，这是金融工程领域的标准模型。该问题是适定的，为确定性优化任务提供了一套完整且内部一致的定义、参数和数值程序。目标以数学精度陈述，没有歧义或主观内容。唯一解所需的所有组件均已提供。\n\n任务是校准 Merton 跳跃扩散模型的跳跃强度参数 $\\lambda$。这是通过最小化目标函数 $J(\\lambda)$ 来完成的，该函数表示由模型生成的期权价格与一组合成市场价格之间的平方差之和。优化被限制在区间 $\\lambda \\in [0, 3]$ 内，并且必须使用从第一性原理实现的黄金分割搜索（GSS）算法来执行。\n\n问题的核心涉及两个主要组件的实现：Merton 定价模型和 GSS 优化器。\n\n首先，我们按照规定实现欧式看涨期权的定价模型。Merton 价格 $C_{\\text{Merton}}$ 是在期权生命周期 $T$ 内发生 $n$ 次跳跃的条件下，Black-Scholes 类型期权价格的加权和。价格由下式给出：\n$$\nC_{\\text{Merton}}(\\lambda) = \\sum_{n=0}^{\\infty} \\pi_n(\\lambda)\\, C_{\\text{BS}}(S_n, K, r, q, \\sigma_n, T; b(\\lambda))\n$$\n表示 $n$ 次跳跃概率的泊松权重 $\\pi_n(\\lambda)$ 为：\n$$\n\\pi_n(\\lambda) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}\n$$\n条件 Black-Scholes 成分 $C_{\\text{BS}}$ 是为调整后的即期价格 $S_n = S_0\\, s_J^{\\,n}$ 和条件波动率 $\\sigma_n = \\sqrt{\\sigma^2 + n\\,\\sigma_J^2/T}$ 定义的。每次跳跃的缩放因子为 $s_J = e^{\\mu_J + \\frac{1}{2}\\sigma_J^2}$。该成分价格由下式给出：\n$$\nC_{\\text{BS}} = S_n\\,e^{-qT}\\,\\Phi(d_1) - K\\,e^{-rT}\\,\\Phi(d_2)\n$$\n其参数 $d_1$ 和 $d_2$ 依赖于有效净漂移率 $b(\\lambda) = r - q - \\lambda k$，其中 $k = s_J - 1$。$d_1$ 的具体公式为：\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S_n}{K}\\right) + \\left(b(\\lambda) + \\tfrac{1}{2}\\sigma_n^2\\right)T}{\\sigma_n \\sqrt{T}}\n$$\n且 $d_2 = d_1 - \\sigma_n \\sqrt{T}$。标准正态累积分布函数 $\\Phi(\\cdot)$ 使用误差函数 $\\operatorname{erf}(\\cdot)$ 计算，即 $\\Phi(x) = \\frac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\frac{x}{\\sqrt{2}}\\right)\\right)$。对于数值实现，无穷级数被截断。求和过程从 $n=0, 1, 2, \\dots$ 开始，当项的泊松权重 $\\pi_n(\\lambda)$ 低于 $10^{-12}$ 的容差时，或当已包含最多 $n_{\\max}=50$ 个项时终止，以先发生者为准。使用一种稳健的迭代方法$\\pi_n(\\lambda) = \\pi_{n-1}(\\lambda) \\cdot \\frac{\\lambda T}{n}$来计算泊松权重，以避免大阶乘导致的数值溢出。\n\n其次，我们将校准目标函数 $J(\\lambda)$ 定义为在一组具有不同执行价格 $\\{K_i\\}_{i=1}^m$ 的 $m$ 个期权上的平方误差和（SSE）：\n$$\nJ(\\lambda) = \\sum_{i=1}^m \\left( C_{\\text{Merton}}(\\lambda; K_i) - C^{\\text{mkt}}_i \\right)^2\n$$\n其中 $C^{\\text{mkt}}_i$ 是给定的合成市场价格。\n\n第三，我们实现黄金分割搜索（GSS）算法来最小化 $J(\\lambda)$。GSS 是一种无导数优化方法，用于通过迭代地缩小搜索区间来寻找单峰函数的极值。搜索从区间 $[a, b] = [0, 3]$ 开始。选择两个内部点 $c$ 和 $d$ 以根据黄金比例 $\\phi = (1+\\sqrt{5})/2 \\approx 1.618$ 分割区间。\n$$\nc = b - \\frac{b-a}{\\phi} \\quad \\text{和} \\quad d = a + \\frac{b-a}{\\phi}\n$$\n在这些点上评估目标函数。如果 $J(c) < J(d)$，则最小值必定位于区间 $[a, d]$ 中，因此新的搜索区间变为 $[a, d]$。否则，如果 $J(c) \\ge J(d)$，新的区间变为 $[c, b]$。此过程在每一步都将区间长度减少 $1/\\phi$ 的因子，保证了收敛性。当区间长度 $|b-a|$ 小于 $10^{-6}$ 的容差或在最多 $200$ 次迭代后，算法终止。最终区间的中点 $(a+b)/2$ 作为校准估计值 $\\widehat{\\lambda}$ 返回。\n\n整个过程包括：首先，通过在给定的“真实”强度 $\\lambda_{\\text{true}}$ 下评估指定的 $C_{\\text{Merton}}$ 函数，为每个测试案例生成合成市场价格 $C^{\\text{mkt}}_i$。然后，这个真实值在概念上被丢弃，并使用 GSS 算法通过最小化 $J(\\lambda)$ 来找到最能重现这些合成价格的 $\\widehat{\\lambda}$。对所有指定的测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\n# Define a global constant for the Golden Ratio.\nGR = (1 + np.sqrt(5)) / 2\n\ndef norm_cdf(x):\n    \"\"\"\n    Computes the standard normal cumulative distribution function using the error function.\n    All mathematical entities must be in LaTeX: Phi(x) = 1/2 * (1 + erf(x/sqrt(2))).\n    \"\"\"\n    return 0.5 * (1 + erf(x / np.sqrt(2)))\n\ndef merton_bs_component(S, K, r, q, T, sigma_n, b):\n    \"\"\"\n    Computes a single Black-Scholes-like component of the Merton price series,\n    using the specific functional form provided in the problem statement.\n    \"\"\"\n    if sigma_n <= 0 or T <= 0:\n        return np.maximum(0, S - K) if S > K else 0.0\n\n    d1 = (np.log(S / K) + (b + 0.5 * sigma_n**2) * T) / (sigma_n * np.sqrt(T))\n    d2 = d1 - sigma_n * np.sqrt(T)\n    price = S * np.exp(-q * T) * norm_cdf(d1) - K * np.exp(-r * T) * norm_cdf(d2)\n    return price\n\ndef merton_price(lambda_val, S0, K, r, q, T, sigma, mu_J, sigma_J):\n    \"\"\"\n    Calculates the Merton jump-diffusion model call option price. The infinite sum\n    is truncated based on the Poisson weight or a maximum number of terms.\n    \"\"\"\n    # Jump-related parameters, constant with respect to lambda\n    k = np.exp(mu_J + 0.5 * sigma_J**2) - 1\n    s_J = 1 + k\n    \n    # Lambda-dependent effective drift\n    b = r - q - lambda_val * k\n    \n    total_price = 0.0\n    lambda_T = lambda_val * T\n    \n    n_max = 50\n    weight_tol = 1e-12\n\n    # Term for n=0 jumps (pure diffusion component)\n    poisson_weight = np.exp(-lambda_T)\n    sigma_0 = sigma\n    component_price_0 = merton_bs_component(S0, K, r, q, T, sigma_0, b)\n    total_price += poisson_weight * component_price_0\n    \n    # Terms for n=1 to n_max jumps\n    for n in range(1, n_max + 1):\n        poisson_weight *= lambda_T / n\n        if poisson_weight < weight_tol:\n            break\n        \n        sigma_n = np.sqrt(sigma**2 + n * sigma_J**2 / T)\n        S_n = S0 * (s_J**n)\n        \n        component_price = merton_bs_component(S_n, K, r, q, T, sigma_n, b)\n        total_price += poisson_weight * component_price\n        \n    return total_price\n\ndef objective_function(lambda_val, S0, r, q, T, sigma, mu_J, sigma_J, strikes, market_prices):\n    \"\"\"\n    Calculates the sum of squared errors (SSE) between model prices and market prices.\n    This is the function to be minimized.\n    \"\"\"\n    sse = 0.0\n    for i in range(len(strikes)):\n        model_price = merton_price(lambda_val, S0, strikes[i], r, q, T, sigma, mu_J, sigma_J)\n        sse += (model_price - market_prices[i])**2\n    return sse\n\ndef golden_section_search(f, a, b, tol=1e-6, max_iter=200):\n    \"\"\"\n    Performs Golden-Section Search to find the minimum of a univariate function 'f'\n    on the interval [a, b].\n    \"\"\"\n    inv_phi = 1 / GR\n    \n    # Initialize interior points\n    c = b - inv_phi * (b - a)\n    d = a + inv_phi * (b - a)\n    \n    fc = f(c)\n    fd = f(d)\n    \n    for _ in range(max_iter):\n        if abs(b - a) < tol:\n            break\n            \n        if fc < fd:\n            b = d\n            d = c\n            fd = fc\n            c = b - inv_phi * (b - a)\n            fc = f(c)\n        else:\n            a = c\n            c = d\n            fc = fd\n            d = a + inv_phi * (b - a)\n            fd = f(d)\n            \n    return (a + b) / 2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite, calibrate lambda for each case, and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path\n        {'S0': 100.0, 'r': 0.02, 'q': 0.0, 'T': 0.75, 'sigma': 0.20,\n         'mu_J': -0.10, 'sigma_J': 0.25, 'strikes': [105.0, 110.0, 120.0],\n         'lambda_true': 0.60},\n        # Case B: Boundary case, no jumps\n        {'S0': 100.0, 'r': 0.01, 'q': 0.0, 'T': 1.00, 'sigma': 0.15,\n         'mu_J': -0.20, 'sigma_J': 0.30, 'strikes': [102.0, 110.0, 125.0],\n         'lambda_true': 0.00},\n        # Case C: Higher jump activity\n        {'S0': 100.0, 'r': 0.03, 'q': 0.0, 'T': 2.00, 'sigma': 0.18,\n         'mu_J': 0.05, 'sigma_J': 0.20, 'strikes': [105.0, 115.0, 130.0, 150.0],\n         'lambda_true': 1.20}\n    ]\n    \n    calibrated_lambdas = []\n    \n    for case in test_cases:\n        # 1. Generate synthetic market prices using the true lambda\n        market_prices = [\n            merton_price(case['lambda_true'], case['S0'], K, case['r'], case['q'], case['T'],\n                         case['sigma'], case['mu_J'], case['sigma_J'])\n            for K in case['strikes']\n        ]\n\n        # 2. Define objective function for this case, capturing all parameters except lambda\n        obj_func = lambda l: objective_function(\n            l, case['S0'], case['r'], case['q'], case['T'], case['sigma'],\n            case['mu_J'], case['sigma_J'], case['strikes'], market_prices\n        )\n\n        # 3. Run Golden-Section Search to find the calibrated lambda\n        lambda_hat = golden_section_search(obj_func, a=0.0, b=3.0, tol=1e-6, max_iter=200)\n        calibrated_lambdas.append(lambda_hat)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{l:.6f}' for l in calibrated_lambdas])}]\")\n\nsolve()\n```"}]}