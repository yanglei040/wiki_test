{"hands_on_practices": [{"introduction": "Heston模型的核心优势之一在于它能够捕捉真实世界资产回报中普遍存在的“肥尾”（即高尖峰）现象，这是Black-Scholes模型无法做到的。本次动手实践将引导你通过编程来直接验证这一关键特性。你将学习如何从模型中模拟数据，并应用正式的统计检验来量化其超额峰度，从而将随机波动率这一抽象概念与可观测的统计特征紧密联系起来 [@problem_id:2441188]。", "id": "2441188", "problem": "要求您設計並實現一個完整的、可運行的程式，用以檢驗一個關於由 Heston 隨機波動率模型生成的對數回報率尾部厚度的統計假設。出發點是描述風險資產價格過程 $\\{S_t\\}_{t \\ge 0}$ 及其瞬時方差過程 $\\{v_t\\}_{t \\ge 0}$ 的 Heston 隨機微分方程組：\n$$\ndS_t = \\mu S_t \\, dt + \\sqrt{v_t}\\, S_t \\, dW_t^{(1)}, \\qquad\ndv_t = \\kappa(\\theta - v_t)\\, dt + \\sigma \\sqrt{v_t}\\, dW_t^{(2)},\n$$\n其中瞬時相關性為 $\\mathrm{corr}(dW_t^{(1)}, dW_t^{(2)}) = \\rho$。在本問題中，將漂移項設為 $\\mu = 0$，以分離出尾部行為，避免漂移項的干擾。考慮長度為 $\\Delta t > 0$ 的單一時間步長，並將單步對數回報率定義為 $r = \\log(S_{t+\\Delta t}/S_t)$。對於較小的 $\\Delta t$，使用由伊藤微積分推導出的主階離散化方法，即在給定 $v_t$ 的條件下，對數回報率 $r$ 近似服從正態分佈：\n$$\nr \\mid v_t \\sim \\mathcal{N}\\!\\left(-\\tfrac{1}{2} v_t \\Delta t,\\; v_t \\Delta t\\right).\n$$\n\n您的模擬必須通過從驅動 $v_t$ 的 Cox–Ingersoll–Ross (CIR) 過程的平穩分佈中抽樣瞬時方差 $v$，來生成一個由單步對數回報率組成的獨立同分佈樣本 $\\{r_i\\}_{i=1}^n$。一個經過充分檢驗且廣泛使用的結論是，當 $\\kappa > 0$ 時，$v_t$ 的平穩分佈為 Gamma 分佈，其形狀參數為 $k = \\frac{2\\kappa\\theta}{\\sigma^2}$，尺度參數為 $b = \\frac{\\sigma^2}{2\\kappa}$，這使得 $\\mathbb{E}[v] = k b = \\theta$。在 $\\sigma = 0$ 的特殊情況下，將 $v$ 視為在 $v = \\theta$ 處的退化分佈（即恆定方差）。您可以假設 $\\rho$ 不影響在給定 $v$ 的條件下 $r$ 的單步邊際分佈，因此在此設定下 $\\rho$ 不會進入 $r$ 的抽樣方案。\n\n建立並實現一個顯著性水平為 $\\alpha = 0.05$ 的單邊假設檢驗，以評估模擬出的對數回報率分佈是否比具有相同方差的正態分佈表現出更高的峰度（即厚尾）。使用以下基於經典漸近理論的原則性檢驗：在原假設（即 $r$ 服從正態分佈，且其方差等於樣本 $\\{r_i\\}_{i=1}^n$ 的樣本方差）下，樣本超額峰度\n$$\ng_2 = \\frac{m_4}{m_2^2} - 3, \\quad m_j = \\frac{1}{n}\\sum_{i=1}^n (r_i - \\bar{r})^j,\\quad \\bar{r} = \\frac{1}{n}\\sum_{i=1}^n r_i,\n$$\n對於大的樣本量 $n$，其漸近標準差為 $\\sqrt{\\frac{24}{n}}$。構建 z-統計量\n$$\nz = \\frac{g_2 - 0}{\\sqrt{24/n}},\n$$\n如果 $z > z_{1-\\alpha}$，則拒絕原假設，接受備擇假設（即具有更高峰度）。其中 $z_{1-\\alpha}$ 是標準正態分佈的 $(1-\\alpha)$-分位數。\n\n按照上述描述實現模擬和檢驗，使用平穩 Gamma 分佈抽樣方案獲取 $v$，並在給定 $v$ 的條件下使用條件正態分佈抽樣方案獲取 $r$。為確保不同測試案例之間的可複現性和獨立性，請為每個案例單獨設定隨機數生成器的種子。\n\n使用以下包含四組參數的測試套件，每組參數以元組 $(\\text{種子}, \\kappa, \\theta, \\sigma, \\Delta t, n)$ 的形式指定：\n- 案例 A（恆定方差的邊界情況）：$(12345, 2.0, 0.04, 0.0, 1.0, 200000)$。\n- 案例 B（高「波動率的波動率」；預期出現厚尾）：$(12346, 2.0, 0.04, 1.0, 1.0, 200000)$。\n- 案例 C（中等「波動率的波動率」但樣本量小；低功效的邊緣案例）：$(12347, 1.5, 0.04, 0.5, 1.0, 2000)$。\n- 案例 D（快速均值回歸且低「波動率的波動率」；更接近正態分佈）：$(12348, 5.0, 0.04, 0.1, 1.0, 50000)$。\n\n對於每種情況，您的程式必須輸出一個布林值，表示是否在 $\\alpha = 0.05$ 的水平上使用上述檢驗拒絕了原假設。最終輸出必須是一行，包含按順序排列的四個案例的布林值列表，其格式必須與 Python 風格的逗號分隔列表完全一致，例如：「[True,False,True,False]」。\n\n不涉及任何物理單位或角度。所有數值概率均以小數表示，而非百分比。為保證可複現性，每個案例的隨機數生成器種子必須精確設定為所提供的整數值。不要讀取任何輸入；所有參數均按上述方式硬編碼。", "solution": "該問題要求設計並實現一個統計檢驗，用以判斷在 Heston 隨機波動率模型下生成的對數回報率分佈是否比高斯分佈表現出更厚的尾部（尖峰態）。此任務的完成方式是：首先根據模型指定的動態特性模擬數據，然後應用一個有漸近理論支持的超額峰度假設檢驗。\n\n其理論框架是 Heston 模型，由一個描述資產價格 $S_t$ 及其瞬時方差 $v_t$ 的雙變量隨機微分方程組構成：\n$$\ndS_t = \\mu S_t \\, dt + \\sqrt{v_t}\\, S_t \\, dW_t^{(1)}\n$$\n$$\ndv_t = \\kappa(\\theta - v_t)\\, dt + \\sigma \\sqrt{v_t}\\, dW_t^{(2)}\n$$\n此處，$W_t^{(1)}$ 和 $W_t^{(2)}$ 是瞬時相關性為 $\\rho$ 的維納過程。為解決此問題，資產價格的漂移參數設為 $\\mu = 0$，以便分離出隨機波動率對回報率分佈形狀的影響。我們考慮在長度為 $\\Delta t$ 的時間範圍內的單步對數回報率，定義為 $r = \\log(S_{t+\\Delta t}/S_t)$。利用從伊藤引理推導出的一階近似，給定區間開始時的方差 $v_t$，對數回報率的條件分佈為正態分佈：\n$$\nr \\mid v_t \\sim \\mathcal{N}\\!\\left(-\\tfrac{1}{2} v_t \\Delta t,\\; v_t \\Delta t\\right)\n$$\n模擬過程生成一個獨立同分佈 (i.i.d.) 的樣本 $\\{r_i\\}_{i=1}^n$。這通過以下步驟實現：首先，從控制 $v_t$ 的 Cox–Ingersoll–Ross (CIR) 過程的平穩分佈中抽樣方差 $v_i$。對於參數 $\\kappa > 0$ 和 $\\theta > 0$，此平穩分佈為一個 Gamma 分佈。其形狀參數為 $k = \\frac{2\\kappa\\theta}{\\sigma^2}$，尺度參數為 $b = \\frac{\\sigma^2}{2\\kappa}$。該分佈的均值為 $\\mathbb{E}[v] = k b = \\theta$。定義了一個特殊情況，即 $\\sigma = 0$，此時方差過程是確定性的，因此 $v$ 是一個等於其均值 $\\theta$ 的常數。對於每個模擬出的方差 $v_i$，都從上述指定的條件正態分佈中抽取一個對應的對數回報率 $r_i$。正是這個兩步生成過程——先從一個混合分佈中抽樣方差，隨後再從一個條件正態分佈中抽樣——導致了 $r$ 的邊際分佈中出現了非正態特徵，特別是尖峰態。\n\n該假設檢驗旨在統計上檢測這種尖峰態。原假設 $H_0$ 是對數回報率樣本 $\\{r_i\\}_{i=1}^n$ 來自一個正態分佈。備擇假設 $H_1$ 是該分佈比正態分佈具有更高的峰度（即呈現尖峰態，或稱「厚尾」）。檢驗在 $\\alpha = 0.05$ 的顯著性水平下進行。檢驗統計量基於樣本超額峰度 $g_2$，其定義為：\n$$\ng_2 = \\frac{m_4}{m_2^2} - 3\n$$\n其中 $m_j$ 是 $j$ 階樣本中心矩，$m_j = \\frac{1}{n}\\sum_{i=1}^n (r_i - \\bar{r})^j$，而 $\\bar{r}$ 是樣本均值。對於一個真正的正態分佈，其總體超額峰度為 $0$。在正態性的原假設下，對於大樣本量 $n$，$g_2$ 的抽樣分佈漸近服從均值為 $0$、標準差為 $\\sqrt{24/n}$ 的正態分佈。這一性質使得我們可以構建一個標準化的 z-統計量：\n$$\nz = \\frac{g_2 - 0}{\\sqrt{24/n}}\n$$\n對於一個旨在檢驗正超額峰度的單邊檢驗，如果觀測到的 z-統計量大於臨界值 $z_{1-\\alpha}$，我們就拒絕原假設 $H_0$。其中 $z_{1-\\alpha}$ 是標準正態分佈的 $(1-\\alpha)$-分位數。當 $\\alpha = 0.05$ 時，臨界值為 $z_{0.95} \\approx 1.64485$。\n\n實現過程將為四個指定的測試案例分別生成樣本。對於每個案例，都使用提供的種子值初始化隨機數生成器以確保可複現性。參數 $(\\kappa, \\theta, \\sigma, \\Delta t, n)$ 決定了模擬的具體細節。對於 $\\sigma=0$ 的特殊情況，將方差設定為常數值 $\\theta$。對於 $\\sigma > 0$ 的情況，方差從相應的 Gamma 分佈中抽取。隨後，生成對數回報率，計算 z-統計量，並通過將該統計量與 $z_{0.95}$ 進行比較來決定是否拒絕 $H_0$。每個案例的布林決策結果將被記錄並按規定格式報告。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef run_heston_kurtosis_test(seed, kappa, theta, sigma, delta_t, n):\n    \"\"\"\n    Simulates Heston model log-returns and tests for excess kurtosis.\n\n    Args:\n        seed (int): The seed for the random number generator.\n        kappa (float): The rate of mean reversion for the variance process.\n        theta (float): The long-run mean of the variance process.\n        sigma (float): The volatility of the variance process.\n        delta_t (float): The time step for the log-return.\n        n (int): The number of samples to generate.\n\n    Returns:\n        bool: True if the null hypothesis of normality is rejected in favor of\n              higher kurtosis, False otherwise.\n    \"\"\"\n    # Initialize a random number generator with the given seed for reproducibility.\n    # Using PCG64 is the modern, recommended practice.\n    rng = np.random.Generator(np.random.PCG64(seed))\n\n    # Step 1: Generate the variance sample {v_i}.\n    if sigma == 0.0:\n        # Special degenerate case: variance is constant at its mean theta.\n        # This corresponds to the Black-Scholes-Merton model where returns are normal.\n        v_sample = np.full(n, theta)\n    else:\n        # In the stationary state, variance v follows a Gamma distribution.\n        # Shape parameter k = 2*kappa*theta / sigma^2\n        # Scale parameter b = sigma^2 / (2*kappa)\n        shape_k = 2 * kappa * theta / (sigma**2)\n        scale_b = (sigma**2) / (2 * kappa)\n        v_sample = rng.gamma(shape_k, scale=scale_b, size=n)\n\n    # Step 2: Generate the log-return sample {r_i}.\n    # The conditional distribution r | v is Normal.\n    # Mean = -0.5 * v * delta_t\n    # Standard deviation = sqrt(v * delta_t)\n    means = -0.5 * v_sample * delta_t\n    # Ensure standard deviation is non-negative, though v_sample from Gamma should be.\n    std_devs = np.sqrt(v_sample * delta_t)\n    r_sample = rng.normal(loc=means, scale=std_devs)\n\n    # Step 3: Perform the hypothesis test for excess kurtosis.\n    # Calculate sample mean.\n    r_bar = np.mean(r_sample)\n    \n    # Calculate 2nd and 4th central moments.\n    m2 = np.mean((r_sample - r_bar)**2)\n    m4 = np.mean((r_sample - r_bar)**4)\n\n    # Avoid division by zero if sample variance is zero (highly improbable).\n    if m2 == 0.0:\n        return False\n\n    # Calculate sample excess kurtosis (g2).\n    g2 = m4 / (m2**2) - 3.0\n\n    # Calculate the z-statistic for the one-sided test.\n    # Under H0 (normality), the standard error of g2 is sqrt(24/n).\n    z_stat = g2 / np.sqrt(24.0 / n)\n\n    # Define significance level and find the critical value.\n    alpha = 0.05\n    # For a one-sided test (H1: kurtosis > 0), we use the (1-alpha) quantile.\n    z_critical = norm.ppf(1 - alpha)\n\n    # Make the decision: reject H0 if z_stat exceeds the critical value.\n    reject_h0 = z_stat > z_critical\n    \n    return reject_h0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Format: (seed, kappa, theta, sigma, delta_t, n)\n    test_cases = [\n        (12345, 2.0, 0.04, 0.0, 1.0, 200000),   # Case A\n        (12346, 2.0, 0.04, 1.0, 1.0, 200000),   # Case B\n        (12347, 1.5, 0.04, 0.5, 1.0, 2000),     # Case C\n        (12348, 5.0, 0.04, 0.1, 1.0, 50000),    # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for each test case\n        seed, kappa, theta, sigma, delta_t, n = case\n        # Run the test and store the boolean result\n        result = run_heston_kurtosis_test(seed, kappa, theta, sigma, delta_t, n)\n        results.append(result)\n\n    # Print the final list of results in the specified format.\n    # The str() of a boolean is 'True' or 'False' (capitalized), which is the standard format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"}, {"introduction": "在理解了方差过程的基础上，我们现在转向为一种其收益直接与已实现波动率挂钩的金融衍生品定价。这项练习巧妙地融合了分析推导与编程计算，要求你首先推导出方差过程的期望路径，然后利用该结果为一份方差互换（variance swap）定价。通过这个过程，你将清晰地看到Heston模型的参数，特别是均值回归动态 $kappa$ 和长期均值 $theta$，如何直接影响波动率衍生品的价值 [@problem_id:2441205]。", "id": "2441205", "problem": "您需要推导并计算一个固定执行价格的方差互换的现值，其标的资产价格在风险中性测度下遵循 Heston 动态模型。Heston 模型由以下随机微分方程组定义\n$dS_t = S_t \\left( r \\, dt + \\sqrt{v_t} \\, dW_t^{S} \\right)$ 和 $dv_t = \\kappa \\left( \\theta - v_t \\right) dt + \\sigma \\sqrt{v_t} \\, dW_t^{v}$，且 $\\mathrm{corr}(dW_t^{S}, dW_t^{v}) = \\rho$，其中 $S_t$ 是资产价格，$v_t$ 是瞬时方差，$r$ 是连续复利无风险利率，$\\kappa$ 是方差的均值回归速度，$\\theta$ 是长期方差，$\\sigma$ 是方差的波动率（也称为 vol-of-vol），$\\rho$ 是布朗运动之间的相关性。方差过程 $v_t$ 是一个 Cox–Ingersoll–Ross (CIR) 平方根过程。\n\n一个到期日为 $T$ 的方差互换在时间 $T$ 的支付等于 $N_{\\mathrm{var}} \\left( K_{\\mathrm{realized}} - K_{\\mathrm{fixed}} \\right)$，其中 $N_{\\mathrm{var}}$ 是以方差率单位计的方差名义本金，$K_{\\mathrm{fixed}}$ 是以方差率单位计的固定执行价格，而年化已实现方差为 $K_{\\mathrm{realized}} = \\dfrac{1}{T} \\int_{0}^{T} v_t \\, dt$。您必须计算此支付的现值（时间 $0$），该现值以与 $N_{\\mathrm{var}}$ 相同的货币计量，并假设所有利率均为连续复利且以小数（而非百分比）表示。\n\n您的推导必须从以下基本原理出发：\n- 风险中性定价原理：现值等于支付的贴现风险中性期望，即 $e^{-r T} \\, \\mathbb{E}^{\\mathbb{Q}}\\left[ \\cdot \\right]$。\n- 对于无跳跃的连续半鞅模型，年化已实现方差等于瞬时方差的时间平均值，即 $K_{\\mathrm{realized}} = \\dfrac{1}{T} \\int_{0}^{T} v_t \\, dt$。\n- Cox–Ingersoll–Ross (CIR) 平方根扩散的期望满足一个一阶线性常微分方程，该方程通过对其漂移项取期望得到，并且标准的解的存在性和唯一性结果适用。不要假设此常微分方程解的任何闭式表达式；请基于此原理推导出期望方差路径。\n\n任务：\n1) 从上述定义出发，推导公平方差互换利率 $K_{\\mathrm{fair}} = \\mathbb{E}^{\\mathbb{Q}} \\left[ K_{\\mathrm{realized}} \\right]$ 关于模型参数 $v_0$、$\\kappa$ 和 $\\theta$ 的表达式。请谨慎处理 $\\kappa \\to 0$ 时的边界行为。\n2) 使用风险中性定价原理，将固定执行价格方差互换支付在时间 $0$ 的现值表示为 $K_{\\mathrm{fair}}$、$K_{\\mathrm{fixed}}$、$N_{\\mathrm{var}}$、$r$ 和 $T$ 的函数。\n3) 实现一个程序，为以下测试套件中的每组参数计算现值。在所有计算中，利率必须视为小数（例如，年化方差水平为 $4$％ 时使用 $0.04$），到期时间 $T$ 以年为单位。最终程序输出必须是本问题陈述末尾描述格式的单行字符串。\n4) 当 $|\\kappa|$ 非常小时，通过使用洛必达法则得到的经解析证明的极限表达式来确保数值稳定性。\n\n测试套件：\n为以下四组参数集分别提供现值。每个元组按 $(\\kappa, \\theta, \\sigma, \\rho, v_0, r, T, N_{\\mathrm{var}}, K_{\\mathrm{fixed}})$ 的顺序排列。\n\n- 情况 A（一般“顺利”路径）：$(2.0, 0.04, 0.6, -0.7, 0.04, 0.01, 1.0, 1.0, 0.05)$\n- 情况 B（接近非均值回归边界）：$(0.00000001, 0.09, 0.3, 0.2, 0.16, 0.0, 0.25, 1.0, 0.15)$\n- 情况 C（长期限下由长期方差主导）：$(3.0, 0.09, 0.5, -0.9, 0.04, 0.02, 5.0, 1.0, 0.08)$\n- 情况 D（中度均值回归且名义本金非单位值）：$(0.5, 0.06, 1.0, 0.5, 0.10, 0.0, 2.0, 2.0, 0.08)$\n\n答案要求：\n- 所有利率均以小数表示，不带百分号。\n- 本问题不涉及物理单位或角度。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_i$ 是按 A、B、C、D 顺序对应的测试用例的现值。", "solution": "问题陈述具有科学依据、形式适定，并包含了获得唯一解所需的所有信息。这是量化金融中的一个标准问题，基于 Heston 随机波动率模型和风险中性定价原理。因此，该问题被认为是**有效的**。\n\n目标是计算固定执行价格方差互换的现值。这需要两个主要步骤：首先，推导公平方差互换利率 $K_{\\mathrm{fair}}$；其次，利用该利率求出互换支付的现值。\n\n**1. 期望方差路径的推导**\n\nHeston 模型将风险中性测度 $\\mathbb{Q}$ 下的瞬时方差 $v_t$ 的动态过程指定为 Cox-Ingersoll-Ross (CIR) 过程：\n$$dv_t = \\kappa (\\theta - v_t) dt + \\sigma \\sqrt{v_t} dW_t^v$$\n其中 $\\kappa$ 是均值回归速度，$\\theta$ 是长期均值方差，$\\sigma$ 是方差的波动率。令 $\\bar{v}(t) = \\mathbb{E}^{\\mathbb{Q}}[v_t]$ 为时间 $t$ 时方差的期望值。通过对随机微分方程（SDE）取期望，我们可以推导出关于 $\\bar{v}(t)$ 的常微分方程（ODE）。随机项的期望为零，即 $\\mathbb{E}^{\\mathbb{Q}}[\\sigma \\sqrt{v_t} dW_t^v] = 0$。由此可得：\n$$d\\mathbb{E}^{\\mathbb{Q}}[v_t] = \\mathbb{E}^{\\mathbb{Q}}[\\kappa (\\theta - v_t)] dt$$\n利用期望算子的线性性质，我们得到：\n$$\\frac{d\\bar{v}(t)}{dt} = \\kappa (\\theta - \\bar{v}(t))$$\n这是一个一阶线性常微分方程，初始条件为 $\\bar{v}(0) = v_0$。我们可以将其改写为：\n$$\\frac{d\\bar{v}(t)}{dt} + \\kappa \\bar{v}(t) = \\kappa \\theta$$\n使用积分因子 $I(t) = e^{\\int \\kappa dt} = e^{\\kappa t}$ 可求得其解。将该常微分方程两边同乘以 $I(t)$ 得：\n$$e^{\\kappa t} \\frac{d\\bar{v}(t)}{dt} + \\kappa e^{\\kappa t} \\bar{v}(t) = \\kappa \\theta e^{\\kappa t}$$\n$$\\frac{d}{dt} \\left( e^{\\kappa t} \\bar{v}(t) \\right) = \\kappa \\theta e^{\\kappa t}$$\n从 $0$ 到 $t$ 积分：\n$$\\int_0^t \\frac{d}{ds} \\left( e^{\\kappa s} \\bar{v}(s) \\right) ds = \\int_0^t \\kappa \\theta e^{\\kappa s} ds$$\n$$e^{\\kappa t} \\bar{v}(t) - e^0 \\bar{v}(0) = \\kappa \\theta \\left[ \\frac{e^{\\kappa s}}{\\kappa} \\right]_0^t = \\theta(e^{\\kappa t} - 1)$$\n求解 $\\bar{v}(t)$：\n$$e^{\\kappa t} \\bar{v}(t) = v_0 + \\theta(e^{\\kappa t} - 1)$$\n$$\\bar{v}(t) = v_0 e^{-\\kappa t} + \\theta(1 - e^{-\\kappa t})$$\n这就是在任意时间 $t > 0$ 时瞬时方差的期望路径。\n\n**2. 公平方差互换利率 $K_{\\mathrm{fair}}$ 的推导**\n\n公平方差互换利率 $K_{\\mathrm{fair}}$ 定义为年化已实现方差 $K_{\\mathrm{realized}}$ 的风险中性期望。\n$$K_{\\mathrm{fair}} = \\mathbb{E}^{\\mathbb{Q}}[K_{\\mathrm{realized}}] = \\mathbb{E}^{\\mathbb{Q}}\\left[\\frac{1}{T} \\int_0^T v_t dt\\right]$$\n通过应用 Fubini 定理来交换期望和积分的次序：\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\int_0^T \\mathbb{E}^{\\mathbb{Q}}[v_t] dt = \\frac{1}{T} \\int_0^T \\bar{v}(t) dt$$\n代入 $\\bar{v}(t)$ 的表达式：\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\int_0^T \\left( v_0 e^{-\\kappa t} + \\theta(1 - e^{-\\kappa t}) \\right) dt$$\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\int_0^T \\left( (v_0 - \\theta) e^{-\\kappa t} + \\theta \\right) dt$$\n对 $\\kappa \\neq 0$ 的情况进行积分：\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\left[ (v_0 - \\theta) \\frac{e^{-\\kappa t}}{-\\kappa} + \\theta t \\right]_0^T$$\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\left( \\left( (v_0 - \\theta) \\frac{e^{-\\kappa T}}{-\\kappa} + \\theta T \\right) - \\left( (v_0 - \\theta) \\frac{1}{-\\kappa} \\right) \\right)$$\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\left( \\frac{v_0 - \\theta}{\\kappa} (1 - e^{-\\kappa T}) + \\theta T \\right)$$\n$$K_{\\mathrm{fair}} = \\theta + (v_0 - \\theta) \\frac{1 - e^{-\\kappa T}}{\\kappa T}$$\n\n**3. 小 $\\kappa$ 的极限情况**\n\n为保证数值稳定性，我们必须分析当 $\\kappa \\to 0$ 时 $K_{\\mathrm{fair}}$ 表达式的行为。分数 $\\frac{1 - e^{-\\kappa T}}{\\kappa T}$ 变为 $\\frac{0}{0}$ 的不定式。我们对函数 $f(x) = \\frac{1 - e^{-x}}{x}$ 在 $x = \\kappa T \\to 0$ 时应用洛必达法则：\n$$\\lim_{x \\to 0} \\frac{1 - e^{-x}}{x} = \\lim_{x \\to 0} \\frac{\\frac{d}{dx}(1 - e^{-x})}{\\frac{d}{dx}(x)} = \\lim_{x \\to 0} \\frac{e^{-x}}{1} = 1$$\n因此，$K_{\\mathrm{fair}}$ 在 $\\kappa \\to 0$ 时的极限为：\n$$\\lim_{\\kappa \\to 0} K_{\\mathrm{fair}} = \\theta + (v_0 - \\theta) \\cdot 1 = v_0$$\n这与当 $\\kappa=0$ 时，期望方差恒等于其初始值 $\\bar{v}(t) = v_0$ 的事实相一致。\n在实现中，当 $x$ 很小时直接计算 $1 - e^{-x}$ 会导致灾难性抵消。通过对 $f(x)$ 在 $x=0$ 附近进行一阶泰勒级数展开可以获得更精确的结果：$f(x) \\approx f(0) + f'(0)x$。我们已经得到 $f(0)=1$。其导数为 $f'(x) = \\frac{-x e^{-x} - (1-e^{-x})}{x^2}$，且 $\\lim_{x \\to 0} f'(x) = -1/2$。\n因此，对于小的 $x = \\kappa T$，我们有 $\\frac{1 - e^{-\\kappa T}}{\\kappa T} \\approx 1 - \\frac{\\kappa T}{2}$。\n将此代入 $K_{\\mathrm{fair}}$ 的表达式中，可得到一个在 $\\kappa$ 很小时数值稳定的近似式：\n$$K_{\\mathrm{fair}} \\approx \\theta + (v_0 - \\theta) \\left(1 - \\frac{\\kappa T}{2}\\right) = v_0 - (v_0 - \\theta)\\frac{\\kappa T}{2}$$\n当 $|\\kappa|$ 低于一个很小的阈值时，将使用此近似式。\n\n**4. 方差互换的现值**\n\n方差互换在到期日 $T$ 的支付为 $N_{\\mathrm{var}} (K_{\\mathrm{realized}} - K_{\\mathrm{fixed}})$。根据风险中性定价原理，时间 $0$ 的现值是贴现后的期望支付：\n$$PV_0 = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}\\left[N_{\\mathrm{var}} (K_{\\mathrm{realized}} - K_{\\mathrm{fixed}})\\right]$$\n根据期望的线性性质，并且由于 $N_{\\mathrm{var}}$ 和 $K_{\\mathrm{fixed}}$ 是常数：\n$$PV_0 = N_{\\mathrm{var}} e^{-rT} \\left(\\mathbb{E}^{\\mathbb{Q}}[K_{\\mathrm{realized}}] - \\mathbb{E}^{\\mathbb{Q}}[K_{\\mathrm{fixed}}]\\right)$$\n$$PV_0 = N_{\\mathrm{var}} e^{-rT} (K_{\\mathrm{fair}} - K_{\\mathrm{fixed}})$$\n\n**5. 实现总结**\n\n程序将实现这些推导出的公式。函数 `calculate_k_fair` 根据参数 $v_0$、$\\kappa$、$\\theta$ 和 $T$ 计算公平方差互换利率。该函数将检查 $|\\kappa|$ 是否低于某个阈值（例如，$10^{-8}$），如果是，则应用稳定的泰勒级数近似；否则，它将使用标准公式，并通过 `numpy.expm1` 实现以保持精度。第二个函数 `calculate_pv` 将使用此公平利率为每个提供的测试用例计算最终现值。参数 $\\sigma$ 和 $\\rho$ 与此计算无关，因为它们不影响方差的期望路径。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the present value of a fixed-strike variance swap\n    under the Heston model for a suite of test cases.\n    \"\"\"\n\n    def calculate_k_fair(v0, kappa, theta, T):\n        \"\"\"\n        Calculates the fair variance swap rate, K_fair.\n\n        Args:\n            v0 (float): Initial variance.\n            kappa (float): Mean-reversion speed.\n            theta (float): Long-run variance.\n            T (float): Time to maturity in years.\n\n        Returns:\n            float: The fair variance swap rate.\n        \"\"\"\n        # For very small kappa, the standard formula is numerically unstable\n        # due to catastrophic cancellation. We use a first-order Taylor\n        # expansion derived in the solution.\n        if abs(kappa) < 1e-8:\n            # K_fair ≈ v₀ - (v₀ - θ) * κ * T / 2\n            return v0 - (v0 - theta) * kappa * T / 2.0\n        else:\n            # Standard formula: K_fair = θ + (v₀ - θ) * (1 - e^(-κT)) / (κT)\n            # We use np.expm1 for precision: 1 - exp(-x) = -expm1(-x)\n            x = kappa * T\n            term = -np.expm1(-x) / x\n            return theta + (v0 - theta) * term\n\n    def calculate_pv(v0, kappa, theta, T, N_var, k_fixed, r):\n        \"\"\"\n        Calculates the present value of the variance swap.\n\n        Args:\n            v0 (float): Initial variance.\n            kappa (float): Mean-reversion speed.\n            theta (float): Long-run variance.\n            T (float): Time to maturity in years.\n            N_var (float): Variance notional.\n            k_fixed (float): Fixed variance strike.\n            r (float): Risk-free rate.\n            \n        Returns:\n            float: The present value of the variance swap.\n        \"\"\"\n        k_fair = calculate_k_fair(v0, kappa, theta, T)\n        pv = N_var * np.exp(-r * T) * (k_fair - k_fixed)\n        return pv\n\n    # Define the test cases from the problem statement.\n    # Each tuple is ordered as (κ, θ, σ, ρ, v₀, r, T, N_var, K_fixed).\n    test_cases = [\n        # Case A: General \"happy path\"\n        (2.0, 0.04, 0.6, -0.7, 0.04, 0.01, 1.0, 1.0, 0.05),\n        # Case B: Near-non-mean-reverting boundary\n        (1.0e-8, 0.09, 0.3, 0.2, 0.16, 0.0, 0.25, 1.0, 0.15),\n        # Case C: Long maturity dominance by long-run variance\n        (3.0, 0.09, 0.5, -0.9, 0.04, 0.02, 5.0, 1.0, 0.08),\n        # Case D: Moderate mean reversion with non-unit notional\n        (0.5, 0.06, 1.0, 0.5, 0.10, 0.0, 2.0, 2.0, 0.08),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters, ignoring sigma and rho as they are not needed.\n        kappa, theta, _sigma, _rho, v0, r, T, N_var, k_fixed = case\n        \n        # Calculate the present value for the current case.\n        pv = calculate_pv(v0, kappa, theta, T, N_var, k_fixed, r)\n        results.append(pv)\n\n    # Final print statement in the exact required format.\n    # The format uses high precision to avoid rounding issues.\n    print(f\"[{','.join(f'{x:.12f}' for x in results)}]\")\n\nsolve()\n```"}, {"introduction": "我们的最终实践将带你进入风险管理和模型驱动交易的高级领域，这反映了量化分析师在实际工作中的复杂任务。挑战在于构建一个由普通期权组成的投资组合，以精确分离并对冲模型中的多种风险，最终只保留对特定参数——“波动率的波动率” $\\sigma$ 的单位风险敞口。这项创建“Volga纯粹”投资组合的任务，要求你计算多种参数敏感度（Greeks），并运用线性代数求解，从而实现高度定制的风险画像 [@problem_id:2441262]。", "id": "2441262", "problem": "一个金融市场在风险中性测度下由 Heston 随机波动率模型建模。资产价格过程 $S_t$ 和方差过程 $v_t$ 满足以下耦合的随机微分方程\n$$\n\\mathrm{d}S_t = (r-q)\\,S_t\\,\\mathrm{d}t + \\sqrt{v_t}\\,S_t\\,\\mathrm{d}W_t^{(1)}, \\quad \\mathrm{d}v_t = \\kappa(\\theta - v_t)\\,\\mathrm{d}t + \\sigma \\sqrt{v_t}\\,\\mathrm{d}W_t^{(2)},\n$$\n相关性为 $\\mathrm{d}\\langle W^{(1)},W^{(2)}\\rangle_t = \\rho\\,\\mathrm{d}t$，其中 $r$ 是连续复利无风险利率，$q$ 是连续股息率，$\\kappa$ 是方差的均值回归速度，$\\theta$ 是长期方差，$\\sigma$ 是方差的波动率（vol-of-vol），$\\rho$ 是布朗运动之间的瞬时相关性。初始条件为时间 $t=0$ 时的 $S_0$ 和 $v_0$。\n\n对于一个执行价为 $K$、到期日为 $T$ 的欧式看涨期权，将其无套利价格表示为 $C(K,T;\\boldsymbol{\\Theta})$，其中 $\\boldsymbol{\\Theta} = (S_0,v_0,\\rho,\\kappa,\\theta,\\sigma,r,q)$。\n\n将期权价格对模型输入参数 $p$ 的一阶参数敏感度定义为在指定参数矢量 $\\boldsymbol{\\Theta}$ 处求值的偏导数 $\\partial C / \\partial p$。考虑一个由 $N$ 个普通欧式看涨期权组成的静态投资组合，其权重为 $w_1,\\dots,w_N$（每个权重可以是任意实数），其中第 $j$ 个期权的执行价为 $K_j$，到期日为 $T_j$。该投资组合的价值为 $V = \\sum_{j=1}^N w_j\\,C(K_j,T_j;\\boldsymbol{\\Theta})$。\n\n如果一个投资组合对 vol-of-vol 参数 $\\sigma$ 的一阶敏感度等于 $1$，而对其他五个模型输入参数 $S_0$、$v_0$、$\\rho$、$\\kappa$ 和 $\\theta$ 的敏感度均为 $0$，则称该投资组合是“关于 vol-of-vol 是 Volga-pure 的”：\n$$\n\\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\sigma} = 1, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial S_0} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial v_0} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\rho} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\kappa} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\theta} = 0,\n$$\n其中 $C_j = C(K_j,T_j;\\boldsymbol{\\Theta})$。\n\n您的任务是使用 $N=6$ 个普通看涨期权构建这样一个投资组合，在所有测试案例中，这些期权的执行价和到期日均相同\n$$\n(K_1,T_1)=(80,0.5),\\ (K_2,T_2)=(100,0.5),\\ (K_3,T_3)=(120,0.5),\\ (K_4,T_4)=(80,1.0),\\ (K_5,T_5)=(100,1.0),\\ (K_6,T_6)=(120,1.0).\n$$\n\n对于以下每个参数集（测试套件），使用 Heston 模型下的欧式看涨期权价格 $C(K,T;\\boldsymbol{\\Theta})$ 和第一性原理，计算一个权重向量 $\\boldsymbol{w}=(w_1,\\dots,w_6)$，使其满足上述六个线性敏感度约束。程序应在内部通过数值一致的方法近似敏感度，并在给定的参数值下验证这些约束。无风险利率 $r$ 和股息率 $q$ 均为连续复利。所有利率、方差和相关性都必须作为无量纲的小数处理。本问题中没有物理单位。\n\n测试套件（每一项为 $(S_0,v_0,\\rho,\\kappa,\\theta,\\sigma,r,q)$）：\n- 案例 1：$(100.0,0.04,-0.5,1.5,0.04,0.5,0.02,0.0)$\n- 案例 2：$(100.0,0.05,-0.3,2.0,0.06,0.1,0.01,0.0)$\n- 案例 3：$(100.0,0.04,-0.9,3.0,0.04,0.4,0.03,0.0)$\n\n对于每种情况，您的程序必须：\n1. 计算一个权重向量 $\\boldsymbol{w}$，使其在给定的 $\\boldsymbol{\\Theta}$下，在线性代数的意义上精确满足六个参数 $(S_0,v_0,\\rho,\\kappa,\\theta,\\sigma)$ 的六个约束条件。\n2. 通过在相同的 $\\boldsymbol{\\Theta}$下直接重新计算敏感度，独立验证该投资组合满足\n$$\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial S_0}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial v_0}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\rho}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\kappa}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\theta}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\sigma} - 1\\right| \\le 10^{-4}.\n$$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含三个案例的验证结果，格式为方括号内以逗号分隔的布尔值列表（例如， $[{\\rm True},{\\rm False},{\\rm True}]$），每个布尔值表示该案例所构建的投资组合是否在规定容差下满足所有六个不等式。", "solution": "所提出的问题是计算金融领域一个定义明确的练习，它基于金融工程的既定原则。经检验，其有效性得到确认。该任务要求构建一个特定的欧式看涨期权投资组合，其对一组 Heston 模型参数的敏感度需满足预设的剖面。解决方案涉及求解一个线性方程组，其系数是期权的一阶敏感度，即“Greeks”。\n\n问题的核心是为一个由 $N=6$ 个欧式看涨期权组成的投资组合找到一个权重向量 $\\boldsymbol{w} = (w_1, \\dots, w_6)^T$。该投资组合必须是“关于 vol-of-vol 是 Volga-pure 的”，这由其敏感度上的一组六个线性约束定义。设 $C_j = C(K_j, T_j; \\boldsymbol{\\Theta})$ 为第 $j$ 个期权的价格，其中 $\\boldsymbol{\\Theta} = (S_0, v_0, \\rho, \\kappa, \\theta, \\sigma, r, q)$ 是模型参数和市场条件的向量。需要关注敏感度的六个参数是 $p_1=S_0$，$p_2=v_0$，$p_3=\\rho$，$p_4=\\kappa$，$p_5=\\theta$ 和 $p_6=\\sigma$。这些约束可以表示为一个线性系统：\n$$\n\\sum_{j=1}^{6} w_j \\frac{\\partial C_j}{\\partial p_i} = b_i, \\quad \\text{for } i=1, \\dots, 6\n$$\n其中目标敏感度向量是 $\\boldsymbol{b} = (0, 0, 0, 0, 0, 1)^T$。用矩阵形式表示，即 $A \\boldsymbol{w} = \\boldsymbol{b}$，其中 $A$ 是 $6 \\times 6$ 的敏感度矩阵，其元素为 $A_{ij} = \\frac{\\partial C_j}{\\partial p_i}$。权重的解形式上由 $\\boldsymbol{w} = A^{-1}\\boldsymbol{b}$ 给出，前提是矩阵 $A$ 可逆。$A$ 的可逆性取决于所提供的六个不同期权的敏感度向量的线性无关性，对于非退化的参数集，通常可以预期这一条件成立。\n\n解决方案主要分两个阶段进行：\n1.  **Heston 期权价格和敏感度的计算**：Heston 模型下欧式看涨期权的价格通过涉及傅里叶变换的半解析解计算。然后使用中心有限差分格式近似其敏感度。\n2.  **求解线性系统**：构建敏感度矩阵 $A$ 后，使用标准的线性代数库例程求解系统 $A\\boldsymbol{w}=\\boldsymbol{b}$，以找到权重 $\\boldsymbol{w}$。然后根据指定的容差检查解的有效性。\n\n**1. Heston 模型期权定价**\n\n执行价为 $K$、到期日为 $T$ 的欧式看涨期权价格由下式给出\n$$\nC(S_0, K, T) = S_0 e^{-qT} P_1 - K e^{-rT} P_2\n$$\n其中 $S_0$ 是初始资产价格，$r$ 是无风险利率，$q$ 是股息率。$P_1$ 和 $P_2$ 项是在不同测度下的概率，通过数值积分对它们各自的特征函数进行反演来计算：\n$$\nP_j = \\frac{1}{2} + \\frac{1}{\\pi} \\int_0^\\infty \\text{Re}\\left[ \\frac{e^{-i\\phi \\ln K} f_j(\\phi; S_0, v_0, T)}{i\\phi} \\right] d\\phi, \\quad \\text{for } j=1, 2\n$$\n特征函数 $f_j$ 由下式给出\n$$\nf_j(\\phi) = \\exp\\left( C_j(\\phi, T) + D_j(\\phi, T)v_0 + i\\phi \\ln S_0 \\right)\n$$\n复值系数 $C_j$ 和 $D_j$ 定义为：\n$$\nC_j(\\phi, T) = i\\phi(r-q)T + \\frac{\\kappa\\theta}{\\sigma^2} \\left[ (b_j - d_j)T - 2\\ln\\left( \\frac{1-g_j e^{-d_j T}}{1-g_j} \\right) \\right]\n$$\n$$\nD_j(\\phi, T) = \\frac{b_j-d_j}{\\sigma^2} \\left( \\frac{1-e^{-d_j T}}{1-g_j e^{-d_j T}} \\right)\n$$\n辅助变量为：\n$$\nd_j = \\sqrt{b_j^2 - \\sigma^2(2u_j i \\phi - \\phi^2)}\n$$\n$$\ng_j = \\frac{b_j-d_j}{b_j+d_j}\n$$\n常数 $u_j$ 和变量 $b_j$ 取决于正在计算的是哪个概率（$P_1$ 或 $P_2$）：\n- 对于 $P_1$：$u_1 = 1/2$, $b_1 = \\kappa - \\rho\\sigma i\\phi$。\n- 对于 $P_2$：$u_2 = -1/2$, $b_2 = \\kappa$。\n\n用于 $P_1$ 和 $P_2$ 的反常积分使用求积方法进行数值计算。被积函数在 $\\phi=0$ 处性态良好，且积分收敛迅速，因此可以在一个足够大的上界处截断积分域。\n\n**2. 敏感度计算与系统求解**\n\n构成矩阵 $A$ 的偏导数 $\\frac{\\partial C_j}{\\partial p_i}$ 使用二阶中心有限差分公式进行近似：\n$$\n\\frac{\\partial C(p)}{\\partial p} \\approx \\frac{C(p + h) - C(p - h)}{2h}\n$$\n其中 $h$ 是一个很小的步长。对于大多数参数，使用形式为 $h = \\epsilon |p|$ 的相对步长；对于可能接近于零的参数，则使用一个小的绝对步长 $\\epsilon$（例如，$10^{-5}$），以保持数值稳定性和准确性。\n\n对于每个测试案例，算法如下：\na. 从测试套件中定义 Heston 参数集 $\\boldsymbol{\\Theta}$。\nb. 定义构成投资组合的六个期权 $(K_j, T_j)$。\nc. 构建 $6 \\times 6$ 的敏感度矩阵 $A$。每一列 $j$ 对应一个期权，每一行 $i$ 对应一个参数 $p_i$。元素 $A_{ij}$ 通过将有限差分公式应用于期权 $j$ 的 Heston 定价函数（关于参数 $p_i$）来计算。\nd. 定义目标向量 $\\boldsymbol{b} = (0, 0, 0, 0, 0, 1)^T$。\ne. 使用标准的数值线性求解器求解线性系统 $A\\boldsymbol{w} = \\boldsymbol{b}$，以得到权重向量 $\\boldsymbol{w}$。\nf. 通过计算投资组合的敏感度剖面 $\\boldsymbol{s} = A\\boldsymbol{w}$ 来验证解。\ng. 检查结果向量 $\\boldsymbol{s}$ 的每个元素是否在指定的 $10^{-4}$ 容差内与目标向量 $\\boldsymbol{b}$ 匹配。即，检查对于所有 $i=1, \\dots, 6$ 是否满足 $|s_i - b_i| \\leq 10^{-4}$。此验证的结果（True 或 False）将为该测试案例记录下来。\n\n对测试套件中提供的三个参数集中的每一个重复此过程。最终输出是这些布尔验证结果的列表。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to construct and verify the Volga-pure portfolios.\n    \"\"\"\n\n    def heston_char_func_integrand(phi, params, K, T, j):\n        \"\"\"\n        Computes the integrand for P1 and P2 probabilities in the Heston model.\n        j=1 for P1, j=2 for P2.\n        \"\"\"\n        S0, v0, rho, kappa, theta, sigma, r, q = params\n        \n        if j == 1:\n            u, b = 0.5, kappa - rho * sigma * 1j * phi\n        else: # j == 2\n            u, b = -0.5, kappa\n\n        d = np.sqrt(b**2 - sigma**2 * (2 * u * 1j * phi - phi**2))\n        g = (b - d) / (b + d)\n        \n        # Numerically stable calculation for log term\n        # C = i*phi*(r-q)*T + kappa*theta/sigma**2 * ( (b-d)*T - 2*log((1-g*exp(-d*T))/(1-g)) )\n        # The log term can be unstable if g is close to 1.\n        # This happens when d is small.\n        # d -> 0 implies b^2 - sigma^2(...) -> 0.\n        # Another formulation of the log term:\n        # 2*log( (1-g*exp(-d*T))/(1-g) ) = 2*log( (b+d- (b-d)exp(-d*T))/(2d)) is not better.\n        # Let's use the standard form and rely on numpy's complex arithmetic precision.\n        \n        # When d*T is large, exp(-d*T) -> 0.\n        # When d*T is small, exp(-d*T) approx 1-d*T.\n        # (1-g*exp(-d*T))/(1-g) = (1-g+g*d*T)/(1-g) = 1 + g*d*T/(1-g)\n        # log(...) approx g*d*T/(1-g)\n        \n        # Use a check for small sigma to avoid division by zero, though not needed for test cases.\n        if sigma < 1e-10:\n            return 0.0\n\n        C_term_log = np.log((1 - g * np.exp(-d * T)) / (1 - g))\n        D = (b - d) / sigma**2 * ((1 - np.exp(-d * T)) / (1 - g * np.exp(-d * T)))\n        C = 1j * phi * (r - q) * T + kappa * theta / sigma**2 * ((b - d) * T - 2 * C_term_log)\n        \n        f = np.exp(C + D * v0 + 1j * phi * np.log(S0))\n        \n        integrand = np.real(np.exp(-1j * phi * np.log(K)) * f / (1j * phi))\n        return integrand\n\n    def heston_call_price(params, K, T):\n        \"\"\"\n        Calculates the price of a European call option using the Heston model.\n        \"\"\"\n        S0, v0, rho, kappa, theta, sigma, r, q = params\n        \n        # Integral P1\n        args_1 = (params, K, T, 1)\n        # The quad function can handle complex-valued functions by integrating real and imag parts\n        # but here the integrand is already made real.\n        integral_1, _ = quad(heston_char_func_integrand, 0, 200, args=args_1)\n        P1 = 0.5 + integral_1 / np.pi\n        \n        # Integral P2\n        args_2 = (params, K, T, 2)\n        integral_2, _ = quad(heston_char_func_integrand, 0, 200, args=args_2)\n        P2 = 0.5 + integral_2 / np.pi\n        \n        price = S0 * np.exp(-q * T) * P1 - K * np.exp(-r * T) * P2\n        return price\n\n    # Define the portfolio of 6 options\n    options = [\n        (80.0, 0.5), (100.0, 0.5), (120.0, 0.5),\n        (80.0, 1.0), (100.0, 1.0), (120.0, 1.0)\n    ]\n\n    # Test suite from the problem statement\n    test_cases = [\n        (100.0, 0.04, -0.5, 1.5, 0.04, 0.5, 0.02, 0.0),\n        (100.0, 0.05, -0.3, 2.0, 0.06, 0.1, 0.01, 0.0),\n        (100.0, 0.04, -0.9, 3.0, 0.04, 0.4, 0.03, 0.0)\n    ]\n    \n    # Parameters for which sensitivities are needed\n    param_indices = [0, 1, 2, 3, 4, 5]  # Indices for S0, v0, rho, kappa, theta, sigma\n    h_rel = 1e-5 # Relative step size for finite differences\n    h_abs = 1e-5 # Absolute step size for certain parameters\n\n    results = []\n    \n    for case_params in test_cases:\n        A = np.zeros((6, 6))\n        \n        for j, (K, T) in enumerate(options):\n            for i, p_idx in enumerate(param_indices):\n                params_list = list(case_params)\n                p_val = params_list[p_idx]\n                \n                # Choose step size h\n                if p_idx == 2: # rho\n                    h = h_abs\n                else: # S0, v0, kappa, theta, sigma\n                    h = h_rel * abs(p_val) if p_val != 0 else h_abs\n                \n                params_plus = params_list[:]\n                params_plus[p_idx] = p_val + h\n                price_plus = heston_call_price(tuple(params_plus), K, T)\n                \n                params_minus = params_list[:]\n                params_minus[p_idx] = p_val - h\n                price_minus = heston_call_price(tuple(params_minus), K, T)\n\n                sensitivity = (price_plus - price_minus) / (2 * h)\n                A[i, j] = sensitivity\n\n        b = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 1.0])\n        \n        try:\n            w = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            # If the matrix is singular, the portfolio cannot be constructed.\n            results.append(False)\n            continue\n            \n        # Verification step\n        portfolio_sensitivities = A @ w\n        \n        sens_zeros = portfolio_sensitivities[:5]\n        sens_one = portfolio_sensitivities[5]\n        \n        tolerance = 1e-4\n        \n        check_zeros = np.all(np.abs(sens_zeros) <= tolerance)\n        check_one = np.abs(sens_one - 1.0) <= tolerance\n        \n        results.append(check_zeros and check_one)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}