{"hands_on_practices": [{"introduction": "将理论付诸实践是掌握任何数值方法的最佳途径。第一个练习有两个目的：它将指导你完整实现Crank-Nicolson方法，并让你直面一个常见的数值计算问题——非平滑初始条件附近产生的虚假振荡。通过将Crank-Nicolson方法与更简单的显式方法在欧式看涨期权收益函数的“拐点”附近进行比较，我们可以从视觉上和量化上理解，为什么像Crank-Nicolson这样的隐式方法所具有的优越稳定性如此重要。[@problem_id:2439346]", "id": "2439346", "problem": "编写一个完整、可运行的程序，比较 Crank-Nicolson (CN) 有限差分法和完全显式时间步进有限差分法在对由 Black-Scholes 偏微分方程 (PDE) 控制的欧式看涨期权进行定价时的行为。您的目标是研究短期限下行权价附近的数值振荡，并用一个简单、客观的度量来量化它们。\n\n您必须基于以下公认的基础来构建您的公式：\n- 在风险中性定价下，欧式看涨期权价格 $V(S,t)$ 的 Black-Scholes 偏微分方程为：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其中 $S$ 为标的资产价格，$r$ 为无风险利率，$\\sigma$ 为波动率，$t$ 表示当前时间（更早的时间对应于更长的距到期时间）。\n- 到期日 $t = T$ 时的终端条件：\n$$\nV(S,T) = \\max(S - K, 0),\n$$\n其中 $K$ 为行权价。\n- 对于一个足够大的有限域 $S \\in [0, S_{\\max}]$，边界条件为：\n$$\nV(0,t) = 0, \\quad V(S_{\\max}, t) \\approx S_{\\max} - K e^{-r (T - t)}.\n$$\n\n用 $M$ 个区间将空间域均匀离散化，使得 $S_j = j \\Delta S$，$j = 0,1,\\dots,M$，其中 $\\Delta S = S_{\\max}/M$。用 $N_t$ 个步长将时间均匀离散化，使得 $t_n = n \\Delta t$，$n=0,1,\\dots,N_t$，其中 $\\Delta t = T/N_t$。在均匀网格上使用标准的空间中心有限差分。实现以下方法：\n- Crank-Nicolson (CN) 时间步进法（一种时间上的隐式梯形法则）。\n- 完全显式前向时间法（使用相同的空间模板）。\n\n两种格式都应将数值解从 $t=T$ 向后推进到 $t=0$。\n\n按如下方式定义并计算一个关注于行权价附近的振荡度量。令 $j_K$ 为最接近行权价的空间索引，$j_K = \\mathrm{round}(K/\\Delta S)$。对于一个固定的窗口半宽 $w$，考虑索引 $j \\in \\{ \\max(1, j_K - w), \\dots, \\min(M-1, j_K + w) \\}$。令 $j$ 处的离散二阶差分为\n$$\n\\Delta^2 V_j = V_{j+1}(0) - 2 V_j(0) + V_{j-1}(0),\n$$\n其中 $V_j(0)$ 表示在 $t=0$ 时的数值解。定义振荡幅度为\n$$\n\\mathcal{O} = \\max_{j} \\big( 0, -\\Delta^2 V_j \\big),\n$$\n在指定窗口上计算。对于像欧式看涨期权这样的凸性收益，真实解在 $S$ 上是凸的，因此行权价附近的任何负的离散二阶差分都表明存在伪数值振荡。\n\n为每个测试用例实现这两种方法，并计算比率\n$$\nR = \\frac{\\mathcal{O}_{\\mathrm{CN}}}{\\mathcal{O}_{\\mathrm{EXP}} + \\varepsilon},\n$$\n其中 $\\varepsilon = 10^{-12}$ 是一个小数，以避免除以零。报告每个测试用例的 $R$ 值。\n\n所有利率必须以小数形式表示（例如，年化利率百分之五表示为 $r = 0.05$）。没有物理单位。\n\n使用以下测试套件，该套件在保持空间网格相同的情况下，探索了一系列短期限和波动率。在所有情况下，设置 $K = 100$，$S_{\\max} = 5K$，$M = 100$，窗口半宽 $w = 5$。\n- 用例 A（短期限，粗糙时间）：$\\sigma = 0.2$，$r = 0.05$，$T = 0.01$，$N_t = 10$。\n- 用例 B（短期限，更精细时间）：$\\sigma = 0.2$，$r = 0.05$，$T = 0.01$，$N_t = 40$。\n- 用例 C（极短期限，低波动率）：$\\sigma = 0.1$，$r = 0.05$，$T = 0.005$，$N_t = 8$。\n- 用例 D（短期限，较高波动率）：$\\sigma = 0.3$，$r = 0.05$，$T = 0.02$，$N_t = 64$。\n\n您的程序必须按 A、B、C、D 的顺序计算每个用例的 $R$ 值，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[x_1,x_2,x_3,x_4]$。每个 $x_i$ 都应为浮点数。不强制要求四舍五入，但可接受固定小数位数。\n\n请确保您实现的科学真实性和内部一致性。仅使用所述的标准有限差分离散化方法。不要在您的度量中使用任何解析定价公式；纯粹通过行权价附近的离散凸性来评估振荡。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于 Black-Scholes 模型和标准的数值分析技术，其设置完整一致，问题提法明确，并且其表述是客观的。我们将继续提供完整的解决方案。\n\n该问题要求实现并比较两种用于求解欧式看涨期权的 Black-Scholes 偏微分方程 (PDE) 的有限差分方法。目标是量化短期限下行权价附近的数值振荡。\n\nBlack-Scholes 偏微分方程由下式给出：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n这是一个终值问题，其在到期日 $t=T$ 的终端条件是期权的收益函数：\n$$\nV(S,T) = \\max(S-K, 0)\n$$\n为了进行数值求解，我们通常将其转换为一个初值问题。令 $\\tau = T - t$。此变换将时间导数 $\\frac{\\partial}{\\partial t}$ 变为 $-\\frac{\\partial}{\\partial \\tau}$，并且问题在 $\\tau$ 上从 $\\tau=0$（到期日）向前求解到 $\\tau=T$（今天）。该 PDE 变为：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\n这是一个抛物型 PDE，形式为 $\\frac{\\partial V}{\\partial \\tau} = \\mathcal{L}V$，其中 $\\mathcal{L}$ 是一个线性空间微分算子。\n\n我们将空间域 $S \\in [0, S_{\\max}]$ 离散化为 $M$ 个宽度为 $\\Delta S = S_{\\max}/M$ 的区间，使得 $S_j = j \\Delta S$，$j \\in \\{0, 1, \\dots, M\\}$。时间域 $\\tau \\in [0, T]$ 被离散化为 $N_t$ 个大小为 $\\Delta\\tau = T/N_t$ 的步长，使得 $\\tau_n = n \\Delta\\tau$，$n \\in \\{0, 1, \\dots, N_t\\}$。令 $V_j^n$ 表示 $V(S_j, \\tau_n)$ 的数值近似。\n\n对空间导数使用标准的中心有限差分，网格点 $S_j$ 处的算子 $\\mathcal{L}$ 可近似为：\n$$\n(\\mathcal{L}_h V)_j = \\left(\\frac{\\sigma^2 S_j^2}{2(\\Delta S)^2} - \\frac{r S_j}{2\\Delta S}\\right)V_{j-1} + \\left(-\\frac{\\sigma^2 S_j^2}{(\\Delta S)^2} - r\\right)V_j + \\left(\\frac{\\sigma^2 S_j^2}{2(\\Delta S)^2} + \\frac{r S_j}{2\\Delta S}\\right)V_{j+1}\n$$\n其中 $\\mathcal{L}_h$ 是离散空间算子。使用 $S_j = j\\Delta S$，我们定义系数：\n$$\n\\alpha_j = \\frac{1}{2}\\sigma^2 j^2 - \\frac{1}{2}rj \\\\\n\\beta_j = -\\sigma^2 j^2 - r \\\\\n\\gamma_j = \\frac{1}{2}\\sigma^2 j^2 + \\frac{1}{2}rj\n$$\n节点 $j$ 处的离散化 PDE 则为 $\\frac{dV_j}{d\\tau} \\approx \\alpha_j V_{j-1} + \\beta_j V_j + \\gamma_j V_{j+1}$。这是不正确的。这些系数与包含 $\\Delta S$ 的完整表达式相关。半离散 PDE 的正确形式是：\n$$\n\\frac{d V_j}{d \\tau} = \\frac{1}{(\\Delta S)^2}\\left(\\frac{1}{2}\\sigma^2 (j\\Delta S)^2 - \\frac{r(j\\Delta S)\\Delta S}{2}\\right)V_{j-1} + \\dots\n$$\n一个更直接的方法是标准的。让我们直接为时间步进格式定义系数：令 $\\tilde{\\alpha}_j = \\frac{\\Delta\\tau}{2}\\left(\\sigma^2 j^2 - rj\\right)$，$\\tilde{\\beta}_j = \\Delta\\tau\\left(\\sigma^2 j^2 + r\\right)$，$\\tilde{\\gamma}_j = \\frac{\\Delta\\tau}{2}\\left(\\sigma^2 j^2 + rj\\right)$。\n\n**1. 完全显式法**\n该方法在 $\\tau$ 上使用前向欧拉离散：$\\frac{V^{n+1}-V^n}{\\Delta\\tau} = \\mathcal{L}_h V^n$。内部节点（$j = 1, \\dots, M-1$）的更新规则是：\n$$\nV_j^{n+1} = (1 - \\tilde{\\beta}_j)V_j^n + \\tilde{\\alpha}_j V_{j-1}^n + \\tilde{\\gamma}_j V_{j+1}^n\n$$\n该格式计算简单，但只是条件稳定的。对于每个时间步，我们根据上一步的向量 $V^n$ 计算新值的向量 $V^{n+1}$。\n\n**2. Crank-Nicolson 法**\n该方法对时间导数使用梯形法则：$\\frac{V^{n+1}-V^n}{\\Delta\\tau} = \\frac{1}{2}(\\mathcal{L}_h V^n + \\mathcal{L}_h V^{n+1})$。这是一种隐式方法，它在每个时间步都会导出一个线性方程组：\n$$\n-\\tilde{\\alpha}_j V_{j-1}^{n+1} + (1 + \\tilde{\\beta}_j) V_j^{n+1} - \\tilde{\\gamma}_j V_{j+1}^{n+1} = \\tilde{\\alpha}_j V_{j-1}^n + (1 - \\tilde{\\beta}_j) V_j^n + \\tilde{\\gamma}_j V_{j+1}^n\n$$\n左侧包含第 $n+1$ 步的未知值，形成一个三对角方程组 $A \\boldsymbol{V}^{n+1} = \\boldsymbol{b}$，其中 $\\boldsymbol{V}^{n+1}$ 是未知期权价格的向量。在整个时间步进过程中，矩阵 $A$ 是恒定的，这使得可以使用像 Thomas 算法这样的三对角求解器进行高效求解。\n\n**边界条件**\n对于这两种方法，必须在每个时间步 $n$ 应用边界条件：\n- 在 $S=0$ 处：$V_0^{n+1} = 0$。\n- 在 $S=S_{\\max}$ 处：$V_M^{n+1} = S_{\\max} - K e^{-r \\tau_{n+1}}$。\n对于 Crank-Nicolson 方法，已知的 $V_M^{n+1}$ 值在节点 $j=M-1$ 的方程中被移到线性方程组的右侧。\n\n**振荡度量**\n解的凸性在 $\\tau=T$（即 $t=0$）时进行评估。在空间节点 $j$ 处的离散二阶差分为 $\\Delta^2 V_j = V_{j+1} - 2 V_j + V_j$。对于欧式看涨期权，价格是 $S$ 的一个凸函数，因此我们期望 $\\Delta^2 V_j \\ge 0$。振荡幅度 $\\mathcal{O}$ 定义为行权价 $K$ 周围窗口内二阶差分负值的最大值：\n$$\n\\mathcal{O} = \\max_{j \\in W} \\left( 0, - (V_{j+1} - 2V_j + V_j) \\right)\n$$\n其中窗口 $W$ 为 $\\{ \\max(1, j_K - w), \\dots, \\min(M-1, j_K + w) \\}$，$j_K = \\mathrm{round}(K/\\Delta S)$。$\\mathcal{O}$ 越大表示伪数值振荡越严重。最终要求的输出是比率 $R = \\mathcal{O}_{\\mathrm{CN}} / (\\mathcal{O}_{\\mathrm{EXP}} + \\varepsilon)$。\n\n对每个测试用例，执行以下步骤：\n1. 设置空间和时间网格。\n2. 使用终端条件 $V(S,T)$ 初始化解向量。\n3. 使用显式或 Crank-Nicolson 更新规则从 $\\tau=0$ 迭代到 $\\tau=T$，并在每一步应用边界条件。\n4. 在最后一个时间步之后，为每种方法计算振荡度量 $\\mathcal{O}$。\n5. 计算比率 $R$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy\n#   version: 1.23.5\n#   name: scipy\n#   version: 1.11.4\n\ndef solve_black_scholes_fdm(params, method):\n    \"\"\"\n    Solves the Black-Scholes PDE using the specified finite difference method.\n\n    Args:\n        params (dict): Dictionary of parameters (K, S_max, M, T, N_t, r, sigma).\n        method (str): 'explicit' or 'cn' (Crank-Nicolson).\n\n    Returns:\n        numpy.ndarray: The option prices at t=0 across the spatial grid.\n    \"\"\"\n    K, S_max, M, T, N_t, r, sigma = params['K'], params['S_max'], params['M'], params['T'], params['N_t'], params['r'], params['sigma']\n\n    # Grid setup\n    dS = S_max / M\n    dt = T / N_t  # This is delta_tau\n    S = np.linspace(0, S_max, M + 1)\n    \n    # Initial condition at t=T (tau=0)\n    V = np.maximum(S - K, 0)\n    \n    # Coefficients for the discretized PDE (do not depend on time)\n    # These are for the interior points j = 1, ..., M-1\n    j = np.arange(1, M)\n    alpha = 0.5 * dt * (sigma**2 * j**2 - r * j)\n    beta = dt * (sigma**2 * j**2 + r)\n    gamma = 0.5 * dt * (sigma**2 * j**2 + r * j)\n\n    if method == 'explicit':\n        # Time-stepping loop\n        for n in range(N_t):\n            V_old = V.copy()\n            # Vectorized update for interior points\n            V[1:M] = (1 - beta) * V_old[1:M] + alpha * V_old[0:M-1] + gamma * V_old[2:M+1]\n            \n            # Apply boundary conditions for the next step\n            V[0] = 0.0\n            V[M] = S_max - K * np.exp(-r * (n + 1) * dt)\n            \n    elif method == 'cn':\n        # Setup the tridiagonal matrix A for the linear system A*V_new = B\n        l_diag = -alpha[1:]      # Lower diagonal\n        m_diag = 1 + beta\n        u_diag = -gamma[:-1]     # Upper diagonal\n        \n        # Matrix A in banded format for scipy solver\n        # 1st row: super-diagonal, 2nd row: main-diagonal, 3rd row: sub-diagonal\n        A_banded = np.zeros((3, M - 1))\n        A_banded[0, 1:] = u_diag\n        A_banded[1, :] = m_diag\n        A_banded[2, :-1] = l_diag\n\n        # Time-stepping loop\n        for n in range(N_t):\n            # Setup RHS vector B\n            B = alpha * V[0:M-1] + (1 - beta) * V[1:M] + gamma * V[2:M+1]\n\n            # Adjust RHS for boundary conditions\n            # BC at S=0 (V[0]=0) does not require adjustment as alpha[0]*V[0]=0\n            v_M_new = S_max - K * np.exp(-r * (n + 1) * dt)\n            B[-1] += gamma[-1] * v_M_new\n\n            # Solve the linear system\n            V[1:M] = solve_banded((1, 1), A_banded, B)\n            \n            # Update boundary conditions\n            V[0] = 0.0\n            V[M] = v_M_new\n            \n    return V\n\ndef calculate_oscillation_metric(V, K, S_max, M, w):\n    \"\"\"\n    Calculates the oscillation metric from the final option prices.\n    \"\"\"\n    dS = S_max / M\n    j_K = int(round(K / dS))\n    \n    start_j = max(1, j_K - w)\n    end_j = min(M - 1, j_K + w)\n    \n    max_neg_convexity = 0.0\n    for j in range(start_j, end_j + 1):\n        second_diff = V[j+1] - 2 * V[j] + V[j-1]\n        max_neg_convexity = max(max_neg_convexity, -second_diff)\n\n    return max_neg_convexity\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.2, 'r': 0.05, 'T': 0.01, 'N_t': 10},\n        # Case B\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.2, 'r': 0.05, 'T': 0.01, 'N_t': 40},\n        # Case C\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.1, 'r': 0.05, 'T': 0.005, 'N_t': 8},\n        # Case D\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.3, 'r': 0.05, 'T': 0.02, 'N_t': 64},\n    ]\n\n    epsilon = 1e-12\n    results = []\n\n    for params in test_cases:\n        # Solve with Crank-Nicolson\n        V_cn = solve_black_scholes_fdm(params, method='cn')\n        osc_cn = calculate_oscillation_metric(V_cn, params['K'], params['S_max'], params['M'], params['w'])\n\n        # Solve with Explicit method\n        V_exp = solve_black_scholes_fdm(params, method='explicit')\n        osc_exp = calculate_oscillation_metric(V_exp, params['K'], params['S_max'], params['M'], params['w'])\n\n        # Calculate the ratio\n        ratio = osc_cn / (osc_exp + epsilon)\n        results.append(ratio)\n\n    # Format the output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"}, {"introduction": "既然我们已经有了一个可用的求解器，我们如何才能让它变得更好呢？本练习介绍了一种经典而优雅的精度增强技术：理查森外推法（Richardson Extrapolation）。其原理惊人地简单：通过使用不同的步长运行两次模拟，我们可以巧妙地组合结果以消除主要的误差项。这个实践将演示如何将我们的Crank-Nicolson求解器在时间上的收敛阶数从二阶显著提升至四阶，从而用少量额外计算换取精度的巨大提升。[@problem_id:2439320]", "id": "2439320", "problem": "考虑风险中性动态下一个欧式看涨期权价值 $V(S,t)$ 的 Black–Scholes 偏微分方程：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n对于资产价格 $S \\ge 0$ 和时间 $t \\in [0,T]$，其在到期日 $T$ 的终端条件由收益给出：\n$$\nV(S,T) = \\max(S-K,0),\n$$\n以及边界条件（对所有 $t \\in [0,T]$）：\n$$\nV(0,t) = 0, \\quad V(S_{\\max},t) = S_{\\max} - K e^{-r(T-t)}.\n$$\n所有利率和波动率都必须以小数形式处理（例如，$5\\%$ 必须输入为 $0.05$）。本问题不涉及角度。不涉及物理单位。设 $S_{\\max}$ 为资产域的有限截断，其选择应足够大，以使截断误差相对于所考虑的离散化误差可以忽略不计。\n\n您必须编写一个完整的程序，该程序：\n- 使用 Crank–Nicolson 方法，在具有相同空间步数 $M$ 的同一均匀资产网格上，但使用两种不同的时间步数 $N$ 和 $2N$（即时间步长 $\\Delta t = T/N$ 和 $\\Delta t/2 = T/(2N)$），计算上述问题的两个数值解。\n- 根据时间 $t=0$ 时的两个数值解，应用时间上的 Richardson 外推法，将两个解组合成 $t=0$ 时的外推值，以消除主阶时间离散误差。\n- 计算欧式看涨期权在 $t=0$ 时对应的 Black–Scholes 公式解析值，\n$$\nC_{\\mathrm{BS}}(S_0,K,r,\\sigma,T) = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2),\n$$\n其中\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2) T}{\\sigma \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma \\sqrt{T},\n$$\n此处 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。\n- 量化在 $t=0$ 和 $S=S_0$ 时，粗时间步长数值、细时间步长数值以及 Richardson 外推值相对于解析值的绝对误差。\n- 对每个测试用例，报告两个作为实数表示的精度改善因子：粗步长绝对误差与外推绝对误差之比，以及细步长绝对误差与外推绝对误差之比。\n\n对于每个测试用例的两种时间步数，均使用相同的均匀资产网格，并通过在资产网格上进行线性插值来获得 $S=S_0$ 处 $t=0$ 时的值。所有输出都必须是实数。\n\n测试集：\n- 测试用例 $1$：$S_0=100$, $K=100$, $r=0.03$, $\\sigma=0.25$, $T=1.0$, $S_{\\max}=5K$, $M=800$, $N=200$。\n- 测试用例 $2$：$S_0=80$, $K=100$, $r=0.01$, $\\sigma=0.15$, $T=0.25$, $S_{\\max}=5K$, $M=800$, $N=120$。\n- 测试用例 $3$：$S_0=120$, $K=100$, $r=0.00$, $\\sigma=0.05$, $T=2.0$, $S_{\\max}=6K$, $M=900$, $N=240$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于以上述顺序列出的每个测试用例，按此顺序输出五个实数：使用 $N$ 个时间步的绝对误差、使用 $2N$ 个时间步的绝对误差、经过 Richardson 外推后的绝对误差、定义为 $N$ 步绝对误差与外推绝对误差之比的改善因子，以及定义为 $2N$ 步绝对误差与外推绝对误差之比的改善因子。将所有三个测试用例的值按相同顺序汇总到一个扁平列表中。例如，输出格式必须为\n$[e_{1,N}, e_{1,2N}, e_{1,\\mathrm{RE}}, \\rho_{1,N\\to \\mathrm{RE}}, \\rho_{1,2N\\to \\mathrm{RE}}, e_{2,N}, e_{2,2N}, e_{2,\\mathrm{RE}}, \\rho_{2,N\\to \\mathrm{RE}}, \\rho_{2,2N\\to \\mathrm{RE}}, e_{3,N}, e_{3,2N}, e_{3,\\mathrm{RE}}, \\rho_{3,N\\to \\mathrm{RE}}, \\rho_{3,2N\\to \\mathrm{RE}}]$。", "solution": "问题要求使用 Crank–Nicolson 有限差分法对欧式看涨期权的 Black–Scholes 偏微分方程（PDE）进行数值求解。然后，使用 Richardson 外推法改进该解，并与 Black–Scholes 解析公式进行比较以量化精度。\n\n控制性的 Black–Scholes 偏微分方程由下式给出：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n其中 $V(S,t)$ 是资产价格为 $S$、时间为 $t$ 时的期权价值，$\\sigma$ 是波动率， $r$ 是无风险利率， $K$ 是执行价格， $T$ 是到期时间。该问题定义在 $S \\ge 0$ 和 $t \\in [0,T]$ 上。\n\n这是一个终端值问题，其在 $t=T$ 时的条件由收益函数给出：\n$$\nV(S,T) = \\max(S-K, 0)\n$$\n为了将其转换为初值问题，我们引入一个新的时间变量 $\\tau = T-t$。当 $t$ 从 $0$ 变为 $T$ 时，$\\tau$ 从 $T$ 变为 $0$。时间导数变换为 $\\partial/\\partial t = -\\partial/\\partial \\tau$。该偏微分方程在 $\\tau$ 中变成一个向前抛物型方程：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\n其在 $\\tau=0$ 时的初始条件为：\n$$\nV(S,0) = \\max(S-K, 0)\n$$\n以及对 $\\tau \\in [0,T]$ 的边界条件：\n$$\nV(0,\\tau) = 0 \\quad \\text{和} \\quad V(S_{\\max},\\tau) = S_{\\max} - K e^{-r\\tau}\n$$\n在这里，原始边界条件 $V(S_{\\max},t)$ 中的 $t$ 已被 $T-\\tau$ 替代。$S$ 的域被截断为 $[0, S_{\\max}]$。\n\n我们对问题域进行离散化。资产价格域 $[0, S_{\\max}]$ 被划分为 $M$ 个宽度为 $\\Delta S = S_{\\max}/M$ 的均匀区间，从而创建了网格点 $S_i = i \\Delta S$，其中 $i=0, 1, \\dots, M$。时间域 $[0,T]$ 被划分为 $N$ 个宽度为 $\\Delta \\tau = T/N$ 的区间，其时间步为 $\\tau_j = j \\Delta \\tau$，其中 $j=0, 1, \\dots, N$。令 $V_i^j$ 表示 $V(S_i, \\tau_j)$ 的数值近似。\n\nCrank–Nicolson 方法在时间区间的中点 $\\tau_{j+1/2}$ 处近似时间导数，并在时间层 $j$ 和 $j+1$ 上对空间导数算子进行平均：\n$$\n\\frac{V_i^{j+1} - V_i^j}{\\Delta \\tau} = \\frac{1}{2} \\left[ (\\mathcal{L}_h V^{j+1})_i + (\\mathcal{L}_h V^j)_i \\right]\n$$\n其中 $\\mathcal{L}_h$ 是空间微分算子 $\\mathcal{L} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2}{\\partial S^2} + r S \\frac{\\partial}{\\partial S} - r$ 的有限差分近似。我们对空间导数使用二阶中心差分：\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - V_{i-1}}{2\\Delta S}, \\qquad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{(\\Delta S)^2}\n$$\n将这些代入算子 $\\mathcal{L}_h$ 可得：\n$$\n(\\mathcal{L}_h V)_i = \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} - \\frac{r S_i}{2\\Delta S}\\right) V_{i-1} + \\left(-\\frac{\\sigma^2 S_i^2}{(\\Delta S)^2} - r\\right) V_i + \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} + \\frac{r S_i}{2\\Delta S}\\right) V_{i+1}\n$$\n重新整理 Crank-Nicolson 格式，将时间层 $j+1$ 的未知值（在左侧）与时间层 $j$ 的已知值（在右侧）分开：\n$$\n\\left(I - \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^{j+1} = \\left(I + \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^j\n$$\n这为内部网格点 $i=1, \\dots, M-1$ 构成了一个线性方程组。每个内部点 $i$ 的方程是：\n$$\n-\\alpha_i V_{i-1}^{j+1} + \\beta_i V_i^{j+1} - \\gamma_i V_{i+1}^{j+1} = \\alpha_i V_{i-1}^{j} + (2-\\beta_i) V_i^{j} + \\gamma_i V_{i+1}^{j}\n$$\n其中系数定义为：\n$$\n\\alpha_i = \\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 - ri\\right) \\quad (\\text{因为 } S_i=i\\Delta S)\n$$\n$$\n\\beta_i = 1 + \\frac{\\Delta \\tau}{2}\\left(\\sigma^2 i^2 + r\\right)\n$$\n$$\n\\gamma_i = \\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 + ri\\right)\n$$\n左侧定义了一个三对角矩阵，右侧是一个由前一个时间步的值计算出的向量。边界条件 $V_0^j = 0$ 和 $V_M^j = S_{\\max} - K e^{-r\\tau_j}$ 通过修改方程组的第一个和最后一个方程来并入。具体来说，对于 $i=1$，涉及 $V_0^{j+1}$ 的项为零。对于 $i=M-1$，项 $-\\gamma_{M-1}V_M^{j+1}$ 是已知的，并被移到右侧。由此产生的三对角系统在每个时间步被高效求解，以将解从 $\\tau=0$推进到 $\\tau=T$。\n\nCrank–Nicolson 方法的时间离散误差为 $O((\\Delta \\tau)^2)$ 阶。我们可以使用 Richardson 外推法来提高精度。设 $C_N(S_0)$ 是使用 $N$ 个时间步（步长 $\\Delta \\tau = T/N$）在 $S=S_0$ 和 $t=0$ 处的数值解，而 $C_{2N}(S_0)$ 是使用 $2N$ 个时间步（步长 $\\Delta \\tau/2$）的解。误差展开式为：\n$$\nC_N \\approx C_{\\text{true}} + c (\\Delta \\tau)^2, \\quad C_{2N} \\approx C_{\\text{true}} + c (\\Delta \\tau/2)^2\n$$\n求解主误差项并代入，我们得到一个具有更高精度阶 $O((\\Delta \\tau)^4)$ 的外推值 $C_{\\text{RE}}$：\n$$\nC_{\\text{RE}}(S_0) = \\frac{4C_{2N}(S_0) - C_N(S_0)}{3}\n$$\n最后，我们使用 Black–Scholes 公式计算欧式看涨期权在 $t=0$ 时的解析解：\n$$\nC_{\\text{BS}}(S_0,T) = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2)\n$$\n其中\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2) T}{\\sigma \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma \\sqrt{T}\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数。计算数值解（$e_N = |C_N - C_{\\text{BS}}|$、$e_{2N} = |C_{2N} - C_{\\text{BS}}|$）和外推解（$e_{\\text{RE}} = |C_{\\text{RE}} - C_{\\text{BS}}|$）的绝对误差。精度改善因子计算为比率 $\\rho_{N\\to \\mathrm{RE}} = e_N/e_{\\text{RE}}$ 和 $\\rho_{2N\\to \\mathrm{RE}} = e_{2N}/e_{\\text{RE}}$。\n\n如果 $S_0$ 不是网格点，则通过在最终资产网格上进行线性插值来获得 $S=S_0$ 处的数值解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.linalg import solve_banded\n\ndef solve_black_scholes_cn(params):\n    \"\"\"\n    Solves the Black-Scholes PDE using the Crank-Nicolson method.\n    Unpacks S0, K, r, sigma, T, S_max, M, N from a dictionary.\n    Returns the option value at S0, t=0.\n    \"\"\"\n    S0, K, r, sigma, T, S_max, M, N = params['S0'], params['K'], params['r'], params['sigma'], params['T'], params['S_max'], params['M'], params['N']\n\n    # Grid setup\n    dt = T / N  # Time step, in forward tau time\n    ds = S_max / M  # Asset price step\n    S_grid = np.linspace(0, S_max, M + 1)\n    \n    # Grid for interior points i = 1, ..., M-1\n    i_pts = np.arange(1, M)\n    \n    # Coefficients for the tridiagonal matrix\n    alpha = 0.25 * dt * (sigma**2 * i_pts**2 - r * i_pts)\n    beta = 1.0 + 0.5 * dt * (sigma**2 * i_pts**2 + r)\n    gamma = 0.25 * dt * (sigma**2 * i_pts**2 + r * i_pts)\n    \n    # Tridiagonal matrix for the LHS (constant in time)\n    # Using scipy's solve_banded format (l=1, u=1)\n    ab = np.zeros((3, M - 1))\n    ab[0, 1:] = -gamma[:-1]\n    ab[1, :] = beta\n    ab[2, :-1] = -alpha[1:]\n    \n    # Initial condition at tau=0 (t=T)\n    V = np.maximum(S_grid - K, 0)\n    \n    # Time-stepping loop (forward in tau from 0 to T)\n    for j in range(N):\n        tau_jp1 = (j + 1) * dt\n        \n        # RHS vector, computed from known values at time j\n        D = alpha * V[0:M-1] + (2.0 - beta) * V[1:M] + gamma * V[2:M+1]\n        \n        # Apply boundary condition at S=S_max\n        V_M_jp1 = S_max - K * np.exp(-r * tau_jp1)\n        D[-1] += gamma[-1] * V_M_jp1\n        \n        # Solve the tridiagonal system Ax=b\n        V_interior_new = solve_banded((1, 1), ab, D)\n        \n        # Update V for the next time step\n        V[1:M] = V_interior_new\n        V[0] = 0.0  # Dirichlet BC at S=0\n        V[M] = V_M_jp1 # Update boundary for use in next iteration's RHS calculation\n\n    # Interpolate to find V(S0, t=0)\n    if np.isclose(S0 % ds, 0.0) or np.isclose(S0 % ds, ds):\n        k = int(round(S0 / ds))\n        return V[k]\n    else:\n        k = int(S0 / ds)\n        w = (S0 - S_grid[k]) / ds\n        return V[k] * (1.0 - w) + V[k+1] * w\n\ndef black_scholes_analytical(params):\n    \"\"\"\n    Calculates the analytical Black-Scholes price for a European call option.\n    \"\"\"\n    S0, K, r, sigma, T = params['S0'], params['K'], params['r'], params['sigma'], params['T']\n    \n    if T == 0.0:\n        return np.maximum(S0 - K, 0.0)\n    if sigma == 0.0:\n        return np.maximum(S0 - K * np.exp(-r * T), 0.0)\n        \n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'S0': 100, 'K': 100, 'r': 0.03, 'sigma': 0.25, 'T': 1.0, 'S_max_factor': 5, 'M': 800, 'N': 200},\n        {'S0': 80, 'K': 100, 'r': 0.01, 'sigma': 0.15, 'T': 0.25, 'S_max_factor': 5, 'M': 800, 'N': 120},\n        {'S0': 120, 'K': 100, 'r': 0.00, 'sigma': 0.05, 'T': 2.0, 'S_max_factor': 6, 'M': 900, 'N': 240},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        # Calculate S_max based on K and the factor\n        case_params['S_max'] = case_params['K'] * case_params['S_max_factor']\n        \n        # Analytical solution\n        C_BS = black_scholes_analytical(case_params)\n\n        # Numerical solution with N steps\n        params_N = case_params.copy()\n        C_N = solve_black_scholes_cn(params_N)\n        \n        # Numerical solution with 2N steps\n        params_2N = case_params.copy()\n        params_2N['N'] = 2 * case_params['N']\n        C_2N = solve_black_scholes_cn(params_2N)\n        \n        # Richardson extrapolation\n        C_RE = (4.0 * C_2N - C_N) / 3.0\n        \n        # Absolute errors\n        e_N = abs(C_N - C_BS)\n        e_2N = abs(C_2N - C_BS)\n        e_RE = abs(C_RE - C_BS)\n\n        # Improvement factors\n        # Handle division by zero if extrapolated error is zero\n        rho_N_RE = e_N / e_RE if e_RE > 0 else np.inf\n        rho_2N_RE = e_2N / e_RE if e_RE > 0 else np.inf\n\n        results.extend([e_N, e_2N, e_RE, rho_N_RE, rho_2N_RE])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "我们最后的实践将从欧式期权的理想世界迈向更复杂的美式期权领域。提前行权的可能性将线性的Black-Scholes偏微分方程转变为一个更具挑战性的自由边界问题。本练习将展示如何调整我们的Crank-Nicolson求解器来处理这一问题，即在每个时间步引入一个迭代方法——投影逐次超松弛法（PSOR）。这种组合使我们能够强制执行提前行权约束，并隐式地找到最优行权边界，从而解决更贴近现实的金融定价问题。[@problem_id:2439350]", "id": "2439350", "problem": "要求您实现一个数值求解器，用于在 Black–Scholes 框架下计算美式看跌期权的提前行权溢价，该求解器使用 Crank–Nicolson 时间步进格式，并在每个时间步结合投影逐次超松弛 (PSOR) 方法来施加不等式约束。您的程序必须是一个完整的、可运行的程序，它不接受任何输入，并按照下文指定的固定测试套件打印结果。\n\n从以下基本原理开始：\n- 风险中性定价与无套利偏微分方程 (PDE)，该方程用于描述基于不支付或支付股息的标的资产的衍生品的无套利价格。在风险中性测度下，标的资产价格 $S$ 服从几何布朗运动，其漂移率为 $r - q$，其中 $r$ 是连续复利无风险利率，$q$ 是连续股息率。对于一个足够平滑的价格函数 $V(S,t)$，其 Black–Scholes 偏微分方程 (PDE) 为\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其中 $\\sigma$ 是常数波动率，$r$ 是常数无风险利率，$q$ 是常数股息率。\n- 对于执行价格为 $K$、到期日为 $T$ 的美式看跌期权，其价值 $V(S,t)$ 必须满足以下线性互补条件\n$$\nV(S,t) \\geq \\max(K - S, 0), \\quad -\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V \\geq 0,\n$$\n以及逐点互补性\n$$\n\\left(V(S,t) - \\max(K - S, 0)\\right)\\left(-\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V\\right) = 0,\n$$\n对于所有 $S \\geq 0$ 和 $t \\in [0,T)$。终端支付条件为\n$$\nV(S,T) = \\max(K - S, 0).\n$$\n使用符合经济学原理的边界条件：对于美式看跌期权，在所有 $t \\in [0,T]$，下边界 $S = 0$ 处取 $V(0,t) = K$，而在一个足够大的上边界 $S = S_{\\max}$ 处取 $V(S_{\\max}, t) = 0$。\n\n任务要求：\n- 将空间域 $S \\in [0, S_{\\max}]$ 在具有 $N$ 个子区间的均匀网格上离散化，步长 $\\Delta S = S_{\\max} / N$；并将时间域 $[0,T]$ 离散化为 $M$ 个大小为 $\\Delta t = T / M$ 的均匀时间步。对内部网格节点应用 Crank–Nicolson 方法，在每个后向时间步形成一个三对角线性互补问题 (LCP)。\n- 在每个时间步，使用投影逐次超松弛 (PSOR) 方法求解离散的 LCP。迭代必须使用一个超松弛因子 $\\omega \\in (0,2)$，并通过在每个空间节点 $S_i$ 将迭代值投影到障碍 $\\max(K - S_i, 0)$ 上来施加行权约束。\n- 使用线性插值返回给定即期价格 $S_0$ 处的期权价格，该价格点可能不正好落在网格节点上。\n- 所有利率 $r$、$q$ 和波动率 $\\sigma$ 必须以小数形式表示（例如，$5\\%$ 表示为 $0.05$）。时间 $T$ 必须以年为单位。不涉及角度单位。输入或输出中不应出现百分号；仅使用小数。\n\n实现细节期望：\n- 在均匀网格上推导 Crank–Nicolson 半隐式内部节点离散化格式，为新时间层级生成一个三对角左侧矩阵，并使用前一时间层级的值构造一个三对角右侧项，同时一致地整合边界值。不要使用任何美式期权定价的解析解公式或惩罚方法；您必须通过 PSOR 强制执行提前行权约束。\n- 为 PSOR 实现一个停止准则，该准则基于所有内部节点上的最大绝对变化小于容差 $\\varepsilon$，并设置最大迭代次数的硬性上限以保证算法终止。\n- 为确保数值稳定性，请为以下每个测试案例选择足够大的 $S_{\\max}$ 以及足够的空间和时间分辨率。\n\n测试套件：\n为以下每个参数集计算在即期价格 $S_0$ 处的美式看跌期权价格。使用指定的 $S_{\\max}$、$N$、$M$、PSOR 松弛因子 $\\omega$、容差 $\\varepsilon$ 和每时间步最大迭代次数 $I_{\\max}$。参数以元组 $(S_0, K, T, r, q, \\sigma, S_{\\max}, N, M, \\omega, \\varepsilon, I_{\\max})$ 的形式给出：\n- 案例 1 (基准，一年期，中等波动率)：$(100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1\\times 10^{-8}, 10000)$。\n- 案例 2 (一年期，高波动率，低利率)：$(100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1\\times 10^{-8}, 10000)$。\n- 案例 3 (一年期，零利率)：$(100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1\\times 10^{-8}, 10000)$。\n- 案例 4 (短期限，价内)：$(50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1\\times 10^{-8}, 10000)$。\n\n最终输出规格：\n- 您的程序必须生成单行输出，其中包含一个由方括号括起来的、逗号分隔的浮点数列表，这些数字按案例 1 到 4 的顺序排列。\n- 每个数字必须精确到 6 位小数。\n- 例如，输出格式必须类似于 $[v_1,v_2,v_3,v_4]$，其中每个 $v_i$ 是一个四舍五入到 6 位小数的浮点数。", "solution": "用户指定了一个计算金融学问题：通过数值求解带提前行权约束的 Black-Scholes 偏微分方程 (PDE) 来为美式看跌期权定价。该问题具有科学依据、是适定的，并且为完整求解提供了所有必要参数。因此，该问题被视为有效。解决方案要求实现用于时间离散化的 Crank-Nicolson 方法，以及用于处理由提前行权特性产生的线性互补问题的投影逐次超松弛 (PSOR) 方法。\n\n期权价格 $V(S,t)$ 的 Black-Scholes 模型由以下 PDE 给出，其中 $S$ 是标的资产价格，$t$ 是时间：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n此处，$r$ 是无风险利率，$q$ 是连续股息率，$\\sigma$ 是标的资产的波动率。对于美式看跌期权，此方程变为一个不等式，并且由于它是一个自由边界问题，其解必须满足一个线性互补形式。期权价格必须始终大于或等于其内在价值，即 $V(S,t) \\geq \\max(K-S, 0)$，其中 $K$ 是执行价格。\n\n这是一个终端值问题，从到期日 $T$ 开始向后沿时间求解至当前时间 $t=0$。为了便于使用标准的前向步进数值格式，我们对时间进行变量替换，令 $\\tau = T - t$。PDE 变为：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V\n$$\n我们将空间域 $S \\in [0, S_{\\max}]$ 离散化为 $N$ 个大小为 $\\Delta S = S_{\\max}/N$ 的区间，从而创建网格点 $S_i = i\\Delta S$，其中 $i=0, 1, \\dots, N$。时间域 $\\tau \\in [0, T]$ 被离散化为 $M$ 个大小为 $\\Delta \\tau = T/M$ 的步，从而创建时间点 $\\tau_j = j\\Delta\\tau$，其中 $j=0, 1, \\dots, M$。令 $V_i^j$ 表示 $V(S_i, \\tau_j)$ 的数值近似值。\n\nCrank-Nicolson 方法在时间中点 $\\tau_{j+1/2}$ 近似时间导数，并在时间层级 $j$ 和 $j+1$ 上对空间算子取平均：\n$$\n\\frac{V^{j+1} - V^{j}}{\\Delta \\tau} = \\frac{1}{2}(\\mathcal{L}V^{j+1} + \\mathcal{L}V^{j})\n$$\n其中 $\\mathcal{L}$ 是空间微分算子。整理后，在每个时间步我们得到一个需要求解的线性方程组：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j+1} = \\left(\\mathbf{I} + \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j}\n$$\n其中 $\\mathbf{L}$ 是在使用中心有限差分对导数 $\\frac{\\partial V}{\\partial S}$ 和 $\\frac{\\partial^2 V}{\\partial S^2}$ 进行空间离散化后，算子 $\\mathcal{L}$的矩阵表示：\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - V_{i-1}}{2\\Delta S}, \\quad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{(\\Delta S)^2}\n$$\n将这些近似代入算子 $\\mathcal{L}$，可以得到矩阵 $\\mathbf{L}$ 的一个三对角结构。对于每个内部节点 $i=1, \\dots, N-1$，方程为：\n$$\nL_i V_{i-1}^{j+1} + M_i V_i^{j+1} + R_i V_{i+1}^{j+1} = Q_i\n$$\n系数定义如下：\n$$\nL_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 - (r-q)i\\right)\n$$\n$$\nM_i = 1 + \\frac{\\Delta \\tau}{2}\\left(\\sigma^2 i^2 + r\\right)\n$$\n$$\nR_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 + (r-q)i\\right)\n$$\n右侧项 $Q_i$ 由时间步 $j$ 的已知值构造：\n$$\nQ_i = -L_i V_{i-1}^{j} + (2-M_i)V_i^{j} - R_i V_{i+1}^{j}\n$$\n美式看跌期权的边界条件是 $V(0,\\tau) = K$ 和 $V(S_{\\max}, \\tau) = 0$。通过调整右侧向量 $Q$ 来整合这些条件。对于第一个内部节点 $i=1$，项 $L_1 V_0^{j+1}$ 移到右侧，变为 $L_1 K$。类似地，在最后一个内部节点 $i=N-1$ 处，项 $R_{N-1}V_N^{j+1}$ 为 $0$。\n\n提前行权约束要求对于所有 $i$，$V_i^{j+1} \\geq g_i = \\max(K-S_i, 0)$。这将线性系统转化为一个线性互补问题 (LCP)，我们使用投影逐次超松弛 (PSOR) 方法来求解。在每个时间步，我们通过迭代来找到向量 $\\mathbf{V}^{j+1}$。对于每个内部节点 $i$ 的第 $k$ 次迭代，其更新规则如下：\n\n1. 计算标准 SOR 更新：\n$$\nv_i^{*} = (1-\\omega)V_i^{(k)} + \\frac{\\omega}{M_i} \\left( Q_i - L_i V_{i-1}^{(k+1)} - R_i V_{i+1}^{(k)} \\right)\n$$\n其中 $\\omega \\in (0,2)$ 是松弛参数，$V^{(k)}$ 是上一次迭代的向量，$V^{(k+1)}$ 使用当前迭代中已经更新的值。\n\n2. 将结果投影到行权价值（障碍）上：\n$$\nV_i^{(k+1)} = \\max(v_i^{*}, g_i)\n$$\nPSOR 迭代持续进行，直到所有节点上连续迭代值之间的最大绝对变化小于容差 $\\varepsilon$，或达到最大迭代次数 $I_{\\max}$。\n\n总体算法如下：\n1.  在到期日 $\\tau=0$ (即 $t=T$)，用终端收益 $V_i^0 = \\max(K - S_i, 0)$ 初始化期权价值网格 $\\mathbf{V}$。\n2.  从 $j=0$ 到 $M-1$ 进行时间上的后向迭代。在每一步中：\n    a.  使用 $\\mathbf{V}^j$ 的值计算右侧向量 $\\mathbf{Q}$。\n    b.  根据边界条件调整 $\\mathbf{Q}$。\n    c.  使用 PSOR 算法求解 $\\mathbf{V}^{j+1}$ 的 LCP，并将 $\\mathbf{V}^j$ 作为初始猜测值。\n    d.  强制执行边界条件 $V_0^{j+1} = K$ 和 $V_N^{j+1} = 0$。\n3.  在最后一个时间步之后，向量 $\\mathbf{V}^M$ 包含 $t=0$ 时的期权价格。\n4.  使用线性插值来找到特定即期价格 $S_0$ 处的期权价格，该点可能不在网格点上。\n\n此过程为美式看跌期权价格提供了一个稳健的数值解，该解遵循 Black-Scholes 框架下的无套利条件和提前行权约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_american_put_price(S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max):\n    \"\"\"\n    Computes the American put option price using the Crank-Nicolson FDM and PSOR.\n\n    :param S0: Initial stock price\n    :param K: Strike price\n    :param T: Time to maturity (in years)\n    :param r: Risk-free interest rate (decimal)\n    :param q: Continuous dividend yield (decimal)\n    :param sigma: Volatility (decimal)\n    :param S_max: Maximum stock price in the grid\n    :param N: Number of spatial steps\n    :param M: Number of time steps\n    :param omega: SOR relaxation factor\n    :param epsilon: PSOR tolerance\n    :param I_max: Max iterations for PSOR\n    :return: American put option price at S0\n    \"\"\"\n    # 1. Grid setup\n    dt = T / M\n    ds = S_max / N\n    S = np.linspace(0, S_max, N + 1)\n    \n    # 2. Initialize option values at maturity (t=T)\n    V = np.maximum(K - S, 0)\n    \n    # 3. Pre-compute Crank-Nicolson coefficients for the tridiagonal system\n    # These coefficients are used for the matrix on the LHS of the time-step equation.\n    i = np.arange(1, N)  # Interior nodes\n    \n    # Coefficients for L_i * V_{i-1} + M_i * V_i + R_i * V_{i+1} = Q_i\n    L_coeffs = -0.25 * dt * (sigma**2 * i**2 - (r - q) * i)\n    M_coeffs = 1 + 0.5 * dt * (sigma**2 * i**2 + r)\n    R_coeffs = -0.25 * dt * (sigma**2 * i**2 + (r - q) * i)\n\n    # 4. Time-stepping loop (backward from T to 0)\n    for j in range(M - 1, -1, -1):\n        # Calculate the explicit part (RHS) of the CN scheme\n        Q = -L_coeffs * V[:-2] + (2 - M_coeffs) * V[1:-1] - R_coeffs * V[2:]\n\n        # Adjust RHS for boundary conditions\n        # For S=0, V=K. For S=S_max, V=0.\n        # Boundary condition V(0,t)=K affects the equation for the first interior node (i=1)\n        Q[0] += L_coeffs[0] * K  # Term involving V_0 from LHS, moved to RHS\n        Q[0] += L_coeffs[0] * K  # Term involving V_0 from RHS side\n        # V(S_max,t)=0 means the R_coeffs[N-2] term involving V_N is zero, no adjustment needed\n\n        # 5. PSOR solver for the linear complementarity problem at each time step\n        v_interior = V[1:-1].copy()  # Initial guess from previous time step\n        obstacle = np.maximum(K - S[1:-1], 0)\n\n        for k in range(I_max):\n            v_old_iter = v_interior.copy()\n\n            # Iterate through interior nodes\n            for i in range(N - 1):\n                # SOR update calculation\n                sor_sum = 0\n                if i > 0:\n                    sor_sum += L_coeffs[i] * v_interior[i - 1]\n                if i < N - 2:\n                    sor_sum += R_coeffs[i] * v_old_iter[i + 1]\n\n                v_star = (1 - omega) * v_old_iter[i] + (omega / M_coeffs[i]) * (Q[i] - sor_sum)\n                \n                # Projection step\n                v_interior[i] = max(v_star, obstacle[i])\n\n            # Check for convergence\n            if np.max(np.abs(v_interior - v_old_iter)) < epsilon:\n                break\n        \n        # Update V with the solution for the current time step\n        V[1:-1] = v_interior\n        V[0] = K  # Boundary at S=0\n        V[N] = 0.0 # Boundary at S=S_max\n        \n    # 6. Interpolate to find price at S0\n    idx = int(S0 / ds)\n    if idx >= N: # Handle case where S0 is at or beyond S_max\n        return 0.0\n    \n    # Linear interpolation\n    price = V[idx] + (V[idx + 1] - V[idx]) * (S0 - S[idx]) / ds\n    return price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max)\n        (100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1e-8, 10000),\n        (50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1e-8, 10000),\n    ]\n\n    results = []\n    for case in test_cases:\n        params = {\n            \"S0\": case[0], \"K\": case[1], \"T\": case[2], \"r\": case[3], \"q\": case[4], \n            \"sigma\": case[5], \"S_max\": case[6], \"N\": case[7], \"M\": case[8], \n            \"omega\": case[9], \"epsilon\": case[10], \"I_max\": case[11]\n        }\n        price = compute_american_put_price(**params)\n        results.append(f\"{price:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"}]}