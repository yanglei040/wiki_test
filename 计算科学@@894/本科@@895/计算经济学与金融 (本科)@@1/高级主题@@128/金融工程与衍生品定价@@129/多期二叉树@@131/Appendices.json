{"hands_on_practices": [{"introduction": "多周期二叉树模型不仅仅是一个定价工具，它更是一个理解动态风险管理的框架。本练习将复制对冲的核心理论付诸实践。通过为一个期权空头头寸实施动态的 $Delta$ 对冲策略，你将亲眼见证一个由标的资产和无风险债券组成的、不断再平衡的投资组合如何能够完美地复制期权的价值，从而使得理论对冲误差为零 [@problem_id:2412792]。这个实践对于掌握无套利定价的原理至关重要。", "id": "2412792", "problem": "给定一个离散时间、多期的二叉树资产定价模型。设标的资产价格过程 $\\{S_{t}\\}_{t=0}^{N}$ 服从乘法动态，即在每个时期，价格要么上涨一个因子 $u$，要么下跌一个因子 $d$，其中 $u&gt;d&gt;0$。每期的无风险总回报率为 $R$，且满足无套利条件 $d&lt;R&lt;u$。考虑一个基于该资产的欧式看涨期权，其执行价格为 $K$，到期时间步为 $N$。令 $C_{t}$ 表示在给定节点时期权在时间 $t$ 的唯一无套利价值，该价值在风险中性测度下计算，其中概率 $q=(R-d)/(u-d)$，且终端条件为 $C_{N}=\\max(S_{N}-K,0)$。在每个非终端节点，将局部 Delta 定义为复制投资组合中的股票数量，\n$$\n\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}},\n$$\n其中上标表示在上涨或下跌子节点中的价值。\n\n一个交易员在时间 $0$ 卖空一份看涨期权，收取期权费 $C_{0}$，并通过持有 $\\Delta_{t}$ 份股票和一笔无风险账户头寸 $B_{t}$ 来动态对冲该空头头寸。此过程无交易成本并满足自融资约束。初始对冲满足 $B_{0}=C_{0}-\\Delta_{0}S_{0}$。沿着一条长度为 $N$ 的已实现价格路径，令第 $t$ 期末的再平衡前对冲误差为\n$$\ne_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t},\\quad t=1,2,\\dots,N,\n$$\n其中 $C_{t}$ 是在时间 $t$ 到达的节点上的期权价值，且 $C_{N}=\\max(S_{N}-K,0)$。在测量 $e_{t}$ 后，对冲组合在时间 $t$（对于 $t=1,2,\\dots,N-1$）被再平衡至 $\\Delta_{t}$。\n\n您的任务是实现一个程序，对于每个给定的参数集和已实现路径，该程序需要构建二叉树价格树、计算期权价值树、为上述定义的看涨期权空头实施动态 Delta 对冲策略，并返回沿该路径的序列 $\\{e_{t}\\}_{t=1}^{N}$。所有值必须以小数形式表示（不得使用百分号），并且每个 $e_{t}$ 必须四舍五入到 $10$ 位小数。\n\n测试套件。对于以下每个案例，请使用所提供的参数和由上涨/下跌移动组成的已实现路径，其中 $U$ 表示按因子 $u$ 上涨，而 $D$ 表示按因子 $d$ 下跌：\n- 案例 1 (通用多期路径): $S_{0}=100.0$, $u=1.1$, $d=0.9$, $R=1.02$, $K=100.0$, $N=4$, 路径 $[U,D,U,U]$。\n- 案例 2 (边界情况，单期): $S_{0}=50.0$, $u=1.2$, $d=0.8$, $R=1.0$, $K=50.0$, $N=1$, 路径 $[U]$。\n- 案例 3 (边缘情况，零利率且全部下跌): $S_{0}=80.0$, $u=1.25$, $d=0.8$, $R=1.0$, $K=90.0$, $N=3$, 路径 $[D,D,D]$。\n- 案例 4 (边缘情况，深度实值且全部上涨): $S_{0}=100.0$, $u=1.2$, $d=0.8$, $R=1.01$, $K=80.0$, $N=3$, 路径 $[U,U,U]$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。此列表的每个元素都必须是对应测试案例的、经过四舍五入的对冲误差列表 $[e_{1},e_{2},\\dots,e_{N}]$。例如，一个包含两个案例的输出应如下所示：$[[e_{1}^{(1)},\\dots,e_{N\\_{1}}^{(1)}],[e_{1}^{(2)},\\dots,e_{N\\_{2}}^{(2)}]]$，该行中任何地方都不能有空格。", "solution": "问题陈述已通过验证。\n\n已知条件逐字提取如下：\n- 资产价格过程：$\\{S_{t}\\}_{t=0}^{N}$，服从乘法二叉树模型。\n- 上涨因子：$u$。下跌因子：$d$。其中 $u > d > 0$。\n- 每期无风险总回报率：$R$。\n- 无套利条件：$d < R < u$。\n- 衍生品：欧式看涨期权，执行价格 $K$，到期时间 $N$。\n- 期权价值：在时间 $t$ 为 $C_{t}$。\n- 终端条件：$C_{N} = \\max(S_{N}-K, 0)$。\n- 风险中性上涨概率：$q = \\frac{R-d}{u-d}$。\n- 期权估值：在风险中性测度下，意味着 $C_{t} = R^{-1}[q C_{t+1}^{(u)} + (1-q) C_{t+1}^{(d)}]$。\n- 复制投资组合的 Delta：$\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}}$。\n- 对冲策略：卖空一份看涨期权，用 $\\Delta_{t}$ 份股票和一笔无风险账户头寸 $B_{t}$ 进行对冲。\n- 初始对冲：$B_{0}=C_{0}-\\Delta_{0}S_{0}$。\n- 再平衡前对冲误差：$e_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t}$，对于 $t=1, 2, \\dots, N$。\n- 再平衡：在自融资约束下，对冲组合在时间 $t$（对于 $t=1, 2, \\dots, N-1$）被再平衡至 $\\Delta_{t}$。\n- 测试案例：提供了四组特定的参数（$S_{0}, u, d, R, K, N$）和已实现路径。\n- 输出要求：对于每个案例，输出一个包含对冲误差列表 $\\{e_{t}\\}_{t=1}^{N}$ 的列表，误差值四舍五入到 10 位小数。\n\n验证结论：该问题有效。\n该问题具有科学依据，是 Cox-Ross-Rubinstein 二叉树期权定价模型中的一个标准练习，这是计算金融学中的一个基本概念。该问题是适定的；所有参数、定义和约束都已提供，确保可以通过计算确定唯一的解。期权价值、风险中性概率和 delta 的定义都是标准且正确的。该问题是客观的，不包含任何歧义。无套利条件被正确陈述，并且测试案例均满足该条件。问题的核心是验证二叉树模型的中心论点：即衍生品的支付可以通过在标的资产和无风险债券中采取动态、自融资的交易策略来完美复制。因此，根据定义，对冲误差在所有时间步上理论上应为零，任何非零结果仅可归因于浮点数值精度。\n\n下面给出一个完整的解法。该方法论建立在离散时间资产定价的基本原则之上。\n\n首先，我们构建标的资产价格的二叉树格，$\\{S_{t}\\}_{t=0}^{N}$。树中在时间步 $i$（$0 \\le i \\le N$）经过 $j$ 次上涨（$0 \\le j \\le i$）后的节点，其价格由下式给出：\n$$S_{i,j} = S_{0} u^{j} d^{i-j}$$\n\n其次，我们确定树中每个节点的期权价值。这通过后向归纳法完成，从到期日 $t=N$ 的已知期权价值开始。欧式看涨期权在到期日的价值是其内在价值：\n$$C_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{for } j = 0, 1, \\dots, N$$\n对于任何 $i < N$ 的非终端节点 $(i,j)$，无套利期权价值 $C_{i,j}$ 是期权在下一时期价值的贴现期望值，该期望值在风险中性测度下计算。风险中性上涨概率为 $q = \\frac{R-d}{u-d}$。估值公式为：\n$$C_{i,j} = \\frac{1}{R} \\left[ q C_{i+1,j+1} + (1-q) C_{i+1,j} \\right]$$\n这个后向递推计算填充了整个期权价值树 $\\{C_{i,j}\\}$。\n\n第三，我们沿着指定的资产价格移动路径实施动态对冲策略。该策略包括创建一个由 $\\Delta_{t}$ 份资产股票和在无风险账户中的现金头寸 $B_{t}$ 组成的投资组合。该投资组合在时间 $t$ 的价值为 $V_t = \\Delta_t S_t + B_t$。\n\n该策略在 $t=0$ 时启动。初始投资组合被构建以复制期权的价值，$V_0 = C_0$。股票数量 $\\Delta_0$ 由 delta 对冲公式给出：\n$$\\Delta_{0} = \\frac{C_{1,1} - C_{1,0}}{S_{1,1} - S_{1,0}}$$\n然后设置初始现金头寸 $B_0$，以确保投资组合价值与期权价值相匹配：$B_{0} = C_{0,0} - \\Delta_{0}S_{0,0}$。\n\n该投资组合是自融资的。这意味着在任何后续时期 $t > 0$，投资组合构成的任何变化都由内部融资，没有外部的现金注入或提取。在时期 $t$ 的开始（在价格从 $t-1$ 发生变动之后），前一时期投资组合 $(\\Delta_{t-1}, B_{t-1})$ 的价值演变为：\n$$V_{t}^{-} = \\Delta_{t-1}S_{t} + B_{t-1}R$$\n问题将时间 $t$ 的对冲误差定义为该投资组合价值与新节点处理论期权价格 $C_{t}$ 之间的差额：\n$$e_{t} = V_{t}^{-} - C_{t}$$\n二叉树模型的一个核心结果是，复制投资组合的价值 $V_{t}^{-}$ 在每个节点都将精确匹配期权的价值 $C_{t}$。因此，我们预期对于所有 $t$，$e_t = 0$，除非存在数值精度误差。\n\n计算完误差后，为下一时期（如果 $t < N$）对投资组合进行再平衡。新的股票数量 $\\Delta_t$ 基于当前节点的后继节点价值计算：\n$$\\Delta_{t} = \\frac{C_{t+1}^{\\text{(up)}} - C_{t+1}^{\\text{(down)}}}{S_{t+1}^{\\text{(up)}} - S_{t+1}^{\\text{(down)}}}$$\n新的现金头寸 $B_t$ 由自融资条件确定。在再平衡期间，投资组合的价值保持不变，因此再平衡后的价值 $V_t^{+} = \\Delta_t S_t + B_t$ 必须等于再平衡前的价值 $V_t^{-}$。因此，新的现金头寸为：\n$$B_{t} = V_{t}^{-} - \\Delta_{t}S_{t}$$\n沿着路径移动、计算对冲误差和再平衡的此过程将重复进行，直到在 $t=N$ 到期。计算出的误差序列 $\\{e_t\\}_{t=1}^N$ 是给定路径的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        {'S0': 100.0, 'u': 1.1, 'd': 0.9, 'R': 1.02, 'K': 100.0, 'N': 4, 'path': ['U', 'D', 'U', 'U']},\n        {'S0': 50.0, 'u': 1.2, 'd': 0.8, 'R': 1.0, 'K': 50.0, 'N': 1, 'path': ['U']},\n        {'S0': 80.0, 'u': 1.25, 'd': 0.8, 'R': 1.0, 'K': 90.0, 'N': 3, 'path': ['D', 'D', 'D']},\n        {'S0': 100.0, 'u': 1.2, 'd': 0.8, 'R': 1.01, 'K': 80.0, 'N': 3, 'path': ['U', 'U', 'U']}\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = _calculate_hedging_errors(\n            S0=case['S0'],\n            u=case['u'],\n            d=case['d'],\n            R=case['R'],\n            K=case['K'],\n            N=case['N'],\n            path=case['path']\n        )\n        results.append(errors)\n    \n    # Format the final output string precisely as required.\n    inner_parts = []\n    for err_list in results:\n        # Format each error to a string with the required precision.\n        # Although the errors are theoretically zero, they may be small non-zero floats.\n        # We ensure standard float representation e.g. '0.0' instead of '0'\n        # The rounding is already done, this is for formatting.\n        formatted_list = [f\"{err:.10f}\".rstrip('0').rstrip('.') if err != 0 else '0.0' for err in err_list]\n        inner_parts.append(f\"[{','.join(formatted_list)}]\")\n        \n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef _calculate_hedging_errors(S0: float, u: float, d: float, R: float, K: float, N: int, path: list[str]) -> list[float]:\n    \"\"\"\n    Calculates the sequence of dynamic hedging errors for a given path.\n\n    Args:\n        S0: Initial asset price.\n        u: Up-move factor.\n        d: Down-move factor.\n        R: Gross risk-free return per period.\n        K: Option strike price.\n        N: Number of periods to maturity.\n        path: A list of 'U' or 'D' strings representing the realized path.\n\n    Returns:\n        A list of hedging errors {e_t} for t=1,...,N, rounded to 10 decimal places.\n    \"\"\"\n    # 1. Construct asset price and option value trees\n    # Risk-neutral probability\n    q = (R - d) / (u - d)\n\n    # Initialize trees\n    S_tree = np.zeros((N + 1, N + 1))\n    C_tree = np.zeros((N + 1, N + 1))\n\n    # Populate asset price tree S[i,j] = price at time i after j up-moves\n    for i in range(N + 1):\n        for j in range(i + 1):\n            S_tree[i, j] = S0 * (u**j) * (d**(i - j))\n\n    # Populate option value tree at maturity (t=N)\n    C_tree[N, :] = np.maximum(S_tree[N, :] - K, 0)\n\n    # Populate option value tree by backward induction\n    for i in range(N - 1, -1, -1):\n        for j in range(i + 1):\n            C_up = C_tree[i + 1, j + 1]\n            C_down = C_tree[i + 1, j]\n            C_tree[i, j] = (q * C_up + (1 - q) * C_down) / R\n\n    # 2. Trace the path and compute hedging errors\n    hedging_errors = []\n    \n    # Initial portfolio setup at t=0\n    num_ups = 0  # number of up moves from t=0\n    \n    # Initial delta (Delta_0)\n    delta_prev = (C_tree[1, 1] - C_tree[1, 0]) / (S_tree[1, 1] - S_tree[1, 0])\n    \n    # Initial bond position (B_0)\n    B_prev = C_tree[0, 0] - delta_prev * S_tree[0, 0]\n\n    # Iterate along the path from t=1 to N\n    for t in range(1, N + 1):\n        # Determine current node based on path\n        move = path[t - 1]\n        if move == 'U':\n            num_ups += 1\n        \n        # Current asset and option values at node (t, num_ups)\n        current_S = S_tree[t, num_ups]\n        current_C = C_tree[t, num_ups]\n        \n        # Value of hedge portfolio before rebalancing\n        portfolio_val_pre_rebalance = delta_prev * current_S + B_prev * R\n        \n        # Calculate hedging error e_t\n        error = portfolio_val_pre_rebalance - current_C\n        hedging_errors.append(round(error, 10))\n\n        # Rebalance the portfolio for the next period (if not at maturity)\n        if t < N:\n            # Calculate new delta (Delta_t) at the current node\n            delta_curr = (C_tree[t + 1, num_ups + 1] - C_tree[t + 1, num_ups]) / \\\n                         (S_tree[t + 1, num_ups + 1] - S_tree[t + 1, num_ups])\n            \n            # Calculate new bond position (B_t) to maintain self-financing\n            # New portfolio value V_t+ must equal V_t-\n            B_curr = portfolio_val_pre_rebalance - delta_curr * current_S\n            \n            # Update portfolio for the next iteration\n            delta_prev = delta_curr\n            B_prev = B_curr\n\n    return hedging_errors\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "掌握了基本的定价机制后，就应该将其应用于更多样化的金融工具。本练习介绍了一种有封顶看涨期权 (capped call option)，这是一种常见的奇异期权，其潜在利润是有限的。通过为该期权定价，你将练习如何调整标准的二叉树估值框架以适应非标准的收益结构，从而加深你对风险中性定价如何灵活应用于各种衍生品的理解 [@problem_id:2412781]。", "id": "2412781", "problem": "考虑一个无摩擦且无套利的市场。某单一风险资产的当前价格为 $S_0 = 100$，其价格在 $N = 3$ 个等長时期内根据一个重组二叉树模型演变，每期恒定的上涨因子为 $u = 1.2$，下跌因子为 $d = 0.9$。无风险资产以每期恒定的有效利率 $r = 0.05$ 增长，因此每期总回报率为 $R = 1 + r = 1.05$。该风险资产不支付股息。\n\n一份以该风险资产为标的的欧式封顶看涨期权，其执行价格为 $K = 100$，封顶金额为 $C = 15$。其在到期日 $T$ 的回报由 $\\min\\!\\big(\\max(S_T - K, 0), C\\big)$ 给出。假定上述二叉树模型和参数在期权的整个存续期内均有效。\n\n在此二叉树模型中，根据无套利原则，计算该封顶看涨期权在时间 $t=0$ 时的无套利价格。请以与 $S_0$ 相同的货币单位表示您的最终答案，并将答案四舍五入到4位有效数字。请勿在最终数值中包含任何货币符号。", "solution": "所述问题是有效的。这是一个在量化金融领域中自洽且有科学依据的问题。二叉树期权定价模型所需的所有参数均已提供：初始资产价格 $S_0$、上涨因子 $u$、下跌因子 $d$、无风险利率 $r$、时期数 $N$，以及衍生品的具体回报结构（一份执行价格为 $K$、封顶金额为 $C$ 的欧式封顶看涨期权）。该模型基于金融理论的基石——无套利基本原则。唯一风险中性概率存在的无套利条件 $d < R < u$ (其中 $R = 1+r$) 是满足的。给定 $d=0.9$、$u=1.2$ 及 $R=1.05$，我们有 $0.9 < 1.05 < 1.2$。因此，该问题是适定的，并且可以计算出唯一的无套利价格。\n\n该欧式封顶看涨期权在时间 $t=0$ 的价格（记为 $V_0$）由风险中性定价原则确定。该原则指出，衍生品的当前价格是其未来回报的贴现期望值，其中期望是在风险中性概率测度下计算的，贴现则使用无风险利率。\n\n首先，我们必须计算资产价格上涨的风险中性概率 $q$。$q$ 的公式由以下条件推导得出：在风险中性测度下，风险资产的期望回报必须等于无风险回报。\n$$\nq S_0 u + (1-q) S_0 d = S_0 R\n$$\n解出 $q$ 可得：\n$$\nq = \\frac{R - d}{u - d}\n$$\n代入给定值：$R = 1.05$、$u = 1.2$ 和 $d = 0.9$。\n$$\nq = \\frac{1.05 - 0.9}{1.2 - 0.9} = \\frac{0.15}{0.30} = 0.5\n$$\n价格下跌的概率为 $1 - q = 1 - 0.5 = 0.5$。\n\n该问题涉及 $N=3$ 个时期。标的资产在到期日的价格 $S_T = S_3$ 可能有 $N+1 = 4$ 个不同的值。设 $j$ 为 $N$ 个时期内价格上涨的次数。到期日的资产价格由 $S_3(j) = S_0 u^j d^{N-j}$ 给出。可能的期末价格为：\n-   当 $j=3$ (3次上涨)时：$S_3(3) = 100 \\times (1.2)^3 = 100 \\times 1.728 = 172.8$\n-   当 $j=2$ (2次上涨, 1次下跌)时：$S_3(2) = 100 \\times (1.2)^2 \\times (0.9)^1 = 100 \\times 1.44 \\times 0.9 = 129.6$\n-   当 $j=1$ (1次上涨, 2次下跌)时：$S_3(1) = 100 \\times (1.2)^1 \\times (0.9)^2 = 100 \\times 1.2 \\times 0.81 = 97.2$\n-   当 $j=0$ (3次下跌)时：$S_3(0) = 100 \\times (0.9)^3 = 100 \\times 0.729 = 72.9$\n\n接下来，我们计算在每种期末资产价格下，期权在到期日的回报 $V_3$。回报定义为 $V_3 = \\min(\\max(S_3 - K, 0), C)$，其中执行价格 $K=100$，封顶金额 $C=15$。\n-   $S_3(3) = 172.8$ 时的回报：$V_3(3) = \\min(\\max(172.8 - 100, 0), 15) = \\min(72.8, 15) = 15$。\n-   $S_3(2) = 129.6$ 时的回报：$V_3(2) = \\min(\\max(129.6 - 100, 0), 15) = \\min(29.6, 15) = 15$。\n-   $S_3(1) = 97.2$ 时的回报：$V_3(1) = \\min(\\max(97.2 - 100, 0), 15) = \\min(0, 15) = 0$。\n-   $S_3(0) = 72.9$ 时的回报：$V_3(0) = \\min(\\max(72.9 - 100, 0), 15) = \\min(0, 15) = 0$。\n\n在时间 $t=0$ 时的无套利价格是在风险中性测度下期望回报的现值。在 $N$ 个时期内实现 $j$ 次上涨的状态的概率遵循参数为 $q$ 的二项分布。该概率由 $\\binom{N}{j} q^j (1-q)^{N-j}$ 给出。\n$$\nV_0 = \\frac{1}{R^N} \\sum_{j=0}^{N} \\binom{N}{j} q^j (1-q)^{N-j} V_3(j)\n$$\n代入 $N=3$、$R=1.05$ 和 $q=0.5$：\n$$\nV_0 = \\frac{1}{(1.05)^3} \\left[ \\binom{3}{0}(0.5)^3 V_3(0) + \\binom{3}{1}(0.5)^3 V_3(1) + \\binom{3}{2}(0.5)^3 V_3(2) + \\binom{3}{3}(0.5)^3 V_3(3) \\right]\n$$\n二项式系数为 $\\binom{3}{0}=1$、$\\binom{3}{1}=3$、$\\binom{3}{2}=3$、$\\binom{3}{3}=1$。\n$$\nV_0 = \\frac{(0.5)^3}{(1.05)^3} \\left[ 1 \\cdot V_3(0) + 3 \\cdot V_3(1) + 3 \\cdot V_3(2) + 1 \\cdot V_3(3) \\right]\n$$\n代入计算出的回报值：\n$$\nV_0 = \\frac{0.125}{(1.05)^3} \\left[ 1 \\cdot 0 + 3 \\cdot 0 + 3 \\cdot 15 + 1 \\cdot 15 \\right]\n$$\n$$\nV_0 = \\frac{0.125}{(1.05)^3} \\left[ 45 + 15 \\right] = \\frac{0.125 \\times 60}{(1.05)^3} = \\frac{7.5}{(1.05)^3}\n$$\n现在，我们计算数值。\n$$\n(1.05)^3 = 1.157625\n$$\n$$\nV_0 = \\frac{7.5}{1.157625} \\approx 6.4788506...\n$$\n问题要求将答案四舍五入到4位有效数字。\n$$\nV_0 \\approx 6.479\n$$\n这就是该欧式封顶看涨期权在时间 $t=0$ 的无套利价格。", "answer": "$$\n\\boxed{6.479}\n$$"}, {"introduction": "真实世界的市场动态很少能用简单的上涨或下跌来完全概括。这个进阶练习将挑战你将二叉树模型扩展为一个三叉树框架，其中包含了资产价格突然“崩盘”的状态。本练习要求你从第一性原理出发，为一个三态世界重新推导风险中性概率，并在计算上处理非复合树，这展示了无套利定价的核心原则如何能被推广到更复杂、更现实的市场模型中 [@problem_id:2412769]。", "id": "2412769", "problem": "给定一个离散时间、多期的资产定价模型，该模型通过增加一个崩盘状态，将经典的二叉树模型扩展为三叉树模型。标的资产在时刻 $t$ 的价格，记为 $S_t$，在 $N$ 个等长的时期内演变。在每个时期，给定当前价格 $S$，下一期的价格 $S^{\\prime}$ 可以取三个值之一：$S u$、$S d$ 或 $S j$，其中 $j<d<1<u$。在每个时期，价格崩盘至 $S j$ 的结果以一个外生给定的概率 $\\alpha \\in (0,1)$ 发生。设 $p_u$ 和 $p_d$ 分别表示在任何时期价格移动到 $S u$ 和 $S d$ 的概率。每期的连续复利无风险利率为 $r$（以小数而非百分比表示），因此每期的无风险总回报为 $R = e^{r}$。假设 $u$、$d$、$j$、$\\alpha$ 和 $r$ 不随时间变化。在风险中性概率测度下，单期无套利条件是：概率之和为一，且折现后的资产价格是一个鞅。等价地，\n$$\np_u + p_d + \\alpha = 1,\n\\qquad\np_u u + p_d d + \\alpha j = R,\n$$\n并且满足 $0 \\leq p_u \\leq 1-\\alpha$ 和 $0 \\leq p_d \\leq 1-\\alpha$。考虑一个行权价为 $K$、到期时间为 $N$ 期的欧式看跌期权。其到期回报为 $(K - S_N)^+$，其中 $x^+ = \\max\\{x,0\\}$。设 $V_t$ 表示在时刻 $t$、标的价格为 $S$ 的给定节点上的期权价值。在到期日 $t=N$ 时，$V_N = (K - S_N)^+$。对于任意时刻 $t \\in \\{0,1,\\dots,N-1\\}$、标的价格为 $S$ 的内部节点，根据风险中性测度进行的无套利估值满足\n$$\nV_t = \\frac{1}{R}\\left( p_u V_{t+1}^{(u)} + p_d V_{t+1}^{(d)} + \\alpha V_{t+1}^{(j)} \\right),\n$$\n其中 $V_{t+1}^{(u)}$、$V_{t+1}^{(d)}$ 和 $V_{t+1}^{(j)}$ 分别是下一期对应于标的价格 $S u$、$S d$ 和 $S j$ 的节点上的期权价值。对于每个测试用例，仅使用上述定义，计算该模型下期权的时刻0价格 $V_0$。所有利率必须按小数（而非百分比）处理，且每期总回报必须按 $R = e^{r}$ 计算。崩盘概率 $\\alpha$ 是外生给定的，与 $S$ 或 $t$ 无关。\n\n测试用例参数（每项按顺序指定 $(S_0,K,N,u,d,j,\\alpha,r)$）：\n\n- 测试用例 1 (一般情况): $(100.0, 100.0, 3, 1.12, 0.92, 0.60, 0.05, 0.02)$。\n- 测试用例 2 (二叉树边界 $\\alpha=0$): $(100.0, 100.0, 3, 1.10, 0.90, 0.60, 0.00, 0.00)$。\n- 测试用例 3 (边界情况 $p_u = 0$): $(80.0, 100.0, 2, 1.20, 0.95, 0.50, 0.10, \\ln(0.905))$。\n- 测试用例 4 (边界情况 $p_d = 0$): $(100.0, 120.0, 1, 1.15, 0.85, 0.50, 0.10, \\ln(1.085))$。\n\n你的程序必须输出一行，其中包含所有四个测试用例的期权价格，按给定顺序排列，形式为一个用方括号括起来的逗号分隔列表，其中每个数字是四舍五入到六位小数的浮点值，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是测试用例 $i$ 的计算价格。", "solution": "该问题要求在一个指定的三叉树资产定价模型中，计算一个欧式看跌期权在时刻 $t=0$ 的价格。该模型在每个时期包含三种可能的价格变动：按因子 $u$ 上涨，按因子 $d$ 下跌，以及按因子 $j$ 崩盘。估值将在风险中性测度下进行，采用倒推归纳法原则。\n\n首先，我们必须确定分别对应上涨和下跌的风险中性概率 $p_u$ 和 $p_d$。崩盘的概率 $\\alpha$ 是给定的。问题提供了风险中性测度下的无套利条件：\n$$\np_u + p_d + \\alpha = 1\n$$\n$$\np_u u + p_d d + \\alpha j = R\n$$\n其中 $R = e^r$ 是每期的无风险总回报。这个关于两个变量 $p_u$ 和 $p_d$ 的二元一次方程组可以直接求解。从第一个方程，我们将 $p_d$ 表示为 $p_u$ 的函数：\n$$\np_d = 1 - \\alpha - p_u\n$$\n将此代入第二个方程得到：\n$$\np_u u + (1 - \\alpha - p_u)d + \\alpha j = R\n$$\n$$\np_u u + d - \\alpha d - p_u d = R - \\alpha j\n$$\n$$\np_u (u - d) = R - d - \\alpha(j - d)\n$$\n由于问题声明 $u > d$，项 $(u-d)$ 非零，这保证了 $p_u$ 有唯一解：\n$$\np_u = \\frac{R - d - \\alpha(j - d)}{u - d}\n$$\n一旦计算出 $p_u$，$p_d$ 即可立即求得。对于一个有效的无套利模型，这些概率必须满足 $0 \\le p_u \\le 1-\\alpha$ 和 $0 \\le p_d \\le 1-\\alpha$。\n\n欧式看跌期权的估值从期权的到期日 $t=N$ 开始，通过倒推归纳法进行。在任何时刻 $t$ 的资产价格状态可以由一个三元组 $(n_u, n_d, n_j)$ 唯一确定，其中 $n_u$、$n_d$ 和 $n_j$ 分别是自 $t=0$ 以来发生的上涨、下跌和崩盘移动的次数。这些次数的总和必须是 $n_u + n_d + n_j = t$。此节点上的资产价格由 $S_t(n_u, n_d, n_j) = S_0 u^{n_u} d^{n_d} j^{n_j}$ 给出。\n\n算法如下：\n\n1.  **在到期日初始化 ($t=N$)**:\n    对于每个满足 $n_u+n_d+n_j=N$ 的可能终端状态 $(n_u, n_d, n_j)$，我们计算资产价格 $S_N = S_0 u^{n_u} d^{n_d} j^{n_j}$。在此终端节点，看跌期权的价值是其内在价值：\n    $$\n    V_N(n_u, n_d, n_j) = \\max(K - S_N, 0)\n    $$\n    所有可能的终端状态的这些价值都会被储存起来。\n\n2.  **倒推递归 ($t = N-1, \\dots, 0$)**:\n    我们从时刻 $t=N-1$ 向后迭代至 $t=0$。对于每个时间步 $t$ 和在该时刻的每个可能状态 $(n_u, n_d, n_j)$，期权价值 $V_t(n_u, n_d, n_j)$ 是在风险中性测度下，下一时期权价值的折现期望值。在时刻 $t$ 的一个节点 $(n_u, n_d, n_j)$ 会转移到时刻 $t+1$ 的三个可能节点之一：\n    - 上涨移动导致状态 $(n_u+1, n_d, n_j)$。\n    - 下跌移动导致状态 $(n_u, n_d+1, n_j)$。\n    - 崩盘移动导致状态 $(n_u, n_d, n_j+1)$。\n    这些后继节点上的期权价值，我们可以记为 $V_{t+1}^{(u)}$、$V_{t+1}^{(d)}$ 和 $V_{t+1}^{(j)}$，已在归纳法的前一步中计算出来。因此，当前节点的价值为：\n    $$\n    V_t(n_u, n_d, n_j) = \\frac{1}{R} \\left( p_u V_{t+1}(n_u+1, n_d, n_j) + p_d V_{t+1}(n_u, n_d+1, n_j) + \\alpha V_{t+1}(n_u, n_d, n_j+1) \\right)\n    $$\n    对时刻 $t$ 的所有状态都执行此计算。\n\n3.  **最终结果 ($t=0$)**:\n    当我们到达时刻 $t=0$ 时，过程终止。此时，只有一个状态 $(0,0,0)$，对应于初始价格 $S_0$。计算出的价值 $V_0(0,0,0)$ 就是该欧式看跌期权的价格。\n\n当此过程通过计算实现时，将为每个给定的测试用例得出正确的期权价格。在任何时间步 $t$ 的状态数为 $\\frac{(t+2)(t+1)}{2}$，对于给定的参数，这在计算上是可行的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the European put option prices for the given test cases\n    using a trinomial tree model with a crash state.\n    \"\"\"\n\n    def price_european_put(params):\n        \"\"\"\n        Calculates the price of a European put option using backward induction\n        on a non-recombining trinomial tree.\n\n        Args:\n            params (tuple): A tuple containing the model parameters\n                            (S0, K, N, u, d, j, alpha, r).\n\n        Returns:\n            float: The time-0 price of the option.\n        \"\"\"\n        S0, K, N, u, d, j, alpha, r = params\n\n        # Step 1: Calculate risk-neutral parameters\n        R = np.exp(r)\n        \n        # We must handle the case where u-d is very close to zero to avoid division issues,\n        # but the problem constraints j < d < 1 < u ensure u > d.\n        # Also, if alpha=1, p_u=p_d=0, if R = j.\n        if (u - d) == 0:\n            # This case is ruled out by the problem statement (u > d)\n            # but as a matter of defensive programming, must be handled.\n            # If u=d, for no-arbitrage R must be u, and j can be anything.\n            # The risk would not be spanned.\n            # This logic path should not be taken by the test cases.\n            return np.nan\n        \n        # Handle the case of the standard binomial model where alpha = 0.\n        # Here j is irrelevant.\n        if alpha == 0:\n            p_u = (R - d) / (u - d)\n            p_d = 1.0 - p_u\n        else:\n            p_u = (R - d - alpha * (j - d)) / (u - d)\n            p_d = 1.0 - alpha - p_u\n\n        # A dictionary to store option values. The key is a tuple (n_u, n_d, n_j)\n        # representing the number of up, down, and jump moves.\n        values = {}\n\n        # Step 2: Initialization at maturity (t=N)\n        for n_u in range(N + 1):\n            for n_d in range(N - n_u + 1):\n                n_j = N - n_u - n_d\n                S_N = S0 * (u**n_u) * (d**n_d) * (j**n_j)\n                values[(n_u, n_d, n_j)] = max(K - S_N, 0)\n        \n        # Step 3: Backward induction from t=N-1 to t=0\n        for t in range(N - 1, -1, -1):\n            next_values = {}\n            for n_u in range(t + 1):\n                for n_d in range(t - n_u + 1):\n                    n_j = t - n_u - n_d\n                    \n                    # Get values from the next time step\n                    val_u = values[(n_u + 1, n_d, n_j)]\n                    val_d = values[(n_u, n_d + 1, n_j)]\n                    val_j = values[(n_u, n_d, n_j + 1)]\n                    \n                    # Calculate discounted expected value\n                    expected_value = p_u * val_u + p_d * val_d + alpha * val_j\n                    next_values[(n_u, n_d, n_j)] = expected_value / R\n            \n            values = next_values\n            \n        # The final price is at t=0, state (0,0,0)\n        return values.get((0, 0, 0), 0.0)\n\n    # Test suite parameters (S0, K, N, u, d, j, alpha, r)\n    test_cases = [\n        (100.0, 100.0, 3, 1.12, 0.92, 0.60, 0.05, 0.02),\n        (100.0, 100.0, 3, 1.10, 0.90, 0.60, 0.00, 0.00),\n        (80.0, 100.0, 2, 1.20, 0.95, 0.50, 0.10, np.log(0.905)),\n        (100.0, 120.0, 1, 1.15, 0.85, 0.50, 0.10, np.log(1.085)),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = price_european_put(case)\n        results.append(result)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```"}]}