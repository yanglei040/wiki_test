{"hands_on_practices": [{"introduction": "在构建收益率曲线之前，我们必须掌握一个核心原则：无套利定价。这个原则不仅适用于固定现金流的债券，也适用于现金流不确定的复杂金融工具。这个练习将挑战你应用复制和对冲的基本思想，利用可交易的远期合约，将与大宗商品价格挂钩的随机现金流转化为等价的确定性现金流，这是将复杂工具纳入收益率曲线构建的关键一步。[@problem_id:2377875]", "id": "2377875", "problem": "要求您在一些可用债券的票息支付不固定，而是与商品价格指数线性挂钩的情况下，引导构建一条贴现曲线。假设市场无摩擦、无套利，且商品远期合约具有流动性，可以在初始时以零成本进行交易。您在时间 $0$ 观察到以下工具：\n- 一张在时间 $0.5$ 到期的零息国库券，其每单位面值的价格所隐含的贴现因子为 $D(0,0.5)=0.97$。\n- 一张一年期的商品挂钩票据（面值 $100$），其价格为 $P_{\\mathrm{CLN}}=101.00$。它在时间 $0.5$ 和 $1$ 支付票息，每次票息等于 $r N \\cdot \\frac{I_t}{I_0}$，其中票面利率 $r=0.04$，名义本金 $N=100$，商品指数在时间 $t$ 的水平为 $I_t$。在到期日 $t=1$ 时，它还会偿还本金 $N=100$。当前指数水平为 $I_0=100$。\n- 针对同一指数的商品远期曲线：交割日在 $t=0.5$ 的远期价格为 $F(0,0.5)=105$，交割日在 $t=1$ 的远期价格为 $F(0,1)=110$。\n\n在无套利和一价定律的假设下，您希望使用这些工具来推断贴现因子。以下哪种程序在引导构建中纳入商品挂钩票据是与套利相一致的，并且隐含的一年期贴现因子 $D(0,1)$ 是多少？\n\nA. 通过在时间 $0$ 卖空 $K_t=rN/I_0$ 单位在每个票息日 $t\\in\\{0.5,1\\}$ 到期的指数远期合约，来复制并对冲掉每笔票息中的指数风险，从而将每笔随机票息 $rN\\cdot \\frac{I_t}{I_0}$ 转换为确定性现金流 $K_t \\cdot F(0,t)=\\frac{rN}{I_0}F(0,t)$。使用这些对冲后的现金流和 $D(0,0.5)$ 来求解 $D(0,1)$。这得出 $D(0,1)\\approx 0.9284$。\n\nB. 使用真实世界测度（RWM）下的指数预期增长，取 $E[I_{0.5}]=I_0\\cdot(1.02)$ 和 $E[I_{1}]=I_0\\cdot(1.02)^2$，用其期望值替换随机票息，然后使用 $D(0,0.5)$ 和 $D(0,1)$ 进行贴现以求解 $D(0,1)$。这得出 $D(0,1)\\approx 0.932$。\n\nC. 将每笔票息中的指数水平替换为当前即期水平 $I_0$，使票息实际固定为 $rN$，然后按照标准固定利率债券的程序求解 $D(0,1)$。这得出 $D(0,1)\\approx 0.934$。\n\nD. 由于其现金流是随机的，将商品挂钩票据从引导构建中排除；仅使用具有确定性现金流的工具以避免模型依赖。\n\n选择唯一的最佳答案。", "solution": "问题陈述经过验证。\n\n**步骤1：提取已知条件**\n- **市场假设：** 无摩擦、无套利市场。流动的商品远期合约，初始成本为零。\n- **工具1（国库券）：** 在 $t=0.5$ 到期。其价格隐含贴现因子 $D(0,0.5) = 0.97$。\n- **工具2（商品挂钩票据，CLN）：** 面值（名义本金）$N=100$。在时间 $0$ 的价格为 $P_{\\mathrm{CLN}}=101.00$。到期日为 $t=1$。它在 $t=0.5$ 和 $t=1$ 支付票息。在时间 $t$ 的票息支付为 $C_t = r N \\cdot \\frac{I_t}{I_0}$，其中 $r=0.04$ 且 $I_0=100$。它在 $t=1$ 时偿还本金 $N=100$。\n- **工具3（商品远期）：** 交割日为 $t=0.5$ 的远期价格为 $F(0,0.5)=105$。交割日为 $t=1$ 的远期价格为 $F(0,1)=110$。\n- **目标：** 确定与套利相一致的程序，并计算出隐含的一年期贴现因子 $D(0,1)$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在无套利定价理论的标准框架内定义明确。所提供的金融工具和市场数据是量化金融问题的基本要素。在有对冲工具可用的情况下，使用具有随机现金流的工具来引导构建收益率曲线的概念具有科学依据。该问题是客观的，并为在无套利条件下得出唯一解提供了所有必要信息。问题陈述中没有内部矛盾、事实不准确或含糊不清之处。对于一个理论练习来说，这些数据在数值上是合理的。\n\n**步骤3：结论和行动**\n问题陈述有效。将推导解决方案。\n\n**推导**\n\n无套利定价的基本原则规定，任何资产的价格都是其未来现金流的现值。对于随机现金流，其现值是通过构建一个具有确定性现金流的、由可交易资产组成的复制投资组合来确定的。\n\n商品挂钩票据（CLN）具有以下现金流：\n1.  在 $t=0.5$ 的一笔随机票息：$C_{0.5} = rN \\frac{I_{0.5}}{I_0}$。\n2.  在 $t=1$ 的一笔随机票息：$C_{1} = rN \\frac{I_{1}}{I_0}$。\n3.  在 $t=1$ 的一笔确定性本金偿还：$N=100$。\n\nCLN 在时间 $t=0$ 的价格由下式给出：\n$$ P_{\\mathrm{CLN}} = \\text{PV}(C_{0.5}) + \\text{PV}(C_{1}) + \\text{PV}(N) $$\n其中 $\\text{PV}(\\cdot)$ 表示在时间 $t=0$ 的现值。\n\n为了求出随机票息的现值，我们必须对冲与指数水平 $I_t$ 相关的不确定性。这可以通过使用可用的远期合约来实现。考虑一笔一般的票息支付 $C_t = rN \\frac{I_t}{I_0}$。在时间 $t=0$，我们可以建立一个交割日为时间 $t$ 的指数远期合约的空头头寸。签订远期合约的初始成本为零。\n\n让我们卖空 $K_t$ 单位的远期合约。在到期日 $t$，该头寸产生的现金流为 $K_t \\cdot (F(0,t) - I_t)$。\n在时间 $t$，来自票息和对冲的总现金流为：\n$$ \\text{Total CF at } t = C_t + K_t \\cdot (F(0,t) - I_t) = \\frac{rN}{I_0}I_t + K_t \\cdot F(0,t) - K_t \\cdot I_t $$\n为了使该现金流成为确定性的（即，独立于随机变量 $I_t$），我们必须将 $I_t$ 的系数设为零：\n$$ \\frac{rN}{I_0} - K_t = 0 \\implies K_t = \\frac{rN}{I_0} $$\n通过这种对冲，时间 $t$ 的现金流变成一个等于以下的确定性金额：\n$$ \\text{Hedged CF at } t = K_t \\cdot F(0,t) = \\frac{rN}{I_0} F(0,t) $$\n由于远期对冲的建立成本为零，一价定律意味着随机票息 $C_t$ 的现值必须等于其确定性的、已对冲的等价物的现值：\n$$ \\text{PV}(C_t) = \\text{PV}\\left(\\frac{rN}{I_0} F(0,t)\\right) = D(0,t) \\cdot \\left(\\frac{rN}{I_0} F(0,t)\\right) $$\n将此应用于 CLN，其价格方程为：\n$$ P_{\\mathrm{CLN}} = D(0,0.5) \\left[ \\frac{rN}{I_0} F(0,0.5) \\right] + D(0,1) \\left[ \\frac{rN}{I_0} F(0,1) + N \\right] $$\n我们现在可以代入给定值来求解 $D(0,1)$。\n- $P_{\\mathrm{CLN}} = 101.00$\n- $D(0,0.5) = 0.97$\n- $r=0.04$, $N=100$, $I_0=100 \\implies \\frac{rN}{I_0} = \\frac{0.04 \\cdot 100}{100} = 0.04$\n- $F(0,0.5)=105$\n- $F(0,1)=110$\n\n在 $t=0.5$ 的对冲后票息为 $0.04 \\cdot 105 = 4.20$。\n在 $t=1$ 的对冲后票息为 $0.04 \\cdot 110 = 4.40$。\n在 $t=1$ 的总现金流是对冲后票息与本金之和：$4.40 + 100 = 104.40$。\n\n定价方程变为：\n$$ 101.00 = 0.97 \\cdot (4.20) + D(0,1) \\cdot (104.40) $$\n$$ 101.00 = 4.074 + 104.40 \\cdot D(0,1) $$\n求解 $D(0,1)$:\n$$ 104.40 \\cdot D(0,1) = 101.00 - 4.074 = 96.926 $$\n$$ D(0,1) = \\frac{96.926}{104.40} \\approx 0.928410... $$\n因此，正确的一年期贴现因子约为 $D(0,1) \\approx 0.9284$。\n\n**逐项分析**\n\n**A. 复制并对冲指数风险...这得出 $D(0,1)\\approx 0.9284$。**\n此选项描述了从无套利定价的第一性原理推导出的精确复制和对冲程序。需要卖空的远期合约数量 $K_t=rN/I_0$是正确的。由此产生的确定性现金流 $\\frac{rN}{I_0}F(0,t)$ 是正确的。计算得出 $D(0,1) \\approx 0.9284$，与我们的推导相符。\n**结论：正确。**\n\n**B. 使用真实世界测度（RWM）下的预期增长...这得出 $D(0,1)\\approx 0.932$。**\n这个程序在根本上是有缺陷的。无套利市场中的资产定价要求对风险中性测度（$\\mathbb{Q}$-measure）下的预期现金流进行贴现，而不是真实世界测度（$\\mathbb{P}$-measure）。使用真实世界期望忽略了与商品指数相关的风险的市场价格。所提供的远期价格 $F(0,t)$ 内在地包含了正确的风险中性信息。使用任意的真实世界增长率与所提供的市场数据不一致，并违反了基本的定价理论。\n**结论：不正确。**\n\n**C. 将指数水平...替换为当前即期水平 $I_0$...这得出 $D(0,1)\\approx 0.934$。**\n该方法假设未来指数水平 $I_t$将等于当前水平 $I_0$。这等同于假设远期价格等于即期价格，即 $F(0,t) = I_0$。这与明确给出的远期曲线相矛盾，其中 $F(0,0.5)=105$ 和 $F(0,1)=110$，而 $I_0=100$。在无套利定价的背景下，一个直接与可观察市场数据相矛盾的假设是无效的。\n**结论：不正确。**\n\n**D. 由于其现金流是随机的，将商品挂钩票据从引导构建中排除...**\n这种方法不科学，并且不必要地丢弃了有价值的市场信息。流动性远期合约的存在允许完全对冲商品指数风险，从而将随机现金流转换为其确定性等价物以进行定价。现代金融学的核心正是对此类风险的估值和管理。抛弃该工具就是忽略一个可解的问题，并构建一个不完整、因而也不够准确的市场贴现函数模型。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$"}, {"introduction": "这是收益率曲线构建的核心实践环节。现实世界的市场数据往往充满噪音，并且用于构建曲线的金融工具数量可能多于需要求解的贴现因子，形成一个超定系统。本练习模拟了这一真实环境，你将需要使用最小二乘法等优化技术来找到最佳拟合的贴现曲线，并通过检查是否存在负远期利率等套利信号来检验结果的内部一致性。[@problem_id:2377895]", "id": "2377895", "problem": "考虑一个具有确定性期限结构的无摩擦市场。设 $P(0,t)$ 表示时间 $t \\ge 0$ 的贴现因子，它是在时间 $t$ 收到的一单位货币在时间 $0$ 的现值。对于任何固定的现金流集合 $\\{(t_k,a_k)\\}_{k=1}^K$，其支付时间为 $t_k$（以年为单位），金额为 $a_k$（以货币单位计），无套利定价关系要求该工具的时间-$0$ 价格 $V$ 满足\n$$\nV = \\sum_{k=1}^K a_k \\, P(0,t_k).\n$$\n对于到期日网格 $0 < t_1 < t_2 < \\dots < t_n$，我们将相邻区间上的分段常数远期利率定义为\n$$\nf_i = -\\frac{\\ln\\!\\left(\\frac{P(0,t_{i+1})}{P(0,t_i)}\\right)}{t_{i+1}-t_i}, \\quad i=1,\\dots,n-1.\n$$\n在此设定下，假设经济体中的短期利率为非负，若 $f_i \\ge 0$ 被违反，则表明推导出的曲线中存在套利信号。如果远期利率 $f_i < -10^{-10}$，则将其视为负利率。\n\n您的任务是，对下面的每个数据集，在数据集中所有不同现金流时间的并集上构建贴现因子 $P(0,t_i)$，使得在方程超定的情况下，相应的工具定价关系在最小二乘意义上尽可能接近成立，并满足所有 $i$ 的 $P(0,t_i) > 0$ 约束。然后，使用拟合的贴现因子，计算已排序时间网格上的分段常数远期利率，并根据上述阈值统计其中严格为负的数量。\n\n所有货币金额均以每 100 单位面值为基准。所有时间均以年为单位。所有利率（收益率和远期利率）必须以小数形式处理（例如，百分之五写作 $0.05$）。要求的输出是整数（计数）。不需要其他单位。\n\n测试套件（三个数据集）：\n\n- 数据集 A（纯净的零息工具）：每个工具在其到期日支付一笔 100 的现金流；观察到的价格如下：\n  - 现金流时间和价格：\n    - $(t,a)=(0.5,100)$，价格为 $98.5112$\n    - $(t,a)=(1.0,100)$，价格为 $96.8500$\n    - $(t,a)=(1.5,100)$，价格为 $94.8841$\n    - $(t,a)=(2.0,100)$，价格为 $92.8642$\n    - $(t,a)=(3.0,100)$，价格为 $88.6920$\n    - $(t,a)=(5.0,100)$，价格为 $79.8516$\n\n- 数据集 B（类似于真实世界报价的带噪声的零息工具）：每个工具在其到期日支付一笔 100 的现金流；观察到的价格如下：\n  - 现金流时间（半年度网格）和价格：\n    - $(0.5, 98.050)$，$(1.0, 96.000)$，$(1.5, 94.250)$，$(2.0, 92.200)$，$(2.5, 90.600)$，\n      $(3.0, 88.800)$，$(3.5, 86.900)$，$(4.0, 85.100)$，$(4.5, 83.650)$，$(5.0, 81.900)$，\n      $(5.5, 80.300)$，$(6.0, 78.600)$，$(6.5, 77.200)$，$(7.0, 75.500)$，$(7.5, 74.100)$，\n      $(8.0, 72.500)$，$(8.5, 71.300)$，$(9.0, 69.700)$，$(9.5, 67.800)$，$(10.0, 68.200)$。\n\n- 数据集 C（包含一个短期零息债券和一个一年期附息债券的边缘案例）：\n  - 工具 1：$(t,a)=(0.5,100)$，价格为 $98.000$。\n  - 工具 2：附息债券，在 $t=0.5$ 和 $t=1.0$ 时支付金额为 2.0 的半年期利息，并在 $t=1.0$ 时支付 100.0 的本金，观察到的价格为 $102.500$。\n\n对于每个数据集：\n1. 构成所有不同现金流时间的并集 $\\{t_i\\}$。\n2. 确定贴现因子 $\\{P(0,t_i)\\}$，使其在所有工具上的定价误差平方和最小化，并满足所有 $i$ 的 $P(0,t_i) > 0$ 约束。\n3. 使用上述公式计算相邻网格区间上的远期利率 $\\{f_i\\}$。\n4. 统计满足 $f_i < -10^{-10}$ 的索引 $i$ 的数量。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含按数据集 A、B、C 顺序排列的三个整数结果，形式为用方括号括起来的逗号分隔列表（例如，“[0,1,2]”）。", "solution": "该问题要求根据一组观察到的金融工具价格构建贴现曲线。这个过程被称为引导法（bootstrapping），是量化金融的基础。在非负短期利率经济的假设下，需要检查所构建曲线的有效性，即是否存在套利机会，其信号是负的远期利率。我将首先验证问题陈述，然后提供一个完整的解决方案。\n\n该问题经过了严格的验证。\n\n**步骤 1：提取已知条件**\n-   具有现金流 $\\{(t_k, a_k)\\}_{k=1}^K$ 的工具的无套利价格 $V$ 为 $V = \\sum_{k=1}^K a_k P(0,t_k)$，其中 $P(0,t)$ 是到期日为 $t$ 的时间-0 贴现因子。\n-   到期日网格为 $0 < t_1 < t_2 < \\dots < t_n$。\n-   在 $[t_i, t_{i+1}]$ 上的分段常数远期利率为 $f_i = -\\frac{\\ln(P(0,t_{i+1})/P(0,t_i))}{t_{i+1}-t_i}$。\n-   如果 $f_i < -10^{-10}$，则存在套利信号。\n-   任务：对于三个数据集，在现金流时间的并集上找到贴现因子 $P(0,t_i)$，通过最小化定价误差的平方和来实现，同时满足 $P(0,t_i) > 0$ 的约束。然后，计算负远期利率的数量。\n-   数据集 A、B 和 C 提供了各种工具的价格和现金流。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上基于无套利资产定价的原理。将价格表述为贴现因子的线性组合是标准理论。使用最小二乘优化是从可能包含噪声或超定的市场数据中引导收益率曲线的标准技术。远期利率的定义和套利条件也是标准的。该问题是适定 (well-posed) 的；它要求解一个约束最小二乘问题，对此存在稳健的算法。数据和目标以明确的量化术语表达。清单中未发现任何缺陷。因此，该问题被视为**有效**。\n\n**方法论**\n\n对于每个数据集，我们必须执行以下步骤：\n\n1.  **建立时间网格**：设数据集中所有工具的所有唯一现金流时间组成的集合为 $\\{t_1, t_2, \\dots, t_n\\}$，按升序排列，其中 $t_1 > 0$。这些时间构成了我们的网格。未知变量是相应的贴现因子，我们用向量 $\\mathbf{p} = [p_1, p_2, \\dots, p_n]^T$ 表示，其中 $p_i = P(0, t_i)$。\n\n2.  **构建线性系统**：每个工具 $j$（其中 $j=1, \\dots, m$）都有一个观察到的价格 $V_j$ 和一组在时间 $\\{t_{jk}\\}$ 发生的现金流 $\\{a_{jk}\\}$。工具 $j$ 的定价方程可以写成一个关于未知贴现因子 $\\mathbf{p}$ 的线性方程：\n    $$ \\sum_{i=1}^n C_{ji} p_i = V_j $$\n    其中 $C_{ji}$ 是工具 $j$ 在时间 $t_i$ 的现金流金额。这就构成了一个包含 $n$ 个未知数的 $m$ 个线性方程组，可以表示为矩阵形式：\n    $$ C\\mathbf{p} = \\mathbf{v} $$\n    这里，$C$ 是 $m \\times n$ 的现金流矩阵，$\\mathbf{p}$ 是 $n \\times 1$ 的贴现因子向量，$\\mathbf{v}$ 是 $m \\times 1$ 的观察价格向量。\n\n3.  **求解优化问题**：问题是找到向量 $\\mathbf{p}$，以最小化模型价格 $C\\mathbf{p}$ 与观察价格 $\\mathbf{v}$ 之间的平方差之和，同时满足所有贴现因子都为正的约束。这是一个约束优化问题：\n    $$ \\min_{\\mathbf{p}} \\| C\\mathbf{p} - \\mathbf{v} \\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{p} > 0 $$\n    这是一个非负约束最小二乘（NNLS）问题。我们使用稍微宽松但在计算上是标准的约束 $\\mathbf{p} \\ge 0$，因为所提供的数据会产生严格为正的解。\n\n4.  **计算和分析远期利率**：在解出 $\\mathbf{p} = [p_1, \\dots, p_n]^T$ 后，我们为每个相邻区间 $[t_i, t_{i+1}]$（其中 $i=1, \\dots, n-1$）计算分段常数远期利率 $f_i$：\n    $$ f_i = -\\frac{\\ln(p_{i+1}/p_i)}{t_{i+1}-t_i} $$\n    如果 $p_{i+1} > p_i$，就会出现负的远期利率，这意味着未来时间 $t_{i+1}$ 的资金在今天的价值高于较早时间 $t_i$ 的资金。这构成了套利机会。我们统计 $f_i < -10^{-10}$ 的实例数量。\n\n**应用于数据集**\n\n**数据集 A：纯净的零息工具**\n-   时间网格为 $\\{0.5, 1.0, 1.5, 2.0, 3.0, 5.0\\}$。共有 $n=6$ 个时间点和 $m=6$ 个工具。\n-   每个工具都是一个在到期时支付 100 的零息债券。方程组为：\n    $$ 100 \\cdot P(0, t_i) = V_i \\quad \\text{对于 } i=1, \\dots, 6 $$\n-   该系统是对角矩阵，可直接求解：$P(0, t_i) = V_i / 100$。计算出的贴现因子为：$0.985112$、 $0.968500$、 $0.948841$、 $0.928642$、 $0.886920$、 $0.798516$。\n-   贴现因子序列是严格递减的，因此对于所有 $i$ 都有 $P(0, t_{i+1}) < P(0, t_i)$。因此，$p_{i+1}/p_i < 1$，$\\ln(p_{i+1}/p_i) < 0$，并且每个远期利率 $f_i$ 都将为正。\n-   负远期利率的数量为 $0$。\n\n**数据集 B：带噪声的零息工具**\n-   时间网格是从 0.5 年到 10.0 年的半年度网格，包含 $n=20$ 个点。共有 $m=20$ 个工具。\n-   与数据集 A 一样，问题简化为对 20 个到期日中的每一个求解 $P(0, t_i) = V_i / 100$。\n-   我们检查价格序列 $V_i$，以确认相应的贴现因子是否单调递减。价格为：$98.050, 96.000, \\dots, 69.700, 67.800, 68.200$。\n-   在期限结构的末端出现了一个异常。我们有 $t_{19} = 9.5$ 时的 $V_{19} = 67.800$ 和 $t_{20} = 10.0$ 时的 $V_{20} = 68.200$。\n-   这给出的贴现因子为 $p_{19} = P(0, 9.5) = 0.67800$ 和 $p_{20} = P(0, 10.0) = 0.68200$。\n-   由于 $p_{20} > p_{19}$，区间 $[9.5, 10.0]$ 的远期利率 $f_{19}$ 将为负：\n    $$ f_{19} = -\\frac{\\ln(0.68200 / 0.67800)}{10.0 - 9.5} \\approx -0.01176 $$\n    该值小于 $-10^{-10}$。所有其他相邻价格都是递减的，因此没有其他负的远期利率。\n-   负远期利率的数量为 $1$。\n\n**数据集 C：包含附息债券的边缘案例**\n-   不同的现金流时间是 $t_1=0.5$ 和 $t_2=1.0$，所以 $n=2$。共有 $m=2$ 个工具。\n-   线性方程组为：\n    $$\n    \\begin{pmatrix}\n    100 & 0 \\\\\n    2.0 & 102.0\n    \\end{pmatrix}\n    \\begin{pmatrix}\n    P(0, 0.5) \\\\\n    P(0, 1.0)\n    \\end{pmatrix}\n    =\n    \\begin{pmatrix}\n    98.000 \\\\\n    102.500\n    \\end{pmatrix}\n    $$\n-   这个系统是恰定 (exactly determined) 的。求解第一个方程得到 $p_1 = P(0, 0.5) = 98.000 / 100 = 0.98000$。\n-   代入第二个方程：$2.0(0.98000) + 102.0 \\cdot p_2 = 102.500$，得到 $1.96 + 102.0 \\cdot p_2 = 102.500$。\n-   解出 $p_2$ 得到 $p_2 = P(0, 1.0) = (102.500 - 1.96) / 102.0 = 100.54 / 102.0 \\approx 0.985686$。\n-   这里，$p_2 \\approx 0.985686 > p_1 = 0.98000$。这意味着在区间 $[0.5, 1.0]$ 上存在负的远期利率：\n    $$ f_1 = -\\frac{\\ln(0.985686 / 0.98000)}{1.0 - 0.5} \\approx -0.01157 $$\n    该值小于 $-10^{-10}$。\n-   负远期利率的数量为 $1$。\n\n最终计数为 $0$、 $1$ 和 $1$。代码将系统地实现这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all datasets and print the result.\n    \"\"\"\n    \n    # Dataset A (clean zero-coupon instruments)\n    dataset_a = [\n        (98.5112, [(0.5, 100.0)]),\n        (96.8500, [(1.0, 100.0)]),\n        (94.8841, [(1.5, 100.0)]),\n        (92.8642, [(2.0, 100.0)]),\n        (88.6920, [(3.0, 100.0)]),\n        (79.8516, [(5.0, 100.0)]),\n    ]\n\n    # Dataset B (noisy zero-coupon instruments)\n    prices_b = [\n        98.050, 96.000, 94.250, 92.200, 90.600, 88.800, 86.900, 85.100, \n        83.650, 81.900, 80.300, 78.600, 77.200, 75.500, 74.100, 72.500, \n        71.300, 69.700, 67.800, 68.200\n    ]\n    times_b = np.arange(0.5, 10.1, 0.5)\n    dataset_b = [(price, [(time, 100.0)]) for price, time in zip(prices_b, times_b)]\n\n    # Dataset C (edge case with a short-dated zero and a one-year coupon bond)\n    dataset_c = [\n        (98.000, [(0.5, 100.0)]),\n        (102.500, [(0.5, 2.0), (1.0, 102.0)]),\n    ]\n    \n    test_cases = [dataset_a, dataset_b, dataset_c]\n    \n    results = []\n    for case in test_cases:\n        count = solve_dataset(case)\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_dataset(instruments):\n    \"\"\"\n    Constructs discount curve for a given dataset and counts negative forward rates.\n\n    Args:\n        instruments: A list of tuples, where each tuple contains an instrument's\n                     price and a list of its cash flows (time, amount).\n\n    Returns:\n        An integer count of negative forward rates.\n    \"\"\"\n    \n    # 1. Establish the Time Grid\n    all_times = set()\n    for _, cash_flows in instruments:\n        for t, _ in cash_flows:\n            all_times.add(t)\n    \n    sorted_times = sorted(list(all_times))\n    time_to_idx = {t: i for i, t in enumerate(sorted_times)}\n    n_times = len(sorted_times)\n    n_instruments = len(instruments)\n\n    # 2. Formulate the Linear System\n    C = np.zeros((n_instruments, n_times))\n    v = np.zeros(n_instruments)\n\n    for j, (price, cash_flows) in enumerate(instruments):\n        v[j] = price\n        for t, amount in cash_flows:\n            if t in time_to_idx:\n                i = time_to_idx[t]\n                C[j, i] += amount\n\n    # 3. Solve the Optimization Problem (NNLS)\n    p, _ = nnls(C, v)\n\n    # 4. Compute and Analyze Forward Rates\n    negative_forward_count = 0\n    neg_threshold = -1.0e-10\n\n    for i in range(n_times - 1):\n        t_i = sorted_times[i]\n        t_i_plus_1 = sorted_times[i+1]\n        \n        p_i = p[i]\n        p_i_plus_1 = p[i+1]\n\n        # Avoid log(0) or division by zero. If p_i is zero, the forward rate\n        # would be infinite, not negative. With the given data, p_i > 0.\n        if p_i > 1e-12:  # Practical threshold for being non-zero\n            ratio = p_i_plus_1 / p_i\n            # If ratio is non-positive, log is undefined. Assume positive discount factors.\n            if ratio > 1e-12:\n                log_ratio = np.log(ratio)\n                delta_t = t_i_plus_1 - t_i\n                \n                # Ensure delta_t is not zero\n                if delta_t > 1e-12:\n                    forward_rate = -log_ratio / delta_t\n                    if forward_rate < neg_threshold:\n                        negative_forward_count += 1\n\n    return negative_forward_count\n\nsolve()\n```"}, {"introduction": "掌握了曲线的构建方法后，我们将从“构建”转向“分析”。理解收益率曲线对输入债券价格的微小变化有多敏感，对于风险管理至关重要。这个高级练习将深入到自举法过程的数学核心，你将应用隐函数定理来推导和计算零利率对债券价格的敏感度——即雅可比矩阵 $J = [\\\\frac{\\\\partial z_i}{\\\\partial P_j}]$，这是衡量曲线风险状况的重要指标。[@problem_id:2377880]", "id": "2377880", "problem": "给定一组固定收益工具，用于在有限的到期日集合上引导（bootstrap）一条连续复利的零息收益率曲线。现有 $n$ 种工具，其支付时间 $\\{t_1,\\dots,t_n\\}$（以年为单位）是递增的。工具 $j$ ($1 \\leq j \\leq n$) 在 $\\{t_1,\\dots,t_j\\}$ 这些时间点支付现金流。将工具 $j$ 的年化票面利率记为 $c_j$（以小数而非百分比表示），净价记为 $P_j$。假设所有工具的名义本金为 $1$，且一个计息区间内的票息金额等于票面利率乘以该区间的年份分数。具体而言，定义计息分数为 $\\Delta t_1 = t_1 - 0$ 和 $\\Delta t_k = t_k - t_{k-1}$（对于所有 $k \\geq 2$）。那么，在时间 $t_k$（$k \\leq j$），工具 $j$ 的现金流为 $c_j \\,\\Delta t_k$，并在 $t_j$ 时额外偿还一笔为 $1$ 的本金。将 $t_k$ 时的连续复利零利率记为 $z_k$。在无套利假设下，工具 $j$ 的净价由以下折现关系给出：\n$$\nP_j \\;=\\; \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp\\!\\left(-z_k\\,t_k\\right),\n$$\n其中 $\\mathbf{1}_{\\{k=j\\}}$ 是指示函数，当 $k=j$ 时等于 $1$，否则等于 $0$。\n\n定义未知零利率向量 $\\mathbf{z} = (z_1,\\dots,z_n)^\\top$ 和观测价格向量 $\\mathbf{P}=(P_1,\\dots,P_n)^\\top$。定义一个包含 $n$ 个未知数的 $n$ 个非线性方程组如下：\n$$\nF_j(\\mathbf{z},\\mathbf{P}) \\;=\\; \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp\\!\\left(-z_k\\,t_k\\right) \\;-\\; P_j \\;=\\; 0,\\quad j=1,\\dots,n.\n$$\n根据这些工具的构造方式，该方程组是下三角的，即方程 $j$ 只涉及 $\\{z_1,\\dots,z_j\\}$。\n\n任务：严格地从上述无套利定价关系和方程组 $F_j(\\mathbf{z},\\mathbf{P})=0$ 的定义出发，推导一个算法来计算引导出的零利率对输入价格的敏感度雅可比矩阵，\n$$\nJ \\;=\\; \\left[\\frac{\\partial z_i}{\\partial P_j}\\right]_{i,j=1}^n.\n$$\n您的推导必须从第一性原理出发，通过对定义方程进行微分并利用其下三角结构，推导过程中不得调用任何预先打包好的敏感度计算公式。然后，将推导出的算法实现为一个完整、可运行的程序，对提供的测试套件中的每个测试用例执行以下操作：\n\n1. 使用上述计息惯例，根据 $\\{t_k\\}$ 和 $\\{c_j\\}$ 构建隐含的现金流矩阵。\n2. 使用一个给定的“真实”零利率向量 $\\{z_k^{\\text{true}}\\}$，通过定价关系计算出合成净价 $\\{P_j\\}$。\n3. 利用三角结构，从 $\\{P_j\\}$ 中引导出 $\\{z_k\\}$。\n4. 通过对 $F_j(\\mathbf{z},\\mathbf{P})=0$ 进行隐式微分，组建相应的方程组，以求解完整的雅可比矩阵 $J$。\n5. 对于每个测试用例，返回按行主序展平的整个雅可比矩阵，形式为一个浮点数列表，数值四舍五入到8位小数。\n\n单位与约定：\n- 所有时间 $\\{t_k\\}$ 均以年为单位。\n- 所有利率 $\\{c_j\\}$ 和 $\\{z_k\\}$ 均为小数（例如，$0.02$ 表示百分之二）。\n- 折现使用连续复利，即 $\\exp(-z_k\\,t_k)$。\n\n测试套件：\n- 案例A（一般半年付息结构，“理想路径”）：$n=4$, $t=[0.5,1.0,1.5,2.0]$, $c=[0.0,0.02,0.025,0.03]$, $z^{\\text{true}}=[0.018,0.020,0.0215,0.022]$。\n- 案例B（全部为零息债券，对角结构边界情况）：$n=3$, $t=[0.25,0.5,1.0]$, $c=[0.0,0.0,0.0]$, $z^{\\text{true}}=[0.015,0.016,0.0175]$。\n- 案例C（票息极小，数值上敏感但适定）：$n=3$, $t=[1.0,2.0,3.0]$, $c=[0.0001,0.0001,0.0001]$, $z^{\\text{true}}=[0.03,0.031,0.032]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个元素的列表，按A、B、C的顺序对应每个测试用例。\n- 每个元素本身必须是一个列表，包含按行主序展平的雅可比矩阵项 $\\left[\\frac{\\partial z_i}{\\partial P_j}\\right]$，数值四舍五入到8位小数。\n- 具体来说，如果测试用例的维度为 $n$，则输出一个长度为 $n\\times n$ 的列表，按顺序包含 $J_{1,1},J_{1,2},\\dots,J_{1,n},J_{2,1},\\dots,J_{n,n}$。\n- 打印的单行必须是标准的Python风格嵌套列表字面量，例如 $\\texttt{[[0.12345678,0.0,\\dots],[\\dots],[\\dots]]}$，且数值四舍五入到8位小数。", "solution": "所述问题在科学上是合理的、适定的且客观的。它基于无套利定价和利率期限结构的基本原理，这是计算金融学的核心课题。所有必要的数据和定义都已提供，问题结构导向一个唯一的、有意义的解。问题中没有逻辑矛盾、不切实际的假设或含糊不清之处。因此，我将着手提供一个完整的解决方案。\n\n目标是推导一个算法，用以计算引导出的零利率相对于输入工具价格的雅可比矩阵，定义为 $J = \\left[\\frac{\\partial z_i}{\\partial P_j}\\right]_{i,j=1}^n$。该推导将基于应用于非线性定价方程组的隐函数定理。\n\n将价格向量 $\\mathbf{P}=(P_1, \\dots, P_n)^\\top$ 与零利率向量 $\\mathbf{z}=(z_1, \\dots, z_n)^\\top$ 关联起来的 $n$ 个方程组如下：\n$$\nF_j(\\mathbf{z}, \\mathbf{P}) = \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp(-z_k\\,t_k) - P_j = 0, \\quad \\text{for } j=1, \\dots, n.\n$$\n在这里，零利率 $\\mathbf{z}$ 被隐式地定义为市场价格 $\\mathbf{P}$ 的函数。为了找到 $\\mathbf{z}$ 相对于 $\\mathbf{P}$ 的敏感度，我们考虑方程组 $\\mathbf{F}(\\mathbf{z}(\\mathbf{P}), \\mathbf{P}) = \\mathbf{0}$ 的全微分。对于每个分量 $F_j$，我们有：\n$$\ndF_j = \\sum_{i=1}^{n} \\frac{\\partial F_j}{\\partial z_i} dz_i + \\sum_{m=1}^{n} \\frac{\\partial F_j}{\\partial P_m} dP_m = 0.\n$$\n这可以用雅可比矩阵表示为矩阵形式：\n$$\n\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}} d\\mathbf{z} + \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{P}} d\\mathbf{P} = \\mathbf{0}.\n$$\n让我们将系统相对于利率的雅可比矩阵记为 $J_z = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}}$，相对于价格的雅可比矩阵记为 $J_P = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{P}}$。方程变为：\n$$\nJ_z d\\mathbf{z} + J_P d\\mathbf{P} = \\mathbf{0}.\n$$\n所求的雅可比矩阵 $J = \\frac{\\partial \\mathbf{z}}{\\partial \\mathbf{P}}$ 通过 $d\\mathbf{z} = J d\\mathbf{P}$ 关联微分 $d\\mathbf{z}$ 和 $d\\mathbf{P}$。将其代入前一个方程可得：\n$$\nJ_z (J d\\mathbf{P}) + J_P d\\mathbf{P} = \\mathbf{0} \\implies (J_z J + J_P) d\\mathbf{P} = \\mathbf{0}.\n$$\n由于此关系必须对价格的任何无穷小变化 $d\\mathbf{P}$ 均成立，因此括号中的矩阵必须是零矩阵。\n$$\nJ_z J + J_P = \\mathbf{0} \\implies J = -(J_z)^{-1} J_P.\n$$\n接下来，我们确定矩阵 $J_z$ 和 $J_P$。\n$F_j$ 对价格 $P_m$ 的偏导数仅在 $m=j$ 时非零：\n$$\n(J_P)_{jm} = \\frac{\\partial F_j}{\\partial P_m} = \\frac{\\partial}{\\partial P_m} \\left( \\dots - P_j \\right) = -\\delta_{jm},\n$$\n其中 $\\delta_{jm}$ 是克罗内克δ。因此，$J_P$ 是负单位矩阵，即 $J_P = -I$。\n\n将 $J_P=-I$ 代入 $J$ 的表达式中，得到一个简化的结果：\n$$\nJ = -(J_z)^{-1}(-I) = (J_z)^{-1}.\n$$\n问题现在简化为计算矩阵 $J_z = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}}$ 并求其逆矩阵。$J_z$ 的元素是 $(J_z)_{ji} = \\frac{\\partial F_j}{\\partial z_i}$。\n根据 $F_j$ 的定义，利率 $z_i$ 仅在 $i \\le j$ 时才出现在公式中。因此，当 $i > j$ 时 $\\frac{\\partial F_j}{\\partial z_i} = 0$，这证实了 $J_z$ 是一个下三角矩阵。\n\n对于 $i \\le j$，导数为：\n$$\n(J_z)_{ji} = \\frac{\\partial F_j}{\\partial z_i} = \\frac{\\partial}{\\partial z_i} \\left[ \\left(c_j\\,\\Delta t_i + \\mathbf{1}_{\\{i=j\\}}\\right)\\exp(-z_i\\,t_i) \\right] = -\\left(c_j\\,\\Delta t_i + \\mathbf{1}_{\\{i=j\\}}\\right) t_i \\exp(-z_i\\,t_i).\n$$\n具体来说，$J_z$ 的元素是：\n- 对角线元素（$i=j$）：$(J_z)_{jj} = -(c_j \\Delta t_j + 1) t_j \\exp(-z_j t_j)$。\n- 非对角线元素（$i<j$）：$(J_z)_{ji} = -c_j \\Delta t_i t_i \\exp(-z_i t_i)$。\n\n最终的算法如下：\n1.  给定一组工具价格 $\\{P_j\\}_{j=1}^n$，首先引导出零利率 $\\{z_k\\}_{k=1}^n$。这是通过迭代完成的。对于 $j=1, \\dots, n$，使用已知的利率 $z_1, \\dots, z_{j-1}$ 求解 $z_j$：\n    $$\n    z_j = -\\frac{1}{t_j} \\ln \\left( \\frac{P_j - \\sum_{k=1}^{j-1} c_j \\Delta t_k \\exp(-z_k t_k)}{c_j \\Delta t_j + 1} \\right).\n    $$\n2.  使用引导出的利率 $\\mathbf{z}$，根据上面推导的公式组装下三角矩阵 $J_z$。导数必须在满足定价方程的点 $(\\mathbf{z}, \\mathbf{P})$ 处计算。\n3.  通过对 $J_z$ 求逆来计算所求的雅可比矩阵 $J$。由于 $J_z$ 是下三角矩阵，其逆矩阵 $J = (J_z)^{-1}$ 也是下三角矩阵，可以通过前向替换法求解系统 $J_z J = I$ 来高效计算。这种方法是数值稳定的，并且是高效的，因为对于任何 $t_j > 0$，对角线元素 $(J_z)_{jj}$ 都是非零的。\n\n实现过程将首先从一组给定的 `true` 零利率计算出合成价格，然后从这些价格中引导出利率（这应能在数值精度范围内恢复 `true` 利率），最后使用这些引导出的利率计算雅可比矩阵。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_triangular\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    def compute_jacobian(t, c, z_true):\n        \"\"\"\n        Derives and computes the Jacobian of zero rates w.r.t. instrument prices.\n\n        Args:\n            t (list): Payment times in years.\n            c (list): Annualized coupon rates (decimal).\n            z_true (list): True zero rates for generating synthetic prices.\n\n        Returns:\n            list: Flattened Jacobian matrix in row-major order, rounded to 8 decimal places.\n        \"\"\"\n        n = len(t)\n        t_arr = np.array(t, dtype=float)\n        c_arr = np.array(c, dtype=float)\n        z_true_arr = np.array(z_true, dtype=float)\n\n        # Step 0: Pre-computation of accrual fractions (delta_t)\n        delta_t = np.zeros(n)\n        delta_t[0] = t_arr[0]\n        if n > 1:\n            delta_t[1:] = t_arr[1:] - t_arr[:-1]\n\n        # Step 2: Compute synthetic clean prices P_j from z_true\n        prices = np.zeros(n)\n        for j in range(n):\n            price = 0.0\n            # Sum of present values of coupons before maturity\n            for k in range(j):\n                price += c_arr[j] * delta_t[k] * np.exp(-z_true_arr[k] * t_arr[k])\n            # Add PV of final payment (last coupon + principal)\n            price += (c_arr[j] * delta_t[j] + 1.0) * np.exp(-z_true_arr[j] * t_arr[j])\n            prices[j] = price\n\n        # Step 3: Bootstrap zero rates z_k from prices P_j\n        # This step recovers z_true and provides the point for derivative evaluation.\n        z_boot = np.zeros(n)\n        for j in range(n):\n            known_pv_of_coupons = 0.0\n            for k in range(j):\n                known_pv_of_coupons += c_arr[j] * delta_t[k] * np.exp(-z_boot[k] * t_arr[k])\n            \n            final_cash_flow = c_arr[j] * delta_t[j] + 1.0\n            \n            # From P_j - known_pv = final_cash_flow * exp(-z_j * t_j)\n            arg_of_log = (prices[j] - known_pv_of_coupons) / final_cash_flow\n            \n            # Handle potential numerical issues for log\n            if arg_of_log <= 0:\n                raise ValueError(f\"Invalid argument for log at step j={j}: {arg_of_log}\")\n\n            z_boot[j] = -np.log(arg_of_log) / t_arr[j]\n\n        # Step 4a: Assemble the matrix J_z = dF/dz\n        J_z = np.zeros((n, n))\n        for j in range(n):\n            for i in range(j + 1):\n                discount_factor = np.exp(-z_boot[i] * t_arr[i])\n                if i < j:\n                    # Off-diagonal element (J_z)_ji\n                    # Derivative of F_j w.r.t z_i where i < j\n                    J_z[j, i] = -c_arr[j] * delta_t[i] * t_arr[i] * discount_factor\n                else:  # i == j\n                    # Diagonal element (J_z)_jj\n                    # Derivative of F_j w.r.t z_j\n                    final_payment = c_arr[j] * delta_t[j] + 1.0\n                    J_z[j, j] = -final_payment * t_arr[j] * discount_factor\n\n        # Step 4b: Solve for the Jacobian J = (J_z)^-1\n        # We are solving J_z @ J = I, where I is the identity matrix.\n        # solve_triangular is efficient for this as J_z is lower-triangular.\n        identity_matrix = np.identity(n)\n        J = solve_triangular(J_z, identity_matrix, lower=True)\n\n        # Step 5: Return flattened Jacobian, rounded to 8 decimal places.\n        return np.round(J.flatten(order='C'), 8).tolist()\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General semiannual coupon structure\n        {'t': [0.5, 1.0, 1.5, 2.0], 'c': [0.0, 0.02, 0.025, 0.03], 'z_true': [0.018, 0.020, 0.0215, 0.022]},\n        # Case B: All zero-coupon bonds\n        {'t': [0.25, 0.5, 1.0], 'c': [0.0, 0.0, 0.0], 'z_true': [0.015, 0.016, 0.0175]},\n        # Case C: Very small coupons\n        {'t': [1.0, 2.0, 3.0], 'c': [0.0001, 0.0001, 0.0001], 'z_true': [0.03, 0.031, 0.032]}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_jacobian(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation is formatted to remove spaces for a compact output.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"}]}