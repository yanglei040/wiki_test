{"hands_on_practices": [{"introduction": "Cox-Ross-Rubinstein 模型的基石在于动态复制的概念，即可以通过在标的资产和无风险资产中动态调整头寸来完美复制期权的支付。这个练习旨在通过计算来验证这一核心原理。通过沿着一条模拟的价格路径实施 Delta 套期保值策略并跟踪对冲误差 $\\epsilon_t$，你将亲眼见证在一个无摩擦的市场中，对冲组合的价值如何精确地跟随期权价值变化，从而证明一个自融资的完美复制策略是可行的。[@problem_id:2412792]", "id": "2412792", "problem": "给定一个离散时间、多期的二叉树资产定价模型。设标的资产价格过程 $\\{S_{t}\\}_{t=0}^{N}$ 服从乘性动态，即在每个时期，价格要么上涨一个因子 $u$，要么下跌一个因子 $d$，其中 $u&gt;d&gt;0$。每期的无风险总回报率为 $R$，且满足无套利条件 $d&lt;R&lt;u$。考虑一个基于此资产的欧式看涨期权，其行权价为 $K$，到期时间步为 $N$。令 $C_{t}$ 表示在给定节点上，期权在 $t$ 时刻的唯一无套利价值，该价值在风险中性测度下计算，其中上涨概率为 $q=(R-d)/(u-d)$，终端条件为 $C_{N}=\\max(S_{N}-K,0)$。在每个非终端节点，将局部Delta定义为复制投资组合中的股票数量，\n$$\n\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}},\n$$\n其中上标表示上行或下行子节点中的价值。\n\n一个交易员在时刻 $0$ 做空一个单位的看涨期权，收到期权费 $C_{0}$，并通过持有 $\\Delta_{t}$ 份股票和一个无风险账户头寸 $B_{t}$ 来动态对冲该空头头寸，交易成本为零且满足自融资约束。初始对冲满足 $B_{0}=C_{0}-\\Delta_{0}S_{0}$。沿着一条长度为 $N$ 的已实现价格路径，在第 $t$ 期末再平衡前的对冲误差定义为\n$$\ne_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t},\\quad t=1,2,\\dots,N,\n$$\n其中 $C_{t}$ 是在 $t$ 时刻到达的节点的期权价值，且 $C_{N}=\\max(S_{N}-K,0)$。在测量 $e_{t}$ 后，对于 $t=1,2,\\dots,N-1$，对冲组合在 $t$ 时刻被再平衡至 $\\Delta_{t}$。\n\n您的任务是实现一个程序，对于每个给定的参数集和已实现的路径，构建二叉树价格树，计算期权价值树，实施上述定义的针对空头看涨期权的动态Delta对冲策略，并返回路径上的序列 $\\{e_{t}\\}_{t=1}^{N}$。所有值必须表示为小数（无百分号），每个 $e_{t}$ 必须四舍五入到10位小数。\n\n测试套件。对于以下每个案例，请使用提供的参数和已实现的上/下行走势路径，其中 $U$ 表示按因子 $u$ 上涨，$D$ 表示按因子 $d$ 下跌：\n- 案例1（通用多期路径）：$S_{0}=100.0$, $u=1.1$, $d=0.9$, $R=1.02$, $K=100.0$, $N=4$，路径 $[U,D,U,U]$。\n- 案例2（边界，单期）：$S_{0}=50.0$, $u=1.2$, $d=0.8$, $R=1.0$, $K=50.0$, $N=1$，路径 $[U]$。\n- 案例3（边缘，零利率且全为下跌）：$S_{0}=80.0$, $u=1.25$, $d=0.8$, $R=1.0$, $K=90.0$, $N=3$，路径 $[D,D,D]$。\n- 案例4（边缘，深度价内且全为上涨）：$S_{0}=100.0$, $u=1.2$, $d=0.8$, $R=1.01$, $K=80.0$, $N=3$，路径 $[U,U,U]$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表被方括号包围。此列表的每个元素必须是对应测试案例的、经过四舍五入的对冲误差列表 $[e_{1},e_{2},\\dots,e_{N}]$。例如，一个包含两个案例的输出应形如 $[[e_{1}^{(1)},\\dots,e_{N\\_{1}}^{(1)}],[e_{1}^{(2)},\\dots,e_{N\\_{2}}^{(2)}]]$，行中不含任何空格。", "solution": "问题陈述已经过验证。\n\n给定的条件逐字提取如下：\n- 资产价格过程：$\\{S_{t}\\}_{t=0}^{N}$ 服从乘性二叉树模型。\n- 上涨因子：$u$。下跌因子：$d$。其中 $u > d > 0$。\n- 每期无风险总回报率：$R$。\n- 无套利条件：$d < R < u$。\n- 衍生品：欧式看涨期权，行权价 $K$，到期日 $N$。\n- 期权价值：$t$ 时刻的 $C_{t}$。\n- 终端条件：$C_{N} = \\max(S_{N}-K, 0)$。\n- 风险中性上涨概率：$q = \\frac{R-d}{u-d}$。\n- 期权估值：在风险中性测度下进行，意味着 $C_{t} = R^{-1}[q C_{t+1}^{(u)} + (1-q) C_{t+1}^{(d)}]$。\n- 复制投资组合Delta：$\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}}$。\n- 对冲策略：做空一个单位看涨期权，用 $\\Delta_{t}$ 份股票和无风险账户头寸 $B_{t}$ 进行对冲。\n- 初始对冲：$B_{0}=C_{0}-\\Delta_{0}S_{0}$。\n- 再平衡前的对冲误差：$e_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t}$，其中 $t=1, 2, \\dots, N$。\n- 再平衡：在自融资约束下，对冲组合在 $t$ 时刻（$t=1, 2, \\dots, N-1$）再平衡至 $\\Delta_{t}$。\n- 测试案例：提供了四组特定的参数集（$S_{0}, u, d, R, K, N$）和已实现的路径。\n- 输出要求：为每个案例提供一组对冲误差列表 $\\{e_{t}\\}_{t=1}^{N}$，四舍五入到10位小数。\n\n验证结论：问题有效。\n该问题具有科学依据，是计算金融学中的一个基本概念——Cox-Ross-Rubinstein二叉树期权定价模型——的标准练习。该问题是适定的；所有参数、定义和约束都已提供，确保可以通过计算确定唯一解。期权价值、风险中性概率和delta的定义是标准且正确的。该问题是客观的，不含任何模糊之处。无套利条件被正确陈述并在测试案例中得到满足。问题的核心是验证二叉树模型的核心论点：衍生品的支付可以通过在标的资产和无风险债券中的动态、自融资交易策略来完美复制。因此，理论上定义的对冲误差在所有时间步长都应为零，任何非零结果仅可归因于浮点数精度问题。\n\n现提出一个完整的解决方案。该方法论建立在离散时间资产定价的基本原则之上。\n\n首先，我们构建标的资产价格的二叉树格 $\\{S_{t}\\}_{t=0}^{N}$。在时间步 $i$（$0 \\le i \\le N$）经过 $j$ 次上涨（$0 \\le j \\le i$）后的一个节点，其价格由下式给出：\n$$S_{i,j} = S_{0} u^{j} d^{i-j}$$\n\n其次，我们确定树中每个节点的期权价值。这是通过向后归纳法完成的，从到期日 $t=N$ 的已知期权价值开始。欧式看涨期权在到期日的价值是其内在价值：\n$$C_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{对于 } j = 0, 1, \\dots, N$$\n对于任何非终端节点 $(i,j)$（其中 $i < N$），无套利期权价值 $C_{i,j}$ 是下一时期期权价值在风险中性测度下计算的贴现期望值。风险中性的上涨概率为 $q = \\frac{R-d}{u-d}$。估值公式为：\n$$C_{i,j} = \\frac{1}{R} \\left[ q C_{i+1,j+1} + (1-q) C_{i+1,j} \\right]$$\n这个向后递推的计算过程填充了整个期权价值树 $\\{C_{i,j}\\}$。\n\n第三，我们沿着指定的资产价格变动路径实施动态对冲策略。该策略涉及创建一个包含 $\\Delta_{t}$ 份资产股票和在无风险账户中持有现金头寸 $B_{t}$ 的投资组合。该投资组合在 $t$ 时刻的价值为 $V_t = \\Delta_t S_t + B_t$。\n\n策略在 $t=0$ 时刻启动。初始投资组合被构建以复制期权的价值，即 $V_0 = C_0$。股票数量 $\\Delta_0$ 由delta对冲公式给出：\n$$\\Delta_{0} = \\frac{C_{1,1} - C_{1,0}}{S_{1,1} - S_{1,0}}$$\n然后，设置初始现金头寸 $B_0$，以确保投资组合价值与期权价值相匹配：$B_{0} = C_{0,0} - \\Delta_{0}S_{0,0}$。\n\n投资组合是自融资的。这意味着在任何后续时期 $t > 0$，投资组合构成的任何变化都在内部融资，没有外部现金注入或提取。在时期 $t$ 开始时（从 $t-1$ 的价格变动之后），上一时期投资组合 $(\\Delta_{t-1}, B_{t-1})$ 的价值演变为：\n$$V_{t}^{-} = \\Delta_{t-1}S_{t} + B_{t-1}R$$\n问题将 $t$ 时刻的对冲误差定义为该投资组合价值与新节点处理论期权价格 $C_{t}$ 之间的差额：\n$$e_{t} = V_{t}^{-} - C_{t}$$\n二叉树模型的一个核心结果是，复制投资组合的价值 $V_{t}^{-}$ 在每个节点都会精确匹配期权的价值 $C_{t}$。因此，我们预期对所有 $t$ 都有 $e_t = 0$，除非受数值精度的影响。\n\n在计算误差后，为下一时期（如果 $t < N$）对投资组合进行再平衡。新的股票数量 $\\Delta_t$ 根据当前节点的后继价值计算：\n$$\\Delta_{t} = \\frac{C_{t+1}^{\\text{(up)}} - C_{t+1}^{\\text{(down)}}}{S_{t+1}^{\\text{(up)}} - S_{t+1}^{\\text{(down)}}}$$\n新的现金头寸 $B_t$ 由自融资条件确定。投资组合的价值在再平衡期间保持不变，因此再平衡后的价值 $V_t^{+} = \\Delta_t S_t + B_t$ 必须等于再平衡前的价值 $V_t^{-}$。因此，新的现金头寸为：\n$$B_{t} = V_{t}^{-} - \\Delta_{t}S_{t}$$\n这个沿着路径移动、计算对冲误差和再平衡的过程一直重复到到期日 $t=N$。计算出的误差序列 $\\{e_t\\}_{t=1}^N$ 是给定路径的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        {'S0': 100.0, 'u': 1.1, 'd': 0.9, 'R': 1.02, 'K': 100.0, 'N': 4, 'path': ['U', 'D', 'U', 'U']},\n        {'S0': 50.0, 'u': 1.2, 'd': 0.8, 'R': 1.0, 'K': 50.0, 'N': 1, 'path': ['U']},\n        {'S0': 80.0, 'u': 1.25, 'd': 0.8, 'R': 1.0, 'K': 90.0, 'N': 3, 'path': ['D', 'D', 'D']},\n        {'S0': 100.0, 'u': 1.2, 'd': 0.8, 'R': 1.01, 'K': 80.0, 'N': 3, 'path': ['U', 'U', 'U']}\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = _calculate_hedging_errors(\n            S0=case['S0'],\n            u=case['u'],\n            d=case['d'],\n            R=case['R'],\n            K=case['K'],\n            N=case['N'],\n            path=case['path']\n        )\n        results.append(errors)\n    \n    # Format the final output string precisely as required.\n    inner_parts = []\n    for err_list in results:\n        # Format each error to a string with the required precision.\n        # Although the errors are theoretically zero, they may be small non-zero floats.\n        # We ensure standard float representation e.g. '0.0' instead of '0'\n        # The rounding is already done, this is for formatting.\n        formatted_list = [f\"{err:.10f}\".rstrip('0').rstrip('.') if err != 0 else '0.0' for err in err_list]\n        inner_parts.append(f\"[{','.join(formatted_list)}]\")\n        \n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef _calculate_hedging_errors(S0: float, u: float, d: float, R: float, K: float, N: int, path: list[str]) -> list[float]:\n    \"\"\"\n    Calculates the sequence of dynamic hedging errors for a given path.\n\n    Args:\n        S0: Initial asset price.\n        u: Up-move factor.\n        d: Down-move factor.\n        R: Gross risk-free return per period.\n        K: Option strike price.\n        N: Number of periods to maturity.\n        path: A list of 'U' or 'D' strings representing the realized path.\n\n    Returns:\n        A list of hedging errors {e_t} for t=1,...,N, rounded to 10 decimal places.\n    \"\"\"\n    # 1. Construct asset price and option value trees\n    # Risk-neutral probability\n    q = (R - d) / (u - d)\n\n    # Initialize trees\n    S_tree = np.zeros((N + 1, N + 1))\n    C_tree = np.zeros((N + 1, N + 1))\n\n    # Populate asset price tree S[i,j] = price at time i after j up-moves\n    for i in range(N + 1):\n        for j in range(i + 1):\n            S_tree[i, j] = S0 * (u**j) * (d**(i - j))\n\n    # Populate option value tree at maturity (t=N)\n    C_tree[N, :] = np.maximum(S_tree[N, :] - K, 0)\n\n    # Populate option value tree by backward induction\n    for i in range(N - 1, -1, -1):\n        for j in range(i + 1):\n            C_up = C_tree[i + 1, j + 1]\n            C_down = C_tree[i + 1, j]\n            C_tree[i, j] = (q * C_up + (1 - q) * C_down) / R\n\n    # 2. Trace the path and compute hedging errors\n    hedging_errors = []\n    \n    # Initial portfolio setup at t=0\n    num_ups = 0  # number of up moves from t=0\n    \n    # Initial delta (Delta_0)\n    delta_prev = (C_tree[1, 1] - C_tree[1, 0]) / (S_tree[1, 1] - S_tree[1, 0])\n    \n    # Initial bond position (B_0)\n    B_prev = C_tree[0, 0] - delta_prev * S_tree[0, 0]\n\n    # Iterate along the path from t=1 to N\n    for t in range(1, N + 1):\n        # Determine current node based on path\n        move = path[t - 1]\n        if move == 'U':\n            num_ups += 1\n        \n        # Current asset and option values at node (t, num_ups)\n        current_S = S_tree[t, num_ups]\n        current_C = C_tree[t, num_ups]\n        \n        # Value of hedge portfolio before rebalancing\n        portfolio_val_pre_rebalance = delta_prev * current_S + B_prev * R\n        \n        # Calculate hedging error e_t\n        error = portfolio_val_pre_rebalance - current_C\n        hedging_errors.append(round(error, 10))\n\n        # Rebalance the portfolio for the next period (if not at maturity)\n        if t < N:\n            # Calculate new delta (Delta_t) at the current node\n            delta_curr = (C_tree[t + 1, num_ups + 1] - C_tree[t + 1, num_ups]) / \\\n                         (S_tree[t + 1, num_ups + 1] - S_tree[t + 1, num_ups])\n            \n            # Calculate new bond position (B_t) to maintain self-financing\n            # New portfolio value V_t+ must equal V_t-\n            B_curr = portfolio_val_pre_rebalance - delta_curr * current_S\n            \n            # Update portfolio for the next iteration\n            delta_prev = delta_curr\n            B_prev = B_curr\n\n    return hedging_errors\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "理论模型是理想化的，而真实世界则充满了各种市场摩擦。这个练习将我们从理想的无摩擦世界带入一个更现实的场景，引入了一个简单的固定交易成本。你将探索即使是微小的交易成本也会如何打破完美的复制策略，并迫使期权卖方必须构建一个“超复制”组合来确保其在所有市场情况下都能履行义务，这最终会导致更高的期权价格。[@problem_id:2439187]", "id": "2439187", "problem": "考虑一个单期 Cox-Ross-Rubinstein (CRR) 模型，其中一支股票的当前价格为 $S_{0} = \\$100$。在一个时期内，股票价格将变动至 $S_{u} = u S_{0}$ (其中 $u = 1.2$) 或 $S_{d} = d S_{0}$ (其中 $d = 0.9$)。该时期内的无风险总回报率为 $R = 1.05$。一份执行价格为 $K = \\$100$ 的欧式看漲期权在该时期结束时到期。\n\n假设在再对冲时点，每当执行非零的股票交易时，都会产生一笔 $c$ 美元的固定交易成本。在这个单期设定中，假设期权卖方在时间 $0$ 选择静态对冲（即在时间 $0$ 选择股票头寸和无风险资产持有量，并持有至到期），因此，只有当初始股票头寸非零时，才会产生交易成本。到期时没有交易。\n\n设 $c = \\$0.50$。请仅使用无套利和超复制的第一性原理，确定期权卖方为保证期权的收益在两种状态下都能被覆盖而必须收取的最小初始期权费（无套利价格的上界）。将您的答案四舍五入到四位有效数字。以美元表示您的答案。", "solution": "该问题要求在一个存在固定交易成本的单期市場中，确定一份欧式看涨期权的最小初始期权费。该期权费对应于能够超复制期权收益的最便宜的投资组合的成本。超复制原则规定，对冲投资组合在到期时的价值必须在所有可能的未来状态下都大于或等于期权的收益。期权卖方旨在寻找构建这样一个投资组合所需的最小初始支出。\n\n首先，我们根据所提供的数据定义模型的参数。\n初始股价为 $S_{0} = 100$。\n上涨因子和下跌因子分别为 $u = 1.2$ 和 $d = 0.9$。\n该时期结束时的股价为：\n在“上涨”状态下：$S_{u} = S_{0} u = 100 \\times 1.2 = 120$。\n在“下跌”状态下：$S_{d} = S_{0} d = 100 \\times 0.9 = 90$。\n无风险总回报率为 $R = 1.05$。\n欧式看涨期权的执行价格为 $K = 100$。\n\n看涨期权在到期时（$t=1$）的收益取决于世界的状态。设 $C_1$ 为该收益。\n在“上涨”状态下，收益为 $C_{u} = \\max(S_{u} - K, 0) = \\max(120 - 100, 0) = 20$。\n在“下跌”状态下，收益为 $C_{d} = \\max(S_{d} - K, 0) = \\max(90 - 100, 0) = 0$。\n\n期权卖方必须在时间 $t=0$ 构建一个投资组合，包含 $\\Delta$ 股股票和投资于无风险资产的金额 $B$。投资组合在到期时的价值必须能覆盖期权的收益。这是一个静态对冲，意味着 $\\Delta$ 和 $B$ 在时间 $t=0$ 选定后不再改变。\n投资组合在时间 $t=1$ 时的价值为 $V_{1} = \\Delta S_{1} + B R$。\n超复制条件为：\n$V_{u} = \\Delta S_{u} + B R \\ge C_{u} \\implies 120\\Delta + 1.05B \\ge 20$。\n$V_{d} = \\Delta S_{d} + B R \\ge C_{d} \\implies 90\\Delta + 1.05B \\ge 0$。\n\n卖方必须收取的初始成本或期权费 $P$，是投资组合的初始价值加上任何交易成本。初始价值为 $V_{0} = \\Delta S_{0} + B = 100\\Delta + B$。如果持有非零的股票头寸，即 $\\Delta \\neq 0$，则会产生 $c = 0.50$ 的固定交易成本。\n需要最小化的总初始支出为：\n$$ P(\\Delta, B) = 100\\Delta + B + c \\cdot I(\\Delta \\neq 0) $$\n其中 $I(\\cdot)$ 是指示函数。\n\n为了最小化此成本，对于给定的 $\\Delta$，我们必须选择满足超复制不等式的最小可能值 $B$。\n从不等式中：\n$B R \\ge 20 - 120\\Delta$\n$B R \\ge 0 - 90\\Delta$\n因此，我们必须有 $B R \\ge \\max(20 - 120\\Delta, -90\\Delta)$。为了最小化 $B$，我们设：\n$$ B = \\frac{1}{R} \\max(20 - 120\\Delta, -90\\Delta) = \\frac{1}{1.05} \\max(20 - 120\\Delta, -90\\Delta) $$\n将此代入成本函数 $P$，我们得到一个关于单一变量 $\\Delta$ 的函数：\n$$ P(\\Delta) = 100\\Delta + \\frac{1}{1.05} \\max(20 - 120\\Delta, -90\\Delta) + 0.50 \\cdot I(\\Delta \\neq 0) $$\n我们必须找到使 $P(\\Delta)$ 最小化的 $\\Delta$ 值。由于指示函数的存在，合理的做法是分两种情况考虑：$\\Delta = 0$ 和 $\\Delta \\neq 0$。\n\n情况1：不持有股票（$\\Delta = 0$）。\n在这种情况下，交易成本为零。成本为：\n$$ P(0) = 100(0) + \\frac{1}{1.05} \\max(20 - 120(0), -90(0)) + 0 = \\frac{1}{1.05} \\max(20, 0) = \\frac{20}{1.05} $$\n仅使用无风险资产进行超复制的成本是 $P(0) = \\frac{20}{1.05} = \\frac{400}{21} \\approx 19.0476$。\n\n情况2：持有非零股票头寸（$\\Delta \\neq 0$）。\n在这种情况下，会产生 $c=0.50$ 的交易成本。成本函数为：\n$$ P(\\Delta) = 100\\Delta + \\frac{1}{1.05} \\max(20 - 120\\Delta, -90\\Delta) + 0.50 $$\n让我们分析函数 $f(\\Delta) = 100\\Delta + \\frac{1}{1.05} \\max(20 - 120\\Delta, -90\\Delta)$。这是一个凸函数，其最小值出现在 $\\max$ 函数的两个参数相等的地方：\n$$ 20 - 120\\Delta = -90\\Delta $$\n$$ 20 = 30\\Delta $$\n$$ \\Delta = \\frac{20}{30} = \\frac{2}{3} $$\n这个 $\\Delta$ 值是无摩擦市场中的标准对冲比率。由于 $\\Delta = \\frac{2}{3} \\neq 0$，这就是 $f(\\Delta)$ 達到最小值的点。$f(\\Delta)$ 的最小值为：\n$$ f\\left(\\frac{2}{3}\\right) = 100\\left(\\frac{2}{3}\\right) + \\frac{1}{1.05} \\left( -90 \\left(\\frac{2}{3}\\right) \\right) = \\frac{200}{3} - \\frac{60}{1.05} $$\n$$ f\\left(\\frac{2}{3}\\right) = \\frac{200}{3} - \\frac{60}{21/20} = \\frac{200}{3} - \\frac{1200}{21} = \\frac{200}{3} - \\frac{400}{7} = \\frac{1400 - 1200}{21} = \\frac{200}{21} $$\n所以，$f(\\Delta)$ 的最小值为 $\\frac{200}{21} \\approx 9.5238$。\n因此，对于任何 $\\Delta \\neq 0$ 的策略，其最小成本为：\n$$ P_{min, \\Delta \\neq 0} = f\\left(\\frac{2}{3}\\right) + 0.50 = \\frac{200}{21} + \\frac{1}{2} = \\frac{400 + 21}{42} = \\frac{421}{42} $$\n计算结果约为 $10.0238$。\n\n最后，为了找到总的最小期权费，我们比较两种情况下的成本：\n$\\Delta=0$ 时的成本：$P(0) = \\frac{400}{21} \\approx 19.0476$。\n$\\Delta \\neq 0$ 时的成本（在 $\\Delta = 2/3$ 处优化）：$P(2/3) = \\frac{421}{42} \\approx 10.0238$。\n\n最小期权费是这两个值中的较小者：\n$$ P_{min} = \\min\\left(\\frac{400}{21}, \\frac{421}{42}\\right) = \\frac{421}{42} $$\n卖方应该选择用 $\\Delta = 2/3$ 股股票进行对冲，因为尽管有交易费用，但这导致了更低的超复制成本。\n数值约为 $10.0238095...$。问题要求四舍五入到四位有效数字。这得到 $10.02$。\n最小初始期权费是 $\\$10.02$。", "answer": "$$\\boxed{10.02}$$"}, {"introduction": "掌握了 CRR 模型的基本原理和市场摩擦的影响后，我们可以进一步展示该框架的强大功能和灵活性，将其应用于为更复杂的金融工具定价。这个练习要求你为一份“远期开始”期权定价，这是一种非标准（或称“奇异”）的衍生品。完成这个任务需要你更深入地运用风险中性定价和鞅定价原理，去推导出一个适用于该特定产品的定价逻辑，从而体验到如何将基本概念扩展到更广泛的金融工程问题中。[@problem_id:2439216]", "id": "2439216", "problem": "考虑无套利条件下的 Cox–Ross–Rubinstein (CRR) 二叉树资产定价模型。一个资产价格过程 $\\{S_n\\}_{n=0}^{N}$ 在 $N$ 个离散时期内演变，每一步中，资产价格要么向上乘以一个因子 $u$，要么向下乘以一个因子 $d$，因此 $S_{n+1} \\in \\{u S_n, d S_n\\}$。每期的无风险总回报率为 $R$，假定其在时间上是恒定的，且满足无套利条件 $d < R < u$。在通过资产定价基本定理定义的风险中性概率 $p = (R - d)/(u - d)$ 下，贴现资产价格 $\\{S_n / R^n\\}$ 是一个鞅，并且任何到期日为 $N$ 的或有索取权在时间 $0$ 的价格等于其风险中性贴现期望。\n\n一个远期生效欧式看涨期权由一个生效时间 $t_1$ 指定，该时间对应于步数索引 $m \\in \\{0,1,\\dots,N\\}$。在时间 $m$，执行价格被设定为当时的资产价格，即 $K = S_m$。该期权在时间 $N$ 到期，其收益为 $(S_N - S_m)^{+}$，其中 $(x)^{+} = \\max\\{x, 0\\}$。\n\n任务：仅从上述核心定义（二叉树动态、无套利、风险中性定价以及贴现鞅性质）出发，推导一个算法来计算该远期生效看涨期权在时间 $0$ 的价格。该算法适用于满足 $d < R < u$ 和 $0 \\le m \\le N$ 的任意输入 $(S_0, u, d, R, N, m)$。您的程序必须实现此算法，并且除了这些原则之外，不得使用任何连续时间近似或外部公式。实现应采用数值稳定的方法计算风险中性期望，并且必须处理如 $m = 0$ 和 $m = N$ 之类的边界情况。\n\n测试的输入和输出规范：您的程序应硬编码以下参数集测试套件，每个参数集以元组 $(S_0, u, d, R, N, m)$ 的形式给出：\n\n- 测试 $1$（一般情况）：$(100.0, 1.1, 0.9, 1.02, 6, 2)$。\n- 测试 $2$（边界 $m = 0$）：$(100.0, 1.1, 0.9, 1.02, 6, 0)$。\n- 测试 $3$（边界 $m = N$）：$(75.0, 1.08, 0.93, 1.01, 5, 5)$。\n- 测试 $4$（每步零利率 $R = 1$ 且因子对称）：$(50.0, 1.2, 1.0/1.2, 1.0, 4, 1)$。\n- 测试 $5$（$m$ 之后剩余期限较短）：$(80.0, 1.05, 0.95, 1.01, 10, 7)$。\n\n最终输出格式要求为单行文本，其中包含按顺序排列的各测试价格，以逗号分隔，并用方括号括起来。每个价格必须是精确到 $6$ 位小数的实数。例如，一个包含三个假设结果的输出应如下所示：\"[12.345678,0.000000,3.210000]\"。", "solution": "我们在满足无套利条件 $d < R < u$ 的 Cox–Ross–Rubinstein (CRR) 二叉树模型中进行分析。根据资产定价基本定理，存在一个风险中性概率 $p = \\frac{R - d}{u - d}$，在该概率下，贴现资产价格过程 $\\left\\{\\frac{S_n}{R^n}\\right\\}_{n=0}^{N}$ 是一个鞅。任何在时间 $N$ 可测的或有索取权 $X_N$ 在时间 $0$ 的价格 $V_0$ 由 $V_0 = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-N} X_N\\right]$ 给出，其中 $\\mathbb{Q}$ 表示风险中性测度。\n\n我们考虑一个远期生效欧式看涨期权，它在第 $m$ 步生效，执行价格为 $K = S_m$，并在第 $N$ 步到期，其收益为 $X_N = (S_N - S_m)^{+}$。为计算其在时间 $0$ 的价格，我们使用两个基本原则：\n\n1. 对从 $m$ 到 $N$ 的子时段进行风险中性定价。\n2. 贴现资产的鞅性质。\n\n固定由二叉树过程生成的信息流 $\\{\\mathcal{F}_n\\}$。在时间 $m$，以 $\\mathcal{F}_m$ 为条件，收益可以重写为\n$$\nX_N = \\left(S_N - S_m\\right)^{+} = S_m \\left(\\frac{S_N}{S_m} - 1\\right)^{+}.\n$$\n将子时段内的乘性回报率定义为\n$$\nY := \\frac{S_N}{S_m},\n$$\n它仅取决于时间 $m$ 之后的 $N - m$ 次价格跳动；具体来说，$Y \\in \\{u^k d^{(N-m)-k} : k = 0,1,\\dots,N-m\\}$。那么，在时间 $m$ 的价值为\n$$\nV_m = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} X_N \\,\\middle|\\, \\mathcal{F}_m \\right]\n= \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} S_m (Y - 1)^{+} \\,\\middle|\\, \\mathcal{F}_m \\right].\n$$\n因为 $S_m$ 是 $\\mathcal{F}_m$-可测的，并且 $Y$ 在给定 $\\mathcal{F}_m$ 的情况下仅取决于未来的变动，所以我们可以将 $S_m$ 提出来：\n$$\nV_m = S_m \\cdot \\underbrace{\\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} (Y - 1)^{+} \\right]}_{=: c_{\\text{rel}}}.\n$$\n量 $c_{\\text{rel}}$ 是确定性的（它不依赖于已实现的 $S_m$），因为它只依赖于 $u$、$d$、$R$ 和步数 $N - m$。因此，\n$$\nV_m = S_m \\, c_{\\text{rel}}.\n$$\n\n接下来，应用从时间 $0$ 到时间 $m$ 的风险中性估值：\n$$\nV_0 = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} V_m \\right] = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} S_m \\right] \\, c_{\\text{rel}}.\n$$\n根据贴现价格的鞅性质，$\\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} S_m\\right] = S_0$。因此，\n$$\nV_0 = S_0 \\, c_{\\text{rel}}.\n$$\n\n剩下的任务是从第一性原理计算 $c_{\\text{rel}}$。在 $\\mathbb{Q}$ 下，$N - m$ 步中的上涨次数 $K$ 服从参数为 $n := N - m$ 和 $p = \\frac{R - d}{u - d}$ 的二项分布。乘性回报率为 $Y = u^{K} d^{n-K}$。因此，\n$$\nc_{\\text{rel}} = R^{-n} \\sum_{k=0}^{n} \\binom{n}{k} p^{k} (1-p)^{n-k} \\, \\max\\!\\left(u^{k} d^{n-k} - 1, 0\\right).\n$$\n此公式是直接从风险中性贴现期望和未来上涨次数的二项分布中得到的。立即可以进行两个边界检查：\n- 如果 $m=N$，则 $n=0$ 且 $Y=1$，因此 $\\max(Y-1,0)=0$ 且 $c_{\\text{rel}}=0$，得出 $V_0 = 0$。\n- 如果 $m=0$，则 $V_0 = S_0 \\, c_{\\text{rel}}$ 等于一个执行价格为 $K = S_0$、期限为 $N$ 步的平价看涨期权在时间 $0$ 的价格，这与立即生效的远期生效期权的定义是一致的。\n\n算法设计：\n- 输入 $(S_0, u, d, R, N, m)$，满足 $d < R < u$ 和 $0 \\le m \\le N$。\n- 计算 $n \\leftarrow N - m$。如果 $n = 0$，返回 $0.0$。\n- 计算 $p \\leftarrow (R - d)/(u - d)$ 和 $q \\leftarrow 1 - p$。\n- 计算\n$$\nc_{\\text{rel}} \\leftarrow R^{-n} \\sum_{k=0}^{n} \\binom{n}{k} p^{k} q^{n-k} \\, \\max\\!\\left(u^{k} d^{n-k} - 1, 0\\right).\n$$\n- 返回 $V_0 \\leftarrow S_0 \\cdot c_{\\text{rel}}$。\n- 为了数值稳定性，可以通过递归更新二项概率质量函数，或者在 $n$ 不大时使用精确的整数二项式系数与浮点数幂来计算 $\\binom{n}{k} p^{k} q^{n-k}$。此处的测试使用的 $n$ 值不大，因此两种方法都是稳定的。结果四舍五入到 $6$ 位小数。\n\n此构建过程仅使用了核心原则：无套利下的风险中性测度的存在性、贴现价格的鞅性质，以及风险中性定价作为贴现期望的定义。它避免了任何连续时间近似，并完全依赖于二叉树结构和基本概率论。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef forward_start_call_price_crr(S0, u, d, R, N, m):\n    \"\"\"\n    Price a forward-start European call in the CRR model.\n    At time m, the strike is set to S_m; maturity at N; payoff is (S_N - S_m)+.\n    Parameters:\n        S0 : float, initial asset price S_0\n        u  : float, up factor per step\n        d  : float, down factor per step\n        R  : float, risk-free gross rate per step\n        N  : int, total number of steps to maturity\n        m  : int, activation step (0 <= m <= N)\n    Returns:\n        float, time-0 price\n    \"\"\"\n    # Handle trivial case: if m == N, payoff is zero.\n    n = N - m\n    if n == 0:\n        return 0.0\n\n    # Risk-neutral probability\n    p = (R - d) / (u - d)\n    q = 1.0 - p\n\n    # Compute c_rel = E[ R^{-n} * max(Y - 1, 0) ] with Y = u^K d^{n-K}, K ~ Bin(n,p)\n    # Use exact binomial coefficients for modest n.\n    c_rel = 0.0\n    R_disc = R ** (-n)\n    # To avoid redundant power computations, precompute powers if beneficial\n    # but here n is small in tests; we compute directly for clarity.\n    for k in range(n + 1):\n        # Binomial probability\n        comb = math.comb(n, k)\n        prob = comb * (p ** k) * (q ** (n - k))\n        # Relative terminal factor\n        y = (u ** k) * (d ** (n - k))\n        payoff = y - 1.0\n        if payoff > 0.0:\n            c_rel += prob * payoff\n\n    c_rel *= R_disc\n    return S0 * c_rel\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (S0, u, d, R, N, m)\n    test_cases = [\n        (100.0, 1.1, 0.9, 1.02, 6, 2),                         # Test 1\n        (100.0, 1.1, 0.9, 1.02, 6, 0),                         # Test 2 (m=0)\n        (75.0, 1.08, 0.93, 1.01, 5, 5),                        # Test 3 (m=N -> price 0)\n        (50.0, 1.2, 1.0/1.2, 1.0, 4, 1),                       # Test 4 (R=1, symmetric u,d)\n        (80.0, 1.05, 0.95, 1.01, 10, 7),                       # Test 5 (short remaining horizon)\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, u, d, R, N, m = case\n        price = forward_start_call_price_crr(S0, u, d, R, N, m)\n        results.append(f\"{price:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}