{"hands_on_practices": [{"introduction": "简化式模型的核心思想是将违约视为一个由特定“强度”驱动的随机事件。本练习将这个抽象概念付诸实践。通过模拟大量公司的违约时间，您将亲手建立起违约强度 $\\lambda$ 与实际违约事件分布之间的直观联系，这对于理解这些模型基于的泊松过程至关重要。[@problem_id:2425480]", "id": "2425480", "problem": "要求您实现一个程序，用于模拟简化形式（强度）模型中独立公司的违约时间，该模型假设违约强度为恒定值。在此框架下，单个公司的违约时间是一个具有恒定强度参数 $ \\lambda $ 的随机时间，并且各公司之间的违约是相互独立的。所有时间量均以年为单位。\n\n您的程序必须针对每个指定的测试用例，在恒定强度 $ \\lambda $ 下生成 $ N $ 个独立的违约时间，在有限时间域 $ [0, T] $ 内观察此过程（在 $ T $ 之后发生的违约不予计算），将该时间域划分为宽度为 $ w $ 年的等宽时间区间（bin），并统计落入每个区间的违约次数。如果 $ \\lambda = 0 $，则解释为在任何有限时间域内均不会发生违约。如果 $ N = 0 $，则解释为没有需要模拟的公司。这些区间必须将 $ [0, T] $ 精确地划分为 $ B $ 个宽度为 $ w $ 的相等子区间，其中 $ B = T / w $ 是一个整数。请使用提供的随机种子以确保可复现性。\n\n对于每个测试用例，所要求的输出是每个区间的整数计数值列表，从最早的时间区间到最晚的时间区间排序。其中，每个区间对应半开区间 $ [t_k, t_{k+1}) $（对于 $ k = 0, 1, \\dots, B - 2 $），最后一个区间包含右端点 $ T $，即 $ [t_{B-1}, T] $，其中 $ t_k = k w $。\n\n测试套件：\n- 案例 1（一般情况）：$ N = 1000 $，$ \\lambda = 0.05 $ 每年，$ T = 80 $ 年，$ w = 5 $ 年，随机种子 $ s = 1729 $。\n- 案例 2（零强度边界情况）：$ N = 1000 $，$ \\lambda = 0 $，$ T = 20 $ 年，$ w = 5 $ 年，随机种子 $ s = 7 $。\n- 案例 3（高强度，短时间域）：$ N = 1000 $，$ \\lambda = 2.0 $ 每年，$ T = 3.0 $ 年，$ w = 0.5 $ 年，随机种子 $ s = 2024 $。\n- 案例 4（零公司边界情况）：$ N = 0 $，$ \\lambda = 0.1 $ 每年，$ T = 10 $ 年，$ w = 1 $ 年，随机种子 $ s = 99 $。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的列表的列表形式的结果，且不含任何空格。例如，如果有两个测试用例，一个可接受的格式是：`[[1,2,3],[0,0,1]]`。在本问题中，您必须输出四个列表（每个测试用例一个），并将它们聚合到单行上的一个顶级列表中，无任何附加文本。\n\n所有时间单位均为年，所有输出均为每个区间的无量纲整数计数值。本任务不涉及角度。最终输出必须严格遵循指定的单行格式。", "solution": "在尝试任何解决方案之前，将首先对问题陈述进行严格的验证过程。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n\n所提供的明确数据、变量和条件如下：\n- **模型**：独立公司的简化形式（强度）模型。\n- **违约强度**：恒定参数，记为 $\\lambda$。\n- **违约时间**：由强度 $\\lambda$ 控制的随机变量 $\\tau$。若 $\\lambda=0$，则不发生违约。\n- **公司数量**：$N$。若 $N=0$，则不模拟任何公司。\n- **观察时间域**：一个有限区间 $[0, T]$。时间 $T$ 之后的违约将被丢弃。\n- **时间区间**：时间域 $[0, T]$ 被划分为 $B$ 个宽度为 $w$ 的等宽区间。\n- **区间划分**：$B = T/w$ 是一个整数。区间为 $[t_k, t_{k+1})$（对于 $k = 0, 1, \\dots, B-2$），最后一个区间为 $[t_{B-1}, T]$，其中 $t_k = kw$。\n- **随机性**：为每个测试用例提供一个随机种子 $s$ 以确保可复现性。\n- **输出**：对于每个测试用例，输出一个包含每个区间违约计数的整数列表。\n\n**测试套件：**\n- **案例 1**：$N = 1000$，$\\lambda = 0.05$ 年$^{-1}$，$T = 80$ 年，$w = 5$ 年，$s = 1729$。\n- **案例 2**：$N = 1000$，$\\lambda = 0$ 年$^{-1}$，$T = 20$ 年，$w = 5$ 年，$s = 7$。\n- **案例 3**：$N = 1000$，$\\lambda = 2.0$ 年$^{-1}$，$T = 3.0$ 年，$w = 0.5$ 年，$s = 2024$。\n- **案例 4**：$N = 0$，$\\lambda = 0.1$ 年$^{-1}$，$T = 10$ 年，$w = 1$ 年，$s = 99$。\n\n**步骤2：使用提取的给定条件进行验证**\n\n根据验证标准对问题进行评估：\n\n1.  **科学基础**：该问题描述了使用强度模型模拟违约时间。这等同于将违约建模为具有恒定强度 $\\lambda$ 的泊松过程的首次到达时间。此类事件的发生时间是一个著名的随机变量，遵循指数分布。该框架是量化金融和信用风险建模的基石。其前提在科学上和数学上都是合理的。\n\n2.  **良构性**：问题表述明确。每个案例的所有参数（$N$、$\\lambda$、$T$、$w$、$s$）都已指定。模拟违约时间并在离散时间区间内进行计数的任务定义清晰。使用随机种子确保了模拟虽然原则上是随机的，但能产生唯一的、确定性的输出。该问题是良构的。\n\n3.  **客观性**：语言是形式化且量化的。没有主观的、基于观点的或模棱两可的陈述。\n\n**步骤3：结论与行动**\n\n该问题是 **有效的**。这是一个基于概率论基本原理及其在计算金融学中应用的标准、明确定义的模拟任务。将提供解决方案。\n\n### 解决方案推导\n\n该问题要求模拟 $N$ 个独立公司的违约时间。每个公司的违约由一个恒定的强度 $\\lambda$ 控制。这是一个经典的泊松过程模型。\n\n**理论基础**\n\n在具有恒定速率 $\\lambda$ 的泊松过程中，首次事件（违约）发生的时间是一个随机变量 $\\tau$，它遵循指数分布。公司在时间 $t$ 之前尚未违约的概率，即生存概率，由下式给出：\n$$\nS(t) = P(\\tau > t) = e^{-\\lambda t}\n$$\n因此，违约时间 $\\tau$ 的累积分布函数 (CDF)，即违约在时间 $t$ 或之前发生的概率，为：\n$$\nF(t) = P(\\tau \\le t) = 1 - S(t) = 1 - e^{-\\lambda t}\n$$\n\n**模拟方法论**\n\n为了从给定分布中生成随机变量，逆变换采样法是一种标准且稳健的技术。设 $U$ 是从区间 $(0, 1)$ 上的标准均匀分布中抽取的随机变量，即 $U \\sim \\text{Uniform}(0, 1)$。我们可以通过设 $F(\\tau) = U$ 并解出 $\\tau$ 来从指数分布中生成一个样本 $\\tau$：\n$$\nU = 1 - e^{-\\lambda \\tau}\n$$\n$$\n1 - U = e^{-\\lambda \\tau}\n$$\n$$\n\\ln(1 - U) = -\\lambda \\tau\n$$\n$$\n\\tau = -\\frac{1}{\\lambda} \\ln(1 - U)\n$$\n由于 $1 - U$ 也服从 $\\text{Uniform}(0, 1)$ 分布，我们可以将表达式简化为：\n$$\n\\tau = -\\frac{1}{\\lambda} \\ln(U)\n$$\n此公式用于为 $N$ 家公司中的每一家生成违约时间。\n\n**算法实现**\n\n对于由参数 $(N, \\lambda, T, w, s)$ 指定的每个测试用例，执行以下算法：\n\n1.  **初始化**：使用给定的种子 $s$ 初始化一个伪随机数生成器，以确保结果是可复现的。\n\n2.  **边界情况处理**：\n    *   如果公司数量 $N = 0$，则没有需要模拟的违约。\n    *   如果违约强度 $\\lambda = 0$，则任何公司的违约时间 $\\tau = \\infty$。在这两种情况下，有限时间域 $[0, T]$ 内都不会观察到违约。\n    *   区间数量为 $B = T/w$。这些情况的输出是一个包含 $B$ 个零的列表。\n\n3.  **一般情况模拟** ($N > 0$ 且 $\\lambda > 0$)：\n    a.  **生成随机变量**：从分布 $\\text{Uniform}(0, 1)$ 中抽取一个包含 $N$ 个独立随机数 $\\{U_i\\}_{i=1}^N$ 的向量。\n    b.  **生成违约时间**：使用逆变换公式 $\\tau_i = -\\frac{1}{\\lambda} \\ln(U_i)$ 将此向量转换为违约时间向量 $\\{\\tau_i\\}_{i=1}^N$。为提高计算效率，此操作以向量化的方式执行。\n    c.  **应用时间域约束**：问题陈述指出，只统计在时间域 $[0, T]$ 内的违约。因此，对模拟出的违约时间进行筛选，只保留那些满足 $\\tau_i \\le T$ 的时间。\n    d.  **区间划分**：将观察区间 $[0, T]$ 分为 $B = T/w$ 个区间。区间边界由序列 $\\{0, w, 2w, \\dots, (B-1)w, T\\}$ 定义。通过统计落入每个区间的已筛选违约时间的数量来构建一个直方图。问题指定第 $k$ 个区间为半开区间 $[kw, (k+1)w)$（สำหรับ $k \\in \\{0, \\dots, B-2\\}$），最后一个区间为闭区间 $[(B-1)w, T]$。标准数值库提供了能够正确实现此逻辑的直方图函数。例如，Python 中的 `numpy.histogram` 函数及其默认设置精确匹配此要求。\n    e.  **输出**：为每个区间生成的计数值数组构成了该测试用例的最终答案。\n\n此过程被系统地应用于所提供的四个测试用例中的每一个。最终输出是将每个案例的结果聚合到一个单一的格式化字符串中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates default times in a reduced-form model and provides bin counts.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case)\n        {'N': 1000, 'lambda': 0.05, 'T': 80.0, 'w': 5.0, 'seed': 1729},\n        # Case 2 (zero intensity edge case)\n        {'N': 1000, 'lambda': 0.0, 'T': 20.0, 'w': 5.0, 'seed': 7},\n        # Case 3 (high intensity, short horizon)\n        {'N': 1000, 'lambda': 2.0, 'T': 3.0, 'w': 0.5, 'seed': 2024},\n        # Case 4 (zero firms edge case)\n        {'N': 0, 'lambda': 0.1, 'T': 10.0, 'w': 1.0, 'seed': 99},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        lam = case['lambda']\n        T = case['T']\n        w = case['w']\n        seed = case['seed']\n\n        # The number of bins, B, is guaranteed to be an integer.\n        num_bins = int(T / w)\n\n        # Handle edge cases where N=0 or lambda=0.\n        # If N=0, there are no firms to default.\n        # If lambda=0, the intensity is zero, so the default time is infinite.\n        # In both scenarios, no defaults occur in any finite horizon.\n        if N == 0 or lam == 0:\n            counts = [0] * num_bins\n            results.append(counts)\n            continue\n\n        # Initialize the random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Generate N uniform random variables from (0, 1).\n        # We use rng.random which is exclusive of 1.0, but log(0) is still an issue\n        # if the sample is exactly 0. In practice, this is exceedingly rare.\n        # np.random.uniform is on [low, high), so we can use it on (0,1)\n        # However, np.random.random() is sufficient and standard.\n        uniform_samples = rng.random(size=N)\n\n        # Apply the inverse transform sampling method to get exponentially distributed default times.\n        # tau = - (1/lambda) * ln(U)\n        default_times = -np.log(uniform_samples) / lam\n\n        # Filter out defaults that occur after the time horizon T.\n        defaults_in_horizon = default_times[default_times <= T]\n\n        # Define the bin edges for the histogram.\n        # np.linspace(0, T, num_bins + 1) creates edges [0, w, 2w, ..., T].\n        bin_edges = np.linspace(0.0, T, num_bins + 1)\n\n        # Use numpy.histogram to count defaults in each bin.\n        # By default, np.histogram uses bins as [edge, next_edge) for all but the\n        # last bin, which is [last_edge_-1, last_edge]. This matches the problem spec exactly.\n        # The problem states: \"[t_k, t_{k+1})\" for k=0..B-2, and \"[t_{B-1}, T]\" for the last bin.\n        counts_np, _ = np.histogram(defaults_in_horizon, bins=bin_edges)\n\n        # Convert the numpy array of counts to a list of standard Python integers.\n        counts = counts_np.tolist()\n        \n        results.append(counts)\n\n    # The required output format is a single line with no spaces.\n    # repr() creates a string representation, e.g., \"[[1, 2], [3, 4]]\".\n    # .replace(' ', '') removes all spaces to match the required format \"[[1,2],[3,4]]\".\n    final_output = repr(results).replace(' ', '')\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "在现实世界中，违约风险并非一成不变，而是与借款人的具体特征密切相关。本练习将您从恒定强度的简单模型带入一个更真实的场景，在这里，违约强度 $\\lambda(\\mathbf{x})$ 是借款人信用分数和收入等协变量的函数。通过处理包含违约和未违约（右删失）贷款的数据集，您将学习使用最大似然估计（MLE）这一强大的统计工具来校准模型参数，这是构建实用信用风险模型的关键一步。[@problem_id:2425483]", "id": "2425483", "problem": "考虑一个针对无担保个人对个人（peer-to-peer）消费贷款的基于强度的简约形式违约模型。设违约时间为一个非负随机变量，在观测窗口内具有条件恒定的违约强度，记为 $\\lambda(\\mathbf{x})$，其中 $\\mathbf{x}$ 表示借款人协变量。违约强度由转换后协变量的对数线性函数指定：\n$$\n\\lambda(\\mathbf{x}) \\equiv \\exp\\!\\left(\\theta_0 + \\theta_1\\,g_1(\\text{FICO}) + \\theta_2\\,g_2(\\text{INC})\\right),\n$$\n其中 $g_1(\\text{FICO}) = \\dfrac{\\text{FICO} - 700}{100}$ 且 $g_2(\\text{INC}) = \\ln\\!\\left(\\dfrac{\\text{INC}}{50000}\\right)$。这里使用自然对数。时间单位为年，收入单位为美元/年。\n\n假设观测到 $6$ 笔独立的贷款，每笔贷款都有协变量、以年为单位的观测时间以及一个右删失指标。对于贷款 $i$，观测时间为 $t_i \\ge 0$，事件指标为 $d_i \\in \\{0,1\\}$，其中 $d_i=1$ 表示在时间 $t_i$ 发生违约，$d_i=0$ 表示在时间 $t_i$ 发生右删失。观测到的数据集如下：\n- 贷款 A：FICO $650$，收入 $30000$，观测时间 $0.5$，违约指标 $1$。\n- 贷款 B：FICO $720$，收入 $60000$，观测时间 $1.0$，违约指标 $0$。\n- 贷款 C：FICO $680$，收入 $45000$，观测时间 $0.8$，违约指标 $1$。\n- 贷款 D：FICO $760$，收入 $120000$，观测时间 $1.2$，违约指标 $0$。\n- 贷款 E：FICO $700$，收入 $50000$，观测时间 $1.5$，违约指标 $0$。\n- 贷款 F：FICO $600$，收入 $25000$，观测时间 $0.3$，违约指标 $1$。\n\n在上述模型下，假设给定 $\\mathbf{x}$ 时违约时间服从条件指数分布，并且各贷款之间相互独立，请通过最大化模型与观测数据所蕴含的似然来估计参数向量 $\\boldsymbol{\\theta} = (\\theta_0,\\theta_1,\\theta_2)$。\n\n在估计出 $\\boldsymbol{\\theta}$ 后，对以下每个测试案例，使用相同的协变量变换 $g_1$ 和 $g_2$，计算在固定期限 $H$（以年为单位）内模型所蕴含的违约概率：\n\n新贷款及期限的测试集：\n- 案例 $1$：FICO $710$，收入 $55000$，期限 $H=1.0$。\n- 案例 $2$：FICO $580$，收入 $20000$，期限 $H=1.0$。\n- 案例 $3$：FICO $800$，收入 $200000$，期限 $H=1.0$。\n- 案例 $4$：FICO $700$，收入 $50000$，期限 $H=0.5$。\n\n您的程序必须：\n- 接收上述固定数据集，并仅使用所提供的信息和模型定义来估计 $\\boldsymbol{\\theta}$。\n- 对每个测试案例，计算在指定期限 $H$ 内发生违约的概率，结果表示为 $[0,1]$ 区间内的一个小数。\n- 生成单行输出，其中包含按案例 $1$ 到 $4$ 排序的结果，形式为方括号内以逗号分隔的列表，每个值四舍五入到 $6$ 位小数。例如，输出应类似于 $[0.123456,0.234567,0.345678,0.456789]$。\n\n所有时间都必须以年为单位处理。所有概率都必须以小数形式表示，而不是百分比，并且在最终输出中必须精确四舍五入到 $6$ 位小数。", "solution": "对问题陈述进行验证。\n\n逐字提取给定信息：\n- 模型：基于强度的简约形式模型。\n- 违约强度：$\\lambda(\\mathbf{x}) \\equiv \\exp\\!\\left(\\theta_0 + \\theta_1\\,g_1(\\text{FICO}) + \\theta_2\\,g_2(\\text{INC})\\right)$。\n- 协变量变换：$g_1(\\text{FICO}) = \\dfrac{\\text{FICO} - 700}{100}$ 和 $g_2(\\text{INC}) = \\ln\\!\\left(\\dfrac{\\text{INC}}{50000}\\right)$。\n- 时间单位：年。\n- 数据：$6$ 笔独立的贷款，包含协变量（$\\text{FICO}_i, \\text{INC}_i$）、观测时间 $t_i$ 和违约指标 $d_i \\in \\{0,1\\}$。\n    - 贷款 A：FICO $650$，收入 $30000$，$t_A=0.5$，$d_A=1$。\n    - 贷款 B：FICO $720$，收入 $60000$，$t_B=1.0$，$d_B=0$。\n    - 贷款 C：FICO $680$，收入 $45000$，$t_C=0.8$，$d_C=1$。\n    - 贷款 D：FICO $760$，收入 $120000$，$t_D=1.2$，$d_D=0$。\n    - 贷款 E：FICO $700$，收入 $50000$，$t_E=1.5$，$d_E=0$。\n    - 贷款 F：FICO $600$，收入 $25000$，$t_F=0.3$，$d_F=1$。\n- 任务1：通过最大似然估计（MLE）来估计 $\\boldsymbol{\\theta} = (\\theta_0,\\theta_1,\\theta_2)$。\n- 任务2：为 $4$ 个测试案例计算模型蕴含的在期限 $H$ 内的违约概率。\n    - 案例 $1$：FICO $710$，收入 $55000$，$H=1.0$。\n    - 案例 $2$：FICO $580$，收入 $20000$，$H=1.0$。\n    - 案例 $3$：FICO $800$，收入 $200000$，$H=1.0$。\n    - 案例 $4$：FICO $700$，收入 $50000$，$H=0.5$。\n- 输出格式：方括号内以逗号分隔的概率列表，四舍五入到 $6$ 位小数。\n\n验证结论：\n该问题具有科学依据、提法明确且客观。它描述了生存分析的一个标准应用，具体来说是带有右删失数据的指数回归模型，这是生物统计学和计量经济学中用于为事件发生时间现象建模的常用技术。模型被完整地指定，数据已提供，目标清晰。没有矛盾、歧义或违反科学原则之处。该问题有效。我们继续进行求解。\n\n问题的核心是通过最大化观测数据的似然函数来估计参数化生存模型的参数向量 $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1, \\theta_2)^T$。该模型假设，对于一笔给定协变量 $\\mathbf{x}$ 的贷款，其违约时间 $T$ 是一个指数随机变量，其恒定速率参数为 $\\lambda(\\mathbf{x})$，也称为违约强度。该强度由对数线性形式 $\\lambda(\\mathbf{x}) = \\exp(\\boldsymbol{\\theta}^T \\mathbf{x})$ 给出，其中 $\\mathbf{x} = [1, g_1(\\text{FICO}), g_2(\\text{INC})]^T$ 是转换后协变量的向量，包含用于截距项 $\\theta_0$ 的常数。\n\n对于速率为 $\\lambda$ 的指数分布，其概率密度函数（PDF）为 $f(t|\\lambda) = \\lambda e^{-\\lambda t}$，生存函数为 $S(t|\\lambda) = P(T > t) = e^{-\\lambda t}$。数据集包含右删失观测值。对于一个观测时间为 $t_i$、事件指标为 $d_i$ 的观测 $i$：\n- 如果发生违约（$d_i=1$），则事件在时间 $t_i$ 被观测到，其对似然的贡献是在 $t_i$ 处求值的 PDF：$f(t_i|\\lambda_i) = \\lambda_i e^{-\\lambda_i t_i}$。\n- 如果观测值是右删失的（$d_i=0$），则事件在时间 $t_i$ 尚未发生，其对似然的贡献是存活超过 $t_i$ 的概率：$S(t_i|\\lambda_i) = e^{-\\lambda_i t_i}$。\n\n单个观测 $i$ 的似然贡献可以紧凑地写为：\n$$\nL_i(\\boldsymbol{\\theta}) = [f(t_i|\\lambda_i)]^{d_i} [S(t_i|\\lambda_i)]^{1-d_i} = (\\lambda_i e^{-\\lambda_i t_i})^{d_i} (e^{-\\lambda_i t_i})^{1-d_i} = \\lambda_i^{d_i} e^{-\\lambda_i t_i}.\n$$\n假设 $N=6$ 笔贷款之间相互独立，总似然是各项贡献的乘积：\n$$\nL(\\boldsymbol{\\theta}) = \\prod_{i=1}^{N} L_i(\\boldsymbol{\\theta}) = \\prod_{i=1}^{N} \\lambda_i^{d_i} e^{-\\lambda_i t_i}.\n$$\n最大化似然等价于一个数值上更稳定的任务，即最大化对数似然函数 $\\ell(\\boldsymbol{\\theta}) = \\ln L(\\boldsymbol{\\theta})$：\n$$\n\\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\ln(\\lambda_i^{d_i} e^{-\\lambda_i t_i}) = \\sum_{i=1}^{N} (d_i \\ln \\lambda_i - \\lambda_i t_i).\n$$\n代入 $\\lambda_i = \\exp(\\boldsymbol{\\theta}^T \\mathbf{x}_i)$，对数似然函数变为：\n$$\n\\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left(d_i (\\boldsymbol{\\theta}^T \\mathbf{x}_i) - t_i \\exp(\\boldsymbol{\\theta}^T \\mathbf{x}_i)\\right).\n$$\n该函数需要相对于 $\\boldsymbol{\\theta}$ 进行最大化。这是一个标准的无约束优化问题。我们可以通过找到对数似然函数梯度的根来求得最优参数 $\\hat{\\boldsymbol{\\theta}}$。关于每个参数 $\\theta_j$ 的偏导数为：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_j} = \\sum_{i=1}^{N} \\left( d_i x_{ij} - t_i \\exp(\\boldsymbol{\\theta}^T \\mathbf{x}_i) x_{ij} \\right) = \\sum_{i=1}^{N} x_{ij} (d_i - t_i \\lambda_i).\n$$\n将梯度向量 $\\nabla_{\\boldsymbol{\\theta}} \\ell(\\boldsymbol{\\theta})$ 设为零，得到一个必须通过数值方法求解的非线性方程组。这可以通过使用拟牛顿法（如 BFGS）最小化负对数似然 $-\\ell(\\boldsymbol{\\theta})$ 来实现，该方法利用梯度信息来指导寻找最小值。\n\n首先，我们根据训练数据构建 $6 \\times 3$ 的设计矩阵 $\\mathbf{X}$，其中每一行对应一笔贷款，形式为 $[1, g_1(\\text{FICO}_i), g_2(\\text{INC}_i)]$。我们还构成观测时间向量 $\\mathbf{t}$ 和事件指标向量 $\\mathbf{d}$。需要最小化的负对数似然函数是：\n$$\n-\\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left( t_i \\exp(\\boldsymbol{\\theta}^T \\mathbf{x}_i) - d_i (\\boldsymbol{\\theta}^T \\mathbf{x}_i) \\right).\n$$\n该目标函数的梯度为 $\\mathbf{X}^T(\\mathbf{t} \\odot \\boldsymbol{\\lambda} - \\mathbf{d})$，其中 $\\odot$ 表示逐元素乘法。\n\n一旦获得最大似然估计 $\\hat{\\boldsymbol{\\theta}}$，我们就可以计算具有协变量 $\\mathbf{x}_{\\text{new}}$ 的新贷款在期限 $H$ 内的违约概率。估计的违约强度为 $\\hat{\\lambda}_{\\text{new}} = \\exp(\\hat{\\boldsymbol{\\theta}}^T \\mathbf{x}_{\\text{new}})$。到时间 $H$ 时发生违约的概率由指数分布的累积分布函数给出：\n$$\nP(T \\le H | \\mathbf{x}_{\\text{new}}) = 1 - S(H | \\mathbf{x}_{\\text{new}}) = 1 - e^{-\\hat{\\lambda}_{\\text{new}} H}.\n$$\n对问题陈述中提供的四个测试案例中的每一个，都使用其各自的协变量和期限执行此计算。最终的数值结果四舍五入到 $6$ 位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating parameters for a reduced-form default model\n    and calculating default probabilities for new loans.\n    \"\"\"\n    \n    # Step 1: Define the training dataset from the problem statement.\n    # Data: (FICO, Income, Observed Time, Default Indicator)\n    training_data = [\n        (650, 30000, 0.5, 1),  # Loan A\n        (720, 60000, 1.0, 0),  # Loan B\n        (680, 45000, 0.8, 1),  # Loan C\n        (760, 120000, 1.2, 0),  # Loan D\n        (700, 50000, 1.5, 0),  # Loan E\n        (600, 25000, 0.3, 1),  # Loan F\n    ]\n\n    # Step 2: Define covariate transformation functions.\n    def g1(fico):\n        return (fico - 700) / 100\n\n    def g2(income):\n        return np.log(income / 50000)\n\n    # Step 3: Prepare the design matrix X and vectors t_obs, d_obs.\n    n_loans = len(training_data)\n    X = np.zeros((n_loans, 3))\n    t_obs = np.zeros(n_loans)\n    d_obs = np.zeros(n_loans)\n\n    for i, (fico, income, time, default) in enumerate(training_data):\n        X[i, 0] = 1 # Intercept\n        X[i, 1] = g1(fico)\n        X[i, 2] = g2(income)\n        t_obs[i] = time\n        d_obs[i] = default\n\n    # Step 4: Define the negative log-likelihood function and its gradient for optimization.\n    def neg_log_likelihood(theta):\n        \"\"\"Negative log-likelihood function for exponential regression model.\"\"\"\n        eta = X @ theta\n        lambda_vals = np.exp(eta)\n        log_lik = d_obs @ eta - t_obs @ lambda_vals\n        return -log_lik\n    \n    def grad_neg_log_likelihood(theta):\n        \"\"\"Gradient of the negative log-likelihood function.\"\"\"\n        eta = X @ theta\n        lambda_vals = np.exp(eta)\n        residual = t_obs * lambda_vals - d_obs\n        grad = X.T @ residual\n        return grad\n\n    # Step 5: Perform Maximum Likelihood Estimation using a numerical optimizer.\n    theta_initial = np.zeros(3) # Initial guess for theta = (theta_0, theta_1, theta_2)\n    \n    # Using BFGS algorithm which is a quasi-Newton method.\n    opt_result = minimize(\n        fun=neg_log_likelihood,\n        x0=theta_initial,\n        method='BFGS',\n        jac=grad_neg_log_likelihood,\n        options={'disp': False}\n    )\n    \n    theta_hat = opt_result.x\n\n    # Step 6: Define test cases and compute default probabilities.\n    test_cases = [\n        # (FICO, Income, Horizon H)\n        (710, 55000, 1.0),   # Case 1\n        (580, 20000, 1.0),   # Case 2\n        (800, 200000, 1.0),  # Case 3\n        (700, 50000, 0.5),   # Case 4\n    ]\n\n    results = []\n    for fico, income, horizon in test_cases:\n        # Create covariate vector for the test case\n        x_new = np.array([1, g1(fico), g2(income)])\n        \n        # Calculate estimated default intensity\n        lambda_hat = np.exp(x_new @ theta_hat)\n        \n        # Calculate probability of default within the horizon\n        prob_default = 1 - np.exp(-lambda_hat * horizon)\n        \n        results.append(prob_default)\n\n    # Step 7: Format the output as specified.\n    # The results must be rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "理论模型的一大价值在于它们能帮助我们解读市场价格并分析其间的差异。本练习将运用简化式框架来分析一个重要的市场现象：CDS-债券基差（CDS-bond basis）。您将分别从公司债券和信用违约互换（Credit Default Swap, CDS）的市场价格中反推出隐含的违约强度，并比较二者的差异，从而深入理解不同金融工具如何对同一信用风险进行定价，并体会理论模型在连接金融市场中的实际应用。[@problem_id:2425537]", "id": "2425537", "problem": "一家公司发行了一支为期$3$年、面值为$100$的零息债券，其净价交易价格为$90$。连续复利无风险利率为恒定的年利率$r=0.02$。假设回收率为恒定的$R=0.40$（市价部分回收），且违约强度为常数。在风险中性测度下的简约式模型中，假设为市价部分回收，因此违约损失与违约前市值成正比。同一家公司的$3$年期信用违约互换（CDS）报价为每年$200$个基点的平价利差，持续支付直至违约或到期，并在违约时支付每单位名义本金$(1-R)$的保护金。\n\n仅使用这些假设和输入：\n- 推断由债券价格隐含的恒定违约强度以及在$[0,T]$上的相应风险中性违约概率；\n- 推断由CDS利差隐含的恒定违约强度以及在$[0,T]$上的相应风险中性违约概率；\n- 将CDS-债券基差定义为观测到的CDS平价利差减去债券隐含的CDS利差（在同一模型下计算），并确定其符号和大小。\n\n哪个选项正确报告了隐含的违约强度、相应的$0$到$T$的违约概率以及CDS-债券基差？\n\nA. $\\lambda_{\\text{bond}}\\approx 0.0151$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 4.44\\%$；$\\lambda_{\\text{CDS}}\\approx 0.0333$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 9.52\\%$；基差 $\\approx +109$ bps（CDS利差超过债券隐含利差）。\n\nB. $\\lambda_{\\text{bond}}\\approx 0.0252$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 7.29\\%$；$\\lambda_{\\text{CDS}}\\approx 0.0333$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 9.52\\%$；基差 $\\approx +49$ bps（CDS利差超过债券隐含利差）。\n\nC. $\\lambda_{\\text{bond}}\\approx 0.0252$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 7.29\\%$；$\\lambda_{\\text{CDS}}\\approx 0.0120$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 3.54\\%$；基差 $\\approx -49$ bps（债券隐含利差超过CDS利差）。\n\nD. $\\lambda_{\\text{bond}}\\approx 0.0252$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 7.29\\%$；$\\lambda_{\\text{CDS}}\\approx 0.0333$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 9.52\\%$；基差 $\\approx -49$ bps（债券隐含利差超过CDS利差）。", "solution": "首先将对问题陈述的科学合理性、清晰度和完整性进行验证。\n\n### 第1步：提取已知条件\n- 工具1：零息债券\n- 债券到期日：$T = 3$ 年\n- 债券面值：$F = 100$\n- 债券净价：$P = 90$\n- 无风险利率（连续复利，恒定）：$r = 0.02$ 每年\n- 回收率（恒定，市价部分回收）：$R = 0.40$\n- 违约强度（风险率）：$\\lambda$，在风险中性测度下假定为常数。\n- 工具2：信用违约互换 (CDS)\n- CDS到期日：$T = 3$ 年\n- CDS平价利差：$S_{\\text{CDS}} = 200$ 基点 $= 0.02$ 每年，连续支付。\n- CDS保护金支付：每单位名义本金$(1-R)$，在违约时支付。\n- 任务：\n    1. 从债券价格推断恒定违约强度$\\lambda_{\\text{bond}}$及其在$[0, T]$上的相应违约概率。\n    2. 从CDS利差推断恒定违约强度$\\lambda_{\\text{CDS}}$及其在$[0, T]$上的相应违约概率。\n    3. 确定CDS-债券基差，定义为观测到的CDS利差减去债券隐含的CDS利差。\n\n### 第2步：使用提取的已知条件进行验证\n该问题在简约式信用风险建模的标准框架内是适定的。\n- **科学依据：** 所使用的概念——违约强度（风险率）、风险中性定价、零息债券、信用违约互换（CDS）以及市价回收——在数理金融和计算经济学中是基础且标准的。该模型是信用风险的一个简化但范式的表示。\n- **良态性：** 问题提供了足够的信息来唯一确定所关注的量（$\\lambda_{\\text{bond}}$、$\\lambda_{\\text{CDS}}$和基差）。使用恒定的强度和利率可以得到闭式解。\n- **客观性：** 问题以精确、定量的语言陈述。术语“市价部分回收”在此背景下具有特定、无歧义的含义，这使其区别于其他回收约定，如面值回收。\n\n### 第3步：结论与行动\n问题陈述有效。可以根据所提供的信息和既定的金融建模原则推导出严谨的解。\n\n### 求解推导\n\n分析按照问题陈述的要求分三部分进行。所有计算都在风险中性概率测度$\\mathbb{Q}$下进行。违约时间记为$\\tau$。给定恒定的违约强度$\\lambda$，生存概率为$\\mathbb{Q}(\\tau > t) = e^{-\\lambda t}$。\n\n**第1部分：由债券价格隐含的违约强度**\n\n债券面临违约风险。问题指定了一个“市价部分回收”模型。设$V(t)$为债券在时刻$t$的违约前无套利价格。在一个小的时间间隔$dt$内，债券持有人必须得到无风险利率$r$的补偿。考虑到时间增值和违约可能性，债券价值的期望变化必须等于无风险回报。价值变化有两个组成部分：一个确定性漂移$\\frac{dV}{dt}dt$和一个在违约情况下的跳跃部分，违约以概率$\\lambda dt$发生。跳跃的幅度是从$V(t)$到回收价值$RV(t)$，损失为$(1-R)V(t)$。\n无套利条件是：\n$$ \\frac{dV}{dt}dt - \\lambda (1-R) V(t) dt = r V(t) dt $$\n这导出了以下常微分方程：\n$$ \\frac{dV}{dt} = (r + \\lambda(1-R))V(t) $$\n该方程在终端条件$V(T) = F$（其中$F$为面值）下求解。从一个通用时间$t$积分到到期日$T$得出：\n$$ V(t) = F e^{-(r + \\lambda(1-R))(T-t)} $$\n在时间$t=0$时，价格为$P = V(0) = 90$。我们现在可以解出债券隐含的违约强度$\\lambda_{\\text{bond}}$。\n$$ 90 = 100 e^{-(0.02 + \\lambda_{\\text{bond}}(1-0.40)) \\times 3} $$\n$$ 0.9 = e^{-(0.02 + 0.6 \\lambda_{\\text{bond}}) \\times 3} $$\n对两边取自然对数：\n$$ \\ln(0.9) = -3(0.02 + 0.6 \\lambda_{\\text{bond}}) $$\n$$ -\\frac{\\ln(0.9)}{3} = 0.02 + 0.6 \\lambda_{\\text{bond}} $$\n求解$\\lambda_{\\text{bond}}$：\n$$ \\lambda_{\\text{bond}} = \\frac{1}{0.6} \\left( -\\frac{\\ln(0.9)}{3} - 0.02 \\right) $$\n使用值$\\ln(0.9) \\approx -0.10536$：\n$$ \\lambda_{\\text{bond}} \\approx \\frac{1}{0.6} \\left( \\frac{0.10536}{3} - 0.02 \\right) = \\frac{1}{0.6} (0.03512 - 0.02) = \\frac{0.01512}{0.6} = 0.0252 $$\n债券存续期$[0, T]$内的风险中性违约概率为：\n$$ \\mathbb{Q}(\\tau \\le T) = 1 - e^{-\\lambda_{\\text{bond}}T} = 1 - e^{-0.0252 \\times 3} = 1 - e^{-0.0756} $$\n$$ \\mathbb{Q}(\\tau \\le 3) \\approx 1 - 0.92718 = 0.07282 \\implies 7.28\\% $$\n这与选项中四舍五入后给出的值$7.29\\%$一致。\n\n**第2部分：由CDS利差隐含的违约强度**\n\n一个具有平价利差$S_{\\text{CDS}}$的信用违约互换在初始时刻的价值为零。这意味着保费分支的现值（$PV_{\\text{premium}}$）必须等于保护分支的现值（$PV_{\\text{protection}}$）。假设名义本金为$1$。\n\n保费分支包括持续支付$S_{\\text{CDS}}$直到到期日$T$或违约时刻$\\tau$（以先到者为准）。其现值是贴现期望支付的积分：\n$$ PV_{\\text{premium}} = \\int_0^T S_{\\text{CDS}} e^{-rt} \\mathbb{Q}(\\tau > t) dt = S_{\\text{CDS}} \\int_0^T e^{-rt} e^{-\\lambda_{\\text{CDS}}t} dt $$\n$$ PV_{\\text{premium}} = S_{\\text{CDS}} \\int_0^T e^{-(r+\\lambda_{\\text{CDS}})t} dt = S_{\\text{CDS}} \\left[ \\frac{1 - e^{-(r+\\lambda_{\\text{CDS}})T}}{r+\\lambda_{\\text{CDS}}} \\right] $$\n\n保护分支是在违约时刻$\\tau$（如果$\\tau \\le T$）支付$(1-R)$。其现值是在所有可能的违约时间上对贴现期望赔付的积分：\n$$ PV_{\\text{protection}} = \\int_0^T e^{-rt} (1-R) f(t) dt $$\n其中$f(t)$是违约时间的概率密度函数，即$f(t) = \\lambda_{\\text{CDS}} e^{-\\lambda_{\\text{CDS}}t}$。\n$$ PV_{\\text{protection}} = (1-R) \\lambda_{\\text{CDS}} \\int_0^T e^{-rt} e^{-\\lambda_{\\text{CDS}}t} dt = (1-R) \\lambda_{\\text{CDS}} \\int_0^T e^{-(r+\\lambda_{\\text{CDS}})t} dt $$\n$$ PV_{\\text{protection}} = (1-R) \\lambda_{\\text{CDS}} \\left[ \\frac{1 - e^{-(r+\\lambda_{\\text{CDS}})T}}{r+\\lambda_{\\text{CDS}}} \\right] $$\n\n令现值相等（$PV_{\\text{premium}} = PV_{\\text{protection}}$）得到一个简单的关系：\n$$ S_{\\text{CDS}} = \\lambda_{\\text{CDS}}(1-R) $$\n给定$S_{\\text{CDS}} = 200$ bps $= 0.02$ 和 $R=0.40$。我们可以解出$\\lambda_{\\text{CDS}}$：\n$$ 0.02 = \\lambda_{\\text{CDS}}(1 - 0.40) \\implies 0.02 = 0.6 \\lambda_{\\text{CDS}} $$\n$$ \\lambda_{\\text{CDS}} = \\frac{0.02}{0.6} = \\frac{2}{60} = \\frac{1}{30} \\approx 0.0333... $$\n相应的风险中性违约概率是：\n$$ \\mathbb{Q}(\\tau \\le T) = 1 - e^{-\\lambda_{\\text{CDS}}T} = 1 - e^{-(1/30) \\times 3} = 1 - e^{-0.1} $$\n$$ \\mathbb{Q}(\\tau \\le 3) \\approx 1 - 0.90484 = 0.09516 \\implies 9.52\\% $$\n\n**第3部分：CDS-债券基差**\n\nCDS-债券基差定义为观测到的CDS利差减去债券隐含的CDS利差。\n债券隐含的CDS利差$S_{\\text{bond}}$是与从债券价格推导出的违约强度$\\lambda_{\\text{bond}}$相一致的理论利差。使用与CDS相同的定价公式：\n$$ S_{\\text{bond}} = \\lambda_{\\text{bond}}(1-R) $$\n代入我们求得的值：\n$$ S_{\\text{bond}} = 0.0252 \\times (1 - 0.40) = 0.0252 \\times 0.6 = 0.01512 $$\n以基点（bps）表示，这是$0.01512 \\times 10000 = 151.2$ bps。\n\n那么CDS-债券基差为：\n$$ \\text{基差} = S_{\\text{CDS}} - S_{\\text{bond}} = 200 \\text{ bps} - 151.2 \\text{ bps} = 48.8 \\text{ bps} $$\n该值为正，约$+49$ bps，表明市场CDS利差高于公司债券价格所隐含的利差。\n\n### 选项评估\n\n我们将推导出的结果与给定选项进行比较。\n我们的结果：\n- $\\lambda_{\\text{bond}} \\approx 0.0252$\n- $\\mathbb{Q}(\\text{在}[0,3]\\text{内违约}) \\text{ (由债券)} \\approx 7.29\\%$\n- $\\lambda_{\\text{CDS}} \\approx 0.0333$\n- $\\mathbb{Q}(\\text{在}[0,3]\\text{内违约}) \\text{ (由CDS)} \\approx 9.52\\%$\n- 基差 $\\approx +49$ bps\n\n- **选项A：** $\\lambda_{\\text{bond}}\\approx 0.0151$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 4.44\\%$；$\\lambda_{\\text{CDS}}\\approx 0.0333$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 9.52\\%$；基差 $\\approx +109$ bps。\n  $\\lambda_{\\text{bond}}$的值不正确。似乎将债券隐含利差（$S_{\\text{bond}} \\approx 0.0151$）与违约强度（$\\lambda_{\\text{bond}}$）混淆了。基差也计算错误。**不正确**。\n\n- **选项B：** $\\lambda_{\\text{bond}}\\approx 0.0252$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 7.29\\%$；$\\lambda_{\\text{CDS}}\\approx 0.0333$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 9.52\\%$；基差 $\\approx +49$ bps（CDS利差超过债券隐含利差）。\n  所有计算值——$\\lambda_{\\text{bond}}$、相应的违约概率、$\\lambda_{\\text{CDS}}$、其相应的违约概率以及基差——都与我们的推导相匹配。CDS利差超过债券隐含利差的定性描述也是正确的。**正确**。\n\n- **选项C：** $\\lambda_{\\text{bond}}\\approx 0.0252$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 7.29\\%$；$\\lambda_{\\text{CDS}}\\approx 0.0120$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 3.54\\%$；基差 $\\approx -49$ bps（债券隐含利差超过CDS利差）。\n  $\\lambda_{\\text{CDS}}$的值不正确。它似乎是按$S_{\\text{CDS}} \\times (1-R) = 0.02 \\times 0.6 = 0.012$计算的，这在数学上是错误的。因此，违约概率和基差也不正确。**不正确**。\n\n- **选项D：** $\\lambda_{\\text{bond}}\\approx 0.0252$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 7.29\\%$；$\\lambda_{\\text{CDS}}\\approx 0.0333$，$\\mathbb{Q}(\\text{在}[0,3]\\text{内违约})\\approx 9.52\\%$；基差 $\\approx -49$ bps（债券隐含利差超过CDS利差）。\n  强度和概率的值是正确的。然而，基差的符号是错误的。基差是$+48.8$ bps，不是负数。“债券隐含利差超过CDS利差”的描述与实际情况相反。**不正确**。", "answer": "$$\\boxed{B}$$"}]}