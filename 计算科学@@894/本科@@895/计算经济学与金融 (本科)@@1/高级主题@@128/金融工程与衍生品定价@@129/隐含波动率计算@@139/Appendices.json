{"hands_on_practices": [{"introduction": "本章节的第一个练习将引导你掌握计算隐含波动率的基础。我们将从经典的 Black-Scholes 模型出发，该模型是期权定价的基石。这个练习的核心是解决一个逆向问题：给定一个期权的市场价格，利用如牛顿-拉弗森法（Newton-Raphson method）这样的数值求解器，反推出能使模型价格与市场价格相匹配的波动率数值 [@problem_id:2400522]。这项实践将为你后续更复杂的应用奠定坚实的计算基础。", "id": "2400522", "problem": "您需要实现一个程序，根据 Black–Scholes 模型，为一组关于某个不支付股息资产的欧式期权计算隐含波动率。隐含波动率定义为：当某个唯一的非负年化标准差值代入 Black–Scholes 定价公式时，所得出的期权价格恰好等于给定的观测市场价格。令 $S$ 表示现货价格，$K$ 表示行权价格，$r$ 表示连续复利无风险利率，$T$ 表示到期时间（以年为单位），$\\sigma$ 表示年化波动率（以小数形式表示），$\\Phi(\\cdot)$ 表示标准正态分布的累积分布函数（CDF），$\\phi(\\cdot)$ 表示其概率密度函数（PDF）。对于一个欧式看涨期权，\n$$\nC(S,K,r,T,\\sigma) \\;=\\; S\\,\\Phi(d_1) \\;-\\; K\\,e^{-rT}\\,\\Phi(d_2),\n$$\n对于一个欧式看跌期权，\n$$\nP(S,K,r,T,\\sigma) \\;=\\; K\\,e^{-rT}\\,\\Phi(-d_2) \\;-\\; S\\,\\Phi(-d_1),\n$$\n其中\n$$\nd_1 \\;=\\; \\frac{\\ln(S/K) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}, \n\\qquad\nd_2 \\;=\\; d_1 - \\sigma\\sqrt{T}.\n$$\n对于给定的观测期权价格 $p_{\\text{obs}}$，其隐含波动率是使得相应的 Black–Scholes 价格等于 $p_{\\text{obs}}$ 的值 $\\sigma^\\star \\ge 0$。如果 $p_{\\text{obs}}$ 位于无套利下界（即，对于看涨期权，$p_{\\text{obs}} = \\max\\{0, S - K e^{-rT}\\}$；对于看跌期权，$p_{\\text{obs}} = \\max\\{0, K e^{-rT} - S\\}$），则隐含波动率必须为 $0$。所有输出必须以年化波动率单位表示（小数形式，非百分比）。\n\n您的程序必须为以下每个测试用例计算隐含波动率，期权类型为看涨（$\\text{C}$）或看跌（$\\text{P}$），所有时间 $T$ 均以年为单位衡量：\n\n- 测试用例 $1$：类型 $\\text{C}$，$S=100.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $68.268949213709$。\n- 测试用例 $2$：类型 $\\text{C}$，$S=60.653065971263$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $14.461007592486$。\n- 测试用例 $3$：类型 $\\text{P}$，$S=60.653065971263$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $53.807941621223$。\n- 测试用例 $4$：类型 $\\text{C}$，$S=120.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $20.0$。\n- 测试用例 $5$：类型 $\\text{P}$，$S=80.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $20.0$。\n- 测试用例 $6$：类型 $\\text{C}$，$S=100.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $7.965567455406$。\n\n您的程序必须生成单行输出，其中按顺序包含所有测试用例的隐含波动率，并精确到小数点后六位。输出格式必须是单行上的一个列表，形式为方括号内以逗号分隔的列表，不含多余的空格。例如，输出格式必须类似于“[v1,v2,v3,v4,v5,v6]”，其中每个 $v_i$ 是一个四舍五入到六位小数的浮点数。\n\n程序必须是自包含的，且不得读取任何输入。最终答案必须是小数形式的浮点数（而非百分比）。请确保数值稳定性，并正确处理位于无套利下界上的情况。以上数据均有科学依据，每个案例都存在一个与 Black–Scholes 模型和无套利边界相符的唯一非负隐含波动率。这组案例覆盖了一般情况、深度实值（ITM）和深度虚值（OTM）状态以及边界条件。最终输出必须按规定将六个结果汇总于单行。", "solution": "该问题要求为一组欧式期权计算隐含波动率 $\\sigma^\\star$，已知它们的观测市场价格 $p_{\\text{obs}}$。这是量化金融中的一个经典反向问题。隐含波动率被定义为波动率参数 $\\sigma$ 的一个值，该值使得期权的理论 Black-Scholes 价格等于其观测价格。\n\n任务的核心是求解方程 $f(\\sigma) = 0$ 以得到 $\\sigma \\ge 0$，其中 $f(\\sigma)$ 是 Black-Scholes 价格与观测价格之差：\n$$\nf(\\sigma) = \\text{BS}(S, K, r, T, \\sigma) - p_{\\text{obs}} = 0\n$$\n在此，$\\text{BS}(S, K, r, T, \\sigma)$ 是期权（看涨期权 $C$ 或看跌期权 $P$）的价格，由问题描述中给出的 Black-Scholes 公式计算。\n\n对于任何大于零的到期时间 $T > 0$，Black-Scholes 定价函数 $\\text{BS}(\\sigma)$ 是关于波动率 $\\sigma$ 的一个严格单调递增的连续函数。这种单调性保证了如果 $\\sigma^\\star$ 的解存在，那么它就是唯一的。此特性使得该问题非常适合使用数值求根算法来解决。我们将采用牛顿-拉夫逊方法，该方法在函数导数可用且性质良好时以其快速收敛而闻名。\n\n牛顿-拉夫逊方法是一种迭代方案，用于寻找实值函数根的逐次更优近似值。其迭代公式为：\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{f(\\sigma_k)}{f'(\\sigma_k)}\n$$\n在我们的情景中，$f(\\sigma) = \\text{BS}(\\sigma) - p_{\\text{obs}}$，其关于 $\\sigma$ 的导数为：\n$$\nf'(\\sigma) = \\frac{\\partial}{\\partial \\sigma} \\left[ \\text{BS}(\\sigma) - p_{\\text{obs}} \\right] = \\frac{\\partial \\text{BS}(\\sigma)}{\\partial \\sigma}\n$$\n这个导数是期权定价中一个非常重要的量，称为 Vega，记作 $\\mathcal{V}$。对于看涨和看跌期权，Vega 的计算公式均为：\n$$\n\\mathcal{V} = S \\phi(d_1) \\sqrt{T}\n$$\n其中 $\\phi(\\cdot)$ 是标准正态分布的概率密度函数（PDF），$d_1$ 的定义与问题描述中相同。由于对所有实数 $x$，$\\phi(x) > 0$，且 $S, T > 0$，所以 Vega 恒为正。这证实了定价函数的单调性。\n\n因此，隐含波动率的迭代公式变为：\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{\\text{BS}(\\sigma_k) - p_{\\text{obs}}}{\\mathcal{V}(\\sigma_k)}\n$$\n\n总体算法设计如下：\n首先，我们处理一个关键的边界条件。问题指出，如果观测价格 $p_{\\text{obs}}$ 等于期权的无套利下界（其内在价值），则隐含波动率为 $0$。看涨期权的内在价值为 $\\max\\{0, S - K e^{-rT}\\}$，看跌期权的内在价值为 $\\max\\{0, K e^{-rT} - S\\}$。我们的实现将首先检查 $p_{\\text{obs}}$ 是否在很小的数值容差内与此值匹配。如果匹配，我们将立即返回 $\\sigma^\\star = 0$，而不进行迭代。\n\n如果价格高于内在价值，我们则启动牛顿-拉夫逊求解器。\n1.  选择一个初始猜测值 $\\sigma_0$。对于广泛的期权参数，$\\sigma_0 = 0.5$ 是一个合理且稳健的起点。\n2.  算法进行迭代，使用上述公式从 $\\sigma_k$ 计算 $\\sigma_{k+1}$。\n3.  迭代持续进行，直到在 $\\sigma_k$ 处计算出的 Black-Scholes 价格与观测价格 $p_{\\text{obs}}$ 之间的绝对差值小于预定义的容差（例如 $10^{-12}$）。\n4.  为确保算法能够终止，设置了最大迭代次数（例如 $100$ 次）。对于所提供的性质良好的测试用例，预计收敛会非常迅速。\n\n该实现包含三个主要的 Python 函数：\n-   一个用于计算看涨或看跌期权 Black-Scholes 价格的函数，使用 `scipy.stats.norm.cdf` 来表示标准正态累积分布函数 $\\Phi(\\cdot)$。\n-   一个用于计算 Vega $\\mathcal{V}$ 的函数，使用 `scipy.stats.norm.pdf` 来表示标准正态概率密度函数 $\\phi(\\cdot)$。\n-   一个主函数，用于协调整个过程：它检查边界条件，并在必要时执行牛顿-拉夫逊迭代来寻找隐含波动率。\n\n最后，将此过程应用于问题中定义的六个测试用例中的每一个。收集得到的隐含波动率，将其格式化为六位小数，并以指定的列表格式打印到标准输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes implied volatility for a set of European options using the Black-Scholes model\n    and the Newton-Raphson method.\n    \"\"\"\n\n    def black_scholes_price(S, K, r, T, sigma, option_type):\n        \"\"\"\n        Calculates the Black-Scholes price for a European option.\n        \"\"\"\n        # For non-positive sigma, price is intrinsic value.\n        if sigma <= 0.0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K * np.exp(-r * T))\n            else:  # 'P'\n                return np.maximum(0.0, K * np.exp(-r * T) - S)\n\n        # To prevent division by zero for T=0\n        if T == 0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K)\n            else: # 'P'\n                return np.maximum(0.0, K - S)\n\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n\n        if option_type == 'C':\n            price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        elif option_type == 'P':\n            price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n        else:\n            raise ValueError(\"Invalid option type. Must be 'C' or 'P'.\")\n        return price\n\n    def vega(S, K, r, T, sigma):\n        \"\"\"\n        Calculates the Vega of a European option.\n        \"\"\"\n        if sigma <= 0.0 or T <= 0.0:\n            return 0.0\n        \n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        return S * norm.pdf(d1) * np.sqrt(T)\n\n    def implied_volatility(S, K, r, T, p_obs, option_type):\n        \"\"\"\n        Calculates the implied volatility using the Newton-Raphson method.\n        \"\"\"\n        # Check if price is at the no-arbitrage lower bound (intrinsic value)\n        if option_type == 'C':\n            intrinsic_value = np.maximum(0.0, S - K * np.exp(-r * T))\n        else:  # 'P'\n            intrinsic_value = np.maximum(0.0, K * np.exp(-r * T) - S)\n        \n        # Using a small tolerance for floating point comparison\n        if np.isclose(p_obs, intrinsic_value):\n            return 0.0\n\n        # Newton-Raphson settings\n        sigma = 0.5  # Initial guess\n        max_iter = 100\n        tolerance = 1e-12\n\n        for _ in range(max_iter):\n            price = black_scholes_price(S, K, r, T, sigma, option_type)\n            v = vega(S, K, r, T, sigma)\n            \n            diff = price - p_obs\n\n            if abs(diff) < tolerance:\n                return sigma\n            \n            if v < 1e-13:\n                # Vega is too small, Newton-Raphson is unstable.\n                # This should not happen for the given test cases.\n                # A more robust solver would switch to bisection here.\n                break\n\n            sigma = sigma - diff / v\n        \n        # Return the last calculated sigma if max iterations are reached\n        return sigma\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (option_type, S, K, r, T, p_obs)\n        ('C', 100.0, 100.0, 0.0, 1.0, 68.268949213709),\n        ('C', 60.653065971263, 100.0, 0.0, 1.0, 14.461007592486),\n        ('P', 60.653065971263, 100.0, 0.0, 1.0, 53.807941621223),\n        ('C', 120.0, 100.0, 0.0, 1.0, 20.0),\n        ('P', 80.0, 100.0, 0.0, 1.0, 20.0),\n        ('C', 100.0, 100.0, 0.0, 1.0, 7.965567455406),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        option_type, S, K, r, T, p_obs = case\n        result = implied_volatility(S, K, r, T, p_obs, option_type)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "在现实世界中，许多期权是美式期权，允许持有者在到期前的任何时间行权，这使得 Black-Scholes 公式不再适用。这项练习将带你进入更广阔的数值定价领域，你将亲手构建一个二叉树模型来为美式期权定价。然后，你将把这个数值定价器作为核心，结合根查找算法来计算隐含波动率 [@problem_id:2400466]，从而深刻理解隐含波动率概念的普适性——它不依赖于任何特定的定价公式，而是定价模型本身的逆运算。", "id": "2400466", "problem": "要求您编写一个完整、可运行的程序，该程序使用重组二叉树模型和考虑提前行权的风险中性定价法，计算支付连续股息的股票的美式期权的隐含波动率。程序必须构建一个美式期权的定价函数，该函数应考虑连续股息率，然后求解使模型价格与给定观测价格相匹配的唯一波动率。为了进行测试，每个观测价格都将通过以下方式合成生成：首先在相同的二叉树设定下，使用一个已知的波动率对同一期权进行定价。\n\n所有参数均已年化，并在适用情况下为连续形式。在风险中性测度下，标的资产在固定数量的时间步长内遵循乘性二叉过程。该股票支付连续股息率。在每个节点，美式期权的价值等于其立即行权价值与风险中性概率下的折现预期持有价值中的较大者。隐含波动率定义为非负实数，当将其作为波动率代入同一二叉模型时，计算出的美式期权价格等于观测价格。\n\n单位和约定：\n- 无风险利率 $r$ 和股息率 $q$ 是以小数形式给出的连续复利年利率。\n- 到期时间 $T$ 以年为单位。\n- 标的资产价格 $S_0$ 和行权价 $K$ 使用任意货币单位；波动率以小数形式报告。\n- 不涉及角度。\n- 所有利率和波动率必须按小数处理，而不是百分比。\n\n测试套件：\n对于每个测试用例，首先使用给定的波动率 $\\,\\sigma^\\star\\,$ 和指定的二叉树步数 $\\,N\\,$ 对美式期权进行定价，从而计算出观测期权价格 $V^{obs}$。然后，仅使用 $V^{obs}$（而非 $\\,\\sigma^\\star\\,$），求解出能在同一模型中重现 $V^{obs}$ 的隐含波动率 $\\,\\hat{\\sigma}\\,$。您的程序应返回每个用例的 $\\,\\hat{\\sigma}\\,$，并四舍五入至六位小数。\n\n- 案例A（普通平价美式看跌期权）：$S_0 = 100$，$K = 100$，$r = 0.05$，$q = 0.02$，$T = 1.0$，$N = 300$，期权类型 put，正向定价波动率 $\\,\\sigma^\\star = 0.20$。\n- 案例B（带股息率的美式看涨期权，可能提前行权）：$S_0 = 120$，$K = 100$，$r = 0.01$，$q = 0.06$，$T = 0.5$，$N = 300$，期权类型 call，正向定价波动率 $\\,\\sigma^\\star = 0.25$。\n- 案例C（短期限）：$S_0 = 100$，$K = 95$，$r = 0.03$，$q = 0.00$，$T = \\tfrac{7}{365}$，$N = 120$，期权类型 call，正向定价波动率 $\\,\\sigma^\\star = 0.15$。\n- 案例D（深度价外美式看跌期权，较长期限）：$S_0 = 150$，$K = 100$，$r = 0.03$，$q = 0.02$，$T = 2.0$，$N = 400$，期权类型 put，正向定价波动率 $\\,\\sigma^\\star = 0.35$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序排列的案例A–D的四个隐含波动率，四舍五入至六位小数，并以逗号分隔，用方括号括起来。例如，格式必须是\n\"[vA,vB,vC,vD]\"\n不含多余空格或字符，其中 $vA$、$vB$、$vC$ 和 $vD$ 均为四舍五入至六位小数的小数形式浮点数。", "solution": "在尝试任何解决方案之前，首先对所提出的问题陈述进行严格验证。\n\n步骤1：提取已知条件\n- **模型类型**：用于美式期权的重组二叉树模型。\n- **标的资产**：支付连续股息率的股票。\n- **估值方法**：考虑提前行权的风险中性定价法。\n- **股价过程**：乘性二叉过程，$S_{t+\\Delta t} = S_t \\cdot u$ 或 $S_{t+\\Delta t} = S_t \\cdot d$。\n- **期权价值规则**：在任何节点，期权价值是其立即行权价值与风险中性概率下的折现预期持有价值中的最大值。\n- **隐含波动率 ($\\hat{\\sigma}$)**：波动率 $\\sigma$ 的唯一非负实数，使得模型价格等于观测市场价格 $V^{obs}$。\n- **观测价格的生成**：每个 $V^{obs}$ 都是通过使用一个已知的波动率（记为 $\\sigma^\\star$）对期权进行定价来合成生成的。\n- **模型参数**：\n    - $S_0$：初始股价。\n    - $K$：行权价。\n    - $r$：无风险利率（连续、年化）。\n    - $q$：股息率（连续、年化）。\n    - $T$：到期时间（年）。\n    - $N$：二叉树的时间步数。\n    - `option_type`：'call' 或 'put'。\n- **测试用例**：\n    - **A**：$S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.02$, $T = 1.0$, $N = 300$, type = put, $\\sigma^\\star = 0.20$。\n    - **B**：$S_0 = 120$, $K = 100$, $r = 0.01$, $q = 0.06$, $T = 0.5$, $N = 300$, type = call, $\\sigma^\\star = 0.25$。\n    - **C**：$S_0 = 100$, $K = 95$, $r = 0.03$, $q = 0.00$, $T = \\frac{7}{365}$, $N = 120$, type = call, $\\sigma^\\star = 0.15$。\n    - **D**：$S_0 = 150$, $K = 100$, $r = 0.03$, $q = 0.02$, $T = 2.0$, $N = 400$, type = put, $\\sigma^\\star = 0.35$。\n- **输出要求**：一个包含四个对应于测试用例的隐含波动率 $\\hat{\\sigma}$ 的列表，四舍五入至六位小数。\n\n步骤2：验证\n- **科学依据**：该问题基于 Cox-Ross-Rubinstein (CRR) 二叉期权定价模型，这是计算金融学的基石。风险中性定价、处理美式期权提前行权的方法以及隐含波动率的概念都是标准且完善的原则。该模型在科学上是合理的。\n- **适定性**：该问题要求解方程 $V_{model}(\\sigma) - V^{obs} = 0$ 的根。对于标准期权，期权价格 $V_{model}(\\sigma)$ 是波动率 $\\sigma$ 的单调递增函数（即 vega 为正）。这确保了对于任何有效的观测价格 $V^{obs}$，都存在唯一的解 $\\sigma$。问题的结构（即 $V^{obs}$ 是通过使用相同模型和一个已知的 $\\sigma^\\star$ 生成的）保证了存在一个解 $\\hat{\\sigma} = \\sigma^\\star$，因此该问题是适定的。\n- **客观性**：所有参数和定义都是定量和精确的。问题不含主观性语言或推测性陈述。\n- **完整性**：每个测试用例都提供了所有必要的参数（$S_0, K, r, q, T, N, \\text{type}$），使得问题是自包含的。\n- **一致性**：问题陈述不含内部矛盾。\n\n步骤3：结论\n该问题被判定为**有效**。它具有科学依据、适定、客观、完整且一致。它代表了量化金融中的一个标准计算任务。我现在将着手进行解决方案的推导和实现。\n\n解决方案是一个两阶段过程。首先，基于指定的二叉模型构建一个美式期权定价器。其次，使用数值求根算法来求解隐含波动率。\n\n**第1部分：美式期权定价的二叉模型**\n\n二叉模型将时间离散化为 $N$ 个步长，每个步长持续时间为 $\\Delta t = T/N$。在每个节点，股价以一个因子 $u$ 上涨或以一个因子 $d$ 下跌。我们使用标准的 Cox-Ross-Rubinstein (CRR) 公式来计算这些因子，它们取决于波动率 $\\sigma$。\n\n1.  **模型参数**：\n    单个时间步长的长度是 $\\Delta t = T/N$。\n    上涨因子是 $u = e^{\\sigma \\sqrt{\\Delta t}}$。\n    下跌因子是 $d = e^{-\\sigma \\sqrt{\\Delta t}} = 1/u$。\n\n2.  **风险中性概率**：\n    为了使折现后的股价过程在风险中性测度下成为一个鞅，考虑到连续股息率 $q$，在 $t+\\Delta t$ 时刻的预期股价（以无风险利率 $r$ 折现）必须等于 $t$ 时刻的股价（在扣除 $\\Delta t$ 时间段内支付股息所造成的价值损失后）。这给出了以下关系：\n    $$S_t e^{-q \\Delta t} = e^{-r \\Delta t} [p (S_t u) + (1-p) (S_t d)]$$\n    求解上涨的风险中性概率 $p$ 可得：\n    $$p = \\frac{e^{(r-q)\\Delta t} - d}{u - d}$$\n    下跌的概率则是 $1-p$。必须满足条件 $0 < p < 1$，这要求 $d < e^{(r-q)\\Delta t} < u$。对于典型的参数值和非零波动率，此条件是满足的。\n\n3.  **回溯归纳算法**：\n    美式期权的价值是通过从到期日向后倒推来确定的。\n    - **在到期日（时间 $T$，第 $N$ 步）**：期权价值等于其内在价值。构建一个到期日的股价树。对于 $j$ 次上涨和 $N-j$ 次下跌（其中 $j \\in \\{0, 1, \\dots, N\\}$），股价为 $S_{N,j} = S_0 u^j d^{N-j}$。期权价值为：\n    $$V_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{对于看涨期权}$$\n    $$V_{N,j} = \\max(K - S_{N,j}, 0) \\quad \\text{对于看跌期权}$$\n\n    - **在中间步骤（时间 $i \\Delta t$，第 $i$ 步，$i < N$）**：在任何节点 $(i, j)$，期权价值是其提前行权价值与折现预期持有价值中的最大值。\n    持有价值是在第 $i+1$ 步期权价值的期望值，折现一个周期：\n    $$C_{i,j} = e^{-r \\Delta t} [p V_{i+1, j+1} + (1-p) V_{i+1, j}]$$\n    在节点 $(i,j)$ 的提前行权价值，此处的股价为 $S_{i,j} = S_0 u^j d^{i-j}$，其值为：\n    $$E_{i,j} = \\max(S_{i,j} - K, 0) \\quad \\text{对于看涨期权}$$\n    $$E_{i,j} = \\max(K - S_{i,j}, 0) \\quad \\text{对于看跌期权}$$\n    因此，美式期权的价值为：\n    $$V_{i,j} = \\max(E_{i,j}, C_{i,j})$$\n    这个回溯迭代过程一直进行到第 $i=0$ 步。在时间 $t=0$ 的期权价格即为单个节点的值 $V_{0,0}$。这整个过程构成了定价函数，我们将其表示为 $V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type})$。\n\n**第2部分：隐含波动率计算**\n\n隐含波动率 $\\hat{\\sigma}$ 是使模型价格等于观测市场价格 $V^{obs}$ 的波动率 $\\sigma$ 的值。我们必须求解以下关于 $\\sigma$ 的方程：\n$$f(\\sigma) = V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type}) - V^{obs} = 0$$\n\n由于 $V_{\\text{model}}$ 没有简单的闭式解，我们必须使用数值求根方法。Brent方法是一个稳健且高效的选择。它需要一个区间 $[a, b]$，使得 $f(a)$ 和 $f(b)$ 异号。\n\n1.  **目标函数**：需要找到其根的目标函数是 `objective_func(sigma) = american_option_pricer(...) - V_obs`。\n2.  **生成观测价格**：对每个测试用例，我们首先用给定的正向定价波动率 $\\sigma^\\star$ 调用我们的定价函数来计算 $V^{obs}$。\n3.  **求根**：然后我们使用 Brent 方法（在 `scipy.optimize.brentq` 中可用）来找到 `objective_func` 的根。\n    - 需要为波动率设定一个合适的搜索区间。下界可以是一个很小的正数，例如 $10^{-6}$，因为波动率不能为负。$5.0$（代表 $500\\%$ 的波动率）的上限非常保守，对于任何实际的期权价格都足以框定解。\n    - 由于期权价格是波动率的单调递增函数，并且我们知道在 $\\sigma = \\sigma^\\star$ 处存在一个解，因此找到一个框定区间是直接了当的。\n\n最终的程序将封装这两个部分。对于每个测试用例，它将首先计算 $V^{obs}$，然后求解 $\\hat{\\sigma}$。问题的设定保证了结果 $\\hat{\\sigma}$ 在求解器的容差范围内将等于 $\\sigma^\\star$。最终结果按规定进行四舍五入。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef american_option_pricer(S0, K, r, q, T, N, sigma, option_type):\n    \"\"\"\n    Prices an American option using a recombining binomial tree model.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (annual, continuous).\n        q (float): Dividend yield (annual, continuous).\n        T (float): Time to maturity (years).\n        N (int): Number of time steps in the binomial tree.\n        sigma (float): Volatility of the underlying stock.\n        option_type (str): Type of option, 'call' or 'put'.\n\n    Returns:\n        float: The price of the American option.\n    \"\"\"\n    # 1. Parameter setup for the binomial model\n    # Ensure sigma is not too close to zero to avoid division issues.\n    if sigma < 1e-9:\n        sigma = 1e-9\n\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n\n    # Check for arbitrage condition and calculate risk-neutral probability\n    a = np.exp((r - q) * dt)\n    if not (d < a < u):\n        # Fallback or handle arbitrage condition violation\n        # For this problem's context, this is unlikely.\n        # This can be triggered if r-q is very large or sigma very small.\n        # If it happens, we can approximate p to be very close to 1 or 0.\n        if a >= u:\n            p = 1.0 \n        else: # a <= d\n            p = 0.0\n    else:\n        p = (a - d) / (u - d)\n\n    # 2. Initialize option values at maturity (time T)\n    # The prices are stored in a 1D array representing nodes at a given time step.\n    V = np.zeros(N + 1)\n    \n    # Stock prices at maturity\n    S_T = S0 * (d ** np.arange(N, -1, -1)) * (u ** np.arange(0, N + 1, 1))\n\n    if option_type == 'call':\n        V[:] = np.maximum(S_T - K, 0)\n        payoff_sign = 1\n    else:  # put\n        V[:] = np.maximum(K - S_T, 0)\n        payoff_sign = -1\n\n    # 3. Backward induction through the tree\n    for i in range(N - 1, -1, -1):\n        # Calculate continuation value at step i (vector of size i+1)\n        # V is of size i+2 from the previous step i+1.\n        # We use V's relevant subarray [0:i+2]\n        continuation_value = np.exp(-r * dt) * (p * V[1:i + 2] + (1 - p) * V[0:i + 1])\n\n        # Calculate stock prices at step i\n        S_i = S0 * (d ** np.arange(i, -1, -1)) * (u ** np.arange(0, i + 1, 1))\n\n        # Calculate early exercise value\n        exercise_value = np.maximum((S_i - K) * payoff_sign, 0)\n\n        # Update option values at step i\n        V[0:i + 1] = np.maximum(continuation_value, exercise_value)\n\n    return V[0]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute implied volatilities.\n    \"\"\"\n    test_cases = [\n        # (S0, K, r, q, T, N, option_type, sigma_star)\n        (100.0, 100.0, 0.05, 0.02, 1.0, 300, 'put', 0.20),  # Case A\n        (120.0, 100.0, 0.01, 0.06, 0.5, 300, 'call', 0.25), # Case B\n        (100.0, 95.0, 0.03, 0.00, 7.0/365.0, 120, 'call', 0.15), # Case C\n        (150.0, 100.0, 0.03, 0.02, 2.0, 400, 'put', 0.35), # Case D\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        S0, K, r, q, T, N, option_type, sigma_star = case\n\n        # 1. Generate the \"observed\" option price using the known volatility\n        observed_price = american_option_pricer(S0, K, r, q, T, N, sigma_star, option_type)\n\n        # 2. Define the objective function for the root-finder\n        # The function calculates the difference between model price and observed price.\n        def objective_func(sigma):\n            return american_option_pricer(S0, K, r, q, T, N, sigma, option_type) - observed_price\n\n        # 3. Find the implied volatility using Brent's method\n        # A search bracket from 0.0001 (0.01%) to 5.0 (500%) is very safe.\n        try:\n            implied_vol = brentq(objective_func, a=1e-6, b=5.0, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # This would happen if f(a) and f(b) don't have opposite signs.\n            # Given the problem's synthetic nature, this is not expected.\n            implied_vol = np.nan\n\n        results.append(round(implied_vol, 6))\n\n    # Final output format: \"[vA,vB,vC,vD]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "Black-Scholes 模型的一个核心假设是波动率恒定，但这与市场上观察到的“波动率微笑”现象相悖。为了更好地捕捉市场动态，我们需要更高级的模型。这个最终练习将你引向现代量化金融的前沿，通过实现业界广泛应用的 SABR 随机波动率模型来计算隐含波动率 [@problem_id:2400489]。你将使用著名的 Hagan 等人提出的解析近似公式，这不仅能让你深入理解波动率的随机特性，更能让你掌握连接理论模型与市场实践的关键技术。", "id": "2400489", "problem": "实现一个完整的程序，计算由随机Alpha Beta Rho (SABR)模型生成的欧式期权的对数正态布莱克隐含波动率。SABR动态在风险中性测度下由以下耦合的随机微分方程定义\n$$\n\\mathrm{d}F_t = \\alpha_t F_t^{\\beta}\\,\\mathrm{d}W_t^{(1)}, \\qquad \\mathrm{d}\\alpha_t = \\nu \\alpha_t\\,\\mathrm{d}W_t^{(2)}, \\qquad \\mathrm{d}\\langle W^{(1)}, W^{(2)}\\rangle_t = \\rho\\,\\mathrm{d}t,\n$$\n其中，$F_t$ 是在时间 $t$ 的远期标的资产价格，$\\alpha_t$ 是瞬时波动率，$\\beta \\in [0,1]$，$\\rho \\in (-1,1)$ 是瞬时相关系数，$\\nu \\ge 0$ 是波动率的波动率。对于一个到期时间 $T>0$，远期价格 $F>0$，执行价格 $K>0$，以及SABR参数 $(\\alpha,\\beta,\\rho,\\nu)$（其中 $\\alpha>0$），对数正态布莱克隐含波动率 $\\sigma_{\\mathrm{imp}}(F,K,T;\\alpha,\\beta,\\rho,\\nu)$ 被定义为唯一的 $\\sigma$，使得使用波动率 $\\sigma$ 的Black-Scholes（对数正态）公式计算出的价格与到期时间为 $T$ 的SABR期权价格相匹配。在短到期时间的渐近机制下，该隐含波动率由一个标准的、根据 $(F,K,T,\\alpha,\\beta,\\rho,\\nu)$ 确定的函数——一阶小时间表达式——明确定义。\n\n您的程序必须根据此短到期时间SABR隐含波动率映射，为下面测试套件中的每一组参数计算相应的对数正态布莱克隐含波动率 $\\sigma_{\\mathrm{imp}}$。所有返回的波动率必须以小数形式表示（例如，$0.2$ 表示百分之二十），并且每个结果必须四舍五入到8位小数。\n\n测试套件（每个案例是一个元组 $(F,K,T,\\alpha,\\beta,\\rho,\\nu)$，所有量均为无量纲，且 $T$ 以年为单位计量）：\n- 案例1：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,1.1,\\,1.0,\\,0.3,\\,0.7,\\,-0.3,\\,0.5)$\n- 案例2（平价期权）：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,1.0,\\,2.0,\\,0.25,\\,1.0,\\,0.0,\\,0.4)$\n- 案例3（极短到期时间）：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,0.9,\\,0.0001,\\,0.2,\\,0.5,\\,0.5,\\,1.2)$\n- 案例4（高正相关性）：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (2.0,\\,1.0,\\,3.0,\\,0.15,\\,0.9,\\,0.99,\\,0.8)$\n- 案例5（高负相关性，低$\\beta$值）：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (0.5,\\,0.8,\\,0.5,\\,0.4,\\,0.3,\\,-0.99,\\,1.0)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。请按顺序报告与案例1到案例5相对应的5个隐含波动率，每个都四舍五入到8位小数。例如，\n\"[v1,v2,v3,v4,v5]\"\n其中每个 $v_i$ 是一个精确格式化为8位小数的浮点数。", "solution": "所提出的问题要求计算在随机Alpha Beta Rho (SABR)模型下定价的欧式期权的对数正态布莱克隐含波动率。计算必须使用由Hagan, Kumar, Lesniewski和Woodward开发的标准一阶小时间渐近公式。\n\n首先，确立问题的有效性。该问题在科学上植根于量化金融中既有的随机波动率模型理论。它是一个适定、客观的问题，并为获得唯一解提供了所有必要的参数和条件。对“标准一阶小时间表达式”的引用明确指向了被广泛使用的Hagan等人提出的公式。所有提供的测试案例均遵守SABR模型定义的参数约束，即 $F>0$, $K>0$, $T>0$, $\\alpha>0$, $\\beta \\in [0,1]$, $\\rho \\in (-1,1)$ 以及 $\\nu \\ge 0$。因此，该问题被认为是有效的，可以构建一个严谨的解决方案。\n\n解决方案的核心是实现用于计算Black-Scholes隐含波动率 $\\sigma_{\\mathrm{imp}}$ 的Hagan渐近公式。该公式为SABR模型的价格到波动率的映射提供了一个精确的近似，尤其适用于短到期时间的情况。\n\n对于给定的远期价格 $F$、执行价格 $K$、到期时间 $T$、初始波动率 $\\alpha$ 以及SABR参数 $\\beta, \\rho, \\nu$，隐含波动率 $\\sigma_{\\mathrm{imp}}$ 的通用公式如下：\n$$ \\sigma_{\\mathrm{imp}}(F,K) \\approx \\frac{\\alpha}{\\left(FK\\right)^{\\frac{1-\\beta}{2}} \\left[1 + \\frac{(1-\\beta)^2}{24}\\log^2\\left(\\frac{F}{K}\\right) + \\frac{(1-\\beta)^4}{1920}\\log^4\\left(\\frac{F}{K}\\right)\\right]} \\times \\left(\\frac{z}{\\chi(z)}\\right) \\times \\left[1 + \\left(\\frac{(1-\\beta)^2\\alpha^2}{24(FK)^{1-\\beta}} + \\frac{\\rho\\beta\\nu\\alpha}{4(FK)^{\\frac{1-\\beta}{2}}} + \\frac{2-3\\rho^2}{24}\\nu^2\\right)T\\right] $$\n该表达式由三个主要部分组成：\n$1$. 一个主干项，它依赖于价内性（moneyness） $\\log(F/K)$ 和参数 $\\beta$。为求完整，我们包含了对 $\\log(F/K)$ 直到四阶的展开，这是提高偏离平价时期权（away from the money）计算精度的标准做法。\n$2$. 一个项 $\\frac{z}{\\chi(z)}$，它用于校正由 $\\nu$ 及其与远期过程的相关性 $\\rho$ 驱动的波动率过程的随机性。辅助变量 $z$ 和 $\\chi(z)$ 定义如下：\n$$ z = \\frac{\\nu}{\\alpha}(FK)^{\\frac{1-\\beta}{2}} \\log\\left(\\frac{F}{K}\\right) $$\n$$ \\chi(z) = \\log\\left(\\frac{\\sqrt{1-2\\rho z+z^2}+z-\\rho}{1-\\rho}\\right) $$\n$3$. 一个时间依赖因子 $[1 + (\\dots)T]$，它表示对到期时间 $T$ 的一阶修正。\n\n稳健实现的一个关键方面是处理此公式中的奇点和数值不稳定性。具体来说，当期权为平价期权（at-the-money，$F=K$）时，价内性 $\\log(F/K)=0$，这意味着 $z=0$。这导致项 $z/\\chi(z)$ 出现 $0/0$ 的不定形式。为解决此问题，我们必须计算当 $K \\to F$ 时的极限。在此极限下，$\\log(F/K) \\to 0$，所有关于 $\\log(F/K)$ 的展开项都消失，且 $\\lim_{z \\to 0} \\frac{z}{\\chi(z)} = 1$。公式简化为平价（ATM）隐含波动率：\n$$ \\sigma_{\\mathrm{imp}}(F,F) = \\frac{\\alpha}{F^{1-\\beta}} \\left[1 + \\left(\\frac{(1-\\beta)^2\\alpha^2}{24F^{2(1-\\beta)}} + \\frac{\\rho\\beta\\nu\\alpha}{4F^{1-\\beta}} + \\frac{2-3\\rho^2}{24}\\nu^2\\right)T\\right] $$\n这个专门的ATM公式必须用于测试套件的案例2以及任何 $F$ 在数值上与 $K$ 无法区分的情况。\n\n算法设计如下：\n$1$. 对于每组输入参数 $(F, K, T, \\alpha, \\beta, \\rho, \\nu)$，首先计算对数价内性 $x = \\log(F/K)$。\n$2$. 如果 $|x|$ 小于一个小的数值容差（例如， $10^{-7}$），则该期权被视为平价期权。应用简化的ATM公式来计算隐含波动率。该分支正确处理了 $F=K$ 的案例2，并防止了近乎平价期权的数值错误。\n$3$. 如果期权不是平价期权，则使用完整的渐近公式。\n    a. 计算 $f = (FK)^{(1-\\beta)/2}$ 和 $z = (\\nu/\\alpha)f x$。\n    b. 计算主干项的分母，包括直到 $\\log^4(F/K)$ 的项。\n    c. 计算 $\\chi(z)$ 并随后计算比率 $z/\\chi(z)$。对于测试案例中提供的参数范围，包括接近 $\\pm 1$ 的 $\\rho$ 值，$\\chi(z)$ 的公式在数值上是稳定的。\n    d. 计算时间依赖的调整因子。\n    e. 结合所有项来计算最终的隐含波动率。\n\n这种结构化的方法确保了根据指定模型的数学正确性以及在各种输入参数范围内的数值稳健性。最终结果按要求四舍五入到8位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the lognormal Black implied volatility for European options\n    under the SABR model using the first-order small-time asymptotic formula\n    by Hagan et al. (2002).\n    \"\"\"\n\n    def sabr_implied_vol(F, K, T, alpha, beta, rho, nu):\n        \"\"\"\n        Calculates SABR implied volatility.\n\n        Args:\n            F (float): Forward price.\n            K (float): Strike price.\n            T (float): Time to maturity in years.\n            alpha (float): Initial volatility.\n            beta (float): Exponent parameter.\n            rho (float): Correlation parameter.\n            nu (float): Volatility of volatility.\n\n        Returns:\n            float: The SABR implied volatility.\n        \"\"\"\n        # For numerical stability, treat cases where F and K are very close as at-the-money.\n        # This avoids issues with log(F/K) and z being close to zero.\n        if abs(F - K) < 1e-7:\n            f_atm = F**(1 - beta)\n            term1 = (1 - beta)**2 * alpha**2 / (24 * f_atm**2)\n            term2 = rho * beta * nu * alpha / (4 * f_atm)\n            term3 = (2 - 3 * rho**2) * nu**2 / 24\n            time_adj = 1 + (term1 + term2 + term3) * T\n            return (alpha / f_atm) * time_adj\n\n        log_FK = np.log(F / K)\n        f = (F * K)**((1 - beta) / 2)\n        \n        # Check for nu=0, which corresponds to the CEV model. In this case, z=0 and z/chi(z)=1.\n        if nu == 0:\n            z = 0.\n            z_over_chi = 1.\n        else:\n            z = nu / alpha * f * log_FK\n            # Use full expression for chi(z) as it's stable for given test cases.\n            sqrt_term = np.sqrt(1 - 2 * rho * z + z**2)\n            chi_z = np.log((sqrt_term + z - rho) / (1 - rho))\n            z_over_chi = z / chi_z\n\n        # Backbone term including expansion up to 4th order in log-moneyness for accuracy.\n        denom_beta_expansion = (1 +\n                                (1 - beta)**2 / 24 * log_FK**2 +\n                                (1 - beta)**4 / 1920 * log_FK**4)\n\n        # Time-dependent adjustment term (first-order in T).\n        term1 = (1 - beta)**2 * alpha**2 / (24 * f**2)\n        term2 = rho * beta * nu * alpha / (4 * f)\n        term3 = (2 - 3 * rho**2) * nu**2 / 24\n        time_adj = 1 + (term1 + term2 + term3) * T\n\n        vol = (alpha / (f * denom_beta_expansion)) * z_over_chi * time_adj\n        return vol\n\n    # Test Suite from the problem statement.\n    # Each case is a tuple (F, K, T, alpha, beta, rho, nu).\n    test_cases = [\n        (1.0, 1.1, 1.0, 0.3, 0.7, -0.3, 0.5), # Case 1\n        (1.0, 1.0, 2.0, 0.25, 1.0, 0.0, 0.4), # Case 2 (at-the-money)\n        (1.0, 0.9, 0.0001, 0.2, 0.5, 0.5, 1.2), # Case 3 (very short maturity)\n        (2.0, 1.0, 3.0, 0.15, 0.9, 0.99, 0.8), # Case 4 (high positive correlation)\n        (0.5, 0.8, 0.5, 0.4, 0.3, -0.99, 1.0), # Case 5 (high negative correlation, low beta)\n    ]\n\n    results = []\n    for case in test_cases:\n        F, K, T, alpha, beta, rho, nu = case\n        implied_vol = sabr_implied_vol(F, K, T, alpha, beta, rho, nu)\n        # Round the result to 8 decimal places.\n        results.append(f\"{implied_vol:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}