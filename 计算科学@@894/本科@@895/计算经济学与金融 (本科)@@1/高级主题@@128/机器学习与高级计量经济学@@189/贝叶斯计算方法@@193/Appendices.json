{"hands_on_practices": [{"introduction": "在金融和经济领域，理解中央银行的政策意图至关重要。本练习通过一个简化的文本分析场景，向您介绍如何使用贝叶斯方法量化情绪。您将应用基础的贝塔-二项分布模型（Beta-Binomial model），这是一个用于推断未知比例（如文本中的“鸽派”词汇比例 $p$）的基石。通过这个练习[@problem_id:2375504]，您将亲手计算后验均值、可信区间和后验概率，从而为看似主观的文本数据提供严谨的量化不确定性评估。", "id": "2375504", "problem": "您将使用一个简化的、基于模型的设置，通过被归类为“鸽派”和“鹰派”术语的相对频率来量化中央银行沟通的情绪。对于单个文档，设 $D$ 表示通过预定词典提取的“鸽派”术语计数，设 $H$ 表示“鹰派”术语的计数。设 $N$ 表示被归类术语的总数，因此 $N = D + H$。假设每个被分类的术语都是独立生成的，并且一个被分类的术语为“鸽派”的未知概率为 $p \\in (0,1)$。在给定 $N$ 的条件下，将计数 $D$ 建模为参数为 $p$ 的二项分布随机变量。为 $p$ 设置一个贝塔先验，即 $p \\sim \\text{Beta}(a,b)$，其中形状参数 $a > 0$ 且 $b > 0$。\n\n将文档的“鸽派指数”定义为上述模型下 $p$ 的后验均值。将在水平 $c \\in (0,1)$ 下的等尾可信区间（CI）定义为一个区间，其下端点和上端点分别是 $p$ 的后验分布的 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数，其中 $\\alpha = 1-c$。为支持分类，将文档在阈值 $\\tau \\in (0,1)$ 下“鸽派倾向高于鹰派”的后验概率定义为 $\\mathbb{P}(p > \\tau \\mid D,H,a,b)$。所有概率值必须表示为 $[0,1]$ 内的小数。\n\n对于下方的每个测试用例，请针对指定的参数 $(D,H,a,b,c,\\tau)$ 计算并返回以下四个量：\n- $p$ 的后验均值，\n- 水平为 $c$ 的等尾可信区间的下端点，\n- 水平为 $c$ 的等尾可信区间的上端点，\n- 后验概率 $\\mathbb{P}(p > \\tau \\mid D,H,a,b)$。\n\n测试套件（每行为一个测试用例 $(D,H,a,b,c,\\tau)$）：\n- $(D,H,a,b,c,\\tau) = (\\,30,\\,20,\\,2,\\,2,\\,0.95,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,0,\\,0,\\,1,\\,1,\\,0.9,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,50,\\,10,\\,0.5,\\,0.5,\\,0.95,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,1,\\,9,\\,5,\\,1,\\,0.9,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,100,\\,100,\\,10,\\,10,\\,0.99,\\,0.5\\,)$\n\n您的程序应产生单行输出，其中包含一个逗号分隔的列表的列表，不带空格，每个内部列表对应一个测试用例，并按 $[\\,\\text{posterior\\_mean},\\,\\text{CI\\_lower},\\,\\text{CI\\_upper},\\,\\mathbb{P}(p>\\tau)\\,]$ 的顺序排列。每个小数必须四舍五入到小数点后 $6$ 位。例如，最终输出格式必须类似于 $[[m_1,l_1,u_1,q_1],[m_2,l_2,u_2,q_2],\\dots]$，并且不含任何空格。", "solution": "问题陈述经过验证。\n\n### 第一步：提取已知信息\n\n- 文档术语计数：$D$ (鸽派)，$H$ (鹰派)。\n- 被归类的总术语数：$N = D + H$。\n- 未知参数：$p \\in (0,1)$，一个术语为“鸽派”的概率。\n- 似然模型：计数 $D$ 被建模为二项随机变量，即 $D \\mid p, N \\sim \\text{Binomial}(N, p)$。\n- 先验模型：为参数 $p$ 指定一个贝塔先验，即 $p \\sim \\text{Beta}(a,b)$，其超参数为 $a > 0$ 和 $b > 0$。\n- “鸽派指数”：定义为 $p$ 的后验均值，$E[p \\mid D, H, a, b]$。\n- 可信区间 (CI)：一个在水平 $c \\in (0,1)$ 下的 $p$ 的等尾区间。其下端点和上端点分别是后验分布的 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数，其中 $\\alpha = 1-c$。\n- 后验概率：$\\mathbb{P}(p > \\tau \\mid D,H,a,b)$，其中分类阈值为 $\\tau \\in (0,1)$。\n- 对每个测试用例 $(D,H,a,b,c,\\tau)$ 需要计算的量：\n    1. $p$ 的后验均值。\n    2. CI 的下端点。\n    3. CI 的上端点。\n    4. 后验概率 $\\mathbb{P}(p > \\tau)$。\n- 参数 $(D,H,a,b,c,\\tau)$ 的测试套件：\n    - $(\\,30,\\,20,\\,2,\\,2,\\,0.95,\\,0.5\\,)$\n    - $(\\,0,\\,0,\\,1,\\,1,\\,0.9,\\,0.5\\,)$\n    - $(\\,50,\\,10,\\,0.5,\\,0.5,\\,0.95,\\,0.5\\,)$\n    - $(\\,1,\\,9,\\,5,\\,1,\\,0.9,\\,0.5\\,)$\n    - $(\\,100,\\,100,\\,10,\\,10,\\,0.99,\\,0.5\\,)$\n\n### 第二步：使用提取的已知信息进行验证\n\n- **科学基础**：该问题基于贝塔-二项分布模型，这是贝叶斯统计中一个标准且基础的共轭先验构造。该框架具有科学合理性，并广泛应用于文本分析和计量经济学等领域。该问题牢固地植根于已建立的概率论。\n- **适定性**：该问题是适定的。贝塔先验与二项似然的结合产生的后验分布也是一个贝塔分布。对于贝塔分布，其均值、分位数和尾部概率都是明确定义且唯一的。给定指定的输入，所有必需的计算都存在唯一解。\n- **客观性**：该问题使用精确、客观的数学语言表述。所有术语都有明确定义（例如，“鸽派指数”定义为后验均值）。该问题不含主观或模棱两可的陈述。\n\n### 第三步：结论与行动\n\n该问题有效。它具有科学合理性、适定性和客观性。它包含了获得唯一解所需的所有必要信息。将提供一个完整的、有理有据的解决方案。\n\n### 解决方案\n\n该问题要求将贝叶斯推断应用于一个标准的共轭模型。核心原理是贝塔分布是二项似然参数的共轭先验。此属性使得后验分布具有闭合形式的解析表达式，从而显著简化了计算。\n\n设概率 $p$ 的先验分布是具有形状参数 $a$ 和 $b$ 的贝塔分布：\n$$ p \\sim \\text{Beta}(a,b) $$\n其概率密度函数 (PDF) 为：\n$$ f(p; a, b) = \\frac{p^{a-1}(1-p)^{b-1}}{B(a,b)} $$\n其中 $B(a,b)$ 是贝塔函数。\n\n观测数据包含 $D$ 个“鸽派”术语和 $H$ 个“鹰派”术语，总共 $N = D+H$ 个术语。在给定概率 $p$ 的情况下，从大小为 $N$ 的样本中观测到 $D$ 个鸽派术语的似然由二项分布描述：\n$$ D \\mid p, N \\sim \\text{Binomial}(N, p) $$\n似然函数为：\n$$ L(p \\mid D, N) = \\binom{N}{D} p^D (1-p)^{N-D} $$\n\n根据贝叶斯定理，$p$ 的后验分布与似然和先验的乘积成正比：\n$$ f(p \\mid D, N, a, b) \\propto L(p \\mid D, N) \\times f(p; a, b) $$\n$$ f(p \\mid D, N, a, b) \\propto \\left( p^D (1-p)^{N-D} \\right) \\times \\left( p^{a-1} (1-p)^{b-1} \\right) $$\n合并含 $p$ 和 $(1-p)$ 的项：\n$$ f(p \\mid D, N, a, b) \\propto p^{D+a-1} (1-p)^{N-D+b-1} $$\n代入 $N = D+H$：\n$$ f(p \\mid D, N, a, b) \\propto p^{D+a-1} (1-p)^{H+b-1} $$\n这个表达式是一个贝塔分布的核，其更新后的参数为 $a' = a+D$ 和 $b' = b+H$。因此，后验分布为：\n$$ p \\mid D, H, a, b \\sim \\text{Beta}(a', b') = \\text{Beta}(a+D, b+H) $$\n\n在确定后验分布后，我们可以计算所需的四个量。\n\n1.  **后验均值（鸽派指数）**：$\\text{Beta}(a', b')$ 分布的均值由下式给出：\n    $$ E[p \\mid D, H, a, b] = \\frac{a'}{a'+b'} = \\frac{a+D}{a+D+b+H} $$\n\n2.  **等尾可信区间 (CI)**：对于置信水平 $c$，我们设 $\\alpha = 1-c$。等尾 CI 由后验分布的 $\\frac{\\alpha}{2}$ 和 $1-\\frac{\\alpha}{2}$ 分位数定义。设 $F_{a',b'}^{-1}(q)$ 为 $\\text{Beta}(a', b')$ 分布对应于概率 $q$ 的分位数函数（逆累积分布函数）。\n    - 下端点：$CI_{\\text{lower}} = F_{a',b'}^{-1}\\left(\\frac{\\alpha}{2}\\right) = F_{a+D, b+H}^{-1}\\left(\\frac{1-c}{2}\\right)$\n    - 上端点：$CI_{\\text{upper}} = F_{a',b'}^{-1}\\left(1 - \\frac{\\alpha}{2}\\right) = F_{a+D, b+H}^{-1}\\left(1 - \\frac{1-c}{2}\\right)$\n\n3.  **后验概率 $\\mathbb{P}(p > \\tau)$**：这是 $p$ 超过某个阈值 $\\tau$ 的概率，根据后验分布计算得出。这等价于在 $\\tau$ 处评估的生存函数 (SF)，即 $S(x) = 1 - F(x)$。\n    $$ \\mathbb{P}(p > \\tau \\mid D,H,a,b) = \\int_{\\tau}^{1} f(p \\mid D,H,a,b) \\,dp = 1 - F_{a',b'}(\\tau) = S_{a+D, b+H}(\\tau) $$\n    其中 $F_{a',b'}$ 和 $S_{a',b'}$ 分别是 $\\text{Beta}(a', b')$ 分布的累积分布函数 (CDF) 和生存函数 (SF)。使用生存函数在数值计算上更可取，以保证稳定性，特别是当 $\\tau$ 接近 $1$ 时。\n\n这些公式将应用于每个测试用例及所提供的参数。分位数和生存函数的计算将使用标准的数值库来执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta\n\ndef solve():\n    \"\"\"\n    Computes Bayesian sentiment metrics for a series of test cases.\n\n    For each case, it calculates the posterior mean, credible interval,\n    and a posterior probability based on a Beta-Binomial model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format (D, H, a, b, c, tau)\n    test_cases = [\n        (30, 20, 2, 2, 0.95, 0.5),\n        (0, 0, 1, 1, 0.9, 0.5),\n        (50, 10, 0.5, 0.5, 0.95, 0.5),\n        (1, 9, 5, 1, 0.9, 0.5),\n        (100, 100, 10, 10, 0.99, 0.5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        D, H, a, b, c, tau = case\n\n        # Calculate posterior parameters for the Beta distribution\n        # a_prime = a + D and b_prime = b + H\n        a_prime = a + D\n        b_prime = b + H\n\n        # 1. Calculate the posterior mean\n        posterior_mean = a_prime / (a_prime + b_prime)\n\n        # 2. Calculate the equal-tailed credible interval\n        alpha = 1.0 - c\n        ci_lower = beta.ppf(alpha / 2.0, a_prime, b_prime)\n        ci_upper = beta.ppf(1.0 - alpha / 2.0, a_prime, b_prime)\n\n        # 3. Calculate the posterior probability P(p > tau)\n        # This is the survival function (1 - CDF) of the posterior Beta distribution\n        prob_p_gt_tau = beta.sf(tau, a_prime, b_prime)\n        \n        case_results = [\n            posterior_mean,\n            ci_lower,\n            ci_upper,\n            prob_p_gt_tau\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string according to the specification:\n    # A comma-separated list of lists with no spaces, with values rounded to 6 decimal places.\n    # Example: [[m1,l1,u1,q1],[m2,l2,u2,q2],...]\n    inner_parts = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places\n        formatted_vals = [f\"{val:.6f}\" for val in res_list]\n        # Join numbers with a comma and enclose in brackets\n        inner_parts.append(f\"[{','.join(formatted_vals)}]\")\n    \n    # Join the inner lists with a comma and enclose in brackets for the final string\n    final_output_str = f\"[{','.join(inner_parts)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"}, {"introduction": "贝叶斯方法不仅用于参数估计，其更强大的功能在于预测能力。这个练习[@problem_id:2375560]将带您进入资源经济学的一个经典场景：预测新矿藏的发现。您将使用泊松-伽马共轭模型（Poisson-Gamma model）来推导后验预测分布，这是贝叶斯预测的核心概念之一。这个推导过程将加深您对模型如何整合先验知识和观测数据来预测未来事件的理解。", "id": "2375560", "problem": "在资源经济学中，一家能源公司将新矿床的发现过程建模为一个齐次泊松过程，其未知强度（每年发现数）记为 $\\lambda$。在任何长度为 $t$ 的时间间隔内，发现的数量被建模为均值为 $\\lambda t$ 的泊松分布。关于 $\\lambda$ 的先验信念由一个伽马分布表示，其形状参数为 $\\alpha>0$，率参数为 $\\beta>0$，其密度函数为 $f(\\lambda)=\\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)}\\lambda^{\\alpha-1}\\exp(-\\beta \\lambda)$（其中 $\\lambda>0$）。在一个长度为 $T>0$（单位：年）的历史时期内，共记录到 $S\\in\\{0,1,2,\\dots\\}$ 次发现。\n\n在这些假设下，使用贝叶斯推断，推导在一个长度为 $\\tau>0$（单位：年）的未来监测窗口内，至少发生一次发现的后验预测概率的闭式表达式。请将您的最终答案表示为仅含 $\\alpha$、$\\beta$、$S$、$T$ 和 $\\tau$ 的单一解析表达式。请勿代入数值。您的答案必须是单个闭式解析表达式。", "solution": "该问题要求在给定发现事件的泊松过程模型、未知率参数的伽马先验分布以及历史数据的情况下，推导在未来时间区间内观测到至少一个事件的后验预测概率。我们将通过系统的贝叶斯推断来求解。\n\n首先，我们对贝叶斯模型的各个组成部分进行形式化。\n\n在长度为 $T$ 的时间段内观测到 $S$ 次发现的似然由泊松概率质量函数给出，其均值为 $\\lambda T$。未知参数 $\\lambda$ 的似然函数为：\n$$ L(\\lambda | S, T) = P(S | \\lambda, T) = \\frac{(\\lambda T)^S \\exp(-\\lambda T)}{S!} $$\n为了进行贝叶斯更新，我们只需要似然函数的核，它与 $\\lambda$ 的函数成正比：\n$$ L(\\lambda | S, T) \\propto \\lambda^S \\exp(-\\lambda T) $$\n\n关于 $\\lambda$ 的先验信念由一个形状参数为 $\\alpha > 0$ 和率参数为 $\\beta > 0$ 的伽马分布指定。先验概率密度函数为：\n$$ p(\\lambda) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)}\\lambda^{\\alpha-1}\\exp(-\\beta \\lambda) $$\n先验的核为：\n$$ p(\\lambda) \\propto \\lambda^{\\alpha-1}\\exp(-\\beta \\lambda) $$\n\n根据贝叶斯定理，给定数据 $(S, T)$ 后 $\\lambda$ 的后验分布与似然和先验的乘积成正比：\n$$ p(\\lambda | S, T) \\propto L(\\lambda | S, T) \\times p(\\lambda) $$\n代入核函数：\n$$ p(\\lambda | S, T) \\propto \\left( \\lambda^S \\exp(-\\lambda T) \\right) \\times \\left( \\lambda^{\\alpha-1}\\exp(-\\beta \\lambda) \\right) $$\n$$ p(\\lambda | S, T) \\propto \\lambda^{S+\\alpha-1} \\exp(-(\\beta+T)\\lambda) $$\n该表达式是一个伽马分布的核。伽马分布是泊松似然的共轭先验。因此，$\\lambda$ 的后验分布是一个具有更新后参数的伽马分布：\n形状参数 $\\alpha' = \\alpha + S$\n率参数 $\\beta' = \\beta + T$\n所以，后验分布为 $\\lambda | S, T \\sim \\text{Gamma}(\\alpha+S, \\beta+T)$。其完整的概率密度函数为：\n$$ p(\\lambda | S, T) = \\frac{(\\beta+T)^{\\alpha+S}}{\\Gamma(\\alpha+S)}\\lambda^{\\alpha+S-1}\\exp(-(\\beta+T)\\lambda) $$\n\n接下来，我们必须求出在长度为 $\\tau > 0$ 的未来时间窗口内发现次数（我们称之为 $N_\\tau$）的后验预测分布。给定 $\\lambda$ 时，$N_\\tau$ 的模型也是一个均值为 $\\lambda \\tau$ 的泊松分布：\n$$ P(N_\\tau = k | \\lambda, \\tau) = \\frac{(\\lambda\\tau)^k \\exp(-\\lambda\\tau)}{k!} \\quad \\text{for } k \\in \\{0, 1, 2, \\dots\\} $$\n$N_\\tau=k$ 的后验预测概率是通过对 $N_\\tau$ 和 $\\lambda$ 的联合分布使用 $\\lambda$ 的后验分布对 $\\lambda$进行边缘化得到的：\n$$ P(N_\\tau = k | S, T, \\tau) = \\int_{0}^{\\infty} P(N_\\tau = k | \\lambda, \\tau) p(\\lambda | S, T) d\\lambda $$\n\n题目要求的是至少有一次发现的概率，即 $P(N_\\tau \\ge 1 | S, T, \\tau)$。更直接的方法是计算其互补事件（零次发现）的概率 $P(N_\\tau = 0 | S, T, \\tau)$，然后用 1 减去它。\n我们先计算 $P(N_\\tau = 0 | S, T, \\tau)$。我们将泊松概率质量函数中的 $k$ 设为 0：\n$$ P(N_\\tau = 0 | \\lambda, \\tau) = \\frac{(\\lambda\\tau)^0 \\exp(-\\lambda\\tau)}{0!} = \\exp(-\\lambda\\tau) $$\n现在，我们对 $\\lambda$ 的后验分布积分：\n$$ P(N_\\tau = 0 | S, T, \\tau) = \\int_{0}^{\\infty} \\exp(-\\lambda\\tau) p(\\lambda | S, T) d\\lambda $$\n代入后验概率密度函数：\n$$ P(N_\\tau = 0 | S, T, \\tau) = \\int_{0}^{\\infty} \\exp(-\\lambda\\tau) \\frac{(\\beta+T)^{\\alpha+S}}{\\Gamma(\\alpha+S)}\\lambda^{\\alpha+S-1}\\exp(-(\\beta+T)\\lambda) d\\lambda $$\n合并指数项并将常数移到积分外：\n$$ P(N_\\tau = 0 | S, T, \\tau) = \\frac{(\\beta+T)^{\\alpha+S}}{\\Gamma(\\alpha+S)} \\int_{0}^{\\infty} \\lambda^{\\alpha+S-1} \\exp(-(\\beta+T+\\tau)\\lambda) d\\lambda $$\n该积分为未归一化的伽马积分的标准形式。回想一下，对于任何 $a>0$ 和 $b>0$：\n$$ \\int_{0}^{\\infty} x^{a-1} \\exp(-bx) dx = \\frac{\\Gamma(a)}{b^a} $$\n在我们的例子中，形状为 $a = \\alpha+S$，率为 $b = \\beta+T+\\tau$。应用此公式：\n$$ \\int_{0}^{\\infty} \\lambda^{\\alpha+S-1} \\exp(-(\\beta+T+\\tau)\\lambda) d\\lambda = \\frac{\\Gamma(\\alpha+S)}{(\\beta+T+\\tau)^{\\alpha+S}} $$\n将此结果代回我们的概率表达式中：\n$$ P(N_\\tau = 0 | S, T, \\tau) = \\frac{(\\beta+T)^{\\alpha+S}}{\\Gamma(\\alpha+S)} \\times \\frac{\\Gamma(\\alpha+S)}{(\\beta+T+\\tau)^{\\alpha+S}} $$\n简化该表达式可得：\n$$ P(N_\\tau = 0 | S, T, \\tau) = \\left( \\frac{\\beta+T}{\\beta+T+\\tau} \\right)^{\\alpha+S} $$\n这个结果是在未来窗口中观测到零次发现的概率。问题要求的是至少有一次发现的概率 $P(N_\\tau \\ge 1)$。这是零次发现的互补事件：\n$$ P(N_\\tau \\ge 1 | S, T, \\tau) = 1 - P(N_\\tau = 0 | S, T, \\tau) $$\n因此，最终表达式为：\n$$ P(N_\\tau \\ge 1 | S, T, \\tau) = 1 - \\left( \\frac{\\beta+T}{\\beta+T+\\tau} \\right)^{\\alpha+S} $$\n这就是后验预测概率的闭式解析表达式，完全由给定的参数和数据 $\\alpha$、$\\beta$、$S$、$T$ 和 $\\tau$ 表示，符合题目要求。", "answer": "$$\\boxed{1 - \\left( \\frac{\\beta+T}{\\beta+T+\\tau} \\right)^{\\alpha+S}}$$"}, {"introduction": "在经济学中，我们常常面临着多种理论模型对同一现象的解释。本练习[@problem_id:2375563]引导您使用贝叶斯因子（Bayes Factor）——一个在贝叶斯框架下进行模型比较的黄金标准——来评估两个简化的宏观经济理论。通过为具有正态-逆伽马（Normal-Inverse-Gamma）先验的线性模型计算边际似然，您将学习如何量化数据对不同模型的支持程度，并直观地感受先验设定对模型选择结果的敏感性。", "id": "2375563", "problem": "给定两个相互竞争的线性时间序列模型，这两个模型旨在作为两种关于国内生产总值 (GDP) 增长率波动的经济理论的风格化表征。第一个模型 $M_{K}$ 代表一个简化的凯恩斯 (Keynesian) 机制，其中包含一个用于捕捉需求变化的截距项。第二个模型 $M_{R}$ 代表一个简化的真实商业周期 (Real Business Cycle, RBC) 机制，通过两个滞后项实现更强的持续性，且不包含截距项。对于一个去均值的实际 GDP 增长率的单变量序列 $\\{y_t\\}_{t=1}^{T}$，在共同样本 $t=3,\\dots,T$ 上定义模型如下：\n- 模型 $M_{K}$ (凯恩斯模型): 对 $t=3,\\dots,T$, $y_t = \\alpha + \\phi y_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n- 模型 $M_{R}$ (真实商业周期模型 (RBC)): 对 $t=3,\\dots,T$, $y_t = \\beta_1 y_{t-1} + \\beta_2 y_{t-2} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n对于每个模型，其参数和先验分布为：\n- 对于 $M_{K}$，参数 $\\theta_K = (\\alpha,\\phi,\\sigma^2)$ 的先验为\n  $\\alpha,\\phi \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,K}, \\sigma^2 V_{0,K})$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,K}, b_{0,K})$。\n- 对于 $M_{R}$，参数 $\\theta_R = (\\beta_1,\\beta_2,\\sigma^2)$ 的先验为\n  $\\beta_1,\\beta_2 \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,R}, \\sigma^2 V_{0,R})$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,R}, b_{0,R})$。\n\n逆伽马 (Inverse-Gamma) 先验由以下密度函数参数化\n$$\np(\\sigma^2) \\;=\\; \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\, (\\sigma^2)^{-(a_0+1)} \\exp\\!\\left(-\\frac{b_0}{\\sigma^2}\\right),\n$$\n其中 $\\Gamma(\\cdot)$ 是伽马函数。\n\n您必须为每个数据集和每个指定的先验配置，计算支持 $M_{K}$ 相对于 $M_{R}$ 的贝叶斯因子 (Bayes factor) 的自然对数，即：\n$$\n\\log \\text{BF}_{K,R} \\;=\\; \\log p(y \\mid M_{K}) \\;-\\; \\log p(y \\mid M_{R}),\n$$\n其中 $p(y \\mid M)$ 表示模型 $M$ 下在共同样本 $t=3,\\dots,T$ 上评估的边际似然。\n\n数据集 (每个序列为 $y_1,\\dots,y_T$), 其中 $T$ 由序列长度隐式指定：\n- 数据集 $1$: $[0.00, 0.10, 0.18, 0.24, 0.29, 0.31, 0.33, 0.35]$.\n- 数据集 $2$: $[0.00, 0.30, 0.20, 0.27, 0.18, 0.25, 0.17, 0.24]$.\n- 数据集 $3$: $[0.05, 0.02, 0.03, 0.01]$.\n\n将使用两种不同的先验设定：\n\n- 先验设定 $\\mathcal{A}$ (无信息，模型间对称)：\n  - 对于 $M_{K}$: $m_{0,K}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,K}^{\\mathcal{A}} = 0.01$, $b_{0,K}^{\\mathcal{A}} = 0.01$.\n  - 对于 $M_{R}$: $m_{0,R}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,R}^{\\mathcal{A}} = 0.01$, $b_{0,R}^{\\mathcal{A}} = 0.01$.\n\n- 先验设定 $\\mathcal{B}$ (有信息，模型特定)：\n  - 对于 $M_{K}$: $m_{0,K}^{\\mathcal{B}} = \\begin{bmatrix} 0.02 \\\\ 0.80 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,K}^{\\mathcal{B}} = 2.00$, $b_{0,K}^{\\mathcal{B}} = 0.01$.\n  - 对于 $M_{R}$: $m_{0,R}^{\\mathcal{B}} = \\begin{bmatrix} 0.60 \\\\ 0.20 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,R}^{\\mathcal{B}} = 2.00$, $b_{0,R}^{\\mathcal{B}} = 0.01$.\n\n测试套件与答案规范：\n- 对于两个模型和所有数据集，用于似然评估的共同样本均为 $t=3,\\dots,T$。\n- 对于每个数据集 $i \\in \\{1,2,3\\}$ 和每个先验设定 $P \\in \\{\\mathcal{A},\\mathcal{B}\\}$，计算标量 $\\log \\text{BF}_{K,R}^{(i,P)}$。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序必须完全如下：\n$$\n[\\log \\text{BF}_{K,R}^{(1,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(1,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{B})}]\n$$\n所有六个输出都必须是浮点数。除此单行外，不允许任何额外的文本或格式。", "solution": "问题陈述经过严格验证。\n\n### 第 1 步：提取已知条件\n- **模型**：\n    - $M_{K}$ (凯恩斯模型): $y_t = \\alpha + \\phi y_{t-1} + \\varepsilon_t$, for $t=3,\\dots,T$.\n    - $M_{R}$ (真实商业周期模型): $y_t = \\beta_1 y_{t-1} + \\beta_2 y_{t-2} + \\varepsilon_t$, for $t=3,\\dots,T$.\n    - 对于两个模型，误差项为 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n- **先验**：\n    - 对于 $M_{K}$，参数 $\\theta_K = (\\alpha,\\phi,\\sigma^2)$ 的先验为 $\\alpha,\\phi \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,K}, \\sigma^2 V_{0,K})$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,K}, b_{0,K})$。\n    - 对于 $M_{R}$，参数 $\\theta_R = (\\beta_1,\\beta_2,\\sigma^2)$ 的先验为 $\\beta_1,\\beta_2 \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,R}, \\sigma^2 V_{0,R})$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,R}, b_{0,R})$。\n- **逆伽马概率密度函数 (PDF)**：$p(\\sigma^2) = \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\, (\\sigma^2)^{-(a_0+1)} \\exp(-\\frac{b_0}{\\sigma^2})$。\n- **目标**：计算贝叶斯因子的自然对数，$\\log \\text{BF}_{K,R} = \\log p(y \\mid M_{K}) - \\log p(y \\mid M_{R})$。\n- **数据集**：\n    - 数据集 $1$: $[0.00, 0.10, 0.18, 0.24, 0.29, 0.31, 0.33, 0.35]$.\n    - 数据集 $2$: $[0.00, 0.30, 0.20, 0.27, 0.18, 0.25, 0.17, 0.24]$.\n    - 数据集 $3$: $[0.05, 0.02, 0.03, 0.01]$.\n- **先验设定**：\n    - 设定 $\\mathcal{A}$：\n        - $M_{K}$: $m_{0,K}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,K}^{\\mathcal{A}} = 0.01$, $b_{0,K}^{\\mathcal{A}} = 0.01$.\n        - $M_{R}$: $m_{0,R}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,R}^{\\mathcal{A}} = 0.01$, $b_{0,R}^{\\mathcal{A}} = 0.01$.\n    - 设定 $\\mathcal{B}$：\n        - $M_{K}$: $m_{0,K}^{\\mathcal{B}} = \\begin{bmatrix} 0.02 \\\\ 0.80 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,K}^{\\mathcal{B}} = 2.00$, $b_{0,K}^{\\mathcal{B}} = 0.01$.\n        - $M_{R}$: $m_{0,R}^{\\mathcal{B}} = \\begin{bmatrix} 0.60 \\\\ 0.20 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,R}^{\\mathcal{B}} = 2.00$, $b_{0,R}^{\\mathcal{B}} = 0.01$.\n- **评估样本**：用于似然评估的共同样本为 $t=3,\\dots,T$。\n- **输出顺序**：$[\\log \\text{BF}_{K,R}^{(1,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(1,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{B})}]$。\n\n### 第 2 步：使用提取的已知条件进行验证\n评估问题的有效性。\n- **科学依据**：该问题是贝叶斯计量经济学中的一个标准练习。它涉及使用通过边际似然计算的贝叶斯因子来比较两个线性回归模型。所选的先验结构，即正态-逆伽马分布，是方差未知的线性模型的自然共轭先验，这是贝叶斯统计学中的一个基本概念。模型本身，一个带常数项的 $AR(1)$ 模型和一个不带常数项的 $AR(2)$ 模型，是教科书级别的例子。该问题牢固地建立在公认的统计学和计量经济学原理之上。\n- **适定性**：所有必要的组成部分——数据、模型设定、先验分布和超参数——都已提供。目标定义明确。对于指定的共轭先验设置，边际似然具有众所周知的解析解。因此，每种情况都存在唯一、稳定且有意义的解。\n- **客观性**：该问题以精确的数学语言陈述。“Keynesian”和“RBC”这两个名称仅作为数学结构的标签，不会给所需计算引入任何主观性。\n- **缺陷清单**：该问题没有违反任何指定的缺陷条件。它在科学上是合理的、可形式化的、完整的、可行的、适定的且可验证的。\n\n### 第 3 步：结论与行动\n此问题是**有效的**。将提供解决方案。\n\n### 求解方法\n\n目标是计算对数贝叶斯因子 $\\log \\text{BF}_{K,R}$，这需要为每个模型 $M \\in \\{M_K, M_R\\}$ 计算对数边际似然 $\\log p(y \\mid M)$。\n\n两个模型都符合一般线性模型的框架：\n$$\ny = X\\beta + \\varepsilon, \\quad \\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_N)\n$$\n其中 $y$ 是一个包含 $N$ 个观测值的向量，$X$ 是一个 $N \\times k$ 的设计矩阵，$\\beta$ 是一个 $k \\times 1$ 的回归系数向量。似然函数为 $p(y \\mid \\beta, \\sigma^2) = (2\\pi\\sigma^2)^{-N/2} \\exp(-\\frac{1}{2\\sigma^2}(y-X\\beta)^T(y-X\\beta))$。\n\n指定的先验是正态-逆伽马分布：\n$$\np(\\beta, \\sigma^2) = p(\\beta \\mid \\sigma^2) p(\\sigma^2)\n$$\n其中 $\\beta \\mid \\sigma^2 \\sim \\mathcal{N}(m_0, \\sigma^2 V_0)$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_0, b_0)$。这是正态线性模型的共轭先验。\n\n边际似然 $p(y \\mid M)$ 是通过将似然与先验的乘积对所有参数进行积分得到的：\n$$\np(y \\mid M) = \\int_0^\\infty \\int_{\\mathbb{R}^k} p(y \\mid \\beta, \\sigma^2) p(\\beta \\mid \\sigma^2) p(\\sigma^2) \\, d\\beta \\, d\\sigma^2\n$$\n对于指定的共轭设置，该积分有解析解。参数的后验分布也是正态-逆伽马分布，$p(\\beta, \\sigma^2 \\mid y) \\propto p(\\beta, \\sigma^2)p(y \\mid \\beta, \\sigma^2)$，其更新后的参数为：\n- $\\beta$ 的后验精度矩阵：$V_n^{-1} = V_0^{-1} + X^T X$\n- $\\beta$ 的后验均值：$m_n = V_n (V_0^{-1}m_0 + X^T y)$\n- $\\sigma^2$ 的后验形状参数：$a_n = a_0 + N/2$\n- $\\sigma^2$ 的后验速率参数：$b_n = b_0 + \\frac{1}{2}(y^T y + m_0^T V_0^{-1} m_0 - m_n^T V_n^{-1} m_n)$\n\n边际似然是后验分布的归一化常数，由下式给出：\n$$\np(y \\mid M) = \\frac{\\Gamma(a_n)}{\\Gamma(a_0)} \\frac{b_0^{a_0}}{b_n^{a_n}} (2\\pi)^{-N/2} \\frac{|V_n|^{1/2}}{|V_0|^{1/2}}\n$$\n为了防止数值下溢并简化计算，我们使用边际似然的自然对数：\n$$\n\\log p(y \\mid M) = \\log\\Gamma(a_n) - \\log\\Gamma(a_0) + a_0\\log(b_0) - a_n\\log(b_n) - \\frac{N}{2}\\log(2\\pi) + \\frac{1}{2}(\\log|V_n| - \\log|V_0|)\n$$\n对数伽马函数 $\\log\\Gamma(\\cdot)$ 由标准科学计算库提供。对数行列式 $\\log|V|$ 进行稳健计算。\n\n对于每个数据集和模型，我们首先使用共同样本 $t=3, \\dots, T$ 构建响应向量 $y$ 和设计矩阵 $X$。观测数量为 $N = T - 2$。\n响应向量为 $y = [y_3, y_4, \\dots, y_T]^T$。\n\n对于模型 $M_K (y_t = \\alpha + \\phi y_{t-1} + \\varepsilon_t)$，参数向量为 $\\beta_K = [\\alpha, \\phi]^T$，设计矩阵为：\n$$\nX_K = \\begin{bmatrix} 1 & y_2 \\\\ 1 & y_3 \\\\ \\vdots & \\vdots \\\\ 1 & y_{T-1} \\end{bmatrix}\n$$\n这是一个 $N \\times 2$ 的矩阵。\n\n对于模型 $M_R (y_t = \\beta_1 y_{t-1} + \\beta_2 y_{t-2} + \\varepsilon_t)$，参数向量为 $\\beta_R = [\\beta_1, \\beta_2]^T$，设计矩阵为：\n$$\nX_R = \\begin{bmatrix} y_2 & y_1 \\\\ y_3 & y_2 \\\\ \\vdots & \\vdots \\\\ y_{T-1} & y_{T-2} \\end{bmatrix}\n$$\n这也是一个 $N \\times 2$ 的矩阵。\n\n六个所需计算中每一个的步骤如下：\n1. 选择一个数据集和一个先验设定。\n2. 构建响应向量 $y$ 以及设计矩阵 $X_K$ 和 $X_R$。\n3. 对于模型 $M_K$，使用其对应的先验超参数 ($m_{0,K}, V_{0,K}, a_{0,K}, b_{0,K}$) 来计算后验参数 ($V_{n,K}, m_{n,K}, a_{n,K}, b_{n,K}$)，然后使用上述公式计算对数边际似然 $\\log p(y \\mid M_K)$。\n4. 对于模型 $M_R$，使用其对应的先验超参数重复步骤3，以找到 $\\log p(y \\mid M_R)$。\n5. 计算对数贝叶斯因子：$\\log \\text{BF}_{K,R} = \\log p(y \\mid M_K) - \\log p(y \\mid M_R)$。\n对问题陈述中指定的每个数据集-先验对重复此过程。该算法将使用 `numpy` 库进行线性代数运算，并使用 `scipy` 库计算对数伽马函数，以 Python 实现。", "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln\nfrom numpy.linalg import inv, slogdet\n\ndef calculate_log_marginal_likelihood(y_data, X, m0, V0, a0, b0):\n    \"\"\"\n    Calculates the log marginal likelihood for a linear model with a Normal-Inverse-Gamma prior.\n    \n    Args:\n        y_data (np.ndarray): The dependent variable vector (N,).\n        X (np.ndarray): The design matrix (N, k).\n        m0 (np.ndarray): The prior mean vector for beta (k,).\n        V0 (np.ndarray): The prior covariance matrix for beta (k, k).\n        a0 (float): The prior shape parameter for sigma^2.\n        b0 (float): The prior rate parameter for sigma^2.\n\n    Returns:\n        float: The log marginal likelihood.\n    \"\"\"\n    N, k = X.shape\n\n    # Calculation of posterior parameters for beta (Vn, mn)\n    V0_inv = inv(V0)\n    Vn_inv = V0_inv + X.T @ X\n    Vn = inv(Vn_inv)\n    mn = Vn @ (V0_inv @ m0 + X.T @ y_data)\n    \n    # Calculation of posterior parameters for sigma^2 (an, bn)\n    an = a0 + N / 2\n    \n    # Quadratic forms for bn\n    # bn = b0 + 0.5 * (y'y + m0'V0_inv*m0 - mn'Vn_inv*mn)\n    ss_data = y_data.T @ y_data\n    ss_prior = m0.T @ V0_inv @ m0\n    ss_posterior_mean = mn.T @ Vn_inv @ mn\n    bn = b0 + 0.5 * (ss_data + ss_prior - ss_posterior_mean)\n\n    # Log determinant term\n    _, logdet_Vn = slogdet(Vn)\n    _, logdet_V0 = slogdet(V0)\n    log_det_term = 0.5 * (logdet_Vn - logdet_V0)\n\n    # Assemble the log marginal likelihood\n    log_ml = (gammaln(an) - gammaln(a0) +\n              a0 * np.log(b0) - an * np.log(bn) -\n              (N / 2) * np.log(2 * np.pi) +\n              log_det_term)\n\n    return log_ml\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the log Bayes Factor for each dataset and prior specification.\n    \"\"\"\n    # Define datasets\n    datasets = {\n        1: np.array([0.00, 0.10, 0.18, 0.24, 0.29, 0.31, 0.33, 0.35]),\n        2: np.array([0.00, 0.30, 0.20, 0.27, 0.18, 0.25, 0.17, 0.24]),\n        3: np.array([0.05, 0.02, 0.03, 0.01])\n    }\n\n    # Define prior specifications\n    priors = {\n        'A': {  # Prior Specification A\n            'K': {'m0': np.array([0.0, 0.0]), 'V0': np.diag([10000.0, 10000.0]), 'a0': 0.01, 'b0': 0.01},\n            'R': {'m0': np.array([0.0, 0.0]), 'V0': np.diag([10000.0, 10000.0]), 'a0': 0.01, 'b0': 0.01}\n        },\n        'B': {  # Prior Specification B\n            'K': {'m0': np.array([0.02, 0.80]), 'V0': np.diag([0.01, 0.01]), 'a0': 2.0, 'b0': 0.01},\n            'R': {'m0': np.array([0.60, 0.20]), 'V0': np.diag([0.01, 0.01]), 'a0': 2.0, 'b0': 0.01}\n        }\n    }\n    \n    test_cases = [\n        (1, 'A'), (1, 'B'),\n        (2, 'A'), (2, 'B'),\n        (3, 'A'), (3, 'B')\n    ]\n\n    results = []\n    for d_idx, p_key in test_cases:\n        y_full = datasets[d_idx]\n        T = len(y_full)\n        N = T - 2\n\n        # Common dependent variable for the sample t=3,...,T\n        y_vec = y_full[2:]\n\n        # Construct Design Matrix for Model K (Keynesian)\n        # y_t = alpha + phi*y_{t-1}\n        X_K = np.vstack([np.ones(N), y_full[1:T-1]]).T\n        \n        # Construct Design Matrix for Model R (RBC)\n        # y_t = beta1*y_{t-1} + beta2*y_{t-2}\n        X_R = np.vstack([y_full[1:T-1], y_full[0:T-2]]).T\n        \n        # Get prior hyperparameters for the current case\n        prior_K = priors[p_key]['K']\n        prior_R = priors[p_key]['R']\n\n        # Calculate log marginal likelihood for Model K\n        log_ml_K = calculate_log_marginal_likelihood(y_vec, X_K, \n            prior_K['m0'], prior_K['V0'], prior_K['a0'], prior_K['b0'])\n        \n        # Calculate log marginal likelihood for Model R\n        log_ml_R = calculate_log_marginal_likelihood(y_vec, X_R, \n            prior_R['m0'], prior_R['V0'], prior_R['a0'], prior_R['b0'])\n\n        # Compute the log Bayes Factor in favor of K over R\n        log_bf_KR = log_ml_K - log_ml_R\n        results.append(log_bf_KR)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}