{"hands_on_practices": [{"introduction": "订单簿中的订单是如何分布的？第一个实践练习将深入探讨市场微观结构的一个基本静态特征。通过将受现实世界启发的数据拟合到幂律分布，你将学习如何量化“小额订单远比大额订单普遍”这一观察结果，这是金融市场的一个关键典型化事实。该练习将为你提供使用最大似然估计（Maximum Likelihood Estimation, MLE）这一强大的统计工具来拟合数据模型的动手经验。[@problem_id:2408310]", "id": "2408310", "problem": "给定从加密货币限价订单簿中观测到的独立限价订单大小样本，以基础资产单位（例如，代币数量）表示。假设在每种情况下，所有观测值都是独立同分布的，并且在指定区间内，订单大小遵循闭合区间上的连续截断幂律分布。具体而言，对于参数 $x_{\\min} > 0$、$x_{\\max} > x_{\\min}$ 和指数 $\\alpha > 0$，其概率密度函数为\n$$\nf(x \\mid \\alpha, x_{\\min}, x_{\\max}) = C(\\alpha; x_{\\min}, x_{\\max}) \\, x^{-\\alpha}, \\quad x \\in [x_{\\min}, x_{\\max}],\n$$\n且在该区间外 $f(x \\mid \\alpha, x_{\\min}, x_{\\max}) = 0$，其中归一化常数 $C(\\alpha; x_{\\min}, x_{\\max})$ 满足\n$$\n\\int_{x_{\\min}}^{x_{\\max}} C(\\alpha; x_{\\min}, x_{\\max}) \\, x^{-\\alpha} \\, dx = 1.\n$$\n对于 $\\alpha \\neq 1$，该常数为\n$$\nC(\\alpha; x_{\\min}, x_{\\max}) = \\frac{1 - \\alpha}{x_{\\max}^{1 - \\alpha} - x_{\\min}^{1 - \\alpha}},\n$$\n对于 $\\alpha = 1$，其值为相应的连续极限。\n\n任务：对于下方的每个测试用例，仅使用落在指定区间 $[x_{\\min}, x_{\\max}]$ 内的观测值，通过最大化截断幂律模型下的对数似然来估计指数 $\\alpha$。将每个用例估计出的 $\\alpha$ 作为纯数字（无单位）报告。然后，从经济学角度解释该指数，说明其如何指示大额订单与小额订单的相对频率；但是，您的程序输出应仅包含数值估计。\n\n所有订单大小均以基础资产单位（例如，代币）表示。指数 $\\alpha$ 是无量纲的。您的程序最终输出必须是单行文本，其中包含一个由逗号分隔的三个估计指数列表，每个指数四舍五入到小数点后四位，并用方括号括起来（例如，$[\\alpha_1,\\alpha_2,\\alpha_3]$）。不应打印任何其他文本。\n\n测试套件（请精确使用这些样本和区间）：\n\n用例 1（理想路径，中度截断）：\n- 区间：$[x_{\\min}, x_{\\max}] = [0.02, 5.0]$。\n- 观测到的订单大小：\n$[0.02, 0.02, 0.025, 0.03, 0.03, 0.035, 0.04, 0.045, 0.05, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.12, 0.15, 0.18, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 1.10, 1.30, 1.50, 1.70, 2.00, 2.50, 3.00, 3.50, 4.00]$。\n\n用例 2（更宽的截断，质量集中在下界附近，有少量大额订单）：\n- 区间：$[x_{\\min}, x_{\\max}] = [0.01, 10.0]$。\n- 观测到的订单大小：\n$[0.01, 0.01, 0.012, 0.015, 0.02, 0.02, 0.025, 0.03, 0.035, 0.04, 0.05, 0.06, 0.08, 0.10, 0.13, 0.17, 0.22, 0.30, 0.40, 0.55, 0.75, 1.00, 1.40, 2.00, 3.00, 4.50, 6.00, 8.00, 9.50]$。\n\n用例 3（拟合前需要进行区间内筛选的边缘用例）：\n- 区间：$[x_{\\min}, x_{\\max}] = [0.05, 2.0]$。\n- 观测到的订单大小（请注意，某些值位于区间之外，在估计前必须丢弃）：\n$[0.03, 0.04, 0.05, 0.06, 0.07, 0.09, 0.12, 0.16, 0.21, 0.28, 0.37, 0.50, 0.68, 0.91, 1.20, 1.60, 2.00, 2.20, 3.00, 0.02, 1.90]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，$[1.7321,2.0000,1.2345]$），列表中的每个条目是对应案例估计出的指数 $\\alpha$，四舍五入到小数点后四位。不应产生任何其他输出。", "solution": "该问题要求根据一组观测到的订单大小，估计截断幂律分布的指数 $\\alpha$。估计将使用最大似然估计（MLE）方法进行。分析过程如下。\n\n首先，必须对问题陈述进行验证。该问题具有科学依据，因为幂律分布是经济物理学和金融学中用于描述订单大小等量的标准模型。该问题是适定的（well-posed），提供了清晰的统计模型和数据，可通过标准估计程序获得唯一解。所有术语均有定义，所提供的数据与上下文一致。因此，该问题被认定为有效，可以构建严谨的解决方案。\n\n对于 $x \\in [x_{\\min}, x_{\\max}]$，订单大小 $x$ 的概率密度函数（PDF）给出如下：\n$$\nf(x \\mid \\alpha, x_{\\min}, x_{\\max}) = C(\\alpha; x_{\\min}, x_{\\max}) \\, x^{-\\alpha}\n$$\n其中 $\\alpha > 0$ 是待估计的指数，$x_{\\min}$ 和 $x_{\\max}$ 是给定的截断边界。归一化常数 $C(\\alpha; x_{\\min}, x_{\\max})$（下文记为 $C(\\alpha)$）确保 PDF 在其支撑集上的积分为1。\n\n对于 $\\alpha \\neq 1$，该常数为：\n$$\nC(\\alpha) = \\frac{1 - \\alpha}{x_{\\max}^{1 - \\alpha} - x_{\\min}^{1 - \\alpha}}\n$$\n对于 $\\alpha = 1$ 的特殊情况，我们必须评估当 $\\alpha \\to 1$ 时 $C(\\alpha)$ 的极限。通过对关于 $\\delta = 1 - \\alpha$ 的表达式应用洛必达法则（L'Hôpital's rule），我们得到：\n$$\nC(1) = \\lim_{\\alpha \\to 1} \\frac{1 - \\alpha}{x_{\\max}^{1 - \\alpha} - x_{\\min}^{1 - \\alpha}} = \\frac{1}{\\ln(x_{\\max}) - \\ln(x_{\\min})} = \\frac{1}{\\ln(x_{\\max}/x_{\\min})}\n$$\n\n给定一组落在区间 $[x_{\\min}, x_{\\max}]$ 内的 $N$ 个独立同分布的观测值 $\\{x_i\\}_{i=1}^N$，似然函数 $L(\\alpha)$ 是各个概率的乘积：\n$$\nL(\\alpha \\mid \\{x_i\\}) = \\prod_{i=1}^{N} f(x_i \\mid \\alpha) = \\prod_{i=1}^{N} C(\\alpha) x_i^{-\\alpha} = [C(\\alpha)]^N \\left( \\prod_{i=1}^{N} x_i \\right)^{-\\alpha}\n$$\n在计算上，使用对数似然函数 $\\mathcal{L}(\\alpha) = \\ln L(\\alpha)$ 更为方便：\n$$\n\\mathcal{L}(\\alpha) = \\ln\\left( [C(\\alpha)]^N \\right) + \\ln\\left( \\left( \\prod_{i=1}^{N} x_i \\right)^{-\\alpha} \\right) = N \\ln C(\\alpha) - \\alpha \\sum_{i=1}^{N} \\ln x_i\n$$\n为了找到最大似然估计值 $\\hat{\\alpha}$，我们必须找到使 $\\mathcal{L}(\\alpha)$ 最大化的 $\\alpha$ 值。这通过求解 $\\frac{d\\mathcal{L}(\\alpha)}{d\\alpha} = 0$ 来实现。其导数为：\n$$\n\\frac{d\\mathcal{L}(\\alpha)}{d\\alpha} = N \\frac{d}{d\\alpha}(\\ln C(\\alpha)) - \\sum_{i=1}^{N} \\ln x_i = 0\n$$\n$\\ln C(\\alpha)$ 的导数并非平凡，得到的方程是超越方程，这意味着无法解析地求解 $\\alpha$。因此，需要采用数值方法。标准方法是使用数值优化算法来找到负对数似然函数 $-\\mathcal{L}(\\alpha)$ 的最小值。\n\n需要最小化的函数是：\n$$\n-\\mathcal{L}(\\alpha) = -N \\ln C(\\alpha) + \\alpha \\sum_{i=1}^{N} \\ln x_i\n$$\n对于 $\\ln C(\\alpha)$，一个适用于所有 $\\alpha \\neq 1$ 的数值稳定表达式是 $\\ln|1 - \\alpha| - \\ln|x_{\\max}^{1 - \\alpha} - x_{\\min}^{1 - \\alpha}|$。必须分段实现完整的目标函数，以处理 $\\alpha = 1$ 的独立情况。算法将搜索使该函数最小化的 $\\alpha > 0$ 的值。\n\n对于每个测试用例，流程如下：\n$1$. 筛选提供的观测订单大小列表，只保留位于指定区间 $[x_{\\min}, x_{\\max}]$ 内的值 $x_i$。设此类有效观测值的数量为 $N$。\n$2$. 计算这些有效观测值的对数之和，$\\sum_{i=1}^{N} \\ln x_i$。\n$3$. 使用 $N$、$\\sum \\ln x_i$、$x_{\\min}$ 和 $x_{\\max}$ 的值，在合适的范围（例如 $\\alpha > 0$）内对负对数似然函数 $-\\mathcal{L}(\\alpha)$ 关于 $\\alpha$ 进行数值最小化。\n$4$. 使此函数最小化的 $\\alpha$ 值即为最大似然估计值 $\\hat{\\alpha}$。\n\n从经济学角度来看，指数 $\\alpha$ 量化了订单大小的分布。一个较大的 $\\alpha$ 值表示概率密度 $f(x) \\propto x^{-\\alpha}$ 随 $x$ 的增加而迅速衰减。这意味着小额订单的频率远超大额订单。一个较小的 $\\alpha$ 值对应于分布中更“重”的尾部（heavy tail），表明大额订单虽然频率仍低于小额订单，但其出现的相对概率更高。因此，$\\alpha$ 是市场碎片化以及散户规模与机构规模流动性供给之间平衡的一个指标。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves for the MLE of the power-law exponent alpha for three test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"interval\": (0.02, 5.0),\n            \"observations\": [\n                0.02, 0.02, 0.025, 0.03, 0.03, 0.035, 0.04, 0.045, 0.05, 0.05, 0.06, 0.07, 0.08, 0.09,\n                0.10, 0.12, 0.15, 0.18, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.60, 0.70, 0.80,\n                0.90, 1.00, 1.10, 1.30, 1.50, 1.70, 2.00, 2.50, 3.00, 3.50, 4.00\n            ]\n        },\n        {\n            \"interval\": (0.01, 10.0),\n            \"observations\": [\n                0.01, 0.01, 0.012, 0.015, 0.02, 0.02, 0.025, 0.03, 0.035, 0.04, 0.05, 0.06, 0.08,\n                0.10, 0.13, 0.17, 0.22, 0.30, 0.40, 0.55, 0.75, 1.00, 1.40, 2.00, 3.00, 4.50,\n                6.00, 8.00, 9.50\n            ]\n        },\n        {\n            \"interval\": (0.05, 2.0),\n            \"observations\": [\n                0.03, 0.04, 0.05, 0.06, 0.07, 0.09, 0.12, 0.16, 0.21, 0.28, 0.37, 0.50, 0.68,\n                0.91, 1.20, 1.60, 2.00, 2.20, 3.00, 0.02, 1.90\n            ]\n        }\n    ]\n\n    results = []\n\n    def neg_log_likelihood(alpha, N, sum_log_x, x_min, x_max):\n        \"\"\"\n        Computes the negative log-likelihood for the truncated power-law distribution.\n        \"\"\"\n        if N == 0:\n            return np.inf\n\n        # Case for alpha = 1\n        if np.isclose(alpha, 1.0):\n            log_C = -np.log(np.log(x_max) - np.log(x_min))\n        # Case for alpha != 1\n        else:\n            one_minus_alpha = 1.0 - alpha\n            try:\n                # This formulation is numerically stable for alpha < 1 and alpha > 1\n                log_C = np.log(np.abs(one_minus_alpha)) - np.log(np.abs(x_max**one_minus_alpha - x_min**one_minus_alpha))\n            except (ValueError, ZeroDivisionError):\n                return np.inf\n\n        log_L = N * log_C - alpha * sum_log_x\n        return -log_L\n\n    for case in test_cases:\n        x_min, x_max = case[\"interval\"]\n        obs = np.array(case[\"observations\"])\n\n        # 1. Filter data to be within the specified interval [x_min, x_max]\n        filtered_obs = obs[(obs >= x_min) & (obs <= x_max)]\n        \n        N = len(filtered_obs)\n        if N == 0:\n            # Handle cases with no valid data, though not expected here.\n            results.append(np.nan)\n            continue\n            \n        # 2. Pre-compute sum of logarithms\n        sum_log_x = np.sum(np.log(filtered_obs))\n\n        # 3. Minimize the negative log-likelihood function\n        # The search for alpha > 0. Bounds avoid alpha=0 and very large values.\n        res = minimize_scalar(\n            neg_log_likelihood,\n            bounds=(1e-6, 10.0),\n            args=(N, sum_log_x, x_min, x_max),\n            method='bounded'\n        )\n\n        estimated_alpha = res.x\n        results.append(estimated_alpha)\n\n    # Format output to four decimal places\n    formatted_results = [f\"{r:.4f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "当一个大额订单被执行时，价格会发生什么变化？这个实践练习将我们的焦点从订单簿的静态状态转移到其对交易活动的动态响应。你将通过估计一个非线性冲击模型的参数，来探索市场冲击——即交易对资产价格的影响——这一概念。本练习将演示如何将非线性关系转化为线性关系，以便使用普通最小二乘法（Ordinary Least Squares, OLS）进行估计，这是量化分析的基石。[@problem_id:2408364]", "id": "2408364", "problem": "您正在研究限价订单簿（LOB）中市价单的即时价格冲击。设即时市场冲击定义为执行一笔规模为 $Q$ 的市价单所引起的中间价变化，记为 $I(Q)$。在一个静态的限价订单簿中，若相对于当前中间价的单位价格位移 $u$ 的边际供给密度为连续函数 $s(u)$，则执行的交易量满足以下一致性条件\n$$\nQ \\;=\\; \\int_{0}^{I(Q)} s(u)\\,du,\n$$\n而冲击 $I(Q)$ 是消耗 $Q$ 单位流动性所需的价格位移。假设边际供给密度是 $u$ 的单调函数，并且限价订单簿在所关注的时间范围内是局部平稳的。\n\n您需要提出一个参数化冲击模型，并在合成数据上对其进行实证评估。该参数化模型为非线性幂律\n$$\nI(Q) \\;=\\; a\\,Q^{b},\n$$\n其中参数 $a>0$ 且 $b>0$。观测值受乘性噪声影响：观测冲击 $I_{\\text{obs}}(Q)$ 满足\n$$\nI_{\\text{obs}}(Q) \\;=\\; I(Q)\\,\\exp(\\varepsilon),\n$$\n其中 $\\varepsilon$ 是均值为 $0$、方差为 $\\tau^{2}$ 的独立同分布高斯噪声。\n\n任务：\n- 对于下文测试套件中描述的每个数据集，按如下方式生成合成数据：从 $[Q_{\\min},Q_{\\max}]$ 上的对数均匀分布（即 $\\log Q_{i}$ 在 $[\\log Q_{\\min},\\log Q_{\\max}]$ 上均匀分布）中抽取 $N$ 个独立的交易规模 $Q_{i}$，计算噪声 $\\varepsilon_{i}\\sim \\mathcal{N}(0,\\tau^{2})$，并设置 $I_{i,\\text{obs}}=a\\,Q_{i}^{b}\\,\\exp(\\varepsilon_{i})$。\n- 基于联合样本 $\\{(Q_{i},I_{i,\\text{obs}})\\}_{i=1}^{N}$ 和上述噪声模型所依据的有充分理由的统计学原理，设计并实现一个对 $b$ 的估计量。您的估计量必须对于严格为正的 $Q_{i}$ 和 $I_{i,\\text{obs}}$ 是良定义的，并且不应依赖于外部数据。\n- 对每个测试用例，仅输出您对该数据集的估计值 $\\hat{b}$。\n\n提供一个单一程序，执行所有测试用例并打印 $\\hat{b}$ 估计值列表。\n\n您可以使用的基础理论包括：\n- 即时市场冲击 $I(Q)$ 的定义，即在LOB中执行数量 $Q$ 所需的价格位移。\n- 积分关系 $Q=\\int_{0}^{I(Q)} s(u)\\,du$，它将消耗的深度与订单规模等同起来。\n- 在正确指定的模型下，高斯分布的性质和最大似然估计（MLE）的原理。\n- 应用于变换后的线性模型时的普通最小二乘法（OLS）回归的性质。\n\n测试套件规格：\n对每个用例，您必须使用指定的随机种子以确保可复现性。在每个元组中，参数为 $(\\text{seed}, a, b, \\tau, N, Q_{\\min}, Q_{\\max})$。\n\n- 用例A（凹冲击，低噪声，宽规模范围）：$(314159,\\, 0.5,\\, 0.6,\\, 0.05,\\, 2000,\\, 100,\\, 50000)$。\n- 用例B（近线性冲击，中等范围）：$(271828,\\, 1.2,\\, 1.0,\\, 0.05,\\, 1500,\\, 50,\\, 20000)$。\n- 用例C（强凹冲击，较高噪声，非常宽的范围）：$(424242,\\, 0.8,\\, 0.3,\\, 0.10,\\, 3000,\\, 10,\\, 100000)$。\n- 用例D（中度凹冲击，更强噪声，样本较少）：$(8675309,\\, 0.3,\\, 0.9,\\, 0.20,\\, 800,\\, 5,\\, 5000)$。\n\n以上所有符号和数字都是精确的，必须严格遵守。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按A、B、C、D顺序排列的四个估计值，以逗号分隔，并用方括号括起来。例如，输出必须如下所示\n$[\\hat{b}_{A},\\hat{b}_{B},\\hat{b}_{C},\\hat{b}_{D}]$，\n每个 $\\hat{b}$ 表示为浮点数。在打印输出中，将每个 $\\hat{b}$ 四舍五入到恰好 $6$ 位小数。\n\n不涉及物理单位或角度单位。不使用百分比。最终答案必须是浮点数。程序不得读取任何输入，必须完全自包含，并可使用指定的种子进行复现。", "solution": "该问题陈述已经过严格验证，并被确认为有效。它在科学上基于已确立的市场微观结构理论，在数学上是适定的，并为任务提供了完整而无歧义的规范。因此，我们可以着手推导和实现解决方案。\n\n该问题要求估计市场冲击的非线性幂律模型中的参数 $b$，该模型由下式给出\n$$\nI(Q) \\;=\\; a\\,Q^{b}\n$$\n观测值受到乘性的、对数正态分布的噪声的影响。对于一组规模为 $\\{Q_i\\}_{i=1}^{N}$ 的 $N$ 笔交易，其观测冲击 $\\{I_{i,\\text{obs}}\\}_{i=1}^{N}$ 由以下模型给出\n$$\nI_{i,\\text{obs}} \\;=\\; a\\,Q_{i}^{b}\\,\\exp(\\varepsilon_{i})\n$$\n其中噪声项 $\\varepsilon_{i}$ 是从均值为 $0$、方差为 $\\tau^2$ 的高斯分布中抽取的独立同分布样本，即 $\\varepsilon_{i} \\sim \\mathcal{N}(0, \\tau^2)$。\n\n为了估计这个非线性模型的参数，一种标准且有效的方法是通过对数变换将关系线性化。对观测方程两边取自然对数，可得：\n$$\n\\log(I_{i,\\text{obs}}) \\;=\\; \\log\\left(a\\,Q_{i}^{b}\\,\\exp(\\varepsilon_{i})\\right)\n$$\n利用对数的基本性质，特别是 $\\log(xyz) = \\log(x) + \\log(y) + \\log(z)$ 和 $\\log(x^k) = k\\log(x)$，我们可以展开右侧：\n$$\n\\log(I_{i,\\text{obs}}) \\;=\\; \\log(a) + \\log(Q_{i}^{b}) + \\log(\\exp(\\varepsilon_{i}))\n$$\n这可以简化为一个线性方程：\n$$\n\\log(I_{i,\\text{obs}}) \\;=\\; \\log(a) + b\\,\\log(Q_{i}) + \\varepsilon_{i}\n$$\n为将其形式化为标准的线性回归问题，我们引入以下变量变换：\n- 令 $y_i = \\log(I_{i,\\text{obs}})$ 为响应变量。\n- 令 $x_i = \\log(Q_i)$ 为预测变量。\n- 令 $\\beta_0 = \\log(a)$ 为截距项。\n- 令 $\\beta_1 = b$ 为斜率系数，这是我们感兴趣的参数。\n\n现在，该模型可以写成简单线性回归的标准形式：\n$$\ny_i \\;=\\; \\beta_0 + \\beta_1 x_i + \\varepsilon_i\n$$\n问题陈述指出，交易规模 $Q_i$ 和噪声项 $\\varepsilon_i$ 是独立生成的。因此，预测变量 $x_i = \\log(Q_i)$ 与误差项 $\\varepsilon_i$ 相互独立。误差 $\\varepsilon_i$ 是从零均值、恒定方差（$\\tau^2$）的正态分布中抽取的独立同分布样本。这些条件满足了经典线性回归模型的所有假设。\n\n在这些条件下，普通最小二乘法（OLS）估计量是参数 $\\beta_0$ 和 $\\beta_1$ 的最佳线性无偏估计量（BLUE）。此外，由于误差项服从正态分布，OLS 估计量与最大似然估计量（MLE）是等价的，而后者具有一致性和渐近有效性等优良的统计特性。\n\nOLS 方法通过最小化残差平方和（SSR）来找到参数估计值 $\\hat{\\beta}_0$ 和 $\\hat{\\beta}_1$：\n$$\n\\text{SSR} \\;=\\; \\sum_{i=1}^{N} (y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_i)^2\n$$\n斜率系数 $\\hat{\\beta}_1$ 的著名闭式解为：\n$$\n\\hat{\\beta}_1 \\;=\\; \\frac{\\sum_{i=1}^{N}(x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N}(x_i - \\bar{x})^2}\n$$\n其中 $\\bar{x} = \\frac{1}{N}\\sum_{i=1}^{N} x_i$ 和 $\\bar{y} = \\frac{1}{N}\\sum_{i=1}^{N} y_i$ 分别是预测变量和响应变量的样本均值。因此，我们对市场冲击指数的估计值 $\\hat{b}$ 就是这个估计出的斜率系数，即 $\\hat{b} = \\hat{\\beta}_1$。\n\n每个测试用例的算法流程如下：\n$1$. 数据生成：\n    - 对于由 $(\\text{seed}, a, b, \\tau, N, Q_{\\min}, Q_{\\max})$ 指定的给定测试用例，使用指定的种子初始化一个伪随机数生成器以保证可复现性。\n    - 从区间 $[Q_{\\min}, Q_{\\max}]$ 上的对数均匀分布中生成 $N$ 个交易规模 $Q_i$。这等价于从均匀分布 $\\mathcal{U}(\\log(Q_{\\min}), \\log(Q_{\\max}))$ 中抽取 $\\log(Q_i)$。\n    - 从正态分布 $\\mathcal{N}(0, \\tau^2)$ 中生成 $N$ 个噪声项 $\\varepsilon_i$。\n    - 计算合成的观测冲击 $I_{i,\\text{obs}} = a\\,Q_i^b \\exp(\\varepsilon_i)$。\n$2$. 模型估计：\n    - 通过取自然对数来转换生成的数据：$y_i = \\log(I_{i,\\text{obs}})$ 和 $x_i = \\log(Q_i)$。\n    - 构建线性系统 $\\mathbf{y} = X\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{y}$ 是 $y_i$ 值的向量，$\\boldsymbol{\\beta} = [\\beta_0, \\beta_1]^T$，$X$ 是一个 $N \\times 2$ 的设计矩阵，其第一列全为1，第二列是 $x_i$ 值的向量。\n    - 使用数值最小二乘求解器求解系数向量 $\\hat{\\boldsymbol{\\beta}}$。该向量的第二个元素 $\\hat{\\beta}_1$ 即为估计值 $\\hat{b}$。\n该方法具有坚实的统计学基础，并且在计算上是稳健的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Generates synthetic market impact data and estimates the power-law exponent 'b'\n    for a series of test cases using Ordinary Least Squares on a log-transformed model.\n    \"\"\"\n\n    # Test cases: (seed, a, b, tau, N, Q_min, Q_max)\n    # The parameters correspond to: random seed, scale parameter 'a', exponent 'b',\n    # noise standard deviation 'tau', number of samples 'N', minimum trade size 'Q_min',\n    # and maximum trade size 'Q_max'.\n    test_cases = [\n        # Case A (concave impact, low noise, wide size range)\n        (314159, 0.5, 0.6, 0.05, 2000, 100, 50000),\n        # Case B (near-linear impact, moderate range)\n        (271828, 1.2, 1.0, 0.05, 1500, 50, 20000),\n        # Case C (strongly concave, higher noise, very wide range)\n        (424242, 0.8, 0.3, 0.10, 3000, 10, 100000),\n        # Case D (moderately concave, heavier noise, fewer samples)\n        (8675309, 0.3, 0.9, 0.20, 800, 5, 5000),\n    ]\n\n    results = []\n\n    for seed, a, b, tau, N, Q_min, Q_max in test_cases:\n        # Step 1: Generate synthetic data.\n        # Initialize a random number generator with the specified seed for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Generate N trade sizes Q from a log-uniform distribution on [Q_min, Q_max].\n        # This is done by drawing from a uniform distribution in log-space.\n        log_Q = rng.uniform(np.log(Q_min), np.log(Q_max), N)\n        Q = np.exp(log_Q)\n\n        # Generate N i.i.d. Gaussian noise terms.\n        epsilon = rng.normal(loc=0.0, scale=tau, size=N)\n\n        # Compute the observed impact I_obs = a * Q^b * exp(epsilon).\n        I_obs = a * (Q ** b) * np.exp(epsilon)\n\n        # Step 2: Transform the data to linearize the model.\n        # log(I_obs) = log(a) + b*log(Q) + epsilon\n        log_I_obs = np.log(I_obs)\n\n        # Step 3: Perform Ordinary Least Squares (OLS) regression.\n        # We model log_I_obs = beta_0 + beta_1 * log_Q, where beta_1 is our estimate for b.\n        y = log_I_obs\n        x = log_Q\n\n        # Construct the design matrix X for the linear system y = X * beta.\n        # The first column is for the intercept (beta_0), the second for the slope (beta_1).\n        X = np.vstack([np.ones(N), x]).T\n\n        # Solve for the coefficient vector beta = [beta_0, beta_1] using a\n        # standard and numerically stable least-squares solver.\n        # beta[0] will be the estimate for log(a), and beta[1] for b.\n        beta, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        b_estimate = beta[1]\n        results.append(b_estimate)\n        \n    # Final print statement in the exact required format.\n    # The output must be a single line: a list of comma-separated values\n    # enclosed in square brackets, with each value rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n```"}, {"introduction": "在分析了市场特性之后，是时候成为一名积极的参与者了。这最后一个实践练习将挑战你模拟指定做市商（Designated Market Maker, DMM）的行为，这是一个为市场提供流动性的关键角色。你将使用基于主体的模拟框架，为做市商的核心困境——赚取买卖价差与管理持仓风险——进行建模。这个练习综合了报价策略、风险管理和随机过程等概念，从零开始构建一个市场主体的动态模型。[@problem_id:2408375]", "id": "2408375", "problem": "你的任务是构建一个指定做市商 (DMM) 的自洽离散时间模拟。该 DMM 在一个限价订单簿中运作，受到明确的微观结构约束和一个随机库存风险因子的影响。DMM 必须持续在订单簿的两侧进行报价，满足最大价差和最小报价量的要求，并通过执行交易来累积收入，同时承担由 Vasicek 过程驱动的库存风险惩罚。\n\n模型设定：\n\n- 时间被离散化为大小为 $\\Delta t > 0$ 的步长，由 $t \\in \\{0,1,\\ldots,T-1\\}$ 索引。\n\n- 存在一个恒定的参考中间价 $m_0 \\in \\mathbb{R}$。\n\n- DMM 必须始终在两侧使用对称的半价差 $h_t \\in \\mathbb{R}_{\\ge 0}$ 发布报价，使得总价差 $2 h_t \\le S_{\\max}$，其中 $S_{\\max} > 0$ 是规定的最大价差。DMM 的最小报价量为 $q_{\\min} \\in \\mathbb{N}$，该报价量必须在每个时间步的买入价和卖出价上同时发布。\n\n- DMM 维持一个库存 $I_t \\in \\mathbb{Z}$，初始库存为 $I_0 \\in \\mathbb{Z}$。在每个时间步，库存会因其发布的报价被执行而发生变化。\n\n- DMM 计算一个保留价格 $r_t \\in \\mathbb{R}$，该价格会根据库存和一个 Vasicek (Ornstein–Uhlenbeck) 风险因子 $X_t$ 来倾斜报价：\n  $$ r_t = m_0 - \\varphi \\, I_t \\, X_t, $$\n  其中 $\\varphi \\in \\mathbb{R}_{\\ge 0}$ 是一个给定的灵敏度参数。\n\n- 在时间 $t$ 发布的买入价和卖出价为：\n  $$ p^{\\text{bid}}_t = r_t - h_t, \\qquad p^{\\text{ask}}_t = r_t + h_t, $$\n  受约束 $2 h_t \\le S_{\\max}$ 的限制。其意图是 DMM 通过使用以下公式来遵守该约束\n  $$ h_t = \\min\\left(H, \\frac{S_{\\max}}{2}\\right), $$\n  其中 $H \\in \\mathbb{R}_{>0}$ 是一个给定的基础半价差。\n\n- 风险因子 $X_t$ 在连续时间内遵循一个 Vasicek 过程，\n  $$ dX_t = \\kappa \\, (\\theta - X_t) \\, dt + \\sigma \\, dW_t, $$\n  其中 $\\kappa \\in \\mathbb{R}_{>0}$，$\\theta \\in \\mathbb{R}$，$\\sigma \\in \\mathbb{R}_{\\ge 0}$，以及标准布朗运动 $W_t$。在步长为 $\\Delta t$ 的离散时间内，通过以下方式模拟 $X_t$\n  $$ X_{t+\\Delta t} = X_t + \\kappa \\, (\\theta - X_t) \\, \\Delta t + \\sigma \\, \\sqrt{\\Delta t} \\, Z_t, $$\n  其中 $\\{Z_t\\}$ 是独立的标准正态随机变量，并且 $X_0$ 是给定的。\n\n- 能够与 DMM 发布的报价成交的市价单到达是独立的泊松过程，其强度对于买入市价单（触及卖出价）为 $\\lambda_a \\in \\mathbb{R}_{\\ge 0}$，对于卖出市价单（触及买入价）为 $\\lambda_b \\in \\mathbb{R}_{\\ge 0}$。在一个时间步 $\\Delta t$ 内，单侧至少有一次到达的概率是\n  $$ p_a = 1 - e^{-\\lambda_a \\Delta t}, \\qquad p_b = 1 - e^{-\\lambda_b \\Delta t}. $$\n  假设在每个时间步，每一侧最多只能发生一次大小为 $q_{\\min}$ 的成交。设 $F^{\\text{ask}}_t \\in \\{0,1\\}$ 为卖方成交的指示符，$F^{\\text{bid}}_t \\in \\{0,1\\}$ 为买方成交的指示符，其中\n  $$ \\mathbb{P}(F^{\\text{ask}}_t = 1) = p_a, \\quad \\mathbb{P}(F^{\\text{bid}}_t = 1) = p_b, $$\n  并且所有随机变量在时间和买卖双方之间都是独立的。\n\n- 库存更新如下\n  $$ I_{t+1} = I_t + q_{\\min} \\, F^{\\text{bid}}_t - q_{\\min} \\, F^{\\text{ask}}_t. $$\n\n- 在时间 $t$，DMM 的已实现价差收入增量为\n  $$ \\Pi^{\\text{rev}}_t = q_{\\min} \\left( F^{\\text{ask}}_t \\, p^{\\text{ask}}_t - F^{\\text{bid}}_t \\, p^{\\text{bid}}_t \\right). $$\n\n- DMM 承担一个非负的瞬时库存风险惩罚，该惩罚通过以下方式取决于当前库存和当前风险因子\n  $$ \\rho_t = \\max(X_t, 0), \\qquad \\Pi^{\\text{risk}}_t = - \\frac{1}{2} \\, \\rho_t \\, I_t^2 \\, \\Delta t. $$\n\n- 在整个时间范围内累积的总目标为\n  $$ U = \\sum_{t=0}^{T-1} \\left( \\Pi^{\\text{rev}}_t + \\Pi^{\\text{risk}}_t \\right). $$\n\n每个时间步 $t \\in \\{0,1,\\ldots,T-1\\}$ 的模拟协议：\n\n1. 使用 $I_t$ 和 $X_t$ 计算 $r_t$；设置 $h_t = \\min(H, S_{\\max}/2)$；然后设置 $p^{\\text{bid}}_t$ 和 $p^{\\text{ask}}_t$。\n2. 分别以概率 $p_a$ 和 $p_b$ 抽取独立的 $F^{\\text{ask}}_t$ 和 $F^{\\text{bid}}_t$。\n3. 计算收入增量 $\\Pi^{\\text{rev}}_t$。\n4. 使用 $\\rho_t = \\max(X_t, 0)$ 和当前 $I_t$ 计算风险惩罚增量 $\\Pi^{\\text{risk}}_t$。\n5. 将库存更新为 $I_{t+1}$。\n6. 使用离散 Vasicek 更新和一个新的 $Z_t \\sim \\mathcal{N}(0,1)$ 来更新 $X_{t+\\Delta t}$。\n\n随机性与可复现性：\n\n- 使用以整数 2025 为种子的单个伪随机数生成器实例，并在整个模拟中按照测试用例的评估顺序以及在每个用例中按照上述指定的操作顺序重用它。\n\n测试套件：\n\n对于下面的每个参数集，模拟该过程并报告标量 $U$，结果四舍五入到六位小数。\n\n- 测试用例 A（平衡流，无约束的基础价差）：\n  - $T = 500$, $\\Delta t = 0.1$, $m_0 = 100.0$, $S_{\\max} = 0.20$, $H = 0.08$, $q_{\\min} = 1$,\n  - $\\lambda_a = 3.0$, $\\lambda_b = 3.0$,\n  - $\\kappa = 2.0$, $\\theta = 0.5$, $\\sigma = 0.5$, $X_0 = 0.5$,\n  - $\\varphi = 0.01$, $I_0 = 0$。\n\n- 测试用例 B（无到达的边缘情况）：\n  - $T = 500$, $\\Delta t = 0.1$, $m_0 = 100.0$, $S_{\\max} = 0.20$, $H = 0.08$, $q_{\\min} = 1$,\n  - $\\lambda_a = 0.0$, $\\lambda_b = 0.0$,\n  - $\\kappa = 2.0$, $\\theta = 0.5$, $\\sigma = 0.5$, $X_0 = 0.5$,\n  - $\\varphi = 0.01$, $I_0 = 0$。\n\n- 测试用例 C（紧价差上限，不平衡流，较大报价量，非零初始库存）：\n  - $T = 300$, $\\Delta t = 0.1$, $m_0 = 50.0$, $S_{\\max} = 0.20$, $H = 0.20$, $q_{\\min} = 2$,\n  - $\\lambda_a = 8.0$, $\\lambda_b = 1.0$,\n  - $\\kappa = 1.0$, $\\theta = 0.5$, $\\sigma = 0.3$, $X_0 = 0.2$,\n  - $\\varphi = 0.02$, $I_0 = 5$。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含三个结果 $[U_A, U_B, U_C]$，以逗号分隔的列表形式并用方括号括起来，每个值都四舍五入到六位小数（例如，$[12.345678,0.000000,-3.210987]$）。不应打印任何其他文本。", "solution": "问题陈述已提交以供验证。\n\n### 步骤 1：提取给定信息\n\n**模型参数：**\n-   离散时间步：$t \\in \\{0, 1, \\ldots, T-1\\}$，时长 $\\Delta t > 0$。\n-   参考中间价：$m_0 \\in \\mathbb{R}$。\n-   最大总价差：$S_{\\max} > 0$。\n-   基础半价差：$H \\in \\mathbb{R}_{>0}$。\n-   最小报价量：$q_{\\min} \\in \\mathbb{N}$。\n-   初始库存：$I_0 \\in \\mathbb{Z}$。\n-   保留价格灵敏度：$\\varphi \\in \\mathbb{R}_{\\ge 0}$。\n-   Vasicek 过程参数：$\\kappa \\in \\mathbb{R}_{>0}$，$\\theta \\in \\mathbb{R}$，$\\sigma \\in \\mathbb{R}_{\\ge 0}$。\n-   初始风险因子值：$X_0$。\n-   市价单到达强度：$\\lambda_a, \\lambda_b \\in \\mathbb{R}_{\\ge 0}$。\n\n**模型方程与逻辑：**\n-   保留价格：$r_t = m_0 - \\varphi \\, I_t \\, X_t$。\n-   半价差：$h_t = \\min\\left(H, \\frac{S_{\\max}}{2}\\right)$。\n-   发布报价：$p^{\\text{bid}}_t = r_t - h_t, \\quad p^{\\text{ask}}_t = r_t + h_t$。\n-   风险因子 $X_t$ 的离散 Vasicek 过程：$X_{t+\\Delta t} = X_t + \\kappa \\, (\\theta - X_t) \\, \\Delta t + \\sigma \\, \\sqrt{\\Delta t} \\, Z_t$，其中 $Z_t \\sim \\mathcal{N}(0,1)$。\n-   时间步 $\\Delta t$ 的成交概率：$p_a = 1 - e^{-\\lambda_a \\Delta t}, \\quad p_b = 1 - e^{-\\lambda_b \\Delta t}$。\n-   成交指示符：$F^{\\text{ask}}_t, F^{\\text{bid}}_t \\in \\{0,1\\}$，其中 $\\mathbb{P}(F^{\\text{ask}}_t = 1) = p_a$ 且 $\\mathbb{P}(F^{\\text{bid}}_t = 1) = p_b$。\n-   库存更新：$I_{t+1} = I_t + q_{\\min} \\, F^{\\text{bid}}_t - q_{\\min} \\, F^{\\text{ask}}_t$。\n-   价差收入增量：$\\Pi^{\\text{rev}}_t = q_{\\min} \\left( F^{\\text{ask}}_t \\, p^{\\text{ask}}_t - F^{\\text{bid}}_t \\, p^{\\text{bid}}_t \\right)$。\n-   库存风险惩罚增量：$\\Pi^{\\text{risk}}_t = - \\frac{1}{2} \\, \\rho_t \\, I_t^2 \\, \\Delta t$，其中 $\\rho_t = \\max(X_t, 0)$。\n-   总目标函数：$U = \\sum_{t=0}^{T-1} \\left( \\Pi^{\\text{rev}}_t + \\Pi^{\\text{risk}}_t \\right)$。\n\n**模拟协议：**\n该协议为每个时间步 $t$ 指定了严格的操作序列：\n1.  使用当前状态 $(I_t, X_t)$ 计算 $r_t$、$h_t$、$p^{\\text{bid}}_t$ 和 $p^{\\text{ask}}_t$。\n2.  抽取随机成交指示符 $F^{\\text{ask}}_t, F^{\\text{bid}}_t$。\n3.  计算收入增量 $\\Pi^{\\text{rev}}_t$。\n4.  使用当前状态 $(I_t, X_t)$ 计算风险惩罚 $\\Pi^{\\text{risk}}_t$。\n5.  将库存更新为 $I_{t+1}$。\n6.  使用一个新的随机抽取值 $Z_t$ 将风险因子更新为 $X_{t+\\Delta t}$。\n\n**可复现性：**\n-   必须使用单个伪随机数生成器 (PRNG)。\n-   PRNG 必须以整数 2025 为种子。\n-   必须根据协议，在所有测试用例中以及在每个模拟步骤内，按顺序使用 PRNG。\n\n**测试用例：**\n-   用例 A：$T = 500, \\Delta t = 0.1, m_0 = 100.0, S_{\\max} = 0.20, H = 0.08, q_{\\min} = 1, \\lambda_a = 3.0, \\lambda_b = 3.0, \\kappa = 2.0, \\theta = 0.5, \\sigma = 0.5, X_0 = 0.5, \\varphi = 0.01, I_0 = 0$。\n-   用例 B：$T = 500, \\Delta t = 0.1, m_0 = 100.0, S_{\\max} = 0.20, H = 0.08, q_{\\min} = 1, \\lambda_a = 0.0, \\lambda_b = 0.0, \\kappa = 2.0, \\theta = 0.5, \\sigma = 0.5, X_0 = 0.5, \\varphi = 0.01, I_0 = 0$。\n-   用例 C：$T = 300, \\Delta t = 0.1, m_0 = 50.0, S_{\\max} = 0.20, H = 0.20, q_{\\min} = 2, \\lambda_a = 8.0, \\lambda_b = 1.0, \\kappa = 1.0, \\theta = 0.5, \\sigma = 0.3, X_0 = 0.2, \\varphi = 0.02, I_0 = 5$。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n根据验证标准对问题进行评估。\n1.  **科学依据：** 该模型是做市商行为的一个简化但标准的表示，借鉴了计算金融和市场微观结构理论中的既定概念，例如基于库存的报价（与 Ho & Stoll、Avellaneda & Stoikov 的研究相关）以及使用 Ornstein-Uhlenbeck 过程来表示随机因子。随机过程的离散化和订单到达的建模是模拟中的标准技术。该问题在科学上是合理的。\n2.  **良构性：** 该问题是一项模拟任务。它提供了所有必要的参数、初始条件以及一个精确、顺序的执行协议。对随机数生成过程的规定，包括种子和操作顺序，确保了可以计算出唯一、确定的结果。该问题是良构的。\n3.  **客观性：** 该问题使用精确的数学和算法语言进行描述。所有术语都有形式化定义。没有主观或模糊的内容。\n4.  **缺陷检查表：** 对潜在缺陷的审查表明不存在任何缺陷。该问题并非不健全、不可形式化、不完整、矛盾、不现实或非良构。每个时间步内随机数生成的顺序由模拟协议的步骤隐式定义：市价单的随机抽取（第2步）发生在风险因子更新的随机抽取（第6步）之前。这是明确无误的。\n\n### 步骤 3：结论与行动\n\n**结论：** 该问题是 **有效的**。它是一个定义明确且具有科学依据的计算金融模拟练习。\n\n**行动：** 继续进行求解。\n\n该问题要求实现一个指定做市商（DMM）损益累积的离散时间蒙特卡洛模拟。DMM 的行为由一套报价规则控制，并受到库存风险的影响，该风险由一个外部随机因子调节。解决方案是通过算法化地执行指定的模拟协议来构建的。\n\n在任何时间步 $t$，系统的状态由 DMM 的库存 $I_t$ 和风险因子 $X_t$ 的值定义。模拟通过从初始状态 $(I_0, X_0)$ 开始，以 $\\Delta t$ 为时长，迭代 $T$ 步来进行。\n\n**DMM 策略与报价：**\n在每个时间步 $t$，DMM 计算一个*保留价格* $r_t$。这个价格是做市模型中的一个核心概念，代表了代理人对资产的内部估值，并根据其当前的风险敞口进行了调整。公式 $r_t = m_0 - \\varphi \\, I_t \\, X_t$ 将这种调整形式化。正库存 ($I_t > 0$) 加上正风险状态 ($X_t > 0$) 会降低保留价格，使 DMM 更倾向于卖出（通过降低其卖出价）而不那么倾向于买入（通过降低其买入价），从而减少其库存。参数 $\\varphi$ 决定了这种库存管理的激进程度。\n然后报价围绕该保留价格对称设置：$p^{\\text{bid}}_t = r_t - h_t$ 和 $p^{\\text{ask}}_t = r_t + h_t$。半价差 $h_t$ 在整个模拟过程中是恒定的，由 DMM 的基础价差 $H$ 决定，并受到监管最大价差 $S_{\\max}$ 的约束，即 $h_t = \\min(H, S_{\\max}/2)$。\n\n**随机动态：**\n模拟环境有两个随机性来源。\n1.  **市价单到达：** 与 DMM 报价成交的市价单的到达被建模为两个独立的泊松过程。对于一个离散时间步 $\\Delta t$，这简化为独立的伯努利试验。买入市价单触及 DMM 卖价的概率为 $p_a = 1 - e^{-\\lambda_a \\Delta t}$，卖出市价单触及买价的概率为 $p_b = 1 - e^{-\\lambda_b \\Delta t}$。在每一步，我们根据这些概率生成指示变量 $F^{\\text{ask}}_t$ 和 $F^{\\text{bid}}_t$。\n2.  **风险因子演化：** 风险因子 $X_t$ 遵循一个 Vasicek (Ornstein-Uhlenbeck) 过程，这是一个均值回归的随机过程。它的演化使用欧拉-丸山离散化进行模拟：$X_{t+\\Delta t} = X_t + \\kappa (\\theta - X_t) \\Delta t + \\sigma \\sqrt{\\Delta t} Z_t$，其中 $Z_t$ 是一个标准正态随机变量。这捕捉了一个影响 DMM 风险感知的波动外部因素。\n\n**目标函数与状态更新：**\n对于每个时间步 $t$，我们计算 DMM 总效用的增量变化。\n-   价差收入 $\\Pi^{\\text{rev}}_t = q_{\\min} ( F^{\\text{ask}}_t p^{\\text{ask}}_t - F^{\\text{bid}}_t p^{\\text{bid}}_t )$，是低买高卖的经典利润。\n-   库存风险惩罚 $\\Pi^{\\text{risk}}_t = - \\frac{1}{2} \\rho_t I_t^2 \\Delta t$，其中 $\\rho_t = \\max(X_t, 0)$，代表了持有非零库存的成本。该成本与库存规模呈二次关系，反映了风险规避，并由时变的非负风险参数 $\\rho_t$ 进行缩放。\n总效用 $U$ 是在模拟时间范围内这些增量的总和。\n\n在使用状态 $(I_t, X_t)$ 计算了步骤 $t$ 的增量后，状态将更新为 $(I_{t+1}, X_{t+1})$ 以准备下一次迭代。库存根据已实现的成交进行更新：$I_{t+1} = I_t + q_{\\min} F^{\\text{bid}}_t - q_{\\min} F^{\\text{ask}}_t$。风险因子 $X_t$ 根据其随机过程进行更新。\n\n**实现与可复现性：**\n该解决方案使用 Python 实现，遵循指定的模拟协议。为确保随机模拟的可复现性，使用种子 2025 初始化了一个伪随机数生成器的单一实例。然后，该生成器用于所有测试用例中的所有随机抽取，其顺序严格遵循协议规定：对于每个时间步 $t$，先为 $F^{\\text{ask}}_t$ 抽样，然后为 $F^{\\text{bid}}_t$ 抽样，最后为 $Z_t$ 抽样。代码计算每个测试用例的总效用 $U$ 并按要求格式报告结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params, rng):\n    \"\"\"\n    Runs a single simulation for a given parameter set and RNG.\n\n    Args:\n        params (dict): A dictionary containing all model parameters.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The total accumulated utility U.\n    \"\"\"\n    T = params['T']\n    dt = params['dt']\n    m0 = params['m0']\n    S_max = params['S_max']\n    H = params['H']\n    q_min = params['q_min']\n    lambda_a = params['lambda_a']\n    lambda_b = params['lambda_b']\n    kappa = params['kappa']\n    theta = params['theta']\n    sigma = params['sigma']\n    X0 = params['X0']\n    phi = params['phi']\n    I0 = params['I0']\n\n    # Initialize state variables\n    I_t = float(I0)\n    X_t = float(X0)\n    total_utility = 0.0\n\n    # Pre-calculate constant values\n    h_t = min(H, S_max / 2.0)\n    p_a = 1.0 - np.exp(-lambda_a * dt)\n    p_b = 1.0 - np.exp(-lambda_b * dt)\n    sqrt_dt = np.sqrt(dt)\n\n    for _ in range(T):\n        # Step 1: Compute reservation price and quotes\n        r_t = m0 - phi * I_t * X_t\n        p_ask_t = r_t + h_t\n        p_bid_t = r_t - h_t\n\n        # Step 2: Draw fill indicators\n        F_ask_t = 1 if rng.random() < p_a else 0\n        F_bid_t = 1 if rng.random() < p_b else 0\n\n        # Step 3: Compute revenue increment\n        pi_rev_t = q_min * (F_ask_t * p_ask_t - F_bid_t * p_bid_t)\n\n        # Step 4: Compute risk penalty increment\n        rho_t = max(X_t, 0.0)\n        pi_risk_t = -0.5 * rho_t * (I_t**2) * dt\n\n        # Accumulate utility\n        total_utility += pi_rev_t + pi_risk_t\n\n        # Step 5: Update inventory for the next step\n        I_t = I_t + q_min * F_bid_t - q_min * F_ask_t\n\n        # Step 6: Update risk factor for the next step\n        Z_t = rng.normal(0, 1)\n        X_t = X_t + kappa * (theta - X_t) * dt + sigma * sqrt_dt * Z_t\n        \n    return total_utility\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        {\n            'T': 500, 'dt': 0.1, 'm0': 100.0, 'S_max': 0.20, 'H': 0.08, 'q_min': 1,\n            'lambda_a': 3.0, 'lambda_b': 3.0,\n            'kappa': 2.0, 'theta': 0.5, 'sigma': 0.5, 'X0': 0.5,\n            'phi': 0.01, 'I0': 0\n        },\n        # Test case B\n        {\n            'T': 500, 'dt': 0.1, 'm0': 100.0, 'S_max': 0.20, 'H': 0.08, 'q_min': 1,\n            'lambda_a': 0.0, 'lambda_b': 0.0,\n            'kappa': 2.0, 'theta': 0.5, 'sigma': 0.5, 'X0': 0.5,\n            'phi': 0.01, 'I0': 0\n        },\n        # Test case C\n        {\n            'T': 300, 'dt': 0.1, 'm0': 50.0, 'S_max': 0.20, 'H': 0.20, 'q_min': 2,\n            'lambda_a': 8.0, 'lambda_b': 1.0,\n            'kappa': 1.0, 'theta': 0.5, 'sigma': 0.3, 'X0': 0.2,\n            'phi': 0.02, 'I0': 5\n        }\n    ]\n\n    # Initialize a single PRNG instance as required for reproducibility\n    rng = np.random.default_rng(2025)\n    \n    results = []\n    for case_params in test_cases:\n        result = run_simulation(case_params, rng)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}