{"hands_on_practices": [{"introduction": "我们的第一个实践练习旨在将 Lemke-Howson 算法的抽象概念与寻找混合策略纳什均衡的基本“无差异”原则联系起来。通过解决一个经典的 $2 \\times 2$ 博弈问题，你将亲手推导出均衡策略，并证明定义该均衡的代数方程与 Lemke-Howson 算法的互补松弛条件在本质上是等价的。这项练习 [@problem_id:2406266] 有助于建立对算法为何有效的直观理解。", "id": "2406266", "problem": "考虑一个双人有限双矩阵博弈，每个参与者有两种纯策略。行参与者的策略为 $T$ 和 $B$，列参与者的策略为 $L$ 和 $R$。行参与者的支付矩阵为\n$$\nA \\;=\\; \\begin{pmatrix}\n\\alpha & \\beta \\\\\n\\gamma & \\delta\n\\end{pmatrix},\n$$\n列参与者的支付矩阵为\n$$\nB \\;=\\; \\begin{pmatrix}\n\\mu & \\nu \\\\\n\\xi & \\zeta\n\\end{pmatrix}.\n$$\n假设该博弈是非退化的，并存在一个唯一的内部混合策略纳什均衡。在该均衡中，行参与者在 $T$ 和 $B$ 之间混合，选择 $T$ 的概率为 $p^{\\ast} \\in (0,1)$；列参与者在 $L$ 和 $R$ 之间混合，选择 $L$ 的概率为 $q^{\\ast} \\in (0,1)$。所有参数 $\\alpha, \\beta, \\gamma, \\delta, \\mu, \\nu, \\xi, \\zeta$ 均为实数，其选择需保证混合策略表达式中出现的分母非零，且最终得到的概率严格介于 $0$ 和 $1$ 之间。\n\n仅使用纳什均衡和最佳响应的定义，推导出 $p^{\\ast}$ 和 $q^{\\ast}$ 作为 $\\alpha, \\beta, \\gamma, \\delta, \\mu, \\nu, \\xi, \\zeta$ 函数的代数表达式。然后，通过构建在完全标记顶点上成立的互补松弛等式，证明由用于双矩阵博弈的 Lemke–Howson (LH) 算法生成的枢轴等式与定义此 $2 \\times 2$ 情形下内部混合策略纳什均衡的无差异条件相一致。\n\n以最简形式给出 $p^{\\ast}$ 的封闭形式表达式作为你的最终答案。请勿对结果进行近似。", "solution": "所述问题是有效的。它在科学上基于已建立的博弈论，问题设定良好，具备唯一解的充分条件，并以客观的数学语言表述。所有给定条件对于完成所需任务都是一致和完备的。\n\n给定一个 $2 \\times 2$ 双矩阵博弈。行参与者的策略是 $T$ (上) 和 $B$ (下)，列参与者的策略是 $L$ (左) 和 $R$ (右)。支付矩阵为：\n行参与者：$A = \\begin{pmatrix} \\alpha & \\beta \\\\ \\gamma & \\delta \\end{pmatrix}$\n列参与者：$B = \\begin{pmatrix} \\mu & \\nu \\\\ \\xi & \\zeta \\end{pmatrix}$\n\n问题陈述，存在一个唯一的内部混合策略纳什均衡 (MSNE)。设行参与者的策略为 $\\{T, B\\}$ 上的概率分布 $p = (p_1, p_2)$，列参与者的策略为 $\\{L, R\\}$ 上的概率分布 $q = (q_1, q_2)$。均衡策略记为 $(p^*, q^*)$。内部均衡意味着所有概率都严格介于 $0$ 和 $1$ 之间。我们定义 $p^* \\equiv p_1^*$ 为行参与者选择策略 $T$ 的概率，因此 $p_2^* = 1-p^*$。类似地，$q^* \\equiv q_1^*$ 是列参与者选择策略 $L$ 的概率，因此 $q_2^* = 1-q^*$。条件为 $p^* \\in (0,1)$ 和 $q^* \\in (0,1)$。\n\n**第一部分：从无差异条件推导均衡策略**\n\n混合策略纳什均衡的定义是：在给定对手策略的情况下，每个参与者对于所有以正概率使用的纯策略都持无差异态度。\n\n为使行参与者愿意在 $T$ 和 $B$ 之间混合，在给定列参与者策略 $q^*$ 的情况下，其选择 $T$ 的期望支付必须等于其选择 $B$ 的期望支付。\n\n行参与者选择 $T$ 的期望支付为 $E_R(T, q^*) = \\alpha q^* + \\beta(1-q^*)$。\n行参与者选择 $B$ 的期望支付为 $E_R(B, q^*) = \\gamma q^* + \\delta(1-q^*)$。\n行参与者的无差异条件是 $E_R(T, q^*) = E_R(B, q^*)$：\n$$\n\\alpha q^* + \\beta(1-q^*) = \\gamma q^* + \\delta(1-q^*)\n$$\n$$\nq^*(\\alpha - \\beta) + \\beta = q^*(\\gamma - \\delta) + \\delta\n$$\n$$\nq^*(\\alpha - \\beta - \\gamma + \\delta) = \\delta - \\beta\n$$\n求解 $q^*$：\n$$\nq^* = \\frac{\\delta - \\beta}{\\alpha - \\beta - \\gamma + \\delta}\n$$\n问题陈述中说明分母非零。\n\n类似地，为使列参与者愿意在 $L$ 和 $R$ 之间混合，在给定行参与者策略 $p^*$ 的情况下，其选择 $L$ 的期望支付必须等于其选择 $R$ 的期望支付。\n\n列参与者选择 $L$ 的期望支付为 $E_C(p^*, L) = \\mu p^* + \\xi(1-p^*)$。\n列参与者选择 $R$ 的期望支付为 $E_C(p^*, R) = \\nu p^* + \\zeta(1-p^*)$。\n列参与者的无差异条件是 $E_C(p^*, L) = E_C(p^*, R)$：\n$$\n\\mu p^* + \\xi(1-p^*) = \\nu p^* + \\zeta(1-p^*)\n$$\n$$\np^*(\\mu - \\xi) + \\xi = p^*(\\nu - \\zeta) + \\zeta\n$$\n$$\np^*(\\mu - \\xi - \\nu + \\zeta) = \\zeta - \\xi\n$$\n求解 $p^*$：\n$$\np^* = \\frac{\\zeta - \\xi}{\\mu - \\xi - \\nu + \\zeta}\n$$\n同样，假设分母非零。\n\n**第二部分：与 Lemke-Howson 算法的联系**\n\nLemke-Howson (LH) 算法是一种用于寻找双矩阵博弈中纳什均衡的枢轴变换法。它通过求解一个相关的线性互补问题 (LCP) 来运作。对于一个大小为 $m \\times n$ (此处 $m=n=2$) 的双矩阵博弈 $(A, B)$，LCP 使用未归一化的策略向量 $x \\in \\mathbb{R}^m$和 $y \\in \\mathbb{R}^n$ 来构建。如果一对 $(x, y)$ 在归一化后满足最佳响应条件，则它对应一个纳什均衡。\n\nLH 算法所求解的 LCP 构建等价于寻找满足以下互补松弛条件系统的非负向量 $x=(x_1, x_2)^T$ 和 $y=(y_1, y_2)^T$：\n对于行参与者，其策略为 $i \\in \\{1, 2\\}$：\n$$\nx_i \\ge 0 \\quad \\text{且} \\quad (B^T x)_j \\le 1 \\quad \\forall j \\in \\{1, 2\\}\n$$\n$$\ny_j \\left( 1 - (B^T x)_j \\right) = 0 \\quad \\forall j \\in \\{1, 2\\}\n$$\n对于列参与者，其策略为 $j \\in \\{1, 2\\}$：\n$$\ny_j \\ge 0 \\quad \\text{且} \\quad (A y)_i \\le 1 \\quad \\forall i \\in \\{1, 2\\}\n$$\n$$\nx_i \\left( 1 - (A y)_i \\right) = 0 \\quad \\forall i \\in \\{1, 2\\}\n$$\n由 LH 算法找到的完全标记顶点对应一个纳什均衡。问题指定了一个唯一的内部 MSNE，这意味着归一化后的均衡策略 $p^*$ 和 $q^*$ 的所有分量都严格为正。这意味着相应的未归一化策略向量 $x$ 和 $y$ 也必须所有分量都严格为正：$x_1 > 0$，$x_2 > 0$，$y_1 > 0$，$y_2 > 0$。\n\n基于此假设，我们可以分析互补松弛条件。\n由于 $x_1 > 0$ 且 $x_2 > 0$，条件 $x_i(1 - (Ay)_i) = 0$ 强制要求松弛量必须为零：\n$$\n1 - (A y)_1 = 0 \\implies \\alpha y_1 + \\beta y_2 = 1\n$$\n$$\n1 - (A y)_2 = 0 \\implies \\gamma y_1 + \\delta y_2 = 1\n$$\n令这两个表达式相等，得到：\n$$\n\\alpha y_1 + \\beta y_2 = \\gamma y_1 + \\delta y_2\n$$\n未归一化的向量 $x$ 和 $y$ 通过归一化与概率向量 $p^*$ 和 $q^*$ 相关联：$q_1^*=q^* = \\frac{y_1}{y_1+y_2}$ 以及 $q_2^*=1-q^* = \\frac{y_2}{y_1+y_2}$。将上述等式两边同时除以总和（非零）$y_1+y_2$ 得到：\n$$\n\\alpha\\left(\\frac{y_1}{y_1+y_2}\\right) + \\beta\\left(\\frac{y_2}{y_1+y_2}\\right) = \\gamma\\left(\\frac{y_1}{y_1+y_2}\\right) + \\delta\\left(\\frac{y_2}{y_1+y_2}\\right)\n$$\n$$\n\\alpha q^* + \\beta (1-q^*) = \\gamma q^* + \\delta (1-q^*)\n$$\n这恰好是第一部分中为行参与者推导出的无差异条件。\n\n类似地，由于 $y_1 > 0$ 且 $y_2 > 0$，条件 $y_j(1 - (B^T x)_j) = 0$ 强制要求松弛量必须为零：\n$$\n1 - (B^T x)_1 = 0 \\implies \\mu x_1 + \\xi x_2 = 1\n$$\n$$\n1 - (B^T x)_2 = 0 \\implies \\nu x_1 + \\zeta x_2 = 1\n$$\n令二者相等，得到：\n$$\n\\mu x_1 + \\xi x_2 = \\nu x_1 + \\zeta x_2\n$$\n用 $x_1+x_2$ 进行归一化，其中 $p_1^*=p^* = \\frac{x_1}{x_1+x_2}$ 且 $p_2^*=1-p^* = \\frac{x_2}{x_1+x_2}$，得到：\n$$\n\\mu p^* + \\xi (1-p^*) = \\nu p^* + \\zeta (1-p^*)\n$$\n这就是列参与者的无差异条件。\n\n因此，我们证明了，在 Lemke-Howson 算法中，与一个内部纳什均衡相对应的完全标记顶点上成立的等式，在数学上等价于用来定义和计算该均衡的无差异条件。LH 算法的枢轴运算是求解该方程组的一个系统性过程。", "answer": "$$\n\\boxed{\\frac{\\zeta - \\xi}{\\mu - \\xi - \\nu + \\zeta}}\n$$"}, {"introduction": "在建立了理论基础之后，下一个练习将带你深入算法的机械运作过程。在这个问题中，你需要在给定的 $3 \\times 3$ 对称博弈中，从一个特定的起始点出发，一步步追踪 Lemke-Howson 算法的枢轴变换路径。这个具体案例 [@problem_id:2406279] 不仅能巩固你对标记、枢轴变换和路径追踪的理解，还能揭示算法的一个重要特性：初始选择会影响最终找到哪个纳什均衡。", "id": "2406279", "problem": "考虑以下对称双矩阵博弈，其中行局中人的支付矩阵为\n$$\nA \\;=\\; \\begin{pmatrix}\n1 & 5 & 0\\\\\n5 & 1 & 3\\\\\n0 & 0 & 4\n\\end{pmatrix},\n$$\n列局中人的支付矩阵为 $A^{\\top}$。该博弈是对称的，即列局中人的支付是行局中人支付的转置，并且在 $(3,3)$ 处存在一个对称的纯纳什均衡。\n\n将 Lemke–Howson (LH) 算法（Lemke–Howson）应用于该双矩阵博弈，从人造均衡点开始，丢弃对应于行局中人纯策略 $1$ 的缺失标签（即行局中人最佳响应多胞体上 $x_{1}=0$ 的标签）。遵循标准的 LH 标签约定：在行局中人的最佳响应多胞体上，标签 $1,2,3$ 对应于 $x_{1}=0, x_{2}=0, x_{3}=0$，标签 $4,5,6$ 对应于由列局中人引起的支付约束 $(A x)_{1}=1$, $(A x)_{2}=1$, $(A x)_{3}=1$ 的紧致性；对称地，在列局中人的最佳响应多胞体上，标签 $1,2,3$ 对应于 $(A^{\\top} y)_{1}=1$, $(A^{\\top} y)_{2}=1$, $(A^{\\top} y)_{3}=1$ 的紧致性，标签 $4,5,6$ 对应于 $y_{1}=0$, $y_{2}=0$, $y_{3}=0$。\n\n当 LH 算法在某个完全标记对处终止时，解释其支撑集以获得潜在的纳什均衡。计算在此起始标签下，由 LH 算法选出的均衡点处行局中人的期望支付。请以单个精确实数（不四舍五入）的形式提供您的答案。", "solution": "问题陈述已经过评估，并被确定为有效。这是一个计算博弈论中适定的问题，提供了所有必要的数据、一个明确的目标和一条具体的算法路径。该问题具有科学依据、客观且内部一致。我们现在开始进行解答。\n\n问题要求将 Lemke-Howson 算法应用于一个对称双矩阵博弈，其行局中人的支付矩阵为 $A$，列局中人的支付矩阵为 $B = A^{\\top}$，其中\n$$\nA = \\begin{pmatrix} 1 & 5 & 0 \\\\ 5 & 1 & 3 \\\\ 0 & 0 & 4 \\end{pmatrix}\n$$\n标准的 Lemke-Howson 算法适用于支付矩阵严格为正的博弈。给定的矩阵 $A$ 包含零元素。为了解决这个问题，我们可以给 $A$ 中的每个元素加上一个常数 $k$，得到一个新矩阵 $A' = A + k \\cdot J$，其中 $J$ 是全一矩阵。这种变换不改变纳什均衡的集合；它只是将每个局中人的期望支付移动了 $k$。我们选择 $k=1$，这使得新矩阵的所有元素都为正。\n$$\nA' = A + 1 \\cdot J = \\begin{pmatrix} 1 & 5 & 0 \\\\ 5 & 1 & 3 \\\\ 0 & 0 & 4 \\end{pmatrix} + \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix} = \\begin{pmatrix} 2 & 6 & 1 \\\\ 6 & 2 & 4 \\\\ 1 & 1 & 5 \\end{pmatrix}\n$$\n列局中人的新支付矩阵是 $B' = (A')^{\\top}$。由于 $A$ 是对称的， $A'$ 也是对称的，因此 $B' = A'$。\n\nLemke-Howson 算法通过遍历两个多胞体的顶点来搜索纳什均衡。对于一个支付经过伸缩以使总和为 $1$ 的博弈，这些多胞体是为行局中人（策略向量 $x$）和列局中人（策略向量 $y$）定义的。设未归一化的策略向量为 $\\bar{x}$ 和 $\\bar{y}$。\n行局中人的多胞体，我们记为 $P_x$，由满足以下条件的向量集合 $\\bar{x} \\in \\mathbb{R}^3$ 给出：\n$$\nA' \\bar{x} \\le \\mathbf{1}, \\quad \\bar{x} \\ge \\mathbf{0}\n$$\n其中 $\\mathbf{1}$ 是一个全一的列向量。列局中人的多胞体 $P_y$ 由满足以下条件的 $\\bar{y} \\in \\mathbb{R}^3$ 定义：\n$$\n(A')^{\\top} \\bar{y} \\le \\mathbf{1}, \\quad \\bar{y} \\ge \\mathbf{0}\n$$\n由于 $A'$ 是对称的，$P_x$ 和 $P_y$ 是由以下不等式定义的相同多胞体：\n$$\n\\begin{cases}\n2z_1 + 6z_2 + z_3 \\le 1 \\\\\n6z_1 + 2z_2 + 4z_3 \\le 1 \\\\\nz_1 + z_2 + 5z_3 \\le 1 \\\\\nz_1 \\ge 0, z_2 \\ge 0, z_3 \\ge 0\n\\end{cases}\n$$\n其中 $z$ 代表 $\\bar{x}$ 或 $\\bar{y}$。\n\n标签约定已在问题中指定。对于这个 $3 \\times 3$ 的博弈，我们有 $6$ 个标签。\n对于一个顶点 $\\bar{x} \\in P_x$，如果对应的不等式是紧的（即等式），则存在一个标签：\n- 标签 $1$：$x_1 = 0$\n- 标签 $2$：$x_2 = 0$\n- 标签 $3$：$x_3 = 0$\n- 标签 $4$：$(A'\\bar{x})_1 = 2\\bar{x}_1 + 6\\bar{x}_2 + \\bar{x}_3 = 1$\n- 标签 $5$：$(A'\\bar{x})_2 = 6\\bar{x}_1 + 2\\bar{x}_2 + 4\\bar{x}_3 = 1$\n- 标签 $6$：$(A'\\bar{x})_3 = \\bar{x}_1 + \\bar{x}_2 + 5\\bar{x}_3 = 1$\n\n对于一个顶点 $\\bar{y} \\in P_y$，标签如下：\n- 标签 $1$：$((A')^{\\top}\\bar{y})_1 = 2\\bar{y}_1 + 6\\bar{y}_2 + \\bar{y}_3 = 1$\n- 标签 $2$：$((A')^{\\top}\\bar{y})_2 = 6\\bar{y}_1 + 2\\bar{y}_2 + 4\\bar{y}_3 = 1$\n- 标签 $3$：$((A')^{\\top}\\bar{y})_3 = \\bar{y}_1 + \\bar{y}_2 + 5\\bar{y}_3 = 1$\n- 标签 $4$：$y_1 = 0$\n- 标签 $5$：$y_2 = 0$\n- 标签 $6$：$y_3 = 0$\n\n算法从“人造均衡点” $(\\bar{x}^{(0)}, \\bar{y}^{(0)}) = ((0,0,0), (0,0,0))$ 开始。\n在 $\\bar{x}^{(0)} = (0,0,0)$ 处，紧约束是 $\\bar{x}_1=0, \\bar{x}_2=0, \\bar{x}_3=0$。该顶点的标签集是 $L(\\bar{x}^{(0)}) = \\{1, 2, 3\\}$。\n在 $\\bar{y}^{(0)} = (0,0,0)$ 处，紧约束是 $\\bar{y}_1=0, \\bar{y}_2=0, \\bar{y}_3=0$。标签集是 $L(\\bar{y}^{(0)}) = \\{4, 5, 6\\}$。\n对 $(\\bar{x}^{(0)}, \\bar{y}^{(0)})$ 的组合标签是 $\\{1, 2, 3, 4, 5, 6\\}$。这是一个完全标记的顶点对。\n\n算法通过丢弃一个指定的标签并沿着一条边路径进行遍历，直到找到另一个完全标记对（一个纳什均衡）。问题陈述我们必须丢弃对应于行局中人纯策略 $1$ 的标签，即标签 $1$ ($x_1=0$）。\n\n要从 $\\bar{x}^{(0)}$ 中丢弃标签 $1$，我们必须离开超平面 $\\bar{x}_1=0$。我们通过增加 $\\bar{x}_1$ 进行枢轴转动，同时保持其他非基变量（$\\bar{x}_2, \\bar{x}_3$）为 $0$。我们沿着这条边移动，直到一个新的约束变为紧约束。对 $\\bar{x}_1$ 的约束是：\n- $2\\bar{x}_1 \\le 1 \\implies \\bar{x}_1 \\le \\frac{1}{2}$\n- $6\\bar{x}_1 \\le 1 \\implies \\bar{x}_1 \\le \\frac{1}{6}$\n- $1\\bar{x}_1 \\le 1 \\implies \\bar{x}_1 \\le 1$\n最严格的约束是 $\\bar{x}_1 \\le \\frac{1}{6}$，它源于 $(A'\\bar{x})_2=1$。这对应于标签 $5$。\n行局中人的新顶点是 $\\bar{x}^{(1)} = (1/6, 0, 0)$。在此顶点处，紧约束是 $\\bar{x}_2=0$（标签 $2$）、$\\bar{x}_3=0$（标签 $3$）和 $(A'\\bar{x})_2=1$（标签 $5$）。标签集是 $L(\\bar{x}^{(1)}) = \\{2, 3, 5\\}$。如预期那样，标签 $1$ 被丢弃，标签 $5$ 被拾起。\n\n当前的顶点对是 $(\\bar{x}^{(1)}, \\bar{y}^{(0)})$。组合标签集是 $L(\\bar{x}^{(1)}) \\cup L(\\bar{y}^{(0)}) = \\{2, 3, 5\\} \\cup \\{4, 5, 6\\} = \\{2, 3, 4, 5, 6\\}$。标签 $1$ 缺失，标签 $5$ 重复。\n\n下一步是从另一个多胞体 $P_y$ 中移除重复的标签 $5$。$P_y$ 上的标签 $5$ 对应于约束 $\\bar{y}_2=0$。要丢弃此标签，我们必须通过增加 $\\bar{y}_2$ 来离开超平面 $\\bar{y}_2=0$，同时保持 $\\bar{y}_1=0$ 和 $\\bar{y}_3=0$。对 $\\bar{y}_2$ 的约束是：\n- $((A')^{\\top}\\bar{y})_1 = 6\\bar{y}_2 \\le 1 \\implies \\bar{y}_2 \\le \\frac{1}{6}$\n- $((A')^{\\top}\\bar{y})_2 = 2\\bar{y}_2 \\le 1 \\implies \\bar{y}_2 \\le \\frac{1}{2}$\n- $((A')^{\\top}\\bar{y})_3 = 1\\bar{y}_2 \\le 1 \\implies \\bar{y}_2 \\le 1$\n最严格的约束是 $\\bar{y}_2 \\le \\frac{1}{6}$，它源于 $((A')^{\\top}\\bar{y})_1=1$。这对应于标签 $1$。\n列局中人的新顶点是 $\\bar{y}^{(1)} = (0, 1/6, 0)$。在此顶点处，紧约束是 $\\bar{y}_1=0$（标签 $4$）、$\\bar{y}_3=0$（标签 $6$）和 $((A')^{\\top}\\bar{y})_1=1$（标签 $1$）。标签集是 $L(\\bar{y}^{(1)}) = \\{1, 4, 6\\}$。标签 $5$ 被丢弃，标签 $1$ 被拾起。\n\n新的顶点对是 $(\\bar{x}^{(1)}, \\bar{y}^{(1)}) = ((1/6, 0, 0), (0, 1/6, 0))$。组合标签集是 $L(\\bar{x}^{(1)}) \\cup L(\\bar{y}^{(1)}) = \\{2, 3, 5\\} \\cup \\{1, 4, 6\\} = \\{1, 2, 3, 4, 5, 6\\}$。\n这又是一个完全标记对，因此算法终止。该对对应于博弈的一个纳什均衡。\n\n未归一化的策略向量是 $\\bar{x} = (1/6, 0, 0)$ 和 $\\bar{y} = (0, 1/6, 0)$。归一化的混合策略 $x$ 和 $y$ 是通过将这些向量除以其分量之和得到的。\n$x = \\frac{\\bar{x}}{\\sum_i \\bar{x}_i} = \\frac{(1/6, 0, 0)}{1/6} = (1, 0, 0)$\n$y = \\frac{\\bar{y}}{\\sum_j \\bar{y}_j} = \\frac{(0, 1/6, 0)}{1/6} = (0, 1, 0)$\n这对应于纯策略组合，其中行局中人选择策略 $1$，列局中人选择策略 $2$。\n\n问题要求计算在此均衡点处行局中人的期望支付。这由原始支付矩阵的元素 $A_{12}$ 给出。\nPayoff$_{row} = x^{\\top} A y = (1, 0, 0) \\begin{pmatrix} 1 & 5 & 0 \\\\ 5 & 1 & 3 \\\\ 0 & 0 & 4 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = 5$。\n\n另外，原始博弈中行局中人的期望支付可以根据 LH 算法在平移后的博弈上的结果来计算。在矩阵为 $A'$ 的博弈中，行局中人的支付为 $u' = 1 / (\\sum_j \\bar{y}_j) = 1/(1/6) = 6$。为了找到原始博弈（矩阵为 $A$）中的支付 $u$，我们减去我们添加的常数 $k$。\n$u = u' - k = 6 - 1 = 5$。\n两种方法得到相同的结果。", "answer": "$$\n\\boxed{5}\n$$"}, {"introduction": "最后一个练习是本章的终极挑战，它将引导你从手动计算过渡到完整的计算实现。你将编写自己的 Lemke-Howson 求解器，这不仅是对你理解的终极考验，也展示了该算法在自动化分析中的强大威力。通过对均衡进行扰动并测试其稳定性 [@problem_id:2406288]，这项练习进一步展示了如何将这种计算工具应用于计算经济学中更高级的研究问题。", "id": "2406288", "problem": "您需要编写一个完整的程序，用以实现计算有限二人双矩阵博弈中纳什均衡的 Lemke–Howson 算法，并用该程序研究计算出的均衡在微小支付扰动下的局部稳定性。该程序必须是自包含的，能对给定的测试套件产生结果，并按规定打印单行聚合输出。\n\n一个有限二人双矩阵博弈由两个支付矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{m \\times n}$ 定义，其中 $m \\in \\mathbb{N}$ 和 $n \\in \\mathbb{N}$ 分别表示行参与者和列参与者的纯策略数量。行（列）参与者的混合策略是一个向量 $x \\in \\Delta_m$（$y \\in \\Delta_n$），其中 $\\Delta_k := \\{ z \\in \\mathbb{R}^k_{\\ge 0} : \\mathbf{1}^\\top z = 1 \\}$ 且 $\\mathbf{1}$ 是一个维度适当的全1向量。一对策略 $(x^\\star,y^\\star)$ 是一个纳什均衡，如果每个参与者的策略都是对对方策略的最佳响应，即在给定对手的混合策略下，每个获得正概率的纯策略都能产生最大的期望支付。\n\nLemke–Howson 算法是一种定义在多面体上的路径跟踪枢轴算法\n$$\nP := \\{ x \\in \\mathbb{R}^m_{\\ge 0} : B^\\top x \\le \\mathbf{1} \\}, \\quad\nQ := \\{ y \\in \\mathbb{R}^n_{\\ge 0} : A y \\le \\mathbf{1} \\}.\n$$\n一个顶点 $x \\in P$ 的标签由其紧不等式对应的索引确定：对于每个 $i \\in \\{1,\\dots,m\\}$，如果 $x_i = 0$，则标签 $i$ 存在；对于每个 $j \\in \\{1,\\dots,n\\}$，如果 $(B^\\top x)_j = 1$，则标签 $m+j$ 存在。类似地，一个顶点 $y \\in Q$ 的标签为 $m+j$（如果 $y_j = 0$）和标签 $i$（如果 $(A y)_i = 1$）。互补对是一对顶点 $(x,y)$，使得 $\\{1,\\dots,m+n\\}$ 中的每个标签在 $x$ 和 $y$ 的标签中总共只出现一次。对于严格为正的支付，任何互补对 $(x,y)$ 都可以通过归一化确定一个纳什均衡：\n$$\n\\hat{x} = \\frac{x}{\\mathbf{1}^\\top x}, \\qquad \\hat{y} = \\frac{y}{\\mathbf{1}^\\top y}.\n$$\n\n您必须从一个指定的缺失标签 $k \\in \\{1,\\dots,m+n\\}$ 开始，实现 Lemke–Howson 算法。实现时，仅使用 $P$ 和 $Q$ 作为线性系统的基本表示\n$$\nB^\\top x + s = \\mathbf{1}, \\quad s \\in \\mathbb{R}^n_{\\ge 0}, \\qquad\nA y + r = \\mathbf{1}, \\quad r \\in \\mathbb{R}^m_{\\ge 0},\n$$\n并采用标准的高斯-若尔当枢轴变换和最小比率规则，以保证每一步中基变量的非负性。路径跟踪必须通过对标签重复的变量进行枢轴变换，在对应于 $P$ 和 $Q$ 的两个单纯形表之间交替进行，当重复的标签等于最初丢弃的标签时终止。\n\n为给定博弈 $(A,B)$ 计算出一个纳什均衡 $(\\hat{x},\\hat{y})$ 后，您必须通过添加指定的幅度和零均值的独立均匀扰动，将支付扰动为 $(\\tilde{A},\\tilde{B})$，并使用相同的算法和起始标签重新计算一个均衡 $(\\tilde{x},\\tilde{y})$。通过 $\\ell_1$ 距离来量化局部稳定性\n$$\nd := \\|\\hat{x} - \\tilde{x}\\|_1 + \\|\\hat{y} - \\tilde{y}\\|_1,\n$$\n如果 $d \\le \\tau$（其中 $\\tau > 0$ 是一个给定的阈值），则将该均衡分类为“稳定”(stable)。所有矩阵必须严格为正，以确保 $P$ 和 $Q$ 的有界性；如果扰动产生了非正项，则应将整个矩阵加上一个非负常数，使所有项都严格为正。\n\n您的程序必须：\n- 在由 $B^\\top x + s = \\mathbf{1}$ 和 $A y + r = \\mathbf{1}$ 定义的两个单纯形表上，从指定的缺失标签 $k$ 开始，实现 Lemke–Howson 枢轴变换程序，并为严格为正的 $(A,B)$ 返回一个均衡 $(\\hat{x},\\hat{y})$。\n- 使用指定的随机种子和幅度 $\\delta > 0$ 生成扰动，对 $A$ 和 $B$ 的每个条目使用 $[-\\delta, \\delta]$ 中的独立均匀噪声。\n- 将稳定性决策计算为 $d \\le \\tau$ 的布尔值。\n\n测试套件：\n为以下三个测试用例提供结果。每个用例都指定了如何构造 $(A,B)$、扰动幅度 $\\delta$、阈值 $\\tau$、起始缺失标签 $k$ 以及用于该用例中任何随机生成的随机种子 $\\sigma$（既用于需要时生成 $(A,B)$，也用于抽取扰动）。对于“随机”用例，从 $[a,b]$ 上的均匀分布中独立同分布地生成 $A$ 和 $B$，$a=0.1$，$b=1.5$。\n\n- 案例 1 (随机正常路径)：$m = 2$, $n = 2$, 随机博弈，种子 $\\sigma = 123$, 扰动幅度 $\\delta = 0.01$, 阈值 $\\tau = 0.10$, 起始缺失标签 $k = 1$。\n- 案例 2 (随机中等规模)：$m = 3$, $n = 3$, 随机博弈，种子 $\\sigma = 7$, 扰动幅度 $\\delta = 0.005$, 阈值 $\\tau = 0.10$, 起始缺失标签 $k = 1$。\n- 案例 3 (显式近纯均衡)：$m = 3$, $n = 3$, 矩阵\n$$\nA = \\begin{bmatrix}\n3.0 & 0.3 & 0.3 \\\\\n0.3 & 3.0 & 0.3 \\\\\n0.3 & 0.3 & 3.0\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n3.0 & 0.3 & 0.3 \\\\\n0.3 & 3.0 & 0.3 \\\\\n0.3 & 0.3 & 3.0\n\\end{bmatrix},\n$$\n扰动幅度 $\\delta = 0.02$, 阈值 $\\tau = 0.20$, 起始缺失标签 $k = 1$, 随机种子 $\\sigma = 999$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述用例的顺序排列结果，其中每个条目等于该用例的布尔稳定性分类。例如，输出必须类似于\n$$\n[\\text{True},\\text{False},\\text{True}],\n$$\n但使用与您的计算相对应的实际布尔值。\n\n不涉及物理单位或角度单位。所有输出必须是布尔值。程序不得读取任何输入，并且必须能按原样运行。除了 Python 标准库之外，唯一允许的库是 NumPy 和 Scientific Python 库；但是，您的解决方案必须完全自包含，并且不得依赖于互联网访问或外部文件。", "solution": "问题已经过验证。\n\n### 步骤 1：提取已知条件\n- **博弈定义**：一个双矩阵博弈由两个支付矩阵定义，$A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{m \\times n}$。\n- **混合策略**：行参与者的策略是 $x \\in \\Delta_m = \\{ z \\in \\mathbb{R}^m_{\\ge 0} : \\mathbf{1}^\\top z = 1 \\}$。列参与者的策略是 $y \\in \\Delta_n = \\{ z \\in \\mathbb{R}^n_{\\ge 0} : \\mathbf{1}^\\top z = 1 \\}$。\n- **Lemke-Howson 多面体**：$P := \\{ x \\in \\mathbb{R}^m_{\\ge 0} : B^\\top x \\le \\mathbf{1} \\}$ 和 $Q := \\{ y \\in \\mathbb{R}^n_{\\ge 0} : A y \\le \\mathbf{1} \\}$。\n- **标签**：$P$ 或 $Q$ 的一个顶点由在该顶点处为紧的那些不等式的索引来标记。对于 $x \\in P$，如果 $x_i = 0$，则存在标签 $i \\in \\{1,\\dots,m\\}$；如果 $(B^\\top x)_j = 1$，则存在标签 $m+j$。对于 $y \\in Q$，如果 $y_j = 0$，则存在标签 $m+j$；如果 $(A y)_i = 1$，则存在标签 $i$。\n- **互补对与均衡**：一对顶点 $(x,y)$ 如果其标签的并集是 $\\{1,\\dots,m+n\\}$ 且无重复，则为互补对。对于严格为正的 $A,B$，一个互补对通过归一化产生一个纳什均衡 $(\\hat{x}, \\hat{y})$：$\\hat{x} = x/(\\mathbf{1}^\\top x)$，$\\hat{y} = y/(\\mathbf{1}^\\top y)$。\n- **算法**：Lemke-Howson 算法将使用系统 $B^\\top x + s = \\mathbf{1}$ ($s \\ge 0$) 和 $A y + r = \\mathbf{1}$ ($r \\ge 0$) 的单纯形表来实现。算法通过丢弃一个标签 $k \\in \\{1,\\dots,m+n\\}$ 开始，并通过在两个单纯形表之间交替进行枢轴变换来跟踪一条路径。当离基标签等于初始标签 $k$ 时终止。枢轴变换使用高斯-若尔当消元法和最小比率规则。\n- **稳定性分析**：\n    1.  为给定的博弈 $(A,B)$ 和起始标签 $k$ 计算一个纳什均衡 $(\\hat{x}, \\hat{y})$。\n    2.  通过为给定幅度 $\\delta$ 和随机种子 $\\sigma$ 添加来自 $[-\\delta, \\delta]$ 的独立同分布均匀噪声，创建一个扰动博弈 $(\\tilde{A}, \\tilde{B})$。\n    3.  如果 $\\tilde{A}$ 或 $\\tilde{B}$ 具有非正项，必须通过加上一个非负常数使其变为严格为正。\n    4.  使用相同的起始标签 $k$ 为 $(\\tilde{A}, \\tilde{B})$ 计算新的均衡 $(\\tilde{x}, \\tilde{y})$。\n    5.  计算稳定性度量 $d = \\|\\hat{x} - \\tilde{x}\\|_1 + \\|\\hat{y} - \\tilde{y}\\|_1$。\n    6.  如果 $d \\le \\tau$（对于给定的阈值 $\\tau$），将均衡分类为稳定。\n- **测试用例**：\n    - 案例 1：$m=2, n=2$，来自 $U[0.1, 1.5]$ 的随机博弈，种子 $\\sigma=123$，$\\delta=0.01$，$\\tau=0.10$，$k=1$。\n    - 案例 2：$m=3, n=3$，来自 $U[0.1, 1.5]$ 的随机博弈，种子 $\\sigma=7$，$\\delta=0.005$，$\\tau=0.10$，$k=1$。\n    - 案例 3：$m=3, n=3$，特定矩阵 $A=B$，对角线项为 $3.0$，非对角线项为 $0.3$，$\\delta=0.02$，$\\tau=0.20$，$k=1$，种子 $\\sigma=999$。\n- **输出**：一个单行的逗号分隔列表，包含布尔稳定性分类，例如 `[True,False,True]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题陈述进行评估。\n- **科学依据**：该问题基于 Lemke-Howson 算法，这是计算博弈论的基石。其数学公式，包括多面体表示、标签、枢轴变换和稳定性分析，都是标准且正确的。\n- **适定性**：该问题是适定的。它为每个测试用例提供了所有必要的数据（$m, n$、矩阵以及参数 $\\delta, \\tau, k, \\sigma$）。算法过程被明确地指定。矩阵必须严格为正的条件（以及强制执行此条件的过程）确保了多面体的有界性，并避免了某些退化情况，从而保证了算法在明确定义的路径上终止。\n- **客观性**：问题陈述完全客观，使用了精确的数学和算法术语。没有主观或含糊的陈述。\n\n该问题不存在任何无效性缺陷：它在科学上是合理的、可形式化的、完整的、可行的、适定的和可验证的。\n\n### 步骤 3：结论与行动\n此问题是 **有效的**。将提供一个解决方案。\n\n### 解决方案\n任务是实现 Lemke-Howson 算法，为双矩阵博弈 $(A,B)$ 找到一个纳什均衡，并评估该均衡在支付矩阵微小扰动下的局部稳定性。\n\nLemke-Howson 算法寻找两个多面体 $P = \\{ x \\in \\mathbb{R}^m_{\\ge 0} : B^\\top x \\le \\mathbf{1} \\}$ 和 $Q = \\{ y \\in \\mathbb{R}^n_{\\ge 0} : A y \\le \\mathbf{1} \\}$ 的一对互补顶点 $(x,y)$。对于严格为正的支付，这样的一对顶点在归一化后对应一个纳什均衡。\n\n实现的核心是在代表多面体的两个单纯形表上执行枢轴变换过程。这些多面体由以下线性系统定义：\n1. 对参与者1（行参与者，选择策略 $x$）：$B^\\top x + s = \\mathbf{1}$，其中 $x \\in \\mathbb{R}^m_{\\ge 0}$，松弛变量 $s \\in \\mathbb{R}^n_{\\ge 0}$。\n2. 对参与者2（列参与者，选择策略 $y$）：$A y + r = \\mathbf{1}$，其中 $y \\in \\mathbb{R}^n_{\\ge 0}$，松弛变量 $r \\in \\mathbb{R}^m_{\\ge 0}$。\n\n我们可以将这些系统以单纯形表的形式表示。对于系统1，我们可以将基变量 $s$ 写成非基变量 $x$ 的形式：$s = \\mathbf{1} - B^\\top x$。这构成了第一个单纯形表，代表 $P$ 的顶点。对于系统2，$r = \\mathbf{1} - A y$ 构成了第二个单纯形表，代表 $Q$ 的顶点。\n\n变量对应于集合 $\\{0, 1, \\dots, m+n-1\\}$ 中的标签。\n- 一个非基变量 $x_i$ ($i \\in \\{0, \\dots, m-1\\}$) 对应于标签 $i$ 存在于 $P$ 的一个顶点。\n- 一个非基松弛变量 $s_j$ ($j \\in \\{0, \\dots, n-1\\}$) 对应于标签 $m+j$ 存在于 $P$ 的一个顶点。\n- 一个非基变量 $y_j$ ($j \\in \\{0, \\dots, n-1\\}$) 对应于标签 $m+j$ 存在于 $Q$ 的一个顶点。\n- 一个非基松弛变量 $r_i$ ($i \\in \\{0, \\dots, m-1\\}$) 对应于标签 $i$ 存在于 $Q$ 的一个顶点。\n\n算法流程如下：\n1.  **初始化**：从顶点对 $(x, y) = (0, 0)$ 开始。在单纯形表1中，非基变量是 $x_0, \\dots, x_{m-1}$（标签为 $0, \\dots, m-1$），基变量是 $s_0, \\dots, s_{n-1}$。在单纯形表2中，非基变量是 $y_0, \\dots, y_{n-1}$（标签为 $m, \\dots, m+n-1$），基变量是 $r_0, \\dots, r_{m-1}$。这对 $(x,y)=(0,0)$ 是完全标记的；从 $0$ 到 $m+n-1$ 的每个标签在两个顶点中（作为非基变量）恰好出现一次。\n2.  **路径跟踪**：给定一个起始标签 $k$ 以“丢弃”。选择与标签 $k$ 对应的变量进入其相应单纯形表的基。例如，如果 $k \\in \\{0, \\dots, m-1\\}$，我们在单纯形表1中进行枢轴变换，使 $x_k$ 成为基变量。\n3.  **枢轴变换**：\n    -   离基变量由最小比率检验确定，以保持可行性（所有基变量的非负性）。该比率计算为当前基变量值的负数除以入基变量的相应系数。我们选择最小的非负比率。如果出现平局，则使用 Bland 法则：我们选择标签最小的离基变量。\n    -   在单纯形表上执行高斯-若尔当枢轴变换操作以更新系统。入基变量成为基变量，离基变量成为非基变量。\n4.  **交替单纯形表**：刚刚离基的变量的标签现在是重复的——它存在于新顶点，并且也存在于另一个单纯形表的相应顶点中。这个重复的标签决定了下一次枢轴变换：与此标签对应的变量将进入*另一个*单纯形表的基。\n5.  **终止**：这个交替枢轴变换的过程持续进行，直到选择离基的变量的标签与启动过程的标签 $k$ 相同。此时，这些顶点形成一个互补对，算法终止。\n\n一旦找到互补顶点对 $(x,y)$，通过对这些向量进行归一化，就可以得到混合策略纳什均衡 $(\\hat{x}, \\hat{y})$：\n$$ \\hat{x} = \\frac{x}{\\sum_{i=0}^{m-1} x_i}, \\quad \\hat{y} = \\frac{y}{\\sum_{j=0}^{n-1} y_j} $$\n由于算法从 $(x,y)=(0,0)$ 开始并移开，终端顶点将是非零的（假设是非退化博弈），这使得归一化是明确定义的。\n\n对于稳定性分析，我们首先为原始博弈 $(A,B)$ 计算一个均衡 $(\\hat{x}, \\hat{y})$。然后，我们通过添加均匀随机噪声生成一个扰动博弈 $(\\tilde{A}, \\tilde{B})$。我们通过必要时平移项来确保扰动后的矩阵保持严格为正。将相同的 Lemke-Howson 过程应用于 $(\\tilde{A}, \\tilde{B})$ 并使用相同的起始标签 $k$ 来找到新的均衡 $(\\tilde{x}, \\tilde{y})$。局部稳定性通过 $\\ell_1$ 距离 $d = \\|\\hat{x} - \\tilde{x}\\|_1 + \\|\\hat{y} - \\tilde{y}\\|_1$ 来量化。如果 $d \\le \\tau$，则该均衡被分类为稳定。对每个测试用例重复此整个过程。", "answer": "```python\nimport numpy as np\n\ndef _ensure_positive(matrix):\n    \"\"\"Ensures all entries of a matrix are strictly positive by shifting.\"\"\"\n    min_val = matrix.min()\n    if min_val <= 1e-9: # Use a small tolerance\n        # Shift by a non-negative constant to make minimum entry positive\n        matrix += -min_val + 1e-9\n    return matrix\n\ndef lemke_howson(A, B, k_start):\n    \"\"\"\n    Implements the Lemke-Howson algorithm for a bimatrix game (A, B).\n    \n    Args:\n        A (np.ndarray): Payoff matrix for player 1 (row player).\n        B (np.ndarray): Payoff matrix for player 2 (column player).\n        k_start (int): The 1-based label to drop to start the algorithm.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A Nash equilibrium (x_hat, y_hat).\n    \"\"\"\n    m, n = A.shape\n    \n    # Tableau for player 1 (polyhedron P): s = 1 - B.T @ x\n    # Rows correspond to basic variables, columns to non-basic variables + constants.\n    # The coefficients of non-basic variables are stored.\n    tab_P = np.hstack((-B.T, np.ones((n, 1))))\n    \n    # Tableau for player 2 (polyhedron Q): r = 1 - A @ y\n    tab_Q = np.hstack((-A, np.ones((m, 1))))\n\n    # Labels for player 1's variables (x_i, s_j)\n    # x_i corresponds to label i, s_j to label m+j\n    p1_non_basic_labels = list(range(m))\n    p1_basic_labels = list(range(m, m + n))\n    \n    # Labels for player 2's variables (y_j, r_i)\n    # y_j corresponds to label m+j, r_i to label i\n    p2_non_basic_labels = list(range(m, m + n))\n    p2_basic_labels = list(range(m))\n\n    # Convert 1-based start label to 0-based\n    leaving_label = k_start - 1\n    \n    # Determine the first tableau to pivot\n    if leaving_label < m:\n        current_tab, basic_labels, non_basic_labels = tab_P, p1_basic_labels, p1_non_basic_labels\n    else:\n        current_tab, basic_labels, non_basic_labels = tab_Q, p2_basic_labels, p2_non_basic_labels\n        \n    # The algorithm starts by making the variable with the dropped label basic\n    entering_label = leaving_label\n    \n    # Main path-following loop\n    while True:\n        # Find the column for the entering variable\n        try:\n            pivot_col_idx = non_basic_labels.index(entering_label)\n        except ValueError:\n            # Should not happen in a correct implementation\n            raise RuntimeError(f\"Entering label {entering_label} not found in non-basic list.\")\n\n        pivot_col = current_tab[:, pivot_col_idx]\n        const_col = current_tab[:, -1]\n        \n        # Minimum ratio test to find the leaving variable\n        ratios = []\n        candidate_rows = []\n        for i, val in enumerate(pivot_col):\n            if val < -1e-9: # Pivot element must be negative\n                ratios.append(-const_col[i] / val)\n                candidate_rows.append(i)\n\n        if not candidate_rows:\n            # This indicates an unbounded ray, which shouldn't happen for strictly positive games.\n            raise RuntimeError(\"Unbounded solution path encountered.\")\n\n        # Find minimum ratio and use Bland's rule for ties\n        min_ratio = min(ratios)\n        tied_indices = [candidate_rows[i] for i, r in enumerate(ratios) if abs(r - min_ratio) < 1e-9]\n        \n        # Bland's rule: choose the leaving variable with the minimum label\n        pivot_row_idx = min(tied_indices, key=lambda i: basic_labels[i])\n        \n        leaving_label = basic_labels[pivot_row_idx]\n        \n        # If the leaving label is the one we started with, we've found the complementary vertex\n        if leaving_label == k_start - 1:\n            break\n            \n        # Perform Gauss-Jordan pivot\n        pivot_val = current_tab[pivot_row_idx, pivot_col_idx]\n        current_tab[pivot_row_idx, :] /= pivot_val\n        for i in range(current_tab.shape[0]):\n            if i != pivot_row_idx:\n                current_tab[i, :] -= current_tab[i, pivot_col_idx] * current_tab[pivot_row_idx, :]\n                \n        # Swap labels of entering and leaving variables\n        basic_labels[pivot_row_idx], non_basic_labels[pivot_col_idx] = non_basic_labels[pivot_col_idx], basic_labels[pivot_row_idx]\n        \n        # The new entering label is the one that just left. Switch tableaux.\n        entering_label = leaving_label\n        if current_tab is tab_P:\n            current_tab, basic_labels, non_basic_labels = tab_Q, p2_basic_labels, p2_non_basic_labels\n        else:\n            current_tab, basic_labels, non_basic_labels = tab_P, p1_basic_labels, p1_non_basic_labels\n\n    # Extract vertex solutions from final tableaux\n    x = np.zeros(m)\n    y = np.zeros(n)\n    \n    sol_P_vars = np.zeros(m + n)\n    for i, label in enumerate(p1_basic_labels):\n        sol_P_vars[label] = tab_P[i, -1]\n    x = sol_P_vars[:m]\n\n    sol_Q_vars = np.zeros(m + n)\n    for i, label in enumerate(p2_basic_labels):\n        sol_Q_vars[label] = tab_Q[i, -1]\n    y = sol_Q_vars[m:]\n\n    # Normalize to get mixed strategies\n    sum_x = np.sum(x)\n    sum_y = np.sum(y)\n\n    x_hat = x / sum_x if sum_x > 0 else np.zeros(m)\n    y_hat = y / sum_y if sum_y > 0 else np.zeros(n)\n    \n    # Handle pure strategy cases if normalization results in division by zero.\n    # If sum_x is 0, one of the r_i is non-basic meaning (Ay)_i = 1 for player 2.\n    # Player 2 has a best response, and Player 1's strategy is pure in the original game.\n    if sum_x == 0:\n        # Player 1 uses a pure strategy. Find which y constraint is tight for p2.\n        # This implies a label i in {0..m-1} is non_basic in Q.\n        # This corresponds to a pure strategy for Player 1.\n        for label in p2_non_basic_labels:\n            if label < m:\n                x_hat[label] = 1.0\n                break\n\n    if sum_y == 0:\n        # Symmetrically, for player 2.\n        for label in p1_non_basic_labels:\n            if label >= m:\n                y_hat[label - m] = 1.0\n                break\n\n    return x_hat, y_hat\n    \ndef solve():\n    test_cases = [\n        {'m': 2, 'n': 2, 'type': 'random', 'sigma': 123, 'delta': 0.01, 'tau': 0.10, 'k': 1},\n        {'m': 3, 'n': 3, 'type': 'random', 'sigma': 7, 'delta': 0.005, 'tau': 0.10, 'k': 1},\n        {\n            'm': 3, 'n': 3, 'type': 'explicit',\n            'A': np.array([[3.0, 0.3, 0.3], [0.3, 3.0, 0.3], [0.3, 0.3, 3.0]]),\n            'B': np.array([[3.0, 0.3, 0.3], [0.3, 3.0, 0.3], [0.3, 0.3, 3.0]]),\n            'sigma': 999, 'delta': 0.02, 'tau': 0.20, 'k': 1\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, n, delta, tau, k = case['m'], case['n'], case['delta'], case['tau'], case['k']\n        rng = np.random.default_rng(case['sigma'])\n\n        if case['type'] == 'random':\n            a, b = 0.1, 1.5\n            A = rng.uniform(a, b, size=(m, n))\n            B = rng.uniform(a, b, size=(m, n))\n        else:\n            A, B = case['A'].copy(), case['B'].copy()\n\n        # Ensure matrices are strictly positive\n        A = _ensure_positive(A_orig := A.copy())\n        B = _ensure_positive(B_orig := B.copy())\n\n        # 1. Compute equilibrium for the original game\n        x_hat, y_hat = lemke_howson(A, B, k)\n\n        # 2. Perturb payoffs\n        delta_A = rng.uniform(-delta, delta, size=(m, n))\n        delta_B = rng.uniform(-delta, delta, size=(m, n))\n        A_tilde = A_orig + delta_A\n        B_tilde = B_orig + delta_B\n        \n        # Ensure perturbed matrices are strictly positive\n        A_tilde = _ensure_positive(A_tilde)\n        B_tilde = _ensure_positive(B_tilde)\n        \n        # 3. Compute equilibrium for the perturbed game\n        x_tilde, y_tilde = lemke_howson(A_tilde, B_tilde, k)\n\n        # 4. Calculate L1 distance and classify stability\n        dist = np.sum(np.abs(x_hat - x_tilde)) + np.sum(np.abs(y_hat - y_tilde))\n        is_stable = dist <= tau\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}