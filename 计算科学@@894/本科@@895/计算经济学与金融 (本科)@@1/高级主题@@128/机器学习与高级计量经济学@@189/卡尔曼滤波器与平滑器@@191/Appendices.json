{"hands_on_practices": [{"introduction": "金融时间序列，特别是对于像公司债券这样流动性不足的资产，常常存在数据点缺失的问题。卡尔曼滤波器以其递归结构，为处理这一问题提供了系统性的方法。当观测值缺失时，滤波器的“更新”步骤可以被跳过，而基于前一状态的“预测”值自然成为当前状态的最佳估计 [@problem_id:2441481]。本练习将通过填补缺失价格数据的实际任务，帮助您理解滤波器预测-更新周期的核心机制，并掌握其在现实世界数据插补中的强大应用。", "id": "2441481", "problem": "一只流动性差的公司债券交易不频繁，导致其每日交易价格数据存在缺失。考虑使用以下线性高斯状态空间模型来为潜在的每日基本价格水平建模。对于时间指数 $t \\in \\{1,2,\\dots,T\\}$，潜在状态 $x_t$（基本价格）遵循以下规律演化：\n$$\nx_t = \\phi x_{t-1} + w_t,\n$$\n其中 $w_t \\sim \\mathcal{N}(0,q)$，而观测到的交易价格 $y_t$ 满足：\n$$\ny_t = x_t + v_t,\n$$\n其中 $v_t \\sim \\mathcal{N}(0,r)$，且 $\\{w_t\\}$ 和 $\\{v_t\\}$ 随时间相互独立，并且与初始状态无关。初始状态的先验分布为\n$$\nx_0 \\sim \\mathcal{N}(m_0, P_0).\n$$\n当 $y_t$ 在某一天不可用时，它被标记为特殊符号 $\\text{NaN}$。对于任何有缺失观测值的日期，我们将实时插补价格定义为条件期望：\n$$\n\\hat{y}_t := \\mathbb{E}[y_t \\mid \\{y_s : 1 \\le s \\le t \\text{ and } y_s \\text{ is observed}\\}],\n$$\n该定义仅使用截至（并包括）时间 $t$ 的可用信息。所有插补价格必须以与输入价格相同的货币单位表示，并报告时四舍五入至4位小数。\n\n现给定以下测试套件。每个测试用例提供参数 $(\\phi,q,r,m_0,P_0)$ 和一个观测价格序列 $(y_1,\\dots,y_T)$，其中缺失条目由 $\\text{NaN}$ 表示。对于每个测试用例，请按时间顺序输出在那些 $y_t$ 缺失的时刻 $t$ 的插补值 $\\hat{y}_t$ 列表。\n\n测试用例 1：\n- 参数：$\\phi = 0.999$, $q = 0.04$, $r = 0.09$, $m_0 = 100.0$, $P_0 = 1.0$。\n- 观测值：$[100.2,\\,100.5,\\,\\text{NaN},\\,100.7,\\,100.6,\\,\\text{NaN},\\,100.8]$。\n\n测试用例 2：\n- 参数：$\\phi = 1.0$, $q = 0.01$, $r = 0.04$, $m_0 = 50.0$, $P_0 = 4.0$。\n- 观测值：$[49.8,\\,50.3,\\,50.0,\\,49.9,\\,50.1]$。\n\n测试用例 3：\n- 参数：$\\phi = 0.995$, $q = 0.10$, $r = 0.16$, $m_0 = 200.0$, $P_0 = 9.0$。\n- 观测值：$[\\text{NaN},\\,\\text{NaN},\\,199.0,\\,199.5,\\,\\text{NaN},\\,200.2]$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表的第 $i$ 个条目本身必须是一个列表，按时间顺序包含第 $i$ 个测试用例的插补值，每个值都四舍五入到4位小数。对于没有缺失观测值的测试用例，请为该用例输出一个空列表 $[]$。例如，输出可能看起来像\n$$\n[[\\hat{y}_{t_1},\\hat{y}_{t_2}],[],[\\hat{y}_{s_1},\\hat{y}_{s_2},\\hat{y}_{s_3}]],\n$$\n并且必须以 `\"[list_case1,list_case2,list_case3]\"` 的确切格式打印，不含空格，每个数字四舍五入到4位小数。", "solution": "该问题要求为一系列交易不频繁的公司债券计算实时插补价格。债券基本价格的动态由一个线性高斯状态空间模型描述，这是计量经济学和金融学中解决此类问题的标准框架。任务是找到在未观测到价格的时刻，仅使用截至该时间点可用信息的价格条件期望。这是卡尔曼滤波器的直接应用。\n\n状态空间模型定义如下：\n状态方程：$x_t = \\phi x_{t-1} + w_t$，其中 $w_t \\sim \\mathcal{N}(0, q)$\n观测方程：$y_t = x_t + v_t$，其中 $v_t \\sim \\mathcal{N}(0, r)$\n\n这里，$x_t$ 是时间 $t$ 的潜在基本价格，$y_t$ 是观测到的交易价格。项 $w_t$ 和 $v_t$ 是独立的、零均值的高斯噪声过程。初始状态 $x_0$ 从高斯分布中抽取，$x_0 \\sim \\mathcal{N}(m_0, P_0)$。\n\n需要计算的量是实时插补价格 $\\hat{y}_t$，它适用于任何观测值 $y_t$ 缺失的时间 $t$。它被定义为：\n$$\n\\hat{y}_t := \\mathbb{E}[y_t \\mid \\{y_s : 1 \\le s \\le t \\text{ and } y_s \\text{ is observed}\\}]\n$$\n令 $\\mathcal{I}_t^{\\text{obs}}$ 表示截至（并包括）时间 $t$ 的观测价格集合。如果 $y_t$ 缺失，该集合等同于截至时间 $t-1$ 的观测价格集合，我们可以将其表示为 $\\mathcal{I}_{t-1}^{\\text{obs}}$。\n使用观测方程，我们可以写出：\n$$\n\\hat{y}_t = \\mathbb{E}[x_t + v_t \\mid \\mathcal{I}_{t-1}^{\\text{obs}}] = \\mathbb{E}[x_t \\mid \\mathcal{I}_{t-1}^{\\text{obs}}] + \\mathbb{E}[v_t \\mid \\mathcal{I}_{t-1}^{\\text{obs}}]\n$$\n观测噪声 $v_t$ 与过去所有的状态和观测值都是独立的。因此，$\\mathbb{E}[v_t \\mid \\mathcal{I}_{t-1}^{\\text{obs}}] = \\mathbb{E}[v_t] = 0$。这将插补价格简化为：\n$$\n\\hat{y}_t = \\mathbb{E}[x_t \\mid \\mathcal{I}_{t-1}^{\\text{obs}}]\n$$\n这个量是在给定截至时间 $t-1$ 的观测历史条件下，对状态 $x_t$ 的一步预测。卡尔曼滤波器提供了一个递归算法来计算该值。\n\n令 $m_{t|t-1}$ 和 $P_{t|t-1}$ 分别为预测状态分布 $p(x_t | y_1, \\dots, y_{t-1}^{\\text{obs}})$ 的均值和方差，令 $m_{t|t}$ 和 $P_{t|t}$ 分别为滤波状态分布 $p(x_t | y_1, \\dots, y_t^{\\text{obs}})$ 的均值和方差。算法流程如下：\n\n**初始化：**\n将时间 $t=0$ 时的初始滤波估计设置为先验分布：\n$m_{0|0} = m_0$\n$P_{0|0} = P_0$\n\n**迭代：**\n对每个时间步 $t=1, 2, \\dots, T$：\n\n**1. 预测步骤：**\n时间 $t$ 的状态预测均值和方差由状态方程和时间 $t-1$ 的滤波估计导出：\n$$\nm_{t|t-1} = \\phi \\cdot m_{t-1|t-1}\n$$\n$$\nP_{t|t-1} = \\phi^2 \\cdot P_{t-1|t-1} + q\n$$\n\n**2. 更新步骤：**\n此步骤取决于观测值 $y_t$ 是否可用。\n\n**情况A：$y_t$ 已被观测。**\n我们通过结合来自 $y_t$ 的新信息来更新状态估计。\n新息（或预测误差）为 $\\nu_t = y_t - m_{t|t-1}$。\n新息方差为 $S_t = P_{t|t-1} + r$。\n卡尔曼增益决定了赋予新息的权重，其值为 $K_t = P_{t|t-1} / S_t$。\n更新后（滤波后）的状态均值和方差为：\n$$\nm_{t|t} = m_{t|t-1} + K_t \\cdot \\nu_t\n$$\n$$\nP_{t|t} = (1 - K_t) \\cdot P_{t|t-1}\n$$\n\n**情况B：$y_t$ 缺失 (NaN)。**\n所需的插补价格即为预测状态均值：\n$$\n\\hat{y}_t = m_{t|t-1}\n$$\n记录该值。由于在时间 $t$ 没有新的可用信息，滤波分布就是预测分布。更新步骤变成一个平凡的恒等变换：\n$$\nm_{t|t} = m_{t|t-1}\n$$\n$$\nP_{t|t} = P_{t|t-1}\n$$\n这确保了不确定性（方差）不会减少，并正确地向前传播，直到下一个可用观测值的出现。\n\n通过从 $t=1$到 $T$ 迭代这些步骤，我们可以处理整个观测序列，并收集所有 $y_t$ 缺失的时间步的插补值 $\\hat{y}_t$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for real-time imputed prices in a linear Gaussian state-space model\n    using the Kalman filter for several test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"params\": {\"phi\": 0.999, \"q\": 0.04, \"r\": 0.09, \"m0\": 100.0, \"P0\": 1.0},\n            \"obs\": [100.2, 100.5, np.nan, 100.7, 100.6, np.nan, 100.8],\n        },\n        {\n            \"params\": {\"phi\": 1.0, \"q\": 0.01, \"r\": 0.04, \"m0\": 50.0, \"P0\": 4.0},\n            \"obs\": [49.8, 50.3, 50.0, 49.9, 50.1],\n        },\n        {\n            \"params\": {\"phi\": 0.995, \"q\": 0.10, \"r\": 0.16, \"m0\": 200.0, \"P0\": 9.0},\n            \"obs\": [np.nan, np.nan, 199.0, 199.5, np.nan, 200.2],\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        # Extract parameters and observations for the current case\n        phi = case[\"params\"][\"phi\"]\n        q = case[\"params\"][\"q\"]\n        r = case[\"params\"][\"r\"]\n        obs = case[\"obs\"]\n        \n        # Initialize filtered state mean and variance from the prior\n        m_filt = case[\"params\"][\"m0\"]\n        P_filt = case[\"params\"][\"P0\"]\n        \n        imputed_values = []\n        \n        # Iterate through time\n        for y_t in obs:\n            # Prediction step\n            m_pred = phi * m_filt\n            P_pred = phi**2 * P_filt + q\n            \n            # Update step\n            if not np.isnan(y_t):\n                # Observation is available\n                nu_t = y_t - m_pred       # Innovation\n                S_t = P_pred + r          # Innovation variance\n                K_t = P_pred / S_t        # Kalman gain\n                m_filt = m_pred + K_t * nu_t\n                P_filt = (1.0 - K_t) * P_pred\n            else:\n                # Observation is missing (NaN)\n                # The imputed price is the one-step-ahead prediction of the state.\n                imputed_values.append(m_pred)\n                # The filtered estimate is just the prediction\n                m_filt = m_pred\n                P_filt = P_pred\n        \n        all_results.append(imputed_values)\n        \n    # Format the output string precisely as specified\n    # The output format is a list of lists, with no spaces, and numbers rounded to 4 decimals.\n    case_results_str = []\n    for res in all_results:\n        # Format numbers to 4 decimal places\n        num_strs = [f\"{v:.4f}\" for v in res]\n        # Join numbers with commas and enclose in brackets\n        case_results_str.append(f\"[{','.join(num_strs)}]\")\n            \n    # Join the string representations of each case's results and enclose in brackets\n    final_output = f\"[{','.join(case_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"}, {"introduction": "在金融计量经济学中，一项核心任务是将观测信号（如股票回报率）分解为其潜在的组成部分，例如长期趋势（永久性成分）和短期波动（暂时性成分）。我们可以巧妙地将这个问题构建为一个状态空间模型，其中未观测到的成分构成了状态向量 $x_t$。通过使用卡尔曼滤波器和Rauch-Tung-Striebel (RTS) 平滑器，我们可以从观测到的回报率中估计这些潜在成分 [@problem_id:2441543]。这个练习将带领您从简单的滤波任务进入更复杂的多变量建模场景，训练您构建和估计一个有意义的金融模型，并使用平滑器进行全样本分析。", "id": "2441543", "problem": "给定一个股票收益率的线性高斯状态空间分解，该分解将收益率分为一个永久性分量和一个暂时性分量。设观测到的收益率为 $y_t$，永久性分量为 $\\alpha_t$，暂时性分量为 $v_t$。假设\n- $y_t = \\alpha_t + v_t$，\n- $\\alpha_t = \\alpha_{t-1} + \\eta_t$，其中 $\\eta_t \\sim \\mathcal{N}(0,\\sigma_{\\eta}^2)$，\n- $v_t = \\phi\\, v_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma_{\\varepsilon}^2)$，\n- 对所有 $t$，$\\eta_t$ 和 $\\varepsilon_t$ 相互独立，且与初始状态无关。\n\n这引出一个状态空间模型，其状态为 $x_t = \\begin{bmatrix}\\alpha_t \\\\ v_t\\end{bmatrix}$，状态转移矩阵为 $F = \\begin{bmatrix}1 & 0 \\\\ 0 & \\phi\\end{bmatrix}$，观测矩阵为 $H = \\begin{bmatrix}1 & 1\\end{bmatrix}$，过程噪声协方差为 $Q = \\mathrm{diag}(\\sigma_{\\eta}^2,\\sigma_{\\varepsilon}^2)$，观测噪声方差为 $R = 0$。设初始状态为 $x_0=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，初始协方差为 $P_0=\\mathrm{diag}(100,100)$。\n\n您的任务是：\n- 从线性高斯状态空间模型的第一性原理出发，实现一个递归估计器，该估计器在给定截至时间 $t$ 的观测值的情况下，为每个 $t$ 生成最小均方误差状态估计；然后，实现一个固定区间后向传递，该传递在给定所有观测值的情况下，生成最小均方误差的平滑状态估计。\n- 对下述每个测试用例，使用该模型通过模拟 $\\alpha_t$、$v_t$ 和 $y_t$ 来生成合成数据，其中使用独立的高斯新息和指定的随机种子以确保可复现性。\n- 对每个测试用例，计算整个样本上平滑估计值 $\\widehat{\\alpha}_t$ 与真实值 $\\alpha_t$ 之间的均方根误差 (RMSE)，同样地，计算平滑估计值 $\\widehat{v}_t$ 与真实值 $v_t$ 之间的 RMSE。\n\n模拟细节：\n- 对每个测试用例，确定性地设置 $x_0=\\begin{bmatrix}0\\\\0\\end{bmatrix}$，并对所有 $t$ 独立抽取 $\\eta_t \\sim \\mathcal{N}(0,\\sigma_{\\eta}^2)$ 和 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma_{\\varepsilon}^2)$。\n- 根据其运动定律递归生成序列 $\\{\\alpha_t\\}_{t=1}^T$ 和 $\\{v_t\\}_{t=1}^T$，然后对 $t=1,\\dots,T$ 设置 $y_t=\\alpha_t+v_t$。\n- 使用所述的 $F$、$H$、$Q$、$R$、$x_0$ 和 $P_0$ 运行您的估计器，先进行时间上的前向传递，然后对整个样本进行后向平滑。\n\n测试套件：\n- 用例 $1$：$T=120$，$\\phi=0.5$，$\\sigma_{\\eta}=0.05$，$\\sigma_{\\varepsilon}=0.2$，种子 $=7$。\n- 用例 $2$：$T=300$，$\\phi=0.95$，$\\sigma_{\\eta}=0.15$，$\\sigma_{\\varepsilon}=0.1$，种子 $=11$。\n- 用例 $3$：$T=80$，$\\phi=-0.6$，$\\sigma_{\\eta}=0.1$，$\\sigma_{\\varepsilon}=0.25$，种子 $=42$。\n\n输出规格：\n- 对每个用例，报告两个浮点数：$\\mathrm{RMSE}_{\\alpha}=\\sqrt{\\frac{1}{T}\\sum_{t=1}^T(\\widehat{\\alpha}_t-\\alpha_t)^2}$ 和 $\\mathrm{RMSE}_{v}=\\sqrt{\\frac{1}{T}\\sum_{t=1}^T(\\widehat{v}_t-v_t)^2}$。\n- 将每个报告值四舍五入到恰好 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含所有结果，格式为方括号括起来的逗号分隔列表，顺序为 $[\\mathrm{RMSE}_{\\alpha}^{(1)},\\mathrm{RMSE}_{v}^{(1)},\\mathrm{RMSE}_{\\alpha}^{(2)},\\mathrm{RMSE}_{v}^{(2)},\\mathrm{RMSE}_{\\alpha}^{(3)},\\mathrm{RMSE}_{v}^{(3)}]$，其中上标表示用例索引。\n- 不涉及物理单位。\n\n测试套件覆盖范围说明：\n- 用例 $1$ 是一个条件良好的基准（中等持续性和较高的暂时性噪声）。\n- 用例 $2$ 用接近 $1$ 的高持续性 $\\phi$ 来测试近非平稳的暂时性动态。\n- 用例 $3$ 测试具有较大暂时性噪声的负自相关暂时性分量。\n\n您的实现必须是一个完整、可运行的程序，能够对指定的用例执行模拟、估计和评估，并以所要求的确切格式打印结果。", "solution": "我们从线性高斯状态空间模型开始。该模型指出，如果潜在状态随高斯过程噪声线性演化，并通过高斯观测噪声进行线性观测，那么在给定截至时间 $t$ 的观测值的情况下，状态的条件分布是高斯的。最小均方误差估计器是状态在给定数据下的条件期望。在线性和高斯性假设下，该估计器通过 Kalman 滤波器递归计算。在给定所有观测值的条件下，固定区间的最小均方误差估计器通过一种称为 Rauch–Tung–Striebel (RTS) 平滑器的后向递归获得。\n\n模型设定。状态为 $x_t=\\begin{bmatrix}\\alpha_t\\\\v_t\\end{bmatrix}$，状态转移方程为\n$$\nx_t = F x_{t-1} + w_t,\\quad F=\\begin{bmatrix}1 & 0\\\\ 0 & \\phi\\end{bmatrix},\\quad w_t\\sim \\mathcal{N}(0,Q),\\quad Q=\\mathrm{diag}(\\sigma_{\\eta}^2,\\sigma_{\\varepsilon}^2).\n$$\n观测方程为\n$$\ny_t = H x_t + u_t,\\quad H=\\begin{bmatrix}1 & 1\\end{bmatrix},\\quad u_t\\sim \\mathcal{N}(0,R),\\quad R=0.\n$$\n初始条件为 $x_0\\sim \\mathcal{N}(m_0,P_0)$，其中 $m_0=\\begin{bmatrix}0\\\\0\\end{bmatrix}$，$P_0=\\mathrm{diag}(100,100)$，且与 $\\{w_t,u_t\\}$ 无关。\n\n前向递归 (Kalman 滤波器)。给定时间 $t-1$ 的滤波估计和协方差，记为 $m_{t-1|t-1}$ 和 $P_{t-1|t-1}$，则单步向前预测为\n$$\nm_{t|t-1} = F m_{t-1|t-1},\\quad P_{t|t-1} = F P_{t-1|t-1} F^\\top + Q.\n$$\n给定观测值 $y_t$，计算新息\n$$\n\\tilde{y}_t = y_t - H m_{t|t-1}, \\quad S_t = H P_{t|t-1} H^\\top + R,\n$$\n和 Kalman 增益\n$$\nK_t = P_{t|t-1} H^\\top S_t^{-1}.\n$$\n然后，滤波估计和协方差更新为\n$$\nm_{t|t} = m_{t|t-1} + K_t \\tilde{y}_t,\\quad P_{t|t} = (I - K_t H) P_{t|t-1}.\n$$\n在我们的模型中，$R=0$，且由于 $H$ 是 $1\\times 2$ 的，因此 $S_t$ 是一个标量，所以 $S_t^{-1}$ 就是方差 $S_t$ 的倒数。\n\n后向递归 (Rauch–Tung–Striebel 平滑器)。从 $m_{T|T}$ 和 $P_{T|T}$ 开始，对 $t=T-1,\\dots,1$ 进行后向移动，使用以下公式获得平滑估计值 $m_{t|T}=\\mathbb{E}[x_t\\mid y_{1:T}]$：\n$$\nJ_t = P_{t|t} F^\\top (P_{t+1|t})^{-1},\\quad m_{t|T} = m_{t|t} + J_t (m_{t+1|T} - m_{t+1|t}),\n$$\n$$\nP_{t|T} = P_{t|t} + J_t (P_{t+1|T} - P_{t+1|t}) J_t^\\top,\n$$\n其中，根据状态动态，$m_{t+1|t}=F m_{t|t}$ 且 $P_{t+1|t}=F P_{t|t} F^\\top + Q$。\n\n模拟。对每个测试用例，给定 $T$、$\\phi$、$\\sigma_{\\eta}$、$\\sigma_{\\varepsilon}$ 和种子，我们模拟潜在过程和观测值：\n- 初始化 $\\alpha_0=0$ 和 $v_0=0$。\n- 对 $t=1,\\dots,T$，独立抽取 $\\eta_t\\sim \\mathcal{N}(0,\\sigma_{\\eta}^2)$ 和 $\\varepsilon_t\\sim \\mathcal{N}(0,\\sigma_{\\varepsilon}^2)$，设置 $\\alpha_t=\\alpha_{t-1}+\\eta_t$ 和 $v_t=\\phi v_{t-1}+\\varepsilon_t$，并定义 $y_t=\\alpha_t+v_t$。\n\n估计与评估。利用模拟出的 $\\{y_t\\}$，我们使用指定的 $F$、$H$、$Q$、$R$、$m_0$ 和 $P_0$ 运行 Kalman 滤波器，存储滤波均值和协方差，然后运行 RTS 平滑器以获得 $m_{t|T}$。$m_{t|T}$ 的分量即为平滑估计值 $\\widehat{\\alpha}_t$ 和 $\\widehat{v}_t$。然后我们计算\n$$\n\\mathrm{RMSE}_{\\alpha} = \\sqrt{\\frac{1}{T}\\sum_{t=1}^T (\\widehat{\\alpha}_t - \\alpha_t)^2},\\quad \\mathrm{RMSE}_{v} = \\sqrt{\\frac{1}{T}\\sum_{t=1}^T (\\widehat{v}_t - v_t)^2}.\n$$\n\n算法考量。\n- 新息方差 $S_t$ 是正的，因为 $P_{t|t-1}$ 是半正定的且 $H$ 具有满行秩；因此即使 $R=0$，$S_t^{-1}$ 也存在。\n- 为保证数值稳定性，计算 $S_t^{-1}$ 和 $(P_{t+1|t})^{-1}$ 所需的矩阵逆可以通过求解线性方程组来完成。\n- 初始协方差 $P_0$ 被设置得很大，以反映关于 $x_0$ 的弥散先验不确定性。\n\n测试套件覆盖范围理由。\n- 用例 1（中等 $\\phi$ 值和相对于 $\\sigma_{\\eta}$ 更大的 $\\sigma_{\\varepsilon}$）评估典型条件。\n- 用例 2（$\\phi$ 接近 1）产生高度持续的暂时性动态，对平滑器分离分量的能力构成挑战。\n- 用例 3（负 $\\phi$ 值）用符号翻转的序列相关性和较高的暂时性噪声来测试算法。\n\n程序为所有用例实现了模拟、滤波和平滑，计算了所要求的 RMSE，将每个值四舍五入到 6 位小数，并按指定顺序打印成一个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_returns(T, phi, sigma_eta, sigma_eps, seed):\n    rng = np.random.default_rng(seed)\n    eta = rng.normal(0.0, sigma_eta, size=T)\n    eps = rng.normal(0.0, sigma_eps, size=T)\n    alpha = np.zeros(T)\n    v = np.zeros(T)\n    # Initial states are zero deterministically\n    a_prev = 0.0\n    v_prev = 0.0\n    for t in range(T):\n        a_prev = a_prev + eta[t]\n        v_prev = phi * v_prev + eps[t]\n        alpha[t] = a_prev\n        v[t] = v_prev\n    y = alpha + v\n    return y, alpha, v\n\ndef kalman_filter_rts(y, F, H, Q, R, x0, P0):\n    \"\"\"\n    y: shape (T,)\n    F: shape (n,n)\n    H: shape (1,n)\n    Q: shape (n,n)\n    R: scalar (float)\n    x0: shape (n,)\n    P0: shape (n,n)\n    Returns smoothed means of shape (T,n)\n    \"\"\"\n    T = y.shape[0]\n    n = x0.shape[0]\n    # Preallocate arrays\n    m_pred = np.zeros((T, n))\n    P_pred = np.zeros((T, n, n))\n    m_filt = np.zeros((T, n))\n    P_filt = np.zeros((T, n, n))\n    I = np.eye(n)\n\n    m_prev = x0.copy()\n    P_prev = P0.copy()\n    H_mat = H.reshape(1, n)  # ensure shape\n    HT = H_mat.T\n\n    for t in range(T):\n        # Predict\n        m_prior = F @ m_prev\n        P_prior = F @ P_prev @ F.T + Q\n\n        # Innovation\n        yhat = (H_mat @ m_prior.reshape(n, 1)).item()\n        innov = y[t] - yhat\n        S = (H_mat @ P_prior @ HT).item() + R  # scalar\n\n        # Kalman gain\n        K = (P_prior @ HT) / S  # shape (n,1)\n\n        # Update\n        m_post = m_prior + (K.flatten() * innov)\n        P_post = (I - K @ H_mat) @ P_prior\n\n        # Store\n        m_pred[t] = m_prior\n        P_pred[t] = P_prior\n        m_filt[t] = m_post\n        P_filt[t] = P_post\n\n        # Prepare for next\n        m_prev = m_post\n        P_prev = P_post\n\n    # RTS smoother\n    m_smooth = np.zeros_like(m_filt)\n    P_smooth = np.zeros_like(P_filt)\n    m_smooth[-1] = m_filt[-1]\n    P_smooth[-1] = P_filt[-1]\n\n    for t in range(T - 2, -1, -1):\n        # Compute predicted next from filtered t\n        P_pred_next = F @ P_filt[t] @ F.T + Q\n        # Smoother gain\n        # Solve P_pred_next * X = F @ P_filt[t]  => X^T = P_filt[t] @ F.T @ inv(P_pred_next)\n        # We compute J = P_filt[t] @ F.T @ inv(P_pred_next)\n        # Use solve for inv(P_pred_next)\n        J = P_filt[t] @ F.T @ np.linalg.inv(P_pred_next)\n        m_pred_next = F @ m_filt[t]\n        m_smooth[t] = m_filt[t] + J @ (m_smooth[t + 1] - m_pred_next)\n        P_smooth[t] = P_filt[t] + J @ (P_smooth[t + 1] - P_pred_next) @ J.T\n\n    return m_smooth, P_smooth\n\ndef rmse(a, b):\n    return float(np.sqrt(np.mean((np.asarray(a) - np.asarray(b)) ** 2)))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (T, phi, sigma_eta, sigma_eps, seed)\n    test_cases = [\n        (120, 0.5, 0.05, 0.2, 7),\n        (300, 0.95, 0.15, 0.1, 11),\n        (80, -0.6, 0.1, 0.25, 42),\n    ]\n\n    results = []\n    for T, phi, sigma_eta, sigma_eps, seed in test_cases:\n        # Simulate data\n        y, alpha_true, v_true = simulate_returns(T, phi, sigma_eta, sigma_eps, seed)\n        # Build model matrices\n        F = np.array([[1.0, 0.0],\n                      [0.0, float(phi)]])\n        H = np.array([1.0, 1.0])  # shape (2,)\n        Q = np.diag([sigma_eta ** 2, sigma_eps ** 2])\n        R = 0.0\n        x0 = np.array([0.0, 0.0])\n        P0 = np.diag([100.0, 100.0])\n\n        # Kalman filter and RTS smoother\n        m_smooth, _ = kalman_filter_rts(y, F, H, Q, R, x0, P0)\n\n        alpha_hat = m_smooth[:, 0]\n        v_hat = m_smooth[:, 1]\n\n        rmse_alpha = rmse(alpha_hat, alpha_true)\n        rmse_v = rmse(v_hat, v_true)\n\n        # Round to 6 decimals as strings\n        results.append(f\"{rmse_alpha:.6f}\")\n        results.append(f\"{rmse_v:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "经济和金融系统并非一成不变；它们会随着政策变化、技术冲击或市场危机而经历结构性变化。标准的卡尔曼滤波器假设模型参数是恒定的，但它可以被扩展到时变系统中，其中状态转移矩阵 $F_t$ 等参数会在已知时间点发生改变 [@problem_id:2441535]。本练习旨在展示如何调整卡尔曼滤波器来模拟这类结构性突变，并通过对比正确设定和错误设定的模型，量化其影响，从而强调模型准确设定的重要性。", "id": "2441535", "problem": "考虑一个用于描述潜在市场因素的线性高斯状态空间模型，该因素的持续性可能存在结构性断裂。该潜在状态是一维的，并根据一个时变的一阶自回归过程演化。令 $t \\in \\{0,1,\\dots,T-1\\}$ 为观测时间的索引。该模型为\n$$\nx_{t+1} = F_t\\, x_t + w_t,\\quad w_t \\sim \\mathcal{N}(0,q),\n$$\n$$\ny_t = H\\, x_t + v_t,\\quad v_t \\sim \\mathcal{N}(0,r),\n$$\n其中 $H=1$。初始状态分布为 $x_0 \\sim \\mathcal{N}(m_0,P_0)$。在索引 $t_k$ 处发生结构性断裂，状态转移矩阵 $F_t$ 从断裂前的值 $a_1$ 变为断裂后的值 $a_2$：\n$$\nF_t = \\begin{cases}\na_1,& \\text{当 } t < t_k \\text{ 时,}\\\\\na_2,& \\text{当 } t \\ge t_k \\text{ 时.}\n\\end{cases}\n$$\n所有参数 $(T,a_1,a_2,q,r,m_0,P_0,t_k)$ 均为给定，并满足标准的正则性条件（有限、实数，且 $q>0$，$r>0$，$P_0>0$）。不涉及角度。不存在物理单位。\n\n您的任务是：\n- 使用上述定义，根据指定的 $(F_t)$ 方案，模拟一条潜在路径 $\\{x_t\\}_{t=0}^{T}$ 和一组观测值 $\\{y_t\\}_{t=0}^{T-1}$。对 $w_t$ 和 $v_t$ 使用独立的高斯抽样，并在每个测试用例中使用相同的模拟数据来评估所有算法。为了保证用例间的可复现性，对于从 0 开始的用例索引 $i$，使用确定性种子 $12345+i$。\n- 针对具有已知 $(F_t)$ 的时变模型，实现最优线性递归估计器（Kalman 滤波器），并实现用于固定区间平滑的 Rauch–Tung–Striebel 平滑器。\n- 在结构性断裂点定义两个定量响应度量：\n  1. 断裂点的即时结构性响应 $D$ 是指在转移索引 $t_k \\to t_k+1$ 处，仅因从 $a_1$ 切换到 $a_2$ 而导致的单步预测均值变化的幅度。如果 $m_{t_k|t_k}$ 表示在考虑断裂的模型下，时间 $t_k$ 的滤波均值，则\n  $$\n  D \\equiv \\left| \\, a_2\\, m_{t_k|t_k} - a_1\\, m_{t_k|t_k} \\, \\right| = \\left| (a_2 - a_1)\\, m_{t_k|t_k} \\right|.\n  $$\n  2. 平滑断裂调整值 $A$ 是指在断裂时间 $t_k$ 处，考虑断裂的模型与一个忽略断裂的反事实模型（即，对所有 $t$ 设定 $F_t \\equiv a_1$）之间平滑状态均值的差异，同时保持数据生成过程的所有其他元素不变：\n  $$\n  A \\equiv m^{\\text{break}}_{t_k|T} - m^{\\text{no-break}}_{t_k|T},\n  $$\n  其中 $m^{\\text{break}}_{t_k|T}$ 是使用已知的结构性断裂 $(F_t)$ 在时间 $t_k$ 得到的平滑均值，而 $m^{\\text{no-break}}_{t_k|T}$ 是在无断裂假设 $(F_t \\equiv a_1)$ 下在时间 $t_k$ 得到的平滑均值，两者均基于相同的模拟观测值 $\\{y_t\\}$ 计算。\n- 边缘情况处理：如果 $t_k = T-1$，仍然使用上述的 $m_{t_k|t_k}$ 计算 $D$。平滑断裂调整值 $A$ 在时间 $t_k$ 仍然是良定义的。\n\n实现一个程序，对以下测试套件中的每个参数集执行上述操作：\n- 用例 1：$T=60$, $a_1=0.9$, $a_2=0.5$, $q=0.04$, $r=0.09$, $m_0=0.0$, $P_0=1.0$, $t_k=30$。\n- 用例 2：$T=50$, $a_1=0.95$, $a_2=0.2$, $q=0.01$, $r=0.04$, $m_0=0.0$, $P_0=1.0$, $t_k=1$。\n- 用例 3：$T=60$, $a_1=0.9$, $a_2=0.9$, $q=0.04$, $r=0.04$, $m_0=0.0$, $P_0=1.0$, $t_k=30$。\n- 用例 4：$T=60$, $a_1=0.7$, $a_2=-0.7$, $q=0.04$, $r=0.01$, $m_0=0.0$, $P_0=1.0$, $t_k=59$。\n\n最终输出格式：\n- 对每个用例，计算定义的配对 $(D,A)$。您的程序应生成单行输出，其中包含所有结果，形式为一个以逗号分隔的浮点数列表，四舍五入到六位小数，顺序为 $[D_1,A_1,D_2,A_2,D_3,A_3,D_4,A_4]$，并用方括号括起来（例如 $[0.123456,-0.000321,\\dots]$）。", "solution": "该问题要求分析一个在其自回归参数上存在结构性断裂的一维线性高斯状态空间模型。这是计量经济学和时间序列分析中的一个标准问题。解决方案涉及过程的模拟，通过 Kalman 滤波器进行估计，以及使用 Rauch-Tung-Striebel (RTS) 平滑器进行回溯性分析。我将首先介绍理论基础，然后描述推导所需度量的计算过程。\n\n该模型由时间 $t \\in \\{0, 1, \\dots, T-1\\}$ 的状态方程和观测方程定义：\n$$\nx_{t+1} = F_t x_t + w_t, \\quad w_t \\sim \\mathcal{N}(0, q)\n$$\n$$\ny_t = H x_t + v_t, \\quad v_t \\sim \\mathcal{N}(0, r)\n$$\n状态 $x_t$ 是一个潜在标量变量，$y_t$ 是其标量观测值。初始状态为 $x_0 \\sim \\mathcal{N}(m_0, P_0)$。观测矩阵给定为 $H=1$。该模型的关键特征是时变的状态转移参数 $F_t$，它在一个已知时间 $t_k$ 表现出结构性断裂：\n$$\nF_t = \\begin{cases}\na_1, & \\text{当 } t < t_k \\text{ 时} \\\\\na_2, & \\text{当 } t \\ge t_k \\text{ 时}\n\\end{cases}\n$$\n这意味着潜在因素的持续性在时间 $t_k$ 发生变化。任务是量化这次断裂的影响。\n\n首先，必须为每组参数模拟状态路径 $\\{x_t\\}_{t=0}^{T}$ 和观测路径 $\\{y_t\\}_{t=0}^{T-1}$ 的单一样本路径。这通过使用一个确定性种子来初始化伪随机数生成器以确保可复现性来实现。初始状态 $x_0$ 从 $\\mathcal{N}(m_0, P_0)$ 中抽取。随后，对于从 0 到 $T-1$ 的每个时间步 $t$，根据 $x_t$ 生成观测值 $y_t$，并使用适当的转移参数 $F_t$ 从 $x_t$ 生成下一个状态 $x_{t+1}$。\n\n其次，我们必须使用生成的观测值 $\\{y_t\\}$ 来估计潜在状态路径。完成此任务的最优线性递归估计器是 Kalman 滤波器，它能生成给定截至当前时间的信息下的状态均值和方差的估计值，分别表示为 $m_{t|t} = \\mathbb{E}[x_t | y_0, \\dots, y_t]$ 和 $P_{t|t} = \\text{Var}(x_t | y_0, \\dots, y_t)$。该滤波器对每个时间点 $t$ 按两个步骤进行：\n\n1.  **预测 (Prediction)：** 基于截至 $t-1$ 的信息来预测时间 $t$ 的状态。\n    $$\n    m_{t|t-1} = F_{t-1} m_{t-1|t-1}\n    $$\n    $$\n    P_{t|t-1} = F_{t-1} P_{t-1|t-1} F_{t-1}^T + q\n    $$\n    该过程以 $m_{0|-1} = m_0$ 和 $P_{0|-1} = P_0$ 初始化。\n\n2.  **更新 (Update)：** 使用新的观测值 $y_t$ 来更新预测。\n    $$\n    \\tilde{y}_t = y_t - H m_{t|t-1} \\quad (\\text{新息})\n    $$\n    $$\n    S_t = H P_{t|t-1} H^T + r \\quad (\\text{新息协方差})\n    $$\n    $$\n    K_t = P_{t|t-1} H^T S_t^{-1} \\quad (\\text{Kalman 增益})\n    $$\n    $$\n    m_{t|t} = m_{t|t-1} + K_t \\tilde{y}_t \\quad (\\text{滤波均值})\n    $$\n    $$\n    P_{t|t} = (I - K_t H) P_{t|t-1} \\quad (\\text{滤波协方差})\n    $$\n\n第三，为了使用整个观测序列来获得每个时间 $t$ 状态的最佳可能估计，我们采用 Rauch-Tung-Striebel (RTS) 平滑器。RTS 平滑器是一个反向传递过程，它从最终的滤波估计 $m_{T-1|T-1}$ 和 $P_{T-1|T-1}$ 开始，并递归地计算平滑估计值 $m_{t|T-1} = \\mathbb{E}[x_t | y_0, \\dots, y_{T-1}]$ 和 $P_{t|T-1} = \\text{Var}(x_t | y_0, \\dots, y_{T-1})$。平滑器方程如下：\n$$\nJ_t = P_{t|t} F_t^T P_{t+1|t}^{-1} \\quad (\\text{平滑器增益})\n$$\n$$\nm_{t|T-1} = m_{t|t} + J_t (m_{t+1|T-1} - m_{t+1|t})\n$$\n$$\nP_{t|T-1} = P_{t|t} + J_t (P_{t+1|T-1} - P_{t+1|t}) J_t^T\n$$\n递归过程对 $t = T-2, T-3, \\dots, 0$ 运行。\n\n为了分析结构性断裂，在相同的模拟数据 $\\{y_t\\}$ 上估计了两个模型：\n1.  **考虑断裂的模型 (Break-Aware Model)：** 使用问题中定义的、真实的、时变的状态转移矩阵 $F_t$。\n2.  **无断裂模型 (No-Break Model)：** 一个错误设定的模型，它错误地假设在所有时间步 $t$ 中，$F_t = a_1$。\n\n最后，计算两个指定的度量：\n1.  **即时结构性响应** $D$，定义为 $D \\equiv |(a_2 - a_1) m_{t_k|t_k}|$。该度量量化了由 $a_1$ 切换到 $a_2$ 引起的单步预测 $m_{t_k+1|t_k}$ 的瞬时变化幅度。在旧机制下，预测值为 $a_1 m_{t_k|t_k}$，而在新机制下变为 $a_2 m_{t_k|t_k}$。值 $m_{t_k|t_k}$ 是来自考虑断裂的模型的滤波均值。\n\n2.  **平滑断裂调整值** $A$，定义为 $A \\equiv m^{\\text{break}}_{t_k|T-1} - m^{\\text{no-break}}_{t_k|T-1}$。该度量比较了在断裂时间 $t_k$，正确设定的考虑断裂的模型与错误设定的无断裂模型的全信息（平滑）状态估计。它衡量了关于断裂的知识及后续数据如何改变对断裂发生时刻状态的回溯性评估。\n\n计算过程包括为每个测试用例实现这些步骤，并按规定仔细管理模型参数和时间索引。", "answer": "```python\nimport numpy as np\n\ndef simulate_data(T, a1, a2, q, r, m0, P0, tk, seed):\n    \"\"\"\n    Simulates a latent path and observations for the state-space model.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    x = np.zeros(T + 1)\n    y = np.zeros(T)\n    \n    # Simulate initial state\n    x[0] = rng.normal(m0, np.sqrt(P0))\n    \n    # State-space model parameters\n    H = 1.0 # scalar\n    \n    # Simulation loop\n    for t in range(T):\n        # Generate observation\n        y[t] = H * x[t] + rng.normal(0, np.sqrt(r))\n        \n        # Determine transition matrix\n        Ft = a1 if t < tk else a2\n        \n        # Generate next state\n        x[t+1] = Ft * x[t] + rng.normal(0, np.sqrt(q))\n        \n    return x, y\n\ndef kalman_filter(y, F, q, H, r, m0, P0):\n    \"\"\"\n    Implements the Kalman filter for a 1D linear Gaussian state-space model.\n    F can be a time-varying array.\n    \"\"\"\n    T = len(y)\n    \n    # Arrays to store filtered and predicted estimates\n    m_filt = np.zeros(T)\n    P_filt = np.zeros(T)\n    m_pred = np.zeros(T + 1)\n    P_pred = np.zeros(T + 1)\n    \n    # Initialization\n    m_pred[0] = m0\n    P_pred[0] = P0\n    \n    for t in range(T):\n        # --- Update step using y[t] ---\n        # Use prediction from previous step (or initialization)\n        m_t_pred = m_pred[t]\n        P_t_pred = P_pred[t]\n        \n        # Innovation\n        y_tilde = y[t] - H * m_t_pred\n        S = H * P_t_pred * H + r\n        \n        # Kalman Gain\n        K = P_t_pred * H / S\n        \n        # Filtered estimates\n        m_filt[t] = m_t_pred + K * y_tilde\n        P_filt[t] = (1 - K * H) * P_t_pred\n        \n        # --- Prediction step for t+1 ---\n        # This occurs T times, from t=0 to t=T-1\n        Ft = F[t]\n        m_pred[t+1] = Ft * m_filt[t]\n        P_pred[t+1] = Ft * P_filt[t] * Ft + q\n        \n    return m_filt, P_filt, m_pred, P_pred\n\ndef rts_smoother(m_filt, P_filt, m_pred, P_pred, F):\n    \"\"\"\n    Implements the Rauch-Tung-Striebel smoother.\n    \"\"\"\n    T = len(m_filt)\n    \n    # Arrays to store smoothed estimates\n    m_smooth = np.zeros(T)\n    P_smooth = np.zeros(T)\n    \n    # Initialization at the last time step\n    m_smooth[T-1] = m_filt[T-1]\n    P_smooth[T-1] = P_filt[T-1]\n    \n    # Backward pass\n    for t in range(T - 2, -1, -1):\n        Ft = F[t]\n        # Smoother gain\n        J = P_filt[t] * Ft / P_pred[t+1]\n        \n        # Smoothed estimates\n        m_smooth[t] = m_filt[t] + J * (m_smooth[t+1] - m_pred[t+1])\n        P_smooth[t] = P_filt[t] + J * (P_smooth[t+1] - P_pred[t+1]) * J\n        \n    return m_smooth, P_smooth\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and compute metrics.\n    \"\"\"\n    test_cases = [\n        # (T, a1, a2, q, r, m0, P0, tk)\n        (60, 0.9, 0.5, 0.04, 0.09, 0.0, 1.0, 30),\n        (50, 0.95, 0.2, 0.01, 0.04, 0.0, 1.0, 1),\n        (60, 0.9, 0.9, 0.04, 0.04, 0.0, 1.0, 30),\n        (60, 0.7, -0.7, 0.04, 0.01, 0.0, 1.0, 59),\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        T, a1, a2, q, r, m0, P0, tk = case\n        \n        # 1. Simulate data using a deterministic seed for the case\n        seed = 12345 + i\n        _, y_sim = simulate_data(T, a1, a2, q, r, m0, P0, tk, seed)\n        \n        H = 1.0\n\n        # --- Break-Aware Model ---\n        F_break = np.array([a1 if t < tk else a2 for t in range(T)])\n        \n        m_filt_break, P_filt_break, m_pred_break, P_pred_break = kalman_filter(y_sim, F_break, q, H, r, m0, P0)\n        \n        m_smooth_break, _ = rts_smoother(m_filt_break, P_filt_break, m_pred_break, P_pred_break, F_break)\n        \n        # --- No-Break Model ---\n        F_nobreak = np.full(T, a1)\n        \n        m_filt_nobreak, P_filt_nobreak, m_pred_nobreak, P_pred_nobreak = kalman_filter(y_sim, F_nobreak, q, H, r, m0, P0)\n\n        m_smooth_nobreak, _ = rts_smoother(m_filt_nobreak, P_filt_nobreak, m_pred_nobreak, P_pred_nobreak, F_nobreak)\n\n        # 2. Compute metrics\n        # Metric D: Immediate structural response\n        m_tk_filt_break = m_filt_break[tk]\n        D = np.abs((a2 - a1) * m_tk_filt_break)\n        \n        # Metric A: Smoothed break adjustment\n        m_tk_smooth_break = m_smooth_break[tk]\n        m_tk_smooth_nobreak = m_smooth_nobreak[tk]\n        A = m_tk_smooth_break - m_tk_smooth_nobreak\n        \n        results.extend([D, A])\n\n    # Final print statement in the exact required format\n    formatted_results = [f'{v:.6f}' for v in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}