{"hands_on_practices": [{"introduction": "我们的第一个动手实践将从最基本的随机过程——白噪声——开始。在理论上，白噪声的功率谱在所有频率上都是恒定的，即“平坦”的。本练习的目标是将这个抽象概念与具体的计算结果联系起来：我们将生成一个模拟公平抛硬币的随机二进制序列，并计算其功率谱密度。通过这个过程，你不仅将掌握从时域信号计算周期图的基本步骤，还将学会如何量化频谱的平坦度，为理解更复杂的信号谱打下坚实基础 [@problem_id:2428968]。", "problem": "考虑一个离散时间随机过程，该过程通过对一个独立同分布的公平硬币投掷序列进行采样，并将结果映射到两个固定幅值而得到。设采样间隔为 $\\Delta t$ 秒，因此采样频率为 $1/\\Delta t$ 赫兹。设 $N$ 为样本数。设两个结果幅值为 $a$ 和 $b$，视为无量纲。设生成的序列为 $s[n] \\in \\{a,b\\}$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，并定义零均值序列 $x[n] = s[n] - \\overline{s}$，其中 $\\overline{s}$ 是 $s[n]$ 的样本均值。定义离散傅里叶变换 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi k n / N}$，其中整数 $k \\in \\{0,1,\\dots,N-1\\}$，并为偶数 $N$ 定义在正频率仓处的单边功率谱密度估计（单位为幅值的平方每赫兹）为\n$$\n\\widehat{S}[k] = \\frac{2\\,\\Delta t}{N} \\left| X[k] \\right|^2 \\quad \\text{for} \\quad k \\in \\{1,2,\\dots,N/2-1\\}.\n$$\n将平坦度度量定义为估计的功率谱密度在除直流分量仓和奈奎斯特仓之外的正频率仓上的变异系数，\n$$\nF = \\frac{\\operatorname{std}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}{\\operatorname{mean}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)},\n$$\n该度量是无量纲的。白过程表现为平坦谱。\n\n为了确保不同实现之间的测试用例具有确定性，$s[n]$ 序列必须通过变换一个均匀伪随机数生成器来生成，其定义如下。设一个整数线性同余生成器通过 $x_{n+1} = (a_{\\mathrm{LCG}} x_n) \\bmod m$ 产生序列 $\\{x_n\\}$，其中 $a_{\\mathrm{LCG}} = 16807$ 且 $m = 2147483647$，从种子 $x_0$ 开始，该种子是小于 $m$ 的严格正整数。定义 $u_n = x_n / m$ 并设置 $s[n] = a$ (如果 $u_n < 0.5$) 或 $s[n] = b$ (其他情况)。谱估计步骤中的所有算术运算必须以实数或复数浮点形式进行，并且不应应用除上述规定之外的任何额外加窗或平均处理。\n\n实现一个程序，对每个指定的测试用例，生成 $s[n]$，构造 $x[n]$，计算 $k \\in \\{1,2,\\dots,N/2-1\\}$ 的 $\\widehat{S}[k]$，并以浮点数形式输出平坦度度量 $F$。频率应解释为赫兹，功率谱密度应解释为幅值的平方每赫兹，但报告的 $F$ 是无量纲的。如果在中间计算中出现任何角度，则必须以弧度为单位。\n\n使用以下参数值测试套件，其中每个测试用例是一个元组 $(N,\\Delta t,a,b,x_0)$：\n- 测试用例 1：$(4096, 1.0 \\times 10^{-3}, 0, 1, 12345)$。\n- 测试用例 2：$(256, 1.0 \\times 10^{-3}, 0, 1, 67890)$。\n- 测试用例 3：$(65536, 1.0 \\times 10^{-4}, -1, 1, 13579)$。\n- 测试用例 4：$(8192, 1.0, 0, 1, 24680)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与上述测试用例相同。例如，输出格式必须与 $[r_1,r_2,r_3,r_4]$ 完全一样，其中每个 $r_j$ 是测试用例 $j$ 计算出的 $F$ 的浮点值。", "solution": "所述问题需进行验证。\n\n**步骤1：提取已知条件**\n-   随机过程：一个离散时间序列 $s[n]$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，源自从独立同分布（i.i.d.）的公平硬币投掷映射到幅值 $a$ 和 $b$ 而来。\n-   采样参数：采样间隔 $\\Delta t$（秒）；样本数 $N$。\n-   信号生成：线性同余生成器 (LCG) 定义为 $x_{n+1} = (a_{\\mathrm{LCG}} x_n) \\bmod m$，其中 $a_{\\mathrm{LCG}} = 16807$，$m = 2147483647$。种子 $x_0$ 是一个小于 $m$ 的正整数。生成序列 $u_n = x_n / m$，如果 $u_n < 0.5$，则 $s[n] = a$，否则 $s[n] = b$。\n-   零均值信号：$x[n] = s[n] - \\overline{s}$，其中 $\\overline{s} = \\frac{1}{N}\\sum_{n=0}^{N-1} s[n]$。\n-   离散傅里叶变换 (DFT)：$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi k n / N}$，其中 $k \\in \\{0,1,\\dots,N-1\\}$。\n-   功率谱密度 (PSD) 估计：对于偶数 $N$，单边 PSD 估计为 $\\widehat{S}[k] = \\frac{2\\,\\Delta t}{N} \\left| X[k] \\right|^2$，其中 $k \\in \\{1,2,\\dots,N/2-1\\}$。\n-   平坦度度量：$F = \\frac{\\operatorname{std}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}{\\operatorname{mean}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}$。\n-   测试用例 $(N,\\Delta t,a,b,x_0)$:\n    1.  $(4096, 1.0 \\times 10^{-3}, 0, 1, 12345)$\n    2.  $(256, 1.0 \\times 10^{-3}, 0, 1, 67890)$\n    3.  $(65536, 1.0 \\times 10^{-4}, -1, 1, 13579)$\n    4.  $(8192, 1.0, 0, 1, 24680)$\n\n**步骤2：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估。\n-   **科学依据**：该问题描述了离散信号功率谱密度估计的程序，这是数字信号处理和计算物理学中的一个标准课题。信号模型（伯努利过程）和分析工具（DFT，周期图）是基本概念。指定的 LCG 是一个有据可查的生成器。该问题牢固地建立在公认的科学和数学原理之上。\n-   **良构性**：所有参数、常量和计算步骤都得到了明确无误的定义。使用具有给定种子的特定伪随机数生成器确保了信号生成是确定性的，从而为每个测试用例得出一个唯一的、可计算的解。\n-   **客观性**：问题以精确、客观、数学化的语言陈述，没有主观论断。定义是形式化的，允许对所需计算进行单一、正确的解释。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。它是自洽的、科学上合理的、并且是良构的。该任务是信号分析中的一个标准计算练习。将提供一个解决方案。\n\n**基于原理的解决方案设计**\n\n该问题要求计算一个确定性生成的随机信号的估计功率谱密度 (PSD) 的一个统计度量，即平坦度 $F$。解决方案是通过遵循所提供的一系列物理和数学定义来构建的。\n\n**1. 信号生成**\n问题的基础是生成离散时间信号 $s[n]$。该信号旨在模拟一个随机过程。它是使用一个特定的线性同余生成器 (LCG) 生成的，这是一种生成伪随机数序列的常用算法。LCG 由递推关系定义：\n$$\nx_{i+1} = (a_{\\mathrm{LCG}} \\cdot x_i) \\pmod m\n$$\n其中乘数 $a_{\\mathrm{LCG}} = 16807$，模数 $m = 2147483647$。从给定的种子 $x_0$ 开始，我们生成一个包含 $N$ 个状态的序列 $x_1, x_2, \\dots, x_N$。然后将这些整数状态归一化，以产生均匀偏差量 $u_n = x_{n+1}/m$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。基于 $0.5$ 的阈值进行二元映射，将此均匀序列转换为具有幅值 $a$ 和 $b$ 的双能级信号 $s[n]$：\n$$\ns[n] = \\begin{cases} a & \\text{if } u_n < 0.5 \\\\ b & \\text{if } u_n \\ge 0.5 \\end{cases}\n$$\n\n**2. 信号调理**\n原始信号 $s[n]$ 具有非零均值，这对应其频谱中的一个大的直流分量 ($k=0$)。为了分析信号的波动（交流）部分，需要移除此直流偏移。我们计算样本均值 $\\overline{s} = \\frac{1}{N}\\sum_{n=0}^{N-1} s[n]$ 并创建一个零均值信号 $x[n]$：\n$$\nx[n] = s[n] - \\overline{s}\n$$\n此步骤确保零频率处的功率 $X[0]$ 为零，从而将分析集中在信号的动态特性上。\n\n**3. 通过离散傅里叶变换进行频谱分析**\n离散信号 $x[n]$ 的频率内容通过其离散傅里叶变换 (DFT) $X[k]$ 来揭示：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi k n / N}\n$$\nDFT 系数的幅值平方 $|X[k]|^2$ 被称为周期图，它与信号在对应于索引 $k$ 的离散频率处的功率成正比。为了提高计算效率，DFT 使用快速傅里叶变换 (FFT) 算法进行计算。\n\n**4. 功率谱密度估计**\n周期图必须被正确缩放以表示物理上的功率谱密度，其单位为功率每单位频率（这里是 幅值$^2$/Hz）。对于一个长度为 $N$ 的实值信号，远离直流 ($k=0$) 和奈奎斯特频率 ($k=N/2$) 的正频率的单边PSD估计 $\\widehat{S}[k]$ 由下式给出：\n$$\n\\widehat{S}[k] = \\frac{2\\,\\Delta t}{N} |X[k]|^2\n$$\n因子 $2$ 是为了将负频率（对于实信号是冗余的）的功率折叠到正频率上。因子 $\\Delta t / N$ 将单位从幅值$^2$每DFT仓转换为幅值$^2$每Hz，因为DFT的频率分辨率是 $\\Delta f = 1/(N\\Delta t)$。此计算是针对频率索引 $k \\in \\{1, 2, \\dots, N/2 - 1\\}$ 执行的。\n\n**5. 平坦度度量计算**\n被建模的过程是白噪声过程的一个近似，理论上白噪声具有平坦的功率谱（在所有频率上功率相等）。估计谱的平坦度由平坦度度量 $F$ 来量化，定义为计算出的PSD值集合 $\\{\\widehat{S}[k]\\}$ 的变异系数（标准差与均值的比率）。\n$$\nF = \\frac{\\operatorname{std}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}{\\operatorname{mean}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}\n$$\n接近 $0$ 的 $F$ 值意味着一个近乎恒定（平坦）的谱，而较大的值则表明在频率仓之间存在显著的功率变化。对于白噪声的周期图估计，不同频率下的值 $\\widehat{S}[k]$ 近似独立且呈指数分布，其理论变异系数为 $1$。样本变异系数 $F$ 是该值的估计。\n\n实现将为问题陈述中指定的每个测试用例系统地执行这五个步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the power spectral density flatness problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        (4096, 1.0e-3, 0.0, 1.0, 12345),\n        (256, 1.0e-3, 0.0, 1.0, 67890),\n        (65536, 1.0e-4, -1.0, 1.0, 13579),\n        (8192, 1.0, 0.0, 1.0, 24680),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, delta_t, a, b, x0 = case\n        result = calculate_flatness(N, delta_t, a, b, x0)\n        results.append(result)\n\n    # Format the output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_flatness(N, delta_t, a, b, x0):\n    \"\"\"\n    Calculates the spectral flatness metric F for a given set of parameters.\n\n    Args:\n        N (int): Number of samples.\n        delta_t (float): Sampling interval in seconds.\n        a (float): First outcome amplitude.\n        b (float): Second outcome amplitude.\n        x0 (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        float: The computed flatness metric F.\n    \"\"\"\n    \n    # LCG parameters from the problem statement\n    A_LCG = 16807\n    M = 2147483647\n\n    # Step 1: Generate the signal sequence s[n] using the LCG.\n    # The LCG generates N states x_1, ..., x_N from the seed x_0.\n    # These states are used to generate s[0], ..., s[N-1].\n    s = np.zeros(N, dtype=np.float64)\n    x_current = x0\n    for n in range(N):\n        x_current = (A_LCG * x_current) % M\n        u_n = x_current / M\n        if u_n < 0.5:\n            s[n] = a\n        else:\n            s[n] = b\n\n    # Step 2: Create the zero-mean sequence x[n].\n    s_mean = np.mean(s)\n    x = s - s_mean\n\n    # Step 3: Compute the Discrete Fourier Transform (DFT).\n    #\n    # np.fft.fft provides an efficient implementation (FFT).\n    X = np.fft.fft(x)\n\n    # Step 4: Compute the single-sided Power Spectral Density (PSD) estimate.\n    # The problem specifies the range for k from 1 to N/2 - 1.\n    # In Python's 0-based indexing, this corresponds to the slice [1:N//2].\n    # N is guaranteed to be even in all test cases.\n    N_div_2 = N // 2\n    \n    # Extract the relevant DFT components.\n    X_pos = X[1:N_div_2]\n    \n    # Calculate the PSD S_hat[k] = (2 * dt / N) * |X[k]|^2.\n    S_hat = (2 * delta_t / N) * np.abs(X_pos)**2\n\n    # Step 5: Compute the flatness metric F.\n    # F is the coefficient of variation (std/mean) of the PSD values.\n    # np.std uses a divisor of M (number of elements) by default (ddof=0),\n    # which is appropriate here.\n    mean_S = np.mean(S_hat)\n    std_S = np.std(S_hat)\n\n    # Handle the case where the mean is zero to avoid division by zero.\n    if mean_S == 0:\n        return 0.0\n\n    F = std_S / mean_S\n    return F\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2428968"}, {"introduction": "在理想世界中，信号的频率总是恰好落在离散傅里叶变换 (DFT) 的频率格点上，但现实并非如此。本练习将引导你直面数字信号处理中的一个核心挑战：频谱泄漏。我们将分析一个频率偏离 DFT 格点的纯正弦信号，你会亲眼看到其能量是如何“泄漏”到邻近频率仓中，形成一个看似复杂的频谱。更重要的是，本练习将向你展示如何通过应用窗口函数（如此处使用的汉宁窗）来显著抑制这种泄漏，从而获得更准确、更清晰的频谱估计 [@problem_id:2429045]。这项技能对于任何严肃的频谱分析工作都至关重要。", "problem": "给定一个经过均匀时间采样的纯正弦波，您的任务是使用离散傅里叶变换（DFT）进行功率谱密度估计，以演示频谱泄漏现象。从基本定义开始：一个长度为 $N$ 的离散时间序列 $x[n]$ 的离散傅里叶变换（DFT）为 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N}$，其中 $k \\in \\{0,1,\\dots,N-1\\}$，$j$ 是虚数单位。采样频率为 $F_s$，因此采样间隔为 $\\Delta t = 1/F_s$，DFT 的频率分辨率为 $\\Delta f = F_s/N$。加窗操作由一个实数序列 $w[n]$ 定义，它逐点应用于 $x[n]$，生成 $x_w[n]=w[n]x[n]$。使用离散时间能量守恒（Parseval 关系）以及这些定义，构建一个带有适当窗函数功率归一化的功率谱密度（PSD）单边周期图估计器。所有三角函数的参数都必须以弧度为单位。\n\n您的程序必须：\n- 构建离散时间信号 $x[n] = \\sin(2\\pi f_0 n / F_s)$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。\n- 应用一个选定的窗函数 $w[n]$（矩形窗 $w[n]=1$ 或 Hann 窗 $w[n] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$）来形成 $x_w[n]=w[n]x[n]$。\n- 计算一个 $N$ 点 DFT（无零填充），并为频率 $f_k = k \\Delta f$（其中 $k \\in \\{0,1,\\dots,\\tfrac{N}{2}\\}$）形成一个单边周期图 PSD 估计 $P[k]$，使用基于窗函数平方平均值的窗函数功率归一化。确保当 $N$ 为偶数时，通过将严格位于直流（DC）和奈奎斯特频率之间的频率点的功率加倍，来正确补偿单边谱中舍弃的负频率内容。\n- 将泄漏比 $\\mathcal{L}$ 定义为位于峰值周围主瓣之外的单边总谱功率的比例。此处的“主瓣”在操作上定义为 PSD 值在峰值的 $-6$ 分贝范围内的频率点集合。用符号表示：找到峰值点索引 $k_{\\max}$，使得 $P[k_{\\max}]$ 最大；定义主瓣索引集 $\\mathcal{M} = \\{k : 10 \\log_{10}(P[k]/P[k_{\\max}]) \\ge -6\\}$；然后计算泄漏比 $\\mathcal{L} = 1 - \\dfrac{\\sum_{k \\in \\mathcal{M}} P[k]}{\\sum_{k} P[k]}$。分贝转换使用 $10 \\log_{10}(\\cdot)$ 应用于功率比。\n- 对于每个测试用例，将泄漏比输出为浮点数。正弦波的振幅为 $1$。\n\n测试套件：\n- 用例 1（非整数频率点，矩形窗）：$F_s = 1024 \\,\\mathrm{Hz}$，$N = 1024$，$f_0 = 128.5 \\,\\mathrm{Hz}$，窗类型“rectangular”。\n- 用例 2（非整数频率点，Hann 窗）：$F_s = 1024 \\,\\mathrm{Hz}$，$N = 1024$，$f_0 = 128.5 \\,\\mathrm{Hz}$，窗类型“Hann”。\n- 用例 3（精确频率点，矩形窗）：$F_s = 1024 \\,\\mathrm{Hz}$，$N = 1024$，$f_0 = 128.0 \\,\\mathrm{Hz}$，窗类型“rectangular”。\n- 用例 4（小偏移，矩形窗）：$F_s = 1024 \\,\\mathrm{Hz}$，$N = 1024$，$f_0 = 128.01 \\,\\mathrm{Hz}$，窗类型“rectangular”。\n- 用例 5（短记录，非整数频率点，矩形窗）：$F_s = 256 \\,\\mathrm{Hz}$，$N = 256$，$f_0 = 50.3 \\,\\mathrm{Hz}$，窗类型“rectangular”。\n\n角度单位要求：所有用于三角函数的角度必须以弧度为单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述顺序列出的五个用例的泄漏比，格式为方括号括起来的逗号分隔列表，每个泄漏比四舍五入到六位小数，例如：“$[0.123456,0.234567,0.345678,0.456789,0.567890]$”。", "solution": "所提出的问题是计算物理学领域中的一个有效且适定的练习，特别是在数字信号处理领域。它要求在不同条件下，根据纯正弦信号的周期图估计来计算频谱泄漏。所提供的定义是标准的且自洽的，从而能够得出一个直接而明确的解。\n\n该解法从第一性原理出发，系统地进行推导。\n\n**1. 信号与加窗模型**\n\n离散时间信号是一个振幅为 $A=1$ 的纯正弦波，以频率 $F_s$ 采样 $N$ 个点。信号定义为：\n$$x[n] = \\sin\\left(\\frac{2\\pi f_0 n}{F_s}\\right), \\quad n \\in \\{0, 1, \\dots, N-1\\}$$\n其中 $f_0$ 是正弦波的频率。\n\n该信号随后与一个窗函数 $w[n]$ 相乘，以产生加窗信号 $x_w[n]$：\n$$x_w[n] = w[n] x[n]$$\n问题指定了两种窗类型：\n- **矩形窗**：$w[n] = 1$ 对所有 $n$。\n- **Hann 窗**：$w[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$。\n\n**2. 功率谱估计**\n\n问题的核心是构建一个经过适当归一化的单边功率谱。我们从加窗信号的离散傅里叶变换（DFT）开始：\n$$X_w[k] = \\sum_{n=0}^{N-1} x_w[n] e^{-j 2\\pi kn/N}$$\n\n为确保估计的功率与窗函数的增益无关，我们必须对频谱进行归一化。离散信号的 Parseval 定理将信号在时域中的能量与其在频域中的能量联系起来：\n$$\\sum_{n=0}^{N-1} |x_w[n]|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_w[k]|^2$$\n加窗信号在 $N$ 个采样点上的平均功率为 $P_{\\text{avg},w} = \\frac{1}{N} \\sum_{n=0}^{N-1} |x_w[n]|^2$。因此：\n$$P_{\\text{avg},w} = \\frac{1}{N^2} \\sum_{k=0}^{N-1} |X_w[k]|^2$$\n原始信号 $x[n]$ 的平均功率与加窗信号的平均功率相关。对于正弦信号，加窗过程会按一个等于窗函数均方值的因子来缩放功率。因此，原始信号的估计平均功率 $P_{\\text{avg},x}$ 为：\n$$P_{\\text{avg},x} = \\frac{P_{\\text{avg},w}}{\\frac{1}{N}\\sum_{n=0}^{N-1} w[n]^2} = \\frac{N}{\\sum_{n=0}^{N-1} w[n]^2} P_{\\text{avg},w}$$\n我们将窗权重平方和表示为 $S_2 = \\sum_{n=0}^{N-1} w[n]^2$。原始信号的总估计功率为：\n$$P_{\\text{total}} = P_{\\text{avg},x} = \\frac{N}{S_2} \\left( \\frac{1}{N^2} \\sum_{k=0}^{N-1} |X_w[k]|^2 \\right) = \\frac{1}{S_2 N} \\sum_{k=0}^{N-1} |X_w[k]|^2$$\n对于实值输入信号 $x[n]$，其 DFT 具有共轭对称性：$X_w[k] = X_w^*[N-k]$。这意味着 $|X_w[k]|^2 = |X_w[N-k]|^2$。我们可以为 $k \\in \\{0, 1, \\dots, N/2\\}$ 构建一个保持总功率不变的单边功率谱 $P[k]$。对双边谱的求和可以重写为（对于偶数 $N$）：\n$$\\sum_{k=0}^{N-1} |X_w[k]|^2 = |X_w[0]|^2 + |X_w[N/2]|^2 + 2\\sum_{k=1}^{N/2-1} |X_w[k]|^2$$\n我们定义单边功率谱 $P[k]$，使其总和等于总平均功率 $P_{\\text{total}}$。$P[k]$ 的分量是包含在每个频率点 $k$ 中的功率：\n$$P[k] = \\begin{cases} \\frac{1}{S_2 N} |X_w[k]|^2 & \\text{对于 } k=0 \\text{ 和 } k=N/2 \\\\ \\frac{2}{S_2 N} |X_w[k]|^2 & \\text{对于 } k=1, 2, \\dots, N/2-1 \\end{cases}$$\n总和 $\\sum_{k=0}^{N/2} P[k]$ 正确地得出了原始信号的总平均功率。鉴于 $x[n]$ 是一个振幅为 $A=1$ 的正弦波，其真实平均功率为 $A^2/2 = 1/2$。我们的估计量 $\\sum P[k]$ 将近似于这个值。\n\n**3. 泄漏比计算**\n\n频谱泄漏比 $\\mathcal{L}$ 定义为位于谱峰主瓣之外的总功率比例。\n首先，我们找到功率谱的最大值 $P_{\\max} = \\max_k P[k]$。主瓣在操作上定义为功率在峰值的 $-6$ 分贝范围内的频率点集合 $\\mathcal{M}$：\n$$\\mathcal{M} = \\left\\{k \\mid 10 \\log_{10}\\left(\\frac{P[k]}{P_{\\max}}\\right) \\ge -6\\right\\}$$\n这个不等式等价于 $P[k] \\ge P_{\\max} \\cdot 10^{-0.6}$。\n\n主瓣中的总功率为 $P_{\\text{lobe}} = \\sum_{k \\in \\mathcal{M}} P[k]$。整个频谱的总功率为 $P_{\\text{total}} = \\sum_{k=0}^{N/2} P[k]$。\n然后，泄漏比计算如下：\n$$\\mathcal{L} = 1 - \\frac{P_{\\text{lobe}}}{P_{\\text{total}}}$$\n\n对每个测试用例实施此过程，以确定在指定条件下的泄漏比。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the spectral leakage ratio for a sinusoidal signal under various\n    windowing and frequency conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Fs, N, f0, window_type)\n        (1024.0, 1024, 128.5, \"rectangular\"),\n        (1024.0, 1024, 128.5, \"Hann\"),\n        (1024.0, 1024, 128.0, \"rectangular\"),\n        (1024.0, 1024, 128.01, \"rectangular\"),\n        (256.0, 256, 50.3, \"rectangular\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        Fs, N, f0, window_type = case\n        \n        # 1. Signal Generation\n        # Construct the time vector for N samples.\n        n = np.arange(N)\n        # Generate the sinusoidal signal with amplitude 1.\n        x = np.sin(2 * np.pi * f0 * n / Fs)\n\n        # 2. Windowing\n        # Apply the specified window function.\n        if window_type == \"rectangular\":\n            w = np.ones(N)\n        elif window_type == \"Hann\":\n            # Per problem: w[n] = 1/2 * (1 - cos(2*pi*n / (N-1)))\n            w = 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1)))\n        \n        x_w = x * w\n\n        # 3. N-point DFT\n        # Compute the DFT of the windowed signal.\n        X_w = np.fft.fft(x_w, n=N)\n\n        # 4. One-sided Power Spectrum Estimation\n        # All test cases have even N. The one-sided spectrum has N/2 + 1 points.\n        num_freq_bins = N // 2 + 1\n        X_w_mag_sq = np.abs(X_w[0:num_freq_bins])**2\n        \n        # Calculate the sum of squares of the window for normalization.\n        S2 = np.sum(w**2)\n        \n        # Initialize the power spectrum array.\n        P = np.zeros(num_freq_bins)\n        \n        # Normalization ensures the sum of P[k] approximates the true signal power (0.5).\n        # Normalization constant for DC and Nyquist bins.\n        norm_const_dc_nyquist = 1.0 / (S2 * N)\n        # Normalization constant for other bins (doubled for one-sided spectrum).\n        norm_const_other = 2.0 / (S2 * N)\n\n        # Calculate power for bins from k=1 to k=N/2 - 1.\n        P[1:-1] = norm_const_other * X_w_mag_sq[1:-1]\n        \n        # Calculate power for DC (k=0) and Nyquist (k=N/2) bins.\n        P[0] = norm_const_dc_nyquist * X_w_mag_sq[0]\n        P[-1] = norm_const_dc_nyquist * X_w_mag_sq[-1]\n\n        # 5. Leakage Ratio Calculation\n        P_total = np.sum(P)\n        \n        # Handle the ideal case where total power is numerically zero.\n        if P_total < 1e-15:\n            leakage_ratio = 0.0\n        else:\n            P_max = np.max(P)\n            # Main lobe is defined as all bins within -6 dB of the peak value.\n            # This corresponds to a linear magnitude ratio of 10^(-6/10).\n            db_threshold_ratio = 10**(-6.0 / 10.0)\n            main_lobe_mask = P >= P_max * db_threshold_ratio\n            \n            # Sum the power within the main lobe.\n            P_lobe = np.sum(P[main_lobe_mask])\n            \n            # Leakage ratio is the fraction of power outside the main lobe.\n            leakage_ratio = 1.0 - (P_lobe / P_total)\n            \n        results.append(leakage_ratio)\n\n    # Final print statement in the exact required format.\n    # Format each result to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2429045"}, {"introduction": "掌握了基本谱估计和泄漏抑制的技巧后，我们可以将这些工具应用于探索更有趣的物理现象。这个实践模拟了一个非线性系统——在这个例子中，我们通过对信号进行平方操作来实现。在许多物理和工程领域，非线性效应会产生新的频率成分，即所谓的“和频”与“差频”。本练习将指导你使用更稳健的韦尔奇方法 (Welch's method) 来分析一个经过平方处理的双音信号，并从噪声中识别出这些由非线性混合产生的标志性频率峰值。这不仅展示了功率谱密度作为一种研究非线性动力学工具的强大能力，也让你熟悉了一种在实践中更为常用和可靠的谱估计算法 [@problem_id:2429016]。", "problem": "您将使用功率谱密度估计，在离散时间域中实现并分析一个非线性混频实验。您必须依赖的基础理论包括：傅里叶变换作为连接时域和频域描述的线性变换的定义，奈奎斯特采样定理（该定理约束了给定采样率下可分辨的频率），功率谱密度（PSD）作为自相关函数的傅里叶变换的定义（维纳-辛钦定理），以及时域中的乘法对应于频域中的卷积这一性质。在您的推导中，不得使用任何其他预先推导的或简化的公式。角度必须以弧度为单位。\n\n构建一个离散时间信号，该信号是两个正弦波的和，其频率、采样率和相位由用户指定。添加零均值白高斯噪声，将带噪信号平方，使用 Welch 方法估计平方信号的单边功率谱密度（PSD），并检测由非线性混频预测出的对应于和频与差频的谱峰。\n\n任务和约束：\n- 信号模型和单位：\n  - 令采样频率为 $f_s$（单位 $\\mathrm{Hz}$），样本数量为 $N$（无量纲）。定义离散时间点为 $t_n = n / f_s$（单位 $\\mathrm{s}$），其中 $n \\in \\{0,1,\\dots,N-1\\}$。\n  - 构建一个纯净信号 $x[n] = A_1 \\sin\\!\\left(2\\pi f_1 t_n + \\phi_1\\right) + A_2 \\sin\\!\\left(2\\pi f_2 t_n + \\phi_2\\right)$，其中 $A_1$ 和 $A_2$ 是振幅（无量纲），$f_1$ 和 $f_2$ 是频率（单位 $\\mathrm{Hz}$），$\\phi_1, \\phi_2$ 是相位（单位 $\\mathrm{rad}$）。\n  - 添加标准差为 $\\sigma_n$（无量纲）的零均值白高斯噪声 $\\eta[n]$，形成 $u[n] = x[n] + \\eta[n]$。\n  - 形成平方信号 $y[n] = \\left(u[n]\\right)^2$。\n- PSD 估计：\n  - 使用 Welch 方法和汉宁窗估计单边 PSD $S_{yy}(f)$。使用段长度 $L$ 为不超过 $N/2$ 的最大 2 的幂，但至少为 $256$ 个样本。使用段长度的 $0.5$ 作为重叠。使用密度标度，使 $S_{yy}(f)$ 的单位为信号功率/$\\mathrm{Hz}$。\n  - 频率轴的单位必须是 $\\mathrm{Hz}$。\n- 非线性混频的峰值检测：\n  - 定义理论目标频率 $f_{\\mathrm{sum}} = f_1 + f_2$ 和 $f_{\\mathrm{diff}} = |f_1 - f_2|$，单位均为 $\\mathrm{Hz}$。确保所有指定用例都满足 $f_{\\mathrm{sum}} \\le f_s/2$，以使和频分量不超出奈奎斯特频率。\n  - 令 Welch 频率仓间距为 $\\Delta f = f_s / L$。对于每个目标 $f_0 \\in \\{f_{\\mathrm{sum}}, f_{\\mathrm{diff}}\\}$，在围绕 $f_0$ 的半宽度为 $w = \\max\\{5, 3\\Delta f\\}$（单位 $\\mathrm{Hz}$）的对称频率窗口内搜索主导 PSD 峰值。如果 $f_0 = 0$，则在 $[0, w]$ 范围内搜索。\n  - 将正确检测的容差定义为 $\\tau = \\max\\{\\Delta f, 0.5\\}$（单位 $\\mathrm{Hz}$）。如果估计的峰值位置 $\\hat f$ 与目标 $f_0$ 之间的绝对差值至多为 $\\tau$，则报告一个为真的检测布尔值。\n- 输出规格：\n  - 对于每个测试用例，返回一个包含四个值的列表：估计的和频峰值 $\\hat f_{\\mathrm{sum}}$（单位 $\\mathrm{Hz}$，四舍五入到三位小数），估计的差频峰值 $\\hat f_{\\mathrm{diff}}$（单位 $\\mathrm{Hz}$，四舍五入到三位小数），和频分量的检测布尔值，以及差频分量的检测布尔值。\n  - 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。顶层列表必须为每个测试用例包含一个这样的四元素列表。例如，总输出必须类似于 $[\\,[\\hat f_{\\mathrm{sum}}^{(1)}, \\hat f_{\\mathrm{diff}}^{(1)}, \\mathrm{det}_{\\mathrm{sum}}^{(1)}, \\mathrm{det}_{\\mathrm{diff}}^{(1)}], \\dots ]$。\n- 角度单位：所有角度必须以 $\\mathrm{rad}$ 为单位。所有频率必须以 $\\mathrm{Hz}$ 表示。\n\n测试套件：\n对于每个测试用例，参数元组为 $(f_s, N, f_1, f_2, A_1, A_2, \\sigma_n, \\mathrm{seed})$，其值如下：\n- 用例 1：$(2000, 4096, 123, 278, 1.0, 0.8, 0.2, 42)$，因此 $f_{\\mathrm{sum}} = 401$ 且 $f_{\\mathrm{diff}} = 155$。\n- 用例 2：$(1200, 4096, 280, 300, 1.0, 1.0, 0.15, 7)$，因此 $f_{\\mathrm{sum}} = 580$ 且 $f_{\\mathrm{diff}} = 20$。\n- 用例 3：$(1000, 4096, 200, 200, 0.7, 0.7, 0.1, 0)$，因此 $f_{\\mathrm{sum}} = 400$ 且 $f_{\\mathrm{diff}} = 0$。\n- 用例 4：$(2000, 16384, 245, 250, 0.9, 1.0, 0.3, 123)$，因此 $f_{\\mathrm{sum}} = 495$ 且 $f_{\\mathrm{diff}} = 5$。\n\n要求：\n- 将您的解决方案实现为一个完整的、可运行的程序，该程序能够构建信号，使用指定的 Welch 配置计算 PSD 估计，按规定在 $f_{\\mathrm{sum}}$ 和 $f_{\\mathrm{diff}}$ 附近搜索峰值，并以所描述的精确格式输出结果。使用提供的种子进行随机数生成，以确保可复现性。", "solution": "所提出的问题是计算物理学和信号处理领域中一个明确定义的练习。它要求实现一个数值实验来演示非线性混频现象。在进行计算求解之前，必须先建立分析所依据的理论基础。该问题陈述被认为是有效的，因为它具有科学依据、自成体系且算法上是明确的。关于信号相位的一个微小模糊之处，通过采纳将其设置为零的标准约定得以解决，因为在指定条件下，所得信号的功率谱对这一选择基本上不敏感。\n\n问题的核心在于对一个复合正弦信号进行平方，这是一个非线性运算。让我们首先在没有噪声的情况下分析此运算的效果。信号由 $x[n] = A_1 \\sin(2\\pi f_1 t_n + \\phi_1) + A_2 \\sin(2\\pi f_2 t_n + \\phi_2)$ 给出。为简单起见，且在不失此功率谱分析一般性的前提下，我们设置相位 $\\phi_1=0$ 和 $\\phi_2=0$。记 $\\omega_i = 2\\pi f_i$ 和 $t_n = n/f_s$，平方后的信号为：\n$$\ny[n] = (x[n])^2 = \\left( A_1 \\sin(\\omega_1 t_n) + A_2 \\sin(\\omega_2 t_n) \\right)^2\n$$\n展开此表达式可得：\n$$\ny[n] = A_1^2 \\sin^2(\\omega_1 t_n) + A_2^2 \\sin^2(\\omega_2 t_n) + 2 A_1 A_2 \\sin(\\omega_1 t_n) \\sin(\\omega_2 t_n)\n$$\n我们应用标准三角恒等式：$\\sin^2\\theta = \\frac{1}{2}(1 - \\cos(2\\theta))$ 和 $\\sin\\alpha\\sin\\beta = \\frac{1}{2}(\\cos(\\alpha-\\beta) - \\cos(\\alpha+\\beta))$。代入这些恒等式可得：\n$$\ny[n] = \\frac{A_1^2}{2} (1 - \\cos(2\\omega_1 t_n)) + \\frac{A_2^2}{2} (1 - \\cos(2\\omega_2 t_n)) + A_1 A_2 \\left(\\cos((\\omega_1 - \\omega_2)t_n) - \\cos((\\omega_1 + \\omega_2)t_n)\\right)\n$$\n根据频率内容收集各项，我们发现：\n$$\ny[n] = \\underbrace{\\frac{A_1^2 + A_2^2}{2}}_{\\text{DC component at } 0\\,\\mathrm{Hz}} - \\underbrace{\\frac{A_1^2}{2}\\cos(2\\omega_1 t_n) - \\frac{A_2^2}{2}\\cos(2\\omega_2 t_n)}_{\\text{Second harmonics at } 2f_1, 2f_2} + \\underbrace{A_1 A_2 \\cos((\\omega_1 - \\omega_2)t_n)}_{\\text{Difference frequency at } |f_1-f_2|} - \\underbrace{A_1 A_2 \\cos((\\omega_1 + \\omega_2)t_n)}_{\\text{Sum frequency at } f_1+f_2}\n$$\n该推导严谨地表明，非线性平方运算会产生新的频谱分量。具体来说，我们预期会观察到功率集中在和频 $f_{\\mathrm{sum}} = f_1+f_2$ 和差频 $f_{\\mathrm{diff}} = |f_1-f_2|$ 处。问题要求检测这两个分量。\n\n引入加性白高斯噪声 $\\eta[n]$ 后，待平方的信号被修正为：$u[n] = x[n] + \\eta[n]$。所得信号为 $y[n] = u[n]^2 = x[n]^2 + 2x[n]\\eta[n] + \\eta[n]^2$。项 $x[n]^2$ 包含上述推导出的确定性峰值。交叉项 $2x[n]\\eta[n]$ 和噪声平方项 $\\eta[n]^2$ 会导致功率谱中的噪声基底变宽，从而使峰值检测变得复杂。$\\eta[n]^2$ 项是一个零均值高斯过程的平方，其均值非零，为 $\\mathbb{E}[\\eta[n]^2] = \\sigma_n^2$，这会增加 $y[n]$ 的直流分量。\n\n为了估计功率谱密度（PSD）$S_{yy}(f)$，我们采用指定的 Welch 方法。该方法可以减轻像周期图这类更简单估计器所固有的高方差。其步骤如下：\n1. 将长度为 $N$ 的信号 $y[n]$ 分割成长度为 $L$ 的重叠段。\n2. 每段都乘以一个窗函数——在此情况下为汉宁窗——以减少由有限段长度引起的频谱泄漏。\n3. 对每个加窗段计算快速傅里叶变换（FFT），其结果的幅值平方提供了该段的周期图。\n4. 最终的 PSD 估计是通过对所有段的周期图进行平均得到的。应用归一化以产生单位为功率/赫兹的单边 PSD。\n\n对于每个测试用例，计算实现将按以下步骤进行：\n1. **信号生成**：创建一个离散时间向量 $t_n$。使用提供的参数合成无噪声信号 $x[n]$。使用指定的种子和标准差 $\\sigma_n$ 生成零均值高斯噪声 $\\eta[n]$，并将其加到 $x[n]$ 上形成 $u[n]$。用于分析的最终信号是 $y[n] = u[n]^2$。\n2. **PSD 估计**：确定段长度 $L$ 为不超过 $N/2$ 的最大 2 的幂，且最小为 $256$。使用 `scipy.signal.welch` 函数计算单边 PSD $S_{yy}(f)$，配置为使用汉宁窗、50% 重叠和 'density' 标度。\n3. **峰值检测**：对于每个目标频率 $f_0 \\in \\{f_{\\mathrm{sum}}, f_{\\mathrm{diff}}\\}$，其中 $f_{\\mathrm{sum}} = f_1+f_2$ 且 $f_{\\mathrm{diff}} = |f_1-f_2|$，执行搜索以找到最大 PSD 值。搜索在频率窗口 $[f_0 - w, f_0 + w]$ 内进行，其中半宽度 $w = \\max\\{5, 3\\Delta f\\}$，$\\Delta f = f_s/L$ 是 Welch 估计的频率分辨率。对于 $f_0=0$ 的特殊情况，搜索窗口为 $[0, w]$。\n4. **结果验证**：将检测到的峰值对应的频率 $\\hat{f}$ 与理论目标 $f_0$ 进行比较。如果 $|\\hat{f} - f_0| \\le \\tau$，则认为检测成功，其中容差 $\\tau = \\max\\{\\Delta f, 0.5\\}$。\n5. **输出格式化**：收集发现的峰值频率 $\\hat{f}_{\\mathrm{sum}}$ 和 $\\hat{f}_{\\mathrm{diff}}$（四舍五入到三位小数）及其对应的布尔检测状态，并按规定格式化。\n\n这种结构化的方法确保了分析严格按照问题要求进行，并基于成熟的信号处理原理。", "answer": "```python\nimport numpy as np\nfrom scipy.signal import welch\n\ndef solve():\n    \"\"\"\n    Implements and analyzes a nonlinear frequency-mixing experiment.\n    \"\"\"\n    # Test cases: (fs, N, f1, f2, A1, A2, sigma_n, seed)\n    test_cases = [\n        (2000, 4096, 123, 278, 1.0, 0.8, 0.2, 42),\n        (1200, 4096, 280, 300, 1.0, 1.0, 0.15, 7),\n        (1000, 4096, 200, 200, 0.7, 0.7, 0.1, 0),\n        (2000, 16384, 245, 250, 0.9, 1.0, 0.3, 123),\n    ]\n\n    results = []\n\n    def find_peak(freqs, syy, f_target, w, tau):\n        \"\"\"\n        Searches for a peak in the PSD within a specified window and validates it.\n        \"\"\"\n        if f_target == 0:\n            search_min, search_max = 0.0, w\n        else:\n            search_min, search_max = f_target - w, f_target + w\n        \n        search_indices = np.where((freqs >= search_min) & (freqs <= search_max))[0]\n        \n        if len(search_indices) == 0:\n            f_peak = -1.0  # Sentinel for not found\n            detected = False\n        else:\n            peak_idx_local = np.argmax(syy[search_indices])\n            peak_idx_global = search_indices[peak_idx_local]\n            f_peak = freqs[peak_idx_global]\n            detected = abs(f_peak - f_target) <= tau\n            \n        return f_peak, detected\n\n    for case in test_cases:\n        fs, N, f1, f2, A1, A2, sigma_n, seed = case\n        \n        # As phases are not specified, they are set to 0 radians.\n        phi1, phi2 = 0.0, 0.0\n\n        # Step 1: Signal Generation\n        t = np.arange(N) / fs\n        x_n = A1 * np.sin(2 * np.pi * f1 * t + phi1) + A2 * np.sin(2 * np.pi * f2 * t + phi2)\n        \n        rng = np.random.default_rng(seed)\n        eta_n = rng.normal(loc=0.0, scale=sigma_n, size=N)\n        u_n = x_n + eta_n\n        \n        y_n = u_n**2\n        \n        # Step 2: PSD Estimation using Welch's method\n        l0 = 1 << int(np.log2(N / 2))\n        L = max(l0, 256)\n        n_overlap = L // 2\n        \n        freqs, Syy = welch(\n            y_n,\n            fs=fs,\n            window='hann',\n            nperseg=L,\n            noverlap=n_overlap,\n            scaling='density',\n            return_onesided=True\n        )\n        \n        # Step 3 & 4: Peak Detection and Validation\n        f_sum_target = f1 + f2\n        f_diff_target = abs(f1 - f2)\n        \n        delta_f = fs / L\n        w = max(5, 3 * delta_f)\n        tau = max(delta_f, 0.5)\n        \n        f_sum_peak, sum_detected = find_peak(freqs, Syy, f_sum_target, w, tau)\n        f_diff_peak, diff_detected = find_peak(freqs, Syy, f_diff_target, w, tau)\n\n        results.append([\n            round(f_sum_peak, 3), \n            round(f_diff_peak, 3), \n            sum_detected, \n            diff_detected\n        ])\n\n    # Final print statement in the exact required format.\n    inner_strs = []\n    for res in results:\n        f_sum_p, f_diff_p, s_det, d_det = res\n        inner_strs.append(f\"[{f_sum_p},{f_diff_p},{str(s_det).lower()},{str(d_det).lower()}]\")\n    print(f\"[{','.join(inner_strs)}]\")\n\nsolve()\n```", "id": "2429016"}]}