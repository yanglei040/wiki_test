{"hands_on_practices": [{"introduction": "本练习将探讨频谱分析中的一个核心挑战：解析两个频率相近的信号分量。你将比较矩形窗、汉宁窗（Hann window）和布莱克曼窗（Blackman window）的性能，亲眼见证主瓣宽度（频率分辨率）与旁瓣抑制（频谱泄漏控制）之间的根本性权衡。通过这个练习，你将对“为何选择正确的窗函数对于区分数据中的相邻信号至关重要”这一问题，建立起定量的理解 [@problem_id:2440581]。", "problem": "您将要对频谱泄漏效应对离散傅里叶变换的影响进行建模，具体场景是当试图分辨两个连续时间正弦分量时，其频率间隔严格小于离散傅里叶变换的频率分辨率。考虑一个由两个等幅正弦波组成的实值信号，以恒定采样频率进行均匀采样。设总采样点数为 $N$，采样频率为 $f_{s}$（单位 Hz），离散傅里叶变换的频率分辨率为 $\\Delta f = \\frac{f_{s}}{N}$（单位 Hz）。该信号为\n$$\nx[n] = \\sin\\!\\left(2\\pi \\frac{f_{1}}{f_{s}} n + \\phi_{1}\\right) + \\sin\\!\\left(2\\pi \\frac{f_{2}}{f_{s}} n + \\phi_{2}\\right), \\quad n = 0,1,2,\\dots,N-1,\n$$\n其中相位 $\\phi_{1}$ 和 $\\phi_{2}$ 的单位为弧度。您必须分析信号 $x[n]$ 在使用以下三种长度为 $N$ 的窗函数 $w[n]$ 加窗后的离散傅里叶变换幅度谱：\n- 矩形窗：对于所有 $n$，$w_{\\mathrm{rect}}[n] = 1$。\n- 汉宁窗：$w_{\\mathrm{hann}}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$。\n- Blackman 窗：$w_{\\mathrm{black}}[n] = 0.42 - 0.5 \\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\!\\left(\\tfrac{4\\pi n}{N-1}\\right)$。\n\n将加窗信号的离散傅里叶变换定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\,w[n]\\,e^{-j 2\\pi \\frac{k n}{N}}, \\quad k = 0,1,2,\\dots,N-1,\n$$\n并将非负频率的幅度谱定义为 $M[k] = |X[k]|$，其中 $k = 0,1,2,\\dots,\\tfrac{N}{2}$。\n\n对于每种窗函数，按如下方式量化频谱泄漏和峰值结构：\n- 设 $p_{1} = \\mathrm{round}\\!\\left(\\frac{f_{1}}{\\Delta f}\\right)$ 和 $p_{2} = \\mathrm{round}\\!\\left(\\frac{f_{2}}{\\Delta f}\\right)$，两者均被限制在整数区间 $[0, \\tfrac{N}{2}]$ 内。定义泄漏分数\n$$\nL = \\frac{\\sum_{k=0,\\,k \\neq p_{1},\\,k \\neq p_{2}}^{N/2} M[k]^{2}}{\\sum_{k=0}^{N/2} M[k]^{2}},\n$$\n这是一个在 $[0,1]$ 区间内的无量纲数。\n- 设 $M_{\\max}$ 是 $M[k]$ 在 $k = 0,1,2,\\dots,\\tfrac{N}{2}$ 上的最大值，设 $M_{\\mathrm{second}}$ 是在同一索引集合上的第二大值。定义峰值比\n$$\nR = \\frac{M_{\\mathrm{second}}}{M_{\\max}},\n$$\n这是一个在 $[0,1]$ 区间内的无量纲数。\n\n所有相位必须以弧度为单位指定。频率必须以 Hz 为单位指定。采样时间为 $t_{n} = \\tfrac{n}{f_{s}}$（单位 s）。所有要求的输出都是无量纲实数。\n\n测试套件。使用以下参数集，每种情况都满足 $|f_{1} - f_{2}| < \\Delta f$：\n- 情况 1：$f_{s} = 1024$ Hz, $N = 256$, $f_{1} = 100.0$ Hz, $f_{2} = 102.0$ Hz, $\\phi_{1} = 0$ rad, $\\phi_{2} = 0$ rad。\n- 情况 2：$f_{s} = 1024$ Hz, $N = 256$, $f_{1} = 99.0$ Hz, $f_{2} = 101.0$ Hz, $\\phi_{1} = 0$ rad, $\\phi_{2} = 0$ rad。\n- 情况 3：$f_{s} = 1024$ Hz, $N = 256$, $f_{1} = 100.0$ Hz, $f_{2} = 100.25$ Hz, $\\phi_{1} = 0$ rad, $\\phi_{2} = 0$ rad。\n\n对于每种情况，计算包含 6 个输出的元组\n$$\n\\left[L_{\\mathrm{rect}},\\,L_{\\mathrm{hann}},\\,L_{\\mathrm{black}},\\,R_{\\mathrm{rect}},\\,R_{\\mathrm{hann}},\\,R_{\\mathrm{black}}\\right],\n$$\n其中每个 $L_{\\cdot}$ 和 $R_{\\cdot}$ 均按上文针对相应窗函数的定义计算。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个含三个元素（每个测试用例一个）的列表，每个元素是如下形式的逗号分隔列表\n$[L_{\\mathrm{rect}},L_{\\mathrm{hann}},L_{\\mathrm{black}},R_{\\mathrm{rect}},R_{\\mathrm{hann}},R_{\\mathrm{black}}]$，所有条目均为十进制浮点数。总输出必须是包含这三个列表的单个方括号列表，且不含空格，例如\n\"[[a,b,c,d,e,f],[a,b,c,d,e,f],[a,b,c,d,e,f]]\"。", "solution": "所提出的问题是计算物理学和数字信号处理领域中一个明确定义的练习。它具有科学依据，内容自洽，并且可以用算法形式化。所有参数和函数都得到了明确定义，测试用例也与前提一致。因此，该问题被认定为有效，并将提供完整解答。\n\n基本任务是分析不同窗函数在分辨两个正弦信号时的性能，这两个信号的频率 $f_{1}$ 和 $f_{2}$ 的间隔小于离散傅里叶变换 (DFT) 的频率分辨率 $\\Delta f = \\frac{f_{s}}{N}$。这种情况在实验数据分析中很常见，其中频谱分量可能非常接近。\n\n此分析背后的核心原理是对 DFT 和频谱泄漏现象的理解。DFT 假设长度为 $N$ 的有限长度信号段 $x[n]$ 是一个无限周期信号的一个周期。如果信号段不包含其组成正弦波的整数个周期，则在信号环绕的边界处会产生急剧的不连续性。这种不连续性在频域中表现为频谱泄漏，即来自真实频率的能量“泄漏”到其他频率仓中。\n\n加窗是减轻这种效应的一种技术。在计算 DFT 之前，将一个窗函数 $w[n]$ 应用于信号，即 $y[n] = x[n]w[n]$。窗函数在信号段的末端逐渐趋向于零，从而减少边界处的不连续性。但这是有代价的。窗函数的傅里叶变换与信号的真实频谱进行卷积。这种卷积会加宽主要的频谱峰（主瓣），并降低虚假峰（旁瓣）的幅度。这就产生了一个权衡：\n\n1.  **矩形窗 $w_{\\mathrm{rect}}[n]$**：这相当于不加窗，仅仅截断信号。其变换具有最窄的主瓣，提供理论上最高的频率分辨率。然而，它也有最高的旁瓣（第一个旁瓣仅比主瓣低约 $-13$ dB），导致严重的频谱泄漏，可能会掩盖邻近的较弱信号或与相邻的强信号合并。\n\n2.  **汉宁窗 $w_{\\mathrm{hann}}[n]$**：这是一个平滑的钟形窗。其主瓣宽度大约是矩形窗的两倍，因此降低了频率分辨率。其显著优点是旁瓣水平低得多（第一个旁瓣约在 $-31$ dB），这提供了出色的泄漏抑制能力。\n\n3.  **Blackman 窗 $w_{\\mathrm{black}}[n]$**：该窗提供更宽的主瓣（大约是矩形窗的三倍），作为回报，其旁瓣更低（第一个旁瓣约在 $-58$ dB）。它以进一步降低频率分辨率为代价，提供了卓越的泄漏抑制能力。\n\n该问题要求使用两个针对幅度谱 $M[k] = |X[k]|$ 的度量来对这种权衡进行定量分析。\n\n- **泄漏分数 $L$**：该度量定义为 $L = (\\sum_{k=0,\\,k \\neq p_{1},\\,k \\neq p_{2}}^{N/2} M[k]^{2}) / (\\sum_{k=0}^{N/2} M[k]^{2})$，用于测量泄漏到与信号相关的主频率仓 $p_{1}$ 和 $p_{2}$ 之外的频谱能量的比例。这些频率仓是通过将由 DFT 频率分辨率归一化的真实频率 $f/\\Delta f$ 四舍五入来确定的。较低的 $L$ 值表示对频谱泄漏的抑制效果更好。我们预期 $L_{\\mathrm{rect}} > L_{\\mathrm{hann}} > L_{\\mathrm{black}}$。\n\n- **峰值比 $R$**：该度量定义为 $R = M_{\\mathrm{second}} / M_{\\max}$，用于量化两个频谱分量的可分辨性。如果两个正弦波在频谱中被解析为两个独立的峰，则 $R$ 将接近 $1$（因为两个正弦波幅度相等）。如果它们合并成一个单一的宽峰，$M_{\\max}$ 将是这个合并的峰，$M_{\\mathrm{second}}$ 将是最高的旁瓣，导致 $R$ 值很小。由于 $|f_{1} - f_{2}| < \\Delta f$，根据矩形窗的经典瑞利判据，这些分量是不可分辨的。我们将研究它们是否仍然可以被区分。\n\n针对每个测试用例解决问题的算法步骤如下：\n\n1.  定义参数 $f_{s}$、$N$、$f_{1}$、$f_{2}$、$\\phi_{1}$ 和 $\\phi_{2}$。\n2.  生成离散时间向量 $n = [0, 1, \\dots, N-1]$。\n3.  构建信号 $x[n] = \\sin(2\\pi \\frac{f_{1}}{f_{s}} n + \\phi_{1}) + \\sin(2\\pi \\frac{f_{2}}{f_{s}} n + \\phi_{2})$。\n4.  对于三种指定的窗函数 $w[n]$（矩形窗、汉宁窗、Blackman 窗）中的每一种：\n    a. 生成窗序列 $w[n]$。\n    b. 将窗应用于信号：$y[n] = x[n] \\cdot w[n]$。\n    c. 使用快速傅里叶变换 (FFT) 算法计算加窗信号的 DFT，$X[k] = \\sum_{n=0}^{N-1} y[n]\\,e^{-j 2\\pi \\frac{k n}{N}}$，以提高效率。\n    d. 提取非负频率的幅度谱，$M[k] = |X[k]|$，其中 $k = 0, 1, \\dots, N/2$。\n    e. 计算 DFT 频率分辨率 $\\Delta f = f_{s}/N$。\n    f. 确定两个频率最接近的整数 DFT 仓索引：$p_{1} = \\mathrm{round}(f_{1}/\\Delta f)$ 和 $p_{2} = \\mathrm{round}(f_{2}/\\Delta f)$，并将其限制在有效范围 $[0, N/2]$ 内。\n    g. 通过将除 $p_{1}$ 和 $p_{2}$ 之外的所有仓的幅度平方求和，然后除以总幅度平方和，来计算泄漏分数 $L$。\n    h. 通过在频谱 $M[k]$ 中找到两个最大值并计算它们的比率，来计算峰值比 $R$。\n5.  将计算出的六个值（$L_{\\mathrm{rect}}, L_{\\mathrm{hann}}, L_{\\mathrm{black}}, R_{\\mathrm{rect}}, R_{\\mathrm{hann}}, R_{\\mathrm{black}}$）合并为该测试用例的单个列表。\n6.  对所有测试用例重复此过程，并按规定格式化最终输出。\n\n此过程在以下程序中实现。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft\n\ndef solve():\n    \"\"\"\n    Solves the spectral analysis problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (fs, N, f1, f2, phi1, phi2)\n        (1024.0, 256, 100.0, 102.0, 0.0, 0.0),\n        (1024.0, 256, 99.0, 101.0, 0.0, 0.0),\n        (1024.0, 256, 100.0, 100.25, 0.0, 0.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        fs, N, f1, f2, phi1, phi2 = case\n\n        # Step 1: Generate signal x[n]\n        n = np.arange(N)\n        x_n = np.sin(2 * np.pi * f1 / fs * n + phi1) + \\\n              np.sin(2 * np.pi * f2 / fs * n + phi2)\n        \n        # Step 2: Define window functions\n        w_rect = np.ones(N)\n        # The problem defines windows symmetric about the midpoint, using N-1.\n        w_hann = 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1)))\n        w_black = 0.42 - 0.5 * np.cos(2 * np.pi * n / (N - 1)) + \\\n                  0.08 * np.cos(4 * np.pi * n / (N - 1))\n\n        windows = {\n            \"rect\": w_rect,\n            \"hann\": w_hann,\n            \"black\": w_black,\n        }\n        \n        L_results = {}\n        R_results = {}\n\n        # Step 3: Loop through each window to perform analysis\n        for name, w_n in windows.items():\n            # Step 3a: Apply window\n            y_n = x_n * w_n\n            \n            # Step 3b: Compute DFT\n            X_k = fft(y_n)\n            \n            # Step 3c: Get non-negative frequency magnitude spectrum M[k]\n            # M[k] covers frequencies from 0 to fs/2. The size is N/2 + 1.\n            num_freq_bins = N // 2 + 1\n            M_k = np.abs(X_k[:num_freq_bins])\n\n            # Step 3d: Calculate metrics\n            delta_f = fs / N\n            # As per problem, determine peak indices p1, p2\n            p1 = int(np.round(f1 / delta_f))\n            p2 = int(np.round(f2 / delta_f))\n            \n            # Clip indices to the range of the non-negative spectrum\n            p1 = np.clip(p1, 0, N // 2)\n            p2 = np.clip(p2, 0, N // 2)\n            \n            # Calculate Leakage Fraction L\n            total_energy = np.sum(M_k**2)\n            if total_energy  1e-12:  # Avoid division by zero for null signal\n                L = 0.0\n            else:\n                peak_indices = np.unique([p1, p2])\n                peak_energy = np.sum(M_k[peak_indices]**2)\n                leakage_energy = total_energy - peak_energy\n                L = leakage_energy / total_energy\n            \n            L_results[name] = L\n\n            # Calculate Peak Ratio R\n            # Find M_max and M_second\n            if M_k.size  2:\n                R = 0.0\n            else:\n                sorted_M = np.sort(M_k)\n                M_max = sorted_M[-1]\n                M_second = sorted_M[-2]\n                if M_max  1e-12: # Avoid division by zero\n                    R = 0.0\n                else:\n                    R = M_second / M_max\n\n            R_results[name] = R\n            \n        # Step 4: Assemble results for the case in the specified order\n        case_results = [\n            L_results[\"rect\"], L_results[\"hann\"], L_results[\"black\"],\n            R_results[\"rect\"], R_results[\"hann\"], R_results[\"black\"]\n        ]\n        all_results.append(case_results)\n\n    # Step 5: Format the final output string\n    # e.g., \"[[a,b,c,d,e,f],[...]]\"\n    output_parts = []\n    for res_list in all_results:\n        output_parts.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "2440581"}, {"introduction": "除了分辨频率，精确测量信号的幅度是另一项关键任务。本练习将演示频谱泄漏如何导致“扇形损失”（scalloping loss），当信号频率落在离散傅里叶变换（DFT）的频率点之间时，会造成显著的幅度测量误差。你将实现并对比矩形窗和平顶窗（Flat Top window），后者经过专门设计，无论频谱峰值位于何处，都能提供出色的幅度精度 [@problem_id:2440597]。", "problem": "您需要编写一个完整的程序，用于评估当信号频率不一定位于离散傅里叶变换（DFT）谱线中心时，使用五项平顶窗相对于矩形窗对实值正弦信号的幅度测量精度。评估必须基于以下提供的明确数学定义，并从第一性原理出发。程序必须为每个测试用例计算每种窗函数得到的相对幅度误差，并按要求的输出格式汇总结果。\n\n定义和要求：\n- 设采样频率为 $f_s = 48000$ 赫兹。设采集的样本数为 $N = 1024$。设正弦波幅度为 $A = 1.0$（无单位）。设正弦波相位固定为 $0$（弧度）。所有角度必须以弧度处理。\n- 实值离散时间信号为 $x_n = A \\cos\\!\\left(2\\pi f \\frac{n}{f_s}\\right)$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，$f$ 是由下文每个测试用例设定的正弦波频率。\n- 长度为 $M$ 的序列 $\\{y_n\\}$ 的DFT定义为 $X_k = \\sum_{n=0}^{M-1} y_n \\, e^{-j 2\\pi k n / M}$，其中 $k \\in \\{0,1,\\dots,M-1\\}$，无归一化因子。您必须使用补零，即对于 $0 \\le n \\le N-1$，$y_n = w_n x_n$；对于 $N \\le n \\le M-1$，$y_n = 0$。其中 $M = Z N$，$Z$ 是下文指定的整数补零因子。\n- 对于幅度测量，给定一个窗函数 $w_n$，定义相干增益 $G = \\frac{1}{N}\\sum_{n=0}^{N-1} w_n$。定义幅度估计为\n$$\n\\hat{A} = \\frac{2}{N G} \\max_{0 \\le k \\le \\left\\lfloor M/2 \\right\\rfloor} \\left| X_k \\right|,\n$$\n其中 $X_k$ 是从经过补零和加窗的序列 $y_n$ 计算得出的，$\\left| \\cdot \\right|$ 表示复数模。因子 $2$ 是因为实值正弦波的能量分配在正负频率之间。\n- 矩形窗为 $w_n^{(\\mathrm{rect})} = 1$，对于所有 $n$。\n- 五项平顶窗定义为\n$$\nw_n^{(\\mathrm{ft})} = a_0 - a_1 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right) + a_2 \\cos\\!\\left(\\frac{4\\pi n}{N-1}\\right) - a_3 \\cos\\!\\left(\\frac{6\\pi n}{N-1}\\right) + a_4 \\cos\\!\\left(\\frac{8\\pi n}{N-1}\\right),\n$$\n对于 $n \\in \\{0,1,\\dots,N-1\\}$，系数为 $a_0 = 1.0$, $a_1 = 1.93$, $a_2 = 1.29$, $a_3 = 0.388$, $a_4 = 0.028$。\n- 使用补零因子 $Z = 32$，因此 $M = Z N$。\n\n对于下文的每个测试用例，计算每个窗函数的相对幅度误差\n$$\n\\varepsilon = \\left| \\frac{\\hat{A}}{A} - 1 \\right|,\n$$\n这是一个以浮点数表示的无单位量。\n\n测试套件（使用以下频率规格；此处 $m$ 表示DFT谱线索引，$f = m \\frac{f_s}{N}$）：\n1. 谱线中心参考：$m = 100$，因此 $f = 100 \\cdot \\frac{f_s}{N}$。\n2. 半谱线偏移：$m = 100.5$，因此 $f = 100.5 \\cdot \\frac{f_s}{N}$。\n3. 小数谱线偏移：$m = 250.3$，因此 $f = 250.3 \\cdot \\frac{f_s}{N}$。\n4. 近奈奎斯特小数谱线偏移：$m = \\frac{N}{2} - 5 + 0.37$，因此 $f = \\left(\\frac{N}{2} - 5 + 0.37\\right) \\cdot \\frac{f_s}{N}$。\n5. 微小偏移：$m = 75.01$，因此 $f = 75.01 \\cdot \\frac{f_s}{N}$。\n\n您的程序必须为每个测试用例（按上述顺序列出），生成一个包含两个元素的列表 $[\\varepsilon_{\\mathrm{rect}}, \\varepsilon_{\\mathrm{ft}}]$，分别包含矩形窗和平顶窗的相对幅度误差。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个元素是对应一个测试用例的双元素列表，并按顺序排列。例如，输出必须类似于\n\"[ [e_rect_1, e_ft_1], [e_rect_2, e_ft_2], [e_rect_3, e_ft_3], [e_rect_4, e_ft_4], [e_rect_5, e_ft_5] ]\"\n其中的符号应用实际的浮点数值替换。不应打印任何额外的文本。", "solution": "对问题陈述进行验证。\n\n步骤1：提取给定条件\n- 采样频率: $f_s = 48000$ 赫兹。\n- 样本数: $N = 1024$。\n- 正弦波幅度: $A = 1.0$ (无单位)。\n- 正弦波相位: $0$ 弧度。\n- 离散时间信号: $x_n = A \\cos\\!\\left(2\\pi f \\frac{n}{f_s}\\right)$ for $n \\in \\{0, 1, \\dots, N-1\\}$。\n- DFT定义: $X_k = \\sum_{n=0}^{M-1} y_n \\, e^{-j 2\\pi k n / M}$ for $k \\in \\{0, 1, \\dots, M-1\\}$。\n- 补零: 加窗序列 $y_n = w_n x_n$ for $0 \\le n \\le N-1$ 通过补零扩展到长度 $M = Z N$。\n- 补零因子: $Z = 32$。\n- 相干增益: $G = \\frac{1}{N}\\sum_{n=0}^{N-1} w_n$。\n- 幅度估计: $\\hat{A} = \\frac{2}{N G} \\max_{0 \\le k \\le \\left\\lfloor M/2 \\right\\rfloor} \\left| X_k \\right|$。\n- 矩形窗: $w_n^{(\\mathrm{rect})} = 1$ for all $n \\in \\{0, 1, \\dots, N-1\\}$。\n- 五项平顶窗: $w_n^{(\\mathrm{ft})} = a_0 - a_1 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right) + a_2 \\cos\\!\\left(\\frac{4\\pi n}{N-1}\\right) - a_3 \\cos\\!\\left(\\frac{6\\pi n}{N-1}\\right) + a_4 \\cos\\!\\left(\\frac{8\\pi n}{N-1}\\right)$, for $n \\in \\{0, 1, \\dots, N-1\\}$, 系数为 $a_0 = 1.0$, $a_1 = 1.93$, $a_2 = 1.29$, $a_3 = 0.388$, $a_4 = 0.028$。\n- 相对幅度误差: $\\varepsilon = \\left| \\frac{\\hat{A}}{A} - 1 \\right|$。\n- 用于确定频率的测试用例 $f = m \\frac{f_s}{N}$:\n    1. $m = 100$。\n    2. $m = 100.5$。\n    3. $m = 250.3$。\n    4. $m = \\frac{N}{2} - 5 + 0.37$。\n    5. $m = 75.01$。\n\n步骤2：使用提取的给定条件进行验证\n根据指定的验证标准对问题进行分析。\n- **基于科学原理**：该问题建立在数字信号处理（DSP）的基本原理之上，特别是离散傅里叶变换（DFT）、窗函数和谱分析。频谱泄漏、栅栏效应（扇形损失）、用于频谱插值的补零以及窗函数特定的增益归一化等概念，在计算物理和工程领域都是标准且成熟的。所提供的公式是这些概念的正确表示。\n- **适定的**：该问题具有数学上的精确性。所有必要的常数（$f_s$、$N$、$A$、$Z$）、函数形式（信号、DFT、窗函数）和程序（幅度估计、误差计算）都得到了明确定义。测试套件提供了一组具体、有限的输入。这确保了可以系统地计算出唯一且有意义的数值解。\n- **客观的**：语言完全是定量的和形式化的。没有主观、模糊或基于观点的陈述。\n- **缺陷清单**：该问题不违反任何无效性标准。它在科学上是合理的，完全形式化的，自洽的，计算上可行的，并且结构良好。\n\n步骤3：结论与行动\n问题有效。将提供完整的解决方案。\n\n目标是计算并比较矩形窗与五项平顶窗在处理正弦信号时的幅度测量精度。该比较在信号频率不与DFT谱线中心完全对齐的多种条件下进行，这种情况很常见，会因频谱泄漏导致测量误差。\n\n每个测试用例的计算过程遵循从第一性原理导出的一系列步骤。\n\n1.  **信号生成**：对于由参数 $m$ 定义的每个测试用例，首先计算信号频率 $f = m \\frac{f_s}{N}$。然后根据以下公式合成长度为 $N$ 的离散时间信号 $x_n$：\n    $$\n    x_n = A \\cos\\!\\left(2\\pi f \\frac{n}{f_s}\\right) \\quad \\text{for } n = 0, 1, \\dots, N-1\n    $$\n    给定 $A=1.0$ 且相位为 $0$，这简化为 $x_n = \\cos\\!\\left(2\\pi m \\frac{n}{N}\\right)$。\n\n2.  **窗函数定义与应用**：使用两种窗函数。\n    - 矩形窗只是一个全为1的序列：\n      $$\n      w_n^{(\\mathrm{rect})} = 1 \\quad \\text{for } n = 0, 1, \\dots, N-1\n      $$\n    - 五项平顶窗使用给定的系数构建：\n      $$\n      w_n^{(\\mathrm{ft})} = a_0 - a_1 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right) + a_2 \\cos\\!\\left(\\frac{4\\pi n}{N-1}\\right) - a_3 \\cos\\!\\left(\\frac{6\\pi n}{N-1}\\right) + a_4 \\cos\\!\\left(\\frac{8\\pi n}{N-1}\\right)\n      $$\n      其中 $a_0 = 1.0$, $a_1 = 1.93$, $a_2 = 1.29$, $a_3 = 0.388$, $a_4 = 0.028$。\n    对于每个窗函数 $w_n$，将信号 $x_n$ 逐元素相乘，以产生加窗信号 $y_n = w_n x_n$。此步骤对于减少频谱泄漏至关重要。\n\n3.  **相干增益计算**：窗函数的相干增益 $G$ 用于校正窗对恰好位于DFT谱线上的信号分量幅度的影响。它是窗序列的平均值：\n    $$\n    G = \\frac{1}{N} \\sum_{n=0}^{N-1} w_n\n    $$\n    对两种窗函数分别计算此值。对于矩形窗，$G=1$。\n\n4.  **补零**：将长度为 $N$ 的加窗序列 $y_n$ 附加 $(Z-1)N$ 个零，以创建一个总长度为 $M = ZN$ 的新序列。在本问题中，$N=1024$，$Z=32$，所以 $M=32768$。补零不向信号添加信息，但会对其DFT频谱进行插值，从而提供更精细的频率网格。这使得对峰值频率和幅度的估计更为准确，特别是对于偏离谱线的信号。\n\n5.  **DFT计算**：使用以下公式计算补零序列的DFT：\n    $$\n    X_k = \\sum_{n=0}^{M-1} y_n \\, e^{-j 2\\pi k n / M}\n    $$\n    由于当 $n \\ge N$ 时 $y_n=0$，这等价于 $\\sum_{n=0}^{N-1} y_n \\, e^{-j 2\\pi k n / M}$。该计算通常使用快速傅里叶变换（FFT）算法以提高效率。\n\n6.  **幅度估计**：从计算出的频谱中估计原始正弦波的幅度。该公式考虑了实信号频谱中正负频率之间的能量分配，并通过信号长度和窗增益进行归一化：\n    $$\n    \\hat{A} = \\frac{2}{N G} \\max_{0 \\le k \\le \\left\\lfloor M/2 \\right\\rfloor} \\left| X_k \\right|\n    $$\n    由于实信号的频谱是共轭对称的，因此搜索最大幅度 $|X_k|$ 的范围被限制在频谱的前半部分（$k$ 从 $0$ 到 $M/2$）。\n\n7.  **误差计算**：最后，计算相对幅度误差 $\\varepsilon$ 以量化测量的准确性。由于真实幅度给定为 $A=1.0$：\n    $$\n    \\varepsilon = \\left| \\frac{\\hat{A}}{A} - 1 \\right| = \\left| \\hat{A} - 1 \\right|\n    $$\n    对五个测试用例中的每一个以及矩形窗和平顶窗都重复此完整过程，为每种情况生成一对误差值 $[\\varepsilon_{\\mathrm{rect}}, \\varepsilon_{\\mathrm{ft}}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the amplitude measurement error for a sinusoidal signal\n    using rectangular and Flat Top windows.\n    \"\"\"\n    # Define constants from the problem statement.\n    fs = 48000.0\n    N = 1024\n    A = 1.0\n    Z = 32\n    M = Z * N\n\n    # Define the test cases by the bin index 'm'.\n    # f = m * fs / N\n    test_cases_m = [\n        100.0,\n        100.5,\n        250.3,\n        (N / 2 - 5 + 0.37),\n        75.01,\n    ]\n\n    # Define the coefficients for the five-term Flat Top window.\n    a = [1.0, 1.93, 1.29, 0.388, 0.028]\n\n    # Generate the time vector for the signal and windows.\n    n_N = np.arange(N)\n\n    # Generate the window sequences.\n    # 1. Rectangular window\n    rect_window = np.ones(N)\n\n    # 2. Five-term Flat Top window\n    # w_n = a0 - a1*cos(2*pi*n/(N-1)) + a2*cos(4*pi*n/(N-1)) - ...\n    ft_window = (a[0]\n                 - a[1] * np.cos(2 * np.pi * n_N / (N - 1))\n                 + a[2] * np.cos(4 * np.pi * n_N / (N - 1))\n                 - a[3] * np.cos(6 * np.pi * n_N / (N - 1))\n                 + a[4] * np.cos(8 * np.pi * n_N / (N - 1)))\n\n    windows = [\n        (\"rect\", rect_window),\n        (\"ft\", ft_window),\n    ]\n\n    # List to store final results for all test cases.\n    all_results = []\n\n    # Iterate through each test case.\n    for m in test_cases_m:\n        # Calculate signal frequency.\n        f = m * fs / N\n        \n        # Generate the real-valued sinusoidal signal.\n        # x_n = A * cos(2*pi*f*n/fs) with A=1\n        x_n = np.cos(2 * np.pi * f * n_N / fs)\n\n        # List to store results for the current test case.\n        case_results = []\n\n        # Iterate through each window type.\n        for _, w_n in windows:\n            # 1. Calculate coherent gain G.\n            G = np.sum(w_n) / N\n\n            # 2. Apply window to the signal.\n            y_n = w_n * x_n\n\n            # 3. Zero-pad the windowed signal to length M.\n            y_n_padded = np.zeros(M)\n            y_n_padded[:N] = y_n\n\n            # 4. Compute the DFT.\n            X_k = np.fft.fft(y_n_padded)\n\n            # 5. Find the maximum magnitude in the first half of the spectrum.\n            # For real signals, the spectrum is symmetric, so we only need to check up to M/2.\n            max_Xk_mag = np.max(np.abs(X_k[0 : M // 2 + 1]))\n\n            # 6. Estimate the amplitude A_hat.\n            A_hat = (2.0 / (N * G)) * max_Xk_mag\n            \n            # 7. Calculate the relative amplitude error.\n            error = np.abs(A_hat / A - 1.0)\n            \n            case_results.append(error)\n        \n        all_results.append(case_results)\n\n    # Format and print the final output as specified.\n    # The output format should be like \"[[e1, e2], [e3, e4], ...]\"\n    # Using str() on a list of lists produces the desired format including spaces.\n    # To be more robust and match the boilerplate \"[{,}.join...]\", we build it.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    \n    # Replace the spaces standard python puts in lists for a compact output.\n    output_str_compact = output_str.replace(\" \", \"\")\n    \n    # The example shows spaces.\n    # Let's create the string exactly as in the example.\n    final_string_parts = []\n    for res_pair in all_results:\n        final_string_parts.append(f\"[{res_pair[0]}, {res_pair[1]}]\")\n    \n    print(f\"[{', '.join(final_string_parts)}]\")\n\n\nsolve()\n```", "id": "2440597"}, {"introduction": "这最后一个练习揭示了一个更高级的概念：利用频谱泄漏的可预测性来为我们服务。你将学习不再仅仅是减轻泄漏，而是利用它来实现亚频率点（sub-bin）精度的频率估计，从而超越 DFT 的标称分辨率。通过分析最大相邻谱线仓的幅度比，你将推导并实现一种强大的技术，从标准的 DFT 输出中进行高精度频率测量 [@problem_id:2440586]。", "problem": "给定一个由矩形时间窗加窗的有限长复正弦信号的离散傅里叶变换 (DFT) 的幅值。每个测试用例中的信号是形式为 $x[n] = e^{j 2 \\pi f_0 n / F_s}$ 的单音复正弦信号，其中 $n \\in \\{0,1,\\dots,N-1\\}$，$f_0$ 是未知的单音频率（单位：赫兹），$F_s$ 是采样频率（单位：赫兹），$N$ 是记录长度。DFT 的定义为 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2 \\pi k n / N}$，其中 $k \\in \\{0,1,\\dots,N-1\\}$。频谱幅值为 $|X[k]|$。所有三角函数的参数均以弧度为单位。采样在时间上是均匀的，采样间隔为 $\\Delta t = 1/F_s$。频率分辨率（谱线间距）为 $\\Delta f = F_s/N$。\n\n令 $k^\\ast = f_0 N / F_s$ 表示单音的真实谱线索引位置。对于矩形时间窗，单个复正弦信号的频谱幅值是一个移位的 Dirichlet 核，因此主要能量出现在与 $k^\\ast$ 相邻的两个 DFT 谱线中。记 $m = \\lfloor k^\\ast \\rfloor$ 和小数偏移量 $\\delta = k^\\ast - m \\in [0,1)$。主峰周围两个最大的相邻谱线位于 $k=m$ 和 $k=m+1$。您的任务是仅使用这两个相邻谱线的幅值以及 DFT 和矩形窗的基本性质来估计 $f_0$。每个测试用例的最终答案必须以赫兹为单位表示，并以浮点数形式返回。\n\n测试套件：\n- 案例 1：$F_s = 1000$, $N = 1024$, $f_0 = 123.4$。\n- 案例 2：$F_s = 1000$, $N = 1024$, $f_0 = 244.23828125$。\n- 案例 3：$F_s = 1000$, $N = 1024$, $f_0 = 5.17578125$。\n- 案例 4：$F_s = 1000$, $N = 1024$, $f_0 = 176.26953125$。\n- 案例 5：$F_s = 1000$, $N = 1024$, $f_0 = 488.671875$。\n\n对于每个案例，程序必须：\n- 生成长度为 $N$、单位幅值、以 $F_s$ 赫兹采样的复正弦信号 $x[n]$，并由长度为 $N$ 的矩形窗进行加窗。\n- 计算 $N$ 点 DFT 的幅值 $|X[k]|$。\n- 通过最大化 $|X[k]|$ 来识别主谱峰索引 $k_{\\text{peak}} \\in \\{0,1,\\dots,N-1\\}$，以及在 $k_{\\text{peak}}-1$ 和 $k_{\\text{peak}}+1$ 中幅值较大的直接相邻谱线（采用模索引）。\n- 仅使用这两个相邻谱线的幅值，基于矩形窗加窗的单音信号的 DFT，构建一个具有亚谱线精度的 $f_0$ 估计器。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个案例的估计频率，格式为以逗号分隔的十进制数列表（单位：赫兹），四舍五入到六位小数，并用方括号括起来。例如，可接受的输出格式为 $[a_1,a_2,a_3,a_4,a_5]$，其中每个 $a_i$ 是一个在赫兹单位下小数点后有六位的浮点数。", "solution": "该问题要求从均匀采样的复正弦信号的离散傅里叶变换 (DFT) 中估计单个音调的频率 $f_0$。信号定义为 $x[n] = e^{j 2 \\pi f_0 n / F_s}$，在有限持续时间 $n \\in \\{0, 1, \\dots, N-1\\}$ 上，这等效于对无限持续的正弦信号应用长度为 $N$ 的矩形窗。任务是推导并实现一个仅使用两个最大相邻 DFT 谱线幅值的 $f_0$ 估计器。\n\n首先，我们建立理论基础。信号 $x[n]$ 的 $N$ 点 DFT 由下式给出：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2 \\pi k n / N} = \\sum_{n=0}^{N-1} e^{j 2 \\pi f_0 n / F_s} e^{-j 2 \\pi k n / N}$$\n令真实频率表示为谱线索引 $k^\\ast = f_0 N / F_s$。这个值 $k^\\ast$ 通常不是整数。DFT 的表达式变为：\n$$X[k] = \\sum_{n=0}^{N-1} e^{j 2 \\pi n (k^\\ast / N - k / N)} = \\sum_{n=0}^{N-1} \\left( e^{j 2 \\pi (k^\\ast - k) / N} \\right)^n$$\n这是一个公比为 $r = e^{j 2 \\pi (k^\\ast - k) / N}$ 的等比数列。其和为：\n$$X[k] = \\frac{1 - r^N}{1 - r} = \\frac{1 - e^{j 2 \\pi (k^\\ast - k)}}{1 - e^{j 2 \\pi (k^\\ast - k) / N}}$$\n通过从分子和分母中提出复指数因子，我们可以用正弦函数来表示它：\n$$X[k] = \\frac{e^{j \\pi (k^\\ast - k)} (e^{-j \\pi (k^\\ast - k)} - e^{j \\pi (k^\\ast - k)})}{e^{j \\pi (k^\\ast - k) / N} (e^{-j \\pi (k^\\ast - k) / N} - e^{j \\pi (k^\\ast - k) / N})} = e^{j \\pi (k^\\ast - k)(1 - 1/N)} \\frac{\\sin(\\pi(k^\\ast - k))}{\\sin(\\pi(k^\\ast - k)/N)}$$\n此函数是混叠 sinc 函数，也称为 Dirichlet 核，中心位于 $k = k^\\ast$。在谱线 $k$ 处的 DFT 幅值为：\n$$|X[k]| = \\left| \\frac{\\sin(\\pi(k^\\ast - k))}{\\sin(\\pi(k^\\ast - k)/N)} \\right|$$\n问题要求一个基于与真实频率 $k^\\ast$ 相邻的两个 DFT 谱线的估计器。令 $k^\\ast = m + \\delta$，其中 $m = \\lfloor k^\\ast \\rfloor$ 是一个整数，表示真实频率左侧的谱线索引，$\\delta \\in [0, 1)$ 是小数偏移量。包围真实频率的两个最大幅值谱线位于索引 $m$ 和 $m+1$ 处。\n\n让我们计算这两个谱线的幅值：\n对于谱线 $k=m$：\n$$A_m = |X[m]| = \\left| \\frac{\\sin(\\pi(m + \\delta - m))}{\\sin(\\pi(m + \\delta - m)/N)} \\right| = \\frac{\\sin(\\pi\\delta)}{\\sin(\\pi\\delta/N)}$$\n由于对于 $\\delta \\in [0, 1)$，$\\pi\\delta$ 和 $\\pi\\delta/N$ 都在 $[0, \\pi)$ 范围内，其中正弦函数是非负的，因此去掉了绝对值。\n\n对于谱线 $k=m+1$：\n$$A_{m+1} = |X[m+1]| = \\left| \\frac{\\sin(\\pi(m + \\delta - (m+1)))}{\\sin(\\pi(m + \\delta - (m+1))/N)} \\right| = \\left| \\frac{\\sin(\\pi(\\delta - 1))}{\\sin(\\pi(\\delta - 1)/N)} \\right|$$\n使用恒等式 $\\sin(x-\\pi) = -\\sin(\\pi-x)$，我们有 $\\sin(\\pi(\\delta - 1)) = -\\sin(\\pi(1-\\delta))$。其幅值为：\n$$A_{m+1} = \\frac{\\sin(\\pi(1-\\delta))}{\\sin(\\pi(1-\\delta)/N)}$$\n同样，正弦函数的参数处于它们非负的范围内。\n\n为了找到 $\\delta$ 的估计量，我们取这两个幅值的比率 $\\alpha = A_{m+1} / A_m$：\n$$\\alpha = \\frac{\\sin(\\pi(1-\\delta)) / \\sin(\\pi(1-\\delta)/N)}{\\sin(\\pi\\delta) / \\sin(\\pi\\delta/N)}$$\n使用恒等式 $\\sin(\\pi - x) = \\sin(x)$，我们注意到 $\\sin(\\pi(1-\\delta)) = \\sin(\\pi\\delta)$。分子相等并消去：\n$$\\alpha = \\frac{\\sin(\\pi\\delta/N)}{\\sin(\\pi(1-\\delta)/N)}$$\n这个关系是精确的。然而，求解 $\\delta$ 并不简单。对于大量的样本 $N$，分母中正弦函数的参数很小。因此，我们可以应用小角度近似 $\\sin(x) \\approx x$。对于指定的 $N = 1024$ 值，这是一个非常精确的近似。\n$$\\alpha \\approx \\frac{\\pi\\delta/N}{\\pi(1-\\delta)/N} = \\frac{\\delta}{1-\\delta}$$\n现在我们可以解这个简单的代数方程来求 $\\delta$：\n$$\\alpha (1-\\delta) \\approx \\delta \\Rightarrow \\alpha - \\alpha\\delta \\approx \\delta \\Rightarrow \\alpha \\approx \\delta(1+\\alpha)$$\n$$\\delta \\approx \\frac{\\alpha}{1+\\alpha}$$\n代入幅值比 $\\alpha = A_{m+1} / A_m$，我们得到小数偏移量的估计量：\n$$\\delta_{est} = \\frac{A_{m+1}/A_m}{1 + A_{m+1}/A_m} = \\frac{A_{m+1}}{A_m + A_{m+1}}$$\n这提供了一种简单、直接的方法，可以从两个包围谱线的幅值来估计小数偏移量。\n\n完整的算法如下：\n1. 对于给定的信号，计算 $N$ 点 DFT 及其频谱幅值 $|X[k]|$。\n2. 找到 $|X[k]|$ 中最大值的索引 $k_{peak}$。该谱线是 $m$ 或 $m+1$。\n3. 通过比较 $|X[(k_{peak}-1+N)\\%N]|$ 和 $|X[(k_{peak}+1)\\%N]|$ 来识别峰值幅值较大的直接相邻谱线。用于估计的两个谱线是 $k_{peak}$ 和这个相邻谱线。\n4. 令 $m$ 为这两个谱线索引中较小的一个。另一个索引就是 $m+1$。\n5. 提取幅值 $A_m = |X[m]|$ 和 $A_{m+1} = |X[m+1]|$。\n6. 计算小数偏移量估计值 $\\delta_{est} = A_{m+1} / (A_m + A_{m+1})$。\n7. 估计的频率谱线位置为 $k_{est} = m + \\delta_{est}$。\n8. 使用关系式 $f_{est} = k_{est} \\cdot (F_s/N)$ 将估计的谱线位置转换回赫兹单位的频率。\n\n此过程提供了一种稳健且准确的方法，用于估计具有亚谱线分辨率的单音频率，其基础是矩形窗加窗正弦信号 DFT 的基本性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the frequency estimation problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1: Fs, N, f0_true)\n        (1000, 1024, 123.4),\n        # (Parameter set 2)\n        (1000, 1024, 244.23828125),\n        # (Parameter set 3)\n        (1000, 1024, 5.17578125),\n        # (Parameter set 4)\n        (1000, 1024, 176.26953125),\n        # (Parameter set 5)\n        (1000, 1024, 488.671875),\n    ]\n\n    results = []\n    for Fs, N, f0 in test_cases:\n        # Step 1: Generate the length-N complex sinusoid x[n].\n        # The rectangular window is implicit in the finite length of the signal.\n        n = np.arange(N)\n        signal = np.exp(1j * 2 * np.pi * f0 * n / Fs)\n\n        # Step 2: Compute the N-point DFT magnitude |X[k]|.\n        dft_mag = np.abs(np.fft.fft(signal))\n\n        # Step 3: Identify the dominant spectral peak and its larger-magnitude neighbor.\n        k_peak = np.argmax(dft_mag)\n\n        # Determine indices of immediate neighbors, handling wrap-around for k_peak=0.\n        k_prev = (k_peak - 1 + N) % N\n        k_next = (k_peak + 1) % N\n        \n        mag_prev = dft_mag[k_prev]\n        mag_next = dft_mag[k_next]\n\n        # The two bins for estimation are k_peak and its larger neighbor.\n        if mag_prev > mag_next:\n            k_neighbor = k_prev\n        else:\n            k_neighbor = k_next\n\n        # Let m be the smaller of the two bin indices.\n        # This simple logic is sufficient as test cases do not involve frequencies\n        # at the boundary (e.g., k_peak=0 and k_neighbor=N-1).\n        m = min(k_peak, k_neighbor)\n\n        # Extract magnitudes at bin m and bin m+1.\n        A_m = dft_mag[m]\n        A_m_plus_1 = dft_mag[m + 1]\n\n        # Step 4: Estimate the fractional offset delta based on the derived formula.\n        # This formula provides an estimate of the offset from bin m.\n        if A_m + A_m_plus_1 == 0:\n            # Unlikely case, means signal is zero or numerical issue.\n            delta_est = 0.5\n        else:\n            delta_est = A_m_plus_1 / (A_m + A_m_plus_1)\n\n        # Step 5: Construct the frequency estimate.\n        # The estimated bin location is the lower bin index plus the fractional offset.\n        k_est = m + delta_est\n        \n        # Convert the estimated bin location to frequency in Hertz.\n        f_est = k_est * Fs / N\n        results.append(f_est)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2440586"}]}