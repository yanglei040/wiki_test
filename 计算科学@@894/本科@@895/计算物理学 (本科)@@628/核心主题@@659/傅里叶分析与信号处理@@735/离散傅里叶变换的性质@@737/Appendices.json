{"hands_on_practices": [{"introduction": "离散傅里叶变换的第一个频率分量（对应于 $k=0$）具有特殊的物理意义，它代表了信号的总和或平均值，通常被称为直流（DC）分量。这个练习通过一个直接的计算，让你亲手验证对于一个简单的输入信号，其变换后的第一个分量是如何捕捉到这一核心信息的。这为你理解DFT如何将信号分解为不同频率成分奠定了坚实的基础。[@problem_id:976215]", "problem": "考虑一个长度为 $N=4$ 的信号 $\\mathbf{x} = (1, 1, 0, 0)$，其分量索引为 $n=0, 1, 2, 3$。令 $U$ 为阶数 $N=4$ 的酉离散傅里叶变换 (DFT) 矩阵，其元素定义为：\n\n$$\nU_{k,n} = \\frac{1}{\\sqrt{N}} \\exp\\left(-2\\pi i \\frac{kn}{N}\\right), \\quad k,n = 0,1,2,3\n$$\n\n其中 $i$ 是虚数单位。变换后的向量为 $\\mathbf{X} = U\\mathbf{x}$。计算 $\\mathbf{X}$ 的第一个分量 $X_0$ 的模的平方，即 $|X_0|^2$。", "solution": "给定信号 $\\mathbf{x} = (x_0, x_1, x_2, x_3) = (1, 1, 0, 0)$。变换后向量 $\\mathbf{X}$ 的第一个分量（对应于频率 $k=0$）是信号 $\\mathbf{x}$ 与酉DFT矩阵 $U$ 的第一行相乘的结果。\n\n$$\nX_0 = \\sum_{n=0}^{3} U_{0,n} x_n\n$$\n\n对于 $k=0$，矩阵元素为：\n\n$$\nU_{0,n} = \\frac{1}{\\sqrt{4}} \\exp\\left(-2\\pi i \\frac{0 \\cdot n}{4}\\right) = \\frac{1}{2} \\exp(0) = \\frac{1}{2}, \\quad \\text{for } n=0,1,2,3.\n$$\n\n代入 $\\mathbf{x}$ 的值：\n\n$$\nX_0 = \\sum_{n=0}^{3} \\frac{1}{2} x_n = \\frac{1}{2}(x_0 + x_1 + x_2 + x_3) = \\frac{1}{2}(1 + 1 + 0 + 0) = \\frac{1}{2}(2) = 1.\n$$\n\n其模的平方为：\n\n$$\n|X_0|^2 = |1|^2 = 1.\n$$", "answer": "\\boxed{1}", "id": "976215"}, {"introduction": "时间和频率是描述信号的两个相互关联的维度，DFT揭示了它们之间深刻的对偶关系——一个域中的操作会在另一个域中产生可预测的对应效应。本实践任务要求你通过编程来验证几个关键的尺度变换性质，例如在时域中对信号进行扩展（上采样）或压缩（下采样）将如何改变其频谱。通过亲自动手实现和检验这些关系，你将更直观地掌握信号处理中时频分析的精髓。[@problem_id:2431109]", "problem": "您的任务是验证一个序列的离散傅里叶变换（DFT）与其在离散时间意义上被压缩或拉伸的版本的DFT之间的精确关系。仅处理有限长度序列和如下定义的DFT。所有索引均为整数，所有变换均作为有限和精确计算。\n\n离散傅里叶变换（DFT）的定义：对于一个长度为 $N$ 的序列 $x[n]$，其DFT $X[k]$ 定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j \\, 2\\pi \\, k \\, n / N}, \\quad k=0,1,\\dots,N-1,\n$$\n其逆DFT为\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j \\, 2\\pi \\, k \\, n / N}, \\quad n=0,1,\\dots,N-1.\n$$\n\n定义序列上的以下三种操作：\n\n1. 离散时间扩展（以因子 $L$ 上采样）：给定一个长度为 $N$ 的序列 $x[n]$ 和一个整数 $L \\ge 1$，定义一个长度为 $N' = L N$ 的序列 $y_{\\text{exp}}[n]$ 为\n$$\ny_{\\text{exp}}[n] = \n\\begin{cases}\nx\\!\\left[\\dfrac{n}{L}\\right], & \\text{如果 } n \\text{ 是 } L \\text{ 的倍数}, \\\\\n0, & \\text{否则},\n\\end{cases}\n\\quad n=0,1,\\dots,N'-1.\n$$\n\n2. 离散时间压缩（以因子 $M$ 下采样）：给定一个长度为 $N$ 的序列 $x[n]$ 和一个能整除 $N$ 的整数 $M \\ge 1$，定义一个长度为 $Q = N/M$ 的序列 $y_{\\text{comp}}[n]$ 为\n$$\ny_{\\text{comp}}[n] = x[M n], \\quad n=0,1,\\dots,Q-1.\n$$\n\n3. 模 $N$ 的循环索引缩放（其中 $a$ 与 $N$ 互质）：给定一个长度为 $N$ 的序列 $x[n]$ 和一个整数 $a$ 使得 $\\gcd(a,N)=1$，定义一个长度为 $N$ 的序列 $y_{\\text{circ}}[n]$ 为\n$$\ny_{\\text{circ}}[n] = x[(a n) \\bmod N], \\quad n=0,1,\\dots,N-1.\n$$\n\n您的程序必须直接根据上述定义验证以下性质，复数值相等的数值绝对容差为 $\\varepsilon = 10^{-9}$：\n\n- 扩展性质：如果 $Y_{\\text{exp}}[k]$ 是长度为 $N' = L N$ 的 $y_{\\text{exp}}[n]$ 的DFT，$X[k]$ 是长度为 $N$ 的 $x[n]$ 的DFT，则\n$$\nY_{\\text{exp}}[k] = X[k \\bmod N], \\quad k=0,1,\\dots,N'-1.\n$$\n\n- 压缩性质：如果 $Y_{\\text{comp}}[k]$ 是长度为 $Q = N/M$ 的 $y_{\\text{comp}}[n]$ 的DFT，$X[k]$ 是长度为 $N$ 的 $x[n]$ 的DFT，则\n$$\nY_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k + r Q], \\quad k=0,1,\\dots,Q-1,\n$$\n其中 $X[\\cdot]$ 的所有索引均取自 $0$到$N-1$ 的范围，且 $Q = N/M$ 是一个整数。\n\n- 循环索引缩放性质：如果 $Y_{\\text{circ}}[k]$ 是长度为 $N$ 的 $y_{\\text{circ}}[n]$ 的DFT，$X[k]$ 是长度为 $N$ 的 $x[n]$ 的DFT，则\n$$\nY_{\\text{circ}}[k] = X[(k \\, a^{-1}) \\bmod N], \\quad k=0,1,\\dots,N-1,\n$$\n其中 $a^{-1}$ 是 $a$ 模 $N$ 的乘法逆元（即，$a \\, a^{-1} \\equiv 1 \\pmod{N}$）。\n\n测试套件。对于每个测试，计算必要的DFT，并通过检查两侧之间的最大绝对差值最多为 $\\varepsilon = 10^{-9}$ 来验证相应性质。为每个测试用例生成一个布尔结果。\n\n- 测试 $1$ (扩展，一般情况)：$N=8$，$L=3$，$x[n] = \\cos\\!\\left(2\\pi \\cdot 1 \\cdot n / 8\\right) + \\tfrac{1}{2}\\sin\\!\\left(2\\pi \\cdot 2 \\cdot n / 8\\right)$，对于 $n=0,1,\\dots,7$。\n\n- 测试 $2$ (压缩，一般情况)：$N=12$，$M=3$，$x[n] = (-1)^n + \\tfrac{1}{4} n$，对于 $n=0,1,\\dots,11$。\n\n- 测试 $3$ (边界情况，单位缩放)：$N=10$，$a=1$。定义 $x[n] = \\cos\\!\\left(2\\pi \\cdot 4 \\cdot n / 10\\right) + \\sin\\!\\left(2\\pi \\cdot 3 \\cdot n / 10\\right)$，对于 $n=0,1,\\dots,9$。同时验证 $L=1$ 时的扩展性质和 $M=1$ 时的压缩性质；当且仅当两个验证都在容差 $\\varepsilon$ 下成功时，测试结果为真。\n\n- 测试 $4$ (循环缩放，互质因子)：$N=10$，$a=3$，其中 $\\gcd(3,10)=1$。定义 $x[n] = \\cos\\!\\left(2\\pi \\cdot 4 \\cdot n / 10\\right) + \\sin\\!\\left(2\\pi \\cdot 3 \\cdot n / 10\\right)$，对于 $n=0,1,\\dots,9$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”）。每个结果必须是与上述测试顺序对应的布尔值。输出行中不允许有任何额外的文本或空白。此问题不涉及任何物理单位；所有量均为无量纲的实数或复数。三角函数中的角度以弧度为单位。", "solution": "问题的核心是验证DFT与时域缩放操作相关的三个性质：扩展（上采样）、压缩（下采样）和循环索引缩放。为了严谨，我们将为每个性质提供简要的解析证明。\n\n设 $x[n]$ 为一个长度为 $N$ 的序列，其DFT为 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi k n / N}$，其中 $j = \\sqrt{-1}$。\n\n**1. 扩展性质**\n\n给定一个长度为 $N$ 的序列 $x[n]$，长度为 $N' = LN$ 的扩展序列 $y_{\\text{exp}}[n]$ 定义为：\n$$\ny_{\\text{exp}}[n] = \n\\begin{cases}\nx[n/L], & \\text{如果 } n \\text{ 是 } L \\text{ 的倍数}, \\\\\n0, & \\text{否则}。\n\\end{cases}\n$$\n需要验证的性质是 $Y_{\\text{exp}}[k] = X[k \\bmod N]$。\n\n**推导：**\n$y_{\\text{exp}}[n]$ 的DFT由下式给出：\n$Y_{\\text{exp}}[k] = \\sum_{n=0}^{N'-1} y_{\\text{exp}}[n] e^{-j 2\\pi k n / N'}$\n由于 $y_{\\text{exp}}[n]$ 仅在 $n$ 是 $L$ 的倍数时非零，我们可以代入 $n = mL$，其中 $m$ 的范围是从 $0$ 到 $N-1$：\n$Y_{\\text{exp}}[k] = \\sum_{m=0}^{N-1} y_{\\text{exp}}[mL] e^{-j 2\\pi k (mL) / (LN)}$\n根据 $y_{\\text{exp}}$ 的定义，$y_{\\text{exp}}[mL] = x[m]$。将此代入方程中：\n$Y_{\\text{exp}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k m / N}$\n右侧是 $x[n]$ 的DFT的定义，其本身具有周期性，周期为 $N$。因此，该表达式等价于 $X[k \\bmod N]$，证明了该性质。\n\n**2. 压缩性质**\n\n给定一个长度为 $N$ 的序列 $x[n]$，长度为 $Q = N/M$ 的压缩序列 $y_{\\text{comp}}[n]$ 定义为 $y_{\\text{comp}}[n] = x[Mn]$。\n需要验证的性质是 $Y_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k + rQ]$。\n\n**推导：**\n我们从 $x[n]$ 的逆DFT表达式开始：\n$y_{\\text{comp}}[n] = x[Mn] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p (Mn) / N} = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p n / Q}$\n现在，我们计算 $y_{\\text{comp}}[n]$ 的DFT：\n$Y_{\\text{comp}}[k] = \\sum_{n=0}^{Q-1} y_{\\text{comp}}[n] e^{-j 2\\pi k n / Q} = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] \\left( \\sum_{n=0}^{Q-1} e^{j 2\\pi (p-k) n / Q} \\right)$\n内部的和仅在 $p-k$ 是 $Q$ 的倍数（即 $p=k+rQ$）时为 $Q$，否则为 $0$。因此：\n$Y_{\\text{comp}}[k] = \\frac{1}{N} \\sum_{r=0}^{M-1} X[k+rQ] \\cdot Q = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k+rQ]$\n这证实了压缩性质的正确性。\n\n**3. 循环索引缩放性质**\n\n给定一个长度为 $N$ 的序列 $x[n]$ 和一个与 $N$ 互质的整数 $a$，缩放后的序列为 $y_{\\text{circ}}[n] = x[(an) \\bmod N]$。\n需要验证的性质是 $Y_{\\text{circ}}[k] = X[(k a^{-1}) \\bmod N]$。\n\n**推导：**\n$y_{\\text{circ}}[n]$ 的DFT为：\n$Y_{\\text{circ}}[k] = \\sum_{n=0}^{N-1} x[(an) \\bmod N] e^{-j 2\\pi k n / N}$\n由于 $\\gcd(a,N)=1$，映射 $m = (an) \\bmod N$ 是集合 $\\{0, \\dots, N-1\\}$ 的一个置换。我们可以将求和变量从 $n$ 更改为 $m$。逆映射为 $n = (a^{-1}m) \\bmod N$。\n$Y_{\\text{circ}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k ((a^{-1}m) \\bmod N) / N} = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi (k a^{-1}) m / N}$\n这个表达式恰好是在频率索引 $k' = (k a^{-1}) \\bmod N$ 处求值的 $x[m]$ 的DFT。因此，该性质在解析上是正确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT properties verification problem.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: Expansion property\n    def test_1():\n        N = 8\n        L = 3\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 1 * n / N) + 0.5 * np.sin(2 * np.pi * 2 * n / N)\n        X = np.fft.fft(x)\n\n        N_prime = L * N\n        y_exp = np.zeros(N_prime, dtype=np.float64)\n        for n_prime in range(N_prime):\n            if n_prime % L == 0:\n                y_exp[n_prime] = x[n_prime // L]\n        \n        # LHS: DFT of the expanded sequence\n        Y_exp_lhs = np.fft.fft(y_exp)\n\n        # RHS: Periodically repeated original DFT\n        Y_exp_rhs = np.zeros(N_prime, dtype=np.complex128)\n        k_prime = np.arange(N_prime)\n        Y_exp_rhs = X[k_prime % N]\n        \n        max_diff = np.max(np.abs(Y_exp_lhs - Y_exp_rhs))\n        return max_diff <= epsilon\n\n    results.append(test_1())\n\n    # Test 2: Compression property\n    def test_2():\n        N = 12\n        M = 3\n        n = np.arange(N)\n        x = (-1)**n + 0.25 * n\n        X = np.fft.fft(x)\n\n        Q = N // M\n        y_comp = x[::M]\n        \n        # LHS: DFT of the compressed sequence\n        Y_comp_lhs = np.fft.fft(y_comp)\n        \n        # RHS: Sum of aliased components\n        Y_comp_rhs = np.zeros(Q, dtype=np.complex128)\n        for k in range(Q):\n            for r in range(M):\n                Y_comp_rhs[k] += X[k + r * Q]\n        Y_comp_rhs /= M\n        \n        max_diff = np.max(np.abs(Y_comp_lhs - Y_comp_rhs))\n        return max_diff <= epsilon\n\n    results.append(test_2())\n\n    # Test 3: Boundary cases (L=1, M=1)\n    def test_3():\n        N = 10\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 4 * n / N) + np.sin(2 * np.pi * 3 * n / N)\n        X = np.fft.fft(x)\n\n        # Part A: Expansion with L=1\n        L = 1\n        N_prime = L * N\n        y_exp = x # y_exp is just x\n        Y_exp_lhs = np.fft.fft(y_exp)\n        k_prime = np.arange(N_prime)\n        Y_exp_rhs = X[k_prime % N]\n        check_L1 = np.max(np.abs(Y_exp_lhs - Y_exp_rhs)) <= epsilon\n\n        # Part B: Compression with M=1\n        M = 1\n        Q = N // M\n        y_comp = x # y_comp is just x\n        Y_comp_lhs = np.fft.fft(y_comp)\n        Y_comp_rhs = np.zeros(Q, dtype=np.complex128)\n        for k in range(Q):\n            for r in range(M):\n                Y_comp_rhs[k] += X[k + r * Q]\n        Y_comp_rhs /= M\n        check_M1 = np.max(np.abs(Y_comp_lhs - Y_comp_rhs)) <= epsilon\n        \n        return check_L1 and check_M1\n\n    results.append(test_3())\n\n    # Test 4: Circular index scaling property\n    def test_4():\n        N = 10\n        a = 3\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 4 * n / N) + np.sin(2 * np.pi * 3 * n / N)\n        X = np.fft.fft(x)\n        \n        # In Python 3.8+, pow(a, -1, N) computes modular inverse\n        a_inv = pow(a, -1, N)\n\n        y_circ = np.zeros(N, dtype=np.float64)\n        for n_val in range(N):\n            y_circ[n_val] = x[(a * n_val) % N]\n\n        # LHS: DFT of the circularly scaled sequence\n        Y_circ_lhs = np.fft.fft(y_circ)\n\n        # RHS: Permuted original DFT\n        Y_circ_rhs = np.zeros(N, dtype=np.complex128)\n        for k in range(N):\n            Y_circ_rhs[k] = X[(k * a_inv) % N]\n        \n        max_diff = np.max(np.abs(Y_circ_lhs - Y_circ_rhs))\n        return max_diff <= epsilon\n\n    results.append(test_4())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2431109"}, {"introduction": "在信号分析中，一个常见的操作是在进行傅里叶变换前对时域信号进行“零填充”（zero-padding），但这究竟意味着什么？这个练习将揭开零填充的神秘面纱，证明它并非“创造”了新的频谱信息，而是在现有的频谱样本之间进行了精确的插值。你将通过编程来验证，对信号补零后再进行DFT，其结果等同于用狄利克雷核（Dirichlet kernel）对原始信号的稀疏频谱进行插值，从而获得对频谱更精细的观察。[@problem_id:2431114]", "problem": "给定一个长度为$N$的有限长度离散时间信号$x_n$，其中$n \\in \\{0,1,\\dots,N-1\\}$。其长度为$N$的离散傅里叶变换 (DFT) $X^{(N)}_k$ 定义为\n$$\nX^{(N)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-i 2\\pi k n / N}, \\quad k \\in \\{0,1,\\dots,N-1\\}.\n$$\n定义长度为$M$的补零序列$\\tilde{x}_n$为\n$$\n\\tilde{x}_n = \\begin{cases}\nx_n, & 0 \\le n \\le N-1,\\\\\n0, & N \\le n \\le M-1,\n\\end{cases}\n$$\n其长度为$M$的离散傅里叶变换$X^{(M)}_r$定义为\n$$\nX^{(M)}_r = \\sum_{n=0}^{M-1} \\tilde{x}_n \\, e^{-i 2\\pi r n / M}, \\quad r \\in \\{0,1,\\dots,M-1\\}.\n$$\n你的程序必须仅使用第一性原理（离散傅里叶变换及其逆变换的定义）来证明由时域补零引起的$X^{(M)}_r$与$N$点频谱$X^{(N)}_k$之间的精确关系。对于下方的每个测试用例，请针对同一对$(N,M)$和序列$x_n$计算两个量：\n(1) 通过离散傅里叶变换的定义，直接从补零序列计算得到的长度为$M$的频谱。\n(2) 完全用$X^{(N)}_k$以及由离散傅里叶变换及其逆变换所蕴含的初等有限和表示的长度为$M$的频谱。\n然后，对于每个测试用例，返回这两个频谱在所有索引$r \\in \\{0,1,\\dots,M-1\\}$上的最大绝对差，结果为浮点小数。\n\n测试套件：\n- 用例 A（通用复合实正弦信号）：$N=16$，$M=128$，对于所有满足$0 \\le n \\le 15$的整数$n$，$x_n = \\cos\\!\\left(2\\pi \\cdot 3.5 \\, n / 16\\right) + 0.6 \\, \\sin\\!\\left(2\\pi \\cdot 5 \\, n / 16\\right)$。\n- 用例 B（Kronecker delta）：$N=9$，$M=27$，当$n=0$时$x_n = 1$，否则$x_n=0$，其中$0 \\le n \\le 8$。\n- 用例 C（频点中心的复指数）：$N=10$，$M=100$，对于$0 \\le n \\le 9$，$x_n = e^{i 2\\pi \\cdot 3 \\, n / 10}$。\n- 用例 D（非正弦、含交变分量）：$N=12$，$M=50$，对于$0 \\le n \\le 11$，$x_n = (n+1)/12 + 0.1\\,(-1)^n$。\n\n不涉及物理单位。角度以弧度为单位。你的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC,resultD]”）。每个条目必须是对应测试用例的最大绝对差，表示为浮点数。", "solution": "给定$n \\in \\{0,1,\\dots,N-1\\}$的$x_n$。其长度为$N$的离散傅里叶变换 (DFT) 为\n$$\nX^{(N)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-i 2\\pi k n / N}, \\quad k=0,1,\\dots,N-1.\n$$\n在此约定下，离散傅里叶逆变换 (IDFT) 为\n$$\nx_n = \\frac{1}{N}\\sum_{k=0}^{N-1} X^{(N)}_k \\, e^{i 2\\pi k n / N}, \\quad n=0,1,\\dots,N-1.\n$$\n定义长度为$M \\ge N$的补零序列$\\tilde{x}_n$为：当$0 \\le n \\le N-1$时，$\\tilde{x}_n=x_n$；当$N \\le n \\le M-1$时，$\\tilde{x}_n=0$。其长度为$M$的DFT为\n$$\nX^{(M)}_r = \\sum_{n=0}^{M-1} \\tilde{x}_n \\, e^{-i 2\\pi r n / M} = \\sum_{n=0}^{N-1} x_n \\, e^{-i 2\\pi r n / M}, \\quad r=0,1,\\dots,M-1,\n$$\n因为当$n \\ge N$时，$\\tilde{x}_n=0$。将$x_n$的逆DFT表达式代入：\n$$\nX^{(M)}_r = \\sum_{n=0}^{N-1} \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, e^{i 2\\pi k n / N}\\right) e^{-i 2\\pi r n / M}\n= \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\sum_{n=0}^{N-1} e^{i 2\\pi n \\left(\\frac{k}{N} - \\frac{r}{M}\\right)}.\n$$\n内部的有限几何级数和是复指数形式的Dirichlet核：\n$$\nD_N(\\alpha) \\equiv \\sum_{n=0}^{N-1} e^{i 2\\pi n \\alpha}\n= e^{i \\pi \\alpha (N-1)} \\, \\frac{\\sin(\\pi N \\alpha)}{\\sin(\\pi \\alpha)},\n$$\n通过极限$\\alpha \\to 0$得到连续延拓$D_N(0)=N$。因此，\n$$\nX^{(M)}_r = \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, D_N\\!\\left(\\frac{k}{N}-\\frac{r}{M}\\right).\n$$\n这表明$X^{(M)}_r$是通过使用Dirichlet核对长度为$N$的DFT样本$X^{(N)}_k$进行插值得到的，该核是一个周期sinc函数。换言之，对时域序列进行补零，会在频域产生更精细的采样，该采样等于对粗糙DFT样本的Dirichlet（周期sinc）插值。该恒等式对于所有整数$N \\ge 1$和$M \\ge N$以及所有序列$x_n$都精确成立。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dirichlet_kernel(N: int, alpha: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute D_N(alpha) = sum_{n=0}^{N-1} exp(i 2π n alpha)\n    using the closed-form expression with robust handling at alpha=0.\n\n    Parameters:\n        N: int, sequence length\n        alpha: ndarray of floats, same shape as output\n\n    Returns:\n        ndarray of complex128 with same shape as alpha\n    \"\"\"\n    alpha = np.asarray(alpha, dtype=np.float64)\n    # Compute using closed-form: e^{iπ alpha (N-1)} * sin(π N alpha) / sin(π alpha)\n    numer = np.sin(np.pi * N * alpha)\n    denom = np.sin(np.pi * alpha)\n\n    # General case\n    with np.errstate(divide='ignore', invalid='ignore'):\n        kernel = np.exp(1j * np.pi * alpha * (N - 1)) * (numer / denom)\n\n    # Handle alpha near integer multiples (here only near 0 under our alpha range) where denom ~ 0\n    # Limit as alpha -> 0 is N.\n    mask = np.isclose(denom, 0.0, atol=1e-12)\n    if np.any(mask):\n        kernel = kernel.astype(np.complex128, copy=False)\n        kernel[mask] = N + 0j\n    return kernel\n\ndef zero_padded_spectrum_direct(x: np.ndarray, M: int) -> np.ndarray:\n    \"\"\"\n    Compute the M-point DFT of x zero-padded to length M.\n    \"\"\"\n    N = x.shape[0]\n    padded = np.zeros(M, dtype=np.complex128)\n    padded[:N] = x.astype(np.complex128)\n    return np.fft.fft(padded, n=M)\n\ndef spectrum_interpolated_from_XN(x: np.ndarray, M: int) -> np.ndarray:\n    \"\"\"\n    Compute the M-point spectrum from the N-point spectrum X^{(N)}_k\n    using the Dirichlet-kernel interpolation identity:\n        X^{(M)}_r = (1/N) sum_k X^{(N)}_k D_N(k/N - r/M)\n    \"\"\"\n    N = x.shape[0]\n    XN = np.fft.fft(x, n=N)  # X^{(N)}_k\n    # Build alpha grid: shape (M, N) for r in [0..M-1], k in [0..N-1]\n    r = np.arange(M, dtype=np.float64).reshape(-1, 1)  # (M,1)\n    k = np.arange(N, dtype=np.float64).reshape(1, -1)  # (1,N)\n    alpha = k / N - r / M                              # (M,N)\n    D = dirichlet_kernel(N, alpha)                     # (M,N)\n    X_interp = (D @ XN) / N                            # (M,)\n    return X_interp\n\ndef max_abs_diff_between_methods(x: np.ndarray, M: int) -> float:\n    \"\"\"\n    Compute max_r |X_zp(r) - X_interp(r)| as a float.\n    \"\"\"\n    X_direct = zero_padded_spectrum_direct(x, M)\n    X_interp = spectrum_interpolated_from_XN(x, M)\n    diff = np.abs(X_direct - X_interp)\n    return float(np.max(diff))\n\ndef make_test_cases():\n    \"\"\"\n    Construct the test cases as specified in the problem statement.\n    Returns a list of tuples (x, M) with x as np.ndarray (complex128) of length N.\n    \"\"\"\n    cases = []\n\n    # Case A: N=16, M=128, x_n = cos(2π*3.5*n/16) + 0.6*sin(2π*5*n/16)\n    N_A, M_A = 16, 128\n    nA = np.arange(N_A, dtype=np.float64)\n    xA = np.cos(2.0 * np.pi * 3.5 * nA / N_A) + 0.6 * np.sin(2.0 * np.pi * 5.0 * nA / N_A)\n    cases.append((xA.astype(np.complex128), M_A))\n\n    # Case B: N=9, M=27, Kronecker delta at n=0\n    N_B, M_B = 9, 27\n    xB = np.zeros(N_B, dtype=np.complex128)\n    xB[0] = 1.0 + 0.0j\n    cases.append((xB, M_B))\n\n    # Case C: N=10, M=100, x_n = exp(i 2π*3*n/10)\n    N_C, M_C = 10, 100\n    nC = np.arange(N_C, dtype=np.float64)\n    xC = np.exp(1j * 2.0 * np.pi * 3.0 * nC / N_C)\n    cases.append((xC.astype(np.complex128), M_C))\n\n    # Case D: N=12, M=50, x_n = (n+1)/12 + 0.1*(-1)^n\n    N_D, M_D = 12, 50\n    nD = np.arange(N_D, dtype=np.float64)\n    xD = (nD + 1.0) / 12.0 + 0.1 * ((-1.0) ** nD)\n    cases.append((xD.astype(np.complex128), M_D))\n\n    return cases\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = make_test_cases()\n\n    results = []\n    for x, M in test_cases:\n        result = max_abs_diff_between_methods(x, M)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2431114"}]}