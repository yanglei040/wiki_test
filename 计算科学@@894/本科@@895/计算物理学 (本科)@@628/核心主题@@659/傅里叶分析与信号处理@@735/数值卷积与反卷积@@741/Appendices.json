{"hands_on_practices": [{"introduction": "在探索高效算法之前，通过直接根据其数学定义实现卷积来打下坚实的基础至关重要。本练习将指导您使用直接求和法从零开始构建卷积函数。更重要的是，它将挑战您去数值验证卷积的一个基本性质——交换律（$f*g = g*f$），并发现理想化的数学世界与浮点运算的实际应用之间的微妙差异 [@problem_id:2419015]。", "problem": "要求您设计并实现一个数值实验。该实验从两个有限序列的离散卷积的基本定义出发，并用它来在计算中评估卷积的交换律。整个工作完全基于纯数学和数值分析的术语；不涉及任何物理单位。\n\n设给定两个有限序列 $f = \\{f_0, f_1, \\dots, f_{N-1}\\}$ 和 $g = \\{g_0, g_1, \\dots, g_{M-1}\\}$。$f$ 和 $g$ 的离散线性卷积（记为 $(f * g)$）对每个整数索引 $n$ 定义为\n$$(f * g)[n] \\equiv \\sum_{k=-\\infty}^{\\infty} f[k]\\, g[n - k],$$\n并约定当 $k < 0$ 或 $k \\ge N$ 时 $f[k] = 0$，当 $k < 0$ 或 $k \\ge M$ 时 $g[k] = 0$。因此，$(f * g)[n]$ 仅在 $n \\in \\{0, 1, \\dots, N + M - 2\\}$ 时非零。\n\n您的任务是：\n\n1) 从上述定义出发（不允许使用变换域或谱方法），实现一个确定性算法，用于计算任意有限实值序列 $f$ 和 $g$ 的 $(f * g)$。该算法必须在每个输出索引 $n$ 处，按照一个固定的、递增的求和索引顺序，显式地执行有限和 $\\sum_{k} f[k]\\, g[n - k]$。不要调用任何内置的卷积例程或任何隐式使用卷积定理的函数。\n\n2) 使用相同的算法计算 $(g * f)$，并在 IEEE $754$ 双精度浮点运算下，定量比较 $(f * g)$ 与 $(g * f)$。为任意一对计算输出 $y_{fg}$ 和 $y_{gf}$ 定义以下诊断指标：\n$$\\Delta_\\infty \\equiv \\frac{\\max_n \\left| y_{fg}[n] - y_{gf}[n] \\right|}{\\max\\left(1, \\max_n |y_{fg}[n]|, \\max_n |y_{gf}[n]|\\right)}.$$\n这是无穷范数下的相对误差，分母中设置了下限 $1$ 以避免除以非常小的数。\n\n3) 对以下三个精心选择的、共同构成一个测试套件的测试用例，评估 $\\Delta_\\infty$。每个序列条目都必须作为双精度实数处理。\n\n- 测试用例 A（范围内的精确算术体系）：$f_A = [\\,1, 2, 3, 4\\,]$, $g_A = [\\,5, 6, 7\\,]$。对于这些整数值，所有中间乘积和总和都保持在 $2^{53}$ 以下，因此这些整数的加法和乘法可以在双精度下精确表示。该用例旨在探究交换律应在机器精度下成立的体系。\n\n- 测试用例 B（平滑的良态信号）：令 $N = 64$，对 $n \\in \\{0, 1, \\dots, N - 1\\}$ 定义网格 $x_n = -3 + 6\\, n/(N - 1)$，并设置 $f_B[n] = \\exp\\!\\left(-\\tfrac{1}{2} x_n^2\\right)$。令 $g_B$ 为一个长度为 $9$ 的归一化盒状函数，即当 $m \\in \\{0, 1, \\dots, 8\\}$ 时 $g_B[m] = 1/9$。该用例旨在探究典型的“理想路径”下的数值行为。\n\n- 测试用例 C（病态动态范围）：按如下方式独立生成 $f_C$ 和 $g_C$。令 $N = 256$ 和 $M = 257$。对于 $f_C$，从 $[-100, 100]$ 区间内均匀抽取 $N$ 个独立的指数 $e_k$，并以相同概率抽取独立的符号 $s_k \\in \\{-1, +1\\}$，然后设置 $f_C[k] = s_k \\cdot 10^{e_k}$。对于 $g_C$，按照相同规则抽取 $M$ 个独立的指数和符号，并设置 $g_C[m] = s_m \\cdot 10^{e_m}$。使用固定的随机种子以确保序列是可复现的。该用例旨在探究在存在极大和极小量级值的情况下浮点运算的非结合性。\n\n4) 对于上述三个测试用例中的每一个，计算如上定义的 $\\Delta_\\infty$。您的程序必须生成一行输出，其中包含三个结果，格式为方括号括起来的逗号分隔列表，并采用科学记数法，小数点后恰好有 $12$ 位数字（例如，$[1.234567890123e-04,5.000000000000e-01,3.210000000000e-16]$）。三个输出必须按 A、B、C 的顺序排列，并且必须是浮点数。\n\n注意：\n\n- 对于每个输出样本 $n$，您必须按递增的索引顺序实现求和，从而明确定义有限加法的顺序。不要按量级对项进行重新排序或使用补偿求和。\n- 您不得调用任何为您计算卷积的函数。您可以使用基本的数组操作来访问元素，并使用循环来执行求和。\n- 不要依赖快速傅里叶变换 (FFT; Fast Fourier Transform) 的任何属性，因为此任务不允许使用频域方法。", "solution": "该问题要求设计并实现一个数值实验，以评估离散卷积在有限精度浮点运算下的交换律。分析需要从离散线性卷积的基本定义出发，而不借助如快速傅里叶变换 (FFT) 等变换域方法。\n\n两个有限序列 $f = \\{f_0, f_1, \\dots, f_{N-1}\\}$ 和 $g = \\{g_0, g_1, \\dots, g_{M-1}\\}$ 的离散线性卷积是一个序列 $h = (f * g)$，其第 $n$ 项由下式给出\n$$h[n] = (f * g)[n] \\equiv \\sum_{k=-\\infty}^{\\infty} f[k]\\, g[n - k].$$\n鉴于序列 $f$ 和 $g$ 具有有限支撑集，即当 $k \\notin [0, N-1]$ 时 $f[k] = 0$，当 $m \\notin [0, M-1]$ 时 $g[m] = 0$，因此求和仅在有限的索引 $k$ 范围内非零。对于给定的输出索引 $n$，项 $f[k]g[n-k]$ 可能非零的条件是 $k \\in [0, N-1]$ 和 $n-k \\in [0, M-1]$ 同时成立。第二个条件等价于 $n - (M-1) \\le k \\le n$。结合这些约束，求和索引 $k$ 必须落在以下范围内\n$$ \\max(0, n - M + 1) \\le k \\le \\min(n, N-1). $$\n得到的卷积序列 $h$ 的长度为 $N + M - 1$，其索引 $n$ 的范围从 $0$ 到 $N + M - 2$。\n\n第一个任务是构建一个确定性算法，通过显式求值和，来计算每个 $n$ 对应的 $h[n]$，其中求和索引 $k$ 严格递增。该算法过程如下：\n1. 初始化一个长度为 $L = N + M - 1$ 的结果数组 $h$，并用零填充。所有计算都将使用 IEEE $754$ 双精度浮点数。\n2. 遍历每个输出索引 $n$，范围从 $0$ 到 $L-1$。\n3. 对每个 $n$，计算求和索引 $k$ 的范围为 $k_{\\text{start}} = \\max(0, n - M + 1)$ 和 $k_{\\text{end}} = \\min(n, N-1)$。\n4. 初始化一个临时求和变量 $S_n = 0.0$。\n5. 将 $k$ 从 $k_{\\text{start}}$ 到 $k_{\\text{end}}$ 按递增顺序迭代。在每一步中，计算乘积 $f[k] \\cdot g[n-k]$ 并将其加到 $S_n$ 上。这强制执行了指定的求和顺序。\n6. 内层循环完成后，赋值 $h[n] = S_n$。\n该过程直接按要求实现了卷积的定义。\n\n第二个任务是研究交换律性质，即 $(f * g) = (g * f)$。在精确算术中，此性质成立。然而，浮点运算不具有结合性，即 $(a+b)+c$ 不一定等于 $a+(b+c)$。由于 $(f * g)$ 和 $(g * f)$ 的计算涉及对同一组乘积项以不同顺序求和，它们的数值结果可能会有所不同。\n\n设 $y_{fg}$ 为使用上述算法计算 $(f * g)$ 的结果， $y_{gf}$ 为计算 $(g * f)$ 的结果。为量化这种差异，我们使用指定的诊断指标，即无穷范数下的相对误差：\n$$ \\Delta_\\infty \\equiv \\frac{\\max_n \\left| y_{fg}[n] - y_{gf}[n] \\right|}{\\max\\left(1, \\max_n |y_{fg}[n]|, \\max_n |y_{gf}[n]|\\right)}. $$\n分母的下限设为 $1$，以保持数值稳定性并为误差提供一个合理的尺度，特别是当卷积信号的最大振幅小于 $1$ 或恒等于零时。\n\n第三和第四个任务涉及将此分析应用于三个测试用例。\n\n测试用例 A: $f_A = [\\,1, 2, 3, 4\\,]$ 和 $g_A = [\\,5, 6, 7\\,]$。所有输入都是小整数。中间乘积（例如 $4 \\times 7 = 28$）和最终和（例如 $(f_A * g_A)[3] = 52$）也都是足够小的整数，可以由 `float64` 的尾数精确表示，该尾数可以容纳高达 $2^{53}$ 的所有整数。由于所有算术运算都是精确的，浮点加法的非结合性不会显现。因此，我们预测 $y_{fg}$ 和 $y_{gf}$ 将是逐位相同的，从而得到 $\\Delta_\\infty = 0$。\n\n测试用例 B: $f_B$ 是一个采样的高斯函数，是一种平滑且行为良好的信号。$g_B$ 是一个归一化的盒状函数。这代表了信号处理中的一个常见场景，例如应用移动平均滤波器。$f_B$ 的分量都是正数且量级相近。以不同顺序对这些值求和，就像在 $(f*g)$ 与 $(g*f)$ 中发生的那样，会因浮点舍入而引入差异。预期误差应在双精度的机器ε（约为 $2.22 \\times 10^{-16}$）的量级上。\n\n测试用例 C: 序列 $f_C$ 和 $g_C$ 的元素构造方式是，其量级从对数尺度上的均匀分布中抽取，跨越多个数量级（大约从 $10^{-100}$ 到 $10^{100}$）。这对求和来说是一个病态问题。当对量级差异巨大的数字求和时，灾难性抵消和吸收误差会非常显著。例如，如果 $A$ 非常大而 $b$ 非常小，$A+b$ 的计算结果可能就是 $A$。求和的顺序变得至关重要。由于 $(f * g)$ 和 $(g * f)$ 将对相同乘积以不同顺序求和，预期最终结果会有显著差异。预计会得到一个相当大的 $\\Delta_\\infty$ 值。为确保可复现性，必须为随机数生成器使用固定的种子。我们选择种子为 $0$。\n\n实现将严格遵循这些原则，生成序列，通过直接求和算法执行卷积，并为每种情况计算 $\\Delta_\\infty$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical convolution problem by direct implementation and assesses commutativity.\n    \"\"\"\n\n    def convolve_direct(f: np.ndarray, g: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the discrete linear convolution of two 1D sequences f and g\n        using direct summation as per the definition.\n\n        Args:\n            f: The first sequence, a 1D NumPy array of float64.\n            g: The second sequence, a 1D NumPy array of float64.\n\n        Returns:\n            The convolved sequence, a 1D NumPy array of float64.\n        \"\"\"\n        N = len(f)\n        M = len(g)\n        if N == 0 or M == 0:\n            return np.array([], dtype=np.float64)\n            \n        L = N + M - 1\n        h = np.zeros(L, dtype=np.float64)\n\n        for n in range(L):\n            s = 0.0\n            k_start = max(0, n - M + 1)\n            k_end = min(n, N - 1)\n            for k in range(k_start, k_end + 1):\n                s += f[k] * g[n - k]\n            h[n] = s\n        return h\n\n    def calculate_delta_inf(y_fg: np.ndarray, y_gf: np.ndarray) -> float:\n        \"\"\"\n        Calculates the relative error in the infinity norm between two sequences.\n\n        Args:\n            y_fg: The result of (f * g).\n            y_gf: The result of (g * f).\n\n        Returns:\n            The diagnostic value Delta_infinity.\n        \"\"\"\n        if y_fg.size == 0 and y_gf.size == 0:\n            return 0.0\n\n        max_abs_diff = np.max(np.abs(y_fg - y_gf))\n        \n        norm_fg = np.max(np.abs(y_fg)) if y_fg.size > 0 else 0.0\n        norm_gf = np.max(np.abs(y_gf)) if y_gf.size > 0 else 0.0\n\n        denominator = max(1.0, norm_fg, norm_gf)\n        \n        return max_abs_diff / denominator\n\n    results = []\n\n    # Test Case A: Exact integer arithmetic regime\n    f_A = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float64)\n    g_A = np.array([5.0, 6.0, 7.0], dtype=np.float64)\n    \n    y_fg_A = convolve_direct(f_A, g_A)\n    y_gf_A = convolve_direct(g_A, f_A)\n    delta_A = calculate_delta_inf(y_fg_A, y_gf_A)\n    results.append(delta_A)\n\n    # Test Case B: Smooth, well-conditioned signals\n    N_B = 64\n    x_n = -3.0 + 6.0 * np.arange(N_B) / (N_B - 1)\n    f_B = np.exp(-0.5 * x_n**2, dtype=np.float64)\n    g_B = np.full(9, 1.0/9.0, dtype=np.float64)\n    \n    y_fg_B = convolve_direct(f_B, g_B)\n    y_gf_B = convolve_direct(g_B, f_B)\n    delta_B = calculate_delta_inf(y_fg_B, y_gf_B)\n    results.append(delta_B)\n\n    # Test Case C: Ill-conditioned dynamic range\n    np.random.seed(0) # For reproducibility\n    N_C = 256\n    M_C = 257\n    \n    # Generate f_C\n    exponents_f = np.random.uniform(-100, 100, N_C)\n    signs_f = np.random.choice([-1.0, 1.0], N_C)\n    f_C = signs_f * (10.0**exponents_f)\n    f_C = f_C.astype(np.float64)\n\n    # Generate g_C\n    exponents_g = np.random.uniform(-100, 100, M_C)\n    signs_g = np.random.choice([-1.0, 1.0], M_C)\n    g_C = signs_g * (10.0**exponents_g)\n    g_C = g_C.astype(np.float64)\n\n    y_fg_C = convolve_direct(f_C, g_C)\n    y_gf_C = convolve_direct(g_C, f_C)\n    delta_C = calculate_delta_inf(y_fg_C, y_gf_C)\n    results.append(delta_C)\n\n    # Format and print the final output\n    output_str = \",\".join([f\"{r:.12e}\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2419015"}, {"introduction": "虽然直接求和在概念上很清晰，但对于长信号来说，其计算效率很低。基于卷积定理，快速傅里叶变换 (Fast Fourier Transform, FFT) 为计算卷积提供了一条快得多的路径。本实践将指导您实现这一强大技术，并特别关注“零填充”这一关键步骤，它确保了离散傅里叶变换（DFT）原生的循环卷积结果与我们期望的线性卷积结果相匹配 [@problem_id:2419128]。", "problem": "实现一个程序，使用快速傅里叶变换（FFT）计算两个有限长度离散时间实数序列的线性卷积。从离散时间卷积和离散傅里叶变换（DFT）的定义出发，您将通过对每个序列进行补零以避免循环混叠，从而在数值上实现线性卷积。您必须遵循以下通用方案实现卷积，不得使用内置的线性卷积例程：将两个序列都补零至一个能保证循环卷积等于线性卷积的长度，通过FFT计算它们的DFT，在频域中进行逐点相乘，然后计算逆DFT以返回到时域。最终结果必须是线性卷积。该算法必须对任意有限长度的实值输入序列有效。您可以假设所有输入均为实数且长度有限。您还必须通过将基于FFT的结果与一个可靠的库例程（该例程实现了线性卷积的定义）计算出的直接时域参考值进行比较，来量化数值精度。\n\n您的程序必须执行以下任务：\n1) 实现一个函数，给定代表序列 $x[n]$ 和 $h[n]$（长度分别为 $N$ 和 $M$）的两个一维数组，通过以下步骤计算它们的线性卷积 $y[k] = \\sum_{n=-\\infty}^{\\infty} x[n]\\,h[k-n]$：\n- 将两个序列都补零至长度 $L$，该长度至少为 $N+M-1$。\n- 计算补零后序列的DFT（使用FFT）。\n- 逐点相乘DFT。\n- 计算逆DFT，并返回前 $L$ 个样本作为线性卷积。\n在此步骤中，您不得使用任何内置的线性卷积例程。但是，您可以在测试套件中（见下文）仅使用直接卷积例程来验证数值精度。\n\n2) 为进行验证，使用直接时域方法计算一个参考线性卷积，然后报告每个测试中基于FFT的结果与直接结果之间的最大绝对误差。\n\n3) 使用以下输入序列测试套件。所有角度均以弧度为单位。每个列表表示一个按索引升序排列的有限序列。\n- 测试 A (一般小规模情况)：$x = [\\,1,\\,2,\\,3\\,]$，$h = [\\,0,\\,1,\\,0.5\\,]$。\n- 测试 B (类冲激输入)：$x = [\\,1,\\,0,\\,0,\\,0\\,]$，$h = [\\,-1,\\,2,\\,-1\\,]$。\n- 测试 C (由短核平滑的正弦波)：$x[n] = \\sin\\!\\big(2\\pi n/8\\big)$ 对于 $n \\in \\{\\,0,\\,1,\\,2,\\,3,\\,4,\\,5,\\,6,\\,7\\,\\}$，且 $h = [\\,0.25,\\,0.5,\\,0.25\\,]$。\n- 测试 D (长度为一的边界情况)：$x = [\\,2.5\\,]$，$h = [\\,-3.0,\\,4.0\\,]$。\n- 测试 E (带短衰减核的交替符号序列)：$x = [\\,-1.0,\\,2.0,\\,-3.0,\\,4.0,\\,-5.0\\,]$，$h = [\\,0.5,\\,-0.25,\\,0.125,\\,-0.0625\\,]$。\n\n4) 对于每个测试，计算最大绝对误差 $e = \\max_k \\big| y_{\\text{FFT}}[k] - y_{\\text{direct}}[k] \\big|$。将测试 A 到 E 的误差按顺序汇总到一个列表中。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。例如，$[r_1,r_2,r_3,r_4,r_5]$。\n- 每个 $r_i$ 必须是一个十进制浮点数，表示相应测试的最大绝对误差，格式化为最多 $12$ 位有效数字。\n\n所有计算都应在无单位的、纯数学的环境中执行。实现必须是完全确定性的，并且不得需要任何用户输入。每个测试的结果都是一个浮点数。程序必须是自包含的，并且可以直接运行。", "solution": "所述问题是有效的。它具有科学依据，提法恰当，客观，并包含唯一解所需的所有必要信息。任务是基于卷积定理，实现使用快速傅里叶变换（FFT）计算线性卷积这一成熟的数值方法。该问题是计算物理和信号处理中的一个标准练习。\n\n解决方案首先建立连接线性卷积、循环卷积和离散傅里叶变换（DFT）的理论原理。随后，基于这些原理设计一个算法，并针对一组给定的测试用例，通过与直接计算方法进行对比来验证其实现。\n\n两个有限长度实值序列 $x[n]$（长度为 $N$）和 $h[n]$（长度为 $M$）的离散线性卷积 $y[k]$ 定义为：\n$$\ny[k] = (x * h)[k] = \\sum_{n=-\\infty}^{\\infty} x[n] h[k-n]\n$$\n对于因果序列，即 $x[n]$ 仅在索引 $n \\in [0, N-1]$ 上非零，$h[n]$ 仅在索引 $n \\in [0, M-1]$ 上非零，此和仅在有限范围内非零。所得序列 $y[k]$ 的长度为 $L = N+M-1$，其索引 $k \\in [0, N+M-2]$。\n\n长度为 $L$ 的序列 $x[n]$ 的离散傅里叶变换（DFT）由下式给出：\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n] e^{-i 2\\pi nk/L} \\quad \\text{for } k \\in [0, L-1]\n$$\n其对应的离散傅里叶逆变换（IDFT）为：\n$$\nx[n] = \\frac{1}{L} \\sum_{k=0}^{L-1} X[k] e^{i 2\\pi nk/L} \\quad \\text{for } n \\in [0, L-1]\n$$\n快速傅里叶变换（FFT）是计算DFT的一种高效算法。\n\nDFT的卷积定理指出，两个长度为 $L$ 的序列的循环卷积可以通过对其DFT的逐元素乘积进行IDFT来计算：\n$$\n(x_L \\circledast h_L)[n] = \\text{IDFT}(\\text{DFT}(x_L) \\cdot \\text{DFT}(h_L))\n$$\n其中 $\\cdot$ 表示逐元素乘法。循环卷积与线性卷积不同。但是，如果首先将序列补零到足够长的长度，就可以使用循环卷积正确计算长度为 $N$ 和 $M$ 的序列的线性卷积。\n\n为避免时域混叠（循环卷积的结果会回卷并污染自身），我们必须将两个序列都用零填充到长度 $L \\ge N+M-1$。设 $x_{pad}$ 和 $h_{pad}$ 是序列 $x$ 和 $h$ 补零至长度 $L$ 后的序列。$x_{pad}$ 和 $h_{pad}$ 的循环卷积在数值上将与原始序列 $x$ 和 $h$ 的线性卷积相同。\n\n这就得到了使用FFT计算线性卷积的以下算法：\n1.  给定长度为 $N$ 的输入序列 $x[n]$ 和长度为 $M$ 的输入序列 $h[n]$。\n2.  确定所需的最小填充长度：$L = N+M-1$。\n3.  创建两个长度均为 $L$ 的新序列 $x_{pad}$ 和 $h_{pad}$。这是通过在 $x[n]$ 后附加 $M-1$ 个零，并在 $h[n]$ 后附加 $N-1$ 个零来完成的。\n4.  使用FFT算法计算填充后序列的DFT：\n    $$\n    X_{pad}[k] = \\text{FFT}(x_{pad})\n    $$\n    $$\n    H_{pad}[k] = \\text{FFT}(h_{pad})\n    $$\n5.  在频域中逐元素相乘DFT：\n    $$\n    Y_{pad}[k] = X_{pad}[k] \\cdot H_{pad}[k]\n    $$\n6.  使用逆FFT（IFFT）算法计算乘积的逆DFT：\n    $$\n    y_{fft}[n] = \\text{IFFT}(Y_{pad}[k])\n    $$\n所得序列 $y_{fft}[n]$ 是 $x[n]$ 和 $h[n]$ 的线性卷积。由于输入序列是实值的，卷积的理论结果也应是实数。由于有限精度计算，计算出的 $y_{fft}[n]$ 的虚部会非零，但应该可以忽略不计。我们取结果的实部 $\\text{Re}(y_{fft}[n])$ 作为最终答案。\n\n为了验证这种基于FFT的方法的数值精度，我们将其结果 $y_{FFT}$ 与使用直接时域卷积算法计算的参考结果 $y_{direct}$ 进行比较。误差通过所得序列所有元素上的最大绝对差来量化：\n$$\ne = \\max_{k} | y_{FFT}[k] - y_{direct}[k] |\n$$\n对每个指定的测试用例都计算此误差 $e$。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Computes linear convolution using FFT and validates against a direct method.\n    \"\"\"\n\n    def compute_convolution_fft(x, h):\n        \"\"\"\n        Computes the linear convolution of two 1D sequences using the FFT method.\n        \n        Args:\n            x (np.ndarray): The first sequence.\n            h (np.ndarray): The second sequence (kernel).\n        \n        Returns:\n            np.ndarray: The linear convolution of x and h.\n        \"\"\"\n        N = len(x)\n        M = len(h)\n        # 1. Determine padding length L >= N + M - 1.\n        L = N + M - 1\n\n        # 2. Zero-pad both sequences to length L.\n        x_pad = np.zeros(L)\n        x_pad[:N] = x\n        \n        h_pad = np.zeros(L)\n        h_pad[:M] = h\n\n        # 3. Compute DFTs using FFT.\n        X_pad = fft(x_pad)\n        H_pad = fft(h_pad)\n\n        # 4. Multiply pointwise in the frequency domain.\n        Y_pad = X_pad * H_pad\n\n        # 5. Compute inverse DFT using IFFT.\n        y_fft = ifft(Y_pad)\n\n        # The result must be real since inputs are real.\n        # The length of the result is L.\n        return np.real(y_fft)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A\n        (np.array([1.0, 2.0, 3.0]), np.array([0.0, 1.0, 0.5])),\n        # Test B\n        (np.array([1.0, 0.0, 0.0, 0.0]), np.array([-1.0, 2.0, -1.0])),\n        # Test C\n        (np.sin(2 * np.pi * np.arange(8) / 8.0), np.array([0.25, 0.5, 0.25])),\n        # Test D\n        (np.array([2.5]), np.array([-3.0, 4.0])),\n        # Test E\n        (np.array([-1.0, 2.0, -3.0, 4.0, -5.0]), np.array([0.5, -0.25, 0.125, -0.0625]))\n    ]\n\n    errors = []\n    for x_test, h_test in test_cases:\n        # Compute convolution using the implemented FFT method.\n        y_fft_result = compute_convolution_fft(x_test, h_test)\n        \n        # Compute reference convolution using a direct, trusted method.\n        # The 'full' mode computes the linear convolution of length N+M-1.\n        y_direct_result = np.convolve(x_test, h_test, mode='full')\n        \n        # Ensure both results have the same length for comparison.\n        L = len(x_test) + len(h_test) - 1\n        # The FFT-based result will have length L. The direct one will as well.\n        if len(y_fft_result) != L or len(y_direct_result) != L:\n            # This check is for robusteness but shouldn't fail with correct logic.\n            raise ValueError(\"Convolution result lengths do not match.\")\n\n        # Calculate the maximum absolute error.\n        max_abs_error = np.max(np.abs(y_fft_result - y_direct_result))\n        errors.append(max_abs_error)\n\n    # Format the results according to the specification.\n    # The \"{:.12g}\" format specifier ensures at most 12 significant digits.\n    formatted_errors = [f\"{err:.12g}\" for err in errors]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_errors)}]\")\n\nsolve()\n```", "id": "2419128"}, {"introduction": "在掌握了卷积这个“正问题”之后，我们现在转向更具挑战性的“反问题”：反卷积，即从一个模糊且带噪声的版本中恢复原始信号。直接的逆运算通常是不稳定的，并且会将噪声放大到灾难性的程度。这个高级实践介绍了吉洪诺夫正则化 (Tikhonov regularization)，一种用于稳定逆过程的强大技术，并挑战您在噪声抑制和信号保真度之间找到最佳平衡点 [@problem_id:2419120]。", "problem": "你需要实现一个完整的、确定性的程序，该程序使用 Tikhonov 正则化对被加性白噪声污染的一维信号执行稳定的反卷积。实现必须从离散卷积和离散傅里叶变换（DFT）的基本定义出发，并应用卷积定理来推导算法。你的程序必须评估一个固定的测试套件，并输出一行包含数值结果的格式化字符串。\n\n本任务的基础是：\n- 长度为 $N$ 的信号的离散循环卷积定义为 $$(h \\circledast x)[n] = \\sum_{m=0}^{N-1} h[m]\\, x[(n-m) \\bmod N].$$\n- 离散傅里叶变换（DFT）及其逆变换，\n$$X[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N}, \\quad x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi kn/N}.$$\n- 卷积定理，它指出对于循环卷积，$$\\mathcal{F}\\{h \\circledast x\\}[k] = H[k]\\, X[k],$$ 其中 $\\mathcal{F}$ 表示 DFT，而 $H[k], X[k]$ 是 $h[n]$ 和 $x[n]$ 的 DFT。\n- Tikhonov 正则化最小二乘目标（零阶，正则化算子为单位矩阵）由下式给出\n$$J(x) = \\lVert h \\circledast x - y \\rVert_2^2 + \\lambda \\lVert x \\rVert_2^2,$$\n其中 $y[n]$ 是观测到的含噪模糊信号，$\\lambda \\ge 0$ 是正则化参数，$\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。\n\n你的实现必须：\n1. 在正向建模（生成观测信号）和反卷积中均使用长度为 $N$ 的循环卷积。\n2. 采用基于 DFT 的逐点解来求解 Tikhonov 正则化正规方程，以计算反卷积估计值 $\\hat{x}[n]$：\n   - 在 DFT 域中进行计算。对于每个 DFT 频点 $k$，计算\n     $$\\hat{X}[k] = \\frac{H^*[k]}{|H[k]|^2 + \\lambda}\\, Y[k],$$\n     其中 $H^*[k]$ 是 $H[k]$ 的复共轭， $|H[k]|^2 = H^*[k] H[k]$，$Y[k]$ 是 $y[n]$ 的 DFT。然后应用逆 DFT 获得 $\\hat{x}[n]$。\n   - 对于 $\\lambda = 0$ 的特殊情况，通过将分母 $|H[k]|^2$ 替换为 $|H[k]|^2 + \\varepsilon$（其中 $\\varepsilon = 10^{-12}$ 为一个固定值）来处理数值稳定性问题，以避免除以零。\n3. 在时域中生成指定标准差、零均值的加性高斯白噪声。为了保证可复现性，请使用固定的随机种子。\n4. 对于每个测试用例，评估候选正则化参数 $\\lambda \\in \\{0, 10^{-8}, 10^{-6}, 10^{-4}, 10^{-3}, 10^{-2}, 10^{-1}\\}$ 的固定列表，并选择使反卷积估计值与已知的真实信号之间的均方根误差（RMSE）最小的 $\\lambda$ 值。RMSE 定义为\n   $$\\mathrm{RMSE}(\\hat{x}, x) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} \\left(\\hat{x}[n] - x[n]\\right)^2}.$$\n5. 对于每个测试用例，还要计算对应于 $\\lambda = 0$ 并按照上述规定使用 $\\varepsilon$ 防护措施的朴素逆滤波器的 RMSE。\n\n角度单位要求：所有三角函数必须接受以弧度为单位的角度。本问题不涉及物理单位。\n\n测试套件规范：\n- 共享参数：\n  - 信号长度 $N = 512$。\n  - 所有地方均使用长度为 $N$ 的循环卷积。\n  - 随机数生成器种子必须在开始时设置为 $12345$ 一次。\n  - 候选正则化参数：上文第 4 项中列出的七个值。\n  - 对于所有核，将它们的非零采样点放置在数组的开头，并补零至长度 $N$，以将其表示为长度为 $N$ 的序列。\n\n- 测试用例 1（中度高斯模糊，复合平滑信号）：\n  - 对于 $n = 0,1,\\dots,N-1$，真实信号 $x_1[n]$为：\n    $$x_1[n] = \\exp\\!\\left(-\\frac{(n-100)^2}{2\\cdot 8^2}\\right) + 0.6\\, \\exp\\!\\left(-\\frac{(n-300)^2}{2\\cdot 12^2}\\right) + 0.1\\, \\sin\\!\\left(2\\pi \\cdot 0.05 \\cdot n\\right).$$\n    正弦函数的参数以弧度为单位。\n  - 模糊核 $h_1[n]$ 是一个标准差为 $\\sigma_k = 2.0$ 个样本的离散高斯函数，在整数索引处采样并归一化使其和为一。在 $m \\in \\{-\\lceil 6\\sigma_k \\rceil,\\dots,\\lceil 6\\sigma_k \\rceil\\}$ 范围内取对称抽头，即包含足够的支持域来近似高斯函数，然后将这些抽头按 $m$ 的递增顺序放置在长度为 $N$ 的数组的开头，并将其余部分补零。\n  - 加性高斯白噪声标准差：$\\sigma_{\\text{noise}} = 0.02$。\n  - 观测数据：$y_1 = h_1 \\circledast x_1 + \\eta$，其中 $\\eta$ 是噪声序列。\n\n- 测试用例 2（匀速运动模糊，阶跃状信号）：\n  - 真实信号 $x_2[n]$：\n    $$x_2[n] = \\begin{cases}1, & 120 \\le n &lt; 220\\\\ 0, & \\text{其他情况}\\end{cases} + 0.1\\, \\sin\\!\\left(2\\pi \\cdot 0.03 \\cdot n\\right).$$\n  - 模糊核 $h_2[n]$ 是一个长度为 $L = 21$ 个样本的均匀盒状函数，在其支持域上的值为 $1/L$，其他地方为零，然后如上所述补零至长度 $N$。\n  - 加性高斯白噪声标准差：$\\sigma_{\\text{noise}} = 0.03$。\n  - 观测数据：$y_2 = h_2 \\circledast x_2 + \\eta$。\n\n- 测试用例 3（单位核边界情况，带有背景的稀疏脉冲）：\n  - 真实信号 $x_3[n]$：\n    $$x_3[n] = 1.0\\cdot \\delta[n-50] + 0.7\\cdot \\delta[n-200] + 1.2\\cdot \\delta[n-350] + 0.05\\, \\exp\\!\\left(-\\frac{(n-256)^2}{2\\cdot 20^2}\\right),$$\n    其中 $\\delta[\\cdot]$ 是整数索引上的克罗内克 δ 函数。\n  - 模糊核 $h_3[n]$ 是单位核（离散 δ 函数），$h_3[0]=1$ 且对于 $n\\neq 0$ 时 $h_3[n]=0$。\n  - 加性高斯白噪声标准差：$\\sigma_{\\text{noise}} = 0.02$。\n  - 观测数据：$y_3 = h_3 \\circledast x_3 + \\eta$。\n\n所需输出：\n- 对于每个测试用例 $j \\in \\{1,2,3\\}$，计算：\n  1. 候选集中使 Tikhonov 反卷积估计与真实信号之间的 RMSE 最小的值 $\\lambda^{\\star}_j$。\n  2. 在 $\\lambda^{\\star}_j$ 处达到的最小 RMSE $\\mathrm{RMSE}_{\\min, j}$。\n  3. 由 $\\lambda=0$ 情况（带 $\\varepsilon$ 防护措施）定义的朴素逆滤波器的 RMSE $\\mathrm{RMSE}_{\\text{naive}, j}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  $$[\\lambda^{\\star}_1, \\mathrm{RMSE}_{\\min,1}, \\mathrm{RMSE}_{\\text{naive},1}, \\lambda^{\\star}_2, \\mathrm{RMSE}_{\\min,2}, \\mathrm{RMSE}_{\\text{naive},2}, \\lambda^{\\star}_3, \\mathrm{RMSE}_{\\min,3}, \\mathrm{RMSE}_{\\text{naive},3}],$$\n  其中所有条目都打印为浮点数。不应打印任何其他文本。", "solution": "问题陈述已经过严格审查，并被确定为有效。这是一个在计算物理领域，特别是在信号处理和逆问题范畴内，定义明确、科学上合理且自成体系的问题。所有常数、函数和过程都得到了足够清晰和精确的定义，可以得出一个唯一的、确定性的解。因此，我们将着手推导和实现所需的算法。\n\n问题的核心是从一个退化的观测信号 $y[n]$ 中恢复原始信号 $x[n]$。该观测信号被建模为 $x[n]$ 与一个已知的模糊核 $h[n]$ 的循环卷积，并被加性高斯白噪声 $\\eta[n]$ 进一步污染。因此，模型为 $y = h \\circledast x + \\eta$。一种朴素的求解方法是试图在频域中通过 $\\hat{X}[k] = Y[k]/H[k]$ 来反转卷积，但这种方法是出了名的不稳定，因为模糊核的离散傅里叶变换（DFT）$H[k]$ 通常有接近于零的值。这会放大 $Y[k]$ 相应频率分量中的噪声。\n\n为了解决这种不稳定性，我们采用 Tikhonov 正则化。目标是找到一个信号估计值 $\\hat{x}$，以最小化正则化的最小二乘目标函数：\n$$\nJ(x) = \\lVert h \\circledast x - y \\rVert_2^2 + \\lambda \\lVert x \\rVert_2^2\n$$\n此处，$\\lambda \\ge 0$ 是正则化参数，它控制着对数据的保真度（第一项）与解的平滑度或大小（第二项）之间的权衡。通过利用卷积定理和帕塞瓦尔定理，这个最小化过程可以在频域中高效执行。目标函数变为对 $x[n]$ 的 DFT 的每个频率分量 $X[k]$ 的独立最小化问题之和：\n$$\nJ(X) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( |H[k]X[k] - Y[k]|^2 + \\lambda|X[k]|^2 \\right)\n$$\n通过将关于 $X[k]$ 的梯度设为零，求解最优的 $X[k]$，得到 Tikhonov 正则化反卷积滤波器：\n$$\n\\hat{X}[k] = \\frac{H^*[k] Y[k]}{|H[k]|^2 + \\lambda}\n$$\n其中 $H^*[k]$ 是 $H[k]$ 的复共轭。然后，通过对 $\\hat{X}[k]$ 应用逆 DFT，可以恢复时域中的估计信号 $\\hat{x}[n]$。\n\n实现将按以下步骤进行：\n\n1.  **系统设置**：我们定义共享参数：信号长度 $N=512$，候选正则化参数列表 $\\lambda \\in \\{0, 10^{-8}, 10^{-6}, 10^{-4}, 10^{-3}, 10^{-2}, 10^{-1}\\}$，以及一个用于在 $\\lambda=0$ 情况下保证数值稳定性的小常数 $\\varepsilon = 10^{-12}$。为了保证可复现性，随机数生成器使用种子 $12345$ 进行初始化。\n\n2.  **测试用例生成**：对于三个测试用例中的每一个，我们将根据其指定的数学定义，以编程方式生成长度为 $N$ 的真实信号 $x[n]$ 和模糊核 $h[n]$。\n    - 对于高斯核 $h_1[n]$，我们首先计算整数索引 $m$ 在 $[-\\lceil 6\\sigma_k \\rceil, \\lceil 6\\sigma_k \\rceil]$ 范围内的未归一化抽头，其中 $\\sigma_k = 2.0$。然后将这些抽头归一化，使其和为一。将得到的抽头序列放置在长度为 $N$ 的核数组的开头。\n    - 对于盒状核 $h_2[n]$，将一个长度为 $L=21$ 且填充值为 $1/21$ 的数组放置在长度为 $N$ 的核数组的开头。\n    - 单位核 $h_3[n]$ 是一个离散 δ 函数，其中 $h_3[0]=1$，所有其他元素为零。\n\n3.  **正向模型仿真**：为每个测试用例模拟观测信号 $y[n]$。\n    - 循环卷积 $h \\circledast x$ 通过卷积定理使用 DFT 高效计算：$h \\circledast x = \\mathcal{F}^{-1}\\{\\mathcal{F}\\{h\\} \\cdot \\mathcal{F}\\{x\\}\\}$。\n    - 生成一个零均值、具有指定标准差 $\\sigma_{\\text{noise}}$ 的加性高斯白噪声序列 $\\eta[n]$。\n    - 最终的观测信号为 $y[n] = (h \\circledast x)[n] + \\eta[n]$。\n\n4.  **反卷积与参数选择**：对于每个测试用例，我们执行以下过程：\n    - 我们计算观测信号 $y[n]$ 和核 $h[n]$ 的 DFT，得到 $Y[k]$ 和 $H[k]$。\n    - 我们遍历每个候选的 $\\lambda$ 值。对于每个 $\\lambda$，我们使用 Tikhonov 滤波器公式计算估计信号的 DFT $\\hat{X}[k]$。如规定，对于 $\\lambda=0$，分母 $|H[k]|^2$ 被替换为 $|H[k]|^2 + \\varepsilon$。\n    - 通过对 $\\hat{X}[k]$ 进行逆 DFT 得到估计信号 $\\hat{x}[n]$。我们取结果的实部以丢弃由数值精度误差引起的可以忽略不计的虚部。\n    - 计算估计值 $\\hat{x}[n]$ 与真实信号 $x[n]$ 之间的均方根误差（RMSE），公式为 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} (\\hat{x}[n] - x[n])^2}$。\n    - 将导致最小 RMSE 的 $\\lambda$ 值确定为最优参数 $\\lambda^\\star$。记录相应的最小 RMSE $\\mathrm{RMSE}_{\\min}$。此外，存储朴素逆滤波器（$\\lambda=0$ 的情况）的 RMSE $\\mathrm{RMSE}_{\\text{naive}}$。\n\n5.  **输出格式化**：将得到的九个数值（对于 $j=1,2,3$ 的 $\\lambda^\\star_j, \\mathrm{RMSE}_{\\min,j}, \\mathrm{RMSE}_{\\text{naive},j}$）收集并按要求格式化为单行字符串。\n\n这种结构化的方法确保了解决方案是对问题陈述中概述的原理和规范的直接且正确的实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the deconvolution test suite.\n    \"\"\"\n    # Shared parameters\n    N = 512\n    lambda_candidates = [0.0, 1e-8, 1e-6, 1e-4, 1e-3, 1e-2, 1e-1]\n    epsilon = 1e-12\n    rng = np.random.default_rng(12345)\n\n    # --- Test Case 1 ---\n    # True signal x1\n    n = np.arange(N)\n    x1 = (np.exp(-(n - 100)**2 / (2 * 8**2)) +\n          0.6 * np.exp(-(n - 300)**2 / (2 * 12**2)) +\n          0.1 * np.sin(2 * np.pi * 0.05 * n))\n\n    # Blur kernel h1\n    sigma_k = 2.0\n    support_half_width = int(np.ceil(6 * sigma_k))\n    m = np.arange(-support_half_width, support_half_width + 1)\n    h1_taps = np.exp(-m**2 / (2 * sigma_k**2))\n    h1_taps /= np.sum(h1_taps)\n    h1 = np.zeros(N)\n    h1[0:len(h1_taps)] = h1_taps\n    \n    # Noise and observation y1\n    noise_std1 = 0.02\n    \n    # --- Test Case 2 ---\n    # True signal x2\n    x2 = np.zeros(N)\n    x2[120:220] = 1.0\n    x2 += 0.1 * np.sin(2 * np.pi * 0.03 * n)\n\n    # Blur kernel h2\n    L = 21\n    h2 = np.zeros(N)\n    h2[0:L] = 1.0 / L\n\n    # Noise and observation y2\n    noise_std2 = 0.03\n\n    # --- Test Case 3 ---\n    # True signal x3\n    x3 = np.zeros(N)\n    x3[50] = 1.0\n    x3[200] = 0.7\n    x3[350] = 1.2\n    x3 += 0.05 * np.exp(-(n - 256)**2 / (2 * 20**2))\n    \n    # Blur kernel h3\n    h3 = np.zeros(N)\n    h3[0] = 1.0\n    \n    # Noise and observation y3\n    noise_std3 = 0.02\n\n    test_cases = [\n        (x1, h1, noise_std1),\n        (x2, h2, noise_std2),\n        (x3, h3, noise_std3),\n    ]\n\n    results = []\n    for x_true, h, noise_std in test_cases:\n        # Generate observed signal y = h * x + noise\n        noise = rng.normal(loc=0.0, scale=noise_std, size=N)\n        y = np.real(np.fft.ifft(np.fft.fft(h) * np.fft.fft(x_true))) + noise\n\n        # Pre-compute DFTs\n        Y = np.fft.fft(y)\n        H = np.fft.fft(h)\n        H_conj = np.conj(H)\n        H_mag_sq = np.abs(H)**2\n\n        min_rmse = float('inf')\n        best_lambda = -1.0\n        naive_rmse = -1.0\n\n        for lam in lambda_candidates:\n            # Apply Tikhonov filter in frequency domain\n            if lam == 0:\n                denominator = H_mag_sq + epsilon\n            else:\n                denominator = H_mag_sq + lam\n            \n            X_hat = (H_conj * Y) / denominator\n            \n            # Inverse FFT to get signal estimate\n            x_hat = np.real(np.fft.ifft(X_hat))\n            \n            # Calculate RMSE\n            current_rmse = np.sqrt(np.mean((x_hat - x_true)**2))\n            \n            if lam == 0:\n                naive_rmse = current_rmse\n            \n            if current_rmse < min_rmse:\n                min_rmse = current_rmse\n                best_lambda = lam\n        \n        results.extend([best_lambda, min_rmse, naive_rmse])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2419120"}]}