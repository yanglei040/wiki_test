{"hands_on_practices": [{"introduction": "我们为什么要在计算中使用卷积定理？这个练习直击了问题的核心。你将通过两种方式实现卷积：一种是复杂度为 $O(N^2)$ 的直接求和法，另一种是利用快速傅里叶变换 (FFT) 的频域相乘法，其复杂度仅为 $O(N \\log N)$。通过亲手实现并比较这两种方法，你将深刻体会到卷积定理在计算效率上的巨大优势，并理解为何基于FFT的方法是信号处理和科学计算的基石。[@problem_id:2383312]", "problem": "要求您通过比较直接的时域线性卷积与使用基2 Cooley–Tukey 快速傅里叶变换 (FFT) 的频域方法，来对卷积定理进行数值验证。\n\n请完全在离散时间内处理，使用非负整数索引的序列。所有量均为无量纲。复指数内的角度必须以弧度为单位计量。\n\n从以下基本理论出发：\n- 两个有限长度序列 $\\{x[n]\\}_{n=0}^{n_x-1}$ 和 $\\{h[n]\\}_{n=0}^{n_h-1}$ 的离散时间线性卷积定义为 $y[n] = \\sum_{m=-\\infty}^{\\infty} x[m] h[n-m]$，其中，当 $m \\notin \\{0,\\dots,n_x-1\\}$ 时，$x[m]=0$；当 $m \\notin \\{0,\\dots,n_h-1\\}$ 时，$h[m]=0$。线性卷积的长度为 $n_y = n_x + n_h - 1$。\n- 长度为 $L$ 的序列 $\\{x[n]\\}_{n=0}^{L-1}$ 的离散傅里叶变换 (DFT) 为 $X[k] = \\sum_{n=0}^{L-1} x[n] \\exp\\!\\left(-2\\pi i \\frac{kn}{L}\\right)$，其中 $k \\in \\{0,\\dots,L-1\\}$；其逆变换为 $x[n] = \\frac{1}{L}\\sum_{k=0}^{L-1} X[k] \\exp\\!\\left(2\\pi i \\frac{kn}{L}\\right)$，其中 $n \\in \\{0,\\dots,L-1\\}$。角度以弧度为单位。\n\n任务：\n- 实现一个基2 Cooley–Tukey 快速傅里叶变换 (FFT) 及其逆变换，用于计算 DFT 和逆 DFT。您的实现必须要求输入长度为 $2$ 的幂，并且必须使用分治法，通过旋转因子 $\\exp\\!\\left(-2\\pi i \\frac{k}{N}\\right)$ 将序列分解为偶数和奇数索引。\n- 根据定义实现直接线性卷积，使用显式求和，其时间复杂度为 $\\mathcal{O}(n_x n_h)$。\n- 按如下方式实现基于 FFT 的线性卷积：给定 $\\{x[n]\\}$ 和 $\\{h[n]\\}$，选择 $L$ 为不小于 $n_x + n_h - 1$ 的最小的 $2$ 的幂，将两个序列都补零至长度 $L$，通过您的基2 Cooley–Tukey FFT 计算它们的 DFT，在频域中进行逐点相乘，然后应用您的逆 FFT。返回前 $n_x + n_h - 1$ 个样本以获得线性卷积结果。\n- 为了进行数值比较，请使用固定的随机种子生成信号，以确保结果可复现。对于下方的每个测试，计算直接线性卷积和基于 FFT 的线性卷积之间的最大绝对差：\n  $$\\varepsilon = \\max_{0 \\le n \\le n_x+n_h-2} \\left|y_{\\text{direct}}[n] - y_{\\text{FFT}}[n]\\right|.$$\n  报告 $\\varepsilon$ 的值，四舍五入到 $10$ 位小数。\n\n角度单位要求：\n- 所有复指数必须使用弧度。\n\n测试套件：\n- 使用单一的随机数生成器，种子为 $2025$。对于每种情况，从均值为 $0$、方差为 $1$ 的标准正态分布中抽取每个独立的实部。\n  1. 一般实数情况：$n_x = 64$，$n_h = 47$，$x[n]$ 和 $h[n]$ 为实值。\n  2. 一般复数情况：$n_x = 32$，$n_h = 16$，$x[n]$ 和 $h[n]$ 为复值，其独立的实部和虚部按上述方式抽取。\n  3. 微小情况：$n_x = 1$，$n_h = 1$，$x[n]$ 和 $h[n]$ 为实值。\n  4. 素数长度边缘情况：$n_x = 7$，$n_h = 11$，$x[n]$ 和 $h[n]$ 为实值。\n\n答案规格：\n- 对于每个测试用例，计算如上定义的 $\\varepsilon$。预期的结果是，由于数值舍入误差，每个 $\\varepsilon$ 都是一个小的非负实数，通常在 $10^{-12}$ 或更小的数量级。没有物理单位。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 $1$ 到 $4$ 的顺序排列，其中每个条目是浮点数 $\\varepsilon$ 并四舍五入到 $10$ 位小数。例如，一个有效的输出格式类似于 $[\\text{e1},\\text{e2},\\text{e3},\\text{e4}]$，其中每个 $\\text{e}$ 打印为一个小数，小数点后恰好有 $10$ 位数字（无百分号）。\n\n您的最终交付物必须是一个完整、可运行的程序，该程序执行所有计算，并仅按指定格式打印所需的单行输出。", "solution": "问题陈述经过审慎分析，被认定为有效。它在科学上基于傅里叶分析的原理，特别是卷积定理。该问题是良构的，为执行数值验证提供了所有必要的定义、参数和约束。指令客观明确，能够导出一个唯一且可复现的解。因此，我们可以着手进行推导和实现。\n\n目标是通过实现并比较两种计算两个有限离散时间序列 $\\{x[n]\\}_{n=0}^{n_x-1}$ 和 $\\{h[n]\\}_{n=0}^{n_h-1}$ 线性卷积的方法，来验证离散卷积定理。\n\n第一种方法是直接计算。线性卷积表示为 $\\{y[n]\\} = \\{x[n]\\} * \\{h[n]\\}$，定义如下：\n$$\ny[n] = \\sum_{m=-\\infty}^{\\infty} x[m] h[n-m]\n$$\n鉴于 $x[m]$ 仅在 $m \\in \\{0, \\dots, n_x-1\\}$ 时非零，而 $h[k]$ 仅在 $k \\in \\{0, \\dots, n_h-1\\}$ 时非零，该求和仅在有限的 $m$ 值范围内非零。得到的序列 $y[n]$ 长度为 $n_y = n_x + n_h - 1$。直接实现涉及遍历索引 $n$ 和 $m$ 的嵌套循环，导致计算复杂度为 $\\mathcal{O}(n_x n_h)$。\n\n第二种方法利用了卷积定理，该定理指出时域中的卷积等效于频域中的逐点相乘。对于离散序列，该定理适用于循环卷积：\n$$\n\\text{DFT}\\{x \\circledast_L y\\} = \\text{DFT}\\{x\\} \\cdot \\text{DFT}\\{y\\}\n$$\n其中 $\\circledast_L$ 表示长度为 $L$ 的循环卷积，DFT 的长度也为 $L$。为了利用此属性计算线性卷积，我们必须防止循环卷积固有的回卷效应（时域混叠）。这可以通过将序列 $x[n]$ 和 $h[n]$ 补零至长度 $L$ (使得 $L \\ge n_x + n_h - 1$) 来实现。然后计算它们的 $L$ 点 DFT 的乘积，并应用一个 $L$ 点逆 DFT 返回到时域。所得到的 $L$ 点序列的前 $n_x + n_h - 1$ 个样本与线性卷积的结果完全相同。\n\n一个长度为 $N$ 的序列 $\\{x[n]\\}$ 的离散傅里叶变换 (DFT) 为：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-2\\pi i \\frac{kn}{N}\\right), \\quad k \\in \\{0, \\dots, N-1\\}\n$$\nDFT 的直接计算复杂度为 $\\mathcal{O}(N^2)$。本问题强制要求使用更高效的基2 Cooley–Tukey 快速傅里叶变换 (FFT) 算法，其复杂度为 $\\mathcal{O}(N \\log N)$，但要求序列长度 $N$ 是 $2$ 的幂。\n\nCooley-Tukey 算法是一种分治算法。对于一个长度为 $N = 2^p$ 的序列 $x[n]$，我们将 DFT 的求和分解为偶数索引项和奇数索引项：\n$$\nX[k] = \\sum_{m=0}^{N/2-1} x[2m] e^{-2\\pi i \\frac{k(2m)}{N}} + \\sum_{m=0}^{N/2-1} x[2m+1] e^{-2\\pi i \\frac{k(2m+1)}{N}}\n$$\n令 $x_e[m] = x[2m]$ 和 $x_o[m] = x[2m+1]$ 分别为偶数和奇数子序列，每个长度为 $N/2$。表达式变为：\n$$\nX[k] = \\sum_{m=0}^{N/2-1} x_e[m] e^{-2\\pi i \\frac{km}{N/2}} + e^{-2\\pi i \\frac{k}{N}} \\sum_{m=0}^{N/2-1} x_o[m] e^{-2\\pi i \\frac{km}{N/2}}\n$$\n这表明 $N$ 点 DFT 可以由两个 $(N/2)$ 点 DFT 构建。设 $X_e[k]$ 和 $X_o[k]$ 分别是 $x_e$ 和 $x_o$ 的 $(N/2)$ 点 DFT。设 $W_N^k = \\exp(-2\\pi i \\frac{k}{N})$ 为“旋转因子”。那么对于 $k \\in \\{0, \\dots, N/2 - 1\\}$：\n$$\nX[k] = X_e[k] + W_N^k X_o[k]\n$$\n利用 DFT 的周期性 ($X_e[k] = X_e[k+N/2]$) 和旋转因子的性质 ($W_N^{k+N/2} = -W_N^k$)，我们得到变换的后半部分：\n$$\nX[k + N/2] = X_e[k] - W_N^k X_o[k]\n$$\n此分解被递归应用，直到我们达到长度 $N=1$ 的基例，此时 DFT 是恒等操作：$\\text{DFT}\\{x[0]\\} = x[0]$。\n\n对于基于 FFT 的卷积，我们必须选择变换长度 $L$，使其为不小于 $n_x + n_h - 1$ 的最小的 $2$ 的幂。在将 $x[n]$ 和 $h[n]$ 补零至此长度 $L$ 后，我们计算它们的 FFT，将结果相乘，然后执行逆 FFT (IFFT)。IFFT 可以通过以下恒等式使用 FFT 算法来计算：\n$$\n\\text{IFFT}\\{X[k]\\} = \\frac{1}{N} \\overline{\\text{FFT}\\{\\overline{X[k]}\\}}\n$$\n其中 $\\overline{z}$ 表示 $z$ 的复共轭。\n\n最后一步是比较直接卷积的结果 $y_{\\text{direct}}[n]$ 和基于 FFT 方法的结果 $y_{\\text{FFT}}[n]$，通过计算最大绝对差：\n$$\n\\varepsilon = \\max_{0 \\le n < n_x+n_h-1} \\left|y_{\\text{direct}}[n] - y_{\\text{FFT}}[n]\\right|\n$$\n这个误差 $\\varepsilon$ 应该是一个很小的数，接近机器精度，这证实了两种方法的数值等效性，从而在实际计算环境中验证了卷积定理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cooley_tukey_fft(x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the radix-2 Cooley-Tukey FFT algorithm recursively.\n    Input length must be a power of 2.\n    \"\"\"\n    N = len(x)\n    if N == 0:\n        return np.array([], dtype=np.complex128)\n    \n    # Validate that N is a power of 2\n    if (N & (N - 1)) != 0:\n        raise ValueError(\"FFT input length must be a power of 2.\")\n\n    # Base case for recursion\n    if N == 1:\n        return x.astype(np.complex128)\n\n    # Recursive step: divide\n    x_even = cooley_tukey_fft(x[0::2])\n    x_odd = cooley_tukey_fft(x[1::2])\n\n    # Combine step: conquer\n    k = np.arange(N // 2)\n    \n    # Twiddle factors. Angles must be in radians.\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    # Butterfly operations\n    X_k = x_even + twiddle_factors * x_odd\n    X_k_plus_N2 = x_even - twiddle_factors * x_odd\n    \n    return np.concatenate([X_k, X_k_plus_N2])\n\ndef inverse_fft(X: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the inverse FFT using the Cooley-Tukey FFT implementation.\n    \"\"\"\n    N = len(X)\n    if N == 0:\n        return np.array([], dtype=np.complex128)\n        \n    # The IFFT can be computed by conjugating the input and output\n    # of a forward FFT and scaling by 1/N.\n    result = np.conj(cooley_tukey_fft(np.conj(X))) / N\n    return result\n\ndef direct_convolution(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes linear convolution using the direct summation definition.\n    Complexity is O(nx * nh).\n    \"\"\"\n    nx = len(x)\n    nh = len(h)\n    ny = nx + nh - 1\n\n    if ny <= 0:\n        return np.array([])\n    \n    # The output type should accommodate complex results if inputs are complex\n    y_dtype = np.result_type(x.dtype, h.dtype, np.float64)\n    y = np.zeros(ny, dtype=y_dtype)\n\n    for n in range(ny):\n        for m in range(nx):\n            if 0 <= n - m < nh:\n                y[n] += x[m] * h[n - m]\n    return y\n\ndef fft_convolution(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes linear convolution using the FFT-based method.\n    \"\"\"\n    nx = len(x)\n    nh = len(h)\n    ny = nx + nh - 1\n    \n    if ny <= 0:\n        return np.array([])\n\n    # Find the smallest power of 2 that is >= ny\n    # (ny-1).bit_length() gives ceil(log2(ny)). 1 << ... gives 2^ceil(log2(ny)).\n    if ny == 1:\n        L = 1\n    else:\n        L = 1 << (ny - 1).bit_length()\n\n    # Zero-pad signals to length L\n    x_padded = np.zeros(L, dtype=x.dtype)\n    x_padded[:nx] = x\n    \n    h_padded = np.zeros(L, dtype=h.dtype)\n    h_padded[:nh] = h\n\n    # Compute FFTs, pointwise product, and inverse FFT\n    X = cooley_tukey_fft(x_padded)\n    H = cooley_tukey_fft(h_padded)\n    Y = X * H\n    y_padded = inverse_fft(Y)\n\n    # Truncate to the linear convolution length\n    return y_padded[:ny]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Use a single random number generator with a fixed seed for reproducibility.\n    # The seed is 2025 as per the problem.\n    rng = np.random.default_rng(2025)\n\n    test_cases = [\n        # (nx, nh, value_type)\n        (64, 47, 'real'),\n        (32, 16, 'complex'),\n        (1, 1, 'real'),\n        (7, 11, 'real'),\n    ]\n\n    results = []\n    for nx, nh, value_type in test_cases:\n        # Generate signals based on test case parameters\n        if value_type == 'real':\n            x = rng.standard_normal(size=nx)\n            h = rng.standard_normal(size=nh)\n        elif value_type == 'complex':\n            x_real = rng.standard_normal(size=nx)\n            x_imag = rng.standard_normal(size=nx)\n            x = x_real + 1j * x_imag\n            h_real = rng.standard_normal(size=nh)\n            h_imag = rng.standard_normal(size=nh)\n            h = h_real + 1j * h_imag\n        \n        # Compute convolution using both methods\n        y_direct = direct_convolution(x, h)\n        y_fft = fft_convolution(x, h)\n\n        # Calculate the maximum absolute difference\n        # The absolute value handles complex numbers correctly.\n        max_abs_diff = np.max(np.abs(y_direct - y_fft))\n        \n        # Append the formatted result\n        results.append(f\"{max_abs_diff:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2383312"}, {"introduction": "在概率论中，卷积定理是计算独立随机变量之和的分布的基石。这个练习将把你之前练习中掌握的高效 FFT 方法应用到一个经典问题上：计算投掷多个骰子所得点数之和的概率分布。通过这个实践，你将连接抽象的数学理论与具体的概率计算，体验如何运用数值工具优雅地解决复杂的组合问题。[@problem_id:2383106]", "problem": "您需要编写一个完整、可运行的程序，该程序使用卷积定理来计算独立掷骰子总和的离散概率分布。中心计算任务是通过将基础分布与自身进行 $n-1$ 次卷积，来获得具有给定基础分布的 $n$ 个独立同分布离散随机变量之和的概率质量函数。您必须使用卷积定理和快速傅里叶变换 (FFT)，而不是直接在时域进行卷积。\n\n需要假设的基本原理：\n- 取整数值的离散随机变量 $X$ 的概率质量函数 (PMF) 是函数 $p(k) = \\mathbb{P}[X = k]$，其中 $k$ 是一个整数。\n- 两个 PMF $p$ 和 $q$ 的离散卷积 $(p * q)(k)$ 定义为 $(p * q)(k) = \\sum_{j} p(j)\\, q(k - j)$。\n- 序列 $x[n]$ 的离散傅里叶变换 (DFT) 是 $\\hat{x}[m] = \\sum_{n=0}^{N-1} x[n]\\, e^{-2 \\pi i m n / N}$，其逆变换为 $\\displaystyle x[n] = \\frac{1}{N}\\sum_{m=0}^{N-1} \\hat{x}[m]\\, e^{+2 \\pi i m n / N}$，其中 $N$ 是变换长度。快速傅里叶变换 (FFT) 是计算 DFT 的一种高效算法。\n- 卷积定理指出，卷积的 DFT 等于 DFT 的逐点乘积：$\\widehat{p * q} = \\hat{p}\\,\\hat{q}$。对于同一序列 $p$ 的 $n$ 重卷积，其 DFT 为 $\\widehat{p^{*n}} = (\\hat{p})^n$。\n\n您的程序必须：\n- 使用卷积定理和 FFT 构建基础骰子 PMF 的 $n$ 重卷积。您必须论证并实现零填充，以确保结果对应于没有循环混叠的线性卷积。推导、论证并使用保证 $n$ 重卷积没有回绕效应的最小填充长度。具体来说，基础骰子取值为 $\\{1,2,\\dots,m\\}$，其 PMF 条目为 $p_1, p_2, \\dots, p_m$，而 $n$ 重和的取值在一个有限整数区间上。您选择的变换长度必须确保在此支撑集上进行正确的线性卷积。\n- 根据概率论，一致地处理 $n = 0$ 的边界条件，即零个独立变量的和应几乎必然为零（在 $0$ 处的单位点质量）。\n- 提取指定 $s$ 的点概率 $\\mathbb{P}[S_n = s]$，以及指定整数 $a$ 和 $b$（其中 $a \\le b$）的区间概率 $\\mathbb{P}[a \\le S_n \\le b]$，其中 $S_n$ 是 $n$ 个独立基础骰子副本的和。\n- 通过丢弃可忽略的虚部、将由数值舍入误差引起的微小负值裁剪为零，并重新归一化使其总和为 $1$，来对逆 FFT 结果进行数值稳定化处理。\n\n在程序中实现的测试套件（无用户输入；对这些案例进行硬编码）：\n- 案例 A (正常路径): 基础骰子是公平的，$m = 6$ 且对于 $k \\in \\{1,\\dots,6\\}$ 有 $p_k = 1/6$，$n = 10$。计算点概率 $\\mathbb{P}[S_{10} = 35]$。\n- 案例 B (边界: 最小和): 同样的公平骰子，$n = 10$。计算 $\\mathbb{P}[S_{10} = 10]$。\n- 案例 C (边界: 最大和): 同样的公平骰子，$n = 10$。计算 $\\mathbb{P}[S_{10} = 60]$。\n- 案例 D (边缘情况: 零个骰子): 同样的公平骰子，$n = 0$。计算 $\\mathbb{P}[S_{0} = 0]$。\n- 案例 E (有偏骰子): 基础骰子是有偏的，$m = 6$ 且 $p = [0.05, 0.15, 0.20, 0.20, 0.20, 0.20]$ 分别对应于面 $\\{1,2,3,4,5,6\\}$，$n = 3$。计算 $\\mathbb{P}[S_{3} = 10]$。\n- 案例 F (不同大小的骰子): 基础骰子是公平的，$m = 4$ 且对于 $k \\in \\{1,2,3,4\\}$ 有 $p_k = 1/4$，$n = 5$。计算 $\\mathbb{P}[S_{5} = 10]$。\n- 案例 G (区间概率): 同样的公平 6 面骰子，$n = 20$。计算区间概率 $\\mathbb{P}[60 \\le S_{20} \\le 70]$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含案例 A 到 G 的结果，按顺序排列，形式为用方括号括起来的、以逗号分隔的浮点数列表。\n- 将每个概率表示为小数点后精确到 $12$ 位的小数。\n- 输出必须严格遵循 $[r_A,r_B,r_C,r_D,r_E,r_F,r_G]$ 的格式，不含空格，其中每个 $r_\\cdot$ 是一个小数点后格式化为恰好 $12$ 位的浮点数。\n\n本问题不涉及物理单位或角度单位。所有答案都是 $\\mathbb{R}$ 中的纯概率值。\n\n约束和附加要求：\n- 您必须使用卷积定理和快速傅里叶变换 (FFT) 来获得 $n$ 重卷积；不允许直接进行重复的时域卷积或枚举。\n- 确保您选择的变换长度是能够避免 $n$ 重线性卷积产生循环混叠的最小值，并在您的解题思路中论证这一选择。\n- 代码必须是自包含的，仅使用标准库和允许的库，并生成上述描述的精确输出格式。", "solution": "该问题是有效的，因为它在科学上基于概率论和数值方法，问题定义明确，并提供了一套完整且一致的要求和数据。\n\n问题的核心是计算 $n$ 个独立同分布 (i.i.d.) 离散随机变量之和 $S_n = \\sum_{i=1}^{n} X_i$ 的概率质量函数 (PMF)。每个随机变量 $X_i$ 代表单次掷一个有 $m$ 个面、取值为集合 $\\{1, 2, \\dots, m\\}$ 中整数的骰子的结果。$X_i$ 的 PMF 是一个给定的序列 $p_X(k) = \\mathbb{P}[X_i = k]$。\n\n根据概率论，两个独立随机变量之和的 PMF 是它们各自 PMF 的卷积。依此类推，$S_n$ 的 PMF（表示为 $p_{S_n}$）是基础 PMF $p_X$ 与自身的 $n$ 重卷积：\n$$\np_{S_n} = \\underbrace{p_X * p_X * \\dots * p_X}_{n \\text{ times}} \\equiv p_X^{*n}\n$$\n其中离散卷积 $(f * g)(k)$ 定义为 $(f * g)(k) = \\sum_{j} f(j) g(k-j)$。直接计算这个 $n$ 重卷积的计算成本很高，其复杂度随 $n$ 迅速增长。\n\n卷积定理提供了一种使用离散傅里叶变换 (DFT) 的更高效方法。该定理指出，两个序列卷积的 DFT 是它们各自 DFT 的逐元素乘积。设 $\\mathcal{F}$ 表示 DFT 算子。那么，\n$$\n\\mathcal{F}\\{f * g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}\n$$\n将此定理递归地应用于 $n$ 重卷积，得到：\n$$\n\\mathcal{F}\\{p_{S_n}\\} = \\mathcal{F}\\{p_X^{*n}\\} = (\\mathcal{F}\\{p_X\\})^n\n$$\n因此，可以通过计算基础 PMF 的 DFT 的 $n$ 次幂的逆 DFT (IDFT)（表示为 $\\mathcal{F}^{-1}$）来获得所需的 PMF $p_{S_n}$：\n$$\np_{S_n} = \\mathcal{F}^{-1}\\left\\{ (\\mathcal{F}\\{p_X\\})^n \\right\\}\n$$\n快速傅里叶变换 (FFT) 是计算 DFT 及其逆变换的高效算法，我们将采用该算法。\n\n使用 DFT 进行卷积的一个关键方面是线性和循环卷积之间的区别。DFT 本质上计算的是循环卷积。为了获得正确的线性卷积结果，输入序列在变换前必须进行零填充至足够长度。设基础 PMF $p_X$ 对于 $m$ 个结果是非零的。我们可以将其表示为一个长度为 $m$ 的序列。两个长度分别为 $L_1$ 和 $L_2$ 的序列的线性卷积结果是一个长度为 $L_1 + L_2 - 1$ 的序列。对于一个长度为 $m$ 的序列的 $n$ 重卷积，结果序列的长度为 $L_n = n(m-1) + 1$。为了防止循环混叠（回绕误差），DFT 的变换长度 $N$ 必须至少这么长：$N \\ge n(m-1) + 1$。问题要求使用最小的有效填充长度，因此我们将选择变换长度 $N$ 恰好为 $N = n(m-1) + 1$。\n\n算法流程如下：\n1. **表示基础 PMF**：对于结果为 $\\{1, \\dots, m\\}$ 的单个骰子，其 PMF 表示为一个长度为 $m$ 的序列 $p$，其中 $p[k-1] = \\mathbb{P}[X=k]$。\n2. **处理边缘情况**：\n   - 如果 $n=1$，PMF 就是基础 PMF $p_X$。\n   - 如果 $n=0$，“零个变量的和”按惯例是一个在 $0$ 处的点质量随机变量。所以，$\\mathbb{P}[S_0=0] = 1$。算法将此作为特殊情况处理。\n3. **确定变换长度**：对于 $n>1$，计算所得 PMF 的所需长度，这也是最小变换长度：$N = n(m-1) + 1$。\n4. **正向 FFT**：将基础 PMF 序列 $p$ 零填充至长度 $N$，并使用 FFT 算法计算其 DFT：$\\hat{p} = \\text{FFT}(p_{\\text{padded}}, N)$。\n5. **频域求幂**：将所得频域谱的每个元素提升到 $n$ 次幂：$\\hat{p}_{S_n} = (\\hat{p})^n$。\n6. **逆向 FFT**：计算 $\\hat{p}_{S_n}$ 的逆 DFT，以获得时域中的最终 PMF：$p_{S_n, \\text{raw}} = \\text{IFFT}(\\hat{p}_{S_n})$。\n7. **数值稳定化**：IFFT 的结果可能由于浮点精度误差而包含微小的非零虚部和负实值。\n   - 丢弃虚部：$p_{S_n} = \\text{Re}(p_{S_n, \\text{raw}})$。\n   - 将任何微小的负值裁剪为零：$p_{S_n}[p_{S_n} < 0] = 0$。\n   - 重新归一化 PMF 以确保其元素总和恰好为 $1$：$p_{S_n} = p_{S_n} / \\sum p_{S_n}$。\n8. **解释结果**：所得数组 $p_{S_n}$ 是和 $S_n$ 的 PMF。和 $S_n$ 的取值范围从 $s_{\\min} = n \\times 1 = n$ 到 $s_{\\max} = n \\times m$。计算出的 PMF 数组 $p_{S_n}$ 长度为 $N=n(m-1)+1$。元素 $p_{S_n}[k]$ 对应于概率 $\\mathbb{P}[S_n = s]$，其中和 $s$ 通过 $s = k + n$ 与索引 $k$ 相关。反之，要查找和为 $s$ 的概率，我们访问索引为 $k=s-n$ 的元素。\n   - 点概率 $\\mathbb{P}[S_n=s]$ 可通过访问 $p_{S_n}[s-n]$ 找到，前提是 $n \\le s \\le nm$。\n   - 区间概率 $\\mathbb{P}[a \\le S_n \\le b]$ 可通过对索引从 $a-n$ 到 $b-n$ 的元素求和找到：$\\sum_{s=a}^{b} p_{S_n}[s-n]$。\n此流程为解决所有指定的测试案例提供了一种计算高效且稳健的方法。", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef compute_dice_sum_pmf(pmf_base, n):\n    \"\"\"\n    Computes the PMF of the sum of n i.i.d. dice rolls using FFT-based convolution.\n\n    Args:\n        pmf_base (list or np.ndarray): The PMF of a single die roll for outcomes 1, 2, ..., m.\n        n (int): The number of dice to sum.\n\n    Returns:\n        tuple: A tuple containing:\n            - pmf_sum (np.ndarray): The resulting PMF of the sum.\n            - min_sum (int): The minimum possible sum.\n    \"\"\"\n    m = len(pmf_base)\n    \n    # Handle the edge case of n=0 dice. The sum is deterministically 0.\n    if n == 0:\n        return np.array([1.0]), 0\n\n    # The minimum possible sum is n*1 = n.\n    min_sum = n\n    \n    # For n=1, the PMF is just the base PMF.\n    if n == 1:\n        return np.array(pmf_base), min_sum\n\n    # Calculate the minimal transform length to avoid circular convolution.\n    # The length of the n-fold linear convolution of a sequence of length m is n*(m-1) + 1.\n    transform_length = n * (m - 1) + 1\n\n    # Perform FFT on the zero-padded base PMF.\n    # The 'n' argument in scipy.fft.fft handles the zero-padding.\n    fft_base = fft.fft(pmf_base, n=transform_length)\n\n    # Apply the convolution theorem: DFT of convolution is product of DFTs.\n    # For n-fold self-convolution, this becomes the n-th power of the DFT.\n    fft_sum = fft_base ** n\n\n    # Perform inverse FFT to get the convolved PMF back in the time domain.\n    pmf_sum_raw = fft.ifft(fft_sum)\n\n    # --- Numerical Stabilization ---\n    # 1. The result should be real; discard negligible imaginary parts.\n    pmf_sum = pmf_sum_raw.real\n\n    # 2. Clip tiny negative values resulting from floating-point errors.\n    pmf_sum = np.clip(pmf_sum, 0, None)\n\n    # 3. Renormalize to ensure the PMF sums to 1.\n    total_prob = np.sum(pmf_sum)\n    if total_prob > 0:\n        pmf_sum /= total_prob\n    \n    return pmf_sum, min_sum\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define base PMFs for the dice used in test cases.\n    fair_6_sided_pmf = np.full(6, 1/6)\n    biased_6_sided_pmf = np.array([0.05, 0.15, 0.20, 0.20, 0.20, 0.20])\n    fair_4_sided_pmf = np.full(4, 1/4)\n\n    # Test suite definition: (pmf_base, n, query_type, query_value)\n    # query_type can be 'point' or 'interval'.\n    # query_value is an integer for 'point' or a tuple (a, b) for 'interval'.\n    test_cases = [\n        # Case A: Fair 6-sided, n=10, P(S_10 = 35)\n        (fair_6_sided_pmf, 10, 'point', 35),\n        # Case B: Fair 6-sided, n=10, P(S_10 = 10)\n        (fair_6_sided_pmf, 10, 'point', 10),\n        # Case C: Fair 6-sided, n=10, P(S_10 = 60)\n        (fair_6_sided_pmf, 10, 'point', 60),\n        # Case D: Fair 6-sided, n=0, P(S_0 = 0)\n        (fair_6_sided_pmf, 0, 'point', 0),\n        # Case E: Biased 6-sided, n=3, P(S_3 = 10)\n        (biased_6_sided_pmf, 3, 'point', 10),\n        # Case F: Fair 4-sided, n=5, P(S_5 = 10)\n        (fair_4_sided_pmf, 5, 'point', 10),\n        # Case G: Fair 6-sided, n=20, P(60 <= S_20 <= 70)\n        (fair_6_sided_pmf, 20, 'interval', (60, 70)),\n    ]\n\n    results = []\n    for pmf_base, n, query_type, query_value in test_cases:\n        pmf_sum, min_sum = compute_dice_sum_pmf(pmf_base, n)\n        \n        m = len(pmf_base)\n        max_sum = n * m\n        \n        result = 0.0\n        if query_type == 'point':\n            s = query_value\n            # Check if sum s is within the possible range [min_sum, max_sum].\n            if min_sum <= s <= max_sum:\n                # The index corresponding to sum s is s - min_sum.\n                index = s - min_sum\n                result = pmf_sum[index]\n        elif query_type == 'interval':\n            a, b = query_value\n            # Clamp the interval to the valid range of sums.\n            start_s = max(a, min_sum)\n            end_s = min(b, max_sum)\n\n            if start_s <= end_s:\n                start_index = start_s - min_sum\n                end_index = end_s - min_sum\n                # Sum the probabilities in the specified range (inclusive).\n                result = np.sum(pmf_sum[start_index : end_index + 1])\n        \n        results.append(result)\n\n    # Format the final output as specified.\n    output_str = \",\".join(f\"{r:.12f}\" for r in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2383106"}, {"introduction": "卷积定理的应用远不止信号处理和概率论，它在数据分析中也是一个用于模式识别的强大工具。本练习将向你展示如何利用该定理，通过一次计算就高效地找到一个模板信号在数据中的最佳匹配位置，这在天体物理学等领域被称为匹配滤波。你将学习如何将一个计算量巨大的暴力搜索问题，转化为一个关于卡方 $\\chi^2$ 拟合优度的快速计算，从而深刻理解卷积定理在现代数据科学中的核心作用。[@problem_id:2383038]", "problem": "给定两个长度均为 $N$ 的实值、有限、离散时间序列，一个数据序列 $d = \\{d_n\\}_{n=0}^{N-1}$ 和一个模板序列 $h = \\{h_n\\}_{n=0}^{N-1}$。考虑循环移位模型 $m_n(\\tau, A) = A \\, h_{(n-\\tau) \\bmod N}$，其中移位 $\\tau \\in \\{0,1,\\dots,N-1\\}$，振幅 $A \\in \\mathbb{R}$ 为实数。对于每个移位 $\\tau$，定义卡方 $\\chi^2(\\tau)$\n$$\n\\chi^2(\\tau) = \\sum_{n=0}^{N-1} \\frac{\\left(d_n - A_{\\star}(\\tau) \\, h_{(n-\\tau) \\bmod N}\\right)^2}{\\sigma^2},\n$$\n其中 $\\sigma^2$ 是已知的均匀方差，$A_{\\star}(\\tau)$ 是在固定 $\\tau$ 下使 $\\chi^2(\\tau)$ 最小的振幅。如果 $\\sum_{n=0}^{N-1} h_n^2 = 0$，则对于所有 $\\tau$，将 $A_{\\star}(\\tau)$ 视为 $0$，且 $\\chi^2(\\tau) = \\sum_{n=0}^{N-1} d_n^2 / \\sigma^2$。如果多个移位 $\\tau$ 达到相同的 $\\chi^2(\\tau)$ 最小值，则选择其中最小的 $\\tau$。\n\n您的任务是，对以下每个测试用例，计算使 $\\chi^2(\\tau)$ 最小的移位 $\\tau_{\\min}$、对应的最小值 $\\chi^2_{\\min}$ 以及对应的最佳拟合振幅 $A_{\\star}(\\tau_{\\min})$。所有用例均使用 $N=8$ 和 $\\sigma^2 = 1$。所有序列都应按模 $N$ 的循环索引方式进行解释。\n\n测试套件：\n1) 正常路径（非平凡模板和移位）：\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [0,1,2,3,2,1,0,0], \\quad d = [2,0,0,0,2,4,6,4].\n$$\n\n2) 边界情况（交替序列，精确负匹配）：\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [1,-1,1,-1,1,-1,1,-1], \\quad d = [-1,1,-1,1,-1,1,-1,1].\n$$\n\n3) 边缘情况（零模板）：\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [0,0,0,0,0,0,0,0], \\quad d = [3,-1,4,1,5,-9,2,6].\n$$\n\n4) 一般情况（周期性模板，分数振幅）：\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [0,1,0,-1,0,1,0,-1], \\quad d = [0,-0.5,0,0.5,0,-0.5,0,0.5].\n$$\n\n对于每个测试用例，您的程序必须输出一个包含三个值的列表 $[\\tau_{\\min}, \\chi^2_{\\min}, A_{\\star}(\\tau_{\\min})]$，其中 $\\tau_{\\min}$ 是一个整数，两个浮点数值需四舍五入到六位小数。您的程序应生成单行输出，其中包含所有四个测试用例的结果，格式为一个由各用例列表组成的、以逗号分隔的列表，并用方括号括起来，不含空格。例如，包含两个假设用例的输出应如下所示\n$$\n[[\\tau_1,\\chi^2_1,A_1],[\\tau_2,\\chi^2_2,A_2]].\n$$", "solution": "我们从最小二乘的定义开始。对于一个固定的移位 $\\tau$，定义\n$$\n\\chi^2(\\tau;A) = \\sum_{n=0}^{N-1} \\frac{\\left(d_n - A \\, h_{(n-\\tau) \\bmod N}\\right)^2}{\\sigma^2}.\n$$\n在均匀方差 $\\sigma^2 = 1$ 的情况下，通过将关于 $A$ 的导数设为零，可以得到最小化振幅 $A_{\\star}(\\tau)$：\n$$\n\\frac{\\partial}{\\partial A} \\chi^2(\\tau;A) = -2 \\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N} + 2 A \\sum_{n=0}^{N-1} h_{(n-\\tau) \\bmod N}^2 = 0.\n$$\n由于循环移位保持平方范数不变，$\\sum_{n=0}^{N-1} h_{(n-\\tau) \\bmod N}^2 = \\sum_{n=0}^{N-1} h_n^2 \\equiv \\|h\\|^2$。因此，如果 $\\|h\\|^2 > 0$，则\n$$\nA_{\\star}(\\tau) = \\frac{\\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}}{\\|h\\|^2}.\n$$\n将 $A_{\\star}(\\tau)$ 代回到 $\\chi^2$ 中并展开可得\n$$\n\\chi^2(\\tau) = \\sum_{n=0}^{N-1} d_n^2 - \\frac{\\left(\\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}\\right)^2}{\\|h\\|^2}.\n$$\n如果 $\\|h\\|^2 = 0$，我们遵循既定约定，对所有 $\\tau$ 取 $A_{\\star}(\\tau)=0$，且 $\\chi^2(\\tau)=\\sum_{n=0}^{N-1} d_n^2$。\n\n量 $\\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}$ 是 $d$ 与 $h$ 在延迟 $\\tau$ 处的循环互相关。记为\n$$\nc(\\tau) \\equiv \\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}.\n$$\n根据卷积定理，$c(\\tau)$ 可以通过快速傅里叶变换（FFT）有效利用离散傅里叶变换（DFT）对所有 $\\tau$ 进行计算。根据DFT的约定\n$$\nD_k = \\sum_{n=0}^{N-1} d_n \\, e^{-2\\pi i k n / N}, \\quad H_k = \\sum_{n=0}^{N-1} h_n \\, e^{-2\\pi i k n / N},\n$$\n逆DFT给出\n$$\nc(\\tau) = \\operatorname{IDFT}\\left(D_k \\, \\overline{H_k}\\right)_\\tau = \\frac{1}{N} \\sum_{k=0}^{N-1} D_k \\, \\overline{H_k} \\, e^{2\\pi i k \\tau / N}.\n$$\n直接推导表明\n$$\n\\operatorname{IDFT}\\left(D_k \\, \\overline{H_k}\\right)_\\tau = \\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N},\n$$\n这正是所求的循环互相关。因此，我们可以通过对 $d$ 进行一次正向FFT，对 $h$ 进行一次正向FFT，与复共轭进行逐点相乘，再进行一次逆FFT，在 $\\mathcal{O}(N \\log N)$ 时间内计算出整个相关序列 $c(\\tau)$。\n\n算法步骤：\n1) 计算 $\\|h\\|^2 = \\sum_{n=0}^{N-1} h_n^2$ 和 $\\|d\\|^2 = \\sum_{n=0}^{N-1} d_n^2$。\n2) 如果 $\\|h\\|^2 = 0$，则对所有 $\\tau$ 设 $A_{\\star}(\\tau)=0$ 和 $\\chi^2(\\tau)=\\|d\\|^2$。\n3) 否则，通过使用FFT的卷积定理计算 $c(\\tau)$。然后对于每个 $\\tau$，\n$$\nA_{\\star}(\\tau) = \\frac{c(\\tau)}{\\|h\\|^2}, \\quad \\chi^2(\\tau) = \\|d\\|^2 - \\frac{c(\\tau)^2}{\\|h\\|^2}.\n$$\n4) 找到使 $\\chi^2(\\tau)$ 最小的 $\\tau_{\\min}$；通过选择最小的 $\\tau$ 来解决平局问题。\n5) 报告 $[\\tau_{\\min}, \\chi^2_{\\min}, A_{\\star}(\\tau_{\\min})]$，其中浮点数条目四舍五入到六位小数。\n\n应用于所提供的测试套件：\n\n用例 1：$h = [0,1,2,3,2,1,0,0]$, $d = [2,0,0,0,2,4,6,4]$。\n我们有 $\\|h\\|^2 = 19$ 和 $\\|d\\|^2 = 76$。互相关在 $\\tau=3$ 处达到最大值，为 $c(3) = 38$，从而得到 $A_{\\star}(3) = 38/19 = 2$ 和 $\\chi^2_{\\min} = 76 - 38^2/19 = 0$。\n\n用例 2：$h = [1,-1,1,-1,1,-1,1,-1]$, $d = [-1,1,-1,1,-1,1,-1,1]$。\n此处 $\\|h\\|^2 = 8$，$\\|d\\|^2 = 8$。对于所有 $\\tau$，$c(\\tau) \\in \\{\\pm 8\\}$，因此对于每个 $\\tau$ 都有 $\\chi^2(\\tau) = 8 - 64/8 = 0$。我们选择最小的索引 $\\tau_{\\min} = 0$，此时 $A_{\\star}(0) = -1$。\n\n用例 3：$h = [0,0,0,0,0,0,0,0]$, $d = [3,-1,4,1,5,-9,2,6]$。\n此时 $\\|h\\|^2 = 0$，因此根据约定，对所有 $\\tau$ 都有 $A_{\\star}(\\tau) = 0$ 和 $\\chi^2(\\tau) = \\|d\\|^2 = 173$。我们选择 $\\tau_{\\min} = 0$ 且 $A_{\\star}(0) = 0$。\n\n用例 4：$h = [0,1,0,-1,0,1,0,-1]$, $d = [0,-0.5,0,0.5,0,-0.5,0,0.5]$。\n我们有 $\\|h\\|^2 = 4$，$\\|d\\|^2 = 1$。互相关在 $\\tau=2$ 处达到峰值，为 $c(2)=2$，得到 $A_{\\star}(2) = 2/4 = 0.5$ 和 $\\chi^2_{\\min} = 1 - 4/4 = 0$。\n\n四舍五入到六位小数后，每个用例的预期输出为\n$$\n[3, 0.000000, 2.000000], \\quad [0, 0.000000, -1.000000], \\quad [0, 173.000000, 0.000000], \\quad [2, 0.000000, 0.500000].\n$$\n按要求汇集成单行：\n$$\n[[3,0.000000,2.000000],[0,0.000000,-1.000000],[0,173.000000,0.000000],[2,0.000000,0.500000]].\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_min_chi2_shift(d, h):\n    \"\"\"\n    Given data d and template h (both length N), compute for circular shifts tau:\n    - A_hat(tau) = argmin_A sum (d_n - A h_{n - tau})^2\n    - chi2(tau) = min value at A_hat(tau) with sigma^2 = 1\n    Return (tau_min, chi2_min, A_hat_at_tau_min), breaking ties by smallest tau.\n    \"\"\"\n    d = np.asarray(d, dtype=np.float64)\n    h = np.asarray(h, dtype=np.float64)\n    N = d.size\n    assert h.size == N, \"d and h must have the same length\"\n\n    norm_h2 = float(np.dot(h, h))\n    norm_d2 = float(np.dot(d, d))\n\n    if norm_h2 == 0.0:\n        # Degenerate case: A_hat(tau)=0 and chi2(tau)=norm_d2 for all tau\n        tau_min = 0\n        chi2_min = norm_d2\n        A_hat_min = 0.0\n        return tau_min, chi2_min, A_hat_min\n\n    # Compute circular cross-correlation c[tau] = sum_n d_n h_{n - tau}\n    D = np.fft.fft(d)\n    H = np.fft.fft(h)\n    c = np.fft.ifft(D * np.conj(H))\n    # Numerical errors may leave tiny imaginary parts\n    c = np.real(c)\n\n    # Compute chi2(tau) = ||d||^2 - c[tau]^2 / ||h||^2\n    chi2 = norm_d2 - (c * c) / norm_h2\n    # Guard against tiny negative due to numerical precision\n    chi2 = np.maximum(chi2, 0.0)\n\n    tau_min = int(np.argmin(chi2))\n    chi2_min = float(chi2[tau_min])\n    A_hat_min = float(c[tau_min] / norm_h2)\n\n    return tau_min, chi2_min, A_hat_min\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            [2, 0, 0, 0, 2, 4, 6, 4],\n            [0, 1, 2, 3, 2, 1, 0, 0]\n        ),\n        # Case 2\n        (\n            [-1, 1, -1, 1, -1, 1, -1, 1],\n            [1, -1, 1, -1, 1, -1, 1, -1]\n        ),\n        # Case 3\n        (\n            [3, -1, 4, 1, 5, -9, 2, 6],\n            [0, 0, 0, 0, 0, 0, 0, 0]\n        ),\n        # Case 4\n        (\n            [0.0, -0.5, 0.0, 0.5, 0.0, -0.5, 0.0, 0.5],\n            [0, 1, 0, -1, 0, 1, 0, -1]\n        ),\n    ]\n\n    results = []\n    for d, h in test_cases:\n        tau_min, chi2_min, A_hat_min = compute_min_chi2_shift(d, h)\n        # Format with required rounding for floats\n        results.append([tau_min, f\"{chi2_min:.6f}\", f\"{A_hat_min:.6f}\"])\n\n    # Build the exact required single-line output without spaces\n    inner = \",\".join(\"[\" + \",\".join([str(r[0]), r[1], r[2]]) + \"]\" for r in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2383038"}]}