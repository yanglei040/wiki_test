{"hands_on_practices": [{"introduction": "在将连续的模拟信号转换为数字信号时，我们必须用有限的离散数值来近似表示无限的可能值，这个过程称为量化。这种近似不可避免地会引入一种误差，即量化噪声（Quantization Noise），它直接影响我们测量的精度。本练习将通过一个思想实验，让您亲手模拟一个正弦波的数字化过程，并计算不同位深度下的信噪比，从而直观地理解数字仪器精度的核心限制。[@problem_id:2438146]", "problem": "一个表示单音测试输入的连续时间正弦信号由函数 $x(t) = A \\sin(2 \\pi f_{0} t + \\varphi)$ 定义，其振幅为 $A$，频率为 $f_{0}$，相位 $\\varphi = 0$ 弧度。该信号以采样频率 $f_{s}$ 进行均匀时间采样，持续时间为 $T$，在时间点 $t_{n} = n / f_{s}$（对于 $n = 0, 1, \\ldots, N-1$）处产生 $N = \\lfloor f_{s} T \\rfloor$ 个离散时间样本 $x[n] = x(t_{n})$。然后，这些样本由一个具有 $B$ 位和满量程峰值振幅 $L$（单位为伏特）的理想、均匀、中置步长量化器进行数字化，过程如下。定义 $K = 2^{B-1} - 1$ 和步长 $\\Delta = L / K$。重建电平为 $k \\Delta$，其中整数 $k$ 满足 $-K \\leq k \\leq K$。量化样本 $y_{q}[n]$ 的获得方式是：首先通过四舍五入将 $x[n]$ 映射到最近的电平 $k \\Delta$，然后在必要时饱和到极限电平：\n$$\nk[n] = \\mathrm{clip}\\left(\\mathrm{round}\\left(\\frac{x[n]}{\\Delta}\\right), -K, K\\right), \\quad y_{q}[n] = k[n] \\Delta,\n$$\n其中 $\\mathrm{round}(\\cdot)$ 表示四舍五入到最近的整数，$\\mathrm{clip}(u, a, b)$ 将 $u$ 限制在区间 $[a, b]$ 内。量化误差为 $e[n] = y_{q}[n] - x[n]$。使用采样数据，定义平均信号功率和平均误差功率如下：\n$$\nP_{s} = \\frac{1}{N} \\sum_{n=0}^{N-1} x[n]^{2}, \\quad P_{e} = \\frac{1}{N} \\sum_{n=0}^{N-1} e[n]^{2},\n$$\n以及以分贝为单位的信噪比（SQNR）如下：\n$$\n\\mathrm{SQNR} = 10 \\log_{10}\\left(\\frac{P_{s}}{P_{e}}\\right).\n$$\n所有角度必须以弧度为单位。所有电压必须以伏特为单位。\n\n您的任务是为下面测试套件中的每一组参数计算 $\\mathrm{SQNR}$。对于每个测试用例，振幅是相对于满量程峰值振幅指定的，为 $L$ 的一个倍数；也就是说，使用等于指定倍数乘以 $L$ 的绝对振幅 $A$。将最终的 $\\mathrm{SQNR}$ 值以分贝表示，并作为浮点数四舍五入到小数点后六位。\n\n测试套件（每个用例是一个元组 $(B, f_{0}, f_{s}, T, L, \\text{振幅倍数})$）：\n- 用例 1：$(16, 1234, 48000, 1.0, 1.0, 0.9)$\n- 用例 2：$(12, 1000, 44100, 0.5, 2.0, 0.8)$\n- 用例 3：$(8, 5000, 96000, 0.25, 1.0, 0.5)$\n- 用例 4：$(3, 200, 8000, 1.0, 1.0, 0.95)$\n- 用例 5：$(16, 3000, 48000, 0.75, 1.0, 0.01)$\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，列表内无空格，顺序与测试套件相同（例如，“[r1,r2,r3,r4,r5]”），其中每个 $r_i$ 是用例 $i$ 的 $\\mathrm{SQNR}$，四舍五入到小数点后六位。", "solution": "问题陈述已经过验证，并被认定为有效。这是一个数字信号处理领域中定义良好的问题，提供了清晰而完整的定义、参数和约束集。所有参数在物理上和计算上都是合理的，其基本原理在科学上是正确的。任务是为一组给定场景计算信噪比（SQNR）。我们开始进行求解。\n\n问题的核心是模拟一个信号采集链，该链包括采样和量化。通过对每个测试用例算法化地执行问题中定义的步骤来获得解决方案。\n\n1.  **信号生成**：\n    连续时间信号是一个纯正弦波，定义为 $x(t) = A \\sin(2 \\pi f_{0} t)$，因为相位 $\\varphi$ 给定为 $0$。振幅 $A$ 由量化器的满量程峰值振幅 $L$ 和指定的振幅倍数确定，即 $A = (\\text{振幅倍数}) \\times L$。\n    该信号以频率 $f_{s}$ 进行均匀采样，持续时间为 $T$。离散样本的总数为 $N = \\lfloor f_{s} T \\rfloor$。样本在时间点 $t_{n} = n/f_{s}$（对于 $n = 0, 1, \\ldots, N-1$）被采集。得到的离散时间信号是：\n    $$x[n] = x(t_{n}) = A \\sin\\left(2 \\pi f_{0} \\frac{n}{f_{s}}\\right)$$\n\n2.  **量化器定义**：\n    系统使用一个具有 $B$ 位分辨率和满量程峰值振幅 $L$ 伏特的均匀中置步长量化器。正（和负）量化电平的数量由 $K = 2^{B-1} - 1$ 确定。重建电平的总数为 $2K+1$。量化步长 $\\Delta$ 是相邻重建电平之间的电压差，由以下公式给出：\n    $$\\Delta = \\frac{L}{K}$$\n    重建电平则为 $\\{k\\Delta \\mid k \\in \\{-K, -K+1, \\ldots, K-1, K\\}\\}$。\n\n3.  **量化过程与误差计算**：\n    每个样本 $x[n]$ 被映射到最近的重建电平。这是一个两步过程。首先，将样本的电压通过步长 $\\Delta$ 进行归一化，并将结果四舍五入到最近的整数。然后，将该整数进行限幅，以确保其保持在有效电平索引范围 $[-K, K]$ 内。得到的索引为 $k[n]$：\n    $$k[n] = \\mathrm{clip}\\left(\\mathrm{round}\\left(\\frac{x[n]}{\\Delta}\\right), -K, K\\right)$$\n    然后通过将该索引乘以步长来重构量化后的样本 $y_{q}[n]$：\n    $$y_{q}[n] = k[n] \\Delta$$\n    每个样本的量化误差是量化值与原始样本值之差：\n    $$e[n] = y_{q}[n] - x[n]$$\n\n4.  **功率与 SQNR 计算**：\n    原始离散时间信号的平均功率 $P_{s}$ 和量化误差信号的平均功率 $P_{e}$，是通过对各自样本值的平方在所有 $N$ 个样本上求平均来计算的：\n    $$P_{s} = \\frac{1}{N} \\sum_{n=0}^{N-1} x[n]^{2}$$\n    $$P_{e} = \\frac{1}{N} \\sum_{n=0}^{N-1} e[n]^{2}$$\n    最后，信噪比（SQNR）以分贝（dB）为单位，使用以下公式计算：\n    $$\\mathrm{SQNR} = 10 \\log_{10}\\left(\\frac{P_{s}}{P_{e}}\\right)$$\n    对于测试套件中提供的每一组参数，都通过计算方式实现这整个过程。数值结果按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Signal-to-Quantization-Noise Ratio (SQNR) for a series\n    of test cases involving a sampled and quantized sinusoidal signal.\n    \"\"\"\n    # Test suite: each case is a tuple (B, f0, fs, T, L, amplitude_multiple)\n    test_cases = [\n        (16, 1234, 48000, 1.0, 1.0, 0.9),\n        (12, 1000, 44100, 0.5, 2.0, 0.8),\n        (8, 5000, 96000, 0.25, 1.0, 0.5),\n        (3, 200, 8000, 1.0, 1.0, 0.95),\n        (16, 3000, 48000, 0.75, 1.0, 0.01)\n    ]\n\n    results = []\n\n    for case in test_cases:\n        B, f0, fs, T, L, amp_multiple = case\n\n        # Step 1: Signal Generation\n        # Amplitude of the sinusoidal signal\n        A = amp_multiple * L\n        # Number of samples, N = floor(fs * T)\n        N = int(fs * T)\n        # Time vector\n        t = np.arange(N) / fs\n        # Discrete-time signal x[n]\n        x_n = A * np.sin(2 * np.pi * f0 * t)\n\n        # Step 2: Quantizer Definition\n        # K determines the number of quantization levels on one side of zero\n        K = (2**(B - 1)) - 1\n        # Quantization step size\n        delta = L / K\n\n        # Step 3: Quantization Process\n        # Normalize signal and round to nearest integer to get level index\n        # np.round() implements rounding to the nearest integer, with .5 cases\n        # rounded to the nearest even integer.\n        k_n_unclipped = np.round(x_n / delta)\n        # Clip the indices to the valid range [-K, K]\n        k_n = np.clip(k_n_unclipped, -K, K)\n        # Reconstruct the quantized signal\n        y_q_n = k_n * delta\n\n        # Calculate the quantization error signal\n        e_n = y_q_n - x_n\n\n        # Step 4: Power and SQNR Calculation\n        # Average signal power\n        Ps = np.mean(x_n**2)\n        # Average error (noise) power\n        Pe = np.mean(e_n**2)\n        \n        # The problem setup ensures Pe > 0 for the given test cases.\n        # Otherwise, an if Pe == 0 check would be needed.\n        sqnr = 10 * np.log10(Ps / Pe)\n\n        results.append(sqnr)\n\n    # Format the final results as a comma-separated list of strings,\n    # with each number rounded to exactly six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2438146"}, {"introduction": "从连续信号中采样数据时，采样率的选择至关重要。如果采样率不足，高频信号成分可能会“伪装”成低频信号，这种现象被称为混叠（Aliasing）。本练习通过一个假设场景，即仅保留信号的偶数索引样本，来模拟一种下采样过程，并引导您在频域中分析由此产生的混叠伪影，深刻理解采样如何从根本上塑造（或扭曲）我们对数据的认知。[@problem_id:2438167]", "problem": "一个有限长度的离散时间信号被定义为在离散傅里叶变换 (DFT) 频率仓上的一系列余弦分量之和。令 $N$ 为一个正偶数，且令 $n \\in \\{0,1,\\dots,N-1\\}$。该信号为\n$$\nx[n] = \\sum_{k=1}^{K} A_k \\cos\\!\\left(\\omega_k n + \\varphi_k\\right),\n$$\n其中，每个角频率的形式为 $\\omega_k = \\dfrac{2\\pi m_k}{N}$，其中 $m_k \\in \\{0,1,\\dots,N-1\\}$ 为整数，振幅 $A_k > 0$ 为实数，相位 $\\varphi_k$ 是以弧度为单位的实数。考虑仅从偶数索引采样点进行的重构，定义如下\n$$\ny[n] =\n\\begin{cases}\nx[n], & \\text{若 $n$ 为偶数},\\\\\n0, & \\text{若 $n$ 为奇数}。\n\\end{cases}\n$$\n将一个序列 $z[n]$ 的长度为 $N$ 的离散傅里叶变换 (DFT) 定义为\n$$\nZ[m] = \\sum_{n=0}^{N-1} z[n]\\, e^{-i\\,2\\pi\\, m n / N},\\quad m \\in \\{0,1,\\dots,N-1\\}。\n$$\n令 $X[m]$ 和 $Y[m]$ 分别表示 $x[n]$ 和 $y[n]$ 的 DFT。令原始频谱仓的集合为\n$$\n\\mathcal{S} = \\bigcup_{k=1}^{K} \\left\\{\\, m_k,\\; (-m_k)\\bmod N \\,\\right\\},\n$$\n去除重复项后。将信号仓功率定义为\n$$\nP_{\\text{信号}} = \\sum_{m \\in \\mathcal{S}} \\left| Y[m] \\right|^2,\n$$\n将总功率定义为\n$$\nP_{\\text{总}} = \\sum_{m=0}^{N-1} \\left| Y[m] \\right|^2,\n$$\n并将混叠伪影功率定义为\n$$\nP_{\\text{混叠}} = P_{\\text{总}} - P_{\\text{信号}}。\n$$\n所需的性能指标是混叠与信号功率比，\n$$\nR = \\frac{P_{\\text{混叠}}}{P_{\\text{信号}}},\n$$\n该比值为无量纲。所有角度都必须解释为弧度。\n\n您的任务是编写一个完整的程序，对下述每个测试用例，构建信号 $x[n]$，仅从偶数索引采样点形成 $y[n]$，计算 $Y[m]$，并以浮点数形式输出比率 $R$，四舍五入到小数点后六位。\n\n测试套件（每个用例是一个元组 $(N,\\; \\{m_k\\},\\; \\{A_k\\},\\; \\{\\varphi_k\\})$）：\n- 用例 1: $(1024,\\; \\{50\\},\\; \\{1.0\\},\\; \\{0.0\\})$。\n- 用例 2: $(1024,\\; \\{30,\\,100\\},\\; \\{1.0,\\,0.8\\},\\; \\{0.0,\\,0.3\\})$。\n- 用例 3: $(1024,\\; \\{256\\},\\; \\{1.0\\},\\; \\{0.7\\})$。\n- 用例 4: $(1024,\\; \\{0\\},\\; \\{1.2\\},\\; \\{0.0\\})$。\n- 用例 5: $(1024,\\; \\{60,\\,572\\},\\; \\{1.0,\\,0.5\\},\\; \\{0.0,\\,1.0\\})$。\n\n您的程序必须生成单行输出，其中按顺序包含五个比率，格式为逗号分隔的列表并用方括号括起，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_j$ 都四舍五入到小数点后六位。不涉及任何物理单位。所有角度均为弧度。最终输出必须严格匹配此单行格式。", "solution": "所提出的问题是离散信号处理中的一个明确定义的练习，涉及对经过特定形式下采样的信号进行频谱分析。该问题具有科学依据，逻辑上一致，并提供了所有必要的参数。因此，该问题是有效的，下面将给出一种解决方案。\n\n令长度为 $N$ 的离散时间信号表示为 $x[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。该信号是 $K$ 个余弦分量的叠加：\n$$\nx[n] = \\sum_{k=1}^{K} A_k \\cos(\\omega_k n + \\varphi_k)\n$$\n每个角频率都是基本 DFT 频率的倍数，$\\omega_k = \\frac{2\\pi m_k}{N}$，其中 $m_k$ 是一个整数频率仓索引。\n\n使用 Euler 恒等式 $e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)$，我们可以将余弦函数表示为：\n$$\n\\cos(\\theta) = \\frac{e^{i\\theta} + e^{-i\\theta}}{2}\n$$\n因此，信号 $x[n]$ 可以用复指数表示：\n$$\nx[n] = \\sum_{k=1}^{K} \\frac{A_k}{2} \\left( e^{i(\\frac{2\\pi m_k n}{N} + \\varphi_k)} + e^{-i(\\frac{2\\pi m_k n}{N} + \\varphi_k)} \\right) = \\sum_{k=1}^{K} \\left( \\frac{A_k e^{i\\varphi_k}}{2} e^{i\\frac{2\\pi m_k n}{N}} + \\frac{A_k e^{-i\\varphi_k}}{2} e^{-i\\frac{2\\pi m_k n}{N}} \\right)\n$$\n$x[n]$ 的长度为 $N$ 的离散傅里叶变换 (DFT) $X[m]$ 定义为：\n$$\nX[m] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i\\frac{2\\pi mn}{N}}\n$$\n给定复指数的 DFT，$\\sum_{n=0}^{N-1} e^{i\\frac{2\\pi k_0 n}{N}} e^{-i\\frac{2\\pi mn}{N}} = N \\delta[m - k_0]$，其中 $\\delta[\\cdot]$ 是离散冲激，则 $x[n]$ 的 DFT 是位于频率仓 $\\pm m_k$ (模 $N$) 的一系列冲激：\n$$\nX[m] = \\sum_{k=1}^{K} \\left( \\frac{N A_k e^{i\\varphi_k}}{2} \\delta[m - m_k] + \\frac{N A_k e^{-i\\varphi_k}}{2} \\delta[m - ((-m_k) \\pmod N)] \\right)\n$$\n频谱 $X[m]$ 仅在 $m$ 属于原始频谱仓集合 $\\mathcal{S} = \\bigcup_{k=1}^{K} \\{m_k, (-m_k) \\pmod N\\}$ 时非零。\n\n信号 $y[n]$ 是通过将 $x[n]$ 的奇数索引采样点置零而形成的：\n$$\ny[n] = x[n] \\cdot p[n], \\quad \\text{其中} \\quad p[n] = \\frac{1 + (-1)^n}{2} = \\frac{1 + e^{i\\pi n}}{2}\n$$\n序列 $p[n]$ 充当一个采样函数。两个序列乘积的 DFT 是它们各自 DFT 的循环卷积再除以 $N$。$p[n]$ 的 DFT 是 $P[m] = \\frac{N}{2} (\\delta[m] + \\delta[m - N/2])$，因为 $e^{i\\pi n} = e^{i\\frac{2\\pi(N/2)n}{N}}$ 且 $N$ 为偶数。\n于是，$y[n]$ 的 DFT，表示为 $Y[m]$，为：\n$$\nY[m] = \\frac{1}{N} (X * P)[m] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] P[(m-k) \\pmod N]\n$$\n代入 $P[m]$ 的表达式，可以得到此操作著名的混叠公式：\n$$\nY[m] = \\frac{1}{N} \\left( X[m] \\cdot \\frac{N}{2} + X[(m - N/2) \\pmod N] \\cdot \\frac{N}{2} \\right) = \\frac{1}{2} \\left( X[m] + X[(m - N/2) \\pmod N] \\right)\n$$\n这个基本关系表明，在给定频率仓 $m$ 处的频谱 $Y[m]$ 是原始频谱 $X[m]$ 在频率仓 $m$ 处的值与在频率仓 $(m - N/2) \\pmod N$ 处的值的平均值。这是混叠的一种表现。来自频率分量 $m'$ 的能量被折叠到 $m = (m' \\pm N/2) \\pmod N$。\n\n为解决该问题，我们将根据问题定义，对每个测试用例实施直接仿真：\n1.  对于一组给定的参数 $(N, \\{m_k\\}, \\{A_k\\}, \\{\\varphi_k\\})$，构建信号 $x[n]$，其中 $n=0, 1, \\dots, N-1$。\n2.  通过将偶数索引的 $n$ 设为 $y[n] = x[n]$，奇数索引的 $n$ 设为 $y[n]=0$，来构建信号 $y[n]$。\n3.  使用标准的快速傅里叶变换 (FFT) 算法计算 DFT $Y[m] = \\text{DFT}\\{y[n]\\}$。\n4.  根据给定的 $\\{m_k\\}$ 构建信号仓集合 $\\mathcal{S}$。\n5.  计算 $y[n]$ 频谱中的总功率为 $P_{\\text{总}} = \\sum_{m=0}^{N-1} |Y[m]|^2$。\n6.  计算集中在原始信号仓中的功率为 $P_{\\text{信号}} = \\sum_{m \\in \\mathcal{S}} |Y[m]|^2$。\n7.  混叠伪影功率是二者之差：$P_{\\text{混叠}} = P_{\\text{总}} - P_{\\text{信号}}$。\n8.  最终的指标是比率 $R = P_{\\text{混叠}} / P_{\\text{信号}}$。我们处理了潜在的除零情况，尽管在提供的测试用例中并未出现。\n9.  按要求，将每个用例计算出的 $R$ 值四舍五入到小数点后六位。\n\n此过程精确地模拟了所描述的物理和数学过程，并将产生正确的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... No scipy functions beyond fft which is in numpy are needed.\n\ndef solve():\n    \"\"\"\n    Solves the signal processing problem for a suite of test cases.\n    For each case, it computes the aliasing-to-signal power ratio R.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, {m_k}, {A_k}, {phi_k})\n    test_cases = [\n        (1024, [50], [1.0], [0.0]),\n        (1024, [30, 100], [1.0, 0.8], [0.0, 0.3]),\n        (1024, [256], [1.0], [0.7]),\n        (1024, [0], [1.2], [0.0]),\n        (1024, [60, 572], [1.0, 0.5], [0.0, 1.0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, m_k_list, A_k_list, phi_k_list = case\n        \n        # Step 1: Construct the signal x[n]\n        n_indices = np.arange(N)\n        x = np.zeros(N, dtype=float)\n        for m_k, A_k, phi_k in zip(m_k_list, A_k_list, phi_k_list):\n            omega_k = (2 * np.pi * m_k) / N\n            x += A_k * np.cos(omega_k * n_indices + phi_k)\n            \n        # Step 2: Construct the signal y[n] from even-indexed samples\n        y = np.zeros(N, dtype=float)\n        y[::2] = x[::2]\n        \n        # Step 3: Compute the DFT of y[n]\n        Y = np.fft.fft(y)\n        \n        # Step 4: Define the set of original spectral bins S\n        S = set()\n        for m_k in m_k_list:\n            S.add(m_k)\n            S.add((-m_k) % N)\n            \n        # Step 5: Calculate total power\n        P_total = np.sum(np.abs(Y)**2)\n        \n        # Step 6: Calculate signal-bin power\n        P_signal = 0.0\n        for m in S:\n            P_signal += np.abs(Y[m])**2\n            \n        # Step 7: Calculate aliasing-artifact power\n        P_alias = P_total - P_signal\n        \n        # Step 8: Calculate the ratio R\n        # Handle the case where P_signal might be zero to avoid division by zero.\n        if P_signal == 0:\n            # If there is no signal power but there is alias power, the ratio is infinite.\n            # If there is no alias power either, the ratio is undefined, which we can treat as 0.\n            R = np.inf if P_alias > 0 else 0.0\n        else:\n            R = P_alias / P_signal\n            \n        # Append the rounded result. Add a small epsilon for rounding stability,\n        # especially for values extremely close to x.5 * 10^-n.\n        results.append(round(R + 1e-9, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2438167"}, {"introduction": "从实验数据中提取动态信息，如速度或变化率，通常需要计算时间导数。然而，直接对含有噪声的信号进行数值微分会极大地放大噪声，导致结果不可靠。本练习将让您对比直接微分和“先平滑后微分”这两种方法的优劣，通过应用高斯滤波器来预处理一个带噪的合成信号，从而掌握在噪声背景下提取精确导数的关键技巧。[@problem_id:2438105]", "problem": "提供给您一个标量实验测量值的合成时间序列模型，该模型包含加性噪声，并按时间离散采样。设采样频率为 $f_s = 1000$ $\\text{s}^{-1}$，采样点数为 $N = 4096$，采样间隔为 $\\Delta t = 1/f_s$。定义连续时间下的底层信号 $x(t)$ 及其精确时间导数 $x'(t)$ 如下\n$$\nx(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\cos(2\\pi f_2 t) + A_3 t,\n$$\n其中 $A_1 = 1$，$f_1 = 5$ $\\text{s}^{-1}$，$A_2 = 0.3$，$f_2 = 40$ $\\text{s}^{-1}$，$A_3 = 0.2$ $\\text{s}^{-1}$。角度单位为弧度。其精确导数为\n$$\nx'(t) = 2\\pi f_1 A_1 \\cos(2\\pi f_1 t) - 2\\pi f_2 A_2 \\sin(2\\pi f_2 t) + A_3.\n$$\n设离散采样时间为 $t_n = n \\Delta t$，其中整数 $n \\in \\{0,1,\\dots,N-1\\}$。测得的离散时间信号 $y[n]$ 定义为\n$$\ny[n] = x(t_n) + \\eta[n],\n$$\n其中 $\\eta[n]$ 是独立同分布的零均值高斯随机变量，其标准差为 $\\sigma_{\\eta}$，单位与 $x(t)$ 相同。为保证所有测试用例中 $\\eta[n]$ 的可复现性，请使用固定的伪随机数生成器种子 $S = 1337$。\n\n您的任务是采用两种方法估计含噪测量值的时间导数，并将其精度与精确导数 $x'(t_n)$ 进行比较：\n1. 对含噪数据进行直接中心差分：\n$$\n\\widehat{d}_{\\text{direct}}[n] = \\frac{y[n+1] - y[n-1]}{2\\Delta t},\n$$\n定义域为 $n \\in \\{1,2,\\dots,N-2\\}$。\n2. 先进行高斯平滑，再进行相同的中心差分：\n   - 定义离散零相位高斯核，其标准差为 $\\sigma_g$ (以采样点数为单位)：\n   $$\n   g[k] = \\frac{\\exp\\!\\left(-\\frac{k^2}{2\\sigma_g^2}\\right)}{\\sum_{m=-K}^{K} \\exp\\!\\left(-\\frac{m^2}{2\\sigma_g^2}\\right)},\n   $$\n   其中 $K = \\lceil 3\\sigma_g \\rceil$ 且 $k \\in \\{-K,-K+1,\\dots,0,\\dots,K-1,K\\}$。若 $\\sigma_g = 0$，则定义 $g[0] = 1$ 且当 $k \\neq 0$ 时 $g[k] = 0$。\n   - 定义平滑后信号为离散卷积\n   $$\n   z[n] = \\sum_{k=-K}^{K} g[k]\\, y[n-k],\n   $$\n   我们约定，对于超出 $\\{0,\\dots,N-1\\}$ 范围的索引，将通过仅考虑后续差分有明确定义的有效采样点来隐式处理，并且仅对 $n \\in \\{1,2,\\dots,N-2\\}$ 范围内的点比较误差。\n   - 对 $z[n]$ 应用相同的中心差分：\n   $$ \n   \\widehat{d}_{\\text{smooth}}[n] = \\frac{z[n+1] - z[n-1]}{2\\Delta t},\n   $$\n   定义域为 $n \\in \\{1,2,\\dots,N-2\\}$。\n\n对于每种方法，使用相对均方根误差 (relative root-mean-square (RMS) error) 来量化其精度：\n$$\n\\mathrm{rRMSE}_{\\text{method}} = \\frac{\\sqrt{\\frac{1}{M}\\sum_{n=n_{\\min}}^{n_{\\max}}\\left(\\widehat{d}_{\\text{method}}[n] - x'(t_n)\\right)^2}}{\\sqrt{\\frac{1}{M}\\sum_{n=n_{\\min}}^{n_{\\max}} \\left(x'(t_n)\\right)^2}},\n$$\n其中 $n_{\\min} = 1$，$n_{\\max} = N-2$，$M = n_{\\max}-n_{\\min}+1$。该值为无量纲量。同时，计算改善因子\n$$\n\\rho = \\frac{\\mathrm{rRMSE}_{\\text{direct}}}{\\mathrm{rRMSE}_{\\text{smooth}}}.\n$$\n\n请实现一个完整的、可运行的程序，按定义构建信号和噪声，应用两种估计方法，并为以下每个测试用例计算各项指标。每个测试用例由 $(\\sigma_{\\eta}, \\sigma_g)$ 唯一指定，其中 $\\sigma_{\\eta}$ 是噪声标准差，$\\sigma_g$ 是高斯核标准差（以采样点数为单位）：\n- 用例 1: $(\\sigma_{\\eta}, \\sigma_g) = (0.5, 0.0)$。\n- 用例 2: $(\\sigma_{\\eta}, \\sigma_g) = (0.5, 2.0)$。\n- 用例 3: $(\\sigma_{\\eta}, \\sigma_g) = (2.0, 4.0)$。\n- 用例 4: $(\\sigma_{\\eta}, \\sigma_g) = (0.0, 4.0)$。\n\n所有最终数值输出必须是无单位的十进制浮点数。对于每个测试用例，返回一个包含三个值的列表 $[\\mathrm{rRMSE}_{\\text{direct}}, \\mathrm{rRMSE}_{\\text{smooth}}, \\rho]$，每个值都四舍五入到恰好6位小数。您的程序应产生单行输出，其中包含四个测试用例的结果。结果格式为一个由方括号括起来的、以逗号分隔的列表，其中每个测试用例的结果本身也是一个由方括号括起来的、以逗号分隔的列表。例如，格式必须是\n\"[ [d1,s1,r1],[d2,s2,r2],[d3,s3,r3],[d4,s4,r4] ]\"\n其中每个 $d_i$、$s_i$ 和 $r_i$ 都替换为相应的四舍五入后的十进制值。", "solution": "所给出的问题是计算物理领域中一个定义明确的练习，具体涉及实验数据的信号处理。它要求使用两种不同的方法来估计含噪信号的时间导数，并对其精度进行定量比较。该问题具有科学依据、客观，并提供了计算唯一解所需的所有必要信息。因此，该问题被认为是有效的。\n\n我将按以下步骤进行求解：首先构建信号及其导数，然后实现两种估计方法，最后为每个测试用例计算指定的误差指标。\n\n**1. 准备工作：信号与系统定义**\n\n问题为仿真提供了一组固定参数。\n- 采样频率: $f_s = 1000$ s$^{-1}$\n- 采样点数: $N = 4096$\n- 采样间隔: $\\Delta t = 1/f_s = 0.001$ s\n- 时间向量: $t_n = n \\Delta t$ for $n \\in \\{0, 1, \\dots, N-1\\}$\n- 伪随机数生成器种子: $S = 1337$\n\n连续时间信号 $x(t)$ 是两个正弦波和一个线性趋势的总和：\n$$\nx(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\cos(2\\pi f_2 t) + A_3 t\n$$\n参数为 $A_1 = 1.0$，$f_1 = 5.0$ s$^{-1}$，$A_2 = 0.3$，$f_2 = 40.0$ s$^{-1}$，$A_3 = 0.2$ s$^{-1}$。\n\n精确时间导数由下式给出：\n$$\nx'(t) = 2\\pi f_1 A_1 \\cos(2\\pi f_1 t) - 2\\pi f_2 A_2 \\sin(2\\pi f_2 t) + A_3\n$$\n\n测得的信号 $y[n]$ 是离散时间的纯净信号 $x(t_n)$ 叠加了标准差为 $\\sigma_{\\eta}$ 的加性高斯白噪声 $\\eta[n]$ 后的结果：\n$$\ny[n] = x(t_n) + \\eta[n]\n$$\n\n**2. 导数估计方法**\n\n任务的核心是比较两种估计导数 $x'(t_n)$ 的方法。两种方法都在区间 $n \\in \\{1, 2, \\dots, N-2\\}$ 上进行评估。\n\n**方法1：直接中心差分**\n\n该方法使用标准的中心差分公式直接应用于含噪数据 $y[n]$ 来近似导数：\n$$\n\\widehat{d}_{\\text{direct}}[n] = \\frac{y[n+1] - y[n-1]}{2\\Delta t}\n$$\n这个计算很简单明了。然而，众所周知，对含噪信号应用差分算子会放大噪声。导数估计中噪声分量的方差与 $\\sigma_{\\eta}^2 / (\\Delta t)^2$ 成正比，当 $\\Delta t$ 很小时，这个值会相当大。\n\n**方法2：先平滑后中心差分**\n\n该方法试图通过先对信号 $y[n]$ 应用一个低通滤波器，然后对平滑后的结果进行微分，来减轻噪声放大效应。\n\n- **平滑**：平滑是通过与一个零相位高斯核 $g[k]$ 进行离散卷积来执行的。\n  - 核的宽度由参数 $\\sigma_g$（以采样点数为单位）控制。\n  - 核的定义域为 $k \\in \\{-K, \\dots, K\\}$，其中 $K = \\lceil 3\\sigma_g \\rceil$。\n  - 公式为：\n    $$\n    g[k] = \\frac{\\exp\\!\\left(-\\frac{k^2}{2\\sigma_g^2}\\right)}{Z}, \\quad \\text{其中 } Z = \\sum_{m=-K}^{K} \\exp\\!\\left(-\\frac{m^2}{2\\sigma_g^2}\\right)\n    $$\n  - 定义了一个特殊情况，即 $\\sigma_g = 0$，此时核函数变为一个离散delta函数，$g[0]=1$ 且当 $k \\neq 0$ 时 $g[k]=0$。在这种情况下，与 $g[k]$ 进行卷积不会改变信号。\n  - 平滑后的信号为 $z[n] = (y * g)[n] = \\sum_{k=-K}^{K} g[k] y[n-k]$。这是一个标准的卷积运算。为了生成与 $y[n]$ 长度相同的输出 $z[n]$，我们使用 'same' 卷积模式，该模式通过填充输入信号（通常用零填充）来隐式处理边界效应。这些边界效应会在平滑后信号 $z[n]$ 的起始和结束位置附近引入误差。\n\n- **微分**：接着，对平滑后的信号 $z[n]$ 应用相同的中心差分公式：\n  $$\n  \\widehat{d}_{\\text{smooth}}[n] = \\frac{z[n+1] - z[n-1]}{2\\Delta t}\n  $$\n\n这个两步过程体现了一种经典的权衡：平滑滤波器减少了噪声（方差），但同时也可能通过衰减信号的高频分量而扭曲底层信号，从而引入系统误差（偏差）。$\\sigma_g$ 的最优选择取决于信号的频率成分和噪声水平。\n\n**3. 误差量化**\n\n每种方法的精度由相对均方根误差 (rRMSE) 来衡量。该指标在评估区间 $n \\in \\{1, \\dots, N-2\\}$ 上，比较了估计误差的均方根 (RMS) 与真实导数信号的均方根。\n\n$$\n\\mathrm{rRMSE}_{\\text{method}} = \\frac{\\sqrt{\\frac{1}{M}\\sum_{n=1}^{N-2}\\left(\\widehat{d}_{\\text{method}}[n] - x'(t_n)\\right)^2}}{\\sqrt{\\frac{1}{M}\\sum_{n=1}^{N-2} \\left(x'(t_n)\\right)^2}}\n$$\n其中 $M = N-2$。\n\n改善因子 $\\rho$ 量化了平滑方法相对于直接方法的性能提升：\n$$\n\\rho = \\frac{\\mathrm{rRMSE}_{\\text{direct}}}{\\mathrm{rRMSE}_{\\text{smooth}}}\n$$\n$\\rho > 1$ 的值表示平滑改善了导数估计。\n\n**4. 实现策略**\n\n解决方案将使用 Python 实现，其中 `numpy` 库用于数值运算和数组处理，`scipy.signal` 库用于卷积。一个单独的函数将为每个指定的测试用例执行整个处理流程。\n\n- **初始化**：设置所有常量，并使用指定的种子初始化伪随机数生成器。\n- **信号生成**：生成离散时间向量 `t`、纯净信号 `x` 和精确导数 `x_prime`。\n- **主循环**：遍历所提供的测试用例 $(\\sigma_{\\eta}, \\sigma_g)$。\n- **循环内部**：\n  1. 生成由 $\\sigma_{\\eta}$ 缩放的噪声向量 $\\eta$，并将其加到 `x` 上以创建含噪信号 `y`。\n  2. **方法1**：对 `y` 应用中心差分，计算 `d_direct_est`。\n  3. **方法2**：\n     - 如果 $\\sigma_g > 0$，构建高斯核 `g`，然后使用 `scipy.signal.convolve(y, g, mode='same')` 计算平滑信号 `z`。\n     - 如果 $\\sigma_g = 0$，则设置 `z = y`。\n     - 对 `z` 应用中心差分，计算 `d_smooth_est`。\n  4. **误差计算**：\n     - 通过对 `x_prime` 进行切片以匹配评估区间，定义目标导数 `d_exact`。\n     - 计算两种方法的误差均方根以及精确导数信号的均方根。\n     - 计算 $\\mathrm{rRMSE}_{\\text{direct}}$、$\\mathrm{rRMSE}_{\\text{smooth}}$ 和 $\\rho$。\n  5. 存储当前测试用例的四舍五入后的结果。\n- **输出**：将收集到的结果格式化为指定的字符串格式，并打印到标准输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the signal processing problem as defined.\n    Constructs a synthetic signal, adds noise, and compares two methods\n    for estimating its time derivative.\n    \"\"\"\n    # Define problem constants\n    f_s = 1000.0  # Sampling frequency in s^-1\n    N = 4096      # Number of samples\n    dt = 1.0 / f_s  # Sampling interval in s\n\n    A1 = 1.0\n    f1 = 5.0      # s^-1\n    A2 = 0.3\n    f2 = 40.0     # s^-1\n    A3 = 0.2      # s^-1\n\n    S = 1337      # Pseudorandom number generator seed\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (sigma_eta, sigma_g)\n        (0.5, 0.0),\n        (0.5, 2.0),\n        (2.0, 4.0),\n        (0.0, 4.0),\n    ]\n\n    # Generate time vector, clean signal, and its exact derivative\n    t = np.arange(N) * dt\n    x = (A1 * np.sin(2 * np.pi * f1 * t) +\n         A2 * np.cos(2 * np.pi * f2 * t) +\n         A3 * t)\n    x_prime = (2 * np.pi * f1 * A1 * np.cos(2 * np.pi * f1 * t) -\n               2 * np.pi * f2 * A2 * np.sin(2 * np.pi * f2 * t) +\n               A3)\n\n    # Initialize the random number generator\n    rng = np.random.default_rng(seed=S)\n    \n    results = []\n    \n    # Process each test case\n    for sigma_eta, sigma_g in test_cases:\n        # Generate the noisy measurement\n        # The problem statement implies the stochastic process should be reproducible,\n        # which is achieved by using the same generator instance over the loop.\n        noise = sigma_eta * rng.standard_normal(N)\n        y = x + noise\n\n        # Method 1: Direct central differencing\n        # Valid for n in {1, ..., N-2}, resulting in N-2 points\n        d_direct_est = (y[2:] - y[:-2]) / (2 * dt)\n\n        # Method 2: Gaussian smoothing followed by central differencing\n        if sigma_g == 0.0:\n            z = y  # No smoothing\n        else:\n            # Define the discrete zero-phase Gaussian kernel\n            K = int(np.ceil(3 * sigma_g))\n            k = np.arange(-K, K + 1)\n            kernel_vals = np.exp(-k**2 / (2 * sigma_g**2))\n            g = kernel_vals / np.sum(kernel_vals)\n            \n            # Convolve the signal with the kernel\n            # 'same' mode ensures output length is N, with boundary effects\n            z = signal.convolve(y, g, mode='same')\n        \n        # Apply central difference to the smoothed signal\n        d_smooth_est = (z[2:] - z[:-2]) / (2 * dt)\n\n        # Quantify accuracy using relative RMS error\n        # The evaluation range is n in {1, ..., N-2}, so we slice the exact derivative\n        d_exact_eval = x_prime[1:-1]\n        \n        # Denominator for rRMSE: RMS of the exact derivative\n        rms_exact_deriv = np.sqrt(np.mean(d_exact_eval**2))\n\n        # Calculate rRMSE for the direct method\n        rms_err_direct = np.sqrt(np.mean((d_direct_est - d_exact_eval)**2))\n        rRMSE_direct = rms_err_direct / rms_exact_deriv\n\n        # Calculate rRMSE for the smoothed method\n        rms_err_smooth = np.sqrt(np.mean((d_smooth_est - d_exact_eval)**2))\n        rRMSE_smooth = rms_err_smooth / rms_exact_deriv\n        \n        # Handle potential division by zero if rRMSE_smooth is zero\n        if rRMSE_smooth == 0.0:\n            # This can happen in noise-free cases if the method is perfect.\n            # If direct is also zero, improvement is 1. Otherwise, infinite.\n            # Given the nature of the problem, this is unlikely.\n            rho = 1.0 if rRMSE_direct == 0.0 else np.inf\n        else:\n            rho = rRMSE_direct / rRMSE_smooth\n            \n        case_result = [\n            round(rRMSE_direct, 6),\n            round(rRMSE_smooth, 6),\n            round(rho, 6)\n        ]\n        results.append(case_result)\n\n    # Format the final output string as per requirements\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n\n```", "id": "2438105"}]}