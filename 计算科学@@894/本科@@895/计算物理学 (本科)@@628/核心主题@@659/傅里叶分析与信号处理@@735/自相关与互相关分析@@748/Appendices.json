{"hands_on_practices": [{"introduction": "理论通过实践才能真正变得鲜活。在计算物理中，伪随机数生成器是蒙特卡洛模拟等多种技术的基础。一个高质量的随机序列应该像白噪声一样，其自身在任何非零时间延迟上都不应存在相关性。本练习 [@problem_id:2374592] 将指导您使用自相关分析作为一种有力的统计工具，来检验伪随机数生成器的质量，并量化其输出序列中隐藏的周期性或模式。", "problem": "你的任务是通过分析伪随机数生成器输出序列的归一化样本自相关来评估其质量。设一个长度为 $N$ 的有限实值序列表示为 $\\{x_n\\}_{n=0}^{N-1}$。定义样本均值 $\\mu$ 和样本方差 $\\sigma^2$ 为\n$$\n\\mu = \\frac{1}{N}\\sum_{n=0}^{N-1} x_n,\\quad \\sigma^2 = \\frac{1}{N}\\sum_{n=0}^{N-1} (x_n - \\mu)^2.\n$$\n对于满足 $0 \\le k \\le K \\le N-1$ 的整数延迟 $k$，定义归一化样本自相关 $\\rho(k)$ 为\n$$\n\\rho(0) = 1,\\quad \\rho(k) = \\frac{1}{(N-k)\\,\\sigma^2}\\sum_{n=0}^{N-k-1} (x_n - \\mu)(x_{n+k} - \\mu)\\quad \\text{for } 1 \\le k \\le K,\n$$\n约定如果 $\\sigma^2 = 0$，则 $\\rho(0) = 1$ 且对于所有 $k \\ge 1$ 有 $\\rho(k) = 0$。\n\n一个序列通过最大延迟为 $K$、阈值为 $\\tau$ 的白度检验，当且仅当 $\\sigma^2 > 0$ 且\n$$\n\\max_{1 \\le k \\le K} |\\rho(k)| \\le \\tau.\n$$\n为检测短周期，使用以下规则：如果一个延迟 $k$（$1 \\le k \\le K$）满足 $\\rho(k) \\ge \\rho(k-1)$，并且当 $k \\le K-1$ 时，还满足 $\\rho(k) \\ge \\rho(k+1)$，则称其为局部最大值；在边界 $k=K$ 处，局部最大值的条件是 $\\rho(K) \\ge \\rho(K-1)$。检测到的周期是集合 $\\{1,2,\\dots,K\\}$ 中满足 $\\rho(k) \\ge \\theta$ 的最小局部最大值 $k$。如果不存在这样的 $k$，则报告检测到的周期为 $0$。\n\n请实现一个程序，对于下面测试套件中的每一组参数，生成指定的序列 $\\{x_n\\}$，计算 $0 \\le k \\le K$ 的 $\\rho(k)$，判断序列是否通过白度检验，并根据上述规则检测短周期。对于每个测试用例，输出一个列表 $[w, p]$，其中 $w$ 是一个布尔值，表示是否通过白度检验，$p$ 是检测到的周期（整数）。你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表（例如：$\"[[\\text{True},0],[\\text{False},64]]\"$) 。\n\n测试套件（每个用例指定如何生成 $\\{x_n\\}$ 以及参数 $N$、$K$、$\\tau$、$\\theta$）：\n\n- 用例 1（长周期乘法线性同余生成器）：定义整数 $m$、$a$、$c$ 和 $s_0$ 为 $m = 2^{31}-1$、 $a = 16807$、 $c = 0$、 $s_0 = 12345$。对于 $n \\ge 0$，定义\n$$\ns_{n+1} \\equiv (a\\,s_n + c) \\bmod m,\\quad x_n = \\frac{s_n}{m}.\n$$\n使用 $N = 10000$、$K = 100$、$\\tau = 0.1$、$\\theta = 0.9$。\n\n- 用例 2（短周期混合线性同余生成器）：定义整数 $m$、$a$、$c$ 和 $s_0$ 为 $m = 64$、$a = 13$、$c = 1$、$s_0 = 7$。对于 $n \\ge 0$，定义\n$$\ns_{n+1} \\equiv (a\\,s_n + c) \\bmod m,\\quad x_n = \\frac{s_n}{m}.\n$$\n使用 $N = 4096$、$K = 80$、$\\tau = 0.1$、$\\theta = 0.9$。\n\n- 用例 3（退化的常数序列）：对于所有 $n \\in \\{0,1,\\dots,N-1\\}$，定义 $x_n = \\tfrac{1}{2}$。使用 $N = 256$、$K = 50$、$\\tau = 0.1$、$\\theta = 0.9$。\n\n你的程序必须输出单行，其格式与列表的列表 $[[w_1,p_1],[w_2,p_2],[w_3,p_3]]$ 完全一致，其中 $w_i$ 和 $p_i$ 分别是用例 $i$ 的白度检验判定结果和检测到的周期。", "solution": "在尝试任何解决方案之前，提交以供分析的问题陈述都经过了严格的验证。\n\n第一步是逐字提取所有给定信息。\n问题提供了长度为 $N$ 的有限实值序列 $\\{x_n\\}_{n=0}^{N-1}$、其样本均值 $\\mu = \\frac{1}{N}\\sum_{n=0}^{N-1} x_n$ 以及样本方差 $\\sigma^2 = \\frac{1}{N}\\sum_{n=0}^{N-1} (x_n - \\mu)^2$ 的定义。\n它定义了整数延迟 $k$（其中 $0 \\le k \\le K \\le N-1$）的归一化样本自相关 $\\rho(k)$ 如下：\n$$\n\\rho(0) = 1\n$$\n$$\n\\rho(k) = \\frac{1}{(N-k)\\,\\sigma^2}\\sum_{n=0}^{N-k-1} (x_n - \\mu)(x_{n+k} - \\mu)\\quad \\text{for } 1 \\le k \\le K\n$$\n约定了一个特殊情况：如果 $\\sigma^2 = 0$，则 $\\rho(0) = 1$ 且对于所有 $k \\ge 1$ 有 $\\rho(k) = 0$。\n\n基于这些统计量定义了两个检验：\n1. 白度检验：若 $\\sigma^2 > 0$ 且 $\\max_{1 \\le k \\le K} |\\rho(k)| \\le \\tau$，则序列通过检验。这里 $K$ 是给定的最大延迟，$\\tau$ 是阈值。\n2. 周期检测规则：如果一个延迟 $k \\in \\{1, \\dots, K\\}$ 满足 $\\rho(k) \\ge \\rho(k-1)$ 且（若 $k \\le K-1$）$\\rho(k) \\ge \\rho(k+1)$，则称其为局部最大值。检测到的周期是满足 $\\rho(k) \\ge \\theta$ 的最小的此类局部最大值 $k$。如果不存在这样的 $k$，则周期为 $0$。\n\n任务要求为三个特定的测试用例实现这些分析，并将输出格式化为列表的列表：$[[w, p]]$，其中 $w$ 是白度检验的布尔结果，$p$ 是检测到的整数周期。\n\n测试用例：\n- 用例 1：一个乘法线性同余生成器（LCG），参数为 $m = 2^{31}-1$、$a = 16807$、$c = 0$、$s_0 = 12345$。序列为 $x_n = s_n/m$，其中 $s_{n+1} \\equiv (a s_n + c) \\bmod m$。分析参数为 $N = 10000$、$K = 100$、$\\tau = 0.1$、$\\theta = 0.9$。\n- 用例 2：一个混合LCG，参数为 $m = 64$、$a = 13$、$c = 1$、$s_0 = 7$。序列生成方式相同。分析参数为 $N = 4096$、$K = 80$、$\\tau = 0.1$、$\\theta = 0.9$。\n- 用例 3：一个退化的常数序列 $x_n = 1/2$。分析参数为 $N = 256$、$K = 50$、$\\tau = 0.1$、$\\theta = 0.9$。\n\n经过验证，该问题被认定为具有科学依据、提法恰当且客观。这些定义是统计时间序列分析中的标准。所用的LCG是伪随机数生成器的经典示例。所有参数和条件都已明确无误地指定，确保了唯一且可验证的解。该问题没有矛盾、含糊不清或不科学的主张。因此，该问题被视为有效，可以构建解决方案。\n\n解决方案的实现首先是为每个用例生成指定的序列 $\\{x_n\\}$。然后，应用一个统一的分析函数。该函数按以下步骤进行：\n\n首先，根据定义计算序列 $\\{x_n\\}_{n=0}^{N-1}$ 的样本均值 $\\mu$ 和样本方差 $\\sigma^2$。这些是描述序列集中趋势和离散程度的基本统计矩。\n\n逻辑上的一个关键分支取决于样本方差 $\\sigma^2$ 的值。如果 $\\sigma^2 = 0$，这意味着序列是常数。根据问题的明确规则：\n- 白度检验要求 $\\sigma^2 > 0$，因此立即失败。结果 $w$ 为 `False`。\n- 自相关被定义为 $\\rho(0) = 1$ 且对于所有 $k \\ge 1$ 都有 $\\rho(k) = 0$。为检测周期，我们寻找 $\\{1, \\dots, K\\}$ 中是局部最大值且满足 $\\rho(k) \\ge \\theta$ 的最小 $k$。一个延迟 $k \\ge 1$ 是局部最大值，如果 $\\rho(k) \\ge \\rho(k-1)$ 且（若适用）$\\rho(k) \\ge \\rho(k+1)$。对于 $k=1$，$\\rho(1) \\ge \\rho(0)$ 变为 $0 \\ge 1$，这是假的。对于 $k \\in \\{2, \\dots, K\\}$，条件评估为 $0 \\ge 0$，这是真的。因此，从 $2$ 到 $K$ 的所有延迟都是局部最大值。然而，条件 $\\rho(k) \\ge \\theta$ 变为 $0 \\ge 0.9$，这永远不会满足。因此，没有检测到周期，结果 $p$ 为 $0$。这就处理了用例 3。\n\n如果 $\\sigma^2 > 0$，则继续分析。计算延迟 $k$ 从 $1$ 到 $K$ 的归一化样本自相关函数 $\\rho(k)$。求和项 $\\sum_{n=0}^{N-k-1} (x_n - \\mu)(x_{n+k} - \\mu)$ 是一个非归一化的自协方差，可以高效地计算为中心化后的序列与其自身延迟版本之间的点积。然后将结果除以 $(N-k)\\sigma^2$ 进行归一化。\n\n在计算出 $k \\in \\{0, \\dots, K\\}$ 的 $\\rho(k)$ 值数组后，执行两个检验：\n1. 如果非零延迟的自相关最大绝对值 $\\max_{1 \\le k \\le K} |\\rho(k)|$ 不超过阈值 $\\tau$，则通过白度检验。此检验评估序列值在多大程度上是不相关的，这是“白噪声”信号的一个关键属性。\n2. 对于周期检测，算法遍历从 $1$ 到 $K$ 的延迟 $k$，检查每个 $k$ 是否具有定义的局部最大值属性。第一个既是局部最大值又满足自相关值 $\\rho(k)$ 大于或等于阈值 $\\theta$ 的延迟 $k$ 被指定为检测到的周期 $p$。如果循环完成而没有找到这样的延迟，则报告周期为 $0$。这种启发式方法可以识别信号中第一个显著的周期性分量。\n\n将此完整方法应用于三个测试用例中的每一个，以产生最终结果。对于用例 1，LCG 是一个已知的长周期生成器，对于给定的 $N$ 和 $K$，预期它会表现出随机性，通过白度检验，并且不显示明显的周期性。对于用例 2，LCG 有一个已知的短周期 64。序列长度 $N=4096$ 是 64 的倍数，因此预期在延迟 $k=64$ 处会有强相关性，导致白度检验失败并检测到周期 64。\n\n以下 Python 程序精确地实现了这一逻辑，并遵守了指定的执行环境和输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"type\": \"lcg\", \n            \"params\": {\"m\": 2**31 - 1, \"a\": 16807, \"c\": 0, \"s0\": 12345},\n            \"N\": 10000, \"K\": 100, \"tau\": 0.1, \"theta\": 0.9\n        },\n        {\n            \"type\": \"lcg\",\n            \"params\": {\"m\": 64, \"a\": 13, \"c\": 1, \"s0\": 7},\n            \"N\": 4096, \"K\": 80, \"tau\": 0.1, \"theta\": 0.9\n        },\n        {\n            \"type\": \"const\",\n            \"params\": {\"val\": 0.5},\n            \"N\": 256, \"K\": 50, \"tau\": 0.1, \"theta\": 0.9\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate the sequence x_n\n        N = case[\"N\"]\n        x = np.zeros(N, dtype=np.float64)\n        if case[\"type\"] == \"lcg\":\n            m, a, c, s0 = case[\"params\"][\"m\"], case[\"params\"][\"a\"], case[\"params\"][\"c\"], case[\"params\"][\"s0\"]\n            s = s0\n            for n in range(N):\n                x[n] = float(s) / m\n                s = (a * s + c) % m\n        elif case[\"type\"] == \"const\":\n            x.fill(case[\"params\"][\"val\"])\n        \n        # Analyze the sequence\n        K, tau, theta = case[\"K\"], case[\"tau\"], case[\"theta\"]\n        w, p = analyze_sequence(x, N, K, tau, theta)\n        results.append([w, p])\n\n    # Final print statement in the exact required format.\n    output_parts = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\ndef analyze_sequence(x, N, K, tau, theta):\n    \"\"\"\n    Analyzes a sequence for whiteness and short period.\n    \n    Args:\n        x (np.ndarray): The sequence {x_n}.\n        N (int): Length of the sequence.\n        K (int): Maximum lag.\n        tau (float): Whiteness test threshold.\n        theta (float): Period detection threshold.\n        \n    Returns:\n        list: A list [w, p] where w is whiteness test result (bool)\n              and p is the detected period (int).\n    \"\"\"\n    mu = np.mean(x)\n    sigma_sq = np.var(x) # np.var uses N in denominator by default.\n\n    # Convention for sigma^2 = 0\n    if np.isclose(sigma_sq, 0.0):\n        w = False  # Fails whiteness test condition sigma^2 > 0\n        p = 0      # rho(k)=0 for k>=1, so rho(k) < theta. No period detected.\n        return [w, p]\n\n    # Compute normalized sample autocorrelation rho(k)\n    rho = np.zeros(K + 1, dtype=np.float64)\n    rho[0] = 1.0\n    \n    centered_x = x - mu\n    for k in range(1, K + 1):\n        # Sum of (x_n - mu)(x_{n+k} - mu) for n from 0 to N-k-1\n        # This is the dot product of the first N-k elements with the last N-k elements\n        numerator = np.dot(centered_x[0:N-k], centered_x[k:N])\n        denominator = (N - k) * sigma_sq\n        rho[k] = numerator / denominator\n\n    # Perform whiteness test\n    max_abs_rho = np.max(np.abs(rho[1:]))\n    w = max_abs_rho <= tau\n\n    # Detect short period\n    p = 0\n    for k in range(1, K + 1):\n        # Check for local maximum at k\n        is_local_max = False\n        cond_left = (rho[k] >= rho[k-1])\n        if k == K:\n            if cond_left:\n                is_local_max = True\n        else:\n            cond_right = (rho[k] >= rho[k+1])\n            if cond_left and cond_right:\n                is_local_max = True\n        \n        if is_local_max:\n            if rho[k] >= theta:\n                p = k\n                break # Found smallest k, so we can stop.\n    \n    return [w, p]\n\nsolve()\n```", "id": "2374592"}, {"introduction": "相关性的概念可以从一维时间序列扩展到多维空间数据，用于分析复杂的空间模式。从磁畴的形成到星系的分布，许多物理系统都表现出独特的空间结构。在此练习 [@problem_id:2374590] 中，我们将研究经典的元胞自动机——康威生命游戏，并应用二维空间自相关函数来量化细胞模式的“聚集”程度。通过计算特征相关长度，您将学习如何从复杂的空间格局中提取一个有意义的物理尺度。", "problem": "您需要实现一个完整的、可运行的程序，该程序在一个有限的二维环面上模拟 Conway 的生命游戏，并使用二维空间自相关分析来量化活细胞分布的空间“团簇性”。您的推导和算法必须从适用于计算物理学的第一性原理开始。\n\nConway 的生命游戏定义在一个边长为 $N$ 的方形晶格上的二元场 $X_t(i,j) \\in \\{0,1\\}$，具有周期性（环形）边界条件。时间以离散步长 $t \\mapsto t+1$ 前进。对于每个晶格位置 $(i,j)$，令 $S_t(i,j)$ 为其八个最近邻（使用周期性环绕）的值的总和。更新规则如下：\n- 如果 $X_t(i,j) = 1$ 且 $S_t(i,j) \\in \\{2,3\\}$，则 $X_{t+1}(i,j) = 1$；否则，$X_{t+1}(i,j) = 0$。\n- 如果 $X_t(i,j) = 0$ 且 $S_t(i,j) = 3$，则 $X_{t+1}(i,j) = 1$；否则，$X_{t+1}(i,j) = 0$。\n\n令时间 $t$ 的空间均值为 $\\mu_t = \\frac{1}{N^2} \\sum_{i,j} X_t(i,j)$，零均值涨落场为 $f_t(i,j) = X_t(i,j) - \\mu_t$。定义离散圆形（周期性）自协方差\n$$\nR_t(\\Delta x,\\Delta y) = \\sum_{i=1}^{N}\\sum_{j=1}^{N} f_t(i,j)\\, f_t(i+\\Delta x \\ \\mathrm{mod}\\ N, \\, j+\\Delta y \\ \\mathrm{mod}\\ N),\n$$\n以及归一化自相关\n$$\nC_t(\\Delta x,\\Delta y) = \n\\begin{cases}\n\\dfrac{R_t(\\Delta x,\\Delta y)}{R_t(0,0)}, & \\text{如果 } R_t(0,0) > 0,\\\\\n0, & \\text{如果 } R_t(0,0)=0.\n\\end{cases}\n$$\n在环面上，定义最小环绕距离\n$$\nd(\\Delta x,\\Delta y) = \\sqrt{\\min(|\\Delta x|, N-|\\Delta x|)^2 + \\min(|\\Delta y|, N-|\\Delta y|)^2}.\n$$\n对于整数半径 $r \\in \\{0,1,2,\\dots,R_{\\max}\\}$（其中 $R_{\\max} = \\left\\lfloor \\sqrt{2}\\,\\frac{N}{2} \\right\\rfloor$），定义离散环状壳层\n$$\n\\mathcal{S}_r = \\{(\\Delta x,\\Delta y): r \\le d(\\Delta x,\\Delta y) < r+1\\},\n$$\n以及各向同性（径向平均）自相关\n$$\nc_t(r) = \\frac{1}{|\\mathcal{S}_r|} \\sum_{(\\Delta x,\\Delta y)\\in \\mathcal{S}_r} C_t(\\Delta x,\\Delta y),\n$$\n约定忽略空的壳层。为将“团簇性”量化为单一标量长度尺度，定义非负部分加权相关长度（不包括 $r=0$ 处的平凡自相关）\n$$\nL_t =\n\\begin{cases}\n\\sqrt{\\dfrac{\\sum\\limits_{r=1}^{R_{\\max}} r^2 \\, \\max\\left(c_t(r),0\\right)}{\\sum\\limits_{r=1}^{R_{\\max}} \\max\\left(c_t(r),0\\right)}}, & \\text{如果分母为正},\\\\\n0, & \\text{其他情况}.\n\\end{cases}\n$$\n所有量均为无量纲。\n\n您必须：\n- 根据指定的初始条件，在 $N \\times N$ 的环面上模拟生命游戏，步数为指定的 $T$。\n- 对下方的每个测试用例，在 $t=0$、$t=\\lfloor T/2 \\rfloor$ 和 $t=T$ 时刻计算 $L_t$。自相关必须针对周期性域进行计算。\n- 根据上述定义处理 $R_t(0,0)=0$ 的边界情况。\n\n程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。输出顺序如下：按顺序对每个测试用例，附加三个浮点数 $[L_0,L_{\\lfloor T/2 \\rfloor},L_T]$；然后将所有测试用例的结果连接成一个扁平列表。不涉及单位；报告原始浮点数值。\n\n测试套件（每项为一个测试用例）：\n- 用例 A（一般随机，中等密度）：$N=64$，$T=128$，Bernoulli 初始状态，存活概率 $p=0.35$，随机种子 $12345$。\n- 用例 B（稀疏随机）：$N=64$，$T=128$，Bernoulli 初始状态，存活概率 $p=0.05$，随机种子 $2021$。\n- 用例 C（密集随机）：$N=64$，$T=128$，Bernoulli 初始状态，存活概率 $p=0.95$，随机种子 $7$。\n- 用例 D（结构化振荡器）：$N=32$，$T=32$，初始状态包含三个不相交的“闪烁体”（每个为一条由三个相邻活细胞组成的线），水平对齐，中心位于晶格坐标 $(8,8)$、$(16,16)$ 和 $(24,24)$。\n- 用例 E（全死）：$N=32$，$T=10$，所有细胞初始为 $0$。\n- 用例 F（全活）：$N=32$，$T=10$，所有细胞初始为 $1$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），包含恰好 $18$ 个浮点数条目，对应六个测试用例中每个用例的三个输出，并按上述顺序排列。", "solution": "所提出的问题是计算物理学中一个明确定义的练习。它要求模拟一个细胞自动机（具体为 Conway 的生命游戏），并随后使用自相关方法对生成的模式进行空间统计分析。该问题具有科学依据，数学上一致，且所有参数和定义都给出了足够的精度。因此，该问题被认为是有效的。我们从第一性原理开始推导解决方案。\n\n问题的核心包括两个主要部分：首先，对二元场 $X_t(i,j)$ 进行动力学模拟；其次，根据该场的快照计算空间相关长度 $L_t$。\n\n**第 1 部分：Conway 的生命游戏模拟**\n\n系统是一个在具有周期性边界条件的 $N \\times N$ 晶格上的二元场 $X_t(i,j) \\in \\{0, 1\\}$。一个细胞在时间 $t+1$ 的状态取决于其自身在时间 $t$ 的状态 $X_t(i,j)$ 以及其八个邻居的总和 $S_t(i,j)$。位置 $(i,j)$ 处的邻居总和可以表示为离散圆形卷积：\n$$\nS_t(i,j) = \\sum_{k,l \\in \\{-1,0,1\\}, (k,l)\\neq(0,0)} X_t(i+k \\ \\mathrm{mod}\\ N, \\, j+l \\ \\mathrm{mod}\\ N)\n$$\n通过将场 $X_t$ 与一个核 $K$ 进行卷积，可以高效地计算此操作：\n$$\nK = \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 0 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix}\n$$\n因此，我们有 $S_t = X_t * K$，其中 $*$ 表示二维圆形卷积。这可以使用处理周期性边界条件的标准库函数进行数值实现。\n\n更新规则同时应用于所有细胞 $(i,j)$：\n1.  如果一个活细胞 ($X_t(i,j) = 1$) 的邻居总和 $S_t(i,j)$ 为 $2$ 或 $3$，它将在下一代中存活。这可以写成逻辑条件：$(X_t(i,j) = 1) \\land (S_t(i,j) \\in \\{2, 3\\})$。\n2.  如果一个死细胞 ($X_t(i,j) = 0$) 的邻居总和 $S_t(i,j)$ 恰好为 $3$，它将变为活细胞（诞生）。这是逻辑条件：$(X_t(i,j) = 0) \\land (S_t(i,j) = 3)$。\n\n下一个时间步的状态 $X_{t+1}(i,j)$ 是这两个条件的逻辑或。模拟通过迭代应用此更新规则进行，持续所需步数 $T$。\n\n**第 2 部分：自相关分析与相关长度**\n\n目标是量化特定时刻模式 $X_t$ 的“团簇性”。这是通过从空间自相关函数计算一个特征长度尺度来实现的。\n\n首先，我们通过减去空间均值 $\\mu_t = \\frac{1}{N^2} \\sum_{i,j} X_t(i,j)$ 来定义零均值涨落场 $f_t(i,j)$：\n$$\nf_t(i,j) = X_t(i,j) - \\mu_t\n$$\n自协方差函数 $R_t(\\Delta x, \\Delta y)$ 测量场与其自身空间平移版本之间的协方差。给出的定义是针对周期性域的：\n$$\nR_t(\\Delta x,\\Delta y) = \\sum_{i=1}^{N}\\sum_{j=1}^{N} f_t(i,j)\\, f_t(i+\\Delta x \\ \\mathrm{mod}\\ N, \\, j+\\Delta y \\ \\mathrm{mod}\\ N)\n$$\n这是一个圆形自相关。直接的暴力计算将按 $O(N^4)$ 的尺度进行，对于给定的晶格尺寸来说是不可行的。我们必须采用一种更高效的方法，该方法基于离散信号的 Wiener-Khinchin 定理。该定理指出，信号自相关的离散傅里叶变换 (DFT) 等于其功率谱密度（信号 DFT 的幅值平方）。令 $\\mathcal{F}$ 表示二维 DFT。圆形自相关可以计算为：\n$$\nR_t = \\mathcal{F}^{-1}\\left[ \\mathcal{F}[f_t] \\cdot \\mathcal{F}[f_t]^* \\right] = \\mathcal{F}^{-1}\\left[ \\left| \\mathcal{F}[f_t] \\right|^2 \\right]\n$$\n其中 $z^*$ 是 $z$ 的复共轭。这将计算复杂度降低到快速傅里叶变换 (FFT) 算法的复杂度，即 $O(N^2 \\log N)$。\n\n然后将自协方差 $R_t$ 归一化以得到自相关函数 $C_t$：\n$$\nC_t(\\Delta x,\\Delta y) = \\frac{R_t(\\Delta x,\\Delta y)}{R_t(0,0)}\n$$\n分母 $R_t(0,0) = \\sum_{i,j} f_t(i,j)^2$ 是场的总方差乘以 $N^2$。如果 $R_t(0,0)=0$，则该场方差为零（是均匀的），意味着处处有 $f_t(i,j)=0$。在这种情况下，没有可供相关的涨落，$C_t(\\Delta x,\\Delta y)$ 被定义为 $0$。\n\n为获得单一的特征长度，我们首先计算各向同性（径向平均）自相关 $c_t(r)$。这涉及在半径为 $r$ 的环状壳层 $\\mathcal{S}_r$ 上对 $C_t(\\Delta x, \\Delta y)$ 进行平均。距离 $d(\\Delta x, \\Delta y)$ 是环面上对于位移 $(\\Delta x, \\Delta y)$ 的最小欧几里得距离：\n$$\nd(\\Delta x,\\Delta y) = \\sqrt{\\min(|\\Delta x|, N-|\\Delta x|)^2 + \\min(|\\Delta y|, N-|\\Delta y|)^2}\n$$\n我们构建一个对应所有可能滞后 $(\\Delta x, \\Delta y)$ 的距离网格，其中 $\\Delta x, \\Delta y \\in \\{0, 1, \\dots, N-1\\}$。对于从 $0$ 到 $R_{\\max} = \\lfloor \\sqrt{2} N/2 \\rfloor$ 的每个整数半径 $r$，我们识别出所有满足 $r \\le d(\\Delta x, \\Delta y) < r+1$ 的滞后 $(\\Delta x, \\Delta y)$。值 $c_t(r)$ 是在这些滞后上 $C_t(\\Delta x, \\Delta y)$ 的平均值。\n\n最后，相关长度 $L_t$ 被定义为径向距离 $r$ 的加权均方根，其中权重是各向同性自相关 $c_t(r)$ 对于 $r \\ge 1$ 的非负值：\n$$\nL_t = \\sqrt{\\frac{\\sum_{r=1}^{R_{\\max}} r^2 \\, \\max(c_t(r),0)}{\\sum_{r=1}^{R_{\\max}} \\max(c_t(r),0)}}\n$$\n求和排除了 $r=0$，因为 $c_t(0)=1$ 是一个平凡自相关。使用 $\\max(c_t(r),0)$ 确保只有正相关（表示聚类或聚集）对长度尺度有贡献，而反相关则被忽略。分母为零（即对于 $r \\ge 1$ 没有正相关）的边界情况导致 $L_t = 0$，这在物理上是合理的。\n\n要实现的算法如下：\n1.  对每个测试用例，根据规范生成初始状态 $X_0$。\n2.  创建一个待分析的模拟时间列表：$t \\in \\{0, \\lfloor T/2 \\rfloor, T\\}$。\n3.  模拟从 $t=0$ 到 $t=T$ 的生命游戏演化过程，并存储所需分析时间的网格状态。\n4.  对每个存储的网格 $X_t$：\n    a. 计算涨落场 $f_t$。\n    b. 如果 $X_t$ 的方差为零，则 $L_t = 0$。\n    c. 否则，使用基于 FFT 的方法计算自协方差矩阵 $R_t$。\n    d. 归一化 $R_t$ 以得到自相关矩阵 $C_t$。\n    e. 预计算环面距离网格 $d(\\Delta x, \\Delta y)$。\n    f. 通过根据距离网格对 $C_t$ 的值进行分箱，计算 $r \\in \\{0, \\dots, R_{\\max}\\}$ 的径向平均自相关 $c_t(r)$。\n    g. 使用最终公式计算相关长度 $L_t$，对 $r \\in \\{1, \\dots, R_{\\max}\\}$ 进行求和。\n5.  收集所有测试用例计算出的 $L_t$ 值，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef calculate_correlation_length(X: np.ndarray) -> float:\n    \"\"\"\n    Calculates the spatial correlation length L_t for a given 2D binary field X.\n    \"\"\"\n    N = X.shape[0]\n\n    # Handle edge cases where the field is uniform (all 0s or all 1s).\n    # The variance is 0, so the fluctuation field is identically zero.\n    # This leads to R_t(0,0)=0, and per definition, L_t=0.\n    if np.var(X) == 0:\n        return 0.0\n\n    # 1. Compute the zero-mean fluctuation field f_t.\n    mu_t = np.mean(X)\n    f_t = X - mu_t\n\n    # 2. Compute the autocovariance R_t using the Wiener-Khinchin theorem.\n    # The result of ifft2 of a real-symmetric spectrum is real.\n    F_f = np.fft.fft2(f_t)\n    power_spectrum = np.abs(F_f)**2\n    R_t = np.real(np.fft.ifft2(power_spectrum))\n\n    # 3. Normalize to get the autocorrelation C_t.\n    R_t_00 = R_t[0, 0]\n    if R_t_00 <= 0: # Should not happen if var > 0, but as safeguard.\n        return 0.0\n    C_t = R_t / R_t_00\n\n    # 4. Compute the isotropic (radially averaged) autocorrelation c_t(r).\n    # First, create a grid of minimal toroidal distances d(dx, dy).\n    # The indices (i, j) of the R_t array correspond to lags (dx, dy).\n    i_coords = np.arange(N)\n    min_dist_1d = np.minimum(i_coords, N - i_coords)\n    dist_x, dist_y = np.meshgrid(min_dist_1d, min_dist_1d)\n    d_grid = np.sqrt(dist_x**2 + dist_y**2)\n\n    R_max = int(np.floor(np.sqrt(2) * N / 2))\n    r_indices = np.floor(d_grid).astype(int)\n    \n    # Bin C_t values by integer radius r.\n    total_C_in_bin = np.bincount(r_indices.ravel(), weights=C_t.ravel(), minlength=R_max + 1)\n    counts_in_bin = np.bincount(r_indices.ravel(), minlength=R_max + 1)\n    \n    # Avoid division by zero for empty shells.\n    c_t = np.zeros(R_max + 1)\n    non_empty_bins = counts_in_bin > 0\n    c_t[non_empty_bins] = total_C_in_bin[non_empty_bins] / counts_in_bin[non_empty_bins]\n\n    # 5. Calculate the correlation length L_t.\n    # Sum is from r=1 to R_max.\n    radii = np.arange(1, R_max + 1)\n    c_t_positive_part = np.maximum(c_t[1:], 0)\n    \n    numerator = np.sum(radii**2 * c_t_positive_part)\n    denominator = np.sum(c_t_positive_part)\n\n    if denominator > 0:\n        L_t = np.sqrt(numerator / denominator)\n    else:\n        L_t = 0.0\n\n    return L_t\n\ndef run_game_of_life(initial_state: np.ndarray, T: int):\n    \"\"\"\n    Simulates Conway's Game of Life for T steps.\n    Returns states at t=0, t=floor(T/2), and t=T.\n    \"\"\"\n    N = initial_state.shape[0]\n    times_to_capture = {0, T // 2, T}\n    captured_states = {}\n\n    grid = initial_state.astype(np.int8)\n    \n    if 0 in times_to_capture:\n        captured_states[0] = grid.copy()\n\n    # Kernel for neighbor sum calculation\n    kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]], dtype=np.int8)\n\n    for t in range(1, T + 1):\n        # Compute neighbor sum using circular convolution\n        neighbor_sum = convolve2d(grid, kernel, mode='same', boundary='wrap')\n        \n        # Apply Game of Life rules\n        # Condition for survival: live cell (grid==1) with 2 or 3 neighbors\n        survives = (grid == 1) & ((neighbor_sum == 2) | (neighbor_sum == 3))\n        # Condition for birth: dead cell (grid==0) with 3 neighbors\n        borns = (grid == 0) & (neighbor_sum == 3)\n        \n        grid = (survives | borns).astype(np.int8)\n        \n        if t in times_to_capture:\n            captured_states[t] = grid.copy()\n            \n    return [captured_states[t] for t in sorted(list(times_to_capture))]\n\n\ndef solve():\n    test_cases = [\n        {'type': 'bernoulli', 'N': 64, 'T': 128, 'p': 0.35, 'seed': 12345},\n        {'type': 'bernoulli', 'N': 64, 'T': 128, 'p': 0.05, 'seed': 2021},\n        {'type': 'bernoulli', 'N': 64, 'T': 128, 'p': 0.95, 'seed': 7},\n        {'type': 'structured', 'N': 32, 'T': 32},\n        {'type': 'all_dead', 'N': 32, 'T': 10},\n        {'type': 'all_alive', 'N': 32, 'T': 10}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N = case['N']\n        T = case['T']\n        \n        if case['type'] == 'bernoulli':\n            rng = np.random.default_rng(case['seed'])\n            initial_state = (rng.random(size=(N, N)) < case['p']).astype(np.int8)\n        elif case['type'] == 'structured':\n            initial_state = np.zeros((N, N), dtype=np.int8)\n            centers = [(8, 8), (16, 16), (24, 24)]\n            for r, c in centers:\n                initial_state[r, c-1] = 1\n                initial_state[r, c] = 1\n                initial_state[r, c+1] = 1\n        elif case['type'] == 'all_dead':\n            initial_state = np.zeros((N, N), dtype=np.int8)\n        elif case['type'] == 'all_alive':\n            initial_state = np.ones((N, N), dtype=np.int8)\n            \n        states_to_analyze = run_game_of_life(initial_state, T)\n        \n        case_results = []\n        for state in states_to_analyze:\n            L = calculate_correlation_length(state)\n            case_results.append(L)\n        \n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "2374590"}, {"introduction": "在掌握了分析单个信号内部结构的自相关之后，我们将转向研究两个不同信号之间关系的互相关。在自然科学和工程学中，我们常常需要理解一个系统如何响应外部输入，例如环境对刺激的反应。本练习 [@problem_id:2374653] 模拟了一个经典的水文物理系统，通过计算降雨量（输入）和河流径流量（输出）之间的互相关，来确定流域系统的特征响应时间。这是一个典型的实例，展示了如何利用互相关来揭示物理过程中的因果延迟和动态联系。", "problem": "您将实现一个完整、可运行的程序，通过计算降雨时间序列和生成的河流流量（径流）时间序列之间的离散互相关，来估算河流系统对降雨的特征响应时间。该程序必须从第一性原理出发构建信号，应用科学合理的预处理，并为每个测试用例确定一个单一的主导响应时间。所有计算都应以纯数学和算法术语表示，所有最终报告的时间必须以小时为单位，并保留两位小数。\n\n物理设置被建模为一个线性时不变 (LTI) 系统，其中流域通过一个因果脉冲响应将降雨转化为径流。使用离散时间，采样间隔为 $\\Delta t$ 小时，由 $n \\in \\{0,1,\\dots,N-1\\}$ 索引，时间为 $t_n = n \\Delta t$。降雨序列为 $r[n]$，流量序列为 $q[n]$。流量由与具有物理意义的因果脉冲响应 $h[k]$ 的离散时间卷积，加上一个可选的缓慢基线趋势 $b(t)$ 和一个小的确定性正弦扰动 $e(t)$ 生成：\n$$\nq[n] = \\Delta t \\sum_{m=0}^{n} h[m] \\, r[n-m] \\;+\\; b(t_n) \\;+\\; e(t_n).\n$$\n所有函数和参数均在下面明确给出；不存在随机性。\n\n您的程序必须：\n\n1. 构建 $r[n]$（降雨）作为不重叠矩形脉冲的和。每个脉冲由一个元组 $(t_{\\mathrm{start}}, T_{\\mathrm{dur}}, I)$ 指定，单位为小时和毫米/小时，表示\n   $$\n   r[n] \\leftarrow r[n] + I \\quad \\text{对于所有 } n \\text{ 使得 } t_{\\mathrm{start}} \\le n \\Delta t < t_{\\mathrm{dur}} + t_{\\mathrm{start}},\n   $$\n   并且 $r[n]$ 初始时在其他地方为 0。所有的 $t_{\\mathrm{start}}$ 和 $T_{\\mathrm{dur}}$ 都是 $\\Delta t$ 的精确倍数，且 $I \\ge 0$。\n\n2. 构建具有以下形式之一的因果脉冲响应 $h[k]$：\n   - 单一延迟指数：\n     $$\n     h[k] = \\begin{cases}\n     \\alpha \\, \\dfrac{1}{\\tau} \\exp\\!\\left(-\\dfrac{k \\Delta t - t_0}{\\tau}\\right), & k \\Delta t \\ge t_0,\\\\\n     0, & \\text{否则,}\n     \\end{cases}\n     $$\n     其中尺度 $\\alpha > 0$，延迟 $t_0 > 0$，时间常数 $\\tau > 0$。\n   - 权重 $\\{w_i\\}$ 之和为 1 的延迟指数混合：\n     $$\n     h[k] = \\sum_{i} \\begin{cases}\n     \\alpha \\, w_i \\, \\dfrac{1}{\\tau_i} \\exp\\!\\left(-\\dfrac{k \\Delta t - t_{0,i}}{\\tau_i}\\right), & k \\Delta t \\ge t_{0,i},\\\\\n     0, & \\text{否则。}\n     \\end{cases}\n     $$\n\n3. 根据每个用例的规定构建缓慢基线 $b(t)$ 和确定性正弦波 $e(t)$。对于基线，使用斜率为 $s$（单位：毫米/小时²）的线性函数 $b(t) = s \\, t$。对于正弦波，使用振幅为 $A$（单位：毫米/小时）、周期为 $P$（单位：小时）的 $e(t) = A \\sin\\!\\left( 2 \\pi \\, t / P \\right)$。\n\n4. 对 $r[n]$ 和 $q[n]$ 进行如下预处理：\n   - 分别从每个序列中移除最小二乘最佳拟合直线 $a t + b$（在整个记录上进行线性去趋势），得到去趋势后的序列 $\\tilde r[n]$ 和 $\\tilde q[n]$。\n   - 不要对数据进行其他滤波或平滑处理。\n\n5. 对于非负整数延迟 $\\ell \\in \\{0,1,2,\\dots,\\ell_{\\max}\\}$，计算 $\\tilde r[n]$ 和 $\\tilde q[n]$ 在延迟 $\\ell$ 处的离散、有限样本、归一化互相关，即在重叠索引 $\\{0,1,\\dots,N-\\ell-1\\}$ 上计算的皮尔逊相关系数。也就是说，对于每个 $\\ell$，考虑具有共同索引范围的配对 $\\{ (\\tilde r[n], \\tilde q[n+\\ell]) \\}$，并使用限制在这些重叠样本上的样本协方差和样本标准差的定义来计算相关系数。如果在某个延迟下任一序列的重叠标准差为零，则将该延迟下的相关性定义为零。\n\n6. 将特征响应时间 $T^\\star$ 定义为使归一化互相关最大化的非负时间延迟，即，令 $\\ell^\\star = \\arg\\max_{0 \\le \\ell \\le \\ell_{\\max}} \\rho_{\\tilde r, \\tilde q}[\\ell]$，并设 $T^\\star = \\ell^\\star \\Delta t$。\n\n7. 为每个测试用例报告 $T^\\star$，单位为小时，四舍五入到两位小数。\n\n您的程序必须实现上述步骤，并生成最终输出，为一行包含所有测试用例的 $T^\\star$ 值的列表，格式为方括号内的逗号分隔列表，例如，“[8.00,6.50,5.00,20.00]”。不得有额外的空格或文本。\n\n测试套件（四个用例）。对于每个用例，请完全按照规定构建数据：\n\n- 测试用例 1：\n  - 长度 $N = 256$，采样间隔 $\\Delta t = 1.0$ 小时。\n  - 降雨脉冲 $(t_{\\mathrm{start}}, T_{\\mathrm{dur}}, I)$，单位为小时和毫米/小时：$(20.0, 5.0, 10.0)$, $(100.0, 3.0, 6.0)$, $(170.0, 4.0, 8.0)$。\n  - 脉冲响应：单一延迟指数，其中 $t_0 = 8.0$ 小时, $\\tau = 6.0$ 小时, $\\alpha = 0.5$。\n  - 基线斜率 $s = 0.0$ 毫米/小时²，正弦波振幅 $A = 0.1$ 毫米/小时，正弦波周期 $P = 64.0$ 小时。\n  - 搜索延迟 $0 \\le \\ell \\le \\ell_{\\max}$，其中 $\\ell_{\\max}$ 对应 $60.0$ 小时（即 $\\ell_{\\max} = 60$ 个样本）。\n\n- 测试用例 2：\n  - 长度 $N = 300$，采样间隔 $\\Delta t = 0.5$ 小时。\n  - 降雨脉冲：$(20.0, 2.0, 5.0)$, $(50.0, 1.0, 8.0)$, $(90.0, 4.0, 6.0)$。\n  - 脉冲响应：单一延迟指数，其中 $t_0 = 6.0$ 小时, $\\tau = 3.0$ 小时, $\\alpha = 0.5$。\n  - 基线斜率 $s = 0.005$ 毫米/小时²，正弦波振幅 $A = 0.05$ 毫米/小时，正弦波周期 $P = 10.0$ 小时。\n  - 搜索延迟 $0 \\le \\ell \\le \\ell_{\\max}$，其中 $\\ell_{\\max}$ 对应 $40.0$ 小时（即 $\\ell_{\\max} = 80$ 个样本）。\n\n- 测试用例 3：\n  - 长度 $N = 256$，采样间隔 $\\Delta t = 1.0$ 小时。\n  - 降雨脉冲：$(30.0, 3.0, 12.0)$, $(60.0, 2.0, 9.0)$, $(200.0, 5.0, 7.0)$。\n  - 脉冲响应：包含两个分量的混合。权重 $w_1 = 0.7$, $w_2 = 0.3$，延迟 $t_{0,1} = 5.0$ 小时和 $t_{0,2} = 15.0$ 小时，时间常数 $\\tau_1 = 4.0$ 小时和 $\\tau_2 = 10.0$ 小时，总尺度 $\\alpha = 0.8$。\n  - 基线斜率 $s = 0.0$ 毫米/小时²，正弦波振幅 $A = 0.0$ 毫米/小时，正弦波周期 $P$ 任意（因为 $A=0$ 未使用）。\n  - 搜索延迟 $0 \\le \\ell \\le \\ell_{\\max}$，其中 $\\ell_{\\max}$ 对应 $50.0$ 小时（即 $\\ell_{\\max} = 50$ 个样本）。\n\n- 测试用例 4：\n  - 长度 $N = 128$，采样间隔 $\\Delta t = 1.0$ 小时。\n  - 降雨脉冲：$(10.0, 5.0, 10.0)$, $(60.0, 3.0, 8.0)$。\n  - 脉冲响应：单一延迟指数，其中 $t_0 = 20.0$ 小时, $\\tau = 8.0$ 小时, $\\alpha = 0.6$。\n  - 基线斜率 $s = 0.002$ 毫米/小时²，正弦波振幅 $A = 0.05$ 毫米/小时，正弦波周期 $P = 32.0$ 小时。\n  - 搜索延迟 $0 \\le \\ell \\le \\ell_{\\max}$，其中 $\\ell_{\\max}$ 对应 $40.0$ 小时（即 $\\ell_{\\max} = 40$ 个样本）。\n\n答案规格和单位：对于每个用例，计算 $T^\\star$（单位：小时）并四舍五入到两位小数。最终程序输出必须是单行，包含这四个值的列表，其格式严格为方括号内的逗号分隔列表（例如，\"[8.00,6.00,5.00,20.00]\"）。本问题不使用角度。在整个计算过程和最终输出中，统一使用小时作为时间单位。", "solution": "我们将降雨-径流转换建模为离散时间下的线性时不变 (LTI) 系统。设采样间隔为 $\\Delta t$ 小时，时间索引为 $n \\in \\{0,1,\\dots,N-1\\}$，时间为 $t_n = n \\Delta t$。降雨序列为 $r[n]$，流量序列 $q[n]$ 由与脉冲响应 $h[k]$ 的因果卷积加上低频基线 $b(t)$ 和小的确定性正弦波 $e(t)$ 生成：\n$$\nq[n] = \\Delta t \\sum_{m=0}^{n} h[m] \\, r[n-m] + b(t_n) + e(t_n).\n$$\n这是连续卷积 $q(t) = \\int_{0}^{\\infty} h(s) r(t-s) \\, ds$ 在步长为 $\\Delta t$ 的黎曼和近似下的离散对应形式。\n\n基本定义。在重叠段上，延迟为 $\\ell \\ge 0$ 的有限样本互协方差定义为\n$$\n\\operatorname{Cov}_{\\ell}(\\tilde r,\\tilde q) = \\frac{1}{M_{\\ell}} \\sum_{n=0}^{M_{\\ell}-1} \\left(\\tilde r[n] - \\overline{\\tilde r}_{\\ell}\\right) \\left(\\tilde q[n+\\ell] - \\overline{\\tilde q}_{\\ell}\\right),\n$$\n其中 $M_{\\ell} = N - \\ell$，$\\overline{\\tilde r}_{\\ell} = \\frac{1}{M_{\\ell}} \\sum_{n=0}^{M_{\\ell}-1} \\tilde r[n]$，且 $\\overline{\\tilde q}_{\\ell} = \\frac{1}{M_{\\ell}} \\sum_{n=0}^{M_{\\ell}-1} \\tilde q[n+\\ell]$。在重叠段上的相应样本标准差为\n$$\n\\sigma_{\\tilde r,\\ell} = \\sqrt{\\frac{1}{M_{\\ell}} \\sum_{n=0}^{M_{\\ell}-1} \\left(\\tilde r[n] - \\overline{\\tilde r}_{\\ell}\\right)^2}, \\quad\n\\sigma_{\\tilde q,\\ell} = \\sqrt{\\frac{1}{M_{\\ell}} \\sum_{n=0}^{M_{\\ell}-1} \\left(\\tilde q[n+\\ell] - \\overline{\\tilde q}_{\\ell}\\right)^2}.\n$$\n延迟为 $\\ell$ 的归一化互相关（皮尔逊相关系数）是\n$$\n\\rho_{\\tilde r,\\tilde q}[\\ell] =\n\\begin{cases}\n\\dfrac{\\operatorname{Cov}_{\\ell}(\\tilde r,\\tilde q)}{\\sigma_{\\tilde r,\\ell} \\, \\sigma_{\\tilde q,\\ell}}, & \\sigma_{\\tilde r,\\ell} > 0 \\text{ and } \\sigma_{\\tilde q,\\ell} > 0, \\\\\n0, & \\text{否则。}\n\\end{cases}\n$$\n\n通过线性去趋势进行预处理。因为水文流量通常包含缓慢的漂移（基流变化），而降雨序列可能根据事件定义而具有低频偏差，我们从每个序列的整个记录中移除最小二乘最佳拟合直线 $a t + b$，以形成 $\\tilde r[n]$ 和 $\\tilde q[n]$。对于一个时间向量为 $t_n = n \\Delta t$ 的序列 $x[n]$，最小二乘拟合求解\n$$\n\\min_{a,b} \\sum_{n=0}^{N-1} \\left(x[n] - (a t_n + b)\\right)^2,\n$$\n其闭式解源于正规方程，或可通过线性最小二乘法计算，然后我们定义 $\\tilde x[n] = x[n] - (a t_n + b)$。这移除了线性趋势并将数据大致中心化到零附近，从而稳定了相关性估计。\n\n为什么互相关峰值能给出响应时间。对于一个 LTI 系统，其中 $q = h * r$（因果卷积），输入 $r$ 和输出 $q$ 之间的互相关满足著名的关系（在 $r$ 是广义平稳的假设下）\n$$\nR_{rq}(\\tau) = \\int_{-\\infty}^{\\infty} r(t) \\, q(t+\\tau) \\, dt = \\int_{0}^{\\infty} h(s) \\, R_{rr}(\\tau - s) \\, ds = (h * R_{rr})(\\tau),\n$$\n即 $r$ 的自相关与脉冲响应 $h$ 的卷积。在离散时间下，类似的关系以求和形式成立。由于对于自相关从非零值开始衰减的信号（例如，有限脉冲，在短延迟之外近似不相关），$R_{rr}(\\tau)$ 通常在 $\\tau = 0$ 附近最大化，因此卷积 $(h * R_{rr})(\\tau)$ 在 $h$ 携带其最大质量的位置附近最大化。对于延迟指数 $h(t) \\propto u(t-t_0) \\exp(- (t-t_0)/\\tau)$，脉冲响应在 $t = t_0$ 处达到最大值，此后衰减。因此，$R_{rq}(\\tau)$ 的峰值在 $\\tau \\approx t_0$ 附近，相应的离散互相关系数 $\\rho_{\\tilde r,\\tilde q}[\\ell]$ 应该在最接近 $t_0/\\Delta t$ 的离散延迟附近最大化，前提是去趋势处理消除了低频偏差。对于指数混合，如果早期分量占主导，峰值则位于最大加权的早期延迟附近，这与主导快速路径对流量贡献最大的物理解释是一致的。\n\n算法设计。我们为每个用例遵循以下步骤：\n1. 根据指定的矩形脉冲构建 $r[n]$，方法是在 $t_{\\mathrm{start}} \\le n \\Delta t < t_{\\mathrm{start}} + T_{\\mathrm{dur}}$ 的索引范围内为每个脉冲加上指定的强度。\n2. 使用指定的参数和公式为单一延迟指数或混合形式构建 $h[k]$。\n3. 使用指定的 $s$、$A$ 和 $P$ 构建 $b(t) = s t$ 和 $e(t) = A \\sin(2 \\pi t / P)$。\n4. 计算 $q[n] = \\Delta t \\sum_{m=0}^{n} h[m] r[n-m] + b(t_n) + e(t_n)$，其中通过截断隐式地使 $m \\ge N$ 时 $h[m] = 0$。\n5. 通过移除整个记录的最小二乘最佳拟合直线，对 $r[n]$ 和 $q[n]$ 进行去趋势处理，得到 $\\tilde r[n]$ 和 $\\tilde q[n]$。\n6. 对于整数延迟 $0 \\le \\ell \\le \\ell_{\\max}$，使用样本协方差和标准差的定义，在重叠索引 $n \\in \\{0,\\dots,N-\\ell-1\\}$ 上计算 $\\rho_{\\tilde r,\\tilde q}[\\ell]$ 作为皮尔逊相关系数。如果某个延迟的任一标准差为零，则将该延迟的相关性定义为零。\n7. 找到 $\\ell^\\star = \\arg\\max_{0 \\le \\ell \\le \\ell_{\\max}} \\rho_{\\tilde r,\\tilde q}[\\ell]$，并计算 $T^\\star = \\ell^\\star \\Delta t$。\n8. 将每个 $T^\\star$ 四舍五入到两位小数，并以指定的单行列表格式输出这四个值。\n\n测试套件的预期定性结果：\n- 测试用例 1 使用单一延迟指数，其中 $t_0 = 8.0$ 小时，衰减适中 $\\tau = 6.0$ 小时。互相关峰值预计在 $T^\\star \\approx 8.0$ 小时附近。\n- 测试用例 2 的 $\\Delta t = 0.5$ 小时， $t_0 = 6.0$ 小时；由于基线斜率的存在，去趋势处理非常重要。互相关峰值预计在 $T^\\star \\approx 6.0$ 小时附近。\n- 测试用例 3 使用延迟为 $t_{0,1} = 5.0$ 小时和 $t_{0,2} = 15.0$ 小时的混合，权重为 $w_1 = 0.7$ 和 $w_2 = 0.3$。较早的路径占主导，因此峰值应在 $T^\\star \\approx 5.0$ 小时附近。\n- 测试用例 4 使用单一延迟指数，延迟较大 $t_0 = 20.0$ 小时；互相关峰值应出现在 $T^\\star \\approx 20.0$ 小时附近。\n\n该程序精确地实现了这些步骤，并以单个带括号、逗号分隔的列表形式打印计算出的 $T^\\star$ 值（单位：小时，每个值四舍五入到两位小数）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_rainfall(N, dt, pulses):\n    \"\"\"\n    Build rainfall r[n] as sum of rectangular pulses.\n    pulses: list of tuples (t_start_hours, duration_hours, intensity_mm_per_h),\n    all t_start and duration are multiples of dt.\n    \"\"\"\n    r = np.zeros(N, dtype=float)\n    for t_start, duration, intensity in pulses:\n        start_idx = int(round(t_start / dt))\n        width = int(round(duration / dt))\n        end_idx = start_idx + width\n        start_idx = max(0, start_idx)\n        end_idx = min(N, end_idx)\n        if end_idx > start_idx:\n            r[start_idx:end_idx] += intensity\n    return r\n\ndef build_kernel_single(N, dt, t0, tau, alpha):\n    \"\"\"\n    Single delayed exponential kernel: h[k] = alpha * (1/tau) * exp(-(k*dt - t0)/tau) for k*dt >= t0 else 0.\n    \"\"\"\n    k = np.arange(N, dtype=float)\n    t = k * dt\n    h = np.zeros(N, dtype=float)\n    mask = t >= t0\n    h[mask] = alpha * (1.0 / tau) * np.exp(-(t[mask] - t0) / tau)\n    return h\n\ndef build_kernel_mixture(N, dt, t0_list, tau_list, w_list, alpha):\n    \"\"\"\n    Mixture of delayed exponentials with weights summing to 1.\n    \"\"\"\n    k = np.arange(N, dtype=float)\n    t = k * dt\n    h = np.zeros(N, dtype=float)\n    for t0, tau, w in zip(t0_list, tau_list, w_list):\n        mask = t >= t0\n        contrib = np.zeros_like(h)\n        contrib[mask] = alpha * w * (1.0 / tau) * np.exp(-(t[mask] - t0) / tau)\n        h += contrib\n    return h\n\ndef add_baseline_and_noise(q, t, slope_s, amp_A, period_P):\n    \"\"\"\n    Add linear baseline b(t) = s * t and sinusoid e(t) = A * sin(2*pi*t/P) to q.\n    If amp_A == 0 or period_P <= 0, sinusoid is zero.\n    \"\"\"\n    baseline = slope_s * t\n    if amp_A != 0.0 and period_P > 0.0:\n        noise = amp_A * np.sin(2.0 * np.pi * t / period_P)\n    else:\n        noise = 0.0\n    return q + baseline + noise\n\ndef detrend_linear(x, t):\n    \"\"\"\n    Remove least-squares best-fit line a*t + b from x.\n    \"\"\"\n    # Design matrix with columns [t, 1]\n    A = np.vstack([t, np.ones_like(t)]).T\n    coeffs, _, _, _ = np.linalg.lstsq(A, x, rcond=None)\n    a, b = coeffs\n    trend = a * t + b\n    return x - trend\n\ndef normalized_cross_correlation(x, y, max_lag):\n    \"\"\"\n    Compute normalized cross-correlation (Pearson correlation) for lags 0..max_lag\n    using overlapping segments for each lag.\n    Returns array of length max_lag+1.\n    \"\"\"\n    N = len(x)\n    corrs = np.zeros(max_lag + 1, dtype=float)\n    for lag in range(max_lag + 1):\n        # overlapping indices: x[0:N-lag], y[lag:N]\n        x_seg = x[:N - lag]\n        y_seg = y[lag:]\n        # Compute means over overlapping segments\n        x_mean = x_seg.mean()\n        y_mean = y_seg.mean()\n        x0 = x_seg - x_mean\n        y0 = y_seg - y_mean\n        x_energy = np.dot(x0, x0)\n        y_energy = np.dot(y0, y0)\n        denom = np.sqrt(x_energy * y_energy)\n        if denom > 0:\n            corrs[lag] = float(np.dot(x0, y0) / denom)\n        else:\n            corrs[lag] = 0.0\n    return corrs\n\ndef characteristic_response_time(r, q, dt, max_lag_hours):\n    \"\"\"\n    Detrend r and q, compute normalized cross-correlation up to max_lag_hours,\n    and return T* (in hours) corresponding to the maximizing lag.\n    \"\"\"\n    N = len(r)\n    t = np.arange(N, dtype=float) * dt\n    # Detrend each series\n    r_d = detrend_linear(r, t)\n    q_d = detrend_linear(q, t)\n    # Compute correlations up to specified max lag\n    max_lag_samples = int(round(max_lag_hours / dt))\n    max_lag_samples = min(max_lag_samples, N - 1 if N > 0 else 0)\n    corrs = normalized_cross_correlation(r_d, q_d, max_lag_samples)\n    best_lag = int(np.argmax(corrs))\n    T_star = best_lag * dt\n    return T_star\n\ndef generate_case(case):\n    \"\"\"\n    Generate rainfall r and discharge q for a given case specification dictionary.\n    \"\"\"\n    N = case[\"N\"]\n    dt = case[\"dt\"]\n    pulses = case[\"pulses\"]\n    kernel_type = case[\"kernel_type\"]\n    # Build rainfall\n    r = build_rainfall(N, dt, pulses)\n    # Build kernel\n    if kernel_type == \"single\":\n        h = build_kernel_single(\n            N, dt,\n            t0=case[\"t0\"],\n            tau=case[\"tau\"],\n            alpha=case[\"alpha\"]\n        )\n    elif kernel_type == \"mixture\":\n        h = build_kernel_mixture(\n            N, dt,\n            t0_list=case[\"t0_list\"],\n            tau_list=case[\"tau_list\"],\n            w_list=case[\"w_list\"],\n            alpha=case[\"alpha\"]\n        )\n    else:\n        raise ValueError(\"Unknown kernel_type\")\n    # Convolution to get q (truncate to length N)\n    q_conv = np.convolve(r, h)[:N] * dt\n    # Add baseline and deterministic sinusoid\n    t = np.arange(N, dtype=float) * dt\n    q = add_baseline_and_noise(\n        q_conv, t,\n        slope_s=case[\"baseline_slope\"],\n        amp_A=case[\"noise_amp\"],\n        period_P=case[\"noise_period\"]\n    )\n    return r, q\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case1\",\n            \"N\": 256,\n            \"dt\": 1.0,\n            \"pulses\": [(20.0, 5.0, 10.0), (100.0, 3.0, 6.0), (170.0, 4.0, 8.0)],\n            \"kernel_type\": \"single\",\n            \"t0\": 8.0, \"tau\": 6.0, \"alpha\": 0.5,\n            \"baseline_slope\": 0.0,\n            \"noise_amp\": 0.1, \"noise_period\": 64.0,\n            \"max_lag_hours\": 60.0\n        },\n        {\n            \"name\": \"Case2\",\n            \"N\": 300,\n            \"dt\": 0.5,\n            \"pulses\": [(20.0, 2.0, 5.0), (50.0, 1.0, 8.0), (90.0, 4.0, 6.0)],\n            \"kernel_type\": \"single\",\n            \"t0\": 6.0, \"tau\": 3.0, \"alpha\": 0.5,\n            \"baseline_slope\": 0.005,\n            \"noise_amp\": 0.05, \"noise_period\": 10.0,\n            \"max_lag_hours\": 40.0\n        },\n        {\n            \"name\": \"Case3\",\n            \"N\": 256,\n            \"dt\": 1.0,\n            \"pulses\": [(30.0, 3.0, 12.0), (60.0, 2.0, 9.0), (200.0, 5.0, 7.0)],\n            \"kernel_type\": \"mixture\",\n            \"t0_list\": [5.0, 15.0],\n            \"tau_list\": [4.0, 10.0],\n            \"w_list\": [0.7, 0.3],\n            \"alpha\": 0.8,\n            \"baseline_slope\": 0.0,\n            \"noise_amp\": 0.0, \"noise_period\": 1.0,\n            \"max_lag_hours\": 50.0\n        },\n        {\n            \"name\": \"Case4\",\n            \"N\": 128,\n            \"dt\": 1.0,\n            \"pulses\": [(10.0, 5.0, 10.0), (60.0, 3.0, 8.0)],\n            \"kernel_type\": \"single\",\n            \"t0\": 20.0, \"tau\": 8.0, \"alpha\": 0.6,\n            \"baseline_slope\": 0.002,\n            \"noise_amp\": 0.05, \"noise_period\": 32.0,\n            \"max_lag_hours\": 40.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        r, q = generate_case(case)\n        T_star = characteristic_response_time(\n            r, q,\n            dt=case[\"dt\"],\n            max_lag_hours=case[\"max_lag_hours\"]\n        )\n        results.append(T_star)\n\n    # Final print statement in the exact required format: list with two decimals.\n    print(f\"[{','.join(f'{v:.2f}' for v in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2374653"}]}