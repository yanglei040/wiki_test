{"hands_on_practices": [{"introduction": "我们常常在电影或视频中看到车轮飞速旋转时似乎变慢甚至倒转的现象，这就是著名的“马车轮效应”。这其实是时间混叠(temporal aliasing)的一个经典例子。这个动手实践将此直观现象形式化：通过构建一个简单的模型，输入车轮的真实旋转频率 $f_{\\text{rot}}$ 和摄像机的帧率 $f_{\\text{fps}}$，我们将能够精确地计算出人眼最终感知到的旋转频率和方向。这个练习旨在通过将数学原理与我们熟悉的视觉体验联系起来，为你建立关于混叠的直观理解 [@problem_id:2373299]。", "problem": "要求您将时间混叠（“车轮效应”）建模为一个旋转相位的采样问题。考虑一个刚性轮，其轮缘上有一个可区分的标记，以恒定的旋转频率 $f_{rot}$ （单位为赫兹，即周/秒）旋转。一台理想相机以赫兹为单位的帧率 $f_{fps}$ 在均匀的时间间隔内对轮子的状态进行采样，曝光为瞬时过程（无运动模糊）。标记的角相位为 $\\phi(t) = 2\\pi f_{rot} t + \\phi_0$，不失一般性，设 $\\phi_0 = 0$。设采样时间为 $t_n = n/f_{fps}$，其中 $n$ 为整数。帧间相位增量为 $\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n)$，此增量对所有 $n$ 均相同。\n\n假设人类感知系统会选择与采样图像一致的最小幅度的帧间变化，即与 $\\Delta \\phi$ 模 $2\\pi$ 同余且位于区间 $(-\\pi, \\pi]$ 内的唯一代表 $\\Delta \\phi^{*}$。将感知到的连续时间旋转频率（以赫兹为单位）定义为 $f_{perc} = \\dfrac{f_{fps}}{2\\pi}\\,|\\Delta \\phi^{*}|$，并将感知到的方向定义为整数 $s \\in \\{-1, 0, +1\\}$，由 $s = \\operatorname{sgn}(\\Delta \\phi^{*})$ 给出，约定当 $f_{perc}$ 恰好为 0 时，$s = 0$。此约定通过取 $\\Delta \\phi^{*} = +\\pi$ 来确定性地解决 $\\Delta \\phi \\equiv \\pi \\pmod{2\\pi}$ 的边界情况。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n- 对于下面的每个测试用例，将 $f_{rot}$ 和 $f_{fps}$ （均以赫兹为单位）作为输入。\n- 仅使用上述原理和定义，计算感知频率 $f_{perc}$ （以赫兹为单位）和感知方向 $s$。\n- 将 $f_{perc}$ （以赫兹为单位）表示为四舍五入到 $6$ 位小数的数值。\n- 对于每个测试用例，返回一个形式为 $[f_{perc}, s]$ 的列表。\n\n物理单位：所有频率必须以赫兹 (Hz) 表示。角度在内部以弧度处理。方向必须是整数 $-1$、$0$ 或 $+1$。将 $f_{perc}$ 四舍五入到 6 位小数。\n\n参数值的测试套件（包括正常路径、边缘和边界情况），每组均以 $(f_{rot}, f_{fps})$ （单位为赫兹）的形式给出：\n- 情况 $1$：$(2.3,\\, 24.0)$\n- 情况 $2$：$(23.0,\\, 24.0)$\n- 情况 $3$：$(12.0,\\, 24.0)$\n- 情况 $4$：$(48.0,\\, 24.0)$\n- 情况 $5$：$(-1.2,\\, 24.0)$\n- 情况 $6$：$(103.0,\\, 24.0)$\n- 情况 $7$：$(0.49,\\, 24.0)$\n- 情况 $8$：$(31.0,\\, 30.0)$\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个元素本身是针对一个测试用例的列表 $[f_{perc}, s]$，其中 $f_{perc}$ 是一个精确到 6 位小数的浮点数，$s$ 是一个整数。例如，整体结构必须类似于 $[[f_1, s_1],[f_2, s_2],\\ldots]$，并采用指定的数字格式，例如 $[[2.300000,1],[1.000000,-1],\\ldots]$。不应打印任何额外文本。", "solution": "问题陈述已经过严格的验证过程。\n\n已知条件如下：\n- 旋转轮上标记的角相位：$\\phi(t) = 2\\pi f_{rot} t$，其中 $f_{rot}$ 是以赫兹为单位的旋转频率。\n- 帧率为 $f_{fps}$ 的相机的采样时间：$t_n = n/f_{fps}$，其中整数 $n \\ge 0$。\n- 帧间相位增量：$\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n)$。\n- 感知相位增量 $\\Delta \\phi^{*}$ 是 $\\Delta \\phi$ 模 $2\\pi$ 同余的唯一代表，使得 $\\Delta \\phi^{*} \\in (-\\pi, \\pi]$。\n- 感知频率: $f_{perc} = \\dfrac{f_{fps}}{2\\pi}\\,|\\Delta \\phi^{*}|$。\n- 感知方向: $s = \\operatorname{sgn}(\\Delta \\phi^{*})$，当 $\\Delta \\phi^{*} = 0$ 时 $s=0$。\n\n验证证实该问题具有科学依据、是适定的且客观的。它基于信号采样理论的基本原理，为时间混叠现象提供了一个清晰、形式化的模型。所有术语均有明确定义，所需的计算在数学上是合理的，并能得出唯一解。因此，该问题被视为有效，并按如下方式推导解决方案。\n\n分析首先推导帧间相位增量 $\\Delta \\phi$。将相位 $\\phi(t)$ 和采样时间 $t_n$ 的表达式代入 $\\Delta \\phi$ 的定义中：\n$$\n\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n) = 2\\pi f_{rot} \\left(\\frac{n+1}{f_{fps}}\\right) - 2\\pi f_{rot} \\left(\\frac{n}{f_{fps}}\\right)\n$$\n化简该表达式可得一个恒定的相位增量：\n$$\n\\Delta \\phi = 2\\pi f_{rot} \\left(\\frac{n+1-n}{f_{fps}}\\right) = 2\\pi \\frac{f_{rot}}{f_{fps}}\n$$\n问题的核心在于感知模型，该模型将真实相位增量 $\\Delta \\phi$ 映射到其感知对应值 $\\Delta \\phi^{*}$。这是一个数学上的环绕操作。我们必须找到一个整数 $k$，代表在感知上被舍弃的完整 $2\\pi$ 旋转的圈数，使得：\n$$\n\\Delta \\phi^{*} = \\Delta \\phi - 2\\pi k\n$$\n且 $\\Delta \\phi^{*}$ 落在指定的主区间 $(-\\pi, \\pi]$ 内。\n\n为了系统地找到 $k$，我们可以使用归一化的频率和相位。令 $x$ 为旋转频率与采样频率之比：\n$$\nx = \\frac{f_{rot}}{f_{fps}}\n$$\n归一化的相位增量为 $\\frac{\\Delta \\phi}{2\\pi} = x$。我们寻求一个归一化的感知相位增量 $p = \\frac{\\Delta \\phi^{*}}{2\\pi}$，使得对于某个整数 $k$，有 $p = x - k$ 且 $p \\in (-0.5, 0.5]$。\n关于 $p$ 的这个不等式可以用 $x$ 和 $k$ 重写为：\n$$\n-0.5 < x - k \\le 0.5\n$$\n对 $k$ 进行整理可得条件：\n$$\nx - 0.5 \\le k < x + 0.5\n$$\n对于任何实数 $x$，满足此条件的唯一整数 $k$ 由上取整函数（ceiling function）给出：\n$$\nk = \\lceil x - 0.5 \\rceil\n$$\n确定 $k$ 后，归一化的感知相位增量 $p$ 可计算为 $p = x - k$。\n\n感知频率 $f_{perc}$ 定义为 $f_{perc} = \\frac{f_{fps}}{2\\pi} |\\Delta \\phi^{*}|$。代入 $\\Delta \\phi^{*} = 2\\pi p$：\n$$\nf_{perc} = \\frac{f_{fps}}{2\\pi} |2\\pi p| = f_{fps} |p| = f_{fps} \\left| \\frac{f_{rot}}{f_{fps}} - k \\right|\n$$\n感知方向 $s$ 是感知相位增量的符号：\n$$\ns = \\operatorname{sgn}(\\Delta \\phi^{*}) = \\operatorname{sgn}(2\\pi p) = \\operatorname{sgn}(p)\n$$\n按照约定，$\\operatorname{sgn}(0) = 0$，这能正确处理感知图像静止（$f_{perc} = 0$）的情况。\n\n对于给定的一对 $(f_{rot}, f_{fps})$，完整的计算算法如下：\n$1$. 计算频率比 $x = f_{rot} / f_{fps}$。\n$2$. 确定要减去的完整旋转圈数的整数值 $k = \\lceil x - 0.5 \\rceil$。\n$3$. 计算归一化的感知相位增量 $p = x - k$。\n$4$. 计算感知频率 $f_{perc} = f_{fps} |p|$。\n$5$. 确定感知方向 $s = \\operatorname{sgn}(p)$。\n$6$. 将 $f_{perc}$ 四舍五入到 6 位小数，并返回数对 $[f_{perc}, s]$。\n现在实现此算法以解决所提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the perceived frequency and direction of a rotating object\n    subject to temporal aliasing, based on the wagon-wheel effect model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (f_rot, f_fps) in hertz.\n    test_cases = [\n        (2.3, 24.0),     # Case 1\n        (23.0, 24.0),    # Case 2\n        (12.0, 24.0),    # Case 3\n        (48.0, 24.0),    # Case 4\n        (-1.2, 24.0),    # Case 5\n        (103.0, 24.0),   # Case 6\n        (0.49, 24.0),    # Case 7\n        (31.0, 30.0),    # Case 8\n    ]\n\n    # A list to store the string-formatted results for each case.\n    results_str_list = []\n\n    for case in test_cases:\n        f_rot, f_fps = case\n\n        # Step 1: Calculate the frequency ratio x.\n        # This represents the number of rotations per sample period.\n        x = f_rot / f_fps\n\n        # Step 2: Determine the integer number of full rotations k to subtract.\n        # The logic k = ceil(x - 0.5) ensures that the remainder p = x - k\n        # falls into the interval (-0.5, 0.5], which corresponds to a\n        # phase increment in (-pi, pi].\n        k = np.ceil(x - 0.5)\n\n        # Step 3: Compute the normalized perceived phase increment p.\n        p = x - k\n\n        # Step 4: Calculate the perceived frequency f_perc.\n        # This is the magnitude of the perceived rotation rate.\n        f_perc = f_fps * np.abs(p)\n\n        # Step 5: Determine the perceived direction s.\n        # This is the sign of the perceived phase increment.\n        # np.sign(0) correctly returns 0.\n        s = int(np.sign(p))\n\n        # Step 6: Format the result for the current case as a string '[f_perc,s]'\n        # f_perc is formatted to exactly 6 decimal places.\n        case_result_str = f\"[{f_perc:.6f},{s}]\"\n        results_str_list.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    # The final output is a single line: a list of lists.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```", "id": "2373299"}, {"introduction": "“莫列波纹”是空间混叠(spatial aliasing)的体现，好比是空间维度上的“马车轮效应”，常见于用数码相机拍摄电脑屏幕或密织物时。这个练习将我们的视野从一维时间域扩展到二维空间域。我们将创建一个具有精细图案（即高空间频率）的合成图像，然后通过对它进行降采样来模拟分辨率降低的过程，并观察那些原本不存在的、虚假的低频莫列图案是如何产生的。这个实践不仅巩固了混叠的核心概念，还引入了二维傅里叶变换作为诊断工具 [@problem_id:2373273]。", "problem": "您将编写一个完整且可运行的程序，使用合成图像来演示和量化二维空间中的混叠和奈奎斯特准则。您必须从核心定义出发：通过空间格点对连续场进行采样、将离散傅里叶变换 (DFT) 作为该格点上复指数的投影、以及采样会在频率空间中复制频谱这一公认的观察结果。您不得在问题陈述中假设任何预先推导的混叠快捷方式；相反，您需要从这些基础出发，推断降采样后观察到的混叠空间频率是如何产生的。\n\n构建一个形式如下的二维合成余弦“织物”图案\n$$\nI(x,y) = \\cos\\!\\big( 2\\pi \\big( f_x x + f_y y \\big) \\big),\n$$\n其中 $x$ 和 $y$ 是索引高分辨率像素网格的整数，而 $(f_x,f_y)$ 是相对于此高分辨率网格以“周期/像素”表示的空间频率向量。使用边长为 $M$ 像素的方形图像，其中 $M = 1024$。假设底层的连续场已经是带限的，因此对于给定的 $(f_x,f_y)$，其在该高分辨率网格上的采样是有效的。\n\n然后，您将通过沿两个轴每隔 $N$ 个样本保留一个样本的方式，对图像进行整数因子 $N$ 的降采样（抽取）。这对应于一个新的采样格点，其在两个方向上的间距都扩大了 $N$ 倍。设降采样后图像的维度为 Python 中步长为 $N$ 的切片所隐含的维度。\n\n从第一性原理出发，使用上述定义来推断高分辨率网格上的空间频率为 $(f_x,f_y)$ 的正弦波，在经过 $N$ 倍降采样后，当以降采样网格的单位（周期/降采样像素）表示时，将如何呈现。特别地，需要展示观察到的频率必须如何折叠到较低采样率所支持的基带内，这与奈奎斯特准则一致，该准则要求每个分量都位于以零为中心、宽度为一个“周期/样本”的区间内。您的实现必须：\n- 为每个测试用例构建高分辨率图像 $I(x,y)$。\n- 在 $x$ 和 $y$ 方向上每隔 $N$ 个像素保留一个，从而对其进行降采样。\n- 通过以下方式估算降采样后图像的主导空间频率幅值（以“周期/降采样像素”为单位）：\n  - 计算二维 DFT（通过快速傅里叶变换）。\n  - 定位幅度最大的非零谱峰。\n  - 使用标准 DFT 频率网格将其索引转换为物理频率。\n- 通过将降采样所隐含的缩放频率向量折叠到降采样网格所支持的奈奎斯特区间内，独立计算理论上预测的混叠空间频率幅值（以“周期/降采样像素”为单位）。\n- 对于每个测试用例，计算估算幅值与理论预测幅值之间的绝对差，结果为一个浮点数。\n\n所有空间频率均以“周期/像素”表示，不要使用任何物理单位。角度（若有）必须解释为弧度，但本问题不要求您使用或报告任何角度。所有数值答案必须报告为 Python 浮点数，不带任何百分号。\n\n测试套件：\n使用 $M = 1024$ 和以下 7 个测试用例，每个用例指定为 $(N,f_x,f_y)$，所有频率单位均为“周期/高分辨率像素”：\n- 用例 1：$(N,f_x,f_y) = (\\,3,\\,0.12,\\,0.00\\,)$\n- 用例 2：$(N,f_x,f_y) = (\\,4,\\,0.125,\\,0.00\\,)$\n- 用例 3：$(N,f_x,f_y) = (\\,5,\\,0.11,\\,0.00\\,)$\n- 用例 4：$(N,f_x,f_y) = (\\,3,\\,0.14,\\,0.10\\,)$\n- 用例 5：$(N,f_x,f_y) = (\\,4,\\,0.249,\\,0.001\\,)$\n- 用例 6：$(N,f_x,f_y) = (\\,7,\\,0.09,\\,0.085\\,)$\n- 用例 7：$(N,f_x,f_y) = (\\,6,\\,0.00,\\,0.09\\,)$\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个 Python 风格的包含 7 个浮点数的列表，每个浮点数是相应测试用例的绝对误差（估算幅值减去理论幅值的绝对值），顺序与上面相同。例如：\n$[e_1,e_2,\\dots,e_7]$ \n其中每个 $e_i$ 是一个浮点数。\n\n程序必须无需任何输入、外部文件或网络访问即可按原样运行，并且只能使用标准库加上指定的数值库。所有计算必须使用上述指定的单位（周期/像素）进行。程序打印的最后一行必须是且仅是结果列表。", "solution": "该问题陈述是有效的。它具有科学依据、问题适定、客观，并包含了获得唯一且有意义解所需的所有信息。它描述了在计算物理学中用于演示混叠现象的一个标准、可验证的过程。我将从第一性原理出发推导解决方案。\n\n分析始于提供的高分辨率合成图像，该图像定义在一个整数坐标 $(x,y)$ 的离散网格上，其中 $x, y \\in \\{0, 1, \\dots, M-1\\}$ 且 $M=1024$。强度函数由下式给出\n$$\nI(x,y) = \\cos\\!\\big( 2\\pi \\big( f_x x + f_y y \\big) \\big)\n$$\n在这里，$(f_x, f_y)$ 代表空间频率向量，单位为“周期/高分辨率像素”。此公式意味着底层的连续场已在两个维度上以单位像素间距对应的速率进行采样。此高分辨率网格的奈奎斯特频率是 0.5 周期/像素。问题规定，给定的频率 $(f_x, f_y)$ 在此初始网格的非混叠范围内。\n\n问题的核心在于抽取过程，即高分辨率图像 $I(x,y)$ 被一个整数因子 $N$ 降采样。一个新的、更粗糙的网格由整数坐标 $(x',y')$ 构建。坐标系之间的关系是 $x = N x'$ 和 $y = N y'$。降采样后的图像 $I_D(x',y')$ 是通过在这些新网格点上从 $I(x,y)$ 中取样形成的：\n$$\nI_D(x', y') = I(N x', N y') = \\cos\\!\\big( 2\\pi \\big( f_x (N x') + f_y (N y') \\big) \\big)\n$$\n这个表达式可以重组，以揭示降采样网格上的新的有效空间频率：\n$$\nI_D(x', y') = \\cos\\!\\big( 2\\pi \\big( (N f_x) x' + (N f_y) y' \\big) \\big)\n$$\n设新的频率向量（以“周期/降采样像素”为单位）为 $(f'_x, f'_y)$。从上面的方程，我们得到：\n$$\nf'_x = N f_x \\quad \\text{and} \\quad f'_y = N f_y\n$$\n这个向量 $(f'_x, f'_y)$ 代表了新网格上正弦图案的真实频率。然而，这不一定是将被观察到的频率。离散网格的性质对可以被唯一表示的频率范围施加了基本限制。\n\n根据离散采样理论，采样信号的频谱是周期性的。采样过程会创建连续信号频谱的无限多个副本，这些副本按采样频率的整数倍进行平移。在我们的归一化单位中，每个维度的采样频率是 1 周期/像素。因此，频率分量 $f'$ 与 $f' + k$ 对于任何整数 $k$ 都是不可区分的。离散信号的观察者只能感知到落入一个已定义的主范围内的频率分量，这个主范围通常是宽度为 1、以零为中心的基带。这种现象就是混叠。奈奎斯特准则规定，为了无混叠地采样信号，其频率分量必须严格位于此基带内。\n\n主混叠，或观察到的频率分量，是通过将真实频率“折叠”到奈奎斯特区间 $[-0.5, 0.5)$ 中找到的。对于任何给定的频率 $f'$，观察到的混叠频率 $f'_a$ 是此区间中唯一的值，使得 $f' - f'_a$ 是一个整数。这可以通过从 $f'$ 中减去最接近它的整数来计算。一个执行此映射的稳健公式是：\n$$\nf'_a = (f' + 0.5) \\pmod 1 - 0.5\n$$\n其中取模运算的结果应在 $[0, 1)$ 区间内。将此应用于我们的二维频率向量 $(f'_x, f'_y)$，我们得到理论上预测的混叠频率向量 $(f'_{x,a}, f'_{y,a})$：\n$$\nf'_{x,a} = ((N f_x) + 0.5) \\pmod 1 - 0.5\n$$\n$$\nf'_{y,a} = ((N f_y) + 0.5) \\pmod 1 - 0.5\n$$\n因此，理论上预测的混叠频率的幅值为：\n$$\n|f'_a|_{theory} = \\sqrt{(f'_{x,a})^2 + (f'_{y,a})^2}\n$$\n\n为了验证这个理论预测，我们必须从降采样图像 $I_D$ 中数值化地估计频率。这是通过使用二维离散傅里叶变换 (DFT) 实现的，该变换通过快速傅里叶变换 (FFT) 算法完成。DFT 将图像投影到复指数函数基上，揭示其频谱内容。对于大小为 $M_{Dy} \\times M_{Dx}$ 的图像，DFT 产生一个复数值矩阵，其中每个元素 $(k_y, k_x)$ 对应于一个离散频率 $(k_y/M_{Dy}, k_x/M_{Dx})$。\n\n由于输入图像 $I_D(x',y')$ 是一个纯余弦波，其 DFT 理想情况下将由位于正负混叠频率 $(\\pm f'_{x,a}, \\pm f'_{y,a})$ 处的两个脉冲（狄拉克δ函数）组成。在有限网格上，由于谱泄漏，这些脉冲会展宽成窄峰，但它们的最大幅值将位于真实频率处或其附近。\n\n数值估算过程如下：\n1.  计算降采样图像 $I_D$ 的二维 FFT：$F_D = \\text{FFT2}(I_D)$。\n2.  将零频分量移至频谱中心，以便于解释：$F_{D, \\text{shifted}} = \\text{fftshift}(F_D)$。\n3.  计算复数频谱的幅值：$|F_{D, \\text{shifted}}|$。\n4.  问题要求的是主导的非零频率。因此，我们通过将其幅值设为零来忽略零频处的峰值（直流分量）。\n5.  定位与平移后频谱中剩余的最大幅值对应的索引 $(k_{y, \\text{peak}}, k_{x, \\text{peak}})$。\n6.  使用标准的 DFT 频率网格将这些整数索引转换为物理频率，该网格也已平移至以零为中心。估算的频率为 $(f_{x, \\text{est}}, f_{y, \\text{est}})$。\n7.  然后，估算的频率幅值为 $|f'|_{est} = \\sqrt{(f_{x, \\text{est}})^2 + (f_{y, \\text{est}})^2}$。\n\n最后，对于每个测试用例，我们计算绝对误差 $\\epsilon = \\big| |f'|_{est} - |f'_a|_{theory} \\big|$。这个误差量化了来自 FFT 的实验测量值与理论预测值之间的差异，该差异应接近于零，仅受限于浮点运算的有限精度和 DFT 频率网格的离散性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the aliasing problem by comparing theoretical predictions with\n    numerical estimates from FFT analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, f_x, f_y)\n    test_cases = [\n        (3, 0.12, 0.00),\n        (4, 0.125, 0.00),\n        (5, 0.11, 0.00),\n        (3, 0.14, 0.10),\n        (4, 0.249, 0.001),\n        (7, 0.09, 0.085),\n        (6, 0.00, 0.09),\n    ]\n\n    results = []\n    M = 1024  # High-resolution image side length\n\n    for N, fx, fy in test_cases:\n        # --- Theoretical Calculation ---\n        # 1. Scale original frequencies by the decimation factor N.\n        # These are the frequencies in units of cycles/downsampled_pixel.\n        f_prime_x = N * fx\n        f_prime_y = N * fy\n\n        # 2. Fold the frequencies into the Nyquist interval [-0.5, 0.5).\n        # This gives the expected aliased frequencies.\n        # The formula (f + 0.5) % 1.0 - 0.5 correctly maps f to [-0.5, 0.5).\n        f_alias_x = (f_prime_x + 0.5) % 1.0 - 0.5\n        f_alias_y = (f_prime_y + 0.5) % 1.0 - 0.5\n        \n        # 3. Calculate the magnitude of the theoretical aliased frequency vector.\n        mag_theory = np.sqrt(f_alias_x**2 + f_alias_y**2)\n\n        # --- Numerical Estimation ---\n        # 1. Create the high-resolution image.\n        x = np.arange(M)\n        y = np.arange(M)\n        xx, yy = np.meshgrid(x, y)\n        I_high_res = np.cos(2 * np.pi * (fx * xx + fy * yy))\n\n        # 2. Downsample the image by decimation factor N.\n        I_downsampled = I_high_res[::N, ::N]\n        M_dy, M_dx = I_downsampled.shape\n\n        # 3. Compute the 2D FFT of the downsampled image.\n        F_downsampled = np.fft.fft2(I_downsampled)\n\n        # 4. Shift the zero-frequency component to the center and get magnitudes.\n        F_shifted = np.fft.fftshift(F_downsampled)\n        abs_F_shifted = np.abs(F_shifted)\n\n        # 5. Locate the peak frequency, ignoring the DC component at the center.\n        # Find center indices for the shifted spectrum.\n        center_y, center_x = M_dy // 2, M_dx // 2\n        \n        # Set the DC component magnitude to zero to exclude it from the search.\n        abs_F_shifted[center_y, center_x] = 0.0\n\n        # Find the indices of the largest non-zero magnitude peak.\n        ky_idx, kx_idx = np.unravel_index(np.argmax(abs_F_shifted), abs_F_shifted.shape)\n\n        # 6. Convert peak indices to physical frequencies (cycles/downsampled_pixel).\n        # Generate the frequency grids corresponding to the shifted FFT output.\n        freq_x_axis = np.fft.fftshift(np.fft.fftfreq(M_dx))\n        freq_y_axis = np.fft.fftshift(np.fft.fftfreq(M_dy))\n\n        f_est_x = freq_x_axis[kx_idx]\n        f_est_y = freq_y_axis[ky_idx]\n\n        # 7. Calculate the magnitude of the estimated frequency vector.\n        mag_est = np.sqrt(f_est_x**2 + f_est_y**2)\n\n        # --- Final Calculation ---\n        # Compute the absolute error between theoretical and estimated magnitudes.\n        error = np.abs(mag_est - mag_theory)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2373273"}, {"introduction": "在了解了混叠如何产生视觉假象后，下一个关键问题是：我们该如何避免它？在处理真实世界的信号时，我们常常需要降低采样率以节省存储或计算资源，这个过程称为“降采样”(downsampling)，但它也带来了混叠的风险。这个练习将对比两种处理流程的优劣：“先降采样后滤波”与“先滤波后降采样”。你将通过编程量化地证明，在降采样之前施加一个低通“抗混叠滤波器”是多么关键，这是保证信号保真度的核心操作，也是所有实验和计算科学领域中的一项重要技能 [@problem_id:2373295]。", "problem": "一个离散时间信号由持续时间有限、均匀采样的余弦和构成，并对其应用两种处理顺序：先低通滤波后降采样，以及先降采样后低通滤波。任务是量化运算顺序对最终频谱的影响，为此将使用一个在离散傅里叶变换 (DFT) 网格上定义的数学理想低通滤波器。此问题涉及计算物理学中的混叠和奈奎斯特准则。\n\n给定采样频率 $F_{s}$（单位：赫兹/Hz）、持续时间 $T$（单位：秒/s）以及一组幅值 $A_{i}$（无量纲）和频率 $f_{i}$（单位：赫兹/Hz）的音调分量 $\\{(A_{i}, f_{i})\\}$，定义连续时间信号\n$$\ns(t) = \\sum_{i} A_{i}\\cos\\!\\big(2\\pi f_{i} t\\big),\n$$\n以及在持续时间 $T$ 内以 $F_{s}$ 采样的离散时间信号\n$$\nx[n] = s\\!\\left(\\frac{n}{F_{s}}\\right), \\quad n=0,1,\\dots,N-1, \\quad N = \\lfloor F_{s} T \\rfloor.\n$$\n设 $M$ 为一个正整数降采样因子。定义降采样后的新采样频率为 $F_{s}^{(\\downarrow)} = F_{s}/M$，以及对应的新奈奎斯特频率为 $F_{\\mathrm{N,new}} = \\frac{F_{s}}{2M}$（单位：赫兹/Hz）。\n\n在 DFT 网格上定义一个理想低通滤波器 $H$，如下所示。对于一个长度为 $L$ 的序列 $u[n]$，设 $U[k]$ 为其 $L$ 点 DFT，其频率仓中心频率（单位：赫兹/Hz）由 $f_{k} = \\frac{k}{L}F_{s}^{(u)}$ 给出（$k=0,\\dots,L-1$），并通过 `fftfreq` 对 DFT 使用标准中心化频率赋值进行解释，其中 $F_{s}^{(u)}$ 是 $u[n]$ 的采样频率。具有截止频率 $f_{c}$（单位：赫兹/Hz，包含边界）的理想低通滤波器在 DFT 网格上由以下频率响应定义\n$$\nH(f) = \\begin{cases}\n1, & |f|\\le f_{c},\\\\\n0, & |f|> f_{c},\n\\end{cases}\n$$\n通过将 $U[k]$ 乘以 $H(f_{k})$ 并用逆 DFT 变换回去来应用。该定义在 DFT 频率仓上强制实现砖墙响应。\n\n将对 $x[n]$ 应用两种处理顺序：\n1. 先滤波后降采样：设 $f_{c} = F_{s}/(2M)$。通过将采样频率为 $F_{s}$、截止频率为 $f_{c}$ 的理想低通滤波器应用于 $x[n]$，形成 $x_{\\mathrm{F}}[n]$。然后形成\n$$\ny_{A}[m] = x_{\\mathrm{F}}[mM], \\quad m=0,1,\\dots,\\left\\lfloor\\frac{N}{M}\\right\\rfloor-1.\n$$\n2. 先降采样后滤波：首先形成采样频率为 $F_{s}^{(\\downarrow)}=F_{s}/M$ 的 $x_{\\downarrow}[m] = x[mM]$。然后应用相同的理想低通滤波器定义，在采样频率 $F_{s}^{(\\downarrow)}$ 和截止频率 $f_{c} = F_{s}/(2M)$ 下处理，以获得 $y_{B}[m]$。\n\n对于公共长度为 $L = \\left\\lfloor N/M \\right\\rfloor$ 的 $y_{A}[m]$ 和 $y_{B}[m]$，计算它们的 $L$ 点离散傅里叶变换 (DFT)，记为 $Y_{A}[k]$ 和 $Y_{B}[k]$。设幅值谱为 $|Y_{A}[k]|$ 和 $|Y_{B}[k]|$。定义归一化频谱差异\n$$\nR = \\frac{\\left\\|\\,|Y_{B}| - |Y_{A}|\\,\\right\\|_{2}}{\\left\\|\\,|Y_{A}|\\,\\right\\|_{2}},\n$$\n其中 $\\|\\cdot\\|_{2}$ 是在 $L$ 个 DFT 仓上的欧几里得范数。此 $R$ 无量纲，用于量化运算顺序对最终频谱的影响。\n\n测试套件。使用以下三个测试用例，分别覆盖一般情况、新奈奎斯特频率下的边界情况以及无混叠的边缘情况。所有持续时间和频率分别以秒 (s) 和赫兹 (Hz) 为单位提供。幅值无量纲。三角函数内的角度以弧度为单位。\n\n- 用例 1（一般情况，包含高于新奈奎斯特频率的分量）：\n  - $F_{s} = 4096$ Hz, $T = 1$ s, $M=4$。\n  - 分量 $\\{(A_{i}, f_{i})\\}$: $(1.0, 100)$, $(0.6, 400)$, $(0.8, 700)$, $(0.5, 900)$。\n\n- 用例 2（边界情况，分量位于新奈奎斯特频率上并包含其他高于新奈奎斯特频率的分量）：\n  - $F_{s} = 4096$ Hz, $T = 1$ s, $M=4$。\n  - 分量 $\\{(A_{i}, f_{i})\\}$: $(1.0, 512)$, $(0.8, 200)$, $(0.7, 900)$。\n\n- 用例 3（无混叠边缘情况；所有音调均安全地低于新奈奎斯特频率）：\n  - $F_{s} = 4096$ Hz, $T = 1$ s, $M=4$。\n  - 分量 $\\{(A_{i}, f_{i})\\}$: $(1.0, 80)$, $(0.5, 200)$, $(0.7, 350)$。\n\n要求的程序输出。对于每个用例，计算如上定义的 $R$ 值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按给定用例的顺序列出结果，每个值四舍五入到六位小数（例如，“[$0.123456,0.000000,1.234568$]”）。输出值为无量纲浮点数。", "solution": "问题陈述已经过严格验证，并被确定为是合理的。它在科学上基于数字信号处理的原理，特别是关于混叠和奈奎斯特-香农采样定理。它定义明确、客观，并提供了一套完整、一致的定义和数据，可以得出一个唯一的、可验证的解。我们可以继续。\n\n该问题的核心在于演示数字信号处理中抽取（降采样）的基本原理：为防止混叠，信号必须在降低其采样率*之前*进行低通滤波。该问题要求对两种处理顺序进行定量比较：一种是正确的顺序（先滤波后降采样），另一种是错误的顺序（先降采样后滤波）。\n\n我们将初始离散信号记为 $x[n]$，其采样频率为 $F_s$，长度为 $N$。降采样因子为 $M$。目标采样频率为 $F_{s}^{(\\downarrow)} = F_s/M$，相应的奈奎斯特频率为 $F_{\\mathrm{N,new}} = F_{s}^{(\\downarrow)}/2 = F_s/(2M)$。\n\n路径 A：先滤波后降采样\n此过程代表了正确的抽取方法。\n1.  **抗混叠滤波器**：信号 $x[n]$ 首先由一个截止频率为 $f_c = F_{\\mathrm{N,new}}$ 的理想低通滤波器处理。这一步称为抗混叠滤波，它从信号中移除所有位于新奈奎斯特频率之上的频率分量。滤波后的信号 $x_{\\mathrm{F}}[n]$ 保证带限于范围 $[-F_{\\mathrm{N,new}}, F_{\\mathrm{N,new}}]$ 内。在数学上，如果 $X[k]$ 是 $x[n]$ 的离散傅里叶变换 (DFT)，则滤波后的频谱为 $X_{\\mathrm{F}}[k] = X[k] H(f_k)$，其中当 $|f_k| \\le f_c$ 时 $H(f_k)$ 为1，否则为0。\n2.  **降采样**：然后将滤波后的信号 $x_{\\mathrm{F}}[n]$ 以因子 $M$ 进行降采样，得到 $y_A[m] = x_{\\mathrm{F}}[mM]$。由于所有可能导致混叠的频率都已事先移除，因此 $y_A[m]$ 的频谱是原始信号低频内容的干净、缩放的表示。频谱 $|Y_A[k]|$ 将仅包含那些满足 $|f_i| \\le F_{\\mathrm{N,new}}$ 的原始信号音调 $(A_i, f_i)$ 对应的峰值。\n\n路径 B：先降采样后滤波\n此过程说明了忽略抗混叠要求的后果。\n1.  **降采样**：原始信号 $x[n]$ 被立即降采样，得到 $x_{\\downarrow}[m] = x[mM]$。在频域中，此操作会导致频谱折叠，即混叠。延伸至 $\\pm F_s/2$ 的原始频谱被复制并求和。原始信号中的任何频率分量 $f_i$ 都会被映射到基带 $[-F_{\\mathrm{N,new}}, F_{\\mathrm{N,new}}]$ 中的一个新的表观频率 $f_{\\text{alias}}$。此混叠频率由 $f_{\\text{alias}} = f_i \\pmod{F_{s}^{(\\downarrow)}}$ 给出，并对负频率进行适当解释。具体来说，一个高频分量 $|f_i| > F_{\\mathrm{N,new}}$ 将不可区分地叠加到一个较低的频率上。\n2.  **滤波**：现在已混叠的信号 $x_{\\downarrow}[m]$ 由相同的理想低通滤波器处理。然而，该滤波器无法区分原始带内分量和已折叠到其通带内的新混叠分量。它会通过所有这些分量。因此，得到的信号 $y_B[m]$ 不仅会包含原始的低频音调，还会包含原始高频音调的混叠产物。频谱 $|Y_B[k]|$ 将展现出与满足 $|f_i| \\le F_{\\mathrm{N,new}}$ 的原始音调对应的峰值，以及与满足 $|f_i| > F_{\\mathrm{N,new}}$ 的音调的混叠频率处的峰值。\n\n定量比较\n归一化频谱差异 $R = \\left\\|\\,|Y_{B}| - |Y_{A}|\\,\\right\\|_{2} / \\left\\|\\,|Y_{A}|\\,\\right\\|_{2}$ 量化了因不当处理而引入的误差。\n-   如果原始信号在频率 $|f_i| > F_{\\mathrm{N,new}}$ 处含有能量，路径 B 将引入路径 A 中不存在的混叠分量。这将导致 $|Y_B| \\neq |Y_A|$，从而 $R > 0$。这在用例 1 和用例 2 中是预期的结果。\n-   如果原始信号已是带限的，以至于其所有分量都满足 $|f_i| \\le F_{\\mathrm{N,new}}$，那么路径 A 中的抗混叠滤波器对信号内容没有影响。降采样将不会引起混叠。路径 B 中的滤波器也将通过整个信号。在这种理想情况下，$y_A[m]$ 和 $y_B[m]$ 将是相同的，它们的频谱将匹配，且 $R$ 将为零。这是对用例 3 的预期，任何偏离零的值都可归因于有限精度算法。\n\n该算法对每个测试用例实施这两条路径，计算最终频谱 $|Y_A[k]|$ 和 $|Y_B[k]|$，然后评估度量 $R$。实现将使用 `scipy.fft` 库来高效计算 DFT、逆 DFT 和相关的频率网格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general, with above-new-Nyquist content)\n        (4096, 1, 4, [(1.0, 100), (0.6, 400), (0.8, 700), (0.5, 900)]),\n        # Case 2 (boundary at the new Nyquist and additional above-new-Nyquist content)\n        (4096, 1, 4, [(1.0, 512), (0.8, 200), (0.7, 900)]),\n        # Case 3 (no-aliasing edge case; all tones safely below the new Nyquist)\n        (4096, 1, 4, [(1.0, 80), (0.5, 200), (0.7, 350)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        Fs, T, M, components = case\n        R = calculate_spectral_difference(Fs, T, M, components)\n        results.append(f\"{R:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_spectral_difference(Fs, T, M, components):\n    \"\"\"\n    Calculates the normalized spectral difference R for a given set of parameters.\n\n    Args:\n        Fs (int): Sampling frequency in Hz.\n        T (int): Signal duration in seconds.\n        M (int): Downsampling factor.\n        components (list): A list of tuples (A_i, f_i) representing signal components.\n\n    Returns:\n        float: The calculated normalized spectral difference R.\n    \"\"\"\n    # Define signal and processing parameters\n    N = int(np.floor(Fs * T))\n    L = int(np.floor(N / M))\n    fc = Fs / (2 * M)\n\n    # Generate the initial discrete-time signal x[n]\n    n = np.arange(N)\n    t = n / Fs\n    x = np.zeros(N, dtype=np.float64)\n    for A, f in components:\n        x += A * np.cos(2 * np.pi * f * t)\n\n    # --- Path A: Filter-then-downsample ---\n    # 1A. Apply ideal low-pass filter to x[n]\n    X = fft(x)\n    freqs_N = fftfreq(N, d=1/Fs)\n    h_mask_A = np.abs(freqs_N) <= fc\n    X_F = X * h_mask_A\n    x_F = np.real(ifft(X_F))\n    \n    # 2A. Downsample the filtered signal\n    y_A = x_F[::M]\n\n    # --- Path B: Downsample-then-filter ---\n    # 1B. Downsample the original signal x[n]\n    x_down = x[::M]\n    Fs_down = Fs / M\n    \n    # 2B. Apply ideal low-pass filter to the downsampled signal\n    X_down = fft(x_down)\n    freqs_L = fftfreq(L, d=1/Fs_down)\n    h_mask_B = np.abs(freqs_L) <= fc\n    X_down_filtered = X_down * h_mask_B\n    y_B = np.real(ifft(X_down_filtered))\n\n    # --- Compute Final Spectra and Metric R ---\n    # DFT of the final signals y_A and y_B\n    Y_A = fft(y_A)\n    Y_B = fft(y_B)\n\n    # Magnitude spectra\n    abs_YA = np.abs(Y_A)\n    abs_YB = np.abs(Y_B)\n\n    # Euclidean norms\n    norm_A = np.linalg.norm(abs_YA)\n    \n    # Avoid division by zero if signal A is null\n    if norm_A == 0:\n        return np.inf if np.linalg.norm(abs_YB) > 0 else 0.0\n\n    norm_diff = np.linalg.norm(abs_YB - abs_YA)\n    \n    R = norm_diff / norm_A\n    return R\n\nsolve()\n```", "id": "2373295"}]}