{"hands_on_practices": [{"introduction": "在依赖高度优化的“黑盒”快速傅里叶变换（FFT）库之前，理解它们究竟在计算什么是至关重要的。本练习将带您回到离散傅里叶变换（DFT）的基本定义。通过将DFT直接实现为矩阵-向量乘法，您将巩固对变换作为基底变换的理解，并建立一个参考实现来验证标准库FFT的正确性，同时确认能量守恒和对称性等基本性质，从而培养数值验证的关键技能。[@problem_id:2391694]", "problem": "您需要实现并使用一个基于线性代数定义的参考离散傅里叶变换，以在小规模问题上验证一个现成的快速傅里叶变换 (FFT) 实现的正确性。请从以下基本原理出发：\n\n- 复指数 $e^{\\mathrm{i} 2 \\pi k n / N}$ 在离散网格 $n \\in \\{0,1,\\dots,N-1\\}$ 上构成一个关于离散内积的正交基，并且它们在 $n$ 和 $k$ 上是 $N$-周期的。\n- 离散傅里叶变换是时域中的标准基与频域中的复指数基之间的一种线性基变换。\n- 离散时间信号被建模为长度为 $N$ 的复值有限序列，角度以弧度为单位。\n\n任务：\n\n1) 实现一个函数，通过使用一个显式构造的 $N \\times N$ 复数矩阵，将离散傅里叶变换计算为纯粹的矩阵向量乘法。这必须是直接的、时间复杂度为平方级的方法，不含任何分治优化。将输入向量表示为 $x \\in \\mathbb{C}^N$，输出表示为 $X \\in \\mathbb{C}^N$。选择与标准库 FFT 默认归一化一致的正变换约定：正变换没有缩放，而逆变换有一个因子 $1/N$。\n\n2) 按照所选的正变换约定，通过使用正变换矩阵的逆矩阵，以纯粹的矩阵向量乘法形式实现相应的逆变换。\n\n3) 使用您基于矩阵的变换，通过检查下述每个测试用例的以下属性，来验证一个现成的 FFT 实现（使用您所用语言中可用的标准库 FFT；在 Python 中，这是 numpy.fft.fft 的默认行为）的正确性：\n- 正变换一致性：您的直接变换结果 $X$ 在数值容差范围内与现成的 FFT 结果相匹配。\n- 逆变换一致性：将您的直接逆变换应用于现成的 FFT 结果，能够在相同容差范围内重建原始信号。\n- 能量守恒（对于所采用的归一化的 Parseval 关系）：在容差范围内，$\\sum_{n=0}^{N-1} |x_n|^2$ 等于 $\\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n- 实数输入的厄米共轭对称性：如果 $x$ 是实数值，则对于所有 $k$，在容差范围内有 $X_k = \\overline{X_{(-k) \\bmod N}}$。\n\n数值细节：\n\n- 使用绝对容差 $10^{-10}$ 和相对容差 $10^{-10}$。\n- 角度以弧度为单位。\n\n测试套件：\n\n对于每个案例，令 $n \\in \\{0,1,\\dots,N-1\\}$。\n\n- 案例 A（理想情况，复标量）：$N = 1$，$x_0 = 3 - 2\\,\\mathrm{i}$。\n- 案例 B（边界大小，实数交替）：$N = 2$，$x_0 = 1$，$x_1 = -1$。\n- 案例 C（素数长度，复数混合）：$N = 3$，$x_0 = 1 + 2\\,\\mathrm{i}$，$x_1 = -3 + 0.5\\,\\mathrm{i}$，$x_2 = -\\mathrm{i}$。\n- 案例 D（2的幂，单频余弦）：$N = 4$，$x_n = \\cos\\!\\left(2 \\pi \\cdot 1 \\cdot n / 4\\right)$。\n- 案例 E（稀疏脉冲）：$N = 5$，当 $n = 2$ 时 $x_n = 2$，否则 $x_n = 0$。\n- 案例 F（复线性调频）：$N = 8$，$x_n = \\exp\\!\\left(\\mathrm{i} \\pi\\, n (n-1) / 8\\right)$。\n- 案例 G（可复现的随机复数）：$N = 16$，$x_n = a_n + \\mathrm{i}\\, b_n$，其中 $\\{a_n\\}$ 和 $\\{b_n\\}$ 是使用固定种子 $12345$ 生成的独立标准正态离差。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，布尔文字量写作 $\\text{True}$ 或 $\\text{False}$，顺序为案例 A 到 G。例如：“[True,False,True]”。", "solution": "问题陈述已经过验证。\n\n**步骤 1：提取的已知条件**\n- **原理**：离散傅里叶变换 (DFT) 是从标准基到网格 $n \\in \\{0, 1, \\dots, N-1\\}$ 上复指数 $e^{\\mathrm{i} 2 \\pi k n / N}$ 的正交基的线性变换。\n- **任务 1**：通过显式构造 $N \\times N$ 的 DFT 矩阵 $W$ 来实现正向 DFT，$X = Wx$。这是一个直接的、$O(N^2)$ 算法。\n- **任务 2**：通过构造逆矩阵 $W_{\\text{inv}}$ 来实现相应的逆 DFT，$x = W_{\\text{inv}}X$。\n- **归一化约定**：正变换不进行缩放。逆变换按因子 $1/N$ 进行缩放。\n- **任务 3**：通过为一组测试用例检查四个属性，来验证一个现成的快速傅里叶变换 (FFT) 实现：\n    1.  **正变换一致性**：直接 DFT 结果必须与现成的 FFT 结果匹配。\n    2.  **逆变换一致性**：将直接 IDFT 应用于现成的 FFT 结果必须能重建原始信号。\n    3.  **能量守恒 (Parseval 关系)**：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n    4.  **厄米共轭对称性**：对于实数值输入 $x$，变换必须满足 $X_k = \\overline{X_{(-k) \\bmod N}}$。\n- **数值容差**：绝对容差 $10^{-10}$，相对容差 $10^{-10}$。\n- **测试用例**：\n    - **A**：$N=1$，$x_0 = 3 - 2\\,\\mathrm{i}$。\n    - **B**：$N=2$，$x = [1, -1]$。\n    - **C**：$N=3$，$x = [1 + 2\\,\\mathrm{i}, -3 + 0.5\\,\\mathrm{i}, -\\mathrm{i}]$。\n    - **D**：$N=4$，$x_n = \\cos(2 \\pi n / 4)$。\n    - **E**：$N=5$，$x = [0, 0, 2, 0, 0]$。\n    - **F**：$N=8$，$x_n = \\exp(\\mathrm{i} \\pi n(n-1) / 8)$。\n    - **G**：$N=16$，$x_n = a_n + \\mathrm{i}\\,b_n$，来自种子为 $12345$ 的标准正态离差。\n- **最终输出**：为每个测试用例输出一个布尔值结果，表示是否所有适用的检查都通过。\n\n**步骤 2：验证**\n对问题的科学有效性、良构性和客观性进行评估。\n- **科学依据**：该问题在根本上是可靠的。它基于离散傅里叶变换的标准数学定义、其矩阵表示，以及像 Parseval 定理和厄米共轭对称性这样的核心属性。所指定的归一化是一种通用的约定。\n- **良构性**：该问题是明确且自包含的。它提供了所有必要的数据（信号、大小 $N$）、要实现的算法、要验证的属性以及严格的数值容差。预期会有一个唯一的、可验证的结果（一个布尔值列表）。\n- **客观性**：语言精确，没有任何主观性陈述。任务是纯粹计算性的和可验证的。\n\n**步骤 3：结论**\n该问题被判定为**有效**。这是一个定义明确的数值验证练习，其根源在于傅里叶分析的基本原理。我现在将提供解决方案。\n\n---\n\n该解决方案要求将离散傅里叶变换 (DFT) 及其逆变换实现为直接的矩阵向量乘法，以此作为验证快速傅里叶变换 (FFT) 实现的参考。\n\n**1. 正向离散傅里叶变换 (DFT)**\nDFT 将一个长度为 $N$ 的离散信号向量 $x \\in \\mathbb{C}^N$ 映射到其频域表示 $X \\in \\mathbb{C}^N$。对于每个频率分量 $k \\in \\{0, 1, \\dots, N-1\\}$，其值 $X_k$ 的计算方法是将信号 $x$ 投影到对应于频率 $k$ 的复指数基向量上。遵循标准定义，公式如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n e^{-\\mathrm{i} 2 \\pi k n / N}\n$$\n这组 $N$ 个线性方程可以用矩阵形式表示为 $X = Wx$，其中 $W$ 是 $N \\times N$ 的 DFT 矩阵。该矩阵的元素（由行 $k$ 和列 $n$ 索引）由下式给出：\n$$\nW_{kn} = e^{-\\mathrm{i} 2 \\pi k n / N}\n$$\n实现过程将显式构造此矩阵并执行矩阵向量乘法，其计算复杂度为 $O(N^2)$。这与 FFT 算法形成对比，后者以 $O(N \\log N)$ 的时间计算相同的变换。\n\n**2. 逆离散傅里叶变换 (IDFT)**\n逆变换从其频谱 $X$ 重建原始信号 $x$。根据指定的归一化约定（正变换无缩放），逆变换必须包含一个 $1/N$ 的缩放因子，以确保正变换和逆变换的复合操作产生单位操作。其公式为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k e^{\\mathrm{i} 2 \\pi k n / N}\n$$\n以矩阵形式表示为 $x = W_{\\text{inv}}X$。逆矩阵 $W_{\\text{inv}}$ 的元素为：\n$$\n(W_{\\text{inv}})_{nk} = \\frac{1}{N} e^{\\mathrm{i} 2 \\pi n k / N}\n$$\nDFT 矩阵的一个基本性质是 $W^{-1} = \\frac{1}{N}W^*$，其中 $W^*$ 是 $W$ 的共轭转置。这源于 $W$ 的列向量的正交性。我们的实现将构造逆变换矩阵并应用它。\n\n**3. 验证程序**\n通过对每个测试用例执行四项检查，来对照我们的直接矩阵实现，验证一个现成 FFT 例程的正确性。所有数值比较都使用相对容差 $r_{tol} = 10^{-10}$ 和绝对容差 $a_{tol} = 10^{-10}$。\n\n- **正变换一致性：** 我们计算 $X_{\\text{direct}} = Wx$ 并从标准库函数获得 $X_{\\text{FFT}}$。然后我们验证 $X_{\\text{direct}}$ 和 $X_{\\text{FFT}}$ 在指定的容差范围内是逐元素相等的。\n\n- **逆变换一致性：** 我们验证将我们的直接逆变换应用于现成 FFT 的结果 $X_{\\text{FFT}}$ 时，原始信号 $x$ 是否能被恢复。我们计算 $x_{\\text{rec}} = W_{\\text{inv}} X_{\\text{FFT}}$ 并检查 $x$ 和 $x_{\\text{rec}}$ 在容差范围内是否逐元素相等。\n\n- **能量守恒 (Parseval 关系)：** 对于指定的归一化，信号元素的模平方和与其变换系数的模平方和通过以下恒等式相关联：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n我们计算该方程的左侧和右侧，并验证它们在给定容差内是否相等。\n\n- **厄米共轭对称性：** 此属性仅适用于纯实数值信号 ($x_n \\in \\mathbb{R}$ 对所有 $n$ 成立)。对于此类信号，DFT 频谱表现出共轭对称性：\n$$\nX_k = \\overline{X_{(-k) \\pmod{N}}}\n$$\n对所有 $k \\in \\{0, 1, \\dots, N-1\\}$ 检查此项。这意味着 $X_0$ 是实数，如果 $N$ 是偶数，$X_{N/2}$ 也是实数。此检查仅对具有实数值输入的测试用例执行。\n\n对于每个测试用例，最终结果是一个单一的布尔值，当且仅当所有适用的检查都通过时，该值为真。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the DFT verification process.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries.\n    # Each dictionary specifies the signal size N and a function to generate the signal x.\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"N\": 1,\n            \"x_func\": lambda N: np.array([3.0 - 2.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"B\",\n            \"N\": 2,\n            \"x_func\": lambda N: np.array([1.0, -1.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"C\",\n            \"N\": 3,\n            \"x_func\": lambda N: np.array([1.0 + 2.0j, -3.0 + 0.5j, -1.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"D\",\n            \"N\": 4,\n            \"x_func\": lambda N: np.cos(2 * np.pi * 1 * np.arange(N) / N),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"E\",\n            \"N\": 5,\n            \"x_func\": lambda N: np.array([0.0, 0.0, 2.0, 0.0, 0.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"F\",\n            \"N\": 8,\n            \"x_func\": lambda N: np.exp(1j * np.pi * np.arange(N) * (np.arange(N) - 1) / N),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"G\",\n            \"N\": 16,\n            \"x_func\": lambda N: (\n                (rng := np.random.default_rng(12345)).standard_normal(N) +\n                1j * rng.standard_normal(N)\n            ),\n            \"is_real\": False,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        x = case[\"x_func\"](N)\n        is_real_input = case[\"is_real\"]\n        \n        # Run all verification checks for the current case.\n        passed = run_verification(x, N, is_real_input)\n        results.append(passed)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_verification(x, N, is_real_input):\n    \"\"\"\n    Performs all DFT verification checks for a given signal x of size N.\n    \"\"\"\n    rtol = 1e-10\n    atol = 1e-10\n    \n    checks_passed = []\n\n    # --- 1. Forward Agreement Check ---\n    # Construct the direct DFT matrix W\n    k = np.arange(N).reshape((N, 1))\n    n = np.arange(N)\n    W = np.exp(-2j * np.pi * k * n / N)\n\n    # Compute direct DFT and canned FFT\n    X_direct = W @ x\n    X_fft = np.fft.fft(x)\n    \n    forward_agreement = np.allclose(X_direct, X_fft, rtol=rtol, atol=atol)\n    checks_passed.append(forward_agreement)\n\n    # --- 2. Inverse Agreement Check ---\n    # Construct the direct IDFT matrix W_inv\n    # The unscaled matrix is the conjugate transpose of W, or simply change the sign of the exponent.\n    W_inv_unscaled = np.exp(2j * np.pi * k * n / N)\n    W_inv = (1 / N) * W_inv_unscaled\n    \n    # Reconstruct the signal from the canned FFT result\n    x_reconstructed = W_inv @ X_fft\n    \n    inverse_agreement = np.allclose(x, x_reconstructed, rtol=rtol, atol=atol)\n    checks_passed.append(inverse_agreement)\n\n    # --- 3. Energy Conservation (Parseval's Relation) Check ---\n    energy_x = np.sum(np.abs(x)**2)\n    energy_X = (1 / N) * np.sum(np.abs(X_direct)**2)\n\n    parseval_check = np.isclose(energy_x, energy_X, rtol=rtol, atol=atol)\n    checks_passed.append(parseval_check)\n\n    # --- 4. Hermitian Symmetry Check (for real inputs only) ---\n    if is_real_input:\n        # Check that the input signal is indeed real, as a sanity check.\n        assert np.all(np.abs(x.imag)  atol)\n        \n        # Check X_k = conj(X_{(-k) mod N})\n        indices = np.arange(N)\n        neg_indices_mod_N = (-indices) % N\n        X_conj_symmetric = np.conj(X_direct[neg_indices_mod_N])\n        \n        hermitian_check = np.allclose(X_direct, X_conj_symmetric, rtol=rtol, atol=atol)\n        checks_passed.append(hermitian_check)\n\n    # Return True only if all executed checks passed.\n    return all(checks_passed)\n\nsolve()\n```", "id": "2391694"}, {"introduction": "FFT 最强大的应用之一是它能够通过卷积定理高效地计算卷积。然而，这种方法自然产生的是“循环卷积”，这在诸如滤波器设计等需要“线性卷积”的应用中往往不是我们所需要的。本练习将直面这一关键区别，您将探索填充长度如何决定计算结果，并学习获得正确线性卷积结果所需的特定条件（$L \\ge N+M-1$），从而避免时域混叠这一常见陷阱。[@problem_id:2391693]", "problem": "在计算物理学中，通常使用快速傅里叶变换（FFT）来加速离散傅里叶变换（DFT），从而实现离散卷积。设长度为 $L$ 的序列 $x[n]$（索引 $n \\in \\{0,1,\\dots,L-1\\}$）的长度为 $L$ 的离散傅里叶变换（DFT）定义为\n$$\nX[k] \\equiv \\sum_{n=0}^{L-1} x[n] \\, e^{-2\\pi \\mathrm{i} kn/L}, \\quad k \\in \\{0,1,\\dots,L-1\\},\n$$\n其逆离散傅里叶变换（IDFT）定义为\n$$\nx[n] \\equiv \\frac{1}{L} \\sum_{k=0}^{L-1} X[k] \\, e^{2\\pi \\mathrm{i} kn/L}.\n$$\n给定两个实数、有限长度序列\n$$\nx[n] = \\begin{cases}\n1,  n=0,\\\\\n2,  n=1,\\\\\n1,  n=2,\\\\\n0,  \\text{其他情况},\n\\end{cases}\n\\qquad\nh[n] = \\begin{cases}\n1,  n=0,\\\\\n0,  n=1,\\\\\n-1,  n=2,\\\\\n1,  n=3,\\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n考虑通过基于FFT的流程计算它们的卷积：将 $x[n]$ 和 $h[n]$ 补零至相同的长度 $L$，计算它们的长度为 $L$ 的DFT，在频域中进行逐点相乘，然后应用长度为 $L$ 的逆DFT，以获得时域中一个长度为 $L$ 的序列。根据定义，此流程产生长度为 $L$ 的循环卷积。\n\n设 $N$ 和 $M$ 分别表示 $x[n]$ 和 $h[n]$ 的非零长度。对于上述序列，$N=3$ 且 $M=4$。\n\n下列哪个陈述是正确的？\n\nA. 如果将 $x[n]$ 和 $h[n]$ 都补零至满足 $L \\ge N+M-1$ 的任意相同长度 $L$，那么逐点积的逆DFT在其前 $N+M-1$ 个采样点上等于线性卷积 $x[n] * h[n]$，而在其余的 $L-(N+M-1)$ 个采样点上恒等于零。\n\nB. 如果将两个序列都补零至长度 $L=N+M-2$，那么只有最后一个采样点会受到循环折叠的影响；逆DFT的前 $N+M-2$ 个采样点等于线性卷积 $x[n]*h[n]$。\n\nC. 对于给定的 $x[n]$ 和 $h[n]$，如果将它们都补零至长度 $L=4$，那么逐点积的逆DFT等于长度为4的循环卷积\n$$\n[\\,2,\\,3,\\,0,\\,-1\\,].\n$$\n\nD. 对于给定的 $x[n]$ 和 $h[n]$，如果将它们都补零至长度 $L=6$，那么逐点积的逆DFT完全等于长度为6的线性卷积 $x[n]*h[n]$。\n\nE. 只将其中一个序列补零至任意 $L \\ge N+M-1$ 的长度，而保持另一个序列的原始长度，足以通过基于FFT的流程获得线性卷积，且不会产生循环混叠。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 长度为 $L$ 的离散傅里叶变换（DFT）定义：$X[k] \\equiv \\sum_{n=0}^{L-1} x[n] \\, e^{-2\\pi \\mathrm{i} kn/L}$，其中 $k \\in \\{0,1,\\dots,L-1\\}$。\n- 长度为 $L$ 的逆离散傅里叶变换（IDFT）定义：$x[n] \\equiv \\frac{1}{L} \\sum_{k=0}^{L-1} X[k] \\, e^{2\\pi \\mathrm{i} kn/L}$。\n- 序列 $x[n]$：$x[0]=1$，$x[1]=2$，$x[2]=1$，其他情况下 $x[n]=0$。其非零长度为 $N=3$。\n- 序列 $h[n]$：$h[0]=1$，$h[1]=0$，$h[2]=-1$，$h[3]=1$，其他情况下 $h[n]=0$。其非零长度为 $M=4$。\n- 基于FFT的卷积流程：将 $x[n]$ 和 $h[n]$ 补零至相同长度 $L$，计算它们的长度为 $L$ 的DFT，进行逐点相乘，然后应用长度为 $L$ 的IDFT。\n- 该流程产生长度为 $L$ 的循环卷积。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学性**：该问题基于离散卷积定理，这是数字信号处理和计算科学的基石。所提供的DFT和IDFT定义是标准的。通过补零建立线性和循环卷积之间的关系是一种成熟的技术。该问题具有科学合理性。\n- **良构性**：该问题提供了评估每个陈述正确性所需的所有定义和数据。可以为每个选项得出唯一且可验证的结论。\n- **客观性**：这些陈述以精确的数学语言表述，没有歧义或主观解释的余地。\n\n**步骤3：结论与行动**\n问题陈述内部一致、有科学依据且提法恰当。因此，它被判定为**有效**。我们继续进行完整解答。\n\n基本原理是离散卷积定理，该定理指出，对于两个长度为 $L$ 的序列 $x_p[n]$ 和 $h_p[n]$，它们的循环卷积（表示为 $(x_p \\circledast_L h_p)[n]$）由其DFT的逐点积的IDFT给出：\n$$\n(x_p \\circledast_L h_p)[n] = \\text{IDFT}\\{ X_p[k] \\cdot H_p[k] \\}\n$$\n其中 $X_p[k] = \\text{DFT}\\{x_p[n]\\}$ 且 $H_p[k] = \\text{DFT}\\{h_p[n]\\}$。\n\n原始序列 $x[n]$（长度 $N$）和 $h[n]$（长度 $M$）的线性卷积，表示为 $(x * h)[n]$，是一个长度为 $N+M-1$ 的序列。补零序列的长度为 $L$ 的循环卷积与原始序列的线性卷积之间的关系由下式给出\n$$\n(x_p \\circledast_L h_p)[n] = \\sum_{r=-\\infty}^{\\infty} (x * h)[n + rL] \\quad \\text{其中 } n \\in \\{0, 1, \\dots, L-1\\}\n$$\n这个公式表明，循环卷积是线性卷积的周期化（混叠）版本。为确保循环卷积结果与线性卷积结果相同，我们必须防止混叠。由于线性卷积 $(x * h)[n]$ 的有限长度为 $N+M-1$（即，它仅在 $n \\in \\{0, 1, \\dots, N+M-2\\}$ 时非零），如果补零长度 $L$ 至少这么大：$L \\ge N+M-1$，就可以避免混叠。\n\n对于给定的序列，$N=3$，$M=4$。线性卷积 $(x*h)[n]$ 的长度为 $N+M-1 = 3+4-1=6$。要从循环卷积中获得线性卷积，条件是使用至少为 $L \\ge 6$ 的补零长度。\n\n我们现在将逐一评估每个陈述。\n\n**A. 如果将 $x[n]$ 和 $h[n]$ 都补零至满足 $L \\ge N+M-1$ 的任意相同长度 $L$，那么逐点积的逆DFT在其前 $N+M-1$ 个采样点上等于线性卷积 $x[n] * h[n]$，而在其余的 $L-(N+M-1)$ 个采样点上恒等于零。**\n\n该陈述描述了使用FFT计算线性卷积的标准方法。条件 $L \\ge N+M-1$ 确保了没有时域混叠。基于FFT的流程输出是一个长度为 $L$ 的序列。线性卷积 $(x*h)[n]$ 的长度为 $N+M-1$。\n- 对于 $n \\in \\{0, 1, \\dots, N+M-2\\}$，求和 $\\sum_{r=-\\infty}^{\\infty} (x * h)[n + rL]$ 仅包含 $r=0$ 的项，因为所有其他 $r \\ne 0$ 的项 $(x * h)[n+rL]$ 均为零。因此，对于这前 $N+M-1$ 个采样点，结果与线性卷积匹配。\n- 对于 $n \\in \\{N+M-1, \\dots, L-1\\}$，求和 $\\sum_{r=-\\infty}^{\\infty} (x * h)[n + rL]$ 为零，因为当 $r=0$ 时，$(x*h)[n]$ 为零，而对于所有其他 $r$，索引超出了 $(x*h)$ 的支撑集。\n因此，得到的长度为 $L$ 的序列是线性卷积的结果，并填充了 $L-(N+M-1)$ 个零。该陈述是对这一事实的精确和正确的描述。\n结论：**正确**。\n\n**B. 如果将两个序列都补零至长度 $L=N+M-2$，那么只有最后一个采样点会受到循环折叠的影响；逆DFT的前 $N+M-2$ 个采样点等于线性卷积 $x[n]*h[n]$。**\n\n对于给定的序列，$L = N+M-2 = 3+4-2=5$。线性卷积的长度为 $N+M-1=6$。该流程的输出是长度为5的循环卷积 $y_c[n]$。线性卷积是 $y_l[n] = (x*h)[n]$。\n关系式为 $y_c[n] = y_l[n] + y_l[n+5] + y_l[n-5] + \\dots$，其中 $n \\in \\{0,1,2,3,4\\}$。\n由于 $y_l[n]$ 仅在 $n \\in \\{0,1,2,3,4,5\\}$ 时非零，这可简化为：\n- $y_c[0] = y_l[0] + y_l[5]$。这个采样点被混叠了。\n- $y_c[1] = y_l[1]$。\n- $y_c[2] = y_l[2]$。\n- $y_c[3] = y_l[3]$。\n- $y_c[4] = y_l[4]$。\n该陈述声称“只有最后一个采样点受到影响”。最后一个采样点是 $y_c[4]$，它没有受到影响。第一个采样点 $y_c[0]$ 受到了影响。该陈述在事实上是错误的。\n结论：**错误**。\n\n**C. 对于给定的 $x[n]$ 和 $h[n]$，如果将它们都补零至长度 $L=4$，那么逐点积的逆DFT等于长度为4的循环卷积 $[\\,2,\\,3,\\,0,\\,-1\\,]$。**\n\n我们必须计算补零序列的长度为4的循环卷积。\n$x_p[n] = \\{1, 2, 1, 0\\}$\n$h_p[n] = h[n] = \\{1, 0, -1, 1\\}$\n设 $y_c[n] = (x_p \\circledast_4 h_p)[n] = \\sum_{m=0}^{3} x_p[m] h_p[(n-m) \\pmod 4]$。\n- $y_c[0] = x_p[0]h_p[0] + x_p[1]h_p[3] + x_p[2]h_p[2] + x_p[3]h_p[1] = (1)(1) + (2)(1) + (1)(-1) + (0)(0) = 1+2-1 = 2$。\n- $y_c[1] = x_p[0]h_p[1] + x_p[1]h_p[0] + x_p[2]h_p[3] + x_p[3]h_p[2] = (1)(0) + (2)(1) + (1)(1) + (0)(-1) = 0+2+1 = 3$。\n- $y_c[2] = x_p[0]h_p[2] + x_p[1]h_p[1] + x_p[2]h_p[0] + x_p[3]h_p[3] = (1)(-1) + (2)(0) + (1)(1) + (0)(1) = -1+0+1 = 0$。\n- $y_c[3] = x_p[0]h_p[3] + x_p[1]h_p[2] + x_p[2]h_p[1] + x_p[3]h_p[0] = (1)(1) + (2)(-1) + (1)(0) + (0)(1) = 1-2+0 = -1$。\n得到的序列是 $\\{2, 3, 0, -1\\}$。陈述中提供的序列是 $[\\,2,\\,3,\\,0,\\,-1\\,]$，与我们的计算结果相符。\n结论：**正确**。\n\n**D. 对于给定的 $x[n]$ 和 $h[n]$，如果将它们都补零至长度 $L=6$，那么逐点积的逆DFT完全等于长度为6的线性卷积 $x[n]*h[n]$。**\n\n这里，补零长度为 $L=6$。避免混叠所需的最小长度是 $N+M-1=3+4-1=6$。由于 $L = N+M-1$，条件得到满足。该流程计算长度为6的循环卷积，在这种情况下，它将与长度为6的线性卷积完全相同。该陈述声称结果“完全等于……长度为6的线性卷积”。这是该理论的正确推论。IDFT的输出序列长度（$L=6$）与线性卷积的长度（$N+M-1=6$）相匹配，并且由于避免了混叠，序列本身是相同的。\n结论：**正确**。\n\n**E. 只将其中一个序列补零至任意 $L \\ge N+M-1$ 的长度，而保持另一个序列的原始长度，足以通过基于FFT的流程获得线性卷积，且不会产生循环混叠。**\n\n所描述的基于FFT的流程涉及DFT的逐点积：$X_p[k] \\cdot H_p[k]$。此操作仅在两个DFT，$X_p[k]$ 和 $H_p[k]$，具有相同长度时才有定义。不同长度序列的DFT将具有不同数量的频率点，使得逐点积没有意义。该流程强制要求将两个序列都补零至一个*共同的*长度 $L$。因此，提议的修改与该流程不兼容。\n结论：**错误**。\n\n综上所述，陈述A、C和D是正确的。", "answer": "$$\\boxed{ACD}$$", "id": "2391693"}, {"introduction": "DFT 隐含地假设我们分析的有限信号段是无限重复信号的一个周期。当真实信号的频率与DFT的频率“箱”不能完美对齐时——这在处理真实世界数据时是常见情况——这个假设就被打破了。本练习让您定量地审视由此产生的“频谱泄漏”现象，即单个正弦波的能量看似扩散到多个相邻的频率箱中。通过计算这些泄漏分量的幅度比，您将对DFT如何处理非周期信号有更深刻、更实际的理解，并明白为何在频谱分析中通常需要使用窗函数。[@problem_id:1717762]", "problem": "一位工程师正在分析一台大型工业电机的振动信号。在此分析中，该信号被建模为一个纯正弦波，$x(t) = \\cos(2\\pi f_c t)$，其中幅度和相位的影响被忽略，因为它们不影响最终所需的比率。该信号由一个模数转换器（ADC）以 $f_s = 8000 \\text{ Hz}$ 的采样率进行采样。总共采集 $N = 1024$ 个样本，然后使用快速傅里叶变换（FFT）算法进行处理，该算法计算离散傅里叶变换（DFT）。\n\n电机的真实旋转频率产生的振动信号频率为 $f_c = 150.0 \\text{ Hz}$。由于有限的采样持续时间，该频率并不与1024点FFT的任何频率仓精确重合。结果，信号的能量表现为分散在多个频率仓中，这种现象被称为频谱泄漏。\n\n设 $X[k]$ 为FFT的第 $k$ 个频率仓的复值系数，其中 $k$ 是从 $0$ 到 $N-1$ 的整数。计算真实频率之上相邻频率仓中FFT系数的幅值与真实频率之下相邻频率仓中FFT系数的幅值之比。具体来说，确定比值 $|X[k_{above}]| / |X[k_{below}]|$ 的值，其中 $k_{below}$ 和 $k_{above}$ 分别是紧邻真实信号频率 $f_c$ 以下和以上的整数频率仓索引。\n\n将您的答案表示为一个保留三位有效数字的实数。", "solution": "我们对连续时间正弦波 $x(t)=\\cos(2\\pi f_{c}t)$ 进行采样，得到离散时间序列 $x[n]=\\cos\\!\\left(2\\pi \\frac{f_{c}}{f_{s}}n\\right)$，其中 $n=0,\\ldots,N-1$。$N$ 点DFT定义为\n$$\nX[k]=\\sum_{n=0}^{N-1}x[n]\\exp\\!\\left(-j\\frac{2\\pi kn}{N}\\right).\n$$\n使用 $x[n]=\\frac{1}{2}\\left(\\exp\\!\\left(j2\\pi \\frac{f_{c}}{f_{s}}n\\right)+\\exp\\!\\left(-j2\\pi \\frac{f_{c}}{f_{s}}n\\right)\\right)$ 和线性性质，\n$$\nX[k]=\\frac{1}{2}X_{+}[k]+\\frac{1}{2}X_{-}[k],\n$$\n其中\n$$\nX_{+}[k]=\\sum_{n=0}^{N-1}\\exp\\!\\left(j2\\pi n\\left(\\frac{f_{c}}{f_{s}}-\\frac{k}{N}\\right)\\right),\\qquad\nX_{-}[k]=\\sum_{n=0}^{N-1}\\exp\\!\\left(-j2\\pi n\\left(\\frac{f_{c}}{f_{s}}+\\frac{k}{N}\\right)\\right).\n$$\n每一项都是一个有限几何级数。令 $\\Delta=\\frac{f_{c}}{f_{s}}-\\frac{k}{N}$。则\n$$\nX_{+}[k]=\\exp\\!\\left(j\\pi (N-1)\\Delta\\right)\\frac{\\sin(\\pi N\\Delta)}{\\sin(\\pi \\Delta)},\n$$\n所以\n$$\n|X_{+}[k]|=\\frac{|\\sin(\\pi N\\Delta)|}{|\\sin(\\pi \\Delta)|}.\n$$\n将音调的频率仓位置定义为 $r=\\frac{Nf_{c}}{f_{s}}$，小数部分偏移量定义为 $\\alpha=r-\\lfloor r\\rfloor\\in(0,1)$。$f_{c}$ 周围的相邻频率仓是 $k_{below}=\\lfloor r\\rfloor$ 和 $k_{above}=\\lfloor r\\rfloor+1$。则\n$$\n\\Delta_{below}=\\frac{f_{c}}{f_{s}}-\\frac{k_{below}}{N}=\\frac{r}{N}-\\frac{\\lfloor r\\rfloor}{N}=\\frac{\\alpha}{N},\\qquad\n\\Delta_{above}=\\frac{f_{c}}{f_{s}}-\\frac{k_{above}}{N}=\\frac{\\alpha-1}{N}=-\\frac{1-\\alpha}{N}.\n$$\n因此，对于接近 $+f_{c}$ 的复指数分量，\n$$\n|X_{+}[k_{below}]|=\\frac{|\\sin(\\pi \\alpha)|}{|\\sin(\\pi \\alpha/N)|},\\qquad\n|X_{+}[k_{above}]|=\\frac{|\\sin(\\pi (1-\\alpha))|}{|\\sin(\\pi (1-\\alpha)/N)|}.\n$$\n使用 $|\\sin(\\pi \\alpha)|=|\\sin(\\pi (1-\\alpha))|$，由主瓣决定的比值为\n$$\nR\\equiv\\frac{|X[k_{above}]|}{|X[k_{below}]|}\\approx\\frac{|X_{+}[k_{above}]|}{|X_{+}[k_{below}]|}=\\frac{\\sin(\\pi \\alpha/N)}{\\sin(\\pi (1-\\alpha)/N)}.\n$$\n现在代入给定参数来求 $\\alpha$。给定 $f_{s}=8000$，$N=1024$ 和 $f_{c}=150$，\n$$\nr=\\frac{Nf_{c}}{f_{s}}=\\frac{1024\\cdot 150}{8000}=19.2,\\qquad \\alpha=0.2.\n$$\n因此\n$$\nR=\\frac{\\sin\\!\\left(\\pi\\cdot \\frac{0.2}{1024}\\right)}{\\sin\\!\\left(\\pi\\cdot \\frac{0.8}{1024}\\right)}.\n$$\n因为自变量很小，使用 $\\sin(x)\\approx x$ 可得\n$$\nR\\approx\\frac{\\pi\\cdot 0.2/1024}{\\pi\\cdot 0.8/1024}=\\frac{0.2}{0.8}=\\frac{1}{4}=0.25.\n$$\n保留三位有效数字，该比率为 $0.250$。", "answer": "$$\\boxed{0.250}$$", "id": "1717762"}]}