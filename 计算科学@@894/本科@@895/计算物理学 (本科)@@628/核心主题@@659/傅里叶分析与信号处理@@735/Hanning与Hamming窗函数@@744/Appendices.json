{"hands_on_practices": [{"introduction": "在信号处理中，一个常见的挑战是在一个强信号的频谱泄漏背景下，检测出一个微弱的信号。窗函数的选择对于能否成功检测至关重要，因为它直接影响频谱的分辨率和动态范围。本练习 [@problem_id:2399897] 将通过一个具体的双音信号场景，让您亲手比较 Hanning 窗和 Hamming 窗的性能，从而深刻理解它们在不同频率间隔下的核心优势与权衡。", "problem": "一个连续时间信号由两个振幅差异显著的正弦分量叠加而成：$$x(t) = \\sin(2\\pi f_1 t) + 10^{-4}\\,\\sin(2\\pi f_2 t),$$ 其中 $t$ 是以秒为单位的时间，$f_1$ 和 $f_2$ 是以赫兹为单位的频率。考虑以采样频率 $f_s$ 均匀采样得到的长度为 $N$ 的离散时间序列为 $$x[n] = \\sin\\!\\left(2\\pi \\frac{f_1}{f_s} n\\right) + 10^{-4}\\,\\sin\\!\\left(2\\pi \\frac{f_2}{f_s} n\\right), \\quad n=0,1,\\dots,N-1,$$ 其中所有角度均以弧度为单位。为在估计频谱时抑制频谱泄漏，数据在计算离散傅里叶变换 (DFT) 之前需乘以一个窗函数 $w[n]$。将比较两种经典的窗函数：\n\n- Hann 窗（有时也称为“Hanning”窗）：$$w_{\\mathrm{Hann}}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)\\right), \\quad n=0,1,\\dots,N-1.$$\n- Hamming 窗：$$w_{\\mathrm{Hamm}}[n] = 0.54 - 0.46 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right), \\quad n=0,1,\\dots,N-1.$$\n\n从基本定义出发，时域加窗是 $x[n]$ 与 $w[n]$ 的乘法，而一个加窗信号 $x[n]w[n]$ 的 $N_{\\mathrm{FFT}}$ 点变换在频率点 $k$ 处的 DFT 为 $$X_w[k] = \\sum_{n=0}^{N-1} x[n]\\,w[n]\\,e^{-j 2\\pi \\frac{k n}{N_{\\mathrm{FFT}}}}, \\quad k=0,1,\\dots,N_{\\mathrm{FFT}}-1,$$ 其中 $j$ 是虚数单位，$N_{\\mathrm{FFT}}$ 是一个用于零填充以细化频谱采样的正整数。使用通过与 DFT 定义一致的快速傅里叶变换 (FFT) 计算的单边幅度谱。\n\n您的任务是设计并实现一个算法，该算法针对每个指定的测试用例，判断哪个窗函数能更好地在远强于 $f_1$ 的分量存在的情况下“揭示”出频率为 $f_2$ 的弱分量。为了使该决策精确且可复现，为给定的窗函数 $w$ 定义如下检测优势度量：\n\n1. 为一个固定的整数零填充因子 $L$ 选择一个 FFT 长度 $N_{\\mathrm{FFT}} = L N$。\n2. 将频率 $f$（单位：赫兹）映射到最近的整数 FFT 频率点索引 $k(f) = \\left\\lfloor \\frac{f}{f_s} N_{\\mathrm{FFT}} + \\tfrac{1}{2}\\right\\rfloor$。\n3. 定义 $f_2$ 周围的局部信号频带为频率点 $k \\in \\{k(f_2)-K, \\dots, k(f_2)+K\\}$（其中 $K$ 是一个固定的较小整数），并取 $$P_{\\mathrm{sig}}(w) = \\max_{k \\in \\{k(f_2)-K,\\dots,k(f_2)+K\\}} |X_w[k]|.$$\n4. 定义 $f_2$ 周围的局部基底频带为频率点 $k \\in \\{k(f_2)-B, \\dots, k(f_2)+B\\}$，但不包括 $f_2$ 周围半宽为 $G$ 个频率点的保护带，即排除 $k \\in \\{k(f_2)-G, \\dots, k(f_2)+G\\}$。如果索引超出有效范围，则将其限制在最近的有效索引处。计算 $$F_{\\mathrm{floor}}(w) = \\max_{\\substack{k \\in \\{k(f_2)-B,\\dots,k(f_2)+B\\} \\\\ k \\notin \\{k(f_2)-G,\\dots,k(f_2)+G\\}}} |X_w[k]|.$$\n5. 检测优势为 $$R(w) = \\frac{P_{\\mathrm{sig}}(w)}{F_{\\mathrm{floor}}(w)}.$$\n\n使用此度量，按如下方式判定一个测试用例的更优窗函数：如果 $R(w_{\\mathrm{Hann}})$ 比 $R(w_{\\mathrm{Hamm}})$ 大，且超出相对容差 $\\varepsilon$，则输出 $1$；如果 $R(w_{\\mathrm{Hamm}})$ 比 $R(w_{\\mathrm{Hann}})$ 大，且超出相同的容差，则输出 $2$；如果两个优势在容差范围内，则输出 $0$。使用 $$\\varepsilon = 10^{-3}.$$ 容差比较必须按如下方式执行 $$\\left|R(w_{\\mathrm{Hann}}) - R(w_{\\mathrm{Hamm}})\\right| \\le \\varepsilon \\,\\max\\!\\left(R(w_{\\mathrm{Hann}}), R(w_{\\mathrm{Hamm}})\\right).$$\n\n对所有测试用例使用以下固定的分析参数实现计算：\n- 零填充因子 $L = 8$，因此 $N_{\\mathrm{FFT}} = 8N$。\n- 信号频带半宽 $K = 2$。\n- 基底频带半宽 $B = 400$。\n- 保护带半宽 $G = 5$。\n\n物理和数值单位：\n- 频率 $f_s$、$f_1$、$f_2$ 的单位是赫兹。\n- 时间的单位是秒。\n- 三角函数内的角度单位是弧度。\n\n测试套件：\n- 用例 1：$f_s = 32768$, $N = 8192$, $f_1 = 1000$, $f_2 = 10000$。\n- 用例 2：$f_s = 32768$, $N = 8192$, $f_1 = 5000$, $f_2 = 5000.5$。\n- 用例 3：$f_s = 48000$, $N = 4096$, $f_1 = 1000$, $f_2 = 1234$。\n\n您的程序必须使用上述规则为每个用例计算决策结果，即一个在 $\\{0,1,2\\}$ 中的整数，并生成单行输出，其中包含三个结果，以逗号分隔并用方括号括起，例如 $$[r_1,r_2,r_3],$$ 其中 $r_i$ 对应于第 $i$ 个用例。不应打印任何其他文本。", "solution": "问题陈述是有效的。这是一个在数字信号处理领域（计算物理学和工程学的一个基础领域）中提出来的、适定的、有科学依据的问题。所有参数、定义和程序都以足够的数学和算法严谨性进行了规定，从而能够得到唯一且可验证的解。其中不存在矛盾、歧义或违反既定科学原理的情况。因此，我们可以着手求解。\n\n其目标是比较 Hann 和 Hamming 窗函数在存在一个强正弦分量（频率为 $f_1$）的情况下，分辨一个弱正弦信号分量（频率为 $f_2$）的效能。这种比较不是定性的，而是基于一个定量的检测优势度量 $R(w)$，它被定义为 $f_2$ 周围窄带内的峰值信号幅值与附近一个不相邻频带内的峰值频谱基底幅值之比。频谱基底主要由来自 $f_1$ 处强信号的泄漏构成。一个更高的 $R(w)$ 值表示能更好地从这个泄漏背景中区分出弱信号。\n\n此比较的理论基础在于两种窗函数在频域中的不同特性。时域加窗等效于频域卷积。一个加窗正弦波的离散傅里叶变换 (DFT) 是该窗函数自身变换的移位版本。\n- **Hann 窗**，其系数由升余弦导出，其旁瓣衰减迅速（约每倍频程 $18$ dB）。此特性对于分辨频率间隔大的信号非常有利，因为强信号的泄漏会随距离迅速减小。\n- **Hamming 窗**，作为 Hann 窗的一种改进，其优化目标是最小化最高旁瓣的电平（相对于主瓣峰值约 $-42.7$ dB）。这样做的代价是旁瓣衰减率较慢。这对于分辨频率间隔近的信号很有利，因为此时强信号的最近旁瓣会造成最显著的干扰。\n\n因此，该问题提出的测试用例探究了这些不同的情况：大频率间隔（用例 1）、极小频率间隔（用例 2）和中等频率间隔（用例 3）。解决方案需要对指定的算法进行直接的数值实现。\n\n每个测试用例的步骤如下：\n\n1.  **信号和窗函数生成**：对于给定的参数集 $\\{f_s, N, f_1, f_2\\}$，我们根据以下公式生成长度为 $N$ 的离散时间信号 $x[n]$：\n    $$x[n] = \\sin\\!\\left(2\\pi \\frac{f_1}{f_s} n\\right) + 10^{-4}\\,\\sin\\!\\left(2\\pi \\frac{f_2}{f_s} n\\right), \\quad n=0,1,\\dots,N-1.$$\n    长度为 $N$ 的 Hann 和 Hamming 窗函数 $w_{\\mathrm{Hann}}[n]$ 和 $w_{\\mathrm{Hamm}}[n]$ 根据其定义生成：\n    $$w_{\\mathrm{Hann}}[n] = 0.5 - 0.5 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$$\n    $$w_{\\mathrm{Hamm}}[n] = 0.54 - 0.46 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$$\n\n2.  **频谱分析**：对于每个窗函数 $w[n]$，计算加窗信号 $x[n]w[n]$。然后使用快速傅里叶变换 (FFT) 算法计算该信号的 $N_{\\mathrm{FFT}}$ 点 DFT，并进行零填充至长度 $N_{\\mathrm{FFT}} = L N = 8N$。这会得到复数频谱 $X_w[k]$。其后的计算使用幅度谱 $|X_w[k]|$。\n\n3.  **度量计算**：计算检测优势度量 $R(w)$。\n    a. 将频率 $f_2$ 映射到最近的整数 FFT 频率点索引 $k(f_2) = \\left\\lfloor \\frac{f_2}{f_s} N_{\\mathrm{FFT}} + \\frac{1}{2}\\right\\rfloor$。\n    b. 通过在信号频带（定义为频率点集合 $\\{k | k \\in [k(f_2)-K, k(f_2)+K]\\}$，其中 $K=2$）上取 $|X_w[k]|$ 的最大值来找到峰值信号幅值 $P_{\\mathrm{sig}}(w)$。\n    c. 通过在基底频带区域内取 $|X_w[k]|$ 的最大值来找到峰值基底幅值 $F_{\\mathrm{floor}}(w)$。该区域包括从 $k(f_2)-B$ 到 $k(f_2)+B$（$B=400$）的频率点，但排除了从 $k(f_2)-G$ 到 $k(f_2)+G$（$G=5$）的中心保护带。具体来说，最大值的搜索是在两个不相交的索引范围的并集上进行的：$[k(f_2)-B, k(f_2)-G-1]$ 和 $[k(f_2)+G+1, k(f_2)+B]$。任何超出有效范围 $[0, N_{\\mathrm{FFT}}-1]$ 的索引都被限制到最近的边界。\n    d. 检测优势是比率 $R(w) = P_{\\mathrm{sig}}(w) / F_{\\mathrm{floor}}(w)$。\n\n4.  **决策**：比较计算出的优势 $R(w_{\\mathrm{Hann}})$ 和 $R(w_{\\mathrm{Hamm}})$。基于指定的相对容差规则（$\\varepsilon = 10^{-3}$）做出决策：\n    - 如果 $|\\,R(w_{\\mathrm{Hann}}) - R(w_{\\mathrm{Hamm}})\\,| \\le \\varepsilon \\max(R(w_{\\mathrm{Hann}}), R(w_{\\mathrm{Hamm}}))$，则认为两个窗函数的性能相当，结果为 $0$。\n    - 如果 $R(w_{\\mathrm{Hann}})$ 比 $R(w_{\\mathrm{Hamm}})$ 大，且超出了此容差，则 Hann 窗更优，结果为 $1$。\n    - 如果 $R(w_{\\mathrm{Hamm}})$ 比 $R(w_{\\mathrm{Hann}})$ 大，且超出了此容差，则 Hamming 窗更优，结果为 $2$。\n\n对所提供的三个测试用例中的每一个都执行此完整过程。最终输出是这些整数结果的有序列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft\n\ndef solve():\n    # Define the fixed analysis parameters from the problem statement.\n    L = 8\n    K = 2\n    B = 400\n    G = 5\n    epsilon = 1e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f_s, N, f_1, f_2)\n        (32768, 8192, 1000, 10000),\n        (32768, 8192, 5000, 5000.5),\n        (48000, 4096, 1000, 1234),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f_s, N, f_1, f_2 = case\n        \n        N_fft = L * N\n        n = np.arange(N)\n        \n        # Generate the discrete-time signal\n        x_n = np.sin(2 * np.pi * f_1 / f_s * n) + 1e-4 * np.sin(2 * np.pi * f_2 / f_s * n)\n        \n        # Define the windows\n        windows = {\n            \"hann\": np.hanning(N),\n            \"hamm\": np.hamming(N),\n        }\n        \n        adv_ratios = {}\n        \n        for name, w in windows.items():\n            # Apply the window to the signal\n            x_w = x_n * w\n            \n            # Compute the FFT and its magnitude\n            X_w = fft(x_w, n=N_fft)\n            mag_X_w = np.abs(X_w)\n            \n            # Map frequency f2 to the nearest integer bin index\n            k_f2 = int(np.round((f_2 / f_s) * N_fft))\n            \n            # 1. Compute P_sig(w)\n            sig_band_start = np.clip(k_f2 - K, 0, N_fft - 1)\n            sig_band_end = np.clip(k_f2 + K, 0, N_fft - 1)\n            P_sig = np.max(mag_X_w[sig_band_start : sig_band_end + 1])\n            \n            # 2. Compute F_floor(w)\n            # The floor is the max over two bands:\n            # [k_f2 - B, k_f2 - G - 1] and [k_f2 + G + 1, k_f2 + B]\n            \n            # Lower band\n            lower_band_start = k_f2 - B\n            lower_band_end = k_f2 - G - 1\n            \n            # Upper band\n            upper_band_start = k_f2 + G + 1\n            upper_band_end = k_f2 + B\n            \n            # Clamp indices to valid range [0, N_fft - 1]\n            c_lower_start = np.clip(lower_band_start, 0, N_fft - 1)\n            c_lower_end = np.clip(lower_band_end, 0, N_fft - 1)\n            c_upper_start = np.clip(upper_band_start, 0, N_fft - 1)\n            c_upper_end = np.clip(upper_band_end, 0, N_fft - 1)\n            \n            max_lower = 0.0\n            if c_lower_start = c_lower_end:\n                max_lower = np.max(mag_X_w[c_lower_start : c_lower_end + 1])\n            \n            max_upper = 0.0\n            if c_upper_start = c_upper_end:\n                max_upper = np.max(mag_X_w[c_upper_start : c_upper_end + 1])\n            \n            F_floor = np.max([max_lower, max_upper])\n            \n            # 3. Compute detection advantage R(w)\n            adv_ratios[name] = P_sig / F_floor if F_floor > 0 else np.inf\n\n        # Compare R(w_hann) and R(w_hamm)\n        R_hann = adv_ratios[\"hann\"]\n        R_hamm = adv_ratios[\"hamm\"]\n        \n        # Apply the decision rule with relative tolerance\n        if abs(R_hann - R_hamm) = epsilon * max(R_hann, R_hamm):\n            results.append(0)\n        elif R_hann > R_hamm:\n            results.append(1)\n        else: # R_hamm > R_hann\n            results.append(2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399897"}, {"introduction": "在了解了 Hanning 窗和 Hamming 窗各自的独特优势后，一个自然的问题是：我们能否创造一个性能介于两者之间的窗函数？本练习 [@problem_id:2399871] 将引导您构建一个由 Hanning 窗和 Hamming 窗线性组合而成的“混合窗”。通过计算并观察其关键频谱指标（如主瓣宽度和峰值旁瓣电平）如何随混合参数 $\\alpha$ 平滑变化，您将体会到窗函数设计的灵活性和其背后的“设计空间”概念。", "problem": "您的任务是构建并分析一个混合离散时间窗函数，该函数由汉宁窗 (Hanning window) 和汉明窗 (Hamming window) 的凸组合形成。设窗长度为 $N=128$，采样点索引为 $n \\in \\{0,1,\\ldots,N-1\\}$。汉宁窗 $W_{Hanning}(n)$ 和汉明窗 $W_{Hamming}(n)$ 定义如下：\n$$\nW_{Hanning}(n) = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right), \\quad\nW_{Hamming}(n) = 0.54 - 0.46\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right).\n$$\n对于混合参数 $\\alpha \\in [0,1]$，定义混合窗为\n$$\nW(n;\\alpha) = \\alpha\\, W_{Hanning}(n) + (1-\\alpha)\\, W_{Hamming}(n).\n$$\n设 $x[n]$ 为长度为 $L=262144$ 的补零序列，其定义为：当 $0 \\le n \\le N-1$ 时，$x[n]=W(n;\\alpha)$，否则 $x[n]=0$。设 $X[k]$ 表示 $x[n]$ 的 $L$ 点离散傅立叶变换 (DFT)：\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n]\\,e^{-i\\,2\\pi kn/L}, \\quad k=0,1,\\ldots,L-1.\n$$\n通过循环移位定义中心化频谱 $X_s[m]$：\n$$\nX_s[m] = X\\big((m + \\tfrac{L}{2}) \\bmod L\\big), \\quad m=0,1,\\ldots,L-1,\n$$\n并令其对应的幅度为 $A[m]=|X_s[m]|$。设 $m_0 = \\tfrac{L}{2}$ 表示中心化频谱中直流 (DC) 分量的索引。定义 $m_L$ 和 $m_R$ 为满足 $m_L  m_0  m_R$ 的最近索引，使得 $A[m_L]$ 和 $A[m_R]$ 是离散序列 $A[m]$ 的严格局部最小值，并且在开区间 $(m_L,m_0)$ 和 $(m_0,m_R)$ 内分别不存在其他严格局部最小值。\n\n使用以上定义，为每个给定的 $\\alpha$ 值计算以下三个标量度量：\n1. 主瓣宽度，以归一化频率（单位：周期/采样点）表示，定义为：\n$$\nw(\\alpha) = \\frac{m_R - m_L}{L}.\n$$\n2. 峰值旁瓣电平，以分贝计，定义为：\n$$\n\\mathrm{PSL}(\\alpha) = 20 \\log_{10} \\left( \\frac{\\max\\big\\{\\max_{0 \\le m  m_L} A[m],\\ \\max_{m_R  m \\le L-1} A[m]\\big\\}}{A[m_0]} \\right).\n$$\n3. 等效噪声带宽 (ENBW)，以 DFT 频点为单位，定义为：\n$$\n\\mathrm{ENBW}(\\alpha) = N\\, \\frac{\\sum_{n=0}^{N-1} W(n;\\alpha)^2}{\\left(\\sum_{n=0}^{N-1} W(n;\\alpha)\\right)^2}.\n$$\n\n以上所有量均为无量纲量。$\\mathrm{PSL}(\\alpha)$ 的分贝值必须按给定公式使用幅度比的以 10 为底的对数进行计算。最终答案不使用角度，因此不需要角度单位。\n\n测试集：\n针对以下五个 $\\alpha$ 值，计算三元组 $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$：\n- $\\alpha = 0.0$，\n- $\\alpha = 0.5$,\n- $\\alpha = 1.0$,\n- $\\alpha = 0.2$,\n- $\\alpha = 0.8$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是对应于上述 $\\alpha$ 顺序的三个浮点数列表 $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$。每个浮点数必须四舍五入到六位小数。例如，一个有效的输出格式是：\n$$\n\\big[\\,[w_1,\\mathrm{PSL}_1,\\mathrm{ENBW}_1],[w_2,\\mathrm{PSL}_2,\\mathrm{ENBW}_2],\\ldots\\,\\big],\n$$\n其确切数值由您的计算确定。", "solution": "所述问题定义明确、内部一致且科学上合理。这是一个关于数字窗函数分析的标准练习，该主题是信号处理和计算物理学中的一个基础课题。我们将着手进行求解。\n\n目标是通过计算三个标准性能度量：主瓣宽度、峰值旁瓣电平和等效噪声带宽，来合成并分析一个混合窗函数，该函数是汉宁窗 (Hanning) 和汉明窗 (Hamming) 的凸组合。\n\n首先，我们定义构成窗和混合窗。窗长度给定为 $N=128$，采样点索引为 $n \\in \\{0, 1, \\dots, N-1\\}$。汉宁窗 $W_{Hanning}(n)$ 和汉明窗 $W_{Hamming}(n)$ 定义如下：\n$$\nW_{Hanning}(n) = \\frac{1}{2} - \\frac{1}{2}\\cos\\left(\\frac{2\\pi n}{N-1}\\right) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi n}{127}\\right)\n$$\n$$\nW_{Hamming}(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi n}{N-1}\\right) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi n}{127}\\right)\n$$\n这是窗函数的“对称”或“DFT-偶对称”版本，对于汉宁窗，其在第一个和最后一个采样点的值为零；对于汉明窗，其值接近于零。混合窗 $W(n;\\alpha)$ 由参数 $\\alpha \\in [0,1]$ 控制的线性插值形成：\n$$\nW(n;\\alpha) = \\alpha\\, W_{Hanning}(n) + (1-\\alpha)\\, W_{Hamming}(n)\n$$\n当 $\\alpha=1$ 时，该窗为纯汉宁窗；当 $\\alpha=0$ 时，为纯汉明窗。汉宁窗以其良好的旁瓣滚降特性而闻名，而汉明窗则为最小化峰值旁瓣电平进行了优化，代价是主瓣稍宽。因此，参数 $\\alpha$ 在这些特性之间进行权衡。\n\n为分析此窗的频谱特性，我们考察其离散傅立叶变换 (DFT)。将长度为 $N$ 的窗序列补零至一个更大的长度 $L=262144$，从而创建一个新的长度为 $L$ 的序列 $x[n]$。补零操作不会改变窗函数的底层连续频谱，但它通过在更精细的频率网格上计算 DFT 来对频谱进行插值。这种密集采样对于精确测量如瓣宽和峰值电平等特征至关重要。$L$ 点 DFT $X[k]$ 计算如下：\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n]\\,e^{-i\\,2\\pi kn/L}\n$$\n为了便于分析，频谱被循环移位，以将零频（直流）分量置于数组中心。中心化频谱 $X_s[m]$ 及其幅度 $A[m]$ 由下式给出：\n$$\nX_s[m] = X\\big((m + \\tfrac{L}{2}) \\bmod L\\big), \\quad A[m] = |X_s[m]|\n$$\n主瓣的峰值位于中心索引 $m_0 = L/2$ 处。\n\n有了这些定义，我们继续为每个给定的 $\\alpha$ 值计算三个指定的度量。\n\n1.  **等效噪声带宽 (ENBW)**：此度量衡量窗的有效带宽，如同它是一个理想的矩形滤波器，单位为 DFT 频点。它使用以下公式直接从窗系数（而非补零序列）计算得出：\n    $$\n    \\mathrm{ENBW}(\\alpha) = N\\, \\frac{\\sum_{n=0}^{N-1} W(n;\\alpha)^2}{\\left(\\sum_{n=0}^{N-1} W(n;\\alpha)\\right)^2}\n    $$\n    此计算不需要 DFT。它衡量了窗函数如何将白噪声信号的能量进行展宽。\n\n2.  **主瓣宽度 ($w$)**: 主瓣宽度是频率分辨率的一个关键指标。它由中心峰值两侧第一个零点（最小值）之间的距离定义。我们必须找到索引 $m_L$ 和 $m_R$，它们是距离中心峰值 $m_0$ 最近的严格局部最小值。索引 $m$ 处的严格局部最小值由条件 $A[m]  A[m-1]$ 和 $A[m]  A[m+1]$ 定义。我们通过从 $m_0-1$ 向下搜索找到 $m_L$，从 $m_0+1$ 向上搜索找到 $m_R$。主瓣宽度即为归一化频率差：\n    $$\n    w(\\alpha) = \\frac{m_R - m_L}{L}\n    $$\n\n3.  **峰值旁瓣电平 (PSL)**：PSL 量化了频谱泄漏，频谱泄漏会掩盖微弱信号。它是最高旁瓣峰值相对于主瓣峰值的幅度，以分贝表示。旁瓣存在于主瓣以外的频谱区域，即索引 $m \\in [0, m_L-1] \\cup [m_R+1, L-1]$。通过在这些区域中取 $A[m]$ 的最大值来找到峰值旁瓣幅度。PSL 于是为：\n    $$\n    \\mathrm{PSL}(\\alpha) = 20 \\log_{10} \\left( \\frac{\\max\\left\\{\\max_{0 \\le m  m_L} A[m], \\max_{m_R  m \\le L-1} A[m]\\right\\}}{A[m_0]} \\right)\n    $$\n    更负的分贝值表示更好的旁瓣抑制效果。\n\n计算过程包括为测试集 $\\{0.0, 0.5, 1.0, 0.2, 0.8\\}$ 中的每个 $\\alpha$ 值实现这些步骤，并收集得到的三元组 $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$。数值计算使用 Python 中的 `NumPy` 库执行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a hybrid Hanning-Hamming window function.\n    \n    For several mixing parameters alpha, it computes three metrics:\n    1. Mainlobe width (w)\n    2. Peak Sidelobe Level (PSL)\n    3. Equivalent Noise Bandwidth (ENBW)\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 128           # Window length\n    L = 262144        # DFT length (zero-padding)\n    test_alphas = [0.0, 0.5, 1.0, 0.2, 0.8] # Mixing parameters\n\n    # --- Container for results ---\n    results = []\n\n    # --- Main loop over test cases ---\n    for alpha in test_alphas:\n        # Step 1: Construct the hybrid window function W(n; alpha)\n        n = np.arange(N, dtype=np.float64)\n        \n        w_hanning = 0.5 - 0.5 * np.cos(2 * np.pi * n / (N - 1))\n        w_hamming = 0.54 - 0.46 * np.cos(2 * np.pi * n / (N - 1))\n        \n        W = alpha * w_hanning + (1 - alpha) * w_hamming\n\n        # Step 2: Calculate Equivalent Noise Bandwidth (ENBW)\n        # This is calculated from the original window coefficients.\n        sum_W = np.sum(W)\n        sum_W_sq = np.sum(W**2)\n        enbw = N * sum_W_sq / (sum_W**2)\n\n        # Step 3: Compute the L-point DFT of the zero-padded window\n        # Create zero-padded sequence x[n]\n        x = np.zeros(L, dtype=np.float64)\n        x[:N] = W\n        \n        # Compute DFT and then shift it to center the DC component\n        X = np.fft.fft(x)\n        Xs = np.fft.fftshift(X)\n        A = np.abs(Xs)\n\n        # Step 4: Analyze the magnitude spectrum A[m] to find mainlobe width (w)\n        m0 = L // 2  # Index of the DC component (mainlobe peak)\n\n        # Find m_L, the first strict local minimum to the left of the peak\n        m_L = -1\n        # Search from m0-1 down to 1. Index m=0 is not checked for minimum.\n        for m in range(m0 - 1, 0, -1):\n            if A[m]  A[m - 1] and A[m]  A[m + 1]:\n                m_L = m\n                break\n        \n        # Find m_R, the first strict local minimum to the right of the peak\n        m_R = -1\n        # Search from m0+1 up to L-2. Index L-1 is not checked.\n        for m in range(m0 + 1, L - 1):\n            if A[m]  A[m - 1] and A[m]  A[m + 1]:\n                m_R = m\n                break\n\n        # A check for robustness, though minima should exist for these windows.\n        if m_L == -1 or m_R == -1:\n            raise ValueError(f\"Could not find mainlobe nulls for alpha = {alpha}\")\n\n        # Calculate mainlobe width in normalized frequency\n        w = (m_R - m_L) / L\n        \n        # Step 5: Calculate Peak Sidelobe Level (PSL)\n        A_m0 = A[m0] # Magnitude of the mainlobe peak\n        \n        # Find peak magnitude in the sidelobe regions\n        sidelobe_region_left = A[0:m_L]\n        sidelobe_region_right = A[m_R + 1:]\n        \n        peak_sidelobe = max(np.max(sidelobe_region_left), np.max(sidelobe_region_right))\n        \n        # Calculate PSL in decibels\n        psl = 20 * np.log10(peak_sidelobe / A_m0)\n\n        # Store the triple of metrics for this alpha\n        results.append([w, psl, enbw])\n    \n    # --- Final Output Formatting ---\n    # The output format is a string representation of a list of lists,\n    # with each float formatted to 6 decimal places.\n    outer_list_parts = []\n    for res_tuple in results:\n        inner_list_str = f\"[{res_tuple[0]:.6f},{res_tuple[1]:.6f},{res_tuple[2]:.6f}]\"\n        outer_list_parts.append(inner_list_str)\n\n    final_output_string = f\"[{','.join(outer_list_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2399871"}, {"introduction": "诸如 Hamming 窗中 $0.54$ 和 $0.46$ 这样的系数并非随意选择，它们是经过精心优化以达到特定频谱特性的结果。这个练习 [@problem_id:2399950] 将让您扮演窗函数设计者的角色，通过对 Hamming 窗的系数进行微小的修改，来定量地分析这种改变对峰值旁瓣电平的影响。这一过程将揭示窗函数性能对其定义系数的敏感性，帮助您理解这些工具背后所蕴含的工程设计思想。", "problem": "长度为 $N$ 的有限长加窗信号由序列 $\\{w[n]\\}_{n=0}^{N-1}$ 定义。考虑由系数 $a_0 \\in (0,1)$ 参数化的 Hamming 型窗函数族，其定义如下：\n$$\nw_{a_0}[n] = a_0 - \\left(1 - a_0\\right)\\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right), \\quad 0 \\le n \\le N-1.\n$$\n令 $W_{a_0}(\\omega)$ 表示 $w_{a_0}[n]$ 的离散时间傅里叶变换 (DTFT)，\n$$\nW_{a_0}(\\omega) = \\sum_{n=0}^{N-1} w_{a_0}[n]\\, e^{-i \\omega n}, \\quad \\omega \\in \\mathbb{R},\n$$\n其中所有角度均以弧度为单位。主瓣区间定义如下：设 $\\omega_{-}  0  \\omega_{+}$ 为最接近 0 且满足 $\\left|W_{a_0}(\\omega_{\\pm})\\right| = 0$ 的两个非零角频率。主瓣是区间 $[\\omega_{-},\\omega_{+}]$，而旁瓣是该区间在频率上的补集。定义峰值旁瓣电平（以分贝计）为相对于主瓣峰值的比值，其公式为：\n$$\nL(a_0;N) = 20 \\log_{10}\\!\\left(\\frac{\\displaystyle \\sup_{\\omega \\notin (\\omega_{-},\\omega_{+})} \\left|W_{a_0}(\\omega)\\right|}{\\displaystyle \\max_{\\omega \\in \\mathbb{R}} \\left|W_{a_0}(\\omega)\\right|}\\right).\n$$\n考虑标准 Hamming 窗（$a_0 = 0.54$）和一个修正窗（$a_0 = 0.53$）。对于每种情况，定义从标准系数变动到修正系数时，峰值旁瓣电平的变化量（以分贝计）为：\n$$\n\\Delta L(N) = L(0.53;N) - L(0.54;N).\n$$\n所有角度都必须以弧度为单位进行处理。您的任务是编写一个完整的程序，对下方测试套件中指定的每个 $N$ 值，计算 $\\Delta L(N)$ 的数值近似值，并报告四舍五入到 $3$ 位小数的结果。\n\n测试套件（窗长 $N$）：\n- $N = 16$，\n- $N = 64$,\n- $N = 65$,\n- $N = 257$。\n\n要求最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_k$ 是对应测试用例计算出的 $\\Delta L(N)$ 值，以分贝为单位，表示为四舍五入到 3 位小数的十进制数。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 窗函数定义：$w_{a_0}[n] = a_0 - \\left(1 - a_0\\right)\\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right)$，对于 $0 \\le n \\le N-1$。\n- 参数范围：$a_0 \\in (0,1)$。\n- 离散时间傅里叶变换 (DTFT)：$W_{a_0}(\\omega) = \\sum_{n=0}^{N-1} w_{a_0}[n]\\, e^{-i \\omega n}$，对于 $\\omega \\in \\mathbb{R}$。\n- 主瓣区间：$[\\omega_{-},\\omega_{+}]$，其中 $\\omega_{-}  0  \\omega_{+}$ 是最接近 $0$ 且满足 $\\left|W_{a_0}(\\omega_{\\pm})\\right| = 0$ 的两个非零角频率。\n- 峰值旁瓣电平 (PSLL)：$L(a_0;N) = 20 \\log_{10}\\!\\left(\\frac{\\displaystyle \\sup_{\\omega \\notin (\\omega_{-},\\omega_{+})} \\left|W_{a_0}(\\omega)\\right|}{\\displaystyle \\max_{\\omega \\in \\mathbb{R}} \\left|W_{a_0}(\\omega)\\right|}\\right)$。\n- 窗系数：标准 Hamming 窗，$a_0 = 0.54$；修正窗，$a_0 = 0.53$。\n- 目标量：$\\Delta L(N) = L(0.53;N) - L(0.54;N)$。\n- 窗长 $N$ 的测试用例：$16, 64, 65, 257$。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学性**：问题基于数字信号处理的原理，特别是窗函数的傅里叶分析。Hamming 型窗是一种标准结构，DTFT 和峰值旁瓣电平的定义是正确且符合惯例的。该问题在根本上是可靠的。\n- **适定性**：问题提供了所有必要的定义、常数和测试参数。目标被清晰地陈述：为一个定义明确的量 $\\Delta L(N)$ 计算数值近似值。对于每个测试用例，都存在一个唯一的、稳定的解。\n- **客观性**：语言精确、数学化，没有歧义或主观性。\n\n**步骤 3：结论与行动**\n问题在科学上有效、客观且适定。没有矛盾、信息缺失或伪科学成分。因此，我们着手构建解决方案。\n\n**基于原理的解决方案**\n\n目标是计算当窗系数 $a_0$ 从 $0.54$ 变为 $0.53$ 时峰值旁瓣电平的变化量 $\\Delta L(N)$。这需要计算每种情况下窗函数的频谱特性。\n\n**1. 频谱的解析形式**\n窗函数由下式给出\n$$\nw_{a_0}[n] = a_0 - (1 - a_0)\\cos\\left(\\frac{2\\pi n}{N-1}\\right), \\quad 0 \\le n \\le N-1.\n$$\n使用欧拉恒等式 $\\cos(x) = \\frac{e^{ix} + e^{-ix}}{2}$，该窗函数可以表示为复指数之和：\n$$\nw_{a_0}[n] = a_0 \\cdot e^{-i \\cdot 0 \\cdot n} - \\frac{1-a_0}{2} e^{i \\frac{2\\pi n}{N-1}} - \\frac{1-a_0}{2} e^{-i \\frac{2\\pi n}{N-1}}.\n$$\n离散时间傅里叶变换 (DTFT) $W_{a_0}(\\omega)$ 是这三个分量的 DTFT 之和。有限复指数序列 $e^{i\\omega_c n}$ 的 DTFT 是一个移位的 Dirichlet 核。令 $D_N(\\omega) = \\sum_{n=0}^{N-1} e^{-i\\omega n} = e^{-i\\omega (N-1)/2} \\frac{\\sin(N\\omega/2)}{\\sin(\\omega/2)}$。于是，该窗函数的 DTFT 为：\n$$\nW_{a_0}(\\omega) = a_0 D_N(\\omega) - \\frac{1-a_0}{2} D_N\\left(\\omega - \\frac{2\\pi}{N-1}\\right) - \\frac{1-a_0}{2} D_N\\left(\\omega + \\frac{2\\pi}{N-1}\\right).\n$$\n该表达式表明窗的频谱是三个移位的 Dirichlet 核的叠加。虽然此解析形式对于理论分析很有用，但对于数值计算，对窗序列的补零版本使用快速傅里叶变换 (FFT) 算法更直接、更稳健。这提供了 DTFT 幅度谱的一个精细采样版本。\n\n**2. 数值计算策略**\n\n我们将实现一个函数，用于根据给定的参数计算 $L(a_0;N)$。其过程如下：\n\n**步骤 2.1：频谱计算**\n对于长度为 $N$ 的窗，我们生成序列 $w_{a_0}[n]$。然后，我们将该序列嵌入一个长度为 $M \\gg N$ 的更大的零数组中（一种称为补零的技术），并使用 FFT 算法计算 $M$ 点离散傅里叶变换 (DFT)。所得复数数组的幅度 $|W[k]|$ 提供了在离散角频率 $\\omega_k = \\frac{2\\pi k}{M}$（其中 $k=0, \\dots, M-1$）处 DTFT 频谱 $|W_{a_0}(\\omega)|$ 的 $M$ 个样本。较大的 $M$ 可确保高频率分辨率。\n\n**步骤 2.2：主瓣峰值**\n频谱的最大值出现在 $\\omega=0$（$k=0$）处。这个峰值 $|W_{a_0}(0)|$ 是信号的直流分量，等于窗系数之和。\n$$\n\\max_{\\omega \\in \\mathbb{R}} |W_{a_0}(\\omega)| = |W_{a_0}(0)| = \\sum_{n=0}^{N-1} w_{a_0}[n] = a_0 N - (1-a_0) \\sum_{n=0}^{N-1} \\cos\\left(\\frac{2\\pi n}{N-1}\\right).\n$$\n求和项 $\\sum_{n=0}^{N-1} \\cos(\\frac{2\\pi n}{N-1})$ 等于 1。因此，主瓣峰值为 $a_0 N - (1-a_0) = a_0(N+1)-1$。这对应于索引 $k=0$ 处的 FFT 结果。\n\n**步骤 2.3：旁瓣识别**\n主瓣是频谱的中心峰，由 $\\omega=0$ 两侧的第一个零点之间的区间定义。旁瓣是此区间外的所有其他峰。为了在数值上找到主瓣的边界：\n1.  我们考虑频谱的正频率部分，即索引 $k=0, \\dots, M/2-1$。\n2.  我们找到频谱中所有局部最大值（峰值）的索引，但不包括 $k=0$ 处的主瓣峰值。`scipy.signal.find_peaks` 函数适用于此任务。\n3.  第一个这样的峰值对应于第一个旁瓣。设其索引为 $k_{\\text{side-peak}}$。\n4.  分隔主瓣和第一个旁瓣的第一个零点，必须位于 $k=0$ 和 $k=k_{\\text{side-peak}}$ 之间。我们通过在该范围内找到频谱的最小值来确定其索引 $k_{\\text{null}}$。\n5.  旁瓣区域则定义为与索引 $k \\ge k_{\\text{null}}$ 对应的所有频率。\n\n**步骤 2.4：峰值旁瓣电平 (PSLL) 计算**\n峰值旁瓣是在整个旁瓣区域上频谱幅度的上确界。在数值上，这是所有索引 $k \\ge k_{\\text{null}}$ 的频谱样本中的最大值。\n$$\n\\text{Peak Side Lobe} = \\max_{k \\ge k_{\\text{null}}} |W[k]|\n$$\nPSLL（以分贝计）随后计算如下：\n$$\nL(a_0;N) = 20 \\log_{10}\\left(\\frac{\\text{Peak Side Lobe}}{\\text{Peak Main Lobe}}\\right).\n$$\n\n**步骤 2.5：$\\Delta L(N)$ 的最终计算**\n对标准系数 $a_0 = 0.54$ 和修正系数 $a_0 = 0.53$ 执行上述过程，分别得出 $L(0.54;N)$ 和 $L(0.53;N)$。然后计算所需的差值 $\\Delta L(N) = L(0.53;N) - L(0.54;N)$。对每个指定的窗长 $N \\in \\{16, 64, 65, 257\\}$ 重复此过程。最终结果按要求四舍五入到 3 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef calculate_psll(a0: float, N: int, M: int) -> float:\n    \"\"\"\n    Calculates the peak side-lobe level (PSLL) in dB for a Hamming-type window.\n\n    Args:\n        a0 (float): The window parameter.\n        N (int): The length of the window.\n        M (int): The size of the FFT for spectral analysis (must be >> N).\n\n    Returns:\n        float: The peak side-lobe level in decibels.\n    \"\"\"\n    \n    # 1. Generate the window sequence.\n    # The case N=1 is not in the test suite and would lead to division by zero.\n    if N == 1:\n        window = np.array([1.0])\n    else:\n        n = np.arange(N)\n        window = a0 - (1 - a0) * np.cos(2 * np.pi * n / (N - 1))\n\n    # 2. Compute the spectrum using a zero-padded FFT.\n    spectrum = np.abs(np.fft.fft(window, M))\n    \n    # We analyze the positive frequency response (first half of the FFT output).\n    response = spectrum[:M // 2]\n\n    # 3. The main lobe peak is the DC component.\n    peak_main_lobe = response[0]\n    \n    if peak_main_lobe == 0:\n        return -np.inf # Should not happen for these windows\n\n    # 4. Find the first side-lobe peak to identify the main-lobe boundary.\n    # We search for peaks starting from index 1 to exclude the main lobe.\n    # The spectra for these windows are well-behaved with clear side lobes.\n    peak_indices, _ = find_peaks(response[1:])\n    \n    if len(peak_indices) == 0:\n        # No side lobes found, theoretically occurs for infinitesimally narrow main lobes.\n        # This case is not expected here.\n        return -np.inf\n\n    # The index returned by find_peaks is relative to the sliced array 'response[1:]'.\n    # Add 1 to get the index in the original 'response' array.\n    first_side_lobe_peak_index = peak_indices[0] + 1\n\n    # 5. Find the null separating the main lobe from the side lobes.\n    # The null is the minimum value between the main lobe peak (index 0) \n    # and the first side lobe peak.\n    # Add 1 to argmin result because the slice starts at index 1.\n    null_index = np.argmin(response[1:first_side_lobe_peak_index]) + 1\n    \n    # 6. The peak side-lobe is the maximum of the spectrum from the first null onwards.\n    # This correctly implements the 'sup' over the side-lobe region.\n    peak_side_lobe = np.max(response[null_index:])\n    \n    # 7. Calculate the PSLL in decibels.\n    psll_db = 20 * np.log10(peak_side_lobe / peak_main_lobe)\n    \n    return psll_db\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [16, 64, 65, 257]\n    \n    a0_standard = 0.54\n    a0_modified = 0.53\n\n    # Use a large, fixed FFT size for high frequency resolution.\n    # A power of 2 is computationally efficient. M = 2^18 is sufficient.\n    M = 2**18\n\n    results = []\n    for N in test_cases:\n        # Calculate PSLL for the standard and modified windows.\n        L_standard = calculate_psll(a0_standard, N, M)\n        L_modified = calculate_psll(a0_modified, N, M)\n        \n        # Calculate the change in PSLL.\n        delta_L = L_modified - L_standard\n        \n        # Round to 3 decimal places as required.\n        results.append(round(delta_L, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399950"}]}