{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解来自于实践。本节将通过一系列动手练习，带你深入探索傅里叶域滤波的强大功能。第一个练习将从一个常见的一维信号处理任务开始：数据去趋势。你将学习如何应用高通滤波器分离信号中的低频趋势（如经济数据中的长期增长）和高频波动（如市场情绪引起的短期振荡），这对于时间序列分析至关重要 [@problem_id:2395589]。", "problem": "考虑一个实值离散时间信号，它在 $N$ 个等距采样点上定义如下：\n$$\nx[n] = a_0 + a_1 \\left(\\frac{n}{N}\\right) + a_2 \\left(\\frac{n}{N}\\right)^2 + A_1 \\sin\\!\\left(2\\pi \\frac{m_1 n}{N}\\right) + A_2 \\sin\\!\\left(2\\pi \\frac{m_2 n}{N}\\right), \\quad n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。设 $N = 1024$， $a_0 = 2.0$， $a_1 = 0.5$， $a_2 = -1.0$， $A_1 = 1.0$， $A_2 = 0.5$， $m_1 = 40$，$m_2 = 160$。在 $N$ 个采样点上，离散傅里叶变换 (DFT) 和离散傅里叶逆变换 (IDFT) 定义如下：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi \\frac{k n}{N}}, \\quad k = 0,1,\\dots,N-1,\n$$\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi \\frac{k n}{N}}, \\quad n = 0,1,\\dots,N-1.\n$$\n设索引 $k$ 对应的频率（单位：周/采样点）为\n$$\nf[k] = \\begin{cases}\n\\frac{k}{N}, & 0 \\le k \\le \\frac{N}{2},\\\\\n-\\frac{N-k}{N}, & \\frac{N}{2} < k \\le N-1.\n\\end{cases}\n$$\n一个截止频率为 $f_c$（单位：周/采样点）的理想高通滤波器在傅里叶域中由掩模指定为\n$$\nM[k] = \\begin{cases}\n1, & |f[k]| \\ge f_c,\\\\\n0, & |f[k]| < f_c,\n\\end{cases}\n\\quad k = 0,1,\\dots,N-1.\n$$\n将此滤波器应用于 $x[n]$ 可得到滤波后的信号 $y[n]$，过程如下：\n$$\nY[k] = M[k] \\, X[k], \\quad y[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] \\, e^{i 2\\pi \\frac{k n}{N}}.\n$$\n将滤波后信号 $y[n]$ 的波动性度量定义为总体标准差\n$$\n\\sigma = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y[n] - \\mu\\right)^2}, \\quad \\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n].\n$$\n您的任务是针对以下五个测试截止频率，计算 $\\sigma$：\n- 测试 1：$f_c = 0$,\n- 测试 2：$f_c = 0.02$,\n- 测试 3：$f_c = 0.10$,\n- 测试 4：$f_c = 0.50$,\n- 测试 5：$f_c = \\frac{m_1}{N}$.\n\n所有量均为无量纲。所有三角函数中的角度必须以弧度为单位进行解释。每个测试中 $\\sigma$ 的最终数值答案必须四舍五入到恰好 6 位小数。\n\n您的程序应生成单行输出，其中包含五个四舍五入后的值，形式为方括号括起来的逗号分隔列表（例如 `\"[v_1,v_2,v_3,v_4,v_5]\"`），其中每个 $v_j$ 是按上述顺序对测试 $j$ 的计算结果。", "solution": "问题陈述已解析和验证。\n\n### 步骤 1：提取已知信息\n- **信号定义**：$x[n] = a_0 + a_1 \\left(\\frac{n}{N}\\right) + a_2 \\left(\\frac{n}{N}\\right)^2 + A_1 \\sin\\!\\left(2\\pi \\frac{m_1 n}{N}\\right) + A_2 \\sin\\!\\left(2\\pi \\frac{m_2 n}{N}\\right)$，对于 $n = 0,1,\\dots,N-1$。\n- **参数**：$N = 1024$， $a_0 = 2.0$， $a_1 = 0.5$， $a_2 = -1.0$， $A_1 = 1.0$， $A_2 = 0.5$， $m_1 = 40$，$m_2 = 160$。\n- **离散傅里叶变换 (DFT)**：$X[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi \\frac{k n}{N}}$。\n- **离散傅里叶逆变换 (IDFT)**：$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi \\frac{k n}{N}}$。\n- **频率映射**：$f[k] = \\frac{k}{N}$ 对于 $0 \\le k \\le \\frac{N}{2}$，且 $f[k] = -\\frac{N-k}{N}$ 对于 $\\frac{N}{2} < k \\le N-1$。\n- **滤波器掩模**：如果 $|f[k]| \\ge f_c$，则 $M[k] = 1$；如果 $|f[k]| < f_c$，则 $M[k] = 0$。\n- **滤波操作**：$Y[k] = M[k] \\, X[k]$，之后进行 $y[n] = \\text{IDFT}(Y[k])$。\n- **波动性度量**：$\\sigma = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y[n] - \\mu\\right)^2}$，其中 $\\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n]$。这是滤波后信号 $y[n]$ 的总体标准差。\n- **截止频率 $f_c$ 的测试用例**：\n  1. $f_c = 0$\n  2. $f_c = 0.02$\n  3. $f_c = 0.10$\n  4. $f_c = 0.50$\n  5. $f_c = \\frac{m_1}{N}$\n\n### 步骤 2：使用提取的信息进行验证\n该问题具有科学依据、是适定的且客观的。它描述了数字信号处理中的一个标准流程：将一个频域滤波器应用于离散信号。所有常数和函数都有清晰的定义。DFT/IDFT 的定义和频率映射是计算库中使用的标准约定。任务是对此流程进行数值实现。问题没有违反科学原理、不存在矛盾或歧义。\n\n### 步骤 3：结论与行动\n问题有效。将提供解法。\n\n### 解法推导\n该问题要求针对几个高通滤波器截止频率 $f_c$ ，计算滤波后信号 $y[n]$ 的波动性（定义为总体标准差 $\\sigma$）。该过程涉及数字信号处理中的一系列标准操作。\n\n**1. 信号生成**\n首先，在 $N=1024$ 个采样点上合成离散时间信号 $x[n]$。该信号是一个二次多项式和两个正弦波的叠加：\n$$\nx[n] = a_0 + a_1 \\left(\\frac{n}{N}\\right) + a_2 \\left(\\frac{n}{N}\\right)^2 + A_1 \\sin\\!\\left(2\\pi \\frac{m_1 n}{N}\\right) + A_2 \\sin\\!\\left(2\\pi \\frac{m_2 n}{N}\\right)\n$$\n多项式分量代表低频内容，而正弦分量对应于离散频率 $f_1 = m_1/N = 40/1024 \\approx 0.039$ 周/采样点 和 $f_2 = m_2/N = 160/1024 \\approx 0.156$ 周/采样点。\n\n**2. 傅里叶变换**\n使用离散傅里叶变换 (DFT) 将信号转换到频域，以获得其频谱 $X[k]$。\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi \\frac{k n}{N}}\n$$\n在数值上，这可以通过快速傅里叶变换 (FFT) 算法高效计算。\n\n**3. 频域滤波**\n在频域中应用高通滤波器。这是通过将信号的频谱 $X[k]$ 与滤波器掩模 $M[k]$ 进行逐元素相乘来实现的。\n$$\nY[k] = M[k] \\, X[k]\n$$\n掩模 $M[k]$ 是基于频率向量 $f[k]$ 和截止频率 $f_c$ 定义的。$f[k]$ 的定义对应于 FFT 输出中频率排序的标准约定，即正频率之后是负频率。该掩模被设计为通过绝对值大于或等于 $f_c$ 的频率：\n$$\nM[k] = \\begin{cases}\n1, & |f[k]| \\ge f_c \\\\\n0, & |f[k]| < f_c\n\\end{cases}\n$$\n此操作会衰减或消除低于截止频率 $f_c$ 的频率分量。\n\n**4. 傅里叶逆变换**\n通过对滤波后的频谱 $Y[k]$ 应用离散傅里叶逆变换 (IDFT)，在时域中恢复滤波后的信号 $y[n]$。\n$$\ny[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] \\, e^{i 2\\pi \\frac{k n}{N}}\n$$\n这在数值上使用快速傅里叶逆变换 (IFFT) 算法计算。由于原始信号 $x[n]$ 是实值的，并且滤波器掩模 $M[k]$ 是实数且对称的（即，对于 $k=1,\\dots,N/2-1$，有 $M[k] = M[N-k]$），因此滤波后的频谱 $Y[k]$ 将表现出埃尔米特对称性（$Y[k] = Y[N-k]^*$）。因此，生成的时域信号 $y[n]$ 必须是实值的。由于浮点不精确性，数值计算可能会引入可忽略的虚部，这部分必须舍弃。\n\n**5. 波动性计算**\n最后，计算实值滤波信号 $y[n]$ 的波动性 $\\sigma$。这被定义为总体标准差：\n$$\n\\sigma = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y[n] - \\mu\\right)^2}, \\quad \\text{其中} \\quad \\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n]\n$$\n对于五个指定的 $f_c$ 值中的每一个，都重复这整个过程。DFT/IDFT 定义和总体标准差公式与 `numpy` 库中的默认实现一致，这简化了计算实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the volatility of a filtered signal for several cutoff frequencies.\n    \"\"\"\n    # 1. Define parameters and test cases from the problem statement.\n    N = 1024\n    a0 = 2.0\n    a1 = 0.5\n    a2 = -1.0\n    A1 = 1.0\n    A2 = 0.5\n    m1 = 40\n    m2 = 160\n\n    test_fcs_raw = [\n        0.0,\n        0.02,\n        0.10,\n        0.50,\n        m1 / N,\n    ]\n\n    # 2. Generate the time-domain signal x[n].\n    n = np.arange(N)\n    x = (a0 +\n         a1 * (n / N) +\n         a2 * (n / N)**2 +\n         A1 * np.sin(2 * np.pi * m1 * n / N) +\n         A2 * np.sin(2 * np.pi * m2 * n / N))\n\n    # 3. Compute the Discrete Fourier Transform (DFT) of the signal.\n    # The result is the spectrum X[k].\n    X = np.fft.fft(x)\n\n    # 4. Define the corresponding frequency vector f[k].\n    # np.fft.fftfreq(N, d=1) gives frequencies in cycles/sample, matching the problem.\n    f = np.fft.fftfreq(N, d=1.0)\n\n    results = []\n    # 5. Process each test case for the cutoff frequency fc.\n    for fc in test_fcs_raw:\n        # a. Create the ideal high-pass filter mask M[k].\n        # The mask is 1 where |f[k]| >= fc, and 0 otherwise.\n        mask = (np.abs(f) >= fc).astype(np.float64)\n\n        # b. Apply the filter in the frequency domain.\n        # The filtered spectrum is Y[k] = M[k] * X[k].\n        Y = X * mask\n\n        # c. Compute the Inverse DFT to get the filtered time-domain signal y[n].\n        # np.fft.ifft correctly applies the 1/N normalization.\n        y = np.fft.ifft(Y)\n        \n        # The resulting signal should be real. We take the real part to discard\n        # negligible imaginary components from floating-point errors.\n        y_real = np.real(y)\n\n        # d. Calculate the volatility (population standard deviation) of y[n].\n        # np.std calculates the population standard deviation by default.\n        sigma = np.std(y_real)\n\n        # e. Append the rounded result to the list.\n        results.append(f\"{sigma:.6f}\")\n\n    # 6. Format the final output as specified.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2395589"}, {"introduction": "现在，让我们将一维滤波的思想扩展到二维空间，例如图像处理。并非所有滤波任务都是各向同性的；有时我们需要沿着特定方向进行处理，比如去除视频中的水平扫描线或在特定方向上产生运动模糊效果。这个练习将指导你设计一个各向异性滤波器，它只在水平方向上模糊图像，同时保持垂直方向的细节完好无损，从而让你掌握方向性滤波的精髓 [@problem_id:2395613]。", "problem": "您的任务是构建并应用一个各向异性的二维傅里叶域滤波器，该滤波器仅沿水平方向执行模糊操作。考虑大小为 $N \\times N$（其中 $N = 128$）的离散、周期性方形场，由整数坐标 $(x,y)$ 索引，其中 $x,y \\in \\{0,1,\\dots,N-1\\}$。对于任何离散标量场 $f[x,y]$（其值可为实数或复数），其二维离散傅里叶变换 (DFT) $F[u,v]$ 及其逆变换 $f[x,y]$ 定义如下：\n$$\nF[u,v] = \\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} f[x,y] \\, \\exp\\!\\left(-i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right),\n$$\n$$\nf[x,y] = \\frac{1}{N^2} \\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} F[u,v] \\, \\exp\\!\\left(i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right).\n$$\n将仅水平方向的各向异性模糊定义为一个傅里叶域传递函数 $H[u,v]$，该函数仅取决于水平角空间波数 $k_x$，而与垂直波数 $k_y$ 无关。设与列索引 $u$ 相关联的角波数为 $k_x(u) = \\frac{2\\pi}{N}\\,u$，在 $2\\pi$ 周期圆上进行解释（角度以弧度为单位）。该滤波器为：\n$$\nH[u,v] = \\exp\\!\\left(-\\frac{k_x(u)^2}{2\\,\\sigma_{k_x}^2}\\right),\n$$\n其中 $\\sigma_{k_x} > 0$ 是水平角波数尺度（单位为弧度/样本）。给定一个输入场 $f[x,y]$，其 DFT 为 $F[u,v]$，则滤波后的场 $g[x,y]$ 定义为：\n$$\nG[u,v] = H[u,v]\\,F[u,v], \\qquad g[x,y] = \\frac{1}{N^2} \\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} G[u,v] \\, \\exp\\!\\left(i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right).\n$$\n您的程序必须构建并应用此滤波器，然后在一组单色平面波测试场上量化其响应。对于整数 $(f_x,f_y)$，其中 $0 \\le f_x \\le N-1$ 且 $0 \\le f_y \\le N-1$，定义单位振幅平面波：\n$$\nf^{(f_x,f_y)}[x,y] = \\exp\\!\\left(i 2\\pi \\left(\\frac{f_x x}{N} + \\frac{f_y y}{N}\\right)\\right).\n$$\n对于每个测试用例，令 $F$ 和 $G$ 分别为输入场和滤波后场的 DFT。定义振幅比：\n$$\nr = \\frac{\\lvert G[f_x,f_y]\\rvert}{\\lvert F[f_x,f_y]\\rvert}.\n$$\n所有角度都必须以弧度为单位。量 $\\sigma_{k_x}$ 是一个角波数，单位为弧度/样本。\n\n测试套件（每个条目为 $(f_x,f_y,\\sigma_{k_x})$）：\n- 测试 1：$(0,\\,8,\\,1.2)$\n- 测试 2：$(8,\\,0,\\,1.2)$\n- 测试 3：$(12,\\,7,\\,0.3)$\n- 测试 4：$(64,\\,0,\\,1.2)$\n- 测试 5：$(23,\\,15,\\,10.0)$\n\n对于每个测试用例，构建 $f^{(f_x,f_y)}[x,y]$，使用给定的 $\\sigma_{k_x}$ 应用指定的仅水平各向异性滤波器，计算如上定义的振幅比 $r$，并将其报告为一个浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含五个振幅比的结果，以逗号分隔的列表形式呈现，保留六位小数，并用方括号括起来，顺序为测试 1 到测试 5（例如，“[r1,r2,r3,r4,r5]”）。", "solution": "问题陈述已经过分析，并被认为是有效的。它具有科学依据、问题定义清晰、客观且内容自洽。它描述了傅里叶域滤波在计算物理学中的一个标准应用，并为获得唯一解提供了所有必要的参数和定义。任务是计算在频域中应用定向高斯模糊后，特定单色平面波的衰减。\n\n问题的核心在于卷积定理，该定理指出空间域中的卷积等效于傅里叶域中的逐点相乘。滤波后场的离散傅里叶变换 (DFT) $G[u,v]$ 由输入场的 DFT $F[u,v]$ 与滤波器传递函数 $H[u,v]$ 的乘积给出。\n$$\nG[u,v] = H[u,v] F[u,v]\n$$\n在分析指定输入场的 DFT 后，问题得到显著简化。输入场是以下形式的单色平面波：\n$$\nf^{(f_x,f_y)}[x,y] = \\exp\\!\\left(i 2\\pi \\left(\\frac{f_x x}{N} + \\frac{f_y y}{N}\\right)\\right)\n$$\n其中 $f_x$ 和 $f_y$ 是整数频率分量。让我们计算该输入场的 DFT $F[u,v]$。\n$$\nF[u,v] = \\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} \\exp\\!\\left(i 2\\pi \\left(\\frac{f_x x}{N} + \\frac{f_y y}{N}\\right)\\right) \\exp\\!\\left(-i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right)\n$$\n$$\nF[u,v] = \\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} \\exp\\!\\left(i 2\\pi \\frac{(f_x - u)x}{N}\\right) \\exp\\!\\left(i 2\\pi \\frac{(f_y - v)y}{N}\\right)\n$$\n$$\nF[u,v] = \\left( \\sum_{x=0}^{N-1} \\exp\\!\\left(i 2\\pi \\frac{(f_x - u)x}{N}\\right) \\right) \\left( \\sum_{y=0}^{N-1} \\exp\\!\\left(i 2\\pi \\frac{(f_y - v)y}{N}\\right) \\right)\n$$\n离散复指数的正交性表明，如果 $j$ 是 $N$ 的整数倍，则 $\\sum_{k=0}^{N-1} \\exp(i 2\\pi jk/N)$ 等于 $N$，否则为 $0$。由于索引 $u,v,f_x,f_y$ 都在 $\\{0, 1, \\dots, N-1\\}$ 范围内，因此只有当 $f_x=u$ 时，项 $(f_x - u)$ 才是 $N$ 的倍数，对于 $y$ 和 $v$ 的项也是如此。因此，这些和仅在特定频率 $(u,v) = (f_x,f_y)$ 处不为零。\n$$\nF[u,v] = (N \\delta_{u,f_x}) (N \\delta_{v,f_y}) = N^2 \\delta_{u,f_x} \\delta_{v,f_y}\n$$\n其中 $\\delta_{j,k}$ 是克罗内克 δ 函数。这表明单色平面波的 DFT 是在其频率对应坐标上的一个单一非零点。所有其他频率分量均为零。\n\n问题要求的是在频率 $(f_x, f_y)$ 处的振幅比 $r$：\n$$\nr = \\frac{\\lvert G[f_x,f_y]\\rvert}{\\lvert F[f_x,f_y]\\rvert} = \\frac{\\lvert H[f_x,f_y] F[f_x,f_y]\\rvert}{\\lvert F[f_x,f_y]\\rvert}\n$$\n由于 $F[f_x,f_y] = N^2 \\neq 0$，我们可以将其简化为：\n$$\nr = \\lvert H[f_x,f_y]\\rvert\n$$\n这是一个关键的简化。问题简化为在输入平面波的特定频率点 $(f_x, f_y)$ 处计算传递函数的大小。无需进行涉及 FFT 的完整数值模拟。\n\n传递函数定义为：\n$$\nH[u,v] = \\exp\\!\\left(-\\frac{k_x(u)^2}{2\\,\\sigma_{k_x}^2}\\right)\n$$\n请注意，$H[u,v]$ 与垂直频率索引 $v$ 无关。由于该函数是实数且为正，其大小就是其本身。因此，比率 $r$ 为：\n$$\nr = H[f_x,f_y] = \\exp\\!\\left(-\\frac{k_x(f_x)^2}{2\\,\\sigma_{k_x}^2}\\right)\n$$\n最后一步是对于给定的离散频率索引 $u$，正确确定水平角波数 $k_x(u)$ 的值。问题将 $k_x(u) = \\frac{2\\pi u}{N}$ 定义为在 $2\\pi$ 周期圆上解释。对于大小为 $N$ 的离散网格，由于混叠效应，从 $0$ 到 $N/2$ 的频率索引代表正波数，而从 $N/2+1$ 到 $N-1$ 的索引代表负波数。索引 $N/2$ 对应于奈奎斯特频率，可以解释为正或负 $\\pi$ 弧度/样本。像 NumPy 这样的数值库中实现的标准约定，是将 DFT 索引 $u \\in \\{0, \\dots, N-1\\}$ 映射到物理频率。对于索引 $u$，频率（单位：周/样本）在 $0 \\le u < N/2$ 时为 $u/N$，在 $N/2 \\le u < N$ 时为 $(u-N)/N$。为了将其转换为角波数（单位：弧度/样本），我们乘以 $2\\pi$。\n给定 $N=128$，索引 $u$ 的角波数 $k_x(u)$ 可以通过离散傅里叶变换的频率约定来计算：\n$$\nk_x(u) = \n\\begin{cases} \n\\frac{2\\pi u}{N} & \\text{for } 0 \\le u \\le 64 \\\\\n\\frac{2\\pi (u-N)}{N} & \\text{for } 65 \\le u \\le 127\n\\end{cases}\n$$\n在实践中，用于 FFT 频率的标准库函数（如 `numpy.fft.fftfreq`）会正确处理此映射。与索引 $u=0,1,\\dots,N-1$ 对应的角波数向量由 $k = 2\\pi \\times \\texttt{fftfreq}(N)$ 给出。我们选择该向量中索引为 $f_x$ 的元素进行计算。\n\n对于每个测试用例 $(f_x, f_y, \\sigma_{k_x})$，我们计算：\n1. 水平角波数 $k_x(f_x)$。\n2. 比率 $r = \\exp(-k_x(f_x)^2 / (2 \\sigma_{k_x}^2))$。\n对所有五个测试用例都遵循此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and applies an anisotropic Fourier-domain filter and quantifies its response.\n    \"\"\"\n    # Define constants from the problem statement.\n    N = 128\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f_x, f_y, sigma_kx)\n        (0, 8, 1.2),\n        (8, 0, 1.2),\n        (12, 7, 0.3),\n        (64, 0, 1.2),\n        (23, 15, 10.0),\n    ]\n\n    results = []\n    \n    # As derived in the solution, a full FFT simulation is not required.\n    # The amplitude ratio r is simply the value of the transfer function H[fx, fy].\n    # H[u,v] depends only on the horizontal wavenumber k_x(u).\n    # r = exp(-k_x(fx)^2 / (2 * sigma_kx^2))\n\n    # Pre-compute the array of discrete angular wavenumbers in radians per sample.\n    # The numpy.fft.fftfreq function computes the discrete frequencies in cycles/sample.\n    # We multiply by 2*pi to get angular wavenumbers in radians/sample.\n    # The array k_x_all will have entries corresponding to indices u = 0, 1, ..., N-1.\n    k_x_all = 2 * np.pi * np.fft.fftfreq(N)\n\n    for case in test_cases:\n        fx, _, sigma_kx = case\n        \n        # 1. Get the horizontal angular wavenumber k_x corresponding to the frequency index fx.\n        # This correctly handles the aliasing of frequencies beyond Nyquist.\n        kx = k_x_all[fx]\n        \n        # 2. Calculate the square of the wavenumber scale.\n        sigma_kx_sq = sigma_kx**2\n        \n        # 3. Calculate the amplitude ratio, r.\n        # The filter is Gaussian, so the expression is exp(-arg).\n        # The argument is (k_x^2) / (2 * sigma_kx^2).\n        if sigma_kx <= 0:\n            # Although the problem states sigma_kx > 0, handle this case for robustness.\n            # Division by zero would occur.\n            # If kx is zero, r=1. If kx is not zero, the filter has zero width, so r=0.\n            r = 1.0 if kx == 0 else 0.0\n        else:\n            exponent = -(kx**2) / (2 * sigma_kx_sq)\n            r = np.exp(exponent)\n        \n        results.append(r)\n\n    # Format the final output as a comma-separated list of floats,\n    # rounded to six decimal places, enclosed in square brackets.\n    output_str = \",\".join([f\"{res:.6f}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "2395613"}, {"introduction": "在许多科学和工程应用中，我们得到的信号或图像（如天文照片或医学扫描）都因测量设备的局限性而变得模糊。傅里叶域滤波提供了一个强大的工具——反卷积——来“撤销”这种模糊。然而，在存在噪声的情况下，简单的逆滤波往往会放大噪声，导致结果无法使用。本练习将带你挑战这个核心问题，通过实现一个带正则化的逆滤波器（Tikhonov正则化）来从模糊且带噪声的图像中恢复出清晰的原始图像，这让你能亲身体验解决不适定逆问题的先进技术 [@problem_id:2395571]。", "problem": "考虑一个在大小为 $N \\times N$ 的方形网格上的二维离散成像模型，该模型具有周期性边界条件（循环卷积）。令 $f[m,n]$ 表示未知的清晰图像，$h[m,n]$ 表示真实的点扩展函数，$g[m,n]$ 表示观测到的图像。其测量模型为\n$$\ng = f * h + \\eta,\n$$\n其中 $*$ 表示循环卷积，$\\eta[m,n]$ 是零均值加性噪声。点扩展函数无法直接获取；取而代之的是一个带噪声的测量值 $\\tilde{h}[m,n]$。\n\n你的任务是通过求解以下正则化最小二乘问题，从 $g$ 和 $\\tilde{h}$ 中估计 $f$。该问题在所有 $N \\times N$ 的实数数组 $x$ 上进行优化：\n$$\n\\hat{f} = \\arg\\min_{x} \\left\\|g - \\tilde{h} * x\\right\\|_2^2 + \\lambda \\left\\|x\\right\\|_2^2,\n$$\n其中 $\\lambda &gt; 0$ 是一个给定的正则化参数。计算出 $\\hat{f}$ 后，使用均方根误差 (RMSE) 评估重建质量：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N^2}\\sum_{m=0}^{N-1}\\sum_{n=0}^{N-1}\\big(\\hat{f}[m,n] - f[m,n]\\big)^2}.\n$$\n\n按如下方式构建合成数据：\n\n1. 网格大小: $N = 128$。\n\n2. 清晰图像 $f[m,n]$:\n   - 令 $i \\in \\{0,1,\\ldots,N-1\\}$ 和 $j \\in \\{0,1,\\ldots,N-1\\}$ 为行和列的索引。\n   - 对于任意实数中心 $c$，在离散环面上定义环绕距离为\n     $$\n     d(i,c) = \\min\\left(\\lvert i - c\\rvert,\\, N - \\lvert i - c\\rvert\\right).\n     $$\n   - 定义两个高斯分量\n     $$\n     G_1[i,j] = \\exp\\!\\left(-\\frac{d(i,N/2)^2 + d(j,N/2)^2}{2\\sigma_1^2}\\right), \\quad \\sigma_1 = 3,\n     $$\n     $$\n     G_2[i,j] = \\exp\\!\\left(-\\frac{d(i,N/3)^2 + d(j,2N/3)^2}{2\\sigma_2^2}\\right), \\quad \\sigma_2 = 5.\n     $$\n   - 定义一个正弦分量\n     $$\n     S[i,j] = \\cos\\!\\left(2\\pi \\left(\\frac{f_x\\, i}{N} + \\frac{f_y\\, j}{N}\\right)\\right), \\quad f_x = 5,\\; f_y = 9.\n     $$\n   - 形成未缩放的图像\n     $$\n     f_0[i,j] = 0.9\\,G_1[i,j] + 0.7\\,G_2[i,j] + 0.3\\,S[i,j].\n     $$\n   - 通过以下方式进行最小-最大归一化到 $[0,1]$\n     $$\n     f[i,j] = \\frac{f_0[i,j] - \\min(f_0)}{\\max(f_0) - \\min(f_0)},\n     $$\n     其中 $\\min(f_0)$ 和 $\\max(f_0)$ 表示 $f_0$ 在所有网格点上的最小值和最大值。\n\n3. 真实点扩展函数 $h[m,n]$:\n   - 使用从原点出发的环绕（环面）径向距离，\n     $$\n     r(i,j) = \\sqrt{\\min(i,N-i)^2 + \\min(j,N-j)^2},\n     $$\n     定义各向同性高斯函数\n     $$\n     h[i,j] = \\exp\\!\\left(-\\frac{r(i,j)^2}{2\\sigma_h^2}\\right),\n     $$\n     然后进行归一化，使得 $\\sum_{i,j} h[i,j] = 1$。模糊宽度 $\\sigma_h$ 在下方的每个测试用例中指定。\n\n4. 带噪声的点扩展函数 $\\tilde{h}[m,n]$:\n   - 生成独立同分布的高斯噪声 $\\nu[i,j] \\sim \\mathcal{N}(0,\\sigma_p^2)$ 并设置\n     $$\n     \\tilde{h}_{\\text{raw}}[i,j] = h[i,j] + \\nu[i,j].\n     $$\n   - 通过将 $\\tilde{h}_{\\text{raw}}$ 的所有负值条目设为 $0$ 来强制非负性，得到 $\\tilde{h}_+[i,j]$。\n   - 重新归一化至和为1，以获得 $\\tilde{h}[i,j] = \\tilde{h}_+[i,j]\\Big/\\sum_{m,n}\\tilde{h}_+[m,n]$。\n\n5. 观测图像 $g[m,n]$:\n   - 生成独立同分布的高斯噪声 $\\eta[i,j] \\sim \\mathcal{N}(0,\\sigma_n^2)$。\n   - 按如下方式形成观测值\n     $$\n     g = f * h + \\eta,\n     $$\n     其中 $*$ 是循环卷积。\n\n6. 随机性与可复现性:\n   - 对于每个标识符为 $t \\in \\{1,2,3,4\\}$ 的测试用例，使用种子 $S_t = 123456 + t$ 初始化一个伪随机数生成器。使用该生成器为该测试用例生成所有高斯随机变量（包括 $\\nu$ 和 $\\eta$）。\n\n测试套件（四个用例），每个由四元组 $(\\sigma_h,\\sigma_n,\\sigma_p,\\lambda)$ 指定：\n- 用例 1 ($t=1$): $(2.0,\\,0.02,\\,0.01,\\,0.001)$。\n- 用例 2 ($t=2$): $(2.0,\\,0.08,\\,0.03,\\,0.02)$。\n- 用例 3 ($t=3$): $(0.7,\\,0.02,\\,0.05,\\,0.005)$。\n- 用例 4 ($t=4$): $(3.0,\\,0.05,\\,0.02,\\,0.02)$。\n\n你的程序必须为每个测试用例，完全按照规定构建 $f$、$h$、$\\tilde{h}$ 和 $g$；计算给定目标的最小化器 $\\hat{f}$；然后计算相应的 $\\mathrm{RMSE}$。最终的程序输出必须是单行文本，包含四个 $\\mathrm{RMSE}$ 值的列表，按用例 $t=1,2,3,4$ 的顺序列出，每个值四舍五入到六位小数，以逗号分隔并用方括号括起来（例如，\"[0.012345,0.067890,0.001234,0.056789]\"）。不应打印任何其他文本。", "solution": "所给出的问题是一个计算图像复原中的标准练习，具体来说，是在点扩展函数存在不确定性情况下的反卷积问题。其目标是从一幅模糊且带噪声的观测图像 $g$ 中恢复出真实图像 $f$，而模糊核 $h$ 也仅通过一个带噪声的测量值 $\\tilde{h}$ 得知。该问题被表述为一个正则化最小二乘优化问题，这是一种处理此类不适定反问题的稳健且成熟的方法。\n\n这个问题是完全自洽的，其科学基础根植于线性系统和傅里叶分析的原理，并且是适定的。所有参数和步骤都以足够的精度进行了规定，以确保得到唯一且可复现的结果。因此，该问题被认为是有效的，并将提供解决方案。\n\n任务是找到目标函数 $J(x)$ 的最小化器 $\\hat{f}$：\n$$\n\\hat{f} = \\arg\\min_{x} J(x) = \\arg\\min_{x} \\left\\|g - \\tilde{h} * x\\right\\|_2^2 + \\lambda \\left\\|x\\right\\|_2^2\n$$\n其中 $x$ 是一个 $N \\times N$ 的实值数组，* 表示二维循环卷积，$\\|\\cdot\\|_2^2$ 是欧几里得范数的平方（元素平方和）。正则化参数 $\\lambda$ 为正，这确保了目标函数是严格凸的，因而有唯一的最小值。\n\n循环卷积算子的存在强烈暗示了在傅里叶域中求解。对于二维离散傅里叶变换 (DFT)（记为 $\\mathcal{F}$）的卷积定理指出，对于 $N \\times N$ 网格上的任意两个离散信号 $a$ 和 $b$，有 $\\mathcal{F}\\{a * b\\} = \\mathcal{F}\\{a\\} \\cdot \\mathcal{F}\\{b\\}$，其中右侧的乘积是逐元素相乘。\n\n让我们用大写字母表示各信号的 DFT：$X = \\mathcal{F}\\{x\\}$，$G = \\mathcal{F}\\{g\\}$，以及 $\\tilde{H} = \\mathcal{F}\\{\\tilde{h}\\}$。利用 Parseval 定理，该定理关联了空间域中的平方和与傅里叶域中的平方和，我们可以变换目标函数。信号 $a$ 的 $\\ell_2$ 范数平方与其 DFT $A$ 的范数平方成正比，即 $\\|a\\|_2^2 \\propto \\|A\\|_2^2$。由于我们是在最小化，可以忽略常数比例因子，并将目标函数写在傅里叶域中：\n$$\nJ(X) = \\left\\| G - \\tilde{H} \\cdot X \\right\\|_F^2 + \\lambda \\left\\|X\\right\\|_F^2\n$$\n其中 $\\|\\cdot\\|_F^2$ 是弗罗贝尼乌斯范数（Frobenius norm）的平方，等同于复值矩阵元素的模长平方和。这可以写成对所有频率分量 $(k,l)$ 的求和：\n$$\nJ(X) = \\sum_{k=0}^{N-1}\\sum_{l=0}^{N-1} \\left( \\left| G[k,l] - \\tilde{H}[k,l] X[k,l] \\right|^2 + \\lambda \\left| X[k,l] \\right|^2 \\right)\n$$\n由于和中的每一项仅依赖于单个频率分量 $X[k,l]$，我们可以通过独立地最小化每一项来最小化总和。对于一个特定的频率 $(k,l)$，我们最小化：\n$$\nJ_{kl}(X_{kl}) = | G_{kl} - \\tilde{H}_{kl} X_{kl} |^2 + \\lambda | X_{kl} |^2\n$$\n为了找到最小化此表达式的复数值 $X_{kl}$，我们对它的共轭 $X_{kl}^*$ 求复导数，并令其为零：\n$$\n\\frac{\\partial J_{kl}}{\\partial X_{kl}^*} = \\frac{\\partial}{\\partial X_{kl}^*} \\left( (G_{kl} - \\tilde{H}_{kl} X_{kl})(G_{kl}^* - \\tilde{H}_{kl}^* X_{kl}^*) + \\lambda X_{kl} X_{kl}^* \\right) = 0\n$$\n$$\n- (G_{kl} - \\tilde{H}_{kl} X_{kl}) \\tilde{H}_{kl}^* + \\lambda X_{kl} = 0\n$$\n$$\n-G_{kl}\\tilde{H}_{kl}^* + |\\tilde{H}_{kl}|^2 X_{kl} + \\lambda X_{kl} = 0\n$$\n解出 $X_{kl}$ 得到估计图像 $\\hat{f}$ 的 DFT 的最优解：\n$$\n\\hat{X}[k,l] = \\frac{G[k,l] \\tilde{H}[k,l]^*}{|\\tilde{H}[k,l]|^2 + \\lambda}\n$$\n这是著名的 Tikhonov 正则化反卷积的解。由于输入信号 $g$ 和 $\\tilde{h}$ 是实数，它们的 DFT $G$ 和 $\\tilde{H}$ 表现出厄米对称性。此性质确保了得到的 $\\hat{X}$ 也具有厄米对称性，因此其逆 DFT $\\hat{f}$ 是一个实值图像，这与问题的约束一致。\n\n因此，算法流程如下：\n1. 对于每个测试用例，根据精确的规范合成数据（$f$, $h$, $\\tilde{h}$, $g$），并使用指定的随机种子以保证可复现性。\n2. 计算观测图像 $g$ 和带噪声的点扩展函数 $\\tilde{h}$ 的二维 DFT，得到 $G$ 和 $\\tilde{H}$。\n3. 在频域中应用推导出的滤波器，计算估计图像 DFT 的每个分量 $\\hat{X}$。\n4. 计算 $\\hat{X}$ 的二维逆 DFT，得到空间域的估计值 $\\hat{f}$。结果应为实数，但显式地取实部是很好的做法，可以丢弃由浮点不精确性产生的可忽略的虚部。\n5. 最后，通过计算估计值 $\\hat{f}$ 与真实清晰图像 $f$ 之间的均方根误差 (RMSE) 来评估重建质量。\n\n该流程将对所提供的四个测试用例中的每一个进行实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the regularized deconvolution problem for four test cases and\n    computes the RMSE for each.\n    \"\"\"\n\n    test_cases = [\n        # (sigma_h, sigma_n, sigma_p, lambda)\n        (2.0, 0.02, 0.01, 0.001),  # Case 1 (t=1)\n        (2.0, 0.08, 0.03, 0.02),   # Case 2 (t=2)\n        (0.7, 0.02, 0.05, 0.005),  # Case 3 (t=3)\n        (3.0, 0.05, 0.02, 0.02),   # Case 4 (t=4)\n    ]\n\n    # --- Static parameters for data generation ---\n    N = 128\n    # Clean image parameters\n    sigma1 = 3.0\n    sigma2 = 5.0\n    fx = 5.0\n    fy = 9.0\n    \n    results = []\n\n    # --- Generate common components for clean image f ---\n    ii, jj = np.indices((N, N))\n\n    def torus_dist(idx, center):\n        d = np.abs(idx - center)\n        return np.minimum(d, N - d)\n\n    # Component G1\n    d_i1 = torus_dist(ii, N / 2.0)\n    d_j1 = torus_dist(jj, N / 2.0)\n    G1 = np.exp(-(d_i1**2 + d_j1**2) / (2.0 * sigma1**2))\n\n    # Component G2\n    d_i2 = torus_dist(ii, N / 3.0)\n    d_j2 = torus_dist(jj, 2.0 * N / 3.0)\n    G2 = np.exp(-(d_i2**2 + d_j2**2) / (2.0 * sigma2**2))\n\n    # Component S\n    S = np.cos(2.0 * np.pi * (fx * ii / N + fy * jj / N))\n\n    # Unscaled image f0\n    f0 = 0.9 * G1 + 0.7 * G2 + 0.3 * S\n\n    # Normalized clean image f\n    f_min, f_max = f0.min(), f0.max()\n    f = (f0 - f_min) / (f_max - f_min)\n\n    # --- Generate common components for true PSF h ---\n    i_coords = np.arange(N)\n    j_coords = np.arange(N)\n    i_dist = np.minimum(i_coords, N - i_coords)\n    j_dist = np.minimum(j_coords, N - j_coords)\n    # Using broadcasting for robust grid creation\n    r = np.sqrt(i_dist[:, np.newaxis]**2 + j_dist[np.newaxis, :]**2)\n\n    for t, case in enumerate(test_cases, 1):\n        sigma_h, sigma_n, sigma_p, lambda_reg = case\n        \n        # --- Initialize PRNG for reproducibility ---\n        seed = 123456 + t\n        rng = np.random.default_rng(seed)\n\n        # --- Generate true PSF h ---\n        h_unnormalized = np.exp(-r**2 / (2.0 * sigma_h**2))\n        h = h_unnormalized / np.sum(h_unnormalized)\n\n        # --- Generate noisy PSF h_tilde ---\n        nu = rng.normal(0.0, sigma_p, size=(N, N))\n        h_tilde_raw = h + nu\n        h_tilde_nonneg = np.maximum(0.0, h_tilde_raw)\n        h_tilde = h_tilde_nonneg / np.sum(h_tilde_nonneg)\n\n        # --- Generate observed image g ---\n        # Circular convolution via FFT\n        f_conv_h = np.real(np.fft.ifft2(np.fft.fft2(f) * np.fft.fft2(h)))\n        eta = rng.normal(0.0, sigma_n, size=(N, N))\n        g = f_conv_h + eta\n        \n        # --- Solve for estimated image f_hat ---\n        # Transform to Fourier domain\n        G = np.fft.fft2(g)\n        H_tilde = np.fft.fft2(h_tilde)\n\n        # Apply regularized inverse filter\n        H_tilde_conj = np.conj(H_tilde)\n        H_tilde_mag_sq = np.abs(H_tilde)**2\n        \n        F_hat_fourier = (G * H_tilde_conj) / (H_tilde_mag_sq + lambda_reg)\n        \n        # Transform back to spatial domain\n        f_hat = np.real(np.fft.ifft2(F_hat_fourier))\n        \n        # --- Calculate RMSE ---\n        rmse = np.sqrt(np.mean((f_hat - f)**2))\n        results.append(rmse)\n    \n    # --- Format and print final output ---\n    output_str = \",\".join([f\"{r:.6f}\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2395571"}]}