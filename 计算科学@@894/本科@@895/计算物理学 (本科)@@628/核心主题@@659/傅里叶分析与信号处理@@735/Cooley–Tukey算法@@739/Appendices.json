{"hands_on_practices": [{"introduction": "要真正掌握一个算法，最好的方法就是亲手实现它。这个练习将引导你从零开始，根据第一性原理构建递归的Cooley-Tukey快速傅里叶变换（FFT）算法。通过这个过程，你不仅能深刻理解其“分而治之”的核心思想，还将通过验证离散傅里叶变换（DFT）的几个基本性质，如循环卷积定理和帕塞瓦尔恒等式，来巩固你的理论知识 [@problem_id:2387187]。", "problem": "设 $N$ 是一个形如 $N = 2^m$ 的正整数，其中 $m$ 为非负整数。对于一个长度为 $N$ 的复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$，其离散傅里叶变换 (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ 定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\n其逆离散傅里叶变换 (IDFT) 定义为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。\n\n编写一个完整的程序，在不调用任何库傅里叶变换程序的情况下，计算长度为 $N = 2^m$ 的序列的DFT和IDFT。您的程序还必须仅使用这些定义，通过明确的测试用例来验证以下基本性质：\n\n- 圆周卷积定理：对于长度为 $N$ 的序列 $a$ 和 $b$，其长度为 $N$ 的圆周卷积 $c$ 定义为 $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$，满足 $C_k = A_k B_k$，其中 $A$、$B$ 和 $C$ 分别是 $a$、$b$ 和 $c$ 的DFT。\n- 帕塞瓦尔恒等式（使用上述归一化）：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n\n您的程序必须实现自己的快速算法来计算 $N = 2^m$ 时的DFT和IDFT，并且必须包含一个直接的 $\\mathcal{O}(N^2)$ DFT用于验证。在需要布尔验证的地方，使用数值容差 $\\varepsilon = 10^{-9}$。所有角度必须以弧度解释。\n\n使用以下测试套件，并按下面给出的顺序生成输出：\n\n- 测试 1（DFT与直接DFT的正确性对比，正常路径）：设 $N = 8$ 且 $x = [0,1,2,3,4,3,2,1]$。使用您的快速实现计算 $X$，并使用直接DFT计算 $\\tilde{X}$。如果 $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$ 则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 2（逆变换恢复）：使用与测试1中相同的 $N$ 和 $x$，通过将您的快速实现的IDFT应用于 $X$ 来计算 $x'$。如果 $\\max_n |x'_n - x_n| \\le \\varepsilon$ 则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 3（通过频域的圆周卷积）：设 $N = 8$，$a = [1,2,3,0,0,0,0,0]$，$b = [0,1,0,0,0,0,0,0]$。直接根据定义计算长度为 $N$ 的圆周卷积 $c$。另外，通过计算 $a$ 和 $b$ 的DFT，进行逐点相乘，然后应用IDFT来计算 $\\hat{c}$。以浮点数形式输出标量 $\\max_n |c_n - \\hat{c}_n|$。\n- 测试 4（帕塞瓦尔恒等式）：设 $N = 16$ 且 $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$，其中 $n = 0,1,\\dots,15$。通过您的快速实现计算 $X$。以浮点数形式输出标量 $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$。\n- 测试 5（边缘情况 $N=1$）：设 $N = 1$ 且 $x = [3 + 4i]$。计算 $X$，然后通过IDFT计算 $x'$。如果 $|x'_0 - x_0| \\le \\varepsilon$ 则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 6（最小非平凡大小 $N=2$）：设 $N = 2$ 且 $x = [1,-1]$。通过您的快速实现计算 $X$。在给定约定下的精确DFT为 $[0,2]$。以浮点数形式输出标量 $\\max_k |X_k - [0,2]_k|$。\n\n最终输出格式：您的程序应生成单行输出，其中包含按顺序排列的六个结果，形式为用方括号括起来的逗号分隔列表，例如 `[r_1,r_2,r_3,r_4,r_5,r_6]`。所有布尔条目必须是 $\\text{True}$ 或 $\\text{False}$，所有实数值条目必须以标准十进制或科学记数法打印。不应打印任何其他文本。", "solution": "所提出的问题是计算物理学中一个定义明确且科学严谨的练习，特别是在信号处理领域。它要求实现和验证离散傅里叶变换（DFT）、其逆变换（IDFT）以及相关的基本定理。该问题是完整的、客观的，其解决方案是可验证的。我们将开始解决该问题。\n\n问题的核心是为一个长度为 $N$ 的给定离散复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$ 计算其DFT $X$。其定义如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\n该公式的直接实现涉及两个嵌套循环，一个针对从 $0$ 到 $N-1$ 的每个索引 $k$，另一个针对从 $0$ 到 $N-1$ 的每个索引 $n$。这导致了 $\\mathcal{O}(N^2)$ 的计算复杂度，对于大的 $N$ 来说效率低下。为了验证目的，将实现这种直接方法。\n\n该问题指定 $N$ 是2的幂，即 $N=2^m$，其中 $m$ 为非负整数。这种结构是采用快速傅里叶变换（FFT）算法的关键，特别是Cooley-Tukey时域抽取算法。该算法将复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N \\log N)$。其原理是分治法。长度为 $N$ 的DFT被递归地分解为两个长度为 $(N/2)$ 的DFT。\n\n将序列 $x_n$ 分解为其偶数索引元素（构成序列 $x'_m = x_{2m}$）和其奇数索引元素（构成序列 $x''_m = x_{2m+1}$），每个序列的长度均为 $N/2$。DFT求和可以重写为：\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\n设 $X'_k$ 和 $X''_k$ 分别是 $x'_m$ 和 $x''_m$ 的长度为 $(N/2)$ 的DFT。上述表达式变为：\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\n其中 $W_N^k = e^{-2\\pi i k/N}$ 是“旋转因子”。对于索引的前半部分，$0 \\le k < N/2$，我们有：\n$$\nX_k = X'_k + W_N^k X''_k\n$$\n对于后半部分，其中索引为 $k+N/2$ ($0 \\le k < N/2$) ，我们使用性质 $X'_{k+N/2} = X'_k$、$X''_{k+N/2} = X''_k$ 和 $W_N^{k+N/2} = -W_N^k$。这得出：\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\n这个递归定义允许构建完整的DFT。递归在基例 $N=1$ 处终止，此时序列 $\\{x_0\\}$ 的DFT就是 $\\{X_0\\} = \\{x_0\\}$。我们的实现将遵循这种递归结构。\n\n逆离散傅里叶变换（IDFT）定义为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\n单独实现一个IDFT是不必要的。我们可以将IDFT与正向DFT关联起来。观察以下推导：\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\n右侧是复共轭序列 $\\{\\overline{X_k}\\}_{k=0}^{N-1}$ 的DFT。因此，我们可以通过计算 $\\overline{X}$ 的DFT，然后对结果取复共轭，再乘以 $1/N$ 来找到 $x_n$。也就是说，$x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$。这使得我们也可以使用我们高效的FFT实现来计算逆变换（IFFT）。\n\n该问题进一步要求验证两个基本定理。\n\n首先是圆周卷积定理。两个长度为 $N$ 的序列 $a$ 和 $b$ 的圆周卷积 $c$ 由 $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$ 给出。该定理指出，卷积的DFT是各个DFT的逐点乘积：$C_k = A_k B_k$。因此，可以通过频域计算 $c$：$c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$，其中 $\\odot$ 表示逐元素相乘。我们将通过直接计算 $c$ 和通过频域路径计算 $c$ 并比较结果来测试这一点。\n\n其次是帕塞瓦尔恒等式。对于给定的DFT归一化，该恒等式为：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n该定理将信号在时域中的总能量与其在频域中的能量联系起来。我们将针对一个特定的测试信号来验证这一点。\n\n程序将首先定义必要的函数：一个直接的 $\\mathcal{O}(N^2)$ DFT，一个递归的 $\\mathcal{O}(N \\log N)$ FFT，一个基于FFT的IFFT，以及一个直接的圆周卷积函数。然后，它将使用这些函数和一个数值容差 $\\varepsilon = 10^{-9}$ 来执行6个指定的测试用例进行比较。结果将被收集并以要求的格式打印出来。", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N <= 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 <= epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 <= epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 <= epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}, {"introduction": "在你实现了自己的FFT算法之后，现在是时候见证它巨大的实用价值了。这个练习聚焦于FFT最经典的计算应用之一：快速卷积。你将通过比较直接计算（复杂度为 $O(N^2)$ ）和基于FFT的计算（复杂度为 $O(N \\log N)$ ）来实现线性卷积，从而直观地感受到FFT带来的惊人速度提升，这一技术是信号处理、图像分析和众多科学计算领域的基石 [@problem_id:2383312]。", "problem": "要求您通过比较时域直接线性卷积与一种使用 `radix-2` Cooley–Tukey 快速傅里叶变换 (FFT) 的频域方法，来对卷积定理进行数值验证。操作应完全在离散时间下进行，处理由非负整数索引的序列。所有量均为无量纲。复指数内的角度必须以弧度为单位。\n\n从以下基本定义出发：\n- 两个有限长度序列 $\\{x[n]\\}_{n=0}^{n_x-1}$ 和 $\\{h[n]\\}_{n=0}^{n_h-1}$ 的离散时间线性卷积定义为 $y[n] = \\sum_{m=-\\infty}^{\\infty} x[m] h[n-m]$，其中当 $m \\notin \\{0,\\dots,n_x-1\\}$ 时 $x[m] = 0$ 且当 $m \\notin \\{0,\\dots,n_h-1\\}$ 时 $h[m] = 0$。线性卷积的长度为 $n_y = n_x + n_h - 1$。\n- 长度为 $L$ 的序列 $\\{x[n]\\}_{n=0}^{L-1}$ 的离散傅里叶变换 (DFT) 为 $X[k] = \\sum_{n=0}^{L-1} x[n] \\exp\\!\\left(-2\\pi i \\frac{kn}{L}\\right)$ (对 $k \\in \\{0,\\dots,L-1\\}$)，其逆变换为 $x[n] = \\frac{1}{L}\\sum_{k=0}^{L-1} X[k] \\exp\\!\\left(2\\pi i \\frac{kn}{L}\\right)$ (对 $n \\in \\{0,\\dots,L-1\\}$)。角度以弧度为单位。\n\n任务：\n- 实现一个 `radix-2` Cooley–Tukey 快速傅里叶变换 (FFT) 及其逆变换，用于计算 DFT 和逆 DFT。您的实现必须要求输入长度为 $2$ 的幂次，并且必须使用将序列分解为偶数和奇数索引的分治策略，并使用旋转因子 $\\exp\\!\\left(-2\\pi i \\frac{k}{N}\\right)$。\n- 根据其定义实现直接线性卷积，采用显式求和，其运行时间应为 $\\mathcal{O}(n_x n_h)$。\n- 按如下方式实现基于 FFT 的线性卷积：给定 $\\{x[n]\\}$ 和 $\\{h[n]\\}$，选择 $L$ 为不小于 $n_x + n_h - 1$ 的最小 $2$ 的幂次，将两个序列都零填充至长度 $L$，通过您的 `radix-2` Cooley–Tukey FFT 计算它们的 DFT，在频域中进行逐点相乘，然后应用您的逆 FFT。返回前 $n_x + n_h - 1$ 个样本以获得线性卷积结果。\n- 为了进行数值比较，请使用固定的随机种子生成信号，以确保结果可复现。对于下述每个测试，计算直接线性卷积与基于 FFT 的线性卷积之间的最大绝对差：\n  $$\\varepsilon = \\max_{0 \\le n \\le n_x+n_h-2} \\left|y_{\\text{direct}}[n] - y_{\\text{FFT}}[n]\\right|.$$\n  报告 $\\varepsilon$ 的值，四舍五入到小数点后 $10$ 位。\n\n角度单位要求：\n- 所有复指数必须使用弧度。\n\n测试套件：\n- 使用一个种子为 $2025$ 的随机数生成器。对于每种情况，从均值为 $0$、方差为 $1$ 的标准正态分布中抽取每个独立的实部或虚部。\n  1. 一般实数情况：$n_x = 64$，$n_h = 47$，$x[n]$ 和 $h[n]$ 为实数值。\n  2. 一般复数情况：$n_x = 32$，$n_h = 16$，$x[n]$ 和 $h[n]$ 为复数值，其实部和虚部均如上所述独立抽取。\n  3. 微小情况：$n_x = 1$，$n_h = 1$，$x[n]$ 和 $h[n]$ 为实数值。\n  4. 素数长度边缘情况：$n_x = 7$，$n_h = 11$，$x[n]$ 和 $h[n]$ 为实数值。\n\n答案规格：\n- 对于每个测试用例，计算如上定义的 $\\varepsilon$。预期结果是，由于数值舍入误差，每个 $\\varepsilon$ 都是一个小的非负实数，通常在 $10^{-12}$ 或更小的数量级。没有物理单位。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，按测试用例 $1$ 到 $4$ 的顺序排列，其中每个条目都是浮点数 $\\varepsilon$ 并四舍五入到小数点后 $10$ 位。例如，一个有效的输出格式类似于 `[\\text{e1},\\text{e2},\\text{e3},\\text{e4}]`，每个 $\\text{e}$ 都打印为小数点后恰好有 $10$ 位的小数（不含百分号）。\n\n您的最终交付物必须是一个完整的、可运行的程序，该程序执行所有计算，并仅按指定格式打印所需的单行输出。", "solution": "经审阅，问题陈述有效。该问题在科学上基于傅里叶分析的原理，特别是卷积定理。问题是适定 (well-posed) 的，为执行数值验证提供了所有必要的定义、参数和约束。指令客观明确，可以得出唯一且可复现的解。因此，我们可以着手进行推导和实现。\n\n目标是通过实现和比较两种计算两个有限离散时间序列 $\\{x[n]\\}_{n=0}^{n_x-1}$ 和 $\\{h[n]\\}_{n=0}^{n_h-1}$ 的线性卷积的方法，来验证离散卷积定理。\n\n第一种方法是直接计算。线性卷积，表示为 $\\{y[n]\\} = \\{x[n]\\} * \\{h[n]\\}$，定义如下：\n$$\ny[n] = \\sum_{m=-\\infty}^{\\infty} x[m] h[n-m]\n$$\n鉴于 $x[m]$ 仅在 $m \\in \\{0, \\dots, n_x-1\\}$ 时非零，而 $h[k]$ 仅在 $k \\in \\{0, \\dots, n_h-1\\}$ 时非零，因此求和仅在有限的 $m$ 范围内非零。得到的序列 $y[n]$ 的长度为 $n_y = n_x + n_h - 1$。直接实现涉及遍历索引 $n$ 和 $m$ 的嵌套循环，导致计算复杂度为 $\\mathcal{O}(n_x n_h)$。\n\n第二种方法利用了卷积定理，该定理指出时域中的卷积等效于频域中的逐点相乘。对于离散序列，该定理适用于循环卷积：\n$$\n\\text{DFT}\\{x \\circledast_L y\\} = \\text{DFT}\\{x\\} \\cdot \\text{DFT}\\{y\\}\n$$\n其中 $\\circledast_L$ 表示长度为 $L$ 的循环卷积，DFT 的长度也为 $L$。为了使用此性质计算线性卷积，我们必须防止循环卷积固有的回绕效应（时域混叠）。这可以通过将两个序列 $x[n]$ 和 $h[n]$ 零填充至长度 $L$ (其中 $L \\ge n_x + n_h - 1$) 来实现。然后计算它们的 $L$ 点 DFT 的乘积，并应用 $L$ 点逆 DFT 返回到时域。所得 $L$ 点序列的前 $n_x + n_h - 1$ 个样本与线性卷积的结果相同。\n\n长度为 $N$ 的序列 $\\{x[n]\\}$ 的离散傅里叶变换 (DFT) 是：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-2\\pi i \\frac{kn}{N}\\right), \\quad k \\in \\{0, \\dots, N-1\\}\n$$\nDFT 的直接计算复杂度为 $\\mathcal{O}(N^2)$。问题要求使用效率更高的 `radix-2` Cooley–Tukey 快速傅里叶变换 (FFT) 算法，其复杂度为 $\\mathcal{O}(N \\log N)$，但要求序列长度 $N$ 是 $2$ 的幂。\n\nCooley-Tukey 算法是一种分治算法。对于长度为 $N = 2^p$ 的序列 $x[n]$，我们将 DFT 的求和分为偶数和奇数索引项：\n$$\nX[k] = \\sum_{m=0}^{N/2-1} x[2m] e^{-2\\pi i \\frac{k(2m)}{N}} + \\sum_{m=0}^{N/2-1} x[2m+1] e^{-2\\pi i \\frac{k(2m+1)}{N}}\n$$\n令 $x_e[m] = x[2m]$ 和 $x_o[m] = x[2m+1]$ 分别为偶数和奇数子序列，每个子序列的长度为 $N/2$。表达式变为：\n$$\nX[k] = \\sum_{m=0}^{N/2-1} x_e[m] e^{-2\\pi i \\frac{km}{N/2}} + e^{-2\\pi i \\frac{k}{N}} \\sum_{m=0}^{N/2-1} x_o[m] e^{-2\\pi i \\frac{km}{N/2}}\n$$\n这表明 $N$ 点 DFT 可以由两个 $(N/2)$ 点 DFT 构建。令 $X_e[k]$ 和 $X_o[k]$ 分别是 $x_e$ 和 $x_o$ 的 $(N/2)$ 点 DFT。令 $W_N^k = \\exp(-2\\pi i \\frac{k}{N})$ 为“旋转因子”。则对于 $k \\in \\{0, \\dots, N/2 - 1\\}$：\n$$\nX[k] = X_e[k] + W_N^k X_o[k]\n$$\n利用 DFT 的周期性 ($X_e[k] = X_e[k+N/2]$) 和旋转因子的性质 ($W_N^{k+N/2} = -W_N^k$)，我们得到变换的后半部分：\n$$\nX[k + N/2] = X_e[k] - W_N^k X_o[k]\n$$\n该分解被递归地应用，直到达到长度 $N=1$ 的基本情况，此时 DFT 是恒等操作：$\\text{DFT}\\{x[0]\\} = x[0]$。\n\n对于基于 FFT 的卷积，我们必须选择变换长度 $L$ 为不小于 $n_x + n_h - 1$ 的最小 $2$ 的幂。将 $x[n]$ 和 $h[n]$ 填充到此长度 $L$ 后，我们计算它们的 FFT，将结果相乘，然后执行逆 FFT (IFFT)。IFFT 可以通过以下恒等式使用 FFT 算法来计算：\n$$\n\\text{IFFT}\\{X[k]\\} = \\frac{1}{N} \\overline{\\text{FFT}\\{\\overline{X[k]}\\}}\n$$\n其中 $\\overline{z}$ 表示 $z$ 的复共轭。\n\n最后一步是通过计算最大绝对差来比较直接卷积的结果 $y_{\\text{direct}}[n]$ 与基于 FFT 的方法的结果 $y_{\\text{FFT}}[n]$：\n$$\n\\varepsilon = \\max_{0 \\le n < n_x+n_h-1} \\left|y_{\\text{direct}}[n] - y_{\\text{FFT}}[n]\\right|\n$$\n这个误差 $\\varepsilon$ 应该是一个接近机器精度的小数，从而证实两种方法的数值等效性，进而在实际计算环境中验证卷积定理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cooley_tukey_fft(x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the radix-2 Cooley-Tukey FFT algorithm recursively.\n    Input length must be a power of 2.\n    \"\"\"\n    N = len(x)\n    if N == 0:\n        return np.array([], dtype=np.complex128)\n    \n    # Validate that N is a power of 2\n    if (N & (N - 1)) != 0:\n        raise ValueError(\"FFT input length must be a power of 2.\")\n\n    # Base case for recursion\n    if N == 1:\n        return x.astype(np.complex128)\n\n    # Recursive step: divide\n    x_even = cooley_tukey_fft(x[0::2])\n    x_odd = cooley_tukey_fft(x[1::2])\n\n    # Combine step: conquer\n    k = np.arange(N // 2)\n    \n    # Twiddle factors. Angles must be in radians.\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    # Butterfly operations\n    X_k = x_even + twiddle_factors * x_odd\n    X_k_plus_N2 = x_even - twiddle_factors * x_odd\n    \n    return np.concatenate([X_k, X_k_plus_N2])\n\ndef inverse_fft(X: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the inverse FFT using the Cooley-Tukey FFT implementation.\n    \"\"\"\n    N = len(X)\n    if N == 0:\n        return np.array([], dtype=np.complex128)\n        \n    # The IFFT can be computed by conjugating the input and output\n    # of a forward FFT and scaling by 1/N.\n    result = np.conj(cooley_tukey_fft(np.conj(X))) / N\n    return result\n\ndef direct_convolution(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes linear convolution using the direct summation definition.\n    Complexity is O(nx * nh).\n    \"\"\"\n    nx = len(x)\n    nh = len(h)\n    ny = nx + nh - 1\n\n    if ny <= 0:\n        return np.array([])\n    \n    # The output type should accommodate complex results if inputs are complex\n    y_dtype = np.result_type(x.dtype, h.dtype, np.float64)\n    y = np.zeros(ny, dtype=y_dtype)\n\n    for n in range(ny):\n        for m in range(nx):\n            if 0 <= n - m < nh:\n                y[n] += x[m] * h[n - m]\n    return y\n\ndef fft_convolution(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes linear convolution using the FFT-based method.\n    \"\"\"\n    nx = len(x)\n    nh = len(h)\n    ny = nx + nh - 1\n    \n    if ny <= 0:\n        return np.array([])\n\n    # Find the smallest power of 2 that is >= ny\n    # (ny-1).bit_length() gives ceil(log2(ny)). 1 << ... gives 2^ceil(log2(ny)).\n    if ny == 1:\n        L = 1\n    else:\n        L = 1 << (ny - 1).bit_length()\n\n    # Zero-pad signals to length L\n    x_padded = np.zeros(L, dtype=x.dtype)\n    x_padded[:nx] = x\n    \n    h_padded = np.zeros(L, dtype=h.dtype)\n    h_padded[:nh] = h\n\n    # Compute FFTs, pointwise product, and inverse FFT\n    X = cooley_tukey_fft(x_padded)\n    H = cooley_tukey_fft(h_padded)\n    Y = X * H\n    y_padded = inverse_fft(Y)\n\n    # Truncate to the linear convolution length\n    return y_padded[:ny]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Use a single random number generator with a fixed seed for reproducibility.\n    # The seed is 2025 as per the problem.\n    rng = np.random.default_rng(2025)\n\n    test_cases = [\n        # (nx, nh, value_type)\n        (64, 47, 'real'),\n        (32, 16, 'complex'),\n        (1, 1, 'real'),\n        (7, 11, 'real'),\n    ]\n\n    results = []\n    for nx, nh, value_type in test_cases:\n        # Generate signals based on test case parameters\n        if value_type == 'real':\n            x = rng.standard_normal(size=nx)\n            h = rng.standard_normal(size=nh)\n        elif value_type == 'complex':\n            x_real = rng.standard_normal(size=nx)\n            x_imag = rng.standard_normal(size=nx)\n            x = x_real + 1j * x_imag\n            h_real = rng.standard_normal(size=nh)\n            h_imag = rng.standard_normal(size=nh)\n            h = h_real + 1j * h_imag\n        \n        # Compute convolution using both methods\n        y_direct = direct_convolution(x, h)\n        y_fft = fft_convolution(x, h)\n\n        # Calculate the maximum absolute difference\n        # The absolute value handles complex numbers correctly.\n        max_abs_diff = np.max(np.abs(y_direct - y_fft))\n        \n        # Append the formatted result\n        results.append(f\"{max_abs_diff:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2383312"}, {"introduction": "快速傅里叶变换不仅是分析工具，更是现代计算物理学中求解偏微分方程的支柱。这个高级实践将展示FFT在“分裂步傅里叶方法”中的强大威力，用于模拟一个典型的量子现象：波包隧穿势垒。通过亲手实现这个模拟，你将体验到像Cooley-Tukey这样的高效算法是如何让我们能够探索和可视化复杂物理系统的行为的，这是纯粹的解析方法难以企及的 [@problem_id:2383392]。", "problem": "您需要推导、实现并验证一个数值求解器，用于求解一维量子隧穿问题，即一个高斯波包穿过矩形势垒。该求解器需使用分步傅里叶方法。您的实现必须通过调用标准数值库来依赖 Cooley–Tukey 快速傅里叶变换 (FFT) 算法。请从含时薛定谔方程出发，并基于第一性原理构建此方法。\n\n使用以下基本和建模假设：\n- 一维含时薛定谔方程为\n$$\ni\\,\\hbar\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{\\hbar^2}{2m}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t).\n$$\n- 在原子单位制下进行计算，其中约化普朗克常数和质量分别设为 $ \\hbar = 1 $ 和 $ m = 1 $，因此方程简化为\n$$\ni\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t).\n$$\n- 所有复指数中的角度必须以弧度为单位。\n\n离散化和数值设计要求：\n- 空间域：一个长度为 $ L = 100 $ 的周期性区间，由 $ N = 1024 $ 个均匀间隔的格点 $ x_j \\in [-L/2,\\,L/2) $ 表示，格点间距为 $ \\Delta x = L/N $。为保证基于傅里叶的方法在数学上的一致性，需要采用周期性边界条件。\n- 傅里叶波数必须与周期性网格上的离散傅里叶变换对保持一致，从而使动能算符在傅里叶空间中是对角的，其色散关系为 $ \\omega(k) = k^2/2 $。请使用一个在长度为 $ L $ 的域上与离散变换在数学上一致的波数网格 $ k_n $。\n- 初始条件：一个归一化的高斯波包，其平均位置为 $ x_0 = -L/4 $，空间宽度为 $ \\sigma = 1 $，中心波数为 $ k_0 = 1.5 $，\n$$\n\\psi(x,0) \\;=\\; C\\,\\exp\\!\\Big(-\\frac{(x-x_0)^2}{4\\sigma^2}\\Big)\\,\\exp(i\\,k_0\\,x),\n$$\n其中 $ C $ 的选择需满足 $ \\int_{-L/2}^{L/2} |\\psi(x,0)|^2\\,dx = 1 $。归一化必须在离散网格上以数值方式执行。\n- 势垒：一个位于 $ x=0 $ 中心的矩形势垒，其高度为 $ V_0 \\ge 0 $，宽度为 $ a \\ge 0 $，\n$$\nV(x) \\;=\\; \\begin{cases}\nV_0, & |x| \\le a/2,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\n- 时间步进：选择时间步长 $ \\Delta t = 0.01 $ 和总模拟时间 $ T = 30 $，步数为整数 $ M = T/\\Delta t $。使用一种二阶、时间可逆的算符分裂（分步）方法，该方法在位置空间中交替应用势能演化，在傅里叶空间中交替应用动能演化。动能演化必须使用 Cooley–Tukey FFT 实现来执行。确保离散化是一致的，以便范数在预期的数值精度范围内得以保持。\n\n需要计算的量：\n- 将在最终时刻 $ T $ 的透射概率定义为势垒右侧（即 $ x > a/2 $）概率密度的离散积分，\n$$\n\\mathcal{T} \\;=\\; \\int_{x>a/2} |\\psi(x,T)|^2\\,dx,\n$$\n实现为在间距为 $ \\Delta x $ 的网格上的黎曼和。报告 $ \\mathcal{T} $ 的值，四舍五入到六位小数。\n\n测试套件：\n- 对 $ L $、$ N $、$ \\Delta t $、$ T $、$ x_0 $、$ \\sigma $ 和 $ k_0 $ 使用上述固定设置。\n- 对以下三组参数 $ (V_0, a) $ 评估求解器：\n  1. $ (0.5,\\,5.0) $：势垒高度低于波包的名义中心动能，这是一个“理想路径”下的透射主导情况。\n  2. $ (1.3,\\,5.0) $：势垒高度略高于中心动能，这是一个隧穿主导的情况。\n  3. $ (0.0,\\,5.0) $：零高度势垒，这是一个应产生接近于1的透射率的边缘情况。\n- 对于每种情况，计算如上定义的相应透射概率 $ \\mathcal{T} $。\n\n最终程序输出格式：\n- 您的程序应生成单行输出，其中包含按上述顺序列出的三个透射概率，每个概率都四舍五入到六位小数，形式为方括号括起来的逗号分隔列表，例如：\n`\"[0.952341,0.007812,0.999998]\"`。\n不允许有任何其他输出。\n\n在所选的原子单位制下，所有物理量都是无量纲的。所有角度都以弧度为单位。最终的数值答案必须是四舍五入到六位小数的浮点数。", "solution": "对问题陈述进行严格验证。\n\n步骤 1：提取给定条件\n- **控制方程**：一维含时薛定谔方程，采用原子单位制（$\\hbar=1$, $m=1$）：\n$$\ni\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t)\n$$\n- **离散化参数**：\n  - 空间域长度：$L = 100$。\n  - 格点数：$N = 1024$。\n  - 网格间距：$\\Delta x = L/N$。\n  - 空间网格：$x_j \\in [-L/2, L/2)$。\n  - 边界条件：周期性。\n  - 时间步长：$\\Delta t = 0.01$。\n  - 总模拟时间：$T = 30$。\n- **初始条件 ($t=0$)**：\n  - 波函数形式：$\\psi(x,0) = C\\,\\exp\\left(-\\frac{(x-x_0)^2}{4\\sigma^2}\\right)\\,\\exp(i\\,k_0\\,x)$。\n  - 平均位置：$x_0 = -L/4$。\n  - 空间宽度：$\\sigma = 1$。\n  - 中心波数：$k_0 = 1.5$。\n  - 归一化：$\\int_{-L/2}^{L/2} |\\psi(x,0)|^2\\,dx = 1$，需要在离散网格上以数值方式执行。\n- **势垒**：\n  - 函数形式：一个矩形势垒，\n  $$\n  V(x) \\;=\\; \\begin{cases}\n  V_0, & |x| \\le a/2,\\\\\n  0, & \\text{otherwise}.\n  \\end{cases}\n  $$\n  - 参数：高度 $V_0 \\ge 0$，宽度 $a \\ge 0$。\n- **数值方法**：\n  - 二阶、时间可逆的分步傅里叶方法。\n  - 动能演化在傅里叶空间中使用 Cooley–Tukey FFT 算法执行。\n- **需要计算的量**：\n  - 在 $t=T$ 时的透射概率：$\\mathcal{T} = \\int_{x>a/2} |\\psi(x,T)|^2\\,dx$，实现为离散求和。\n- **测试套件**：\n  - 情况 1：$(V_0, a) = (0.5, 5.0)$。\n  - 情况 2：$(V_0, a) = (1.3, 5.0)$。\n  - 情况 3：$(V_0, a) = (0.0, 5.0)$。\n\n步骤 2：使用提取的给定条件进行验证\n- **科学依据**：该问题基于量子力学的基本原理——薛定谔方程。波包隧穿的物理情景是一个典型问题。所提出的数值技术，即分步傅里叶方法，是求解此类偏微分方程的标准且稳健的算法。在计算物理学中，使用原子单位制是一种常见且有效的简化方法。该问题在科学上是合理的。\n- **适定性**：模拟所需的所有参数（$L$, $N$, $\\Delta t$, $T$）以及定义初始状态和势的参数均已提供。初值问题是适定的。要计算的量（$\\mathcal{T}$）也已明确指定。\n- **客观性**：问题陈述使用了精确的数学和物理术语，没有主观或含糊不清的表述。\n- **综合评估**：该问题不违反任何无效性标准。它是一个完整、一致且适定的计算物理学问题。\n\n步骤 3：结论与行动\n该问题是**有效的**。将推导并实现一个解法。\n\n含时薛定谔方程由下式给出\n$$\ni\\,\\frac{\\partial \\psi(x,t)}{\\partial t} = \\hat{H}\\psi(x,t)\n$$\n其中哈密顿算符 $\\hat{H}$ 是动能算符 $\\hat{T}$ 和势能算符 $\\hat{V}$ 的和。在给定的单位制（$\\hbar=1$, $m=1$）下，它们是：\n$$\n\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}, \\quad \\hat{V} = V(x)\n$$\n波函数在一个小时间步长 $\\Delta t$ 内演化的形式解是\n$$\n\\psi(x, t + \\Delta t) = e^{-i\\hat{H}\\Delta t} \\psi(x,t) = e^{-i(\\hat{T} + \\hat{V})\\Delta t} \\psi(x,t)\n$$\n由于动能算符和势能算符不对易，即 $[\\hat{T}, \\hat{V}] \\neq 0$，指数的和不能简单地分解。分步法为时间演化算符提供了一个近似。问题指定了一个二阶精确的对称格式（Strang 分裂）：\n$$\ne^{-i(\\hat{T} + \\hat{V})\\Delta t} \\approx e^{-i\\hat{V}\\frac{\\Delta t}{2}} e^{-i\\hat{T}\\Delta t} e^{-i\\hat{V}\\frac{\\Delta t}{2}}\n$$\n对于单步而言，此近似的精度为 $\\mathcal{O}(\\Delta t^3)$ 阶，并且是幺正的，因此能保持波函数的范数，这对于物理上的一致性至关重要。从 $t=0$ 到 $t=T$ 的完整时间演化是通过将此操作应用 $M = T/\\Delta t$ 次来实现的。\n\n该算法通过实现分裂算符的每个部分来进行：\n1.  **势能演化**：算符 $e^{-i\\hat{V}\\frac{\\Delta t}{2}}$ 涉及势能 $V(x)$，它是位置 $x$ 的函数。在位置表象中，此算符是对角的。其作用是一个简单的乘法：\n    $$\n    \\psi(x,t) \\rightarrow e^{-iV(x)\\frac{\\Delta t}{2}} \\psi(x,t)\n    $$\n2.  **动能演化**：算符 $e^{-i\\hat{T}\\Delta t}$ 包含一个二阶导数，这使其在位置表象中成为非局域的，难以应用。然而，傅里叶变换可将动量（并因此将动能）算符对角化。令 $\\tilde{\\psi}(k,t)$ 为 $\\psi(x,t)$ 的傅里叶变换：\n    $$\n    \\tilde{\\psi}(k,t) = \\mathcal{F}\\{\\psi(x,t)\\} = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} \\psi(x,t) e^{-ikx} dx\n    $$\n    在傅里叶空间中，动能算符变成了一个简单的乘法，乘以 $\\frac{k^2}{2}$。因此，动能演化步骤为：\n    $$\n    \\tilde{\\psi}(k,t) \\rightarrow e^{-i\\frac{k^2}{2}\\Delta t} \\tilde{\\psi}(k,t)\n    $$\n    要实现这一点，必须：\n    a.  将波函数变换到傅里叶空间：$\\psi(x) \\rightarrow \\tilde{\\psi}(k) = \\text{FFT}(\\psi(x))$。\n    b.  在傅里叶空间中应用动能演化相位因子。\n    c.  变换回位置空间：$\\tilde{\\psi}(k) \\rightarrow \\psi(x) = \\text{IFFT}(\\tilde{\\psi}(k))$。\n问题要求使用 Cooley-Tukey 算法，这是 NumPy 等数值库中快速傅里叶变换 (FFT) 的标准实现。\n\n数值实现需要对所有连续变量进行离散化。\n- **空间网格**：将域 $[-L/2, L/2)$ 离散化为 $N$ 个点 $x_j = -L/2 + j\\Delta x$（对于 $j=0, \\dots, N-1$），网格间距为 $\\Delta x = L/N$。波函数由其在这些点上的值组成的向量 $\\psi_j = \\psi(x_j)$ 表示。\n- **波数网格**：为了与在长度为 $L$、包含 $N$ 个点的域上的离散傅里叶变换保持一致，相应的波数网格 $k_n$ 由 $k_n = 2\\pi f_n$ 给出，其中 $f_n$ 是标准 FFT 例程提供的频率。对于 $\\Delta x$ 的采样间距，这些频率为 $f_n = n/(N\\Delta x)$（对于 $n = 0, \\dots, N/2-1$）和 $f_n = (n-N)/(N\\Delta x)$（对于 $n=N/2, \\dots, N-1$）。这种排序由 `numpy.fft.fftfreq` 函数处理。\n- **初始条件**：初始波包在空间网格 $x_j$ 上构建：\n$$\n\\psi_j(0) = C \\exp\\left(-\\frac{(x_j - x_0)^2}{4\\sigma^2}\\right) \\exp(i k_0 x_j)\n$$\n归一化常数 $C$ 是通过数值方法强制执行条件 $\\sum_{j=0}^{N-1} |\\psi_j(0)|^2 \\Delta x = 1$ 来找到的。这给出 $C = 1 / \\sqrt{\\sum_{j=0}^{N-1} \\left|\\exp\\left(-\\frac{(x_j - x_0)^2}{4\\sigma^2}\\right) \\exp(i k_0 x_j)\\right|^2 \\Delta x}$。\n- **势垒**：矩形势 $V(x)$ 在空间网格 $x_j$ 上定义。对于给定的 $V_0$ 和 $a$，如果 $|x_j| \\le a/2$，则 $V_j = V_0$，否则 $V_j = 0$。\n\n传播算法如下：\n1.  初始化参数：$L=100$, $N=1024$, $\\Delta t=0.01$, $T=30$。计算 $\\Delta x = L/N$ 和步数 $M = \\text{int}(T/\\Delta t)$。\n2.  构建空间网格 $x_j$ 和波数网格 $k_n$。\n3.  对于每个测试用例 $(V_0, a)$：\n    a. 构建势能数组 $V_j$。\n    b. 构建初始波函数数组 $\\psi_j(0)$ 并对其进行数值归一化。\n    c. 预先计算演化算符：$U_V = \\exp(-i V_j \\Delta t/2)$ 和 $U_T = \\exp(-i k_n^2 \\Delta t/2)$。\n    d. 在一个从 $m=0$ 到 $M-1$ 的循环中进行演化：\n        i.   应用第一步势能演化的半步：$\\psi \\leftarrow \\psi \\cdot U_V$。\n        ii.  变换到k空间：$\\tilde{\\psi} \\leftarrow \\text{FFT}(\\psi)$。\n        iii. 应用动能步：$\\tilde{\\psi} \\leftarrow \\tilde{\\psi} \\cdot U_T$。\n        iv.  变换到x空间：$\\psi \\leftarrow \\text{IFFT}(\\tilde{\\psi})$。\n        v.   应用第二步势能演化的半步：$\\psi \\leftarrow \\psi \\cdot U_V$。\n4.  在最终时刻 $T$，波函数为 $\\psi_j(T)$。\n5.  通过对势垒右侧格点上的概率密度求和来计算透射概率 $\\mathcal{T}$：\n    $$\n    \\mathcal{T} = \\sum_{j \\text{ where } x_j > a/2} |\\psi_j(T)|^2 \\Delta x\n    $$\n对给定的三组参数 $(V_0, a)$ 中的每一组重复此过程。波包的中心动能为 $E_k = k_0^2/2 = (1.5)^2/2 = 1.125$。所选的势垒高度分别低于（$V_0=0.5$）、高于（$V_0=1.3$）和等于零（相对于此能量），从而分别正确地探究了经典透射、量子隧穿和自由传播的机制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a numerical solver for 1D quantum tunneling\n    of a Gaussian wavepacket through a rectangular potential barrier using the\n    split-step Fourier method.\n    \"\"\"\n\n    # Discretization and numerical design parameters\n    L = 100.0         # Spatial domain length\n    N = 1024          # Number of grid points\n    dx = L / N        # Spatial grid spacing\n    x = np.arange(-L/2, L/2, dx) # Spatial grid\n\n    # Wavenumber grid consistent with numpy's FFT\n    # k = 2 * pi * f, where f are the frequencies from fftfreq\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Initial condition parameters\n    x0 = -L / 4.0     # Mean position\n    sigma = 1.0       # Spatial width\n    k0 = 1.5          # Central wavenumber\n\n    # Time stepping parameters\n    dt = 0.01         # Time step\n    T = 30.0          # Total simulation time\n    num_steps = int(T / dt)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.5, 5.0),  # V0, a: Barrier height < central energy\n        (1.3, 5.0),  # V0, a: Barrier height > central energy (tunneling)\n        (0.0, 5.0),  # V0, a: Zero-height barrier (free propagation)\n    ]\n\n    results = []\n    \n    # Pre-compute the kinetic energy evolution operator (independent of V0, a)\n    # This is U_T = exp(-i * T_op * dt) where T_op = k^2 / 2\n    kinetic_evolution_op = np.exp(-1j * k**2 * dt / 2.0)\n\n    for V0, a in test_cases:\n        # 1. Set up the potential barrier\n        V = np.zeros_like(x)\n        V[np.abs(x) <= a / 2.0] = V0\n        \n        # Pre-compute the potential energy evolution operator for this case\n        # This is U_V = exp(-i * V_op * dt/2)\n        potential_evolution_op = np.exp(-1j * V * dt / 2.0)\n\n        # 2. Set up the initial wavefunction\n        # Un-normalized Gaussian wavepacket\n        psi_0_unnormalized = np.exp(-(x - x0)**2 / (4 * sigma**2)) * np.exp(1j * k0 * x)\n        \n        # Numerically normalize the wavefunction\n        norm_squared = np.sum(np.abs(psi_0_unnormalized)**2) * dx\n        C = 1.0 / np.sqrt(norm_squared)\n        psi = C * psi_0_unnormalized\n        psi = psi.astype(np.complex128)\n\n        # 3. Time evolution using the split-step Fourier method\n        for _ in range(num_steps):\n            # First half potential step\n            psi = psi * potential_evolution_op\n\n            # Full kinetic step in Fourier space\n            psi_k = np.fft.fft(psi)\n            psi_k = psi_k * kinetic_evolution_op\n            psi = np.fft.ifft(psi_k)\n\n            # Second half potential step\n            psi = psi * potential_evolution_op\n        \n        # 4. Compute the transmission probability\n        # Find indices for x > a/2\n        transmission_indices = np.where(x > a / 2.0)\n        \n        # Calculate probability density in the transmission region\n        prob_density_transmitted = np.abs(psi[transmission_indices])**2\n        \n        # Integrate (sum) over the transmission region\n        transmission_probability = np.sum(prob_density_transmitted) * dx\n        \n        results.append(round(transmission_probability, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2383392"}]}