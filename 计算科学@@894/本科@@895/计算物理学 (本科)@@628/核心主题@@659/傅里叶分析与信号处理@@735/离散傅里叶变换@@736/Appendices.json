{"hands_on_practices": [{"introduction": "掌握任何一个强大的数学工具，第一步都是理解其基本定义。本练习旨在通过一个具体的4点离散傅里叶变换（DFT）计算，让你亲手实践DFT的求和公式。这个过程不仅能加深你对变换过程本身的理解，还能锻炼你处理复数运算和单位根的能力，为之后学习更高效的算法（如快速傅里叶变换FFT）打下坚实的数学基础。[@problem_id:2213509]", "problem": "在数字信号处理中，离散傅里叶变换 (DFT) 是一种基本工具，用于将有限个数据点序列分解为其组成频率分量。\n\n考虑一个由 $N=4$ 个样本序列表示的离散时间复信号：$x_0 = 1$，$x_1 = 2j$，$x_2 = 3$ 以及 $x_3 = -j$，其中 $j = \\sqrt{-1}$。\n\n序列 $x_n$（其中 $n=0, 1, \\dots, N-1$）的 $N$ 点 DFT 是一个序列 $X_k$（其中 $k=0, 1, \\dots, N-1$），由以下分析方程给出：\n$$X_k = \\sum_{n=0}^{N-1} x_n \\exp\\left(-j \\frac{2\\pi nk}{N}\\right)$$\n计算给定信号 $x_n$ 的 4 点 DFT 序列 $X_k = [X_0, X_1, X_2, X_3]$。你的最终答案应该是一个包含四个复数的序列，以单行矩阵的形式呈现。", "solution": "我们对 $N=4$ 使用 DFT 分析方程：\n$$X_{k}=\\sum_{n=0}^{3}x_{n}\\exp\\left(-j\\frac{2\\pi nk}{4}\\right), \\quad k=0,1,2,3.$$\n定义 $4$ 次本原单位根 $W=\\exp\\left(-j\\frac{2\\pi}{4}\\right)=\\exp(-j\\frac{\\pi}{2})=-j$。则 $W^{0}=1$，$W^{1}=-j$，$W^{2}=-1$，$W^{3}=j$，且 $W^{4}=1$。\n\n对于 $k=0$：\n$$X_{0}=x_{0}W^{0\\cdot 0}+x_{1}W^{1\\cdot 0}+x_{2}W^{2\\cdot 0}+x_{3}W^{3\\cdot 0}=1+2j+3+(-j)=4+j.$$\n\n对于 $k=1$：\n$$X_{1}=x_{0}W^{0}+x_{1}W^{1}+x_{2}W^{2}+x_{3}W^{3}=1+(2j)(-j)+3(-1)+(-j)(j)=1+2-3+1=1.$$\n\n对于 $k=2$：\n$$X_{2}=x_{0}W^{0}+x_{1}W^{2}+x_{2}W^{4}+x_{3}W^{6}=1+(2j)(-1)+3(1)+(-j)(-1)=(1+3)+(-2j+j)=4-j.$$\n\n对于 $k=3$：\n$$X_{3}=x_{0}W^{0}+x_{1}W^{3}+x_{2}W^{6}+x_{3}W^{9}=1+(2j)(j)+3(-1)+(-j)(-j)=1-2-3-1=-5.$$\n\n因此，该 4 点 DFT 序列为\n$$\\begin{pmatrix}4+j & 1 & 4-j & -5\\end{pmatrix}.$$", "answer": "$$\\boxed{\\begin{pmatrix}4+j & 1 & 4-j & -5\\end{pmatrix}}$$", "id": "2213509"}, {"introduction": "在理解了DFT的计算方法之后，下一步是建立数学公式与物理直觉之间的联系。本练习使用了一个非常特殊的信号 $x[n]=(-1)^n$，它代表了在给定采样率下可以无歧义表示的最高频率——奈奎斯特频率。通过计算它的DFT，你将亲眼见证一个信号的全部能量如何集中在单一的频率分量上，从而直观地理解“频率成分”的真正含义。[@problem_id:1759605]", "problem": "一个离散时间测试信号 $x[n]$ 被生成，用以表征一个数字系统的频率响应。该信号定义在一个对应于 $N$ 个采样点的有限时长上，从 $n=0$ 到 $n=N-1$，其中 $N$ 是一个偶正整数。该信号由交替序列 $x[n] = (-1)^n$ 给出。\n\n为分析该信号的频率成分，我们计算其 $N$ 点离散傅里叶变换 (DFT)，记为 $X[k]$。DFT 的定义如下：\n$$ X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi k n}{N}\\right) $$\n其中 $j$ 是虚数单位，$k$ 是频率指数，为一个从 $0$ 到 $N-1$ 的整数。\n\n确定在特定频率指数 $k = N/2$ 处的 DFT 系数值。请用 $N$ 来表示你的答案。", "solution": "我们给定的离散时间信号为 $x[n]=(-1)^{n}$，$n=0,1,\\ldots,N-1$，其中 $N$ 为偶数，其 $N$ 点 DFT 定义为\n$$\nX[k]=\\sum_{n=0}^{N-1} x[n]\\exp\\left(-j\\frac{2\\pi k n}{N}\\right).\n$$\n我们需要计算 $X[k]$ 在 $k=\\frac{N}{2}$ 处的值。代入 $k=\\frac{N}{2}$ 和 $x[n]=(-1)^{n}$ 可得\n$$\nX\\left[\\frac{N}{2}\\right]=\\sum_{n=0}^{N-1}(-1)^{n}\\exp\\left(-j\\frac{2\\pi \\left(\\frac{N}{2}\\right) n}{N}\\right)\n=\\sum_{n=0}^{N-1}(-1)^{n}\\exp\\left(-j\\pi n\\right).\n$$\n使用 Euler 公式，对于整数 $n$ 我们有\n$$\n\\exp\\left(-j\\pi n\\right)=\\cos(\\pi n)-j\\sin(\\pi n)=(-1)^{n},\n$$\n因为 $\\sin(\\pi n)=0$ 且 $\\cos(\\pi n)=(-1)^{n}$。因此，被加数项可简化为\n$$\n(-1)^{n}\\exp\\left(-j\\pi n\\right)=(-1)^{n}\\cdot(-1)^{n}=(-1)^{2n}=1.\n$$\n于是，\n$$\nX\\left[\\frac{N}{2}\\right]=\\sum_{n=0}^{N-1}1=N.\n$$\n因此，在 $k=\\frac{N}{2}$ 处的 DFT 系数等于 $N$。", "answer": "$$\\boxed{N}$$", "id": "1759605"}, {"introduction": "理论学习的最终目的是应用于实践。虽然直接计算DFT具有教育意义，但其 $\\mathcal{O}(N^2)$ 的复杂度在实际应用中显得过于缓慢。本练习将引导你完成从理论到编码的飞跃：亲手实现作为现代信号处理基石的高效算法——快速傅里叶变换（FFT）。更进一步，你将应用自己编写的程序来验证卷积定理和帕塞瓦尔恒等式等基本定理，从而将抽象的理论与可验证的计算实践紧密联系起来。[@problem_id:2387187]", "problem": "设 $N$ 是一个正整数，其形式为 $N = 2^m$，其中 $m$ 为某个非负整数。对于一个长度为 $N$ 的复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$，其离散傅里叶变换 (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ 定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi j \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\n其逆离散傅里叶变换 (IDFT) 定义为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi j \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。\n\n编写一个完整的程序，在不调用任何库傅里叶变换例程的情况下，计算长度为 $N = 2^m$ 的序列的 DFT 和 IDFT。您的程序还必须仅使用这些定义，通过显式测试用例验证以下基本性质：\n\n- 循环卷积定理：对于长度为 $N$ 的序列 $a$ 和 $b$，它们的长度为 $N$ 的循环卷积 $c$ 定义为 $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$，满足 $C_k = A_k B_k$，其中 $A$、$B$ 和 $C$ 分别是 $a$、$b$ 和 $c$ 的 DFT。\n- Parseval 恒等式 (使用上述归一化)：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n\n您的程序必须实现自己的快速算法来计算 $N = 2^m$ 时的 DFT 和 IDFT，并且必须包含一个直接的 $\\mathcal{O}(N^2)$ DFT 用于验证。在需要布尔验证的地方，使用数值容差 $\\varepsilon = 10^{-9}$。所有角度必须以弧度为单位进行解释。\n\n使用以下测试套件，并按下面给出的顺序生成输出：\n\n- 测试 1 (DFT 正确性与直接 DFT 对比，正常路径)：设 $N = 8$ 且 $x = [0,1,2,3,4,3,2,1]$。使用您的快速实现计算 $X$，并使用直接 DFT 计算 $\\tilde{X}$。如果 $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 2 (逆变换恢复)：使用与测试 1 相同的 $N$ 和 $x$，将您的 IDFT 应用于快速实现得到的 $X$ 来计算 $x'$。如果 $\\max_n |x'_n - x_n| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 3 (通过频域的循环卷积)：设 $N = 8$，$a = [1,2,3,0,0,0,0,0]$，$b = [0,1,0,0,0,0,0,0]$。直接根据其定义计算长度为 $N$ 的循环卷积 $c$。另外，通过计算 $a$ 和 $b$ 的 DFT，进行逐点相乘，然后应用 IDFT 来计算 $\\hat{c}$。以浮点数形式输出标量 $\\max_n |c_n - \\hat{c}_n|$。\n- 测试 4 (Parseval 恒等式)：设 $N = 16$ 且 $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$，其中 $n = 0,1,\\dots,15$。使用您的快速实现计算 $X$。以浮点数形式输出标量 $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$。\n- 测试 5 (边界情况 $N=1$)：设 $N = 1$ 且 $x = [3 + 4j]$。计算 $X$，然后通过 IDFT 计算 $x'$。如果 $|x'_0 - x_0| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 6 (最小非平凡尺寸 $N=2$)：设 $N = 2$ 且 $x = [1,-1]$。使用您的快速实现计算 $X$。在给定约定下，精确的 DFT 是 $[0,2]$。以浮点数形式输出标量 $\\max_k |X_k - [0,2]_k|$。\n\n最终输出格式：您的程序应生成单行输出，其中包含六个结果，按顺序排列，以逗号分隔，并用方括号括起来，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$。所有布尔条目必须是 $\\text{True}$ 或 $\\text{False}$，所有实值条目必须以标准十进制或科学记数法打印。不应打印任何其他文本。", "solution": "所提出的问题是一项定义明确且科学严谨的计算物理练习，尤其是在信号处理领域。它要求实现和验证离散傅里叶变换 (DFT)、其逆变换 (IDFT) 以及相关的基本定理。该问题是完整的、客观的，并且其解决方案是可验证的。我们将着手解决。\n\n问题的核心是计算给定长度为 $N$ 的离散复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$ 的 DFT $X$。其定义如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi j \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\n该公式的直接实现涉及两个嵌套循环，一个针对从 $0$ 到 $N-1$ 的每个索引 $k$，另一个针对从 $0$ 到 $N-1$ 的每个索引 $n$。这导致计算复杂度为 $\\mathcal{O}(N^2)$，对于大的 $N$ 来说效率低下。为了验证，我们将实现这样一种直接方法。\n\n问题规定 $N$ 是 2 的幂，即 $N = 2^m$，其中 $m$ 是非负整数。这种结构是采用快速傅里叶变换 (FFT) 算法的关键，特别是 Cooley-Tukey 时域抽取算法。该算法将复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N \\log N)$。其原理是分治法。长度为 $N$ 的 DFT 被递归地分解为两个长度为 $(N/2)$ 的 DFT。\n\n将序列 $x_n$ 分解为其偶数索引元素，形成序列 $x'_m = x_{2m}$，和其奇数索引元素，形成序列 $x''_m = x_{2m+1}$，每个序列的长度都为 $N/2$。DFT 的求和可以重写为：\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi j k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi j k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi j k m / (N/2)} + e^{-2\\pi j k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi j k m / (N/2)}\n$$\n设 $X'_k$ 和 $X''_k$ 分别是 $x'_m$ 和 $x''_m$ 的长度为 $(N/2)$ 的 DFT。上述表达式变为：\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\n其中 $W_N^k = e^{-2\\pi j k/N}$ 是“旋转因子”。对于索引的前半部分，$0 \\le k < N/2$，我们有：\n$$\nX_k = X'_k + W_N^k X''_k\n$$\n对于后半部分，其中索引为 $k+N/2$（$0 \\le k < N/2$），我们利用性质 $X'_{k+N/2} = X'_k$、$X''_{k+N/2} = X''_k$ 和 $W_N^{k+N/2} = -W_N^k$。这得到：\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\n这个递归定义允许构建完整的 DFT。递归在基例 $N=1$ 处终止，此时序列 $\\{x_0\\}$ 的 DFT 就是 $\\{X_0\\} = \\{x_0\\}$。我们的实现将遵循这种递归结构。\n\n逆离散傅里叶变换 (IDFT) 定义为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi j \\, k n / N}\n$$\n无需单独实现。我们可以将 IDFT 与正向 DFT 联系起来。观察以下推导：\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi j k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi j k n / N}\n$$\n右侧是复共轭序列 $\\{\\overline{X_k}\\}_{k=0}^{N-1}$ 的 DFT。因此，我们可以通过计算 $\\overline{X}$ 的 DFT，对结果取复共轭，再乘以 $1/N$ 来求得 $x_n$。即 $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$。这使我们也能使用高效的 FFT 实现来计算逆变换 (IFFT)。\n\n该问题进一步要求验证两个基本定理。\n\n首先是循环卷积定理。两个长度为 $N$ 的序列 $a$ 和 $b$ 的循环卷积 $c$ 由 $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$ 给出。该定理指出，卷积的 DFT 是单个 DFT 的逐点乘积：$C_k = A_k B_k$。因此，可以通过频域计算 $c$：$c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$，其中 $\\odot$ 表示逐元素乘法。我们将通过直接计算 $c$ 和通过频域路径计算 $c$ 并比较结果来对此进行测试。\n\n第二是 Parseval 恒等式。对于给定的 DFT 归一化，该恒等式为：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n该定理将信号在时域中的总能量与其在频域中的能量联系起来。我们将对一个特定的测试信号验证这一点。\n\n程序将首先定义必要的函数：一个直接的 $\\mathcal{O}(N^2)$ DFT，一个递归的 $\\mathcal{O}(N \\log N)$ FFT，一个基于 FFT 的 IFFT，以及一个直接的循环卷积函数。然后，它将使用这些函数和 $\\varepsilon = 10^{-9}$ 的数值容差来执行 6 个指定的测试用例。结果将被收集并以所需格式打印。", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N <= 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 <= epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 <= epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 <= epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}]}