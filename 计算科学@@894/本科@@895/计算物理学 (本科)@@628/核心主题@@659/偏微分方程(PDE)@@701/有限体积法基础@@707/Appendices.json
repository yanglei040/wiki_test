{"hands_on_practices": [{"introduction": "守恒性是有限体积方法 (Finite Volume Method, FVM) 的基石，它确保了离散格式在全局意义上精确地维持了物理量的总量。本练习将通过一个巧妙的思想实验来探索这一核心原则：我们将故意构建一个在每个单元交界面上引入微小不守恒量的数值格式 [@problem_id:2394360]。通过从第一性原理推导并用代码验证由此产生的全局质量误差的累积，您将深刻体会到为什么严格的通量守恒对 FVM 的可靠性至关重要。", "problem": "您的任务是分析并实现一个一维有限体积法 (FVM)，该方法在每个面上故意引入微小的量以违反守恒性，并量化由此产生的全局质量误差增长。考虑一维空间中的线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n其定义在周期性域 $[0,L]$ 上，具有恒定的平流速度 $a > 0$。使用包含 $N$ 个控制体的均匀网格，每个控制体宽度为 $\\Delta x = L/N$。将时间层 $n$ 时单元 $i$ 中的单元平均值记为 $U_i^n$。每个单元的 FVM 半离散平衡方程为\n$$\n\\frac{d U_i}{d t} = - \\frac{1}{\\Delta x} \\left( F_{i+\\frac{1}{2}}^{(i)} - F_{i-\\frac{1}{2}}^{(i)} \\right),\n$$\n其向前欧拉时间离散格式为\n$$\nU_i^{n+1} = U_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+\\frac{1}{2}}^{(i),n} - F_{i-\\frac{1}{2}}^{(i),n} \\right).\n$$\n对于基础数值通量，当 $a>0$ 时使用一阶迎风格式：\n$$\n\\widehat{F}_{i+\\frac{1}{2}}^n = a\\, U_i^n.\n$$\n引入一个故意的非守恒扰动，具体如下：在每个面 $i+\\tfrac{1}{2}$ 处，为其两侧的相邻单元使用两个不同的通量值，使得左侧单元 $i$ 使用\n$$\nF_{i+\\frac{1}{2}}^{(i),n} = \\widehat{F}_{i+\\frac{1}{2}}^n + \\epsilon,\n$$\n而右侧单元 $i+1$ 使用\n$$\nF_{i+\\frac{1}{2}}^{(i+1),n} = \\widehat{F}_{i+\\frac{1}{2}}^n,\n$$\n其中 $\\epsilon$ 是一个微小的恒定偏差，对于所有面和所有时间步均相同。这种选择使得离散格式在每个时间步的每个面上都存在一个固定的不匹配量 $\\epsilon$，从而故意使其非守恒。对所有面上的量使用周期性索引。\n\n任务：\n1. 从守恒方程的积分形式、FVM 更新格式以及上述非守恒通量构造出发，从第一性原理推导全局质量漂移的闭式表达式\n$$\n\\Delta M(T) = M(T) - M(0), \\quad M(t) \\equiv \\sum_{i=0}^{N-1} U_i(t)\\,\\Delta x,\n$$\n它应表示为面的数量 $N_{\\text{faces}}$、偏差 $\\epsilon$ 和最终时间 $T$ 的函数。假设 $\\epsilon$ 在时间和空间上是常数，并且时间步长 $\\Delta t$ 和步数 $n_{\\text{steps}}$ 满足 $T = n_{\\text{steps}} \\Delta t$。请将 $\\Delta M(T)$ 表示为 $N_{\\text{faces}}$、$\\epsilon$ 和 $T$ 的函数。\n\n2. 实现一个程序，该程序：\n   - 在单元中心 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ 处初始化解，其值为\n     $$\n     U_i^0 = \\sin\\left( \\frac{2\\pi x_i}{L} \\right) + 0.5.\n     $$\n   - 使用上述非守恒通量、显式欧拉时间步进和周期性边界，将解推进 $n_{\\text{steps}}$ 步，时间步长为 $\\Delta t = \\text{CFL}\\,\\Delta x/a$，其中 $\\text{CFL}\\in(0,1]$ 是给定的 Courant–Friedrichs–Lewy 数。\n   - 计算测量的全局质量漂移 $\\Delta M_{\\text{meas}} = M(T) - M(0)$，并将其与任务1中分析预测的漂移 $\\Delta M_{\\text{pred}}$ 进行比较。\n\n3. 对于下方的每个测试用例，返回标量差\n$$\n\\delta = \\Delta M_{\\text{meas}} - \\Delta M_{\\text{pred}},\n$$\n结果应为一个浮点数。\n\n所有量均为无量纲。角度以弧度为单位。没有需要转换的物理单位。\n\n测试套件（每个元组为 $(N, L, a, \\epsilon, \\text{CFL}, n_{\\text{steps}})$）：\n- 用例 A: $(50, 1.0, 1.0, 1.0\\times 10^{-6}, 0.6, 100)$。\n- 用例 B: $(1, 1.0, 1.0, 2.0\\times 10^{-7}, 0.4, 1000)$。\n- 用例 C: $(10, 2.0, 0.5, -1.0\\times 10^{-6}, 0.8, 250)$。\n- 用例 D: $(37, 1.5, 1.0, 0.0, 0.7, 123)$。\n\n附加说明：\n- 对所有测试用例使用周期性边界，并设 $N_{\\text{faces}}=N$。\n- 通过使用 $a>0$ 和 $\\text{CFL}\\leq 1$ 确保稳定性。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[r_A,r_B,r_C,r_D]”），其中每个 $r_\\cdot$ 是对应指定测试用例的 $\\delta$ 值，以标准浮点数格式打印。", "solution": "我们从控制体中标量守恒的积分形式出发。对于单元宽度为 $\\Delta x$、单元索引为 $i$ 的均匀网格，具有恒定速度 $a$ 的一维线性平流方程的积分形式可得到半离散有限体积法 (FVM)\n$$\n\\frac{dU_i}{dt} = -\\frac{1}{\\Delta x}\\left( F_{i+\\frac{1}{2}}^{(i)} - F_{i-\\frac{1}{2}}^{(i)} \\right),\n$$\n其中 $F_{i+\\frac{1}{2}}^{(i)}$ 表示单元 $i$ 在其右侧面 $i+\\tfrac{1}{2}$ 处使用的数值通量，$F_{i-\\frac{1}{2}}^{(i)}$ 是单元 $i$ 在其左侧面 $i-\\tfrac{1}{2}$ 处使用的数值通量。向前欧拉时间离散化形式为\n$$\nU_i^{n+1} = U_i^{n} - \\frac{\\Delta t}{\\Delta x}\\left( F_{i+\\frac{1}{2}}^{(i),n} - F_{i-\\frac{1}{2}}^{(i),n} \\right).\n$$\n对于一个守恒的 FVM，我们强制要求每个内部面 $i+\\tfrac{1}{2}$ 贡献一个单一的通量值，该值被其相邻的两个单元以相反的符号使用，从而在对所有单元求和时通过项的对消来保证全局守恒。在这里，我们通过在每个面 $i+\\tfrac{1}{2}$ 处定义两种不同的通量用法来故意违反这一点：\n- 对于左侧单元 $i$，我们取\n$$\nF_{i+\\frac{1}{2}}^{(i),n} = \\widehat{F}_{i+\\frac{1}{2}}^n + \\epsilon,\n$$\n- 对于右侧单元 $i+1$，我们取\n$$\nF_{i+\\frac{1}{2}}^{(i+1),n} = \\widehat{F}_{i+\\frac{1}{2}}^n,\n$$\n其中每个面在每个时间步上都有一个恒定的偏差 $\\epsilon$。基础通量 $\\widehat{F}_{i+\\frac{1}{2}}^n$ 是当 $a>0$ 时的标准迎风通量，\n$$\n\\widehat{F}_{i+\\frac{1}{2}}^n = a\\,U_i^n,\n$$\n当它被两个相邻单元相同时使用时，该格式是相容且守恒的。在周期性边界和均匀间距下，共有 $N$ 个面，我们将其统称为面的集合。\n\n时间层 $n$ 的全局质量为\n$$\nM^n = \\sum_{i=0}^{N-1} U_i^n \\,\\Delta x.\n$$\n将更新方程对所有单元求和，\n$$\n\\sum_{i=0}^{N-1}\\left(U_i^{n+1} - U_i^n\\right)\n= -\\frac{\\Delta t}{\\Delta x}\\sum_{i=0}^{N-1}\\left(F_{i+\\frac{1}{2}}^{(i),n} - F_{i-\\frac{1}{2}}^{(i),n}\\right).\n$$\n根据我们对非守恒通量的构造，单元 $i$ 的更新方程中，其右界面 $i+1/2$ 处的通量为 $F^{(i),n}_{i+1/2} = \\hat{F}^n_{i+1/2} + \\epsilon$，而其左界面 $i-1/2$ 处的通量为 $F^{(i),n}_{i-1/2} = \\hat{F}^n_{i-1/2}$ （因为单元 $i$ 是界面 $i-1/2$ 的右侧单元）。对所有单元求和，\n$$\n\\sum_{i=0}^{N-1} \\left( U_i^{n+1} - U_i^n \\right) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i=0}^{N-1} \\left( (\\hat{F}^n_{i+1/2} + \\epsilon) - \\hat{F}^n_{i-1/2} \\right).\n$$\n这是一个伸缩求和。由于周期性边界条件，$\\sum (\\hat{F}^n_{i+1/2} - \\hat{F}^n_{i-1/2}) = 0$。因此，\n$$\n\\sum_{i=0}^{N-1}\\left(U_i^{n+1} - U_i^n\\right) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i=0}^{N-1} \\epsilon = -\\frac{\\Delta t}{\\Delta x}\\, N_{\\text{faces}}\\,\\epsilon.\n$$\n两边同乘以 $\\Delta x$ 可得到每个时间步的全局质量变化\n$$\nM^{n+1} - M^n = -\\Delta t\\, N_{\\text{faces}}\\,\\epsilon.\n$$\n这表明每一步的质量漂移与解的值和空间离散宽度无关，仅取决于面的数量、时间步长和偏差 $\\epsilon$。在 $n_{\\text{steps}}$ 步（$\\Delta t$ 为常数）之后，总漂移为\n$$\n\\Delta M(T) \\equiv M(T) - M(0) = \\sum_{n=0}^{n_{\\text{steps}}-1} \\left(M^{n+1}-M^n\\right) = - n_{\\text{steps}} \\Delta t \\, N_{\\text{faces}}\\, \\epsilon = - T\\, N_{\\text{faces}}\\, \\epsilon,\n$$\n因为 $T = n_{\\text{steps}}\\Delta t$。在均匀网格的周期性边界条件下，$N_{\\text{faces}} = N$。因此，\n$$\n\\Delta M(T) = - T\\, N\\, \\epsilon.\n$$\n\n模拟的算法设计：\n- 在单元中心 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ 处初始化 $U_i^0 = \\sin\\left(\\frac{2\\pi x_i}{L}\\right) + 0.5$，其中 $i=0,\\dots,N-1$。\n- 选择 $\\Delta t = \\text{CFL}\\,\\Delta x / a$，其中 $a>0$ 且 $\\text{CFL}\\leq 1$，以满足通常的迎风格式稳定性限制。\n- 在每个时间步，使用周期性索引计算基础迎风通量 $\\widehat{F}_{i+\\frac{1}{2}}^n = a\\,U_i^n$（$i=0,\\dots,N-1$）。通过以下公式更新每个单元来应用非守恒用法\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left[ \\left(\\widehat{F}_{i+\\frac{1}{2}}^n + \\epsilon\\right) - \\widehat{F}_{i-\\frac{1}{2}}^n \\right],\n$$\n其中索引按 $N$ 取模。\n- 在 $n_{\\text{steps}}$ 步之后，使用 $M(t) = \\sum_i U_i(t)\\Delta x$ 计算测量的全局质量漂移 $\\Delta M_{\\text{meas}} = M(T) - M(0)$，并与预测的漂移 $\\Delta M_{\\text{pred}} = - T\\,N\\,\\epsilon$ 进行比较，以获得 $\\delta = \\Delta M_{\\text{meas}} - \\Delta M_{\\text{pred}}$。\n\n程序应该运行指定的测试套件：\n- 用例 A: $(N, L, a, \\epsilon, \\text{CFL}, n_{\\text{steps}}) = (50, 1.0, 1.0, 1.0\\times 10^{-6}, 0.6, 100)$,\n- 用例 B: $(1, 1.0, 1.0, 2.0\\times 10^{-7}, 0.4, 1000)$,\n- 用例 C: $(10, 2.0, 0.5, -1.0\\times 10^{-6}, 0.8, 250)$,\n- 用例 D: $(37, 1.5, 1.0, 0.0, 0.7, 123)$,\n\n并以“[r_A,r_B,r_C,r_D]”的格式输出单行结果，其中每个 $r_\\cdot$ 是该用例对应的浮点数 $\\delta$。由于对于所述构造的分析是精确的，因此在浮点舍入误差范围内，差值 $\\delta$ 应接近于零。", "answer": "```python\nimport numpy as np\n\ndef run_case(N, L, a, eps, CFL, n_steps):\n    # Spatial discretization\n    N = int(N)\n    dx = L / N\n    # Time step from CFL condition (assume a > 0 as per problem statement)\n    dt = CFL * dx / a\n    # Initialize solution: U_i^0 = sin(2*pi*x_i/L) + 0.5 at cell centers\n    i = np.arange(N)\n    x = (i + 0.5) * dx\n    U = np.sin(2.0 * np.pi * x / L) + 0.5\n\n    # Initial mass\n    M0 = dx * np.sum(U)\n\n    # Time stepping with non-conservative flux usage\n    for _ in range(n_steps):\n        # Base upwind fluxes at faces: F_hat[i] = a * U[i] for a > 0\n        F_hat = a * U.copy()\n        # Update: U^{n+1} = U^n - (dt/dx) * [ (F_hat[i] + eps) - F_hat[i-1] ]\n        # periodic indexing: F_hat[i-1] corresponds to np.roll(F_hat, 1)[i]\n        # This matches the derived non-conservative scheme:\n        # F_{i+1/2}^{(i),n} = \\hat{F}_{i+1/2}^n + \\epsilon\n        # F_{i-1/2}^{(i),n} = \\hat{F}_{i-1/2}^n\n        U = U - (dt / dx) * ((F_hat + eps) - np.roll(F_hat, 1))\n\n    # Final mass\n    M_end = dx * np.sum(U)\n\n    # Measured mass drift\n    dM_meas = M_end - M0\n    # Predicted mass drift: - T * N * eps, with T = n_steps * dt\n    T = n_steps * dt\n    dM_pred = - T * N * eps\n\n    # Return difference\n    return dM_meas - dM_pred\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (N, L, a, eps, CFL, n_steps)\n    test_cases = [\n        (50, 1.0, 1.0, 1.0e-6, 0.6, 100),    # Case A\n        (1, 1.0, 1.0, 2.0e-7, 0.4, 1000),    # Case B\n        (10, 2.0, 0.5, -1.0e-6, 0.8, 250),   # Case C\n        (37, 1.5, 1.0, 0.0, 0.7, 123),       # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, a, eps, CFL, n_steps = case\n        delta = run_case(N, L, a, eps, CFL, n_steps)\n        # For stable output, represent as a float string with sufficient precision\n        results.append(f\"{delta:.12e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2394360"}, {"introduction": "在理解了守恒性的重要之后，我们来应用一个简单且完全守恒的格式——一阶迎风格式——来解决基本的线性对流问题。本练习旨在揭示即便是正确的守恒格式也可能存在的固有缺陷：数值耗散 [@problem_id:2394306]。您将模拟一个阶梯函数随时间的演化，并以定量方式测量其在传播过程中逐渐模糊的“弥散宽度”，这是评估任何对流格式性能的一项关键实践技能。", "problem": "考虑一维线性平流方程，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\n其定义在长度为 $L$ 的周期性域上，即 $x \\in [0,L)$，并采用周期性边界条件。平流速度 $a$ 是一个正常数。从积分形式的守恒律和均匀网格上的有限体积平均的定义出发，推导一个与 $a>0$ 时信息传播的物理特性相符的一阶、显式、守恒的有限体积方法。\n\n您将通过模拟一个方块阶跃函数的平流，并量化界面随时间的展宽情况，来研究数值扩散。使用一个包含 $N$ 个单元的均匀网格，空间步长为 $\\Delta x = L/N$，单元中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，$i=0,1,\\dots,N-1$。设初始条件为方块函数\n$$\nu(x,0) = \\begin{cases}\n1, & x \\in [x_L, x_R),\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\n其中 $x_L = 0.2\\,L$ 且 $x_R = 0.7\\,L$。使用一阶有限体积格式演化该解，其显式时间步长 $\\Delta t$ 的选择应满足一个预设的 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$。在给定模拟的所有时间步中，使用相同的常数 $\\nu$。让模拟运行到一个预设的最终时间 $T$; 使用整数个时间步 $n = \\text{round}(T/\\Delta t)$，使得模拟时间为 $t_n = n\\,\\Delta t$。\n\n将在时间 $t_n$ 的下降界面的“展宽宽度”定义为：从单元中心廓线向下穿过 $\\theta_{\\text{hi}} = 0.9$ 水平的点，到其后向下穿过 $\\theta_{\\text{lo}} = 0.1$ 水平的点之间的最小空间距离（沿周期性域测量）。使用相邻单元中心的单元中心值进行线性插值来计算这些穿越点。如果存在多个下降界面（由于周期性），计算每个下降界面周围的展宽宽度并报告最小宽度。以与 $L$ 相同的无量纲长度单位表示该宽度。\n\n在单个程序中实现模拟和宽度测量。对于下方的每个测试用例，输出在时间 $t_n$ 测得的展宽宽度，并四舍五入到 $8$ 位小数。\n\n使用以下测试套件，参数为 $(N,\\ \\nu,\\ T,\\ a,\\ L)$：\n- 用例 1: $(200,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 2: $(200,\\ 0.9,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 3: $(200,\\ 0.2,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 4: $(50,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 5: $(200,\\ 1.0,\\ 0.2,\\ 1.0,\\ 1.0)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。例如，它应该看起来像\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5],\n$$\n其中每个 $\\text{result}_k$ 是用例 $k$ 的展宽宽度，四舍五入到 $8$ 位小数。不允许有任何其他输出。", "solution": "我们从平流方程的积分守恒形式开始，\n$$\n\\partial_t u(x,t) + \\partial_x f(u) = 0,\\quad f(u) = a u,\\quad a>0.\n$$\n令 $\\mathcal{C}_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ 是一个宽度均匀的控制体积，$\\Delta x = x_{i+\\tfrac{1}{2}} - x_{i-\\tfrac{1}{2}}$，其单元中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$ 且索引是周期性的。定义单元平均值为\n$$\n\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{\\mathcal{C}_i} u(x,t)\\,dx.\n$$\n将守恒律在 $\\mathcal{C}_i$ 上积分得到\n$$\n\\frac{d}{dt}\\left( \\int_{\\mathcal{C}_i} u(x,t)\\,dx \\right) + \\left[ f(u(x_{i+\\tfrac{1}{2}},t)) - f(u(x_{i-\\tfrac{1}{2}},t)) \\right] = 0,\n$$\n或等价地，\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( f_{i+\\tfrac{1}{2}} - f_{i-\\tfrac{1}{2}} \\right),\n$$\n其中 $f_{i\\pm \\tfrac{1}{2}}$ 是通过单元界面的通量。采用时间步长为 $\\Delta t$ 的一阶显式时间离散化可得\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left( \\hat{f}_{i+\\tfrac{1}{2}}^n - \\hat{f}_{i-\\tfrac{1}{2}}^n \\right),\n$$\n其中数值通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n$ 与物理特性一致。对于 $a>0$ 的线性平流，信息从左向右传播，每个界面上的精确 Riemann 解仅依赖于左侧的状态。因此，Godunov 迎风数值通量为\n$$\n\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n\\quad\\text{for }a>0.\n$$\n引入 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$，更新方程简化为一阶迎风格式\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\nu\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\\quad a>0,\n$$\n其中 $i$ 采用周期性索引。\n\n为了将此离散方法与连续过程联系起来并揭示数值扩散，我们进行修正方程分析。记 $\\bar{u}_i^n \\approx u(x_i,t^n)$，其中 $t^n = n\\Delta t$。在时间上进行泰勒展开得到\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\Delta t\\,u_t(x_i,t^n) + \\mathcal{O}(\\Delta t^2).\n$$\n对后向差分在空间上进行泰勒展开得到\n$$\n\\bar{u}_i^n - \\bar{u}_{i-1}^n = \\Delta x\\,u_x(x_i,t^n) - \\frac{\\Delta x^2}{2}u_{xx}(x_i,t^n) + \\frac{\\Delta x^3}{6}u_{xxx}(x_i,t^n) + \\mathcal{O}(\\Delta x^4).\n$$\n代入格式中得到\n$$\n\\Delta t\\,u_t = -\\nu\\left[ \\Delta x\\,u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx} + \\cdots \\right] + \\mathcal{O}(\\Delta t^2).\n$$\n两边除以 $\\Delta t$ 并回顾 $\\nu = a\\Delta t/\\Delta x$，\n$$\nu_t + a\\,u_x = \\frac{a\\,\\Delta x}{2}(1 - \\nu)\\,u_{xx} - \\frac{a\\,\\Delta x^2}{6}\\left(1 - 3\\nu + 2\\nu^2\\right)u_{xxx} + \\cdots.\n$$\n主导修正项是一个扩散项，其有效（或人为）扩散系数为\n$$\nD_{\\text{num}} = \\frac{a\\,\\Delta x}{2}(1 - \\nu).\n$$\n因此，对于 $0<\\nu<1$，一阶迎风法会引入数值扩散，使不连续性在一个宽度上被展宽，该宽度随 $\\sqrt{D_{\\text{num}}\\,t}$ 增长；而当 $\\nu=1$ 时，主导扩散项消失，该方法简化为网格上的纯位移算子。\n\n为了量化阶跃的展宽，我们定义 $10$–$90$ 厚度。考虑一个下降界面，其中 $u$ 的值从接近 $1$ 降至接近 $0$。令 $\\theta_{\\text{hi}} = 0.9$ 且 $\\theta_{\\text{lo}} = 0.1$。在分段常数的单元中心廓线 $\\{\\bar{u}_i^n\\}$ 上，我们通过在相邻单元中心之间进行线性插值，来确定 $u=\\theta$ 的近似位置。具体来说，对于下降前缘上的一对相邻索引 $(i,i+1)$，若满足 $\\bar{u}_i^n \\ge \\theta > \\bar{u}_{i+1}^n$，\n$$\nx(\\theta) \\approx x_i + \\Delta x \\frac{\\bar{u}_i^n - \\theta}{\\bar{u}_i^n - \\bar{u}_{i+1}^n}.\n$$\n我们收集整个域上（考虑周期性卷绕）所有向下的 $\\theta_{\\text{hi}}$ 穿越点和所有向下的 $\\theta_{\\text{lo}}$ 穿越点，并且对于每个 $\\theta_{\\text{hi}}$ 穿越点，我们确定沿周期性坐标到其后的 $\\theta_{\\text{lo}}$ 穿越点的距离。这样的最小距离，记作 $w_{10\\text{–}90}$，就是测得的展宽宽度。该宽度以与 $L$ 相同的长度单位报告。\n\n算法设计：\n- 空间离散化：均匀单元，周期性边界条件，对于 $a>0$，采用一阶迎风通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n$。\n- 时间步进：采用前向欧拉法，固定 $\\Delta t$ 以满足预设的 $\\nu = a\\,\\Delta t/\\Delta x$；推进 $n=\\text{round}(T/\\Delta t)$ 步。\n- 初始化：在 $[0.2L, 0.7L)$ 上 $u(x,0)=1$，在 $[0,L)$ 的其他位置为 $0$，在单元中心处采样。\n- 宽度测量：使用单元中心值的线性插值，以及下降界面上 $\\theta_{\\text{hi}}$ 和 $\\theta_{\\text{lo}}$ 穿越点之间的最小下游距离，来计算 $w_{10\\text{–}90}$；使用周期性展开来处理靠近 $x=0$ 的界面。\n\n基于 $D_{\\text{num}}$ 的定性预期：对于固定的 $a$、$L$ 和 $T$，更精细的网格（更小的 $\\Delta x$）会减小 $D_{\\text{num}}$，从而减少展宽；更大的 $\\nu$（更接近 $1$）也会减小 $D_{\\text{num}}$，产生更窄的界面；在 $\\nu=1$ 时，主导扩散项消失，界面厚度基本上限制在网格尺度。程序精确地实现了该格式和测量方法，并对每个指定的测试用例 $(N,\\nu,T,a,L)$，输出展宽宽度 $w_{10\\text{–}90}(t_n)$，四舍五入到 $8$ 位小数，并按要求将结果汇总为单行列表。", "answer": "```python\nimport numpy as np\n\ndef upwind_fvm_step(u, nu):\n    \"\"\"\n    First-order upwind finite volume update for a > 0:\n    u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n), with periodic indexing.\n    \"\"\"\n    return u - nu * (u - np.roll(u, 1))\n\ndef initialize_block(N, L, xL_frac=0.2, xR_frac=0.7):\n    \"\"\"\n    Initialize u(x,0) = 1 on [x_L, x_R) and 0 elsewhere on [0,L), sampled at cell centers.\n    x_L = xL_frac * L, x_R = xR_frac * L.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    xL = xL_frac * L\n    xR = xR_frac * L\n    u0 = np.where((x >= xL) & (x < xR), 1.0, 0.0)\n    return x, u0\n\ndef interpolate_crossing_pos(x_i, x_ip1, u_i, u_ip1, theta, L):\n    \"\"\"\n    Linear interpolation between (x_i, u_i) and (x_ip1, u_ip1) to find x where u=theta.\n    The positions x_i and x_ip1 are assumed to be neighbors on a uniform periodic grid.\n    Returns position wrapped into [0, L).\n    \"\"\"\n    # Handle periodic wrap for positions if necessary (assume uniform spacing)\n    # For uniform grid, x_ip1 - x_i = dx and we do not need special position handling for periodicity;\n    # after computing the position, wrap into [0, L).\n    denom = (u_i - u_ip1)\n    if denom == 0.0:\n        return None\n    frac = (u_i - theta) / denom\n    # x along the straight line between centers\n    dx = x_ip1 - x_i\n    if abs(dx) > L/2: # periodic wrap\n        if dx > 0:\n            dx -= L\n        else:\n            dx += L\n    xi = x_i + dx * frac\n    # Wrap into [0, L)\n    xi_wrapped = xi % L\n    return xi_wrapped\n\ndef measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1):\n    \"\"\"\n    Measure the 10-90 smearing width on descending interfaces using linear interpolation\n    between neighboring cell centers. Returns the minimal width among all descending interfaces.\n    \"\"\"\n    N = len(u)\n    # Build arrays of theta_hi and theta_lo crossing positions for descending fronts\n    hi_positions = []\n    lo_positions = []\n    for i in range(N):\n        ip1 = (i + 1) % N\n        u_i = u[i]\n        u_ip1 = u[ip1]\n        # Descending segment if u_i > u_ip1 (strict to avoid degenerate flat segments)\n        if u_i > u_ip1:\n            # theta_hi crossing: u_i >= theta_hi > u_ip1\n            if (u_i >= theta_hi) and (u_ip1 < theta_hi):\n                xi = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_hi, L)\n                if xi is not None:\n                    hi_positions.append(xi)\n            # theta_lo crossing: u_i >= theta_lo > u_ip1\n            if (u_i >= theta_lo) and (u_ip1 < theta_lo):\n                xl = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_lo, L)\n                if xl is not None:\n                    lo_positions.append(xl)\n\n    # Sort positions\n    hi_positions = np.sort(np.array(hi_positions, dtype=float)) if len(hi_positions) > 0 else np.array([], dtype=float)\n    lo_positions = np.sort(np.array(lo_positions, dtype=float)) if len(lo_positions) > 0 else np.array([], dtype=float)\n\n    if hi_positions.size == 0 or lo_positions.size == 0:\n        # No descending interfaces detected; width undefined. Return 0.0 as fallback.\n        return 0.0\n\n    # For each hi crossing, find the next downstream lo crossing (with periodicity)\n    widths = []\n    for h in hi_positions:\n        # Compute downstream distances to all lo positions with periodic wrap\n        dists = []\n        for l in lo_positions:\n            d = l - h\n            if d < 0:\n                d += L\n            dists.append(d)\n        if len(dists) > 0:\n            widths.append(min(dists))\n    if len(widths) == 0:\n        return 0.0\n    return float(min(widths))\n\ndef simulate_and_measure(N, nu, T, a, L):\n    \"\"\"\n    Run the first-order upwind FVM for linear advection with given parameters and\n    measure the 10-90 smearing width at time ~ T.\n    \"\"\"\n    dx = L / N\n    dt = nu * dx / a\n    # Number of steps to approximate T with fixed dt\n    nsteps = int(np.round(T / dt))\n    # Initialize\n    x, u = initialize_block(N, L, xL_frac=0.2, xR_frac=0.7)\n    # Time-stepping\n    for _ in range(nsteps):\n        u = upwind_fvm_step(u, nu)\n    # Measure width\n    width = measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1)\n    return width\n\ndef solve():\n    # Define the test cases: (N, nu, T, a, L)\n    test_cases = [\n        (200, 0.5, 0.2, 1.0, 1.0),  # Case 1\n        (200, 0.9, 0.2, 1.0, 1.0),  # Case 2\n        (200, 0.2, 0.2, 1.0, 1.0),  # Case 3\n        (50,  0.5, 0.2, 1.0, 1.0),  # Case 4\n        (200, 1.0, 0.2, 1.0, 1.0),  # Case 5\n    ]\n\n    results = []\n    for N, nu, T, a, L in test_cases:\n        width = simulate_and_measure(N, nu, T, a, L)\n        # Round to 8 decimal places as required\n        results.append(width)\n\n    # Final print statement in the exact required format with rounding\n    print(\"[\" + \",\".join(f\"{w:.8f}\" for w in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2394306"}, {"introduction": "这个综合性练习将我们前面学到的概念提升到一个新的维度，用于解决一个更具现实意义的工程物理问题。您将从头开始构建一个完整的 FVM 程序，以计算二维稳态热传导问题中的温度分布 [@problem_id:2394364]。此任务要求您处理二维网格离散化、施加狄利克雷 ($Dirichlet$) 边值条件、以及组装并求解一个大型线性方程组，是将在 FVM 学习中获得的各项技能融会贯通的绝佳实践。", "problem": "您的任务是构建一个完整的、可运行的程序，应用有限体积法 (FVM) 计算一个二维矩形域内的稳态温度场。该区域具有固定温度（Dirichlet）边界条件和内部的位置相关热源。物理模型为具有恒定导热系数的稳态热传导。您的程序必须从第一性原理出发，实现控制体离散化，并针对一组指定的测试用例求解所得到的线性系统。\n\n连续模型由任意控制体上的稳态能量守恒定律给出，在导热系数恒定的情况下，该定律可简化为 Poisson 型方程：\n$$\n\\nabla \\cdot \\left( k \\, \\nabla T \\right) + q(x,y) = 0,\n$$\n在域\n$$\n\\Omega = \\{(x,y) \\mid 0 \\le x \\le L_x,\\; 0 \\le y \\le L_y\\},\n$$\n中，其中 $T$ 是温度，$k$ 是恒定导热系数，$q(x,y)$ 是体积热源密度。Dirichlet 边界条件固定了整个边界 $\\partial\\Omega$ 上的温度：\n$$\nT(0,y) = T_L,\\quad T(L_x,y) = T_R,\\quad T(x,0) = T_B,\\quad T(x,L_y) = T_T.\n$$\n\n离散化要求：\n- 将域划分为 $N_x \\times N_y$ 个大小均匀的矩形控制体，尺寸为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。对于整数 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$，将未知温度 $T_{i,j}$ 放置在每个单元中心 $(x_i,y_j)$ 处，其中 $x_i = (i+\\tfrac{1}{2})\\Delta x$ 且 $y_j = (j+\\tfrac{1}{2})\\Delta y$。\n- 从通用控制体上的积分守恒定律出发，应用散度定理，为每个单元推导出使用其各面扩散通量的离散平衡方程。对于内界面，使用相邻单元中心之间的中心两点差分来近似法向导数。对于邻近固定温度边界的面，将边界条件施加在面上，并在半个单元距离上（从单元中心到边界面）近似法向导数。\n- 为所有 $N_x N_y$ 个未知数组装生成的线性系统，并对其进行数值求解。\n\n输出要求：\n对于每个测试用例，您的程序必须计算以下三个量：\n1. 中心最接近 $(L_x/2, L_y/2)$ 的控制体的温度，记为 $T_{\\mathrm{center}}$（单位：开尔文）。\n2. 域上的面积平均温度，对于均匀网格，该值计算为所有单元中心温度的算术平均值，记为 $T_{\\mathrm{avg}}$（单位：开尔文）。\n3. 所有单元中心中的最高温度，记为 $T_{\\mathrm{max}}$（单位：开尔文）。\n\n所有温度均以开尔文表示，并将每个报告的浮点数四舍五入至 $6$ 位小数。\n\n测试套件：\n使用以下三个测试用例，每个用例都已完整指定。\n\n- 测试用例 A（高斯热源，等温边界）：\n  - 域尺寸：$L_x = 1.0\\,\\mathrm{m}$，$L_y = 1.0\\,\\mathrm{m}$。\n  - 网格：$N_x = 51$，$N_y = 51$。\n  - 导热系数：$k = 10.0\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n  - 边界温度：$T_L = 300.0\\,\\mathrm{K}$，$T_R = 300.0\\,\\mathrm{K}$，$T_B = 300.0\\,\\mathrm{K}$，$T_T = 300.0\\,\\mathrm{K}$。\n  - 热源： \n    $$\n    q(x,y) = A \\exp\\!\\big(-\\alpha\\big[(x-x_c)^2+(y-y_c)^2\\big]\\big),\\quad\n    A = 1.0\\times 10^6\\,\\mathrm{W\\,m^{-3}},\\;\\alpha = 80.0,\\;x_c = 0.5,\\;y_c = 0.5.\n    $$\n\n- 测试用例 B（无热源，左右温差）：\n  - 域尺寸：$L_x = 1.0\\,\\mathrm{m}$，$L_y = 1.0\\,\\mathrm{m}$。\n  - 网格：$N_x = 51$，$N_y = 51$。\n  - 导热系数：$k = 10.0\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n  - 边界温度：$T_L = 300.0\\,\\mathrm{K}$，$T_R = 400.0\\,\\mathrm{K}$，$T_B = 300.0\\,\\mathrm{K}$，$T_T = 300.0\\,\\mathrm{K}$。\n  - 热源：$q(x,y) = 0$。\n\n- 测试用例 C（角点附近的高斯热汇，等温边界）：\n  - 域尺寸：$L_x = 1.0\\,\\mathrm{m}$，$L_y = 1.0\\,\\mathrm{m}$。\n  - 网格：$N_x = 51$，$N_y = 51$。\n  - 导热系数：$k = 10.0\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n  - 边界温度：$T_L = 300.0\\,\\mathrm{K}$，$T_R = 300.0\\,\\mathrm{K}$，$T_B = 300.0\\,\\mathrm{K}$，$T_T = 300.0\\,\\mathrm{K}$。\n  - 热源：\n    $\n    q(x,y) = A \\exp\\!\\big(-\\alpha\\big[(x-x_c)^2+(y-y_c)^2\\big]\\big),\\;\n    A = -7.0\\times 10^5\\,\\mathrm{W\\,m^{-3}},\\;\\alpha = 60.0,\\;x_c = 0.25,\\;y_c = 0.75.\n    $\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，形式为一个由逗号分隔的包含三个子列表的列表。每个子列表按 $[T_{\\mathrm{center}}, T_{\\mathrm{avg}}, T_{\\mathrm{max}}]$ 的顺序包含三个浮点数，每个浮点数四舍五入到 $6$ 位小数。该行必须如下所示：\n  $$\n  [[t_{A,\\mathrm{center}},t_{A,\\mathrm{avg}},t_{A,\\mathrm{max}}],[t_{B,\\mathrm{center}},t_{B,\\mathrm{avg}},t_{B,\\mathrm{max}}],[t_{C,\\mathrm{center}},t_{C,\\mathrm{avg}},t_{C,\\mathrm{max}}]]\n  $$\n无任何附加文本。", "solution": "用户要求使用有限体积法 (FVM) 解决一个二维稳态热传导问题。首先对该问题进行验证，以确保其科学性和逻辑完整性。\n\n### 问题验证\n\n**1. 已知条件提取：**\n- **控制方程：** 对于恒定导热系数 $k$，稳态热传导方程是一个泊松 (Poisson) 型方程：$\\nabla \\cdot (k \\nabla T) + q(x,y) = 0$。\n- **计算域：** 一个矩形域 $\\Omega = \\{(x,y) \\mid 0 \\le x \\le L_x,\\; 0 \\le y \\le L_y\\}$。\n- **边界条件：** 在所有四个边界上都指定了狄利克雷 (Dirichlet) 条件：$T(0,y) = T_L$，$T(L_x,y) = T_R$，$T(x,0) = T_B$ 和 $T(x,L_y) = T_T$。\n- **离散化：** 域被划分为一个 $N_x \\times N_y$ 的均匀控制体网格。单元尺寸为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。未知温度 $T_{i,j}$ 位于单元中心 $(x_i, y_j) = ((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y)$。\n- **数值方法：** 问题要求基于积分守恒定律进行控制体离散化。通量需使用中心差分（对于内界面）和半单元差分（对于边界面）进行近似。\n- **要求输出：** 对于每个测试用例，计算 $T_{\\mathrm{center}}$、$T_{\\mathrm{avg}}$ 和 $T_{\\mathrm{max}}$。\n- **测试用例：** 三个特定的测试用例（A、B、C）被完整定义，包含了域尺寸、网格分辨率、导热系数、边界温度和热源项函数等所有必要参数。\n\n**2. 验证分析：**\n- **科学依据：** 该问题基于应用于热传导的能量守恒基本原理，这是物理学和工程学中的一个核心课题。控制方程是一个标准的椭圆型偏微分方程（泊松方程）。所提供的物理参数是现实的。该问题在科学上是合理的。\n- **适定性：** 该问题是一个适定的边值问题。对于带有狄利克雷边界条件的线性椭圆型偏微分方程，保证存在唯一且稳定的解。所指定的 FVM 离散化方法会导出一个对角占优的线性系统，这也保证了数值解的唯一性。\n- **客观性与完备性：** 该问题以客观的数学术语陈述。解决此问题所需的所有数据——控制方程、域、边界条件、材料属性、热源项和离散化参数——均已明确提供。该问题是自洽且无歧义的。\n\n**3. 结论与行动：**\n该问题被判定为**有效**。它是计算物理学中一个标准的、定义明确的问题。将提供一个解决方案。\n\n### 有限体积法离散化\n\n分析从控制方程在一个以 $(x_i, y_j)$ 为中心、体积为 $\\Delta V = \\Delta x \\Delta y \\cdot 1$ 的通用控制体 $V_{i,j}$ 上的积分形式开始：\n$$\n\\int_{V_{i,j}} \\left( \\nabla \\cdot (k \\, \\nabla T) + q(x,y) \\right) dV = 0\n$$\n对第一项应用散度定理，并将热源项在单元上近似为常数，我们得到：\n$$\n\\oint_{\\partial V_{i,j}} (k \\, \\nabla T) \\cdot \\mathbf{n} \\, ds + \\bar{q}_{i,j} \\Delta x \\Delta y = 0\n$$\n其中 $\\partial V_{i,j}$ 是控制体的边界，$\\mathbf{n}$ 是向外的单位法向量，$\\bar{q}_{i,j} = q(x_i, y_j)$。该积分表示离开控制体的净热通量。守恒原理指出，净热流出量必须与体积内产生的热量相平衡。热通量矢量定义为 $\\mathbf{J} = -k \\nabla T$。因此，通过四个面（东、西、北、南）的热流出总量必须等于总的热生成量：\n$$\n(\\text{通量}_{e} + \\text{通量}_{w} + \\text{通量}_{n} + \\text{通量}_{s})_{\\text{流出}} = q(x_i, y_j) \\Delta x \\Delta y\n$$\n设 $T_{i,j}$ 为控制体 $V_{i,j}$ 中心的温度。其邻居为 $T_{i \\pm 1, j}$ 和 $T_{i, j \\pm 1}$。\n\n**1. 内部控制体：**\n对于一个内部单元，流出通量使用相邻单元中心之间的中心差分进行近似：\n- 东面 (e)：通量$_{e} = k \\frac{T_{i,j} - T_{i+1,j}}{\\Delta x} \\Delta y$\n- 西面 (w)：通量$_{w} = k \\frac{T_{i,j} - T_{i-1,j}}{\\Delta x} \\Delta y$\n- 北面 (n)：通量$_{n} = k \\frac{T_{i,j} - T_{i,j+1}}{\\Delta y} \\Delta x$\n- 南面 (s)：通量$_{s} = k \\frac{T_{i,j} - T_{i,j-1}}{\\Delta y} \\Delta x$\n\n代入平衡方程并除以 $\\Delta x \\Delta y$：\n$$\nk \\frac{T_{i,j}-T_{i+1,j}}{(\\Delta x)^2} + k \\frac{T_{i,j}-T_{i-1,j}}{(\\Delta x)^2} + k \\frac{T_{i,j}-T_{i,j+1}}{(\\Delta y)^2} + k \\frac{T_{i,j}-T_{i,j-1}}{(\\Delta y)^2} = q_{i,j}\n$$\n重新整理以形成关于 $T_{i,j}$ 的线性方程：\n$$\n\\left(\\frac{2k}{(\\Delta x)^2} + \\frac{2k}{(\\Delta y)^2}\\right)T_{i,j} - \\frac{k}{(\\Delta x)^2}T_{i+1,j} - \\frac{k}{(\\Delta x)^2}T_{i-1,j} - \\frac{k}{(\\Delta y)^2}T_{i,j+1} - \\frac{k}{(\\Delta y)^2}T_{i,j-1} = q_{i,j}\n$$\n\n**2. 边界控制体：**\n对于邻近边界的控制体，通量计算需要修改。考虑靠近左边界的单元 $(0,j)$，其中 $T(0,y) = T_L$。从单元中心 $x_0 = \\Delta x/2$ 到 $x=0$ 处边界的距离是 $\\Delta x/2$。\n通过西面的流出量为：\n$$\n\\text{通量}_{w} = k \\frac{T_{0,j} - T_L}{\\Delta x / 2} \\Delta y\n$$\n单元 $(0,j)$ 的能量平衡变为：\n$$\nk \\frac{T_{0,j}-T_{1,j}}{\\Delta x} \\Delta y + k \\frac{T_{0,j}-T_L}{\\Delta x/2} \\Delta y + \\text{（北/南通量）} = q_{0,j} \\Delta x \\Delta y\n$$\n除以 $\\Delta x \\Delta y$ 并重新整理，得到代数方程：\n$$\n\\left(\\frac{3k}{(\\Delta x)^2} + \\frac{2k}{(\\Delta y)^2}\\right)T_{0,j} - \\frac{k}{(\\Delta x)^2}T_{1,j} - \\frac{k}{(\\Delta y)^2}T_{0,j+1} - \\frac{k}{(\\Delta y)^2}T_{0,j-1} = q_{0,j} + \\frac{2k}{(\\Delta x)^2}T_L\n$$\n对于邻近其他三个边界（右、上、下）的单元以及邻近两个边界的角点单元，可以推导出类似的方程。\n\n**3. 线性系统组装：**\n所有 $N = N_x \\times N_y$ 个控制体的离散方程构成一个大型线性方程组 $A\\mathbf{T} = \\mathbf{b}$，其中 $\\mathbf{T}$ 是未知单元中心温度的向量。使用单个索引 $p = i + j \\times N_x$ 将二维温度网格 $T_{i,j}$ 映射到一维向量 $\\mathbf{T}$。系数矩阵 $A$ 根据推导出的方程组装而成。对于索引为 $p$ 的单元 $(i,j)$：\n- 对角元素 $A_{p,p}$ 包含 $T_{i,j}$ 的系数。\n- 非对角元素 $A_{p, p\\pm1}$ 和 $A_{p, p\\pm N_x}$ 包含相邻温度的系数。\n- 右侧向量元素 $b_p$ 包含热源项 $q_{i,j}$ 以及来自边界条件的任何贡献。\n然后求解该系统以获得温度场。所得到的矩阵 $A$ 是稀疏、带状且对角占优的，这确保了可以高效地找到唯一解。所需的输出——$T_{\\mathrm{center}}$、$T_{\\mathrm{avg}}$ 和 $T_{\\mathrm{max}}$——由最终的温度场计算得出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve_case(Lx, Ly, Nx, Ny, k, T_bcs, q_func):\n    \"\"\"\n    Solves the 2D steady-state heat conduction problem for one test case.\n\n    Args:\n        Lx (float): Domain size in x-direction.\n        Ly (float): Domain size in y-direction.\n        Nx (int): Number of control volumes in x-direction.\n        Ny (int): Number of control volumes in y-direction.\n        k (float): Thermal conductivity.\n        T_bcs (dict): Dictionary of boundary temperatures {'L', 'R', 'B', 'T'}.\n        q_func (callable): Function for the heat source q(x, y).\n\n    Returns:\n        list: A list containing [T_center, T_avg, T_max].\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    # Coefficients from discretization\n    Cx = k / dx**2\n    Cy = k / dy**2\n\n    N = Nx * Ny\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Cell center coordinates\n    x_centers = (np.arange(Nx) + 0.5) * dx\n    y_centers = (np.arange(Ny) + 0.5) * dy\n\n    # Assemble matrix A and vector b\n    for j in range(Ny):\n        for i in range(Nx):\n            p = i + j * Nx  # 1D index for the current cell (i, j)\n            x, y = x_centers[i], y_centers[j]\n\n            # Diagonal element initialization (from interior point stencil)\n            A[p, p] = 0\n            # West neighbor (i-1, j) or Left boundary\n            if i > 0:\n                A[p, p] += Cx\n                A[p, p - 1] = -Cx\n            else:  # Left boundary at x=0\n                A[p, p] += 2 * Cx\n                b[p] += 2 * Cx * T_bcs['L']\n\n            # East neighbor (i+1, j) or Right boundary\n            if i  Nx - 1:\n                A[p, p] += Cx\n                A[p, p + 1] = -Cx\n            else:  # Right boundary at x=Lx\n                A[p, p] += 2 * Cx\n                b[p] += 2 * Cx * T_bcs['R']\n\n            # South neighbor (i, j-1) or Bottom boundary\n            if j > 0:\n                A[p, p] += Cy\n                A[p, p - Nx] = -Cy\n            else:  # Bottom boundary at y=0\n                A[p, p] += 2 * Cy\n                b[p] += 2 * Cy * T_bcs['B']\n\n            # North neighbor (i, j+1) or Top boundary\n            if j  Ny - 1:\n                A[p, p] += Cy\n                A[p, p + Ny] = -Cy\n            else:  # Top boundary at y=Ly\n                A[p, p] += 2 * Cy\n                b[p] += 2 * Cy * T_bcs['T']\n            \n            # Add source term to RHS\n            b[p] += q_func(x, y)\n\n    # Solve the linear system A * T = b\n    T_vector = linalg.solve(A, b)\n    T_field = T_vector.reshape((Ny, Nx))\n\n    # Calculate required outputs\n    center_ix = Nx // 2\n    center_iy = Ny // 2\n    T_center = T_field[center_iy, center_ix]\n    T_avg = np.mean(T_field)\n    T_max = np.max(T_field)\n\n    return [T_center, T_avg, T_max]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver, and print results.\n    \"\"\"\n    # Define source functions for each case\n    def q_A(x, y):\n        A = 1.0e6\n        alpha = 80.0\n        xc, yc = 0.5, 0.5\n        return A * np.exp(-alpha * ((x - xc)**2 + (y - yc)**2))\n\n    def q_B(x, y):\n        return 0.0\n\n    def q_C(x, y):\n        A = -7.0e5\n        alpha = 60.0\n        xc, yc = 0.25, 0.75\n        return A * np.exp(-alpha * ((x - xc)**2 + (y - yc)**2))\n\n    test_cases = [\n        # Test case A\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 51, 'Ny': 51, 'k': 10.0,\n         'T_bcs': {'L': 300.0, 'R': 300.0, 'B': 300.0, 'T': 300.0},\n         'q_func': q_A},\n        # Test case B\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 51, 'Ny': 51, 'k': 10.0,\n         'T_bcs': {'L': 300.0, 'R': 400.0, 'B': 300.0, 'T': 300.0},\n         'q_func': q_B},\n        # Test case C\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 51, 'Ny': 51, 'k': 10.0,\n         'T_bcs': {'L': 300.0, 'R': 300.0, 'B': 300.0, 'T': 300.0},\n         'q_func': q_C}\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = solve_case(\n            case['Lx'], case['Ly'], case['Nx'], case['Ny'],\n            case['k'], case['T_bcs'], case['q_func']\n        )\n        results.append(case_results)\n\n    # Format the final output string exactly as specified\n    formatted_results = []\n    for res_case in results:\n        formatted_case = [f\"{val:.6f}\" for val in res_case]\n        formatted_results.append(f\"[{','.join(formatted_case)}]\")\n    \n    print(f\"[[{','.join(formatted_results)}]]\")\n\nsolve()\n```", "id": "2394364"}]}