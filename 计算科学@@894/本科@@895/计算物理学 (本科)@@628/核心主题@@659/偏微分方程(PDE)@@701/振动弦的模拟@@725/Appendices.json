{"hands_on_practices": [{"introduction": "动手实践的第一步是构建一个基本但功能完备的弦振动模拟器。这个练习将指导你从一维波动方程出发，通过显式时域有限差分法（FDTD）编写程序，模拟两个高斯波包的相向传播与干涉。通过这个实践 [@problem_id:2438583]，你不仅能掌握数值求解偏微分方程的核心技术，还能直观地验证波的叠加原理和能量守恒等基本物理概念。", "problem": "你的任务是推导、实现并测试一个关于拉紧的均匀弦在微小横向振动下的数值模拟。在此模拟中，两个局域高斯波包相向传播、叠加并发生干涉。你的程序必须为具有固定端边界条件的一维波动方程实现一个显式时域有限差分格式。程序必须在没有用户输入的情况下运行，并且必须输出一行包含指定测试套件结果的字符串。\n\n物理和数学基础：\n- 从应用于均匀密度弦的牛顿第二定律出发：一个线质量密度为 $\\mu$ 的小段弦，在近似水平的张力 $T$ 作用下，得到连续介质方程 $\\mu \\partial^2 u / \\partial t^2 = T \\partial^2 u / \\partial x^2$，其中 $u(x,t)$ 是横向位移。通过 $c^2 = T/\\mu$ 定义波速 $c$，得到波动方程 $\\partial^2 u / \\partial t^2 = c^2 \\partial^2 u / \\partial x^2$。\n- 施加固定端（狄利克雷）边界条件 $u(0,t)=0$ 和 $u(L,t)=0$，其中 $L$ 是弦的长度。\n- 为了保证稳定性，使用间距为 $\\Delta x$ 的均匀空间网格和步长为 $\\Delta t$ 的均匀时间步，并满足 Courant–Friedrichs–Lewy (CFL) 条件。\n- 使用空间和时间的中心二阶差分来离散化波动方程，从而得到一个关于 $u_i^n$ 和 $u_i^{n-1}$ 的 $u_i^{n+1}$ 的显式更新式，其中 $u_i^n$ 近似于在 $x_i = i \\Delta x$ 和 $t_n = n \\Delta t$ 处的 $u(x_i, t_n)$。利用初始速度 $v(x)=\\partial u/\\partial t(x,0)$，通过泰勒展开推导 $u_i^1$ 的二阶精确初始步公式。\n- 选择初始位移 $u(x,0)$ 为两个高斯分布的和，其中心分别位于 $x=x_1$ 和 $x=x_2$，振幅为 $A_1$ 和 $A_2$，宽度为 $\\sigma_1$ 和 $\\sigma_2$。选择初始速度 $v(x)$，使得第一个高斯波包以速度 $c$ 向右传播，第二个高斯波包以速度 $c$ 向左传播。根据由两个高斯函数及其空间导数构造的 $u(x,0)$，显式地推导所需的 $v(x)$。除了上述基本定律和定义外，不要使用任何快捷公式；从第一性原理和标准微积分出发推导你需要的一切。\n- 弦的总机械能（每单位平面外宽度）为 $E(t) = \\int_0^L \\tfrac{1}{2}\\left[(\\partial u/\\partial t)^2 + c^2 (\\partial u/\\partial x)^2\\right] \\, dx$。对于固定端且无外力的情况，只要在模拟时间内波包不与边界接触，$E(t)$ 在数值模拟中应近似守恒。\n\n数值规格：\n- 对 $x$ 和 $u$ 使用米作为单位，对 $t$ 使用秒。波速 $c$ 的单位是米/秒。所有报告的位移量和误差必须以米为单位。任何报告的能量变化都是无量纲的比率。不涉及角度。\n- 在 $[0,L]$ 上使用包含 $N_x$ 个点的空间网格，其中 $x_i = i \\Delta x$，且 $\\Delta x = L/(N_x-1)$。\n- 使用满足 $0 < \\lambda \\le 1$ 的时间步长 $\\Delta t$，其中 $\\lambda = c \\Delta t / \\Delta x$ 是 Courant 数。为保证稳定性，请使用严格小于 $1$ 的 $\\lambda$。在你的实现中定义并使用一个你选择的特定 $\\lambda$，并据此计算 $\\Delta t$。\n\n需要计算的观测量：\n- 设 $t_\\star$ 为两个高斯波包中心重合的时间，设 $x_\\star$ 为碰撞位置。如果 $t_\\star$ 不恰好落在某个时间步上，通过时间插值计算在 $(x_\\star, t_\\star)$ 处的模拟弦位移；如果 $x_\\star$ 不恰好是网格点，则使用最接近 $x_\\star$ 的网格点。报告两种测试情况下碰撞点的绝对误差：一种是相长干涉（两个振幅均为正），另一种是相消干涉（振幅符号相反）。误差必须以米为单位。\n- 对于第三种测试情况（使用不同的参数集），计算 $t=0$ 和 $t=t_\\star$ 之间的总能量相对变化，定义为 $|E(t_\\star)-E(0)|/E(0)$，并报告此相对变化是否严格小于一个选定的容差（返回一个布尔值）。选择模拟参数和 $t_\\star$ 以确保在 $0 \\le t \\le t_\\star$ 期间，波包与边界保持足够远的距离。\n\n测试套件：\n提供三组参数集。在每种情况下，计算域为 $[0,L]$，$L$ 的单位是米，波速 $c$ 的单位是米/秒，高斯参数的单位是米。\n- 情况 A（相长干涉）：\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.020$, $\\sigma_1 = 0.050$, $\\sigma_2 = 0.050$, $x_1 = 0.300$, $x_2 = 0.700$。\n  - 预期碰撞发生在 $t_\\star = (x_2 - x_1)/(2c)$ 和 $x_\\star = (x_1 + x_2)/2$。在 $(x_\\star, t_\\star)$ 处的预期位移是 $A_1 + A_2$。你的程序必须输出此情况下的绝对误差（以米为单位），作为第一个数字。\n- 情况 B（相消干涉）：\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.015$, $A_2 = -0.015$, $\\sigma_1 = 0.040$, $\\sigma_2 = 0.040$, $x_1 = 0.350$, $x_2 = 0.650$。\n  - 在 $(x_\\star, t_\\star)$ 处的预期位移是 $0.0$。你的程序必须输出此情况下的绝对误差（以米为单位），作为第二个数字。\n- 情况 C（能量检验）：\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.013$, $\\sigma_1 = 0.030$, $\\sigma_2 = 0.070$, $x_1 = 0.250$, $x_2 = 0.750$。\n  - 计算在 $t_\\star = (x_2 - x_1)/(2c)$ 时的相对能量变化 $|E(t_\\star)-E(0)|/E(0)$，并返回一个布尔值，如果该值严格小于容差 $0.02$ 则为真，否则为假。此布尔值必须是第三个输出。\n\n实现要求：\n- 在时间和空间上使用二阶精确的显式格式，在所有时间步强制执行 $u(0,t)=0$ 和 $u(L,t)=0$，并将 $u(x,0)$ 初始化为两个高斯函数的和。推导并实现 $v(x)=\\partial u/\\partial t(x,0)$，使得第一个高斯函数以速度 $c$ 向右传播，第二个以速度 $c$ 向左传播。\n- 为保证稳定性，使用严格小于 $1$ 的 Courant 数 $\\lambda$。根据 $\\lambda$、$c$ 和 $\\Delta x$ 显式计算 $\\Delta t$。\n- 使用 $v(x)$ 和 $u(x,0)$ 的空间梯度计算 $E(0)$，并使用在 $t_\\star$ 处对 $\\partial u/\\partial t$ 和 $\\partial u/\\partial x$ 的一致离散近似来计算 $E(t_\\star)$。确保对于任何测试用例，模拟的时间跨度都不允许波包与边界相互作用。\n- 你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序为：情况 A 的误差（米）、情况 B 的误差（米）、情况 C 的能量守恒布尔值。例如：\"[0.00012,0.00003,True]\"。不要打印任何其他文本。\n\n假设和约束：\n- 使用足够大的 $N_x$，以使 $x_\\star$ 位于或非常接近一个网格点，并且高斯函数被良好地解析。你必须确保 $\\lambda \\in (0,1)$，并且对于每种情况，时间积分都能达到 $t_\\star$。\n- 所有浮点输出都应以原始十进制数的形式给出；不要在打印输出中附加单位。在内部，所有量都必须按照上面指定的物理上正确的单位进行处理。", "solution": "我们从应用于一根拉紧的均匀弦的微分元的牛顿第二定律开始。设 $\\mu$ 为线质量密度（单位长度的质量），$T$ 为恒定张力。对于微小的横向位移 $u(x,t)$，由张力引起的垂直力为 $T \\partial^2 u / \\partial x^2 \\, \\mathrm{d}x$，它等于弦元的质量 $\\mu \\, \\mathrm{d}x$ 乘以其垂直加速度 $\\partial^2 u / \\partial t^2$。两边除以 $\\mu \\, \\mathrm{d}x$ 得到标准的波动方程\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}, \\quad c^2 = \\frac{T}{\\mu}.\n$$\n我们施加固定端条件 $u(0,t)=0$ 和 $u(L,t)=0$，并选择初始条件 $u(x,0) = u_0(x)$ 和 $u_t(x,0)=v_0(x)$ 来生成两个相向传播的高斯波包。\n\n有限差分格式：\n在均匀网格 $x_i = i \\Delta x$（$i=0,\\dots,N_x-1$，$\\Delta x = L/(N_x-1)$）上离散化空间，在 $t_n = n \\Delta t$（$n=0,1,2,\\dots$）上离散化时间。记 $u_i^n \\approx u(x_i,t_n)$。在空间和时间上使用中心差分。波动方程变为\n$$\n\\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2} = c^2 \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2},\n$$\n或者等价地，写成显式更新式\n$$\nu_i^{n+1} = 2 u_i^n - u_i^{n-1} + \\lambda^2 \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n \\right), \\quad \\lambda = \\frac{c \\Delta t}{\\Delta x}.\n$$\n为保证稳定性，Courant–Friedrichs–Lewy (CFL) 条件要求 $0 < \\lambda \\le 1$；我们严格选择 $\\lambda < 1$。通过为所有 $n$ 设置 $u_0^n = 0$ 和 $u_{N_x-1}^n = 0$ 来实施固定端条件。\n\n初始化：\n我们需要 $u_i^0 = u_0(x_i)$ 和 $u_i^1$ 来开始递推。时间上的二阶泰勒展开给出\n$$\nu(x,t+\\Delta t) = u(x,t) + \\Delta t \\, u_t(x,t) + \\frac{\\Delta t^2}{2} \\, u_{tt}(x,t) + \\mathcal{O}(\\Delta t^3).\n$$\n使用波动方程 $u_{tt} = c^2 u_{xx}$ 和中心空间拉普拉斯算子，我们得到二阶精确的初始步\n$$\nu_i^1 = u_i^0 + \\Delta t \\, v_0(x_i) + \\frac{\\lambda^2}{2}\\left(u_{i+1}^0 - 2 u_i^0 + u_{i-1}^0\\right),\n$$\n并强制执行边界条件 $u_0^1 = u_{N_x-1}^1 = 0$。\n\n构造相向传播的高斯函数：\n我们定义两个高斯分布\n$$\nf(x) = A_1 \\exp\\!\\left(-\\frac{(x - x_1)^2}{2 \\sigma_1^2}\\right), \\quad\ng(x) = A_2 \\exp\\!\\left(-\\frac{(x - x_2)^2}{2 \\sigma_2^2}\\right),\n$$\n并将初始位移设置为它们的和 $u_0(x) = f(x) + g(x)$。为了使 $f$ 以速度 $c$ 向右传播，使 $g$ 以速度 $c$ 向左传播，我们使用从波动方程的线性和不变性推导出的 d’Alembert 分解：$u(x,t) = F(x - c t) + G(x + c t)$，其中 $F$ 和 $G$ 由初始数据确定。匹配 $u_0(x) = f(x) + g(x)$ 得到 $F(x) = f(x)$ 和 $G(x) = g(x)$。在 $t=0$ 时对时间求导，得到\n$$\nv_0(x) = \\left.\\frac{\\partial u}{\\partial t}\\right|_{t=0} = - c F'(x) + c G'(x) = - c f'(x) + c g'(x).\n$$\n对于高斯函数的导数，\n$$\n\\frac{d}{dx}\\left[A \\exp\\!\\left(-\\frac{(x - x_0)^2}{2 \\sigma^2}\\right)\\right]\n= - A \\frac{x - x_0}{\\sigma^2} \\exp\\!\\left(-\\frac{(x - x_0)^2}{2 \\sigma^2}\\right).\n$$\n因此，我们根据上述表达式显式地构造 $v_0(x) = - c f'(x) + c g'(x)$。\n\n碰撞时间和位置：\n$f$ 和 $g$ 的中心分别位于 $x_f(t) = x_1 + c t$ 和 $x_g(t) = x_2 - c t$。当 $x_f(t_\\star) = x_g(t_\\star)$ 时它们相遇，得到 $t_\\star = (x_2 - x_1)/(2 c)$ 和 $x_\\star = (x_1 + x_2)/2$。在 $(x_\\star,t_\\star)$ 处，连续解的值为 $u(x_\\star,t_\\star) = f(x_1) + g(x_2) = A_1 + A_2$，这与 $\\sigma_1$ 和 $\\sigma_2$ 无关。对于 $A_1 = -A_2$ 且宽度对称的相消干涉，其和为 $0$。\n\n能量及其离散近似：\n总能量为\n$$\nE(t) = \\int_0^L \\frac{1}{2}\\left[\\left(\\frac{\\partial u}{\\partial t}\\right)^2 + c^2 \\left(\\frac{\\partial u}{\\partial x}\\right)^2 \\right] dx,\n$$\n对于具有固定端的连续波动方程，能量是守恒的。在离散情况下，我们近似为\n$$\nE^n \\approx \\sum_{i=0}^{N_x-1} \\frac{1}{2} \\left[ (v_i^n)^2 + c^2 (D_x u_i^n)^2 \\right] \\Delta x,\n$$\n其中 $D_x u_i^n$ 是内部点的中心空间差分，\n$$\nD_x u_i^n = \\frac{u_{i+1}^n - u_{i-1}^n}{2 \\Delta x} \\quad \\text{对于 } 1 \\le i \\le N_x-2,\n$$\n在边界处使用与 $u=0$ 一致的单边差分。对于 $E^0$，我们使用 $v_i^0 = v_0(x_i)$。对于之后时间的 $E^n$，中心时间差分 $v_i^n \\approx \\left(u_i^{n+1} - u_i^{n-1}\\right)/(2 \\Delta t)$ 是二阶精确的；在两层推进的实现中，一个精确的代理是在当前可用时间层上的 $v_i^{n} \\approx \\left(u_i^{n} - u_i^{n-1}\\right)/\\Delta t$，这足以在与边界相互作用之前的适度时间内监测近似守恒性。\n\n算法设计：\n1. 选择足够大的 $N_x$ 和严格小于 $1$ 的 $\\lambda = c \\Delta t / \\Delta x$，并根据 $\\lambda$ 计算 $\\Delta t$。\n2. 在 $[0,L]$ 上构建网格 $x_i$ 并从两个高斯函数构建 $u_i^0$。计算 $v_i^0 = -c f'(x_i) + c g'(x_i)$。强制 $u_0^0=u_{N_x-1}^0=0$ 和 $v_0^0=v_{N_x-1}^0=0$。\n3. 使用基于泰勒展开的初始步公式计算 $u_i^1$ 并强制执行边界值。\n4. 使用显式更新式进行时间推进，直到刚过 $t_\\star$。检测到 $t$ 穿过 $t_\\star$ 的步长，并在最接近 $x_\\star$ 的网格索引处进行时间线性插值，以估计 $u(x_\\star,t_\\star)$。\n5. 从 $u^0$ 和 $v^0$ 计算 $E(0)$。从最近的两个时间层和空间梯度计算 $E(t_\\star)$。计算相对能量变化。\n6. 对三种测试情况重复此过程。\n\n测试套件和输出：\n- 情况 A: $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.020$, $\\sigma_1 = 0.050$, $\\sigma_2 = 0.050$, $x_1 = 0.300$, $x_2 = 0.700$。计算绝对误差 $|u(x_\\star,t_\\star) - (A_1 + A_2)|$（米）。\n- 情况 B: $L = 1.0$, $c = 1.0$, $A_1 = 0.015$, $A_2 = -0.015$, $\\sigma_1 = 0.040$, $\\sigma_2 = 0.040$, $x_1 = 0.350$, $x_2 = 0.650$。计算绝对误差 $|u(x_\\star,t_\\star) - 0.0|$（米）。\n- 情况 C: $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.013$, $\\sigma_1 = 0.030$, $\\sigma_2 = 0.070$, $x_1 = 0.250$, $x_2 = 0.750$。计算一个布尔值，如果 $|E(t_\\star)-E(0)|/E(0) < 0.02$ 则为真，否则为假。\n\n程序输出一行：一个列表，包含情况 A 的误差（米）、情况 B 的误差（米）和情况 C 的布尔值，按此顺序排列，格式为方括号内的逗号分隔列表，不含额外文本。所选的网格和时间步长确保波包在 $t_\\star$ 之前不会到达边界，这使得在模拟窗口内的干涉和能量诊断有意义且不受边界反射的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian(x, A, x0, sigma):\n    return A * np.exp(-0.5 * ((x - x0) / sigma) ** 2)\n\ndef gaussian_derivative(x, A, x0, sigma):\n    # d/dx of Gaussian profile\n    return gaussian(x, A, x0, sigma) * (-(x - x0) / (sigma ** 2))\n\ndef discrete_energy(u, v, c, dx):\n    # Spatial derivative with centered differences (one-sided at boundaries)\n    du_dx = np.empty_like(u)\n    du_dx[0] = (u[1] - u[0]) / dx\n    du_dx[-1] = (u[-1] - u[-2]) / dx\n    du_dx[1:-1] = (u[2:] - u[:-2]) / (2.0 * dx)\n    energy_density = 0.5 * (v ** 2 + (c ** 2) * (du_dx ** 2))\n    return np.sum(energy_density) * dx\n\ndef simulate_case(L, c, A1, A2, sigma1, sigma2, x1, x2, Nx=2001, CFL=0.9):\n    # Grid setup\n    x = np.linspace(0.0, L, Nx)\n    dx = x[1] - x[0]\n    dt = CFL * dx / c\n    lam2 = (c * dt / dx) ** 2\n\n    # Initial conditions u0 and v0 to produce right- and left-moving Gaussians\n    f = gaussian(x, A1, x1, sigma1)  # right-moving\n    g = gaussian(x, A2, x2, sigma2)  # left-moving\n    u0 = f + g\n    v0 = -c * gaussian_derivative(x, A1, x1, sigma1) + c * gaussian_derivative(x, A2, x2, sigma2)\n\n    # Enforce fixed ends\n    u0[0] = 0.0\n    u0[-1] = 0.0\n    v0[0] = 0.0\n    v0[-1] = 0.0\n\n    # First time step (second-order accurate)\n    u1 = np.empty_like(u0)\n    u1[1:-1] = u0[1:-1] + dt * v0[1:-1] + 0.5 * lam2 * (u0[2:] - 2.0 * u0[1:-1] + u0[:-2])\n    u1[0] = 0.0\n    u1[-1] = 0.0\n\n    # Collision time and location\n    t_star = (x2 - x1) / (2.0 * c)\n    x_star = 0.5 * (x1 + x2)\n    # Index nearest to x_star\n    i_star = int(np.round((x_star - x[0]) / dx))\n    i_star = max(0, min(Nx - 1, i_star))\n\n    # Energy at t=0\n    E0 = discrete_energy(u0, v0, c, dx)\n\n    # Time march until just past t_star\n    t_prev = 0.0\n    t_curr = dt\n    u_prev = u0.copy()\n    u_curr = u1.copy()\n\n    u_at_tstar = None\n\n    # If t_star is before dt (unlikely with these parameters), handle interpolation from u0 and u1\n    if t_prev <= t_star <= t_curr:\n        alpha = (t_star - t_prev) / (t_curr - t_prev)\n        u_at_tstar = (1.0 - alpha) * u_prev[i_star] + alpha * u_curr[i_star]\n\n    # March forward\n    # Target to go slightly beyond t_star\n    t_end = t_star + 2.0 * dt\n    n_steps = int(np.ceil((t_end - t_curr) / dt))\n    for _ in range(n_steps):\n        u_next = np.empty_like(u_curr)\n        # Interior update\n        u_next[1:-1] = (2.0 * u_curr[1:-1] - u_prev[1:-1] +\n                        lam2 * (u_curr[2:] - 2.0 * u_curr[1:-1] + u_curr[:-2]))\n        # Fixed ends\n        u_next[0] = 0.0\n        u_next[-1] = 0.0\n\n        # Advance times\n        t_next = t_curr + dt\n\n        # Capture u at t_star by temporal interpolation when crossed\n        if u_at_tstar is None and (t_curr <= t_star <= t_next):\n            alpha = (t_star - t_curr) / (t_next - t_curr)\n            u_at_tstar = (1.0 - alpha) * u_curr[i_star] + alpha * u_next[i_star]\n\n        # Shift\n        u_prev, u_curr = u_curr, u_next\n        t_prev, t_curr = t_curr, t_next\n\n    # Safety: if u_at_tstar still None due to rounding, take nearest\n    if u_at_tstar is None:\n        u_at_tstar = u_curr[i_star]\n\n    # Approximate velocity at final time level for energy at t_star\n    v_end = (u_curr - u_prev) / dt\n    E_end = discrete_energy(u_curr, v_end, c, dx)\n\n    return u_at_tstar, E0, E_end\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A: constructive interference\n    case_A = dict(L=1.0, c=1.0, A1=0.010, A2=0.020, sigma1=0.050, sigma2=0.050, x1=0.300, x2=0.700)\n    # Case B: destructive interference\n    case_B = dict(L=1.0, c=1.0, A1=0.015, A2=-0.015, sigma1=0.040, sigma2=0.040, x1=0.350, x2=0.650)\n    # Case C: energy check\n    case_C = dict(L=1.0, c=1.0, A1=0.010, A2=0.013, sigma1=0.030, sigma2=0.070, x1=0.250, x2=0.750)\n\n    # Common numerical parameters\n    Nx = 2001\n    CFL = 0.9\n\n    # Run simulations\n    uA_at_star, EA0, EAend = simulate_case(Nx=Nx, CFL=CFL, **case_A)\n    uB_at_star, EB0, EBend = simulate_case(Nx=Nx, CFL=CFL, **case_B)\n    uC_at_star, EC0, ECend = simulate_case(Nx=Nx, CFL=CFL, **case_C)\n\n    # Expected values at collision\n    expected_A = case_A[\"A1\"] + case_A[\"A2\"]  # constructive\n    expected_B = 0.0  # destructive\n\n    err_A = abs(uA_at_star - expected_A)  # meters\n    err_B = abs(uB_at_star - expected_B)  # meters\n\n    rel_energy_change_C = abs(ECend - EC0) / EC0 if EC0 != 0.0 else float('inf')\n    energy_ok_C = bool(rel_energy_change_C < 0.02)\n\n    results = [err_A, err_B, energy_ok_C]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2438583"}, {"introduction": "在构建了基础的二阶精度模拟器后，一个自然的问题是如何提高计算的准确性。这个练习 [@problem_id:2438535] 专注于数值方法本身，要求你实现一个四阶精度的空间导数近似格式，并与标准的二阶格式进行误差比较。通过量化分析，你将深刻理解数值方法的“收敛阶”概念，并体验到高阶方法在处理平滑解时的巨大优势。", "problem": "考虑一根理想、拉紧、均匀的弦在一维闭环上的微小横向振动，闭环长度为 $L$，因此位移 $u(x,t)$ 在空间上是周期性的，周期为 $L$。控制恢复力的空间算子是二阶空间导数 $\\partial^2 u / \\partial x^2$。在一个包含 $N$ 个点、间距为 $\\Delta x = L/N$ 且具有周期性边界条件的均匀网格上，通过构造两个针对 $\\partial^2 u / \\partial x^2$ 的离散近似算子，来近似该空间算子在光滑周期函数 $u(x)$ 上的作用：一个算子在 $\\Delta x$ 上具有二阶精度，另一个在 $\\Delta x$ 上具有四阶精度。对于每种近似，使用网格上的均方根（RMS）误差来量化其与精确二阶导数之间的误差。三角函数中使用的角度必须以弧度为单位进行解释。\n\n定义测试函数为 $u(x) = \\sin(k x)$，其中 $k = 2\\pi m / L$，$m \\ge 1$ 为整数模数。其精确的二阶导数为 $\\partial^2 u / \\partial x^2 = -k^2 \\sin(k x)$。对于每个指定的参数集 $(L, m, N)$，计算二阶近似的均方根误差 $E_2$ 和四阶近似的均方根误差 $E_4$，然后计算该参数集的改进因子 $I = E_2 / E_4$。\n\n您的程序必须为以下测试套件中的每个参数集实现这些计算，其中所有量均为指定的实数和整数：\n- 测试 $1$：$L = 1.0$，$m = 3$，$N = 256$。\n- 测试 $2$：$L = 1.0$，$m = 1$，$N = 5$。\n- 测试 $3$：$L = 2.0$，$m = 7$，$N = 64$。\n- 测试 $4$：$L = 2.0$，$m = 15$，$N = 64$。\n\n对于每个测试，使用均匀网格 $x_j = j \\Delta x$（其中 $j = 0, 1, \\dots, N-1$），网格间距 $\\Delta x = L/N$，并采用周期性边界条件。对于每个测试，将改进因子 $I$ 计算为浮点数。最终程序输出必须是单行，包含一个由逗号分隔的四个改进因子的列表，并用方括号括起来，每个数字四舍五入到八位小数（例如，`[1.23456789, 2.34567890, 3.45678901, 4.56789012]`）。不应打印任何其他文本。本问题中所有计算量均为无量纲，因此输出中无需物理单位。", "solution": "问题陈述具有科学依据、提法明确、客观且内容完整。它提出了计算物理学中的一个标准练习：比较数值微分格式。所有必需的参数和定义均已提供。该问题是有效的。\n\n核心任务是量化将二阶空间导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 的有限差分近似从二阶提升到四阶时精度的改进程度。这项工作在周期性域的背景下完成，这简化了有限差分模板的应用。\n\n首先，我们建立离散域和有限差分算子。问题定义在一个长度为 $L$ 的一维周期性域上。我们将此域离散化为一个包含 $N$ 个点的均匀网格，$x_j = j \\Delta x$，其中 $j = 0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/N$。周期性边界条件意味着对于任何整数 $j$，都有 $u_{j+N} = u_j$。\n\n函数 $u(x)$ 在网格点 $x_j$ 处的二阶导数可以使用其邻近点进行近似。所需算子的模板源自泰勒级数展开。\n\n二阶精度的中心差分近似 $(D_2 u)_j$ 由下式给出：\n$$ (D_2 u)_j = \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2} $$\n此近似的主导误差项与 $(\\Delta x)^2$ 成正比，因此它是一种二阶方法。\n\n四阶精度的中心差分近似 $(D_4 u)_j$ 需要一个更宽的五点模板：\n$$ (D_4 u)_j = \\frac{-u_{j+2} + 16u_{j+1} - 30u_j + 16u_{j-1} - u_{j-2}}{12(\\Delta x)^2} $$\n此处的主导误差项与 $(\\Delta x)^4$ 成正比，从而得到一种更精确的四阶方法，尤其是在 $\\Delta x$ 足够小的情况下。\n\n问题指定了一个测试函数 $u(x) = \\sin(kx)$，其中波数 $k = 2\\pi m / L$ 由整数模数 $m \\ge 1$ 确定。选择正弦函数是理想的，因为它是空间微分算子的本征函数。其精确的二阶导数很容易通过解析方法计算：\n$$ \\frac{\\partial^2 u}{\\partial x^2} = -k^2 \\sin(kx) $$\n\n为了执行计算，我们首先在离散网格上评估测试函数 $u(x)$ 及其精确的二阶导数，得到向量 $u_j = \\sin(k x_j)$ 和 $(u''_{\\text{exact}})_j = -k^2 u_j$。\n\n接下来，我们将离散算子 $D_2$ 和 $D_4$ 应用于向量 $u_j$。通过将索引对 $N$ 取模来处理周期性边界条件。例如，当 $j=0$ 时，索引 $j-1$ 处的值为 $u_{-1} = u_{N-1}$，当 $j=N-1$ 时，索引 $j+1$ 处的值为 $u_N = u_0$。这种环绕索引可以通过对向量 $u_j$ 执行循环移位或滚动操作来高效实现。\n\n有了精确导数 $(u''_{\\text{exact}})_j$ 和两种近似 $(D_2 u)_j$ 和 $(D_4 u)_j$，我们就可以量化每种格式的误差。问题要求计算均方根（RMS）误差，对于二阶格式，其计算公式为：\n$$ E_2 = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} \\left( (D_2 u)_j - (u''_{\\text{exact}})_j \\right)^2} $$\n同样地，对于四阶格式：\n$$ E_4 = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} \\left( (D_4 u)_j - (u''_{\\text{exact}})_j \\right)^2} $$\n\n最后，改进因子 $I$ 是这些误差的比值：\n$$ I = \\frac{E_2}{E_4} $$\n这个无量纲因子衡量了对于给定的参数集 $(L, m, N)$，四阶格式相对于二阶格式的精度提高了多少倍。计算过程涉及为四个指定的测试用例中的每一个计算该因子。实现将使用 `numpy` 进行高效的数组操作，特别是使用 `numpy.roll` 来处理周期性边界条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the improvement factor of a fourth-order finite difference scheme over a\n    second-order scheme for approximating the second derivative of a sine function\n    on a periodic grid.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, m, N)\n        (1.0, 3, 256),\n        (1.0, 1, 5),\n        (2.0, 7, 64),\n        (2.0, 15, 64),\n    ]\n\n    results = []\n    for L, m, N in test_cases:\n        # 1. Define grid and function parameters\n        delta_x = L / N\n        k = 2.0 * np.pi * m / L\n        \n        # 2. Evaluate the function and its exact second derivative on the grid\n        x_grid = np.arange(N) * delta_x\n        u = np.sin(k * x_grid)\n        u_xx_exact = -k**2 * u\n        \n        # 3. Compute the second-order approximation\n        # The stencil is [1, -2, 1] / dx^2\n        # np.roll handles periodic boundary conditions\n        u_jp1 = np.roll(u, -1)\n        u_jm1 = np.roll(u, 1)\n        u_xx_2 = (u_jp1 - 2.0 * u + u_jm1) / delta_x**2\n        \n        # 4. Compute the fourth-order approximation\n        # The stencil is [-1, 16, -30, 16, -1] / (12 * dx^2)\n        u_jp2 = np.roll(u, -2)\n        u_jm2 = np.roll(u, 2)\n        u_xx_4 = (-u_jp2 + 16.0 * u_jp1 - 30.0 * u + 16.0 * u_jm1 - u_jm2) / (12.0 * delta_x**2)\n        \n        # 5. Calculate the Root-Mean-Square (RMS) error for each approximation\n        error_2 = u_xx_2 - u_xx_exact\n        E2 = np.sqrt(np.mean(error_2**2))\n        \n        error_4 = u_xx_4 - u_xx_exact\n        E4 = np.sqrt(np.mean(error_4**2))\n        \n        # 6. Compute the improvement factor I = E2 / E4\n        # If E4 is extremely close to zero, this could be a large number, which is expected.\n        # The problem setup ensures E4 is not exactly zero for the given test cases.\n        improvement_factor = E2 / E4\n        results.append(improvement_factor)\n\n    # Final print statement in the exact required format.\n    # Each number is rounded to eight decimal places.\n    print(f\"[{','.join([f'{r:.8f}' for r in results])}]\")\n\nsolve()\n```", "id": "2438535"}, {"introduction": "真实的物理系统往往比理想模型更复杂，例如介质属性可能随空间和时间变化。这个练习 [@problem_id:2438557] 让你挑战一个更高级的场景：模拟一根波速受移动“光斑”调制的弦的振动。你需要推导并实现一个适用于变系数波动方程的保守型有限差分格式，这对于模拟非均匀介质中的波动现象是一项至关重要的技能。", "problem": "要求您为一个一维振动弦建模，其局部波速受光调制。横向位移场表示为 $u(x,t)$，定义在空间域 $x \\in [0,L]$ 上，弦的两端固定。从牛顿第二定律和局部波速 $c(x,t)$ 的定义出发，为下面的偏微分方程\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\!\\big(c^2(x,t)\\,u_x(x,t)\\big),\n$$\n推导一个在空间和时间上均为二阶精确的守恒有限差分格式，其中边界条件为齐次 Dirichlet 条件 $u(0,t)=u(L,t)=0$，初始数据为给定的 $u(x,0)=u_0(x)$ 和 $u_t(x,0)=v_0(x)$。光敏波速由下式给出\n$$\nc(x,t) \\;=\\; c_0\\,\\sqrt{\\,1 - \\beta\\,I(x,t)\\,},\\quad\nI(x,t) \\;=\\; \\exp\\!\\left(-\\dfrac{(x - x_s(t))^2}{2\\sigma^2}\\right),\\quad\nx_s(t) \\;=\\; x_{\\text{start}} + v_s\\,t,\n$$\n其中 $c_0$ 是基准波速（单位 $\\mathrm{m/s}$），$0 \\le \\beta < 1$ 是光敏系数（无量纲），$\\sigma$ 是光斑宽度（单位 $\\mathrm{m}$），$v_s$ 是光斑速度（单位 $\\mathrm{m/s}$）。您可以假设所有参数都使得 $c(x,t)$ 在所有关心的 $x$ 和 $t$ 上保持为实数且严格为正。\n\n您的任务是：\n1) 从一小段弦元的受力平衡以及定义 $c^2(x,t) = T(x,t)/\\rho$（其中 $T(x,t)$ 是局部张力，$\\rho$ 是单位长度的质量密度）出发，证明在小斜率极限下，当光通过 $T(x,t)=\\rho\\,c^2(x,t)$ 调制张力（其中 $c(x,t)$ 如给定形式）时，可以导出上述控制方程。\n\n2) 在均匀网格 $x_i = i\\,\\Delta x$（$i=0,1,\\dots,N-1$，$\\Delta x = L/(N-1)$）和均匀时间步长 $t^n = n\\,\\Delta t$（$n=0,1,2,\\dots$）上对方程进行离散化。在空间上，对通量 $\\partial_x\\!\\big(c^2 u_x\\big)$ 使用中心差分，并在半节点处计算系数；在时间上，对 $u_{tt}$ 使用中心差分。即，使用以下近似：\n$$\n\\big(c^2 u_x\\big)_x\\Big|_{x=x_i,\\,t=t^{n+\\tfrac{1}{2}}} \\;\\approx\\; \\dfrac{1}{\\Delta x^2}\\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}\\,(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}\\,(u^n_i-u^n_{i-1})\\right],\n$$\n其中 $a^{n+\\tfrac{1}{2}}_{i\\pm \\tfrac{1}{2}}$ 通过节点值 $a=c^2$ 的算术平均来近似 $c^2\\!\\left(x_{i\\pm \\tfrac{1}{2}},t^{n+\\tfrac{1}{2}}\\right)$。推导内部节点 $i=1,\\dots,N-2$ 上 $u^{n+1}_i$ 的显式更新公式，以及一个使用 $u^0_i$、$v^0_i$ 和在 $t^{\\tfrac{1}{2}}$ 处计算的空间算子的、用于计算 $u^1_i$ 的相容二阶启动公式。\n\n3) 陈述一个关于稳定性的充分 Courant–Friedrichs–Lewy (CFL) 条件，用 $\\Delta t$、$\\Delta x$ 和最大波速表示。用此条件通过 $\\Delta t = C_{\\mathrm{CFL}}\\,\\Delta x/\\max_{x,t} c(x,t)$（其中 $0 < C_{\\mathrm{CFL}} \\le 1$）来选择 $\\Delta t$。对于本问题，您必须取 $C_{\\mathrm{CFL}} = 0.9$，并注意对于给定模型，$\\max_{x,t} c(x,t) = c_0$。\n\n4) 在一个程序中实现该显式格式，并运行三个指定的测试用例。使用固定端点边界条件 $u_0^n = u_{N-1}^n = 0$（对所有 $n$）。所需的观测量和单位在下面指定。\n\n实现细节和物理单位：\n- 所有长度单位必须是 $\\mathrm{m}$，时间单位是 $\\mathrm{s}$，波速单位是 $\\mathrm{m/s}$。位移以 $\\mathrm{m}$ 报告，频率以 $\\mathrm{Hz}$ 报告。\n- 如果使用角度，单位必须是弧度。\n- 最终程序必须产生单行输出，包含一个 Python 风格的列表，内有三个浮点数，按测试用例的顺序排列，每个数四舍五入到六位小数。\n\n测试套件（每组测试必须使用提供的参数独立模拟）：\n- 测试 $1$ （正常情况；移动光斑，高斯初始扰动）：\n  - $L = 1.0\\,\\mathrm{m}$，$c_0 = 100.0\\,\\mathrm{m/s}$，$\\beta = 0.3$，$\\sigma = 0.05\\,\\mathrm{m}$，$v_s = 2.0\\,\\mathrm{m/s}$，$x_{\\text{start}} = 0.0\\,\\mathrm{m}$。\n  - 网格：$N = 401$ 个点，因此 $\\Delta x = L/(N-1)$。\n  - 时间步长：$\\Delta t = 0.9\\,\\Delta x/c_0$。\n  - 终止时间：$T_{\\text{end}} = 0.015\\,\\mathrm{s}$。\n  - 初始条件：$u_0(x) = A\\,\\exp\\!\\left(-\\dfrac{(x-x_c)^2}{2w^2}\\right)$，其中 $A = 1.0\\times 10^{-3}\\,\\mathrm{m}$，$x_c = 0.25\\,L$，$w = 0.02\\,\\mathrm{m}$，且 $v_0(x)=0$。\n  - 输出：位移在终止时间的空间 $\\mathrm{L}^2$ 范数，定义为 $\\|u(\\cdot,T_{\\text{end}})\\|_2 = \\left(\\sum_{i=0}^{N-1} u_i^2(T_{\\text{end}})\\,\\Delta x\\right)^{1/2}$，单位为 $\\mathrm{m}$。\n\n- 测试 $2$ （边界交互边缘情况；存在光斑，扰动靠近边界）：\n  - $L = 1.0\\,\\mathrm{m}$，$c_0 = 100.0\\,\\mathrm{m/s}$，$\\beta = 0.5$，$\\sigma = 0.03\\,\\mathrm{m}$，$v_s = 3.0\\,\\mathrm{m/s}$，$x_{\\text{start}} = 0.0\\,\\mathrm{m}$。\n  - 网格：$N = 401$。\n  - 时间步长：$\\Delta t = 0.9\\,\\Delta x/c_0$。\n  - 终止时间：$T_{\\text{end}} = 0.010\\,\\mathrm{s}$。\n  - 初始条件：$u_0(x) = A\\,\\exp\\!\\left(-\\dfrac{(x-x_c)^2}{2w^2}\\right)$，其中 $A = 1.0\\times 10^{-3}\\,\\mathrm{m}$，$x_c = 0.02\\,\\mathrm{m}$，$w = 0.01\\,\\mathrm{m}$，且 $v_0(x)=0$。\n  - 输出：在整个模拟区间内，弦上任意位置观测到的最大绝对位移，即 $\\max_{0\\le n \\le T_{\\text{end}}/\\Delta t}\\max_{0\\le i \\le N-1} |u_i^n|$，单位为 $\\mathrm{m}$。\n\n- 测试 $3$ （一致性检查；无光斑，第一简正模与频率提取）：\n  - $L = 1.0\\,\\mathrm{m}$，$c_0 = 100.0\\,\\mathrm{m/s}$，$\\beta = 0.0$（因此 $c(x,t)\\equiv c_0$），$\\sigma$ 和 $v_s$ 为任意值且不使用。\n  - 网格：$N = 601$。\n  - 时间步长：$\\Delta t = 0.9\\,\\Delta x/c_0$。\n  - 终止时间：$T_{\\text{end}} = 0.100\\,\\mathrm{s}$。\n  - 初始条件：$u_0(x) = A\\,\\sin\\!\\left(\\dfrac{\\pi x}{L}\\right)$，其中 $A=1.0\\times 10^{-3}\\,\\mathrm{m}$ 且 $v_0(x)=0$。\n  - 跟踪波腹 $x=L/2$ 处的位移 $u$ 随时间的变化，通过检测零点穿越并对穿越时间进行线性插值来估计平均周期，从而估算主导振荡频率。理论上的第一模态频率为 $f_1 = c_0/(2L)$，单位为 $\\mathrm{Hz}$。\n  - 输出：绝对误差 $|f_{\\text{num}} - f_1|$，单位为 $\\mathrm{Hz}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 列表，内含与测试 $1$、$2$、$3$ 依次对应的三个数字，四舍五入到六位小数，例如：`[0.001234,0.001345,0.000120]`。", "solution": "所提出的问题是计算物理学中一个标准的、适定的初边值问题。它在科学上是合理的，数学上是一致的，并且为获得唯一的、稳定的数值解所需的所有参数和条件均已提供。因此，该问题被认定为 **有效**，并将提供解答。\n\n主要任务是为具有可变系数的一维波动方程推导并实现一个有限差分格式，该方程由下式给出\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\!\\big(c^2(x,t)\\,u_x(x,t)\\big)\n$$\n其中 $u(x,t)$ 是弦的横向位移，$c(x,t)$ 是非均匀、随时间变化的波速。\n\n**1. 控制方程的推导**\n\n我们从牛顿第二定律开始，将其应用于水平位置 $x$ 和 $x+\\Delta x$ 之间长度为 $\\Delta s$ 的微小弦元。设 $\\rho$ 为恒定的线质量密度。该弦元的质量为 $\\Delta m = \\rho \\Delta s$。对于小位移，斜率 $u_x = \\partial u/\\partial x$ 很小，因此弦元长度约等于其水平投影，即 $\\Delta s \\approx \\Delta x$。此时质量为 $\\Delta m \\approx \\rho \\Delta x$。\n\n作用在弦元上的净垂直力是其两端张力 $T(x,t)$ 的垂直分量之差。某一点张力的垂直分量是 $T \\sin\\theta$，其中 $\\theta$ 是弦与水平方向的夹角。在小斜率近似下，$\\sin\\theta \\approx \\tan\\theta = u_x$。\n因此，净垂直力 $\\Delta F_v$ 为\n$$\n\\Delta F_v \\;=\\; T(x+\\Delta x, t)\\,u_x(x+\\Delta x, t) - T(x,t)\\,u_x(x,t).\n$$\n根据牛顿第二定律 $F=ma$，净力等于质量乘以加速度，其中加速度是位移对时间的二阶偏导数 $u_{tt}$。\n$$\n(\\rho \\Delta x)\\, u_{tt}(x,t) \\;=\\; T(x+\\Delta x, t)\\,u_x(x+\\Delta x, t) - T(x,t)\\,u_x(x,t).\n$$\n两边同除以 $\\Delta x$ 并取 $\\Delta x \\to 0$ 的极限，得到对 $x$ 的偏导数定义：\n$$\n\\rho\\,u_{tt}(x,t) \\;=\\; \\partial_x \\big( T(x,t)\\,u_x(x,t) \\big).\n$$\n问题陈述波速的平方由 $c^2(x,t) = T(x,t)/\\rho$ 定义，这意味着张力被调制为 $T(x,t) = \\rho\\,c^2(x,t)$。将此代入运动方程得到\n$$\n\\rho\\,u_{tt}(x,t) \\;=\\; \\partial_x \\big( \\rho\\,c^2(x,t)\\,u_x(x,t) \\big).\n$$\n由于 $\\rho$ 是一个常数，它可以从空间导数中提出并在方程两边消去，从而得到指定的控制方程：\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\big(c^2(x,t)\\,u_x(x,t)\\big).\n$$\n推导完成。该方程的形式是守恒的，因为其空间部分是一个通量的散度，在此情况下是横向动量的通量。\n\n**2. 有限差分格式的推导**\n\n我们用均匀空间网格 $x_i = i\\,\\Delta x$（$i=0, 1, \\dots, N-1$，其中 $\\Delta x = L/(N-1)$）和均匀时间步长 $t^n = n\\,\\Delta t$ 来离散化求解域。位移表示为 $u_i^n \\approx u(x_i, t^n)$。\n\n在点 $(x_i, t^n)$ 处的二阶时间导数 $u_{tt}$ 使用二阶精确的中心差分进行近似：\n$$\nu_{tt}(x_i, t^n) \\;\\approx\\; \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{\\Delta t^2}.\n$$\n空间算子 $\\partial_x(c^2 u_x)$ 按照问题陈述中的要求进行离散。这是一种针对通量项的二阶精确中心差分格式。令 $a(x,t) = c^2(x,t)$。通量为 $F(x,t) = a(x,t)u_x(x,t)$。我们有 $\\partial_x F \\approx (F_{i+1/2} - F_{i-1/2})/\\Delta x$。在半网格点处的通量近似为 $F_{i\\pm 1/2} \\approx a_{i\\pm 1/2} (u_{i\\pm 1} - u_i)/\\Delta x$。这导致了指定的格式，我们将其记为 $\\mathcal{L}[u]$。问题要求在半时间步 $t^{n+1/2}$ 处计算系数 $a = c^2$，同时使用时间 $t^n$ 处的位移 $u$。完整的离散方程是：\n$$\n\\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{\\Delta t^2} \\;=\\; \\frac{1}{\\Delta x^2}\\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}\\,(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}\\,(u^n_i-u^n_{i-1})\\right],\n$$\n其中半节点处的系数是节点值的算术平均：\n$$\na^{n+\\tfrac{1}{2}}_{i\\pm\\tfrac{1}{2}} \\;=\\; \\frac{1}{2}\\left( a(x_i, t^{n+\\tfrac{1}{2}}) + a(x_{i\\pm 1}, t^{n+\\tfrac{1}{2}}) \\right).\n$$\n该格式是显式的。求解 $u_i^{n+1}$ 得到内部节点（$i=1, \\dots, N-2$）的更新规则：\n$$\nu_i^{n+1} \\;=\\; 2u_i^n - u_i^{n-1} + \\left(\\frac{\\Delta t}{\\Delta x}\\right)^2 \\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}(u^n_i-u^n_{i-1})\\right].\n$$\n边界条件为 $u_0^n = 0$ 和 $u_{N-1}^n = 0$（对所有 $n \\ge 0$）。\n\n对于第一个时间步（$n=0$），我们需要 $u^1_i$。通用更新规则需要 $u^{-1}_i$，但它并未给出。我们使用初始速度 $v_0(x) = u_t(x,0)$ 和在 $t=0$ 处的中心差分近似：\n$$\nv_i^0 \\;\\approx\\; \\frac{u_i^1 - u_i^{-1}}{2\\Delta t} \\quad\\implies\\quad u_i^{-1} \\;=\\; u_i^1 - 2\\Delta t v_i^0.\n$$\n将此代入 $n=0$ 的更新规则中得到：\n$$\nu_i^1 \\;=\\; 2u_i^0 - (u_i^1 - 2\\Delta t v_i^0) + \\Delta t^2 \\mathcal{L}^{1/2}[u^0]_i,\n$$\n其中 $\\mathcal{L}^{1/2}[u^0]_i$ 是空间算子，其系数在 $t^{1/2}=\\Delta t/2$ 处计算并作用于 $u^0$。求解 $u_i^1$ 得到二阶精确的启动公式：\n$$\nu_i^1 \\;=\\; u_i^0 + \\Delta t v_i^0 + \\frac{\\Delta t^2}{2} \\mathcal{L}^{1/2}[u^0]_i.\n$$\n此公式与问题的要求一致。\n\n**3. 稳定性条件**\n\n对于波动方程的显式有限差分格式，稳定性由 Courant–Friedrichs–Lewy (CFL) 条件决定。对于可变波速 $c(x,t)$，一个充分的稳定性条件是数值依赖域必须包含物理依赖域。这导致了以下要求：\n$$\nC_{\\text{CFL}} \\;=\\; \\frac{\\max_{x,t} c(x,t) \\cdot \\Delta t}{\\Delta x} \\;\\le\\; 1.\n$$\n波速由 $c(x,t) = c_0\\sqrt{1 - \\beta I(x,t)}$ 给出。由于 $0 \\le \\beta < 1$ 且强度项 $I(x,t) = \\exp(\\dots)$ 是非负的，所以 $c(x,t)$ 的最大值出现在 $I(x,t)$ 取最小值处。$I(x,t)$ 的最小值为 $0$，当 $|x-x_s(t)| \\to \\infty$ 时取到。因此，$\\max_{x,t} c(x,t) = c_0$。\n稳定性条件简化为 $c_0 \\Delta t / \\Delta x \\le 1$。问题指定将时间步长选择为\n$$\n\\Delta t = 0.9 \\frac{\\Delta x}{c_0},\n$$\n这对应于 Courant 数 $C_{\\text{CFL}} = 0.9$。由于 $0.9 \\le 1$，在此选择下格式是稳定的。\n\n**4. 实现策略**\n\n该数值格式使用 Python 和 `numpy` 库来实现，以进行高效的数组运算。\n- 模拟状态由三个数组维持：`u_prev` ($u^{n-1}$)、`u_curr` ($u^n$) 和 `u_next` ($u^{n+1}$)。\n- 模拟开始时，通过初始条件 $u_0(x)$ 初始化 `u_curr` 并应用边界条件。\n- 第一个时间步使用推导出的启动公式计算 $u^1$，这是一个特殊情况，因为所有测试用例的初始速度 $v_0(x)=0$。\n- 然后，主循环从 $n=1$ 迭代到最终时间步。在每次迭代中，它使用通用更新规则从 $u^n$ 和 $u^{n-1}$ 计算 $u^{n+1}$。\n- 在每一步中，首先计算与时间相关的系数 $a(x, t^{n+1/2})$，然后计算平均后的半节点系数。接着，使用向量化的 `numpy` 操作在内部网格点上计算空间算子。\n- 每次更新后都强制执行边界条件 $u_0=0, u_{N-1}=0$。\n- 计算每个测试用例所需的观测量：\n  - **测试 1**：最终的空间 $\\mathrm{L}^2$ 范数 $\\|u(\\cdot, T_{\\text{end}})\\|_2 = \\left(\\sum_i (u_i^{\\text{final}})^2 \\Delta x\\right)^{1/2}$，在循环结束后计算。\n  - **测试 2**：最大绝对位移 $\\max_{n,i}|u_i^n|$，在每个时间步的循环内更新。\n  - **测试 3**：记录弦中点 $u(L/2, t)$ 的位移。模拟结束后，处理这些时间序列数据，通过符号变化来检测零点穿越。使用线性插值来估计每次穿越的精确时间。穿越点之间的时间差的平均值给出了半周期，由此计算出数值频率 $f_{\\text{num}}$。最终结果是绝对误差 $|f_{\\text{num}} - f_1|$，其中 $f_1 = c_0/(2L)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs three test cases for the vibrating string simulation.\n    \"\"\"\n\n    def run_simulation(L, c0, beta, sigma, vs, x_start, N, T_end, u0_func, v0_func, C_CFL=0.9):\n        \"\"\"\n        Generic simulation engine for the 1D wave equation with variable coefficients.\n        \"\"\"\n        dx = L / (N - 1)\n        x = np.linspace(0, L, N)\n        \n        c_max = c0\n        dt = C_CFL * dx / c_max\n        \n        num_steps = int(np.ceil(T_end / dt))\n        \n        def x_s(t):\n            \"\"\"Calculates the center of the moving spotlight at a given time.\"\"\"\n            return x_start + vs * t\n\n        def I(x_nodes, t):\n            \"\"\"Calculates the light intensity profile on the grid at a given time.\"\"\"\n            return np.exp(-(x_nodes - x_s(t))**2 / (2 * sigma**2))\n\n        def a(x_nodes, t):\n            \"\"\"Calculates the square of the wave speed, c^2, on the grid.\"\"\"\n            if beta == 0:\n                return np.full_like(x_nodes, c0**2)\n            return c0**2 * (1 - beta * I(x_nodes, t))\n\n        # Initialize displacement fields\n        u_prev = np.zeros(N)\n        u_curr = u0_func(x)\n        u_next = np.zeros(N)\n        v0 = v0_func(x)\n        \n        # Apply boundary conditions to initial state\n        u_curr[0] = 0\n        u_curr[-1] = 0\n\n        # Storage for observables\n        max_abs_u = np.max(np.abs(u_curr))\n        u_mid_history = []\n        time_history = []\n        mid_point_idx = (N - 1) // 2\n\n        # First step (n=0 to n=1) using the second-order start-up formula\n        t_half = 0.5 * dt\n        a_vals_t_half = a(x, t_half)\n        \n        a_half_p = 0.5 * (a_vals_t_half[1:-1] + a_vals_t_half[2:])\n        a_half_m = 0.5 * (a_vals_t_half[:-2] + a_vals_t_half[1:-1])\n\n        spatial_op_u0 = (a_half_p * (u_curr[2:] - u_curr[1:-1]) - \n                         a_half_m * (u_curr[1:-1] - u_curr[:-2]))\n        \n        u_next[1:-1] = (u_curr[1:-1] + dt * v0[1:-1] + \n                        0.5 * (dt / dx)**2 * spatial_op_u0)\n\n        # Update state variables for the main loop\n        u_prev[:] = u_curr\n        u_curr[:] = u_next\n        \n        # Update observables after first step\n        max_abs_u = max(max_abs_u, np.max(np.abs(u_curr)))\n        if beta == 0.0:  # For Test 3\n            u_mid_history.append(u_curr[mid_point_idx])\n            time_history.append(dt)\n        \n        # Main time-stepping loop (n=1, 2, ..., num_steps-1)\n        for n in range(1, num_steps):\n            t_n_plus_half = (n + 0.5) * dt\n            \n            a_vals_n_plus_half = a(x, t_n_plus_half)\n            \n            a_half_p = 0.5 * (a_vals_n_plus_half[1:-1] + a_vals_n_plus_half[2:])\n            a_half_m = 0.5 * (a_vals_n_plus_half[:-2] + a_vals_n_plus_half[1:-1])\n\n            spatial_op_un = (a_half_p * (u_curr[2:] - u_curr[1:-1]) -\n                             a_half_m * (u_curr[1:-1] - u_curr[:-2]))\n            \n            u_next[1:-1] = (2 * u_curr[1:-1] - u_prev[1:-1] + \n                            (dt / dx)**2 * spatial_op_un)\n            \n            u_prev[:] = u_curr\n            u_curr[:] = u_next\n            \n            max_abs_u = max(max_abs_u, np.max(np.abs(u_curr)))\n            if beta == 0.0:\n                u_mid_history.append(u_curr[mid_point_idx])\n                time_history.append((n + 1) * dt)\n\n        return u_curr, dx, max_abs_u, u_mid_history, time_history\n\n    # --- Test Case 1 ---\n    L1, c0_1, beta1, sigma1, vs1, x_start1 = 1.0, 100.0, 0.3, 0.05, 2.0, 0.0\n    N1, T_end1 = 401, 0.015\n    A1, xc1, w1 = 1.0e-3, 0.25 * L1, 0.02\n    u0_1 = lambda x: A1 * np.exp(-(x - xc1)**2 / (2 * w1**2))\n    v0_1 = lambda x: np.zeros_like(x)\n    u_final1, dx1, _, _, _ = run_simulation(L1, c0_1, beta1, sigma1, vs1, x_start1, N1, T_end1, u0_1, v0_1)\n    l2_norm = np.sqrt(np.sum(u_final1**2) * dx1)\n    result1 = round(l2_norm, 6)\n\n    # --- Test Case 2 ---\n    L2, c0_2, beta2, sigma2, vs2, x_start2 = 1.0, 100.0, 0.5, 0.03, 3.0, 0.0\n    N2, T_end2 = 401, 0.010\n    A2, xc2, w2 = 1.0e-3, 0.02, 0.01\n    u0_2 = lambda x: A2 * np.exp(-(x - xc2)**2 / (2 * w2**2))\n    v0_2 = lambda x: np.zeros_like(x)\n    _, _, max_u, _, _ = run_simulation(L2, c0_2, beta2, sigma2, vs2, x_start2, N2, T_end2, u0_2, v0_2)\n    result2 = round(max_u, 6)\n\n    # --- Test Case 3 ---\n    L3, c0_3, beta3, N3, T_end3, A3 = 1.0, 100.0, 0.0, 601, 0.100, 1.0e-3\n    u0_3 = lambda x: A3 * np.sin(np.pi * x / L3)\n    v0_3 = lambda x: np.zeros_like(x)\n    _, _, _, u_mid, t_hist = run_simulation(L3, c0_3, beta3, 1.0, 0.0, 0.0, N3, T_end3, u0_3, v0_3)\n    \n    u_mid = np.array(u_mid)\n    t_hist = np.array(t_hist)\n    \n    # Find zero crossings by detecting sign changes\n    crossings_indices = np.where(np.diff(np.sign(u_mid)))[0]\n    \n    crossing_times = []\n    for idx in crossings_indices:\n        t1, t2 = t_hist[idx], t_hist[idx+1]\n        u1, u2 = u_mid[idx], u_mid[idx+1]\n        # Linear interpolation to find precise time of zero crossing\n        if u2 - u1 != 0:\n            t_cross = t1 - u1 * (t2 - t1) / (u2 - u1)\n            crossing_times.append(t_cross)\n            \n    if len(crossing_times) < 2:\n        f_num = np.nan\n    else:\n        half_periods = np.diff(crossing_times)\n        avg_period = 2 * np.mean(half_periods)\n        f_num = 1 / avg_period\n        \n    f_theory = c0_3 / (2 * L3)\n    abs_error = abs(f_num - f_theory)\n    result3 = round(abs_error, 6)\n    \n    results = [f\"{result1:.6f}\", f\"{result2:.6f}\", f\"{result3:.6f}\"]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2438557"}]}