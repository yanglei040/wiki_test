{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本练习是应用 Lax-Wendroff 格式的一个基本实践，旨在解决一维线性平流问题。通过将数值解与精确解进行比较，您将学习如何量化一个关键的数值误差——相位误差，这源于数值色散效应，即不同波长的波在数值模拟中以略微不同的速度传播。这项练习不仅能帮助您掌握 Lax-Wendroff 格式的实现，还能培养您对数值精度进行定量分析的能力。[@problem_id:2407698]", "problem": "考虑在周期性空间域 $x \\in [0,1]$ 上的线性平流方程 $u_t + u_x = 0$，其无量纲波速 $a=1$ 并采用周期性边界条件。初始条件为 $u(x,0) = \\sin(10 \\pi x)$。精确解由特征位移给出，为 $u(x,t) = \\sin(10 \\pi (x - t))$。一个完整的时间周期对应于 $T=1$，因为在周期性域上，一个域长度的位移会使解恢复为其自身。\n\n您需要在一个包含 $N$ 个点、间距为 $\\Delta x = 1/N$ 的均匀网格上，计算 $t=T$ 时刻的全离散数值解。使用的时间步长 $\\Delta t$ 需满足库朗数 $C = \\Delta t / \\Delta x$ 等于一个给定值，并且经过整数步数后达到最终时间 $T$。假设在所有测试案例中 $N/C$ 均为整数，因此步数 $n_{\\text{steps}} = N/C$，时间步长 $\\Delta t = T / n_{\\text{steps}}$。请使用一种与守恒律 $u_t + u_x = 0$ 的时间二阶泰勒展开一致的二阶精度显式方法，将解从 $t=0$ 推进到 $t=T$，并应用周期性边界条件。\n\n在 $t=T$ 时刻，获得网格点 $x_j = j \\Delta x$（其中 $j=0,1,\\dots,N-1$）上的数值解 $u_j^{\\text{num}}$ 后，通过拟合一个相移 $\\varphi \\in (-\\pi,\\pi]$ 来量化相位误差。拟合的目标是使形式为 $A \\sin(10 \\pi x_j - \\varphi)$ 的位移正弦曲线（其中振幅 $A \\in \\mathbb{R}$ 可自由变化）在最小二乘意义下最佳地逼近 $u_j^{\\text{num}}$。形式上，将相位误差 $\\varphi^\\star$ 定义为以下表达式的任意一个最小值点：\n$$\n\\min_{\\varphi \\in (-\\pi,\\pi],\\, A \\in \\mathbb{R}} \\sum_{j=0}^{N-1} \\left[u_j^{\\text{num}} - A \\sin(10 \\pi x_j - \\varphi)\\right]^2.\n$$\n报告以弧度为单位的相位误差 $\\varphi^\\star$。每个报告的相位误差必须四舍五入到八位小数。\n\n使用以下参数对 $(N,C)$ 的测试套件：\n- $(N,C) = (200, 0.5)$,\n- $(N,C) = (100, 1.0)$,\n- $(N,C) = (20, 0.8)$,\n- $(N,C) = (90, 0.9)$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果顺序与测试套件的顺序相同，例如 $[\\varphi_1,\\varphi_2,\\varphi_3,\\varphi_4]$，其中每个 $\\varphi_i$ 是按上述规定四舍五入后的相位误差（以弧度为单位）。", "solution": "所提出的问题是计算物理学中的一个标准练习：量化用于求解线性平流方程的有限差分格式的数值误差。该问题是适定的，具有科学依据，并包含了获得其唯一解所需的所有信息。我将开始进行求解。\n\n控制偏微分方程 (PDE) 是具有恒定波速 $a$ 的线性平流方程：\n$$ \\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0 $$\n问题指定了无量纲波速 $a=1$、周期性空间域 $x \\in [0,1]$ 以及初始条件 $u(x,0) = \\sin(10 \\pi x)$。积分的最终时间为 $T=1$，这对应于波穿过长度为 $1$ 的域所需的一个完整周期。在此刻，精确解 $u(x,t) = \\sin(10 \\pi (x-at))$ 返回到其初始状态：\n$$ u(x,T) = u(x,1) = \\sin(10 \\pi (x-1)) = \\sin(10 \\pi x - 10 \\pi) = \\sin(10 \\pi x) $$\n因此，在 $t=T$ 时，精确解相对于初始条件的相移为 $0$。在数值解中观察到的任何相移都代表了该格式的累积相位误差。\n\n问题要求使用一种从泰勒展开推导出的二阶精度显式方法。经典的选择是 Lax-Wendroff 格式。我们从 $u(x, t+\\Delta t)$ 的泰勒级数开始：\n$$ u(x, t+\\Delta t) = u(x,t) + \\Delta t \\frac{\\partial u}{\\partial t} + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 u}{\\partial t^2} + \\mathcal{O}((\\Delta t)^3) $$\n根据 PDE，我们有 $\\frac{\\partial u}{\\partial t} = -a \\frac{\\partial u}{\\partial x}$。假设函数足够光滑，对时间求导可得到时间二阶导数：\n$$ \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial}{\\partial t}\\left(-a \\frac{\\partial u}{\\partial x}\\right) = -a \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial u}{\\partial t}\\right) = -a \\frac{\\partial}{\\partial x}\\left(-a \\frac{\\partial u}{\\partial x}\\right) = a^2 \\frac{\\partial^2 u}{\\partial x^2} $$\n将这些代入泰勒展开，得到一个半离散格式：\n$$ u(x, t+\\Delta t) = u(x,t) - a \\Delta t \\frac{\\partial u}{\\partial x} + \\frac{a^2 (\\Delta t)^2}{2} \\frac{\\partial^2 u}{\\partial x^2} + \\mathcal{O}((\\Delta t)^3) $$\n为了获得一个全离散格式，我们引入均匀网格 $x_j = j \\Delta x$ 和时间层 $t_n = n \\Delta t$。令 $u_j^n \\approx u(x_j, t_n)$。我们使用二阶中心有限差分来近似空间导数：\n$$ \\frac{\\partial u}{\\partial x}\\bigg|_{x_j, t_n} \\approx \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x} $$\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j, t_n} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} $$\n代入这些近似值，得到了 $u_j^{n+1}$ 的显式更新规则：\n$$ u_j^{n+1} = u_j^n - a \\Delta t \\left( \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x} \\right) + \\frac{a^2 (\\Delta t)^2}{2} \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} \\right) $$\n引入库朗数 $C = a \\Delta t / \\Delta x$（对于本问题，$a=1$，因此 $C = \\Delta t / \\Delta x$），我们可以通过收集关于 $u_{j-1}^n$、$u_j^n$ 和 $u_{j+1}^n$ 的项来重排该格式：\n$$ u_j^{n+1} = u_j^n - \\frac{C}{2} (u_{j+1}^n - u_{j-1}^n) + \\frac{C^2}{2} (u_{j+1}^n - 2u_j^n + u_{j-1}^n) $$\n$$ u_j^{n+1} = \\left(\\frac{C^2}{2} + \\frac{C}{2}\\right) u_{j-1}^n + (1 - C^2) u_j^n + \\left(\\frac{C^2}{2} - \\frac{C}{2}\\right) u_{j+1}^n $$\n这就是 Lax-Wendroff 格式。它是一种显式的三点模板格式，在空间和时间上均为二阶精度，并且当 $|C| \\le 1$ 时是冯·诺依曼稳定的。周期性边界条件通过在每个时间步设置 $u_{-1}^n = u_{N-1}^n$ 和 $u_N^n = u_0^n$ 来施加。\n\n在使用 $n_{\\text{steps}}=T/\\Delta t = N/C$ 步将解从 $t=0$ 推进到 $t=T$ 后，我们获得了网格点 $x_j$ 上的数值解 $u_j^{\\text{num}}$。最后一步是通过将此数值数据拟合到形式为 $f(x_j; A, \\varphi) = A \\sin(k x_j - \\varphi)$（其中 $k=10\\pi$）的模型来量化相位误差。我们必须找到参数 $A$ 和 $\\varphi$ 以最小化残差平方和：\n$$ \\min_{\\varphi \\in (-\\pi,\\pi],\\, A \\in \\mathbb{R}} \\sum_{j=0}^{N-1} \\left[u_j^{\\text{num}} - A \\sin(k x_j - \\varphi)\\right]^2 $$\n这个关于 $\\varphi$ 的非线性最小二乘问题可以被线性化。使用三角恒等式 $\\sin(\\alpha - \\beta) = \\sin\\alpha \\cos\\beta - \\cos\\alpha \\sin\\beta$，模型函数可以重写为：\n$$ A \\sin(k x_j - \\varphi) = (A \\cos\\varphi) \\sin(k x_j) - (A \\sin\\varphi) \\cos(k x_j) $$\n我们定义新的线性系数 $c_1 = A \\cos\\varphi$ 和 $c_2 = -A \\sin\\varphi$。模型在这些系数上变为线性的：$f(x_j) = c_1 \\sin(k x_j) + c_2 \\cos(k x_j)$。现在的任务是一个标准的线性最小二乘问题：\n$$ \\min_{c_1, c_2} \\sum_{j=0}^{N-1} \\left[u_j^{\\text{num}} - \\left(c_1 \\sin(k x_j) + c_2 \\cos(k x_j)\\right)\\right]^2 $$\n令基向量为 $S_j = \\sin(k x_j)$ 和 $C_j = \\cos(k x_j)$。系数 $(c_1, c_2)$ 的解由正规方程组给出：\n$$ \\begin{pmatrix} \\sum S_j^2 & \\sum S_j C_j \\\\ \\sum S_j C_j & \\sum C_j^2 \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = \\begin{pmatrix} \\sum u_j^{\\text{num}} S_j \\\\ \\sum u_j^{\\text{num}} C_j \\end{pmatrix} $$\n求解这个 $2 \\times 2$ 系统得到 $c_1$ 和 $c_2$。然后从 $c_1$ and $c_2$ 的定义中恢复相位 $\\varphi$：\n$$ \\tan\\varphi = \\frac{\\sin\\varphi}{\\cos\\varphi} = \\frac{-c_2/A}{c_1/A} = \\frac{-c_2}{c_1} $$\n相位误差 $\\varphi^\\star$ 可以通过双参数反正切函数在区间 $(-\\pi, \\pi]$ 内唯一确定：\n$$ \\varphi^\\star = \\operatorname{atan2}(-c_2, c_1) $$\n这个值 $\\varphi^\\star$ 代表了在 $t=T$ 时数值解相对于精确解的相位滞后或超前，并且是需要报告的量。正值表示相位滞后（数值波较慢）。对于 $C=1$ 的特殊情况，Lax-Wendroff 格式在网格上是精确的，得到 $u_j^{n+1} = u_{j-1}^n$，经过 $n_{\\text{steps}} = N$ 步后，结果为 $u_j^{\\text{final}} = u_{j-N}^0 = u_j^0$。在这种情况下，相位误差必须精确为零。\n对于每一给定的参数对 $(N, C)$，整个过程都通过计算来实现。", "answer": "```python\nimport numpy as np\n\ndef run_lax_wendroff(N, C):\n    \"\"\"\n    Solves the linear advection equation u_t + u_x = 0 on a periodic\n    domain [0,1] using the Lax-Wendroff scheme.\n\n    Args:\n        N (int): Number of grid points.\n        C (float): Courant number.\n\n    Returns:\n        numpy.ndarray: The numerical solution at the final time T=1.\n    \"\"\"\n    # Parameters definition\n    T_final = 1.0\n    wave_number = 10.0 * np.pi\n    \n    # Spatial grid setup\n    dx = 1.0 / N\n    x_grid = np.arange(N) * dx\n    \n    # Initial condition\n    u0 = np.sin(wave_number * x_grid)\n    \n    # Time stepping setup\n    # The problem statement guarantees N/C is an integer.\n    num_steps = int(round(N / C))\n    \n    # Pre-calculate Lax-Wendroff coefficients\n    # u_j^{n+1} = coeff_jm1 * u_{j-1} + coeff_j * u_j + coeff_jp1 * u_{j+1}\n    courant_sq = C * C\n    coeff_jm1 = 0.5 * (courant_sq + C)  # Coefficient for u_{j-1}\n    coeff_j = 1.0 - courant_sq           # Coefficient for u_j\n    coeff_jp1 = 0.5 * (courant_sq - C)  # Coefficient for u_{j+1}\n    \n    u = u0.copy()\n    \n    # Time-marching loop\n    for _ in range(num_steps):\n        # Periodic boundary conditions are handled by np.roll\n        u_jm1 = np.roll(u, 1)\n        u_jp1 = np.roll(u, -1)\n        \n        u = coeff_jm1 * u_jm1 + coeff_j * u + coeff_jp1 * u_jp1\n        \n    return u\n\ndef calculate_phase_error(u_final, N):\n    \"\"\"\n    Calculates the phase error by fitting the numerical solution to the model\n    A * sin(k*x - phi) using linear least-squares.\n\n    Args:\n        u_final (numpy.ndarray): The numerical solution at the final time.\n        N (int): Number of grid points.\n\n    Returns:\n        float: The calculated phase error phi in radians.\n    \"\"\"\n    # Define basis functions for the least-squares fit\n    wave_number = 10.0 * np.pi\n    dx = 1.0 / N\n    x_grid = np.arange(N) * dx\n    \n    # Model: c1*sin(k*x) + c2*cos(k*x)\n    S_basis = np.sin(wave_number * x_grid)\n    C_basis = np.cos(wave_number * x_grid)\n\n    # Set up and solve the normal equations: (M^T * M) * c = M^T * u\n    # where M = [S_basis, C_basis], c = [c1, c2]^T, u = u_final\n    \n    # M^T * M matrix components\n    S2 = np.dot(S_basis, S_basis)\n    C2 = np.dot(C_basis, C_basis)\n    SC = np.dot(S_basis, C_basis)\n    \n    M_T_M = np.array([[S2, SC], \n                      [SC, C2]])\n                      \n    # M^T * u vector components\n    uS = np.dot(u_final, S_basis)\n    uC = np.dot(u_final, C_basis)\n    \n    M_T_u = np.array([uS, uC])\n    \n    # Solve for coefficients c1, c2\n    # c1 = A*cos(phi), c2 = -A*sin(phi)\n    try:\n        c1, c2 = np.linalg.solve(M_T_M, M_T_u)\n    except np.linalg.LinAlgError:\n        # This is unlikely to happen with sine and cosine bases\n        return np.nan\n\n    # Recover the phase phi from the coefficients\n    # phi = atan2(-c2, c1)\n    phase_error = np.arctan2(-c2, c1)\n    \n    return phase_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200, 0.5),\n        (100, 1.0),\n        (20, 0.8),\n        (90, 0.9),\n    ]\n\n    results = []\n    for N, C in test_cases:\n        # Run the numerical simulation\n        u_final = run_lax_wendroff(N, C)\n        \n        # Calculate the phase error from the final state\n        phase_err = calculate_phase_error(u_final, N)\n        \n        results.append(phase_err)\n\n    # Format and print the final results as specified.\n    formatted_results = \",\".join([f\"{r:.8f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2407698"}, {"introduction": "虽然 Lax-Wendroff 格式对于光滑解是二阶精度的，但它并非没有缺点。本练习将引导您探索高阶线性格式的一个重要局限性：在处理间断或尖锐梯度时会产生非物理的振荡。根据 Godunov 定理，任何高于一阶的线性格式都无法保证解的正定性，这个练习将通过模拟一个必须保持非负的物理量（如粒子数密度）的平流过程，来直观地展示这一现象。通过这个实践，您将深刻理解在处理包含激波或接触间断的物理问题时，为什么需要更先进的非线性格式。[@problem_id:2407736]", "problem": "考虑一个非负标量数密度 $n(x,t)$ 在长度为 $L$ 的周期性区域上的一维线性平流，其速度为恒定值 $a&gt;0$，该过程由以下守恒律控制：\n$$\n\\partial_t n(x,t) + a\\,\\partial_x n(x,t) = 0,\\quad x\\in[0,L],\\ t\\ge 0,\n$$\n附带周期性边界条件和均匀空间离散。其精确解保持非负性：如果对所有 $x$ 有 $n(x,0)\\ge 0$，则对所有 $t\\ge 0$ 都有 $n(x,t)\\ge 0$。您需要在一个均匀网格上，使用在时间和空间上均为二阶精度的显式方法，在周期性网格上计算一个全离散数值解。网格包含 $N$ 个网格点，间距为 $\\Delta x = L/N$，节点为 $x_j = j\\,\\Delta x$，$j=0,1,\\dots,N-1$。使用由 Courant–Friedrichs–Lewy (CFL) 数 $c = a\\,\\Delta t/\\Delta x$ 定义的均匀时间步长 $\\Delta t$（其中 $c\\in(0,1]$），并将解推进至不超过目标时间 $T$ 的最大完整时间步数 $K=\\lfloor T/\\Delta t\\rfloor$。\n\n对于每个指定的测试用例，您的程序必须从给定的非负初始数据开始演化离散解，并检测数值解在演化到时间 $T$ 的过程中，是否在任何网格点上出现小于某个小的负阈值的值。为避免因浮点舍入误差导致的假阳性，当且仅当在某个时间步 $m\\in\\{0,1,\\dots,K\\}$ 中出现 $\\min_j n_j^m &lt; -\\varepsilon$ 时，才断定出现了非物理的负值。这里的容差为 $\\varepsilon = 10^{-12}$，$n_j^m$ 表示在网格节点 $x_j$ 和时间层 $t^m=m\\,\\Delta t$ 的离散解。\n\n使用无量纲单位（不需要物理单位）。不涉及角度。以下所有参数值均为无量纲。在每个测试中，区域在 $[0,L]$ 上都是周期性的。\n\n测试套件（每个项目列出 $(L,a,N,c,T,\\text{初始剖面})$）：\n- 用例 A（光滑剖面，“理想路径”）：$(L,a,N,c,T) = (1.0,\\,1.0,\\,400,\\,0.5,\\,1.0)$。初始条件：对于 $x\\in[0,L)$，$n(x,0) = \\exp\\!\\left(-\\left(\\dfrac{x-0.3}{0.05}\\right)^2\\right)$。\n- 用例 B（单个间断点对，接近 Courant 边界）：$(L,a,N,c,T) = (1.0,\\,1.0,\\,400,\\,0.9,\\,0.2)$。初始条件：当 $x\\in[0.25,0.55]$ 时，$n(x,0) = 1$，否则在 $[0,L)$ 上 $n(x,0)=0$。\n- 用例 C（多个间断点，较粗的网格）：$(L,a,N,c,T) = (1.0,\\,1.0,\\,200,\\,0.5,\\,0.2)$。初始条件：在并集 $[0.10,0.20]\\cup[0.60,0.80]$ 上 $n(x,0) = 1$，否则在 $[0,L)$ 上 $n(x,0)=0$。\n\n对于每个用例，您的程序必须计算一个布尔指示符，指明在从 $t=0$ 到 $t=K\\,\\Delta t$ 的时间步进过程中，是否在任何网格点上观测到任何非物理负值（由阈值 $\\varepsilon$ 定义）。最终输出必须是单行文本，其中按顺序包含用例 A、B、C 的三个结果，格式为方括号内由逗号分隔的整数列表，如果相应用例检测到非物理负值，则条目为 $1$，否则为 $0$。例如，要求的输出格式为 $[x_1,x_2,x_3]$，其中 $x_i\\in\\{0,1\\}$。", "solution": "所提出的问题是计算物理学中一个适定的练习。它要求实现一类特定的数值方法来求解一维线性平流方程，并测试数值解的一个基本性质：非负性保持。\n\n控制方程是标量密度 $n(x,t)$ 的线性平流方程，其波速 $a$ 为正常数：\n$$\n\\partial_t n + a\\,\\partial_x n = 0\n$$\n该问题要求一种在时间和空间上均为二阶精度的显式数值格式。对于此方程，满足这些性质的典型方法是 Lax-Wendroff 格式。我们将推导此格式并用它来解决问题。\n\n我们从解 $n(x, t+\\Delta t)$ 在时间上围绕 $t$ 的泰勒级数展开开始：\n$$\nn(x, t+\\Delta t) = n(x,t) + \\Delta t \\frac{\\partial n}{\\partial t} + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 n}{\\partial t^2} + O((\\Delta t)^3)\n$$\n为了在时间上达到二阶精度，我们必须使用控制偏微分方程来近似时间导数。一阶时间导数由偏微分方程直接给出：\n$$\n\\frac{\\partial n}{\\partial t} = -a \\frac{\\partial n}{\\partial x}\n$$\n二阶时间导数可以通过对偏微分方程关于时间求导并回代得到：\n$$\n\\frac{\\partial^2 n}{\\partial t^2} = \\frac{\\partial}{\\partial t}\\left(-a \\frac{\\partial n}{\\partial x}\\right) = -a \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial n}{\\partial t}\\right) = -a \\frac{\\partial}{\\partial x}\\left(-a \\frac{\\partial n}{\\partial x}\\right) = a^2 \\frac{\\partial^2 n}{\\partial x^2}\n$$\n将这些表达式回代到泰勒展开中，得到一个半离散方程，其在 $\\Delta t$ 上具有二阶精度：\n$$\nn(x, t+\\Delta t) = n(x,t) - a \\Delta t \\frac{\\partial n}{\\partial x} + \\frac{(a \\Delta t)^2}{2} \\frac{\\partial^2 n}{\\partial x^2} + O((\\Delta t)^3)\n$$\n为创建一个全离散格式，我们用网格点 $x_j = j\\Delta x$ 对空间域进行离散，并用 $n_j^m \\approx n(x_j, t^m)$ 来近似这些点在时间 $t^m=m\\Delta t$ 的解。我们用二阶精度的中心有限差分替换空间导数：\n$$\n\\left.\\frac{\\partial n}{\\partial x}\\right|_{x_j} \\approx \\frac{n_{j+1}^m - n_{j-1}^m}{2\\Delta x}\n$$\n$$\n\\left.\\frac{\\partial^2 n}{\\partial x^2}\\right|_{x_j} \\approx \\frac{n_{j+1}^m - 2n_j^m + n_{j-1}^m}{(\\Delta x)^2}\n$$\n将这些有限差分代入半离散方程，得到 $n_j^{m+1}$ 的显式更新规则：\n$$\nn_j^{m+1} = n_j^m - a \\Delta t \\left( \\frac{n_{j+1}^m - n_{j-1}^m}{2\\Delta x} \\right) + \\frac{(a \\Delta t)^2}{2} \\left( \\frac{n_{j+1}^m - 2n_j^m + n_{j-1}^m}{(\\Delta x)^2} \\right)\n$$\n引入无量纲的 Courant–Friedrichs–Lewy (CFL) 数 $c = a\\Delta t/\\Delta x$，我们可以简化该表达式：\n$$\nn_j^{m+1} = n_j^m - \\frac{c}{2} (n_{j+1}^m - n_{j-1}^m) + \\frac{c^2}{2} (n_{j+1}^m - 2n_j^m + n_{j-1}^m)\n$$\n按当前时间层 $m$ 的空间索引用对各项进行分组：\n$$\nn_j^{m+1} = \\left( \\frac{c^2}{2} + \\frac{c}{2} \\right) n_{j-1}^m + (1 - c^2) n_j^m + \\left( \\frac{c^2}{2} - \\frac{c}{2} \\right) n_{j+1}^m\n$$\n这就是 Lax-Wendroff 格式。为使该格式是保正的（即，如果所有 $n_k^m \\ge 0$ 都成立，则能保证 $n_j^{m+1} \\ge 0$），模板中的所有系数都必须是非负的。我们分析在稳定范围 $c \\in (0,1]$ 内的系数：\n- $n_{j-1}^m$ 的系数：$\\frac{c(c+1)}{2}$。当 $c \\ge 0$ 时，该值为非负。\n- $n_j^m$ 的系数：$1 - c^2$。当 $c \\le 1$ 时，该值为非负。\n- $n_{j+1}^m$ 的系数：$\\frac{c(c-1)}{2}$。当 $c \\in [0,1]$ 时，该值为非正。\n\n对于任何 $c \\in (0,1)$，$n_{j+1}^m$ 的系数都是负的。这意味着 Lax-Wendroff 格式通常不具有保正性。它是一种非单调格式，会在解的陡峭梯度或间断点周围引入虚假振荡（下冲和过冲）。这是 Godunov 定理的一种体现，该定理指出，对于守恒律，任何精度阶高于一阶的线性数值格式都不能是保单调的。因此，我们预计当初始条件包含间断时（如用例 B 和 C），会观测到负值。对于像用例 A 中的高斯函数那样的光滑初始条件，任何振荡都应该小得多，并且可能不会低于指定的负阈值 $\\varepsilon = 10^{-12}$。\n\n解决该问题的算法如下：\n1. 对于每个测试用例，定义参数 $L, a, N, c, T$。\n2. 计算网格间距 $\\Delta x = L/N$、时间步长 $\\Delta t = c \\Delta x / a$ 和总时间步数 $K = \\lfloor T/\\Delta t \\rfloor$。\n3. 创建一个均匀空间网格 $x_j = j\\Delta x$，$j=0, \\dots, N-1$。\n4. 根据用例指定的初始条件初始化离散解数组 $n^0$。\n5. 设置一个标志 `negative_detected = 0`。\n6. 从时间步 $m=0$ 迭代到 $K-1$：\n   a. 使用 Lax-Wendroff 公式计算下一个时间步的解 $n^{m+1}$。通过循环处理网格索引来实施周期性边界条件（例如，$n_{-1}^m \\equiv n_{N-1}^m$ 和 $n_N^m \\equiv n_0^m$）。\n   b. 计算出新数组 $n^{m+1}$ 后，找到其最小值 $\\min_j n_j^{m+1}$。\n   c. 如果此最小值小于 $-\\varepsilon = -10^{-12}$，则设置 `negative_detected = 1` 并终止该用例的时间步进。\n   d. 更新解数组以进行下一次迭代。\n7. 记录该用例的 `negative_detected` 的最终值。\n8. 处理完所有用例后，将结果报告为这些标志的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using the Lax-Wendroff scheme\n    and detects the occurrence of unphysical negative values.\n    \"\"\"\n\n    # Define the tolerance for detecting negative values.\n    epsilon = 1.0e-12\n\n    def run_simulation(L, a, N, c, T, initial_profile_func):\n        \"\"\"\n        Runs a single simulation case.\n\n        Returns:\n            int: 1 if a negative value below the threshold is detected, 0 otherwise.\n        \"\"\"\n        # Grid and time step parameters\n        dx = L / N\n        dt = c * dx / a\n        num_steps = int(T // dt)\n\n        # Spatial grid (uniform and periodic)\n        # x corresponds to nodes x_j = j*dx for j=0, ..., N-1\n        x = np.linspace(0, L, N, endpoint=False)\n\n        # Initialize the solution array n from the initial condition\n        n = initial_profile_func(x)\n\n        # Lax-Wendroff coefficients\n        # n_j^{m+1} = c_j-1 * n_{j-1}^m + c_j * n_j^m + c_j+1 * n_{j+1}^m\n        # Note: np.roll(n, 1) corresponds to n_{j-1}\n        #       np.roll(n, -1) corresponds to n_{j+1}\n        c_j_minus_1 = c * (c + 1.0) / 2.0\n        c_j = 1.0 - c**2\n        c_j_plus_1 = c * (c - 1.0) / 2.0\n        \n        # Check initial state (t=0)\n        if np.min(n) < -epsilon:\n            return 1\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # Apply the Lax-Wendroff update rule\n            # np.roll handles periodic boundary conditions efficiently\n            n_new = (c_j_minus_1 * np.roll(n, 1) +\n                     c_j * n +\n                     c_j_plus_1 * np.roll(n, -1))\n            \n            n = n_new\n            \n            # Check for unphysical negative values\n            if np.min(n) < -epsilon:\n                return 1\n\n        return 0\n\n    # Define test cases based on the problem statement\n    test_cases = [\n        # Case A: Smooth Gaussian profile\n        {\n            \"L\": 1.0, \"a\": 1.0, \"N\": 400, \"c\": 0.5, \"T\": 1.0,\n            \"initial_profile_func\": lambda x: np.exp(-((x - 0.3) / 0.05)**2)\n        },\n        # Case B: Single discontinuity pair (square pulse)\n        {\n            \"L\": 1.0, \"a\": 1.0, \"N\": 400, \"c\": 0.9, \"T\": 0.2,\n            \"initial_profile_func\": lambda x: np.where((x >= 0.25) & (x < 0.55), 1.0, 0.0)\n        },\n        # Case C: Multiple discontinuities, coarser grid\n        {\n            \"L\": 1.0, \"a\": 1.0, \"N\": 200, \"c\": 0.5, \"T\": 0.2,\n            \"initial_profile_func\": lambda x: np.where(\n                ((x >= 0.10) & (x < 0.20)) | ((x >= 0.60) & (x < 0.80)), 1.0, 0.0\n            )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            case[\"L\"], case[\"a\"], case[\"N\"], case[\"c\"], case[\"T\"], case[\"initial_profile_func\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2407736"}, {"introduction": "任何显式时间推进格式的成功应用都离不开对其稳定性的理解，而 Courant-Friedrichs-Lewy (CFL) 条件是其中的核心。本练习将带您深入探讨 Lax-Wendroff 格式的稳定性理论基础。您将通过 von Neumann 分析方法，从理论上推导格式的放大因子，并将其与直接的数值实验结果进行对比。这项实践旨在建立理论分析与数值现象之间的桥梁，让您亲眼见证当稳定性条件被违反时，数值误差是如何灾难性地增长的。[@problem_id:2407699]", "problem": "考虑一维线性平流方程 $u_t + a\\,u_x = 0$，其中平流速度 $a \\in \\mathbb{R}$ 是一个常数，定义在周期性域 $x \\in [0,1)$ 上。用包含 $N$ 个点的均匀网格对空间进行离散化，其中 $N = 256$，网格索引为 $j \\in \\{0,1,\\dots,N-1\\}$，网格间距为 $\\Delta x = 1/N$。时间以步长 $\\Delta t$ 离散，并定义库朗数 $C = a\\,\\Delta t/\\Delta x$。所有量均为无量纲。\n\n使用二阶 Lax–Wendroff 格式\n$$\nu_j^{n+1}\n=\nu_j^n\n-\n\\frac{C}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right)\n+\n\\frac{C^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right),\n$$\n其中索引为周期性，$u_{j\\pm N}^n \\equiv u_j^n$。\n\n设初始条件为一个光滑的 Fourier 模式和一个植入的最高波数模式的组合，\n$$\nu_j^0 = \\sin\\!\\left(2\\pi m \\frac{j}{N}\\right) + \\varepsilon\\,(-1)^j,\n$$\n其中 $m = 4$ 且 $\\varepsilon = 10^{-6}$。\n\n对于下方的每一组参数，通过 $C = a\\,\\Delta t/\\Delta x$ 选择 $\\Delta t$ 以使库朗数等于指定的 $C$。对每一组参数，计算并报告以下四个量：\n- 一个布尔值，表示 von Neumann 意义下的不稳定性，如果 $|C| > 1$ 则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 理论上所有 Fourier 模式中最大的单步放大因子，即 $\\max_{\\theta \\in [0,2\\pi)} |G(\\theta)|$，其中 $G(\\theta)$ 是波数角 $\\theta$ 对应的 Lax–Wendroff 放大因子。\n- 波数索引为 $m$ 的特定光滑模式的理论单步放大因子，即 $|G(\\theta_m)|$，其中 $\\theta_m = 2\\pi m/N$。\n- 经过恰好一个时间步长后，对同一光滑模式数值测量得到的单步放大因子，该值通过比较应用一次该格式前后该模式的幅值得到。\n\n测试集 (每个案例为 $(a,C)$):\n- 案例 1: $(a,C) = (1,\\,0.5)$.\n- 案例 2: $(a,C) = (1,\\,1.0)$.\n- 案例 3: $(a,C) = (1,\\,1.1)$.\n- 案例 4: $(a,C) = (1,\\,1.5)$.\n- 案例 5: $(a,C) = (-1,\\,-1.1)$.\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个案例的条目本身是一个形式为 $[b,g_{\\max},g_m^{\\mathrm{theory}},g_m^{\\mathrm{meas}}]$ 的列表，顺序与上文所述相同。元素 $b$ 必须是 $\\mathrm{True}$ 或 $\\mathrm{False}$；三个实数必须四舍五入到小数点后恰好六位数字。输出行中任何位置都不允许有空格。例如，包含两个案例的一行输出应如下所示：$[[\\mathrm{False},1.000000,0.999000,0.999001],[\\mathrm{True},1.420000,1.000010,1.000012]]$。", "solution": "所述问题是偏微分方程数值分析领域中一个适定的、有科学依据的练习。它涉及将 Lax–Wendroff 格式应用于一维线性平流方程。所有给定的参数和条件都是一致的，并且足以得到唯一解。因此，我将进行完整的推导和计算求解。\n\n该问题要求分析用于线性平流方程 $u_t + a\\,u_x = 0$ 的二阶 Lax–Wendroff 格式。该格式由下式给出\n$$\nu_j^{n+1} = u_j^n - \\frac{C}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{C^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right)\n$$\n其中 $u_j^n$ 是网格点 $j$ 和时间步 $n$ 处的数值解，$C = a\\,\\Delta t/\\Delta x$ 是库朗数。\n\n为了确定该格式的理论性质，我们进行 von Neumann 稳定性分析。我们考虑单个 Fourier 模式的演化，$u_j^n = \\hat{u}^n(k) e^{i k x_j}$，其中 $x_j = j\\Delta x$，$k$ 是波数。我们定义无量纲波数角 $\\theta = k \\Delta x$。解的拟设变为 $u_j^n = \\hat{u}^n(\\theta) e^{ij\\theta}$。放大因子 $G(\\theta)$ 由关系式 $\\hat{u}^{n+1}(\\theta) = G(\\theta) \\hat{u}^n(\\theta)$ 定义。将该拟设代入格式可得：\n$$\nG(\\theta)e^{ij\\theta} = e^{ij\\theta} - \\frac{C}{2}\\left(e^{i(j+1)\\theta} - e^{i(j-1)\\theta}\\right) + \\frac{C^2}{2}\\left(e^{i(j+1)\\theta} - 2e^{ij\\theta} + e^{i(j-1)\\theta}\\right)\n$$\n两边同除以 $e^{ij\\theta}$，我们得到放大因子：\n$$\nG(\\theta) = 1 - \\frac{C}{2}\\left(e^{i\\theta} - e^{-i\\theta}\\right) + \\frac{C^2}{2}\\left(e^{i\\theta} - 2 + e^{-i\\theta}\\right)\n$$\n使用恒等式 $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$ 和 $e^{i\\theta} + e^{-i\\theta} = 2\\cos\\theta$，上式可化简为：\n$$\nG(\\theta) = 1 - iC\\sin\\theta + C^2(\\cos\\theta - 1)\n$$\n放大因子的幅值 $|G(\\theta)|$ 决定了格式的稳定性。对于所有 $\\theta$，要求 $|G(\\theta)| \\le 1$ 才是稳定的。其幅值的平方为：\n$$\n|G(\\theta)|^2 = \\text{Re}(G(\\theta))^2 + \\text{Im}(G(\\theta))^2 = (1 + C^2(\\cos\\theta - 1))^2 + (-C\\sin\\theta)^2\n$$\n$$\n|G(\\theta)|^2 = 1 + 2C^2(\\cos\\theta - 1) + C^4(\\cos\\theta - 1)^2 + C^2\\sin^2\\theta\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C^2(1 - \\cos\\theta) + C^4(1 - 2\\cos\\theta + \\cos^2\\theta) + C^2(1 - \\cos^2\\theta)\n$$\n$$\n|G(\\theta)|^2 = 1 - C^2 + (2C^2 - 2C^4)\\cos\\theta + (C^4 - C^2)\\cos^2\\theta\n$$\n一个更简洁的推导使用了半角恒等式 $1 - \\cos\\theta = 2\\sin^2(\\theta/2)$:\n$$\nG(\\theta) = 1 - 2C^2\\sin^2(\\theta/2) - iC(2\\sin(\\theta/2)\\cos(\\theta/2))\n$$\n$$\n|G(\\theta)|^2 = (1 - 2C^2\\sin^2(\\theta/2))^2 + 4C^2\\sin^2(\\theta/2)\\cos^2(\\theta/2)\n$$\n$$\n|G(\\theta)|^2 = 1 - 4C^2\\sin^2(\\theta/2) + 4C^4\\sin^4(\\theta/2) + 4C^2\\sin^2(\\theta/2)(1-\\sin^2(\\theta/2))\n$$\n$$\n|G(\\theta)|^2 = 1 - 4C^2\\sin^2(\\theta/2) + 4C^4\\sin^4(\\theta/2) + 4C^2\\sin^2(\\theta/2) - 4C^2\\sin^4(\\theta/2)\n$$\n这可化简为一个非常紧凑的形式：\n$$\n|G(\\theta)|^2 = 1 - 4C^2(1-C^2)\\sin^4(\\theta/2)\n$$\n现在我们计算所需的四个量。\n\n1.  **不稳定条件**：如果对所有 $\\theta \\in [0, 2\\pi)$ 都有 $|G(\\theta)|^2 \\le 1$，则该格式是稳定的。项 $\\sin^4(\\theta/2)$ 是非负的。如果 $C^2 \\le 1$，那么 $(1-C^2) \\ge 0$，这使得第二项 $-4C^2(1-C^2)\\sin^4(\\theta/2) \\le 0$。因此，$|G(\\theta)|^2 \\le 1$，格式是稳定的。如果 $C^2 > 1$，那么 $(1-C^2) < 0$，使得第二项为正。在这种情况下，$|G(\\theta)|^2$ 可能超过 $1$。因此，不稳定的条件是 $|C| > 1$。\n\n2.  **理论最大放大因子, $\\max_{\\theta} |G(\\theta)|$**：\n    -   如果 $|C| \\le 1$：由于 $|G(\\theta)|^2$ 表达式中的第二项是非正的，其最大值为 $1$（在 $\\theta=0$ 处取得）。\n    -   如果 $|C| > 1$：第二项是正的，因此当 $\\sin^4(\\theta/2)$ 取最大值时，$|G(\\theta)|^2$ 也取最大值。$\\sin^4(\\theta/2)$ 的最大值是 $1$（在 $\\theta=\\pi$ 处取得）。\n        $$\n        \\max |G(\\theta)|^2 = |G(\\pi)|^2 = 1 - 4C^2(1-C^2) = 1 - 4C^2 + 4C^4 = (2C^2 - 1)^2\n        $$\n        因此，$\\max_{\\theta} |G(\\theta)| = \\sqrt{(2C^2-1)^2} = |2C^2-1|$。由于 $C^2 > 1$，所以 $2C^2-1 > 1$，因此最大因子是 $2C^2-1$。\n\n3.  **模式 $m$ 的理论放大因子**：\n    问题指定了一个包含 $N=256$ 个点的网格，以及一个波数索引为 $m=4$ 的光滑模式。对应的波数角为 $\\theta_m = 2\\pi m/N = 2\\pi(4)/256 = \\pi/32$。此模式的理论放大因子是 $|G(\\theta_m)|$，可由推导出的公式直接计算：\n    $$\n    |G(\\theta_m)| = \\sqrt{1 - 4C^2(1-C^2)\\sin^4(\\theta_m/2)} = \\sqrt{1 - 4C^2(1-C^2)\\sin^4(\\pi/64)}\n    $$\n\n4.  **模式 $m$ 的数值测量放大因子**：\n    这需要进行一个单步数值实验。\n    -   首先，根据 $u_j^0 = \\sin(2\\pi m j/N) + \\varepsilon (-1)^j$ 构建大小为 $N=256$ 的初始条件向量 $u^0$，其中 $m=4$ 且 $\\varepsilon=10^{-6}$。\n    -   我们计算初始状态的离散 Fourier 变换 (DFT)，$\\hat{u}^0 = \\text{FFT}(u^0)$。模式 $m$ 的初始复振幅为 $\\hat{u}^0_m$。其幅值为 $|\\hat{u}^0_m|$。\n    -   接下来，我们将 Lax–Wendroff 格式单步应用于 $u^0$，以获得下一时间步的状态 $u^1$。此计算必须遵守周期性边界条件，这可以通过数组的循环移位（例如，`numpy.roll`）来高效实现。\n    -   然后，我们计算新状态的 DFT，$\\hat{u}^1 = \\text{FFT}(u^1)$，并找出模式 $m$ 的复振幅的幅值 $|\\hat{u}^1_m|$。\n    -   数值测量的放大因子是这些幅值的比值：$g_m^{\\mathrm{meas}} = |\\hat{u}^1_m| / |\\hat{u}^0_m|$。该值预计将与理论值 $|G(\\theta_m)|$ 极度接近，任何偏差都可归因于浮点精度限制。\n\n对于每个测试案例 $(a,C)$，计算这四个量并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing the Lax-Wendroff scheme for five test cases.\n\n    For each case, it calculates:\n    1. A boolean for von Neumann instability.\n    2. The theoretical maximum amplification factor over all modes.\n    3. The theoretical amplification factor for a specific mode m.\n    4. The numerically measured amplification factor for mode m after one time step.\n    \"\"\"\n    # Define constants from the problem statement\n    N = 256\n    m = 4\n    eps = 1e-6\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (a, C), where 'a' is advection speed and 'C' is Courant number.\n    test_cases = [\n        (1.0, 0.5),\n        (1.0, 1.0),\n        (1.0, 1.1),\n        (1.0, 1.5),\n        (-1.0, -1.1),\n    ]\n\n    results = []\n    \n    # Grid for initial condition\n    j = np.arange(N)\n    \n    # Wavenumber angle for the smooth mode m\n    theta_m = 2.0 * np.pi * m / N\n\n    for a, C in test_cases:\n        # 1. Instability (von Neumann sense)\n        # The scheme is unstable if and only if |C| > 1.\n        is_unstable = np.abs(C) > 1.0\n\n        # 2. Theoretical maximum per-step amplification factor\n        if np.abs(C) <= 1.0:\n            g_max = 1.0\n        else:\n            g_max = 2.0 * C**2 - 1.0\n\n        # 3. Theoretical per-step amplification factor for mode m\n        # |G|^2 = 1 - 4*C^2*(1-C^2)*sin^4(theta/2)\n        # We need to compute the square root of this for a complex result when C > 1\n        # The term under the square root can be negative if C^2 outside of [0,1]\n        # and sin^4 is not zero. Let's use complex arithmetic to be safe.\n        term_inside_sqrt = 1.0 - 4.0 * C**2 * (1.0 - C**2) * np.sin(theta_m / 2.0)**4\n        g_m_theory = np.sqrt(np.abs(term_inside_sqrt))\n        \n        # 4. Numerically measured per-step amplification factor for mode m\n        # Initial condition\n        u0 = np.sin(2.0 * np.pi * m * j / N) + eps * (-1)**j\n\n        # Compute initial amplitude of mode m via FFT\n        u0_fft = np.fft.fft(u0)\n        A0_m = np.abs(u0_fft[m])\n\n        # Apply one step of the Lax-Wendroff scheme\n        u_jp1 = np.roll(u0, -1)\n        u_jm1 = np.roll(u0, 1)\n        u1 = u0 - (C / 2.0) * (u_jp1 - u_jm1) + (C**2 / 2.0) * (u_jp1 - 2.0 * u0 + u_jm1)\n\n        # Compute final amplitude of mode m via FFT\n        u1_fft = np.fft.fft(u1)\n        A1_m = np.abs(u1_fft[m])\n\n        # Calculate the measured amplification factor\n        g_m_measured = A1_m / A0_m if A0_m != 0 else 0.0\n        \n        # Store results for this case\n        results.append([\n            is_unstable,\n            g_max,\n            g_m_theory,\n            g_m_measured\n        ])\n    \n    # Format the output string precisely as required, with no spaces and\n    # with floating-point numbers rounded to exactly six decimal places.\n    case_strings = []\n    for res in results:\n        b_val, gmax_val, gm_th_val, gm_ms_val = res\n        s_bool = str(b_val)\n        s_gmax = f\"{gmax_val:.6f}\"\n        s_gm_th = f\"{gm_th_val:.6f}\"\n        s_gm_ms = f\"{gm_ms_val:.6f}\"\n        case_strings.append(f\"[{s_bool},{s_gmax},{s_gm_th},{s_gm_ms}]\")\n        \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2407699"}]}