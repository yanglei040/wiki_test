{"hands_on_practices": [{"introduction": "我们从一个直观的物理问题开始：一块矩形板上的稳态热传导。这个练习旨在展示，在特定的边界条件下（例如本例中的绝热边界），一个看似复杂的偏微分方程问题有时会如何简化。通过推导此场景下的解析解，你将体会到物理直觉与数学分析相结合的力量，这在着手进行更复杂的数值模拟之前是宝贵的一步。[@problem_id:2406731]", "problem": "考虑一个均匀、各向同性的矩形板，占据区域 $\\{(x,y)\\,|\\,0 \\le x \\le L_x,\\;0 \\le y \\le L_y\\}$，且无内部热源。稳态温度场 $T(x,y)$ 在该开矩形上满足二维拉普拉斯方程\n$$\n\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0\n$$\n。边界条件如下：底边保持在均匀温度 $T(x,0) = T_{\\mathrm{hot}}$（单位：$\\mathrm{K}$），顶边保持在均匀温度 $T(x,L_y) = T_{\\mathrm{cold}}$（单位：$\\mathrm{K}$），左右两边是绝热的，即对所有 $y \\in [0,L_y]$ 都有 $\\frac{\\partial T}{\\partial x}(0,y) = 0$ 和 $\\frac{\\partial T}{\\partial x}(L_x,y) = 0$。所有长度单位均为 $\\mathrm{m}$，所有温度单位均为 $\\mathrm{K}$。不涉及角度。您的任务是，对每一个指定的参数集，计算几何中心 $(x,y) = (L_x/2,L_y/2)$ 处的稳态温度，并以 $\\mathrm{K}$ 为单位报告结果，四舍五入到小数点后3位。\n\n测试用例（每个案例指定了 $(L_x,\\;L_y,\\;T_{\\mathrm{hot}},\\;T_{\\mathrm{cold}})$，单位为 $(\\mathrm{m},\\;\\mathrm{m},\\;\\mathrm{K},\\;\\mathrm{K})$）：\n- 案例 A: $L_x = 1.0\\,\\mathrm{m}$，$L_y = 1.0\\,\\mathrm{m}$，$T_{\\mathrm{hot}} = 400.0\\,\\mathrm{K}$，$T_{\\mathrm{cold}} = 300.0\\,\\mathrm{K}$。\n- 案例 B: $L_x = 2.5\\,\\mathrm{m}$，$L_y = 0.8\\,\\mathrm{m}$，$T_{\\mathrm{hot}} = 310.0\\,\\mathrm{K}$，$T_{\\mathrm{cold}} = 330.0\\,\\mathrm{K}$。\n- 案例 C: $L_x = 0.7\\,\\mathrm{m}$，$L_y = 3.0\\,\\mathrm{m}$，$T_{\\mathrm{hot}} = 273.15\\,\\mathrm{K}$，$T_{\\mathrm{cold}} = 373.15\\,\\mathrm{K}$。\n- 案例 D: $L_x = 1.2\\,\\mathrm{m}$，$L_y = 2.0\\,\\mathrm{m}$，$T_{\\mathrm{hot}} = 300.0\\,\\mathrm{K}$，$T_{\\mathrm{cold}} = 300.0\\,\\mathrm{K}$。\n\n对每个案例，计算 $(L_x/2,L_y/2)$ 处的稳态温度 $T$（单位K），并四舍五入至小数点后3位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如：“[resultA,resultB,resultC,resultD]”），不含空格，其中每个条目都是以小数形式表示的、单位为K的四舍五入后的数值。", "solution": "问题陈述是连贯的、有科学依据的，并且在数学上是适定的。它描述了一个矩形域上的二维拉普拉斯方程的标准边值问题，该问题具有狄利克雷（Dirichlet）和诺伊曼（Neumann）边界条件的组合。根据偏微分方程理论，此类问题具有唯一且稳定的解。因此，我们将直接推导该解。\n\n该物理系统由稳态热方程描述，即温度场 $T(x,y)$ 的拉普拉斯方程：\n$$\n\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0\n$$\n区域是由 $0 \\le x \\le L_x$ 和 $0 \\le y \\le L_y$ 定义的矩形。边界条件为：\n1. $T(x,0) = T_{\\mathrm{hot}}$ (Dirichlet)\n2. $T(x,L_y) = T_{\\mathrm{cold}}$ (Dirichlet)\n3. $\\frac{\\partial T}{\\partial x}(0,y) = 0$ (Neumann)\n4. $\\frac{\\partial T}{\\partial x}(L_x,y) = 0$ (Neumann)\n\n我们采用分离变量法，假设解的形式为 $T(x,y) = X(x)Y(y)$。将此代入拉普拉斯方程并分离变量，得到：\n$$\n\\frac{X''(x)}{X(x)} = -\\frac{Y''(y)}{Y(y)} = -\\lambda\n$$\n其中 $\\lambda$ 是分离常数。这得到两个常微分方程：\n$$\nX''(x) + \\lambda X(x) = 0\n$$\n$$\nY''(y) - \\lambda Y(y) = 0\n$$\n我们首先利用齐次诺伊曼边界条件求解关于 $X(x)$ 的方程。条件 $\\frac{\\partial T}{\\partial x}(0,y) = X'(0)Y(y) = 0$ 和 $\\frac{\\partial T}{\\partial x}(L_x,y) = X'(L_x)Y(y) = 0$ 要求对于任何非平凡解 $Y(y)$，都必须有 $X'(0) = 0$ 和 $X'(L_x) = 0$。\n\n情况1：$\\lambda  0$。设 $\\lambda = k^2$ 且 $k  0$。解为 $X(x) = A\\cos(kx) + B\\sin(kx)$。其导数为 $X'(x) = -Ak\\sin(kx) + Bk\\cos(kx)$。\n应用 $X'(0)=0$ 得到 $B_k=0$，因此 $B=0$。解的形式为 $X(x) = A\\cos(kx)$。\n应用 $X'(L_x)=0$ 得到 $-Ak\\sin(kL_x) = 0$。对于非平凡解（$A \\neq 0$），必须有 $\\sin(kL_x) = 0$，这意味着 $kL_x = n\\pi$，其中 $n=1, 2, 3, \\ldots$。\n特征值为 $\\lambda_n = k_n^2 = \\left(\\frac{n\\pi}{L_x}\\right)^2$，其中 $n \\ge 1$。对应的特征函数为 $X_n(x) = A_n \\cos\\left(\\frac{n\\pi x}{L_x}\\right)$。\n\n情况2：$\\lambda = 0$。方程变为 $X''(x) = 0$，解为 $X(x) = C_1x + C_2$。其导数为 $X'(x) = C_1$。\n条件 $X'(0)=0$ 和 $X'(L_x)=0$ 均得出 $C_1=0$。因此，$X_0(x) = C_2$（一个常数）也是一个有效的特征函数，对应于特征值 $\\lambda_0 = 0$。\n\n情况3：$\\lambda  0$。设 $\\lambda = -k^2$ 且 $k  0$。方程 $X''(x) - k^2X(x) = 0$ 的解为 $X(x) = A\\cosh(kx) + B\\sinh(kx)$。应用边界条件导致 $A=B=0$，只得到平凡解。因此，不存在负特征值。\n\n现在我们求解 $Y(y)$。\n对于 $\\lambda_n = k_n^2 = \\left(\\frac{n\\pi}{L_x}\\right)^2$ 且 $n \\ge 1$，方程为 $Y_n''(y) - k_n^2 Y_n(y) = 0$。其解为 $Y_n(y) = C_n\\cosh(k_n y) + D_n\\sinh(k_n y)$。\n对于 $\\lambda_0 = 0$，方程为 $Y_0''(y) = 0$。其解为 $Y_0(y) = C_0 y + D_0$。\n\n通解是所有可能的乘积解的叠加：\n$$\nT(x,y) = X_0(x)Y_0(y) + \\sum_{n=1}^{\\infty} X_n(x)Y_n(y)\n$$\n合并常数后，上式变为：\n$$\nT(x,y) = C_0 y + D_0 + \\sum_{n=1}^{\\infty} \\cos\\left(\\frac{n\\pi x}{L_x}\\right) \\left[ E_n \\cosh\\left(\\frac{n\\pi y}{L_x}\\right) + F_n \\sinh\\left(\\frac{n\\pi y}{L_x}\\right) \\right]\n$$\n现在我们应用剩下的非齐次狄利克雷边界条件。\n在 $y=0$ 处：$T(x,0) = T_{\\mathrm{hot}}$。\n$$\nT_{\\mathrm{hot}} = D_0 + \\sum_{n=1}^{\\infty} E_n \\cos\\left(\\frac{n\\pi x}{L_x}\\right)\n$$\n这是常函数 $T_{\\mathrm{hot}}$ 的傅里叶余弦级数表示。通过观察，或通过计算傅里叶系数，可知常数项必须为 $D_0 = T_{\\mathrm{hot}}$，并且所有其他对于 $n \\ge 1$ 的系数必须为零，即对于所有 $n \\ge 1$ 都有 $E_n = 0$。\n\n解简化为：\n$$\nT(x,y) = C_0 y + T_{\\mathrm{hot}} + \\sum_{n=1}^{\\infty} F_n \\cos\\left(\\frac{n\\pi x}{L_x}\\right) \\sinh\\left(\\frac{n\\pi y}{L_x}\\right)\n$$\n在 $y=L_y$ 处：$T(x,L_y) = T_{\\mathrm{cold}}$。\n$$\nT_{\\mathrm{cold}} = C_0 L_y + T_{\\mathrm{hot}} + \\sum_{n=1}^{\\infty} F_n \\sinh\\left(\\frac{n\\pi L_y}{L_x}\\right) \\cos\\left(\\frac{n\\pi x}{L_x}\\right)\n$$\n这是常函数 $T_{\\mathrm{cold}}$ 的傅里叶余弦级数。再次通过比较系数：\n常数项必须匹配：$T_{\\mathrm{cold}} = C_0 L_y + T_{\\mathrm{hot}} \\implies C_0 = \\frac{T_{\\mathrm{cold}} - T_{\\mathrm{hot}}}{L_y}$。\n对于 $n \\ge 1$ 的余弦项的系数必须为零：$F_n \\sinh\\left(\\frac{n\\pi L_y}{L_x}\\right) = 0$。\n由于对于 $n \\ge 1$，有 $\\frac{n\\pi L_y}{L_x}  0$，因此 $\\sinh\\left(\\frac{n\\pi L_y}{L_x}\\right) \\neq 0$。所以，对于所有 $n \\ge 1$ 必须有 $F_n = 0$。\n\n级数中的所有项都为零。唯一解非常简单，只取决于 $y$ 坐标：\n$$\nT(x,y) = \\left(\\frac{T_{\\mathrm{cold}} - T_{\\mathrm{hot}}}{L_y}\\right) y + T_{\\mathrm{hot}}\n$$\n这个线性分布代表了一个均匀的垂直温度梯度，与两平行板之间的一维热流一致，这是由绝热的侧边界决定的。题目要求我们找到板的几何中心 $(x,y) = (L_x/2, L_y/2)$ 处的温度。温度与 $x$ 无关。代入 $y = L_y/2$ 得到：\n$$\nT(L_x/2, L_y/2) = \\left(\\frac{T_{\\mathrm{cold}} - T_{\\mathrm{hot}}}{L_y}\\right) \\frac{L_y}{2} + T_{\\mathrm{hot}} = \\frac{T_{\\mathrm{cold}} - T_{\\mathrm{hot}}}{2} + T_{\\mathrm{hot}} = \\frac{T_{\\mathrm{cold}} + T_{\\mathrm{hot}}}{2}\n$$\n垂直中点处的温度就是顶部和底部边界温度的算术平均值。这个结果与板的尺寸 $L_x$ 和 $L_y$ 无关。每个测试用例都通过应用此公式来求解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the steady-state temperature at the center of a rectangular plate\n    with specified boundary conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains (Lx, Ly, Thot, Tcold) in units of (m, m, K, K).\n    test_cases = [\n        (1.0, 1.0, 400.0, 300.0),\n        (2.5, 0.8, 310.0, 330.0),\n        (0.7, 3.0, 273.15, 373.15),\n        (1.2, 2.0, 300.0, 300.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current case.\n        # Lx and Ly are not needed for the final calculation but are kept for clarity.\n        Lx, Ly, Thot, Tcold = case\n\n        # The analytical solution for the temperature T(x,y) is:\n        # T(x,y) = ((Tcold - Thot) / Ly) * y + Thot\n        # This is because the side walls are insulated, making the heat flow\n        # purely one-dimensional in the y-direction.\n        # We need to find the temperature at the geometric center (Lx/2, Ly/2).\n        # T(Lx/2, Ly/2) = ((Tcold - Thot) / Ly) * (Ly/2) + Thot\n        # T_center = (Tcold - Thot) / 2 + Thot\n        # T_center = (Tcold + Thot) / 2\n        \n        temp_center = (Thot + Tcold) / 2.0\n        \n        # Format the result to 3 decimal places as required.\n        results.append(f\"{temp_center:.3f}\")\n\n    # Final print statement in the exact required format: [resultA,resultB,...]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2406731"}, {"introduction": "然而，大多数现实世界的问题并没有简单的解析解，这正是数值方法大显身手的地方。这个核心练习将指导你从零开始，使用有限差分法构建一个能够处理混合边界条件（即狄利克雷（Dirichlet）和诺伊曼（Neumann）条件）的二维拉普拉斯方程求解器。掌握这一过程是计算物理学中的一项基本功，它为你解决更广泛的物理和工程问题奠定了坚实的基础。[@problem_id:2406696]", "problem": "考虑二维拉普拉斯方程，它是用于稳态、无源场的典型椭圆偏微分方程 (PDE)。在一个矩形域中的控制方程为\n$$\n\\nabla^2 u(x,y) \\equiv \\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) = 0 \\quad \\text{for} \\quad (x,y)\\in \\Omega,\n$$\n其中 $\\Omega = [0,1]\\times[0,1]$。边界条件在边界 $\\partial\\Omega$ 上给定，可以是狄利克雷(Dirichlet)类型 $u = d(x,y)$ 或诺伊曼(Neumann)类型 $\\frac{\\partial u}{\\partial n} = g(x,y)$，其中 $\\frac{\\partial}{\\partial n}$ 表示外法向导数。目标是构建一个能够处理边界上不同（可能为分段的）区段上混合的狄利克雷和诺伊曼条件的计算求解器。\n\n你的任务是编写一个完整、可运行的程序，该程序能够：\n- 使用 $N\\times N$ 个节点的均匀笛卡尔网格对域 $\\Omega$ 进行离散化，其中 $N$ 由每个测试用例指定。\n- 基于泰勒展开，从第一性原理为 $\\nabla^2 u = 0$ 的内部离散化推导出一个二阶精度的有限差分方法，并对沿内法线方向的诺伊曼边界条件进行二阶精度的处理（不得在未推导的情况下假定任何公式；使用导数的定义和泰勒级数来构建二阶近似）。\n- 组装并求解所有网格节点上关于 $u$ 的最终线性系统。\n- 支持沿正方形每条边分段指定的边界条件。对于每条边，区段通过一个遍历该边的参数 $s\\in[0,1]$ 给出：对于左边和右边，$s=y$；对于底边和顶边，$s=x$。在每个网格边界节点，通过在指定的区段区间内定位 $s$ 来选择适当的边界条件类型和值。在四个角节点上，施加从测试用例指定的精确解中获取的狄利克雷值，以消除任何歧义。\n- 对于诺伊曼数据，必须使用外法向导数。单位外法向量在左边为 $(-\\hat{\\boldsymbol{i}})$，右边为 $(+\\hat{\\boldsymbol{i}})$，底边为 $(-\\hat{\\boldsymbol{j}})$，顶边为 $(+\\hat{\\boldsymbol{j}})$。\n\n使用以下测试套件。在每个案例中，都提供了一个精确的调和函数 $u^\\star(x,y)$。你必须构建与 $u^\\star(x,y)$ 一致的边界条件数据，以使精确解同时满足偏微分方程和边界条件。对于诺伊曼数据，使用上述外法线定义计算 $g(x,y)=\\frac{\\partial u^\\star}{\\partial n}(x,y)$。\n\n- 测试用例A（一般混合，光滑多项式）：\n  - 域： $\\Omega=[0,1]\\times[0,1]$。\n  - 网格： $N=51$ （因此网格间距为 $h=\\frac{1}{N-1}$）。\n  - 精确解： $u^\\star(x,y)=x^2 - y^2$。\n  - 边界分段：\n    - 左边 ($x=0$): 在 $s\\in[0,1]$ 上为狄利克雷条件， $u = u^\\star(0,y)$。\n    - 右边 ($x=1$): 在 $s\\in[0,1]$ 上为狄利克雷条件， $u = u^\\star(1,y)$。\n    - 底边 ($y=0$): 在 $s\\in[0,1]$ 上为诺伊曼条件， $\\frac{\\partial u}{\\partial n} = -\\frac{\\partial u^\\star}{\\partial y}(x,0)$。\n    - 顶边 ($y=1$): 在 $s\\in[0,1]$ 上为诺伊曼条件， $\\frac{\\partial u}{\\partial n} = +\\frac{\\partial u^\\star}{\\partial y}(x,1)$。\n    - 角点：设为 $u^\\star$ 的狄利克雷值。\n- 测试用例B（某条边上的分段混合）：\n  - 域： $\\Omega=[0,1]\\times[0,1]$。\n  - 网格： $N=51$。\n  - 精确解： $u^\\star(x,y)=x$。\n  - 边界分段：\n    - 左边 ($x=0$): 在 $s\\in[0,1]$ 上为狄利克雷条件， $u = u^\\star(0,y)$。\n    - 右边 ($x=1$): 在 $s\\in[0,1]$ 上为诺伊曼条件， $\\frac{\\partial u}{\\partial n} = +\\frac{\\partial u^\\star}{\\partial x}(1,y)$。\n    - 底边 ($y=0$): 在 $s\\in[0,1]$ 上为狄利克雷条件， $u = u^\\star(x,0)$。\n    - 顶边 ($y=1$): 沿 $s=x$ 分段：\n      - 在 $s\\in[0,0.4]$ 上为诺伊曼条件， $\\frac{\\partial u}{\\partial n} = +\\frac{\\partial u^\\star}{\\partial y}(x,1)$，\n      - 在 $s\\in(0.4,1]$ 上为狄利克雷条件， $u = u^\\star(x,1)$。\n    - 角点：设为 $u^\\star$ 的狄利克雷值。\n- 测试用例C（具有小网格和两条边上齐次诺伊曼条件的边界情况）：\n  - 域： $\\Omega=[0,1]\\times[0,1]$。\n  - 网格： $N=9$。\n  - 精确解： $u^\\star(x,y)=y$。\n  - 边界分段：\n    - 左边 ($x=0$): 在 $s\\in[0,1]$ 上为诺伊曼条件， $\\frac{\\partial u}{\\partial n} = -\\frac{\\partial u^\\star}{\\partial x}(0,y)$。\n    - 右边 ($x=1$): 在 $s\\in[0,1]$ 上为诺伊曼条件， $\\frac{\\partial u}{\\partial n} = +\\frac{\\partial u^\\star}{\\partial x}(1,y)$。\n    - 底边 ($y=0$): 在 $s\\in[0,1]$ 上为狄利克雷条件， $u = u^\\star(x,0)$。\n    - 顶边 ($y=1$): 在 $s\\in[0,1]$ 上为狄利克雷条件， $u = u^\\star(x,1)$。\n    - 角点：设为 $u^\\star$ 的狄利克雷值。\n\n要求的数值设计：\n- 内部离散化：使用关于网格节点的泰勒展开和作为对称差商极限的二阶导数定义，为内部节点上的 $\\nabla^2 u = 0$ 推导出一个二阶精度的五点有限差分近似。\n- 诺伊曼边界离散化：为边界节点处沿内法线方向的外法向导数推导一个二阶精度的单边有限差分近似。构建边界节点、沿内法线方向的前两个内部节点以及诺伊曼数据 $g$ 之间的线性关系，该关系在 $h$ 上是二阶一致的。\n- 狄利克雷边界离散化：在边界节点上精确地施加给定的 $u$ 值。\n\n对于每个测试用例，计算所有网格节点上的最大绝对误差\n$$\nE_\\infty = \\max_{0\\le i,j \\le N-1} \\left| u_{i,j}^{\\text{num}} - u^\\star(x_i,y_j) \\right|\n$$\n其中 $x_i = i\\,h$, $y_j = j\\,h$, 且 $h=\\frac{1}{N-1}$。\n\n最终输出格式：\n- 你的程序必须生成单行输出，其中包含一个列表，按顺序含有测试用例A、B和C的三个误差值，四舍五入到八位小数。格式必须严格如下：\n- 单行：\"[eA,eB,eC]\"，其中每个条目都是一个十进制数（例如，\"[0.00000000,0.00000000,0.00000000]\"）。\n\n此问题不涉及物理单位。不使用角度。不需要百分比。程序必须是完全自包含的，并且不得读取任何输入。它必须“按原样”运行并产生所需的单行输出。在所有选择和推导中确保科学真实性和内部一致性。你的算法必须从导数和泰勒展开的基本定义开始；在你的实现设计中，不得在未推导的情况下假定任何快捷公式。求解器必须足够通用，以处理上面给出的分段边界规范。", "solution": "用户请求在单位正方形上对二维拉普拉斯方程 $\\nabla^2 u = 0$ 进行计算求解，要求对内部节点和诺伊曼边界条件均使用二阶有限差分法。该问题定义明确，科学上合理，并提供了测试用例所需的所有参数。问题有效性检查通过。我们将着手构建求解器。\n\n控制偏微分方程(PDE)是在域 $\\Omega = [0,1]\\times[0,1]$ 上的拉普拉斯方程：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) = 0\n$$\n\n我们使用一个包含 $N \\times N$ 个节点的均匀笛卡尔网格来离散化域 $\\Omega$。网格点由 $(x_i, y_j) = (i h, j h)$ 表示，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = \\frac{1}{N-1}$。函数 $u$ 在网格点 $(x_i, y_j)$ 上的值记为 $u_{i,j}$。\n\n有限差分格式的推导\n\n该方法的核心是使用泰勒级数展开来近似偏导数。\n\n1. 内部节点离散化\n\n对于一个内部节点 $(i,j)$，其中 $0  i  N-1$ 且 $0  j  N-1$，我们近似其二阶偏导数。函数 $u$ 在点 $(x_i, y_j)$ 附近沿 $x$ 方向的泰勒级数展开为：\n$$\nu(x_i+h, y_j) = u_{i,j} + h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\frac{h^3}{6} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + O(h^4)\n$$\n$$\nu(x_i-h, y_j) = u_{i,j} - h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} - \\frac{h^3}{6} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + O(h^4)\n$$\n将这两个展开式相加可以消去奇数阶导数项：\n$$\nu_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h^2 \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + O(h^4)\n$$\n求解二阶导数，我们得到二阶精度的中心差分近似：\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + O(h^2)\n$$\n同理， $y$ 方向二阶导数的近似为：\n$$\n\\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} + O(h^2)\n$$\n将这些近似代入拉普拉斯方程 $\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0$，得到内部节点的离散方程：\n$$\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} = 0\n$$\n两边乘以 $h^2$，我们得到著名的离散拉普拉斯算子的五点格式：\n$$\nu_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = 0\n$$\n\n2. 诺伊曼边界条件离散化\n\n问题要求对法向导数 $\\frac{\\partial u}{\\partial n} = g(x,y)$ 使用二阶精度的单边近似。我们来推导在右边界 $x=1$ （即节点 $(N-1, j)$）上的情况，此处外法线方向为 $+x$ 方向，因此 $\\frac{\\partial u}{\\partial n} = \\frac{\\partial u}{\\partial x}$。我们必须构建一个涉及边界节点 $u_{N-1,j}$ 和沿内法线方向的两个相邻内部节点 $u_{N-2,j}$ 和 $u_{N-3,j}$ 的线性关系。\n\n我们将 $u_{N-2,j}$ 和 $u_{N-3,j}$ 在边界节点 $(x_{N-1}, y_j)$ 处进行泰勒展开：\n$$\nu_{N-2,j} = u(x_{N-1}-h, y_j) = u_{N-1,j} - h \\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{N-1,j} + O(h^3)\n$$\n$$\nu_{N-3,j} = u(x_{N-1}-2h, y_j) = u_{N-1,j} - 2h \\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} + \\frac{(2h)^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{N-1,j} + O(h^3)\n$$\n我们构造线性组合 $A u_{N-2,j} + B u_{N-3,j}$ 来消去二阶导数项 $\\frac{\\partial^2 u}{\\partial x^2}$。我们需要 $A \\frac{h^2}{2} + B \\frac{4h^2}{2} = 0$，这意味着 $A + 4B = 0$。选择 $A=4$ 和 $B=-1$，可得：\n$$\n4 u_{N-2,j} - u_{N-3,j} = (4-1) u_{N-1,j} + (-4h+2h) \\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} + O(h^3)\n$$\n$$\n4 u_{N-2,j} - u_{N-3,j} = 3 u_{N-1,j} - 2h \\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} + O(h^3)\n$$\n求解一阶导数，得到二阶精度的单边有限差分公式：\n$$\n\\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} = \\frac{3u_{N-1,j} - 4u_{N-2,j} + u_{N-3,j}}{2h} + O(h^2)\n$$\n给定诺伊曼条件 $\\frac{\\partial u}{\\partial x}|_{N-1,j} = g_{N-1,j}$，该边界节点的离散方程变为：\n$$\n3u_{N-1,j} - 4u_{N-2,j} + u_{N-3,j} = 2h g_{N-1,j}\n$$\n考虑到外法线的方向，可以为其他三个边界推导出类似的公式：\n- 左边界 ($i=0, \\frac{\\partial u}{\\partial n} = -\\frac{\\partial u}{\\partial x} = g$): $3u_{0,j} - 4u_{1,j} + u_{2,j} = -2h g_{0,j}$\n- 底边界 ($j=0, \\frac{\\partial u}{\\partial n} = -\\frac{\\partial u}{\\partial y} = g$): $3u_{i,0} - 4u_{i,1} + u_{i,2} = -2h g_{i,0}$\n- 顶边界 ($j=N-1, \\frac{\\partial u}{\\partial n} = \\frac{\\partial u}{\\partial y} = g$): $3u_{i,N-1} - 4u_{i,N-2} + u_{i,N-3} = 2h g_{i,N-1}$\n\n系统组装与求解\n\n所有 $N^2$ 个节点的离散方程构成一个大型线性系统 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u}$ 是一个包含所有未知值 $u_{i,j}$ 的向量。我们将二维网格索引 $(i,j)$ 映射到一维向量索引 $k = j \\times N + i$。矩阵 $A$ 和向量 $\\mathbf{b}$ 逐行构建，每个网格节点 $k$ 对应一行：\n\n1.  **内部节点 $(i,j)$**：方程为 $u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = 0$。对应的矩阵行 $k$ 在主对角线（$A_{k,k}$）上的系数为 $-4$，在对应其四个邻居的列上的系数为 $1$。右端项 $b_k$ 为 $0$。\n\n2.  **狄利克雷边界节点 $(i,j)$**：条件为 $u_{i,j} = d_{i,j}$。这被直接强制执行。矩阵行 $k$ 变为一个单位行：$A_{k,k} = 1$，所有其他 $A_{k,m}=0$，且 $b_k = d_{i,j}$。\n\n3.  **诺伊曼边界节点 $(i,j)$**：方程是上面推导的单边格式之一。对于右边界上的一个节点，使用方程 $3u_{N-1,j} - 4u_{N-2,j} + u_{N-3,j} = 2h g_{N-1,j}$。对应于 $(N-1, j)$ 的矩阵行 $k$ 将在映射到 $(N-1,j), (N-2,j), (N-3,j)$ 的列上分别具有系数 $3, -4, 1$。右端项为 $b_k = 2h g_{N-1,j}$。\n\n4.  **角节点**：问题指定角节点总是被赋予来自精确解 $u^\\star$ 的狄利克雷值。这是狄利克雷边界条件的一个特例，对于消除歧义至关重要，特别是当两个诺伊曼边界在一个角点相遇时。\n\n得到的线性系统是大型稀疏的。为了效率，它使用稀疏矩阵格式（例如 `scipy.sparse.lil_matrix`）构建，并使用稀疏直接求解器（`scipy.sparse.linalg.spsolve`）求解。求解向量 $\\mathbf{u}$ 后，将其重塑回一个 $N \\times N$ 的网格，代表数值解 $u_{i,j}^{\\text{num}}$。然后将该解与网格上的精确解 $u^\\star(x_i, y_j)$ 进行比较，以计算最大绝对误差 $E_\\infty = \\max_{i,j} |u_{i,j}^{\\text{num}} - u^\\star(x_i, y_j)|$。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_laplace_2d(N, u_star, bc_config):\n    \"\"\"\n    Solves the 2D Laplace equation on a unit square using a second-order\n    finite difference method with mixed Dirichlet/Neumann boundary conditions.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    num_unknowns = N * N\n    \n    # Initialize sparse matrix A and vector b\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b = np.zeros(num_unknowns)\n    \n    # Create coordinate grids\n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n    \n    for j in range(N):\n        for i in range(N):\n            k = j * N + i  # Row-major mapping from (i, j) to k\n            x, y = x_coords[i], y_coords[j]\n            \n            # 1. Corner nodes (always Dirichlet from exact solution)\n            is_corner = (i == 0 or i == N - 1) and (j == 0 or j == N - 1)\n            if is_corner:\n                A[k, k] = 1.0\n                b[k] = u_star(x, y)\n                continue\n\n            # 2. Boundary nodes (not corners)\n            side_name = None\n            s_coord = -1.0\n            if i == 0:\n                side_name, s_coord = 'left', y\n            elif i == N - 1:\n                side_name, s_coord = 'right', y\n            elif j == 0:\n                side_name, s_coord = 'bottom', x\n            elif j == N - 1:\n                side_name, s_coord = 'top', x\n\n            if side_name:\n                segments = bc_config[side_name]\n                bc_type, bc_value_func = None, None\n                \n                # Find the correct piecewise segment for this node\n                for seg_s_max, seg_type, seg_func in segments:\n                    # The condition `s_coord = seg_s_max` correctly handles\n                    # intervals like [0, 0.4] and (0.4, 1.0]. A small\n                    # tolerance is added for floating point comparison.\n                    if s_coord = seg_s_max + 1e-9:\n                        bc_type = seg_type\n                        bc_value_func = seg_func\n                        break\n                \n                if bc_type == 'D': # Dirichlet condition\n                    A[k, k] = 1.0\n                    b[k] = bc_value_func(x, y)\n                elif bc_type == 'N': # Neumann condition\n                    g_val = bc_value_func(x, y)\n                    if side_name == 'left': # d/dn = -d/dx = g. Forward diff for d/dx: (-3u0+4u1-u2)/2h. So g = -(-3u0+4u1-u2)/2h => 3u0-4u1+u2 = -2hg\n                        A[k, j * N + 0] = 3.0\n                        A[k, j * N + 1] = -4.0\n                        A[k, j * N + 2] = 1.0\n                        b[k] = -2.0 * h * g_val\n                    elif side_name == 'right': # d/dn = d/dx = g. Backward diff for d/dx: (3u_{N-1}-4u_{N-2}+u_{N-3})/2h. So g = (...) => 3u_{N-1}-4u_{N-2}+u_{N-3} = 2hg\n                        A[k, j * N + (N - 1)] = 3.0\n                        A[k, j * N + (N - 2)] = -4.0\n                        A[k, j * N + (N - 3)] = 1.0\n                        b[k] = 2.0 * h * g_val\n                    elif side_name == 'bottom': # d/dn = -d/dy = g. Forward diff for d/dy. => 3u_{i,0}-4u_{i,1}+u_{i,2} = -2hg\n                        A[k, (0 * N) + i] = 3.0\n                        A[k, (1 * N) + i] = -4.0\n                        A[k, (2 * N) + i] = 1.0\n                        b[k] = -2.0 * h * g_val\n                    elif side_name == 'top': # d/dn = d/dy = g. Backward diff for d/dy. => 3u_{i,N-1}-4u_{i,N-2}+u_{i,N-3} = 2hg\n                        A[k, ((N - 1) * N) + i] = 3.0\n                        A[k, ((N - 2) * N) + i] = -4.0\n                        A[k, ((N - 3) * N) + i] = 1.0\n                        b[k] = 2.0 * h * g_val\n                continue\n\n            # 3. Interior nodes\n            A[k, k] = -4.0\n            A[k, k - 1] = 1.0  # u_{i-1, j}\n            A[k, k + 1] = 1.0  # u_{i+1, j}\n            A[k, k - N] = 1.0  # u_{i, j-1}\n            A[k, k + N] = 1.0  # u_{i, j+1}\n            b[k] = 0.0\n\n    # Solve the linear system\n    A_csc = A.tocsc()\n    u_vec = spsolve(A_csc, b)\n    u_numerical = u_vec.reshape((N, N))\n\n    # Calculate exact solution and error\n    u_exact_grid = np.zeros((N, N))\n    for j in range(N):\n        for i in range(N):\n            u_exact_grid[j, i] = u_star(x_coords[i], y_coords[j])\n            \n    max_error = np.max(np.abs(u_numerical - u_exact_grid))\n    return max_error\n\n\ndef solve():\n    # Test case A (general mixed, smooth polynomial)\n    N_A = 51\n    u_star_A = lambda x, y: x**2 - y**2\n    u_dy_A = lambda x, y: -2*y\n    bc_A = {\n        'left':   [(1.0, 'D', lambda x, y: u_star_A(0, y))],\n        'right':  [(1.0, 'D', lambda x, y: u_star_A(1, y))],\n        'bottom': [(1.0, 'N', lambda x, y: -u_dy_A(x, 0))], # d/dn = -d/dy\n        'top':    [(1.0, 'N', lambda x, y: u_dy_A(x, 1))]   # d/dn = +d/dy\n    }\n    case_A = (N_A, u_star_A, bc_A)\n\n    # Test case B (piecewise mix on a side)\n    N_B = 51\n    u_star_B = lambda x, y: x\n    u_dx_B = lambda x, y: 1.0\n    u_dy_B = lambda x, y: 0.0\n    bc_B = {\n        'left':   [(1.0, 'D', lambda x, y: u_star_B(0, y))],\n        'right':  [(1.0, 'N', lambda x, y: u_dx_B(1, y))],   # d/dn = +d/dx\n        'bottom': [(1.0, 'D', lambda x, y: u_star_B(x, 0))],\n        'top':    [(0.4, 'N', lambda x, y: u_dy_B(x, 1)),   # d/dn = +d/dy\n                   (1.0, 'D', lambda x, y: u_star_B(x, 1))]\n    }\n    case_B = (N_B, u_star_B, bc_B)\n\n    # Test case C (edge case with small grid and homogeneous Neumann)\n    N_C = 9\n    u_star_C = lambda x, y: y\n    u_dx_C = lambda x, y: 0.0\n    u_dy_C = lambda x, y: 1.0\n    bc_C = {\n        'left':   [(1.0, 'N', lambda x, y: -u_dx_C(0, y))], # d/dn = -d/dx\n        'right':  [(1.0, 'N', lambda x, y: u_dx_C(1, y))],  # d/dn = +d/dx\n        'bottom': [(1.0, 'D', lambda x, y: u_star_C(x, 0))],\n        'top':    [(1.0, 'D', lambda x, y: u_star_C(x, 1))]\n    }\n    case_C = (N_C, u_star_C, bc_C)\n    \n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        error = solve_laplace_2d(*case)\n        results.append(f\"{error:.8f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2406696"}, {"introduction": "当你将偏微分方程离散化后，通常会得到一个大型线性方程组。如何高效地求解这个方程组，是数值计算中的下一个关键问题。本练习将带你探索三种经典的迭代求解方法：雅可比（Jacobi）法、高斯-赛德尔（Gauss-Seidel）法和逐次超松弛（SOR）法。通过亲手实现并比较它们的收敛速度，你将对算法效率和数值稳定性获得深刻的实践理解。[@problem_id:2406769]", "problem": "考虑在方形域 $\\Omega = (0,1)\\times(0,1)$ 上的二维拉普拉斯方程 $\\nabla^2 u = 0$，其带有狄利克雷边界条件。设边界数据为 $u(x,0) = \\sin(\\pi x)$，$u(x,1) = 0$，$u(0,y)=0$ 以及 $u(1,y)=0$，其中角度以弧度为单位。使用均匀网格对该域进行离散化，每个空间方向上有 $N$ 个内部点（因此网格间距为 $h = \\frac{1}{N+1}$，包括边界在内的总网格点数为 $(N+2)\\times(N+2)$）。使用标准的二阶中心有限差分近似来处理拉普拉斯算子，从而获得关于内部未知数的线性系统。从由连续方程和中心差分推导出的离散拉普拉斯算子定义出发，实现三种定常迭代方法来求解离散方程：雅可比 (Jacobi) 方法、高斯-赛德尔 (Gauss-Seidel) 方法以及带有松弛参数 $\\omega$ (满足 $0  \\omega  2$) 的逐次超松弛 (SOR) 方法。对于每种方法，请使用以下基本依据和定义：\n\n- 在内部网格点 $(i,j)$ 处的离散拉普拉斯方程由 $\\nabla^2 u = 0$ 的中心差分近似得到：\n$$\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} = 0,$$\n这在代数上等价于差分格式方程\n$$-u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} + 4 u_{i,j} = 0.$$\n- 由此，将内部的离散残差定义为\n$$r_{i,j} = 4u_{i,j} - \\left(u_{i+1,j}+u_{i-1,j}+u_{i,j+1}+u_{i,j-1}\\right),$$\n及其无穷范数定义为 $\\|r\\|_{\\infty} = \\max_{i,j} |r_{i,j}|$.\n- 使用停止准则 $\\|r^{(k)}\\|_{\\infty} \\le \\text{tol}\\cdot \\|r^{(0)}\\|_{\\infty}$，其中 $\\text{tol}$ 是给定的容差，$k$ 是迭代指数，初始猜测 $u^{(0)}$ 在所有内部点上为零，并在边界点上取固定的边界值。\n\n您的程序必须：\n- 实现 Jacobi 迭代，该迭代仅使用前一次迭代的值来更新所有内部值。\n- 实现 Gauss–Seidel 迭代，其方式是使用最新的可用邻近值（您可以使用红黑排序来实现此目的）。\n- 通过以下公式使用红黑排序和松弛参数 $\\omega$ 实现 SOR 迭代：\n$$u^{(k+1)}_{i,j} = u^{(k)}_{i,j} + \\omega\\left(\\frac{1}{4}\\left(u^{(*)}_{i+1,j}+u^{(*)}_{i-1,j}+u^{(*)}_{i,j+1}+u^{(*)}_{i,j-1}\\right) - u^{(k)}_{i,j}\\right),$$\n其中 $u^{(*)}$ 表示与每种颜色上的 Gauss–Seidel 排序一致的最新值。取 $\\omega = 1$ 可恢复为 Gauss–Seidel 方法。\n\n您的任务是通过报告每个测试用例中每种方法满足停止准则所需的迭代次数，来定量比较这三种方法的收敛速度。所有方法都使用相同的离散化、边界条件和停止判据，并将迭代次数报告为整数。\n\n测试套件。在以下参数集上运行您的程序，其中每个测试用例都是一个三元组 $(N, \\text{tol}, \\omega)$：\n- 测试 $1$：$(20, 10^{-5}, 1.5)$。\n- 测试 $2$：$(20, 10^{-5}, 1.0)$。\n- 测试 $3$：$(10, 10^{-8}, 1.8)$。\n- 测试 $4$：$(40, 10^{-4}, 1.9)$。\n\n对于每个测试用例，您的程序必须生成一个列表 $[n_J, n_{GS}, n_{SOR}]$，其中分别包含 Jacobi、Gauss–Seidel 和 SOR 方法满足停止准则所需的迭代次数。将所有测试的结果汇总到单行中，作为这些列表的逗号分隔列表，不含空格，并用方括号括起来。例如，您的输出必须与\n$[[n_J^{(1)},n_{GS}^{(1)},n_{SOR}^{(1)}],[n_J^{(2)},n_{GS}^{(2)},n_{SOR}^{(2)}],[n_J^{(3)},n_{GS}^{(3)},n_{SOR}^{(3)}],[n_J^{(4)},n_{GS}^{(4)},n_{SOR}^{(4)}]]$\n完全一样, 打印为单行。不涉及物理单位。正弦函数中的角度必须以弧度解释。", "solution": "所述问题是椭圆偏微分方程数值解领域一个标准的、适定性的练习。它在科学上是合理的，内容是自包含的，并且算法上是明确的。不存在矛盾、歧义或事实错误。因此，我们直接进行求解。\n\n该问题要求在单位方形域 $\\Omega = (0,1)\\times(0,1)$ 上求解二维拉普拉斯方程 $\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0$。势函数 $u(x,y)$ 满足狄利克雷边界条件：$u(x,0) = \\sin(\\pi x)$，并且在其他三个边界上 $u=0$。\n\n第一步是离散化连续问题。该域被一个含 $(N+2) \\times (N+2)$ 个点的均匀网格覆盖，其中 $N$ 是每个方向上的内部点数。网格间距为 $h = \\frac{1}{N+1}$。对于下标 $i,j \\in \\{0, 1, \\dots, N+1\\}$，一个网格点表示为 $(x_i, y_j) = (ih, jh)$。该点的势值为 $u_{i,j} \\approx u(x_i, y_j)$。\n\n拉普拉斯算子 $\\nabla^2$ 在每个内部网格点 $(i,j)$ 处使用二阶中心差分公式进行近似：\n$$ \\nabla^2 u \\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\n将此近似设为 $0$，得到内部点（$1 \\le i,j \\le N$）的离散拉普拉斯方程：\n$$ u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = 0 $$\n这个五点差分格式方程可以重排，将 $u_{i,j}$ 表示为其四个邻近点的平均值：\n$$ u_{i,j} = \\frac{1}{4} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} \\right) $$\n这组关于 $N^2$ 个内部未知值的 $N^2$ 个线性方程构成了一个形式为 $A\\mathbf{u} = \\mathbf{b}$ 的大型稀疏线性系统，其中 $\\mathbf{u}$ 是未知数 $u_{i,j}$ 的向量，矩阵 $A$ 代表离散拉普拉斯算子。右端向量 $\\mathbf{b}$ 包含了固定的边界值。此类系统非常适合用迭代法求解。\n\n我们的任务是实现三种经典的定常迭代法：Jacobi、Gauss-Seidel 和逐次超松弛 (SOR)。这些方法从一个初始猜测 $u^{(0)}$ 开始，生成一个收敛到真实解的近似序列 $u^{(k)}$。\n\nJacobi 方法是最简单的迭代格式。对于每个点 $(i,j)$，新值 $u_{i,j}^{(k+1)}$ 仅使用前一次迭代 $u^{(k)}$ 的值来计算。其更新规则是平均公式的直接应用：\n$$ u_{i,j}^{(k+1)} = \\frac{1}{4} \\left( u_{i+1,j}^{(k)} + u_{i-1,j}^{(k)} + u_{i,j+1}^{(k)} + u_{i,j-1}^{(k)} \\right) $$\n此更新可以对所有内部点同时（或以任何顺序）执行，因为在同一次迭代中，每个点的计算都与其他点无关。在向量化实现中，需要一个第 $k$ 次迭代网格的完整副本来计算第 $k+1$ 次迭代的网格。\n\nGauss-Seidel 方法是对 Jacobi 方法的改进，它在当前迭代中使用了最新计算出的值。其更新规则是：\n$$ u_{i,j}^{(k+1)} = \\frac{1}{4} \\left( u_{i+1,j}^{(*)} + u_{i-1,j}^{(*)} + u_{i,j+1}^{(*)} + u_{i,j-1}^{(*)} \\right) $$\n其中 $u^{(*)}$ 表示可用的最新值。例如，在字典序（逐行逐列）中，计算 $u_{i,j}^{(k+1)}$ 会使用来自当前迭代 $k+1$ 的 $u_{i-1,j}^{(k+1)}$ 和 $u_{i,j-1}^{(k+1)}$，以及来自前一次迭代 $k$ 的 $u_{i+1,j}^{(k)}$ 和 $u_{i,j+1}^{(k)}$。这种对更新顺序的依赖性使并行化变得复杂。红黑排序方案规避了这个问题。网格点被像棋盘一样着色。首先更新所有“红”点，使用其“黑”邻点（来自前一次迭代）的值。然后，更新所有“黑”点，使用其“红”邻点新计算出的值。这两个阶段（红点更新，黑点更新）中的每一个都可以被完全向量化。\n\n逐次超松弛 (SOR) 方法是 Gauss-Seidel 方法的一种外推，旨在加速收敛。它计算 Gauss-Seidel 的更新量，然后由松弛参数 $\\omega$ 控制，将解沿着该方向进一步推进。更新公式为：\n$$ u_{i,j}^{(k+1)} = u_{i,j}^{(k)} + \\omega \\left( u_{i,j}^{\\text{GS}} - u_{i,j}^{(k)} \\right) = (1-\\omega)u_{i,j}^{(k)} + \\omega u_{i,j}^{\\text{GS}} $$\n其中 $u_{i,j}^{\\text{GS}}$ 是在该点通过 Gauss-Seidel 步骤计算出的值。与 Gauss-Seidel 一样，SOR 也使用红黑排序来实现，以高效地使用最新值。当 $\\omega=1$ 时，SOR 方法就精确地简化为 Gauss-Seidel 方法。对于拉普拉斯类型的问题，在 $1  \\omega  2$（超松弛）范围内选择一个最优的 $\\omega$ 通常会显著提升收敛速度。\n\n停止判据基于离散残差的无穷范数，定义为 $\\|r^{(k)}\\|_{\\infty} = \\max_{i,j} |r_{i,j}^{(k)}|$，其中 $r_{i,j}^{(k)} = 4u_{i,j}^{(k)} - (u_{i+1,j}^{(k)} + u_{i-1,j}^{(k)} + u_{i,j+1}^{(k)} + u_{i,j-1}^{(k)})$。当 $\\|r^{(k)}\\|_{\\infty} \\le \\text{tol} \\cdot \\|r^{(0)}\\|_{\\infty}$ 时，迭代停止，其中 $\\text{tol}$ 是给定的容差，$\\|r^{(0)}\\|_{\\infty}$ 是初始猜测（内部点上 $u^{(0)}=0$）的残差范数。这个相对判据确保了不同问题设置之间的公平比较。\n\n该实现包含三个主要函数。一个函数用于设置 $(N+2) \\times (N+2)$ 网格，将内部初始化为 0 并设置边界条件。第二个函数实现 Jacobi 迭代。第三个函数实现带红黑排序的 SOR 迭代，通过设置 $\\omega=1$ 也可用于 Gauss-Seidel 方法。一个辅助函数在每一步计算残差范数。主程序遍历所有测试用例，调用相应的求解器函数，并记录收敛所需的迭代次数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef setup_initial_state(N):\n    \"\"\"\n    Initializes the grid with boundary conditions and zero interior.\n\n    Args:\n        N (int): Number of interior points in each direction.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The (N+2)x(N+2) grid `u`.\n            - float: The grid spacing `h`.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    u = np.zeros((N + 2, N + 2))\n    \n    # Set boundary condition u(x,0) = sin(pi*x)\n    # The j=0 row corresponds to y=0.\n    x_coords = np.linspace(0, 1, N + 2)\n    u[0, :] = np.sin(np.pi * x_coords)\n    \n    # Other boundaries u(x,1)=0, u(0,y)=0, u(1,y)=0 are already zero.\n    return u, h\n\ndef calculate_residual_norm(u, N):\n    \"\"\"\n    Calculates the infinity norm of the residual on the interior grid.\n\n    Args:\n        u (np.ndarray): The full (N+2)x(N+2) grid.\n        N (int): Number of interior grid points.\n\n    Returns:\n        float: The infinity norm of the residual.\n    \"\"\"\n    interior = u[1:N + 1, 1:N + 1]\n    neighbors_sum = (u[1:N + 1, 2:N + 2] + u[1:N + 1, 0:N] +\n                     u[2:N + 2, 1:N + 1] + u[0:N, 1:N + 1])\n    residual = 4 * interior - neighbors_sum\n    return np.max(np.abs(residual))\n\ndef solve_jacobi(N, tol):\n    \"\"\"\n    Solves the Laplace equation using the Jacobi method.\n\n    Args:\n        N (int): Number of interior grid points.\n        tol (float): Convergence tolerance.\n\n    Returns:\n        int: Number of iterations to converge.\n    \"\"\"\n    u, h = setup_initial_state(N)\n    \n    r0_norm = calculate_residual_norm(u, N)\n    if r0_norm == 0:\n        return 0\n    \n    threshold = tol * r0_norm\n    \n    k = 0\n    while True:\n        k += 1\n        \n        u_old = u.copy()\n        \n        neighbors_sum = (u_old[1:N + 1, 2:N + 2] + u_old[1:N + 1, 0:N] +\n                         u_old[2:N + 2, 1:N + 1] + u_old[0:N, 1:N + 1])\n        u[1:N + 1, 1:N + 1] = 0.25 * neighbors_sum\n        \n        r_norm = calculate_residual_norm(u, N)\n        if r_norm = threshold:\n            return k\n\ndef solve_sor(N, tol, omega):\n    \"\"\"\n    Solves the Laplace equation using SOR with red-black ordering.\n    Recovers Gauss-Seidel for omega=1.0.\n\n    Args:\n        N (int): Number of interior grid points.\n        tol (float): Convergence tolerance.\n        omega (float): Relaxation parameter.\n\n    Returns:\n        int: Number of iterations to converge.\n    \"\"\"\n    u, h = setup_initial_state(N)\n    \n    r0_norm = calculate_residual_norm(u, N)\n    if r0_norm == 0:\n        return 0\n        \n    threshold = tol * r0_norm\n    \n    # Create red-black masks for the interior (N x N) grid.\n    # (j, i) indices for the interior part start from 0.\n    # Grid point (j_grid, i_grid) where j_grid, i_grid in [1,N]\n    # corresponds to mask point (j_grid-1, i_grid-1).\n    # Color depends on (j_grid + i_grid). (j_grid-1) + (i_grid-1) has same parity.\n    I, J = np.meshgrid(np.arange(N), np.arange(N))\n    red_mask = (I + J) % 2 == 0\n    black_mask = ~red_mask\n    \n    k = 0\n    while True:\n        k += 1\n        \n        # Keep a copy of the interior from the start of the iteration\n        # for the (1-omega) term.\n        u_old_interior = u[1:N + 1, 1:N + 1].copy()\n\n        # Update red points. Neighbors are black, use values from start of iteration.\n        neighbors_sum = (u[1:N + 1, 2:N + 2] + u[1:N + 1, 0:N] +\n                         u[2:N + 2, 1:N + 1] + u[0:N, 1:N + 1])\n        gs_update = 0.25 * neighbors_sum\n        u[1:N + 1, 1:N + 1][red_mask] = (1 - omega) * u_old_interior[red_mask] + \\\n                                      omega * gs_update[red_mask]\n\n        # Update black points. Neighbors are red, use newly updated values.\n        neighbors_sum = (u[1:N + 1, 2:N + 2] + u[1:N + 1, 0:N] +\n                         u[2:N + 2, 1:N + 1] + u[0:N, 1:N + 1])\n        gs_update = 0.25 * neighbors_sum\n        u[1:N + 1, 1:N + 1][black_mask] = (1 - omega) * u_old_interior[black_mask] + \\\n                                        omega * gs_update[black_mask]\n        \n        r_norm = calculate_residual_norm(u, N)\n        if r_norm = threshold:\n            return k\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (20, 1e-5, 1.5),\n        (20, 1e-5, 1.0),\n        (10, 1e-8, 1.8),\n        (40, 1e-4, 1.9),\n    ]\n\n    results = []\n    for N, tol, omega_sor in test_cases:\n        # Calculate iterations for Jacobi\n        n_J = solve_jacobi(N, tol)\n        \n        # Calculate iterations for Gauss-Seidel (SOR with omega=1.0)\n        n_GS = solve_sor(N, tol, 1.0)\n        \n        # Calculate iterations for SOR with the specified omega\n        n_SOR = solve_sor(N, tol, omega_sor)\n        \n        results.append([n_J, n_GS, n_SOR])\n\n    # Format the output string as specified: [[r1,r2,r3],[...],...]\n    formatted_results = [f'[{\",\".join(map(str, r))}]' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2406769"}]}