{"hands_on_practices": [{"introduction": "在构建一个求解器以从源计算势之前，理解其逆过程是非常有价值的。第一个实践将要求你利用一个已知的势场 $\\phi$，使用离散拉普拉斯算子来计算产生它的源密度 $\\rho$ [@problem_id:2427919]。这个练习将巩固你对作为泊松求解器核心的有限差分近似的理解，并提供一种直观和量化方法误差的直接方法。", "problem": "给定一个在方形域 $[0,1] \\times [0,1]$ 上的标量势图 $\\phi(x,y)$，它在一个尺寸为 $n \\times n$、包含边界点的均匀笛卡尔网格上被采样。假设在一个无量纲公式中，泊松方程为\n$$\n\\nabla^{2}\\phi(x,y) = - \\rho(x,y).\n$$\n设网格间距为 $h = \\frac{1}{n-1}$，网格节点为 $x_i = i h$ 和 $y_j = j h$，其中 $i,j \\in \\{0,1,\\dots,n-1\\}$。对于内部节点 $(i,j)$ (其中 $i \\in \\{1,\\dots,n-2\\}$ 且 $j \\in \\{1,\\dots,n-2\\}$)，定义标准的五点离散拉普拉斯算子为\n$$\n(\\Delta_h \\phi)_{i,j} = \\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^{2}}.\n$$\n定义内部节点上的离散源密度为\n$$\n\\rho_{i,j}^{\\mathrm{comp}} = - (\\Delta_h \\phi)_{i,j}.\n$$\n对于下述每个测试用例，计算在所有内部节点上，计算所得的源密度 $\\rho_{i,j}^{\\mathrm{comp}}$ 与精确解析源密度 $\\rho^{\\mathrm{exact}}(x_i,y_j)$ 之间的最大绝对误差，\n$$\nE = \\max_{1 \\le i \\le n-2,\\; 1 \\le j \\le n-2} \\left| \\rho_{i,j}^{\\mathrm{comp}} - \\rho^{\\mathrm{exact}}(x_i,y_j) \\right|.\n$$\n所有量均为无量纲。无需物理单位。\n\n测试套件：\n- 用例1（光滑三角函数内部，非零源）：$n = 33$，$\\phi(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，$\\rho^{\\mathrm{exact}}(x,y) = 2\\pi^{2}\\sin(\\pi x)\\sin(\\pi y)$。\n- 用例2（二次多项式，恒定源）：$n = 5$，$\\phi(x,y) = x^{2} + y^{2}$，$\\rho^{\\mathrm{exact}}(x,y) = -4$。\n- 用例3（双线性多项式，零源）：$n = 3$，$\\phi(x,y) = x y$，$\\rho^{\\mathrm{exact}}(x,y) = 0$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含上述用例的三个误差值 $E$。这些值应按所列顺序排列，以逗号分隔，并用方括号括起来，每个值四舍五入到10位小数（例如，`[0.1234567890,0.0000000000,0.0000012346]`）。", "solution": "对所述问题进行验证。\n\n**步骤1：提取已知条件**\n- 域：方形域 $[0,1] \\times [0,1]$。\n- 网格：尺寸为 $n \\times n$ 的均匀笛卡尔网格，包含所有边界点。\n- 网格间距：$h = \\frac{1}{n-1}$。\n- 网格节点：$(x_i, y_j)$，其中 $x_i = i h$，$y_j = j h$，对于 $i,j \\in \\{0,1,\\dots,n-1\\}$。\n- 控制方程：泊松方程，$\\nabla^{2}\\phi(x,y) = - \\rho(x,y)$。\n- 离散拉普拉斯算子：对于内部节点 $(i,j)$，其中 $i,j \\in \\{1,\\dots,n-2\\}$，五点格式由 $(\\Delta_h \\phi)_{i,j} = \\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^{2}}$ 给出。\n- 计算的源密度：$\\rho_{i,j}^{\\mathrm{comp}} = - (\\Delta_h \\phi)_{i,j}$。\n- 误差度量：所有内部节点上的最大绝对误差，$E = \\max_{1 \\le i \\le n-2,\\; 1 \\le j \\le n-2} \\left| \\rho_{i,j}^{\\mathrm{comp}} - \\rho^{\\mathrm{exact}}(x_i,y_j) \\right|$。\n- 测试用例：\n    1. $n = 33$，$\\phi(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，$\\rho^{\\mathrm{exact}}(x,y) = 2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$。\n    2. $n = 5$，$\\phi(x,y) = x^{2} + y^{2}$，$\\rho^{\\mathrm{exact}}(x,y) = -4$。\n    3. $n = 3$，$\\phi(x,y) = x y$，$\\rho^{\\mathrm{exact}}(x,y) = 0$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据。泊松方程是物理学中的一个基本方程，而五点格式是拉普拉斯算子的标准二阶精确有限差分近似。通过直接计算连续拉普拉斯算子可以验证，对于所有三个测试用例，给定的势函数 $\\phi(x,y)$ 和精确源密度 $\\rho^{\\mathrm{exact}}(x,y)$ 之间的解析关系都是正确的：\n- 对于用例1：$\\nabla^2(\\sin(\\pi x)\\sin(\\pi y)) = -\\pi^2\\sin(\\pi x)\\sin(\\pi y) - \\pi^2\\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$，因此 $\\rho^{\\mathrm{exact}} = - \\nabla^2\\phi = 2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$。\n- 对于用例2：$\\nabla^2(x^2+y^2) = 2+2=4$，因此 $\\rho^{\\mathrm{exact}} = - \\nabla^2\\phi = -4$。\n- 对于用例3：$\\nabla^2(xy) = 0+0=0$，因此 $\\rho^{\\mathrm{exact}} = - \\nabla^2\\phi = 0$。\n该问题是适定的、客观的，并包含了获得唯一解所需的所有必要信息。这是一个用于验证离散化方案的标准数值方法练习。\n\n**步骤3：结论与行动**\n问题有效。将提供一个合理的解法。\n\n**基于原理的求解**\n\n目标是量化有限差分近似的误差。问题的核心在于连续拉普拉斯算子 $\\nabla^2$ 与其离散近似 $\\Delta_h$ 之间的差异。\n\n在网格点 $(x_i, y_j)$ 处的离散五点拉普拉斯算子 $(\\Delta_h \\phi)_{i,j}$ 是由泰勒级数展开推导出来的。对于一个足够光滑的函数 $\\phi(x,y)$，其关于 $x$ 的二阶偏导数的中心差分近似为：\n$$ \\frac{\\phi(x_i+h, y_j) - 2\\phi(x_i, y_j) + \\phi(x_i-h, y_j)}{h^2} = \\frac{\\partial^2\\phi}{\\partial x^2}\\bigg|_{(x_i,y_j)} + \\frac{h^2}{12}\\frac{\\partial^4\\phi}{\\partial x^4}\\bigg|_{(x_i,y_j)} + \\mathcal{O}(h^4) $$\n关于 $y$ 的偏导数也存在一个类似的表达式。将它们相加即可得到拉普拉斯算子的近似：\n$$ (\\Delta_h \\phi)_{i,j} = \\nabla^2\\phi\\bigg|_{(x_i,y_j)} + \\frac{h^2}{12}\\left(\\frac{\\partial^4\\phi}{\\partial x^4} + \\frac{\\partial^4\\phi}{\\partial y^4}\\right)\\bigg|_{(x_i,y_j)} + \\mathcal{O}(h^4) $$\n近似误差的主导项被称为截断误差，其阶数为 $h^2$。\n\n计算所得的源密度为 $\\rho_{i,j}^{\\mathrm{comp}} = -(\\Delta_h \\phi)_{i,j}$，精确源密度为 $\\rho^{\\mathrm{exact}}(x_i,y_j) = -\\nabla^2\\phi|_{(x_i,y_j)}$。因此，逐点误差为：\n$$ \\rho_{i,j}^{\\mathrm{comp}} - \\rho^{\\mathrm{exact}}(x_i,y_j) = -\\frac{h^2}{12}\\left(\\frac{\\partial^4\\phi}{\\partial x^4} + \\frac{\\partial^4\\phi}{\\partial y^4}\\right)\\bigg|_{(x_i,y_j)} - \\mathcal{O}(h^4) $$\n任务是计算此误差在内部网格节点上的绝对值的最大值。\n\n**算法步骤：**\n对于每个给定了参数 $n$ 以及函数 $\\phi(x,y)$ 和 $\\rho^{\\mathrm{exact}}(x,y)$ 的测试用例：\n1.  定义网格。网格间距为 $h=1/(n-1)$，网格节点为 $x_i = i h$, $y_j = j h$，其中 $i,j \\in \\{0, \\dots, n-1\\}$。\n2.  采样势函数。构造一个 $n \\times n$ 的矩阵 $\\Phi$，其中每个元素 $\\Phi_{i,j} = \\phi(x_i, y_j)$。\n3.  计算源密度。对于每个内部节点 $(i,j)$，其中 $i,j \\in \\{1, \\dots, n-2\\}$，使用五点格式公式计算 $\\rho_{i,j}^{\\mathrm{comp}}$：\n    $$ \\rho_{i,j}^{\\mathrm{comp}} = -\\frac{\\Phi_{i+1,j} + \\Phi_{i-1,j} + \\Phi_{i,j+1} + \\Phi_{i,j-1} - 4\\Phi_{i,j}}{h^2} $$\n    这可以使用数组切片进行高效的向量化计算。\n4.  计算误差。在内部网格节点上采样精确源密度 $\\rho^{\\mathrm{exact}}(x_i, y_j)$。计算所有内部节点的绝对差 $|\\rho_{i,j}^{\\mathrm{comp}} - \\rho^{\\mathrm{exact}}(x_i, y_j)|$。\n5.  找出最大误差 $E$，即所有计算出的绝对差中的最大值。\n\n**测试用例分析：**\n- **用例1**：$\\phi(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。四阶偏导数非零：$\\frac{\\partial^4\\phi}{\\partial x^4} = \\pi^4\\phi(x,y)$ 且 $\\frac{\\partial^4\\phi}{\\partial y^4} = \\pi^4\\phi(x,y)$。误差预计为非零，且与 $h^2$ 成正比。当 $n=33$，$h = 1/32$ 时，误差应该很小但不可忽略。\n- **用例2**：$\\phi(x,y) = x^2 + y^2$。这是一个二次多项式。所有三阶及更高阶的偏导数都恒等于零。截断误差项 $\\frac{h^2}{12}(\\dots)$ 为零。因此，对于此函数，有限差分近似是精确的。误差 $E$ 必须为0，仅受浮点精度的限制。\n- **用例3**：$\\phi(x,y) = xy$。这是一个双线性多项式。所有二阶及更高阶的偏导数都恒等于零。同样，截断误差为零，有限差分公式是精确的。误差 $E$ 必须为0。\n\n实现将对每个用例遵循此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_error(n, phi_func, rho_exact_func):\n    \"\"\"\n    Computes the maximum absolute error for a given test case.\n\n    Args:\n        n (int): The grid size (n x n).\n        phi_func (callable): A function for the scalar potential phi(x, y).\n        rho_exact_func (callable): A function for the exact source rho(x, y).\n\n    Returns:\n        float: The maximum absolute error E over the interior nodes.\n    \"\"\"\n    # 1. Define the grid.\n    if n < 3:\n        # No interior points for n < 3. Error is trivially 0.\n        return 0.0\n        \n    h = 1.0 / (n - 1)\n    # Create grid coordinates. 'ij' indexing ensures that the first index\n    # corresponds to x and the second to y, matching the problem's notation.\n    x = np.linspace(0.0, 1.0, n)\n    y = np.linspace(0.0, 1.0, n)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Sample the potential on the full grid.\n    phi_grid = phi_func(xx, yy)\n\n    # 3. Compute the source density on the interior grid.\n    # The five-point stencil is applied using vectorized numpy slicing.\n    # phi_grid[1:-1, 1:-1] corresponds to phi_ij for interior i,j\n    # phi_grid[2:, 1:-1]   corresponds to phi_{i+1,j}\n    # phi_grid[:-2, 1:-1]  corresponds to phi_{i-1,j}\n    # etc.\n    laplacian_phi_interior = (phi_grid[2:, 1:-1] + phi_grid[:-2, 1:-1] +\n                              phi_grid[1:-1, 2:] + phi_grid[1:-1, :-2] -\n                              4 * phi_grid[1:-1, 1:-1]) / (h**2)\n    \n    rho_comp_interior = -laplacian_phi_interior\n\n    # 4. Compute the error.\n    # Sample the exact source density on the interior grid.\n    rho_exact_interior = rho_exact_func(xx[1:-1, 1:-1], yy[1:-1, 1:-1])\n    \n    error_matrix = np.abs(rho_comp_interior - rho_exact_interior)\n\n    # 5. Find the maximum error.\n    max_error = np.max(error_matrix)\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Smooth trigonometric function\n        {\n            \"n\": 33,\n            \"phi_func\": lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y),\n            \"rho_exact_func\": lambda x, y: 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n        },\n        # Case 2: Quadratic polynomial\n        {\n            \"n\": 5,\n            \"phi_func\": lambda x, y: x**2 + y**2,\n            \"rho_exact_func\": lambda x, y: -4.0 + 0 * x  # 0*x ensures array output\n        },\n        # Case 3: Bilinear polynomial\n        {\n            \"n\": 3,\n            \"phi_func\": lambda x, y: x * y,\n            \"rho_exact_func\": lambda x, y: 0.0 + 0 * x\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_error(\n            n=case[\"n\"],\n            phi_func=case[\"phi_func\"],\n            rho_exact_func=case[\"rho_exact_func\"]\n        )\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.10f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2427919"}, {"introduction": "掌握了离散拉普拉斯算子之后，我们现在转向主要任务：求解泊松方程以获得势场。本练习将指导你在两个不同分辨率的网格上求解该问题，并使用理查森外推法（Richardson extrapolation）这一强大且广泛使用的技术来组合结果 [@problem_id:2427894]。此实践不仅强化了建立和求解线性系统的过程，还介绍了一种无需知道精确解就能获得更高精度并估计数值误差的实用方法。", "problem": "您面临的数学任务是，计算方形域上二维泊松问题的数值近似解。考虑在开放单位正方形 $\\Omega = (0,1) \\times (0,1)$ 上的偏微分方程 (PDE) $- \\nabla^2 u(x,y) = f(x,y)$，其齐次狄利克雷边界条件为 $u(x,y) = 0$ on $\\partial \\Omega$。对于每一对给定的正整数 $(k,\\ell)$，定义精确解为 $u^{\\star}(x,y) = \\sin(k \\pi x) \\sin(\\ell \\pi y)$，从而源项为 $f(x,y) = \\pi^2 (k^2 + \\ell^2) \\sin(k \\pi x) \\sin(\\ell \\pi y)$。角度以弧度为单位。\n\n对于下述每个测试用例，考虑 $\\Omega$ 上的一个均匀笛卡尔网格，其内部节点在每个空间方向上有 $N_{\\mathrm{c}}$ 个点，网格间距为 $h_{\\mathrm{c}} = 1/(N_{\\mathrm{c}}+1)$。同时考虑一个更精细的网格，其内部节点在每个方向上有 $N_{\\mathrm{f}} = 2 N_{\\mathrm{c}} + 1$ 个点，网格间距为 $h_{\\mathrm{f}} = 1/(N_{\\mathrm{f}}+1) = h_{\\mathrm{c}}/2$。在每个网格上，使用任意一种在所述均匀网格上满足齐次狄利克雷边界条件的一致、二阶精度的空间离散化方法，计算内部网格点上 $u(x,y)$ 的数值近似解。\n\n令 $U_{\\mathrm{c}}$ 表示粗网格上的数值解，令 $U_{\\mathrm{f}}$ 表示细网格上的数值解。令 $\\mathcal{I}$ 为粗网格内部节点的集合，并令 $U_{\\mathrm{f}\\to\\mathrm{c}}$ 表示细网格数值解在与粗网格重合的细网格子集（即坐标与 $\\mathcal{I}$ 中节点坐标相匹配的细网格内部节点子集）上的限制。假设所选二阶格式的逐点离散误差在网格间距 $h$ 上具有偶次幂的渐近展开，其中在精确解光滑的每个固定网格点上，首个非零项与 $h^2$ 成正比。\n\n对每个测试用例，计算以下三个标量值：\n- $E_{\\mathrm{c}}$，粗网格解在 $\\mathcal{I}$ 上的离散最大范数绝对误差，定义为 $E_{\\mathrm{c}} = \\max_{(x_i,y_j)\\in \\mathcal{I}} \\left| U_{\\mathrm{c}}(x_i,y_j) - u^{\\star}(x_i,y_j) \\right|$。\n- $E_{\\mathrm{f}\\to\\mathrm{c}}$，限制在 $\\mathcal{I}$ 上的细网格解的离散最大范数绝对误差，定义为 $E_{\\mathrm{f}\\to\\mathrm{c}} = \\max_{(x_i,y_j)\\in \\mathcal{I}} \\left| U_{\\mathrm{f}\\to\\mathrm{c}}(x_i,y_j) - u^{\\star}(x_i,y_j) \\right|$。\n- $E_{\\mathrm{comb}}$，一个组合估计值在 $\\mathcal{I}$ 上的离散最大范数绝对误差。该组合估计值是在每个 $(x_i,y_j)\\in \\mathcal{I}$ 处，由 $U_{\\mathrm{c}}(x_i,y_j)$ 和 $U_{\\mathrm{f}\\to\\mathrm{c}}(x_i,y_j)$ 组合而成，以便在上述假设下，消除偶次幂截断误差展开中的主阶项。报告 $E_{\\mathrm{comb}} = \\max_{(x_i,y_j)\\in \\mathcal{I}} \\left| U_{\\mathrm{comb}}(x_i,y_j) - u^{\\star}(x_i,y_j) \\right|$。\n\n测试套件：\n- 用例 $1$：$(k,\\ell,N_{\\mathrm{c}}) = (1,1,15)$。\n- 用例 $2$：$(k,\\ell,N_{\\mathrm{c}}) = (2,1,7)$。\n- 用例 $3$：$(k,\\ell,N_{\\mathrm{c}}) = (3,2,21)$。\n\n您的程序必须生成单行输出，其中包含一个列表的列表，按以下用例和量的顺序排列结果：对于以上列出的每个用例，按顺序输出三元组 $[E_{\\mathrm{c}}, E_{\\mathrm{f}\\to\\mathrm{c}}, E_{\\mathrm{comb}}]$。最终打印的行必须是表示这三个三元组列表的单个字符串，例如 `[[a_{11},a_{12},a_{13}],[a_{21},a_{22},a_{23}],[a_{31},a_{32},a_{33}]]`, 其中每个 $a_{ij}$ 都是一个浮点数。\n\n输出中的所有浮点数都必须以科学记数法打印，小数点后精确到八位。\n\n此问题不涉及物理单位。所有三角函数中的角度必须以弧度为单位。", "solution": "该问题在科学和数学上是合理的。它提出了一个适定的泊松方程边值问题，并要求使用标准的、定义明确的技术进行数值求解和误差分析。所有必要的数据和定义均已提供。因此，我们将着手求解。\n\n问题的核心是在单位正方形域 $\\Omega = (0,1) \\times (0,1)$上求解二维泊松方程\n$$\n- \\nabla^2 u(x,y) = f(x,y)\n$$\n，并满足齐次狄利克雷边界条件 $u(x,y) = 0$ for $(x,y) \\in \\partial\\Omega$。源项 $f(x,y)$ 通过人造解方法确定，其中精确解被指定为 $u^{\\star}(x,y) = \\sin(k \\pi x) \\sin(\\ell \\pi y)$。应用负拉普拉斯算子，我们验证给定的源项：\n$$\n- \\nabla^2 u^{\\star}(x,y) = -\\left(\\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}\\right) \\left[ \\sin(k \\pi x) \\sin(\\ell \\pi y) \\right] = \\pi^2 (k^2+\\ell^2) \\sin(k \\pi x) \\sin(\\ell \\pi y) = f(x,y).\n$$\n问题要求在均匀笛卡尔网格上使用二阶精度的空间离散化方法进行数值求解。对此，标准的选择是五点有限差分格式。对于在 $x$ 和 $y$ 方向上均具有均匀间距 $h$ 的网格，内部网格节点 $(x_i, y_j)$ 处的拉普拉斯算子可近似为：\n$$\n\\nabla^2 u(x_i, y_j) \\approx \\frac{U_{i+1,j} - 2U_{i,j} + U_{i-1,j}}{h^2} + \\frac{U_{i,j+1} - 2U_{i,j} + U_{i,j-1}}{h^2}.\n$$\n此处，$U_{i,j}$ 表示 $u(x_i, y_j)$ 的数值近似值。将此近似代入泊松方程 $- \\nabla^2 u = f$ 并整理各项，得到每个内部节点 $(i,j)$ 处的离散方程：\n$$\n4U_{i,j} - U_{i-1,j} - U_{i+1,j} - U_{i,j-1} - U_{i,j+1} = h^2 f(x_i, y_j).\n$$\n该格式是一致的，并具有二阶截断误差，即 $O(h^2)$。通过在节点 $(i,j)$ 位于边界 $\\partial\\Omega$ 上时设置 $U_{i,j} = 0$ 来施加齐次狄利克雷边界条件 $u=0$。对于每个方向有 $N$ 个内部点的网格，这组 $N^2$ 个线性代数方程可组装成一个矩阵系统 $A\\mathbf{U} = \\mathbf{b}$，其中 $\\mathbf{U}$ 是包含 $N^2$ 个未知值 $U_{i,j}$ 的向量，$A$ 是一个大小为 $N^2 \\times N^2$ 的稀疏、对称正定、块三对角矩阵，而 $\\mathbf{b}$ 是一个包含网格点上 $h^2 f(x_i, y_j)$ 值的向量。该系统可以被高效地求解以得到 $\\mathbf{U}$。\n\n问题要求在网格间距为 $h_{\\mathrm{c}}$ 的粗网格和间距为 $h_{\\mathrm{f}} = h_{\\mathrm{c}}/2$ 的细网格上计算误差。此外，还要求使用理查森外推法（Richardson extrapolation）得到一个组合解。问题指出，逐点误差在 $h$ 的偶次幂上具有渐近展开：\n$$\nU_h(x,y) = u^{\\star}(x,y) + C(x,y)h^2 + D(x,y)h^4 + \\dots\n$$\n令 $U_{\\mathrm{c}}$ 为粗网格（间距 $h_{\\mathrm{c}}$）上的解，$U_{\\mathrm{f}}$ 为细网格（间距 $h_{\\mathrm{f}}$）上的解。在一个同时是两个网格节点的点 $(x,y)$ 处，我们有：\n$$\nU_{\\mathrm{c}}(x,y) = u^{\\star}(x,y) + C(x,y)h_{\\mathrm{c}}^2 + O(h_{\\mathrm{c}}^4)\n$$\n$$\nU_{\\mathrm{f}}(x,y) = u^{\\star}(x,y) + C(x,y)h_{\\mathrm{f}}^2 + O(h_{\\mathrm{f}}^4) = u^{\\star}(x,y) + C(x,y)\\frac{h_{\\mathrm{c}}^2}{4} + O(h_{\\mathrm{c}}^4).\n$$\n我们可以通过线性组合这两个方程来消除主误差项 $C(x,y)h_{\\mathrm{c}}^2$。将第二个方程乘以 4，然后减去第一个方程，得到：\n$$\n4U_{\\mathrm{f}}(x,y) - U_{\\mathrm{c}}(x,y) = 3u^{\\star}(x,y) + O(h_{\\mathrm{c}}^4).\n$$\n这为 $u^{\\star}(x,y)$ 提供了一个更精确的估计，我们将其定义为组合解 $U_{\\mathrm{comb}}$：\n$$\nU_{\\mathrm{comb}}(x,y) = \\frac{4U_{\\mathrm{f}}(x,y) - U_{\\mathrm{c}}(x,y)}{3}.\n$$\n此组合解的误差阶为 $O(h_{\\mathrm{c}}^4)$，比原始解的 $O(h_{\\mathrm{c}}^2)$ 误差有所改进。在我们的情况下，比较是在粗网格节点集合 $\\mathcal{I}$ 上进行的。因此，我们在公式中使用 $U_{\\mathrm{f}\\to\\mathrm{c}}$，即细网格解在这些节点上的限制：\n$$\nU_{\\mathrm{comb}} = \\frac{4U_{\\mathrm{f}\\to\\mathrm{c}} - U_{\\mathrm{c}}}{3}.\n$$\n所需的量 $E_{\\mathrm{c}}$、$E_{\\mathrm{f}\\to\\mathrm{c}}$ 和 $E_{\\mathrm{comb}}$ 分别是对应数值解 $U_{\\mathrm{c}}$、$U_{\\mathrm{f}\\to\\mathrm{c}}$ 和 $U_{\\mathrm{comb}}$ 的离散最大范数绝对误差，定义为 $E = \\max_{(x_i,y_j)\\in \\mathcal{I}} \\left| U(x_i,y_j) - u^{\\star}(x_i,y_j) \\right|$。\n\n对于每个测试用例 $(k,\\ell,N_{\\mathrm{c}})$，算法流程如下：\n$1$. 定义具有 $N_{\\mathrm{c}}$ 个内部点和间距 $h_{\\mathrm{c}} = 1/(N_{\\mathrm{c}}+1)$ 的粗网格。\n$2$. 定义具有 $N_{\\mathrm{f}} = 2N_{\\mathrm{c}}+1$ 个内部点和间距 $h_{\\mathrm{f}} = h_{\\mathrm{c}}/2$ 的细网格。\n$3$. 求解线性系统 $A_{\\mathrm{c}}\\mathbf{U}_{\\mathrm{c}} = \\mathbf{b}_{\\mathrm{c}}$ 以获得粗网格解 $U_{\\mathrm{c}}$。\n$4$. 求解线性系统 $A_{\\mathrm{f}}\\mathbf{U}_{\\mathrm{f}} = \\mathbf{b}_{\\mathrm{f}}$ 以获得细网格解 $U_{\\mathrm{f}}$。\n$5$. 在粗网格节点上计算精确解 $u^{\\star}$。\n$6$. 将细网格解 $U_{\\mathrm{f}}$ 限制到粗网格节点上以获得 $U_{\\mathrm{f}\\to\\mathrm{c}}$。这涉及到从细网格解数组中每隔一个点选取一个点。\n$7$. 使用理查森外推公式在粗网格上计算组合解 $U_{\\mathrm{comb}}$。\n$8$. 通过在粗网格上将 $U_{\\mathrm{c}}$、$U_{\\mathrm{f}\\to\\mathrm{c}}$ 和 $U_{\\mathrm{comb}}$ 与精确解 $u^{\\star}$ 进行比较，计算最大范数误差 $E_{\\mathrm{c}}$、$E_{\\mathrm{f}\\to\\mathrm{c}}$ 和 $E_{\\mathrm{comb}}$。\n对所有指定的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef setup_and_solve_poisson(N, k, l):\n    \"\"\"\n    Sets up and solves the 2D Poisson problem on an N x N interior grid using\n    a five-point finite difference scheme.\n\n    Args:\n        N (int): The number of interior grid points in each spatial direction.\n        k (int): Wavenumber in the x-direction for the manufactured solution.\n        l (int): Wavenumber in the y-direction for the manufactured solution.\n\n    Returns:\n        tuple: A tuple containing:\n            - U (np.ndarray): The 2D numerical solution array of shape (N, N).\n            - xx (np.ndarray): The 2D array of x-coordinates.\n            - yy (np.ndarray): The 2D array of y-coordinates.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    \n    # Create grid coordinates for interior points\n    x = np.linspace(h, 1.0 - h, N)\n    y = np.linspace(h, 1.0 - h, N)\n    xx, yy = np.meshgrid(x, y)\n    \n    # Evaluate the source term f(x,y) on the grid\n    f_grid = (np.pi**2 * (k**2 + l**2) * \n              np.sin(k * np.pi * xx) * np.sin(l * np.pi * yy))\n    \n    # Flatten the source term into the RHS vector b, using column-major (Fortran) order\n    b = h**2 * f_grid.flatten(order='F')\n    \n    # Construct the sparse matrix A for the 5-point stencil\n    N2 = N * N\n    \n    main_diag = np.full(N2, 4.0)\n    \n    # Off-diagonals for x-connections (indices i-1, i+1)\n    off_diag_x = np.full(N2 - 1, -1.0)\n    # Remove connections across column boundaries in the flattened vector\n    off_diag_x[N-1::N] = 0.0\n    \n    # Off-diagonals for y-connections (indices j-1, j+1)\n    off_diag_y = np.full(N2 - N, -1.0)\n    \n    diagonals = [main_diag, off_diag_x, off_diag_x, off_diag_y, off_diag_y]\n    offsets = [0, 1, -1, N, -N]\n    \n    # Create the sparse matrix in Compressed Sparse Row format for efficiency\n    A = sparse.diags(diagonals, offsets, shape=(N2, N2), format='csr')\n    \n    # Solve the linear system A*U = b\n    # Using spsolve from SciPy's sparse linear algebra library\n    u_vec = spsolve(A, b)\n    \n    # Reshape the solution vector back to a 2D grid, using the same column-major order\n    U = u_vec.reshape((N, N), order='F')\n    \n    return U, xx, yy\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1, 15),\n        (2, 1, 7),\n        (3, 2, 21),\n    ]\n\n    all_results_str = []\n    \n    for case in test_cases:\n        k, l, Nc = case\n        \n        # Define fine grid parameters based on coarse grid\n        Nf = 2 * Nc + 1\n        \n        # Solve the PDE on the coarse grid\n        Uc, xc, yc = setup_and_solve_poisson(Nc, k, l)\n        \n        # Solve the PDE on the fine grid\n        Uf, _, _ = setup_and_solve_poisson(Nf, k, l)\n        \n        # Evaluate the exact solution on the coarse grid for error calculation\n        u_star_c = np.sin(k * np.pi * xc) * np.sin(l * np.pi * yc)\n        \n        # Restrict the fine grid solution to the coarse grid nodes.\n        # Coarse grid nodes correspond to odd-indexed nodes (1, 3, 5, ...) in the fine grid.\n        Uf_to_c = Uf[1::2, 1::2]\n        \n        # Apply Richardson extrapolation to get a higher-order accurate solution\n        # U_comb = U_f_to_c + (U_f_to_c - U_c) / (r^p - 1), where r=2, p=2.\n        U_comb = (4.0 * Uf_to_c - Uc) / 3.0\n        \n        # Calculate discrete maximum-norm absolute errors\n        Ec = np.max(np.abs(Uc - u_star_c))\n        Ef_to_c = np.max(np.abs(Uf_to_c - u_star_c))\n        E_comb = np.max(np.abs(U_comb - u_star_c))\n        \n        # Format the results for this case as specified (scientific notation, 8 decimal places)\n        case_result_str = f\"[{Ec:.8e},{Ef_to_c:.8e},{E_comb:.8e}]\"\n        all_results_str.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2427894"}, {"introduction": "现实世界的问题常常具有复杂的几何形状，这些形状会显著影响解的行为。这个高级实践将挑战你在一个L形域上求解拉普拉斯方程（泊松方程在源为零时的特例）[@problem_id:2427929]。通过分析凹角附近的解，你将从数值上研究解的奇性这一概念，这是一种势的导数可能变为无穷大的现象，并将你的计算结果与基本的理论预测联系起来。", "problem": "考虑在有界平面域 $\\Omega$ 上静电势 $u(x,y)$ 的二维拉普拉斯方程，\n$$\n\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0 \\quad \\text{in } \\Omega,\n$$\n其狄利克雷边界条件在 $\\partial \\Omega$ 上指定为\n$$\nu(0,y) = 1 \\quad \\text{for } y \\in [0,1] \\text{ that belong to } \\partial \\Omega, \\quad u = 0 \\quad \\text{on the rest of } \\partial \\Omega.\n$$\n将考虑两个域：\n- L 形域 $\\Omega_L = \\{(x,y) \\in [0,1]^2 \\,:\\, x \\le 0.5 \\text{ or } y \\le 0.5\\}$，其在 $c = (0.5,0.5)$ 处有一个凹角，内角为 $\\omega = 3\\pi/2$。\n- 方形域 $\\Omega_S = [0,1]^2$，点 $c = (0.5,0.5)$ 位于其内部，且没有凹角。\n\n对于给定的整数分辨率参数 $N \\ge 2$，定义间距为 $h = 1/N$ 的均匀网格，网格节点为 $(x_i,y_j) = (i h, j h)$，其中整数 $i,j \\in \\{0,1,\\dots,N\\}$。假设 $N$ 为偶数，以使凹角 $c$ 与网格线对齐。令 $u_{i,j}$ 表示 $u(x_i,y_j)$ 的数值近似解，该解通过精确实施狄利克雷边界条件并在所选域的内部求解拉普拉斯方程得到。\n\n在梯度有良好定义的网格节点上，通过中心差分将其大小定义为\n$$\n\\left|\\nabla u\\right|_{i,j} = \\sqrt{\\left(\\frac{u_{i+1,j} - u_{i-1,j}}{2h}\\right)^2 + \\left(\\frac{u_{i,j+1} - u_{i,j-1}}{2h}\\right)^2},\n$$\n前提是所有引用的值都属于该域。对于固定点 $c = (0.5,0.5)$，其到网格节点 $(x_i,y_j)$ 的离散距离定义为\n$$\nr_{i,j} = \\sqrt{(x_i - 0.5)^2 + (y_j - 0.5)^2}.\n$$\n对于每个整数环索引 $k \\in \\{2,3,\\dots,10\\}$，定义环\n$$\n\\mathcal{A}_k = \\left\\{ (i,j) \\,:\\, \\text{the gradient magnitude is defined at } (i,j) \\text{ and } k h \\le r_{i,j} < (k+1) h \\right\\}.\n$$\n对于每个非空环 $\\mathcal{A}_k$，计算梯度大小的中位数\n$$\nG_k = \\operatorname{median}\\left\\{ \\left|\\nabla u\\right|_{i,j} \\,:\\, (i,j) \\in \\mathcal{A}_k \\right\\},\n$$\n并将其与代表性半径 $R_k = k h$ 相关联。\n\n将估计的奇异性指数 $\\hat{\\alpha}$ 定义为数据 $(\\log R_k, \\log G_k)$ 在所有非空环 $k \\in \\{2,3,\\dots,10\\}$ 上的最小二乘意义下的最佳拟合线的斜率。即，\n$$\n\\hat{\\alpha} = \\arg\\min_{a,b} \\sum_{k} \\left(\\log G_k - (a \\log R_k + b)\\right)^2, \\quad \\text{and we report } a \\text{ as } \\hat{\\alpha}.\n$$\n\n测试套件：\n- 案例 1：$\\Omega = \\Omega_L$, $N = 96$。\n- 案例 2：$\\Omega = \\Omega_L$, $N = 144$。\n- 案例 3：$\\Omega = \\Omega_S$, $N = 96$。\n\n答案规格：\n- 对于每个案例，计算相应的 $\\hat{\\alpha}$ 作为浮点数。\n- 您的程序应生成单行输出，其中包含三个结果，以逗号分隔的列表形式包含在方括号内，顺序为案例 1、2、3，每个值四舍五入到三位小数（例如，`[-0.333,-0.332,0.000]`）。\n- 不涉及物理单位。所有角度，当通过 $\\omega$ 隐式出现时，根据定义均以弧度为单位。", "solution": "所提出的问题是计算物理学中一个适定且有科学依据的练习，具体涉及二维拉普拉斯方程的数值解法和解的奇异性分析。问题陈述完整、无歧义，并且所有提供的数据都是一致的。因此，可以构建一个严谨的解。\n\n问题的核心是在两个不同的域上求解拉普拉斯方程 $\\Delta u = 0$：一个 L 形域 $\\Omega_L$ 和一个方形域 $\\Omega_S$。该方程使用间距为 $h = 1/N$ 的均匀网格进行离散化。在每个内部网格节点 $(x_i, y_j)$，拉普拉斯算子 $\\Delta$ 由标准的五点有限差分格式近似。这导出了离散方程：\n$$\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} = 0\n$$\n这简化为内部节点上的电势 $u_{i,j}$ 与其四个最近邻居之间的代数关系：\n$$\n4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = 0\n$$\n该方程应用于域的每个内部节点。位于边界 $\\partial \\Omega$ 上的节点的电势值由狄利克雷条件指定：对于左边界的适用部分，$u(0,y) = 1$，在其他地方 $u=0$。\n\n在所有内部节点上应用有限差分格式会得到一个形如 $A\\mathbf{x} = \\mathbf{b}$ 的大型稀疏线性代数方程组。这里，$\\mathbf{x}$ 是所有内部节点上未知电势值 $u_{i,j}$ 的向量，矩阵 $A$ 编码了由五点格式定义的连接关系，向量 $\\mathbf{b}$ 包含了来自固定边界条件的值。这个线性系统保证有唯一解，可以使用稀疏线性代数求解器高效地找到，例如 `scipy.sparse.linalg` 库中的 `spsolve`。\n\n该问题的一个关键方面是解的梯度在点 $c = (0.5, 0.5)$ 附近的行为。\n对于 L 形域 $\\Omega_L$，该点是内角为 $\\omega = 3\\pi/2$ 的凹角。椭圆偏微分方程理论中一个公认的结果是，解在此类角点处表现出奇异性。在角点附近，电势 $u$ 的行为类似于 $u \\sim r^{\\alpha}$，其中 $r$ 是距角点的径向距离，指数 $\\alpha$ 由 $\\pi/\\omega$ 给出。对于 $\\omega = 3\\pi/2$，我们得到 $\\alpha = \\pi / (3\\pi/2) = 2/3$。因此，梯度的大小预期行为类似于 $|\\nabla u| \\sim r^{\\alpha-1} = r^{2/3 - 1} = r^{-1/3}$。因此，$|\\nabla u|$ 对 $r$ 的对数-对数图应该产生一条斜率约为 $-1/3$ 的直线。问题要求估计这个斜率，记为 $\\hat{\\alpha}$。\n\n对于方形域 $\\Omega_S$，点 $c = (0.5, 0.5)$ 位于域的内部，远离任何边界角点。在具有平滑边界数据的凸域内，拉普拉斯方程的解是解析的（无限可微）。因此，电势 $u(x,y)$ 及其梯度在 $c$ 的邻域内是平滑函数。对于离 $c$ 很小的距离 $r$，梯度大小 $|\\nabla u|$ 将近似为常数。一个近似常数函数对 $r$ 的对数-对数图的斜率将接近 0。因此，我们预期在这种情况下，估计的奇异性指数 $\\hat{\\alpha}$ 约等于 0。\n\n求解过程如下：\n1.  对于每个测试案例（域类型和分辨率 $N$），生成一个网格并识别内部和边界节点。$N$ 为偶数的条件确保了点 $c$ 与网格节点对齐。\n2.  构建与有限差分方程组对应的稀疏矩阵 $A$ 和右侧向量 $\\mathbf{b}$。通过将已知的边界值移到向量 $\\mathbf{b}$ 中来实施边界条件。\n3.  求解线性系统 $A\\mathbf{x} = \\mathbf{b}$ 以找到所有内部节点上的电势 $u_{i,j}$。\n4.  在中心差分格式有效的每个网格节点 $(i,j)$ 上计算梯度大小 $|\\nabla u|_{i,j}$（即，格式中使用的所有四个邻居 $(i \\pm 1, j)$ 和 $(i, j \\pm 1)$ 都位于域内或其边界上）。\n5.  对于从 2 到 10 的每个整数环索引 $k$，识别所有有效的网格节点 $(i,j)$，其到 $c$ 的距离 $r_{i,j}$ 满足 $k h \\le r_{i,j} < (k+1) h$。\n6.  对于每个非空环 $\\mathcal{A}_k$，计算梯度大小的中位数 $G_k$。使用中位数可以提供一个对异常值稳健的度量。\n7.  收集数据对 $(\\log R_k, \\log G_k)$，其中 $R_k = k h$。\n8.  对这些数据点执行线性最小二乘回归，以找到最佳拟合线的斜率。该斜率即为估计的奇异性指数 $\\hat{\\alpha}$。\n\n将对三个指定的测试案例实施这一系统性程序，以获得所需的 $\\hat{\\alpha}$ 数值。对于 L 形域，随着 $N$ 的增加，结果预计将收敛到理论值 $-1/3$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef get_domain_masks(N, domain_type):\n    \"\"\"\n    Generates boolean masks for the domain, identifying interior points.\n    N must be an even integer.\n    \"\"\"\n    is_in_domain = np.zeros((N + 1, N + 1), dtype=bool)\n    is_interior = np.zeros((N + 1, N + 1), dtype=bool)\n\n    if domain_type == 'L_shape':\n        ic = N // 2\n        for i in range(N + 1):\n            for j in range(N + 1):\n                if i <= ic or j <= ic:\n                    is_in_domain[i, j] = True\n    elif domain_type == 'square':\n        is_in_domain.fill(True)\n    else:\n        raise ValueError(\"Unknown domain type\")\n\n    # An interior point must be in the domain, and so must its 4 cardinal neighbors.\n    for i in range(1, N):\n        for j in range(1, N):\n            if (is_in_domain[i, j] and\n                    is_in_domain[i - 1, j] and is_in_domain[i + 1, j] and\n                    is_in_domain[i, j - 1] and is_in_domain[i, j + 1]):\n                is_interior[i, j] = True\n\n    return is_in_domain, is_interior\n\ndef solve_laplace(N, domain_type):\n    \"\"\"\n    Solves the 2D Laplace equation on a uniform grid for a given domain.\n    \"\"\"\n    h = 1.0 / N\n    is_in_domain, is_interior = get_domain_masks(N, domain_type)\n\n    u = np.zeros((N + 1, N + 1), dtype=float)\n\n    # Apply Dirichlet boundary conditions\n    # u(0,y) = 1\n    u[0, :] = 1.0\n    # Rest of the boundary is u=0, which is the default from np.zeros.\n\n    # Map interior grid points to a 1D index for the linear system\n    interior_points = np.argwhere(is_interior)\n    num_unknowns = len(interior_points)\n    point_to_idx = {tuple(p): i for i, p in enumerate(interior_points)}\n\n    # Assemble the sparse matrix A and vector b for Ax=b\n    A = lil_matrix((num_unknowns, num_unknowns), dtype=float)\n    b = np.zeros(num_unknowns, dtype=float)\n\n    for k, (i, j) in enumerate(interior_points):\n        A[k, k] = 4.0\n        # Check neighbors\n        for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if is_interior[ni, nj]:\n                # Neighbor is another unknown\n                neighbor_idx = point_to_idx[(ni, nj)]\n                A[k, neighbor_idx] = -1.0\n            else:\n                # Neighbor is a boundary point with a known value\n                b[k] += u[ni, nj]\n\n    # Solve the sparse linear system\n    # Convert to CSC format for efficient solving\n    A_csc = A.tocsc()\n    x = spsolve(A_csc, b)\n\n    # Transfer solution vector back to the 2D grid\n    for k, (i, j) in enumerate(interior_points):\n        u[i, j] = x[k]\n\n    return u, h, is_in_domain\n\ndef estimate_singularity_exponent(u, h, N, is_in_domain):\n    \"\"\"\n    Estimates the singularity exponent alpha_hat from the numerical solution.\n    \"\"\"\n    # Identify points where the centered-difference gradient is well-defined\n    grad_definable = np.zeros((N + 1, N + 1), dtype=bool)\n    for i in range(1, N):\n        for j in range(1, N):\n            if (is_in_domain[i - 1, j] and is_in_domain[i + 1, j] and\n                    is_in_domain[i, j - 1] and is_in_domain[i, j + 1]):\n                grad_definable[i, j] = True\n\n    definable_points = np.argwhere(grad_definable)\n\n    log_R_k_list, log_G_k_list = [], []\n\n    # Analyze rings k = 2, 3, ..., 10\n    for k in range(2, 11):\n        R_k = k * h\n        r_min, r_max = k * h, (k + 1) * h\n        gradients_in_ring = []\n\n        for i, j in definable_points:\n            x, y = i * h, j * h\n            r_ij = np.sqrt((x - 0.5)**2 + (y - 0.5)**2)\n\n            if r_min <= r_ij < r_max:\n                du_dx = (u[i + 1, j] - u[i - 1, j]) / (2 * h)\n                du_dy = (u[i, j + 1] - u[i, j - 1]) / (2 * h)\n                grad_mag = np.sqrt(du_dx**2 + du_dy**2)\n                gradients_in_ring.append(grad_mag)\n\n        if gradients_in_ring:\n            G_k = np.median(gradients_in_ring)\n            # Avoid log(0) in case median is zero\n            if G_k > 1e-12:\n                log_R_k_list.append(np.log(R_k))\n                log_G_k_list.append(np.log(G_k))\n\n    # Cannot perform regression with fewer than 2 points\n    if len(log_R_k_list) < 2:\n        return 0.0\n\n    # Perform linear least-squares regression: log(G) = a*log(R) + b\n    # The slope 'a' is the desired exponent alpha_hat.\n    coeffs = np.polyfit(log_R_k_list, log_G_k_list, 1)\n    alpha_hat = coeffs[0]\n\n    return alpha_hat\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        ('L_shape', 96),\n        ('L_shape', 144),\n        ('square', 96),\n    ]\n\n    results = []\n    for domain_type, N in test_cases:\n        u, h, is_in_domain = solve_laplace(N, domain_type)\n        alpha_hat = estimate_singularity_exponent(u, h, N, is_in_domain)\n        results.append(alpha_hat)\n\n    # Format output as specified: comma-separated list in brackets,\n    # with each value rounded to three decimal places.\n    formatted_results = [f'{r:.3f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2427929"}]}