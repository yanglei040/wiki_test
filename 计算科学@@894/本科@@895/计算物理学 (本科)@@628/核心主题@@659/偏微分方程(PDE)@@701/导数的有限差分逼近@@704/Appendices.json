{"hands_on_practices": [{"introduction": "在我们运用有限差分来解决复杂问题之前，必须首先验证我们的基本公式是否如理论所预测的那样有效。本练习旨在构建和测试核心工具——中心差分公式，并通过经验性实验来确认其二阶收敛精度 ($O(h^2)$) [@problem_id:2391581]。这是建立对数值方法信心的基础，也是掌握其强大功能的第一步。", "problem": "设计并实现一个完全可复现的数值实验，以经验性地验证用于求导的对称有限差分近似的精度阶。仅使用以下基础理论：一个足够光滑的函数在某一点的 Taylor 级数展开，以及一阶和二阶导数的极限定义。您的任务是：\n\n1. 对于一个光滑函数 $f(x)$，在点 $x_0$ 处使用步长 $h$，构建其一阶导数和二阶导数的对称中心有限差分近似。该近似必须使用在 $x_0 \\pm h$（对于二阶导数，还可选地使用 $x_0$）处计算的 $f$ 的值。不要假设或引用任何已有的误差公式；相反，您的推理应基于在 $x_0$ 点的 Taylor 级数展开，以证明预期的截断误差行为。\n\n2. 对于一个导数已知的给定函数 $f(x)$，定义在 $x_0$ 处的真实一阶导数 $f'(x)$ 和真实二阶导数 $f''(x)$。对于一个步长序列 $h_k = h_0/2^k, k = 0,1,\\dots,n-1$，计算绝对误差 $e_k = \\lvert A(h_k) - T \\rvert$，其中 $A(h_k)$ 是使用步长 $h_k$ 在 $x_0$ 处对目标导数的数值近似，而 $T$ 是相应的真实导数值。对于每对连续的误差，计算观测到的精度阶\n$$\np_k = \\log_2\\left( \\frac{e_k}{e_{k+1}} \\right).\n$$\n将加密序列中最后一个可用的 $p_k$（即对应于两个最小步长的那个）作为该测试用例的标量结果报告，该值经验性地近似了渐近阶。\n\n3. 将上述内容实现为一个完整的程序，运行以下测试套件。每个测试用例指定了目标导数阶数、一个函数 $f(x)$、一个求值点 $x_0$、一个初始步长 $h_0$ 以及加密次数 $n$。函数及其真实导数必须严格按照下面的规定进行处理。\n\n- 测试用例 1 (理想路径，一阶导数)：目标导数为 $f'(x)$，其中 $f(x) = \\sin(x)$，$x_0 = 0.37$ (弧度)，$h_0 = 0.2$，$n = 5$。\n- 测试用例 2 (不同光滑度特性，一阶导数)：目标导数为 $f'(x)$，其中 $f(x) = \\exp(\\sin(x))$，$x_0 = -0.8$ (弧度)，$h_0 = 0.2$，$n = 5$。使用精确恒等式 $f'(x) = \\exp(\\sin(x)) \\cos(x)$。\n- 测试用例 3 (理想路径，二阶导数)：目标导数为 $f''(x)$，其中 $f(x) = \\sin(x)$，$x_0 = 0.37$ (弧度)，$h_0 = 0.2$，$n = 5$。使用精确恒等式 $f''(x) = -\\sin(x)$。\n- 测试用例 4 (非平凡有理函数，二阶导数)：目标导数为 $f''(x)$，其中 $f(x) = \\frac{1}{1+x^2}$，$x_0 = 0.9$，$h_0 = 0.2$，$n = 5$。使用精确恒等式 $f''(x) = \\frac{6x^2 - 2}{(1+x^2)^3}$。\n- 测试用例 5 (函数值数量级大的边界情况，一阶导数)：目标导数为 $f'(x)$，其中 $f(x) = \\exp(x)$，$x_0 = 5.0$，$h_0 = 0.4$，$n = 5$。使用精确恒等式 $f'(x) = \\exp(x)$。\n\n4. 您的实现必须：\n- 对于目标 $f'(x)$，使用仅基于 $x_0 \\pm h$ 的对称中心模板。\n- 对于目标 $f''(x)$，使用仅基于 $x_0 \\pm h$ 和 $x_0$ 的对称中心模板。\n- 使用加密策略 $h_k = h_0/2^k$，其中 $k = 0,1,\\dots,n-1$。\n- 计算绝对误差和观测阶序列 $p_k$。\n- 对每个测试用例，返回序列中最后一个 $p_k$ 作为最终的标量结果。\n- 如果在最小尺度上误差值恰好为零，使用最近的非零相邻对来计算 $p_k$。\n\n5. 最终输出格式：\n您的程序应产生单行输出，其中包含用方括号括起来的结果，结果为逗号分隔的浮点数列表（例如，\"[r1,r2,r3,r4,r5]\"）。每个数字必须是相应测试用例的最终观测阶，并四舍五入到六位小数。\n\n角度必须以弧度为单位进行解释。本问题不涉及任何物理单位。预期结果是，一阶导数和二阶导数的对称格式的观测阶都接近于 $2$，这与和 $h^2$ 成正比的截断误差是一致的。", "solution": "该问题陈述是数值分析中一个有效、适定的练习。它在科学上基于 Taylor 级数和有限差分方法的理论，不包含任何矛盾，并提供了构建一个唯一的、可验证的解所需的所有信息。因此，我们将着手进行推导和实现。\n\n目标是推导一个足够光滑的函数 $f(x)$ 的一阶和二阶导数的对称有限差分公式，分析其截断误差，并通过数值实验经验性地验证其理论精度阶。\n\n首先，我们推导一阶导数 $f'(x)$ 的有限差分近似。设 $f(x)$ 至少是三阶连续可微的。$f(x)$ 在点 $x_0$ 附近，对于步长 $+h$ 和 $-h$ 的 Taylor 级数展开式由下式给出：\n$$\nf(x_0 + h) = f(x_0) + h f'(x_0) + \\frac{h^2}{2!} f''(x_0) + \\frac{h^3}{3!} f'''(x_0) + O(h^4) \\quad (1)\n$$\n$$\nf(x_0 - h) = f(x_0) - h f'(x_0) + \\frac{h^2}{2!} f''(x_0) - \\frac{h^3}{3!} f'''(x_0) + O(h^4) \\quad (2)\n$$\n从方程 $(1)$ 中减去方程 $(2)$，消去了 $h$ 的偶次幂项：\n$$\nf(x_0 + h) - f(x_0 - h) = 2h f'(x_0) + \\frac{2h^3}{6} f'''(x_0) + O(h^5)\n$$\n解出 $f'(x_0)$ 得：\n$$\nf'(x_0) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h} - \\frac{h^2}{6} f'''(x_0) + O(h^4)\n$$\n这给出了一阶导数的对称中心有限差分近似：\n$$\nA_{f'}(h) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h}\n$$\n因此，截断误差定义为近似值与真实值之差，$E_{trunc} = A_{f'}(h) - f'(x_0)$，为：\n$$\nE_{trunc} = -\\frac{h^2}{6} f'''(x_0) + O(h^4)\n$$\n误差的主项与 $h^2$ 成正比，这意味着该近似是二阶精度的。\n\n接下来，我们推导二阶导数 $f''(x)$ 的近似。设 $f(x)$ 至少是四阶连续可微的。将方程 $(1)$ 和 $(2)$ 相加，消去了 $h$ 的奇次幂项：\n$$\nf(x_0 + h) + f(x_0 - h) = 2f(x_0) + h^2 f''(x_0) + \\frac{2h^4}{24} f''''(x_0) + O(h^6)\n$$\n解出 $f''(x_0)$ 得：\n$$\nf''(x_0) = \\frac{f(x_0 + h) - 2f(x_0) + f(x_0 - h)}{h^2} - \\frac{h^2}{12} f''''(x_0) + O(h^4)\n$$\n这给出了二阶导数的对称中心有限差分近似：\n$$\nA_{f''}(h) = \\frac{f(x_0 + h) - 2f(x_0) + f(x_0 - h)}{h^2}\n$$\n该近似的截断误差为：\n$$\nE_{trunc} = -\\frac{h^2}{12} f''''(x_0) + O(h^4)\n$$\n误差的主项同样与 $h^2$ 成正比，所以该近似也是二阶精度的。\n\n为了经验性地验证精度阶，我们分析当步长 $h$ 被加密时绝对误差的行为。对于一个 $p$ 阶的近似，绝对误差 $e(h) = |A(h) - T|$（其中 $T$ 是真实的导数值）在 $h$ 足够小时表现为 $e(h) \\approx C h^p$，其中 $C$ 为某个常数。\n考虑一个步长序列 $h_k = h_0 / 2^k$，其中 $k=0, 1, 2, \\dots$。相应的误差为 $e_k = e(h_k)$ 和 $e_{k+1} = e(h_{k+1})$。连续误差之比为：\n$$\n\\frac{e_k}{e_{k+1}} \\approx \\frac{C h_k^p}{C h_{k+1}^p} = \\frac{C (h_0/2^k)^p}{C (h_0/2^{k+1})^p} = \\frac{(1/2^k)^p}{(1/2^{k+1})^p} = \\left(\\frac{2^{k+1}}{2^k}\\right)^p = 2^p\n$$\n通过取以 2 为底的对数，我们可以计算观测到的精度阶 $p_k$：\n$$\np_k = \\log_2\\left(\\frac{e_k}{e_{k+1}}\\right)\n$$\n随着 $k$ 的增加，$h_k$ 减小，$p_k$ 应收敛于理论阶 $p$。对于我们推导的二阶格式，我们预期 $p_k \\to 2$。\n\n该数值实验按以下方式实现。对于每个测试用例：\n1.  生成一个包含 $n$ 个步长的序列：$h_k = h_0 / 2^k$，其中 $k=0, \\dots, n-1$。\n2.  在点 $x_0$ 处计算导数的真实值 $T$。\n3.  对于每个步长 $h_k$，使用一阶或二阶导数公式计算相应的数值近似值 $A(h_k)$。\n4.  计算一个绝对误差序列：$e_k = |A(h_k) - T|$。\n5.  计算一个观测阶序列：$p_k = \\log_2(e_k / e_{k+1})$，其中 $k=0, \\dots, n-2$。\n6.  结果是最后一个有效计算出的阶 $p_{n-2}$，它对应于两个最小步长 $h_{n-2}$ 和 $h_{n-1}$ 之间的比较。这提供了对渐近精度阶的一个经验估计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a numerical experiment to verify the order of accuracy\n    of symmetric finite difference approximations for first and second derivatives.\n    \"\"\"\n\n    # Define the functions, their true derivatives, and parameters for each test case.\n    test_cases = [\n        {\n            # Test case 1: f'(x) for sin(x)\n            \"target_order\": 1,\n            \"f\": lambda x: np.sin(x),\n            \"true_deriv_func\": lambda x: np.cos(x),\n            \"x0\": 0.37,\n            \"h0\": 0.2,\n            \"n\": 5,\n        },\n        {\n            # Test case 2: f'(x) for exp(sin(x))\n            \"target_order\": 1,\n            \"f\": lambda x: np.exp(np.sin(x)),\n            \"true_deriv_func\": lambda x: np.exp(np.sin(x)) * np.cos(x),\n            \"x0\": -0.8,\n            \"h0\": 0.2,\n            \"n\": 5,\n        },\n        {\n            # Test case 3: f''(x) for sin(x)\n            \"target_order\": 2,\n            \"f\": lambda x: np.sin(x),\n            \"true_deriv_func\": lambda x: -np.sin(x),\n            \"x0\": 0.37,\n            \"h0\": 0.2,\n            \"n\": 5,\n        },\n        {\n            # Test case 4: f''(x) for 1/(1+x^2)\n            \"target_order\": 2,\n            \"f\": lambda x: 1.0 / (1.0 + x**2),\n            \"true_deriv_func\": lambda x: (6.0 * x**2 - 2.0) / (1.0 + x**2)**3,\n            \"x0\": 0.9,\n            \"h0\": 0.2,\n            \"n\": 5,\n        },\n        {\n            # Test case 5: f'(x) for exp(x) with large function magnitude\n            \"target_order\": 1,\n            \"f\": lambda x: np.exp(x),\n            \"true_deriv_func\": lambda x: np.exp(x),\n            \"x0\": 5.0,\n            \"h0\": 0.4,\n            \"n\": 5,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        target_order = case[\"target_order\"]\n        f = case[\"f\"]\n        true_deriv_func = case[\"true_deriv_func\"]\n        x0 = case[\"x0\"]\n        h0 = case[\"h0\"]\n        n = case[\"n\"]\n\n        # Calculate the true value of the derivative\n        true_value = true_deriv_func(x0)\n\n        # Generate step sizes and compute errors\n        errors = []\n        for k in range(n):\n            h = h0 / (2**k)\n            \n            if target_order == 1:\n                # Symmetric centered difference for the first derivative\n                approx_val = (f(x0 + h) - f(x0 - h)) / (2.0 * h)\n            elif target_order == 2:\n                # Symmetric centered difference for the second derivative\n                approx_val = (f(x0 + h) - 2.0 * f(x0) + f(x0 - h)) / (h**2)\n            else:\n                # This case should not be reached based on the problem statement\n                raise ValueError(\"Invalid target derivative order.\")\n\n            # Compute and store the absolute error\n            errors.append(np.abs(approx_val - true_value))\n\n        # Compute observed orders of accuracy\n        observed_orders = []\n        for k in range(n - 1):\n            e_k = errors[k]\n            e_k_plus_1 = errors[k + 1]\n            \n            # Ensure errors are non-zero to avoid division by zero\n            # or log of zero. This also handles the specified edge case.\n            if e_k > 0 and e_k_plus_1 > 0:\n                p_k = np.log2(e_k / e_k_plus_1)\n                observed_orders.append(p_k)\n\n        # The result for the test case is the last available observed order\n        if observed_orders:\n            final_p = observed_orders[-1]\n        else:\n            # Handle case where no valid order could be computed (e.g., all errors are zero)\n            # For this problem set, this fallback is not expected to be needed.\n            final_p = np.nan\n            \n        results.append(final_p)\n\n    # Format the final output as a comma-separated list of numbers rounded to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2391581"}, {"introduction": "理论上的精确性在面对现实世界的数据时会遇到挑战。本实践将引导您进行一次“现实检验”，探讨数值微分一个至关重要且常常出人意料的特性：它对噪声的敏感性 [@problem_id:2392343]。通过从一个带噪的模拟位置信号中估计速度和加速度，您将亲手量化噪声放大效应，并深刻理解在减小截断误差与控制测量误差之间的关键权衡。", "problem": "给你一个一维位置随时间变化的时间序列模型，其中包含附加的测量噪声。该位置是一个光滑、已知的时间函数，并在每个样本上叠加了零均值、独立的噪声。你的任务是设计并实现一个程序，该程序针对一组测试用例，构建带噪声的位置数据，使用有限差分法估计速度和加速度，并定量分析微分算子对测量噪声的放大作用。\n\n你的推理必须仅基于以下基本定义和事实：函数的导数是差商的极限；线性算子作用于独立随机变量时，其输出的方差根据算子权重的平方和进行累加；可以使用泰勒级数展开来推导有限差分模板的局部截断误差阶。除这些原则外，不得使用任何其他预先包装好的公式。\n\n使用以下信号模型。无噪声的位置为\n$$\nx(t) = A \\sin(2\\pi f_1 t) + C \\sin(2\\pi f_2 t) + D t^2,\n$$\n参数为\n$$\nA = 1.0\\ \\text{m},\\quad C = 0.5\\ \\text{m},\\quad f_1 = 1.0\\ \\text{Hz},\\quad f_2 = 3.0\\ \\text{Hz},\\quad D = 0.05\\ \\text{m/s}^2.\n$$\n三角函数中的角度以弧度为单位。精确的速度和加速度分别为，\n$$\nv(t) = \\frac{dx}{dt} = 2\\pi f_1 A \\cos(2\\pi f_1 t) + 2\\pi f_2 C \\cos(2\\pi f_2 t) + 2 D t,\n$$\n$$\na(t) = \\frac{d^2 x}{dt^2} = - (2\\pi f_1)^2 A \\sin(2\\pi f_1 t) - (2\\pi f_2)^2 C \\sin(2\\pi f_2 t) + 2 D.\n$$\n\n采样和噪声模型。对于每个测试用例，在以下时间点进行均匀采样\n$$\nt_n = n \\,\\Delta t,\\quad n=0,1,\\dots,N-1,\\quad N = \\left\\lfloor \\frac{T}{\\Delta t}\\right\\rfloor + 1,\\quad T = 10\\ \\text{s},\n$$\n并形成带噪声的测量值\n$$\nx_n^{\\text{noisy}} = x(t_n) + \\eta_n,\\quad \\eta_n \\sim \\mathcal{N}(0,\\sigma_x^2)\\ \\text{i.i.d.},\n$$\n为了可复现性，使用固定的随机种子 $12345$。所有距离单位为米，时间单位为秒。\n\n有限差分要求。从第一性原理出发，推导并实现用于一阶和二阶导数的二阶精度有限差分格式，具体如下：\n- 对于内部点，使用中心、二阶精度的模板。\n- 在两个边界处，使用单侧、二阶精度的模板。\n你的实现必须生成与输入 $x_n$ 长度相同的数组 $v_n^{\\text{FD}}$ 和 $a_n^{\\text{FD}}$。\n\n噪声放大分析。设在索引 $i$ 处的有限差分导数是线性组合\n$$\ny_i = \\sum_{j} w_{i,j} x_j,\n$$\n其中 $y_i$ 表示一阶或二阶导数估计值，$w_{i,j}$ 是有限差分权重除以 $\\Delta t$ 的适当幂次。仅使用期望的线性性质和噪声样本的独立性，推导并计算：\n- 一阶导数的经验均方根（RMS）噪声放大：\n$$\ng_v^{\\text{emp}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( v_i^{\\text{FD}}[x^{\\text{noisy}}] - v_i^{\\text{FD}}[x^{\\text{clean}}]\\right)^2 },\n$$\n以及二阶导数的经验均方根（RMS）噪声放大：\n$$\ng_a^{\\text{emp}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( a_i^{\\text{FD}}[x^{\\text{noisy}}] - a_i^{\\text{FD}}[x^{\\text{clean}}]\\right)^2 }.\n$$\n- 由权重预测的理论RMS噪声放大：\n$$\ng^{\\text{theory}} = \\sigma_x \\sqrt{ \\frac{1}{N} \\sum_{i=0}^{N-1} \\left( \\sum_{j} w_{i,j}^2 \\right) }.\n$$\n使用每个索引处（包括边界模板）的实际权重计算 $g_v^{\\text{theory}}$ 和 $g_a^{\\text{theory}}$。\n\n性能指标。对于每个测试用例，计算：\n- 速度估计值相对于精确速度的RMS误差：\n$$\nE_v = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( v_i^{\\text{FD}}[x^{\\text{noisy}}] - v(t_i) \\right)^2 } \\ \\text{in m/s}.\n$$\n- 加速度估计值相对于精确加速度的RMS误差：\n$$\nE_a = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( a_i^{\\text{FD}}[x^{\\text{noisy}}] - a(t_i) \\right)^2 } \\ \\text{in m/s}^2.\n$$\n- 比率\n$$\nR_v = \\frac{ g_v^{\\text{emp}} }{ g_v^{\\text{theory}} },\n$$\n$$\nR_a = \\frac{ g_a^{\\text{emp}} }{ g_a^{\\text{theory}} },\n$$\n这些比率表明经验噪声放大与理论预测的匹配程度。\n\n测试套件。在以下四个测试用例上运行你的程序，这些用例的采样间隔和噪声水平不同：\n- 用例1：$\\Delta t = 0.01\\ \\text{s}$，$\\sigma_x = 0.001\\ \\text{m}$。\n- 用例2：$\\Delta t = 0.1\\ \\text{s}$，$\\sigma_x = 0.001\\ \\text{m}$。\n- 用例3：$\\Delta t = 0.01\\ \\text{s}$，$\\sigma_x = 0.01\\ \\text{m}$。\n- 用例4：$\\Delta t = 0.001\\ \\text{s}$，$\\sigma_x = 0.001\\ \\text{m}$。\n\n最终输出格式。你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的聚合结果。对于从1到4的每个用例，按以下顺序附加四个浮点数：$E_v$（单位 m/s）、$E_a$（单位 m/s$^2$）、$R_v$（无量纲）、$R_a$（无量纲）。每个数字必须以科学记数法打印，并保留恰好六位有效数字。例如，总的输出格式为\n$$\n[\\ E_{v,1},\\ E_{a,1},\\ R_{v,1},\\ R_{a,1},\\ E_{v,2},\\ E_{a,2},\\ R_{v,2},\\ R_{a,2},\\ E_{v,3},\\ E_{a,3},\\ R_{v,3},\\ R_{a,3},\\ E_{v,4},\\ E_{a,4},\\ R_{v,4},\\ R_{a,4}\\ ].\n$$", "solution": "我们从第一性原理开始。函数 $x(t)$ 在时间 $t$ 的一阶导数由以下极限定义\n$$\n\\frac{dx}{dt}(t) = \\lim_{\\Delta t \\to 0} \\frac{x(t+\\Delta t) - x(t-\\Delta t)}{2\\Delta t},\n$$\n这表明对于有限但较小的 $\\Delta t$，应使用对称（中心）差商。二阶导数定义为\n$$\n\\frac{d^2x}{dt^2}(t) = \\lim_{\\Delta t \\to 0} \\frac{x(t+\\Delta t) - 2x(t) + x(t-\\Delta t)}{\\Delta t^2}.\n$$\n使用在 $t_i = i \\Delta t$ 附近的泰勒级数展开，\n$$\nx(t_{i\\pm 1}) = x(t_i) \\pm \\Delta t\\, x'(t_i) + \\frac{\\Delta t^2}{2} x''(t_i) \\pm \\frac{\\Delta t^3}{6} x^{(3)}(t_i) + \\frac{\\Delta t^4}{24} x^{(4)}(t_i) + \\mathcal{O}(\\Delta t^5),\n$$\n我们可以为内部点推导出二阶精度的中心模板：\n$$\nx'(t_i) = \\frac{x_{i+1} - x_{i-1}}{2\\Delta t} + \\mathcal{O}(\\Delta t^2),\n$$\n$$\nx''(t_i) = \\frac{x_{i+1} - 2 x_i + x_{i-1}}{\\Delta t^2} + \\mathcal{O}(\\Delta t^2),\n$$\n其中 $x_i = x(t_i)$。在边界处，无法构建对称差分；作为替代，使用前向点的泰勒展开可以得到单侧、二阶精度的模板。对于左边界 $i=0$ 处的一阶导数，\n$$\nx'(t_0) = \\frac{-3 x_0 + 4 x_1 - x_2}{2\\Delta t} + \\mathcal{O}(\\Delta t^2),\n$$\n类似地，对于右边界 $i=N-1$，\n$$\nx'(t_{N-1}) = \\frac{3 x_{N-1} - 4 x_{N-2} + x_{N-3}}{2\\Delta t} + \\mathcal{O}(\\Delta t^2).\n$$\n对于二阶导数，前向和后向的二阶精度单侧模板为\n$$\nx''(t_0) = \\frac{2 x_0 - 5 x_1 + 4 x_2 - x_3}{\\Delta t^2} + \\mathcal{O}(\\Delta t^2),\n$$\n$$\nx''(t_{N-1}) = \\frac{2 x_{N-1} - 5 x_{N-2} + 4 x_{N-3} - x_{N-4}}{\\Delta t^2} + \\mathcal{O}(\\Delta t^2).\n$$\n这些公式是通过求解方程组得到的，该方程组逐项匹配泰勒展开式以消除低阶误差项，从而确保二阶精度。\n\n噪声放大分析基于线性性质。设将 $\\{x_j\\}$ 映射到导数估计值 $\\{y_i\\}$ 的有限差分算子是线性的：\n$$\ny_i = \\sum_{j} w_{i,j} x_j,\n$$\n其中 $w_{i,j}$ 是算子权重，包括由导数阶数决定的、按 $\\Delta t$ 的适当幂次进行的归一化。假设测量值包含附加的零均值、独立噪声 $\\eta_j$，其方差为 $\\mathbb{V}[\\eta_j] = \\sigma_x^2$。根据线性和独立性，\n$$\n\\mathbb{E}[y_i] = \\sum_{j} w_{i,j} \\mathbb{E}[x_j],\n$$\n$$\n\\mathbb{V}[y_i] = \\sum_{j} w_{i,j}^2 \\,\\mathbb{V}[\\eta_j] = \\sigma_x^2 \\sum_{j} w_{i,j}^2.\n$$\n因此，在索引 $i$ 处噪声分量的均方根（RMS）等于\n$$\n\\sqrt{\\mathbb{V}[y_i]} = \\sigma_x \\sqrt{\\sum_{j} w_{i,j}^2}.\n$$\n在所有索引上计算的全局RMS，与实践中使用的经验RMS一致，其形式为\n$$\ng^{\\text{theory}} = \\sigma_x \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left(\\sum_{j} w_{i,j}^2\\right)}.\n$$\n该表达式通过依赖于索引的权重自然地包含了边界效应。\n\n由此得出两个推论：\n- 对于一阶导数，权重与 $1/\\Delta t$ 成比例，因此 $g_v^{\\text{theory}} \\propto \\sigma_x/\\Delta t$；也就是说，如果每个样本的位置噪声水平固定，减小 $\\Delta t$ 会增加速度估计中的噪声放大。\n- 对于二阶导数，权重与 $1/\\Delta t^2$ 成比例，因此 $g_a^{\\text{theory}} \\propto \\sigma_x/\\Delta t^2$，这意味着噪声被更强烈地放大。\n\n经验均方根（RMS）噪声放大可以通过比较应用于带噪声数据和纯净数据的微分算子来分离，这样做可以消除确定性的截断误差：\n$$\ng^{\\text{emp}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( y_i[x^{\\text{noisy}}] - y_i[x^{\\text{clean}}] \\right)^2 }.\n$$\n由于 $y_i[\\cdot]$ 是线性的且 $x^{\\text{noisy}} = x^{\\text{clean}} + \\eta$，其差值等于 $y_i[\\eta]$，在大量样本的极限下，其RMS与上面推导的理论表达式相匹配。因此，比率\n$$\nR_v = \\frac{g_v^{\\text{emp}}}{g_v^{\\text{theory}}},\n$$\n$$\nR_a = \\frac{g_a^{\\text{emp}}}{g_a^{\\text{theory}}},\n$$\n当经验平均值具有代表性时，应接近于1。\n\n算法设计：\n- 构建时间样本 $t_i = i \\Delta t$，$i=0,\\dots,N-1$，$T=10$ 秒。\n- 根据给定的解析表达式计算纯净位置 $x(t_i)$、精确速度 $v(t_i)$ 和精确加速度 $a(t_i)$。\n- 使用固定种子生成附加噪声 $\\eta_i \\sim \\mathcal{N}(0,\\sigma_x^2)$ 以确保可复现性，并构成 $x^{\\text{noisy}}_i = x(t_i) + \\eta_i$。\n- 实现用于一阶和二阶导数的二阶精度有限差分估计器，其在内部应用中心模板，在边界应用单侧模板，从而为纯净和带噪声的输入生成 $v^{\\text{FD}}$ 和 $a^{\\text{FD}}$。\n- 计算性能指标：将 $E_v$ 和 $E_a$ 计算为与精确导数相比的RMS误差。将 $g_v^{\\text{emp}}$ 和 $g_a^{\\text{emp}}$ 计算为在带噪声和纯净数据上有限差分输出之间的RMS差异。通过在每个索引处对权重的平方求和并取平均，然后乘以 $\\sigma_x$ 并开方，来计算 $g_v^{\\text{theory}}$ 和 $g_a^{\\text{theory}}$。最后，计算 $R_v$ 和 $R_a$ 作为经验放大与理论放大的比率。\n- 对四个指定的测试用例重复上述步骤。以要求的单行、括号内、逗号分隔的列表形式打印合并结果，使用科学记数法并保留六位有效数字。\n\n预期趋势：\n- 将 $\\sigma_x$ 增加10倍，应该会使 $g^{\\text{emp}}$ 以及 $E_v$ 和 $E_a$ 中由噪声主导的分量增加10倍。\n- 增加 $\\Delta t$ 应该会使 $g_v^{\\text{theory}}$ 大致按 $1/\\Delta t$ 的比例减小，使 $g_a^{\\text{theory}}$ 大致按 $1/\\Delta t^2$ 的比例减小；然而，截断误差以 $\\mathcal{O}(\\Delta t^2)$ 的速度增长，因此由于截断误差和噪声放大之间的权衡，$E_v$ 和 $E_a$ 可能不会随 $\\Delta t$ 的增加而单调减小。\n- 比率 $R_v$ 和 $R_a$ 应接近1，从而验证线性噪声放大分析的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef position(t, A=1.0, C=0.5, f1=1.0, f2=3.0, D=0.05):\n    # x(t) in meters\n    return A * np.sin(2*np.pi*f1*t) + C * np.sin(2*np.pi*f2*t) + D * t**2\n\ndef velocity_true(t, A=1.0, C=0.5, f1=1.0, f2=3.0, D=0.05):\n    # v(t) in m/s\n    return 2*np.pi*f1*A * np.cos(2*np.pi*f1*t) + 2*np.pi*f2*C * np.cos(2*np.pi*f2*t) + 2*D*t\n\ndef acceleration_true(t, A=1.0, C=0.5, f1=1.0, f2=3.0, D=0.05):\n    # a(t) in m/s^2\n    return -(2*np.pi*f1)**2 * A * np.sin(2*np.pi*f1*t) - (2*np.pi*f2)**2 * C * np.sin(2*np.pi*f2*t) + 2*D\n\ndef fd_first_derivative(x, dt):\n    \"\"\"\n    Second-order accurate finite difference for first derivative.\n    - One-sided 3-point at boundaries (order 2).\n    - Centered 3-point in interior (order 2).\n    Returns y of same length as x.\n    \"\"\"\n    n = x.size\n    y = np.empty_like(x, dtype=float)\n    if n  3:\n        raise ValueError(\"Need at least 3 points for second-order first derivative\")\n    # Left boundary: (-3 x0 + 4 x1 - x2)/(2 dt)\n    y[0] = (-3.0*x[0] + 4.0*x[1] - 1.0*x[2]) / (2.0*dt)\n    # Interior\n    y[1:-1] = (x[2:] - x[:-2]) / (2.0*dt)\n    # Right boundary: (3 xN-1 - 4 xN-2 + xN-3)/(2 dt)\n    y[-1] = (3.0*x[-1] - 4.0*x[-2] + 1.0*x[-3]) / (2.0*dt)\n    return y\n\ndef fd_second_derivative(x, dt):\n    \"\"\"\n    Second-order accurate finite difference for second derivative.\n    - One-sided 4-point at boundaries (order 2).\n    - Centered 3-point in interior (order 2).\n    Returns y of same length as x.\n    \"\"\"\n    n = x.size\n    y = np.empty_like(x, dtype=float)\n    if n  4:\n        raise ValueError(\"Need at least 4 points for second derivative with second-order accuracy\")\n    # Left boundary: (2 x0 - 5 x1 + 4 x2 - x3)/dt^2\n    y[0] = (2.0*x[0] - 5.0*x[1] + 4.0*x[2] - 1.0*x[3]) / (dt*dt)\n    # Interior\n    y[1:-1] = (x[2:] - 2.0*x[1:-1] + x[:-2]) / (dt*dt)\n    # Right boundary: (2 xN-1 - 5 xN-2 + 4 xN-3 - xN-4)/dt^2\n    y[-1] = (2.0*x[-1] - 5.0*x[-2] + 4.0*x[-3] - 1.0*x[-4]) / (dt*dt)\n    return y\n\ndef weights_sqsum_first(n, dt):\n    \"\"\"\n    For each index i, compute sum_j w_{i,j}^2 for the first derivative operator.\n    Returns an array s of length n with s[i] = sum_j w_{i,j}^2.\n    \"\"\"\n    s = np.zeros(n, dtype=float)\n    inv = 1.0 / (2.0*dt)\n    # Left boundary: (-3, 4, -1)/(2 dt)\n    coeffs = np.array([-3.0, 4.0, -1.0]) * inv\n    s[0] = np.sum(coeffs**2)\n    # Interior: [-1, +1] at i-1 and i+1\n    c = np.array([-1.0, 1.0]) * inv\n    val = np.sum(c**2)\n    s[1:-1] = val\n    # Right boundary: (1, -4, 3)/(2 dt) applied to (i-2, i-1, i)\n    coeffs = np.array([1.0, -4.0, 3.0]) * inv\n    s[-1] = np.sum(coeffs**2)\n    return s\n\ndef weights_sqsum_second(n, dt):\n    \"\"\"\n    For each index i, compute sum_j w_{i,j}^2 for the second derivative operator.\n    Returns an array s of length n with s[i] = sum_j w_{i,j}^2.\n    \"\"\"\n    s = np.zeros(n, dtype=float)\n    inv2 = 1.0 / (dt*dt)\n    # Left boundary: (2, -5, 4, -1)/dt^2\n    coeffs = np.array([2.0, -5.0, 4.0, -1.0]) * inv2\n    s[0] = np.sum(coeffs**2)\n    # Interior: (1, -2, 1)/dt^2\n    c = np.array([1.0, -2.0, 1.0]) * inv2\n    val = np.sum(c**2)\n    s[1:-1] = val\n    # Right boundary: (-1, 4, -5, 2)/dt^2 applied to (i-3, i-2, i-1, i)\n    coeffs = np.array([-1.0, 4.0, -5.0, 2.0]) * inv2\n    s[-1] = np.sum(coeffs**2)\n    return s\n\ndef rms(x):\n    return np.sqrt(np.mean(np.square(x)))\n\ndef format_float(x):\n    # Scientific notation with exactly six significant figures\n    return f\"{x:.6e}\"\n\ndef run_case(dt, sigma_x, rng):\n    T = 10.0\n    N = int(np.floor(T/dt)) + 1\n    t = np.linspace(0.0, dt*(N-1), N)\n    x_clean = position(t)\n    # Generate noise with given sigma\n    noise = rng.normal(loc=0.0, scale=sigma_x, size=N)\n    x_noisy = x_clean + noise\n\n    # True derivatives\n    v_true = velocity_true(t)\n    a_true = acceleration_true(t)\n\n    # Finite difference estimates\n    v_fd_clean = fd_first_derivative(x_clean, dt)\n    a_fd_clean = fd_second_derivative(x_clean, dt)\n    v_fd_noisy = fd_first_derivative(x_noisy, dt)\n    a_fd_noisy = fd_second_derivative(x_noisy, dt)\n\n    # RMS errors against exact\n    E_v = rms(v_fd_noisy - v_true)\n    E_a = rms(a_fd_noisy - a_true)\n\n    # Empirical noise amplification (difference noisy-clean)\n    g_v_emp = rms(v_fd_noisy - v_fd_clean)\n    g_a_emp = rms(a_fd_noisy - a_fd_clean)\n\n    # Theoretical noise amplification from weights\n    s1 = weights_sqsum_first(N, dt)\n    s2 = weights_sqsum_second(N, dt)\n    g_v_theory = sigma_x * np.sqrt(np.mean(s1))\n    g_a_theory = sigma_x * np.sqrt(np.mean(s2))\n\n    # Ratios (avoid division by zero, though here not zero)\n    R_v = g_v_emp / g_v_theory if g_v_theory > 0 else np.nan\n    R_a = g_a_emp / g_a_theory if g_a_theory > 0 else np.nan\n\n    return E_v, E_a, R_v, R_a\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (dt [s], sigma_x [m])\n    test_cases = [\n        (0.01, 0.001),   # Case 1\n        (0.1, 0.001),    # Case 2\n        (0.01, 0.01),    # Case 3\n        (0.001, 0.001),  # Case 4\n    ]\n\n    rng = np.random.default_rng(12345)\n\n    results = []\n    for dt, sigma_x in test_cases:\n        E_v, E_a, R_v, R_a = run_case(dt, sigma_x, rng)\n        results.extend([E_v, E_a, R_v, R_a])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(format_float(x) for x in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2392343"}, {"introduction": "掌握了导数近似的基础知识及其在含噪数据中的表现后，我们便可以将这些工具应用于求解描述物理系统的偏微分方程。平流-扩散方程是流体动力学和输运现象中的一个基本模型。通过本练习，您将比较中心差分、上风格式和下风格式在求解该方程时的表现，从而揭示不同离散格式的选择如何深刻影响数值解的稳定性与物理真实性 [@problem_id:2392370]。", "problem": "考虑一维线性平流-扩散偏微分方程 (PDE)\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = \\nu\\,\\partial_{xx} u(x,t),\n$$\n该方程定义在周期性域 $x \\in [0,1)$ 上，周期为 $1$，其中 $a0$ 是恒定的平流速度，$\\nu \\ge 0$ 是恒定的扩散系数。设初始条件为\n$$\nu(x,0) = \\sin\\!\\big(2\\pi k\\,x\\big),\n$$\n其中波数 $k \\ge 1$ 为整数，角度以弧度为单位。\n\n使用一个包含 $N$ 个点的均匀周期性网格对空间进行离散化，网格间距为 $\\Delta x = 1/N$，网格节点为 $x_i = i\\,\\Delta x$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。对于一个网格函数 $\\mathbf{u} = (u_0,\\dots,u_{N-1})^\\top$，定义空间一阶和二阶导数的周期性有限差分算子如下：\n$$\n(\\mathrm{D}^{\\mathrm{C}} \\mathbf{u})_i = \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x},\\quad\n(\\mathrm{D}^{\\mathrm{U}} \\mathbf{u})_i = \\frac{u_i - u_{i-1}}{\\Delta x},\\quad\n(\\mathrm{D}^{\\mathrm{D}} \\mathbf{u})_i = \\frac{u_{i+1} - u_i}{\\Delta x},\n$$\n和\n$$\n(\\mathrm{D}^{(2)} \\mathbf{u})_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2},\n$$\n其中索引采用周期性规则，即 $u_{-1} \\equiv u_{N-1}$ 且 $u_{N} \\equiv u_0$。对于每种平流近似 $\\mathrm{D}^{\\bullet} \\in \\{\\mathrm{D}^{\\mathrm{C}}, \\mathrm{D}^{\\mathrm{U}}, \\mathrm{D}^{\\mathrm{D}}\\}$，定义相应的半离散空间算子\n$$\n\\mathbf{L}^{(\\bullet)} = -a\\,\\mathrm{D}^{\\bullet} + \\nu\\,\\mathrm{D}^{(2)}.\n$$\n通过矩阵指数对半离散系统进行精确的时间演化，使得\n$$\n\\mathbf{u}^{(\\bullet)}(T) = \\exp\\!\\big( T\\,\\mathbf{L}^{(\\bullet)} \\big)\\,\\mathbf{u}(0),\n$$\n其中 $\\mathbf{u}(0)$ 是采样得到的初始条件 $\\big(\\sin(2\\pi k x_i)\\big)_{i=0}^{N-1}$，$\\exp$ 表示矩阵指数。偏微分方程在网格节点上的精确解为\n$$\nu_{\\text{exact}}(x_i,T) = \\exp\\!\\big( -\\nu\\,(2\\pi k)^2\\,T \\big)\\,\\sin\\!\\big( 2\\pi k\\,(x_i - a\\,T) \\big).\n$$\n对于每种平流近似，计算在时间 $T$ 的离散 $\\ell^2$ 误差，\n$$\nE^{(\\bullet)} = \\left( \\Delta x \\sum_{i=0}^{N-1} \\big(u^{(\\bullet)}_i(T) - u_{\\text{exact}}(x_i,T)\\big)^2 \\right)^{1/2}.\n$$\n\n您的程序必须对以下四个测试用例（角度以弧度为单位）中的每一个，评估三元组 $\\big(E^{(\\mathrm{C})}, E^{(\\mathrm{U})}, E^{(\\mathrm{D})}\\big)$：\n\n- 用例 1：$N=64$, $a=1$, $\\nu=0.01$, $T=0.1$, $k=1$。\n- 用例 2：$N=64$, $a=1$, $\\nu=0.0005$, $T=0.05$, $k=1$。\n- 用例 3：$N=32$, $a=1$, $\\nu=0.1$, $T=0.1$, $k=1$。\n- 用例 4：$N=64$, $a=1$, $\\nu=0.01$, $T=0.1$, $k=3$。\n\n最终输出格式要求为单行，包含一个由 $12$ 个浮点数组成的扁平列表，排序如下\n$$\n\\big[E^{(\\mathrm{C})}_{1}, E^{(\\mathrm{U})}_{1}, E^{(\\mathrm{D})}_{1}, E^{(\\mathrm{C})}_{2}, E^{(\\mathrm{U})}_{2}, E^{(\\mathrm{D})}_{2}, E^{(\\mathrm{C})}_{3}, E^{(\\mathrm{U})}_{3}, E^{(\\mathrm{D})}_{3}, E^{(\\mathrm{C})}_{4}, E^{(\\mathrm{U})}_{4}, E^{(\\mathrm{D})}_{4}\\big],\n$$\n其中下标表示测试用例的索引。每个数字必须四舍五入到小数点后恰好 $8$ 位，并以十进制小数表示。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$\\big[0.12345678,0.00000000,\\dots\\big]$）。", "solution": "问题陈述已经过严格审查，并被确定为有效。这是一个在计算物理学领域内提法恰当、有科学依据的问题，涉及偏微分方程的数值解。所有常数、变量、边界条件和方法都有精确的定义，并且相互一致。\n\n该问题要求计算一维线性平流-扩散方程中平流项的三种不同有限差分近似的数值误差：\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = \\nu\\,\\partial_{xx} u(x,t)\n$$\n空间域为 $x \\in [0,1)$，具有周期性边界条件。求解过程首先是在一个由 $N$ 个点 $x_i = i\\,\\Delta x$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$，$\\Delta x = 1/N$）组成的均匀网格上对空间导数进行离散化。这种半离散化将偏微分方程转换为一个由 $N$ 个耦合常微分方程 (ODE) 组成的系统：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}^{(\\bullet)}\\mathbf{u}(t)\n$$\n其中 $\\mathbf{u}(t)$ 是网格点上解值的向量，$\\mathbf{L}^{(\\bullet)}$ 是给定平流格式 $(\\bullet) \\in \\{\\mathrm{C}, \\mathrm{U}, \\mathrm{D}\\}$ 的空间算子的矩阵表示。问题要求对该 ODE 系统进行精确的时间积分，这通过使用矩阵指数来实现：\n$$\n\\mathbf{u}(T) = \\exp(T\\,\\mathbf{L}^{(\\bullet)})\\,\\mathbf{u}(0)\n$$\n任务的核心是为算子构建矩阵，计算在时间 $T$ 的解，并根据给定的解析解评估离散 $\\ell^2$ 误差。\n\n每个测试用例的处理流程如下：\n\n1.  **算子的矩阵表示**：有限差分算子表示为作用于网格函数向量 $\\mathbf{u} = (u_0, \\dots, u_{N-1})^\\top$ 的 $N \\times N$ 矩阵。由于存在周期性边界条件，这些矩阵是循环矩阵。\n\n    - 二阶导数算子 $(\\mathrm{D}^{(2)} \\mathbf{u})_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2}$ 由一个矩阵 $\\mathbf{M}^{(2)}$ 表示，其元素为：\n      $$\n      \\mathbf{M}^{(2)}_{i,j} = \\frac{1}{\\Delta x^2} \\begin{cases} -2  \\text{若 } j=i \\\\ 1  \\text{若 } j = (i \\pm 1) \\pmod N \\\\ 0  \\text{其他情况} \\end{cases}\n      $$\n\n    - 中心差分一阶导数算子 $(\\mathrm{D}^{\\mathrm{C}} \\mathbf{u})_i = \\frac{u_{i+1} - u_{i-1}}{2\\Delta x}$ 由一个矩阵 $\\mathbf{M}^{(\\mathrm{C})}$ 表示：\n      $$\n      \\mathbf{M}^{(\\mathrm{C})}_{i,j} = \\frac{1}{2\\Delta x} \\begin{cases} 1  \\text{若 } j = (i+1) \\pmod N \\\\ -1  \\text{若 } j = (i-1) \\pmod N \\\\ 0  \\text{其他情况} \\end{cases}\n      $$\n\n    - 上风差分算子 $(\\mathrm{D}^{\\mathrm{U}} \\mathbf{u})_i = \\frac{u_i - u_{i-1}}{\\Delta x}$ 由一个矩阵 $\\mathbf{M}^{(\\mathrm{U})}$ 表示：\n      $$\n      \\mathbf{M}^{(\\mathrm{U})}_{i,j} = \\frac{1}{\\Delta x} \\begin{cases} 1  \\text{若 } j=i \\\\ -1  \\text{若 } j = (i-1) \\pmod N \\\\ 0  \\text{其他情况} \\end{cases}\n      $$\n\n    - 下风差分算子 $(\\mathrm{D}^{\\mathrm{D}} \\mathbf{u})_i = \\frac{u_{i+1} - u_i}{\\Delta x}$ 由一个矩阵 $\\mathbf{M}^{(\\mathrm{D})}$ 表示：\n      $$\n      \\mathbf{M}^{(\\mathrm{D})}_{i,j} = \\frac{1}{\\Delta x} \\begin{cases} -1  \\text{若 } j=i \\\\ 1  \\text{若 } j = (i+1) \\pmod N \\\\ 0  \\text{其他情况} \\end{cases}\n      $$\n\n2.  **半离散系统的构建**：对于每种平流格式 $(\\bullet)$，组装完整的半离散算子矩阵 $\\mathbf{L}^{(\\bullet)}$：\n    $$\n    \\mathbf{L}^{(\\bullet)} = -a\\,\\mathbf{M}^{(\\bullet)} + \\nu\\,\\mathbf{M}^{(2)}\n    $$\n    其中 $\\mathbf{M}^{(\\bullet)}$ 是 $\\mathbf{M}^{(\\mathrm{C})}$、$\\mathbf{M}^{(\\mathrm{U})}$ 或 $\\mathbf{M}^{(\\mathrm{D})}$ 之一。\n\n3.  **数值解与误差计算**：对于由参数 $(N, a, \\nu, T, k)$ 定义的每个测试用例：\n    - 定义网格点 $x_i = i/N$，其中 $i \\in \\{0, \\dots, N-1\\}$。\n    - 从初始函数 $u(x,0) = \\sin(2\\pi k x)$ 形成初始条件向量 $\\mathbf{u}(0)$，其元素为 $(\\mathbf{u}(0))_i = \\sin(2\\pi k x_i)$。\n    - 时间 $T$ 的数值解向量通过 $\\mathbf{u}^{(\\bullet)}(T) = \\exp(T\\,\\mathbf{L}^{(\\bullet)})\\,\\mathbf{u}(0)$ 计算。矩阵指数使用稳健的数值算法计算，例如 `scipy.linalg.expm` 中提供的算法。\n    - 在网格点上计算精确解向量 $\\mathbf{u}_{\\text{exact}}(T)$：$(\\mathbf{u}_{\\text{exact}}(T))_i = \\exp(-\\nu(2\\pi k)^2 T) \\sin(2\\pi k(x_i - aT))$。\n    - 然后根据给定公式计算离散 $\\ell^2$ 误差：\n      $$\n      E^{(\\bullet)} = \\left( \\Delta x \\sum_{i=0}^{N-1} \\big(u^{(\\bullet)}_i(T) - u_{\\text{exact}}(x_i,T)\\big)^2 \\right)^{1/2}\n      $$\n\n此过程系统地应用于所有四个测试用例，并将得到的十二个误差值按规定格式收集和格式化。实现将利用 `numpy` 库进行高效的数组和矩阵运算，以及利用 `scipy` 进行矩阵指数计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection-diffusion equation using finite differences\n    and matrix exponentiation for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: N=64, a=1, nu=0.01, T=0.1, k=1\n        (64, 1.0, 0.01, 0.1, 1),\n        # Case 2: N=64, a=1, nu=0.0005, T=0.05, k=1\n        (64, 1.0, 0.0005, 0.05, 1),\n        # Case 3: N=32, a=1, nu=0.1, T=0.1, k=1\n        (32, 1.0, 0.1, 0.1, 1),\n        # Case 4: N=64, a=1, nu=0.01, T=0.1, k=3\n        (64, 1.0, 0.01, 0.1, 3),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, a, nu, T, k = case\n        \n        # Grid setup\n        dx = 1.0 / N\n        x = np.arange(N) * dx\n        \n        # Initial condition vector\n        u0 = np.sin(2 * np.pi * k * x)\n        \n        # Exact solution at time T\n        decay_factor = np.exp(-nu * (2 * np.pi * k)**2 * T)\n        u_exact_T = decay_factor * np.sin(2 * np.pi * k * (x - a * T))\n        \n        # Construct matrix for the second derivative (D^2)\n        dx2 = dx**2\n        M2 = (np.diag(np.full(N, -2.0)) + \n              np.diag(np.full(N - 1, 1.0), 1) + \n              np.diag(np.full(N - 1, 1.0), -1)) / dx2\n        M2[0, -1] = 1.0 / dx2\n        M2[-1, 0] = 1.0 / dx2\n\n        # Construct matrices for the first derivative (D^C, D^U, D^D)\n        # Central difference (D^C)\n        M1_C = (np.diag(np.full(N - 1, 1.0), 1) + \n                np.diag(np.full(N - 1, -1.0), -1)) / (2 * dx)\n        M1_C[0, -1] = -1.0 / (2 * dx)\n        M1_C[-1, 0] = 1.0 / (2 * dx)\n\n        # Upwind difference (D^U)\n        M1_U = (np.diag(np.full(N, 1.0)) + \n                np.diag(np.full(N - 1, -1.0), -1)) / dx\n        M1_U[0, -1] = -1.0 / dx\n        \n        # Downwind difference (D^D)\n        M1_D = (np.diag(np.full(N, -1.0)) + \n                np.diag(np.full(N - 1, 1.0), 1)) / dx\n        M1_D[-1, 0] = 1.0 / dx\n        \n        M1_schemes = {'C': M1_C, 'U': M1_U, 'D': M1_D}\n        case_errors = []\n        \n        for scheme_key in ['C', 'U', 'D']:\n            M1 = M1_schemes[scheme_key]\n            \n            # Assemble the semi-discrete operator matrix L\n            L = -a * M1 + nu * M2\n            \n            # Compute numerical solution using matrix exponential\n            u_T_numerical = expm(T * L) @ u0\n            \n            # Compute the discrete l^2 error\n            error = np.sqrt(dx * np.sum((u_T_numerical - u_exact_T)**2))\n            case_errors.append(error)\n\n        results.extend(case_errors)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2392370"}]}