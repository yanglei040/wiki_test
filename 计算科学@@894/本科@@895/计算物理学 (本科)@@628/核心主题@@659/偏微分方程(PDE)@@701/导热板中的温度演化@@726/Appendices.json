{"hands_on_practices": [{"introduction": "本练习是学习模拟热流的基石。通过数值求解二维热传导方程随时间的演化，您将直接实践前向时间中心空间（FTCS）方法，并学习如何实现周期性和绝热等关键物理边界条件。这项实践将为您掌握更复杂的热分析技术打下坚实的基础。[@problem_id:2445101]", "problem": "考虑一个厚度均匀的薄导热板，其模型为二维区域，坐标为 $x \\in [0,L_x)$ 和 $y \\in [0,L_y]$。温度场 $T(x,y,t)$ 的演化遵循热传导方程，这是一个偏微分方程 (PDE)，具体如下\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) + s(x,y,t),\n$$\n其中 $\\alpha$ 是恒定的热扩散系数，$s(x,y,t)$ 是一个体积热源项，单位为温变率。$x$ 方向的边界条件是周期性的，即对所有的 $y$ 和 $t$ 都有 $T(0,y,t) = T(L_x,y,t)$，这模拟了将边缘 $x=0$ 和 $x=L_x$ 重合而形成的薄圆柱壳。$y$ 方向的边界是热绝缘的（法向热通量为零），即对所有的 $x$ 和 $t$ 都有 $\\frac{\\partial T}{\\partial y}(x,0,t)=0$ 和 $\\frac{\\partial T}{\\partial y}(x,L_y,t)=0$。初始条件是均匀的：处处有 $T(x,y,0) = T_0$。\n\n源项 $s(x,y,t)$ 代表一个沿 $x$ 方向均匀、在 $y$ 方向上局限于一个条带内的线性加热带。其定义如下\n$$\ns(x,y,t) =\n\\begin{cases}\nH, & \\text{若 } y \\in [y_1,y_2] \\text{ 且 } t \\in [0,\\tau],\\\\\n0, & \\text{其他情况},\n\\end{cases}\n$$\n其中 $H$ 是一个恒定的加热速率。所有温度必须以开尔文（Kelvin）表示，所有长度以米（meter）表示，所有时间以秒（second）表示。此问题不涉及角度。材料和几何形状在空间上是均匀的，并且板的属性不随时间变化。\n\n您的程序必须对几组参数集将 $T(x,y,t)$ 数值演化到指定的终止时间 $t=t_f$，然后为每组参数报告：\n- 在时间 $t_f$ 时，点 $(x^\\ast,y^\\ast) = (L_x/4, L_y/2)$ 处的温度（以开尔文计）。\n- 在时间 $t_f$ 时，点 $(x^\\ast,y^\\ast) = (3L_x/4, L_y/2)$ 处的温度（以开尔文计）。\n- 在时间 $t_f$ 时，板上 $T(\\cdot,\\cdot,t_f)$ 的空间面积平均值（以开尔文计）。\n\n为确保所需逐点量的无歧义评估，请在 $x$ 和 $y$ 方向上使用均匀网格，其节点坐标由 $x_i = i\\,L_x/N_x$（其中 $i \\in \\{0,1,\\dots,N_x-1\\}$）和 $y_j = j\\,L_y/(N_y-1)$（其中 $j \\in \\{0,1,\\dots,N_y-1\\}$）定义。对于以下所有测试用例，根据此约定，点 $(L_x/4, L_y/2)$ 和 $(3L_x/4, L_y/2)$ 均与网格节点重合。面积平均值是矩形域上的连续空间平均值，并且必须以开尔文报告。\n\n对所有测试使用以下材料参数：\n- 热扩散系数 $\\alpha = 1.11\\times 10^{-4}\\ \\text{m}^2/\\text{s}$。\n\n使用以下参数集测试套件。在每种情况下，板的初始温度为 $T_0 = 300\\ \\text{K}$，并且 $s(x,y,t)$ 由如上所述的宽度为 $w$、持续时间为 $\\tau$ 的条带指定。所有输出必须以开尔文表示，并四舍五入到三位小数。\n\n测试用例 A（中心条带，加热在 $t_f$ 之前停止）：\n- $L_x = 0.2\\ \\text{m}$，$L_y = 0.1\\ \\text{m}$。\n- $N_x = 64$，$N_y = 33$，$\\Delta t = 0.002\\ \\text{s}$，$t_f=1.0\\ \\text{s}$。\n- $H = 50\\ \\text{K/s}$，$w = 0.01\\ \\text{m}$，$\\tau = 0.5\\ \\text{s}$。\n- 加热带占据 $y \\in [y_1,y_2]$，其中 $y_1 = (L_y - w)/2$ 且 $y_2 = (L_y + w)/2$。\n\n测试用例 B（位于下部绝缘边缘的条带）：\n- $L_x = 0.2\\ \\text{m}$，$L_y = 0.1\\ \\text{m}$。\n- $N_x = 48$，$N_y = 25$，$\\Delta t = 0.002\\ \\text{s}$，$t_f=0.4\\ \\text{s}$。\n- $H = 100\\ \\text{K/s}$，$w = 0.01\\ \\text{m}$，$\\tau = 0.2\\ \\text{s}$。\n- 加热带占据 $y \\in [y_1,y_2]$，其中 $y_1 = 0$ 且 $y_2 = w$。\n\n测试用例 C（无加热）：\n- $L_x = 0.2\\ \\text{m}$，$L_y = 0.1\\ \\text{m}$。\n- $N_x = 32$，$N_y = 17$，$\\Delta t = 0.002\\ \\text{s}$，$t_f=0.3\\ \\text{s}$。\n- $H = 0\\ \\text{K/s}$，$w = 0.01\\ \\text{m}$，$\\tau = 0.0\\ \\text{s}$。\n- 加热带位置无关紧要。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表。列表必须按以下顺序排列\n$$\n[\\ T^{(A)}(L_x/4,L_y/2,t_f),\\ T^{(A)}(3L_x/4,L_y/2,t_f),\\ \\overline{T}^{(A)}(t_f),\\ T^{(B)}(L_x/4,L_y/2,t_f),\\ T^{(B)}(3L_x/4,L_y/2,t_f),\\ \\overline{T}^{(B)}(t_f),\\ T^{(C)}(L_x/4,L_y/2,t_f),\\ T^{(C)}(3L_x/4,L_y/2,t_f),\\ \\overline{T}^{(C)}(t_f)\\ ],\n$$\n每一项都以开尔文为单位，并四舍五入到三位小数，其中 $T^{(\\cdot)}$ 表示指定测试用例中的温度场，$\\overline{T}^{(\\cdot)}(t_f)$ 表示时间 $t_f$ 时的空间面积平均值。", "solution": "所给出的问题是二维线性热传导方程的一个适定的初边值问题。它具有科学依据，需要数值求解，并提供了所有必要的参数和条件。因此，该问题是有效的。我将开始求解。\n\n控制偏微分方程 (PDE) 是带有源项 $s(x,y,t)$ 的热传导方程：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) + s(x,y,t)\n$$\n这个方程描述了在热扩散系数为 $\\alpha$ 的区域 $x \\in [0,L_x)$、$y \\in [0,L_y]$ 中，温度场 $T(x,y,t)$ 的演化。\n\n将使用有限差分法 (FDM) 获得数值解。我将采用显式时间前向、空间中心 (FTCS) 差分格式，因为它易于直接实现。连续区域被离散化为一系列网格点 $(x_i, y_j, t_n)$，其中 $x_i = i \\Delta x$，$y_j = j \\Delta y$，$t_n = n \\Delta t$。网格参数已给出为 $N_x$ 和 $N_y$，因此空间步长为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / (N_y - 1)$。网格点上的温度表示为 $T_{i,j}^n \\approx T(x_i, y_j, t_n)$。\n\n偏导数近似如下：\n- 时间导数（一阶前向差分）：\n$$\n\\frac{\\partial T}{\\partial t} \\approx \\frac{T_{i,j}^{n+1} - T_{i,j}^n}{\\Delta t}\n$$\n- 空间导数（二阶中心差分）：\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\approx \\frac{T_{i+1,j}^n - 2T_{i,j}^n + T_{i-1,j}^n}{\\Delta x^2}\n$$\n$$\n\\frac{\\partial^2 T}{\\partial y^2} \\approx \\frac{T_{i,j+1}^n - 2T_{i,j}^n + T_{i,j-1}^n}{\\Delta y^2}\n$$\n将这些近似代入热传导方程，得到下一个时间步长温度 $T_{i,j}^{n+1}$ 的显式更新规则：\n$$\nT_{i,j}^{n+1} = T_{i,j}^n + \\Delta t \\left[ \\alpha \\left( \\frac{T_{i+1,j}^n - 2T_{i,j}^n + T_{i-1,j}^n}{\\Delta x^2} + \\frac{T_{i,j+1}^n - 2T_{i,j}^n + T_{i,j-1}^n}{\\Delta y^2} \\right) + s_{i,j}^n \\right]\n$$\n此格式在 Courant-Friedrichs-Lewy (CFL) 条件下是稳定的。对于二维热传导方程，该条件为 $\\alpha \\Delta t \\left( \\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2} \\right) \\le \\frac{1}{2}$。所有测试用例中给定的参数都满足此条件，从而保证了数值解的稳定性。\n\n边界条件必须在有限差分格式中正确实现：\n1. **$x$ 方向的周期性边界：** $T(0,y,t) = T(L_x,y,t)$。在离散网格上，这意味着 $T_{0,j}^n = T_{N_x,j}^n$。在 $i=0$ 处的点的相邻点是 $i=1$ 和 $i=N_x-1$。在 $i=N_x-1$ 处的点的相邻点是 $i=N_x-2$ 和 $i=0$。这可以通过对 $x$ 轴对应的数据数组执行循环移位操作来高效实现。\n\n2. **$y$ 方向的绝缘（Neumann）边界：** 在 $y=0$ ($j=0$) 和 $y=L_y$ ($j=N_y-1$) 处 $\\frac{\\partial T}{\\partial y} = 0$。通过使用域外的“虚拟点”，可以采用二阶精确的中心差分来近似该导数。对于 $j=0$，条件 $\\frac{T_{i,1}^n - T_{i,-1}^n}{2\\Delta y} = 0$ 意味着虚拟点的值为 $T_{i,-1}^n = T_{i,1}^n$。在 $j=0$ 处的拉普拉斯项变为：\n    $$\n    \\left. \\frac{\\partial^2 T}{\\partial y^2} \\right|_{j=0} \\approx \\frac{T_{i,1}^n - 2T_{i,0}^n + T_{i,-1}^n}{\\Delta y^2} = \\frac{2(T_{i,1}^n - T_{i,0}^n)}{\\Delta y^2}\n    $$\n    类似地，对于 $j=N_y-1$，虚拟点为 $T_{i,N_y}^n = T_{i,N_y-2}^n$，拉普拉斯项为：\n    $$\n    \\left. \\frac{\\partial^2 T}{\\partial y^2} \\right|_{j=N_y-1} \\approx \\frac{2(T_{i,N_y-2}^n - T_{i,N_y-1}^n)}{\\Delta y^2}\n    $$\n\n模拟从均匀初始条件 $T(x,y,0) = T_0$ 开始。FTCS 更新规则被迭代应用，总步数等于 $t_f/ \\Delta t$。源项 $s_{i,j}^n$ 在每个步骤中应用，如果网格点 $(x_i, y_j)$ 位于加热带内且当前时间 $t_n$ 小于 $\\tau$，则其值为 $H$，否则为 $0$。\n\n达到终止时间 $t_f$ 后，从最终温度场 $T_{i,j}^{final}$ 中提取所需的量：\n- **逐点温度：** 直接从对应于 $(L_x/4, L_y/2)$ 和 $(3L_x/4, L_y/2)$ 的网格节点读取数值。网格的构建方式使得这些点是精确的网格点，其索引为 $i = N_x/4$（或 $i=3N_x/4$）和 $j = (N_y-1)/2$。\n- **空间面积平均值：** 连续平均值 $\\overline{T}(t_f) = \\frac{1}{L_x L_y} \\iint T(x,y,t_f) \\,dx\\,dy$ 进行数值计算。该积分使用复合求积法则进行评估。由于 $x$ 方向的周期性，积分 $\\int_0^{L_x} f(x) dx$ 最好用矩形法则近似：$\\Delta x \\sum_{i=0}^{N_x-1} f(x_i)$。对于非周期性的 $y$ 方向，梯形法则是合适的，例如，$\\int_0^{L_y} g(y) dy$ 的积分可以使用 `np.trapz(g, dx=Δy)` 来近似。结合这两者，二重积分的计算方法是：首先对每个 $x_i$ 使用梯形法则沿 $y$ 轴积分，然后将结果沿 $x$ 轴求和，并乘以 $\\Delta x$。最终值是该积分除以总面积 $L_x L_y$。\n\n作为验证，面积平均温度的演化可以解析地确定。将 PDE 在整个域上积分，并应用散度定理以及给定的零通量边界条件，可得当 $t \\le \\tau$ 时 $\\frac{d\\overline{T}}{dt} = \\frac{1}{L_y} H w$，当 $t > \\tau$ 时为 $0$。其解为 $\\overline{T}(t_f) = T_0 + \\frac{Hw}{L_y} \\min(t_f, \\tau)$。对于 $H=0$ 的测试用例 C，温度场必须在所有时间内保持恒定为 $T_0=300\\,\\text{K}$。这些解析结果可作为对数值实现的严格检验。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D heat equation for the specified test cases and prints the results.\n    \"\"\"\n    \n    # Material parameter\n    ALPHA = 1.11e-4  # m^2/s\n    T0 = 300.0  # K\n\n    test_cases = [\n        # Test Case A\n        {\n            \"Lx\": 0.2, \"Ly\": 0.1, \"Nx\": 64, \"Ny\": 33, \n            \"dt\": 0.002, \"tf\": 1.0, \n            \"H\": 50.0, \"w\": 0.01, \"tau\": 0.5,\n            \"strip_type\": \"central\"\n        },\n        # Test Case B\n        {\n            \"Lx\": 0.2, \"Ly\": 0.1, \"Nx\": 48, \"Ny\": 25, \n            \"dt\": 0.002, \"tf\": 0.4, \n            \"H\": 100.0, \"w\": 0.01, \"tau\": 0.2,\n            \"strip_type\": \"lower_edge\"\n        },\n        # Test Case C\n        {\n            \"Lx\": 0.2, \"Ly\": 0.1, \"Nx\": 32, \"Ny\": 17, \n            \"dt\": 0.002, \"tf\": 0.3,\n            \"H\": 0.0, \"w\": 0.01, \"tau\": 0.0,\n            \"strip_type\": \"irrelevant\"\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Extract parameters\n        Lx, Ly, Nx, Ny = case[\"Lx\"], case[\"Ly\"], case[\"Nx\"], case[\"Ny\"]\n        dt, tf = case[\"dt\"], case[\"tf\"]\n        H, w, tau = case[\"H\"], case[\"w\"], case[\"tau\"]\n        strip_type = case[\"strip_type\"]\n\n        # Grid setup\n        dx = Lx / Nx\n        dy = Ly / (Ny - 1)\n        \n        # Grid coordinates\n        y_coords = np.linspace(0, Ly, Ny)\n        x_coords = np.linspace(0, Lx, Nx, endpoint=False)\n\n        # Initialize temperature field\n        T = np.full((Ny, Nx), T0, dtype=np.float64)\n\n        # Define heating strip location\n        if strip_type == \"central\":\n            y1 = (Ly - w) / 2\n            y2 = (Ly + w) / 2\n        elif strip_type == \"lower_edge\":\n            y1 = 0.0\n            y2 = w\n        else: # \"irrelevant\" or other\n            y1, y2 = -1.0, -1.0 # No heating should occur\n\n        # Pre-calculate source term mask\n        source_mask = np.zeros_like(T)\n        if H > 0:\n            # Add a small epsilon for robust float comparison at boundaries\n            y_indices = np.where((y_coords >= y1 - 1e-9)  (y_coords = y2 + 1e-9))[0]\n            source_mask[y_indices, :] = H\n\n        # Time-stepping loop\n        num_steps = int(round(tf / dt))\n        for n in range(num_steps):\n            # Calculate laplacian\n            # x-direction (periodic)\n            T_xx = (np.roll(T, -1, axis=1) - 2 * T + np.roll(T, 1, axis=1)) / (dx * dx)\n            \n            # y-direction (Neumann)\n            T_yy = np.zeros_like(T)\n            # Interior points\n            T_yy[1:-1, :] = (T[2:, :] - 2 * T[1:-1, :] + T[:-2, :]) / (dy * dy)\n            # Boundary y=0\n            T_yy[0, :] = 2 * (T[1, :] - T[0, :]) / (dy * dy)\n            # Boundary y=Ly\n            T_yy[-1, :] = 2 * (T[-2, :] - T[-1, :]) / (dy * dy)\n            \n            laplacian = T_xx + T_yy\n            \n            # Current source term\n            current_time = (n + 1) * dt # time at end of step\n            s_current = source_mask if current_time = tau else 0.0\n            \n            # Update temperature using FTCS scheme\n            T += dt * (ALPHA * laplacian + s_current)\n        \n        # --- Post-processing ---\n        \n        # 1. Pointwise temperatures\n        # Indices for (Lx/4, Ly/2) and (3Lx/4, Ly/2)\n        ix1 = Nx // 4\n        ix2 = 3 * Nx // 4\n        iy = (Ny - 1) // 2\n        \n        T_pt1 = T[iy, ix1]\n        T_pt2 = T[iy, ix2]\n        \n        # 2. Spatial area average\n        # Integrate along y (non-periodic) using trapezoidal rule\n        integral_y = np.trapz(T, dx=dy, axis=0) # Result is a 1D array of size Nx\n        # Integrate along x (periodic) using rectangular rule (summation)\n        total_integral = np.sum(integral_y) * dx\n        avg_T = total_integral / (Lx * Ly)\n\n        # Store results for this case\n        all_results.extend([T_pt1, T_pt2, avg_T])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.3f}' for val in all_results)}]\")\n\nsolve()\n```", "id": "2445101"}, {"introduction": "这个实践将您带入一个实际的工程设计挑战。您不再仅仅观察温度的演变，而是将运用稳态热传导（泊松方程）的知识来主动设计一个系统。这项练习要求您找到冷却通道的最佳布局以最大限度地降低热点区域的温度，从而在数值模拟和解决现实世界优化问题之间架起一座桥梁。[@problem_id:2445124]", "problem": "要求您为一个薄、均匀、各向同性、方形导热板的稳态温度场建立、离散化并求解一个优化问题。该导热板在指定热区内有内部热生成，并有一组离散的候选位置用于布置内部冷却通道，这些通道被理想化为单位厚度的线汇。您的任务是，对于几个指定的测试用例，计算在不同的候选节点上放置固定数量的冷却通道，且板边界上为固定的环境温度的条件下，热区上可达到的最小平均温度。您必须实现一个完整的程序，该程序执行以下操作：(i) 基于第一性原理构建一个数学上一致的模型，(ii) 使用有限差分法 (FDM) 在均匀网格上离散化稳态控制方程，(iii) 对给定基数的冷却通道布局的所有组合，求解得到的线性系统，以及 (iv) 报告每个测试用例热区的最小平均温度，以开尔文表示并四舍五入到三位小数。\n\n基本建模基础。从能量守恒和傅里叶导热定律出发。对于一个薄板，其导热系数为常数 $k$（单位为 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$），忽略内部的对流和辐射，稳态温度场 $T(x,y)$ 满足\n$$\n\\nabla \\cdot \\left( k \\nabla T \\right) + q_{\\text{hot}}(x,y) - q_{\\text{sink}}(x,y) = 0,\n$$\n其中 $q_{\\text{hot}}(x,y)$ 是局限于指定热区的体积热生成率（单位为 $\\mathrm{W\\,m^{-3}}$），而 $q_{\\text{sink}}(x,y)$ 是代表单位厚度冷却通道的局部体积热汇项之和。当 $k$ 为常数时，方程变为\n$$\n\\nabla^2 T(x,y) = \\frac{q_{\\text{sink}}(x,y) - q_{\\text{hot}}(x,y)}{k}.\n$$\n在整个板边界上施加狄利克雷边界条件 (BCs) $T = T_{\\text{amb}}$ (单位为 $\\mathrm{K}$)。\n\n离散化。考虑一个边长为 $L$（单位为 $\\mathrm{m}$）的正方形区域，在 $N \\times N$ 个节点的均匀网格上进行离散化，网格间距为 $h = L/(N-1)$。使用标准的 5 点模板对拉普拉斯算子进行有限差分离散化。对于索引为 $(i,j)$ 的内部网格节点，令 $T_{i,j}$ 表示离散温度。离散方程为\n$$\n\\frac{T_{i+1,j} + T_{i-1,j} + T_{i,j+1} + T_{i,j-1} - 4 T_{i,j}}{h^2} = \\frac{q_{\\text{sink},i,j} - q_{\\text{hot},i,j}}{k}.\n$$\n对于边界节点，强制执行狄利克雷条件 $T_{i,j} = T_{\\text{amb}}$。将 $q_{\\text{hot},i,j}$ 表示为在指定热区索引上为常数 $q_{\\text{hot}}$（单位为 $\\mathrm{W\\,m^{-3}}$），在其他地方为零。将每个冷却通道建模为其所在节点处贡献一个恒定的体积热汇 $s$（单位为 $\\mathrm{W\\,m^{-3}}$）；如果通道放置在集合 $\\mathcal{S}$ 中的节点索引处，则对于 $(i,j) \\in \\mathcal{S}$，$q_{\\text{sink},i,j} = s$，否则为零。\n\n优化任务。对于下面的每个测试用例，给定：\n- 板边长 $L$（单位为 $\\mathrm{m}$），\n- 网格尺寸 $N$（无量纲），\n- 导热系数 $k$（单位为 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$），\n- 环境边界温度 $T_{\\text{amb}}$（单位为 $\\mathrm{K}$），\n- 热区索引范围 $\\{i_{\\min}..i_{\\max}\\}$ 和 $\\{j_{\\min}..j_{\\max}\\}$（包含边界），\n- 热区上的均匀内部体积热生成率 $q_{\\text{hot}}$（单位为 $\\mathrm{W\\,m^{-3}}$），\n- 一个候选节点列表 $\\mathcal{C} = \\{(i,j)\\}$，允许在这些位置放置冷却通道，\n- 要放置的通道数量 $m$（一个整数，满足 $0 \\le m \\le |\\mathcal{C}|$），以及\n- 每个通道节点的汇强度 $s$（单位为 $\\mathrm{W\\,m^{-3}}$）。\n\n对于每个测试用例，评估从 $\\mathcal{C}$ 中选出的 $m$ 个不同节点的所有组合，为每个组合求解线性系统，计算热区节点集 $\\mathcal{H}$ 上的 $T_{i,j}$ 平均值，并报告在所有组合中实现的 $\\mathcal{H}$ 上的最小平均温度。\n\n数值单位和输出。所有温度必须以开尔文表示，并且每个测试用例的最终答案必须四舍五入到三位小数。不使用角度。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[300.123,299.876,305.000]$。\n\n测试套件。请严格使用以下三个测试用例；索引是从零开始且包含边界：\n- 测试用例 1 (正常路径):\n  - $L = 0.20$ $\\mathrm{m}$，$N = 20$，$k = 200$ $\\mathrm{W\\,m^{-1}\\,K^{-1}}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，\n  - 热区行 $i \\in \\{7,8,9,10,11,12\\}$ 和列 $j \\in \\{7,8,9,10,11,12\\}$，\n  - $q_{\\text{hot}} = 1.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$，\n  - 候选集 $\\mathcal{C}_1 = \\{(6,7),(6,9),(6,12),(13,7),(13,9),(13,12),(7,6),(9,6),(12,13),(9,13)\\}$，\n  - 通道数量 $m = 2$，\n  - 汇强度 $s = 5.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$。\n- 测试用例 2 (无通道的边界情况):\n  - $L = 0.20$ $\\mathrm{m}$，$N = 20$，$k = 200$ $\\mathrm{W\\,m^{-1}\\,K^{-1}}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，\n  - 热区行 $i \\in \\{7,8,9,10,11,12\\}$ 和列 $j \\in \\{7,8,9,10,11,12\\}$，\n  - $q_{\\text{hot}} = 1.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$，\n  - 候选集 $\\mathcal{C}_2 = \\mathcal{C}_1$ (与测试用例 1 相同)，\n  - 通道数量 $m = 0$，\n  - 汇强度 $s = 5.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$ (由于 $m=0$ 而无关紧要)。\n- 测试用例 3 (不同材料和几何形状):\n  - $L = 0.16$ $\\mathrm{m}$，$N = 16$，$k = 60$ $\\mathrm{W\\,m^{-1}\\,K^{-1}}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，\n  - 热区行 $i \\in \\{6,7,8,9\\}$ 和列 $j \\in \\{6,7,8,9\\}$，\n  - $q_{\\text{hot}} = 1.2 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$，\n  - 候选集 $\\mathcal{C}_3 = \\{(5,5),(5,7),(5,8),(5,10),(10,5),(10,7),(10,8),(10,10),(7,5),(8,5),(7,10),(8,10)\\}$，\n  - 通道数量 $m = 3$，\n  - 汇强度 $s = 8.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个测试用例的最小热区平均温度，格式为方括号括起来的逗号分隔列表，每个条目均为以开尔文表示并四舍五入到三位小数的浮点数，例如 $[T_1,T_2,T_3]$，其中每个 $T_i$ 是以开尔文表示并四舍五入到三位小数的浮点数。", "solution": "所呈现的问题是一个根植于传热学基本原理的适定优化任务。它要求找到离散数量的冷却通道的最优布局，以最小化导热板特定区域的平均温度。求解过程首先将物理问题表述为线性方程组，然后对冷却通道的每一种可能配置求解该系统，以确定目标函数的全局最小值。\n\n控制物理定律是稳态热方程，对于具有恒定导热系数 $k$ 的均匀各向同性介质，该方程简化为泊松方程：\n$$\n\\nabla^2 T(x,y) = -\\frac{q(x,y)}{k}\n$$\n其中 $T(x,y)$ 是温度场，而 $q(x,y) = q_{\\text{hot}}(x,y) - q_{\\text{sink}}(x,y)$ 是净体积热源密度，单位为 $\\mathrm{W\\,m^{-3}}$。该板是一个边长为 $L$ 的正方形区域，其边界上的温度由狄利克雷条件 $T = T_{\\text{amb}}$ 固定。\n\n为了数值求解此偏微分方程，将区域离散化为 $N \\times N$ 个节点的均匀网格，网格间距为 $h = L/(N-1)$。拉普拉斯算子 $\\nabla^2$ 使用标准的 5 点有限差分模板进行近似。对于内部节点 $(i,j)$，其中 $i,j \\in \\{1, \\dots, N-2\\}$，泊松方程的离散形式为：\n$$\n\\frac{T_{i+1,j} + T_{i-1,j} + T_{i,j+1} + T_{i,j-1} - 4T_{i,j}}{h^2} = -\\frac{q_{i,j}}{k}\n$$\n对所有 $(N-2)^2$ 个内部节点重新整理此方程，得到一个线性代数方程组，$\\mathbf{A}\\mathbf{T}_{\\text{int}} = \\mathbf{b}$。\n- $\\mathbf{T}_{\\text{int}}$ 是一个维度为 $(N-2)^2$ 的向量，包含内部节点的未知温度。\n- $\\mathbf{A}$ 是一个大小为 $(N-2)^2 \\times (N-2)^2$ 的稀疏块三对角矩阵，代表离散化的负拉普拉斯算子。对于一个展平索引为 $p$ 的内部节点，矩阵方程中对应的行源自 $4T_p - \\sum_{n \\in \\text{neighbors}} T_n = \\frac{h^2}{k}q_p$。因此，$\\mathbf{A}$ 的对角元素为 $4$，与相邻内部节点对应的非对角元素为 $-1$。\n- $\\mathbf{b}$ 是维度为 $(N-2)^2$ 的右侧向量。每个元素 $b_p$ 由两部分组成：来自热源/汇项的贡献 $\\frac{h^2}{k}q_{i,j}$，以及来自任何相邻边界节点的贡献，这些节点的温度是已知的 ($T_{\\text{amb}}$)。如果一个内部节点 $(i,j)$ 与边界相邻，已知的温度 $T_{\\text{amb}}$ 会被移到方程的右侧。\n\n优化通过组合搜索来执行。对于每个测试用例，我们给定一组候选位置 $\\mathcal{C}$ 和要放置的通道数量 $m$。算法计算放置 $m$ 个冷却通道的所有 $\\binom{|\\mathcal{C}|}{m}$ 种组合。对于每种组合：\n1.  构建总源项网格 $q_{i,j} = q_{\\text{hot},i,j} - q_{\\text{sink},i,j}$。$q_{\\text{hot},i,j}$ 仅在指定的热区 $\\mathcal{H}$ 中非零，而 $q_{\\text{sink},i,j}$ 仅在当前组合所选的节点上非零。\n2.  使用当前的 $q_{i,j}$ 分布和固定的边界温度 $T_{\\text{amb}}$ 来组装向量 $\\mathbf{b}$。矩阵 $\\mathbf{A}$ 与源/汇的配置无关，每个测试用例只构建一次。\n3.  求解稀疏线性系统 $\\mathbf{A}\\mathbf{T}_{\\text{int}} = \\mathbf{b}$ 以得到内部温度向量 $\\mathbf{T}_{\\text{int}}$。`scipy.sparse.linalg.spsolve` 是完成此任务的合适且高效的求解器。\n4.  将解 $\\mathbf{T}_{\\text{int}}$ 放入边界设置为 $T_{\\text{amb}}$ 的网格内部，以重建完整的温度网格。\n5.  通过对热区 $\\mathcal{H}$ 中所有节点的温度求和，然后除以节点数 $|\\mathcal{H}|$，来计算该区域的平均温度。\n6.  将此平均温度与先前组合中找到的最小值进行比较，并在必要时更新最小值。\n\n在遍历所有组合后，报告所得的热区最小平均温度。对问题陈述中提供的每个测试用例重复此过程。$m=0$ 的情况会自然处理，因为只有一个组合（无通道），系统只需求解一次。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the optimization problem for three test cases.\n    For each case, it finds the optimal placement of cooling channels\n    to minimize the average temperature of a hot area on a conducting plate.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"L\": 0.20, \"N\": 20, \"k\": 200, \"T_amb\": 300,\n            \"hot_area_rows\": (7, 12), \"hot_area_cols\": (7, 12),\n            \"q_hot\": 1.0e6,\n            \"C\": [(6, 7), (6, 9), (6, 12), (13, 7), (13, 9), (13, 12), (7, 6), (9, 6), (12, 13), (9, 13)],\n            \"m\": 2, \"s\": 5.0e6\n        },\n        # Test case 2 (boundary case with no channels)\n        {\n            \"L\": 0.20, \"N\": 20, \"k\": 200, \"T_amb\": 300,\n            \"hot_area_rows\": (7, 12), \"hot_area_cols\": (7, 12),\n            \"q_hot\": 1.0e6,\n            \"C\": [(6, 7), (6, 9), (6, 12), (13, 7), (13, 9), (13, 12), (7, 6), (9, 6), (12, 13), (9, 13)],\n            \"m\": 0, \"s\": 5.0e6\n        },\n        # Test case 3 (different material and geometry)\n        {\n            \"L\": 0.16, \"N\": 16, \"k\": 60, \"T_amb\": 300,\n            \"hot_area_rows\": (6, 9), \"hot_area_cols\": (6, 9),\n            \"q_hot\": 1.2e6,\n            \"C\": [(5, 5), (5, 7), (5, 8), (5, 10), (10, 5), (10, 7), (10, 8), (10, 10), (7, 5), (8, 5), (7, 10), (8, 10)],\n            \"m\": 3, \"s\": 8.0e6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, k, T_amb = case[\"L\"], case[\"N\"], case[\"k\"], case[\"T_amb\"]\n        hot_area_rows, hot_area_cols = case[\"hot_area_rows\"], case[\"hot_area_cols\"]\n        q_hot, C, m, s = case[\"q_hot\"], case[\"C\"], case[\"m\"], case[\"s\"]\n        \n        h = L / (N - 1)\n        N_int = N - 2\n        num_unknowns = N_int * N_int\n\n        # Define hot area grid and node list\n        q_hot_grid = np.zeros((N, N))\n        hot_area_nodes = []\n        for i in range(hot_area_rows[0], hot_area_rows[1] + 1):\n            for j in range(hot_area_cols[0], hot_area_cols[1] + 1):\n                q_hot_grid[i, j] = q_hot\n                hot_area_nodes.append((i, j))\n\n        # Construct the A matrix (sparse). This is constant for each case.\n        A = lil_matrix((num_unknowns, num_unknowns))\n        for i in range(1, N - 1):\n            for j in range(1, N - 1):\n                p = (i - 1) * N_int + (j - 1)\n                A[p, p] = 4\n                if i > 1: A[p, p - N_int] = -1\n                if i  N - 2: A[p, p + N_int] = -1\n                if j > 1: A[p, p - 1] = -1\n                if j  N - 2: A[p, p + 1] = -1\n        A_csc = A.tocsc()\n\n        min_avg_temp = float('inf')\n        sink_combinations = combinations(C, m)\n\n        for sink_placement in sink_combinations:\n            q_sink_grid = np.zeros((N, N))\n            for r, c in sink_placement:\n                q_sink_grid[r, c] = s\n\n            q_total_grid = q_hot_grid - q_sink_grid\n\n            # Construct the b vector\n            b = np.zeros(num_unknowns)\n            for i in range(1, N - 1):\n                for j in range(1, N - 1):\n                    p = (i - 1) * N_int + (j - 1)\n                    \n                    source_term = (h**2 / k) * q_total_grid[i, j]\n                    \n                    boundary_term = 0\n                    if i == 1: boundary_term += T_amb\n                    if i == N - 2: boundary_term += T_amb\n                    if j == 1: boundary_term += T_amb\n                    if j == N - 2: boundary_term += T_amb\n                    \n                    b[p] = source_term + boundary_term\n            \n            # Solve the sparse linear system\n            T_int_vec = spsolve(A_csc, b)\n            \n            # Reconstruct the full temperature grid\n            T_full = np.full((N, N), T_amb, dtype=float)\n            T_full[1:N-1, 1:N-1] = T_int_vec.reshape((N_int, N_int))\n\n            # Calculate average temperature over the hot area\n            current_hot_area_temp_sum = 0\n            for r, c in hot_area_nodes:\n                current_hot_area_temp_sum += T_full[r, c]\n            \n            avg_temp = current_hot_area_temp_sum / len(hot_area_nodes)\n            min_avg_temp = min(min_avg_temp, avg_temp)\n        \n        results.append(round(min_avg_temp, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2445124"}, {"introduction": "这项练习将带您进入引人入胜的逆问题世界。在这里，我们的目标不是预测已知原因所产生的效果，而是从观测到的效果中推断出未知的原因。这项“侦探工作”利用热传导方程模型来确定一个隐藏热源的位置，展示了计算物理学在诊断和系统辨识中的强大应用。[@problem_id:2445154]", "problem": "您将求解一个关于均匀各向同性薄导热板中温度演化的反问题。推导过程需从能量守恒和傅里叶热传导定律这两个基本原理出发。考虑一个边长为 $L$ 的方形板，其热扩散系数 $\\alpha$ 为常数，边界温度在所有时刻均保持为零，且初始温度也为零。一个位置未知的恒定点热源从时间 $t=0$ 开始以恒定速率注入热量，直至最终时刻 $t=T$。该板被模型化为二维空间问题，其厚度足够薄，因此可以忽略板面外方向的传导。目标是仅根据时刻 $t=T$ 的最终温度场，确定热源所在的网格位置。\n\n您的程序必须以纯数学方式实现以下流程：\n- 从能量平衡和傅里叶定律出发，推导二维热方程的一致离散演化格式。在一个覆盖方形区域 $[0,L]\\times[0,L]$ 的 $N_x \\times N_x$ 节点均匀网格上，使用一个无条件稳定的时间推进格式，并在 $x=0$、$x=L$、$y=0$ 和 $y=L$ 处施加零狄利克雷边界条件。\n- 将恒定点热源表示为某个未知内部网格节点上的单个节点强迫项。该节点强迫项的幅值随时间恒定，但其大小是未知的。\n- 利用离散演化的线性结构，构建一个反演估计器。对于每个候选内部节点，该估计器计算由位于该节点、具有其最佳恒定幅值的热源所产生的预测最终场与测量的最终场之间的最小二乘残差。选择使此残差最小的节点。\n\n下方的测试套件指定了参数集和真实的热源位置。对于每个测试用例，您必须：\n- 在均匀网格上构建离散算子。\n- 在内部通过求解正问题来生成“测量”的最终温度场。求解时使用相同的离散模型、零初始条件，并在整个积分时间段内，于真实热源位置施加指定的恒定幅值的恒定热源。\n- 通过解决上述反向选择问题，反演出热源的位置。\n\n请勿使用任何外部输入。使用从零开始的索引，原点位于左下角。在大小为 $N_x \\times N_x$ 的完整网格上，以整数网格索引 $(i_x,i_y)$ 的形式报告热源位置，其中 $i_x \\in \\{0,1,\\dots,N_x-1\\}$ 随 $x$ 从左到右递增，$i_y \\in \\{0,1,\\dots,N_x-1\\}$ 随 $y$ 从下到上递增。热源将始终严格位于内部，即 $1 \\le i_x \\le N_x-2$ 和 $1 \\le i_y \\le N_x-2$。您的输出中无需包含物理单位。\n\n测试套件（五个用例）：\n- 用例 1：$L=1$，$N_x=25$，$\\alpha=10^{-3}$，时间步长 $\\Delta t=2\\times 10^{-2}$，步数 $N_t=200$，源幅值 $q=1$，真实源位置 $(i_x,i_y)=(12,9)$。\n- 用例 2：$L=1$，$N_x=25$，$\\alpha=2\\times 10^{-3}$，时间步长 $\\Delta t=1.5\\times 10^{-2}$，步数 $N_t=160$，源幅值 $q=0.8$，真实源位置 $(i_x,i_y)=(1,7)$。\n- 用例 3：$L=1$，$N_x=21$，$\\alpha=5\\times 10^{-4}$，时间步长 $\\Delta t=10^{-2}$，步数 $N_t=80$，源幅值 $q=1.2$，真实源位置 $(i_x,i_y)=(10,10)$。\n- 用例 4：$L=1$，$N_x=27$，$\\alpha=1.5\\times 10^{-3}$，时间步长 $\\Delta t=10^{-2}$，步数 $N_t=150$，源幅值 $q=0.5$，真实源位置 $(i_x,i_y)=(2,2)$。\n- 用例 5：$L=1$，$N_x=17$，$\\alpha=10^{-3}$，时间步长 $\\Delta t=2.5\\times 10^{-2}$，步数 $N_t=60$，源幅值 $q=1$，真实源位置 $(i_x,i_y)=(8,1)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个用例的估计源位置列表。该列表按用例顺序排列，是一个由逗号分隔的5个元素的列表，每个元素是一个包含两个整数 $[i_x,i_y]$ 的列表。例如，输出格式必须严格符合 $[[i_{x,1},i_{y,1}],[i_{x,2},i_{y,2}],[i_{x,3},i_{y,3}],[i_{x,4},i_{y,4}],[i_{x,5},i_{y,5}]]$。", "solution": "该问题经评估在科学上是合理的、适定的且自洽的。这是一个计算物理学中的标准反问题，基于热传递的基本原理。所有必要的参数和条件均已提供。我将开始进行求解。\n\n**1. 控制方程与离散化**\n\n推导从应用于板内一个微小控制体 $d A=dx\\,dy$ 的能量守恒原理开始。热能的时间变化率必须等于流入该控制体的净热流量加上内部产生的任何热量。这可以表示为：\n$$\n\\rho c_p \\frac{\\partial u}{\\partial t} = -\\nabla \\cdot \\mathbf{q} + Q\n$$\n其中 $u(x,y,t)$ 是温度场，$\\rho$ 是密度，$c_p$ 是比热容，$\\mathbf{q}$ 是热通量矢量，$Q$ 是体热源密度。傅里叶热传导定律将热通量与温度梯度关联起来：$\\mathbf{q} = -k \\nabla u$，其中 $k$ 是热导率。对于物性恒定的均匀材料，代入可得：\n$$\n\\rho c_p \\frac{\\partial u}{\\partial t} = \\nabla \\cdot (k \\nabla u) + Q = k \\nabla^2 u + Q\n$$\n两边同除以 $\\rho c_p$，并定义热扩散系数 $\\alpha = k/(\\rho c_p)$ 和源项 $S = Q/(\\rho c_p)$（单位为温度/时间），我们得到标准的热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u + S(x,y,t)\n$$\n我们使用一个含 $N_x \\times N_x$ 个节点的均匀网格对空间域 $[0,L]\\times[0,L]$ 进行离散化。网格间距为 $\\Delta x = \\Delta y = h = L/(N_x-1)$。令 $u_{i,j}^n$ 表示在时间 $t_n = n\\Delta t$ 时网格点 $(x_i, y_j) = (ih, jh)$ 处的温度。拉普拉斯算子 $\\nabla^2$ 使用五点中心差分格式进行近似：\n$$\n\\nabla^2 u \\Big|_{(i,j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n\n**2. 时间离散化与矩阵形式**\n\n为确保所要求的无条件稳定性，我们使用一种隐式时间推进格式。因其简单性和稳定性，我们选择后向 Euler 法。该方法在未来的时间步 $n+1$ 处计算空间导数：\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\alpha \\left( \\frac{u_{i+1,j}^{n+1} + u_{i-1,j}^{n+1} + u_{i,j+1}^{n+1} + u_{i,j-1}^{n+1} - 4u_{i,j}^{n+1}}{h^2} \\right) + S_{i,j}^{n+1}\n$$\n整理各项，将时间步 $n+1$ 的未知量置于左侧，对于每个内部网格点 $(i,j)$（其中 $i,j \\in \\{1, \\dots, N_x-2\\}$），我们得到一个线性方程：\n$$\n(1 + 4c)u_{i,j}^{n+1} - c(u_{i+1,j}^{n+1} + u_{i-1,j}^{n+1} + u_{i,j+1}^{n+1} + u_{i,j-1}^{n+1}) = u_{i,j}^n + \\Delta t S_{i,j}^{n+1}\n$$\n其中 $c = \\alpha \\Delta t / h^2$ 是扩散数。零狄利克雷边界条件（所有边界上 $u=0$）被隐式处理，因为任何索引在边界上的项 $u^{n+1}$ 均为零，从而从方程中消去。\n\n这个包含 $(N_x-2)^2$ 个线性方程的方程组必须在每个时间步求解。我们可以将其表示为矩阵形式。设 $\\mathbf{u}^n$ 是一个大小为 $N_{int} = (N_x-2)^2$ 的向量，表示所有内部节点的温度，并已展平为单个列向量。该系统变为：\n$$\n\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\mathbf{S}^{n+1}\n$$\n矩阵 $\\mathbf{A}$ 是一个代表离散隐式算子的稀疏块三对角矩阵，它不随时间变化。向量 $\\mathbf{S}^{n+1}$ 代表节点源强迫项。由于热源在时间和空间上（在单个节点上）是恒定的，我们可以写成 $\\mathbf{S}^{n+1} = q \\, \\mathbf{e}_{k_s}$，其中 $k_s$ 是源节点展平后的一维索引，$\\mathbf{e}_{k_s}$ 是对应的标准基向量，$q$ 是源幅值。\n\n**3. 正问题求解**\n\n正问题在于，给定初始条件 $\\mathbf{u}^0 = \\mathbf{0}$ 以及位置 $k_s$ 和幅值 $q$ 已知的热源，求解最终温度场 $\\mathbf{u}_{final} = \\mathbf{u}^{N_t}$。时间演化通过对 $n=0, \\dots, N_t-1$ 迭代求解线性系统来计算：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{A}^{-1}(\\mathbf{u}^n + q \\Delta t \\, \\mathbf{e}_{k_s})\n$$\n为高效执行此操作，矩阵 $\\mathbf{A}$ 只需进行一次分解（例如，使用 LU 分解），然后在每个时间步通过前向和后向代换重用该分解结果来求解 $\\mathbf{u}^{n+1}$。此过程用于根据每个测试用例中提供的真实源参数生成“测量”的最终温度场 $\\mathbf{u}_{meas}$。\n\n**4. 反问题构建**\n\n反问题的目标是在给定 $\\mathbf{u}_{meas}$ 的情况下，找到源位置 $k_s$。源幅值 $q$ 也是未知的。该问题被构建为对所有可能的内部节点进行搜索。对于每个候选源位置 $k_c$，我们找到一个最佳源幅值，使其在最小二乘意义下能够最好地解释测量数据。\n\n设 $\\mathbf{U}_{k_c}$ 是由位于 $k_c$ 的单位源（$q=1$）产生的最终温度场，使用相同的正向模型计算得出。由于线性关系，位于 $k_c$、幅值为 $q_c$ 的源所对应的预测场为 $\\mathbf{u}_{pred} = q_c \\mathbf{U}_{k_c}$。我们必须找到使残差最小化的 $k_c$ 和 $q_c$：\n$$\nR(k_c, q_c) = \\| \\mathbf{u}_{meas} - q_c \\mathbf{U}_{k_c} \\|_2^2\n$$\n对于一个固定的候选位置 $k_c$，最佳幅值 $q_c^*$ 可通过将 $R$ 对 $q_c$ 的导数置零来求得：\n$$\n\\frac{\\partial R}{\\partial q_c} = 0 \\implies q_c^* = \\frac{\\mathbf{U}_{k_c}^T \\mathbf{u}_{meas}}{\\mathbf{U}_{k_c}^T \\mathbf{U}_{k_c}} = \\frac{\\langle \\mathbf{U}_{k_c}, \\mathbf{u}_{meas} \\rangle}{\\| \\mathbf{U}_{k_c} \\|_2^2}\n$$\n这个最佳幅值是 $\\mathbf{u}_{meas}$ 在基向量 $\\mathbf{U}_{k_c}$ 上的标量投影。\n\n**5. 算法流程**\n\n最终估计的源位置是代入其最佳幅值后使残差最小化的候选节点：\n$$\nk_{est} = \\arg\\min_{k_c} \\| \\mathbf{u}_{meas} - q_c^*(k_c) \\, \\mathbf{U}_{k_c} \\|_2^2\n$$\n完整的算法如下：\n1. **生成数据**：对于每个测试用例，构建矩阵 $\\mathbf{A}$。使用真实的源参数模拟 $N_t$ 个时间步的温度演化，以生成测量向量 $\\mathbf{u}_{meas}$。\n2. **迭代和测试候选点**：遍历每个内部网格节点 $(i_c, j_c)$ 作为候选源位置。\n    a. 对于每个候选点 $(i_c, j_c)$，模拟在该位置施加单位源（$q=1$）的正问题，以计算相应的最终温度分布 $\\mathbf{U}_{k_c}$。\n    b. 使用推导出的投影公式计算最佳源幅值 $q_c^*$。\n    c. 计算 $\\mathbf{u}_{meas}$ 与预测值 $q_c^* \\mathbf{U}_{k_c}$ 之间残差的 L2 范数的平方。\n3. **选择最佳拟合**：估计的源位置是产生最小残差的候选点 $(i_c, j_c)$。程序为每个指定的测试用例实现此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import splu\n\ndef solve():\n    \"\"\"\n    Main function to solve the inverse heat source problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {'L': 1, 'Nx': 25, 'alpha': 1e-3, 'dt': 2e-2, 'Nt': 200, 'q': 1, 'true_loc': (12, 9)},\n        {'L': 1, 'Nx': 25, 'alpha': 2e-3, 'dt': 1.5e-2, 'Nt': 160, 'q': 0.8, 'true_loc': (1, 7)},\n        {'L': 1, 'Nx': 21, 'alpha': 5e-4, 'dt': 1e-2, 'Nt': 80, 'q': 1.2, 'true_loc': (10, 10)},\n        {'L': 1, 'Nx': 27, 'alpha': 1.5e-3, 'dt': 1e-2, 'Nt': 150, 'q': 0.5, 'true_loc': (2, 2)},\n        {'L': 1, 'Nx': 17, 'alpha': 1e-3, 'dt': 2.5e-2, 'Nt': 60, 'q': 1, 'true_loc': (8, 1)},\n    ]\n\n    results = []\n    for case in test_cases:\n        estimated_loc = find_source_location(**case)\n        results.append(list(estimated_loc))\n\n    formatted_results = [f'[{r[0]},{r[1]}]' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_forward_simulation(solver, Nt, dt, source_amplitude, source_k, N_int):\n    \"\"\"\n    Simulates the heat equation forward in time.\n    \n    Args:\n        solver: Pre-factorized sparse matrix solver (from splu).\n        Nt: Number of time steps.\n        dt: Time step size.\n        source_amplitude: The 'q' value for the source.\n        source_k: The flattened index of the source node.\n        N_int: Total number of interior nodes.\n\n    Returns:\n        The final temperature field as a 1D numpy array.\n    \"\"\"\n    f_vec = np.zeros(N_int)\n    if source_k is not None:\n        f_vec[source_k] = source_amplitude * dt\n\n    u_n = np.zeros(N_int)\n    for _ in range(Nt):\n        b = u_n + f_vec\n        u_n = solver.solve(b)\n    \n    return u_n\n\ndef find_source_location(L, Nx, alpha, dt, Nt, q, true_loc):\n    \"\"\"\n    Finds the heat source location for a single test case.\n    \"\"\"\n    # 1. Setup grid and parameters\n    h = L / (Nx - 1)\n    c = alpha * dt / h**2\n    N_int_dim = Nx - 2\n    N_int = N_int_dim**2\n\n    # 2. Build the sparse matrix A for the implicit scheme (I - c*L)\n    M = N_int_dim\n    N = M * M\n    main_diag = np.full(N, 1 + 4 * c)\n    sub_diag = np.full(N - 1, -c)\n    sup_diag = np.full(N - 1, -c)\n    # Remove fictitious connections between grid rows\n    sub_diag[M-1::M] = 0\n    sup_diag[M-1::M] = 0\n    lower_M_diag = np.full(N - M, -c)\n    upper_M_diag = np.full(N - M, -c)\n    \n    diagonals_data = [upper_M_diag, sup_diag, main_diag, sub_diag, lower_M_diag]\n    offsets = [M, 1, 0, -1, -M]\n    A = diags(diagonals_data, offsets, shape=(N, N), format='csc')\n    \n    # Pre-factorize the matrix for efficient solves\n    solver = splu(A)\n\n    # 3. Generate \"measured\" data by solving the forward problem with true parameters\n    k_true = (true_loc[0] - 1) + (true_loc[1] - 1) * N_int_dim\n    u_meas = run_forward_simulation(solver, Nt, dt, q, k_true, N_int)\n\n    # 4. Inverse search for the source location\n    min_residual = float('inf')\n    best_location = None\n    \n    # Iterate through all possible interior nodes as candidates\n    for j_c in range(1, Nx - 1):\n        for i_c in range(1, Nx - 1):\n            k_c = (i_c - 1) + (j_c - 1) * N_int_dim\n            \n            # a. Simulate the final field for a unit source at the candidate location\n            U_kc = run_forward_simulation(solver, Nt, dt, 1.0, k_c, N_int)\n            \n            dot_Ukc_Ukc = np.dot(U_kc, U_kc)\n            # If the response is negligible, this is not a viable candidate\n            if dot_Ukc_Ukc  1e-30:\n                continue\n\n            # b. Calculate the optimal source amplitude and the corresponding residual\n            q_star = np.dot(U_kc, u_meas) / dot_Ukc_Ukc\n            residual = np.sum((u_meas - q_star * U_kc)**2)\n\n            # c. Update the best-fit location if the current candidate is better\n            if residual  min_residual:\n                min_residual = residual\n                best_location = (i_c, j_c)\n                \n    return best_location\n\nsolve()\n```", "id": "2445154"}]}