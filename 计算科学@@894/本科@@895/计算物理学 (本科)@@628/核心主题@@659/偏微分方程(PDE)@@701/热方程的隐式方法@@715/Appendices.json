{"hands_on_practices": [{"introduction": "这项首个练习将通过实施一个无条件稳定的隐式方法来求解一维热方程，为您提供基础的实践经验。您将应用 Crank-Nicolson 方法解决一个热扩散问题，并将您的数值结果与已知的解析解进行比较。这项实践对于为求解抛物型偏微分方程打下坚实基础，以及理解准确性验证的重要性至关重要 [@problem_id:2402549]。", "problem": "考虑一维热传导进入一个半无限均匀固体。温度场 $T(x,t)$ 满足热传导方程（一个偏微分方程 (PDE)）\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\,\\frac{\\partial^2 T}{\\partial x^2}, \\quad x > 0, \\; t > 0,\n$$\n其中 $\\alpha$ 是热扩散率。该固体初始处于均匀温度，而位于 $x=0$ 的表面被突然升至一个更高的温度并保持不变。为了计算数值近似解，我们用一个有限区间 $[0,L]$ 来近似该半无限域，并使用以下适定的初始和边界条件：\n- 初始条件：对于所有 $x \\in (0,L]$，$T(x,0) = T_0$。\n- 表面边界条件：对于所有 $t > 0$，$T(0,t) = T_s$。\n- 远端边界条件：对于所有 $t > 0$，$\\frac{\\partial T}{\\partial x}(L,t) = 0$。\n\n在这些条件下，半无限域（无有限-$L$截断）的精确解析解是已知的，由下式给出\n$$\nT_{\\text{exact}}(x,t) = T_0 + \\bigl(T_s - T_0\\bigr)\\,\\mathrm{erfc}\\!\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right), \\quad x \\ge 0, \\; t > 0,\n$$\n其中 $\\mathrm{erfc}$ 表示互补误差函数。\n\n您的任务是针对每个指定的参数集，在截断域 $[0,L]$ 上，使用一个具有 $N_x$ 个等尺寸子区间的均匀空间网格（因此网格点为 $x_i = i\\,\\Delta x$，其中对于 $i=0,1,\\dots,N_x$，$\\Delta x = L/N_x$）和一个均匀时间步长 $\\Delta t$（因此到达最终时间 $t_f$ 的时间步数为 $t_f/\\Delta t$，在测试集中保证为整数），计算在最终时间 $t=t_f$ 时的 $T(x,t)$ 的数值近似解。然后，在网格 $\\{x_i\\}_{i=0}^{N_x}$ 上，计算数值解 $T_{\\text{num}}(x_i,t_f)$ 与精确解 $T_{\\text{exact}}(x_i,t_f)$ 之间的最大绝对误差（单位为开尔文）：\n$$\nE_{\\max} = \\max_{0 \\le i \\le N_x} \\left| T_{\\text{num}}(x_i,t_f) - T_{\\text{exact}}(x_i,t_f) \\right|.\n$$\n\n所有物理单位必须一致使用：长度单位为米 ($\\mathrm{m}$)，时间单位为秒 ($\\mathrm{s}$)，温度单位为开尔文 ($\\mathrm{K}$)，扩散率单位为平方米每秒 ($\\mathrm{m^2/s}$)。以开尔文报告每个 $E_{\\max}$，并四舍五入到六位小数。\n\n测试集。对于以下每个参数集 $(\\alpha, L, T_0, T_s, t_f, N_x, \\Delta t)$，计算 $E_{\\max}$：\n\n- 情况 $1$：$\\alpha = 1.0\\times 10^{-5}\\ \\mathrm{m^2/s}$，$L = 0.1\\ \\mathrm{m}$，$T_0 = 300\\ \\mathrm{K}$，$T_s = 400\\ \\mathrm{K}$，$t_f = 100\\ \\mathrm{s}$，$N_x = 400$，$\\Delta t = 0.1\\ \\mathrm{s}$。\n- 情况 $2$：$\\alpha = 1.4\\times 10^{-7}\\ \\mathrm{m^2/s}$，$L = 0.02\\ \\mathrm{m}$，$T_0 = 293\\ \\mathrm{K}$，$T_s = 350\\ \\mathrm{K}$，$t_f = 10\\ \\mathrm{s}$，$N_x = 200$，$\\Delta t = 0.5\\ \\mathrm{s}$。\n- 情况 $3$：$\\alpha = 1.0\\times 10^{-5}\\ \\mathrm{m^2/s}$，$L = 0.02\\ \\mathrm{m}$，$T_0 = 300\\ \\mathrm{K}$，$T_s = 310\\ \\mathrm{K}$，$t_f = 200\\ \\mathrm{s}$，$N_x = 200$，$\\Delta t = 0.2\\ \\mathrm{s}$。\n- 情况 $4$：$\\alpha = 5.0\\times 10^{-6}\\ \\mathrm{m^2/s}$，$L = 0.05\\ \\mathrm{m}$，$T_0 = 300\\ \\mathrm{K}$，$T_s = 360\\ \\mathrm{K}$，$t_f = 200\\ \\mathrm{s}$，$N_x = 40$，$\\Delta t = 2.0\\ \\mathrm{s}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个四舍五入后的误差列表，按测试集的顺序排列，以逗号分隔，并用方括号括起来，例如\n$[e_1,e_2,e_3,e_4]$\n其中每个 $e_k$ 是情况 $k$ 的误差，单位为开尔文，四舍五入到六位小数（输出行中不含单位或多余空格）。", "solution": "所给出的问题是一个在截断空间域上关于一维热传导方程的适定初边值问题。需要计算一个数值解，并将其与对应于半无限域的给定解析解进行比较。\n\n该问题的验证如下。控制偏微分方程 $\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$ 是热传递的基本原理。初始条件和边界条件是标准的且具有物理意义。所有参数都以一致的单位给出。关键在于，对显式前向时间中心空间 (FTCS) 格式的稳定性参数 $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$ 进行分析，发现四个测试案例的 $s$ 值分别约为 $16$、$7$、$200$ 和 $6.4$。由于 FTCS 格式要求 $s \\le \\frac{1}{2}$ 才能保持稳定，因此显式方法将是极其不稳定的。这要求使用无条件稳定的隐式方法。因此，该问题在科学上是合理的，并且结构严谨，旨在测试此类方法的实现。\n\n选用 Crank-Nicolson 方法是因为其无条件稳定以及在时间和空间上都具有二阶精度 $O((\\Delta t)^2)$ 和 $O((\\Delta x)^2)$。该方法在时间区间 $[t_n, t_{n+1}]$ 的中点近似时间导数，并对两个时间层上的空间导数进行平均。令 $T_i^n$ 表示在网格点 $x_i = i\\Delta x$ 和时间 $t_n = n\\Delta t$ 处温度 $T(x_i, t_n)$ 的数值近似。热传导方程的 Crank-Nicolson 离散形式为：\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left[ \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} + \\frac{T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}}{(\\Delta x)^2} \\right] $$\n该方程适用于内部空间网格点 $i = 1, 2, \\dots, N_x - 1$。令 $r = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$。重新整理方程，将时间步 $n+1$ 的未知温度与时间步 $n$ 的已知温度分开，得到：\n$$ -r T_{i-1}^{n+1} + (1+2r) T_i^{n+1} - r T_{i+1}^{n+1} = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n $$\n这个方程组必须用边界条件来补充。空间网格有 $N_x+1$ 个点，索引从 $i=0$ 到 $i=N_x$。在每个时间步，需要求解的 $N_x$ 个未知数是 $T_1^{n+1}, \\dots, T_{N_x}^{n+1}$。\n\n在边界 $x=0$（对应于 $i=0$），应用狄利克雷条件 $T(0,t) = T_s$，因此对于所有 $n \\ge 0$，$T_0^n = T_s$。对于第一个未知数 $T_1^{n+1}$（即在 $i=1$ 处），已知的 $T_0^{n+1} = T_s$ 被移到方程的右边：\n$$ (1+2r) T_1^{n+1} - r T_2^{n+1} = (1-2r) T_1^n + r T_2^n + 2r T_s $$\n\n在边界 $x=L$（对应于 $i=N_x$），施加诺伊曼条件 $\\frac{\\partial T}{\\partial x}(L,t)=0$。这通过一个涉及“虚拟点” $x_{N_x+1} = L+\\Delta x$ 的二阶精度中心差分来近似。条件 $\\frac{T_{N_x+1} - T_{N_x-1}}{2\\Delta x} = 0$ 意味着 $T_{N_x+1} = T_{N_x-1}$。将此代入 $i=N_x$ 的通用 Crank-Nicolson 方程，得到最后一个未知数 $T_{N_x}^{n+1}$ 的方程：\n$$ -2r T_{N_x-1}^{n+1} + (1+2r) T_{N_x}^{n+1} = 2r T_{N_x-1}^n + (1-2r) T_{N_x}^n $$\n这些针对 $i = 1, \\dots, N_x$ 的方程构成了一个形式为 $\\mathbf{A} \\mathbf{U}^{n+1} = \\mathbf{b}^n$ 的线性系统，其中 $\\mathbf{U}^{n+1}$ 是未知温度的向量 $[T_1^{n+1}, \\dots, T_{N_x}^{n+1}]^T$。矩阵 $\\mathbf{A}$ 是一个常数、$N_x \\times N_x$ 的三对角矩阵：\n$$ \\mathbf{A} = \\begin{pmatrix}\n1+2r & -r & 0 & \\dots & \\dots & 0 \\\\\n-r & 1+2r & -r & \\ddots & & \\vdots \\\\\n0 & \\ddots & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & -r & 1+2r & -r & 0 \\\\\n\\vdots & & \\ddots & 0 & -2r & 1+2r\n\\end{pmatrix} $$\n右侧向量 $\\mathbf{b}^n$ 是根据时间 $n$ 的已知温度计算的：\n$$ b_1^n = (1-2r) T_1^n + r T_2^n + 2r T_s $$\n$$ b_i^n = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n \\quad \\text{对于 } i=2, \\dots, N_x-1 $$\n$$ b_{N_x}^n = 2r T_{N_x-1}^n + (1-2r) T_{N_x}^n $$\n数值求解过程首先设置初始温度分布：对于 $x>0$，$T(x,0) = T_0$；对于 $x=0$，$T(0,0)=T_s$。然后，对于从 $n=0$到 $N_t-1$ 的每个时间步，其中 $N_t=t_f/\\Delta t$，构造右侧向量 $\\mathbf{b}^n$ 并求解三对角系统 $\\mathbf{A} \\mathbf{U}^{n+1} = \\mathbf{b}^n$ 以找到下一时间步的温度。重复此过程直到达到最终时间 $t_f$。这种三对角系统可以使用科学计算库中可用的算法（如托马斯算法）高效求解。\n\n最后，在 $t=t_f$ 时，将计算出的数值解 $T_{\\text{num}}(x_i, t_f)$ 与半无限域的解析解 $T_{\\text{exact}}(x_i, t_f)$ 进行比较，并确定在所有网格点上的最大绝对误差 $E_{\\max}$。需要注意的是，此误差度量混合了数值离散误差和由域截断及近似远场边界条件引起的建模误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation for given test cases using the Crank-Nicolson method\n    and computes the maximum error against the analytical solution.\n    \"\"\"\n    # (alpha, L, T0, Ts, tf, Nx, dt)\n    test_cases = [\n        (1.0e-5, 0.1, 300.0, 400.0, 100.0, 400, 0.1),\n        (1.4e-7, 0.02, 293.0, 350.0, 10.0, 200, 0.5),\n        (1.0e-5, 0.02, 300.0, 310.0, 200.0, 200, 0.2),\n        (5.0e-6, 0.05, 300.0, 360.0, 200.0, 40, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, T0, Ts, tf, Nx, dt = case\n\n        # Discretization parameters\n        dx = L / Nx\n        # Note: The stability parameter for FTCS is alpha*dt/dx**2.\n        # The Crank-Nicolson parameter 'r' is defined with a factor of 2.\n        r = (alpha * dt) / (2 * dx**2)\n        Nt = int(round(tf / dt))\n\n        # --- Initial Condition ---\n        # T_current is the temperature vector at the current time step.\n        # It has Nx+1 points, from x=0 to x=L.\n        T_current = np.full(Nx + 1, T0)\n        T_current[0] = Ts # Boundary condition at x=0\n\n        # --- Set up the Crank-Nicolson matrix system A*U_next = b ---\n        # Matrix A is tridiagonal and constant through time.\n        # We use scipy.linalg.solve_banded which is efficient.\n        # The matrix A acts on the interior points plus the far boundary, so it is Nx x Nx.\n        \n        # 'ab' stores the bands of matrix A in a format required by solve_banded.\n        # For a (1,1) banded matrix A, ab is (3, Nx).\n        # ab[0, 1:] = upper diagonal\n        # ab[1, :]   = main diagonal\n        # ab[2, :-1] = lower diagonal\n        ab = np.zeros((3, Nx))\n\n        # Main diagonal\n        ab[1, :] = 1 + 2 * r\n\n        # Upper diagonal\n        ab[0, 1:] = -r\n\n        # Lower diagonal\n        ab[2, :-1] = -r\n        # Modification for Neumann boundary condition at x=L (i=Nx)\n        # This affects the last row of matrix A: A[Nx-1, Nx-2] = -2*r\n        # which corresponds to the last element of the lower diagonal band.\n        if Nx > 1:\n            ab[2, Nx - 2] = -2 * r\n\n        # --- Time-stepping loop ---\n        for _ in range(Nt):\n            # Construct the right-hand side vector b\n            b = np.zeros(Nx)\n\n            # Equation for the first interior point i=1 (vector index 0)\n            b[0] = (1 - 2 * r) * T_current[1] + r * T_current[2] + 2 * r * Ts\n\n            # Equations for interior points i=2 to Nx-1 (vector indices 1 to Nx-2)\n            # This loop is slow but clear. Vectorization is possible but complex to write.\n            for i in range(2, Nx):\n                b[i-1] = r * T_current[i-1] + (1 - 2 * r) * T_current[i] + r * T_current[i+1]\n\n            # Equation for the last point i=Nx (vector index Nx-1)\n            # This is only relevant if there's more than one unknown point\n            if Nx > 1:\n                b[Nx - 1] = 2 * r * T_current[Nx - 1] + (1 - 2 * r) * T_current[Nx]\n\n            # Solve the linear system for the unknown interior temperatures at the next time step\n            T_next_interior = solve_banded((1, 1), ab, b)\n            \n            # Update the temperature vector\n            T_current[1:] = T_next_interior\n            # T_current[0] is always Ts\n\n        # --- Error Calculation ---\n        # The numerical solution at t=tf is in T_current\n        T_numerical = T_current\n\n        # Calculate the exact solution at t=tf\n        x = np.linspace(0, L, Nx + 1)\n        # The argument of erfc can become infinite if t=0, but tf > 0 here.\n        argument = x / (2 * np.sqrt(alpha * tf))\n        T_exact = T0 + (Ts - T0) * erfc(argument)\n        \n        # Compute the maximum absolute error\n        max_error = np.max(np.abs(T_numerical - T_exact))\n        results.append(round(max_error, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402549"}, {"introduction": "虽然 Crank-Nicolson 方法准确且稳定，但在模拟具有尖锐梯度或不连续性的问题时，它可能会产生非物理振荡。本练习将介绍广义 $\\theta$ 方法，让您探索准确性与数值阻尼之间的权衡。通过经验性地找到最佳的 $\\theta$ 值，您将对数值稳定性以及如何确保模拟结果的物理真实性有更深入的理解 [@problem_id:2402615]。", "problem": "您将为线性热方程实现并测试一种基于广义 $\\theta$ 格式的完全隐式一维时间积分方法，然后通过经验确定能够消除与 Crank–Nicolson 格式相关的振荡的最小 $\\theta$ 值。所有变量均为无量纲。\n\n考虑在有限区间上具有固定狄利克雷边界数据的热方程：\n- 偏微分方程：$u_t = \\alpha\\,u_{xx}$，其中 $x \\in (0,L)$ 且 $t > 0$。\n- 区域长度：$L = 1$。\n- 扩散系数：$\\alpha = 1$。\n- 边界条件：$u(0,t) = 1$ 且 $u(L,t) = 0$，对于所有 $t \\ge 0$。\n- 初始条件：位于中点的单位阶跃函数，$u(x,0) = 1$ 当 $x < L/2$ 时，$u(x,0) = 0$ 当 $x \\ge L/2$ 时。\n\n使用包含 $N$ 个子区间（即包括边界在内共 $N+1$ 个网格点）的均匀网格对空间进行离散化，并使用均匀步长 $\\Delta t$ 对时间进行离散化。定义 $\\Delta x = L/N$ 以及无量纲比率 $r = \\alpha\\,\\Delta t/\\Delta x^2$，因此有 $\\Delta t = r\\,\\Delta x^2/\\alpha$。在内部网格点 $x_i = i\\,\\Delta x$（其中 $i = 1,2,\\dots,N-1$）上，使用标准的中心二阶差分来近似空间二阶导数，并使用有限差分来近似时间导数。广义 $\\theta$ 格式通过分别以权重 $\\theta$ 和 $(1-\\theta)$ 计算在时间 $t^{n+1}$ 和 $t^n$ 处的离散拉普拉斯算子，从而混合了对扩散项的隐式和显式处理。您必须从热方程和这些相容的离散化出发，推导出每个时间步中关于内部未知数的线性系统。\n\n振荡：已知对于标量测试方程，Crank–Nicolson 格式（选择 $\\theta = 1/2$）是 A-稳定的，但非 L-稳定，这在 $r$ 值中等偏大时，可能导致高频空间模态在时间上发生振荡衰减，从而在不连续点附近引起空间上的过冲和下冲。为了量化这一点，将给定时间 $t$ 的过冲度量定义为\n$$\n\\mathcal{M} = \\max\\{0,\\max_i u_i - 1\\} + \\max\\{0,-\\min_i u_i\\},\n$$\n即，在网格上（包括边界）任意位置处，解超过 $1$ 的量与低于 $0$ 的量的总和。\n\n您的任务是：\n- 针对一维热方程，在所述网格上根据指定的边界和初始数据，实现一个广义 $\\theta$ 格式的求解器。\n- 对于给定的 $(N,r,T,\\tau)$，其中 $T$ 为最终时间，$\\tau$ 为容差，凭经验确定\n$$\n\\theta^\\star = \\min\\{\\theta \\in [1/2,1]: \\mathcal{M}(\\theta;N,r,T) \\le \\tau\\},\n$$\n即区间 $[1/2,1]$ 中的最小 $\\theta$ 值，使得在时间 $T$ 的过冲度量小于或等于 $\\tau$。如果 $\\theta = 1/2$ 已经满足容差，则返回 $\\theta^\\star = 1/2$。如果在 $[1/2,1]$ 区间内没有 $\\theta$ 满足容差，则返回 $\\theta^\\star = 1$。\n- 利用 $\\theta$ 格式关于 $\\theta$ 的单调阻尼特性，采用一种稳健的搜索策略，以 $10^{-3}$ 的绝对精度找到 $\\theta^\\star$。\n\n推导基本依据：\n- 使用 $u_t = \\alpha u_{xx}$、$\\Delta x$、$\\Delta t$ 和 $r$ 的定义、用于 $u_{xx}$ 的中心二阶差分、以及用于 $u_t$ 的相容有限差分，并结合广义 $\\theta$ 混合的空间项。在每个时间步精确地引入狄利克雷边界条件。\n\n数值要求：\n- 空间用 $N$ 个子区间（即 $N+1$ 个节点）进行离散化。时间步长使用 $\\Delta t = r\\,\\Delta x^2$（其中 $\\alpha = 1$ 且 $L=1$）。使用等于 $\\lceil T / \\Delta t \\rceil$ 的时间步数将解从 $t=0$ 推进到 $t \\approx T$，并在最后一个步长处计算 $\\mathcal{M}$。\n- 内部节点上的初始条件为阶跃函数：如果 $x_i < 1/2$，则 $u_i^0 = 1$，否则 $u_i^0 = 0$。边界条件满足 $u_0^n = 1$ 和 $u_N^n = 0$ 对所有 $n$ 成立。\n\n测试套件：\n为以下参数集 $(N,r,T,\\tau)$ 提供结果：\n- 案例 1：$(N,r,T,\\tau) = (200,\\,1.0,\\,0.02,\\,10^{-3})$。\n- 案例 2：$(N,r,T,\\tau) = (200,\\,2.0,\\,0.02,\\,10^{-3})$。\n- 案例 3：$(N,r,T,\\tau) = (200,\\,0.6,\\,0.02,\\,10^{-3})$。\n- 案例 4：$(N,r,T,\\tau) = (200,\\,0.2,\\,0.02,\\,10^{-3})$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为上述案例的结果，顺序不变，每个 $\\theta^\\star$ 值需精确四舍五入到小数点后三位（例如，$[0.500,0.625,0.575,0.500]$）。", "solution": "所提出的问题是有效的。这是一个计算物理学领域中关于一维热方程数值解的适定、有科学依据的问题。所有参数、条件和目标都得到了清晰、客观的定义。我们将着手提供一个完整的解决方案。\n\n基本任务是求解线性热方程，并凭经验确定一种广义时间积分格式中的参数 $\\theta$ 的最小值，该值能将非物理振荡抑制在给定容差范围内。\n\n控制偏微分方程(PDE)是一维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n该方程描述了函数 $u(x,t)$ 在区域 $x \\in (0, L)$ 且 $t > 0$ 上的行为。给定的参数为区域长度 $L=1$ 和热扩散系数 $\\alpha=1$。该系统受固定的狄利克雷边界条件和不连续的初始条件约束：\n- 边界条件 (BCs)：$u(0,t) = 1$ 且 $u(L,t) = 0$，对于 $t \\ge 0$。\n- 初始条件 (IC)：$u(x,0) = 1$ 当 $x < L/2$ 时，$u(x,0) = 0$ 当 $x \\ge L/2$ 时。\n\n我们使用均匀网格对区域进行离散化。空间域 $x \\in [0, L]$ 被划分为 $N$ 个宽度为 $\\Delta x = L/N$ 的子区间。网格点为 $x_i = i \\Delta x$，其中 $i = 0, 1, \\dots, N$。时间域用均匀的时间步长 $\\Delta t$ 进行离散化。令 $u_i^n$ 表示 $u(x_i, t^n)$ 的数值近似，其中 $t^n = n \\Delta t$。无量纲参数 $r$ 定义为 $r = \\alpha \\Delta t / \\Delta x^2$。根据问题给定的值 $L=1$ 和 $\\alpha=1$，我们有 $\\Delta x = 1/N$ 和 $\\Delta t = r/N^2$。\n\n热方程的广义 $\\theta$ 格式是通过用前向差分近似时间导数，并用在时间层 $n$ 和 $n+1$ 处计算的中心差分的加权平均来近似空间二阶导数而构建的：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\left[ \\theta \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{\\Delta x^2} \\right) + (1-\\theta) \\left( \\frac{u_{i-1}^{n} - 2u_i^{n} + u_{i+1}^{n}}{\\Delta x^2} \\right) \\right]\n$$\n此格式适用于内部网格点，即 $i = 1, 2, \\dots, N-1$。参数 $\\theta \\in [0, 1]$ 控制了隐式程度：$\\theta=0$ 得到显式前向欧拉法，$\\theta=1/2$ 得到 Crank-Nicolson 方法，而 $\\theta=1$ 得到完全隐式后向欧拉法。\n\n为了推导关于未知值 $u_i^{n+1}$ 的线性系统，我们两边乘以 $\\Delta t$ 并代入 $r = \\alpha \\Delta t / \\Delta x^2$：\n$$\nu_i^{n+1} - u_i^n = r \\theta (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) + r(1-\\theta) (u_{i-1}^{n} - 2u_i^{n} + u_{i+1}^{n})\n$$\n我们通过将所有在新的时间层 $n+1$ 上的项归到左侧 (LHS)，并将所有在当前时间层 $n$ 上的项归到右侧 (RHS) 来重排此方程：\n$$\n-r\\theta u_{i-1}^{n+1} + (1 + 2r\\theta)u_i^{n+1} - r\\theta u_{i+1}^{n+1} = r(1-\\theta)u_{i-1}^{n} + (1 - 2r(1-\\theta))u_i^n + r(1-\\theta)u_{i+1}^{n}\n$$\n这代表了一个包含 $N-1$ 个未知内部值 $\\{u_i^{n+1}\\}_{i=1}^{N-1}$ 的 $N-1$ 个线性方程组。我们可以将该系统写成矩阵形式 $\\mathbf{A} \\mathbf{u}^{n+1}_{\\text{int}} = \\mathbf{b}$，其中 $\\mathbf{u}^{n+1}_{\\text{int}} = (u_1^{n+1}, \\dots, u_{N-1}^{n+1})^T$。\n\n矩阵 $\\mathbf{A}$ 是一个由 $r$ 和 $\\theta$ 定义的具有常数项的 $(N-1) \\times (N-1)$ 对称三对角矩阵：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1+2r\\theta & -r\\theta & & \\\\\n-r\\theta & 1+2r\\theta & -r\\theta & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -r\\theta & 1+2r\\theta & -r\\theta \\\\\n& & & -r\\theta & 1+2r\\theta\n\\end{pmatrix}\n$$\n右端向量 $\\mathbf{b}$ 取决于时间 $n$ 的已知解以及边界条件。边界条件为对所有 $n$ 都有 $u_0^n = 1$ 和 $u_N^n = 0$。这些已知值会修正系统的第一个和最后一个方程。\n\n对于 $i=1$：\n$$\n-r\\theta u_0^{n+1} + (1+2r\\theta)u_1^{n+1} - r\\theta u_2^{n+1} = r(1-\\theta)u_0^n + (1 - 2r(1-\\theta))u_1^n + r(1-\\theta)u_2^n\n$$\n将已知的边界项 $u_0^{n+1}=1$ 和 $u_0^n=1$ 移到右端项（RHS），可得：\n$$\n(1+2r\\theta)u_1^{n+1} - r\\theta u_2^{n+1} = r\\theta(1) + r(1-\\theta)(1) + (1 - 2r(1-\\theta))u_1^n + r(1-\\theta)u_2^n\n$$\n第一个方程的右端项变为 $b_1 = r + (1 - 2r(1-\\theta))u_1^n + r(1-\\theta)u_2^n$。\n\n对于 $i=N-1$：\n$$\n-r\\theta u_{N-2}^{n+1} + (1+2r\\theta)u_{N-1}^{n+1} - r\\theta u_N^{n+1} = \\dots\n$$\n涉及 $u_N^{n+1}=0$ 和 $u_N^n=0$ 的边界项消失。最后一个方程的右端项是 $b_{N-1} = r(1-\\theta)u_{N-2}^n + (1 - 2r(1-\\theta))u_{N-1}^n$。\n\n时间步进过程如下：\n1. 根据初始条件(IC)和边界条件(BCs)初始化解向量 $\\mathbf{u}^0$。\n2. 对从 $n=0$ 到 $n_{\\text{steps}}-1 = \\lceil T/\\Delta t \\rceil-1$ 的每个时间步：\n    a. 使用解 $\\mathbf{u}^n$ 构建右端向量 $\\mathbf{b}$。\n    b. 求解三对角系统 $\\mathbf{A} \\mathbf{u}^{n+1}_{\\text{int}} = \\mathbf{b}$ 以找到下一个时间步的内部解。这可以通过使用例如托马斯算法（TDMA）等具有 $O(N)$ 线性时间复杂度的算法来高效完成。\n3. 在最后一个时间步之后，计算过冲度量 $\\mathcal{M}$：\n$$\n\\mathcal{M} = \\max\\{0, \\max_i u_i - 1\\} + \\max\\{0, -\\min_i u_i\\}\n$$\n该度量量化了对极值原理的总体违背程度；对于连续热方程，解必须保持在初始和边界数据的最小值和最大值之间，即 $u(x,t) \\in [0, 1]$。数值格式可能会违背这一点，特别是对于此处给出的非光滑初始数据。\n\n问题要求找到 $\\theta^\\star = \\min\\{\\theta \\in [1/2, 1] | \\mathcal{M}(\\theta) \\le \\tau\\}$，其中 $\\tau$ 是一个很小的容差。对于 $\\theta \\in [1/2, 1]$，度量 $\\mathcal{M}(\\theta)$ 是关于 $\\theta$ 的单调递减函数，因为增加 $\\theta$ 会增强格式的数值阻尼。这种单调行为允许使用二分法高效地搜索 $\\theta^\\star$。\n\n搜索 $\\theta^\\star$ 的算法如下：\n1. 定义搜索区间 $[\\theta_{\\text{low}}, \\theta_{\\text{high}}] = [1/2, 1]$。\n2. 首先，检查 $\\theta=1/2$ 时的过冲。如果 $\\mathcal{M}(1/2) \\le \\tau$，则 $\\theta^\\star = 1/2$。\n3. 如果不满足，则检查 $\\theta=1$。如果 $\\mathcal{M}(1) > \\tau$，则区间内没有解满足标准，我们必须返回 $\\theta^\\star=1$。\n4. 否则，执行二分搜索：\n   - 当 $(\\theta_{\\text{high}} - \\theta_{\\text{low}})$ 大于期望的精度 $10^{-3}$ 时：\n     - 设置 $\\theta_{\\text{mid}} = (\\theta_{\\text{low}} + \\theta_{\\text{high}})/2$。\n     - 计算 $\\mathcal{M}(\\theta_{\\text{mid}})$。\n     - 如果 $\\mathcal{M}(\\theta_{\\text{mid}}) \\le \\tau$，意味着找到了一个有效的 $\\theta$，因此我们尝试通过设置 $\\theta_{\\text{high}} = \\theta_{\\text{mid}}$ 来寻找更小的值。\n     - 如果 $\\mathcal{M}(\\theta_{\\text{mid}}) > \\tau$，说明 $\\theta_{\\text{mid}}$ 太小，我们必须通过设置 $\\theta_{\\text{low}} = \\theta_{\\text{mid}}$ 来寻找更大的值。\n5. 最终得到的 $\\theta_{\\text{high}}$ 就是 $\\theta^\\star$ 的期望近似值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef _calculate_overshoot(theta, N, r, T):\n    \"\"\"\n    Solves the 1D heat equation using the generalized theta-scheme and calculates\n    the overshoot metric M at the final time.\n    \"\"\"\n    # System parameters\n    L = 1.0\n    alpha = 1.0\n    \n    # Discretization\n    dx = L / N\n    dt = r * dx**2 / alpha\n    num_steps = int(np.ceil(T / dt))\n\n    # Initial condition\n    x = np.linspace(0, L, N + 1)\n    u = np.where(x < L / 2, 1.0, 0.0)\n    \n    # Enforce boundary conditions on the initial state\n    u[0] = 1.0\n    u[N] = 0.0\n    \n    # Extract interior points for time marching\n    u_int = u[1:N].copy()\n    \n    # Set up the tridiagonal system for the implicit part: A * u_new = b\n    # A is constant throughout the simulation for fixed theta and r.\n    diag_A = 1 + 2 * r * theta\n    offdiag_A = -r * theta\n    A_banded = np.zeros((3, N - 1))\n    A_banded[0, 1:] = offdiag_A\n    A_banded[1, :] = diag_A\n    A_banded[2, :-1] = offdiag_A\n\n    # RHS contribution from a portion of the explicit scheme and boundary conditions\n    r_expl = r * (1 - theta)\n    # The vector d contains contributions from boundary conditions.\n    # For a constant BC u_0=1, the total contribution is r*(1-theta)*u_0^n + r*theta*u_0^{n+1} = r.\n    # For u_N=0, the contribution is 0.\n    d = np.zeros(N - 1)\n    d[0] = r\n\n    # Time marching loop\n    for _ in range(num_steps):\n        # Calculate the RHS vector b = B*u_int + d, where B is the explicit matrix.\n        # This is implemented via direct vector operations for efficiency.\n        b = np.empty(N - 1)\n        \n        # Interior of the RHS vector\n        b[1:-1] = r_expl * u_int[:-2] + (1 - 2 * r_expl) * u_int[1:-1] + r_expl * u_int[2:]\n        \n        # First element (affected by u_0=1 BC)\n        b[0] = (1 - 2 * r_expl) * u_int[0] + r_expl * u_int[1]\n        \n        # Last element (affected by u_N=0 BC, which adds nothing)\n        b[-1] = r_expl * u_int[-2] + (1 - 2 * r_expl) * u_int[-1]\n        \n        # Add the boundary contributions vector\n        b += d\n        \n        # Solve the tridiagonal system for the next time step's interior values\n        u_int = solve_banded((1, 1), A_banded, b, check_finite=False)\n\n    # Reconstruct full solution vector with final boundaries\n    u_final = np.concatenate(([1.0], u_int, [0.0]))\n\n    # Calculate the overshoot metric M\n    overshoot = np.maximum(0, u_final.max() - 1.0)\n    undershoot = np.maximum(0, -u_final.min())\n    metric = overshoot + undershoot\n    \n    return metric\n\ndef find_theta_star(N, r, T, tau):\n    \"\"\"\n    Finds the smallest theta in [0.5, 1.0] for which the overshoot metric\n    is below a tolerance tau, using a bisection search.\n    \"\"\"\n    theta_low = 0.5\n    theta_high = 1.0\n    accuracy = 1e-3\n\n    # Check the lower bound (Crank-Nicolson) first.\n    m_low = _calculate_overshoot(theta_low, N, r, T)\n    if m_low <= tau:\n        return theta_low\n    \n    # Check the upper bound (Fully Implicit). If it fails, no solution in range.\n    m_high = _calculate_overshoot(theta_high, N, r, T)\n    if m_high > tau:\n        return theta_high\n\n    # Bisection search for the optimal theta\n    while (theta_high - theta_low) > accuracy:\n        theta_mid = (theta_low + theta_high) / 2.0\n        m_mid = _calculate_overshoot(theta_mid, N, r, T)\n        \n        if m_mid <= tau:\n            # Condition met, try for a smaller theta (less damping)\n            theta_high = theta_mid\n        else:\n            # Condition not met, need a larger theta (more damping)\n            theta_low = theta_mid\n            \n    return theta_high\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, r, T, tau)\n        (200, 1.0, 0.02, 1e-3),\n        (200, 2.0, 0.02, 1e-3),\n        (200, 0.6, 0.02, 1e-3),\n        (200, 0.2, 0.02, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, r, T, tau = case\n        theta_star = find_theta_star(N, r, T, tau)\n        results.append(f\"{theta_star:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2402615"}, {"introduction": "现实世界中的热传递问题很少是一维的。这项实践将您的技能扩展到二维，通过模拟方形板上的热耗散。您将实施交替方向隐式（ADI）方法，这是一种高效的技术，它通过将问题分解为一系列一维求解，避免了完全二维隐式求解器带来的巨大计算成本。此练习对于处理更真实、多维的物理模拟至关重要 [@problem_id:2402582]。", "problem": "考虑一个方形域上的二维热扩散问题，由以下偏微分方程 (PDE) 控制：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2}\\right),\n$$\n该方程作用于方形板 $\\Omega = [0,L]\\times[0,L]$ 上，并具有恒定的狄利克雷边界条件\n$$\nT(x,y,t) = T_b \\quad \\text{for all } (x,y)\\in \\partial \\Omega, \\; t \\ge 0,\n$$\n以及如下形式的初始条件\n$$\nT(x,y,0) = T_b + A \\exp\\left(-\\frac{(x - L/2)^2 + (y - L/2)^2}{2\\sigma^2}\\right).\n$$\n使用一个包含 $N\\times N$ 个点的均匀笛卡尔网格，空间步长 $\\Delta x = \\Delta y = L/(N-1)$，以及均匀的时间步长 $\\Delta t$。从 $t=0$ 开始，演化温度直至最终时间 $t_{\\text{final}}$。所有温度必须以开尔文 (K) 为单位，所有长度以米 (m) 为单位，所有时间以秒 (s) 为单位。\n\n您的任务是为下面列出的每个测试用例计算以下两个量：\n- 在时间 $t=t_{\\text{final}}$ 时，板中心网格点 $(x=L/2,y=L/2)$ 处的温度 (开尔文)。\n- 在时间 $t=t_{\\text{final}}$ 时，所有网格点上的最高温度 (开尔文)。\n\n假设 $N$ 为奇数，因此网格包含精确的中心点 $(L/2,L/2)$。对于所有 $t \\ge 0$，将边界值视为固定在 $T_b$。\n\n测试套件 (每个用例指定 $(L,\\alpha,T_b,A,\\sigma,\\Delta t,t_{\\text{final}},N)$)：\n- 用例 1：$L=0.1$ m, $\\alpha=1.0\\times 10^{-4}$ m$^2$/s, $T_b=300.0$ K, $A=100.0$ K, $\\sigma=0.01$ m, $\\Delta t=2.5\\times 10^{-4}$ s, $t_{\\text{final}}=0.01$ s, $N=41$。\n- 用例 2：$L=0.1$ m, $\\alpha=1.0\\times 10^{-4}$ m$^2$/s, $T_b=300.0$ K, $A=50.0$ K, $\\sigma=0.02$ m, $\\Delta t=1.0\\times 10^{-3}$ s, $t_{\\text{final}}=0.01$ s, $N=5$。\n- 用例 3：$L=0.1$ m, $\\alpha=1.0\\times 10^{-4}$ m$^2$/s, $T_b=300.0$ K, $A=0.0$ K, $\\sigma=0.01$ m, $\\Delta t=1.0\\times 10^{-3}$ s, $t_{\\text{final}}=0.02$ s, $N=31$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含两个元素的列表 $[T_{\\text{center}},T_{\\max}]$，单位为开尔文。对于以上三个用例，要求的格式为\n[[T_center_case1,T_max_case1],[T_center_case2,T_max_case2],[T_center_case3,T_max_case3]]\n打印输出中不含空格 (例如: [[300.123456,350.654321],[...],[...]])。这些值是单位为开尔文的实数。", "solution": "该问题陈述已被验证且视为有效。它提出了一个针对二维热方程的适定的初边值问题，这是物理学中的一个基本模型。所有参数和条件都已明确指定，从而可以得到一个唯一、稳定且有意义的数值解。\n\n该问题要求数值求解二维热方程：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2}\\right)\n$$\n该方程作用于一个方形域 $\\Omega = [0,L]\\times[0,L]$ 上，空间网格为 $N \\times N$ 个点。边界温度固定为 $T(x,y,t) = T_b$（对于 $(x,y) \\in \\partial\\Omega$），初始温度分布由一个叠加在边界温度上的高斯函数给出。\n\n对于这种抛物型偏微分方程的数值解，由于其无条件稳定性的特性，隐式有限差分法是合适的。交替方向隐式 (ADI) 方法，特别是 Peaceman-Rachford 格式，是解决二维问题的有效选择。该方法通过将每个时间步 $\\Delta t$ 分裂成两个大小为 $\\Delta t / 2$ 的半步来解耦维度，从而将庞大的二维问题转化为一系列可以高效求解的、较小的、独立的一维问题。\n\n令 $T_{i,j}^n$ 表示在时间 $t_n = n\\Delta t$ 时网格点 $(x_i, y_j)$ 处的温度。空间网格步长为 $\\Delta x = \\Delta y = L/(N-1)$。\n\nADI 格式通过两个半步将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$：\n\n步骤 1：从 $t_n$ 推进到中间时刻 $t_{n+1/2} = t_n + \\Delta t/2$。\n在这一步中，该格式在 $x$ 方向上是隐式的，在 $y$ 方向上是显式的。有限差分方程为：\n$$\n\\frac{T_{i,j}^{n+1/2} - T_{i,j}^n}{\\Delta t/2} = \\alpha \\left( \\frac{T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2}}{\\Delta x^2} + \\frac{T_{i,j-1}^n - 2T_{i,j}^n + T_{i,j+1}^n}{\\Delta y^2} \\right)\n$$\n令 $r = \\frac{\\alpha \\Delta t}{2\\Delta x^2}$ (因为 $\\Delta x = \\Delta y$)。将各项重新整理，把时间层 $n+1/2$ 的未知数分组到左侧，我们得到：\n$$\n-r T_{i-1,j}^{n+1/2} + (1+2r) T_{i,j}^{n+1/2} - r T_{i+1,j}^{n+1/2} = T_{i,j}^n + r (T_{i,j-1}^n - 2T_{i,j}^n + T_{i,j+1}^n)\n$$\n此方程为每个内部行 $j \\in \\{1, 2, \\dots, N-2\\}$ 建立。对于一个固定的 $j$，这是一个关于未知温度 $T_{i,j}^{n+1/2}$ (对于 $i \\in \\{1, 2, \\dots, N-2\\}$) 的三对角线性方程组。边界值 $T_{0,j}^{n+1/2}$ 和 $T_{N-1,j}^{n+1/2}$ 是已知的，且等于 $T_b$。这些方程组可以使用 Thomas 算法（三对角矩阵算法）高效求解。\n\n步骤 2：从 $t_{n+1/2}$ 推进到 $t_{n+1}$。\n在这一步中，该格式在 $x$ 方向上是显式的，在 $y$ 方向上是隐式的：\n$$\n\\frac{T_{i,j}^{n+1} - T_{i,j}^{n+1/2}}{\\Delta t/2} = \\alpha \\left( \\frac{T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2}}{\\Delta x^2} + \\frac{T_{i,j-1}^{n+1} - 2T_{i,j}^{n+1} + T_{i,j+1}^{n+1}}{\\Delta y^2} \\right)\n$$\n重新整理后，得到一个关于 $y$ 方向的三对角系统：\n$$\n-r T_{i,j-1}^{n+1} + (1+2r) T_{i,j}^{n+1} - r T_{i,j+1}^{n+1} = T_{i,j}^{n+1/2} + r(T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2})\n$$\n此方程为每个内部列 $i \\in \\{1, 2, \\dots, N-2\\}$ 建立。对于一个固定的 $i$，这将形成一个关于未知数 $T_{i,j}^{n+1}$ (对于 $j \\in \\{1, 2, \\dots, N-2\\}$) 的三对角系统。边界值 $T_{i,0}^{n+1}$ 和 $T_{i,N-1}^{n+1}$ 是已知的，且等于 $T_b$。这些系统同样使用 Thomas 算法求解。\n\n总体算法如下：\n1.  **初始化**：定义模拟参数 $(L, \\alpha, T_b, A, \\sigma, \\Delta t, t_{\\text{final}}, N)$。构建空间网格 $x_i, y_j$。计算总时间步数 $N_t = \\lceil t_{\\text{final}} / \\Delta t \\rceil$。使用给定的高斯函数初始化 $t=0$ 时的温度场 $T$。边界点保持固定在 $T_b$。预先计算参数 $r$。构建用于线性求解的恒定三对角矩阵。\n\n2.  **时间演化**：对 $n$ 从 $0$ 到 $N_t-1$ 进行循环：\n    a. 创建一个中间温度数组 $T_{\\text{intermediate}}$。\n    b. 对于每个内部行 $j$，根据 $T^n$ 中的已知值组装右侧向量，并求解三对角系统以得到 $T_{\\text{intermediate}}$ 中的相应行。通过调整右侧向量来施加边界值。\n    c. 对于每个内部列 $i$，根据 $T_{\\text{intermediate}}$ 中的已知值组装右侧向量，并求解三对角系统以得到新温度数组 $T^{n+1}$ 中的相应列。\n    d. 更新温度数组：$T \\leftarrow T^{n+1}$。\n\n3.  **结果提取**：在最后一个时间步之后，得到在 $t=t_{\\text{final}}$ 时的温度场 $T$。中心网格点的温度 $T_{\\text{center}}$ 在索引 $((N-1)/2, (N-1)/2)$ 处找到。最高温度 $T_{\\max}$ 通过取整个网格上的最大值找到。\n\n由于域、边界条件和初始条件的对称性，预期最高温度在整个模拟过程中将保持在板的几何中心。因此，预期在 $t_{\\text{final}}$ 时，$T_{\\text{center}} = T_{\\max}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_case(params):\n    \"\"\"\n    Solves the 2D heat equation for a single test case using the ADI method.\n    \"\"\"\n    L, alpha, T_b, A, sigma, dt, t_final, N = params\n    \n    # 1. Initialization\n    dx = L / (N - 1)\n    # The problem asks to treat N as odd, so center index is integer\n    center_idx = (N - 1) // 2\n\n    # Create spatial grid\n    x = np.linspace(0, L, N)\n    y = np.linspace(0, L, N)\n    X, Y = np.meshgrid(x, y)\n\n    # Initialize temperature field from IC\n    T = T_b + A * np.exp(-((X - L/2)**2 + (Y - L/2)**2) / (2 * sigma**2))\n    \n    # Enforce boundary conditions (though IC should be consistent)\n    T[0, :] = T_b\n    T[-1, :] = T_b\n    T[:, 0] = T_b\n    T[:, -1] = T_b\n\n    # ADI parameters\n    r = (alpha * dt) / (2 * dx**2)\n    num_steps = int(np.ceil(t_final / dt))\n\n    # Construct the tridiagonal matrix for the linear solver.\n    # The matrix is for an (N-2) x (N-2) system (interior points).\n    M = N - 2\n    # For solve_banded, the matrix is specified in banded format (3, M)\n    # ab[0,:] = upper diagonal (length M, first element unused)\n    # ab[1,:] = main diagonal (length M)\n    # ab[2,:] = lower diagonal (length M, last element unused)\n    ab = np.zeros((3, M))\n    ab[0, 1:] = -r\n    ab[1, :] = 1 + 2 * r\n    ab[2, :-1] = -r\n    \n    # 2. Time Evolution\n    T_intermediate = np.copy(T)\n\n    for _ in range(num_steps):\n        # --- Step 1: Implicit in x, explicit in y ---\n        for j in range(1, N - 1): # Iterate over interior rows\n            # Construct RHS vector d\n            d = T[j, 1:-1] + r * (T[j-1, 1:-1] - 2*T[j, 1:-1] + T[j+1, 1:-1])\n            # Add boundary contributions\n            d[0] += r * T_b  # Boundary at x=0\n            d[-1] += r * T_b # Boundary at x=L\n\n            # Solve the tridiagonal system for the current row\n            T_intermediate[j, 1:-1] = solve_banded((1, 1), ab, d)\n        \n        # Enforce BC on intermediate solution\n        T_intermediate[0, :] = T_b\n        T_intermediate[-1, :] = T_b\n        T_intermediate[:, 0] = T_b\n        T_intermediate[:, -1] = T_b\n\n        # --- Step 2: Implicit in y, explicit in x ---\n        for i in range(1, N - 1): # Iterate over interior columns\n            # Construct RHS vector d\n            d = T_intermediate[1:-1, i] + r * (T_intermediate[1:-1, i-1] - 2*T_intermediate[1:-1, i] + T_intermediate[1:-1, i+1])\n            # Add boundary contributions\n            d[0] += r * T_b # Boundary at y=0\n            d[-1] += r * T_b # Boundary at y=L\n\n            # Solve the tridiagonal system for the current column\n            T[1:-1, i] = solve_banded((1, 1), ab, d)\n        \n        # Enforce BC on final solution for the step\n        T[0, :] = T_b\n        T[-1, :] = T_b\n        T[:, 0] = T_b\n        T[:, -1] = T_b\n        \n    # 3. Result Extraction\n    T_center = T[center_idx, center_idx]\n    T_max = np.max(T)\n    \n    return [T_center, T_max]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, T_b, A, sigma, dt, t_final, N)\n        (0.1, 1.0e-4, 300.0, 100.0, 0.01, 2.5e-4, 0.01, 41),\n        (0.1, 1.0e-4, 300.0, 50.0, 0.02, 1.0e-3, 0.01, 5),\n        (0.1, 1.0e-4, 300.0, 0.0, 0.01, 1.0e-3, 0.02, 31),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Format the output string as required\n    results_str = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2402582"}]}