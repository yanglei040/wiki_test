{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本次动手实践的第一个练习将引导您为一维热方程实现经典 Crank-Nicolson (CN) 格式。这个练习的重点是将离散化方程转化为一个三对角线性系统，并利用高效的求解器进行时间演化，这是掌握 CN 方法的基础。[@problem_id:2383934]", "problem": "考虑单位区间上的一维扩散（热）方程，其具有齐次狄利克雷边界条件和光滑初始条件。设 $x \\in (0,1)$ 且 $t \\in [0,T]$。该偏微分方程为\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad u(0,t)=0,\\quad u(1,t)=0,\\quad u(x,0) = \\sin(\\pi x),\n$$\n其中 $\\kappa > 0$ 是一个常数扩散系数，所有量均为无量纲。\n\n用 $N_x$ 个子区间对空间域进行均匀离散，使得网格间距为 $\\Delta x = 1/N_x$，内部网格点为 $x_i = i\\,\\Delta x$（其中 $i=1,2,\\dots,N_x-1$）。用均匀时间步长 $\\Delta t > 0$ 对时间进行离散，使得 $t^n = n\\,\\Delta t$ 且 $T = N_t\\,\\Delta t$，其中 $N_t$ 为某个非负整数。使用 Crank–Nicolson 时间离散格式，结合内部网格上空间二阶导数的标准二阶中心有限差分，将离散解从 $t^0$ 演化到 $t^{N_t}$，同时满足 $x=0$ 和 $x=1$ 处的齐次狄利克雷边界值。\n\n将时间层 $n$ 的离散内部向量定义为 $\\mathbf{u}^n \\in \\mathbb{R}^{N_x-1}$，其分量为 $u_i^n \\approx u(x_i,t^n)$。令离散拉普拉斯算子 $\\mathcal{L}_h$ 作用于内部向量的方式为\n$$\n(\\mathcal{L}_h \\mathbf{v})_i = \\frac{v_{i-1} - 2 v_i + v_{i+1}}{(\\Delta x)^2}, \\quad i=1,\\dots,N_x-1,\n$$\n并约定 $v_0 = 0$ 和 $v_{N_x} = 0$ 以强制施加齐次狄利克雷边界条件。Crank–Nicolson 更新由以下线性系统定义\n$$\n\\left(I - \\frac{\\kappa \\Delta t}{2}\\,\\mathcal{L}_h\\right)\\mathbf{u}^{n+1} = \\left(I + \\frac{\\kappa \\Delta t}{2}\\,\\mathcal{L}_h\\right)\\mathbf{u}^{n}, \\quad n=0,1,\\dots,N_t-1,\n$$\n初始数据为 $u_i^0 = \\sin(\\pi x_i)$。\n\n为进行验证，使用精确解\n$$\nu_{\\text{exact}}(x,t) = \\sin(\\pi x)\\, e^{-\\kappa \\pi^2 t}.\n$$\n使用离散 $L^2$ 范数在最终时间 $T$ 测量误差\n$$\n\\| \\mathbf{e} \\|_{2,h} = \\left( \\Delta x \\sum_{i=1}^{N_x-1} \\left(u_i^{N_t} - u_{\\text{exact}}(x_i,T)\\right)^2 \\right)^{1/2}.\n$$\n\n您的任务是编写一个完整的、可运行的程序，通过上述格式构建在时间 $T$ 的内部网格离散解，并计算以下每个测试用例的离散 $L^2$ 误差。所有量均为无量纲，无需物理单位。\n\n测试套件（每个元组为 $(\\kappa, N_x, \\Delta t, T)$）：\n- 测试 A: $(1.0, 50, 0.0025, 0.1)$\n- 测试 B: $(0.5, 80, 0.001, 0.05)$\n- 测试 C: $(1.0, 10, 0.025, 0.1)$\n- 测试 D: $(1.0, 40, 0.01, 0.0)$\n\n对于每个测试，假设 $T / \\Delta t$ 是一个整数，并使用恰好 $N_t = T / \\Delta t$ 个时间步。在内部网格点上用 $u_i^0 = \\sin(\\pi x_i)$ 进行初始化。对于 $T=0$ 的测试，该格式应执行零个时间步，并直接将初始条件与时间 $T=0$ 时的精确解进行比较。\n\n最终输出格式：您的程序应生成单行输出，其中包含测试 [A,B,C,D] 的最终离散 $L^2$ 误差，格式为方括号内以逗号分隔的列表，并四舍五入到 $8$ 位小数（例如，$[0.00000000,0.12345678,0.00000001,0.31415927]$）。不应打印任何其他文本。", "solution": "所呈现的问题是一维扩散方程的数值解，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t)\n$$\n其空间域为 $x \\in (0,1)$，边界条件为齐次狄利克雷条件 $u(0,t) = 0$, $u(1,t) = 0$，初始条件为 $u(x,0) = \\sin(\\pi x)$。该问题是适定的，并且所有提供的参数都已明确定义。我们使用指定的 Crank–Nicolson 格式来构建数值解。\n\n首先，我们对域进行离散化。空间域 $[0,1]$ 被划分为 $N_x$ 个宽度为 $\\Delta x = 1/N_x$ 的子区间。内部网格点为 $x_i = i\\Delta x$，其中 $i = 1, 2, \\dots, N_x-1$。时间域以均匀步长 $\\Delta t$ 离散，使得 $t^n = n\\Delta t$。在这些点上的数值解记为 $u_i^n \\approx u(x_i, t^n)$。\n\nCrank–Nicolson 方法在半时间步 $t^{n+1/2} = t^n + \\Delta t/2$ 处用中心差分近似时间导数，并通过平均时间层 $n$ 和 $n+1$ 处的值来近似空间二阶导数。针对我们的偏微分方程的格式为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\kappa}{2} \\left( \\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_i, t^{n+1}} + \\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_i, t^n} \\right)\n$$\n我们对空间导数采用标准的二阶中心差分：\n$$\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_i, t^n} \\approx \\frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{(\\Delta x)^2}\n$$\n将此近似代入格式，得到内部点 $i=1, \\dots, N_x-1$ 的全离散方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\kappa}{2} \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{(\\Delta x)^2} + \\frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{(\\Delta x)^2} \\right)\n$$\n边界条件 $u(0,t)=0$ 和 $u(1,t)=0$ 意味着对于所有 $n$，网格边界上的值为 $u_0^n = 0$ 和 $u_{N_x}^n = 0$。\n\n为了更紧凑的表示，我们将时间层 $n+1$ 的项组合在左侧，将时间层 $n$ 的项组合在右侧。我们定义无量纲参数 $\\alpha = \\frac{\\kappa \\Delta t}{2(\\Delta x)^2}$。方程变为：\n$$\n-\\alpha u_{i-1}^{n+1} + (1+2\\alpha)u_i^{n+1} - \\alpha u_{i+1}^{n+1} = \\alpha u_{i-1}^{n} + (1-2\\alpha)u_i^{n} + \\alpha u_{i+1}^{n}\n$$\n这代表了关于时间 $n+1$ 处未知解值向量 $\\mathbf{u}^{n+1} = [u_1^{n+1}, u_2^{n+1}, \\dots, u_{N_x-1}^{n+1}]^T$ 的一个线性方程组。以矩阵形式，该系统写作：\n$$\nA \\mathbf{u}^{n+1} = B \\mathbf{u}^{n}\n$$\n其中 $A$ 和 $B$ 是 $(N_x-1) \\times (N_x-1)$ 的三对角矩阵。矩阵 $A$ 的主对角线元素为 $(1+2\\alpha)$，次对角线元素为 $-\\alpha$。矩阵 $B$ 的主对角线元素为 $(1-2\\alpha)$，次对角线元素为 $\\alpha$。\n$$\nA = \n\\begin{pmatrix}\n1+2\\alpha & -\\alpha & 0 & \\dots \\\\\n-\\alpha & 1+2\\alpha & -\\alpha & \\dots \\\\\n0 & \\ddots & \\ddots & \\ddots \\\\\n\\vdots & & -\\alpha & 1+2\\alpha\n\\end{pmatrix}, \\quad\nB = \n\\begin{pmatrix}\n1-2\\alpha & \\alpha & 0 & \\dots \\\\\n\\alpha & 1-2\\alpha & \\alpha & \\dots \\\\\n0 & \\ddots & \\ddots & \\ddots \\\\\n\\vdots & & \\alpha & 1-2\\alpha\n\\end{pmatrix}\n$$\n这直接对应于问题陈述中提供的算子形式 $\\left(I - \\frac{\\kappa \\Delta t}{2}\\,\\mathcal{L}_h\\right)\\mathbf{u}^{n+1} = \\left(I + \\frac{\\kappa \\Delta t}{2}\\,\\mathcal{L}_h\\right)\\mathbf{u}^{n}$，其中 $\\mathcal{L}_h$ 是离散拉普拉斯算子的矩阵表示。\n\n将解从 $t=0$ 推进到 $T$ 的算法如下：\n1. 在时间 $t^0=0$ 初始化解向量：对于 $i=1, \\dots, N_x-1$，有 $u_i^0 = \\sin(\\pi x_i)$。\n2. 对于从 $0$ 到 $N_t-1$ 的每个时间步 $n$，其中 $N_t = T/\\Delta t$：\n   a. 计算右侧向量 $\\mathbf{b} = B \\mathbf{u}^n$。\n   b. 求解线性系统 $A \\mathbf{u}^{n+1} = \\mathbf{b}$ 以得到未知向量 $\\mathbf{u}^{n+1}$。由于 $A$ 是对称正定的三对角矩阵，该系统可以使用针对带状矩阵的专门算法高效求解。\n3. 最终的数值解是向量 $\\mathbf{u}^{N_t}$。\n\n误差使用离散 $L^2$-范数进行量化，定义为：\n$$\n\\| \\mathbf{e} \\|_{2,h} = \\left( \\Delta x \\sum_{i=1}^{N_x-1} \\left(u_i^{N_t} - u_{\\text{exact}}(x_i,T)\\right)^2 \\right)^{1/2}\n$$\n其中精确解由 $u_{\\text{exact}}(x,t) = \\sin(\\pi x) e^{-\\kappa \\pi^2 t}$ 给出。对于 $T=0$ 的测试用例，不执行时间步（$N_t=0$），误差通过比较初始离散数据 $\\mathbf{u}^0$ 和 $t=0$ 时的精确解来计算。该误差在机器精度范围内恒为零。\n\n提供的 Python 代码为每个测试用例实现了这一完整过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using the Crank-Nicolson method for a suite of test cases\n    and computes the discrete L2 error against the exact solution.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (kappa, Nx, dt, T).\n    test_cases = [\n        (1.0, 50, 0.0025, 0.1),  # Test A\n        (0.5, 80, 0.001, 0.05),   # Test B\n        (1.0, 10, 0.025, 0.1),    # Test C\n        (1.0, 40, 0.01, 0.0),    # Test D\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current test case.\n        kappa, Nx, dt, T = case\n\n        # Calculate discretization parameters.\n        dx = 1.0 / Nx\n        # The problem statement guarantees T / dt is an integer.\n        # Use rounding for robustness against floating-point representation issues.\n        Nt = int(round(T / dt))\n        \n        # Define the interior spatial grid. There are Nx-1 interior points.\n        x = np.linspace(dx, 1.0 - dx, Nx - 1)\n        \n        # Set the initial condition u(x,0) = sin(pi*x) on the interior grid.\n        u_current = np.sin(np.pi * x)\n        \n        # If T > 0, perform time stepping.\n        if Nt > 0:\n            # Dimensionless parameter for the matrices.\n            alpha = kappa * dt / (2.0 * dx**2)\n            \n            # Construct the tridiagonal matrix A for the left-hand side: (I - (kappa*dt/2)*L_h).\n            # The matrix is stored in the banded format required by scipy.linalg.solve_banded.\n            # It has 1 lower diagonal, 1 main diagonal, and 1 upper diagonal.\n            A_banded = np.zeros((3, Nx - 1))\n            A_banded[0, 1:] = -alpha           # Upper diagonal\n            A_banded[1, :] = 1.0 + 2.0 * alpha # Main diagonal\n            A_banded[2, :-1] = -alpha          # Lower diagonal\n            \n            # Time-stepping loop.\n            for _ in range(Nt):\n                # Calculate the right-hand side vector b = B @ u_current,\n                # where B = (I + (kappa*dt/2)*L_h).\n                # This is done efficiently without explicitly forming matrix B.\n                rhs = (1.0 - 2.0 * alpha) * u_current\n                rhs[1:] += alpha * u_current[:-1]   # Add contribution from lower diagonal of B\n                rhs[:-1] += alpha * u_current[1:]  # Add contribution from upper diagonal of B\n                \n                # Solve the tridiagonal system A * u_next = rhs for u_next.\n                u_current = solve_banded((1, 1), A_banded, rhs)\n\n        # After the loop, u_current holds the numerical solution at time T.\n        # For T=0, u_current is still the initial condition.\n        \n        # Calculate the exact solution at the final time T on the grid.\n        u_exact = np.sin(np.pi * x) * np.exp(-kappa * np.pi**2 * T)\n        \n        # Compute the discrete L2 error between numerical and exact solutions.\n        error_l2 = np.sqrt(dx * np.sum((u_current - u_exact)**2))\n        \n        # Store the formatted result.\n        results.append(f\"{error_l2:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2383934"}, {"introduction": "Crank-Nicolson 格式以其无条件稳定性而著称，但这并不意味着任何时间步长都能产生物理上准确的结果。本练习旨在揭示该格式的一个关键限制：当处理具有尖锐梯度（例如不连续的初始条件）的问题时，采用较大的时间步长可能会引入非物理的数值振荡。通过这个实践，您将学会审慎选择时间步长，并理解稳定性与精度之间的微妙区别。[@problem_id:2443615]", "problem": "考虑一维热方程\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t > 0,\n$$\n其齐次 Dirichlet 边界条件为\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0,\n$$\n初始条件由一个紧支集的高帽剖面给出\n$$\nu(x,0) = \\begin{cases}\n1, & |x - 1/2| \\le w/2,\\\\\n0, & \\text{其他情况},\n\\end{cases}\n$$\n其中宽度为 $w = 0.1$。在 $[0,1]$ 上使用包含 $M$ 个相等子区间的均匀空间网格，因此空间步长为 $\\Delta x = 1/M$，网格点为 $x_i = i \\,\\Delta x$（$i = 0,1,\\ldots,M$）。内部未知量位于索引 $i = 1,2,\\ldots,M-1$ 处。时间积分将通过对空间上采用二阶中心有限差分法得到的半离散系统应用时间上的梯形法则（也称为 Crank–Nicolson 格式）来执行。设扩散数为\n$$\nr = \\frac{\\alpha \\,\\Delta t}{(\\Delta x)^2},\n$$\n其中 $\\alpha = 1$ 为固定值。使用由指定的 $r$ 值确定的恒定时间步长 $\\Delta t$，将数值解从 $t=0$ 演化到 $t = T_{\\text{end}}$。目标是检测当 $r$ 较大时可能出现的物理上不准确的时间振荡，其表现为尽管在给定条件下精确解在 $t>0$ 时保持非负，但数值解中却出现了负值。\n\n对于给定的参数集，定义一个“检测到振荡”布尔值如下：在每个时间步之后，如果在任何时间 $t \\in (0, T_{\\text{end}}]$，任意内部网格点的值严格低于 $-10^{-10}$ 的容差阈值，则将该布尔值设为 $\\text{True}$；否则设为 $\\text{False}$。在 $x=0$ 和 $x=1$ 处的边界值固定为 $0$，不应用于检测标准。\n\n您的程序必须为以下参数值 $(M, r, T_{\\text{end}})$ 的测试套件实现上述数学模型和检测规则，其中 $\\alpha = 1$ 和 $w = 0.1$ 保持不变：\n- 测试 A（正常路径，小扩散数）：$(M, r, T_{\\text{end}}) = (100, 0.1, 0.05)$。\n- 测试 B（接近符号变化阈值的边界区域）：$(M, r, T_{\\text{end}}) = (100, 0.5, 0.05)$。\n- 测试 C（中等大小的扩散数）：$(M, r, T_{\\text{end}}) = (100, 0.6, 0.05)$。\n- 测试 D（非常大的扩散数）：$(M, r, T_{\\text{end}}) = (100, 5.0, 0.05)$。\n\n对于每个测试，唯一的结果是如上定义的布尔值“检测到振荡”。您的程序应生成单行输出，其中包含测试 A–D 的四个布尔结果，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如，“[False,True,True,False]”）。输出中不需要物理单位。不涉及角度。不涉及百分比。输出必须严格遵守指定的格式。", "solution": "所提出的问题是有效的。这是一个在计算科学中定义明确的问题，基于偏微分方程数值分析的基本原理。所有必要的参数和条件都已提供，不存在科学或逻辑上的矛盾。我们将继续进行求解。\n\n该问题要求数值求解一维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t > 0\n$$\n热扩散系数给定为 $\\alpha = 1$。边界条件为齐次 Dirichlet 型：\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0\n$$\n初始条件是宽度为 $w = 0.1$ 的高帽函数：\n$$\nu(x,0) = \\begin{cases}\n1, & \\text{if } |x - 1/2| \\le 0.1/2 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\n这对应于当 $x \\in [0.45, 0.55]$ 时，$u(x,0)=1$。\n\n首先，我们在空间上进行半离散化。空间域 $[0,1]$ 被离散化为 $M$ 个等长的子区间，长度为 $\\Delta x = 1/M$。网格点为 $x_i = i \\Delta x$（$i = 0, 1, \\ldots, M$）。令 $u_i(t)$ 为 $u(x_i, t)$ 的数值近似。二阶空间导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{(\\Delta x)^2}\n$$\n将此应用于内部网格点 $i = 1, 2, \\ldots, M-1$，我们得到一个常微分方程（ODE）组：\n$$\n\\frac{d u_i}{dt} = \\frac{\\alpha}{(\\Delta x)^2} (u_{i+1} - 2u_i + u_{i-1})\n$$\n令 $\\mathbf{u}(t) = [u_1(t), u_2(t), \\ldots, u_{M-1}(t)]^T$ 为内部点的解向量。该 ODE 系统可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}\n$$\n其中 $L_{1D}$ 是一个 $(M-1) \\times (M-1)$ 的三对角矩阵，表示带有齐次 Dirichlet 边界条件的离散拉普拉斯算子：\n$$\nL_{1D} = \\begin{pmatrix}\n-2 & 1 & 0 & \\dots & 0 \\\\\n1 & -2 & 1 & \\dots & 0 \\\\\n0 & 1 & -2 & \\dots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n0 & \\dots & 0 & 1 & -2\n\\end{pmatrix}\n$$\n\n接下来，我们使用梯形法则（也称为 Crank-Nicolson 方法）在时间上进行离散化。给定时间步长 $\\Delta t$，令 $\\mathbf{u}^n$ 表示在时间 $t_n = n \\Delta t$ 的解向量。该格式为：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^{n+1} + \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^n \\right)\n$$\n引入扩散数 $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$，我们可以重排方程以求解 $\\mathbf{u}^{n+1}$：\n$$\n\\left(I - \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^n\n$$\n其中 $I$ 是 $(M-1) \\times (M-1)$ 的单位矩阵。在每个时间步，我们必须求解一个形式为 $A \\mathbf{x} = \\mathbf{b}$ 的线性系统，其中：\n- 系统矩阵为 $A_{CN} = I - \\frac{r}{2} L_{1D}$。\n- 未知向量为 $\\mathbf{x} = \\mathbf{u}^{n+1}$。\n- 右侧向量为 $\\mathbf{b}_{CN} = (I + \\frac{r}{2} L_{1D}) \\mathbf{u}^n$。\n\n矩阵 $A_{CN}$ 是三对角矩阵，主对角线上的元素为 $(1+r)$，次对角线和超对角线上的元素为 $-r/2$。对于任何 $r > 0$，该系统都是非奇异且对角占优的，因此可以使用处理三对角系统的算法（如 Thomas 算法）高效求解。\n\n模拟过程如下：\n1. 对于由 $(M, r, T_{\\text{end}})$ 指定的每个测试用例，我们设置 $\\alpha=1$ 和 $w=0.1$。\n2. 空间步长为 $\\Delta x = 1/M$。时间步长由扩散数确定，$\\Delta t = r (\\Delta x)^2 / \\alpha$。\n3. 通过在内部网格点 $x_i$（$i=1, \\ldots, M-1$）上对高帽函数进行采样来构建初始解向量 $\\mathbf{u}^0$。\n4. 构建 Crank-Nicolson 步骤所需的矩阵。左侧矩阵 $A_{CN}$ 在整个模拟过程中是恒定的。\n5. 一个时间步进循环将解从 $t=0$ 演化到 $t=T_{\\text{end}}$。在每一步中：\n    a. 通过将算子 $(I + \\frac{r}{2} L_{1D})$ 应用于当前解 $\\mathbf{u}^n$ 来计算右侧向量 $\\mathbf{b}_{CN}$。\n    b. 求解线性系统 $A_{CN} \\mathbf{u}^{n+1} = \\mathbf{b}_{CN}$ 以得到 $\\mathbf{u}^{n+1}$。\n    c. 检查新的解向量 $\\mathbf{u}^{n+1}$ 是否存在振荡。如果其任何分量小于容差 $-10^{-10}$，则布尔标志 `oscillation_detected` 被设置为 `True`，并且该测试用例的模拟终止。\n6. 如果时间循环完成而标志未被设置，则其值保持为 `False`。\n\nCrank-Nicolson 格式对于任何 $r > 0$ 在 $L_2$-范数意义下是无条件稳定的。然而，对于非光滑的初始条件，除非时间步长足够小，否则它可能无法保持非负性并可能引入虚假振荡。对非负性的傅里叶稳定性分析表明，如果所有模式的放大因子都为非负，则可以避免振荡。对于最高频率模式，这导致条件 $1 - 2r \\ge 0$，即 $r \\le 0.5$。因此，我们预计对于 $r > 0.5$ 的测试用例将检测到振荡。具体来说，对于测试 C ($r=0.6$) 和测试 D ($r=5.0$)，我们期望会发现负值。对于测试 A ($r=0.1$) 和测试 B ($r=0.5$)，我们期望解将保持非负。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    def run_simulation(M, r, T_end, alpha, w):\n        \"\"\"\n        Solves the 1D heat equation using the Crank-Nicolson method for one set of parameters.\n\n        Args:\n            M (int): Number of spatial subintervals.\n            r (float): Diffusion number.\n            T_end (float): End time for the simulation.\n            alpha (float): Thermal diffusivity.\n            w (float): Width of the initial top-hat profile.\n\n        Returns:\n            bool: True if oscillations are detected, False otherwise.\n        \"\"\"\n        # --- 1. Setup simulation parameters ---\n        dx = 1.0 / M\n        dt = r * dx**2 / alpha\n        num_steps = int(np.ceil(T_end / dt))\n        tol = -1.0e-10\n        \n        # --- 2. Create spatial grid and initial condition ---\n        # Grid consists of M-1 interior points.\n        x_interior = np.linspace(dx, 1.0 - dx, M - 1)\n        \n        u = np.zeros(M - 1)\n        left_bound = 0.5 - w / 2.0\n        right_bound = 0.5 + w / 2.0\n        \n        # Set initial condition u(x,0) based on the top-hat profile.\n        # N.B. Using a small epsilon for float comparison safety is good practice,\n        # but for M=100, the boundaries 0.45 and 0.55 are exact grid points.\n        u[(x_interior >= left_bound) & (x_interior <= right_bound)] = 1.0\n        \n        # --- 3. Construct matrices for the Crank-Nicolson scheme ---\n        # The scheme is (I - r/2 * L) u_next = (I + r/2 * L) u_current\n        # Let A = (I - r/2 * L) and B = (I + r/2 * L). We solve A * u_next = B * u_current.\n        \n        # A matrix in banded form for Scipy's solver.\n        # It has 1 lower, 1 upper diagonal. Shape (3, M-1).\n        # Row 0: super-diagonal, Row 1: main diagonal, Row 2: sub-diagonal.\n        A_banded = np.zeros((3, M - 1))\n        A_banded[0, 1:] = -r / 2.0\n        A_banded[1, :] = 1.0 + r\n        A_banded[2, :-1] = -r / 2.0\n        \n        # --- 4. Time-stepping loop ---\n        u_current = u\n        oscillation_detected = False\n        \n        for _ in range(num_steps):\n            # Calculate the right-hand side vector: rhs = B * u_current\n            # B is tridiagonal with (1-r) on the main diagonal and r/2 on off-diagonals.\n            # We compute the matrix-vector product efficiently without forming B.\n            rhs = np.zeros(M - 1)\n            \n            # For interior points of the u_current vector (indices 1 to M-3)\n            if M - 1 > 2:\n                rhs[1:-1] = (r / 2.0) * u_current[:-2] + \\\n                            (1.0 - r) * u_current[1:-1] + \\\n                            (r / 2.0) * u_current[2:]\n            \n            # Handle endpoints with homogeneous Dirichlet BCs (u_0=0, u_M=0)\n            if M - 1 > 0: # Ensure u_current is not empty\n                rhs[0] = (1.0 - r) * u_current[0] + (r / 2.0) * u_current[1] if M - 1 > 1 else (1.0 - r) * u_current[0]\n            if M - 1 > 1:\n                rhs[-1] = (r / 2.0) * u_current[-2] + (1.0 - r) * u_current[-1]\n            \n            # Solve the tridiagonal system A * u_next = rhs\n            u_next = solve_banded((1, 1), A_banded, rhs)\n            \n            # Check for oscillations\n            if np.any(u_next < tol):\n                oscillation_detected = True\n                break\n            \n            u_current = u_next\n            \n        return oscillation_detected\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100, 0.1, 0.05),  # Test A\n        (100, 0.5, 0.05),  # Test B\n        (100, 0.6, 0.05),  # Test C\n        (100, 5.0, 0.05),  # Test D\n    ]\n\n    # Fixed parameters\n    alpha = 1.0\n    w = 0.1\n    \n    results = []\n    for case in test_cases:\n        M, r, T_end = case\n        result = run_simulation(M, r, T_end, alpha, w)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443615"}, {"introduction": "在获得了数值解之后，我们自然会问：如何提高解的精度？Richardson 外推法提供了一种优雅而强大的技术，能够显著提升数值解的精度阶数。本练习将指导您使用两个不同时间步长（一个粗略，一个精细）的 Crank-Nicolson 计算结果，通过简单的线性组合来消除主要的误差项，从而获得一个更高阶的精确解。[@problem_id:2443584]", "problem": "考虑由线性常微分方程 (ODE) $y'(t)=\\lambda\\,y(t)$ 和初始条件 $y(0)=y_0$ 给出的标量初值问题，其中 $t \\in [0,T]$，$\\lambda \\in \\mathbb{R}$，$y_0 \\in \\mathbb{R}$，$T \\in \\mathbb{R}_{>0}$。时间将使用时间梯形法则（也称为 Crank-Nicolson (CN) 格式）在具有 $N$ 个步长（大小为 $\\Delta t = T/N$）的均匀网格上，以及在具有 $2N$ 个步长（大小为 $\\Delta t/2$）的加密均匀网格上进行离散化。通过两次 CN 计算（一次步长为 $\\Delta t$，另一次步长为 $\\Delta t/2$），得到两个在 $t=T$ 时的离散终值。将 Richardson 外推应用于这两个 CN 终值，构造一个时间上四阶精度的单一终端近似值。对于下面套件中的每个测试用例，计算此四阶精度终端近似值相对于精确解 $y(T)=y_0\\,e^{\\lambda T}$ 的绝对误差。\n\n您的程序必须为测试套件中的所有测试用例实现这些计算，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个条目必须是对应测试用例的绝对误差（一个浮点数），并按所列顺序排列。\n\n测试套件：\n- 用例 1：$(\\lambda, y_0, T, N) = (-2.0, 1.0, 1.0, 20)$。\n- 用例 2：$(\\lambda, y_0, T, N) = (0.0, 2.0, 3.0, 12)$。\n- 用例 3：$(\\lambda, y_0, T, N) = (-50.0, 1.0, 1.0, 200)$。\n- 用例 4：$(\\lambda, y_0, T, N) = (3.0, 0.5, 0.5, 20)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用例 1 到 4 的绝对误差，形式为用方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4]$，其中 $e_i$ 表示用例 $i$ 的绝对误差（一个浮点数）。不应打印任何其他文本。", "solution": "此问题是求解线性标量常微分方程 $y'(t) = \\lambda y(t)$，其初始条件为 $y(0)=y_0$。我们必须首先使用梯形法则（也称为 Crank-Nicolson 格式）在时间上对此方程进行离散化。\n\n对于一般的 ODE $y' = f(t, y)$，从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个时间步长的梯形法则由下式给出：\n$$y_{n+1} =y_n + \\frac{\\Delta t}{2} \\left[ f(t_n, y_n) + f(t_{n+1}, y_{n+1}) \\right]$$\n在我们的情况下，$f(t,y) = \\lambda y(t)$。将此代入格式中，我们得到：\n$$y_{n+1} = y_n + \\frac{\\Delta t}{2} \\left[ \\lambda y_n + \\lambda y_{n+1} \\right]$$\n这是一个隐式格式，我们必须求解 $y_{n+1}$：\n$$y_{n+1} \\left( 1 - \\frac{\\lambda \\Delta t}{2} \\right) = y_n \\left( 1 + \\frac{\\lambda \\Delta t}{2} \\right)$$\n这给出了时间步进的显式递推关系：\n$$y_{n+1} = y_n \\left( \\frac{1 + \\lambda \\Delta t/2}{1 - \\lambda \\Delta t/2} \\right)$$\n从初始条件 $y_0$ 开始，通过重复应用此公式，可以找到时间 $t_n = n \\Delta t$ 处的解：\n$$y_n = y_0 \\left( \\frac{1 + \\lambda \\Delta t/2}{1 - \\lambda \\Delta t/2} \\right)^n$$\n对于在区间 $[0, T]$ 上使用 $N$ 步的计算，步长为 $\\Delta t = T/N$。在 $t = T = N \\Delta t$ 时的终端近似值为：\n$$y_N(T) = y_0 \\left( \\frac{1 + \\lambda (T/N)/2}{1 - \\lambda (T/N)/2} \\right)^N$$\nCrank-Nicolson 方法是二阶精度的，这意味着在固定时间 $T$ 的全局误差具有步长 $\\Delta t$ 的偶数次幂的渐近展开：\n$$y_N(T) = y(T) + C_2 (\\Delta t)^2 + C_4 (\\Delta t)^4 + O((\\Delta t)^6)$$\n其中 $y(T)$ 是精确解，$C_2, C_4, \\dots$ 是与 $\\Delta t$ 无关的常数。\n\nRichardson 外推是一种利用两个以不同步长计算的低阶近似值来构造更高阶近似值的技术。我们给定两个网格：一个具有 $N$ 个步长（大小为 $h = \\Delta t = T/N$）的粗网格，以及一个具有 $2N$ 个步长（大小为 $h/2 = T/(2N)$）的加密网格。设相应的终端近似值为 $A(h)$ 和 $A(h/2)$。\n$$A(h) = y_N(T)$$\n$$A(h/2) = y_{2N}(T)$$\n误差展开式为：\n$$A(h) = y(T) + C_2 h^2 + C_4 h^4 + O(h^6)$$\n$$A(h/2) = y(T) + C_2 (h/2)^2 + C_4 (h/2)^4 + O((h/2)^6) = y(T) + \\frac{1}{4} C_2 h^2 + \\frac{1}{16} C_4 h^4 + O(h^6)$$\n为消除 $O(h^2)$ 阶的主误差项，我们构造一个 $A(h)$ 和 $A(h/2)$ 的线性组合。将第二个方程乘以 $4$ 并减去第一个方程，得到：\n$$4A(h/2) - A(h) = (4y(T) - y(T)) + (C_2 h^2 - C_2 h^2) + \\left(\\frac{4}{16} C_4 h^4 - C_4 h^4\\right) + O(h^6)$$\n$$4A(h/2) - A(h) = 3y(T) - \\frac{3}{4} C_4 h^4 + O(h^6)$$\n求解 $y(T)$，我们得到外推近似值 $y_{extra}$：\n$$y_{extra} = \\frac{4A(h/2) - A(h)}{3}$$\n这个新近似值的误差是：\n$$y_{extra} - y(T) = -\\frac{1}{4} C_4 h^4 + O(h^6)$$\n这证实了外推结果是四阶精度的，如问题所述。此过程应用于四个测试用例中的每一个。对于 $\\lambda = 0$ 的特殊情况，ODE 为 $y'(t)=0$，因此对于所有 $t$，$y(t) = y_0$。数值格式正确地得出 $y_{n+1} = y_n$，因此数值近似值和精确解都是 $y_0$。产生的误差恰好为 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute error of a fourth-order Richardson-extrapolated\n    solution to the ODE y'(t) = lambda*y(t) for several test cases.\n    The underlying numerical method is the Crank-Nicolson scheme.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, y0, T, N)\n        (-2.0, 1.0, 1.0, 20),\n        (0.0, 2.0, 3.0, 12),\n        (-50.0, 1.0, 1.0, 200),\n        (3.0, 0.5, 0.5, 20),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lamb, y0, T, N = case\n        \n        # Handle the trivial case where lambda is 0\n        if lamb == 0.0:\n            results.append(0.0)\n            continue\n            \n        # Coarse grid computation\n        # N steps, step size dt1 = T/N\n        N1 = N\n        dt1 = T / N1\n        # The amplification factor for the Crank-Nicolson scheme\n        amp_factor1 = (1.0 + 0.5 * lamb * dt1) / (1.0 - 0.5 * lamb * dt1)\n        # Closed-form solution for the numerical approximation at T\n        y_N = y0 * (amp_factor1 ** N1)\n        \n        # Refined grid computation\n        # 2N steps, step size dt2 = T/(2N)\n        N2 = 2 * N\n        dt2 = T / N2\n        amp_factor2 = (1.0 + 0.5 * lamb * dt2) / (1.0 - 0.5 * lamb * dt2)\n        y_2N = y0 * (amp_factor2 ** N2)\n        \n        # Richardson extrapolation to get a fourth-order accurate result\n        # The formula for p=2 order method and r=2 refinement is (r^p * A_fine - A_coarse) / (r^p - 1)\n        # which is (4 * y_2N - y_N) / 3\n        y_extrapolated = (4.0 * y_2N - y_N) / 3.0\n        \n        # Exact solution\n        y_exact = y0 * np.exp(lamb * T)\n        \n        # Absolute error\n        absolute_error = abs(y_extrapolated - y_exact)\n        \n        results.append(absolute_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443584"}]}