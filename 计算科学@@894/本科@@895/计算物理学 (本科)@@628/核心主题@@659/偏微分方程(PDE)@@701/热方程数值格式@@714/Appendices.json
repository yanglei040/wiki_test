{"hands_on_practices": [{"introduction": "理论稳定性分析（如冯·诺依曼分析）可能感觉很抽象。本练习通过数值模拟一个微小舍入误差的增长或衰减，为您提供了对稳定性的具体、直观的理解。我们将看到，根据参数 $r$ 的选择，数值格式本身既可以抑制这个误差，也可以使其爆炸性地放大。[@problem_id:2400867]", "problem": "您需要编写一个完整、可运行的程序，研究在一维热方程的无量纲形式下，单点数值舍入误差如何在时间前向中心差分 (FTCS) 格式中传播。从周期性域上的偏微分方程 $u_t = u_{xx}$ 所描述的热扩散基本模型开始。将空间离散化为 $N$ 个间距为 $\\Delta x$ 的均匀点，以步长 $\\Delta t$ 将时间离散化，并在每个时间步应用 FTCS 更新。计算应在无量纲单位下进行，因此您的答案中不需要任何物理单位。\n\n您的程序必须实现以下数学定义和任务，并且在实现中不得使用任何预先推导出的稳定性或放大公式：\n- 定义无量纲比 $r = \\Delta t / \\Delta x^2$。\n- 对每个时间步的索引 $i = 0, 1, \\dots, N - 1$ 使用周期性 FTCS 更新，\n  $$u_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right),$$\n  其中周期性索引为 $u_{-1} = u_{N-1}$ 和 $u_N = u_0$。\n- 初始化一个扰动场，该场在除单个索引 $i_0 = \\lfloor N/2 \\rfloor$ 外的值恒为零，而在该索引处的值设为 IEEE 754 双精度机器ε $\\varepsilon = 2^{-52}$。这模拟了一个单点数值舍入误差。\n- 使用 FTCS 更新将扰动演化 $T$ 个时间步。计算每个时间步的二范数放大因子\n  $$g = \\left(\\frac{\\lVert e^T \\rVert_2}{\\lVert e^0 \\rVert_2}\\right)^{1/T},$$\n  其中 $e^n$ 是经过 $n$ 步后的扰动向量，$\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。\n\n目标是通过报告测量出的几何增长因子 $g$，来量化单点舍入误差在稳定 ($r < 0.5$) 和不稳定 ($r > 0.5$) 的 FTCS 区域中是如何被放大或衰减的。\n\n实现您的程序以处理以下参数集 $(N, r, T)$ 的测试套件，所有测试均采用周期性边界和索引 $i_0 = \\lfloor N/2 \\rfloor$：\n- 测试 1（稳定，正常情况）：$N = 64$，$r = 0.25$，$T = 200$。\n- 测试 2（不稳定，轻度）：$N = 64$，$r = 0.51$，$T = 80$。\n- 测试 3（临界情况）：$N = 33$，$r = 0.5$，$T = 200$。\n- 测试 4（不稳定，严重）：$N = 128$，$r = 0.9$，$T = 30$。\n\n您的程序应为每个测试计算 $g$，并生成单行输出，其中包含一个逗号分隔的浮点数列表，该列表四舍五入到六位小数，并用方括号括起来，顺序与上文相同（例如，“[$g_1, g_2, g_3, g_4$]”）。输出是无量纲数，因此不需要物理单位。每个 $g$ 必须打印为四舍五入到六位小数的浮点数。最终输出类型为浮点数列表。", "solution": "问题陈述已经过严格验证，被认为是有效的。它具有科学依据、是适定的、客观的，并包含得出唯一且有意义解所需的所有必要信息。该问题是计算物理领域中研究有限差分格式稳定性的一个标准数值实验。我们现在开始求解。\n\n我们所考虑的基本物理过程是一维热扩散，由以下偏微分方程 (PDE) 描述：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial^2 u}{\\partial x^2}\n$$\n其中 $u(x, t)$ 是位置 $x$ 和时间 $t$ 处的温度。问题指定了一个周期性域，这意味着对于某个周期 $L$，有 $u(x, t) = u(x+L, t)$。在我们的数值模拟中，域是 $N$ 个离散点的集合，通过连接边界来强制实现周期性，使得点 $i=0$ 左边的邻居是 $i=N-1$，点 $i=N-1$ 右边的邻居是 $i=0$。\n\n为了对该方程进行数值求解，我们将空间和时间都进行离散化。设空间域被离散化为 $N$ 个点，均匀间距为 $\\Delta x$，时间被离散化为大小为 $\\Delta t$ 的步长。我们将 $u(i\\Delta x, n\\Delta t)$ 的数值近似记为 $u_i^n$。时间前向中心差分 (FTCS) 格式按如下方式近似导数：\n- 时间导数 $\\frac{\\partial u}{\\partial t}$ 使用前向差分进行近似：\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(i,n)} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n- 空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用中心差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(i,n)} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\n将这些近似代入热方程，得到 FTCS 更新规则：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\n重新整理此方程以求解未来状态 $u_i^{n+1}$，得到问题陈述中提供的显式公式：\n$$\nu_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right)\n$$\n其中 $r = \\frac{\\Delta t}{(\\Delta x)^2}$ 是此抛物线型问题的无量纲 Courant-Friedrichs-Lewy (CFL) 数。\n\n该更新规则是一个线性变换。如果我们将时间步 $n$ 的系统状态表示为一个向量 $\\mathbf{u}^n = [u_0^n, u_1^n, \\dots, u_{N-1}^n]^T$，那么从一个时间步到下一个时间步的演化可以用矩阵形式表示：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{A} \\mathbf{u}^n\n$$\n其中 $\\mathbf{A}$ 是 $N \\times N$ 的放大矩阵。根据更新规则和周期性边界条件 ($u_{-1} = u_{N-1}$ 和 $u_N = u_0$)，矩阵 $\\mathbf{A}$ 是一个具有以下结构的循环矩阵：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1-2r & r & 0 & \\dots & 0 & r \\\\\nr & 1-2r & r & \\dots & 0 & 0 \\\\\n0 & r & 1-2r & \\dots & 0 & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\n0 & 0 & 0 & \\dots & 1-2r & r \\\\\nr & 0 & 0 & \\dots & r & 1-2r\n\\end{pmatrix}\n$$\n问题在于研究数值舍入误差的传播。由于演化方程是线性的，任何误差 $\\mathbf{e}^n$ 都会遵循相同的规则演化：$\\mathbf{e}^{n+1} = \\mathbf{A} \\mathbf{e}^n$。通过归纳法，经过 $T$ 个时间步后的误差由 $\\mathbf{e}^T = \\mathbf{A}^T \\mathbf{e}^0$ 给出。\n\n模拟过程如下：\n1.  对于每个测试用例 $(N, r, T)$，创建一个大小为 $N$ 的初始误差向量 $\\mathbf{e}^0$。该向量除中心索引 $i_0 = \\lfloor N/2 \\rfloor$ 外，其余各处均初始化为零。\n2.  该单点的值被设为双精度机器ε，$\\varepsilon = 2^{-52}$。因此，$\\mathbf{e}^0_{i_0} = \\varepsilon$。\n3.  计算该初始向量的欧几里得范数（或 $L_2$范数）：$\\lVert \\mathbf{e}^0 \\rVert_2 = \\sqrt{\\sum_{i=0}^{N-1} (e_i^0)^2} = \\sqrt{\\varepsilon^2} = \\varepsilon$。\n4.  循环迭代 $T$ 个时间步。在每一步 $n$ 中，利用带有周期性边界条件的 FTCS 更新规则，从 $\\mathbf{e}^n$ 计算误差向量 $\\mathbf{e}^{n+1}$。\n5.  经过 $T$ 步后，得到最终误差向量 $\\mathbf{e}^T$。计算其欧几里得范数 $\\lVert \\mathbf{e}^T \\rVert_2$。\n6.  然后根据其定义计算每个时间步的几何增长因子 $g$：\n$$\ng = \\left(\\frac{\\lVert \\mathbf{e}^T \\rVert_2}{\\lVert \\mathbf{e}^0 \\rVert_2}\\right)^{1/T}\n$$\n若 $g > 1$，则表明误差被放大，格式对于给定参数是不稳定的。若 $g < 1$，则表明误差被衰减，格式是稳定的。若 $g \\approx 1$，则表明是中性稳定或临界情况。对所提供的四个测试用例中的每一个都执行此过程。实现将使用 `numpy` 进行高效的数组操作，特别是使用 `numpy.roll` 来巧妙地处理周期性边界条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical amplification factor for the FTCS scheme\n    for the 1D heat equation under different stability regimes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, r, T)\n    # N: number of spatial points\n    # r: nondimensional ratio delta_t / (delta_x)^2\n    # T: number of time steps\n    test_cases = [\n        (64, 0.25, 200),  # Test 1: stable\n        (64, 0.51, 80),   # Test 2: unstable (mild)\n        (33, 0.5, 200),   # Test 3: borderline\n        (128, 0.9, 30),   # Test 4: unstable (severe)\n    ]\n\n    results = []\n    \n    # The IEEE 754 double-precision machine epsilon\n    epsilon = np.finfo(float).eps\n\n    for N, r, T in test_cases:\n        # Initialize the perturbation field 'e'.\n        # It is zero everywhere except for a single point.\n        e = np.zeros(N, dtype=float)\n        \n        # Set the perturbation at the central grid point.\n        # i_0 = floor(N/2) is implemented via integer division.\n        i0 = N // 2\n        e[i0] = epsilon\n        \n        # The initial L2 norm of the error vector.\n        # Since only one element is non-zero, the norm is its absolute value.\n        norm_e0 = np.linalg.norm(e)\n\n        # Evolve the perturbation for T time steps using the FTCS scheme.\n        for _ in range(T):\n            # Applying periodic boundary conditions efficiently using np.roll.\n            # np.roll(e, 1) shifts elements to the right (e_{i-1})\n            # np.roll(e, -1) shifts elements to the left (e_{i+1})\n            e_im1 = np.roll(e, 1)\n            e_ip1 = np.roll(e, -1)\n            \n            # Apply the FTCS update rule.\n            e = e + r * (e_ip1 - 2 * e + e_im1)\n\n        # Calculate the L2 norm of the final error vector.\n        norm_eT = np.linalg.norm(e)\n        \n        # Calculate the geometric amplification factor per time step, g.\n        # Handle the case where the error is damped to zero to avoid division errors.\n        if norm_eT == 0.0 or norm_e0 == 0.0:\n            g = 0.0\n        else:\n            g = (norm_eT / norm_e0)**(1.0 / T)\n\n        results.append(g)\n\n    # Format the results as a list of strings, each rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2400867"}, {"introduction": "在了解了显式方法的严格稳定性限制之后，我们现在探索一种强大的替代方案：隐式格式。我们将实现克兰克-尼科尔森（Crank-Nicolson）方法，这是一种无条件稳定的方法，允许使用更大的时间步长。为了增加趣味性，我们会将此方法应用于圆盘上的热扩散问题，这需要我们仔细处理极坐标系在原点的奇点问题。[@problem_id:2400870]", "problem": "考虑一个半径为 $R$ 的二维圆盘中的径向对称热传导问题，其中温度仅取决于径向坐标 $r$ 和时间 $t$。该问题的控制方程可由局部能量守恒和傅里叶热传导定律推导得出，是极坐标下无角度依赖的热方程：\n$$\n\\frac{\\partial u}{\\partial t}(r,t) = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2}(r,t) + \\frac{1}{r}\\frac{\\partial u}{\\partial r}(r,t) \\right), \\quad 0 \\le r \\le R, \\; t \\ge 0,\n$$\n边界条件为对所有 $t \\ge 0$ 都有 $u(R,t) = 0$，且原点处的正则性与物理对称性一致。假设所有量均为无量纲。\n\n你的任务是编写一个完整、可运行的程序，使用一种无条件稳定且时间上二阶精确的格式来计算该初边值问题的温度演化。空间离散化必须是二阶精确的，并且其构建方式必须确保在原点 $r=0$ 处的离散化与拉普拉斯算子的极坐标形式以及由有限能量和傅里叶定律所蕴含的对称性条件相一致。你必须从守恒律形式出发，得到一种当 $r \\to 0$ 时遵循正确极限行为的离散化方法。\n\n使用以下规格：\n\n- 计算域为径向坐标上的区间 $[0,R]$。\n- 使用均匀网格 $r_i = i \\,\\Delta r$，$i = 0,1,\\dots,N$，其中 $\\Delta r = R/N$。\n- 对所有时间层 $n$，施加边界条件 $u_N^n = 0$。\n- 初始条件为 $u(r,0) = \\exp\\!\\left( -\\left(\\frac{r}{\\sigma}\\right)^2 \\right)$。\n- 时间步进格式必须是 Crank-Nicolson 方法（在时间上也被称为梯形法则），该方法与二阶精确的空间离散化配对使用时是无条件稳定且时间上二阶精确的。以矩阵形式构建该方法，并在每个时间步求解得到的线性系统。\n- 离散空间算子必须能正确处理 $r=0$ 处而无奇点，并且必须通过在原点处对极坐标拉普拉斯算子取恰当的极限，从第一性原理推导得出。你不得在 $r=0$ 处引入任何临时的低阶修正。\n\n测试套件与输出：\n\n- 运行你的程序，测试以下四个案例。在每个案例中，按下列方式设置参数 $(\\alpha, R, \\sigma, N, M, T)$，其中 $M$ 是均匀时间步的数量，$\\Delta t = T/M$：\n  - 案例 $1$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.2, 200, 50, 0.05)$。\n  - 案例 $2$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.2, 50, 50, 0.05)$。\n  - 案例 $3$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.05, 200, 100, 0.02)$。\n  - 案例 $4$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.5, 200, 50, 0.05)$。\n- 对每个案例，计算数值解直到最终时间 $T$，并报告原点处的温度，即 $u(0,T)$。\n- 你的程序必须产生单行输出，其中包含四个案例的结果，结果为方括号括起来的逗号分隔列表，顺序为案例1到案例4。每个数字必须四舍五入到八位小数。例如，输出格式必须严格为\n$[x_1,x_2,x_3,x_4]$\n其中每个 $x_i$ 是案例 $i$ 的 $u(0,T)$ 值，四舍五入到八位小数。\n\n你的实现必须是自包含的，不得读取任何用户输入，也不得需要任何外部文件或网络访问。问题的最终答案必须是代码。通过推导和使用与极坐标拉普拉斯算子极限行为一致的原点空间离散化方法，来确保科学真实性。本问题中的数值量均为无量纲；不需要物理单位。最终输出格式要求是严格的，必须严格遵守。", "solution": "所给出的问题是一个关于二维径向对称圆盘内线性热方程的适定初边值问题。它在科学上是合理的，并包含了进行数值求解所需的所有信息。因此，我们将着手解决它。\n\n我们的目标是计算由极坐标下径向对称热方程控制的温度演化 $u(r,t)$：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} \\right)\n$$\n对于 $r \\in [0, R]$ 和 $t \\ge 0$。该问题受边界条件 $u(R,t) = 0$ 和初始条件 $u(r,0) = \\exp(-(r/\\sigma)^2)$ 的约束。物理一致性要求，由于对称性，温度梯度在原点处为零，即 $\\frac{\\partial u}{\\partial r}\\big|_{r=0} = 0$。\n\n我们将采用 Crank-Nicolson 方法进行时间积分，这是一种二阶精确且无条件稳定的格式。该方程在时间上离散化为：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\mathcal{L}_h \\mathbf{u}^{n+1} + \\mathcal{L}_h \\mathbf{u}^n \\right)\n$$\n其中 $\\mathbf{u}^n$ 是在时间 $t_n = n\\Delta t$ 的数值解向量，$\\mathcal{L}_h$ 是近似连续算子 $\\mathcal{L} \\equiv \\alpha \\left( \\frac{\\partial^2}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial}{\\partial r} \\right)$ 的离散空间算子。该格式是隐式的，可以整理成一个在每个时间步都需要求解的线性系统：\n$$\n\\left(I - \\frac{\\Delta t}{2} L\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} L\\right) \\mathbf{u}^n\n$$\n其中 $L$ 是 $\\mathcal{L}_h$ 的矩阵表示。未知量向量由离散径向点上的温度组成，即 $\\mathbf{u} = [u_0, u_1, \\ldots, u_{N-1}]^T$，对应于半径 $r_i = i\\Delta r$，$i=0, \\ldots, N-1$，其中 $\\Delta r = R/N$。边界条件固定了对所有 $n$ 都有 $u_N^n = 0$。\n\n关键步骤是构建一个二阶精确的空间离散化 $\\mathcal{L}_h$。\n\n对于内部点 $r_i$（其中 $i \\in \\{1, 2, \\ldots, N-1\\}$），我们使用标准的二阶中心差分公式来计算导数：\n$$\n\\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta r)^2}, \\quad \\frac{\\partial u}{\\partial r}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - u_{i-1}}{2\\Delta r}\n$$\n将这些代入 $\\mathcal{L}u$ 的表达式，得到节点 $i$ 处的离散算子：\n$$\n(\\mathcal{L}_h \\mathbf{u})_i = \\alpha \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta r)^2} + \\frac{1}{i\\Delta r} \\frac{u_{i+1} - u_{i-1}}{2\\Delta r} \\right) = \\frac{\\alpha}{(\\Delta r)^2} \\left[ \\left(1 - \\frac{1}{2i}\\right)u_{i-1} - 2u_i + \\left(1 + \\frac{1}{2i}\\right)u_{i+1} \\right]\n$$\n\n在原点 $r=0$（$i=0$）处，项 $\\frac{1}{r}\\frac{\\partial u}{\\partial r}$ 是奇异的。正确的离散化必须通过考虑拉普拉斯算子的极限行为来推导。根据对称性，温度分布必须是 $r$ 的偶函数，这意味着 $\\frac{\\partial u}{\\partial r}\\big|_{r=0} = 0$。对奇异项应用洛必达法则，我们发现：\n$$\n\\lim_{r\\to 0} \\frac{1}{r}\\frac{\\partial u}{\\partial r} = \\lim_{r\\to 0} \\frac{\\frac{\\partial^2 u}{\\partial r^2}}{1} = \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0}\n$$\n因此，热方程在原点处变为：\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{r=0} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0} + \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0} \\right) = 2\\alpha \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0}\n$$\n我们使用中心差分来离散化 $r=0$ 处的二阶导数。对称性条件 $u_r(0)=0$ 意味着对于围绕 $r=0$ 的泰勒展开，$u(r) = u(0) + \\frac{1}{2}u_{rr}(0)r^2 + O(r^4)$。这表明 $u(\\Delta r) = u(-\\Delta r)$，在我们的离散记法中即为 $u_1 = u_{-1}$。$u_{rr}(0)$ 的中心差分为：\n$$\n\\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r_0} \\approx \\frac{u_1 - 2u_0 + u_{-1}}{(\\Delta r)^2} = \\frac{u_1 - 2u_0 + u_1}{(\\Delta r)^2} = \\frac{2(u_1 - u_0)}{(\\Delta r)^2}\n$$\n将此代入原点处的特定热方程，得到 $i=0$ 的离散化形式：\n$$\n(\\mathcal{L}_h \\mathbf{u})_0 = 2\\alpha \\left( \\frac{2(u_1 - u_0)}{(\\Delta r)^2} \\right) = \\frac{4\\alpha}{(\\Delta r)^2} (u_1 - u_0)\n$$\n这种离散化是二阶精确的，并且与几何形状一致。\n\n根据这些表达式，我们构建 $N \\times N$ 矩阵 $L$。令 $c = \\alpha/(\\Delta r)^2$。\n- 第一行（$i=0$）为：$L_{0,0} = -4c$，$L_{0,1} = 4c$，当 $j>1$ 时 $L_{0,j}=0$。\n- 对于行 $i=1, \\ldots, N-2$，非零元素为：\n  $L_{i,i-1} = c(1 - 1/(2i))$，$L_{i,i} = -2c$，以及 $L_{i,i+1} = c(1+1/(2i))$。\n- 最后一行（$i=N-1$）必须考虑边界条件 $u_N=0$：\n  $L_{N-1,N-2} = c(1 - 1/(2(N-1)))$ 和 $L_{N-1,N-1} = -2c$。\n\n算法流程如下：\n1.  对于每个测试案例，定义参数 $(\\alpha, R, \\sigma, N, M, T)$ 并计算 $\\Delta r=R/N$ 和 $\\Delta t=T/M$。\n2.  构建矩阵 $A = I - \\frac{\\Delta t}{2} L$ 和 $B = I + \\frac{\\Delta t}{2} L$。为提高效率，我们在时间步进循环开始前一次性计算矩阵 $A$ 的 LU 分解。\n3.  使用初始条件初始化解向量 $\\mathbf{u}^0$：$u_i^0 = \\exp(-(i\\Delta r/\\sigma)^2)$，其中 $i=0, \\ldots, N-1$。\n4.  迭代 $n=0, \\ldots, M-1$：\n    a. 计算右侧向量 $\\mathbf{b} = B \\mathbf{u}^n$。\n    b. 使用预先计算的 $A$ 的 LU 分解求解线性系统 $A \\mathbf{u}^{n+1} = \\mathbf{b}$ 以得到 $\\mathbf{u}^{n+1}$。\n5.  经过 $M$ 步后，原点处的最终温度为 $u_0^M$，即最终解向量的第一个元素。报告此值。\n该实现将使用 `numpy` 进行矩阵运算，并使用 `scipy.linalg` 高效求解线性系统。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the radially symmetric heat equation for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, R, sigma, N, M, T)\n        (1.0, 1.0, 0.2, 200, 50, 0.05),\n        (1.0, 1.0, 0.2, 50, 50, 0.05),\n        (1.0, 1.0, 0.05, 200, 100, 0.02),\n        (1.0, 1.0, 0.5, 200, 50, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, R, sigma, N, M, T = case\n        result = run_simulation(alpha, R, sigma, N, M, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(alpha, R, sigma, N, M, T):\n    \"\"\"\n    Computes the temperature evolution for a single test case.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        R (float): Radius of the disk.\n        sigma (float): Width of the initial Gaussian profile.\n        N (int): Number of spatial grid points in the radius (excluding the boundary).\n        M (int): Number of time steps.\n        T (float): Final time.\n\n    Returns:\n        float: Temperature at the origin u(0, T).\n    \"\"\"\n    # Grid parameters\n    dr = R / N\n    dt = T / M\n    \n    # Grid points for r (interior points from r=0 to r=R-dr)\n    r = np.linspace(0, R - dr, N)\n\n    # Construct the spatial discretization matrix L\n    # The size of the system is N x N for points u_0, u_1, ..., u_{N-1}\n    L = np.zeros((N, N))\n    c = alpha / dr**2\n\n    # Equation at the origin (i=0)\n    L[0, 0] = -4.0 * c\n    L[0, 1] = 4.0 * c\n\n    # Equations for interior points (i=1 to N-2)\n    for i in range(1, N - 1):\n        # r_i = i * dr, so the coefficients simplify\n        L[i, i - 1] = c * (1.0 - 1.0 / (2.0 * i))\n        L[i, i]     = -2.0 * c\n        L[i, i + 1] = c * (1.0 + 1.0 / (2.0 * i))\n\n    # Equation at the point next to the boundary (i=N-1)\n    # The u_N term is zero due to boundary condition and moves to the other side.\n    if N > 1:\n        i = N - 1\n        L[i, i - 1] = c * (1.0 - 1.0 / (2.0 * i))\n        L[i, i]     = -2.0 * c\n        # The u_{N} term is u_N = 0, so L[i, i+1] which would reference u_N is zero.\n\n    # Construct Crank-Nicolson matrices A and B\n    # A u^{n+1} = B u^{n}\n    # where A = I - dt/2 * L, B = I + dt/2 * L\n    I = np.identity(N)\n    A = I - (dt / 2.0) * L\n    B = I + (dt / 2.0) * L\n\n    # Initial condition u(r, 0)\n    u = np.exp(-(r / sigma)**2)\n\n    # Pre-compute LU factorization of A for efficiency\n    try:\n        lu_and_piv = linalg.lu_factor(A)\n    except linalg.LinAlgError:\n        # This case should not be reached for a well-posed problem.\n        return np.nan\n\n    # Time-stepping loop\n    for _ in range(M):\n        # Calculate the right-hand side vector\n        b = B @ u\n        # Solve the linear system A u_next = b\n        u = linalg.lu_solve(lu_and_piv, b)\n\n    # Return the temperature at the origin at the final time\n    return u[0]\n\n# Execute the solver\nsolve()\n```", "id": "2400870"}, {"introduction": "本练习介绍了一种不同但用途广泛的范式：线方法（Method of Lines, MOL）。我们不再同时对空间和时间进行离散化，而是首先只对空间域进行离散化，这将单个偏微分方程（PDE）转化为一个大型的耦合常微分方程（ODE）组。然后，我们可以应用强大、高阶的 ODE 求解器，如四阶龙格-库塔（RK4）方法，来求解时间演化。[@problem_id:2395932]", "problem": "给定一个在有限区间上带有狄利克雷边界条件的无量纲形式的一维热传导方程。令 $u(x,t)$ 求解\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in (0,L), \\; t \\in (0,T],\n$$\n其边界条件为 $u(0,t)=g_0(t)$ 和 $u(L,t)=g_L(t)$，初始条件为 $u(x,0)=\\varphi(x)$。使用直线法（MOL）在具有 $N$ 个内部点的均匀网格上对空间域进行离散化。定义网格节点 $x_i = i\\,\\Delta x$，其中 $i \\in \\{0,1,\\dots,N+1\\}$，$\\Delta x = L/(N+1)$。对于内部索引 $i \\in \\{1,2,\\dots,N\\}$，令 $y_i(t) \\approx u(x_i,t)$。对空间二阶导数使用标准的二阶中心差分近似，使得对于每个内部索引 $i \\in \\{1,2,\\dots,N\\}$ 有，\n$$\n\\frac{d y_i}{dt}(t) = \\alpha\\,\\frac{y_{i-1}(t) - 2\\,y_i(t) + y_{i+1}(t)}{(\\Delta x)^2},\n$$\n并且在所有时间 $t$ 上强制满足 $y_0(t)=g_0(t)$ 和 $y_{N+1}(t)=g_L(t)$。初始数据为 $y_i(0)=\\varphi(x_i)$，其中 $i \\in \\{1,2,\\dots,N\\}$。使用固定的时间步长 $\\Delta t$ （假设 $T/\\Delta t$ 为整数）将此自治系统从 $t=0$ 推进到 $t=T$，并报告在内部索引\n$$\ni_\\star = \\left\\lfloor \\frac{N+1}{2} \\right\\rfloor,\n$$\n处的值，即量 $y_{i_\\star}(T)$。\n\n所有量均为无量纲。三角函数中的角度应解释为弧度。您的程序必须对以下测试集评估该系统，每个测试集均指定 $(\\alpha, L, N, \\Delta t, T, \\varphi, g_0, g_L)$：\n\n- 测试用例 $1$ (理想情况)：\n  - $\\alpha = 0.1$, $L=1$, $N=10$, $\\Delta t = 0.001$, $T=0.1$,\n  - $\\varphi(x) = \\sin(\\pi x)$,\n  - $g_0(t) = 0$, $g_L(t) = 0$。\n\n- 测试用例 $2$ (最简内部网格，边界条件驱动衰减)：\n  - $\\alpha = 0.5$, $L=1$, $N=1$, $\\Delta t=0.01$, $T=0.2$,\n  - $\\varphi(x) = x\\,(L-x)$,\n  - $g_0(t) = 0$, $g_L(t) = 0$。\n\n- 测试用例 $3$ (左侧非齐次、时变边界)：\n  - $\\alpha = 0.05$, $L=1$, $N=20$, $\\Delta t=0.0005$, $T=0.05$,\n  - $\\varphi(x) = 0$,\n  - $g_0(t) = 1 - e^{-t}$, $g_L(t) = 0$。\n\n对每个测试用例，计算 $y_{i_\\star}(T)$ 并将结果汇总到一行，以方括号括起来的逗号分隔列表形式呈现。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个数字均以十进制表示法格式化，小数点后恰好有 $10$ 位数字（例如，$[r_1,r_2,r_3]$，其中每个 $r_k$ 在小数点后恰好有 $10$ 位数字）。", "solution": "问题陈述经评估有效。它描述了将直线法应用于一维热传导方程的标准应用，这是计算物理学中的一个基本问题。为测试用例提供的参数在物理上和数值上都是合理的，可确保解的稳定性。\n\n问题描述中存在一个微小的不精确之处：它将得到的常微分方程组（ODEs）称为“自治”系统。这仅在边界条件 $g_0(t)$ 和 $g_L(t)$ 为常数时才成立。对于测试用例 3，其中 $g_0(t) = 1 - e^{-t}$，该系统是非自治的，因为右端函数显式地依赖于时间。这是一个技术性细节，不会妨碍求解，因为四阶龙格-库塔方法同样适用于形式为 $\\frac{d\\vec{y}}{dt} = \\vec{f}(t, \\vec{y})$ 的非自治系统。\n\n此外，问题正文中并未明确指定时间积分方法。然而，指定的问题主题是“四阶龙格-库塔方法”，这提供了明确的上下文。因此，我们将使用此方法进行求解。\n\n该问题要求解一维热传导方程：\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in (0,L), \\; t \\in (0,T]\n$$\n其初始条件为 $u(x,0) = \\varphi(x)$，时变狄利克雷边界条件为 $u(0,t) = g_0(t)$ 和 $u(L,t) = g_L(t)$。\n\n采用直线法（MOL）将此偏微分方程（PDE）转换为一个耦合的常微分方程组（ODEs）。空间域 $[0, L]$ 被离散化为 $N+2$ 个点 $x_i = i\\,\\Delta x$（其中 $i=0, 1, \\dots, N+1$），空间步长为 $\\Delta x = L/(N+1)$。我们在 $N$ 个内部点上寻找近似解 $y_i(t) \\approx u(x_i,t)$，即对于 $i \\in \\{1, 2, \\dots, N\\}$。\n\n每个内部节点 $x_i$ 处的空间二阶导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{x=x_i} \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{(\\Delta x)^2}\n$$\n将此近似代入热传导方程，得到一个包含 $N$ 个常微分方程的系统：\n$$\n\\frac{d y_i}{dt}(t) = \\frac{\\alpha}{(\\Delta x)^2} \\left[ y_{i-1}(t) - 2\\,y_i(t) + y_{i+1}(t) \\right], \\quad i \\in \\{1, 2, \\dots, N\\}\n$$\n通过在所有时间 $t$ 上设定 $y_0(t) = g_0(t)$ 和 $y_{N+1}(t) = g_L(t)$ 来引入边界条件。\n\n该系统可以表示为向量形式。令 $\\vec{y}(t) = [y_1(t), y_2(t), \\dots, y_N(t)]^T$ 为内部节点解的状态向量。该系统的一般形式为：\n$$\n\\frac{d\\vec{y}}{dt} = \\vec{f}(t, \\vec{y}(t))\n$$\n函数 $\\vec{f}$ 的分量由有限差分格式定义。对于每个分量 $i \\in \\{1, \\dots, N\\}$，对应的函数 $f_i$ 是：\n$$\nf_i(t, \\vec{y}) = \\frac{\\alpha}{(\\Delta x)^2} \\left[ y_{i-1}(t) - 2\\,y_i(t) + y_{i+1}(t) \\right]\n$$\n其中，$y_0(t)$ 和 $y_{N+1}(t)$ 分别被理解为边界值 $g_0(t)$ 和 $g_L(t)$。此常微分方程组的初始条件源自偏微分方程的初始条件：$\\vec{y}(0) = [\\varphi(x_1), \\varphi(x_2), \\dots, \\varphi(x_N)]^T$。\n\n为了以固定的时间步长 $\\Delta t$ 将解从 $t=0$ 推进到 $t=T$，我们使用经典的四阶龙格-库塔（RK4）方法。给定在时间 $t_n = n\\,\\Delta t$ 的解向量 $\\vec{y}_n$，在下一个时间步 $t_{n+1} = t_n + \\Delta t$ 的解计算如下：\n$$\n\\vec{y}_{n+1} = \\vec{y}_n + \\frac{\\Delta t}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\n其中四个阶段向量按顺序计算：\n\\begin{align*}\n\\vec{k}_1 &= \\vec{f}(t_n, \\vec{y}_n) \\\\\n\\vec{k}_2 &= \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2}\\vec{k}_1) \\\\\n\\vec{k}_3 &= \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2}\\vec{k}_2) \\\\\n\\vec{k}_4 &= \\vec{f}(t_n + \\Delta t, \\vec{y}_n + \\Delta t\\vec{k}_3)\n\\end{align*}\n从初始状态 $\\vec{y}_0 = \\vec{y}(0)$ 开始，此迭代过程重复总共 $M = T/\\Delta t$ 步。每个测试用例的最终结果是在特定内部节点 $i_\\star = \\left\\lfloor \\frac{N+1}{2} \\right\\rfloor$ 处、时间为 $T$ 时的解的值。在一个状态向量索引范围为 $0$ 到 $N-1$ 的零基索引编程环境中，这对应于索引为 $i_\\star - 1$ 的元素。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation using the Method of Lines with a fourth-order\n    Runge-Kutta time integrator for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, L, N, dt, T, phi, g0, gL)\n    test_cases = [\n        (\n            0.1, 1.0, 10, 0.001, 0.1,\n            lambda x, L: np.sin(np.pi * x),\n            lambda t: 0.0,\n            lambda t: 0.0\n        ),\n        (\n            0.5, 1.0, 1, 0.01, 0.2,\n            lambda x, L: x * (L - x),\n            lambda t: 0.0,\n            lambda t: 0.0\n        ),\n        (\n            0.05, 1.0, 20, 0.0005, 0.05,\n            lambda x, L: np.zeros_like(x),\n            lambda t: 1.0 - np.exp(-t),\n            lambda t: 0.0\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, N, dt, T, phi, g0, gL = case\n\n        # Spatial discretization\n        dx = L / (N + 1)\n        x_interior = np.linspace(dx, L - dx, N)\n\n        # Initial condition\n        y = phi(x_interior, L)\n\n        # Define the ODE system dy/dt = f(t, y)\n        def f(t, y_vec):\n            \"\"\"\n            Represents the discretized spatial operator for the heat equation.\n            \n            Args:\n                t (float): Current time.\n                y_vec (np.ndarray): Solution vector at interior points.\n            \n            Returns:\n                np.ndarray: The time derivative dy/dt.\n            \"\"\"\n            # Construct a temporary vector including boundary values\n            y_extended = np.concatenate(([g0(t)], y_vec, [gL(t)]))\n            \n            # Compute the second spatial derivative using central differences\n            d2y_dx2 = (y_extended[:-2] - 2 * y_extended[1:-1] + y_extended[2:]) / dx**2\n            \n            return alpha * d2y_dx2\n\n        # Time integration using RK4\n        num_steps = round(T / dt)\n        current_time = 0.0\n        \n        for _ in range(num_steps):\n            k1 = f(current_time, y)\n            k2 = f(current_time + 0.5 * dt, y + 0.5 * dt * k1)\n            k3 = f(current_time + 0.5 * dt, y + 0.5 * dt * k2)\n            k4 = f(current_time + dt, y + dt * k3)\n            \n            y = y + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n            current_time += dt\n\n        # Extract the required solution component\n        # The problem defines i_star as a 1-based index from 1 to N.\n        # Python uses 0-based indexing.\n        i_star = (N + 1) // 2\n        result_index = i_star - 1\n        \n        results.append(y[result_index])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.10f}' for r in results])}]\")\n\nsolve()\n```", "id": "2395932"}]}