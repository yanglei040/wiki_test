{"hands_on_practices": [{"introduction": "第一个实践将让你掌握一项基本任务：通过数值方法验证有限差分格式的精度。你将处理一个经典的椭圆型偏微分方程——泊松方程（Poisson equation），并分别使用标准的5点格式和更高阶的9点格式进行求解。通过在逐渐加密的网格上将数值解与已知的精确解进行比较，你将直接观察到误差是如何减小的，并验证方法的理论收敛阶，这是任何计算科学家都应具备的基石技能。[@problem_id:2393516]", "problem": "考虑在单位正方形域上的二维泊松方程，其带有齐次 Dirichlet 边界条件。设开域为 $\\Omega = (0,1)\\times(0,1)$，边界为 $\\partial\\Omega$。定义精确解为 $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$，对于 $(x,y)\\in \\overline{\\Omega}$，该解是解析且非多项式的。源项由控制方程 $-\\Delta u = f$ 在 $\\Omega$ 中确定，且在 $\\partial\\Omega$ 上有 $u = 0$。\n\na) 根据 $u(x,y)$ 的定义和等式 $-\\Delta u = f$，推导 $f(x,y)$ 的闭式表达式。\n\nb) 对于一个均匀笛卡尔网格，每个坐标方向有 $m$ 个相等的子区间，定义网格间距 $h = 1/m$ 和网格节点 $(x_i,y_j) = (i h, j h)$，其中 $i,j\\in\\{0,1,\\dots,m\\}$。通过 Dirichlet 条件 $u(x,y)=0$ 在 $\\partial\\Omega$ 上施加边界值，这对精确解 $u$ 成立。对于内部节点，使用以下两种针对内部节点 $(i,j)$ 处 $-\\Delta$ 的离散算子，构建与 $-\\Delta u = f$ 相应的离散线性系统：\n- 标准的二阶 $5$ 点差分格式，\n$$\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right).$$\n- 经典的四阶 $9$ 点差分格式，\n$$\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big).$$\n\nc) 对于每个选定的 $m$，令 $u_h^{(5)}$ 和 $u_h^{(9)}$ 分别表示通过求解各自的离散系统得到的网格上的数值解，其中右端项在内部节点处设为 $f(x_i,y_j)$。通过将边界值设为精确解 $u(x_i,y_j)$，内部值设为相应的数值解，来构造完整的网格函数。定义网格函数 $w$ 相对于精确解 $u$ 的离散均方根误差（一种离散 $L^2$ 逼近）为\n$$E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}.$$\n令 $E^{(5)}(h)$ 和 $E^{(9)}(h)$ 分别表示 $5$ 点和 $9$ 点解的这些误差。\n\nd) 对于每对连续的网格间距 $(h, h/2)$，定义观测到的以 2 为底的收敛率为\n$$p^{(5)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(5)}(h)}{E^{(5)}(h/2)}\\right),\\qquad p^{(9)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(9)}(h)}{E^{(9)}(h/2)}\\right).$$\n\n使用以下子区间数量的测试集：$m\\in\\{2,4,8,16\\}$。对于每个 $m$，使用 $u$ 的定义计算 $f$ 并在 $\\partial\\Omega$ 上施加边界条件 $u=0$。对于两两加密 $(m,m') = (2,4)$、$(4,8)$ 和 $(8,16)$，计算相应的观测收敛率。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$。\n\n所有数值必须以浮点数形式报告。不涉及物理单位。如果出现角度，必须以弧度为单位。最终输出格式必须与规范完全匹配：单行输出，列表用方括号括起来，值用逗号分隔。", "solution": "问题陈述经过严格验证。\n\n步骤 1：提取的已知条件\n-   **控制方程**: 二维泊松方程 $-\\Delta u = f$，定义在开放单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上。\n-   **边界条件 (BC)**: 齐次 Dirichlet 边界条件，$u = 0$ 定义在边界 $\\partial\\Omega$ 上。\n-   **精确解**: $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$，对于 $(x,y)\\in \\overline{\\Omega} = [0,1]\\times[0,1]$。\n-   **源项**: 由等式 $f = -\\Delta u$ 定义。\n-   **离散化**: 均匀笛卡尔网格，每个方向有 $m$ 个子区间，得到网格间距 $h = 1/m$ 和节点 $(x_i,y_j) = (ih, jh)$，其中 $i,j\\in\\{0,1,\\dots,m\\}$。\n-   **离散算子**:\n    -   用于负拉普拉斯算子的标准二阶 $5$ 点差分格式：$\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right)$。\n    -   用于负拉普拉斯算子的经典四阶 $9$ 点差分格式：$\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big)$。\n-   **数值解**: $u_h^{(5)}$ 和 $u_h^{(9)}$ 是由差分格式产生的离散线性系统的解。右端项在内部节点处为 $f(x_i,y_j)$。边界值设为 $u(x_i,y_j)=0$。\n-   **误差度量**: 离散均方根误差 $E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}$。\n-   **收敛率**: 观测到的以 2 为底的收敛率 $p(h\\to h/2) = \\log_2\\left(\\frac{E(h)}{E(h/2)}\\right)$。\n-   **测试参数**: 子区间数量 $m\\in\\{2,4,8,16\\}$。\n-   **要求输出**: 一个数值列表：$[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$。\n\n步骤 2：使用提取的已知条件进行验证\n该问题是偏微分方程数值分析中的一个标准练习，特别是将有限差分法应用于泊松方程。\n-   **有科学依据**: 该问题基于数值分析和偏微分方程的既定数学原理。泊松方程、有限差分格式和收敛性分析都是基础且被广泛理解的概念。\n-   **适定性**: 带有 Dirichlet 边界条件的泊松方程是适定椭圆问题的经典例子。两种差分格式所产生的离散线性系统都对应于对称正定矩阵，从而保证了解的唯一性。\n-   **客观性**: 问题以精确、客观的数学语言陈述。\n-   **一致性检查**: 给定的精确解 $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ 正确地满足了在 $\\partial\\Omega$ 上的齐次 Dirichlet 边界条件 $u=0$，因为当 $x=0,1$ 时 $\\sin(\\pi x) = 0$，当 $y=0,1$ 时 $\\sin(\\pi y)=0$。\n-   **完整性**: 提供了构建和解决问题所需的所有必要信息。\n\n步骤 3：结论与行动\n该问题是有效的。它在科学上是合理的、适定的和自洽的。将提供完整的解决方案。\n\n**a) 部分：源项 $f(x,y)$ 的推导**\n\n源项 $f(x,y)$ 由关系式 $f = -\\Delta u = -(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2})$ 确定。我们计算精确解 $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ 的二阶偏导数。\n\n首先，关于 $x$ 的偏导数：\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) \\right) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) + \\pi \\mathrm{e}^{x+y}\\cos(\\pi x)\\sin(\\pi y) $$\n其次，关于 $x$ 的二阶偏导数：\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) \\right) \\\\ = \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) + \\mathrm{e}^{x+y}(\\pi\\cos(\\pi x) - \\pi^2\\sin(\\pi x))\\sin(\\pi y) \\\\ = \\mathrm{e}^{x+y}\\sin(\\pi y) \\left[ (1-\\pi^2)\\sin(\\pi x) + 2\\pi\\cos(\\pi x) \\right] $$\n由于 $u(x,y)$ 在交换 $x$ 和 $y$ 时具有对称性，关于 $y$ 的二阶偏导数是类似的：\n$$ \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y}\\sin(\\pi x) \\left[ (1-\\pi^2)\\sin(\\pi y) + 2\\pi\\cos(\\pi y) \\right] $$\n拉普拉斯算子 $\\Delta u$ 是这些二阶偏导数的和：\n$$ \\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y} \\left[ 2(1-\\pi^2)\\sin(\\pi x)\\sin(\\pi y) + 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\n最后，源项为 $f(x,y) = -\\Delta u$：\n$$ f(x,y) = \\mathrm{e}^{x+y} \\left[ 2(\\pi^2-1)\\sin(\\pi x)\\sin(\\pi y) - 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\n这就是所要求的闭式表达式。\n\n**b)、c)、d) 部分：数值解与分析**\n\n此问题要求解线性系统 $A \\mathbf{u}_h = \\mathbf{b}$，以求出在 $(m-1)^2$ 个内部网格点上数值解的未知值。向量 $\\mathbf{u}_h$ 包含值 $u_{i,j}$（其中 $i,j \\in \\{1, \\dots, m-1\\}$），并按字典序（列主序）排列。矩阵 $A$ 表示离散负拉普拉斯算子，向量 $\\mathbf{b}$ 包含内部点处源项 $f(x_i, y_j)$ 的值。\n\n对于 $5$ 点差分格式，与 $(-\\Delta_h^{(5)})$ 对应的矩阵 $A_5$ 可以使用 Kronecker 积来构造。设 $T_{1D}$ 为一维二阶导数算子 $-\\frac{d^2}{dx^2}$ 的 $(m-1) \\times (m-1)$ 矩阵，由 $T_{1D} = \\frac{1}{h^2} \\text{tridiag}(-1, 2, -1)$ 给出。设 $I$ 为 $(m-1) \\times (m-1)$ 的单位矩阵。则二维算子的矩阵为：\n$$ A_5 = I \\otimes T_{1D} + T_{1D} \\otimes I $$\n\n对于 $9$ 点差分格式，与 $(-\\Delta_h^{(9)})$ 对应的矩阵 $A_9$ 具有块三对角结构 $A_9 = \\text{block\\_tridiag}(B, D, B)$，其中块 $D$ 和 $B$ 是 $(m-1) \\times (m-1)$ 矩阵：\n$$ D = \\frac{1}{6h^2} \\text{tridiag}(-4, 20, -4) $$\n$$ B = \\frac{1}{6h^2} \\text{tridiag}(-1, -4, -1) $$\n这种结构源于差分格式的系数，它将同一网格行内的节点（矩阵 $D$）和相邻网格行之间的节点（矩阵 $B$）耦合起来。\n\n对于每个 $m \\in \\{2, 4, 8, 16\\}$，数值计算步骤如下：\n1.  设置网格间距 h=1/m 并定义网格坐标。\n2.  构建大小为 $(m-1)^2 \\times (m-1)^2$ 的稀疏矩阵 A_5 和 A_9。\n3.  通过在 $(m-1)^2$ 个内部网格点上计算 $f(x_i, y_j)$ 来构建右端项向量 $\\mathbf{b}$。\n4.  求解两个线性系统 $A_5 \\mathbf{u}_h^{(5)} = \\mathbf{b}$ 和 $A_9 \\mathbf{u}_h^{(9)} = \\mathbf{b}$，以获得内部点的数值解。\n5.  将内部解嵌入一个零值网格中，形成完整的 $(m+1) \\times (m+1)$ 网格解 $u_h^{(5)}$ 和 $u_h^{(9)}$，这正确地表示了齐次边界条件。\n6.  在完整网格上计算精确解 $u(x,y)$。\n7.  使用指定公式计算离散均方根误差 $E^{(5)}(h)$ 和 $E^{(9)}(h)$。为每个 $m$ 值存储这些误差。\n8.  在计算完所有 $m$ 值的误差后，使用给定的对数公式为每个加密级别计算观测到的收敛率 $p^{(5)}$ 和 $p^{(9)}$。\n\n对于二阶 $5$ 点差分格式，期望收敛率 $p \\approx 2$；对于四阶 $9$ 点差分格式，期望收敛率 $p \\approx 4$，因为这些分别是相应离散化的理论精度阶数。数值实验旨在验证这一理论行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D Poisson equation on a unit square using 5-point and 9-point\n    finite difference stencils and computes errors and convergence rates.\n    \"\"\"\n    m_values = [2, 4, 8, 16]\n    errors = {'5': {}, '9': {}}\n\n    def u_exact_func(x, y):\n        \"\"\"Computes the exact solution u(x,y).\"\"\"\n        return np.exp(x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def f_func(x, y):\n        \"\"\"Computes the source term f(x,y) = -Delta u.\"\"\"\n        term1 = 2 * (np.pi**2 - 1) * np.sin(np.pi * x) * np.sin(np.pi * y)\n        term2 = -2 * np.pi * (np.cos(np.pi * x) * np.sin(np.pi * y) + np.sin(np.pi * x) * np.cos(np.pi * y))\n        return np.exp(x + y) * (term1 + term2)\n\n    for m in m_values:\n        h = 1.0 / m\n        N = m - 1  # Number of interior grid points in one dimension\n\n        # Create the full grid\n        grid_pts = np.linspace(0, 1, m + 1)\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n\n        # Evaluate exact solution on the full grid\n        u_exact_grid = u_exact_func(X, Y)\n\n        if N == 0: # Trivial case with no interior points\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n        else:\n            N2 = N * N # Total number of unknowns\n\n            # Interior grid points and RHS vector b\n            interior_grid_pts = np.linspace(h, 1 - h, N)\n            XI, YI = np.meshgrid(interior_grid_pts, interior_grid_pts, indexing='ij')\n            # Use Fortran ordering for flattening to match lexicographical (column-major) order\n            b = f_func(XI, YI).flatten(order='F')\n\n            # --- 5-point stencil system ---\n            # A_5 = I kron T + T kron I for -Delta\n            T_1d = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(N, N))\n            I_n = sparse.eye(N)\n            A5 = (1 / h**2) * (sparse.kron(I_n, T_1d) + sparse.kron(T_1d, I_n))\n            \n            u_sol_5_flat = spsolve(A5.tocsc(), b)\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_5[1:-1, 1:-1] = u_sol_5_flat.reshape((N, N), order='F')\n\n            # --- 9-point stencil system ---\n            # Block-tridiagonal construction A_9 = block_tridiag(B, D, B)\n            D_diag_vals = [np.full(N - 1, -4), np.full(N, 20), np.full(N - 1, -4)]\n            D = (1 / (6 * h**2)) * sparse.diags(D_diag_vals, [-1, 0, 1])\n\n            B_diag_vals = [np.full(N - 1, -1), np.full(N, -4), np.full(N - 1, -1)]\n            B = (1 / (6 * h**2)) * sparse.diags(B_diag_vals, [-1, 0, 1])\n            \n            # Off-diagonal blocks for Kronecker sum\n            off_diag_block_matrix = sparse.diags([1, 1], [-1, 1], shape=(N, N))\n            A9 = sparse.kron(I_n, D) + sparse.kron(off_diag_block_matrix, B)\n            \n            u_sol_9_flat = spsolve(A9.tocsc(), b)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n            u_sol_9[1:-1, 1:-1] = u_sol_9_flat.reshape((N, N), order='F')\n\n        # Compute discrete RMS error: E = sqrt(h^2 * sum((w-u)^2))\n        # This is equivalent to h * Frobenius_norm(w-u)\n        diff_5 = u_sol_5 - u_exact_grid\n        errors['5'][m] = h * np.sqrt(np.sum(diff_5**2))\n\n        diff_9 = u_sol_9 - u_exact_grid\n        errors['9'][m] = h * np.sqrt(np.sum(diff_9**2))\n\n    # Calculate convergence rates and assemble final results\n    results = []\n    \n    # E(h=1/2) for m=2\n    results.append(errors['5'][2])\n    results.append(errors['9'][2])\n\n    # p(1/2 -> 1/4) for m=2,4\n    results.append(np.log2(errors['5'][2] / errors['5'][4]))\n    results.append(np.log2(errors['9'][2] / errors['9'][4]))\n\n    # p(1/4 -> 1/8) for m=4,8\n    results.append(np.log2(errors['5'][4] / errors['5'][8]))\n    results.append(np.log2(errors['9'][4] / errors['9'][8]))\n\n    # p(1/8 -> 1/16) for m=8,16\n    results.append(np.log2(errors['5'][8] / errors['5'][16]))\n    results.append(np.log2(errors['9'][8] / errors['9'][16]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393516"}, {"introduction": "从稳态问题转向时间演化问题，本实践将探索一维热传导方程这一典型的抛物型偏微分方程。重点将转移到实际操作中的一个关键方面：边界条件的处理。你将研究两种不同的诺伊曼（Neumann）边界条件数值近似方法——一种是一阶格式，另一种是二阶格式——如何影响模拟的全局精度，从而亲身验证一个重要原则：即整体误差往往由离散化方案中的“最弱环节”所决定。[@problem_id:2393512]", "problem": "考虑空间区间 $[0,1]$ 上的一维热传导方程（一种抛物型偏微分方程），\n$$\nu_t(x,t) = \\alpha \\, u_{xx}(x,t), \\quad x \\in [0,1], \\; t \\in [0,T],\n$$\n其中热扩散系数 $\\alpha > 0$，并服从于诺伊曼(Neumann)边界条件\n$$\nu_x(0,t) = g_0(t), \\quad u_x(1,t) = g_1(t),\n$$\n和一个初始条件\n$$\nu(x,0) = u_0(x).\n$$\n通过比较两种在空间上具有不同阶相容性的诺伊曼(Neumann)边界条件的数学实现，研究不同的边界条件闭合格式如何影响总体精度。对于所有内部网格点，$u_{xx}$ 的内部空间离散化必须采用标准二阶中心有限差分，时间推进必须采用向前欧拉法。待比较的两种边界闭合格式是：\n\n1. 一种一阶相容的单边闭合格式（记为 $\\mathrm{FO}$）：在 $x=0$ 和 $x=1$ 处，使用一阶单边有限差分来施加诺伊曼(Neumann)边界条件以消除虚拟点值，\n$$\n\\frac{u(x_0,t) - u(x_{-1},t)}{h} = g_0(t) \\;\\;\\Rightarrow\\;\\; u(x_{-1},t) = u(x_0,t) - h\\, g_0(t),\n$$\n$$\n\\frac{u(x_{N+1},t) - u(x_N,t)}{h} = g_1(t) \\;\\;\\Rightarrow\\;\\; u(x_{N+1},t) = u(x_N,t) + h\\, g_1(t),\n$$\n其中 $h$ 是空间步长，$x_i = i h$, $i=0,1,\\dots,N$，满足 $N h = 1$，且 $x_{-1}$ 和 $x_{N+1}$ 是虚拟点。\n\n2. 一种二阶相容的中心闭合格式（记为 $\\mathrm{SO}$）：在 $x=0$ 和 $x=1$ 处，使用中心有限差分来施加诺伊曼(Neumann)边界条件以消除虚拟点值，\n$\n\\frac{u(x_1,t) - u(x_{-1},t)}{2h} = g_0(t) \\;\\Rightarrow\\; u(x_{-1},t) = u(x_1,t) - 2 h\\, g_0(t),\n$\n$\n\\frac{u(x_{N+1},t) - u(x_{N-1},t)}{2h} = g_1(t) \\;\\Rightarrow\\; u(x_{N+1},t) = u(x_{N-1},t) + 2 h\\, g_1(t).\n$\n\n在每个显式时间步中，使用虚拟点值，并采用与内部相同的 $u_{xx}$ 二阶中心公式来计算边界节点上的离散拉普拉斯算子。向前欧拉法的时间步长必须选择为\n$$\n\\Delta t = c \\, \\frac{h^2}{2 \\alpha},\n$$\n其中 $c = 0.45$ 是一个固定常数，对于 $T > 0$，时间步数取为最接近 $T / \\Delta t$ 的整数，并调整最后一步的步长以确保最终时间恰好是 $T$。\n\n使用以下两种精确人造解（本问题不涉及物理单位）：\n- 情形A（非零诺伊曼(Neumann)通量）：取\n$$\nu(x,t) = \\sin(\\pi x)\\, e^{-\\alpha \\pi^2 t}, \\quad u_0(x) = \\sin(\\pi x), \\quad g_0(t) = \\pi \\, e^{-\\alpha \\pi^2 t}, \\quad g_1(t) = -\\pi \\, e^{-\\alpha \\pi^2 t}.\n$$\n- 情形B（齐次诺伊曼(Neumann)通量）：取\n$$\nu(x,t) = \\cos(\\pi x)\\, e^{-\\alpha \\pi^2 t}, \\quad u_0(x) = \\cos(\\pi x), \\quad g_0(t) = 0, \\quad g_1(t) = 0.\n$$\n\n固定参数 $\\alpha = 1$, $T = 0.1$。对于两种边界闭合格式 $\\mathrm{FO}$ 和 $\\mathrm{SO}$ 中的每一种，以及情形A和B中的每一种，计算在时间 $T$ 时，均匀网格 $N \\in \\{20, 40, 80, 160\\}$ 上的离散 $L^2$ 范数误差（其中 $h = 1/N$，网格点为 $x_i = i h$, $i = 0, 1, \\dots, N$）。对于在这4次网格加密中收集到的误差序列 $E(h)$，将观测到的空间阶 $p$ 定义为 $\\log E$ 对 $\\log h$ 进行最小二乘拟合得到的斜率。\n\n你的程序必须：\n- 实现采用给定 $\\Delta t$ 公式和二阶中心内点空间离散的向前欧拉时间积分。\n- 严格按照给定的方式实现两种边界闭合格式 $\\mathrm{FO}$ 和 $\\mathrm{SO}$。\n- 对于两种情形（A和B）以及每种边界闭合格式，使用 $\\{(\\log h, \\log E(h))\\}$ 上的最小二乘法从四层网格的误差序列中计算观测阶 $p$。\n- 此外，报告在最细网格 $N=160$ 上，$\\mathrm{SO}$ 闭合格式是否比 $\\mathrm{FO}$ 闭合格式获得了更小的 $L^2$ 范数误差。\n\n测试套件和要求输出：\n- 使用 $\\alpha = 1$, $T = 0.1$, $c = 0.45$ 和 $N \\in \\{20, 40, 80, 160\\}$。\n- 按以下顺序生成六个输出：\n  1. 情形A下采用 $\\mathrm{FO}$ 的观测阶 $p$。\n  2. 情形A下采用 $\\mathrm{SO}$ 的观测阶 $p$。\n  3. 情形B下采用 $\\mathrm{FO}$ 的观测阶 $p$。\n  4. 情形B下采用 $\\mathrm{SO}$ 的观测阶 $p$。\n  5. 一个布尔值，指示在情形A的 $N=160$ 网格上，$\\mathrm{SO}$ 的 $L^2$ 范数误差是否严格小于 $\\mathrm{FO}$ 的误差。\n  6. 一个布尔值，指示在情形B的 $N=160$ 网格上，$\\mathrm{SO}$ 的 $L^2$ 范数误差是否严格小于 $\\mathrm{FO}$ 的误差。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含六个结果，以逗号分隔列表的形式置于方括号内，并严格遵循上述顺序。例如，形如\n$$\n[\\;p\\_A^{\\mathrm{FO}},\\;p\\_A^{\\mathrm{SO}},\\;p\\_B^{\\mathrm{FO}},\\;p\\_B^{\\mathrm{SO}},\\;b\\_A,\\;b\\_B\\;]\n$$\n的输出，其中前四项为实数（浮点数），后两项为布尔值。不应打印任何其他文本。", "solution": "问题陈述经过严格验证，并被确定为具有科学依据、适定且自洽。它提出了一个标准的数值分析任务，涉及使用有限差分法求解抛物型偏微分方程。所有参数、方程和条件都得到了明确定义，构成了一个一致且可解的问题。我们着手进行解的推导和实现。\n\n该问题要求在区域 $x \\in [0,1]$ 和 $t \\in [0,T]$ 上模拟一维热传导方程 $u_t(x,t) = \\alpha \\, u_{xx}(x,t)$。我们在均匀网格上采用有限差分法，空间点为 $x_i = i h$，其中 $i=0, 1, \\dots, N$，$h=1/N$ 是空间步长。时间域被离散化为大小为 $\\Delta t$ 的步长，其中 $t_n = n \\Delta t$。令 $u_i^n$ 为精确解 $u(x_i, t_n)$ 的数值近似。\n\n时间导数 $u_t$ 使用一阶精度的向前欧拉法来近似。空间二阶导数 $u_{xx}$ 使用二阶精度的中心差分格式来近似。结合这些离散化方法，得到对所有网格点 $i=0, \\dots, N$ 的更新规则：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\n对 $u_i^{n+1}$ 进行整理，并引入网格傅里叶数 $\\lambda = \\frac{\\alpha \\Delta t}{h^2}$，我们得到显式更新公式：\n$$\nu_i^{n+1} = u_i^n + \\lambda (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n此公式应用于所有内部点 $i = 1, \\dots, N-1$。对于边界点 $i=0$ 和 $i=N$，该公式需要“虚拟点” $x_{-1} = -h$ 和 $x_{N+1} = 1+h$ 处的值。这些值 $u_{-1}^n$ 和 $u_{N+1}^n$ 是通过使用两种不同的有限差分闭合格式来施加诺伊曼(Neumann)边界条件 $u_x(0,t) = g_0(t)$ 和 $u_x(1,t) = g_1(t)$ 来确定的。\n\n问题指定了时间和空间步长之间的固定关系：$\\Delta t = c \\frac{h^2}{2 \\alpha}$，其中 $c = 0.45$。这得到 $\\lambda = c/2 = 0.225$，满足向前欧拉法的稳定性条件 $\\lambda \\le 1/2$。时间步数取为最接近 $T/\\Delta t$ 的整数，然后调整 $\\Delta t$ 以确保最终时间恰好是 $T$。\n\n两种边界闭合格式如下：\n\n1.  **一阶（FO）闭合格式**：虚拟点由诺伊曼(Neumann)条件的一阶精度单边差分近似确定，具体如下：\n    $$\n    u_{-1}^n = u_0^n - h g_0(t_n)\n    $$\n    $$\n    u_{N+1}^n = u_N^n + h g_1(t_n)\n    $$\n    将这些代入 $i=0$ 和 $i=N$ 的通用更新公式，得到特定的边界更新规则：\n    -   在 $i=0$ 处： $u_0^{n+1} = u_0^n + \\lambda (u_1^n - 2u_0^n + (u_0^n - h g_0(t_n))) = (1-\\lambda) u_0^n + \\lambda u_1^n - \\lambda h g_0(t_n)$。\n    -   在 $i=N$ 处： $u_N^{n+1} = u_N^n + \\lambda ((u_N^n + h g_1(t_n)) - 2u_N^n + u_{N-1}^n) = \\lambda u_{N-1}^n + (1-\\lambda) u_N^n + \\lambda h g_1(t_n)$。\n    该边界条件实现的局部截断误差为 $\\mathcal{O}(h)$。这预计会将整个格式的总体空间精度限制在一阶，因此观测到的收敛率 $p$ 应约等于 $1$。\n\n2.  **二阶（SO）闭合格式**：虚拟点由诺伊曼(Neumann)条件的二阶精度中心差分近似确定：\n    $$\n    u_{-1}^n = u_1^n - 2h g_0(t_n)\n    $$\n    $$\n    u_{N+1}^n = u_{N-1}^n + 2h g_1(t_n)\n    $$\n    代入这些可得到边界更新规则：\n    -   在 $i=0$ 处： $u_0^{n+1} = u_0^n + \\lambda (u_1^n - 2u_0^n + (u_1^n - 2h g_0(t_n))) = (1-2\\lambda) u_0^n + 2\\lambda u_1^n - 2\\lambda h g_0(t_n)$。\n    -   在 $i=N$ 处： $u_N^{n+1} = u_N^n + \\lambda ((u_{N-1}^n + 2h g_1(t_n)) - 2u_N^n + u_{N-1}^n) = 2\\lambda u_{N-1}^n + (1-2\\lambda) u_N^n + 2\\lambda h g_1(t_n)$。\n    该边界实现的局部截断误差为 $\\mathcal{O}(h^2)$，这与内部空间离散化的 $\\mathcal{O}(h^2)$ 精度是一致的。时间误差为 $\\mathcal{O}(\\Delta t) = \\mathcal{O}(h^2)$。因此，整个格式预计将是二阶精度的，观测到的收敛率 $p$ 应约等于 $2$。\n\n数值实验按如下步骤进行：对于每种情形（A、B）和每种闭合格式（FO、SO），我们针对一系列网格分辨率 $N \\in \\{20, 40, 80, 160\\}$ 求解该问题。对于每个分辨率，我们计算在时间 $T$ 的最终数值解 $u_i$。误差使用离散 $L^2$ 范数来度量，其定义为 $E(h) = \\sqrt{h \\sum_{i=0}^N (u_i - u_{exact}(x_i, T))^2}$。观测到的收敛阶 $p$ 是通过对点 $(\\log h, \\log E(h))$ 进行线性最小二乘拟合的斜率来计算的。最后，比较两种闭合格式在最细网格（$N=160$）上的误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified. It computes convergence orders\n    for two different Neumann boundary condition closures for the 1D heat equation.\n    \"\"\"\n    # Define problem parameters\n    alpha = 1.0\n    T = 0.1\n    c = 0.45\n    N_values = [20, 40, 80, 160]\n\n    # Define the two manufactured solution cases\n    case_A = {\n        'name': 'A',\n        'u_exact': lambda x, t, a: np.sin(np.pi * x) * np.exp(-a * np.pi**2 * t),\n        'u_0': lambda x: np.sin(np.pi * x),\n        'g_0': lambda t, a: np.pi * np.exp(-a * np.pi**2 * t),\n        'g_1': lambda t, a: -np.pi * np.exp(-a * np.pi**2 * t)\n    }\n\n    case_B = {\n        'name': 'B',\n        'u_exact': lambda x, t, a: np.cos(np.pi * x) * np.exp(-a * np.pi**2 * t),\n        'u_0': lambda x: np.cos(np.pi * x),\n        'g_0': lambda t, a: 0.0,\n        'g_1': lambda t, a: 0.0\n    }\n\n    # Define the configurations to test\n    test_configs = [\n        {'case': case_A, 'closure': 'FO'},\n        {'case': case_A, 'closure': 'SO'},\n        {'case': case_B, 'closure': 'FO'},\n        {'case': case_B, 'closure': 'SO'},\n    ]\n\n    observed_orders = []\n    errors_N160 = {}\n\n    for config in test_configs:\n        case = config['case']\n        closure_type = config['closure']\n        \n        log_h_list = []\n        log_E_list = []\n\n        for N in N_values:\n            h = 1.0 / N\n            x = np.linspace(0.0, 1.0, N + 1)\n            \n            # Time stepping setup\n            dt_base = c * h**2 / (2.0 * alpha)\n            num_steps = int(round(T / dt_base))\n            dt = T / num_steps\n            \n            lam = alpha * dt / h**2\n            \n            # Initial condition\n            u = case['u_0'](x)\n            \n            # Time integration loop\n            for n in range(num_steps):\n                t_n = n * dt\n                u_new = np.zeros_like(u)\n                \n                # Interior points update\n                u_new[1:-1] = u[1:-1] + lam * (u[:-2] - 2 * u[1:-1] + u[2:])\n                \n                # Boundary functions g0(t), g1(t)\n                g0_tn = case['g_0'](t_n, alpha)\n                g1_tn = case['g_1'](t_n, alpha)\n\n                # Boundary points update\n                if closure_type == 'FO':\n                    u_new[0] = (1.0 - lam) * u[0] + lam * u[1] - lam * h * g0_tn\n                    u_new[-1] = lam * u[-2] + (1.0 - lam) * u[-1] + lam * h * g1_tn\n                elif closure_type == 'SO':\n                    u_new[0] = (1.0 - 2.0 * lam) * u[0] + 2.0 * lam * u[1] - 2.0 * lam * h * g0_tn\n                    u_new[-1] = 2.0 * lam * u[-2] + (1.0 - 2.0 * lam) * u[-1] + 2.0 * lam * h * g1_tn\n\n                u = u_new\n\n            # Compute error at final time T\n            u_exact_T = case['u_exact'](x, T, alpha)\n            error = np.sqrt(h) * np.linalg.norm(u - u_exact_T)\n            \n            log_h_list.append(np.log(h))\n            log_E_list.append(np.log(error))\n            \n            if N == 160:\n                errors_N160[(case['name'], closure_type)] = error\n\n        # Compute observed order of convergence using least-squares fit\n        p, _ = np.polyfit(log_h_list, log_E_list, 1)\n        observed_orders.append(p)\n    \n    # Final comparisons for N=160\n    b_A = errors_N160[('A', 'SO')]  errors_N160[('A', 'FO')]\n    b_B = errors_N160[('B', 'SO')]  errors_N160[('B', 'FO')]\n    \n    # Prepare results for printing\n    results_list = observed_orders + [b_A, b_B]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results_list))}]\")\n\nsolve()\n```", "id": "2393512"}, {"introduction": "这个综合性实践将让你挑战一个非线性的高阶偏微分方程：Kuramoto-Sivashinsky 方程，一个时空混沌的范例模型。为了求解它，你需要超越简单的格式，实现一种强大的隐式-显式（IMEX）方法，这对于同时包含刚性线性和非刚性非线性部分的方程至关重要。本练习不仅让你掌握处理复杂动力学问题的策略，还展示了在周期性区域上利用快速傅里叶变换（FFT）高效求解隐式部分方案的威力。[@problem_id:2393592]", "problem": "考虑 Kuramoto–Sivashinsky 偏微分方程 (PDE)\n$$u_t + u\\,u_x + u_{xx} + u_{xxxx} = 0,$$\n该方程定义在一个长度为 $L$ 的一维周期性域上，即 $x \\in [0,L)$，并采用周期性边界条件。你的任务是，从第一性原理出发，推导、实现并测试一种能够在时间上推进解的有限差分法。你必须遵循以下要求：\n\n- 从线方法（method-of-lines）的观点和有限差分法的核心定义出发。在一个包含 $N$ 个节点的均匀网格上使用标准的中心有限差分格式进行空间离散，网格间距为 $\\Delta x = L/N$，并使用周期性环绕索引。在每个时间步中，通过一次线性求解隐式处理线性项 $u_{xx}$ 和 $u_{xxxx}$，并以守恒（斜对称）形式显式处理非线性对流项 $u\\,u_x$。使用对于线性部分无条件稳定且对于完整 PDE 相容的单步时间离散格式。在所有空间算子中均使用周期性边界条件。\n- 确保你的离散空间微分是守恒的，即对于周期性网格，离散导数在所有节点上的离散和恰好为零。\n- 程序必须是完全确定性的（无随机性）。使用如下指定的平滑、零均值的三角函数初始数据。不允许外部输入。\n\n初始条件族：对于参数 $A$ 和整数 $m$，使用\n$$u(x,0) = A\\left[\\sin\\!\\left(\\tfrac{2\\pi m}{L}\\,x\\right) + \\tfrac{1}{4}\\cos\\!\\left(\\tfrac{4\\pi m}{L}\\,x\\right)\\right].$$\n\n每个测试用例需报告的数值输出：\n- 初始时刻与最终时刻之间离散空间平均值的绝对漂移，\n$$\\left|\\overline{u}(T)-\\overline{u}(0)\\right|,$$\n其中 $\\overline{u}(t)$ 是在时间 $t$ 时所有网格点上的离散平均值。\n- 最终时刻的离散本质上确界（无穷范数），\n$$\\|u(\\cdot,T)\\|_{\\infty} = \\max_i |u_i(T)|.$$\n\n两个报告值都必须四舍五入到 $6$ 位小数。\n\n测试套件：对以下四组参数运行你的求解器。对于每组参数，最终时间为 $T$，时间步长为 $\\Delta t$，且步数 $T/\\Delta t$ 是一个整数。\n\n- 测试 $1$：$L=32.0$, $N=64$, $\\Delta t=0.01$, $T=0.5$, $A=0.5$, $m=1$。\n- 测试 $2$：$L=32.0$, $N=128$, $\\Delta t=0.005$, $T=0.5$, $A=0.5$, $m=1$。\n- 测试 $3$：$L=8.0$, $N=64$, $\\Delta t=0.01$, $T=0.2$, $A=0.5$, $m=1$。\n- 测试 $4$：$L=32.0$, $N=64$, $\\Delta t=0.01$, $T=0.5$, $A=0.0$, $m=1$。\n\n最终输出格式：\n- 你的程序应该产生单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是一个双元素列表。每个双元素列表的形式必须为 $[\\text{mean\\_drift},\\text{final\\_linf}]$，两个值都四舍五入到 $6$ 位小数。例如，\n$$[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]],$$\n除了列表的默认字符串转换所显示的空格外，不添加任何其他空格。\n\n你的最终答案必须是一个完整的、可运行的程序，该程序只产生这一行输出，不包含任何其他内容。答案是无量纲的；不要使用任何物理单位。三角函数中出现的角度，根据其构造，单位为弧度。", "solution": "所提出的问题是数值偏微分方程领域中一个适定的计算任务。它具有科学依据，内部一致，并包含了解决该问题所需的所有信息。我们将从第一性原理出发，给出一个完整的解。\n\n控制方程是 Kuramoto–Sivashinsky (KS) 偏微分方程 (PDE)：\n$$u_t + u\\,u_x + u_{xx} + u_{xxxx} = 0$$\n该方程定义在一维周期性域 $x \\in [0,L)$ 上。我们的任务是使用有限差分法对此方程进行数值求解。\n\n首先，我们采用线方法（method-of-lines）。我们将空间域离散化为一个包含 $N$ 个点的均匀网格，$x_i = i \\Delta x$，其中 $i = 0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/N$。令 $u_i(t)$ 为解 $u(x_i, t)$ 的近似值。该偏微分方程组被转化为关于向量 $\\mathbf{u}(t) = [u_0(t), u_1(t), \\dots, u_{N-1}(t)]^T$ 的常微分方程组 (ODEs)。\n\nKS 方程可以写为 $u_t = \\mathcal{N}(u) + \\mathcal{L}(u)$，其中 $\\mathcal{N}(u) = -u u_x$ 是非线性部分，$\\mathcal{L}(u) = -u_{xx} - u_{xxxx}$ 是线性部分。\n\n我们使用带周期性边界条件的中心有限差分格式来离散化空间算子。二阶和四阶导数的模板为：\n$$ (D_{xx} \\mathbf{u})_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} $$\n$$ (D_{xxxx} \\mathbf{u})_i = \\frac{u_{i+2} - 4u_{i+1} + 6u_i - 4u_{i-1} + u_{i-2}}{\\Delta x^4} $$\n这些算子满足问题的要求，即在周期性网格上导数的离散和为零。这一点从模板系数之和为 $1-2+1=0$ 以及 $1-4+6-4+1=0$ 中可以明显看出。设 $\\mathbf{D}_{xx}$ 和 $\\mathbf{D}_{xxxx}$ 是表示这些离散算子的循环矩阵。那么半离散化的线性部分为 $\\mathbf{L}\\mathbf{u} = -(\\mathbf{D}_{xx} + \\mathbf{D}_{xxxx})\\mathbf{u}$。\n\n对于非线性项 $u u_x$，问题要求使用守恒（斜对称）形式。我们将“守恒”解释为保持解的空间平均值 $\\overline{u} = \\frac{1}{N}\\sum_i u_i$ 不变。连续平均值是守恒的，因为 KS 方程可以写成守恒形式：$u_t + \\left(\\frac{1}{2}u^2 + u_x + u_{xxx}\\right)_x = 0$。如果右端项在所有网格点上的和为零，那么离散格式就能保持平均值守恒。对于线性部分，这一点已经满足。对于非线性部分，我们把 $u u_x$ 写成 $(\\frac{1}{2}u^2)_x$ 并用中心差分进行离散化，这是一种标准的守恒格式：\n$$ (\\mathbf{N}(\\mathbf{u}))_i = -\\frac{u_{i+1}^2/2 - u_{i-1}^2/2}{2\\Delta x} = -\\frac{u_{i+1}^2 - u_{i-1}^2}{4\\Delta x} $$\n在周期性网格上，和 $\\sum_i (\\mathbf{N}(\\mathbf{u}))_i$ 是一个伸缩求和，因此其值恰好为零，从而确保了平均值的离散守恒。\n\n半离散化的常微分方程组为：\n$$ \\frac{d\\mathbf{u}}{dt} = \\mathbf{N}(\\mathbf{u}) + \\mathbf{L}\\mathbf{u} $$\n\n接下来，我们进行时间离散。问题指定了一种单步方法，该方法为保证稳定性而隐式处理线性部分，显式处理非线性部分。这导向了一阶隐式-显式 (IMEX) 欧拉格式，该格式对于线性部分是无条件稳定且相容的。给定时间 $t_n$ 的解 $\\mathbf{u}^n$，在 $t_{n+1} = t_n + \\Delta t$ 的解通过求解以下方程得到：\n$$ \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\mathbf{N}(\\mathbf{u}^n) + \\mathbf{L}\\mathbf{u}^{n+1} $$\n重新整理后，得到每个时间步需要求解的线性系统：\n$$ (\\mathbf{I} - \\Delta t \\mathbf{L})\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\mathbf{N}(\\mathbf{u}^n) $$\n代入 $\\mathbf{L}$ 和 $\\mathbf{N}(\\mathbf{u})$ 的表达式：\n$$ (\\mathbf{I} + \\Delta t \\mathbf{D}_{xx} + \\Delta t \\mathbf{D}_{xxxx})\\mathbf{u}^{n+1} = \\mathbf{u}^n - \\Delta t \\left(-\\frac{(\\mathbf{u}^n_{\\text{shifted}+1})^2 - (\\mathbf{u}^n_{\\text{shifted}-1})^2}{4\\Delta x}\\right) $$\n左侧的矩阵 $\\mathbf{A} = \\mathbf{I} + \\Delta t \\mathbf{D}_{xx} + \\Delta t \\mathbf{D}_{xxxx}$ 是一个循环矩阵。直接求逆的计算成本很高（$O(N^3)$）。因此，我们利用循环矩阵可以被离散傅里叶变换 (DFT) 对角化这一性质。设 $\\mathcal{F}$ 表示 DFT 算子。方程 $\\mathbf{A}\\mathbf{u}^{n+1} = \\mathbf{b}^n$（其中 $\\mathbf{b}^n$ 是右端项）可以被高效求解：\n1.  在物理空间中计算右端项 $\\mathbf{b}^n$。\n2.  将 $\\mathbf{b}^n$ 变换到傅里叶空间：$\\hat{\\mathbf{b}}^n = \\mathcal{F}(\\mathbf{b}^n)$。\n3.  傅里叶变换将 $\\mathbf{A}$ 对角化为 $\\hat{\\mathbf{A}}$，这是一个对角矩阵，其元素是 $\\mathbf{A}$ 的特征值。在傅里叶空间中的方程为 $\\hat{\\mathbf{A}} \\hat{\\mathbf{u}}^{n+1} = \\hat{\\mathbf{b}}^n$。\n4.  通过逐元素相除求解 $\\hat{\\mathbf{u}}^{n+1}$：$\\hat{u}^{n+1}_k = \\hat{b}^n_k / \\hat{A}_k$。\n5.  变换回物理空间：$\\mathbf{u}^{n+1} = \\mathcal{F}^{-1}(\\hat{\\mathbf{u}}^{n+1})$。\n\n特征值 $\\hat{A}_k$ 是从离散微分算子的特征值推导出来的。对于对应第 $m$ 个傅里叶模式的离散波数 $k = 2\\pi m / L$，$\\mathbf{D}_{xx}$ 和 $\\mathbf{D}_{xxxx}$ 的特征值为：\n$$ \\hat{D}_{xx}(k) = \\frac{2(\\cos(k\\Delta x) - 1)}{\\Delta x^2} $$\n$$ \\hat{D}_{xxxx}(k) = \\left( \\hat{D}_{xx}(k) \\right)^2 = \\frac{4(\\cos(k\\Delta x) - 1)^2}{\\Delta x^4} = \\frac{2\\cos(2k\\Delta x) - 8\\cos(k\\Delta x) + 6}{\\Delta x^4} $$\n因此，隐式算子矩阵 $\\mathbf{A}$ 的特征值为：\n$$ \\hat{A}_k = 1 + \\Delta t \\hat{D}_{xx}(k) + \\Delta t \\hat{D}_{xxxx}(k) $$\n这些值可以预先计算。每个时间步的整体算法成本为 $O(N \\log N)$，主要由快速傅里叶变换 (FFT) 主导。\n\n实现将遵循此过程。对于每个测试用例，我们使用给定的公式初始化解，计算初始离散平均值 $\\overline{u}(0) = \\frac{1}{N}\\sum_i u_i(0)$，然后在时间步进循环中迭代 $T/\\Delta t$ 步。最后，我们计算最终平均值 $\\overline{u}(T)$、绝对平均值漂移 $|\\overline{u}(T)-\\overline{u}(0)|$ 以及最终的无穷范数 $\\|u(\\cdot,T)\\|_{\\infty} = \\max_i |u_i(T)|$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, N, dt, T, A, m):\n    \"\"\"\n    Solves the Kuramoto-Sivashinsky equation using a finite difference method\n    with an IMEX-1 (Implicit-Explicit Euler) time-stepping scheme.\n\n    The equation is u_t + u*u_x + u_xx + u_xxxx = 0.\n\n    Time stepping scheme:\n    (u^{n+1} - u^n)/dt = -N(u^n) - L_op(u^{n+1})\n    where N(u) = u*u_x is the nonlinear term, treated explicitly,\n    and L_op(u) = u_xx + u_xxxx is the linear part, treated implicitly.\n\n    Rearranging yields the linear system to solve at each step:\n    (I + dt*L_op) u^{n+1} = u^n - dt*N(u^n)\n    This system is solved efficiently in Fourier space.\n    \"\"\"\n    # 1. Spatial and temporal grid setup\n    dx = L / N\n    x = np.arange(N) * dx\n    num_steps = int(round(T / dt))\n\n    # 2. Initial condition\n    # u(x,0) = A * [sin(2*pi*m/L * x) + 1/4 * cos(4*pi*m/L * x)]\n    u = A * (np.sin(2 * np.pi * m / L * x) + 0.25 * np.cos(4 * np.pi * m / L * x))\n    initial_mean = np.mean(u)\n\n    # 3. Pre-computation for the linear operator (solved in Fourier space)\n    # Wavenumbers k for the discrete Fourier transform\n    # The physical wavenumbers are k_phys = 2 * pi * freqs\n    freqs = np.fft.fftfreq(N, d=dx)\n    k = 2 * np.pi * freqs\n\n    # Eigenvalues of the finite difference operators for u_xx and u_xxxx.\n    # Stencil for D_xx: (1, -2, 1)/dx^2.\n    # Symbol (eigenvalue for basis func e^{ikx}): (e^{ik*dx} - 2 + e^{-ik*dx}) / dx^2\n    # which simplifies to 2*(cos(k*dx)-1)/dx^2\n    D2_hat = 2 * (np.cos(k * dx) - 1) / dx**2\n    # Symbol for D_xxxx is (D2_hat)^2\n    D4_hat = D2_hat**2\n\n    # The PDE has u_t + L_op*u + ... = 0, so du/dt = -L_op*u - ...\n    # The implicit operator matrix for (I - dt * (-D2_hat - D4_hat)) is\n    # I + dt*(D2_hat + D4_hat). This is the divisor in Fourier space.\n    implicit_op_hat = 1.0 + dt * (D2_hat + D4_hat)\n    \n    # 4. Main time-stepping loop\n    u_hat = np.fft.fft(u)\n\n    for _ in range(num_steps):\n        # Go to physical space to compute nonlinear term\n        u_phys = np.fft.ifft(u_hat).real\n\n        # Nonlinear term N(u) = u*u_x discretized in conservative form.\n        # This corresponds to discretizing (u^2/2)_x with a centered difference.\n        # (f(i+1) - f(i-1))/(2dx), where f_i = u_i^2/2.\n        # - (u_{i+1}^2/2 - u_{i-1}^2/2)/(2dx) = (u_{i+1}^2 - u_{i-1}^2)/(4dx)\n        # We use np.roll for periodic boundary conditions.\n        Nu = (np.roll(u_phys, -1)**2 - np.roll(u_phys, 1)**2) / (4.0 * dx)\n\n        # Form the right-hand-side: u^n - dt * N(u^n)\n        # PDE is u_t = -N(u) - L(u).\n        RHS_phys = u_phys - dt * Nu\n        RHS_hat = np.fft.fft(RHS_phys)\n\n        # Solve for next time step in Fourier space\n        u_hat_next = RHS_hat / implicit_op_hat\n        u_hat = u_hat_next\n\n    # 5. Compute final outputs and round as specified\n    u_final = np.fft.ifft(u_hat).real\n    \n    final_mean = np.mean(u_final)\n    mean_drift = np.abs(final_mean - initial_mean)\n    final_linf = np.max(np.abs(u_final))\n    \n    return [round(mean_drift, 6), round(final_linf, 6)]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (L, N, dt, T, A, m)\n    test_cases = [\n        (32.0, 64, 0.01, 0.5, 0.5, 1),\n        (32.0, 128, 0.005, 0.5, 0.5, 1),\n        (8.0, 64, 0.01, 0.2, 0.5, 1),\n        (32.0, 64, 0.01, 0.5, 0.0, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Print the final result in the exact required format.\n    # The string representation of a list includes spaces, which must be removed.\n    print(f\"{results}\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "2393592"}]}