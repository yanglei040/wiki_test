{"hands_on_practices": [{"introduction": "在掌握了如何求解带有边界条件的拉普拉斯方程后，一个自然的问题是：如果在区域内部固定一个点的电势，整个电势场会如何变化？这项实践将通过引入一个“内部”边界条件来探索这一问题，帮助你理解局部约束如何影响全局解。通过计算有无内部约束时两种解的均方根差异[@problem_id:2405011]，你将能定量地分析这种扰动的影响，并加深对电势场行为的物理直觉。", "problem": "给定一个方形域上的二维拉普拉斯方程，该方形域采用均匀笛卡尔离散化和狄利克雷边界条件。考虑一个边长为$1$米的正方形域，离散化为一个$N \\times N$节点的均匀网格，网格间距为$h = \\dfrac{1}{N-1}$米。设网格索引为从零开始，其中$i \\in \\{0,\\dots,N-1\\}$索引垂直坐标（从下到上），$j \\in \\{0,\\dots,N-1\\}$索引水平坐标（从左到右）。在每个严格内部节点$(i,j)$（即$1 \\le i \\le N-2$且$1 \\le j \\le N-2$）处的离散拉普拉斯方程为\n$$\n\\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^2} = 0,\n$$\n这等价于\n$$\n\\phi_{i,j} = \\frac{1}{4}\\left(\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1}\\right).\n$$\n在边界上，每个边都指定了狄利克雷值：底边$i=0$、顶边$i=N-1$、左边$j=0$和右边$j=N-1$。在四个角节点处，即两条边规格相交的地方，边界值定义为两条相交边上指定值的算术平均值。所有电势必须以伏特为单位进行处理和报告。\n\n任务是研究引入单个内部狄利克雷约束（一个“内部”固定电压点）对全局离散解的影响。对于一组给定的边界边值和一个指定的内部节点$(i^\\star,j^\\star)$及其固定内部电压$V^\\star$，定义两个离散解：\n- $\\phi^{(0)}$：满足边界边上的狄利克雷条件且无内部约束的唯一离散调和函数；\n- $\\phi^{(\\mathrm{int})}$：满足边界边上相同的狄利克雷条件以及内部狄利克雷约束$\\phi_{i^\\star,j^\\star} = V^\\star$的唯一离散调和函数。\n\n对于每种情况，计算这两个解在整个网格上的均方根（RMS）差，\n$$\nD = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\phi^{(\\mathrm{int})}_{i,j} - \\phi^{(0)}_{i,j}\\right)^2},\n$$\n以伏特为单位表示。\n\n如果连续迭代中所有网格节点上的一致最大绝对变化严格小于指定的容差$\\varepsilon$（单位为伏特），或者达到了指定的最大迭代次数，则认为一个离散解是可接受的。使用容差$\\varepsilon = 10^{-6}$伏特，最大迭代次数为$200{,}000$。\n\n测试套件。对于每个测试，您必须计算如上定义的$D$。以下三个测试指定了$N$、每条边上的边界电压、内部点及其固定电压。对$(i^\\star,j^\\star)$使用从零开始的索引。\n- 测试 $1$（一般情况）：\n  - $N = 41$。\n  - 边电压：顶边$1.0$伏特，底边$0.0$伏特，左边$0.0$伏特，右边$0.0$伏特。\n  - 内部约束：$(i^\\star,j^\\star) = (20,20)$，电压$V^\\star = 0.75$伏特。\n- 测试 $2$（靠近边界的内部点）：\n  - $N = 21$。\n  - 边电压：左边$1.0$伏特，顶边$0.0$伏特，底边$0.0$伏特，右边$0.0$伏特。\n  - 内部约束：$(i^\\star,j^\\star) = (10,2)$，电压$V^\\star = 0.20$伏特。\n- 测试 $3$（零边界，仅内部源）：\n  - $N = 11$。\n  - 边电压：顶边$0.0$伏特，底边$0.0$伏特，左边$0.0$伏特，右边$0.0$伏特。\n  - 内部约束：$(i^\\star,j^\\star) = (5,5)$，电压$V^\\star = 1.00$伏特。\n\n您的程序必须为每个测试计算满足指定容差的$\\phi^{(0)}$和$\\phi^{(\\mathrm{int})}$，然后计算均方根差$D$（以伏特为单位）。最终的程序输出必须是单行文本，包含测试$1$到$3$的三个$D$值，按顺序排列，四舍五入到$6$位小数，并严格格式化为方括号内无空格的逗号分隔列表（例如，“[0.123456,0.000001,1.234567]”）。", "solution": "所提出的问题是有效的。这是一个计算物理中的标准练习，涉及在笛卡尔网格上使用有限差分法求解二维拉普拉斯方程。选择的方法是雅可比松弛法，这是一种用于求解此类离散化产生的线性方程组的经典迭代技术。该问题定义明确，科学上合理，且所有参数都已提供，可以明确求解。\n\n控制方程是拉普拉斯方程，$\\nabla^2 \\phi = 0$。对于一个间距为$h$的均匀笛卡尔网格的二维域，对节点$(i,j)$处的拉普拉斯算子$\\nabla^2$进行二阶中心差分近似，得到离散方程：\n$$\n\\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^2} = 0\n$$\n这可以重新整理，将电势$\\phi_{i,j}$表示为其四个最近邻点的平均值，这构成了雅可比迭代更新规则的基础：\n$$\n\\phi_{i,j}^{(k+1)} = \\frac{1}{4}\\left(\\phi_{i+1,j}^{(k)} + \\phi_{i-1,j}^{(k)} + \\phi_{i,j+1}^{(k)} + \\phi_{i,j-1}^{(k)}\\right)\n$$\n其中上标$(k)$表示迭代次数。此更新同时应用于网格的所有严格内部节点，即索引$i,j$在范围$[1, N-2]$内的节点。\n\n解决每个测试用例的总体算法如下：\n\n1.  **网格初始化**：对于给定的网格大小$N \\times N$，创建一个表示电势$\\phi$的数组。根据问题说明设置边界值。四个角节点的电势设置为两条相交边电势的算术平均值。例如，左下角$(i=0, j=0)$的电势设置为$\\phi_{0,0} = \\frac{1}{2}(V_{\\text{bottom}} + V_{\\text{left}})$，其中$V_{\\text{bottom}}$和$V_{\\text{left}}$是相应边上的电压。\n\n2.  **求解$\\phi^{(0)}$（无约束解）**：\n    - 从初始化的网格开始，应用雅可比迭代。在每次迭代中，计算一个新的电势值网格，其中每个内部点的值是其邻居点在上一轮迭代网格中的值的平均值。\n    - 重复此过程，直到满足收敛准则。当连续两次迭代中任何节点的最大绝对电势差$\\max(|\\phi^{(k+1)} - \\phi^{(k)}|)$小于指定的容差$\\varepsilon = 10^{-6}$伏特时，达到收敛。如果达到最大迭代次数$200,000$次，迭代也会终止。\n    - 得到的网格即为离散解$\\phi^{(0)}$。\n\n3.  **求解$\\phi^{(\\mathrm{int})}$（有约束解）**：\n    - 此过程与求解$\\phi^{(0)}$几乎相同，但有一个关键修改。在特定节点$(i^\\star, j^\\star)$处引入一个内部狄利克雷约束，将其电势固定为$V^\\star$。\n    - 对所有内部节点执行雅可比迭代。在更新步骤之后，将约束节点的值重置为其固定值，即$\\phi_{i^\\star, j^\\star} = V^\\star$。这在整个迭代过程中强制执行内部约束。\n    - 应用相同的收敛准则。得到的网格即为离散解$\\phi^{(\\mathrm{int})}$。\n\n4.  **计算均方根差**：一旦$\\phi^{(0)}$和$\\phi^{(\\mathrm{int})}$都计算完毕，就使用给定的公式在整个$N \\times N$网格上计算它们之间的均方根（RMS）差$D$：\n    $$\n    D = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\phi^{(\\mathrm{int})}_{i,j} - \\phi^{(0)}_{i,j}\\right)^2}\n    $$\n    该度量量化了因引入单个内部固定电压点而对电势场造成的平均全局扰动。\n\n实现将使用Python和NumPy库完成，这允许在网格上进行高效的矢量化操作。单个函数封装了雅可比求解器，能够处理无约束和有约束两种情况。对于三个测试用例中的每一种情况（$\\phi^{(0)}$和$\\phi^{(\\mathrm{int})}$），都将调用此函数来计算所需的解。然后，将最终的$D$值列表按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef jacobi_solver(N, bc_top, bc_bottom, bc_left, bc_right,\n                  interior_constraint=None, tol=1e-6, max_iter=200000):\n    \"\"\"\n    Solves the 2D Laplace equation on a square grid using Jacobi relaxation.\n\n    Args:\n        N (int): The number of nodes along one dimension of the grid.\n        bc_top (float): Voltage on the top edge.\n        bc_bottom (float): Voltage on the bottom edge.\n        bc_left (float): Voltage on the left edge.\n        bc_right (float): Voltage on the right edge.\n        interior_constraint (tuple, optional): A tuple (i, j, V) specifying an\n            interior fixed-voltage point. Defaults to None.\n        tol (float, optional): Convergence tolerance. Defaults to 1e-6.\n        max_iter (int, optional): Maximum number of iterations. Defaults to 200000.\n\n    Returns:\n        numpy.ndarray: The converged potential field phi.\n    \"\"\"\n    phi = np.zeros((N, N), dtype=np.float64)\n\n    # Apply boundary conditions to edges\n    phi[N-1, :] = bc_top      # Top edge (i = N-1)\n    phi[0, :] = bc_bottom     # Bottom edge (i = 0)\n    phi[:, 0] = bc_left       # Left edge (j = 0)\n    phi[:, N-1] = bc_right    # Right edge (j = N-1)\n\n    # Apply boundary conditions to corners (arithmetic mean)\n    phi[0, 0] = (bc_bottom + bc_left) / 2.0\n    phi[0, N-1] = (bc_bottom + bc_right) / 2.0\n    phi[N-1, 0] = (bc_top + bc_left) / 2.0\n    phi[N-1, N-1] = (bc_top + bc_right) / 2.0\n\n    # If an interior constraint exists, retrieve its details\n    if interior_constraint:\n        i_star, j_star, v_star = interior_constraint\n        phi[i_star, j_star] = v_star\n\n    for _ in range(max_iter):\n        phi_old = phi.copy()\n\n        # Vectorized Jacobi update for all interior points\n        phi[1:-1, 1:-1] = 0.25 * (\n            phi_old[2:, 1:-1] +   # phi_{i+1, j}\n            phi_old[:-2, 1:-1] +  # phi_{i-1, j}\n            phi_old[1:-1, 2:] +   # phi_{i, j+1}\n            phi_old[1:-1, :-2]    # phi_{i, j-1}\n        )\n\n        # Re-enforce the interior constraint after the update\n        if interior_constraint:\n            phi[i_star, j_star] = v_star\n\n        # Check for convergence across the whole grid\n        max_change = np.max(np.abs(phi - phi_old))\n        if max_change < tol:\n            break\n\n    return phi\n\ndef calculate_rms_difference(case_params):\n    \"\"\"\n    Calculates the RMS difference D for a given test case.\n    \n    Args:\n        case_params (tuple): Contains N, boundary conditions, and interior constraint.\n    \n    Returns:\n        float: The computed RMS difference D.\n    \"\"\"\n    N, bcs, int_constr = case_params\n    bc_top, bc_bottom, bc_left, bc_right = bcs\n\n    # Solve for phi^(0) (unconstrained)\n    phi_0 = jacobi_solver(N, bc_top, bc_bottom, bc_left, bc_right)\n    \n    # Solve for phi^(int) (with interior constraint)\n    phi_int = jacobi_solver(N, bc_top, bc_bottom, bc_left, bc_right, \n                            interior_constraint=int_constr)\n    \n    # Calculate the RMS difference D\n    rms_diff = np.sqrt(np.mean((phi_int - phi_0)**2))\n    \n    return rms_diff\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: N=41, top=1V, others=0V, constraint=(20,20) at 0.75V\n        (41, (1.0, 0.0, 0.0, 0.0), (20, 20, 0.75)),\n        # Test 2: N=21, left=1V, others=0V, constraint=(10,2) at 0.20V\n        (21, (0.0, 0.0, 1.0, 0.0), (10, 2, 0.20)),\n        # Test 3: N=11, all=0V, constraint=(5,5) at 1.00V\n        (11, (0.0, 0.0, 0.0, 0.0), (5, 5, 1.00)),\n    ]\n\n    results = []\n    for case in test_cases:\n        D = calculate_rms_difference(case)\n        results.append(D)\n\n    # Final print statement in the exact required format.\n    formatted_results = ','.join([f\"{res:.6f}\" for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2405011"}, {"introduction": "许多物理问题本质上是三维的，将数值方法从二维扩展到三维是计算物理中的一项基本技能。本练习旨在让你将雅可比松弛法应用于一个三维空心立方体内的静电势问题[@problem_id:2404972]。你需要将二维的四点模板扩展为三维的六点模板，并通过编程实践来巩固对三维空间中拉普拉斯方程数值解的理解。", "problem": "考虑一个在笛卡尔坐标系下占据域 $[0,1]^3$ 的中空、理想导电立方体内部的静电势。势函数 $V(x,y,z)$ 在开放单位立方体内满足三维拉普拉斯方程，即偏微分方程 (PDE) $\\nabla^2 V = 0$，并带有狄利克雷边界条件 (BC)。立方体中恰好有一个面保持在固定电势 $V_0$（单位：伏特），而其他五个面保持在 $0$ 伏特（接地）。电势为 $V_0$ 的特定面由轴标签 $a \\in \\{x,y,z\\}$ 标识，并且始终是“正”侧面，即：如果 $a=x$，则为平面 $x=1$；如果 $a=y$，则为平面 $y=1$；如果 $a=z$，则为平面 $z=1$。\n\n在均匀网格上离散化单位立方体，每个坐标方向上有 $N$ 个内部点，因此每个轴的总网格点数（包括边界）为 $N+2$，网格间距为 $h = \\frac{1}{N+1}$。令 $U_{i,j,k}$ 表示网格点 $(x_i,y_j,z_k) = (i\\,h,j\\,h,k\\,h)$ 处的离散电势，其中整数索引 $i,j,k \\in \\{0,1,\\dots,N+1\\}$。在所有边界点上施加 $U_{i,j,k}=0$，但由 $a$ 指定的位于“正”侧的单个面上的点除外，这些点上的值为 $U_{i,j,k}=V_0$。\n\n通过以下规则在此网格上定义一系列网格函数 $\\{U^{(m)}\\}_{m=0}^{\\infty}$：\n- 初始化内部值，对于所有 $1 \\le i,j,k \\le N$，设 $U^{(0)}_{i,j,k}=0$，而所有边界值均由上述狄利克雷边界条件设定，并对所有 $m$ 保持固定。\n- 对于每个整数 $m \\ge 0$，通过离散调和平均关系定义内部点的下一次迭代值\n$$\nU^{(m+1)}_{i,j,k} = \\frac{1}{6}\\Big(U^{(m)}_{i+1,j,k} + U^{(m)}_{i-1,j,k} + U^{(m)}_{i,j+1,k} + U^{(m)}_{i,j-1,k} + U^{(m)}_{i,j,k+1} + U^{(m)}_{i,j,k-1}\\Big)\n$$\n对于所有 $1 \\le i,j,k \\le N$，同时在每次迭代中保持边界值不变。\n- 对于给定的容差 $\\varepsilon > 0$，将停止时间 $K$ 定义为最小的非负整数，使得在执行 $K$ 次完整扫描（每次扫描通过上述平均法则更新所有内部点一次）后，以下条件成立：\n$$\n\\max_{0 \\le i,j,k \\le N+1} \\left| U^{(K)}_{i,j,k} - U^{(K-1)}_{i,j,k} \\right| < \\varepsilon,\n$$\n约定不使用 $U^{(-1)}$（因此，首次评估该严格不等式是在一次扫描之后，即 $K \\ge 1$）。报告的 $K$ 是直至（并包括）首次满足该严格不等式的扫描所执行的总次数。\n\n对于每种情况，还需报告距离几何中心 $(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$ 最近的单个网格节点上的离散电势值（单位：伏特）。设 $n = N+2$ 为每轴的总网格点数；则每个方向上最接近中心的索引为 $c = \\operatorname{round}\\!\\big(\\tfrac{1}{2}(n-1)\\big)$，报告的中心值为 $U^{(K)}_{c,c,c}$（单位：伏特）。\n\n测试套件：\n为以下参数集 $(N,\\varepsilon,V_0,a)$ 提供结果：\n- 情况 A (一般实例): $(N,\\varepsilon,V_0,a) = (10,\\,10^{-3},\\,1,\\,z)$。\n- 情况 B (最小内部，两次扫描内达到精确离散不动点): $(N,\\varepsilon,V_0,a) = (1,\\,10^{-12},\\,1,\\,x)$。\n- 情况 C (退化边界数据): $(N,\\varepsilon,V_0,a) = (6,\\,5\\times 10^{-3},\\,0,\\,y)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个双元素列表 $[K, U^{(K)}_{c,c,c}]$。例如，输出格式必须是\n\"[ [K_A, V_A], [K_B, V_B], [K_C, V_C] ]\"\n其中 $K_A$、$K_B$、$K_C$ 为整数，$V_A$、$V_B$、$V_C$ 为代表伏特的浮点数。所有电势必须以伏特表示。不涉及角度。输出中不出现百分比；所有量均为原始整数或浮点数。", "solution": "该问题要求在单位立方体内，对受狄利克雷边界条件约束的三维拉普拉斯方程 $\\nabla^2 V = 0$ 进行数值求解。电势 $V$ 在立方体的所有六个面上都有指定：一个面维持在恒定电势 $V_0$，而另外五个面接地（电势为 $0$）。这是一个静电学中的标准问题，用于描述无电荷区域内的电势。\n\n这个连续问题在一个均匀的笛卡尔网格上被离散化。域 $[0,1]^3$ 被划分为一个网格，每轴有 $N+2$ 个点，网格间距为 $h = \\frac{1}{N+1}$。在网格点 $(x_i, y_j, z_k) = (ih, jh, kh)$ 处的离散电势用 $U_{i,j,k}$ 表示，其中索引 $i,j,k \\in \\{0, 1, \\dots, N+1\\}$。\n\n拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}$ 在每个内部网格点 $(i,j,k)$ 处使用二阶中心差分格式进行近似：\n$$\n\\nabla^2 V \\bigg|_{(x_i,y_j,z_k)} \\approx \\frac{U_{i+1,j,k} - 2U_{i,j,k} + U_{i-1,j,k}}{h^2} + \\frac{U_{i,j+1,k} - 2U_{i,j,k} + U_{i,j-1,k}}{h^2} + \\frac{U_{i,j,k+1} - 2U_{i,j,k} + U_{i,j,k-1}}{h^2}\n$$\n将此近似值设为 $0$，便可得到一个关于未知内部电势的线性方程组。对 $U_{i,j,k}$ 进行项的重排，得到离散调和平均性质：\n$$\nU_{i,j,k} = \\frac{1}{6}\\Big(U_{i+1,j,k} + U_{i-1,j,k} + U_{i,j+1,k} + U_{i,j-1,k} + U_{i,j,k+1} + U_{i,j,k-1}\\Big)\n$$\n此方程必须对所有内部点成立，即对所有 $1 \\le i,j,k \\le N$。\n\n问题指定使用雅可比法 (Jacobi method) 来求解这个线性系统。这是一种迭代松弛技术。给定内部网格上电势的初始猜测值 $U^{(0)}$，生成一系列精确化的近似解 $\\{U^{(m)}\\}_{m=0}^{\\infty}$。从迭代 $m$ 到 $m+1$ 的更新，是通过对所有内部点同时应用离散调和平均法则来定义的，仅使用来自上一次迭代 $m$ 的值：\n$$\nU^{(m+1)}_{i,j,k} = \\frac{1}{6}\\Big(U^{(m)}_{i+1,j,k} + U^{(m)}_{i-1,j,k} + U^{(m)}_{i,j+1,k} + U^{(m)}_{i,j-1,k} + U^{(m)}_{i,j,k+1} + U^{(m)}_{i,j,k-1}\\Big)\n$$\n在整个过程中边界值保持恒定。所有内部点的初始猜测值被指定为 $U^{(0)}_{i,j,k}=0$。\n\n迭代持续进行，直到解收敛。收敛性由一个基于连续迭代之间电势值最大变化的停止准则确定。当在整个网格上的最大绝对差值首次低于给定容差 $\\varepsilon$ 时，过程在第 $K \\ge 1$ 次迭代时终止：\n$$\n\\max_{0 \\le i,j,k \\le N+1} \\left| U^{(K)}_{i,j,k} - U^{(K-1)}_{i,j,k} \\right| < \\varepsilon\n$$\n报告迭代次数 $K$ 和最接近立方体几何中心的网格点上的最终电势 $U^{(K)}_{c,c,c}$。中心索引 $c$ 计算为 $c = \\operatorname{round}\\!\\big(\\frac{1}{2}((N+2)-1)\\big)$。\n\n实现过程如下：\n1.  初始化两个大小为 $(N+2) \\times (N+2) \\times (N+2)$ 的三维数组 `U` 和 `U_next`，分别表示当前和下一个迭代步骤的电势。\n2.  对两个数组都施加狄利克雷边界条件。对于给定的轴 $a$ 和电势 $V_0$，该轴正端的面（$x=1$，$y=1$ 或 $z=1$）被设为 $V_0$。其余的边界面和初始内部点被设为 $0$。\n3.  执行一个迭代循环。在每次迭代 $m$ 中，使用雅可比更新法则的向量化版本，根据 `U`（表示 $U^{(m-1)}$）计算所有内部点的 `U_next`（表示 $U^{(m)}$）。\n4.  计算 `U_next` 和 `U` 之间的最大绝对差值。\n5.  将 `U_next` 的值复制到 `U`，为下一次迭代做准备。\n6.  当最大差值小于 $\\varepsilon$ 时，循环终止。最终的迭代计数 $K$ 即为所执行的扫描次数。\n7.  从收敛后的网格 `U` 中提取中心索引 $(c,c,c)$ 处的最终电势。\n\n测试案例如下：\n- 情况 A: $(N,\\varepsilon,V_0,a) = (10, 10^{-3}, 1, z)$ 是一个具有相当精细网格的标准案例。\n- 情况 B: $(N,\\varepsilon,V_0,a) = (1, 10^{-12}, 1, x)$ 代表一个只有一个内部网格点的最小问题。雅可比迭代在 $K=2$ 步内收敛到精确的离散解，因为第二次更新不会产生任何变化。\n- 情况 C: $(N,\\varepsilon,V_0,a) = (6, 5 \\times 10^{-3}, 0, y)$ 是一个 $V_0=0$ 的退化情况。所有边界电势均为 $0$，初始内部电势也为 $0$。唯一的解是处处为 $U=0$。算法在单步（$K=1$）内收敛，因为初始状态已经是不动点，所以第一次迭代后的差值为零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef solve_case(N, epsilon, V0, a):\n    \"\"\"\n    Solves the 3D Laplace equation on a unit cube using Jacobi relaxation.\n\n    Args:\n        N (int): Number of interior points in each dimension.\n        epsilon (float): Convergence tolerance.\n        V0 (float): Potential on the high-potential face.\n        a (str): Axis ('x', 'y', or 'z') of the high-potential face.\n\n    Returns:\n        list: A list containing [K, central_potential], where K is the number\n              of iterations and central_potential is the potential at the\n              grid point nearest the center.\n    \"\"\"\n    n = N + 2  # Total number of grid points per axis including boundaries\n\n    # Initialize U for iteration m and U_next for iteration m+1.\n    # Start with U^(0) = 0 everywhere.\n    U = np.zeros((n, n, n), dtype=np.float64)\n\n    # Apply Dirichlet boundary conditions.\n    # All faces are at 0V (grounded) by default.\n    # We only need to set the face at V0.\n    if V0 != 0:\n        if a == 'x':\n            U[N + 1, :, :] = V0\n        elif a == 'y':\n            U[:, N + 1, :] = V0\n        elif a == 'z':\n            U[:, :, N + 1] = V0\n            \n    # U_next must also have the boundary conditions.\n    U_next = U.copy()\n\n    K = 0\n    while True:\n        K += 1\n\n        # Perform one sweep of Jacobi relaxation.\n        # Update interior points of U_next based on values in U.\n        # This is the vectorized form of the 7-point stencil update.\n        U_next[1:-1, 1:-1, 1:-1] = (\n            U[0:-2, 1:-1, 1:-1] + U[2:, 1:-1, 1:-1] +\n            U[1:-1, 0:-2, 1:-1] + U[1:-1, 2:, 1:-1] +\n            U[1:-1, 1:-1, 0:-2] + U[1:-1, 1:-1, 2:]\n        ) / 6.0\n\n        # Calculate the maximum absolute difference between the new and old grids.\n        # The maximum is taken over all points, including boundaries.\n        max_diff = np.max(np.abs(U_next - U))\n\n        # Prepare for the next iteration by copying U_next to U.\n        U = U_next.copy()\n\n        # Check for convergence.\n        if max_diff < epsilon:\n            break\n            \n    # Find the index of the grid point nearest to the geometric center.\n    c = int(round(0.5 * (n - 1)))\n    \n    central_potential = U[c, c, c]\n    \n    return [K, central_potential]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, V0, a)\n        (10, 1e-3, 1.0, 'z'),      # Case A\n        (1, 1e-12, 1.0, 'x'),      # Case B\n        (6, 5e-3, 0.0, 'y'),      # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        N, epsilon, V0, a = case\n        result = solve_case(N, epsilon, V0, a)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python includes a space after the comma,\n    # which matches the format example '[ [K_A, V_A], [K_B, V_B], [K_C, V_C] ]'.\n    # The provided template code produces this format correctly.\n    inner_parts = []\n    for pair in results:\n        # Manually format each inner list to avoid locale-specific representations\n        # and ensure consistency with the problem's example format '[K, V]'.\n        inner_parts.append(f\"[{pair[0]}, {pair[1]}]\")\n    \n    # The example format shows spaces between elements: \"[ [K_A, V_A], [K_B, V_B], [K_C, V_C] ]\"\n    final_output_string = f\"[{', '.join(inner_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2404972"}, {"introduction": "我们的讨论目前集中在描述无源区域的拉普拉斯方程 $\\nabla^2 u = 0$。这项高级实践将挑战你解决更普适的、包含源项 $f$ 的泊松方程 $\\nabla^2 u = f$ [@problem_id:2404984]。你不仅需要为此调整雅可比迭代格式，还将探索周期性边界条件——这在模拟晶体结构或宇宙学模型等领域至关重要——并处理其独特的解存在性条件。", "problem": "考虑单位平方域 $$\\Omega = [0,1]\\times[0,1]$$ 上的二维泊松偏微分方程（PDE）$$\\nabla^2 u(x,y) = f(x,y)$$，其中三角函数中的所有角度均以弧度为单位。您将实现雅可比松弛法，以求解该方程在两种不同边界模型下的有限差分-离散化形式，然后量化边界模型的选择如何影响解的结构。这两种边界模型是：(i) 环面上的周期性边界条件（对边视为相同），以及 (ii) 方形域上的齐次狄利克雷边界条件（边界值为零）。对于周期性模型，请注意其可解性要求右端项的均值为零。\n\n您的实现必须从以下基本原理出发：\n- 泊松方程 $$\\nabla^2 u = f$$ 定义为梯度的散度，及其在每个坐标方向上间距为 $$h$$ 的均匀网格上使用二阶中心差分的有限差分-离散化。\n- 雅可比松弛格式是通过分离五点模板的中心点而获得的不动点迭代。\n- 周期性泊松问题的可解性条件，该条件通过对 $$\\nabla^2 u = f$$ 在整个域上积分并利用散度定理和周期性得到。\n\n基于这些原理，推导每种边界模型下均匀网格上的雅可比松弛更新规则：\n- 周期性边界条件：每个网格点有四个邻居，采用环绕式索引；离散拉普拉斯算子使用周期性平移。\n- 齐次狄利克雷边界条件：解在边界上固定为 $$0$$；仅使用其邻居和边界值更新内部未知数。\n\n使用每个维度上有 $$N_x=N_y$$ 个点的均匀网格。对于周期性模型，将网格放置在平坦环面上，点为 $$x_i = i/N_x$$ 和 $$y_j = j/N_y$$，其中 $$i,j \\in \\{0,1,\\dots,N_x-1\\}$$，间距为 $$h_p = 1/N_x$$。对于狄利克雷模型，使用点 $$x_i = i/(N_x-1)$$ 和 $$y_j = j/(N_y-1)$$，其中 $$i,j \\in \\{0,1,\\dots,N_x-1\\}$$，间距为 $$h_d = 1/(N_x-1)$$，并在边界索引 $$i=0$$、$$i=N_x-1$$、$$j=0$$、$$j=N_y-1$$ 上强制 $$u=0$$。\n\n实现雅可比格式，初始猜测为零，停止准则基于残差的相对离散 $$L^2$$-范数。设残差为 $$r = f - \\Delta_h u$$，其中 $$\\Delta_h$$ 表示经过适当边界处理的标准五点离散拉普拉斯算子。将相对残差定义为 $$\\|r\\|_2 / \\|f\\|_2$$，其中 $$\\|g\\|_2 = \\left(\\sum_{i,j} g_{i,j}^2 \\, h^2\\right)^{1/2}$$ 使用相应的网格间距 $$h\\in\\{h_p,h_d\\}$$。当相对残差低于指定容差或达到最大迭代次数时停止。对于周期性模型，如果 $$f$$ 的离散均值，即 $$\\bar f = \\frac{1}{N_x N_y} \\sum_{i,j} f_{i,j}$$，其绝对值大于一个小的阈值，则该离散问题不可解；在这种情况下，报告周期性求解器不收敛（不要试图通过减去其均值来“修正”$$f$$）。\n\n测试套件和要求输出：\n- 测试用例 $$1$$（周期性，零均值解析模态）：使用 $$N_x=N_y=64$$ 和 $$f(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$$。使用周期性边界条件求解，直到相对残差容差达到 $$10^{-8}$$ 或达到最多 $$6000$$ 次雅可比迭代，以先到者为准。将数值解与该模态下周期性五点拉普拉斯算子的离散傅里叶模态解进行比较。具体来说，对于网格函数 $$f_{i,j} = \\sin(2\\pi x_i)\\sin(2\\pi y_j)$$，精确满足 $$\\Delta_h u = f$$ 的相应离散解是 $$u^\\star = -f/\\lambda_d$$，其中 $$\\lambda_d = \\frac{8}{h_p^2}\\sin^2\\!\\left(\\frac{\\pi}{N_x}\\right)$$。以浮点数形式报告相对 $$L^2$$ 误差 $$\\|u-u^\\star\\|_2/\\|u^\\star\\|_2$$。\n- 测试用例 $$2$$（周期性，不可解的强迫项）：使用 $$N_x=N_y=64$$ 和 $$f(x,y) \\equiv 1$$（值为 $$1$$ 的常数网格函数）。尝试在相同的容差和迭代上限下使用周期性边界条件求解。检测 $$f$$ 的非零均值，并报告一个布尔值，指示求解器是否因离散问题不可解而正确地拒绝收敛。此用例的预期输出是布尔值 `False`，表示由于违反了可解性条件而未收敛。\n- 测试用例 $$3$$（周期性与狄利克雷的结构性影响）：使用由 $$f(x,y) = \\cos(2\\pi x) + \\cos(2\\pi y)$$ 定义的一对问题，采用相同的容差和迭代上限。一次在 $$64\\times 64$$ 环面网格（间距 $$h_p=1/64$$）上使用周期性边界条件求解，另一次在 $$65\\times 65$$ 方形网格（间距 $$h_d=1/64$$）上使用齐次狄利克雷边界条件求解。使用它们各自的间距计算两个数值解的连续 $$L^2$$ 范数 $$\\|u_{\\mathrm{per}}\\|_2$$ 和 $$\\|u_{\\mathrm{dir}}\\|_2$$。以浮点数形式报告比率 $$R = \\|u_{\\mathrm{per}}\\|_2 / \\|u_{\\mathrm{dir}}\\|_2$$。\n\n角度单位说明：所有三角函数必须使用弧度。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述三个测试用例的顺序列出结果。也就是说，输出必须是 $$[e_1,b_2,R_3]$$ 的形式，其中 $$e_1$$ 是测试用例 $$1$$ 的浮点相对误差，$$b_2$$ 是测试用例 $$2$$ 的布尔值，$$R_3$$ 是测试用例 $$3$$ 的浮点比率。例如，$$[0.00012,False,1.73]$$。", "solution": "所述问题是有效的。它构成了计算物理学领域中一个适定的练习，要求实现和分析用于二维泊松方程的雅可比松弛法。该问题具有科学依据，没有矛盾，并为每个测试用例计算唯一且有意义的解提供了所有必要的数据和条件。我们继续进行推导和求解。\n\n控制偏微分方程是在二维域 $\\Omega = [0,1]\\times[0,1]$ 上的泊松方程：\n$$ \\nabla^2 u(x,y) = f(x,y) $$\n其中 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 是拉普拉斯算子。为了数值求解此方程，我们将域 $\\Omega$ 离散化为由点 $(x_i, y_j)$ 组成的均匀网格，在两个坐标方向上的间距相等，均为 $h$。函数 $u(x,y)$ 由其在此网格上的值 $u_{i,j} = u(x_i, y_j)$ 表示。\n\n二阶偏导数使用二阶中心有限差分进行近似：\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} $$\n$$ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\n将这些近似值代入泊松方程，得到拉普拉斯算子的离散五点模板表示，记为 $\\Delta_h$：\n$$ (\\Delta_h u)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} = f_{i,j} $$\n该方程为未知的网格值 $u_{i,j}$ 构成了一个大型线性代数方程组。\n\n雅可比松弛法是求解此方程组的一种迭代格式。它通过重新排列离散方程以分离中心点 $u_{i,j}$ 来推导：\n$$ 4u_{i,j} = u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - h^2 f_{i,j} $$\n$$ u_{i,j} = \\frac{1}{4} (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - h^2 f_{i,j}) $$\n通过使用上一次迭代（索引为 $k$）的值来计算右侧，从而计算下一次迭代（$k+1$）的值，这个代数恒等式被转换为不动点迭代：\n$$ u_{i,j}^{(k+1)} = \\frac{1}{4} \\left( u_{i+1,j}^{(k)} + u_{i-1,j}^{(k)} + u_{i,j+1}^{(k)} + u_{i,j-1}^{(k)} - h^2 f_{i,j} \\right) $$\n从初始猜测 $u^{(0)}$ 开始，该公式被重复应用于所有网格点，直到解收敛。邻近点 $(u_{i\\pm 1, j}, u_{i, j\\pm 1})$ 的处理方式取决于边界条件。\n\n对于周期性边界条件，网格代表一个环面。域 $\\Omega$ 的对边被视为相同。使用一个 $N_x \\times N_y$ 点的网格，其中 $x_i = i/N_x$ 和 $y_j = j/N_y$，对于 $i \\in \\{0, \\dots, N_x-1\\}$ 和 $j \\in \\{0, \\dots, N_y-1\\}$。网格间距为 $h_p = 1/N_x$。索引以 $N_x$ 和 $N_y$ 为模进行处理，因此对于一个点 $(i,j)$，其邻居是 $((i\\pm 1) \\pmod{N_x}, j)$ 和 $(i, (j\\pm 1) \\pmod{N_y})$。一个关键的可解性条件来自于对 PDE 在整个域上积分：$\\int_\\Omega \\nabla^2 u \\, dA = \\int_\\Omega f \\, dA$。散度定理将左侧转换为一个边界积分 $\\oint_{\\partial\\Omega} \\nabla u \\cdot \\mathbf{n} \\, dS$，对于周期性函数，该积分为零。因此，我们必须有 $\\int_\\Omega f \\, dA = 0$。其离散模拟是 $\\sum_{i,j} f_{i,j} = 0$。如果强迫函数 $f$ 的均值非零，则解不存在，雅可比迭代将不会收敛。\n\n对于齐次狄利克雷边界条件，解在方形域的边界上固定为零：$u(x,y)=0$ 对于 $(x,y) \\in \\partial\\Omega$。使用一个 $N_x \\times N_y$ 点的网格，其中 $x_i = i/(N_x-1)$ 和 $y_j = j/(N_y-1)$，对于 $i,j \\in \\{0, \\dots, N_x-1\\}$。网格间距为 $h_d = 1/(N_x-1)$。边界点是那些索引为 $i=0$、$i=N_x-1$、$j=0$ 或 $j=N_y-1$ 的点。雅可比更新仅应用于内部网格点，其中 $i,j \\in \\{1, \\dots, N_x-2\\}$。对于与边界相邻的内部点，更新公式直接使用已知的边界零值。\n\n算法流程如下：\n1. 初始化解网格，$u^{(0)}_{i,j} = 0$。\n2. 对每次迭代 $k=0, 1, 2, \\dots$ 直到达到最大值：\n   a. 使用适用于边界条件的雅可比更新规则，从 $u^{(k)}$ 计算下一次迭代 $u^{(k+1)}$。\n   b. 计算离散残差网格 $r^{(k+1)} = f - \\Delta_h u^{(k+1)}$。离散拉普拉斯算子 $\\Delta_h$ 也必须遵守边界条件。\n   c. 计算残差的离散相对 $L^2$-范数：$\\frac{\\|r^{(k+1)}\\|_2}{\\|f\\|_2}$，其中范数定义为 $\\|g\\|_2 = \\sqrt{\\sum_{i,j} g_{i,j}^2 h^2}$。\n   d. 如果相对残差低于指定的容差 $\\epsilon$，则迭代收敛并终止。\n3. 对于周期性情况，必须对可解性条件 $\\left| \\sum_{i,j} f_{i,j} \\right| < \\delta$（其中 $\\delta$ 为某个小的数值容差）进行初步检查。如果违反此条件，求解器必须报告不收敛。\n\n此过程应用于三个指定的测试用例。\n\n用例 $1$：周期性问题，其中 $N_x=N_y=64$ 且 $f(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$。此强迫函数均值为零，因此解存在。将数值解 $u$ 与精确离散解 $u^\\star = -f/\\lambda_d$ 进行比较，其中 $\\lambda_d = \\frac{8}{h_p^2}\\sin^2(\\frac{\\pi}{N_x})$ 是该模态下离散拉普拉斯算子的精确特征值。计算相对误差 $\\|u-u^\\star\\|_2/\\|u^\\star\\|_2$。\n\n用例 $2$：周期性问题，其中 $N_x=N_y=64$ 且 $f(x,y)=1$。$f$ 的离散均值为 $1$，这违反了可解性条件。求解器应能检测到此情况并且不收敛。要求的输出是 `False`。\n\n用例 $3$：周期性解与狄利克雷解的比较，其中 $f(x,y) = \\cos(2\\pi x) + \\cos(2\\pi y)$。网格间距保持恒定为 $h=1/64$。对于周期性情况，这需要一个 $64 \\times 64$ 的网格。对于狄利克雷情况，这需要一个 $65 \\times 65$ 的网格。计算所得解的 $L^2$-范数之比 $R = \\|u_{\\mathrm{per}}\\|_2 / \\|u_{\\mathrm{dir}}\\|_2$，以量化边界条件施加的结构性差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def get_l2_norm(grid, h):\n        \"\"\"Calculates the discrete L2 norm: sqrt(sum(g_ij^2 * h^2)).\"\"\"\n        # Note: np.linalg.norm computes the Frobenius norm sqrt(sum(g_ij^2)).\n        return h * np.linalg.norm(grid)\n\n    def apply_laplacian(u, h, bc_type):\n        \"\"\"Applies the 5-point discrete Laplacian to a grid u.\"\"\"\n        if bc_type == 'periodic':\n            # Use np.roll for efficient periodic boundary handling.\n            u_i_plus = np.roll(u, -1, axis=1)\n            u_i_minus = np.roll(u, 1, axis=1)\n            u_j_plus = np.roll(u, -1, axis=0)\n            u_j_minus = np.roll(u, 1, axis=0)\n            lap_u = (u_i_plus + u_i_minus + u_j_plus + u_j_minus - 4.0 * u) / (h**2)\n        elif bc_type == 'dirichlet':\n            # Create a zero-padded laplacian grid and fill the interior.\n            lap_u = np.zeros_like(u)\n            # Central difference on the interior of the grid.\n            lap_u[1:-1, 1:-1] = (u[1:-1, 2:] + u[1:-1, :-2] + u[2:, 1:-1] + u[:-2, 1:-1] - 4.0 * u[1:-1, 1:-1]) / (h**2)\n        else:\n            raise ValueError(\"Unknown boundary condition type.\")\n        return lap_u\n\n    def jacobi_solver(N, f_func, bc_type, tol, max_iter):\n        \"\"\"\n        Solves the 2D Poisson equation using Jacobi relaxation.\n\n        Args:\n            N (int): Number of grid points in each dimension (Nx=Ny=N).\n            f_func (function): The forcing function f(x, y).\n            bc_type (str): 'periodic' or 'dirichlet'.\n            tol (float): Relative residual tolerance for convergence.\n            max_iter (int): Maximum number of iterations.\n        \n        Returns:\n            A tuple (u, h, converged_flag) or (None, h, converged_flag) for non-solvable periodic case.\n        \"\"\"\n        if bc_type == 'periodic':\n            h = 1.0 / N\n            x = np.linspace(0, 1.0 - h, N)\n        elif bc_type == 'dirichlet':\n            h = 1.0 / (N - 1)\n            x = np.linspace(0, 1.0, N)\n        else:\n            raise ValueError(\"Unknown boundary condition type.\")\n            \n        xv, yv = np.meshgrid(x, x, indexing='ij')\n        f = f_func(xv, yv)\n        u = np.zeros_like(f)\n\n        if bc_type == 'periodic':\n            # Check solvability condition for periodic problem.\n            mean_f = np.mean(f)\n            if abs(mean_f) > 1e-12:\n                # The problem is not solvable.\n                return None, h, False\n\n        f_norm = get_l2_norm(f, h)\n        if f_norm == 0:\n            # If f is zero everywhere, u=0 is the solution.\n            return u, h, True\n\n        for k in range(max_iter):\n            u_old = u.copy()\n            \n            if bc_type == 'periodic':\n                u_i_plus = np.roll(u_old, -1, axis=1)\n                u_i_minus = np.roll(u_old, 1, axis=1)\n                u_j_plus = np.roll(u_old, -1, axis=0)\n                u_j_minus = np.roll(u_old, 1, axis=0)\n                u = 0.25 * (u_i_plus + u_i_minus + u_j_plus + u_j_minus - h**2 * f)\n            else: # dirichlet\n                # Update only interior points\n                u[1:-1, 1:-1] = 0.25 * (u_old[1:-1, 2:] + u_old[1:-1, :-2] + \\\n                                       u_old[2:, 1:-1] + u_old[:-2, 1:-1] - h**2 * f[1:-1, 1:-1])\n\n            # Check for convergence\n            lap_u = apply_laplacian(u, h, bc_type)\n            residual = f - lap_u\n            residual_norm = get_l2_norm(residual, h)\n            \n            if residual_norm / f_norm < tol:\n                return u, h, True\n        \n        # If loop finishes, max iterations were reached without convergence.\n        # This is also considered non-convergence for the purpose of the problem.\n        return u, h, False\n\n    results = []\n    \n    # --- Test Case 1: Periodic, analytic mode ---\n    N1 = 64\n    tol1 = 1e-8\n    max_iter1 = 6000\n    f1_func = lambda x, y: np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n    \n    u1, h1, _ = jacobi_solver(N1, f1_func, 'periodic', tol1, max_iter1)\n    \n    # Analytic discrete solution\n    lambda_d = (8.0 / h1**2) * (np.sin(np.pi / N1)**2)\n    x1 = np.linspace(0, 1.0 - h1, N1)\n    xv1, yv1 = np.meshgrid(x1, x1, indexing='ij')\n    f1 = f1_func(xv1, yv1)\n    u_star1 = -f1 / lambda_d\n    \n    # Relative L2 error\n    error_norm = get_l2_norm(u1 - u_star1, h1)\n    ustar_norm = get_l2_norm(u_star1, h1)\n    relative_error = error_norm / ustar_norm\n    results.append(relative_error)\n\n    # --- Test Case 2: Periodic, non-solvable forcing ---\n    N2 = 64\n    tol2 = 1e-8\n    max_iter2 = 6000\n    f2_func = lambda x, y: np.ones_like(x)\n    \n    # Solver will detect non-zero mean and return converged_flag=False.\n    _, _, converged2 = jacobi_solver(N2, f2_func, 'periodic', tol2, max_iter2)\n    # As per prompt, output False for non-convergence.\n    results.append(converged2)\n\n    # --- Test Case 3: Periodic vs. Dirichlet ---\n    f3_func = lambda x, y: np.cos(2 * np.pi * x) + np.cos(2 * np.pi * y)\n    tol3 = 1e-8\n    max_iter3 = 6000\n    \n    # Periodic solution\n    # N=64 gives h=1/64\n    u_per, h_per, _ = jacobi_solver(64, f3_func, 'periodic', tol3, max_iter3)\n    norm_per = get_l2_norm(u_per, h_per)\n    \n    # Dirichlet solution\n    # N=65 gives h=1/64\n    u_dir, h_dir, _ = jacobi_solver(65, f3_func, 'dirichlet', tol3, max_iter3)\n    norm_dir = get_l2_norm(u_dir, h_dir)\n    \n    # Ratio of norms\n    ratio = norm_per / norm_dir\n    results.append(ratio)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2404984"}]}