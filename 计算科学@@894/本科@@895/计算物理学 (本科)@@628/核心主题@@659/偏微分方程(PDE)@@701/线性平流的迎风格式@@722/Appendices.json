{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式莫过于亲手实践。我们从一个基础但极具启发性的练习开始。这个练习要求你使用一阶迎风格式来模拟一个急剧变化的波形——亥维赛德阶跃函数（Heaviside step function）的平流过程。这是一个经典的数值实验，因为它能非常直观地暴露出一阶迎风格式最显著的特性之一：数值耗散（numerical diffusion）。通过将你的数值结果与精确解进行比较，你将亲眼看到尖锐的界面是如何在网格上传播时被逐渐“平滑”或“模糊”掉的，从而对迎风格式的性质建立起第一手的感性认识。[@problem_id:2448567]", "problem": "考虑一个标量场 $u(x,t)$ 的一维线性平流方程，其平流速度 $a$ 为常数，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x \\in [x_{\\min},x_{\\max}],\\ t \\ge 0,\n$$\n其初始条件由 Heaviside 阶跃函数给出\n$$\nu(x,0) = H(x - x_0),\\quad H(\\xi) = \\begin{cases}\n1,& \\xi \\ge 0,\\\\\n0,& \\xi &lt; 0.\n\\end{cases}\n$$\n施加与初始数据远场状态一致的流入边界条件：如果 $a > 0$，则对所有 $t \\ge 0$ 强制 $u(x_{\\min},t)=0$；如果 $a < 0$，则对所有 $t \\ge 0$ 强制 $u(x_{\\max},t)=1$。所有量均为无量纲量。\n\n在 $[x_{\\min},x_{\\max}]$ 上的一个包含 $N$ 个点的均匀空间网格上，将解在时间上推进至最终时间 $T$。时间步长 $\\Delta t$ 的选择应满足指定的 Courant–Friedrichs–Lewy (CFL) 数 $C$，其中\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x},\\quad \\Delta x = \\frac{x_{\\max} - x_{\\min}}{N-1}.\n$$\n使用与 $a$ 符号一致的一阶迎风离散格式。对于下面的每个测试用例，计算在时间 $T$ 的离散 $\\ell^1$ 误差，定义为\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x,\n$$\n其中 $x_i$ 是网格点，$u_i^{\\text{num}}(T)$ 是在时间 $T$ 的数值解，而解析解是平移后的阶跃函数\n$$\nu^{\\text{exact}}(x,T) = H\\!\\left( x - (x_0 + a\\,T) \\right),\n$$\n该解析解对于下面给出的时间和参数是有效的，因为平流带来的间断点严格保持在区间 $[x_{\\min},x_{\\max}]$ 内部，不与边界发生相互作用。\n\n测试套件（每个测试用例是一个元组 $(a,x_{\\min},x_{\\max},x_0,N,T,C)$）：\n- 测试 $1$：$(1.0,\\,0.0,\\,1.0,\\,0.25,\\,401,\\,0.2,\\,0.5)$。\n- 测试 $2$：$(-0.7,\\,0.0,\\,1.0,\\,0.8,\\,401,\\,0.15,\\,0.8)$。\n- 测试 $3$：$(1.0,\\,0.0,\\,1.0,\\,0.3,\\,201,\\,0.3,\\,1.0)$。\n\n您的程序必须按所列顺序为每个测试计算 $E_1$，并生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个数字四舍五入到六位小数（例如，$[0.123456,0.000000,1.234568]$）。", "solution": "该问题是有效的，因为它具有科学依据、是适定的且客观的。它提出了计算物理学中的一个标准任务：使用一阶迎风格式求解线性平流方程并评估数值误差。所有参数和条件都已明确定义。\n\n控制方程是标量场 $u(x,t)$ 在恒定平流速度 $a$ 下的一维线性平流方程：\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\n为了对该方程进行数值求解，我们对时空域进行离散化。空间域 $[x_{\\min}, x_{\\max}]$ 被划分为一个包含 $N$ 个点的均匀网格，$x_i = x_{\\min} + i\\Delta x$, $i=0, 1, \\dots, N-1$，其中网格间距为 $\\Delta x = (x_{\\max} - x_{\\min}) / (N-1)$。时间以离散步长推进，我们将 $u(x_i, t^n)$ 的数值近似表示为 $u_i^n$。\n\n时间导数 $\\partial_t u$ 使用一阶向前差分（向前欧拉法）进行近似：\n$$\n\\partial_t u(x_i, t^n) \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n一阶迎风格式使用单边有限差分来近似空间导数 $\\partial_x u$。单边模板的选择取决于信息传播的方向，该方向由平流速度 $a$ 的符号决定。这确保了数值方法从“迎风”方向提取信息，这是双曲型求解器稳定性的一个关键属性。\n\n情况 1：$a > 0$\n信息从左向右（沿 $x$ 轴正方向）传播。在 $x_i$ 处的空间导数使用后向差分进行近似，该差分涉及迎风点 $x_{i-1}$：\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\n将这些离散近似代入偏微分方程，得到更新规则：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\n$$\n求解下一个时间步的解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n) = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\n其中 $C = \\frac{a \\Delta t}{\\Delta x}$ 是 Courant–Friedrichs–Lewy (CFL) 数，因为 $a>0$。该格式应用于 $i=1, \\dots, N-1$。\n\n情况 2：$a < 0$\n信息从右向左（沿 $x$ 轴负方向）传播。空间导数使用向前差分进行近似，该差分涉及迎风点 $x_{i+1}$：\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\n相应的更新规则为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_i^n}{\\Delta x} = 0\n$$\n求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n) = u_i^n + C (u_{i+1}^n - u_i^n)\n$$\n此处，CFL 数定义为 $C = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$，这意味着 $\\frac{a \\Delta t}{\\Delta x} = -C$。该格式应用于 $i=0, \\dots, N-2$。\n\n如果满足 CFL 条件 $C \\le 1$，则该显式时间步进格式的稳定性得到保证。所提供的所有测试用例都满足此条件。\n\n模拟按以下步骤进行：\n1.  **初始化**：对于每个测试用例 $(a, x_{\\min}, x_{\\max}, x_0, N, T, C)$，计算网格间距 $\\Delta x$ 和名义时间步长 $\\Delta t = C \\Delta x / |a|$。解数组 $u$ 使用 Heaviside 函数 $u(x,0) = H(x - x_0)$ 进行初始化。\n2.  **时间演化**：通过一个循环将解从 $t=0$ 推进到 $T$。为确保精确达到最终时间 $T$，每次迭代的时间步长计算为 $\\Delta t_{\\text{curr}} = \\min(\\Delta t, T - t)$。这处理了 $T$ 不是 $\\Delta t$ 整数倍的情况。\n3.  **更新步骤**：在循环内部，复制一份解 $u^n$。使用适当的迎风公式为所有内部点计算新的解 $u^{n+1}$，更新系数按 $\\Delta t_{\\text{curr}}$ 进行缩放。\n4.  **边界条件**：计算完内部点的更新后，强制施加流入边界条件。如果 $a > 0$，则设置左边界的值：$u_0^{n+1} = 0$。如果 $a < 0$，则设置右边界的值：$u_{N-1}^{n+1} = 1$。流出边界无需特殊处理，因为它已由迎风模板的单边特性处理。\n5.  **误差计算**：一旦模拟达到 $t=T$，就获得了最终的数值解 $u_i^{\\text{num}}(T)$。在同一网格上计算解析解 $u^{\\text{exact}}(x_i,T) = H(x_i - (x_0 + aT))$。然后使用以下公式计算离散 $\\ell^1$ 误差：\n    $$\n    E_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x\n    $$\n对于 $C=1.0$ 的测试用例，格式（对于 $a>0$）简化为 $u_i^{n+1} = u_{i-1}^n$。这对应于每个时间步将离散数据精确地移动一个网格单元。由于总时间 $T$ 的选择使得总平流距离 $aT$ 是 $\\Delta x$ 的整数倍，因此网格上的数值解与精确解完全相同，从而导致零误差。对于 $C &lt; 1$，该格式会引入数值耗散，这会抹平尖锐的阶跃并产生非零误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation for multiple test cases\n    using a first-order upwind scheme and computes the l1 error.\n    \"\"\"\n    test_cases = [\n        # (a, x_min, x_max, x_0, N, T, C)\n        (1.0, 0.0, 1.0, 0.25, 401, 0.2, 0.5),\n        (-0.7, 0.0, 1.0, 0.8, 401, 0.15, 0.8),\n        (1.0, 0.0, 1.0, 0.3, 201, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(*case)\n        # Append result formatted to six decimal places.\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(a, x_min, x_max, x_0, N, T, C):\n    \"\"\"\n    Runs a single simulation case for the 1D linear advection equation.\n\n    Args:\n        a (float): Advection speed.\n        x_min (float): Minimum of the spatial domain.\n        x_max (float): Maximum of the spatial domain.\n        x_0 (float): Initial position of the step in the Heaviside function.\n        N (int): Number of grid points.\n        T (float): Final time.\n        C (float): Courant–Friedrichs–Lewy (CFL) number.\n\n    Returns:\n        float: The discrete l1 error at the final time T.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    dx = (x_max - x_min) / (N - 1)\n    x = np.linspace(x_min, x_max, N)\n    # The problem defines H(xi) = 1 for xi >= 0. np.heaviside with second arg 1.0 does this.\n    u = np.heaviside(x - x_0, 1.0)\n\n    # 2. Setup time stepping\n    # The advection speed 'a' is non-zero in all test cases.\n    dt_nominal = C * dx / abs(a)\n    \n    # 3. Time integration loop\n    t = 0.0\n    # Use a small tolerance for floating point comparison to ensure loop termination.\n    while t < T:\n        # Determine current time step to not step over T.\n        current_dt = min(dt_nominal, T - t)\n        \n        # Make a copy of the solution at the current time step 'n'.\n        u_n = u.copy()\n        \n        # The update coefficient nu = a * dt / dx\n        nu = a * current_dt / dx\n        \n        if a > 0:\n            # FTBS (Forward-Time, Backward-Space) for a > 0\n            # u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n)\n            u[1:] = u_n[1:] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_min\n            u[0] = 0.0\n        else: # a < 0\n            # FTFS (Forward-Time, Forward-Space) for a < 0\n            # u_i^{n+1} = u_i^n - nu * (u_{i+1}^n - u_i^n)\n            u[:-1] = u_n[:-1] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_max\n            u[-1] = 1.0\n            \n        t += current_dt\n\n    # 4. Calculate exact solution at time T\n    x_final_discontinuity = x_0 + a * T\n    u_exact = np.heaviside(x - x_final_discontinuity, 1.0)\n    \n    # 5. Compute the discrete l1 error\n    error = np.sum(np.abs(u - u_exact)) * dx\n    \n    return error\n\nsolve()\n```", "id": "2448567"}, {"introduction": "在第一个练习中，我们定性地观察到了数值耗散。现在，我们将更进一步，定量地分析这一现象。虽然一阶迎风格式在离散形式下能够精确地保持总“质量”（即 $\\int u \\, dx$）守恒，但它却无法保持所有物理量的不变。这个练习将引导你考察一个更高阶的量——解的二阶矩或“能量”（即 $\\int u^2 \\, dx$）的演化。通过计算并比较初始和最终时刻的离散二阶矩，你将量化数值耗散对解的影响，深刻理解数值格式如何在保持某些守恒律的同时，却引入了针对其他物理量的人为耗散。[@problem_id:2448571]", "problem": "考虑一维周期性域上的常速线性平流方程，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\qquad x\\in[0,L],\\ t\\ge 0,\n$$\n其满足周期性边界条件和如下初始条件\n$$\nu(x,0)=\\sin\\!\\left(\\tfrac{2\\pi x}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x}{L}\\right).\n$$\n在一个包含$N$个点的均匀网格上，点的位置为$x_i=i\\,\\Delta x$（$i=0,1,\\dots,N-1$），且$\\Delta x=L/N$。在时间层$t^n=n\\,\\Delta t$上定义离散解值$u_i^n\\approx u(x_i,t^n)$，其中时间步长通过库朗数$s\\in(0,1]$按下式选取\n$$\n\\Delta t=\\frac{s\\,\\Delta x}{|a|}.\n$$\n使用带周期性绕回的一阶迎风有限差分格式，将解从时间层$n$更新到$n+1$：\n- 若$a>0$，\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i-1}^{n}\\right),\n$$\n- 若$a<0$，\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i+1}^{n}\\right),\n$$\n其中由于周期性，下标均在模$N$的意义下理解。将离散解从$t=0$演化到最终时间\n$$\nt_{\\mathrm{final}}=\\frac{L}{|a|},\n$$\n这恰好对应$N_t=N/s$个时间步（下文所有测试用例均保证$N/s$为整数），使得精确连续解恰好在域上完成一次完整的绕回。\n\n在时间层$n$的离散二阶矩定义为\n$$\nM_2^n=\\sum_{i=0}^{N-1} \\left(u_i^n\\right)^2 \\,\\Delta x,\n$$\n以及诊断比率\n$$\nR=\\frac{M_2^{N_t}}{M_2^0}.\n$$\n对于具有周期性边界的连续方程，物理量$\\int_0^L u(x,t)^2\\,\\mathrm{d}x$在时间上是守恒的。本问题旨在检验迎风格式引入的数值耗散如何在一个区域遍历周期内影响离散二阶矩$M_2^n$的守恒性。\n\n本问题中所有物理量均为无量纲。\n\n请实现一个程序，对下列测试集中的每一组参数，计算如上定义的比率$R$。\n\n测试集（每个元组列出$(L,a,N,s)$）：\n1. $(1,\\ 1,\\ 200,\\ 0.5)$,\n2. $(1,\\ 1,\\ 100,\\ 1)$,\n3. $(1,\\ -1,\\ 200,\\ 0.5)$,\n4. $(1,\\ 1,\\ 20,\\ 0.5)$,\n5. $(1,\\ 1,\\ 200,\\ 0.25)$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），$r_k$是对应于上述顺序的第$k$个测试用例的$R$的浮点值。", "solution": "所给问题是计算物理学中的一个标准练习，涉及线性平流方程的数值解。该问题是适定的，科学上是合理的，并且所有参数和条件都已明确指定。因此，可以构建一个解决方案。\n\n问题的核心是量化一阶迎风有限差分格式固有的数值耗散。控制偏微分方程是线性平流方程：\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\n该方程定义在一维域$x\\in[0,L]$上，并带有周期性边界条件。对于这样的系统，解的平方积分$\\int_0^L u(x,t)^2\\,\\mathrm{d}x$是一个守恒量。然而，数值格式会引入人为的耗散，导致该量的离散模拟随时间衰减。\n\n我们使用一个包含$N$个点的均匀网格对域进行离散化，$x_i = i\\,\\Delta x$（$i \\in \\{0, 1, \\dots, N-1\\}$），其中网格间距为$\\Delta x = L/N$。解$u(x,t)$由离散值$u_i^n \\approx u(x_i, t^n)$近似，其中$t^n = n\\,\\Delta t$是离散的时间层。\n\n首先，我们建立系统在$t=0$时的初始状态。初始条件由下式给出：\n$$\nu(x,0)=\\sin\\!\\left(\\tfrac{2\\pi x}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x}{L}\\right)\n$$\n以离散形式，初始解向量$u^0 = [u_0^0, u_1^0, \\dots, u_{N-1}^0]^T$初始化为：\n$$\nu_i^0 = \\sin\\!\\left(\\tfrac{2\\pi x_i}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x_i}{L}\\right) = \\sin\\!\\left(\\tfrac{2\\pi i}{N}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi i}{N}\\right)\n$$\n适用于每个网格点$i=0, 1, \\dots, N-1$。\n\n接下来，我们使用一阶迎风格式随时间演化解。时间步长$\\Delta t$由库朗数$s \\in (0,1]$确定：\n$$\n\\Delta t=\\frac{s\\,\\Delta x}{|a|}\n$$\n迎风格式的更新规则取决于平流速度$a$的符号，该符号决定了信息传播的方向。\n\n情况1：$a>0$（向右传播）。空间导数$\\partial_x u$使用后向差分进行近似，因为信息来自“迎风”方向，即来自较小的$x$。更新规则是：\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i-1}^{n}\\right)\n$$\n这里，由于$a>0$，有$s = a \\frac{\\Delta t}{\\Delta x}$。由于周期性边界条件，下标$i-1$在模$N$的意义下计算，即$u_{-1}^n = u_{N-1}^n$。\n\n情况2：$a<0$（向左传播）。空间导数使用前向差分进行近似，因为信息来自较大的$x$。更新规则是：\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i+1}^{n}\\right)\n$$\n这里，$s = |a| \\frac{\\Delta t}{\\Delta x} = -a \\frac{\\Delta t}{\\Delta x}$。由于周期性，下标$i+1$在模$N$的意义下计算，即$u_{N}^n = u_0^n$。\n\n模拟从$t=0$进行到最终时间$t_{\\mathrm{final}}=L/|a|$。这个时间对应于波在域上完成一次完整的周期性穿行。总时间步数$N_t$为：\n$$\nN_t = \\frac{t_{\\mathrm{final}}}{\\Delta t} = \\frac{L/|a|}{s\\,\\Delta x/|a|} = \\frac{L}{s\\,\\Delta x} = \\frac{L}{s(L/N)} = \\frac{N}{s}\n$$\n问题保证对于所有测试用例，$N_t$都是整数。一个循环将执行此更新步骤$N_t$次，以获得最终的离散解$u^{N_t}$。\n\n最后，我们计算诊断比率$R$。这需要计算离散二阶矩，定义为：\n$$\nM_2^n=\\sum_{i=0}^{N-1} \\left(u_i^n\\right)^2 \\,\\Delta x\n$$\n我们使用初始解$u^0$计算初始时刻的该量$M_2^0$，并使用最终解$u^{N_t}$计算最终时刻的该量$M_2^{N_t}$。比率$R$则由下式给出：\n$$\nR=\\frac{M_2^{N_t}}{M_2^0}\n$$\n此比率$R$量化了在一个遍历周期内，由于数值耗散导致的离散$L_2$范数平方的衰减。对于一个无耗散格式，$R$将恰好为$1$。对于一阶迎风格式，我们预计当$s<1$时$R<1$，其与$1$的偏差表示耗散的大小。\n\n对于每个测试用例$(L, a, N, s)$的算法如下：\n1.  定义网格参数：$\\Delta x = L/N$ 和 $N_t = \\text{int}(N/s)$。\n2.  生成空间网格 $x_i = i \\Delta x$，$i = 0, \\dots, N-1$。\n3.  使用给定公式计算初始解向量$u^0$。\n4.  计算初始二阶矩$M_2^0 = \\Delta x \\sum_{i=0}^{N-1} (u_i^0)^2$。\n5.  迭代$N_t$次：在每一步中，根据$a$的符号使用适当的迎风公式更新解向量$u$，并遵守周期性边界。这可以通过向量化的数组操作高效实现。\n6.  循环结束后，根据最终解向量计算最终二阶矩$M_2^{N_t}$。\n7.  计算并存储比率$R = M_2^{N_t} / M_2^0$。\n\n对所有给定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using the first-order upwind scheme\n    and computes the diagnostic ratio R for several test cases.\n    \"\"\"\n    # Test suite from the problem statement: (L, a, N, s)\n    test_cases = [\n        (1, 1, 200, 0.5),\n        (1, 1, 100, 1),\n        (1, -1, 200, 0.5),\n        (1, 1, 20, 0.5),\n        (1, 1, 200, 0.25),\n    ]\n\n    results = []\n    \n    for L, a, N, s in test_cases:\n        # Step 1: Define grid parameters and number of time steps.\n        dx = L / N\n        # The problem statement guarantees that N/s is an integer.\n        num_time_steps = int(N / s)\n        \n        # Step 2: Set the initial condition on the grid.\n        # Grid points x_i = i * dx for i = 0, ..., N-1.\n        x = np.linspace(0, L, N, endpoint=False)\n        u_initial = np.sin(2 * np.pi * x / L) + 0.5 * np.sin(4 * np.pi * x / L)\n        \n        # Step 3: Calculate the initial discrete second moment M_2^0.\n        m2_initial = np.sum(u_initial**2) * dx\n        \n        # Step 4: Evolve the solution in time using the upwind scheme.\n        u_current = np.copy(u_initial)\n        \n        # The update rule depends on the sign of the velocity 'a'.\n        if a > 0:\n            # For a > 0, the scheme uses the backward difference (u_i - u_{i-1}).\n            # u_i^{n+1} = u_i^n - s * (u_i^n - u_{i-1}^n)\n            # np.roll(u, 1) provides u_{i-1} with periodic wrapping.\n            for _ in range(num_time_steps):\n                u_previous = np.roll(u_current, 1)\n                u_current = u_current - s * (u_current - u_previous)\n        else: # a < 0\n            # For a < 0, the scheme uses the forward difference (u_{i+1} - u_i).\n            # The problem statement gives u_i^{n+1} = u_i^n - s * (u_i^n - u_{i+1}^n)\n            # which is equivalent to u_i^{n+1} = u_i^n + s * (u_{i+1}^n - u_i^n).\n            # np.roll(u, -1) provides u_{i+1} with periodic wrapping.\n            for _ in range(num_time_steps):\n                u_next = np.roll(u_current, -1)\n                u_current = u_current - s * (u_current - u_next)\n                \n        # Step 5: Calculate the final discrete second moment M_2^{N_t}.\n        m2_final = np.sum(u_current**2) * dx\n        \n        # Step 6: Compute the diagnostic ratio R.\n        # A check is included for the theoretical case of M_2^0 = 0, though not\n        # possible with the given initial condition.\n        if m2_initial == 0:\n            ratio = 1.0 if m2_final == 0 else np.inf\n        else:\n            ratio = m2_final / m2_initial\n            \n        results.append(ratio)\n        \n    # Final print statement in the exact required format.\n    # Results are formatted as floating-point numbers to ensure consistency.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "2448571"}, {"introduction": "最后一个实践练习将我们对数值耗散的理解置于一个更广泛的物理情境中。在许多真实的物理系统中，输运过程（平流）和扩散过程同时存在，这由平流-扩散方程（advection-diffusion equation）描述。这个练习要求你求解该方程，并巧妙地设计一种方法来区分并估算由格式自身引入的“数值扩散”与方程中固有的“物理扩散”。完成这个挑战，你将能更好地理解为什么在模拟真实物理问题时，必须清楚地认识到数值方法可能带来的影响，以及如何判断数值结果的可靠性。[@problem_id:2448642]", "problem": "考虑一维线性平流-扩散方程\n$$\n\\frac{\\partial u}{\\partial t} + c \\,\\frac{\\partial u}{\\partial x} = D \\,\\frac{\\partial^2 u}{\\partial x^2}\n$$\n在周期性域 $[0,L)$ 上，其中 $u(x,t)$ 是无量纲的。设初始条件为单个傅里叶模式 $u(x,0) = \\sin\\!\\big(2\\pi m x / L\\big)$，其中 $m \\ge 1$ 为整数。使用包含 $N$ 个点的均匀网格，网格间距为 $\\Delta x = L/N$，并采用周期性边界条件。\n\n使用显式、线性、常系数的有限差分时间步进格式来推进时间上的解，该格式通过组合用于平流项的一阶迎风离散、用于扩散项的二阶中心离散以及时间上的前向欧拉方法得到：\n$$\nu^{n+1}_j \\;=\\; u^n_j \\;-\\; r\\left(u^n_j - u^n_{j-1}\\right) \\;+\\; s\\left(u^n_{j+1} - 2u^n_j + u^n_{j-1}\\right),\n$$\n其中，$u^n_j$ 是 $u(x_j, t^n)$ 在 $x_j = j\\,\\Delta x$（$j \\in \\{0,1,\\dots,N-1\\}$）和 $t^n = n\\,\\Delta t$ 处的近似值，并且\n$$\nr \\equiv \\frac{c\\,\\Delta t}{\\Delta x}, \\qquad s \\equiv \\frac{D\\,\\Delta t}{\\Delta x^2}.\n$$\n假设 $c \\ge 0$，因此迎风差分使用左侧邻点 $u^n_{j-1}$。通过将 $u^n_{-1} \\equiv u^n_{N-1}$ 和 $u^n_{N} \\equiv u^n_{0}$ 来强制周期性。\n\n对于一个给定的参数集 $(L,N,c,D,\\Delta t,t_{\\mathrm{final}},m)$，定义连续波数 $k \\equiv 2\\pi m/L$，计算时间步数 $n_{\\mathrm{steps}} \\equiv \\left\\lfloor t_{\\mathrm{final}}/\\Delta t \\right\\rfloor$，将该格式精确推进 $n_{\\mathrm{steps}}$ 步，并将实现的最终时间记为 $T \\equiv n_{\\mathrm{steps}}\\,\\Delta t$。令 $A_0$ 为初始状态在波数索引 $m$ 处离散傅里叶系数（通过离散傅里叶变换(DFT)计算）的模，令 $A_T$ 为时间 $T$ 处对应的模。定义有效扩散系数\n$$\nD_{\\mathrm{eff}} \\;\\equiv\\; -\\,\\frac{1}{k^2\\,T}\\,\\ln\\!\\left(\\frac{A_T}{A_0}\\right),\n$$\n并定义估计的数值扩散为\n$$\nD_{\\mathrm{num}} \\;\\equiv\\; D_{\\mathrm{eff}} - D.\n$$\n\n您的任务是编写一个程序，对于下面测试套件中的每个参数集，计算 $D_{\\mathrm{num}}$ 的浮点数值。所有量均为无量纲。每个输出值均需四舍五入到六位小数。\n\n测试套件（包含三个案例，旨在探究一个典型情况、一个数值扩散消失的边界情况，以及一个扩散主导的边缘情况）：\n- 案例 1（无物理扩散的典型平流）：\n  - $L = 1$, $N = 256$, $c = 1$, $D = 0$, $\\Delta t = 0.5\\,\\Delta x / c$, $t_{\\mathrm{final}} = 0.1$, $m = 1$。\n- 案例 2（单位库朗数下、带微小物理扩散的平流）：\n  - $L = 1$, $N = 256$, $c = 1$, $D = 0.001$, $\\Delta t = \\Delta x / c$, $t_{\\mathrm{final}} = 0.1$, $m = 1$。\n- 案例 3（扩散主导，时间步长接近扩散稳定性极限）：\n  - $L = 1$, $N = 256$, $c = 0.5$, $D = 0.01$, $\\Delta t = 0.49\\,\\Delta x^{2} / D$, $t_{\\mathrm{final}} = 0.1$, $m = 1$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的三个结果（例如，“[0.123456,0.000000,0.987654]”）。每个条目都必须是四舍五入到六位小数的浮点数。", "solution": "起点是一维平流-扩散方程\n$$\n\\frac{\\partial u}{\\partial t} + c \\,\\frac{\\partial u}{\\partial x} = D \\,\\frac{\\partial^2 u}{\\partial x^2},\n$$\n该方程建立在周期性域 $[0,L)$ 上，初始条件为 $u(x,0) = \\sin(2\\pi m x / L)$，其中 $m \\in \\mathbb{N}$ 并且所有量均为无量纲。其目标是量化一阶迎风空间离散所固有的数值扩散与由 $D$ 代表的物理扩散之间的相互作用。\n\n离散化。在一个包含 $N$ 个点、间距为 $\\Delta x = L/N$ 的均匀网格上，记 $x_j = j\\,\\Delta x$ (其中 $j \\in \\{0,1,\\dots,N-1\\}$) 和时间 $t^n = n\\,\\Delta t$。对平流项使用一阶迎风格式（对于 $c \\ge 0$），对扩散项使用二阶中心差分格式，并通过前向欧拉时间步进相结合，得到以下显式更新格式：\n$$\nu^{n+1}_j = u^n_j - r\\left(u^n_j - u^n_{j-1}\\right) + s\\left(u^n_{j+1} - 2u^n_j + u^n_{j-1}\\right),\n$$\n其中\n$$\nr \\equiv \\frac{c\\,\\Delta t}{\\Delta x}, \\qquad s \\equiv \\frac{D\\,\\Delta t}{\\Delta x^2}.\n$$\n周期性强制 $u^n_{-1} \\equiv u^n_{N-1}$ 和 $u^n_N \\equiv u^n_0$。其线性、平移不变的结构确保了离散傅里叶模式在更新后仍然是傅里叶模式。\n\n傅里叶模式分析与有效扩散。考虑一个形式为 $u^n_j \\propto \\exp\\!\\left(\\mathrm{i}\\,j\\,\\theta\\right)$ 的网格傅里叶模式，其离散相位为 $\\theta \\equiv k\\,\\Delta x$，其中 $k = 2\\pi m / L$ 是连续波数。代入更新方程，可得单步放大因子\n$$\nG(\\theta;r,s) \\;=\\; 1 - r\\left(1 - e^{-\\mathrm{i}\\theta}\\right) + s\\left(e^{\\mathrm{i}\\theta} - 2 + e^{-\\mathrm{i}\\theta}\\right).\n$$\n经过 $n$ 步后，振幅被乘以 $|G|^n$。如果 $t=0$ 时的振幅是 $A_0$，而在时间 $T = n\\,\\Delta t$ 时的振幅是 $A_T$，则有\n$$\n\\frac{A_T}{A_0} = |G|^n = \\exp\\!\\left(n \\ln |G|\\right) = \\exp\\!\\left(\\frac{T}{\\Delta t}\\,\\ln|G|\\right).\n$$\n通过将此衰减与连续统的指数衰减 $\\exp(-D_{\\mathrm{eff}}\\,k^2 T)$ 相匹配，定义有效扩散系数：\n$$\nD_{\\mathrm{eff}} \\;=\\; -\\,\\frac{1}{k^2 T}\\,\\ln\\!\\left(\\frac{A_T}{A_0}\\right).\n$$\n那么，估计的数值扩散为\n$$\nD_{\\mathrm{num}} \\;=\\; D_{\\mathrm{eff}} - D.\n$$\n对于小的 $\\theta$（即，被良好解析的模式），对一阶迎风平流格式进行修正方程展开，表明其主阶人工扩散为\n$$\nD_{\\mathrm{num}} \\;\\approx\\; \\frac{c\\,\\Delta x}{2}\\,\\left(1 - r\\right),\n$$\n在该阶上与 $D$ 无关。这一预测为相互作用提供了明确的预期：作用于该模式的总扩散约等于 $D_{\\mathrm{eff}} \\approx D + D_{\\mathrm{num}}$ 之和。\n\n数值流程。初始化 $u^0_j = \\sin\\!\\big(2\\pi m x_j / L\\big)$。计算 $n_{\\mathrm{steps}} = \\left\\lfloor t_{\\mathrm{final}}/\\Delta t \\right\\rfloor$ 并将显式格式推进 $n_{\\mathrm{steps}}$ 步。令 $T = n_{\\mathrm{steps}}\\,\\Delta t$ 表示实现的最终时间。分别计算 $u^0$ 和 $u^{n_{\\mathrm{steps}}}$ 在索引 $m$ 处的离散傅里叶变换 (DFT) 系数的模 $A_0$ 和 $A_T$。然后如上计算 $D_{\\mathrm{eff}}$ 和 $D_{\\mathrm{num}}$。\n\n测试套件预期。对于 $L = 1$ 和 $N = 256$，网格间距为 $\\Delta x = 1/256$。对于三个测试案例：\n\n- 案例 1：$c = 1$, $D = 0$, $\\Delta t = 0.5\\,\\Delta x / c$，因此 $r = 0.5$ 且 $s = 0$。主阶预测给出\n$$\nD_{\\mathrm{num}} \\approx \\frac{1 \\cdot (1/256)}{2}\\,(1 - 0.5) = \\frac{1}{512}\\cdot \\frac{1}{2} = \\frac{1}{1024} \\approx 9.765625\\times 10^{-4}.\n$$\n对于基频模式 $\\theta = 2\\pi/N$，程序计算出的值应非常接近此值。\n\n- 案例 2：$c = 1$, $D = 0.001$, $\\Delta t = \\Delta x / c$, 因此 $r = 1$。主阶数值扩散消失，\n$$\nD_{\\mathrm{num}} \\approx \\frac{1 \\cdot (1/256)}{2}\\,(1 - 1) = 0,\n$$\n并且程序测得的 $D_{\\mathrm{num}}$ 应接近于 $0$。\n\n- 案例 3：$c = 0.5$, $D = 0.01$, $\\Delta t = 0.49\\,\\Delta x^2 / D$, 因此 $s = 0.49$ 并且\n$$\nr = \\frac{c\\,\\Delta t}{\\Delta x} = \\frac{0.5 \\cdot 0.49\\,\\Delta x^2 / D}{\\Delta x} = \\frac{0.245\\,\\Delta x}{D} \\approx 9.5703125\\times 10^{-2}.\n$$\n主阶预测得出\n$$\nD_{\\mathrm{num}} \\approx \\frac{0.5\\,\\Delta x}{2}\\,(1 - r) \\approx 0.25\\,\\Delta x\\,(1 - r) \\approx 9.765625\\times 10^{-4}\\times 0.904296875 \\approx 8.83102\\times 10^{-4}.\n$$\n程序根据实际的放大系数计算 $D_{\\mathrm{eff}}$ 并减去 $D$，从而得到一个接近该预测值的估计。\n\n输出格式。程序应为每个案例计算 $D_{\\mathrm{num}}$，将每个结果四舍五入到六位小数，并在一行中打印出用方括号括起来的、以逗号分隔的结果列表，例如\n$$\n[\\text{value}_1,\\text{value}_2,\\text{value}_3].\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(L, N, c, D, dt, t_final, m):\n    # Grid\n    x = np.linspace(0.0, L, N, endpoint=False)\n    dx = L / N\n\n    # Initial condition: single Fourier mode\n    u = np.sin(2.0 * np.pi * m * x / L).astype(np.float64)\n    u0 = u.copy()\n\n    # Time step counts\n    if dt <= 0.0:\n        return float('nan')\n    n_steps = int(np.floor(t_final / dt))\n    if n_steps <= 0:\n        # No stepping; numerical diffusion undefined; return 0.0 by convention\n        return 0.0\n    T = n_steps * dt\n\n    # Precompute coefficients\n    r = c * dt / dx\n    s = D * dt / (dx * dx)\n\n    # Time integration\n    for _ in range(n_steps):\n        u_plus = np.roll(u, -1)\n        u_minus = np.roll(u, 1)\n        u = u - r * (u - u_minus) + s * (u_plus - 2.0 * u + u_minus)\n\n    # Compute Fourier amplitudes at index m using DFT\n    U0 = np.fft.fft(u0)\n    UT = np.fft.fft(u)\n    A0 = np.abs(U0[m])\n    AT = np.abs(UT[m])\n\n    # Continuous wavenumber\n    k = 2.0 * np.pi * m / L\n\n    # Effective diffusion and numerical diffusion\n    # Guard against zero or negative ratio due to numerical issues\n    ratio = AT / A0 if A0 > 0 else 1.0\n    # Prevent log of zero\n    ratio = max(ratio, 1e-300)\n    D_eff = - (1.0 / (k * k * T)) * np.log(ratio)\n    D_num = D_eff - D\n    return D_num\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L, N, c, D, dt_formula, t_final, m)\n    cases = [\n        # Case 1: L=1, N=256, c=1, D=0, dt=0.5*dx/c, t_final=0.1, m=1\n        {\"L\": 1.0, \"N\": 256, \"c\": 1.0, \"D\": 0.0, \"dt_type\": \"half_dx_over_c\", \"t_final\": 0.1, \"m\": 1},\n        # Case 2: L=1, N=256, c=1, D=0.001, dt=dx/c, t_final=0.1, m=1\n        {\"L\": 1.0, \"N\": 256, \"c\": 1.0, \"D\": 0.001, \"dt_type\": \"dx_over_c\", \"t_final\": 0.1, \"m\": 1},\n        # Case 3: L=1, N=256, c=0.5, D=0.01, dt=0.49*dx^2/D, t_final=0.1, m=1\n        {\"L\": 1.0, \"N\": 256, \"c\": 0.5, \"D\": 0.01, \"dt_type\": \"0.49_dx2_over_D\", \"t_final\": 0.1, \"m\": 1},\n    ]\n\n    results = []\n    for case in cases:\n        L = case[\"L\"]\n        N = case[\"N\"]\n        c = case[\"c\"]\n        D = case[\"D\"]\n        dx = L / N\n        # Compute dt according to specified formula\n        if case[\"dt_type\"] == \"half_dx_over_c\":\n            dt = 0.5 * dx / c if c > 0 else 0.0\n        elif case[\"dt_type\"] == \"dx_over_c\":\n            dt = dx / c if c > 0 else 0.0\n        elif case[\"dt_type\"] == \"0.49_dx2_over_D\":\n            dt = 0.49 * dx * dx / D if D > 0 else 0.0\n        else:\n            dt = 0.0\n\n        dnum = run_case(L, N, c, D, dt, case[\"t_final\"], case[\"m\"])\n        # Round to six decimal places for output\n        dnum_rounded = float(f\"{dnum:.6f}\")\n        results.append(dnum_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```", "id": "2448642"}]}