{"hands_on_practices": [{"introduction": "我们的动手实践之旅从一个经典的物理问题——弦的振动——开始。本练习要求你为一维波动方程实现一种基础的数值方法，即时域有限差分（FDTD）法。通过引入一个内部固定点，你将在应用各种边界条件方面获得实践经验，这是模拟真实物理系统的一项关键技能。[@problem_id:2449924]", "problem": "考虑一根长度为 $L$ 的拉紧的均匀弦，其横向位移 $u(x,t)$ 由一维波动方程控制：\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}, \\quad 0 < x < L,\\ t \\ge 0,\n$$\n其中 $c$ 是波速。弦的两端是固定的：\n$$\nu(0,t) = 0,\\quad u(L,t) = 0 \\quad \\text{对于所有 } t \\ge 0,\n$$\n并且弦穿过一个无质量环，该环在位于横向位移 $u=0$ 处的无摩擦水平杆上滑动。该环位于弦上 $x=a$ 的位置，因此横向位移受到以下约束：\n$$\nu(a,t) = 0 \\quad \\text{对于所有 } t \\ge 0.\n$$\n假设横向位移很小，因此张力保持不变，并且在 $x=a$ 处的斜率不受约束。初始条件为：\n$$\nu(x,0) = A \\exp\\!\\left(-\\frac{(x - x_0)^2}{2\\sigma^2}\\right), \\quad \\frac{\\partial u}{\\partial t}(x,0) = 0,\n$$\n其中 $A$ 是脉冲振幅，$x_0$ 是中心，$\\sigma$ 是宽度参数。\n\n你的任务是计算 $u(x,T_f)$ 的一个数值近似解，该解在一个包含 $N+1$ 个点、间距为 $\\Delta x = L/N$ 的均匀空间网格上采样，并以时间步长 $\\Delta t$ 推进 $M$ 步，其中 $\\Delta t$ 通过 Courant 因子 $r$ 由下式指定：\n$$\n\\Delta t = r \\frac{\\Delta x}{c}.\n$$\n对于下方的每个测试用例，请使用给定的物理和数值参数。位于 $x=a$ 的内部约束恰好与一个网格节点对齐，观测点 $x_{\\text{obs}}$ 也恰好与一个网格节点对齐。\n\n所有用例共用的物理单位和参数：\n- 弦长 $L = 1.0\\ \\text{m}$。\n- 波速 $c = 1.0\\ \\text{m/s}$。\n- 脉冲振幅 $A = 1.0 \\times 10^{-3}\\ \\text{m}$。\n- 脉冲中心 $x_0 = 0.25\\ \\text{m}$。\n- 脉冲宽度 $\\sigma = 0.03\\ \\text{m}$。\n\n对于每个用例，在最终时刻 $T_f$ 计算以下三个量：\n1. 观测点处的位移 $u(x_{\\text{obs}}, T_f)$，单位为米。\n2. 网格上位移的离散 $\\ell^2$ 范数，定义为：\n$$\n\\left\\|u(\\cdot, T_f)\\right\\|_2 = \\sqrt{\\sum_{j=0}^{N} \\left(u(x_j,T_f)\\right)^2 \\Delta x},\n$$\n单位为米。\n3. 网格上的最大绝对位移 $\\max_{0 \\le j \\le N} \\left|u(x_j,T_f)\\right|$，单位为米。\n\n所有三个量都用米表示，每个都四舍五入到六位小数。\n\n测试套件（每一行指定 $\\{N, r, a, T_f, x_{\\text{obs}}\\}$）：\n- 用例 1：$\\{400,\\ 0.9,\\ 0.5\\ \\text{m},\\ 0.45\\ \\text{s},\\ 0.75\\ \\text{m}\\}$。\n- 用例 2：$\\{400,\\ 1.0,\\ 0.25\\ \\text{m},\\ 0.50\\ \\text{s},\\ 0.60\\ \\text{m}\\}$。\n- 用例 3：$\\{80,\\ 0.9,\\ 0.5\\ \\text{m},\\ 0.45\\ \\text{s},\\ 0.625\\ \\text{m}\\}$。\n- 用例 4：$\\{500,\\ 0.9,\\ 0.02\\ \\text{m},\\ 0.54\\ \\text{s},\\ 0.60\\ \\text{m}\\}$。\n\n最终输出格式：\n你的程序应该生成单行输出，包含所有四个用例的结果，聚合在一个扁平列表中，每个值都四舍五入到六位小数，顺序如下：\n$$\n\\left[ u(x_{\\text{obs}},T_f),\\ \\left\\|u(\\cdot,T_f)\\right\\|_2,\\ \\max |u(\\cdot,T_f)| \\right]\n$$\n先是用例 1 的结果，接着是用例 2 的同样三元组，然后是用例 3，再然后是用例 4。最后一行必须是用方括号括起来的逗号分隔列表，例如：\n$$\n[\\text{case1\\_u},\\text{case1\\_l2},\\text{case1\\_max},\\text{case2\\_u},\\dots,\\text{case4\\_max}].\n$$\n所有数值必须以米为单位，保留小数点后六位，不带任何附加文本。", "solution": "该问题要求对带有一个内部固定点约束的一维波动方程进行数值求解。合适的方法是采用有限差分格式，它将连续偏微分方程在一个时空网格上进行离散化。\n\n控制方程是关于横向位移 $u(x,t)$ 的线性波动方程：\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\n$$\n对于 $x \\in (0, L)$ 和 $t \\ge 0$。弦在两端固定，$u(0,t)=0$ 和 $u(L,t)=0$，并在内部位置 $x=a$ 有一个额外的固定点，其中 $u(a,t)=0$。这个内部约束有效地将弦解耦成两个独立的段 $[0, a]$ 和 $[a, L]$，每一段都由两端固定的波动方程控制。\n\n我们将使用在空间和时间上均为二阶精度的中心差分格式。设空间域被离散为 $N$ 个宽度为 $\\Delta x = L/N$ 的区间，网格点为 $x_j = j \\Delta x$，其中 $j=0, 1, \\dots, N$。设时间域被离散为大小为 $\\Delta t$ 的步长，时间点为 $t_n = n \\Delta t$，其中 $n=0, 1, \\dots, M$。网格点 $(x_j, t_n)$ 处的位移记为 $u_j^n \\approx u(x_j, t_n)$。\n\n二阶偏导数近似为：\n$$\n\\frac{\\partial^2 u}{\\partial t^2}\\bigg|_{(x_j, t_n)} \\approx \\frac{u_j^{n+1} - 2u_j^n + u_j^{n-1}}{(\\Delta t)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_j, t_n)} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\n$$\n将这些近似代入波动方程，并为下一时间步的位移 $u_j^{n+1}$ 重新整理，得到显式蛙跳积分格式：\n$$\nu_j^{n+1} = 2u_j^n - u_j^{n-1} + \\left(c \\frac{\\Delta t}{\\Delta x}\\right)^2 (u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n定义 Courant 数 $r = c \\frac{\\Delta t}{\\Delta x}$，更新规则简化为：\n$$\nu_j^{n+1} = 2(1-r^2)u_j^n + r^2(u_{j+1}^n + u_{j-1}^n) - u_j^{n-1}\n$$\n该格式在 $r \\le 1$ 时是稳定的。问题指定所有测试用例的 $r \\le 1$。\n\n为启动该格式，我们需要在两个初始时间层 $t_0=0$ 和 $t_1=\\Delta t$ 的解。\n在 $t_0=0$ 时，位移由初始条件给出：\n$$\nu_j^0 = u(x_j, 0) = A \\exp\\!\\left(-\\frac{(x_j - x_0)^2}{2\\sigma^2}\\right)\n$$\n为了找到在 $t_1=\\Delta t$ 时的位移，我们使用初始速度条件 $\\frac{\\partial u}{\\partial t}(x,0) = 0$。在 $t=0$ 处用中心差分近似该条件，$\\frac{u_j^1 - u_j^{-1}}{2\\Delta t} = 0$，意味着 $u_j^{-1} = u_j^1$。将此代入 $n=0$ 的通用更新规则：\n$$\nu_j^1 = 2(1-r^2)u_j^0 + r^2(u_{j+1}^0 + u_{j-1}^0) - u_j^1\n$$\n解出 $u_j^1$ 得到特殊的第一步公式：\n$$\nu_j^1 = (1-r^2)u_j^0 + \\frac{r^2}{2}(u_{j+1}^0 + u_{j-1}^0)\n$$\n固定边界条件 $u(0,t)=0$，$u(L,t)=0$ 和内部约束 $u(a,t)=0$ 在每个时间步都强制执行。设 $j_a=a/\\Delta x$ 是对应于内部约束的整数索引。那么对于所有时间层 $n$：\n$$\nu_0^n = 0, \\quad u_N^n = 0, \\quad u_{j_a}^n = 0\n$$\n这些约束在计算初始条件后立即应用，并在每个时间步更新结束时应用。\n\n数值算法如下：\n1.  为一个给定的测试用例初始化参数：$N, r, a, T_f, x_{\\text{obs}}$ 以及全局常量 $L, c, A, x_0, \\sigma$。\n2.  计算离散化步长 $\\Delta x = L/N$ 和 $\\Delta t = r \\Delta x / c$，以及总时间步数 $M = T_f/\\Delta t$。\n3.  创建三个数组来存储在时间 $n-1$、$n$ 和 $n+1$ 的解，记为 `u_prev`、`u_curr` 和 `u_next`。\n4.  使用给定的高斯函数计算初始位移 `u_prev`（在 $t=0$ 时）。\n5.  对 `u_prev` 应用固定约束：$u_0^0=0$, $u_N^0=0$, $u_{j_a}^0=0$。\n6.  使用从零速度初始条件导出的特殊第一步公式计算第一个时间步的 `u_curr`（在 $t=\\Delta t$ 时）。应用约束。\n7.  从 $n=1$ 迭代到 $M-1$：\n    a. 使用通用的蛙跳更新规则，根据 `u_curr`（在 $t_n$ 时）和 `u_prev`（在 $t_{n-1}$ 时）计算 `u_next`（在 $t_{n+1}$ 时）。\n    b. 应用固定约束：$u_0^{n+1}=0$, $u_N^{n+1}=0$, $u_{j_a}^{n+1}=0$。\n    c. 为下一次迭代更新数组（例如，`u_prev, u_curr = u_curr, u_next`）。\n8.  经过 $M$ 步后，数组 `u_curr` 包含最终的位移分布 $u(x_j, T_f)$。\n9.  根据这个最终分布，计算所需的量：\n    - 观测点处的位移：$u(x_{\\text{obs}}, T_f) = u_{j_{\\text{obs}}}^M$。\n    - 离散 $\\ell^2$ 范数：$\\|u(\\cdot, T_f)\\|_2 = \\sqrt{\\sum_{j=0}^{N} (u_j^M)^2 \\Delta x}$。\n    - 最大绝对位移：$\\max_{j} |u_j^M|$。\n\n将此过程系统地应用于每个测试用例，以生成最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D wave equation with an internal constraint for a suite of test cases.\n    \"\"\"\n    \n    # Test suite: each entry is a tuple of (N, r, a, Tf, x_obs)\n    test_cases = [\n        (400, 0.9, 0.5, 0.45, 0.75),\n        (400, 1.0, 0.25, 0.50, 0.60),\n        (80, 0.9, 0.5, 0.45, 0.625),\n        (500, 0.9, 0.02, 0.54, 0.60),\n    ]\n\n    # Common physical parameters for all cases\n    L = 1.0       # m, String length\n    c = 1.0       # m/s, Wave speed\n    A = 1.0e-3    # m, Pulse amplitude\n    x0 = 0.25     # m, Pulse center\n    sigma = 0.03  # m, Pulse width\n\n    all_results = []\n    \n    for case in test_cases:\n        N, r, a, Tf, x_obs = case\n        \n        # Discretization parameters\n        dx = L / N\n        dt = r * dx / c\n        # The number of steps M is guaranteed to be an integer per problem statement\n        M = int(round(Tf / dt))\n\n        # Spatial grid and node indices for constraints/observation\n        x = np.linspace(0, L, N + 1)\n        j_a = int(round(a / dx))\n        j_obs = int(round(x_obs / dx))\n        \n        # Initialize arrays for solution at time steps n-1 and n\n        u_prev = np.zeros(N + 1)\n        u_curr = np.zeros(N + 1)\n        \n        # Set u_prev to initial displacement u(x, 0)\n        u_prev[:] = A * np.exp(-(x - x0)**2 / (2 * sigma**2))\n        \n        # Apply boundary and internal constraints at t=0\n        u_prev[0] = 0.0\n        u_prev[N] = 0.0\n        u_prev[j_a] = 0.0\n        \n        # Calculate u_curr for the first time step u(x, dt) using du/dt(x,0)=0\n        u_curr[1:-1] = ( (1 - r**2) * u_prev[1:-1] \n                       + 0.5 * r**2 * (u_prev[2:] + u_prev[:-2]) )\n        \n        # Apply constraints at t=dt\n        u_curr[0] = 0.0\n        u_curr[N] = 0.0\n        u_curr[j_a] = 0.0\n\n        # Handle trivial cases M=0 or M=1\n        if M == 0:\n            final_u = u_prev\n        elif M == 1:\n            final_u = u_curr\n        else:\n            # Main time-stepping loop (Verlet/leapfrog integration)\n            # Loop for n = 1 to M-1 to compute solutions up to t = M*dt\n            for _ in range(1, M):\n                # Calculate the next state u_next using values from u_curr and u_prev\n                # The update is performed only on interior points\n                u_next_interior = (2.0 * (1.0 - r**2) * u_curr[1:-1]\n                                   + r**2 * (u_curr[2:] + u_curr[:-2])\n                                   - u_prev[1:-1])\n                \n                # Update history: the current state becomes the previous one\n                u_prev = u_curr\n                \n                # The next state becomes the current one. A new array is allocated.\n                u_curr = np.zeros(N + 1)\n                u_curr[1:-1] = u_next_interior\n                # The internal constraint must be re-applied to the new u_curr\n                u_curr[j_a] = 0.0\n            \n            final_u = u_curr\n\n        # Calculate required quantities from the final displacement profile\n        u_at_obs = final_u[j_obs]\n        l2_norm = np.sqrt(np.sum(final_u**2) * dx)\n        max_abs_u = np.max(np.abs(final_u))\n        \n        all_results.extend([u_at_obs, l2_norm, max_abs_u])\n\n    # Format the final output list as a comma-separated string\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2449924"}, {"introduction": "在一维情况的基础上，我们现在进入二维空间，探索波在各向异性介质中的传播，其中波速依赖于方向。这个练习挑战你将 FDTD 算法扩展到二维网格，并考虑不同的波速 $c_x$ 和 $c_y$ 。本练习的一个关键部分是通过与已知的解析解进行比较来验证你模拟的准确性，这是可靠的科学计算的基石。[@problem_id:2449882]", "problem": "设计并实现一个完整的程序，该程序需数值近似求解具有各向异性波速的二维波动方程，并对于多组参数集，在指定的最终时间点，将其解与相应的精确解进行定量比较。控制性偏微分方程为\n$$\n\\frac{\\partial^2 u}{\\partial t^2}(x,y,t) = c_x^2 \\,\\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + c_y^2 \\,\\frac{\\partial^2 u}{\\partial y^2}(x,y,t),\n$$\n在矩形空间域 $[0,L_x]\\times[0,L_y]$ 上，时间 $t\\in[0,T]$，并采用齐次狄利克雷边界条件\n$$\nu(0,y,t)=u(L_x,y,t)=u(x,0,t)=u(x,L_y,t)=0,\n$$\n以及可分离初始条件\n$$\nu(x,y,0)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big),\\qquad\n\\frac{\\partial u}{\\partial t}(x,y,0)=0.\n$$\n此处，$u$ 是无量纲的，$x$ 和 $y$ 的单位是米，$t$ 的单位是秒，$c_x$ 和 $c_y$ 的单位是米/秒，而 $L_x$、$L_y$、$T$ 的单位分别是米和秒。与上述条件一致的精确解为\n$$\nu_{\\text{exact}}(x,y,t)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big)\\,\\cos(\\omega t),\n\\quad\n\\omega=\\sqrt{c_x^2\\Big(\\frac{m\\pi}{L_x}\\Big)^2 + c_y^2\\Big(\\frac{n\\pi}{L_y}\\Big)^2 }.\n$$\n使用一个在每个空间方向上包含边界的 $N_x\\times N_y$ 点的均匀网格，其间距为 $\\Delta x=L_x/(N_x-1)$ 和 $\\Delta y=L_y/(N_y-1)$，并以恒定时间步长 $\\Delta t$ 进行时间演化，总共 $N=\\operatorname{round}(T/\\Delta t)$ 步。通过在相同网格上对 $u_{\\text{exact}}$ 进行采样，并计算所有网格点上的最大绝对差，来评估在 $t_N=N\\,\\Delta t$ 时的误差。对于下述每个测试用例，将此最大绝对误差作为一个无量纲实数报告。\n\n您的程序必须对以下三个测试用例分别进行实现，并按照“最终输出格式”下的规定，将三个产生的误差聚合到单行输出中。所有输入均应视为国际单位制（SI），即米和秒。误差值本身是无量纲的。\n\n测试套件 (每行指定 $\\{L_x,L_y,c_x,c_y,m,n,N_x,N_y,\\Delta t,T\\}$):\n- 用例 A: $\\{\\,1.0,\\,1.0,\\,1.0,\\,2.0,\\,1,\\,1,\\,81,\\,81,\\,0.005,\\,0.5\\,\\}$\n- 用例 B: $\\{\\,1.0,\\,1.0,\\,0.5,\\,3.0,\\,2,\\,3,\\,101,\\,71,\\,0.0042,\\,0.28\\,\\}$\n- 用例 C: $\\{\\,1.0,\\,1.0,\\,2.0,\\,2.5,\\,3,\\,1,\\,65,\\,65,\\,0.0047,\\,0.235\\,\\}$\n\n最终输出格式：您的程序应生成单行输出，其中包含三个用例（按 A、B、C 顺序排列）的误差值，形式为用方括号括起来的逗号分隔列表，例如，\n$$\n[\\varepsilon_A,\\varepsilon_B,\\varepsilon_C],\n$$\n其中每个 $\\varepsilon$ 是一个实数。", "solution": "在尝试求解之前，对问题陈述进行分析以验证其有效性。\n\n首先，逐字提取所有给定的数据和条件。\n控制方程：\n$$\n\\frac{\\partial^2 u}{\\partial t^2}(x,y,t) = c_x^2 \\,\\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + c_y^2 \\,\\frac{\\partial^2 u}{\\partial y^2}(x,y,t)\n$$\n定义域：$x \\in [0,L_x]$, $y \\in [0,L_y]$, $t \\in [0,T]$。\n边界条件（齐次狄利克雷）：\n$$\nu(0,y,t)=u(L_x,y,t)=u(x,0,t)=u(x,L_y,t)=0\n$$\n初始条件：\n$$\nu(x,y,0)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big),\\qquad \\frac{\\partial u}{\\partial t}(x,y,0)=0\n$$\n精确解：\n$$\nu_{\\text{exact}}(x,y,t)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big)\\,\\cos(\\omega t),\n\\quad\n\\omega=\\sqrt{c_x^2\\Big(\\frac{m\\pi}{L_x}\\Big)^2 + c_y^2\\Big(\\frac{n\\pi}{L_y}\\Big)^2 }\n$$\n数值网格：\n$N_x \\times N_y$ 个点；$\\Delta x=L_x/(N_x-1)$，$\\Delta y=L_y/(N_y-1)$；$\\Delta t$ 是时间步长。\n步数：$N=\\operatorname{round}(T/\\Delta t)$。\n误差度量：在 $t_N = N \\Delta t$ 时，数值解与精确解之间的最大绝对差。\n测试用例：\n- 用例 A: $\\{L_x=1.0,\\,L_y=1.0,\\,c_x=1.0,\\,c_y=2.0,\\,m=1,\\,n=1,\\,N_x=81,\\,N_y=81,\\,\\Delta t=0.005,\\,T=0.5\\}$\n- 用例 B: $\\{L_x=1.0,\\,L_y=1.0,\\,c_x=0.5,\\,c_y=3.0,\\,m=2,\\,n=3,\\,N_x=101,\\,N_y=71,\\,\\Delta t=0.0042,\\,T=0.28\\}$\n- 用例 C: $\\{L_x=1.0,\\,L_y=1.0,\\,c_x=2.0,\\,c_y=2.5,\\,m=3,\\,n=1,\\,N_x=65,\\,N_y=65,\\,\\Delta t=0.0047,\\,T=0.235\\}$\n\n接下来，根据形式化标准对该问题进行验证。\n1.  **科学依据**：该问题描述了具有各向异性波速的二维线性波动方程，这是物理学中的一个基本模型。所提供的初始条件和边界条件是标准的。通过代入偏微分方程并检查初始和边界条件，可以轻松验证给定的精确解。该问题在数学上和科学上都是合理的。\n2.  **适定性**：该问题是双曲型偏微分方程的一个经典初边值问题。对于给定的光滑初始数据和狄利克雷边界条件，可以保证解的唯一性和稳定性。数值计算任务也得到了精确定义。\n3.  **客观性**：问题以定量的、无歧义的语言陈述。所有参数均已定义。\n4.  **完整性与一致性**：为每个测试用例提供了所有必需的信息。\n5.  **可行性**：数值模拟的参数必须满足显式有限差分格式的 Courant-Friedrichs-Lewy (CFL) 稳定性条件。对于二维各向异性波动方程，该条件为 $S = \\Delta t \\sqrt{ (c_x/\\Delta x)^2 + (c_y/\\Delta y)^2 } \\leq 1$。我们对每个用例进行检查：\n    - 用例 A: $\\Delta x = 1/(80)$, $\\Delta y = 1/(80)$。$S = 0.005 \\sqrt{(1.0/(1/80))^2 + (2.0/(1/80))^2} = 0.005 \\sqrt{80^2 + 160^2} \\approx 0.894 < 1$。稳定。\n    - 用例 B: $\\Delta x = 1/(100)$, $\\Delta y = 1/(70)$。$S = 0.0042 \\sqrt{(0.5/(1/100))^2 + (3.0/(1/70))^2} = 0.0042 \\sqrt{50^2 + 210^2} \\approx 0.907 < 1$。稳定。\n    - 用例 C: $\\Delta x = 1/(64)$, $\\Delta y = 1/(64)$。$S = 0.0047 \\sqrt{(2.0/(1/64))^2 + (2.5/(1/64))^2} = 0.0047 \\sqrt{128^2 + 160^2} \\approx 0.963 < 1$。稳定。\n所有测试用例使用的参数都能确保数值格式的稳定性。\n\n结论：该问题有效。它是一个定义明确、科学合理且数值上可行的问题。我们继续进行求解。\n\n本解答采用时域有限差分（FDTD）方法构建。我们将空间域离散化为网格 $\\{ (x_i, y_j) | x_i = i\\Delta x, y_j = j\\Delta y \\}$，其中 $i \\in \\{0, ..., N_x-1\\}$，$j \\in \\{0, ..., N_y-1\\}$，时间离散化为 $t_k = k\\Delta t$。令 $u_{i,j}^k$ 为 $u(x_i, y_j, t_k)$ 的数值近似。\n\n二阶偏导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial t^2}\\Bigg|_{i,j,k} \\approx \\frac{u_{i,j}^{k+1} - 2u_{i,j}^k + u_{i,j}^{k-1}}{(\\Delta t)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\Bigg|_{i,j,k} \\approx \\frac{u_{i+1,j}^k - 2u_{i,j}^k + u_{i-1,j}^k}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\Bigg|_{i,j,k} \\approx \\frac{u_{i,j+1}^k - 2u_{i,j}^k + u_{i,j-1}^k}{(\\Delta y)^2}\n$$\n将这些近似代入控制偏微分方程，得到显式更新格式。对于所有内部网格点 $(i,j)$，其中 $1 \\leq i \\leq N_x-2$ 且 $1 \\leq j \\leq N_y-2$：\n$$\n\\frac{u_{i,j}^{k+1} - 2u_{i,j}^k + u_{i,j}^{k-1}}{(\\Delta t)^2} = c_x^2 \\frac{u_{i+1,j}^k - 2u_{i,j}^k + u_{i-1,j}^k}{(\\Delta x)^2} + c_y^2 \\frac{u_{i,j+1}^k - 2u_{i,j}^k + u_{i,j-1}^k}{(\\Delta y)^2}\n$$\n对 $u_{i,j}^{k+1}$ 求解，我们得到三层时间步进格式：\n$$\nu_{i,j}^{k+1} = 2u_{i,j}^k - u_{i,j}^{k-1} + \\left(\\frac{c_x \\Delta t}{\\Delta x}\\right)^2(u_{i+1,j}^k - 2u_{i,j}^k + u_{i-1,j}^k) + \\left(\\frac{c_y \\Delta t}{\\Delta y}\\right)^2(u_{i,j+1}^k - 2u_{i,j}^k + u_{i,j-1}^k)\n$$\n此公式根据第 $k$ 步和第 $k-1$ 步的解来计算第 $k+1$ 时间步的解。此公式适用于 $k \\geq 1$。\n\n对于第一个时间步（$k=0$），我们必须使用初始条件。状态 $u_{i,j}^0$ 由 $u(x_i, y_j, 0)$ 给出。为了求解 $u_{i,j}^1$，我们需要虚拟状态 $u_{i,j}^{-1}$。这可以通过对初始速度条件 $\\frac{\\partial u}{\\partial t}(x,y,0)=0$ 使用中心差分进行离散化来获得：\n$$\n\\frac{\\partial u}{\\partial t}\\Bigg|_{i,j,0} \\approx \\frac{u_{i,j}^1 - u_{i,j}^{-1}}{2\\Delta t} = 0 \\implies u_{i,j}^{-1} = u_{i,j}^1\n$$\n将 $u_{i,j}^{-1} = u_{i,j}^1$ 代入 $k=0$ 时的通用更新公式：\n$$\nu_{i,j}^1 = 2u_{i,j}^0 - u_{i,j}^1 + (\\Delta t)^2 \\left[ c_x^2 \\frac{u_{i+1,j}^0 - 2u_{i,j}^0 + u_{i-1,j}^0}{\\Delta x^2} + c_y^2 \\frac{u_{i,j+1}^0 - 2u_{i,j}^0 + u_{i,j-1}^0}{\\Delta y^2} \\right]\n$$\n对 $u_{i,j}^1$ 求解，得到用于第一步的两层格式：\n$$\nu_{i,j}^1 = u_{i,j}^0 + \\frac{(\\Delta t)^2}{2} \\left[ c_x^2 \\frac{u_{i+1,j}^0 - 2u_{i,j}^0 + u_{i-1,j}^0}{\\Delta x^2} + c_y^2 \\frac{u_{i,j+1}^0 - 2u_{i,j}^0 + u_{i,j-1}^0}{\\Delta y^2} \\right]\n$$\n通过在所有时间步将数值网格边界上的值设置为零来施加齐次狄利克雷边界条件 $u=0$。\n\n总体算法如下：\n1.  初始化参数并创建空间网格。\n2.  计算 $t=0$ 时的初始状态 $u^0$。该数组将代表“前一”时间步的解，$u_{\\text{prev}}$。\n3.  使用特殊的第一步公式计算 $t=\\Delta t$ 时的状态 $u^1$。该数组代表“当前”解，$u_{\\text{curr}}$。\n4.  从 $k=1$ 迭代到 $N-1$：\n    a. 使用通用的三层更新公式，根据 $u_{\\text{curr}} (= u^k)$ 和 $u_{\\text{prev}} (= u^{k-1})$ 计算下一个状态 $u^{k+1}$。\n    b. 为下一次迭代更新状态数组：$u_{\\text{prev}}$ 变为 $u_{\\text{curr}}$，而 $u_{\\text{curr}}$ 变为新计算的 $u^{k+1}$。通过高效管理来避免重复的内存分配。\n5.  经过 $N$ 步后，数组 $u_{\\text{curr}}$ 保存了在最终时间 $t_N = N \\Delta t$ 时的数值解。\n6.  在同一网格上计算 $t_N$ 时的精确解。\n7.  通过在整个网格上逐点比较数值解和精确解，计算最大绝对误差。\n\n对每个测试用例执行此过程。为提高效率，使用了 NumPy 的向量化数组操作。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (Lx, Ly, cx, cy, m, n, Nx, Ny, dt, T)\n        (1.0, 1.0, 1.0, 2.0, 1, 1, 81, 81, 0.005, 0.5),   # Case A\n        (1.0, 1.0, 0.5, 3.0, 2, 3, 101, 71, 0.0042, 0.28), # Case B\n        (1.0, 1.0, 2.0, 2.5, 3, 1, 65, 65, 0.0047, 0.235), # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        error = solve_wave_equation_2d(*params)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_wave_equation_2d(Lx, Ly, cx, cy, m, n, Nx, Ny, dt, T):\n    \"\"\"\n    Numerically solves the 2D anisotropic wave equation for a single test case.\n\n    Implements a finite-difference time-domain (FDTD) scheme with second-order\n    central differences in space and time.\n    \"\"\"\n    # 1. Grid and parameter setup\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    \n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    # 'ij' indexing ensures X.shape is (Nx, Ny) and corresponds to u[i, j]\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Initial conditions\n    # u_prev stores the solution at the previous time step (k-1)\n    # u_curr stores the solution at the current time step (k)\n    \n    # Initialize u_prev to u(t=0)\n    u_prev = np.sin(m * np.pi * X / Lx) * np.sin(n * np.pi * Y / Ly)\n    \n    # Initialize u_curr to zeros, which respects boundary conditions\n    u_curr = np.zeros_like(u_prev)\n\n    # 3. Calculate first time step (t=dt) using special update rule\n    # This is a discrete version of the spatial operator L(u)\n    lap_u0 = (cx**2 * (u_prev[0:-2, 1:-1] - 2*u_prev[1:-1, 1:-1] + u_prev[2:, 1:-1]) / dx**2 +\n              cy**2 * (u_prev[1:-1, 0:-2] - 2*u_prev[1:-1, 1:-1] + u_prev[1:-1, 2:]) / dy**2)\n    \n    # Update interior points for u(t=dt)\n    u_curr[1:-1, 1:-1] = u_prev[1:-1, 1:-1] + 0.5 * dt**2 * lap_u0\n\n    # 4. Time-stepping loop\n    num_steps = round(T / dt)\n    # Loop from k=1 up to num_steps-1 to calculate u^2, u^3, ..., u^N\n    for _ in range(1, num_steps):\n        # Calculate Laplacian of the current state u_curr\n        lap_uk = (cx**2 * (u_curr[0:-2, 1:-1] - 2*u_curr[1:-1, 1:-1] + u_curr[2:, 1:-1]) / dx**2 +\n                  cy**2 * (u_curr[1:-1, 0:-2] - 2*u_curr[1:-1, 1:-1] + u_curr[1:-1, 2:]) / dy**2)\n        \n        # Calculate the interior of the next state u_next using the general update rule\n        u_next_interior = (2.0 * u_curr[1:-1, 1:-1] - u_prev[1:-1, 1:-1] + dt**2 * lap_uk)\n        \n        # Swap arrays to advance time, reusing memory\n        # u_prev will now hold u_curr's data\n        # u_curr will be overwritten with u_next's data\n        u_prev, u_curr = u_curr, u_prev\n        u_curr[1:-1, 1:-1] = u_next_interior\n\n    # 5. Final time and exact solution\n    final_time = num_steps * dt\n    omega = np.sqrt(cx**2 * (m * np.pi / Lx)**2 + cy**2 * (n * np.pi / Ly)**2)\n    \n    u_exact = (np.sin(m * np.pi * X / Lx) * \n               np.sin(n * np.pi * Y / Ly) * \n               np.cos(omega * final_time))\n    \n    # 6. Calculate and return final error\n    # The error is the maximum absolute difference over all grid points.\n    error = np.max(np.abs(u_curr - u_exact))\n    \n    return error\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2449882"}, {"introduction": "我们最后的实践将这些数值技能应用于一个真实场景：室内声学。你将模拟一个声脉冲在二维房间中的传播，以识别其共振频率，即“房间模式”。这个综合性练习涉及实现诺伊曼（Neumann）边界条件来模拟反射墙，并使用快速傅里叶变换（FFT）来分析时域数据，从而填合数值模拟与物理解释之间的鸿沟。[@problem_id:2449910]", "problem": "考虑一个由线性波动方程描述的二维标量声压场\n$$\n\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right),\n$$\n其定义域为一个矩形区域 $$0 \\le x \\le L_x$$ 和 $$0 \\le y \\le L_y$$，边界为刚性壁，因此压力在边界上的外法向导数为零，\n$$\n\\left.\\frac{\\partial p}{\\partial n}\\right|_{\\partial \\Omega} = 0,\n$$\n即诺伊曼（Neumann）边界条件。设 $$c$$ 为恒定的声速，单位为米/秒。您将使用时间和空间上均为二阶精度的中心差分格式，在 $$\\Delta x = \\Delta y$$ 的均匀笛卡尔网格上对时间演化进行数值模拟。设 $$\\Delta t$$ 为时间步长。该格式必须满足适用于二维等间距空间的 Courant–Friedrichs–Lewy (CFL) 稳定性约束。初始状态为静止，声场由在第一个时间步施加于某个内部网格节点上的单个脉冲源激发。位于另一内部网格节点的接收器记录压力时间序列。不使用物理阻尼。\n\n您的任务是实现一个完整的程序，该程序：\n- 使用时间和空间上的二阶中心差分法离散波动方程。\n- 在所有四个壁上实施与离散化方法一致的 $$p$$ 的诺伊曼（Neumann）边界条件。\n- 使用均匀的空间步长 $$\\Delta x = \\Delta y$$。\n- 通过满足二维稳定性约束的库朗数（Courant number）$$s$$ 来选择时间步长 $$\\Delta t$$，其中 $$\\Delta t = s \\, \\Delta x / c$$。\n- 在时间索引 $$n=0$$ 时，在源网格节点注入一个单位脉冲源，并在指定的总仿真时间 $$T$$ 内记录接收器网格节点的压力。\n- 通过计算所记录时间序列的离散傅里叶变换幅值，并针对三个解析上最低的非零模式，在相应解析频率周围的窄频率窗口中搜索主导谱峰，从而估计三个最低的驻波模式频率（单位为赫兹）。\n\n仅使用以下基础知识：\n- 上述标量波动方程以及矩形区域上诺伊曼（Neumann）边界条件的定义。\n- 二维均匀网格上用于一阶和二阶导数的中心差分近似。\n- 多维显式双曲格式的稳定性约束概念。\n- 矩形刚性壁腔（诺伊曼边界条件）的解析非零本征频率由下式给出\n$$\nf_{m,n} = \\frac{c}{2}\\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2},\n$$\n其中 $$m,n$$ 为非负整数且不全为零，排除了 $$f_{0,0}=0$$。当 $$L_x=L_y$$ 时可能出现简并。\n\n您必须遵守的数值细节：\n- 使用 $$\\Delta x$$ 单位为米，$$\\Delta t$$ 单位为秒，$$c$$ 单位为米/秒，长度 $$L_x, L_y$$ 单位为米，总时间 $$T$$ 单位为秒。频率必须以赫兹为单位报告。\n- 选择库朗数 $$s$$，使得显式格式在二维且 $$\\Delta x = \\Delta y$$ 的情况下是稳定的。\n- 为稳健地估计模态频率，在计算离散傅里叶变换之前，对记录的时间序列应用汉宁窗（Hann window）。在加窗前移除记录信号的均值以抑制零频分量。当搜索与给定解析频率 $$f_{m,n}$$ 对应的测量频率时，应在以 $$f_{m,n}$$ 为中心、宽度设为 $$5\\ \\text{Hz}$$ 或 $$0.15 f_{m,n}$$ 中较大者的对称窗口内搜索最大幅值的谱线，该窗口被限制在总体分析频带内。\n- 将所有最终频率误差表示为绝对相对误差，即 $$\\left| \\hat{f} - f \\right| / f$$，以无单位的小数形式表示。\n\n测试套件：\n对以下三个测试用例运行您的程序。在所有用例中，设置 $$c = 343\\ \\text{m/s}$$，$$\\Delta x = \\Delta y = 0.1\\ \\text{m}$$，库朗数 $$s = 0.5$$（因此 $$\\Delta t = s \\Delta x / c$$），总仿真时间 $$T = 1.6\\ \\text{s}$$。将脉冲源放置在 $$x_s = 0.37 L_x$$、$$y_s = 0.41 L_y$$ 处，接收器放置在 $$x_r = 0.23 L_x$$、$$y_r = 0.67 L_y$$ 处，两者都对齐到最近的网格节点。使用 $$20\\ \\text{Hz} \\le f \\le 300\\ \\text{Hz}$$ 的分析频带。\n- 用例 1 (通用矩形房间): $$L_x = 3.0\\ \\text{m}$$, $$L_y = 4.0\\ \\text{m}$$。\n- 用例 2 (方形房间): $$L_x = 2.0\\ \\text{m}$$, $$L_y = 2.0\\ \\text{m}$$。\n- 用例 3 (狭长房间): $$L_x = 5.0\\ \\text{m}$$, $$L_y = 2.0\\ \\text{m}$$。\n\n对于每个用例，计算三个最低的非零解析模态频率 $$f_{m,n}$$，按照描述从模拟频谱中识别出它们对应的测量值，并报告三个绝对相对误差（以小数形式）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含九个结果（按用例 1、用例 2、用例 3的顺序，每个用例三个结果），形式为方括号内以逗号分隔的列表（例如，“[r1,r2,r3,r4,r5,r6,r7,r8,r9]”）。每个条目必须是一个十进制数。", "solution": "问题陈述已经过评估，被认为是科学上合理、适定且完整的。它描述了计算声学中的一个标准问题：在封闭的二维域中模拟波的传播，并随后分析其共振频率。我们接下来将进行解法的推导和实现。\n\n控制方程是声压 $$p(x,y,t)$$ 的二维线性标量波动方程：\n$$\n\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right) = c^2 \\nabla^2 p\n$$\n其中 $$c$$ 是恒定的声速。该问题将使用时域有限差分（FDTD）方法在均匀的笛卡尔网格上进行数值求解。\n\n设离散压力场表示为 $$p_{i,j}^n \\approx p(i\\Delta x, j\\Delta y, n\\Delta t)$$，其中 $$i, j, n$$ 是空间和时间的整数索引，$$\\Delta x, \\Delta y, \\Delta t$$ 是对应的步长。题目给定 $$\\Delta x = \\Delta y$$。\n\n我们使用二阶精度的中心差分近似来离散偏导数：\n$$\n\\frac{\\partial^2 p}{\\partial t^2} \\approx \\frac{p_{i,j}^{n+1} - 2p_{i,j}^n + p_{i,j}^{n-1}}{(\\Delta t)^2}\n$$\n$$\n\\nabla^2 p \\approx \\frac{p_{i+1,j}^n - 2p_{i,j}^n + p_{i-1,j}^n}{(\\Delta x)^2} + \\frac{p_{i,j+1}^n - 2p_{i,j}^n + p_{i,j-1}^n}{(\\Delta y)^2}\n$$\n将这些近似代入波动方程，并注意到 $$\\Delta x = \\Delta y$$，我们得到离散更新方程：\n$$\n\\frac{p_{i,j}^{n+1} - 2p_{i,j}^n + p_{i,j}^{n-1}}{(\\Delta t)^2} = c^2 \\left( \\frac{p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - 4p_{i,j}^n}{(\\Delta x)^2} \\right)\n$$\n求解下一个时间步的压力 $$p_{i,j}^{n+1}$$，得到显式 FDTD 格式：\n$$\np_{i,j}^{n+1} = 2p_{i,j}^n - p_{i,j}^{n-1} + \\left(\\frac{c\\Delta t}{\\Delta x}\\right)^2 \\left( p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - 4p_{i,j}^n \\right)\n$$\n量 $$s = c\\Delta t/\\Delta x$$ 是库朗数（Courant number）。更新方程则为：\n$$\np_{i,j}^{n+1} = 2p_{i,j}^n - p_{i,j}^{n-1} + s^2 \\left( p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - 4p_{i,j}^n \\right)\n$$\n为使该显式格式在二维且 $$\\Delta x = \\Delta y$$ 的情况下数值稳定，库朗数 $$s$$ 必须满足 Courant–Friedrichs–Lewy (CFL) 条件：\n$$\ns \\le \\frac{1}{\\sqrt{2}} \\approx 0.7071\n$$\n指定的库朗数 $$s = 0.5$$ 符合此条件，确保了稳定性。\n\n仿真从静止状态开始，意味着初始条件为 $$p(x,y,0) = 0$$ 和 $$\\frac{\\partial p}{\\partial t}(x,y,0) = 0$$。离散形式为 $$p_{i,j}^0 = 0$$。零速度条件通过在 $$n=0$$ 处使用中心差分来离散时间导数实现：\n$$\n\\frac{p_{i,j}^1 - p_{i,j}^{-1}}{2\\Delta t} = 0 \\implies p_{i,j}^{-1} = p_{i,j}^1\n$$\n将 $$n=0$$ 代入更新方程并使用 $$p_{i,j}^{-1} = p_{i,j}^1$$，可以消除对虚拟时间层 $$n=-1$$ 的需求。然而，一个更简单的方法是初始化两个压力场 $$p^n$$ 和 $$p^{n-1}$$ 为零。脉冲源在第一个时间步 $$n=0$$ 时作为附加项引入。设源位于网格节点 $$(i_s, j_s)$$。$$p_{i,j}^1$$ 的更新方程包含一个源项，我们通过在第一次更新步骤中，在源位置处的压力场上增加一个与 $$\\Delta t$$ 成正比的值来对其建模。这修改了 $$p^1$$ 的计算：\n$$\np_{i_s,j_s}^1 = 2p_{i_s,j_s}^0 - p_{i_s,j_s}^{-1} + s^2(...)_{i_s,j_s}^0 + \\text{source} \\cdot \\delta_{n,0}\n$$\n在静止初始条件下，这简化了时间演化。源在时间索引 $$n=0$$ 时施加，影响时间索引 $$n=1$$ 的压力场计算。\n\n边界条件为刚性壁（诺伊曼）类型，即 $$\\partial p / \\partial n = 0$$，其中 $$\\mathbf{n}$$ 是向外的法向矢量。对于 $$x=0$$ 处的壁，条件为 $$\\partial p / \\partial x = 0$$。在边界节点 $$i=0$$ 处使用二阶中心差分对此条件进行离散化，得到：\n$$\n\\frac{p_{1,j}^n - p_{-1,j}^n}{2\\Delta x} = 0 \\implies p_{-1,j}^n = p_{1,j}^n\n$$\n其中 $$p_{-1,j}^n$$ 是域外“鬼点”（ghost point）处的压力。这个鬼点值用于边界点的主更新模板中。例如，在 $$i=0$$ 处，项 $$p_{i-1,j}^n$$ 变为 $$p_{1,j}^n$$。左壁上一点（$$i=0$$）的更新规则变为：\n$$\np_{0,j}^{n+1} = 2p_{0,j}^n - p_{0,j}^{n-1} + s^2 \\left( 2p_{1,j}^n + p_{0,j+1}^n + p_{0,j-1}^n - 4p_{0,j}^n \\right)\n$$\n类似的规则适用于其他三面墙和四个角点。一种系统化的实现方法是，在每次计算空间导数之前，用一层鬼单元（ghost cells）填充压力网格，并根据这些关系填充鬼单元的值。\n\n仿真通过迭代应用更新方程来进行，总时间步数为 $$N_t = \\lfloor T/\\Delta t \\rfloor$$。在每一步，记录接收器位置 $$(i_r, j_r)$$ 的压力，形成一个时间序列。\n\n对于频率分析，首先对记录的时间序列进行处理，移除其均值以消除直流（DC）分量。然后，应用汉宁窗（Hann window）以减少频谱泄漏。使用快速傅里叶变换（FFT）算法计算加窗信号的离散傅里叶变换（DFT），从而得到幅值谱。\n\n给定域和诺伊曼（Neumann）边界条件下的解析本征频率为：\n$$\nf_{m,n} = \\frac{c}{2}\\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2}\n$$\n其中 $$m, n$$ 是非负整数，且不全为零。对于每个测试用例，我们计算三个最低的、不相同的非零解析频率。\n\n对于每个解析频率 $$f_{\\text{anal}}$$，我们在计算出的频谱中搜索其对应的测量值 $$\\hat{f}_{\\text{meas}}$$。搜索在一个以 $$f_{\\text{anal}}$$ 为中心、宽度为 $$\\max(5 \\text{ Hz}, 0.15 f_{\\text{anal}})$$ 的频率窗口内进行。该窗口被限制在指定的分析频带 $$[20 \\text{ Hz}, 300 \\text{ Hz}]$$ 内。此搜索窗口内最大幅值峰值对应的频率即为 $$\\hat{f}_{\\text{meas}}$$。\n\n最后，每个模态频率的绝对相对误差计算如下：\n$$\n\\text{Error} = \\frac{|\\hat{f}_{\\text{meas}} - f_{\\text{anal}}|}{f_{\\text{anal}}}\n$$\n对所有三个测试用例重复此过程，并报告所得的九个误差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Lx, Ly)\n        (3.0, 4.0),  # Case 1\n        (2.0, 2.0),  # Case 2\n        (5.0, 2.0),  # Case 3\n    ]\n\n    all_results = []\n    for Lx, Ly in test_cases:\n        errors = run_simulation_and_analyze(Lx, Ly)\n        all_results.extend(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in all_results)}]\")\n\ndef run_simulation_and_analyze(Lx, Ly):\n    \"\"\"\n    Runs the FDTD simulation for a given geometry and analyzes the results.\n    Returns a list of three relative frequency errors.\n    \"\"\"\n    # --- 1. Simulation Setup ---\n\n    # Constants and parameters\n    c = 343.0      # Speed of sound (m/s)\n    dx = 0.1       # Spatial step (m), dy = dx\n    s = 0.5        # Courant number\n    T = 1.6        # Total simulation time (s)\n\n    # Derived parameters\n    dt = s * dx / c\n    Nx = int(round(Lx / dx)) + 1\n    Ny = int(round(Ly / dx)) + 1\n    Nt = int(np.floor(T / dt))\n\n    # Effective dimensions based on grid\n    Lx_eff = (Nx - 1) * dx\n    Ly_eff = (Ny - 1) * dx\n\n    # Source and receiver locations (snapped to grid)\n    xs_frac, ys_frac = 0.37, 0.41\n    xr_frac, yr_frac = 0.23, 0.67\n    is_ = int(round(xs_frac * (Nx - 1)))\n    js_ = int(round(ys_frac * (Ny - 1)))\n    ir_ = int(round(xr_frac * (Nx - 1)))\n    jr_ = int(round(yr_frac * (Ny - 1)))\n    \n    # Pressure fields (current, previous)\n    p_now = np.zeros((Nx, Ny), dtype=np.float64)\n    p_prev = np.zeros((Nx, Ny), dtype=np.float64)\n    \n    receiver_signal = np.zeros(Nt, dtype=np.float64)\n    s2 = s**2\n\n    # --- 2. FDTD Simulation Loop ---\n    \n    p_padded = np.zeros((Nx + 2, Ny + 2), dtype=np.float64)\n\n    for n in range(Nt):\n        # Apply Neumann boundary conditions using ghost cells\n        p_padded[1:-1, 1:-1] = p_now\n        \n        # Walls\n        p_padded[0, 1:-1] = p_padded[2, 1:-1]      # x=0\n        p_padded[-1, 1:-1] = p_padded[-3, 1:-1]    # x=Lx\n        p_padded[1:-1, 0] = p_padded[1:-1, 2]      # y=0\n        p_padded[1:-1, -1] = p_padded[1:-1, -3]    # y=Ly\n\n        # Corners\n        p_padded[0, 0] = p_padded[2, 2]\n        p_padded[-1, 0] = p_padded[-3, 2]\n        p_padded[0, -1] = p_padded[2, -3]\n        p_padded[-1, -1] = p_padded[-3, -3]\n\n        # Calculate Laplacian using the padded grid\n        laplacian = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] +\n                     p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - 4 * p_now)\n\n        # Update pressure field\n        p_next = 2 * p_now - p_prev + s2 * laplacian\n\n        # Inject impulsive source at n=0\n        if n == 0:\n            # Source is applied to affect the field at n=1\n            p_next[is_, js_] += dt\n\n        # Update fields for next iteration\n        p_prev, p_now = p_now, p_next\n\n        # Record pressure at receiver\n        receiver_signal[n] = p_now[ir_, jr_]\n\n    # --- 3. Frequency Analysis ---\n\n    # Signal processing\n    signal_proc = receiver_signal - np.mean(receiver_signal)\n    signal_win = signal_proc * np.hanning(Nt)\n\n    # FFT\n    yf = fft.rfft(signal_win)\n    xf = fft.rfftfreq(Nt, d=dt)\n    spectrum = np.abs(yf)\n\n    # Analysis band\n    analysis_f_min, analysis_f_max = 20.0, 300.0\n\n    # --- 4. Analytical Frequencies and Error Calculation ---\n\n    # Find the 3 lowest non-zero analytical frequencies\n    modes = []\n    max_m, max_n = 10, 10\n    for m in range(max_m):\n        for n in range(max_n):\n            if m == 0 and n == 0:\n                continue\n            freq = (c / 2.0) * np.sqrt((m / Lx_eff)**2 + (n / Ly_eff)**2)\n            if freq > 0:\n                modes.append({'m': m, 'n': n, 'freq': freq})\n    \n    # Sort by frequency, handling degeneracies\n    modes.sort(key=lambda x: x['freq'])\n    unique_freqs = []\n    seen_freqs = set()\n    for mode in modes:\n        f_rounded = round(mode['freq'], 4)\n        if f_rounded not in seen_freqs:\n            unique_freqs.append(mode['freq'])\n            seen_freqs.add(f_rounded)\n        if len(unique_freqs) >= 3:\n            break\n            \n    analytical_freqs = unique_freqs[:3]\n    \n    errors = []\n    for f_anal in analytical_freqs:\n        # Define search window for peak picking\n        search_width = max(5.0, 0.15 * f_anal)\n        search_min = f_anal - search_width / 2.0\n        search_max = f_anal + search_width / 2.0\n        \n        # Clamp to analysis band\n        clamped_search_min = max(analysis_f_min, search_min)\n        clamped_search_max = min(analysis_f_max, search_max)\n\n        # Find indices for the search window in the FFT frequency array\n        idx_low = np.searchsorted(xf, clamped_search_min, side='left')\n        idx_high = np.searchsorted(xf, clamped_search_max, side='right')\n\n        if idx_low >= idx_high: \n            # If window is empty or outside range, this indicates a problem\n            # But for this problem, modes are expected to be found\n            errors.append(1.0) # Maximum error\n            continue\n\n        # Find peak in the search window\n        peak_idx_local = np.argmax(spectrum[idx_low:idx_high])\n        peak_idx_global = idx_low + peak_idx_local\n        f_meas = xf[peak_idx_global]\n        \n        # Calculate relative error\n        rel_error = np.abs(f_meas - f_anal) / f_anal\n        errors.append(rel_error)\n\n    return errors\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2449910"}]}