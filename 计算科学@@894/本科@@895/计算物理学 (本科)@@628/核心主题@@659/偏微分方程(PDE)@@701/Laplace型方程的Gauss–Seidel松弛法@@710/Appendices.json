{"hands_on_practices": [{"introduction": "我们从一个经典的热传导问题开始，但增加了一点现实世界的复杂性。这个练习要求你计算一个矩形板上的稳态温度分布，其中一些边缘是绝热的。要解决这个问题，你将学习如何使用“虚拟点”方法来实现诺伊曼边界条件（$\\frac{\\partial T}{\\partial n} = 0$），这是模拟具有绝热边界或对称面的物理系统时一项至关重要的技能 [@problem_id:2397045]。", "problem": "考虑一个矩形板上的稳态温度场，该温度场由标量场 $T(x,y)$ 描述，在域 $\\Omega = [0,L_x] \\times [0,L_y]$ 的内部满足拉普拉斯方程 $\\nabla^2 T = 0$。温度是无量纲的。板的边界 $\\partial \\Omega$ 可能具有固定温度（狄利克雷条件）或完美热绝缘（法向导数为零的诺伊曼条件）。一个在 $x$ 方向有 $N_x$ 个节点、在 $y$ 方向有 $N_y$ 个节点的均匀笛卡尔网格覆盖了整个矩形区域（包括其边界），网格间距为 $\\Delta x = L_x/(N_x - 1)$ 和 $\\Delta y = L_y/(N_y - 1)$。令 $T_{i,j}$ 表示网格节点 $(x_i,y_j)$ 处 $T$ 的离散近似值，其中 $x_i = i \\,\\Delta x$（$i = 0,1,\\dots,N_x-1$）且 $y_j = j \\,\\Delta y$（$j = 0,1,\\dots,N_y-1$）。\n\n您的任务是为下面指定的几种边值配置计算离散解 $T_{i,j}$，使得与 $\\nabla^2 T = 0$ 对应的离散方程在整个内部区域都在规定的容差范围内得到满足。离散五点拉普拉斯算子的解释应与施加在 $\\partial \\Omega$ 上的边界条件保持一致。对于位于狄利克雷条件边界上的节点，其值 $T_{i,j}$ 必须等于指定的边界值。对于邻近绝缘边界的节点，必须强制执行法向导数为零的条件，以使内部解在满足拉普拉斯方程的同时与该约束保持一致。数值解必须满足离散残差界\n$$\n\\max_{i,j \\text{ not Dirichlet}} \\left| \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{\\Delta x^2} + \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{\\Delta y^2} \\right| \\le \\varepsilon,\n$$\n其中，边界处的有限差分表达式必须与边界数据一致，且 $\\varepsilon$ 在每个测试用例中给出。\n\n对每个测试用例，您必须报告两个数字：\n- 标量值 $T_{\\mathrm{center}}$，定义为在最接近域几何中心的网格节点上计算出的温度。当 $N_x$ 和 $N_y$ 为奇数时，该节点索引为 $i_c = (N_x-1)/2$ 和 $j_c = (N_y-1)/2$，因此 $T_{\\mathrm{center}} = T_{i_c, j_c}$。\n- 标量 $S_{\\mathrm{Neu}}$，定义为在所有绝缘（诺伊曼）边界上的所有节点上，使用二阶单边有限差分计算的离散法向导数的最大绝对值。对于位于 $y = L_y$ 的上边界，节点 $i$ 处的离散导数为\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{top},i} \\approx \\frac{-3 T_{i,N_y-1} + 4 T_{i,N_y-2} - T_{i,N_y-3}}{2 \\,\\Delta y}.\n$$\n对于位于 $y = 0$ 的下边界，\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{bottom},i} \\approx \\frac{3 T_{i,0} - 4 T_{i,1} + T_{i,2}}{2 \\,\\Delta y}.\n$$\n对于位于 $x = 0$ 的左边界，\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{left},j} \\approx \\frac{3 T_{0,j} - 4 T_{1,j} + T_{2,j}}{2 \\,\\Delta x}.\n$$\n对于位于 $x = L_x$ 的右边界，\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{right},j} \\approx \\frac{-3 T_{N_x-1,j} + 4 T_{N_x-2,j} - T_{N_x-3,j}}{2 \\,\\Delta x}.\n$$\n然后\n$$\nS_{\\mathrm{Neu}} = \\max \\left( \\{\\left| \\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{edge,node}} \\right| \\;\\text{over all insulated edges and their nodes}\\} \\right).\n$$\n\n请使用以下测试套件。每个测试用例指定 $(L_x,L_y,N_x,N_y)$、所有四个边界（按顺序：左、右、下、上）的边界条件、残差容差 $\\varepsilon$ 以及为确保终止的迭代上限 $I_{\\max}$。狄利克雷边界用 $D$ 及其值表示，绝缘边界用法向导数为零的 $N$ 表示。在属于狄利克雷边界一部分的角点处，该角点应用狄利克雷值。\n\n- 测试用例 A:\n  - 几何参数: $L_x = 1$, $L_y = 1$, $N_x = 33$, $N_y = 33$.\n  - 边界条件: $(D:1,\\; D:0,\\; N:0,\\; N:0)$.\n  - 容差和上限: $\\varepsilon = 10^{-8}$, $I_{\\max} = 20000$.\n\n- 测试用例 B:\n  - 几何参数: $L_x = 2$, $L_y = 1$, $N_x = 31$, $N_y = 17$.\n  - 边界条件: $(N:0,\\; N:0,\\; D:1,\\; D:0)$.\n  - 容差和上限: $\\varepsilon = 10^{-8}$, $I_{\\max} = 20000$.\n\n- 测试用例 C:\n  - 几何参数: $L_x = 1$, $L_y = 1$, $N_x = 25$, $N_y = 25$.\n  - 边界条件: $(D:0.5,\\; D:0.5,\\; N:0,\\; N:0)$.\n  - 容差和上限: $\\varepsilon = 10^{-8}$, $I_{\\max} = 20000$.\n\n您的程序必须按 A、B、C 的顺序为每个测试用例计算 $(T_{\\mathrm{center}}, S_{\\mathrm{Neu}})$，并生成单行输出，其中包含用方括号括起来的逗号分隔结果列表。输出应按 $[T_{\\mathrm{center}}^{(A)}, S_{\\mathrm{Neu}}^{(A)}, T_{\\mathrm{center}}^{(B)}, S_{\\mathrm{Neu}}^{(B)}, T_{\\mathrm{center}}^{(C)}, S_{\\mathrm{Neu}}^{(C)}]$ 的顺序列出这六个数字。由于所有量都是无量纲的，因此不需要单位。任何角度（如果有）均不使用。", "solution": "用户要求解定义在矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上的标量温度场 $T(x,y)$ 的二维稳态拉普拉斯方程的数值解。控制方程为：\n$$ \\nabla^2 T = \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0 $$\n该问题将在具有混合狄利克雷和诺伊曼边界条件的离散笛卡尔网格上求解。\n\n解将使用有限差分法获得。域被离散化为一个 $N_x \\times N_y$ 个节点的网格，均匀间距为 $\\Delta x = L_x/(N_x - 1)$ 和 $\\Delta y = L_y/(N_y - 1)$。网格节点 $(x_i, y_j) = (i\\Delta x, j\\Delta y)$ 处的温度用 $T_{i,j}$ 表示。\n\n拉普拉斯方程中的偏导数使用二阶中心差分进行近似。这得到了内部节点 $(i,j)$ 处离散拉普拉斯算子的著名五点差分格式：\n$$ \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{(\\Delta x)^2} + \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{(\\Delta y)^2} = 0 $$\n该方程为所有非狄利克雷节点上的未知温度 $T_{i,j}$ 构成了一个线性代数方程组。\n\n该方程组使用 Gauss-Seidel 迭代法求解。方程被重新整理以用其邻近点的值表示 $T_{i,j}$。在迭代过程中，我们遍历网格，使用其邻近点的最新计算值来更新每个 $T_{i,j}$。内部节点的更新公式为：\n$$ T_{i,j}^{(k+1)} = \\frac{1}{2\\left(\\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2}\\right)} \\left[ \\frac{T_{i+1,j}^{(k)} + T_{i-1,j}^{(k+1)}}{(\\Delta x)^2} + \\frac{T_{i,j+1}^{(k)} + T_{i,j-1}^{(k+1)}}{(\\Delta y)^2} \\right] $$\n其中上标表示迭代次数，更新通过先扫描索引 $j$ 再扫描索引 $i$ 的方式进行原位更新。\n\n边界条件按如下方式并入：\n- **狄利克雷边界**：这些边界上的节点温度被固定为指定值。它们不参与迭代更新过程。问题描述阐明，任何与狄利克雷边界相邻的角点都被视为狄利克雷点。对于所有指定的测试用例，这意味着所有四个角点都是狄利克雷点。\n- **诺伊曼边界**：施加法向导数为零的条件（$\\frac{\\partial T}{\\partial n}=0$）。这通过使用“虚拟点”来实现。例如，在左边界（$i=0$）上，条件 $\\frac{\\partial T}{\\partial x}=0$ 通过中心差分被离散化为 $\\frac{T_{1,j} - T_{-1,j}}{2\\Delta x} = 0$，这意味着虚拟点的值为 $T_{-1,j} = T_{1,j}$。将此代入 $(0,j)$ 处的五点差分格式，得到该边界节点的更新规则：\n$$ T_{0,j}^{(k+1)} = \\frac{1}{2\\left(\\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2}\\right)} \\left[ \\frac{2 T_{1,j}^{(k)}}{(\\Delta x)^2} + \\frac{T_{0,j+1}^{(k)} + T_{0,j-1}^{(k+1)}}{(\\Delta y)^2} \\right] $$\n对于其他三个绝缘边界（右、上、下），可以推导出类似的公式。\n\n迭代过程持续进行直到解收敛。当在所有非狄利克雷节点上评估的离散残差的最大绝对值低于指定的容差 $\\varepsilon$ 时，即达到收敛。节点 $(i,j)$ 处的残差是使用当前温度场 $T_{i,j}$ 计算的离散拉普拉斯算子的值，必要时为诺伊曼边界使用虚拟点。为防止无限循环，迭代次数也设有上限 $I_{\\max}$。\n\n收敛后，计算两个量：\n1.  $T_{\\mathrm{center}}$：最接近板几何中心的网格节点处的温度，具体在索引 $i_c = (N_x-1)/2$ 和 $j_c = (N_y-1)/2$ 处。\n2.  $S_{\\mathrm{Neu}}$：所有绝缘边界上法向导数的最大绝对值。这是使用问题描述中提供的特定二阶单边有限差分公式计算的。最大值取自绝缘段上的所有节点，根据角点规则，这不包括角点本身。如果没有诺伊曼类型的边界，则 $S_{\\mathrm{Neu}}$ 取为 $0$。\n\n实现将包含一个遍历测试用例的主程序。对每个用例，将调用一个求解函数。该函数将：1. 初始化温度网格并识别狄利克雷节点。2. 执行 Gauss-Seidel 迭代，在每次扫描中根据内部或诺伊曼边界公式更新所有非狄利克雷节点。3. 周期性地计算最大残差，以检查是否收敛到 $\\varepsilon$。4. 循环终止后，计算并返回 $T_{\\mathrm{center}}$ 和 $S_{\\mathrm{Neu}}$。所有测试用例的最终结果将被汇总并按指定格式打印。", "answer": "```python\nimport numpy as np\n\ndef compute_case(Lx, Ly, Nx, Ny, boundaries, epsilon, max_iter):\n    \"\"\"\n    Solves the 2D Laplace equation on a rectangular grid with mixed boundary conditions.\n    \"\"\"\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n\n    T = np.zeros((Ny, Nx), dtype=np.float64)\n    is_dirichlet = np.zeros((Ny, Nx), dtype=bool)\n    \n    bc_map = {'left': boundaries[0], 'right': boundaries[1], \n              'bottom': boundaries[2], 'top': boundaries[3]}\n\n    # Set Dirichlet boundary conditions and mask\n    if bc_map['left'].startswith('D'):\n        val = float(bc_map['left'].split(':')[1])\n        T[:, 0] = val\n        is_dirichlet[:, 0] = True\n    if bc_map['right'].startswith('D'):\n        val = float(bc_map['right'].split(':')[1])\n        T[:, -1] = val\n        is_dirichlet[:, -1] = True\n    if bc_map['bottom'].startswith('D'):\n        val = float(bc_map['bottom'].split(':')[1])\n        T[0, :] = val\n        is_dirichlet[0, :] = True\n    if bc_map['top'].startswith('D'):\n        val = float(bc_map['top'].split(':')[1])\n        T[-1, :] = val\n        is_dirichlet[-1, :] = True\n\n    # Pre-calculate coefficients for the update rule\n    cx = 1 / (dx**2)\n    cy = 1 / (dy**2)\n    c = 1 / (2 * (cx + cy))\n    \n    # Identify Neumann boundaries for convenience\n    is_left_N = bc_map['left'].startswith('N')\n    is_right_N = bc_map['right'].startswith('N')\n    is_bottom_N = bc_map['bottom'].startswith('N')\n    is_top_N = bc_map['top'].startswith('N')\n\n    for k in range(max_iter):\n        # Gauss-Seidel update sweep\n        for j in range(Ny):\n            for i in range(Nx):\n                if is_dirichlet[j, i]:\n                    continue\n                \n                # Interior points\n                if 1 = j  Ny - 1 and 1 = i  Nx - 1:\n                    T[j,i] = c * (cx * (T[j, i+1] + T[j, i-1]) + cy * (T[j+1, i] + T[j-1, i]))\n                # Neumann boundary points (corners are Dirichlet for all test cases)\n                elif is_bottom_N and j == 0 and 1 = i  Nx - 1:\n                    T[j,i] = c * (cx * (T[j,i+1] + T[j,i-1]) + cy * (2 * T[j+1,i]))\n                elif is_top_N and j == Ny - 1 and 1 = i  Nx - 1:\n                    T[j,i] = c * (cx * (T[j,i+1] + T[j,i-1]) + cy * (2 * T[j-1,i]))\n                elif is_left_N and i == 0 and 1 = j  Ny - 1:\n                    T[j,i] = c * (cx * (2 * T[j,i+1]) + cy * (T[j+1,i] + T[j-1,i]))\n                elif is_right_N and i == Nx - 1 and 1 = j  Ny - 1:\n                    T[j,i] = c * (cx * (2 * T[j,i-1]) + cy * (T[j+1,i] + T[j-1,i]))\n        \n        # Check for convergence every 10 iterations to reduce overhead\n        if k % 10 == 0 or k == max_iter - 1:\n            max_res = 0.0\n            for j in range(Ny):\n                for i in range(Nx):\n                    if is_dirichlet[j, i]:\n                        continue\n                    \n                    res_val = 0.0\n                    # Interior residual\n                    if 1 = j  Ny - 1 and 1 = i  Nx - 1:\n                        res_val = cx*(T[j,i+1]+T[j,i-1]-2*T[j,i]) + cy*(T[j+1,i]+T[j-1,i]-2*T[j,i])\n                    # Neumann boundary residuals\n                    elif is_bottom_N and j == 0 and 1 = i  Nx-1:\n                        res_val = cx*(T[j,i+1]+T[j,i-1]-2*T[j,i]) + cy*(2*T[j+1,i]-2*T[j,i])\n                    elif is_top_N and j == Ny-1 and 1 = i  Nx-1:\n                        res_val = cx*(T[j,i+1]+T[j,i-1]-2*T[j,i]) + cy*(2*T[j-1,i]-2*T[j,i])\n                    elif is_left_N and i == 0 and 1 = j  Ny-1:\n                        res_val = cx*(2*T[j,i+1]-2*T[j,i]) + cy*(T[j+1,i]+T[j-1,i]-2*T[j,i])\n                    elif is_right_N and i == Nx-1 and 1 = j  Ny-1:\n                        res_val = cx*(2*T[j,i-1]-2*T[j,i]) + cy*(T[j+1,i]+T[j-1,i]-2*T[j,i])\n                    \n                    max_res = max(max_res, abs(res_val))\n\n            if max_res = epsilon:\n                break\n    \n    # Calculate output values\n    ic, jc = (Nx - 1) // 2, (Ny - 1) // 2\n    T_center = T[jc, ic]\n\n    s_neu_max = 0.0\n    if is_left_N:\n        if Nx > 3: # Ensure indices are valid for the stencil\n            deriv = (3 * T[1:-1, 0] - 4 * T[1:-1, 1] + T[1:-1, 2]) / (2 * dx)\n            if deriv.size > 0:\n                s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n    if is_right_N:\n        if Nx > 3:\n            deriv = (-3 * T[1:-1, -1] + 4 * T[1:-1, -2] - T[1:-1, -3]) / (2 * dx)\n            if deriv.size > 0:\n                s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n    if is_bottom_N:\n        if Ny > 3:\n            deriv = (3 * T[0, 1:-1] - 4 * T[1, 1:-1] + T[2, 1:-1]) / (2 * dy)\n            if deriv.size > 0:\n                s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n    if is_top_N:\n        if Ny > 3:\n            deriv = (-3 * T[-1, 1:-1] + 4 * T[-2, 1:-1] - T[-3, 1:-1]) / (2 * dy)\n            if deriv.size > 0:\n                s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n\n    return T_center, s_neu_max\n\ndef solve():\n    test_cases = [\n        {'Lx': 1, 'Ly': 1, 'Nx': 33, 'Ny': 33, 'boundaries': ('D:1', 'D:0', 'N:0', 'N:0'), 'epsilon': 1e-8, 'max_iter': 20000},\n        {'Lx': 2, 'Ly': 1, 'Nx': 31, 'Ny': 17, 'boundaries': ('N:0', 'N:0', 'D:1', 'D:0'), 'epsilon': 1e-8, 'max_iter': 20000},\n        {'Lx': 1, 'Ly': 1, 'Nx': 25, 'Ny': 25, 'boundaries': ('D:0.5', 'D:0.5', 'N:0', 'N:0'), 'epsilon': 1e-8, 'max_iter': 20000},\n    ]\n\n    results = []\n    for case in test_cases:\n        T_center, S_neu = compute_case(**case)\n        results.extend([T_center, S_neu])\n\n    print(f\"[{','.join(f'{x:.8g}' for x in results)}]\")\n\nsolve()\n```", "id": "2397045"}, {"introduction": "在掌握了拉普拉斯方程之后，我们现在转向一个更普适的方程：泊松方程。这个练习模拟了一个被点状负载作用的拉伸薄膜的变形，其位移由泊松方程 $T\\nabla^2 u(x,y) = -p(x,y)$ 决定。你将通过这个练习学习如何处理源项，特别是如何在一个离散网格上恰当地表示像狄拉克-$\\delta$函数这样的集中载荷，这将松弛法的应用范围从无源场扩展到了有力或源存在的物理场景中 [@problem_id:2397056]。", "problem": "您的任务是实现一个基于高斯-赛德尔松弛法的数值求解器，用于计算一块受点状载荷作用的、张紧的、固定的薄弹性膜的静态平面外位移。其控制偏微分方程(PDE)是均匀张力下薄膜的二维泊松方程。数学模型如下。\n\n一块方形薄膜占据域 $[0,L]\\times[0,L]$，并在边界处被固定，因此对于 $(x,y)\\in\\partial([0,L]\\times[0,L])$，边界位移满足 $u(x,y)=0$。薄膜张力是一个正常数 $T$，单位为 $\\mathrm{N/m}$。在单位面积的横向载荷 $p(x,y)$（单位为 $\\mathrm{N/m^2}$）作用下，静态位移 $u(x,y)$（单位为米）满足泊松方程\n$$\nT\\,\\nabla^2 u(x,y) = -\\,p(x,y)\n$$\n其中拉普拉斯算子定义为 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}$。一个施加在 $(x_0,y_0)$ 处、大小为 $P$（单位为 $\\mathrm{N}$）的点状载荷可表示为\n$$\np(x,y) = P\\,\\delta(x-x_0)\\,\\delta(y-y_0),\n$$\n其中 $\\delta$ 是狄拉克δ分布。\n\n从二阶导数的定义及其在均匀网格上的中心有限差分近似出发，推导泊松方程在均匀网格上的五点有限差分离散格式。该网格在每个空间方向上有 $N$ 个内部点，网格间距为 $h=L/(N+1)$。使用网格节点 $(x_i,y_j)=(ih,jh)$（其中 $i,j\\in\\{0,1,\\dots,N+1\\}$）对域进行离散化，并强制当 $i\\in\\{0,N+1\\}$ 或 $j\\in\\{0,N+1\\}$ 时 $u_{i,j}=0$。通过将总载荷注入到最接近 $(x_0,y_0)$ 的内部网格节点 $(i_0,j_0)$ 来表示点状载荷，并根据连续载荷积分为 $P$ 且离散更新在物理单位上保持一致的要求，推导该节点上经过正确缩放的离散右端项。您的推导必须从中心有限差分近似和狄拉克δ函数的定义出发，不能假设任何预先给定的离散更新公式。\n\n设计一个迭代高斯-赛德尔松弛算法，该算法就地更新内部网格值直至收敛。您可以选择使用逐次超松弛(Successive Over-Relaxation)变体，并使用一个固定的松弛因子 $\\omega\\in(1,2)$ 来加速收敛，同时保持高斯-赛德尔结构。使用基于一次完整扫描中所有内部节点上 $u$ 的最大绝对变化量的收敛准则，当此最大绝对变化量小于给定阈值 $\\tau$（单位为米）时停止。确保您的算法是数值稳定的，并且所有步骤都由您推导的离散方程所证明。\n\n您的程序必须为下面的每个测试用例计算施加点状载荷处最近的内部网格节点的位移，单位为米。对于每个测试用例，将结果精确到小数点后六位。不允许用户输入；所有参数都是硬编码的。本问题不使用角度。所有物理量必须使用上述指定的单位，所有位移均以米报告。\n\n使用以下必须嵌入到您程序中的测试套件：\n\n- 测试用例 1：$L=1.0$ $\\mathrm{m}$，$N=63$，$T=100.0$ $\\mathrm{N/m}$，$P=1.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$。\n- 测试用例 2：$L=1.0$ $\\mathrm{m}$，$N=63$，$T=100.0$ $\\mathrm{N/m}$，$P=5.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$。\n- 测试用例 3：$L=1.0$ $\\mathrm{m}$，$N=63$，$T=100.0$ $\\mathrm{N/m}$，$P=1.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.2,0.3)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$。\n- 测试用例 4：$L=1.0$ $\\mathrm{m}$，$N=63$，$T=100.0$ $\\mathrm{N/m}$，$P=0.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-10}$ $\\mathrm{m}$。\n- 测试用例 5：$L=1.0$ $\\mathrm{m}$，$N=127$，$T=100.0$ $\\mathrm{N/m}$，$P=1.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含五个四舍五入后的结果，以逗号分隔，并用方括号括起来，顺序与测试用例一致，例如 $[u_1,u_2,u_3,u_4,u_5]$，其中每个 $u_k$ 是一个浮点数，小数点后有六位数字，表示米。", "solution": "该问题已经过验证，被认为是科学上合理的、适定的和完整的。将构建一个解决方案。\n\n薄膜静态位移 $u(x,y)$ 的控制方程是二维泊松方程：\n$$ T\\,\\nabla^2 u(x,y) = -p(x,y) $$\n其中 $T$ 是张力，$p(x,y)$ 是单位面积载荷，$\\nabla^2 = \\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}$ 是拉普拉斯算子。域为一个方形区域 $[0,L]\\times[0,L]$，其边界条件为固定边界，即在边界上 $u=0$。\n\n首先，我们对域和微分算子进行离散化。建立一个在每个方向上具有 $N$ 个内部点的均匀网格。网格间距为 $h = L/(N+1)$。网格节点位于 $(x_i, y_j) = (ih, jh)$，其中整数 $i, j \\in \\{0, 1, \\dots, N+1\\}$。这些节点上的位移表示为 $u_{i,j} = u(x_i, y_j)$。边界条件意味着如果 $i \\in \\{0, N+1\\}$ 或 $j \\in \\{0, N+1\\}$，则 $u_{i,j} = 0$。\n\n二阶偏导数使用二阶中心差分公式进行近似。对于函数 $f(z)$，其二阶导数为 $f''(z) \\approx (f(z+h) - 2f(z) + f(z-h))/h^2$。将此应用于节点 $(i,j)$ 上的 $u(x,y)$：\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(i,j)} \\approx \\frac{u(x_i+h, y_j) - 2u(x_i, y_j) + u(x_i-h, y_j)}{h^2} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} $$\n$$ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(i,j)} \\approx \\frac{u(x_i, y_j+h) - 2u(x_i, y_j) + u(x_i, y_j-h)}{h^2} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\n离散化的拉普拉斯算子，被称为五点模板，变为：\n$$ \\nabla^2 u \\bigg|_{(i,j)} \\approx \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} $$\n将此代入泊松方程，得到内部节点（$i,j \\in \\{1, \\dots, N\\}$）的线性系统：\n$$ T \\left( \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} \\right) = -p_{i,j} $$\n其中 $p_{i,j}$ 是节点 $(i,j)$ 处载荷密度 $p(x,y)$ 的离散表示。\n\n载荷是在 $(x_0, y_0)$ 处大小为 $P$ 的点状力，由狄拉克δ分布描述：$p(x,y) = P\\,\\delta(x-x_0)\\,\\delta(y-y_0)$。为了找到离散载荷 $p_{i,j}$，我们必须保持δ函数的积分性质。总力是载荷密度在整个面积上的积分。在离散网格上，总力是每个节点上力的总和，其中一个节点上的力是该节点的密度 $p_{i,j}$ 乘以与其关联的面积元 $h^2$。\n$$ \\sum_{i=1}^{N} \\sum_{j=1}^{N} p_{i,j} h^2 \\approx \\iint_{\\text{domain}} p(x,y) \\,dx\\,dy = \\iint_{\\text{domain}} P\\,\\delta(x-x_0)\\,\\delta(y-y_0) \\,dx\\,dy = P $$\n问题规定，将整个载荷 $P$ 施加到最接近 $(x_0, y_0)$ 的单一内部网格节点 $(i_0, j_0)$ 上。这意味着我们必须有 $p_{i_0,j_0}h^2 = P$，而对于所有其他节点 $(i,j) \\neq (i_0, j_0)$，有 $p_{i,j}=0$。这给出了施力点处的离散载荷密度为 $p_{i_0,j_0} = P/h^2$。\n\n由此，在载荷点 $(i_0,j_0)$ 的离散泊松方程为：\n$$ T \\left( \\frac{u_{i_0+1,j_0} + u_{i_0-1,j_0} + u_{i_0,j_0+1} + u_{i_0,j_0-1} - 4u_{i_0,j_0}}{h^2} \\right) = -\\frac{P}{h^2} $$\n对于任何其他内部节点 $(i,j) \\neq (i_0,j_0)$，我们有 $p_{i,j}=0$，因此方程简化为离散拉普拉斯方程：\n$$ \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} = 0 $$\n为了构建迭代格式，我们重新整理离散方程以求解 $u_{i,j}$：\n$$ 4u_{i,j} = u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + \\frac{p_{i,j} h^2}{T} $$\n$$ u_{i,j} = \\frac{1}{4} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + f_{i,j} \\right) $$\n这里我们定义源项 $f_{i,j} = p_{i,j} h^2 / T$。根据我们的载荷离散化，该源项仅在 $(i_0, j_0)$ 处非零：\n$$ f_{i,j} = \\begin{cases} P/T  \\text{if } (i,j) = (i_0,j_0) \\\\ 0  \\text{otherwise} \\end{cases} $$\n\n高斯-赛德尔法是求解此线性系统的一种迭代技术。它使用其邻居节点的最新计算值来更新每个节点上的 $u_{i,j}$ 值。对于第 $k+1$ 次迭代，$u_{i,j}$ 的更新公式为：\n$$ u_{i,j}^{(k+1)} = \\frac{1}{4} \\left( u_{i+1,j}^{(k)} + u_{i-1,j}^{(k+1)} + u_{i,j+1}^{(k)} + u_{i,j-1}^{(k+1)} + f_{i,j} \\right) $$\n假设采用字典序扫描（例如，先增加 $i$，再增加 $j$）。这通过在单个数组内就地覆写 $u_{i,j}$ 的值来实现。\n\n为了加速收敛，使用逐次超松弛法（SOR）。该方法通过引入一个松弛因子 $\\omega \\in (1,2)$ 来修改高斯-赛德尔更新。首先，通过高斯-赛德尔步骤计算一个临时值，我们称之为 $u_{i,j}^{\\text{GS}}$：\n$$ u_{i,j}^{\\text{GS}} = \\frac{1}{4} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + f_{i,j} \\right) $$\n然后，新值 $u_{i,j}^{\\text{new}}$ 是旧值 $u_{i,j}^{\\text{old}}$ 和 $u_{i,j}^{\\text{GS}}$ 的加权平均：\n$$ u_{i,j}^{\\text{new}} = (1-\\omega) u_{i,j}^{\\text{old}} + \\omega u_{i,j}^{\\text{GS}} $$\n对于具有狄利克雷边界条件的方形域，最优松弛因子已知为：\n$$ \\omega_{\\text{opt}} = \\frac{2}{1 + \\sin(\\pi h/L)} = \\frac{2}{1 + \\sin(\\pi / (N+1))} $$\n使用此 $\\omega$ 值可以显著减少收敛所需的迭代次数，相比于标准高斯-赛德尔法（其中 $\\omega=1$）。\n\n算法流程如下：\n$1$. 初始化一个 $(N+2) \\times (N+2)$ 的网格 $u$，所有元素设置为 $0$。这自动满足了边界上 $u_{i,j}=0$ 的边界条件。\n$2$. 确定网格参数：$h = L/(N+1)$ 以及最接近载荷施加点 $(x_0,y_0)$ 的节点的索引 $(i_0,j_0)$。它们由 $i_0 = \\text{round}(x_0/h)$ 和 $j_0 = \\text{round}(y_0/h)$ 给出。必须断言 $1 \\le i_0, j_0 \\le N$。\n$3$. 构建一个同样大小的源网格 $f$，其中 $f_{j_0,i_0} = P/T$，所有其他元素为 $0$。注意数组索引 `(row, col)` 对应于 `(j, i)`。\n$4$. 使用 $\\omega_{\\text{opt}}$ 的公式计算最优松弛因子 $\\omega$。\n$5$. 迭代直至收敛：\n    a. 初始化一个变量 $\\text{max\\_abs\\_change} = 0$。\n    b. 遍历所有内部网格点，对于 $j=1, \\dots, N$ 和 $i=1, \\dots, N$。\n    c. 在每个点 $(i,j)$，存储当前值 $u_{j,i}^{\\text{old}}$。\n    d. 使用SOR更新公式计算新值 $u_{j,i}^{\\text{new}}$。\n    e. 就地更新网格：$u_{j,i} = u_{j,i}^{\\text{new}}$。\n    f. 更新最大变化量：$\\text{max\\_abs\\_change} = \\max(\\text{max\\_abs\\_change}, |u_{j,i}^{\\text{new}} - u_{j,i}^{\\text{old}}|)$。\n    g. 在对所有内部节点进行一次完整扫描后，检查收敛准则：如果 $\\text{max\\_abs\\_change}  \\tau$，则终止迭代。\n$6$. 收敛后，所需的位移是载荷点处的值 $u_{j_0,i_0}$。然后按照要求将此值四舍五入到 $6$ 位小数。\n\n为每个提供的测试用例实施此过程。", "answer": "```python\nimport numpy as np\nimport math\n\ndef run_simulation(L, N, T, P, x0, y0, tau):\n    \"\"\"\n    Solves the Poisson equation for membrane displacement using the\n    Successive Over-Relaxation (SOR) method.\n\n    Args:\n        L (float): Side length of the square membrane [m].\n        N (int): Number of interior grid points in each direction.\n        T (float): Tension in the membrane [N/m].\n        P (float): Magnitude of the point load [N].\n        x0 (float): x-coordinate of the load application point [m].\n        y0 (float): y-coordinate of the load application point [m].\n        tau (float): Convergence threshold for displacement [m].\n\n    Returns:\n        float: The displacement at the node nearest to the load point.\n    \"\"\"\n    # Handle the trivial case where there is no load.\n    if P == 0.0:\n        return 0.0\n\n    # 1. Initialize grid and parameters\n    # The grid size is (N+2) x (N+2) to include the clamped boundaries.\n    grid_size = N + 2\n    u = np.zeros((grid_size, grid_size), dtype=np.float64)\n    \n    # Calculate the grid spacing h.\n    h = L / (N + 1)\n    \n    # 2. Determine load point and create the discrete source term grid `f`.\n    # Numpy array indexing is (row, col), which corresponds to (j, i).\n    # The variable i corresponds to the x-direction, and j to the y-direction.\n    # We find the nearest grid indices (i0, j0) to the physical point (x0, y0).\n    i0 = int(round(x0 / h))\n    j0 = int(round(y0 / h))\n    \n    # Verify that the calculated load point is an interior node.\n    if not (1 = i0 = N and 1 = j0 = N):\n        raise ValueError(f\"Load point ({x0}, {y0}) maps to a boundary node.\")\n\n    # The source term f is zero everywhere except at the load point.\n    # As derived, f_i0,j0 = P/T.\n    f_source_value = P / T\n    \n    # 3. Calculate the optimal relaxation parameter omega for SOR.\n    omega = 2.0 / (1.0 + math.sin(math.pi / (N + 1)))\n\n    # 4. Main SOR iteration loop.\n    # A safety break is included to prevent infinite loops.\n    max_iterations = 20000 \n    for _ in range(max_iterations):\n        max_abs_change = 0.0\n        \n        # Sweep over all interior grid points.\n        for j in range(1, N + 1):\n            for i in range(1, N + 1):\n                u_old = u[j, i]\n                \n                # Apply the source term only at the specific load point.\n                source = f_source_value if i == i0 and j == j0 else 0.0\n                \n                # Calculate the update using the Gauss-Seidel formula.\n                u_gs = 0.25 * (u[j, i+1] + u[j, i-1] + u[j+1, i] + u[j-1, i] + source)\n                \n                # Apply the SOR formula. The update is done in-place.\n                u[j, i] = (1.0 - omega) * u_old + omega * u_gs\n                \n                # Track the maximum change in displacement over the grid for this iteration.\n                max_abs_change = max(max_abs_change, abs(u[j, i] - u_old))\n\n        # 5. Check for convergence.\n        if max_abs_change  tau:\n            break\n            \n    # 6. Return the displacement at the node nearest to the load application point.\n    return u[j0, i0]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 1.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-8},\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 5.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-8},\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 1.0, 'x0': 0.2, 'y0': 0.3, 'tau': 1e-8},\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 0.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-10},\n        {'L': 1.0, 'N': 127, 'T': 100.0, 'P': 1.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            L=case['L'], N=case['N'], T=case['T'], P=case['P'],\n            x0=case['x0'], y0=case['y0'], tau=case['tau']\n        )\n        # Format the result to exactly six decimal places.\n        results.append(f\"{result:.6f}\")\n\n    # Print the final output in the required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2397056"}, {"introduction": "虽然高斯-赛德尔方法是可靠的，但对于大型网格，其收敛速度可能很慢。为了解决这个问题，我们引入一种强大的加速技术：逐次超松弛（SOR）方法。在这个实践中，你不仅要实现SOR算法，还将编写一个脚本来通过经验性测试寻找给定几何构型的最佳松弛参数 $\\omega_{\\text{opt}}$ [@problem_id:2397060]。这能让你深入理解性能优化的重要性，并掌握在计算科学中至关重要的经验性算法分析技能。", "problem": "您需要实现一个二维拉普拉斯方程的数值求解器，使用逐次超松弛（SOR）方法来加速 Gauss-Seidel 迭代。您的实现必须通过经验性方法，为具有 Dirichlet 边界条件的特定矩形几何区域确定最优松弛参数 $\\,\\omega_{\\mathrm{opt}}\\,\\in(0,2)\\,$。该任务必须从第一性原理出发，即从拉普拉斯方程的定义和在均匀笛卡尔网格上的标准五点有限差分格式开始。\n\n您必须遵守以下要求。\n\n- 从二维空间中的拉普拉斯方程定义 $\\,\\nabla^2 u = 0\\,$ 和在矩形格点上的五点均匀网格有限差分格式出发。使用由逐次超松弛（SOR）增强的 Gauss-Seidel 迭代法。除了这些基础知识外，不要假定任何预先推导的公式。\n- 使用红黑排序（棋盘式更新），以便在每次迭代中，首先更新所有红色的内部点，然后更新所有黑色的内部点，进行原地更新。\n- 采用以下收敛准则。将一次完整的红黑扫描定义为一次“迭代”。每次扫描后，将迭代间变化量定义为在所有已更新的内部点（不包括 Dirichlet 固定的边界点和任何内部 Dirichlet 障碍物）上，更新后的值与前一次迭代值之间的最大绝对差值。当这个更新量的无穷范数低于容差 $\\,\\tau = 10^{-5}\\,$, 或迭代次数达到最大值 $\\,I_{\\max} = 5000\\,$ 时停止，以先到者为准。\n- 对所有内部未知数使用零初始猜测值，即在每次求解开始时，内部点的 $\\,u_{i,j}=0\\,$。在迭代开始前应用 Dirichlet 边界值和任何内部 Dirichlet 障碍物的值，并在迭代过程中保持它们不变。\n- 将 $\\,\\omega_{\\mathrm{opt}}\\,$ 的经验性搜索定义为两阶段搜索：\n  - 粗略阶段：在网格 $\\,\\{1.0, 1.1, 1.2, \\dots, 1.9\\}\\,$ 上测试 $\\,\\omega\\,$。\n  - 精细阶段：设 $\\,\\omega_c\\,$ 为粗略阶段中使收敛迭代次数最小化的值（若有多个最小值，则选择最小的 $\\,\\omega\\,$）。然后在均匀网格 $\\,\\max(1.0,\\omega_c-0.05),\\,\\max(1.0,\\omega_c-0.05)+0.01,\\,\\dots,\\,\\min(1.95,\\omega_c+0.05)\\,$ 上测试 $\\,\\omega\\,$。选择 $\\,\\omega_{\\mathrm{opt}}\\,$ 作为精细网格上迭代次数的最小化值（同样，若有多个最小值，则选择最小的 $\\,\\omega\\,$）。报告保留两位小数的 $\\,\\omega_{\\mathrm{opt}}\\,$，并将相应的最小迭代次数作为整数报告。只有在选定最小值之后才进行四舍五入。\n- 在两个方向上使用均匀的网格间距。您无需报告物理单位，也不应使用角度量。\n\n测试套件。实现您的程序以计算并报告以下三（$3$）个测试用例的结果。\n\n- A 用例（具有热顶边的正方形）：\n  - 网格：$\\,N_x = 50\\,$, $\\,N_y = 50\\,$。\n  - Dirichlet 边界值：上边界 $\\,u=1.0\\,$，下、左、右边界 $\\,u=0.0\\,$。\n  - 无内部障碍物。\n- B 用例（具有热左边的矩形）：\n  - 网格：$\\,N_x = 60\\,$, $\\,N_y = 30\\,$。\n  - Dirichlet 边界值：左边界 $\\,u=1.0\\,$，上、下、右边界 $\\,u=0.0\\,$。\n  - 无内部障碍物。\n- C 用例（带有暖内部障碍物的正方形）：\n  - 网格：$\\,N_x = 40\\,$, $\\,N_y = 40\\,$。\n  - Dirichlet 边界值：所有四个外边界 $\\,u=0.0\\,$。\n  - 内部 Dirichlet 障碍物：一个边长为 $\\,8\\,$ 个内部网格点的居中正方形（即，在从零开始的索引中，索引 $\\,x\\in\\{16,17,\\dots,23\\}\\,$ 和 $\\,y\\in\\{16,17,\\dots,23\\}\\,$），其值固定为 $\\,u=0.5\\,$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个双元素列表 $[\\omega_{\\mathrm{opt}}, I_{\\min}]$，其中 $\\,\\omega_{\\mathrm{opt}}\\,$ 四舍五入到两位小数，$\\,I_{\\min}\\,$ 是作为整数的最小迭代次数。因此，最后一行必须看起来像\n$\\,\\big[[\\omega^{(A)}_{\\mathrm{opt}}, I^{(A)}_{\\min}], [\\omega^{(B)}_{\\mathrm{opt}}, I^{(B)}_{\\min}], [\\omega^{(C)}_{\\mathrm{opt}}, I^{(C)}_{\\min}]\\big]\\,$\n，不带任何附加文本。例如，一个语法正确的输出将是\n$\\,\\big[[1.80, 250], [1.90, 180], [1.75, 310]\\big]\\,$\n，尽管这些不是此问题的预期数值。", "solution": "我们从二维空间中的拉普拉斯方程开始，\n$$\n\\nabla^2 u \\;=\\; \\frac{\\partial^2 u}{\\partial x^2} \\;+\\; \\frac{\\partial^2 u}{\\partial y^2} \\;=\\; 0,\n$$\n该方程定义在具有 Dirichlet 边界数据的矩形区域上。在两个方向上间距均为 $\\,h\\,$ 的均匀笛卡尔网格上，内部索引为 $\\,i=1,\\dots,N_x-2\\,$ 和 $\\,j=1,\\dots,N_y-2\\,$（最外层索引保留给 Dirichlet 边界），经典的五点有限差分（FD）近似产生离散拉普拉斯算子\n$$\n\\frac{u_{i+1,j} - 2\\,u_{i,j} + u_{i-1,j}}{h^2} \\;+\\; \\frac{u_{i,j+1} - 2\\,u_{i,j} + u_{i,j-1}}{h^2} \\;=\\; 0,\n$$\n对于均匀的 $\\,h\\,$ 和纯拉普拉斯问题（无源项），该式简化为不动点关系\n$$\nu_{i,j} \\;=\\; \\frac{1}{4}\\,\\big( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} \\big).\n$$\n这个恒等式提示了一种迭代方法：Gauss-Seidel（GS）迭代法使用最新可用的邻居值对每个内部点 $\\,u_{i,j}\\,$ 进行原地更新。当某些网格点是 Dirichlet 固定的（边界或内部障碍物）时，它们不参与更新并被保留为常数，以便它们的值可以在不改变的情况下参与邻居值的求和。\n\n逐次超松弛（SOR）通过对 GS 更新朝向不动点进行凸外插来加速 GS。将 $\\,\\{i,j\\}\\,$ 处的 Gauss-Seidel 更新表示为\n$$\nu^{\\mathrm{GS}}_{i,j} \\;=\\; \\frac{1}{4}\\,\\big( u_{i+1,j}^{\\star} + u_{i-1,j}^{\\star} + u_{i,j+1}^{\\star} + u_{i,j-1}^{\\star} \\big),\n$$\n其中每个邻居值 $\\,u^{\\star}\\,$ 是当前的原地值（一些邻居已在同一次扫描中更新，另一些则尚未更新）。使用松弛参数 $\\,\\omega\\in(0,2)\\,$ 的 SOR 更新为\n$$\nu^{\\mathrm{new}}_{i,j} \\;=\\; (1-\\omega)\\,u^{\\mathrm{old}}_{i,j} \\;+\\; \\omega\\,u^{\\mathrm{GS}}_{i,j}.\n$$\n对于红黑排序，网格根据 $\\,i+j\\,$ 的奇偶性被划分为两个交错的集合。首先使用黑色邻居点（因为每个红色点的最近邻居都是黑色的）更新所有红色点，然后使用新更新的红色邻居点更新所有黑色点，从而完成一次迭代（一次扫描）。这种排序方式支持向量化更新，并保留了 Gauss-Seidel 的依赖结构。\n\n收敛性通过每次迭代变化量的无穷范数来监控。设 $\\,\\Delta^{(k)}\\,$ 为在第 $\\,k\\,$ 次迭代期间，所有已更新的内部点上更新后值与先前值之间的最大绝对差值。我们在以下条件满足时终止\n$$\n\\Delta^{(k)} \\;\\; \\tau \\;=\\; 10^{-5},\n$$\n或者当迭代次数达到上限 $\\,I_{\\max}=5000\\,$ 时。对于所有内部点，初始猜测值设为 $\\,u_{i,j}=0\\,$，同时施加 Dirichlet 边界和内部障碍物的值，并保持其固定。\n\n为了经验性地确定 $\\,\\omega_{\\mathrm{opt}}\\,$，我们在一个预定的 $\\,\\omega\\,$ 值集合上，最小化满足停止准则所需的迭代次数。我们采用两阶段搜索来平衡鲁棒性和计算成本：\n\n- 粗略阶段：评估 $\\,\\omega \\in \\{1.0, 1.1, \\dots, 1.9\\}\\,$ 并选择使迭代次数最小化的 $\\,\\omega_c\\,$（若有多个最小值，则选择较小的 $\\,\\omega\\,$）。\n- 精细阶段：在均匀网格 $\\,\\omega \\in [\\max(1.0,\\omega_c-0.05), \\min(1.95,\\omega_c+0.05)]\\,$ 上，步长为 $\\,0.01\\,$，评估 $\\,\\omega\\,$，并选择使迭代次数最小化的 $\\,\\omega_{\\mathrm{opt}}\\,$（同样，若有多个最小值，则选择较小的 $\\,\\omega\\,$）。只有在选定最小值之后，我们才将 $\\,\\omega_{\\mathrm{opt}}\\,$ 四舍五入到两位小数进行报告。\n\n我们实现三种几何结构。\n\n- A 用例：$\\,N_x=50\\,$, $\\,N_y=50\\,$。顶边固定为 $\\,u=1.0\\,$；其他边界固定为 $\\,u=0.0\\,$；无障碍物。\n- B 用例：$\\,N_x=60\\,$, $\\,N_y=30\\,$。左边固定为 $\\,u=1.0\\,$；其他边界固定为 $\\,u=0.0\\,$；无障碍物。\n- C 用例：$\\,N_x=40\\,$, $\\,N_y=40\\,$。所有外边界固定为 $\\,u=0.0\\,$。一个居中的内部 Dirichlet 障碍物，边长为 $\\,8\\,$ 个内部网格点，索引为 $\\,x\\in\\{16,\\dots,23\\},\\,y\\in\\{16,\\dots,23\\}\\,$，固定值为 $\\,u=0.5\\,$。\n\n为保证效率和正确性的算法细节：\n\n- 在内部点上构建布尔掩码以识别红色和黑色的更新位置，并可选择性地将障碍物单元从更新中排除。\n- 在每个红色（或黑色）半扫描中，计算整个内部区域的邻居和 $\\,u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\,$，然后仅在红色（或黑色）掩码上应用 SOR 更新。对于红色半扫描，邻居和使用的值中，所有红色点的邻居实际上都是黑色单元；因此，求和正确地使用了最新的黑色值。红色点更新后，重新计算邻居和，以便黑色点的更新能“看到”已更新的红色邻居值。\n- 追踪该次扫描中所有更新的最大绝对变化量，记为 $\\,\\Delta^{(k)}\\,$。\n\n然后，程序对每个测试用例执行两阶段搜索，记录最佳的 $\\,\\omega_{\\mathrm{opt}}\\,$ 及其最小迭代次数 $\\,I_{\\min}\\,$，将 $\\,\\omega_{\\mathrm{opt}}\\,$ 四舍五入到两位小数，并打印包含列表的单行\n$$\n\\big[[\\omega^{(A)}_{\\mathrm{opt}}, I^{(A)}_{\\min}], [\\omega^{(B)}_{\\mathrm{opt}}, I^{(B)}_{\\min}], [\\omega^{(C)}_{\\mathrm{opt}}, I^{(C)}_{\\min}]\\big].\n$$\n这个过程对于具有 Dirichlet 数据的均匀网格上的拉普拉斯类型问题是通用的，并且演示了逐次超松弛（SOR）如何加速 Gauss-Seidel 迭代，以及如何针对给定的离散几何结构经验性地调整松弛参数 $\\,\\omega\\,$。", "answer": "```python\nimport numpy as np\n\ndef sor_red_black(\n    nx: int,\n    ny: int,\n    boundary_values: dict,\n    obstacle_mask: np.ndarray | None = None,\n    obstacle_value: float | None = None,\n    omega: float = 1.5,\n    tol: float = 1e-5,\n    max_iters: int = 5000,\n) -> int:\n    \"\"\"\n    Perform red-black SOR for Laplace's equation on an nx-by-ny grid.\n    - boundary_values: dict with any of 'top','bottom','left','right' mapping to floats.\n      Edges not specified default to 0.0.\n    - obstacle_mask: full-size boolean array (ny, nx), True where Dirichlet-fixed internal obstacle exists.\n    - obstacle_value: float value assigned to obstacle cells (required if obstacle_mask is provided).\n    - omega: relaxation parameter in (0,2).\n    - tol: stopping tolerance on infinity norm of per-iteration change.\n    - max_iters: maximum number of red-black sweeps.\n    Returns: number of iterations (sweeps) taken to reach tol (or max_iters if not reached).\n    \"\"\"\n    # Initialize potential field\n    u = np.zeros((ny, nx), dtype=np.float64)\n\n    # Apply boundary conditions (unspecified edges are zero)\n    if 'bottom' in boundary_values:\n        u[0, :] = boundary_values['bottom']\n    if 'top' in boundary_values:\n        u[-1, :] = boundary_values['top']\n    if 'left' in boundary_values:\n        u[:, 0] = boundary_values['left']\n    if 'right' in boundary_values:\n        u[:, -1] = boundary_values['right']\n\n    # Internal Dirichlet obstacle\n    if obstacle_mask is not None:\n        if obstacle_value is None:\n            raise ValueError(\"obstacle_value must be provided when obstacle_mask is given.\")\n        u[obstacle_mask] = obstacle_value\n\n    # Interior masks (exclude outer boundary)\n    # Boolean mask of interior points that are updatable (not obstacle)\n    interior_shape = (ny - 2, nx - 2)\n    if interior_shape[0] = 0 or interior_shape[1] = 0:\n        return 0  # no interior to update\n\n    # Build interior obstacle mask\n    if obstacle_mask is not None:\n        obsI = obstacle_mask[1:-1, 1:-1].copy()\n    else:\n        obsI = np.zeros(interior_shape, dtype=bool)\n\n    update_mask = ~obsI  # True where we update\n\n    # Red-black masks over the interior\n    ii = np.arange(1, ny - 1)[:, None]\n    jj = np.arange(1, nx - 1)[None, :]\n    parity = (ii + jj)  1  # 0 for even (red), 1 for odd (black)\n    red_mask = (parity == 0)[1 - 1:ny - 1 - 1 + 1, 1 - 1:nx - 1 - 1 + 1]  # same shape as interior\n    black_mask = ~red_mask\n    red_mask = red_mask  update_mask\n    black_mask = black_mask  update_mask\n\n    # Helper to compute neighbor sum over interior\n    def neighbor_sum(U):\n        return (U[2:, 1:-1] + U[:-2, 1:-1] + U[1:-1, 2:] + U[1:-1, :-2])\n\n    # Iterate\n    iters = 0\n    for k in range(1, max_iters + 1):\n        max_change = 0.0\n\n        # Red half-sweep\n        s = neighbor_sum(u)\n        uI = u[1:-1, 1:-1]\n        if np.any(red_mask):\n            old_vals = uI[red_mask]\n            gs_vals = 0.25 * s[red_mask]\n            new_vals = (1.0 - omega) * old_vals + omega * gs_vals\n            change = np.max(np.abs(new_vals - old_vals)) if new_vals.size else 0.0\n            max_change = max(max_change, float(change))\n            uI[red_mask] = new_vals\n\n        # Black half-sweep\n        s = neighbor_sum(u)  # recompute after red updates\n        if np.any(black_mask):\n            old_vals = uI[black_mask]\n            gs_vals = 0.25 * s[black_mask]\n            new_vals = (1.0 - omega) * old_vals + omega * gs_vals\n            change = np.max(np.abs(new_vals - old_vals)) if new_vals.size else 0.0\n            max_change = max(max_change, float(change))\n            uI[black_mask] = new_vals\n\n        iters = k\n        if max_change  tol:\n            break\n\n    return iters\n\n\ndef empirical_omega_opt(\n    nx: int,\n    ny: int,\n    boundary_values: dict,\n    obstacle_mask: np.ndarray | None,\n    obstacle_value: float | None,\n    tol: float = 1e-5,\n    max_iters: int = 5000,\n):\n    \"\"\"\n    Two-stage empirical search for omega_opt minimizing iteration count.\n    Returns (omega_opt_rounded_to_2_decimals, min_iterations).\n    \"\"\"\n    # Coarse grid: 1.0 to 1.9 step 0.1\n    coarse_candidates = [round(1.0 + 0.1 * i, 10) for i in range(0, 10)]  # [1.0, ..., 1.9]\n    coarse_results = []\n    for w in coarse_candidates:\n        it = sor_red_black(\n            nx, ny, boundary_values,\n            obstacle_mask=obstacle_mask,\n            obstacle_value=obstacle_value,\n            omega=w, tol=tol, max_iters=max_iters\n        )\n        coarse_results.append((w, it))\n    # Select best coarse (min iters, tie-break by smallest omega)\n    min_it_coarse = min(it for _, it in coarse_results)\n    best_coarse = min([w for (w, it) in coarse_results if it == min_it_coarse])\n\n    # Fine grid around best_coarse: step 0.01 within [1.0, 1.95]\n    start = max(1.0, best_coarse - 0.05)\n    end = min(1.95, best_coarse + 0.05)\n    n_steps = int(round((end - start) / 0.01))  # inclusive range\n    fine_candidates = [round(start + 0.01 * i, 10) for i in range(n_steps + 1)]\n    fine_results = []\n    for w in fine_candidates:\n        it = sor_red_black(\n            nx, ny, boundary_values,\n            obstacle_mask=obstacle_mask,\n            obstacle_value=obstacle_value,\n            omega=w, tol=tol, max_iters=max_iters\n        )\n        fine_results.append((w, it))\n    min_it_fine = min(it for _, it in fine_results)\n    best_fine = min([w for (w, it) in fine_results if it == min_it_fine])\n\n    return round(best_fine, 2), int(min_it_fine)\n\n\ndef build_obstacle_mask(ny: int, nx: int, y0: int, y1: int, x0: int, x1: int) -> np.ndarray:\n    \"\"\"\n    Build a full-size boolean mask with True on [y0:y1, x0:x1] inclusive of endpoints if using slice semantics.\n    Here, we assume x1, y1 are exclusive upper bounds for numpy slicing.\n    \"\"\"\n    mask = np.zeros((ny, nx), dtype=bool)\n    mask[y0:y1, x0:x1] = True\n    return mask\n\n\ndef solve():\n    results = []\n\n    # Common solver settings\n    tol = 1e-5\n    max_iters = 5000\n\n    # Case A: Nx=50, Ny=50, top=1.0, others=0.0, no obstacle\n    nx_A, ny_A = 50, 50\n    bvals_A = {'top': 1.0, 'bottom': 0.0, 'left': 0.0, 'right': 0.0}\n    omega_A, it_A = empirical_omega_opt(\n        nx_A, ny_A, bvals_A,\n        obstacle_mask=None, obstacle_value=None,\n        tol=tol, max_iters=max_iters\n    )\n    results.append([omega_A, it_A])\n\n    # Case B: Nx=60, Ny=30, left=1.0, others=0.0, no obstacle\n    nx_B, ny_B = 60, 30\n    bvals_B = {'left': 1.0, 'top': 0.0, 'bottom': 0.0, 'right': 0.0}\n    omega_B, it_B = empirical_omega_opt(\n        nx_B, ny_B, bvals_B,\n        obstacle_mask=None, obstacle_value=None,\n        tol=tol, max_iters=max_iters\n    )\n    results.append([omega_B, it_B])\n\n    # Case C: Nx=40, Ny=40, all edges 0.0, centered 8x8 obstacle at 0.5\n    nx_C, ny_C = 40, 40\n    bvals_C = {'top': 0.0, 'bottom': 0.0, 'left': 0.0, 'right': 0.0}\n    # Center indices for obstacle: 8x8 block\n    side = 8\n    x0 = nx_C // 2 - side // 2\n    x1 = x0 + side\n    y0 = ny_C // 2 - side // 2\n    y1 = y0 + side\n    obstacle_C = build_obstacle_mask(ny_C, nx_C, y0, y1, x0, x1)\n    omega_C, it_C = empirical_omega_opt(\n        nx_C, ny_C, bvals_C,\n        obstacle_mask=obstacle_C, obstacle_value=0.5,\n        tol=tol, max_iters=max_iters\n    )\n    results.append([omega_C, it_C])\n\n    # Final output in the exact required format\n    # Print a single line: [[omegaA,iterA],[omegaB,iterB],[omegaC,iterC]]\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2397060"}]}