{"hands_on_practices": [{"introduction": "幂法是计算主导特征对 ($A v = \\lambda v$) 的基本迭代算法，但当主导特征值之间靠得很近时，其收敛速度会变得非常缓慢。本练习将指导您亲手实现幂法和霍特林（Hotelling）降维法。通过这个过程，您将通过经验验证，降维如何通过解决收敛缓慢的问题，从而显著加速寻找后续特征对的过程 [@problem_id:2384610]。", "problem": "考虑使用迭代法计算实对称矩阵的多个特征对的问题。从特征值和特征向量的核心定义开始：对于一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，一个特征对 $(\\lambda, v)$ 满足 $A v = \\lambda v$，其中 $v \\neq 0$。非零向量 $x$ 的瑞利商为 $r(x) = \\dfrac{x^{\\top} A x}{x^{\\top} x}$，对于单位向量 $x$，则有 $r(x) = x^{\\top} A x$。幂法通过重复应用矩阵 $A$ 并进行归一化来构造一个序列，$x_{k+1} = \\dfrac{A x_k}{\\|A x_k\\|_2}$，并监视 $r(x_k)$ 是否收敛。降阶是在计算出近似的主特征对 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 后对矩阵 $A$ 进行变换，通过构建一个降阶矩阵 $A_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}$ 来实现，其中 $\\widehat{v}_1$ 已被归一化为单位长度。对于对称矩阵 $A$，如果 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 是精确的，则 $A_{\\text{def}}$ 的最大模特征值近似于 $A$ 的第二大特征值。\n\n你的任务是仅使用上述定义和基本的线性代数运算来实现以下内容：\n\n1) 实现用于实对称矩阵 $A$ 的幂法：\n- 初始化一个随机向量 $x_0 \\in \\mathbb{R}^n$，其元素为独立的标准正态分布项，然后将其归一化为单位长度。\n- 迭代 $x_{k+1} = \\dfrac{A x_k}{\\|A x_k\\|_2}$。\n- 在每次迭代中，计算瑞利商 $r_k = x_k^{\\top} A x_k$。\n- 当瑞利商的绝对变化满足 $|r_k - r_{k-1}| < \\tau$ 时停止，其中 $\\tau$ 是给定的容差。\n- 统计满足停止条件所需的迭代次数 $k$。\n\n2) 对归一化后的特征向量近似值执行 Hotelling 降阶法：给定 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 且 $\\|\\widehat{v}_1\\|_2 = 1$，构建 $A_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}$。\n\n3) 通过构造具有指定谱的矩阵，演示当谱隙较小时幂法的收敛缓慢，并展示通过降阶法寻找第二个特征对时的显著加速。将 $A$ 构造成 $A = Q \\Lambda Q^{\\top}$，其中 $\\Lambda = \\operatorname{diag}(\\lambda_1, \\ldots, \\lambda_n)$，$Q$ 是一个正交矩阵，通过对一个具有标准正态分布项的随机矩阵进行正交三角分解（QR分解）得到。使用一个带有固定整数种子的伪随机数生成器，以使 $Q$ 可复现。\n\n4) 对于下述每个测试用例：\n- 根据指定的谱构建矩阵 $A$。\n- 对 $A$ 应用幂法以计算 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$，并记录满足停止条件所需的迭代次数 $k_1$。\n- 构建 $A_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}$。\n- 对 $A_{\\text{def}}$ 应用幂法以计算第二个特征值的近似值，并记录满足停止条件所需的迭代次数 $k_2$。\n\n使用以下参数值作为测试套件：\n- 通用参数：维度 $n = 5$；容差 $\\tau = 10^{-10}$；每次调用幂法允许的最大迭代次数 $k_{\\max} = 200000$；对于每个用例，将正交矩阵 $Q$ 生成为具有所述种子的 $n \\times n$ 标准正态矩阵的QR分解的 $Q$ 因子，并在 $Q$ 形成后立即从同一个伪随机数生成器为每次幂法调用生成初始向量 $x_0$（将 $x_0$ 归一化为单位长度）。所有随机数都是无量纲的。\n- 用例 $\\mathrm{A}$ (小谱隙)：谱系 $\\{\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4, \\lambda_5\\} = \\{1, 1 - 10^{-2}, 0.2, 0.1, 0.05\\}$，种子 $s = 123$。\n- 用例 $\\mathrm{B}$ (极小谱隙)：谱系 $\\{\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4, \\lambda_5\\} = \\{1, 1 - 10^{-3}, 0.2, 0.1, 0.05\\}$，种子 $s = 456$。\n- 用例 $\\mathrm{C}$ (大谱隙)：谱系 $\\{\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4, \\lambda_5\\} = \\{1, 0.5, 0.2, 0.1, 0.05\\}$，种子 $s = 789$。\n\n你的程序必须生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来，顺序如下：\n- $[k_1^{(\\mathrm{A})}, k_2^{(\\mathrm{A})}, k_1^{(\\mathrm{B})}, k_2^{(\\mathrm{B})}, k_1^{(\\mathrm{C})}, k_2^{(\\mathrm{C})}]$，\n其中 $k_1^{(\\cdot)}$ 是对 $A$ 第一次调用幂法时的迭代次数，$k_2^{(\\cdot)}$ 是对 $A_{\\text{def}}$ 调用时的迭代次数。每个 $k$ 都必须以整数形式报告。此问题不涉及任何物理单位，也不需要角度或百分比。", "solution": "该问题要求实现并演示如何结合使用幂法和 Hotelling 降阶法来计算一个实对称矩阵的前两个特征对。问题的核心在于阐明幂法收敛速度对谱隙的依赖性，并展示在寻找次主特征对时，降阶法如何规避慢收敛问题。\n\n首先，我们建立理论背景。对于一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其特征值为 $|\\lambda_1| > |\\lambda_2| \\ge \\dots \\ge |\\lambda_n|$，且对应的特征向量为标准正交集 $\\{v_1, v_2, \\dots, v_n\\}$，幂法是一种旨在寻找主特征对 $(\\lambda_1, v_1)$ 的迭代算法。其迭代步骤由下式给出\n$$\nx_{k+1} = \\frac{A x_k}{\\|A x_k\\|_2}\n$$\n其中 $x_0$ 是一个不与 $v_1$ 正交的初始向量。对于随机选择的 $x_0$，此条件以概率 $1$ 成立。向量序列 $\\{x_k\\}$ 收敛于 $\\pm v_1$。收敛速率由比率 $|\\lambda_2 / \\lambda_1|$ 决定。如果这个比率接近 $1$，则谱隙很小，收敛会很慢。\n\n特征值 $\\lambda_1$ 可以使用瑞利商来估计，对于非零向量 $x$，其定义为 $r(x) = \\frac{x^{\\top} A x}{x^{\\top} x}$。当 $x_k \\to v_1$ 时，瑞利商 $r(x_k)$ 收敛于 $\\lambda_1$。问题指定的停止准则为 $|r_k - r_{k-1}| < \\tau$，其中 $r_k = x_k^{\\top} A x_k$（假设 $x_k$ 是单位向量），$\\tau$ 是一个很小的容差。因此，需要实现的算法如下：\n1. 初始化一个归一化的随机向量 $x_0$。令 $x \\leftarrow x_0$。\n2. 计算一个初始瑞利商 $r_{\\text{old}} = x^{\\top} A x$。\n3. 对于 $k=1, 2, \\dots, k_{\\max}$：\n    a. 计算下一个迭代向量：$x_{\\text{next}} = A x / \\|A x\\|_2$。\n    b. 更新向量：$x \\leftarrow x_{\\text{next}}$。\n    c. 计算新的瑞利商：$r_{\\text{new}} = x^{\\top} A x$。\n    d. 检查是否收敛：如果 $|r_{\\text{new}} - r_{\\text{old}}| < \\tau$，则终止并报告迭代次数 $k$。\n    e. 为下一次迭代更新：$r_{\\text{old}} \\leftarrow r_{\\text{new}}$。\n对问题陈述的字面解释要求每次迭代进行两次矩阵-向量乘积，这在计算上是低效的。更标准的实现会重用中间乘积 $A x$。然而，我们将严格遵循所述的公式。\n\n一旦找到了主特征对的近似值 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$（其中 $\\|\\widehat{v}_1\\|_2=1$），Hotelling 降阶法会构造一个新矩阵：\n$$\nA_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}\n$$\n如果 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 是一个精确的特征对 $(\\lambda_1, v_1)$，那么 $A$ 的特征向量 $v_2, \\dots, v_n$ 也是 $A_{\\text{def}}$ 的特征向量，并且具有相同的特征值 $\\lambda_2, \\dots, \\lambda_n$。向量 $v_1$ 成为 $A_{\\text{def}}$ 的一个特征向量，其特征值为 $0$。因此，$A_{\\text{def}}$ 的主特征值是 $\\lambda_2$。对 $A_{\\text{def}}$ 应用幂法将能计算出原始矩阵 $A$ 的第二个特征对。第二阶段的收敛速率将取决于比率 $|\\lambda_3 / \\lambda_2|$。对于问题中提供的谱，该比率远小于1，这预示着与在小谱隙存在的情况下寻找 $\\lambda_1$ 相比，收敛速度将显著加快。\n\n每个测试用例的总体流程如下：\n1.  为伪随机数生成器设置种子，以确保可复现性。\n2.  构造对称矩阵 $A = Q \\Lambda Q^{\\top}$，其中 $\\Lambda$ 是指定特征值的对角矩阵，$Q$ 是通过对一个具有标准正态分布项的 $n \\times n$ 随机矩阵进行 QR 分解得到的正交矩阵。\n3.  为第一次幂法运行生成一个随机、归一化的初始向量 $x_0$。\n4.  对 $A$ 应用以 $x_0$ 为初始向量的幂法，找到 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 和迭代次数 $k_1$。\n5.  构造降阶矩阵 $A_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}$。\n6.  为第二次幂法运行生成一个新的随机、归一化的初始向量。\n7.  对 $A_{\\text{def}}$ 应用幂法，找到第二个特征值的近似值，并记录迭代次数 $k_2$。\n8.  最终输出整理所有指定测试用例的迭代次数 $\\{k_1, k_2\\}$。\n\n测试用例旨在阐释这一理论：用例 A 和 B 的谱隙很小（$1 - \\lambda_2/\\lambda_1$ 分别为 $10^{-2}$ 和 $10^{-3}$），这应该导致 $k_1$ 的值很大。用例 C 的谱隙较大，这应该导致一个较小的 $k_1$。在所有用例中，$\\lambda_2$ 和 $\\lambda_3$ 之间的间隔都很大，因此预计 $k_2$ 会很小，从而证明了降阶法的有效性。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef power_method(A, x0, tolerance, max_iter):\n    \"\"\"\n    Implements the power method for a real symmetric matrix.\n\n    Args:\n        A (np.ndarray): The symmetric matrix.\n        x0 (np.ndarray): The initial normalized vector.\n        tolerance (float): The stopping condition tolerance.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        tuple: A tuple containing:\n            - r_new (float): The estimated eigenvalue.\n            - x (np.ndarray): The estimated eigenvector.\n            - k (int): The number of iterations performed.\n        Returns (None, None, max_iter) if convergence is not achieved.\n    \"\"\"\n    n = A.shape[0]\n    x = x0.copy()\n    \n    # This implementation follows the problem description literally, which requires\n    # two matrix-vector products per iteration. One to update the vector,\n    # and one to compute the new Rayleigh quotient.\n    r_old = x.T @ A @ x\n\n    for k in range(1, max_iter + 1):\n        # Update step for the vector\n        Ax = A @ x\n        norm_Ax = np.linalg.norm(Ax)\n        if norm_Ax == 0:\n            # This can happen for the deflated matrix if x aligns with v1\n            return 0.0, x, k\n        x = Ax / norm_Ax\n\n        # Compute new Rayleigh quotient and check for convergence\n        r_new = x.T @ A @ x\n        \n        if np.abs(r_new - r_old) < tolerance:\n            return r_new, x, k\n        \n        r_old = r_new\n\n    return r_old, x, max_iter\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the power method and deflation experiments.\n    \"\"\"\n    # Common parameters\n    n = 5\n    tolerance = 1e-10\n    max_iter = 200000\n\n    test_cases = [\n        # Case A (small spectral gap)\n        (123, np.array([1.0, 1.0 - 1e-2, 0.2, 0.1, 0.05])),\n        # Case B (very small spectral gap)\n        (456, np.array([1.0, 1.0 - 1e-3, 0.2, 0.1, 0.05])),\n        # Case C (large spectral gap)\n        (789, np.array([1.0, 0.5, 0.2, 0.1, 0.05])),\n    ]\n\n    results = []\n\n    for seed, spectrum in test_cases:\n        rng = np.random.default_rng(seed)\n        \n        # 1. Construct the matrix A = Q * Lambda * Q^T\n        Lambda = np.diag(spectrum)\n        M = rng.standard_normal((n, n))\n        Q, _ = qr(M)\n        A = Q @ Lambda @ Q.T\n\n        # 2. Apply power method to A to find the first eigenpair\n        x0_1 = rng.standard_normal(n)\n        x0_1 /= np.linalg.norm(x0_1)\n        lambda_hat_1, v_hat_1, k1 = power_method(A, x0_1, tolerance, max_iter)\n        \n        # 3. Form the deflated matrix A_def\n        A_def = A - lambda_hat_1 * np.outer(v_hat_1, v_hat_1)\n\n        # 4. Apply power method to A_def to find the second eigenpair\n        x0_2 = rng.standard_normal(n)\n        x0_2 /= np.linalg.norm(x0_2)\n        _, _, k2 = power_method(A_def, x0_2, tolerance, max_iter)\n        \n        results.extend([k1, k2])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2384610"}, {"introduction": "幂法的成功依赖于初始猜测向量不与主导特征向量正交。那么，当初始向量“几乎”与降维后矩阵的主导特征向量正交时，会对收敛速度产生什么影响呢？通过一个精确控制的数值实验，本练习让您量化初始向量的方向与计算出的特征值精度之间的关系，从而揭示算法数值稳定性的一个关键方面 [@problem_id:2384633]。", "problem": "考虑一个具有严格有序特征值的实对称矩阵。设 $A \\in \\mathbb{R}^{3 \\times 3}$ 是对角矩阵\n$$\nA = \\mathrm{diag}(5,3,1),\n$$\n其标准正交特征向量是与特征值 $\\lambda_1 = 5$、$\\lambda_2 = 3$ 和 $\\lambda_3 = 1$ 分别对应的标准基向量 $e_1, e_2, e_3 \\in \\mathbb{R}^3$。定义消去主特征对影响的降阶矩阵为\n$$\nA_{\\mathrm{def}} = A - \\lambda_1 \\, e_1 e_1^\\top.\n$$\n对于一个由角度 $\\theta \\in \\mathbb{R}$ 参数化的初始向量 $x^{(0)}(\\theta)$，令\n$$\nx^{(0)}(\\theta) = \\cos(\\theta) \\, e_2 + \\sin(\\theta) \\, e_3,\n$$\n使得初始猜测向量位于由 $e_2$ 和 $e_3$ 张成的不变子空间中，并与 $e_2$ 成 $\\theta$角。考虑通过在每一步中重复应用降阶矩阵并进行归一化所定义的序列：\n$$\nx^{(k)} = \\frac{A_{\\mathrm{def}} x^{(k-1)}}{\\lVert A_{\\mathrm{def}} x^{(k-1)} \\rVert_2}, \\quad k = 1,2,\\dots, T,\n$$\n其中 $\\lVert \\cdot \\rVert_2$ 表示欧几里得范数，T 是一个固定的正整数。经过 $T$ 次迭代后，通过瑞利商近似 $A_{\\mathrm{def}}$ 的主特征值\n$$\n\\widehat{\\mu}_T(\\theta) = \\left(x^{(T)}(\\theta)\\right)^\\top A_{\\mathrm{def}} \\, x^{(T)}(\\theta).\n$$\n通过相对于真实第二特征值 $\\lambda_2 = 3$ 的相对误差来量化降阶特征值近似的精度：\n$$\n\\varepsilon(\\theta) = \\frac{\\left| \\widehat{\\mu}_T(\\theta) - \\lambda_2 \\right|}{\\left| \\lambda_2 \\right|}.\n$$\n使用以弧度表示的角度。设置迭代次数为 $T = 5$。对下列初始角度测试集计算相对误差 $\\varepsilon(\\theta)$：\n$$\n\\theta \\in \\left\\{ 0,\\; \\frac{\\pi}{4},\\; \\frac{\\pi}{2} - 10^{-8},\\; \\frac{\\pi}{2},\\; \\frac{\\pi}{2} - 10^{-3} \\right\\}.\n$$\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$）的结果，其顺序与上述角度的顺序相同。每个 $r_i$ 必须是浮点数，表示指定集合中对应 $\\theta$ 的 $\\varepsilon(\\theta)$ 值。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 矩阵：$A = \\mathrm{diag}(5, 3, 1)$，一个实对称矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$。\n- $A$ 的特征值：$\\lambda_1 = 5$，$\\lambda_2 = 3$，$\\lambda_3 = 1$。\n- $A$ 的特征向量：标准正交的标准基向量 $e_1, e_2, e_3 \\in \\mathbb{R}^3$，分别与 $\\lambda_1, \\lambda_2, \\lambda_3$ 相关联。\n- 降阶矩阵：$A_{\\mathrm{def}} = A - \\lambda_1 \\, e_1 e_1^\\top$。\n- 初始向量参数化：$x^{(0)}(\\theta) = \\cos(\\theta) \\, e_2 + \\sin(\\theta) \\, e_3$。\n- 迭代格式（归一化幂法）：$x^{(k)} = \\frac{A_{\\mathrm{def}} x^{(k-1)}}{\\lVert A_{\\mathrm{def}} x^{(k-1)} \\rVert_2}$。\n- 迭代次数：$T = 5$。\n- 特征值近似：瑞利商 $\\widehat{\\mu}_T(\\theta) = \\left(x^{(T)}(\\theta)\\right)^\\top A_{\\mathrm{def}} \\, x^{(T)}(\\theta)$。\n- 误差度量：相对误差 $\\varepsilon(\\theta) = \\frac{\\left| \\widehat{\\mu}_T(\\theta) - \\lambda_2 \\right|}{\\left| \\lambda_2 \\right|}$。\n- 测试角度（以弧度为单位）：$\\theta \\in \\left\\{ 0,\\; \\frac{\\pi}{4},\\; \\frac{\\pi}{2} - 10^{-8},\\; \\frac{\\pi}{2},\\; \\frac{\\pi}{2} - 10^{-3} \\right\\}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，采用了数值线性代数中的标准概念：特征值问题、矩阵降阶和幂迭代法。整个设定是自洽的，提供了所有必要的参数和定义。逻辑上是一致的，而且任务是适定的，对于每个指定的初始条件都有唯一且可验证的解。没有矛盾、歧义或事实性错误。初始向量是迭代矩阵的一个特征向量这一特殊情况，是该算法分析中的一个标准场景，并不构成缺陷。\n\n**步骤 3：结论与操作**\n问题是有效的。将提供一个完整的解决方案。\n\n该问题要求对通过幂法在降阶矩阵上计算的特征值的精度进行数值评估。我们首先对迭代过程进行严格分析。矩阵 $A$ 已知为 $A = \\mathrm{diag}(5, 3, 1)$。其特征对为 $(\\lambda_1, e_1) = (5, [1,0,0]^\\top)$、$(\\lambda_2, e_2) = (3, [0,1,0]^\\top)$ 和 $(\\lambda_3, e_3) = (1, [0,0,1]^\\top)$。降阶矩阵构造为 $A_{\\mathrm{def}} = A - \\lambda_1 e_1 e_1^\\top$。代入给定值，我们有：\n$$\nA_{\\mathrm{def}} = \\begin{pmatrix} 5 & 0 & 0 \\\\ 0 & 3 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - 5 \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 5 & 0 & 0 \\\\ 0 & 3 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - \\begin{pmatrix} 5 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 \\\\ 0 & 3 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}.\n$$\n$A_{\\mathrm{def}}$ 的特征值为 $\\mu_1 = 3$、$\\mu_2 = 1$ 和 $\\mu_3 = 0$，对应的特征向量为 $e_2$、$e_3$ 和 $e_1$。当应用于 $A_{\\mathrm{def}}$ 时，幂迭代法旨在收敛到与模最大特征值相关联的特征向量，即 $\\mu_1=3$（等于 $\\lambda_2$）。初始向量由 $x^{(0)}(\\theta) = \\cos(\\theta) e_2 + \\sin(\\theta) e_3$ 给出。该向量位于由 $\\{e_2, e_3\\}$ 张成的不变子空间中，且与 $e_1$ 正交。因此，所有后续的迭代向量 $x^{(k)}$ 都将保留在该子空间中。我们来分析一次迭代对该子空间中向量 $v = c_2 e_2 + c_3 e_3$ 的影响：\n$$\nA_{\\mathrm{def}} v = A_{\\mathrm{def}}(c_2 e_2 + c_3 e_3) = c_2 (A_{\\mathrm{def}} e_2) + c_3 (A_{\\mathrm{def}} e_3) = c_2 (\\mu_1 e_2) + c_3 (\\mu_2 e_3) = 3 c_2 e_2 + 1 c_3 e_3.\n$$\n应用 $A_{\\mathrm{def}}$ 会将沿 $e_2$ 的分量缩放 3 倍，沿 $e_3$ 的分量缩放 1 倍。沿 $e_3$ 的分量与沿 $e_2$ 的分量之比从 $c_3/c_2$ 变为 $(1 c_3)/(3 c_2) = (1/3)(c_3/c_2)$。对于初始向量 $x^{(0)}(\\theta)$，该比率为 $\\sin(\\theta)/\\cos(\\theta) = \\tan(\\theta)$。一次迭代后，未归一化的向量为 $3\\cos(\\theta) e_2 + \\sin(\\theta) e_3$。现在分量的比率为 $(1/3)\\tan(\\theta)$。$k$ 次迭代后，未归一化的向量将与 $3^k \\cos(\\theta) e_2 + 1^k \\sin(\\theta) e_3$ 成比例。$e_3$ 分量与 $e_2$ 分量之比将为 $(1/3)^k \\tan(\\theta)$。归一化的向量 $x^{(k)}(\\theta)$ 可以写成 $x^{(k)}(\\theta) = \\cos(\\theta_k) e_2 + \\sin(\\theta_k) e_3$，其中 $\\tan(\\theta_k) = (1/3)^k \\tan(\\theta)$。$T$ 次迭代后，最终向量为 $x^{(T)}(\\theta) = \\cos(\\theta_T) e_2 + \\sin(\\theta_T) e_3$，其中 $\\tan(\\theta_T) = (1/3)^T \\tan(\\theta)$。现在我们计算瑞利商：\n$$\n\\widehat{\\mu}_T(\\theta) = (x^{(T)})^\\top A_{\\mathrm{def}} x^{(T)} = (\\cos(\\theta_T) e_2 + \\sin(\\theta_T) e_3)^\\top (3\\cos(\\theta_T) e_2 + \\sin(\\theta_T) e_3).\n$$\n利用 $e_2$ 和 $e_3$ 的标准正交性，我们得到：\n$$\n\\widehat{\\mu}_T(\\theta) = 3\\cos^2(\\theta_T) + \\sin^2(\\theta_T) = 3\\cos^2(\\theta_T) + (1 - \\cos^2(\\theta_T)) = 1 + 2\\cos^2(\\theta_T).\n$$\n那么，相对于 $\\lambda_2 = 3$ 的相对误差 $\\varepsilon(\\theta)$ 为：\n$$\n\\varepsilon(\\theta) = \\frac{|\\widehat{\\mu}_T(\\theta) - \\lambda_2|}{|\\lambda_2|} = \\frac{|(1 + 2\\cos^2(\\theta_T)) - 3|}{3} = \\frac{|2\\cos^2(\\theta_T) - 2|}{3} = \\frac{2| \\cos^2(\\theta_T) - 1 |}{3} = \\frac{2}{3}\\sin^2(\\theta_T).\n$$\n利用恒等式 $\\sin^2(\\phi) = \\tan^2(\\phi) / (1+\\tan^2(\\phi))$，我们可以用初始角度 $\\theta$ 来表示误差：\n$$\n\\varepsilon(\\theta) = \\frac{2}{3} \\frac{\\tan^2(\\theta_T)}{1+\\tan^2(\\theta_T)} = \\frac{2}{3} \\frac{(1/3)^{2T} \\tan^2(\\theta)}{1+(1/3)^{2T} \\tan^2(\\theta)}.\n$$\n这个解析结果可以用来验证数值实现的正确性。我们考虑两种特殊情况。如果 $\\theta=0$，则 $x^{(0)} = e_2$，这正是所求的特征向量。迭代过程不改变该向量，因此 $\\widehat{\\mu}_T(0) = 3$ 且 $\\varepsilon(0) = 0$。这与公式一致，因为 $\\tan(0)=0$。如果 $\\theta=\\pi/2$，则 $x^{(0)}=e_3$。这是 $A_{\\mathrm{def}}$ 的另一个特征向量（与 $\\mu_2=1$ 相关联）。迭代对所有 $k$ 都得到 $x^{(k)}=e_3$，因此 $\\widehat{\\mu}_T(\\pi/2) = (e_3)^\\top A_{\\mathrm{def}} e_3 = 1$。相对误差为 $|1 - 3|/3 = 2/3$。当 $\\theta \\to \\pi/2$ 时，由于 $\\tan^2(\\theta) \\to \\infty$，这是我们公式的极限值。当 $\\theta$ 接近 $\\pi/2$ 时，初始向量在 $e_2$ 方向上的分量很小，导致在固定的迭代次数 $T=5$ 后收敛缓慢且误差较大。以下代码通过数值方法实现了规定的迭代过程，以计算所要求的误差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the relative error in eigenvalue approximation\n    using the power method on a deflated matrix.\n    \"\"\"\n    \n    # Define problem parameters\n    T = 5  # Number of iterations\n    lambda2_true = 3.0  # True second eigenvalue of A\n\n    # Define the test suite of initial angles in radians\n    test_angles = [\n        0.0,\n        np.pi / 4.0,\n        np.pi / 2.0 - 1e-8,\n        np.pi / 2.0,\n        np.pi / 2.0 - 1e-3\n    ]\n\n    # The matrix A is diag(5, 3, 1). The deflated matrix A_def = A - lambda1*e1*e1.T\n    # This results in A_def = diag(0, 3, 1).\n    A_def = np.diag([0.0, 3.0, 1.0])\n\n    # Standard basis vectors in R^3\n    e2 = np.array([0.0, 1.0, 0.0])\n    e3 = np.array([0.0, 0.0, 1.0])\n\n    results = []\n    \n    # Iterate through each specified angle\n    for theta in test_angles:\n        # 1. Define the initial vector x^{(0)}\n        x = np.cos(theta) * e2 + np.sin(theta) * e3\n        \n        # 2. Perform T iterations of the normalized power method\n        for _ in range(T):\n            v = A_def @ x\n            norm_v = np.linalg.norm(v)\n            \n            # The norm will not be zero because x is constructed in the invariant\n            # subspace of A_def spanned by e2 and e3.\n            x = v / norm_v\n        \n        x_T = x # Final vector after T iterations\n        \n        # 3. Approximate the dominant eigenvalue of A_def using the Rayleigh quotient\n        mu_hat_T = x_T.T @ A_def @ x_T\n\n        # 4. Quantify the accuracy by the relative error\n        relative_error = np.abs(mu_hat_T - lambda2_true) / np.abs(lambda2_true)\n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2384633"}, {"introduction": "降维技术通过变换矩阵来“移除”一个已知的特征对。我们能否逆转这个过程，即向矩阵中“注入”一个特定的特征对呢？这个“增维”挑战要求您构建一个新矩阵，它不仅包含一个预设的特征对 $(\\lambda_0, v_0)$，同时还保留另一个给定矩阵的谱，这将加深您对矩阵结构、相似变换及谱性质之间深层联系的理解 [@problem_id:2384661]。", "problem": "构造一个程序，针对每个测试用例，构建一个实数方阵 $A \\in \\mathbb{R}^{n \\times n}$，该方阵具有一个预设的目标特征对 $(\\lambda_0, v_0)$，且其剩余特征值与一个给定的较小实数方阵 $A_0 \\in \\mathbb{R}^{(n-1) \\times (n-1)}$ 的谱重合，所有特征值都计及其代数重数。对于每个测试用例，给定一个实数标量 $\\lambda_0 \\in \\mathbb{R}$、一个非零实数向量 $v_0 \\in \\mathbb{R}^n$ 以及一个实数矩阵 $A_0 \\in \\mathbb{R}^{(n-1) \\times (n-1)}$。您的程序必须为每个用例构造一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$，使得：\n- $(\\lambda_0, v_0)$ 是 $A$ 的一个特征对，即 $A v_0 = \\lambda_0 v_0$，并且\n- $A$ 的特征值多重集等于 $\\{\\lambda_0\\} \\cup \\sigma(A_0)$，其中 $\\sigma(A_0)$ 表示 $A_0$ 的特征值多重集。\n\n为了进行数值验证，定义一个容差 $\\tau = 10^{-8}$。对于每个构造的矩阵 $A$，您的程序必须验证以下两个条件是否都成立：\n1. 特征对残差条件：残差的欧几里得范数满足 $\\|A v_0 - \\lambda_0 v_0\\|_2 \\le \\tau \\cdot \\max\\{1, (\\|A\\|_2 + |\\lambda_0|)\\|v_0\\|_2\\}$。\n2. 谱匹配条件：从 $A$ 的特征值中移除一个与 $\\lambda_0$ 模长最接近的特征值后（以计入目标特征值），$A$ 的剩余特征值多重集在以下意义上与 $\\sigma(A_0)$ 在容差范围内匹配：对于 $\\sigma(A_0)$ 中的每个 $\\mu$，在 $A$ 的剩余特征值中存在一个不同的特征值 $\\nu$，使得 $|\\nu - \\mu| \\le \\tau \\cdot \\max\\{1, |\\mu|\\}$。\n\n测试套件的数值如下。对于每个用例，$n$ 是 $v_0$ 的长度，且 $A_0 \\in \\mathbb{R}^{(n-1)\\times(n-1)}$：\n- 用例 1：$\\lambda_0 = -1.5$, $v_0 = [\\,2,\\,-1,\\,0,\\,2\\,]^\\top$, $A_0 = \\begin{bmatrix} 0 & 2 & 0 \\\\ -2 & 0 & 0 \\\\ 0 & 0 & 3 \\end{bmatrix}$。\n- 用例 2：$\\lambda_0 = 0$, $v_0 = [\\,1,\\,1,\\,1\\,]^\\top$, $A_0 = \\begin{bmatrix} 5 & 0 \\\\ 0 & 5 \\end{bmatrix}$。\n- 用例 3：$\\lambda_0 = 7$, $v_0 = [\\,0,\\,1\\,]^\\top$, $A_0 = \\begin{bmatrix} -3 \\end{bmatrix}$。\n- 用例 4：$\\lambda_0 = 2$, $v_0 = [\\,1,\\,0,\\,0\\,]^\\top$, $A_0 = \\begin{bmatrix} 4 & 1 \\\\ 0 & 4 \\end{bmatrix}$。\n\n您的程序必须按顺序为每个用例输出一个布尔值，表示两个验证条件是否都成立。最终输出必须是单行文本，包含一个由方括号括起来的、用逗号分隔的布尔值列表。例如，输出格式必须类似于“[result1,result2,result3,result4]”（不含空格）。本问题不涉及角度或物理单位。所有数值比较都必须使用指定的容差 $\\tau = 10^{-8}$。", "solution": "问题陈述经审阅，确认有效。它提出了一个数值线性代数领域中明确定义的任务，不存在科学或逻辑上的不一致之处。目标是构造一个实数矩阵 $A \\in \\mathbb{R}^{n \\times n}$，使其满足两个条件：它必须拥有一个指定的特征对 $(\\lambda_0, v_0)$，并且其剩余的谱必须与给定矩阵 $A_0 \\in \\mathbb{R}^{(n-1) \\times (n-1)}$ 的谱相匹配。我们接下来推导一个构造性的解法。\n\n我们方法的核心在于使用相似变换。如果存在某个可逆矩阵 $P$ 使得 $A = P B P^{-1}$，则称矩阵 $A$ 与矩阵 $B$ 相似。相似矩阵具有相同的谱（特征值及其代数重数）。我们的目标是审慎地选择 $P$ 和 $B$，以满足给定的特征对和谱属性。\n\n设给定的特征向量为 $v_0 \\in \\mathbb{R}^n$，其中 $v_0 \\neq 0$。我们首先为 $\\mathbb{R}^n$ 构造一组特殊的基。令 $u_0 = v_0 / \\|v_0\\|_2$ 为单位化的特征向量。然后我们将 $\\{u_0\\}$ 扩充为 $\\mathbb{R}^n$ 的一组标准正交基，记作 $\\{u_0, u_1, \\dots, u_{n-1}\\}$。令 $U$ 为列向量是这些基向量的正交矩阵：$U = [u_0 | u_1 | \\dots | u_{n-1}]$。由于 $U$ 是正交矩阵，其逆矩阵等于其转置，即 $U^{-1} = U^\\top$。\n\n我们通过相似变换 $A = U B U^\\top$ 来定义矩阵 $A$。现在我们必须确定 $B$ 的结构以满足问题的条件。\n\n首先，我们施加特征对条件 $A v_0 = \\lambda_0 v_0$。代入 $A$ 的定义以及 $v_0 = \\|v_0\\|_2 u_0$，我们得到：\n$$\n(U B U^\\top) (\\|v_0\\|_2 u_0) = \\lambda_0 (\\|v_0\\|_2 u_0)\n$$\n由于 $\\|v_0\\|_2$ 是一个非零标量，我们可以将其简化为 $U B U^\\top u_0 = \\lambda_0 u_0$。从左侧乘以 $U^\\top$ 可得：\n$$\nB (U^\\top u_0) = \\lambda_0 (U^\\top u_0)\n$$\n根据构造，$u_0$ 是 $U$ 的第一列。因此，$U^\\top u_0$ 是向量 $e_1 = [1, 0, \\dots, 0]^\\top$。该条件简化为 $B e_1 = \\lambda_0 e_1$。这个方程意味着矩阵 $B$ 的第一列必须是 $[\\lambda_0, 0, \\dots, 0]^\\top$。因此，$B$ 必须具有上三角分块结构：\n$$\nB = \\begin{bmatrix} \\lambda_0 & w^\\top \\\\ 0 & C \\end{bmatrix}\n$$\n其中 $w \\in \\mathbb{R}^{n-1}$ 是一个任意行向量，$C \\in \\mathbb{R}^{(n-1) \\times (n-1)}$ 是某个矩阵。\n\n其次，我们考虑谱条件。$A$ 的谱，记作 $\\sigma(A)$，必须为 $\\{\\lambda_0\\} \\cup \\sigma(A_0)$。由于 $A$ 和 $B$ 相似，所以 $\\sigma(A) = \\sigma(B)$。分块三角矩阵的特征值是其对角线上各分块矩阵特征值的并集。因此，$B$ 的谱为 $\\{\\lambda_0\\} \\cup \\sigma(C)$。\n为了满足问题的要求，我们必须有 $\\sigma(C) = \\sigma(A_0)$。虽然存在许多与 $A_0$ 相似并因此共享其谱的矩阵 $C$，但最简单和最直接的选择是令 $C = A_0$。\n\n行向量 $w^\\top$ 不影响 $B$ 的特征值。它的选择会影响 $A$ 的特征向量（除 $v_0$ 外），但不会影响所需的谱属性。为简单起见，我们选择 $w=0$。这使得 $B$ 具有分块对角形式：\n$$\nB = \\begin{bmatrix} \\lambda_0 & 0 \\\\ 0 & A_0 \\end{bmatrix}\n$$\n\n通过这些选择，矩阵 $A$ 的最终构造为：\n$$\nA = U \\begin{bmatrix} \\lambda_0 & 0 \\\\ 0 & A_0 \\end{bmatrix} U^\\top\n$$\n构造 $A$ 的步骤如下：\n1.  给定 $v_0$，将其单位化以获得 $u_0 = v_0 / \\|v_0\\|_2$。\n2.  为 $u_0$ 的正交补构造一组标准正交基。这等价于找到 $u_0^\\top$ 的零空间的一组标准正交基。令列向量为这些基向量的矩阵为 $U_1 \\in \\mathbb{R}^{n \\times (n-1)}$。\n3.  构造正交矩阵 $U = [u_0 | U_1]$。\n4.  构造分块对角矩阵 $B = \\text{scipy.linalg.block\\_diag}(\\lambda_0, A_0)$。\n5.  计算 $A = U B U^\\top$。由于 $\\lambda_0$、$v_0$ 和 $A_0$ 都是实数， $U$ 和 $B$ 可以构造成实数矩阵，从而确保 $A$ 也是实数矩阵。\n\n对于数值验证，必须用容差 $\\tau = 10^{-8}$ 检查两个条件。\n1.  特征对残差条件 $\\|A v_0 - \\lambda_0 v_0\\|_2 \\le \\tau \\cdot \\max\\{1, (\\|A\\|_2 + |\\lambda_0|)\\|v_0\\|_2\\}$，通过直接计算相关范数来检查。\n2.  谱匹配条件要求将 $A_0$ 的特征值多重集 $\\sigma(A_0)$ 与从 $A$ 的特征值中移除一个与 $\\lambda_0$ 模长最接近的特征值后得到的特征值多重集进行比较。令 $A$ 的剩余特征值多重集为 $S'_A$。我们必须验证是否存在一个双射 $f: \\sigma(A_0) \\to S'_A$，使得对于 $\\sigma(A_0)$ 中的每个 $\\mu$，其像 $\\nu = f(\\mu)$ 满足 $|\\nu - \\mu| \\le \\tau \\cdot \\max\\{1, |\\mu|\\}$。这是一个二分图上的最小权完美匹配问题，可以通过找到 $\\sigma(A_0)$ 中元素的一个排列，使得该排列与 $S'_A$ 中元素之间的距离总和最小来解决。鉴于测试用例中的维度较小，遍历所有排列是可行的。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import null_space, block_diag\nfrom itertools import permutations\n\ndef solve():\n    \"\"\"\n    Constructs and verifies a matrix A for each test case.\n    \"\"\"\n    test_cases = [\n        {\n            \"lambda0\": -1.5,\n            \"v0\": np.array([2.0, -1.0, 0.0, 2.0]),\n            \"A0\": np.array([[0.0, 2.0, 0.0], [-2.0, 0.0, 0.0], [0.0, 0.0, 3.0]])\n        },\n        {\n            \"lambda0\": 0.0,\n            \"v0\": np.array([1.0, 1.0, 1.0]),\n            \"A0\": np.array([[5.0, 0.0], [0.0, 5.0]])\n        },\n        {\n            \"lambda0\": 7.0,\n            \"v0\": np.array([0.0, 1.0]),\n            \"A0\": np.array([[-3.0]])\n        },\n        {\n            \"lambda0\": 2.0,\n            \"v0\": np.array([1.0, 0.0, 0.0]),\n            \"A0\": np.array([[4.0, 1.0], [0.0, 4.0]])\n        },\n    ]\n\n    results = []\n    tau = 1e-8\n\n    for case in test_cases:\n        lambda0 = case[\"lambda0\"]\n        v0 = case[\"v0\"]\n        A0 = case[\"A0\"]\n        n = len(v0)\n\n        # Step 1: Construct the orthogonal matrix U\n        u0 = v0 / np.linalg.norm(v0)\n        u0_col = u0.reshape(-1, 1)\n\n        # Find an orthonormal basis for the orthogonal complement of u0\n        # This is the null space of u0.T\n        U1 = null_space(u0.reshape(1, -1))\n\n        # Form the full orthogonal matrix U\n        U = np.hstack((u0_col, U1))\n        \n        # Step 2: Construct the block matrix B\n        B = block_diag(lambda0, A0)\n\n        # Step 3: Construct the matrix A\n        A = U @ B @ U.T\n\n        # Step 4: Verification\n        # Condition 1: Eigenpair residual\n        residual_norm = np.linalg.norm(A @ v0 - lambda0 * v0)\n        bound = tau * max(1.0, (np.linalg.norm(A, 2) + np.abs(lambda0)) * np.linalg.norm(v0))\n        cond1_holds = residual_norm <= bound\n        \n        # Condition 2: Spectrum match\n        eigs_A = np.linalg.eigvals(A)\n        eigs_A0 = np.linalg.eigvals(A0)\n        \n        # Find and remove the eigenvalue of A closest in modulus to lambda0\n        idx_to_remove = np.argmin(np.abs(np.abs(eigs_A) - np.abs(lambda0)))\n        eigs_A_rem = np.delete(eigs_A, idx_to_remove)\n        \n        # Sort remaining eigenvalues for a canonical order\n        eigs_A_rem = np.sort(eigs_A_rem)\n        \n        cond2_holds = False\n        # Check all permutations of eigs_A0 to find a valid matching\n        for p in permutations(eigs_A0):\n            p_arr = np.array(p)\n            # Check the tolerance for this permutation\n            errors = np.abs(eigs_A_rem - p_arr)\n            tolerances = tau * np.maximum(1.0, np.abs(p_arr))\n            if np.all(errors <= tolerances):\n                cond2_holds = True\n                break\n        \n        results.append(cond1_holds and cond2_holds)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2384661"}]}