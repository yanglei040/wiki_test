{"hands_on_practices": [{"introduction": "要真正理解一个算法，我们不仅要探索它成功的情况，也要研究它失效的场景。第一个练习要求你实现基础的、无位移的 QR 算法，并将其应用于一个著名的、无法收敛并会进入循环的特定矩阵上。通过亲手观察这种行为 [@problem_id:2431496]，你将具体理解简单 QR 迭代的局限性，并认识到位移策略等增强技术的重要性。", "problem": "给定实数方阵和以下基于正交-上三角 (QR) 分解的迭代映射。对于给定的实数矩阵 $A^{(0)} \\in \\mathbb{R}^{n \\times n}$，通过以下规则定义序列 $\\{A^{(k)}\\}_{k=0}^{\\infty}$：对于每个迭代指数 $k \\ge 0$，计算正交-上三角 (QR) 分解 $A^{(k)} = Q^{(k)} R^{(k)}$，其中 $Q^{(k)}$ 是正交矩阵，$R^{(k)}$ 是对角线元素为正的上三角矩阵，然后设置\n$$\nA^{(k+1)} = R^{(k)} Q^{(k)}.\n$$\n考虑以下针对 $2 \\times 2$ 实数矩阵的判定问题：在容差 $\\tau = 10^{-12}$ 和最大迭代次数 $k_{\\max} = 100$ 的条件下运行上述迭代。使用以下互斥规则对序列的行为进行分类：\n- 收敛到上三角矩阵：如果对于某个 $k \\le k_{\\max}$，$A^{(k)}$ 的严格下三角部分的欧几里得范数满足 $\\lVert \\operatorname{tril}(A^{(k)}, -1) \\rVert_{F} < \\tau$，则报告整数代码 $0$。\n- 检测到长度为 $1$ 的循环：如果对于某个 $k \\le k_{\\max}$，有 $\\lVert A^{(k)} - A^{(k-1)} \\rVert_{F} < \\tau$，则报告整数代码 $1$。\n- 检测到长度为 $2$ 的循环：如果对于某个 $k \\le k_{\\max}$，有 $\\lVert A^{(k)} - A^{(k-2)} \\rVert_{F} < \\tau$，则报告整数代码 $2$。\n- 其它情况：如果在 $k_{\\max}$ 次迭代内未满足上述任何条件，则报告整数代码 $3$。\n\n此处，$\\lVert \\cdot \\rVert_{F}$ 表示弗罗贝尼乌斯范数，$\\operatorname{tril}(\\cdot,-1)$ 提取严格下三角部分，并且 $R^{(k)}$ 的对角线为正的约束必须在每一步强制执行。\n\n使用此判定问题在以下测试矩阵套件上研究该迭代的行为：\n- 测试 $1$ (翻转矩阵): \n$$\nA^{(1)} = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}.\n$$\n- 测试 $2$ (具有不同特征值的对称矩阵): \n$$\nA^{(2)} = \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix}.\n$$\n- 测试 $3$ (单位矩阵): \n$$\nA^{(3)} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}.\n$$\n- 测试 $4$ (对角线为正的上三角矩阵): \n$\nA^{(4)} = \\begin{bmatrix} 1 & 10 \\\\ 0 & 1 \\end{bmatrix}.\n$\n\n对于上述 4 个测试中的每一个，你的程序必须从 $A^{(0)} = A^{(j)}$ (其中 $j \\in \\{1,2,3,4\\}$) 开始运行迭代，并根据上述规则返回相应的整数代码。\n\n最终输出格式：你的程序应产生单行输出，其中包含一个由方括号括起来的、逗号分隔的 4 个整数代码列表（例如，$[c_1,c_2,c_3,c_4]$）。不应打印任何其他文本。此问题不涉及任何物理单位或角度；所有输出都是无单位的整数。", "solution": "对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- **迭代映射**: 对于一个实数矩阵 $A^{(0)} \\in \\mathbb{R}^{n \\times n}$，序列 $\\{A^{(k)}\\}_{k=0}^{\\infty}$ 定义如下：\n  1. $A^{(k)} = Q^{(k)} R^{(k)}$，其中 $Q^{(k)}$ 是正交的，$R^{(k)}$ 是对角线元素为正的上三角矩阵。\n  2. $A^{(k+1)} = R^{(k)} Q^{(k)}$。\n- **$2 \\times 2$ 矩阵的判定问题参数**:\n  - 容差: $\\tau = 10^{-12}$。\n  - 最大迭代次数: $k_{\\max} = 100$。\n- **分类规则**:\n  1.  **代码 0 (收敛到上三角矩阵)**: $\\lVert \\operatorname{tril}(A^{(k)}, -1) \\rVert_{F} < \\tau$ 对于某个 $k \\in [0, k_{\\max}]$。\n  2.  **代码 1 (长度为 1 的循环)**: $\\lVert A^{(k)} - A^{(k-1)} \\rVert_{F} < \\tau$ 对于某个 $k \\in [1, k_{\\max}]$。\n  3.  **代码 2 (长度为 2 的循环)**: $\\lVert A^{(k)} - A^{(k-2)} \\rVert_{F} < \\tau$ 对于某个 $k \\in [2, k_{\\max}]$。\n  4.  **代码 3 (其它情况)**: 未满足上述任何条件。\n- **定义**:\n  - $\\lVert \\cdot \\rVert_{F}$ 是弗罗贝尼乌斯范数。\n  - $\\operatorname{tril}(\\cdot, -1)$ 是矩阵的严格下三角部分。\n- **测试矩阵 ($A^{(0)}$)**:\n  1.  $A^{(1)} = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}$\n  2.  $A^{(2)} = \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix}$\n  3.  $A^{(3)} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$\n  4.  $A^{(4)} = \\begin{bmatrix} 1 & 10 \\\\ 0 & 1 \\end{bmatrix}$\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据**: 该问题描述了纯（无位移）QR 算法，这是数值线性代数中用于特征值计算的一种基础且成熟的方法。所描述的行为和分类规则是分析此类迭代方法收敛性的标准测试。该问题在科学上是合理的。\n- **适定性**: 迭代映射是确定性的。上三角矩阵 $R^{(k)}$ 必须具有正对角线元素的条件确保了对于任何非奇异矩阵 $A^{(k)}$，QR 分解是唯一的。所有初始测试矩阵都是非奇异的，并且由于迭代 $A^{(k+1)} = (Q^{(k)})^T A^{(k)} Q^{(k)}$ 是一个相似变换，所有后续矩阵 $A^{(k)}$ 也都将是非奇异的。分类规则是在每次迭代时执行的条件检查。为确保规则的“互斥”性，必须按特定的优先顺序进行检查。自然的逻辑顺序就是所呈现的顺序：$0, 1, 2, 3$。这使得问题是适定的。\n- **客观性**: 问题使用精确的数学语言陈述，具有明确定义的量、条件和数值。它没有模糊性和主观性。\n\n**第 3 步：结论与行动**\n该问题是**有效的**。将提供一个解决方案。\n\nQR 迭代由序列 $A^{(k+1)} = R^{(k)}Q^{(k)}$ 定义，其中 $A^{(k)} = Q^{(k)}R^{(k)}$。将 $R^{(k)} = (Q^{(k)})^T A^{(k)}$（因为 $Q^{(k)}$ 是正交的）代入更新规则可得 $A^{(k+1)} = (Q^{(k)})^T A^{(k)} Q^{(k)}$。这表明每个 $A^{(k)}$ 都与其前驱正交相似，因此序列 $\\{A^{(k)}\\}$ 中的所有矩阵都与初始矩阵 $A^{(0)}$ 具有相同的特征值。\n\n已知在某些条件下，该算法会收敛到一个上三角（对于复特征值则为拟上三角）Schur 型。具体来说，对于一个具有不同模长特征值 $\\{\\lambda_i\\}$（$|\\lambda_1| > |\\lambda_2| > \\dots > |\\lambda_n|$）的实数矩阵，序列 $A^{(k)}$ 会收敛到一个上三角矩阵，其对角线元素是 $A^{(0)}$ 的特征值。分类规则旨在测试这种收敛性或识别其他行为，如不动点或循环，当特征值模长条件不满足时，这些行为就可能发生。这些规则在从 $0$ 到 $k_{max}$ 的每次迭代 $k$ 中按 $0, 1, 2$ 的顺序检查。\n\n**测试用例分析：**\n\n**测试 1：** $A^{(0)} = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}$。\n该矩阵是对称的。其特征方程为 $\\lambda^2 - 1 = 0$，得到特征值 $\\lambda_1 = 1$ 和 $\\lambda_2 = -1$。特征值的模长相等，$|\\lambda_1| = |\\lambda_2| = 1$，这违反了简单 QR 算法的标准收敛条件。\n为确定其行为，我们计算第一次迭代。我们需要唯一的 QR 分解 $A^{(0)} = Q^{(0)}R^{(0)}$，其中 $R^{(0)}$ 的对角线元素为正。对于 $A^{(0)}$，此分解为 $Q^{(0)} = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}$ 和 $R^{(0)} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = I$。$Q^{(0)}$ 是正交的且 $R^{(0)}$ 是对角线为正的上三角矩阵，这两个条件都满足。\n下一个迭代是 $A^{(1)} = R^{(0)}Q^{(0)} = I Q^{(0)} = Q^{(0)} = A^{(0)}$。\n该序列是常数：对于所有 $k \\ge 0$，$A^{(k)} = A^{(0)}$。这是迭代的一个不动点。\n现在我们应用分类规则：\n- 在 $k=0$ 时：$A^{(0)}$ 是上三角矩阵吗？不是，因为元素 $A_{21}^{(0)} = 1 \\neq 0$。范数 $\\lVert \\operatorname{tril}(A^{(0)},-1)\\rVert_F = 1$，不小于 $\\tau = 10^{-12}$。规则 $0$ 不满足。\n- 在 $k=1$ 时：我们有 $A^{(1)} = A^{(0)}$。\n  - 规则 $0$：$A^{(1)}$ 是上三角矩阵吗？不是。\n  - 规则 $1$：$\\lVert A^{(1)} - A^{(0)} \\rVert_F < \\tau$ 吗？是，因为 $\\lVert A^{(0)} - A^{(0)} \\rVert_F = 0 < \\tau$。\n过程终止并报告代码 $1$。\n\n**测试 2：** $A^{(0)} = \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix}$。\n这是一个对称矩阵。其特征方程是 $(2-\\lambda)^2 - 1 = 0$，得到特征值 $\\lambda_1 = 3$ 和 $\\lambda_2 = 1$。特征值是实数且具有不同的模长，$|3| > |1|$。QR 算法的理论预测，对于这样的矩阵，序列 $A^{(k)}$ 将收敛到一个包含特征值的对角矩阵，按模长排序：$A^{(k)} \\to \\begin{pmatrix} 3 & 0 \\\\ 0 & 1 \\end{pmatrix}$。对角矩阵是上三角矩阵的一种特殊情况。因此，$A^{(k)}$ 的严格下三角部分将收敛到零。对于某个足够大的 $k \\le k_{\\max}$，条件 $\\lVert \\operatorname{tril}(A^{(k)},-1)\\rVert_F < \\tau$ 将被满足。\n分类将是代码 $0$。\n\n**测试 3：** $A^{(0)} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$。\n初始矩阵是单位矩阵。它已经是上三角（实际上是对角）形式。\n我们在第一步 $k=0$ 就应用分类规则：\n- 规则 $0$：$\\lVert \\operatorname{tril}(A^{(0)},-1)\\rVert_F < \\tau$ 吗？单位矩阵的严格下三角部分是零矩阵，所以其弗罗贝尼乌斯范数为 $0$。条件 $0 < \\tau$ 满足。\n过程立即终止并报告代码 $0$。\n\n**测试 4：** $A^{(0)} = \\begin{bmatrix} 1 & 10 \\\\ 0 & 1 \\end{bmatrix}$。\n初始矩阵已经是上三角形式。这是一个具有重特征值 $\\lambda_1=\\lambda_2=1$ 的不可对角化的 Jordan 块。\n与测试 3 类似，我们在 $k=0$ 时检查条件：\n- 规则 $0$：$\\lVert \\operatorname{tril}(A^{(0)},-1)\\rVert_F < \\tau$ 吗？该矩阵是上三角矩阵，因此其严格下三角部分为零。范数为 $0$。条件 $0 < \\tau$ 满足。\n过程立即终止并报告代码 $0$。\n它也是迭代的一个不动点，因为 $A^{(0)}$ 是对角线为正的上三角矩阵，这得到 $Q^{(0)}=I$ 和 $R^{(0)}=A^{(0)}$，所以 $A^{(1)} = R^{(0)}Q^{(0)} = A^{(0)}I = A^{(0)}$。然而，收敛到上三角形式的规则具有更高的优先级，并且在 $k=0$ 时就已满足。\n\n预测的分类代码为 $[1, 0, 0, 0]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QR iteration classification problem for a suite of test matrices.\n    \"\"\"\n\n    def classify_qr_behavior(A0, k_max, tau):\n        \"\"\"\n        Runs the QR iteration and classifies the behavior of the sequence A^(k).\n\n        Args:\n            A0 (np.ndarray): The initial 2x2 real matrix.\n            k_max (int): The maximum number of iterations.\n            tau (float): The tolerance for convergence/cycle detection.\n\n        Returns:\n            int: The integer classification code (0, 1, 2, or 3).\n        \"\"\"\n        # A sliding window of the last three matrices in the sequence: [A^(k-2), A^(k-1), A^(k)]\n        A_hist = [\n            np.full_like(A0, np.nan, dtype=float),\n            np.full_like(A0, np.nan, dtype=float),\n            A0.astype(float)\n        ]\n\n        # Default result if no condition is met within k_max iterations.\n        result_code = 3\n\n        for k in range(k_max + 1):\n            A_k = A_hist[2]\n\n            # Rule 0: Converged to upper triangular.\n            # This check has the highest precedence.\n            if np.linalg.norm(np.tril(A_k, -1), 'fro') < tau:\n                result_code = 0\n                break\n\n            # Rule 1: Detected a cycle of length 1 (fixed point).\n            # This check requires k >= 1 to have a previous matrix A^(k-1).\n            if k >= 1:\n                if np.linalg.norm(A_k - A_hist[1], 'fro') < tau:\n                    result_code = 1\n                    break\n            \n            # Rule 2: Detected a cycle of length 2.\n            # This check requires k >= 2 to have A^(k-2).\n            if k >= 2:\n                if np.linalg.norm(A_k - A_hist[0], 'fro') < tau:\n                    result_code = 2\n                    break\n            \n            # If the loop reaches its final iteration, break and return the default code 3.\n            if k == k_max:\n                break\n\n            # Compute the next matrix in the sequence, A^(k+1).\n            Q, R = np.linalg.qr(A_k)\n            \n            # Enforce the problem constraint: R must have positive diagonal entries.\n            # The QR decomposition is unique for non-singular matrices under this constraint.\n            signs = np.sign(np.diag(R))\n            # Handle potential zero on the diagonal (though not expected for these test cases).\n            signs[signs == 0] = 1.0\n            S = np.diag(signs)\n            \n            Q_corr = Q @ S\n            R_corr = S @ R\n            \n            A_next = R_corr @ Q_corr\n\n            # Update the history by sliding the window.\n            A_hist = [A_hist[1], A_hist[2], A_next]\n            \n        return result_code\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[0., 1.], [1., 0.]]),    # Test 1\n        np.array([[2., 1.], [1., 2.]]),    # Test 2\n        np.array([[1., 0.], [0., 1.]]),    # Test 3\n        np.array([[1., 10.], [0., 1.]])   # Test 4\n    ]\n    \n    # Parameters for the decision problem.\n    tau = 1e-12\n    k_max = 100\n\n    results = []\n    for A0 in test_cases:\n        code = classify_qr_behavior(A0, k_max, tau)\n        results.append(code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2431496"}, {"introduction": "在上一练习的基础上，我们现在来研究另一个具有挑战性的场景：亏损矩阵（defective matrices），它们拥有重根但缺少一组完整的特征向量。本实践将探讨无位移 QR 算法在若尔当块（Jordan block）——亏损矩阵的一种标准形式——上的表现 [@problem_id:2431478]。你将会发现，即使算法没有陷入循环，其收敛速度也可能慢到不切实际，这进一步揭示了开发更高级 QR 算法变体的必要性。", "problem": "考虑用于计算特征值的正交三角(QR)算法，它是一系列正交相似变换。设 $A_{0} \\in \\mathbb{R}^{n \\times n}$ 是一个实矩阵。在无位移的情况下，在第 $k$ 次迭代时，计算一个QR分解 $A_{k} = Q_{k} R_{k}$，其中 $Q_{k}$ 是正交矩阵，$R_{k}$ 是上三角矩阵，然后更新 $A_{k+1} = R_{k} Q_{k}$。在带有固定位移 $\\mu \\in \\mathbb{R}$ 的情况下，计算 $A_{k} - \\mu I = Q_{k} R_{k}$ 并更新 $A_{k+1} = R_{k} Q_{k} + \\mu I$。这些步骤建立在以下基本事实上：(i) 正交变换保持特征值和范数不变，(ii) 每个实矩阵都允许进行实QR分解，以及 (iii) 重复应用正交相似变换通常会驱动一个矩阵趋向于其​​实Schur形式（一个对角线元素为特征值的上三角矩阵）。\n\n本题要求你通过原理性推理和计算，研究QR算法在亏损(不可对角化)的若尔当块上的行为。具体来说，考虑实若尔当块\n$$\nJ(\\lambda, s) \\;=\\; \\begin{bmatrix} \\lambda & s \\\\ 0 & \\lambda \\end{bmatrix},\n$$\n其中 $\\lambda \\in \\mathbb{R}$ 且 $s \\in \\mathbb{R}$，$s \\neq 0$。当 $s \\neq 0$ 时，这样的矩阵有一个重特征值 $\\lambda$，其代数重数为2，但几何重数为1，因此它是不可对角化的。\n\n你的任务是：\n- 使用标准的数值线性代数子程序，实现无位移的QR迭代 $A_{k+1} = R_{k} Q_{k}$ 和固定位移的QR迭代 $A_{k+1} = R_{k} Q_{k} + \\mu I$。你不能硬编码三角矩阵的任何特殊性质；应使用通用的QR分解。\n- 仅使用核心定义和经过充分检验的事实（正交性、相似性和QR分解的存在性），推断当迭代应用于一个上三角的若尔当块 $J(\\lambda, s)$ 时必然会发生什么，并将其与从一个通过正交变换与 $J(\\lambda, s)$ 相似的非三角矩阵开始的迭代进行对比。\n\n对于数值实验，请使用以下测试套件。所有角度都必须以弧度为单位进行解释。本题中没有物理单位。使用弗罗贝尼乌斯范数来量化矩阵差异。令 $\\lVert \\cdot \\rVert_{F}$ 表示弗罗贝尼乌斯范数，令 $e_{12}$ 表示矩阵的 $(2,1)$ 次对角线元素的大小（即第2行第1列元素的绝对值）。\n\n- 测试 1 (无位移，已为三角阵)：令 $\\lambda = 1.25$，$s = 1.0$，$K = 40$。从 $A_{0} = J(\\lambda, s)$ 开始，运行 $K$ 次无位移迭代。输出一个布尔值，表示 $\\lVert A_{K} - A_{0} \\rVert_{F} \\le 10^{-12}$ 是否成立。\n- 测试 2 (固定位移等于特征值，已为三角阵)：令 $\\lambda = -3.2$，$s = 0.5$，$\\mu = \\lambda$，$K = 40$。从 $A_{0} = J(\\lambda, s)$ 开始，运行 $K$ 次带位移迭代。输出一个布尔值，表示 $\\lVert A_{K} - A_{0} \\rVert_{F} \\le 10^{-12}$ 是否成立。\n- 测试 3 (无位移，正交相似，非三角阵起始)：令 $\\lambda = 1.0$，$s = 1.0$，$K = 80$，且 $\\theta = \\pi/5$。令 $R(\\theta)$ 为旋转矩阵\n$$\nR(\\theta) \\;=\\; \\begin{bmatrix} \\cos(\\theta) & -\\sin(\\theta) \\\\ \\sin(\\theta) & \\cos(\\theta) \\end{bmatrix}.\n$$\n设置 $A_{0} = R(\\theta)\\, J(\\lambda, s)\\, R(\\theta)^{\\mathsf{T}}$ 并运行 $K$ 次无位移迭代。输出一个布尔值，表示 $e_{12}(A_{K}) \\le 10^{-10}$ 是否成立。\n- 测试 4 (对角线向特征值稳定)：使用与测试3中相同的 $A_{0}$、$\\lambda$、$s$、$\\theta$ 和 $K$，运行 $K$ 次无位移迭代，并输出一个布尔值，表示 $A_{K}$ 的两个对角线元素是否都在 $\\lambda$ 的 $10^{-10}$ 范围内。\n- 测试 5 (超小上对角线元素的边缘情况)：令 $\\lambda = 0.0$，$s = 10^{-12}$，$K = 5$。从 $A_{0} = J(\\lambda, s)$ 开始，运行 $K$ 次无位移迭代。输出一个布尔值，表示 $\\lVert A_{K} - A_{0} \\rVert_{F} \\le 10^{-14}$ 是否成立。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，`[{\\tt True},{\\tt False},{\\tt True}]`），其顺序与上面定义的测试1到测试5一致。所有五个测试的输出都必须是你的程序根据指定参数计算出的布尔值。", "solution": "问题陈述已经过验证，被认为是有效的。它在数值线性代数方面有科学依据，问题设定良好、客观且自成一体。所有术语、参数和算法都得到了明确的定义。\n\n该问题研究了用于计算特征值的QR算法的行为，特别是它在 $2 \\times 2$ 亏损若尔当块上的应用。QR算法的核心是迭代 $A_{k+1} = R_k Q_k$，其中 $A_k = Q_k R_k$ 是矩阵 $A_k$ 在第 $k$ 步的QR分解。这构成一个正交相似变换，$A_{k+1} = Q_k^T A_k Q_k$，它能保持特征值不变。对于带位移的版本，迭代为 $A_k - \\mu I = Q_k R_k$ 和 $A_{k+1} = R_k Q_k + \\mu I$，这等价于 $A_{k+1} = Q_k^T (A_k - \\mu I) Q_k + \\mu I = Q_k^T A_k Q_k$。因此，在这两种情况下，序列中的所有矩阵 $A_k$ 都与初始矩阵 $A_0$ 正交相似。\n\n我们分析所提出的两种主要配置下的行为。\n\n**情况1：从上三角矩阵开始迭代**\n\n这种情况涉及测试1、2和5。初始矩阵是 $A_0 = J(\\lambda, s)$，它已经是上三角（Schur）形式。\n$$\nA_0 = J(\\lambda, s) = \\begin{bmatrix} \\lambda & s \\\\ 0 & \\lambda \\end{bmatrix}\n$$\n让我们分析无位移QR迭代的一个步骤。我们计算QR分解 $A_0 = Q_0 R_0$。由于 $A_0$ 是上三角矩阵，其QR分解特别简单。QR分解的一个标准约定（例如在 `numpy.linalg.qr` 中实现的）确保了 $R$ 的对角元素是非负的。对于一个上三角矩阵 $A$，得到的 $Q$ 矩阵是一个对角矩阵，其元素为 $\\pm 1$。\n具体来说，如果 $A = \\begin{bmatrix} a & b \\\\ 0 & c \\end{bmatrix}$，那么 $Q = \\begin{bmatrix} \\text{sign}(a) & 0 \\\\ 0 & \\text{sign}(c) \\end{bmatrix}$ 且 $R = \\begin{bmatrix} |a| & b \\cdot \\text{sign}(a) \\\\ 0 & |c| \\end{bmatrix}$，假设 $a, c \\neq 0$。如果一个元素为 $0$，相应的符号可以取为 $1$。\n下一个迭代是 $A_1 = R_0 Q_0$。\n对于 $A_0 = J(\\lambda, s)$，如果 $\\lambda \\neq 0$，QR分解得到 $Q_0 = \\text{sign}(\\lambda) I$ 和 $R_0 = \\begin{bmatrix} |\\lambda| & s \\cdot \\text{sign}(\\lambda) \\\\ 0 & |\\lambda| \\end{bmatrix}$。\n那么，下一个迭代是 $A_1 = R_0 Q_0 = \\begin{bmatrix} |\\lambda| & s \\cdot \\text{sign}(\\lambda) \\\\ 0 & |\\lambda| \\end{bmatrix} (\\text{sign}(\\lambda)I) = \\begin{bmatrix} |\\lambda|\\text{sign}(\\lambda) & s \\cdot (\\text{sign}(\\lambda))^2 \\\\ 0 & |\\lambda|\\text{sign}(\\lambda) \\end{bmatrix} = \\begin{bmatrix} \\lambda & s \\\\ 0 & \\lambda \\end{bmatrix} = A_0$。\n如果 $\\lambda=0$，$A_0 = \\begin{bmatrix} 0 & s \\\\ 0 & 0 \\end{bmatrix}$。其QR分解为 $Q_0=I, R_0=A_0$。那么 $A_1=R_0 Q_0 = A_0 I = A_0$。\n因此，对于无位移QR算法，如果 $A_0$ 是一个若尔当块，它就是迭代的一个不动点：对于所有 $k \\ge 0$，$A_k = A_0$。因此，$\\lVert A_K - A_0 \\rVert_F = 0$。这个推理直接适用于测试1 ($\\lambda=1.25, s=1.0$) 和测试5 ($\\lambda=0.0, s=10^{-12}$)。指定的不等式必定成立。这两个测试都应产生 `True`。\n\n对于测试2中的固定位移情况，我们有 $A_0=J(\\lambda, s)$ 并且位移 $\\mu = \\lambda$。第一步是构建矩阵 $B_0 = A_0 - \\mu I = A_0 - \\lambda I = \\begin{bmatrix} 0 & s \\\\ 0 & 0 \\end{bmatrix}$。如前所述，该矩阵的QR分解是 $Q_0=I$ 和 $R_0=B_0$。更新规则是 $A_1 = R_0 Q_0 + \\mu I = B_0 I + \\lambda I = (A_0 - \\lambda I) + \\lambda I = A_0$。同样，$A_0$ 是一个不动点。因此，$\\lVert A_K - A_0 \\rVert_F = 0$，测试2应产生 `True`。\n\n**情况2：从非三角矩阵开始迭代**\n\n这种情况涉及测试3和4。初始矩阵是 $A_0 = R(\\theta) J(\\lambda, s) R(\\theta)^{\\mathsf{T}}$，其中 $R(\\theta)$ 是一个旋转矩阵。由于 $R(\\theta)$ 是正交的，$A_0$ 与 $J(\\lambda, s)$ 正交相似。它具有相同的特征值 $\\{\\lambda, \\lambda\\}$ 和相同的弗罗贝尼乌斯范数。无位移QR算法生成一个序列 $A_k$，其中每个矩阵都与 $A_0$ 正交相似。\n\n众所周知，QR算法会收敛到矩阵的实Schur形式。对于只有实特征值的矩阵，Schur形式是一个上三角矩阵，其对角线上的元素是特征值。极限矩阵 $A_\\infty = \\lim_{k\\to\\infty} A_k$ 必须是上三角矩阵。由于弗罗贝尼乌斯范数在正交变换下保持不变，我们必须有 $\\lVert A_\\infty \\rVert_F = \\lVert A_0 \\rVert_F = \\lVert J(\\lambda, s) \\rVert_F$。\n一个具有特征值 $\\lambda, \\lambda$ 的一般上三角矩阵是 $T = \\begin{bmatrix} \\lambda & s' \\\\ 0 & \\lambda \\end{bmatrix}$。其弗罗贝尼乌斯范数是 $\\sqrt{2\\lambda^2 + (s')^2}$。$J(\\lambda, s)$ 的弗罗贝尼乌斯范数是 $\\sqrt{2\\lambda^2 + s^2}$。令范数相等，得到 $|s'| = |s|$。因此，迭代必须收敛到 $\\begin{bmatrix} \\lambda & s \\\\ 0 & \\lambda \\end{bmatrix}$ 或 $\\begin{bmatrix} \\lambda & -s \\\\ 0 & \\lambda \\end{bmatrix}$ 这两种形式之一。\n\n然而，关键点是*收敛速度*。无位移QR算法中矩阵次对角线元素的收敛通常是几何级的，其 $(i,j)$ 元素 ($i>j$) 的收敛率与比值 $|\\lambda_i / \\lambda_j|$ 有关。在这个问题中，两个特征值相同，所以它们的比值为1。这是一个退化情况，无位移QR算法会表现出病态的慢收敛。虽然次对角线元素 $(A_k)_{21}$ 确实会收敛到0，但其速率是亚线性的（例如，$O(1/k)$），而不是几何级的。\n\n对于测试3，我们被要求检查在 $K=80$ 次迭代后，次对角线元素 $(A_K)_{21}$ 的量级是否小于或等于 $10^{-10}$。考虑到极其缓慢的收敛速度，次对角线元素衰减到如此小的值是极不可能的。数值实验将表明 $(A_K)_{21}$ 仍然显著大于 $10^{-10}$。因此，测试3的预期结果是 `False`。\n\n对于测试4，我们检查 $A_K$ 的对角线元素是否在 $10^{-10}$ 的容差内收敛到了特征值 $\\lambda$。只有当矩阵变为三角矩阵时（即下三角部分的非对角线元素为零时），$A_k$ 的对角线元素才会成为特征值。由于向三角Schur形式的收敛很慢，对角线元素向 $\\lambda$ 的收敛同样缓慢。因为次对角线元素不会接近零，所以对角线元素也不会接近 $\\lambda$。因此，测试4的预期结果也是 `False`。\n\n总而言之，预期的结果是：\n- 测试 1: `True`\n- 测试 2: `True`\n- 测试 3: `False`\n- 测试 4: `False`\n- 测试 5: `True`", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef unshifted_qr_iteration(A0, K):\n    \"\"\"\n    Performs K steps of the unshifted QR algorithm.\n    \"\"\"\n    A = np.copy(A0)\n    for _ in range(K):\n        # Compute the QR factorization of the current matrix A.\n        # The 'full' mode is default, but 'reduced' is sufficient and conventional.\n        Q, R = np.linalg.qr(A)\n        # Update A to the next iterate by reversing the order of multiplication.\n        A = R @ Q\n    return A\n\ndef shifted_qr_iteration(A0, mu, K):\n    \"\"\"\n    Performs K steps of the fixed-shift QR algorithm.\n    \"\"\"\n    A = np.copy(A0)\n    I = np.identity(A.shape[0])\n    for _ in range(K):\n        # Apply the shift to the current matrix A.\n        A_shifted = A - mu * I\n        # Compute the QR factorization of the shifted matrix.\n        Q, R = np.linalg.qr(A_shifted)\n        # Update A to the next iterate and add the shift back.\n        A = R @ Q + mu * I\n    return A\n\ndef solve():\n    \"\"\"\n    Executes the five test cases specified in the problem and prints the results.\n    \"\"\"\n    results = []\n\n    # Test 1: Unshifted QR on an already triangular Jordan block.\n    # The iteration should be a fixed point.\n    lam1, s1, k1 = 1.25, 1.0, 40\n    A0_1 = np.array([[lam1, s1], [0.0, lam1]])\n    A_K_1 = unshifted_qr_iteration(A0_1, k1)\n    norm_diff_1 = np.linalg.norm(A_K_1 - A0_1, 'fro')\n    results.append(norm_diff_1 <= 1e-12)\n\n    # Test 2: Shifted QR with shift equal to the eigenvalue on a Jordan block.\n    # This iteration should also be a fixed point.\n    lam2, s2, k2 = -3.2, 0.5, 40\n    mu2 = lam2\n    A0_2 = np.array([[lam2, s2], [0.0, lam2]])\n    A_K_2 = shifted_qr_iteration(A0_2, mu2, k2)\n    norm_diff_2 = np.linalg.norm(A_K_2 - A0_2, 'fro')\n    results.append(norm_diff_2 <= 1e-12)\n\n    # Test 3 & 4: Unshifted QR on a non-triangular, orthogonally similar matrix.\n    # Convergence is expected to be very slow due to repeated eigenvalues.\n    lam3, s3, k3, theta3 = 1.0, 1.0, 80, np.pi/5\n    J3 = np.array([[lam3, s3], [0.0, lam3]])\n    c, s = np.cos(theta3), np.sin(theta3)\n    R_theta = np.array([[c, -s], [s, c]])\n    A0_3 = R_theta @ J3 @ R_theta.T\n    A_K_3 = unshifted_qr_iteration(A0_3, k3)\n    \n    # Test 3: Check if the subdiagonal element has converged to near-zero.\n    # Due to slow convergence, this is expected to be False.\n    e12_3 = np.abs(A_K_3[1, 0])\n    results.append(e12_3 <= 1e-10)\n\n    # Test 4: Check if the diagonal elements have converged to the eigenvalue.\n    # This also depends on convergence to Schur form, so expected to be False.\n    diag_check_4 = (np.abs(A_K_3[0, 0] - lam3) <= 1e-10) and \\\n                   (np.abs(A_K_3[1, 1] - lam3) <= 1e-10)\n    results.append(diag_check_4)\n\n    # Test 5: Unshifted QR on a Jordan block with a tiny superdiagonal.\n    # This is also a fixed point of the iteration.\n    lam5, s5, k5 = 0.0, 1e-12, 5\n    A0_5 = np.array([[lam5, s5], [0.0, lam5]])\n    A_K_5 = unshifted_qr_iteration(A0_5, k5)\n    norm_diff_5 = np.linalg.norm(A_K_5 - A0_5, 'fro')\n    results.append(norm_diff_5 <= 1e-14)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2431478"}, {"introduction": "在明确了基础 QR 算法的弱点之后，我们现在转向现代数值软件中使用的强大解决方案：隐式双步位移 QR 算法。这个高级实践将指导你实现一个 Francis 步，这是一种复杂的技术，它仅使用实数运算就能处理复数特征值，并显著加速收敛 [@problem_id:2431491]。掌握这个“追逐凸起”（bulge-chasing）的过程，将让你深入了解健壮、专业的特征值求解器是如何构建的。", "problem": "您必须实现、测试并运行一个针对上Hessenberg形式的实矩阵的单步隐式双步位移正交三角分解(QR)迭代，以处理尾部子块具有共轭复特征值对的情况。您的程序必须是一个完整、可运行的程序。目标是实现一个Francis隐式双步位移步，作为对一个实上Hessenberg矩阵的正交相似变换。实现必须避免任何复数运算，方法是利用由尾部 $2\\times 2$ 子块构造的实二次位移。\n\n从以下基本定义和事实开始：\n- 矩阵 $A$ 的一个特征对是一个标量 $\\,\\lambda\\,$ 和一个非零向量 $\\,v\\,$，满足 $\\,A v = \\lambda v\\,$。\n- 相似变换 $\\,\\widetilde{A} = S^{-1} A S\\,$ 保留了特征多项式，因此也保留了所有特征值。如果 $\\,S\\,$ 是正交的，那么 $\\,\\widetilde{A} = S^{\\mathsf{T}} A S\\,$ 会保留内积和Frobenius范数。\n- 任何方阵 $\\,A\\in\\mathbb{R}^{n\\times n}\\,$ 都可以通过正交相似变换约化为（上）Hessenberg形式 $\\,H\\,$，其中对于所有 $\\,i > j+1\\,$，都有 $\\,H_{ij} = 0\\,$。\n- 一个双步位移QR步使用上Hessenberg矩阵的尾部 $\\,2\\times 2\\,$ 子块构造一个二次多项式位移。如果尾部子块是 $\\,T = \\begin{bmatrix} t_{11} & t_{12}\\\\ t_{21} & t_{22}\\end{bmatrix}\\,$，那么位移多项式是 $\\,q(x) = x^2 - s x + p\\,$，其中 $\\,s = t_{11} + t_{22}\\,$ 且 $\\,p = t_{11} t_{22} - t_{12} t_{21}\\,$。该多项式等于 $\\, (x - \\mu_1)(x - \\mu_2)\\,$，其中 $\\,\\mu_1, \\mu_2\\,$ 是 $\\,T\\,$ 的（可能为复数的）特征值，这确保了多项式系数为实数。根据隐式Q定理（Implicit Q Theorem），可以构造一系列源自 $\\,q(H)\\,$ 的正交变换，在不显式构造 $\\,q(H)\\,$ 的情况下，达到与两个连续的单步位移步相同的效果。\n\n您的任务：\n- 实现一个函数，对一个实上Hessenberg矩阵 $\\,H \\in \\mathbb{R}^{n\\times n}\\,$ 执行单步的实数隐式双步位移QR迭代，生成 $\\,\\widehat{H} = Q^{\\mathsf{T}} H Q\\,$，其中 $\\,Q\\,$ 是正交的。您必须：\n  - 全程只使用实数运算（无复数类型）。\n  - 使用如上所述的、来自尾部 $2\\times 2$ 子块的二次位移系数 $\\,s\\,$ 和 $\\,p\\,$。\n  - 通过 $\\,\\left(H^2 - s H + p I\\right) e_1\\,$ 的前导向量来初始化变换，其中 $\\,e_1\\,$ 是第一个标准基向量，然后使用Householder反射变换进行凸起追踪，以维持Hessenberg结构。\n  - 通过对每个Householder反射变换进行左乘和右乘来保持正交性。\n  - 通过正交变换消除第一副对角线下方的填充元素，并将任何小于数值上合理容差的残留项置零，以维持上Hessenberg形式。\n\n- 您不得使用任何预打包的特征值例程、复数运算或执行QR算法的黑箱函数。允许使用线性代数原语，如矩阵向量乘积和Householder反射变换，但它们必须从正交变换的基本原理构建。\n\n测试套件：\n将您的实现应用于以下四个实上Hessenberg矩阵（所有条目均为实数，每个矩阵都明确给出）：\n1) 情况A ($\\,4\\times 4\\,$):\n$$\nH_A =\n\\begin{bmatrix}\n1.0 & 2.0 & 0.0 & 0.0\\\\\n3.0 & 4.0 & 5.0 & 0.0\\\\\n0.0 & 6.0 & 0.5 & 2.0\\\\\n0.0 & 0.0 & -3.0 & 0.5\n\\end{bmatrix}.\n$$\n2) 情况B ($\\,5\\times 5\\,$):\n$$\nH_B =\n\\begin{bmatrix}\n2.0 & -1.0 & 4.0 & 0.0 & 0.0\\\\\n5.0 & 3.0 & -2.0 & 1.0 & 0.0\\\\\n0.0 & -3.0 & 1.0 & 2.0 & 4.0\\\\\n0.0 & 0.0 & 1.5 & 0.0 & 2.0\\\\\n0.0 & 0.0 & 0.0 & -2.5 & 0.0\n\\end{bmatrix}.\n$$\n3) 情况C ($\\,3\\times 3\\,$):\n$$\nH_C =\n\\begin{bmatrix}\n0.0 & 2.0 & 1.0\\\\\n-10.0 & 0.0 & 3.0\\\\\n0.0 & -4.0 & 1.0\n\\end{bmatrix}.\n$$\n4) 情况D ($\\,2\\times 2\\,$):\n$$\nH_D =\n\\begin{bmatrix}\n0.0 & 5.0\\\\\n-4.0 & 0.0\n\\end{bmatrix}.\n$$\n\n对每种情况，在一次双步位移步 $\\,H \\mapsto \\widehat{H}\\,$ 后需要计算的验证指标：\n- $\\,b_1\\,$: $\\,\\widehat{H}\\,$ 中保持上Hessenberg结构（布尔值；如果在容差范围内，对于所有 $\\,i > j+1\\,$ 都有 $\\,\\widehat{H}_{ij} = 0\\,$，则为真）。\n- $\\,b_2\\,$: 迹保持不变，即 $\\,|\\mathrm{tr}(\\widehat{H}) - \\mathrm{tr}(H)|\\,$ 在一个小的指定容差内（布尔值）。\n- $\\,b_3\\,$: Frobenius范数保持不变，即 $\\,\\| \\widehat{H} \\|_F\\,$ 与 $\\,\\|H\\|_F\\,$ 在一个小的容差内相等（布尔值）。\n- $\\,b_4\\,$: 遵守了实数运算规则（布尔值；如果 $\\,\\widehat{H}\\,$ 没有复数项，则为真）。\n\n数值容差：\n- 对于迹的保持性，使用 $\\,10^{-10}\\,$ 的相对容差。\n- 对于Frobenius范数的保持性，使用 $\\,10^{-12}\\,$ 的相对容差。\n- 在检查Hessenberg结构时，将满足 $\\,i > j+1\\,$ 且其绝对值小于 $\\,10^{-12} \\cdot \\left(|\\widehat{H}_{i-1,i-1}| + |\\widehat{H}_{ii}|\\right)\\,$ 的元素 $\\,\\widehat{H}_{ij}\\,$ 视为零。\n\n最终输出格式：\n- 您的程序必须按顺序 $\\,\\{H_A,H_B,H_C,H_D\\}\\,$ 运行这四种情况，为每种情况计算布尔值 $\\,b_1, b_2, b_3, b_4\\,$，并生成一行输出，其中包含一个由方括号括起来的、逗号分隔的 $\\,16\\,$ 个布尔值列表，顺序如下：\n$$\n[b_{1,A}, b_{2,A}, b_{3,A}, b_{4,A},\\; b_{1,B}, b_{2,B}, b_{3,B}, b_{4,B},\\; b_{1,C}, b_{2,C}, b_{3,C}, b_{4,C},\\; b_{1,D}, b_{2,D}, b_{3,D}, b_{4,D}].\n$$\n不涉及角度或物理单位。输出元素为布尔值。程序必须是自包含的，并且不需要用户输入。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于数值线性代数中公认的理论，特别是用于计算特征值的Francis隐式双步位移QR算法。该问题定义明确，提供了所有必要的数据、约束和验证指标。它客观且没有歧义或矛盾。因此，我们可以着手解决。\n\n任务是为实上Hessenberg矩阵 $\\,H \\in \\mathbb{R}^{n\\times n}\\,$ 实现Francis隐式双步位移QR算法的单步迭代。该算法是非对称特征值求解器的基石，旨在使用纯实数运算来寻找特征值，包括共轭复数对。\n\n特征值计算的一个基本原理是使用相似变换 $\\,\\hat{H} = Q^{-1}HQ\\,$，这种变换能保持 $\\,H\\,$ 的特征值。当 $\\,Q\\,$ 是正交矩阵（$\\,Q^{-1}=Q^{\\mathsf{T}}\\,$）时，该变换是数值稳定的。QR算法通过迭代应用此类变换，将矩阵趋向于一种可以轻松提取特征值的形式，通常是上三角（Schur）形式。\n\n一个带有实数位移 $\\,\\mu\\,$ 的简单QR步包括分解 $\\,H - \\mu I = QR\\,$ 并形成 $\\,\\hat{H} = R Q + \\mu I = Q^{\\mathsf{T}}HQ\\,$。然而，如果 $\\,H\\,$ 有共轭复特征值，仅使用实数位移可能会导致收敛缓慢或失败。一种更稳健的策略是使用两个位移 $\\,\\mu_1\\,$ 和 $\\,\\mu_2\\,$，它们对应于尾部子矩阵的一对共轭复特征值。直接应用带有复数位移 $\\,\\mu_1\\,$ 和 $\\,\\mu_2\\,$ 的两个QR步将需要复数运算。\n\n隐式双步位移法，或称Francis步，通过仅使用实数运算同时应用这两个步骤来规避此问题。这两个位移产生一个实系数二次多项式 $\\,q(x) = (x-\\mu_1)(x-\\mu_2) = x^2 - (\\mu_1+\\mu_2)x + \\mu_1\\mu_2 = x^2 - sx + p\\,$。系数 $\\,s\\,$（迹）和 $\\,p\\,$（行列式）是从 $\\,H\\,$ 的尾部 $\\,2 \\times 2\\,$ 子矩阵计算得出的，该子矩阵的特征值被用作位移 $\\,\\mu_1, \\mu_2\\,$。这确保了 $\\,s\\,$ 和 $\\,p\\,$ 是实数。\n\n然后，算法利用隐式Q定理（Implicit Q Theorem）隐式地进行。该定理本质上表明，如果一个正交相似变换 $\\,Q^{\\mathsf{T}}HQ\\,$ 将 $\\,H\\,$ 约化为一个未约化的上Hessenberg矩阵 $\\,\\hat{H}\\,$，并且 $\\,Q\\,$ 的第一列是固定的，那么矩阵 $\\,Q\\,$ 和 $\\,\\hat{H}\\,$ 是唯一确定的。我们只需要为我们的总变换矩阵 $\\,Q\\,$ 构造正确的第一列，其余部分通过强制维持Hessenberg结构即可得出。\n\n期望的变换矩阵 $\\,Q\\,$ 的第一列与矩阵 $\\,(H^2 - sH + pI)\\,$ 的第一列成比例。令 $\\,\\mathbf{v} = (H^2 - sH + pI)\\mathbf{e}_1\\,$，其中 $\\,\\mathbf{e}_1\\,$ 是第一个标准基向量。对于一个上Hessenberg矩阵 $\\,H\\,$，向量 $\\,\\mathbf{v}\\,$ 只有其前三个分量 $\\,v_0, v_1, v_2\\,$ 可能为非零值。\n\n算法如下：\n\n1.  **位移计算**: 对于一个大小为 $\\,n \\times n\\,$ 且 $\\,n \\geq 3\\,$ 的矩阵 $\\,H\\,$，计算其尾部 $\\,2 \\times 2\\,$ 子块 $\\,H[n-2:n, n-2:n]\\,$ 的迹 $\\,s\\,$ 和行列式 $\\,p\\,$。\n\n2.  **引入凸起**: 计算 $\\,\\mathbf{v} = (H^2 - sH + pI)\\mathbf{e}_1\\,$ 的前三个分量。构造一个Householder反射变换 $\\,P_0\\,$，它作用于前三行/列，并将此三维向量映射到 $\\,\\mathbf{e}_1\\,$ 的倍数。相似变换 $\\,H \\leftarrow P_0 H P_0\\,$ 会产生一个“凸起”——即破坏Hessenberg结构的非零项，通常从位置 $\\,(2,0)\\,$ 或 $\\,(3,1)\\,$ 开始。\n\n3.  **凸起追踪**: 生成一系列Householder反射变换 $\\,P_1, P_2, \\ldots, P_{n-3}\\,$，以将凸起沿次对角线向下追赶并移出矩阵。每个反射变换 $\\,P_k\\,$ 都被设计为作用于行和列 $\\,k+1\\,$ 到 $\\,k+3\\,$，以恢复列 $\\,k\\,$ 的Hessenberg结构。这是通过从列向量 $\\,H[k+1:k+4, k]\\,$ 构造一个反射变换来将次对角线以下的元素置零。应用相似变换 $\\,H \\leftarrow P_k H P_k\\,$ 会恢复列 $\\,k\\,$，但在列 $\\,k+1\\,$ 中产生一个新的凸起。重复此过程，直到凸起被追赶出矩阵。\n\n4.  **最终化**: 循环终止后，矩阵 $\\,\\hat{H}\\,$ 在浮点精度下恢复为上Hessenberg形式。必须根据数值容差将次对角线下方的小的伪非零项设置为零。然而，这一步是一个近似。对迹和Frobenius范数保持性的验证（指标 $\\,b_2, b_3\\,$）必须在进行此置零操作*之前*在矩阵上进行，因为纯正交变换会精确保持这些量。对Hessenberg结构的检查（$\\,b_1\\,$）则在清理后的矩阵上执行。对实数运算的检查（$\\,b_4\\,$）通过构造方式得以满足。\n\n对于 $\\,n < 3\\,$ 的矩阵，双步位移步不适用；矩阵将原样返回。\n\n实现将构建一个执行这些步骤的函数。Householder反射变换使用标准的数值稳定方法构建。对于每个反射变换，依次应用左乘和右乘矩阵以实现相似变换。\n\n然后计算验证指标：\n- $\\,b_1\\,$：检查在应用指定的清理容差后，对所有 $\\,i > j+1\\,$ 是否有 $\\,\\hat{H}_{ij} = 0\\,$。\n- $\\,b_2\\,$：确认迹的保持性，$\\,|\\mathrm{tr}(\\hat{H}) - \\mathrm{tr}(H)| \\le 10^{-10} |\\mathrm{tr}(H)|\\,$。\n- $\\,b_3\\,$：确认Frobenius范数的保持性，$\\,\\|\\hat{H}\\|_F\\,$ 和 $\\,\\|H\\|_F\\,$ 在相对容差 $\\,10^{-12}\\,$ 内相等。\n- $\\,b_4\\,$：确认结果矩阵的元素是实数。", "answer": "```python\nimport numpy as np\n\ndef _create_householder_vector(x):\n    \"\"\"\n    Creates a Householder vector u from a given vector x.\n    The reflector P = I - 2*u*u.T transforms x into [alpha, 0, ..., 0].T.\n    Returns the vector u and the scalar alpha.\n    \"\"\"\n    if len(x) == 0:\n        return np.array([]), 0.0\n    \n    # Use copysign for numerical stability\n    alpha = np.linalg.norm(x)\n    signed_alpha = np.copysign(alpha, x[0])\n    \n    u = x.copy()\n    u[0] += signed_alpha\n    \n    norm_u = np.linalg.norm(u)\n    if norm_u < 1e-15:  # Vector is already close to zero or e_1 aligned\n        return np.zeros_like(u), -signed_alpha\n        \n    u /= norm_u\n    return u, -signed_alpha\n\ndef francis_double_shift_qr_step(H):\n    \"\"\"\n    Performs a single implicit double-shift QR step on a real upper Hessenberg matrix H.\n    \"\"\"\n    n = H.shape[0]\n    if n < 3:\n        return H.copy()\n\n    H_new = H.copy()\n\n    # 1. Calculate shift parameters s (trace) and p (determinant)\n    # from the trailing 2x2 block.\n    s = H_new[n-2, n-2] + H_new[n-1, n-1]\n    p = H_new[n-2, n-2] * H_new[n-1, n-1] - H_new[n-2, n-1] * H_new[n-1, n-2]\n\n    # 2. Compute the first column of (H^2 - sH + pI).\n    # This vector determines the first Householder transformation.\n    # Only the first 3 components are non-zero for a Hessenberg matrix.\n    h00, h10, h01 = H_new[0, 0], H_new[1, 0], H_new[0, 1]\n    h11, h21 = H_new[1, 1], H_new[2, 1]\n\n    v0 = h00 * (h00 - s) + h01 * h10 + p\n    v1 = h10 * (h00 + h11 - s)\n    v2 = h10 * h21\n    \n    v = np.array([v0, v1, v2])\n\n    # 3. Bulge-chasing loop\n    for k in range(n - 2):\n        # Determine the size of the reflector and the part of H to operate on.\n        # Window size is 3, but shrinks near the end of the matrix.\n        m = min(k + 3, n)\n        \n        # Get the vector for the Householder reflector.\n        # For k=0, it's the initial vector v calculated above.\n        # For k>0, it's part of the k-1 column of the current matrix,\n        # which contains the bulge from the previous step.\n        if k == 0:\n            sub_vector = v\n        else:\n            sub_vector = H_new[k:m, k-1]\n\n        # Create Householder reflector P = I - 2*u*u.T\n        if np.linalg.norm(sub_vector) < 1e-15:\n            continue\n        \n        u, _ = _create_householder_vector(sub_vector)\n        \n        if np.linalg.norm(u) < 1e-15:\n            continue\n\n        # Apply the transformation P from the left: H_new <- P H_new\n        # This acts on rows k to m-1.\n        sub_matrix_left = H_new[k:m, k:]\n        tau_left = 2 * (u.T @ sub_matrix_left)\n        H_new[k:m, k:] -= np.outer(u, tau_left)\n\n        # Apply the transformation P from the right: H_new <- H_new P\n        # This acts on columns k to m-1.\n        sub_matrix_right = H_new[:, k:m]\n        tau_right = 2 * (sub_matrix_right @ u)\n        H_new[:, k:m] -= np.outer(tau_right, u)\n\n    return H_new\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        np.array([\n            [1.0, 2.0, 0.0, 0.0],\n            [3.0, 4.0, 5.0, 0.0],\n            [0.0, 6.0, 0.5, 2.0],\n            [0.0, 0.0, -3.0, 0.5]\n        ]),\n        np.array([\n            [2.0, -1.0, 4.0, 0.0, 0.0],\n            [5.0, 3.0, -2.0, 1.0, 0.0],\n            [0.0, -3.0, 1.0, 2.0, 4.0],\n            [0.0, 0.0, 1.5, 0.0, 2.0],\n            [0.0, 0.0, 0.0, -2.5, 0.0]\n        ]),\n        np.array([\n            [0.0, 2.0, 1.0],\n            [-10.0, 0.0, 3.0],\n            [0.0, -4.0, 1.0]\n        ]),\n        np.array([\n            [0.0, 5.0],\n            [-4.0, 0.0]\n        ])\n    ]\n\n    results = []\n    \n    for H_orig in test_cases:\n        n = H_orig.shape[0]\n        \n        # Run one step of the algorithm\n        H_raw = francis_double_shift_qr_step(H_orig)\n\n        # Create a cleaned version for the Hessenberg structure check\n        H_clean = H_raw.copy()\n        for i in range(n):\n            for j in range(n):\n                if i > j + 1:\n                    # Tolerance from problem description\n                    tol_clean = 1e-12 * (np.abs(H_clean[i-1, i-1]) + np.abs(H_clean[i, i]))\n                    if np.abs(H_clean[i, j]) < tol_clean:\n                        H_clean[i, j] = 0.0\n        \n        # --- Verification Metrics ---\n        # b1: Upper Hessenberg structure preserved\n        b1 = True\n        for i in range(n):\n            for j in range(n):\n                if i > j + 1 and H_clean[i, j] != 0.0:\n                    b1 = False\n                    break\n            if not b1:\n                break\n\n        # b2: Trace preserved (use raw matrix)\n        trace_orig = np.trace(H_orig)\n        trace_new = np.trace(H_raw)\n        b2 = np.isclose(trace_orig, trace_new, rtol=1e-10, atol=1e-12)\n\n        # b3: Frobenius norm preserved (use raw matrix)\n        norm_orig = np.linalg.norm(H_orig, 'fro')\n        norm_new = np.linalg.norm(H_raw, 'fro')\n        b3 = np.isclose(norm_orig, norm_new, rtol=1e-12, atol=1e-14)\n\n        # b4: Real arithmetic respected\n        b4 = not np.iscomplexobj(H_raw)\n\n        results.extend([b1, b2, b3, b4])\n    \n    # Format the final output as a comma-separated list of booleans\n    # Python's str(True) is 'True', which is a standard representation.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    output_str = output_str.replace(\"True\", \"true\").replace(\"False\", \"false\") # Match lowercase example\n    print(output_str)\n\nsolve()\n```", "id": "2431491"}]}