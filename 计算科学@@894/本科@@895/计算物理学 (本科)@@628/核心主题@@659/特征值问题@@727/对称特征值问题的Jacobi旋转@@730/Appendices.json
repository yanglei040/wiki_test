{"hands_on_practices": [{"introduction": "将理论转化为代码是计算物理学的核心技能。这个练习将指导你从头开始实现经典的雅可比旋转方法。通过编程实现对对称矩阵的迭代对角化，你不仅能计算出特征值，还将通过数值方式验证谱定理的关键结论：特征向量矩阵 $Q$ 的正交性以及原始矩阵 $A \\approx Q \\Lambda Q^{\\mathsf{T}}$ 的重构精度。这项实践对于深入理解雅可比方法的内在机理和培养严谨的数值验证能力至关重要。[@problem_id:2405358]", "problem": "你需要编写一个完整的程序，使用 Jacobi 旋转来验证实对称矩阵的谱定理，并定量地检验所得特征向量的正交性。对于每个测试用例，按如下方式构造一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$：给定一个整数种子 $s$ 和实数边界 $a_{\\min}$ 和 $a_{\\max}$，使用一个以 $s$ 为种子初始化的伪随机数生成器，生成一个 $n \\times n$ 的矩阵 $M$，其元素独立地从区间 $\\left[a_{\\min}, a_{\\max}\\right]$ 上的连续均匀分布中采样。然后定义 $A = \\dfrac{1}{2}\\left(M + M^{\\mathsf{T}}\\right)$，以确保 $A$ 是实对称矩阵。您的任务是计算一个正交矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 和一个对角矩阵 $\\Lambda \\in \\mathbb{R}^{n \\times n}$，使得 $A \\approx Q \\Lambda Q^{\\mathsf{T}}$。对于 $Q^{\\mathsf{T}} A Q$ 的非对角部分的 Frobenius 范数，使用收敛容差 $\\varepsilon = 10^{-10}$，并强制执行 $10^{6}$ 次相似性旋转的硬上限。如果在内部计算了任何旋转角度，它们必须以弧度为单位。对于每个测试用例，报告以下三个实数：\n- $r_{\\mathrm{off}} = \\left\\| \\mathrm{offdiag}\\left(Q^{\\mathsf{T}} A Q\\right) \\right\\|_{F}$，其中 $\\mathrm{offdiag}(X)$ 表示将矩阵 $X$ 的对角线元素置零后的矩阵，$\\|\\cdot\\|_{F}$ 表示 Frobenius 范数，\n- $r_{\\mathrm{rec}} = \\left\\| A - Q \\Lambda Q^{\\mathsf{T}} \\right\\|_{F}$，\n- $r_{\\mathrm{orth}} = \\left\\| Q^{\\mathsf{T}} Q - I \\right\\|_{F}$，其中 $I$ 是 $\\mathbb{R}^{n \\times n}$ 中的单位矩阵。\n\n所有这三个量都必须以科学记数法格式的浮点数报告，小数点后精确到 $10$ 位。\n\n测试套件包含以下参数集 $(n, s, a_{\\min}, a_{\\max})$：\n- $(n, s, a_{\\min}, a_{\\max}) = (1, 1, -1, 1)$，\n- $(n, s, a_{\\min}, a_{\\max}) = (2, 2, -1, 1)$，\n- $(n, s, a_{\\min}, a_{\\max}) = (5, 7, -1, 1)$，\n- $(n, s, a_{\\min}, a_{\\max}) = (6, 11, -10, 10)$。\n\n你的程序应该生成单行输出，包含一个逗号分隔的列表，其中每个元素是对应测试用例的三元组，每个三元组按 $\\left[r_{\\mathrm{off}}, r_{\\mathrm{rec}}, r_{\\mathrm{orth}}\\right]$ 顺序排列，且整个集合用方括号括起来。例如，包含两个测试用例的输出看起来像 $[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}]]$，其中每个符号 $x_{i}, y_{i}, z_{i}$ 表示一个指定格式的浮点数。请确保你的确切输出格式是单行，不含任何额外文本，每个数字都使用科学记数法，小数点后精确到 $10$ 位。", "solution": "该问题要求使用 Jacobi 特征值算法对实对称矩阵的谱定理进行数值验证。谱定理指出，对于任何实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，存在一个正交矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 和一个实对角矩阵 $\\Lambda \\in \\mathbb{R}^{n \\times n}$，使得 $A = Q \\Lambda Q^{\\mathsf{T}}$。$Q$ 的列是 $A$ 的标准正交特征向量，$\\Lambda$ 的对角线元素是相应的实特征值。\n\n我们的方法是实现 Jacobi 旋转法，来为给定的对称矩阵 $A$ 计算矩阵 $Q$ 和 $\\Lambda$。矩阵 $A$ 由一个伪随机矩阵 $M$ 构造，其元素从均匀分布 $U(a_{\\min}, a_{\\max})$ 中采样，通过定义 $A = \\frac{1}{2}(M + M^{\\mathsf{T}})$ 来确保其对称性。\n\nJacobi 方法是一种迭代算法，通过一系列相似性变换，逐步将 $A$ 的非对角线元素的量值减小到零。每次变换都是一次 Givens 旋转，旨在消去一个特定的非对角线元素 $a_{pq}$。\n单次 Jacobi 旋转是一种形式为 $A' = J^{\\mathsf{T}} A J$ 的相似性变换，其中 $J \\equiv J(p, q, \\theta)$ 是在 $(p, q)$ 平面中的一个旋转矩阵。矩阵 $J$ 是一个单位矩阵，除了四个元素外：\n$$\nJ_{pp} = \\cos\\theta, \\quad J_{qq} = \\cos\\theta \\\\\nJ_{pq} = \\sin\\theta, \\quad J_{qp} = -\\sin\\theta\n$$\n选择旋转角度 $\\theta$ 以使得变换后矩阵 $A'$ 的元素 $a'_{pq}$ 变为零。该条件导出以下方程：\n$$\n\\cot(2\\theta) = \\frac{a_{qq} - a_{pp}}{2 a_{pq}}\n$$\n为了数值稳定性和效率，我们避免直接计算 $\\theta$。而是计算 $t = \\tan\\theta$。设 $\\tau = \\frac{a_{qq} - a_{pp}}{2 a_{pq}}$。关于 $t$ 的方程是 $t^2 + 2\\tau t - 1 = 0$。我们选择绝对值较小的根以确保 $|\\theta| \\le \\pi/4$，这可以增强稳定性。这个根由下式给出：\n$$\nt = \\frac{\\operatorname{sgn}(\\tau)}{|\\tau| + \\sqrt{1 + \\tau^2}}\n$$\n对于 $\\tau \\neq 0$。如果 $\\tau = 0$（即 $a_{pp} = a_{qq}$），则 $\\theta = \\pi/4$ 且 $t=1$。由 $t$ 可得 $c = \\cos\\theta = 1/\\sqrt{1+t^2}$ 和 $s = \\sin\\theta = t \\cdot c$。\n\n该算法按以下步骤进行：\n1.  将特征向量矩阵 $Q$ 初始化为单位矩阵 $I \\in \\mathbb{R}^{n \\times n}$。\n2.  迭代地应用旋转。我们使用循环 Jacobi 方法，在每一次“扫描”中，我们遍历所有唯一的非对角元素对 $(p, q)$（其中 $p < q$）。\n3.  对于每对 $(p, q)$，如果 $a_{pq}$ 在数值上不为零，我们计算 $c$ 和 $s$ 并更新矩阵 $A$ 和 $Q$：\n    -   $A \\leftarrow J^{\\mathsf{T}} A J$\n    -   $Q \\leftarrow Q J$\n    这些更新只影响各自矩阵的第 $p$ 行和第 $q$ 行以及第 $p$ 列和第 $q$ 列。特征向量矩阵 $Q$ 累积了所有旋转矩阵的乘积。\n4.  当 $A$ 的非对角部分的 Frobenius 范数（定义为 $S = \\sqrt{\\sum_{i \\neq j} a_{ij}^2}$）低于指定的容差 $\\varepsilon = 10^{-10}$ 时，或者达到最大旋转次数（$10^6$）时，该过程终止。\n\n收敛后，矩阵 $A$ 已被变换为一个近似对角矩阵 $\\Lambda_{\\text{approx}}$，其对角线元素即为特征值。最终的矩阵 $Q$ 的列包含了相应的特征向量。\n\n为了验证计算出的分解，我们计算三个误差度量：\n1.  非对角误差，$r_{\\mathrm{off}} = \\left\\| \\mathrm{offdiag}(Q^{\\mathsf{T}} A Q) \\right\\|_{F}$。这衡量了变换后的矩阵与完美对角矩阵的接近程度。\n2.  重构误差，$r_{\\mathrm{rec}} = \\left\\| A - Q \\Lambda Q^{\\mathsf{T}} \\right\\|_{F}$，其中 $\\Lambda$ 是由 $Q^{\\mathsf{T}} A Q$ 的对角线元素构成的纯对角矩阵。这量化了计算出的特征值和特征向量重构原始矩阵 $A$ 的优劣程度。\n3.  正交性误差，$r_{\\mathrm{orth}} = \\left\\| Q^{\\mathsf{T}} Q - I \\right\\|_{F}$。这衡量了计算出的特征向量矩阵 $Q$ 与正交矩阵的接近程度。\n\n对于 $n=1$ 的平凡情况，矩阵 $A = [a_{11}]$ 已经是对角矩阵。我们有 $Q=[1]$ 和 $\\Lambda=[a_{11}]$，所有三个误差度量都精确为 $0$。对于所有其他情况，应用 Jacobi 算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the eigenvalues and eigenvectors of real symmetric matrices\n    using the Jacobi rotation method and verifies the spectral theorem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, s, a_min, a_max)\n        (1, 1, -1, 1),\n        (2, 2, -1, 1),\n        (5, 7, -1, 1),\n        (6, 11, -10, 10),\n    ]\n    \n    TOLERANCE = 1e-10\n    MAX_ROTATIONS = 1_000_000\n\n    results_all_cases = []\n    for n, s, a_min, a_max in test_cases:\n        \n        # Handle the trivial case n=1\n        if n == 1:\n            results_all_cases.append([0.0, 0.0, 0.0])\n            continue\n            \n        # 1. Construct the real symmetric matrix A\n        rng = np.random.default_rng(seed=s)\n        M = rng.uniform(low=a_min, high=a_max, size=(n, n))\n        A = 0.5 * (M + M.T)\n        A_orig = A.copy()\n        \n        # Initialize eigenvector matrix Q to identity\n        Q = np.identity(n, dtype=np.float64)\n\n        # 2. Jacobi Iteration\n        rotation_count = 0\n        max_sweeps = 100 # A generous limit for sweeps\n        \n        for sweep in range(max_sweeps):\n            # Calculate sum of squares of off-diagonal elements\n            off_diag_sq_sum = np.sum(A**2) - np.sum(np.diag(A)**2)\n            \n            # Check for convergence\n            if np.sqrt(off_diag_sq_sum) < TOLERANCE:\n                break\n            \n            # Perform a sweep through all off-diagonal elements\n            for p in range(n):\n                for q in range(p + 1, n):\n                    if rotation_count >= MAX_ROTATIONS:\n                        break\n\n                    apq = A[p, q]\n                    # Skip rotation if element is already numerically zero\n                    if abs(apq) < 1e-20:\n                        continue\n\n                    # Calculate rotation parameters c and s\n                    app = A[p, p]\n                    aqq = A[q, q]\n                    tau = (aqq - app) / (2.0 * apq)\n                    \n                    if tau == 0:\n                        t = 1.0\n                    else:\n                        t = np.sign(tau) / (abs(tau) + np.sqrt(1.0 + tau**2))\n                    \n                    c = 1.0 / np.sqrt(1.0 + t**2)\n                    s = c * t\n\n                    # Apply rotation to A (transform A -> J^T * A * J)\n                    app_old = A[p, p]\n                    aqq_old = A[q, q]\n                    A[p, p] = c*c*app_old - 2*c*s*apq + s*s*aqq_old\n                    A[q, q] = s*s*app_old + 2*c*s*apq + c*c*aqq_old\n                    A[p, q] = 0.0\n                    A[q, p] = 0.0\n\n                    for i in range(n):\n                        if i != p and i != q:\n                            aip_old = A[i, p]\n                            aiq_old = A[i, q]\n                            A[i, p] = c * aip_old - s * aiq_old\n                            A[p, i] = A[i, p]\n                            A[i, q] = s * aip_old + c * aiq_old\n                            A[q, i] = A[i, q]\n\n                    # Apply rotation to Q (transform Q -> Q * J)\n                    Q_col_p = Q[:, p].copy()\n                    Q_col_q = Q[:, q].copy()\n                    Q[:, p] = c * Q_col_p - s * Q_col_q\n                    Q[:, q] = s * Q_col_p + c * Q_col_q\n                    \n                    rotation_count += 1\n\n                if rotation_count >= MAX_ROTATIONS:\n                    break\n            \n            if rotation_count >= MAX_ROTATIONS:\n                break\n\n        # 3. Calculate final metrics\n        A_diag = A\n        \n        # r_off: Frobenius norm of the off-diagonal part of Q^T A Q\n        off_diag_part = A_diag - np.diag(np.diag(A_diag))\n        r_off = np.linalg.norm(off_diag_part, 'fro')\n\n        # r_rec: Frobenius norm of A - Q Lambda Q^T\n        Lambda = np.diag(np.diag(A_diag))\n        reconstruction = Q @ Lambda @ Q.T\n        r_rec = np.linalg.norm(A_orig - reconstruction, 'fro')\n        \n        # r_orth: Frobenius norm of Q^T Q - I\n        identity = np.identity(n, dtype=np.float64)\n        ortho_check = Q.T @ Q - identity\n        r_orth = np.linalg.norm(ortho_check, 'fro')\n        \n        results_all_cases.append([r_off, r_rec, r_orth])\n    \n    # Format and print the final results\n    output_str = \"[\"\n    for i, case_results in enumerate(results_all_cases):\n        res_str = f\"[{case_results[0]:.10e},{case_results[1]:.10e},{case_results[2]:.10e}]\"\n        output_str += res_str\n        if i < len(results_all_cases) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "2405358"}, {"introduction": "在掌握了正向的对角化过程后，这个练习将挑战你的逆向思维。给定最终的对角矩阵 $\\Lambda$ 和一系列旋转操作，你的任务是重构出原始的稠密对称矩阵 $A$。这项实践旨在让你深刻理解总的正交变换矩阵 $Q$ 是如何由一系列基本旋转累积构成的，并巩固对谱分解公式 $A = Q \\Lambda Q^{\\mathsf{T}}$ 的几何直觉。[@problem_id:2405315]", "problem": "给定一个针对对称特征值问题的经典雅可比方法的逆向表述。在正向雅可比过程中，一个实对称矩阵通过一系列正交平面旋转（雅可比旋转）被对角化。在这个逆问题中，给定一个对角矩阵和指定的雅可比旋转序列，你必须重构出那个通过正向应用这些旋转而被对角化的稠密对称矩阵。\n\n基本原理：\n- 如果 $Q^{\\mathsf{T}}Q=I$，则实方阵 $Q$ 是正交的，其中 $I$ 是单位矩阵，${\\mathsf{T}}$ 表示转置。正交相似变换将对称矩阵映射到对称矩阵，并保持特征值不变。\n- 在由索引为 $p$ 和 $q$ 的标准基向量张成的坐标平面中的一次雅可比旋转，是一个正交矩阵，它除了在行和列 $(p,q)$ 上的 $2\\times 2$ 子块等于一个角度为 $\\theta$ 的旋转外，其余部分与单位矩阵相同。\n\n本问题的定义和约定：\n- 角度以弧度为单位。\n- 索引 $p$ 和 $q$ 是从零开始的整数，满足 $0\\le p<q<n$，其中 $n$ 是矩阵的维度。\n- 对于给定的 $n$，初等雅可比旋转 $G(p,q,\\theta)\\in\\mathbb{R}^{n\\times n}$ 定义为单位矩阵，但以下元素除外：\n  $$\n  G_{pp}=\\cos\\theta,\\quad G_{qq}=\\cos\\theta,\\quad G_{pq}=\\sin\\theta,\\quad G_{qp}=-\\sin\\theta,\n  $$\n  且在行或列 $p$ 和 $q$ 中的所有其他非对角元素 $G_{ij}=0$。这定义了嵌入在 $\\mathbb{R}^n$ 中的标准平面旋转。\n- 给定一个包含 $k$ 次旋转的序列 $\\{(p_1,q_1,\\theta_1),\\ldots,(p_k,q_k,\\theta_k)\\}$，构造正交矩阵\n  $$\n  Q \\equiv G(p_1,q_1,\\theta_1)\\,G(p_2,q_2,\\theta_2)\\,\\cdots\\,G(p_k,q_k,\\theta_k).\n  $$\n- 设 $\\Lambda=\\mathrm{diag}(\\lambda_0,\\ldots,\\lambda_{n-1})$ 是一个实对角矩阵。你的任务是仅根据 $\\Lambda$ 和旋转序列，重构出通过正向雅可比过程并使用给定旋转而被对角化的对称矩阵 $A$。你必须仅使用上述定义和正交相似变换的一般性质，从第一性原理推导出如何计算 $A$。\n\n程序要求：\n- 实现一个程序，对于下面的每个测试用例，根据旋转序列构造指定的 $Q$，并按行主序返回重构矩阵 $A$ 的上三角元素（包括对角线）。例如，对于 $n=3$，返回列表 $[A_{00},A_{01},A_{02},A_{11},A_{12},A_{22}]$。\n- 为进行数值报告，将返回的每个数字四舍五入到 $10^{-6}$，并将其格式化为小数点后恰好六位。\n- 最终输出必须是单行，包含一个列表，该列表连接了每个测试用例的上三角输出，形式为用方括号括起来的、无空格的逗号分隔列表。\n\n测试套件（角度以弧度为单位，索引从零开始）：\n- 测试用例 1（边界情况：旋转序列为空）：$n=3$，$\\Lambda=\\mathrm{diag}(1.5,-0.5,2.5)$，旋转序列 $\\varnothing$。\n- 测试用例 2（单次旋转）：$n=3$，$\\Lambda=\\mathrm{diag}(1,2,4)$，旋转序列 $\\{(0,1,\\pi/6)\\}$。\n- 测试用例 3（具有共享索引的多次旋转）：$n=4$，$\\Lambda=\\mathrm{diag}(0.5,1.5,2.5,3.5)$，旋转序列 $\\{(0,2,\\pi/4),(1,3,\\pi/3),(0,1,-\\pi/8)\\}$。\n- 测试用例 4（角度包含零）：$n=3$，$\\Lambda=\\mathrm{diag}(3,1,2)$，旋转序列 $\\{(0,2,0),(0,2,\\pi/2),(1,2,0)\\}$。\n\n你的程序应生成单行输出，其中包含连接后的结果，形式为逗号分隔并用方括号括起来的列表（例如，$\\big[$result$1,$result$2,\\ldots\\big]$）。不应打印任何其他文本。", "solution": "该问题要求从一个实对称矩阵 $A$ 的对角形式 $\\Lambda$ 和产生此对角化的一系列雅可比旋转来重构矩阵 $A$。这是雅可比特征值算法的逆过程。我们将首先从线性代数的基本原理推导出重构公式，然后开发一个计算它的算法。\n\n谱理论的一个基本结果指出，任何实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 都可以通过一次正交相似变换进行对角化。也就是说，存在一个正交矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 和一个对角矩阵 $\\Lambda \\in \\mathbb{R}^{n \\times n}$，使得：\n$$\n\\Lambda = P^{\\mathsf{T}} A P\n$$\n在这里，$\\Lambda$ 的对角元素是 $A$ 的特征值，而 $P$ 的列是相应的标准正交特征向量。这个关系可以被求逆，以根据特征值和特征向量来表示 $A$。由于 $P$ 是正交的，其转置就是其逆，即 $P^{\\mathsf{T}} = P^{-1}$。通过左乘 $P$ 和右乘 $P^{\\mathsf{T}}$，我们得到：\n$$\nP \\Lambda P^{\\mathsf{T}} = P (P^{\\mathsf{T}} A P) P^{\\mathsf{T}} = (P P^{\\mathsf{T}}) A (P P^{\\mathsf{T}}) = I A I = A\n$$\n因此，重构公式为 $A = P \\Lambda P^{\\mathsf{T}}$。\n\n问题指出，正向雅可比过程使用 $k$ 次初等旋转的序列 $\\{(p_1,q_1,\\theta_1), \\ldots, (p_k,q_k,\\theta_k)\\}$ 来对角化 $A$。一次初等雅可比旋转是由矩阵 $G(p,q,\\theta)$ 表示的正交变换。正向过程将这些旋转作为一系列相似变换来应用。设 $A_0 = A$。该序列为：\n$$\nA_1 = G(p_1,q_1,\\theta_1)^{\\mathsf{T}} A_0 G(p_1,q_1,\\theta_1)\n$$\n$$\nA_2 = G(p_2,q_2,\\theta_2)^{\\mathsf{T}} A_1 G(p_2,q_2,\\theta_2)\n$$\n$$\n\\vdots\n$$\n$$\n\\Lambda = A_k = G(p_k,q_k,\\theta_k)^{\\mathsf{T}} A_{k-1} G(p_k,q_k,\\theta_k)\n$$\n通过递归代入，我们找到了 $A$ 和 $\\Lambda$ 之间的关系：\n$$\n\\Lambda = \\left(G_k^{\\mathsf{T}} \\cdots G_2^{\\mathsf{T}} G_1^{\\mathsf{T}}\\right) A \\left(G_1 G_2 \\cdots G_k\\right)\n$$\n这里我们使用简写 $G_i = G(p_i,q_i,\\theta_i)$。利用性质 $(AB)^{\\mathsf{T}} = B^{\\mathsf{T}}A^{\\mathsf{T}}$，上式可简化为：\n$$\n\\Lambda = (G_1 G_2 \\cdots G_k)^{\\mathsf{T}} A (G_1 G_2 \\cdots G_k)\n$$\n问题将总变换矩阵 $Q$ 定义为初等旋转的有序乘积：\n$$\nQ \\equiv G_1 G_2 \\cdots G_k\n$$\n将此定义与 $\\Lambda$ 的表达式相比较，我们发现标准谱分解中的变换矩阵 $P$ 与 $Q$ 完全对应。\n$$\n\\Lambda = Q^{\\mathsf{T}} A Q\n$$\n因此，重构 $A$ 的公式为：\n$$\nA = Q \\Lambda Q^{\\mathsf{T}}\n$$\n由于每个 $G_i$ 都是正交矩阵，它们的乘积 $Q$ 也是一个正交矩阵，这验证了此推导的正确性。\n\n解决该问题的算法如下：\n1. 对于每个测试用例，给定维度 $n$、特征值列表 $(\\lambda_0, \\ldots, \\lambda_{n-1})$ 和旋转序列 $\\{(p_1,q_1,\\theta_1), \\ldots, (p_k,q_k,\\theta_k)\\}$。\n2. 构造对角矩阵 $\\Lambda = \\mathrm{diag}(\\lambda_0, \\ldots, \\lambda_{n-1})$。\n3. 构造总旋转矩阵 $Q$。这可以通过先初始化一个矩阵，然后按指定顺序将其与每个初等雅可比旋转矩阵 $G_i = G(p_i,q_i,\\theta_i)$ 相乘来完成。\n    - 如果旋转序列为空 ($k=0$)，则 $Q$ 是大小为 $n \\times n$ 的单位矩阵 $I$。\n    - 如果序列不为空，则计算 $Q = G_1 G_2 \\cdots G_k$。这可以通过迭代完成：从 $Q=G_1$ 开始，然后计算 $Q \\leftarrow Q G_2$，以此类推，直到 $Q \\leftarrow Q G_k$。一个初等旋转矩阵 $G(p,q,\\theta)$ 是一个 $n \\times n$ 的单位矩阵，但有四个元素不同：\n    $$\n    G_{pp}=\\cos\\theta, \\quad G_{qq}=\\cos\\theta, \\quad G_{pq}=\\sin\\theta, \\quad G_{qp}=-\\sin\\theta\n    $$\n4. 使用推导出的公式 $A = Q \\Lambda Q^{\\mathsf{T}}$ 计算对称矩阵 $A$。\n5. 按行主序提取 $A$ 的上三角元素，包括主对角线。这些是满足 $0 \\le i \\le j < n$ 的元素 $A_{ij}$。\n6. 将每个提取的元素四舍五入到 $10^{-6}$ 并以小数点后恰好六位的形式呈现。将所有测试用例的所有结果连接成一个单一列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reverse Jacobi rotation problem for a suite of test cases.\n    \"\"\"\n    # Test suite (angles in radians, indices zero-based):\n    # - Case 1: n=3, Lambda=diag(1.5,-0.5,2.5), sequence []\n    # - Case 2: n=3, Lambda=diag(1,2,4), sequence [(0,1,pi/6)]\n    # - Case 3: n=4, Lambda=diag(0.5,1.5,2.5,3.5), sequence [(0,2,pi/4),(1,3,pi/3),(0,1,-pi/8)]\n    # - Case 4: n=3, Lambda=diag(3,1,2), sequence [(0,2,0),(0,2,pi/2),(1,2,0)]\n    test_cases = [\n        {'n': 3, 'lambdas': [1.5, -0.5, 2.5], 'rotations': []},\n        {'n': 3, 'lambdas': [1, 2, 4], 'rotations': [(0, 1, np.pi / 6)]},\n        {'n': 4, 'lambdas': [0.5, 1.5, 2.5, 3.5], 'rotations': [(0, 2, np.pi / 4), (1, 3, np.pi / 3), (0, 1, -np.pi / 8)]},\n        {'n': 3, 'lambdas': [3, 1, 2], 'rotations': [(0, 2, 0), (0, 2, np.pi / 2), (1, 2, 0)]}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n = case['n']\n        lambdas = case['lambdas']\n        rotations = case['rotations']\n\n        # Step 1: Construct the diagonal matrix Lambda\n        Lambda_mat = np.diag(lambdas)\n\n        # Step 2: Construct the orthogonal matrix Q from the sequence of rotations\n        if not rotations:\n            Q_mat = np.identity(n)\n        else:\n            # Initialize Q with the first rotation matrix G_1\n            p, q, theta = rotations[0]\n            c, s = np.cos(theta), np.sin(theta)\n            G = np.identity(n)\n            G[p, p], G[q, q] = c, c\n            G[p, q], G[q, p] = s, -s\n            Q_mat = G\n\n            # Accumulate the product Q = G_1 * G_2 * ... * G_k\n            for i in range(1, len(rotations)):\n                p, q, theta = rotations[i]\n                c, s = np.cos(theta), np.sin(theta)\n                G = np.identity(n)\n                G[p, p], G[q, q] = c, c\n                G[p, q], G[q, p] = s, -s\n                Q_mat = Q_mat @ G\n        \n        # Step 3: Reconstruct matrix A using A = Q * Lambda * Q^T\n        A_mat = Q_mat @ Lambda_mat @ Q_mat.T\n\n        # Step 4: Extract the upper-triangular entries in row-major order\n        case_results = []\n        for i in range(n):\n            for j in range(i, n):\n                # Format to 6 decimal places, including trailing zeros\n                formatted_val = f\"{A_mat[i, j]:.6f}\"\n                case_results.append(formatted_val)\n        \n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n\n```", "id": "2405315"}, {"introduction": "本练习旨在将抽象的数值算法与量子物理学的基石问题联系起来。你将学习如何通过离散化（有限差分法）将一维定态薛定谔方程这个微分方程问题，转化为一个矩阵特征值问题。通过求解这个哈密顿量矩阵的特征值，你将能得到量子系统的离散能级，这清晰地展示了像雅可比方法这样的特征值求解器在模拟真实物理世界中的强大作用。[@problem_id:2405321]", "problem": "给定无量纲形式的一维不含时薛定谔特征值问题\n$$\n\\left(-\\frac{d^2}{dx^2} + V(x)\\right)\\psi(x) = E\\,\\psi(x),\n$$\n在闭区间 $[x_{\\min},x_{\\max}]$ 上，满足狄利克雷边界条件 $\\psi(x_{\\min})=0$ 和 $\\psi(x_{\\max})=0$，其中，无量纲单位的选择使得 $\\hbar^2/(2m)=1$。请计算几种给定势能 $V(x)$ 下的最低特征值 $E$ 的近似值。空间域和采样分辨率由 $[x_{\\min},x_{\\max}]$ 上的 $N$ 个点的均匀网格指定。每个案例所求的输出是最低的 $k$ 个特征值，表示为无量纲实数。\n\n对于每个测试用例，程序必须：\n- 将 $[x_{\\min},x_{\\max}]$ 解释为空间域。\n- 在 $[x_{\\min},x_{\\max}]$ 上使用 $N$ 个点的均匀网格。\n- 施加狄利克雷边界条件 $\\psi(x_{\\min})=0$ 和 $\\psi(x_{\\max})=0$。\n- 将 $V(x)$ 视为各用例下方所给定的形式。\n- 返回该用例的最低 $k$ 个特征值 $E$，按升序排列，每个值四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n1. 用例A（谐振子）：$V(x) = \\tfrac{1}{2}\\,\\omega^2 x^2$，其中 $\\omega=1$。域：$[x_{\\min},x_{\\max}] = [-8,8]$。网格大小：$N=81$。返回最低的 k=3 个特征值。\n2. 用例B（箱中粒子）：$V(x) = 0$。域：$[x_{\\min},x_{\\max}] = [0,1]$。网格大小：$N=81$。返回最低的 k=3 个特征值。\n3. 用例C（对称双势阱）：$V(x) = a\\,(x^2-b^2)^2$，其中 $a=25$ 且 $b=1$。域：$[x_{\\min},x_{\\max}] = [-2,2]$。网格大小：$N=81$。返回最低的 k=2 个特征值。\n4. 用例D（谐振子，粗网格）：$V(x) = \\tfrac{1}{2}\\,\\omega^2 x^2$，其中 $\\omega=0.5$。域：$[x_{\\min},x_{\\max}] = [-6,6]$。网格大小：$N=41$。返回最低的 k=1 个特征值。\n\n最终输出格式：\n您的程序必须生成一行包含一个类似JSON的浮点数列表的列表，不含空格。每个内部列表按 A、B、C、D 的顺序对应一个测试用例，并包含该用例的 $k$ 个特征值，每个值四舍五入到恰好 $6$ 位小数。例如，格式必须与以下完全一样\n$[\\,[e_{A,1},e_{A,2},e_{A,3}],\\,[e_{B,1},e_{B,2},e_{B,3}],\\,[e_{C,1},e_{C,2}],\\,[e_{D,1}]\\,]$\n但使用数值且不含任何空格，例如，\n$[[0.123456,0.234567,0.345678],[...],[...],[...]]$。\n\n所有返回的值都是无量纲的；不报告任何物理单位。不涉及角度，因此不需要角度单位。程序必须是自包含的，并且不需要用户输入。", "solution": "该问题要求计算一维不含时薛定谔方程的最低特征值，其形式为\n$$\n\\hat{H}\\psi(x) = \\left(-\\frac{d^2}{dx^2} + V(x)\\right)\\psi(x) = E\\,\\psi(x)\n$$\n对于有限域 $[x_{\\min}, x_{\\max}]$ 上的几种势能 $V(x)$，并满足狄利克雷边界条件 $\\psi(x_{\\min})=0$ 和 $\\psi(x_{\\max})=0$。所给方程的形式意味着在一个单位制中 $\\hbar^2/(2m)=1$。\n\n为了数值求解此特征值问题，我们采用有限差分法。连续空间域 $[x_{\\min}, x_{\\max}]$ 被离散化为一个由 $N$ 个点组成的均匀网格，记为 $x_i = x_{\\min} + i \\cdot \\Delta x$，其中 $i = 0, 1, \\dots, N-1$。网格间距为 $\\Delta x = (x_{\\max} - x_{\\min})/(N-1)$。连续波函数 $\\psi(x)$ 由其在这些网格点上的值 $\\psi_i = \\psi(x_i)$ 来近似。\n\n狄利克雷边界条件规定 $\\psi_0 = \\psi(x_0) = 0$ 和 $\\psi_{N-1} = \\psi(x_{N-1}) = 0$。这留下了 $M=N-2$ 个未知的波函数值，对应于内部点 $x_1, \\dots, x_{N-2}$。\n\n二阶导数算符 $d^2/dx^2$ 在每个内部网格点 $x_i$ 处使用二阶中心差分公式进行近似：\n$$\n\\frac{d^2\\psi}{dx^2}\\bigg|_{x=x_i} \\approx \\frac{\\psi(x_{i+1}) - 2\\psi(x_i) + \\psi(x_{i-1})}{(\\Delta x)^2} = \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2}\n$$\n将此近似代入内部点 $x_i$ 的薛定谔方程，得到一个线性代数方程组：\n$$\n-\\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2} + V(x_i)\\psi_i = E \\psi_i\n$$\n对于每个 $i \\in \\{1, 2, \\dots, M\\}$，该方程可以重新排列为：\n$$\n-\\frac{1}{(\\Delta x)^2}\\psi_{i-1} + \\left(\\frac{2}{(\\Delta x)^2} + V(x_i)\\right)\\psi_i - \\frac{1}{(\\Delta x)^2}\\psi_{i+1} = E \\psi_i\n$$\n这个包含 $M$ 个方程的系统可以转化为矩阵特征值问题 $\\mathbf{H}\\vec{\\psi} = E\\vec{\\psi}$，其中 $\\vec{\\psi} = (\\psi_1, \\psi_2, \\dots, \\psi_M)^T$ 是内部点上波函数值的向量，而 $\\mathbf{H}$ 是一个表示离散化哈密顿算符的 $M \\times M$ 矩阵。\n\n矩阵 $\\mathbf{H}$ 是实对称三对角矩阵。其元素由以下公式给出：\n$$\nH_{ij} = \\begin{cases} \\frac{2}{(\\Delta x)^2} + V(x_i) & \\text{if } i=j \\\\ -\\frac{1}{(\\Delta x)^2} & \\text{if } |i-j|=1 \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\n这里，索引 $i$ 和 $j$ 的范围是从 $1$ 到 $M=N-2$。势能 $V(x_i)$ 在内部网格点上求值。\n\n寻找能量特征值 $E$ 的问题被转化为寻找矩阵 $\\mathbf{H}$ 的特征值的问题。由于 $\\mathbf{H}$ 是一个实对称矩阵，其特征值全部为实数，这与能量特征值必须是实数的物理要求相一致。我们使用标准的数值线性代数库，例如 NumPy 的 `linalg.eigh` 函数，来高效地计算这些特征值。该函数专为厄米（或实对称）矩阵设计，并返回按升序排列的特征值。\n\n对于每个测试用例，我们根据给定的势能 $V(x)$、域 $[x_{\\min}, x_{\\max}]$ 和网格大小 $N$ 构建相应的哈密顿矩阵 $\\mathbf{H}$。然后我们计算其特征值，并按要求选择最低的 $k$ 个值，将它们四舍五入到指定的精度。这个过程为量子系统的低能级提供了精确的数值近似。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-independent Schrödinger equation for a set of test cases\n    using the finite difference method.\n    \"\"\"\n\n    def solve_case(V_func, domain, N, k):\n        \"\"\"\n        Solves the 1D Schrödinger equation for a single given potential.\n        \n        Args:\n            V_func (callable): The potential function V(x).\n            domain (list or tuple): The spatial domain [xmin, xmax].\n            N (int): The number of grid points.\n            k (int): The number of lowest eigenvalues to return.\n            \n        Returns:\n            list: The lowest k eigenvalues, rounded to 6 decimal places.\n        \"\"\"\n        xmin, xmax = domain\n        \n        # Grid spacing\n        dx = (xmax - xmin) / (N - 1)\n        \n        # The number of interior points defines the matrix size\n        M = N - 2\n        \n        # Discretize the domain for interior points\n        x_interior = np.linspace(xmin + dx, xmax - dx, num=M, dtype=float)\n        \n        # Evaluate the potential at interior points\n        V_interior = V_func(x_interior)\n        \n        # Construct the Hamiltonian matrix H\n        # The kinetic energy part contributes to the main and off-diagonals.\n        # Main diagonal elements\n        diag = (2.0 / (dx**2)) + V_interior\n        \n        # Off-diagonal elements (constant for a uniform grid)\n        offdiag_val = -1.0 / (dx**2)\n        offdiag = np.full(M - 1, offdiag_val)\n        \n        # Create the tridiagonal matrix\n        H_matrix = np.diag(diag) + np.diag(offdiag, k=1) + np.diag(offdiag, k=-1)\n        \n        # Find eigenvalues. numpy.linalg.eigh is efficient for Hermitian (real symmetric)\n        # matrices and returns sorted eigenvalues and corresponding eigenvectors.\n        # We only need the eigenvalues, which are the first element of the returned tuple.\n        eigenvalues = np.linalg.eigh(H_matrix)[0]\n        \n        # Select the lowest k eigenvalues\n        lowest_k_eigenvalues = eigenvalues[:k]\n        \n        # Round the results to the specified precision\n        return [round(e, 6) for e in lowest_k_eigenvalues]\n\n    # Definition of the test suite as per the problem statement\n    test_cases = [\n        # Case A: Harmonic oscillator, V(x) = 0.5 * omega^2 * x^2, omega=1\n        {\n            \"V_func\": lambda x: 0.5 * (1.0**2) * x**2,\n            \"domain\": [-8.0, 8.0],\n            \"N\": 81,\n            \"k\": 3\n        },\n        # Case B: Particle in a box, V(x) = 0\n        {\n            \"V_func\": lambda x: np.zeros_like(x),\n            \"domain\": [0.0, 1.0],\n            \"N\": 81,\n            \"k\": 3\n        },\n        # Case C: Symmetric double well, V(x) = a * (x^2 - b^2)^2, a=25, b=1\n        {\n            \"V_func\": lambda x, a=25.0, b=1.0: a * (x**2 - b**2)**2,\n            \"domain\": [-2.0, 2.0],\n            \"N\": 81,\n            \"k\": 2\n        },\n        # Case D: Harmonic oscillator, coarse grid, V(x) = 0.5 * omega^2 * x^2, omega=0.5\n        {\n            \"V_func\": lambda x: 0.5 * (0.5**2) * x**2,\n            \"domain\": [-6.0, 6.0],\n            \"N\": 41,\n            \"k\": 1\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_case(case[\"V_func\"], case[\"domain\"], case[\"N\"], case[\"k\"])\n        all_results.append(result)\n\n    # Format the final output string into a JSON-like list of lists with no spaces\n    # Example: [[valA1,valA2],[valB1],[valC1,valC2,valC3]]\n    output_str = '[' + ','.join(['[' + ','.join(map(str, res)) + ']' for res in all_results]) + ']'\n    \n    print(output_str)\n\nsolve()\n```", "id": "2405321"}]}