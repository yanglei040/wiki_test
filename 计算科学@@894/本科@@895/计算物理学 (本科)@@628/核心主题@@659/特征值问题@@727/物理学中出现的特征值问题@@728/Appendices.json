{"hands_on_practices": [{"introduction": "物理世界中，许多重要的量子系统，如非谐振子，无法精确求解。本练习将引导你掌握一种强大的近似方法：在一个方便的基组（如谐振子的本征态）中将哈密顿算符表示为一个有限维矩阵。通过数值对角化这个矩阵，我们可以近似得到系统的能级，这是计算物理学中矩阵力学的核心实践。[@problem_id:2387563]", "problem": "考虑一个质量为 $m$ 的粒子在一维非谐势 $V(x)=\\frac{1}{2}k x^{2}+\\frac{1}{4}\\lambda x^{4}$ 中运动，其运动由一维不含时薛定谔方程描述，其中 $k>0$ 且 $\\lambda\\ge 0$。在约化普朗克常数 $\\hbar=1$ 和质量 $m=1$ 的单位制下进行计算，因此能量是无量纲的。目标是通过数值近似哈密顿算符的能谱来计算基态能量 $E_{0}(k,\\lambda)$，并报告相对于具有相同二次项系数 $k$ 的相应谐振子的能量移动 $\\Delta E(k,\\lambda)=E_{0}(k,\\lambda)-\\frac{1}{2}\\sqrt{k}$。使用一个由相同 $k$ 定义的谐振子的定态构成的维度为 $M$ 的有限规范正交基，在一个大小为 $M$ 的截断希尔伯特空间上近似哈密顿算符。对于下面指定的每个测试用例 $(k,\\lambda,M)$，计算标量 $\\Delta E(k,\\lambda)$。\n\n所有能量都必须用 $\\hbar=1$ 和 $m=1$ 所隐含的无量纲单位表示。最终的数值答案必须四舍五入到8位小数。\n\n测试套件（每项为 $(k,\\lambda,M)$）：\n- 用例 1： $(1.0,0.0,20)$\n- 用例 2： $(1.0,0.1,50)$\n- 用例 3： $(0.25,0.05,60)$\n- 用例 4： $(2.0,0.5,60)$\n- 用例 5： $(1.0,0.0001,20)$\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果与测试套件的顺序相同，例如 $[\\Delta E_{1},\\Delta E_{2},\\Delta E_{3},\\Delta E_{4},\\Delta E_{5}]$，每个条目都四舍五入到8位小数。", "solution": "该物理系统由一维不含时薛定谔方程\n$$\n\\hat{H}\\,\\psi(x)=E\\,\\psi(x),\n$$\n描述，其哈密顿算符为\n$$\n\\hat{H}=\\hat{T}+\\hat{V}=\\frac{\\hat{p}^{2}}{2m}+\\frac{1}{2}k \\hat{x}^{2}+\\frac{1}{4}\\lambda \\hat{x}^{4}.\n$$\n在指定的单位制 $\\hbar=1$ 和 $m=1$ 下，动能项为 $\\hat{T}=\\frac{\\hat{p}^{2}}{2}=-\\frac{1}{2}\\frac{d^{2}}{dx^{2}}$。谐振子参考哈密顿量为\n$$\n\\hat{H}_{0}=\\frac{\\hat{p}^{2}}{2}+\\frac{1}{2}k \\hat{x}^{2},\n$$\n其角频率为 $\\omega=\\sqrt{k}$，并具有精确的本征态 $\\{\\lvert n \\rangle\\}_{n=0}^{\\infty}$ 和对应的本征值\n$$\nE_{n}^{(0)}=\\left(n+\\frac{1}{2}\\right)\\omega.\n$$\n因此，纯谐振子情况下的基态能量为 $E_{0}^{(0)}=\\frac{1}{2}\\omega=\\frac{1}{2}\\sqrt{k}$。\n\n为了近似完整非谐哈密顿量 $\\hat{H}=\\hat{H}_{0}+\\frac{1}{4}\\lambda \\hat{x}^{4}$ 的能谱，我们将 $\\hat{H}$ 在由前 $M$ 个谐振子本征态 $\\{\\lvert n\\rangle\\}_{n=0}^{M-1}$ 张成的截断希尔伯特空间上展开。在该基底下，位置算符可以由湮灭算符 $\\hat{a}$ 和产生算符 $\\hat{a}^{\\dagger}$ 表示。它们满足正则对易关系 $[\\hat{a},\\hat{a}^{\\dagger}]=1$，其作用方式为\n$$\n\\hat{a}\\lvert n\\rangle=\\sqrt{n}\\,\\lvert n-1\\rangle,\\quad \\hat{a}^{\\dagger}\\lvert n\\rangle=\\sqrt{n+1}\\,\\lvert n+1\\rangle.\n$$\n当 $\\omega=\\sqrt{k}$ 时，\n$$\n\\hat{x}=\\frac{1}{\\sqrt{2\\omega}}\\,(\\hat{a}+\\hat{a}^{\\dagger}).\n$$\n因此，在所选基底下，$\\hat{x}$ 的矩阵表示仅在超对角线和次对角线上有非零元素：\n$$\n\\langle m\\lvert \\hat{x}\\rvert n\\rangle=\\frac{1}{\\sqrt{2\\omega}}\\left(\\sqrt{n}\\,\\delta_{m,n-1}+\\sqrt{n+1}\\,\\delta_{m,n+1}\\right).\n$$\n由此，通过矩阵乘法 $\\hat{x}^{2}=\\hat{x}\\hat{x}$ 构造 $\\hat{x}^{2}$，然后构造 $\\hat{x}^{4}=(\\hat{x}^{2})(\\hat{x}^{2})$。截断的哈密顿矩阵为\n$$\nH_{mn}=\\left(n+\\frac{1}{2}\\right)\\omega\\,\\delta_{mn}+\\frac{\\lambda}{4}\\,\\langle m\\lvert \\hat{x}^{4}\\rvert n\\rangle,\\quad m,n\\in\\{0,1,\\dots,M-1\\}.\n$$\n这个 $M\\times M$ 的厄米矩阵可以通过数值方法对角化，以获得近似的本征值 $\\{E_{j}\\}_{j=0}^{M-1}$，其中 $E_{0}$ 是最低的本征值。然后，相对于谐振子情况的基态能量移动计算如下\n$$\n\\Delta E(k,\\lambda)=E_{0}(k,\\lambda)-\\frac{1}{2}\\sqrt{k}.\n$$\n\n基于这些原理推导出的算法步骤：\n- 对于每个测试用例 $(k,\\lambda,M)$，计算 $\\omega=\\sqrt{k}$。\n- 构建 $\\hat{a}$ 的 $M\\times M$ 矩阵表示，其元素为 $\\langle m\\lvert \\hat{a}\\rvert n\\rangle=\\sqrt{n}\\,\\delta_{m,n-1}$，并通过厄米共轭得到 $\\hat{a}^{\\dagger}$。\n- 构造矩阵 $\\hat{x}=(\\hat{a}+\\hat{a}^{\\dagger})/\\sqrt{2\\omega}$，然后通过矩阵乘法计算 $\\hat{x}^{2}$ 和 $\\hat{x}^{4}$。\n- 组装哈密顿矩阵 $H$，其对角线元素为 $\\left(n+\\frac{1}{2}\\right)\\omega$，并加上 $(\\lambda/4)\\,\\hat{x}^{4}$。\n- 对角化 $H$，提取最低本征值 $E_{0}$，并计算 $\\Delta E=E_{0}-\\frac{1}{2}\\omega$。\n- 将每个 $\\Delta E$ 四舍五入到8位小数，并以要求的聚合格式返回结果。\n\n检查与覆盖范围：\n- 对于 $\\lambda=0$ (用例 1)，该构造产生一个对角矩阵 $H$，其最低本征值恰好为 $\\frac{1}{2}\\omega$，因此 $\\Delta E$ 在四舍五入后应在数值上为 $0$。\n- 对于小的 $\\lambda$ (用例 5)，随着 $M$ 的增加，结果应逼近一级微扰移动 $\\Delta E\\approx \\frac{\\lambda}{4}\\langle 0\\lvert \\hat{x}^{4}\\rvert 0\\rangle=\\frac{3\\lambda}{16\\omega^{2}}$。\n- 对于较弱的束缚 (用例 3，具有较小的 $k$)，增加基底大小 $M$ 以捕捉更大的空间范围。\n- 对于更强的非谐性 (用例 4)，更大的 $M$ 可以减轻截断误差。\n\n最终程序实现了此构造，并打印出单行内容，包含5个浮点数 $[\\Delta E_{1},\\Delta E_{2},\\Delta E_{3},\\Delta E_{4},\\Delta E_{5}]$，每个数都四舍五入到8位小数，且顺序与测试套件相同。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ground_state_energy_shift(k: float, lam: float, M: int) -> float:\n    \"\"\"\n    Compute Delta E = E0(anharmonic) - E0(harmonic) for\n    V(x) = 1/2 k x^2 + 1/4 lam x^4\n    using a truncated harmonic oscillator basis of size M,\n    in units with hbar=1, m=1.\n    \"\"\"\n    # Angular frequency for the harmonic part\n    omega = np.sqrt(k)\n\n    # Construct annihilation operator 'a' in the number basis |n>, n=0..M-1\n    a = np.zeros((M, M), dtype=np.float64)\n    # a|n> = sqrt(n) |n-1>\n    n_vals = np.arange(1, M, dtype=np.float64)\n    a[:-1, 1:] = np.diag(np.sqrt(n_vals))  # a[m, n] = sqrt(n) delta_{m, n-1}\n\n    # Creation operator is the transpose (real matrices here)\n    adag = a.T\n\n    # Position operator x = (a + a^\\dagger) / sqrt(2*omega)\n    x = (a + adag) / np.sqrt(2.0 * omega)\n\n    # Compute x^2 and x^4 via matrix multiplication\n    x2 = x @ x\n    x4 = x2 @ x2\n\n    # Harmonic Hamiltonian diagonal: (n + 1/2) * omega\n    diag = omega * (np.arange(M, dtype=np.float64) + 0.5)\n    H = np.diag(diag) + (lam / 4.0) * x4\n\n    # Diagonalize the Hermitian Hamiltonian\n    # eigh returns eigenvalues in ascending order\n    evals = np.linalg.eigh(H)[0]\n    E0 = float(evals[0])\n\n    # Energy shift relative to harmonic ground state\n    delta_E = E0 - 0.5 * omega\n    return delta_E\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (k, lambda, M)\n    test_cases = [\n        (1.0, 0.0, 20),     # Case 1: boundary (no anharmonicity)\n        (1.0, 0.1, 50),     # Case 2: moderate anharmonicity\n        (0.25, 0.05, 60),   # Case 3: softer oscillator\n        (2.0, 0.5, 60),     # Case 4: stronger k and anharmonicity\n        (1.0, 0.0001, 20),  # Case 5: very weak anharmonicity\n    ]\n\n    results = []\n    for k, lam, M in test_cases:\n        dE = ground_state_energy_shift(k, lam, M)\n        # Clean small numerical noise around zero before formatting\n        if abs(dE) < 0.5e-8:\n            dE = 0.0\n        results.append(dE)\n\n    # Format each result to 8 decimal places\n    formatted = [f\"{val:.8f}\" for val in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2387563"}, {"introduction": "薛定谔方程本质上是一个偏微分方程，描述了连续空间中的量子行为。本实践将向你展示如何利用有限差分法，将这样一个连续问题转化为一个离散的矩阵本征值问题。这种技术不仅是模拟量子点等纳米结构的关键，也是解决从热传导到电磁学等众多领域中偏微分方程问题的基石。[@problem_id:2387539]", "problem": "您需要编写一个完整的、可运行的程序，构建并求解一个离散特征值问题。该问题对应于一个粒子在带有中心吸引杂质的二维圆形量子点中的不含时薛定谔方程。\n\n请在无量纲单位下进行计算，其中因子 $\\hbar^2/(2m^\\ast)$ 设为 $1$，因此能量和长度都是无量纲的。\n\n从定态的基本不含时薛定谔方程出发，\n$$\n\\left[-\\nabla^2 + V(\\mathbf{r})\\right]\\psi(\\mathbf{r}) = E\\,\\psi(\\mathbf{r}),\n$$\n其中 $\\mathbf{r}=(x,y)$，$\\nabla^2$ 是拉普拉斯算子，$V(\\mathbf{r})$ 是势能，$E$ 是能量本征值。考虑一个半径为 $R$ 的圆形量子点，在边界上施加狄利克雷边界条件，即 $\\psi(r=R)=0$，这代表一个限制粒子的无限高硬壁。在量子点内部，包含一个软化库仑形式的中心吸引杂质势\n$$\nV(r) = -\\frac{\\alpha}{\\sqrt{r^2 + \\delta^2}},\n$$\n其强度参数为 $\\alpha \\ge 0$，软化长度为 $\\delta > 0$，以避免在 $r=0$ 处出现数值奇异点。\n\n在方形区域 $[-R,R]\\times[-R,R]$ 上使用均匀笛卡尔网格对问题进行离散化，每个轴上有 $N$ 个等间距的网格点。用 $h$ 表示网格间距，则 $h = 2R/(N-1)$。对内部点上的拉普拉斯算子使用标准的五点中心差分近似，\n$$\n-\\nabla^2 \\psi(x_i,y_j) \\approx \\frac{4\\,\\psi_{i,j} - \\psi_{i+1,j} - \\psi_{i-1,j} - \\psi_{i,j+1} - \\psi_{i,j-1}}{h^2}.\n$$\n通过将未知数限制在圆 $r<R$ 内部的网格点上来施加狄利克雷边界条件；将圆外的任何邻近点处的波函数值视为零。构建相应的稀疏哈密顿矩阵 $H$，使得离散特征值问题表示为\n$$\nH \\mathbf{u} = E \\mathbf{u},\n$$\n其中 $\\mathbf{u}$ 是表示内部网格点上 $\\psi$ 值的未知量向量，$H$ 包含在每个内部网格点上计算的差分动能项和对角势能项 $V(r)$。计算最小的代数本征值 $E_{\\min}$，它对应于该无量纲模型中的基态能量。\n\n您的程序必须实现上述离散化方法，并使用稀疏对称特征值求解器来求解基态能量。所有计算都应在所述的无量纲单位下进行，因此不需要进行物理单位转换。\n\n测试套件。您的程序必须运行以下四个测试用例，并报告每个用例的基态能量：\n- 用例 1：$N=41$，$R=1.0$，$\\alpha=0.0$，$\\delta=0.02$。\n- 用例 2：$N=51$，$R=1.0$，$\\alpha=0.5$，$\\delta=0.02$。\n- 用例 3：$N=51$，$R=1.0$，$\\alpha=1.5$，$\\delta=0.02$。\n- 用例 4：$N=31$，$R=1.0$，$\\alpha=0.0$，$\\delta=0.02$。\n\n答案规格和输出格式。对于每个用例，计算最小本征值 $E_{\\min}$ 并将其四舍五入到 $6$ 位小数。您的程序应生成单行输出，其中包含按顺序排列的四个四舍五入后的基态能量，格式为方括号内以逗号分隔的列表，例如，“[e1,e2,e3,e4]”，其中每个“e$k$”是格式化为小数点后恰好有 $6$ 位的浮点数。\n\n您的程序必须是自包含的，并且不需要用户输入。它必须使用适用于大型、对称、稀疏矩阵的鲁棒稀疏特征值例程来获得最小代数本征值。除了指定的离散化方法外，不需要使用任何加速技术。通过使用如上所述的小而-非零的软化长度 $\\delta$ 来确保数值稳定性。", "solution": "所提出的问题陈述经过严格审查，被认为是有效的。它在科学上基于量子力学原理，构成一个适定的边界值问题，并以客观、明确的数学和数值形式进行规定。这是计算物理学中的一个标准问题，适合求解。\n\n目标是确定一个粒子在带有中心吸引杂质的二维圆形量子点中的基态能量。这通过求解不含时薛定谔方程来实现，在指定的无量纲单位（$\\hbar^2/(2m^\\ast) = 1$）下，该方程由下式给出：\n$$\nH\\psi(\\mathbf{r}) = \\left[-\\nabla^2 + V(\\mathbf{r})\\right]\\psi(\\mathbf{r}) = E\\,\\psi(\\mathbf{r})\n$$\n区域是一个半径为 $R$ 的圆，量子点内部的势定义为：\n$$\nV(r) = -\\frac{\\alpha}{\\sqrt{r^2 + \\delta^2}}\n$$\n其中 $r = \\sqrt{x^2+y^2}$。边界条件为硬壁，即 $\\psi(r=R) = 0$。\n\n我们将这个连续问题离散化到有限网格上，以获得一个矩阵特征值问题。在方形区域 $[-R, R] \\times [-R, R]$上构建一个均匀的笛卡尔网格，包含 $N \\times N$ 个点。网格坐标为 $(x_i, y_j)$，其中对于索引 $i, j \\in \\{0, 1, \\dots, N-1\\}$，$x_i = -R + i \\cdot h$ 且 $y_j = -R + j \\cdot h$。网格间距为 $h = 2R/(N-1)$。\n\n在每个内部网格点 $(x_i, y_j)$ 处，拉普拉斯算子 $\\nabla^2$ 使用标准的五点中心差分格式近似：\n$$\n\\nabla^2 \\psi(x_i, y_j) \\approx \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\,\\psi_{i,j}}{h^2}\n$$\n其中 $\\psi_{i,j}$ 表示波函数在 $(x_i, y_j)$ 处的值 $\\psi(x_i, y_j)$。\n\n将此近似代入薛定谔方程并重新整理各项，得到每个相关网格点的离散方程：\n$$\n\\left(\\frac{4}{h^2} + V(x_i, y_j)\\right) \\psi_{i,j} - \\frac{1}{h^2}\\left(\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1}\\right) = E\\,\\psi_{i,j}\n$$\n狄利克雷边界条件 $\\psi(r=R)=0$ 的施加方式为，仅考虑严格位于圆形边界内部的网格点，即那些满足半径 $r_{i,j} = \\sqrt{x_i^2+y_j^2} < R$ 的点 $(x_i, y_j)$。假设有 $M$ 个这样的内部点。这些 $M$ 个点上的波函数值 $\\{\\psi_{i,j}\\}$ 构成了未知数的集合。这些未知数被排序并展开成一个维度为 $M$ 的单列向量 $\\mathbf{u}$。\n\n所有 $M$ 个点的线性方程组可以表示为矩阵形式 $H\\mathbf{u} = E\\mathbf{u}$。这里，$H$ 是 $M \\times M$ 的离散哈密顿矩阵。为了构建 $H$，我们首先建立一个从每个内部网格点的二维索引 $(i,j)$ 到一维向量索引 $k \\in \\{0, 1, \\dots, M-1\\}$ 的映射。\n\n矩阵 $H$ 的元素确定如下：\n对于索引为 $k$、对应于网格位置 $(i,j)$ 的一个内部点：\n对角线元素由该点的动能项和势能项给出：\n$$\nH_{k,k} = \\frac{4}{h^2} + V(x_i, y_j) = \\frac{4}{h^2} - \\frac{\\alpha}{\\sqrt{x_i^2 + y_j^2 + \\delta^2}}\n$$\n非对角线元素表示与邻近点的耦合。对于一个位于 $(i', j')$、对应于向量索引 $l$ 的邻近网格点，矩阵元素为：\n$$\nH_{k,l} = -\\frac{1}{h^2}\n$$\n仅当邻近点 $(i', j')$ 是四个相邻点之一 —— $(i+1,j)$, $(i-1,j)$, $(i,j+1)$ 或 $(i,j-1)$ —— 并且它也是圆形区域内的一个内部点时，该元素才非零。如果一个邻近点位于边界圆上或圆外，其贡献为零，这正确地实现了狄利克雷条件。\n\n最终得到的矩阵 $H$ 是实数、对称且稀疏的。基态能量 $E_{\\min}$ 对应于 $H$ 的最小代数本征值。由于 $H$ 的尺寸很大（即使对于中等大小的 $N$，$M$ 也可能达到数千），使用直接对角化方法在计算上是低效的。因此，需要使用一种为大型、稀疏、对称矩阵优化的迭代算法。在 `scipy.sparse.linalg.eigsh` 函数中实现的 Lanczos 算法是完成此任务的一个合适且鲁棒的选择。我们将此函数配置为求解最小的代数本征值，即 `which='SA'` (Smallest Algebraic)，这直接对应于基态。\n\n因此，整体算法如下：\n1.  对于给定的参数 $N$、$R$、$\\alpha$ 和 $\\delta$，定义网格。\n2.  识别出所有严格位于半径为 $R$ 的圆内的网格点 $(x_i, y_j)$。这定义了问题的大小 $M$。\n3.  创建一个从这 $M$ 个点的二维索引 $(i,j)$ 到一维索引 $k$ 的映射。\n4.  基于有限差分格式和势能值，构建 $M \\times M$ 的稀疏矩阵 $H$。\n5.  使用稀疏特征值求解器（`scipy.sparse.linalg.eigsh`）来找到 $H$ 的最小本征值。\n6.  该本征值即为所求的基态能量 $E_{\\min}$。\n对问题陈述中指定的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import eigsh\n\ndef compute_ground_state(N, R, alpha, delta):\n    \"\"\"\n    Constructs and solves the discrete Schrödinger equation for a 2D quantum dot.\n\n    Args:\n        N (int): Number of grid points along one axis.\n        R (float): Radius of the circular quantum dot.\n        alpha (float): Strength of the central attractive potential.\n        delta (float): Softening length for the potential.\n\n    Returns:\n        float: The ground-state energy (smallest eigenvalue).\n    \"\"\"\n    # 1. Define the grid\n    h = 2.0 * R / (N - 1)\n    grid_coords = np.linspace(-R, R, N)\n    \n    # 2. Identify interior points and create index mapping\n    # The unknowns are the wavefunction values at points (x_i, y_j) where r < R\n    interior_points = []\n    point_to_index = {}\n    for i in range(N):\n        for j in range(N):\n            x = grid_coords[i]\n            y = grid_coords[j]\n            if x**2 + y**2 < R**2:\n                idx = len(interior_points)\n                interior_points.append((i, j))\n                point_to_index[(i, j)] = idx\n\n    M = len(interior_points)\n    if M == 0:\n        return np.inf\n\n    # 3. Construct the sparse Hamiltonian matrix H\n    H = lil_matrix((M, M), dtype=np.float64)\n    \n    h2_inv = 1.0 / h**2\n    \n    for k, (i, j) in enumerate(interior_points):\n        # Diagonal elements: kinetic term + potential term\n        x = grid_coords[i]\n        y = grid_coords[j]\n        r_sq = x**2 + y**2\n        \n        potential_V = -alpha / np.sqrt(r_sq + delta**2)\n        H[k, k] = 4.0 * h2_inv + potential_V\n        \n        # Off-diagonal elements (coupling to neighbors)\n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for ni, nj in neighbors:\n            # The neighbor must also be an interior point\n            if (ni, nj) in point_to_index:\n                l = point_to_index[(ni, nj)]\n                H[k, l] = -h2_inv\n\n    # 4. Solve the eigenvalue problem for the smallest eigenvalue\n    # Convert H to Compressed Sparse Column format for efficient computation\n    H_csc = H.asformat('csc')\n    \n    # We need the smallest algebraic eigenvalue, which corresponds to the ground state.\n    # eigsh is suitable for symmetric matrices. We ask for 1 eigenvalue ('k=1')\n    # with the smallest algebraic value ('which=SA'). This robustly finds the ground state,\n    # which can be negative for an attractive potential.\n    eigenvalues = eigsh(H_csc, k=1, which='SA', return_eigenvectors=False)\n    \n    e_min = eigenvalues[0]\n    return e_min\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, alpha, delta)\n        (41, 1.0, 0.0, 0.02),\n        (51, 1.0, 0.5, 0.02),\n        (51, 1.0, 1.5, 0.02),\n        (31, 1.0, 0.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, R, alpha, delta = case\n        ground_energy = compute_ground_state(N, R, alpha, delta)\n        results.append(ground_energy)\n\n    # Final print statement in the exact required format.\n    # The result for each case must be rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2387539"}, {"introduction": "在求解本征值问题时，求出本征值（能量）往往只是第一步。本征向量（波函数）本身包含了关于系统物理性质的丰富信息。本练习将带你探索安德森局域化这一深刻的物理现象，通过分析本征向量的一个统计特性——反参与比（Inverse Participation Ratio），来区分无序系统中的扩展态和局域态，展示了本征向量分析在揭示物理本质中的强大作用。[@problem_id:2387591]", "problem": "你需要通过求解本征值问题和分析本征向量，对一维紧束缚模型中的安德森局域化进行数值研究。考虑一个长度为 $N$、具有开放边界条件的一维链，其紧束缚哈密顿量定义在由位点局域基态所张成的希尔伯特空间上。哈密顿矩阵 $H \\in \\mathbb{R}^{N \\times N}$ 由下式指定：\n$$\nH_{ij} = \\epsilon_i \\delta_{ij} - t \\left( \\delta_{i,j+1} + \\delta_{i,j-1} \\right),\n$$\n其中，$\\epsilon_i$ 是从区间 $[-W/2, W/2]$ 的均匀分布中抽取的独立在位能，$t$ 是最近邻跃迁振幅，$\\delta_{ij}$ 是克罗内克δ函数。使用 $t = 1$。\n\n对于 $H$ 的任意一个归一化本征向量 $\\boldsymbol{\\psi}^{(k)} = (\\psi^{(k)}_1,\\ldots,\\psi^{(k)}_N)$ 及其对应的本征值 $E_k$，定义逆参与率 (IPR) 为：\n$$\n\\mathrm{IPR}_k = \\sum_{i=1}^{N} \\left| \\psi^{(k)}_i \\right|^4.\n$$\n设能量窗口以 $E = 0$ 为中心，半宽为 $\\Delta E = 0.5$。对于一个给定的实例 $(N, W, s)$，其中 $s$ 是一个整数随机种子，请根据上述规则构建 $H$ 并计算所有本征对 $(E_k, \\boldsymbol{\\psi}^{(k)})$。选取满足 $|E_k| \\le \\Delta E$ 的下标 $k$ 构成的子集 $\\mathcal{S}$。如果 $\\mathcal{S}$ 非空，计算该子集上的平均逆参与率：\n$$\n\\overline{\\mathrm{IPR}} = \\frac{1}{|\\mathcal{S}|} \\sum_{k \\in \\mathcal{S}} \\mathrm{IPR}_k.\n$$\n如果 $\\mathcal{S}$ 为空，则将 $\\overline{\\mathrm{IPR}}$ 定义为具有最小绝对值 $|E_k|$ 的本征值 $E_k$ 所对应的单个本征向量的 $\\mathrm{IPR}_k$。\n\n所有量均为无量纲量。对于每个测试用例，都使用提供的种子 $s$ 初始化伪随机数生成器，以确保结果是可复现的。\n\n请实现一个程序，对以下每个测试用例计算 $\\overline{\\mathrm{IPR}}$ 并将其四舍五入到六位小数：\n\n- 测试用例 1: $(N, W, s) = (50, 0.0, 12345)$。\n- 测试用例 2: $(N, W, s) = (50, 1.0, 123)$。\n- 测试用例 3: $(N, W, s) = (50, 4.0, 42)$。\n- 测试用例 4: $(N, W, s) = (200, 2.0, 2024)$。\n\n你的程序应该生成一行输出，其中包含四个结果，格式为方括号括起来的逗号分隔列表，四舍五入到六位小数，并按上面列出的测试用例顺序排列（例如，“[$x_1,x_2,x_3,x_4$]”，其中每个 $x_i$ 是小数点后有六位的十进制数）。不要打印任何其他文本。", "solution": "所提出的问题是计算凝聚态物理中一个有效且适定的数值任务。它涉及研究一维系统中的安德森局域化。我们将按部就班地进行求解。\n\n研究的核心对象是一个具有开放边界条件的 $N$ 个位点的一维链的紧束缚哈密顿量。该哈密顿量的矩阵表示 $H$ 由下式给出：\n$$\nH_{ij} = \\epsilon_i \\delta_{ij} - t \\left( \\delta_{i,j+1} + \\delta_{i,j-1} \\right)\n$$\n这里，$H_{ii} = \\epsilon_i$ 是对角元素，代表在位能。这些能量是随机变量，独立地从均匀分布 $U[-W/2, W/2]$ 中抽取，其中 $W$ 是无序强度。非对角元素 $H_{i,i\\pm 1} = -t$ 代表电子在相邻位点 $i$ 和 $i \\pm 1$ 之间跃迁的动能。跃迁振幅固定为 $t=1$。所有其他矩阵元素均为零。这种结构形成一个实对称三对角矩阵。\n\n我们算法的第一步是为每个给定的测试用例 $(N, W, s)$ 构建这个 $N \\times N$ 的哈密顿矩阵。为保证可复现性，用于生成在位能 $\\epsilon_i$ 的伪随机数生成器必须用指定的整数种子 $s$ 进行初始化。\n\n一旦哈密顿矩阵 $H$ 构建完成，我们必须求解不含时薛定谔方程，该方程表现为本征值问题：\n$$\nH \\boldsymbol{\\psi}^{(k)} = E_k \\boldsymbol{\\psi}^{(k)}\n$$\n其中 $E_k$ 是能量本征值，$\\boldsymbol{\\psi}^{(k)}$ 是对应的本征向量（或称波函数）。由于 $H$ 是一个实对称矩阵，其本征值 $E_k$ 均为实数，其本征向量 $\\boldsymbol{\\psi}^{(k)}$ 构成一个完备的规范正交基。我们将使用专为此类矩阵设计的数值本征求解器，例如 SciPy 或 NumPy 库中的 `eigh` 函数，来计算所有 $N$ 个本征对 $(E_k, \\boldsymbol{\\psi}^{(k)})$。该函数通常按升序返回本征值。\n\n本征向量 $\\boldsymbol{\\psi}^{(k)}$ 的局域化程度由其逆参与率 (IPR) 来量化。对于一个归一化的本征向量 $\\boldsymbol{\\psi}^{(k)} = (\\psi^{(k)}_1, \\ldots, \\psi^{(k)}_N)$，IPR 定义为：\n$$\n\\mathrm{IPR}_k = \\sum_{i=1}^{N} \\left| \\psi^{(k)}_i \\right|^4\n$$\n一个离域态，其概率密度 $|\\psi^{(k)}_i|^2$ 均匀地分布在所有 $N$ 个位点上（即 $|\\psi^{(k)}_i|^2 \\approx 1/N$），其 IPR 的数量级为 $1/N$。相反，一个完全局域在单个位点 $j$ 上的态（即 $\\psi^{(k)}_i = \\delta_{ij}$），其 IPR 为 $1$。因此，较大的 IPR 意味着更强的局域化。\n\n问题要求我们分析以 $E=0$ 为中心的特定能量窗口内的本征态。我们定义一个本征态下标 $k$ 的子集 $\\mathcal{S}$，使其对应的本征值落在此窗口内：\n$$\n\\mathcal{S} = \\{ k \\mid |E_k| \\le \\Delta E \\}\n$$\n能量半宽给定为 $\\Delta E = 0.5$。\n\n最终要计算的量是这个态子集上的平均 IPR，记为 $\\overline{\\mathrm{IPR}}$。其计算方法取决于集合 $\\mathcal{S}$ 是否为空。\n1.  如果 $\\mathcal{S}$ 非空（即能量窗口中至少有一个态），我们计算该子集中所有态的 IPR 的算术平均值：\n    $$\n    \\overline{\\mathrm{IPR}} = \\frac{1}{|\\mathcal{S}|} \\sum_{k \\in \\mathcal{S}} \\mathrm{IPR}_k\n    $$\n2.  如果 $\\mathcal{S}$ 为空，问题指定了另一种处理方法。我们必须找到其本征值 $E_k$ 最接近零（即具有最小绝对值 $|E_k|$）的那个本征向量。然后将量 $\\overline{\\mathrm{IPR}}$ 定义为此特定态的 IPR。\n\n对于每个测试用例 $(N, W, s)$ 的总体算法如下：\n1.  使用种子 $s$ 初始化随机数生成器。\n2.  构建 $N \\times N$ 的三对角哈密顿矩阵 $H$：\n    a. 从 $U[-W/2, W/2]$ 中生成 $N$ 个随机在位能 $\\epsilon_i$作为对角线元素。\n    b. 将第一上对角线和第一下对角线的元素设置为 $-t = -1$。\n3.  求解 $H$ 的本征值问题，以获得所有本征值 $E_k$ 和对应的归一化本征向量 $\\boldsymbol{\\psi}^{(k)}$。\n4.  对每个本征向量 $\\boldsymbol{\\psi}^{(k)}$，计算其 IPR, $\\mathrm{IPR}_k = \\sum_{i=1}^{N} (\\psi^{(k)}_i)^4$。\n5.  识别出属于集合 $\\mathcal{S}$（其中 $|E_k| \\le 0.5$）的下标 $k$。\n6.  根据上述两种情况计算 $\\overline{\\mathrm{IPR}}$。\n7.  将最终结果四舍五入到六位小数。\n\n此过程将针对每个提供的测试用例进行实现和执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, W, s)\n        (50, 0.0, 12345),\n        (50, 1.0, 123),\n        (50, 4.0, 42),\n        (200, 2.0, 2024),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, W, s = case\n        \n        # 1. Initialize random number generator for reproducibility.\n        rng = np.random.default_rng(seed=s)\n\n        # 2. Construct the Hamiltonian matrix H.\n        # The hopping amplitude t is 1. The off-diagonal elements are -t.\n        t = 1.0\n\n        # The diagonal consists of on-site energies epsilon_i drawn from a\n        # uniform distribution on [-W/2, W/2].\n        onsite_energies = rng.uniform(low=-W/2.0, high=W/2.0, size=N)\n        H = np.diag(onsite_energies)\n\n        # The off-diagonal elements for nearest-neighbor hopping in a\n        # 1D chain with open boundary conditions.\n        off_diagonal_elements = -t * np.ones(N - 1)\n        H += np.diag(off_diagonal_elements, k=1)\n        H += np.diag(off_diagonal_elements, k=-1)\n\n        # 3. Solve the eigenvalue problem H*psi = E*psi.\n        # eigh is used for Hermitian (real symmetric) matrices. It returns\n        # eigenvalues in ascending order and corresponding eigenvectors as columns.\n        eigenvalues, eigenvectors = eigh(H)\n\n        # 4. Calculate the Inverse Participation Ratio (IPR) for all eigenvectors.\n        # IPR_k = sum_i |psi_i^(k)|^4. Since eigenvectors are real, this is sum(psi**4).\n        # The eigenvectors are columns of the 'eigenvectors' matrix, so axis=0.\n        ipr_values = np.sum(eigenvectors**4, axis=0)\n\n        # 5. Select the subset of states within the specified energy window.\n        # The window is centered at E=0 with half-width Delta_E = 0.5.\n        delta_E = 0.5\n        energy_window_indices = np.where(np.abs(eigenvalues) <= delta_E)[0]\n\n        # 6. Compute the mean IPR according to the problem's rules.\n        mean_ipr = 0.0\n        if len(energy_window_indices) > 0:\n            # Case 1: The subset S is non-empty. Average the IPRs of the\n            # states within the window.\n            selected_iprs = ipr_values[energy_window_indices]\n            mean_ipr = np.mean(selected_iprs)\n        else:\n            # Case 2: The subset S is empty. Find the IPR of the state\n            # whose eigenvalue has the smallest absolute value.\n            idx_min_abs_E = np.argmin(np.abs(eigenvalues))\n            mean_ipr = ipr_values[idx_min_abs_E]\n\n        # Store the result rounded to six decimal places.\n        results.append(f\"{mean_ipr:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2387591"}]}