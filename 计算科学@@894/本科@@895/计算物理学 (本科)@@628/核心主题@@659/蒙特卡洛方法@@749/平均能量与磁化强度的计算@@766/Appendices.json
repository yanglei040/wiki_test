{"hands_on_practices": [{"introduction": "第一个实践提供了统计力学中的一个基础练习：从微观态计算宏观性质。通过对一个小型二维伊辛模型的所有可能构型进行精确枚举，你将直接根据配分函数计算平均能量和磁化强度。该练习将巩固对系统哈密顿量与其可观测热力学行为之间联系的理解，即使在非均匀外场的影响下也是如此。[@problem_id:2380966]", "problem": "考虑一个二维伊辛模型，该模型包含 $N=L_x L_y$ 个自旋 $s_i \\in \\{+1,-1\\}$，分布在尺寸为 $L_x \\times L_y$ 的矩形晶格上，且在两个方向上均具有周期性边界条件。其哈密顿量定义为\n$$\nE(\\mathbf{s}) \\equiv -J \\sum_{\\langle i,j\\rangle} s_i s_j \\;-\\; \\sum_{i=1}^{N} h(x_i) s_i,\n$$\n其中 $\\langle i,j\\rangle$ 表示最近邻对，每条键只计算一次，$J>0$ 是铁磁交换常数，依赖于位置的外部磁场为\n$$\nh(x) \\equiv H_0 \\,\\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right),\n$$\n其中 $x\\in \\{0,1,\\dots,L_x-1\\}$ 是格点的整数x坐标。正弦函数的参数必须以弧度为单位。使用无量纲单位，设玻尔兹曼常数 $k_{\\mathrm{B}}=1$，能量以 $J$ 为单位度量，温度 $T$ 以 $J$ 为单位度量。温度为 $T$ 时的正则系综定义了配分函数\n$$\nZ \\equiv \\sum_{\\mathbf{s}} e^{-\\beta E(\\mathbf{s})}, \\quad \\beta \\equiv \\frac{1}{T},\n$$\n和系综平均\n$$\n\\langle E \\rangle \\equiv \\frac{1}{Z}\\sum_{\\mathbf{s}} E(\\mathbf{s})\\, e^{-\\beta E(\\mathbf{s})}, \\qquad\n\\langle M \\rangle \\equiv \\frac{1}{Z}\\sum_{\\mathbf{s}} \\left(\\sum_{i=1}^{N} s_i\\right)\\, e^{-\\beta E(\\mathbf{s})}.\n$$\n对于每个指定的参数集，计算如上定义的单位自旋平均能量 $\\langle E\\rangle/N$ 和单位自旋平均总磁化强度 $\\langle M\\rangle/N$。\n\n所有量均为无量纲，因此除上述规定外，不需要其他物理单位。$h(x)$ 中的角度必须以弧度解释。您的程序必须生成四舍五入到六位小数的数值。\n\n测试套件 (每个案例是一个元组 $(L_x,L_y,J,H_0,T)$):\n- 案例A: $(L_x,L_y,J,H_0,T)=(\\,3,\\,3,\\,1,\\,0,\\,2.5\\,)$。\n- 案例B: $(L_x,L_y,J,H_0,T)=(\\,4,\\,3,\\,1,\\,0.8,\\,1.8\\,)$。\n- 案例C: $(L_x,L_y,J,H_0,T)=(\\,2,\\,3,\\,1,\\,5.0,\\,1.0\\,)$。\n- 案例D: $(L_x,L_y,J,H_0,T)=(\\,3,\\,3,\\,1,\\,0.7,\\,\\infty\\,)$，其中 $T=\\infty$ 表示极限情况 $\\beta=0$。\n\n最终输出格式:\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 对于每个案例，按以下顺序输出两个浮点数：首先是 $\\langle E\\rangle/N$，然后是 $\\langle M\\rangle/N$，每个都四舍五入到六位小数。\n- 将案例A、B、C和D的结果按此顺序连接成一个单一的扁平列表。例如，输出格式必须为\n$$\n[\\langle E\\rangle/N\\text{(A)},\\langle M\\rangle/N\\text{(A)},\\langle E\\rangle/N\\text{(B)},\\langle M\\rangle/N\\text{(B)},\\langle E\\rangle/N\\text{(C)},\\langle M\\rangle/N\\text{(C)},\\langle E\\rangle/N\\text{(D)},\\langle M\\rangle/N\\text{(D)}].\n$$", "solution": "该问题陈述已经过严格验证，并被确定为有效。它具有科学依据、良构、客观且内部一致。它构成了统计物理学中的一个标准计算问题。\n\n该解决方案通过使用精确枚举法直接计算正则系综平均值来展开。对于所有测试案例，系统尺寸 $N = L_x L_y$ 都足够小（最大为 $N=12$），使得对所有 $2^N$ 个微观态的求和在计算上是可行的。\n\n计算的基础在于统计力学中正则系综的原理。系统处于能量为 $E(\\mathbf{s})$ 的特定微观态 $\\mathbf{s}$（一种自旋构型）的概率由玻尔兹曼分布给出：\n$$\nP(\\mathbf{s}) = \\frac{e^{-\\beta E(\\mathbf{s})}}{Z}\n$$\n其中 $\\beta = 1/T$ 是逆温度（玻尔兹曼常数 $k_B=1$），$Z$ 是配分函数，它作为一个归一化常数，确保所有概率之和为1。其定义为对所有可能的微观态求和：\n$$\nZ = \\sum_{\\mathbf{s}} e^{-\\beta E(\\mathbf{s})}\n$$\n任何可观测量 $O(\\mathbf{s})$ 的热平均（或期望值）则计算如下：\n$$\n\\langle O \\rangle = \\sum_{\\mathbf{s}} O(\\mathbf{s}) P(\\mathbf{s}) = \\frac{1}{Z} \\sum_{\\mathbf{s}} O(\\mathbf{s}) e^{-\\beta E(\\mathbf{s})}\n$$\n所需的具体量是平均能量 $\\langle E \\rangle$ 和平均总磁化强度 $\\langle M \\rangle = \\langle \\sum_i s_i \\rangle$。\n\n在具有周期性边界条件的 $L_x \\times L_y$ 晶格上的二维伊辛模型的哈密顿量 $E(\\mathbf{s})$ 如下所示：\n$$\nE(\\mathbf{s}) = -J \\sum_{\\langle i,j\\rangle} s_i s_j - \\sum_{i=1}^{N} h(x_i) s_i\n$$\n第一项是铁磁相互作用能，其中 $J>0$ 是耦合常数，求和遍及所有唯一的最近邻对 $\\langle i,j \\rangle$。第二项是由依赖于位置的外部磁场 $h(x) = H_0 \\sin(2\\pi x/L_x)$ 引起的能量，其中 $x \\in \\{0, 1, \\dots, L_x-1\\}$ 是格点的整数x坐标。\n\n计算算法如下：\n1. 对于由参数 $(L_x, L_y, J, H_0, T)$ 定义的每个测试案例，总自旋数为 $N = L_x L_y$。我们还计算逆温度 $\\beta = 1/T$。\n2. 我们遍历所有 $2^N$ 种可能的自旋构型。每个构型 $\\mathbf{s}$ 都可以唯一地映射到一个从 $0$ 到 $2^N-1$ 的整数。该整数的二进制表示用于设置自旋值 $s_i \\in \\{+1, -1\\}$。\n3. 对于每个构型 $\\mathbf{s}$：\n    a. 计算能量 $E(\\mathbf{s})$。通过对每个格点 $i$ 的自旋 $s_i$ 与其“右”和“下”邻居的自旋的乘积进行求和，可以高效地计算相互作用项 $\\sum_{\\langle i,j \\rangle} s_i s_j$，这种方法考虑了周期性边界条件并确保每条键只被计算一次。通过对所有格点上的 $-h(x_i)s_i$ 进行求和来计算外场能量。\n    b. 计算总磁化强度 $M(\\mathbf{s}) = \\sum_i s_i$。\n    c. 确定玻尔兹曼因子 $w = e^{-\\beta E(\\mathbf{s})}$。\n    d. 更新三个和：$S_Z = \\sum w$、$S_E = \\sum E(\\mathbf{s})w$ 和 $S_M = \\sum M(\\mathbf{s})w$，其中求和是针对迄今为止访问过的所有构型。\n4. 遍历完所有 $2^N$ 个构型后，计算系综平均值：\n$$\n\\langle E \\rangle = \\frac{S_E}{S_Z} \\qquad \\text{and} \\qquad \\langle M \\rangle = \\frac{S_M}{S_Z}\n$$\n最后，将这些值除以总自旋数 $N$，转换为单位自旋的量。\n\n对于 $T \\to \\infty$（案例D），即对应于 $\\beta \\to 0$ 的情况，出现了一个特殊情况。在此极限下，对所有构型，无论其能量如何，玻尔兹曼因子 $e^{-\\beta E(\\mathbf{s})} \\to e^0 = 1$。所有 $2^N$ 个态都变得等概率。由于自旋态的对称性（$s_i = \\pm 1$），任何单个自旋的热平均为零：$\\langle s_i \\rangle = (1/2)(+1) + (1/2)(-1) = 0$。类似地，对于任何不同的自旋对，$\\langle s_i s_j \\rangle = \\langle s_i \\rangle \\langle s_j \\rangle = 0$。平均磁化强度为 $\\langle M \\rangle = \\sum_i \\langle s_i \\rangle = 0$。平均能量为 $\\langle E \\rangle = -J \\sum_{\\langle i,j\\rangle} \\langle s_i s_j \\rangle - \\sum_i h(x_i) \\langle s_i \\rangle = 0$。因此，对于案例D，单位自旋的平均能量和单位自旋的平均磁化强度都精确为 $0$。这个解析结果被直接使用。\n\n最终的实现将此精确枚举算法转换为了一个 Python 脚本，该脚本利用 `numpy` 库进行高效的数组操作，特别是在计算带周期性边界的能量时。对于每个案例，计算出的 $\\langle E \\rangle/N$ 和 $\\langle M \\rangle/N$ 值都按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the average energy and magnetization per spin for a 2D Ising model\n    on a rectangular lattice with periodic boundary conditions using exact enumeration.\n    \"\"\"\n    # Test suite: (Lx, Ly, J, H0, T)\n    test_cases = [\n        (3, 3, 1.0, 0.0, 2.5),  # Case A\n        (4, 3, 1.0, 0.8, 1.8),  # Case B\n        (2, 3, 1.0, 5.0, 1.0),  # Case C\n        (3, 3, 1.0, 0.7, float('inf')),  # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        Lx, Ly, J, H0, T = case\n        N = Lx * Ly\n\n        # Handle the infinite temperature limit analytically\n        if T == float('inf'):\n            E_per_spin = 0.0\n            M_per_spin = 0.0\n            results.extend([E_per_spin, M_per_spin])\n            continue\n\n        beta = 1.0 / T\n\n        # Pre-calculate the site-dependent magnetic field grid\n        x_coords = np.arange(Lx)\n        h_vals = H0 * np.sin(2.0 * np.pi * x_coords / Lx)\n        H_grid = np.tile(h_vals, (Ly, 1))\n\n        # Initialize sums for partition function and observables\n        Z_sum = 0.0\n        E_times_Z_sum = 0.0\n        M_times_Z_sum = 0.0\n\n        # Iterate through all 2^N spin configurations\n        for i in range(2**N):\n            # Generate the spin configuration from the integer's binary representation\n            # '0' bit maps to spin -1, '1' bit maps to spin +1\n            bits = bin(i)[2:].zfill(N)\n            spins_1d = np.array([int(b) * 2 - 1 for b in bits])\n            s = spins_1d.reshape((Ly, Lx))\n\n            # Calculate the total energy E(s) for the current configuration\n            # Interaction energy: sum over right and down neighbors to count each bond once\n            E_int = -J * np.sum(s * np.roll(s, -1, axis=1) + s * np.roll(s, -1, axis=0))\n            \n            # External field energy\n            E_field = -np.sum(s * H_grid)\n            \n            E = E_int + E_field\n\n            # Calculate the total magnetization M(s)\n            M = np.sum(s)\n\n            # Calculate the Boltzmann weight and update the sums\n            # Use a high-precision float to avoid overflow/underflow issues\n            boltzmann_weight = np.exp(-beta * E, dtype=np.float64)\n            \n            Z_sum += boltzmann_weight\n            E_times_Z_sum += E * boltzmann_weight\n            M_times_Z_sum += M * boltzmann_weight\n\n        # Calculate the ensemble averages\n        avg_E = E_times_Z_sum / Z_sum\n        avg_M = M_times_Z_sum / Z_sum\n\n        # Normalize to get per-spin quantities\n        E_per_spin = avg_E / N\n        M_per_spin = avg_M / N\n\n        results.append(round(E_per_spin, 6))\n        results.append(round(M_per_spin, 6))\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2380966"}, {"introduction": "从静态性质转向动态演化，本练习模拟了一个在网络上达成共识的过程，该模型直接类似于伊辛系统在零温下的动力学。你将实现一个异步更新算法，以观察局部少数服从多数的规则如何导致全局有序。这项实践对于理解集体行为如何随时间涌现以及培养模拟随机过程的技能至关重要。[@problem_id:2380973]", "problem": "给定一个节点网络，每个节点具有一个代表决策的二元状态，在离散时间 $t$ 用自旋 $s_i(t) \\in \\{-1,+1\\}$ 表示，其中 $i$ 是节点索引。该网络被建模为一个无向简单图，其节点集为 $\\{0,1,\\dots,N-1\\}$，边集为 $\\mathcal{E} \\subset \\{(i,j) \\mid 0 \\le i < j \\le N-1\\}$。系统在时间 $t$ 的微观构型是向量 $\\mathbf{s}(t) = (s_0(t),\\dots,s_{N-1}(t))$。构型的瞬时能量 $E(t)$ 定义为不一致连接（即端点具有相反自旋的边）的数量，由下式给出\n$$\nE(t) = \\sum_{(i,j) \\in \\mathcal{E}} \\frac{1 - s_i(t) s_j(t)}{2}.\n$$\n瞬时磁化强度 $m(t)$ 定义为自旋的算术平均值，\n$$\nm(t) = \\frac{1}{N} \\sum_{i=0}^{N-1} s_i(t).\n$$\n系统的动力学规定如下。在每个离散更新步 $t = 1,2,\\dots$，从 $\\{0,1,\\dots,N-1\\}$ 中均匀随机地选择一个节点索引 $i$。设 $N(i)$ 为图中节点 $i$ 的邻居集合。定义局部邻居和\n$$\nh_i(t) = \\sum_{j \\in N(i)} s_j(t-1).\n$$\n更新后的自旋 $s_i(t)$ 由以下规则设定\n$$\ns_i(t) = \n\\begin{cases}\n+1, & \\text{如果 } h_i(t) > 0,\\\\\n-1, & \\text{如果 } h_i(t) < 0,\\\\\n\\xi_t, & \\text{如果 } h_i(t) = 0,\n\\end{cases}\n$$\n其中 $\\xi_t$ 是一个独立的随机变量，以相等的概率 $1/2$ 取值 $+1$ 和 $-1$。在时间 $t$，所有其他自旋保持不变，即对所有 $k \\ne i$，有 $s_k(t) = s_k(t-1)$。更新调度是异步的，意味着每个离散时间步只更新一个节点。\n\n对于给定的有限数量的预烧步数 $T_{\\mathrm{burn}}$ 和测量步数 $T_{\\mathrm{meas}}$，定义测量窗口内的时间平均能量 $\\overline{E}$ 和时间平均磁化强度 $\\overline{m}$ 如下\n$$\n\\overline{E} = \\frac{1}{T_{\\mathrm{meas}}} \\sum_{t=T_{\\mathrm{burn}}+1}^{T_{\\mathrm{burn}}+T_{\\mathrm{meas}}} E(t), \\quad\n\\overline{m} = \\frac{1}{T_{\\mathrm{meas}}} \\sum_{t=T_{\\mathrm{burn}}+1}^{T_{\\mathrm{burn}}+T_{\\mathrm{meas}}} m(t).\n$$\n所有的随机选择（节点选择以及当 $h_i(t)=0$ 时的平局打破）必须由一个伪随机数生成器生成，该生成器使用指定的非负整数种子 $S$ 进行初始化，以确保结果的可复现性。\n\n你的任务是编写一个完整的程序，该程序针对下述每个测试用例，在时间 $t=0$ 用指定的自旋向量 $\\mathbf{s}(0)$ 初始化系统，然后根据上述规则执行 $T_{\\mathrm{burn}} + T_{\\mathrm{meas}}$ 个异步更新步，在每个步骤 $t \\ge 1$ 后计算 $E(t)$ 和 $m(t)$，并最终报告该测试用例的 $\\overline{E}$ 和 $\\overline{m}$。\n\n测试套件（每个用例指定 $N$、$\\mathcal{E}$、$\\mathbf{s}(0)$、$T_{\\mathrm{burn}}$、$T_{\\mathrm{meas}}$ 和 $S$）：\n- 用例 1（4个节点上的完全图）：\n  - $N = 4$,\n  - $\\mathcal{E} = \\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\\}$,\n  - $\\mathbf{s}(0) = [ +1, -1, +1, -1 ]$,\n  - $T_{\\mathrm{burn}} = 20$,\n  - $T_{\\mathrm{meas}} = 50$,\n  - $S = 1$.\n- 用例 2（10个节点上的环形图）：\n  - $N = 10$,\n  - $\\mathcal{E} = \\{(i,(i+1) \\bmod 10) \\mid i \\in \\{0,1,\\dots,9\\}\\}$,\n  - $\\mathbf{s}(0) = [ +1, -1, +1, -1, +1, -1, +1, -1, +1, -1 ]$,\n  - $T_{\\mathrm{burn}} = 200$,\n  - $T_{\\mathrm{meas}} = 400$,\n  - $S = 2$.\n- 用例 3（6个节点上的星形图，中心为节点0）：\n  - $N = 6$,\n  - $\\mathcal{E} = \\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$,\n  - $\\mathbf{s}(0) = [ +1, +1, -1, -1, -1, -1 ]$,\n  - $T_{\\mathrm{burn}} = 100$,\n  - $T_{\\mathrm{meas}} = 200$,\n  - $S = 3$.\n- 用例 4（5个节点上的路径图）：\n  - $N = 5$,\n  - $\\mathcal{E} = \\{(0,1),(1,2),(2,3),(3,4)\\}$,\n  - $\\mathbf{s}(0) = [ +1, +1, +1, +1, +1 ]$,\n  - $T_{\\mathrm{burn}} = 10$,\n  - $T_{\\mathrm{meas}} = 20$,\n  - $S = 4$.\n\n程序输出规范：\n- 对每个用例，计算如上定义的 $\\overline{E}$ 和 $\\overline{m}$。\n- 将每个报告值四舍五入到6位小数。\n- 最终的程序输出必须是单行，包含一个由逗号分隔的8个数字列表，顺序为 $[\\overline{E}_1,\\overline{m}_1,\\overline{E}_2,\\overline{m}_2,\\overline{E}_3,\\overline{m}_3,\\overline{E}_4,\\overline{m}_4]$，用方括号括起来，且没有空格。", "solution": "所给出的问题是统计物理学中一个定义明确的计算练习，具体来说是在一个图上模拟一个离散时间随机过程。该模型是投票者模型的一个变体，其中节点（自旋）会采纳其局部多数派的状态。其动力学与一个类伊辛 (Ising-like) 系统的零温更新算法相关。该问题具有科学依据、内部一致，并且需要通过直接模拟来找到所需的时间平均可观测量。\n\n该系统由一组 $N$ 个具有二元自旋 $s_i \\in \\{-1, +1\\}$ 的节点定义，构成一个无向图 $G = (V, \\mathcal{E})$，其中 $V = \\{0, 1, \\dots, N-1\\}$。系统在离散时间 $t$ 的构型为向量 $\\mathbf{s}(t) = (s_0(t), \\dots, s_{N-1}(t))$。\n\n瞬时能量 $E(t)$ 定义为连接具有相反自旋的节点的边的数量：\n$$\nE(t) = \\sum_{(i,j) \\in \\mathcal{E}} \\frac{1 - s_i(t) s_j(t)}{2}\n$$\n如果 $s_i(t) \\ne s_j(t)$，该表达式的值为 $1$，否则为 $0$，因此它正确地计算了“不一致”或“反铁磁性”连接的数量。瞬时磁化强度 $m(t)$ 是整个网络上的平均自旋值：\n$$\nm(t) = \\frac{1}{N} \\sum_{i=0}^{N-1} s_i(t)\n$$\n\n系统根据异步更新调度进行演化。在每个时间步 $t \\ge 1$，从所有节点中均匀随机地选择一个节点 $i$ 进行可能的状态改变。更新规则是确定性的，取决于该节点的邻居 $N(i)$ 在前一个时间步 $t-1$ 的状态。新状态 $s_i(t)$ 由局部邻居和 $h_i(t)$ 的符号决定：\n$$\nh_i(t) = \\sum_{j \\in N(i)} s_j(t-1)\n$$\n自旋 $s_i(t)$ 更新如下：\n$$\ns_i(t) = \n\\begin{cases}\n+1, & \\text{如果 } h_i(t) > 0 \\\\\n-1, & \\text{如果 } h_i(t) < 0 \\\\\n\\xi_t, & \\text{如果 } h_i(t) = 0\n\\end{cases}\n$$\n其中 $\\xi_t$ 是一个从 $\\{-1, +1\\}$ 中等概率抽取的随机变量，$P(\\xi_t = 1) = P(\\xi_t = -1) = 1/2$。所有其他自旋保持不变：对于 $k \\ne i$，$s_k(t) = s_k(t-1)$。此更新规则使自旋与局部多数意见对齐，这对应于一个局部能量最小化步骤。随机性通过随机选择要更新的节点以及当 $h_i(t) = 0$ 时的平局打破规则引入。\n\n任务是计算在指定测量窗口内的时间平均能量 $\\overline{E}$ 和磁化强度 $\\overline{m}$。模拟总共运行 $T_{\\mathrm{burn}} + T_{\\mathrm{meas}}$ 步。最初的 $T_{\\mathrm{burn}}$ 步构成“预烧”或热化阶段，在此期间系统向统计稳态演化，不进行测量。随后的 $T_{\\mathrm{meas}}$ 步构成测量阶段。平均值定义为：\n$$\n\\overline{E} = \\frac{1}{T_{\\mathrm{meas}}} \\sum_{t=T_{\\mathrm{burn}}+1}^{T_{\\mathrm{burn}}+T_{\\mathrm{meas}}} E(t), \\quad\n\\overline{m} = \\frac{1}{T_{\\mathrm{meas}}} \\sum_{t=T_{\\mathrm{burn}}+1}^{T_{\\mathrm{burn}}+T_{\\mathrm{meas}}} m(t)\n$$\n模拟的所有随机元素必须由一个使用特定种子 $S$ 初始化的伪随机数生成器（PRNG）控制，以确保可复现性。\n\n每个测试用例的计算过程如下：\n1. 使用给定的种子 $S$ 初始化伪随机数生成器。\n2. 使用邻接表表示图，这对于访问邻居是高效的。初始自旋构型 $\\mathbf{s}(0)$ 存储在数值数组中。\n3. 初始化能量和磁化强度的累积和，$\\Sigma E = 0$ 和 $\\Sigma m = 0$。\n4. 执行一个从 $t=1$ 到 $T_{\\mathrm{burn}} + T_{\\mathrm{meas}}$ 的循环：\n    a. 使用伪随机数生成器从 $\\{0, \\dots, N-1\\}$ 中均匀随机选择一个节点索引 $i_{\\mathrm{update}}$。\n    b. 使用时间 $t-1$ 的自旋状态计算局部邻居和 $h_{i_{\\mathrm{update}}}(t)$。\n    c. 根据 $h_{i_{\\mathrm{update}}}(t)$ 的符号更新自旋 $s_{i_{\\mathrm{update}}}(t)$，如果 $h_{i_{\\mathrm{update}}}(t)=0$，则使用伪随机数生成器打破平局。自旋数组被就地修改以反映状态 $\\mathbf{s}(t)$。\n    d. 如果当前步 $t$ 处于测量窗口内（即 $t > T_{\\mathrm{burn}}$），则从新更新的状态 $\\mathbf{s}(t)$ 计算瞬时 $E(t)$ 和 $m(t)$。\n    e. 将这些瞬时值加到各自的累积和 $\\Sigma E$ 和 $\\Sigma m$ 中。\n5. 循环结束后，计算平均值：$\\overline{E} = \\Sigma E / T_{\\mathrm{meas}}$ 和 $\\overline{m} = \\Sigma m / T_{\\mathrm{meas}}$。\n6. 按要求将最终平均值四舍五入到6位小数。\n\n该算法为每个提供的测试用例实现，并将结果汇总成指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n\n    def solve_case(N, edges, s0, T_burn, T_meas, S):\n        \"\"\"\n        Solves a single test case of the spin network simulation.\n\n        Args:\n            N (int): Number of nodes.\n            edges (list of tuples): List of edges in the graph.\n            s0 (list of int): Initial spin configuration.\n            T_burn (int): Number of burn-in steps.\n            T_meas (int): Number of measurement steps.\n            S (int): Seed for the random number generator.\n\n        Returns:\n            tuple: A tuple containing the time-averaged energy and magnetization,\n                   each rounded to 6 decimal places.\n        \"\"\"\n        # 1. Initialize the PRNG with the given seed S.\n        rng = np.random.default_rng(seed=S)\n\n        # 2. Represent the graph using an adjacency list.\n        adj = [[] for _ in range(N)]\n        for i, j in edges:\n            adj[i].append(j)\n            adj[j].append(i)\n\n        # The spin configuration is stored in a NumPy array.\n        s = np.array(s0, dtype=np.int8)\n\n        # 3. Initialize cumulative sums for energy and magnetization.\n        total_E = 0.0\n        total_m = 0.0\n        \n        T_total = T_burn + T_meas\n\n        # 4. Execute the simulation loop.\n        for t in range(1, T_total + 1):\n            # a. Select a node to update uniformly at random.\n            i_update = rng.integers(N)\n\n            # b. Calculate the local neighbor sum h_i.\n            h_i = 0\n            for neighbor in adj[i_update]:\n                h_i += s[neighbor]\n\n            # c. Update the spin s_i based on the sign of h_i.\n            if h_i > 0:\n                s[i_update] = 1\n            elif h_i  0:\n                s[i_update] = -1\n            else:  # h_i == 0, tie-breaking\n                s[i_update] = rng.choice([-1, 1])\n\n            # d. If in measurement phase, compute and accumulate observables.\n            if t > T_burn:\n                # Calculate instantaneous energy E(t): number of disagreeing connections.\n                # The formula (1 - s_i*s_j)/2 is equivalent to counting disagreeing pairs.\n                current_E = 0.5 * sum(1 - s[u] * s[v] for u, v in edges)\n                \n                # Calculate instantaneous magnetization m(t): mean of spins.\n                current_m = np.mean(s)\n\n                # e. Add to cumulative sums.\n                total_E += current_E\n                total_m += current_m\n\n        # 5. Calculate final averages.\n        avg_E = total_E / T_meas if T_meas > 0 else 0\n        avg_m = total_m / T_meas if T_meas > 0 else 0\n\n        # 6. Round results.\n        return round(avg_E, 6), round(avg_m, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: complete graph on 4 nodes\n        {\n            \"N\": 4,\n            \"edges\": [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)],\n            \"s0\": [+1, -1, +1, -1],\n            \"T_burn\": 20,\n            \"T_meas\": 50,\n            \"S\": 1\n        },\n        # Case 2: ring on 10 nodes\n        {\n            \"N\": 10,\n            # Normalize edges to (i, j) with i  j\n            \"edges\": list(sorted({tuple(sorted(t)) for t in [(i, (i + 1) % 10) for i in range(10)]})),\n            \"s0\": [+1, -1, +1, -1, +1, -1, +1, -1, +1, -1],\n            \"T_burn\": 200,\n            \"T_meas\": 400,\n            \"S\": 2\n        },\n        # Case 3: star on 6 nodes\n        {\n            \"N\": 6,\n            \"edges\": [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)],\n            \"s0\": [+1, +1, -1, -1, -1, -1],\n            \"T_burn\": 100,\n            \"T_meas\": 200,\n            \"S\": 3\n        },\n        # Case 4: path on 5 nodes\n        {\n            \"N\": 5,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (3, 4)],\n            \"s0\": [+1, +1, +1, +1, +1],\n            \"T_burn\": 10,\n            \"T_meas\": 20,\n            \"S\": 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E_avg, m_avg = solve_case(**case)\n        results.append(E_avg)\n        results.append(m_avg)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2380973"}, {"introduction": "许多计算物理研究的最后一步是分析模拟产生的大量数据。本练习介绍了一种复杂的数据分析技术，通过检验能量分布的形状来表征相变。你将为合成数据集计算四阶能量累积量 $\\kappa_4$，并学习其符号如何帮助区分连续相变和非连续（一级）相变。[@problem_id:2380998]", "problem": "考虑一个格点自旋系统，其微观态由整数 $i \\in \\{1,\\dots,N\\}$ 索引，每个微观态具有能量 $E_i$ 和总磁化强度 $M_i$。对于一组 $N$ 个统计独立的样本 $\\{(E_i,M_i)\\}_{i=1}^N$，定义样本平均值 $\\langle E \\rangle_N = \\frac{1}{N} \\sum_{i=1}^N E_i$ 和 $\\langle |M| \\rangle_N = \\frac{1}{N} \\sum_{i=1}^N |M_i|$。能量涨落由中心矩 $\\mu_k = \\frac{1}{N}\\sum_{i=1}^N (E_i - \\langle E \\rangle_N)^k$ 量化，其中整数 $k \\ge 1$。能量的累积量生成函数为 $K_E(t) = \\ln \\langle e^{t E} \\rangle$，而第 $n$ 阶能量累积量定义为 $\\kappa_n = \\left.\\frac{d^n}{dt^n} K_E(t) \\right|_{t=0}$。你的任务是推导一个四阶能量累积量 $\\kappa_4$ 的可计算表达式，该表达式纯粹用最高4阶的经验中心矩表示，然后在模仿单峰和双峰能量分布的合成数据集上进行数值实现。\n\n从上述基本定义出发，且不使用任何预先提供的快捷公式，完成以下任务：\n- 推导一个用从样本 $\\{E_i\\}_{i=1}^N$ 计算出的中心矩 $\\mu_2$ 和 $\\mu_4$ 表示四阶能量累积量 $\\kappa_4$ 的公式。使用累积量生成函数的定义以及矩和累积量的性质来证明每一步。\n- 运用概率论的基本原理，解释为什么相共存点（一级相变的典型特征）附近的对称双峰能量分布，与连续临界点（二级相变的典型特征）附近的单峰、近似高斯的能量分布，在 $\\kappa_4$ 的符号上存在差异。\n- 实现一个程序，该程序：\n  - 为下述每种测试情况生成独立的样本 $(E_i,M_i)$。\n  - 计算经验平均值 $\\langle E \\rangle_N$ 和 $\\langle |M| \\rangle_N$。\n  - 计算能量的经验中心矩 $\\mu_2$ 和 $\\mu_4$，然后根据你推导的表达式计算四阶能量累积量 $\\kappa_4$。\n  - 如果 $\\kappa_4  0$，则将每种情况分类为“类一级相变”，否则分类为“类二级相变”。将此分类编码为整数标签，类一级相变为 $1$，类二级相变为 $2$。\n  - 为保证可复现性，使用等于 $12345$ 的固定伪随机数生成器种子。\n\n你必须实现以下三个合成测试用例。所有分布都将使用独立的高斯分量进行采样，对于双分量混合分布，所有混合权重必须等于 $1/2$。以下所有数字都是无量纲的，必须严格按照给定的值使用。\n\n测试套件：\n- 情况 A（单峰，“类二级相变”基准）：抽取 $N = 50000$ 对 $(E,M)$，其中 $E \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2)$ 且 $M \\sim \\mathcal{N}(\\mu_M, \\sigma_M^2)$，此处 $\\mu_E = 0.0$，$\\sigma_E = 1.0$，$\\mu_M = 0.0$，$\\sigma_M = 1.0$。\n- 情况 B（双峰，“类一级相变”，清晰分离）：从两个独立高斯分布的等权重混合中抽取 $N = 50000$ 对 $(E,M)$，对 $E$ 和 $M$ 均如此。对于 $E$，分量为 $\\mathcal{N}(-2.0, 0.2^2)$ 和 $\\mathcal{N}(+2.0, 0.2^2)$。对于 $M$，分量为 $\\mathcal{N}(-1.0, 0.1^2)$ 和 $\\mathcal{N}(+1.0, 0.1^2)$。\n- 情况 C（双峰，“类一级相变”，有限样本边缘情况）：从两个独立高斯分布的等权重混合中抽取 $N = 1000$ 对 $(E,M)$，对 $E$ 和 $M$ 均如此。对于 $E$，分量为 $\\mathcal{N}(-1.5, 0.5^2)$ 和 $\\mathcal{N}(+1.5, 0.5^2)$。对于 $M$，分量为 $\\mathcal{N}(-0.5, 0.2^2)$ 和 $\\mathcal{N}(+0.5, 0.2^2)$。\n\n对于每种情况，你的程序必须按顺序输出一个包含四个量的列表：$[\\kappa_4, \\langle E \\rangle_N, \\langle |M| \\rangle_N, \\text{label}]$，其中 $\\kappa_4$、$\\langle E \\rangle_N$ 和 $\\langle |M| \\rangle_N$ 是实数，而 $\\text{label}$ 是如上定义的整数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含三种情况的结果，格式为一个由方括号括起来的、逗号分隔的列表的列表，严格如下：\n[[k4_A,meanE_A,meanAbsM_A,label_A],[k4_B,meanE_B,meanAbsM_B,label_B],[k4_C,meanE_C,meanAbsM_C,label_C]]\n不得打印任何其他文本。所有角度在此问题中均不相关，也不需要物理单位；报告所有数值结果时，使用纯实数，不带单位，也不带百分号。", "solution": "该问题提出了三个任务：首先，推导一个用经验中心矩表示四阶能量累积量 $\\kappa_4$ 的表达式；其次，从理论上解释 $\\kappa_4$ 的符号如何区分单峰和双峰能量分布；第三，在合成数据集上对这些概念进行数值实现。这个问题是适定的，并且在统计力学和概率论中有坚实的科学基础。我们着手解决此问题。\n\n### 第一部分：四阶累积量 $\\kappa_4$ 的推导\n\n累积量和矩之间的关系由它们各自的生成函数推导得出。随机变量 $E$ 的矩生成函数 (MGF) 定义为 $M_E(t) = \\langle e^{tE} \\rangle$，其中 $\\langle \\cdot \\rangle$ 表示期望值。将指数函数进行泰勒级数展开并逐项取期望，可以得到用原点矩 $m_k = \\langle E^k \\rangle$ 表示的 MGF：\n$$\nM_E(t) = \\left\\langle \\sum_{k=0}^{\\infty} \\frac{(tE)^k}{k!} \\right\\rangle = \\sum_{k=0}^{\\infty} \\frac{\\langle E^k \\rangle}{k!} t^k = \\sum_{k=0}^{\\infty} \\frac{m_k}{k!} t^k\n$$\n根据定义，$m_0 = 1$。累积量生成函数 (CGF) 定义为 $K_E(t) = \\ln M_E(t)$。第 $n$ 阶累积量 $\\kappa_n$ 是 $K_E(t)$ 在 $t=0$ 附近泰勒级数展开式中 $\\frac{t^n}{n!}$ 的系数：\n$$\nK_E(t) = \\sum_{n=1}^{\\infty} \\frac{\\kappa_n}{n!} t^n\n$$\n为了推导 $\\kappa_4$ 的表达式，我们将其与中心矩 $\\mu_k = \\langle (E - m_1)^k \\rangle$ 关联起来。累积量的一个关键性质是对于 $n \\ge 2$ 的阶数，其具有位移不变性。对于一个平移后的变量 $E' = E - c$，其 CGF 为 $K_{E'}(t) = K_E(t) - ct$。因此，$\\kappa_1(E') = \\kappa_1(E) - c$，且对所有 $n \\ge 2$，$\\kappa_n(E') = \\kappa_n(E)$。这使我们可以对一个零均值变量 $E' = E - m_1$ 进行推导，对于该变量，其原点矩与 $E$ 的中心矩相同，即 $\\langle(E')^k\\rangle = \\mu_k$。对于这个变量，$m_1' = \\mu_1 = 0$。\n\n零均值变量 $E'$ 的 MGF 为：\n$$\nM_{E'}(t) = 1 + \\mu_1 \\cdot t + \\frac{\\mu_2}{2!} t^2 + \\frac{\\mu_3}{3!} t^3 + \\frac{\\mu_4}{4!} t^4 + O(t^5)\n$$\n由于 $\\mu_1 = 0$，我们有：\n$$\nM_{E'}(t) = 1 + \\left( \\frac{\\mu_2}{2} t^2 + \\frac{\\mu_3}{6} t^3 + \\frac{\\mu_4}{24} t^4 + \\dots \\right)\n$$\nCGF 是 $K_{E'}(t) = \\ln M_{E'}(t)$。使用泰勒展开 $\\ln(1+x) = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \\dots$，并令 $x = \\frac{\\mu_2}{2} t^2 + \\frac{\\mu_3}{6} t^3 + \\frac{\\mu_4}{24} t^4 + \\dots$，我们展开 $K_{E'}(t)$：\n$$\nK_{E'}(t) = \\left( \\frac{\\mu_2}{2} t^2 + \\frac{\\mu_3}{6} t^3 + \\frac{\\mu_4}{24} t^4 + \\dots \\right) - \\frac{1}{2} \\left( \\frac{\\mu_2}{2} t^2 + \\frac{\\mu_3}{6} t^3 + \\dots \\right)^2 + O(t^6)\n$$\n我们收集截至 $t^4$ 阶的项：\n$K_{E'}(t)$ 展开式中的线性项为零，因此 $\\kappa_1(E') = 0$，正如预期。\n$t^2$ 项是 $\\frac{\\mu_2}{2}t^2$。将其与 $\\frac{\\kappa_2}{2!}t^2$ 比较，我们发现 $\\kappa_2 = \\mu_2$。\n$t^3$ 项是 $\\frac{\\mu_3}{6}t^3$。将其与 $\\frac{\\kappa_3}{3!}t^3$ 比较，我们发现 $\\kappa_3 = \\mu_3$。\n$t^4$ 项有两个贡献：来自第一个括号的 $\\frac{\\mu_4}{24}t^4$，和来自第二个括号的 $-\\frac{1}{2}(\\frac{\\mu_2}{2}t^2)^2 = -\\frac{\\mu_2^2}{8}t^4$。所有其他项都是更高阶的。因此，$t^4$ 的总系数是 $\\frac{\\mu_4}{24} - \\frac{\\mu_2^2}{8}$。\n我们将其与 CGF 定义中 $t^4$ 的系数 $\\frac{\\kappa_4}{4!} = \\frac{\\kappa_4}{24}$ 相等：\n$$\n\\frac{\\kappa_4}{24} = \\frac{\\mu_4}{24} - \\frac{\\mu_2^2}{8} = \\frac{\\mu_4 - 3\\mu_2^2}{24}\n$$\n这便得出了所需的四阶累积量表达式：\n$$\n\\kappa_4 = \\mu_4 - 3\\mu_2^2\n$$\n这个公式纯粹用中心矩 $\\mu_2$ 和 $\\mu_4$ 表示，这些矩可以从样本 $\\{E_i\\}_{i=1}^N$ 中估计出来。\n\n### 第二部分：$\\kappa_4$ 符号的物理解释\n\n$\\kappa_4$ 的符号提供了关于概率分布 $P(E)$ 形状的信息，特别是其偏离高斯形式的程度。这个量与超额峰度直接相关，$\\gamma_2 = \\frac{\\mu_4}{\\mu_2^2} - 3 = \\frac{\\kappa_4}{\\mu_2^2}$。由于 $\\mu_2 = \\sigma^2$ 是非负的，$\\kappa_4$ 的符号与超额峰度的符号相同。\n\n单峰、近似高斯的能量分布是处于二级（连续）相变点附近的系统的特征。对于一个完美的高斯分布，其中心矩为 $\\mu_2 = \\sigma^2$ 和 $\\mu_4 = 3\\sigma^4$。将这些代入我们推导的公式中得到：\n$$\n\\kappa_4 = (3\\sigma^4) - 3(\\sigma^2)^2 = 0\n$$\n因此，对于一个具有高斯能量涨落的系统（情况 A），我们期望 $\\kappa_4 \\approx 0$，任何偏离零的值都源于有限的抽样误差。问题将这种情况定义为“类二级相变”，并在 $\\kappa_4 \\ge 0$ 时赋予其标签 $2$。\n\n对称双峰能量分布是处于一级相变点附近的系统的特征，此时两个不同的热力学相（例如，高能态和低能态）共存。这导致能量的概率分布呈双峰状。考虑这样一种分布的理想化模型，它由两个对称的狄拉克 $\\delta$ 函数组成：$P(E) = \\frac{1}{2}\\delta(E-a) + \\frac{1}{2}\\delta(E+a)$，对于某个 $a  0$。平均能量为 $\\langle E \\rangle = 0$。中心矩很容易计算：\n$$\n\\mu_2 = \\langle E^2 \\rangle = \\frac{1}{2}(-a)^2 + \\frac{1}{2}(a)^2 = a^2\n$$\n$$\n\\mu_4 = \\langle E^4 \\rangle = \\frac{1}{2}(-a)^4 + \\frac{1}{2}(a)^4 = a^4\n$$\n于是第四阶累积量为：\n$$\n\\kappa_4 = \\mu_4 - 3\\mu_2^2 = a^4 - 3(a^2)^2 = -2a^4\n$$\n由于 $a  0$，$\\kappa_4$ 严格为负。这种分布是扁平峰（比高斯分布更平坦）。对于情况 B 和 C 中指定的两个高斯分布的混合，只要均值之间的分离与其标准差相比是显著的，分布就呈强烈的双峰性，并得出相同的结论：概率质量集中在远离均值的两个峰上，这使得四阶矩 $\\mu_4$ 相对于方差的平方 $\\mu_2^2$ 显得“小”，从而导致负的 $\\kappa_4$。这个负号是一级相变共存的经典标志，此类情况被标记为“类一级相变”（标签 $1$）。\n\n### 第三部分：算法设计与实现\n\n问题的数值部分要求生成合成数据并计算指定的量。实现过程如下：\n\n_1. 数据生成：_ 使用指定的种子 `12345` 初始化单个伪随机数生成器，以确保可复现性。\n- 对于情况 A（单峰），从各自的高斯分布 $\\mathcal{N}(0.0, 1.0^2)$ 中抽取 $N=50000$ 个独立的 $E$ 和 $M$ 样本。\n- 对于情况 B 和 C（双峰），数据代表了两个分量的混合。问题陈述为“从两个独立高斯分布的等权重混合中抽取 $N$ 对 $(E,M)$，对 $E$ 和 $M$ 均如此”。这意味着对于每一对 $(E_i, M_i)$，一个单一的随机选择决定了它是从分量1还是分量2中抽取。这在 $E$ 和 $M$ 之间建立了关联，这在物理上代表了相共存。为了实现这一点，我们从第一个分量的二元分布（其中 $E$ 和 $M$ 是独立的）中生成 $N/2$ 对样本，从第二个分量的二元分布中生成 $N/2$ 对样本，然后将它们连接起来。\n  对于情况 B ($N=50000$):\n  - 分量 1: $E \\sim \\mathcal{N}(-2.0, 0.2^2)$, $M \\sim \\mathcal{N}(-1.0, 0.1^2)$\n  - 分量 2: $E \\sim \\mathcal{N}(+2.0, 0.2^2)$, $M \\sim \\mathcal{N}(+1.0, 0.1^2)$\n  对于情况 C ($N=1000$)，原理相同，只是使用了其指定的参数。\n\n_2. 可观测量计算：_ 对每个生成的数据集 $\\{E_i, M_i\\}_{i=1}^N$：\n- 样本平均能量计算为 $\\langle E \\rangle_N = \\frac{1}{N} \\sum_{i=1}^N E_i$。\n- 样本平均绝对磁化强度为 $\\langle |M| \\rangle_N = \\frac{1}{N} \\sum_{i=1}^N |M_i|$。\n- 使用其定义计算能量的二阶和四阶中心矩：\n  $$ \\mu_2 = \\frac{1}{N}\\sum_{i=1}^N (E_i - \\langle E \\rangle_N)^2 $$\n  $$ \\mu_4 = \\frac{1}{N}\\sum_{i=1}^N (E_i - \\langle E \\rangle_N)^4 $$\n- 然后使用推导出的公式计算四阶累积量：$\\kappa_4 = \\mu_4 - 3\\mu_2^2$。\n\n_3. 分类：_ 根据计算出的 $\\kappa_4$ 的符号对每种情况进行分类：\n- 如果 $\\kappa_4  0$，标签为 $1$（“类一级相变”）。\n- 如果 $\\kappa_4 \\ge 0$，标签为 $2$（“类二级相变”）。\n\n最终输出是一个列表，其中包含每种情况的结果 $[\\kappa_4, \\langle E \\rangle_N, \\langle |M| \\rangle_N, \\text{label}]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by generating synthetic data for three test cases,\n    computing the specified physical quantities including the fourth-order\n    energy cumulant, and classifying the cases based on its sign.\n    \"\"\"\n    # Use a fixed seed for the pseudorandom number generator for reproducibility.\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    # Define the parameters for the three test cases.\n    test_cases_params = [\n        # Case A: Unimodal, \"second-order-like\"\n        {\n            \"N\": 50000,\n            \"type\": \"unimodal\",\n            \"E_params\": {\"mu\": 0.0, \"sigma\": 1.0},\n            \"M_params\": {\"mu\": 0.0, \"sigma\": 1.0},\n        },\n        # Case B: Bimodal, \"first-order-like\", clear separation\n        {\n            \"N\": 50000,\n            \"type\": \"bimodal\",\n            \"E_params\": [{\"mu\": -2.0, \"sigma\": 0.2}, {\"mu\": 2.0, \"sigma\": 0.2}],\n            \"M_params\": [{\"mu\": -1.0, \"sigma\": 0.1}, {\"mu\": 1.0, \"sigma\": 0.1}],\n        },\n        # Case C: Bimodal, \"first-order-like\", finite-sample edge\n        {\n            \"N\": 1000,\n            \"type\": \"bimodal\",\n            \"E_params\": [{\"mu\": -1.5, \"sigma\": 0.5}, {\"mu\": 1.5, \"sigma\": 0.5}],\n            \"M_params\": [{\"mu\": -0.5, \"sigma\": 0.2}, {\"mu\": 0.5, \"sigma\": 0.2}],\n        },\n    ]\n\n    results = []\n    for params in test_cases_params:\n        N = params[\"N\"]\n        \n        # Generate synthetic data (E, M) pairs\n        if params[\"type\"] == \"unimodal\":\n            E = rng.normal(loc=params[\"E_params\"][\"mu\"], scale=params[\"E_params\"][\"sigma\"], size=N)\n            M = rng.normal(loc=params[\"M_params\"][\"mu\"], scale=params[\"M_params\"][\"sigma\"], size=N)\n        elif params[\"type\"] == \"bimodal\":\n            # For bimodal cases, generate N/2 samples from each component,\n            # ensuring correlation between E and M by picking from the same\n            # component for each (E, M) pair.\n            n1 = N // 2\n            n2 = N - n1\n            \n            E1 = rng.normal(loc=params[\"E_params\"][0][\"mu\"], scale=params[\"E_params\"][0][\"sigma\"], size=n1)\n            E2 = rng.normal(loc=params[\"E_params\"][1][\"mu\"], scale=params[\"E_params\"][1][\"sigma\"], size=n2)\n            E = np.concatenate((E1, E2))\n            \n            M1 = rng.normal(loc=params[\"M_params\"][0][\"mu\"], scale=params[\"M_params\"][0][\"sigma\"], size=n1)\n            M2 = rng.normal(loc=params[\"M_params\"][1][\"mu\"], scale=params[\"M_params\"][1][\"sigma\"], size=n2)\n            M = np.concatenate((M1, M2))\n\n            # Shuffle the pairs to mix the components\n            p = rng.permutation(N)\n            E = E[p]\n            M = M[p]\n\n        # Compute empirical averages\n        mean_E = np.mean(E)\n        mean_abs_M = np.mean(np.abs(M))\n\n        # Compute empirical central moments of energy\n        # The sample central moments are defined with a 1/N normalization factor.\n        # np.var uses ddof=0 by default, which is equivalent to 1/N.\n        mu_2 = np.var(E)\n        mu_4 = np.mean((E - mean_E)**4)\n\n        # Compute the fourth-order energy cumulant using the derived formula\n        kappa_4 = mu_4 - 3 * (mu_2**2)\n\n        # Classify the case based on the sign of kappa_4\n        # Label 1: first-order-like (k4  0)\n        # Label 2: second-order-like (k4 >= 0)\n        label = 1 if kappa_4  0 else 2\n        \n        results.append([kappa_4, mean_E, mean_abs_M, label])\n\n    # Format the results into the required string format: [[...],[...],[...]]\n    results_str_list = [\n        f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results\n    ]\n    final_output_str = f\"[{','.join(results_str_list)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2380998"}]}