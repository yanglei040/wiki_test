{"hands_on_practices": [{"introduction": "本练习将我们的研究置于经典的随机行走模型中，这是扩散现象的概念基石。通过在不同晶格上推导和模拟均方位移，您将直接观察到一个简单的、无记忆的随机过程如何产生可预测的宏观定律。这个实践旨在加强微观随机性与涌现的确定性行为之间的联系，这是统计物理学的一个核心主题。[@problem_id:2445720]", "problem": "您将研究两种无限二维晶格上的无偏离散时间最近邻随机游走：方形晶格和蜂窝晶格。每个行走者在时间步 $0$ 从原点出发，以固定的时间间隔 $\\tau$（单位：秒）进行固定长度 $a$（单位：米）的移动，并且在每一步中，从晶格几何所允许的最近邻中进行均匀选择。蜂窝晶格使用三个相互夹角为 $120^\\circ$ 的键合方向进行建模；方形晶格则使用四个基本方向进行建模。您的目标是基于第一性原理，量化并比较这两种晶格上的扩散，并证实或证伪长时扩散系数中任何与晶格相关的差异。所有数值结果必须以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位表示。\n\n必需的推导和实现任务：\n- 从 $n$ 步后随机游走位移的定义 $\\mathbf{r}_n = \\sum_{k=1}^{n} \\mathbf{s}_k$ 和二维空间扩散的定义关系出发，推导扩散系数 $D$ 的估计量。该估计量应以在总物理时间 $t = n \\tau$ 内、经过 $n$ 步累积的均方位移 $\\langle r_n^2 \\rangle$ 来表示。您的推导必须仅依赖于以下核心属性：在给定当前状态下，各步增量是独立的；由于晶格对称性，每一步的增量均值为零；步长为固定值 $a$。不要假设任何特定于晶格的简化公式。\n- 实现两个独立的模拟器：\n  1. 方形晶格：每一步从 $4$ 个单位向量 $(\\pm 1, 0)$, $(0, \\pm 1)$（经 $a$ 缩放）中进行均匀选择。\n  2. 蜂窝晶格：使用三个长度为 $a$ 的键矢量 $\\mathbf{b}_1 = a (1, 0)$, $\\mathbf{b}_2 = a (-\\tfrac{1}{2}, \\tfrac{\\sqrt{3}}{2})$, $\\mathbf{b}_3 = a (-\\tfrac{1}{2}, -\\tfrac{\\sqrt{3}}{2})$。从一个子晶格出发的选择为 $\\{\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3\\}$，而从另一个子晶格出发的选择为 $\\{-\\mathbf{b}_1, -\\mathbf{b}_2, -\\mathbf{b}_3\\}$。从一个子晶格的原点开始，每走一步就交替更换子晶格。\n- 对于下方的每个测试用例，在每种晶格上模拟 $M$ 个独立的行走者进行 $n$ 步运动，分别为每种晶格计算这 $M$ 个行走者的均方位移 $\\langle r_n^2 \\rangle$，并使用您推导的估计量将其转换为扩散系数的估计值 $\\hat{D}$。在给定的测试用例中，对两种晶格使用相同的 $M$、$n$、$a$ 和 $\\tau$。如果提供了随机种子，请使用它来生成可复现的结果。\n\n物理单位和输出要求：\n- 以浮点数形式报告每个扩散系数，单位为 $\\mathrm{m}^2/\\mathrm{s}$。不要打印单位字符串；只打印数值。\n- 在蜂窝晶格几何中，相关角度必须在内部以弧度单位进行处理；上述指定的算法已经编码了方向，因此您无需在程序输出中显式处理角度。\n\n测试套件（每个元组为 $(n, a, \\tau, M, \\text{seed})$，所有量均应以国际单位制（SI）进行解释）：\n- 用例 A (理想情况): $(20000, 1.0 \\times 10^{-9}, 1.0 \\times 10^{-12}, 200, 12345)$。\n- 用例 B (边界条件, 单步): $(1, 5.0 \\times 10^{-10}, 2.0 \\times 10^{-13}, 1000, 54321)$。\n- 用例 C (短程行走, 多次试验): $(2000, 2.0 \\times 10^{-10}, 1.0 \\times 10^{-13}, 500, 202311)$。\n- 用例 D (不同尺度): $(5000, 3.0 \\times 10^{-10}, 5.0 \\times 10^{-13}, 300, 777)$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个结果列表，每个测试用例对应一个结果，并按 A、B、C、D 的顺序排列。对于每个测试用例，输出一个包含三个浮点数的列表 $[\\hat{D}_{\\text{square}}, \\hat{D}_{\\text{honeycomb}}, D_{\\text{theory}}]$，其中 $D_{\\text{theory}}$ 是您在所述假设下推导出的理论扩散系数。因此，完整输出必须是一个列表的列表，例如 $[[x_1, y_1, z_1], [x_2, y_2, z_2], [x_3, y_3, z_3], [x_4, y_4, z_4]]$，所有值单位均为 $\\mathrm{m}^2/\\mathrm{s}$。必须只打印这个单行列表。", "solution": "主要任务是建立随机游走的微观参数与宏观扩散系数之间的关系。行走者在 $n$ 步后的位置 $\\mathbf{r}_n$ 是单个步矢量 $\\mathbf{s}_k$ 的总和：\n$$ \\mathbf{r}_n = \\sum_{k=1}^{n} \\mathbf{s}_k $$\n我们感兴趣的量是均方位移 (MSD) $\\langle r_n^2 \\rangle$，其中平均值 $\\langle \\cdot \\rangle$ 是对一组独立的行走者进行系综平均得到的。位移的平方是位置矢量与其自身的点积：\n$$ r_n^2 = \\mathbf{r}_n \\cdot \\mathbf{r}_n = \\left( \\sum_{i=1}^{n} \\mathbf{s}_i \\right) \\cdot \\left( \\sum_{j=1}^{n} \\mathbf{s}_j \\right) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\mathbf{s}_i \\cdot \\mathbf{s}_j $$\n根据期望算符的线性性质，MSD 为：\n$$ \\langle r_n^2 \\rangle = \\left\\langle \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\mathbf{s}_i \\cdot \\mathbf{s}_j \\right\\rangle = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_j \\rangle $$\n我们将这个双重求和分解为索引相等 ($i=j$) 和索引不相等 ($i \\neq j$) 的项：\n$$ \\langle r_n^2 \\rangle = \\sum_{i=1}^{n} \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_i \\rangle + \\sum_{i \\neq j} \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_j \\rangle $$\n问题陈述指出，步增量是独立的。因此，对于 $i \\neq j$，乘积的期望等于期望的乘积：$\\langle \\mathbf{s}_i \\cdot \\mathbf{s}_j \\rangle = \\langle \\mathbf{s}_i \\rangle \\cdot \\langle \\mathbf{s}_j \\rangle$。问题还明确指出，该游走是无偏的，意味着步方向的选择来自一个对称集合，这导致任何步矢量的均值为零：对所有 $k$ 都有 $\\langle \\mathbf{s}_k \\rangle = \\mathbf{0}$。对于所定义的方形和蜂窝晶格，这一点都成立。因此，所有交叉项 ($i \\neq j$) 都为零：\n$$ \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_j \\rangle = \\mathbf{0} \\cdot \\mathbf{0} = 0 \\quad \\text{for } i \\neq j $$\nMSD 表达式简化为对角项之和：\n$$ \\langle r_n^2 \\rangle = \\sum_{i=1}^{n} \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_i \\rangle = \\sum_{i=1}^{n} \\langle |\\mathbf{s}_i|^2 \\rangle $$\n步长被设定为固定常数 $|\\mathbf{s}_k| = a$。因此，其平方也是常数 $|\\mathbf{s}_k|^2 = a^2$，其期望就是 $a^2$。求和变为：\n$$ \\langle r_n^2 \\rangle = \\sum_{i=1}^{n} a^2 = n a^2 $$\n这就是具有固定步长的无偏随机游走在 $n$ 步后的理论 MSD。\n在连续极限下，二维扩散由爱因斯坦关系式描述，该关系式将 MSD 与扩散系数 $D$ 和时间 $t$ 联系起来：\n$$ \\langle r^2(t) \\rangle = 4 D t $$\n我们通过将总时间 $t$ 设为步数 $n$ 乘以每步时间 $\\tau$（即 $t = n \\tau$），将我们的离散模型与此连续描述关联起来。令两个 MSD 表达式相等，得到：\n$$ n a^2 = 4 D (n \\tau) $$\n求解 $D$ 得到理论扩散系数，我们将其表示为 $D_{\\text{theory}}$：\n$$ D_{\\text{theory}} = \\frac{a^2}{4 \\tau} $$\n这一理论结果对于任何满足初始假设的晶格都是通用的，并且值得注意的是，它与晶格的配位数或几何形状无关。该推导驳斥了在这些模型条件下扩散系数依赖于晶格的观点。\n\n对于问题的数值部分，我们必须从模拟数据中估计 $D$。对 $M$ 个行走者进行 $n$ 步模拟，会产生一组最终位移的平方值 $\\{r_{n,1}^2, r_{n,2}^2, \\dots, r_{n,M}^2\\}$。模拟得到的 MSD，$\\langle r_n^2 \\rangle_{\\text{sim}}$，是这些值的样本均值。我们将这个经验结果代入扩散关系式中，以找到我们的估计量 $\\hat{D}$：\n$$ \\langle r_n^2 \\rangle_{\\text{sim}} = 4 \\hat{D} (n \\tau) \\implies \\hat{D} = \\frac{\\langle r_n^2 \\rangle_{\\text{sim}}}{4 n \\tau} $$\n这就是要实现的估计量。\n\n实现将包括两个独立的模拟器。两者都将跟踪一个由 $M$ 个行走者组成的群体，该群体由一个形状为 $(M, 2)$、初始化为零的 NumPy 数组表示。对于 $n$ 个时间步中的每一步，为每个行走者选择一个随机的步矢量，并加到其当前位置上。为了提高效率，该过程是向量化的。\n\n对于方形晶格，可能的步矢量集合是 $\\{\\,(a, 0), (-a, 0), (0, a), (0, -a)\\,\\}$。在每一步，以均匀概率 $p=1/4$ 从这 $4$ 个矢量中选择一个。\n\n对于蜂窝晶格，其结构是二分的。步矢量的集合取决于行走者当前所占据的子晶格。设子晶格为 $A$ 和 $B$。从 $A$ 开始的行走者必须移动到 $B$，从 $B$ 开始的必须移动到 $A$。我们定义基底键矢量为 $\\mathbf{b}_1 = a(1, 0)$, $\\mathbf{b}_2 = a(-\\tfrac{1}{2}, \\tfrac{\\sqrt{3}}{2})$ 和 $\\mathbf{b}_3 = a(-\\tfrac{1}{2}, -\\tfrac{\\sqrt{3}}{2})$。\n- 从子晶格 $A$（例如，在偶数步 $0, 2, \\dots$），允许的步为 $\\{\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3\\}$，每个的概率为 $p=1/3$。\n- 从子晶格 $B$（例如，在奇数步 $1, 3, \\dots$），允许的步为 $\\{-\\mathbf{b}_1, -\\mathbf{b}_2, -\\mathbf{b}_3\\}$，每个的概率为 $p=1/3$。\n\n在 $n$ 步之后，计算每个行走者的最终位移平方，然后对所有 $M$ 个行走者取平均值得到 $\\langle r_n^2 \\rangle_{\\text{sim}}$，并用此来计算 $\\hat{D}_{\\text{square}}$ 和 $\\hat{D}_{\\text{honeycomb}}$。这些模拟值将与推导出的 $D_{\\text{theory}} = a^2 / (4\\tau)$ 进行比较。由于有限模拟 ($M < \\infty$) 中固有的统计涨落，估计值 $\\hat{D}$ 会与 $D_{\\text{theory}}$ 有轻微偏差，但随着 $M$ 和 $n$ 变大，应会收敛于它。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_square(n, a, tau, M, seed):\n    \"\"\"\n    Simulates a random walk on a 2D square lattice.\n\n    Args:\n        n (int): Number of steps.\n        a (float): Step length in meters.\n        tau (float): Time interval per step in seconds.\n        M (int): Number of independent walkers.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: Estimated diffusion coefficient in m^2/s.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    # Initialize all M walkers at the origin (0, 0).\n    positions = np.zeros((M, 2), dtype=np.float64)\n    # Define the four possible step vectors.\n    steps_set = a * np.array([[1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0]])\n\n    for _ in range(n):\n        # For each of the M walkers, choose one of the 4 steps randomly.\n        choices = rng.integers(0, 4, size=M)\n        # Get the corresponding displacement vectors for all walkers.\n        displacements = steps_set[choices]\n        # Update all positions simultaneously.\n        positions += displacements\n    \n    # For n=0, division by zero occurs. Problem cases have n>=1.\n    if n == 0:\n        return 0.0\n\n    # Calculate the squared displacement from the origin for each walker.\n    squared_displacements = np.sum(positions**2, axis=1)\n    # Compute the mean squared displacement over all walkers.\n    mean_squared_displacement = np.mean(squared_displacements)\n    \n    # Use the derived estimator for the diffusion coefficient D.\n    D_hat = mean_squared_displacement / (4.0 * n * tau)\n    return D_hat\n\ndef simulate_honeycomb(n, a, tau, M, seed):\n    \"\"\"\n    Simulates a random walk on a 2D honeycomb lattice.\n\n    Args:\n        n (int): Number of steps.\n        a (float): Step length in meters.\n        tau (float): Time interval per step in seconds.\n        M (int): Number of independent walkers.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: Estimated diffusion coefficient in m^2/s.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    # Initialize all M walkers at the origin (0, 0) on sublattice A.\n    positions = np.zeros((M, 2), dtype=np.float64)\n    \n    sqrt3_div_2 = np.sqrt(3.0) / 2.0\n    # Define bond vectors for sublattice A -> B transitions.\n    steps_A = a * np.array([[1.0, 0.0], [-0.5, sqrt3_div_2], [-0.5, -sqrt3_div_2]])\n    # Bond vectors for sublattice B -> A are the negative of A -> B.\n    steps_B = -steps_A\n\n    for i in range(n):\n        # For each of the M walkers, choose one of the 3 steps randomly.\n        choices = rng.integers(0, 3, size=M)\n        # Select step set based on sublattice (even/odd step number).\n        if i % 2 == 0:  # Walker is on sublattice A\n            displacements = steps_A[choices]\n        else:  # Walker is on sublattice B\n            displacements = steps_B[choices]\n        # Update all positions simultaneously.\n        positions += displacements\n\n    if n == 0:\n        return 0.0\n\n    # Calculate and average the squared displacements.\n    squared_displacements = np.sum(positions**2, axis=1)\n    mean_squared_displacement = np.mean(squared_displacements)\n    \n    # Estimate D.\n    D_hat = mean_squared_displacement / (4.0 * n * tau)\n    return D_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, a, tau, M, seed)\n        (20000, 1.0e-9, 1.0e-12, 200, 12345),  # Case A\n        (1, 5.0e-10, 2.0e-13, 1000, 54321),    # Case B\n        (2000, 2.0e-10, 1.0e-13, 500, 202311), # Case C\n        (5000, 3.0e-10, 5.0e-13, 300, 777),      # Case D\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n, a, tau, M, seed = case\n        \n        # Run simulation for the square lattice.\n        D_square = simulate_square(n, a, tau, M, seed)\n        \n        # Run simulation for the honeycomb lattice.\n        D_honeycomb = simulate_honeycomb(n, a, tau, M, seed)\n        \n        # Calculate the theoretical diffusion coefficient.\n        D_theory = (a**2) / (4.0 * tau)\n        \n        all_results.append([D_square, D_honeycomb, D_theory])\n\n    # Format the final output string to match the required format.\n    formatted_results = []\n    for res in all_results:\n        # Format each sublist as a string \"[v1,v2,v3]\"\n        formatted_results.append(f\"[{','.join(map(str, res))}]\")\n    \n    # Join all sublist strings and wrap in outer brackets.\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2445720"}, {"introduction": "现在，我们从无相互作用的随机行走转向一个有相互作用的系统：伊辛模型，这是统计物理学的基石。本练习将指导您实现吉布斯采样，一种强大的马尔可夫链蒙特卡洛算法，来模拟二元合金。您将学习如何强制执行细致平衡条件以从玻尔兹曼分布中采样，并计算揭示系统行为的关键物理可观测量，包括有趣的相变现象。[@problem_id:2411722]", "problem": "您将使用吉布斯采样（也称为热浴算法）为模拟为类伊辛格点阵系统的二维二元合金实现一个马尔可夫链蒙特卡洛模拟器。考虑一个线性尺寸为 $L$ 的方形点阵，其具有周期性边界条件，因此点阵格点总数为 $N = L^2$。每个格点 $i$ 带有一个二元变量 $s_i \\in \\{-1, +1\\}$，代表两种原子种类之一。一个构型的能量由伊辛哈密顿量给出\n$$\n\\mathcal{H}(s) = - J \\sum_{\\langle i,j \\rangle} s_i s_j\n$$\n其中求和遍及方形点阵上的所有最近邻对，而 $J$ 是一个耦合常数。您将使用吉布斯采样构建一个马尔可夫链，该链在逆温度 $\\beta = 1/T$（玻尔兹曼常数 $k_B$ 设为 $1$，即温度以 $J/k_B$ 为单位且 $k_B=1$）下，相对于玻尔兹曼分布是各态历经的并满足细致平衡条件。您必须显式地实现周期性边界条件，并使用棋盘格（红黑）更新方案，以便一个子晶格的所有格点都使用其邻居的当前值同时进行更新。\n\n从平衡概率与玻尔兹曼权重 $e^{-\\beta \\mathcal{H}(s)}$ 成正比的基本定义出发，推导在固定温度 $T$ 和耦合常数 $J$ 的条件下，给定一个格点 $s_i$ 的邻居状态时，对其进行重采样的吉布斯更新所依赖的单格点条件概率。使用该条件概率实现一个单格点吉布斯采样器，通过交替进行子晶格更新来更新整个点阵。随机初始化自旋，并在采集测量数据前设置一段热化时间。\n\n对于热化后马尔可夫链的每个状态，计算以下可观测量：\n- 单格点瞬时磁化强度 $m = \\frac{1}{N} \\sum_i s_i$ 及其绝对值 $|m|$。\n- 单格点瞬时能量 $e = \\frac{1}{N} \\mathcal{H}(s)$，计算时每个最近邻对只计算一次。\n- Binder 累积量 $U_4 = 1 - \\frac{\\langle m^4 \\rangle}{3 \\langle m^2 \\rangle^2}$，其中尖括号表示在固定温度和点阵尺寸下，对马尔可夫链的测量样本进行的时间平均。\n\n设计您的模拟器，使其在给定固定的随机数生成器种子时，能够产生可复现的结果。您的程序必须运行以下参数集的测试套件，并为每个测试用例报告时间平均绝对磁化强度 $\\langle |m| \\rangle$、时间平均单格点能量 $\\langle e \\rangle$ 和 Binder 累积量 $U_4$。所有温度都采用 $k_B=1$ 的单位制，因此 $T$ 以 $J$ 为单位表示。在两个方向上都使用周期性边界条件。\n\n测试套件（每个元组为 $(L, J, T, n_{\\text{therm}}, n_{\\text{meas}})$）：\n- 正常路径，有序相：$(40, 1.0, 1.8, 800, 800)$。\n- 接近二维伊辛模型临界点：$(40, 1.0, 2.269, 1500, 1500)$。\n- 无序相：$(40, 1.0, 3.5, 800, 800)$。\n- 边界情况（无相互作用）：$(40, 0.0, 1.0, 500, 1000)$。\n\n您的程序必须为每个测试用例计算所要求的三个可观测量，在 $n_{\\text{meas}}$ 次测量扫描中对它们进行平均，并将三个输出中的每一个都四舍五入到4位小数以供报告。最终输出中没有物理单位，因为在选定的 $k_B=1$ 单位制中，所有量都是无量纲的。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例对应的结果本身必须是一个用方括号括起来的、包含三个四舍五入浮点数 $[\\langle |m| \\rangle, \\langle e \\rangle, U_4]$ 的逗号分隔列表，其顺序与上述测试套件相同。例如，输出应如下所示\n$[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4]]$\n其中每个 $x_i, y_i, z_i$ 都四舍五入到4位小数，且不打印任何其他文本。", "solution": "目标是使用一种特定的马尔可夫链蒙特卡洛方法，即吉布斯采样，来模拟二维伊辛模型，并计算几个关键的统计可观测量。\n\n**1. 吉布斯采样与条件概率**\n\n吉布斯采样算法，也称为热浴算法，通过在给定系统所有其他分量当前状态的情况下，从其条件概率分布中抽取一个新值来更新系统单个分量 $s_i$ 的状态。对于伊辛模型，由于哈密顿量 $\\mathcal{H}$ 的最近邻性质，一个自旋 $s_i$ 的状态仅依赖于其直接邻居。\n\n在给定其邻居构型固定的情况下，找到自旋 $i$ 处于状态 $s_i$ 的条件概率与该自旋能量贡献相关的玻尔兹曼因子成正比：\n$$ P(s_i | \\{s_j\\}_{j \\in \\text{nn}(i)}) \\propto e^{-\\beta E_i} $$\n其中 $E_i$ 是总能量中依赖于 $s_i$ 的部分。该能量为 $E_i = -J s_i \\sum_{j \\in \\text{nn}(i)} s_j$。我们定义局域场 $h_i = \\sum_{j \\in \\text{nn}(i)} s_j$，即四个相邻自旋之和。那么，$E_i = -J s_i h_i$。\n\n$s_i$ 处于 $+1$ 状态的条件概率通过对两种可能状态（$s_i = +1$ 和 $s_i = -1$）进行归一化得到：\n$$ P(s_i = +1 | h_i) = \\frac{e^{-\\beta (-J(+1)h_i)}}{e^{-\\beta (-J(+1)h_i)} + e^{-\\beta (-J(-1)h_i)}} = \\frac{e^{\\beta J h_i}}{e^{\\beta J h_i} + e^{-\\beta J h_i}} $$\n这个表达式可以使用双曲正切函数重写为数值稳定的形式，或者为了更便于实现，写成：\n$$ P(s_i = +1 | h_i) = \\frac{1}{1 + e^{-2\\beta J h_i}} $$\n$s_i$ 为 $-1$ 的概率就是 $P(s_i = -1 | h_i) = 1 - P(s_i = +1 | h_i)$。\n单个自旋 $s_i$ 的吉布斯更新规则如下：\n1. 计算其邻居之和 $h_i$。\n2. 计算概率 $p_+ = P(s_i = +1 | h_i)$。\n3. 抽取一个均匀随机数 $r \\in [0, 1)$。\n4. 如果 $r < p_+$，则设置 $s_i = +1$；否则，设置 $s_i = -1$。\n\n**2. 棋盘格更新方案**\n\n为了并行化更新并确保正确性，采用了棋盘格（或红黑）更新方案。点阵格点被划分为两个子晶格，“红色”和“黑色”，就像棋盘上的方格一样。如果 $i+j$ 是偶数，则格点 $(i,j)$ 是“红色”的；如果 $i+j$ 是奇数，则是“黑色”的。关键特性是，一个红色格点的所有邻居都是黑色的，反之亦然。\n\n对点阵的一次完整扫描包括两个步骤：\n1.  **更新红色子晶格**：同时更新红色子晶格上的所有自旋。对于每个红色自旋，其邻居都位于黑色子晶格上。因此，每个红色自旋的更新仅依赖于黑色自旋的当前状态，所以这些更新是相互独立的。\n2.  **更新黑色子晶格**：随后，同时更新黑色子晶格上的所有自旋。这些自旋的邻居位于红色子晶格上，因此它们的更新将使用步骤1中新计算出的红色自旋的值。\n\n这种方案保证了整个扫描过程满足细致平衡条件，并允许进行高效的矢量化实现。\n\n**3. 可观测量及其计算**\n\n经过 $n_{\\text{therm}}$ 次扫描的热化周期以使系统达到平衡后，在 $n_{\\text{meas}}$ 次扫描中进行测量。\n\n- **单格点磁化强度 ($m$)**：对于给定的自旋构型，这是平均自旋值：$m = \\frac{1}{N} \\sum_{i=1}^N s_i$。我们将需要其绝对值 $|m|$，以及用于计算 Binder 累积量的 $m^2$ 和 $m^4$。\n\n- **单格点能量 ($e$)**：总能量为 $\\mathcal{H} = -J \\sum_{\\langle i,j \\rangle} s_i s_j$。为避免重复计算键，我们对每个格点与其“右侧”和“下方”邻居的相互作用求和（使用周期性边界）。\n$$ \\mathcal{H} = -J \\sum_{i,j} s_{i,j} (s_{i,j+1} + s_{i+1,j}) $$\n其中索引对 $L$ 取模。单格点能量为 $e = \\mathcal{H} / N$。\n\n- **Binder 累积量 ($U_4$)**：这是一个用于定位相变的高阶矩比率。其定义为：\n$$ U_4 = 1 - \\frac{\\langle m^4 \\rangle}{3 \\langle m^2 \\rangle^2} $$\n其中 $\\langle m^2 \\rangle$ 和 $\\langle m^4 \\rangle$ 是瞬时磁化强度的平方和四次方的均值，通过对测量扫描进行平均得到。该量具有在临界温度下近似与系统尺寸无关的有用性质。它在有序相中趋近于 $2/3$，在无序相中趋近于 $0$。对于无相互作用的情况（$J=0$），对于有限系统，$U_4 = 2/(3N)$，该值接近于 $0$。\n\n**4. 算法实现**\n\n对于每个测试用例 $(L, J, T, n_{\\text{therm}}, n_{\\text{meas}})$，模拟将按以下步骤进行：\n1.  用随机自旋（等概率地为 $+1$ 或 $-1$）初始化一个 $L \\times L$ 的点阵。\n2.  定义红色和黑色子晶格掩码。\n3.  设置 $\\beta = 1/T$（如果 $T > 0$）。\n4.  **热化**：执行 $n_{\\text{therm}}$ 次完整的棋盘格扫描，不进行测量。\n5.  **测量**：执行 $n_{\\text{meas}}$ 次扫描。每次扫描后：\n    a. 计算瞬时磁化强度 $m$ 和单格点能量 $e$。\n    b. 存储 $|m|$、$e$、$m^2$ 和 $m^4$。\n6.  **求平均**：测量循环结束后，计算存储量的平均值：$\\langle |m| \\rangle$、$\\langle e \\rangle$、$\\langle m^2 \\rangle$ 和 $\\langle m^4 \\rangle$。\n7.  根据平均矩计算 Binder 累积量 $U_4$。\n8.  返回按规定四舍五入的最终三个可观测量。\n\n使用 `numpy` 允许对邻居求和计算（使用 `numpy.roll`）和对整个子晶格的概率更新进行高效的矢量化操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, J, T, n_therm, n_meas, rng):\n    \"\"\"\n    Runs a Markov Chain Monte Carlo simulation for the 2D Ising model.\n\n    Args:\n        L (int): Linear size of the square lattice.\n        J (float): Coupling constant.\n        T (float): Temperature.\n        n_therm (int): Number of thermalization sweeps.\n        n_meas (int): Number of measurement sweeps.\n        rng (np.random.Generator): Random number generator instance.\n\n    Returns:\n        tuple: A tuple containing the averaged absolute magnetization,\n               averaged energy per site, and the Binder cumulant.\n    \"\"\"\n    N = L * L\n    \n    # Initialize spins randomly\n    spins = rng.choice([-1, 1], size=(L, L))\n    \n    # Create checkerboard masks\n    x, y = np.meshgrid(range(L), range(L))\n    red_mask = (x + y) % 2 == 0\n    black_mask = ~red_mask\n    \n    beta = 1.0 / T if T > 0 else float('inf')\n\n    # Simulation sweeps\n    for _ in range(n_therm):\n        # Gibbs sweep\n        for mask in [red_mask, black_mask]:\n            # Sum of neighbors using np.roll for periodic boundaries\n            neighbors_sum = (np.roll(spins, 1, axis=0) +\n                             np.roll(spins, -1, axis=0) +\n                             np.roll(spins, 1, axis=1) +\n                             np.roll(spins, -1, axis=1))\n            \n            # Argument for the exponential in the probability calculation\n            # For J=0, delta_E_arg is 0, prob is 0.5, which is correct.\n            delta_E_arg = 2.0 * J * neighbors_sum * beta\n            \n            # Probability to be in the +1 state, numerically stable form\n            prob_plus_one = 1.0 / (1.0 + np.exp(-delta_E_arg))\n            \n            # Generate random numbers and update spins\n            rand_flips = rng.random(size=(L,L))\n            new_spins = 2 * (rand_flips  prob_plus_one) - 1\n            \n            # Apply update only to the current sublattice\n            spins[mask] = new_spins[mask]\n\n    # Measurement phase\n    m_vals = []\n    e_vals = []\n    m2_vals = []\n    m4_vals = []\n\n    for _ in range(n_meas):\n        # Gibbs sweep\n        for mask in [red_mask, black_mask]:\n            neighbors_sum = (np.roll(spins, 1, axis=0) +\n                             np.roll(spins, -1, axis=0) +\n                             np.roll(spins, 1, axis=1) +\n                             np.roll(spins, -1, axis=1))\n            \n            delta_E_arg = 2.0 * J * neighbors_sum * beta\n            prob_plus_one = 1.0 / (1.0 + np.exp(-delta_E_arg))\n            \n            rand_flips = rng.random(size=(L,L))\n            new_spins = 2 * (rand_flips  prob_plus_one) - 1\n            spins[mask] = new_spins[mask]\n\n        # Calculate observables\n        m = np.mean(spins)\n        \n        # Energy calculation (each bond counted once)\n        energy_total = -J * np.sum(spins * (np.roll(spins, 1, axis=0) + np.roll(spins, 1, axis=1)))\n        e = energy_total / N\n        \n        # Store values for averaging\n        m_vals.append(np.abs(m))\n        e_vals.append(e)\n        m2_vals.append(m**2)\n        m4_vals.append(m**4)\n        \n    # Calculate final averages\n    avg_abs_m = np.mean(m_vals)\n    avg_e = np.mean(e_vals)\n    avg_m2 = np.mean(m2_vals)\n    avg_m4 = np.mean(m4_vals)\n    \n    # Calculate Binder cumulant, handle division by zero\n    if avg_m2 > 1e-12:\n        binder_cumulant = 1.0 - (avg_m4 / (3.0 * avg_m2**2))\n    else:\n        # Occurs if m is always zero (highly unlikely in finite simulation)\n        # or for J=0 case where avg_m2 is small. The theoretical value is 0.\n        binder_cumulant = 0.0\n\n    return avg_abs_m, avg_e, binder_cumulant\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, J, T, n_therm, n_meas)\n        (40, 1.0, 1.8, 800, 800),\n        (40, 1.0, 2.269, 1500, 1500),\n        (40, 1.0, 3.5, 800, 800),\n        (40, 0.0, 1.0, 500, 1000),\n    ]\n\n    # For reproducibility\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    results = []\n    for case in test_cases:\n        L, J, T, n_therm, n_meas = case\n        avg_abs_m, avg_e, binder_cumulant = run_simulation(L, J, T, n_therm, n_meas, rng)\n        \n        # Round results to 4 decimal places\n        result_tuple = [\n            round(avg_abs_m, 4),\n            round(avg_e, 4),\n            round(binder_cumulant, 4)\n        ]\n        results.append(result_tuple)\n\n    # Format the final output string to match the required format.\n    formatted_results = []\n    for res in results:\n        # Format each sublist as a string \"[v1,v2,v3]\"\n        formatted_results.append(f\"[{','.join(map(str, res))}]\")\n    \n    # Join all sublist strings and wrap in outer brackets.\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2411722"}, {"introduction": "最后的这个实践通过将统计物理工具包应用于一个完全不同的领域——图像合成，展示了其卓越的普适性。您将使用模拟退火，一种带有温度调度策略的、基于 Metropolis 的算法，来解决一个被构建为能量最小化问题的马赛克创作任务。这个练习突出了能量函数、温度和达到“基态”等概念，如何为解决远超传统物理学范畴的复杂优化问题提供一个强大的框架。[@problem_id:2411642]", "problem": "您将为一项马赛克合成任务实现一个模拟退火求解器，该任务被建模为有限状态空间上的一个离散马尔可夫链。目标是在网格上放置彩色瓦片，使生成的图像在满足局部颜色平滑度约束的同时，逼近给定的目标图像。该设计必须基于统计物理学的基础。您必须形式化状态空间、定义一个受格点模型中相互作用启发的能量函数、论证一个构成马尔可夫链的转移机制，并实现一个驱动系统朝向低能构型的退火方案。\n\n用作基础和构建依据的基本原理：\n- 平衡统计物理学中的玻尔兹曼分布：一个在构型 $X$ 上的概率测度，在温度 $T$ 下正比于 $\\exp(-E(X)/T)$，其中 $E(X)$ 是能量函数。\n- Metropolis方法（Metropolis–Hastings算法的一个特例）：一种马尔可夫链蒙特卡洛构造，通过基于能量差和温度接受或拒绝提议的移动，来强制执行相对于目标分布的细致平衡。\n- 基本的马尔可夫链定义：一个具有无记忆性的随机过程，其转移概率仅取决于当前状态，且细致平衡是其具有指定不变分布的平稳性的一个充分条件。\n\n问题设置：\n- 网格与调色板。设网格大小为 $N \\times M$，整数索引为 $(i,j)$，其中 $i \\in \\{0,\\dots,N-1\\}$ 且 $j \\in \\{0,\\dots,M-1\\}$。设有限调色板为 $P=\\{p_{0},p_{1},\\dots,p_{K-1}\\}$，其中每个 $p_{k}$ 是集合 $\\{0,\\dots,255\\}$ 中的一个灰度强度值。一个马赛克构型 $X$ 是一个 $N \\times M$ 的调色板索引数组 $x_{ij} \\in \\{0,\\dots,K-1\\}$；位置 $(i,j)$ 处的渲染强度为 $R_{ij}=p_{x_{ij}}$。\n- 目标图像。目标是一个 $N \\times M$ 的灰度强度网格 $I$，其值为 $I_{ij} \\in \\{0,\\dots,255\\}$。\n- 能量函数。定义总能量\n$$\nE(X) \\;=\\; \\sum_{i=0}^{N-1} \\sum_{j=0}^{M-1} \\big(R_{ij}-I_{ij}\\big)^{2}\n\\;+\\;\n\\lambda \\sum_{i=0}^{N-1} \\sum_{j=0}^{M-1} \\Big( \\mathbf{1}_{i+1N} \\cdot \\big(R_{ij}-R_{i+1,j}\\big)^{2} + \\mathbf{1}_{j+1M} \\cdot \\big(R_{ij}-R_{i,j+1}\\big)^{2} \\Big),\n$$\n其中 $\\lambda \\ge 0$ 是一个平滑度权重，$\\mathbf{1}_{\\cdot}$ 是一个指示函数，当邻居存在时为 $1$，否则为 $0$。第一项强制对目标图像的保真度，第二项是局部颜色约束，通过惩罚相邻瓦片之间的巨大差异来鼓励平滑性。\n\n需要推导和实现的算法要求：\n- 状态空间与提议。状态空间是所有 $N \\times M$ 调色板索引分配的集合。单次更新提议是：在所有位置中均匀随机选择一个 $(i,j)$，并提议将 $x_{ij}$ 更改为从集合 $\\{0,\\dots,K-1\\} \\setminus \\{x_{ij}\\}$ 中均匀随机抽取的另一个调色板索引 $x'_{ij}$。这定义了一个在离散选择上对称的提议核。\n- 接受准则。基于 Metropolis 方法设计一个接受准则，使其在给定温度 $T$ 下满足相对于玻尔兹曼分布 $\\pi_{T}(X) \\propto \\exp(-E(X)/T)$ 的细致平衡。用提议构型与当前构型之间的能量差 $\\Delta E$ 和温度 $T$ 来表示接受概率。\n- 温度方案。在总共 $S$ 次提议中，使用几何降温方案 $T_{t}=T_{0}\\,\\alpha^{t}$，其中 $T_{0}0$ 且 $\\alpha \\in (0,1)$，$t \\in \\{0,1,\\dots,S-1\\}$ 是提议计数。论证为何这种方案是计算物理学中用于模拟退火的一种启发式方法。不要求证明收敛性。\n- 局部能量更新。为确保计算效率，对于单点更改，应仅使用受影响的项（$(i,j)$ 处的数据项及其与最多四个邻居的相互作用）来计算能量差 $\\Delta E$，而不是重新计算完整的 $E(X)$。\n\n实现细节：\n- 初始化。通过将每个目标强度 $I_{ij}$ 映射到 $P$ 中绝对差最小的调色板值来初始化 $X$，即选择 $x_{ij} \\in \\operatorname*{arg\\,min}_{k \\in \\{0,\\dots,K-1\\}} |p_{k}-I_{ij}|$。\n- 随机性。每个测试用例使用固定的伪随机种子，以确保输出是确定性的。\n- 输出。对于每个测试用例，运行退火过程，执行精确的 $S$ 次提议。报告最终总能量 $E(X)$，形式为小数点后保留三位数的浮点数。\n\n测试套件：\n提供一个程序，运行以下四个案例，并按顺序将四个结果打印为一行，用逗号分隔并用方括号括起来。\n\n- 案例1（一般情况）：$N=M=4$，$K=3$，$P=[0,128,255]$，$\\lambda=0.1$，$T_{0}=50.0$，$\\alpha=0.995$，$S=6000$，种子 $=12345$。目标 $I$：\n$$\n\\begin{bmatrix}\n0  64  128  192\\\\\n16  80  144  208\\\\\n32  96  160  224\\\\\n48  112  176  240\n\\end{bmatrix}\n$$\n- 案例2（小网格，强平滑度）：$N=M=2$，$K=3$，$P=[0,128,255]$，$\\lambda=2.0$，$T_{0}=10.0$，$\\alpha=0.99$，$S=2000$，种子 $=7$。目标 $I$：\n$$\n\\begin{bmatrix}\n200  50\\\\\n60  210\n\\end{bmatrix}\n$$\n- 案例3（无平滑度）：$N=M=3$，$K=4$，$P=[0,85,170,255]$，$\\lambda=0.0$，$T_{0}=1.0$，$\\alpha=0.9$，$S=1000$，种子 $=99$。目标 $I$：\n$$\n\\begin{bmatrix}\n0  0  255\\\\\n0  128  255\\\\\n0  255  255\n\\end{bmatrix}\n$$\n- 案例4（棋盘格冲突，二元调色板）：$N=M=4$，$K=2$，$P=[0,255]$，$\\lambda=1.0$，$T_{0}=5.0$，$\\alpha=0.997$，$S=8000$，种子 $=202$。目标 $I$：\n$$\n\\begin{bmatrix}\n0  255  0  255\\\\\n255  0  255  0\\\\\n0  255  0  255\\\\\n255  0  255  0\n\\end{bmatrix}\n$$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例顺序列出结果，每个值都四舍五入到小数点后三位。例如，一个有效的输出行格式为 $[\\text{r}_{1},\\text{r}_{2},\\text{r}_{3},\\text{r}_{4}]$，其中每个 $\\text{r}_{i}$ 是一个恰好有三位小数的浮点数，且不打印任何额外文本。", "solution": "目标是合成一个能够逼近目标图像 $I$ 的马赛克构型 $X$。这被构建为一个能量最小化问题。构型空间巨大，因此需要一种随机搜索算法，而模拟退火是一种具有物理动机且有效的选择。\n\n首先，我们对系统进行形式化。状态空间 $\\mathcal{S}$ 是所有可能的马赛克构型的集合。一个构型或状态 $X$ 是一个 $N \\times M$ 的调色板索引网格，其中每个位置 $(i,j)$ 被分配一个索引 $x_{ij} \\in \\{0, 1, \\dots, K-1\\}$。状态总数是有限的，等于 $K^{NM}$。一个构型 $X$ 在位置 $(i,j)$ 的渲染强度是 $R_{ij} = p_{x_{ij}}$，其中 $P=\\{p_0, p_1, \\dots, p_{K-1}\\}$ 是可用灰度值的调色板。\n\n一个构型 $X$ 的质量通过我们希望最小化的能量函数 $E(X)$ 来量化。给定的函数是：\n$$\nE(X) = \\underbrace{\\sum_{i=0}^{N-1} \\sum_{j=0}^{M-1} (R_{ij} - I_{ij})^2}_{\\text{数据保真度项}} + \\underbrace{\\lambda \\sum_{i=0}^{N-1} \\sum_{j=0}^{M-1} \\left( \\mathbf{1}_{i+1N} (R_{ij} - R_{i+1,j})^2 + \\mathbf{1}_{j+1M} (R_{ij} - R_{i,j+1})^2 \\right)}_{\\text{平滑度正则化项}}\n$$\n此处，$I_{ij}$ 是目标图像的强度，$\\lambda \\ge 0$ 是一个加权系数，$\\mathbf{1}_{\\cdot}$ 是指示函数。第一项，即数据保真度项或外场项，惩罚与目标图像的偏差。第二项，即平滑度项或相互作用项，惩罚相邻瓦片之间的大强度差异，以促进局部同质性。这个能量函数类似于在像 Ising 或 Potts 模型等格点模型中使用的哈密顿量，其中状态具有特定位置的能量（来自外场）和与邻居的相互作用能。\n\n为了找到一个低能状态，我们采用马尔可夫链蒙特卡洛（MCMC）方法。我们构建一个马尔可夫链，其状态是构型 $X \\in \\mathcal{S}$，其平稳分布是玻尔兹曼分布 $\\pi_T(X)$：\n$$\n\\pi_T(X) = \\frac{1}{Z(T)} \\exp\\left(-\\frac{E(X)}{T}\\right)\n$$\n其中 $T$ 是一个类似于温度的参数，$Z(T) = \\sum_{X' \\in \\mathcal{S}} \\exp(-E(X')/T)$ 是配分函数。在低温下（$T \\to 0$），此分布将概率集中在能量 $E(X)$ 最低的状态上。\n\n马尔可夫链通过一系列被接受或拒绝的提议移动来演化。问题指定了提议机制：\n1. 从 $N \\times M$ 网格中均匀随机选择一个位置 $(i,j)$。\n2. 通过将此位置的调色板索引从其当前值 $x_{ij}$ 更改为从集合 $\\{0, \\dots, K-1\\} \\setminus \\{x_{ij}\\}$ 中均匀随机选择的新索引 $x'_{ij}$，来提议一个新构型 $X'$。\n\n令从状态 $X$ 移动到 $X'$ 的提议概率为 $g(X'|X)$。一个特定位置以概率 $1/(NM)$ 被选中，一个特定的新索引以概率 $1/(K-1)$ 被选中。因此，如果 $X$ 和 $X'$ 仅在一个位置上不同，则 $g(X'|X) = 1/(NM(K-1))$。反向提议，从 $X'$ 到 $X$，涉及选择相同的位置 $(i,j)$ 和从 $K-1$ 个备选项中选择原始的索引 $x_{ij}$。因此，$g(X|X') = 1/(NM(K-1))$，所以提议核是对称的：$g(X'|X) = g(X|X')$。\n\n为确保链收敛于 $\\pi_T(X)$，我们强制执行细致平衡条件：$\\pi_T(X) P(X \\to X') = \\pi_T(X') P(X' \\to X)$，其中 $P(X \\to X') = g(X'|X) A(X \\to X')$ 是总转移概率，$A(X \\to X')$ 是接受概率。由于 $g$ 的对称性，细致平衡简化为 $\\pi_T(X) A(X \\to X') = \\pi_T(X') A(X' \\to X)$。满足此条件的标准接受概率选择是 Metropolis 准则：\n$$\nA(X \\to X') = \\min\\left(1, \\frac{\\pi_T(X')}{\\pi_T(X)}\\right) = \\min\\left(1, \\exp\\left(-\\frac{E(X') - E(X)}{T}\\right)\\right)\n$$\n令 $\\Delta E = E(X') - E(X)$ 为能量变化，则接受概率为 $A = \\min(1, \\exp(-\\Delta E/T))$。如果提议的移动降低了能量（$\\Delta E  0$），则总是接受。如果它增加了能量（$\\Delta E  0$），则以一个随着 $\\Delta E$ 增加或 $T$ 降低而减小的概率接受。这使得系统能够逃离局部能量极小值。\n\n模拟退火是一种利用此 MCMC 过程的启发式方法。它从一个高的初始温度 $T_0$ 开始，此时许多能量增加的移动都被接受，从而可以对状态空间进行广泛探索。然后根据一个降温方案逐渐降低温度。指定的方案是几何降温：\n$$\nT_t = T_0 \\alpha^t\n$$\n对于 $t \\in \\{0, 1, \\dots, S-1\\}$，其中 $t$ 是步数（提议数），$T_0$ 是初始温度，$\\alpha \\in (0,1)$ 是降温速率。随着 $T$ 的降低，接受准则变得更加严格，系统会优先稳定在低能状态。虽然这种启发式方法不能保证在有限步数内找到全局最小值，但它是一种被广泛使用且有效的实用方法。\n\n实现的一个关键方面是计算效率。为每个提议重新计算整个能量 $E(X')$ 的成本过高。由于一个提议只改变一个位置 $(i,j)$，能量变化 $\\Delta E$ 可以局部计算。设提议的变化是从旧索引 $x_{ij}$ 到新索引 $x'_{ij}$，对应的渲染颜色为 $R_o = p_{x_{ij}}$ 和 $R_n = p_{x'_{ij}}$。数据保真度项的变化仅发生在位置 $(i,j)$：\n$$\n\\Delta E_{\\text{data}} = (R_n - I_{ij})^2 - (R_o - I_{ij})^2\n$$\n平滑度项的变化仅涉及位置 $(i,j)$ 与其直接邻居之间的相互作用。设 $\\mathcal{N}(i,j)$ 为 $(i,j)$ 的现有邻居坐标集。对于每个邻居 $(u,v) \\in \\mathcal{N}(i,j)$，相互作用项 $(R_{ij} - R_{uv})^2$ 发生变化。总的平滑度能量变化是：\n$$\n\\Delta E_{\\text{smooth}} = \\lambda \\sum_{(u,v) \\in \\mathcal{N}(i,j)} \\left[ (R_n - R_{uv})^2 - (R_o - R_{uv})^2 \\right]\n$$\n总能量变化是 $\\Delta E = \\Delta E_{\\text{data}} + \\Delta E_{\\text{smooth}}$。这种局部更新比完全重新计算快得多。\n\n该算法按以下步骤进行：\n1. 初始化构型 $X$。对每个位置 $(i,j)$，将调色板索引 $x_{ij}$ 设为 $\\operatorname*{arg\\,min}_{k} |p_k - I_{ij}|$。\n2. 设置伪随机生成器种子以保证可复现性。\n3. 对于从 $0$ 到 $S-1$ 的 $t$：\n    a. 计算当前温度 $T_t = T_0 \\alpha^t$。\n    b. 通过随机选择一个位置和一个新索引来提议一个新状态 $X'$。\n    c. 局部计算 $\\Delta E$。\n    d. 生成一个均匀随机数 $u \\in [0,1)$。\n    e. 如果 $u  \\min(1, \\exp(-\\Delta E/T_t))$，则接受该移动：将构型 $X$ 更新为 $X'$。\n4. 经过 $S$ 步后，使用完整的能量公式计算最终构型的总能量 $E(X)$ 并报告结果。", "answer": "```python\nimport numpy as np\n\ndef calculate_total_energy(palette_indices, palette, target_image, lam):\n    \"\"\"Calculates the total energy of a given configuration from scratch.\"\"\"\n    rendered_image = palette[palette_indices]\n    N, M = rendered_image.shape\n\n    # Data fidelity term\n    data_energy = np.sum((rendered_image - target_image)**2)\n\n    # Smoothness term\n    smoothness_energy = 0\n    # Horizontal differences\n    if M > 1:\n        smoothness_energy += np.sum((rendered_image[:, :-1] - rendered_image[:, 1:])**2)\n    # Vertical differences\n    if N > 1:\n        smoothness_energy += np.sum((rendered_image[:-1, :] - rendered_image[1:, :])**2)\n        \n    return data_energy + lam * smoothness_energy\n\ndef run_annealing(N, M, K, P, lam, T0, alpha, S, seed, I):\n    \"\"\"Runs the simulated annealing algorithm for a single test case.\"\"\"\n    \n    # Set seed for reproducibility\n    np.random.seed(seed)\n    \n    # Convert inputs to numpy arrays\n    palette = np.array(P, dtype=np.float64)\n    target_image = np.array(I, dtype=np.float64)\n\n    # Initialization\n    # Find the closest palette color for each pixel in the target image\n    palette_indices = np.zeros((N, M), dtype=int)\n    for i in range(N):\n        for j in range(M):\n            palette_indices[i, j] = np.argmin(np.abs(palette - target_image[i, j]))\n\n    # Annealing loop\n    all_indices = list(range(K))\n    for t in range(S):\n        T = T0 * (alpha ** t)\n\n        # Propose a move: pick a random site and a random new color\n        i, j = np.random.randint(N), np.random.randint(M)\n        \n        current_idx = palette_indices[i, j]\n        options = all_indices[:current_idx] + all_indices[current_idx+1:]\n        new_idx = np.random.choice(options)\n        \n        current_color = palette[current_idx]\n        new_color = palette[new_idx]\n\n        # Efficiently calculate energy difference (Delta E)\n        # Data fidelity term change\n        delta_e = (new_color - target_image[i, j])**2 - (current_color - target_image[i, j])**2\n        \n        # Smoothness term change\n        # Neighbors: (i-1, j), (i+1, j), (i, j-1), (i, j+1)\n        # Since (a-b)^2 = (b-a)^2, the calculation is symmetric\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = i + di, j + dj\n            if 0 = ni  N and 0 = nj  M:\n                neighbor_idx = palette_indices[ni, nj]\n                neighbor_color = palette[neighbor_idx]\n                delta_e += lam * ((new_color - neighbor_color)**2 - (current_color - neighbor_color)**2)\n\n        # Metropolis acceptance criterion\n        if delta_e  0 or (T > 1e-9 and np.random.rand()  np.exp(-delta_e / T)):\n            palette_indices[i, j] = new_idx\n            \n    # Calculate final energy of the final configuration\n    final_energy = calculate_total_energy(palette_indices, palette, target_image, lam)\n    \n    return final_energy\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the simulated annealing solver for each,\n    printing the results in the required format.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 4, \"M\": 4, \"K\": 3, \"P\": [0, 128, 255], \"lam\": 0.1, \n            \"T0\": 50.0, \"alpha\": 0.995, \"S\": 6000, \"seed\": 12345,\n            \"I\": [\n                [0, 64, 128, 192],\n                [16, 80, 144, 208],\n                [32, 96, 160, 224],\n                [48, 112, 176, 240]\n            ]\n        },\n        {\n            \"N\": 2, \"M\": 2, \"K\": 3, \"P\": [0, 128, 255], \"lam\": 2.0, \n            \"T0\": 10.0, \"alpha\": 0.99, \"S\": 2000, \"seed\": 7,\n            \"I\": [\n                [200, 50],\n                [60, 210]\n            ]\n        },\n        {\n            \"N\": 3, \"M\": 3, \"K\": 4, \"P\": [0, 85, 170, 255], \"lam\": 0.0, \n            \"T0\": 1.0, \"alpha\": 0.9, \"S\": 1000, \"seed\": 99,\n            \"I\": [\n                [0, 0, 255],\n                [0, 128, 255],\n                [0, 255, 255]\n            ]\n        },\n        {\n            \"N\": 4, \"M\": 4, \"K\": 2, \"P\": [0, 255], \"lam\": 1.0,\n            \"T0\": 5.0, \"alpha\": 0.997, \"S\": 8000, \"seed\": 202,\n            \"I\": [\n                [0, 255, 0, 255],\n                [255, 0, 255, 0],\n                [0, 255, 0, 255],\n                [255, 0, 255, 0]\n            ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # A small check in run_annealing was made to avoid division by zero if T gets too small\n        # The logic is if T is very small, exp(-delta_e / T) for delta_e>0 is effectively 0, so never accept.\n        # This is implicitly handled by floating point precision but an explicit check is safer.\n        # Added if T > 1e-9 to the acceptance check.\n        result = run_annealing(\n            case[\"N\"], case[\"M\"], case[\"K\"], case[\"P\"], case[\"lam\"],\n            case[\"T0\"], case[\"alpha\"], case[\"S\"], case[\"seed\"], case[\"I\"]\n        )\n        results.append(result)\n\n    # Format the output as a comma-separated list of floats with 3 decimal places\n    output_str = \",\".join([f\"{r:.3f}\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "2411642"}]}