{"hands_on_practices": [{"introduction": "我们从生成非均匀随机变量最直接的技术——逆变换采样法开始。该方法的核心原理是：对于任何连续分布，其累积分布函数（CDF）可以将服从该分布的随机变量转换为一个均匀分布的随机变量。通过逆转这一过程，我们可以将一个标准的均匀分布随机数转换为符合我们目标分布的随机数。这个练习将通过一个虽不简单但可解析求解的例子（三角分布），让你亲手实践推导CDF及求其逆函数，为解决更复杂的问题打下坚实的基础。[@problem_id:2398091]", "problem": "你需要编写一个完整的、可运行的程序，用于从三角概率分布中生成独立样本，且不能使用任何直接生成此类样本的库函数。只允许使用单位区间上连续均匀分布的独立样本作为基本要素。\n\n设三角分布由三个实数参数 $a$、$c$ 和 $b$ 定义，其中 $a < b$ 且 $a \\le c \\le b$。其概率密度函数在$[a, b]$之外为零，在$[a, b]$内，于$[a, c]$上线性递增，于$[c, b]$上线性递减，并经过缩放以使在$[a, b]$上的积分等于 $1$。具体而言，对于 $x \\in \\mathbb{R}$，\n$$\nf(x; a,c,b) =\n\\begin{cases}\n\\dfrac{2(x-a)}{(b-a)(c-a)}, & a \\le x \\le c,\\quad \\text{如果 } c > a \\\\\n\\dfrac{2(b-x)}{(b-a)(b-c)}, & c \\le x \\le b,\\quad \\text{如果 } c  b \\\\\n0,  \\text{其他情况}.\n\\end{cases}\n$$\n\n你的程序必须对每个指定的测试用例，仅使用第一性原理完成以下所有操作：\n1. 对给定的 $(a,c,b)$，从三角分布中生成 $N$ 个独立样本。\n2. 计算样本均值和样本方差（使用总体归一化，即除以 $N$）。\n3. 通过对给定密度函数积分，计算精确的累积分布函数 $F(x; a,c,b)$，然后计算 Kolmogorov–Smirnov 统计量 $D_N = \\sup_x \\lvert F_N(x) - F(x)\\rvert$，其中 $F_N$ 是所生成样本的经验累积分布函数。\n4. 将样本均值的绝对误差与指定容差 $\\delta_\\mu$、样本方差的绝对误差与指定容差 $\\delta_{\\sigma^2}$ 以及 Kolmogorov–Smirnov 统计量与指定容差 $\\delta_{\\mathrm{KS}}$ 进行比较。一个测试用例当且仅当所有三个比较都满足时，才被视为通过。\n\n仅使用 $[0,1]$ 上的独立均匀变量来构建非均匀样本。你的程序必须是确定性的：为底层的均匀随机数生成器使用固定的种子 $123456$（十进制整数）。\n\n测试套件。对下面的每个元组 $(a,c,b,N,\\delta_\\mu,\\delta_{\\sigma^2},\\delta_{\\mathrm{KS}})$，执行上述过程：\n- 测试 1：$(0.0,\\,0.5,\\,1.0,\\,200000,\\,0.002,\\,0.003,\\,0.01)$\n- 测试 2：$(0.0,\\,0.0,\\,5.0,\\,150000,\\,0.01,\\,0.03,\\,0.02)$\n- 测试 3：$(-2.0,\\,1.0,\\,1.0,\\,140000,\\,0.01,\\,0.03,\\,0.02)$\n- 测试 4：$(-3.0,\\,-1.0,\\,2.0,\\,160000,\\,0.008,\\,0.03,\\,0.02)$\n\n答案规范和最终输出格式。对于四个测试中的每一个，返回一个布尔值，指示该测试是否通过。你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与测试顺序一致；例如，一个有效的输出行看起来像\n[`True`, `False`, `True`, `True`]。", "solution": "问题陈述经过验证，被认为是有效的。它构成了计算物理学中一个适定问题，特别是在非均匀随机变量的生成方面。任务是使用逆变换采样法从三角分布中生成样本，然后使用标准统计检验，根据理论属性验证生成的样本。该问题具有科学依据，是客观的，并为得出唯一的、可验证的解决方案提供了所有必要信息。在众数 $c$ 等于端点 $a$ 或 $b$ 的边界情况下，概率密度函数 (PDF) 缺乏明确定义，这是一个微小的不精确之处，但任何有能力的从业者都可以通过考虑极限或分布的几何形状来严格解决，这是一项标准的练习。\n\n解决方案分几步进行：首先，我们推导累积分布函数 (CDF) 及其逆函数，这对于逆变换采样法至关重要。其次，我们陈述该分布的理论均值和方差。第三，我们详细说明计算 Kolmogorov-Smirnov 统计量的算法。\n\n三角分布由其在支撑集 $x \\in [a,b]$上的概率密度函数 (PDF) $f(x; a,c,b)$ 定义：\n$$\nf(x; a,c,b) =\n\\begin{cases}\n\\dfrac{2(x-a)}{(b-a)(c-a)},  a \\le x \\le c \\\\\n\\dfrac{2(b-x)}{(b-a)(b-c)},  c  x \\le b\n\\end{cases}\n$$\n这在 $a  c  b$ 时有效。我们将在推导过程中处理 $c=a$ 和 $c=b$ 的边缘情况。\n\n生成样本所选用的方法是逆变换采样法。该方法依赖于这样一个事实：如果 $X$ 是一个具有 CDF $F_X(x)$ 的连续随机变量，那么随机变量 $U = F_X(X)$ 在 $[0,1]$ 上均匀分布。因此，我们可以通过生成均匀随机变量 $u \\in [0,1]$ 并计算 $x = F_X^{-1}(u)$ 来生成 $X$ 的样本。\n\n累积分布函数 (CDF) 的推导, $F(x) = \\int_{-\\infty}^x f(t) dt$：\n对于 $x  a$，$F(x)=0$。\n对于 $a \\le x \\le c$：\n$$\nF(x) = \\int_a^x \\frac{2(t-a)}{(b-a)(c-a)} dt = \\frac{2}{(b-a)(c-a)} \\left[ \\frac{(t-a)^2}{2} \\right]_a^x = \\frac{(x-a)^2}{(b-a)(c-a)}\n$$\n在众数 $c$ 处的值为 $F(c) = \\frac{(c-a)^2}{(b-a)(c-a)} = \\frac{c-a}{b-a}$。\n\n对于 $c  x \\le b$：\n$$\nF(x) = F(c) + \\int_c^x \\frac{2(b-t)}{(b-a)(b-c)} dt = \\frac{c-a}{b-a} + \\left[ \\frac{-(b-t)^2}{(b-a)(b-c)} \\right]_c^x\n$$\n$$\nF(x) = \\frac{c-a}{b-a} + \\frac{-(b-x)^2 - (-(b-c)^2)}{(b-a)(b-c)} = \\frac{c-a}{b-a} + \\frac{(b-c)^2 - (b-x)^2}{(b-a)(b-c)}\n$$\n这个表达式可以简化为一个更优美的形式：\n$$\nF(x) = 1 - \\frac{(b-x)^2}{(b-a)(b-c)}\n$$\n对于 $x  b$，$F(x)=1$。\n总之，对于一般情况 $a  c  b$：\n$$\nF(x; a,c,b) =\n\\begin{cases}\n0,  x  a \\\\\n\\frac{(x-a)^2}{(b-a)(c-a)},  a \\le x \\le c \\\\\n1 - \\frac{(b-x)^2}{(b-a)(b-c)},  c  x \\le b \\\\\n1,  x  b\n\\end{cases}\n$$\n对于边缘情况 $c=a$（一个从 $a$ 到 $b$ 递减的直角三角分布），PDF 仅在 $x \\in [a,b]$ 上非零，由 $f(x) = \\frac{2(b-x)}{(b-a)^2}$ 给出。CDF 变为 $F(x) = 1 - \\frac{(b-x)^2}{(b-a)^2}$，对于 $x \\in [a,b]$。\n对于边缘情况 $c=b$（一个从 $a$ 到 $b$ 递增的直角三角分布），PDF 为 $f(x) = \\frac{2(x-a)}{(b-a)^2}$，对于 $x \\in [a,b]$。CDF 变为 $F(x) = \\frac{(x-a)^2}{(b-a)^2}$，对于 $x \\in [a,b]$。\n\n逆 CDF 的推导, $x = F^{-1}(u)$：\n我们设 $u = F(x)$，对于 $u \\in [0,1]$，然后求解 $x$。\n设 $F_c = F(c) = \\frac{c-a}{b-a}$。\n如果 $0 \\le u \\le F_c$，这对应于 $a \\le x \\le c$。\n$$ u = \\frac{(x-a)^2}{(b-a)(c-a)} \\implies x = a + \\sqrt{u(b-a)(c-a)} $$\n如果 $F_c  u \\le 1$，这对应于 $c  x \\le b$。\n$$ u = 1 - \\frac{(b-x)^2}{(b-a)(b-c)} \\implies x = b - \\sqrt{(1-u)(b-a)(b-c)} $$\n对于边缘情况，这些公式会简化。\n如果 $c=a$，那么 $F_c=0$，对于任何 $u \\in [0,1]$ 我们使用第二种形式，它变为 $x = b - \\sqrt{(1-u)(b-a)^2} = b - (b-a)\\sqrt{1-u}$。\n如果 $c=b$，那么 $F_c=1$，对于任何 $u \\in [0,1]$ 我们使用第一种形式，它变为 $x = a + \\sqrt{u(b-a)^2} = a + (b-a)\\sqrt{u}$。\n\n理论与样本统计量：\n三角分布的理论均值 $\\mu$ 和方差 $\\sigma^2$ 由以下公式给出：\n$$ \\mu = \\frac{a+b+c}{3} $$\n$$ \\sigma^2 = \\frac{(a-b)^2 + (b-c)^2 + (c-a)^2}{36} $$\n给定一组 $N$ 个生成的样本 $\\{X_i\\}_{i=1}^N$，样本均值 $\\bar{X}$ 和样本方差 $S_N^2$（使用总体归一化）为：\n$$ \\bar{X} = \\frac{1}{N} \\sum_{i=1}^N X_i $$\n$$ S_N^2 = \\frac{1}{N} \\sum_{i=1}^N (X_i - \\bar{X})^2 $$\n那么绝对误差为 $|\\bar{X} - \\mu|$ 和 $|S_N^2 - \\sigma^2|$。\n\nKolmogorov-Smirnov 统计量：\nKolmogorov-Smirnov (KS) 统计量 $D_N$ 衡量经验分布函数 (EDF) $F_N(x)$ 与理论 CDF $F(x)$ 之间的最大距离。\n$$ D_N = \\sup_x |F_N(x) - F(x)| $$\n一组样本的 EDF 是 $F_N(x) = \\frac{1}{N}\\sum_{i=1}^N I(X_i \\le x)$，其中 $I(\\cdot)$ 是指示函数。\n为便于计算，如果我们将样本排序使得 $X_{(1)} \\le X_{(2)} \\le \\dots \\le X_{(N)}$，则统计量 $D_N$ 可以使用以下公式高效地计算：\n$$ D_N = \\max_{i=1,\\dots,N} \\left( \\frac{i}{N} - F(X_{(i)}) , F(X_{(i)}) - \\frac{i-1}{N} \\right) $$\n每个测试用例的流程是生成 $N$ 个样本，计算样本均值、样本方差和 KS 统计量，并验证它们与理论值的偏差是否分别在指定的容差 $\\delta_\\mu$、$\\delta_{\\sigma^2}$ 和 $\\delta_{\\mathrm{KS}}$ 之内。一个测试当且仅当所有三个条件都满足时才通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function that executes the validation tests for generating\n    samples from a triangular distribution.\n    \"\"\"\n    test_cases = [\n        (0.0, 0.5, 1.0, 200000, 0.002, 0.003, 0.01),\n        (0.0, 0.0, 5.0, 150000, 0.01, 0.03, 0.02),\n        (-2.0, 1.0, 1.0, 140000, 0.01, 0.03, 0.02),\n        (-3.0, -1.0, 2.0, 160000, 0.008, 0.03, 0.02)\n    ]\n\n    results = []\n    \n    # Use a fixed seed for the random number generator for deterministic output.\n    seed = 123456\n    rng = np.random.default_rng(seed)\n\n    for case in test_cases:\n        a, c, b, N, tol_mu, tol_var, tol_ks = case\n        \n        # Step 1: Generate N independent samples from the triangular distribution.\n        samples = _generate_triangular_samples(a, c, b, N, rng)\n        \n        # Step 2: Compute the sample mean and the sample variance.\n        sample_mean = np.mean(samples)\n        sample_var = np.var(samples) # Uses N in the denominator by default (ddof=0).\n\n        # Compute theoretical mean and variance.\n        true_mean = (a + b + c) / 3.0\n        true_var = ((a - b)**2 + (b - c)**2 + (c - a)**2) / 36.0\n\n        # Step 3: Compute the Kolmogorov–Smirnov statistic.\n        sorted_samples = np.sort(samples)\n        cdf_at_samples = _get_triangular_cdf(sorted_samples, a, c, b)\n        \n        i_vals = np.arange(1, N + 1)\n        d_plus = np.max(i_vals / N - cdf_at_samples)\n        d_minus = np.max(cdf_at_samples - (i_vals - 1) / N)\n        ks_stat = max(d_plus, d_minus)\n        \n        # Step 4: Compare errors with tolerances.\n        err_mean = abs(sample_mean - true_mean)\n        err_var = abs(sample_var - true_var)\n        \n        test_passed = (err_mean = tol_mu) and \\\n                      (err_var = tol_var) and \\\n                      (ks_stat = tol_ks)\n                      \n        results.append(test_passed)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _generate_triangular_samples(a, c, b, N, rng):\n    \"\"\"\n    Generates N samples from a triangular distribution using inverse transform sampling.\n    \"\"\"\n    u = rng.uniform(0.0, 1.0, N)\n    samples = np.zeros(N, dtype=float)\n    \n    # Handle the edge cases of right-triangular distributions\n    if a == c:\n        # Decreasing right-triangular distribution\n        samples = b - (b - a) * np.sqrt(1 - u)\n    elif b == c:\n        # Increasing right-triangular distribution\n        samples = a + (b - a) * np.sqrt(u)\n    else:\n        # General scalene-triangular distribution\n        fc = (c - a) / (b - a)\n        term1_factor = (b - a) * (c - a)\n        term2_factor = (b - a) * (b - c)\n        \n        # Create a boolean mask for u = fc\n        mask = u = fc\n        \n        # For u = fc, use the first part of the inverse CDF\n        samples[mask] = a + np.sqrt(u[mask] * term1_factor)\n        \n        # For u  fc, use the second part\n        samples[~mask] = b - np.sqrt((1.0 - u[~mask]) * term2_factor)\n        \n    return samples\n\ndef _get_triangular_cdf(x, a, c, b):\n    \"\"\"\n    Computes the exact Cumulative Distribution Function (CDF) for a triangular distribution.\n    The input x can be a scalar or a numpy array for vectorized computation.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    cdf_vals = np.zeros_like(x, dtype=float)\n    \n    # Handle the edge cases of right-triangular distributions\n    if a == c:\n        # Mask for values within the support [a, b]\n        mask_mid = (x = a)  (x = b)\n        cdf_vals[mask_mid] = 1.0 - ((b - x[mask_mid])**2 / (b - a)**2)\n    elif b == c:\n        # Mask for values within the support [a, b]\n        mask_mid = (x = a)  (x = b)\n        cdf_vals[mask_mid] = (x[mask_mid] - a)**2 / (b - a)**2\n    else:\n        # General scalene-triangular distribution\n        mask1 = (x = a)  (x = c)\n        mask2 = (x  c)  (x = b)\n        \n        cdf_vals[mask1] = (x[mask1] - a)**2 / ((b - a) * (c - a))\n        cdf_vals[mask2] = 1.0 - (b - x[mask2])**2 / ((b - a) * (b - c))\n\n    # For values outside the support [a, b]\n    cdf_vals[x  b] = 1.0\n    cdf_vals[x  a] = 0.0\n\n    return cdf_vals\n\nsolve()\n```", "id": "2398091"}, {"introduction": "虽然逆变换法很强大，但某些关键分布（如高斯分布）的CDF无法解析地求逆。在此，我们探索一种不同但同样巧妙的方法：Box-Muller变换。这个练习将演示如何通过一次聪明的坐标变换，从一对均匀分布的随机数生成一对独立的标准正态（高斯）随机变量。我们还将进一步学习如何生成相关的二元正态变量，这是模拟现实物理系统的普遍需求，从而掌握引入随机变量间相关性的基本线性代数技巧。[@problem_id:2398116]", "problem": "您需要编写一个完整、可运行的程序，该程序从仅有(0,1)开区间上的独立均匀随机数出发，构建二维非均匀随机变量，然后根据指定的目标属性验证生成的样本。任务如下。\n\n任务。给定(0,1)上的独立均匀随机输入，生成二维向量 $\\mathbf{X} \\in \\mathbb{R}^{2}$ 的样本，使得：\n- 在独立情况下，$\\mathbf{X}$ 服从标准二元正态分布，其均值向量为 $\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，协方差矩阵为 $\\boldsymbol{\\Sigma}=\\mathbf{I}_{2}$，其中 $\\mathbf{I}_{2}$ 表示 $2 \\times 2$ 的单位矩阵。\n- 在相关情况下，$\\mathbf{X}$ 服从具有指定均值向量 $\\boldsymbol{\\mu}\\in\\mathbb{R}^{2}$ 和指定对称正定协方差矩阵 $\\boldsymbol{\\Sigma}\\in\\mathbb{R}^{2\\times 2}$ 的二元正态分布。\n\n验证。对于给定的样本大小 $N$，计算经验均值\n$$\n\\hat{\\boldsymbol{\\mu}}=\\frac{1}{N}\\sum_{i=1}^{N}\\mathbf{X}_{i}\n$$\n和经验协方差（使用总体归一化）\n$$\n\\hat{\\boldsymbol{\\Sigma}}=\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\mathbf{X}_{i}-\\hat{\\boldsymbol{\\mu}}\\right)\\left(\\mathbf{X}_{i}-\\hat{\\boldsymbol{\\mu}}\\right)^{\\top}.\n$$\n定义均值误差 $e_{\\mu}=\\max_{j\\in\\{1,2\\}}\\left|\\hat{\\mu}_{j}-\\mu_{j}\\right|$ 和协方差误差 $e_{\\Sigma}=\\max_{j,k\\in\\{1,2\\}}\\left|\\hat{\\Sigma}_{jk}-\\Sigma_{jk}\\right|$。如果一个测试同时满足 $e_{\\mu}lt;\\varepsilon_{\\mu}$ 和 $e_{\\Sigma}lt;\\varepsilon_{\\Sigma}$，则认为该测试通过，其中 $\\varepsilon_{\\mu}$ 和 $\\varepsilon_{\\Sigma}$ 是为该测试指定的容差。\n\n随机性与可复现性。使用固定的伪随机种子 $s$ 来初始化均匀生成器，以确保结果是可复现的。使用整数种子 $s=123456789$。\n\n测试套件。您的程序必须按顺序运行以下四个测试，每个测试根据上述通过/失败规则产生一个布尔值。\n\n- 测试 $\\mathbf{T1}$（独立，大样本）：\n  - 目标参数：$\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$\\boldsymbol{\\Sigma}=\\begin{bmatrix}1 amp; 0 \\\\ 0 amp; 1\\end{bmatrix}$。\n  - 样本大小：$N=200{,}000$。\n  - 容差：$\\varepsilon_{\\mu}=0.02$，$\\varepsilon_{\\Sigma}=0.02$。\n\n- 测试 $\\mathbf{T2}$（独立，小样本边缘情况）：\n  - 目标参数：$\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$\\boldsymbol{\\Sigma}=\\begin{bmatrix}1 amp; 0 \\\\ 0 amp; 1\\end{bmatrix}$。\n  - 样本大小：$N=100$。\n  - 容差：$\\varepsilon_{\\mu}=0.30$，$\\varepsilon_{\\Sigma}=0.30$。\n\n- 测试 $\\mathbf{T3}$（相关，一般情况）：\n  - 目标参数：$\\boldsymbol{\\mu}=\\begin{bmatrix}1.5 \\\\ -0.5\\end{bmatrix}$，$\\boldsymbol{\\Sigma}=\\begin{bmatrix}4.0 amp; 1.2 \\\\ 1.2 amp; 1.0\\end{bmatrix}$。\n  - 样本大小：$N=300{,}000$。\n  - 容差：$\\varepsilon_{\\mu}=0.03$，$\\varepsilon_{\\Sigma}=0.03$。\n\n- 测试 $\\mathbf{T4}$（相关，近边界相关性）：\n  - 目标参数：$\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$\\boldsymbol{\\Sigma}=\\begin{bmatrix}1.0 amp; -0.95 \\\\ -0.95 amp; 1.0\\end{bmatrix}$。\n  - 样本大小：$N=300{,}000$。\n  - 容差：$\\varepsilon_{\\mu}=0.03$，$\\varepsilon_{\\Sigma}=0.04$。\n\n输出规范。您的程序应生成单行输出，其中包含四个测试 $\\mathbf{T1}$、$\\mathbf{T2}$、$\\mathbf{T3}$ 和 $\\mathbf{T4}$ 的结果，形式为逗号分隔的布尔值列表并用方括号括起，例如\n[`True`, `False`, `True`, `True`]。\n不允许有其他输出。", "solution": "对问题陈述进行验证。\n\n逐字提取给定条件：\n- 任务是从(0,1)开区间上的独立均匀随机数生成二维向量 $\\mathbf{X} \\in \\mathbb{R}^{2}$ 的样本。\n- 对于独立情况，目标是均值向量为 $\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$、协方差矩阵为 $\\boldsymbol{\\Sigma}=\\mathbf{I}_{2}$ 的标准二元正态分布。\n- 对于相关情况，目标是具有指定均值向量 $\\boldsymbol{\\mu}\\in\\mathbb{R}^{2}$ 和指定对称正定协方差矩阵 $\\boldsymbol{\\Sigma}\\in\\mathbb{R}^{2\\times 2}$ 的二元正态分布。\n- 验证要求计算样本大小为 $N$ 的经验均值 $\\hat{\\boldsymbol{\\mu}}=\\frac{1}{N}\\sum_{i=1}^{N}\\mathbf{X}_{i}$ 和经验协方差 $\\hat{\\boldsymbol{\\Sigma}}=\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\mathbf{X}_{i}-\\hat{\\boldsymbol{\\mu}}\\right)\\left(\\mathbf{X}_{i}-\\hat{\\boldsymbol{\\mu}}\\right)^{\\top}$。\n- 误差定义为 $e_{\\mu}=\\max_{j\\in\\{1,2\\}}\\left|\\hat{\\mu}_{j}-\\mu_{j}\\right|$ 和 $e_{\\Sigma}=\\max_{j,k\\in\\{1,2\\}}\\left|\\hat{\\Sigma}_{jk}-\\Sigma_{jk}\\right|$。\n- 如果 $e_{\\mu}lt;\\varepsilon_{\\mu}$ 且 $e_{\\Sigma}lt;\\varepsilon_{\\Sigma}$，则测试通过。\n- 必须使用固定的伪随机种子 $s=123456789$。\n- 四个测试用例（$\\mathbf{T1}$、$\\mathbf{T2}$、$\\mathbf{T3}$、$\\mathbf{T4}$）及其各自的参数（$\\boldsymbol{\\mu}$、$\\boldsymbol{\\Sigma}$、$N$、$\\varepsilon_{\\mu}$、$\\varepsilon_{\\Sigma}$）已指定。\n\n根据所需标准对问题进行验证。该问题具有科学依据，提法恰当，并且是客观的。它涉及计算物理学和统计学中的一个标准基础技术：非均匀随机变量的生成。其理论基础（利用Box-Muller变换和Cholesky分解等方法）是合理的。提供了唯一、可验证解所需的所有参数和定义。经确认，为相关测试指定的协方差矩阵是对称且正定的，确保存在有效的Cholesky分解。对于测试 $\\mathbf{T3}$，$\\det(\\boldsymbol{\\Sigma}) = 4.0 \\times 1.0 - 1.2^2 = 2.56  0$。对于测试 $\\mathbf{T4}$，$\\det(\\boldsymbol{\\Sigma}) = 1.0 \\times 1.0 - (-0.95)^2 = 0.0975  0$。因此，该问题被认定为有效。\n\n解决方案分三部分构建：生成标准正态随机变量，变换到一般二元正态分布，以及经验验证。\n\n首先，我们解决从均匀分布生成独立标准正态随机变量的问题。问题要求从(0,1)开区间上的均匀分布中抽取的独立随机数 $U_{1}, U_{2}$ 开始。一个标准且高效的方法是Box-Muller变换。此变换取两个这样的均匀变量，通过以下关系生成两个独立的标准正态变量 $Z_{1}, Z_{2} \\sim \\mathcal{N}(0,1)$：\n$$\nZ_1 = \\sqrt{-2 \\ln U_1} \\cos(2 \\pi U_2)\n$$\n$$\nZ_2 = \\sqrt{-2 \\ln U_1} \\sin(2 \\pi U_2)\n$$\n这两个变量构成一个随机向量 $\\mathbf{Z} = \\begin{bmatrix} Z_1 \\\\ Z_2 \\end{bmatrix}$，它服从标准二元正态分布 $\\mathbf{Z} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I}_2)$。此过程足以生成测试 $\\mathbf{T1}$ 和 $\\mathbf{T2}$ 所需的样本，因为在这些测试中目标分布确实是 $\\mathcal{N}(\\mathbf{0}, \\mathbf{I}_2)$。\n\n其次，我们开发从一般二元正态分布 $\\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$ 生成样本的方法，这对于测试 $\\mathbf{T3}$ 和 $\\mathbf{T4}$ 是必需的。这是通过对第一步中生成的标准正态向量 $\\mathbf{Z}$ 应用仿射变换来实现的。设期望的随机向量为 $\\mathbf{X}$。我们寻求一个形式为 $\\mathbf{X} = \\mathbf{A}\\mathbf{Z} + \\mathbf{b}$ 的变换，其中 $\\mathbf{A}$ 是某个矩阵，$\\mathbf{b}$ 是某个向量。$\\mathbf{X}$ 的期望是 $E[\\mathbf{X}] = E[\\mathbf{A}\\mathbf{Z} + \\mathbf{b}] = \\mathbf{A}E[\\mathbf{Z}] + \\mathbf{b}$。由于 $E[\\mathbf{Z}] = \\mathbf{0}$，这简化为 $E[\\mathbf{X}] = \\mathbf{b}$。为了匹配目标均值 $\\boldsymbol{\\mu}$，我们必须设置 $\\mathbf{b} = \\boldsymbol{\\mu}$。$\\mathbf{X}$ 的协方差矩阵由下式给出：\n$$\n\\text{Cov}(\\mathbf{X}) = E\\left[ (\\mathbf{X}-\\boldsymbol{\\mu})(\\mathbf{X}-\\boldsymbol{\\mu})^{\\top} \\right] = E\\left[ (\\mathbf{A}\\mathbf{Z})(\\mathbf{A}\\mathbf{Z})^{\\top} \\right] = E\\left[ \\mathbf{A}\\mathbf{Z}\\mathbf{Z}^{\\top}\\mathbf{A}^{\\top} \\right] = \\mathbf{A} E[\\mathbf{Z}\\mathbf{Z}^{\\top}] \\mathbf{A}^{\\top}\n$$\n矩阵 $E[\\mathbf{Z}\\mathbf{Z}^{\\top}]$ 是 $\\mathbf{Z}$ 的协方差矩阵，即单位矩阵 $\\mathbf{I}_2$。因此，$\\text{Cov}(\\mathbf{X}) = \\mathbf{A}\\mathbf{A}^{\\top}$。为了匹配目标协方差矩阵 $\\boldsymbol{\\Sigma}$，我们必须找到一个矩阵 $\\mathbf{A}$ 使得 $\\mathbf{A}\\mathbf{A}^{\\top} = \\boldsymbol{\\Sigma}$。由于问题指定 $\\boldsymbol{\\Sigma}$ 是一个对称正定矩阵，可以使用Cholesky分解找到 $\\mathbf{A}$ 的一个解。$\\boldsymbol{\\Sigma}$ 的Cholesky分解产生一个唯一的下三角矩阵 $\\mathbf{L}$，其对角线元素为正，使得 $\\boldsymbol{\\Sigma} = \\mathbf{L}\\mathbf{L}^{\\top}$。我们选择 $\\mathbf{A} = \\mathbf{L}$。\n因此，完整的变换是：\n$$\n\\mathbf{X} = \\mathbf{L}\\mathbf{Z} + \\boldsymbol{\\mu}\n$$\n其中 $\\mathbf{Z} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I}_2)$ 且 $\\mathbf{L}$ 是 $\\boldsymbol{\\Sigma}$ 的Cholesky因子。要为一个给定的测试生成 $N$ 个样本 $\\mathbf{X}_i$，我们首先使用Box-Muller变换生成 $N$ 个独立的向量 $\\mathbf{Z}_i$，然后对每个向量应用仿射变换。\n\n第三，按照规定实施验证程序。对于每个测试，在生成大小为 $N$ 的样本 $\\{\\mathbf{X}_1, \\dots, \\mathbf{X}_N\\}$ 后，经验均值向量 $\\hat{\\boldsymbol{\\mu}}$ 被计算为样本的算术平均值。然后通过减去这个经验均值来对数据进行中心化。设中心化后的数据矩阵为 $\\mathbf{D}_{\\text{cent}}$，大小为 $N \\times 2$，其中每行是 $(\\mathbf{X}_i - \\hat{\\boldsymbol{\\mu}})^T$。然后使用矩阵乘法高效地计算经验协方差矩阵 $\\hat{\\boldsymbol{\\Sigma}}$，这等同于所提供的求和公式：\n$$\n\\hat{\\boldsymbol{\\Sigma}} = \\frac{1}{N} \\mathbf{D}_{\\text{cent}}^{\\top} \\mathbf{D}_{\\text{cent}}\n$$\n最后，计算元素级的最大绝对误差 $e_{\\mu} = \\max_{j} |\\hat{\\mu}_j - \\mu_j|$ 和 $e_{\\Sigma} = \\max_{j,k} |\\hat{\\Sigma}_{jk} - \\Sigma_{jk}|$，并与指定的容差 $\\varepsilon_{\\mu}$ 和 $\\varepsilon_{\\Sigma}$ 进行比较，以确定测试是否通过。对四个测试用例中的每一个都执行整个过程，并使用固定的随机种子 $s=123456789$ 以保证可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of generating and validating non-uniform random variables.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T1: independent, large sample\n        {\n            \"name\": \"T1\",\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"N\": 200000,\n            \"eps_mu\": 0.02,\n            \"eps_Sigma\": 0.02,\n        },\n        # T2: independent, small sample\n        {\n            \"name\": \"T2\",\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"N\": 100,\n            \"eps_mu\": 0.30,\n            \"eps_Sigma\": 0.30,\n        },\n        # T3: correlated, general case\n        {\n            \"name\": \"T3\",\n            \"mu\": np.array([1.5, -0.5]),\n            \"Sigma\": np.array([[4.0, 1.2], [1.2, 1.0]]),\n            \"N\": 300000,\n            \"eps_mu\": 0.03,\n            \"eps_Sigma\": 0.03,\n        },\n        # T4: correlated, near-boundary correlation\n        {\n            \"name\": \"T4\",\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma\": np.array([[1.0, -0.95], [-0.95, 1.0]]),\n            \"N\": 300000,\n            \"eps_mu\": 0.03,\n            \"eps_Sigma\": 0.04,\n        },\n    ]\n\n    # Initialize the random number generator with the specified seed for reproducibility.\n    seed = 123456789\n    rng = np.random.default_rng(seed)\n\n    results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        mu_target = case[\"mu\"]\n        Sigma_target = case[\"Sigma\"]\n        eps_mu = case[\"eps_mu\"]\n        eps_Sigma = case[\"eps_Sigma\"]\n\n        # Step 1: Generate uniform random numbers in (0, 1).\n        # We need N pairs of uniform numbers for the Box-Muller transform.\n        # To strictly be in (0, 1), we can use np.nextafter, but for practical purposes\n        # rng.uniform is sufficient as P(U=0)=0.\n        u = rng.uniform(low=np.nextafter(0, 1), high=1, size=(N, 2))\n        U1 = u[:, 0]\n        U2 = u[:, 1]\n        \n        # Step 2: Apply Box-Muller transform to get standard normal variates.\n        R = np.sqrt(-2.0 * np.log(U1))\n        theta = 2.0 * np.pi * U2\n        \n        Z1 = R * np.cos(theta)\n        Z2 = R * np.sin(theta)\n        \n        # Z is an (N, 2) matrix of standard normal samples.\n        Z = np.vstack([Z1, Z2]).T\n\n        # Step 3: Transform standard normal samples to the target distribution.\n        # X = L @ Z.T + mu, where L is the Cholesky factor of Sigma.\n        if np.array_equal(Sigma_target, np.eye(2)):\n            # For the standard normal case, L is the identity matrix.\n            L = np.eye(2)\n        else:\n            # For the general case, compute the Cholesky decomposition.\n            L = np.linalg.cholesky(Sigma_target)\n\n        # Apply the affine transformation.\n        # Z.T is (2, N). L @ Z.T is (2, N). Transpose to get (N, 2).\n        # Add mu (broadcasts over rows).\n        X = (L @ Z.T).T + mu_target\n\n        # Step 4: Validate the generated samples.\n        # Compute empirical mean.\n        mu_hat = np.mean(X, axis=0)\n\n        # Compute empirical covariance with population normalization (ddof=0).\n        # np.cov calculates this directly. rowvar=False treats columns as variables.\n        Sigma_hat = np.cov(X, rowvar=False, ddof=0)\n        \n        # Compute errors.\n        e_mu = np.max(np.abs(mu_hat - mu_target))\n        e_Sigma = np.max(np.abs(Sigma_hat - Sigma_target))\n        \n        # Check against tolerances.\n        test_passed = (e_mu  eps_mu) and (e_Sigma  eps_Sigma)\n        results.append(test_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2398116"}, {"introduction": "现在我们回到逆变换采样法，但处理一个更普遍的情形：CDF的逆函数没有简单的封闭解析式。这个练习旨在解决从一个由任意非负多项式定义的分布中采样的问题。虽然我们可以通过对多项式积分来解析地计算其CDF，但求逆过程需要依赖数值求根算法。这项实践连接了理论采样方法与实际编程实现，展示了如何将统计原理与稳健的数值技术相结合，构建一个高度通用的随机数生成器，并证明了即便没有解析逆函数，逆变换法依然适用。[@problem_id:2398130]", "problem": "给定一个定义在有限区间 $[a,b]$ 上的非负多项式 $P(x) = \\sum_{i=0}^{N} c_i x^i$，其中 $N$ 是一个非负整数，并且对于所有 $i \\in \\{0,1,\\dots,N\\}$，$c_i \\in \\mathbb{R}$。假设对于所有 $x \\in [a,b]$，都有 $P(x) \\ge 0$，并且 $\\int_a^b P(x)\\,dx  0$。将区间 $[a,b]$ 上的归一化概率密度函数 $p(x)$ 定义为\n$$\np(x) = \\frac{P(x)}{Z}, \\quad \\text{其中 } Z = \\int_a^b P(x)\\,dx.\n$$\n设 $p(x)$ 的累积分布函数 (CDF) $F(x)$ 为\n$$\nF(x) = \\int_a^x p(t)\\,dt, \\quad x \\in [a,b].\n$$\n您的任务是实现一个程序，该程序为下述的每个测试用例，在 $[a,b]$ 上生成服从 $p(x)$ 分布的独立随机变量，然后通过将生成的样本与从 $P(x)$ 推导出的精确分布进行比较来评估定量诊断指标。\n\n对于每个测试用例，您必须：\n- 使用提供的多项式系数 $\\{c_i\\}_{i=0}^N$、区间端点 $a$ 和 $b$、样本量 $n$ 以及随机种子 $s$。\n- 在 $[a,b]$ 上生成 $n$ 个密度为 $p(x)$ 的独立样本。\n- 计算精确的归一化常数 $Z = \\int_a^b P(x)\\,dx$。\n- 通过以下公式计算在 $p(x)$ 分布下的精确矩 $\\mathbb{E}[X]$ 和 $\\mathbb{E}[X^2]$：\n$$\n\\mathbb{E}[X^m] = \\frac{\\int_a^b x^m P(x)\\,dx}{\\int_a^b P(x)\\,dx}, \\quad \\text{对于 } m \\in \\{1,2\\}.\n$$\n- 从生成的样本中计算经验均值和经验二阶矩（即样本中 $X^2$ 的平均值）。\n- 为每个测试用例报告三个实数：\n  1) 样本均值相对于精确 $\\mathbb{E}[X]$ 的绝对误差，\n  2) 样本二阶矩相对于精确 $\\mathbb{E}[X^2]$ 的绝对误差，\n  3) Kolmogorov–Smirnov 统计量 $D_n = \\sup_{x \\in \\mathbb{R}} |F_n(x) - F(x)|$，其中 $F_n$ 是基于 $n$ 个样本的经验累积分布函数，$F$ 是由 $P(x)$ 在 $[a,b]$ 上导出的精确 CDF，并对于 $x  a$ 扩展为 0，对于 $x  b$ 扩展为 1。\n\n测试套件：\n- 案例 $1$：$N = 0$，系数 $[c_0] = [1.0]$，区间 $[0.0, 1.0]$，样本量 $n = 20000$，种子 $s = 12345$。\n- 案例 $2$：$N = 1$，系数 $[c_0,c_1] = [0.0, 1.0]$，区间 $[0.0, 1.0]$，样本量 $n = 30000$，种子 $s = 2024$。\n- 案例 $3$：$N = 2$，系数 $[c_0,c_1,c_2] = [0.35, -1.0, 1.0]$，区间 $[0.0, 1.0]$，样本量 $n = 40000$，种子 $s = 424242$。\n- 案例 $4$：$N = 2$，系数 $[c_0,c_1,c_2] = [2.0, 1.0, -1.0]$，区间 $[-1.0, 2.0]$，样本量 $n = 50000$，种子 $s = 731$。\n\n最终输出格式：\n- 您的程序必须产生单行输出，其中包含所有按顺序汇总的结果，形式为用方括号括起来的逗号分隔列表。\n- 顺序必须是，从案例 1 到案例 4：$[\\Delta \\mu_1, \\Delta m_{2,1}, D_{n,1}, \\Delta \\mu_2, \\Delta m_{2,2}, D_{n,2}, \\Delta \\mu_3, \\Delta m_{2,3}, D_{n,3}, \\Delta \\mu_4, \\Delta m_{2,4}, D_{n,4}]$，其中 $\\Delta \\mu_k$ 是案例 $k$ 中样本均值的绝对误差，$\\Delta m_{2,k}$ 是案例 $k$ 中样本二阶矩的绝对误差，$D_{n,k}$ 是案例 $k$ 的 Kolmogorov–Smirnov 统计量。\n- 输出中的每个实数必须四舍五入到恰好 6 位小数。\n- 例如，格式类似于 [`r_1`, `r_2`, ..., `r_12`]，其中每个 `r_j` 都是一个打印为恰好 6 位小数的实数。", "solution": "问题陈述已经过验证，并被认为是可接受的。它具有科学依据、是适定的，并包含推导出唯一且可验证的解所需的所有必要信息。该问题属于计算物理学的标准范畴，涉及非均匀随机变量的生成。每个测试用例的前提——具体而言，即多项式 $P(x)$ 在指定区间 $[a,b]$ 上的非负性——已经过验证并且成立。\n\n解法基于概率论和数值方法的基本原理，系统地进行。\n\n首先，我们将与给定区间 $[a,b]$ 上的多项式 $P(x) = \\sum_{i=0}^{N} c_i x^i$ 相关联的概率分布形式化。未归一化的密度是 $P(x)$。要创建一个有效的概率密度函数 (PDF) $p(x)$，我们必须用 $P(x)$ 在其定义域上的积分来对其进行归一化。归一化常数 $Z$ 由下式给出：\n$$\nZ = \\int_a^b P(x) \\,dx\n$$\n由于 $P(x)$ 是一个多项式，其不定积分（我们记作 $Q(x) = \\int P(x) \\,dx$）也是一个多项式。具体来说，\n$$\nQ(x) = \\sum_{i=0}^{N} c_i \\frac{x^{i+1}}{i+1}\n$$\n根据微积分基本定理，归一化常数就是 $Z = Q(b) - Q(a)$。于是，PDF 被正确地定义为：当 $x \\in [a,b]$ 时，$p(x) = P(x) / Z$；否则，$p(x) = 0$。\n\n累积分布函数 (CDF) $F(x)$ 是 PDF 从区间下界到 $x$ 的积分：\n$$\nF(x) = \\int_a^x p(t) \\,dt = \\frac{1}{Z} \\int_a^x P(t) \\,dt = \\frac{Q(x) - Q(a)}{Z}\n$$\n该函数 $F(x)$ 将区间 $[a,b]$ 映射到 $[0,1]$，并且是单调不减的。\n\n其次，我们处理从 $p(x)$ 分布生成随机变量的问题。当 CDF 已知时，完成此任务最直接且高效的方法是逆变换采样法。该方法指出，如果 $U$ 是一个从 $[0,1]$ 上的均匀分布中抽取的随机变量，那么随机变量 $X = F^{-1}(U)$ 将服从 PDF 为 $p(x)$、CDF 为 $F(x)$ 的分布。为了生成一个样本，我们首先从 $\\mathcal{U}(0,1)$ 中抽取一个值 $u$，然后就 $x$ 求解方程 $F(x) = u$。这等价于求解多项式方程：\n$$\n\\frac{Q(x) - Q(a)}{Z} = u \\implies Q(x) - (Z u + Q(a)) = 0\n$$\n对于问题中指定的多项式次数（$N \\le 2$），$Q(x)$ 的次数至多为 3。虽然三次方程存在解析解，但数值方法更为鲁棒和通用。由于 $F(x)$ 是一个单调函数，对于任何 $u \\in [0,1]$，方程 $F(x) - u = 0$ 在 $[a,b]$ 上都存在一个唯一的根 $x$。这个根可以使用数值求根算法（例如 Brent's method）可靠地找到。只要根被限定在如这里的 $[a,b]$ 区间内，该方法就能保证收敛。\n\n第三，我们计算分布的精确矩以进行比较。分布的 m 阶矩 $\\mathbb{E}[X^m]$ 定义为：\n$$\n\\mathbb{E}[X^m] = \\int_a^b x^m p(x) \\,dx = \\frac{1}{Z} \\int_a^b x^m P(x) \\,dx\n$$\n被积函数 $x^m P(x)$ 是另一个多项式，因此其定积分可以被精确计算，而没有数值误差。\n$$\n\\int_a^b x^m P(x) \\,dx = \\int_a^b \\left( \\sum_{i=0}^{N} c_i x^{i+m} \\right) \\,dx = \\sum_{i=0}^{N} c_i \\left[ \\frac{x^{i+m+1}}{i+m+1} \\right]_a^b\n$$\n这使得理论均值 $\\mathbb{E}[X]$（对于 $m=1$）和二阶矩 $\\mathbb{E}[X^2]$（对于 $m=2$）的精确计算成为可能。\n\n最后，我们评估生成的样本集 $\\{x_j\\}_{j=1}^n$ 的质量。经验均值 $\\hat{\\mu}$ 和经验二阶矩 $\\hat{m}_2$ 计算如下：\n$$\n\\hat{\\mu} = \\frac{1}{n} \\sum_{j=1}^n x_j \\quad \\text{和} \\quad \\hat{m}_2 = \\frac{1}{n} \\sum_{j=1}^n x_j^2\n$$\n绝对误差 $|\\hat{\\mu} - \\mathbb{E}[X]|$ 和 $|\\hat{m}_2 - \\mathbb{E}[X^2]|$ 量化了样本矩与其理论值之间的偏差。此外，Kolmogorov-Smirnov (KS) 统计量 $D_n$ 用于衡量整体的拟合优度。它被定义为经验 CDF $F_n(x)$ 和理论 CDF $F(x)$ 在整个实数轴上的最大绝对差：\n$$\nD_n = \\sup_{x \\in \\mathbb{R}} |F_n(x) - F(x)|\n$$\n这里，$F_n(x) = \\frac{1}{n}\\sum_{j=1}^{n}\\mathbb{I}(x_j \\le x)$，其中 $\\mathbb{I}$ 是指示函数。KS 统计量为随机数生成过程的质量提供了一个鲁棒的度量。\n\n该实现将对每个测试用例精确地遵循这些步骤，并使用所提供的参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It generates samples from polynomial-based probability distributions,\n    calculates exact and empirical statistics, and reports the errors.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 0, 'coeffs': [1.0], 'interval': [0.0, 1.0], 'n': 20000, 's': 12345},\n        {'N': 1, 'coeffs': [0.0, 1.0], 'interval': [0.0, 1.0], 'n': 30000, 's': 2024},\n        {'N': 2, 'coeffs': [0.35, -1.0, 1.0], 'interval': [0.0, 1.0], 'n': 40000, 's': 424242},\n        {'N': 2, 'coeffs': [2.0, 1.0, -1.0], 'interval': [-1.0, 2.0], 'n': 50000, 's': 731}\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Note: coeffs are [c0, c1, ..., cN]. numpy.poly1d wants [cN, ..., c0].\n        coeffs = np.array(case['coeffs'])\n        a, b = case['interval']\n        n = case['n']\n        seed = case['s']\n\n        # 1. Theoretical Calculations\n        # Represent the polynomial P(x)\n        P_poly = np.poly1d(coeffs[::-1])\n        \n        # Q(x) is the indefinite integral of P(x)\n        Q_poly = P_poly.integ()\n        \n        # Z is the normalization constant\n        Z = Q_poly(b) - Q_poly(a)\n        \n        # Calculate theoretical moments E[X^m] = (1/Z) * integral(x^m * P(x) dx)\n        # The integrand for E[X^m] is x^m * P(x)\n        P_moment1 = np.poly1d([1.0, 0.0]) * P_poly  # This is x * P(x)\n        Q_moment1 = P_moment1.integ()\n        exact_mean = (Q_moment1(b) - Q_moment1(a)) / Z\n        \n        P_moment2 = np.poly1d([1.0, 0.0, 0.0]) * P_poly # This is x^2 * P(x)\n        Q_moment2 = P_moment2.integ()\n        exact_mean_sq = (Q_moment2(b) - Q_moment2(a)) / Z\n        \n        # Define the theoretical CDF, F(x)\n        def cdf(x):\n            # Handle array inputs for kstest\n            x = np.asarray(x)\n            # Clip x to the interval [a, b] for calculation, assuming 0 before a and 1 after b\n            vals = np.clip(x, a, b)\n            f_vals = (Q_poly(vals) - Q_poly(a)) / Z\n            # Apply boundary conditions of a CDF\n            f_vals[x  a] = 0.0\n            f_vals[x  b] = 1.0\n            return f_vals\n\n        # 2. Sample Generation\n        rng = np.random.default_rng(seed)\n        uniform_samples = rng.random(size=n)\n        \n        # Function to find root of: F(x) - u = 0\n        def root_fn(x, u):\n            return (Q_poly(x) - Q_poly(a)) / Z - u\n        \n        # Generate samples using inverse transform sampling with a numerical root finder\n        samples = np.zeros(n)\n        for i in range(n):\n            u = uniform_samples[i]\n            # Brent's method is robust for finding the unique root in [a,b]\n            samples[i] = brentq(root_fn, a, b, args=(u,))\n        \n        # 3. Empirical Diagnostics\n        sample_mean = np.mean(samples)\n        sample_mean_sq = np.mean(samples**2)\n        \n        mean_abs_error = abs(sample_mean - exact_mean)\n        mean_sq_abs_error = abs(sample_mean_sq - exact_mean_sq)\n        \n        # Kolmogorov-Smirnov test\n        ks_result = stats.kstest(samples, cdf)\n        ks_stat = ks_result.statistic\n        \n        # 4. Store the results for this case\n        all_results.extend([mean_abs_error, mean_sq_abs_error, ks_stat])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2398130"}]}