{"hands_on_practices": [{"introduction": "计算复杂三维形状的体积对于传统积分方法而言可能是一个艰巨的任务。蒙特卡洛“击中或错过”法为此提供了一种优雅而强大的替代方案。其核心思想是将复杂形状置于一个体积已知的简单边界框（如立方体）内，然后向该框内随机“投掷飞镖”，最终落在形状内部的飞镖数量与总投掷数量之比，便为我们提供了形状体积与边界框体积之比的估计值。本练习 [@problem_id:2414597] 将引导你从第一性原理推导此方法，并在实践中编写代码实现，从而掌握这项基本技术。", "problem": "考虑使用蒙特卡洛（MC）积分法来估计三维空间中凸包体积的问题。设 $d=3$。设 $\\mathcal{P}=\\{\\mathbf{p}_i\\}_{i=1}^n \\subset [0,1]^3$ 为一个有限点集，并用 $\\mathrm{conv}(\\mathcal{P})$ 表示其凸包。目标是估计体积 $V(\\mathrm{conv}(\\mathcal{P}))$。整个过程完全使用纯数学术语，不涉及物理单位。所有可能出现的角度都必须以弧度为单位，但此处并未使用任何角度。\n\n从以下基本原理出发：对于任意可测集 $S \\subseteq [0,1]^3$，其体积为积分 $V(S)=\\int_{[0,1]^3} \\mathbf{1}_S(\\mathbf{x})\\,\\mathrm{d}\\mathbf{x}$，其中 $\\mathbf{1}_S$ 是集合 $S$ 的指示函数。该恒等式将 Lebesgue 测度与在 $[0,1]^3$ 上均匀分布的期望联系起来。\n\n任务：\n- 基于上述基本原理和蒙特卡洛（MC）积分的第一性原理，推导一个用于估计 $V(\\mathrm{conv}(\\mathcal{P}))$ 的估计量。该估计量使用 $N$ 个从 $[0,1]^3$ 中均匀抽取的独立同分布样本 $\\{\\mathbf{X}_k\\}_{k=1}^N$，以及一个以半空间形式表示的用于判断点是否在 $\\mathrm{conv}(\\mathcal{P})$ 内的谓词。明确陈述保证无偏性的假设，并将方差推导为 $N$ 和 $V(\\mathrm{conv}(\\mathcal{P}))$ 的函数。在此推导过程中不得使用任何快捷公式。\n- 实现一个完整的、可运行的程序，对每个测试用例执行以下操作：\n  - 通过在 $[0,1]^3$ 中使用指定的随机种子进行均匀采样，或使用单位立方体的8个顶点来构建 $\\mathcal{P}$。\n  - 使用一个稳健的凸包计算程序来计算 $\\mathrm{conv}(\\mathcal{P})$ 的半空间表示。\n  - 在 $[0,1]^3$ 中使用指定的随机种子生成 $N$ 个独立同分布的均匀样本，评估指示函数以判断样本点是否属于 $\\mathrm{conv}(\\mathcal{P})$，并计算体积的蒙特卡洛估计值。\n  - 对每个测试用例，返回一个四舍五入到6位小数的浮点数作为估计值。\n\n测试套件：\n- 用例1（理想路径，大 $N$ 值）：$\\mathcal{P}$ 是在 $[0,1]^3$ 中使用种子 $s_p=2025$ 均匀采样的 $n=100$ 个点。使用 $N=100000$ 个蒙特卡洛样本，种子为 $s_m=314159$。\n- 用例2（方差压力测试，小 $N$ 值）：$\\mathcal{P}$ 与用例1相同。使用 $N=5000$ 个蒙特卡洛样本，种子为 $s_m=271828$。\n- 用例3（不同点云，大 $N$ 值）：$\\mathcal{P}$ 是在 $[0,1]^3$ 中使用种子 $s_p=42$ 均匀采样的 $n=100$ 个点。使用 $N=100000$ 个蒙特卡洛样本，种子为 $s_m=123456$。\n- 用例4（边界覆盖，完整立方体）：$\\mathcal{P}$ 为 $[0,1]^3$ 中单位立方体的8个顶点。使用 $N=200000$ 个蒙特卡洛样本，种子为 $s_m=13579$。\n\n答案规格与输出格式：\n- 对每个用例，输出 $V(\\mathrm{conv}(\\mathcal{P}))$ 的蒙特卡洛估计值，格式为浮点数，四舍五入到6位小数。\n- 将用例1到4的结果按顺序汇总到单行输出中，形式为一个用方括号括起来的逗号分隔列表，不含空格，例如 `[x1,x2,x3,x4]`，其中每个 $x_i$ 是一个四舍五入到6位小数的浮点数。", "solution": "问题陈述已经过分析，并被认为是有效的。该问题是自洽、良定的，并且在科学上基于蒙特卡洛方法和计算几何的既定原理。它提出了一个清晰、客观的任务，可以通过严谨的数学推导和计算实现来解决。我们现在开始进行解答。\n\n问题的核心是估计凸集 $S = \\mathrm{conv}(\\mathcal{P})$ 的体积，其中 $S$ 是单位立方体 $[0,1]^3$ 的一个子集。体积 $V(S)$ 由指示函数 $\\mathbf{1}_S(\\mathbf{x})$ 在单位立方体上的 Lebesgue 积分定义：\n$$V(S) = \\int_{[0,1]^3} \\mathbf{1}_S(\\mathbf{x})\\,\\mathrm{d}\\mathbf{x}$$\n其中，如果 $\\mathbf{x} \\in S$，则 $\\mathbf{1}_S(\\mathbf{x}) = 1$；如果 $\\mathbf{x} \\notin S$，则 $\\mathbf{1}_S(\\mathbf{x}) = 0$。\n\n这个积分可以被解释为函数 $g(\\mathbf{X}) = \\mathbf{1}_S(\\mathbf{X})$ 的期望，其中 $\\mathbf{X}$ 是一个从 $[0,1]^3$ 上的均匀分布中抽取的随机变量。该分布的概率密度函数 (PDF) 为：当 $\\mathbf{x} \\in [0,1]^3$ 时，$f(\\mathbf{x}) = 1$；否则 $f(\\mathbf{x}) = 0$。因此，期望为：\n$$E[\\mathbf{1}_S(\\mathbf{X})] = \\int_{[0,1]^3} \\mathbf{1}_S(\\mathbf{x}) f(\\mathbf{x}) \\,\\mathrm{d}\\mathbf{x} = \\int_{[0,1]^3} \\mathbf{1}_S(\\mathbf{x}) \\cdot 1 \\,\\mathrm{d}\\mathbf{x} = V(S)$$\n这个恒等式是解决此问题的蒙特卡洛方法的基础。\n\n根据大数定律，一个随机变量的期望可以通过大量独立同分布 (i.i.d.) 样本的样本均值来近似。设 $\\{\\mathbf{X}_k\\}_{k=1}^N$ 为从 $[0,1]^3$ 中均匀抽取的 $N$ 个此类样本。随机变量 $\\mathbf{1}_S(\\mathbf{X})$ 的样本均值提供了体积 $V(S)$ 的一个估计量 $\\hat{V}_N$：\n$$\\hat{V}_N = \\frac{1}{N} \\sum_{k=1}^N \\mathbf{1}_S(\\mathbf{X}_k)$$\n这个估计量被称为“命中或脱靶”蒙特卡洛估计量。它表示落在集合 $S$ 内部的随机点的比例，再乘以采样域的体积（在本例中为1）。\n\n我们必须分析这个估计量的统计特性，特别是其偏差和方差。\n\n如果估计量 $\\hat{V}_N$ 的期望值等于真实体积，即 $E[\\hat{V}_N] = V(S)$，那么该估计量就是无偏的。我们利用期望的线性性质来验证这一点：\n$$E[\\hat{V}_N] = E\\left[\\frac{1}{N} \\sum_{k=1}^N \\mathbf{1}_S(\\mathbf{X}_k)\\right] = \\frac{1}{N} \\sum_{k=1}^N E[\\mathbf{1}_S(\\mathbf{X}_k)]$$\n假设是样本 $\\{\\mathbf{X}_k\\}$ 是同分布的。因此，$E[\\mathbf{1}_S(\\mathbf{X}_k)]$ 对所有 $k$ 都是一个常数，且等于 $E[\\mathbf{1}_S(\\mathbf{X})] = V(S)$。将此代入方程得到：\n$$E[\\hat{V}_N] = \\frac{1}{N} \\sum_{k=1}^N V(S) = \\frac{1}{N} \\cdot N \\cdot V(S) = V(S)$$\n该估计量确实是无偏的。此性质的关键假设是样本是从 $[0,1]^3$ 上的正确均匀分布中抽取的。\n\n接下来，我们推导估计量的方差 $\\mathrm{Var}(\\hat{V}_N)$。估计量的方差量化了其与均值的期望平方偏差，是衡量估计量精度的一个指标。样本 $\\{\\mathbf{X}_k\\}$ 是独立的这一假设让我们能够断言，和的方差等于方差的和：\n$$\\mathrm{Var}(\\hat{V}_N) = \\mathrm{Var}\\left(\\frac{1}{N} \\sum_{k=1}^N \\mathbf{1}_S(\\mathbf{X}_k)\\right) = \\frac{1}{N^2} \\sum_{k=1}^N \\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X}_k))$$\n因为样本是同分布的，所以方差项 $\\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X}_k))$ 对所有 $k$ 都是常数。设其为 $\\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X}))$。该表达式简化为：\n$$\\mathrm{Var}(\\hat{V}_N) = \\frac{1}{N^2} \\cdot N \\cdot \\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X})) = \\frac{1}{N} \\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X}))$$\n随机变量 $Y = \\mathbf{1}_S(\\mathbf{X})$ 是一个伯努利变量，因为它只取两个值：1（“命中”）或 0（“脱靶”）。命中的概率是 $p = P(Y=1) = P(\\mathbf{X} \\in S)$。如前所述，这个概率等于体积 $V(S)$。参数为 $p$ 的伯努利变量的方差由 $p(1-p)$ 给出。因此：\n$$\\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X})) = V(S)(1 - V(S))$$\n将此结果代入估计量方差的方程，我们得到最终表达式：\n$$\\mathrm{Var}(\\hat{V}_N) = \\frac{V(S)(1 - V(S))}{N}$$\n这个结果表明，蒙特卡洛估计的方差与样本数 $N$ 成反比。因此，标准误差 $\\sigma_{\\hat{V}_N} = \\sqrt{\\mathrm{Var}(\\hat{V}_N)}$ 与 $1/\\sqrt{N}$ 成正比，这是标准蒙特卡洛积分的特征收敛速率。当 $V(S) = 0.5$ 时方差最大，当体积接近0或1时方差减小。\n\n为实现此方法，需要一个点在多面体内的测试。一个凸多面体，例如 $\\mathrm{conv}(\\mathcal{P})$，可以表示为有限个半空间的交集。每个半空间由形如 $\\mathbf{a}_j \\cdot \\mathbf{x} + b_j \\le 0$ 的不等式定义，其中 $\\mathbf{a}_j$ 是第 $j$ 个刻面平面的法向量，$b_j$ 是偏移量。一个点 $\\mathbf{x}$ 位于凸包内部，当且仅当它同时满足所有这些不等式。这为评估每个样本点 $\\mathbf{X}_k$ 的 $\\mathbf{1}_S(\\mathbf{X}_k)$ 提供了一个直接的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import ConvexHull\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the Monte Carlo volume estimation problem for the given test cases.\n    \"\"\"\n\n    def estimate_volume(hull, N, seed_m):\n        \"\"\"\n        Estimates the volume of a convex hull using Monte Carlo integration.\n        \n        Args:\n            hull (scipy.spatial.ConvexHull): The convex hull object.\n            N (int): The number of Monte Carlo samples.\n            seed_m (int): The random seed for Monte Carlo samples.\n\n        Returns:\n            float: The estimated volume.\n        \"\"\"\n        # Generate N samples uniformly from the [0,1]^3 cube\n        rng_mc = np.random.default_rng(seed_m)\n        mc_samples = rng_mc.random((N, 3))\n\n        # The hull is defined by a set of half-spaces Ax + b <= 0.\n        # A is hull.equations[:, :3] and b is hull.equations[:, 3].\n        # The normals in hull.equations point outwards from the hull.\n        A = hull.equations[:, :3]\n        b = hull.equations[:, 3]\n\n        # For each sample point, evaluate all plane equations.\n        # A point is inside if it satisfies all inequalities.\n        # Use a small tolerance for floating point comparisons.\n        is_inside = np.all(mc_samples @ A.T + b <= 1e-12, axis=1)\n        \n        # The number of \"hits\" is the sum of boolean `is_inside` array.\n        hits = np.sum(is_inside)\n\n        # The volume estimate is the ratio of hits to total samples,\n        # since the bounding box volume is 1.\n        volume_estimate = hits / N\n        \n        return volume_estimate\n\n    test_cases = [\n        # (n, s_p, N, s_m, use_cube_vertices)\n        (100, 2025, 100000, 314159, False),\n        (100, 2025, 5000, 271828, False),\n        (100, 42, 100000, 123456, False),\n        (8, None, 200000, 13579, True),\n    ]\n\n    results = []\n    \n    # Pre-compute hull for cases 1 and 2 as they share the same point cloud\n    rng_points_c12 = np.random.default_rng(2025)\n    points_c12 = rng_points_c12.random((100, 3))\n    hull_c12 = ConvexHull(points_c12)\n\n    # Case 1\n    n1, s_p1, N1, s_m1, _ = test_cases[0]\n    vol1 = estimate_volume(hull_c12, N1, s_m1)\n    results.append(round(vol1, 6))\n\n    # Case 2\n    n2, s_p2, N2, s_m2, _ = test_cases[1]\n    vol2 = estimate_volume(hull_c12, N2, s_m2)\n    results.append(round(vol2, 6))\n\n    # Case 3\n    n3, s_p3, N3, s_m3, _ = test_cases[2]\n    rng_points_c3 = np.random.default_rng(s_p3)\n    points_c3 = rng_points_c3.random((n3, 3))\n    hull_c3 = ConvexHull(points_c3)\n    vol3 = estimate_volume(hull_c3, N3, s_m3)\n    results.append(round(vol3, 6))\n\n    # Case 4\n    n4, s_p4, N4, s_m4, use_cube = test_cases[3]\n    # Generate the 8 vertices of the unit cube\n    points_c4 = np.array(list(itertools.product([0, 1], repeat=3)), dtype=float)\n    hull_c4 = ConvexHull(points_c4)\n    vol4 = estimate_volume(hull_c4, N4, s_m4)\n    results.append(round(vol4, 6))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2414597"}, {"introduction": "蒙特卡洛方法的应用远不止于几何估计，它可以推广到更广泛的概率系统中。许多现实世界中的工程和物理问题，其结果依赖于多个随机变量的综合影响。本练习 [@problem_id:2414629] 模拟了一个制造业场景，其中零件的尺寸是随机变化的，我们的目标是估算整个流程的“合格率”，即一个随机零件能成功装配的概率。通过这个实践，你将学习如何通过多次模拟系统并计算成功结果的比例，来有效地估算一个成功指示函数的期望值，从而解决这类多变量概率问题。", "problem": "一个矩形制造零件必须能装入一个矩形夹具中。该零件具有随机的宽度和高度，夹具也具有随机的槽宽和槽高。所有尺寸均以毫米（mm）为单位。当且仅当零件的宽度小于或等于槽宽，并且零件的高度小于或等于槽高时，单次试验才能成功装配。设零件宽度为随机变量 $W_{p}$，零件高度为 $H_{p}$，槽宽为 $W_{s}$，槽高为 $H_{s}$。假设 $W_{p}$ 和 $H_{p}$相互独立，$W_{s}$ 和 $H_{s}$相互独立，并且所有零件变量与所有夹具变量均相互独立。工艺合格率 (process yield) 是一个随机零件能装入一个随机夹具的概率，即事件 $\\{W_{p} \\leq W_{s} \\text{ and } H_{p} \\leq H_{s}\\}$ 的概率。\n\n请从期望的积分概率定义和指示函数的定义出发，为合格率设计一个 Monte Carlo 估计器。您必须使用这些定义来推导您的估计器。将您的估计器实现为一个完整、可运行的程序，该程序：\n- 使用伪随机抽样来估计以下每个测试用例的合格率。\n- 使用固定种子 $s=12345$ 以保证可复现性。\n- 每个测试用例使用 $N=400000$ 个独立样本。\n- 将每个合格率以小数形式（而非百分比）报告。\n- 结果打印到小数点后六位。\n\n测试套件（每个案例指定了 $(W_{p},H_{p},W_{s},H_{s})$ 的分布）：\n- 案例 A (理想情况，全为正态分布)：\n  - $W_{p} \\sim \\mathcal{N}(50.0,\\,0.1^{2})$，$H_{p} \\sim \\mathcal{N}(10.0,\\,0.05^{2})$，\n  - $W_{s} \\sim \\mathcal{N}(50.15,\\,0.08^{2})$，$H_{s} \\sim \\mathcal{N}(10.10,\\,0.04^{2})$。\n- 案例 B (边界情况，对称正态分布)：\n  - $W_{p} \\sim \\mathcal{N}(30.0,\\,0.2^{2})$，$H_{p} \\sim \\mathcal{N}(20.0,\\,0.2^{2})$，\n  - $W_{s} \\sim \\mathcal{N}(30.0,\\,0.2^{2})$，$H_{s} \\sim \\mathcal{N}(20.0,\\,0.2^{2})$。\n- 案例 C (低合格率，负平均间隙)：\n  - $W_{p} \\sim \\mathcal{N}(40.2,\\,0.1^{2})$，$H_{p} \\sim \\mathcal{N}(15.1,\\,0.1^{2})$，\n  - $W_{s} \\sim \\mathcal{N}(40.1,\\,0.1^{2})$，$H_{s} \\sim \\mathcal{N}(15.0,\\,0.1^{2})$。\n- 案例 D (均匀公差)：\n  - $W_{p} \\sim \\mathcal{U}[99.0,\\,101.0]$，$H_{p} \\sim \\mathcal{U}[49.0,\\,51.0]$，\n  - $W_{s} \\sim \\mathcal{U}[100.0,\\,102.0]$，$H_{s} \\sim \\mathcal{U}[50.0,\\,51.0]$。\n\n不涉及角度单位。所有物理单位均为毫米（mm）。您的实现不得截断或限制采样值；请使用规定的分布。\n\n最终输出格式：您的程序应生成单行输出，其中包含按 A、B、C、D 顺序排列的四个估计合格率，形式为用方括号括起来的逗号分隔列表（例如，`[result_A,result_B,result_C,result_D]`），其中每个结果都是一个四舍五入到小数点后六位的浮点数。", "solution": "问题陈述已经过验证，被认为是有效的。它在概率论和统计学方面有科学依据，定义了所有必要参数，问题明确且客观。该任务是使用 Monte Carlo 方法估计概率的一个标准应用，这是计算物理学和工程学中的一个核心课题。我们将继续提供完整的解决方案。\n\n该问题要求估计制造过程的合格率 $Y$。合格率定义为一个随机制造的零件能够装入一个随机夹具的概率。设零件尺寸为随机变量 $W_{p}$（宽度）和 $H_{p}$（高度），夹具槽尺寸为 $W_{s}$（宽度）和 $H_{s}$（高度）。当且仅当两个条件同时满足时，装配才算成功：$W_{p} \\leq W_{s}$ 且 $H_{p} \\leq H_{s}$。\n\n问题陈述指出，所有四个随机变量 $W_{p}$、$H_{p}$、$W_{s}$ 和 $H_{s}$ 都是相互独立的。设这些变量的概率密度函数 (PDF) 分别为 $p_{W_p}(w_p)$、$p_{H_p}(h_p)$、$p_{W_s}(w_s)$ 和 $p_{H_s}(h_s)$。系统的状态可以用一个4维随机向量 $\\mathbf{X} = (W_p, H_p, W_s, H_s)$ 来描述。根据独立性假设，$\\mathbf{X}$ 的联合概率密度函数是各个独立概率密度函数的乘积：\n$$p(\\mathbf{x}) = p(w_p, h_p, w_s, h_s) = p_{W_p}(w_p) p_{H_p}(h_p) p_{W_s}(w_s) p_{H_s}(h_s)$$\n其中 $\\mathbf{x} = (w_p, h_p, w_s, h_s)$ 是随机向量 $\\mathbf{X}$ 的一个特定实现。\n\n合格率 $Y$ 是成功事件的概率，我们记为 $A$。事件 $A$ 是 4 维空间 $\\mathbb{R}^4$ 中所有满足 $w_p \\leq w_s$ 且 $h_p \\leq h_s$ 的结果 $\\mathbf{x}$ 的集合。概率 $Y = P(A)$ 的正式表达式为联合概率密度函数在事件 $A$ 定义的区域上的积分：\n$$Y = \\int \\int \\int \\int_{A} p(w_p, h_p, w_s, h_s) \\, dw_p \\, dh_p \\, dw_s \\, dh_s$$\n\n为了将其转换为适合 Monte Carlo 估计的形式，我们引入一个指示函数 $\\mathbb{I}_{A}(\\mathbf{x})$。该函数定义为：\n$$\n\\mathbb{I}_{A}(\\mathbf{x}) = \n\\begin{cases} \n1 & \\text{if } w_p \\leq w_s \\text{ and } h_p \\leq h_s \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n使用指示函数，我们可以将合格率 $Y$ 的积分重写在整个状态空间 $\\Omega = \\mathbb{R}^4$ 上：\n$$Y = \\int_{\\Omega} \\mathbb{I}_{A}(\\mathbf{x}) p(\\mathbf{x}) \\, d\\mathbf{x}$$\n根据定义，这个积分是指示函数 $\\mathbb{I}_{A}(\\mathbf{X})$ 关于概率分布 $p(\\mathbf{x})$ 的期望值：\n$$Y = E[\\mathbb{I}_{A}(\\mathbf{X})]$$\n\nMonte Carlo 方法提供了一个用于估计函数 $f(\\mathbf{X})$ 期望值的估计器，其方法是通过将在从分布 $p(\\mathbf{x})$ 中抽取的 $N$ 个独立同分布 (i.i.d.) 的随机样本 $\\mathbf{x}^{(1)}, \\mathbf{x}^{(2)}, \\ldots, \\mathbf{x}^{(N)}$ 上的函数值的样本均值来近似该期望值。在我们的例子中，该函数是 $f(\\mathbf{X}) = \\mathbb{I}_{A}(\\mathbf{X})$。\n\n因此，合格率 $\\hat{Y}_N$ 的 Monte Carlo 估计器是该指示函数的样本均值：\n$$\\hat{Y}_N = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbb{I}_{A}(\\mathbf{x}^{(i)})$$\n此处，$\\mathbf{x}^{(i)} = (w_p^{(i)}, h_p^{(i)}, w_s^{(i)}, h_s^{(i)})$ 是从联合分布中抽取的第 $i$ 个随机样本。由于如果第 $i$ 个样本对应一次成功的装配，则 $\\mathbb{I}_{A}(\\mathbf{x}^{(i)})$ 为 1，否则为 0，因此和 $\\sum_{i=1}^{N} \\mathbb{I}_{A}(\\mathbf{x}^{(i)})$ 就是成功装配的总次数，我们称之为 $N_{success}$。\n\n因此，估计合格率的算法如下：\n1.  初始化一个成功计数器 $N_{success}$ 为 0。\n2.  生成 $N$ 个独立的随机样本，其中每个样本 $i \\in \\{1, \\ldots, N\\}$ 包含从其指定分布中抽取的四个值 $(w_p^{(i)}, h_p^{(i)}, w_s^{(i)}, h_s^{(i)})$。对于此问题，$N = 400000$。\n3.  对每个样本 $i$，评估装配条件：如果 $w_p^{(i)} \\leq w_s^{(i)}$ 且 $h_p^{(i)} \\leq h_s^{(i)}$，则将 $N_{success}$ 加一。\n4.  估计的合格率为 $\\hat{Y}_N = \\frac{N_{success}}{N}$。\n\n这个过程将对指定的四个测试用例中的每一个进行实现。我们将使用固定的随机种子 $s=12345$ 以保证可复现性。对于给定的分布 $\\mathcal{N}(\\mu, \\sigma^2)$，我们从均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布中抽样。对于均匀分布 $\\mathcal{U}[a, b]$，我们从区间 $[a, b)$ 上的均匀分布中抽样。该实现将使用 `numpy` 库进行向量化以提高效率，一次性为四个变量中的每一个生成 $N$ 个样本，然后进行逐元素的比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the manufacturing yield estimation problem using Monte Carlo simulation\n    for four different test cases.\n    \"\"\"\n    \n    # Define problem constants\n    SEED = 12345\n    NUM_SAMPLES = 400000\n\n    # Initialize the random number generator for reproducibility.\n    # The same generator instance is used across all test cases to ensure\n    # the entire output is reproducible from a single seed.\n    rng = np.random.default_rng(SEED)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of parameter tuples for (Wp, Hp, Ws, Hs).\n    # Each parameter tuple is (distribution_name, param1, param2).\n    # For 'norm': (mean, std_dev)\n    # For 'uniform': (low, high)\n    test_cases = [\n        # Case A (happy path, all normal)\n        (\n            ('norm', 50.0, 0.1), \n            ('norm', 10.0, 0.05),\n            ('norm', 50.15, 0.08), \n            ('norm', 10.10, 0.04)\n        ),\n        # Case B (boundary, symmetric normals)\n        (\n            ('norm', 30.0, 0.2), \n            ('norm', 20.0, 0.2), \n            ('norm', 30.0, 0.2), \n            ('norm', 20.0, 0.2)\n        ),\n        # Case C (low yield, negative mean clearance)\n        (\n            ('norm', 40.2, 0.1), \n            ('norm', 15.1, 0.1), \n            ('norm', 40.1, 0.1), \n            ('norm', 15.0, 0.1)\n        ),\n        # Case D (uniform tolerances)\n        (\n            ('uniform', 99.0, 101.0), \n            ('uniform', 49.0, 51.0), \n            ('uniform', 100.0, 102.0), \n            ('uniform', 50.0, 51.0)\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        wp_params, hp_params, ws_params, hs_params = case\n        \n        # Generate N samples for each of the four random variables\n        # using a vectorized approach for efficiency.\n        all_samples = []\n        for dist, p1, p2 in [wp_params, hp_params, ws_params, hs_params]:\n            if dist == 'norm':\n                # p1 is mean, p2 is standard deviation\n                samples = rng.normal(loc=p1, scale=p2, size=NUM_SAMPLES)\n            elif dist == 'uniform':\n                # p1 is low, p2 is high\n                samples = rng.uniform(low=p1, high=p2, size=NUM_SAMPLES)\n            all_samples.append(samples)\n            \n        wp_samples, hp_samples, ws_samples, hs_samples = all_samples\n\n        # Check the fit condition for all N samples in a vectorized manner.\n        # The condition is (Wp <= Ws) AND (Hp <= Hs).\n        # The result 'successes' is a boolean array.\n        is_fit = (wp_samples <= ws_samples) & (hp_samples <= hs_samples)\n\n        # The sum of the boolean array gives the total number of successful fits\n        # (True evaluates to 1, False to 0).\n        num_successes = np.sum(is_fit)\n\n        # The yield is the ratio of successful fits to the total number of samples.\n        yield_estimate = num_successes / NUM_SAMPLES\n        \n        # Format the result to six decimal places and append to the list.\n        results.append(f\"{yield_estimate:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2414629"}, {"introduction": "蒙特卡洛积分的一个关键优势在于其误差估计，由于中心极限定理 (Central Limit Theorem, CLT)，该误差通常随着样本量 $N$ 的增加以 $1/\\sqrt{N}$ 的速率减小。然而，CLT 的成立需要满足一些前提条件，其中最重要的是被积函数的方差必须是有限的。本练习 [@problem_id:2411534] 是一个至关重要的“压力测试”，旨在揭示当此条件不被满足时会发生什么。通过模拟一个被积函数方差为无穷大的积分估计过程，你将亲眼观察到标准误差计算为何会失效，并深刻理解在使用计算方法时，洞察其背后理论假设的重要性。", "problem": "考虑单位区间上的一族积分\n$$ I(p) \\equiv \\int_{0}^{1} u^{p} \\, du, $$\n其中 $p$ 是一个实数参数，满足 $p > -1$，以确保该积分存在且为有限值。对于在 $[0,1]$ 上均匀分布的随机变量 $U$，定义被积函数为 $f_{p}(U) = U^{p}$。其精确值为\n$$ I(p) = \\frac{1}{p+1}. $$\n对于给定的样本量 $n \\in \\mathbb{N}$ 和批次数 $B \\in \\mathbb{N}$，考虑 $B$ 个独立的批次，每批包含从 $[0,1]$ 上的均匀分布中独立抽取的 $n$ 个样本 $U_{1},\\dots,U_{n}$。对于每批 $b \\in \\{1,\\dots,B\\}$，定义批次样本均值\n$$ \\bar{f}_{b} = \\frac{1}{n} \\sum_{i=1}^{n} f_{p}(U_{i}), $$\n和无偏批次样本方差\n$$ s_{b}^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n} \\left( f_{p}(U_{i}) - \\bar{f}_{b} \\right)^{2}, $$\n当 $n \\ge 2$ 时。当 $n \\ge 2$ 时，定义名义 $95\\%$ 水平、基于正态分布的半宽度\n$$ h_{b} = 1.96 \\cdot \\frac{\\sqrt{s_{b}^{2}}}{\\sqrt{n}}. $$\n对于每个 $n \\ge 2$ 的批次 $b$，构建名义区间\n$$ \\left[ \\bar{f}_{b} - h_{b}, \\, \\bar{f}_{b} + h_{b} \\right]. $$\n设批次 $b$ 的覆盖指示变量为 $C_{b}$，如果 $I(p)$ 位于上述区间内，则 $C_{b} = 1$，否则 $C_{b} = 0$。如果 $n < 2$，由于样本方差未定义，按惯例定义 $C_{b} = 0$。定义跨批次的经验覆盖率\n$$ \\widehat{\\mathrm{cov}} = \\frac{1}{B} \\sum_{b=1}^{B} C_{b}. $$\n请注意，对于 $p \\le -\\tfrac{1}{2}$，方差 $\\mathbb{V}[f_{p}(U)]$ 是无穷大的，因为\n$$ \\mathbb{E}\\left[ f_{p}(U)^{2} \\right] = \\int_{0}^{1} u^{2p} \\, du $$\n是发散的，尽管对于所有 $p > -1$，$I(p)$ 仍然是有限的。这种情况违反了中心极限定理（CLT）通常要求的有限方差条件，因此基于正态分布的名义误差界限可能会失效。\n\n您的任务是编写一个完整的程序，针对每个测试用例，以小数形式生成经验覆盖率 $\\widehat{\\mathrm{cov}}$。每个测试用例指定 $(p, n, B, \\text{seed})$，其中 $\\text{seed}$ 用于初始化伪随机数生成器以确保可复现性。不涉及角度和物理单位；无需进行单位换算。所有答案必须以小数形式表示。\n\n测试集：\n- 测试 $1$：$p = -\\tfrac{1}{2}$，$n = 500$，$B = 200$，$\\text{seed} = 17$。\n- 测试 $2$：$p = -0.6$，$n = 500$，$B = 200$，$\\text{seed} = 19$。\n- 测试 $3$：$p = \\tfrac{1}{2}$，$n = 500$，$B = 200$，$\\text{seed} = 23$。\n- 测试 $4$：$p = \\tfrac{1}{2}$，$n = 5000$，$B = 200$，$\\text{seed} = 29$。\n- 测试 $5$：$p = -\\tfrac{1}{2}$，$n = 5000$，$B = 200$，$\\text{seed} = 31$。\n- 测试 $6$：$p = \\tfrac{1}{2}$，$n = 1$，$B = 200$，$\\text{seed} = 37$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试 1 到测试 6 的六个经验覆盖率，按顺序排列，形式为用方括号括起来的逗号分隔列表，例如，\n`[x1,x2,x3,x4,x5,x6]`。", "solution": "问题陈述已经过评估并被确定为有效。这是一个计算统计学中定义良好的问题，其基础是蒙特卡洛积分和假设检验的原理。定义清晰，参数完整，其背景（探究中心极限定理的局限性）在科学上是合理的。不存在矛盾、歧义或事实错误。\n\n任务是执行蒙特卡洛模拟，以计算积分 $I(p) = \\int_{0}^{1} u^{p} \\, du$ 的名义 $95\\%$ 置信区间的经验覆盖率。该模拟将检验覆盖行为如何随参数 $p$ 而变化，该参数控制被积函数 $f_{p}(U) = U^{p}$（其中 $U \\sim \\text{Uniform}[0,1]$）的方差的有限性。\n\n已知该积分的精确值为 $I(p) = \\frac{1}{p+1}$（对于 $p > -1$）。\n\n为计算由 $(p, n, B, \\text{seed})$ 指定的单个测试用例的经验覆盖率 $\\widehat{\\mathrm{cov}}$，算法如下：\n\n1.  使用提供的整数 `seed` 初始化伪随机数生成器，以确保可复现性。\n2.  计算积分的真实值，我们记为 $I_{true} = \\frac{1}{p+1}$。\n3.  对于样本量 $n$ 小于 $2$ 的情况，给出了一个特定规则。如果 $n < 2$，样本方差 $s_{b}^{2}$ 未定义。根据惯例，所有批次的覆盖指示变量 $C_{b}$ 都被设置为 $0$。因此，经验覆盖率 $\\widehat{\\mathrm{cov}}$ 为 $0$。此情况的计算到此终止。\n4.  对于 $n \\ge 2$ 的主要情况，模拟在 $B$ 个独立批次上进行。我们将维护一个计数器（初始化为零），用于记录置信区间覆盖了真实值 $I_{true}$ 的批次数。\n5.  一种高效的方法是，一次性生成所有 $B$ 个批次所需的全部随机数。我们生成一个 $B \\times n$ 的独立随机变量矩阵，其中每个元素都从 $[0,1]$ 上的均匀分布中抽取。设该矩阵为 $\\mathbf{U}$，其元素为 $U_{b,i}$，其中批次 $b \\in \\{1, \\dots, B\\}$，样本索引 $i \\in \\{1, \\dots, n\\}$。\n6.  将被积函数 $f_{p}(u) = u^{p}$ 逐元素应用于矩阵 $\\mathbf{U}$，得到一个新矩阵 $\\mathbf{F}$，其元素为 $F_{b,i} = (U_{b,i})^{p}$。$\\mathbf{F}$ 的每一行对应于单个批次的样本 $\\{f_{p}(U_{i})\\}_{i=1}^{n}$。\n7.  对每个批次 $b$（即对 $\\mathbf{F}$ 的每一行），我们计算所需的统计量：\n    a. 批次样本均值：$\\bar{f}_{b} = \\frac{1}{n} \\sum_{i=1}^{n} F_{b,i}$。这可以通过计算矩阵 $\\mathbf{F}$ 各行的均值来同时为所有批次进行计算。\n    b. 无偏批次样本方差：$s_{b}^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n} (F_{b,i} - \\bar{f}_{b})^{2}$。这也可以通过计算矩阵 $\\mathbf{F}$ 各行的样本方差（使用单自由度校正，`ddof=1`）来为所有批次进行计算。\n8.  使用这些统计量，我们为每个批次计算名义 $95\\%$ 置信区间的半宽度：\n    $$h_{b} = 1.96 \\cdot \\frac{\\sqrt{s_{b}^{2}}}{\\sqrt{n}}$$\n    请注意，值 $1.96$ 是标准正态分布的 $0.975$ 分位数的近似值，即 $z_{0.025}$。\n9.  对于每个批次 $b$，我们判断置信区间 $[\\bar{f}_{b} - h_{b}, \\bar{f}_{b} + h_{b}]$ 是否包含真实值 $I_{true}$。此条件等效于检验绝对误差 $|\\bar{f}_{b} - I_{true}|$ 是否小于或等于半宽度 $h_{b}$。\n10. 统计满足此条件的批次数。设此计数为 $N_{covered}$。\n11. 经验覆盖率是覆盖区间数与总批次数的比率：\n    $$\\widehat{\\mathrm{cov}} = \\frac{N_{covered}}{B}$$\n对指定的六个测试用例中的每一个都执行此过程。理论上预期，对于 $p > -1/2$（此时 $f_{p}(U)$ 的方差是有限的），中心极限定理成立，$\\widehat{\\mathrm{cov}}$ 应接近名义水平 $0.95$，尤其是在 $n$ 较大时。相反，对于 $p \\le -1/2$，方差是无穷大的，基于正态分布的置信区间的理论基础无效，我们预计 $\\widehat{\\mathrm{cov}}$ 将显著偏离 $0.95$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_coverage(p: float, n: int, B: int, seed: int) -> float:\n    \"\"\"\n    Computes the empirical coverage fraction for a given set of parameters.\n\n    Args:\n        p: The exponent parameter for the integrand u^p.\n        n: The sample size for each batch.\n        B: The number of batches.\n        seed: The seed for the random number generator.\n\n    Returns:\n        The empirical coverage fraction as a float.\n    \"\"\"\n    # Per the problem statement, for n < 2, the sample variance is not defined,\n    # and the coverage indicator C_b is 0 by convention. Thus, the total\n    # empirical coverage is 0.\n    if n < 2:\n        return 0.0\n\n    # Initialize the pseudorandom number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Calculate the exact value of the integral I(p) = 1/(p+1).\n    I_true = 1.0 / (p + 1.0)\n\n    # Generate all uniform random samples for all B batches at once.\n    # The shape of the resulting array is (B, n).\n    uniform_samples = rng.uniform(size=(B, n))\n\n    # Evaluate the integrand f_p(u) = u^p on the samples.\n    f_p_samples = uniform_samples**p\n\n    # Calculate batch means along axis 1 (across samples in a batch).\n    # The result is an array of shape (B,).\n    batch_means = np.mean(f_p_samples, axis=1)\n\n    # Calculate unbiased batch sample variances along axis 1.\n    # ddof=1 ensures the denominator is (n-1).\n    # The result is an array of shape (B,).\n    batch_variances = np.var(f_p_samples, axis=1, ddof=1)\n\n    # Calculate the half-width of the nominal 95% confidence interval for each batch.\n    # h_b = 1.96 * sqrt(s_b^2 / n)\n    # A small epsilon is not strictly necessary with standard floating point\n    # arithmetic as var >= 0, but good practice to consider. Here, it is omitted.\n    half_widths = 1.96 * np.sqrt(batch_variances / n)\n\n    # Determine for each batch if the true value is within the confidence interval.\n    # This is true if |sample_mean - true_value| <= half_width.\n    # This operation returns a boolean array of shape (B,).\n    is_covered = np.abs(batch_means - I_true) <= half_widths\n\n    # The empirical coverage is the mean of the boolean indicators (True=1, False=0).\n    coverage_fraction = np.mean(is_covered)\n\n    return coverage_fraction\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (p, n, B, seed)\n    test_cases = [\n        (-0.5, 500, 200, 17),    # Test 1\n        (-0.6, 500, 200, 19),    # Test 2\n        (0.5, 500, 200, 23),     # Test 3\n        (0.5, 5000, 200, 29),    # Test 4\n        (-0.5, 5000, 200, 31),   # Test 5\n        (0.5, 1, 200, 37),      # Test 6\n    ]\n\n    results = []\n    for p, n, B, seed in test_cases:\n        # Calculate the empirical coverage for the current test case.\n        result = compute_coverage(p, n, B, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2411534"}]}