{"hands_on_practices": [{"introduction": "理论是基础，但计算物理学的真正乐趣在于动手实践。要真正理解自回避行走，最直接的方法就是编写程序来生成并分析它们。这个练习将指导你使用一种名为“递归回溯”的算法，对长度为 $N$ 的短自回避行走进行精确枚举。通过计算行走“跨度”的平均值，你将亲身体验到这些看似简单的路径如何遵循深刻的标度定律，并首次估算关键指数 $\\nu$。[@problem_id:2436367]", "problem": "要求您以精确、可复现和可测试的方式，研究二维方格上的自避行走（Self-Avoiding Walk, SAW）的跨度。自避行走是一系列格点的序列，其中每一步移动一个单位到四个最近邻之一，且任何格点不能被访问超过一次。考虑从原点 $(0,0)$ 开始，有恰好 $N$ 个单位步长，且位于无限方格上的行走。\n\n对于一个长度为 $N$ 的行走，将其访问过的位置表示为 $\\{(x_i,y_i)\\}_{i=0}^{N}$，其中 $(x_0,y_0)=(0,0)$，对所有 $i$ 都有 $\\|(x_{i+1},y_{i+1})-(x_i,y_i)\\|_1=1$，且当 $i\\neq j$ 时 $(x_i,y_i)\\neq(x_j,y_j)$。定义 $x$ 方向上的跨度为\n$$\nS_N=\\max_{0\\le i\\le N} x_i - \\min_{0\\le i\\le N} x_i.\n$$\n令 $\\langle S_N\\rangle$ 表示对所有从原点开始的长度为 $N$ 的自避行走的 $S_N$ 所取的算术平均值，其中每条行走的权重相等。\n\n任务：\n1. 对每个指定的 $N$ 值，计算 $\\langle S_N\\rangle$ 的精确值。\n2. 使用两个指定的值 $N_1$ 和 $N_2$（满足 $N_2>N_1\\ge 1$），计算由成对对数斜率定义的标度指数估计值 $\\nu$：\n$$\n\\nu=\\frac{\\log\\big(\\langle S_{N_2}\\rangle/\\langle S_{N_1}\\rangle\\big)}{\\log\\big(N_2/N_1\\big)}.\n$$\n\n测试套件：\n- 情况1：$N=0$。\n- 情况2：$N=1$。\n- 情况3：$N=2$。\n- 情况4：$N=5$。\n- 情况5：$N=8$。\n- 情况6：$N=10$。\n- 情况7：$(N_1,N_2)=(4,10)$，程序必须使用上述定义计算 $\\nu$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序和格式如下：\n- $[\\langle S_0\\rangle,\\langle S_1\\rangle,\\langle S_2\\rangle,\\langle S_5\\rangle,\\langle S_8\\rangle,\\langle S_{10}\\rangle,\\nu]$,\n- 每个数字必须四舍五入到小数点后恰好六位，\n- 输出行中不允许有空格。\n\n不涉及物理单位。不使用角度。不使用百分比。所有量均为纯数。每种情况的预期答案是如上定义的实数（浮点数）。", "solution": "问题陈述已经过严格验证。它在科学上是合理的、适定的且无歧义，是研究自避行走中的一个标准计算练习。因此可以推导出解决方案。任务是计算在二维方格上进行 $N$ 步自避行走（SAW）的平均跨度 $\\langle S_N \\rangle$，以及一个相关的标度指数 $\\nu$。\n\n**1. 理论框架**\n\n长度为 $N$ 的自避行走是一系列 $N+1$ 个不同格点 $p_0, p_1, \\ldots, p_N$ 的序列，其中 $p_0$ 是原点 $(0,0)$，每个后续格点 $p_{i+1}$ 是 $p_i$ 的最近邻。相邻格点之间的距离满足 $\\|p_{i+1} - p_i\\|_1 = 1$。行走在 $x$ 方向上的跨度定义为 $S_N = \\max_{i} x_i - \\min_{i} x_i$，其中 $p_i = (x_i, y_i)$。\n\n我们感兴趣的量 $\\langle S_N \\rangle$ 是在所有长度为 $N$ 的唯一自避行走（SAW）的系综上对 $S_N$ 取的算术平均值，其中每条行走被赋予相等的权重。\n$$\n\\langle S_N \\rangle = \\frac{1}{C_N} \\sum_{w \\in \\mathcal{W}_N} S_N(w)\n$$\n这里，$\\mathcal{W}_N$ 是所有长度为 $N$ 的自避行走的集合，而 $C_N = |\\mathcal{W}_N|$ 是此类行走的总数。\n\n对于较小的 $N$，对所有可能的行走进行精确枚举在计算上是可行的。这是我们将采用的方法。\n\n**2. 算法方法：递归回溯**\n\n我们将使用递归回溯（深度优先搜索）算法生成给定长度 $N$ 的所有自避行走。\n递归的状态由当前位置、已走的步数和已访问格点的集合定义。\n\n该算法按以下方式进行：\n- 从原点 $p_0 = (0,0)$ 开始，路径仅包含此点。\n- 递归地将行走延长一步。从当前位置 $p_i$，尝试移动到四个最近邻中的每一个。\n- 仅当新格点 $p_{i+1}$ 未被访问过时，向该点的移动才有效。\n- 如果移动有效，则将新格点添加到路径中并进行递归。递归调用返回后，通过从路径中移除该格点来进行回溯，以探索其他可能性。\n- 当行走达到所需的 $N$ 步长度时（即路径包含 $N+1$ 个格点），递归终止。\n\n**3. 使用晶格对称性进行优化**\n\n通过利用方格的对称性，计算工作量可以减少大约4倍。所有自避行走的集合在旋转 $90^\\circ$、$180^\\circ$、$270^\\circ$ 及反射操作下是不变的。\n\n我们不生成所有的行走，而是只生成行走的子集，记为 $\\mathcal{W}_R$，其中第一步固定指向特定方向，例如向右，到达位置 $(1,0)$。对于 $\\mathcal{W}_R$ 中的任意行走 $w$，我们可以通过将其旋转 $90^\\circ$、$180^\\circ$ 和 $270^\\circ$ 来生成另外三条不同的行走。这些行走分别对应于起始步向上、向左和向下的行走。\n\n设 $w_R$ 是 $\\mathcal{W}_R$ 中的一条行走，其坐标为 $\\{(x_i, y_i)\\}$。\n- 沿 $y$ 轴的反射得到一条行走 $w_L \\in \\mathcal{W}_L$，其坐标为 $\\{(-x_i, y_i)\\}$。它的 x-跨度是 $S_x(w_L) = \\max(-x_i) - \\min(-x_i) = \\max(x_i) - \\min(x_i) = S_x(w_R)$。\n- 逆时针旋转 $90^\\circ$ 得到一条行走 $w_U \\in \\mathcal{W}_U$，其坐标为 $\\{(-y_i, x_i)\\}$。它的 x-跨度是 $S_x(w_U) = \\max(-y_i) - \\min(-y_i) = \\max(y_i) - \\min(y_i) = S_y(w_R)$，即原始行走的 y-跨度。\n- 类似地，对于一条行走 $w_D \\in \\mathcal{W}_D$，$S_x(w_D) = S_y(w_R)$。\n\n所有行走的 x-跨度总和为：\n$$\n\\sum_{w \\in \\mathcal{W}_N} S_x(w) = \\sum_{w \\in \\mathcal{W}_R} S_x(w) + \\sum_{w \\in \\mathcal{W}_L} S_x(w) + \\sum_{w \\in \\mathcal{W}_U} S_x(w) + \\sum_{w \\in \\mathcal{W}_D} S_x(w)\n$$\n$$\n\\sum_{w \\in \\mathcal{W}_N} S_x(w) = 2 \\sum_{w \\in \\mathcal{W}_R} S_x(w) + 2 \\sum_{w \\in \\mathcal{W}_R} S_y(w)\n$$\n行走总数为 $C_N = 4 |\\mathcal{W}_R|$（对于 $N \\ge 1$）。\n因此，平均跨度是：\n$$\n\\langle S_N \\rangle = \\frac{2 \\sum_{w \\in \\mathcal{W}_R} (S_x(w) + S_y(w))}{4 |\\mathcal{W}_R|} = \\frac{1}{2 |\\mathcal{W}_R|} \\sum_{w \\in \\mathcal{W}_R} (S_x(w) + S_y(w))\n$$\n这个优化后的公式只需要枚举 $\\mathcal{W}_R$ 中的行走，计算它们的 x-跨度和 y-跨度，然后合并结果。这就是所实现的程序。对于 $N=0$ 和 $N=1$ 的平凡情况直接处理：\n- 对于 $N=0$，只有一条行走 $\\{(0,0)\\}$。$S_0=0-0=0$。所以 $\\langle S_0 \\rangle = 0$。\n- 对于 $N=1$，有四条行走。两条的 $S_1=1$（沿 x-轴的步），两条的 $S_1=0$（沿 y-轴的步）。$\\langle S_1 \\rangle = (1+1+0+0)/4 = 0.5$。\n\n**4. 标度指数的计算**\n\n该问题要求使用两对数据 $(N_1, \\langle S_{N_1} \\rangle)$ 和 $(N_2, \\langle S_{N_2} \\rangle)$ 来计算标度指数 $\\nu$ 的估计值。该关系基于大 $N$ 时的预期幂律标度关系 $\\langle S_N \\rangle \\sim N^\\nu$。指数 $\\nu$ 使用成对对数斜率公式进行估计：\n$$\n\\nu=\\frac{\\log\\big(\\langle S_{N_2}\\rangle/\\langle S_{N_1}\\rangle\\big)}{\\log\\big(N_2/N_1\\big)}\n$$\n对于本问题，我们使用 $(N_1, N_2) = (4, 10)$。这需要计算 $\\langle S_4 \\rangle$ 和 $\\langle S_{10} \\rangle$。\n\n**5. 实现计划**\n\n将使用一个 Python 类来封装逻辑。一个递归方法将执行优化的行走生成过程。为高效地满足自避条件，将使用一个元组的 `set` 来存储已访问的坐标，以实现 $O(1)$ 的平均时间复杂度查找。程序将计算 $N \\in \\{0, 1, 2, 4, 5, 8, 10\\}$ 时的 $\\langle S_N \\rangle$，然后使用 $N=4$ 和 $N=10$ 的值计算 $\\nu$，最后按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SawEnumerator:\n    \"\"\"\n    A class to enumerate Self-Avoiding Walks (SAWs) on a 2D square lattice\n    and calculate the average span. It uses a recursive backtracking algorithm\n    optimized with lattice symmetries.\n    \"\"\"\n    def __init__(self):\n        self.total_x_span_sum = 0.0\n        self.total_y_span_sum = 0.0\n        self.walk_count_one_dir = 0\n\n    def _walk_recursive(self, current_steps, max_steps, pos, path_set, path_list):\n        \"\"\"\n        Recursively generates SAWs from a given state.\n\n        Args:\n            current_steps (int): The number of steps already taken.\n            max_steps (int): The target number of steps for the walk.\n            pos (tuple): The current (x, y) position of the walk.\n            path_set (set): A set of visited coordinates for fast lookups.\n            path_list (list): The ordered list of coordinates in the path.\n        \"\"\"\n        if current_steps == max_steps:\n            self.walk_count_one_dir += 1\n            x_coords = [p[0] for p in path_list]\n            y_coords = [p[1] for p in path_list]\n            self.total_x_span_sum += max(x_coords) - min(x_coords)\n            self.total_y_span_sum += max(y_coords) - min(y_coords)\n            return\n\n        x, y = pos\n        # Possible moves to nearest neighbors\n        moves = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n\n        for next_pos in moves:\n            if next_pos not in path_set:\n                # Explore this valid move\n                path_set.add(next_pos)\n                path_list.append(next_pos)\n                self._walk_recursive(current_steps + 1, max_steps, next_pos, path_set, path_list)\n                # Backtrack to explore other branches\n                path_list.pop()\n                path_set.remove(next_pos)\n\n    def calculate_avg_span(self, N):\n        \"\"\"\n        Calculates the average x-span for all SAWs of length N.\n\n        Args:\n            N (int): The number of steps in the SAW.\n\n        Returns:\n            float: The average span <S_N>.\n        \"\"\"\n        if N == 0:\n            # The only walk is a single point at the origin. Span is 0.\n            return 0.0\n        \n        if N == 1:\n            # Four walks: (0,0)->(1,0), (0,0)->(-1,0), (0,0)->(0,1), (0,0)->(0,-1).\n            # Spans are 1, 1, 0, 0. Average is 2/4 = 0.5.\n            return 0.5\n\n        # Reset counters for a new calculation\n        self.total_x_span_sum = 0.0\n        self.total_y_span_sum = 0.0\n        self.walk_count_one_dir = 0\n\n        # Optimization: only generate walks starting with a step to the right (1,0).\n        start_pos = (0, 0)\n        first_step_pos = (1, 0)\n        \n        path_set = {start_pos, first_step_pos}\n        path_list = [start_pos, first_step_pos]\n        \n        # We have taken 1 step, so N-1 steps remain. The recursion explores these.\n        self._walk_recursive(1, N, first_step_pos, path_set, path_list)\n\n        # Using symmetry to find total span and total walks from the partial calculation.\n        # Walks starting right/left contribute proportionally to total_x_span_sum.\n        # Walks starting up/down contribute proportionally to total_y_span_sum.\n        total_span = 2 * self.total_x_span_sum + 2 * self.total_y_span_sum\n        total_walks = 4 * self.walk_count_one_dir\n\n        if total_walks == 0:\n            # This case should not be reached for N >= 1\n            return 0.0\n\n        return total_span / total_walks\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    Calculates average spans and the scaling exponent nu for the given test cases.\n    \"\"\"\n    # The set of N values for which <S_N> must be calculated.\n    test_cases_N = [0, 1, 2, 5, 8, 10]\n    \n    # Parameters for the nu calculation\n    N1, N2 = 4, 10\n    \n    calculator = SawEnumerator()\n    \n    # Store calculated <S_N> values in a dictionary.\n    s_N_values = {}\n    \n    # Determine all unique N values needed for all tasks.\n    all_N_needed = sorted(list(set(test_cases_N + [N1, N2])))\n    \n    for N in all_N_needed:\n        s_N_values[N] = calculator.calculate_avg_span(N)\n        \n    s0 = s_N_values[0]\n    s1 = s_N_values[1]\n    s2 = s_N_values[2]\n    s4 = s_N_values[4]\n    s5 = s_N_values[5]\n    s8 = s_N_values[8]\n    s10 = s_N_values[10]\n\n    # Compute the scaling exponent nu using the specified formula.\n    nu = np.log(s10 / s4) / np.log(N2 / N1)\n    \n    # Assemble the final list of results in the required order.\n    results = [s0, s1, s2, s5, s8, s10, nu]\n    \n    # Format the output string to exactly match the problem specification:\n    # six decimal places, comma-separated, no spaces, enclosed in brackets.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2436367"}, {"introduction": "对于更长的行走（大的 $N$），精确枚举会因“组合爆炸”而变得不可行，因此我们必须转向蒙特卡洛方法。本练习将介绍一种强大的重要性采样技术——动力学生长算法与Rosenbluth权重相结合。你将在三角晶格上生成长的自回避行走，并计算其均方末端距 $\\langle R^2 \\rangle$，从而更精确地估算临界指数 $\\nu$，并验证不同二维晶格上的普适性概念。[@problem_id:2436438]", "problem": "您需要编写一个完整、可运行的程序，该程序使用第一性原理和一种有原则的蒙特卡洛方法，在二维三角晶格上估计自回避随机游走的临界指数 $ \\nu $。临界指数 $ \\nu $ 由 $ N $ 步自回避游走的均方末端距 $ \\langle R^2 \\rangle $ 在 $ N \\to \\infty $ 时的标度行为定义，即 $ \\langle R^2 \\rangle \\propto N^{2 \\nu} $。您的程序必须通过生成自回避游走并测量 $ \\langle R^2 \\rangle $ 对 $ N $ 的依赖关系，来估计三角晶格上的 $ \\nu $，然后执行回归以推断 $ \\nu $。您必须将您的估计值与二维方格晶格的参考值 $ \\nu_{\\text{ref}} = 3/4 $ 进行比较，并报告其绝对偏差。\n\n为确保普遍的可复现性和科学真实性，您必须遵守以下精确的建模假设、定义和数值规范：\n\n- 晶格与几何：\n  - 使用一个通过整数坐标 $ (i,j) \\in \\mathbb{Z}^2 $ 实现的二维三角晶格，其基向量为 $ \\mathbf{a}_1 = (1,0) $ 和 $ \\mathbf{a}_2 = \\left( \\tfrac{1}{2}, \\tfrac{\\sqrt{3}}{2} \\right) $。一个晶格点对应于 $ \\mathbf{r} = i \\mathbf{a}_1 + j \\mathbf{a}_2 $。\n  - 在整数坐标中，六个最近邻位移恰好是集合 $ \\{ (1,0), (0,1), (-1,1), (-1,0), (0,-1), (1,-1) \\} $。\n  - 对于任何晶格点 $ (i,j) $，其到原点的欧几里得距离的平方为 $ R^2(i,j) = i^2 + j^2 + i j $。\n\n- 自回避随机游走 (SAW)：\n  - 长度为 $ N $ 的游走是从原点 $ (0,0) $ 开始的 $ N $ 步最近邻移动序列，该序列从不重复访问任何点。\n  - 您必须通过动力学生长来生成全长游走：在每一步，从当前可用的未访问邻居中均匀随机地选择一个；如果在任何步骤中没有可用的邻居，则生长尝试失败并被丢弃。\n\n- 通过 Rosenbluth 权重进行无偏估计：\n  - 为消除动力学生长中固有的采样偏差，每次成功的 $ N $ 步游走都必须被赋予一个 Rosenbluth 权重 $ W = \\prod_{k=1}^{N} c_k $，其中 $ c_k $ 是在采取第 $ k $ 步之前，从当前位置出发可选择的步数。\n  - 长度为 $ N $ 时 $ \\langle R^2 \\rangle $ 的无偏估计量是加权平均值 $ \\langle R^2 \\rangle \\approx \\left( \\sum_{m} W_m R^2_m \\right) \\big/ \\left( \\sum_{m} W_m \\right) $，其中求和遍历所有长度为 $ N $ 的成功游走 $ m $。为确保数值稳定性，您必须使用 log-sum-exp 程序在对数域中执行这些加权求和。\n\n- 估计 $ \\nu $：\n  - 对于一组长度 $ \\{ N_\\ell \\} $，按上述方法计算加权平均值 $ \\{ \\langle R^2 \\rangle (N_\\ell) \\} $。\n  - 对 $ \\log \\langle R^2 \\rangle $ 与 $ \\log N $ 进行线性回归以获得斜率 $ s $，由此估计 $ \\nu = s / 2 $。使用普通最小二乘法。\n\n- 测试套件和采样参数：\n  - 您的程序必须运行三个独立的案例（每个案例是一个独立的实验），使用以下确定性参数集。在每个案例中，都使用三角晶格和上述带 Rosenbluth 权重的动力学生长方法。对于一个案例中的每个 $ N $，收集达到指定数量的成功游走；如果生长尝试次数超过指定的最大值，则使用已收集到的任意数量的成功游走继续。如果对于某个 $ N $，收集到的成功游走次数少于 $ 10 $ 次，则在该案例的回归分析中排除该 $ N $ 值。\n    - 案例 $ 1 $：随机种子 $ 1729 $，长度 $ [10, 20, 30, 40] $，每个长度的目标成功游走次数 $ 40 $，每个长度的最大生长尝试次数 $ 100000 $。\n    - 案例 $ 2 $：随机种子 $ 2027 $，长度 $ [8, 16, 24, 32] $，每个长度的目标成功游走次数 $ 40 $，每个长度的最大生长尝试次数 $ 100000 $。\n    - 案例 $ 3 $：随机种子 $ 123 $，长度 $ [5, 10, 15, 20] $，每个长度的目标成功游走次数 $ 60 $，每个长度的最大生长尝试次数 $ 100000 $。\n\n- 输出规范：\n  - 对于每个案例，计算估计的 $ \\nu $ 值和与参考值 $ \\nu_{\\text{ref}} = 3/4 $ 的绝对偏差。将估计值和偏差都四舍五入到 $ 3 $ 位小数。\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [$\\widehat{\\nu}_1$, $|\\widehat{\\nu}_1 - 0.75|$, $\\widehat{\\nu}_2$, $|\\widehat{\\nu}_2 - 0.75|$, $\\widehat{\\nu}_3$, $|\\widehat{\\nu}_3 - 0.75|$]。\n  - 此问题不涉及任何物理单位。\n\n最终的程序必须是自包含的，不需要用户输入，并严格遵守指定的输出格式。每个测试案例的输出必须是实数（浮点数）。", "solution": "所述问题是有效的。这是一个定义明确的计算统计力学练习，基于可靠的物理和数学原理。它是自包含的，所有必要的参数和步骤都已指定，提出了一个具有挑战性但可行的计算任务。我们将着手进行解答。\n\n目标是估计二维三角晶格上自回避随机游走 (SAW) 的临界指数 $\\nu$。该指数控制着游走的空间尺寸随其长度的标度关系。基本关系式如下：\n$$ \\langle R^2 \\rangle \\propto N^{2\\nu} $$\n其中 $N$ 是游走的步数，$\\langle R^2 \\rangle$ 是均方末端距，对所有可能的 $N$ 步 SAW 的系综取平均。SAW 模型是研究良溶剂中长链聚合物的核心，也是临界现象理论中的一个典型问题。\n\n为了估计 $\\nu$，我们必须首先生成 SAW 的统计系综，并计算不同长度 $N$ 下的 $\\langle R^2 \\rangle$。然后，通过分析 $\\langle R^2 \\rangle$ 对 $N$ 的依赖关系，我们就可以提取出该指数。\n\n**1. 晶格表示与几何**\n\n问题指定了一个二维三角晶格。一种方便的表示方法是使用非正交基和整数坐标 $(i,j) \\in \\mathbb{Z}^2$。一个点 $(i,j)$ 相对于原点 $(0,0)$ 的位置向量 $\\mathbf{r}$ 由 $\\mathbf{r} = i\\mathbf{a}_1 + j\\mathbf{a}_2$ 给出，其中基向量为 $\\mathbf{a}_1 = (1,0)$ 和 $\\mathbf{a}_2 = (\\frac{1}{2}, \\frac{\\sqrt{3}}{2})$。该晶格的配位数为 $z=6$。在整数坐标系中，从任意点指向其最近邻的六个向量集合为 $\\{ (1,0), (0,1), (-1,1), (-1,0), (0,-1), (1,-1) \\}$。\n\n从原点到点 $(i,j)$ 的欧几里得距离的平方由点积 $\\mathbf{r} \\cdot \\mathbf{r}$ 导出：\n$$ R^2(i,j) = (i\\mathbf{a}_1 + j\\mathbf{a}_2) \\cdot (i\\mathbf{a}_1 + j\\mathbf{a}_2) = i^2|\\mathbf{a}_1|^2 + j^2|\\mathbf{a}_2|^2 + 2ij(\\mathbf{a}_1 \\cdot \\mathbf{a}_2) $$\n由于 $|\\mathbf{a}_1|^2 = 1$， $|\\mathbf{a}_2|^2 = 1$，以及 $\\mathbf{a}_1 \\cdot \\mathbf{a}_2 = \\frac{1}{2}$，该式可简化为题目中给出的公式：\n$$ R^2(i,j) = i^2 + j^2 + ij $$\n\n**2. 蒙特卡洛模拟：动力学生长与 Rosenbluth 权重**\n\n我们被要求使用动力学生长算法来生成 SAW。这是一种简单的序贯方法：\n1. 从原点 $(0,0)$ 开始游走。\n2. 在每一步 $k$（$k=1, \\dots, N$），识别出尚未访问过的可用最近邻点的集合。\n3. 如果此集合为空，则游走被困住，生长尝试失败。该游走被丢弃。\n4. 如果集合非空，则从可用点中均匀随机选择一个并移动到该点。\n5. 重复此过程，直到成功完成一次长度为 $N$ 的游走。\n\n这种简单的动力学生长过程存在固有的偏差。在晶格中探索更“开放”区域的游走更有可能在不被困住的情况下达到全长 $N$。这种“损耗偏差”意味着对成功生成的游走进行简单平均，并不能得到对应于所有可能 SAW 的真实系综平均值。\n\n为了修正这种偏差，我们必须使用 Rosenbluth-Rosenbluth 方法。对于每个成功生成的游走 $m$，我们计算一个权重 $W_m$：\n$$ W_m = \\prod_{k=1}^{N} c_{m,k} $$\n其中 $c_{m,k}$ 是在游走 $m$ 的第 $k$ 步时可选择的步数（未访问的邻居数量）。这个权重恰好抵消了采样偏差。因此，均方末端距的无偏估计量是加权平均值：\n$$ \\langle R^2 \\rangle = \\frac{\\sum_{m} W_m R^2_m}{\\sum_{m} W_m} $$\n其中 $R^2_m$ 是游走 $m$ 的末端距平方，求和遍历我们样本中所有成功生成的游走。\n\n权重 $W_m$ 的值可能相差许多数量级，这会引入数值不稳定性。为了缓解这个问题，所有涉及权重求和的计算都必须在对数域中进行。我们计算每次游走的权重对数 $\\log W_m = \\sum_{k=1}^{N} \\log c_{m,k}$。然后使用 log-sum-exp 恒等式来计算所需的和：\n$$ \\log \\left( \\sum_{i} e^{x_i} \\right) = x_{\\max} + \\log \\left( \\sum_{i} e^{x_i - x_{\\max}} \\right) $$\n应用此方法，我们计算 $\\log \\langle R^2 \\rangle$ 如下：\n$$ \\log \\langle R^2 \\rangle = \\log \\left( \\sum_{m} W_m R^2_m \\right) - \\log \\left( \\sum_{m} W_m \\right) $$\n其中 $\\log(\\sum W_m)$ 是对 $\\log W_m$ 值数组的 log-sum-exp 运算结果，而 $\\log(\\sum W_m R^2_m)$ 是对 $(\\log W_m + \\log R^2_m)$ 值数组的 log-sum-exp 运算结果。\n\n**3. 临界指数 $\\nu$ 的估计**\n\n对于大的 $N$，定义标度关系式 $\\langle R^2 \\rangle \\approx A N^{2\\nu}$ 可以通过取自然对数进行线性化：\n$$ \\log \\langle R^2 \\rangle \\approx \\log A + (2\\nu) \\log N $$\n这表明 $y = \\log \\langle R^2 \\rangle$ 和 $x = \\log N$ 之间存在线性关系。这条线的斜率是 $s = 2\\nu$。\n\n步骤如下：\n1. 对于给定测试案例中每个指定的长度 $N_\\ell$，生成一个 SAW 样本并计算无偏估计 $\\langle R^2 \\rangle(N_\\ell)$。\n2. 构建一组数据点 $(\\log N_\\ell, \\log \\langle R^2 \\rangle(N_\\ell))$。任何成功游走次数少于 10 次的长度 $N_\\ell$ 都必须被排除。\n3. 对这些数据点执行普通最小二乘 (OLS) 线性回归，以找到最佳拟合斜率 $s$。OLS 斜率的公式为：\n$$ s = \\frac{\\sum_{i} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i} (x_i - \\bar{x})^2} $$\n其中 $x_i = \\log N_i$ 且 $y_i = \\log \\langle R^2 \\rangle(N_i)$。\n4. 临界指数的估计值为 $\\widehat{\\nu} = s/2$。\n5. 最后，我们计算我们的估计值与二维系统参考值 $\\nu_{\\text{ref}} = 3/4 = 0.75$ 的绝对偏差。\n\n对问题中指定的三个测试案例，使用提供的随机种子和采样参数，独立重复此过程，以确保可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the critical exponent nu for self-avoiding walks\n    on a triangular lattice for three specified test cases.\n    \"\"\"\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 1\n        {\n            \"seed\": 1729,\n            \"lengths\": [10, 20, 30, 40],\n            \"target_walks\": 40,\n            \"max_attempts\": 100000,\n        },\n        # Case 2\n        {\n            \"seed\": 2027,\n            \"lengths\": [8, 16, 24, 32],\n            \"target_walks\": 40,\n            \"max_attempts\": 100000,\n        },\n        # Case 3\n        {\n            \"seed\": 123,\n            \"lengths\": [5, 10, 15, 20],\n            \"target_walks\": 60,\n            \"max_attempts\": 100000,\n        },\n    ]\n\n    # --- Constants ---\n    NEIGHBOR_DELTAS = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]\n    NU_REF = 0.75\n\n    # --- Helper Functions ---\n    def custom_logsumexp(x):\n        \"\"\"Numerically stable log-sum-exp operation.\"\"\"\n        if not len(x):\n            return -np.inf\n        max_x = np.max(x)\n        if np.isneginf(max_x):\n            return -np.inf\n        return max_x + np.log(np.sum(np.exp(x - max_x)))\n\n    final_results = []\n    for case in test_cases:\n        rng = np.random.default_rng(case[\"seed\"])\n        \n        log_N_vals = []\n        log_mean_R2_vals = []\n\n        for N in case[\"lengths\"]:\n            successful_walks_data = []\n\n            for _ in range(case[\"max_attempts\"]):\n                path = {(0, 0)}\n                current_pos = (0, 0)\n                log_W = 0.0\n                \n                is_trapped = False\n                for _ in range(N):\n                    neighbors = [(current_pos[0] + dx, current_pos[1] + dy) for dx, dy in NEIGHBOR_DELTAS]\n                    available_neighbors = [n for n in neighbors if n not in path]\n                    \n                    c_k = len(available_neighbors)\n                    if c_k == 0:\n                        is_trapped = True\n                        break\n                    \n                    log_W += np.log(c_k)\n                    \n                    # Choose a step uniformly at random\n                    step_idx = rng.integers(0, c_k)\n                    current_pos = available_neighbors[step_idx]\n                    path.add(current_pos)\n\n                if not is_trapped:\n                    i, j = current_pos\n                    r_sq = float(i**2 + i*j + j**2)\n                    successful_walks_data.append({\"log_W\": log_W, \"r_sq\": r_sq})\n\n                if len(successful_walks_data) >= case[\"target_walks\"]:\n                    break\n            \n            # Exclusion rule: must have at least 10 successful walks\n            if len(successful_walks_data) < 10:\n                continue\n\n            # Process collected data for this N\n            log_weights = np.array([d[\"log_W\"] for d in successful_walks_data])\n            r_sq_values = np.array([d[\"r_sq\"] for d in successful_walks_data])\n\n            # Filter out any walks that end at the origin (R^2 = 0) to avoid log(0)\n            valid_indices = r_sq_values > 0\n            if not np.any(valid_indices):\n                continue\n\n            log_weights = log_weights[valid_indices]\n            r_sq_values = r_sq_values[valid_indices]\n\n            # Calculate log of mean R^2 using log-sum-exp\n            log_total_weight = custom_logsumexp(log_weights)\n            log_weighted_r2_sum = custom_logsumexp(log_weights + np.log(r_sq_values))\n            \n            log_mean_R2 = log_weighted_r2_sum - log_total_weight\n            \n            log_N_vals.append(np.log(N))\n            log_mean_R2_vals.append(log_mean_R2)\n\n        # Perform linear regression to find nu\n        if len(log_N_vals) < 2:\n            # Not enough data points for regression, produce NaN or handle as error\n            # For this problem, a valid case will always produce enough points.\n            # We add representative invalid values for robustness.\n            nu_hat = float('nan')\n            deviation = float('nan')\n        else:\n            x = np.array(log_N_vals)\n            y = np.array(log_mean_R2_vals)\n\n            # OLS slope calculation\n            x_mean = np.mean(x)\n            y_mean = np.mean(y)\n            numerator = np.sum((x - x_mean) * (y - y_mean))\n            denominator = np.sum((x - x_mean)**2)\n            \n            slope = numerator / denominator if denominator != 0 else 0.0\n            \n            nu_hat = slope / 2.0\n            deviation = abs(nu_hat - NU_REF)\n\n        # Round and append results for the case\n        final_results.append(f\"{nu_hat:.3f}\")\n        final_results.append(f\"{deviation:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(final_results)}]\")\n\n# Execute the simulation and print results\nsolve()\n```", "id": "2436438"}, {"introduction": "自回避行走模型不仅仅是数学上的抽象，它也是模拟现实世界中聚合物链的有力工具。在这个实践中，你将通过引入一个外部场来模拟聚合物在重力作用下的沉降行为。你将扩展Rosenbluth方法，引入玻尔兹曼权重来处理能量项，从而研究外场如何影响聚合物链的构象和尺寸。[@problem_id:2436444]", "problem": "设计并实现一个程序，用于研究在均匀外场作用下方形晶格上的自回避随机行走 (SAW)。该外场会使步进偏向一个优先方向，用于模拟聚合物沉降。行走在二维方形晶格（维度为$2$）上进行，无量纲单位下的晶格间距等于$1$。SAW 从原点 $(0,0)$ 开始，包含 $N$ 次最近邻步进，每步为 $(\\pm 1,0)$ 或 $(0,\\pm 1)$ 中的一种，并遵循自回避约束，即每个晶格点最多只能访问一次。\n\n外场是均匀的，指向 $y$ 轴负方向（向下）。以高度 $y_N$ 结束的构型的能量由线性势 $U(y_N) = \\alpha \\, y_N$ 建模，其中 $\\alpha \\ge 0$ 是一个无量纲场强，与重力加速度、单体质量和逆热能的乘积成正比。一个构型的玻尔兹曼权重与 $\\exp(- U(y_N)) = \\exp(- \\alpha \\, y_N)$ 成正比。等价地，每一步垂直增量为 $\\Delta y \\in \\{-1,0,+1\\}$ 的步进携带一个局部玻尔兹曼因子 $\\exp(-\\alpha \\, \\Delta y)$，因此，向下的步进 $\\Delta y = -1$ 会受到因子 $\\exp(+\\alpha)$ 的偏好，向上的步进 $\\Delta y = +1$ 会受到因子 $\\exp(-\\alpha)$ 的抑制，而水平步进 $\\Delta y = 0$ 不受影响。\n\n由于均匀生长长度为 $N$ 的 SAW 会因陷阱（死胡同）而具有高损耗率，因此请使用 Rosenbluth 重要性采样方法进行有偏生长，定义如下。在从位置 $\\mathbf{r}_i$ 开始的每一步生长 $i \\in \\{0,1,\\dots,N-1\\}$ 中，枚举所有通往未访问邻居的允许下一步集合 $\\mathcal{A}_i$。对于每个垂直增量为 $\\Delta y(s)$ 的允许步进 $s \\in \\mathcal{A}_i$，定义局部玻尔兹曼因子 $b(s) = \\exp(-\\alpha \\, \\Delta y(s))$ 和步进选择归一化因子 $C_i = \\sum_{s \\in \\mathcal{A}_i} b(s)$。以概率 $p(s_i) = b(s_i)/C_i$ 选择下一步 $s_i$。如果 $\\mathcal{A}_i$ 为空（即 $C_i = 0$），则行走被困住，当前尝试不会产生长度为 $N$ 的构型。一个成功生长到长度 $N$ 的构型的 Rosenbluth 权重为 $W_N = \\prod_{i=0}^{N-1} C_i$。\n\n令 $\\mathbf{R}_N = \\mathbf{r}_N - \\mathbf{r}_0$ 表示端到端矢量。考虑以下可观测量：\n- 端到端矢量沿场方向（向下）的投影（按步长归一化），定义为 $A_1 = (\\mathbf{R}_N \\cdot \\hat{\\mathbf{e}}_f)/N$，其中 $\\hat{\\mathbf{e}}_f = (0,-1)$ 是沿场方向的单位矢量，因此 $A_1 = -y_N/N$。\n- 端到端距离的平方，定义为 $A_2 = \\|\\mathbf{R}_N\\|^2 = x_N^2 + y_N^2$。\n这些可观测量在所有长度为 $N$ 的 SAW 上的玻尔兹曼加权期望值，通过重要性采样估计量来估计：\n$$\n\\langle A \\rangle \\approx \\frac{\\sum_{k=1}^{M_s} W_N^{(k)} \\, A^{(k)}}{\\sum_{k=1}^{M_s} W_N^{(k)}},\n$$\n其中 $M_s$ 是在 $M$ 次独立的 Rosenbluth 生长尝试中成功生成长度为 $N$ 的行走次数，$W_N^{(k)}$ 是第 $k$ 个成功构型的 Rosenbluth 权重，$A^{(k)}$ 是在该构型上计算的可观测量。同时，估计损耗率 $a = (M - M_s)/M$，即在达到长度 $N$ 之前被困住的尝试所占的比例。\n\n基于以上定义和原理，编写一个完整的程序，该程序：\n- 按照上述规定，实现用于 SAW 的有偏 Rosenbluth 生长过程。\n- 对每个测试用例，使用指定的伪随机种子执行 $M$ 次独立尝试，统计成功生成长度为 $N$ 的构型数量，计算 $\\langle A_1 \\rangle$ 和 $\\langle A_2 \\rangle$ 的 Rosenbluth 加权估计值，并计算损耗率 $a$。\n- 全程使用无量纲单位（不要求物理单位）。\n- 将报告的每个浮点数结果四舍五入到 $6$ 位小数。\n\n测试套件。您的程序必须计算以下参数集的结果，每个参数集指定为一个元组 $(N,\\alpha,M,\\text{seed})$：\n- Case $1$: $(32, 0.0, 6000, 314159)$。\n- Case $2$: $(32, 0.5, 6000, 271828)$。\n- Case $3$: $(40, 1.0, 8000, 161803)$。\n\n最终输出格式。您的程序应生成单行输出，包含一个结果列表，每个测试用例一个结果，其中每个结果本身是包含三个浮点数的列表，顺序为 $[\\langle A_1 \\rangle, \\langle A_2 \\rangle, a]$，每个浮点数都四舍五入到 $6$ 位小数。总体格式必须是单行：\n[[r11,r12,r13],[r21,r22,r23],[r31,r32,r33]]\n行内任何位置都不能有空格。", "solution": "该问题要求为一个在二维方形晶格上、受有偏外场作用的自回避随机行走 (SAW) 实现一个模拟程序。该模拟必须采用 Rosenbluth 方法进行重要性采样，以估算物理可观测量。\n\n该物理系统是一个由 $N$ 个单体组成的聚合物链，模型化为一个在晶格间距为 $1$ 的方形晶格上的 $N$ 步 SAW。行走从原点 $\\mathbf{r}_0 = (0,0)$ 开始。自回避约束意味着任何晶格点都不能被访问超过一次。一个外场施加在 $y$ 轴负方向，由势能 $U(y_N) = \\alpha \\, y_N$ 表示，其中 $y_N$ 是行走最终的垂直坐标，$\\alpha \\ge 0$ 是无量纲场强。给定 SAW 构型的统计权重由玻尔兹曼因子 $e^{-U(y_N)/k_B T}$ 决定，在给定的无量纲单位中，它与 $\\exp(-\\alpha \\, y_N)$ 成正比。这个总权重可以分解为每一步的局部因子之积，即 $\\prod_{i=0}^{N-1} \\exp(-\\alpha \\, \\Delta y_i)$，其中 $\\Delta y_i$ 是第 $i$ 步的垂直位移。\n\n由于行走在达到所需长度 $N$ 之前陷入死胡同的概率很高，即“损耗”概率高，直接对 SAW 进行均匀采样在计算上是低效的。为克服此问题，题目规定使用有偏 Rosenbluth 生长算法，这是一种重要性采样方法。\n\n对于每一次行走尝试，算法流程如下：\n$1$. 行走从 $\\mathbf{r}_0 = (0,0)$ 开始，初始 Rosenbluth 权重为 $1$。维护一个已访问点集，初始时只包含原点。\n$2$. 对于从 $0$ 到 $N-1$ 的每一步 $i$，从当前位置 $\\mathbf{r}_i$：\n    a. 我们识别出允许的下一步集合 $\\mathcal{A}_i$，这些步导致到达相邻的、未被访问的晶格点。\n    b. 如果 $\\mathcal{A}_i$ 为空，行走被困。该次尝试终止，并被视为不成功。\n    c. 对于每个垂直位移为 $\\Delta y(s)$ 的允许步进 $s \\in \\mathcal{A}_i$，我们计算一个局部玻尔兹曼因子 $b(s) = \\exp(-\\alpha \\, \\Delta y(s))$。向下的一步 ($\\Delta y = -1$) 受因子 $\\exp(\\alpha)$ 的偏好，向上的一步 ($\\Delta y = +1$) 受因子 $\\exp(-\\alpha)$ 的抑制，水平步 ($\\Delta y = 0$) 的因子为 $1$。\n    d. 我们计算当前步的归一化因子 $C_i = \\sum_{s \\in \\mathcal{A}_i} b(s)$。此因子是所有可能延续路径的权重之和。\n    e. 构型的总 Rosenbluth 权重 $W_N$ 通过乘以 $C_i$ 来更新。一次成功行走的完整权重是乘积 $W_N = \\prod_{i=0}^{N-1} C_i$。为了数值稳定性，最好计算权重的对数，$\\ln W_N = \\sum_{i=0}^{N-1} \\ln C_i$。\n    f. 下一步 $s_i$ 从 $\\mathcal{A}_i$ 中选择，其概率与它的玻尔兹曼因子成正比，即 $p(s_i) = b(s_i) / C_i$。\n    g. 更新位置 $\\mathbf{r}_{i+1} = \\mathbf{r}_i + \\Delta\\mathbf{r}(s_i)$，并将新点添加到已访问点集中。\n\n经过 $M$ 次独立尝试后，我们将得到一个包含 $M_s \\le M$ 次成功生长行走的样本。一个可观测量 $A$ 的统计期望值使用重要性采样公式进行估计，该公式用其 Rosenbluth 权重 $W_N^{(k)}$ 对每个样本 $k$ 进行加权：\n$$\n\\langle A \\rangle \\approx \\frac{\\sum_{k=1}^{M_s} W_N^{(k)} A^{(k)}}{\\sum_{k=1}^{M_s} W_N^{(k)}}\n$$\n其中 $A^{(k)}$ 是第 $k$ 次成功行走的可观测量的值。这个估计量校正了生长过程引入的偏差，从而得到对所有可能的长度为 $N$ 的 SAW 的真实玻尔兹曼加权平均值的估计。\n\n需要计算的具体可观测量是：\n- 端到端矢量 $\\mathbf{R}_N = (x_N, y_N)$ 沿场方向的归一化投影，$A_1 = -y_N/N$。\n- 端到端距离的平方，$A_2 = \\|\\mathbf{R}_N\\|^2 = x_N^2 + y_N^2$。\n\n此外，还需计算损耗率 $a$，它衡量未能达到长度 $N$ 的行走所占的比例，计算公式为 $a = (M - M_s)/M$。\n\n实现将包含一个遍历指定测试用例的主循环。对于每个用例，一个函数将执行 $M$ 次尝试，并使用提供的种子值以保证可复现性。每次尝试都将试图生长一个 SAW。收集成功尝试的结果（可观测量 $A_1^{(k)}$、$A_2^{(k)}$ 和对数 Rosenbluth 权重 $\\ln W_N^{(k)}$）。在所有尝试结束后，计算 $\\langle A_1 \\rangle$、$\\langle A_2 \\rangle$ 和 $a$ 的最终估计值。采用一种数值稳定的方法计算加权和，该方法涉及在进行指数运算前，将对数权重减去其最大值，以防止浮点溢出。最终结果按要求四舍五入到 $6$ 位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (32, 0.0, 6000, 314159),  # Case 1: (N, alpha, M, seed)\n        (32, 0.5, 6000, 271828),  # Case 2\n        (40, 1.0, 8000, 161803),  # Case 3\n    ]\n\n    all_results = []\n    for N, alpha, M, seed in test_cases:\n        result = run_simulation(N, alpha, M, seed)\n        # Round each value to 6 decimal places.\n        rounded_result = [round(val, 6) for val in result]\n        all_results.append(rounded_result)\n\n    # Print in the specified format: [[r11,r12,r13],[r21,r22,r23],...]\n    print(str(all_results).replace(\" \", \"\"))\n\ndef run_simulation(N, alpha, M, seed):\n    \"\"\"\n    Performs M independent Rosenbluth growth trials for a single parameter set.\n\n    Args:\n        N (int): Number of steps in the SAW.\n        alpha (float): Field strength.\n        M (int): Number of trials.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        tuple: A tuple containing the estimated observables \n               (<A1>, <A2>, attrition_rate).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    successful_walks = []\n    for _ in range(M):\n        result = _run_single_trial(N, alpha, rng)\n        if result is not None:\n            successful_walks.append(result)\n\n    M_s = len(successful_walks)\n    attrition_rate = (M - M_s) / M\n\n    if M_s == 0:\n        return (0.0, 0.0, attrition_rate)\n\n    # Extract results from successful walks\n    # result is (A1, A2, log_W)\n    A1_values = np.array([walk[0] for walk in successful_walks])\n    A2_values = np.array([walk[1] for walk in successful_walks])\n    log_weights = np.array([walk[2] for walk in successful_walks])\n\n    # Numerically stable calculation of weighted averages\n    # W_scaled = exp(log_W - max(log_W))\n    max_log_W = np.max(log_weights)\n    scaled_weights = np.exp(log_weights - max_log_W)\n    \n    sum_scaled_weights = np.sum(scaled_weights)\n\n    if sum_scaled_weights == 0:\n        # This case is highly unlikely but handled for robustness.\n        return (0.0, 0.0, attrition_rate)\n\n    avg_A1 = np.sum(A1_values * scaled_weights) / sum_scaled_weights\n    avg_A2 = np.sum(A2_values * scaled_weights) / sum_scaled_weights\n\n    return (avg_A1, avg_A2, attrition_rate)\n\ndef _run_single_trial(N, alpha, rng):\n    \"\"\"\n    Grows a single self-avoiding walk using the biased Rosenbluth method.\n\n    Args:\n        N (int): The number of steps for the walk.\n        alpha (float): The field strength parameter.\n        rng (np.random.Generator): The random number generator instance.\n\n    Returns:\n        tuple or None: A tuple (A1, A2, log_W) for a successful walk, \n                       or None if the walk gets trapped.\n    \"\"\"\n    # Using a set for O(1) average time complexity for checking visited sites.\n    path = {(0, 0)}\n    x, y = 0, 0\n    log_W = 0.0\n    \n    # Possible nearest-neighbor steps on a square lattice\n    moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    for _ in range(N):\n        allowed_steps = []\n        for dx, dy in moves:\n            if (x + dx, y + dy) not in path:\n                allowed_steps.append((dx, dy))\n\n        if not allowed_steps:\n            return None  # Walk is trapped\n\n        # Calculate Boltzmann factors and probabilities for allowed steps\n        boltzmann_factors = [np.exp(-alpha * dy) for _, dy in allowed_steps]\n        C_i = sum(boltzmann_factors)\n        \n        # Update the log of the Rosenbluth weight\n        log_W += np.log(C_i)\n\n        probabilities = [b / C_i for b in boltzmann_factors]\n        \n        # Select the next step based on the biased probabilities\n        chosen_idx = rng.choice(len(allowed_steps), p=probabilities)\n        dx, dy = allowed_steps[chosen_idx]\n        \n        # Update position and path\n        x, y = x + dx, y + dy\n        path.add((x, y))\n\n    # Calculate observables for the completed walk\n    A1 = -y / N\n    A2 = float(x**2 + y**2) # final position is (x,y)\n    \n    return (A1, A2, log_W)\n\n# Execute the simulation.\nsolve()\n```", "id": "2436444"}]}