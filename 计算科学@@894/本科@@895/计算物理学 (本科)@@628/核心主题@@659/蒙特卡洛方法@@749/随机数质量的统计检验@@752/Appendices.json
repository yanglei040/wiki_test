{"hands_on_practices": [{"introduction": "在许多物理和计算应用中，我们常常面对一个有偏的随机源——例如，一枚不均匀的硬币。如何从这样的源中提取出真正无偏的随机比特流呢？这个实践带你亲手实现著名的冯·诺依曼（von Neumann）随机性提取器，这是一种简洁而巧妙的算法，能够将有偏的独立比特序列转换为完全无偏的序列。通过实现这一过程，并使用一系列基础统计测试（如频率测试、序列测试和游程测试）来验证输出质量，你将掌握随机性提取和验证的核心技能。[@problem_id:2442648]", "problem": "给定一个无穷的独立同分布的抛硬币序列，每次抛掷得到正面的概率为 $p$，得到反面的概率为 $1 - p$。将正面表示为 $1$，反面表示为 $0$。定义 von Neumann 提取器如下：将原始抛掷序列划分为不相交的连续对，并根据以下规则映射每一对\n- $(1, 0) \\mapsto 1$，\n- $(0, 1) \\mapsto 0$，\n- $(0, 0)$ 和 $(1, 1)$ 不产生输出，\n持续此过程，直到恰好产生 $N$ 个输出比特。\n\n仅使用原始抛掷结果独立的假设，从有偏源生成长度为 $N$ 的 von Neumann 提取输出序列，并使用以下三个检验评估最终输出的统计质量，每个检验都会产生一个双边 $p$-值：\n1. 频率（单比特）检验：如果 $N$ 个输出比特中有 $k$ 个等于 $1$，则在零假设 $H_0\\!:\\, \\Pr(1)=0.5$ 下，计算精确的双边二项 $p$-值。\n2. 对不重叠相邻对的序列检验：使用输出的前 $2 \\lfloor N/2 \\rfloor$ 个比特，构成 $\\lfloor N/2 \\rfloor$ 个不重叠的对比特，并统计 $(0,0)$、$(0,1)$、$(1,0)$、$(1,1)$ 的出现次数。在比特独立且公平的零假设下，每种对比特的期望比例为 $1/4$。计算自由度为 $3$ 的卡方拟合优度 $p$-值。\n3. 针对 $\\Pr(1)=\\Pr(0)=1/2$ 的二元序列的独立性游程检验：设 $n_1$ 和 $n_0$ 分别表示 $N$ 个输出比特中 1 和 0 的数量，并设 $R$ 为相同比特的游程总数。在给定 $n_1$ 和 $n_0$ 且序列独立的零假设下，使用均值\n$$\\mu_R \\,=\\, 1 \\,+\\, \\frac{2 n_1 n_0}{N}$$\n和方差\n$$\\sigma_R^2 \\,=\\, \\frac{2 n_1 n_0 \\left(2 n_1 n_0 - N\\right)}{N^2 (N-1)}$$\n构建正态近似统计量\n$$Z \\,=\\, \\frac{R - \\mu_R}{\\sigma_R},$$\n并计算相应的双边 $p$-值。\n\n为保证可复现性，请为产生原始有偏抛掷结果的伪随机数生成器使用一个固定的整数种子 $s$。对于测试用例索引 $i$（从 $0$ 开始），使用种子 $s + i$。\n\n测试套件。对于下面的每个参数对 $(p, N)$，生成 von Neumann 提取的输出，并计算上述三个 $p$-值：\n- 用例 $0$：$(p, N) = (0.30, 8000)$，\n- 用例 $1$：$(p, N) = (0.49, 12000)$，\n- 用例 $2$：$(p, N) = (0.90, 6000)$，\n- 用例 $3$：$(p, N) = (0.50, 10000)$，\n基础种子 $s = 20240913$。\n\n最终输出格式。你的程序应产生一行输出，其中包含一个由方括号括起来的、包含四个项目的逗号分隔列表。每个项目对应一个测试用例，并且其本身是一个包含三个十进制数的列表，这三个数分别为频率检验 $p$-值、序列检验 $p$-值和游程检验 $p$-值，每个值都四舍五入到六位小数。例如，总体格式必须是\n$[[p_{0,1},p_{0,2},p_{0,3}],[p_{1,1},p_{1,2},p_{1,3}],[p_{2,1},p_{2,2},p_{2,3}],[p_{3,1},p_{3,2},p_{3,3}]]$,\n其中 $p_{i,j}$ 表示用例 $i$ 的第 $j$ 个检验的 $p$-值。不应打印任何额外文本。", "solution": "问题陈述被评估为有效。它具有科学依据、提法恰当且客观。该任务是计算统计学中的一个标准练习，具体涉及通过一种成熟的随机性提取技术生成的随机数的质量评估。所有参数、方法和检验统计量都得到了清晰且正确的定义。\n\n解决方案分三个阶段展开：首先，使用 von Neumann 提取器生成一个去偏的二元序列；其次，对该序列应用三个不同的统计检验；第三，为指定的测试用例实现此过程。\n\n**1. Von Neumann 提取器**\n\n此问题的基础是 von Neumann 随机性提取器。它处理一个独立同分布 (i.i.d.) 的有偏比特序列 $X_i$，其中出现 1 的概率为 $\\Pr(X_i=1)=p$，出现 0 的概率为 $\\Pr(X_i=0)=1-p$，且 $p \\in (0,1)$。该提取器通过获取不重叠的比特对 $(X_{2j-1}, X_{2j})$ 来处理输入流。\n\n操作规则如下：\n-   如果对比特为 $(1,0)$，则输出 $1$。\n-   如果对比特为 $(0,1)$，则输出 $0$。\n-   如果对比特为 $(0,0)$ 或 $(1,1)$，则不产生输出，并处理下一对。\n\n该方法有效性的理论依据基于简单的概率论。生成输出的对比特的概率为 $\\Pr(1,0) = p(1-p)$ 和 $\\Pr(0,1) = (1-p)p$。这两个概率是相同的。对比特被丢弃的概率是 $\\Pr(0,0) + \\Pr(1,1) = (1-p)^2 + p^2$。\n\n在生成一个输出比特的条件下，产生一个 $1$ 的条件概率是：\n$$ \\Pr(\\text{output}=1 | \\text{output is generated}) = \\frac{\\Pr(1,0)}{\\Pr(1,0) + \\Pr(0,1)} = \\frac{p(1-p)}{p(1-p) + (1-p)p} = \\frac{1}{2} $$\n类似地，产生一个 $0$ 的条件概率也是 $1/2$。因此，输出序列是完全无偏的。此外，因为输入比特是独立同分布的，所以不重叠的对比特也是独立的，这确保了最终的输出比特彼此之间也是独立的。因此，该过程将一个有偏的独立同分布源转换为一个无偏的独立同分布源，这样的源理应能通过随机性统计检验。\n\n模拟过程通过创建一个带有偏差 $p$ 的伪随机比特流，根据规则成对地处理它们，并收集输出，直到形成所需长度 $N$ 的序列。为保证可复现性，对于测试用例索引 $i$，伪随机数生成器使用种子 $s+i$ 进行初始化，其中基础种子为 $s=20240913$。\n\n**2. 统计质量评估**\n\n生成的 $N$ 比特序列的质量通过三个标准统计检验进行评估。每个检验都评估一个与理想随机性相关的特定零假设（$H_0$），并得出一个 $p$-值。在假设 $H_0$ 为真的情况下，$p$-值表示观测到至少与实测结果一样极端的结果的概率。\n\n**2.1. 频率（单比特）检验**\n此检验旨在检查无偏二元序列最基本的属性：平均而言，0 和 1 的数量相等。\n-   $H_0$：出现 1 的概率为 $1/2$。\n-   设 $k$ 为 $N$ 比特序列中 1 的数量。在 $H_0$ 下，$k$ 服从二项分布 $B(N, 0.5)$。\n-   双边 $p$-值是观测到 1 的数量与期望均值 $N/2$ 的偏差等于或大于 $k$ 与均值偏差的概率。该值使用精确的二项概率质量函数计算。\n\n**2.2. 对比特序列检验**\n此检验通过检查相邻比特是否独立来检验是否存在短程相关性。\n-   $H_0$：比特是独立且公平的。这意味着四种可能的不重叠对比特——$(0,0)$, $(0,1)$, $(1,0)$, $(1,1)$——应以相等的概率 $1/4$ 出现。\n-   前 $2 \\lfloor N/2 \\rfloor$ 个比特被构造成 $M = \\lfloor N/2 \\rfloor$ 个对比特。每种对比特类型（$c_{00}, c_{01}, c_{10}, c_{11}$）的出现次数被统计下来。\n-   执行卡方（$\\chi^2$）拟合优度检验，以比较观测频数与每种对比特的期望频数 $M/4$。$\\chi^2$ 统计量为：\n$$ \\chi^2 = \\sum_{ij \\in \\{00,01,10,11\\}} \\frac{(c_{ij} - M/4)^2}{M/4} $$\n-   将此统计量与自由度为 $4-1=3$ 的 $\\chi^2$ 分布进行比较以获得 $p$-值。\n\n**2.3. 游程检验**\n此检验通过分析序列中“游程”的数量来检查独立性，其中游程是相同值的最长连续子序列。异常数量的游程可能表示聚类（游程太少）或快速振荡（游程太多）。\n-   $H_0$：在 1 的计数（$n_1$）和 0 的计数（$n_0$）固定的情况下，序列是独立的。\n-   设 $R$ 为观测到的游程总数。对于大的 $N$，$R$ 的分布可以由一个正态分布近似，其指定的均值为 $\\mu_R = 1 + \\frac{2 n_1 n_0}{N}$，方差为 $\\sigma_R^2 = \\frac{2 n_1 n_0 (2 n_1 n_0 - N)}{N^2 (N-1)}$。\n-   计算检验统计量 $Z = (R - \\mu_R) / \\sigma_R$。\n-   双边 $p$-值由标准正态分布导出，为 $2 \\times \\Phi(-|Z|)$，其中 $\\Phi$ 是标准正态累积分布函数。\n\n这三个检验的实现将为每个测试用例产生三个 $p$-值，然后按要求格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import binomtest, chisquare, norm\n\ndef generate_von_neumann_sequence(p, N, seed):\n    \"\"\"\n    Generates a sequence of N unbiased bits from a biased source using the\n    von Neumann extractor.\n\n    Args:\n        p (float): The probability of '1' in the source sequence.\n        N (int): The desired length of the output sequence.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        np.ndarray: A numpy array of length N containing the unbiased bits.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    output_list = []\n    \n    # Heuristic for chunk size to generate raw bits.\n    # A larger chunk is more efficient than many small ones.\n    # 20000 raw bits = 10000 pairs.\n    chunk_size = 20000\n\n    while len(output_list) < N:\n        # Generate a chunk of biased bits (True for 1, False for 0).\n        raw_bits = rng.random(size=chunk_size) < p\n        \n        for i in range(0, chunk_size, 2):\n            b1, b2 = raw_bits[i], raw_bits[i+1]\n            \n            # Check for (1,0) or (0,1) pairs.\n            if b1 != b2:\n                # Map (1,0) to 1 and (0,1) to 0.\n                output_list.append(1 if b1 else 0)\n                if len(output_list) == N:\n                    break\n    \n    return np.array(output_list, dtype=np.int8)\n\ndef frequency_test(sequence):\n    \"\"\"\n    Performs the frequency (monobit) test.\n    \n    Args:\n        sequence (np.ndarray): The binary sequence to test.\n        \n    Returns:\n        float: The two-sided p-value.\n    \"\"\"\n    N = len(sequence)\n    if N == 0:\n        return 1.0\n    k = np.sum(sequence)\n    # The binomtest function computes the exact two-sided binomial test p-value.\n    result = binomtest(k, n=N, p=0.5, alternative='two-sided')\n    return result.pvalue\n\ndef serial_test(sequence):\n    \"\"\"\n    Performs the serial test on non-overlapping adjacent pairs.\n    \n    Args:\n        sequence (np.ndarray): The binary sequence to test.\n        \n    Returns:\n        float: The chi-squared p-value.\n    \"\"\"\n    N = len(sequence)\n    M = N // 2\n    if M == 0:\n        return 1.0 # Not enough data for pairs.\n\n    # Form non-overlapping pairs from the first 2*M bits.\n    seq_pairs = sequence[:2*M].reshape(M, 2)\n    \n    # A mapping to count pairs: (0,0)->0, (0,1)->1, (1,0)->2, (1,1)->3\n    pair_values = 2 * seq_pairs[:, 0] + seq_pairs[:, 1]\n    observed_counts = np.bincount(pair_values, minlength=4)\n    \n    # Under H0, expected count for each pair is M/4.\n    expected_count = M / 4.0\n    \n    if expected_count == 0:\n        return 1.0\n        \n    # The chisquare test compares observed vs expected frequencies.\n    # Degrees of freedom is k-1 = 4-1 = 3 by default.\n    _, p_value = chisquare(f_obs=observed_counts, f_exp=[expected_count]*4)\n    return p_value\n\ndef runs_test(sequence):\n    \"\"\"\n    Performs the runs test for independence.\n    \n    Args:\n        sequence (np.ndarray): The binary sequence to test.\n        \n    Returns:\n        float: The normal approximation p-value.\n    \"\"\"\n    N = len(sequence)\n    n1 = np.sum(sequence)\n    n0 = N - n1\n\n    # If the sequence is monolithic, the test is not applicable.\n    # This implies extreme non-randomness. p-value should be 0.\n    if n1 == 0 or n0 == 0:\n        return 0.0\n\n    # Count the number of runs R.\n    R = np.sum(sequence[:-1] != sequence[1:]) + 1\n    \n    # Calculate mean and variance under the null hypothesis.\n    mu_R = 1 + (2.0 * n1 * n0) / N\n    \n    numerator_sigma2 = 2.0 * n1 * n0 * (2.0 * n1 * n0 - N)\n    denominator_sigma2 = float(N**2) * (N - 1)\n    \n    # Variance can be non-positive only in extreme cases not expected here.\n    if denominator_sigma2 == 0 or numerator_sigma2 <= 0:\n        return 0.0\n        \n    sigma2_R = numerator_sigma2 / denominator_sigma2\n    sigma_R = np.sqrt(sigma2_R)\n    \n    # Calculate Z-score and two-sided p-value from standard normal distribution.\n    Z = (R - mu_R) / sigma_R\n    p_value = 2 * norm.sf(abs(Z)) # sf is the survival function, 1-cdf\n    \n    return p_value\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (0.30, 8000),\n        (0.49, 12000),\n        (0.90, 6000),\n        (0.50, 10000),\n    ]\n    base_seed = 20240913\n\n    all_results = []\n    for i, (p, N) in enumerate(test_cases):\n        seed = base_seed + i\n        \n        # 1. Generate the sequence\n        sequence = generate_von_neumann_sequence(p, N, seed)\n        \n        # 2. Run the statistical tests\n        p_freq = frequency_test(sequence)\n        p_serial = serial_test(sequence)\n        p_runs = runs_test(sequence)\n        \n        all_results.append([p_freq, p_serial, p_runs])\n\n    # 3. Format the output as specified\n    formatted_cases = []\n    for pvals in all_results:\n        formatted_pvals = [f\"{p:.6f}\" for p in pvals]\n        formatted_cases.append(f'[{\",\".join(formatted_pvals)}]')\n    \n    print(f'[{\",\".join(formatted_cases)}]')\n\nsolve()\n```", "id": "2442648"}, {"introduction": "我们如何确信我们的统计测试工具是可靠的呢？一个有效的方法是用它们来检验一些数学上已知其分布特性的确定性序列。这个练习将探讨一个源于数论的著名序列：$x_n = \\{\\alpha n^2\\}$。根据韦尔（Weyl）判则，当 $\\alpha$ 是无理数时，该序列在 $[0,1)$ 区间上是均匀分布的。通过对该序列应用卡方检验和柯尔莫可洛夫-斯米尔诺夫（Kolmogorov-Smirnov）检验，你不仅能亲眼验证这一深刻的数学理论，还能加深对这些标准统计工具在评估连续分布均匀性方面的理解。[@problem_id:2442653]", "problem": "给定一个由小数部分映射定义的确定性序列。对于一个实数 $\\alpha$ 和一个正整数 $N$，定义序列 $\\{x_n\\}_{n=1}^{N}$ 如下：\n$$\nx_n = \\{\\alpha n^2\\} = \\alpha n^2 - \\lfloor \\alpha n^2 \\rfloor \\in [0,1),\n$$\n其中 $\\{\\cdot\\}$ 表示小数部分，$\\lfloor \\cdot \\rfloor$ 表示向下取整函数。考虑原假设，即样本 $\\{x_n\\}_{n=1}^{N}$ 是从 $[0,1)$ 上的连续均匀分布中抽取的。\n\n对于下方测试套件中的每一组参数，请对样本 $\\{x_n\\}_{n=1}^{N}$ 进行以下两种均匀性拟合优度检验：\n\n1. 卡方拟合优度检验，使用 $K$ 个等宽区间将 $[0,1)$ 划分为多个区间 $I_j = [\\frac{j-1}{K}, \\frac{j}{K})$，其中 $j = 1, 2, \\dots, K$。令 $O_j$为区间 $I_j$ 中的观测频数，$E_j = \\frac{N}{K}$ 为原假设下的期望频数。卡方统计量为\n$$\n\\chi^2 = \\sum_{j=1}^{K} \\frac{(O_j - E_j)^2}{E_j},\n$$\n在原假设下，该统计量渐近服从自由度为 $K-1$ 的卡方分布。请计算相应的p值。\n\n2. 单样本柯尔莫可洛夫-斯米尔诺夫(KS)检验，其统计量为\n$$\nD_N = \\sup_{u \\in [0,1]} \\left| F_N(u) - u \\right|,\n$$\n其中 $F_N(u)$ 是 $\\{x_n\\}_{n=1}^{N}$ 的经验累积分布函数。在原假设下，$D_N$ 的分布是柯尔莫可洛夫分布，该分布决定了p值。\n\n对于每项检验，使用决策规则在显著性水平 $\\delta$ 下判断是否拒绝原假设：当且仅当p值小于 $\\delta$ 时拒绝原假设。\n\n测试套件：\n- 情况 1：$\\alpha = \\sqrt{2}$，$N = 10000$，$K = 50$，$\\delta = 0.001$。\n- 情况 2：$\\alpha = \\sqrt{3}$，$N = 200$，$K = 10$，$\\delta = 0.001$。\n- 情况 3（对照组，有理数 $\\alpha$）：$\\alpha = \\frac{1}{2}$，$N = 1000$，$K = 20$，$\\delta = 0.001$。\n\n您的程序必须为每种情况生成序列 $\\{x_n\\}_{n=1}^{N}$，计算两个p值，并为每种情况输出一个列表，该列表按顺序包含四个条目：\n$$\n[\\text{p\\_chi2}, \\text{p\\_KS}, I_{\\chi^2}, I_{\\mathrm{KS}}],\n$$\n其中，$\\text{p\\_chi2}$ 是卡方检验的p值，$\\text{p\\_KS}$ 是柯尔莫可洛夫-斯米尔诺夫检验的p值，如果卡方检验在水平 $\\delta$ 下拒绝原假设，则 $I_{\\chi^2}$ 等于 $1$，否则为 $0$；如果柯尔莫可洛夫-斯米尔诺夫检验在水平 $\\delta$ 下拒绝原假设，则 $I_{\\mathrm{KS}}$ 等于 $1$，否则为 $0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表内容是三种情况的结果，每种情况的结果都如上所述，格式化为用方括号括起来的、逗号分隔的列表。总输出必须是单个方括号列表，例如：\n$$\n[[\\text{p1\\_chi2},\\text{p1\\_KS},I1_{\\chi^2},I1_{\\mathrm{KS}}],[\\text{p2\\_chi2},\\text{p2\\_KS},I2_{\\chi^2},I2_{\\mathrm{KS}}],[\\text{p3\\_chi2},\\text{p3\\_KS},I3_{\\chi^2},I3_{\\mathrm{KS}}]].\n$$\n数字打印时不得包含单位。不需要也不允许用户输入。答案必须由程序仅使用指定的测试套件计算并打印。", "solution": "该问题要求对一个确定性生成的序列应用两种标准的拟合优度统计检验——卡方检验和柯尔莫可洛夫-斯米尔诺夫检验——以评估其均匀性。我们必须首先验证其前提，如果前提有效，则构建一个系统化的解决方案。\n\n问题陈述是有效的。它在科学上基于数学领域的数论，特别是序列的均匀分布理论，以及用于测试伪随机数生成器的统计方法。所有参数和定义都已提供，使得问题定义良好且客观。卡方检验的适用条件，即期望频数不应过小，在所有测试情况中都得到满足。例如，在最受限的情况（情况2）中，每个区间的期望计数为 $E_j = N/K = 200/10 = 20$，远高于通常 $E_j \\ge 5$ 的最低要求。\n\n问题的核心在于检验原假设 $H_0$，即由 $x_n = \\{\\alpha n^2\\} = \\alpha n^2 - \\lfloor \\alpha n^2 \\rfloor$ 定义的序列 $\\{x_n\\}_{n=1}^{N}$ 的行为如同从区间 $[0,1)$ 上的连续均匀分布中抽取的样本。这类序列的行为在数论中已得到充分理解。根据 Weyl 判据，对于任何除常数项外至少有一个无理数系数的多项式 $P(n)$，序列 $\\{P(n)\\alpha\\}_{n=1}^{\\infty}$ 在 $[0,1)$ 上是均匀分布的。对于多项式 $P(n) = n^2$，序列 $\\{n^2 \\alpha\\}$ 是均匀分布的当且仅当 $\\alpha$ 是无理数。\n\n因此，对于情况1（$\\alpha = \\sqrt{2}$）和情况2（$\\alpha = \\sqrt{3}$），其中 $\\alpha$ 是无理数，我们预期当 $N$ 很大时，序列是均匀分布的。因此，统计检验应该无法拒绝原假设，从而产生较高的p值。相反，对于情况3（$\\alpha = 1/2$），其中 $\\alpha$ 是有理数，该序列不是均匀分布的。$x_n$ 的值局限于一个有限集合；具体来说，如果 $n$ 是偶数，$x_n = 0$；如果 $n$ 是奇数，$x_n = 0.5$。这种与均匀性的急剧偏离应该很容易被两种检验检测到，导致极低的p值和对原假设的拒绝。\n\n解决方案的步骤是为每组指定的参数集实施这些检验。\n\n**1. 序列生成**\n对于每种情况，我们通过计算 $x_n = (\\alpha \\cdot n^2) \\pmod 1$（其中 $n = 1, 2, \\ldots, N$）来生成序列 $\\{x_n\\}_{n=1}^{N}$。高精度浮点运算对于最大限度地减少数值误差至关重要。\n\n**2. 卡方($\\chi^2$)拟合优度检验**\n此检验将样本空间离散化。区间 $[0,1)$ 被划分为 $K$ 个不相交的等宽区间，$I_j = [\\frac{j-1}{K}, \\frac{j}{K})$，其中 $j=1, \\dots, K$。统计落入每个区间 $I_j$ 的观测数据点数 $O_j$。在均匀性的原假设下，每个区间中点的期望数量为 $E_j = N/K$。然后计算卡方统计量为：\n$$\n\\chi^2 = \\sum_{j=1}^{K} \\frac{(O_j - E_j)^2}{E_j}\n$$\n在 $H_0$ 下，此统计量服从自由度为 $K-1$ 的卡方分布。p值，即观测到至少与计算值一样极端的检验统计量的概率，由 $P(\\chi^2_{K-1} \\ge \\chi^2_{obs})$ 给出。这是使用卡方分布的生存函数（1 - 累积分布函数(CDF)）计算的。\n\n**3. 柯尔莫可洛夫-斯米尔诺夫(KS)检验**\n此检验将样本的经验累积分布函数(ECDF) $F_N(u)$ 与参考分布的累积分布函数(CDF)进行比较，对于 $U[0,1)$ 分布，参考CDF为 $F(u)=u$。ECDF 定义为：\n$$\nF_N(u) = \\frac{1}{N} \\sum_{n=1}^{N} \\mathbf{1}_{x_n \\le u}\n$$\n其中 $\\mathbf{1}$ 是指示函数。检验统计量是这两个函数在整个定义域上的最大绝对差：\n$$\nD_N = \\sup_{u \\in [0,1]} |F_N(u) - u|\n$$\n在 $H_0$ 下，$D_N$ 统计量的分布被称为柯尔莫可洛夫分布，用于计算相应的p值。由于此检验不因分箱而丢失信息，通常比卡方检验更具效力。\n\n**4. 决策规则**\n对于每项检验，将计算出的p值与给定的显著性水平 $\\delta$ 进行比较。当且仅当p值小于 $\\delta$ 时，拒绝原假设 $H_0$。一个指示变量，$I_{\\chi^2}$ 或 $I_{\\mathrm{KS}}$，在拒绝时设为 $1$，在未能拒绝时设为 $0$。\n\n实现将利用 `numpy` 库进行数值运算和序列生成，并利用 `scipy.stats` 模块进行统计检验的实现（`chisquare` 和 `kstest`），这些模块提供了p值的直接计算。最终输出将按照规定格式化为嵌套列表结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the problem by performing chi-squared and Kolmogorov-Smirnov tests\n    on a deterministic sequence for multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, N, K, delta)\n        (np.sqrt(2), 10000, 50, 0.001),  # Case 1\n        (np.sqrt(3), 200, 10, 0.001),    # Case 2\n        (0.5, 1000, 20, 0.001),         # Case 3\n    ]\n\n    all_results = []\n    for alpha, N, K, delta in test_cases:\n        # Generate the sequence x_n = {alpha * n^2} for n = 1, ..., N\n        # Ensure high precision by using float64 where intermediate products\n        # could become large. n**2 for n=10000 is 1e8, well within int64.\n        # The multiplication with float alpha will promote the result to float64.\n        n = np.arange(1, N + 1)\n        x_n = np.mod(alpha * n**2, 1.0)\n\n        # 1. Chi-squared goodness-of-fit test\n        # Get observed counts in K equal-width bins\n        observed_counts, _ = np.histogram(x_n, bins=K, range=(0, 1))\n        \n        # scipy.stats.chisquare with no f_exp assumes uniform expected frequencies.\n        # The expected frequency is N / K.\n        # The degrees of freedom is K - 1.\n        chi2_stat, p_chi2 = stats.chisquare(f_obs=observed_counts)\n        \n        # Determine if we reject the null hypothesis\n        I_chi2 = 1 if p_chi2 < delta else 0\n\n        # 2. One-sample Kolmogorov-Smirnov test\n        # Test against the continuous uniform distribution on [0, 1]\n        ks_result = stats.kstest(x_n, 'uniform')\n        p_ks = ks_result.pvalue\n        \n        # Determine if we reject the null hypothesis\n        I_ks = 1 if p_ks < delta else 0\n\n        # Collate results for the current case\n        case_result = [p_chi2, p_ks, I_chi2, I_ks]\n        all_results.append(case_result)\n\n    # Format the final output string as a list of lists.\n    # Example: [[p1, p2, i1, i2],[p3, p4, i3, i4]]\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2442653"}, {"introduction": "一个伪随机数生成器（PRNG）通过了一系列一维统计测试，是否就意味着它是‘好’的？这个终极实践将揭示一个深刻的警示：一维测试的通过是必要但远非充分的。你将亲自设计一个特殊的PRNG，它在所有一维测试（如分布均匀性、均值）下都表现得完美无瑕，但在一个简单的二维物理模拟——蒙特卡洛方法计算 $\\pi$ 值——中却暴露出灾难性的缺陷。这个练习将让你从根本上理解为什么多维结构对于可靠的物理模拟至关重要，以及为何必须警惕那些看似随机却隐藏着致命相关性的序列。[@problem_id:2442681]", "problem": "您需要构建并分析一个确定性伪随机数生成器 (PRNG)。对于每个给定的种子，该生成器会产生一个位于开区间 $(0,1)$ 内的有限实数序列。该序列需要通过一个指定的统计检验套件，同时在一个简单的蒙特卡洛 (MC) 物理模拟中产生系统性的错误结果。您编写的程序必须实现该生成器，应用这些检验，运行模拟，并为每个测试用例报告一个布尔结果。所有定义和阈值如下所述。\n\n一个以 $s$ 为种子的 PRNG 会生成一个序列 $\\{x_n\\}_{n=1}^N$，其中每个 $x_n \\in (0,1)$。对于一个固定的种子 $s$，在零假设 $\\mathcal{H}_0$（即序列是独立同分布 (i.i.d.) 且共同分布为 $\\mathrm{Uniform}(0,1)$）下，定义三个假设检验：\n\n- 单样本柯尔莫哥洛夫-斯米尔诺夫 (KS) 检验：令 $F_N(x)$ 表示 $\\{x_n\\}_{n=1}^N$ 的经验分布函数，令 $F(x)=x$ 表示 $\\mathrm{Uniform}(0,1)$ 的累积分布函数。定义 KS 统计量为 $D_N=\\sup_{x\\in[0,1]} \\left| F_N(x) - F(x) \\right|$。相关的 $p$ 值在 $\\mathcal{H}_0$ 假设下计算。\n\n- 等概率分箱的卡方检验：将 $(0,1)$ 划分为 $B$ 个等宽的分箱。令 $O_j$ 为分箱 $j$（其中 $j=1,\\dots,B$）的观测计数，令 $E_j=N/B$ 为在 $\\mathcal{H}_0$ 假设下的期望计数。卡方统计量为 $\\chi^2=\\sum_{j=1}^B \\frac{(O_j-E_j)^2}{E_j}$。相关的 $p$ 值在 $\\mathcal{H}_0$ 假设下，根据自由度为 $B-1$ 的卡方分布计算。\n\n- 样本均值检验：令 $\\bar{X}=\\frac{1}{N}\\sum_{n=1}^N x_n$。在 $\\mathcal{H}_0$ 假设下，根据中心极限定理，$Z=\\sqrt{12N}\\,(\\bar{X}-\\tfrac{1}{2})$ 近似服从标准正态分布。双边 $p$ 值根据标准正态分布计算。\n\n定义一个通过标准阈值 $\\varepsilon$，其中 $0<\\varepsilon<\\tfrac{1}{2}$。当且仅当所有三个 $p$ 值都严格位于开区间 $(\\varepsilon,1-\\varepsilon)$ 内时，我们称该统计检验套件通过。\n\n独立于上述检验，通过在单位正方形上采用经典的投镖法，定义一个受物理学启发的 $\\pi$ 的 MC 估计量。使用相同的 PRNG 和相同的种子 $s$，从一个数据流 $(x_1,x_2,\\dots)$ 中为 $k=1,\\dots,M$ 形成 $M$ 个连续数对 $(x_{2k-1},x_{2k})$。定义\n$$\n\\widehat{\\pi} = 4\\, \\frac{1}{M}\\sum_{k=1}^M \\mathbf{1}\\!\\left\\{ x_{2k-1}^2 + x_{2k}^2 \\le 1 \\right\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。给定一个绝对误差容限 $\\tau>0$，当且仅当 $|\\widehat{\\pi} - \\pi| > \\tau$ 时，宣告 MC 模拟失败。通过使用 $\\pi$，所涉及的所有角度都隐式地以弧度表示；不计算任何显式角度。\n\n您的程序必须实现您选择的单个确定性 PRNG 设计，并根据以下测试套件对其进行评估。对于每个测试用例，程序必须计算一个布尔值，该值在且仅在 PRNG 通过统计检验套件且 MC 模拟失败时为真，否则为假。\n\n测试套件包含以下参数集 $(s, N, B, M, \\varepsilon, \\tau)$:\n\n- 案例 1: $(s, N, B, M, \\varepsilon, \\tau) = (123456789, 100000, 100, 50000, 10^{-9}, 10^{-2})$。\n- 案例 2: $(s, N, B, M, \\varepsilon, \\tau) = (0, 50000, 50, 20000, 10^{-9}, 10^{-2})$。\n- 案例 3: $(s, N, B, M, \\varepsilon, \\tau) = (987654321098765432, 120000, 200, 60000, 10^{-9}, 10^{-2})$。\n\n您的程序应生成单行输出，其中包含上述案例的三个布尔结果，形式为用方括号括起来的逗号分隔列表（例如，`[True,False,True]`）。不应产生任何其他输出。所有报告的值都是无单位的；输出中不需要任何物理单位。所有内部计算都必须是确定性的，并且不需要用户输入。", "solution": "所述问题是有效的。这是一个适定且有科学依据的计算物理学练习，它探讨了伪随机数序列一维和多维属性之间的关键区别。一个简单的一维统计检验套件不足以认证一个可用于多维应用（如蒙特卡洛模拟）的生成器。我们将构建一个在二维上存在刻意缺陷，但其一维边际分布仍保持均匀的生成器，从而满足所述标准。\n\n问题的核心是设计一个单一的确定性伪随机数生成器 (PRNG)，对于给定的种子 $s$，它生成的序列 $\\{x_n\\}$ 能同时满足：\n1. 通过由三个检验（柯尔莫哥洛夫-斯米尔诺夫检验、卡方检验、样本均值检验）组成的统计检验套件，意味着每个检验的 $p$ 值都落在区间 $(\\varepsilon, 1-\\varepsilon)$ 内。\n2. 在 $\\pi$ 的蒙特卡洛 (MC) 估计中失败，意味着估计值 $\\widehat{\\pi}$ 与真实值 $\\pi$ 的差异超过容限 $\\tau$。\n\n我们将构建一个在相邻数字之间具有特定致命相关的 PRNG。让一个高质量、密码学安全的 PRNG（例如 `numpy` 库提供的 PCG64 生成器）作为随机性的基础来源。用给定的整数种子 $s$ 为这个基础生成器设定种子，以产生一个来自 $\\mathrm{Uniform}(0,1)$ 分布的 i.i.d. 值序列 $\\{u_k\\}$。\n\n然后，我们有缺陷的 PRNG 将通过构造数对来构建目标序列 $\\{x_n\\}$：\n$$ x_{2k-1} = u_k $$\n$$ x_{2k} = 1 - u_k $$\n对于 $k = 1, 2, 3, \\dots$。\n\n让我们来分析这个序列 $\\{x_n\\}$ 的属性。\n\n首先，考虑一维统计属性。序列 $\\{x_n\\}$ 是两个序列 $\\{u_k\\}$ 和 $\\{1-u_k\\}$ 的混合。如果 $u_k \\sim \\mathrm{Uniform}(0,1)$，那么根据概率论的一个基本结果，变换后的变量 $1-u_k$ 也服从 $\\mathrm{Uniform}(0,1)$ 分布。因此，组合序列 $\\{x_n\\}$ 的边际累积分布函数是一个均匀累积分布函数与其自身的等权重平均，这仍然是均匀累积分布函数。因此，$\\{x_n\\}$ 的边际分布是 $\\mathrm{Uniform}(0,1)$。因此，对于任何一维检验，它都应该表现为均匀分布。\n- **柯尔莫哥洛夫-斯米尔诺夫检验**将 $\\{x_n\\}_{n=1}^N$ 的经验累积分布函数与均匀累积分布函数 $F(x)=x$ 进行比较。由于边际分布是均匀的，经验累积分布函数将收敛于真实的累积分布函数，预计该检验将以高 $p$ 值通过。\n- **卡方检验**检查落入 $B$ 个分箱中的数字频率。均匀的边际分布意味着计数应该均匀分布，所以该检验也预计会通过。\n- **样本均值检验**依赖于序列的均值。其期望为 $E[x_n] = \\frac{1}{2} E[u_k] + \\frac{1}{2} E[1-u_k] = \\frac{1}{2}(\\frac{1}{2}) + \\frac{1}{2}(1-\\frac{1}{2}) = \\frac{1}{2}$。样本均值 $\\bar{X}$ 将收敛到 $\\frac{1}{2}$，检验统计量 $Z=\\sqrt{12N}\\,(\\bar{X}-\\tfrac{1}{2})$ 将接近 $0$，从而产生接近 $1$ 的 $p$ 值。\n鉴于 $\\varepsilon=10^{-9}$ 这一极其宽松的通过-失败阈值，几乎可以肯定所有三个统计检验都会通过。\n\n其次，考虑二维蒙特卡洛模拟。该方法通过在单位正方形内采样点 $(x,y)$ 并计算落入单位圆内的点的比例来估计 $\\pi$。我们的生成器产生数对 $(x_{2k-1}, x_{2k}) = (u_k, 1-u_k)$。这些点并未在单位正方形内均匀分布；它们完全位于线段 $y = 1-x$（其中 $x \\in (0,1)$）上。这是二维均匀性上的一场灾难性失败。\n\nMC 估计量为 $\\widehat{\\pi} = 4\\, \\frac{1}{M}\\sum_{k=1}^M \\mathbf{1}\\!\\left\\{ x_{2k-1}^2 + x_{2k}^2 \\le 1 \\right\\}$。代入我们相关的数对，指示函数内的条件变为：\n$$ u_k^2 + (1-u_k)^2 \\le 1 $$\n展开该表达式得到：\n$$ u_k^2 + 1 - 2u_k + u_k^2 \\le 1 $$\n$$ 2u_k^2 - 2u_k \\le 0 $$\n$$ 2u_k(u_k - 1) \\le 0 $$\n由于基础生成器产生 $u_k \\in [0,1)$，项 $u_k$ 是非负的，而项 $(u_k-1)$ 是非正的。因此，它们的乘积总是非正的，该不等式总是成立。\n\n生成的每一对 $(x_{2k-1}, x_{2k})$ 都将被计为圆内的“命中”。因此，估计量中的求和变为 $\\sum_{k=1}^M 1 = M$。$\\pi$ 的估计量将因此是：\n$$ \\widehat{\\pi} = 4 \\frac{M}{M} = 4 $$\n如果 $|\\widehat{\\pi} - \\pi| > \\tau$，则 MC 模拟失败。在我们的情况下，这是 $|4 - \\pi| > 10^{-2}$。由于 $\\pi \\approx 3.14159$，绝对误差约为 $|4 - \\pi| \\approx 0.8584$，这远大于容限 $\\tau=10^{-2}$。因此，MC 模拟保证会失败。\n\n每个测试用例的最终布尔结果为真，当且仅当统计检验套件通过（我们预期会如此）且 MC 模拟失败（这是保证的）。实现将按所述方式生成序列，使用 `scipy.stats` 库中的函数应用指定的统计检验，并计算 MC 模拟结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kstest, chisquare, norm\n\ndef solve():\n    \"\"\"\n    Implements a flawed PRNG, evaluates it against a statistical battery and a\n    Monte Carlo simulation, and reports the combined outcome for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (s, N, B, M, epsilon, tau)\n        (123456789, 100000, 100, 50000, 1e-9, 1e-2),\n        (0, 50000, 50, 20000, 1e-9, 1e-2),\n        (987654321098765432, 120000, 200, 60000, 1e-9, 1e-2),\n    ]\n\n    results = []\n    for s, N, B, M, epsilon, tau in test_cases:\n        # Step 0: Determine total sequence length required.\n        # Length must be sufficient for both tests and MC simulation, and be even for pairing.\n        L = max(N, 2 * M)\n        if L % 2 != 0:\n            L += 1\n\n        # Step 1: Implement the PRNG with a 2D flaw.\n        # Use numpy's default PRNG (PCG64) as the base generator.\n        rng = np.random.default_rng(s)\n        # Generate L/2 base numbers.\n        base_rands = rng.random(size=L // 2)\n        # Construct the flawed sequence x_n where x_2k = 1 - x_{2k-1}.\n        x_sequence = np.empty(L, dtype=np.float64)\n        x_sequence[0::2] = base_rands\n        x_sequence[1::2] = 1.0 - base_rands\n\n        # Step 2: Perform the statistical battery on the first N numbers.\n        x_for_tests = x_sequence[:N]\n\n        # 2a: One-sample Kolmogorov–Smirnov test.\n        # Test against the standard uniform distribution on (0,1).\n        ks_result = kstest(x_for_tests, 'uniform')\n        p_ks = ks_result.pvalue\n\n        # 2b: Chi-square test for equal-probability bins.\n        observed_counts, _ = np.histogram(x_for_tests, bins=B, range=(0.0, 1.0))\n        # With f_exp not provided, chisquare computes it as sum(f_obs)/len(f_obs),\n        # which is N/B, as required.\n        chi2_result = chisquare(f_obs=observed_counts)\n        p_chi2 = chi2_result.pvalue\n\n        # 2c: Sample mean test.\n        mean_val = np.mean(x_for_tests)\n        z_stat = np.sqrt(12.0 * N) * (mean_val - 0.5)\n        # Two-sided p-value from standard normal survival function.\n        p_mean = 2.0 * norm.sf(np.abs(z_stat))\n\n        # Check if the statistical battery passes.\n        stat_pass = (p_ks > epsilon and p_ks < 1.0 - epsilon) and \\\n                    (p_chi2 > epsilon and p_chi2 < 1.0 - epsilon) and \\\n                    (p_mean > epsilon and p_mean < 1.0 - epsilon)\n\n        # Step 3: Perform the Monte Carlo simulation on the first 2M numbers.\n        x_for_mc = x_sequence[:(2 * M)]\n        x_coords = x_for_mc[0::2]\n        y_coords = x_for_mc[1::2]\n\n        # Count \"hits\" inside the unit circle.\n        hits = np.sum(x_coords**2 + y_coords**2 <= 1.0)\n        # Calculate pi estimate.\n        pi_estimate = 4.0 * hits / M\n\n        # Check if the MC simulation fails.\n        mc_fail = np.abs(pi_estimate - np.pi) > tau\n\n        # Step 4: Determine the final boolean result for the case.\n        # The result is True iff the battery passes AND the simulation fails.\n        final_result = stat_pass and mc_fail\n        results.append(final_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2442681"}]}