{"hands_on_practices": [{"introduction": "要真正掌握自相关时间的概念，最直接的方法就是亲手计算它。本练习将指导你为几种代表不同物理情景的合成时间序列，计算其积分自相关时间 $\\tau_{\\mathrm{int}}$ 和有效样本数 $N_{\\mathrm{eff}}$。通过处理具有长时相关、不相关（白噪声）和振荡相关等不同特性的数据，你将巩固对核心定义的应用，并深入理解不同系统动态如何影响统计效率 [@problem_id:2442361]。", "problem": "考虑一个表示来自液-气临界点附近平衡分子动力学 (MD) 模拟的维里压力的时间序列，在该临界点附近预计会出现大的涨落和长时关联。设离散时间序列表示为 $\\{p_t\\}_{t=1}^N$。对于任意有限序列，定义样本均值 $\\bar{p}$、滞后 k 阶样本自协方差 $C(k)$、归一化样本自相关函数 $\\rho(k)$、积分自相关时间 $\\tau_{\\mathrm{int}}$、统计非效率 $g$ 以及有效无关联样本数 $N_{\\mathrm{eff}}$ 如下：\n$$\n\\bar{p} \\equiv \\frac{1}{N}\\sum_{t=1}^{N} p_t,\n\\quad\nC(k) \\equiv \\frac{1}{N-k}\\sum_{t=1}^{N-k} \\left(p_t-\\bar{p}\\right)\\left(p_{t+k}-\\bar{p}\\right) \\ \\text{for} \\ k=0,1,\\dots,N-1,\n$$\n$$\n\\rho(k) \\equiv \\frac{C(k)}{C(0)},\n\\quad\n\\tau_{\\mathrm{int}} \\equiv 1 + 2 \\sum_{k=1}^{M} \\rho(k),\n\\quad\ng \\equiv \\tau_{\\mathrm{int}},\n\\quad\nN_{\\mathrm{eff}} \\equiv \\frac{N}{g}.\n$$\n截断指数 $M$ 定义为使得所有先前滞后的值都严格为正的最大非负整数，具体为：\n$$\nM \\equiv \\max \\left\\{ m \\in \\{0,1,\\dots,N-1\\}: \\rho(k) > 0 \\ \\text{for all} \\ k \\in \\{1,2,\\dots,m\\} \\right\\}.\n$$\n如果没有出现非正的 $\\rho(k)$，则取 $M \\equiv N-1$。本问题中的所有量均为无量纲，任何角度都必须以弧度为单位进行解释。\n\n您的任务是为一个小型测试套件计算 $\\tau_{\\mathrm{int}}$ 和 $N_{\\mathrm{eff}}$。该测试套件包含多个合成的维里压力序列，这些序列由线性随机递推关系生成，并由下面定义的确定性伪随机“热噪声”驱动。每个序列的长度为 $N$，并且会丢弃长度为 $B$ 的初始暂态部分，以确保近似平稳性。具体来说，伪随机数生成器和噪声的定义如下：\n- 线性同余生成器 (LCG)：整数 $X_{n+1} \\equiv (a X_n + c) \\bmod m$，其中 $m \\equiv 2^{64}$，$a \\equiv 6364136223846793005$，$c \\equiv 1442695040888963407$，种子 $X_0$ 针对每个案例指定。均匀分布偏量为 $U_n \\equiv X_n / m \\in [0,1)$。\n- 标准正态分布偏量 $\\epsilon_t$ 通过 Box-Muller 变换按顺序生成：对于独立的均匀分布值 $U_{2j},U_{2j+1}$，定义\n$$\nZ_{2j} \\equiv \\sqrt{-2 \\ln U_{2j}}\\ \\cos(2\\pi U_{2j+1}), \\quad\nZ_{2j+1} \\equiv \\sqrt{-2 \\ln U_{2j}}\\ \\sin(2\\pi U_{2j+1}),\n$$\n并将 $\\epsilon_t$ 取为序列 $\\{Z_0, Z_1, Z_2, \\dots\\}$。\n\n构建以下三个测试案例，每个案例都通过给定的递推关系生成样本，并在丢弃前 $B$ 个样本后得到一个序列 $\\{p_t\\}_{t=1}^{N}$。在所有案例中，新息噪声为上面定义的 $\\epsilon_t$，任何所需的滞后值的初始条件都设为零。\n- 案例 A（长相关，“理想路径”）：1 阶自回归递推\n$$\np_t = \\phi\\, p_{t-1} + \\epsilon_t,\n$$\n参数为 $N \\equiv 2048$，$B \\equiv 1024$，$\\phi \\equiv 0.95$，种子 $X_0 \\equiv 1$。\n- 案例 B（边界，近似不相关）：1 阶自回归递推\n$$\np_t = \\phi\\, p_{t-1} + \\epsilon_t,\n$$\n参数为 $N \\equiv 2048$，$B \\equiv 0$，$\\phi \\equiv 0.0$，种子 $X_0 \\equiv 2$。\n- 案例 C（边缘案例，振荡相关）：2 阶自回归递推\n$$\np_t = 2 r \\cos(\\omega)\\, p_{t-1} - r^2\\, p_{t-2} + \\epsilon_t,\n$$\n参数为 $N \\equiv 2048$，$B \\equiv 1024$，$r \\equiv 0.9$，$\\omega \\equiv 0.2$ (弧度)，种子 $X_0 \\equiv 3$。\n\n对于每个案例，计算归一化样本自相关函数 $\\rho(k)$、使用上述截断规则的积分自相关时间 $\\tau_{\\mathrm{int}}$ 以及对应的有效样本量 $N_{\\mathrm{eff}}$。对于每个案例，报告数对 $\\left[\\tau_{\\mathrm{int}}, N_{\\mathrm{eff}}\\right]$，四舍五入到 $4$ 位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表由三个按 A、B、C 顺序排列的括号数对组成，并被外层方括号包围。例如，一个语法上有效的输出行必须类似于\n$$\n\\bigl[[\\tau_A, N_{\\mathrm{eff},A}],[\\tau_B, N_{\\mathrm{eff},B}],[\\tau_C, N_{\\mathrm{eff},C}]\\bigr],\n$$\n其中每个数值项都四舍五入到 $4$ 位小数，并以小数形式表示（而非分数）。不应打印任何额外文本。", "solution": "核心目标是从第一性原理出发，根据样本矩和相关性的定义，估计相关样本的时间关联和统计非效率。对于离散平稳序列 $\\{p_t\\}_{t=1}^{N}$，样本均值为 $\\bar{p} \\equiv \\frac{1}{N}\\sum_{t=1}^{N} p_t$。滞后 k 阶样本自协方差定义为\n$$\nC(k) \\equiv \\frac{1}{N-k}\\sum_{t=1}^{N-k} \\left(p_t-\\bar{p}\\right)\\left(p_{t+k}-\\bar{p}\\right),\n$$\n其中 $C(0)$ 等于样本方差。归一化自相关函数为\n$$\n\\rho(k) \\equiv \\frac{C(k)}{C(0)}.\n$$\n积分自相关时间定义为\n$$\n\\tau_{\\mathrm{int}} \\equiv 1 + 2 \\sum_{k=1}^{M} \\rho(k),\n$$\n其中 $M$ 是一个截断指数，必须指定它才能获得有限样本估计。所采用的定义选择 $M$ 为使得所有对于 $k \\in \\{1,\\dots,M\\}$ 的 $\\rho(k)$ 都严格为正的最大非负整数，即 $M$比第一个使 $\\rho(k)$ 变为非正的滞后小一；如果不存在这样的滞后，则设 $M \\equiv N-1$。这一选择确保求和仅包含经验相关函数中可靠的正值部分，防止在长滞后处因带噪声的负值估计而产生伪抵消。统计非效率为 $g \\equiv \\tau_{\\mathrm{int}}$，有效无关联样本数为\n$$\nN_{\\mathrm{eff}} \\equiv \\frac{N}{g}.\n$$\n\n合成的维里压力序列由线性随机递推关系生成，并由确定性伪随机“热噪声”驱动，以确保可复现性。噪声 $\\epsilon_t$ 从一个线性同余生成器 (LCG) 构建，其模数 $m \\equiv 2^{64}$，乘数 $a \\equiv 6364136223846793005$，增量 $c \\equiv 1442695040888963407$，以及针对特定案例的种子 $X_0$。均匀分布偏量为 $U_n \\equiv X_n/m$。成对的均匀分布值通过 Box-Muller 变换生成独立的标准正态变量：\n$$\nZ_{2j} \\equiv \\sqrt{-2 \\ln U_{2j}}\\ \\cos(2\\pi U_{2j+1}), \\quad\nZ_{2j+1} \\equiv \\sqrt{-2 \\ln U_{2j}}\\ \\sin(2\\pi U_{2j+1}),\n$$\n且 $\\epsilon_t$ 为序列 $\\{Z_0, Z_1, \\dots\\}$。然后，序列定义如下：\n- 案例 A：$p_t = \\phi p_{t-1} + \\epsilon_t$，其中 $\\phi \\equiv 0.95$，并丢弃前 $B \\equiv 1024$ 个暂态样本。\n- 案例 B：$p_t = \\phi p_{t-1} + \\epsilon_t$，其中 $\\phi \\equiv 0.0$（白噪声），$B \\equiv 0$。\n- 案例 C：$p_t = 2 r \\cos(\\omega) p_{t-1} - r^2 p_{t-2} + \\epsilon_t$，其中 $r \\equiv 0.9$，$\\omega \\equiv 0.2$ 弧度，并丢弃 $B \\equiv 1024$。\n\n对于每个案例，在生成 $N+B$ 个样本并丢弃前 $B$ 个后，我们得到长度为 $N$ 的平稳序列。为了高效且精确地使用所提供的定义计算经验自协方差，我们减去均值形成 $x_t \\equiv p_t - \\bar{p}$，通过 $x_t$ 与自身的卷积计算线性（非循环）自相关，并将每个滞后值除以贡献项的数量 $(N-k)$ 以匹配 $C(k)$：\n$$\nS(k) \\equiv \\sum_{t=1}^{N-k} x_t x_{t+k}, \\quad C(k) \\equiv \\frac{S(k)}{N-k}, \\quad \\rho(k) \\equiv \\frac{C(k)}{C(0)}.\n$$\n在数值上，$S(k)$ 可以通过对补零以避免循环绕回的零均值数据的功率谱进行离散傅里叶逆变换来获得；然后应用 $(N-k)$ 的无偏归一化。截断指数 $M$ 被找到为 $M \\equiv \\max\\{m \\ge 0 : \\rho(k) > 0 \\ \\forall k \\in \\{1,\\dots,m\\}\\}$，即 $M$ 比第一个非正滞后小一；如果没有非正滞后，则取 $M \\equiv N-1$。最后，\n$$\n\\tau_{\\mathrm{int}} \\equiv 1 + 2 \\sum_{k=1}^{M} \\rho(k), \\quad g \\equiv \\tau_{\\mathrm{int}}, \\quad N_{\\mathrm{eff}} \\equiv \\frac{N}{g}.\n$$\n\n定性地，对于 $\\phi \\equiv 0.95$ 的案例 A，1 阶自回归过程的理论归一化自相关按几何级数衰减，即 $\\rho(k) \\approx \\phi^k$，这给出了一个无限样本积分自相关时间 $\\tau_{\\mathrm{int}} \\approx 1 + \\frac{2\\phi}{1-\\phi}$，当 $\\phi$ 接近 1 时该值很大，意味着 $N_{\\mathrm{eff}}$ 很小。对于 $\\phi \\equiv 0.0$ 的案例 B，当 $k \\ge 1$ 时 $\\rho(k)$ 在零附近波动，通常得到 $M \\equiv 0$，因此 $\\tau_{\\mathrm{int}} \\approx 1$ 且 $N_{\\mathrm{eff}} \\approx N$。对于案例 C，具有共轭复根的 2 阶自回归模型产生阻尼振荡自相关，它在一个中等滞后处穿过零点；因此，$M$ 是有限的，$\\tau_{\\mathrm{int}}$ 是中等大小的，导致 $N_{\\mathrm{eff}}$ 小于 $N$ 但远大于案例 A 中的值。\n\n程序实现了确定性噪声生成器，使用指定的参数和暂态丢弃期 (burn-in) 构建每个时间序列，根据定义计算 $C(k)$、$\\rho(k)$、$\\tau_{\\mathrm{int}}$ 和 $N_{\\mathrm{eff}}$，将每个数值输出四舍五入到 4 位小数，并打印包含以下内容的单行：\n$$\n\\bigl[[\\tau_A, N_{\\mathrm{eff},A}],[\\tau_B, N_{\\mathrm{eff},B}],[\\tau_C, N_{\\mathrm{eff},C}]\\bigr].\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# Deterministic Linear Congruential Generator (LCG) parameters\nLCG_M = 1 << 64\nLCG_A = 6364136223846793005\nLCG_C = 1442695040888963407\n\ndef lcg_uniforms(seed: int, count: int):\n    \"\"\"\n    Generate 'count' uniforms in [0,1) using a 64-bit LCG with given seed.\n    Returns a list of floats.\n    \"\"\"\n    x = seed & (LCG_M - 1)\n    us = []\n    for _ in range(count):\n        x = (LCG_A * x + LCG_C) & (LCG_M - 1)\n        u = x / LCG_M\n        us.append(u)\n    return us\n\ndef box_muller_normals(seed: int, n: int):\n    \"\"\"\n    Generate n standard normal variates using Box-Muller from the LCG uniforms.\n    Seed is for the LCG.\n    \"\"\"\n    # Need 2 * ceil(n/2) uniforms\n    pairs = (n + 1) // 2\n    u = lcg_uniforms(seed, 2 * pairs)\n    normals = []\n    for j in range(pairs):\n        u1 = u[2 * j]\n        u2 = u[2 * j + 1]\n        # Guard against log(0)\n        if u1 == 0.0:\n            u1 = 1.0 / LCG_M\n        r = math.sqrt(-2.0 * math.log(u1))\n        theta = 2.0 * math.pi * u2\n        z0 = r * math.cos(theta)\n        z1 = r * math.sin(theta)\n        normals.append(z0)\n        normals.append(z1)\n    return np.array(normals[:n], dtype=float)\n\ndef generate_ar1(phi: float, N: int, burn: int, seed: int):\n    \"\"\"\n    Generate AR(1): p_t = phi * p_{t-1} + epsilon_t\n    epsilon_t ~ N(0,1), via deterministic Box-Muller using LCG with given seed.\n    Start from p_0 = 0. Discard burn-in samples and return last N.\n    \"\"\"\n    total = N + burn\n    eps = box_muller_normals(seed, total)\n    p_prev = 0.0\n    series = np.empty(total, dtype=float)\n    for t in range(total):\n        p_t = phi * p_prev + eps[t]\n        series[t] = p_t\n        p_prev = p_t\n    if burn > 0:\n        series = series[burn:]\n    return series\n\ndef generate_ar2_osc(r: float, omega: float, N: int, burn: int, seed: int):\n    \"\"\"\n    Generate AR(2) with complex-conjugate roots r * exp(± i omega):\n      p_t = 2 r cos(omega) p_{t-1} - r^2 p_{t-2} + epsilon_t\n    epsilon_t ~ N(0,1), via deterministic Box-Muller using LCG with given seed.\n    Start with p_{-1} = 0, p_0 = 0. Discard burn-in and return last N.\n    \"\"\"\n    total = N + burn\n    eps = box_muller_normals(seed, total)\n    a1 = 2.0 * r * math.cos(omega)\n    a2 = - (r ** 2)\n    p_im2 = 0.0  # p_{t-2}\n    p_im1 = 0.0  # p_{t-1}\n    series = np.empty(total, dtype=float)\n    for t in range(total):\n        p_t = a1 * p_im1 + a2 * p_im2 + eps[t]\n        series[t] = p_t\n        p_im2, p_im1 = p_im1, p_t\n    if burn > 0:\n        series = series[burn:]\n    return series\n\ndef unbiased_acf(x: np.ndarray):\n    \"\"\"\n    Compute unbiased autocovariance and normalized autocorrelation rho(k)\n    for k = 0..N-1 using FFT-based linear autocorrelation.\n    Returns rho as a 1D numpy array of length N.\n    \"\"\"\n    N = x.shape[0]\n    x_centered = x - np.mean(x)\n    # Next power of two for zero-padding to avoid circular correlation\n    nfft = 1 << (2 * N - 1).bit_length()\n    # Real FFT\n    f = np.fft.rfft(x_centered, n=nfft)\n    # Power spectrum and inverse FFT to get linear autocorrelation sequence\n    acf_full = np.fft.irfft(f * np.conj(f), n=nfft).real[:N]\n    # Unbiased normalization\n    counts = np.arange(N, 0, -1)  # N, N-1, ..., 1\n    cov_unbiased = acf_full / counts\n    var0 = cov_unbiased[0]\n    if var0 <= 0:\n        # Degenerate case: constant series or numerical issue; return zeros except rho(0)=1\n        rho = np.zeros(N, dtype=float)\n        rho[0] = 1.0\n        return rho\n    rho = cov_unbiased / var0\n    return rho\n\ndef integrated_autocorrelation_time(rho: np.ndarray):\n    \"\"\"\n    Compute tau_int = 1 + 2 sum_{k=1}^M rho(k),\n    where M is one less than the first nonpositive lag; if none, M = N-1.\n    \"\"\"\n    N = rho.shape[0]\n    # Find first k >= 1 such that rho[k] <= 0\n    nonpos = np.where(rho[1:] <= 0.0)[0]\n    if nonpos.size > 0:\n        first_nonpos_k = int(nonpos[0]) + 1  # adjust for slicing offset\n        M = first_nonpos_k - 1\n    else:\n        M = N - 1\n    if M <= 0:\n        return 1.0  # sum is empty, tau_int = 1\n    s = float(np.sum(rho[1:M+1]))\n    tau_int = 1.0 + 2.0 * s\n    # Ensure non-negative due to possible tiny numerical noise\n    if tau_int < 0.0:\n        tau_int = 0.0\n    return tau_int\n\ndef analyze_series(p: np.ndarray):\n    \"\"\"\n    Given a series p, compute rho, tau_int, and N_eff with the specified definitions.\n    \"\"\"\n    N = p.shape[0]\n    rho = unbiased_acf(p)\n    tau = integrated_autocorrelation_time(rho)\n    g = tau\n    # Protect against division by zero\n    if g <= 0:\n        neff = float('inf')\n    else:\n        neff = N / g\n    return tau, neff\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A: AR(1) with phi = 0.95, N=2048, B=1024, seed=1\n    N_A, B_A, phi_A, seed_A = 2048, 1024, 0.95, 1\n    series_A = generate_ar1(phi_A, N_A, B_A, seed_A)\n\n    # Case B: AR(1) with phi = 0.0, N=2048, B=0, seed=2\n    N_B, B_B, phi_B, seed_B = 2048, 0, 0.0, 2\n    series_B = generate_ar1(phi_B, N_B, B_B, seed_B)\n\n    # Case C: AR(2) with r=0.9, omega=0.2, N=2048, B=1024, seed=3\n    N_C, B_C, r_C, omega_C, seed_C = 2048, 1024, 0.9, 0.2, 3\n    series_C = generate_ar2_osc(r_C, omega_C, N_C, B_C, seed_C)\n\n    results = []\n    for series in (series_A, series_B, series_C):\n        tau, neff = analyze_series(series)\n        # Round to 4 decimal places\n        tau_r = f\"{tau:.4f}\"\n        neff_r = f\"{neff:.4f}\"\n        results.append(f\"[{tau_r},{neff_r}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2442361"}, {"introduction": "在第一個練習中，我們處理了已知的時間序列；現在，我們將更進一步，從一個物理模型中親手生成數據。本練習要求你构建一个微正则系综（NVE）分子动力学模拟的简化模型，并从中生成“瞬时温度”的时间序列 [@problem_id:2442392]。这让你能亲身体验从第一性原理出发，观察物理系统的动态如何自然地产生相关数据，并应用自相关分析来量化其“记忆时间”。", "problem": "要求您构建一个独立的程序，用于生成和分析一个微正则（恒定粒子数、体积和能量）系综 (NVE) 分子动力学 (MD) 系统的瞬时温度确定性时间序列。考虑一个系统，其模型为 $M$ 个质量为单位1、无相互作用的经典一维谐振子。对于振子 $j \\in \\{1,\\dots,M\\}$，其角频率为 $\\omega_j$，初始相位为 $\\phi_j$，总能量为 $E_j$。位置和速度满足运动方程 $\\ddot{x}_j(t) + \\omega_j^2 x_j(t) = 0$，其中 $m_j = 1$。振子 $j$ 的瞬时动能为 $K_j(t) = \\tfrac{1}{2} v_j(t)^2$，对于谐振动，这可以得出 $K_j(t) = E_j \\sin^2(\\omega_j t + \\phi_j)$。总动能为 $K(t) = \\sum_{j=1}^M K_j(t)$。\n\n将瞬时温度时间序列定义为\n$$\nT_{\\mathrm{inst}}(t) = \\frac{2}{f k_{\\mathrm{B}}}\\,K(t),\n$$\n其中 $f$ 是速度自由度数，$k_{\\mathrm{B}}$ 是 Boltzmann 常数。使用无量纲单位，取 $k_{\\mathrm{B}} = 1$ 且 $f = M$。设离散采样时间为 $t_n = n\\,\\Delta t$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。\n\n对于给定的离散时间序列 $\\{T_{\\mathrm{inst}}(t_n)\\}_{n=0}^{N-1}$，定义样本均值 $\\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} T_{\\mathrm{inst}}(t_n)$、离散自协方差\n$$\n\\Gamma(\\ell) = \\frac{1}{N - \\ell} \\sum_{n=0}^{N-1-\\ell} \\big(T_{\\mathrm{inst}}(t_n) - \\mu\\big)\\,\\big(T_{\\mathrm{inst}}(t_{n+\\ell}) - \\mu\\big), \\quad \\ell \\in \\{0,1,\\dots,N-1\\},\n$$\n以及归一化自相关\n$$\n\\rho(\\ell) = \\frac{\\Gamma(\\ell)}{\\Gamma(0)}.\n$$\n定义统计非效率\n$$\ng = 1 + 2 \\sum_{\\ell=1}^{L^\\star} \\rho(\\ell),\n$$\n其中 $L^\\star$ 是满足对于所有 $\\ell \\in \\{1,2,\\dots,L^\\star\\}$ 都有 $\\rho(\\ell) > 0$ 的最大非负整数，并且满足 $L^\\star = N-1$ 或 $\\rho(L^\\star+1) \\le 0$。将积分自相关时间定义为\n$$\n\\tau_{\\mathrm{int}} = \\frac{\\Delta t}{2}\\, g,\n$$\n这样样本均值的方差将符合标准的连续时间关系。\n\n您的程序必须对下面的每个测试用例，使用上述模型从第一性原理生成 $T_{\\mathrm{inst}}(t_n)$，计算 $\\rho(\\ell)$ 直到出现第一个非正值，然后使用上述定义计算 $g$ 和 $\\tau_{\\mathrm{int}}$。\n\n测试套件（所有量均为无量纲）：\n- 用例 $\\mathcal{A}$:\n  - $M = 1$, $N = 4096$, $\\Delta t = 0.01$,\n  - $\\omega_1 = 1.5$, $\\phi_1 = 0.37$, $E_1 = 1.0$.\n- 用例 $\\mathcal{B}$:\n  - $M = 2$, $N = 4096$, $\\Delta t = 0.01$,\n  - $(\\omega_1,\\omega_2) = \\big(1.0, \\sqrt{2}\\big)$,\n  - $(\\phi_1,\\phi_2) = (0.1, 1.3)$,\n  - $(E_1,E_2) = (1.0, 0.6)$.\n- 用例 $\\mathcal{C}$:\n  - $M = 10$, $N = 8192$, $\\Delta t = 0.005$,\n  - $\\omega_j$ 在闭区间 $[0.5, 2.0]$上对 $j \\in \\{1,\\dots,10\\}$ 线性分布，\n  - $\\phi_j = \\big(j \\pi / 7\\big) \\bmod (2\\pi)$ 对 $j \\in \\{1,\\dots,10\\}$，\n  - $E_j = 1.0$ 对所有 $j \\in \\{1,\\dots,10\\}$。\n\n对每个用例，报告序对 $\\big[\\tau_{\\mathrm{int}}, g\\big]$。$\\tau_{\\mathrm{int}}$ 的时间单位应与 $t$ 和 $\\Delta t$ 相同。您的程序应生成单行输出，包含结果，格式为由逗号分隔的外部列表和内部列表，且无空格，格式如下：`[[\\tau_{\\mathrm{int}}^{(\\mathcal{A})},g^{(\\mathcal{A})}],[\\tau_{\\mathrm{int}}^{(\\mathcal{B})},g^{(\\mathcal{B})}],[\\tau_{\\mathrm{int}}^{(\\mathcal{C})},g^{(\\mathcal{C})}]]`。", "solution": "问题陈述已经过严格验证，并被确定为有效。它具有科学依据，数学上是适定的，并为获得唯一解提供了完整且一致的定义和数据。因此，我们可以着手进行解的推导和实现。\n\n问题要求计算瞬时温度 $T_{\\mathrm{inst}}(t)$ 时间序列的统计非效率 $g$ 和积分自相关时间 $\\tau_{\\mathrm{int}}$。该时间序列由一个包含 $M$ 个无相互作用的一维经典谐振子的确定性模型生成。\n\n瞬时温度在无量纲单位（$k_{\\mathrm{B}}=1$）下，以 $f=M$ 个自由度定义为：\n$$\nT_{\\mathrm{inst}}(t) = \\frac{2}{M} K(t)\n$$\n其中 $K(t)$ 是系统的总动能。对于一个由 $M$ 个质量为单位1 ($m_j=1$)、初始参数为 $(\\omega_j, \\phi_j, E_j)$ 的谐振子组成的系统，总动能由各个动能之和给出：\n$$\nK(t) = \\sum_{j=1}^{M} K_j(t) = \\sum_{j=1}^{M} E_j \\sin^2(\\omega_j t + \\phi_j)\n$$\n因此，瞬时温度的表达式变为：\n$$\nT_{\\mathrm{inst}}(t) = \\frac{2}{M} \\sum_{j=1}^{M} E_j \\sin^2(\\omega_j t + \\phi_j)\n$$\n该函数在离散时间点 $t_n = n\\,\\Delta t$（其中 $n \\in \\{0, 1, \\dots, N-1\\}$）进行采样，生成一个离散时间序列 $\\{T_n\\} \\equiv \\{T_{\\mathrm{inst}}(t_n)\\}$。\n\n对此时间序列的后续分析遵循一个标准的统计流程。首先，我们计算该序列的样本均值：\n$$\n\\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} T_n\n$$\n接着，我们计算时间延迟为 $\\ell$ 步的离散、无偏自协方差函数 $\\Gamma(\\ell)$：\n$$\n\\Gamma(\\ell) = \\frac{1}{N - \\ell} \\sum_{n=0}^{N-1-\\ell} \\big(T_n - \\mu\\big)\\,\\big(T_{n+\\ell} - \\mu\\big)\n$$\n用方差 $\\Gamma(0)$ 对其进行归一化，以获得归一化自相关函数 $\\rho(\\ell)$：\n$$\n\\rho(\\ell) = \\frac{\\Gamma(\\ell)}{\\Gamma(0)}\n$$\n统计非效率 $g$ 量化了为获得一个独立样本所需的模拟步数。它是通过对自相关函数积分来计算的：\n$$\ng = 1 + 2 \\sum_{\\ell=1}^{L^\\star} \\rho(\\ell)\n$$\n求和的截断点 $L^\\star$ 定义为使自相关 $\\rho(\\ell)$ 对于所有之前的延迟 $\\ell \\in \\{1, 2, \\dots, L^\\star\\}$ 都保持为正的最大整数。求和必须在自相关函数变为非正的第一个延迟处终止。如果对于所有 $\\ell \\in \\{1, \\dots, N-1\\}$ 都有 $\\rho(\\ell) > 0$，则 $L^\\star = N-1$。\n\n最后，积分自相关时间 $\\tau_{\\mathrm{int}}$ 由统计非效率和模拟时间步长 $\\Delta t$ 决定：\n$$\n\\tau_{\\mathrm{int}} = \\frac{\\Delta t}{2}\\, g\n$$\n这个值代表了系统“记忆”持续存在的特征时间。\n\n针对每个测试用例解决该问题的算法步骤如下：\n1.  初始化特定用例的参数：$M, N, \\Delta t$，以及振子参数集 $\\{\\omega_j\\}$、$\\{\\phi_j\\}$ 和 $\\{E_j\\}$。\n2.  生成离散时间向量 $t_n = n\\Delta t$，其中 $n = 0, \\dots, N-1$。\n3.  通过计算 $T_{\\mathrm{inst}}(t_n)$ 的解析表达式来构建瞬时温度时间序列 $\\{T_n\\}$。为提高效率，这是一个向量化操作。\n4.  计算时间序列 $\\{T_n\\}$ 的样本均值 $\\mu$。\n5.  通过减去均值来中心化时间序列：$T'_n = T_n - \\mu$。\n6.  计算方差 $\\Gamma(0) = \\frac{1}{N}\\sum_{n=0}^{N-1} (T'_n)^2$。\n7.  对延迟 $\\ell$ 从 1 到 $N-1$ 进行迭代。在每一步中：\n    a. 计算自协方差和 $\\sum_{n=0}^{N-1-\\ell} T'_n T'_{n+\\ell}$。\n    b. 通过除以归一化因子 $N-\\ell$ 计算 $\\Gamma(\\ell)$。\n    c. 计算 $\\rho(\\ell) = \\Gamma(\\ell) / \\Gamma(0)$。\n    d. 如果 $\\rho(\\ell) \\le 0$，则满足终止条件。设 $L^\\star = \\ell-1$ 并跳出循环。$g$ 的求和完成。\n    e. 如果 $\\rho(\\ell) > 0$，则将其加入用于计算 $g$ 的累加和中。如果循环完成而未跳出，则 $L^\\star=N-1$。\n8.  计算统计非效率 $g = 1 + 2 \\sum_{\\ell=1}^{L^\\star} \\rho(\\ell)$。\n9.  计算积分自相关时间 $\\tau_{\\mathrm{int}} = \\frac{\\Delta t}{2} g$。\n10. 存储结果序对 $[\\tau_{\\mathrm{int}}, g]$。\n\n对提供的三个测试用例均执行此程序。数值实现依赖于 `numpy` 库来进行高效的数组操作。最终结果按照规定格式化为单个字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            \"M\": 1, \"N\": 4096, \"dt\": 0.01,\n            \"omegas\": np.array([1.5]),\n            \"phis\": np.array([0.37]),\n            \"Es\": np.array([1.0]),\n        },\n        # Case B\n        {\n            \"M\": 2, \"N\": 4096, \"dt\": 0.01,\n            \"omegas\": np.array([1.0, np.sqrt(2)]),\n            \"phis\": np.array([0.1, 1.3]),\n            \"Es\": np.array([1.0, 0.6]),\n        },\n        # Case C\n        {\n            \"M\": 10, \"N\": 8192, \"dt\": 0.005,\n            \"omegas\": np.linspace(0.5, 2.0, 10),\n            \"phis\": (np.arange(1, 11) * np.pi / 7) % (2 * np.pi),\n            \"Es\": np.ones(10),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_autocorrelation_properties(case)\n        results.append(result)\n\n    # Format the output string to be exactly as required, without spaces within lists.\n    output_str = f\"[{','.join(f'[{tau},{g}]' for tau, g in results)}]\"\n    print(output_str)\n\ndef calculate_autocorrelation_properties(params):\n    \"\"\"\n    Calculates tau_int and g for a single test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        tuple: A tuple containing (tau_int, g).\n    \"\"\"\n    M = params[\"M\"]\n    N = params[\"N\"]\n    dt = params[\"dt\"]\n    omegas = params[\"omegas\"]\n    phis = params[\"phis\"]\n    Es = params[\"Es\"]\n\n    # 1. Generate the time series for instantaneous temperature\n    t = np.arange(N) * dt\n    T_inst = np.zeros(N)\n\n    # Sum contributions from each oscillator\n    for j in range(M):\n        arg = omegas[j] * t + phis[j]\n        T_inst += Es[j] * np.sin(arg)**2\n    \n    T_inst *= (2.0 / M)\n    \n    # 2. Calculate sample mean and center the series\n    mu = np.mean(T_inst)\n    T_prime = T_inst - mu\n\n    # 3. Calculate variance Gamma(0)\n    # The problem defines Gamma(l) with 1/(N-l) prefactor.\n    # For l=0, Gamma(0) = (1/N) * sum((T_n - mu)^2).\n    # np.var calculates (1/N) * sum((x-mean(x))^2), which matches.\n    gamma_0 = np.var(T_inst)\n\n    if gamma_0 == 0:\n        # If variance is zero, the series is constant.\n        # Autocorrelation is undefined, but g=1 and tau_int = dt/2 is a reasonable limit.\n        g = 1.0\n        tau_int = 0.5 * dt * g\n        return tau_int, g\n\n    # 4. Find L_star and sum rho(l)\n    sum_rho = 0.0\n    # L_star is largest l <= N-2 s.t. rho(1...l) > 0\n    # but the problem formulation uses l in {1,...,L_star}.\n    # We sum rho(l) for l > 0 as long as rho(l) is positive.\n    for l in range(1, N):\n        # Calculate autocovariance Gamma(l)\n        # Gamma(l) = 1/(N-l) * sum_{n=0}^{N-l-1} (T_n-mu)(T_{n+l}-mu)\n        numerator = np.dot(T_prime[0:N-l], T_prime[l:N])\n        gamma_l = numerator / (N - l)\n        \n        # Calculate normalized autocorrelation rho(l)\n        rho_l = gamma_l / gamma_0\n        \n        if rho_l > 0:\n            sum_rho += rho_l\n        else:\n            # First non-positive rho(l) found, stop summation.\n            break\n            \n    # 5. Calculate g and tau_int\n    # g = 1 + 2 * sum_{l=1}^{L_star} rho(l)\n    g = 1.0 + 2.0 * sum_rho\n    \n    # tau_int = (dt/2) * g\n    tau_int = 0.5 * dt * g\n    \n    return tau_int, g\n\nsolve()\n```", "id": "2442392"}, {"introduction": "在实际的蒙特卡洛模拟中，我们不仅关心稳态下的误差，还必须确保模拟已经达到了稳态（或称“平衡”）。本练习介绍了一种非常强大且实用的技术——分块法（blocking method），用于估计相关数据的统计误差，并设计一个判据来检测系统是否处于非稳态 [@problem_id:2442379]。完成此练习将使你掌握一种在科研实践中诊断模拟质量和获取可靠误差估计的关键工具。", "problem": "你的任务是实现分块法（也称分箱法），用以估计由马尔可夫链蒙特卡洛 (MCMC) 模拟产生的相关数据的样本均值的标准误，并设计一个仅基于分块曲线的定量判据，以检测系统是否未达到平衡（非平稳性）。你可以假定的基本前提包括：平稳时间序列的自协方差函数的定义，积分自相关时间的定义，独立同分布 (i.i.d.) 数据的样本均值方差等于总体方差除以样本量这一事实，以及当块大小大于自相关时间时，分块法通过将块平均值近似视为独立来估计样本均值方差的经验观察。除这些核心定义外，你不得假定任何简化公式。\n\n用作起点的定义：\n- 令 $\\{X_t\\}_{t=1}^N$ 为一个标量时间序列。对于一个均值为 $\\mu$、自协方差函数为 $\\gamma(k)=\\mathbb{E}[(X_t-\\mu)(X_{t+k}-\\mu)]$ 的平稳过程，积分自相关时间定义为 $\\tau_{\\mathrm{int}}=1+2\\sum_{k=1}^{\\infty}\\rho(k)$，其中 $\\rho(k)=\\gamma(k)/\\gamma(0)$ 是自相关函数。在平稳性和弱混合假设下，样本均值 $\\bar{X}=\\frac{1}{N}\\sum_{t=1}^N X_t$ 的方差表现为 $\\mathrm{Var}(\\bar{X})\\approx \\frac{\\sigma^2\\tau_{\\mathrm{int}}}{N}$，其中 $\\sigma^2=\\gamma(0)$。\n- 分块法将数据划分为 $m$ 个大小相等的不重叠连续数据块，每块大小为 $b$（因此 $m=\\lfloor N/b\\rfloor$），并计算块平均值。当 $b$ 足够大时，这些块平均值近似不相关，其样本方差除以 $m$ 即为对总体均值方差的估计。\n\n你的程序必须：\n1) 根据以下规则构建类似MCMC的合成时间序列。所有链均为一阶自回归 (AR(1)) 实值过程，参数为 $\\phi$，均值 $\\mu_t$ 随时间变化，由递推关系 $X_{t+1}=\\phi X_t + (1-\\phi)\\mu_t + \\eta_{t+1}$ 给出，其中 $\\eta_{t}$ 是独立的零均值高斯随机变量，其方差的选择要使得平稳方差（当 $\\mu_t$ 为常数且 $|\\phi| < 1$ 时）近似为1。具体地，你必须使用 $\\mathrm{Var}(\\eta_t)=1-\\phi^2$，这样对于恒定的 $\\mu_t$，过程的平稳方差接近于1。\n2) 对于给定的序列 $\\{X_t\\}_{t=1}^N$，按如下方式实现分块估计器。对于块大小 $b=2^k$（其中 $k\\in\\{0,1,2,\\dots\\}$），仅考虑那些使得完整数据块数量 $m=\\lfloor N/b\\rfloor$ 至少为8的 $b$。对于每个这样的 $b$，计算 $m$ 个连续块的平均值，然后计算这些块平均值的无偏样本方差。块大小为 $b$ 时总体均值的估计方差即为块平均值的样本方差除以 $m$。相应的标准误是该方差的平方根。此过程会生成一个作为 $b$ 的函数的标准误估计序列（即分块曲线）。\n3) 设计一个仅基于分块曲线在最大可达块大小处的形状的定量判据，以判断链是否已达到平衡。你必须使用精确、可检验的不等式将该判据形式化。对于本问题，按如下方式定义分块曲线末端的“平台期”：取最后 $K$ 个有效块大小（使用 $K=4$，如果有效块大小数量少于4，则使用所有可用的），计算它们的标准误估计值的中位数，以及定义为这 $K$ 个点上的 $(\\max-\\min)/\\text{median}$ 的相对范围。当且仅当这些尾部数据点上的相对范围小于或等于阈值 $R_\\star=0.15$，并且至少有3个尾部数据点时，宣布链已平衡。否则，宣布其未平衡。\n4) 使用平台期标准误估计值（取为最后 $K$ 个块大小的中位数），结合原始序列的样本方差 $s^2$，通过将平台期均值方差与 i.i.d. 均值方差基线进行比较，构造一个积分自相关时间 $\\tau_{\\mathrm{int}}$ 的估计量。你的估计量必须仅是 $N$、平台期标准误和 $s^2$ 的函数，并且必须与上述基本定义一致。\n\n测试套件。你必须在以下四个测试用例上运行你的代码，每个用例由 $(N,\\phi,\\mu_t,\\text{seed},X_1)$ 定义：\n- 用例 A（平稳，长链）：$N=65536$，$\\phi=0.9$，恒定均值 $\\mu_t\\equiv 0$，种子 $=101$，初始值 $X_1=0$。\n- 用例 B（慢弛豫，短链，远离平衡态的起始点）：$N=8192$，$\\phi=0.9995$，恒定均值 $\\mu_t\\equiv 0$，种子 $=202$，初始值 $X_1=20$。\n- 用例 C（平稳，短链）：$N=2048$，$\\phi=0.5$，恒定均值 $\\mu_t\\equiv 0$，种子 $=303$，初始值 $X_1=0$。\n- 用例 D（分段常数均值漂移）：$N=65536$，$\\phi=0.9$，当 $t\\le N/2$ 时均值 $\\mu_t=0$，当 $t > N/2$ 时均值 $\\mu_t=1$，种子 $=404$，初始值 $X_1=0$。\n\n对于每个用例，你的程序必须输出：\n- 一个布尔值，指示你的平台期判据是否宣布链已平衡。\n- 根据第4项中指定的平台期标准误和原始样本方差构造的 $\\tau_{\\mathrm{int}}$ 的浮点估计值。\n- 根据第3项中指定的平台期标准误的浮点估计值。\n\n数值报告要求：\n- 所有浮点输出必须四舍五入到六位小数。\n- 本问题中没有物理或角度单位。\n- 最终输出必须是单行文本，包含一个有四个元素的JSON数组，每个元素对应一个测试用例。每个元素本身是一个形式为 `[equilibrated, \\tau_{\\mathrm{int}}, SE]` 的JSON数组，其中布尔值是JSON布尔类型，两个浮点数是四舍五入到六位小数的十进制数。例如，一个有效的输出格式是 `[[true,1.234000,0.056000],[\\dots],\\dots]`。\n\n你的程序应该生成单行输出，其中包含一个如上所述格式的JSON数组的数组，不含任何额外文本。给定上述种子，程序必须是完全确定性的，并且不得要求任何用户输入。", "solution": "该问题是良定的、科学上合理的，并为一项计算任务提供了完整、自洽的规范。因此，该问题是有效的。我将继续提供解决方案。\n\n该任务要求实现分块法来分析相关的时间序列数据，特别是估计样本均值的标准误，并设计一个检测非平稳性的判据。此外，还必须推导并实现一个积分自相关时间的估计量。\n\n首先，我们处理合成时间序列的生成。问题指定了一个一阶自回归过程，或称 AR(1) 过程，由以下递推关系定义：\n$$X_{t+1} = \\phi X_t + (1-\\phi)\\mu_t + \\eta_{t+1}$$\n这里，$\\{X_t\\}_{t=1}^N$是长度为 $N$ 的时间序列，$\\phi$ 是自回归参数，$\\mu_t$ 是一个可能随时间变化的均值，而 $\\eta_{t+1}$ 是从零均值高斯分布中抽取的独立同分布随机变量，即 $\\eta_t \\sim \\mathcal{N}(0, \\sigma_\\eta^2)$。噪声的方差被指定为 $\\sigma_\\eta^2 = 1-\\phi^2$。这个选择是经过考虑的；对于一个 $\\mu_t$ 为常数 $\\mu$ 且 $|\\phi| < 1$ 的平稳过程，中心化过程 $Y_t = X_t - \\mu$ 遵循 $Y_t = \\phi Y_{t-1} + \\eta_t$。其平稳方差为 $\\mathrm{Var}(Y_t) = \\mathrm{Var}(\\eta_t) / (1-\\phi^2)$。通过我们选择的 $\\mathrm{Var}(\\eta_t) = 1-\\phi^2$，该过程的平稳方差变为 $\\sigma^2 = \\mathrm{Var}(X_t) = 1$。这使波动的内禀尺度被归一化。\n\n接下来，我们实现分块法。对于一个平稳时间序列 $\\{X_t\\}_{t=1}^N$，样本均值为 $\\bar{X} = \\frac{1}{N}\\sum_{t=1}^N X_t$。这个样本均值的方差不像独立数据那样简单地为 $\\sigma^2/N$，而是因相关性而被放大。正确的渐近公式是：\n$$\\mathrm{Var}(\\bar{X}) \\approx \\frac{\\sigma^2 \\tau_{\\mathrm{int}}}{N}$$\n其中 $\\sigma^2$ 是过程的方差，$\\tau_{\\mathrm{int}}$ 是积分自相关时间，由 $\\tau_{\\mathrm{int}} = 1 + 2\\sum_{k=1}^{\\infty} \\rho(k)$ 给出，而 $\\rho(k)$ 是自相关函数。分块法直接提供了 $\\mathrm{Var}(\\bar{X})$ 的一个估计。数据被划分为 $m = \\lfloor N/b \\rfloor$ 个大小为 $b$ 的不重叠数据块。对于每个数据块 $j \\in \\{1, \\dots, m\\}$，我们计算其块平均值：\n$$\\bar{X}_j^{(b)} = \\frac{1}{b} \\sum_{i=1}^{b} X_{(j-1)b+i}$$\n当块大小 $b$ 远大于 $\\tau_{\\mathrm{int}}$ 时，块平均值序列 $\\{\\bar{X}_j^{(b)}\\}_{j=1}^m$ 近似变为独立同分布。因此，我们可以将它们视为一个包含 $m$ 个独立样本的集合。这些样本的均值的方差，也就是 $\\mathrm{Var}(\\bar{X})$ 的一个估计量，由样本均值方差的标准公式给出：\n$$V_b = \\frac{s^2_{\\text{blocks}}(b)}{m}$$\n其中 $s^2_{\\text{blocks}}(b)$ 是块平均值的无偏样本方差：\n$$s^2_{\\text{blocks}}(b) = \\frac{1}{m-1} \\sum_{j=1}^{m} \\left(\\bar{X}_j^{(b)} - \\left(\\frac{1}{m}\\sum_{l=1}^m \\bar{X}_l^{(b)}\\right)\\right)^2$$\n块大小为 $b$ 时的均值标准误即为 $SE_b = \\sqrt{V_b}$。只要数据块数量 $m$ 至少为8，就对块大小 $b=2^k$（其中 $k=0, 1, 2, \\dots$）执行此过程。这将生成“分块曲线”，即 $SE_b$ 对 $b$ 的图。\n\n分块曲线的形状用于诊断非平稳性。对于一个平稳过程，随着 $b$ 增大，$SE_b$ 最初会上升（因为短程相关性被平均掉），然后在 $b \\gg \\tau_{\\mathrm{int}}$ 时收敛到一个平台。而对于一个非平稳过程，例如带有漂移或趋势的过程，块间方差会随着 $b$ 持续增大，导致 $SE_b$ 不会出现平台。我们按如下方式形式化一个平台期判据：\n1. 考虑最后 $K$ 个有效的块大小，其中 $K$ 是4与有效块大小总数的较小者。\n2. 令相应的标准误估计值为 $\\{S_1, S_2, \\dots, S_K\\}$。\n3. 计算中位数，$S_{\\text{median}} = \\text{median}(S_1, \\dots, S_K)$。\n4. 计算相对范围，$R = \\frac{\\max(S_1, \\dots, S_K) - \\min(S_1, \\dots, S_K)}{S_{\\text{median}}}$。检查 $S_{\\text{median}}>0$ 是审慎的做法。\n5. 当且仅当 $R \\le R_\\star = 0.15$ 且尾部数据点数量 $K$ 至少为3时，该过程被宣布为“已平衡”（平稳）。\n平台期标准误估计值 $SE_{\\text{plateau}}$ 被定义为 $S_{\\text{median}}$，无论是否满足平衡判据。\n\n最后，我们构造积分自相关时间 $\\hat{\\tau}_{\\mathrm{int}}$ 的一个估计量。我们从基本关系 $\\mathrm{Var}(\\bar{X}) \\approx \\frac{\\sigma^2 \\tau_{\\mathrm{int}}}{N}$ 出发。从我们的数据中可以得到两个估计量：\n- 来自于分块法平台期的 $\\mathrm{Var}(\\bar{X})$ 的估计：$(SE_{\\text{plateau}})^2$。\n- 来自于原始数据的样本方差的过程方差 $\\sigma^2$ 的估计：$s^2 = \\frac{1}{N-1}\\sum_{t=1}^N (X_t - \\bar{X})^2$。\n将这些代入关系式，得到：\n$$(SE_{\\text{plateau}})^2 \\approx \\frac{s^2 \\hat{\\tau}_{\\mathrm{int}}}{N}$$\n解出我们的估计量 $\\hat{\\tau}_{\\mathrm{int}}$，可得：\n$$\\hat{\\tau}_{\\mathrm{int}} = \\frac{N \\cdot (SE_{\\text{plateau}})^2}{s^2}$$\n这个公式将均值方差的宏观估计与微观样本方差联系起来，从而提取出统计非效率因子 $\\tau_{\\mathrm{int}}$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the blocking method to estimate standard error and autocorrelation time\n    for AR(1) processes and applies a quantitative criterion for non-stationarity.\n    \"\"\"\n\n    def generate_ar1_series(N, phi, mu_func, seed, X1):\n        \"\"\"Generates an AR(1) time series.\"\"\"\n        rng = np.random.default_rng(seed)\n        noise_std = np.sqrt(1 - phi**2)\n        # Generate all noise values at once for efficiency\n        eta = rng.normal(loc=0.0, scale=noise_std, size=N - 1)\n        \n        X = np.zeros(N)\n        X[0] = X1\n        \n        for t in range(N - 1):\n            # mu_t influences the state at t+1\n            mu_t_val = mu_func(t)\n            X[t+1] = phi * X[t] + (1 - phi) * mu_t_val + eta[t]\n            \n        return X\n\n    test_cases = [\n        # Case A: Stationary, long chain\n        {'N': 65536, 'phi': 0.9, 'mu_func': lambda t: 0.0, 'seed': 101, 'X1': 0.0},\n        # Case B: Slow relaxation, far-from-equilibrium start\n        {'N': 8192, 'phi': 0.9995, 'mu_func': lambda t: 0.0, 'seed': 202, 'X1': 20.0},\n        # Case C: Stationary, short chain\n        {'N': 2048, 'phi': 0.5, 'mu_func': lambda t: 0.0, 'seed': 303, 'X1': 0.0},\n        # Case D: Piecewise-constant mean shift (non-stationary)\n        {'N': 65536, 'phi': 0.9, 'mu_func': lambda t, N_val=65536: 1.0 if (t + 1) > N_val / 2 else 0.0, 'seed': 404, 'X1': 0.0}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        phi = case['phi']\n        mu_func = case['mu_func']\n        seed = case['seed']\n        X1 = case['X1']\n\n        # 1. Generate time series\n        series = generate_ar1_series(N, phi, mu_func, seed, X1)\n        \n        # 2. Implement blocking estimator\n        se_values = []\n        k = 0\n        while True:\n            b = 2**k\n            m = N // b\n            if m < 8:\n                break\n            \n            # Truncate data to fit full blocks\n            data_to_block = series[:m*b]\n            # Reshape into m blocks of size b\n            blocks = data_to_block.reshape((m, b))\n            # Compute block averages\n            block_averages = blocks.mean(axis=1)\n            \n            # Unbiased sample variance of block averages\n            var_of_block_averages = np.var(block_averages, ddof=1)\n            \n            # Estimated variance of the overall mean\n            var_of_mean = var_of_block_averages / m\n            se = np.sqrt(var_of_mean)\n            se_values.append(se)\n            \n            k += 1\n\n        # 3. Apply equilibrium criterion\n        num_points = len(se_values)\n        K = min(4, num_points)\n        \n        is_equilibrated = False\n        se_plateau = 0.0\n        \n        if K > 0:\n            tail_points = np.array(se_values[-K:])\n            se_plateau = np.median(tail_points)\n\n            if K >= 3:\n                R_star = 0.15\n                se_min = np.min(tail_points)\n                se_max = np.max(tail_points)\n                \n                relative_range = 0.0\n                if se_plateau > 0:\n                    relative_range = (se_max - se_min) / se_plateau\n                \n                if relative_range <= R_star:\n                    is_equilibrated = True\n\n        # 4. Estimate tau_int\n        raw_sample_var = np.var(series, ddof=1)\n        tau_int = 0.0\n        if raw_sample_var > 0:\n            tau_int = (N * se_plateau**2) / raw_sample_var\n        \n        results.append(f\"[{str(is_equilibrated).lower()},{tau_int:.6f},{se_plateau:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2442379"}]}