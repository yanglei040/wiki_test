{"hands_on_practices": [{"introduction": "任何有限尺寸标度分析的基础，都是为有限系统精确计算热力学可观测量。本练习侧重于计算二维伊辛模型 (Ising model) 的磁化率 $\\chi(T,L)$，这是统计力学的基石。你将使用精确枚举法——一种适用于小系统的强大方法——来观察磁化率峰值（我们用它作为有限尺寸伪临界温度 $T_c(L)$ 的代理）如何受到边界条件（周期性与开放边界）选择的影响。这项实践有助于构建统计物理模拟的基本编程技能，并让你具体理解有限系统边界如何影响物理测量，而这正是有限尺寸标度理论旨在解决的关键挑战。[@problem_id:2394487]", "problem": "考虑一个在 $L\\times L$ 方形晶格上的铁磁二维伊辛模型，其自旋变量为 $s_i\\in\\{-1,+1\\}$，耦合常数为 $J>0$，且外场为零。其哈密顿量为\n$$\n\\mathcal{H}(\\{s\\})=-J\\sum_{\\langle i,j\\rangle}s_is_j,\n$$\n其中，求和遍历所有最近邻对 $\\langle i,j\\rangle$，每对只计算一次。需要考虑两种边界条件：开放边界条件和周期性边界条件。在开放边界条件下，一个格点的邻居仅限于在 $L\\times L$ 网格内部与其相邻的格点，不包含任何环绕连接。在周期性边界条件下，邻居关系包含环绕连接，因此晶格在拓扑上是一个环面。\n\n对于给定的温度 $T>0$ 和系统尺寸 $L$，定义配分函数为\n$$\nZ(T,L)=\\sum_{\\{s\\}}\\exp\\left(-\\frac{\\mathcal{H}(\\{s\\})}{k_{\\mathrm{B}}T}\\right),\n$$\n以及总磁化强度 $M(\\{s\\})=\\sum_i s_i$ 的热力学平均由以下公式给出\n$$\n\\langle M\\rangle_{T,L}=\\frac{1}{Z(T,L)}\\sum_{\\{s\\}} M(\\{s\\})\\exp\\left(-\\frac{\\mathcal{H}(\\{s\\})}{k_{\\mathrm{B}}T}\\right),\n$$\n$$\n\\langle M^2\\rangle_{T,L}=\\frac{1}{Z(T,L)}\\sum_{\\{s\\}} M(\\{s\\})^2\\exp\\left(-\\frac{\\mathcal{H}(\\{s\\})}{k_{\\mathrm{B}}T}\\right).\n$$\n单位自旋的零场磁化率定义为\n$$\n\\chi(T,L)=\\frac{1}{k_{\\mathrm{B}}TN}\\left(\\langle M^2\\rangle_{T,L}-\\langle M\\rangle_{T,L}^2\\right),\\quad N=L^2.\n$$\n\n对于本问题，采用无量纲单位 $J=1$ 和 $k_{\\mathrm{B}}=1$，因此温度是以 $J/k_{\\mathrm{B}}$ 为单位进行度量的。对于每个指定的 $(L,\\text{边界条件})$ 对，将有限尺寸赝临界温度 $T_c(L)$ 操作上定义为离散温度集\n$$\n\\mathcal{T}=\\{T\\,\\mid\\,T=1.00+0.02\\,n,\\ n\\in\\mathbb{Z},\\ 0\\le n\\le 150\\}\n$$\n中能使 $\\chi(T,L)$ 达到其最大值的那个元素。如果在 $\\mathcal{T}$ 中有多个温度都能使 $\\chi(T,L)$ 达到最大值，则取其中最小的温度作为 $T_c(L)$。\n\n您的任务是为以下测试组中的每种情况计算 $T_c(L)$：\n- 情况 1：$L=2$，开放边界条件。\n- 情况 2：$L=2$，周期性边界条件。\n- 情况 3：$L=3$，开放边界条件。\n- 情况 4：$L=3$，周期性边界条件。\n- 情况 5：$L=4$，开放边界条件。\n- 情况 6：$L=4$，周期性边界条件。\n\n所有结果都必须以 $J/k_{\\mathrm{B}}$ 为单位表示，并四舍五入到小数点后 3 位。您的程序应生成单行输出，其中包含从情况 1 到情况 6 的结果，结果为逗号分隔的列表，并用方括号括起来（例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$），其中每个 $x_i$ 都是一个按规定格式化的浮点数。", "solution": "问题陈述已经过严格验证。我们发现它具有科学依据、提法明确且客观。它植根于统计力学的标准框架，特别是作为该领域基石的二维伊辛模型。所有参数、定义和步骤都已足够清晰和精确地说明，可以得出一个唯一的、可验证的解。因此，该问题被认为是有效的，适合采用直接计算方法。\n\n任务是计算 $L \\times L$ 晶格上铁磁二维伊辛模型的有限尺寸赝临界温度 $T_c(L)$。该温度被定义为在指定的离散集合 $\\mathcal{T}$ 中，使单位自旋的零场磁化率 $\\chi(T,L)$ 达到最大的点。\n\n指定的系统尺寸（$L=2, 3, 4$）很小，使得该问题可以通过精确枚举来解决。可能的自旋构型（或微观态）总数为 $2^N$，其中 $N=L^2$。对于最大的系统 $L=4$，这相当于 $2^{16} = 65536$ 个状态，这个数量在计算上是微不足道的。\n\n系统的方法如下：\n\n首先，对于由系统尺寸 $L$ 和边界条件类型（开放或周期性）定义的每种指定情况，我们将构建精确的态密度，记为 $g(E, M)$。该函数计算具有特定总能量 $E$ 和特定总磁化强度 $M$ 的不同自旋构型 $\\{\\text{s}\\}$ 的数量。能量由采用无量纲单位 $J=1$ 的哈密顿量计算得出：\n$$ E = \\mathcal{H}(\\{s\\}) = -\\sum_{\\langle i,j \\rangle} s_i s_j $$\n磁化强度是所有自旋的总和：\n$$ M = \\sum_{i=1}^{N} s_i $$\n通过系统地遍历所有 $2^N$ 种可能的构型，计算每种构型的 $(E,M)$，并增加相应计数器的值，来计算态密度。\n\n其次，在确定了态密度 $g(E,M)$ 之后，我们就可以对任意温度 $T$ 高效地计算所需的热力学量。配分函数 $Z(T,L)$ 由对所有唯一的能量和磁化强度对的求和给出：\n$$ Z(T,L) = \\sum_{E, M} g(E,M) \\exp\\left(-\\frac{E}{T}\\right) $$\n在这里，我们使用了玻尔兹曼常数 $k_{\\mathrm{B}}=1$ 的无量纲设定。\n\n第三，我们计算单位自旋的磁化率 $\\chi(T,L)$。其通用定义为：\n$$ \\chi(T,L) = \\frac{1}{T N} \\left( \\langle M^2 \\rangle_{T,L} - \\langle M \\rangle_{T,L}^2 \\right) $$\n由于在零外磁场中哈密顿量具有自旋翻转对称性，对于任何有限系统，在非零温度下，平均磁化强度 $\\langle M \\rangle_{T,L}$ 恒等于零。因此，磁化率的表达式简化为：\n$$ \\chi(T,L) = \\frac{1}{T N} \\langle M^2 \\rangle_{T,L} $$\n磁化强度平方的热力学平均 $\\langle M^2 \\rangle_{T,L}$ 计算如下：\n$$ \\langle M^2 \\rangle_{T,L} = \\frac{1}{Z(T,L)} \\sum_{E, M} g(E,M) M^2 \\exp\\left(-\\frac{E}{T}\\right) $$\n\n最后，为了确定 $T_c(L)$，我们对给定离散集合 $\\mathcal{T} = \\{T \\mid T=1.00+0.02n, n \\in \\{0, 1, \\dots, 150\\}\\}$ 中的每个温度 $T$ 计算 $\\chi(T,L)$。$T_c(L)$ 的值是使 $\\chi(T,L)$ 达到其最大值的温度。问题规定，如果出现多个温度都能得到最大磁化率的情况，则选择其中最小的温度。通过按升序遍历温度，并且仅当发现一个严格更大的 $\\chi$ 值时才更新 $T_c(L)$ 的候选值，可以严格遵守此规则。\n\n对六个测试案例中的每一个都实施了此完整算法，以产生所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef get_dos(L, boundary_type):\n    \"\"\"\n    Computes the exact density of states g(E, M) for an L x L Ising lattice.\n\n    Args:\n        L (int): The linear size of the lattice.\n        boundary_type (str): 'obc' for open or 'pbc' for periodic boundaries.\n\n    Returns:\n        defaultdict: A dictionary mapping (energy, magnetization) tuples to counts.\n    \"\"\"\n    N = L * L\n    dos = defaultdict(int)\n\n    # Iterate through all 2^N possible spin configurations.\n    # Each integer 'i' from 0 to 2^N - 1 represents a unique configuration.\n    for i in range(2**N):\n        # Generate the spin configuration from the integer 'i'.\n        # Bit 'j' of 'i' corresponds to spin s_j. 0 -> -1, 1 -> +1.\n        spins = np.array([2 * ((i >> j) & 1) - 1 for j in range(N)])\n        \n        energy = 0\n        # Calculate energy by summing over nearest-neighbor interactions.\n        # To avoid double counting, we only sum interactions with 'right'\n        # and 'down' neighbors for each spin.\n        for idx in range(N):\n            s_i = spins[idx]\n            y, x = divmod(idx, L)\n\n            # Interaction with the right neighbor\n            if boundary_type == 'pbc':\n                idx_right = y * L + (x + 1) % L\n                energy -= s_i * spins[idx_right]\n            elif x < L - 1: # OBC\n                idx_right = y * L + x + 1\n                energy -= s_i * spins[idx_right]\n\n            # Interaction with the down neighbor\n            if boundary_type == 'pbc':\n                idx_down = ((y + 1) % L) * L + x\n                energy -= s_i * spins[idx_down]\n            elif y < L - 1: # OBC\n                idx_down = (y + 1) * L + x\n                energy -= s_i * spins[idx_down]\n\n        magnetization = np.sum(spins)\n        dos[(energy, magnetization)] += 1\n    \n    return dos\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        (2, 'obc'), (2, 'pbc'),\n        (3, 'obc'), (3, 'pbc'),\n        (4, 'obc'), (4, 'pbc'),\n    ]\n\n    # Define the discrete set of temperatures according to the problem statement.\n    # T = 1.00 + 0.02*n for n from 0 to 150.\n    temperatures = np.linspace(1.0, 1.00 + 0.02 * 150, 151)\n    \n    final_results = []\n\n    for L, bc in test_cases:\n        N = L * L\n        dos = get_dos(L, bc)\n        \n        max_chi = -1.0\n        tc = -1.0\n        \n        for T in temperatures:\n            # Using dimensionless units J=1, k_B=1.\n            Z = 0.0       # Partition function\n            M2_sum = 0.0  # Sum for <M^2> numerator\n            \n            # Sum over the density of states to compute Z and <M^2>\n            for (energy, mag), count in dos.items():\n                boltzmann_factor = np.exp(-energy / T)\n                Z += count * boltzmann_factor\n                M2_sum += count * mag**2 * boltzmann_factor\n            \n            # Avoid division by zero, although not expected here for T > 0.\n            if Z > 0:\n                avg_M2 = M2_sum / Z\n            else:\n                avg_M2 = 0\n            \n            # Susceptibility per spin: chi = (1/(T*N)) * (<M^2> - <M>^2)\n            # In zero field, <M> = 0.\n            chi = avg_M2 / (T * N)\n            \n            # Find T that maximizes chi.\n            # If chi == max_chi, keep the existing tc since it's smaller.\n            # This handles the tie-breaking rule.\n            if chi > max_chi:\n                max_chi = chi\n                tc = T\n\n        # Format result to 3 decimal places as specified.\n        # This ensures outputs like 2.4 are printed as 2.400.\n        final_results.append(f\"{tc:.3f}\")\n\n    # Print the final list of results in the required format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "2394487"}, {"introduction": "有限尺寸标度分析的一个主要目标，是将在有限计算机上进行的模拟与无限系统的理想化热力学极限联系起来。本练习利用了有限尺寸标度理论的核心预测：在尺寸为 $L$ 的系统中测得的伪临界温度 $T_L^*$ 会遵循幂律 $T_L^* - T_c \\sim L^{-1/\\nu}$ 趋近于真实的临界温度 $T_c$。你将使用一个二维伊辛模型的给定数据，对 $L^{-1}$ 进行多项式拟合，从而将有限尺寸的结果外推至 $L \\to \\infty$ 的极限，以估算真实的 $T_c$。这个练习将带你从原始数据生成转向数据分析，教你一种从数值模拟中提取有物理意义的关键技术，并展示了如何系统地处理和消除有限尺寸效应，以揭示其背后的普适物理规律。[@problem_id:2394503]", "problem": "您的任务是实现一个基于基本原理的有限尺寸标度（Finite-Size Scaling, FSS）分析，以估计一个二维（$2\\mathrm{D}$）Ising模型的相边界。该模型建立在具有竞争关系的最近邻（$J_1$）和次近邻（$J_2$）相互作用的方格子上，并处于热力学极限下。考虑铁磁区域，其中 $J_1 > 0$ 且 $J_2 \\ge 0$。当 $J_2/J_1$低于某个阈值时，有限温度下的相变是连续的，并且属于标准的二维Ising普适类。温度以 $J_1/k_{\\mathrm{B}}$ 为单位表示。\n\n从平衡关联长度 $\\xi$ 在连续相变附近发散的基本定义 $\\xi \\sim \\xi_0 \\lvert t \\rvert^{-\\nu}$ 出发（其中 $t = (T - T_{\\mathrm{c}})/T_{\\mathrm{c}}$ 是约化温度，$\\nu$ 是关联长度临界指数），并利用二维Ising普适类中 $\\nu = 1$ 这一经过充分检验的事实，请从第一性原理出发，推断线性尺寸为 $L$ 的有限体系如何对 $\\xi$ 施加一个截断，从而使热力学奇点变得圆滑和发生位移。特别地，对于由有限尺寸 $L$ 下磁化率最大值位置定义的赝临界温度 $T^*_L$，请在 $L \\to \\infty$ 的极限下，为热力学临界温度 $T_{\\mathrm{c}}$ 给出一个合理的估计量。您的估计量必须遵循当 $\\xi(T) \\sim \\mathcal{O}(L)$ 时奇点被圆滑化的逻辑，并且可以包含与此框架一致的次领头解析修正。\n\n实现一个程序，该程序在给定固定 $J_2/J_1$ 下多个 $L$ 的有限尺寸赝临界温度 $T^*_L$ 后，拟合一个与FSS推理一致的模型，然后将 $T^*_L$ 外推到 $L \\to \\infty$ 以估计 $T_{\\mathrm{c}}(J_2/J_1)$。为了数值稳定性和考虑次领头修正，您必须使用一个关于 $L^{-1}$ 的最高到二次的多项式来对 $T^*_L$ 作为 $L$ 的函数进行建模，并提取该表示中对应于 $L \\to \\infty$ 极限的截距。所有温度均以 $J_1/k_{\\mathrm{B}}$ 为单位报告，并四舍五入到9位小数。\n\n测试套件和数据（所有温度均以 $J_1/k_{\\mathrm{B}}$ 为单位）：\n- 使用系统尺寸 $L \\in \\{10, 20, 40, 80\\}$。\n- 对于 $J_2/J_1 = 0.0$，当 $L = 10, 20, 40, 80$ 时，赝临界温度分别为 $2.394185314$、$2.330435314$、$2.299497814$、$2.284263439$。\n- 对于 $J_2/J_1 = 0.1$，当 $L = 10, 20, 40, 80$ 时，赝临界温度分别为 $2.16795863574$、$2.11570863574$、$2.09014613574$、$2.07750551074$。\n- 对于 $J_2/J_1 = 0.2$，当 $L = 10, 20, 40, 80$ 时，赝临界温度分别为 $1.94273195748$、$1.90123195748$、$1.88085695748$、$1.87076320748$。\n\n您的程序必须：\n- 对 $T^*_L$ 与一个最高到二次的 $L^{-1}$ 多项式基进行回归，以估计在每个 $J_2/J_1$ 值下对应于 $L \\to \\infty$ 的截距。\n- 生成单行输出，其中包含一个由逗号分隔的列表，列表内是三个估计的 $T_{\\mathrm{c}}$ 值（以 $J_1/k_{\\mathrm{B}}$ 为单位），四舍五入到9位小数，并用方括号括起来。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由逗号分隔并用方括号括起来的结果列表，例如，“[x0,x1,x2]”。请将“x0,x1,x2”替换为您的三个浮点数结果，每个结果在小数点后精确显示9位数字，且无空格。", "solution": "所提出的问题是计算统计力学中的一个标准练习，具体涉及应用有限尺寸标度理论，将来自有限体系的数值数据外推到热力学极限。该问题具有科学依据，提法明确，并包含了获得唯一解所需的所有信息。因此，我将着手对求解方法进行原则性推导。\n\n连续相变理论的基石是平衡关联长度 $\\xi$ 在温度 $T$ 接近临界温度 $T_{\\mathrm{c}}$ 时的发散。这种发散由一个幂律描述：\n$$\n\\xi(T) \\sim \\xi_0 \\lvert t \\rvert^{-\\nu}\n$$\n其中 $t = (T - T_{\\mathrm{c}})/T_{\\mathrm{c}}$ 是约化温度，$\\xi_0$ 是一个非普适振幅，而 $\\nu$ 是一个普适临界指数。对于指定问题，该体系属于二维（$2\\mathrm{D}$）Ising普适类，其关联长度指数 $\\nu = 1$ 是一个精确结果。因此，在 $T_{\\mathrm{c}}$ 附近，关联长度的行为如下：\n$$\n\\xi(T) \\sim \\xi_0 \\lvert T - T_{\\mathrm{c}} \\rvert^{-1}\n$$\n\n在任何实际的模拟或实验中，系统尺寸都是有限的，由一个线性维度 $L$ 来表征。有限体系无法维持比其自身尺寸更大的尺度上的涨落。这给关联长度施加了一个有效截断，$\\xi_L(T) \\le L$。因此，在热力学极限（$L \\to \\infty$）下存在于 $T_{\\mathrm{c}}$ 处的尖锐奇点，在有限体系中会被圆滑化和发生位移。响应函数，例如磁化率，在 $L \\to \\infty$ 时会在 $T_{\\mathrm{c}}$ 处发散，但在有限体系中，它会在一个依赖于系统尺寸的赝临界温度（记为 $T^*_L$）处呈现一个有限的峰值。\n\n有限尺寸标度假说断言，当热力学关联长度 $\\xi(T)$ 与系统尺寸 $L$ 相当时，这种圆滑效应会变得显著。因此，峰值的位置 $T^*_L$ 由以下条件确定：\n$$\n\\xi(T^*_L) \\sim L\n$$\n将 $\\xi$ 的标度形式代入并设 $\\nu = 1$，得到：\n$$\n\\xi_0 \\lvert T^*_L - T_{\\mathrm{c}} \\rvert^{-1} \\sim L\n$$\n重新整理该关系式可以揭示赝临界温度 $T^*_L$ 是如何随着 $L$ 的增大而趋近于真实临界温度 $T_{\\mathrm{c}}$ 的：\n$$\n\\lvert T^*_L - T_{\\mathrm{c}} \\rvert \\sim L^{-1}\n$$\n这意味着对于较大的 $L$，$T^*_L$ 相对于 $L^{-1}$ 的图像应为线性关系，并且在 $L^{-1} = 0$ (即 $L \\to \\infty$) 处的截距将给出热力学临界温度 $T_{\\mathrm{c}}$。我们可以将其写成一个形式展开式：\n$$\nT^*_L = T_{\\mathrm{c}} + c_1 L^{-1} + \\dots\n$$\n其中 $c_1$ 是一个非普适常数。\n\n更高级的标度理论考虑了次领头修正，这些修正源于无关标度场或解析背景贡献。赝临界温度位移的一般形式为：\n$$\nT^*_L = T_{\\mathrm{c}} + a_{1} L^{-1/\\nu} + a_{2} L^{-(\\omega + 1/\\nu)} + \\dots\n$$\n其中 $\\omega > 0$ 是领头标度修正指数。对于 $\\nu=1$ 的二维Ising普适类，这变为：\n$$\nT^*_L = T_{\\mathrm{c}} + a_{1} L^{-1} + a_{2} L^{-(1+\\omega)} + \\dots\n$$\n问题指定使用一个关于 $L^{-1}$ 的最高到二次的多项式作为模型。这是一种实用且稳健的方法，特别是当 $\\omega$ 的值没有被高精度地知晓，或者当数据质量不足以分辨多个非整数指数时。因此，我们采用拟合函数：\n$$\nT^*_L = C_0 + C_1 L^{-1} + C_2 L^{-2}\n$$\n在这个模型中，参数 $C_0$ 代表在热力学极限 $L \\to \\infty$ 下的外推值，因此它就是我们对真实临界温度 $T_{\\mathrm{c}}$ 的估计量。$C_1 L^{-1}$ 项捕捉了领头的有限尺寸标度行为，而 $C_2 L^{-2}$ 项提供了对领头次级修正的有效表示，无论其精确来源如何。\n\n为了确定系数 $C_0, C_1$ 和 $C_2$，我们执行线性最小二乘回归。对于每个对应于固定比率 $J_2/J_1$ 的数据集，我们都有一组测量值 $(L_i, T^*_{L_i})$。我们寻求系数向量 $\\mathbf{C} = [C_0, C_1, C_2]^T$，它能最小化残差平方和：\n$$\n\\chi^2 = \\sum_{i} \\left( T^*_{L_i} - (C_0 + C_1 L_i^{-1} + C_2 L_i^{-2}) \\right)^2\n$$\n这是一个标准的线性代数问题，可以通过构建一个设计矩阵 $\\mathbf{A}$ 和一个观测向量 $\\mathbf{b}$ 来解决。设计矩阵 $\\mathbf{A}$ 的每一行对应一个系统尺寸 $L_i$，由 $[1, L_i^{-1}, L_i^{-2}]$ 给出；观测向量 $\\mathbf{b}$ 的元素为 $T^*_{L_i}$。通过求解正规方程 $(\\mathbf{A}^T \\mathbf{A})\\mathbf{C} = \\mathbf{A}^T \\mathbf{b}$ 即可找到解。所得系数 $C_0$ 即为所求的 $T_{\\mathrm{c}}$ 的估计值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a finite-size scaling analysis to estimate the critical temperature\n    of a 2D Ising model with J1-J2 interactions.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case includes system sizes L and corresponding pseudocritical\n    # temperatures T_star. Temperatures are in units of J1/k_B.\n    test_cases = [\n        {\n            # Case for J2/J1 = 0.0\n            'L': np.array([10, 20, 40, 80], dtype=np.float64),\n            'T_star': np.array([2.394185314, 2.330435314, 2.299497814, 2.284263439], dtype=np.float64)\n        },\n        {\n            # Case for J2/J1 = 0.1\n            'L': np.array([10, 20, 40, 80], dtype=np.float64),\n            'T_star': np.array([2.16795863574, 2.11570863574, 2.09014613574, 2.07750551074], dtype=np.float64)\n        },\n        {\n            # Case for J2/J1 = 0.2\n            'L': np.array([10, 20, 40, 80], dtype=np.float64),\n            'T_star': np.array([1.94273195748, 1.90123195748, 1.88085695748, 1.87076320748], dtype=np.float64)\n        }\n    ]\n\n    estimated_tc_values = []\n\n    for case in test_cases:\n        L = case['L']\n        T_star = case['T_star']\n\n        # The fitting model is a polynomial in L^-1 up to quadratic order:\n        # T_star(L) = C0 + C1 * L^-1 + C2 * L^-2\n        # We need to solve a linear least-squares problem for the coefficients [C0, C1, C2].\n        # C0 is the estimate for T_c in the thermodynamic limit (L -> infinity).\n\n        # Construct the design matrix 'A' for the linear system A*x = b.\n        # The columns of A are the basis functions: L^0, L^-1, L^-2.\n        L_inv = 1.0 / L\n        A = np.vstack([np.ones_like(L), L_inv, L_inv**2]).T\n        \n        # The vector of observations 'b' contains the T_star values.\n        b = T_star\n        \n        # Solve the linear least squares problem A*x = b for x = [C0, C1, C2].\n        # numpy.linalg.lstsq returns the solution vector as the first element.\n        coeffs = np.linalg.lstsq(A, b, rcond=None)[0]\n        \n        # The extrapolated critical temperature Tc is the intercept, C0.\n        tc_estimate = coeffs[0]\n        estimated_tc_values.append(tc_estimate)\n\n    # Format the results as specified: a list of floats rounded to 9 decimal places,\n    # comma-separated, and enclosed in square brackets. No spaces.\n    formatted_results = [f\"{tc:.9f}\" for tc in estimated_tc_values]\n    output_string = f\"[{','.join(formatted_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```", "id": "2394503"}, {"introduction": "除了定位临界点，有限尺寸标度分析的真正威力在于它能够揭示定义相变普适类的普适标度函数和临界指数。这项高级练习旨在解决数据坍缩问题，这是有限尺寸标度分析一个直观且有力的证明。有限尺寸标度假设预测，当可观测量 $m(L,t)$ 和控制参数 $t$ 通过系统尺寸 $L$ 的适当幂次进行重整化后，来自所有不同尺寸的数据都将坍缩到一条单一的主曲线上 $F(x)$。你将实现一个自动化此过程的算法，通过数值优化标度指数来最小化坍缩曲线的“厚度”。这项实践引入了一种直接从原始数据中确定临界指数的、研究级别的先进技术，掌握这种方法将为你提供一个强大的、与模型无关的工具，用于分析各种系统中的临界现象。[@problem_id:2394510]", "problem": "您将处理一个通用的有限尺寸标度问题，重点是通过重标度坐标轴，将一个可观测量的多条曲线坍缩到一条主曲线上。其科学背景是连续相变点附近的有限尺寸标度假设。设某个可观测量表示为 $m(L,t)$，其中 $L$ 是系统尺寸，$t$ 是一个无量纲的约化控制参数（例如，约化温度）。有限尺寸标度假设指出，存在指数组合 $p$ 和 $q$ 以及一个无量纲的标度函数 $F(\\cdot)$，使得重标度化后的变量\n$$\nx = t \\, L^{p}, \\quad y = m(L,t) \\, L^{q}\n$$\n在使用正确的指数 $p$ 和 $q$ 时，可以将来自不同 $L$ 的数据坍缩到一条公共的、与尺寸无关的主曲线 $y = F(x)$ 上。在热力学极限下，这一论述得到了重整化群论证的支持，并且是计算物理学中有限尺寸标度标准范式的一部分。\n\n您的任务是实现一个算法，该算法通过数值优化 $p$ 和 $q$ 的选择，来自动执行数据坍缩，以最小化坍缩后曲线的上下包络线之间的面积。为了精确定义此算法目标：给定一组由 $j$ 索引的曲线，在如上重标度为 $(x_j, y_j)$ 后，将其公共定义域 $[x_{\\min}, x_{\\max}]$ 定义为所有单个 $x$ 区间的交集。在 $[x_{\\min}, x_{\\max}]$ 内的 $N_g$ 个点的均匀网格上，对每条曲线 $y_j(x)$ 进行线性插值，计算每个网格点上的跨度 $w(x) = \\max_j y_j(x) - \\min_j y_j(x)$，并将目标函数定义为定义域上的平均跨度\n$$\n\\mathcal{A}(p,q) = \\frac{1}{x_{\\max} - x_{\\min}} \\int_{x_{\\min}}^{x_{\\max}} \\left[ \\max_j y_j(x) - \\min_j y_j(x) \\right] \\, dx.\n$$\n使用梯形法则对积分进行数值近似。如果公共定义域为空或小到可以忽略，则将 $\\mathcal{A}(p,q)$ 视为一个非常大的值，以抑制此类参数选择。算法必须搜索使 $\\mathcal{A}(p,q)$ 最小化的 $p$ 和 $q$。\n\n算法和实现要求：\n- 使用适用于非凸问题的无导数数值优化器。\n- 使用包含 $N_g = 401$ 个点的均匀网格来评估积分和包络线宽度。\n- 在公共定义域上对 $y_j(x)$ 使用线性插值。\n- 将 $p$ 和 $q$ 的搜索约束在合理的边界内：$p \\in [0.5, 1.5]$，$q \\in [0.05, 0.25]$。\n- 不涉及物理单位；所有变量都是无量纲的。\n\n测试套件：\n根据以下公式构建合成数据集\n$$\nm(L,t) = L^{-q_{\\mathrm{true}}} \\, F\\!\\left(t \\, L^{p_{\\mathrm{true}}}\\right),\n$$\n其中标度函数为\n$$\nF(u) = \\left[ 1 + (a\\,u)^2 \\right]^{-b},\n$$\n该函数对于所有实数 $u$ 都是光滑且为正的。对于含噪声的情况，添加独立的、均值为零的高斯噪声，其标准差等于指定分数乘以该数据集无噪声 $m(L,t)$ 值的中位数。为保证可复现性，每个案例使用固定的随机种子。\n\n提供如下三个测试案例。对于每个案例，构建 $n_L$ 个系统尺寸 $\\{L\\}$、一个在 $[t_{\\min}, t_{\\max}]$ 上包含 $N_t$ 个点的均匀 $t$ 网格，然后如上计算 $m(L,t)$。\n\n- 案例 1 (清洁，典型指数):\n  - 参数：$p_{\\mathrm{true}} = 1.0$, $q_{\\mathrm{true}} = 0.125$, $a = 2.0$, $b = 0.5$。\n  - 系统尺寸：$L \\in \\{16, 32, 64, 128\\}$ (即 $n_L = 4$)。\n  - 网格：$t \\in [-0.30, 0.30]$，包含 $N_t = 241$ 个均匀间隔的点。\n  - 噪声：无 (标准差等于 $0$)，种子不适用。\n\n- 案例 2 (含噪声，指数与案例 1 相同):\n  - 参数：$p_{\\mathrm{true}} = 1.0$, $q_{\\mathrm{true}} = 0.125$, $a = 2.0$, $b = 0.5$。\n  - 系统尺寸：$L \\in \\{16, 32, 64, 128\\}$。\n  - 网格：$t \\in [-0.30, 0.30]$，包含 $N_t = 241$ 个均匀间隔的点。\n  - 噪声：高斯噪声，其标准差等于每个 $L$ 的无噪声 $m(L,t)$ 值中位数的 $0.02$ 倍，种子为 $123$。\n\n- 案例 3 (不同指数和中等噪声):\n  - 参数：$p_{\\mathrm{true}} = 0.9$, $q_{\\mathrm{true}} = 0.2$, $a = 1.5$, $b = 0.8$。\n  - 系统尺寸：$L \\in \\{12, 24, 48, 96\\}$。\n  - 网格：$t \\in [-0.40, 0.40]$，包含 $N_t = 241$ 个均匀间隔的点。\n  - 噪声：高斯噪声，其标准差等于每个 $L$ 的无噪声 $m(L,t)$ 值中位数的 $0.01$ 倍，种子为 $456$。\n\n您的程序必须：\n- 为每个测试案例实现上述指定的合成数据生成。\n- 实现目标函数 $\\mathcal{A}(p,q)$，其为在包含 $N_g = 401$ 个点的网格上、使用线性插值和梯形积分计算出的定义域平均包络宽度，当公共定义域为空或极小时返回一个大的惩罚值。\n- 在 $p \\in [0.5, 1.5]$ 和 $q \\in [0.05, 0.25]$ 的范围内数值最小化 $\\mathcal{A}(p,q)$，以估计每个案例的 $(p, q)$。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个结果都必须是 $[p_{\\mathrm{est}}, q_{\\mathrm{est}}]$ 形式的、包含两个浮点数的列表，并四舍五入到恰好三位小数。对于这三个案例，输出必须采用以下形式\n  $$\n  \\left[ [p_{\\mathrm{est}}^{(1)}, q_{\\mathrm{est}}^{(1)}], [p_{\\mathrm{est}}^{(2)}, q_{\\mathrm{est}}^{(2)}], [p_{\\mathrm{est}}^{(3)}, q_{\\mathrm{est}}^{(3)}] \\right].\n  $$\n除了包含该列表的单行文本外，不应打印任何其他文本。", "solution": "我们从核心的有限尺寸标度假设出发：对于一个在连续相变点附近的可观测量 $m(L,t)$，存在指数组合 $p$ 和 $q$ 以及一个标度函数 $F(\\cdot)$，使得 $m(L,t) = L^{-q} F(t L^{p})$。该陈述基于重整化群的考虑以及一个假设，即在临界点附近，唯一相关的尺度是系统尺寸与相干长度之比，这为变量经过适当重标度后发生数据坍缩提供了理论依据。\n\n为了通过计算找出正确的指数，我们定义了一个定量度量，用于衡量曲线在重标度后的坍缩程度。如果我们使用 $x = t L^{p}$ 和 $y = m L^{q}$ 对每条曲线进行重标度，完美的坍缩将产生一条不依赖于 $L$ 的单一曲线 $y = F(x)$。一个实用的、与模型无关的量化坍缩质量的方法是，在相同的 $x$ 值上比较不同曲线的 $y$ 值分布的跨度。在给定的 $x$ 处，上包络线是 $\\max_j y_j(x)$，下包络线是 $\\min_j y_j(x)$，其中 $j$ 索引不同 $L$ 的曲线。在 $x$ 处的跨度是其差值 $\\max_j y_j(x) - \\min_j y_j(x)$。我们将这个跨度在所有曲线共有的 $x$ 值定义域上进行聚合，以避免在数据支持范围之外进行外推。\n\n由于数据是离散的，我们以数值方式进行处理。对于一个给定的猜测 $(p,q)$，我们：\n- 将重标度后的 $x_j = t_j L_j^{p}$ 和 $y_j = m_j L_j^{q}$ 计算出来，用于每条曲线 $j$。\n- 将重标度后的 $x_j$ 所覆盖的所有区间的交集确定为公共定义域 $[x_{\\min}, x_{\\max}]$；即 $x_{\\min} = \\max_j \\min(x_j)$ 和 $x_{\\max} = \\min_j \\max(x_j)$。\n- 如果公共定义域为空或小到可以忽略，我们返回一个大的惩罚值以抑制此类参数选择。\n- 否则，在 $[x_{\\min}, x_{\\max}]$ 上构建一个含 $N_g$ 个点的均匀网格。\n- 对于每条曲线 $j$，使用稳定的单调插值法，将作为 $x_j$ 函数的 $y_j$ 线性插值到这个网格上（数据在 $x$ 上天然是单调的，因为 $t$ 是单调的且 $L^{p} > 0$）。这样就得到了在公共网格上所有 $j$ 的 $y_j(x)$。\n- 在每个网格点 $x$ 处，计算跨度 $w(x) = \\max_j y_j(x) - \\min_j y_j(x)$。\n- 将目标函数计算为定义域上的平均包络宽度，\n$$\n\\mathcal{A}(p,q) = \\frac{1}{x_{\\max} - x_{\\min}} \\int_{x_{\\min}}^{x_{\\max}} w(x) \\, dx,\n$$\n我们通过在均匀网格上应用梯形法则来近似该积分。通过除以 $(x_{\\max} - x_{\\min})$ 进行归一化，可以防止算法通过将定义域坍缩到一个极小区间来人为地减小目标函数值，从而使得该度量在不同的 $(p,q)$ 之间具有可比性。\n\n有了这个目标函数，我们选择一个适用于非凸曲面的无导数优化器。像标准科学计算库中实现的 Powell 方法或 Nelder–Mead 方法是合适的，因为目标函数涉及插值和积分，这使得求导变得不便或结果含噪声。我们强制施加简单的边界约束 $p \\in [0.5, 1.5]$ 和 $q \\in [0.05, 0.25]$，这反映了许多模型的典型范围，并可防止病态的重标度。\n\n为了测试与验证，我们从一个已知的标度函数和已知的指数生成合成数据。具体来说，我们使用\n$$\nm(L,t) = L^{-q_{\\mathrm{true}}} \\, F(t L^{p_{\\mathrm{true}}}), \\quad F(u) = \\left[1 + (a u)^2 \\right]^{-b}.\n$$\n我们提供三个测试案例：一个清洁数据集，其 $p_{\\mathrm{true}} = 1.0$, $q_{\\mathrm{true}} = 0.125$, $a = 2.0$, $b = 0.5$；一个含噪声的数据集，指数相同，噪声标准差为每个 $L$ 信号中位数的 $0.02$ 倍；以及第三个数据集，具有不同指数 $p_{\\mathrm{true}} = 0.9$, $q_{\\mathrm{true}} = 0.2$，参数 $a = 1.5$, $b = 0.8$，以及中等噪声，其大小为每个 $L$ 信号中位数的 $0.01$ 倍。对于含噪声的案例，我们使用固定的随机种子以确保可复现性。$t$ 的网格是均匀的，$L$ 值的选择能确保对于真实的指数，重标度后的定义域有充分的重叠。\n\n算法针对每个测试案例按以下步骤进行：\n- 使用给定的 $p_{\\mathrm{true}}$、$q_{\\mathrm{true}}$、$a$ 和 $b$ 为指定集合中的每个 $L_j$ 生成 $\\{(t_j, m_j, L_j)\\}$，并按要求添加噪声。\n- 将目标函数 $\\mathcal{A}(p,q)$ 定义为在公共 $x$ 域上包含 $N_g = 401$ 个点的均匀网格上计算出的平均包络宽度。\n- 使用带箱式约束 $p \\in [0.5, 1.5]$ 和 $q \\in [0.05, 0.25]$ 的无导数优化器，对 $(p,q)$ 最小化 $\\mathcal{A}(p,q)$，可以从多个初始猜测点开始以提高鲁棒性。\n- 将得到的估计值 $(p_{\\mathrm{est}}, q_{\\mathrm{est}})$ 四舍五入到三位小数。\n\n最后，我们将三个 $(p_{\\mathrm{est}}, q_{\\mathrm{est}})$ 对聚合到一个列表中，并以所需格式将其作为单行打印：\n$$\n\\left[ [p_{\\mathrm{est}}^{(1)}, q_{\\mathrm{est}}^{(1)}], [p_{\\mathrm{est}}^{(2)}, q_{\\mathrm{est}}^{(2)}], [p_{\\mathrm{est}}^{(3)}, q_{\\mathrm{est}}^{(3)}] \\right].\n$$\n这种方法是有原则的，因为它直接源于有限尺寸标度假设，并通过一种基于包络线的跨度度量将数据坍缩操作化，而其数值实现则利用了标准的插值、求积和鲁棒优化技术。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Finite-size scaling data collapse by minimizing the average envelope width.\n\ndef scaling_function(u, a, b):\n    # F(u) = [1 + (a u)^2]^{-b}\n    return (1.0 + (a * u) ** 2) ** (-b)\n\ndef generate_synthetic_case(L_values, t_min, t_max, N_t, p_true, q_true, a, b, noise_frac=0.0, seed=None):\n    \"\"\"\n    Generate synthetic data for a single case:\n    m(L,t) = L^{-q_true} * F(t * L^{p_true}), F(u) = [1 + (a u)^2]^{-b}\n    Optionally add Gaussian noise with std = noise_frac * median(noiseless_m(L,t)) per L.\n    \"\"\"\n    t_grid = np.linspace(t_min, t_max, N_t)\n    datasets = []\n    rng = np.random.default_rng(seed) if seed is not None else None\n    for L in L_values:\n        u = t_grid * (L ** p_true)\n        m_clean = (L ** (-q_true)) * scaling_function(u, a, b)\n        if noise_frac > 0 and rng is not None:\n            sigma = noise_frac * np.median(m_clean)\n            noise = rng.normal(loc=0.0, scale=sigma, size=m_clean.shape)\n            m_noisy = m_clean + noise\n        else:\n            m_noisy = m_clean.copy()\n        datasets.append((t_grid.copy(), m_noisy, float(L)))\n    return datasets\n\ndef average_envelope_width(params, datasets, Ng=401, penalty=1e6):\n    \"\"\"\n    Compute the average envelope width over the common x-domain for given (p, q).\n    Uses linear interpolation and trapezoidal integration on a uniform grid.\n    Returns a large penalty if the common domain is empty or too small.\n    \"\"\"\n    p, q = params\n    # Rescale each dataset\n    x_list = []\n    y_list = []\n    for (t, m, L) in datasets:\n        x = t * (L ** p)\n        y = m * (L ** q)\n        # Ensure increasing x order for interpolation\n        # t_grid is monotonic, but if p is negative (not allowed) or pathological bounds, this prevents issues.\n        idx = np.argsort(x)\n        x_list.append(x[idx])\n        y_list.append(y[idx])\n\n    # Determine common domain\n    x_mins = [xi[0] for xi in x_list]\n    x_maxs = [xi[-1] for xi in x_list]\n    x_min_common = max(min(xi) for xi in x_list)\n    x_max_common = min(max(xi) for xi in x_list)\n\n    if not np.isfinite(x_min_common) or not np.isfinite(x_max_common):\n        return penalty\n    if x_max_common <= x_min_common:\n        return penalty\n\n    # Uniform grid on the common domain\n    grid = np.linspace(x_min_common, x_max_common, Ng)\n    # Interpolate y on the grid\n    Y = np.empty((len(y_list), Ng))\n    for i, (xi, yi) in enumerate(zip(x_list, y_list)):\n        # np.interp assumes xi is ascending\n        Y[i, :] = np.interp(grid, xi, yi)\n    # Envelope width at each grid point\n    width = np.max(Y, axis=0) - np.min(Y, axis=0)\n    domain_length = x_max_common - x_min_common\n    # Average envelope width: integral divided by domain length\n    avg_width = np.trapz(width, grid) / domain_length\n    # Numerical safety\n    if not np.isfinite(avg_width):\n        return penalty\n    return float(avg_width)\n\ndef estimate_exponents(datasets, bounds=((0.5, 1.5), (0.05, 0.25))):\n    \"\"\"\n    Estimate (p, q) by minimizing the average envelope width with respect to params.\n    Uses Powell's method with bounds and multiple starting points for robustness.\n    \"\"\"\n    # Multiple initial guesses to reduce risk of local minima\n    initial_guesses = [\n        np.array([1.0, 0.1]),\n        np.array([0.8, 0.2]),\n        np.array([1.2, 0.15]),\n    ]\n    best_val = np.inf\n    best_params = None\n    for x0 in initial_guesses:\n        res = minimize(\n            average_envelope_width,\n            x0=x0,\n            args=(datasets,),\n            method=\"Powell\",\n            bounds=bounds,\n            options={\"xtol\": 1e-4, \"ftol\": 1e-6, \"maxiter\": 200, \"disp\": False},\n        )\n        if res.fun < best_val:\n            best_val = res.fun\n            best_params = res.x\n    # Clip to bounds for numerical safety\n    p_est = float(np.clip(best_params[0], bounds[0][0], bounds[0][1]))\n    q_est = float(np.clip(best_params[1], bounds[1][0], bounds[1][1]))\n    return p_est, q_est\n\ndef solve():\n    # Define the three test cases\n\n    # Case 1: Clean, canonical exponents\n    case1 = generate_synthetic_case(\n        L_values=[16, 32, 64, 128],\n        t_min=-0.30, t_max=0.30, N_t=241,\n        p_true=1.0, q_true=0.125, a=2.0, b=0.5,\n        noise_frac=0.0, seed=None\n    )\n\n    # Case 2: Noisy, same exponents as case 1\n    case2 = generate_synthetic_case(\n        L_values=[16, 32, 64, 128],\n        t_min=-0.30, t_max=0.30, N_t=241,\n        p_true=1.0, q_true=0.125, a=2.0, b=0.5,\n        noise_frac=0.02, seed=123\n    )\n\n    # Case 3: Different exponents, moderate noise\n    case3 = generate_synthetic_case(\n        L_values=[12, 24, 48, 96],\n        t_min=-0.40, t_max=0.40, N_t=241,\n        p_true=0.9, q_true=0.2, a=1.5, b=0.8,\n        noise_frac=0.01, seed=456\n    )\n\n    # Estimate exponents for each case\n    results_pairs = []\n    for datasets in [case1, case2, case3]:\n        p_est, q_est = estimate_exponents(datasets)\n        # Round to three decimals for final output format\n        results_pairs.append([round(p_est, 3), round(q_est, 3)])\n\n    # Format output as a single-line list of lists with exactly three decimals\n    formatted = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{v:.3f}\" for v in pair) + \"]\" for pair in results_pairs\n    ) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2394510"}]}