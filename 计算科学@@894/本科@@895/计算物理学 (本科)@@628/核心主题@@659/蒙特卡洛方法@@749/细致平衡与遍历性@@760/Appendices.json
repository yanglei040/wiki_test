{"hands_on_practices": [{"introduction": "细致平衡和全局平衡都导向平稳分布，但它们描述了截然不同的物理情景。这个练习旨在通过一个具体的例子来精确阐明这一区别。我们将构建一个简单的三态系统，其中全局平衡成立而细致平衡被打破，进而揭示一个具有持续概率流的非平衡稳态 [@problem_id:2385718]。通过直接计算这个净概率流，你将亲身体会到违反细致平衡条件的物理后果。", "problem": "在计算物理学中，马尔可夫链蒙特卡洛方法依赖于细致平衡和遍历性的相互作用来确保采样的正确性。考虑一个由3个状态$\\{A,B,C\\}$组成的循环上的离散时间马尔可夫链，其中转移仅发生在循环中的最近邻状态之间以及向自身状态的转移（自循环）。你需要构建一个传递机制，该机制是遍历的，满足全局平衡，但不满足细致平衡。\n\n设转移概率由两个实数 $r$ 和 $s$ 参数化，其中 $0 < s < r$ 且 $r + s < 1$，因此从每个状态出发的转移概率为：\n- 从 $A$ 出发：以概率 $r$ 转移到 $B$，以概率 $s$ 转移到 $C$，以概率 $1 - r - s$ 停留在 $A$；\n- 从 $B$ 出发：以概率 $r$ 转移到 $C$，以概率 $s$ 转移到 $A$，以概率 $1 - r - s$ 停留在 $B$；\n- 从 $C$ 出发：以概率 $r$ 转移到 $A$，以概率 $s$ 转移到 $B$，以概率 $1 - r - s$ 停留在 $C$。\n\n这定义了一个 $3 \\times 3$ 的转移矩阵 $P$，其元素为 $P_{ij}$，其中 $i,j \\in \\{A,B,C\\}$。仅使用以下基本要素：离散时间马尔可夫链的定义，不可约性和非周期性（合称遍历性）的定义，平稳分布 $\\boldsymbol{\\pi}$ 的平稳性条件（全局平衡）$\\boldsymbol{\\pi}^{\\top} P = \\boldsymbol{\\pi}^{\\top}$，以及对所有状态对 $i,j$ 的细致平衡条件 $\\pi_i P_{ij} = \\pi_j P_{ji}$。\n\n任务：\n1. 证明对于 $0 < s < r$ 且 $r + s < 1$，该马尔可夫链是遍历的（不可约且非周期）。\n2. 确定一个平稳分布 $\\boldsymbol{\\pi}$，并验证其满足全局平衡。\n3. 证明除非 $r = s$，否则细致平衡不成立，因此对于 $0 < s < r$ 的情况，细致平衡被破坏。\n4. 将从 $A$ 到 $B$ 的稳态净概率流定义为 $J_{A \\to B} = \\pi_A P_{AB} - \\pi_B P_{BA}$，并以 $r$ 和 $s$ 的函数形式计算其闭式解。\n\n你的最终答案必须是 $J_{A \\to B}$ 关于 $r$ 和 $s$ 的解析表达式。无需单位。不要四舍五入；请提供精确表达式。", "solution": "**求解推导**\n\n按 $(A, B, C)$ 顺序排列的状态所对应的转移矩阵 $P$ 为：\n$$\nP = \\begin{pmatrix}\n1 - r - s & r & s \\\\\ns & 1 - r - s & r \\\\\nr & s & 1 - r - s\n\\end{pmatrix}\n$$\n\n**任务 1：遍历性**\n一个有限状态马尔可夫链如果是不可约且非周期的，那么它就是遍历的。\n\n- **不可约性**：如果从任意一个状态出发，都可以在有限步内到达任何其他状态，则该链是不可约的。这些转移可以看作是顶点集 $\\{A, B, C\\}$ 上的一个有向图。给定的概率为 $P_{AB}=r$, $P_{BA}=s$, $P_{BC}=r$, $P_{CB}=s$, $P_{CA}=r$, $P_{AC}=s$。由于 $r > 0$ 且 $s > 0$，所有这些转移概率都是非零的。该图是强连通的。例如，可以遍历循环 $A \\to B \\to C \\to A$。因此，每个状态都可以从任何其他状态到达，该链是不可约的。\n\n- **非周期性**：状态 $i$ 的周期是所有满足 $P_{ii}^{(n)} > 0$ 的整数 $n > 0$ 的最大公约数（GCD）。如果一个链的所有状态的周期都为 1，则该链是非周期的。条件 $r+s < 1$ 意味着自循环概率 $P_{AA} = P_{BB} = P_{CC} = 1 - r - s$ 均严格大于 $0$。对于不可约链中的任何状态 $i$，自循环（在 1 步内返回状态 $i$）的存在确保了该状态的周期为 1。由于 $P_{AA} > 0$，状态 $A$ 可能的返回时间集合包括 $n=1$。任何包含 1 的整数集合的最大公约数是 1。因此，状态 $A$ 是非周期的。由于该链是不可约的，一个状态的非周期性意味着所有状态都是非周期的。\n\n由于该链既是不可约的也是非周期的，因此它是遍历的。这保证了唯一平稳分布的存在。\n\n**任务 2：平稳分布与全局平衡**\n平稳分布 $\\boldsymbol{\\pi} = (\\pi_A, \\pi_B, \\pi_C)^{\\top}$ 必须满足全局平衡方程 $\\boldsymbol{\\pi}^{\\top} P = \\boldsymbol{\\pi}^{\\top}$，并且服从归一化条件 $\\pi_A + \\pi_B + \\pi_C = 1$。这对应于以下线性方程组：\n$$\n\\pi_A = \\pi_A(1 - r - s) + \\pi_B s + \\pi_C r \\\\\n\\pi_B = \\pi_A r + \\pi_B(1 - r - s) + \\pi_C s \\\\\n\\pi_C = \\pi_A s + \\pi_B r + \\pi_C(1 - r - s)\n$$\n由于转移概率的循环对称性，我们可以假设存在一个对称解 $\\pi_A = \\pi_B = \\pi_C = c$。代入归一化条件可得 $3c = 1$，所以 $c = 1/3$。\n我们来验证 $\\pi_A = \\pi_B = \\pi_C = 1/3$ 是否满足第一个平衡方程：\n$$\n\\frac{1}{3} \\overset{?}{=} \\frac{1}{3}(1 - r - s) + \\frac{1}{3}s + \\frac{1}{3}r \\\\\n\\frac{1}{3} = \\frac{1}{3} - \\frac{r}{3} - \\frac{s}{3} + \\frac{s}{3} + \\frac{r}{3} \\\\\n\\frac{1}{3} = \\frac{1}{3}\n$$\n该方程成立。由于对称性，其他两个方程也满足。因此，唯一的平稳分布是 $\\boldsymbol{\\pi} = (1/3, 1/3, 1/3)^{\\top}$。找到此分布并根据方程进行验证的过程构成了对全局平衡的验证。\n\n**任务 3：对细致平衡的违背**\n细致平衡条件是对于所有状态对 $i,j$，都有 $\\pi_i P_{ij} = \\pi_j P_{ji}$。让我们检查状态对 $(A, B)$ 的情况。\n$$\n\\pi_A P_{AB} = \\pi_B P_{BA}\n$$\n使用平稳分布和转移概率：\n$$\n\\frac{1}{3} \\cdot r = \\frac{1}{3} \\cdot s\n$$\n这个等式简化为 $r = s$。然而，问题指定的条件是 $0 < s < r$，这明确意味着 $r \\neq s$。因此，对于状态对 $(A,B)$，细致平衡条件被破坏。\n$$\n\\pi_A P_{AB} > \\pi_B P_{BA}\n$$\n对状态对 $(B,C)$ 和 $(C,A)$ 进行类似分析，同样表明除非 $r=s$，否则细致平衡被破坏。具体来说，$\\pi_B P_{BC} = (1/3)r \\neq (1/3)s = \\pi_C P_{CB}$，并且 $\\pi_C P_{CA} = (1/3)r \\neq (1/3)s = \\pi_A P_{AC}$。因此，该系统不满足细致平衡。\n\n**任务 4：稳态净概率流**\n从状态 $A$ 到状态 $B$ 的稳态净概率流定义为 $J_{A \\to B} = \\pi_A P_{AB} - \\pi_B P_{BA}$。我们代入已知值：\n- $\\pi_A = 1/3$\n- $\\pi_B = 1/3$\n- $P_{AB} = r$\n- $P_{BA} = s$\n\n计算如下：\n$$\nJ_{A \\to B} = \\left(\\frac{1}{3}\\right) r - \\left(\\frac{1}{3}\\right) s = \\frac{1}{3}(r - s)\n$$\n由于 $r > s$，该流为正，表明存在一个沿 $A \\to B$ 方向的净概率流。这个非零流是违背细致平衡的直接结果。系统处于一个非平衡稳态，存在一个持续的概率环流 $A \\to B \\to C \\to A$。", "answer": "$$\n\\boxed{\\frac{1}{3}(r-s)}\n$$", "id": "2385718"}, {"introduction": "理论上的平衡条件直接关系到我们编写的模拟算法是否正确。这个练习将探讨在实现马尔可夫链蒙特卡洛（MCMC）算法时一个常见的陷阱。你将分析一个错误地使用了Metropolis接受准则（而非正确的Metropolis-Hastings准则）的MCMC采样器，并推导出它实际收敛到的平稳分布 [@problem_id:2385732]。这项实践将让你深刻理解，为何在构建采样算法时，精确满足细致平衡的每一个细节都至关重要。", "problem": "考虑一个马尔可夫链，用于在两状态空间 $\\{0,1\\}$ 上从一个离散目标分布进行采样，其目标概率为 $\\pi(0)=p$ 和 $\\pi(1)=1-p$，其中 $0<p<1$。其提议核由下式给出：\n$$\nq(1 \\mid 0)=a,\\quad q(0 \\mid 1)=b,\\quad q(0 \\mid 0)=1-a,\\quad q(1 \\mid 1)=1-b,\n$$\n其中 $0<a<1$ 且 $0<b<1$。然而，所使用的接受概率被错误地指定为\n$$\nA(x' \\mid x)=\\min\\left(1,\\frac{\\pi(x')}{\\pi(x)}\\right),\n$$\n而不是包含提议不对称性的正确 Metropolis-Hastings 接受准则。最终的转移核根据 $q(\\cdot \\mid x)$ 执行一个提议，然后以如上所述的 $A(\\cdot \\mid x)$ 接受该提议，否则保持在当前状态。\n\n假设该链是遍历的。请确定此错误实现的算法中状态 $0$ 的平稳概率 $\\mu(0)$，并以 $p$、$a$ 和 $b$ 的解析表达式给出其闭式形式。将最终答案表示为单个闭式表达式。无需四舍五入，也不涉及单位。", "solution": "马尔可夫链的平稳分布 $\\mu$ 由其在链的演化下保持不变的性质所定义。这由全局平衡方程表示：\n$$\n\\sum_{x} \\mu(x) T(x' | x) = \\mu(x')\n$$\n其中 $T(x' | x)$ 是从状态 $x$ 到状态 $x'$ 的转移概率。对于一个离散两状态系统 $\\{0, 1\\}$，该方程组可简化为单个独立条件：从状态 $0$ 流出的概率流必须等于从状态 $1$ 流入状态 $0$ 的概率流。这表示为：\n$$\n\\mu(0) T(1 | 0) = \\mu(1) T(0 | 1)\n$$\n此处，由于概率的归一化，有 $\\mu(1) = 1 - \\mu(0)$。对于 $x' \\neq x$ 的情况，转移概率 $T(x'|x)$ 由提议概率 $q(x'|x)$ 和接受概率 $A(x'|x)$ 的乘积给出。\n\n首先，我们构建非对角转移概率。\n从状态 $x=0$ 到 $x'=1$ 的转移概率为：\n$$\nT(1 | 0) = q(1 | 0) A(1 | 0)\n$$\n使用给定的定义：\n$q(1 | 0) = a$\n$A(1 | 0) = \\min\\left(1, \\frac{\\pi(1)}{\\pi(0)}\\right) = \\min\\left(1, \\frac{1-p}{p}\\right)$\n因此，\n$$\nT(1 | 0) = a \\min\\left(1, \\frac{1-p}{p}\\right)\n$$\n类似地，从状态 $x=1$ 到 $x'=0$ 的转移概率为：\n$$\nT(0 | 1) = q(0 | 1) A(0 | 1)\n$$\n使用给定的定义：\n$q(0 | 1) = b$\n$A(0 | 1) = \\min\\left(1, \\frac{\\pi(0)}{\\pi(1)}\\right) = \\min\\left(1, \\frac{p}{1-p}\\right)$\n因此，\n$$\nT(0 | 1) = b \\min\\left(1, \\frac{p}{1-p}\\right)\n$$\n现在，我们将这些表达式代入平衡方程：\n$$\n\\mu(0) \\left[a \\min\\left(1, \\frac{1-p}{p}\\right)\\right] = \\mu(1) \\left[b \\min\\left(1, \\frac{p}{1-p}\\right)\\right]\n$$\n使用 $\\mu(1) = 1 - \\mu(0)$，我们得到：\n$$\n\\mu(0) a \\min\\left(1, \\frac{1-p}{p}\\right) = (1 - \\mu(0)) b \\min\\left(1, \\frac{p}{1-p}\\right)\n$$\n我们对该方程求解 $\\mu(0)$：\n$$\n\\mu(0) \\left[ a \\min\\left(1, \\frac{1-p}{p}\\right) + b \\min\\left(1, \\frac{p}{1-p}\\right) \\right] = b \\min\\left(1, \\frac{p}{1-p}\\right)\n$$\n$$\n\\mu(0) = \\frac{b \\min\\left(1, \\frac{p}{1-p}\\right)}{a \\min\\left(1, \\frac{1-p}{p}\\right) + b \\min\\left(1, \\frac{p}{1-p}\\right)}\n$$\n为了在不进行分类讨论的情况下简化此表达式，令 $z = \\frac{p}{1-p}$。则 $\\frac{1-p}{p} = \\frac{1}{z}$。表达式变为：\n$$\n\\mu(0) = \\frac{b \\min(1, z)}{a \\min(1, 1/z) + b \\min(1, z)}\n$$\n我们可以将分子和分母同时除以 $\\min(1, z)$（由于 $0 < p < 1$，因此 $z > 0$，故该值非零）：\n$$\n\\mu(0) = \\frac{b}{a \\frac{\\min(1, 1/z)}{\\min(1, z)} + b}\n$$\n考虑对于任意 $z > 0$ 的比率 $\\frac{\\min(1, 1/z)}{\\min(1, z)}$。\n- 如果 $0 < z \\leq 1$，则 $1/z \\geq 1$。该比率为 $\\frac{1}{z}$。\n- 如果 $z > 1$，则 $0 < 1/z < 1$。该比率为 $\\frac{1/z}{1} = \\frac{1}{z}$。\n两种情况下，该比率都等于 $1/z$。\n将 $1/z = \\frac{1-p}{p}$ 代回，我们发现：\n$$\n\\frac{\\min(1, 1/z)}{\\min(1, z)} = \\frac{1-p}{p}\n$$\n现在，我们将此结果代回 $\\mu(0)$ 的表达式中：\n$$\n\\mu(0) = \\frac{b}{a \\left(\\frac{1-p}{p}\\right) + b}\n$$\n为了消除繁分数，我们将分子和分母同乘以 $p$：\n$$\n\\mu(0) = \\frac{bp}{a \\left(\\frac{1-p}{p}\\right)p + bp} = \\frac{bp}{a(1-p) + bp}\n$$\n这就是处于状态 $0$ 的平稳概率的最终表达式。这一结果表明，这个错误实现的链的平稳分布 $\\mu$ 通常不等于目标分布 $\\pi$。要使它们相等，我们需要 $\\mu(0)=p$，这意味着 $\\frac{b}{a(1-p)+bp} = 1$，即 $b = a(1-p)+bp$。这可简化为 $b(1-p) = a(1-p)$，这要求 $a=b$。这就是提议核对称的条件，在这种情况下，Metropolis 接受概率是正确的，并得出 Metropolis 算法。对于不对称的提议（$a \\neq b$），平稳分布 $\\mu$ 会偏离目标分布 $\\pi$。", "answer": "$$\\boxed{\\frac{bp}{a(1-p) + bp}}$$", "id": "2385732"}, {"introduction": "掌握了核心原理后，让我们来看一个激动人心的应用，它展示了MCMC方法的强大通用性。在这个练习中，你将跳出传统的物理学领域，运用MCMC来解决一个复杂的逻辑谜题。你需要将谜题的逻辑约束巧妙地转化为一个“能量函数”，其中谜题的解对应于系统的“基态”，然后通过一个正确设计的、满足细致平衡与遍历性的采样器来找到这个解 [@problem_id:2385680]。这项实践不仅能巩固你对核心概念的理解，更能让你体验到如何将物理学算法应用于解决通用的组合优化问题。", "problem": "设计并实现一个程序，使用马尔可夫链蒙特卡洛（MCMC）方法为小型的、结构化的逻辑谜题搜索其赋值空间。谜题由 $N$ 个位置（索引为 $0,1,\\dots,N-1$）和 $K$ 个分类属性（例如，颜色、宠物、饮料）组成。每个类别正好有 $N$ 个不同的值，一个有效的赋值是一个双射，它将每个类别中的值一一对应地分配给各个位置，因此在同一类别内，没有两个位置具有相同的值。约束关联了不同类别中值的位置（例如，等价性、相邻性、顺序性）。将状态 $s$ 的能量函数 $E(s)$ 定义为 $s$ 中被违反的约束的总数。在温度 $T$ 下，链的目标平稳分布是玻尔兹曼分布 $\\pi_T(s) \\propto \\exp(-E(s)/T)$。\n\n您的程序必须：\n- 将状态表示为对 $N$ 个位置的 $K$ 个独立排列，每个类别对应一个排列。\n- 使用一个对称的提议机制：在每一步，从 $K$ 个类别中均匀随机选择一个类别，然后均匀随机选择两个不同的位置，并提议交换该类别在这两个位置上的值。\n- 使用一个接受准则，确保对于任何固定的 $T>0$，相对于 $\\pi_T(s)$ 的细致平衡条件得以满足。\n- 论证并实现一个在状态空间上是遍历的（连通且非周期）的移动集。\n- 对于每个测试用例，使用指定的随机种子序列，从几次随机重启开始运行MCMC固定的步数，并返回在整个运行过程中观测到的最低能量。\n\n使用的定义：\n- 设 $p_{A,v}$ 表示当前状态下类别 $A$ 中值 $v$ 的位置。每个约束如果被违反，则对 $E(s)$ 贡献 $1$，否则贡献 $0$。允许的原始约束类型有：\n    - 跨类别相等: $p_{A,v} = p_{B,w}$。\n    - 跨类别不等: $p_{A,v} \\neq p_{B,w}$。\n    - 固定位置: $p_{A,v} = \\ell$，其中 $\\ell$ 是给定的整数 $\\ell \\in \\{0,\\dots,N-1\\}$。\n    - 相邻: $|p_{A,v} - p_{B,w}| = 1$。\n    - 紧邻左侧: $p_{A,v} + 1 = p_{B,w}$。\n    - 严格位于右侧: $p_{A,v} > p_{B,w}$。\n\n实现要求：\n- 使用恒定温度 $T$（无模拟退火）。\n- 提议分布必须是对称的，这样仅使用能量差和温度即可满足细致平衡条件。\n- 每次重启都从一个独立的随机赋值开始，该赋值是在每个类别内从所有排列中均匀抽取的，并使用指定的种子偏移量。\n\n测试套件。请精确实现以下三个谜题、MCMC参数和种子。对于每个谜题，输出在所有步骤和重启中观测到的最小能量 $E_{\\min}$。\n\n谜题A (happy path, $N=4$):\n- 类别（$K=3$），每个类别有 $N=4$ 个值：\n    - color: [Yellow, Blue, Red, Green]\n    - pet: [Cat, Dog, Fish, Bird]\n    - drink: [Coffee, Tea, Milk, Water]\n- 约束（每个子句满足时贡献0，违反时贡献1）：\n    - 紧邻左侧: $p_{\\text{color},\\text{Red}} + 1 = p_{\\text{color},\\text{Green}}$。\n    - 相等: $p_{\\text{drink},\\text{Tea}} = p_{\\text{color},\\text{Blue}}$。\n    - 相邻: $|p_{\\text{pet},\\text{Dog}} - p_{\\text{color},\\text{Yellow}}| = 1$。\n    - 固定位置: $p_{\\text{drink},\\text{Milk}} = 2$。\n    - 固定位置: $p_{\\text{pet},\\text{Cat}} = 0$。\n    - 不等: $p_{\\text{drink},\\text{Water}} \\neq p_{\\text{color},\\text{Yellow}}$。\n    - 严格位于右侧: $p_{\\text{pet},\\text{Bird}} > p_{\\text{color},\\text{Red}}$。\n    - 不等: $p_{\\text{pet},\\text{Fish}} \\neq p_{\\text{color},\\text{Green}}$。\n    - 相等: $p_{\\text{drink},\\text{Coffee}} = p_{\\text{color},\\text{Yellow}}$。\n\n谜题B (small, $N=3$):\n- 类别（$K=3$），每个类别有 $N=3$ 个值：\n    - color: [Red, Green, Blue]\n    - pet: [Dog, Cat, Fish]\n    - drink: [Tea, Milk, Coffee]\n- 约束:\n    - 相等: $p_{\\text{color},\\text{Red}} = p_{\\text{drink},\\text{Tea}}$。\n    - 固定位置: $p_{\\text{pet},\\text{Cat}} = 1$。\n    - 严格位于右侧: $p_{\\text{color},\\text{Blue}} > p_{\\text{color},\\text{Green}}$。\n    - 不等: $p_{\\text{pet},\\text{Fish}} \\neq p_{\\text{color},\\text{Red}}$。\n    - 相邻: $|p_{\\text{drink},\\text{Milk}} - p_{\\text{pet},\\text{Dog}}| = 1$。\n    - 相等: $p_{\\text{drink},\\text{Coffee}} = p_{\\text{color},\\text{Blue}}$。\n\n谜题C (unsatisfiable by construction, $N=3$):\n- 类别（$K=3$），每个类别有 $N=3$ 个值：\n    - color: [Red, Green, Blue]\n    - pet: [Dog, Cat, Fish]\n    - drink: [Tea, Milk, Coffee]\n- 约束:\n    - 相等: $p_{\\text{drink},\\text{Tea}} = p_{\\text{color},\\text{Red}}$。\n    - 相等: $p_{\\text{drink},\\text{Coffee}} = p_{\\text{color},\\text{Red}}$。\n    - 固定位置: $p_{\\text{pet},\\text{Dog}} = 0$。\n    - 固定位置: $p_{\\text{color},\\text{Blue}} = 2$。\n    - 相邻: $|p_{\\text{drink},\\text{Milk}} - p_{\\text{pet},\\text{Cat}}| = 1$。\n    - 严格位于右侧: $p_{\\text{pet},\\text{Fish}} > p_{\\text{color},\\text{Green}}$。\n\n所有谜题的MCMC参数和种子：\n- 温度: $T = 0.7$。\n- 每次重启的步数: $S = 30000$。\n- 重启次数: $R = 8$。\n- 基础随机种子: 谜题A使用种子 $20231105$，谜题B使用种子 $20231106$，谜题C使用种子 $20231107$。每次重启 $r \\in \\{0,\\dots,R-1\\}$ 必须使用种子 $(\\text{基础种子} + r)$。\n\n要求输出：\n- 您的程序应生成一行文本，其中包含一个用方括号括起来的逗号分隔列表。第 $i$ 个条目必须是为测试套件中第 $i$ 个谜题找到的最小能量 $E_{\\min}$。对于此测试套件，要求的输出格式为 `\"[x,y,z]\"`，其中 $x$、$y$ 和 $z$ 是整数。\n\n科学和算法要求：\n- 从玻尔兹曼平稳分布的定义 $\\pi_T(s) \\propto \\exp(-E(s)/T)$ 出发。\n- 确保接受准则对于任何固定的 $T$ 都满足相对于 $\\pi_T$ 的细致平衡条件。\n- 使用对称提议，以便提议概率在细致平衡条件中可以被抵消。\n- 解释为什么移动集在状态空间（对称群的乘积）上是遍历的，以及为什么链是非周期的（由于可能存在拒绝，导致自转移概率非零）。\n\n此问题中不涉及物理单位、角度或百分比。最终输出必须是如上所述的整数，并采用确切的格式。", "solution": "此问题的解决方案需要设计一个MCMC模拟，该模拟从谜题解的状态空间中采样，目标是找到一个能最小化能量函数 $E(s)$ 的解。能量被定义为被违反的逻辑约束的数量。马尔可夫链的目标平稳分布是玻尔兹曼分布 $\\pi_T(s) \\propto \\exp(-E(s)/T)$，其中 $T$ 是一个恒定的温度。该分布偏好能量较低的状态。\n\n**1. 状态表示和能量函数**\n\n系统的状态 $s$ 对应于所有类别的值到位置的完整赋值。谜题涉及 $N$ 个位置（索引为 $0, \\dots, N-1$）和 $K$ 个类别。对于每个类别，都有 $N$ 个不同的值。一个有效的赋值要求对于每个类别，其 $N$ 个值与 $N$ 个位置一一对应，形成一个排列。\n\n因此，状态空间 $\\mathcal{S}$ 是 $K$ 个对称群的乘积，$\\mathcal{S} = (S_N)^K$，其中 $S_N$ 是 $N$ 个元素的排列群。状态空间的大小是 $(N!)^K$。\n\n为了计算方便，状态 $s$ 由一组查找表表示。主要的表示是一个 $K \\times N$ 的矩阵 `pos_to_val`，其中 `pos_to_val[k][p]` 存储类别 $k$ 在位置 $p$ 上的值。为了高效地评估约束，我们还维护一个反向查找表 `val_to_pos`，这是一个 $K \\times N$ 的矩阵，其中 `val_to_pos[k][v]` 存储类别 $k$ 中值 $v$ 的位置。设 $p_{k,v}$ 表示 `val_to_pos[k][v]`。\n\n能量函数 $E(s)$ 是被违反的约束的总数。每个约束都是一个逻辑命题。如果对于给定的状态 $s$ 该命题为假，则它对能量贡献 $1$；否则贡献 $0$。例如，一个约束 $p_{A,v} = p_{B,w}$ 在 `val_to_pos[A][v]` $\\ne$ `val_to_pos[B][w]` 时被违反。\n\n**2. Metropolis-Hastings 算法**\n\n为了找到低能量状态，我们使用Metropolis-Hastings算法，这是一种特定类型的MCMC。该算法生成一个状态序列 $s_0, s_1, s_2, \\dots$，使得这些状态的分布收敛到目标分布 $\\pi_T(s)$。\n\n从状态 $s$ 到新状态 $s'$ 的转换是一个两步过程：从 $s$ 提议一个移动到候选状态 $s'$，然后接受或拒绝这个移动。\n\n**2.1. 提议机制**\n\n问题指定了一个对称的提议机制。在每一步，从状态 $s$ 开始：\n1.  从 $K$ 个可用类别中均匀随机选择一个类别 $k$。概率为 $1/K$。\n2.  从所有不同的位置对集合中均匀随机选择两个不同的位置 $p_1$ 和 $p_2$。共有 $\\binom{N}{2}$ 个这样的对，所以选择特定对 $\\{p_1, p_2\\}$ 的概率是 $1/\\binom{N}{2}$。\n3.  通过交换类别 $k$ 在位置 $p_1$ 和 $p_2$ 上的值来生成一个候选状态 $s'$。\n\n提议概率 $g(s \\to s')$ 是从 $s$ 开始提议 $s'$ 的概率。对于此机制，概率为 $(1/K) \\times (1/\\binom{N}{2})$。要逆转此移动，必须从 $s'$ 开始，选择相同的类别 $k$，并选择相同的两个位置 $p_1$ 和 $p_2$ 进行交换。这个逆向提议的概率 $g(s' \\to s)$ 也是 $(1/K) \\times (1/\\binom{N}{2})$。由于 $g(s \\to s') = g(s' \\to s)$，提议分布是对称的。\n\n**2.2. 接受准则和细致平衡**\n\n马尔可夫链收敛到平稳分布 $\\pi_T(s)$ 的保证来自于链满足细致平衡条件：\n$$ \\pi_T(s) P(s \\to s') = \\pi_T(s') P(s' \\to s) $$\n其中 $P(s \\to s') = g(s \\to s') A(s \\to s')$ 是总转移概率，而 $A(s \\to s')$ 是接受概率。\n\n将 $P$ 和 $\\pi_T(s) \\propto \\exp(-E(s)/T)$ 的表达式代入细致平衡方程，得到：\n$$ \\exp(-E(s)/T) g(s \\to s') A(s \\to s') = \\exp(-E(s')/T) g(s' \\to s) A(s' \\to s) $$\n因为我们的提议机制是对称的（$g(s \\to s') = g(s' \\to s)$），提议概率可以消去：\n$$ \\frac{A(s \\to s')}{A(s' \\to s)} = \\frac{\\exp(-E(s')/T)}{\\exp(-E(s)/T)} = \\exp\\left(-\\frac{E(s') - E(s)}{T}\\right) $$\n设 $\\Delta E = E(s') - E(s)$。该比率变为 $\\exp(-\\Delta E / T)$。标准的Metropolis接受准则满足此条件：\n$$ A(s \\to s') = \\min\\left(1, \\exp(-\\Delta E / T)\\right) $$\n该准则在实现中使用。如果提议的移动导致一个能量更低或相等的-状态（$\\Delta E \\le 0$），它总是被接受。如果导致一个能量更高的状态（$\\Delta E > 0$），它以概率 $\\exp(-\\Delta E / T)$（小于1）被接受。这使得搜索能够逃离局部最小值。\n\n**3. 马尔可夫链的遍历性**\n\n为了让MCMC模拟能够探索整个状态空间并收敛到唯一的平稳分布，马尔可夫链必须是遍历的。遍历性需要两个属性：连通性和非周期性。\n\n- **连通性**：如果可以从任何状态 $s_a \\in \\mathcal{S}$ 经过有限步到达任何其他状态 $s_b \\in \\mathcal{S}$，则称链是连通的。我们的移动集包括在任何单个类别的排列内交换两个值。交换两个元素是 $S_N$ 对称群中的一个对换。群论的一个基本定理是，所有对换的集合可以生成整个对称群 $S_N$。这意味着任何排列都可以通过一系列交换从任何其他排列得到。由于我们的移动集允许我们独立地对 $K$ 个类别排列中的任何一个应用交换，我们可以将 $s_a$ 中的 $K$ 个排列中的每一个都转换为与 $s_b$ 中的相匹配。因此，整个状态空间 $\\mathcal{S} = (S_N)^K$ 是连通的。\n\n- **非周期性**：如果对于任何状态 $s$，从 $s$ 回到自身的所有可能路径长度的最大公约数为 $1$，则马尔可夫链是非周期的。一个保证非周期性的充分条件是，停留在任何状态 $s$ 的概率 $P(s \\to s)$ 非零。在我们的算法中，如果一个到 $s' \\neq s$ 的提议移动被拒绝，就会发生自转移。只要当前状态 $s$ 不是全局能量最大值，就有可能提议一个移动到 $E(s') > E(s)$ 的状态 $s'$。对于这样的移动，$\\Delta E > 0$，接受概率 $\\exp(-\\Delta E / T)$ 小于 $1$。拒绝此移动的概率是 $1 - \\exp(-\\Delta E/T) > 0$。由于提议这样的移动和拒绝它都有非零概率，因此停留在状态 $s$ 的总概率大于零（$P(s \\to s) > 0$）。这确保了链是非周期的。\n\n由于链是遍历的且满足细致平衡，它保证会收敛到玻尔兹曼分布 $\\pi_T(s)$。该算法通过从几个独立的随机初始状态运行MCMC模拟固定的步数，并报告在所有运行和所有步骤中找到的最低能量。这增加了找到全局最小能量的机会，对于一个可满足的谜题，该能量为 $E_{\\min}=0$。\n\n```python\nimport numpy as np\n\n# Puzzle A Definition\npuzzle_a_def = {\n    \"N\": 4, \"K\": 3,\n    \"categories\": {\"color\": 0, \"pet\": 1, \"drink\": 2},\n    \"values\": {\n        0: {\"Yellow\": 0, \"Blue\": 1, \"Red\": 2, \"Green\": 3},\n        1: {\"Cat\": 0, \"Dog\": 1, \"Fish\": 2, \"Bird\": 3},\n        2: {\"Coffee\": 0, \"Tea\": 1, \"Milk\": 2, \"Water\": 3},\n    },\n    \"constraints\": [\n        (\"IMMEDIATE_LEFT\", (\"color\", \"Red\"), (\"color\", \"Green\")),\n        (\"EQUALITY\", (\"drink\", \"Tea\"), (\"color\", \"Blue\")),\n        (\"ADJACENCY\", (\"pet\", \"Dog\"), (\"color\", \"Yellow\")),\n        (\"FIXED_POS\", (\"drink\", \"Milk\"), 2),\n        (\"FIXED_POS\", (\"pet\", \"Cat\"), 0),\n        (\"INEQUALITY\", (\"drink\", \"Water\"), (\"color\", \"Yellow\")),\n        (\"STRICT_RIGHT_OF\", (\"pet\", \"Bird\"), (\"color\", \"Red\")),\n        (\"INEQUALITY\", (\"pet\", \"Fish\"), (\"color\", \"Green\")),\n        (\"EQUALITY\", (\"drink\", \"Coffee\"), (\"color\", \"Yellow\")),\n    ]\n}\n\n# Puzzle B Definition\npuzzle_b_def = {\n    \"N\": 3, \"K\": 3,\n    \"categories\": {\"color\": 0, \"pet\": 1, \"drink\": 2},\n    \"values\": {\n        0: {\"Red\": 0, \"Green\": 1, \"Blue\": 2},\n        1: {\"Dog\": 0, \"Cat\": 1, \"Fish\": 2},\n        2: {\"Tea\": 0, \"Milk\": 1, \"Coffee\": 2},\n    },\n    \"constraints\": [\n        (\"EQUALITY\", (\"color\", \"Red\"), (\"drink\", \"Tea\")),\n        (\"FIXED_POS\", (\"pet\", \"Cat\"), 1),\n        (\"STRICT_RIGHT_OF\", (\"color\", \"Blue\"), (\"color\", \"Green\")),\n        (\"INEQUALITY\", (\"pet\", \"Fish\"), (\"color\", \"Red\")),\n        (\"ADJACENCY\", (\"drink\", \"Milk\"), (\"pet\", \"Dog\")),\n        (\"EQUALITY\", (\"drink\", \"Coffee\"), (\"color\", \"Blue\")),\n    ]\n}\n\n# Puzzle C Definition\npuzzle_c_def = {\n    \"N\": 3, \"K\": 3,\n    \"categories\": {\"color\": 0, \"pet\": 1, \"drink\": 2},\n    \"values\": {\n        0: {\"Red\": 0, \"Green\": 1, \"Blue\": 2},\n        1: {\"Dog\": 0, \"Cat\": 1, \"Fish\": 2},\n        2: {\"Tea\": 0, \"Milk\": 1, \"Coffee\": 2},\n    },\n    \"constraints\": [\n        (\"EQUALITY\", (\"drink\", \"Tea\"), (\"color\", \"Red\")),\n        (\"EQUALITY\", (\"drink\", \"Coffee\"), (\"color\", \"Red\")),\n        (\"FIXED_POS\", (\"pet\", \"Dog\"), 0),\n        (\"FIXED_POS\", (\"color\", \"Blue\"), 2),\n        (\"ADJACENCY\", (\"drink\", \"Milk\"), (\"pet\", \"Cat\")),\n        (\"STRICT_RIGHT_OF\", (\"pet\", \"Fish\"), (\"color\", \"Green\")),\n    ]\n}\n\nPUZZLES = [puzzle_a_def, puzzle_b_def, puzzle_c_def]\n\nclass MCMCSolver:\n    def __init__(self, puzzle_def, T, S, R, base_seed):\n        self.N = puzzle_def[\"N\"]\n        self.K = puzzle_def[\"K\"]\n        self.T = T\n        self.S = S\n        self.R = R\n        self.base_seed = base_seed\n\n        self.cat_map = puzzle_def[\"categories\"]\n        self.val_maps = puzzle_def[\"values\"]\n        \n        self.parsed_constraints = self._parse_constraints(puzzle_def[\"constraints\"])\n\n    def _parse_constraints(self, constraints_def):\n        parsed = []\n        for c in constraints_def:\n            ctype = c[0]\n            if ctype in (\"EQUALITY\", \"INEQUALITY\", \"ADJACENCY\", \"IMMEDIATE_LEFT\", \"STRICT_RIGHT_OF\"):\n                cat1_name, val1_name = c[1]\n                cat2_name, val2_name = c[2]\n                k1 = self.cat_map[cat1_name]\n                k2 = self.cat_map[cat2_name]\n                v1 = self.val_maps[k1][val1_name]\n                v2 = self.val_maps[k2][val2_name]\n                parsed.append((ctype, (k1, v1), (k2, v2)))\n            elif ctype == \"FIXED_POS\":\n                cat_name, val_name = c[1]\n                pos = c[2]\n                k = self.cat_map[cat_name]\n                v = self.val_maps[k][val_name]\n                parsed.append((ctype, (k, v), pos))\n        return parsed\n\n    def _evaluate_energy(self, val_to_pos_map):\n        violations = 0\n        for ctype, term1, term2 in self.parsed_constraints:\n            if ctype == \"EQUALITY\":\n                k1, v1 = term1\n                k2, v2 = term2\n                if val_to_pos_map[k1, v1] != val_to_pos_map[k2, v2]:\n                    violations += 1\n            elif ctype == \"INEQUALITY\":\n                k1, v1 = term1\n                k2, v2 = term2\n                if val_to_pos_map[k1, v1] == val_to_pos_map[k2, v2]:\n                    violations += 1\n            elif ctype == \"FIXED_POS\":\n                k, v = term1\n                pos = term2\n                if val_to_pos_map[k, v] != pos:\n                    violations += 1\n            elif ctype == \"ADJACENCY\":\n                k1, v1 = term1\n                k2, v2 = term2\n                if abs(val_to_pos_map[k1, v1] - val_to_pos_map[k2, v2]) != 1:\n                    violations += 1\n            elif ctype == \"IMMEDIATE_LEFT\":\n                k1, v1 = term1\n                k2, v2 = term2\n                if val_to_pos_map[k1, v1] + 1 != val_to_pos_map[k2, v2]:\n                    violations += 1\n            elif ctype == \"STRICT_RIGHT_OF\":\n                k1, v1 = term1\n                k2, v2 = term2\n                if val_to_pos_map[k1, v1] = val_to_pos_map[k2, v2]:\n                    violations += 1\n        return violations\n\n    def run(self):\n        min_global_energy = float('inf')\n\n        for r in range(self.R):\n            seed = self.base_seed + r\n            rng = np.random.default_rng(seed)\n\n            # Initialize state\n            pos_to_val = np.empty((self.K, self.N), dtype=int)\n            val_to_pos = np.empty((self.K, self.N), dtype=int)\n            for k in range(self.K):\n                perm = rng.permutation(self.N)\n                pos_to_val[k, :] = perm\n                for p, v in enumerate(perm):\n                    val_to_pos[k, v] = p\n\n            current_energy = self._evaluate_energy(val_to_pos)\n            min_restart_energy = current_energy\n\n            for _ in range(self.S):\n                # Propose a move\n                k_swap = rng.integers(self.K)\n                p1, p2 = rng.choice(self.N, 2, replace=False)\n                \n                # Create a proposed state by swapping\n                prop_pos_to_val = np.copy(pos_to_val)\n                prop_val_to_pos = np.copy(val_to_pos)\n\n                v1, v2 = prop_pos_to_val[k_swap, p1], prop_pos_to_val[k_swap, p2]\n                prop_pos_to_val[k_swap, p1], prop_pos_to_val[k_swap, p2] = v2, v1\n                prop_val_to_pos[k_swap, v1], prop_val_to_pos[k_swap, v2] = p2, p1\n                \n                proposed_energy = self._evaluate_energy(prop_val_to_pos)\n                \n                delta_E = proposed_energy - current_energy\n                \n                # Metropolis acceptance criterion\n                if delta_E = 0 or rng.random()  np.exp(-delta_E / self.T):\n                    pos_to_val = prop_pos_to_val\n                    val_to_pos = prop_val_to_pos\n                    current_energy = proposed_energy\n                \n                if current_energy  min_restart_energy:\n                    min_restart_energy = current_energy\n\n            if min_restart_energy  min_global_energy:\n                min_global_energy = min_restart_energy\n        \n        return int(min_global_energy)\n\ndef solve():\n    T = 0.7\n    S = 30000\n    R = 8\n    SEEDS = [20231105, 20231106, 20231107]\n    \n    test_cases = [\n        (PUZZLES[0], T, S, R, SEEDS[0]),\n        (PUZZLES[1], T, S, R, SEEDS[1]),\n        (PUZZLES[2], T, S, R, SEEDS[2]),\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = MCMCSolver(*case)\n        min_energy = solver.run()\n        results.append(min_energy)\n    \n    # Final print statement in the exact required format.\n    # print(f\"[{','.join(map(str, results))}]\")\n    # Expected output: [0,0,1]\n\n```", "answer": "```\n[0,0,1]\n```", "id": "2385680"}]}