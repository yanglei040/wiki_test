{"hands_on_practices": [{"introduction": "本实践旨在建立微观能量涨落与宏观热力学量——热容之间的联系。通过精确枚举一个小尺寸系统的所有可能状态，你将亲手验证统计力学的一块基石——涨落-耗散定理。这项练习将具体展示宏观属性如何从微观的统计行为中涌现 [@problem_id:2448166]。", "problem": "考虑一个线性尺寸为$L$、具有周期性边界条件、零外场和均匀最近邻耦合$J$的二维方形晶格上的伊辛模型。每个自旋$s_i$的取值为$\\{-1,+1\\}$。其哈密顿量为\n$$\n\\mathcal{H}(\\{s\\}) \\;=\\; -J \\sum_{\\langle i,j\\rangle} s_i s_j,\n$$\n其中，求和遍及所有满足周期性边界条件的、不同的最近邻对。在绝对温度为$T$、玻尔兹曼常数为$k_{\\mathrm B}$的正则系综平衡下进行研究，并定义总自旋数$N=L^2$，逆温度$\\beta = 1/(k_{\\mathrm B} T)$，配分函数\n$$\nZ(\\beta) \\;=\\; \\sum_{\\{s\\}} e^{-\\beta \\mathcal{H}(\\{s\\})},\n$$\n以及由正则系综导出的总能量概率分布$P(E)$。令$g(E)$表示态密度（总能量恰好等于$E$的微观态数量）。则\n$$\nP(E) \\;=\\; \\frac{g(E)\\, e^{-\\beta E}}{Z(\\beta)}.\n$$\n\n任务：\n1. 对于指定的系统，计算由正则系综导出的离散能量分布$P(E)$，并验证其归一化。\n2. 根据$P(E)$计算平均能量$\\langle E\\rangle$和方差$\\mathrm{Var}(E)=\\langle E^2\\rangle - \\langle E\\rangle^2$。\n3. 计算由下式定义的单位自旋热容$c(T)$：\n$$\nc(T) \\;=\\; \\frac{1}{N}\\,\\frac{d\\langle E\\rangle}{dT}.\n$$\n仅使用上述基本定义，证明能量$E$的方差与热容之间的关系。\n\n所有计算均使用以下固定参数：\n- $L=4$,\n- $J=1$,\n- $k_{\\mathrm B}=1$。\n因此，在这些单位下，所有能量、温度和热容均为无量纲量。此问题不涉及角度，也不需要其他物理单位。\n\n测试集（三个用于探测性质上不同区域的温度）：\n- 低温 $T=0.5$，\n- 近临界温度 $T=2.2691853$，\n- 高温 $T=5.0$。\n\n对于上述给定的每个温度，按顺序生成三个输出：\n- 一个布尔值，表示$\\sum_E P(E)$是否在$10^{-12}$的绝对容差内等于$1$，\n- 单位自旋方差$\\mathrm{Var}(E)/N$，以实数形式表示，\n- 单位自旋热容$c(T)$，以实数形式表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含汇总了三个温度下结果的、用逗号分隔并由方括号括起来的列表。该列表必须精确包含九个条目，排列如下\n$$\n[\\text{norm\\_ok}_{T=0.5},\\, \\mathrm{Var}(E)/N\\big|_{T=0.5},\\, c(T)\\big|_{T=0.5},\\, \\text{norm\\_ok}_{T=2.2691853},\\, \\mathrm{Var}(E)/N\\big|_{T=2.2691853},\\, c(T)\\big|_{T=2.2691853},\\, \\text{norm\\_ok}_{T=5.0},\\, \\mathrm{Var}(E)/N\\big|_{T=5.0},\\, c(T)\\big|_{T=5.0}],\n$$\n其中每个$\\text{norm\\_ok}_{T}$是布尔字面量True或False，每个实数均以十进制形式打印。不应打印任何额外文本。", "solution": "对于任意有限的$L$，在具有周期性边界条件的$L\\times L$晶格上，哈密顿量为$\\mathcal{H}(\\{s\\}) = -J \\sum_{\\langle i,j\\rangle} s_i s_j$的二维伊辛模型具有有限的微观态集合。在温度$T$下，当系统处于正则系综平衡时，一个微观态$\\{s\\}$的概率由玻尔兹曼因子除以配分函数给出，即$p(\\{s\\}) = e^{-\\beta \\mathcal{H}(\\{s\\})}/Z(\\beta)$，其中$\\beta = 1/(k_{\\mathrm B} T)$且$Z(\\beta) = \\sum_{\\{s\\}} e^{-\\beta \\mathcal{H}(\\{s\\})}$。将微观态按其总能量$E$分组，定义了态密度$g(E)$，并得到正则能量分布\n$$\nP(E) \\;=\\; \\frac{g(E)\\, e^{-\\beta E}}{Z(\\beta)}.\n$$\n归一化可由定义得出：\n$$\n\\sum_E P(E) \\;=\\; \\sum_E \\frac{g(E)\\, e^{-\\beta E}}{Z(\\beta)} \\;=\\; \\frac{1}{Z(\\beta)} \\sum_{\\{s\\}} e^{-\\beta \\mathcal{H}(\\{s\\})} \\;=\\; 1.\n$$\n\n从基本定义出发，平均能量和能量平方的平均值为\n$$\n\\langle E\\rangle \\;=\\; \\sum_E E\\, P(E), \n\\qquad\n\\langle E^2\\rangle \\;=\\; \\sum_E E^2\\, P(E),\n$$\n方差则为$\\mathrm{Var}(E) = \\langle E^2\\rangle - \\langle E\\rangle^2$。\n\n为将方差与热容联系起来，我们从配分函数$Z(\\beta)$及其对数开始。对$\\beta$求导得\n$$\n\\frac{\\partial \\ln Z}{\\partial \\beta} \n\\;=\\; \\frac{1}{Z}\\frac{\\partial Z}{\\partial \\beta}\n\\;=\\; \\frac{1}{Z} \\sum_{\\{s\\}} \\left(-\\mathcal{H}(\\{s\\})\\right) e^{-\\beta \\mathcal{H}(\\{s\\})}\n\\;=\\; - \\langle E\\rangle.\n$$\n再次求导，\n$$\n\\frac{\\partial^2 \\ln Z}{\\partial \\beta^2}\n\\;=\\; -\\frac{\\partial \\langle E\\rangle}{\\partial \\beta}\n\\;=\\; \\langle E^2\\rangle - \\langle E\\rangle^2\n\\;=\\; \\mathrm{Var}(E).\n$$\n总热容$C$定义为\n$$\nC \\;=\\; \\frac{d\\langle E\\rangle}{dT}.\n$$\n使用$\\beta = 1/(k_{\\mathrm B} T)$，我们有$d\\beta/dT = -1/(k_{\\mathrm B} T^2)$。因此，\n$$\nC \\;=\\; \\frac{d\\langle E\\rangle}{d\\beta} \\frac{d\\beta}{dT}\n\\;=\\; \\left(-\\frac{\\partial^2 \\ln Z}{\\partial \\beta^2}\\right)\\left(-\\frac{1}{k_{\\mathrm B} T^2}\\right)\n\\;=\\; \\frac{\\mathrm{Var}(E)}{k_{\\mathrm B} T^2}.\n$$\n除以自旋总数$N=L^2$，得到单位自旋热容\n$$\nc(T) \\;=\\; \\frac{C}{N} \\;=\\; \\frac{\\mathrm{Var}(E)}{N\\, k_{\\mathrm B}\\, T^2}.\n$$\n\n当$J=1$和$k_{\\mathrm B}=1$时，所有物理量均为无量纲量，上式简化为$c(T) = \\mathrm{Var}(E)/(N T^2)$。这个恒等式直接从正则系综的定义中得出，并精确地展示了能量的方差如何决定热容。\n\n从算法上讲，对于有限的$L$，可以通过构建所有自旋构型$\\{s\\}$，使用带周期性边界条件的哈密顿量计算它们的能量，统计每种不同能量的出现次数以构成$g(E)$，然后用$Z = \\sum_E g(E) e^{-\\beta E}$计算$P(E) = g(E) e^{-\\beta E}/Z$，从而获得$g(E)$。从$P(E)$出发，计算$\\langle E\\rangle$、$\\langle E^2\\rangle$、$\\mathrm{Var}(E)$，最后计算$c(T)=\\mathrm{Var}(E)/(N T^2)$。归一化检验用于验证$\\sum_E P(E)$在指定的数值容差内等于$1$。所选的测试温度$T=0.5$、$T=2.2691853$和$T=5.0$涵盖了低温、近临界和高温区域；相应地，对于这个有限系统，单位自旋方差在极低和极高温度下很小，在临界区附近较大，而单位自旋热容则遵循由$c(T) = \\mathrm{Var}(E)/(N T^2)$决定的相同定性趋势。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ising_energy_spectrum_L(L: int, J: float = 1.0):\n    \"\"\"\n    Compute the energy spectrum (unique energies and their degeneracies g(E))\n    for the 2D Ising model on an LxL lattice with periodic boundary conditions\n    and zero external field, with coupling J.\n\n    Returns:\n        E_values: np.ndarray of shape (M,), sorted unique energies (dtype=int64)\n        g_values: np.ndarray of shape (M,), degeneracy counts for each energy (dtype=int64)\n        N: total number of spins (int)\n    \"\"\"\n    N = L * L\n    # Neighbor indices for counting each bond once: right and down neighbors\n    right = np.empty(N, dtype=np.int64)\n    down = np.empty(N, dtype=np.int64)\n    for r in range(L):\n        for c in range(L):\n            idx = r * L + c\n            right[idx] = r * L + ((c + 1) % L)\n            down[idx] = ((r + 1) % L) * L + c\n\n    # Enumerate all spin configurations via bit representation\n    num_states = 1 << N  # 2^N\n    states = np.arange(num_states, dtype=np.uint32)  # shape (num_states,)\n    masks = (1 << np.arange(N, dtype=np.uint32))     # shape (N,)\n\n    # Convert bits to spins in {-1, +1}\n    bits = ((states[:, None] & masks) != 0).astype(np.int8)  # shape (num_states, N)\n    spins = (bits << 1) - 1  # 0->-1, 1->+1\n\n    # Compute total energy for each configuration; count each bond once (right and down)\n    # E = -J * sum_{i} (s_i s_{right(i)} + s_i s_{down(i)})\n    # We can vectorize using advanced indexing over columns\n    prod_right = spins * spins[:, right]\n    prod_down = spins * spins[:, down]\n    bond_sum = prod_right + prod_down\n    # Sum over all sites to get total bond contribution, then multiply by -J\n    E = (-J * bond_sum.sum(axis=1)).astype(np.int64)  # shape (num_states,)\n\n    # Get unique energies and degeneracies g(E)\n    E_values, g_values = np.unique(E, return_counts=True)\n    g_values = g_values.astype(np.int64)\n    return E_values.astype(np.int64), g_values, N\n\ndef canonical_stats_from_spectrum(E_values, g_values, T: float, kB: float = 1.0):\n    \"\"\"\n    Given energy levels E_values (int) and degeneracies g_values (int),\n    compute canonical probabilities P(E), mean energy, mean squared energy,\n    and variance at temperature T with Boltzmann constant kB.\n    \"\"\"\n    beta = 1.0 / (kB * T)\n    E_float = E_values.astype(np.float64)\n    g_float = g_values.astype(np.float64)\n\n    # Unnormalized weights: w(E) = g(E) * exp(-beta * E)\n    # For numerical stability here, direct exponentiation is sufficient for given L and T.\n    weights = g_float * np.exp(-beta * E_float)\n    Z = weights.sum()\n    P_E = weights / Z\n\n    # Normalization check\n    norm_ok = bool(np.isclose(P_E.sum(), 1.0, atol=1e-12, rtol=0.0))\n\n    # Moments\n    mean_E = np.sum(P_E * E_float)\n    mean_E2 = np.sum(P_E * (E_float ** 2))\n    var_E = mean_E2 - mean_E ** 2\n    # Guard against tiny negative due to floating errors\n    if var_E < 0 and var_E > -1e-18:\n        var_E = 0.0\n\n    return norm_ok, mean_E, mean_E2, var_E\n\ndef solve():\n    # Define the test cases from the problem statement.\n    L = 4\n    J = 1.0\n    kB = 1.0\n    test_temperatures = [0.5, 2.2691853, 5.0]\n\n    # Precompute spectrum for given L and J\n    E_values, g_values, N = ising_energy_spectrum_L(L=L, J=J)\n\n    results = []\n    for T in test_temperatures:\n        norm_ok, mean_E, mean_E2, var_E = canonical_stats_from_spectrum(E_values, g_values, T=T, kB=kB)\n        var_per_spin = var_E / N\n        c_per_spin = var_E / (N * (T ** 2) * kB)  # with kB=1.0\n        results.append(norm_ok)\n        results.append(var_per_spin)\n        results.append(c_per_spin)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2448166"}, {"introduction": "接下来，我们将介绍一种强大的计算工具——传递矩阵方法，它是求解带状几何上统计模型的关键技术。你将为二维伊辛模型构建传递矩阵，并利用其本征值来计算关联长度 $\\xi$。这个练习不仅能让你掌握一种非蒙特卡洛的计算方法，还能加深你对长程有序和关联如何被编码在算符谱中的理解 [@problem_id:2384603]。", "problem": "考虑一个宽度为 $W$ 的条带上的铁磁性二维（2D）Ising 模型，该条带在宽度方向上具有周期性边界条件，传递方向沿行方向。设每个自旋 $s_i \\in \\{-1,+1\\}$，沿传递方向（连续行之间）的最近邻耦合由无量纲耦合常数 $K_v$ 给出，行内（水平方向）的最近邻耦合由无量纲耦合常数 $K_h$ 给出。行间传递矩阵 $T$ 定义在行构型的 $2^W$ 维空间上。对于两个连续的行构型 $\\boldsymbol{s}$ 和 $\\boldsymbol{s}'$，定义\n$$\n\\mathcal{H}_{\\text{row}}(\\boldsymbol{s})=\\sum_{i=1}^{W} s_i s_{i+1},\\quad s_{W+1}\\equiv s_1,\\qquad\n\\mathcal{V}(\\boldsymbol{s},\\boldsymbol{s}')=\\sum_{i=1}^{W} s_i s_i',\n$$\n以及对称传递矩阵的矩阵元\n$$\nT_{\\boldsymbol{s},\\boldsymbol{s}'}=\\exp\\!\\left(K_v\\,\\mathcal{V}(\\boldsymbol{s},\\boldsymbol{s}')+\\frac{K_h}{2}\\,\\mathcal{H}_{\\text{row}}(\\boldsymbol{s})+\\frac{K_h}{2}\\,\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}')\\right).\n$$\n设 $\\lambda_0$ 为 $T$ 的最大特征值，$\\lambda_1$ 为模第二大的特征值。沿传递方向的相关长度 $\\xi$（以行间晶格间距为单位）定义为\n$$\n\\xi=\\frac{1}{\\ln\\!\\left(\\frac{\\lambda_0}{|\\lambda_1|}\\right)}.\n$$\n构建一个程序，对于下面提供的每个测试用例，精确地按照定义构建 $T$，确定如上定义的 $\\lambda_0$ 和 $\\lambda_1$，并返回相应的 $\\xi$。如果在数值精度范围内 $|\\lambda_1|$ 实际上为零，则定义 $\\xi=0$。\n\n所有输出都必须以沿传递方向的晶格间距为单位的无量纲量报告。本问题不涉及角度。最终输出必须是单行，包含一个由方括号括起来的逗号分隔列表，其中包含所有测试用例的相关长度，每个值四舍五入到 $8$ 位小数，例如 $[\\xi_1,\\xi_2,\\xi_3]$。\n\n使用以下参数值测试套件：\n- 测试用例A（边界尺寸条带）：$W=1$, $K_v=0.4$, $K_h=0.4$。\n- 测试用例B（高温各向异性）：$W=3$, $K_v=0.1$, $K_h=0.2$。\n- 测试用例C（中等宽度条带上的近临界各向同性）：$W=4$, $K_v=0.4$, $K_h=0.4$。\n- 测试用例D（较宽条带上的低温各向同性）：$W=5$, $K_v=0.7$, $K_h=0.7$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D]$），每个条目四舍五入到 $8$ 位小数。每个结果必须是浮点数。", "solution": "所述问题是有效的。它在科学上基于统计力学的原理，特别是二维Ising模型的传递矩阵表述。其定义和参数是完整的、数学上一致的、且是适定的，允许一个唯一且稳定的数值解。问题陈述中没有矛盾、歧义或事实错误。我将继续提供完整解法。\n\n问题要求计算有限宽度条带上铁磁性二维Ising模型的相关长度 $\\xi$。完成此任务的基本理论工具是传递矩阵方法。对于一个宽度为 $W$、长度为 $N$ 的晶格上的系统，配分函数 $Z$ 可以表示为行间传递矩阵 $T$ 的 $N$ 次方的迹：$Z = \\text{Tr}(T^N)$。在条带长度 $N \\to \\infty$ 的热力学极限下，系统的物理性质由传递矩阵 $T$ 的最大特征值 $\\lambda_0$ 主导。\n\n相关长度 $\\xi$ 表征了自旋-自旋关联函数随距离的指数衰减。沿着传递方向，这种衰减由最大特征值 $\\lambda_0$ 与模第二大的特征值（我们记为 $\\lambda_1$）之比决定。以行间晶格间距为单位测量的相关长度由以下公式给出：\n$$\n\\xi = \\frac{1}{\\ln\\left(\\frac{\\lambda_0}{|\\lambda_1|}\\right)}\n$$\n我们的任务是根据给定参数构建矩阵 $T$，计算其特征值，并使用此公式求出 $\\xi$。\n\n传递矩阵 $T$ 作用于由单行所有可能的自旋构型所张成的向量空间上。对于宽度为 $W$ 的条带，一个行构型是一个向量 $\\boldsymbol{s} = (s_1, s_2, \\dots, s_W)$，其中每个自旋 $s_i \\in \\{-1, +1\\}$。此类构型的总数为 $2^W$，因此 $T$ 是一个 $2^W \\times 2^W$ 的矩阵。该矩阵的索引对应于行构型。\n\n矩阵元 $T_{\\boldsymbol{s},\\boldsymbol{s}'}$ 连接一行中的构型 $\\boldsymbol{s}$ 与下一行中的构型 $\\boldsymbol{s}'$。问题为此矩阵元提供了一个对称的定义：\n$$\nT_{\\boldsymbol{s},\\boldsymbol{s}'} = \\exp\\left(K_v\\,\\mathcal{V}(\\boldsymbol{s},\\boldsymbol{s}') + \\frac{K_h}{2}\\,\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}) + \\frac{K_h}{2}\\,\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}')\\right)\n$$\n其中 $K_v$ 和 $K_h$ 分别是垂直和水平耦合常数。指数中的项代表相互作用能：\n1.  $\\mathcal{V}(\\boldsymbol{s},\\boldsymbol{s}') = \\sum_{i=1}^{W} s_i s_i'$ 是构型为 $\\boldsymbol{s}$ 和 $\\boldsymbol{s}'$ 的相邻两行之间的相互作用能。\n2.  $\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}) = \\sum_{i=1}^{W} s_i s_{i+1}$（具有周期性边界条件 $s_{W+1} \\equiv s_1$）是构型为 $\\boldsymbol{s}$ 的行内的相互作用能。将此项对称地分配给两个构型 $\\boldsymbol{s}$ 和 $\\boldsymbol{s}'$ 确保了最终得到的矩阵 $T$ 是对称的（$T_{\\boldsymbol{s},\\boldsymbol{s}'} = T_{\\boldsymbol{s}',\\boldsymbol{s}}$）。\n\n算法步骤如下：\n1.  **生成状态空间**：对于给定的宽度 $W$，我们首先列举所有 $2^W$ 种可能的自旋构型。这可以通过将其二进制表示，将从 $0$ 到 $2^W-1$ 的整数 $k$ 映射到唯一的自旋向量来完成。例如，一个整数的比特位 $b_i \\in \\{0, 1\\}$ 可以通过诸如 $s_i = 1 - 2b_i$ 的变换映射到自旋 $s_i \\in \\{+1, -1\\}$。这些构型存储在一个大小为 $2^W \\times W$ 的矩阵中。\n\n2.  **构建传递矩阵 $T$**：我们构建 $2^W \\times 2^W$ 的矩阵 $T$。为了提高计算效率，此过程适合进行向量化操作。\n    - 对所有 $2^W$ 种构型，预先计算行内相互作用能 $\\mathcal{H}_{\\text{row}}(\\boldsymbol{s})$。\n    - 所有行间能量组成的矩阵，其矩阵元为 $\\mathcal{V}_{ij} = \\mathcal{V}(\\boldsymbol{s}^{(i)}, \\boldsymbol{s}^{(j)})$，可以通过构型矩阵与其转置的矩阵乘积来计算。\n    - 行内能量之和的矩阵，其矩阵元为 $(\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}^{(i)}) + \\mathcal{H}_{\\text{row}}(\\boldsymbol{s}^{(j)}))$，是通过对预先计算的能量向量使用广播操作来形成的。\n    - 最后，根据定义使用指数函数逐元素计算 $T$ 的矩阵元。\n\n3.  **求解特征值问题**：由于 $T$ 是一个实对称矩阵，其所有特征值都是实数。我们使用为对称矩阵优化的标准数值特征求解器来找到完整的谱。这些求解器通常按升序返回排序后的特征值。对于任何实数耦合 $K_v, K_h$，$T$ 的矩阵元都是严格为正的，因此根据Perron-Frobenius定理，存在一个唯一的最大特征值 $\\lambda_0$，它是正的且重数为一。\n\n4.  **计算相关长度**：\n    - 最大特征值 $\\lambda_0$ 是已排序特征值数组的最后一个元素。\n    - 为了找到模第二大的特征值 $|\\lambda_1|$，我们确定所有其他特征值绝对值的最大值。\n    - 然后使用公式 $\\xi = 1/\\ln(\\lambda_0/|\\lambda_1|)$ 计算相关长度 $\\xi$。根据问题说明，如果 $|\\lambda_1|$ 在数值上为零（在机器精度内），我们定义 $\\xi=0$。\n\n此过程是确定性的，并为所定义的有限宽度系统提供了精确的相关长度。该实现将把此方法应用于每个指定的测试用例。", "answer": "```python\nimport numpy as np\n\ndef calculate_xi(W, K_v, K_h):\n    \"\"\"\n    Calculates the correlation length for the 2D Ising model on a strip.\n\n    Args:\n        W (int): The width of the strip.\n        K_v (float): The dimensionless vertical coupling.\n        K_h (float): The dimensionless horizontal coupling.\n\n    Returns:\n        float: The calculated correlation length xi.\n    \"\"\"\n    num_configs = 1 << W\n\n    # Step 1: Generate all 2^W spin configurations.\n    # We map integers 0 to 2^W-1 to spin configurations {-1, +1}^W.\n    # The j-th bit of integer i corresponds to the j-th spin.\n    # We use bit order from MSB to LSB for s_1 to s_W.\n    indices = np.arange(num_configs, dtype=int)\n    bit_positions = np.arange(W - 1, -1, -1)\n    bits = ((indices[:, None] & (1 << bit_positions)) > 0).astype(np.int8)\n    configs = 1 - 2 * bits  # Map {0, 1} -> {+1, -1}\n\n    # Step 2: Pre-calculate the horizontal interaction energy H_row for each configuration.\n    # H_row(s) = sum(s_i * s_{i+1}) with periodic s_{W+1}=s_1.\n    # np.roll shifts columns cyclically, implementing the periodic boundary condition.\n    H_values = np.sum(configs * np.roll(configs, -1, axis=1), axis=1)\n\n    # Step 3: Build the transfer matrix T in a vectorized manner.\n    # V_ij = sum(s_i_k * s_j_k), the vertical interaction between rows.\n    # This is equivalent to a matrix multiplication of the configs with its transpose.\n    V = configs @ configs.T\n\n    # H_sum_ij = H_i + H_j\n    # This is constructed using numpy's broadcasting rules.\n    H_sum = H_values[:, None] + H_values[None, :]\n\n    # T_ij = exp(K_v * V_ij + 0.5 * K_h * (H_i + H_j))\n    T = np.exp(K_v * V + 0.5 * K_h * H_sum)\n\n    # Step 4: Find eigenvalues.\n    # T is real and symmetric, so we use np.linalg.eigvalsh for efficiency.\n    # It returns real eigenvalues sorted in ascending order.\n    eigenvalues = np.linalg.eigvalsh(T)\n\n    # Step 5: Identify lambda_0 and the magnitude of lambda_1.\n    # lambda_0 is the largest eigenvalue.\n    lambda_0 = eigenvalues[-1]\n\n    # This case is not strictly necessary for W >= 1, but is good practice.\n    if num_configs < 2:\n        return 0.0\n\n    # |lambda_1| is the second-largest eigenvalue in magnitude. We find it by\n    # taking the maximum of the absolute values of all other eigenvalues.\n    other_evals = eigenvalues[:-1]\n    abs_lambda_1 = np.max(np.abs(other_evals))\n\n    # Step 6: Calculate the correlation length xi.\n    # Handle the case where the second largest eigenvalue is numerically zero.\n    if abs_lambda_1 < 1e-15:\n        return 0.0\n\n    # The ratio must be > 1 for the logarithm to be positive. For a positive\n    # matrix, Perron-Frobenius guarantees lambda_0 > |lambda_k| for all k!=0.\n    ratio = lambda_0 / abs_lambda_1\n    if ratio <= 1.0:\n        # This case suggests numerical instability or degeneracy,\n        # which is not expected here. Returning infinity for a critical system.\n        return np.inf\n\n    xi = 1.0 / np.log(ratio)\n\n    return xi\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite of parameters.\n    \"\"\"\n    test_cases = [\n        # (W, K_v, K_h)\n        (1, 0.4, 0.4),  # Test case A\n        (3, 0.1, 0.2),  # Test case B\n        (4, 0.4, 0.4),  # Test case C\n        (5, 0.7, 0.7),  # Test case D\n    ]\n\n    results = []\n    for W, K_v, K_h in test_cases:\n        xi = calculate_xi(W, K_v, K_h)\n        results.append(xi)\n\n    # Format the results to 8 decimal places and print in the required format.\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "2384603"}, {"introduction": "最后，我们进入临界现象研究的核心：利用有限尺寸标度理论提取普适的临界指数。在本练习中，你将使用模仿大规模模拟得出的合成数据，通过对数-对数坐标下的线性回归分析，估算临界指数 $\\beta$、$\\gamma$ 和 $\\nu$。这项实践将教会你现代计算物理学中的一项基本功，展示如何系统地分析有限尺寸系统的模拟数据，以揭示相变点处的普适规律 [@problem_id:2448171]。", "problem": "给定的是二维伊辛模型在 $L \\times L$ 方形晶格上、零外场条件下的合成噪声扰动观测量。目标是利用有限尺寸标度分析来估计临界指数 $\\,\\beta\\,$、$\\,\\gamma\\,$ 和 $\\,\\nu\\,$。您的程序必须从基本定义和有限尺寸标度假设出发，实现一个有据可依的分析，然后通过对所提供数据进行回归来推断指数。本问题中所有量均为无量纲量，因此无需进行单位转换。\n\n基本原理如下。\n\n- 伊辛哈密顿量为 $\\,\\mathcal{H} = -J \\sum_{\\langle i j \\rangle} s_i s_j - h \\sum_i s_i\\,$，其中 $\\,s_i \\in \\{-1,+1\\}\\,$，耦合 $\\,J>0\\,$，并且本问题中场强 $\\,h=0\\,$。\n- 单位自旋的磁化强度为 $\\,m = L^{-2} \\sum_i s_i\\,$。静态磁化率为 $\\,\\chi = L^{2} \\left(\\langle m^2 \\rangle - \\langle m \\rangle^2 \\right)/T\\,$。\n- 具有最近邻相互作用的二维模型有一个已知的临界温度 $\\,T_c = \\dfrac{2J}{\\ln(1+\\sqrt{2})}\\,$。在约化单位（$\\,J=1\\,$ 和玻尔兹曼常数 $\\,k_B=1\\,$）下，我们使用 $\\,T_c = 2/\\ln(1+\\sqrt{2}) \\approx 2.269185314\\,$。\n\n经过充分检验的有限尺寸标度（FSS）假设指出，自由能密度的奇异部分 $\\,f_s(t,h,L) = L^{-d} \\mathcal{F}(t L^{1/\\nu}, h L^{y_h})\\,$，其中 $\\,d=2\\,$ 是空间维度，$\\,t=(T-T_c)/T_c\\,$ 是约化温度，$\\,\\nu\\,$ 是相干长度指数，$\\,y_h\\,$ 是磁场的标度维。从此假设可推断，在临界点 $\\,t=0\\,$ 处，\n- 磁化强度标度关系为 $\\,\\langle |m| \\rangle \\sim L^{-\\beta/\\nu}\\,$，\n- 磁化率标度关系为 $\\,\\chi \\sim L^{\\gamma/\\nu}\\,$，\n- 由磁化率峰值位置定义的赝临界温度 $\\,T_{\\max}(L)\\,$ 随着 $\\,T_{\\max}(L) - T_c \\sim L^{-1/\\nu}\\,$ 趋近于 $\\,T_c\\,$。\n\n您的任务是利用这些标度关系式，通过在适当的对数-对数坐标中拟合直线来估计 $\\,\\beta\\,$、$\\,\\gamma\\,$ 和 $\\,\\nu\\,$。具体来说，对于每个数据集：\n- 拟合 $\\,\\log \\langle |m| \\rangle\\,$ 与 $\\,\\log L\\,$ 的关系以估计斜率 $\\,s_m \\approx -\\beta/\\nu\\,$，\n- 拟合 $\\,\\log \\chi\\,$ 与 $\\,\\log L\\,$ 的关系以估计斜率 $\\,s_\\chi \\approx \\gamma/\\nu\\,$，\n- 拟合 $\\,\\log\\!\\left(T_{\\max}(L)-T_c\\right)\\,$ 与 $\\,\\log L\\,$ 的关系以估计斜率 $\\,s_t \\approx -1/\\nu\\,$，\n然后合并结果得到 $\\,\\nu \\approx -1/s_t\\,$、$\\,\\beta \\approx (-s_m)\\,\\nu\\,$ 和 $\\,\\gamma \\approx (s_\\chi)\\,\\nu\\,$。\n\n对三个拟合使用普通最小二乘法处理对数值。不要假设任何关于精确指数值的先验知识；从数据中推断它们。\n\n测试套件。以下三个数据集模拟了在临界点附近通过马尔可夫链蒙特卡洛（MCMC）产生的测量值，并带有轻微的标度修正。在所有 $\\,T_{\\max}(L)-T_c\\,$ 的计算中，请严格使用下面给出的 $\\,T_c = 2.269185314\\,$。\n\n数据集 A：\n- $\\,L = [8,12,16,24,32,48,64]\\,$\n- $\\,\\langle |m| \\rangle = [0.806300,\\,0.742300,\\,0.706000,\\,0.660900,\\,0.631600,\\,0.595200,\\,0.572000]\\,$\n- $\\,\\chi = [32.300,\\,64.360,\\,105.430,\\,212.330,\\,350.690,\\,707.700,\\,1167.590]\\,$\n- $\\,T_{\\max}(L) = [2.387310314,\\,2.346685314,\\,2.326841314,\\,2.307310314,\\,2.297661914,\\,2.288091314,\\,2.283335714]\\,$\n\n数据集 B：\n- $\\,L = [10,14,20,28,40,56,80]\\,$\n- $\\,\\langle |m| \\rangle = [0.937100,\\,0.864300,\\,0.801600,\\,0.750100,\\,0.703600,\\,0.665300,\\,0.627800]\\,$\n- $\\,\\chi = [45.840,\\,84.620,\\,160.970,\\,293.370,\\,555.000,\\,1003.200,\\,1891.000]\\,$\n- $\\,T_{\\max}(L) = [2.384415314,\\,2.350605314,\\,2.325688314,\\,2.309288314,\\,2.297116314,\\,2.289062314,\\,2.283059314]\\,$\n\n数据集 C：\n- $\\,L = [6,8,10,12,14]\\,$\n- $\\,\\langle |m| \\rangle = [0.904500,\\,0.828700,\\,0.778300,\\,0.743600,\\,0.716900]\\,$\n- $\\,\\chi = [18.790,\\,29.925,\\,43.343,\\,58.709,\\,76.010]\\,$\n- $\\,T_{\\max}(L) = [2.420296314,\\,2.379185314,\\,2.355585314,\\,2.340296314,\\,2.329838314]\\,$\n\n要求：\n- 使用自然对数为每个数据集实现三个独立的最小二乘拟合。\n- 从 $\\,T_{\\max}(L)\\,$ 位移拟合中计算 $\\,\\nu\\,$，然后使用 $\\,\\beta/\\nu\\,$ 和 $\\,\\gamma/\\nu\\,$ 的估计值从磁化强度和磁化率拟合中计算 $\\,\\beta\\,$ 和 $\\,\\gamma\\,$。\n- 对于每个数据集，返回一个列表 $\\,[\\beta, \\gamma, \\nu]\\,$，其中每个值都使用标准的四舍五入法保留三位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含三个数据集的三个列表结果，格式为逗号分隔，并用方括号括起，例如 $\\,[[\\beta_A,\\gamma_A,\\nu_A],[\\beta_B,\\gamma_B,\\nu_B],[\\beta_C,\\gamma_C,\\nu_C]]\\,$。不应打印任何额外文本。\n\n您的解决方案必须是一个完整的、可运行的程序，不读取任何输入，并严格使用上述数据。唯一允许使用的库是 Python 标准库、NumPy 和 SciPy。", "solution": "所提出的问题是计算统计物理学中的一个标准练习。其目标是利用有限尺寸标度的原理，从合成的数值数据中为二维伊辛模型估计临界指数 $\\beta$、$\\gamma$ 和 $\\nu$。该问题定义明确，科学上合理，且内部一致。我们将着手解决。\n\n分析的基础是有限尺寸标度（FSS）假设。对于一个在 $d$ 维空间中线性尺寸为 $L$ 的系统，其自由能密度的奇异部分（记为 $f_s$）在临界点附近，假定具有如下的标度形式：\n$$f_s(t, h, L) = L^{-d} \\mathcal{F}(t L^{1/\\nu}, h L^{y_h})$$\n此处，$t = (T-T_c)/T_c$ 是约化温度，$h$ 是外磁场，$\\nu$ 是相干长度临界指数，$y_h$ 是磁场的标度维。对于本问题，空间维度 $d=2$。分析在临界温度（$t=0$）和零外场（$h=0$）下进行。\n\n从 FSS 假设可以推导出各种热力学量的标度关系。该问题正确地提供了在临界点处进行观测所需的标度关系：\n1.  单位自旋的平均绝对磁化强度 $\\langle |m| \\rangle$ 随系统尺寸 $L$ 的标度关系为：\n    $$\\langle |m| \\rangle \\propto L^{-\\beta/\\nu}$$\n    其中 $\\beta$ 是磁化强度临界指数。\n2.  磁化率 $\\chi$ 的标度关系为：\n    $$\\chi \\propto L^{\\gamma/\\nu}$$\n    其中 $\\gamma$ 是磁化率临界指数。\n3.  有限尺寸系统的磁化率峰值位置 $T_{\\max}(L)$，在热力学极限（$L \\to \\infty$）下，根据以下关系趋近于真实的临界温度 $T_c$：\n    $$T_{\\max}(L) - T_c \\propto L^{-1/\\nu}$$\n这些幂律依赖关系构成了我们估计过程的基础。\n\n为了从所提供的数据中确定指数，我们通过对两边取自然对数，将这些幂律关系转换为线性方程：\n1.  $\\ln(\\langle |m| \\rangle) = C_m - (\\beta/\\nu) \\ln L$\n2.  $\\ln(\\chi) = C_\\chi + (\\gamma/\\nu) \\ln L$\n3.  $\\ln(T_{\\max}(L) - T_c) = C_t - (1/\\nu) \\ln L$\n此处，$C_m$、$C_\\chi$ 和 $C_t$ 是常数。这些方程中的每一个都具有线性形式 $y = c + s \\cdot x$，其中自变量是 $x = \\ln L$，因变量 $y$ 是相应观测量值的对数。这些直线的斜率与临界指数直接相关：$s_m = -\\beta/\\nu$，$s_\\chi = \\gamma/\\nu$，$s_t = -1/\\nu$。这些斜率可以通过普通最小二乘法（OLS）线性回归进行数值确定。\n\n对三个数据集中的每一个，计算过程如下执行：\na.  对于给定数据集中的每个晶格尺寸 $L_i$，为所有回归准备自变量 $x_i = \\ln(L_i)$。\nb.  计算回归的因变量：$y_{m,i} = \\ln(\\langle |m| \\rangle_i)$、$y_{\\chi,i} = \\ln(\\chi_i)$ 和 $y_{t,i} = \\ln(T_{\\max}(L)_i - T_c)$。在计算 $y_{t,i}$ 时，使用提供的临界温度值 $T_c = 2.269185314$。\nc.  进行三次独立的 OLS 回归以找到最佳拟合斜率：\n    -   $s_m$ 通过 $y_m$ 对 $x$ 的回归获得。\n    -   $s_\\chi$ 通过 $y_\\chi$ 对 $x$ 的回归获得。\n    -   $s_t$ 通过 $y_t$ 对 $x$ 的回归获得。\nd.  然后根据这些估计的斜率，使用指定关系式计算临界指数：\n    -   $\\nu = -1 / s_t$\n    -   $\\beta = -s_m \\cdot \\nu$\n    -   $\\gamma = s_\\chi \\cdot \\nu$\ne.  最后，按要求将计算出的 $\\beta$、$\\gamma$ 和 $\\nu$ 值四舍五入到三位小数。整个过程在随附的程序中系统地实现。二维伊辛模型的已知精确值为 $\\beta = 1/8=0.125$，$\\gamma = 7/4=1.75$ 和 $\\nu=1$。从所提供的数据（包括噪声和标度修正）中得到的结果，预计将是这些理论值的近似值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Estimates the critical exponents beta, gamma, and nu for the 2D Ising model\n    using finite-size scaling analysis on three provided datasets.\n    \"\"\"\n    \n    # Define the critical temperature T_c as given in the problem statement.\n    T_c = 2.269185314\n\n    # The three datasets provided in the problem statement.\n    datasets = [\n        # Dataset A\n        {\n            \"L\": np.array([8, 12, 16, 24, 32, 48, 64]),\n            \"m_abs\": np.array([0.806300, 0.742300, 0.706000, 0.660900, 0.631600, 0.595200, 0.572000]),\n            \"chi\": np.array([32.300, 64.360, 105.430, 212.330, 350.690, 707.700, 1167.590]),\n            \"T_max\": np.array([2.387310314, 2.346685314, 2.326841314, 2.307310314, 2.297661914, 2.288091314, 2.283335714])\n        },\n        # Dataset B\n        {\n            \"L\": np.array([10, 14, 20, 28, 40, 56, 80]),\n            \"m_abs\": np.array([0.937100, 0.864300, 0.801600, 0.750100, 0.703600, 0.665300, 0.627800]),\n            \"chi\": np.array([45.840, 84.620, 160.970, 293.370, 555.000, 1003.200, 1891.000]),\n            \"T_max\": np.array([2.384415314, 2.350605314, 2.325688314, 2.309288314, 2.297116314, 2.289062314, 2.283059314])\n        },\n        # Dataset C\n        {\n            \"L\": np.array([6, 8, 10, 12, 14]),\n            \"m_abs\": np.array([0.904500, 0.828700, 0.778300, 0.743600, 0.716900]),\n            \"chi\": np.array([18.790, 29.925, 43.343, 58.709, 76.010]),\n            \"T_max\": np.array([2.420296314, 2.379185314, 2.355585314, 2.340296314, 2.329838314])\n        }\n    ]\n\n    all_results = []\n\n    for data in datasets:\n        # Prepare the variables for linear regression by taking natural logarithms.\n        log_L = np.log(data[\"L\"])\n        \n        # 1. Magnetization fit: log(<|m|>) = C_m - (beta/nu) * log(L)\n        log_m = np.log(data[\"m_abs\"])\n        # Perform OLS regression to find the slope s_m = -beta/nu\n        s_m = stats.linregress(log_L, log_m).slope\n        \n        # 2. Susceptibility fit: log(chi) = C_chi + (gamma/nu) * log(L)\n        log_chi = np.log(data[\"chi\"])\n        # Perform OLS regression to find the slope s_chi = gamma/nu\n        s_chi = stats.linregress(log_L, log_chi).slope\n        \n        # 3. T_max shift fit: log(T_max(L) - T_c) = C_t - (1/nu) * log(L)\n        log_T_shift = np.log(data[\"T_max\"] - T_c)\n        # Perform OLS regression to find the slope s_t = -1/nu\n        s_t = stats.linregress(log_L, log_T_shift).slope\n        \n        # Calculate the critical exponents from the slopes.\n        nu = -1.0 / s_t\n        beta = -s_m * nu\n        gamma = s_chi * nu\n        \n        # Round the results to three decimal places.\n        beta_rounded = round(beta, 3)\n        gamma_rounded = round(gamma, 3)\n        nu_rounded = round(nu, 3)\n        \n        # Store the list of exponents for the current dataset.\n        all_results.append([beta_rounded, gamma_rounded, nu_rounded])\n        \n    # Format the final output according to the problem specification.\n    # The string representation of a list of lists is converted to a compact\n    # format by removing all space characters.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```", "id": "2448171"}]}