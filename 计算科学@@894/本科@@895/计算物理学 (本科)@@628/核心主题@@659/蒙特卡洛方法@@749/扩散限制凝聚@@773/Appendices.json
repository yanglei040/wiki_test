{"hands_on_practices": [{"introduction": "我们已经知道，标准的DLA模型能生成具有特定分形维度的结构。但这个分形维度是否依赖于我们选择的微观网格（例如方形晶格）呢？本练习将通过在方形和六边形两种不同晶格上模拟DLA，来引导你探索物理学中的“普适性”概念。通过亲手计算并比较两种情况下的分形维度 $D_f$，你将深入理解为何不同的微观规则有时会产生相同的宏观行为。[@problem_id:2386014]", "problem": "编写一个完整、可运行的程序，该程序为两种二维晶格模拟扩散限制聚集（DLA），并通过回旋半径的标度关系估算分形维度。目标是在方形晶格和六边形晶格上对聚集过程进行建模，并比较两者之间经验估算出的分形维度 $D_f$。程序必须通过使用固定的随机数种子来确定性地运行，并且必须按照下面指定的精确格式输出单行结果。\n\n使用的基本原理和定义：\n- 扩散限制聚集（DLA）是一个生长过程，其中粒子进行无偏的最近邻随机游走（一种与扩散方程 $\\partial_t \\rho = D \\nabla^2 \\rho$ 一致的布朗运动的离散模型），直到它们在首次接触团簇边界（与任何已占据位点相邻）时粘附上去。\n- 晶格上的一个随机游走步骤会从其最近邻集合中均匀选择一个。对于方形晶格，每个位点有 $4$ 个邻居；对于六边形晶格，每个位点有 $6$ 个邻居。\n- 对于位于位置 $\\{\\mathbf{r}_i\\}_{i=1}^N$ 的 $N$ 个点集，其回旋半径 $R_g$ 定义为\n$$\nR_g^2 = \\frac{1}{N}\\sum_{i=1}^N \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2,\n\\quad \\text{其中} \\quad\n\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i.\n$$\n对于一个统计上自相似的聚集体（分形），标度关系 $R_g \\propto N^{1/D_f}$ 成立，因此对 $\\log R_g$ 与 $\\log N$ 进行双对数线性回归会得到一个斜率 $s$，其中 $D_f = 1/s$。\n- 距离和角度必须在数学上一致的嵌入方式中处理。对于方形晶格，使用笛卡尔嵌入 $\\mathbf{r}=(x,y)$，其中 $x$ 和 $y$ 是整数。对于六边形晶格，使用轴坐标系 $(q,r)$，其最近邻方向为 $(1,0)$、$(-1,0)$、$(0,1)$、$(0,-1)$、$(1,-1)$、$(-1,1)$，并通过以下方式嵌入到平面中\n$$\nx = q + \\frac{1}{2} r,\\qquad y = \\frac{\\sqrt{3}}{2} r,\n$$\n这样，离原点的欧几里得距离平方为\n$$\nx^2 + y^2 = q^2 + q r + r^2.\n$$\n\n模拟规则和数值细节：\n- 在 $N=1$ 时，以原点处的一个已占据位点初始化聚集体。\n- 在半径为 $R_{\\text{launch}} = \\sqrt{R_{\\max}^2} + \\Delta_{\\text{launch}}$ 的圆上以随机方向发射每个扩散粒子，其中 $R_{\\max}^2$ 是当前任何已占据位点离原点的最大欧几里得距离平方，$\\Delta_{\\text{launch}}$ 是一个正边距。使用 $[0,2\\pi)$ 范围内的均匀随机角度（以弧度为单位）来放置发射点，然后四舍五入到最近的晶格位点（对于六边形晶格，在与嵌入方式一致的轴坐标系中进行舍入；对于方形晶格，对笛卡尔坐标进行舍入）。角度必须以弧度为单位处理。\n- 执行无偏的最近邻随机游走，直到出现以下情况之一：\n  1. 游走者移动到一个位点，该位点的邻居集合中包含任何当前已占据的位点。在这种情况下，游走者在其当前位点不可逆地粘附，并成为聚集体的一部分。\n  2. 游走者游走到“杀灭”半径 $R_{\\text{kill}} = R_{\\text{launch}} + \\Delta_{\\text{kill}}$ 之外，在这种情况下，该游走者被丢弃，并发射一个新的游走者。\n- 在每次使 $N$ 增加到 $N+1$ 的粘附事件后，使用上述精确定义，在所选的嵌入方式中更新回旋半径 $R_g(N+1)$。\n- 通过对 $\\log R_g(N)$ 与 $\\log N$ 进行最小二乘线性回归来估算分形维度 $D_f$，回归范围要避开非常小的 $N$ 以减小有限尺寸效应。具体来说，当 $N_{\\text{final}} \\ge 100$ 时，在 $N \\ge N_{\\min}$（其中 $N_{\\min} = \\max(50, \\lfloor 0.2 N_{\\text{final}} \\rfloor)$）的范围内进行拟合；否则，$N_{\\min} = 10$。使用自然对数。\n\n您的程序必须实现两种晶格类型，并为每个测试用例计算 $D_f$。必须为每个测试用例设定随机数生成器的种子，以保证确定性行为。\n\n要求的测试套件（每个元组为 $(\\text{晶格}, N_{\\text{final}}, \\text{种子}, \\Delta_{\\text{launch}}, \\Delta_{\\text{kill}})$）：\n- Case A: $(\\text{\"square\"},\\, 220,\\, 2023,\\, 5,\\, 15)$\n- Case B: $(\\text{\"hex\"},\\, 220,\\, 2023,\\, 5,\\, 15)$\n- Case C: $(\\text{\"square\"},\\, 60,\\, 777,\\, 5,\\, 15)$\n- Case D: $(\\text{\"hex\"},\\, 60,\\, 777,\\, 5,\\, 15)$\n\n所有距离都是无量纲的晶格间距；角度必须以弧度为单位。输出是无单位的实数（浮点数）。对于每个测试用例，程序必须输出估算出的 $D_f$，并四舍五入到三位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个逗号分隔的列表，用方括号括起来，顺序为 $[\\text{Case A}, \\text{Case B}, \\text{Case C}, \\text{Case D}]$。例如：[$1.700,1.690,1.660,1.650$]。", "solution": "我们通过显式的最近邻随机游走来模拟扩散限制聚集（DLA），该方法基于两个基本要素。首先，晶格上的无偏最近邻随机游走为布朗运动提供了离散表示，与扩散方程 $\\partial_t \\rho = D \\nabla^2 \\rho$ 一致。其次，聚集体的分形维度 $D_f$ 是通过质量-半径标度关系来定义的。我们避免使用任何特定于晶格的简化公式，而是从定义中推导出测量过程。\n\n原理与推导：\n1. 随机游走动力学与聚集。设 $\\mathcal{S}$ 表示已占据位点的集合，初始时 $\\mathcal{S}=\\{(0,0)\\}$。游走者在欧几里得半径 $R_{\\text{launch}} = \\sqrt{R_{\\max}^2} + \\Delta_{\\text{launch}}$ 处发射，其中 $R_{\\max}^2=\\max_{\\mathbf{r}\\in\\mathcal{S}} \\|\\mathbf{r}\\|^2$。发射方向在 $[0,2\\pi)$（弧度）内均匀采样，以保持各向同性。对于方形晶格，位置被四舍五入为整数笛卡尔坐标 $(x,y)\\in\\mathbb{Z}^2$；对于六边形晶格，我们使用轴坐标 $(q,r)\\in\\mathbb{Z}^2$，其最近邻为 $(1,0)$、$(-1,0)$、$(0,1)$、$(0,-1)$、$(1,-1)$、$(-1,1)$。游走过程是每一步从最近邻中均匀随机选择一个。如果游走者的当前位点有任何邻居在 $\\mathcal{S}$ 中，它就会粘附，该位点被添加到 $\\mathcal{S}$ 中。如果它游走到 $R_{\\text{kill}}=R_{\\text{launch}}+\\Delta_{\\text{kill}}$ 之外，它将被丢弃，并发射一个新的游走者。这些规则实现了受限于到聚集体边界的扩散通量的生长过程。\n\n2. 嵌入与距离度量。对于方形晶格，我们使用 $\\mathbf{r}=(x,y)$，其欧几里得距离平方为 $\\|\\mathbf{r}\\|^2=x^2+y^2$。对于六边形晶格，我们将轴坐标 $(q,r)$ 嵌入为\n$$\nx = q + \\frac{1}{2} r,\\qquad y = \\frac{\\sqrt{3}}{2} r,\n$$\n这会得到恒等式\n$$\nx^2 + y^2 = q^2 + q r + r^2.\n$$\n该恒等式允许在随机游走过程中，直接从整数轴坐标精确计算欧几里得距离平方，而没有浮点数歧义。我们通过将笛卡尔坐标 $(x,y)$ 转换为分数轴坐标 $(q_f,r_f)$（通过 $q_f = x - y/\\sqrt{3}$ 和 $r_f = 2y/\\sqrt{3}$），然后应用带有约束条件 $x_c + y_c + z_c = 0$ 的标准立方体坐标舍入法，得到整数轴坐标 $(q,r)$，从而将发射点四舍五入到最近的六边形位点。\n\n3. 通过回旋半径计算分形维度。对于位于 $\\{\\mathbf{r}_i\\}$ 的 $N$ 个已占据位点，其回旋半径为\n$$\nR_g^2(N) = \\frac{1}{N}\\sum_{i=1}^N \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2\n= \\frac{1}{N}\\sum_{i=1}^N |\\mathbf{r}_i|^2 - \\left|\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i\\right|^2,\n$$\n这个公式是精确且计算方便的。对于自相似聚集体，质量-半径标度关系 $N \\propto R^{{D_f}}$ 意味着 $R \\propto N^{1/D_f}$，因此\n$$\n\\log R_g(N) = \\frac{1}{D_f}\\log N + \\text{常量}.\n$$\n因此，在避免小 $N$ 瞬态效应的范围内，对 $\\log R_g$ 与 $\\log N$ 进行最小二乘拟合，会得到一个斜率 $s$ 和估算值 $D_f = 1/s$。为了减少有限尺寸和晶格人为效应，我们在 $N \\ge N_{\\min}$ 的范围内进行拟合，当 $N_{\\text{final}} \\ge 100$ 时 $N_{\\min}=\\max(50,\\lfloor 0.2 N_{\\text{final}}\\rfloor)$，否则 $N_{\\min}=10$。\n\n算法设计：\n- 数据结构：将已占据集合 $\\mathcal{S}$ 维护为一个晶格坐标的哈希集合，以实现期望时间复杂度为 $O(1)$ 的成员资格测试。保持动态和 $\\sum \\mathbf{r}_i$ 和 $\\sum |\\mathbf{r}_i|^2$，以便在每次粘附事件中以 $O(1)$ 的时间更新 $R_g$。跟踪 $R_{\\max}^2$ 作为已占据位点中离原点的最大欧几里得距离平方，用于更新发射半径。\n- 六边形晶格的实现细节：在随机游走过程中，使用轴坐标邻居和精确公式 $q^2 + q r + r^2$ 计算欧几里得距离平方，以进行杀灭半径检查。仅在粘附事件发生时，使用 $x=q+\\frac{1}{2}r$，$y=\\frac{\\sqrt{3}}{2}r$ 将坐标转换为笛卡尔坐标 $(x,y)$ 以更新 $R_g$。\n- 确定性：为每个测试用例使用一个固定种子和独立的随机数生成器，以保证可复现性。角度在 $[0,2\\pi)$ 范围内以弧度为单位均匀采样。\n- 计算保障措施：为每个发射的游走者设定一个宽松的随机游走最大步数，以保证终止；如果超过该限制，则丢弃并重新发射，以避免病态轨迹。当该限制设置得较高时，这不会显著地使结果产生偏差。\n\n测试套件与输出：\n我们运行四个测试用例，元组为 $(\\text{晶格}, N_{\\text{final}}, \\text{种子}, \\Delta_{\\text{launch}}, \\Delta_{\\text{kill}})$：\n- Case A: $(\\text{\"square\"}, 220, 2023, 5, 15)$。\n- Case B: $(\\text{\"hex\"}, 220, 2023, 5, 15)$。\n- Case C: $(\\text{\"square\"}, 60, 777, 5, 15)$。\n- Case D: $(\\text{\"hex\"}, 60, 777, 5, 15)$。\n对于每种情况，我们都按照指定的方式通过对 $\\log R_g$ 与 $\\log N$ 进行线性回归来计算 $D_f$，并将结果四舍五入到三位小数。程序以 [$D_A, D_B, D_C, D_D$] 的格式打印单行结果。二维 DLA 的典型值接近 $D_f \\approx 1.7$；由于配位数和晶格各向异性的不同，两种晶格可能会产生略有不同的估算值，但在这些尺寸下，两者应处于同一范围。\n\n整个实现遵循所要求的环境，仅使用允许的库，并生成指定的单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# ---------------------------\n# DLA simulation on square and hex lattices with R_g scaling\n# ---------------------------\n\n# Neighbor steps for square and hex lattices\nSQUARE_NEIGHBORS = ((1, 0), (-1, 0), (0, 1), (0, -1))\nHEX_NEIGHBORS = ((1, 0), (-1, 0), (0, 1), (0, -1), (1, -1), (-1, 1))\n\nSQRT3 = np.sqrt(3.0)\nSQRT3_OVER_2 = SQRT3 / 2.0\n\ndef axial_to_cartesian(q: int, r: int) -> tuple[float, float]:\n    \"\"\"\n    Map axial hex coordinates (q, r) to Cartesian coordinates (x, y).\n    x = q + r/2\n    y = (sqrt(3)/2) * r\n    \"\"\"\n    x = q + 0.5 * r\n    y = SQRT3_OVER_2 * r\n    return x, y\n\ndef hex_distance_sq_axial(q: int, r: int) -> int:\n    \"\"\"\n    Exact Euclidean squared distance in the hex embedding:\n    x^2 + y^2 = q^2 + q*r + r^2\n    \"\"\"\n    return q*q + q*r + r*r\n\ndef cartesian_to_axial_round(x: float, y: float) -> tuple[int, int]:\n    \"\"\"\n    Convert Cartesian (x, y) in the hex embedding to the nearest axial integer (q, r)\n    using cube-coordinate rounding. Inverse of axial_to_cartesian.\n    From axial to cart: x = q + r/2, y = (sqrt(3)/2) r.\n    Inverse (fractional axial): q_f = x - y/sqrt(3), r_f = 2y/sqrt(3).\n    \"\"\"\n    qf = x - y / SQRT3\n    rf = 2.0 * y / SQRT3\n    # Convert to cube coords (x_c, y_c, z_c) with x_c + y_c + z_c = 0\n    xf = qf\n    zf = rf\n    yf = -xf - zf\n    rx = round(xf)\n    ry = round(yf)\n    rz = round(zf)\n    dx = abs(rx - xf)\n    dy = abs(ry - yf)\n    dz = abs(rz - zf)\n    if dx > dy and dx > dz:\n        rx = -ry - rz\n    elif dy > dz:\n        ry = -rx - rz\n    else:\n        rz = -rx - ry\n    q = int(rx)\n    r = int(rz)\n    return q, r\n\ndef simulate_dla(lattice: str, N_final: int, seed: int, launch_margin: float, kill_margin: float) -> float:\n    \"\"\"\n    Simulate DLA on the specified lattice ('square' or 'hex') until N_final occupied sites (including the seed),\n    return the estimated fractal dimension D_f by fitting log(R_g) vs log(N) with N >= N_min (see problem statement).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    if lattice == \"square\":\n        neighbors = SQUARE_NEIGHBORS\n        # Distance from origin squared\n        dist2 = lambda pos: pos[0]*pos[0] + pos[1]*pos[1]\n        # Map lattice coord to cartesian\n        to_cart = lambda pos: (float(pos[0]), float(pos[1]))\n        # Round launch on circle to nearest lattice site\n        def launch_from_radius(R_launch: float) -> tuple[int, int]:\n            theta = rng.uniform(0.0, 2.0*np.pi)\n            x = R_launch * np.cos(theta)\n            y = R_launch * np.sin(theta)\n            return int(round(x)), int(round(y))\n    elif lattice == \"hex\":\n        neighbors = HEX_NEIGHBORS\n        dist2 = lambda pos: hex_distance_sq_axial(pos[0], pos[1])\n        to_cart = lambda pos: axial_to_cartesian(pos[0], pos[1])\n        def launch_from_radius(R_launch: float) -> tuple[int, int]:\n            theta = rng.uniform(0.0, 2.0*np.pi)\n            x = R_launch * np.cos(theta)\n            y = R_launch * np.sin(theta)\n            return cartesian_to_axial_round(x, y)\n    else:\n        raise ValueError(\"Unknown lattice type\")\n\n    occupied = set()\n    origin = (0, 0)\n    occupied.add(origin)\n\n    # Running sums for R_g computation\n    sum_x = 0.0\n    sum_y = 0.0\n    sum_sq = 0.0\n    # R_g at N=1 is zero\n    Rg_by_N = [(1, 0.0)]\n\n    # Track maximum squared radius\n    Rmax2 = 0.0  # includes the origin which is 0\n\n    # Simulation parameters\n    max_steps_per_walker = 10000  # safety limit to avoid very long walks\n\n    # Main aggregation loop\n    while len(occupied) < N_final:\n        # Set launch and kill radii\n        R_launch = np.sqrt(Rmax2) + float(launch_margin)\n        R_kill = R_launch + float(kill_margin)\n        R_kill2 = R_kill * R_kill\n\n        # Launch a new walker\n        pos = launch_from_radius(R_launch)\n\n        steps = 0\n        while True:\n            steps += 1\n            if steps > max_steps_per_walker:\n                # Discard and relaunch\n                break\n\n            # Propose a random nearest-neighbor step\n            # Choose index more cheaply than rng.choice on small tuple\n            di = int(rng.integers(0, len(neighbors)))\n            dx, dy = neighbors[di]\n            new_pos = (pos[0] + dx, pos[1] + dy)\n\n            # Do not move into already occupied site (reflect by rejecting step)\n            if new_pos in occupied:\n                continue\n\n            pos = new_pos\n\n            # Kill if beyond kill radius\n            if dist2(pos) > R_kill2:\n                break\n\n            # Stick if adjacent to occupied site\n            hit = False\n            # Test adjacency\n            for ndx, ndy in neighbors:\n                nb = (pos[0] + ndx, pos[1] + ndy)\n                if nb in occupied:\n                    hit = True\n                    break\n            if hit:\n                # Stick the walker\n                occupied.add(pos)\n                # Update R_g running sums using Cartesian embedding\n                x, y = to_cart(pos)\n                sum_x += x\n                sum_y += y\n                sum_sq += x*x + y*y\n                N_now = len(occupied)\n                # Update Rmax2\n                d2 = x*x + y*y\n                if d2 > Rmax2:\n                    Rmax2 = d2\n                # Compute R_g from definition: R_g^2 = (sum |r|^2)/N - |sum r|^2 / N^2\n                cm2 = (sum_x*sum_x + sum_y*sum_y) / (N_now * N_now)\n                Rg2 = (sum_sq / N_now) - cm2\n                if Rg2 < 0.0:\n                    Rg2 = 0.0\n                Rg = float(np.sqrt(Rg2))\n                Rg_by_N.append((N_now, Rg))\n                break  # proceed to next walker\n\n    # Prepare data for fitting log(R_g) vs log(N)\n    Ns = np.array([n for n, _ in Rg_by_N], dtype=float)\n    Rgs = np.array([rg for _, rg in Rg_by_N], dtype=float)\n\n    # Select fitting range\n    if N_final >= 100:\n        N_min = max(50, int(np.floor(0.2 * N_final)))\n    else:\n        N_min = 10\n    mask = Ns >= N_min\n    # Ensure we have sufficient points; if not, relax to use all N >= 2\n    if not np.any(mask):\n        mask = Ns >= 2.0\n\n    # Avoid log of zero; filter R_g > 0 as well\n    mask = mask & (Rgs > 0.0)\n\n    # In degenerate cases with too few points, fall back to pseudo-estimate to avoid crash\n    if np.count_nonzero(mask) < 2:\n        # Minimal fallback: return NaN-like but still numeric; choose 0.0 as indicator\n        return float(\"nan\")\n\n    logN = np.log(Ns[mask])\n    logRg = np.log(Rgs[mask])\n\n    # Linear regression: logRg = m * logN + b\n    m, b = np.polyfit(logN, logRg, 1)\n    if m == 0.0:\n        return float(\"nan\")\n    D_est = 1.0 / m\n    return float(D_est)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (lattice, N_final, seed, launch_margin, kill_margin)\n    test_cases = [\n        (\"square\", 220, 2023, 5, 15),  # Case A\n        (\"hex\",    220, 2023, 5, 15),  # Case B\n        (\"square\",  60,  777, 5, 15),  # Case C\n        (\"hex\",     60,  777, 5, 15),  # Case D\n    ]\n\n    results = []\n    for lattice, N_final, seed, lmargin, kmargin in test_cases:\n        D_est = simulate_dla(lattice, N_final, seed, lmargin, kmargin)\n        # Round to three decimal places as required\n        if np.isnan(D_est):\n            # In the unlikely event of NaN, output 0.000 to maintain format\n            results.append(\"0.000\")\n        else:\n            results.append(f\"{D_est:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386014"}, {"introduction": "标准的DLA模型假定任何接触到团簇的粒子都会立即附着，但这往往会产生非常稀疏和“多刺”的脆弱分枝。本练习引入了一种“噪声抑制”机制：一个位点必须被随机游走的粒子访问多次后，才能真正实现附着。通过调整这个附着所需的“访问次数”阈值 $m$，你将研究附着效率如何影响团簇的最终形态及其分形维度，并探索从经典DLA分形到更紧凑生长模式之间的过渡。[@problem_id:2386048]", "problem": "考虑在整数格点上的二维扩散限制聚集 (DLA) 模型，其中在时间 $t=0$ 时，一个单个不动的种子占据原点。粒子从一个发射圆上被逐一释放，并在离散时间内进行无偏的最近邻随机游走。模型施加了一条降噪规则：粒子在首次降落到聚集体旁边时不会立即粘附。取而代之的是，每个空格点都维护一个整数计数器，记录当该位置至少有一个最近邻已被占据时，随机游走粒子降落到此处的次数。仅当一个位置的计数器达到预设的正整数阈值 $m$ 时，该位置才会被永久占据。目标是为不同的 $m$ 值生成聚集体，并通过质量-半径标度关系来估计其分形维度 $D_f(m)$。\n\n模型说明：\n- 格点：整数对集合 $(x,y)\\in\\mathbb{Z}^2$。\n- 种子：在时间 $t=0$ 时，已占据位置的集合为 $\\{(0,0)\\}$。\n- 随机游走动力学：位于 $(x,y)$ 的游走粒子在一个离散步长内，以相等的概率 $1/4$ 移动到 $(x\\pm 1,y)$ 或 $(x,y\\pm 1)$。\n- 发射规则：令 $R(t)$ 表示当前聚集体的半径，定义为所有已占据位置上的最大欧几里得距离 $\\sqrt{x^2+y^2}$。定义边距 $r_{\\mathrm{margin}}=5$ 和最小发射半径 $r_{\\min}=10$。每个新的游走粒子从半径为 $r_{\\mathrm{launch}}=\\max\\{R(t)+r_{\\mathrm{margin}},\\,r_{\\min}\\}$ 的圆上以一个均匀随机的角度（单位：弧度）发射，并置于离该圆上对应点最近的格点位置。角度必须在 $[0,2\\pi)$ 范围内均匀采样。\n- 终止规则：定义终止半径 $r_{\\mathrm{kill}}=r_{\\mathrm{launch}}+3\\,r_{\\mathrm{margin}}$。如果一个游走粒子与原点的欧几里得距离超过了 $r_{\\mathrm{kill}}$，则该粒子被丢弃，并按上述规则发射一个新的粒子。\n- 排斥规则：任何试图将游走粒子移动到已占据位置的提议步长都将被拒绝并立即重新采样；等效地，在该时间步中，粒子停留在其当前格点，并在下一步重新抽取一个方向。\n- 降落事件与降噪：当一个游走粒子位于一个空格点 $(x,y)$，且其四个最近邻中至少有一个已被占据时，发生一次降落事件。每个空格点 $(x,y)$ 维护一个从 $0$ 开始的整数计数器 $c(x,y)$，在每次于 $(x,y)$ 发生降落事件时加 $1$。当 $c(x,y)$ 首次达到阈值 $m$ 时，位置 $(x,y)$ 变为永久占据，该位置不再需要计数器 $c(x,y)$，当前游走粒子被移除。聚集体半径 $R(t)$ 也随之更新。\n- 模拟终止条件：持续发射游走粒子并应用上述规则，直到已占据位置集合的元素数量恰好为 $N$。\n\n分形维度估计：\n- 对于一个大小为 $|\\mathcal{C}|=N$ 的已完成聚集体（其占据位置集合为 $\\mathcal{C}$），定义聚集体半径 $R_{\\max}=\\max\\{\\sqrt{x^2+y^2}:(x,y)\\in\\mathcal{C}\\}$ 和质量函数 $M(R)=|\\{(x,y)\\in\\mathcal{C}:\\sqrt{x^2+y^2}\\le R\\}|$。\n- 定义拟合窗口参数 $\\alpha=0.2$ 和 $\\beta=0.9$。令 $R_{\\min}=\\lceil\\alpha R_{\\max}\\rceil$ 和 $R_{\\mathrm{fit}}=\\lfloor\\beta R_{\\max}\\rfloor$。考虑整数半径集合 $\\{R_i\\}_{i=1}^K=\\{R\\in\\mathbb{Z}: R_{\\min}\\le R\\le R_{\\mathrm{fit}},\\,R\\ge 1\\}$，按升序排列，其中 $K$ 是此类半径的数量。对每个 $R_i$，计算 $M(R_i)$。将 $D_f$ 估计为对数据点集 $\\{(\\log R_i,\\log M(R_i))\\}_{i=1}^K$ 进行最小二乘法线性拟合得到的直线的斜率。\n- 所有对数均为自然对数。\n\n测试套件与所需输出：\n- 使用以下测试用例，每个用例由元组 $(m,N,\\text{seed})$ 指定，其中“seed”用于初始化随机数生成器以确保结果的可复现性：\n  1. $(m=1,\\,N=900,\\,\\text{seed}=1337)$\n  2. $(m=3,\\,N=700,\\,\\text{seed}=2021)$\n  3. $(m=5,\\,N=600,\\,\\text{seed}=31415)$\n- 对每个用例，根据模型模拟聚集体，按上述方法估计 $D_f$，并将结果四舍五入保留三位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含三个四舍五入后的 $D_f$ 估计值，形式为用方括号括起来的逗号分隔列表（例如，$[1.700,1.750,1.780]$）。不应打印任何额外的文本或行。角度必须使用弧度。所有量均为无量纲量，无需进行物理单位换算。", "solution": "**算法方法**\n\n模拟将在 $\\mathbb{Z}^2$ 格点的稀疏表示上进行，这是必要的，因为格点是无界的。采用以下数据结构：\n1.  **已占据位置 (Occupied Sites)**：一个坐标元组的集合，`occupied_sites`，用于存储构成聚集体的粒子的位置。`set` 数据结构为成员资格测试提供了高效的 $O(1)$ 平均时间复杂度，这对于排斥规则至关重要。\n2.  **周边位置 (Perimeter Sites)**：一个集合，`perimeter_sites`，用于存储所有与聚集体中至少一个位置是最近邻的空格点的坐标。这优化了对“降落事件”的检查，根据定义，降落事件只能发生在这些位置上。\n3.  **降落计数器 (Landing Counters)**：一个字典，`landing_counters`，用于将周边位置的坐标映射到一个整数计数值。它跟踪随机游走粒子访问每个特定周边位置的次数，从而实现降噪机制。\n\n模拟通过逐一添加粒子的方式进行，直到聚集体达到目标大小 $N$。对于每个粒子，执行以下步骤：\n\n1.  **粒子发射**：一个新的游走粒子被引入系统。\n    -   确定当前聚集体半径 $R(t) = \\max\\{\\sqrt{x^2+y^2} \\mid (x,y) \\in \\text{occupied\\_sites}\\}$。为优化计算，我们维护最大半径的平方值，并仅在发生聚集时更新它。\n    -   计算发射半径 $r_{\\mathrm{launch}} = \\max\\{R(t) + r_{\\mathrm{margin}}, r_{\\min}\\}$，其中 $r_{\\mathrm{margin}} = 5$ 且 $r_{\\min} = 10$。\n    -   从 $[0, 2\\pi)$ 范围内均匀采样一个随机角度 $\\theta$。\n    -   将游走粒子放置在离发射圆上坐标点 $(r_{\\mathrm{launch}}\\cos\\theta, r_{\\mathrm{launch}}\\sin\\theta)$ 最近的整数格点 $(x, y)$ 上。这通过对浮点坐标进行四舍五入来实现。如果该位置已被占据（罕见事件），则重新采样角度，直到找到一个空的发射位置。\n    -   定义终止半径为 $r_{\\mathrm{kill}} = r_{\\mathrm{launch}} + 3 \\cdot r_{\\mathrm{margin}}$。\n\n2.  **随机游走**：游走粒子在格点上进行无偏随机游走。在每个离散时间步：\n    -   **终止条件**：检查游走粒子与原点的欧几里得距离。如果超过 $r_{\\mathrm{kill}}$，则丢弃该粒子，并继续发射新粒子。\n    -   **降落事件与粘附**：检查游走粒子的当前位置是否在 `perimeter_sites` 集合中。\n        -   如果是，则发生一次降落事件。`landing_counters` 中对应的计数器加一。\n        -   如果该位置的计数器达到阈值 $m$，则该位置成为聚集体的一部分。`occupied_sites` 和 `perimeter_sites` 集合将被更新，最大聚集体半径会重新计算，当前游走粒子被移除。然后发射一个新的游走粒子。\n    -   **移动**：以 $1/4$ 的等概率选择一个方向（上、下、左、右）。\n        -   计算一个提议的 `next_pos`。\n        -   **排斥规则**：如果 `next_pos` 位于 `occupied_sites` 中，则粒子在该时间步不移动。\n        -   否则，将粒子的位置更新为 `next_pos`。\n\n**分形维度估计**\n\n当聚集体生长到大小为 $N$ 后，根据质量-半径标度关系 $M(R) \\propto R^{D_f}$ 来估计其分形维度 $D_f$。该关系在对数-对数图上是线性的：$\\log M(R) = D_f \\log R + \\text{常量}$。\n\n1.  **数据收集**：\n    -   确定最终聚集体的最大半径 $R_{\\max}$。\n    -   通过 $R_{\\min-\\text{fit}} = \\lceil\\alpha R_{\\max}\\rceil$ 和 $R_{\\mathrm{fit}} = \\lfloor\\beta R_{\\max}\\rfloor$ 定义半径的拟合窗口，其中 $\\alpha = 0.2$ 且 $\\beta = 0.9$。\n    -   对于在 $[R_{\\min-\\text{fit}}, R_{\\mathrm{fit}}]$ 范围内的每个整数半径 $R$（且 $R \\ge 1$），计算其质量 $M(R)$。$M(R)$ 是指与原点距离不大于 $R$ 的已占据位置的数量。\n    -   针对此半径范围生成一组数据点 $(\\log R, \\log M(R))$。按规定使用自然对数。\n\n2.  **线性回归**：\n    -   对收集到的对数-对数数据点进行简单线性回归。\n    -   分形维度 $D_f$ 是最佳拟合直线的斜率。这可以使用标准的数值库计算，例如 `numpy.polyfit`，该函数可将指定次数的多项式拟合到数据并返回其系数。对于一条直线（1次），第一个系数就是斜率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_dla_and_get_df(m, N, seed):\n    \"\"\"\n    Simulates a noise-reduced DLA cluster and calculates its fractal dimension.\n\n    Args:\n        m (int): The noise reduction threshold.\n        N (int): The target number of particles in the cluster.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated fractal dimension D_f.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # --- Data Structures ---\n    # The set of occupied lattice sites\n    occupied_sites = {(0, 0)}\n    # The set of empty sites adjacent to the cluster\n    perimeter_sites = {(1, 0), (-1, 0), (0, 1), (0, -1)}\n    # Counters for the number of landings on perimeter sites\n    landing_counters = {}\n    \n    current_R_sq = 0.0\n\n    # --- Model Parameters ---\n    R_MARGIN = 5\n    R_MIN_LAUNCH = 10\n    MOVES = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]], dtype=np.int32)\n\n    # --- Main Simulation Loop ---\n    # Grow the cluster until it reaches size N\n    while len(occupied_sites) < N:\n        # --- 1. Set up for a new walker ---\n        current_R = np.sqrt(current_R_sq)\n        r_launch = max(current_R + R_MARGIN, R_MIN_LAUNCH)\n        r_kill_sq = (r_launch + 3 * R_MARGIN)**2\n\n        # Launch walker from a random position on the launch circle\n        while True:\n            angle = rng.uniform(0, 2 * np.pi)\n            x_c = r_launch * np.cos(angle)\n            y_c = r_launch * np.sin(angle)\n            walker_pos = (int(round(x_c)), int(round(y_c)))\n            if walker_pos not in occupied_sites:\n                break\n        \n        # --- 2. Random Walk Loop for the current walker ---\n        while True:\n            # Check kill condition\n            if walker_pos[0]**2 + walker_pos[1]**2 > r_kill_sq:\n                break  # Walker is killed, launch a new one\n\n            # Check for landing event (walker is on the cluster perimeter)\n            if walker_pos in perimeter_sites:\n                landing_counters[walker_pos] = landing_counters.get(walker_pos, 0) + 1\n                \n                # Check for sticking condition\n                if landing_counters[walker_pos] >= m:\n                    # Particle sticks!\n                    new_site = walker_pos\n                    occupied_sites.add(new_site)\n\n                    # Update cluster max radius\n                    current_R_sq = max(current_R_sq, new_site[0]**2 + new_site[1]**2)\n\n                    # Update perimeter and counters\n                    perimeter_sites.remove(new_site)\n                    if new_site in landing_counters:\n                        del landing_counters[new_site]\n\n                    for dx, dy in MOVES:\n                        neighbor = (new_site[0] + dx, new_site[1] + dy)\n                        if neighbor not in occupied_sites:\n                            perimeter_sites.add(neighbor)\n                    \n                    break # Walker has stuck, end its walk\n\n            # Perform one step of the random walk\n            move = MOVES[rng.integers(4)]\n            next_pos = (walker_pos[0] + move[0], walker_pos[1] + move[1])\n\n            # Exclusion rule: cannot move into an occupied site\n            if next_pos not in occupied_sites:\n                walker_pos = next_pos\n            # If next_pos is occupied, walker stays put for this time step\n\n    # --- 3. Fractal Dimension Estimation ---\n    ALPHA = 0.2\n    BETA = 0.9\n\n    R_max = np.sqrt(current_R_sq)\n    \n    R_min_fit = int(np.ceil(ALPHA * R_max))\n    R_fit = int(np.floor(BETA * R_max))\n\n    if R_min_fit > R_fit or R_fit < 1:\n        return np.nan # Not enough range for fitting\n\n    radii_for_fit = list(range(max(1, R_min_fit), R_fit + 1))\n    if not radii_for_fit:\n      return np.nan\n\n    log_R_values = []\n    log_M_values = []\n    \n    # Pre-calculate squared distances of all particles from origin\n    dist_sq_array = np.array([x**2 + y**2 for x, y in occupied_sites])\n    \n    for R_i in radii_for_fit:\n        R_i_sq = R_i**2\n        mass = np.sum(dist_sq_array <= R_i_sq)\n        if mass > 0:\n            log_R_values.append(np.log(R_i))\n            log_M_values.append(np.log(mass))\n\n    if len(log_R_values) < 2:\n        return np.nan # Not enough points for a linear regression\n\n    # Perform least-squares fit: log(M) = D_f * log(R) + C\n    # np.polyfit returns [slope, intercept]\n    slope, _ = np.polyfit(log_R_values, log_M_values, 1)\n    D_f = slope\n    \n    return D_f\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 900, 1337),\n        (3, 700, 2021),\n        (5, 600, 31415),\n    ]\n\n    results = []\n    for m, N, seed in test_cases:\n        df = simulate_dla_and_get_df(m, N, seed)\n        # Round result to three decimal places\n        results.append(f\"{df:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386048"}]}