{"hands_on_practices": [{"introduction": "在深入研究复杂的蒙特卡洛模拟之前，我们首先通过一个可以精确求解的小系统来建立坚实的基础。这个练习将引导你直接根据统计力学的基本原理——玻尔兹曼分布和配分函数——来计算一个小型“观点网络”的宏观性质。通过对所有可能的 $2^N$ 个状态进行精确枚举，你将亲身体会到为何这种直接方法对于大系统而言是不可行的，从而深刻理解为何我们需要像Metropolis算法这样的随机抽样方法。[@problem_id:2413243]", "problem": "考虑一个由有限无向图上的自旋表示的二元观点系统。每个个体是一个由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引的节点，其自旋为 $s_i \\in \\{-1,+1\\}$。设两个不同个体 $i$ 和 $j$ 之间的“友谊强度”为一个非负的对称权重 $w_{ij} = w_{ji} \\ge 0$，且 $w_{ii} = 0$，并假设当且仅当 $w_{ij} > 0$ 时，$i$ 和 $j$ 之间存在一条边。在温度为 $T > 0$、外加均匀场为 $h$ 的情况下，一个构型 $s = (s_0,\\dots,s_{N-1})$ 的相互作用能由伊辛哈密顿量给出\n$$\nH(s) \\;=\\; -\\sum_{0 \\le i < j \\le N-1} J_{ij} \\, s_i s_j \\;-\\; h \\sum_{i=0}^{N-1} s_i,\n$$\n其中耦合强度为 $J_{ij} = J_0 \\, w_{ij}$，$J_0 > 0$ 是一个均匀的耦合尺度。在玻尔兹曼常数 $k_B$ 等于 $1$ 的单位制下进行计算，因此构型 $s$ 的正则概率为\n$$\n\\mathbb{P}(s) \\;=\\; \\frac{1}{Z} \\exp\\!\\left(-\\frac{H(s)}{T}\\right), \\qquad Z \\;=\\; \\sum_{s \\in \\{-1,+1\\}^N} \\exp\\!\\left(-\\frac{H(s)}{T}\\right).\n$$\n\n对于下面指定的每个测试用例，计算以下平衡可观测量：\n- 每自旋的绝对磁化强度，\n$$\nm \\;=\\; \\frac{1}{N} \\, \\Big\\langle \\big| \\sum_{i=0}^{N-1} s_i \\big| \\Big\\rangle,\n$$\n- 每自旋的能量，\n$$\ne \\;=\\; \\frac{1}{N} \\, \\langle H(s) \\rangle,\n$$\n其中 $\\langle \\cdot \\rangle$ 表示在给定温度 $T$ 下相对于 $\\mathbb{P}(s)$ 的正则期望。在这些单位制下，所有量都是无量纲的。能量以 $J_0$ 为单位表示，温度以 $k_B = 1$ 的单位制表示。\n\n测试套件（每个用例由 $(N,\\{(i,j,w_{ij})\\},J_0,h,T)$ 完全指定）：\n- 用例 1：$N = 4$；加权边 $\\{(0,1,1.0),(1,2,1.0),(2,3,1.0)\\}$；$J_0 = 1.0$；$h = 0.0$；$T = 0.1$。\n- 用例 2：$N = 4$；加权边 $\\{(0,1,1.0),(1,2,1.0),(2,3,1.0)\\}$；$J_0 = 1.0$；$h = 0.0$；$T = 5.0$。\n- 用例 3：$N = 3$；加权边 $\\{(0,1,2.0),(1,2,0.5),(0,2,1.0)\\}$；$J_0 = 1.0$；$h = 0.0$；$T = 1.5$。\n- 用例 4：$N = 4$；加权边 $\\{(0,1,1.5),(2,3,1.5),(1,2,0.1)\\}$；$J_0 = 1.0$；$h = 0.2$；$T = 1.0$。\n\n最终输出格式要求：\n- 您的程序必须生成单行输出，其中包含四个用例的结果，结果为逗号分隔的列表并用方括号括起来。每个用例的结果本身必须是一个双元素列表 $[m,e]$，其中 $m$ 和 $e$ 都使用标准的四舍五入精确到 $6$ 位小数。输出中不得有任何空格。\n- 具体来说，输出必须具有以下形式\n$$\n[[m_1,e_1],[m_2,e_2],[m_3,e_3],[m_4,e_4]],\n$$\n其中每个 $m_k$ 和 $e_k$ 都是小数点后恰好有 $6$ 位数字的十进制数。\n\n不涉及角度或百分比；不要使用角度单位或百分号。在指定的单位制中，所有温度和能量都是无量纲的。问题完全由上述定义确定；仅使用所提供的参数。您的代码必须严格使用上述测试套件，并以要求的单行格式生成最终输出。", "solution": "问题陈述经过严格审查，被认定为有效。它在科学上基于统计力学的原理，对于其小系统规模而言是适定(well-posed)的，并且以客观、数学的精确性表达。它未违反任何导致无效的标准。该问题描述了有限、加权、无向图上的标准伊辛模型，并要求计算基本平衡可观测量：每自旋的绝对磁化强度和每自旋的能量。\n\n关键的观察点是，对于测试用例中给出的少量自旋 $N$（$N=3$ 和 $N=4$），系统构型的总数 $2^N$ 非常小（分别为 $2^3 = 8$ 和 $2^4 = 16$）。这允许通过枚举所有可能的状态来直接、精确地计算配分函数和热期望值。这种方法在计算上是可行的，并能得出精确结果，从而避免了使用诸如 Metropolis 蒙特卡洛模拟等随机方法，因为这些方法只能提供统计估计值。\n\n该解决方案基于统计力学中正则系综的原理。在给定温度 $T$ 下，系统处于具有能量 $H(s)$ 的特定构型 $s$ 的概率由玻尔兹曼分布给出：\n$$\n\\mathbb{P}(s) = \\frac{1}{Z} \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\n其中 $Z$ 是配分函数，它对概率分布进行归一化。它是所有可能构型的玻尔兹曼因子之和：\n$$\nZ = \\sum_{s \\in \\{-1,+1\\}^N} \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\n对于给定构型 $s = (s_0, \\dots, s_{N-1})$，哈密顿量 $H(s)$ 定义为：\n$$\nH(s) = -\\sum_{0 \\le i < j \\le N-1} J_{ij} s_i s_j - h \\sum_{i=0}^{N-1} s_i\n$$\n耦合强度 $J_{ij}$ 由问题指定的友谊权重 $w_{ij}$ 和均匀耦合尺度 $J_0$ 导出，即 $J_{ij} = J_0 w_{ij}$。\n\n任何可观测量 $A(s)$ 的热期望值通过对所有可能构型上的 $A(s)$ 进行加权平均计算得出，权重为其各自的概率：\n$$\n\\langle A \\rangle = \\sum_s A(s) \\mathbb{P}(s) = \\frac{1}{Z} \\sum_s A(s) \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\n需要计算的两个可观测量是：\n1.  每自旋的能量，$e = \\frac{1}{N} \\langle H \\rangle$。\n2.  每自旋的绝对磁化强度，$m = \\frac{1}{N} \\langle \\left| M \\right| \\rangle$，其中一个状态 $s$ 的总磁化强度为 $M(s) = \\sum_{i=0}^{N-1} s_i$。\n\n计算过程如下：\n首先，对于每个测试用例，我们构造对称的 $N \\times N$ 耦合矩阵 $J$，其中 $J_{ij} = J_0 w_{ij}$。\n其次，我们系统地生成所有 $2^N$ 个自旋构型 $s$。这是通过遍历从 $0$ 到 $2^N - 1$ 的整数，并使用它们的二进制表示来定义自旋状态（例如，比特 $0 \\mapsto +1$，比特 $1 \\mapsto -1$）来实现的。\n对于每个构型 $s$，我们计算其能量 $H(s)$ 和其总绝对磁化强度 $|M(s)|$。\n\n一个关键的数值考虑是玻尔兹曼因子 $\\exp(-H(s)/T)$ 的计算。当 $T$ 很小时，参数 $-H(s)/T$ 可能变得非常大且为正，导致数值溢出。为确保稳定性，我们在进行指数运算之前，从所有能量中减去系统的最小能量 $H_{\\text{min}} = \\min_s H(s)$。期望值的计算在此平移下是不变的：\n$$\n\\langle A \\rangle = \\frac{\\sum_s A(s) \\exp\\left(-\\frac{H(s) - H_{\\text{min}}}{T}\\right)}{\\sum_s \\exp\\left(-\\frac{H(s) - H_{\\text{min}}}{T}\\right)}\n$$\n这种重新表述保证了指数函数的所有参数都小于或等于零，从而防止溢出并保持数值精度。\n\n每个测试用例的算法实现如下：\n1.  将 $\\langle H \\rangle$ 的分子、$\\langle |M| \\rangle$ 的分子以及（平移后的）配分函数的和初始化为零。\n2.  遍历所有 $2^N$ 个状态。对于每个状态 $s$：\n    a.  计算 $H(s)$ 和 $|M(s)|$。\n    b.  计算平移后的玻尔兹曼因子 $W'(s) = \\exp(-(H(s) - H_{\\text{min}})/T)$。\n    c.  更新总和：将 $W'(s)$ 加到配分函数的和中，将 $H(s) \\cdot W'(s)$ 加到能量的和中，并将 $|M(s)| \\cdot W'(s)$ 加到磁化强度的和中。\n3.  遍历所有状态后，通过将累积的和除以平移后的玻尔兹曼因子的总和，来计算最终的期望值 $\\langle H \\rangle$ 和 $\\langle |M| \\rangle$。\n4.  最后，将这些期望值除以 $N$ 以获得每自旋的量 $e$ 和 $m$。然后按照问题陈述的要求对它们进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_observables(N, edges, J0, h, T):\n    \"\"\"\n    Calculates equilibrium observables for an Ising model on a graph by exact enumeration.\n    \n    Args:\n        N (int): Number of spins.\n        edges (list): List of tuples (i, j, w_ij) representing weighted edges.\n        J0 (float): Uniform coupling scale.\n        h (float): External uniform field.\n        T (float): Temperature (with k_B = 1).\n        \n    Returns:\n        tuple: A tuple (m, e) containing the absolute magnetization per spin\n               and the energy per spin.\n    \"\"\"\n    # 1. Construct the coupling matrix J\n    J_mat = np.zeros((N, N))\n    for i, j, w_ij in edges:\n        J_mat[i, j] = J0 * w_ij\n        J_mat[j, i] = J0 * w_ij\n\n    num_states = 1 << N\n    all_energies = np.zeros(num_states)\n    all_abs_mags = np.zeros(num_states)\n\n    # 2. Enumerate all 2^N states and calculate H and |M| for each\n    for i in range(num_states):\n        # Generate spin configuration s from the bits of integer i.\n        # bit 0 -> spin +1, bit 1 -> spin -1\n        s = np.array([1 if not ((i >> j) & 1) else -1 for j in range(N)])\n        \n        # Calculate Hamiltonian H(s) = -0.5 * s.T @ J_mat @ s - h * sum(s)\n        interaction_energy = -0.5 * np.dot(s, np.dot(J_mat, s))\n        field_energy = -h * np.sum(s)\n        H_s = interaction_energy + field_energy\n        \n        M_s = np.sum(s)\n        \n        all_energies[i] = H_s\n        all_abs_mags[i] = np.abs(M_s)\n        \n    # 3. Calculate expectation values using numerically stable method\n    if T <= 0:\n        # In the zero-temperature limit, the system occupies the ground state(s).\n        min_energy = np.min(all_energies)\n        ground_state_indices = np.where(all_energies == min_energy)[0]\n        \n        avg_H = min_energy\n        avg_abs_M = np.mean(all_abs_mags[ground_state_indices])\n    else:\n        # For T > 0, use Boltzmann statistics with a shift to avoid overflow.\n        min_energy = np.min(all_energies)\n        shifted_boltzmann_factors = np.exp(-(all_energies - min_energy) / T)\n        \n        Z_prime = np.sum(shifted_boltzmann_factors)\n        \n        avg_H = np.sum(all_energies * shifted_boltzmann_factors) / Z_prime\n        avg_abs_M = np.sum(all_abs_mags * shifted_boltzmann_factors) / Z_prime\n\n    # 4. Compute per-spin observables\n    e = avg_H / N\n    m = avg_abs_M / N\n\n    return m, e\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (N, edges, J0, h, T)\n        (4, [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)], 1.0, 0.0, 0.1),\n        # Case 2\n        (4, [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)], 1.0, 0.0, 5.0),\n        # Case 3\n        (3, [(0, 1, 2.0), (1, 2, 0.5), (0, 2, 1.0)], 1.0, 0.0, 1.5),\n        # Case 4\n        (4, [(0, 1, 1.5), (2, 3, 1.5), (1, 2, 0.1)], 1.0, 0.2, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, edges, J0, h, T = case\n        m, e = calculate_observables(N, edges, J0, h, T)\n        \n        # Format each [m, e] pair as a string with 6 decimal places and no spaces.\n        result_str = f\"[{m:.6f},{e:.6f}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413243"}, {"introduction": "既然我们已经认识到精确枚举的局限性，现在是时候学习并实践计算物理学中的主力算法——Metropolis算法了。这个核心练习将要求你从零开始为一个二维伊辛模型实现Metropolis模拟，你将探索不同边界条件（如周期性边界和开放边界）对系统磁化强度的细微而重要的影响。通过将你的模拟结果与已知的理论预测进行比较，你将掌握评估有限尺寸效应的关键技能，这是连接模拟与理论或真实世界的桥梁。[@problem_id:2413296]", "problem": "您的任务是设计并执行一个针对二维伊辛模型的Metropolis单自旋翻转模拟，以量化不同边界条件如何改变磁化强度的有限尺寸修正。您的实现必须是一个完整、可运行的程序。该模型包含位于线性尺寸为 $L$ 的方形晶格上的自旋 $s_i \\in \\{-1,+1\\}$，其哈密顿量为\n$$\nH(\\{s\\}) = - J \\sum_{\\langle i,j \\rangle} s_i s_j,\n$$\n其中 $J>0$，$ \\langle i,j \\rangle$ 表示由边界条件定义的最近邻对。使用 $J=1$ 和玻尔兹曼常数 $k_{\\mathrm{B}}=1$，因此温度 $T$ 是无量纲的。必须采用具有单自旋翻转提议的Metropolis算法，使用的接受概率为\n$$\nP_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right),\n$$\n其中 $\\Delta E$ 是提议的翻转所引起的能量变化，且 $\\beta = 1/T$。\n\n需要实现的边界条件：\n- 周期性边界条件 (PBC): 坐标为 $(x,y)$ 的格点的邻居是 $((x+1)\\!\\!\\mod L, y)$, $((x-1)\\!\\!\\mod L, y)$, $(x, (y+1)\\!\\!\\mod L)$, $(x, (y-1)\\!\\!\\mod L)$。\n- 开放边界条件 (OBC): 晶格外部的邻居不存在，对 $H$ 没有贡献。\n- 螺旋边界条件 (HBC): 将晶格展平为一维索引 $i = x + L y \\in \\{0,\\dots,L^2-1\\}$，并使用邻居 $\\{(i+1)\\!\\!\\mod N, (i-1)\\!\\!\\mod N, (i+L)\\!\\!\\mod N, (i-L)\\!\\!\\mod N\\}$，其中 $N=L^2$。为提高算法效率，您必须使用棋盘格（红黑）并行Metropolis更新；为严格保持在HBC下子晶格更新的独立性，请选择奇数 $L$。\n\n单位自旋磁化强度为\n$$\nm(\\{s\\}) = \\frac{1}{N}\\left|\\sum_{i=1}^N s_i\\right|, \\quad N=L^2.\n$$\n将在温度 $T$、尺寸为 $L$ 的晶格上、边界条件为 $\\mathcal{B}$ 下的有限尺寸修正定义为\n$$\n\\Delta m(L,\\mathcal{B},T) = m_{\\infty}(T) - \\langle m \\rangle_{L,\\mathcal{B},T},\n$$\n其中 $\\langle m \\rangle_{L,\\mathcal{B},T}$ 是 $m(\\{s\\})$ 在平衡态下的蒙特卡洛平均值，而 $m_{\\infty}(T)$ 是二维伊辛模型在 $T<T_{\\mathrm{c}}$ 时的精确无限晶格自发磁化强度，由经过充分检验的表达式给出\n$$\nm_{\\infty}(T) = \\left[1 - \\sinh^{-4}\\!\\left(\\frac{2}{T}\\right)\\right]^{1/8}, \\quad T<T_{\\mathrm{c}},\n$$\n并且对于 $T \\ge T_{\\mathrm{c}}$，$m_{\\infty}(T)=0$。临界温度为\n$$\nT_{\\mathrm{c}} = \\frac{2}{\\ln\\!\\left(1+\\sqrt{2}\\right)}.\n$$\n\n从玻尔兹曼分布和Metropolis转移规则出发。实现一个棋盘格（双子晶格）更新，该更新并行地翻转一个子晶格上的所有自旋，然后再更新另一个。使用热启动，初始自旋 $s_i \\in \\{-1,+1\\}$ 以相等概率随机取值。进行指定次数的完整扫描以使系统热化，然后在每次扫描后测量 $m$ 并对其进行平均以估算 $\\langle m \\rangle_{L,\\mathcal{B},T}$。使用固定的随机种子以保证可复现性。\n\n测试套件。为以下参数集运行您的程序，所有参数均在 $T=2.2$（满足 $T<T_{\\mathrm{c}}$）下，使用列出的热化扫描次数和测量扫描次数。所有晶格尺寸均为奇数，以确保螺旋边界条件与棋盘格更新的兼容性。每个测试用例都是独立的，并有自己固定的种子。\n- 案例 1：$(\\mathcal{B}=\\mathrm{PBC},\\, L=9,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231101)$。\n- 案例 2：$(\\mathcal{B}=\\mathrm{OBC},\\, L=9,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231102)$。\n- 案例 3：$(\\mathcal{B}=\\mathrm{HBC},\\, L=9,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231103)$。\n- 案例 4：$(\\mathcal{B}=\\mathrm{PBC},\\, L=13,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231104)$。\n- 案例 5：$(\\mathcal{B}=\\mathrm{OBC},\\, L=13,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231105)$。\n- 案例 6：$(\\mathcal{B}=\\mathrm{HBC},\\, L=13,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231106)$。\n\n您的输出必须是列表\n$$\n[\\Delta m_1,\\Delta m_2,\\Delta m_3,\\Delta m_4,\\Delta m_5,\\Delta m_6],\n$$\n其中 $\\Delta m_k$ 是为案例 $k$ 计算的有限尺寸修正，四舍五入到 $6$ 位小数。程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[0.123456,0.234567,0.345678,0.456789,0.567890,0.678901]$）。由于所有量都是无量纲的，因此不需要物理单位。未使用角度。\n\n您的解决方案必须源自玻尔兹曼权重、伊辛哈密顿量的定义以及Metropolis接受规则。请勿使用任何预先计算的模拟输出。您的程序必须是完全自包含的，并且不需要用户输入。本问题陈述中的所有数学符号和数字均以LaTeX格式书写。请在您的假设和数值选择中确保科学真实性和内部一致性。", "solution": "该问题陈述已经过严格验证，并被确定为有效。它具有科学依据，是良态的、客观的且内部一致的。它提出了一个计算统计力学中的标准问题，并明确指定了所有必要的参数、定义和约束。\n\n任务是执行二维伊辛模型的Metropolis蒙特卡洛模拟，以计算不同晶格尺寸和边界条件下自发磁化强度的有限尺寸修正 $\\Delta m$。解决方案源自统计力学和蒙特卡洛方法的基本原理。\n\n其基本原理是，在热平衡状态下，一个物理系统处于具有能量 $H(\\{s\\})$ 的微观状态 $\\{s\\}$ 的概率由玻尔兹曼分布给出：\n$$\nP(\\{s\\}) = \\frac{1}{Z} e^{-\\beta H(\\{s\\})}\n$$\n其中 $Z$ 是配分函数，$\\beta = 1/(k_{\\mathrm{B}}T)$。对于方形晶格上的伊辛模型，哈密顿量由下式给出：\n$$\nH(\\{s\\}) = -J \\sum_{\\langle i,j \\rangle} s_i s_j\n$$\n其中 $J=1$ 且 $k_{\\mathrm{B}}=1$。\n\n对于任何非平凡的系统尺寸，直接从玻尔兹曼分布中抽样是难以实现的。因此，我们采用马尔可夫链蒙特卡洛 (MCMC) 方法，特别是Metropolis算法，来生成一系列根据 $P(\\{s\\})$ 分布的状态。该算法通过满足细致平衡条件来确保系统向平衡态演化。对于一个提议的单自旋翻转 $s_k \\to -s_k$，其Metropolis转移规则由接受概率决定：\n$$\nP_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right)\n$$\n其中 $\\Delta E$ 是由翻转引起的能量变化。对于自旋 $s_k$ 的翻转，能量变化为：\n$$\n\\Delta E = E_{\\text{final}} - E_{\\text{initial}} = -J \\sum_{\\langle k,j \\rangle} (-s_k)s_j - \\left(-J \\sum_{\\langle k,j \\rangle} s_k s_j\\right) = 2J s_k \\sum_{\\langle k,j \\rangle} s_j\n$$\n此处，$\\sum_{\\langle k,j \\rangle} s_j$ 是格点 $k$ 的邻近自旋之和。\n\n为提高计算效率，我们实现了一种棋盘格更新方案。晶格格点被划分为两个独立的子晶格，即“红色”和“黑色”，类似于棋盘。如果 $(x+y)$ 是偶数，则格点 $(x,y)$ 是红色的；如果 $(x+y)$ 是奇数，则为黑色。关键在于，一个红色格点的所有最近邻都是黑色的，反之亦然。这种独立性允许对一个子晶格上的所有自旋进行同步（矢量化）更新，然后对另一个子晶格上的所有自旋进行同步更新。一次完整的蒙特卡洛扫描包括更新红色子晶格，然后更新黑色子晶格。\n\n每个测试用例的模拟协议如下：\n1.  **初始化**：系统在“热”状态下初始化，其中每个自旋 $s_i$ 以相等的概率随机赋值为 $+1$ 或 $-1$。为保证可复现性，会为一个合适的随机数生成器设定种子。\n2.  **热化**：系统演化指定的热化扫描次数 $N_{\\mathrm{therm}}$。在此阶段，系统从其随机初始状态弛豫至热平衡。不进行测量。\n3.  **测量**：热化之后，模拟继续进行 $N_{\\mathrm{meas}}$ 次测量扫描。每次完整扫描后，计算并记录瞬时单位自旋绝对磁化强度 $m(\\{s\\}) = \\frac{1}{N}|\\sum_i s_i|$。\n4.  **平均**：通过对测量阶段收集的 $m(\\{s\\})$ 瞬时值进行平均，来估算磁化强度的平衡期望值 $\\langle m \\rangle_{L,\\mathcal{B},T}$。\n\n邻居和的计算严重依赖于边界条件 ($\\mathcal{B}$) ：\n-   **周期性边界条件 (PBC)**：晶格被视为一个环面。通过对其坐标应用模 $L$ 运算来找到一个格点的邻居。这可以通过在二维数组上使用 `numpy.roll` 来高效实现。\n-   **开放边界条件 (OBC)**：边缘和角落的自旋的邻居少于四个，因为任何延伸到晶格边界之外的连接都不存在。这可以通过构建邻居和数组，并使用排除边界的适当数组切片来添加来自每个方向的贡献来实现。\n-   **螺旋边界条件 (HBC)**：将 $L \\times L$ 晶格展平为大小为 $N=L^2$ 的一维数组。格点 $i$ 的邻居位于索引 $(i\\pm 1) \\pmod N$ 和 $(i\\pm L) \\pmod N$ 处。根据规定，对于奇数 $L$，此配置与棋盘格更新方案兼容。这可以通过在一维数组上使用 `numpy.roll` 来高效实现。\n\n最后，使用为 $T<T_{\\mathrm{c}}$ 提供的无限晶格自发磁化强度 $m_{\\infty}(T)$ 的精确结果来计算有限尺寸修正：\n$$\n\\Delta m(L,\\mathcal{B},T) = m_{\\infty}(T) - \\langle m \\rangle_{L,\\mathcal{B},T}\n$$\n其中 $T=2.2$ 低于临界温度 $T_{\\mathrm{c}} = 2/\\ln(1+\\sqrt{2}) \\approx 2.269$。$m_{\\infty}(T)$ 的公式为：\n$$\nm_{\\infty}(T) = \\left[1 - \\sinh^{-4}\\left(\\frac{2}{T}\\right)\\right]^{1/8}\n$$\n对六个指定的测试用例中的每一个都重复整个过程，并将结果汇总。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Ising model simulations and compute finite-size corrections.\n    \"\"\"\n\n    def calculate_avg_m(L, T, bc_type, n_therm, n_meas, seed):\n        \"\"\"\n        Performs a Metropolis simulation of the 2D Ising model.\n\n        Args:\n            L (int): Linear size of the lattice.\n            T (float): Temperature.\n            bc_type (str): Boundary condition type ('PBC', 'OBC', 'HBC').\n            n_therm (int): Number of thermalization sweeps.\n            n_meas (int): Number of measurement sweeps.\n            seed (int): Seed for the random number generator.\n\n        Returns:\n            float: The time-averaged absolute magnetization per spin.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        beta = 1.0 / T\n        N = L * L\n        J = 1.0\n\n        # Initialize spins and checkerboard masks\n        if bc_type == 'HBC':\n            spins = rng.choice([-1, 1], size=N)\n            # Create 2D indices to define masks, then flatten\n            x, y = np.meshgrid(np.arange(L), np.arange(L))\n            mask_red = ((x + y) % 2 == 0).flatten()\n            mask_black = ((x + y) % 2 == 1).flatten()\n        else: # PBC, OBC\n            spins = rng.choice([-1, 1], size=(L, L))\n            x, y = np.meshgrid(np.arange(L), np.arange(L))\n            mask_red = (x + y) % 2 == 0\n            mask_black = (x + y) % 2 == 1\n        \n        num_red = np.sum(mask_red)\n        num_black = np.sum(mask_black)\n\n        def update_sublattice(spins, mask, num_sites_in_mask):\n            \"\"\"Applies one parallel update to a sublattice.\"\"\"\n            # Calculate sum of neighbors for all sites\n            if bc_type == 'PBC':\n                neighbors_sum = (np.roll(spins, 1, axis=0) + np.roll(spins, -1, axis=0) +\n                                 np.roll(spins, 1, axis=1) + np.roll(spins, -1, axis=1))\n            elif bc_type == 'OBC':\n                neighbors_sum = np.zeros_like(spins, dtype=np.int8)\n                neighbors_sum[1:, :] += spins[:-1, :]  # Neighbors from top\n                neighbors_sum[:-1, :] += spins[1:, :]  # Neighbors from bottom\n                neighbors_sum[:, 1:] += spins[:, :-1]  # Neighbors from left\n                neighbors_sum[:, :-1] += spins[:, 1:]  # Neighbors from right\n            elif bc_type == 'HBC':\n                neighbors_sum = (np.roll(spins, 1) + np.roll(spins, -1) +\n                                 np.roll(spins, L) + np.roll(spins, -L))\n\n            sublattice_spins = spins[mask]\n            sublattice_neighbors_sum = neighbors_sum[mask]\n\n            # Calculate energy change for a flip for all spins on the sublattice\n            delta_E = 2.0 * J * sublattice_spins * sublattice_neighbors_sum\n            \n            # Metropolis acceptance condition\n            accept = (delta_E <= 0) | (rng.random(size=num_sites_in_mask) < np.exp(-beta * delta_E))\n            \n            # Apply flips. Must assign back to the masked array to modify in place.\n            new_sublattice_spins = sublattice_spins.copy()\n            new_sublattice_spins[accept] *= -1\n            spins[mask] = new_sublattice_spins\n            \n            return spins\n\n        # Thermalization sweeps\n        for _ in range(n_therm):\n            spins = update_sublattice(spins, mask_red, num_red)\n            spins = update_sublattice(spins, mask_black, num_black)\n\n        # Measurement sweeps\n        magnetization_values = []\n        for _ in range(n_meas):\n            spins = update_sublattice(spins, mask_red, num_red)\n            spins = update_sublattice(spins, mask_black, num_black)\n            m = np.abs(np.sum(spins)) / N\n            magnetization_values.append(m)\n        \n        return np.mean(magnetization_values)\n\n    # Define test cases from the problem statement.\n    test_cases = [\n        ('PBC', 9, 2.2, 1000, 2000, 20231101),\n        ('OBC', 9, 2.2, 1000, 2000, 20231102),\n        ('HBC', 9, 2.2, 1000, 2000, 20231103),\n        ('PBC', 13, 2.2, 1000, 2000, 20231104),\n        ('OBC', 13, 2.2, 1000, 2000, 20231105),\n        ('HBC', 13, 2.2, 1000, 2000, 20231106),\n    ]\n\n    # Calculate exact infinite-lattice magnetization for T=2.2\n    T_val = 2.2\n    Tc = 2.0 / np.log(1.0 + np.sqrt(2.0))\n    if T_val < Tc:\n        m_infinity = (1.0 - np.sinh(2.0 / T_val)**(-4))**(1.0/8.0)\n    else:\n        m_infinity = 0.0\n\n    results = []\n    for case in test_cases:\n        bc_type, L, T_case, n_therm, n_meas, seed = case\n        avg_m = calculate_avg_m(L, T_case, bc_type, n_therm, n_meas, seed)\n        delta_m = m_infinity - avg_m\n        results.append(round(delta_m, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2413296"}, {"introduction": "Metropolis算法的威力远不止于模拟物理系统中的热平衡，它同样是解决复杂优化问题的强大工具。在最后一个练习中，我们将这一思想推广到一个全新的领域，通过“模拟退火”这一巧妙技术来解决著名的旅行商问题（TSP），你将学习如何将一个抽象的优化问题映射到一个物理式的“能量”景观上。这个实践不仅展示了统计物理概念惊人的普适性，也为你提供了一个强大的工具来解决现实世界中的复杂优化难题。[@problem_id:2413263]", "problem": "您需要实现一个模拟退火过程，该过程被解释为一种具有随时间变化温度的 Metropolis 算法，通过最小化一个具有物理动机的能量来近似求解旅行商问题 (TSP) 的实例。您的设计必须从 Ising 模型中使用的经典 Metropolis 框架出发，并且您的实现必须在代表排列的离散构型空间上应用相同的转移规则和玻尔兹曼接受逻辑。目标是生成一个可复现的程序，该程序能为指定的测试套件输出最终的路径长度。所有距离都以任意长度单位 (a.u.) 表示，并且所有报告的路径长度必须四舍五入到 a.u. 的六位小数。\n\n使用的基本原理和推导基础：\n- 在温度 $T$ 下，玻尔兹曼分布为能量为 $E(\\boldsymbol{s})$ 的构型 $\\boldsymbol{s}$ 分配概率 $P(\\boldsymbol{s}) \\propto \\exp\\!\\left(-E(\\boldsymbol{s})/T\\right)$。\n- Metropolis 转移规则使用接受概率 $A(\\boldsymbol{s}\\to\\boldsymbol{s}') = \\min\\!\\left\\{1,\\exp\\!\\left(-\\Delta E/T\\right)\\right\\}$（其中 $\\Delta E = E(\\boldsymbol{s}')-E(\\boldsymbol{s})$），以满足相对于玻尔兹曼分布的细致平衡条件。\n- 模拟退火是一种非平稳的 Metropolis 过程，其中温度 $T$ 根据冷却方案 $T_{t+1} = \\alpha T_t$（固定 $0 < \\alpha < 1$）从初始温度 $T_0$ 开始逐渐降低。\n\n将旅行商问题 (TSP) 建模为能量最小化问题：\n- 考虑平面上的 $N$ 个城市，其位置为 $\\{\\boldsymbol{r}_i\\}_{i=0}^{N-1}$，并令 $d_{ij}$ 为 $\\boldsymbol{r}_i$ 和 $\\boldsymbol{r}_j$ 之间的欧几里得距离（单位为 a.u.）。\n- 一条路径是由一个排列 $\\boldsymbol{p} = (p_0,p_1,\\dots,p_{N-1})$ 表示的循环排序，其中每个 $p_k$ 是 $\\{0,\\dots,N-1\\}$ 中一个不同的城市索引，且 $p_N \\equiv p_0$。\n- 定义路径能量（待最小化）为总路径长度\n$$\nE(\\boldsymbol{p}) \\equiv \\sum_{k=0}^{N-1} d_{p_k,\\,p_{k+1}} \\quad \\text{(in a.u.)}.\n$$\n\n算法要求：\n- 使用上述定义的 $E(\\boldsymbol{p})$ 和几何冷却方案 $T_{t+1}=\\alpha T_t$ 的 Metropolis 接受规则。\n- 使用一种能保持排列约束的构型空间移动，以维持类似于 Ising 模型中单自旋翻转提议的物理真实性，但需适应于受约束的流形。为实现计算效率和作为循环路径局部拓扑变化的可物理解释性，请使用 $2$-opt 移动：选择索引 $i$ 和 $j$（满足 $0 \\le i  j \\le N-1$），这两个索引在循环中不是直接相邻的（包括循环回绕），然后反转它们之间的片段。能量变化 $\\Delta E$ 必须仅通过四个受影响边的距离精确计算，而不是通过重新计算总和。\n- 每次运行时，使用给定的伪随机种子，从所有 $N!$ 个排列中均匀随机地抽取一个排列进行初始化。\n\n使用的冷却方案和参数：\n- 初始温度 $T_0 = 1.0$（与 $E$ 的能量单位相同，即 a.u.）。\n- 几何冷却因子 $\\alpha = 0.995$。\n- 温度级别数 $N_T = 1000$。\n- 在每个温度级别，执行 $M = 20N$ 次独立的 $2$-opt Metropolis 提议。\n\n要实现和报告的测试套件：\n对于以下每个测试用例，使用指定的种子和上述参数运行模拟退火，然后应用最终的确定性 $2$-opt 下降法（重复任何严格改进的 $2$-opt 移动，直到不存在此类移动为止），以确保达到一个 $2$-opt 局部最小值。报告最终路径长度 $E(\\boldsymbol{p}_{\\mathrm{final}})$（单位 a.u.），四舍五入到六位小数。\n\n- 测试用例 A（单位圆上的凸正方形）：$N=4$，城市位于角度 $\\theta_k = \\frac{2\\pi k}{4}$ 处，位置为 $\\boldsymbol{r}_k = (\\cos\\theta_k,\\sin\\theta_k)$，其中 $k\\in\\{0,1,2,3\\}$。使用种子 $7$。\n- 测试用例 B（单位圆上的正五边形）：$N=5$，城市位于角度 $\\theta_k = \\frac{2\\pi k}{5}$ 处，位置为 $\\boldsymbol{r}_k = (\\cos\\theta_k,\\sin\\theta_k)$，其中 $k\\in\\{0,1,2,3,4\\}$。使用种子 $13$。\n- 测试用例 C（单位圆上的正六边形）：$N=6$，城市位于角度 $\\theta_k = \\frac{2\\pi k}{6}$ 处，位置为 $\\boldsymbol{r}_k = (\\cos\\theta_k,\\sin\\theta_k)$，其中 $k\\in\\{0,1,2,3,4,5\\}$。使用种子 $29$。\n\n角度单位说明：所有角度均为弧度。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [A,B,C]。每个条目是最终路径长度（单位 a.u.），四舍五入到六位小数。例如，一个有效的输出格式类似于“[x.xxxxxx,y.yyyyyy,z.zzzzzz]”，每个值小数点后恰好有六位数字。", "solution": "所呈现的问题陈述是有效的。它具有科学依据、问题定义良好、客观且完整。它描述了 Metropolis 算法（以模拟退火形式）在经典组合优化问题——旅行商问题 (TSP) 上的标准应用。将最小化路径长度类比为寻找系统基态能量，是统计力学在优化领域应用的基石。算法的所有参数、初始条件和测试用例都得到了明确的规定，包括用于确保可复现性的伪随机种子。所要求的移动集，即 2-opt 移动，是 TSP 的一种定义明确的标准启发式方法。该问题是可形式化和算法上可处理的。\n\n现在我将继续对解决方案进行详细的推导和描述。\n\n### 1. 旅行商问题的建模\n\n该问题是找到一条最短路径，该路径访问给定集合中的每个城市恰好一次，并返回起始城市。这可以映射到统计物理学中的一个问题。\n\n- **构型空间 ($S$):** 系统的一个状态，或一个构型，是一条特定的路径。对于从 $0$ 到 $N-1$ 索引的 $N$ 个城市，一条路径可以由城市索引的一个排列 $\\boldsymbol{p} = (p_0, p_1, \\dots, p_{N-1})$ 来表示。所有 $N!$ 个此类排列的集合构成了构型空间。\n\n- **能量函数 ($E$):** 构型 $\\boldsymbol{p}$ 的“能量”被定义为路径的总长度。给定城市的位置 $\\{\\boldsymbol{r}_i\\}_{i=0}^{N-1}$，我们首先计算欧几里得距离矩阵 $d_{ij} = ||\\boldsymbol{r}_i - \\boldsymbol{r}_j||_2$。然后，能量为：\n$$ E(\\boldsymbol{p}) = \\sum_{k=0}^{N-1} d_{p_k, p_{(k+1) \\pmod N}} $$\nTSP 的目标是找到使该能量函数最小化的排列 $\\boldsymbol{p}^*$，即系统的基态。\n\n### 2. 模拟退火算法\n\n模拟退火是一种受冶金学中退火过程启发的元启发式算法。它在一系列递减的温度下使用 Metropolis 算法来引导其搜索能量函数的全局最小值。\n\n- **初始状态:** 模拟从一条随机路径开始，该路径通过从城市索引 $\\{0, 1, \\dots, N-1\\}$ 中均匀随机抽取一个排列来生成。使用以特定种子初始化的伪随机数生成器来确保可复现性。\n\n- **Metropolis 步骤:** 在给定温度 $T$ 下，系统从当前构型 $\\boldsymbol{p}$ 转移到一个新的提议构型 $\\boldsymbol{p}'$。该转移以 Metropolis 准则给出的概率被接受：\n$$ A(\\boldsymbol{p} \\to \\boldsymbol{p}') = \\min\\left\\{1, \\exp\\left(-\\frac{\\Delta E}{T}\\right)\\right\\} $$\n其中 $\\Delta E = E(\\boldsymbol{p}') - E(\\boldsymbol{p})$ 是能量的变化。如果 $\\Delta E \\le 0$，则新构型更好或相等，该移动总是被接受。如果 $\\Delta E  0$，则该移动以概率 $\\exp(-\\Delta E/T)$ 被接受，这使得系统能够偶尔跳出局部最小值。\n\n- **新构型的提议 (2-Opt 移动):** 通过 2-opt 移动从当前路径 $\\boldsymbol{p}$ 生成一条新路径 $\\boldsymbol{p}'$。该移动包括从排列数组中选择两个索引 $i$ 和 $j$（满足 $0 \\le i  j \\le N-1$），并反转它们之间的路径片段。\n设当前路径为 $\\boldsymbol{p} = (p_0, \\dots, p_{i-1}, p_i, \\dots, p_j, p_{j+1}, \\dots, p_{N-1})$。新路径 $\\boldsymbol{p}'$ 通过反转从索引 $i$ 到 $j$ 的子数组形成：\n$$ \\boldsymbol{p}' = (p_0, \\dots, p_{i-1}, p_j, p_{j-1}, \\dots, p_i, p_{j+1}, \\dots, p_{N-1}) $$\n此操作会断开路径中的两条边 $(p_{(i-1)\\pmod N}, p_i)$ 和 $(p_j, p_{(j+1)\\pmod N})$，并创建两条新边 $(p_{(i-1)\\pmod N}, p_j)$ 和 $(p_i, p_{(j+1)\\pmod N})$。能量变化可以高效地计算，而无需重新求和整个路径长度：\n$$ \\Delta E = \\left( d_{p_{(i-1)\\pmod N}, p_j} + d_{p_i, p_{(j+1)\\pmod N}} \\right) - \\left( d_{p_{(i-1)\\pmod N}, p_i} + d_{p_j, p_{(j+1)\\pmod N}} \\right) $$\n为确保移动是非平凡的，我们必须选择 $i$ 和 $j$，使得片段反转不对应于反转整个路径（这会导致 $\\Delta E=0$）。我们将生成对 $(i, j)$，如果它们对应于这种平凡情况，则予以拒绝。\n\n- **冷却方案:** 温度 $T$ 根据几何冷却方案逐渐降低。从初始温度 $T_0$ 开始，在固定数量的 Metropolis 步骤后更新温度：\n$$ T_{k+1} = \\alpha T_k $$\n其中 $\\alpha \\in (0, 1)$ 是冷却因子。该过程运行固定的温度级别数 $N_T$。在每个温度级别，执行 $M = 20N$ 次 Metropolis 提议。\n\n### 3. 最终局部优化\n\n模拟退火过程结束后，最终路径可能不是关于 2-opt 移动的局部最小值。因此，执行确定性的局部搜索或下降法，以保证得到一个 2-opt 局部最优解。此过程包括系统地检查当前路径上所有可能的 2-opt 移动。如果找到一个严格减小路径长度的移动（$\\Delta E  0$），则立即接受该移动，并从新的、改进后的路径重新开始搜索。重复此过程，直到对所有可能的 2-opt 移动进行一次完整遍历后不再有任何改进。\n\n### 4. 测试用例的实现\n\n算法将根据指定的参数实现：\n- **初始温度:** $T_0 = 1.0$\n- **冷却因子:** $\\alpha = 0.995$\n- **温度级别数:** $N_T = 1000$\n- **每个温度的步数:** $M = 20N$\n\n每个测试用例的城市坐标在单位圆上生成：$\\boldsymbol{r}_k = (\\cos(2\\pi k/N), \\sin(2\\pi k/N))$。\n- **用例 A:** $N=4$，种子$=7$\n- **用例 B:** $N=5$，种子$=13$\n- **用例 C:** $N=6$，种子$=29$\n\n对于每个用例，将执行完整的程序（初始化、模拟退火和最终的 2-opt 下降法）。将报告最终的路径长度，四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulated annealing for the TSP test cases.\n    \"\"\"\n    test_cases = [\n        # (N, seed)\n        (4, 7),  # Test case A\n        (5, 13), # Test case B\n        (6, 29)  # Test case C\n    ]\n\n    # Annealing parameters\n    t0 = 1.0\n    alpha = 0.995\n    n_temp_levels = 1000\n\n    results = []\n    for n_cities, seed in test_cases:\n        # Generate city coordinates on a unit circle\n        angles = 2 * np.pi * np.arange(n_cities) / n_cities\n        cities = np.array([np.cos(angles), np.sin(angles)]).T\n        \n        # Pre-compute distance matrix\n        dist_matrix = np.sqrt(\n            np.sum(\n                (cities[:, np.newaxis, :] - cities[np.newaxis, :, :]) ** 2, axis=2\n            )\n        )\n        \n        # Number of Metropolis steps per temperature\n        m_steps = 20 * n_cities\n\n        # Initialize random number generator with seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. INITIALIZATION: Start with a random tour\n        current_tour = rng.permutation(n_cities)\n        current_energy = 0\n        for i in range(n_cities):\n            current_energy += dist_matrix[current_tour[i], current_tour[(i + 1) % n_cities]]\n\n        # 2. SIMULATED ANNEALING\n        t = t0\n        for _ in range(n_temp_levels):\n            for _ in range(m_steps):\n                # Propose a 2-opt move\n                # Select two distinct indices i and j\n                i, j = rng.choice(n_cities, 2, replace=False)\n                if i  j:\n                    i, j = j, i\n                \n                # A reversal of the whole tour is trivial (delta_E=0)\n                # and just wastes computation. Skip it.\n                if i == 0 and j == n_cities - 1:\n                    continue\n\n                # Calculate energy change (Delta E) for the 2-opt move\n                # Edges to be broken: (p[i-1], p[i]) and (p[j], p[j+1])\n                # New edges: (p[i-1], p[j]) and (p[i], p[j+1])\n                p_i_minus_1 = current_tour[i - 1] # works for i=0 due to -1 index\n                p_i = current_tour[i]\n                p_j = current_tour[j]\n                p_j_plus_1 = current_tour[(j + 1) % n_cities]\n\n                delta_e = (\n                    dist_matrix[p_i_minus_1, p_j] + dist_matrix[p_i, p_j_plus_1]\n                ) - (\n                    dist_matrix[p_i_minus_1, p_i] + dist_matrix[p_j, p_j_plus_1]\n                )\n\n                # Metropolis acceptance criterion\n                if delta_e  0 or rng.random()  np.exp(-delta_e / t):\n                    # Accept move: reverse the segment p[i:j+1]\n                    current_tour[i:j+1] = current_tour[i:j+1][::-1]\n                    current_energy += delta_e\n            \n            # Cool down\n            t *= alpha\n            \n        # 3. FINAL 2-OPT LOCAL SEARCH\n        improved = True\n        while improved:\n            improved = False\n            for i in range(n_cities - 1):\n                for j in range(i + 1, n_cities):\n                    # Avoid trivial full reversal\n                    if i == 0 and j == n_cities - 1:\n                        continue\n                    \n                    p_i_minus_1 = current_tour[i - 1]\n                    p_i = current_tour[i]\n                    p_j = current_tour[j]\n                    p_j_plus_1 = current_tour[(j + 1) % n_cities]\n\n                    delta_e = (\n                        dist_matrix[p_i_minus_1, p_j] + dist_matrix[p_i, p_j_plus_1]\n                    ) - (\n                        dist_matrix[p_i_minus_1, p_i] + dist_matrix[p_j, p_j_plus_1]\n                    )\n                    \n                    # Accept any strictly improving move\n                    if delta_e  -1e-9: # Use a small tolerance for float comparison\n                        current_tour[i:j+1] = current_tour[i:j+1][::-1]\n                        current_energy += delta_e\n                        improved = True\n                        # Restart search from the new tour\n                        break\n                if improved:\n                    break\n        \n        results.append(f\"{current_energy:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413263"}]}