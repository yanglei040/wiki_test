{"hands_on_practices": [{"introduction": "本节的实践练习将引导您完成逆变换采样方法的完整工作流程，从基本原理到最终验证。我们将从一个基础但非常重要的例子开始：对指数分布进行采样。通过这个练习，您不仅将掌握推导和实现一个解析逆变换的过程，还将学会使用统计检验来验证您生成的样本是否符合目标分布，这是计算科学中一项至重要的技能 [@problem_id:2403697]。", "problem": "要求您使用第一性原理来形式化、实现并验证指数分布的采样。考虑率参数为 $\\lambda \\in (0,\\infty)$ 且累积分布函数为 $F(x) = \\mathbb{P}(X \\le x)$ 的指数分布。\n\n任务：\n1. 使用逆变换原理，通过从单位区间上均匀分布的变量 $U$ 中独立抽取，生成 $n$ 个来自率参数为 $\\lambda$ 的指数分布的独立样本。您必须利用以下性质：如果 $U$ 在单位区间上均匀分布，则 $F^{-1}(U)$ 的累积分布函数为 $F$。\n2. 对于每个参数三元组 $(\\lambda,n,\\alpha)$，其中 $\\lambda \\in (0,\\infty)$，$n \\in \\mathbb{N}$，$\\alpha \\in (0,1)$ 为显著性水平，请基于您生成的 $n$ 个样本，对率参数为 $\\lambda$ 的指数分布进行单样本分布拟合优度检验。报告其 $p$ 值以及一个布尔决策：如果在显著性水平 $\\alpha$ 下不拒绝数据遵循率参数为 $\\lambda$ 的指数分布的原假设，则为 $\\text{True}$，否则为 $\\text{False}$。$p$ 值必须报告为实数。\n3. 为保证可复现性，请在开始时使用固定的整数种子 $s=123456789$ 对您的伪随机数生成器进行一次初始化。\n\n测试用例：\n- 案例 $1$：$(\\lambda,n,\\alpha) = (0.7,1000,0.05)$\n- 案例 $2$：$(\\lambda,n,\\alpha) = (2.3,200,0.01)$\n- 案例 $3$：$(\\lambda,n,\\alpha) = (0.1,500,0.10)$\n- 案例 $4$：$(\\lambda,n,\\alpha) = (10.0,100,0.05)$\n- 案例 $5$：$(\\lambda,n,\\alpha) = (0.5,5,0.20)$\n\n您的程序必须：\n- 实现第 $1$ 项中描述的采样器，为每个案例生成 $n$ 个样本。\n- 实现第 $2$ 项中描述的检验，并计算每个案例的 $p$ 值。\n- 对于每个案例 $i \\in \\{1,2,3,4,5\\}$，按顺序输出两个值：四舍五入到六位小数的 $p$ 值和上述指定的布尔决策。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有结果，形式为一个用方括号括起来的逗号分隔列表。该列表的长度必须为 $10$，并按 $[p_1,d_1,p_2,d_2,p_3,d_3,p_4,d_4,p_5,d_5]$ 的顺序排列，其中 $p_i$ 是案例 $i$ 的 $p$ 值（四舍五入到六位小数），$d_i$ 是对应的布尔决策。", "solution": "该问题要求使用逆变换法从指数分布中生成随机样本，然后使用拟合优度检验对这些样本进行统计验证。解决方案分两部分展开：首先是采样算法的推导，其次是统计检验的说明。\n\n**1. 指数分布的逆变换采样**\n\n指数分布的特征是其率参数 $\\lambda > 0$。其随机变量 $X$ 的概率密度函数 (PDF) 由下式给出：\n$$\nf(x; \\lambda) = \\begin{cases} \\lambda e^{-\\lambda x} & \\text{if } x \\ge 0 \\\\ 0 & \\text{if } x < 0 \\end{cases}\n$$\n累积分布函数 (CDF) $F(x)$ 表示随机变量 $X$ 取值小于或等于 $x$ 的概率。它通过将 PDF 从 $0$ 积分到 $x$ 得到：\n$$\nF(x) = \\mathbb{P}(X \\le x) = \\int_0^x \\lambda e^{-\\lambda t} dt = \\left[ -e^{-\\lambda t} \\right]_0^x = 1 - e^{-\\lambda x} \\quad \\text{for } x \\ge 0\n$$\n逆变换采样方法基于以下原理：如果 $U$ 是从区间 $(0, 1)$ 上的标准均匀分布中抽取的随机变量，那么随机变量 $X = F^{-1}(U)$ 将服从以 CDF $F$ 为特征的分布。\n\n为应用此方法，我们必须首先求出 CDF 的逆函数，记为 $F^{-1}(u)$。我们设 $u = F(x)$，然后求解 $x$：\n$$\nu = 1 - e^{-\\lambda x}\n$$\n整理各项以分离 $x$：\n$$\ne^{-\\lambda x} = 1 - u\n$$\n对两边取自然对数：\n$$\n-\\lambda x = \\ln(1 - u)\n$$\n最后，解出 $x$ 得到逆 CDF：\n$$\nx = F^{-1}(u) = -\\frac{1}{\\lambda} \\ln(1 - u)\n$$\n因此，要从率参数为 $\\lambda$ 的指数分布中生成一个样本 $x$，需要从 $\\text{Uniform}(0,1)$ 分布中生成一个随机数 $u$，并应用变换 $x = -\\frac{1}{\\lambda} \\ln(1 - u)$。\n\n一个有用的简化来自以下性质：如果 $U \\sim \\text{Uniform}(0,1)$，则随机变量 $V = 1 - U$ 也服从 $\\text{Uniform}(0,1)$ 分布。这允许我们将公式中的 $1 - u$ 替换为 $u$，从而得到一个计算上等效且更直接的表达式：\n$$\nx = -\\frac{1}{\\lambda} \\ln(u)\n$$\n我们将实现此公式来为每个测试用例生成 $n$ 个样本。该过程首先使用指定的种子 $s=123456789$ 初始化一个伪随机数生成器，以确保可复现性。然后，对于每个测试用例 $(\\lambda, n, \\alpha)$，我们从 $\\text{Uniform}(0,1)$ 分布中抽取 $n$ 个独立的值 $u_1, u_2, \\dots, u_n$，并计算相应的指数样本 $x_i = -\\frac{1}{\\lambda} \\ln(u_i)$。\n\n**2. 拟合优度检验**\n\n生成样本数据 $\\{x_1, \\dots, x_n\\}$ 后，必须执行单样本分布拟合优度检验。原假设 $H_0$ 是数据来自具有指定率参数 $\\lambda$ 的指数分布。备择假设 $H_1$ 是数据不来自该分布。\n\n适用于此场景的标准检验是单样本柯尔莫哥洛夫-斯米尔诺夫 (K-S) 检验。该检验将样本数据的经验累积分布函数 (ECDF) $F_n(x)$ 与假设分布的理论 CDF $F(x) = 1 - e^{-\\lambda x}$ 进行比较。ECDF 定义为：\n$$\nF_n(x) = \\frac{1}{n} \\sum_{i=1}^n \\mathbb{I}(x_i \\le x)\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。K-S 检验统计量 $D_n$ 是 ECDF 与理论 CDF 在所有可能的 $x$ 值上的最大绝对差：\n$$\nD_n = \\sup_x | F_n(x) - F(x) |\n$$\n在原假设下，$D_n$ 统计量的分布是已知的，并且独立于所检验的特定连续分布。这一性质使得计算 $p$ 值成为可能，$p$ 值定义为：假设 $H_0$ 为真时，观测到与从数据中计算出的检验统计量同样极端或更极端的统计量的概率。\n\n决策规则基于显著性水平 $\\alpha$：\n- 如果 $p$ 值小于 $\\alpha$，我们拒绝原假设 $H_0$。\n- 如果 $p$ 值大于或等于 $\\alpha$，我们不拒绝原假设 $H_0$。\n\n问题要求一个布尔决策，当不拒绝 $H_0$ 时为 $\\text{True}$。因此，给定测试用例的决策将是比较 $p\\text{-值} \\ge \\alpha$ 的结果。在实现上，我们将使用 `scipy.stats.kstest` 函数。`scipy` 中的指数分布实现是通过一个位置参数 `loc` 和一个尺度参数 `scale` 来参数化的。为了匹配我们的目标 PDF $\\lambda e^{-\\lambda x}$，我们必须设置 `loc`$=0$ 和 `scale`$=1/\\lambda$。\n\n每个测试用例 $(\\lambda, n, \\alpha)$ 的完整算法如下：\n1. 使用以 $s=123456789$ 为种子的生成器生成 $n$ 个均匀随机数 $u_1, \\dots, u_n$。\n2. 将这些数转换为指数样本 $x_i = -\\frac{1}{\\lambda} \\ln(u_i)$。\n3. 对样本 $\\{x_i\\}$ 使用参数为 `loc=0` 和 `scale=1/\\lambda` 的 'expon' 分布进行 K-S 检验。\n4. 从检验结果中获取 $p$ 值。\n5. 计算布尔决策为 $p\\text{-值} \\ge \\alpha$。\n6. 报告四舍五入到六位小数的 $p$ 值和布尔决策。\n\n此程序将对所有五个指定的测试用例执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the problem by generating exponential samples via inverse transform\n    and validating them with a Kolmogorov-Smirnov goodness-of-fit test.\n\n    The process adheres to the problem's requirements for validation,\n    reproducibility with a fixed seed, and specific output formatting.\n    \"\"\"\n    \n    # Global seed for reproducibility, as per problem statement.\n    # The modern `default_rng` is used for generating pseudo-random numbers.\n    seed = 123456789\n    rng = np.random.default_rng(seed)\n\n    # Test suite: each tuple is (lambda, n, alpha)\n    test_cases = [\n        (0.7, 1000, 0.05),\n        (2.3, 200, 0.01),\n        (0.1, 500, 0.10),\n        (10.0, 100, 0.05),\n        (0.5, 5, 0.20),\n    ]\n\n    results = []\n    for lambda_val, n, alpha in test_cases:\n        # Task 1: Generate n samples from the exponential distribution with rate lambda.\n        # This is implemented using the inverse transform method.\n        # If U is a random variable from Uniform(0, 1), then X = -ln(U)/lambda\n        # is a random variable from Exponential(lambda).\n        \n        # Generate n uniform random numbers in the interval [0.0, 1.0).\n        uniform_samples = rng.uniform(size=n)\n        \n        # Apply the inverse CDF transformation.\n        exponential_samples = -np.log(uniform_samples) / lambda_val\n\n        # Task 2: Conduct a one-sample Kolmogorov-Smirnov test.\n        # The null hypothesis (H0) is that the generated data follows an\n        # exponential distribution with the given rate lambda_val.\n        # The `scipy.stats.expon` distribution is parameterized by `loc` and `scale`.\n        # For a rate lambda, the scale parameter is 1/lambda and loc is 0.\n        scale_param = 1.0 / lambda_val\n        ks_statistic, p_value = stats.kstest(exponential_samples, 'expon', args=(0, scale_param))\n        \n        # The decision is True if we do not reject H0 at significance level alpha.\n        # This occurs when the p-value is greater than or equal to alpha.\n        decision = p_value >= alpha\n        \n        # Format results as specified in the problem statement.\n        p_value_rounded = round(p_value, 6)\n        \n        results.append(p_value_rounded)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) function correctly converts boolean values to \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function to solve the problem and print the output.\nsolve()\n```", "id": "2403697"}, {"introduction": "在掌握了基础知识后，我们来挑战一个在物理学和复杂系统中无处不在的分布：幂律分布。这个练习要求您为一个在有限区间上截断的幂律分布生成随机变量。这个过程需要您细致地处理归一化、推导累积分布函数及其逆函数，并特别注意指数参数 $\\alpha=1$ 时的特殊情况，这能极好地锻炼您在编码前进行严谨数学分析的能力 [@problem_id:2403909]。", "problem": "您的任务是构建一个程序，用于从计算物理学中使用的截断幂律概率分布中生成独立的随机变量。该分布在一个有限区间上定义，其概率密度函数（Probability Density Function, PDF）为\n$$\np(x) = C\\,x^{-\\alpha} \\quad \\text{for } x \\in [x_{\\min}, x_{\\max}],\n$$\n在其他情况下$p(x)=0$，其中 $C$ 是归一化常数，它使得在 $[x_{\\min}, x_{\\max}]$ 上的总概率等于 $1$。参数满足 $x_{\\min} > 0$、$x_{\\max} > x_{\\min}$ 和 $\\alpha > 0$。域变量是实值 $x \\in \\mathbb{R}$。目标是生成完全遵循此截断密度分布的合成数据。\n\n您的程序必须：\n- 通过上述目标分布的精确定义隐式处理 $C$，确保生成的变量遵循在 $[x_{\\min}, x_{\\max}]$ 上的密度 $p(x)$ 分布。\n- 对于每个测试用例，完全按照此分布生成 $N$ 个独立变量，使用一个在最初用固定整数种子 $20231102$ 初始化一次的伪随机数生成器，然后按照下面列出的顺序跨测试用例顺序使用伪随机数。\n- 对于每个测试用例，生成 $N$ 个变量后，计算以下三个汇总统计量：\n  1. $N$ 个变量中的最小值。\n  2. 中位数，定义为第 $\\left(\\frac{N+1}{2}\\right)$ 个顺序统计量（请注意，下面的每个 $N$ 都是奇数，所以这是一个无需插值的精确顺序统计量）。\n  3. $N$ 个变量中的最大值。\n- 将每个测试用例报告的三个值都四舍五入到恰好六位小数。\n- 将所有测试用例的结果汇总到单行输出中，该输出包含一个逗号分隔的列表的列表，每个内部列表按以下顺序对应一个测试用例。\n\n测试套件（五个测试用例）：\n- 用例 1: $\\alpha = 2.5$, $x_{\\min} = 1.0$, $x_{\\max} = 10.0$, $N = 9999$.\n- 用例 2: $\\alpha = 1.0$, $x_{\\min} = 0.1$, $x_{\\max} = 100.0$, $N = 9999$.\n- 用例 3: $\\alpha = 0.3$, $x_{\\min} = 1.0$, $x_{\\max} = 1000000.0$, $N = 7777$.\n- 用例 4: $\\alpha = 5.0$, $x_{\\min} = 0.5$, $x_{\\max} = 2.0$, $N = 5555$.\n- 用例 5: $\\alpha = 0.9$, $x_{\\min} = 2.0$, $x_{\\max} = 3.0$, $N = 3333$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由五个内部列表组成的逗号分隔列表形式的结果，每个内部列表按 [最小值, 中位数, 最大值] 的顺序包含相应测试用例的三个四舍五入后的值。确切要求的格式是：\n[\n[min_case1,median_case1,max_case1],\n[min_case2,median_case2,max_case2],\n[min_case3,median_case3,max_case3],\n[min_case4,median_case4,max_case4],\n[min_case5,median_case5,max_case5]\n]\n输出中出现的所有数字都必须按规定四舍五入到六位小数。不得打印任何额外文本。", "solution": "我们审查了问题陈述并确认其有效。该问题具有科学依据，提法明确，客观，并为计算物理学中的一个可解问题提供了一套完整且一致的给定条件。任务是从截断幂律分布中生成随机变量，这是一个标准流程。逆变换采样法对于此目的而言是精确的，我们将采用该方法。\n\n逆变换采样法的基本原理是：如果一个随机变量 $U$ 在区间 $[0, 1]$ 上均匀分布，那么通过变换 $X = F^{-1}(U)$ 定义的随机变量 $X$ 将遵循某个概率密度函数 $p(x)$ 的分布，该概率密度函数的累积分布函数（CDF）是 $F(x)$。这里，$F^{-1}$ 是逆CDF，也称为分位数函数。\n\n因此，步骤是首先从给定的概率密度函数（PDF）$p(x)$ 推导出累积分布函数（CDF）$F(x)$，然后求其反函数 $F^{-1}(u)$。\n\nPDF由以下公式给出：\n$$\np(x) = C\\,x^{-\\alpha} \\quad \\text{for } x \\in [x_{\\min}, x_{\\max}]\n$$\n其中 $C$ 是一个归一化常数。对于支撑区间 $[x_{\\min}, x_{\\max}]$ 内的一个值 $x$，其累积分布函数（CDF）$F(x)$ 是概率 $P(X \\le x)$，由PDF从 $x_{\\min}$ 到 $x$ 的积分给出。\n$$\nF(x) = \\int_{x_{\\min}}^{x} p(t) \\,dt\n$$\n为确保 $F(x_{\\max}) = 1$，该积分必须通过在整个支撑区间上的总概率进行归一化。\n$$\nF(x) = \\frac{\\int_{x_{\\min}}^{x} C t^{-\\alpha} \\,dt}{\\int_{x_{\\min}}^{x_{\\max}} C t^{-\\alpha} \\,dt}\n$$\n常数 $C$ 被消去，这与问题中隐式处理 $C$ 的指令一致。我们剩下要计算 $t^{-\\alpha}$ 的积分。积分的形式取决于 $\\alpha$ 是否等于1。\n\n情况 1: $\\alpha \\neq 1$\n$t^{-\\alpha}$ 的不定积分是 $\\frac{t^{1-\\alpha}}{1-\\alpha}$。定积分是：\n$$\n\\int_{a}^{b} t^{-\\alpha} \\,dt = \\left[ \\frac{t^{1-\\alpha}}{1-\\alpha} \\right]_{a}^{b} = \\frac{b^{1-\\alpha} - a^{1-\\alpha}}{1-\\alpha}\n$$\n将此代入CDF的表达式中：\n$$\nF(x) = \\frac{\\frac{x^{1-\\alpha} - x_{\\min}^{1-\\alpha}}{1-\\alpha}}{\\frac{x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}}{1-\\alpha}} = \\frac{x^{1-\\alpha} - x_{\\min}^{1-\\alpha}}{x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}}\n$$\n\n情况 2: $\\alpha = 1$\nPDF为 $p(x) \\propto x^{-1}$。$t^{-1}$ 的不定积分是 $\\ln(t)$。定积分是：\n$$\n\\int_{a}^{b} t^{-1} \\,dt = \\left[ \\ln(t) \\right]_{a}^{b} = \\ln(b) - \\ln(a) = \\ln(b/a)\n$$\n将此代入CDF的表达式中：\n$$\nF(x) = \\frac{\\ln(x) - \\ln(x_{\\min})}{\\ln(x_{\\max}) - \\ln(x_{\\min})} = \\frac{\\ln(x/x_{\\min})}{\\ln(x_{\\max}/x_{\\min})}\n$$\n\n接下来，我们必须通过设 $u = F(x)$（其中 $u \\in [0, 1]$）并求解 $x$ 来找到逆CDF $F^{-1}(u)$。\n\n情况 1: $\\alpha \\neq 1$\n$$\nu = \\frac{x^{1-\\alpha} - x_{\\min}^{1-\\alpha}}{x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}}\n$$\n$$\nu(x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}) = x^{1-\\alpha} - x_{\\min}^{1-\\alpha}\n$$\n$$\nx^{1-\\alpha} = x_{\\min}^{1-\\alpha} + u(x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha})\n$$\n$$\nx = F^{-1}(u) = \\left[ x_{\\min}^{1-\\alpha} + u(x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}) \\right]^{\\frac{1}{1-\\alpha}}\n$$\n\n情况 2: $\\alpha = 1$\n$$\nu = \\frac{\\ln(x) - \\ln(x_{\\min})}{\\ln(x_{\\max}) - \\ln(x_{\\min})}\n$$\n$$\nu(\\ln(x_{\\max}) - \\ln(x_{\\min})) = \\ln(x) - \\ln(x_{\\min})\n$$\n$$\n\\ln(x) = \\ln(x_{\\min}) + u(\\ln(x_{\\max}) - \\ln(x_{\\min}))\n$$\n使用对数的性质，这可以简化为：\n$$\n\\ln(x) = (1-u)\\ln(x_{\\min}) + u\\ln(x_{\\max}) = \\ln(x_{\\min}^{1-u} x_{\\max}^{u})\n$$\n对两边取指数，得到分位数函数：\n$$\nx = F^{-1}(u) = x_{\\min}^{1-u} x_{\\max}^{u} = x_{\\min} \\left(\\frac{x_{\\max}}{x_{\\min}}\\right)^u\n$$\n\n计算算法如下：\n1. 使用指定的种子初始化一个伪随机数生成器。\n2. 对于每个测试用例 $(\\alpha, x_{\\min}, x_{\\max}, N)$:\n   a. 从 $[0, 1]$ 上的均匀分布中生成 $N$ 个独立的随机数 $u_1, u_2, \\dots, u_N$。\n   b. 对于每个 $u_i$，根据 $\\alpha$ 的值使用相应的公式计算出对应的变量 $x_i = F^{-1}(u_i)$。\n   c. 从得到的 $N$ 个变量样本 $\\{x_i\\}$ 中，计算最小值、中位数（对于奇数 $N$，即为第 $((N+1)/2)$ 个顺序统计量）和最大值。\n   d. 将这三个统计量四舍五入到六位小数。\n3. 整理并按规定格式化结果。\n此过程将保证生成的变量遵循所期望的截断幂律分布。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Generates random variates from a truncated power-law distribution using\n    inverse transform sampling and computes summary statistics for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, x_min, x_max, N)\n        (2.5, 1.0, 10.0, 9999),\n        (1.0, 0.1, 100.0, 9999),\n        (0.3, 1.0, 1000000.0, 7777),\n        (5.0, 0.5, 2.0, 5555),\n        (0.9, 2.0, 3.0, 3333),\n    ]\n\n    # Initialize a single pseudorandom number generator as required.\n    # The generator's state will be updated sequentially across all test cases.\n    rng = np.random.default_rng(20231102)\n\n    all_results = []\n    \n    for case in test_cases:\n        alpha, x_min, x_max, N = case\n\n        # Generate N uniform random numbers in [0, 1).\n        u = rng.random(size=N)\n\n        # Apply the inverse transform sampling formula.\n        # Two distinct formulas are required depending on whether alpha is 1.\n        if alpha == 1.0:\n            # Quantile function for alpha = 1: x = x_min * (x_max / x_min)^u\n            samples = x_min * (x_max / x_min)**u\n        else:\n            # Quantile function for alpha != 1:\n            # x = [x_min^(1-alpha) + u * (x_max^(1-alpha) - x_min^(1-alpha))]^(1/(1-alpha))\n            one_minus_alpha = 1.0 - alpha\n            x_min_pow = x_min**one_minus_alpha\n            x_max_pow = x_max**one_minus_alpha\n            \n            inner_term = x_min_pow + u * (x_max_pow - x_min_pow)\n            samples = inner_term**(1.0 / one_minus_alpha)\n\n        # Compute the required summary statistics.\n        # N is always odd, so np.median correctly calculates the ((N+1)/2)-th order statistic.\n        min_val = np.min(samples)\n        median_val = np.median(samples)\n        max_val = np.max(samples)\n\n        # Round the statistics to exactly six decimal places and store them.\n        all_results.append([\n            round(min_val, 6),\n            round(median_val, 6),\n            round(max_val, 6)\n        ])\n\n    # Format the results into the exact string format required.\n    # The output must be a single line.\n    # Example format: [[min1,med1,max1],[min2,med2,max2],...]\n    # Using .6f ensures that six decimal places are always shown.\n    formatted_cases = []\n    for res in all_results:\n        case_str = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\"\n        formatted_cases.append(case_str)\n    \n    final_output = f\"[{','.join(formatted_cases)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2403909"}, {"introduction": "现实世界中的许多概率分布，其累积分布函数（CDF）往往无法求得解析逆。本练习将向您展示逆变换采样方法的真正威力，即当解析解不存在时如何与数值方法相结合。您将为一个一维无限深势阱中粒子的量子态推导其概率密度，并使用数值求根算法来计算其CDF的逆，从而完成采样，这是计算科学家必备的一项高级实用技能 [@problem_id:2403893]。", "problem": "一个非相对论量子粒子被限制在区间 $[0,L]$ 上的一维无限深势阱中，势阱壁是完全刚性的。对于 $x \\in [0,L]$ 和整数 $n \\ge 1$，其归一化定态波函数由 $\\psi_n(x) = \\sqrt{\\frac{2}{L}} \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)$ 给出。考虑 $n = 2$ 的第一激发态，因此在 $[0,L]$ 上的概率密度为 $f(x) = \\lvert \\psi_2(x) \\rvert^2$。所有三角函数参数都必须以弧度为单位进行解释。\n\n任务：\n1. 从第一性原理出发，推导与 $f(x)$ 相关的累积分布函数 $F(x)$，其定义为 $F(x) = \\int_{0}^{x} f(t)\\,dt$，其中 $x \\in [0,L]$。证明 $F(x)$ 在 $[0,L]$ 上是严格单调递增的，因此在 $u \\in [0,1]$ 上存在唯一的逆函数 $G(u)$，使得 $F(G(u)) = u$。\n2. 构建一个程序，对下面列出的每个测试用例执行以下操作：\n   - 计算函数 $F(x)$ 及其逆函数 $G(u)$，使得对于任何 $u \\in [0,1]$，值 $x = G(u)$ 满足 $\\lvert F(x) - u \\rvert \\le 10^{-12}$。\n   - 使用为该测试用例指定的整数种子初始化的伪随机数生成器，生成 $N$ 个在开区间 $(0,1)$ 上均匀分布的独立伪随机变量 $u_1,\\dots,u_N$。\n   - 将均匀分布的变量转换为样本 $x_i = G(u_i)$，这些样本服从在 $[0,L]$ 上密度为 $f(x)$ 的分布。\n   - 计算样本的以下三个汇总统计量：\n     - 样本均值 $m_N = \\frac{1}{N}\\sum_{i=1}^{N} x_i$（以与 $L$ 相同的长度单位表示您的答案）。\n     - 样本二阶矩 $s_N^{(2)} = \\frac{1}{N}\\sum_{i=1}^{N} x_i^2$（以 $L$ 的长度单位的平方表示您的答案）。\n     - 针对目标累积分布函数 $F$ 的柯尔莫哥洛夫-斯米尔诺夫统计量 $D_N$，定义为\n       $$D_N = \\max\\!\\left(\\max_{1\\le i\\le N}\\left(\\frac{i}{N} - F(x_{(i)})\\right), \\max_{1\\le i\\le N}\\left(F(x_{(i)}) - \\frac{i-1}{N}\\right)\\right),$$\n       其中 $x_{(1)} \\le \\cdots \\le x_{(N)}$ 是样本的非递减排序。统计量 $D_N$ 是无量纲的。\n3. 您的程序必须生成单行输出，其中包含所有测试用例的结果，格式为逗号分隔的子列表构成的列表，每个子列表按顺序包含三个值 $[m_N, s_N^{(2)}, D_N]$。输出中的每个浮点结果必须四舍五入到 $6$ 位小数。例如，要求的总体格式是 `[[m_N,1, s^(2)_N,1, D_N,1], [m_N,2, s^(2)_N,2, D_N,2], ...]` 并且程序必须只打印一行包含此列表的内容，并如示例所示保留方括号和逗号。\n\n测试套件：\n- 用例 1：$L = 1.0$, $N = 1000$, 种子 $= 12345$。\n- 用例 2：$L = 5.0$, $N = 2000$, 种子 $= 20231102$。\n- 用例 3：$L = 2.0$, $N = 1$, 种子 $= 42$。\n\n角度单位说明：所有出现在三角函数内的角度都必须是弧度。\n\n物理单位：$m_N$ 以与 $L$ 相同的单位报告，$s_N^{(2)}$ 以该单位的平方报告，$D_N$ 为无量纲数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由子列表组成的逗号分隔列表，每个子列表的形式为 $[m_N,s_N^{(2)},D_N]$，并用方括号括起来，例如：`[[a,b,c],[d,e,f],[g,h,i]]`。", "solution": "该问题要求应用逆变换采样方法，从一个由一维无限深势阱中粒子的量子力学概率密度定义的分布中生成随机变量。步骤涉及概率密度函数和累积分布函数的解析推导，然后通过数值实现来生成样本并计算指定的统计量。该问题具有科学依据且定义明确。\n\n该系统是一个在区间 $[0, L]$ 上的无限深势阱中的粒子。对于整数量子数 $n \\ge 1$，定态波函数为 $\\psi_n(x) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{n\\pi x}{L}\\right)$。我们关心的是对应于 $n=2$ 的第一激发态。\n\n**1. 概率密度函数 (PDF)**\n\n概率密度函数 $f(x)$ 由波函数的模平方给出，即 $f(x) = |\\psi_2(x)|^2$。\n对于 $n=2$，波函数为：\n$$ \\psi_2(x) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{2\\pi x}{L}\\right) $$\n对应的 $x \\in [0, L]$ 上的概率密度函数为：\n$$ f(x) = \\left| \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{2\\pi x}{L}\\right) \\right|^2 = \\frac{2}{L} \\sin^2\\left(\\frac{2\\pi x}{L}\\right) $$\n使用三角函数的降幂恒等式 $\\sin^2(\\theta) = \\frac{1 - \\cos(2\\theta)}{2}$，我们可以将概率密度函数重写为：\n$$ f(x) = \\frac{2}{L} \\left( \\frac{1 - \\cos\\left(2 \\cdot \\frac{2\\pi x}{L}\\right)}{2} \\right) = \\frac{1}{L} \\left( 1 - \\cos\\left(\\frac{4\\pi x}{L}\\right) \\right) $$\n这种形式更便于积分。\n\n**2. 累积分布函数 (CDF)**\n\n累积分布函数 $F(x)$ 定义为概率密度函数从 $0$ 到 $x$ 的积分：\n$$ F(x) = \\int_{0}^{x} f(t) \\,dt = \\int_{0}^{x} \\frac{1}{L} \\left( 1 - \\cos\\left(\\frac{4\\pi t}{L}\\right) \\right) dt $$\n我们逐项进行积分：\n$$ F(x) = \\frac{1}{L} \\left[ \\int_{0}^{x} 1 \\,dt - \\int_{0}^{x} \\cos\\left(\\frac{4\\pi t}{L}\\right) dt \\right] $$\n$$ F(x) = \\frac{1}{L} \\left[ t - \\frac{L}{4\\pi} \\sin\\left(\\frac{4\\pi t}{L}\\right) \\right]_{0}^{x} $$\n代入积分上下限可得：\n$$ F(x) = \\frac{1}{L} \\left[ \\left( x - \\frac{L}{4\\pi} \\sin\\left(\\frac{4\\pi x}{L}\\right) \\right) - \\left( 0 - \\frac{L}{4\\pi} \\sin(0) \\right) \\right] $$\n$$ F(x) = \\frac{x}{L} - \\frac{1}{4\\pi} \\sin\\left(\\frac{4\\pi x}{L}\\right) $$\n作为检验，我们计算 CDF 在边界处的值：$F(0) = 0$ 且 $F(L) = \\frac{L}{L} - \\frac{1}{4\\pi}\\sin(4\\pi) = 1 - 0 = 1$。这证实了函数的归一性。\n\n**3. 累积分布函数的逆函数存在性**\n\n为了应用逆变换采样，CDF $F(x)$ 必须有唯一的逆函数。如果一个连续函数是严格单调的，那么它就有唯一的逆函数。我们可以通过检查其导数来证明 $F(x)$ 在 $[0, L]$ 上是严格单调递增的。根据微积分基本定理，$F'(x) = f(x)$。\n$$ F'(x) = f(x) = \\frac{2}{L} \\sin^2\\left(\\frac{2\\pi x}{L}\\right) $$\n项 $\\frac{2}{L}$ 是正的。项 $\\sin^2(\\theta)$ 对所有实数 $\\theta$ 都是非负的。它仅在 $\\sin(\\theta)=0$ 时等于 $0$。对于 $\\theta = \\frac{2\\pi x}{L}$ 且 $x \\in [0, L]$，这种情况发生在 $x=0$、$x=L/2$ 和 $x=L$ 处。\n由于对所有 $x \\in [0, L]$ 都有 $F'(x) \\ge 0$，且 $F'(x)$ 仅在有限个孤立点上为零，因此函数 $F(x)$ 在整个区间 $[0, L]$ 上是严格单调递增的。因此，对于 $u \\in [0, 1]$，存在唯一的逆函数 $G(u) = F^{-1}(u)$。\n\n**4. 逆变换采样算法**\n\n逆变换方法包括两个步骤：\n1. 从 $[0, 1]$ 上的均匀分布中生成一个随机变量 $u$，记为 $u \\sim U(0, 1)$。\n2. 通过应用逆 CDF 计算样本 $x$：$x = G(u) = F^{-1}(u)$。\n\n我们必须求解关于 $x$ 的方程是 $F(x) = u$，即：\n$$ \\frac{x}{L} - \\frac{1}{4\\pi} \\sin\\left(\\frac{4\\pi x}{L}\\right) = u $$\n这是一个超越方程，无法用简单的闭合形式求解 $x$。我们必须使用数值求根算法。对于给定的 $u$，我们在区间 $[0, L]$ 上寻找函数 $h(x) = F(x) - u = 0$ 的根 $x$。因为对于 $u \\in (0, 1)$，有 $h(0) = F(0) - u = -u < 0$ 和 $h(L) = F(L) - u = 1 - u > 0$，所以根被限定在 $[0, L]$ 内。像 Brent 方法这样鲁棒且高效的算法适合于将根找到所需的精度。\n\n**5. 汇总统计量的计算**\n\n对于通过此方法生成的 $N$ 个样本集合 $\\{x_1, x_2, \\ldots, x_N\\}$，我们计算以下统计量：\n- **样本均值 ($m_N$)**：样本的算术平均值。\n$$ m_N = \\frac{1}{N} \\sum_{i=1}^{N} x_i $$\n- **样本二阶矩 ($s_N^{(2)}$)**：样本平方的算术平均值。\n$$ s_N^{(2)} = \\frac{1}{N} \\sum_{i=1}^{N} x_i^2 $$\n- **柯尔莫哥洛夫-斯米尔诺夫 (KS) 统计量 ($D_N$)**：此统计量衡量样本的经验分布函数 (EDF) 与理论累积分布函数 $F(x)$ 之间的最大距离。对于一个已排序的样本集 $x_{(1)} \\le x_{(2)} \\le \\cdots \\le x_{(N)}$，该统计量定义为：\n$$ D_N = \\max\\left( \\max_{1 \\le i \\le N}\\left(\\frac{i}{N} - F(x_{(i)})\\right), \\max_{1 \\le i \\le N}\\left(F(x_{(i)}) - \\frac{i-1}{N}\\right) \\right) $$\n算法将对每个测试用例进行实现，使用指定的种子生成 $N$ 个样本，计算这三个统计量，并按要求的格式报告结果。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the inverse transform sampling problem for a particle in a box.\n    \"\"\"\n    test_cases = [\n        # (L, N, seed)\n        (1.0, 1000, 12345),\n        (5.0, 2000, 20231102),\n        (2.0, 1, 42),\n    ]\n\n    def F_cdf(x, L):\n        \"\"\"\n        Computes the theoretical cumulative distribution function (CDF) F(x).\n        F(x) = x/L - sin(4*pi*x/L) / (4*pi)\n        \"\"\"\n        arg = 4.0 * np.pi * x / L\n        return (x / L) - (np.sin(arg) / (4.0 * np.pi))\n\n    all_results = []\n\n    for L, N, seed in test_cases:\n        # 1. Initialize the pseudorandom number generator with the specified seed.\n        rng = np.random.default_rng(seed)\n\n        # 2. Generate N independent pseudorandom variates uniformly distributed on (0,1).\n        u_samples = rng.uniform(0.0, 1.0, size=N)\n\n        # 3. For each uniform variate u, find the corresponding x by inverting the CDF.\n        # This requires solving F(x) - u = 0 for x.\n        x_samples = np.zeros(N)\n        for i, u in enumerate(u_samples):\n            # The function to find the root of.\n            func_to_solve = lambda x: F_cdf(x, L) - u\n            \n            # Use Brent's method to find the root in the interval [0, L].\n            # The root is guaranteed to be in this interval as F(0)=0 and F(L)=1.\n            # h(0) = -u < 0 and h(L) = 1-u > 0 for u in (0,1).\n            x_samples[i] = brentq(func_to_solve, 0.0, L)\n\n        # 4. Compute the required summary statistics.\n        # Sample mean\n        m_N = np.mean(x_samples)\n\n        # Sample second moment\n        s2_N = np.mean(np.square(x_samples))\n\n        # Kolmogorov-Smirnov statistic\n        if N > 0:\n            x_sorted = np.sort(x_samples)\n            F_values = F_cdf(x_sorted, L)\n            \n            # i/N for i=1,...,N\n            i_over_N = np.arange(1, N + 1) / N\n            # (i-1)/N for i=1,...,N\n            i_minus_1_over_N = np.arange(0, N) / N\n            \n            # D_N = max(max(i/N - F(x_i)), max(F(x_i) - (i-1)/N))\n            max1 = np.max(i_over_N - F_values)\n            max2 = np.max(F_values - i_minus_1_over_N)\n            D_N = np.max([max1, max2])\n        else:\n            # Although not in the test suite, handle the N=0 case gracefully.\n            m_N, s2_N, D_N = 0.0, 0.0, 0.0\n\n        all_results.append([m_N, s2_N, D_N])\n\n    # 5. Format the final output string exactly as specified.\n    # Each sublist is formatted, then joined by commas, then enclosed in brackets.\n    sublist_strs = [f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in all_results]\n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2403893"}]}