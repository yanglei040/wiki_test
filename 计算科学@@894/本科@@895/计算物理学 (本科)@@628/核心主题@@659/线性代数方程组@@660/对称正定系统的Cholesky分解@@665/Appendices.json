{"hands_on_practices": [{"introduction": "Cholesky 分解不仅是一种计算方法，更是检验对称矩阵是否正定的“试金石”。本练习将指导你从头实现该分解过程，并亲眼见证当一个矩阵不再满足正定条件时，分解算法将如何以及为何会失败 [@problem_id:2376407]。通过探索一个跨越正定与非正定边界的参数化矩阵，你将对这一核心判据建立起深刻而直观的理解。", "problem": "您需要从第一性原理出发，实现并分析用于对称正定 (SPD) 系统的 Cholesky 分解。一个 $n \\times n$ 的实矩阵 $A$ 是对称正定 (SPD) 的，如果 $A = A^{\\mathsf{T}}$ 且对于所有非零向量 $x \\in \\mathbb{R}^n$ 都有 $x^{\\mathsf{T}} A x > 0$。一个经过充分检验的数学事实是，一个 SPD 矩阵允许唯一的 Cholesky 分解 $A = L L^{\\mathsf{T}}$，其中 $L$ 是下三角矩阵，并且 $L$ 的所有对角线元素都严格为正。另一个经过充分检验的事实 (Sylvester 判据) 是，一个对称矩阵是 SPD 的，当且仅当其所有顺序主子式都为正。\n\n您的任务：\n\n1. 实现一个例程，尝试对给定的对称矩阵 $A$ 计算 Cholesky 分解 $A = L L^{\\mathsf{T}}$，不进行任何主元选择。该例程必须显式检查每个计算出的对角主元平方值的正性，并在任何步骤中出现非正值时宣告失败。实现不得依赖于黑盒的 SPD 检查；它应纯粹根据计算出的中间量来检测失败。\n\n2. 使用以下对称矩阵的参数族：\n   $$ A(r) = \\begin{bmatrix} 1 & r \\\\ r & 1 \\end{bmatrix}, $$\n   其中 $r \\in \\mathbb{R}$。这个矩阵族包含了随着单个非对角元素 $r$ 的微小变化而从 SPD 变为非 SPD 的矩阵。在一组参数值的测试集上评估您的例程\n   $$ r \\in \\{\\, 0.9,\\; 0.999999,\\; 1.0,\\; 1.000001 \\,\\}. $$\n   为每个测试记录一个布尔值，指示 Cholesky 例程是成功 (返回 $\\,\\text{True}\\,$) 还是失败 (返回 $\\,\\text{False}\\,$)。\n\n3. 作为一个额外的“成功路径”覆盖案例，测试以下已根据 Sylvester 判据确认为 SPD 的固定的 $3 \\times 3$ 对称矩阵：\n   $$ B = \\begin{bmatrix} 4 & 1 & 1 \\\\ 1 & 3 & 1 \\\\ 1 & 1 & 2 \\end{bmatrix}. $$\n   记录一个布尔值，指示 Cholesky 例程在处理矩阵 $B$ 时是否成功。\n\n4. 输出规范。您的程序必须生成单行输出，其中包含一个 Python 风格的列表字面量，内含所有测试的布尔值，顺序如下：四个 $A(r)$ 案例，$r$ 分别等于 $0.9$, $0.999999$, $1.0$, $1.000001$，然后是单个案例 $B$。例如，所需格式为：\n   $$ [\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5] $$\n   其中每个 $\\text{result}_i$ 是 $\\text{True}$ 或 $\\text{False}$。\n\n注意事项和约束：\n\n- 请将您的推理建立在 SPD 矩阵的定义和上文所述的 Cholesky 分解存在条件之上。不要假设任何未说明的属性。\n- 不涉及物理单位。\n- 不适用角度单位。\n- 唯一可接受的输出是按所述确切顺序排列的单行布尔值列表。", "solution": "所陈述的问题定义明确、自成体系且科学上合理，它基于数值线性代数的既定原则。因此，该问题是有效的，我们进而提供一个完整的解决方案。任务要求实现一个 Cholesky 分解例程，并将其应用于一组指定的测试矩阵。\n\n基本原理是将一个对称正定 (SPD) 矩阵 $A$ 分解为乘积 $A = LL^{\\mathsf{T}}$，其中 $L$ 是一个下三角矩阵。$L$ 的元素（记作 $L_{ij}$）可以直接从这个方程计算得出。对于一个 $n \\times n$ 矩阵 $A$，元素 $A_{ij}$ 由 $L$ 的第 $i$ 行与 $L^{\\mathsf{T}}$ 的第 $j$ 列（即 $L$ 的第 $j$ 行）的点积给出：\n$$ A_{ij} = \\sum_{k=1}^{j} L_{ik} L_{jk} \\quad \\text{for } i \\ge j $$\n由于 $A$ 是对称的， $A_{ij} = A_{ji}$，我们只需要计算 $i \\ge j$ 的 $L_{ij}$。\n\n该算法按顺序计算 $L$ 的各列，从 $j=1$ 到 $j=n$。对于每一列 $j$，我们首先计算对角元素 $L_{jj}$，然后计算 $i > j$ 的非对角元素 $L_{ij}$。\n\n考虑对角元素 $A_{jj}$：\n$$ A_{jj} = \\sum_{k=1}^{j} L_{jk}^2 = \\left( \\sum_{k=1}^{j-1} L_{jk}^2 \\right) + L_{jj}^2 $$\n由此，我们解出 $L$ 的对角元素的平方：\n$$ L_{jj}^2 = A_{jj} - \\sum_{k=1}^{j-1} L_{jk}^2 $$\n为了使 Cholesky 分解存在且得到一个对角线元素为正的实值矩阵 $L$，在每一步 $j$ 中，项 $L_{jj}^2$ 都必须严格为正。如果对于任何 $j$，$L_{jj}^2 \\le 0$，则该矩阵不是正定的，分解失败。这是我们的例程必须检查的条件。如果 $L_{jj}^2 > 0$，我们有 $L_{jj} = \\sqrt{A_{jj} - \\sum_{k=1}^{j-1} L_{jk}^2}$。\n\n接下来，考虑 $i > j$ 的非对角元素 $A_{ij}$：\n$$ A_{ij} = \\sum_{k=1}^{j} L_{ik} L_{jk} = \\left( \\sum_{k=1}^{j-1} L_{ik} L_{jk} \\right) + L_{ij} L_{jj} $$\n求解 $L_{ij}$，我们得到：\n$$ L_{ij} = \\frac{1}{L_{jj}} \\left( A_{ij} - \\sum_{k=1}^{j-1} L_{ik} L_{jk} \\right) $$\n只要 $L_{jj} \\ne 0$，这个计算就是可能的，而如果 $L_{jj}^2 > 0$，这一点就得到了保证。\n\n我们现在基于此算法分析指定的测试案例。\n\n1.  **参数族 $A(r) = \\begin{bmatrix} 1 & r \\\\ r & 1 \\end{bmatrix}$**\n\n    我们将该算法应用于这个 $2 \\times 2$ 矩阵。\n    \n    对于列 $j=1$：\n    对角元素的平方为 $L_{11}^2 = A_{11} = 1$。因为 $1 > 0$，此步骤成功，我们得到 $L_{11} = 1$。\n    非对角元素为 $L_{21} = \\frac{1}{L_{11}} (A_{21}) = \\frac{r}{1} = r$。\n    \n    对于列 $j=2$：\n    对角元素的平方为 $L_{22}^2 = A_{22} - L_{21}^2 = 1 - r^2$。\n    当且仅当该量严格为正时，分解成功，即 $1 - r^2 > 0$，这等价于 $r^2 < 1$，或 $|r| < 1$。\n\n    我们评估指定的 $r$ 值：\n    - 对于 $r = 0.9$：$L_{22}^2 = 1 - (0.9)^2 = 1 - 0.81 = 0.19 > 0$。例程成功。结果：$\\text{True}$。\n    - 对于 $r = 0.999999$：$L_{22}^2 = 1 - (0.999999)^2 > 0$。该值为正，尽管很小。例程成功。结果：$\\text{True}$。\n    - 对于 $r = 1.0$：$L_{22}^2 = 1 - (1.0)^2 = 0$。这不严格为正。例程必须失败。结果：$\\text{False}$。\n    - 对于 $r = 1.000001$：$L_{22}^2 = 1 - (1.000001)^2 < 0$。例程必须失败。结果：$\\text{False}$。\n\n2.  **固定矩阵 $B = \\begin{bmatrix} 4 & 1 & 1 \\\\ 1 & 3 & 1 \\\\ 1 & 1 & 2 \\end{bmatrix}$**\n\n    我们将该算法应用于这个 $3 \\times 3$ 矩阵。\n\n    对于列 $j=1$：\n    $L_{11}^2 = B_{11} = 4$。因为 $4 > 0$，我们继续。$L_{11} = 2$。\n    $L_{21} = B_{21} / L_{11} = 1/2$。\n    $L_{31} = B_{31} / L_{11} = 1/2$。\n\n    对于列 $j=2$：\n    $L_{22}^2 = B_{22} - L_{21}^2 = 3 - (1/2)^2 = 3 - 1/4 = 11/4$。因为 $11/4 > 0$，我们继续。$L_{22} = \\sqrt{11}/2$。\n    $L_{32} = \\frac{1}{L_{22}}(B_{32} - L_{31}L_{21}) = \\frac{1}{\\sqrt{11}/2}(1 - (1/2)(1/2)) = \\frac{2}{\\sqrt{11}}(3/4) = \\frac{3}{2\\sqrt{11}}$。\n\n    对于列 $j=3$：\n    $L_{33}^2 = B_{33} - (L_{31}^2 + L_{32}^2) = 2 - \\left( (1/2)^2 + \\left(\\frac{3}{2\\sqrt{11}}\\right)^2 \\right) = 2 - \\left( \\frac{1}{4} + \\frac{9}{44} \\right) = 2 - \\left( \\frac{11}{44} + \\frac{9}{44} \\right) = 2 - \\frac{20}{44} = 2 - \\frac{5}{11} = \\frac{17}{11}$。\n    因为 $17/11 > 0$，最后一步成功。\n\n    由于所有对角主元的平方都严格为正，矩阵 $B$ 的 Cholesky 分解成功。结果：$\\text{True}$。\n\n因此，五个测试案例按指定顺序的布尔结果序列为：$\\text{True}$, $\\text{True}$, $\\text{False}$, $\\text{False}$, $\\text{True}$。最终答案中的程序将实现此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Cholesky factorization from first principles,\n    tests it on several matrices, and prints the results.\n    \"\"\"\n\n    def cholesky_factorization_attempt(A: np.ndarray) -> bool:\n        \"\"\"\n        Attempts to compute the Cholesky factorization of a symmetric matrix A.\n\n        The routine follows the standard column-wise algorithm. It explicitly\n        checks for the strict positivity of the squared diagonal pivots (L_jj^2).\n        If a non-positive pivot is encountered, the matrix is not positive-definite,\n        and the factorization fails.\n\n        Args:\n            A (np.ndarray): The n x n symmetric matrix to factorize.\n\n        Returns:\n            bool: True if the factorization succeeds, False otherwise.\n        \"\"\"\n        n = A.shape[0]\n        L = np.zeros_like(A, dtype=float)\n\n        for j in range(n):\n            # Compute the sum of squares of elements in the j-th row of L up to column j-1.\n            # This corresponds to sum_{k=0}^{j-1} L[j, k]^2\n            s1 = np.dot(L[j, :j], L[j, :j])\n\n            # Compute the squared diagonal element L[j, j]^2.\n            squared_pivot = A[j, j] - s1\n\n            # The core condition for positive-definiteness in Cholesky factorization:\n            # The pivot must be strictly positive.\n            if squared_pivot <= 0:\n                return False\n\n            L[j, j] = np.sqrt(squared_pivot)\n\n            # Compute the elements in the j-th column below the diagonal.\n            if j < n - 1:\n                # This corresponds to the sum sum_{k=0}^{j-1} L[i, k] * L[j, k] for each i > j.\n                s2 = np.dot(L[j + 1:n, :j], L[j, :j])\n                L[j + 1:n, j] = (A[j + 1:n, j] - s2) / L[j, j]\n\n        return True\n\n    # 1. Define the parametric test cases A(r).\n    r_values = [0.9, 0.999999, 1.0, 1.000001]\n    test_matrices = [np.array([[1.0, r], [r, 1.0]]) for r in r_values]\n\n    # 2. Define the fixed 3x3 test case B.\n    B_matrix = np.array([\n        [4.0, 1.0, 1.0],\n        [1.0, 3.0, 1.0],\n        [1.0, 1.0, 2.0]\n    ])\n    test_matrices.append(B_matrix)\n\n    # 3. Evaluate the routine on all test cases.\n    results = []\n    for matrix in test_matrices:\n        success = cholesky_factorization_attempt(matrix)\n        results.append(success)\n\n    # 4. Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2376407"}, {"introduction": "Cholesky 分解最主要的应用之一是高效求解形如 $A x = b$ 的线性方程组，其中 $A$ 是对称正定矩阵。在掌握了分解算法本身之后，本练习将引导你构建一个完整的求解器，整合前向替换和后向替换两个关键步骤 [@problem_id:2379908]。通过实现从输入矩阵 $A$ 和向量 $b$ 到最终解 $x$ 的完整流程，你将巩固对该方法如何为众多物理和工程问题提供高效稳定解决方案的理解。", "problem": "您将实现并测试一个程序，该程序使用 Cholesky 分解求解对称正定线性系统。在计算物理中，许多椭圆偏微分方程的离散化会产生形如 $A x = b$ 的线性系统，其中 $A$ 是对称正定的。一个基本特征是，$A$ 是对称正定的当且仅当对于每一个非零向量 $x$ 都有 $x^{\\mathsf{T}} A x > 0$。在此条件下，二次能量 $E(x) = \\tfrac{1}{2} x^{\\mathsf{T}} A x - b^{\\mathsf{T}} x$ 是严格凸的，并有满足正规方程 $A x = b$ 的唯一极小值点。您的任务是从基本原理出发，构建一个利用此结构的求解器。\n\n实现一个函数，该函数在给定一个对称正定矩阵 $A$ 和一个向量 $b$ 的情况下，通过以下步骤返回解 $x$：\n- 计算 Cholesky 分解 $A = L L^{\\mathsf{T}}$，其中 $L$ 是具有严格正对角线元素的下三角矩阵，过程中不调用任何用于 Cholesky 分解的库例程。\n- 通过前向代入求解下三角系统 $L y = b$。\n- 通过回代求解上三角系统 $L^{\\mathsf{T}} x = y$。\n\n实现要求：\n- 输入 $A$ 必须是实数方阵且对称。您的实现必须在数值上检查其对称性。\n- 如果 $A$ 不是正定的，您的分解过程应能通过检测非正主元来发现这一点，并发出错误信号。\n- 使用双精度浮点运算。\n- 不要调用任何内置的 Cholesky 求解器；使用基本运算实现分解和三角系统求解。\n\n测试套件：\n您的程序必须对以下七个测试用例运行求解器，并汇总结果。\n\n- 用例 $1$ (小型，良态)：\n  $$A_1 = \\begin{bmatrix} 4 & 1 & 1 \\\\ 1 & 3 & 0 \\\\ 1 & 0 & 2 \\end{bmatrix}, \\quad x^{\\star}_1 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}, \\quad b_1 = A_1 x^{\\star}_1.$$\n  报告最大绝对误差 $e_1 = \\|x_1 - x^{\\star}_1\\|_{\\infty}$，格式为浮点数。\n\n- 用例 $2$ (单位矩阵)：\n  $$A_2 = I_{5}, \\quad x^{\\star}_2 = \\begin{bmatrix} -2 \\\\ 0.5 \\\\ 3.5 \\\\ 0 \\\\ -1 \\end{bmatrix}, \\quad b_2 = x^{\\star}_2.$$\n  报告 $e_2 = \\|x_2 - x^{\\star}_2\\|_{\\infty}$。\n\n- 用例 $3$ (大尺度缩放的对角矩阵)：\n  $$A_3 = \\operatorname{diag}\\!\\left(10^{-3},\\,10^{-1},\\,1,\\,10,\\,10^{3}\\right), \\quad x^{\\star}_3 = \\begin{bmatrix} 1 \\\\ -1 \\\\ 2 \\\\ -2 \\\\ 0.5 \\end{bmatrix}, \\quad b_3 = A_3 x^{\\star}_3.$$\n  报告 $e_3 = \\|x_3 - x^{\\star}_3\\|_{\\infty}$。\n\n- 用例 $4$ (带 Dirichlet 边界的一维泊松算子，带状对称正定)：\n  对于 $n = 6$，令 $A_4 \\in \\mathbb{R}^{n \\times n}$ 为三对角矩阵，其主对角线元素为 $2$，第一亚对角线和第一超对角线元素为 $-1$，即，\n  $$A_4 = \\begin{bmatrix}\n  2 & -1 & 0 & 0 & 0 & 0 \\\\\n  -1 & 2 & -1 & 0 & 0 & 0 \\\\\n  0 & -1 & 2 & -1 & 0 & 0 \\\\\n  0 & 0 & -1 & 2 & -1 & 0 \\\\\n  0 & 0 & 0 & -1 & 2 & -1 \\\\\n  0 & 0 & 0 & 0 & -1 & 2\n  \\end{bmatrix}.$$\n  取 $x^{\\star}_4 = \\mathbf{1} \\in \\mathbb{R}^{6}$ (所有元素均为 1)，且 $b_4 = A_4 x^{\\star}_4$。报告 $e_4 = \\|x_4 - x^{\\star}_4\\|_{\\infty}$。\n\n- 用例 $5$ (随机对称正定)：\n  按如下方式构造 $A_5$。设置一个确定性种子，生成一个元素为独立标准正态分布的矩阵 $M \\in \\mathbb{R}^{6 \\times 6}$，并令\n  $$A_5 = M^{\\mathsf{T}} M + 10^{-3} I_{6}.$$\n  选择一个元素为独立标准正态分布的向量 $x^{\\star}_5 \\in \\mathbb{R}^{6}$，并设置 $b_5 = A_5 x^{\\star}_5$。报告 $e_5 = \\|x_5 - x^{\\star}_5\\|_{\\infty}$。\n\n- 用例 $6$ (病态对称正定，希尔伯特矩阵)：\n  令 $A_6 \\in \\mathbb{R}^{5 \\times 5}$ 为希尔伯特矩阵，其元素为 $(A_6)_{ij} = 1/(i+j+1)$，其中索引 $i,j \\in \\{0,1,2,3,4\\}$ 从零开始。令\n  $$x^{\\star}_6 = \\begin{bmatrix} 1 \\\\ -1 \\\\ 1 \\\\ -1 \\\\ 1 \\end{bmatrix}, \\quad b_6 = A_6 x^{\\star}_6.$$\n  报告 $e_6 = \\|x_6 - x^{\\star}_6\\|_{\\infty}$。\n\n- 用例 $7$ (对称但非正定)：\n  $$A_7 = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}, \\quad b_7 = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}.$$\n  运行您的求解器，并报告一个布尔值 $r_7$。如果您的求解器正确检测到非正定性并发出错误信号，则该值为 $\\text{True}$，否则为 $\\text{False}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，列表中的条目按上述用例的顺序排列，即 $[e_1,e_2,e_3,e_4,e_5,e_6,r_7]$。例如，一个示意格式为 [$r_1,r_2,r_3,r_4,r_5,r_6,r_7$]，其中 $r_k$ 表示用例 $k$ 的结果。\n\n用例 1 到 6 的最终输出是浮点数。用例 7 的最终输出是布尔值。此问题不涉及角度或物理单位；所有量均为无量纲实数。", "solution": "我们从对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的定义开始：$A$ 是对称的 ($A = A^{\\mathsf{T}}$) 并且对于所有非零 $x \\in \\mathbb{R}^{n}$ 满足 $x^{\\mathsf{T}} A x > 0$。在计算物理中，此类矩阵作为离散化椭圆算子的刚度矩阵而出现。考虑二次能量\n$$\nE(x) = \\tfrac{1}{2} x^{\\mathsf{T}} A x - b^{\\mathsf{T}} x.\n$$\n由于 $A$ 是正定的，$E$ 是严格凸且强制的。唯一的极小值点 $x^{\\star}$ 满足一阶最优性条件 $\\nabla E(x) = A x - b = 0$，这等价于线性系统 $A x = b$。\n\nCholesky 分解利用正定性来保证分解形式\n$$\nA = L L^{\\mathsf{T}},\n$$\n的存在性和唯一性，其中 $L$ 是具有严格正对角线元素的下三角矩阵。该分解可以通过一个每次处理 $A$ 一列的构造性算法来计算。其核心等式来自于按分量展开 $A = L L^{\\mathsf{T}}$。对于 $k \\in \\{0,\\dots,n-1\\}$，可写为\n$$\nA_{kk} = \\sum_{j=0}^{k} L_{kj}^{2} \\quad \\text{以及} \\quad A_{ik} = \\sum_{j=0}^{k} L_{ij} L_{kj} \\quad \\text{对于 } i > k.\n$$\n减去先前已计算条目的贡献，可得到递推公式\n$$\nL_{kk} = \\sqrt{A_{kk} - \\sum_{j=0}^{k-1} L_{kj}^{2}}, \\quad\nL_{ik} = \\frac{A_{ik} - \\sum_{j=0}^{k-1} L_{ij} L_{kj}}{L_{kk}} \\quad \\text{对于 } i = k+1,\\dots,n-1.\n$$\n根据正定性，平方根下的项是严格为正的，这确保了实数平方根的良定义性和严格为正的主元。\n\n一旦计算出 $L$，求解 $A x = b$ 就简化为两个三角系统的求解：\n- 前向代入求解 $L y = b$。对于 $i = 0,\\dots,n-1$：\n$$\ny_i = \\frac{1}{L_{ii}} \\left( b_i - \\sum_{j=0}^{i-1} L_{ij} y_j \\right).\n$$\n- 回代求解 $L^{\\mathsf{T}} x = y$。对于 $i = n-1,\\dots,0$：\n$$\nx_i = \\frac{1}{L_{ii}} \\left( y_i - \\sum_{j=i+1}^{n-1} L_{ji} x_j \\right).\n$$\n\n算法设计：\n- 验证 $A$ 是方阵且数值对称；一个实用的检查是 $\\|A - A^{\\mathsf{T}}\\|_{\\infty}$ 是否小于机器精度与 $\\|A\\|_{\\infty}$ 的乘积的某个小倍数。\n- 使用上述递推公式执行 Cholesky 分解。如果在任何步骤中，计算出的主元 $A_{kk} - \\sum_{j=0}^{k-1} L_{kj}^{2}$ 是非正的（例如，在数值容差内小于或等于零），则声明 $A$ 不是正定矩阵并发出错误信号。\n- 使用上述公式执行前向代入和回代。\n- 对于每个对称正定测试用例，计算最大绝对误差 $e = \\|x - x^{\\star}\\|_{\\infty} = \\max_i |x_i - x^{\\star}_i|$。\n- 对于对称但非正定的测试用例，捕获发出的错误并报告一个布尔值以指示检测成功。\n\n基本原理与数值考量：\n- 不需要主元选择：对于对称正定矩阵，无主元选择的 Cholesky 分解在浮点运算中是后向稳定的，并且在精确算术中保证主元为正。\n- 分解的计算复杂度为 $\\mathcal{O}(n^{3}/3)$ 次浮点运算，三角系统求解的复杂度为 $\\mathcal{O}(n^{2})$。\n- 该测试套件涵盖了良态小型系统、平凡的单位矩阵、大尺度缩放的对角系统、椭圆算子典型的带状系统、随机对称正定系统，以及一个用于探究数值稳健性的病态希尔伯特矩阵。最后一个测试确保求解器能正确检测出违反了正定性的情况。\n\n程序实现了这些步骤，没有调用库中的 Cholesky 例程，完全按照规定构造了每个测试用例，计算了误差度量 $e_1,\\dots,e_6$ 和布尔值 $r_7$，并打印出包含列表 $[e_1,e_2,e_3,e_4,e_5,e_6,r_7]$ 的单行结果。", "answer": "```python\nimport numpy as np\n\ndef cholesky_solve(A: np.ndarray, b: np.ndarray, symmetry_tol: float = 1e-12) -> np.ndarray:\n    \"\"\"\n    Solve A x = b for symmetric positive definite A using Cholesky factorization A = L L^T,\n    followed by forward and back substitution. Raises ValueError if A is not SPD.\n\n    Parameters:\n        A (np.ndarray): Real symmetric positive definite matrix of shape (n, n).\n        b (np.ndarray): Right-hand side vector of shape (n,).\n        symmetry_tol (float): Tolerance for numerical symmetry check.\n\n    Returns:\n        x (np.ndarray): Solution vector of shape (n,).\n    \"\"\"\n    A = np.array(A, dtype=np.float64, copy=True)\n    b = np.array(b, dtype=np.float64, copy=False)\n    n = A.shape[0]\n\n    if A.ndim != 2 or A.shape[1] != n:\n        raise ValueError(\"Matrix A must be square.\")\n    if b.shape != (n,):\n        raise ValueError(\"Vector b must have shape (n,).\")\n\n    # Symmetry check\n    if not np.allclose(A, A.T, atol=symmetry_tol, rtol=0.0):\n        raise ValueError(\"Matrix A is not symmetric within the given tolerance.\")\n\n    # Cholesky factorization: compute lower-triangular L such that A = L L^T\n    L = np.zeros_like(A)\n    for k in range(n):\n        # Compute diagonal element\n        if k == 0:\n            sumsq = 0.0\n        else:\n            sumsq = float(np.dot(L[k, :k], L[k, :k]))\n        diag = A[k, k] - sumsq\n        if not np.isfinite(diag) or diag <= 0.0:\n            raise ValueError(\"Matrix A is not positive definite (nonpositive pivot encountered).\")\n        Lkk = np.sqrt(diag)\n        L[k, k] = Lkk\n\n        # Compute subdiagonal elements in column k\n        if k < n - 1:\n            # Vectorized computation of the remaining entries in column k\n            for i in range(k + 1, n):\n                if k == 0:\n                    cross = 0.0\n                else:\n                    cross = float(np.dot(L[i, :k], L[k, :k]))\n                L[i, k] = (A[i, k] - cross) / Lkk\n\n    # Forward substitution: solve L y = b\n    y = np.zeros(n, dtype=np.float64)\n    for i in range(n):\n        if i == 0:\n            acc = 0.0\n        else:\n            acc = float(np.dot(L[i, :i], y[:i]))\n        y[i] = (b[i] - acc) / L[i, i]\n\n    # Back substitution: solve L^T x = y\n    x = np.zeros(n, dtype=np.float64)\n    for i in range(n - 1, -1, -1):\n        if i == n - 1:\n            acc = 0.0\n        else:\n            acc = float(np.dot(L[i + 1:, i], x[i + 1:]))\n        x[i] = (y[i] - acc) / L[i, i]\n\n    return x\n\n\ndef make_tridiagonal_poisson(n: int) -> np.ndarray:\n    \"\"\"Construct the 1D Poisson tridiagonal SPD matrix with 2 on diagonal and -1 on off-diagonals.\"\"\"\n    A = np.zeros((n, n), dtype=np.float64)\n    diag = 2.0\n    off = -1.0\n    for i in range(n):\n        A[i, i] = diag\n        if i + 1 < n:\n            A[i, i + 1] = off\n            A[i + 1, i] = off\n    return A\n\n\ndef make_hilbert(n: int) -> np.ndarray:\n    \"\"\"Construct the Hilbert matrix of size n with zero-based indexing: A[i,j] = 1 / (i + j + 1).\"\"\"\n    i = np.arange(n, dtype=np.float64).reshape(-1, 1)\n    j = np.arange(n, dtype=np.float64).reshape(1, -1)\n    return 1.0 / (i + j + 1.0)\n\n\ndef solve():\n    results = []\n\n    # Case 1\n    A1 = np.array([[4.0, 1.0, 1.0],\n                   [1.0, 3.0, 0.0],\n                   [1.0, 0.0, 2.0]], dtype=np.float64)\n    x1_true = np.array([1.0, 2.0, 3.0], dtype=np.float64)\n    b1 = A1 @ x1_true\n    x1 = cholesky_solve(A1, b1)\n    e1 = float(np.max(np.abs(x1 - x1_true)))\n    results.append(e1)\n\n    # Case 2\n    A2 = np.eye(5, dtype=np.float64)\n    x2_true = np.array([-2.0, 0.5, 3.5, 0.0, -1.0], dtype=np.float64)\n    b2 = x2_true.copy()\n    x2 = cholesky_solve(A2, b2)\n    e2 = float(np.max(np.abs(x2 - x2_true)))\n    results.append(e2)\n\n    # Case 3\n    A3 = np.diag([1e-3, 1e-1, 1.0, 10.0, 1e3]).astype(np.float64)\n    x3_true = np.array([1.0, -1.0, 2.0, -2.0, 0.5], dtype=np.float64)\n    b3 = A3 @ x3_true\n    x3 = cholesky_solve(A3, b3)\n    e3 = float(np.max(np.abs(x3 - x3_true)))\n    results.append(e3)\n\n    # Case 4\n    n4 = 6\n    A4 = make_tridiagonal_poisson(n4)\n    x4_true = np.ones(n4, dtype=np.float64)\n    b4 = A4 @ x4_true\n    x4 = cholesky_solve(A4, b4)\n    e4 = float(np.max(np.abs(x4 - x4_true)))\n    results.append(e4)\n\n    # Case 5\n    np.random.seed(7)\n    M = np.random.randn(6, 6).astype(np.float64)\n    A5 = M.T @ M + 1e-3 * np.eye(6, dtype=np.float64)\n    x5_true = np.random.randn(6).astype(np.float64)\n    b5 = A5 @ x5_true\n    x5 = cholesky_solve(A5, b5)\n    e5 = float(np.max(np.abs(x5 - x5_true)))\n    results.append(e5)\n\n    # Case 6\n    A6 = make_hilbert(5)\n    x6_true = np.array([1.0, -1.0, 1.0, -1.0, 1.0], dtype=np.float64)\n    b6 = A6 @ x6_true\n    x6 = cholesky_solve(A6, b6)\n    e6 = float(np.max(np.abs(x6 - x6_true)))\n    results.append(e6)\n\n    # Case 7 (non-SPD detection)\n    A7 = np.array([[0.0, 1.0],\n                   [1.0, 0.0]], dtype=np.float64)\n    b7 = np.array([1.0, 2.0], dtype=np.float64)\n    detected = False\n    try:\n        _ = cholesky_solve(A7, b7)\n        detected = False\n    except ValueError:\n        detected = True\n    results.append(detected)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2379908"}, {"introduction": "在许多实际应用中，矩阵并非一成不变，而是会随着新数据的加入而更新，每次都从头计算完整的分解是低效的。本项高级练习将向你介绍一种优雅且高效的算法，用于在原矩阵发生秩一更新后，直接更新其 Cholesky 分解 [@problem_id:2379848]。掌握这项复杂度仅为 $\\mathcal{O}(n^2)$ 的更新技术，将让你领略到数值线性代数领域为追求实时和大规模应用中的极致效率而设计的精妙之处。", "problem": "给定一个对称正定矩阵的下三角形式分解，即一个对角线元素严格为正的矩阵 $L \\in \\mathbb{R}^{n \\times n}$，使得 $A = L L^{T}$，其中 $A$ 是对称正定矩阵。考虑一个形式为 $A \\leftarrow A + v v^{T}$ 的秩-1 更新，其中 $v \\in \\mathbb{R}^{n}$ 是一个非零向量。您的任务是实现一个算法，该算法将 $L$ 更新为一个新的、对角线元素为正的下三角因子 $L^{\\prime}$，使其满足 $A + v v^{T} = L^{\\prime} L^{\\prime T}$，且仅使用 $\\mathcal{O}(n^{2})$ 次运算，而无需从头重新计算 Cholesky 分解。\n\n使用的基本依据和定义如下：\n- 一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定的，当且仅当对于所有非零 $x \\in \\mathbb{R}^{n}$ 都有 $x^{T} A x &gt; 0$；并且当且仅当存在一个唯一的、对角线元素为正的下三角矩阵 $L$，使得 $A = L L^{T}$ (Cholesky 分解)。\n- 对于任意 $v \\in \\mathbb{R}^{n}$，如果 $A$ 是对称正定矩阵，那么矩阵 $A + v v^{T}$ 也是对称正定的。\n\n您的程序必须：\n- 实现一个原地风格的秩-1 更新例程，该例程对下三角因子 $L$ 和向量 $v$ 进行操作，以生成 $L^{\\prime}$，使得 $L^{\\prime} L^{\\prime T} = L L^{T} + v v^{T}$，且仅使用 $\\mathcal{O}(n^{2})$ 次算术运算。\n- 通过计算目标矩阵 $A + v v^{T}$ 与重构矩阵 $L^{\\prime} L^{\\prime T}$ 之差的 Frobenius 范数，即计算 $\\| L^{\\prime} L^{\\prime T} - (A + v v^{T}) \\|_{F}$，来为每个测试验证其正确性。\n- 将这些范数作为浮点数返回。\n\n测试套件：\n使用以下五个测试用例。在每个用例中，$L$ 都是对角线元素为正的下三角矩阵。所有元素均为实值。\n\n1) 正常流程用例 ($n = 4$):\n- $L = \\begin{bmatrix}\n2.0 & 0 & 0 & 0 \\\\\n0.5 & 1.8 & 0 & 0 \\\\\n1.2 & -0.3 & 1.5 & 0 \\\\\n-0.7 & 0.4 & 0.6 & 1.1\n\\end{bmatrix}$\n- $v = \\begin{bmatrix} 0.8 \\\\ -1.2 \\\\ 0.3 \\\\ 0.5 \\end{bmatrix}$\n\n2) 边界用例 ($n = 1$):\n- $L = \\begin{bmatrix} 2.0 \\end{bmatrix}$\n- $v = \\begin{bmatrix} 3.0 \\end{bmatrix}$\n\n3) 零更新边缘用例 ($n = 3$):\n- $L = \\begin{bmatrix}\n1.2 & 0 & 0 \\\\\n0.1 & 1.1 & 0 \\\\\n-0.2 & 0.05 & 0.9\n\\end{bmatrix}$\n- $v = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$\n\n4) 小扰动用例 ($n = 3$):\n- $L = \\begin{bmatrix}\n3.0 & 0 & 0 \\\\\n1.0 & 2.5 & 0 \\\\\n-1.2 & 0.7 & 2.2\n\\end{bmatrix}$\n- $v = \\begin{bmatrix} 1\\times 10^{-8} \\\\ -2\\times 10^{-8} \\\\ 3\\times 10^{-8} \\end{bmatrix}$\n\n5) 病态但有效的用例 ($n = 5$):\n- $L = \\begin{bmatrix}\n1\\times 10^{-6} & 0 & 0 & 0 & 0 \\\\\n2\\times 10^{-7} & 1\\times 10^{-3} & 0 & 0 & 0 \\\\\n-1\\times 10^{-7} & 3\\times 10^{-4} & 1\\times 10^{-1} & 0 & 0 \\\\\n5\\times 10^{-8} & -2\\times 10^{-4} & 4\\times 10^{-2} & 1.0 & 0 \\\\\n1\\times 10^{-8} & 1\\times 10^{-5} & -3\\times 10^{-3} & 2\\times 10^{-1} & 10.0\n\\endbmatrix}$\n- $v = \\begin{bmatrix} 1\\times 10^{-6} \\\\ -1\\times 10^{-4} \\\\ 1\\times 10^{-2} \\\\ -1.0 \\\\ 2.0 \\end{bmatrix}$\n\n您的程序应该：\n- 对于每个测试用例，计算 $A = L L^{T}$，通过您的秩-1 更新例程使用给定的 $L$ 和 $v$ 计算 $L^{\\prime}$，然后计算 Frobenius 范数 $\\| L^{\\prime} L^{\\prime T} - (A + v v^{T}) \\|_{F}$ 作为一个浮点值。\n- 生成单行输出，其中包含五个结果，形式为用方括号括起来的逗号分隔列表（例如 $[r_{1},r_{2},r_{3},r_{4},r_{5}]$）。\n\n注意：\n- 此问题不涉及物理单位。\n- 不要对 $A + v v^{T}$ 调用通用的完整 Cholesky 分解来获取 $L^{\\prime}$。您必须实现直接对因子 $L$ 和向量 $v$ 操作的 $\\mathcal{O}(n^{2})$ 秩-1 更新算法。", "solution": "该问题陈述已经过严格验证，并被确定为有效。它在数值线性代数领域具有科学依据，是良定的、客观的，并包含获得唯一且可验证解所需的所有信息。因此，我们可以继续进行所需算法的推导和实现。\n\n问题要求在对一个对称正定 (SPD) 矩阵进行秩-1 更新后，计算其更新后的 Cholesky 分解。给定一个对角线元素为正的下三角矩阵 $L \\in \\mathbb{R}^{n \\times n}$ 使得 $A = L L^{T}$，以及一个向量 $v \\in \\mathbb{R}^{n}$，我们寻求一个新的、对角线元素也为正的下三角矩阵 $L^{\\prime} \\in \\mathbb{R}^{n \\times n}$，使得 $L^{\\prime} {L^{\\prime}}^T = A + v v^T$。一种朴素的方法是先计算 $A' = A + v v^T$，然后对 $A'$ 执行完整的 Cholesky 分解，这将耗费 $\\mathcal{O}(n^3)$ 次运算。要求是设计一个复杂度为 $\\mathcal{O}(n^2)$ 的算法。\n\n需要满足的基本关系是：\n$$\nL^{\\prime} {L^{\\prime}}^T = L L^T + v v^T\n$$\n这个方程可以用矩阵乘积来表示。考虑增广矩阵 $\\begin{bmatrix} L & v \\end{bmatrix} \\in \\mathbb{R}^{n \\times (n+1)}$。那么，更新后的矩阵 $A' = A + v v^T$ 可以写为：\n$$\nA' = \\begin{bmatrix} L & v \\end{bmatrix} \\begin{bmatrix} L^T \\\\ v^T \\end{bmatrix}\n$$\n这种表示方法并不能直接导出一个三角因子。一个更富有成效的表述是考虑其转置，我们得到一个 $(n+1) \\times n$ 的矩阵 $M$：\n$$\nM = \\begin{bmatrix} L^T \\\\ v^T \\end{bmatrix}\n$$\n那么，更新后的矩阵就是 $A' = M^T M = (L^T)^T L^T + (v^T)^T v^T = L L^T + v v^T$。\n我们正在寻求一个分解 $A' = L' {L'}^T$。通过将 $L'^T$ 等同于一个上三角矩阵 $R$，我们有 $A' = R^T R$。这表明 $R$ 是矩阵 $M$ 的 QR 分解得到的上三角因子。也就是说，如果我们找到一个正交矩阵 $Q \\in \\mathbb{R}^{(n+1) \\times (n+1)}$ 使得：\n$$\nQ M = \\begin{bmatrix} R \\\\ 0 \\end{bmatrix}\n$$\n其中 $R \\in \\mathbb{R}^{n \\times n}$ 是上三角矩阵，那么 $M = Q^T \\begin{bmatrix} R \\\\ 0 \\end{bmatrix}$。因此，\n$$\nA' = M^T M = \\left( Q^T \\begin{bmatrix} R \\\\ 0 \\end{bmatrix} \\right)^T \\left( Q^T \\begin{bmatrix} R \\\\ 0 \\end{bmatrix} \\right) = \\begin{bmatrix} R^T & 0 \\end{bmatrix} Q Q^T \\begin{bmatrix} R \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} R^T & 0 \\end{bmatrix} \\begin{bmatrix} R \\\\ 0 \\end{bmatrix} = R^T R\n$$\n因此，我们可以认定 $L'^T = R$。矩阵 $M$ 具有一个特殊结构：其顶部的 $n \\times n$ 块 $L^T$ 已经是上三角矩阵。\n$$\nM = \\begin{bmatrix} L^T \\\\ v^T \\end{bmatrix} = \\begin{bmatrix}\nl_{11} & l_{21} & \\dots & l_{n1} \\\\\n0 & l_{22} & \\dots & l_{n2} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\dots & l_{nn} \\\\\nv_1 & v_2 & \\dots & v_n\n\\end{bmatrix}\n$$\n这个结构除了最后一行外，“几乎”是上三角的。我们可以通过一系列 $n$ 次 Givens 旋转，一次一个元素地在最后一行中引入零。对于每一列 $j=1, \\dots, n$，我们在第 $j$ 行和第 $n+1$ 行的平面上应用一次旋转，以将元素 $(n+1, j)$（即 $v_j$）置零。这个过程必须从 $j=1$ 到 $n$ 依次进行。\n\n为了能直接在下三角矩阵 $L$ 上实现，我们可以推导出一个等价的逐列算法。这避免了显式构造 $L^T$。该算法从 $j=1$ 到 $n$ 逐次更新 $L$ 的一列。设 $p$ 为一个辅助向量，初始化为 $v$。在每一步 $j$ 中，我们使用一次 Givens 旋转来结合对角线元素 $L_{jj}$ 和 $p$ 的当前第 $j$ 个元素（记为 $p_j$）。这次旋转会更新 $L_{jj}$ 并消除 $p_j$。然后必须将相同的旋转应用于 $L$ 的第 $j$ 列的其余部分（对于 $i > j$ 的元素 $L_{ij}$）和 $p$ 的相应元素（对于 $i > j$ 的元素 $p_i$）。\n\n算法如下：\n初始化一个辅助向量 $p \\leftarrow v$。待计算的矩阵 $L'$ 可以在 $L$ 的一个副本上原地完成。\n\n对于 $j = 1, 2, \\dots, n$：\n1.  提取对角线元素 $\\alpha = L_{jj}$ 和向量元素 $\\beta = p_j$。\n2.  计算 $L'$ 的新对角线元素，即欧几里得范数：\n    $$\n    L'_{jj} = \\sqrt{\\alpha^2 + \\beta^2}\n    $$\n    根据 Cholesky 因子的定义，$L_{jj} > 0$，因此 $L'_{jj}$ 也将是正的（除非 $\\alpha$ 和 $\\beta$ 均为零，但事实并非如此）。\n3.  定义 Givens 旋转的余弦和正弦：\n    $$\n    c = \\frac{\\alpha}{L'_{jj}}, \\quad s = \\frac{\\beta}{L'_{jj}}\n    $$\n    它们满足 $c^2 + s^2 = 1$。变换 $\\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix} \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix} = \\begin{pmatrix} L'_{jj} \\\\ 0 \\end{pmatrix}$ 能有效地将 $\\beta$ 并入对角线，并将 $p$ 的目标元素置零。\n4.  将此相同的旋转应用于 $L$ 的第 $j$ 列的其余元素和向量 $p$。对于每个 $i = j+1, \\dots, n$：\n    $$\n    \\begin{pmatrix} L'_{ij} \\\\ p'_{i} \\end{pmatrix} = \\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix} \\begin{pmatrix} L_{ij} \\\\ p_{i} \\end{pmatrix}\n    $$\n    这等价于以下更新操作：\n    $$\n    L'_{ij} \\leftarrow c \\cdot L_{ij} + s \\cdot p_i\n    $$\n    $$\n    p_i \\leftarrow -s \\cdot L_{ij} + c \\cdot p_i\n    $$\n    这些更新必须使用第 $j$ 步开始前的 $L_{ij}$ 和 $p_i$ 的值。在原地实现时，必须注意对两个更新都使用“旧”值。\n\n对所有列重复此过程。算术运算的总数主要由步骤 4 决定。对于每个 $j$，针对 $i$ 的更新循环运行 $n-j$ 次，每次执行常数次的乘法和加法。因此，总复杂度与 $\\sum_{j=1}^{n-1} (n-j) \\approx n^2/2$ 成正比，即所要求的 $\\mathcal{O}(n^2)$。得到的矩阵 $L'$ 就是 $A + v v^T$ 所需的下三角 Cholesky 因子。", "answer": "```python\nimport numpy as np\n\ndef chol_rank1_update(L: np.ndarray, v: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Performs a rank-1 update of a Cholesky factorization.\n\n    Given a lower-triangular matrix L and a vector v, computes the \n    lower-triangular matrix L_prime such that:\n    L_prime @ L_prime.T = L @ L.T + v @ v.T\n\n    The algorithm has O(n^2) complexity.\n\n    Args:\n        L: An (n, n) lower-triangular numpy array with a positive diagonal.\n        v: An (n,) numpy array representing the update vector.\n\n    Returns:\n        An (n, n) lower-triangular numpy array L_prime.\n    \"\"\"\n    n = L.shape[0]\n    # Make copies to avoid modifying the original inputs\n    L_prime = L.copy()\n    p = v.copy().astype(float) # Ensure p is float for computations\n\n    for j in range(n):\n        # Extract the diagonal element of L and the j-th element of p\n        alpha = L_prime[j, j]\n        beta = p[j]\n\n        # Compute the new diagonal element for L_prime\n        # np.hypot calculates sqrt(alpha^2 + beta^2) robustly\n        L_prime_jj_new = np.hypot(alpha, beta)\n\n        # Calculate Givens rotation parameters\n        if L_prime_jj_new == 0.0:\n            # This case occurs if alpha and beta are both zero. Since L has a\n            # positive diagonal, alpha > 0, so this branch is unlikely.\n            c = 1.0\n            s = 0.0\n        else:\n            c = alpha / L_prime_jj_new\n            s = beta / L_prime_jj_new\n        \n        # Update the diagonal element of L_prime\n        L_prime[j, j] = L_prime_jj_new\n\n        # Apply the rotation to the rest of the column j and vector p\n        if j < n - 1:\n            # Select the sub-column of L and sub-vector of p to be updated\n            L_subcol = L_prime[j+1:n, j]\n            p_subvec = p[j+1:n]\n            \n            # The update for the new p sub-vector must use the OLD L sub-column.\n            # The update for the new L sub-column must use the OLD p sub-vector.\n            # We compute the new p sub-vector first before updating L_prime's column.\n            new_p_subvec = -s * L_subcol + c * p_subvec\n            L_prime[j+1:n, j] = c * L_subcol + s * p_subvec\n            p[j+1:n] = new_p_subvec\n            \n    return L_prime\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the Cholesky rank-1 update validation.\n    \"\"\"\n    test_cases = [\n        # 1) Happy-path case (n=4)\n        (np.array([[2.0, 0, 0, 0], \n                   [0.5, 1.8, 0, 0], \n                   [1.2, -0.3, 1.5, 0], \n                   [-0.7, 0.4, 0.6, 1.1]]), \n         np.array([0.8, -1.2, 0.3, 0.5])),\n        # 2) Boundary case (n=1)\n        (np.array([[2.0]]), \n         np.array([3.0])),\n        # 3) Zero-update edge case (n=3)\n        (np.array([[1.2, 0, 0], \n                   [0.1, 1.1, 0], \n                   [-0.2, 0.05, 0.9]]), \n         np.array([0.0, 0.0, 0.0])),\n        # 4) Small-perturbation case (n=3)\n        (np.array([[3.0, 0, 0], \n                   [1.0, 2.5, 0], \n                   [-1.2, 0.7, 2.2]]), \n         np.array([1e-8, -2e-8, 3e-8])),\n        # 5) Ill-conditioned but valid case (n=5)\n        (np.array([[1e-6, 0, 0, 0, 0],\n                   [2e-7, 1e-3, 0, 0, 0],\n                   [-1e-7, 3e-4, 1e-1, 0, 0],\n                   [5e-8, -2e-4, 4e-2, 1.0, 0],\n                   [1e-8, 1e-5, -3e-3, 2e-1, 10.0]]),\n         np.array([1e-6, -1e-4, 1e-2, -1.0, 2.0])),\n    ]\n\n    results = []\n    for L, v in test_cases:\n        # Compute the target matrix A_prime = L L^T + v v^T\n        A = L @ L.T\n        v_col = v[:, np.newaxis]\n        A_prime_target = A + v_col @ v_col.T\n\n        # Get the updated Cholesky factor L_prime using the O(n^2) algorithm\n        L_prime = chol_rank1_update(L, v)\n        \n        # Reconstruct the matrix from the updated factor\n        A_prime_reconstructed = L_prime @ L_prime.T\n\n        # Compute the Frobenius norm of the difference to verify correctness\n        error_norm = np.linalg.norm(A_prime_reconstructed - A_prime_target, 'fro')\n        results.append(error_norm)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2379848"}]}