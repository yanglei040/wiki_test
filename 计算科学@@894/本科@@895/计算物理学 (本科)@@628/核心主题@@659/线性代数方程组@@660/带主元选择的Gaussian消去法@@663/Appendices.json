{"hands_on_practices": [{"introduction": "要理解主元选择的威力，最好的方法是在最基础的层面观察其运作。本练习模拟了计算机的有限精度算术，要求你手动执行带部分主元选择的高斯消元法。通过这个经典例子，你将具体地理解主元选择策略如何防止因小主对角元素可能导致的舍入误差放大问题。[@problem_id:2193047]", "problem": "考虑以下线性方程组：\n$$\n\\begin{align*}\n(2.00 \\times 10^{-4}) x_1 + 2.00 x_2 &= 4.00 \\\\\n1.00 x_1 + 3.00 x_2 &= 5.00\n\\end{align*}\n$$\n你需要使用高斯消元法求解该方程组，但所有计算都必须使用一种简化的浮点表示法，称为**三位截断算术**。在这种算术系统中，数字首先被写成规格化十进制形式，$\\pm 0.d_1d_2d_3d_4... \\times 10^n$，其中 $d_1 \\in \\{1, 2, \\dots, 9\\}$。然后，通过“截断”第三位之后的所有数字来存储该数，得到形式 $\\pm 0.d_1d_2d_3 \\times 10^n$。每次独立的算术运算（加、减、乘、除）后都会进行这种截断。\n\n使用**带部分主元的高斯消元法**计算解向量 $\\mathbf{x} = [x_1, x_2]^T$。将你的最终答案表示为解向量的两个分量。", "solution": "我们应用带部分主元的高斯消元法，并遵循三位截断算术规则（每次运算后以三位有效数字的规格化形式存储数字）。\n\n从增广矩阵开始\n$$\n\\left[\\begin{array}{cc|c}\n2.00\\times 10^{-4} & 2.00 & 4.00\\\\\n1.00 & 3.00 & 5.00\n\\end{array}\\right].\n$$\n对第1列进行部分主元选取，比较 $|2.00\\times 10^{-4}|$ 和 $|1.00|$，因此我们交换两行：\n$$\n\\left[\\begin{array}{cc|c}\n1.00 & 3.00 & 5.00\\\\\n2.00\\times 10^{-4} & 2.00 & 4.00\n\\end{array}\\right].\n$$\n消元乘数\n$$\n\\ell_{21}=\\text{chop}_{3}\\left(\\frac{2.00\\times 10^{-4}}{1.00}\\right)=2.00\\times 10^{-4}.\n$$\n每次运算后进行截断，更新第2行的元素：\n- 新的 $a_{21}$:\n$$\n\\text{chop}_{3}\\left(2.00\\times 10^{-4}-\\ell_{21}\\cdot 1.00\\right)=\\text{chop}_{3}\\left(2.00\\times 10^{-4}-2.00\\times 10^{-4}\\right)=0.\n$$\n- 新的 $a_{22}$:\n$$\n\\ell_{21}\\cdot a_{12}=\\text{chop}_{3}\\left((2.00\\times 10^{-4})\\cdot 3.00\\right)=6.00\\times 10^{-4},\n$$\n$$\na_{22}^{(new)}=\\text{chop}_{3}\\left(2.00-6.00\\times 10^{-4}\\right)=\\text{chop}_{3}(1.9994)=1.99.\n$$\n- 新的 $b_{2}$:\n$$\n\\ell_{21}\\cdot b_{1}=\\text{chop}_{3}\\left((2.00\\times 10^{-4})\\cdot 5.00\\right)=1.00\\times 10^{-3},\n$$\n$$\nb_{2}^{(new)}=\\text{chop}_{3}\\left(4.00-1.00\\times 10^{-3}\\right)=\\text{chop}_{3}(3.999)=3.99.\n$$\n因此，上三角方程组为\n$$\n\\begin{cases}\n1.00\\,x_{1}+3.00\\,x_{2}=5.00,\\\\\n1.99\\,x_{2}=3.99.\n\\end{cases}\n$$\n每次运算后进行截断，进行回代求解：\n$$\nx_{2}=\\text{chop}_{3}\\left(\\frac{3.99}{1.99}\\right)=\\text{chop}_{3}(2.005025\\ldots)=2.00.\n$$\n然后\n$$\na_{12}\\,x_{2}=\\text{chop}_{3}(3.00\\cdot 2.00)=6.00,\\quad\nb_{1}-a_{12}x_{2}=\\text{chop}_{3}(5.00-6.00)=-1.00,\n$$\n$$\nx_{1}=\\text{chop}_{3}\\left(\\frac{-1.00}{1.00}\\right)=-1.00.\n$$\n因此，在带部分主元的三位截断算术下，解向量为 $x_{1}=-1.00$ 和 $x_{2}=2.00$。", "answer": "$$\\boxed{\\begin{pmatrix}-1.00 \\\\ 2.00\\end{pmatrix}}$$", "id": "2193047"}, {"introduction": "在真实的计算物理问题中，线性系统常常源于不同物理定律的结合，其系数矩阵的元素尺度可能相差悬殊。本练习提供了一些典型的病态系统，它们对于朴素的算法来说是出了名的难以处理。你的任务是运用一个稳健的专业级求解器来找到答案，从而体验内置主元选择策略的程序库函数在解决实际问题时的强大与可靠。[@problem_id:2397351]", "problem": "考虑三个独立的线性系统，它们是在将异构物理模型转换为国际单位制（SI）后得到的。系数已包含所有必要的单位转换，并且每个系统都有指定 SI 单位的未知数。由于方程和系数之间的数量级差异巨大，必须精确地获得数值解。对于每个系统，给定矩阵 $\\mathbf{A}$ 和右侧向量 $\\mathbf{b}$，求解未知向量 $\\mathbf{x} = [x_1, x_2, x_3]^{\\mathsf{T}}$，并以指定 SI 单位的实数形式报告解的分量（输出中不包含单位符号；数值应按每个系统声明的单位进行解释）。您的程序必须处理以下测试套件，并按规定格式生成聚合输出。\n\n系统 A（异构单位，理想情况）：\n- 未知数：$x_1$ 单位为 $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$x_2$ 单位为 $\\mathrm{C}$，$x_3$ 单位为 $\\mathrm{m}$。\n- 系数矩阵\n$$\n\\mathbf{A}_A =\n\\begin{bmatrix}\n10^{9} & 3 & -2\\times 10^{-6} \\\\\n2\\times 10^{-3} & -5\\times 10^{6} & 7 \\\\\n4 & 10^{-9} & 3\\times 10^{3}\n\\end{bmatrix}\n$$\n- 右侧向量\n$$\n\\mathbf{b}_A =\n\\begin{bmatrix}\n1999999990.999998 \\\\\n15000007.004 \\\\\n3007.999999997\n\\end{bmatrix}\n$$\n\n系统 B（具有不同尺度的近奇异结构）：\n- 未知数：$x_1$、$x_2$、$x_3$ 无量纲。\n- 系数矩阵\n$$\n\\mathbf{A}_B =\n\\begin{bmatrix}\n10^{-12} & 1 & 1 \\\\\n1 & 1 & 1 \\\\\n1 & 1 & 1+10^{-12}\n\\end{bmatrix}\n$$\n- 右侧向量\n$$\n\\mathbf{b}_B =\n\\begin{bmatrix}\n10^{-12} \\\\\n1 \\\\\n1+10^{-12}\n\\end{bmatrix}\n$$\n\n系统 C（主对角线元素为零且系数变化极大）：\n- 未知数：$x_1$ 单位为 $\\mathrm{m}$，$x_2$ 单位为 $\\mathrm{Pa}$，$x_3$ 单位为 $\\mathrm{s}$。\n- 系数矩阵\n$$\n\\mathbf{A}_C =\n\\begin{bmatrix}\n0 & 10^{5} & 1 \\\\\n10^{-10} & 1 & 1 \\\\\n1 & 0 & 10^{-5}\n\\end{bmatrix}\n$$\n- 右侧向量\n$$\n\\mathbf{b}_C =\n\\begin{bmatrix}\n200003 \\\\\n5.0000000001 \\\\\n1.00003\n\\end{bmatrix}\n$$\n\n所需输出格式：\n- 对每个系统，计算解向量 $\\mathbf{x}$，并将每个分量四舍五入至 $8$ 位有效数字。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目是对应系统 A、B、C 的三个四舍五入后的解分量的列表。例如，输出必须如下所示\n$$\n[\\,[x_{1,A},x_{2,A},x_{3,A}],\\,[x_{1,B},x_{2,B},x_{3,B}],\\,[x_{1,C},x_{2,C},x_{3,C}]\\,]\n$$\n其中每个 $x$ 是一个四舍五入到 $8$ 位有效数字的实数。", "solution": "所提出的问题是有效的。它是一组适定（well-posed）的线性代数问题，这些问题基于数值分析，并与计算物理相关。所有必要的数据均已提供，并且没有科学或逻辑上的矛盾。问题的核心是为三个不同的系统求解矩阵方程 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$，每个系统都旨在测试所用数值方法的稳健性。这些矩阵表现出的特性对朴素算法（naive algorithms）构成了挑战，例如系数数量级的巨大变化、近奇异性以及主对角线上存在零元素。在这些条件下，使用数值稳定的算法不仅是更可取的，而且是必需的。\n\n求解这类系统的基本原理是高斯消去法（Gaussian elimination）。然而，如果主元（用于归一化的对角线元素）为零或相对于矩阵中的其他元素非常小，那么高斯消去法的朴素实现将是数值不稳定的。这可能导致除以零或舍入误差的灾难性放大。确保数值稳定性的标准且正确的方法是采用主元选择策略（pivoting strategy）的高斯消去法。\n\n最常见的策略是部分主元法（partial pivoting）。在消去过程的第 $k$ 步，算法会在第 $k$ 列中从第 $k$ 行到最后一行搜索绝对值最大的元素。然后将包含该元素的行与第 $k$ 行交换。这确保了主元在数量级上尽可能大，从而最小化了消去步骤中使用的乘数，进而控制了数值误差的增长。系统 $\\mathbf{A}_C$ 在位置 $(1,1)$ 处有一个 $0$，这使得主元选择成为必需；如果不进行行交换，算法将因除以零而立即失败。系统 $\\mathbf{A}_A$ 和 $\\mathbf{A}_B$ 的系数数量级差异巨大，使其成为病态（ill-conditioned）矩阵。对于这类矩阵，主元选择对于获得精确解至关重要。\n\n在现代计算实践中，人们不会从头开始实现这个算法。相反，人们依赖于标准科学计算库中提供的高度优化、经过严格测试且数值稳定的实现。这些库，例如 LAPACK (Linear Algebra PACKage)，构成了像 NumPy 这样的环境中线性代数例程的基础。函数 `numpy.linalg.solve` 内部使用一个 LAPACK 求解器（通常是 `_gesv` 的一个变体），该求解器实现了带部分主元法的 LU 分解。这是完成此项任务的合适且专业的工具。\n\n解决每个系统的步骤如下：\n1. 对每个系统（A, B, C），将系数矩阵 $\\mathbf{A}$ 和右侧向量 $\\mathbf{b}$ 定义为 `float64` 类型的数值数组，以获得最大精度。\n2. 调用 `numpy.linalg.solve(A, b)` 函数来计算解向量 $\\mathbf{x}$。该函数通过其底层的主元选择策略自动处理矩阵带来的数值挑战。\n3. 问题要求将所得解向量 $\\mathbf{x}$ 的每个分量四舍五入到 $8$ 位有效数字。这需要一个特定的舍入函数，该函数要考虑数值的数量级。对于一个非零数 $x$，为得到 $n$ 位有效数字而必须四舍五入到的小数位数 $d$ 由公式 $d = n - 1 - \\lfloor\\log_{10}|x|\\rfloor$ 给出。\n4. 将所有三个系统的四舍五入后的解向量收集起来，并按照问题陈述中指定的格式格式化为单个字符串。分析检查表明，精确解是整数向量：$\\mathbf{x}_A = [2, -3, 1]^{\\mathsf{T}}$，$\\mathbf{x}_B = [1, -1, 1]^{\\mathsf{T}}$ 和 $\\mathbf{x}_C = [1, 2, 3]^{\\mathsf{T}}$。一个稳健的数值求解器应该能高精度地恢复这些解，并且在四舍五入后，结果应与这些精确值相匹配。因此，输出将是一个包含这些浮点数的列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef round_to_significant_digits(x, n):\n    \"\"\"\n    Rounds a number x to n significant digits.\n    \"\"\"\n    if x == 0 or not np.isfinite(x):\n        return float(x) if isinstance(x, (int, float)) else x\n    \n    power = n - 1 - math.floor(math.log10(abs(x)))\n    factor = 10**power\n    \n    return round(x * factor) / factor\n\ndef solve():\n    \"\"\"\n    Solves the three linear systems defined in the problem statement\n    using a robust numerical solver and formats the output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([\n                [1e9, 3, -2e-6],\n                [2e-3, -5e6, 7],\n                [4, 1e-9, 3e3]\n            ], dtype=np.float64),\n            \"b\": np.array([\n                1999999990.999998,\n                15000007.004,\n                3007.999999997\n            ], dtype=np.float64)\n        },\n        {\n            \"A\": np.array([\n                [1e-12, 1, 1],\n                [1, 1, 1],\n                [1, 1, 1 + 1e-12]\n            ], dtype=np.float64),\n            \"b\": np.array([\n                1e-12,\n                1,\n                1 + 1e-12\n            ], dtype=np.float64)\n        },\n        {\n            \"A\": np.array([\n                [0, 1e5, 1],\n                [1e-10, 1, 1],\n                [1, 0, 1e-5]\n            ], dtype=np.float64),\n            \"b\": np.array([\n                200003,\n                5.0000000001,\n                1.00003\n            ], dtype=np.float64)\n        }\n    ]\n\n    results = []\n    num_significant_digits = 8\n\n    for case in test_cases:\n        A = case[\"A\"]\n        b = case[\"b\"]\n        \n        # Solve the linear system using numpy's robust solver, which\n        # employs LU decomposition with partial pivoting.\n        x = np.linalg.solve(A, b)\n        \n        # Round each component of the solution vector to 8 significant digits.\n        x_rounded = [round_to_significant_digits(val, num_significant_digits) for val in x]\n        \n        results.append(x_rounded)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a Python list is used for the inner lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397351"}, {"introduction": "主元选择并非孤立的数值技巧，其行为直接受到问题物理结构的影响。在此练习中，你将分析一个电阻网络，其中一个元件的电阻值 $\\varepsilon$ 是可变的。通过追踪当 $\\varepsilon$ 趋近于零时算法所选择的主元序列，你将探索物理系统特性与数值算法稳定性及性能之间的深刻联系。[@problem_id:2397377]", "problem": "给定一个纯电阻直流网络，该网络有四个标记为$1,2,3,4$的非接地节点和一个标记为$0$的接地节点。所有电阻均为理想、温度无关的线性电阻。根据节点分析法，可从该网络定义节点电导矩阵$G(\\varepsilon)\\in\\mathbb{R}^{4\\times 4}$，定义如下。对于任意一对不同的节点$i\\neq j$，如果节点$i$和$j$由一个电阻为$R_{ij}$（单位为$\\mathrm{\\Omega}$）的电阻器直接连接，则定义互电导为$g_{ij} \\equiv 1/R_{ij}$（单位为$\\mathrm{S}$）。每个节点$i\\in\\{1,2,3,4\\}$也通过一个电阻为$R_{i0}=1$（单位为$\\mathrm{\\Omega}$）的电阻器接地，因此$g_{i0}=1$（单位为$\\mathrm{S}$）。非零的节点间电阻器规定如下\n- $R_{12}=2$ (单位为$\\mathrm{\\Omega}$)，所以 $g_{12}=\\frac{1}{2}$ (单位为$\\mathrm{S}$),\n- $R_{23}=\\varepsilon$ (单位为$\\mathrm{\\Omega}$)，所以 $g_{23}=\\frac{1}{\\varepsilon}$ (单位为$\\mathrm{S}$),\n- $R_{34}=2$ (单位为$\\mathrm{\\Omega}$)，所以 $g_{34}=\\frac{1}{2}$ (单位为$\\mathrm{S}$),\n- $R_{14}=3$ (单位为$\\mathrm{\\Omega}$)，所以 $g_{14}=\\frac{1}{3}$ (单位为$\\mathrm{S}$),\n- $R_{13}=4$ (单位为$\\mathrm{\\Omega}$)，所以 $g_{13}=\\frac{1}{4}$ (单位为$\\mathrm{S}$)。\n\n节点电导矩阵的元素由以下公式给出\n- $G_{ii}(\\varepsilon)=\\sum\\limits_{j\\in\\{0,1,2,3,4\\}\\setminus\\{i\\}} g_{ij}$，为节点$i$上所有相连电导（包括接地电导）的总和，\n- 对于$i\\neq j$，如果节点$i$和$j$直接相连，则$G_{ij}(\\varepsilon)=-g_{ij}$，否则$G_{ij}(\\varepsilon)=0$。\n\n对于每个指定的$\\varepsilon>0$（单位为$\\mathrm{\\Omega}$），$G(\\varepsilon)$的主元序列$P(\\varepsilon)$定义如下。考虑对一个矩阵$A\\in\\mathbb{R}^{n\\times n}$进行消元过程，在每一步$k\\in\\{1,\\dots,n\\}$中，从行$i\\in\\{k,\\dots,n\\}$中选择一个主元行$p_k\\in\\{k,\\dots,n\\}$，使得$|A_{ik}|$的绝对值最大。如果存在多个最大值，则选择最小的索引$i$。然后交换行$k$和$p_k$，并继续消除第$k$列对角线以下的元素。当此过程应用于$A=G(\\varepsilon)$时，主元序列$P(\\varepsilon)$是在每一步$k=1,2,3,4$中选定的行的原始行索引（使用基于1的索引）列表。如前所述，必须通过在当前子矩阵中选择最小的行索引来解决并列问题。\n\n您的任务是为下面测试套件中的每个$\\varepsilon$计算$P(\\varepsilon)$。对于任何$\\varepsilon>0$（单位为$\\mathrm{\\Omega}$），该网络都是物理上适定的，所有计算都应在实数算术中执行。不需要电流注入，也不要求计算电压；只需报告主元序列。问题陈述中出现的所有物理量均采用国际单位制，具体来说，电阻单位为$\\mathrm{\\Omega}$，电导单位为$\\mathrm{S}$。所要求的输出是无单位的整数索引。\n\n测试套件（$\\varepsilon$的值，单位为$\\mathrm{\\Omega}$）：\n- $\\varepsilon=10$,\n- $\\varepsilon=1$,\n- $\\varepsilon=10^{-3}$,\n- $\\varepsilon=10^{-9}$。\n\n输出规格：\n- 对于上述给定的每个$\\varepsilon$，按顺序计算主元序列$P(\\varepsilon)$，该序列是一个包含四个整数的列表，使用基于1的索引，指向任何交换之前的原始行顺序。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应一个测试用例的$P(\\varepsilon)$的列表表示，顺序与测试套件中的顺序相同。例如，一个有效的输出格式是$[[p_{11},p_{12},p_{13},p_{14}],[p_{21},p_{22},p_{23},p_{24}],[p_{31},p_{32},p_{33},p_{34}],[p_{41},p_{42},p_{43},p_{44}]]$，其中$[p_{m1},p_{m2},p_{m3},p_{m4}]$是第$m$个$\\varepsilon$测试值的主元序列。", "solution": "我们首先将节点电导矩阵的构建过程形式化。对于每个节点$i\\in\\{1,2,3,4\\}$和接地节点$0$，令$g_{ij}$表示$i$和$j$之间的电导（单位为$\\mathrm{S}$）。在给定的网络中，非零电导为$g_{10}=g_{20}=g_{30}=g_{40}=1$，$g_{12}=\\frac{1}{2}$，$g_{23}=\\frac{1}{\\varepsilon}$，$g_{34}=\\frac{1}{2}$，$g_{14}=\\frac{1}{3}$，以及$g_{13}=\\frac{1}{4}$。节点电导矩阵$G(\\varepsilon)\\in\\mathbb{R}^{4\\times 4}$的元素为\n$$\nG_{ii}(\\varepsilon)=\\sum_{j\\in\\{0,1,2,3,4\\}\\setminus\\{i\\}} g_{ij},\\quad\nG_{ij}(\\varepsilon)=\\begin{cases}\n-g_{ij}, & i\\neq j \\text{ 且节点 }i,j\\text{ 直接相连},\\\\\n0, & \\text{其他情况。}\n\\end{cases}\n$$\n具体来说，使用$g_{23}=\\frac{1}{\\varepsilon}$，我们得到：\n$$\nG(\\varepsilon)=\\begin{bmatrix}\n1+\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4} & -\\frac{1}{2} & -\\frac{1}{4} & -\\frac{1}{3}\\\\[6pt]\n-\\frac{1}{2} & 1+\\frac{1}{2}+\\frac{1}{\\varepsilon} & -\\frac{1}{\\varepsilon} & 0\\\\[6pt]\n-\\frac{1}{4} & -\\frac{1}{\\varepsilon} & 1+\\frac{1}{\\varepsilon}+\\frac{1}{2}+\\frac{1}{4} & -\\frac{1}{2}\\\\[6pt]\n-\\frac{1}{3} & 0 & -\\frac{1}{2} & 1+\\frac{1}{2}+\\frac{1}{3}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{25}{12} & -\\frac{1}{2} & -\\frac{1}{4} & -\\frac{1}{3}\\\\[6pt]\n-\\frac{1}{2} & \\frac{3}{2}+\\frac{1}{\\varepsilon} & -\\frac{1}{\\varepsilon} & 0\\\\[6pt]\n-\\frac{1}{4} & -\\frac{1}{\\varepsilon} & \\frac{7}{4}+\\frac{1}{\\varepsilon} & -\\frac{1}{2}\\\\[6pt]\n-\\frac{1}{3} & 0 & -\\frac{1}{2} & \\frac{11}{6}\n\\end{bmatrix}.\n$$\n\n现在我们精确定义主元序列。对于一个方阵$A\\in\\mathbb{R}^{n\\times n}$，在步骤$k\\in\\{1,\\dots,n\\}$，我们选择\n$$\np_k=\\arg\\max_{i\\in\\{k,\\dots,n\\}} |A_{ik}|,\n$$\n通过选择最小的索引$i$来打破并列关系。然后我们交换行$k$和$p_k$，并对所有$i\\in\\{k+1,\\dots,n\\}$和$j\\in\\{k,\\dots,n\\}$应用标准消元更新$A_{ij}\\leftarrow A_{ij}-m_{ik}A_{kj}$，其中$m_{ik}=A_{ik}/A_{kk}$。主元序列$P(\\varepsilon)$报告在每一步选择的行的原始行索引（使用基于1的索引）。为了跟踪原始索引，我们维护一个在每次行交换时都会更新的排列。\n\n基于原理的解释：对于每一个$\\varepsilon>0$，矩阵$G(\\varepsilon)$都是一个对称正定（SPD）的M-矩阵，这是因为该网络是一个严格无源电阻网络，且每个节点都通过正电导接地。因此，$G(\\varepsilon)$在节点1处是严格行对角占优的，并且除了当$\\varepsilon\\to 0^{+}$时$g_{23}=\\frac{1}{\\varepsilon}$变得很大并产生近似约束$v_2\\approx v_3$之外，矩阵是良态的。上述定义的部分主元法规则在每一步通过最大化列的模来选择主元，这一选择是由非对角耦合的结构和演变的舒尔补驱动的。随着$\\varepsilon$的减小，涉及节点2和3的元素在数值上增大，但它们在第一步消元后的影响仍然会在降维系统的$(2,2)$位置产生一个占优的对角元素，从而导致该特定网络的枢轴选择顺序保持一致。\n\n为阐明这一点，考虑$\\varepsilon=1$的情况，此时$g_{23}=1$。那么\n$$\nG(1)=\\begin{bmatrix}\n\\frac{25}{12} & -\\frac{1}{2} & -\\frac{1}{4} & -\\frac{1}{3}\\\\\n-\\frac{1}{2} & \\frac{5}{2} & -1 & 0\\\\\n-\\frac{1}{4} & -1 & \\frac{11}{4} & -\\frac{1}{2}\\\\\n-\\frac{1}{3} & 0 & -\\frac{1}{2} & \\frac{11}{6}\n\\end{bmatrix}.\n$$\n在步骤$k=1$时，第1列的绝对值为$|\\frac{25}{12}|,|\\frac{1}{2}|,|\\frac{1}{4}|,|\\frac{1}{3}|$，最大值在第1行，因此主元为$\\pi_1=1$。在向下消元后，跨越行和列$\\{2,3,4\\}$的子矩阵中，降维后的第2列的绝对值条目约为$|2.38|,|1.06|,|0.08|$，因此主元位于当前第2行，对应于原始索引$\\pi_2=2$。继续下去，下一个主元在当前第3行（原始索引$\\pi_3=3$），最后一个是$\\pi_4=4$。因此$P(1)=[1,2,3,4]$。对测试套件中$\\varepsilon$的其他值进行数值分析，会发现由于上述持续的占优模式，即使当$\\varepsilon\\to 0^{+}$使矩阵变得越来越病态时，也会得到相同的主元序列。\n\n因此，对于测试套件\n$$\n\\varepsilon\\in\\{10,\\ 1,\\ 10^{-3},\\ 10^{-9}\\},\n$$\n计算出的主元序列为\n$$\nP(10)=[1,2,3,4],\\quad P(1)=[1,2,3,4],\\quad P(10^{-3})=[1,2,3,4],\\quad P(10^{-9})=[1,2,3,4].\n$$\n所要求的程序需要为每个指定的$\\varepsilon$构建$G(\\varepsilon)$，执行定义的主元选择和带行交换的消元过程，同时跟踪原始索引，并以单行列表的列表形式输出结果$[P(10),P(1),P(10^{-3}),P(10^{-9})]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_conductance_matrix(eps: float) -> np.ndarray:\n    \"\"\"\n    Construct the 4x4 nodal conductance matrix G(eps) for the specified network.\n    Resistances (ohms): R10=R20=R30=R40=1, R12=2, R23=eps, R34=2, R14=3, R13=4.\n    Conductances (siemens): g = 1/R.\n    \"\"\"\n    # Conductances to ground\n    g10 = g20 = g30 = g40 = 1.0\n\n    # Inter-node conductances\n    g12 = 1.0 / 2.0\n    g23 = 1.0 / eps\n    g34 = 1.0 / 2.0\n    g14 = 1.0 / 3.0\n    g13 = 1.0 / 4.0\n\n    # Initialize 4x4 zero matrix\n    G = np.zeros((4, 4), dtype=float)\n\n    # Diagonals: sum of incident conductances including to ground\n    # Node 1\n    G[0, 0] = g10 + g12 + g14 + g13\n    # Node 2\n    G[1, 1] = g20 + g12 + g23\n    # Node 3\n    G[2, 2] = g30 + g23 + g34 + g13\n    # Node 4\n    G[3, 3] = g40 + g34 + g14\n\n    # Off-diagonals: -g_ij for direct connections\n    # 1-2\n    G[0, 1] = G[1, 0] = -g12\n    # 2-3\n    G[1, 2] = G[2, 1] = -g23\n    # 3-4\n    G[2, 3] = G[3, 2] = -g34\n    # 1-4\n    G[0, 3] = G[3, 0] = -g14\n    # 1-3\n    G[0, 2] = G[2, 0] = -g13\n\n    return G\n\ndef pivot_sequence_partial(A_in: np.ndarray) -> list:\n    \"\"\"\n    Compute the pivot sequence of A using partial pivoting:\n    At each step k, choose the row i >= k with maximum absolute value in column k,\n    breaking ties by smallest row index. Swap rows and eliminate below.\n    Return the sequence of original row indices (1-based) selected as pivots.\n    \"\"\"\n    A = A_in.copy().astype(float)\n    n = A.shape[0]\n    # Track original row indices for each current row\n    row_ids = list(range(1, n + 1))  # 1-based original indices\n    pivots = []\n\n    for k in range(n):\n        # Find pivot row index p in [k, n-1] with maximal |A[i,k]|, tie -> smallest i\n        max_val = -1.0\n        p = k\n        for i in range(k, n):\n            val = abs(A[i, k])\n            if val > max_val:\n                max_val = val\n                p = i\n        # Record original row index\n        pivots.append(row_ids[p])\n        # Swap rows k and p in A and in row_ids\n        if p != k:\n            A[[k, p], :] = A[[p, k], :]\n            row_ids[k], row_ids[p] = row_ids[p], row_ids[k]\n        # If pivot is zero (singular), we still proceed to matching the definition;\n        # elimination factors will be zero or inf, but for our SPD matrices this won't occur.\n        pivot_val = A[k, k]\n        # Eliminate entries below the pivot\n        if pivot_val != 0.0:\n            for i in range(k + 1, n):\n                m = A[i, k] / pivot_val\n                if m != 0.0:\n                    A[i, k:] -= m * A[k, k:]\n                else:\n                    # Nothing to eliminate if already zero\n                    pass\n        else:\n            # No elimination possible if pivot is exactly zero; continue to next column\n            pass\n\n    return pivots\n\ndef solve():\n    # Define the test cases from the problem statement (epsilons in ohms).\n    test_eps = [10.0, 1.0, 1e-3, 1e-9]\n\n    results = []\n    for eps in test_eps:\n        G = build_conductance_matrix(eps)\n        piv = pivot_sequence_partial(G)\n        results.append(piv)\n\n    # Final print statement in the exact required format: single line list of lists.\n    print(str(results))\n\nsolve()\n```", "id": "2397377"}]}