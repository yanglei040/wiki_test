{"hands_on_practices": [{"introduction": "理解一个算法最好的方式之一就是在简单情形下手动执行它。这个练习将引导你对一个二维旋转矩阵进行解析LU分解。这是一个基础性练习，它将抽象的分解过程与一个具体的几何变换联系起来，帮助你巩固LU分解的计算步骤和核心思想。[@problem_id:2409827]", "problem": "在计算物理学中，平面上的线性变换通常由矩阵表示，矩阵的分解有助于高效的数值求解器。考虑一个以角度 $\\theta$ (以弧度为单位) 进行的二维旋转，它由 $2 \\times 2$ 矩阵表示\n$$\nR(\\theta) = \\begin{pmatrix}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\cos\\theta\n\\end{pmatrix}.\n$$\n求 $R(\\theta)$ 的下-上三角 (LU) 分解，其中 LU 代表下三角-上三角分解，并遵循下三角因子 $L$ 的主对角线元素为1且不使用行主元法的约定。假设 $\\cos\\theta \\neq 0$，因此不需要行主元法。将 $R(\\theta)$ 表示为 $R(\\theta) = L U$ 的形式，其中 $L$ 为单位下三角矩阵，$U$ 为上三角矩阵，并给出矩阵 $L(\\theta)$ 和 $U(\\theta)$ 作为 $\\theta$ 的函数的闭式表达式。\n\n答案格式要求：提供一个单一的解析表达式作为最终答案，该表达式由一个行矩阵构成，其两个元素分别为矩阵 $L(\\theta)$和 $U(\\theta)$。不需要四舍五入，也不涉及单位。", "solution": "首先必须对问题陈述进行严格验证。\n\n步骤1：提取已知条件。\n问题提供了以下信息：\n- 一个用于二维旋转（角度为 $\\theta$）的 $2 \\times 2$ 矩阵：$R(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}$。\n- 任务是找到 $R(\\theta)$ 的下-上三角 (LU) 分解。\n- 分解必须遵循 $R(\\theta) = L U$ 的形式，其中 $L$ 是一个单位下三角矩阵 (主对角线元素为1)，$U$ 是一个上三角矩阵。\n- 做出了一个明确的假设：$\\cos\\theta \\neq 0$，这确保了不需要行主元法。\n- 期望的输出是矩阵 $L(\\theta)$ 和 $U(\\theta)$ 的闭式表达式。\n\n步骤2：使用提取的已知条件进行验证。\n- **科学依据**：该问题基于线性代数的基本概念，特别是LU分解及其在旋转矩阵上的应用，这是计算物理学和工程学中的一个标准课题。这些概念在数学上和科学上都是可靠的。\n- **适定性**：该问题是适定的。它指明了要分解的矩阵、分解的精确形式（单位下三角矩阵 $L$），并提供了一个必要条件（$\\cos\\theta \\neq 0$）以保证作为无主元LU分解基础的标准高斯消元过程不会失败。这确保了 $L$ 和 $U$ 存在唯一解。\n- **客观性**：该问题使用精确、客观的数学语言陈述，没有任何歧义或主观论断。\n\n结论：该问题是有效的。它是线性代数中一个标准的、定义明确的练习题。我将继续进行求解。\n\n目标是找到一个单位下三角矩阵 $L$ 和一个上三角矩阵 $U$，使得 $R(\\theta) = L U$。鉴于 $R(\\theta)$ 是一个 $2 \\times 2$ 矩阵，矩阵 $L$ 和 $U$ 也将是 $2 \\times 2$ 矩阵。它们的一般形式是：\n$$\nL = \\begin{pmatrix} 1 & 0 \\\\ l_{21} & 1 \\end{pmatrix}\n\\quad \\text{和} \\quad\nU = \\begin{pmatrix} u_{11} & u_{12} \\\\ 0 & u_{22} \\end{pmatrix}\n$$\n此处，$l_{21}$、$u_{11}$、$u_{12}$ 和 $u_{22}$ 是我们必须确定为 $\\theta$ 的函数的未知元素。\n\n分解方程为：\n$$\nR(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix} = L U = \\begin{pmatrix} 1 & 0 \\\\ l_{21} & 1 \\end{pmatrix} \\begin{pmatrix} u_{11} & u_{12} \\\\ 0 & u_{22} \\end{pmatrix}\n$$\n对等式右侧执行矩阵乘法，得到：\n$$\n\\begin{pmatrix} 1 & 0 \\\\ l_{21} & 1 \\end{pmatrix} \\begin{pmatrix} u_{11} & u_{12} \\\\ 0 & u_{22} \\end{pmatrix} = \\begin{pmatrix} 1 \\cdot u_{11} + 0 \\cdot 0 & 1 \\cdot u_{12} + 0 \\cdot u_{22} \\\\ l_{21} \\cdot u_{11} + 1 \\cdot 0 & l_{21} \\cdot u_{12} + 1 \\cdot u_{22} \\end{pmatrix} = \\begin{pmatrix} u_{11} & u_{12} \\\\ l_{21} u_{11} & l_{21} u_{12} + u_{22} \\end{pmatrix}\n$$\n通过令 $R(\\theta)$ 和得到的 $LU$ 乘积的对应元素相等，我们得到一个方程组：\n$$\n\\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} u_{11} & u_{12} \\\\ l_{21} u_{11} & l_{21} u_{12} + u_{22} \\end{pmatrix}\n$$\n我们可以依次求解未知数。从第一行得到：\n1.  $u_{11} = \\cos\\theta$\n2.  $u_{12} = -\\sin\\theta$\n\n从第二行得到：\n3.  $l_{21} u_{11} = \\sin\\theta$。代入 $u_{11}$ 的表达式，我们有 $l_{21} \\cos\\theta = \\sin\\theta$。由于问题陈述 $\\cos\\theta \\neq 0$，我们可以用 $\\cos\\theta$ 相除来求得 $l_{21}$：\n    $$\n    l_{21} = \\frac{\\sin\\theta}{\\cos\\theta} = \\tan\\theta\n    $$\n4.  $l_{21} u_{12} + u_{22} = \\cos\\theta$。我们代入 $l_{21}$ 和 $u_{12}$ 的已知值：\n    $$\n    (\\tan\\theta)(-\\sin\\theta) + u_{22} = \\cos\\theta\n    $$\n    解出 $u_{22}$：\n    $$\n    u_{22} = \\cos\\theta + \\tan\\theta \\sin\\theta = \\cos\\theta + \\frac{\\sin\\theta}{\\cos\\theta} \\sin\\theta = \\frac{\\cos^2\\theta + \\sin^2\\theta}{\\cos\\theta}\n    $$\n    使用基本三角恒等式 $\\cos^2\\theta + \\sin^2\\theta = 1$，上式可简化为：\n    $$\n    u_{22} = \\frac{1}{\\cos\\theta} = \\sec\\theta\n    $$\n在找到了所有未知元素后，我们可以构建矩阵 $L(\\theta)$ 和 $U(\\theta)$：\n$$\nL(\\theta) = \\begin{pmatrix} 1 & 0 \\\\ \\tan\\theta & 1 \\end{pmatrix}\n$$\n$$\nU(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sec\\theta \\end{pmatrix}\n$$\n这些就是旋转矩阵 $R(\\theta)$ 的单位下三角和上三角因子，对所有满足 $\\cos\\theta \\neq 0$ 的 $\\theta$ 均有效。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ \\tan\\theta & 1 \\end{pmatrix} & \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sec\\theta \\end{pmatrix} \\end{pmatrix}}\n$$", "id": "2409827"}, {"introduction": "掌握如何获得$L$和$U$矩阵后，下一步是理解如何应用它们。这个问题巧妙地颠倒了传统的解题流程：你将不再是求解未知的$\\mathbf{x}$，而是利用已知的$L$、$U$和$\\mathbf{x}$来反推出原始方程组右端的向量$\\mathbf{b}$。这项练习能加深你对两步求解过程($L\\mathbf{y}=\\mathbf{b}$和$U\\mathbf{x}=\\mathbf{y}$)的理解，并巩固这些因子如何与整个线性系统关联。[@problem_id:2409873]", "problem": "在静电学的计算建模中，考虑在域 $(0,1)$ 上带有狄利克雷边界条件的一维泊松边值问题。使用一个包含 $N=3$ 个内部点的均匀网格和标准的二阶中心差分近似，用于求解内部值的无量纲化线性系统可以写成 $A\\,\\mathbf{x}=\\mathbf{b}$ 的形式，其中系数矩阵 $A$ 是一个三对角矩阵，其主对角线上的元素为 $2$，第一亚对角线和第一上对角线上的元素为 $-1$。假设 $A$ 的一个不进行主元选择的 LU 分解由下式给出：\n$$\nL=\\begin{pmatrix}\n1 & 0 & 0 \\\\\n-\\frac{1}{2} & 1 & 0 \\\\\n0 & -\\frac{2}{3} & 1\n\\end{pmatrix},\\quad\nU=\\begin{pmatrix}\n2 & -1 & 0 \\\\\n0 & \\frac{3}{2} & -1 \\\\\n0 & 0 & \\frac{4}{3}\n\\end{pmatrix},\n$$\n使得 $A=L\\,U$。假设三个内部网格点上的解向量为\n$$\n\\mathbf{x}=\\begin{pmatrix}1 \\\\ 1 \\\\ 1\\end{pmatrix}。\n$$\n确定右端向量 $\\mathbf{b}$ 使得 $A\\,\\mathbf{x}=\\mathbf{b}$。将你的最终答案表示为一个行向量，按内部网格点的顺序列出其三个分量。无需四舍五入。", "solution": "线性系统为 $A\\,\\mathbf{x}=\\mathbf{b}$，其中 $A=L\\,U$。根据矩阵乘法和分解的定义，这意味着\n$$\n\\mathbf{b}=A\\,\\mathbf{x}=(L\\,U)\\,\\mathbf{x}=L\\,(U\\,\\mathbf{x})。\n$$\n我们首先计算 $U\\,\\mathbf{x}$。已知\n$$\nU=\\begin{pmatrix}\n2 & -1 & 0 \\\\\n0 & \\frac{3}{2} & -1 \\\\\n0 & 0 & \\frac{4}{3}\n\\end{pmatrix},\\quad\n\\mathbf{x}=\\begin{pmatrix}1 \\\\ 1 \\\\ 1\\end{pmatrix},\n$$\n我们有\n$$\nU\\,\\mathbf{x}=\\begin{pmatrix}\n2\\cdot 1 + (-1)\\cdot 1 + 0\\cdot 1 \\\\\n0\\cdot 1 + \\frac{3}{2}\\cdot 1 + (-1)\\cdot 1 \\\\\n0\\cdot 1 + 0\\cdot 1 + \\frac{4}{3}\\cdot 1\n\\end{pmatrix}\n=\\begin{pmatrix}\n1 \\\\ \\frac{1}{2} \\\\ \\frac{4}{3}\n\\end{pmatrix}。\n$$\n接下来，计算 $\\mathbf{b}=L\\,(U\\,\\mathbf{x})$。已知\n$$\nL=\\begin{pmatrix}\n1 & 0 & 0 \\\\\n-\\frac{1}{2} & 1 & 0 \\\\\n0 & -\\frac{2}{3} & 1\n\\end{pmatrix},\\quad\nU\\,\\mathbf{x}=\\begin{pmatrix}1 \\\\ \\frac{1}{2} \\\\ \\frac{4}{3}\\end{pmatrix},\n$$\n我们得到\n$$\n\\mathbf{b}=L\\,(U\\,\\mathbf{x})=\\begin{pmatrix}\n1\\cdot 1 + 0\\cdot \\frac{1}{2} + 0\\cdot \\frac{4}{3} \\\\\n-\\frac{1}{2}\\cdot 1 + 1\\cdot \\frac{1}{2} + 0\\cdot \\frac{4}{3} \\\\\n0\\cdot 1 + \\left(-\\frac{2}{3}\\right)\\cdot \\frac{1}{2} + 1\\cdot \\frac{4}{3}\n\\end{pmatrix}\n=\\begin{pmatrix}\n1 \\\\ 0 \\\\ 1\n\\end{pmatrix}。\n$$\n因此，右端向量 $\\mathbf{b}$ 是 $\\begin{pmatrix}1 \\\\ 0 \\\\ 1\\end{pmatrix}$，其行向量形式为 $\\begin{pmatrix}1 & 0 & 1\\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix}1 & 0 & 1\\end{pmatrix}}$$", "id": "2409873"}, {"introduction": "真实世界的物理问题常常产生大型稀疏矩阵，存储所有零元素是极其低效的。这个实践将你从理论带入一个实际的编程挑战：为一个以节省内存的“天际线”（skyline）格式存储的矩阵调整并实现回代算法。这项任务旨在磨练你的算法思维，以及处理高性能科学计算中常见数据结构的能力。[@problem_id:2409844]", "problem": "给定一个形如 $U \\mathbf{x} = \\mathbf{y}$ 的线性方程组，其中 $U \\in \\mathbb{R}^{n \\times n}$ 是一个对角元素非零的上三角矩阵，$\\mathbf{y} \\in \\mathbb{R}^{n}$。矩阵 $U$ 并未显式给出，而是通过如下定义的列式压缩天际线格式进行存储。\n\n对于每个列索引 $j \\in \\{0, 1, \\dots, n-1\\}$，令 $r_j$ 为第 $j$ 列中可能包含非零元素的第一个（最小的）行索引。第 $j$ 列的轮廓由元素 $\\{ U_{i,j} \\mid i = r_j, r_j + 1, \\dots, j \\}$ 组成，这些元素连续存储在一个一维数组 $\\mathrm{val}$ 中。设 $\\mathrm{col\\_ptr}$ 是一个长度为 $n+1$ 的整数数组，采用从 0 开始的索引，使得第 $j$ 列的片段为 $\\mathrm{val}[\\mathrm{col\\_ptr}[j]\\,:\\,\\mathrm{col\\_ptr}[j+1])$。因此，第 $j$ 列片段的长度为 $j - r_j + 1$，对角线上的元素 $U_{j,j}$ 是该片段的最后一个元素。长度为 $n$ 的数组 $\\mathrm{row\\_start}$ 存储了值 $r_j$。所有索引均从 0 开始，天际线上方的元素（第 $j$ 列中行索引 $i < r_j$ 的元素）被隐式地视为零。根据上三角结构，主对角线下方的元素也为零。\n\n您的任务是为以下每个测试用例计算解向量 $\\mathbf{x}$。对于每个用例，都给定了 $n$、$\\mathrm{col\\_ptr}$、$\\mathrm{row\\_start}$、$\\mathrm{val}$ 和 $\\mathbf{y}$，所有这些都采用从 0 开始的索引。\n\n测试套件：\n- 用例 A:\n  - $n = 4$\n  - $\\mathrm{col\\_ptr} = [0, 1, 3, 6, 9]$\n  - $\\mathrm{row\\_start} = [0, 0, 0, 1]$\n  - $\\mathrm{val} = [3, -1, 4, 2, 0.5, -2, 1, 3, 5]$\n  - $\\mathbf{y} = [1, 2, -1, 10]$\n- 用例 B:\n  - $n = 3$\n  - $\\mathrm{col\\_ptr} = [0, 1, 2, 3]$\n  - $\\mathrm{row\\_start} = [0, 1, 2]$\n  - $\\mathrm{val} = [7, -3, 2]$\n  - $\\mathbf{y} = [14, 6, -4]$\n- 用例 C:\n  - $n = 1$\n  - $\\mathrm{col\\_ptr} = [0, 1]$\n  - $\\mathrm{row\\_start} = [0]$\n  - $\\mathrm{val} = [4]$\n  - $\\mathbf{y} = [10]$\n- 用例 D:\n  - $n = 5$\n  - $\\mathrm{col\\_ptr} = [0, 1, 3, 5, 7, 9]$\n  - $\\mathrm{row\\_start} = [0, 0, 1, 2, 3]$\n  - $\\mathrm{val} = [2, 1, 3, -1, 4, 0.5, 5, -0.5, 6]$\n  - $\\mathbf{y} = [3, 2, 4.5, 4.5, 6]$\n\n所有算术运算均在实数范围内进行。此任务不涉及物理单位。\n\n程序输出规范：\n- 您的程序必须生成单行输出，其中按顺序包含用例 A、B、C 和 D 的解列表。\n- 每个解必须表示为一个浮点数列表，对应于该用例解向量 $\\mathbf{x}$ 的各个元素。\n- 最终输出必须是单行，由一个类似 JSON 的数组的数组组成，各项之间用逗号分隔，不含空格。例如，形如 [a,b,c] 的单行是扁平列表的有效示意图；此处您必须输出一个对应于四个用例的列表的列表。", "solution": "用户提供的问题是有效的。它在数值线性代数领域有坚实的科学基础，是适定的，并且其所有术语和数据都得到了完整、一致且无歧义的规定。任务是求解一个线性方程组 $U \\mathbf{x} = \\mathbf{y}$，其中 $U$ 是一个对角元素非零的上三角矩阵。唯一解的存在性是保证的，因为这样的矩阵 $U$ 总是可逆的。解可以通过回代法求得，该方法需要针对指定的列式压缩天际线存储格式进行调整。\n\n求解上三角系统 $U \\mathbf{x} = \\mathbf{y}$ 的基本原理是回代法。该系统由以下方程描述：\n$$ \\sum_{j=i}^{n-1} U_{i,j} x_j = y_i \\quad \\text{for } i = 0, 1, \\dots, n-1 $$\n该算法通过逆序求解变量，即从 $x_{n-1}$ 向下到 $x_0$。对于 $i=n-1$ 的最后一个方程，仅涉及一个未知数：\n$$ U_{n-1,n-1} x_{n-1} = y_{n-1} \\implies x_{n-1} = \\frac{y_{n-1}}{U_{n-1,n-1}} $$\n一旦 $x_{n-1}$ 已知，我们可以将其代入倒数第二个方程（对于 $i=n-2$）来求解 $x_{n-2}$。对所有前面的变量重复此过程。对于一个通用索引 $i$，$x_i$ 的公式为：\n$$ x_i = \\frac{1}{U_{i,i}} \\left( y_i - \\sum_{j=i+1}^{n-1} U_{i,j} x_j \\right) $$\n这是一种行式方法，因为它需要沿第 $i$ 行访问元素 $U_{i,j}$。然而，该矩阵是以列式压缩天际线格式提供的。访问行元素效率会很低。一个更合适的方法是源自类 SAXPY 更新方案的列式算法。\n\n我们将系统 $U\\mathbf{x} = \\mathbf{y}$ 改写为 $U$ 的列向量的线性组合：\n$$ \\sum_{j=0}^{n-1} \\mathbf{u}_j x_j = \\mathbf{y} $$\n其中 $\\mathbf{u}_j$ 是 $U$ 的第 $j$ 列。由于 $U$ 是上三角的，我们可以将其表示为：\n$$ \\mathbf{u}_{n-1} x_{n-1} = \\mathbf{y} - \\sum_{j=0}^{n-2} \\mathbf{u}_j x_j $$\n这种表示方式并不能立即简化问题。相反，让我们调整回代过程，使其以列为中心。我们可以维护一个右端向量的工作副本，我们称之为 $\\mathbf{z}$，并将其初始化为 $\\mathbf{y}$。该算法计算 $x_j$，其中 $j=n-1, n-2, \\dots, 0$。\n\n1.  初始化解向量 $\\mathbf{x} \\in \\mathbb{R}^n$ 并设置一个临时向量 $\\mathbf{z} = \\mathbf{y}$。\n2.  从 $n-1$ 向下迭代到 $0$。在每次迭代中，我们求解 $x_j$，然后更新向量 $\\mathbf{z}$ 以消除项 $\\mathbf{u}_j x_j$ 的贡献。\n    a. 首先，我们求解 $x_j$。在第 $j$ 步，值 $x_{j+1}, \\dots, x_{n-1}$ 是已知的，它们的影响已经从 $\\mathbf{z}$ 中减去。第 $j$ 个方程实际上变成了 $U_{j,j} x_j = z_j$。因此，我们计算：\n       $$ x_j = \\frac{z_j}{U_{j,j}} $$\n    b. 接下来，我们更新临时向量 $\\mathbf{z}$ 的其余元素。项 $\\mathbf{u}_j x_j$ 对行 $i < j$ 的方程有贡献。我们必须从 $\\mathbf{z}$ 中减去这个贡献：\n       $$ z_i \\leftarrow z_i - U_{i,j} x_j \\quad \\text{for } i < j $$\n\n对于给定的存储格式，这种列式算法非常高效。列 $\\mathbf{u}_j$ 的非零元素为 $\\{ U_{i,j} \\mid i = r_j, \\dots, j \\}$，其中 $r_j$ 是第 $j$ 列的起始行索引。这些值连续存储在 `val` 数组中。求解步骤如下：\n\n设 `val`、`col_ptr` 和 `row_start` 是定义矩阵 $U$ 的数组。\n1.  初始化 `x = np.zeros(n)` 和 `z = np.copy(y)`。\n2.  对于 $j = n-1, n-2, \\dots, 0$：\n    a. 对角元素 $U_{j,j}$ 是第 $j$ 列的最后一个条目。它在 `val` 中的索引是 `col_ptr[j+1] - 1`。计算：\n       $$ x_j = \\frac{z_j}{\\mathrm{val}[\\mathrm{col\\_ptr}[j+1] - 1]} $$\n    b. 获取第 $j$ 列的起始行索引，$r_j = \\mathrm{row\\_start}[j]$。\n    c. 对第 $j$ 列轮廓中的所有行 $i$（不包括对角元素本身），更新临时向量 $\\mathbf{z}$：\n       对于 $i = r_j, r_j+1, \\dots, j-1$：\n       i. 矩阵元素 $U_{i,j}$ 位于 `val` 数组中索引为 `col_ptr[j] + i - r_j` 的位置。\n       ii. 执行更新：\n          $$ z_i \\leftarrow z_i - \\mathrm{val}[\\mathrm{col\\_ptr}[j] + i - r_j] \\times x_j $$\n对所有列重复此过程，即可得出完整的解向量 $\\mathbf{x}$。对每个提供的测试用例实施此算法，以找到最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_skyline_system(n, col_ptr, row_start, val, y):\n    \"\"\"\n    Solves an upper-triangular linear system Ux=y using back-substitution,\n    where U is stored in a column-oriented compressed skyline format.\n\n    Args:\n        n (int): The dimension of the matrix.\n        col_ptr (list or np.ndarray): Array of pointers to the start of each column in `val`.\n        row_start (list or np.ndarray): Array of starting row indices for each column's profile.\n        val (list or np.ndarray): 1D array containing the non-zero entries of U.\n        y (list or np.ndarray): The right-hand side vector.\n\n    Returns:\n        list: The solution vector x as a list of floats.\n    \"\"\"\n    x = np.zeros(n, dtype=float)\n    z = np.array(y, dtype=float)\n\n    # Iterate backwards from the last column to the first\n    for j in range(n - 1, -1, -1):\n        # 1. Solve for x[j]\n        # The diagonal element U_jj is the last element of column j's data in `val`\n        u_jj_idx = col_ptr[j+1] - 1\n        u_jj = val[u_jj_idx]\n\n        if u_jj == 0:\n            # This case is ruled out by the problem statement (\"nonzero diagonal entries\")\n            # but is good practice to handle.\n            raise ValueError(f\"Matrix is singular: zero on diagonal at index ({j},{j}).\")\n\n        x[j] = z[j] / u_jj\n\n        # 2. Update the RHS vector z\n        # The profile of column j starts at row r_j = row_start[j]\n        r_j = row_start[j]\n\n        # Iterate through the off-diagonal elements of column j's profile\n        # These are U_ij for i from r_j to j-1\n        for i in range(r_j, j):\n            # Calculate the index of U_ij in the `val` array\n            # The start of column j's data is at col_ptr[j]\n            # The offset for row i within the column data is (i - r_j)\n            u_ij_idx = col_ptr[j] + (i - r_j)\n            u_ij = val[u_ij_idx]\n            \n            z[i] -= u_ij * x[j]\n            \n    return x.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, solve them, and print the results\n    in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 4,\n            \"col_ptr\": [0, 1, 3, 6, 9],\n            \"row_start\": [0, 0, 0, 1],\n            \"val\": [3, -1, 4, 2, 0.5, -2, 1, 3, 5],\n            \"y\": [1, 2, -1, 10],\n        },\n        {\n            \"n\": 3,\n            \"col_ptr\": [0, 1, 2, 3],\n            \"row_start\": [0, 1, 2],\n            \"val\": [7, -3, 2],\n            \"y\": [14, 6, -4],\n        },\n        {\n            \"n\": 1,\n            \"col_ptr\": [0, 1],\n            \"row_start\": [0],\n            \"val\": [4],\n            \"y\": [10],\n        },\n        {\n            \"n\": 5,\n            \"col_ptr\": [0, 1, 3, 5, 7, 9],\n            \"row_start\": [0, 0, 1, 2, 3],\n            \"val\": [2, 1, 3, -1, 4, 0.5, 5, -0.5, 6],\n            \"y\": [3, 2, 4.5, 4.5, 6],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        solution_x = solve_skyline_system(\n            case[\"n\"],\n            case[\"col_ptr\"],\n            case[\"row_start\"],\n            case[\"val\"],\n            case[\"y\"]\n        )\n        results.append(solution_x)\n\n    # Format the output string exactly as specified:\n    # A list of lists, stringified with no spaces.\n    formatted_results = []\n    for res_list in results:\n        # Format each inner list as '[item1,item2,...]'\n        formatted_list = f\"[{','.join(map(str, res_list))}]\"\n        formatted_results.append(formatted_list)\n    \n    # Join the formatted inner lists and wrap with outer brackets\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2409844"}]}