{"hands_on_practices": [{"introduction": "数值求解常微分方程的核心思想是将连续问题离散化，一步步地逼近解。欧拉方法是其中最基础、最直观的算法，它通过在每个点处沿解曲线的切线方向前进一小步来近似下一个点的位置。本练习旨在让你亲手完成一个欧拉步骤，从而牢固掌握这一基本技巧。[@problem_id:2180117]", "problem": "考虑由常微分方程 $y' = x + \\cos(\\pi y)$ 及初始条件 $y(0) = 1$ 所给出的初始值问题。使用单步欧拉法来近似计算 $y(0.1)$ 的值。", "solution": "我们使用单步欧拉法，从 $x_{0}=0$ 到 $x_{1}=0.1$，步长为 $h=0.1=\\frac{1}{10}$。欧拉法的更新公式为\n$$\ny_{1}=y_{0}+h\\,f(x_{0},y_{0}),\n$$\n其中 $f(x,y)=x+\\cos(\\pi y)$。利用在 $x_{0}=0$ 处的初始条件 $y_{0}=1$，我们计算\n$$\nf(0,1)=0+\\cos(\\pi\\cdot 1)=\\cos(\\pi)=-1.\n$$\n因此，\n$$\ny(0.1)\\approx y_{1}=1+\\frac{1}{10}\\cdot(-1)=1-\\frac{1}{10}=\\frac{9}{10}.\n$$", "answer": "$$\\boxed{\\frac{9}{10}}$$", "id": "2180117"}, {"introduction": "虽然欧拉方法简单易用，但其精度有限。为了量化这种不精确性，我们引入了“局部截断误差”（Local Truncation Error, LTE）的概念，它衡量了单步计算所引入的误差。本练习旨在让你通过一个具体的例子，将理论与实践联系起来：你将计算一个欧拉步骤的真实误差，并将其与理论上由泰勒展开得到的误差主项进行比较，从而深刻理解数值方法的精度阶数。[@problem_id:2395152]", "problem": "考虑标量常微分方程的初值问题，$y^{\\prime}(t) = -y(t)^{3}$，初始条件为 $y(0)=1$。设步长为 $h=\\frac{1}{2}$。将前向欧拉法的局部截断误差 (LTE) 定义为单步缺陷\n$$\\tau(h) = y(h) - y(0) - h\\,f(0,y(0)),$$\n其中 $f(t,y)=-y^{3}$。由在 $t=0$ 处的泰勒展开得到的 LTE 的主阶近似为 $\\frac{h^{2}}{2}\\,y^{\\prime\\prime}(0)$。计算比值\n$$R = \\frac{\\tau(h)}{\\frac{h^{2}}{2}\\,y^{\\prime\\prime}(0)}.$$\n将 $R$ 以一个四舍五入到六位有效数字的实数形式报告。", "solution": "定义为单步缺陷的前向欧拉局部截断误差为\n$$\\tau(h) = y(h) - y(0) - h\\,f(0,y(0)).$$\n对于给定问题，$f(t,y)=-y^{3}$，因此 $f(0,y(0))=-1$。从而，\n$$\\tau(h) = y(h) - 1 - h(-1) = y(h) - 1 + h.$$\n\n为了精确地计算 $y(h)$，使用分离变量法求解初值问题 $y^{\\prime}(t)=-y(t)^{3}$，$y(0)=1$：\n$$\\frac{dy}{dt} = -y^{3} \\quad \\Longrightarrow \\quad \\frac{dy}{y^{3}} = -dt.$$\n对两边积分可得\n$$\\int y^{-3}\\,dy = \\int -1\\,dt \\quad \\Longrightarrow \\quad -\\frac{1}{2}y^{-2} = -t + C.$$\n等价地，\n$$\\frac{1}{2}y^{-2} = t + C^{\\prime}.$$\n代入 $y(0)=1$ 得到 $\\frac{1}{2}=C^{\\prime}$，因此\n$$\\frac{1}{2}y^{-2} = t + \\frac{1}{2} \\quad \\Longrightarrow \\quad y(t)^{-2} = 2t+1 \\quad \\Longrightarrow \\quad y(t) = \\frac{1}{\\sqrt{1+2t}}.$$\n因此，\n$$y(h) = \\frac{1}{\\sqrt{1+2h}}.$$\n当 $h=\\frac{1}{2}$ 时，这给出\n$$y\\!\\left(\\frac{1}{2}\\right) = \\frac{1}{\\sqrt{1+2\\cdot \\frac{1}{2}}} = \\frac{1}{\\sqrt{2}}.$$\n代入到 $\\tau(h)$ 中，\n$$\\tau\\!\\left(\\frac{1}{2}\\right) = \\frac{1}{\\sqrt{2}} - 1 + \\frac{1}{2} = \\frac{1}{\\sqrt{2}} - \\frac{1}{2}.$$\n\n接下来，求 $y^{\\prime\\prime}(0)$。对 $y^{\\prime}=-y^{3}$ 关于 $t$ 求导：\n$$y^{\\prime\\prime} = -3y^{2}y^{\\prime} = -3y^{2}(-y^{3}) = 3y^{5}.$$\n在 $t=0$ 时，$y(0)=1$，所以\n$$y^{\\prime\\prime}(0) = 3.$$\nLTE 的主阶近似为\n$$\\frac{h^{2}}{2}\\,y^{\\prime\\prime}(0) = \\frac{\\left(\\frac{1}{2}\\right)^{2}}{2}\\cdot 3 = \\frac{1}{8}\\cdot 3 = \\frac{3}{8}.$$\n\n从而，所求的比值为\n$$R = \\frac{\\tau\\!\\left(\\frac{1}{2}\\right)}{\\frac{h^{2}}{2}\\,y^{\\prime\\prime}(0)} = \\frac{\\frac{1}{\\sqrt{2}} - \\frac{1}{2}}{\\frac{3}{8}} = \\frac{8}{3}\\left(\\frac{1}{\\sqrt{2}} - \\frac{1}{2}\\right) = \\frac{4(\\sqrt{2}-1)}{3}.$$\n数值上，\n$$R = \\frac{4(\\sqrt{2}-1)}{3} \\approx 0.5522847498\\ldots,$$\n四舍五入到六位有效数字为 $0.552285$。", "answer": "$$\\boxed{0.552285}$$", "id": "2395152"}, {"introduction": "掌握了单步数值方法和误差分析的基础后，我们现在将视野扩展到一个完整的物理系统仿真。钟摆波是一个引人入胜的物理现象，它由一组长度经过精心设计的单摆组成，其动力学由非线性常微分方程 $$\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin(\\theta_n(t)) = 0$$ 描述。本练习模拟了计算科学家的完整工作流程：你将对物理系统进行建模，将二阶常微分方程转化为一阶方程组，并利用数值求解器来模拟钟摆波的形成，从而见证数值方法在探索复杂物理现象中的强大威力。[@problem_id:2403226]", "problem": "考虑一组简单的摆，模型为点质量附着在长度可变的无质量刚性杆上。对于每个由 $n \\in \\{1,2,\\dots,N\\}$ 索引的摆，令 $\\theta_n(t)$ 表示其在时间 $t$ 相对于垂直向下的角位移，正方向选择一致。假设为平面运动，无驱动，无耗散。根据 Newton 第二旋转定律，每个摆的动力学由常微分方程（ODE）决定：\n$$\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin\\big(\\theta_n(t)\\big) = 0,\n$$\n初始条件为\n$$\n\\theta_n(0)=\\theta_0,\\quad \\frac{d\\theta_n}{dt}(0)=0,\n$$\n其中 $g$ 是以 $\\mathrm{m/s^2}$ 为单位的重力加速度，$L_n$ 是第 $n$ 个摆的长度（以 $\\mathrm{m}$ 为单位），角度以弧度表示。为了产生摆波图案，考虑一组目标周期 $\\{T_n\\}_{n=1}^N$，其设计使得在小角度极限下，每个摆在一个共同的对齐时间 $T_{\\mathrm{align}}$ 内完成整数次振荡，即 $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$，其中 $K_n$ 为整数。在小角度近似下，周期为 $T_n = 2\\pi \\sqrt{\\frac{L_n}{g}}$，这意味着长度的选择为\n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\n在下面的所有任务中，使用包含精确 $\\sin(\\theta_n)$ 项的完整非线性常微分方程，而不是小角度近似。使用单位：长度以 $\\mathrm{m}$ 为单位，$g$ 以 $\\mathrm{m/s^2}$ 为单位，时间以 $\\mathrm{s}$ 为单位，角度以弧度为单位。\n\n测试套件和要求输出：\n\n- 测试案例 A（线性设计极限下的小振幅重构相位）：\n  - 参数：$N=15$，$g=9.81\\,\\mathrm{m/s^2}$，$\\theta_0=0.05\\,\\mathrm{rad}$，$T_{\\mathrm{align}}=60\\,\\mathrm{s}$，以及 $K_n = K_0 + N - n$，其中 $K_0=46$。因此，$K_1=60$，$K_{15}=46$，且对于 $n \\in \\{1,\\dots,15\\}$，$L_n = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2$。在 $t \\in [0,T_{\\mathrm{align}}]$ 上模拟每个摆。定义标量\n  $$\n  E_A = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  以浮点数形式报告 $E_A$ 的值，单位为弧度。\n\n- 测试案例 B（较大振幅下的非线性失相）：\n  - 参数：与测试案例 A 相同，除了 $\\theta_0=0.5\\,\\mathrm{rad}$。在 $t \\in [0,T_{\\mathrm{align}}]$ 上进行模拟。定义\n  $$\n  E_B = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  以浮点数形式报告 $E_B$ 的值，单位为弧度。\n\n- 测试案例 C（长度相同的退化对）：\n  - 参数：$N=2$，$L_1=L_2=1.0\\,\\mathrm{m}$，$g=9.81\\,\\mathrm{m/s^2}$，$\\theta_0=0.1\\,\\mathrm{rad}$，模拟区间为 $t \\in [0,T]$，其中 $T=10\\,\\mathrm{s}$。对于这两个初始条件和长度均相同的摆，定义\n  $$\n  E_C = \\max_{t \\in [0,T]} \\left|\\theta_1(t) - \\theta_2(t)\\right|.\n  $$\n  以浮点数形式报告 $E_C$ 的值，单位为弧度。\n\n您的程序必须使用上述常微分方程以及指定的参数和初始条件来计算 $(E_A, E_B, E_C)$。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，顺序为 $[E_A,E_B,E_C]$，例如 $[x_A,x_B,x_C]$，其中每个条目都是一个以弧度为单位的浮点数。不应打印任何其他文本。", "solution": "出发点是单摆的力矩平衡，这是从第一性原理推导出来的。对于在重力 $g$ 作用下、位于长度为 $L_n$ 的无质量刚性杆末端的点质量 $m$，其绕支点的引力力矩为 $\\tau = - m g L_n \\sin(\\theta_n)$。转动惯量为 $I = m L_n^2$。根据 Newton 第二旋转定律 $I \\frac{d^2 \\theta_n}{dt^2} = \\tau$，可得\n$$\nm L_n^2 \\frac{d^2 \\theta_n}{dt^2} = - m g L_n \\sin(\\theta_n)\n\\quad \\Rightarrow \\quad\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin(\\theta_n) = 0.\n$$\n这是一个二阶非线性常微分方程（ODE）初值问题（IVP）。在初始条件 $\\theta_n(0) = \\theta_0$ 和 $\\frac{d\\theta_n}{dt}(0) = 0$ 下，对于每个 $n$ 的解是唯一确定的。\n\n为产生摆波图案，选择的摆长应使得在小角度极限下，每个摆在一个共同的对齐时间 $T_{\\mathrm{align}}$ 内完成整数次振荡。如果小角度周期为 $T_n = 2\\pi \\sqrt{L_n/g}$，并且我们强制要求 $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$（其中 $K_n$ 为整数），那么摆长遵循\n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\n选择一个随 $n$ 严格递减的整数序列 $K_n$ 可以确保摆长 $L_n$ 随 $n$ 严格递增。在测试案例 A 和 B 中，选择 $K_n = K_0 + N - n$ 会得到从 $K_1 = K_0 + N - 1$ 到 $K_N = K_0$ 的序列，因此 $L_1 < L_2 < \\cdots < L_N$。\n\n对于测试案例 A，初始位移 $\\theta_0$ 很小。在线性极限下，经过 $K_n$ 次完整振荡后，每个摆在 $t = T_{\\mathrm{align}}$ 时返回其初始状态，这意味着 $\\theta_n(T_{\\mathrm{align}}) = \\theta_0$，因而 $E_A = 0$。然而，求解包含 $\\sin(\\theta_n)$ 的精确非线性常微分方程会产生一个微小的偏差，因为在非线性情况下周期依赖于振幅；数值 $E_A$ 量化了这一偏差。\n\n对于测试案例 B，初始位移 $\\theta_0$ 更大，振幅相关的周期偏移也更显著。$L_n$ 序列不变，但预计 $E_B$ 会更大，因为非线性效应会导致相对于线性设计的对齐时间 $T_{\\mathrm{align}}$ 发生失相。\n\n对于测试案例 C，两个摆的长度相同 ($L_1 = L_2$) 且初始数据相同 ($\\theta_1(0) = \\theta_2(0) = \\theta_0$ 和 $\\frac{d\\theta_1}{dt}(0) = \\frac{d\\theta_2}{dt}(0) = 0$)，它们的常微分方程是相同的。根据光滑常微分方程解的唯一性，对于所有 $t$ 都有 $\\theta_1(t) \\equiv \\theta_2(t)$。因此，从解析上讲 $E_C = 0$。数值解将得到一个接近零的值，任何偏差都可归因于数值误差和采样。\n\n与这些原则一致的算法纲要：\n- 通过引入 $\\omega_n = \\frac{d\\theta_n}{dt}$，将每个二阶常微分方程表示为一阶系统：\n  $$\n  \\frac{d\\theta_n}{dt} = \\omega_n,\\quad \\frac{d\\omega_n}{dt} = -\\frac{g}{L_n} \\sin(\\theta_n).\n  $$\n- 对于测试案例 A 和 B，对每个 $n \\in \\{1,\\dots,N\\}$，在初始条件 $(\\theta_n(0),\\omega_n(0)) = (\\theta_0,0)$ 下，将系统从 $t=0$ 积分到 $t=T_{\\mathrm{align}}$，并计算 $\\theta_n(T_{\\mathrm{align}})$。将 $E_A$ 或 $E_B$ 计算为所有 $n$ 中与 $\\theta_0$ 的最大绝对偏差。\n- 对于测试案例 C，在相同的初始条件下，将两个相同的摆在 $t \\in [0,T]$ 区间上进行积分，在足够精细的时间网格上对 $\\theta_1(t)$ 和 $\\theta_2(t)$ 进行采样，并计算 $E_C$ 为网格上 $|\\theta_1(t)-\\theta_2(t)|$ 的最大绝对差。\n- 使用指定的单位：$g$ 以 $\\mathrm{m/s^2}$ 为单位，长度以 $\\mathrm{m}$ 为单位，时间以 $\\mathrm{s}$ 为单位，角度以弧度为单位。\n\n最终程序计算三个标量 $(E_A,E_B,E_C)$，并按要求顺序 $[E_A,E_B,E_C]$ 将它们作为逗号分隔的列表打印在单行中，其值以弧度为单位。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef pendulum_rhs(t, y, g, L):\n    theta, omega = y\n    return [omega, -(g / L) * np.sin(theta)]\n\ndef simulate_endpoint_theta(L, theta0, g, t_end, rtol=1e-10, atol=1e-12, method=\"DOP853\"):\n    # Integrate one pendulum to time t_end and return theta(t_end)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, t_end),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=[t_end],\n        dense_output=False,\n        vectorized=False,\n    )\n    theta_T = sol.y[0, -1]\n    return theta_T\n\ndef simulate_theta_time_series(L, theta0, g, T, num_points=5001, rtol=1e-11, atol=1e-13, method=\"DOP853\"):\n    # Integrate one pendulum over [0,T] and return time grid and theta(t) array\n    t_eval = np.linspace(0.0, T, num_points)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, T),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=t_eval,\n        dense_output=False,\n        vectorized=False,\n    )\n    return sol.t, sol.y[0, :]\n\ndef compute_lengths_for_alignment(N, g, T_align, K0):\n    # K_n = K0 + N - n yields increasing lengths with n\n    Ks = np.array([K0 + N - n for n in range(1, N + 1)], dtype=float)\n    # L_n = g * (T_align / (2*pi*K_n))^2\n    Ls = g * (T_align / (2.0 * np.pi * Ks))**2\n    return Ls\n\ndef main():\n    # Constants\n    g = 9.81  # m/s^2\n\n    results = []\n\n    # Test case A\n    N_A = 15\n    T_align_A = 60.0  # s\n    K0_A = 46\n    theta0_A = 0.05  # rad\n    Ls_A = compute_lengths_for_alignment(N_A, g, T_align_A, K0_A)\n    deviations_A = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_A, g, T_align_A)\n        deviations_A.append(abs(theta_T - theta0_A))\n    E_A = float(np.max(deviations_A))\n    results.append(E_A)\n\n    # Test case B (same lengths, larger amplitude)\n    theta0_B = 0.5  # rad\n    deviations_B = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_B, g, T_align_A)\n        deviations_B.append(abs(theta_T - theta0_B))\n    E_B = float(np.max(deviations_B))\n    results.append(E_B)\n\n    # Test case C (two identical pendula)\n    L_C = 1.0  # m\n    theta0_C = 0.1  # rad\n    T_C = 10.0  # s\n    t_grid, theta1 = simulate_theta_time_series(L_C, theta0_C, g, T_C)\n    _, theta2 = simulate_theta_time_series(L_C, theta0_C, g, T_C)  # identical parameters\n    E_C = float(np.max(np.abs(theta1 - theta2)))\n    results.append(E_C)\n\n    # Print results in required format\n    print(f\"[{','.join(f'{x:.12g}' for x in results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "2403226"}]}