{"hands_on_practices": [{"introduction": "本练习将引导你掌握科学计算中的一项基本技术：人造解方法（method of manufactured solutions）。我们不从一个无法解析求解的问题开始，而是从一个已知精确解的函数出发，反向构造一个常微分方程。通过将你的中点法实现的数值结果与这个“真解”进行比较，你不仅可以严格地验证代码的正确性，还能亲眼观察到该方法在实践中如何体现其理论上的二阶收敛特性 [@problem_id:2413529]。", "problem": "考虑以下基于常微分方程人造解法的验证任务。设精确解为标量函数 $y(t)$，定义于 $t \\in [0, T]$，具体如下：\n$$\ny(t) = e^{-2 t}\\,\\big(\\sin(3 t) + t^2\\big),\n$$\n其中三角函数中的所有角度均以弧度为单位。通过将右侧项设为精确解的时间导数，并将初始条件设为初始时间的精确值来定义初值问题：\n$$\n\\frac{dy}{dt} = \\frac{d}{dt}\\Big[e^{-2 t}\\,\\big(\\sin(3 t) + t^2\\big)\\Big], \\quad y(0) = y(0).\n$$\n对于此初值问题，在区间 $[0, T]$ 上使用中点法和均匀时间步长 $h$ 来近似 $y(T)$，其中 $T=2$ 且 $h$ 能整除 $T$，因此步数 $N = T/h$ 为整数。对于给定的 $h$，全局误差是绝对差 $|y_{\\text{num}}(T) - y(T)|$，其中 $y_{\\text{num}}(T)$ 是由中点法产生的数值近似值，$y(T)$ 是精确值。\n\n您的程序必须为以下步长测试集评估全局误差，所有步长的单位与 $t$ 相同：\n- $h = 1.0$（在 $[0, 2]$ 上的一个粗略步长），\n- $h = 0.5$（一次中等程度的细化），\n- $h = 0.2$（一次更精细的细化），\n- $h = 0.05$（一次非常精细的细化）。\n\n要求：\n- 使用上方指定的精确解 $y(t)$ 通过其时间导数定义右侧项，并使用 $y(0)$ 作为初始条件。\n- 计算测试集中每个 $h$ 的全局误差 $|y_{\\text{num}}(T) - y(T)|$。\n- 报告每个误差，四舍五入到12位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起的逗号分隔列表，按测试集的顺序排列结果，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_i$ 是一个四舍五入到12位小数的浮点数。", "solution": "问题陈述已经过验证，被认为是合理的。它提出了一个基于人造解法的适定的验证任务，这是计算科学中用于评估数值格式准确性的标准技术。所有提供的信息都是完整、一致且有科学依据的。\n\n任务是计算中点法对于一个特定的常微分方程 (ODE)，在给定的一组步长下，在一个固定区间上的全局误差。\n\n首先，我们定义初值问题 (IVP) 的组成部分。精确解如下：\n$$\ny(t) = e^{-2 t}\\,\\big(\\sin(3 t) + t^2\\big)\n$$\n对于时间区间 $t \\in [0, T]$，其中最终时间 $T=2$。\n\nIVP 是根据此解构建的。初始条件是精确解在 $t=0$ 时的值：\n$$\ny(0) = e^{-2(0)}\\big(\\sin(3(0)) + 0^2\\big) = 1 \\cdot (0 + 0) = 0\n$$\nODE 的右侧项，我们记为 $f(t, y)$，是精确解的时间导数。由于 $y(t)$ 的导数仅依赖于 $t$，我们可以将 ODE 写成 $\\frac{dy}{dt} = f(t)$。我们使用乘法法则来计算这个导数：\n$$\n\\frac{d}{dt} \\left( u(t) v(t) \\right) = u'(t)v(t) + u(t)v'(t)\n$$\n设 $u(t) = e^{-2t}$ 且 $v(t) = \\sin(3t) + t^2$。它们的导数是：\n$$\nu'(t) = -2e^{-2t}\n$$\n$$\nv'(t) = 3\\cos(3t) + 2t\n$$\n应用乘法法则，我们得到函数 $f(t)$：\n$$\nf(t) = \\frac{dy}{dt} = (-2e^{-2t})\\big(\\sin(3t) + t^2\\big) + (e^{-2t})\\big(3\\cos(3t) + 2t\\big)\n$$\n$$\nf(t) = e^{-2t}\\big(-2\\sin(3t) - 2t^2 + 3\\cos(3t) + 2t\\big)\n$$\n此函数 $f(t)$ 定义了我们 ODE 的右侧项，即 $\\frac{dy}{dt} = f(t)$。\n\n接下来，我们定义数值方法。中点法是一种二阶 Runge-Kutta 方法。对于一般的 ODE $\\frac{dy}{dt} = F(t, y)$，从 $t_n$ 到 $t_{n+1} = t_n + h$ 的单步计算如下：\n$$\nk_1 = F(t_n, y_n)\n$$\n$$\nk_2 = F(t_n + h/2, y_n + (h/2)k_1)\n$$\n$$\ny_{n+1} = y_n + h k_2\n$$\n在我们的特定情况下，右侧项 $F(t, y)$ 与 $y$ 无关，即 $F(t, y) = f(t)$。公式显著简化为：\n$$\nk_1 = f(t_n)\n$$\n$$\nk_2 = f(t_n + h/2)\n$$\n$$\ny_{n+1} = y_n + h f(t_n + h/2)\n$$\n这就是我们将用来近似解的迭代格式。\n\n寻找数值解 $y_{\\text{num}}(T)$ 的算法如下。给定区间 $[0, T] = [0, 2]$ 和一组步长 $h \\in \\{1.0, 0.5, 0.2, 0.05\\}$。对于每个 $h$：\n1.  计算步数 $N = T/h$。对于给定的值，这将是一个整数。\n2.  在起始时间初始化解：$t_0 = 0, y_0 = y(0) = 0$。\n3.  对 $n = 0, 1, 2, \\ldots, N-1$ 进行迭代：\n    -   当前时间是 $t_n = n \\cdot h$。\n    -   当前步长的时间中点是 $t_{n+1/2} = t_n + h/2$。\n    -   解的下一个值计算为 $y_{n+1} = y_n + h \\cdot f(t_{n+1/2})$。\n4.  经过 $N$ 步后，最终时间 $T=2$ 处的数值近似值为 $y_{\\text{num}}(T) = y_N$。\n\n最后，我们计算全局误差。在最终时间 $T=2$ 处的精确值为：\n$$\ny(2) = e^{-2(2)}\\big(\\sin(3 \\cdot 2) + 2^2\\big) = e^{-4}\\big(\\sin(6) + 4\\big)\n$$\n对于给定的步长 $h$，全局误差 $E_h$ 是数值近似值与精确值之间的绝对差：\n$$\nE_h = |y_{\\text{num}}(T) - y(T)| = |y_N - y(2)|\n$$\n对每个指定的 $h$ 值重复此过程。所得误差按要求四舍五入到12位小数。实现将使用数值库来计算指数函数和三角函数，角度按规定使用弧度单位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the verification task for the midpoint method.\n\n    This function implements the method of manufactured solutions to test the\n    midpoint method for a given ordinary differential equation. It computes\n    the global error at T=2 for a suite of step sizes.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # The step sizes h are given in the problem.\n    test_cases = [1.0, 0.5, 0.2, 0.05]\n\n    # Final time T.\n    T = 2.0\n\n    # 1. Define the exact solution y(t)\n    def y_exact(t):\n        \"\"\"\n        The exact manufactured solution.\n        y(t) = exp(-2t) * (sin(3t) + t^2)\n        \"\"\"\n        return np.exp(-2.0 * t) * (np.sin(3.0 * t) + t**2)\n\n    # 2. Define the right-hand side f(t) = dy/dt\n    def f(t):\n        \"\"\"\n        The time derivative of the exact solution, dy/dt.\n        f(t) = exp(-2t) * (3*cos(3t) - 2*sin(3t) + 2t - 2t^2)\n        \"\"\"\n        return np.exp(-2.0 * t) * (\n            3.0 * np.cos(3.0 * t) - 2.0 * np.sin(3.0 * t) + 2.0 * t - 2.0 * t**2\n        )\n\n    # Calculate the exact value at the final time T.\n    y_T_exact = y_exact(T)\n\n    results = []\n    # Loop over each step size h in the test suite.\n    for h in test_cases:\n        # 3. Apply the midpoint method.\n        \n        # Number of steps. Using int(round(...)) to avoid float precision issues.\n        N = int(round(T / h))\n        \n        # Initialize the numerical solution with the exact initial condition.\n        y_num = y_exact(0.0)\n        t = 0.0\n\n        # Iterate N times to reach T.\n        for n in range(N):\n            # Midpoint in time for the current interval [t, t+h]\n            t_mid = t + h / 2.0\n            \n            # Update the solution using the midpoint method for dy/dt = f(t)\n            # y_{n+1} = y_n + h * f(t_n + h/2)\n            y_num = y_num + h * f(t_mid)\n            \n            # Update the current time for the next step.\n            t = (n + 1) * h\n\n        # 4. Compute the global error.\n        # The global error is the absolute difference at the final time T.\n        error = abs(y_num - y_T_exact)\n        \n        # Append the rounded error to the results list.\n        results.append(round(error, 12))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2413529"}, {"introduction": "真实的物理系统常常拥有守恒量，例如能量或动量。本练习将使用著名的 Lotka-Volterra 捕食者-被捕食者模型，来探究数值积分器如何处理这类守恒律，该模型拥有一个非哈密顿系统的守恒量。你将实现中点法来模拟种群动态，并量化这个守恒量随时间的“漂移”，从而深入理解像显式中点法这类非辛积分器在长时间积分中的保真度问题 [@problem_id:2413563]。", "problem": "考虑由以下自治常微分方程组 (ODEs) 控制的相互作用种群的二维 Lotka–Volterra 模型：\n$$\n\\frac{dx}{dt} = x\\,(a - b\\,y), \\quad \\frac{dy}{dt} = y\\,(-c + d\\,x),\n$$\n其中参数 $a>0$、$b>0$、$c>0$、$d>0$，初始条件为 $(x(0),y(0)) = (x_0,y_0)$，且 $x_0>0$ 和 $y_0>0$。该系统有一个光滑的非哈密顿守恒量\n$$\nI(x,y) = d\\,x - c\\,\\ln(x) + b\\,y - a\\,\\ln(y),\n$$\n其中 $\\ln$ 表示自然对数。对于所有使得 $x(t)>0$ 和 $y(t)>0$ 成立的 $t$，沿着精确解 $(x(t),y(t))$，量 $I(x(t),y(t))$ 保持不变。\n\n任务：编写一个完整、可运行的程序，使用显式中点法（即两阶段 Runge–Kutta 中点格式），以固定时间步长 $h$ 将解从时间 $t=0$ 数值推进到时间 $t=T$。对于每个指定的测试用例，计算在最终时刻守恒量的绝对漂移，\n$$\n\\Delta I = \\bigl|\\,I\\bigl(x(T),y(T)\\bigr) - I(x_0,y_0)\\,\\bigr|.\n$$\n此外，对于一对指定的步长，计算由下式定义的不变量漂移误差的观测阶 $p$：\n$$\np = \\frac{\\ln\\!\\bigl(\\Delta I(h_2)/\\Delta I(h_1)\\bigr)}{\\ln\\!\\bigl(h_2/h_1\\bigr)}.\n$$\n\n使用以下测试套件。在所有用例中，参数均为 $a=1.0$、$b=0.5$、$c=0.75$、$d=0.25$，并在 $I(x,y)$ 中使用自然对数。所有时间单位都是任意但一致的，不涉及角度。\n\n- 测试用例 A（一般情况，中等步长）：$(x_0,y_0)=(1.5,1.0)$，$T=20.0$，$h=0.1$。以浮点数形式输出标量 $\\Delta I$。\n- 测试用例 B（一般情况，较小步长）：$(x_0,y_0)=(1.5,1.0)$，$T=20.0$，$h=0.05$。以浮点数形式输出标量 $\\Delta I$。\n- 测试用例 C（使用 A 和 B 计算观测误差阶）：设 $h_1=0.1$，$h_2=0.05$，且 $(x_0,y_0)=(1.5,1.0)$，$T=20.0$。使用在这些相同参数下，由 $h_1$ 和 $h_2$ 得到的 $\\Delta I$ 值来计算 $p$。以浮点数形式输出标量 $p$。\n- 测试用例 D（平衡初始条件）：$(x_0,y_0)=(c/d,\\,a/b)$，$T=9.0$，$h=0.3$。以浮点数形式输出标量 $\\Delta I$。\n- 测试用例 E（时间上的边界条件）：$(x_0,y_0)=(1.2,0.8)$，$T=0.0$，$h=0.1$。以浮点数形式输出标量 $\\Delta I$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [A,B,C,D,E]。列表中的每个浮点数在打印前必须四舍五入到 $10$ 位小数，例如 $[0.1234567890,0.0000000000,2.0000000000,0.0000000000,0.0000000000]$。", "solution": "所提出的问题是计算物理学中一个适定的初值问题，需要对 Lotka-Volterra 方程进行数值积分。该问题在科学上是合理的，内部一致，并包含获得唯一解所需的所有必要信息。验证标准已满足。\n\n该系统由一对描述两个相互作用种群 $x(t)$ 和 $y(t)$ 的自治常微分方程 (ODEs) 定义：\n$$\n\\frac{dx}{dt} = x(a - by)\n$$\n$$\n\\frac{dy}{dt} = y(-c + dx)\n$$\n其中 $a, b, c, d$ 是正实数参数。该系统可以写成向量形式 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{f}(\\mathbf{u})$，其中 $\\mathbf{u}(t) = [x(t), y(t)]^T$，向量场 $\\mathbf{f}$ 由下式给出：\n$$\n\\mathbf{f}(\\mathbf{u}) = \\begin{pmatrix} x(a - by) \\\\ y(-c + dx) \\end{pmatrix}\n$$\n该问题要求使用显式中点法，以固定时间步长 $h$，将解从时间 $t=0$ 的初始状态 $\\mathbf{u}_0 = (x_0, y_0)$ 推进到最终时间 $t=T$。显式中点法是一种二阶 Runge-Kutta 格式，其将解从时间 $t_n$ 的 $\\mathbf{u}_n$ 推进到时间 $t_{n+1} = t_n + h$ 的 $\\mathbf{u}_{n+1}$ 的步骤定义如下：\n\n1. 计算第一阶段，即在当前点 $\\mathbf{u}_n$ 的斜率：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{u}_n)\n$$\n2. 使用 $\\mathbf{k}_1$ 估计在时间中点 $t_n + h/2$ 处的状态：\n$$\n\\mathbf{u}_{\\text{mid}} = \\mathbf{u}_n + \\frac{h}{2} \\mathbf{k}_1\n$$\n3. 计算第二阶段，即在估计的中点状态 $\\mathbf{u}_{\\text{mid}}$ 处的斜率：\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{u}_{\\text{mid}})\n$$\n4. 使用中点斜率 $\\mathbf{k}_2$ 计算最终状态 $\\mathbf{u}_{n+1}$：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + h \\mathbf{k}_2\n$$\n重复此过程共 $N = T/h$ 步，以获得 $\\mathbf{u}(T) = [x(T),y(T)]^T$ 的数值近似解。\n\n问题指出 Lotka-Volterra 系统拥有一个守恒量：\n$$\nI(x,y) = dx - c\\ln(x) + by - a\\ln(y)\n$$\n对于精确解 $(x(t), y(t))$，$I(x(t), y(t))$ 保持不变。然而，诸如显式中点法之类的数值方法通常不能精确保持此类不变量。数值不变量随时间的变化是衡量该方法误差的一个指标。我们被要求计算在最终时间 $T$ 的绝对漂移 $\\Delta I$：\n$$\n\\Delta I = |I(x(T), y(T)) - I(x_0, y_0)|\n$$\n对于一个 $p$ 阶方法，全局误差应具有 $O(h^p)$ 的量级。对于非辛积分器，守恒量的漂移 $\\Delta I(h)$ 也应表现出这种缩放行为。观测收敛阶 $p$ 可以根据两个不同步长 $h_1$ 和 $h_2$ 的结果，使用以下公式计算：\n$$\np = \\frac{\\ln(\\Delta I(h_2) / \\Delta I(h_1))}{\\ln(h_2 / h_1)}\n$$\n\n所提供的测试用例如下分析：\n- **用例 A 和 B**：这是使用不同步长（$h=0.1$ 和 $h=0.05$）的标准数值积分。结果将是 $\\Delta I$ 的非零值。\n- **用例 C**：这需要根据用例 A 和 B 的结果计算观测阶 $p$。由于显式中点法是二阶方法（$p_{theory}=2$），结果应接近于 $2$。\n- **用例 D**：初始条件 $(x_0, y_0) = (c/d, a/b)$ 对应于系统的非平凡不动点（或平衡点），在该点上 $dx/dt = 0$ 且 $dy/dt = 0$。对于一个相容的数值方法，如果模拟从一个不动点开始，它应该在所有时间内都保持在该点（在机器精度范围内）。因此，$(x(T), y(T)) = (x_0, y_0)$，我们预期 $\\Delta I = 0$。\n- **用例 E**：积分是在一个长度为零的时间区间（$T=0$）上进行的。没有进行任何时间步进，所以最终状态与初始状态相同。因此，$(x(T), y(T)) = (x_0, y_0)$，我们预期 $\\Delta I = 0$。\n\n将实现以下算法：\n1. 对于每个测试用例，获取参数 $a, b, c, d$ 和初始/最终条件 $x_0, y_0, T, h$。\n2. 实现一个函数 `run_simulation`，该函数使用显式中点法执行时间步进循环。\n3. 实现一个函数 `I(x, y, ...)` 来计算守恒量。\n4. 对于用例 A、B、D 和 E，首先计算初始值 $I(x_0, y_0)$，然后运行模拟找到 $(x_T, y_T)$，再计算最终值 $I(x_T, y_T)$，最后取它们的绝对差值来计算 $\\Delta I$。\n5. 对于用例 C，使用从用例 A 和 B 中计算出的 $\\Delta I$ 值来计算 $p$。\n6. 收集所有结果，将它们格式化为 $10$ 位小数，并以指定的列表格式打印出来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra problem for the given test cases.\n    \"\"\"\n    \n    # Define problem parameters\n    a, b, c, d = 1.0, 0.5, 0.75, 0.25\n\n    # Define the test cases from the problem statement.\n    # Format: (x0, y0, T, h)\n    test_cases = [\n        (1.5, 1.0, 20.0, 0.1),        # Case A\n        (1.5, 1.0, 20.0, 0.05),       # Case B\n        # Case C is derived from A and B\n        (c / d, a / b, 9.0, 0.3),     # Case D\n        (1.2, 0.8, 0.0, 0.1),         # Case E\n    ]\n\n    def conserved_quantity(x, y, a, b, c, d):\n        \"\"\"Computes the conserved quantity I(x, y).\"\"\"\n        return d * x - c * np.log(x) + b * y - a * np.log(y)\n\n    def run_simulation(x0, y0, T, h, a, b, c, d):\n        \"\"\"\n        Advances the Lotka-Volterra system using the explicit midpoint method.\n        \"\"\"\n        if T == 0.0:\n            return float(x0), float(y0)\n\n        num_steps = int(np.round(T / h))\n        x, y = float(x0), float(y0)\n\n        for _ in range(num_steps):\n            # Stage 1: Slope at current point\n            k1x = x * (a - b * y)\n            k1y = y * (-c + d * x)\n            \n            # State at midpoint\n            x_mid = x + 0.5 * h * k1x\n            y_mid = y + 0.5 * h * k1y\n\n            # Stage 2: Slope at midpoint\n            k2x = x_mid * (a - b * y_mid)\n            k2y = y_mid * (-c + d * x_mid)\n\n            # Update step using midpoint slope\n            x += h * k2x\n            y += h * k2y\n            \n        return x, y\n\n    # List to store final computed values for [A, B, C, D, E]\n    results = []\n    \n    # Store delta_I for cases A and B to use for C\n    delta_I_ab = []\n\n    # Process cases A and B\n    for params in test_cases[:2]:\n        x0, y0, T, h = params\n        I0 = conserved_quantity(x0, y0, a, b, c, d)\n        xT, yT = run_simulation(x0, y0, T, h, a, b, c, d)\n        IT = conserved_quantity(xT, yT, a, b, c, d)\n        delta_I = np.abs(IT - I0)\n        results.append(delta_I)\n        delta_I_ab.append(delta_I)\n\n    # Process case C (Observed order p)\n    h1 = test_cases[0][3]  # h from Case A\n    h2 = test_cases[1][3]  # h from Case B\n    delta_I_h1 = delta_I_ab[0]\n    delta_I_h2 = delta_I_ab[1]\n    \n    # The order p is calculated using the drift values from A and B\n    p = np.log(delta_I_h2 / delta_I_h1) / np.log(h2 / h1)\n    results.append(p)\n    \n    # Process cases D and E\n    for params in test_cases[2:]:\n        x0, y0, T, h = params\n        I0 = conserved_quantity(x0, y0, a, b, c, d)\n        xT, yT = run_simulation(x0, y0, T, h, a, b, c, d)\n        IT = conserved_quantity(xT, yT, a, b, c, d)\n        delta_I = np.abs(IT - I0)\n        results.append(delta_I)\n    \n    # Final print statement in the exact required format.\n    # Each float is rounded to 10 decimal places.\n    formatted_results = [f\"{val:.10f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2413563"}, {"introduction": "使用固定的步长通常效率不高；一个强大的求解器应当在解剧烈变化时采用小步长，而在解平缓时采用大步长。本实践将指导你把基本的中点法升级为一个功能强大的自适应积分器。你将通过实现一种“步长加倍”的误差估计方案来控制局部误差，并自动调整步长 $h$ 以满足预设的容差，这是构建现代高效常微分方程求解器的基石技术 [@problem_id:2413547]。", "problem": "你的任务是编写一个完整的、可运行的程序，该程序使用显式中点法和一个基于比较大小为 $h$ 的单步与大小为 $h/2$ 的两步的自适应步长控制器，来求解一个标量常微分方程（ODE）。考虑一个形式为 $y'(t) = f(t,y)$、初始条件为 $y(t_0) = y_0$ 的标量ODE，其中 $t$ 是时间，$y$ 是状态变量。\n\n你的程序必须实现以下数学规范：\n\n- 对于步长为 $h$，显式中点法的单步更新为\n$$\n\\Phi_h(t,y) \\equiv y + h \\, f\\!\\left(t + \\frac{h}{2},\\, y + \\frac{h}{2} f(t,y)\\right).\n$$\n\n- 将单次全步长近似定义为 $y_h = \\Phi_h(t,y)$。通过先计算 $y_{h/2}^{(1)} = \\Phi_{h/2}(t,y)$，然后计算 $y_{h/2}^{(2)} = \\Phi_{h/2}(t + h/2,\\, y_{h/2}^{(1)})$ 来定义两次半步长的组合。使用 $y_{h/2}^{(2)}$ 作为步末更高质量的近似值。\n\n- 对于步长为 $h$ 的一步，其局部误差估计由下式给出\n$$\n\\mathrm{err} = \\frac{\\lvert y_{h/2}^{(2)} - y_h \\rvert}{2^2 - 1}.\n$$\n\n- 对于给定的绝对容差 $\\mathrm{atol}$ 和相对容差 $\\mathrm{rtol}$，定义标量接受阈值\n$$\n\\tau = \\mathrm{atol} + \\mathrm{rtol} \\cdot \\max\\!\\big(\\lvert y_h \\rvert,\\, \\lvert y_{h/2}^{(2)} \\rvert\\big).\n$$\n如果 $\\mathrm{err} \\le \\tau$，则接受该步。当一个步骤被接受时，推进 $(t,y) \\leftarrow (t+h,\\, y_{h/2}^{(2)})$。\n\n- 对于每次尝试的步骤（无论接受或拒绝），根据控制器更新步长\n$$\nh_{\\mathrm{new}} = h \\cdot \\mathrm{clip}\\!\\left(s \\left(\\frac{\\tau}{\\mathrm{err}}\\right)^{1/3},\\, \\alpha_{\\min},\\, \\alpha_{\\max}\\right),\n$$\n其中 $s$ 是一个安全因子，指数 $1/3$ 源于二阶方法的主局部误差为 $h^3$ 阶，而 $\\mathrm{clip}(x, a, b)$ 将 $x$ 约束在区间 $[a,b]$ 内。如果 $\\mathrm{err} = 0$，则使用最大增长因子，即将乘法项设置为 $\\alpha_{\\max}$。通过必要时截断最后一步来确保 $h$ 不会越过目标最终时间，从而精确到达最终时间 $t_{\\mathrm{end}}$。任何三角函数中出现的角度都必须解释为弧度。\n\n- 使用固定的控制器参数 $s = 0.9$，$\\alpha_{\\min} = 0.2$，$\\alpha_{\\max} = 5.0$，以及最小步长 $h_{\\min} = 10^{-16}$。如果在到达 $t_{\\mathrm{end}}$ 之前 $h$ 降至 $h_{\\min}$ 以下，则终止积分并返回当前的近似值。\n\n实现该积分器，并将其应用于以下测试套件。每个测试用例都指定了 $f(t,y)$、$t_0$、$y_0$、$t_{\\mathrm{end}}$、初始步长 $h_0$、$\\mathrm{rtol}$ 和 $\\mathrm{atol}$。所有数字都是无单位的。所有角度都以弧度为单位。\n\n- 测试用例 1 (指数衰减):\n  - $f(t,y) = -2\\, y$,\n  - $t_0 = 0$,\n  - $y_0 = 1$,\n  - $t_{\\mathrm{end}} = 1$,\n  - $h_0 = 0.1$,\n  - $\\mathrm{rtol} = 10^{-8}$,\n  - $\\mathrm{atol} = 10^{-12}$。\n\n- 测试用例 2 (单位承载能力的逻辑斯谛增长):\n  - $f(t,y) = y \\, (1 - y)$,\n  - $t_0 = 0$,\n  - $y_0 = 0.2$,\n  - $t_{\\mathrm{end}} = 5$,\n  - $h_0 = 0.2$,\n  - $\\mathrm{rtol} = 10^{-7}$,\n  - $\\mathrm{atol} = 10^{-12}$。\n\n- 测试用例 3 (带三角函数强迫项的线性方程):\n  - $f(t,y) = \\cos(t) - y$,\n  - $t_0 = 0$,\n  - $y_0 = 0$,\n  - $t_{\\mathrm{end}} = 4$,\n  - $h_0 = 0.1$,\n  - $\\mathrm{rtol} = 10^{-9}$,\n  - $\\mathrm{atol} = 10^{-12}$。\n\n- 测试用例 4 (快速指数衰减):\n  - $f(t,y) = -50\\, y$,\n  - $t_0 = 0$,\n  - $y_0 = 1$,\n  - $t_{\\mathrm{end}} = 0.1$,\n  - $h_0 = 0.05$,\n  - $\\mathrm{rtol} = 10^{-6}$,\n  - $\\mathrm{atol} = 10^{-12}$。\n\n你的程序必须按所列顺序运行所有四个测试用例，并对每个用例返回 $y(t_{\\mathrm{end}})$ 的数值近似值。最终输出必须是单行，包含一个Python风格的列表，其中含有四个十进制数结果，每个数都四舍五入到恰好 $10$ 位小数，并按测试套件的顺序排列，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是一个小数点后有 $10$ 位数字的浮点数。你的程序必须以此格式精确地产生一行输出，并且不得读取任何输入。", "solution": "所述问题是有效的。它提出了计算物理学中一个明确定义的任务：使用显式中点法和自适应步长控制器对标量常微分方程（ODE）进行数值积分。该问题在科学上是合理的、自洽的，并且所有参数和数学关系都得到了明确的规定。我现在将提供解决方案。\n\n求解形式为 $y'(t) = f(t,y)$ 且初始条件为 $y(t_0) = y_0$ 的ODE，其根本挑战在于使用离散点序列来近似 $y(t)$ 的连续轨迹。自适应步长积分器优于固定步长积分器，因为它会调整步长 $h$ 以维持所需的精度水平，同时最小化计算开销，在解变化迅速的区域采取小步长，在解平滑的区域采取大步长。\n\n该积分器的核心是显式中点法，一种二阶 Runge-Kutta 方法。对于从时间 $t$ 到 $t+h$ 的一步，状态 $y$ 使用单步更新函数 $\\Phi_h(t,y)$ 进行推进：\n$$\n\\Phi_h(t,y) = y + h \\, f\\!\\left(t + \\frac{h}{2},\\, y + \\frac{h}{2} f(t,y)\\right)\n$$\n这个公式可以解释为一个两阶段过程。首先，在区间中点 $t+h/2$ 处估计一个中间状态。其次，使用该中点处的斜率在整个区间 $h$ 上进行外推。\n\n为了自适应地控制步长，我们需要一个局部截断误差的估计——即单步内产生的误差。问题指定了一种步长加倍的方法。在此方法中，我们用两种方式计算在 $t+h$ 处的解：\n1. 大小为 $h$ 的单步，得到 $y_h = \\Phi_h(t,y)$。\n2. 两次大小为 $h/2$ 的连续步骤，得到 $y_{h/2}^{(2)} = \\Phi_{h/2}(t + h/2, \\Phi_{h/2}(t,y))$。\n\n由于显式中点法的局部截断误差为 $O(h^3)$ 阶，精确解 $y(t+h)$ 可以与我们的数值近似值相关联：\n$$\ny_h = y(t+h) + C h^3 + O(h^4)\n$$\n$$\ny_{h/2}^{(2)} = y(t+h) + 2 C (h/2)^3 + O(h^4) = y(t+h) + \\frac{1}{4} C h^3 + O(h^4)\n$$\n其中 $C$ 是一个与解的导数相关的常数。通过将这两个方程相减，我们可以消除未知的真值 $y(t+h)$，并解出误差项 $\\frac{1}{4} C h^3$，这正是更精确的两步近似 $y_{h/2}^{(2)}$ 的误差。该误差的大小估计为：\n$$\n\\mathrm{err} = \\lvert y(t+h) - y_{h/2}^{(2)} \\rvert \\approx \\frac{\\lvert y_{h/2}^{(2)} - y_h \\rvert}{2^p - 1} = \\frac{\\lvert y_{h/2}^{(2)} - y_h \\rvert}{3}\n$$\n其中 $p=2$ 是方法的阶数。\n\n然后将此误差估计与期望的容差阈值 $\\tau$ 进行比较，该阈值是绝对容差 $\\mathrm{atol}$ 和相对容差 $\\mathrm{rtol}$ 的组合：\n$$\n\\tau = \\mathrm{atol} + \\mathrm{rtol} \\cdot \\max\\!\\big(\\lvert y_h \\rvert,\\, \\lvert y_{h/2}^{(2)} \\rvert\\big)\n$$\n如果 $\\mathrm{err} \\le \\tau$，则接受该步，并使用更精确的近似值将状态推进到 $(t+h, y_{h/2}^{(2)})$。如果 $\\mathrm{err} > \\tau$，则拒绝该步，并从同一点 $(t,y)$ 以更小的步长重新尝试该步。\n\n下一次尝试的步长（无论当前步是被接受还是被拒绝）由一个比例-积分（PI）控制器公式确定：\n$$\nh_{\\mathrm{new}} = h \\cdot \\mathrm{clip}\\!\\left(s \\left(\\frac{\\tau}{\\mathrm{err}}\\right)^{1/(p+1)},\\, \\alpha_{\\min},\\, \\alpha_{\\max}\\right)\n$$\n此处，$s=0.9$ 是一个用于促进稳定性的安全因子。对于我们的二阶方法，指数为 $1/(p+1)=1/3$。比率 $\\tau/\\mathrm{err}$ 用于缩放步长：如果误差小于容差，则增加步长；如果误差大于容差，则减小步长。$\\mathrm{clip}$ 函数，其最小和最大因子分别为 $\\alpha_{\\min}=0.2$ 和 $\\alpha_{\\max}=5.0$，可防止对步长进行过于激进的更改。如果 $\\mathrm{err}=0$，则将步长乘以最大因子 $\\alpha_{\\max}$。\n\n完整的积分算法如下：\n初始化 $t=t_0$，$y=y_0$ 和初始步长 $h=h_0$。循环直到 $t$ 到达 $t_{\\mathrm{end}}$：\n1.  检查当前步是否会越过 $t_{\\mathrm{end}}$。如果是，则设置 $h = t_{\\mathrm{end}} - t$。\n2.  为当前步的尝试进入一个内部循环。\n3.  检查当前 $h$ 是否低于最小阈值 $h_{\\min}$。如果是，则终止积分。\n4.  计算 $y_h$ 和 $y_{h/2}^{(2)}$。\n5.  计算误差 $\\mathrm{err}$ 和容差 $\\tau$。\n6.  如果该步被接受（$\\mathrm{err} \\le \\tau$）：\n    a.  推进状态：$t \\leftarrow t+h$，$y \\leftarrow y_{h/2}^{(2)}$。\n    b.  使用控制器公式计算下一步的步长 $h_{\\mathrm{new}}$。更新 $h \\leftarrow h_{\\mathrm{new}}$。\n    c.  退出内部循环，继续下一个积分步骤。\n7.  如果该步被拒绝（$\\mathrm{err} > \\tau$）：\n    a.  计算一个新的、更小的步长 $h_{\\mathrm{new}}$。更新 $h \\leftarrow h_{\\mathrm{new}}$。\n    b.  重复内部循环，用较小的 $h$ 从同一点 $(t,y)$ 重新尝试该步。\n\n重复此过程直到 $t=t_{\\mathrm{end}}$，此时 $y$ 的最终值就是所需的数值解。将对四个指定的测试用例中的每一个实施该算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adaptive_midpoint_integrator(f, t0, y0, t_end, h0, rtol, atol):\n    \"\"\"\n    Integrates a scalar ODE y'(t) = f(t,y) using an adaptive explicit midpoint method.\n\n    Args:\n        f (callable): The function f(t, y).\n        t0 (float): Initial time.\n        y0 (float): Initial state.\n        t_end (float): Final time.\n        h0 (float): Initial step size.\n        rtol (float): Relative tolerance.\n        atol (float): Absolute tolerance.\n\n    Returns:\n        float: The numerical approximation of y(t_end).\n    \"\"\"\n    \n    # --- Controller parameters ---\n    S = 0.9          # Safety factor\n    ALPHA_MIN = 0.2  # Minimum step size scaling factor\n    ALPHA_MAX = 5.0  # Maximum step size scaling factor\n    H_MIN = 1e-16    # Minimum allowed step size\n\n    # --- One-step explicit midpoint update function ---\n    def phi(t_n, y_n, h_n, func):\n        \"\"\"Computes one step of the explicit midpoint method.\"\"\"\n        k1 = func(t_n, y_n)\n        y_mid = y_n + 0.5 * h_n * k1\n        t_mid = t_n + 0.5 * h_n\n        k2 = func(t_mid, y_mid)\n        return y_n + h_n * k2\n\n    # --- Initial conditions ---\n    t = float(t0)\n    y = float(y0)\n    h = float(h0)\n    \n    # --- Main integration loop ---\n    while t  t_end:\n        # Ensure the final step lands exactly on t_end\n        if t + h > t_end:\n            h = t_end - t\n\n        # --- Adaptive step control loop (accept/reject) ---\n        while True:\n            # Check for termination due to excessively small step size\n            if h  H_MIN:\n                return y \n\n            # Calculate one full step\n            y_h = phi(t, y, h, f)\n\n            # Calculate two half steps\n            h_half = h / 2.0\n            y_half_1 = phi(t, y, h_half, f)\n            y_half_2 = phi(t + h_half, y_half_1, h_half, f)\n\n            # Estimate local error\n            # Denominator is (2^p - 1) where p=2 for midpoint method\n            error_diff = abs(y_half_2 - y_h)\n            err = error_diff / 3.0\n\n            # Calculate tolerance threshold\n            y_scale = max(abs(y_h), abs(y_half_2))\n            tau = atol + rtol * y_scale\n\n            # Check for step acceptance\n            if err = tau:\n                # --- Step accepted ---\n                t += h\n                y = y_half_2  # Use the more accurate result\n                \n                # Calculate step size for the next step\n                if err == 0.0:\n                    factor = ALPHA_MAX\n                else:\n                    factor = S * (tau / err)**(1.0/3.0)\n                \n                # Clip factor and update h\n                h = h * min(ALPHA_MAX, max(ALPHA_MIN, factor))\n                \n                # Exit the inner loop to proceed to the next t\n                break\n            else:\n                # --- Step rejected ---\n                # Calculate a new, smaller step size and retry this step\n                if err == 0.0:\n                    # Should not be reached if err > tau, but for robustness\n                    factor = ALPHA_MIN\n                else:\n                    factor = S * (tau / err)**(1.0/3.0)\n                \n                # Clip the reducing factor and update h for the retry\n                h_new = h * min(ALPHA_MAX, max(ALPHA_MIN, factor))\n                h = h_new\n\n    return y\n\ndef solve():\n    \"\"\"\n    Runs the adaptive midpoint integrator on a suite of test cases and\n    prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (exponential decay)\n        {\n            \"f\": lambda t, y: -2.0 * y,\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"t_end\": 1.0,\n            \"h0\": 0.1,\n            \"rtol\": 1e-8,\n            \"atol\": 1e-12,\n        },\n        # Test case 2 (logistic growth)\n        {\n            \"f\": lambda t, y: y * (1.0 - y),\n            \"t0\": 0.0,\n            \"y0\": 0.2,\n            \"t_end\": 5.0,\n            \"h0\": 0.2,\n            \"rtol\": 1e-7,\n            \"atol\": 1e-12,\n        },\n        # Test case 3 (linear equation with trigonometric forcing)\n        {\n            \"f\": lambda t, y: np.cos(t) - y,\n            \"t0\": 0.0,\n            \"y0\": 0.0,\n            \"t_end\": 4.0,\n            \"h0\": 0.1,\n            \"rtol\": 1e-9,\n            \"atol\": 1e-12,\n        },\n        # Test case 4 (fast exponential decay)\n        {\n            \"f\": lambda t, y: -50.0 * y,\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"t_end\": 0.1,\n            \"h0\": 0.05,\n            \"rtol\": 1e-6,\n            \"atol\": 1e-12,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        final_y = adaptive_midpoint_integrator(\n            f=case[\"f\"],\n            t0=case[\"t0\"],\n            y0=case[\"y0\"],\n            t_end=case[\"t_end\"],\n            h0=case[\"h0\"],\n            rtol=case[\"rtol\"],\n            atol=case[\"atol\"],\n        )\n        results.append(final_y)\n\n    # Format the final output string as required\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2413547"}]}