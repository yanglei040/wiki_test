{"hands_on_practices": [{"introduction": "这个练习将数值稳定性的抽象概念转化为一次直接的、互动的体验。在这个“稳定性游戏”中，你将亲手探索显式欧拉法的局限性。通过为同一个刚性问题手动选择不同的时间步长 $\\Delta t$，你将直观地观察到数值解如何因为步长选择不当而急剧发散，从而深刻理解为什么稳定性条件不仅是理论推导，更是一个在实践中必须严格遵守的壁垒。[@problem_id:2442901]", "problem": "设计并实现一个完整、可运行的程序，该程序将针对常微分方程（ODE）中的一个刚性初值问题，把时间步长的选择问题转化为一个稳定性“游戏”。你的任务是利用第一性原理来形式化地描述以下挑战。\n\n考虑自治线性常微分方程\n$$\n\\frac{dy}{dt} = -\\lambda\\, y,\n$$\n及其初始条件\n$$\ny(0) = y_0,\n$$\n其中 $\\lambda \\gt 0$ 是一个大参数，导致该问题成为刚性问题。请在无量纲变量下进行计算，不涉及任何物理单位。\n\n仅从数值分析和微积分的基本定义出发，完成以下步骤。\n\n1) 使用导数的定义和在 $t_n$ 处的一阶有限差分，推导出前向（显式）Euler 更新格式。使用同样的基础和在 $t_{n+1}$ 处的一阶有限差分，推导出后向（隐式）Euler 更新格式。不得预先假定任何更新法则；每一个都必须从 $\\frac{dy}{dt}$ 的定义以及步长关系 $t_{n+1} = t_n + \\Delta t$ 进行推导。\n\n2) 对于这两种积分器，当右端项为 $-\\lambda y$ 时，确定由推导出的更新格式所隐含的单步放大因子。使用绝对稳定性的概念：当且仅当此单步放大因子的模严格小于 $1$ 时，离散轨迹是绝对稳定的；否则是不稳定的。为了本游戏的目的，模等于 $1$ 的临界情况必须视为不稳定。\n\n3) 在区间 $[0,T]$ 上，使用均匀步长 $\\Delta t$，将两种方法实现为时间步进算法。精确推进 $N$ 步，其中 $N = T/\\Delta t$（所有提供的 $\\Delta t$ 值都能被 $T$ 整除）。除了根据放大因子计算稳定性分类外，还需模拟轨迹 $y_n$，并记录整个步进过程中所达到的最大绝对值，作为行为诊断。\n\n4) 游戏目标是选择合适的 $\\Delta t$，以使显式 Euler 方法保持绝对稳定。对于下方的每个测试用例，你必须根据第 2 项中的绝对稳定性准则，报告显式 Euler 方法是否不稳定（即“失败”状态）。\n\n测试套件：\n- 刚性参数：$\\lambda = 1000$。\n- 初始值：$y_0 = 1$。\n- 终止时间：$T = 1$。\n- 时间步长：$\\Delta t \\in \\{\\, 0.0005,\\ 0.0020,\\ 0.0025 \\,\\}$。\n\n对于测试套件中的每个 $\\Delta t$，在 $[0,T]$ 上运行显式和隐式 Euler 方法，并确定一个标量输出 $r$，其定义如下：\n- $r = 1$：如果根据第 2 项的绝对稳定性准则，显式 Euler 方法不稳定（即其放大因子的模大于或等于 $1$）。\n- $r = 0$：其他情况。\n\n最终输出格式：\n你的程序应该生成单行输出，其中包含用方括号括起来并以逗号分隔的结果列表，结果的顺序与所提供的时间步长顺序相同。例如，打印的行应形如\n$$\n[ r_1, r_2, r_3 ]\n$$\n但不含空格，即严格为 $[r_1,r_2,r_3]$ 的格式，其中每个 $r_k$ 是整数 $0$ 或 $1$，分别对应于 $\\Delta t = 0.0005$、$\\Delta t = 0.0020$ 和 $\\Delta t = 0.0025$。", "solution": "所述问题是有效的。这是一个关于常微分方程（ODE）数值分析的适定且有科学依据的练习，重点关注刚性和数值稳定性这两个关键概念。问题的前提在事实上是正确的，所用术语精确，目标也清晰明确。我们将根据第一性原理进行严谨的推导和求解。\n\n控制方程为线性自治常微分方程：\n$$\n\\frac{dy}{dt} = -\\lambda y, \\quad y(0) = y_0\n$$\n其中 $\\lambda > 0$ 是一个大常数，这是刚性系统的特征。其精确解为 $y(t) = y_0 e^{-\\lambda t}$，该解会快速衰减至零。一个数值方法必须能够重现这种衰减，而不引入伪振荡或发散。\n\n**1. 从第一性原理推导 Euler 积分器**\n\n我们使用均匀步长 $\\Delta t$ 对时间连续统进行离散化，即 $t_n = n \\Delta t$。在 $t_n$ 处的解的数值近似值记为 $y_n$。导数 $\\frac{dy}{dt}$ 由以下极限定义：\n$$\n\\frac{dy}{dt} = \\lim_{\\Delta t \\to 0} \\frac{y(t+\\Delta t) - y(t)}{\\Delta t}\n$$\n\n**前向（显式）Euler 方法：**\n为了推导前向 Euler 更新格式，我们通过去掉导数定义中的极限，使用一阶前向有限差分来近似在时间 $t_n$ 处的导数：\n$$\n\\frac{dy}{dt}\\bigg|_{t=t_n} \\approx \\frac{y(t_{n+1}) - y(t_n)}{\\Delta t}\n$$\n将此近似代入常微分方程 $\\frac{dy}{dt} = -\\lambda y$，并在已知的时间步 $t_n$ 对所有项求值，得到：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = -\\lambda y_n\n$$\n重新整理以求解未知值 $y_{n+1}$，得到显式更新法则：\n$$\ny_{n+1} = y_n + \\Delta t (-\\lambda y_n) = (1 - \\lambda \\Delta t) y_n\n$$\n该方法被称为“显式”的，因为 $y_{n+1}$ 可以直接使用在第 $n$ 步已知的值计算出来。\n\n**后向（隐式）Euler 方法：**\n为了推导后向 Euler 更新格式，我们使用一阶后向有限差分来近似导数，但求值点在下一个时间步 $t_{n+1}$：\n$$\n\\frac{dy}{dt}\\bigg|_{t=t_{n+1}} \\approx \\frac{y(t_{n+1}) - y(t_n)}{\\Delta t}\n$$\n为保持一致性，常微分方程的右端项也必须在 $t_{n+1}$ 处求值：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = -\\lambda y_{n+1}\n$$\n为了求出 $y_{n+1}$，我们必须对该方程进行代数求解。\n$$\ny_{n+1} + \\lambda \\Delta t y_{n+1} = y_n \\implies y_{n+1}(1 + \\lambda \\Delta t) = y_n\n$$\n分离出 $y_{n+1}$ 得到隐式更新法则：\n$$\ny_{n+1} = \\frac{1}{1 + \\lambda \\Delta t} y_n\n$$\n该方法是“隐式”的，因为 $y_{n+1}$ 出现在初始方程的两边，需要一个求解步骤来推进解。\n\n**2. 放大因子与绝对稳定性分析**\n\n对于这两种方法，更新法则的形式均为 $y_{n+1} = G y_n$，其中标量 $G$ 是单步放大因子。数值解保持稳定，当且仅当误差不会随步数增加而增长。绝对稳定性的条件是放大因子的模必须严格小于一：$|G| < 1$。问题指明，模等于 $1$ 的临界情况应被视为不稳定。\n\n**前向 Euler 稳定性：**\n放大因子为 $G_{FE} = 1 - \\lambda \\Delta t$。稳定性条件为：\n$$\n|1 - \\lambda \\Delta t| < 1\n$$\n由于 $\\lambda > 0$ 且 $\\Delta t > 0$，我们有 $\\lambda \\Delta t > 0$。该不等式变为：\n$$\n-1 < 1 - \\lambda \\Delta t < 1\n$$\n右侧不等式 $1 - \\lambda \\Delta t < 1$ 意味着 $-\\lambda \\Delta t < 0$，该条件始终满足。左侧不等式 $-1 < 1 - \\lambda \\Delta t$ 得出 $\\lambda \\Delta t < 2$。\n因此，前向 Euler 方法是条件稳定的，要求 $\\Delta t < \\frac{2}{\\lambda}$。对于不稳定情况，其准则为 $\\Delta t \\ge \\frac{2}{\\lambda}$。\n\n**后向 Euler 稳定性：**\n放大因子为 $G_{BE} = \\frac{1}{1 + \\lambda \\Delta t}$。稳定性条件为：\n$$\n\\left| \\frac{1}{1 + \\lambda \\Delta t} \\right| < 1\n$$\n由于 $\\lambda > 0$ 且 $\\Delta t > 0$，分母 $1 + \\lambda \\Delta t$ 总是大于 $1$。因此，对于所有正的 $\\Delta t$，$0 < G_{BE} < 1$。稳定性条件总是满足的。因此，对于此问题，后向 Euler 方法是无条件稳定的，这一性质被称为 A-稳定性。\n\n**3. 实现与游戏目标**\n\n这个“游戏”要求我们判断给定的时间步长 $\\Delta t$ 是否会使显式 Euler 方法不稳定。结果 $r$ 为 $1$ 表示不稳定，为 $0$ 表示稳定。参数为 $\\lambda=1000$，$y_0 = 1$ 和 $T=1$。\n$\\Delta t$ 的稳定性阈值为：\n$$\n\\Delta t < \\frac{2}{\\lambda} = \\frac{2}{1000} = 0.002\n$$\n如果 $\\Delta t \\ge 0.002$，该方法不稳定。我们将把这个条件应用于每个测试用例。\n\n- **测试用例 1：$\\Delta t = 0.0005$**\n  由于 $0.0005 < 0.002$，稳定性条件得到满足。该方法是稳定的。\n  $|G_{FE}| = |1 - 1000 \\times 0.0005| = |1 - 0.5| = 0.5 < 1$。\n  结果：$r_1 = 0$。\n\n- **测试用例 2：$\\Delta t = 0.0020$**\n  此处 $\\Delta t = 0.002$，正好落在边界上。根据问题的严格规定，这被视为不稳定。\n  $|G_{FE}| = |1 - 1000 \\times 0.0020| = |1 - 2.0| = 1.0$。\n  条件 $|G_{FE}| \\ge 1$ 被满足。\n  结果：$r_2 = 1$。\n\n- **测试用例 3：$\\Delta t = 0.0025$**\n  此处 $0.0025 > 0.002$，违反了稳定性条件。该方法是不稳定的。\n  $|G_{FE}| = |1 - 1000 \\times 0.0025| = |1 - 2.5| = 1.5 > 1$。\n  条件 $|G_{FE}| \\ge 1$ 被满足。\n  结果：$r_3 = 1$。\n\n最终结果序列为 $[0, 1, 1]$。所提供的代码将实现这一逻辑，包括按要求模拟轨迹以展示稳定与不稳定的后果，尽管最终的打印输出仅取决于放大因子分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stability game for a stiff ODE using Euler methods.\n\n    The program performs the following steps as required:\n    1. For each test case (time step), it calculates the amplification factor for\n       the explicit Euler method.\n    2. It determines if the method is unstable based on the condition that the\n       magnitude of the amplification factor is greater than or equal to 1.\n    3. It implements both explicit and implicit Euler methods to simulate the\n       trajectory, demonstrating adherence to the full problem statement, although\n       the final output depends only on the stability criterion.\n    4. It collects the stability results (0 for stable, 1 for unstable) and\n       prints them in the specified format.\n    \"\"\"\n\n    # Define problem parameters from the statement.\n    lambda_val = 1000.0\n    y0 = 1.0\n    T = 1.0\n\n    # Define the test suite of time steps.\n    delta_t_values = [0.0005, 0.0020, 0.0025]\n\n    results = []\n\n    for delta_t in delta_t_values:\n        # --- Part 4: The Game Objective ---\n        # Determine stability for explicit Euler based on the amplification factor.\n        # The amplification factor for explicit Euler is G_FE = 1 - lambda * delta_t.\n        # Stability requires |G_FE| < 1. Unstable if |G_FE| >= 1.\n        \n        amp_factor_mag = abs(1.0 - lambda_val * delta_t)\n\n        # The result r is 1 if unstable, 0 otherwise.\n        if amp_factor_mag >= 1.0:\n            r = 1\n        else:\n            r = 0\n        results.append(r)\n\n        # --- Part 3: Simulation (for completeness as requested) ---\n        # Although not needed for the final output 'r', the problem requires\n        # implementing the time-stepping to simulate the trajectories.\n        \n        # Ensure N is an integer, as guaranteed by the problem statement.\n        N = int(round(T / delta_t))\n        \n        # Explicit Euler Simulation\n        y_explicit = np.zeros(N + 1)\n        y_explicit[0] = y0\n        amp_factor_explicit = 1.0 - lambda_val * delta_t\n        for n in range(N):\n            y_explicit[n+1] = amp_factor_explicit * y_explicit[n]\n        # max_abs_explicit = np.max(np.abs(y_explicit)) # Diagnostic\n\n        # Implicit Euler Simulation\n        y_implicit = np.zeros(N + 1)\n        y_implicit[0] = y0\n        amp_factor_implicit = 1.0 / (1.0 + lambda_val * delta_t)\n        for n in range(N):\n            y_implicit[n+1] = amp_factor_implicit * y_implicit[n]\n        # max_abs_implicit = np.max(np.abs(y_implicit)) # Diagnostic\n        \n        # The diagnostics max_abs_explicit and max_abs_implicit could be\n        # inspected to observe the blow-up or decay, confirming the theory.\n        # For example, for delta_t = 0.0025 (unstable), max_abs_explicit\n        # would be a very large number, while max_abs_implicit would be 1.0.\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2442901"}, {"introduction": "数值解的稳定性（即解保持有界）并不完全等同于结果的物理真实性。本练习将揭示一种更微妙的失效模式：即使在数值上稳定，显式方法也可能产生不符合物理现实的结果，例如负的物质浓度。通过分析一个化学反应动力学模型，你将发现，要保持解的正确物理性质（如非负性），对时间步长的要求可能比单纯维持数值稳定性更为苛刻，这突显了为物理问题选择合适数值方法的重要性。[@problem_id:2442899]", "problem": "考虑由常微分方程（ODE）组建模的线性常系数双物种动力学链\n$$\n\\frac{d}{dt}\\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix}\n=\n\\begin{bmatrix}\n- k_1 & 0 \\\\\nk_1 & - k_2\n\\end{bmatrix}\n\\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix},\n\\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\n$$\n其速率常数为 $k_1 = 1000\\,\\text{s}^{-1}$ 和 $k_2 = 1\\,\\text{s}^{-1}$。自变量是时间 $t$，单位为秒。该系统是刚性的，因为系统矩阵的特征值相差数个数量级。\n\n你的任务是通过推导和计算来证明，对于一个刚性问题，显式单步法如何在数值稳定（有界）的情况下产生定性上错误的轨迹，而隐式单步法如何保持定性特征。\n\n从以下基本原理出发：\n- 时间导数的定义，$\\frac{dy}{dt} = \\lim_{h\\to 0} \\frac{y(t+h)-y(t)}{h}$。\n- 前向（显式）欧拉法源于用在当前时间点计算的前向有限差分替换导数。\n- 后向（隐式）欧拉法源于用在下一时间点计算的后向有限差分替换导数。\n- 单步法的线性稳定性通过标量测试方程 $\\frac{dy}{dt} = \\lambda y$ 进行评估，方法是检验放大因子 $R(z)$，其中 $z = h\\lambda$。对于线性系统 $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$，稳定性由放大矩阵的谱半径决定。\n\n要求：\n1) 从基本定义出发，推导将显式欧拉法和后向欧拉法应用于给定 $2\\times 2$ 线性系统的离散时间更新映射。用时间步长 $h$ 和系统矩阵 $A$ 表示这两个更新。\n\n2) 使用标量测试方程分析，推导显式欧拉法的放大因子 $R(z)$ 及其稳定域。解释这如何导出以矩阵 $I + hA$（其中 $I$ 是单位矩阵）的谱半径表示的线性系统稳定性条件。对于本问题，如果 $I + hA$ 的谱半径小于或等于 $1$，则将一个显式步长分类为“数值稳定（有界）”。\n\n3) 实现这两种方法，用几个固定的时间步长 $h$ 将系统从 $t=0$ 演化到 $t = T$（其中 $T = 0.95\\,\\text{s}$）。对于每种方法和每个时间步长，记录在任何离散时间层上是否有任何分量变为负值。浓度为负是定性上的违背。\n\n4) 对于每个时间步长 $h$，通过计算 $I + hA$ 的谱半径并检查其是否小于或等于 $1$ 来确定显式欧拉法是否数值稳定（有界）。\n\n5) 使用以下时间步长测试集（单位为秒）：$h \\in \\{0.0005,\\ 0.0019,\\ 0.0020\\}$。对于每个 $h$，将两种方法演化到 $T = 0.95\\,\\text{s}$（对于每个列出的 $h$，这恰好是整数步数），并按顺序报告三个布尔值：\n- 显式方法的有界稳定性标志（如第 4 项所定义），\n- 显式方法是否曾产生负分量，\n- 隐式方法是否曾产生负分量。\n\n最终输出规格：\n- 你的程序应产生单行输出，其中包含一个含三个列表的列表（每个测试用例一个，按上面给出的 $h$ 的顺序）。每个内部列表必须是 $[\\text{explicit\\_bounded},\\ \\text{explicit\\_has\\_negative},\\ \\text{implicit\\_has\\_negative}]$ 的形式，其中每个条目都是一个布尔值。例如，输出可能看起来像 $[[\\text{True},\\text{False},\\text{False}],[\\dots],[\\dots]]$。\n- 在输出的布尔值中无需报告额外的单位。时间必须在内部以秒为单位处理。", "solution": "该问题要求展示显式和隐式单步数值方法在应用于刚性常微分方程（ODE）系统时，其定性及定量行为的差异。我们将首先验证该问题，然后进行所需的推导和计算。\n\n该问题是有效的。它提出了一个基于线性化学动力学标准模型的适定初值问题，这是一个在计算物理和计算化学中有坚实基础的课题。所有必需的常数、初始条件和定义都已给出，问题没有科学谬误、歧义或主观论断。我们着手求解。\n\n该系统由线性ODE $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$ 给出，其中状态向量为 $\\mathbf{y}(t) = \\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix}$，初始条件为 $\\mathbf{y}(0) = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，系统矩阵 $A$ 为\n$$\nA = \\begin{bmatrix} -k_1 & 0 \\\\ k_1 & -k_2 \\end{bmatrix} = \\begin{bmatrix} -1000 & 0 \\\\ 1000 & -1 \\end{bmatrix}.\n$$\n自变量是时间 $t$，速率常数为 $k_1 = 1000\\,\\text{s}^{-1}$ 和 $k_2 = 1\\,\\text{s}^{-1}$。\n\n1) 离散时间更新映射的推导\n\n设 $\\mathbf{y}_n$ 是在时间 $t_n = n h$ 处 $\\mathbf{y}(t_n)$ 的数值近似，其中 $h$ 是时间步长。\n\n显式（前向）欧拉法使用前向有限差分来近似时间 $t_n$ 处的导数 $\\frac{d\\mathbf{y}}{dt}$：\n$$\n\\frac{\\mathbf{y}_{n+1} - \\mathbf{y}_n}{h} \\approx A\\mathbf{y}_n.\n$$\n求解 $\\mathbf{y}_{n+1}$ 得到显式更新映射：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h A\\mathbf{y}_n = (I + hA)\\mathbf{y}_n,\n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵。\n\n隐式（后向）欧拉法使用后向有限差分来近似时间 $t_{n+1}$ 处的导数，并在未来时间 $t_{n+1}$ 处计算右侧项：\n$$\n\\frac{\\mathbf{y}_{n+1} - \\mathbf{y}_n}{h} \\approx A\\mathbf{y}_{n+1}.\n$$\n为了求得 $\\mathbf{y}_{n+1}$，我们必须求解一个线性系统：\n$$\n\\mathbf{y}_n = \\mathbf{y}_{n+1} - hA\\mathbf{y}_{n+1} = (I - hA)\\mathbf{y}_{n+1}.\n$$\n通过对矩阵 $(I - hA)$ 求逆来求解 $\\mathbf{y}_{n+1}$，得到隐式更新映射：\n$$\n\\mathbf{y}_{n+1} = (I - hA)^{-1}\\mathbf{y}_n.\n$$\n\n2) 显式欧拉法的稳定性分析\n\n单步法的稳定性使用标量测试方程 $\\frac{dy}{dt} = \\lambda y$（其中 $\\lambda \\in \\mathbb{C}$）来分析。应用显式欧拉法可得到递推关系：\n$$\ny_{n+1} = y_n + h(\\lambda y_n) = (1 + h\\lambda)y_n.\n$$\n项 $R(z) = 1 + h\\lambda = 1+z$（其中 $z = h\\lambda$）是放大因子。数值解保持有界的充要条件是 $|R(z)| \\le 1$。对于显式欧拉法，此条件 $|1+z| \\le 1$ 定义的稳定域是在复平面上以 $(-1, 0)$ 为中心、半径为 $1$ 的圆盘。\n\n对于线性系统 $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$，如果该条件对于矩阵 $A$ 的每个特征值 $\\lambda_i$ 都有 $z=h\\lambda_i$ 成立，则该方法是稳定的。这等价于要求放大矩阵 $I+hA$ 的所有特征值的模不大于 $1$。这些特征值的最大模即为谱半径 $\\rho(I+hA)$。因此，显式欧拉法数值稳定（有界）的条件是：\n$$\n\\rho(I + hA) \\le 1.\n$$\n\n3, 4, 5) 具体问题的应用与计算分析\n\n矩阵 $A = \\begin{bmatrix} -1000 & 0 \\\\ 1000 & -1 \\end{bmatrix}$ 是一个下三角矩阵，所以其特征值即为其对角线元素：$\\lambda_1 = -1000$ 和 $\\lambda_2 = -1$。\n显式欧拉放大矩阵 $I+hA$ 的特征值为 $1+h\\lambda_1 = 1 - 1000h$ 和 $1+h\\lambda_2 = 1 - h$。谱半径为 $\\rho(I+hA) = \\max(|1 - 1000h|, |1 - h|)$。\n为保证稳定性，我们要求 $|1 - 1000h| \\le 1$ 和 $|1 - h| \\le 1$。第一个不等式 $-1 \\le 1 - 1000h \\le 1$ 意味着 $-2 \\le -1000h \\le 0$，化简后得 $0 \\le h \\le \\frac{2}{1000} = 0.002\\,\\text{s}$。第二个不等式给出 $0 \\le h \\le 2\\,\\text{s}$。这两个条件中更严格的一个决定了整个系统的稳定性。因此，显式方法有界的充要条件是 $h \\le 0.002\\,\\text{s}$。\n\n然而，数值稳定性（有界性）并不能保证定性上的正确性。在这个动力学模型中，浓度 $y_1$ 和 $y_2$ 必须保持非负。让我们考察从 $\\mathbf{y}_0 = [1, 0]^T$ 开始的显式欧拉法的第一步：\n$$\n\\begin{bmatrix} y_{1,1} \\\\ y_{2,1} \\end{bmatrix} = \\begin{bmatrix} 1 - 1000h & 0 \\\\ 1000h & 1 - h \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 1 - 1000h \\\\ 1000h \\end{bmatrix}.\n$$\n为使各分量保持非负，我们需要 $y_{1,1} \\ge 0$，这意味着 $1 - 1000h \\ge 0$，即 $h \\le \\frac{1}{1000} = 0.001\\,\\text{s}$。这个条件比稳定性条件 $h \\le 0.002\\,\\text{s}$ 更为严格。对于 $0.001 < h \\le 0.002$ 范围内的任何步长 $h$，显式欧拉法在数值上是有界的，但会为分量 $y_1$ 产生不符合物理意义的负值。\n\n对于后向欧拉法，更新矩阵为 $(I - hA)^{-1} = \\left(\\begin{bmatrix} 1+1000h & 0 \\\\ -1000h & 1+h \\end{bmatrix}\\right)^{-1} = \\frac{1}{(1+1000h)(1+h)}\\begin{bmatrix} 1+h & 0 \\\\ 1000h & 1+1000h \\end{bmatrix}$。由于 $h > 0$，该矩阵的所有元素都是非负的。因为初始状态 $\\mathbf{y}_0$ 是非负的，所有后续状态 $\\mathbf{y}_{n+1} = (I - hA)^{-1}\\mathbf{y}_n$ 根据归纳法也将保持非负。因此，对于任何步长 $h > 0$，后向欧拉法都是保正的。\n\n我们现在评估测试用例：$h \\in \\{0.0005, 0.0019, 0.0020\\}$。\n\n情况 $h=0.0005\\,\\text{s}$：\n- `explicit_bounded`：$h = 0.0005 \\le 0.002$，所以该方法是有界的。$\\rho(I+hA) = \\max(|1-0.5|,|1-0.0005|) = 0.9995 \\le 1$。真 (True)。\n- `explicit_has_negative`：$h = 0.0005 \\le 0.001$，所以非负性得以保持。假 (False)。\n- `implicit_has_negative`：该方法总是保正的。假 (False)。\n结果：`[True, False, False]`\n\n情况 $h=0.0019\\,\\text{s}$：\n- `explicit_bounded`：$h = 0.0019 \\le 0.002$，所以该方法是有界的。$\\rho(I+hA) = \\max(|1-1.9|,|1-0.0019|) = \\max(0.9, 0.9981) = 0.9981 \\le 1$。真 (True)。\n- `explicit_has_negative`：$h = 0.0019 > 0.001$，所以 $y_1$ 变为负值。真 (True)。\n- `implicit_has_negative`：总是保正的。假 (False)。\n结果：`[True, True, False]`\n\n情况 $h=0.0020\\,\\text{s}$：\n- `explicit_bounded`：$h = 0.0020$，处于稳定边界。$\\rho(I+hA) = \\max(|1-2.0|,|1-0.0020|) = \\max(1.0, 0.998) = 1.0 \\le 1$。真 (True)。\n- `explicit_has_negative`：$h = 0.0020 > 0.001$，所以 $y_1$ 变为负值。真 (True)。\n- `implicit_has_negative`：总是保正的。假 (False)。\n结果：`[True, True, False]`\n\n最终的编译结果与这些推导相符。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stiff ODE problem, demonstrating the difference between\n    explicit and implicit Euler methods.\n    \"\"\"\n    # Define problem parameters\n    k1 = 1000.0\n    k2 = 1.0\n    T_final = 0.95\n    y0 = np.array([1.0, 0.0])\n    \n    # System matrix\n    A = np.array([[-k1, 0.0], [k1, -k2]])\n\n    # Define the test cases from the problem statement.\n    test_cases = [0.0005, 0.0019, 0.0020]\n\n    results = []\n    \n    # Process each test case (each time step h)\n    for h in test_cases:\n        # Requirement 4: Determine if explicit Euler is boundedly stable\n        # Eigenvalues of A are its diagonal entries since it is triangular\n        lambda1 = -k1\n        lambda2 = -k2\n        # Eigenvalues of the amplification matrix I + hA\n        eig_val1_amp = 1.0 + h * lambda1\n        eig_val2_amp = 1.0 + h * lambda2\n        # Spectral radius is the maximum of the absolute values of the eigenvalues\n        spectral_radius = max(abs(eig_val1_amp), abs(eig_val2_amp))\n        \n        # The problem defines stability as spectral radius <= 1.\n        # A small tolerance accounts for potential floating-point inaccuracies\n        # when h=0.002 (where spectral radius is exactly 1).\n        explicit_bounded = spectral_radius <= 1.0 + 1e-9\n\n        # Requirement 3 & 5: Check for negative components\n        num_steps = int(round(T_final / h))\n\n        # --- Explicit Euler Simulation ---\n        y_exp = np.copy(y0)\n        M_exp = np.eye(2) + h * A\n        explicit_has_negative = False\n        for _ in range(num_steps):\n            y_exp = M_exp @ y_exp\n            # Check if any component of the state vector is negative\n            if np.any(y_exp < 0):\n                explicit_has_negative = True\n                break\n        \n        # --- Implicit Euler Simulation ---\n        y_imp = np.copy(y0)\n        # Pre-compute the inverse of (I - hA) for efficiency\n        M_imp_inv = np.linalg.inv(np.eye(2) - h * A)\n        implicit_has_negative = False\n        for _ in range(num_steps):\n            y_imp = M_imp_inv @ y_imp\n            # Check if any component is negative (theoretically will not happen)\n            if np.any(y_imp < 0):\n                implicit_has_negative = True\n                break\n        \n        # Append the list of booleans for the current case\n        results.append([explicit_bounded, explicit_has_negative, implicit_has_negative])\n\n    # Final print statement in the exact required format.\n    # The output format requires no spaces, e.g., [[True,False,False],...].\n    # str(results) would produce spaces, so we remove them.\n    final_output_string = str(results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```", "id": "2442899"}, {"introduction": "在认识到显式方法的根本限制后，是时候来见证隐式求解器的强大威力了。本练习将引导你比较现代科学计算库中自适应显式求解器（如“RK45”）与自适应隐式求解器（如“BDF”）在解决典型刚性问题时的计算效率。通过对比两者完成任务所需的函数求值总次数，你将量化地理解隐式方法带来的巨大性能优势，并明白为何它成为处理多尺度物理和工程问题的标准工具。[@problem_id:2442926]", "problem": "考虑由以下线性刚性常微分方程定义的标量初值问题\n$$\n\\frac{dy}{dt} = -\\lambda\\, y, \\quad y(0)=1,\n$$\n在一个有限时间区间上。其精确解为\n$$\ny(t) = e^{-\\lambda t}.\n$$\n当动力学包含快速衰减的模态时，一个系统被称为刚性的，因此显式求解器必须采用极小的步长来维持数值稳定性，而隐式求解器在更大的步长下仍能保持稳定。在自适应时间步长方案中，步长会被调整，以使局部截断误差的估计值保持在用户指定的容差之下。\n\n你的任务是编写一个完整的程序，对下面的每个测试用例，分别使用自适应显式龙格－库塔方法和自适应隐式多步法对问题进行积分，然后比较所使用的函数求值次数。使用以下要求。\n\n- 使用自适应显式方法“RK45”（一种带有嵌入式误差估计器的经典显式龙格-库塔方法）和自适应隐式方法“BDF”（反向微分公式），两者都采用由用户指定容差控制的自动步长控制。\n- 对于隐式求解器，提供精确的雅可比矩阵\n$$\nJ(t,y) = \\frac{\\partial f}{\\partial y} = -\\lambda,\n$$\n这样隐式方法就不需要用有限差分来近似它。\n- 对于两种求解器，在每个测试用例中都使用相同的绝对和相对容差。设 $rtol$ 表示相对容差，$atol$ 表示绝对容差。\n- 对每个测试用例，记录每个求解器报告的右端函数求值次数 $N_{\\mathrm{fev}}$，显式方法的次数记为 $N_{\\mathrm{fev}}^{\\mathrm{exp}}$，隐式方法的次数记为 $N_{\\mathrm{fev}}^{\\mathrm{imp}}$。计算比率\n$$\nR = \\frac{N_{\\mathrm{fev}}^{\\mathrm{exp}}}{N_{\\mathrm{fev}}^{\\mathrm{imp}}}.\n$$\n- 每个测试用例返回一个 $R$。\n\n测试套件：\n- 用例1（基准，轻度刚性）：$\\lambda = 50$，在 $t \\in [0, 2.0]$ 上积分，其中 $rtol = 10^{-6}$，$atol = 10^{-12}$。\n- 用例2（刚性）：$\\lambda = 5000$，在 $t \\in [0, 1.0]$ 上积分，其中 $rtol = 10^{-6}$，$atol = 10^{-12}$。\n- 用例3（非常刚性）：$\\lambda = 50000$，在 $t \\in [0, 0.5]$ 上积分，其中 $rtol = 10^{-6}$，$atol = 10^{-12}$。\n\n重要实现说明：\n- 右端函数为 $f(t,y) = -\\lambda y$。\n- 所有计算均采用无量纲单位；不需要物理单位。\n- 所有用例的初值均为 $y(0)=1$。\n- 不要通过计算精确解来指导时间步长；仅依赖求解器的自适应控制。\n- 为了可比性，不要提供任何 $t_{\\mathrm{eval}}$ 网格；允许每个求解器选择其自己的内部步长。\n\n输出规格：\n- 对每个测试用例，输出比率 $R$，四舍五入到六位小数。\n- 你的程序应生成单行输出，其中包含按上述测试用例顺序列出的结果，格式为逗号分隔的列表，并用方括号括起来。例如，包含三个结果的输出行必须如下所示：\n$$\n[\\text{R}_{1},\\text{R}_{2},\\text{R}_{3}],\n$$\n其中每个 $\\text{R}_{k}$ 是一个小数点后四舍五入到六位的十进制数。\n\n你的程序必须是一个完整的、可运行的程序，不需要用户输入，并且只使用指定的库。", "solution": "所述问题是有效的。这是一个适定的、有科学依据的计算物理练习，旨在探讨常微分方程（ODE）中刚性的基本概念。参数明确，任务清晰。我们将着手解决。\n\n该问题研究由以下线性常微分方程（ODE）给出的标量初值问题（IVP）：\n$$\n\\frac{dy}{dt} = -\\lambda y, \\quad y(0) = 1\n$$\n对于正参数 $\\lambda$。其精确解已知为 $y(t) = e^{-\\lambda t}$。该方程是刚性系统的典型模型。\n\n当一个常微分方程组的雅可比矩阵的特征值在数量级上差异巨大时，该系统被称为“刚性”的。对于这个标量问题，雅可比矩阵就是右端函数对 $y$ 的导数，即 $J = \\frac{\\partial}{\\partial y}(-\\lambda y) = -\\lambda$。唯一的特征值是 $-\\lambda$。当 $\\lambda$ 是一个大的正数时，相应的解分量 $e^{-\\lambda t}$ 会极快地衰减。这种快速衰减的模态对显式数值积分方法施加了严格的稳定性约束。\n\n显式方法，如指定的龙格-库塔“RK45”方法，仅使用当前状态 $y_n$ 的信息来计算下一个状态 $y_{n+1}$。它们的稳定性是有限的。对于该模型问题，显式方法的时间步长 $\\Delta t$ 通常必须满足 $\\Delta t \\cdot \\lambda \\lesssim C$ 形式的条件，其中 $C$ 是一个数量级为1的常数，具体取决于所用的方法。这意味着，为了保持数值稳定性，步长必须与系统中最快的时间尺度 $\\sim \\frac{1}{\\lambda}$ 处于同一数量级，即使在快速瞬态衰减很久之后，解已经变化平滑时也是如此。对于大的 $\\lambda$，这会迫使求解器采用数量庞大且极小的步长，从而导致高昂的计算成本。“RK45”中的自适应步长控制会自动减小步长以满足此稳定性要求，从而导致大量的函数求值次数 $N_{\\mathrm{fev}}^{\\mathrm{exp}}$。\n\n隐式方法，如反向微分公式（“BDF”），为刚性问题提供了一种更优越的替代方案。隐式方法通过求解一个包含新状态 $y_{n+1}$ 本身的方程来确定它，例如 $y_{n+1} = y_n + \\Delta t f(t_{n+1}, y_{n+1})$。对于非线性的 $f$，这需要在每个时间步求解一个方程组，通常使用牛顿-拉夫逊类型的迭代方法。这种迭代求解器的收敛性取决于 $f$ 的雅可比矩阵。通过提供精确的雅可比矩阵 $J = -\\lambda$，我们辅助求解器完成此任务，避免了有限差分近似带来的计算开销和潜在的不准确性。像BDF这样的隐式方法的主要优点是它们具有大的稳定性区域。它们是“A-稳定”或“刚性稳定”的，这意味着它们可以采用大的时间步长，步长仅受解析解中慢变分量所需的精度限制，而不受快速衰减模态的稳定性约束。\n\n在本实验中，我们将比较“RK45”（$N_{\\mathrm{fev}}^{\\mathrm{exp}}$）和“BDF”（$N_{\\mathrm{fev}}^{\\mathrm{imp}}$）在 $\\lambda$ 值不断增大时函数求值的次数。对于轻度刚性的用例1（$\\lambda=50$），显式方法可能相当高效。然而，当 $\\lambda$ 增加到数千时（用例2和3），问题变得非常刚性。“RK45”求解器将被迫进入稳定性受限的区域，采用大量的步长。而“BDF”求解器不受稳定性约束，将能够采用大得多的步长，仅由指定的容差决定，以在初始快速瞬态后追踪平滑的解。因此，我们预计 $N_{\\mathrm{fev}}^{\\mathrm{imp}}$ 将远小于 $N_{\\mathrm{fev}}^{\\mathrm{exp}}$，并且比率 $R = N_{\\mathrm{fev}}^{\\mathrm{exp}} / N_{\\mathrm{fev}}^{\\mathrm{imp}}$ 将随 $\\lambda$ 的增大而显著增长，这表明了显式方法在处理刚性问题时的极度低效。\n\n实现将利用SciPy库中的 `solve_ivp` 函数。对于每个测试用例，我们将配置并运行这两个求解器，使用相同的容差和积分区间，从求解器的输出结构中检索函数求值次数，并计算指定的比率 $R$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the stiff ODE y' = -lambda*y for different lambda values,\n    comparing the performance of an explicit (RK45) and an implicit (BDF) solver.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (lambda_val, t_span, rtol, atol)\n    test_cases = [\n        (50.0, [0.0, 2.0], 1e-6, 1e-12),\n        (5000.0, [0.0, 1.0], 1e-6, 1e-12),\n        (50000.0, [0.0, 0.5], 1e-6, 1e-12)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lambda_val, t_span, rtol, atol = case\n\n        # The right-hand side of the ODE dy/dt = f(t, y)\n        # Using a lambda function to capture the current lambda_val\n        fun = lambda t, y: -lambda_val * y\n\n        # The Jacobian of the right-hand side, d(f)/d(y)\n        # solve_ivp expects the Jacobian as a 2-D array-like structure.\n        jac = lambda t, y: [[-lambda_val]]\n        \n        # Initial condition y(0) = 1.\n        # solve_ivp expects a 1-D array for the initial state.\n        y0 = [1.0]\n\n        # Integrate using the explicit \"RK45\" method\n        sol_exp = solve_ivp(\n            fun=fun,\n            t_span=t_span,\n            y0=y0,\n            method='RK45',\n            rtol=rtol,\n            atol=atol\n        )\n        n_fev_exp = sol_exp.nfev\n\n        # Integrate using the implicit \"BDF\" method, providing the exact Jacobian\n        sol_imp = solve_ivp(\n            fun=fun,\n            t_span=t_span,\n            y0=y0,\n            method='BDF',\n            rtol=rtol,\n            atol=atol,\n            jac=jac\n        )\n        n_fev_imp = sol_imp.nfev\n        \n        # Compute the ratio of function evaluations\n        if n_fev_imp > 0:\n            ratio = n_fev_exp / n_fev_imp\n        else:\n            # Handle the unlikely case of zero evaluations to avoid division by zero\n            ratio = np.inf\n\n        # Format the result to six decimal places and add to the list\n        results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2442926"}]}