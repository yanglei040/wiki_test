{"hands_on_practices": [{"introduction": "我们实践的第一步是构建核心的模拟引擎。这个练习要求你从牛顿第二定律出发，编写一个程序来模拟考虑了二次空气阻力的炮弹弹道。通过实现一个数值积分器（如四阶龙格-库塔法），你将学会如何将物理方程转化为可执行的代码，并处理基本的事件检测，例如炮弹是否越过了特定距离的城墙。这个基础练习是后续更复杂分析的基石。[@problem_id:2430459]", "problem": "一枚质量为 $m$ 的炮弹从地面以初速度 $v_0$、与水平方向成 $\\theta$ 角的发射角发射。运动发生在一个大小为 $g$ 的均匀重力场中，并受到与速度平方成正比的二次空气动力阻力。空气密度为 $\\rho$，炮弹被建模为半径为 $r$ 的刚性球体，其阻力系数为 $C_d$，横截面积为 $A = \\pi r^2$。阻力方向始终与瞬时速度相反。在距发射点水平距离 $D$ 处，有一堵高度为 $H$ 的垂直城堡墙壁。任务是通过第一性原理和数值模拟，判断炮弹是否能越过墙壁，其定义为在炮弹撞击地面之前，其水平位置达到 $x = D$ 时的高度大于或等于 $H$。\n\n你的程序必须：\n- 从基本物理定律（牛顿第二定律和运动学定义）出发，建立带二次空气阻力的炮弹在均匀重力场中的运动方程。\n- 实现一个时间推进的数值积分器，以演化系统状态 $(x(t), y(t), v_x(t), v_y(t))$ 从 $t = 0$ 开始，直到出现以下条件之一：\n    1. 水平位置达到或超过墙壁位置 ($x \\ge D$)。\n    2. 抛射体撞击地面 ($y < 0$)。\n    3. 超过预设的最大模拟时间（声明未能到达墙壁）。\n- 当满足条件 $x \\ge D$ 时，通过在包含 $D$ 的最后两个时间步之间进行线性插值，计算出在 $x = D$ 处的垂直位置，并将其与 $H$ 比较，以判断是否越过墙壁。\n- 如果抛射体在到达 $x = D$ 之前撞击地面，或者在未达到 $x \\ge D$ 的情况下达到了最大模拟时间，则声明未越过墙壁。\n\n所有量必须使用国际单位制（SI）表示：长度单位为米 ($\\mathrm{m}$)，质量单位为千克 ($\\mathrm{kg}$)，时间单位为秒 ($\\mathrm{s}$)，重力加速度单位为 $\\mathrm{m/s^2}$。使用 $g = 9.81\\,\\mathrm{m/s^2}$。角度 $\\theta$ 以度为单位指定。\n\n测试套件：\n使用以下五个测试用例。对于每个用例，输出一个布尔值，表示炮弹是否越过墙壁（如果越过则为 True，否则为 False）。所有用例使用相同的空气密度 $\\rho$ 和重力加速度 $g$，但其他参数可能因用例而异。\n\n公共参数：\n- $\\rho = 1.225\\,\\mathrm{kg/m^3}$，\n- $g = 9.81\\,\\mathrm{m/s^2}$。\n\n各用例参数：\n1. 用例1（正常路径，轻松越过）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 200.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 100.0\\,\\mathrm{m}$，$H = 10.0\\,\\mathrm{m}$。\n2. 用例2（边界情况：纯垂直发射，永远无法到达墙壁）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 100.0\\,\\mathrm{m/s}$，$\\theta = 90.0^\\circ$，$D = 50.0\\,\\mathrm{m}$，$H = 5.0\\,\\mathrm{m}$。\n3. 用例3（边界情况：墙壁在发射点）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 100.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 0.0\\,\\mathrm{m}$，$H = 1.0\\,\\mathrm{m}$。\n4. 用例4（低速，真空极限，测试在到达墙壁前撞击地面）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.0$，$v_0 = 20.0\\,\\mathrm{m/s}$，$\\theta = 10.0^\\circ$，$D = 30.0\\,\\mathrm{m}$，$H = 0.1\\,\\mathrm{m}$。\n5. 用例5（合理的中世纪高性能射击，在一定距离上越过）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 250.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 300.0\\,\\mathrm{m}$，$H = 30.0\\,\\mathrm{m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的布尔值列表。例如，一个包含五个结果的有效输出格式为“[True,False,True,False,True]”。不应打印任何其他文本。\n\n角度单位要求：\n角度 $\\theta$ 以度为单位提供，在进行任何三角计算时必须在内部转换为弧度。\n\n单位要求：\n所有内部计算均以国际单位制（SI）表示；比较结果是无单位的布尔值。是否越过墙壁的判断，是将插值得到的高度 $y(D)$（单位为 $\\mathrm{m}$）与墙高 $H$（单位为 $\\mathrm{m}$）进行比较。\n\n您的程序必须是一个完整的、可运行的程序，该程序硬编码了上述测试套件，并打印出所要求的单行输出。", "solution": "我们从牛顿第二定律和运动学开始。设 $(x(t), y(t))$ 表示抛射体的位置，$(v_x(t), v_y(t))$ 为其速度分量，速率为 $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$。质量为 $m$，重力大小为 $g$，方向向下。在中等雷诺数下的稳定流中，球体的阻力被建模为与速度成二次方关系，其大小为 $\\frac{1}{2}\\rho C_d A v(t)^2$，方向与瞬时速度相反。此处 $\\rho$ 是空气密度，$C_d$ 是阻力系数，$A = \\pi r^2$ 是横截面积。\n\n根据牛顿第二定律，\n$$\nm \\frac{d\\mathbf{v}}{dt} = \\mathbf{F}_g + \\mathbf{F}_d,\n$$\n其中 $\\mathbf{F}_g = (0, - m g)$ 且 $\\mathbf{F}_d = - \\frac{1}{2} \\rho C_d A \\, v \\, \\mathbf{v}$，因为 $v \\, \\mathbf{v}$ 等于在 $\\mathbf{v}$ 方向上大小为 $v^2$ 的矢量，而负号则强制其与运动方向相反。分量形式为，\n$$\n\\frac{dv_x}{dt} = - \\frac{\\frac{1}{2} \\rho C_d A}{m} \\, v \\, v_x, \\quad\n\\frac{dv_y}{dt} = - g - \\frac{\\frac{1}{2} \\rho C_d A}{m} \\, v \\, v_y.\n$$\n运动学给出\n$$\n\\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y.\n$$\n\n从地面 ($x(0)=0$, $y(0)=0$) 发射时（$t=0$）的初始条件由初速度 $v_0$ 和角度 $\\theta$（以度为单位，转换为弧度 $\\theta_\\mathrm{rad}$）决定：\n$$\nv_x(0) = v_0 \\cos(\\theta_\\mathrm{rad}), \\quad v_y(0) = v_0 \\sin(\\theta_\\mathrm{rad}).\n$$\n\n在二次阻力作用下，这些耦合的非线性一阶常微分方程通常没有闭式解，因此我们采用数值方法求解。一个稳健的选择是经典的四阶 Runge–Kutta (RK4) 方法。对于状态向量 $\\mathbf{s} = (x, y, v_x, v_y)$ 和时间步长 $\\Delta t$，定义右端项 $\\mathbf{f}(\\mathbf{s}) = (v_x, v_y, a_x, a_y)$，其中\n$$\na_x = - \\frac{1}{2} \\frac{\\rho C_d A}{m} v v_x, \\quad a_y = - g - \\frac{1}{2} \\frac{\\rho C_d A}{m} v v_y, \\quad v = \\sqrt{v_x^2 + v_y^2}.\n$$\n给定时刻 $t_n$ 的状态 $\\mathbf{s}_n$，RK4 方法通过以下方式推进到时刻 $t_{n+1} = t_n + \\Delta t$ 的状态 $\\mathbf{s}_{n+1}$：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{f}(\\mathbf{s}_n), \\\\\n\\mathbf{k}_2 &= \\mathbf{f}\\left(\\mathbf{s}_n + \\tfrac{1}{2}\\Delta t \\, \\mathbf{k}_1 \\right), \\\\\n\\mathbf{k}_3 &= \\mathbf{f}\\left(\\mathbf{s}_n + \\tfrac{1}{2}\\Delta t \\, \\mathbf{k}_2 \\right), \\\\\n\\mathbf{k}_4 &= \\mathbf{f}\\left(\\mathbf{s}_n + \\Delta t \\, \\mathbf{k}_3 \\right), \\\\\n\\mathbf{s}_{n+1} &= \\mathbf{s}_n + \\frac{\\Delta t}{6} \\left( \\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4 \\right).\n\\end{aligned}\n$$\n\n终止与事件处理：\n- 我们沿时间正向进行积分，直到满足以下三个条件之一：(i) 水平上到达或超过墙壁 ($x \\ge D$)，(ii) 抛射体撞击地面 ($y < 0$)，或 (iii) 达到最大模拟时间 $t_{\\max}$ 以避免在退化情况（例如，水平速度为零）下出现无限循环。\n- 为评估在墙壁确切位置 $x = D$ 处的垂直位置，我们在满足 $x_\\text{prev} < D \\le x_\\text{next}$ 的最后两个积分状态之间执行线性插值。将两个包围状态表示为 $(x_\\text{prev}, y_\\text{prev})$ 和 $(x_\\text{next}, y_\\text{next})$，其中 $x_\\text{next} \\ne x_\\text{prev}$，插值得到的墙壁处高度为：\n$$\ny(D) \\approx y_\\text{prev} + \\frac{D - x_\\text{prev}}{x_\\text{next} - x_\\text{prev}} \\left( y_\\text{next} - y_\\text{prev} \\right).\n$$\n- 当且仅当 $y(D) \\ge H$ 且抛射体在到达 $x = D$ 之前未撞击地面时，才算越过墙壁。\n\n数值参数：\n- 我们使用指定的 $g = 9.81\\,\\mathrm{m/s^2}$ 和 $\\rho = 1.225\\,\\mathrm{kg/m^3}$。\n- 对于测试套件中的距离和速度，固定的时间步长 $\\Delta t$（例如 $\\Delta t = 10^{-3}\\,\\mathrm{s}$）在精度和计算成本之间提供了平衡。\n- 最大模拟时间 $t_{\\max}$ 可以设置为一个足够大的值（例如，$t_{\\max} = 200\\,\\mathrm{s}$）以确保终止。\n\n正确性考量：\n- 对于平滑的右端项，RK4 格式在 $\\Delta t$ 上具有四阶精度。\n- 阻力和重力是状态的光滑函数，因此该方法是合适的。\n- 对于小的 $\\Delta t$而言，在 $x$ 方向上的线性插值是合理的，因为状态变化平滑，且 $x_\\text{prev}$ 和 $x_\\text{next}$ 之间的距离很小。\n\n对测试套件的应用：\n我们现在对每个用例进行定性分析；程序将执行精确的数值评估和比较。\n\n1. 用例1：$m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 200.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 100.0\\,\\mathrm{m}$，$H = 10.0\\,\\mathrm{m}$。即使没有阻力，在 $x = D$ 处的高度也相当大（约为 $10^2\\,\\mathrm{m}$ 量级），因此考虑阻力后 $y(D)$ 仍然远大于 $H$。程序得出 True。\n2. 用例2：$\\theta = 90.0^\\circ$ 意味着 $v_x(0) = 0$。抛射体垂直运动，永远不会到达 $x = D = 50.0\\,\\mathrm{m}$，因此无法越过墙壁。程序得出 False。\n3. 用例3：$D = 0.0\\,\\mathrm{m}$ 意味着我们将初始高度 $y(0) = 0$ 与 $H = 1.0\\,\\mathrm{m}$ 进行比较。由于 $0 < 1.0$，墙壁未被越过。程序得出 False。\n4. 用例4：在真空（$C_d = 0.0$）中，$v_0 = 20.0\\,\\mathrm{m/s}$ 和 $\\theta = 10.0^\\circ$ 会产生一条低矮且快速下降的轨迹，在 $x$ 到达 $D = 30.0\\,\\mathrm{m}$ 之前就撞击地面（这在无阻力极限下可以通过解析方式验证），因此墙壁未被越过。程序得出 False。\n5. 用例5：$v_0 = 250.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 300.0\\,\\mathrm{m}$，$H = 30.0\\,\\mathrm{m}$。抛射体在大约几秒钟内到达 $x = 300.0\\,\\mathrm{m}$，并且尽管有阻力，仍然保持在相当高的高度；因此 $y(D) \\ge H$。程序得出 True。\n\n因此，五个测试用例的预期布尔值输出列表，按顺序为：\n[True, False, False, False, True]。\n\n随附的程序实现了 RK4 积分器、事件检测、在 $x = D$ 处的插值，并精确打印出所要求的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_clearance(m, r, Cd, rho, v0, theta_deg, D, H, g=9.81, dt=1e-3, t_max=200.0):\n    \"\"\"\n    Simulate a projectile with quadratic drag and determine if it clears a wall.\n\n    Parameters:\n        m (float): mass [kg]\n        r (float): radius [m]\n        Cd (float): drag coefficient [-]\n        rho (float): air density [kg/m^3]\n        v0 (float): initial speed [m/s]\n        theta_deg (float): launch angle [deg]\n        D (float): wall horizontal distance [m]\n        H (float): wall height [m]\n        g (float): gravitational acceleration [m/s^2]\n        dt (float): time step [s]\n        t_max (float): maximum simulation time [s]\n\n    Returns:\n        bool: True if clears (y(D) >= H before ground impact), else False.\n    \"\"\"\n    # Handle trivial D == 0 without integrating\n    if D == 0.0:\n        # Launched from y=0, so cannot clear any positive H\n        return 0.0 >= H\n\n    # Cross-sectional area of sphere\n    A = np.pi * r * r\n\n    # Initial state\n    theta = np.deg2rad(theta_deg)\n    vx = v0 * np.cos(theta)\n    vy = v0 * np.sin(theta)\n    x = 0.0\n    y = 0.0\n    t = 0.0\n\n    # Precompute drag factor\n    drag_coeff_factor = 0.5 * rho * Cd * A / m\n\n    # Keep previous state for interpolation\n    prev_x, prev_y = x, y\n\n    # Integration loop using RK4\n    while t < t_max:\n        if x >= D:\n            break\n        if y < 0.0:\n            # Impacted ground before reaching the wall\n            return False\n\n        # Store current for interpolation after step\n        prev_x, prev_y = x, y\n\n        # Define RHS function\n        def rhs(state):\n            sx, sy, svx, svy = state\n            v = np.hypot(svx, svy)\n            ax = -drag_coeff_factor * v * svx\n            ay = -g - drag_coeff_factor * v * svy\n            return np.array([svx, svy, ax, ay], dtype=float)\n\n        state = np.array([x, y, vx, vy], dtype=float)\n\n        k1 = rhs(state)\n        k2 = rhs(state + 0.5 * dt * k1)\n        k3 = rhs(state + 0.5 * dt * k2)\n        k4 = rhs(state + dt * k3)\n\n        state_next = state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n        x, y, vx, vy = state_next\n        t += dt\n\n        # Check if we have crossed or reached the wall this step\n        if x >= D:\n            dx = x - prev_x\n            if dx == 0.0:\n                # No horizontal progress; cannot interpolate meaningfully\n                # Let the loop continue (will hit t_max or ground)\n                continue\n            # Linear interpolation to find y at x = D\n            frac = (D - prev_x) / dx\n            y_at_D = prev_y + frac * (y - prev_y)\n            return y_at_D >= H\n\n    # If loop exits due to time max or other reasons without reaching D, or check at end\n    if x >= D:\n        # If exactly at or beyond D at final step, compute y_at_D by interpolation\n        dx = x - prev_x\n        if dx == 0.0:\n            # Degenerate; treat as not cleared unless y itself is defined at D (unlikely)\n            return y >= H\n        frac = (D - prev_x) / dx\n        y_at_D = prev_y + frac * (y - prev_y)\n        return y_at_D >= H\n\n    # Did not reach the wall\n    return False\n\ndef solve():\n    # Common parameters\n    rho = 1.225  # kg/m^3\n    g = 9.81     # m/s^2\n\n    # Test cases as tuples: (m, r, Cd, rho, v0, theta_deg, D, H)\n    test_cases = [\n        # Case 1: happy path, clears easily\n        (5.0, 0.06, 0.47, rho, 200.0, 45.0, 100.0, 10.0),\n        # Case 2: vertical launch; never reaches the wall\n        (5.0, 0.06, 0.47, rho, 100.0, 90.0, 50.0, 5.0),\n        # Case 3: wall at launch point\n        (5.0, 0.06, 0.47, rho, 100.0, 45.0, 0.0, 1.0),\n        # Case 4: low speed, vacuum; hits ground before reaching D\n        (5.0, 0.06, 0.0,  rho, 20.0,  10.0, 30.0, 0.1),\n        # Case 5: plausible medieval high-performance shot\n        (5.0, 0.06, 0.47, rho, 250.0, 45.0, 300.0, 30.0),\n    ]\n\n    results = []\n    for (m, r, Cd, rho_i, v0, theta_deg, D, H) in test_cases:\n        clears = simulate_clearance(\n            m=m, r=r, Cd=Cd, rho=rho_i, v0=v0,\n            theta_deg=theta_deg, D=D, H=H, g=g, dt=1e-3, t_max=200.0\n        )\n        results.append(clears)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2430459"}, {"introduction": "在掌握了单次弹道模拟后，我们可以探索更广泛的可能性。这个实践将引导你进入数值优化的领域，你需要将前一个练习中开发的弹道模拟器封装到一个优化算法（黄金分割搜索法）中。通过这个练习，你将能回答一个经典的物理问题：在存在空气阻力的情况下，哪个发射角度可以使炮弹的射程达到最远？[@problem_id:2398598]", "problem": "要求您实现一个完整的程序，使用黄金分割搜索来最大化一个只能通过数值模拟获得的单变量目标函数。目标函数是在二次方空气阻力下，一个以速度 $v_0$ 和角度 $\\theta$（单位为度）从地面发射的抛射体的水平射程（单位为米）。运动方程源于牛顿第二定律，由下式给出：\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad\n\\frac{d\\mathbf{v}}{dt} = -g \\,\\mathbf{e}_y - \\frac{k}{m}\\,\\|\\mathbf{v}\\|\\,\\mathbf{v},\n$$\n其中 $\\mathbf{r} = (x,y)$ 是位置（单位为米），$\\mathbf{v} = (v_x,v_y)$ 是速度（单位为米/秒），$m$ 是质量（单位为千克），$g$ 是重力加速度（单位为米/秒²），$k$ 是二次方阻力系数（单位为千克/米），$\\mathbf{e}_y$ 是垂直方向的单位向量。在时间 $t=0$ 时的初始条件为：\n$$\nx(0)=0,\\quad y(0)=0,\\quad v_x(0)=v_0\\cos\\theta,\\quad v_y(0)=v_0\\sin\\theta.\n$$\n将水平射程 $R(\\theta)$ 定义为轨迹首次返回地面时 $x(t)$ 的值，即满足 $y(t)=0$ 的最小 $t>0$。使用地平面上方的最后一步和下方的第一步之间的线性插值来估计着地点。由于当 $k>0$ 时 $R(\\theta)$ 没有解析解，因此必须通过数值时间积分来计算。\n\n建模和计算的基本依据：\n- 使用牛顿第二定律推导上述系统。\n- 将时间离散化，并使用经典的四阶 Runge–Kutta 方法，以固定的时间步长 $\\Delta t = 0.005$ 秒来演化系统。\n- 检测着地事件，并通过线性插值估计精确的着陆点 $x$ 坐标。\n- 假设 $g$ 和 $k$ 为常数。\n\n黄金分割搜索规范：\n- 在闭区间 $[\\underline{\\theta},\\overline{\\theta}] = [0.1^\\circ, 89.9^\\circ]$ 上最大化 $R(\\theta)$。\n- 假设 $R(\\theta)$ 在此区间上是单峰的。\n- 实现黄金分割搜索，使用黄金比例共轭 $\\varphi = (\\sqrt{5}-1)/2$ 来界定和缩小搜索区间，无需使用导数。\n- 当区间宽度小于或等于 $\\varepsilon_\\theta = 10^{-5}$ 度，或在 $N_{\\max} = 64$ 次迭代之后终止，以先到者为准。\n- 返回最终区间的中点作为最大化点 $\\theta^\\star$。\n\n单位与数值要求：\n- 所有距离必须以米为单位计算。\n- 所有时间必须以秒为单位计算。\n- 在整个搜索过程中，所有角度都必须以度为单位处理，并以度为单位报告。\n- 将报告的每个最优角度四舍五入到小数点后4位。\n\n测试套件：\n实现您的程序以解决以下三个测试用例。每个用例由 $(v_0, m, k, g)$ 定义，单位如上所述。对于每个用例，使用指定的算法和数值方法，计算出最大化射程的发射角 $\\theta^\\star$（以度为单位）。\n\n- 用例 A（无阻力基线，预期内部最大值在 $45^\\circ$ 附近）：$(v_0, m, k, g) = (50, 1.0, 0.0, 9.81)$。\n- 用例 B（中等二次方阻力）：$(v_0, m, k, g) = (50, 0.145, 0.001286, 9.81)$。\n- 用例 C（强二次方阻力，可能存在偏向边界的最大值）：$(v_0, m, k, g) = (20, 0.005, 0.001372, 9.81)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按上述测试用例的顺序列出三个最大化角度（单位为度），每个角度四舍五入到小数点后4位，例如：\"[45.0000,38.1234,5.6789]\"。打印的列表中不得有空格。", "solution": "所述问题是有效的。这是一个计算物理学和数值优化领域的适定问题。所有参数、方法和条件都已明确指定，并且在科学上是合理的。该问题要求实现数值模拟与优化算法的结合，这是科学和工程领域的标准程序。我们将着手解决该问题。\n\n该问题的核心是找到发射角度 $\\theta$，以最大化受二次方空气阻力影响的抛射体的水平射程 $R(\\theta)$。由于函数 $R(\\theta)$ 没有解析解，我们必须以数值方式构建它。这个过程包括两个主要部分：首先，一个用于求解运动方程的数值积分器；其次，一个用于寻找结果函数最大值的优化算法。\n\n让我们首先将常微分方程（ODE）系统形式化。在任意时间 $t$，抛射体的状态由其位置 $\\mathbf{r}(t) = (x(t), y(t))$ 和速度 $\\mathbf{v}(t) = (v_x(t), v_y(t))$ 描述。我们可以定义一个状态向量 $\\mathbf{y}(t) \\in \\mathbb{R}^4$ 如下：\n$$\n\\mathbf{y}(t) = \\begin{pmatrix} x(t) \\\\ y(t) \\\\ v_x(t) \\\\ v_y(t) \\end{pmatrix}\n$$\n给定的控制方程为 $\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}$ 和 $\\frac{d\\mathbf{v}}{dt} = -g\\mathbf{e}_y - \\frac{k}{m}\\|\\mathbf{v}\\|\\mathbf{v}$。我们可以将其写成一个包含四个一阶常微分方程的系统，即 $\\frac{d\\mathbf{y}}{dt} = f(t, \\mathbf{y})$：\n$$\nf(t, \\mathbf{y}) = \\begin{pmatrix} v_x \\\\ v_y \\\\ -\\frac{k}{m} \\sqrt{v_x^2 + v_y^2} \\cdot v_x \\\\ -g - \\frac{k}{m} \\sqrt{v_x^2 + v_y^2} \\cdot v_y \\end{pmatrix}\n$$\n对于给定的发射速度 $v_0$ 和角度 $\\theta$，在 $t=0$ 时的初始条件是：\n$$\n\\mathbf{y}(0) = \\begin{pmatrix} 0 \\\\ 0 \\\\ v_0 \\cos(\\theta_{rad}) \\\\ v_0 \\sin(\\theta_{rad}) \\end{pmatrix}\n$$\n注意，角度 $\\theta$ 以度为单位给出，在使用三角函数时必须将其转换为弧度（$\\theta_{rad}$）。\n\n为求解该系统，我们采用经典的四阶 Runge-Kutta (RK4) 方法。给定在时间 $t_n$ 的状态 $\\mathbf{y}_n$，在时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $\\mathbf{y}_{n+1}$ 可通过下式近似：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中，中间向量斜率为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= f(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= f(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t\\mathbf{k}_3)\n\\end{aligned}\n$$\n我们从 $\\mathbf{y}(0)$ 开始，以固定的时间步长 $\\Delta t = 0.005$ 秒逐步执行此积分。对于给定的 $\\theta$，当抛射体击中地面时，模拟终止。这通过检测垂直位置 $y(t)$ 变为负值来实现。设 $\\mathbf{y}_{n-1}$ 是 $y_{n-1} \\ge 0$ 的最后一个状态，而 $\\mathbf{y}_{n}$ 是 $y_{n} < 0$ 的第一个状态。水平射程 $R(\\theta)$ 是 $y(t)=0$ 时刻 $x$ 坐标的插值。通过在 $(x_{n-1}, y_{n-1})$ 和 $(x_n, y_n)$ 之间使用线性插值，我们可求得射程：\n$$\nR(\\theta) = x_{n-1} - y_{n-1} \\frac{x_n - x_{n-1}}{y_n - y_{n-1}}\n$$\n这个过程定义了我们必须最大化的目标函数 $R(\\theta)$。\n\n优化过程使用黄金分割搜索算法执行，该算法适用于在闭区间上最大化单峰函数，且无需导数。搜索区间为 $[\\underline{\\theta}, \\overline{\\theta}] = [0.1^\\circ, 89.9^\\circ]$。设某次迭代中的区间为 $[a, b]$。我们计算两个内部点 $c$ 和 $d$：\n$$\n\\begin{aligned}\nc &= b - \\varphi(b - a) \\\\\nd &= a + \\varphi(b - a)\n\\end{aligned}\n$$\n其中 $\\varphi = \\frac{\\sqrt{5}-1}{2}$ 是黄金比例共轭。然后我们计算在这些点上的目标函数值 $R(c)$ 和 $R(d)$。\n- 如果 $R(c) > R(d)$，则最大值必定位于区间 $[a, d]$ 内。我们通过设置 $b=d$ 来更新搜索区间。\n- 如果 $R(d) \\ge R(c)$，则最大值必定位于区间 $[c, b]$ 内。我们通过设置 $a=c$ 来更新搜索区间。\n这个过程被重复执行，每一步都将区间宽度缩小一个因子 $\\varphi$。当区间宽度 $(b-a)$ 小于或等于容差 $\\varepsilon_\\theta = 10^{-5}$ 度，或达到最大迭代次数 $N_{\\max} = 64$ 时，算法终止。然后将最终区间的中点 $\\frac{a+b}{2}$ 作为最优角度 $\\theta^\\star$ 报告。\n\n整个过程如下：\n1.  实现代表 ODE 系统的函数 $f(t, \\mathbf{y})$。\n2.  实现 RK4 积分步骤。\n3.  实现目标函数 $R(\\theta)$，该函数对于给定的角度 $\\theta$，使用 RK4 模拟轨迹，检测着地事件，并返回插值得到的射程。\n4.  实现黄金分割搜索算法，找到使 $R(\\theta)$ 最大化的角度 $\\theta^\\star \\in [0.1, 89.9]$。\n5.  将此过程应用于所提供的三个测试用例中的每一个。\n基线用例（用例 A，$k=0$）是一个关键的验证点。在没有空气阻力的情况下，射程由 $R(\\theta) = (v_0^2/g) \\sin(2\\theta)$ 给出，该函数在 $\\theta = 45^\\circ$ 时取得最大值。我们对此用例的数值解应非常接近这一理论结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile optimization problem for the given test cases.\n    \"\"\"\n\n    # Golden ratio conjugate as specified\n    PHI_CONJ = (np.sqrt(5) - 1.0) / 2.0\n\n    def dydt(y_state, k, m, g):\n        \"\"\"\n        Computes the derivative of the state vector for the projectile motion ODEs.\n        State vector y_state = [x, y, vx, vy].\n        \"\"\"\n        _, _, vx, vy = y_state\n        v_mag = np.sqrt(vx**2 + vy**2)\n        \n        # When v_mag is zero (at t=0), the drag term is zero.\n        # This check avoids potential division by zero if not handled carefully, though here it just multiplies.\n        if v_mag == 0.0:\n            drag_term_x = 0.0\n            drag_term_y = 0.0\n        else:\n            drag_factor = (k / m) * v_mag\n            drag_term_x = drag_factor * vx\n            drag_term_y = drag_factor * vy\n\n        ax = -drag_term_x\n        ay = -g - drag_term_y\n        \n        return np.array([vx, vy, ax, ay])\n\n    def rk4_step(f_ode, y_state, dt, k, m, g):\n        \"\"\"\n        Performs a single step of the classical fourth-order Runge-Kutta method.\n        \"\"\"\n        k1 = f_ode(y_state, k, m, g)\n        k2 = f_ode(y_state + 0.5 * dt * k1, k, m, g)\n        k3 = f_ode(y_state + 0.5 * dt * k2, k, m, g)\n        k4 = f_ode(y_state + dt * k3, k, m, g)\n        return y_state + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def calculate_range(theta_deg, v0, m, k, g):\n        \"\"\"\n        Numerically simulates projectile trajectory to calculate the horizontal range.\n        This serves as the objective function R(theta).\n        \"\"\"\n        dt = 0.005  # Time step in seconds\n        \n        # Initial conditions\n        theta_rad = np.deg2rad(theta_deg)\n        y_state = np.array([\n            0.0,  # x(0)\n            0.0,  # y(0)\n            v0 * np.cos(theta_rad),  # vx(0)\n            v0 * np.sin(theta_rad)   # vy(0)\n        ])\n\n        y_prev = y_state\n        \n        # Max simulation steps to prevent infinite loops (e.g., if it never lands)\n        max_steps = 100000 \n        for _ in range(max_steps):\n            y_curr = rk4_step(dydt, y_prev, dt, k, m, g)\n            \n            # Check for ground crossing (y becomes negative)\n            if y_curr[1] < 0.0 and y_prev[1] >= 0.0:\n                # Linearly interpolate to find the range at y = 0\n                x_prev, y_pos_prev = y_prev[0], y_prev[1]\n                x_curr, y_pos_curr = y_curr[0], y_curr[1]\n                # Formula: R = x_prev - y_prev * (dx / dy)\n                range_val = x_prev - y_pos_prev * (x_curr - x_prev) / (y_pos_curr - y_pos_prev)\n                return range_val\n            \n            y_prev = y_curr\n            \n        # Return 0 if the projectile does not land within the maximum number of steps\n        return 0.0\n\n    def golden_section_maximize(f_obj, a, b, tol, max_iter):\n        \"\"\"\n        Maximizes a unimodal function f_obj on the interval [a, b] using golden-section search.\n        \"\"\"\n        # Pre-calculate initial interior points and their function values\n        h = b - a\n        c = b - PHI_CONJ * h\n        d = a + PHI_CONJ * h\n        f_c = f_obj(c)\n        f_d = f_obj(d)\n\n        for _ in range(max_iter):\n            if (b - a) < tol:\n                break\n            \n            if f_c > f_d:\n                b = d\n                d = c\n                f_d = f_c\n                h = b - a\n                c = b - PHI_CONJ * h\n                f_c = f_obj(c)\n            else:\n                a = c\n                c = d\n                f_c = f_d\n                h = b - a\n                d = a + PHI_CONJ * h\n                f_d = f_obj(d)\n                \n        return (a + b) / 2.0\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        # (v0, m, k, g)\n        (50.0, 1.0, 0.0, 9.81),        # Case A: No drag\n        (50.0, 0.145, 0.001286, 9.81), # Case B: Moderate drag (baseball-like)\n        (20.0, 0.005, 0.001372, 9.81)  # Case C: Strong drag\n    ]\n\n    results = []\n    # Search parameters\n    theta_min, theta_max = 0.1, 89.9\n    tolerance = 1e-5\n    max_iterations = 64\n\n    for v0, m, k, g in test_cases:\n        # Create a lambda function to pass parameters to the objective function\n        objective_function = lambda theta: calculate_range(theta, v0, m, k, g)\n        \n        # Perform the optimization\n        optimal_angle = golden_section_maximize(\n            objective_function, theta_min, theta_max, tolerance, max_iterations\n        )\n        \n        # Append the rounded result\n        results.append(f\"{optimal_angle:.4f}\")\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2398598"}, {"introduction": "最后一个练习将我们的技能从优化提升到求解边界值问题。这个任务将向你介绍强大而通用的“打靶法”。通过将你的弹道模拟器与根查找算法相结合，你将能够精确地确定击中特定目标所需的发射角度 $\\theta$，这是从弹道学到航天器任务设计等多个领域的关键技术。[@problem_id:2430429]", "problem": "一个质量为 $m$ 的二维抛射体从原点以初速度 $v_0$ 和与水平面夹角为 $\\theta$ 的发射角发射。该抛射体在均匀重力加速度 $\\mathbf{g} = (0,-g)$ 下运动，并受到一个与速度平方成正比、方向与瞬时速度相反的二次空气动力阻力。使用牛顿第二定律对阻力进行建模如下。设状态为 $\\mathbf{r}(t) = (x(t),y(t))$ 和 $\\mathbf{v}(t) = (v_x(t),v_y(t))$，其中 $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$。运动方程为\n$$\n\\frac{d x}{d t} = v_x, \\quad \\frac{d y}{d t} = v_y,\n$$\n$$\n\\frac{d v_x}{d t} = -k\\, v\\, v_x, \\quad \\frac{d v_y}{d t} = -g - k\\, v\\, v_y,\n$$\n初始条件为\n$$\nx(0) = 0,\\quad y(0) = 0,\\quad v_x(0) = v_0 \\cos\\theta,\\quad v_y(0) = v_0 \\sin\\theta.\n$$\n阻力参数 $k$ 定义为\n$$\nk = \\frac{\\tfrac{1}{2}\\,\\rho\\, C_d\\, A}{m},\n$$\n其中 $\\rho$ 是空气密度，$C_d$ 是阻力系数，$A$ 是横截面积。\n\n你的任务是编写一个完整的、可运行的程序，对于每个目标点 $(x_T,y_T)$，使用求根算法来确定所有能使抛射体在高度 $y = y_T$ 处通过垂直线 $x = x_T$ 的发射角 $\\theta \\in (0,\\tfrac{\\pi}{2})$（严格介于水平和垂直之间）。求根过程必须应用于一个从第一性原理构建的关于发射角的标量函数，具体如下。\n\n1. 对于给定的 $\\theta$，定义标量函数\n$$\nF(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T,\n$$\n其中 $t^\\star(\\theta)$ 是以角度 $\\theta$ 和速度 $v_0$ 发射的飞行过程中，$x\\big(t^\\star(\\theta)\\big) = x_T$ 首次出现的时间（如果存在）。如果抛射体从未到达 $x_T$（例如，在 $x$ 到达 $x_T$ 之前就以 $y=0$ 落地），则 $F(\\theta)$ 未定义，该 $\\theta$ 不应用于求根的托架区间对。\n\n2. 一个有效的解角度 $\\theta^\\star$ 满足 $F(\\theta^\\star) = 0$。你的程序必须系统地搜索区间 $\\theta \\in [\\theta_{\\min}, \\theta_{\\max}]$，其中 $\\theta_{\\min} = 0.1^\\circ$ 和 $\\theta_{\\max} = 89.9^\\circ$，以检测 $F(\\theta)$ 变号的子区间，然后对每个检测到的子区间应用一维求根算法（例如，托架法）以收敛到一个根。\n\n3. 如果存在多个不同的根，必须找到并报告所有在 $(0^\\circ,90^\\circ)$ 内的此类角度。如果不存在根，则为该情况报告一个空列表。\n\n数值要求和约定：\n\n- 仅使用上述微分方程和初始条件作为物理模型；不要代入任何闭式轨迹公式。\n- 实现一个数值常微分方程积分器，当 $x(t)$ 首次等于 $x_T$（如果发生）或当抛射体在下降过程中击中地面 $y(t)=0$ 时停止。使用足够严格的公差以可靠地检测穿越。\n- 距离单位必须是米，时间单位是秒，质量单位是千克，空气密度单位是千克每立方米，面积单位是平方米，加速度单位是米每二次方秒。角度必须以度为单位报告。\n- 每个解角度以度为单位报告，四舍五入到三位小数。\n- 如果在穿越时间 $t^\\star$ 时，值 $|y(t^\\star) - y_T|$ 在 $10^{-3}$ 米以内，则该解角度是可接受的。你的求根公差应确保达到此目标精度。\n- 为保证可复现性，对所有测试用例使用以下固定的物理参数：$m = 0.145$ 千克，$\\rho = 1.225$ 千克每立方米，$C_d = 0.47$，$A = 0.0042$ 平方米，以及 $g = 9.81$ 米每二次方秒。\n\n覆盖不同情况的测试套件：\n\n- 情况 1（理想情况，地面目标，预期有两个解）：$v_0 = 40.0$ 米每秒，$(x_T,y_T) = (80.0, 0.0)$ 米。\n- 情况 2（高处目标，通常有一个或两个解）：$v_0 = 40.0$ 米每秒，$(x_T,y_T) = (60.0, 10.0)$ 米。\n- 情况 3（近程，预期有两个解）：$v_0 = 30.0$ 米每秒，$(x_T,y_T) = (30.0, 0.0)$ 米。\n- 情况 4（超出最大射程，预期无解）：$v_0 = 40.0$ 米每秒，$(x_T,y_T) = (200.0, 0.0)$ 米。\n\n程序输入和输出规范：\n\n- 无外部输入。使用上述确切的常数和测试套件。\n- 你的程序应生成单行输出，其中包含四个情况的结果，格式为用方括号括起来的逗号分隔列表。每个情况的结果必须是一个解角度（以度为单位）的列表，按升序排序并四舍五入到三位小数。如果某个情况没有解，则为该情况输出一个空列表。\n- 例如，要求的整体输出格式类似于 $[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$，其中数值以十进制形式显示，不含额外文本。\n\n你的程序必须是完整的、可直接运行的，并且必须使用应用于上述定义的 $F(\\theta)$ 的求根算法来为每种情况定位解角度。角度必须以度为单位报告。", "solution": "所提出的问题是计算物理学中一个定义明确的标准练习。它在科学上是成立的，在数学上是一致的，并且解决它所需的所有参数都已提供。该物理模型基于带有二次空气阻力的牛顿第二定律，是粘性介质中抛射体运动的经典表示。数值任务是找到使抛射体穿过特定目标点的发射角，这构成了一个边值问题。规定的解决方法——“打靶法”结合标量函数的求根算法——是处理这类问题的一种稳健且适当的技术。因此，该问题是有效的，我们将着手提供一个完整的解决方案。\n\n问题的核心是求解一个耦合的一阶常微分方程（ODEs）组。设系统在时间 $t$ 的状态由向量 $\\mathbf{S}(t) = [x(t), y(t), v_x(t), v_y(t)]^T$ 描述。运动方程可以写成 $\\frac{d\\mathbf{S}}{dt} = \\mathbf{f}(t, \\mathbf{S})$ 的形式，其中函数 $\\mathbf{f}$ 定义为：\n$$\n\\mathbf{f}(t, \\mathbf{S}) = \n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\n-k \\sqrt{v_x^2 + v_y^2} \\, v_x \\\\\n-g - k \\sqrt{v_x^2 + v_y^2} \\, v_y\n\\end{pmatrix}\n$$\n在 $t=0$ 时的初始状态由 $\\mathbf{S}(0) = [0, 0, v_0 \\cos\\theta, v_0 \\sin\\theta]^T$ 给出。参数 $\\theta$ 是我们必须确定的发射角。\n\n对于这个系统，轨迹 $\\mathbf{r}(t)$ 不存在直接的解析解。我们必须采用数值方法。问题要求我们找到使轨迹穿过目标点 $(x_T, y_T)$ 的 $\\theta$ 值。这是一个边值问题。我们将使用“打靶法”来解决它，该方法将边值问题转化为一个求根问题。\n\n打靶法按以下步骤进行：\n1.  我们选择一个试射角 $\\theta$。这完全确定了初始条件 $\\mathbf{S}(0)$。\n2.  我们从 $t=0$ 开始按时间向前数值积分该 ODEs 系统。这个过程就是“发射”抛射体。\n3.  我们监测轨迹，以找到抛射体水平位置 $x(t)$ 首次等于目标水平位置 $x_T$ 的时间 $t^\\star$。\n4.  在这个时间 $t^\\star$，我们评估抛射体的高度 $y(t^\\star)$。\n5.  我们定义一个标量目标函数 $F(\\theta)$，作为抛射体在 $x=x_T$ 处的高度与目标高度 $y_T$ 之间的差值：\n    $$\n    F(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T\n    $$\n    一个解角度 $\\theta^\\star$ 是使 $F(\\theta^\\star) = 0$ 的角度。因此，问题简化为寻找函数 $F(\\theta)$ 的根。\n\n为了实现这个方法，我们需要一个稳健的 ODE 积分器。SciPy 库中的 `solve_ivp` 函数是完成此任务的出色工具。`solve_ivp` 的一个关键特性是它能够检测“事件”——即状态和时间的某个函数变为零的条件。我们将利用此功能来精确确定穿越时间 $t^\\star$，而无需积分到固定的最大时间然后进行插值。\n\n我们定义两个终止事件函数：\n1.  `event_reach_x_target(t, S)`：此函数返回 $x(t) - x_T$。当该值为零时，积分器将停止，表示抛射体已到达目标的经度。\n2.  `event_hit_ground(t, S)`：此函数返回 $y(t)$。我们将其配置为仅当 $y(t)$ 减小时（即抛射体正在下落）触发，这标志着抛射体在到达 $x=x_T$ 之前已击中地面。\n\n函数 $F(\\theta)$ 是通过为给定的 $\\theta$ 调用 ODE 求解器来构建的。如果积分因 `event_reach_x_target` 事件而终止，我们计算并返回 $y(t^\\star) - y_T$。如果积分因 `event_hit_ground` 事件而终止，或者在未触发任何事件的情况下达到最大模拟时间，这意味着轨迹未能达到指定距离。在这种情况下，函数 $F(\\theta)$ 对于托架法的目的被认为是未定义的，我们可以返回一个非数值，如 `NaN`（非数字），以表示这种情况。\n\n为了在指定的区间 $\\theta \\in [0.1^\\circ, 89.9^\\circ]$ 内找到 $F(\\theta)=0$ 的所有根，我们采用一个两阶段过程：\n1.  **区间锁定 (Bracketing)**：我们首先将搜索区间离散化为一个精细的角度网格。我们评估网格上每个点的 $F(\\theta)$。通过搜索相邻网格点 $(\\theta_i, \\theta_{i+1})$ 使得函数符号改变（即 $F(\\theta_i) \\cdot F(\\theta_{i+1}) < 0$），我们根据介值定理识别出保证至少包含一个根的子区间。正确处理 `NaN` 情况非常重要，因为一个有效的托架区间要求两端都有确定的数值。\n2.  **求解 (Solving)**：对于每个找到的托架区间 $[\\theta_a, \\theta_b]$，我们应用一个数值求根算法。在 `scipy.optimize.brentq` 中实现的 Brent 方法是一个高效的选择。它结合了二分法的保证收敛性和割线法的更快收敛速度，并且是在已知托架区间时进行一维求根的标准方法。求根器的公差将被设置以确保在角度和最终目标高度上都达到所需的精度。\n\n这种数值积分、事件检测、区间锁定和求根的系统化过程将应用于每个测试用例，以找到所有有效的发射角。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile motion problem for all test cases.\n    \"\"\"\n    # Fixed physical parameters\n    M = 0.145  # mass in kg\n    RHO = 1.225  # air density in kg/m^3\n    C_D = 0.47  # drag coefficient (dimensionless)\n    A = 0.0042  # cross-sectional area in m^2\n    G = 9.81  # gravitational acceleration in m/s^2\n\n    # Derived drag parameter k = (rho * C_d * A) / (2 * m)\n    K = (0.5 * RHO * C_D * A) / M\n\n    # Test suite\n    test_cases = [\n        (40.0, (80.0, 0.0)),   # Case 1\n        (40.0, (60.0, 10.0)),  # Case 2\n        (30.0, (30.0, 0.0)),   # Case 3\n        (40.0, (200.0, 0.0)),  # Case 4\n    ]\n\n    def derivatives(t, state, k, g):\n        \"\"\"\n        Computes the derivatives for the system of ODEs.\n        state = [x, y, v_x, v_y]\n        \"\"\"\n        x, y, vx, vy = state\n        v = np.sqrt(vx**2 + vy**2)\n        \n        # Avoid division by zero if velocity is zero, though unlikely in this problem.\n        if v == 0:\n            ax = 0\n            ay = -g\n        else:\n            ax = -k * v * vx\n            ay = -g - k * v * vy\n            \n        return [vx, vy, ax, ay]\n\n    def calculate_y_error_at_xT(theta_deg, v0, xT, yT, k_param, g_param):\n        \"\"\"\n        Calculates the error F(theta) = y(t*) - yT for a given launch angle.\n        Returns np.nan if the projectile does not reach xT.\n        \"\"\"\n        theta_rad = np.deg2rad(theta_deg)\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n        \n        initial_state = [0.0, 0.0, vx0, vy0]\n        \n        # Event: projectile reaches the target's x-coordinate\n        def reach_x_target(t, state, k, g):\n            return state[0] - xT\n        reach_x_target.terminal = True\n        reach_x_target.direction = 1 # Trigger only when x is increasing\n\n        # Event: projectile hits the ground (y=0)\n        def hit_ground(t, state, k, g):\n            return state[1]\n        hit_ground.terminal = True\n        hit_ground.direction = -1 # Trigger only when y is decreasing\n\n        t_span = (0, 100) # Max integration time of 100s is sufficient\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=initial_state,\n            args=(k_param, g_param),\n            events=[reach_x_target, hit_ground],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-8\n        )\n\n        # Check which event terminated the integration\n        if sol.status == 1 and sol.t_events[0].size > 0:\n            # The 'reach_x_target' event was triggered\n            y_at_t_star = sol.y_events[0][0][1]\n            return y_at_t_star - yT\n        else:\n            # Projectile hit the ground first or integration timed out\n            return np.nan\n\n    all_results = []\n    for v0, (xT, yT) in test_cases:\n        \n        # Define the function for root finding, which depends on the case parameters\n        objective_func = lambda th: calculate_y_error_at_xT(th, v0, xT, yT, K, G)\n\n        # 1. Bracketing stage: Scan the angle range to find sign changes\n        theta_min_deg = 0.1\n        theta_max_deg = 89.9\n        scan_step_deg = 0.5  # Step size for scanning\n        \n        angles_to_scan = np.arange(theta_min_deg, theta_max_deg + scan_step_deg, scan_step_deg)\n        f_values = np.array([objective_func(th) for th in angles_to_scan])\n        \n        case_roots = []\n        for i in range(len(angles_to_scan) - 1):\n            th1, f1 = angles_to_scan[i], f_values[i]\n            th2, f2 = angles_to_scan[i+1], f_values[i+1]\n\n            if not np.isnan(f1) and not np.isnan(f2):\n                if f1 * f2 < 0:\n                    # Found a bracket [th1, th2]\n                    try:\n                        # 2. Solving stage: Find the root within the bracket\n                        root_deg = brentq(objective_func, th1, th2, xtol=1e-5)\n                        # Check if this root is a duplicate before adding\n                        is_duplicate = False\n                        for existing_root in case_roots:\n                            if abs(root_deg - existing_root) < 1e-4:\n                                is_duplicate = True\n                                break\n                        if not is_duplicate:\n                            case_roots.append(root_deg)\n                    except ValueError:\n                        # brentq can fail if signs are not opposite, though our check prevents this.\n                        pass\n        \n        case_roots.sort()\n        all_results.append([round(r, 3) for r in case_roots])\n\n    # Format the final output string as specified\n    case_strs = []\n    for res_list in all_results:\n        num_strs = [f\"{num:.3f}\" for num in res_list]\n        case_strs.append(f\"[{','.join(num_strs)}]\")\n    \n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "2430429"}]}