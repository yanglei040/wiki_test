{"hands_on_practices": [{"introduction": "即使是像求解二次方程的求根公式这样我们耳熟能详的公式，也可能暗藏数值计算的陷阱。本练习将探究“灾难性抵消”（catastrophic cancellation）现象，即当两个几乎相等的数在浮点运算中相减时，会导致精度的急剧损失。通过实现并比较一个直接的（naive）公式和一个数值稳定的代数等价形式，你将亲身体验如何识别并修正这种基本的数值不稳定性来源。[@problem_id:2421654]", "problem": "您需要研究使用浮点运算计算二次多项式根时的数值稳定性和不稳定性。考虑二次方程 $a x^{2} + b x + c = 0$ 的实根，在精确算术中，这些根由二次公式给出。在有限精度算术中，当 $b^{2} \\gg 4 a c$ 时，相减抵消会严重降低精度。您的任务是从第一性原理分析这种情况，并实现一个程序，用一个精心选择的测试集来量化所产生的误差。\n\n出发点和目标：\n1) 从二次方程根的精确定义开始：对于给定的实系数 $a$，$b$ 和 $c$，根是满足 $a x^{2} + b x + c = 0$ 的值 $x$。在精确算术中，使用二次公式和实数的一般法则可以得出两个精确的根。定义判别式 $D = b^{2} - 4 a c$ 并假设 $D \\ge 0$，因此两个根都是实数。在浮点运算中，必须考虑舍入误差，尤其是相减抵消（两个几乎相等的数相减时有效数字的损失）。\n2) 分析不稳定性：当 $b^{2} \\gg 4 a c$ 时，量 $\\sqrt{b^{2} - 4 a c}$ 接近于 $|b|$。使用公式 $x = \\frac{-b \\pm \\sqrt{b^{2} - 4 a c}}{2 a}$，其中一个符号会导致分子中两个几乎相等的大数相减，这在浮点运算中会导致灾难性抵消，并使该根的相对误差变得很大。使用二次方程的标准代数恒等式（例如 Vieta’s formulas：根之和 $r_{1} + r_{2} = -b/a$ 和根之积 $r_{1} r_{2} = c/a$），重新表达计算过程以避免这种减法。不要给出死记硬背的“修正”公式；相反，应从这些恒等式和精确代数出发进行推理，构建一个在精确算术中代数上等价，但在浮点计算中能避免几乎相等的量相减的替代方案。\n3) 量化误差：对于真根 $x^{\\star}$ 的一个计算近似值 $\\hat{x}$，将相对误差定义为 $|\\hat{x} - x^{\\star}| / |x^{\\star}|$。您将使用任意高精度算术来获得一个基准真值 $x^{\\star}$，用于与浮点计算结果进行比较。\n\n编程要求：\n- 实现两个计算 $a x^{2} + b x + c = 0$ 根的算法：\n  1) 在标准双精度浮点运算中，直接使用 $x = \\frac{-b \\pm \\sqrt{b^{2} - 4 a c}}{2 a}$ 进行计算。\n  2) 一个通过精确恒等式的代数变换推导出的数值稳定替代算法，旨在当 $b^{2} \\gg 4 a c$ 时避免相减抵消；然后使用精确的乘积关系 $r_{1} r_{2} = c/a$ 计算第二个根，以同样避免第二个根的抵消问题。\n- 为了评估误差，使用至少具有 $80$ 位十进制精度的任意精度浮点算术来计算高精度参考值。\n- 在高精度计算中也使用同样的避免相减抵消的代数方法，以确保参考值尽可能准确。\n- 对于每个测试用例，将“量级较小的根”定义为两个真根中绝对值较小的那个根，$x^{\\star}_{\\text{small}} = \\operatorname{argmin}_{r \\in \\{r_{1}, r_{2}\\}} |r|$。对于每个算法，从其两个输出中选择量级较小的计算根，并通过相对误差 $|\\hat{x} - x^{\\star}_{\\text{small}}| / |x^{\\star}_{\\text{small}}|$ 将其与 $x^{\\star}_{\\text{small}}$ 进行比较。\n- 您的程序必须产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个双元素列表 $[e_{\\text{naive}}, e_{\\text{stable}}]$，其中 $e_{\\text{naive}}$ 是直接使用二次公式计算的量级较小的根的相对误差，$e_{\\text{stable}}$ 是使用您的数值稳定方法计算的量级较小的根的相对误差。因此，如果有 $N$ 个测试用例，输出将是一个包含 $N$ 个双元素列表的单一列表。\n\n测试集：\n使用以下六个测试用例，每个用例以 $(a,b,c)$ 的形式给出，选择它们是为了测试不同的稳定性状况。在所有表达式中，所有数字都是纯实数单位（没有物理单位），不涉及角度。\n- 用例 $1$：$(a,b,c) = (\\,1,\\; 10^{8} + 1,\\; 1\\,)$，即 $(\\,1,\\; 100000001,\\; 1\\,)$。\n- 用例 $2$：$(a,b,c) = (\\,1,\\; 10^{16},\\; 1\\,)$。\n- 用例 $3$：$(a,b,c) = (\\,1,\\; -\\,10^{8} - 1,\\; 1\\,)$，即 $(\\,1,\\; -\\,100000001,\\; 1\\,)$。\n- 用例 $4$：$(a,b,c) = (\\,1,\\; 2,\\; 1\\,)$，由于 $D = 0$，该方程有一个重实根。\n- 用例 $5$：$(a,b,c) = (\\,1,\\; 2,\\; 10^{-16}\\,)$。\n- 用例 $6$：$(a,b,c) = (\\,10^{-16},\\; 1,\\; 10^{-16}\\,)$。\n\n最终输出规范：\n- 程序必须精确打印一行：一个 Python 风格的列表的列表，顺序与上述测试集相同。每个内部列表包含两个浮点数 $[e_{\\text{naive}}, e_{\\text{stable}}]$，分别代表朴素算法和稳定算法计算的量级较小的根的相对误差。例如，对于两个假设的测试用例，一个有效的输出格式为：$[[0.1,1e-12],[0.5,2.3e-16]]$。", "solution": "当前问题是从第一性原理出发，分析在有限精度算术中使用标准二次公式计算二次方程 $a x^2 + b x + c = 0$ 的根时遇到的数值不稳定性，并实现一个数值稳定的替代算法。\n\n如果一个问题是科学上合理的、适定的 (well-posed) 和客观的，那么它就是有效的。这个问题是数值分析中的一个经典练习，它基于浮点运算和误差分析的既定原则。给定的条件是完整的，目标是明确定义的，并且在计算科学领域内，其前提在事实上是正确的。因此，该问题被认为是有效的。\n\n我们从解析解开始。对于实系数 $a$，$b$ 和 $c$（其中 $a \\ne 0$），二次方程 $a x^{2} + b x + c = 0$ 的根由二次公式给出：\n$$\nx = \\frac{-b \\pm \\sqrt{D}}{2a}\n$$\n其中判别式为 $D = b^2 - 4ac$。给定条件是 $D \\ge 0$，以确保根是实数。设两个根为 $r_1$ 和 $r_2$。\n\n**数值不稳定性分析**\n\n不稳定性的根源在于使用有限精度浮点运算，特别是在 $b^2 \\gg 4ac$ 的情况下。这个条件意味着判别式 $D = b^2 - 4ac$ 非常接近 $b^2$。因此，$\\sqrt{D}$ 非常接近 $\\sqrt{b^2} = |b|$。\n\n让我们分析二次公式的分子 $-b \\pm \\sqrt{D}$。\n其中一个根的计算将涉及 $-b + \\sqrt{D}$ 或 $-b - \\sqrt{D}$。\n考虑 $\\operatorname{sgn}(b) = +1$ 的情况，即 $b > 0$。此时 $|b|=b$。\n项 $\\sqrt{D} = \\sqrt{b^2 - 4ac}$ 略小于 $b$。\n两个根通过以下方式计算：\n$$\nx_1 = \\frac{-b + \\sqrt{D}}{2a} \\quad \\text{and} \\quad x_2 = \\frac{-b - \\sqrt{D}}{2a}\n$$\n在 $x_1$ 的表达式中，分子 $-b + \\sqrt{D}$ 的计算涉及两个几乎相等的数相减。这一操作被称为**灾难性抵消 (catastrophic cancellation)**。在浮点运算中，如果 $\\sqrt{D}$ 足够接近 $b$，它们的差可能只有很少甚至没有有效数字，从而导致计算出的 $x_1$ 值存在巨大的相对误差。相反地，根 $x_2$ 涉及两个大的负数相加，这是一个数值上稳定的操作。\n\n类似地，如果 $\\operatorname{sgn}(b) = -1$，即 $b < 0$，则 $|b| = -b$。\n在这种情况下，$\\sqrt{D}$ 接近 $|b| = -b$。两个根是：\n$$\nx_1' = \\frac{-b - \\sqrt{D}}{2a} \\quad \\text{and} \\quad x_2' = \\frac{-b + \\sqrt{D}}{2a}\n$$\n这里，$x_1'$ 的分子涉及两个几乎相等的数相减（因为 $\\sqrt{D} \\approx -b$），导致灾难性抵消。而 $x_2'$ 的计算涉及两个大的正数相加，是稳定的。\n\n总的来说，当根号的符号选择为与 $-b$ 的符号相反时（这等价于与 $b$ 的符号相同），根的计算是不稳定的。这种不稳定的计算总是产生绝对值较小的那个根。\n\n**稳定算法的推导**\n\n为了解决这个问题，我们必须构建一个代数上等价但能避免相减抵消的替代表达式。问题指导我们使用 Vieta's formulas，它将多项式的根与其系数联系起来。对于我们的二次方程，它们是：\n$$\nr_1 + r_2 = -\\frac{b}{a} \\quad \\text{(根之和)}\n$$\n$$\nr_1 r_2 = \\frac{c}{a} \\quad \\text{(根之积)}\n$$\n策略是首先使用标准公式计算*不*会遭受抵消的那个根（量级较大的根），然后使用 Vieta's formulas 精确地找到第二个根（量级较小的根）。\n\n对一个根的稳定计算涉及分子中同号量的相加。这对应于表达式：\n$$\nr_{\\text{large}} = \\frac{-b - \\operatorname{sgn}(b)\\sqrt{b^2 - 4ac}}{2a}\n$$\n此处，$\\operatorname{sgn}(b)$ 是符号函数，如果 $b \\ge 0$ 则为 $+1$，如果 $b < 0$ 则为 $-1$（$b=0$ 时的选择是任意的，但必须保持一致；此公式无论如何都有效）。该表达式能稳健地计算出绝对值较大的根，因为它避免了几乎相等的量相减。\n\n一旦精确计算出 $r_{\\text{large}}$，我们就可以使用乘积恒等式 $r_{\\text{large}} \\cdot r_{\\text{small}} = c/a$ 来找到另一个根 $r_{\\text{small}}$：\n$$\nr_{\\text{small}} = \\frac{c/a}{r_{\\text{large}}} = \\frac{c}{a \\cdot r_{\\text{large}}}\n$$\n代入 $r_{\\text{large}}$ 的表达式，我们得到：\n$$\nr_{\\text{small}} = \\frac{c}{a \\left( \\frac{-b - \\operatorname{sgn}(b)\\sqrt{b^2 - 4ac}}{2a} \\right)} = \\frac{2c}{-b - \\operatorname{sgn}(b)\\sqrt{b^2-4ac}}\n$$\n这种形式的 $r_{\\text{small}}$ 避免了困扰朴素公式的抵消问题，因为除法在浮点运算中是一个表现良好的操作（只要分母不接近于零，而这里的情况并非如此，因为 $|-b - \\operatorname{sgn}(b)\\sqrt{D}| \\approx 2|b|$）。\n\n由此得到的稳定算法如下：\n1.  计算判别式 $D = b^2 - 4ac$。\n2.  使用稳定形式计算一个根 $r_1$：$r_1 = \\frac{-b - \\operatorname{sgn}(b)\\sqrt{D}}{2a}$。\n3.  使用 Vieta's 乘积公式计算第二个根 $r_2$：$r_2 = \\frac{c}{a \\cdot r_1}$。\n\n**实现与误差量化**\n\n每个测试用例 $(a,b,c)$ 的实现将包括三个部分：\n1.  **参考值计算：** 我们使用 Python 的 `decimal` 库和 $85$ 位数字的精度，通过稳定算法计算“真”根 $x^{\\star}_1$ 和 $x^{\\star}_2$。然后确定量级较小的根 $x^{\\star}_{\\text{small}}$。\n2.  **朴素计算：** 我们使用标准的双精度浮点运算 (`float`)，通过直接二次公式 $x = \\frac{-b \\pm \\sqrt{D}}{2a}$ 计算根 $\\hat{x}_{n1}, \\hat{x}_{n2}$。我们从这对根中确定量级较小的根 $\\hat{x}_{n, \\text{small}}$。\n3.  **稳定计算：** 我们使用 `float` 运算，通过上面推导的稳定算法计算根 $\\hat{x}_{s1}, \\hat{x}_{s2}$。我们确定量级较小的根 $\\hat{x}_{s, \\text{small}}$。\n\n对于朴素算法和稳定算法，计算出的量级较小的根的相对误差都是相对于高精度参考值计算的：\n$$\ne = \\frac{|\\hat{x}_{\\text{small}} - x^{\\star}_{\\text{small}}|}{|x^{\\star}_{\\text{small}}|}\n$$\n这种误差量化将展示在 $b^2 \\gg 4ac$ 的情况下，朴素方法的失败和稳定方法的成功。对于不满足此条件的用例（例如，$D=0$），两种方法预计都会表现良好。", "answer": "```python\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Analyzes numerical stability in solving quadratic equations and quantifies the error\n    of a naive vs. a stable algorithm for a given test suite.\n    \"\"\"\n    \n    # Set precision for high-accuracy reference calculations.\n    # At least 80 decimal digits are required; 85 provides a margin.\n    getcontext().prec = 85\n\n    # Define the test cases as per the problem statement.\n    test_cases = [\n        (1, 10**8 + 1, 1),\n        (1, 10**16, 1),\n        (1, -(10**8 + 1), 1),\n        (1, 2, 1),\n        (1, 2, 1e-16),\n        (1e-16, 1, 1e-16)\n    ]\n\n    results = []\n\n    for a_val, b_val, c_val in test_cases:\n        # --- 1. High-Precision Reference Calculation ---\n        a_hp, b_hp, c_hp = Decimal(a_val), Decimal(b_val), Decimal(str(c_val))\n\n        d_hp = b_hp**2 - 4 * a_hp * c_hp\n        \n        # Stable algorithm for high-precision reference roots\n        if d_hp < 0:\n            # Problem constraints ensure D >= 0, but as a safeguard.\n            # For this problem, we can assume this branch is not taken.\n            ref_r1, ref_r2 = float('nan'), float('nan')\n        else:\n            sqrt_d_hp = d_hp.sqrt()\n            # Use np.copysign on the float value of b_hp to determine the sign.\n            # This is robust for b=0.\n            r1_hp = (-b_hp - Decimal(np.copysign(1, b_val)) * sqrt_d_hp) / (2 * a_hp)\n            if r1_hp == 0:\n                # This case happens if c=0, so one root is 0. The other is -b/a.\n                # The stable algorithm for r2 would fail.\n                # However, test cases do not have c=0.\n                r2_hp = -b_hp / a_hp\n            else:\n                r2_hp = c_hp / (a_hp * r1_hp)\n            ref_r1, ref_r2 = r1_hp, r2_hp\n\n        # Identify the smaller-magnitude reference root\n        if abs(ref_r1) < abs(ref_r2):\n            x_star_small = ref_r1\n        else:\n            x_star_small = ref_r2\n            \n        # --- 2. Standard Double-Precision Calculations ---\n        a_f, b_f, c_f = float(a_val), float(b_val), float(c_val)\n        d_f = b_f**2 - 4 * a_f * c_f\n        \n        if d_f < 0:\n            # Handle cases where floating point error makes D negative\n            sqrt_d_f = 0.0\n        else:\n            sqrt_d_f = np.sqrt(d_f)\n\n        # 2a. Naive algorithm\n        naive_r1 = (-b_f + sqrt_d_f) / (2 * a_f)\n        naive_r2 = (-b_f - sqrt_d_f) / (2 * a_f)\n\n        # Identify smaller-magnitude root from naive method\n        x_hat_n_small = naive_r1 if abs(naive_r1) < abs(naive_r2) else naive_r2\n\n        # 2b. Stable algorithm\n        stable_r1 = (-b_f - np.copysign(sqrt_d_f, b_f)) / (2 * a_f)\n        if stable_r1 == 0:\n             # As before, this is for c=0 case not present in tests.\n             stable_r2 = -b_f / a_f\n        else:\n            stable_r2 = c_f / (a_f * stable_r1)\n        \n        # Identify smaller-magnitude root from stable method\n        # Note: The way the stable method is structured, stable_r2 is derived\n        # to be the smaller magnitude root when b^2 >> 4ac. Comparing magnitudes\n        # is a more general approach that is always correct.\n        if abs(stable_r1) < abs(stable_r2):\n            x_hat_s_small = stable_r1\n        else:\n            x_hat_s_small = stable_r2\n\n        # --- 3. Error Calculation ---\n        # Perform error calculation in high precision to avoid further errors.\n        if x_star_small == 0:\n            # If the true root is 0, relative error is 0 if computed is 0, else infinite.\n            # Test cases do not have zero roots.\n            e_naive = 0.0 if x_hat_n_small == 0.0 else float('inf')\n            e_stable = 0.0 if x_hat_s_small == 0.0 else float('inf')\n        else:\n            e_naive = float(abs(Decimal(x_hat_n_small) - x_star_small) / abs(x_star_small))\n            e_stable = float(abs(Decimal(x_hat_s_small) - x_star_small) / abs(x_star_small))\n        \n        results.append([e_naive, e_stable])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```", "id": "2421654"}, {"introduction": "当我们试图近似一个连续的数学运算（如求导）时，我们常常面临一个根本性的权衡。本练习将深入探讨数值微分中两种相互竞争的误差来源：随着步长 $h$ 减小而缩小的“截断误差”（truncation error），以及随之增大的“舍入误差”（round-off error）。你将通过实验确定一个能够最小化总误差的最佳步长，从而揭示精确数值计算所需的微妙平衡。[@problem_id:2421640]", "problem": "您需要编写一个完整的程序，该程序针对一组有限的步长，确定能够使$\\sin(x)$在指定点$x_0$的导数的有限差分近似值的绝对误差最小化的步长$h$。程序需在指定的差分格式下运行，且角度必须以弧度为单位进行处理。\n\n请使用以下完全指定的设置。\n\n1. 函数与精确导数：\n   - 目标函数：$f(x) = \\sin(x)$。\n   - 精确导数：$f'(x) = \\cos(x)$。\n\n2. 待评估的有限差分格式：\n   - 前向差分：$D_{\\mathrm{fwd}}(x_0;h) = \\dfrac{\\sin(x_0 + h) - \\sin(x_0)}{h}$。\n   - 中心差分：$D_{\\mathrm{cen}}(x_0;h) = \\dfrac{\\sin(x_0 + h) - \\sin(x_0 - h)}{2h}$。\n\n3. 对于给定的$x_0$和差分格式，待最小化的误差度量：\n   - 绝对误差：$E(h) = \\left| D(x_0;h) - \\cos(x_0) \\right|$。\n\n4. 候选步长：\n   - 考虑等比数列 $h_k = 10^{a + k\\Delta}$，其中 $a=-16$，$\\Delta=10^{-2}$，$k \\in \\{0,1,2,\\dots,K\\}$ 且 $K=1500$。这将产生一个有限集合 $\\{h_k\\}$，其范围从 $10^{-16}$ 到 $10^{-1}$（包含两端）。\n\n5. 选择规则：\n   - 对于每个测试用例，从上述候选集合中选择使 $E(h)$ 最小的 $h^\\star$。如果有多个 $h$ 值达到相同的最小误差值，则选择其中最大的 $h$。\n\n6. 测试套件（所有角度均以弧度为单位）：\n   - 用例 1：$x_0 = 1.0$，格式 = 中心差分。\n   - 用例 2：$x_0 = 1.0$，格式 = 前向差分。\n   - 用例 3：$x_0 = \\dfrac{\\pi}{2}$，格式 = 中心差分。\n   - 用例 4：$x_0 = \\dfrac{\\pi}{2}$，格式 = 前向差分。\n   - 用例 5：$x_0 = 0.0$，格式 = 中心差分。\n   - 用例 6：$x_0 = 0.123$，格式 = 前向差分。\n\n您的程序必须根据上述第1-5项，为六个用例中的每一个计算出最小化步长$h^\\star$。最终输出必须是单行文本，其中包含一个由六个选定的$h^\\star$值组成的逗号分隔列表，并用方括号括起来，值的顺序与用例列表的顺序一致。每个返回的步长值都必须使用科学记数法表示，小数点后保留六位数字，例如$1.234567\\mathrm{e}{-08}$。因此，要求的最终输出格式为单行：\n[$h^\\star_1$,$h^\\star_2$,$h^\\star_3$,$h^\\star_4$,$h^\\star_5$,$h^\\star_6$]。", "solution": "问题要求我们确定一个最优步长 $h^\\star$，该步长可以使$f(x) = \\sin(x)$在几个点$x_0$上导数的有限差分近似的绝对误差最小化。这是数值分析中的一个经典问题，它揭示了截断误差和舍入误差之间的基本权衡。\n\n我们首先分析数值微分中的误差来源。对于给定的步长$h$，总绝对误差$E(h)$是数值近似值$D(x_0;h)$与真实导数$f'(x_0)$之间差值的绝对值：\n$$\nE(h) = |D(x_0;h) - f'(x_0)|\n$$\n这个总误差可以看作是两个主要组成部分之和：截断误差$E_{\\text{trunc}}(h)$和舍入误差$E_{\\text{round}}(h)$。\n\n1.  **截断误差**：这种误差是近似公式本身所固有的，源于对Taylor级数展开的截断。\n    -   对于**前向差分格式**，$D_{\\mathrm{fwd}}(x_0;h) = \\frac{f(x_0+h) - f(x_0)}{h}$，我们将$f(x_0+h)$在$x_0$处进行展开：\n        $$\n        f(x_0+h) = f(x_0) + h f'(x_0) + \\frac{h^2}{2} f''(x_0) + O(h^3)\n        $$\n        将此代入$D_{\\mathrm{fwd}}$的公式中可得：\n        $$\n        D_{\\mathrm{fwd}}(x_0;h) = f'(x_0) + \\frac{h}{2} f''(x_0) + O(h^2)\n        $$\n        因此，主阶截断误差与$h$成正比：\n        $$\n        E_{\\text{trunc, fwd}}(h) = \\left| \\frac{h}{2} f''(x_0) \\right|\n        $$\n        这是一种一阶精度的方法。对于$f(x)=\\sin(x)$，我们有$f''(x)=-\\sin(x)$，所以$E_{\\text{trunc, fwd}}(h) = \\frac{h}{2} |\\sin(x_0)|$。\n\n    -   对于**中心差分格式**，$D_{\\mathrm{cen}}(x_0;h) = \\frac{f(x_0+h) - f(x_0-h)}{2h}$，我们同时使用$f(x_0+h)$和$f(x_0-h)$的Taylor展开式：\n        $$\n        f(x_0 \\pm h) = f(x_0) \\pm h f'(x_0) + \\frac{h^2}{2} f''(x_0) \\pm \\frac{h^3}{6} f'''(x_0) + O(h^4)\n        $$\n        从$f(x_0+h)$的展开式中减去$f(x_0-h)$的展开式，可得：\n        $$\n        f(x_0+h) - f(x_0-h) = 2h f'(x_0) + \\frac{h^3}{3} f'''(x_0) + O(h^5)\n        $$\n        除以$2h$，我们得到：\n        $$\n        D_{\\mathrm{cen}}(x_0;h) = f'(x_0) + \\frac{h^2}{6} f'''(x_0) + O(h^4)\n        $$\n        主阶截断误差与$h^2$成正比：\n        $$\n        E_{\\text{trunc, cen}}(h) = \\left| \\frac{h^2}{6} f'''(x_0) \\right|\n        $$\n        这是一种二阶精度的方法。对于$f(x)=\\sin(x)$，我们有$f'''(x)=-\\cos(x)$，所以$E_{\\text{trunc, cen}}(h) = \\frac{h^2}{6} |\\cos(x_0)|$。\n\n    在这两种情况下，截断误差都随着$h$的减小而减小。\n\n2.  **舍入误差**：这种误差源于计算机中浮点运算的有限精度。当$h$非常小时，分子中的减法，例如$f(x_0+h) - f(x_0)$，涉及两个几乎相等的数。这会导致有效数字的损失，这种效应被称为灾难性抵消。计算$f(x)$的误差大致与机器epsilon $\\epsilon_{\\text{mach}}$和$f(x)$的大小成正比。因此，分子中的误差量级为$\\epsilon_{\\text{mach}} |f(x_0)|$。这个很小的绝对误差再被一个很小的数$h$除，从而放大了舍入误差。\n    $$\n    E_{\\text{round}}(h) \\approx \\frac{\\epsilon_{\\text{mach}} |f(x_0)|}{h}\n    $$\n    与截断误差不同，舍入误差随着$h$的减小而*增大*。\n\n总误差$E(h) \\approx E_{\\text{trunc}}(h) + E_{\\text{round}}(h)$是一个关于$h$的递减函数与一个关于$1/h$的递增函数之和。这个和在某个最优步长$h^\\star$处存在一个最小值。当$h > h^\\star$时，误差由截断误差主导；当$h < h^\\star$时，误差由舍入误差主导。\n\n问题要求在一个离散的、有限的候选步长集合$\\{h_k\\}$（其中$h_k = 10^{-16 + k \\cdot 10^{-2}}$，$k \\in \\{0, 1, \\dots, 1500\\}$）上对$h^\\star$进行经验性搜索。对于每个测试用例，算法按以下步骤进行：\n\n1.  定义点$x_0$和数值微分格式（前向或中心）。\n2.  计算精确导数，$d_{\\text{true}} = \\cos(x_0)$。\n3.  生成从最小到最大的有序候选步长集合$\\{h_k\\}$。\n4.  将最小误差$E_{\\min}$初始化为无穷大，将最优步长$h^\\star$初始化为一个占位符值。\n5.  遍历集合中的每个候选步长$h_k$。\n    a. 使用指定的格式计算数值导数$D(x_0; h_k)$。\n    b. 计算绝对误差$E(h_k) = |D(x_0; h_k) - d_{\\text{true}}|$。\n    c. 将$E(h_k)$与$E_{\\min}$进行比较。如果$E(h_k) \\le E_{\\min}$，则更新$E_{\\min} = E(h_k)$和$h^\\star = h_k$。由于迭代是从较小的$h_k$向较大的$h_k$进行，此更新规则确保了当多个$h_k$值产生相同的最小误差时，所选择的将是最大的那个$h_k$。这直接满足了问题陈述中指定的平局打破规则。\n6.  遍历所有$h_k$之后，最终的$h^\\star$值即为此测试用例的期望结果。\n\n对所有六个指定的测试用例重复此过程。然后收集得到的最佳步长，并根据输出规范进行格式化。当$x_0 = \\pi/2$时，中心差分会出现一个特殊情况。由于$\\sin(\\pi/2+h) = \\cos(h)$和$\\sin(\\pi/2-h) = \\cos(h)$，分子$f(x_0+h) - f(x_0-h)$在数学上为零。对于很大范围的$h$值，数值近似产生的误差都接近机器精度。在这种情况下，选择在平局时取最大$h$值的规则变得至关重要。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal finite-difference step size h by minimizing absolute error.\n\n    The function iterates through a set of candidate step sizes for six different\n    test cases involving forward and central difference approximations of the\n    derivative of sin(x). It finds the step size h that minimizes the\n    absolute error |D(x0;h) - cos(x0)|.\n    \"\"\"\n    # Define the six test cases as per the problem statement.\n    # Each case is a tuple: (x0, 'scheme_name')\n    test_cases = [\n        (1.0, 'central'),\n        (1.0, 'forward'),\n        (np.pi / 2, 'central'),\n        (np.pi / 2, 'forward'),\n        (0.0, 'central'),\n        (0.123, 'forward'),\n    ]\n\n    # Generate the candidate step sizes h_k = 10^(a + k*Delta)\n    a = -16.0\n    delta = 1e-2\n    K = 1500\n    exponents = a + np.arange(K + 1) * delta\n    h_values = np.power(10.0, exponents)\n\n    optimal_h_results = []\n\n    for x0, scheme in test_cases:\n        true_derivative = np.cos(x0)\n        \n        min_error = np.inf\n        optimal_h = -1.0\n\n        # Iterate through all candidate step sizes to find the minimum error.\n        # h_values are sorted in increasing order.\n        for h in h_values:\n            numerical_derivative = 0.0\n            if scheme == 'forward':\n                # Forward difference: (f(x+h) - f(x)) / h\n                numerical_derivative = (np.sin(x0 + h) - np.sin(x0)) / h\n            elif scheme == 'central':\n                # Central difference: (f(x+h) - f(x-h)) / (2h)\n                numerical_derivative = (np.sin(x0 + h) - np.sin(x0 - h)) / (2 * h)\n\n            error = np.abs(numerical_derivative - true_derivative)\n\n            # If the current error is less than or equal to the minimum error found so far,\n            # update the minimum error and the optimal h.\n            # Because we iterate from smallest h to largest h, this correctly implements\n            # the tie-breaking rule: \"select the largest such h\".\n            if error <= min_error:\n                min_error = error\n                optimal_h = h\n        \n        optimal_h_results.append(optimal_h)\n\n    # Format the results as specified: scientific notation with 6 decimal places.\n    formatted_results = [f\"{h:.6e}\" for h in optimal_h_results]\n    \n    # Print the final output in the required single-line format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2421640"}, {"introduction": "在物理系统的模拟中，保持像能量守恒这样的基本定律至关重要。本练习将对比一个简单的积分器（前向欧拉法）和一个“辛”积分器（速度Verlet算法）在模拟单摆时的表现。你将观察到算法的选择如何极大地影响系统的长期稳定性，并理解为何结构保持算法对于可靠的物理模拟是必不可少的。[@problem_id:2421691]", "problem": "你需要编写一个完整的、可运行的程序，来比较一个非辛时间积分器和一个辛时间积分器在演化单摆时的长期能量行为。使用单位长度、单位质量和单位引力加速度的无量纲单摆，其运动方程为\n$$\n\\frac{d\\theta}{dt}=\\omega,\\quad \\frac{d\\omega}{dt}=-\\sin(\\theta),\n$$\n其中 $\\theta$ 是角位移，$\\omega$ 是角速度。总机械能为\n$$\nE(\\theta,\\omega)=\\frac{1}{2}\\,\\omega^2 + \\left(1-\\cos\\theta\\right).\n$$\n角度必须以弧度为单位。所有量均为无量纲。实现一个非辛积分器（前向显式欧拉格式）和一个辛积分器（速度 Verlet 格式）。对于每次模拟，在长时程上计算每个时间步的能量，并量化长期的能量漂移。\n\n对于每个测试用例，从初始状态 $(\\theta(0),\\omega(0))$、恒定时间步长 $\\Delta t$ 和总时间 $T$ 开始，你必须：\n- 使用前向显式欧拉法，在区间 $[0,T]$ 上以步长 $\\Delta t$ 模拟该系统。\n- 使用速度 Verlet 法，在相同的区间和步长下模拟该系统。\n- 对于每种方法，使用在时间 $t_n=n\\,\\Delta t$（其中 $N=T/\\Delta t$）下的离散能量时间序列 $\\{E_n\\}_{n=0}^N$ 计算以下指标：\n  1. 最终相对能量误差，\n  $$\n  \\frac{E_N - E_0}{E_0}.\n  $$\n  2. $E_n$ 相对于 $t_n$ 的线性最小二乘漂移率除以 $E_0$（这是点 $(t_n,E_n)$ 的最佳拟合线的斜率，再除以 $E_0$），这是一个无量纲的单位时间漂移率。\n  3. 最大绝对相对能量偏差，\n  $$\n  \\max_{0\\le n\\le N}\\frac{|E_n - E_0|}{E_0}.\n  $$\n\n使用以下初始条件和数值参数的测试套件；所有角度均以弧度为单位：\n- 用例 1：$\\theta(0)=0.1$, $\\omega(0)=0.0$, $\\Delta t=0.01$, $T=100.0$。\n- 用例 2：$\\theta(0)=1.0$, $\\omega(0)=0.0$, $\\Delta t=0.05$, $T=200.0$。\n- 用例 3：$\\theta(0)=0.5$, $\\omega(0)=0.0$, $\\Delta t=0.2$, $T=100.0$。\n- 用例 4：$\\theta(0)=3.0$, $\\omega(0)=0.0$, $\\Delta t=0.01$, $T=200.0$。\n\n你的程序必须为每个用例生成一个包含六个实数的列表，顺序如下：\n$$\n\\left[\\text{欧拉法最终相对能量误差},\\ \\text{Verlet法最终相对能量误差},\\ \\text{欧拉法相对漂移率},\\ \\text{Verlet法相对漂移率},\\ \\text{欧拉法最大相对能量偏差},\\ \\text{Verlet法最大相对能量偏差}\\right].\n$$\n将四个用例的结果汇总成一个列表的列表，并保持上述用例顺序。你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`[[a,b,c,d,e,f],[...],...]`）。所有输出都是无量纲的实数。不需要绘制图表，也不应打印任何其他输出。", "solution": "该问题要求通过将一个非辛积分器（前向显式欧拉法）和一个辛积分器（速度 Verlet 法）应用于无量纲单摆，来比较这两种方法的性能。目标是量化并对比它们的长期能量守恒特性。分析将首先验证问题陈述，然后定义物理系统和数值格式，最后概述计算所需指标的实现方案。\n\n该问题被确定为有效的。它在科学上基于经典力学和数值分析的原理。方程组、能量函数、数值方法和评估指标都是标准且明确定义的。该问题是自包含的，为每个测试用例提供了所有必要的参数。没有矛盾、歧义或事实不准确之处。因此，我们着手解决。\n\n无量纲单摆的动力学由一个包含两个一阶常微分方程的系统描述：\n$$\n\\frac{d\\theta}{dt} = \\omega\n$$\n$$\n\\frac{d\\omega}{dt} = -\\sin(\\theta)\n$$\n这里，$\\theta$ 是与垂直方向的角位移，$\\omega$ 是角速度。系统的总机械能 $E$ 是其动能和势能之和，由下式给出：\n$$\nE(\\theta, \\omega) = \\frac{1}{2}\\omega^2 + (1 - \\cos\\theta)\n$$\n其中，在稳定平衡点 $\\theta=0$ 处势能为零。对于一个孤立的物理系统，该能量必须是守恒的。\n\n我们现在定义两种用于在离散时间步 $t_n = n \\Delta t$ 上近似解 $(\\theta(t), \\omega(t))$ 的数值积分器。\n\n**1. 前向显式欧拉法：**\n前向欧拉法是一种一阶、非辛积分器。它使用以下更新规则将时间 $t_n$ 的状态 $(\\theta_n, \\omega_n)$推进到时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $(\\theta_{n+1}, \\omega_{n+1})$：\n$$\n\\theta_{n+1} = \\theta_n + \\Delta t \\cdot \\omega_n\n$$\n$$\n\\omega_{n+1} = \\omega_n - \\Delta t \\cdot \\sin(\\theta_n)\n$$\n作为非辛方法，这种方法不保留哈密顿系统相空间流的几何结构。量级为 $O(\\Delta t^2)$ 的局部截断误差会在许多步之后系统性地累积。对于像单摆这样的振荡系统，这通常会导致计算出的能量出现长期漂移，通常是增加。能量误差预期会随时间 $T$ 线性增长。\n\n**2. 速度 Verlet 法：**\n速度 Verlet 法是一种二阶、辛积分器。它专为形如 $\\ddot{x} = a(x)$ 的系统设计，单摆系统 $\\ddot{\\theta} = -\\sin(\\theta)$ 正是这种情况。更新分三步进行：\n首先，将速度推进半步：\n$$\n\\omega_{n+1/2} = \\omega_n - \\sin(\\theta_n) \\frac{\\Delta t}{2}\n$$\n其次，使用这个中间速度将位置推进一整步：\n$$\n\\theta_{n+1} = \\theta_n + \\omega_{n+1/2} \\Delta t\n$$\n最后，使用新位置处的加速度将其余半步的速度推进：\n$$\n\\omega_{n+1} = \\omega_{n+1/2} - \\sin(\\theta_{n+1}) \\frac{\\Delta t}{2}\n$$\n根据设计，辛积分器会守恒一个“影子哈密顿量”，该量非常接近系统的真实哈密顿量。因此，它们不会表现出长期的能量漂移。计算出的能量 $E_n$ 会在真实的初始能量 $E_0$ 附近振荡，但误差 $|E_n - E_0|$ 在非常长（通常是指数级长）的模拟时间内保持有界。\n\n为了量化这些行为，我们将从离散能量时间序列 $\\{E_n\\}_{n=0}^N$（其中 $N=T/\\Delta t$）计算三个指标：\n1.  **最终相对能量误差, $\\frac{E_N - E_0}{E_0}$**：该指标衡量整个模拟区间内的净能量变化。对于欧拉法，预期值会显著非零，而对于 Verlet 法，它应该接近于零。\n2.  **相对漂移率**：这是拟合点 $(t_n, E_n)$ 的普通最小二乘线的斜率 $m$，并用初始能量 $E_0$ 进行归一化。斜率通过公式 $m = \\frac{\\sum_{n=0}^{N} (t_n - \\bar{t})(E_n - \\bar{E})}{\\sum_{n=0}^{N} (t_n - \\bar{t})^2}$ 计算，其中 $\\bar{t}$ 和 $\\bar{E}$ 是平均值。该指标直接量化了长期能量漂移的平均速率。我们预期欧拉法会得到一个显著的正值，而 Verlet 法的值会接近于零。\n3.  **最大绝对相对能量偏差, $\\max_{0\\le n\\le N}\\frac{|E_n - E_0|}{E_0}$**：该指标捕捉了能量波动的最大幅度。对于欧拉法，这主要由长期漂移决定。对于 Verlet 法，它衡量的是有界能量振荡的大小。\n\n实现过程将包括一个主程序，该程序遍历四个指定的测试用例。对于每个用例，分别使用欧拉和 Verlet 积分器执行模拟。每次运行的状态历史 $(\\theta_n, \\omega_n)$ 都将被存储。根据这些历史记录，计算出相应的能量时间序列 $\\{E_n\\}$。然后，为每种积分器计算三个指标。将得到的六个值收集起来并按要求格式化。这种系统化的方法可以对积分器进行直接和定量的比较，这将证明辛速度 Verlet 法卓越的长期稳定性。", "answer": "```python\nimport numpy as np\nimport json\n\ndef energy(theta, omega):\n    \"\"\"\n    Calculates the non-dimensional energy of the simple pendulum.\n    \"\"\"\n    return 0.5 * omega**2 + (1.0 - np.cos(theta))\n\ndef euler_step(theta, omega, dt):\n    \"\"\"\n    Performs a single step of the forward explicit Euler method.\n    \"\"\"\n    theta_next = theta + dt * omega\n    omega_next = omega - dt * np.sin(theta)\n    return theta_next, omega_next\n\ndef verlet_step(theta, omega, dt):\n    \"\"\"\n    Performs a single step of the velocity Verlet method.\n    \"\"\"\n    # Force (acceleration) function\n    def acceleration(th):\n        return -np.sin(th)\n\n    omega_half = omega + acceleration(theta) * (dt / 2.0)\n    theta_next = theta + omega_half * dt\n    omega_next = omega_half + acceleration(theta_next) * (dt / 2.0)\n    return theta_next, omega_next\n\ndef run_simulation(integrator_step_func, theta0, omega0, dt, T):\n    \"\"\"\n    Runs a simulation for the pendulum dynamics using a given integrator.\n    \"\"\"\n    if dt <= 0:\n        raise ValueError(\"Time step dt must be positive.\")\n    N = int(round(T / dt))\n    num_points = N + 1\n    \n    theta_hist = np.zeros(num_points)\n    omega_hist = np.zeros(num_points)\n    \n    theta_hist[0] = theta0\n    omega_hist[0] = omega0\n    \n    theta_n, omega_n = theta0, omega0\n    for n in range(N):\n        theta_n, omega_n = integrator_step_func(theta_n, omega_n, dt)\n        theta_hist[n + 1] = theta_n\n        omega_hist[n + 1] = omega_n\n        \n    return theta_hist, omega_hist\n\ndef calculate_metrics(T, dt, theta_hist, omega_hist):\n    \"\"\"\n    Calculates the three required energy metrics from a simulation history.\n    \"\"\"\n    num_points = len(theta_hist)\n    times = np.linspace(0, T, num_points)\n    \n    energies = energy(theta_hist, omega_hist)\n    E0 = energies[0]\n    EN = energies[-1]\n\n    if E0 == 0:\n        # This case is avoided by the problem's initial conditions,\n        # but as a safeguard, return NaNs.\n        return np.nan, np.nan, np.nan\n\n    # Metric 1: Final relative energy error\n    final_rel_err = (EN - E0) / E0\n\n    # Metric 2: Linear least-squares drift rate divided by E0\n    # The slope of the best-fit line to (times, energies) is the first\n    # coefficient returned by np.polyfit with deg=1.\n    slope = np.polyfit(times, energies, deg=1)[0]\n    rel_drift_rate = slope / E0\n\n    # Metric 3: Maximum absolute relative energy deviation\n    max_abs_rel_dev = np.max(np.abs((energies - E0) / E0))\n    \n    return final_rel_err, rel_drift_rate, max_abs_rel_dev\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (theta(0), omega(0), dt, T)\n        (0.1, 0.0, 0.01, 100.0),\n        (1.0, 0.0, 0.05, 200.0),\n        (0.5, 0.0, 0.2, 100.0),\n        (3.0, 0.0, 0.01, 200.0),\n    ]\n\n    all_results = []\n    for theta0, omega0, dt, T in test_cases:\n        # Run simulation with Forward Euler\n        euler_theta, euler_omega = run_simulation(euler_step, theta0, omega0, dt, T)\n        euler_metrics = calculate_metrics(T, dt, euler_theta, euler_omega)\n\n        # Run simulation with Velocity Verlet\n        verlet_theta, verlet_omega = run_simulation(verlet_step, theta0, omega0, dt, T)\n        verlet_metrics = calculate_metrics(T, dt, verlet_theta, verlet_omega)\n        \n        # Assemble the 6 metrics for the current case in the specified order\n        case_results = [\n            euler_metrics[0],  # Euler final relative error\n            verlet_metrics[0], # Verlet final relative error\n            euler_metrics[1],  # Euler relative drift rate\n            verlet_metrics[1], # Verlet relative drift rate\n            euler_metrics[2],  # Euler max relative deviation\n            verlet_metrics[2]  # Verlet max relative deviation\n        ]\n        all_results.append(case_results)\n\n    # Print the final result in the exact specified format `[[...],...]`\n    # Using json.dumps and replacing spaces ensures a compact, correct format.\n    print(json.dumps(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2421691"}]}