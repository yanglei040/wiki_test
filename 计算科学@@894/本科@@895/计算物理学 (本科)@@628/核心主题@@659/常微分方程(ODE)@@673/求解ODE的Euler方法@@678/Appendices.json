{"hands_on_practices": [{"introduction": "让我们从一个具体的电子学例子开始，建立我们的直觉。本练习将探讨一个简单的 RC 电路的响应，该系统的行为由一个一阶常微分方程控制。通过应用前向欧拉方法，我们将研究时间步长 $h$ 的选择如何对数值解的稳定性产生关键影响，有时甚至会产生不符合物理现实的振荡。这个实践对于理解条件稳定性的概念至关重要，这是使用显式数值方法时的一个核心考量 [@problem_id:2390244]。", "problem": "一个电阻-电容电路由一个电阻为 $R$ (单位 $\\Omega$) 的电阻器和一个电容为 $C$ (单位 $\\mathrm{F}$) 的电容器连接到一个电压源 $V_{\\text{in}}(t)$ (单位 $\\mathrm{V}$) 构成。电容器电压 $V(t)$ (单位 $\\mathrm{V}$) 满足以下一阶常微分方程\n$$\n\\frac{dV}{dt} = \\frac{1}{RC}\\big(V_{\\text{in}}(t)-V(t)\\big),\n$$\n其初始条件为 $V(0)=V_{\\text{init}}$。考虑 $V_{\\text{in}}(t)$ 为恒定值 $V_0$ （直流阶跃）的情况，以及 $V_{\\text{in}}(t)$ 为恒定值 $0$ 的情况。使用均匀步长 $h$ (单位 $\\mathrm{s}$) 对时间进行离散化，形成时间序列 $t_n = nh$，其中 $n\\in\\{0,1,2,\\dots,N\\}$ 且 $N=\\lfloor T_{\\text{end}}/h \\rfloor$，并通过步长为 $h$ 的显式单步更新方法生成的序列 $V_n$ 来近似 $V(t_n)$。对于下方的每一组参数，模拟从 $t=0$ 到 $t=T_{\\text{end}}$ 的过程，并计算以下量：\n\n1. 一个布尔值 $b_{\\text{osc}}$，当且仅当误差序列 $e_n$ 中存在至少一次符号变化时为 $\\text{True}$。当使用 $V_{\\text{in}}(t)=V_0$ 时，误差定义为 $e_n = V_n - V_0$；当使用 $V_{\\text{in}}(t)=0$ 时，误差定义为 $e_n = V_n$，其中 $n\\in\\{0,1,\\dots,N\\}$。在检测符号变化时，将满足 $|e_n|\\le \\varepsilon$ 的值视为零，其中 $\\varepsilon=10^{-12}$ (单位 $\\mathrm{V}$)。\n2. 一个布尔值 $b_{\\text{conv}}$，当且仅当序列在模拟结束时数值上收敛时为 $\\text{True}$。此处收敛的定义为同时满足 $|V_N - V_{N-1}| \\le \\tau$ 和 $\\max_{0\\le n\\le N} |V_n| \\le V_{\\max}$，其中 $\\tau=10^{-6}$ (单位 $\\mathrm{V}$) 且 $V_{\\max}=10^{6}$ (单位 $\\mathrm{V}$)。\n3. 一个浮点数 $V_{\\text{final}}$，其值为 $V_N$ (单位 $\\mathrm{V}$)，四舍五入到六位小数。如果在模拟过程中的任何时刻出现 $\\max_{0\\le n\\le N} |V_n| > V_{\\max}$，则将 $V_{\\text{final}}$ 报告为特殊浮点值 $\\mathrm{NaN}$。\n\n物理常数和单位必须一致使用：$R$ 的单位为 $\\Omega$，$C$ 的单位为 $\\mathrm{F}$，时间单位为 $\\mathrm{s}$，电压单位为 $\\mathrm{V}$。不涉及角度。所有布尔值必须是字面逻辑值，所有浮点数必须是定义的小数。不报告百分比。\n\n测试套件（每个元组列出 $(R,C,V_0,V_{\\text{init}},h,T_{\\text{end}})$）：\n\n- 案例 $1$ (基准，单调逼近): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=0.1\\,\\mathrm{s},\\; T_{\\text{end}}=5\\,\\mathrm{s})$.\n- 案例 $2$ (边界因子): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=1.0\\,\\mathrm{s},\\; T_{\\text{end}}=5\\,\\mathrm{s})$.\n- 案例 $3$ (振荡但衰减): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=1.5\\,\\mathrm{s},\\; T_{\\text{end}}=40\\,\\mathrm{s})$.\n- 案例 $4$ (振荡且在时限内不收敛): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=2.5\\,\\mathrm{s},\\; T_{\\text{end}}=20\\,\\mathrm{s})$.\n- 案例 $5$ (带电电容器的自由衰减): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=0\\,\\mathrm{V},\\; V_{\\text{init}}=5\\,\\mathrm{V},\\; h=1.5\\,\\mathrm{s},\\; T_{\\text{end}}=40\\,\\mathrm{s})$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个案例的结果为一个三元组，格式为 $[b_{\\text{osc}},b_{\\text{conv}},V_{\\text{final}}]$。整体输出格式必须为\n$[ [b_{\\text{osc}},b_{\\text{conv}},V_{\\text{final}}], [b_{\\text{osc}},b_{\\text{conv}},V_{\\text{final}}], \\dots ]$\n不含任何额外文本。例如，两个假设案例的有效输出为 $[[\\text{True},\\text{False},3.000000],[\\text{False},\\text{True},5.000000]]$。", "solution": "所提出的问题是一个良态的初值问题 (IVP)，用于模拟 RC 电路的一阶线性常微分方程 (ODE)。该问题具有科学依据、形式化规范和客观性。它要求使用规定的离散化方案对 ODE 进行数值求解，并计算与数值解行为相关的特定指标。该问题是有效的，并将提供一个解决方案。\n\n电容器电压 $V(t)$ 的控制 ODE 为：\n$$\n\\frac{dV}{dt} = \\frac{1}{RC} \\left( V_{\\text{in}}(t) - V(t) \\right)\n$$\n其初始条件为 $V(0) = V_{\\text{init}}$。\n\n问题指定了“显式单步更新”，对于一阶 ODE，这对应于前向欧拉 (Forward Euler) 方法。时域被离散化为大小为 $h$ 的步长，即 $t_n = nh$。时刻 $t_n$ 的电压，记为 $V(t_n)$，由序列 $V_n$ 近似。对于 ODE $\\frac{dy}{dt} = f(t,y)$，前向欧拉 (Forward Euler) 更新规则是 $y_{n+1} = y_n + h f(t_n, y_n)$。\n\n对于给定的 RC 电路 ODE，函数为 $f(t, V) = \\frac{1}{RC}(V_{\\text{in}}(t) - V)$。在每个测试案例中，输入电压 $V_{\\text{in}}(t)$ 是一个常数，我们记为 $V_{\\text{in,const}}$（等于 $V_0$ 或 $0$）。因此，$V_n$ 的更新规则是：\n$$\nV_{n+1} = V_n + h \\left( \\frac{1}{RC} (V_{\\text{in,const}} - V_n) \\right)\n$$\n设电路的时间常数为 $\\tau_{RC} = RC$。该方程可以重排以突出其作为线性递推关系式的结构：\n$$\nV_{n+1} = V_n \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) + V_{\\text{in,const}} \\left( \\frac{h}{\\tau_{RC}} \\right)\n$$\n为了分析此数值方案的稳定性和振荡行为，我们研究误差 $e_n$ 的演变，该误差定义为与稳态电压 $V_{\\text{in,const}}$ 的偏差。\n$$\ne_n = V_n - V_{\\text{in,const}}\n$$\n将 $V_n = e_n + V_{\\text{in,const}}$ 代入更新规则：\n$$\ne_{n+1} + V_{\\text{in,const}} = (e_n + V_{\\text{in,const}}) \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) + V_{\\text{in,const}} \\left( \\frac{h}{\\tau_{RC}} \\right)\n$$\n$$\ne_{n+1} = e_n \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) + V_{\\text{in,const}} \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) - V_{\\text{in,const}} + V_{\\text{in,const}} \\left( \\frac{h}{\\tau_{RC}} \\right)\n$$\n$$\ne_{n+1} = e_n \\left( 1 - \\frac{h}{\\tau_{RC}} \\right)\n$$\n这是一个关于误差的几何级数，$e_n = e_0 \\alpha^n$，其中初始误差为 $e_0 = V_{\\text{init}} - V_{\\text{in,const}}$，稳定性因子为 $\\alpha = 1 - h/\\tau_{RC}$。数值解的行为由 $\\alpha$ 的值决定：\n1.  $0  \\alpha  1$（即 $0  h/\\tau_{RC}  1$）：误差 $e_n$ 单调衰减至零且不改变符号。数值解单调地逼近稳态。这意味着 $b_{\\text{osc}} = \\text{False}$。\n2.  $-1  \\alpha \\le 0$（即 $1 \\le h/\\tau_{RC}  2$）：误差 $e_n$ 每一步都会改变符号，而其幅值衰减。数值解在收敛过程中围绕稳态振荡。这意味着 $b_{\\text{osc}} = \\text{True}$。\n3.  $\\alpha \\le -1$（即 $h/\\tau_{RC} \\ge 2$）：误差的幅值 $|e_n|$ 不会衰减。如果 $\\alpha = -1$，幅值恒定。如果 $\\alpha  -1$，幅值呈指数增长。数值解是不稳定的。这意味着 $b_{\\text{osc}} = \\text{True}$（因为符号交替变化），但解不会收敛。\n\n针对每组参数解决该问题的算法如下：\n1.  计算模拟所需的常数：时间常数 $\\tau_{RC} = R \\times C$，以及总步数 $N = \\lfloor T_{\\text{end}}/h \\rfloor$。\n2.  确定恒定输入电压 $V_{\\text{in,const}}$。\n3.  初始化一个大小为 $N+1$ 的数组 `voltages`，并设初始条件 `voltages[0]` $= V_{\\text{init}}$。\n4.  从 $n=0$ 到 $N-1$ 迭代，使用更新规则 $V_{n+1} = V_n(1 - h/\\tau_{RC}) + V_{\\text{in,const}}(h/\\tau_{RC})$ 生成序列 $V_n$。\n5.  在模拟期间，跟踪最大绝对电压 $\\max_{0\\le n\\le N} |V_n|$，以对照发散阈值 $V_{\\max} = 10^6\\,\\mathrm{V}$ 进行检查。\n6.  模拟结束后，计算所需的量：\n    a.  **$b_{\\text{osc}}$**：创建误差序列 $e_n = V_n - V_{\\text{in,const}}$（如果 $V_{\\text{in,const}}=0$，则为 $e_n=V_n$）。遍历误差序列。如果任何两个连续的非零误差（非零定义为 $|e_n| > \\varepsilon = 10^{-12}\\,\\mathrm{V}$）的符号相反，则记录一次符号变化。\n    b.  **$b_{\\text{conv}}$**：检查是否满足发散条件。如果 $\\max|V_n| > V_{\\max}$，则收敛性为假。否则，检查最终电压变化是否在容差范围内：$|V_N - V_{N-1}| \\le \\tau = 10^{-6}\\,\\mathrm{V}$。必须同时满足这两个条件，$b_{\\text{conv}}$ 才为 $\\text{True}$。\n    c.  **$V_{\\text{final}}$**：如果解已发散 ($\\max|V_n| > V_{\\max}$)，则其值为特殊浮点数 $\\mathrm{NaN}$。否则，其为最终电压 $V_N$。输出时结果将被格式化为六位小数。\n\n将此程序应用于五个测试案例中的每一个，以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RC circuit problem for all test cases using the Forward Euler method.\n    \"\"\"\n    \n    # Each tuple lists (R, C, V0, V_init, h, T_end)\n    test_cases = [\n        (1e3, 1e-3, 5.0, 0.0, 0.1, 5.0),\n        (1e3, 1e-3, 5.0, 0.0, 1.0, 5.0),\n        (1e3, 1e-3, 5.0, 0.0, 1.5, 40.0),\n        (1e3, 1e-3, 5.0, 0.0, 2.5, 20.0),\n        (1e3, 1e-3, 0.0, 5.0, 1.5, 40.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(simulate_rc_circuit(case))\n    \n    # Format the final output string as a list of lists.\n    # The str() representation of a list is already '[...]'.\n    # For floats, format to 6 decimal places. NaN is handled correctly.\n    formatted_results = []\n    for res in results:\n        b_osc, b_conv, v_final = res\n        if np.isnan(v_final):\n            v_final_str = 'nan'\n        else:\n            v_final_str = f\"{v_final:.6f}\"\n        formatted_results.append(f\"[{b_osc},{b_conv},{v_final_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef simulate_rc_circuit(params):\n    \"\"\"\n    Simulates one RC circuit case and calculates the required metrics.\n    \"\"\"\n    R, C, V0, V_init, h, T_end = params\n    \n    # Physical and numerical constants from the problem statement\n    RC = R * C\n    N = int(T_end / h)\n    eps = 1e-12\n    tau = 1e-6\n    V_max = 1e6\n    \n    # The constant input voltage is V0, unless V0=0, then it's a free decay.\n    V_in_const = V0\n\n    voltages = np.zeros(N + 1)\n    voltages[0] = V_init\n    \n    max_abs_V = abs(V_init)\n    is_diverged = False\n    \n    # Stability factor and terms for the recurrence relation\n    alpha = 1.0 - h / RC\n    beta = V_in_const * (h / RC)\n\n    # Simulation loop using the Forward Euler method\n    for n in range(N):\n        voltages[n+1] = voltages[n] * alpha + beta\n        \n        # Track maximum absolute voltage for divergence check\n        current_abs_v = abs(voltages[n+1])\n        if current_abs_v > max_abs_V:\n            max_abs_V = current_abs_v\n    \n    # Check for divergence after the simulation is complete\n    if max_abs_V > V_max:\n        is_diverged = True\n        \n    # --- 1. Oscillation Check (b_osc) ---\n    b_osc = False\n    errors = voltages - V_in_const\n\n    def get_sign(val):\n        if val > eps:\n            return 1\n        if val  -eps:\n            return -1\n        return 0\n\n    last_sign = get_sign(errors[0])\n    for i in range(1, N + 1):\n        current_sign = get_sign(errors[i])\n        if last_sign * current_sign  0:\n            b_osc = True\n            break\n        if current_sign != 0:\n            last_sign = current_sign\n\n    # --- 2. Convergence Check (b_conv) ---\n    b_conv = False\n    if not is_diverged:\n        # Check if the final step size is within the convergence tolerance\n        if abs(voltages[N] - voltages[N-1]) = tau:\n            b_conv = True\n\n    # --- 3. Final Voltage (V_final) ---\n    if is_diverged:\n        V_final = np.nan\n    else:\n        V_final = voltages[N]\n        \n    return [b_osc, b_conv, V_final]\n\nsolve()\n```", "id": "2390244"}, {"introduction": "现在，我们将注意力从耗散系统转向物理学中一个基本的保守系统：谐振子。本练习将引导你在相空间中探索该系统的演化，并检验一个关键的物理定律——刘维尔定理（Liouville's theorem），该定理要求相空间体积守恒。你将会发现，标准的向前欧拉方法尽管简单，却无法维持这一定律，这暴露了其在哈密顿系统长期模拟中的一个严重缺陷 [@problem_id:2390251]。这一观察结果推动了对一类称为辛积分器（symplectic integrators）的特殊数值方法的需求。", "problem": "考虑一维谐振子，其哈密顿量为 $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k q^2}{2}$，其中 $q$ 是广义坐标，$p$ 是共轭动量。相空间 $(q,p)$ 中的精确哈密顿流满足哈密顿方程 $\\dot{q}=\\dfrac{\\partial H}{\\partial p}$ 和 $\\dot{p}=-\\dfrac{\\partial H}{\\partial q}$，这组方程定义了一个常微分方程（ODE）系统。\n\n通过对哈密顿方程进行时间步长为 $h$ 的前向（显式）时间离散化，定义一个离散时间映射 $(q_n,p_n)\\mapsto(q_{n+1},p_{n+1})$：\n- $q_{n+1}=q_n+h\\,\\dfrac{p_n}{m}$，\n- $p_{n+1}=p_n-h\\,k\\,q_n$。\n\n设相空间中的初始区域为一个以 $(q_0,p_0)$ 为中心、边长分别为 $\\delta q$ 和 $\\delta p$ 的轴对齐矩形。其四个角点为\n- $(q_0-\\delta q/2,\\;p_0-\\delta p/2)$，\n- $(q_0+\\delta q/2,\\;p_0-\\delta p/2)$，\n- $(q_0+\\delta q/2,\\;p_0+\\delta p/2)$，\n- $(q_0-\\delta q/2,\\;p_0+\\delta p/2)$，\n按逆时针顺序列出。初始面积为 $A_0=\\delta q\\,\\delta p$。\n\n对于下方的每一组参数，将四个角点在离散时间映射下各演化 $N$ 步，得到它们的像点。这些像点在 $(q,p)$ 平面中形成一个四边形。使用演化后同样按逆时针顺序列出的顶点计算该四边形的面积 $A_N$，并报告面积比 $R=A_N/A_0$（无量纲）。所有测试用例均使用相同的 $(q_0,p_0,\\delta q,\\delta p)$：\n- $q_0=0.3$，\n- $p_0=-0.5$，\n- $\\delta q=10^{-3}$，\n- $\\delta p=10^{-3}$。\n\n测试套件（每个用例为 $(m,k,h,N)$）：\n- 用例 1：$(m,k,h,N)=(1,\\;1,\\;0.1,\\;100)$。\n- 用例 2：$(m,k,h,N)=(1,\\;1,\\;0.0,\\;10)$。\n- 用例 3：$(m,k,h,N)=(2,\\;8,\\;0.05,\\;400)$。\n- 用例 4：$(m,k,h,N)=(1,\\;4,\\;0.45,\\;5)$。\n\n您的程序必须为每个用例计算 $R$，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个 $R$ 值四舍五入到六位小数（例如，$[2.000000,1.500000]$）。所有报告的值都是无量纲的；不要包含单位、角度单位或百分号。最终输出必须是遵循指定格式的单行文本。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 哈密顿量：$H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k q^2}{2}$\n- 哈密顿方程：$\\dot{q}=\\dfrac{\\partial H}{\\partial p} = \\dfrac{p}{m}$ 和 $\\dot{p}=-\\dfrac{\\partial H}{\\partial q} = -kq$\n- 离散时间映射（前向欧拉法）：\n  - $q_{n+1}=q_n+h\\,\\dfrac{p_n}{m}$\n  - $p_{n+1}=p_n-h\\,k\\,q_n$\n- 初始相空间区域：一个以 $(q_0,p_0)$ 为中心、边长分别为 $\\delta q$ 和 $\\delta p$ 的轴对齐矩形。\n- 初始角点（逆时针）：\n  - $(q_0-\\delta q/2,\\;p_0-\\delta p/2)$\n  - $(q_0+\\delta q/2,\\;p_0-\\delta p/2)$\n  - $(q_0+\\delta q/2,\\;p_0+\\delta p/2)$\n  - $(q_0-\\delta q/2,\\;p_0+\\delta p/2)$\n- 初始面积：$A_0=\\delta q\\,\\delta p$\n- 任务：将四个角点演化 $N$ 步，计算所得四边形的面积 $A_N$，并报告比率 $R=A_N/A_0$。\n- 固定的初始参数：$q_0=0.3$，$p_0=-0.5$，$\\delta q=10^{-3}$，$\\delta p=10^{-3}$。\n- 测试用例 $(m,k,h,N)$：\n  - 用例 1：$(1,\\;1,\\;0.1,\\;100)$\n  - 用例 2：$(1,\\;1,\\;0.0,\\;10)$\n  - 用例 3：$(2,\\;8,\\;0.05,\\;400)$\n  - 用例 4：$(1,\\;4,\\;0.45,\\;5)$\n\n步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了谐振子，这是经典力学中的一个基本系统。它采用了哈密顿方程，这是经典动力学的一种标准表述。所用的数值方法，即显式（前向）欧拉法，是一种众所周知（尽管简单）的求解常微分方程的技术。问题的前提具有科学合理性。\n- **适定性**：所有必要的参数（$m, k, h, N, q_0, p_0, \\delta q, \\delta p$）均已提供。计算结果的指令明确无歧义。每个测试用例都存在唯一的、有意义的解。\n- **客观性**：问题以精确的数学和算法术语陈述，没有主观性或含糊不清之处。\n\n步骤 3：结论与行动\n该问题是有效的。这是一个定义明确的计算物理练习，具体涉及将数值积分器应用于哈密顿系统的性质。将提供一个解决方案。\n\n该问题要求通过跟踪四个顶点进行数值计算。然而，更基础的分析揭示了其根本原理。该离散时间映射是一个线性变换。设状态向量为 $\\mathbf{x}_n = \\begin{pmatrix} q_n \\\\ p_n \\end{pmatrix}$。该映射可以写成矩阵形式：\n$$\n\\mathbf{x}_{n+1} = \\begin{pmatrix} q_{n+1} \\\\ p_{n+1} \\end{pmatrix} = \\begin{pmatrix} q_n + h \\frac{p_n}{m} \\\\ p_n - h k q_n \\end{pmatrix} = \\begin{pmatrix} 1  h/m \\\\ -hk  1 \\end{pmatrix} \\begin{pmatrix} q_n \\\\ p_n \\end{pmatrix}\n$$\n设此单步演化矩阵为 $M = \\begin{pmatrix} 1  h/m \\\\ -hk  1 \\end{pmatrix}$。这是一个线性映射。线性代数的一个基本定理指出，线性变换会以一个恒定的因子缩放平面中的所有面积，该因子等于变换矩阵行列式的绝对值。\n\n单步矩阵 $M$ 的行列式为：\n$$\n\\det(M) = (1)(1) - \\left(\\frac{h}{m}\\right)(-hk) = 1 + \\frac{h^2 k}{m}\n$$\n由于 $h \\ge 0$、$k > 0$ 且 $m > 0$（用例 2 中 $h=0$ 的情况除外），我们有 $\\det(M) \\ge 1$。相空间中任何区域的面积在每一步都会乘以这个因子。\n\n经过 $N$ 步后，总变换由矩阵 $M^N$ 给出。总面积缩放因子为 $\\det(M^N)$。利用矩阵乘积的行列式等于行列式的乘积这一性质，我们有：\n$$\n\\det(M^N) = (\\det(M))^N\n$$\n最终面积 $A_N$ 与初始面积 $A_0$ 之比恰好是这个缩放因子。因此，面积比 $R$ 由以下精确的解析表达式给出：\n$$\nR = \\frac{A_N}{A_0} = \\left(1 + \\frac{h^2 k}{m}\\right)^N\n$$\n只要变换是线性的，这个结果就与初始形状、其面积 $A_0$ 或其位置 $(q_0, p_0)$ 无关。面积不守恒（即 $\\det(M) \\neq 1$）是显式欧拉法应用于哈密顿系统时的一个已知缺陷。一个合格的辛积分器会保持相空间面积，意味着其行列式将恰好为 $1$。\n\n该问题要求通过演化四个角点来进行数值模拟。虽然这不如解析推导优雅，但必须按指令实现。步骤如下：\n\n1.  初始化矩形的四个角点 $(q, p)$：\n    - $P_1 = (q_0 - \\delta q/2, p_0 - \\delta p/2)$\n    - $P_2 = (q_0 + \\delta q/2, p_0 - \\delta p/2)$\n    - $P_3 = (q_0 + \\delta q/2, p_0 + \\delta p/2)$\n    - $P_4 = (q_0 - \\delta q/2, p_0 + \\delta p/2)$\n\n2.  对每个角点，迭代映射 $N$ 次。对于从 $0$ 到 $N-1$ 的 $n$：\n    - $q_{n+1} = q_n + \\frac{h}{m} p_n$\n    - $p_{n+1} = p_n - h k q_n$\n    在更新 $p_{n+1}$ 时使用 $q_n$ 而非新计算出的 $q_{n+1}$ 至关重要。\n\n3.  经过 $N$ 步后，我们得到一个平行四边形的四个最终顶点：$P'_1=(q'_1, p'_1)$、$P'_2=(q'_2, p'_2)$、$P'_3=(q'_3, p'_3)$ 和 $P'_4=(q'_4, p'_4)$。\n\n4.  这个变换后的四边形的面积 $A_N$ 可以使用鞋带公式计算，该公式适用于按顺序列出顶点的多边形 $(q_i, p_i)$：\n    $$\n    A_N = \\frac{1}{2} \\left| \\sum_{i=1}^{4} (q_i p_{i+1} - q_{i+1} p_i) \\right|\n    $$\n    其中索引 $i+1$ 对 $4$ 取模（因此 $(q_5, p_5) = (q_1, p_1)$）。因为变换是线性的，最终的四边形是一个平行四边形，其面积也可以通过表示相邻边的向量的叉积的模来计算，例如 $|\\det(P'_2 - P'_1, P'_4 - P'_1)|$。\n\n5.  初始面积为 $A_0 = \\delta q \\cdot \\delta p = (10^{-3}) \\cdot (10^{-3}) = 10^{-6}$。\n\n6.  所需的比率为 $R = A_N / A_0$。此过程得到的数值结果必须与上面推导的解析公式一致。这证实了实现的正确性。\n\n我们现在将此应用于给定的测试用例。\n\n- **用例 1**：$(m,k,h,N) = (1, 1, 0.1, 100)$\n  $R = \\left(1 + \\frac{(0.1)^2 (1)}{1}\\right)^{100} = (1.01)^{100} \\approx 2.704814$\n\n- **用例 2**：$(m,k,h,N) = (1, 1, 0.0, 10)$\n  当 $h=0.0$ 时，映射为恒等映射：$q_{n+1}=q_n$ 且 $p_{n+1}=p_n$。点不移动，面积不改变。\n  $R = \\left(1 + \\frac{(0.0)^2 (1)}{1}\\right)^{10} = (1)^{10} = 1.0$\n\n- **用例 3**：$(m,k,h,N) = (2, 8, 0.05, 400)$\n  $R = \\left(1 + \\frac{(0.05)^2 (8)}{2}\\right)^{400} = (1 + \\frac{0.0025 \\cdot 8}{2})^{400} = (1 + 0.01)^{400} \\approx 53.593453$\n\n- **用例 4**：$(m,k,h,N) = (1, 4, 0.45, 5)$\n  $R = \\left(1 + \\frac{(0.45)^2 (4)}{1}\\right)^{5} = (1 + 0.2025 \\cdot 4)^{5} = (1 + 0.81)^{5} = (1.81)^{5} \\approx 19.344930$\n\n实现将遵循指定的数值步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the phase space area ratio for a harmonic oscillator\n    evolved with the explicit Euler method.\n    \"\"\"\n\n    # Define the fixed initial parameters for the phase space patch.\n    q0 = 0.3\n    p0 = -0.5\n    dq = 1e-3\n    dp = 1e-3\n\n    # The initial area of the rectangle.\n    A0 = dq * dp\n\n    # Define the four initial corner points of the rectangle in counterclockwise order.\n    # The shape is (4, 2) where each row is a (q, p) coordinate.\n    initial_corners = np.array([\n        [q0 - dq / 2, p0 - dp / 2],\n        [q0 + dq / 2, p0 - dp / 2],\n        [q0 + dq / 2, p0 + dp / 2],\n        [q0 - dq / 2, p0 + dp / 2]\n    ])\n\n    test_cases = [\n        # Case 1: (m, k, h, N)\n        (1.0, 1.0, 0.1, 100),\n        # Case 2\n        (1.0, 1.0, 0.0, 10),\n        # Case 3\n        (2.0, 8.0, 0.05, 400),\n        # Case 4\n        (1.0, 4.0, 0.45, 5)\n    ]\n\n    results = []\n    for m, k, h, N in test_cases:\n        # Start with a fresh copy of the initial corners for each test case.\n        corners = np.copy(initial_corners)\n\n        # Evolve the four corner points for N steps.\n        for _ in range(N):\n            q_n = corners[:, 0]\n            p_n = corners[:, 1]\n            \n            # Apply the explicit Euler update rules.\n            # It's crucial to use the old q_n and p_n for both updates.\n            q_np1 = q_n + h * p_n / m\n            p_np1 = p_n - h * k * q_n\n            \n            # Update the corners for the next iteration.\n            corners[:, 0] = q_np1\n            corners[:, 1] = p_np1\n        \n        final_corners = corners\n        \n        # Calculate the area of the final quadrilateral using the Shoelace formula.\n        # This formula works for any simple polygon.\n        # Area = 0.5 * |(x1y2 + x2y3 + ... + xny1) - (y1x2 + y2x3 + ... + ynx1)|\n        # A vectorized implementation using np.roll is efficient.\n        q = final_corners[:, 0]\n        p = final_corners[:, 1]\n        \n        # We use np.roll to get the next vertex in the sequence.\n        # np.roll(p, -1) gets [p2, p3, p4, p1]\n        term1 = np.sum(q * np.roll(p, -1))\n        # np.roll(q, -1) gets [q2, q3, q4, q1]\n        term2 = np.sum(p * np.roll(q, -1))\n        \n        A_N = 0.5 * np.abs(term1 - term2)\n        \n        # Calculate the area ratio R.\n        # For h=0, A_N might be extremely close but not exactly A0 due to float precision.\n        # However, A0 is also very small, so division is safe.\n        if A0 == 0:\n            area_ratio = 1.0 if A_N == 0 else np.inf\n        else:\n            area_ratio = A_N / A0\n            \n        results.append(f\"{area_ratio:.6f}\")\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2390251"}, {"introduction": "基于前一个练习中发现的向前欧拉方法无法守恒物理量的缺陷，本实践将介绍一个简单而优雅的解决方案：半隐式欧拉方法，通常也称为欧拉-克罗默（Euler-Cromer）方法。我们将应用标准欧拉和半隐式欧拉方法来模拟彗星的轨道，这是一个经典的开普勒问题。通过比较两种模拟的长期能量漂移，你将见证欧拉-克罗默方法卓越的稳定性，这为辛积分在长期保持物理系统定性特征方面的威力提供了一个实际的证明 [@problem_id:2390259]。", "problem": "考虑一个牛顿二体系统，该系统模拟一个质量可忽略不计的彗星绕一个中心大质量天体运行。在无量纲引力单位制下进行计算，其中引力常数与中心天体质量的乘积归一化为 $G M = 1$，彗星质量为 $m = 1$。运动被限制在一个平面内，位置向量为 $\\mathbf{x}(t) \\in \\mathbb{R}^2$，速度为 $\\mathbf{v}(t) = d\\mathbf{x}/dt$。所使用的基本定律是牛顿第二定律和平方反比引力定律，它们导出以下一阶系统\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}.\n$$\n在这些单位制下，总机械能（哈密顿量）为\n$$\nH(\\mathbf{x},\\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert},\n$$\n对于连续动力学系统，该值不随时间变化。\n\n您的任务是仅基于核心定义 $d\\mathbf{x}/dt = \\mathbf{v}$ 和 $d\\mathbf{v}/dt = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$，为此常微分方程（ODE，ordinary differential equation）设计并实现两个一阶时间步进积分器：\n- 一个标准的显式欧拉积分器，它使用在当前时间层级上计算的速度来推进位置。\n- 一个半隐式欧拉积分器（也称为 Euler–Cromer），它使用当前位置的加速度来推进速度，然后在同一步内使用更新后的速度来推进位置。\n\n从第一性原理出发，通过以步长 $\\Delta t$ 离散化时间，并一致地应用上述定义来构造步进更新逻辑，推导每种方法的更新逻辑。除此显式时间离散化外，不要引入任何额外的近似，并确保两种方法在每一步开始时都使用相同的力计算公式 $\\mathbf{a}(\\mathbf{x}) = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$。\n\n使用以下测试套件。对于每种情况，使用固定的时间步长 $\\Delta t$ 对指定的轨道周期数 $P$ 进行积分。在这些单位制下，半长轴为 $a$ 的开普勒椭圆的轨道周期是 $T = 2\\pi a^{3/2}$。初始状态被选择为圆形轨道上或椭圆轨道的远日点上，初始速度垂直于半径向量且方向为顺行运动。在这些单位制下，所有量都是无量纲的。\n\n- 测试用例 $1$（圆形“理想路径”）：$a = 1$, $e = 0$, 初始状态 $\\mathbf{x}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$, $\\Delta t = 0.01$, $P = 50$。\n- 测试用例 $2$（中等偏心率彗星）：$a = 1$, $e = 0.6$, 远日点初始状态 $\\mathbf{x}_0 = (1.6, 0)$, $\\mathbf{v}_0 = (0, 0.5)$, $\\Delta t = 0.001$, $P = 20$。\n- 测试用例 $3$（高偏心率彗星）：$a = 1$, $e = 0.9$, 远日点初始状态 $\\mathbf{x}_0 = (1.9, 0)$, $\\mathbf{v}_0 \\approx (0, 0.22941573387)$, $\\Delta t = 0.0005$, $P = 5$。\n- 测试用例 $4$（边界时间步长，圆形轨道）：$a = 1$, $e = 0$, 初始状态 $\\mathbf{x}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$, $\\Delta t = 0.05$, $P = 5$。\n\n对于每个测试用例，计算每个积分器的相对末端能量漂移，\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H(\\mathbf{x}_N,\\mathbf{v}_N) - H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|}{\\left| H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|},\n$$\n其中 $N = \\left\\lceil \\frac{P \\, T}{\\Delta t} \\right\\rceil$ 是所采取的步数，然后返回比率\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}.\n$$\n该比率 $r$ 是无量纲的。若 $r  1$ ，则表明在相同时间内，半隐式欧拉（Euler–Cromer）方法比标准显式欧拉方法表现出更小的绝对能量漂移。\n\n最终输出格式：您的程序应生成单行输出，其中包含测试用例 1–4 的 $r$ 值，以逗号分隔的列表形式排列，并用方括号括起，例如 $[r_1,r_2,r_3,r_4]$。条目必须是浮点数。输出中不含任何物理单位，因为根据设计，所有量都是无量纲的。\n\n您的实现必须是完全自包含的，并且不得读取任何输入。每个测试用例的答案是单个浮点数 $r$。这四个输出的集合必须遵循上述格式显示在一行上。通过始终使用标准的双精度算术，并忠实地实现根据所述基本定律和定义推导出的两种积分器，来确保数值稳定性。", "solution": "问题陈述已经过严格验证，并被证实是有效的。它在科学上基于经典力学原理，特别是开普勒问题，并且在数学上是一个适定的常微分方程组初值问题。问题中的参数和目标定义精确，不含任何矛盾、模糊或事实错误。该任务是计算物理学中的一个标准练习，要求推导和比较两种基本的数值积分器。\n\n我们接下来进行推导和求解。\n\n该系统由一组关于位置向量 $\\mathbf{x}(t) \\in \\mathbb{R}^2$ 和速度向量 $\\mathbf{v}(t) \\in \\mathbb{R}^2$ 的一阶常微分方程（ODE）描述：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}) = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}\n$$\n这里，$\\mathbf{a}(\\mathbf{x})$ 是由引力引起的加速度，引力参数 $G M$ 设为 $1$。\n\n我们将使用一个恒定的时间步长 $\\Delta t$ 来离散化时间。设系统在时间 $t_n = n \\Delta t$ 的状态为 $(\\mathbf{x}_n, \\mathbf{v}_n)$。我们寻求在时间 $t_{n+1} = t_n + \\Delta t$ 找到状态 $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$。\n\n**标准显式欧拉积分器的推导**\n\n显式（或前向）欧拉方法使用当前时间层级 $t_n$ 上的值来近似导数。\n第一个 ODE 的离散近似是：\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{x}}{dt} \\right|_{t_n} = \\mathbf{v}_n\n$$\n同样，对于第二个 ODE：\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t_n} = \\mathbf{a}(\\mathbf{x}_n)\n$$\n重新整理这些表达式，得到显式欧拉方法的更新规则。首先，根据当前位置 $\\mathbf{x}_n$ 计算加速度 $\\mathbf{a}_n$。然后，使用时间 $t_n$ 的状态来推进位置和速度。\n\n单步的更新逻辑是：\n1.  计算加速度：$\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  更新速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  更新位置：$\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n \\Delta t$\n\n其关键特征是，新位置 $\\mathbf{x}_{n+1}$ 是使用旧速度 $\\mathbf{v}_n$ 计算的，而不是使用新计算出的速度 $\\mathbf{v}_{n+1}$。\n\n**半隐式欧拉（Euler–Cromer）积分器的推导**\n\n半隐式欧拉方法（也称为 Euler-Cromer 方法）引入了一个细微但关键的修改。首先执行速度的更新，然后立即使用这个新计算出的速度来更新位置。在单一步长内对时间层级的这种“混合”使用定义了其半隐式的特性。\n\n速度的更新与显式方法保持相同：\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\mathbf{a}(\\mathbf{x}_n) \\implies \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{x}_n) \\Delta t\n$$\n然而，位置的更新使用新的速度 $\\mathbf{v}_{n+1}$：\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\mathbf{v}_{n+1}\n$$\n\n单步的更新逻辑是：\n1.  计算加速度：$\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  更新速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  更新位置：$\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1} \\Delta t$\n\n该方法是一个简单的辛积分器。对于像开普勒问题这样的哈密顿系统，此类积分器表现出卓越的长期稳定性，特别是在能量守恒方面。它们不完全守恒能量，但能量误差通常保持有界，并围绕真实值振荡，而显式欧拉方法通常会导致能量的长期漂移。\n\n**模拟与评估方法**\n\n对于每个测试用例，我们使用每个积分器进行一次模拟，共两次。\n初始状态为 $(\\mathbf{x}_0, \\mathbf{v}_0)$。\n总积分时间由轨道周期数 $P$ 指定。半长轴为 $a$ 的开普勒轨道的周期为 $T = 2\\pi a^{3/2}$。\n所需的总步数为 $N = \\lceil (P \\cdot T) / \\Delta t \\rceil$。\n\n连续系统的守恒量是机械能，或哈密顿量：\n$$\nH(\\mathbf{x}, \\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert}\n$$\n我们计算初始能量 $H_0 = H(\\mathbf{x}_0, \\mathbf{v}_0)$。经过 $N$ 步后，我们得到最终状态 $(\\mathbf{x}_N, \\mathbf{v}_N)$ 并计算最终能量 $H_N = H(\\mathbf{x}_N, \\mathbf{v}_N)$。\n\n每个积分器的性能通过相对末端能量漂移 $\\delta$ 来量化：\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H_N - H_0 \\right|}{\\left| H_0 \\right|}\n$$\n问题要求计算两种方法这些漂移的比率 $r$：\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}\n$$\n若 $r  1$，则表明对于给定的参数，半隐式 Euler-Cromer 方法比标准显式欧拉方法提供了更好的长期能量守恒性。实现将精确遵循这些推导。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem using explicit Euler and semi-implicit Euler\n    methods and computes the ratio of their energy drifts.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        # case 1: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.01, P=50\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.01, 'P': 50},\n        # case 2: a=1, e=0.6, x0=(1.6,0), v0=(0,0.5), dt=0.001, P=20\n        {'a': 1.0, 'x0': np.array([1.6, 0.0]), 'v0': np.array([0.0, 0.5]), 'dt': 0.001, 'P': 20},\n        # case 3: a=1, e=0.9, x0=(1.9,0), v0=(0, ~0.2294), dt=0.0005, P=5\n        {'a': 1.0, 'x0': np.array([1.9, 0.0]), 'v0': np.array([0.0, 0.22941573387]), 'dt': 0.0005, 'P': 5},\n        # case 4: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.05, P=5\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.05, 'P': 5},\n    ]\n\n    results = []\n\n    def hamiltonian(x, v):\n        \"\"\"Computes the Hamiltonian (total energy) of the system.\"\"\"\n        r_norm = np.linalg.norm(x)\n        v_norm_sq = np.dot(v, v)\n        return 0.5 * v_norm_sq - 1.0 / r_norm\n\n    def run_explicit_euler(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the standard explicit Euler method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Store old velocity for position update\n            v_old = v\n            # Update velocity\n            v = v + a * dt\n            # Update position using old velocity\n            x = x + v_old * dt\n        return x, v\n\n    def run_euler_cromer(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the semi-implicit Euler-Cromer method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Update velocity\n            v = v + a * dt\n            # Update position using new velocity\n            x = x + v * dt\n        return x, v\n        \n    for case in test_cases:\n        a = case['a']\n        x0 = case['x0']\n        v0 = case['v0']\n        dt = case['dt']\n        P = case['P']\n\n        # Calculate orbital period and number of steps\n        T = 2.0 * np.pi * a**(1.5)\n        N = int(np.ceil(P * T / dt))\n\n        # Initial energy\n        H0 = hamiltonian(x0, v0)\n\n        # Run Explicit Euler simulation\n        x_N_euler, v_N_euler = run_explicit_euler(x0, v0, N, dt)\n        H_N_euler = hamiltonian(x_N_euler, v_N_euler)\n        delta_euler = np.abs(H_N_euler - H0) / np.abs(H0)\n\n        # Run Euler-Cromer simulation\n        x_N_cromer, v_N_cromer = run_euler_cromer(x0, v0, N, dt)\n        H_N_cromer = hamiltonian(x_N_cromer, v_N_cromer)\n        delta_cromer = np.abs(H_N_cromer - H0) / np.abs(H0)\n\n        # Calculate the ratio of energy drifts\n        # Handle the case where delta_euler is zero to avoid division by zero\n        if delta_euler == 0.0:\n            # If Euler has no drift, and Cromer does, ratio is infinity.\n            # If neither has drift, ratio is undefined, but 1.0 is a neutral choice.\n            # In practice, with finite precision, this is unlikely.\n            r = 1.0 if delta_cromer == 0.0 else np.inf\n        else:\n            r = delta_cromer / delta_euler\n        \n        results.append(r)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390259"}]}