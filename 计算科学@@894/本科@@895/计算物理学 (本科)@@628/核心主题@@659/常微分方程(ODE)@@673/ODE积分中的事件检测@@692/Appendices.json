{"hands_on_practices": [{"introduction": "在许多物理和工程系统中，精确检测状态变量何时达到临界边界至关重要。本练习将通过模拟一个微机电系统（MEMS）加速度计来实践这一概念。[@problem_id:2390610] 你的任务是确定内部质量块何时撞击其外壳，即所谓的“触底”事件。这个实践旨在帮助你掌握如何设置事件函数来监控和捕捉系统达到其物理极限的瞬间。", "problem": "一个单自由度微机电系统（MEMS）加速度计可以建模为一个通过线性弹簧和阻尼器连接到外壳的检验质量。设检验质量的绝对位移为 $X(t)$，外壳（基座）的绝对位移为 $Y(t)$。定义相对位移为 $x(t) = X(t) - Y(t)$。外壳受到一个给定的基座加速度 $a_b(t) = \\ddot{Y}(t)$。检验质量被限制在外壳内部，使得相对位移被约束在区间 $[-d_{\\max}, d_{\\max}]$ 内。当 $|x(t)| = d_{\\max}$ 时，检验质量与外壳发生物理接触（此情况称为“触底”）。您的任务是从第一性原理出发，推导 $x(t)$ 的控制常微分方程（ODE），然后实现一个带有稳健事件检测功能的数值积分器，以确定首次发生触底的时间 $t_e$（如果它在指定的时间范围內发生）。\n\n从应用于检验质量的牛顿第二定律以及检验质量与外壳之间的线性粘性阻尼模型开始。使用速度和加速度作为时间导数的定义。不要假设任何预先推导的相对运动公式；从绝对运动出发，使用 $x(t) = X(t) - Y(t)$ 以及线性的弹簧和阻尼力进行推导。\n\n一旦推导出 $x(t)$ 的控制常微分方程，实现一个数值积分算法，该算法能够：\n- 从初始条件 $(x(0), \\dot{x}(0))$ 开始，随时间对系统进行前向积分。\n- 在首次满足 $x(t) = d_{\\max}$ 或 $x(t) = -d_{\\max}$ 时检测到一个事件。\n- 将 $|x(0)| = d_{\\max}$ 的情况视为在 $t = 0$ 时发生的瞬时事件，不进行积分。\n- 如果事件在仿真时域 $T_{\\text{end}}$ 结束前发生，则在第一个事件处停止积分。\n\n在整个过程中使用物理上一致的单位。质量单位为千克，刚度为牛顿/米，阻尼为牛顿·秒/米，位移为米，时间为秒，加速度为米/秒平方。正弦函数的参数必须是弧度。\n\n您的程序必须实现以下四个测试用例，它们共同构成测试套件。在所有情况下，最终的时间输出以秒为单位，速度输出以米/秒为单位。\n\n- 测试用例 1（在负阶跃基座加速度下的正边界碰撞）：\n  - 质量：$m = 1.0 \\times 10^{-6}\\,\\mathrm{kg}$\n  - 阻尼：$c = 3.162 \\times 10^{-4}\\,\\mathrm{N\\cdot s/m}$\n  - 刚度：$k = 10\\,\\mathrm{N/m}$\n  - 最大位移：$d_{\\max} = 1.0 \\times 10^{-5}\\,\\mathrm{m}$\n  - 初始条件：$x(0) = 0\\,\\mathrm{m}$，$\\dot{x}(0) = 0\\,\\mathrm{m/s}$\n  - 基座加速度：常数阶跃 $a_b(t) = a_0$，其中 $a_0 = -150\\,\\mathrm{m/s^2}$\n  - 时间范围：$T_{\\text{end}} = 0.05\\,\\mathrm{s}$\n\n- 测试用例 2（在有界正弦基座加速度下无接触，非共振）：\n  - 质量：$m = 1.0 \\times 10^{-6}\\,\\mathrm{kg}$\n  - 阻尼：$c = 3.162 \\times 10^{-4}\\,\\mathrm{N\\cdot s/m}$\n  - 刚度：$k = 10\\,\\mathrm{N/m}$\n  - 最大位移：$d_{\\max} = 1.0 \\times 10^{-5}\\,\\mathrm{m}$\n  - 初始条件：$x(0) = 0\\,\\mathrm{m}$，$\\dot{x}(0) = 0\\,\\mathrm{m/s}$\n  - 基座加速度：正弦 $a_b(t) = A \\sin(2\\pi f t)$，其中 $A = 8\\,\\mathrm{m/s^2}$，$f = 100\\,\\mathrm{Hz}$\n  - 时间范围：$T_{\\text{end}} = 0.5\\,\\mathrm{s}$\n\n- 测试用例 3（在正阶跃基座加速度下的负边界碰撞）：\n  - 质量：$m = 1.0 \\times 10^{-6}\\,\\mathrm{kg}$\n  - 阻尼：$c = 3.162 \\times 10^{-4}\\,\\mathrm{N\\cdot s/m}$\n  - 刚度：$k = 10\\,\\mathrm{N/m}$\n  - 最大位移：$d_{\\max} = 1.0 \\times 10^{-5}\\,\\mathrm{m}$\n  - 初始条件：$x(0) = 0\\,\\mathrm{m}$，$\\dot{x}(0) = 0\\,\\mathrm{m/s}$\n  - 基座加速度：常数阶跃 $a_b(t) = a_0$，其中 $a_0 = +150\\,\\mathrm{m/s^2}$\n  - 时间范围：$T_{\\text{end}} = 0.05\\,\\mathrm{s}$\n\n- 测试用例 4（初始化时立即接触）：\n  - 质量：$m = 1.0 \\times 10^{-6}\\,\\mathrm{kg}$\n  - 阻尼：$c = 3.162 \\times 10^{-4}\\,\\mathrm{N\\cdot s/m}$\n  - 刚度：$k = 10\\,\\mathrm{N/m}$\n  - 最大位移：$d_{\\max} = 1.0 \\times 10^{-5}\\,\\mathrm{m}$\n  - 初始条件：$x(0) = d_{\\max}\\,\\mathrm{m}$，$\\dot{x}(0) = 0\\,\\mathrm{m/s}$\n  - 基座加速度：$a_b(t) = 0\\,\\mathrm{m/s^2}$\n  - 时间范围：$T_{\\text{end}} = 0.01\\,\\mathrm{s}$\n\n对于每个测试用例，您的程序必须输出一个包含四个条目的列表：\n- 一个布尔值，指示是否在 $T_{\\text{end}}$ 之前发生触底。\n- 事件时间 $t_e$（以秒为单位）（如果未发生事件，则使用 $-1.0$）。\n- 事件发生时的相对速度 $\\dot{x}(t_e)$（以米/秒为单位）（如果未发生事件，则使用 $0.0$）。\n- 一个整数，用于标识碰撞的边界：如果 $x(t_e) = d_{\\max}$ 则为 $+1$，如果 $x(t_e) = -d_{\\max}$ 则为 $-1$，如果未发生事件则为 $0$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表应由每个测试用例的一个此类四条目列表组成，顺序与上述指定相同。例如：\"[[True,0.012345,0.456789,1],[False,-1.0,0.0,0],[...],[...]]\"。", "solution": "问题陈述已经过严格验证，被认为是科学上可靠、适定且客观的。它提出了一个机械振动和计算物理学中的标准问题，并提供了所有必要的数据和条件。不存在逻辑矛盾、事实错误或模糊之处。因此，我将着手进行推导和求解。\n\n任务是确定一个 MEMS 加速度计首次“触底”的时间，该加速度计被建模为一个受基座激励的、有阻尼的单自由度机械系统。这包括两个主要步骤：首先，从基本原理推导相对位移的控制运动方程；其次，实现一个带有事件检测的数值解法，以找到精确的碰撞时刻。\n\n**1. 控制常微分方程 (ODE) 的推导**\n\n该系统由一个检验质量 $m$ 组成，它通过刚度为 $k$ 的线性弹簧和阻尼系数为 $c$ 的粘性阻尼器连接到一个外壳上。检验质量的绝对位移为 $X(t)$，外壳的绝对位移为 $Y(t)$。相对位移定义为 $x(t) = X(t) - Y(t)$。\n\n我们从应用于检验质量 $m$ 的牛顿第二定律开始。作用在质量上的所有外力之和等于该质量乘以其绝对加速度 $\\ddot{X}(t)$。\n$$ \\sum F = m \\ddot{X}(t) $$\n作用在质量上的力来自弹簧和阻尼器。这些力由质量和外壳之间的相对运动产生。\n弹簧力 $F_s$ 与相对位移 $x(t)$ 成正比：\n$$ F_s = -k x(t) $$\n阻尼力 $F_d$ 与相对速度 $\\dot{x}(t) = \\dot{X}(t) - \\dot{Y}(t)$ 成正比：\n$$ F_d = -c \\dot{x}(t) $$\n将这些力代入牛顿定律，得到以绝对加速度 $\\ddot{X}(t)$ 表示的运动方程：\n$$ -k x(t) - c \\dot{x}(t) = m \\ddot{X}(t) $$\n为了得到一个仅用相对位移 $x(t)$ 表示的方程，我们使用定义 $x(t) = X(t) - Y(t)$ 来表示 $\\ddot{X}(t)$。将此定义对时间 $t$ 求导两次，得到：\n$$ X(t) = x(t) + Y(t) $$\n$$ \\dot{X}(t) = \\dot{x}(t) + \\dot{Y}(t) $$\n$$ \\ddot{X}(t) = \\ddot{x}(t) + \\ddot{Y}(t) $$\n问题通过其加速度 $a_b(t) = \\ddot{Y}(t)$ 来指定基座的运动。将此式以及 $\\ddot{X}(t)$ 的表达式代入运动方程：\n$$ -k x(t) - c \\dot{x}(t) = m (\\ddot{x}(t) + a_b(t)) $$\n将各项重新整理成二阶线性常微分方程的标准形式，我们得到相对位移 $x(t)$ 的控制方程：\n$$ m \\ddot{x}(t) + c \\dot{x}(t) + k x(t) = -m a_b(t) $$\n这个方程描述了检验质量相对于外壳的相对运动动力学，该运动由基座加速度 $a_b(t)$ 驱动。\n\n**2. 状态空间表示法**\n\n常微分方程的数值积分器通常在一阶方程组上操作。我们必须将我们的二阶常微分方程转换为这种形式。我们定义一个状态向量 $\\mathbf{z}(t)$，它由相对位移和相对速度组成：\n$$ \\mathbf{z}(t) = \\begin{bmatrix} z_0(t) \\\\ z_1(t) \\end{bmatrix} = \\begin{bmatrix} x(t) \\\\ \\dot{x}(t) \\end{bmatrix} $$\n状态向量的时间导数 $\\dot{\\mathbf{z}}(t)$ 为：\n$$ \\dot{\\mathbf{z}}(t) = \\begin{bmatrix} \\dot{z}_0(t) \\\\ \\dot{z}_1(t) \\end{bmatrix} = \\begin{bmatrix} \\dot{x}(t) \\\\ \\ddot{x}(t) \\end{bmatrix} $$\n根据我们的状态定义，第一个分量是 $\\dot{z}_0 = z_1$。第二个分量 $\\dot{z}_1 = \\ddot{x}$ 通过重新整理控制常微分方程得到：\n$$ \\ddot{x}(t) = \\frac{1}{m} \\left( -c \\dot{x}(t) - k x(t) - m a_b(t) \\right) $$\n代入状态变量 $z_0$ 和 $z_1$：\n$$ \\dot{z}_1(t) = -\\frac{c}{m} z_1(t) - \\frac{k}{m} z_0(t) - a_b(t) $$\n因此，一阶常微分方程组为：\n$$ \\dot{\\mathbf{z}}(t) = \\mathbf{f}(t, \\mathbf{z}(t)) = \\begin{bmatrix} z_1(t) \\\\ -\\frac{k}{m} z_0(t) - \\frac{c}{m} z_1(t) - a_b(t) \\end{bmatrix} $$\n现在，给定一个初始状态 $\\mathbf{z}(0) = [x(0), \\dot{x}(0)]^T$，这个系统就可以进行数值求解了。\n\n**3. 事件检测**\n\n问题要求找到检验质量首次与外壳接触的时间 $t_e$。这个被称为“触底”的事件，在相对位移的绝对值等于最大允许间隙时发生，即 $|x(t)| = d_{\\max}$。这等效于两个条件：\n1.  $x(t) - d_{\\max} = 0$（在正边界接触）\n2.  $x(t) + d_{\\max} = 0$（在负边界接触）\n\n这是一个与常微分方程的时间积分同时进行的求根问题。我们将使用 SciPy 库中的 `scipy.integrate.solve_ivp` 函数，该函数内置了对此类事件检测的支持。\n\n我们定义两个事件函数，它们的根对应于触底条件：\n$$ g_p(t, \\mathbf{z}) = z_0(t) - d_{\\max} $$\n$$ g_n(t, \\mathbf{z}) = z_0(t) + d_{\\max} $$\n积分器将在积分过程中监控 $g_p$ 和 $g_n$ 的值，并定位它们穿过零点的时间 $t$。通过将这些事件函数的 `terminal` 属性设置为 `True`，我们指示积分器在找到根的第一个时间 $t_e > 0$ 处停止。\n\n由 `solve_ivp` 返回的解对象提供了事件发生的时间 $t_e$ 和系统在该时刻的状态 $\\mathbf{z}(t_e)$。由此，我们可以提取事件时间和相对速度 $\\dot{x}(t_e) = z_1(t_e)$。碰撞边界的符号（$+1$ 或 $-1$）由触发终止的事件函数是 $g_p$ 还是 $g_n$ 来决定。如果积分在没有任何事件被触发的情况下完成，直到最终时间 $T_{\\text{end}}$，这表示没有发生接触。\n\n一种特殊情况是系统在边界处启动，即 $|x(0)| = d_{\\max}$。在这种情况下，无需进行积分，事件被记录为在 $t_e=0$ 时发生。\n\n**4. 实现策略**\n\n最终的程序将按以下方式构建：\n- 将定义一个测试用例列表，每个用例包含物理参数（$m, c, k, d_{\\max}$）、初始条件（$x(0), \\dot{x}(0)$）、基座加速度函数 $a_b(t)$ 和仿真时间范围 $T_{\\text{end}}$。\n- 程序将遍历每个测试用例。\n- 对于每个用例，它将首先检查在 $t=0$ 时是否存在瞬时事件。\n- 如果没有瞬时事件，它将定义 ODE 系统函数和上述两个终止事件函数。\n- 将调用 `scipy.integrate.solve_ivp` 来对系统从 $t=0$ 积分到 $t=T_{\\text{end}}$。\n- 将分析 `solve_ivp` 的输出。如果程序因事件而终止，则提取事件时间、最终速度和边界标识符（$+1$ 或 $-1$）。\n- 如果积分在没有事件的情况下完成，则按规定记录结果（无事件，$t_e = -1.0$，$\\dot{x}(t_e) = 0.0$，side=$0$）。\n- 所有结果被编译成一个最终的列表之列表，并格式化为单个字符串用于输出，严格遵守指定的格式。这确保了对问题陈述的完整和正确回应。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Derives the ODE for a MEMS accelerometer, solves it numerically for four\n    test cases, and detects the first \"bottoming out\" event.\n    \"\"\"\n    test_cases = [\n        {\n            \"m\": 1.0e-6, \"c\": 3.162e-4, \"k\": 10.0, \"d_max\": 1.0e-5,\n            \"x0\": 0.0, \"xdot0\": 0.0,\n            \"ab_func\": lambda t: -150.0, \"T_end\": 0.05,\n        },\n        {\n            \"m\": 1.0e-6, \"c\": 3.162e-4, \"k\": 10.0, \"d_max\": 1.0e-5,\n            \"x0\": 0.0, \"xdot0\": 0.0,\n            \"ab_func\": lambda t: 8.0 * np.sin(2 * np.pi * 100 * t), \"T_end\": 0.5,\n        },\n        {\n            \"m\": 1.0e-6, \"c\": 3.162e-4, \"k\": 10.0, \"d_max\": 1.0e-5,\n            \"x0\": 0.0, \"xdot0\": 0.0,\n            \"ab_func\": lambda t: 150.0, \"T_end\": 0.05,\n        },\n        {\n            \"m\": 1.0e-6, \"c\": 3.162e-4, \"k\": 10.0, \"d_max\": 1.0e-5,\n            \"x0\": 1.0e-5, \"xdot0\": 0.0,\n            \"ab_func\": lambda t: 0.0, \"T_end\": 0.01,\n        }\n    ]\n\n    # ODE system function\n    # z = [x, x_dot]\n    # dz/dt = [x_dot, x_ddot]\n    # m*x_ddot + c*x_dot + k*x = -m*a_b\n    def ode_system(t, z, m, c, k, ab_func):\n        x, x_dot = z\n        x_ddot = (-c * x_dot - k * x - m * ab_func(t)) / m\n        return [x_dot, x_ddot]\n\n    results = []\n    for params in test_cases:\n        m, c, k = params[\"m\"], params[\"c\"], params[\"k\"]\n        d_max = params[\"d_max\"]\n        x0, xdot0 = params[\"x0\"], params[\"xdot0\"]\n        ab_func = params[\"ab_func\"]\n        T_end = params[\"T_end\"]\n        \n        # Check for immediate event at t=0\n        if np.isclose(x0, d_max):\n            results.append([True, 0.0, xdot0, 1])\n            continue\n        if np.isclose(x0, -d_max):\n            results.append([True, 0.0, xdot0, -1])\n            continue\n\n        # Event function for positive boundary contact\n        def event_pos(t, z, m, c, k, ab_func):\n            return z[0] - d_max\n        event_pos.terminal = True\n        event_pos.direction = 0\n\n        # Event function for negative boundary contact\n        def event_neg(t, z, m, c, k, ab_func):\n            return z[0] + d_max\n        event_neg.terminal = True\n        event_neg.direction = 0\n        \n        y0 = [x0, xdot0]\n        t_span = [0, T_end]\n        \n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=t_span,\n            y0=y0,\n            method='RK45',\n            args=(m, c, k, ab_func),\n            events=[event_pos, event_neg],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        if sol.status == 1:  # An event was triggered\n            event_occurred = True\n            hit_side = 0\n            \n            # Check which event occurred first\n            t_e_pos = sol.t_events[0][0] if len(sol.t_events[0]) > 0 else np.inf\n            t_e_neg = sol.t_events[1][0] if len(sol.t_events[1]) > 0 else np.inf\n            \n            if t_e_pos <= t_e_neg:\n                event_time = t_e_pos\n                event_state = sol.y_events[0][0]\n                hit_side = 1\n            else:\n                event_time = t_e_neg\n                event_state = sol.y_events[1][0]\n                hit_side = -1\n\n            event_velocity = event_state[1]\n            results.append([event_occurred, event_time, event_velocity, hit_side])\n            \n        else:  # Integration finished without event\n            results.append([False, -1.0, 0.0, 0])\n\n    # Format the final output string exactly as specified in the problem description,\n    # without extraneous spaces.\n    output_parts = []\n    for res_list in results:\n        # Convert boolean to lowercase 'true'/'false' if needed by a stricter parser,\n        # but standard str() is 'True'/'False' which is fine for Python eval.\n        # Problem example uses 'True'/'False', so str() is correct.\n        part = '[' + ','.join(map(str, res_list)) + ']'\n        output_parts.append(part)\n\n    final_output_string = '[' + ','.join(output_parts) + ']'\n    print(final_output_string)\n\nsolve()\n```", "id": "2390610"}, {"introduction": "事件检测不仅限于固定边界。本练习将挑战你处理一个更动态的场景：一个抛射体撞击一个抛物线形的山丘。[@problem_id:2390630] 其事件函数 $y(t) = h(x(t))$ 依赖于系统的多个状态变量，这要求你构建一个能反映不同自由度之间相互作用的条件。通过解决这个问题，你将学会如何为非平凡的几何约束定义和实现事件检测。", "problem": "考虑一个质点抛体在无空气动力阻力的均匀引力场中的弹道运动。设抛体的状态由位置 $(x(t), y(t))$（单位：米）和速度 $(v_x(t), v_y(t))$（单位：米/秒）给出。其动力学遵循牛顿第二定律，其中存在一个指向下方的恒定重力加速度 $g$。地面是一个确定的、完全刚性的抛物线表面，由高度函数 $h(x) = a x^2 + b$ 描述，其中 $a$ 的单位是米⁻¹，$b$ 的单位是米。碰撞事件发生在满足 $y(t_{\\text{hit}}) = h(x(t_{\\text{hit}}))$ 的最早时间 $t_{\\text{hit}} > 0$处，并且只有当轨迹从上向下穿越表面时，该事件才被检测到。碰撞后无反弹。假设抛体的初始状态由位置 $(x(0), y(0)) = (x_0, y_0)$（单位：米）和初速度 $v_0$（单位：米/秒）以及一个从 $x$ 轴正方向测量的发射角 $\\theta$（角度以度为单位提供）指定。\n\n根据第一性原理，该运动由以下常微分方程（ordinary differential equation (ODE)）控制：\n- $dx/dt = v_x$，\n- $dy/dt = v_y$，\n- $dv_x/dt = 0$，\n- $dv_y/dt = -g$。\n\n定义事件函数 $\\phi(t) = y(t) - h(x(t))$。碰撞时间 $t_{\\text{hit}}$ 是 $\\phi(t)$ 的最小正根，且其方向性穿越为负（即 $\\phi$ 从正值穿越到负值）。\n\n您的任务是编写一个完整的程序，对以下每个测试用例，从 $t = 0$ 开始对常微分方程进行时间上的正向积分，直到发生第一次碰撞事件，或者如果未发生事件，则直到达到有限的截止时间 $t_{\\max}$。使用以下规则：\n- 使用 $g = 9.81$ 米/秒²。\n- 在使用三角函数之前，将发射角 $\\theta$ 从度转换为弧度。\n- 事件由 $\\phi(t) = y(t) - (a x(t)^2 + b)$ 定义，且检测仅限于向下穿越。\n- 如果检测到事件，则返回四元组 $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$，其中 $v_{\\text{hit}} = \\sqrt{v_x(t_{\\text{hit}})^2 + v_y(t_{\\text{hit}})^2}$ 是碰撞时的速率。\n- 如果在 $[0, t_{\\max}]$ 区间内未发生事件，则返回 $[\\mathrm{nan}, \\mathrm{nan}, \\mathrm{nan}, \\mathrm{nan}]$。\n\n所有答案必须以国际单位制（SI）表示：时间单位为秒，位置单位为米，速率单位为米/秒。角度以度为单位提供，必须在内部转换为弧度。您的程序必须将报告的每个浮点值四舍五入到六位小数。\n\n测试套件（每个用例为 $(a, b, x_0, y_0, v_0, \\theta, t_{\\max})$）：\n- 用例 A（通用“理想路径”）：$(0.02, 0.0, 0.0, 2.0, 20.0, 30.0, 10.0)$。\n- 用例 B（在凸起山丘上方近水平发射）：$(0.05, 1.0, 0.0, 1.5, 10.0, 0.0, 10.0)$。\n- 用例 C（大角度发射；因山丘升高，碰撞发生较晚）：$(0.001, 0.0, 0.0, 1.0, 50.0, 60.0, 30.0)$。\n- 用例 D（在固定水平位置垂直下落）：$(0.01, 2.0, 5.0, 5.0, 0.0, 90.0, 10.0)$。\n\n最终输出格式：您的程序应生成一行输出，其中包含四个用例的结果，格式为一个由逗号分隔的列表，并用方括号括起。列表中的每个元素本身也是一个列表，形式为 $[t_1,x_1,y_1,v_1]$。例如：$[[t_1,x_1,y_1,v_1],[t_2,x_2,y_2,v_2],[t_3,x_3,y_3,v_3],[t_4,x_4,y_4,v_4]]$。每个数字必须按照规定四舍五入到六位小数。", "solution": "所提出的问题是有效的。这是一个在经典力学和计算物理学领域中定义明确的问题，其基础是运动学和常微分方程的既定原理。所有必要的条件和参数都已提供，并且没有科学或逻辑上的不一致之处。我们将着手提供一个解决方案。\n\n该问题要求对描述抛体运动的常微分方程（ODEs）系统进行数值求解，积分过程在一个特定事件发生时终止：即抛体与抛物线表面的碰撞。此任务的核心是正确构建动力学系统并实现事件检测算法。\n\n首先，我们定义系统在任意时间 $t \\ge 0$ 的状态。状态向量 $S(t)$ 由抛体的位置和速度分量给出：\n$$\nS(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\\\ v_x(t) \\\\ v_y(t) \\end{bmatrix}\n$$\n该系统的动力学由质点在均匀引力场（加速度为 $g$）中的牛顿第二定律决定。这产生了一个包含四个一阶常微分方程的系统：\n$$\n\\frac{dS}{dt} = \\frac{d}{dt} \\begin{bmatrix} x \\\\ y \\\\ v_x \\\\ v_y \\end{bmatrix} = \\begin{bmatrix} v_x \\\\ v_y \\\\ 0 \\\\ -g \\end{bmatrix} = F(S)\n$$\n初始状态 $S(0)$ 由给定的初始条件确定：位置 $(x_0, y_0)$、速率 $v_0$ 和发射角 $\\theta$。角度 $\\theta$ 必须首先从度转换为弧度，我们称之为 $\\theta_{\\text{rad}}$。初始速度分量为：\n$$\nv_x(0) = v_0 \\cos(\\theta_{\\text{rad}})\n$$\n$$\nv_y(0) = v_0 \\sin(\\theta_{\\text{rad}})\n$$\n因此，初始状态向量被完全指定为 $S(0) = [x_0, y_0, v_x(0), v_y(0)]^T$。\n\n碰撞事件由抛体的垂直位置 $y(t)$ 等于抛物线地表高度 $h(x(t)) = ax(t)^2 + b$ 这一条件定义。我们定义一个事件函数 $\\phi(t)$，其根对应于轨迹与表面的交点：\n$$\n\\phi(t) = y(t) - h(x(t)) = y(t) - (a \\cdot x(t)^2 + b)\n$$\n如果在时间 $t_{\\text{hit}}$ 处 $\\phi(t_{\\text{hit}}) = 0$，则发生碰撞。此问题指定了两个额外约束条件：\n$1$. 碰撞必须是 $t > 0$ 的最早此类事件。\n$2$. 仅当向下穿越时才检测到该事件，这意味着抛体正从表面上方移动到其下方。这可转换为事件函数在根处递减的条件，即 $\\frac{d\\phi}{dt} \\bigg|_{t=t_{\\text{hit}}} < 0$。\n\n解决此类问题的标准且最稳健的方法是使用包含事件检测求根功能的数值常微分方程积分器。SciPy 库中的 `scipy.integrate.solve_ivp` 函数正是为此目的而设计的。\n\n对于每个测试用例，算法按以下步骤进行：\n$1$. **初始化**：使用参数 $(a, b, x_0, y_0, v_0, \\theta, t_{\\max})$ 定义具体的问题实例。重力常数为 $g = 9.81 \\, \\text{m/s}^2$。按上文所述计算初始状态向量 $S(0)$。积分时间区间为 $[0, t_{\\max}]$。\n\n$2$. **常微分方程系统定义**：定义一个函数（例如 `ode_system(t, S)`）来计算导数向量 $\\frac{dS}{dt}$。该函数实现运动方程，返回 $[S_2, S_3, 0, -g]$，其中 $S_i$ 是状态向量的第 $i$ 个分量（为清晰起见，使用基于1的索引）。\n\n$3$. **事件函数定义**：定义一个函数（例如 `event_func(t, S)`）来计算事件函数 $\\phi(t, S(t)) = S_1 - (a \\cdot S_0^2 + b)$ 的值。为满足问题约束，我们为求解器配置此事件函数：\n    - 将其 `terminal` 属性设置为 `True`。这会指示求解器在找到事件时终止积分。\n    - 将其 `direction` 属性设置为 $-1$。这会指示求解器仅报告事件函数递减（从正值穿越到负值）的根，这与物理要求相匹配。\n\n$4$. **数值积分**：使用常微分方程系统、时间区间、初始状态向量和配置好的事件函数来调用 `solve_ivp` 函数。我们还必须请求 `dense_output=True`，以确保求解器能够在积分步之间准确定位根。\n\n$5$. **结果提取**：求解器返回后，我们检查其输出。\n    - 如果 `sol.t_events` 列表不为空，则表示成功检测到事件。第一个元素 `sol.t_events[0][0]` 给出碰撞时间 $t_{\\text{hit}}$。碰撞时的相应状态 $S(t_{\\text{hit}})$ 可以在 `sol.y_events[0][0]` 中找到。\n    - 从碰撞状态中，我们提取位置 $(x_{\\text{hit}}, y_{\\text{hit}})$ 和速度 $(v_{x,\\text{hit}}, v_{y,\\text{hit}})$。最终的碰撞速率计算为 $v_{\\text{hit}} = \\sqrt{v_{x,\\text{hit}}^2 + v_{y,\\text{hit}}^2}$。\n    - 如果 `sol.t_events` 列表为空，则表示在 $[0, t_{\\max}]$ 区间内没有发生满足条件的事件。在这种情况下，所有四个输出值都报告为非数值（`nan`）。\n\n$6$. **格式化**：最终的数值结果 $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$ 按要求四舍五入到六位小数。\n\n此过程为问题提供了一个完整、正确且稳健的解决方案，它使用标准的、经过验证的计算工具直接实现了物理原理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the impact time and state of a projectile on a parabolic surface.\n    \"\"\"\n    # Gravitational constant in m/s^2\n    G = 9.81\n\n    # Test suite: (a, b, x0, y0, v0, theta, t_max)\n    test_cases = [\n        # Case A (general “happy path”)\n        (0.02, 0.0, 0.0, 2.0, 20.0, 30.0, 10.0),\n        # Case B (near-horizontal launch above a raised hill)\n        (0.05, 1.0, 0.0, 1.5, 10.0, 0.0, 10.0),\n        # Case C (steep launch; impact occurs later as the hill rises)\n        (0.001, 0.0, 0.0, 1.0, 50.0, 60.0, 30.0),\n        # Case D (vertical drop at fixed horizontal position)\n        (0.01, 2.0, 5.0, 5.0, 0.0, 90.0, 10.0),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        a, b, x0, y0, v0, theta_deg, t_max = case\n\n        # Convert angle to radians for trigonometric functions\n        theta_rad = np.deg2rad(theta_deg)\n\n        # Calculate initial velocity components\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n\n        # Initial state vector: [x, y, vx, vy]\n        s0 = [x0, y0, vx0, vy0]\n\n        def ode_system(t, s):\n            \"\"\"\n            Defines the system of ordinary differential equations for projectile motion.\n            s = [x, y, vx, vy]\n            \"\"\"\n            # dx/dt = vx\n            # dy/dt = vy\n            # dvx/dt = 0\n            # dvy/dt = -g\n            return [s[2], s[3], 0, -G]\n\n        def event_func(t, s):\n            \"\"\"\n            Event function for impact detection.\n            The event occurs when y(t) - h(x(t)) = 0.\n            h(x) = a*x^2 + b\n            \"\"\"\n            return s[1] - (a * s[0]**2 + b)\n\n        # Set event properties: terminate on event, detect downward crossing\n        event_func.terminal = True\n        event_func.direction = -1\n\n        # Integrate the ODE system\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=[0, t_max],\n            y0=s0,\n            events=event_func,\n            dense_output=True,\n        )\n\n        # Process the results\n        if sol.t_events and len(sol.t_events[0]) > 0:\n            # Event was detected\n            t_hit = sol.t_events[0][0]\n            s_hit = sol.y_events[0][0]\n            x_hit, y_hit, vx_hit, vy_hit = s_hit\n\n            # The problem asks for the height of the impact to be y_hit,\n            # which is guaranteed by the event function to be a*x_hit**2 + b\n            # at the located root.\n            \n            # Calculate final speed at impact\n            v_hit = np.sqrt(vx_hit**2 + vy_hit**2)\n\n            case_result = [t_hit, x_hit, y_hit, v_hit]\n        else:\n            # No event detected within t_max\n            case_result = [np.nan, np.nan, np.nan, np.nan]\n\n        all_results.append(case_result)\n\n    # Format the final output string\n    formatted_results = []\n    for case_res in all_results:\n        str_vals = []\n        for val in case_res:\n            if np.isnan(val):\n                str_vals.append(\"nan\")\n            else:\n                str_vals.append(f\"{val:.6f}\")\n        formatted_results.append(f\"[{','.join(str_vals)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2390630"}, {"introduction": "超越了单次停止事件，许多模拟需要处理一系列离散事件，并在每次事件发生时更新系统状态。本练习通过模拟一个在振动平台上来回弹跳的小球来深入探讨这一高级应用。[@problem_id:2390644] 你需要实现一个事件驱动的循环，其中每次碰撞都是一个重置小球速度的事件，然后积分继续进行。这个实践将使你能够处理具有不连续动力学特性的复杂系统，这是计算物理中一项强大的技术。", "problem": "您的任务是为一个在一维振动平台上方弹跳的小球，在常微分方程积分中实现事件检测。小球的垂直位置由牛顿第二定律推导出的引力作用下运动的二阶常微分方程建模。平台根据一个预设的运动学函数进行垂直运动。当小球从上方接近平台且其高度与平台高度相等时，发生一次碰撞事件。碰撞时，小球的速度根据恢复系数的定义发生改变。您的任务是在有限的时间区间内检测所有此类事件，并在每次碰撞时根据碰撞定律一致地更新小球的速度。最终输出必须为一组指定的测试用例计算得出。\n\n请使用以下基本依据：\n- 均匀重力场中垂直运动的牛顿第二定律：小球的垂直位置 $y(t)$ 和垂直速度 $v(t)$ 服从 $\\dot{y}(t) = v(t)$ 和 $\\dot{v}(t) = -g$，其中 $g$ 是重力加速度。\n- 平台高度为 $y_{p}(t)$，是一个已知的时间函数。平台速度为 $v_{p}(t) = \\dot{y}_{p}(t)$。\n- 恢复系数 $e \\in [0,1]$ 定义为碰撞后相对法向速度大小与碰撞前相对法向速度大小之比。\n\n数学设置：\n- 状态向量：$\\mathbf{x}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$，由以下方程控制\n$$\n\\dot{\\mathbf{x}}(t) = \\begin{bmatrix} v(t) \\\\ -g \\end{bmatrix}.\n$$\n- 平台运动：$y_{p}(t) = A \\sin(\\omega t)$，其中 $\\omega = 2\\pi f$，$A$ 是振幅，$f$ 是频率。平台速度为 $v_{p}(t) = A \\omega \\cos(\\omega t)$。\n- 事件定义：当 $y(t) = y_{p}(t)$ 且小球从上方接近平台时，事件发生。事件必须通过一个标量函数的零点来检测，并且您的检测必须强制执行接近方向以避免伪接触。\n- 碰撞更新：如果事件在时间 $t_{\\mathrm{imp}}$ 发生，设 $v^{-}$ 为碰撞前瞬间的小球速度，$v^{+}$ 为碰撞后瞬间的速度。设 $v_{p}$ 为同一瞬间的平台速度。使用恢复系数的定义从 $v^{-}$ 和 $v_{p}$ 更新 $v^{+}$。\n- 粘附准则：为避免在碰撞后相对速度可忽略不计时出现数值颤振，如果 $|v^{+} - v_{p}|$ 小于一个小的容差 $\\varepsilon_{v}$，则视作小球“粘附”在平台上。在这种情况下，在模拟的剩余时间内，小球随平台一起运动，即 $y(t) = y_{p}(t)$。\n\n数值说明：\n- 使用一个支持事件检测的自适应常微分方程积分器来将状态从 $t=0$ 推进到 $t=T$，在碰撞发生时重复处理。确保配置事件包围和方向性，以仅在 $y(t) - y_{p}(t)$ 递减穿越零时检测到穿越。\n- 在每次处理过的碰撞后使用一个小的正时间偏移量来重新初始化积分器，使其离开事件表面。\n- 使用足够小的相对和绝对容差，以可靠地定位事件时间。\n\n输出：\n对于每个测试用例，计算以下量：\n1. 在 $t \\in [0,T]$ 内检测到的总碰撞事件数 $N$（整数）。\n2. 如果至少发生一次碰撞，第一次碰撞的时间 $t_{\\mathrm{first}}$（秒）；否则报告 $-1.0$。\n3. 如果至少发生一次碰撞，最后一次碰撞的时间 $t_{\\mathrm{last}}$（秒）；否则报告 $-1.0$。\n4. 模拟结束时小球的最终高度 $y(T)$（米）。\n\n物理和数值单位及格式：\n-所有时间必须以秒报告，所有长度以米报告。\n-报告 $t_{\\mathrm{first}}$、$t_{\\mathrm{last}}$ 和 $y(T)$，四舍五入到六位小数。\n-恢复系数 $e$ 是无量纲的。重力加速度 $g$ 的单位是 $\\mathrm{m}/\\mathrm{s}^2$。振幅 $A$ 的单位是米，频率 $f$ 的单位是赫兹，角频率 $\\omega$ 的单位是弧度每秒。\n\n测试套件：\n模拟以下四个案例，每个案例指定为 $(g, A, f, e, y_{0}, v_{0}, T)$，其中 $y_{0}$ 和 $v_{0}$ 是 $t=0$ 时的初始高度（米）和初始垂直速度（米每秒）：\n\n- 案例 1（通用振动平台）：$(9.81, 0.10, 1.5, 0.8, 1.0, 0.0, 3.0)$。\n- 案例 2（边界：初始接触且向下接近）：$(9.81, 0.05, 2.0, 0.9, 0.0, -1.0, 1.0)$。\n- 案例 3（边缘：时间范围内无碰撞）：$(9.81, 0.05, 1.0, 0.8, -0.5, 2.0, 0.5)$。\n- 案例 4（边缘：在静止地面上的完全非弹性碰撞）：$(9.81, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0)$。\n\n最终输出格式：\n-您的程序应生成单行输出，包含四个案例的结果，形式为一个逗号分隔的四个子列表的列表。每个子列表按 $[N, t_{\\mathrm{first}}, t_{\\mathrm{last}}, y(T)]$ 的顺序排列，浮点数值四舍五入到六位小数。例如，输出必须类似于：\n\"[ [N1,tfirst1,tlast1,yT1], [N2,tfirst2,tlast2,yT2], [N3,tfirst3,tlast3,yT3], [N4,tfirst4,tlast4,yT4] ]\"，除了列表分隔符所必需的空格外，不含其他多余空格。将每个占位符替换为计算出的数字。", "solution": "问题陈述已经过分析，并被确定是有效的。它构成了一个计算物理学中的适定问题，基于经典力学的基本原理。目标明确，所提供的数据足以构建一个一致的数值解。任务是模拟一个在重力作用下的小球的一维运动，该运动受到与振动平台的碰撞影响，并报告此运动的特定度量指标。\n\n该方法涉及对控制常微分方程（ODE）进行数值积分，并结合事件检测机制来处理离散的碰撞。解决方案是按部就班构建的，从物理模型开始，然后到数值算法。\n\n小球在任意时刻 $t$ 的状态由其垂直位置 $y(t)$ 和速度 $v(t)$ 描述。状态向量为 $\\mathbf{x}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$。根据牛顿第二定律，对于在均匀引力场中的物体，运动方程为：\n$$\n\\dot{\\mathbf{x}}(t) = \\frac{d\\mathbf{x}}{dt} = \\begin{bmatrix} v(t) \\\\ -g \\end{bmatrix}\n$$\n其中 $g$ 是重力加速度。这是一个一阶常微分方程组。\n\n平台的运动被规定为时间的正弦函数：\n$$\ny_{p}(t) = A \\sin(\\omega t)\n$$\n其中 $A$ 是振幅，$\\omega = 2\\pi f$ 是角频率。平台的速度是其位置对时间的导数：\n$$\nv_{p}(t) = \\dot{y}_{p}(t) = A \\omega \\cos(\\omega t)\n$$\n\n当小球与平台接触时，发生碰撞事件。问题为有效碰撞指定了两个条件：\n$1$. 小球的位置等于平台的位置：$y(t) = y_{p}(t)$。\n$2$. 小球从上方接近平台。这意味着在碰撞前瞬间，相对速度 $v(t) - v_{p}(t)$ 为负。\n\n这些条件由一个标量事件函数 $E(t, \\mathbf{x}(t)) = y(t) - y_{p}(t)$ 捕捉。一次碰撞对应于此函数的根，$E(t, \\mathbf{x}(t))=0$。接近方向的条件意味着事件必须仅在函数 $E(t, \\mathbf{x}(t))$ 递减穿越零时被检测到。\n\nODE 系统的数值积分使用自适应步长积分器执行，特别是 SciPy 库中的 `solve_ivp` 函数，该函数因其内置的事件检测功能而非常适合这类问题。模拟在一个循环中进行。在循环的每一步中，积分器将解从当前时间 $t_{current}$ 推进，直到达到最终时间 $T$ 或检测到事件。\n\n如果在时间 $t_{\\mathrm{imp}}$ 检测到事件，则积分停止。获得碰撞前瞬间小球的状态 $\\mathbf{x}^{-}(t_{\\mathrm{imp}}) = \\begin{bmatrix} y(t_{\\mathrm{imp}}) \\\\ v^{-}(t_{\\mathrm{imp}}) \\end{bmatrix}$。然后根据恢复定律瞬时更新小球的速度。恢复系数 $e$ 定义为：\n$$\nv_{\\mathrm{rel, post}} = -e \\cdot v_{\\mathrm{rel, pre}}\n$$\n其中 $v_{\\mathrm{rel, pre}} = v^{-} - v_{p}$ 和 $v_{\\mathrm{rel, post}} = v^{+} - v_{p}$ 分别是碰撞前后的相对速度。这里，$v_{p}$ 是在 $t_{\\mathrm{imp}}$ 时的平台速度，$v^{+}$ 是碰撞后瞬间的小球速度。这得出了小球速度的更新规则：\n$$\nv^{+} = v_{p}(t_{\\mathrm{imp}}) - e \\left( v^{-} - v_{p}(t_{\\mathrm{imp}}) \\right)\n$$\n小球的位置在碰撞过程中保持连续，$y^{+}(t_{\\mathrm{imp}}) = y^{-}(t_{\\mathrm{imp}})$。\n\n速度更新后，执行“粘附”检查。如果碰撞后的相对速度 $|v^{+} - v_{p}(t_{\\mathrm{imp}})|$ 低于一个小的数值容差 $\\varepsilon_{v}$，则认为小球已粘附到平台上。在这种情况下，弹道运动的模拟终止。对于所有随后的时间 $t > t_{\\mathrm{imp}}$，小球的轨迹由平台的运动在运动学上确定，$y(t) = y_{p}(t)$。那么在时间 $T$ 的最终高度就是 $y(T) = y_p(T)$。\n\n如果小球没有粘附，则用新状态 $\\mathbf{x}^{+}(t_{\\mathrm{imp}}) = \\begin{bmatrix} y(t_{\\mathrm{imp}}) \\\\ v^{+} \\end{bmatrix}$ 重新初始化积分器，并将时间从 $t_{\\mathrm{imp}}$ 推进一个小的偏移量，以防止事件被立即再次检测到。然后积分循环继续。\n\n重复此过程，直到模拟时间 $t$ 达到最终时间 $T$。对于在初始时间 $t=0$ 发生碰撞的边界情况，通过在开始主积分循环之前执行碰撞更新计算来特别处理。\n\n在此过程中收集所需的输出——总碰撞次数 $N$、第一次和最后一次碰撞的时间（$t_{\\mathrm{first}}$、$t_{\\mathrm{last}}$）以及最终的小球高度 $y(T)$。如果没有发生碰撞，$N$ 为 $0$，并且 $t_{\\mathrm{first}}$ 和 $t_{\\mathrm{last}}$ 报告为 $-1.0$。ODE 求解器的数值容差（`rtol`、`atol`）设置为一个小值 $10^{-12}$，以确保轨迹和事件时间定位的高精度。粘附容差 $\\varepsilon_v$ 设置为 $10^{-8}$。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_simulation(g, A, f, e, y0, v0, T):\n        \"\"\"\n        Solves the bouncing ball problem for a single set of parameters.\n        \"\"\"\n        omega = 2.0 * np.pi * f\n        sticking_tolerance = 1e-8\n        time_offset = 1e-12\n\n        # Define platform kinematics\n        def platform_pos(t):\n            if A == 0.0:\n                return 0.0\n            return A * np.sin(omega * t)\n\n        def platform_vel(t):\n            if A == 0.0:\n                return 0.0\n            return A * omega * np.cos(omega * t)\n\n        # Define ODE system for the ball\n        def dynamics(t, state):\n            # state = [y, v]\n            return [state[1], -g]\n\n        # Define event function for impact detection\n        def impact_event(t, state):\n            # Event function is zero when ball height equals platform height\n            return state[0] - platform_pos(t)\n        \n        impact_event.terminal = True  # Stop integration at event\n        impact_event.direction = -1   # Trigger only when function is decreasing\n\n        # Initialize simulation variables\n        t_current = 0.0\n        state_current = np.array([y0, v0], dtype=float)\n        impact_times = []\n        is_sticking = False\n\n        # Handle potential impact at t=0, which solve_ivp might ignore.\n        # Check if positions match and relative velocity is negative.\n        if np.isclose(state_current[0], platform_pos(0.0)):\n            v_rel_initial = state_current[1] - platform_vel(0.0)\n            if v_rel_initial < 0:\n                impact_times.append(0.0)\n                v_minus = state_current[1]\n                v_p = platform_vel(0.0)\n                v_plus = v_p - e * (v_minus - v_p)\n                \n                if abs(v_plus - v_p) < sticking_tolerance:\n                    is_sticking = True\n                    t_current = 0.0\n                else:\n                    state_current[1] = v_plus\n                    t_current += time_offset\n\n        # Main simulation loop\n        while t_current < T and not is_sticking:\n            sol = solve_ivp(\n                dynamics,\n                (t_current, T),\n                state_current,\n                events=impact_event,\n                dense_output=True,\n                rtol=1e-12,\n                atol=1e-12\n            )\n            \n            t_current = sol.t[-1]\n            state_current = sol.y[:, -1]\n\n            # Check if an event was found\n            if sol.status == 1 and sol.t_events[0].size > 0:\n                t_event = sol.t_events[0][0]\n                impact_times.append(t_event)\n                \n                # State right before impact\n                state_at_event = sol.sol(t_event)\n                v_minus = state_at_event[1]\n                v_p = platform_vel(t_event)\n                \n                # Apply restitution law\n                v_plus = v_p - e * (v_minus - v_p)\n                \n                # Check for sticking\n                if abs(v_plus - v_p) < sticking_tolerance:\n                    is_sticking = True\n                    t_current = t_event # Set time for final height calculation\n                    break\n                \n                # Re-initialize state for next integration segment\n                t_current = t_event + time_offset\n                state_current[0] = state_at_event[0]\n                state_current[1] = v_plus\n                \n                if t_current >= T:\n                    break\n        \n        # Calculate final reported values\n        N = len(impact_times)\n        t_first = -1.0 if N == 0 else impact_times[0]\n        t_last = -1.0 if N == 0 else impact_times[-1]\n        \n        if is_sticking:\n            y_final = platform_pos(T)\n        else:\n            y_final = state_current[0]\n\n        return [\n            N,\n            round(t_first, 6),\n            round(t_last, 6),\n            round(y_final, 6)\n        ]\n\n    test_cases = [\n        (9.81, 0.10, 1.5, 0.8, 1.0, 0.0, 3.0),\n        (9.81, 0.05, 2.0, 0.9, 0.0, -1.0, 1.0),\n        (9.81, 0.05, 1.0, 0.8, -0.5, 2.0, 0.5),\n        (9.81, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0)\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n    \n    # Format the final output string exactly as required, with no extra spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2390644"}]}