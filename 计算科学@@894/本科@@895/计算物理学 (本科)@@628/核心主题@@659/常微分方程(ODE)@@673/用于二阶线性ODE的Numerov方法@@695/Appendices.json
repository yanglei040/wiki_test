{"hands_on_practices": [{"introduction": "我们的第一个实践将从一个经典的力学问题——悬链线——开始。通过推导其微分方程并将其转化为适合 Numerov 方法的线性形式 $y''(x) = g y(x)$，你将亲手实现该算法并根据已知的解析解来检验其精度。这个练习是掌握 Numerov 方法的绝佳起点，它让你在一个直观且可验证的场景中熟悉算法的核心步骤 [@problem_id:2421976]。", "problem": "一条均匀、完全柔韧、不可伸长的链条，其线质量密度为 $\\lambda$，在大小为 $g$ 的竖直引力场中悬挂并处于静力平衡状态。建立一个笛卡尔坐标系，其中水平轴为 $x$，垂直轴 $y(x)$ 描述链条的形状。设张力的恒定水平分量为 $T_0$，并定义参数 $a = T_0 / (\\lambda g)$，其量纲为长度。根据力平衡和几何关系，推导出该曲线的控制方程：\n$$\na\\,y''(x) = \\sqrt{1 + \\left(y'(x)\\right)^2}.\n$$\n然后，通过选择垂直原点，使最低点位于 $x=0$ 处，且满足 $y(0)=a$ 和 $y'(0)=0$，将此方程转换为一个不含一阶导数项的线性齐次二阶常微分方程，从而适用于 Numerov 方法。\n\n接下来，使用针对不含一阶导数项的二阶线性常微分方程的 Numerov 方法，在区间 $x \\in [0, X]$ 上数值计算链条的形状。使用初始条件 $y(0)=a$ 和 $y'(0)=0$，并通过在 $x=0$ 处的泰勒展开（直到并包括 $h^4$ 阶项）来初始化第二个点，其中 $h$ 是均匀的网格间距。将您的数值解与推导中得到的解析参考解 $y(x) = a \\cosh(x/a)$ 进行比较，并报告在整个网格上的最大绝对误差。\n\n您的程序必须从第一性原理实现 Numerov 方案，不得调用任何黑盒常微分方程求解器。所有计算都是无量纲的，即不需要进行特定的单位转换；将 $x$ 和 $y$ 视为具有相同的长度单位，$a$ 和 $X$ 也以该单位给出。\n\n测试套件：\n- 案例 1 (理想情况)：$a=2.0$, $X=1.0$, $h=0.01$。\n- 案例 2 (粗网格边界检查)：$a=2.0$, $X=1.0$, $h=0.2$。\n- 案例 3 (近乎平坦的曲线)：$a=50.0$, $X=1.0$, $h=0.05$。\n- 案例 4 (大曲率)：$a=0.5$, $X=1.0$, $h=0.01$。\n\n对于每个案例，计算最大绝对误差\n$$\nE = \\max_{0 \\le n \\le N} \\left| y_n - a \\cosh\\!\\left(\\frac{x_n}{a}\\right) \\right|,\n$$\n其中 $x_n = n h$ 且根据所提供的案例，$N = X/h$ 是一个整数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个误差值四舍五入到 $10$ 位小数（例如，$\\left[0.0000001234,0.0012345678,0.0,0.0\\right]$）。", "solution": "我们从基本静力学开始。设 $T(x)$ 表示在位置 $x$ 处的张力大小，$\\theta(x)$ 表示链条与水平方向的夹角。在静力平衡中，水平分量 $T_x = T(x)\\cos\\theta(x)$ 是恒定的，因此 $T_x = T_0$。垂直分量为 $T_y = T(x)\\sin\\theta(x)$。在一个微分弧长 $\\mathrm{d}s$ 上，内力的垂直分量发生变化，以平衡该元素的重量 $\\lambda g\\,\\mathrm{d}s$：\n$$\n\\mathrm{d}T_y = \\lambda g\\,\\mathrm{d}s.\n$$\n利用几何关系 $\\tan\\theta = y'$、$\\cos\\theta = 1/\\sqrt{1+(y')^2}$ 和 $\\sin\\theta = y'/\\sqrt{1+(y')^2}$，以及关系式 $T \\cos\\theta = T_0$，我们得到 $T = T_0 \\sqrt{1+(y')^2}$。于是\n$$\nT_y = T \\sin\\theta = T_0 \\sqrt{1+(y')^2} \\cdot \\frac{y'}{\\sqrt{1+(y')^2}} = T_0\\, y'.\n$$\n对 $x$ 求导并使用 $\\mathrm{d}s = \\sqrt{1+(y')^2}\\,\\mathrm{d}x$ 得到\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(T_y\\right) = T_0\\, y'' = \\lambda g \\sqrt{1+(y')^2}.\n$$\n定义 $a = \\dfrac{T_0}{\\lambda g}$，我们得到非线性二阶常微分方程\n$$\na\\, y'' = \\sqrt{1 + (y')^2}.\n$$\n\n为了使该方程可积，并将其与适用于 Numerov 方法的线性形式联系起来，令 $p(x) = y'(x)$。此时方程变为\n$$\na \\frac{\\mathrm{d}p}{\\mathrm{d}x} = \\sqrt{1+p^2}.\n$$\n引入代换 $u(x) = \\operatorname{arsinh}(p) = \\ln\\!\\left(p + \\sqrt{1+p^2}\\right)$。由于 $\\dfrac{\\mathrm{d}}{\\mathrm{d}p}\\operatorname{arsinh}(p) = \\dfrac{1}{\\sqrt{1+p^2}}$，我们有\n$$\n\\frac{\\mathrm{d}u}{\\mathrm{d}x} = \\frac{1}{\\sqrt{1+p^2}} \\frac{\\mathrm{d}p}{\\mathrm{d}x} = \\frac{1}{a}.\n$$\n积分得到 $u(x) = \\dfrac{x-x_0}{a}$，其中 $x_0$ 是某个常数，因此\n$$\ny'(x) = p(x) = \\sinh\\!\\left(\\frac{x-x_0}{a}\\right).\n$$\n再次积分，\n$$\ny(x) = a \\cosh\\!\\left(\\frac{x-x_0}{a}\\right) + C,\n$$\n其中常数由边界条件和垂直原点的选择决定。如果我们要求曲线关于 $x=0$ 对称，最低点在 $x=0$ 处，并选择垂直原点使得 $y(0)=a$ 和 $y'(0)=0$，那么 $x_0=0$ 和 $C=0$，得到标准的悬链线形式 $y(x) = a \\cosh(x/a)$。对于此选择，注意到\n$$\ny''(x) = \\frac{1}{a^2} y(x),\n$$\n因为对 $y(x)=a \\cosh(x/a)$ 求导两次得到 $y''(x) = \\frac{1}{a}\\cosh(x/a)$，即 $y''(x) = \\frac{1}{a^2}y(x)$。因此，在适当地选择垂直原点后，非线性控制方程等价于线性齐次方程\n$$\ny''(x) = g\\, y(x), \\quad \\text{with } g = \\frac{1}{a^2}.\n$$\n这是一个不含一阶导数项的二阶线性常微分方程，是 Numerov 方法的标准形式。\n\n$y''(x) = f(x) y(x)$ 的 Numerov 方法推导：\n考虑一个间距为 $h$ 的均匀网格 $x_n = x_0 + n h$。将 $y_{n\\pm 1} = y(x_{n\\pm 1})$ 在 $x_n$ 处进行泰勒展开：\n$$\ny_{n\\pm 1} = y_n \\pm h y'_n + \\frac{h^2}{2} y''_n \\pm \\frac{h^3}{6} y'''_n + \\frac{h^4}{24} y''''_n + \\mathcal{O}(h^5).\n$$\n将 $y_{n+1}$ 和 $y_{n-1}$ 的展开式相加，以消除奇数阶导数：\n$$\ny_{n+1} + y_{n-1} = 2 y_n + h^2 y''_n + \\frac{h^4}{12} y''''_n + \\mathcal{O}(h^6).\n$$\n使用 $y'' = f y$ 并求导两次，得到 $y'''' = \\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}(f y) = f'' y + 2 f' y' + f y''$。对于足够平滑的 $f$，Numerov 的思想是利用邻近点的微分方程来近似 $y''''$，从而得到一个六阶方法。对于齐次情况 $y'' = f(x) y$，标准的 Numerov 递推关系是\n$$\n\\left(1 - \\frac{h^2}{12} f_{n+1}\\right) y_{n+1}\n= 2 y_n - y_{n-1} + \\frac{h^2}{12} \\left(10 f_n y_n + f_{n-1} y_{n-1}\\right) + \\mathcal{O}(h^6),\n$$\n其中 $f_n = f(x_n)$。在我们的应用中，$f(x) = g = 1/a^2$ 是常数，因此 $f_{n-1} = f_n = f_{n+1} = g$，递推关系简化为\n$$\n\\left(1 - \\frac{h^2 g}{12}\\right) y_{n+1}\n= 2 y_n - y_{n-1} + \\frac{h^2 g}{12} \\left(10 y_n + y_{n-1}\\right).\n$$\n为启动该递推，我们需要 $y_0$ 和 $y_1$。初始条件是 $y(0) = a$ 和 $y'(0) = 0$。在 $x=0$ 处使用泰勒展开，并包括到 $\\mathcal{O}(h^4)$ 阶项，\n$$\ny(h) = y(0) + h y'(0) + \\frac{h^2}{2} y''(0) + \\frac{h^3}{6} y'''(0) + \\frac{h^4}{24} y''''(0) + \\mathcal{O}(h^5).\n$$\n由于 $y''(0) = g y(0) = g a$，$y'''(0) = g y'(0) = 0$ 且 $y''''(0) = g y''(0) = g^2 a$（因为 $g$ 是常数），我们得到\n$$\ny(h) = a + \\frac{h^2}{2} g a + \\frac{h^4}{24} g^2 a + \\mathcal{O}(h^5)\n= a \\left(1 + \\frac{h^2 g}{2} + \\frac{h^4 g^2}{24}\\right) + \\mathcal{O}(h^5).\n$$\n因此，设 $y_0 = a$ 且\n$$\ny_1 = a \\left(1 + \\frac{h^2 g}{2} + \\frac{h^4 g^2}{24}\\right).\n$$\n\n为了验证，我们将其与精确解 $y(x) = a \\cosh(x/a)$ 进行比较，并计算在整个网格上的最大绝对误差：\n$$\nE = \\max_{0 \\le n \\le N} \\left| y_n - a \\cosh\\!\\left(\\frac{x_n}{a}\\right) \\right|,\n\\quad x_n = n h, \\quad N = \\frac{X}{h}.\n$$\n\n测试套件与覆盖范围：\n- 案例 1 测试了一般、高解析度的场景（$a=2.0$, $X=1.0$, $h=0.01$），其中 Numerov 方法的 $\\mathcal{O}(h^6)$ 精度应产生非常小的误差。\n- 案例 2 使用粗网格（$h=0.2$）来测试该方案的极限，并观察到精度下降但稳定性得以保持。\n- 案例 3 探索了小曲率情况（$a=50.0$），此时 $g = 1/a^2$ 很小，解几乎是平坦的；这测试了对小 $g$ 值的敏感性。\n- 案例 4 使用大曲率（$a=0.5$），在相同区间内测试了对于较大 $g$ 值的数值稳定性。\n\n程序实现了针对常数 $g$ 的专用 Numerov 递推，使用四阶泰勒展开进行启动，并按要求以单行、方括号括起、逗号分隔的形式报告 $E$ 值列表，每个值四舍五入到 $10$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerov_constant_g(g, a, X, h):\n    \"\"\"\n    Solve y'' = g * y on x in [0, X] with y(0)=a, y'(0)=0 using Numerov's method.\n    Initialize y(h) using a 4th-order Taylor expansion.\n    Return max absolute error vs exact y(x) = a cosh(x/a).\n    \"\"\"\n    # Number of steps, ensure integer\n    N = int(round(X / h))\n    X_effective = N * h  # Adjusted X to match grid if needed\n    x = np.linspace(0.0, X_effective, N + 1)\n\n    # Initial conditions\n    y = np.empty(N + 1, dtype=float)\n    y[0] = a\n    # Taylor-based start: y(h) = a*(1 + (h^2 g)/2 + (h^4 g^2)/24)\n    y1 = a * (1.0 + 0.5 * (h*h*g) + (h**4) * (g**2) / 24.0)\n    if N >= 1:\n        y[1] = y1\n\n    if N >= 2:\n        # Precompute coefficients since g is constant\n        c_denom = 1.0 - (h*h*g)/12.0\n        c_y_n = 2.0 + (h*h*g) * (10.0/12.0)\n        c_y_nm1 = -1.0 + (h*h*g) * (1.0/12.0)\n\n        for n in range(1, N):\n            # Numerov recurrence specialized to constant g:\n            # (1 - h^2 g / 12) y_{n+1} = 2 y_n - y_{n-1} + (h^2 g / 12) (10 y_n + y_{n-1})\n            # Rearranged in terms of coefficients c_y_n and c_y_nm1\n            y[n+1] = (c_y_n * y[n] + c_y_nm1 * y[n-1]) / c_denom\n\n    # Exact solution for comparison: y(x) = a cosh(x/a)\n    y_exact = a * np.cosh(x / a)\n    err = np.max(np.abs(y - y_exact))\n    return err\n\ndef solve():\n    # Define the test cases from the problem statement: (a, X, h)\n    test_cases = [\n        (2.0, 1.0, 0.01),   # Case 1: happy path\n        (2.0, 1.0, 0.2),    # Case 2: coarse grid\n        (50.0, 1.0, 0.05),  # Case 3: near-flat curve\n        (0.5, 1.0, 0.01),   # Case 4: steep curvature\n    ]\n\n    results = []\n    for a, X, h in test_cases:\n        g = 1.0 / (a * a)\n        err = numerov_constant_g(g, a, X, h)\n        # Round to 10 decimal places for output formatting\n        results.append(err)\n\n    # Final print statement in the exact required format: bracketed, comma-separated, 10 decimals\n    formatted = \"[\" + \",\".join(f\"{val:.10f}\" for val in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2421976"}, {"introduction": "在掌握了基本应用后，我们将进入一个更复杂的量子力学场景，以展示 Numerov 方法的普适性。在这个实践中，你将求解一个在随机无序势中运动的粒子的薛定谔方程，其形式为 $\\psi''(x) = -k(x)\\psi(x)$，其中系数 $k(x)$ 随空间无规则变化。通过计算波函数的局域化指标，你将能观察到深刻的安德森局域化现象，并体会到数值方法在探索无解析解的前沿物理问题时的关键作用 [@problem_id:2422024]。", "problem": "考虑一个在有限区间上、在随机势中运动的粒子的时间无关一维薛定谔方程（一个二阶常微分方程（ODE））：\n$$\n\\psi''(x) + k(x)\\,\\psi(x) = 0,\n$$\n其中 \n$$\nk(x) = \\frac{2m}{\\hbar^2}\\left(E - V(x)\\right).\n$$\n使用无量纲单位，设约化普朗克常数 $\\,\\hbar = 1\\,$ 且质量 $\\,m = \\tfrac{1}{2}\\,$，因此 $\\,\\tfrac{2m}{\\hbar^2} = 1\\,$，故而 $\\,k(x) = E - V(x)\\,$。势 $\\,V(x)\\,$ 在均匀网格上是分段常数，定义在网格点 $\\,x_i = i\\,h\\,$（其中 $\\,i = 0,1,\\dots,M\\,$，$\\,h = L/M\\,$ 且 $\\,L > 0\\,$）上。对于给定的无序强度 $\\,W \\ge 0\\,$ 和给定的整数伪随机种子 $\\,s\\,$，使用以种子 $\\,s\\,$ 初始化的伪随机数生成器，从区间 $\\,[-W/2,\\,W/2]\\,$ 上的均匀分布中独立抽取数值 $\\,V_i = V(x_i)\\,$。施加初始条件\n$$\n\\psi(0) = 0,\\quad \\psi'(0) = 1,\n$$\n这些条件对于任意给定的 $\\,E\\,$ 和 $\\,V(x)\\,$ 的实现都确定了一个唯一解。在网格上计算出离散解 $\\,\\{\\psi_i\\}_{i=0}^{M}\\,$ 后，将其归一化以得到 $\\,\\tilde{\\psi}_i = \\psi_i \\big/ \\sqrt{\\sum_{j=0}^{M} \\psi_j^2}\\,$。使用这个归一化的离散波函数，计算以下两个量化局域化程度的无量纲诊断量：\n1. 逆参与率（inverse participation ratio），\n$$\n\\mathrm{IPR} = \\sum_{i=0}^{M} \\tilde{\\psi}_i^4,\n$$\n2. 右尾范数分数（right-tail norm fraction），\n$$\nT = \\sum_{i=\\lfloor 0.9\\,M \\rfloor}^{M} \\tilde{\\psi}_i^2.\n$$\n在这些单位下，所有量都是无量纲的。\n\n你的任务是编写一个完整的程序，对下面的每个测试用例，按规定构造随机势，使用给定的初始条件在 $[0,L]$ 上求解 $\\,\\psi(x)\\,$，对结果进行归一化，并输出浮点数对 $\\,(\\mathrm{IPR}, T)\\,$。\n\n使用以下测试套件。每个测试用例都是一个元组 $\\,\\left(L,\\,M,\\,W,\\,E,\\,s\\right)\\,$，其中 $\\,L\\,$ 是区间长度，$\\,M\\,$ 是均匀步数，$\\,W\\,$ 是无序强度，$\\,E\\,$ 是能量，$\\,s\\,$ 是整数种子：\n- 测试用例 $\\,1\\,$: $\\,\\left(200.0,\\,4000,\\,0.0,\\,1.0,\\,123\\right)\\,$\n- 测试用例 $\\,2\\,$: $\\,\\left(200.0,\\,4000,\\,1.0,\\,1.0,\\,456\\right)\\,$\n- 测试用例 $\\,3\\,$: $\\,\\left(200.0,\\,4000,\\,4.0,\\,1.0,\\,789\\right)\\,$\n- 测试用例 $\\,4\\,$: $\\,\\left(200.0,\\,4000,\\,2.0,\\,{-0.5},\\,321\\right)\\,$\n\n你的程序必须生成单行输出，其中包含按顺序聚合的所有测试用例的结果，形式为方括号内的逗号分隔列表。对于每个测试用例，按顺序输出两个浮点数 $\\,\\mathrm{IPR}\\,$ 和 $\\,T\\,$。因此，最终格式必须是\n$$\n\\big[\\mathrm{IPR}_1,\\,T_1,\\,\\mathrm{IPR}_2,\\,T_2,\\,\\mathrm{IPR}_3,\\,T_3,\\,\\mathrm{IPR}_4,\\,T_4\\big].\n$$", "solution": "出发点是一维不含时薛定谔方程，\n$$\n\\psi''(x) + k(x)\\,\\psi(x) = 0,\\quad k(x) = \\frac{2m}{\\hbar^2}\\left(E - V(x)\\right).\n$$\n在指定的无量纲单位中，设 $\\,\\hbar = 1\\,$ 且 $\\,m = \\tfrac{1}{2}\\,$，因此 $\\,\\tfrac{2m}{\\hbar^2} = 1\\,$，方程简化为\n$$\n\\psi''(x) + \\big(E - V(x)\\big)\\,\\psi(x) = 0.\n$$\n在均匀网格 $\\,x_i = i\\,h\\,$（其中 $\\,i = 0,1,\\dots,M\\,$，$\\,h = L/M\\,$）上，定义 $\\,k_i = E - V_i\\,$，其中 $\\,V_i\\,$ 是对每个测试用例使用给定种子初始化的伪随机数生成器，从 $\\,[-W/2,\\,W/2]\\,$ 上的均匀分布中独立采样的。初始条件 $\\,\\psi(0) = 0\\,$ 和 $\\,\\psi'(0) = 1\\,$ 确定了该常微分方程的唯一解。为了在网格上初始化一个两步递推关系，在 $\\,x = 0\\,$ 处的泰勒展开给出\n$$\n\\psi(h) = \\psi(0) + h\\,\\psi'(0) + \\frac{h^2}{2}\\,\\psi''(0) + \\mathcal{O}(h^3).\n$$\n由于 $\\,\\psi''(0) = -k_0\\,\\psi(0) = 0\\,$，可以得到领头阶精确的初始值\n$$\n\\psi_0 = 0,\\qquad \\psi_1 = h.\n$$\n对于形如 $\\,\\psi''(x) + k(x)\\,\\psi(x) = 0\\,$ 的二阶线性常微分方程，Numerov 方法提供了一种高精度的三点积分格式。在均匀网格上，其形式为\n$$\n\\psi_{i+1} = \\frac{2\\,\\psi_i\\,\\Big(1 - \\frac{h^2}{12}\\,5\\,k_i\\Big) - \\psi_{i-1}\\,\\Big(1 + \\frac{h^2}{12}\\,k_{i-1}\\Big)}{1 + \\frac{h^2}{12}\\,k_{i+1}},\\quad i = 1,2,\\dots,M-1,\n$$\n这在代数上等价于标准的 Numerov 更新式\n$$\n\\left(1 + \\frac{h^2}{12}\\,k_{i+1}\\right)\\psi_{i+1} = 2\\left(1 - \\frac{5h^2}{12}\\,k_i\\right)\\psi_i - \\left(1 + \\frac{h^2}{12}\\,k_{i-1}\\right)\\psi_{i-1}.\n$$\n对于足够光滑的 $\\,k(x)\\,$，此格式与该常微分方程相容，并达到 $\\,\\mathcal{O}(h^6)\\,$ 阶的局部截断误差。在当前情况下，$\\,k(x)\\,$ 在网格上是分段常数的，这在 $\\,h \\to 0\\,$ 时保持了高阶精度。\n\n在从 $\\,i=1\\,$ 到 $\\,i=M-1\\,$ 的前向积分过程中，振幅 $\\,\\psi_i\\,$ 会根据 $\\,k_i\\,$ 的符号和空间变化而指数级增长或衰减。为避免数值上溢或下溢，同时保持解的形状，当部分计算出的序列 $\\{\\psi_j\\}_{j\\le i}$ 的幅值超过预设阈值时，可以将其乘以一个大因子进行重新缩放。这种重新缩放不影响归一化的波函数或由其计算出的任何无量纲诊断量。\n\n计算出 $\\,\\{\\psi_i\\}_{i=0}^{M}\\,$ 后，通过以下公式对离散波函数进行归一化\n$$\n\\tilde{\\psi}_i = \\frac{\\psi_i}{\\sqrt{\\sum_{j=0}^{M} \\psi_j^2}},\n$$\n这与连续的 $\\,L^2\\,$ 归一化相符，因为均匀网格因子在诸如逆参与率等比值中被抵消了。于是，逆参与率为\n$$\n\\mathrm{IPR} = \\sum_{i=0}^{M} \\tilde{\\psi}_i^4,\n$$\n而右尾范数分数（衡量波函数在定义域最后 $\\,10\\%\\,$ 的权重）为\n$$\nT = \\sum_{i=\\lfloor 0.9\\,M \\rfloor}^{M} \\tilde{\\psi}_i^2.\n$$\n$\\,\\mathrm{IPR}\\,$ 和 $\\,T\\,$ 都是无量纲的。对于一个遍布整个区间的扩展态，我们预期 $\\,\\mathrm{IPR}\\,$ 会很小（其标度行为如同 $\\,1/M\\,$），而 $\\,T\\,$ 会接近 $\\,0.1\\,$；而对于一个局域态，$\\,\\mathrm{IPR}\\,$ 会更大，并且 $\\,T\\,$ 强烈依赖于局域化中心相对于右边界的位置。\n\n该测试套件检验了几种情况：当 $\\,W = 0\\,$ 和 $\\,E = 1\\,$ 时，自由空间中的解是振荡的扩展态；在固定的 $\\,E = 1\\,$ 时，随着 $\\,W\\,$ 从 $\\,1\\,$ 增加到 $\\,4\\,$，无序的增加促进了局域化；当 $\\,E = -0.5\\,$ 且无序强度适中（$\\,W = 2\\,$）时，在给定的初始条件下，解表现出倏逝行为，并向右边界集中。该程序为每个测试用例实现了所描述的构造、积分、归一化和诊断量计算，并以指定的单行列表格式输出结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerov_solve_ipr_tail(L, M, W, E, seed):\n    \"\"\"\n    Solve psi''(x) + (E - V(x)) psi(x) = 0 on [0, L] with psi(0)=0, psi'(0)=1\n    using a uniform grid of M steps (M+1 points), random piecewise-constant V,\n    and return (IPR, T) where T is the right-tail norm fraction.\n    \"\"\"\n    # Grid setup\n    N = M  # number of steps\n    h = L / N\n    # Random potential at grid nodes: V_i ~ U[-W/2, W/2]\n    rng = np.random.default_rng(seed)\n    if W == 0.0:\n        V = np.zeros(N + 1, dtype=np.float64)\n    else:\n        V = rng.uniform(-W / 2.0, W / 2.0, size=N + 1).astype(np.float64)\n    k = (E - V).astype(np.float64)\n\n    # Allocate solution array\n    psi = np.empty(N + 1, dtype=np.float64)\n\n    # Initial conditions: psi(0)=0, psi'(0)=1 -> psi(h) ~ h (since psi''(0)=0)\n    psi[0] = 0.0\n    psi[1] = h\n\n    h2 = h * h\n    # Safety parameters for rescaling to avoid overflow\n    rescale_threshold = 1e100\n    rescale_factor = 1e50\n\n    # Numerov integration\n    # (1 + h^2 k_{i+1}/12) psi_{i+1} = 2(1 - 5 h^2 k_i/12) psi_i - (1 + h^2 k_{i-1}/12) psi_{i-1}\n    for i in range(1, N):\n        kim1 = k[i - 1]\n        ki = k[i]\n        kip1 = k[i + 1] if i + 1 <= N else k[i]  # safe guard, though loop stops at i=N-1\n\n        denom = 1.0 + (h2 * kip1) / 12.0\n        num = 2.0 * (1.0 - (5.0 * h2 * ki) / 12.0) * psi[i] - (1.0 + (h2 * kim1) / 12.0) * psi[i - 1]\n\n        psi[i + 1] = num / denom\n\n        # Rescale to avoid overflow; scaling entire prefix preserves shape\n        if not np.isfinite(psi[i + 1]) or abs(psi[i + 1]) > rescale_threshold or abs(psi[i]) > rescale_threshold:\n            psi[: i + 2] /= rescale_factor\n\n    # Normalize\n    norm2 = float(np.dot(psi, psi))\n    if norm2 == 0.0 or not np.isfinite(norm2):\n        # Fallback in pathological cases\n        return float('nan'), float('nan')\n    psi /= np.sqrt(norm2)\n\n    # Inverse Participation Ratio (IPR)\n    ipr = float(np.sum(psi * psi * psi * psi))\n    # Right-tail norm fraction: last 10% of the grid\n    tail_start = int(np.floor(0.9 * N))\n    tail = float(np.sum(psi[tail_start:] * psi[tail_start:]))\n\n    return ipr, tail\n\ndef solve():\n    # Define the test cases from the problem statement: (L, M, W, E, seed)\n    test_cases = [\n        (200.0, 4000, 0.0, 1.0, 123),\n        (200.0, 4000, 1.0, 1.0, 456),\n        (200.0, 4000, 4.0, 1.0, 789),\n        (200.0, 4000, 2.0, -0.5, 321),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, M, W, E, seed = case\n        ipr, tail = numerov_solve_ipr_tail(L, M, W, E, seed)\n        results.append(ipr)\n        results.append(tail)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2422024"}, {"introduction": "最后一个实践将带你解决量子力学中一类最重要的问题：本征值问题。你将学习如何将 Numerov 方法与“打靶法”相结合，来寻找一维量子纳米线中的束缚态能级。这是一种强大的通用技术，它将求解微分方程的任务嵌入到一个更大的寻根算法中，以找到满足边界条件的特定能量（即本征值）。通过这个练习，你将体验到如何将 Numerov 方法作为一个核心模块，去解决更宏大、更接近科研实践的计算任务 [@problem_id:2421997]。", "problem": "一个长度为 $L$ 的一维量子纳米线被模型化为一个质量为 $m$ 的粒子，该粒子被限制在位于 $x=0$ 和 $x=L$ 的具有完美硬壁的盒子中。其势能函数为：当 $0<x<L$ 时 $V(x)=0$，在其他地方 $V(x)=+\\infty$。考虑定态薛定谔方程\n$$-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2}+V(x)\\psi(x)=E\\,\\psi(x),$$\n其边界条件为 $\\psi(0)=0$ 和 $\\psi(L)=0$。您将使用 Numerov 方法数值求解本征能量，从而计算在零温下，作为化学势函数的洛伦兹展宽态密度以及单位长度的量子电容。\n\n使用的基本依据：\n- 一个无限深势阱中粒子的定态薛定谔方程，写作\n$$\\psi''(x)=\\frac{2m}{\\hbar^2}\\left[V(x)-E\\right]\\psi(x),$$\n形式，其边界条件为 $\\psi(0)=0$ 和 $\\psi(L)=0$。\n- 通过狄拉克 $\\delta$ 函数的洛伦兹表示，将离散谱展宽为连续函数的态密度 (DoS) 定义。设一个小的正展宽半峰宽为 $\\Gamma$，使用\n$$\\delta(E-E_n)\\approx \\frac{1}{\\pi}\\frac{\\Gamma}{(E-E_n)^2+\\Gamma^2}。$$\n- 零温下量子电容（单位长度）的定义为线性电荷密度对化学势 $\\mu$ 的导数，\n$$\\frac{C_Q}{L}=e^2 \\frac{\\partial n}{\\partial \\mu}=e^2 D(\\mu),$$\n其中 $D(E)$ 是能量为 $E$ 时的单位长度态密度，$e$ 是元电荷。\n\n您的任务：\n1) 从薛定谔方程的形式 $\\psi''(x)=S\\,\\psi(x)$ 出发，其中 $S(x)=\\frac{2m}{\\hbar^2}\\left[V(x)-E\\right]$，推导一个适用于此类二阶线性常微分方程的 Numerov 型算法，确保步长为 $h$ 时的局部截断误差为 $h^6$ 阶。实现一个打靶法，该方法从 $x=0$ 积分到 $x=L$，并强制 $\\psi(0)=0$，同时设 $\\psi(h)$ 为一个任意小的非零值，然后找出使边界值 $\\psi(L)$ 为零的能量 $E$。使用一个稳健的根的区间限定与精确化策略来确定指定能量上限内的所有束缚态能量 $E_n$。\n2) 使用束缚态能量 $\\{E_n\\}$，构建单位长度的洛伦兹展宽态密度，其中自旋简并因子 $g_s=2$，\n$$D(E)=\\frac{g_s}{L}\\sum_n \\frac{1}{\\pi}\\frac{\\Gamma}{(E-E_n)^2+\\Gamma^2}。$$\n3) 通过下式计算零温下单位长度的量子电容：\n$$\\frac{C_Q}{L}=e^2 D(\\mu)。$$\n\n重要的实现和单位要求：\n- 使用以下常量：$m=m_e$（自由电子质量），$\\hbar$（约化普朗克常数）和 $e$（元电荷），所有常量均采用国际单位制 (SI)。\n- 计算中所有的内部能量单位必须是焦耳；如果参数以电子伏特 (eV) 或毫电子伏特 (meV) 给出，请使用 $1\\,\\mathrm{eV}=e\\,\\mathrm{J}$ 将它们转换为焦耳。\n- 将最终的单位长度量子电容以法拉每米 (F/m) 表示，并将每个报告值以科学记数法格式化，小数点后恰好有六位数字。\n- 您必须使用 Numerov 方法结合区间限定加二分法（或等效的单调）求根算法来求解边界值 $\\psi(L)$，从而搜索本征能量。不要在您的代码中使用本征能量的解析解。\n\n测试套件：\n对于每个参数三元组 $(L,\\Gamma,\\mu)$，计算 $\\frac{C_Q}{L}$（单位为 $\\mathrm{F/m}$），并达到要求的精度。长度 $L$ 的单位为米，展宽半峰宽 $\\Gamma$ 的单位为毫电子伏特 (meV)，化学势 $\\mu$ 的单位为电子伏特 (eV)。使用 $g_s=2$。\n\n- 情况 1 (正常路径，低于第一能级): $(L, \\Gamma, \\mu)=(1.0\\times 10^{-8}, 2.0, 0.020)$。\n- 情况 2 (接近一个共振): $(L, \\Gamma, \\mu)=(1.0\\times 10^{-8}, 2.0, 0.0235)$。\n- 情况 3 (多个子带贡献): $(L, \\Gamma, \\mu)=(1.0\\times 10^{-8}, 2.0, 0.100)$。\n- 情况 4 (较短的线，较高的第一能级): $(L, \\Gamma, \\mu)=(5.0\\times 10^{-9}, 2.0, 0.050)$。\n- 情况 5 (较长的线，较小的展宽): $(L, \\Gamma, \\mu)=(2.0\\times 10^{-8}, 1.0, 0.010)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个结果，以逗号分隔的列表形式，并用方括号括起来，格式为科学记数法，小数点后恰好有六位数字（例如：'[1.234567e-08,2.345678e-07,3.456789e-06,4.567890e-05,5.678901e-04]'）。", "solution": "所提出的问题是计算量子物理中的一个标准练习，要求确定定态薛定谔方程的本征能量，并随后计算态密度和量子电容。该问题定义明确、科学上合理且内部一致。我们将采用严谨的解法进行处理。\n\n该问题的核心是一个质量为 $m$ 的粒子在一维区域内的定态薛定谔方程 (TISE)，该区域长度为 $L$，势能为零，并被无限深势阱所限制。该方程由下式给出：\n$$\n\\psi''(x) + \\frac{2m}{\\hbar^2}(E - V(x))\\psi(x) = 0\n$$\n其边界条件为 $\\psi(0) = 0$ 和 $\\psi(L) = 0$。在纳米线内部，从 $x=0$ 到 $x=L$，势能 $V(x)=0$。方程简化为谐振子方程的形式：\n$$\n\\psi''(x) + k^2\\psi(x) = 0\n$$\n其中 $k^2 = \\frac{2mE}{\\hbar^2}$。问题要求使用 Numerov 方法进行数值求解，该方法专为这类缺少一阶导数项的二阶常微分方程 (ODE) 设计。\n\n首先，我们推导 Numerov 递推关系。按照要求，标准方法产生的局部截断误差为 $\\mathcal{O}(h^6)$ 阶。我们从波函数 $\\psi(x)$ 在网格点 $x_i$ 附近的泰勒级数展开开始：\n$$\n\\psi(x_i \\pm h) = \\psi_i \\pm h\\psi'_i + \\frac{h^2}{2!}\\psi''_i \\pm \\frac{h^3}{3!}\\psi'''_i + \\frac{h^4}{4!}\\psi^{(4)}_i \\pm \\frac{h^5}{5!}\\psi^{(5)}_i + \\mathcal{O}(h^6)\n$$\n将 $\\psi(x_i+h)$ 和 $\\psi(x_i-h)$ 的展开式相加，可以消去奇数阶导数项：\n$$\n\\psi_{i+1} + \\psi_{i-1} = 2\\psi_i + h^2\\psi''_i + \\frac{h^4}{12}\\psi^{(4)}_i + \\mathcal{O}(h^6)\n$$\n我们可以通过对原始 ODE 求两次导来获得 $\\psi^{(4)}_i$ 的表达式：$\\psi^{(4)}(x) = \\frac{d^2}{dx^2}(-k^2(x)\\psi(x))$。用有限差分算子近似这个二阶导数可得：\n$$\n\\psi^{(4)}_i \\approx \\frac{1}{h^2}( (k^2\\psi)_{i+1} - 2(k^2\\psi)_i + (k^2\\psi)_{i-1} )\n$$\n将此式代入求和后的泰勒展开式并整理各项，即可得到 Numerov 递推关系：\n$$\n\\psi_{i+1}\\left(1 + \\frac{h^2}{12}k_{i+1}^2\\right) = 2\\psi_i\\left(1 - \\frac{5h^2}{12}k_i^2\\right) - \\psi_{i-1}\\left(1 + \\frac{h^2}{12}k_{i-1}^2\\right)\n$$\n对于无限深势阱的特定情况，$V(x)=0$ 并且对于给定的试验能量 $E$ 是一个常数，这使得 $k^2 = \\frac{2mE}{\\hbar^2}$ 在势阱内的整个网格上都是常数。我们将这个常数记作 $k_E^2$。递推关系简化为：\n$$\n\\psi_{i+1}\\left(1 + \\frac{h^2}{12}k_E^2\\right) = \\psi_i\\left(2 - \\frac{10h^2}{12}k_E^2\\right) - \\psi_{i-1}\\left(1 + \\frac{h^2}{12}k_E^2\\right)\n$$\n这个关系允许我们根据前两个值 $\\psi_i$ 和 $\\psi_{i-1}$ 来计算 $\\psi_{i+1}$。\n\n为了找到本征能量，我们采用打靶法。该方法将边值问题转化为初值问题。我们强制执行第一个边界条件 $\\psi(0)=0$，并在第一步为波函数选择一个任意小的非零值，例如 $\\psi(h) = \\text{const}$，因为薛定谔方程的线性特性意味着解的归一化在确定之前是任意的。对于给定的试验能量 $E$，我们使用 Numerov 递推关系将波函数从 $x=0$ 积分到 $x=L$。第二个边界条件 $\\psi(L)=0$ 只有在特定的离散能量值 $E$ 处才能满足，这些值就是所寻求的本征能量。\n我们定义一个函数 $\\Phi(E) = \\psi(L; E)$，它表示在给定能量 $E$ 时，数值计算出的波函数在 $x=L$ 处的值。本征能量是这个函数的根，即满足 $\\Phi(E_n) = 0$ 的 $E_n$。\n\n为了找到这些根，我们实现了一个稳健的两阶段过程。首先，我们通过以一个小的步长 $\\Delta E$ 扫描一个合适的能量范围 $[E_{min}, E_{max}]$ 来将根限定在区间内。如果 $\\Phi(E_j) \\cdot \\Phi(E_{j+1}) < 0$，则认为根被限定在区间 $[E_j, E_{j+1}]$ 内。其次，一旦根被限定在区间内，就使用二分法来找到它的精确值。这种迭代方法重复地将区间减半，同时确保根始终位于新的、更小的区间内，直到区间宽度小于预设的容差。\n\n在计算出指定能量上限（选择一个足够大于测试用例中最大化学势的值）内的本征能量集合 $\\{E_n\\}$ 之后，我们计算单位长度的洛伦兹展宽态密度 (DoS) $D(E)$。包含自旋简并因子 $g_s=2$ 时，能量为 $E$ 处的 DoS 由下式给出：\n$$\nD(E) = \\frac{g_s}{L} \\sum_{n} \\frac{1}{\\pi} \\frac{\\Gamma}{(E - E_n)^2 + \\Gamma^2}\n$$\n其中 $\\Gamma$ 是展宽半峰宽。\n\n最后，在零温下，单位长度的量子电容 $C_Q/L$ 与化学势 $\\mu$ 处的态密度成正比。其关系为：\n$$\n\\frac{C_Q}{L} = e^2 D(\\mu)\n$$\n其中 $e$ 是元电荷。我们使用数值确定的本征能量和提供的参数为每个测试用例计算这个值。所有物理常数均采用国际单位制 (SI)，以 eV 或 meV 为单位的能量参数在内部计算时会转换为焦耳。$C_Q/L$ 的最终结果以法拉每米 (F/m) 表示。", "answer": "```python\nimport numpy as np\nfrom scipy.constants import hbar, m_e, e\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Physical constants in SI units\n    # hbar: Reduced Planck constant (J.s)\n    # m_e: Electron mass (kg)\n    # e: Elementary charge (C)\n\n    def solve_bvp_numerov(energy_J, L, N_grid, m):\n        \"\"\"\n        Solves the Schrodinger equation for a given energy E using the Numerov method.\n        Returns the wavefunction value at x=L.\n\n        Args:\n            energy_J (float): Trial energy in Joules.\n            L (float): Length of the nanowire in meters.\n            N_grid (int): Number of grid points for discretization.\n            m (float): Mass of the particle in kg.\n\n        Returns:\n            float: Value of psi at x=L.\n        \"\"\"\n        if energy_J <= 0:\n            return 0.0\n\n        h = L / N_grid\n        k2 = (2.0 * m * energy_J) / (hbar**2)\n        \n        # Numerov method coefficients for constant k^2\n        h2_k2_12 = h**2 * k2 / 12.0\n        c1 = 1.0 + h2_k2_12\n        c2 = 2.0 * (1.0 - 5.0 * h2_k2_12)\n        \n        # Initial conditions: psi(0) = 0, psi(h) = small constant\n        psi_prev = 0.0\n        psi_curr = 1e-5\n        \n        for _ in range(1, N_grid):\n            psi_next = (c2 * psi_curr - c1 * psi_prev) / c1\n            psi_prev, psi_curr = psi_curr, psi_next\n            \n        return psi_curr\n\n    def bisection(func, a, b, tol=1e-10):\n        \"\"\"\n        Finds a root of func in the interval [a, b] using the bisection method.\n        'tol' is relative to the size of the interval.\n        \"\"\"\n        fa, fb = func(a), func(b)\n        if fa * fb >= 0:\n            return None  # No root or multiple roots in the interval\n\n        while (b - a) / (abs(a) + abs(b)) > tol:\n            c = (a + b) / 2.0\n            fc = func(c)\n            if fc == 0.0:\n                return c\n            if fa * fc < 0:\n                b, fb = c, fc\n            else:\n                a, fa = c, fc\n        return (a + b) / 2.0\n\n    def find_eigenenergies(L, m, E_max_J, N_grid, N_scan_steps=2000):\n        \"\"\"\n        Finds all eigenenergies up to E_max_J by scanning and using bisection.\n        \n        Args:\n            L (float): Length of the nanowire in meters.\n            m (float): Mass of the particle in kg.\n            E_max_J (float): Maximum energy to scan for eigenvalues, in Joules.\n            N_grid (int): Number of grid points for Numerov.\n            N_scan_steps (int): Number of steps for the initial energy scan.\n\n        Returns:\n            list: A list of eigenenergies in Joules.\n        \"\"\"\n        energies = []\n        target_func = lambda E: solve_bvp_numerov(E, L, N_grid, m)\n\n        E_scan = np.linspace(1e-24, E_max_J, N_scan_steps) # Start slightly above zero\n        psi_L_prev = target_func(E_scan[0])\n        \n        for i in range(1, len(E_scan)):\n            E_curr = E_scan[i]\n            psi_L_curr = target_func(E_curr)\n            \n            if psi_L_prev * psi_L_curr < 0:\n                E_prev = E_scan[i-1]\n                root = bisection(target_func, E_prev, E_curr)\n                if root is not None:\n                    energies.append(root)\n            \n            psi_L_prev = psi_L_curr\n            \n        return energies\n\n    def compute_cq_per_l(mu_J, Gamma_J, L, eigenenergies):\n        \"\"\"\n        Computes the quantum capacitance per unit length.\n\n        Args:\n            mu_J (float): Chemical potential in Joules.\n            Gamma_J (float): Broadening half-width in Joules.\n            L (float): Length of the nanowire in meters.\n            eigenenergies (list): List of eigenenergies in Joules.\n\n        Returns:\n            float: Quantum capacitance per unit length in F/m.\n        \"\"\"\n        g_s = 2.0  # Spin degeneracy\n        \n        dos_sum = 0.0\n        for En in eigenenergies:\n            lorentzian = (1.0 / np.pi) * (Gamma_J / ((mu_J - En)**2 + Gamma_J**2))\n            dos_sum += lorentzian\n            \n        dos_per_length = (g_s / L) * dos_sum\n        \n        # C_Q/L = e^2 * D(mu), with D(mu) being per unit length and energy.\n        # D(mu) is in units of (J^-1 m^-1)\n        # e^2 is in C^2. C^2 / J is Farad. So result is F/m.\n        cq_per_l = e**2 * dos_per_length\n        return cq_per_l\n\n    # Test suite from the problem statement\n    test_cases = [\n        (1.0e-8, 2.0, 0.020),  # Case 1\n        (1.0e-8, 2.0, 0.0235), # Case 2\n        (1.0e-8, 2.0, 0.100),  # Case 3\n        (5.0e-9, 2.0, 0.050),  # Case 4\n        (2.0e-8, 1.0, 0.010),  # Case 5\n    ]\n    \n    # Parameters for the numerical solution\n    N_GRID_POINTS = 1000\n    # Set energy ceiling high enough for all test cases\n    E_CEILING_EV = 0.5 \n    E_CEILING_J = E_CEILING_EV * e\n\n    results = []\n    \n    # Run simulation for each test case\n    for case in test_cases:\n        L_m, Gamma_meV, mu_eV = case\n        \n        # Convert parameters to SI units (Joules)\n        Gamma_J = Gamma_meV * 1e-3 * e\n        mu_J = mu_eV * e\n        \n        # 1. Find the eigenenergies\n        eigenenergies = find_eigenenergies(L_m, m_e, E_CEILING_J, N_GRID_POINTS)\n        \n        # 2. Compute quantum capacitance per unit length\n        result = compute_cq_per_l(mu_J, Gamma_J, L_m, eigenenergies)\n        results.append(result)\n\n    # Format the final output as specified\n    print(f\"[{','.join(['{:.6e}'.format(r) for r in results])}]\")\n\nsolve()\n```", "id": "2421997"}]}