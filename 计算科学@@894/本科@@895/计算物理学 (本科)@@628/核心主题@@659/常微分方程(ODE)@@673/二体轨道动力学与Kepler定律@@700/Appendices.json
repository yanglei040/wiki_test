{"hands_on_practices": [{"introduction": "在深入研究复杂的数值模拟之前，让我们首先通过一个直接的计算来巩固我们对基本物理定律的理解。这个练习将应用源自牛顿引力定律的开普勒第三定律，来解决一个天体轨道周期的实际问题。通过这个实践，你将体会到这些基础定律在无需复杂积分的情况下所拥有的强大预测能力，并为后续的计算挑战打下坚实的基础 [@problem_id:2196965]。", "problem": "一家航天机构正计划将一颗新的观测卫星送入绕地球的稳定圆形轨道。出于任务计时的目的，他们需要计算地球的年轨道周期与新卫星的周期之比。\n\n该卫星将被放置在这样一个高度，使其轨道半径恰好等于月球轨道的半长轴 $a_M$。地球本身以半长轴为 $a_E$ 的近圆形轨道围绕太阳运行。\n\n你的任务是计算地球绕太阳的轨道周期 $T_E$ 与卫星绕地球的轨道周期 $T_S$ 之比。\n\n你已知以下数据：\n- 太阳质量：$M_{Sun} = 1.989 \\times 10^{30}$ kg\n- 地球质量：$M_{Earth} = 5.972 \\times 10^{24}$ kg\n- 地球绕太阳轨道的半长轴：$a_E = 1.496 \\times 10^{11}$ m\n- 月球绕地球轨道的半长轴：$a_M = 3.844 \\times 10^8$ m\n\n在你的计算中，假设轨道是圆形的。对于一个双体系统，如果环绕体的质量远小于中心天体，则可以忽略环绕体的质量。例如，卫星的质量与地球的质量相比可以忽略不计，而地球的质量与太阳的质量相比也可以忽略不计。万有引力常数用 $G$ 表示。\n\n计算比值 $\\frac{T_E}{T_S}$ 的数值，并将你的最终答案保留三位有效数字。", "solution": "我们使用牛顿双体圆形轨道动力学，这等价于从牛顿万有引力定律推导出的开普勒第三定律。对于一个质量可忽略的物体，在半径为 $r$ 的圆形轨道上围绕一个中心质量为 $M$ 的天体运行时，其轨道周期为\n$$\nT=2\\pi\\sqrt{\\frac{r^{3}}{G M}}.\n$$\n对于地球绕太阳运行，\n$$\nT_{E}=2\\pi\\sqrt{\\frac{a_{E}^{3}}{G M_{Sun}}},\n$$\n对于卫星在半径 $a_{M}$ 处绕地球运行，\n$$\nT_{S}=2\\pi\\sqrt{\\frac{a_{M}^{3}}{G M_{Earth}}}.\n$$\n求两周期之比，并约去共同因子 $2\\pi$ 和 $G$，可得\n$$\n\\frac{T_{E}}{T_{S}}=\\sqrt{\\frac{a_{E}^{3} M_{Earth}}{a_{M}^{3} M_{Sun}}}\n=\\sqrt{\\left(\\frac{a_{E}}{a_{M}}\\right)^{3}\\frac{M_{Earth}}{M_{Sun}}}.\n$$\n\n代入给定的数值：\n$$\n\\frac{a_{E}}{a_{M}}=\\frac{1.496\\times 10^{11}}{3.844\\times 10^{8}}\n=\\left(\\frac{1.496}{3.844}\\right)\\times 10^{3}\\approx 0.389178\\times 10^{3}=3.89178\\times 10^{2}.\n$$\n接着\n$$\n\\left(\\frac{a_{E}}{a_{M}}\\right)^{3}=(3.89178)^{3}\\times 10^{6}\\approx 58.9447113949\\times 10^{6}=5.89447113949\\times 10^{7}.\n$$\n对于质量比，\n$$\n\\frac{M_{Earth}}{M_{Sun}}=\\frac{5.972\\times 10^{24}}{1.989\\times 10^{30}}\n=\\left(\\frac{5.972}{1.989}\\right)\\times 10^{-6}\\approx 3.00251382\\times 10^{-6}.\n$$\n因此，根号内的表达式为\n$$\n\\left(\\frac{a_{E}}{a_{M}}\\right)^{3}\\frac{M_{Earth}}{M_{Sun}}\n=(5.89447113949\\times 10^{7})(3.00251382\\times 10^{-6})\n=(5.89447113949\\times 3.00251382)\\times 10^{1}\\approx 176.9823106.\n$$\n因此，\n$$\n\\frac{T_{E}}{T_{S}}=\\sqrt{176.9823106}\\approx 13.3035\\ldots\n$$\n保留三位有效数字，得到 $13.3$。", "answer": "$$\\boxed{13.3}$$", "id": "2196965"}, {"introduction": "解析解在现实世界中往往难以获得，因此数值模拟成为研究动力学系统的关键工具。这个练习将带你进入数值积分的世界，通过实现两种最简单的积分器——显式欧拉法和半隐式欧拉-克罗默法（Euler-Cromer method）来模拟彗星的轨道。你将亲眼见证算法中一个微小的改动如何戏剧性地影响系统的长期能量守恒，这是计算物理学中至关重要的一课 [@problem_id:2390259]。", "problem": "考虑一个牛顿二体系统，该系统模拟一个质量可忽略的彗星绕一个中心大质量天体运行。在无量纲引力单位下进行计算，其中引力常数与中心天体质量的乘积被归一化为 $G M = 1$，彗星质量为 $m = 1$。运动被限制在一个平面内，位置向量为 $\\mathbf{x}(t) \\in \\mathbb{R}^2$，速度为 $\\mathbf{v}(t) = d\\mathbf{x}/dt$。将要使用的基本定律是牛顿第二定律和平方反比引力，这二者可导出一阶系统\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}.\n$$\n在这些单位下，总机械能（哈密顿量）为\n$$\nH(\\mathbf{x},\\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert},\n$$\n对于连续动力学，该量不随时间改变。\n\n您的任务是仅基于核心定义 $d\\mathbf{x}/dt = \\mathbf{v}$ 和 $d\\mathbf{v}/dt = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$，为这个常微分方程（ODE）设计并实现两种一阶时间步进积分器：\n- 一种标准的显式欧拉积分器，它使用在当前时间层级评估的速度来推进位置。\n- 一种半隐式欧拉积分器（也称为 Euler–Cromer），它使用当前位置的加速度来推进速度，然后在同一步骤内使用更新后的速度来推进位置。\n\n从第一性原理出发，通过将时间离散化为大小为 $\\Delta t$ 的步长，并一致地应用上述定义来构建步与步之间的推进，推导每种方法的更新逻辑。除了这种显式的时间离散化之外，不要引入任何额外的近似，并确保两种方法在每步开始时都使用相同的力评估 $\\mathbf{a}(\\mathbf{x}) = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$。\n\n使用以下测试套件。对于每种情况，使用固定的时间步长 $\\Delta t$ 对指定的轨道周期数 $P$ 进行积分。在这些单位中，半长轴为 $a$ 的开普勒椭圆的轨道周期为 $T = 2\\pi a^{3/2}$。初始状态被选为圆形轨道上或椭圆的远日点，初始速度垂直于半径向量且方向为顺行运动。在这些单位中，所有量都是无量纲的。\n\n- 测试用例 1（圆形“理想路径”）：$a = 1$，$e = 0$，初始状态 $\\mathbf{x}_0 = (1, 0)$，$\\mathbf{v}_0 = (0, 1)$，$\\Delta t = 0.01$，$P = 50$。\n- 测试用例 2（中等偏心率彗星）：$a = 1$，$e = 0.6$，远日点初始状态 $\\mathbf{x}_0 = (1.6, 0)$，$\\mathbf{v}_0 = (0, 0.5)$，$\\Delta t = 0.001$，$P = 20$。\n- 测试用例 3（高偏心率彗星）：$a = 1$，$e = 0.9$，远日点初始状态 $\\mathbf{x}_0 = (1.9, 0)$，$\\mathbf{v}_0 \\approx (0, 0.22941573387)$，$\\Delta t = 0.0005$，$P = 5$。\n- 测试用例 4（边界时间步长，圆形）：$a = 1$，$e = 0$，初始状态 $\\mathbf{x}_0 = (1, 0)$，$\\mathbf{v}_0 = (0, 1)$，$\\Delta t = 0.05$，$P = 5$。\n\n对于每个测试用例，计算每个积分器的相对末端能量漂移，\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H(\\mathbf{x}_N,\\mathbf{v}_N) - H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|}{\\left| H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|},\n$$\n其中 $N = \\left\\lceil \\frac{P \\, T}{\\Delta t} \\right\\rceil$ 是所采取的步数，然后返回比率\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}.\n$$\n该比率 $r$ 是无量纲的。若 $r < 1$，则表示半隐式欧拉方法（Euler–Cromer）在相同时间内表现出比标准显式欧拉方法更小的绝对能量漂移。\n\n最终输出格式：您的程序应生成单行输出，其中包含测试用例 1-4 的 $r$ 值，以逗号分隔的列表形式，并包含在方括号内，例如 $[r_1,r_2,r_3,r_4]$。条目必须是浮点数。输出中不出现物理单位，因为所有量通过构造都是无量纲的。\n\n您的实现必须是完全自包含的，并且不得读取任何输入。每个测试用例的答案是一个浮点数 $r$。这四个输出的集合必须按照上述格式出现在一行上。通过全程使用标准的双精度算术，并忠实地实现基于所述基本定律和定义推导出的两种积分器，来确保数值稳定性。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于经典力学原理，特别是开普勒问题，在数学上被恰当地表述为一个常微分方程组的初值问题。参数和目标定义精确，不含任何矛盾、歧义或事实错误。该任务是计算物理学中的一个标准练习，要求推导和比较两种基本的数值积分器。\n\n我们着手进行推导和求解。\n\n该系统由一组关于位置向量 $\\mathbf{x}(t) \\in \\mathbb{R}^2$ 和速度向量 $\\mathbf{v}(t) \\in \\mathbb{R}^2$ 的一阶常微分方程（ODE）描述：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}) = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}\n$$\n这里，$\\mathbf{a}(\\mathbf{x})$ 是由引力引起的加速度，引力参数 $G M$ 被设为 $1$。\n\n我们将使用一个恒定的时间步长 $\\Delta t$ 来离散化时间。设系统在时间 $t_n = n \\Delta t$ 的状态为 $(\\mathbf{x}_n, \\mathbf{v}_n)$。我们寻求在时间 $t_{n+1} = t_n + \\Delta t$ 时找到状态 $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$。\n\n**标准显式欧拉积分器的推导**\n\n显式（或前向）欧拉方法使用当前时间层级 $t_n$ 的值来近似导数。\n第一个 ODE 的离散近似是：\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{x}}{dt} \\right|_{t_n} = \\mathbf{v}_n\n$$\n类似地，对于第二个 ODE：\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t_n} = \\mathbf{a}(\\mathbf{x}_n)\n$$\n重新整理这些表达式，得到显式欧拉方法的更新规则。首先，根据当前位置 $\\mathbf{x}_n$ 计算加速度 $\\mathbf{a}_n$。然后，使用时间 $t_n$ 的状态来推进位置和速度。\n\n单步的更新逻辑如下：\n1. 计算加速度：$\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2. 更新速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3. 更新位置：$\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n \\Delta t$\n\n关键特征是新位置 $\\mathbf{x}_{n+1}$ 是使用旧速度 $\\mathbf{v}_n$ 计算的，而不是新计算出的速度 $\\mathbf{v}_{n+1}$。\n\n**半隐式欧拉（Euler–Cromer）积分器的推导**\n\n半隐式欧拉方法，也称为 Euler-Cromer 方法，引入了一个细微但至关重要的修改。速度的更新首先被执行，然后这个新计算出的速度立即被用来更新位置。在一个步长内“混合”不同时间层级的做法定义了其半隐式的特性。\n\n速度的更新与显式方法保持相同：\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\mathbf{a}(\\mathbf{x}_n) \\implies \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{x}_n) \\Delta t\n$$\n然而，位置的更新使用了新的速度 $\\mathbf{v}_{n+1}$：\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\mathbf{v}_{n+1}\n$$\n\n单步的更新逻辑如下：\n1. 计算加速度：$\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2. 更新速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3. 更新位置：$\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1} \\Delta t$\n\n该方法是一种简单的辛积分器。对于像开普勒问题这样的哈密顿系统，此类积分器表现出优越的长期稳定性，尤其是在能量守恒方面。它们不能精确地守恒能量，但能量误差通常保持有界，围绕真实值振荡，而显式欧拉方法通常会导致能量的长期漂移。\n\n**模拟与评估方法论**\n\n对于每个测试用例，我们用每种积分器进行一次模拟，共两次。\n初始状态为 $(\\mathbf{x}_0, \\mathbf{v}_0)$。\n总积分时间由轨道周期数 $P$ 指定。半长轴为 $a$ 的开普勒轨道的周期为 $T = 2\\pi a^{3/2}$。\n所需的总步数为 $N = \\lceil (P \\cdot T) / \\Delta t \\rceil$。\n\n连续系统的守恒量是机械能，或哈密顿量：\n$$\nH(\\mathbf{x}, \\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert}\n$$\n我们计算初始能量 $H_0 = H(\\mathbf{x}_0, \\mathbf{v}_0)$。经过 $N$ 步后，我们得到最终状态 $(\\mathbf{x}_N, \\mathbf{v}_N)$ 并计算最终能量 $H_N = H(\\mathbf{x}_N, \\mathbf{v}_N)$。\n\n每个积分器的性能由相对末端能量漂移 $\\delta$ 来量化：\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H_N - H_0 \\right|}{\\left| H_0 \\right|}\n$$\n问题要求计算两种方法这些漂移的比率 $r$：\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}\n$$\n若值 $r < 1$，则表明半隐式 Euler-Cromer 方法在长期能量守恒方面优于标准的显式欧拉方法（针对给定参数）。实现将精确遵循这些推导。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem using explicit Euler and semi-implicit Euler\n    methods and computes the ratio of their energy drifts.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        # case 1: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.01, P=50\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.01, 'P': 50},\n        # case 2: a=1, e=0.6, x0=(1.6,0), v0=(0,0.5), dt=0.001, P=20\n        {'a': 1.0, 'x0': np.array([1.6, 0.0]), 'v0': np.array([0.0, 0.5]), 'dt': 0.001, 'P': 20},\n        # case 3: a=1, e=0.9, x0=(1.9,0), v0=(0, ~0.2294), dt=0.0005, P=5\n        {'a': 1.0, 'x0': np.array([1.9, 0.0]), 'v0': np.array([0.0, 0.22941573387]), 'dt': 0.0005, 'P': 5},\n        # case 4: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.05, P=5\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.05, 'P': 5},\n    ]\n\n    results = []\n\n    def hamiltonian(x, v):\n        \"\"\"Computes the Hamiltonian (total energy) of the system.\"\"\"\n        r_norm = np.linalg.norm(x)\n        v_norm_sq = np.dot(v, v)\n        return 0.5 * v_norm_sq - 1.0 / r_norm\n\n    def run_explicit_euler(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the standard explicit Euler method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Store old velocity for position update\n            v_old = v\n            # Update velocity\n            v = v + a * dt\n            # Update position using old velocity\n            x = x + v_old * dt\n        return x, v\n\n    def run_euler_cromer(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the semi-implicit Euler-Cromer method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Update velocity\n            v = v + a * dt\n            # Update position using new velocity\n            x = x + v * dt\n        return x, v\n        \n    for case in test_cases:\n        a = case['a']\n        x0 = case['x0']\n        v0 = case['v0']\n        dt = case['dt']\n        P = case['P']\n\n        # Calculate orbital period and number of steps\n        T = 2.0 * np.pi * a**(1.5)\n        N = int(np.ceil(P * T / dt))\n\n        # Initial energy\n        H0 = hamiltonian(x0, v0)\n\n        # Run Explicit Euler simulation\n        x_N_euler, v_N_euler = run_explicit_euler(x0, v0, N, dt)\n        H_N_euler = hamiltonian(x_N_euler, v_N_euler)\n        delta_euler = np.abs(H_N_euler - H0) / np.abs(H0)\n\n        # Run Euler-Cromer simulation\n        x_N_cromer, v_N_cromer = run_euler_cromer(x0, v0, N, dt)\n        H_N_cromer = hamiltonian(x_N_cromer, v_N_cromer)\n        delta_cromer = np.abs(H_N_cromer - H0) / np.abs(H0)\n\n        # Calculate the ratio of energy drifts\n        # Handle the case where delta_euler is zero to avoid division by zero\n        if delta_euler == 0.0:\n            # If Euler has no drift, and Cromer does, ratio is infinity.\n            # If neither has drift, ratio is undefined, but 1.0 is a neutral choice.\n            # In practice, with finite precision, this is unlikely.\n            r = 1.0 if delta_cromer == 0.0 else np.inf\n        else:\n            r = delta_cromer / delta_euler\n        \n        results.append(r)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390259"}, {"introduction": "在前一个练习的基础上，我们现在来比较更高级的积分方案。这个练习将一个标准的、通用的高阶方法（经典的四阶龙格-库塔法 (RK4)）与一个保持系统几何结构的辛方法（蛙跳法, Leapfrog）进行对决。你将定量地测量和观察非辛方法中能量的长期漂移与辛方法中能量的有界振荡之间的根本区别，这是对任何长期天体运动模拟都至关重要的深刻见解 [@problem_id:2423025]。", "problem": "考虑牛顿定律下引力参数为 $\\mu$ 的平面双体引力问题。在无量纲单位下，设 $\\mu = 1$，此时半长轴 $a = 1$ 的轨道周期为 $T = 2\\pi$。状态为 $\\mathbf{y}(t) = (\\mathbf{r}(t), \\mathbf{v}(t)) \\in \\mathbb{R}^4$，其中 $\\mathbf{r}(t) \\in \\mathbb{R}^2$ 是位置，$\\mathbf{v}(t) \\in \\mathbb{R}^2$ 是速度。运动方程为常微分方程 (ODE)\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\qquad\n\\frac{d\\mathbf{v}}{dt} = -\\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|^3},\n$$\n其中 $\\|\\cdot\\|$ 是欧几里得范数。精确解的守恒比轨道能（单位质量的能量）为\n$$\nE(\\mathbf{r},\\mathbf{v}) = \\frac{1}{2}\\|\\mathbf{v}\\|^2 - \\frac{1}{\\|\\mathbf{r}\\|}.\n$$\n对于半长轴为 $a$、离心率为 $e$ 的椭圆，其近心点半径为 $r_{\\mathrm{p}} = a(1-e)$，近心点速度由活力公式 $v_{\\mathrm{p}} = \\sqrt{\\mu\\left(\\frac{2}{r_{\\mathrm{p}}} - \\frac{1}{a}\\right)}$ 给出。您将使用此公式在近心点初始化轨道，平面内坐标为 $\\mathbf{r}(0) = (r_{\\mathrm{p}},0)$ 和 $\\mathbf{v}(0) = (0,v_{\\mathrm{p}})$。\n\n您的任务是量化和比较应用于此开普勒轨道的两种数值时间积分器的长期能量行为：\n\n- 经典的四阶龙格-库塔方法 (RK4)，阶数为 $p=4$。\n- 二阶辛蛙跳 (速度Verlet) 方法，阶数为 $p=2$。\n\n从基本原理上讲，单步法的精度阶数定义为其全局误差在固定有限时间内随时间步长 $h$ 减小的速率，而辛性质则关乎哈密顿系统中的结构保持。在双体引力运动中，精确能量 $E$ 是恒定的，因此任何偏差都纯粹是数值赝象。您需要测量：\n\n1. RK4的线性漂移度量：在离散时间 $t_n = nh$（$n=0,1,\\dots,N$）构建时间序列 $y(t_n) = \\big(E(\\mathbf{r}_n,\\mathbf{v}_n) - E_0\\big)/|E_0|$，其中 $E_0 = E(\\mathbf{r}_0,\\mathbf{v}_0)$。对 $y$ 与 $t$ 进行最小二乘线性拟合，以估计漂移率 $\\hat{s}$（无量纲，单位为每无量纲时间），并报告在整个仿真时域内的总线性漂移为 $\\Delta_{\\mathrm{RK4}} = \\hat{s}\\,T_{\\mathrm{end}}$，其中 $T_{\\mathrm{end}}$ 是总仿真时间。\n2. 蛙跳法的有界振荡度量：计算整个轨迹上的最大绝对相对能量偏差，$\\mathcal{A}_{\\mathrm{LF}} = \\max_{0\\le n\\le N} |y(t_n)|$。\n\n请实现这两种积分器，并为以下测试套件计算这两个度量。所有量均为无量纲；除了本文给出的定义外，不需要任何物理单位。无需提供角度作为输入，您在推理或代码中使用的任何内部角度均默认为弧度。\n\n测试套件（每个案例均使用 $a=1$, $\\mu=1$，并模拟 $N_{\\mathrm{per}}=200$ 个完整周期，因此 $T_{\\mathrm{end}} = N_{\\mathrm{per}}\\cdot 2\\pi$）：\n\n- 案例1：离心率 $e=0$，时间步长 $h=0.05$。\n- 案例2：离心率 $e=0.6$，时间步长 $h=0.05$。\n- 案例3：离心率 $e=0.6$，时间步长 $h=0.02$。\n\n对于每个案例，请按照指定使用活力公式在近心点进行初始化。对于RK4，计算如上定义的 $\\Delta_{\\mathrm{RK4}}$。对于蛙跳法，计算如上定义的 $\\mathcal{A}_{\\mathrm{LF}}$。您的程序应生成单行输出，包含一个逗号分隔的列表，其中有三个项目，每个案例一项，每个项目本身都是一个$[\\Delta_{\\mathrm{RK4}},\\mathcal{A}_{\\mathrm{LF}}]$顺序的双元素列表。例如，整体输出格式必须是\n$$\n[\\,[\\Delta_{\\mathrm{RK4}}^{(1)},\\mathcal{A}_{\\mathrm{LF}}^{(1)}],\\,[\\Delta_{\\mathrm{RK4}}^{(2)},\\mathcal{A}_{\\mathrm{LF}}^{(2)}],\\,[\\Delta_{\\mathrm{RK4}}^{(3)},\\mathcal{A}_{\\mathrm{LF}}^{(3)}]\\,]\n$$\n打印在单行上，使用浮点数。为便于阅读，请将您打印的浮点数四舍五入到合理的有效位数。\n\n您的代码必须是完全自包含的，不要求用户输入，并且必须精确地按照本文的定义实现两种积分器和能量诊断。", "solution": "该问题要求对应用于平面双体引力问题的两种数值积分器——四阶龙格-库塔方法 (RK4) 和二阶蛙跳法——进行定量比较。目标是数值地展示它们相对于一个守恒量（比轨道能）的特征性长期行为。对于像RK4这样通用的、非结构保持的方法，能量预计会表现出长期漂移。对于像蛙跳法这样的辛方法，能量误差预计会保持有界。我们将计算特定的度量来量化这些现象。\n\n系统由状态向量 $\\mathbf{y}(t) = (\\mathbf{r}(t), \\mathbf{v}(t))$ 描述，其中 $\\mathbf{r} \\in \\mathbb{R}^2$ 是位置，$\\mathbf{v} \\in \\mathbb{R}^2$ 是速度。运动方程由一阶常微分方程 (ODE) 系统 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$ 给出：\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{r}) = -\\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|^{3}}\n$$\n这对应于引力参数 $\\mu=1$。该系统是哈密顿系统，其比轨道能 $E$ 是精确解的一个守恒量：\n$$\nE(\\mathbf{r}, \\mathbf{v}) = \\frac{1}{2}\\|\\mathbf{v}\\|^{2} - \\frac{1}{\\|\\mathbf{r}\\|}\n$$\n轨道在近心点被初始化。对于给定的半长轴 $a$ 和离心率 $e$，近心点半径为 $r_{\\mathrm{p}} = a(1-e)$。初始位置设为 $\\mathbf{r}(0) = (r_{\\mathrm{p}}, 0)$。相应的近心点速度 $v_{\\mathrm{p}}$ 由活力公式求得：\n$$\nv_{\\mathrm{p}} = \\sqrt{\\mu\\left(\\frac{2}{r_{\\mathrm{p}}} - \\frac{1}{a}\\right)}\n$$\n于是初始速度为 $\\mathbf{v}(0) = (0, v_{\\mathrm{p}})$。对于所有指定的测试案例，我们有 $a=1$ 和 $\\mu=1$，这意味着精确的初始能量为 $E_0 = E(\\mathbf{r}(0), \\mathbf{v}(0)) = -\\frac{\\mu}{2a} = -0.5$。\n\n我们将实现两种不同的单步法，以根据时间 $t_n$ 的解 $\\mathbf{y}_n$ 来近似计算时间 $t_{n+1} = t_n + h$ 的解 $\\mathbf{y}_{n+1}$。\n\n首先，是经典的四阶龙格-库塔 (RK4) 方法，阶数为 $p=4$。对于一个常微分方程 $\\dot{\\mathbf{y}} = f(t, \\mathbf{y})$，单步计算如下：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= f(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 &= f(t_n + \\frac{h}{2}, \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= f(t_n + \\frac{h}{2}, \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= f(t_n + h, \\mathbf{y}_n + h \\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n在这里，$\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$ 是一个4维向量，函数 $f$ 不显式依赖于时间 $t$，所以 $f(t, \\mathbf{y}) = f(\\mathbf{y}) = (\\mathbf{v}, -\\mathbf{r}/\\|\\mathbf{r}\\|^3)$。\n\n其次，是二阶蛙跳法，阶数为 $p=2$，采用其速度Verlet形式。该方法特别适用于形式为 $H(\\mathbf{r},\\mathbf{v}) = T(\\mathbf{v}) + U(\\mathbf{r})$ 的可分哈密顿量。加速度 $\\mathbf{a}(\\mathbf{r})$ 仅依赖于位置。从 $(\\mathbf{r}_n, \\mathbf{v}_n)$ 和预先计算的加速度 $\\mathbf{a}_n = \\mathbf{a}(\\mathbf{r}_n)$ 开始的单步计算过程如下：\n$$\n\\begin{aligned}\n\\mathbf{r}_{n+1} &= \\mathbf{r}_n + h \\mathbf{v}_n + \\frac{h^2}{2} \\mathbf{a}_n \\\\\n\\mathbf{a}_{n+1} &= \\mathbf{a}(\\mathbf{r}_{n+1}) = -\\frac{\\mathbf{r}_{n+1}}{\\|\\mathbf{r}_{n+1}\\|^{3}} \\\\\n\\mathbf{v}_{n+1} &= \\mathbf{v}_n + \\frac{h}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\n\\end{aligned}\n$$\n此方法是辛方法，保证了它能保持哈密顿系统相空间流的几何结构。其结果是，虽然数值能量不被精确守恒，但其误差在非常长的积分时间内仍保持有界。\n\n在每一步 $n=0, 1, \\dots, N$，我们计算数值能量 $E_n = E(\\mathbf{r}_n, \\mathbf{v}_n)$ 和相对能量误差：\n$$\ny_n = \\frac{E_n - E_0}{|E_0|}\n$$\n对这些积分器的评估依赖于两个不同的度量。对于RK4方法，我们量化能量的线性漂移。我们对时间序列 $(t_n, y_n)$（其中 $t_n = nh$）进行线性最小二乘拟合，以找到模型 $y(t) = \\hat{s}t + c$。斜率 $\\hat{s}$ 代表能量漂移率。在仿真时域 $T_{\\mathrm{end}} = N_{\\mathrm{per}} \\cdot 2\\pi = 400\\pi$ 内的总漂移报告为：\n$$\n\\Delta_{\\mathrm{RK4}} = \\hat{s} \\cdot T_{\\mathrm{end}}\n$$\n对于蛙跳法，我们通过计算整个仿真过程中的最大绝对相对能量偏差来量化能量误差的有界振荡：\n$$\n\\mathcal{A}_{\\mathrm{LF}} = \\max_{0 \\le n \\le N} |y_n|\n$$\n\n我们进行总时间为 $T_{\\mathrm{end}} = 200 \\cdot 2\\pi = 400\\pi$ 的仿真。步数为 $N = \\text{round}(T_{\\mathrm{end}}/h)$。对于三个测试案例中的每一个，我们计算初始条件，运行两种积分器，并计算所需的度量。\n\n案例1：$e=0$，$h=0.05$。\n- 初始条件：$a=1, e=0 \\implies r_{\\mathrm{p}} = 1$。$v_{\\mathrm{p}} = \\sqrt{1(\\frac{2}{1} - \\frac{1}{1})} = 1$。$\\mathbf{r}_0 = (1, 0)$，$\\mathbf{v}_0 = (0, 1)$。\n- $N = \\text{round}(400\\pi / 0.05) = 25133$。\n\n案例2：$e=0.6$，$h=0.05$。\n- 初始条件：$a=1, e=0.6 \\implies r_{\\mathrm{p}} = 0.4$。$v_{\\mathrm{p}} = \\sqrt{1(\\frac{2}{0.4} - \\frac{1}{1})} = 2$。$\\mathbf{r}_0 = (0.4, 0)$，$\\mathbf{v}_0 = (0, 2)$。\n- $N = \\text{round}(400\\pi / 0.05) = 25133$。\n\n案例3：$e=0.6$，$h=0.02$。\n- 初始条件：同案例2。$\\mathbf{r}_0 = (0.4, 0)$，$\\mathbf{v}_0 = (0, 2)$。\n- $N = \\text{round}(400\\pi / 0.02) = 62832$。\n\n对于每个案例，初始能量为 $E_0 = -0.5$。计算将根据指定的程序进行。实现过程包括为加速度、RK4步和蛙跳步编写函数，然后为测试套件中的每个案例组织仿真和度量计算。最终输出将是一个列表，其中包含每个测试案例的 $[\\Delta_{\\mathrm{RK4}}, \\mathcal{A}_{\\mathrm{LF}}]$ 对。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares RK4 and Leapfrog integrators for the Kepler problem\n    and computes energy drift/oscillation metrics.\n    \"\"\"\n    # Define problem constants and test suite\n    MU_GRAV = 1.0\n    SEMI_MAJOR_AXIS = 1.0\n    N_PERIODS = 200\n    T_END = N_PERIODS * 2 * np.pi\n\n    test_cases = [\n        {'e': 0.0, 'h': 0.05},\n        {'e': 0.6, 'h': 0.05},\n        {'e': 0.6, 'h': 0.02},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        eccentricity = case['e']\n        h = case['h']\n\n        # --- Initial Conditions ---\n        r_pericenter = SEMI_MAJOR_AXIS * (1 - eccentricity)\n        v_pericenter = np.sqrt(MU_GRAV * (2 / r_pericenter - 1 / SEMI_MAJOR_AXIS))\n        \n        r0 = np.array([r_pericenter, 0.0])\n        v0 = np.array([0.0, v_pericenter])\n        \n        y0 = np.concatenate([r0, v0])\n\n        E0 = 0.5 * np.linalg.norm(v0)**2 - MU_GRAV / np.linalg.norm(r0)\n        \n        N_steps = int(np.round(T_END / h))\n        times = np.linspace(0, N_steps * h, N_steps + 1)\n        \n        # --- Helper functions ---\n        def acceleration(r):\n            dist_cubed = np.linalg.norm(r)**3\n            return -MU_GRAV * r / dist_cubed\n\n        def f_ode(y):\n            r = y[:2]\n            v = y[2:]\n            accel = acceleration(r)\n            return np.concatenate([v, accel])\n            \n        def energy(r, v):\n            return 0.5 * np.linalg.norm(v)**2 - MU_GRAV / np.linalg.norm(r)\n\n        # --- Integrator 1: RK4 ---\n        y_rk4 = np.zeros((N_steps + 1, 4))\n        y_rk4[0] = y0\n        \n        for n in range(N_steps):\n            k1 = f_ode(y_rk4[n])\n            k2 = f_ode(y_rk4[n] + 0.5 * h * k1)\n            k3 = f_ode(y_rk4[n] + 0.5 * h * k2)\n            k4 = f_ode(y_rk4[n] + h * k3)\n            y_rk4[n+1] = y_rk4[n] + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        \n        energies_rk4 = np.array([energy(y[:2], y[2:]) for y in y_rk4])\n        rel_energy_error_rk4 = (energies_rk4 - E0) / np.abs(E0)\n        \n        # Calculate Delta_RK4\n        slope, _ = np.polyfit(times, rel_energy_error_rk4, 1)\n        delta_rk4 = slope * T_END\n\n        # --- Integrator 2: Leapfrog (Velocity Verlet) ---\n        r_lf = np.zeros((N_steps + 1, 2))\n        v_lf = np.zeros((N_steps + 1, 2))\n        \n        r_lf[0] = r0\n        v_lf[0] = v0\n        \n        a_n = acceleration(r_lf[0])\n        \n        for n in range(N_steps):\n            # Update position to full step\n            r_lf[n+1] = r_lf[n] + h * v_lf[n] + 0.5 * h**2 * a_n\n            \n            # Compute new acceleration\n            a_n_plus_1 = acceleration(r_lf[n+1])\n            \n            # Update velocity to full step\n            v_lf[n+1] = v_lf[n] + 0.5 * h * (a_n + a_n_plus_1)\n            \n            # Store new acceleration for a_n in the next step\n            a_n = a_n_plus_1\n\n        energies_lf = np.array([energy(r_lf[i], v_lf[i]) for i in range(N_steps + 1)])\n        rel_energy_error_lf = (energies_lf - E0) / np.abs(E0)\n\n        # Calculate A_LF\n        A_lf = np.max(np.abs(rel_energy_error_lf))\n\n        results.append([delta_rk4, A_lf])\n\n    # Format the final output string according to the problem specification\n    result_str = '[' + ','.join([f\"[{res[0]:.6e},{res[1]:.6e}]\" for res in results]) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "2423025"}]}