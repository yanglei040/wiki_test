{"hands_on_practices": [{"introduction": "在深入研究常微分方程 (ODE) 之前，在一个更简单的背景下理解外推的核心原理是很有帮助的。本练习将理查森外推法 (Richardson extrapolation) 应用于一个我们熟知的几何级数，将部分和序列视为一个在其极限点（对应于无限项）求值的函数。通过这个练习，你将建立起如何结合不同步长的低精度结果以获得高精度估计的直观理解 [@problem_id:2378481]。", "problem": "设 $x$ 是一个满足 $|x|<1$ 的实参数。定义几何级数和 $S(x)$ 及其第$N$项部分和 $S_{N}(x)$ 如下：\n$$\nS(x) = \\sum_{k=0}^{\\infty} x^{k}, \\qquad S_{N}(x) = \\sum_{k=0}^{N} x^{k}.\n$$\n考虑定义在离散集合 $\\{h = 1/N : N \\in \\mathbb{N}\\}$ 上的映射 $h \\mapsto S(h)$，由 $S(h) := S_{1/h}(x) = S_{N}(x)$ 给出，并将 $h$ 视为一个步长参数。借鉴Bulirsch–Stoer外推法的思想，构造一个唯一的二次多项式 $P_{2}(h)$，该多项式对以下三个数据点进行插值：$\\big(h_{1},S(h_{1})\\big)$、$\\big(h_{2},S(h_{2})\\big)$ 和 $\\big(h_{3},S(h_{3})\\big)$，其中\n$$\nh_{1}=\\frac{1}{N}, \\qquad h_{2}=\\frac{1}{2N}, \\qquad h_{3}=\\frac{1}{3N},\n$$\n且 $N \\in \\mathbb{N}$ 是一个固定的自然数。请确定 $P_{2}(0)$ 的值，并给出一个仅用 $x$ 和 $N$ 表示的完全简化的闭式解析表达式。\n\n答案规格：\n- 以单个闭式解析表达式的形式提供最终答案。\n- 无需四舍五入，不涉及单位。", "solution": "首先必须验证问题陈述的科学性和逻辑完整性。\n\n步骤1：提取已知条件\n- 一个实参数 $x$，满足约束条件 $|x|<1$。\n- 几何级数和定义为 $S(x) = \\sum_{k=0}^{\\infty} x^{k}$。\n- 第$N$项部分和定义为 $S_{N}(x) = \\sum_{k=0}^{N} x^{k}$。\n- 一个函数 $S(h)$ 定义在离散点集 $h = 1/M$（$M \\in \\mathbb{N}$）上，其关系为 $S(h) := S_{1/h}(x)$。\n- 一个唯一的二次多项式，记为 $P_{2}(h)$，对以下三个特定点进行插值：\n  - $(h_{1}, S(h_{1}))$，其中 $h_{1} = \\frac{1}{N}$\n  - $(h_{2}, S(h_{2}))$，其中 $h_{2} = \\frac{1}{2N}$\n  - $(h_{3}, S(h_{3}))$，其中 $h_{3} = \\frac{1}{3N}$\n- 整数 $N$ 是一个固定的自然数，$N \\in \\mathbb{N}$。\n- 目标是确定此多项式在 $h=0$ 处的值，即 $P_{2}(0)$，并用一个仅含 $x$ 和 $N$ 的简化闭式解析表达式表示。\n\n步骤2：使用提取的已知条件进行验证\n- **科学依据：** 该问题是在分析学和数值方法的标准数学框架内提出的。几何级数、部分和以及多项式插值都是基本概念。将一个近似序列外推到其极限的思想，是Bulirsch–Stoer方法的核心，也是计算科学中一种成熟的技术。条件 $|x|<1​$ 恰当地确保了该几何级数的收敛性。该问题在科学上是合理的。\n- **适定性：** 一个唯一的二次多项式由三个不同的点确定。对于任何 $N \\in \\mathbb{N}$，值 $h_{1} = 1/N$、$h_{2} = 1/(2N)$ 和 $h_{3} = 1/(3N)$ 都是不相等的。因此，存在一个唯一的插值多项式 $P_2(h)$。任务是求其在特定点 $h=0$ 处的值，这是一个唯一定义的量。该问题是适定的。\n- **客观性：** 问题陈述是精确的、定量的，并且没有主观或模糊的语言。\n\n步骤3：结论与行动\n该问题是有效的。这是一个关于多项式插值和外推的定义明确的数学练习。我将继续进行求解。\n\n任务是求值 $P_{2}(0)$，其中 $P_{2}(h)$ 是经过三个点 $(h_k, A_k)$ 的唯一二次多项式，这里 $h_k$ 是给定的步长，$A_k = S(h_k)$ 是对应的部分和的值。\n令 $h_1 = \\frac{1}{N}$，$h_2 = \\frac{1}{2N}$，$h_3 = \\frac{1}{3N}$。\n对应的函数值为：\n$A_1 = S(h_1) = S_N(x) = \\sum_{k=0}^{N} x^k$\n$A_2 = S(h_2) = S_{2N}(x) = \\sum_{k=0}^{2N} x^k$\n$A_3 = S(h_3) = S_{3N}(x) = \\sum_{k=0}^{3N} x^k$\n\n我们寻求在 $h=0$ 处计算该插值多项式的值。这是一种外推，因为 $h=0$ 位于插值点定义的区间之外。一个直接的方法是使用 $P_2(h)$ 的Lagrange插值公式，然后令 $h=0$。\nLagrange插值多项式的形式为：\n$$\nP_2(h) = A_1 \\frac{(h-h_2)(h-h_3)}{(h_1-h_2)(h_1-h_3)} + A_2 \\frac{(h-h_1)(h-h_3)}{(h_2-h_1)(h_2-h_3)} + A_3 \\frac{(h-h_1)(h-h_2)}{(h_3-h_1)(h_3-h_2)}\n$$\n在 $h=0$ 处求值，我们得到：\n$$\nP_2(0) = A_1 \\frac{h_2 h_3}{(h_1-h_2)(h_1-h_3)} + A_2 \\frac{h_1 h_3}{(h_2-h_1)(h_2-h_3)} + A_3 \\frac{h_1 h_2}{(h_3-h_1)(h_3-h_2)}\n$$\n这将 $P_2(0)$ 表示为 $A_1$、$A_2$ 和 $A_3$ 的线性组合。我们必须计算这些系数。为简化起见，令 $h_0 = 1/N$。那么 $h_1=h_0$，$h_2=h_0/2$，$h_3=h_0/3$。\n\n$A_1$ 的系数：\n$$\nc_1 = \\frac{(\\frac{h_0}{2})(\\frac{h_0}{3})}{(h_0-\\frac{h_0}{2})(h_0-\\frac{h_0}{3})} = \\frac{\\frac{1}{6}h_0^2}{(\\frac{1}{2}h_0)(\\frac{2}{3}h_0)} = \\frac{\\frac{1}{6}h_0^2}{\\frac{1}{3}h_0^2} = \\frac{1}{2}\n$$\n$A_2$ 的系数：\n$$\nc_2 = \\frac{(h_0)(\\frac{h_0}{3})}{(\\frac{h_0}{2}-h_0)(\\frac{h_0}{2}-\\frac{h_0}{3})} = \\frac{\\frac{1}{3}h_0^2}{(-\\frac{1}{2}h_0)(\\frac{1}{6}h_0)} = \\frac{\\frac{1}{3}h_0^2}{-\\frac{1}{12}h_0^2} = -4\n$$\n$A_3$ 的系数：\n$$\nc_3 = \\frac{(h_0)(\\frac{h_0}{2})}{(\\frac{h_0}{3}-h_0)(\\frac{h_0}{3}-\\frac{h_0}{2})} = \\frac{\\frac{1}{2}h_0^2}{(-\\frac{2}{3}h_0)(-\\frac{1}{6}h_0)} = \\frac{\\frac{1}{2}h_0^2}{\\frac{1}{9}h_0^2} = \\frac{9}{2}\n$$\n因此，外推值为：\n$$\nP_2(0) = \\frac{1}{2}A_1 - 4A_2 + \\frac{9}{2}A_3\n$$\n系数和为 $c_1+c_2+c_3 = \\frac{1}{2}-4+\\frac{9}{2} = 5-4=1$ 的条件得到满足，这与外推公式的预期相符。\n\n接下来，我们代入 $A_k = S_{kN}(x)$ 的表达式。有限几何级数的和由 $S_M(x) = \\frac{1-x^{M+1}}{1-x}$ 给出。\n各项为：\n$A_1 = S_N(x) = \\frac{1-x^{N+1}}{1-x}$\n$A_2 = S_{2N}(x) = \\frac{1-x^{2N+1}}{1-x}$\n$A_3 = S_{3N}(x) = \\frac{1-x^{3N+1}}{1-x}$\n\n将它们代入 $P_2(0)$ 的表达式中：\n$$\nP_2(0) = \\frac{1}{2}\\left(\\frac{1-x^{N+1}}{1-x}\\right) - 4\\left(\\frac{1-x^{2N+1}}{1-x}\\right) + \\frac{9}{2}\\left(\\frac{1-x^{3N+1}}{1-x}\\right)\n$$\n我们可以提取公分母 $\\frac{1}{1-x}$：\n$$\nP_2(0) = \\frac{1}{1-x} \\left[ \\frac{1}{2}(1-x^{N+1}) - 4(1-x^{2N+1}) + \\frac{9}{2}(1-x^{3N+1}) \\right]\n$$\n现在，我们简化方括号内的表达式。首先，合并常数项：\n$$\n\\frac{1}{2} - 4 + \\frac{9}{2} = \\frac{10}{2} - 4 = 5 - 4 = 1\n$$\n接下来，合并包含 $x$ 的幂的项：\n$$\n-\\frac{1}{2}x^{N+1} + 4x^{2N+1} - \\frac{9}{2}x^{3N+1}\n$$\n结合这些结果，方括号内的表达式变为：\n$$\n1 - \\frac{1}{2}x^{N+1} + 4x^{2N+1} - \\frac{9}{2}x^{3N+1}\n$$\n因此，$P_2(0)$ 的最终闭式表达式为：\n$$\nP_2(0) = \\frac{1 - \\frac{1}{2}x^{N+1} + 4x^{2N+1} - \\frac{9}{2}x^{3N+1}}{1-x}\n$$\n该表达式是仅关于 $x$ 和 $N$ 的函数，并且处于其最简解析形式。\n作为验证，在 $N \\to \\infty$ 的极限情况下，由于 $|x|<1$，我们有 $x^{N+1} \\to 0$，$x^{2N+1} \\to 0$，以及 $x^{3N+1} \\to 0$。$P_2(0)$ 的表达式趋近于 $\\frac{1}{1-x}$，这正是级数 $S(x)$ 的真实和。对于一个有效的外推方案，这是正确的行为。", "answer": "$$\n\\boxed{\\frac{1 - \\frac{1}{2}x^{N+1} + 4x^{2N+1} - \\frac{9}{2}x^{3N+1}}{1-x}}\n$$", "id": "2378481"}, {"introduction": "现在，让我们从抽象原理转向完整的实现。这个实践要求你从头开始编写一个 Bulirsch-Stoer (BS) 求解器，用以模拟带电粒子在匀强磁场中的运动，这是一个经典的计算物理问题。这个挑战将测试你综合运用修正中点法 (modified midpoint method) 和理查森外推表来创建一个自适应、高精度的 ODE 求解器的能力，并评估其在保持物理不变量（如拉莫尔半径 $r_{\\mathrm{L}}$）方面的性能 [@problem_id:2378480]。", "problem": "实现一个完整、可运行的程序，使用 Bulirsch–Stoer (BS) 外推法积分求解带电粒子在匀强磁场中的运动。物理模型必须基于洛伦兹力定律以及速度作为位置时间导数的运动学定义。以下列基本定律为基础：\n\n- 洛伦兹力：$\\mathbf{F} = q\\,\\mathbf{v} \\times \\mathbf{B}$。\n- 牛顿第二定律：$m\\,\\dfrac{d\\mathbf{v}}{dt} = \\mathbf{F}$。\n- 运动学：$\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{v}$。\n\n假设存在一个沿 $z$ 轴方向的空间均匀、不随时间变化的磁场 $\\mathbf{B}$，即 $\\mathbf{B} = (0,0,B_0)$，并且没有电场。设粒子质量为 $m$（单位：千克），电荷为 $q$（单位：库仑），位置为 $\\mathbf{x}(t)$（单位：米），速度为 $\\mathbf{v}(t)$（单位：米/秒），时间为 $t$（单位：秒）。所有物理量必须使用国际单位制 (SI)。所有角度（如适用）必须以弧度为单位。\n\n你的程序必须实现采用改进中点法和 Richardson 外推的 Bulirsch–Stoer 外推算法，以将状态 $(\\mathbf{x},\\mathbf{v})$ 随时间推进。实现必须从第一性原理出发，遵循上述基本定义，不得使用任何预构建的常微分方程 (ODE) 求解器。明确常微分方程 (ODE) 指的是形式为 $\\dfrac{d\\mathbf{y}}{dt} = \\mathbf{f}(t,\\mathbf{y})$ 的方程组。代码必须数值稳定，并且必须自适应步长以满足相对公差参数 $r_{\\text{tol}}$。\n\n在匀强磁场中的精确圆周运动具有恒定的拉莫尔半径（回旋半径）。对于 $\\mathbf{B} = (0,0,B_0)$，导心位置为\n$$\n\\mathbf{R}_{\\mathrm{gc}} = \\mathbf{x} + \\frac{m}{q B_0^2}\\,\\mathbf{v} \\times \\mathbf{B},\n$$\n在精确动力学下，该值不随时间变化，轨道半径为\n$$\nr_{\\mathrm{L}} = \\left\\| \\mathbf{x} - \\mathbf{R}_{\\mathrm{gc}} \\right\\|.\n$$\n使用此特性来评估数值方法是否精确地守恒轨道半径。\n\n测试套件规范（所有常数和初始条件均采用 SI 单位）：\n- 使用电子参数 $q = -1.602176634\\times 10^{-19}$ C 和 $m = 9.1093837015\\times 10^{-31}$ kg，磁场大小 $B_0 = 1$ 特斯拉，初始位置 $\\mathbf{x}(0) = (0,0,0)$ 米，初始速度 $\\mathbf{v}(0) = (1.0\\times 10^{6}, 0, 0)$ 米/秒。定义回旋频率 $\\omega_c = \\dfrac{|q| B_0}{m}$ 和回旋周期 $T = \\dfrac{2\\pi}{\\omega_c}$，其中 $\\pi$ 是圆周率。\n\n- 你的程序必须在均匀间隔的时间点上评估轨迹，并计算半径与初始拉莫尔半径的最大相对偏差，\n$$\n\\max_{t \\in [0,t_{\\text{final}}]} \\frac{\\left| r_{\\mathrm{L}}(t) - r_{\\mathrm{L}}(0) \\right|}{r_{\\mathrm{L}}(0)},\n$$\n每个周期使用固定数量的采样点。相对偏差是无量纲的；将其作为浮点数报告。\n\n提供四个测试用例来探究不同方面：\n- 测试 A (正常路径): $t_{\\text{final}} = T$，其中 $r_{\\text{tol}} = 10^{-10}$，每周期使用 $400$ 个样本。\n- 测试 B (更严公差): $t_{\\text{final}} = T$，其中 $r_{\\text{tol}} = 10^{-12}$，每周期使用 $400$ 个样本。\n- 测试 C (更松公差): $t_{\\text{final}} = T$，其中 $r_{\\text{tol}} = 10^{-8}$，每周期使用 $400$ 个样本。\n- 测试 D (多周期累积): $t_{\\text{final}} = 10\\,T$，其中 $r_{\\text{tol}} = 10^{-10}$，每周期使用 $400$ 个样本。\n\n所有关于 $T$ 的计算都必须使用弧度。四个测试的最终输出是按上述顺序排列的测试 A–D 的最大相对半径偏差的四个浮点数值。此外，计算一个布尔值，该布尔值回答以下概念性问题：“Bulirsch–Stoer 方法是否精确守恒圆形轨道半径？” 将此布尔值定义为真，当且仅当在机器运算精度内，所有四个计算出的最大相对偏差完全等于 $0$，否则为假。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，包含一个列表，其中按顺序列出五个结果，用方括号括起并用逗号分隔，例如 $[a,b,c,d,e]$，其中 $a$、$b$、$c$ 和 $d$ 是浮点数（测试 A–D 的最大相对偏差），$e$ 是回答上述守恒问题的布尔值。不应打印任何其他文本。\n\n程序必须完全独立且可直接运行，无需用户输入。确保所有选定值和计算的科学真实性和数值一致性。所有物理参数均以 SI 单位表示，并为相对偏差生成无量纲输出。是否实现精确守恒的概念性论证将另行评估；在此，你必须按规定计算数值证据和布尔值。", "solution": "用户要求实现 Bulirsch-Stoer (BS) 外推法，以求解带电粒子在匀强磁场中的运动轨迹。该问题在科学上是合理的，问题提法是适定的，并为完整求解提供了所有必要信息。\n\n质量为 $m$、电荷为 $q$ 的粒子的运动遵循牛顿第二定律，其中作用力为洛伦兹力。给定匀强磁场 $\\mathbf{B} = (0, 0, B_0)$ 且无电场，该系统可由以下方程描述：\n$$ \\frac{d\\mathbf{x}}{dt} = \\mathbf{v} $$\n$$ m\\,\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{v} \\times \\mathbf{B}) $$\n这构成了一个一阶常微分方程 (ODE) 组。设状态向量为 $\\mathbf{y}(t) = (\\mathbf{x}(t), \\mathbf{v}(t)) = (x, y, z, v_x, v_y, v_z)$。该方程组可以写作 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$。$\\mathbf{f}$ 的分量为：\n$$\n\\mathbf{f}(t, \\mathbf{y}) =\n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\nv_z \\\\\n\\frac{q B_0}{m} v_y \\\\\n-\\frac{q B_0}{m} v_x \\\\\n0\n\\end{pmatrix}\n$$\n无量纲量 $\\omega_c = \\frac{|q| B_0}{m}$ 是回旋频率。通过从初始状态 $\\mathbf{y}(0) = (\\mathbf{x}(0), \\mathbf{v}(0))$ 开始对该 ODE 系统进行数值积分，即可解决此问题。\n\nBulirsch-Stoer 方法是一种用于求解 ODE 的高级数值技术，它结合了三个关键思想：\n1.  **改进的中点法 (Modified Midpoint Method)**：该方法用于在从 $t$ 到 $t+H$ 的一个大区间 $H$ 上获得解的低阶近似。它通过将 $H$ 分为 $n$ 个大小为 $h = H/n$ 的子步来实现。状态序列 $z_0, z_1, \\dots, z_n$ 的计算如下：\n    $$ z_0 = \\mathbf{y}(t) $$\n    $$ z_1 = z_0 + h \\cdot \\mathbf{f}(t, z_0) $$\n    $$ z_{m+1} = z_{m-1} + 2h \\cdot \\mathbf{f}(t+mh, z_m) \\quad \\text{for } m=1, \\dots, n-1 $$\n    最后的平滑步骤得出对 $\\mathbf{y}(t+H)$ 的估计：\n    $$ \\mathbf{y}_n(H) = \\frac{1}{2}\\left(z_n + z_{n-1} + h \\cdot \\mathbf{f}(t+H, z_n)\\right) $$\n    此方法的误差有一个关于子步长偶数次幂的级数展开，即 $\\mathbf{y}_{true}(t+H) - \\mathbf{y}_n(H) = \\sum_{i=1}^{\\infty} c_i h^{2i} = \\sum_{i=1}^{\\infty} c_i (H/n)^{2i}$。\n\n2.  **Richardson 外推法 (Richardson Extrapolation)**：该技术利用已知的误差结构来系统地消除误差项。我们为一系列递增的子步数（例如 $n \\in \\{2, 4, 6, 8, \\dots\\}$）计算估计值 $\\mathbf{y}_n(H)$，然后将结果外推到极限 $n \\to \\infty$（等效于 $h \\to 0$）。这是一种对变量 $h^2$ 进行多项式外推的形式。我们构造一个表格（通常使用 Neville 算法），其中对角线项代表越来越高阶的近似。设 $T_{k,1}$ 是使用 $n_k$ 个子步的改进中点法得到的结果。外推表格为：\n    $$ T_{k,j} = T_{k,j-1} + \\frac{T_{k,j-1} - T_{k-1,j-1}}{(n_k/n_{k-j+1})^2 - 1} $$\n    表格项 $T_{k,k}$ 是真实解的一个高阶估计。\n\n3.  **自适应步长控制 (Adaptive Step-Size Control)**：BS 方法单步计算量很大。为保持效率，总步长 $H$ 会进行自适应调整，以最小的计算量满足指定的公差。在使用 $k$ 次外推成功计算从 $t$ 到 $t+H$ 的一个步长，得到解 $T_{k,k}$ 和估计误差 $\\epsilon$ 后，选择下一个步长 $H_{next}$ 以使单位步长的误差接近期望公差。一种常见的控制策略是：\n    $$ H_{next} = H \\cdot S \\cdot \\left(\\frac{\\text{tol}}{\\epsilon}\\right)^{1/(2k+1)} $$\n    其中 $S$ 是一个安全因子（例如 $0.9$），`tol` 是该步的目标公差，$2k$ 是方法的近似阶数。如果一个步长失败（误差超过公差），则用一个更小的 $H$ 重新计算。\n\n在 $xy$ 平面内运动的轨道半径（或称拉莫尔半径）由 $r_L = \\frac{v_\\perp}{\\omega_c} = \\frac{\\sqrt{v_x^2 + v_y^2}}{\\omega_c}$ 给出。解析上，对于此系统，动能和垂直速度的大小都是守恒的，这意味着 $r_L$ 是一个运动常数。然而，BS 方法作为一个通用数值积分器，并非“几何积分器”，因此不会内在地精确守恒这类量。由于截断误差和浮点误差，数值解将显示出与真实恒定半径的微小偏差。这种偏差的大小可作为衡量该方法准确性和稳定性的实用指标。我们计算最大相对偏差来测试实现。精确守恒的概念性问题通过检查这些数值计算出的偏差是否恒等于零来回答，而这通常是预料之外的。\n\n实现将包含一个驱动函数，该函数管理从一个用户指定的输出时间到下一个的自适应步进。其核心是，这个驱动函数调用一个执行单步 Bulirsch-Stoer 的函数，该函数又会使用改进的中点法和 Richardson 外推，直到满足局部误差公差。在每个输出点计算拉莫尔半径，以确定整个积分区间上的最大相对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Bulirsch-Stoer simulation for all test cases.\n    \"\"\"\n    # Physical constants (SI units)\n    Q = -1.602176634e-19  # Electron charge in Coulombs\n    M = 9.1093837015e-31   # Electron mass in kg\n    B0 = 1.0               # Magnetic field in Tesla\n\n    # Initial conditions (SI units)\n    X0 = np.array([0.0, 0.0, 0.0])\n    V0 = np.array([1.0e6, 0.0, 0.0])\n    Y0 = np.concatenate([X0, V0])\n\n    # Derived parameters\n    OMEGA_C = np.abs(Q) * B0 / M\n    T_PERIOD = 2.0 * np.pi / OMEGA_C\n\n    # ODE function: dy/dt = f(t, y)\n    q_over_m = Q / M\n    def lorentz_force_ode(t, y):\n        \"\"\"\n        Describes the motion of a charged particle in a uniform B-field.\n        y = [x, y, z, vx, vy, vz]\n        \"\"\"\n        vx, vy = y[3], y[4]\n        ax = q_over_m * B0 * vy\n        ay = -q_over_m * B0 * vx\n        return np.array([y[3], y[4], y[5], ax, ay, 0.0])\n\n    # Test cases from the problem statement.\n    # (t_final_factor, rtol, samples_per_period)\n    test_cases_spec = [\n        (1.0, 1e-10, 400),  # Test A\n        (1.0, 1e-12, 400),  # Test B\n        (1.0, 1e-8, 400),   # Test C\n        (10.0, 1e-10, 400), # Test D\n    ]\n\n    all_results = []\n    \n    # --- Bulirsch-Stoer Implementation ---\n\n    def _modified_midpoint(func, y0, t, H, n):\n        \"\"\"\n        Performs n steps of the modified midpoint method over interval H.\n        \"\"\"\n        h = H / n\n        \n        # First step\n        z0 = y0\n        k1 = func(t, z0)\n        z1 = z0 + h * k1\n        \n        # Main loop\n        z_prev = z0\n        z_curr = z1\n        t_curr = t + h\n        for _ in range(1, n):\n            k = func(t_curr, z_curr)\n            z_next = z_prev + 2.0 * h * k\n            z_prev = z_curr\n            z_curr = z_next\n            t_curr += h\n        \n        # Final smoothing step\n        k_final = func(t + H, z_curr)\n        y_final = 0.5 * (z_prev + z_curr + h * k_final)\n        \n        return y_final\n\n    def _bs_step(func, y, t, H_try, rtol, atol_abs):\n        \"\"\"\n        Performs a single adaptive Bulirsch-Stoer step.\n        \"\"\"\n        MAX_K = 8  # Maximum order of extrapolation\n        N_SEQ = [2 * (k + 1) for k in range(MAX_K)]  # Sequence of substeps: 2, 4, 6,...\n        \n        table = np.zeros((MAX_K, MAX_K, len(y)))\n        \n        for k in range(MAX_K):\n            n_k = N_SEQ[k]\n            y_est = _modified_midpoint(func, y, t, H_try, n_k)\n            table[k, 0] = y_est\n\n            # Richardson extrapolation (Neville's algorithm)\n            for j in range(1, k + 1):\n                n_k_minus_j = N_SEQ[k-j]\n                factor = (n_k / n_k_minus_j)**2\n                num = table[k, j-1] - table[k-1, j-1]\n                den = factor - 1.0\n                table[k, j] = table[k, j-1] + num / den\n\n            # Check for convergence\n            y_new = table[k, k]\n            \n            # error estimation\n            if k == 0:\n                err_est = np.inf\n            else:\n                y_prev = table[k-1, k-1]\n                err_est = np.linalg.norm(y_new - y_prev)\n\n            atol = atol_abs\n            y_scale = np.linalg.norm(y) \n            tol = atol + rtol * y_scale\n\n            if err_est < tol:\n                # Converged\n                order = 2 * (k + 1)\n                return y_new, err_est, order, True\n\n        # Did not converge\n        return y, np.inf, 0, False\n\n    def integrate_bs(func, y0, t_eval, rtol):\n        \"\"\"\n        Main Bulirsch-Stoer ODE integrator with adaptive step size.\n        \"\"\"\n        t_start = t_eval[0]\n        t_end = t_eval[-1]\n        \n        t = t_start\n        y = y0\n        \n        results = [y0]\n        \n        # Initial step size guess (heuristic)\n        H = 0.1 * (t_end - t_start)\n        \n        # Safety and step control factors\n        S = 0.9 \n        MIN_FACTOR = 0.2\n        MAX_FACTOR = 5.0\n\n        for i in range(1, len(t_eval)):\n            t_out = t_eval[i]\n            while t < t_out:\n                H_try = min(H, t_out - t)\n                \n                # Absolute tolerance for a step is relative to current state\n                atol_step = rtol * np.linalg.norm(y)\n\n                y_new, err, order, success = _bs_step(func, y, t, H_try, rtol, atol_step)\n\n                if success:\n                    # Step successful, update state and next step size\n                    t += H_try\n                    y = y_new\n                    \n                    if err == 0.0:\n                        factor = MAX_FACTOR\n                    else:\n                        factor = S * (atol_step / err)**(1.0 / (order + 1))\n                    \n                    H = H_try * min(MAX_FACTOR, max(MIN_FACTOR, factor))\n\n                else:\n                    # Step failed, reduce step size and retry\n                    H = H_try * 0.25\n        \n            results.append(y)\n\n        return np.array(results)\n\n    # Execute test cases\n    deviations = []\n    for t_factor, rtol, samples_per_period in test_cases_spec:\n        t_final = t_factor * T_PERIOD\n        num_samples = int(samples_per_period * t_factor) + 1\n        t_eval = np.linspace(0.0, t_final, num_samples)\n        \n        y_traj = integrate_bs(lorentz_force_ode, Y0, t_eval, rtol)\n\n        # Calculate Larmor radius at each sample point\n        v_perp_sq = y_traj[:, 3]**2 + y_traj[:, 4]**2\n        rL_t = np.sqrt(v_perp_sq) / OMEGA_C\n\n        # Calculate initial Larmor radius\n        rL0 = rL_t[0]\n\n        # Calculate max relative deviation\n        if rL0 == 0.0:\n            max_rel_dev = np.max(np.abs(rL_t))\n        else:\n            max_rel_dev = np.max(np.abs(rL_t - rL0) / rL0)\n        \n        deviations.append(max_rel_dev)\n\n    # Conceptual question: Does the BS method conserve the radius exactly?\n    # True if and only if all deviations are *exactly* 0.0\n    is_conserved_exactly = all(d == 0.0 for d in deviations)\n\n    final_results = deviations + [is_conserved_exactly]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2378480"}, {"introduction": "成功构建了 BS 求解器之后，探索其更深层次的性质至关重要。最后一个练习是一个概念性的思想实验：如果我们用一种特殊的“结构保持”积分器（如辛方法 Störmer-Verlet）作为 BS 框架的基础，会发生什么？这个问题将引导你深入审视外推过程本身，揭示出尽管它能显著提高局部精度，但由于其线性组合的本质，可能会破坏基础积分器在长期模拟中所依赖的几何特性（如辛性），从而影响能量守恒等长期行为 [@problem_id:2378529]。", "problem": "一个哈密顿初值问题的广义位置 $q \\in \\mathbb{R}^{d}$ 和动量 $p \\in \\mathbb{R}^{d}$ 由哈密顿方程\n$$\n\\frac{dq}{dt}=\\frac{\\partial H}{\\partial p}(q,p),\\qquad \\frac{dp}{dt}=-\\frac{\\partial H}{\\partial q}(q,p),\n$$\n所支配，其中 $H(q,p)$ 是一个光滑的哈密顿量。一个步长为 $h$ 的单步数值方法定义了一个映射 $\\Phi_{h}:(q^{n},p^{n})\\mapsto(q^{n+1},p^{n+1})$。如果该方法的雅可比矩阵 $D\\Phi_{h}(z)$ 对所有 $z=(q,p)$ 都满足 $D\\Phi_{h}(z)^{\\mathsf{T}}\\,J\\,D\\Phi_{h}(z)=J$（其中 $J$ 是典范辛矩阵），则称该方法为辛方法；如果满足 $\\Phi_{-h}=\\Phi_{h}^{-1}$，则称该方法为时间可逆（对称）方法。\n\nBulirsch–Stoer 外推框架通过应用一个基础单步方法，以 $n$ 个大小为 $h=H/n$ 的相等子步长（对于 $n\\in\\{n_{1},n_{2},\\dots\\}$）来构建一个在大小为 $H$ 的宏步长上的一系列近似值，然后使用以 $h$ 的幂进行的 Richardson 外推来加速子步长解在宏步长上向精确解的收敛。经典的 Gragg–Bulirsch–Stoer 方法利用了这样一个事实：对于一个时间可逆的基础积分器，其局部误差允许一个关于 $h$ 的偶次幂展开，这使得在 $h^{2}$ 上的外推特别有效。\n\n现在假设，您使用 Störmer–Verlet 方法代替修正中点规则作为 Bulirsch–Stoer 外推中的基础积分器，并保持外推框架的所有其他方面不变。考虑一个光滑、有界的哈密顿系统（如谐振子 $H(q,p)=\\tfrac{1}{2}\\,(p^{2}+q^{2})$）的长时间积分，使用固定的宏步长 $H>0$ 和一个 Bulirsch–Stoer 子步长计数序列 $n$，在每个宏步长上产生一个高阶外推终点。\n\n下列哪个陈述是正确的？\n\nA. 因为 Störmer–Verlet 方法是时间可逆的，所以子步长终点误差对 $h$ 的依赖性允许一个 $h^{2k}$ 的偶次幂展开，因此在 $h^{2}$ 上的 Richardson 外推仍然有效，并且通常在减小局部误差方面非常高效。\n\nB. 尽管每个 Störmer–Verlet 子步长以及它们的任何有限复合都是辛的，但通过不同 $h$ 计算出的结果的线性组合所构建的最终外推终点，通常不是任何辛映射的像；因此，由外推的 Bulirsch–Stoer 推进定义的整体单步映射不是辛的，Störmer–Verlet 方法典型的长时间近似能量守恒性质可能会被破坏。\n\nC. 基于 Störmer–Verlet 构建的外推 Bulirsch–Stoer 格式对于 Richardson 外推系数的任何选择都是辛的，因为辛映射的复合是辛的，而外推是一种伪装的复合；因此，长时间能量行为得以保持并随阶数提高而改善。\n\nD. 使用辛基础积分器会使 Bulirsch–Stoer 所假设的偶次幂误差结构失效；误差包含 $h$ 的主导奇次幂，因此外推停滞不前，无法系统地提高阶数。\n\nE. 即使对于谐振子，也应该预期，在固定的宏步长 $H$ 和相当的短期精度下，外推方法可能会在多个周期内表现出缓慢的长期能量漂移，而这种漂移在使用普通 Störmer–Verlet 方法时不存在（或在参数上小得多），这反映了精确守恒的修正哈密顿量的丢失。\n\n选择所有适用的选项。", "solution": "该问题陈述具有科学依据，提法恰当，且内部一致。它描述了几何数值积分领域中的一个有效情景。我将进行全面分析。\n\n问题要求评估使用 Störmer–Verlet 积分器作为其基础方法来求解哈密顿系统的 Bulirsch–Stoer (BS) 外推方法的性质。设步长为 $h$ 的 Störmer–Verlet 方法的单步映射为 $\\Phi_h$。几何数值积分中的一个基本结果是，对于可分离的哈密顿量 $H(q,p) = T(p) + V(q)$，Störmer–Verlet 方法拥有两个关键性质：\n1.  **时间可逆性（或对称性）：** 映射满足 $\\Phi_{-h} = \\Phi_h^{-1}$。这意味着使用负步长应用该方法等同于使用正步长反转该映射。\n2.  **辛性：** 对所有 $(q,p)$，该映射的雅可比矩阵 $D\\Phi_h$ 是一个辛矩阵。也就是说，$(D\\Phi_h)^{\\mathsf{T}} J (D\\Phi_h) = J$，其中 $J = \\begin{pmatrix} 0 & I \\\\ -I & 0 \\end{pmatrix}$ 是典范辛矩阵。\n\nBulirsch–Stoer 框架在一个大小为 $H$ 的宏步长上操作。它通过使用变动数量的子步长 $n$ 来应用基础方法 $\\Phi_h$，从而计算在时间 $H$ 处解的一系列近似值。对于序列 $\\{n_1, n_2, \\ldots\\}$ 中的每个 $n$，子步长大小为 $h = H/n$，近似值为 $Y(h) = (\\Phi_h)^n(y_0)$，其中 $y_0 = (q(0), p(0))$ 是初始条件。\n\n经典的 Gragg–Bulirsch–Stoer 方法的有效性依赖于基础积分器是对称的。Gragg 的一个定理指出，对于任何对称的单步方法，在固定区间 $H$ 上，近似值 $Y(h)$ 的误差允许一个仅包含子步长大小 $h$ 的偶次幂的渐近展开：\n$$ Y(h) = y(H) + c_1 h^2 + c_2 h^4 + c_3 h^6 + \\dots $$\n其中 $y(H)$ 是精确解，系数 $c_k$ 依赖于 $H$ 但不依赖于 $h$。这个偶次幂展开允许以 $h^2$ 的幂进行 Richardson 外推，这是非常高效的。\n\n最终的外推结果，我们称之为 $Y_{ext}$，是通过将一个关于 $h^2$ 的多项式拟合到近似值集合 $\\{Y(h_1), Y(h_2), \\dots\\}$（其中 $h_i = H/n_i$），并计算该多项式在 $h^2 = 0$ 处的值得到的。这个过程导致 $Y_{ext}$ 是基础近似值的线性组合：\n$$ Y_{ext} = \\sum_i \\gamma_i Y(h_i) = \\sum_i \\gamma_i (\\Phi_{h_i})^{n_i}(y_0) $$\n系数 $\\gamma_i$ 由外推方案确定，并且它们满足 $\\sum_i \\gamma_i = 1$。因此，外推方法单个宏步长的整体单步映射是 $\\mathcal{F}_H: y_0 \\mapsto Y_{ext}$。\n\n现在，我们逐一分析每个陈述。\n\n**A. 因为 Störmer–Verlet 方法是时间可逆的，所以子步长终点误差对 $h$ 的依赖性允许一个 $h^{2k}$ 的偶次幂展开，因此在 $h^{2}$ 上的 Richardson 外推仍然有效，并且通常在减小局部误差方面非常高效。**\n这个陈述是正确的。Störmer–Verlet 方法确实是时间可逆的。正如 Gragg 定理所确立的，这种对称性正是保证存在关于步长 $h$ 的偶次幂的渐近误差展开的性质。这种结构是 GBS 方法的基础。因此，使用 Störmer–Verlet 作为基础积分器，允许在 $h^2$ 上进行有效且高效的 Richardson 外推，以系统地提高宏步长上局部解的精度阶数。\n**结论：正确。**\n\n**B. 尽管每个 Störmer–Verlet 子步长以及它们的任何有限复合都是辛的，但通过不同 $h$ 计算出的结果的线性组合所构建的最终外推终点，通常不是任何辛映射的像；因此，由外推的 Bulirsch–Stoer 推进定义的整体单步映射不是辛的，Störmer–Verlet 方法典型的长时间近似能量守恒性质可能会被破坏。**\n这个陈述是正确的。每个映射 $\\Phi_h$ 都是辛的。任意数量辛映射的复合也是一个辛映射，因此每个近似值 $Y(h_i) = (\\Phi_{h_i})^{n_i}(y_0)$ 都是将一个辛映射应用于初始数据的结果。然而，外推结果 $Y_{ext}$ 是这些结果的线性组合。辛映射的集合在线性组合下是不封闭的。外推方法的所得单步映射 $\\mathcal{F}_H(y_0) = \\sum_i \\gamma_i (\\Phi_{h_i})^{n_i}(y_0)$ 通常本身不是一个辛映射。辛性的丧失意味着该方法不再精确守恒一个附近的修正哈密顿量。对于长时间积分，这通常会导致基础辛积分器优异的能量守恒性质的退化，可能会引入长期漂移。\n**结论：正确。**\n\n**C. 基于 Störmer–Verlet 构建的外推 Bulirsch–Stoer 格式对于 Richardson 外推系数的任何选择都是辛的，因为辛映射的复合是辛的，而外推是一种伪装的复合；因此，长时间能量行为得以保持并随阶数提高而改善。**\n这个陈述是错误的。它从根本上误解了外推的数学本质。外推是线性组合，而不是映射的复合。正如选项 B 的分析中所解释的，辛映射的线性组合通常不是辛的。要使该方案是辛的，其雅可比矩阵 $D\\mathcal{F}_H = \\sum_i \\gamma_i D((\\Phi_{h_i})^{n_i})$ 必须对任何初始条件都是一个辛矩阵。辛矩阵的线性组合通常不是辛的。“外推是一种伪装的复合”这个前提是错误的，因此其结论，即该方案是辛的并且保持长时间能量行为，也是错误的。\n**结论：错误。**\n\n**D. 使用辛基础积分器会使 Bulirsch–Stoer 所假设的偶次幂误差结构失效；误差包含 $h$ 的主导奇次幂，因此外推停滞不前，无法系统地提高阶数。**\n这个陈述是错误的。保证偶次幂误差展开的性质是时间可逆性（对称性），而不是非辛性。Störmer–Verlet 方法既是辛的，也是时间可逆的。这两个性质是独立的，不是相互排斥的。它的时间可逆性确保了偶次幂误差结构，使其成为在 $h^2$ 上进行外推的完美候选者。不存在矛盾，外推也不会停滞不前；它将如预期那样执行，提高精度阶数。\n**结论：错误。**\n\n**E. 即使对于谐振子，也应该预期，在固定的宏步长 $H$ 和相当的短期精度下，外推方法可能会在多个周期内表现出缓慢的长期能量漂移，而这种漂移在使用普通 Störmer–Verlet 方法时不存在（或在参数上小得多），这反映了精确守恒的修正哈密顿量的丢失。**\n这个陈述是正确的。这是外推方法非辛这一事实的直接和实际后果，正如在选项 B 中所确立的。纯 Störmer–Verlet 方法是辛的，它精确地守恒一个修正的哈密顿量，这意味着原始哈密顿量的误差在指数级长的时间内保持有界；不存在长期的能量漂移。外推方法是非辛的，不拥有一个守恒的修正哈密顿量。虽然它是一个高阶方法，导致每步的能量误差非常小，从而漂移非常缓慢，但预计长期漂移仍会在许多宏步长上累积。这种长时间行为上的质的差异——有界能量误差与能量漂移——是辛积分器和非辛积分器之间的一个标志性区别。该陈述准确地描述了这一现象及其根本原因。\n**结论：正确。**", "answer": "$$\\boxed{ABE}$$", "id": "2378529"}]}