{"hands_on_practices": [{"introduction": "在使用打靶法求解边值问题（BVP）之前，我们必须首先正确地重构问题。这包括将二阶常微分方程（ODE）转换为一阶常微分方程组，并定义一个“残差”函数，该函数的根对应于正确的初始条件。这项练习 [@problem_id:2220758] 将巩固你对这一基本步骤的理解，确保你能为数值求解器正确地设置问题。", "problem": "打靶法（shooting method）是一种通过将边值问题（Boundary Value Problem, BVP）简化为初值问题（Initial Value Problem, IVP）来求解的数值技术。考虑以下构成一个BVP的二阶常微分方程：\n$$y''(x) = 6y(x) - \\cos(x)$$\n其边界条件为 $y(0) = 3$ 和 $y(\\pi/2) = -1$。\n\n为了应用打靶法，我们通过引入一个参数 $s$ 来将此BVP转换为IVP，该参数表示未知的初始斜率，即 $y'(0) = s$。这个IVP的解（可以记作 $y(x, s)$ 以强调其对 $s$ 的依赖性）必须在 $x = \\pi/2$ 处满足第二个边界条件。\n\n为了进行数值计算，使用代换 $u_1(x) = y(x)$ 和 $u_2(x) = y'(x)$ 将二阶IVP转换为一个含两个一阶IVP的系统。目标是找到 $s$ 的值，使得解 $y(\\pi/2, s)$ 与所要求的边界值相匹配。这通常通过找到一个函数 $F(s) = 0$ 的根来实现。\n\n以下哪个选项正确定义了通过打靶法求解给定BVP所必须使用的一阶IVP系统及相应的标量函数 $F(s)$？设 $u_1(x, s)$ 是基于参数 $s$ 的 $y(x, s)$ 的解。\n\nA. 系统：$u_1' = u_2, u_2' = 6u_1 - \\cos(x)$，初始条件为 $u_1(0) = 3, u_2(0) = s$。\n   求根所用的函数：$F(s) = u_1(\\pi/2, s) + 1$。\n\nB. 系统：$u_1' = u_2, u_2' = 6u_1 - \\cos(x)$，初始条件为 $u_1(0) = 3, u_2(0) = s$。\n   求根所用的函数：$F(s) = u_1(\\pi/2, s) - 3$。\n\nC. 系统：$u_1' = u_2, u_2' = 6u_2 - \\cos(x)$，初始条件为 $u_1(0) = 3, u_2(0) = s$。\n   求根所用的函数：$F(s) = u_1(\\pi/2, s) + 1$。\n\nD. 系统：$u_1' = u_2, u_2' = 6u_1 - \\cos(x)$，初始条件为 $u_1(0) = s, u_2(0) = 3$。\n   求根所用的函数：$F(s) = u_1(\\pi/2, s) + 1$。\n\nE. 系统：$u_1' = u_2, u_2' = 6u_1 - \\cos(x)$，初始条件为 $u_1(0) = 3, u_2(0) = -1$。\n   求根所用的函数：$F(s) = u_1(\\pi/2, s) - s$。", "solution": "我们给定的边值问题是 $y''(x)=6y(x)-\\cos(x)$，其边界条件为 $y(0)=3$ 和 $y\\!\\left(\\frac{\\pi}{2}\\right)=-1$。在打靶法中，我们通过设 $y'(0)=s$ 引入未知的初始斜率 $s$，并求解由 $s$ 参数化的相关初值问题。\n\n为了将这个二阶ODE转换为一阶系统，定义 $u_{1}(x)=y(x)$ 和 $u_{2}(x)=y'(x)$。然后通过微分，我们得到\n$$\nu_{1}'(x)=u_{2}(x), \\qquad u_{2}'(x)=y''(x)=6y(x)-\\cos(x)=6u_{1}(x)-\\cos(x).\n$$\n在 $x=0$ 处的初始条件变为\n$$\nu_{1}(0)=y(0)=3, \\qquad u_{2}(0)=y'(0)=s.\n$$\n设 $u_{1}(x,s)$ 表示在给定 $s$ 下对应于 $y(x,s)$ 的解分量。正确的 $s$ 值是通过施加在 $x=\\frac{\\pi}{2}$ 处的边界条件来确定的，即 $y\\!\\left(\\frac{\\pi}{2},s\\right)=-1$。定义一个衡量右边界差异的标量函数为\n$$\nF(s)=u_{1}\\!\\left(\\frac{\\pi}{2},s\\right)-\\left(-1\\right)=u_{1}\\!\\left(\\frac{\\pi}{2},s\\right)+1.\n$$\n打靶法随后寻找使 $F(s)=0$ 的 $s$ 值。这与选项A中描述的系统和函数完全匹配，而其他选项均未能同时正确地表述该系统和边界残差。", "answer": "$$\\boxed{A}$$", "id": "2220758"}, {"introduction": "一旦边值问题被构造成一个依赖于未知初始斜率 $s$ 的初值问题（IVP），任务就变成了一个寻根问题。我们需要找到 $s$ 的值，使得解能够“击中”另一端的边界条件。这个练习 [@problem_id:2220751] 将在一个具体的物理热传导问题背景下，引导你完成割线法的一次迭代，让你亲身体会如何调整“射击”以找到正确的弹道。", "problem": "一个长度为 $L=2.0$ m 的一维翅片安装在热表面上，用于向周围环境散热。沿翅片的稳态温度分布 $T(x)$ 遵循以下二阶常微分方程：\n$$ T''(x) = \\gamma (T(x) - T_{env}) $$\n其中 $x$ 是从翅片根部起算的距离，单位为米。物理参数如下：\n-   传热系数: $\\gamma = 0.09 \\text{ m}^{-2}$\n-   环境温度: $T_{env} = 20.0$ °C\n-   根部温度: $T(0) = 150.0$ °C\n-   尖端温度: $T(2.0) = 50.0$ °C\n\n你的任务是应用打靶法来为初始温度梯度 $s = T'(0)$ 找到一个更好的近似值。你将采用割线法作为求根算法。给定梯度的两个初始猜测值 $s_0 = -10.0$ °C/m 和 $s_1 = -30.0$ °C/m，计算下一个近似值 $s_2$。\n\n为了求出在给定初始梯度下翅片末端的温度，你应该使用所得初值问题的解析解。\n\n以 °C/m 为单位表示你的最终答案。将你的答案四舍五入到三位有效数字。", "solution": "我们通过标准的打靶法将边值问题转化为一个初值问题。定义过余温度 $\\theta(x) = T(x) - T_{env}$。控制方程和初始条件变为\n$$\n\\theta''(x) = \\gamma\\,\\theta(x), \\quad \\theta(0) = T(0) - T_{env}, \\quad \\theta'(0) = s,\n$$\n其中 $\\gamma>0$。令 $\\lambda = \\sqrt{\\gamma}$。其通解为\n$$\n\\theta(x) = C \\cosh(\\lambda x) + D \\sinh(\\lambda x).\n$$\n应用 $x=0$ 处的初始条件，得到 $C = \\theta(0) = T(0) - T_{env}$ 以及 $\\theta'(x) = \\lambda\\big(C \\sinh(\\lambda x) + D \\cosh(\\lambda x)\\big)$，所以 $\\theta'(0) = \\lambda D = s$，因此 $D = \\frac{s}{\\lambda}$。因此，\n$$\nT(x;s) = T_{env} + \\theta(x) = T_{env} + \\big(T(0) - T_{env}\\big)\\cosh(\\lambda x) + \\frac{s}{\\lambda}\\sinh(\\lambda x).\n$$\n对于 $x=L$ 处的尖端边界条件，其残差为\n$$\nf(s) = T(L;s) - T(L) = \\big[T_{env} + \\big(T(0) - T_{env}\\big)\\cosh(\\lambda L) + \\tfrac{s}{\\lambda}\\sinh(\\lambda L)\\big] - T(L).\n$$\n根据给定数据 $L=2.0$, $\\gamma=0.09$, $T_{env}=20.0$, $T(0)=150.0$, $T(L)=50.0$，我们有 $\\lambda=\\sqrt{\\gamma}=0.3$ 以及\n$$\nf(s) = -30 + 130\\,\\cosh(0.6) + \\frac{s}{0.3}\\,\\sinh(0.6).\n$$\n使用 $\\cosh(0.6) = \\frac{\\exp(0.6)+\\exp(-0.6)}{2} \\approx 1.185465218242$ 和 $\\sinh(0.6) = \\frac{\\exp(0.6)-\\exp(-0.6)}{2} \\approx 0.636653582148$，这可以简化为以下线性形式\n$$\nf(s) \\approx 124.11047837146 + 2.12217860716\\,s.\n$$\n在给定的猜测值 $s_{0}=-10.0$ 和 $s_{1}=-30.0$ 处求值：\n$$\nf(s_{0}) \\approx 124.11047837146 + 2.12217860716(-10.0) = 102.88869229986,\n$$\n$$\nf(s_{1}) \\approx 124.11047837146 + 2.12217860716(-30.0) = 60.44512015666.\n$$\n应用割线法求下一个迭代值：\n$$\ns_{2} = s_{1} - f(s_{1})\\,\\frac{s_{1}-s_{0}}{f(s_{1}) - f(s_{0})}\n= -30.0 - 60.44512015666\\,\\frac{-20.0}{60.44512015666 - 102.88869229986}.\n$$\n计算分母 $60.44512015666 - 102.88869229986 = -42.44357214320$，所以\n$$\ns_{2} \\approx -30.0 - \\frac{-1208.9024031332}{-42.44357214320} \\approx -58.4825791536.\n$$\n因为 $f(s)$ 是关于 $s$ 的线性函数，所以这一步割线法迭代得到了打靶残差的精确根。四舍五入到三位有效数字，得到以所要求单位表示的结果为 $-58.5$。", "answer": "$$\\boxed{-58.5}$$", "id": "2220751"}, {"introduction": "虽然像割线法这样的简单方法是有效的，但对于复杂的非线性问题，我们需要更强大的技术。牛顿法提供了更快的收敛速度，但它要求我们能够计算残差函数相对于初始斜率 $s$ 的导数。通过推导并求解一组被称为“敏感性方程”的附加常微分方程，我们可以求得这个导数。这项高级练习 [@problem_id:2437831] 将指导你设置并实现这种稳健的牛顿打靶法，这是一种因其高效和强大而在科学计算领域广泛应用的技术。", "problem": "考虑一个非线性的、稳态的、一维传导模型，该模型写作闭区间 $[0,1]$ 上的一个常微分方程（ODE）边值问题（BVP）：\n$$\ny''(x) + \\lambda \\sinh\\!\\big(y(x)\\big) = 0,\\quad x \\in [0,1],\n$$\n边界条件为\n$$\ny(0) = \\alpha,\\qquad y(1) = \\beta,\n$$\n其中 $\\lambda$、$\\alpha$ 和 $\\beta$ 为给定的实常数，$\\sinh(\\cdot)$ 是双曲正弦函数。所有量均为无量纲（无物理单位）。打靶法将该 BVP 重构为一个由未知初始斜率 $s = y'(0)$ 参数化的初值问题（IVP）：\n$$\ny'(x) = v(x),\\qquad v'(x) = -\\lambda \\sinh\\!\\big(y(x)\\big),\\qquad y(0)=\\alpha,\\quad v(0)=s.\n$$\n定义终端失配函数\n$$\n\\Phi(s) := y(1;s) - \\beta,\n$$\n其中 $y(1;s)$ 表示使用参数 $s$ 积分 IVP 在 $x=1$ 处得到的状态 $y$。数值目标是找到 $s^\\star$，使得 $\\Phi(s^\\star)=0$。\n\n任务：\n- 从初值问题和打靶法公式的定义出发，仅使用标准变分法和链式法则，推导由 $z(x) := \\partial y(x;s)/\\partial s$ 满足的线性敏感性（变分）ODE 及其在 $x=0$ 处的初始条件。解释为何该敏感性使得能够使用 Newton 法来更新 $s$。\n- 实现一个鲁棒的 Newton 迭代法用于求解 $\\Phi(s)=0$ 的根，该方法使用敏感性方程来评估导数 $\\Phi'(s)$。在每个 Newton 步中，将耦合的状态-敏感性 IVP 从 $x=0$ 积分到 $x=1$，以获得 $y(1;s)$ 和 $z(1;s) = \\partial y(1;s)/\\partial s$。使用这些值计算 $s$ 的 Newton 更新量。如果需要，您可以使用简单的回溯线搜索来提高魯棒性。\n- 使用一个具有严格局部误差控制的确定性自适应 ODE 积分器来积分耦合的 ODE 系统。确保绝对和相对容差足够小，以将解和敏感性解析到终端残差 $|\\Phi(s)|$ 至少达到 $10^{-10}$ 的精度。\n- 使用以下参数集 $(\\lambda,\\alpha,\\beta)$ 的测试套件：\n  1. $(\\lambda,\\alpha,\\beta)=(5.0,0.0,0.0)$\n  2. $(\\lambda,\\alpha,\\beta)=(1.0,0.0,1.0)$\n  3. $(\\lambda,\\alpha,\\beta)=(10.0,0.0,0.2)$\n  4. $(\\lambda,\\alpha,\\beta)=(0.01,0.0,0.5)$\n  5. $(\\lambda,\\alpha,\\beta)=(2.5,0.2,-0.3)$\n- 对每个参数集，计算经 Newton 法收敛的初始斜率 $s^\\star$，使得 $|\\Phi(s^\\star)| \\le 10^{-10}$。\n\n最终输出格式：\n- 您的程序必须产生单行输出，其中包含一个 Python 风格的浮点数列表，每个测试用例一个数字，顺序与测试套件相同。每个数字必须是相应的收敛初始斜率 $s^\\star$，格式化为小数点后恰好 $8$ 位。例如，打印字符串 $[s\\_1,s\\_2,s\\_3,s\\_4,s\\_5]$，其中每个 $s\\_k$ 四舍五入到 $8$ 位小数，并且不含任何额外的空白或文本。", "solution": "所述问题是一个在数学和计算上都良定义的任务。它是数学物理领域的一个标准非线性边值问题（BVP），其通过打靶法的重构是一种典范技术。该问题是自洽的、有科学依据的，并且其参数已指定，允许在给定初始猜测的情况下找到唯一的数值解。因此，该问题被认为是有效的。解法从第一性原理出发。\n\n该 BVP 由以下二阶常微分方程（ODE）定义：\n$$\ny''(x) + \\lambda \\sinh(y(x)) = 0, \\quad x \\in [0,1]\n$$\n其狄利克雷边界条件为：\n$$\ny(0) = \\alpha, \\quad y(1) = \\beta\n$$\n\n打靶法将此 BVP 转换为一个初值问题（IVP）。我们引入一个状态向量，其分量为 $y(x)$ 及其导数 $v(x) = y'(x)$。该二阶 ODE 被重写为一个由两个一阶 ODE 组成的系统：\n$$\n\\begin{cases}\ny'(x) = v(x) \\\\\nv'(x) = -\\lambda \\sinh(y(x))\n\\end{cases}\n$$\n在 $x=0$ 处的边界条件 $y(0)=\\alpha$ 用作初始条件。第二个初始条件 $v(0)=y'(0)$ 是未知的。我们将这个未知的初始斜率指定为一个参数 $s$：\n$$\ny(0) = \\alpha, \\quad v(0) = s\n$$\n此 IVP 的解取决于 $s$ 的选择，我们将其表示为 $y(x;s)$。打靶法的目标是找到参数的特定值 $s^\\star$，使得解在 $x=1$ 处满足第二个边界条件：\n$$\ny(1; s^\\star) = \\beta\n$$\n这是一个关于终端失配函数 $\\Phi(s)$ 的求根问题：\n$$\n\\Phi(s) := y(1;s) - \\beta = 0\n$$\n\n为了使用 Newton 法求解 $\\Phi(s)=0$，我们需要 $\\Phi(s)$ 相对于 $s$ 的导数。Newton 迭代由以下公式给出：\n$$\ns_{k+1} = s_k - \\frac{\\Phi(s_k)}{\\Phi'(s_k)}\n$$\n导数 $\\Phi'(s)$ 计算如下：\n$$\n\\Phi'(s) = \\frac{d}{ds} \\left( y(1;s) - \\beta \\right) = \\frac{\\partial y(1;s)}{\\partial s}\n$$\n为了求这个偏导数，我们推导敏感性方程。设 $z(x;s) = \\frac{\\partial y(x;s)}{\\partial s}$ 和 $w(x;s) = \\frac{\\partial v(x;s)}{\\partial s}$。我们将 IVP 系统对参数 $s$求导，应用链式法则，并注意 $x$ 和 $s$ 的微分顺序可以交换：\n$$\n\\frac{\\partial}{\\partial s} (y') = \\frac{d}{dx}\\left(\\frac{\\partial y}{\\partial s}\\right) = z'(x)\n$$\n由第一个 ODE，$y' = v$，我们有：\n$$\nz'(x) = \\frac{\\partial v(x;s)}{\\partial s} = w(x)\n$$\n由第二个 ODE，$v' = -\\lambda \\sinh(y)$，我们有：\n$$\n\\frac{\\partial}{\\partial s} (v') = \\frac{d}{dx}\\left(\\frac{\\partial v}{\\partial s}\\right) = w'(x)\n$$\n$$\nw'(x) = \\frac{\\partial}{\\partial s} \\left( -\\lambda \\sinh(y(x;s)) \\right) = -\\lambda \\cosh(y(x;s)) \\cdot \\frac{\\partial y(x;s)}{\\partial s} = -\\lambda \\cosh(y(x;s)) z(x)\n$$\n这就产生了一个关于敏感度 $z(x)$ 和 $w(x)$ 的线性 ODE 系统：\n$$\n\\begin{cases}\nz'(x) = w(x) \\\\\nw'(x) = -\\lambda \\cosh(y(x;s)) z(x)\n\\end{cases}\n$$\n这等价于 $z(x)$ 的二阶线性变分方程：\n$$\nz''(x) + \\lambda \\cosh(y(x;s)) z(x) = 0\n$$\n该系统的初始条件通过对原始初始条件关于 $s$ 求导得到：\n$$\nz(0) = \\frac{\\partial y(0)}{\\partial s} = \\frac{\\partial \\alpha}{\\partial s} = 0 \\quad (\\text{因为 } \\alpha \\text{ 是一个常数})\n$$\n$$\nw(0) = \\frac{\\partial v(0)}{\\partial s} = \\frac{\\partial s}{\\partial s} = 1\n$$\nNewton 法所需的导数是 $\\Phi'(s) = z(1;s)$。为了找到这个值，我们必须求解一个由四个一阶 ODE 组成的耦合系统。设状态向量为 $\\mathbf{u}(x) = [y(x), v(x), z(x), w(x)]^T$。该耦合系统是：\n$$\n\\mathbf{u}'(x) = \\frac{d}{dx} \\begin{bmatrix} y \\\\ v \\\\ z \\\\ w \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\lambda \\sinh(y) \\\\ w \\\\ -\\lambda \\cosh(y) z \\end{bmatrix}\n$$\n对于给定的试验斜率 $s_k$，在 $x=0$ 处的初始条件为：\n$$\n\\mathbf{u}(0) = [\\alpha, s_k, 0, 1]^T\n$$\n基于 Newton 法的打靶法算法如下：\n1.  为斜率选择一个初始猜测值 $s_0$。\n2.  对于 $k=0, 1, 2, \\dots$ 直到收敛：\n    a. 定义初始条件向量 $\\mathbf{u}(0) = [\\alpha, s_k, 0, 1]^T$。\n    b. 使用高精度自适应 ODE 求解器将耦合的四维 ODE 系统从 $x=0$ 积分到 $x=1$。\n    c. 从 $x=1$ 处的数值解中，提取终端状态 $\\mathbf{u}(1) = [y(1;s_k), v(1;s_k), z(1;s_k), w(1;s_k)]^T$。\n    d. 评估失配函数：$\\Phi(s_k) = y(1;s_k) - \\beta$。\n    e. 检查收敛性：如果 $|\\Phi(s_k)|$ 低于指定的容差（例如 $10^{-10}$），则迭代完成，且 $s^\\star = s_k$。\n    f. 评估导数：$\\Phi'(s_k) = z(1;s_k)$。\n    g. 计算 Newton 更新量：$\\Delta s = - \\Phi(s_k) / \\Phi'(s_k)$。\n    h. 为增强鲁棒性，可使用回溯线搜索。更新以 $s_{k+1} = s_k + \\gamma \\Delta s$ 的形式应用，其中 $\\gamma \\in (0, 1]$ 从 $\\gamma=1$开始缩减，直到观察到残差 $|\\Phi(s)|$ 有充分下降。\n    i. 更新斜率：$s_{k+1} = s_k + \\gamma \\Delta s$。\n\n对于给定的测试用例，初始猜测值 $s_0 = \\beta - \\alpha$ 是一个合理的选择，因为它对应于边界之间线性插值的斜率。然而，对于对称情况 $(\\lambda=5.0, \\alpha=0.0, \\beta=0.0)$，此猜测值为 $s_0=0$。这将导致平凡解 $y(x)=0$，这确实是一个有效的解，因为 $\\Phi(0) = 0 - 0 = 0$。为了找到非平凡解，必须使用一个非零的初始猜测值，例如 $s_0=1.0$。对于所有其他指定情况，$s_0 = \\beta - \\alpha$ 是一个合适的非零猜测值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear BVP using the Newton-shooting method with sensitivity analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, alpha, beta)\n        (5.0, 0.0, 0.0),\n        (1.0, 0.0, 1.0),\n        (10.0, 0.0, 0.2),\n        (0.01, 0.0, 0.5),\n        (2.5, 0.2, -0.3),\n    ]\n\n    results = []\n\n    def solve_bvp_for_case(lambda_val, alpha, beta):\n        \"\"\"\n        Computes the converged initial slope s* for a single set of parameters.\n        \"\"\"\n        \n        def coupled_ode(t, u, lambda_p):\n            \"\"\"\n            Defines the coupled state-sensitivity ODE system.\n            u = [y, v, z, w]\n            y' = v\n            v' = -lambda * sinh(y)\n            z' = w\n            w' = -lambda * cosh(y) * z\n            \"\"\"\n            y, v, z, w = u\n            y_dot = v\n            v_dot = -lambda_p * np.sinh(y)\n            z_dot = w\n            w_dot = -lambda_p * np.cosh(y) * z\n            return [y_dot, v_dot, z_dot, w_dot]\n\n        # Initial guess for the slope s = y'(0)\n        if lambda_val == 5.0 and alpha == 0.0 and beta == 0.0:\n            # For the symmetric case, s=0 gives the trivial solution y=0.\n            # To find a non-trivial solution, a non-zero guess is required.\n            s = 1.0\n        else:\n            # For other cases, the slope of the line connecting boundaries is a reasonable guess.\n            s = beta - alpha\n            \n        max_iter = 30\n        tolerance = 1e-10\n        ode_atol = 1e-13\n        ode_rtol = 1e-13\n\n        for i in range(max_iter):\n            # 1. Integrate the coupled system for the current guess s\n            u0 = np.array([alpha, s, 0.0, 1.0])\n            sol = solve_ivp(\n                fun=coupled_ode,\n                t_span=[0, 1],\n                y0=u0,\n                method='DOP853',\n                args=(lambda_val,),\n                atol=ode_atol,\n                rtol=ode_rtol\n            )\n            \n            # Check for integration failures\n            if sol.status != 0:\n                # Handle integration failure, e.g., by stopping.\n                # In a robust implementation, one might try another guess or method.\n                break\n\n            u1 = sol.y[:, -1]\n            y1, _, z1, _ = u1\n\n            # 2. Evaluate the residual (mismatch) and check for convergence\n            phi = y1 - beta\n            if abs(phi) < tolerance:\n                break\n                \n            # 3. Evaluate the derivative of the mismatch function\n            phi_prime = z1\n            if abs(phi_prime) < 1e-14:\n                # Derivative is too small; Newton's method may fail or diverge.\n                break\n\n            # 4. Compute the Newton update step\n            ds = -phi / phi_prime\n\n            # 5. Apply step with a simple backtracking line search for robustness\n            gamma = 1.0\n            max_backtrack = 10\n            s_next = s + gamma * ds\n            \n            for j in range(max_backtrack):\n                u0_next = np.array([alpha, s_next, 0.0, 1.0])\n                sol_next = solve_ivp(\n                    fun=coupled_ode,\n                    t_span=[0, 1],\n                    y0=u0_next,\n                    method='DOP853',\n                    args=(lambda_val,),\n                    atol=ode_atol,\n                    rtol=ode_rtol,\n                )\n                \n                if sol_next.status != 0:\n                     # If integration fails during line search, reduce step size\n                    gamma *= 0.5\n                    s_next = s + gamma * ds\n                    continue\n\n                y1_next = sol_next.y[0, -1]\n                phi_next = y1_next - beta\n                \n                if abs(phi_next) < abs(phi):\n                    # Step accepted, break line search\n                    break\n                else:\n                    # Reduce step size\n                    gamma *= 0.5\n                    s_next = s + gamma * ds\n            \n            s = s_next\n            \n        return s\n\n    for case in test_cases:\n        lambda_val, alpha, beta = case\n        s_star = solve_bvp_for_case(lambda_val, alpha, beta)\n        results.append(s_star)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2437831"}]}