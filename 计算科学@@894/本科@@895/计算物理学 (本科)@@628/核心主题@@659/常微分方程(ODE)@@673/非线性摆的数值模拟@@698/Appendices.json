{"hands_on_practices": [{"introduction": "在进行任何数值模拟之前，验证我们所使用工具的可靠性是至关重要的一步。这个练习将指导你通过一个基本但极其重要的实践来做到这一点：数值地确定一个积分器的收敛阶。我们将以广泛应用的四阶龙格-库塔方法（RK4）为例，通过系统地减小时间步长 $h$ 并观察全局误差的变化，来经验性地验证其理论上的四阶精度 [@problem_id:2420941]。掌握这种方法将为你评估和选择适合未来任何计算任务的数值方法奠定坚实的基础。", "problem": "考虑一个长度为 $L$ 的非线性单摆，在大小为 $g$ 的匀强引力场中运动，其运动由以下二阶常微分方程描述：$ \\dfrac{\\mathrm{d}^2 \\theta}{\\mathrm{d} t^2} + \\dfrac{g}{L} \\sin(\\theta) = 0 $，其中 $\\theta(t)$ 是以弧度为单位的角位移，$t$ 是以秒为单位的时间。定义状态向量 $ \\mathbf{y}(t) = \\begin{bmatrix} \\theta(t) \\\\ \\omega(t) \\end{bmatrix} $，其中 $ \\omega(t) = \\dfrac{\\mathrm{d} \\theta}{\\mathrm{d} t} $。由此可得如下一阶系统：$ \\dfrac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{y}(t) = \\begin{bmatrix} \\omega(t) \\\\ -\\dfrac{g}{L} \\sin(\\theta(t)) \\end{bmatrix} $，给定初始条件为 $ \\mathbf{y}(0) = \\begin{bmatrix} \\theta_0 \\\\ \\omega_0 \\end{bmatrix} $。角度必须以弧度为单位，时间以秒为单位。\n\n对于一个固定的总模拟时间 $T$，设 $N$ 为一个正整数，$h = T / N$ 为均匀时间步长。设 $ \\Phi_h^N(\\mathbf{y}_0) $ 表示从 $ \\mathbf{y}_0 $ 开始，应用步长为 $h$ 的显式经典四阶单步法，经过 $N$ 步后在时间 $T$ 得到的数值状态。该方法定义如下：对于从 $(t_n, \\mathbf{y}_n)$ 到 $(t_{n+1}, \\mathbf{y}_{n+1})$ 的每一步，其中 $t_{n+1} = t_n + h$，\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{f}(t_n, \\mathbf{y}_n), \\\\\n\\mathbf{k}_2 &= \\mathbf{f}\\!\\left(t_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_1\\right), \\\\\n\\mathbf{k}_3 &= \\mathbf{f}\\!\\left(t_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_2\\right), \\\\\n\\mathbf{k}_4 &= \\mathbf{f}\\!\\left(t_n + h, \\mathbf{y}_n + h\\,\\mathbf{k}_3\\right), \\\\\n\\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\tfrac{h}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right),\n\\end{aligned}\n$$\n其中 $ \\mathbf{f}(t,\\mathbf{y}) = \\begin{bmatrix} \\omega \\\\ -\\dfrac{g}{L}\\sin(\\theta) \\end{bmatrix} $。\n\n步长为 $h$ 时的终态误差定义为\n$$\nE(h) = \\left\\| \\Phi_h^N(\\mathbf{y}_0) - \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0) \\right\\|_2,\n$$\n其中 $h_{\\mathrm{ref}} = T / N_{\\mathrm{ref}}$，$N_{\\mathrm{ref}}$ 是一个足够大的正整数，使得 $ \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0) $ 可作为时间 $T$ 的一个参考解。欧几里得范数 $ \\| \\cdot \\|_2 $ 在 $ \\mathbb{R}^2 $ 中计算。\n\n对于一个固定的问题实例，将观测全局误差阶 $p$ 定义为在对应于 $ N \\in \\{ 64, 128, 256, 512, 1024 \\} $ 的有限步长集合上，通过计算映射 $ \\log(h) \\mapsto \\log(E(h)) $ 的最小二乘最佳拟合直线的斜率。\n\n您的任务是编写一个完整、可运行的程序，该程序为以下每个测试用例计算如上定义的观测全局误差阶 $p$。使用 $ g = 9.81 \\,\\mathrm{m/s^2} $，角度以弧度表示，角速度以弧度/秒表示。每个测试用例的参考离散化必须使用 $ N_{\\mathrm{ref}} = 65536 $。\n\n测试套件（所有角度以弧度为单位，时间以秒为单位，长度以米为单位，角速度以弧度/秒为单位）：\n- 测试 A: $L = 1.0$, $\\theta_0 = 0.3$, $\\omega_0 = 0.0$, $T = 10.0$。\n- 测试 B: $L = 1.0$, $\\theta_0 = 2.5$, $\\omega_0 = 0.0$, $T = 10.0$。\n- 测试 C: $L = 2.0$, $\\theta_0 = 1.0$, $\\omega_0 = 1.0$, $T = 20.0$。\n- 测试 D: $L = 1.0$, $\\theta_0 = 1.2$, $\\omega_0 = 0.0$, $T = 40.0$。\n\n您的程序必须产生单行输出，其中包含四个结果，按测试 A、B、C、D 的顺序排列，以逗号分隔并用方括号括起，每个值四舍五入到两位小数（无单位），例如：\"[4.00,4.01,3.99,3.98]\"。", "solution": "所述问题是有效的。它在经典力学和数值分析方面有坚实的科学基础，所有必要的条件和参数都已给出，问题陈述适定，语言客观明确。不存在矛盾、信息缺失或逻辑缺陷。因此，我们可以着手求解。\n\n该问题要求计算应用于非线性摆方程的经典四阶龙格-库塔(RK4)法的观测实验收敛阶 $p$。控制方程是一个二阶常微分方程(ODE)：\n$$\n\\frac{\\mathrm{d}^2 \\theta}{\\mathrm{d} t^2} + \\frac{g}{L} \\sin(\\theta) = 0\n$$\n通过定义状态向量 $\\mathbf{y}(t) = [\\theta(t), \\omega(t)]^T$，其中 $\\omega(t) = \\frac{\\mathrm{d}\\theta}{\\mathrm{d}t}$ 是角速度，该方程被转换为一个包含两个一阶ODE的系统。该系统为：\n$$\n\\frac{\\mathrm{d}\\mathbf{y}}{\\mathrm{d}t} = \\mathbf{f}(\\mathbf{y}) = \\begin{bmatrix} \\omega \\\\ -\\frac{g}{L}\\sin(\\theta) \\end{bmatrix}\n$$\n这构成了具有初始条件 $\\mathbf{y}(0) = [\\theta_0, \\omega_0]^T$ 的初值问题(IVP)。函数 $\\mathbf{f}$ 是自治的，意味着它不显式依赖于时间 $t$。\n\n数值方法的收敛阶表征了当步长 $h$ 减小时全局误差减小的速率。对于一个 $p$ 阶方法，在固定的最终时间 $T$，全局误差 $E(h)$ 预期会按照关系 $E(h) \\propto h^p$ 缩放。该问题将误差 $E(h)$ 定义为数值解 $\\Phi_h^N(\\mathbf{y}_0)$ 与高精度参考解 $\\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0)$ 之差的欧几里得范数：\n$$\nE(h) = \\left\\| \\Phi_h^N(\\mathbf{y}_0) - \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0) \\right\\|_2\n$$\n为了从数值数据中确定阶数 $p$，我们可以对误差关系式取对数：\n$$\n\\log(E(h)) \\approx p \\log(h) + C'\n$$\n其中 $C'$ 是一个常数。该方程揭示了 $\\log(E(h))$ 和 $\\log(h)$ 之间的线性关系，其斜率即为收敛阶 $p$。问题规定 $p$ 应计算为由一组预定步长生成的数据点 $(\\log(h), \\log(E(h)))$ 的最小二乘最佳拟合直线的斜率。经典龙格-库塔法是已知的四阶方法，因此我们预期计算出的 $p$ 值会非常接近 $4$。\n\n解决每个测试用例的计算过程如下：\n\n1.  **定义系统参数**：对于每个测试用例，指定参数 $L$、$\\theta_0$、$\\omega_0$ 和 $T$。重力加速度固定为 $g = 9.81 \\, \\mathrm{m/s^2}$。初始状态向量为 $\\mathbf{y}_0 = [\\theta_0, \\omega_0]^T$。\n\n2.  **实现RK4积分器**：将创建一个函数来实现问题陈述中定义的单步RK4方案。该函数将在一个时间步长 $h$ 内将状态向量 $\\mathbf{y}_n$推进到 $\\mathbf{y}_{n+1}$。另一个函数将通过重复应用单步函数 $N = T/h$ 次来协调在整个区间 $[0, T]$ 上的积分。\n\n3.  **计算参考解**：对于每个测试用例，在最终时间 $T$ 计算一个高精度的参考解 $\\mathbf{y}_{\\mathrm{ref}} = \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0)$。问题指定了大量的步数 $N_{\\mathrm{ref}} = 65536$，以确保该解是一个可靠的基准。\n\n4.  **计算近似解和误差**：对于步数集合 $N \\in \\{ 64, 128, 256, 512, 1024 \\}$，确定相应的步长 $h = T/N$。对于每个 $N$，计算数值解 $\\mathbf{y}_N = \\Phi_h^N(\\mathbf{y}_0)$。然后计算误差 $E(h) = \\| \\mathbf{y}_N - \\mathbf{y}_{\\mathrm{ref}} \\|_2$ 并与其对应的步长 $h$ 一起存储。\n\n5.  **确定收敛阶**：利用这组配对 $(h, E(h))$，我们计算相应的对数配对 $(\\log(h), \\log(E(h)))$。对这些对数数据点执行线性最小二乘回归。所得最佳拟合线的斜率即为观测到的收敛阶 $p$。\n\n对所有四个提供的测试用例（测试 A、B、C、D）重复整个过程。收集最终的 $p$ 值，四舍五入到两位小数，并格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed global error order for the RK4 method applied\n    to the nonlinear pendulum problem for a suite of test cases.\n    \"\"\"\n    # Define gravitational constant\n    g = 9.81  # m/s^2\n\n    # Test cases: (L, theta0, omega0, T)\n    test_cases = [\n        (1.0, 0.3, 0.0, 10.0),  # Test A\n        (1.0, 2.5, 0.0, 10.0),  # Test B\n        (2.0, 1.0, 1.0, 20.0),  # Test C\n        (1.0, 1.2, 0.0, 40.0),  # Test D\n    ]\n\n    # Parameters for the numerical experiment\n    N_values = [64, 128, 256, 512, 1024]\n    N_ref = 65536\n\n    results = []\n    \n    # Define the system of ODEs: d(y)/dt = f(t, y)\n    # y = [theta, omega]\n    # f returns [d(theta)/dt, d(omega)/dt]\n    # The system is autonomous, so t is not used.\n    def f(t, y, g_over_L):\n        theta, omega = y\n        return np.array([omega, -g_over_L * np.sin(theta)])\n\n    def integrate_rk4(y0, T, N, g_over_L):\n        \"\"\"\n        Solves the ODE system from t=0 to t=T using N steps of RK4.\n        \"\"\"\n        h = T / N\n        y = np.copy(y0)\n        t = 0.0\n        \n        for _ in range(N):\n            k1 = f(t, y, g_over_L)\n            k2 = f(t + h / 2.0, y + h / 2.0 * k1, g_over_L)\n            k3 = f(t + h / 2.0, y + h / 2.0 * k2, g_over_L)\n            k4 = f(t + h, y + h * k3, g_over_L)\n            \n            y += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += h\n            \n        return y\n\n    for case in test_cases:\n        L, theta0, omega0, T = case\n        g_over_L = g / L\n        y0 = np.array([theta0, omega0])\n\n        # 1. Compute the reference solution with N_ref steps\n        y_ref = integrate_rk4(y0, T, N_ref, g_over_L)\n\n        h_values = []\n        errors = []\n\n        # 2. Compute solutions and errors for a range of N\n        for N in N_values:\n            h = T / N\n            y_approx = integrate_rk4(y0, T, N, g_over_L)\n            \n            # 3. Calculate the Euclidean norm of the error vector\n            error = np.linalg.norm(y_approx - y_ref, 2)\n            \n            h_values.append(h)\n            errors.append(error)\n        \n        # 4. Perform linear regression on log(error) vs log(h)\n        # We expect log(error) = p * log(h) + C\n        log_h = np.log(h_values)\n        log_E = np.log(errors)\n        \n        # numpy.polyfit returns [slope, intercept] for degree 1\n        p, _ = np.polyfit(log_h, log_E, 1)\n        \n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.2f}', results))}]\")\n\nsolve()\n```", "id": "2420941"}, {"introduction": "虽然像四阶龙格-库塔（RK4）这样的通用积分器在短期模拟中表现出色，但在处理像单摆这样的保守系统时，它们往往会在长时间积分后引入非物理的能量漂移。这个实践将向你介绍一类专门为哈密顿系统设计的积分器——辛积分器。通过实现并测试看似简单但功能强大的欧拉-克罗默（Euler-Cromer）方法，你将亲眼见证它在长时间模拟中保持能量误差有界的卓越特性 [@problem_id:2420954]。这一特性对于天体力学和分子动力学等领域的长期稳定模拟至关重要。", "problem": "考虑一个无阻尼的刚性摆，由一个质点和一根无质量的杆组成，在没有摩擦的垂直平面内运动。设其与垂直向下方向的角位移表示为 $ \\theta(t) $ (单位为弧度)，角速度为 $ \\omega(t) = \\dot{\\theta}(t) $ (单位为弧度/秒)。其运动方程为非线性二阶常微分方程\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L} \\sin\\!\\big(\\theta(t)\\big) = 0 ,\n$$\n其中 $ L $ 是摆的长度（单位为米），$ g $ 是重力加速度（单位为米/平方秒）。对于质量为 $ m $ 的质点，其总机械能为\n$$\nE(\\theta,\\omega) = m g L \\big(1 - \\cos\\theta\\big) + \\frac{1}{2} m L^2 \\omega^2 .\n$$\n在整个问题中，取 $ m = 1 $ 千克。所有角度均使用弧度，所有时间均使用秒。\n\n基于小角度周期 $ T_0 $ 定义以下时间离散化：\n$$\nT_0 = 2\\pi \\sqrt{\\frac{L}{g}}, \\quad \\Delta t = \\frac{T_0}{N_{\\text{pp}}}, \\quad N_{\\text{steps}} = N_{\\text{pp}} \\times N_{\\text{per}} ,\n$$\n其中 $ N_{\\text{pp}} $ 是每个小角度周期的时间步数，$ N_{\\text{per}} $ 是要模拟的周期数（周期以 $ T_0 $ 为单位计数）。使用离散时间更新规则\n$$\n\\omega_{n+1} = \\omega_n - \\frac{g}{L} \\sin(\\theta_n)\\,\\Delta t, \\qquad\n\\theta_{n+1} = \\theta_n + \\omega_{n+1}\\,\\Delta t ,\n$$\n初始条件为\n$$\n\\theta_0 = \\theta(0) = \\theta_{\\text{init}}, \\qquad \\omega_0 = \\omega(0) = 0 .\n$$\n在每个步骤中，计算总能量\n$$\nE_n = g L \\big(1 - \\cos\\theta_n\\big) + \\frac{1}{2} L^2 \\omega_n^2,\n$$\n并定义相对于初始能量 $ E_0 $ 的相对能量偏差为\n$$\n\\varepsilon_n = \n\\begin{cases}\n\\left| \\dfrac{E_n - E_0}{E_0} \\right|, & \\text{if } E_0 \\neq 0, \\\\\n0, & \\text{if } E_0 = 0 .\n\\end{cases}\n$$\n对于下面测试套件中的每组参数，模拟 $ N_{\\text{steps}} $ 步，并报告最大相对能量偏差\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\varepsilon_n .\n$$\n\n测试套件 (每个元组为 $ (L \\ \\text{单位 m}, \\ g \\ \\text{单位 m/s}^2, \\ \\theta_{\\text{init}} \\ \\text{单位 rad}, \\ N_{\\text{pp}}, \\ N_{\\text{per}}) $):\n- 情况1： $(1.0, \\ 9.81, \\ 0.3, \\ 64, \\ 2500)$，\n- 情况2： $(1.0, \\ 9.81, \\ 1.2, \\ 64, \\ 2500)$，\n- 情况3： $(2.0, \\ 9.81, \\ 2.5, \\ 96, \\ 2000)$，\n- 情况4： $(0.5, \\ 9.81, \\ 0.1, \\ 32, \\ 3000)$，\n- 情况5： $(1.0, \\ 9.81, \\ 3.0, \\ 128, \\ 1500)$。\n\n您的程序必须为每种情况计算 $ \\varepsilon_{\\max} $ 作为浮点数，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个数字四舍五入到八位小数（例如，$ [0.00123456,0.01234567] $）。对于 $L$ 使用米，对于 $g$ 使用米/平方秒，对于 $\\theta$ 使用弧度，对于时间使用秒。输出必须按照测试套件情况的顺序将结果汇总为 $ [\\varepsilon_{\\max}^{(1)}, \\varepsilon_{\\max}^{(2)}, \\varepsilon_{\\max}^{(3)}, \\varepsilon_{\\max}^{(4)}, \\varepsilon_{\\max}^{(5)}] $。", "solution": "问题陈述已经过严格验证，被认为是有效的。它具有科学依据，提法得当，客观，并包含获得唯一解所需的所有必要信息。该问题是计算物理学中的一个标准练习，涉及保守动力系统的数值积分。\n\n物理系统是一个简单的刚性摆，其运动由非线性二阶常微分方程描述\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L} \\sin(\\theta(t)) = 0,\n$$\n其中 $ \\theta(t) $ 是角位移，$ \\omega(t) = \\dot{\\theta}(t) $ 是角速度，$L$ 是摆的长度，$g$ 是重力加速度。由于该系统是保守的（无阻尼且无外力），其总机械能 $ E(\\theta, \\omega) $ 是一个运动守恒量。对于一个质点 $m$，这个能量是势能和动能的总和：\n$$\nE(\\theta,\\omega) = \\underbrace{m g L (1 - \\cos\\theta)}_{\\text{Potential Energy}} + \\underbrace{\\frac{1}{2} m L^2 \\omega^2}_{\\text{Kinetic Energy}}.\n$$\n在指定的质量 $ m = 1 \\ \\text{kg} $ 下，能量表达式简化为\n$$\nE(\\theta,\\omega) = g L (1 - \\cos\\theta) + \\frac{1}{2} L^2 \\omega^2.\n$$\n任务是使用特定的数值方法模拟摆的动力学，并通过计算所计算的能量与其初始值的最大相对偏差来量化该方法的准确性。一个用于保守系统的理想数值积分器将精确地保持能量守恒。实际的积分器会引入误差，导致数值能量发生偏差。\n\n规定的数值积分方案是\n$$\n\\omega_{n+1} = \\omega_n - \\frac{g}{L} \\sin(\\theta_n)\\,\\Delta t,\n$$\n$$\n\\theta_{n+1} = \\theta_n + \\omega_{n+1}\\,\\Delta t,\n$$\n其中 $ (\\theta_n, \\omega_n) $ 是在时间 $ t_n = n \\Delta t $ 的状态，$ \\Delta t $ 是离散时间步长。该方案被称为 Euler-Cromer 方法。它是标准 Euler 方法的一种改进，其中更新后的速度 $ \\omega_{n+1} $ 用于计算新的位置 $ \\theta_{n+1} $。这个看似微小的改变使得该积分器具有辛性。辛积分器特别适用于哈密顿系统（如此处的摆）的长期模拟。虽然它们不守恒精确的能量 $E$，但它们确实守恒一个邻近的量，一个“影子”哈密顿量。因此，辛积分器的能量误差通常随时间保持有界，在初始值附近振荡，而对于像前向 Euler 这样的非辛方法，能量误差则倾向于无界增长。问题要求的是这个能量振荡的最大振幅，用 $ \\varepsilon_{\\max} $ 来量化。\n\n为每个给定的参数集计算 $ \\varepsilon_{\\max} $ 的算法如下：\n\n1.  **初始化**：给定一个包含参数 $(L, g, \\theta_{\\text{init}}, N_{\\text{pp}}, N_{\\text{per}})$ 的测试用例，首先计算派生的模拟常量：\n    - 小角度振荡的周期：$ T_0 = 2\\pi\\sqrt{L/g} $。\n    - 时间步长：$ \\Delta t = T_0 / N_{\\text{pp}} $。\n    - 模拟的总步数：$ N_{\\text{steps}} = N_{\\text{pp}} \\times N_{\\text{per}} $。\n\n2.  **初始条件**：设置系统在时间 $ t=0 $ ($n=0$) 的初始状态：\n    - 初始角度：$ \\theta_0 = \\theta_{\\text{init}} $。\n    - 初始角速度：$ \\omega_0 = 0 $。\n\n3.  **初始能量和误差**：使用初始状态计算初始能量 $ E_0 $：\n    $$\n    E_0 = g L (1 - \\cos\\theta_0).\n    $$\n    相对能量偏差 $ \\varepsilon_n $ 定义为 $ \\varepsilon_n = |(E_n - E_0) / E_0| $，其中 $ E_0 \\ne 0 $。对于给定的初始条件，$ E_0 $ 是非零的，因为 $ \\theta_{\\text{init}} $ 绝不是 $ 2\\pi $ 的倍数。初始偏差为 $ \\varepsilon_0 = 0 $。目前为止发现的最大偏差初始化为 $ \\varepsilon_{\\max} = 0 $。\n\n4.  **时间演化循环**：从 $n=0$ 迭代到 $ N_{\\text{steps}}-1 $ 来模拟运动。在每次迭代中，从状态 $(\\theta_n, \\omega_n)$ 开始：\n    a. 使用 Euler-Cromer 更新规则计算新状态 $ (\\theta_{n+1}, \\omega_{n+1}) $。\n    b. 计算新步骤的总能量，$ E_{n+1} = g L (1 - \\cos\\theta_{n+1}) + \\frac{1}{2} L^2 \\omega_{n+1}^2 $。\n    c. 计算相对能量偏差 $ \\varepsilon_{n+1} = |(E_{n+1} - E_0) / E_0| $。\n    d. 更新最大偏差：$ \\varepsilon_{\\max} = \\max(\\varepsilon_{\\max}, \\varepsilon_{n+1}) $。\n    e. 新状态 $ (\\theta_{n+1}, \\omega_{n+1}) $ 成为下一次迭代的当前状态。\n\n5.  **结果**：经过 $ N_{\\text{steps}} $ 次迭代后，$ \\varepsilon_{\\max} $ 的最终值就是给定测试用例的结果。对所有五个测试套件重复此过程，并收集结果。最终输出格式化为这些值的列表，四舍五入到八位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear pendulum problem for a suite of test cases.\n    \"\"\"\n    # Test Suite (L in m, g in m/s^2, theta_init in rad, N_pp, N_per)\n    test_cases = [\n        (1.0, 9.81, 0.3, 64, 2500),\n        (1.0, 9.81, 1.2, 64, 2500),\n        (2.0, 9.81, 2.5, 96, 2000),\n        (0.5, 9.81, 0.1, 32, 3000),\n        (1.0, 9.81, 3.0, 128, 1500),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, g, theta_init, N_pp, N_per = case\n        \n        # Calculate simulation parameters\n        T0 = 2.0 * np.pi * np.sqrt(L / g)\n        dt = T0 / N_pp\n        N_steps = N_pp * N_per\n        \n        # Initial conditions\n        theta = theta_init\n        omega = 0.0\n        \n        # Calculate initial energy\n        # The problem states m=1, so we omit it.\n        # E = g * L * (1 - cos(theta)) + 0.5 * L**2 * omega**2\n        E0 = g * L * (1.0 - np.cos(theta_init))\n        \n        # Initialize maximum relative energy deviation\n        # Epsilon_0 is 0 by definition.\n        epsilon_max = 0.0\n\n        # Handle the case where initial energy is zero to avoid division by zero.\n        # For the given test cases, theta_init is never a multiple of 2*pi, so E0 is not zero.\n        if E0 == 0.0:\n            results.append(0.0)\n            continue\n\n        # Simulation loop\n        for _ in range(N_steps):\n            # Update state using the Euler-Cromer method\n            omega = omega - (g / L) * np.sin(theta) * dt\n            theta = theta + omega * dt\n            \n            # Calculate total energy at the current step\n            E_n = g * L * (1.0 - np.cos(theta)) + 0.5 * L**2 * omega**2\n            \n            # Calculate relative energy deviation\n            epsilon_n = np.abs((E_n - E0) / E0)\n            \n            # Update the maximum deviation\n            if epsilon_n > epsilon_max:\n                epsilon_max = epsilon_n\n        \n        results.append(epsilon_max)\n\n    # Format results to eight decimal places and print\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2420954"}, {"introduction": "掌握了可靠的模拟方法后，我们现在可以将它们应用于一个视觉上引人入胜的物理现象：单摆波。在这个练习中，你将模拟一组经过精心选择不同长度的单摆，并观察它们如何从初始的同步状态演化出复杂的集体波状运动，最终又回归同步 [@problem_id:2403226]。这个实践不仅展示了计算物理学的美感，还深刻揭示了理想化线性模型（其中所有单摆将完美地重新同步）与真实非线性动力学（其中周期的振幅依赖性导致相位漂移）之间的关键差异。", "problem": "考虑一组单摆，每个单摆被建模为附着在不同长度的无质量刚性杆上的质点。对于由 $n \\in \\{1,2,\\dots,N\\}$ 索引的每个单摆，令 $\\theta_n(t)$ 表示其在时间 $t$ 时相对于垂直向下的角位移，并选择一致的正方向。假设为平面运动，无驱动，无耗散。根据牛顿第二定律的转动形式，每个单摆的动力学由以下常微分方程 (ODE) 决定：\n$$\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin\\big(\\theta_n(t)\\big) = 0,\n$$\n初始条件为\n$$\n\\theta_n(0)=\\theta_0,\\quad \\frac{d\\theta_n}{dt}(0)=0,\n$$\n其中，$g$ 是以 $\\mathrm{m/s^2}$ 为单位的重力加速度，$L_n$ 是第 $n$ 个单摆的长度（以 $\\mathrm{m}$ 为单位），角度以弧度表示。为了产生摆波现象，考虑一组目标周期 $\\{T_n\\}_{n=1}^N$，其设计使得在小角度极限下，每个单摆在一个共同的对齐时间 $T_{\\mathrm{align}}$ 内完成整数次振荡，即 $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$，其中 $K_n$ 为整数。在小角度近似下，周期为 $T_n = 2\\pi \\sqrt{\\frac{L_n}{g}}$，这意味着摆长的选择为：\n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\n在以下所有任务中，请使用包含精确 $\\sin(\\theta_n)$ 项的完整非线性常微分方程，而非小角度近似。使用的单位：长度为 $\\mathrm{m}$，$g$ 为 $\\mathrm{m/s^2}$，时间为 $\\mathrm{s}$，角度为弧度。\n\n测试套件与所需输出：\n\n- 测试用例 A（线性设计极限下的小振幅重新同相）：\n  - 参数：$N=15$，$g=9.81\\,\\mathrm{m/s^2}$，$\\theta_0=0.05\\,\\mathrm{rad}$，$T_{\\mathrm{align}}=60\\,\\mathrm{s}$，以及 $K_n = K_0 + N - n$（其中 $K_0=46$）。因此，$K_1=60$，$K_{15}=46$，且对于 $n \\in \\{1,\\dots,15\\}$，$L_n = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2$。在 $t \\in [0,T_{\\mathrm{align}}]$ 上模拟每个单摆。定义标量\n  $$\n  E_A = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  将 $E_A$ 以弧度为单位，作为浮点数报告。\n\n- 测试用例 B（较大振幅下的非线性失相）：\n  - 参数：与测试用例 A 相同，除了 $\\theta_0=0.5\\,\\mathrm{rad}$。在 $t \\in [0,T_{\\mathrm{align}}]$ 上进行模拟。定义\n  $$\n  E_B = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  将 $E_B$ 以弧度为单位，作为浮点数报告。\n\n- 测试用例 C（长度相同的简并对）：\n  - 参数：$N=2$，$L_1=L_2=1.0\\,\\mathrm{m}$，$g=9.81\\,\\mathrm{m/s^2}$，$\\theta_0=0.1\\,\\mathrm{rad}$，以及模拟区间 $t \\in [0,T]$（其中 $T=10\\,\\mathrm{s}$）。对于这两个具有相同初始条件和长度的单摆，定义\n  $$\n  E_C = \\max_{t \\in [0,T]} \\left|\\theta_1(t) - \\theta_2(t)\\right|.\n  $$\n  将 $E_C$ 以弧度为单位，作为浮点数报告。\n\n您的程序必须使用上述常微分方程以及指定的参数和初始条件来计算 $(E_A, E_B, E_C)$。最终输出必须是单行文本，包含一个用方括号括起来的逗号分隔列表，顺序为 $[E_A,E_B,E_C]$，例如 $[x_A,x_B,x_C]$，其中每个条目都是以弧度为单位的浮点数。不应打印任何其他文本。", "solution": "出发点是单摆的力矩平衡，这可以从第一性原理导出。对于一个质量为 $m$ 的质点，位于长度为 $L_n$ 的无质量刚性杆的末端，在重力 $g$ 的作用下，其绕支点的重力力矩为 $\\tau = - m g L_n \\sin(\\theta_n)$。转动惯量为 $I = m L_n^2$。牛顿第二定律的转动形式给出 $I \\frac{d^2 \\theta_n}{dt^2} = \\tau$，因此\n$$\nm L_n^2 \\frac{d^2 \\theta_n}{dt^2} = - m g L_n \\sin(\\theta_n)\n\\quad \\Rightarrow \\quad\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin(\\theta_n) = 0.\n$$\n这是一个二阶非线性常微分方程 (ODE) 的初值问题 (IVP)。在初始条件 $\\theta_n(0) = \\theta_0$ 和 $\\frac{d\\theta_n}{dt}(0) = 0$下，对于每个 $n$ ，解是唯一确定的。\n\n为产生摆波现象，所选的摆长应使得在小角度极限下，每个单摆在一个共同的对齐时间 $T_{\\mathrm{align}}$ 内完成整数次振荡。如果小角度周期为 $T_n = 2\\pi \\sqrt{L_n/g}$，并且我们强制要求 $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$（其中 $K_n$ 为整数），那么摆长遵循以下关系：\n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\n选择一个随 $n$ 严格递减的整数序列 $K_n$ 可以确保摆长 $L_n$ 随 $n$ 严格递增。在测试用例 A 和 B 中，选择 $K_n = K_0 + N - n$ 会得到从 $K_1 = K_0 + N - 1$ 到 $K_N = K_0$ 的序列，因此 $L_1 < L_2 < \\cdots < L_N$。\n\n对于测试用例 A，初始位移 $\\theta_0$ 很小。在线性极限下，经过 $K_n$ 次完整振荡后，每个单摆在 $t = T_{\\mathrm{align}}$ 时会返回其初始状态，这意味着 $\\theta_n(T_{\\mathrm{align}}) = \\theta_0$，因此 $E_A = 0$。然而，求解包含 $\\sin(\\theta_n)$ 的精确非线性常微分方程会产生一个微小的偏差，因为在非线性区域，周期与振幅相关；数值 $E_A$ 量化了这种偏差。\n\n对于测试用例 B，初始位移 $\\theta_0$ 更大，与振幅相关的周期偏移也更显著。$L_n$ 序列保持不变，但预计 $E_B$ 会更大，因为非线性效应会导致相对于线性设计对齐时间 $T_{\\mathrm{align}}$ 的失相。\n\n对于测试用例 C，两个单摆的长度相同 ($L_1 = L_2$) 且初始数据相同 ($\\theta_1(0) = \\theta_2(0) = \\theta_0$ 和 $\\frac{d\\theta_1}{dt}(0) = \\frac{d\\theta_2}{dt}(0) = 0$)，它们的常微分方程是完全相同的。根据光滑常微分方程解的唯一性，对于所有 $t$，有 $\\theta_1(t) \\equiv \\theta_2(t)$。因此，从解析上讲 $E_C = 0$。数值解将得到一个接近于零的值，任何偏差都可归因于数值误差和采样。\n\n与这些原理一致的算法纲要：\n- 通过引入 $\\omega_n = \\frac{d\\theta_n}{dt}$，将每个二阶常微分方程表示为一阶系统：\n  $$\n  \\frac{d\\theta_n}{dt} = \\omega_n,\\quad \\frac{d\\omega_n}{dt} = -\\frac{g}{L_n} \\sin(\\theta_n).\n  $$\n- 对于测试用例 A 和 B，对每个 $n \\in \\{1,\\dots,N\\}$，在初始条件 $(\\theta_n(0),\\omega_n(0)) = (\\theta_0,0)$ 下，将系统从 $t=0$ 积分到 $t=T_{\\mathrm{align}}$，并计算 $\\theta_n(T_{\\mathrm{align}})$。将 $E_A$ 或 $E_B$ 计算为所有 $n$ 中与 $\\theta_0$ 的最大绝对偏差。\n- 对于测试用例 C，在相同的初始条件下，将两个完全相同的单摆在 $t \\in [0,T]$ 上进行积分，在足够精细的时间网格上对 $\\theta_1(t)$ 和 $\\theta_2(t)$ 进行采样，并计算 $E_C$ 为该网格上 $|\\theta_1(t)-\\theta_2(t)|$ 的最大绝对差值。\n- 使用指定的单位：$g$ 为 $\\mathrm{m/s^2}$，长度为 $\\mathrm{m}$，时间为 $\\mathrm{s}$，角度为弧度。\n\n最终程序计算三个标量 $(E_A,E_B,E_C)$，并在一行中按要求的顺序 $[E_A,E_B,E_C]$ 以逗号分隔的列表形式打印，数值以弧度为单位。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef pendulum_rhs(t, y, g, L):\n    theta, omega = y\n    return [omega, -(g / L) * np.sin(theta)]\n\ndef simulate_endpoint_theta(L, theta0, g, t_end, rtol=1e-10, atol=1e-12, method=\"DOP853\"):\n    # Integrate one pendulum to time t_end and return theta(t_end)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, t_end),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=[t_end],\n        dense_output=False,\n        vectorized=False,\n    )\n    theta_T = sol.y[0, -1]\n    return theta_T\n\ndef simulate_theta_time_series(L, theta0, g, T, num_points=5001, rtol=1e-11, atol=1e-13, method=\"DOP853\"):\n    # Integrate one pendulum over [0,T] and return time grid and theta(t) array\n    t_eval = np.linspace(0.0, T, num_points)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, T),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=t_eval,\n        dense_output=False,\n        vectorized=False,\n    )\n    return sol.t, sol.y[0, :]\n\ndef compute_lengths_for_alignment(N, g, T_align, K0):\n    # K_n = K0 + N - n yields increasing lengths with n\n    Ks = np.array([K0 + N - n for n in range(1, N + 1)], dtype=float)\n    # L_n = g * (T_align / (2*pi*K_n))^2\n    Ls = g * (T_align / (2.0 * np.pi * Ks))**2\n    return Ls\n\ndef main():\n    # Constants\n    g = 9.81  # m/s^2\n\n    results = []\n\n    # Test case A\n    N_A = 15\n    T_align_A = 60.0  # s\n    K0_A = 46\n    theta0_A = 0.05  # rad\n    Ls_A = compute_lengths_for_alignment(N_A, g, T_align_A, K0_A)\n    deviations_A = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_A, g, T_align_A)\n        deviations_A.append(abs(theta_T - theta0_A))\n    E_A = float(np.max(deviations_A))\n    results.append(E_A)\n\n    # Test case B (same lengths, larger amplitude)\n    theta0_B = 0.5  # rad\n    deviations_B = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_B, g, T_align_A)\n        deviations_B.append(abs(theta_T - theta0_B))\n    E_B = float(np.max(deviations_B))\n    results.append(E_B)\n\n    # Test case C (two identical pendula)\n    L_C = 1.0  # m\n    theta0_C = 0.1  # rad\n    T_C = 10.0  # s\n    t_grid, theta1 = simulate_theta_time_series(L_C, theta0_C, g, T_C)\n    _, theta2 = simulate_theta_time_series(L_C, theta0_C, g, T_C)  # identical parameters\n    E_C = float(np.max(np.abs(theta1 - theta2)))\n    results.append(E_C)\n\n    # Print results in required format\n    print(f\"[{','.join(f'{x:.12g}' for x in results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "2403226"}]}