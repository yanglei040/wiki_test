{"hands_on_practices": [{"introduction": "自适应算法的“智能”在于其控制器，即根据误差调整步长的规则。本练习超越了常见的比例控制器，探索了一种带有“记忆”功能（利用历史误差信息）的比例-积分（PI）控制器。通过计算这两种控制器提出的步长差异，您将对它们的行为方式获得定量的理解，并体会为何PI控制器能提供更稳定的性能。[@problem_id:2153291]", "problem": "在数值分析领域，自适应步长控制是高效求解常微分方程 (ODE) 的一项关键技术。自适应算法在每一步调整其步长 $h$，以使局部误差估计 $E$ 保持在期望容差 TOL 附近。\n\n一种常见方法是标准比例控制器（控制器 S），它根据已完成步骤 $k$ 的误差 $E_k$ 将步长从 $h_k$ 更新为 $h_{k+1}$：\n$$h_{k+1} = \\gamma h_k \\left( \\frac{\\text{TOL}}{E_k} \\right)^p$$\n其中 $\\gamma$ 是一个安全因子，$p$ 是一个与积分方法阶数相关的常数。\n\n另一种方法是比例-积分 (PI) 控制器（控制器 PI），它结合了上一步的误差 $E_{k-1}$ 信息，以平滑步长的选择。其更新规则为：\n$$h_{k+1} = \\gamma h_k \\left( \\frac{\\text{TOL}}{E_k} \\right)^{k_P} \\left( \\frac{\\text{TOL}}{E_{k-1}} \\right)^{k_I}$$\n其中 $k_P$ 和 $k_I$ 分别是比例增益和积分增益。\n\n考虑一个具有以下参数的数值模拟：\n- 期望容差，TOL $= 1.0 \\times 10^{-5}$\n- 安全因子，$\\gamma = 0.9$\n- 控制器 S 指数，$p = 0.2$\n- 控制器 PI 增益，$k_P = 0.4$ 和 $k_I = 0.3$\n\n该模拟运行了若干步。在第 $n$ 步开始时，步长为 $h_n = 0.1$。执行此步后，得到的局部误差估计为 $E_n = 2.0 \\times 10^{-5}$。基于此误差，使用控制器 S 计算下一步的步长 $h_{n+1}$。然后，模拟继续以这个新步长执行第 $n+1$ 步，得到的误差为 $E_{n+1} = 4.0 \\times 10^{-6}$。\n\n此时，为了确定后续步长 $h_{n+2}$，根据当前状态（步长 $h_{n+1}$ 和误差历史）考虑两种方案：\n1.  方案 S：继续使用控制器 S 计算 $h_{n+2}^{(S)}$。\n2.  方案 PI：切换到 PI 控制器计算 $h_{n+2}^{(PI)}$。\n\n你的任务是确定 PI 控制器提出的步长与标准控制器提出的步长之比。计算 $\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}$ 的值。\n\n将你的最终答案四舍五入到三位有效数字。", "solution": "我们使用给定的更新法则。对于在第 $n+1$ 步应用的控制器 S，建议的下一步步长是\n$$h_{n+2}^{(S)}=\\gamma h_{n+1}\\left(\\frac{\\text{TOL}}{E_{n+1}}\\right)^{p}。$$\n对于在第 $n+1$ 步应用的控制器 PI，建议的下一步步长是\n$$h_{n+2}^{(PI)}=\\gamma h_{n+1}\\left(\\frac{\\text{TOL}}{E_{n+1}}\\right)^{k_{P}}\\left(\\frac{\\text{TOL}}{E_{n}}\\right)^{k_{I}}。$$\n因此，它们的比值为\n$$\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}=\\left(\\frac{\\text{TOL}}{E_{n+1}}\\right)^{k_{P}-p}\\left(\\frac{\\text{TOL}}{E_{n}}\\right)^{k_{I}}。$$\n使用给定值 $\\text{TOL}=1.0\\times 10^{-5}$, $E_{n}=2.0\\times 10^{-5}$, $E_{n+1}=4.0\\times 10^{-6}$, $p=0.2$, $k_{P}=0.4$, $k_{I}=0.3$，我们得到\n$$\\frac{\\text{TOL}}{E_{n+1}}=\\frac{1.0\\times 10^{-5}}{4.0\\times 10^{-6}}=2.5,\\qquad \\frac{\\text{TOL}}{E_{n}}=\\frac{1.0\\times 10^{-5}}{2.0\\times 10^{-5}}=0.5,$$\n所以\n$$\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}=(2.5)^{0.2}(0.5)^{0.3}。$$\n通过对数计算，\n$$\\ln\\!\\left(\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}\\right)=0.2\\ln(2.5)+0.3\\ln(0.5)\\approx 0.2\\cdot 0.9162907319+0.3\\cdot(-0.6931471806)\\approx -0.024686,$$\n因此\n$$\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}=\\exp(-0.024686)\\approx 0.9756,$$\n四舍五入到三位有效数字为 $0.976$。", "answer": "$$\\boxed{0.976}$$", "id": "2153291"}, {"introduction": "现在，让我们从理论走向实践，亲手构建完整的自适应积分器。本练习要求您实现并比较两种核心的误差估计策略：高效的嵌入式龙格-库塔-费尔伯格（Runge-Kutta-Fehlberg）方法和概念上更简单的步长加倍法。通过在不同常微分方程上比较它们的性能，您将深刻理解算法复杂性与计算成本之间的权衡。[@problem_id:2372273]", "problem": "你需要编写一个完整的程序，比较两种自适应步长策略在求解常微分方程标量初值问题时的表现。考虑一个形式为 $y'(t)=f(t,y)$ 且 $y(t_0)=y_0$ 的初值问题，求解区间为有限区间 $[t_0,t_f]$。对于下文的每个测试用例，从 $t_0$ 到 $t_f$ 进行积分，并生成两份摘要，一份针对嵌入式龙格-库塔-菲尔伯格 $4(5)$ 方法，另一份针对基于经典四阶龙格-库塔方法构建的步长加倍策略。对每种策略，报告其函数求值的总次数和所有被接受步长的算术平均值。\n\n两种策略都必须严格遵循的数学规范：\n- 误差缩放：对于从 $(t,y)$ 开始，步长为 $h$ 的一次试探步，定义标量尺度 $s=\\max\\{|y|,|y_{\\mathrm{trial}}|\\}$，容差 $T=\\text{atol}+\\text{rtol}\\cdot s$，以及由该策略计算出的误差估计 $E\\ge 0$。当且仅当 $E\\le T$ 时，一个试探步被接受。如果接受，则更新 $(t,y)\\leftarrow (t+h,y_{\\mathrm{accept}})$。如果试探步会越过 $t_f$，则在试探前将 $h$ 替换为 $t_f-t$。\n- 步长更新：设方法的有效局部误差阶为 $q=5$，因此局部误差的行为符合 $\\mathcal{O}(h^q)$。在任何一次试探（无论接受或拒绝）后，定义增长因子\n$$\ng=\n\\begin{cases}\n\\max(g_{\\min},\\min(g_{\\max},\\,\\sigma\\,(T/\\max(E,\\varepsilon))^{1/q} )), & E>0,\\\\\ng_{\\max}, & E=0,\n\\end{cases}\n$$\n其中固定常数 $\\sigma=0.9$，$g_{\\min}=0.2$，$g_{\\max}=5$，$\\varepsilon=10^{-30}$。然后将下一次试探的步长设置为 $h\\leftarrow \\max(h_{\\min},\\min(h_{\\max},g\\,h))$，其中 $h_{\\min}=10^{-12}$，$h_{\\max}=t_f-t_0$。对于所有测试用例，初始步长必须为 $h_0=(t_f-t_0)/50$。\n- 角度单位：所有出现的三角函数均使用弧度。\n\n嵌入式龙格-库塔-菲尔伯格 $4(5)$ 方法详细说明：\n- 使用经典的 Fehlberg 系数，共 $6$ 级。给定 $h$，内部的级计算如下\n$$\n\\begin{aligned}\nk_1&=f(t, y),\\\\\nk_2&=f\\!\\left(t+\\tfrac{1}{4}h,\\,y+h\\left(\\tfrac{1}{4}k_1\\right)\\right),\\\\\nk_3&=f\\!\\left(t+\\tfrac{3}{8}h,\\,y+h\\left(\\tfrac{3}{32}k_1+\\tfrac{9}{32}k_2\\right)\\right),\\\\\nk_4&=f\\!\\left(t+\\tfrac{12}{13}h,\\,y+h\\left(\\tfrac{1932}{2197}k_1-\\tfrac{7200}{2197}k_2+\\tfrac{7296}{2197}k_3\\right)\\right),\\\\\nk_5&=f\\!\\left(t+h,\\,y+h\\left(\\tfrac{439}{216}k_1-8k_2+\\tfrac{3680}{513}k_3-\\tfrac{845}{4104}k_4\\right)\\right),\\\\\nk_6&=f\\!\\left(t+\\tfrac{1}{2}h,\\,y+h\\left(-\\tfrac{8}{27}k_1+2k_2-\\tfrac{3544}{2565}k_3+\\tfrac{1859}{4104}k_4-\\tfrac{11}{40}k_5\\right)\\right).\n\\end{aligned}\n$$\n四阶和五阶试探解为\n$$\n\\begin{aligned}\ny_4&=y+h\\left(\\tfrac{25}{216}k_1+\\tfrac{1408}{2565}k_3+\\tfrac{2197}{4104}k_4-\\tfrac{1}{5}k_5\\right),\\\\\ny_5&=y+h\\left(\\tfrac{16}{135}k_1+\\tfrac{6656}{12825}k_3+\\tfrac{28561}{56430}k_4-\\tfrac{9}{50}k_5+\\tfrac{2}{55}k_6\\right).\n\\end{aligned}\n$$\n使用 $y_{\\mathrm{trial}}=y_5$ 作为试探解，$y_{\\mathrm{accept}}=y_5$ 作为接受解，误差估计为 $E=|y_5-y_4|$。每次试探步（无论是否接受）精确计算 $6$ 次函数求值。\n\n步长加倍策略（基于经典四阶龙格-库塔方法）：\n- 步长为 $h$ 的经典四阶龙格-库塔步进公式为\n$$\n\\begin{aligned}\nK_1&=f(t,y),\\quad K_2=f\\!\\left(t+\\tfrac{h}{2},y+\\tfrac{h}{2}K_1\\right),\\quad K_3=f\\!\\left(t+\\tfrac{h}{2},y+\\tfrac{h}{2}K_2\\right),\\\\\nK_4&=f\\!\\left(t+h,y+hK_3\\right),\\quad \\Phi_h(y)=y+\\tfrac{h}{6}\\left(K_1+2K_2+2K_3+K_4\\right).\n\\end{aligned}\n$$\n对于每次试探步，计算 $y^{(1)}=\\Phi_h(y)$ 和 $y^{(2)}=\\Phi_{h/2}(\\Phi_{h/2}(y))$。使用 $y_{\\mathrm{trial}}=y^{(2)}$ 作为试探解，$y_{\\mathrm{accept}}=y^{(2)}$ 作为接受解，并使用 Richardson 误差估计\n$$\nE=\\frac{|\\,y^{(2)}-y^{(1)}\\,|}{2^4-1}=\\frac{|\\,y^{(2)}-y^{(1)}\\,|}{15}.\n$$\n每次试探步（无论是否接受）精确计算 $12$ 次函数求值（一个全步长消耗 $4$ 次求值，两个半步长消耗 $8$ 次求值）。\n\n测试套件：\n对于下方的每个用例 $i\\in\\{1,2,3\\}$，程序必须使用相同的 $(t_0,t_f,y_0,\\text{rtol},\\text{atol})$ 运行两种策略，并生成在“要求的最终输出格式”中指定的输出。\n- 用例 1（平滑线性）：$f(t,y)=-2y+t$，$t_0=0$，$t_f=10$，$y_0=1$，$\\text{rtol}=10^{-6}$，$\\text{atol}=10^{-9}$。\n- 用例 2（振荡强迫项，弧度）：$f(t,y)=50\\cos(50t)-y$，$t_0=0$，$t_f=2$，$y_0=0$，$\\text{rtol}=10^{-5}$，$\\text{atol}=10^{-7}$。\n- 用例 3（逻辑斯谛增长）：$f(t,y)=y(1-y)$，$t_0=0$，$t_f=10$，$y_0=10^{-6}$，$\\text{rtol}=10^{-7}$，$\\text{atol}=10^{-12}$。\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中包含一个有三个条目（每个测试用例一个）的列表，每个条目是以下形式的列表\n$$\n[\\;N_{\\mathrm{RKF45}},\\;N_{\\mathrm{SD}},\\;\\overline{h}_{\\mathrm{RKF45}},\\;\\overline{h}_{\\mathrm{SD}}\\;],\n$$\n其中 $N_{\\mathrm{RKF45}}$ 是嵌入式龙格-库塔-菲尔伯格方法使用的函数求值总次数，$N_{\\mathrm{SD}}$ 是步长加倍策略使用的函数求值总次数，$\\overline{h}_{\\mathrm{RKF45}}$ 是嵌入式龙格-库塔-菲尔伯格方法在 $[t_0,t_f]$ 区间上所有被接受步长的算术平均值，$\\overline{h}_{\\mathrm{SD}}$ 是步长加倍策略在 $[t_0,t_f]$ 区间上所有被接受步长的算术平均值。输出必须以 Python 列表的精确格式打印为单行，例如：\n[[N1_RKF45,N1_SD,mean_h1_RKF45,mean_h1_SD],[N2_RKF45,N2_SD,mean_h2_RKF45,mean_h2_SD],[N3_RKF45,N3_SD,mean_h3_RKF45,mean_h3_SD]]\n\n不应打印任何额外文本。", "solution": "该任务是实现并比较两种用于求解标量常微分方程（ODEs）的自适应步长控制策略。自适应积分的基本原理是动态调整步长 $h$，以确保每步的局部截断误差保持在用户定义的容差范围内。这种方法比使用固定步长的效率要高得多，因为它允许积分器在解平滑时采取大步长，在解变化迅速时采取小步长。\n\n两种策略的控制机制均由一个通用框架管理。在每个时间点 $t$ 和对应的解 $y$，尝试一次大小为 $h$ 的试探步。这将产生一个试探解 $y_{\\mathrm{trial}}$ 和一个局部误差的估计值 $E \\ge 0$。如果 $E \\le T$，则该步被认为是可接受的，其中 $T$ 是容差，定义为相对容差和绝对容差的组合：$T = \\text{atol} + \\text{rtol} \\cdot s$，尺度因子 $s = \\max\\{|y|, |y_{\\mathrm{trial}}|\\}$。如果该步被接受，解将推进到 $(t+h, y_{\\mathrm{accept}})$。\n\n无论步长被接受还是拒绝，下一次试探的步长 $h_{\\text{new}}$ 都会根据观测到的误差进行计算。问题指定了一个标准的更新规则：\n$$\nh_{\\text{new}} = g \\cdot h_{\\text{old}}\n$$\n其中 $g$ 是一个增长因子。对于一个局部误差估计表现为 $\\mathcal{O}(h^q)$ 的方法，理想的因子应为 $(T/E)^{1/q}$。为确保稳定性，该因子会受到调节：\n$$\ng =\n\\begin{cases}\n\\max\\left(g_{\\min}, \\min\\left(g_{\\max}, \\sigma \\left(\\frac{T}{\\max(E, \\varepsilon)}\\right)^{1/q}\\right)\\right), & E > 0 \\\\\ng_{\\max}, & E = 0\n\\end{cases}\n$$\n这里，$\\sigma < 1$ 是一个安全因子，$\\varepsilon$ 是一个极小的数用以防止除以零，而 $g_{\\min}$ 和 $g_{\\max}$ 是防止步长剧烈变化的界限。新的步长也会被限制在 $[h_{\\min}, h_{\\max}]$ 范围内。问题指定了 $q=5$，$\\sigma=0.9$，$g_{\\min}=0.2$，$g_{\\max}=5$ 和 $\\varepsilon=10^{-30}$。\n\n这两种策略的唯一区别在于它们如何计算试探解和误差估计 $E$。\n\n**1. 嵌入式龙格-库塔-菲尔伯格 $4(5)$ 方法 (RKF45)**\n\n这是一种“嵌入式”方法，它使用一对不同阶（$p=4$ 和 $p+1=5$）的龙格-库塔公式，这些公式共享中间的函数求值（级），以最小化计算成本。对于给定的步长 $h$，该方法计算六个级，$k_1, \\dots, k_6$，然后通过线性组合它们来产生两个近似解：一个四阶解 $y_4$ 和一个五阶解 $y_5$。\n$$\ny_4 = y + h \\sum_{i=1}^6 b_i k_i, \\quad y_5 = y + h \\sum_{i=1}^6 b_i^* k_i\n$$\n问题指定使用更高阶的解来推进积分，因此 $y_{\\mathrm{trial}} = y_5$ 且 $y_{\\mathrm{accept}} = y_5$。这两个解之间的差值为低阶方法的局部截断误差提供了一个渐近正确的估计：\n$$\nE = |y_5 - y_4| = \\mathcal{O}(h^5)\n$$\n这个误差估计被用于步长控制逻辑中。由于误差估计是 $5$ 阶的，指定的控制器参数 $q=5$是合适的。整个过程每次试探步需要 $6$ 次函数求值。\n\n**2. 步长加倍法与经典四阶龙格-库塔 (RK4)**\n\n该策略基于 Richardson 外推法，使用单一的底层方法（RK4，阶为 $p=4$）来生成误差估计。对于期望的步长 $h$，解从 $t$ 推进到 $t+h$ 的过程通过两种不同的方式完成：\n- 一次大小为 $h$ 的单步，得到 $y^{(1)} = \\Phi_h(y)$。\n- 两次连续的大小为 $h/2$ 的步长，得到 $y^{(2)} = \\Phi_{h/2}(\\Phi_{h/2}(y))$。\n\n更精确的解 $y^{(2)}$ 的局部截断误差可以通过两个结果之间的差值来估计：\n$$\nE = \\frac{|y^{(2)} - y^{(1)}|}{2^p - 1} = \\frac{|y^{(2)} - y^{(1)}|}{15}\n$$\n这个误差估计也是 $\\mathcal{O}(h^{p+1}) = \\mathcal{O}(h^5)$ 阶的，使得 $q=5$ 成为步长控制器的正确选择。问题指定用更精确的结果来推进解，即 $y_{\\text{accept}} = y^{(2)}$。这项技术计算成本较高；一次试探需要一个全步长（$4$ 次函数求值）和两个半步长（$2 \\times 4 = 8$ 次求值），总共 $12$ 次函数求值，因为没有任何级的计算被共享。\n\n该程序围绕一个实现主控制循环的通用自适应积分函数构建。此函数接受一个“步进器”（stepper）函数作为参数，该函数封装了特定于 RKF45 或步长加倍法的逻辑。这种设计将控制逻辑与误差估计方法清晰地分离开来。主脚本定义了三个指定的 ODE 问题，并对每个问题调用积分器两次——一次使用 RKF45 步进器，一次使用步长加倍步进器——以计算并报告所需的性能指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# --- Global constants for step-size control ---\nSIGMA = 0.9\nG_MIN = 0.2\nG_MAX = 5.0\nEPSILON = 1e-30\nH_MIN = 1e-12\nQ_ORDER = 5.0\n\n# --- Stepper implementation for RKF45 ---\ndef rkf45_step(f, t, y, h):\n    \"\"\"\n    Performs one trial step using the Runge-Kutta-Fehlberg 4(5) method.\n    \"\"\"\n    # Fehlberg coefficients\n    k1 = f(t, y)\n    k2 = f(t + 1/4 * h, y + h * (1/4 * k1))\n    k3 = f(t + 3/8 * h, y + h * (3/32 * k1 + 9/32 * k2))\n    k4 = f(t + 12/13 * h, y + h * (1932/2197 * k1 - 7200/2197 * k2 + 7296/2197 * k3))\n    k5 = f(t + h, y + h * (439/216 * k1 - 8 * k2 + 3680/513 * k3 - 845/4104 * k4))\n    k6 = f(t + 1/2 * h, y + h * (-8/27 * k1 + 2 * k2 - 3544/2565 * k3 + 1859/4104 * k4 - 11/40 * k5))\n\n    # 4th and 5th order solutions\n    y4 = y + h * (25/216 * k1 + 1408/2565 * k3 + 2197/4104 * k4 - 1/5 * k5)\n    y5 = y + h * (16/135 * k1 + 6656/12825 * k3 + 28561/56430 * k4 - 9/50 * k5 + 2/55 * k6)\n\n    # Use 5th order for trial and acceptance\n    y_trial = y5\n    y_accept = y5\n\n    # Error estimate is the difference between the two\n    error_est = abs(y5 - y4)\n    \n    # 6 function evaluations per trial step\n    f_evals = 6\n    \n    return y_trial, y_accept, error_est, f_evals\n\n# --- Stepper implementation for Step-Doubling RK4 ---\ndef rk4_single_step(f, t, y, h):\n    \"\"\"\n    Performs a single step of the classical 4th order Runge-Kutta method.\n    \"\"\"\n    k1 = f(t, y)\n    k2 = f(t + h/2.0, y + h/2.0 * k1)\n    k3 = f(t + h/2.0, y + h/2.0 * k2)\n    k4 = f(t + h, y + h * k3)\n    return y + h/6.0 * (k1 + 2*k2 + 2*k3 + k4)\n\ndef sd_rk4_step(f, t, y, h):\n    \"\"\"\n    Performs one trial step using step-doubling with the RK4 method.\n    \"\"\"\n    # One step of size h\n    y1 = rk4_single_step(f, t, y, h)\n    \n    # Two steps of size h/2\n    y_mid = rk4_single_step(f, t, y, h/2.0)\n    y2 = rk4_single_step(f, t + h/2.0, y_mid, h/2.0)\n\n    # Use the more accurate solution for trial and acceptance\n    y_trial = y2\n    y_accept = y2\n    \n    # Richardson error estimate\n    error_est = abs(y2 - y1) / 15.0\n    \n    # 12 function evaluations per trial step (4 for full step, 8 for two half-steps)\n    f_evals = 12\n    \n    return y_trial, y_accept, error_est, f_evals\n\n# --- Generic adaptive ODE integrator ---\ndef integrate(f, t0, tf, y0, rtol, atol, stepper_func):\n    \"\"\"\n    Integrates an ODE using an adaptive step-size strategy.\n    \"\"\"\n    t = float(t0)\n    y = float(y0)\n    \n    h_max = float(tf - t0)\n    h = h_max / 50.0\n\n    total_f_evals = 0\n    accepted_h_sum = 0.0\n    accepted_steps_count = 0\n\n    while t < tf:\n        if t + h > tf:\n            h = tf - t\n\n        y_trial, y_accept, E, f_evals = stepper_func(f, t, y, h)\n        total_f_evals += f_evals\n        \n        s = max(abs(y), abs(y_trial))\n        T = atol + rtol * s\n\n        accepted = (E <= T)\n\n        if accepted:\n            accepted_h_sum += h\n            accepted_steps_count += 1\n            t += h\n            y = y_accept\n\n        # Step-size update logic\n        if E > 0:\n            g = max(G_MIN, min(G_MAX, SIGMA * (T / max(E, EPSILON))**(1.0/Q_ORDER)))\n        else: # E == 0 implies error is smaller than machine precision\n            g = G_MAX\n        \n        h = max(H_MIN, min(h_max, g * h))\n\n    mean_h = accepted_h_sum / accepted_steps_count if accepted_steps_count > 0 else 0.0\n    \n    return total_f_evals, mean_h\n\n# --- Main solution function ---\ndef solve():\n    \"\"\"\n    Defines test cases and runs the comparison, printing the final result.\n    \"\"\"\n    # Define the ODE functions for the test cases\n    def f1(t, y): return -2.0 * y + t\n    def f2(t, y): return 50.0 * math.cos(50.0 * t) - y\n    def f3(t, y): return y * (1.0 - y)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: smooth linear\n        (f1, 0.0, 10.0, 1.0, 1e-6, 1e-9),\n        # Case 2: oscillatory forcing\n        (f2, 0.0, 2.0, 0.0, 1e-5, 1e-7),\n        # Case 3: logistic growth\n        (f3, 0.0, 10.0, 1e-6, 1e-7, 1e-12)\n    ]\n\n    results = []\n    for case in test_cases:\n        f, t0, tf, y0, rtol, atol = case\n        \n        # Run RKF45 strategy\n        n_rkf45, h_avg_rkf45 = integrate(f, t0, tf, y0, rtol, atol, rkf45_step)\n        \n        # Run Step-Doubling RK4 strategy\n        n_sd, h_avg_sd = integrate(f, t0, tf, y0, rtol, atol, sd_rk4_step)\n        \n        results.append([n_rkf45, n_sd, h_avg_rkf45, h_avg_sd])\n\n    # Final print statement in the exact required format.\n    print(str(results))\n\nsolve()\n```", "id": "2372273"}, {"introduction": "在计算物理学中，某些问题不仅要求精度，还需要保持系统的基本物理结构，例如哈密顿系统中的能量守恒。本练习将探索自适应方法与辛积分器（专为此类问题设计）之间有趣的交叉领域。您将研究在控制局部误差时使用可变步长（这会破坏严格的辛性）所带来的关键权衡，并评估其对长期能量守恒的影响。[@problem_id:2372254]", "problem": "考虑一个单自由度单摆，其被建模为一个可分的哈密顿系统，具有广义坐标 $q$（角度，单位为弧度）和正则动量 $p$（角动量，无量纲单位）。使用无量纲化的哈密顿量\n$$\nH(q,p) = \\frac{p^{2}}{2} + 1 - \\cos(q),\n$$\n由此可得哈密顿方程\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = p,\\qquad \\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -\\sin(q).\n$$\n角度必须以弧度为单位进行处理。时间是无量纲的。能量是无量纲的。\n\n您的任务如下，从哈密顿方程的基本原理以及可分哈密顿量 $H(q,p) = T(p) + V(q)$ 的定义出发：\n\n- 实现一个适用于可分哈密顿系统的固定步长、二阶辛积分器（例如，一种通过组合 $T(p)$ 和 $V(q)$ 的精确流构成的方法，当时间步长恒定时，该方法通常被认为是辛的）。使用此方法以恒定步长对 $(q,p)$ 进行长时间演化。\n\n- 为同一个辛方法实现一个自适应步长控制器，采用步长加倍法：给定一个大小为 $h$ 的步长，比较执行一次大小为 $h$ 的完整步长所产生的状态与执行两次大小为 $h/2$ 的半步长所产生的状态。使用状态空间中的欧几里得范数，\n$$\n\\lVert \\Delta \\mathbf{y} \\rVert_2 = \\sqrt{(q_{2} - q_{1})^{2} + (p_{2} - p_{1})^{2}},\n$$\n作为局部误差指示器，以根据指定的标量容差接受或拒绝一个步长。如果步长被接受，则使用更精确的两次半步长的结果进行演化。设计您的控制器，使其能根据从第一性原理推导出的方法的局部截断误差阶来调整 $h$，并包含最小和最大步长的安全措施。请注意，以这种方式改变 $h$ 通常会破坏精确的辛性；但您仍必须实现并测试它。\n\n- 实现一个经典四阶的非辛显式 Runge–Kutta 方法，并为其配备一个自适应步长控制器，该控制器使用与上述相同的步长加倍策略和欧几里得范数误差指示器。步长自适应应基于从第一性原理推导出的方法的局部截断误差阶。\n\n对于每次模拟，计算最终时间 $T$ 的相对能量漂移，\n$$\n\\delta_H = \\frac{\\lvert H(q(T),p(T)) - H(q(0),p(0)) \\rvert}{H(q(0),p(0))}.\n$$\n\n测试套件（角度单位为弧度；时间无量纲）：\n- 情况 1（理想路径，中等振幅）：\n  - 初始状态：$q(0) = 1.0$, $p(0) = 0.0$。\n  - 最终时间：$T = 100.0$。\n  - 自适应控制器容差：$\\text{tol} = 10^{-5}$。\n  - 固定辛步长：$h_{\\text{fixed}} = 0.05$。\n  - 自适应控制器设置：初始步长 $h_{\\text{init}} = 0.05$，最小步长 $h_{\\min} = 10^{-6}$，最大步长 $h_{\\max} = 0.2$。\n- 情况 2（接近分界线，强非线性）：\n  - 初始状态：$q(0) = 2.9$, $p(0) = 0.0$。\n  - 最终时间：$T = 50.0$。\n  - 自适应控制器容差：$\\text{tol} = 10^{-5}$。\n  - 固定辛步长：$h_{\\text{fixed}} = 0.02$。\n  - 自适应控制器设置：初始步长 $h_{\\text{init}} = 0.02$，最小步长 $h_{\\min} = 10^{-6}$，最大步长 $h_{\\max} = 0.2$。\n- 情况 3（较高动量，混合尺度）：\n  - 初始状态：$q(0) = 0.3$, $p(0) = 1.2$。\n  - 最终时间：$T = 100.0$。\n  - 自适应控制器容差：$\\text{tol} = 2\\times 10^{-5}$。\n  - 固定辛步长：$h_{\\text{fixed}} = 0.04$。\n  - 自适应控制器设置：初始步长 $h_{\\text{init}} = 0.04$，最小步长 $h_{\\min} = 10^{-6}$，最大步长 $h_{\\max} = 0.2$。\n\n对于每种情况，计算三个浮点数结果：\n- 固定步长辛积分器在 $t = T$ 时的相对能量漂移 $\\delta_H$。\n- 辛方法的自适应步长版本（步长加倍法控制）在 $t = T$ 时的相对能量漂移 $\\delta_H$。\n- 经典四阶 Runge–Kutta 方法的自适应步长版本（步长加倍法控制）在 $t = T$ 时的相对能量漂移 $\\delta_H$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，该输出是一个由方括号括起来的逗号分隔列表。该列表必须按以下顺序包含 $9$ 个浮点数：\n  - $\\big[\\delta_{H,\\text{fixed}}^{(1)}, \\delta_{H,\\text{adapt-sympl}}^{(1)}, \\delta_{H,\\text{adapt-RK4}}^{(1)}, \\delta_{H,\\text{fixed}}^{(2)}, \\delta_{H,\\text{adapt-sympl}}^{(2)}, \\delta_{H,\\text{adapt-RK4}}^{(2)}, \\delta_{H,\\text{fixed}}^{(3)}, \\delta_{H,\\text{adapt-sympl}}^{(3)}, \\delta_{H,\\text{adapt-RK4}}^{(3)}\\big]$。\n- 每个浮点数需使用恰好 $6$ 位有效数字的科学记数法表示（例如，$1.234560\\times 10^{-4}$ 应打印为 $1.234560\\mathrm{e}{-04}$）。程序不得打印任何其他内容。\n\n您的实现必须是一个完整的、可运行的现代编程语言程序，且不得需要任何用户输入或外部文件。数值算法必须根据所提供的基本原理推导并显式实现；不要调用外部库中的黑箱 ODE 求解器。角度必须以弧度为单位。如上所述，时间、动量和能量均无量纲。", "solution": "所给出的问题陈述是有效的。这是一个基于经典哈密顿力学和数值分析原理的、适定的初值问题。唯一解所需的所有参数和条件都已提供，任务也定义清晰且科学合理。因此，我将继续提供完整的解决方案。\n\n所研究的系统是一个单摆，由无量纲化的可分哈密顿量描述：\n$$\nH(q,p) = T(p) + V(q) = \\frac{p^2}{2} + (1 - \\cos(q))\n$$\n其中 $q$ 是广义坐标（角度），$p$ 是正则动量。其动力学由哈密顿方程决定：\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = p, \\qquad \\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -\\sin(q)\n$$\n\n我们的任务是实现并比较三种数值积分方案。每种方法的性能将通过计算在最终时间 $T$ 的相对能量漂移 $ \\delta_H $ 来评估：\n$$\n\\delta_H = \\frac{\\lvert H(q(T),p(T)) - H(q(0),p(0)) \\rvert}{H(q(0),p(0))}\n$$\n\n### 1. 二阶辛积分器\n\n对于可分哈密顿量，可以通过组合对应于动能 $T(p)$ 和势能 $V(q)$ 的精确流来构造辛积分器。步长为 $h$ 的时间演化算子 $e^{h L_H}$ 可以使用对称分裂（如 Strang 分裂）来近似，该分裂是二阶精确的。\n$$\n\\Phi_h \\approx \\Phi_V(h/2) \\circ \\Phi_T(h) \\circ \\Phi_V(h/2)\n$$\n在这里，$\\Phi_T(\\tau)$ 是在哈密顿量 $T(p)$ 下演化时间 $\\tau$ 的精确流，$\\Phi_V(\\tau)$ 是在哈密顿量 $V(q)$ 下演化时间 $\\tau$ 的精确流。\n\n在 $T(p) = p^2/2$ 下的流产生：\n$$\n\\frac{dq}{dt} = p, \\qquad \\frac{dp}{dt} = 0 \\quad \\implies \\quad q(\\tau) = q(0) + \\tau p(0), \\quad p(\\tau) = p(0)\n$$\n在 $V(q) = 1 - \\cos(q)$ 下的流产生：\n$$\n\\frac{dq}{dt} = 0, \\qquad \\frac{dp}{dt} = -\\sin(q) \\quad \\implies \\quad q(\\tau) = q(0), \\quad p(\\tau) = p(0) - \\tau \\sin(q(0))\n$$\n\n将组合 $\\Phi_V(h/2) \\circ \\Phi_T(h) \\circ \\Phi_V(h/2)$ 应用于状态 $(q_n, p_n)$ 以获得 $(q_{n+1}, p_{n+1})$，得到 Størmer-Verlet 或蛙跳积分格式：\n\\begin{enumerate}\n    \\item 将动量更新半步：$p_{n+1/2} = p_n - \\frac{h}{2} \\sin(q_n)$\n    \\item 使用新动量将位置更新一整步：$q_{n+1} = q_n + h \\cdot p_{n+1/2}$\n    \\item 使用新位置将动量更新第二个半步：$p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\sin(q_{n+1})$\n\\end{enumerate}\n对于固定的步长 $h$，此方法是辛的，意味着它精确地保持一个邻近的影子哈密顿量，从而带来出色的长期能量稳定性（能量误差有界）。对于固定步长的模拟，该方案以恒定的 $h$ 重复应用。\n\n### 2. 自适应步长控制\n\n自适应步长控制器会调整步长 $h$，以将局部误差估计值维持在给定的容差 $\\text{tol}$ 以下。问题指定了步长加倍法。给定状态 $\\mathbf{y}_n = (q_n, p_n)^T$，我们用两种方式计算在 $t_n+h$ 时的状态：\n\\begin{enumerate}\n    \\item 一次大小为 $h$ 的步长：$\\mathbf{y}_1 = \\Psi_h(\\mathbf{y}_n)$\n    \\item 两次大小为 $h/2$ 的步长：$\\mathbf{y}_2 = \\Psi_{h/2}(\\Psi_{h/2}(\\mathbf{y}_n))$\n\\end{enumerate}\n其中 $\\Psi_h$ 是单步的数值积分映射。\n\n对于一个 $p$ 阶方法，局部截断误差为 $O(h^{p+1})$。较不精确解 $\\mathbf{y}_1$ 的误差约为 $C h^{p+1}$，而较精确解 $\\mathbf{y}_2$ 的误差约为 $2C(h/2)^{p+1} = C h^{p+1}/2^p$。差值 $\\Delta \\mathbf{y} = \\mathbf{y}_1 - \\mathbf{y}_2$ 可作为局部误差的估计。我们使用其欧几里得范数 $\\text{err} = \\lVert \\Delta \\mathbf{y} \\rVert_2$ 作为误差指示器。\n\n步长控制逻辑如下：\n- 如果 $\\text{err} \\le \\text{tol}$，则接受该步长。状态推进至 $\\mathbf{y}_{n+1} = \\mathbf{y}_2$（更精确的结果）。\n- 如果 $\\text{err} > \\text{tol}$，则拒绝该步长，并选择一个更小的步长从 $\\mathbf{y}_n$ 重试。\n\n新的步长 $h_{\\text{new}}$ 通过将当前误差与期望容差关联来确定。由于 $\\text{err} \\propto h^{p+1}$，我们期望 $\\text{tol} \\propto h_{\\text{new}}^{p+1}$。这导出了更新规则：\n$$\nh_{\\text{new}} = S \\cdot h \\left( \\frac{\\text{tol}}{\\text{err}} \\right)^{\\frac{1}{p+1}}\n$$\n其中 $S$ 是一个安全因子（通常 $S \\approx 0.9$）以防止频繁的拒绝。步长也受到最小值 $h_{\\min}$ 和最大值 $h_{\\max}$ 的限制。对于二阶辛积分器，阶数为 $p=2$。改变步长会破坏方法的精确辛性，但与非辛方法相比，它仍能提供更好的能量守恒性。\n\n### 3. 四阶 Runge-Kutta 方法 (RK4)\n\n作为比较，使用一种非辛方法：经典的四阶 Runge-Kutta 方法。对于 ODE 系统 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$，步长为 $h$ 的更新规则是：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h\\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n在我们的问题中，$\\mathbf{y} = (q, p)^T$，函数 $\\mathbf{f}(\\mathbf{y}) = (p, -\\sin(q))^T$ 是自治的。此方法非辛，预计在长时间积分中会表现出长期的能量漂移。\n\nRK4 的自适应步长控制采用相同的步长加倍策略。唯一的区别是方法的阶数，即 $p=4$。因此，步长自适应公式使用指数 $1/(p+1) = 1/5$。实现将遵循与自适应辛积分器相同的逻辑，但使用 RK4 步进函数和相应的阶数。", "answer": "```python\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#     - name: numpy\n#       version: 1.23.5\n#     - name: scipy\n#       version: 1.11.4\n\ndef hamiltonian(y):\n    \"\"\"Computes the Hamiltonian for a given state vector y = [q, p].\"\"\"\n    q, p = y\n    return p**2 / 2.0 + 1.0 - np.cos(q)\n\ndef f_ode(y):\n    \"\"\"RHS of the ODE system dy/dt = f(y) for RK4.\"\"\"\n    q, p = y\n    return np.array([p, -np.sin(q)])\n\ndef step_symplectic(y, h):\n    \"\"\"Performs a single step of the 2nd-order symplectic leapfrog integrator.\"\"\"\n    q, p = y\n    p_half = p - (h / 2.0) * np.sin(q)\n    q_new = q + h * p_half\n    p_new = p_half - (h / 2.0) * np.sin(q_new)\n    return np.array([q_new, p_new])\n\ndef step_rk4(y, h):\n    \"\"\"Performs a single step of the classical 4th-order Runge-Kutta method.\"\"\"\n    k1 = f_ode(y)\n    k2 = f_ode(y + h / 2.0 * k1)\n    k3 = f_ode(y + h / 2.0 * k2)\n    k4 = f_ode(y + h * k3)\n    return y + h / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\ndef solve_fixed_symplectic(y0, T, h):\n    \"\"\"Solves the ODE with the fixed-step symplectic integrator.\"\"\"\n    t = 0.0\n    y = np.copy(y0)\n    num_steps = int(np.ceil(T / h))\n    for _ in range(num_steps):\n        # Adjust last step to land exactly on T\n        current_h = min(h, T - t)\n        if current_h <= 0: break\n        y = step_symplectic(y, current_h)\n        t += current_h\n    return y\n\ndef solve_adaptive(y0, T, h_init, tol, h_min, h_max, step_func, p_order):\n    \"\"\"Generic adaptive step size solver using step-doubling.\"\"\"\n    t = 0.0\n    y = np.copy(y0)\n    h = h_init\n    S = 0.9  # Safety factor\n\n    while t < T:\n        h = min(h, T - t)\n        \n        step_accepted = False\n        while not step_accepted:\n            if h < h_min:\n                h = h_min\n\n            # Perform one big step and two small steps\n            y1 = step_func(y, h)\n            y_mid = step_func(y, h / 2.0)\n            y2 = step_func(y_mid, h / 2.0)\n\n            # Calculate error\n            err = np.linalg.norm(y1 - y2)\n            if err == 0.0:\n                err = 1e-16  # Avoid division by zero, allow h to grow\n\n            # Step control logic\n            if err <= tol:\n                # Accept step\n                step_accepted = True\n                t += h\n                y = y2  # Use the more accurate result\n                \n                # Propose step size for the next iteration\n                h_new = S * h * (tol / err)**(1.0 / (p_order + 1.0))\n                h = min(h_max, h_new)\n            else:\n                # Reject step, reduce step size for retry\n                h_new = S * h * (tol / err)**(1.0 / (p_order + 1.0))\n                h = max(h_min, h_new)\n                \n                # Prevent infinite loop if h_min is too large for the tolerance\n                if h <= h_min and err > tol:\n                    step_accepted = True\n                    t += h\n                    y = y2\n    return y\n    \ndef solve():\n    \"\"\"Main function to run test cases and produce the final output.\"\"\"\n    test_cases = [\n        {\n            \"q0\": 1.0, \"p0\": 0.0, \"T\": 100.0, \"tol\": 1e-5,\n            \"h_fixed\": 0.05, \"h_init\": 0.05, \"h_min\": 1e-6, \"h_max\": 0.2\n        },\n        {\n            \"q0\": 2.9, \"p0\": 0.0, \"T\": 50.0, \"tol\": 1e-5,\n            \"h_fixed\": 0.02, \"h_init\": 0.02, \"h_min\": 1e-6, \"h_max\": 0.2\n        },\n        {\n            \"q0\": 0.3, \"p0\": 1.2, \"T\": 100.0, \"tol\": 2e-5,\n            \"h_fixed\": 0.04, \"h_init\": 0.04, \"h_min\": 1e-6, \"h_max\": 0.2\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        y0 = np.array([case[\"q0\"], case[\"p0\"]])\n        h0 = hamiltonian(y0)\n\n        # 1. Fixed-step symplectic integrator\n        y_final_fixed = solve_fixed_symplectic(y0, case[\"T\"], case[\"h_fixed\"])\n        h_final_fixed = hamiltonian(y_final_fixed)\n        drift_fixed = abs(h_final_fixed - h0) / h0 if h0 != 0 else abs(h_final_fixed - h0)\n        results.append(drift_fixed)\n\n        # 2. Adaptive-step symplectic integrator\n        y_final_adapt_sympl = solve_adaptive(y0, case[\"T\"], case[\"h_init\"], case[\"tol\"], case[\"h_min\"], case[\"h_max\"], step_symplectic, p_order=2)\n        h_final_adapt_sympl = hamiltonian(y_final_adapt_sympl)\n        drift_adapt_sympl = abs(h_final_adapt_sympl - h0) / h0 if h0 != 0 else abs(h_final_adapt_sympl - h0)\n        results.append(drift_adapt_sympl)\n\n        # 3. Adaptive-step RK4 integrator\n        y_final_adapt_rk4 = solve_adaptive(y0, case[\"T\"], case[\"h_init\"], case[\"tol\"], case[\"h_min\"], case[\"h_max\"], step_rk4, p_order=4)\n        h_final_adapt_rk4 = hamiltonian(y_final_adapt_rk4)\n        drift_adapt_rk4 = abs(h_final_adapt_rk4 - h0) / h0 if h0 != 0 else abs(h_final_adapt_rk4 - h0)\n        results.append(drift_adapt_rk4)\n\n    # Format the final output string\n    output_str = \",\".join([\"{:.6e}\".format(r) for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2372254"}]}