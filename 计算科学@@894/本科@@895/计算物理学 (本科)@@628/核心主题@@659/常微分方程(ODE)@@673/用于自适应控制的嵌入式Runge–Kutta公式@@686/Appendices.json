{"hands_on_practices": [{"introduction": "嵌入式龙格-库塔方法的核心在于其内置的误差估计器，它使得自适应步长控制成为可能。但是这个误差估计器究竟是如何工作的呢？这个练习将通过一个思想实验来揭开它的神秘面纱。你将故意“破坏”误差估计器——使用一组错误的系数来计算局部误差。[@problem_id:2388676]\n\n通过比较这个“有缺陷”的求解器与正常求解器的最终全局误差，你将亲身体会到局部误差控制如何直接影响解的整体精度。这个实践强调了一个基本原则：一个可靠的自适应求解器，其性能严重依赖于一个理论上正确的误差估计策略。", "problem": "设计并实现一个基于嵌入式 Runge–Kutta 对的自适应步长积分器，以研究不正确的局部误差估计如何影响全局误差。纯粹在常微分方程初值问题的数学设定下进行工作。您必须使用的基本依据是初值问题的定义、局部截断误差以及显式 Runge–Kutta 方法的结构。\n\n问题要求：\n- 考虑由 $y'(t) = f(t,y(t))$ 和 $y(t_{0}) = y_{0}$ 给出的标量常微分方程的初值问题。目标是从 $t_{0}$ 推进到最终时间 $T$。\n- 使用一个显式嵌入式 Runge–Kutta 对，其中两个不同阶的公式共享相同的内部阶段，在每一步提供两个近似值 $y_{n+1}$ 和 $\\hat{y}_{n+1}$。高阶近似值 $y_{n+1}$ 用作步长结果，其差值 $e_{n+1} = y_{n+1} - \\hat{y}_{n+1}$ 用作步长控制的局部误差估计。\n- 实现一对特定的、广泛使用的阶数组合 $p$ 和 $q$（其中 $p > q$）；为确保具体性和可复现性，请使用 Bogacki–Shampine 对，其阶数为 $p=q+1$，即 $p = 3$ 和 $q = 2$。在步长被接受时，使用高阶近似值来推进解。\n- 实现两个版本的自适应控制器：\n  1. 正确的控制器：使用低阶公式的正确嵌入系数来计算局部误差估计 $e_{n+1}$。\n  2. 有缺陷的控制器：通过如下方式有意更改嵌入的低阶权重，以计算一个有缺陷的局部误差估计 $\\hat{e}_{n+1}$：在形成差值之前，交换低阶规则的最后两个权重。换言之，如果低阶权重为 $\\{b_{1}^{(q)}, b_{2}^{(q)}, b_{3}^{(q)}, b_{4}^{(q)}\\}$，有缺陷的控制器在构造 $\\hat{y}_{n+1}$ 时使用 $\\{b_{1}^{(q)}, b_{2}^{(q)}, b_{4}^{(q)}, b_{3}^{(q)}\\}$，因此 $\\hat{e}_{n+1} = y_{n+1} - \\hat{y}_{n+1}$。仅将此有缺陷的估计用于步长接受和步长选择，而在接受步长后，仍然使用高阶近似值 $y_{n+1}$ 来推进解。\n- 对标量状态使用标准误差范数：\n  $$\\mathrm{err\\_norm} = \\frac{|e_{n+1}|}{\\mathrm{atol} + \\mathrm{rtol} \\cdot \\max(|y_{n}|, |y_{n+1}|)}.$$\n  如果 $\\mathrm{err\\_norm} \\le 1$，则接受该步长。\n- 使用一个从 $p$ 阶方法的局部截断误差缩放推导出的步长控制器。如果一个步长被接受或拒绝，提出一个新的步长\n  $$h_{\\mathrm{new}} = h \\cdot s \\cdot \\mathrm{err\\_norm}^{-1/(p+1)},$$\n  其中 $s$ 是一个安全因子。将 $h_{\\mathrm{new}}$ 限制在 $[\\alpha_{\\min} h, \\alpha_{\\max} h]$ 范围内，以避免不稳定的变化。使用 $p = 3$，$s = 0.9$，$\\alpha_{\\min} = 0.2$ 和 $\\alpha_{\\max} = 5$。\n- 在被接受的步长上，使用 Bogacki–Shampine 对的高阶公式来推进解。对两个控制器使用相同的初始步长和控制器参数。\n\n测试问题和精确解：\n- 设 $f(t,y) = \\lambda y$，其中 $\\lambda < 0$，$y(0) = 1$。精确解为 $y(t) = \\exp(\\lambda t)$。\n- 将最终时间 $T$ 处的全局误差定义为\n  $$E = |y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)|.$$\n\n测试套件：\n为以下构成测试套件的参数集提供结果（以下所有数字均为无量纲）：\n- 案例 A (理想路径)：$\\lambda = -1$，$T = 10$，$y_{0} = 1$，$\\mathrm{rtol} = 10^{-3}$，$\\mathrm{atol} = 10^{-12}$。\n- 案例 B (更严格的容差)：$\\lambda = -1$，$T = 10$，$y_{0} = 1$，$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-12}$。\n- 案例 C (更快衰减的动力学)：$\\lambda = -5$，$T = 2$，$y_{0} = 1$，$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-12}$。\n\n每个案例需要计算的内容：\n- 计算两个浮点数：\n  - $E_{\\mathrm{correct}}$：使用正确控制器得到的最终时刻绝对误差。\n  - $E_{\\mathrm{flawed}}$：使用有缺陷控制器得到的最终时刻绝对误差。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，本身是一个双元素列表 $[E_{\\mathrm{correct}}, E_{\\mathrm{flawed}}]$。例如：[[EcA,EfA],[EcB,EfB],[EcC,EfC]]。以一致、紧凑的小数格式打印数值。", "solution": "所提供的问题经过了严格的验证。\n\n**步骤 1：提取已知条件**\n- **初值问题 (IVP)**：一个标量常微分方程 (ODE) $y'(t) = f(t,y(t))$，其初始条件为 $y(t_{0}) = y_{0}$，将从 $t_{0}$ 积分到最终时间 $T$。\n- **数值方法**：一个阶数为 $p=3$ 和 $q=2$ 的显式嵌入式 Runge–Kutta 对，具体为 Bogacki–Shampine 对。高阶 ($p=3$) 的近似值 $y_{n+1}$ 用于推进解。\n- **局部误差估计**：高阶 ($y_{n+1}$) 和低阶 ($\\hat{y}_{n+1}$) 近似值之间的差值 $e_{n+1} = y_{n+1} - \\hat{y}_{n+1}$，用作局部截断误差的估计。\n- **控制器**：\n    1.  **正确的控制器**：使用标准的局部误差估计 $e_{n+1}$。\n    2.  **有缺陷的控制器**：使用一个有缺陷的估计 $\\hat{e}_{n+1} = y_{n+1} - \\hat{y}_{n+1, \\text{flawed}}$，其中 $\\hat{y}_{n+1, \\text{flawed}}$ 是通过交换低阶权重的最后两个元素来计算的。这个有缺陷的估计仅用于步长控制。\n- **误差范数与接受条件**：缩放后的误差范数定义为 $\\mathrm{err\\_norm} = |e_{n+1}| / (\\mathrm{atol} + \\mathrm{rtol} \\cdot \\max(|y_{n}|, |y_{n+1}|))$。如果 $\\mathrm{err\\_norm} \\le 1$，则接受该步长。\n- **步长控制律**：新的步长提议为 $h_{\\mathrm{new}} = h \\cdot s \\cdot \\mathrm{err\\_norm}^{-1/(p+1)}$，其中 $s = 0.9$ 且 $p = 3$。结果被限制在 $[\\alpha_{\\min} h, \\alpha_{\\max} h]$ 范围内，其中 $\\alpha_{\\min} = 0.2$ 和 $\\alpha_{\\max} = 5$。\n- **测试问题**：$f(t,y) = \\lambda y$ 且 $y(0) = 1$。精确解为 $y(t) = \\exp(\\lambda t)$。\n- **全局误差度量**：$E = |y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)|$。\n- **测试案例**：\n    - 案例 A：$\\lambda = -1$, $T = 10$, $y_{0} = 1$, $\\mathrm{rtol} = 10^{-3}$, $\\mathrm{atol} = 10^{-12}$。\n    - 案例 B：$\\lambda = -1$, $T = 10$, $y_{0} = 1$, $\\mathrm{rtol} = 10^{-6}$, $\\mathrm{atol} = 10^{-12}$。\n    - 案例 C：$\\lambda = -5$, $T = 2$, $y_{0} = 1$, $\\mathrm{rtol} = 10^{-6}$, $\\mathrm{atol} = 10^{-12}$。\n- **所需计算**：对每个案例，计算使用正确控制器 ($E_{\\mathrm{correct}}$) 和有缺陷控制器 ($E_{\\mathrm{flawed}}$) 时的最终时刻全局误差。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题定义明确且科学上合理。它涉及计算工程中的一个基本课题：常微分方程自适应数值方法的设计与分析。所有参数和程序都以足够的精度进行了规定，可以进行唯一的实现。唯一未指定的参数是初始步长 $h_0$。这是一个微小的疏漏。为了在两个控制器之间进行可复现的比较，对两者使用相同的、合理的初始步长就足够了。我将假设所有模拟都使用一个小的、固定的初始步长 $h_0$，这是一种标准方法。因此，该问题被认为是有效的。\n\n**步骤 3：结论与行动**\n问题是**有效的**。将提供一个完整的、有理有据的解决方案。\n\n**基本原理与方法**\n\n该问题要求对初值问题 $y'(t) = f(t,y(t))$, $y(t_0) = y_0$ 进行数值积分。这是通过使用自适应步长 Runge-Kutta 方法来实现的。\n\n一个显式 Runge-Kutta 方法通过一系列中间阶段的求值，从 $t_n$ 时刻的解计算出时间 $t_{n+1} = t_n + h_n$ 的解。对于一个 $s$ 级方法，我们有：\n$$k_i = f\\left(t_n + c_i h_n, y_n + h_n \\sum_{j=1}^{i-1} a_{ij} k_j\\right), \\quad i=1, \\dots, s$$\n$$y_{n+1} = y_n + h_n \\sum_{i=1}^s b_i k_i$$\n系数 $c_i$、$a_{ij}$ 和 $b_i$ 定义了具体的方法。\n\n一个嵌入式对使用同一组阶段值 $k_i$，提供两个解：$y_{n+1}$（$p$ 阶）和 $\\hat{y}_{n+1}$（$q < p$ 阶）。\n$$y_{n+1} = y_n + h_n \\sum_{i=1}^s b_i k_i \\quad (\\text{order } p)$$\n$$\\hat{y}_{n+1} = y_n + h_n \\sum_{i=1}^s \\hat{b}_i k_i \\quad (\\text{order } q)$$\n差值 $e_{n+1} = y_{n+1} - \\hat{y}_{n+1} = h_n \\sum_{i=1}^s (b_i - \\hat{b}_i)k_i$ 提供了低阶方法局部截断误差的一个估计。这个误差估计用于控制步长 $h_n$。\n\n**Bogacki–Shampine 3(2) 对**\n\n所指定的 Bogacki–Shampine 方法是一个3级方法，可产生一个3阶解和一个2阶解。它具有“首末同阶”(First Same As Last, FSAL) 的特性，意味着一个步长的最后阶段求值可以复用为后续步长的第一阶段，从而提高效率。其结构如下：\n\n1.  计算三个中间阶段：\n    $$k_1 = f(t_n, y_n)$$\n    $$k_2 = f(t_n + \\frac{1}{2}h, y_n + \\frac{1}{2}h k_1)$$\n    $$k_3 = f(t_n + \\frac{3}{4}h, y_n + \\frac{3}{4}h k_2)$$\n2.  计算3阶近似值，用于推进解：\n    $$y_{n+1} = y_n + h\\left(\\frac{2}{9}k_1 + \\frac{1}{3}k_2 + \\frac{4}{9}k_3\\right)$$\n3.  使用推进后的解 $y_{n+1}$ 计算第四个阶段。这是 FSAL 阶段。\n    $$k_4 = f(t_n + h, y_{n+1})$$\n4.  计算2阶近似值以进行误差估计：\n    $$\\hat{y}_{n+1} = y_n + h\\left(\\frac{7}{24}k_1 + \\frac{1}{4}k_2 + \\frac{1}{3}k_3 + \\frac{1}{8}k_4\\right)$$\n局部误差估计为 $e_{n+1} = y_{n+1} - \\hat{y}_{n+1}$。\n\n**自适应步长控制**\n\n控制器的目标是调整步长 $h$，使局部误差估计满足给定的容差。误差相对于解的大小进行缩放：\n$$\\mathrm{err\\_norm} = \\frac{|e_{n+1}|}{\\mathrm{atol} + \\mathrm{rtol} \\cdot \\max(|y_{n}|, |y_{n+1}|)}$$\n其中 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 分别是绝对和相对误差容差。\n\n如果 $\\mathrm{err\\_norm} \\le 1$，则接受该步长。如果接受，则推进解：$t_{n+1} = t_n + h$，$y_{n+1} = y_{n+1}$。如果拒绝，则用一个更小的 $h$ 重试该步长。\n\n无论哪种情况，都会提出一个新的步长 $h_{\\mathrm{new}}$。基于局部误差行为类似于 $C \\cdot h^{p+1}$ 的假设，从当前误差推导出最优步长：\n$$h_{\\mathrm{new}} = h \\cdot s \\cdot \\left(\\frac{1}{\\mathrm{err\\_norm}}\\right)^{1/(p+1)}$$\n这里，$p=3$ 是用于步长预测的方法阶数，$s=0.9$ 是确保鲁棒性的安全因子。新的步长被裁剪以避免过大或过小的变化：$h_{\\mathrm{new}}$ 被限制在 $[\\alpha_{\\min} h, \\alpha_{\\max} h] = [0.2h, 5.0h]$。\n\n**有缺陷的控制器**\n\n问题要求对一个有缺陷的控制器进行研究。缺陷被引入到局部误差估计中。2阶方法的正确权重为 $\\hat{\\mathbf{b}} = [7/24, 1/4, 1/3, 1/8]$。缺陷在于交换了最后两个权重：\n$$\\hat{\\mathbf{b}}_{\\text{flawed}} = [7/24, 1/4, 1/8, 1/3]$$\n这导致了一个有缺陷的2阶近似：\n$$\\hat{y}_{n+1, \\text{flawed}} = y_n + h\\left(\\frac{7}{24}k_1 + \\frac{1}{4}k_2 + \\frac{1}{8}k_3 + \\frac{1}{3}k_4\\right)$$\n有缺陷的误差估计是 $\\hat{e}_{n+1} = y_{n+1} - \\hat{y}_{n+1, \\text{flawed}}$。然后，这个 $\\hat{e}_{n+1}$ 被用于误差范数计算和随后的步长调整。必须强调的是，即使使用有缺陷的控制器，解仍然是使用正确的3阶公式 $y_{n+1}$ 来推进的。缺陷只影响自适应机制，而不影响传播公式本身。\n\n**算法与实现**\n\n实现的核心将是一个 `adaptive_integrator` 函数，它执行以下循环：\n1.  初始化 $t=t_0$，$y=y_0$ 和一个初始步长 $h=h_0$。我们将使用 $h_0 = 10^{-2}$。计算第一阶段 $k_1 = f(t_0, y_0)$。\n2.  开始主循环，只要 $t < T$ 就继续。\n3.  在循环内部，为步长接受启动一个子循环。\n4.  在子循环中，计算阶段 $k_2, k_3$、3阶解 $y_{n+1}$ 和最终阶段 $k_4$。\n5.  根据控制器类型（正确的或有缺陷的），计算相应的局部误差估计（$e_{n+1}$ 或 $\\hat{e}_{n+1}$）。\n6.  计算误差范数 $\\mathrm{err\\_norm}$。\n7.  如果 $\\mathrm{err\\_norm} \\le 1$，则接受步长。推进时间和解 ($t \\leftarrow t+h, y \\leftarrow y_{n+1}$)。阶段 $k_4$ 成为下一步的新 $k_1$ (FSAL)。退出子循环。\n8.  如果 $\\mathrm{err\\_norm} > 1$，则拒绝步长。当前的 $y_{n+1}$ 被丢弃。子循环以一个新的、更小的步长 $h$ 继续。\n9.  在接受和拒绝的情况下，都使用控制律和裁剪来计算一个新的建议步长 $h_{\\mathrm{new}}$，并更新 $h$。\n10. 主循环在 $t \\ge T$ 时终止。对最后一步的步长进行最终调整，以确保积分恰好在 $T$ 处停止。\n\n此过程将对每个测试案例执行，一次使用正确的控制器，一次使用有缺陷的控制器。最终的全局误差 $E = |y_{\\mathrm{num}}(T) - \\exp(\\lambda T)|$ 随后被计算和报告。有缺陷控制器的行为（与正确的控制器相比，是更激进还是更保守）将决定最终的全局误差是更大还是更小。这个实验展示了全局误差对局部误差估计器正确性的敏感度，而局部误差估计器的正确性是自适应求解器可靠性的基础。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef adaptive_integrator(f, t0, y0, T, rtol, atol, h0, flawed_controller):\n    \"\"\"\n    Integrates an ODE using the adaptive Bogacki-Shampine 3(2) method.\n    \"\"\"\n    # Bogacki-Shampine coefficients and controller parameters\n    # The method structure:\n    # k1 = f(t, y)\n    # k2 = f(t + 1/2 h, y + 1/2 h k1)\n    # k3 = f(t + 3/4 h, y + 3/4 h k2)\n    # y_next = y + h * (2/9 k1 + 1/3 k2 + 4/9 k3)  (order 3 solution)\n    # k4 = f(t + h, y_next)                          (FSAL stage)\n    # error = y_next - y_hat_next, where y_hat_next is the order 2 solution.\n    # The error is computed using a difference of weights for better numerical stability.\n    \n    b3_weights = np.array([2/9, 1/3, 4/9, 0])      # Order 3 weights\n    b2_weights_correct = np.array([7/24, 1/4, 1/3, 1/8]) # Order 2 weights\n    b2_weights_flawed = np.array([7/24, 1/4, 1/8, 1/3])  # Flawed order 2 weights\n\n    if flawed_controller:\n        err_weights = b3_weights - b2_weights_flawed\n    else:\n        err_weights = b3_weights - b2_weights_correct\n\n    s = 0.9\n    p = 3\n    alpha_min = 0.2\n    alpha_max = 5.0\n\n    t = t0\n    y = y0\n    h = h0\n\n    # First stage evaluation (k1) for the first step\n    k1 = f(t, y)\n\n    while t < T:\n        if t + h > T:\n            h = T - t  # Adjust last step to hit T exactly\n\n        step_accepted = False\n        while not step_accepted:\n            # Prevent infinitely small step size\n            if abs(h) < 1e-15 * T:\n                raise RuntimeError(\"Step size has become excessively small.\")\n\n            # Compute stages for BS(3,2)\n            k2 = f(t + 0.5 * h, y + 0.5 * h * k1)\n            k3 = f(t + 0.75 * h, y + 0.75 * h * k2)\n            y_next = y + h * (b3_weights[0] * k1 + b3_weights[1] * k2 + b3_weights[2] * k3)\n            k4 = f(t + h, y_next)\n\n            # Calculate local error estimate\n            local_error = h * (err_weights[0] * k1 + err_weights[1] * k2 + \n                               err_weights[2] * k3 + err_weights[3] * k4)\n\n            # Calculate scaled error norm\n            y_scale = atol + rtol * max(abs(y), abs(y_next))\n            err_norm = abs(local_error) / y_scale if y_scale > 0 else 0\n\n            # Step acceptance logic\n            if err_norm <= 1.0:\n                step_accepted = True\n                t += h\n                y = y_next\n                # FSAL: k4 of this step is k1 of the next\n                k1 = k4\n                \n                # Update step size for the next step\n                if err_norm == 0:\n                    # Avoid division by zero and propose max increase\n                    h_new = h * alpha_max\n                else:\n                    h_new = h * s * (err_norm ** (-1.0 / (p + 1.0)))\n            else:\n                # Step rejected, reduce step size and retry\n                h_new = h * s * (err_norm ** (-1.0 / (p + 1.0)))\n\n            # Clip the new step size\n            h = max(h * alpha_min, min(h * alpha_max, h_new))\n\n    return y\n\ndef solve():\n    \"\"\"\n    Runs the simulation for the specified test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'lambda': -1.0, 'T': 10.0, 'y0': 1.0, 'rtol': 1e-3, 'atol': 1e-12},\n        # Case B\n        {'lambda': -1.0, 'T': 10.0, 'y0': 1.0, 'rtol': 1e-6, 'atol': 1e-12},\n        # Case C\n        {'lambda': -5.0, 'T': 2.0, 'y0': 1.0, 'rtol': 1e-6, 'atol': 1e-12},\n    ]\n\n    results = []\n    h0 = 1e-2  # Fixed initial step size for all runs for fair comparison\n\n    for case in test_cases:\n        lambda_val = case['lambda']\n        T = case['T']\n        y0 = case['y0']\n        rtol = case['rtol']\n        atol = case['atol']\n\n        # Define the ODE and its exact solution\n        f = lambda t, y: lambda_val * y\n        y_exact_func = lambda t: np.exp(lambda_val * t)\n        \n        y_exact_T = y_exact_func(T)\n\n        # Run with correct controller\n        y_num_correct = adaptive_integrator(f, 0, y0, T, rtol, atol, h0, flawed_controller=False)\n        E_correct = abs(y_num_correct - y_exact_T)\n\n        # Run with flawed controller\n        y_num_flawed = adaptive_integrator(f, 0, y0, T, rtol, atol, h0, flawed_controller=True)\n        E_flawed = abs(y_num_flawed - y_exact_T)\n\n        results.append([E_correct, E_flawed])\n\n    # Format the output string as specified\n    output_str = '[' + ','.join([f'[{r[0]:.5e},{r[1]:.5e}]' for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "2388676"}, {"introduction": "在掌握了自适应方法如何实现局部精度控制之后，一个关键问题随之而来：它的局限性在哪里？这个实践将一个标准的自适应龙格-库塔方法应用于天体力学中的经典问题——开普勒问题，这是一个具有能量 $E(t)$ 和角动量 $L(t)$ 等守恒量的物理系统。[@problem_id:2388495]\n\n通过将其数值结果与一种特殊设计的结构保持算法（辛积分器）进行对比，你将观察到能量的长期漂移现象。这次练习将帮助你理解，为什么即使在非常高的精度设置下，通用的自适应求解器通常也不适用于保守系统的长期模拟，并揭示了局部精度与全局结构保持之间的重要区别。", "problem": "考虑无量纲单位下的平面二体（开普勒）问题，引力参数 $ \\mu = 1 $。设状态为 $ y(t) = (x(t), y(t), z(t), v_x(t), v_y(t), v_z(t)) \\in \\mathbb{R}^6 $，其中运动被限制在平面 $ z = 0 $ 上。运动方程为一阶常微分方程 (ODE)\n$$\n\\frac{d}{dt}\n\\begin{pmatrix}\n\\mathbf{r}(t) \\\\\n\\mathbf{v}(t)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{v}(t) \\\\\n- \\frac{\\mathbf{r}(t)}{\\lVert \\mathbf{r}(t) \\rVert^3}\n\\end{pmatrix},\n$$\n其中 $ \\mathbf{r}(t) = (x(t), y(t), z(t)) $ 且 $ \\mathbf{v}(t) = (v_x(t), v_y(t), v_z(t)) $。总比机械能为\n$$\nE(t) = \\frac{1}{2} \\lVert \\mathbf{v}(t) \\rVert^2 - \\frac{1}{\\lVert \\mathbf{r}(t) \\rVert},\n$$\n比角动量矢量为\n$$\n\\mathbf{L}(t) = \\mathbf{r}(t) \\times \\mathbf{v}(t), \\quad L(t) = \\lVert \\mathbf{L}(t) \\rVert.\n$$\n\n您的任务是使用两种不同的数值时间积分器对下面的每个测试用例积分这些ODE：\n- 一种通过使用嵌入式单步公式对来自适应控制局部截断误差的方法，以及\n- 一种保留正则辛形式并使用固定步长的方法。\n\n对于每种方法和每个测试用例，计算守恒量 $ E(t) $ 和 $ L(t) $ 在整个仿真区间内的最大相对漂移。具体来说，如果 $ Q(t) $ 是一个关注量（$ E(t) $ 或 $ L(t) $），初始值为 $ Q(0) = Q_0 $，则报告\n$$\n\\max_{0 \\le t \\le T} \\frac{\\lvert Q(t) - Q_0 \\rvert}{\\lvert Q_0 \\rvert}.\n$$\n所有量都是无量纲的。输出必须是实数（小数），而不是百分比。\n\n使用以下测试套件。每个测试用例指定了初始条件 $ \\mathbf{r}(0) $ 和 $ \\mathbf{v}(0) $（其中 $ z(0) = v_z(0) = 0 $）、最终时间 $ T $、自适应方法的绝对和相对容差 $ (\\text{atol}, \\text{rtol}) $，以及辛方法的固定步长 $ \\Delta t $。令 $ P = 2\\pi $ 表示在这些单位下对应于半长轴 $ a = 1 $ 的轨道周期。\n\n- 测试用例 1（理想路径，中等偏心率）：\n  - $ \\mathbf{r}(0) = (0.7, 0, 0) $\n  - $ \\mathbf{v}(0) = (0, 1.363818169698585, 0) $\n  - $ T = 10 P $\n  - 自适应方法容差：$ \\text{rtol} = 10^{-9} $，$ \\text{atol} = 10^{-12} $\n  - 辛方法固定步长：$ \\Delta t = P/200 $\n\n- 测试用例 2（边界情况，圆形轨道）：\n  - $ \\mathbf{r}(0) = (1, 0, 0) $\n  - $ \\mathbf{v}(0) = (0, 1, 0) $\n  - $ T = 10 P $\n  - 自适应方法容差：$ \\text{rtol} = 10^{-6} $，$ \\text{atol} = 10^{-9} $\n  - 辛方法固定步长：$ \\Delta t = P/50 $\n\n- 测试用例 3（边缘情况，高偏心率）：\n  - $ \\mathbf{r}(0) = (0.2, 0, 0) $\n  - $ \\mathbf{v}(0) = (0, 3.0, 0) $\n  - $ T = 5 P $\n  - 自适应方法容差：$ \\text{rtol} = 10^{-7} $，$ \\text{atol} = 10^{-10} $\n  - 辛方法固定步长：$ \\Delta t = P/400 $\n\n对于每个测试用例，产生四个数字：\n- 自适应方法下 $ E(t) $ 的最大相对漂移，\n- 自适应方法下 $ L(t) $ 的最大相对漂移，\n- 辛方法下 $ E(t) $ 的最大相对漂移，\n- 辛方法下 $ L(t) $ 的最大相对漂移。\n\n将报告的每个浮点数四舍五入到八位有效数字。您的程序应产生单行输出，包含一个含三个条目（每个测试用例一个）的列表。每个条目必须是按上述顺序包含四个浮点数的列表。确切的输出格式必须是单行：\n[ [eA1,lA1,eS1,lS1], [eA2,lA2,eS2,lS2], [eA3,lA3,eS3,lS3] ]。", "solution": "对提供的问题进行验证。\n\n**步骤1：提取给定信息**\n- **系统：** 无量纲单位下的平面二体（开普勒）问题。\n- **引力参数：** $ \\mu = 1 $。\n- **状态矢量：** $ y(t) = (x(t), y(t), z(t), v_x(t), v_y(t), v_z(t)) \\in \\mathbb{R}^6 $。\n- **约束：** 平面运动，$ z(t) = 0 $。\n- **运动方程 (ODE)：**\n$$\n\\frac{d}{dt}\n\\begin{pmatrix}\n\\mathbf{r}(t) \\\\\n\\mathbf{v}(t)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{v}(t) \\\\\n- \\frac{\\mathbf{r}(t)}{\\lVert \\mathbf{r}(t) \\rVert^3}\n\\end{pmatrix}\n$$\n- **守恒量：**\n  - 比机械能：$ E(t) = \\frac{1}{2} \\lVert \\mathbf{v}(t) \\rVert^2 - \\frac{1}{\\lVert \\mathbf{r}(t) \\rVert} $。\n  - 比角动量矢量：$ \\mathbf{L}(t) = \\mathbf{r}(t) \\times \\mathbf{v}(t) $，大小为 $ L(t) = \\lVert \\mathbf{L}(t) \\rVert $。\n- **任务：** 使用两种方法对ODE进行积分：一种是自适应步长的嵌入式单步公式，另一种是固定步长的正则辛积分器。\n- **分析指标：** 计算 $ Q \\in \\{E, L\\} $ 的最大相对漂移 $ \\max_{0 \\le t \\le T} \\frac{\\lvert Q(t) - Q_0 \\rvert}{\\lvert Q_0 \\rvert} $。\n- **轨道周期参考：** 对于半长轴 $ a = 1 $ 的圆形轨道，$ P = 2\\pi $。\n- **测试用例：** 提供了三个测试用例，每个都包含初始条件 $ (\\mathbf{r}(0), \\mathbf{v}(0)) $、最终时间 $ T $、自适应方法的容差 $ (\\text{rtol}, \\text{atol}) $，以及辛方法的固定步长 $ \\Delta t $。\n\n**步骤2：使用提取的给定信息进行验证**\n- **科学依据：** 该问题基于开普勒问题，这是经典力学和天体力学中的一个基本课题。方程和定义都是标准且正确的。它在科学上是合理的。\n- **良构性：** 该问题是一个常微分方程组的初值问题。矢量场在远离奇点 $ \\mathbf{r} = \\mathbf{0} $ 的地方是光滑且行为良好的。由于初始条件非奇异且描述的是束缚轨道，因此在所有时间内都存在唯一的稳定解。\n- **客观性：** 问题陈述使用精确的数学语言编写，没有任何主观或模棱两可的术语。\n- **完整性与一致性：** 所有必要的参数、初始条件以及数值方法的规范都已提供。问题是自包含的，没有矛盾。术语“用于自适应控制的嵌入式Runge-Kutta公式”在其标准数值分析语境中被理解为自适应步长控制。\n- **主题相关性：** 该问题是计算物理学中的一个经典应用，比较了不同类别的数值积分器在哈密顿系统上的表现，这直接相关。\n\n**步骤3：结论与行动**\n问题是有效的。将提供一个有理有据的解决方案。\n\n**基于原理的解决方案**\n\n该问题要求对开普勒问题进行数值积分，这是天体力学的基石。该系统是一个保守的哈密顿系统，拥有对评估数值积分器质量至关重要的守恒量。我们将比较一个通用的自适应积分器与一个专门的几何积分器。\n\n**系统动力学与守恒量**\n开普勒问题由哈密顿函数描述：\n$$\nH(\\mathbf{r}, \\mathbf{p}) = \\frac{1}{2} \\lVert \\mathbf{p} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{r} \\rVert}\n$$\n其中 $ \\mathbf{r} $ 是位置矢量，$ \\mathbf{p} = \\mathbf{v} $ 是正则动量（由于质量是单位1，它等于速度）。运动方程由哈密顿方程给出：$ \\dot{\\mathbf{r}} = \\partial H / \\partial \\mathbf{p} = \\mathbf{p} $ 和 $ \\dot{\\mathbf{p}} = -\\partial H / \\partial \\mathbf{r} = -\\mathbf{r} / \\lVert\\mathbf{r}\\rVert^3 $，这与所提供的ODE系统相匹配。\n\n对于这样的系统，在精确的解析解中有两个基本量是守恒的：\n$1$. 总比机械能 $ E(t) $，它与哈密顿量 $ H(\\mathbf{r}(t), \\mathbf{p}(t)) $ 相同。它的守恒源于 $ H $ 的时间无关性。\n$2$. 比角动量矢量 $ \\mathbf{L}(t) = \\mathbf{r}(t) \\times \\mathbf{p}(t) $。它的守恒是引力势 $ V(\\mathbf{r}) = -1/\\lVert\\mathbf{r}\\rVert $ 的旋转对称性（中心力性质）的结果。因此，其大小 $ L(t) = \\lVert\\mathbf{L}(t)\\rVert $ 也是恒定的。\n\n数值积分器通常不能完美地保持这些量。它们未能保持这些量的方式是其性能的关键区别点。\n\n**数值积分方法1：自适应Runge-Kutta**\n指定的第一种方法是用于自适应步长控制的嵌入式单步公式。一个标准的选择是 Dormand-Prince $4(5)$ 对，通常称为 `RK45`。在每一步，该方法产生两个解：一个四阶精度的解 $ y_{n+1}^{(4)} $ 和一个五阶精度的解 $ y_{n+1}^{(5)} $。它们之间的差异可作为低阶方法局部截断误差的估计。然后将此误差估计与用户定义的容差进行比较，该容差是绝对容差 $ \\text{atol} $ 和相对容差 $ \\text{rtol} $ 的函数。步长 $ h $ 会被持续调整，以使估计误差低于此容差阈值。虽然这些方法在达到指定局部精度方面非常高效，但它们并非为保持哈密顿系统的几何结构而设计。因此，对于长期积分，它们通常会表现出能量的长期（单调）漂移，即使容差非常小也是如此。\n\n**数值积分方法2：辛积分器**\n第二种方法是固定步长的正则辛积分器。这些是专为哈密顿系统设计的几何积分器。它们通常不完全守恒哈密顿量（能量）。然而，它们确实保持了辛二形式 $ d\\mathbf{r} \\wedge d\\mathbf{p} $，这是哈密顿流的一个基本性质。一个实际的后果是，数值解位于一个附近的“影子”哈密顿量上，该哈密顿量被积分器精确守恒。这导致能量误差 $ E(t) - E_0 $ 在指数级长的时间内保持有界和振荡，这与非辛方法的长期漂移形成鲜明对比。\n\n对于可分离的哈密顿量 $ H = T(\\mathbf{p}) + V(\\mathbf{r}) $，一个简单且广泛使用的二阶辛积分器是蛙跳法，此处以其速度-Verlet形式实现。对于一个步长 $ \\Delta t $，算法的一步如下：\n$$\n\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{a}(\\mathbf{r}_n)\n$$\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\Delta t \\, \\mathbf{v}_{n+1/2}\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{\\Delta t}{2} \\mathbf{a}(\\mathbf{r}_{n+1})\n$$\n其中 $ \\mathbf{a}(\\mathbf{r}) = -\\mathbf{r}/\\lVert\\mathbf{r}\\rVert^3 $ 是加速度。由于其时间可逆性和对称性，对于中心力问题，该积分器还能非常精确地守恒角动量，通常能达到机器精度。\n\n**分析步骤**\n对于三个测试用例中的每一个，执行以下步骤：\n$1$. 使用初始状态 $ y_0 = (\\mathbf{r}(0), \\mathbf{v}(0)) $ 计算初始能量 $ E_0 $ 和角动量大小 $ L_0 $。\n$2$. 使用 `RK45` 自适应积分器（通过 `scipy.integrate.solve_ivp`）和辛蛙跳积分器的自定义实现，将系统从 $ t=0 $ 积分到指定的最终时间 $ T $。\n$3$. 在每次积分过程中，在每个时间步记录 $ E(t) $ 和 $ L(t) $ 的值。\n$4$. 计算每个量的最大相对漂移为 $ \\max_t \\frac{|Q(t) - Q_0|}{|Q_0|} $。\n$5$. 为每个测试用例收集四个结果漂移值（两种方法的能量和角动量），并报告到八位有效数字。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Kepler problem for three test cases using two different\n    numerical integration methods and calculates the drift in conserved quantities.\n    \"\"\"\n\n    # Helper function to format a number to 8 significant digits.\n    def format_sig(num):\n        return float('{:.8g}'.format(num))\n\n    # --- Problem Definition ---\n\n    def kepler_ode(t, y):\n        \"\"\"ODE system for the Kepler problem: dy/dt = f(t, y).\"\"\"\n        r_vec = y[:3]\n        r_norm = np.linalg.norm(r_vec)\n        \n        if r_norm == 0:\n            accel = np.zeros(3)\n        else:\n            accel = -r_vec / r_norm**3\n            \n        return np.concatenate((y[3:], accel))\n\n    def kepler_accel(r_vec):\n        \"\"\"Acceleration function a(r) for the symplectic integrator.\"\"\"\n        r_norm = np.linalg.norm(r_vec)\n        if r_norm == 0:\n            return np.zeros(3)\n        return -r_vec / r_norm**3\n\n    # --- Conserved Quantities ---\n\n    def calculate_energy(state):\n        \"\"\"Calculates the specific mechanical energy.\"\"\"\n        r_vec = state[:3]\n        v_vec = state[3:]\n        r_norm = np.linalg.norm(r_vec)\n        v_norm_sq = np.dot(v_vec, v_vec)\n        if r_norm == 0:\n            return np.inf\n        return 0.5 * v_norm_sq - 1.0 / r_norm\n\n    def calculate_angular_momentum_magnitude(state):\n        \"\"\"Calculates the magnitude of the specific angular momentum.\"\"\"\n        r_vec = state[:3]\n        v_vec = state[3:]\n        L_vec = np.cross(r_vec, v_vec)\n        return np.linalg.norm(L_vec)\n\n    # --- Integrators ---\n\n    def solve_adaptive(y0, T, rtol, atol):\n        \"\"\"Integrates using an adaptive-step Runge-Kutta method (RK45).\"\"\"\n        sol = solve_ivp(\n            kepler_ode,\n            (0, T),\n            y0,\n            method='RK45',\n            rtol=rtol,\n            atol=atol,\n            dense_output=False\n        )\n        \n        E0 = calculate_energy(y0)\n        L0 = calculate_angular_momentum_magnitude(y0)\n        \n        energies = np.array([calculate_energy(sol.y[:, i]) for i in range(sol.y.shape[1])])\n        angular_momenta = np.array([calculate_angular_momentum_magnitude(sol.y[:, i]) for i in range(sol.y.shape[1])])\n        \n        max_rel_E_drift = np.max(np.abs(energies - E0)) / np.abs(E0) if E0 != 0 else 0\n        max_rel_L_drift = np.max(np.abs(angular_momenta - L0)) / np.abs(L0) if L0 != 0 else 0\n\n        return format_sig(max_rel_E_drift), format_sig(max_rel_L_drift)\n\n    def solve_symplectic(y0, T, dt):\n        \"\"\"Integrates using a fixed-step symplectic leapfrog (Velocity-Verlet) method.\"\"\"\n        r = y0[:3].copy()\n        v = y0[3:].copy()\n        \n        E0 = calculate_energy(y0)\n        L0 = calculate_angular_momentum_magnitude(y0)\n        \n        num_steps = int(np.ceil(T / dt))\n        \n        max_rel_E_drift = 0.0\n        max_rel_L_drift = 0.0\n        \n        # Velocity-Verlet implementation\n        accel = kepler_accel(r)\n        \n        for _ in range(num_steps):\n            # Kick (half step)\n            v_half = v + 0.5 * dt * accel\n            # Drift (full step)\n            r = r + dt * v_half\n            # New acceleration\n            accel = kepler_accel(r)\n            # Kick (half step)\n            v = v_half + 0.5 * dt * accel\n            \n            # Calculate conserved quantities at the new state\n            current_state = np.concatenate((r, v))\n            E = calculate_energy(current_state)\n            L = calculate_angular_momentum_magnitude(current_state)\n            \n            rel_E_drift = np.abs(E - E0) / np.abs(E0) if E0 != 0 else 0\n            rel_L_drift = np.abs(L - L0) / np.abs(L0) if L0 != 0 else 0\n            \n            if rel_E_drift > max_rel_E_drift:\n                max_rel_E_drift = rel_E_drift\n            if rel_L_drift > max_rel_L_drift:\n                max_rel_L_drift = rel_L_drift\n                \n        return format_sig(max_rel_E_drift), format_sig(max_rel_L_drift)\n\n    # --- Main Execution Logic ---\n\n    P = 2 * np.pi\n    \n    test_cases = [\n        # Case 1: Moderate eccentricity\n        {\n            \"y0\": np.array([0.7, 0, 0, 0, 1.363818169698585, 0]),\n            \"T\": 10 * P,\n            \"rtol\": 1e-9, \"atol\": 1e-12,\n            \"dt\": P / 200\n        },\n        # Case 2: Circular orbit\n        {\n            \"y0\": np.array([1, 0, 0, 0, 1, 0]),\n            \"T\": 10 * P,\n            \"rtol\": 1e-6, \"atol\": 1e-9,\n            \"dt\": P / 50\n        },\n        # Case 3: High eccentricity\n        {\n            \"y0\": np.array([0.2, 0, 0, 0, 3.0, 0]),\n            \"T\": 5 * P,\n            \"rtol\": 1e-7, \"atol\": 1e-10,\n            \"dt\": P / 400\n        }\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        y0 = case[\"y0\"]\n        \n        eA, lA = solve_adaptive(y0, case[\"T\"], case[\"rtol\"], case[\"atol\"])\n        eS, lS = solve_symplectic(y0, case[\"T\"], case[\"dt\"])\n        \n        all_results.append([eA, lA, eS, lS])\n        \n    case_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "2388495"}, {"introduction": "最后，让我们来探索步长控制器在极端挑战下的动态行为。当解的复杂度剧烈变化时，控制器会如何应对？在这个练习中，你将让自适应求解器面对一个我们特意构造的“对抗性”常微分方程，该方程包含随参数 $\\epsilon$ 变化的快变与高频振荡成分。[@problem_id:2388548]\n\n通过统计求解过程中被拒绝的步数，你将探索步长自适应机制的实际性能极限。这会让你深刻理解，为什么对于那些解的高阶导数剧烈变化的问题，即使问题本身不是传统意义上的“刚性”问题，求解器也可能会频繁地拒绝步长，从而导致计算效率下降。", "problem": "构建、论证并测试一个一维对抗性常微分方程（ODE）初值问题，该问题能够在类刚性参数趋于零时，可靠地在自适应 Embedded Runge–Kutta (ERK) 求解器中引发频繁的步长拒绝。从基本概念出发：一个初值问题由 $y^{\\prime} = f(t,y,\\epsilon)$ 和 $y(0)=y_0$ 给出，其中对于固定的 $\\epsilon>0$，$f$ 在其变量上足够平滑。一个显式 ERK 方法在每个步长内使用 $f$ 的多个阶段求值，以产生两个不同形式阶的近似值，其差值用作自适应步长控制的局部误差估计。一个 $p$ 阶方法的局部截断误差对于步长 $h$ 缩放为 $O(h^{p+1})$，而当右端项包含快速变化的组分时，精确解的高阶导数可以放大这种缩放效应。\n\n您必须遵循以下说明。\n\n1) 对抗性 ODE 的设计与论证。通过组合一个稳定的线性耗散分量与一个随时间加速并在 $\\epsilon \\to 0$ 时集中在小尺度上的快速变化的光滑强迫项来设计 $f$。为了使任务具体且可测试，请使用以下典型的对抗模型：\n- 定义 ODE\n$$\ny^{\\prime}(t) \\;=\\; f(t,y,\\epsilon) \\;=\\; -\\,y \\;+\\; \\sin\\!\\Big(\\frac{t^2}{\\epsilon}\\Big)\\;+\\;0.3\\,\\exp\\!\\Big(-\\frac{(t-0.7)^2}{2\\,(2\\epsilon)^2}\\Big)\\,\\sin\\!\\Big(\\frac{t}{\\epsilon}\\Big).\n$$\n- 在区间 $t\\in[0,1]$ 上使用初始条件 $y(0)=0$。\n- 从第一性原理出发，解释为什么当 $\\epsilon\\to 0$ 时，这个 $f$ 对于带自适应控制的显式 ERK 方法是具有对抗性的：耗散项 $-y$ 产生唯一的稳定解，啁啾正弦项 $\\sin(t^2/\\epsilon)$ 产生一个与 $2t/\\epsilon$ 成正比的瞬时频率，该频率随 $t$ 增加，而局部化的高斯因子乘以一个快速振荡项 $\\sin(t/\\epsilon)$，其中心位于 $t=0.7$，宽度量级为 $O(\\epsilon)$。随着 $\\epsilon$ 减小，解的高阶时间导数的量级大致按 $\\epsilon^{-1}$ 的幂增长，迫使 $h$ 骤然缩小以满足局部误差控制，这反过来又在控制器对快速变化区域的步长预测过于乐观时导致频繁的拒绝。\n\n2) 数值方法与自适应控制器。实现一个阶为 $p=3$ 和 $p_{\\mathrm{emb}}=2$ 的显式嵌入式 Runge–Kutta 对（Bogacki–Shampine $3(2)$ 对），使用以下接受和步长自适应策略，所有这些都用适合一维状态的加权标量范数表示：\n- 使用相对容差 $\\mathrm{rtol}$ 和绝对容差 $\\mathrm{atol}$ 以及误差比\n$$\nE \\;=\\; \\frac{|y_{\\text{high}}-y_{\\text{low}}|}{\\mathrm{atol}+\\mathrm{rtol}\\,\\max\\{|y_n|,|y_{\\text{high}}|\\}},\n$$\n其中 $y_{\\text{high}}$ 是高阶更新，而 $y_{\\text{low}}$ 是低阶嵌入式更新。\n- 如果 $E\\le 1$，则接受该步；否则拒绝。拒绝时，减小步长并在不推进时间的情况下重试。\n- 通过控制器更新步长 $h$\n$$\nh_{\\text{new}} \\;=\\; h \\cdot \\mathrm{clip}\\!\\Big(\\gamma\\,E^{-1/3},\\,\\eta_{\\min},\\,\\eta_{\\max}\\Big),\n$$\n其中安全因子 $\\gamma=0.9$，最小因子 $\\eta_{\\min}=0.2$，最大因子 $\\eta_{\\max}=5$。如果 $E=0$，则取最大增长因子。\n\n3) 实现约束。编写一个完整的程序，该程序：\n- 实现具有“首末同阶”（First Same As Last, FSAL）属性的 Bogacki–Shampine $3(2)$ 方法。\n- 在 $t=0$ 到 $t=1$ 之间进行积分，初始步长为 $h_0=10^{-1}$，最小允许步长为 $h_{\\min}=10^{-12}$，以避免无限循环。\n- 为每个测试用例计数并返回被拒绝的步数。\n- 仅使用最终答案中指定的允许环境和库。\n\n4) 测试套件。在以下五个测试用例上评估求解器，这些用例探测了不同的机制和边界条件。每个用例都是一个三元组 $(\\epsilon,\\mathrm{rtol},\\mathrm{atol})$：\n- 用例 A（良性基准）：$(1,\\;10^{-5},\\;10^{-8})$。\n- 用例 B（中度振荡）：$(10^{-1},\\;10^{-5},\\;10^{-8})$。\n- 用例 C（强振荡）：$(10^{-2},\\;10^{-5},\\;10^{-8})$。\n- 用例 D（极端振荡）：$(10^{-3},\\;10^{-5},\\;10^{-8})$。\n- 用例 E（更严格的容差边界）：$(10^{-2},\\;10^{-7},\\;10^{-10})$。\n\n5) 要求的最终输出格式。您的程序应生成单行输出，其中包含按 A 到 E 的顺序排列的结果，形式为方括号括起来的逗号分隔列表，其中每个条目是该用例被拒绝的步数的整数值。例如，打印的行必须具有以下形式\n$[r_A,r_B,r_C,r_D,r_E]$\n其中每个 $r_\\cdot$ 是一个整数。不得打印任何额外文本。\n\n所有数值必须解释为无量纲。角度以弧度为单位。不涉及物理单位。程序必须是自包含的，并且不需要用户输入或外部文件。", "solution": "问题陈述被评估为**有效**。这是一个计算物理学领域中适定的初值问题，具体涉及常微分方程（ODE）的数值解。该问题具有科学依据，使用了成熟的数值方法（嵌入式 Runge-Kutta）和自适应步长控制的标准技术。所有参数、方程和约束都以足够的精度定义，从而允许一个唯一的、可验证的解。目标清晰且可形式化。\n\n### 1. 对抗性 ODE 的设计与论证\n\n指定的 ODE 为\n$$\ny^{\\prime}(t) = f(t,y,\\epsilon) = -y + \\sin\\Big(\\frac{t^2}{\\epsilon}\\Big) + 0.3\\,\\exp\\Big(-\\frac{(t-0.7)^2}{8\\epsilon^2}\\Big)\\sin\\Big(\\frac{t}{\\epsilon}\\Big)\n$$\n在区间 $t \\in [0,1]$ 上，初始条件为 $y(0)=0$。此 ODE 被设计为对显式自适应求解器具有对抗性，特别是在参数 $\\epsilon > 0$ 值很小的情况下。其原因如下。\n\n该 ODE 是一个形式为 $y' + y = g(t, \\epsilon)$ 的线性一阶方程，其中 $g(t, \\epsilon)$ 是由正弦项和高斯调制项组成的强迫函数。项 $-y$ 代表线性耗散，这保证了解 $y(t)$ 是稳定的并保持有界，跟踪强迫项 $g(t, \\epsilon)$ 的行为。其精确解由 $y(t) = e^{-t} \\int_0^t e^\\tau g(\\tau, \\epsilon) d\\tau$ 给出。\n\n其对抗性源于强迫函数 $g(t, \\epsilon)$ 在 $\\epsilon \\to 0$ 时的特性：\n1.  **啁啾频率分量**：项 $\\sin(t^2/\\epsilon)$ 的瞬时角频率为 $\\omega(t) = \\frac{d}{dt}(t^2/\\epsilon) = 2t/\\epsilon$。振荡频率随时间线性增加，迫使自适应求解器在积分区间上前进时不断减小其步长 $h$。\n2.  **局部化高频爆发**：项 $0.3\\,\\exp(-\\frac{(t-0.7)^2}{2\\,(2\\epsilon)^2})\\sin(t/\\epsilon)$ 引入了一个高频振荡 $\\sin(t/\\epsilon)$，该振荡由一个以 $t=0.7$ 为中心的高斯包络进行调制。该高斯的标准差为 $\\sigma = 2\\epsilon$，意味着该特征在空间上集中于一个宽度为 $O(\\epsilon)$ 的狭窄区域。这为求解器制造了一个突发的、局部化的挑战。\n\n一个 $p$ 阶 Runge-Kutta 方法的局部截断误差（LTE）具有形式 $LTE = C h^{p+1} y^{(p+1)}(\\xi)$，其中 $C$ 是一个常数，$\\xi$ 在步长区间内。解 $y(t)$ 的高阶导数由强迫项 $g(t, \\epsilon)$ 的导数决定。我们有：\n$$\ny'(t) = -y + g(t, \\epsilon) \\\\\ny''(t) = -y' + g' = y - g + g' \\\\\ny^{(k)}(t) = (-1)^k y + \\sum_{j=0}^{k-1} (-1)^{k-1-j} g^{(j)}(t, \\epsilon)\n$$\n因此，$y^{(k)}(t)$ 的量级由强迫项的最高可用导数 $g^{(k-1)}(t, \\epsilon)$ 主导。$g(t, \\epsilon)$ 各分量的导数与 $\\epsilon$ 成反比。例如，对于啁啾项 $g_1(t) = \\sin(t^2/\\epsilon)$，其 $k$ 阶导数的缩放关系为 $g_1^{(k)}(t) = O(\\epsilon^{-k})$。\n\n对于 Bogacki-Shampine 对，误差估计基于三阶（$p=3$）和二阶（$p_{\\text{emb}}=2$）近似值之间的差异。这个差异是对嵌入式（低阶）方法 LTE 的估计，其行为如 $O(h^{p_{\\text{emb}}+1} y^{(p_{\\text{emb}}+1)}) = O(h^3 y^{(3)})$。由于 $y^{(3)}$ 的缩放与 $g^{(2)}$ 相同，且 $g^{(2)}(t, \\epsilon) = O(\\epsilon^{-2})$，误差估计 $\\Delta$ 满足：\n$$\n\\Delta \\approx C' h^3 \\epsilon^{-2}\n$$\n自适应控制器旨在将误差比 $E = |\\Delta| / (\\text{atol} + \\text{rtol} \\cdot \\text{scale})$ 保持在 $1$ 以下。这意味着步长 $h$ 必须满足 $h^3 \\lesssim (\\text{atol} + \\dots) \\epsilon^2$，或大致为 $h = O(\\epsilon^{2/3})$。随着 $\\epsilon$ 减小，所需的步长会显著缩小。一个根据当前误差预测下一步步长的自适应控制器，在遇到快速增加的频率时，很可能会做出过于乐观的预测。这导致误差估计 $E > 1$，引发步长拒绝，并强制使用更小的步长重试。这个过程在高振荡区域频繁重复，导致拒绝步数的计数很高。\n\n### 2. 数值方法：Bogacki–Shampine 3(2) 对\n\nBogacki–Shampine 方法是一个阶为 3 和 2 的显式 Runge-Kutta 对。其 Butcher 表格如下：\n$$\n\\begin{array}{c|cccc}\n0 & 0 & 0 & 0 & 0 \\\\\n1/2 & 1/2 & 0 & 0 & 0 \\\\\n3/4 & 0 & 3/4 & 0 & 0 \\\\\n1 & 2/9 & 1/3 & 4/9 & 0 \\\\\n\\hline\ny_{\\text{high}} & 2/9 & 1/3 & 4/9 & 0 \\\\\ny_{\\text{low}} & 7/24 & 1/4 & 1/3 & 1/8\n\\end{array}\n$$\n对于从 $(t_n, y_n)$ 开始、步长为 $h$ 的一步，各阶段计算如下：\n$$\n\\begin{aligned}\nk_1 &= f(t_n, y_n, \\epsilon) \\\\\nk_2 &= f\\left(t_n + \\frac{1}{2}h, y_n + \\frac{1}{2}h k_1, \\epsilon\\right) \\\\\nk_3 &= f\\left(t_n + \\frac{3}{4}h, y_n + \\frac{3}{4}h k_2, \\epsilon\\right)\n\\end{aligned}\n$$\n然后计算三阶解，它将作为下一步的候选解 $y_{n+1}$：\n$$\ny_{\\text{high}} = y_n + h\\left(\\frac{2}{9}k_1 + \\frac{1}{3}k_2 + \\frac{4}{9}k_3\\right)\n$$\n第四个阶段在时间 $t_n+h$ 处使用这个新的近似值进行求值：\n$$\nk_4 = f(t_n + h, y_{\\text{high}}, \\epsilon)\n$$\n嵌入的二阶解则为：\n$$\ny_{\\text{low}} = y_n + h\\left(\\frac{7}{24}k_1 + \\frac{1}{4}k_2 + \\frac{1}{3}k_3 + \\frac{1}{8}k_4\\right)\n$$\n该方法具有“首末同阶”（First Same As Last, FSAL）属性。如果步长被接受，状态前进到 $(t_{n+1}, y_{n+1}) = (t_n+h, y_{\\text{high}})$。后续步骤的第一个阶段求值将是 $k'_1 = f(t_{n+1}, y_{n+1}, \\epsilon)$，这与刚刚计算的 $k_4$ 相同。这允许重用 $k_4$ 的求值结果，每个被接受的步长可节省一次函数求值。\n\n### 3. 自适应控制算法\n\n自适应步长控制基于局部误差的估计。\n\n**误差估计**：局部误差通过高阶解和低阶解之间的差来估计。对于这个标量问题，误差为 $\\Delta = y_{\\text{high}} - y_{\\text{low}}$。计算加权误差比 $E$ 以根据解的量级和指定的容差对误差进行归一化：\n$$\nE = \\frac{|\\Delta|}{\\mathrm{atol} + \\mathrm{rtol} \\cdot \\max\\{|y_n|, |y_{\\text{high}}|\\}}\n$$\n其中 `atol` 是绝对容差，`rtol` 是相对容差。如果 $E \\le 1$，则接受该步。\n\n**步长控制**：在一个步长完成时（无论接受或拒绝），使用标准的比例-积分（PI）控制器逻辑（这里简化为比例控制器）提出一个新的步长 $h_{\\text{new}}$：\n$$\nh_{\\text{new}} = h \\cdot \\text{clip}\\left(\\gamma E^{-1/(p_{\\text{emb}}+1)}, \\eta_{\\min}, \\eta_{\\max}\\right)\n$$\n对于我们的 $p_{\\text{emb}}=2$ 方法，指数为 $-1/3$。参数为：\n-   安全因子 $\\gamma = 0.9$，以提供一个保守的估计。\n-   最小步长变化因子 $\\eta_{\\min} = 0.2$。\n-   最大步长变化因子 $\\eta_{\\max} = 5$。\n`clip` 函数将乘法因子限制在 $[\\eta_{\\min}, \\eta_{\\max}]$ 范围内，以防止步长变化过于激进或缓慢。如果 $E=0$，则使用最大因子 $\\eta_{\\max}$。如果一个大小为 $h$ 的步长被拒绝（$E>1$），建议的 $h_{\\text{new}}$ 将小于 $h$，并从同一点 $(t_n, y_n)$ 使用这个新的、更小的步长重试。如果步长被接受（$E \\le 1$），状态将前进，并使用 $h_{\\text{new}}$ 作为下一步的步长。最终步长始终受下界 $h_{\\min} = 10^{-12}$ 的限制。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test cases as tuples of (epsilon, rtol, atol)\n    test_cases = [\n        (1.0, 1e-5, 1e-8),        # Case A: Benign baseline\n        (1e-1, 1e-5, 1e-8),       # Case B: Moderate oscillations\n        (1e-2, 1e-5, 1e-8),       # Case C: Strong oscillations\n        (1e-3, 1e-5, 1e-8),       # Case D: Extreme oscillations\n        (1e-2, 1e-7, 1e-10)       # Case E: Tighter tolerance edge\n    ]\n\n    results = []\n    for epsilon, rtol, atol in test_cases:\n        rejected_steps = solve_ode(epsilon, rtol, atol)\n        results.append(rejected_steps)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef f(t, y, epsilon):\n    \"\"\"\n    Defines the right-hand side of the adversarial ODE y' = f(t, y, epsilon).\n    \"\"\"\n    term1 = -y\n    term2 = np.sin(t**2 / epsilon)\n    # The denominator is 2 * (2*epsilon)^2 = 8 * epsilon^2\n    term3 = 0.3 * np.exp(-(t - 0.7)**2 / (8 * epsilon**2)) * np.sin(t / epsilon)\n    return term1 + term2 + term3\n\ndef solve_ode(epsilon, rtol, atol):\n    \"\"\"\n    Integrates the ODE using an adaptive Bogacki-Shampine 3(2) method.\n\n    Args:\n        epsilon (float): The stiffness-like parameter in the ODE.\n        rtol (float): Relative tolerance for step-size control.\n        atol (float): Absolute tolerance for step-size control.\n\n    Returns:\n        int: The total number of rejected steps during integration.\n    \"\"\"\n    t_start, t_end = 0.0, 1.0\n    y_start = 0.0\n\n    # Controller parameters\n    gamma = 0.9      # Safety factor\n    eta_min = 0.2    # Minimum step-size scaling factor\n    eta_max = 5.0    # Maximum step-size scaling factor\n    \n    # Integration parameters\n    h0 = 1e-1\n    h_min = 1e-12\n    \n    # Butcher tableau coefficients for Bogacki-Shampine 3(2)\n    c2, c3 = 1/2, 3/4\n    a21 = 1/2\n    a32 = 3/4\n    \n    b1_high, b2_high, b3_high = 2/9, 1/3, 4/9\n    b1_low, b2_low, b3_low, b4_low = 7/24, 1/4, 1/3, 1/8\n\n    # Initial conditions\n    t = t_start\n    y = y_start\n    h = h0\n    rejected_steps = 0\n    use_fsal = False\n    k1 = 0.0 # Will be properly initialized inside the loop\n\n    while t < t_end:\n        # Ensure the final step lands exactly on t_end\n        if t + h > t_end:\n            h = t_end - t\n            use_fsal = False  # FSAL is invalid for a step of modified length\n\n        # Calculate stages for the RK method\n        if not use_fsal:\n            k1 = f(t, y, epsilon)\n        # if use_fsal is True, k1 has been set to the previous step's k4\n\n        k2 = f(t + c2 * h, y + a21 * h * k1, epsilon)\n        k3 = f(t + c3 * h, y + a32 * h * k2, epsilon)\n        \n        # Calculate the higher-order (3rd order) approximation\n        y_high = y + h * (b1_high * k1 + b2_high * k2 + b3_high * k3)\n\n        # Use the FSAL property: calculate k4 using y_high\n        k4 = f(t + h, y_high, epsilon)\n\n        # Calculate the lower-order (2nd order) embedded approximation\n        y_low = y + h * (b1_low * k1 + b2_low * k2 + b3_low * k3 + b4_low * k4)\n\n        # Estimate the error and the error ratio E\n        error = abs(y_high - y_low)\n        scale = atol + rtol * max(abs(y), abs(y_high))\n        error_ratio = error / scale if scale > 1e-30 else 0.0\n\n        # Decide whether to accept or reject the step\n        if error_ratio <= 1.0:  # Accept the step\n            t += h\n            y = y_high\n            \n            # Prepare for the next step using FSAL\n            use_fsal = True\n            k1 = k4  # k4 of this step is k1 of the next\n\n            # Update step size for the next step\n            if error_ratio == 0.0:\n                factor = eta_max\n            else:\n                factor = gamma * (error_ratio ** (-1.0 / 3.0))\n            \n            h_new = h * np.clip(factor, eta_min, eta_max)\n            h = max(h_min, h_new)\n\n        else:  # Reject the step\n            rejected_steps += 1\n            use_fsal = False  # Must re-evaluate k1 for the retried step\n\n            # Reduce step size for the retry\n            factor = gamma * (error_ratio ** (-1.0 / 3.0))\n            h_new = h * np.clip(factor, eta_min, eta_max)\n            h = max(h_min, h_new)\n            \n            if h <= h_min and t < t_end:\n                # To prevent infinite loops in pathological cases where h must be < h_min\n                # we are forced to take a step at h_min. This may violate tolerance.\n                # Continuing with h=h_min as per problem interpretation.\n                pass\n\n    return rejected_steps\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2388548"}]}