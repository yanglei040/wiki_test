{"hands_on_practices": [{"introduction": "评估任何数值方法的首要步骤是检验其准确性。本练习将指导您通过动手实践来验证一个简单预测-校正格式（即Heun方法）的收敛阶。通过将该方法应用于一个具有已知解析解但同时在有限时间存在奇点的微分方程 $y' = y^2$，您将学习如何通过数值实验来测量全局误差，并利用对数-对数图来估计收敛阶 $p$。这个过程不仅能巩固您对收敛性理论的理解，还能让您体会到在接近解的奇点时，数值方法的实际表现可能会如何变化。[@problem_id:2429754]", "problem": "考虑自治常微分方程 (ODE) $y' = y^2$ 的初值问题，其初始条件为 $y(0) = 1$。其唯一的解析解为 $y(t) = \\dfrac{1}{1 - t}$（$t \\in [0,1)$），该解在 $t=1$ 处表现出有限时间奇异性。令 $f(t,y) = y^2$。考虑在均匀网格 $t_n = t_0 + n h$（其中 $n = 0,1,\\dots,N$，$N h = t_{\\text{end}} - t_0$ 且 $t_0 = 0$）上，应用常数步长 $h > 0$ 的两步预测-校正时步格式：\n1. 预测步（显式欧拉法）：$y^{\\text{pred}}_{n+1} = y_n + h\\, f(t_n, y_n)$。\n2. 校正步（使用预测值的梯形更新）：$y_{n+1} = y_n + \\dfrac{h}{2}\\,\\left[f(t_n, y_n) + f(t_{n+1}, y^{\\text{pred}}_{n+1})\\right]$。\n对于下方的每个测试用例，你必须：\n- 使用上述格式和指定的步长 $h$ 列表（每个 $h$ 的选择都使 $t_{\\text{end}} / h$ 为正整数），从 $t=0$ 积分到 $t=t_{\\text{end}}$。\n- 对于列表中的每个 $h$，计算在 $t = t_{\\text{end}}$ 处的绝对全局误差，定义为 $E(h) = \\left|y_{\\text{num}}(t_{\\text{end}};h) - \\dfrac{1}{1 - t_{\\text{end}}}\\right|$，其中 $y_{\\text{num}}(t_{\\text{end}};h)$ 是步长为 $h$ 的格式产生的数值近似解。\n- 对于一个测试用例中的所有 $(h, E(h))$ 对，通过对点集 $\\left(\\log(h), \\log(E(h))\\right)$ 进行最小二乘线性拟合来估计观测收敛阶 $p$。即，拟合 $\\log(E(h)) \\approx C + p \\log(h)$ 并报告该测试用例的 $p$值。\n- 将每个报告的 $p$ 值四舍五入到三位小数，并报告无量纲值。\n\n测试套件：\n- 用例 A：$t_{\\text{end}} = 0.1$，其中 $h \\in \\{0.02, 0.01, 0.005, 0.0025\\}$。\n- 用例 B：$t_{\\text{end}} = 0.5$，其中 $h \\in \\{0.1, 0.05, 0.025, 0.0125\\}$。\n- 用例 C：$t_{\\text{end}} = 0.9$，其中 $h \\in \\{0.1, 0.05, 0.025, 0.0125\\}$。\n- 用例 D：$t_{\\text{end}} = 0.95$，其中 $h \\in \\{0.05, 0.025, 0.0125\\}$。\n\n你的程序应该产生单行输出，包含四个四舍五入后的估计值 $[p_A, p_B, p_C, p_D]$，形式为逗号分隔的列表并用方括号括起，例如 $[2.000,2.000,1.950,1.700]$。不应打印任何额外文本。所有角度、单位和量均为无量纲；报告最终的四个值时，保留小数点后三位。", "solution": "所提供的问题是计算物理学中一个定义明确的练习，内容涉及常微分方程 (ODE) 的数值解。它具有科学依据，逻辑一致，并包含了获得唯一解所需的所有信息。因此，该问题是有效的，我们着手解决它。\n\n该问题要求分析一个应用于由以下自治 ODE 给出的初值问题 (IVP) 的数值方法：\n$$\ny'(t) = y(t)^2, \\quad y(0) = 1\n$$\n该方程是 Riccati 方程的一个特例。其解析解可通过分离变量法求得：\n$$\n\\frac{dy}{y^2} = dt \\implies \\int \\frac{dy}{y^2} = \\int dt \\implies -\\frac{1}{y} = t + C\n$$\n使用初始条件 $y(0)=1$，我们求出积分常数 $C$：\n$$\n-\\frac{1}{1} = 0 + C \\implies C = -1\n$$\n因此，唯一的解析解是：\n$$\ny(t) = \\frac{1}{1 - t}\n$$\n该解存在于 $t \\in [0, 1)$，并在 $t=1$ 处表现出有限时间奇异性。问题中定义的待积函数为 $f(t,y) = y^2$。由于该 ODE 是自治的，函数 $f$ 不显式依赖于 $t$。\n\n所使用的数值格式是以下两步预测-校正方法：\n1.  **预测步（显式欧拉法）：** 使用前向欧拉法计算在时间 $t_{n+1} = t_n + h$ 处的预测值 $y^{\\text{pred}}_{n+1}$：\n    $$\n    y^{\\text{pred}}_{n+1} = y_n + h\\, f(t_n, y_n) = y_n + h\\, y_n^2\n    $$\n2.  **校正步（梯形更新）：** 通过对区间开始处的斜率 $f(t_n, y_n)$ 和区间结束处的斜率（其中函数在预测值处求值）$f(t_{n+1}, y^{\\text{pred}}_{n+1})$ 进行平均，来计算最终值 $y_{n+1}$：\n    $$\n    y_{n+1} = y_n + \\frac{h}{2} \\left[ f(t_n, y_n) + f(t_{n+1}, y^{\\text{pred}}_{n+1}) \\right] = y_n + \\frac{h}{2} \\left[ y_n^2 + (y^{\\text{pred}}_{n+1})^2 \\right]\n    $$\n该格式被广泛称为 Heun 方法或改进欧拉方法。它属于二阶 Runge-Kutta 方法族。对于一个足够光滑的解，该方法的局部截断误差为 $\\mathcal{O}(h^3)$ 阶，这导致在固定时间 $t_{\\text{end}}$ 的全局误差 $E(h)$ 为 $\\mathcal{O}(h^2)$ 阶。\n\n问题要求估计观测收敛阶 $p$。对于一个全局误差为 $E(h) \\approx K h^p$（其中 $K$ 为某个常数）的方法，我们可以对两边取自然对数：\n$$\n\\log(E(h)) \\approx \\log(K) + p \\log(h)\n$$\n该方程具有线性关系式 $Y = C + pX$ 的形式，其中 $Y = \\log(E(h))$，$X = \\log(h)$，截距为 $C = \\log(K)$。收敛阶 $p$ 是这条线的斜率。我们通过对数据集 $(\\log(h_i), \\log(E_i))$ 进行线性最小二乘回归来计算 $p$，其中 $E_i = E(h_i)$ 是在给定测试用例中每个步长 $h_i$ 在 $t=t_{\\text{end}}$ 处的绝对全局误差。\n\n为每个测试用例获得结果的算法如下：\n1.  定义积分终点 $t_{\\text{end}}$ 和步长集合 $\\{h_i\\}$。\n2.  计算在终点处的精确解 $y_{\\text{exact}} = (1 - t_{\\text{end}})^{-1}$。\n3.  对于集合中的每个步长 $h_i$：\n    a. 确定步数 $N_i = \\text{integer}(t_{\\text{end}} / h_i)$。\n    b. 在 $t_0=0$ 处用 $y_0=1$ 初始化数值解。\n    c. 使用预测-校正公式迭代 $N_i$ 次，以找到数值解 $y_{\\text{num}}(t_{\\text{end}}; h_i) = y_{N_i}$。\n    d. 计算绝对全局误差 $E_i = |y_{\\text{num}}(t_{\\text{end}}; h_i) - y_{\\text{exact}}|$。\n    e. 存储数据对 $(\\log(h_i), \\log(E_i))$。\n4.  使用该测试用例中所有存储的数据对，计算通过这些点的最佳拟合线的斜率 $p$。\n5.  报告 $p$ 的值，四舍五入到三位小数。\n\nHeun 方法的理论收敛阶为 $p=2$。在 $t_{\\text{end}}$ 远离 $t=1$ 处的奇异点的测试用例中，预期会观测到这个结果。当 $t_{\\text{end}}$ 接近 $1$ 时，解 $y(t)$ 的高阶导数变得非常大，这增加了主导误差项的量级。这可能导致方法性能的下降，对于给定的步长范围，观测收敛阶 $p$ 可能会低于理论值 2。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by calculating the observed convergence order\n    for a predictor-corrector method on a specific ODE for four test cases.\n    \"\"\"\n    \n    # Define the four test cases from the problem statement.\n    test_cases = [\n        {\"t_end\": 0.1, \"h_values\": [0.02, 0.01, 0.005, 0.0025]},\n        {\"t_end\": 0.5, \"h_values\": [0.1, 0.05, 0.025, 0.0125]},\n        {\"t_end\": 0.9, \"h_values\": [0.1, 0.05, 0.025, 0.0125]},\n        {\"t_end\": 0.95, \"h_values\": [0.05, 0.025, 0.0125]}\n    ]\n\n    # The ODE function y' = f(t, y) = y^2. It is autonomous.\n    def f_ode(y):\n        return y * y\n\n    def integrate_ode(t_end, h):\n        \"\"\"\n        Integrates the ODE y'=y^2 from t=0 to t_end using the specified\n        predictor-corrector scheme (Heun's method).\n        \n        Args:\n            t_end (float): The final integration time.\n            h (float): The constant step size.\n\n        Returns:\n            float: The numerical approximation of y(t_end).\n        \"\"\"\n        y = 1.0  # Initial condition y(0) = 1\n        num_steps = int(round(t_end / h))\n\n        for _ in range(num_steps):\n            # Predictor step (Explicit Euler)\n            f_yn = f_ode(y)\n            y_pred = y + h * f_yn\n            \n            # Corrector step (Trapezoidal update)\n            f_y_pred = f_ode(y_pred)\n            y = y + 0.5 * h * (f_yn + f_y_pred)\n            \n        return y\n\n    results = []\n    for case in test_cases:\n        t_end = case[\"t_end\"]\n        h_values = case[\"h_values\"]\n        \n        # Calculate the exact solution at t_end\n        y_exact = 1.0 / (1.0 - t_end)\n        \n        log_h_vals = []\n        log_E_vals = []\n        \n        for h in h_values:\n            # Compute numerical solution\n            y_num = integrate_ode(t_end, h)\n            \n            # Compute absolute global error\n            error = np.abs(y_num - y_exact)\n            \n            # Store log of step size and log of error\n            log_h_vals.append(np.log(h))\n            log_E_vals.append(np.log(error))\n            \n        # Perform a linear least-squares fit to find the convergence order p (the slope)\n        # log(E) = p * log(h) + C\n        p, _ = np.polyfit(log_h_vals, log_E_vals, 1)\n        \n        results.append(f\"{p:.3f}\")\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2429754"}, {"introduction": "在验证了一个数值方法的收敛阶之后，一个更深层次的问题是：它能否定性地再现真实系统的行为？本练习揭示了一个数值积分中常见且微妙的陷阱：伪影不动点（spurious fixed points）。您将通过解析推导和编程实践，发现即使对于简单的线性系统 $\\frac{dx}{dt} = \\lambda x$，一个看似合理的预测-校正格式也可能在特定参数下，产生原连续系统所不具备的、非物理的平衡点。这个练习是一个深刻的教训，提醒我们在相信和解释计算结果时，必须保持批判性思维。[@problem_id:2429768]", "problem": "设计一个自洽的计算物理任务，以演示一个标准的预测-校正方法如何引入原始连续时间系统中不存在的伪不动点。请仅使用以下基本依据：常微分方程的定义、连续动力学系统的平衡点（不动点）的定义，以及由显式欧拉预测子和梯形法则校正子构建的单步预测-校正方法的显式公式。\n\n考虑由 $\\dfrac{dx}{dt} = f(x)$ 给定的一维标量常微分方程，其中 $x \\in \\mathbb{R}$ 并且 $t \\in \\mathbb{R}$ 表示时间。连续系统的平衡点（不动点）是任何满足 $f(x^\\ast)=0$ 的 $x^\\ast$。一个具有显式欧拉预测和梯形法则校正的单步预测-校正方法，使用以下两个阶段，从时间 $t_n$ 的 $x_n$ 推进到时间 $t_{n+1}=t_n+h$ 的 $x_{n+1}$：\n- 预测步：$x_{\\mathrm{p}} = x_n + h\\, f(x_n)$。\n- 校正步：$x_{n+1} = x_n + \\dfrac{h}{2}\\,\\big(f(x_n) + f(x_{\\mathrm{p}})\\big)$。\n\n您的任务是：\n1. 通过取 $f(x)=\\lambda\\,x$（其中 $\\lambda \\in \\mathbb{R}$ 是一个常数参数）来构造一个具体例子。将 $\\lambda$ 解释为具有时间倒数的单位，即 $\\lambda$ 的单位是 $\\mathrm{s}^{-1}$，并使用一个以 $\\mathrm{s}$ 为单位的均匀时间步长 $h>0$。从第一性原理推导，对于此线性函数 $f(x)$，上述预测-校正方法所产生的离散单步映射 $x_{n+1} = \\Phi_{h,\\lambda}(x_n)$。\n2. 仅使用映射的不动点和微分方程的平衡点的定义，确定参数 $(\\lambda,h)$ 在何种条件下，离散映射 $\\Phi_{h,\\lambda}$ 会拥有非零不动点 $x^\\ast \\neq 0$，即使在 $\\lambda \\neq 0$ 时连续系统仅有平衡点 $x^\\ast=0$。解释为什么相对于原始连续系统，离散映射的这种非零不动点是伪的且非物理的。\n3. 实现一个程序，对于每个给定的测试用例 $(\\lambda,h)$，判断离散映射 $\\Phi_{h,\\lambda}$ 是否具有伪非零不动点。在比较实数以确定相等条件时，您必须使用 $\\varepsilon=10^{-12}$ 的数值公差。判断结果应以布尔值形式报告：在假设 $\\lambda \\neq 0$ 的情况下，如果存在伪非零不动点，则返回 $\\text{True}$，否则返回 $\\text{False}$。如果 $\\lambda=0$，回想一下，连续系统已经将每个 $x$ 都作为平衡点，因此不会引入伪的非物理不动点；在这种情况下，您的判断必须是 $\\text{False}$。\n\n物理单位：\n- 时间步长 $h$ 必须以 $\\mathrm{s}$ 为单位指定。\n- 参数 $\\lambda$ 必须以 $\\mathrm{s}^{-1}$ 为单位指定。\n- 此问题中没有角度量。\n- 无需输出单位；输出为布尔值。\n\n测试套件：\n在以下参数对 $(\\lambda,h)$ 上评估您的决策函数：\n- 情况 $1$：$(\\lambda,h)=(-1,\\;0.1)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n- 情况 $2$：$(\\lambda,h)=(-1,\\;2.0)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n- 情况 $3$：$(\\lambda,h)=(-4,\\;0.5)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n- 情况 $4$：$(\\lambda,h)=(3,\\;0.5)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n- 情况 $5$：$(\\lambda,h)=(-2.5,\\;0.8)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个结果列表，该列表为方括号内由逗号分隔且无空格的布尔值，其顺序与上述测试套件一致。例如，一个有效的输出形如 $\\big[\\text{False},\\text{True},\\ldots\\big]$。您的程序不得读取任何输入，也不得打印任何其他内容。", "solution": "所述问题是有效的。它在科学上基于数值分析和动力学系统的原理，是适定的 (well-posed)，并且其所有组成部分都得到了客观和严格的定义。我们将开始解答。\n\n任务是分析一个特定的预测-校正数值积分格式如何引入在原始连续时间动力学系统中不存在的伪的、非物理的不动点。我们考虑由 $\\frac{dx}{dt} = f(x)$ 给定的标量常微分方程 (ODE)，其具体线性形式为 $f(x) = \\lambda x$，其中 $\\lambda \\in \\mathbb{R}$ 是一个常数参数。\n\n首先，我们确定连续系统的平衡点。一个平衡点或不动点 $x^\\ast$ 是一个系统不随时间演化的状态，在数学上对应于 $\\frac{dx}{dt} = 0$。对于我们的系统，这个条件是 $f(x^\\ast) = \\lambda x^\\ast = 0$。对于任何非零参数 $\\lambda \\neq 0$，连续系统的唯一平衡点是平凡平衡点 $x^\\ast = 0$。如果 $\\lambda=0$，ODE 变为 $\\frac{dx}{dt} = 0$，此时每个点 $x \\in \\mathbb{R}$ 都是一个平衡点。\n\n接下来，我们推导将指定的预测-校正方法应用于此 ODE 所生成的离散单步映射 $x_{n+1} = \\Phi_{h,\\lambda}(x_n)$。该方法使用一个时间步长 $h > 0$。\n\n预测步是显式欧拉方法：\n$$x_{\\mathrm{p}} = x_n + h f(x_n)$$\n代入 $f(x_n) = \\lambda x_n$，我们得到预测值 $x_{\\mathrm{p}}$：\n$$x_{\\mathrm{p}} = x_n + h (\\lambda x_n) = x_n(1 + h\\lambda)$$\n\n校正步基于梯形法则，它对区间起点和预测终点的斜率进行平均：\n$$x_{n+1} = x_n + \\frac{h}{2} \\big(f(x_n) + f(x_{\\mathrm{p}})\\big)$$\n代入 $f(x_n) = \\lambda x_n$ 和 $f(x_{\\mathrm{p}}) = \\lambda x_{\\mathrm{p}}$：\n$$x_{n+1} = x_n + \\frac{h}{2} (\\lambda x_n + \\lambda x_{\\mathrm{p}})$$\n现在，我们用预测步的表达式替换 $x_{\\mathrm{p}}$：\n$$x_{n+1} = x_n + \\frac{h\\lambda}{2} \\big(x_n + x_n(1 + h\\lambda)\\big)$$\n从括号项中提出公因子 $x_n$：\n$$x_{n+1} = x_n + \\frac{h\\lambda}{2} \\big(x_n(1 + (1 + h\\lambda))\\big) = x_n + \\frac{h\\lambda}{2} \\big(x_n(2 + h\\lambda)\\big)$$\n最后，从整个表达式中提出公因子 $x_n$ 得到离散映射：\n$$x_{n+1} = x_n \\left(1 + \\frac{h\\lambda}{2}(2 + h\\lambda)\\right) = x_n \\left(1 + h\\lambda + \\frac{h^2\\lambda^2}{2}\\right)$$\n所以，单步映射为 $\\Phi_{h,\\lambda}(x_n) = x_n \\left(1 + h\\lambda + \\frac{1}{2}(h\\lambda)^2\\right)$。这是一个线性映射，其中第 $n+1$ 步的状态仅仅是第 $n$ 步状态的一个倍数。\n\n我们现在求解该离散映射的不动点。映射的不动点 $x^\\ast$ 必须满足条件 $x^\\ast = \\Phi_{h,\\lambda}(x^\\ast)$：\n$$x^\\ast = x^\\ast \\left(1 + h\\lambda + \\frac{h^2\\lambda^2}{2}\\right)$$\n为了求出满足此方程的 $x^\\ast$ 值，我们对其进行整理：\n$$x^\\ast - x^\\ast \\left(1 + h\\lambda + \\frac{h^2\\lambda^2}{2}\\right) = 0$$\n$$x^\\ast \\left(1 - \\left(1 + h\\lambda + \\frac{h^2\\lambda^2}{2}\\right)\\right) = 0$$\n$$x^\\ast \\left(-h\\lambda - \\frac{h^2\\lambda^2}{2}\\right) = 0$$\n$$-x^\\ast h\\lambda \\left(1 + \\frac{h\\lambda}{2}\\right) = 0$$\n如果任一因子为零，该方程就有解。\n$1$. 第一种可能性是 $x^\\ast = 0$。这个不动点对所有 $h$ 和 $\\lambda$ 的值都存在，并对应于原始 ODE 的真实平衡点。\n$2$. 第二种可能性是另一个因子为零：$-h\\lambda \\left(1 + \\frac{h\\lambda}{2}\\right) = 0$。因为给定 $h > 0$ 且我们寻找的伪不动点仅在 $\\lambda \\neq 0$ 时才有意义，所以项 $-h\\lambda$ 非零。因此，此条件简化为：\n$$1 + \\frac{h\\lambda}{2} = 0$$\n$$h\\lambda = -2$$\n\n如果条件 $h\\lambda = -2$ 满足，不动点方程变为 $-x^\\ast \\cdot 0 = 0$，这对*任何* $x^\\ast \\in \\mathbb{R}$ 的值都成立。这意味着在 $h\\lambda = -2$ 的条件下，实线上的每一点都是该离散映射的不动点。映射本身变为恒等映射：$x_{n+1} = x_n(1 - 2 + \\frac{(-2)^2}{2}) = x_n(1 - 2 + 2) = x_n$。\n\n这些不动点被认为是伪的，因为对于 $\\lambda \\neq 0$，连续系统只拥有一个平衡点 $x^\\ast = 0$。对于满足 $h\\lambda = -2$ 的特定参数组合，数值方法错误地暗示*任何*初始状态 $x_0$ 都是一个定常解，因为对所有 $n \\ge 0$ 都有 $x_n = x_0$。这是一个严重的定性错误。例如，如果 $\\lambda < 0$，真实解 $x(t) = x_0 e^{\\lambda t}$ 会指数衰减到 0。而 $h\\lambda=-2$ 的数值方法却错误地预测了一个静态系统。因此，这些无穷多个非零不动点是离散化产生的非物理假象。\n\n基于此分析，存在伪非零不动点（对于 $\\lambda \\neq 0$）的判据恰好是 $h\\lambda = -2$。$\\lambda = 0$ 的情况被排除，正如问题陈述中正确指出的，此时连续系统和离散映射都将所有点作为平衡点/不动点，因此没有引入伪不动点。\n\n在实现时，我们必须使用 $\\varepsilon = 10^{-12}$ 的数值公差。决策逻辑如下：\n- 如果 $|\\lambda| < \\varepsilon$，我们认为 $\\lambda=0$。结果为 $\\text{False}$。\n- 否则，我们计算乘积 $p = h\\lambda$。\n- 伪非零不动点存在当且仅当 $|p - (-2)| < \\varepsilon$，即 $|p + 2| < \\varepsilon$。若此条件成立，结果为 $\\text{True}$；否则为 $\\text{False}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef has_spurious_fixed_points(lambda_val: float, h: float, epsilon: float = 1e-12) -> bool:\n    \"\"\"\n    Determines if the discrete map has spurious nonzero fixed points.\n\n    Args:\n        lambda_val: The parameter lambda from the ODE dx/dt = lambda * x.\n        h: The time step for the numerical method.\n        epsilon: The numerical tolerance for equality checks.\n\n    Returns:\n        True if spurious nonzero fixed points exist, False otherwise.\n    \"\"\"\n    # According to the problem statement, if lambda is 0, the continuous system\n    # already has every point as an equilibrium. Thus, the fixed points of the\n    # discrete map are not considered spurious.\n    if abs(lambda_val) < epsilon:\n        return False\n\n    # The condition for the existence of spurious nonzero fixed points is derived\n    # to be h * lambda = -2. We check this condition using the provided tolerance.\n    product = h * lambda_val\n    if abs(product + 2.0) < epsilon:\n        return True\n    else:\n        return False\n\ndef solve():\n    \"\"\"\n    Runs the analysis for the test cases provided in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (lambda, h).\n    test_cases = [\n        (-1.0, 0.1),    # Case 1\n        (-1.0, 2.0),    # Case 2\n        (-4.0, 0.5),    # Case 3\n        (3.0, 0.5),     # Case 4\n        (-2.5, 0.8)     # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_val, h = case\n        result = has_spurious_fixed_points(lambda_val, h)\n        results.append(result)\n\n    # Final print statement in the exact required format: [Boolean,Boolean,...]\n    # The str() of a Python bool ('True', 'False') matches the implicitly desired format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "2429768"}, {"introduction": "掌握了预测-校正方法的基本分析后，让我们将其应用于一个更强大的实际场景：自适应步长控制。本练习将向您展示如何利用预测值 $\\vec{y}_p$ 和校正值 $\\vec{y}_c$ 之间的差异来估计局部误差，并动态调整积分步长 $h$。这种技术使得模拟在解变化剧烈时自动采用小步长以保证精度，在解平滑时采用大步长以提高效率。您将把这一智能算法应用于著名的洛伦兹系统——一个混沌理论中的经典模型，亲身体验现代科学计算中效率与可靠性并重的求解策略。[@problem_id:2429776]", "problem": "编写一个完整、可运行的程序，该程序使用基于预测状态和校正状态之差的自适应步长控制的单步预测-校正方法，来推进 Lorenz 初值问题的求解。Lorenz 系统是如下的三维自治系统\n$$\n\\frac{d}{dt}\\begin{bmatrix}x \\\\ y \\\\ z\\end{bmatrix} = \\begin{bmatrix}\n\\sigma \\left(y - x\\right) \\\\\nx \\left(\\rho - z\\right) - y \\\\\nx y - \\beta z\n\\end{bmatrix},\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是无量纲参数，$t$ 是无量纲时间，状态向量为 $\\vec{y}(t) = \\begin{bmatrix}x(t) \\\\ y(t) \\\\ z(t)\\end{bmatrix}$。本问题中的所有量均为无量纲。\n\n从 $\\left(t_n,\\vec{y}_n\\right)$ 开始的每一步，步长为 $h$，使用以下显式预测-校正对计算预测状态 $\\vec{y}_p$ 和校正状态 $\\vec{y}_c$：\n$$\n\\vec{y}_p = \\vec{y}_n + h\\,\\vec{f}\\!\\left(\\vec{y}_n\\right), \\quad\n\\vec{y}_c = \\vec{y}_n + \\frac{h}{2}\\left(\\vec{f}\\!\\left(\\vec{y}_n\\right) + \\vec{f}\\!\\left(\\vec{y}_p\\right)\\right),\n$$\n其中 $\\vec{f}(\\vec{y})$ 表示 Lorenz 系统的右侧。定义局部差异\n$$\ne = \\left\\|\\vec{y}_c - \\vec{y}_p\\right\\|_2.\n$$\n使用以下自适应步长控制：\n- 如果 $e \\le \\text{tol}$ 则接受该步，此时将状态推进至 $\\left(t_{n+1},\\vec{y}_{n+1}\\right) = \\left(t_n + h,\\vec{y}_c\\right)$。\n- 如果该步被拒绝 $(e > \\text{tol})$，则不推进时间，并用更小的 $h$ 重新计算该步。\n- 在每次尝试中（无论前一次尝试是被接受还是被拒绝），根据以下公式更新试探步长：\n$$\nh \\leftarrow h \\cdot \\operatorname{clip}\\!\\left(s \\left(\\frac{\\text{tol}}{\\max(e,\\epsilon)}\\right)^{1/2}, g_{\\min}, g_{\\max}\\right),\n$$\n其中 $s$ 是一个安全因子，$g_{\\min}$ 和 $g_{\\max}$ 限定了每次尝试的乘法变化范围，$\\epsilon$ 是一个用于避免除以零的正数，而 $\\operatorname{clip}(u,a,b)$ 表示将 $u$ 的值限制在区间 $\\left[a,b\\right]$ 内。接受步长时，强制 $h \\le h_{\\max}$。在所有尝试中，强制 $h \\ge h_{\\min}$。如果 $t + h > t_f$，则在该次尝试中将 $h$ 替换为 $t_f - t$，以确保恰好在 $t_f$ 结束。\n\n实现上述方法，对下述每个测试用例，从给定的初始步长 $h_0$ 开始，从 $t_0$ 推进到 $t_f$，并只计算被接受的步数。对 $e$ 使用欧几里得范数 $\\left\\|\\cdot\\right\\|_2$。在步长更新中使用 $\\epsilon = 10^{-30}$。所有计算必须以双精度进行。\n\n测试套件：\n- A例（典型混沌参数，中等容差）：\n  - $\\sigma = 10$, $\\rho = 28$, $\\beta = 8/3$; $\\vec{y}_0 = \\begin{bmatrix}1 \\\\ 1 \\\\ 1\\end{bmatrix}$; $t_0 = 0$, $t_f = 2$; $\\text{tol} = 10^{-5}$; $h_0 = 10^{-2}$; $h_{\\min} = 10^{-6}$; $h_{\\max} = 5 \\times 10^{-2}$; $s = 0.9$; $g_{\\min} = 0.2$; $g_{\\max} = 2.0$。\n- B例（较宽松容差，较大最大步长）：\n  - $\\sigma = 10$, $\\rho = 28$, $\\beta = 8/3$; $\\vec{y}_0 = \\begin{bmatrix}1 \\\\ 1 \\\\ 1\\end{bmatrix}$; $t_0 = 0$, $t_f = 2$; $\\text{tol} = 10^{-2}$; $h_0 = 10^{-2}$; $h_{\\min} = 10^{-6}$; $h_{\\max} = 1/2$; $s = 0.9$; $g_{\\min} = 0.2$; $g_{\\max} = 2.0$。\n- C例（更严格容差，不同初始状态，更短时间范围）：\n  - $\\sigma = 10$, $\\rho = 28$, $\\beta = 8/3$; $\\vec{y}_0 = \\begin{bmatrix}0 \\\\ 1 \\\\ 1\\end{bmatrix}$; $t_0 = 0$, $t_f = 1/2$; $\\text{tol} = 10^{-7}$; $h_0 = 10^{-3}$; $h_{\\min} = 10^{-7}$; $h_{\\max} = 5 \\times 10^{-3}$; $s = 0.9$; $g_{\\min} = 0.2$; $g_{\\max} = 2.0$。\n- D例（非混沌参数，向原点收敛）：\n  - $\\sigma = 10$, $\\rho = 0$, $\\beta = 8/3$; $\\vec{y}_0 = \\begin{bmatrix}5 \\\\ 5 \\\\ 5\\end{bmatrix}$; $t_0 = 0$, $t_f = 1$; $\\text{tol} = 10^{-6}$; $h_0 = 10^{-2}$; $h_{\\min} = 10^{-7}$; $h_{\\max} = 10^{-1}$; $s = 0.9$; $g_{\\min} = 0.2$; $g_{\\max} = 2.0$。\n\n要求的最终输出格式：\n- 对于A、B、C、D各例，按顺序生成最终状态 $\\vec{y}(t_f) = \\begin{bmatrix}x(t_f) \\\\ y(t_f) \\\\ z(t_f)\\end{bmatrix}$ 的三个分量，四舍五入到小数点后六位，后跟达到 $t_f$ 所用的已接受步数的整数值。\n- 将所有结果聚合到单行中，作为一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n\\left[x_A, y_A, z_A, N_A, x_B, y_B, z_B, N_B, x_C, y_C, z_C, N_C, x_D, y_D, z_D, N_D\\right],\n$$\n其中 $x_\\bullet$、$y_\\bullet$、$z_\\bullet$ 是小数点后六位的浮点数，$N_\\bullet$ 是整数。程序唯一输出的即为这单独的一行。", "solution": "Lorenz 系统是一个一阶自治系统，由 $\\vec{f}(\\vec{y}) = \\begin{bmatrix}\\sigma(y-x) \\\\ x(\\rho - z) - y \\\\ xy - \\beta z\\end{bmatrix}$ 定义，其状态为 $\\vec{y}(t) = \\begin{bmatrix}x(t) \\\\ y(t) \\\\ z(t)\\end{bmatrix}$。为了使用预测-校正方法和自适应步长控制来执行从 $t_0$ 到 $t_f$ 的时间积分，我们使用显式欧拉步作为预测器，并配以显式梯形法则（也称为改进欧拉法或 Heun 方法）作为校正器。在每一步，给定在时间 $t_n$ 的状态 $\\vec{y}_n$ 和一个试探步长 $h$，预测器和校正器定义如下\n$$\n\\vec{y}_p = \\vec{y}_n + h\\,\\vec{f}(\\vec{y}_n), \\qquad\n\\vec{y}_c = \\vec{y}_n + \\frac{h}{2}\\big(\\vec{f}(\\vec{y}_n) + \\vec{f}(\\vec{y}_p)\\big).\n$$\n步长控制器需要一个局部误差的度量。对于单步法，一个标准方法是使用嵌入式估计，该估计源于在同一步上应用的两个不同阶数近似值之间的差异。在这里，差值 $\\vec{y}_c - \\vec{y}_p$ 提供了一个大小与局部截断误差成正比的估计。为了说明这一点，将 $\\vec{y}(t_n + h)$ 展开为泰勒级数：\n$$\n\\vec{y}(t_n + h) = \\vec{y}_n + h \\vec{f}(\\vec{y}_n) + \\frac{h^2}{2} \\vec{J}(\\vec{y}_n)\\,\\vec{f}(\\vec{y}_n) + \\mathcal{O}(h^3),\n$$\n其中 $\\vec{J}(\\vec{y})$ 是 $\\vec{f}$ 的雅可比矩阵。显式欧拉预测器 $\\vec{y}_p$ 匹配到 $\\mathcal{O}(h)$ 的项，而梯形校正器 $\\vec{y}_c$ 匹配到 $\\mathcal{O}(h^2)$ 的项，使得校正后的值具有二阶精度。差值 $\\vec{y}_c - \\vec{y}_p$ 的尺度为 $\\mathcal{O}(h^2)$，因此其欧几里得范数\n$$\ne = \\left\\|\\vec{y}_c - \\vec{y}_p\\right\\|_2\n$$\n可作为局部误差的代理。\n\n为了将局部误差控制在用户定义的容差 $\\text{tol}$ 之内，我们在 $e \\le \\text{tol}$ 时接受一个步长，否则拒绝它。经典的步长控制使用关系式 $e \\propto h^2$ 来推导下一个试探步长 $h_{\\text{new}}$ 的更新公式：\n$$\nh_{\\text{new}} = h \\cdot \\left(\\frac{\\text{tol}}{e}\\right)^{1/2}.\n$$\n为了在实践中使其稳健，我们增加一个安全因子 $s \\in (0,1)$ 并通过 $g_{\\min} \\le \\frac{h_{\\text{new}}}{h} \\le g_{\\max}$ 来限制乘法变化，从而得到\n$$\nh \\leftarrow h \\cdot \\operatorname{clip}\\!\\left(s \\left(\\frac{\\text{tol}}{\\max(e,\\epsilon)}\\right)^{1/2}, g_{\\min}, g_{\\max}\\right),\n$$\n并使用一个非常小的 $\\epsilon > 0$ 以避免在 $e=0$ 时出现除以零的情况。在每次尝试中，我们强制 $h \\ge h_{\\min}$，并且在接受后不超过 $h_{\\max}$。我们还通过在 $t + h > t_f$ 时缩短最后一次尝试的步长，来确保最后一步恰好落在 $t_f$ 上。\n\n算法上，对于每个用例：\n1. 初始化 $t \\leftarrow t_0$、$\\vec{y} \\leftarrow \\vec{y}_0$、$h \\leftarrow h_0$ 以及一个已接受步数计数器 $N \\leftarrow 0$。\n2. 当 $t < t_f$ 时：\n   - 设置 $h \\leftarrow \\min\\left(h, t_f - t\\right)$ 以避免超过最终时间。\n   - 计算预测器 $\\vec{y}_p = \\vec{y} + h\\,\\vec{f}(\\vec{y})$。\n   - 计算校正器 $\\vec{y}_c = \\vec{y} + \\frac{h}{2}\\left(\\vec{f}(\\vec{y}) + \\vec{f}(\\vec{y}_p)\\right)$。\n   - 计算 $e = \\left\\|\\vec{y}_c - \\vec{y}_p\\right\\|_2$。\n   - 计算一个乘法因子 $\\phi = s \\left(\\frac{\\text{tol}}{\\max(e,\\epsilon)}\\right)^{1/2}$，然后将其限制在 $\\phi \\leftarrow \\operatorname{clip}(\\phi, g_{\\min}, g_{\\max})$。\n   - 如果 $e \\le \\text{tol}$：\n     - 接受：设置 $\\vec{y} \\leftarrow \\vec{y}_c$，$t \\leftarrow t + h$，$N \\leftarrow N + 1$。\n     - 更新 $h \\leftarrow \\min\\left(h \\cdot \\phi, h_{\\max}\\right)$ 并强制 $h \\ge h_{\\min}$。\n   - 否则：\n     - 拒绝：更新 $h \\leftarrow \\max\\left(h \\cdot \\phi, h_{\\min}\\right)$ 并重试，不推进 $t$ 或 $\\vec{y}$。\n3. 终止后，报告 $\\vec{y}(t_f)$ 和 $N$。\n\nLorenz 系统的右侧计算如下\n$$\n\\vec{f}\\!\\left(\\begin{bmatrix}x \\\\ y \\\\ z\\end{bmatrix}\\right) = \\begin{bmatrix}\n\\sigma\\left(y - x\\right) \\\\\nx\\left(\\rho - z\\right) - y \\\\\nx y - \\beta z\n\\end{bmatrix}.\n$$\n测试套件中的所有用例都使用此 $\\vec{f}$ 及指定的参数、初始条件、容差和步长控制器常量。所要求的输出是四个用例按顺序连接的结果，每个用例包括在 $t_f$ 时的最终状态分量（四舍五入到小数点后六位），后跟已接受步数的整数值。程序将这些值打印为由方括号括起的单个逗号分隔列表。\n\n此方法基于预测-校正对的局部误差行为，并提供了一种系统性的方法来调整步长以满足指定的容差，同时遵守步长的下限和上限，并确保在 $t_f$ 精确终止。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lorenz_rhs(y, sigma, rho, beta):\n    x, yv, z = y\n    return np.array([\n        sigma * (yv - x),\n        x * (rho - z) - yv,\n        x * yv - beta * z\n    ], dtype=np.float64)\n\ndef integrate_lorenz_pc_adaptive(y0, t0, tf, sigma, rho, beta,\n                                 tol, h0, hmin, hmax,\n                                 safety=0.9, gmin=0.2, gmax=2.0,\n                                 eps=1e-30):\n    y = np.array(y0, dtype=np.float64)\n    t = float(t0)\n    h = float(h0)\n    accepted_steps = 0\n\n    # Ensure bounds are sensible\n    hmin = float(hmin)\n    hmax = float(hmax)\n    safety = float(safety)\n    gmin = float(gmin)\n    gmax = float(gmax)\n\n    # Main adaptive loop\n    while t < tf:\n        # Prevent overshooting the final time\n        if t + h > tf:\n            h = tf - t\n        # Enforce min/max bounds on h for this attempt\n        if h < hmin:\n            h = hmin\n        if h > hmax:\n            h = hmax\n\n        f_n = lorenz_rhs(y, sigma, rho, beta)\n        y_pred = y + h * f_n\n        f_pred = lorenz_rhs(y_pred, sigma, rho, beta)\n        y_corr = y + 0.5 * h * (f_n + f_pred)\n\n        # Error estimate: Euclidean norm of difference\n        err = np.linalg.norm(y_corr - y_pred, ord=2)\n\n        # Compute multiplicative factor for next h\n        # Avoid division by zero using eps\n        ratio = tol / max(err, eps)\n        phi = safety * (ratio ** 0.5)\n        # Clip by growth/shrinkage limits\n        if phi < gmin:\n            phi = gmin\n        elif phi > gmax:\n            phi = gmax\n\n        if err <= tol:\n            # Accept step\n            y = y_corr\n            t = t + h\n            accepted_steps += 1\n            # Update h for next attempt, enforce bounds\n            h = h * phi\n            if h > hmax:\n                h = hmax\n            if h < hmin:\n                h = hmin\n        else:\n            # Reject step: shrink h and retry\n            h = h * phi\n            if h < hmin:\n                h = hmin\n            # Do not advance t or y\n\n        # Safety net to avoid pathological infinite loops:\n        # if h becomes effectively zero and cannot advance time, break.\n        if h <= 0.0:\n            break\n\n    return y, accepted_steps\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (sigma, rho, beta, y0, t0, tf, tol, h0, hmin, hmax, safety, gmin, gmax)\n    test_cases = [\n        # Case A\n        (10.0, 28.0, 8.0/3.0, (1.0, 1.0, 1.0), 0.0, 2.0, 1e-5, 1e-2, 1e-6, 5e-2, 0.9, 0.2, 2.0),\n        # Case B\n        (10.0, 28.0, 8.0/3.0, (1.0, 1.0, 1.0), 0.0, 2.0, 1e-2, 1e-2, 1e-6, 5e-1, 0.9, 0.2, 2.0),\n        # Case C\n        (10.0, 28.0, 8.0/3.0, (0.0, 1.0, 1.0), 0.0, 0.5, 1e-7, 1e-3, 1e-7, 5e-3, 0.9, 0.2, 2.0),\n        # Case D\n        (10.0, 0.0, 8.0/3.0, (5.0, 5.0, 5.0), 0.0, 1.0, 1e-6, 1e-2, 1e-7, 1e-1, 0.9, 0.2, 2.0),\n    ]\n\n    results_str = []\n    for case in test_cases:\n        sigma, rho, beta, y0, t0, tf, tol, h0, hmin, hmax, safety, gmin, gmax = case\n        y_final, n_acc = integrate_lorenz_pc_adaptive(\n            y0=y0, t0=t0, tf=tf,\n            sigma=sigma, rho=rho, beta=beta,\n            tol=tol, h0=h0, hmin=hmin, hmax=hmax,\n            safety=safety, gmin=gmin, gmax=gmax, eps=1e-30\n        )\n        # Append formatted floats and integer as specified\n        results_str.append(f\"{y_final[0]:.6f}\")\n        results_str.append(f\"{y_final[1]:.6f}\")\n        results_str.append(f\"{y_final[2]:.6f}\")\n        results_str.append(str(int(n_acc)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2429776"}]}