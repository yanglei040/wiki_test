{"hands_on_practices": [{"introduction": "在量子力学中，求解薛定谔方程是核心任务之一。本练习将指导你使用有限差分法，将微分方程形式的边值问题转化为一个矩阵本征值问题，这是一种解决线性边值问题的直接而强大的技术 [@problem_id:2377652]。通过亲手构建哈密顿量矩阵并与精确解进行比较，你将深刻理解算符离散化的过程及其精度。", "problem": "考虑一维稳态薛定谔边界值问题，对于势能为 $V(x) = \\tfrac{1}{2} m \\omega^{2} x^{2}$ 的量子谐振子：\n$$\n-\\frac{\\hbar^{2}}{2 m}\\,\\frac{d^{2}\\psi}{dx^{2}} + \\frac{1}{2} m \\omega^{2} x^{2}\\,\\psi(x) = E\\,\\psi(x),\n$$\n其束缚态条件为当 $x \\to \\pm \\infty$ 时，$\\psi(x) \\to 0$。为了将其转化为一个在有限区间上的计算边界值问题，我们将域截断为 $x \\in [-L,L]$，并施加齐次狄利克雷边界条件 $\\psi(-L)=\\psi(L)=0$。在 $[-L,L]$ 上使用一个包含 $N$ 个内部点的均匀网格，通过对称二阶有限差分对二阶导数进行离散化，并构建相应的哈密顿算符的对称矩阵表示。然后，计算最低的 $K$ 个能量本征值，并将其与已知的精确谐振子能谱 $E_n^{(\\mathrm{exact})} = \\hbar \\omega \\left(n + \\tfrac{1}{2}\\right)$（其中 $n \\in \\{0,1,\\dots\\}$）进行比较。\n\n您的程序必须：\n- 从不含时薛定谔方程出发，并在 $x=\\pm L$ 处施加边界条件。\n- 使用包含 $N$ 个内部点的均匀网格，并采用对称二阶有限差分来近似内部的二阶导数算符。\n- 将离散的哈密顿矩阵组装为离散动能算符与在网格点上求值的对角势能算符之和。\n- 计算该矩阵的最低 $K$ 个本征值。\n- 对于每个测试用例，计算前 $K$ 个能级的最大绝对相对误差：\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n < K} \\left| \\frac{E_n^{(\\mathrm{num})} - E_n^{(\\mathrm{exact})}}{E_n^{(\\mathrm{exact})}} \\right|.\n$$\n所有误差都应报告为无量纲的十进制数（最终报告值不需要物理单位）。\n\n测试套件：\n- 用例 1：$(\\hbar, m, \\omega, L, N, K) = (1, 1, 1, 8, 300, 6)$\n- 用例 2：$(\\hbar, m, \\omega, L, N, K) = (1, 1, 1, 6, 60, 4)$\n- 用例 3：$(\\hbar, m, \\omega, L, N, K) = (1, 1, 2.3, 8, 300, 5)$\n- 用例 4：$(\\hbar, m, \\omega, L, N, K) = (1, 1, 1, 3, 300, 4)$\n\n注意事项与约束：\n- 您必须将 $N$ 视为内部网格点的数量（因此包括边界在内的总点数为 $N+2$），并在 $x=\\pm L$ 处使用齐次狄利克雷边界值。\n- 为保证数值稳定性，请使用双精度实数运算。\n- 不涉及角度；无需角度单位。\n- 最终答案必须以无量纲数的形式报告。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与测试用例相同。每个数字必须以包含六位有效数字的科学记数法打印。例如：`[1.23457e-04,3.21000e-03,\\dots]`。\n\n您的任务：实现上述要求，并为四个测试用例生成指定格式的单行输出。", "solution": "所提出的问题是有效的。这是一个来自计算量子力学领域的、定义明确且具有科学依据的问题，没有任何不一致、模糊不清或事实错误。我现在将提供解决方案。\n\n问题的核心是通过在有限域上求解不含时薛定谔方程，来找到量子谐振子的离散能谱。控制方程为：\n$$\n-\\frac{\\hbar^{2}}{2 m}\\,\\frac{d^{2}\\psi}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n其中势能为 $V(x) = \\frac{1}{2} m \\omega^{2} x^{2}$。在无限域 $x \\in (-\\infty, \\infty)$ 上的解析解给出的能量本征值为 $E_n = \\hbar \\omega (n + \\frac{1}{2})$，其中 n 为非负整数。为了进行数值计算，问题必须被限制在有限区间 $x \\in [-L, L]$ 上，并施加边界条件 $\\psi(-L) = \\psi(L) = 0$。\n\n第一步是对域进行离散化。我们定义了一个包含 $N$ 个内部点的均匀网格。包括边界在内的总网格点数为 $N+2$。区间长度为 $2L$，它被划分为 $N+1$ 个子区间。因此，网格间距（或步长）为：\n$$\n\\Delta x = \\frac{L - (-L)}{N+1} = \\frac{2L}{N+1}\n$$\n网格点为 $x_i = -L + i \\cdot \\Delta x$，其中 $i \\in \\{0, 1, \\dots, N+1\\}$。波函数 $\\psi(x)$ 由其在这些点上的值 $\\psi_i = \\psi(x_i)$ 来表示。问题集中于 $N$ 个内部点 $x_1, \\dots, x_N$，在这些点上波函数是未知的。边界条件规定 $\\psi_0 = \\psi(-L) = 0$ 且 $\\psi_{N+1} = \\psi(L) = 0$。\n\n通过对算符进行离散化，连续的薛定谔方程被转换为一个矩阵本征值问题。在每个内部网格点 $x_i$ 处，二阶导数算符通过一个对称二阶有限差分公式来近似：\n$$\n\\left. \\frac{d^2\\psi}{dx^2} \\right|_{x_i} \\approx \\frac{\\psi(x_{i-1}) - 2\\psi(x_i) + \\psi(x_{i+1})}{(\\Delta x)^2} = \\frac{\\psi_{i-1} - 2\\psi_i + \\psi_{i+1}}{(\\Delta x)^2}\n$$\n将此近似代入内部点 $x_i$ 的薛定谔方程中，得到：\n$$\n-\\frac{\\hbar^2}{2m} \\left( \\frac{\\psi_{i-1} - 2\\psi_i + \\psi_{i+1}}{(\\Delta x)^2} \\right) + V(x_i)\\psi_i = E \\psi_i\n$$\n这组关于未知值 $\\psi_1, \\dots, \\psi_N$ 的 $N$ 个线性方程可以写成矩阵形式 $\\mathbf{H}\\vec{\\psi} = E\\vec{\\psi}$，其中 $\\vec{\\psi} = [\\psi_1, \\dots, \\psi_N]^T$ 是内部点上波函数值的向量，而 $\\mathbf{H}$ 是 $N \\times N$ 的离散哈密顿矩阵。\n\n哈密顿矩阵 $\\mathbf{H}$ 是动能矩阵 $\\mathbf{T}$ 和势能矩阵 $\\mathbf{V}$ 的和。\n\n势能算符变成一个对角矩阵 $\\mathbf{V}$，其元素对应于在每个内部网格点上求得的势能：\n$$\nV_{ij} = \\delta_{ij} V(x_i) = \\delta_{ij} \\left( \\frac{1}{2} m \\omega^2 x_i^2 \\right)\n$$\n\n动能算符产生一个三对角矩阵 $\\mathbf{T}$。其元素由有限差分公式导出：\n$$\n\\mathbf{T}_{ij} =\n\\begin{cases}\n\\frac{\\hbar^2}{m(\\Delta x)^2} & \\text{若 } i=j \\\\\n-\\frac{\\hbar^2}{2m(\\Delta x)^2} & \\text{若 } |i-j|=1 \\\\\n0 & \\text{其他情况}\n\\end{cases}\n$$\n边界条件 $\\psi_0=0$ 和 $\\psi_{N+1}=0$ 被直接并入第一个（$i=1$）和最后一个（$i=N$）内部点的方程中，确保了三对角结构的维持。\n\n因此，完整的哈密顿矩阵 $\\mathbf{H} = \\mathbf{T} + \\mathbf{V}$ 是一个实的、对称的、三对角的矩阵，其元素为：\n$$\nH_{ij} =\n\\begin{cases}\n\\frac{\\hbar^2}{m(\\Delta x)^2} + \\frac{1}{2} m \\omega^2 x_i^2 & \\text{若 } i=j \\\\\n-\\frac{\\hbar^2}{2m(\\Delta x)^2} & \\text{若 } |i-j|=1 \\\\\n0 & \\text{其他情况}\n\\end{cases}\n$$\n问题简化为求解该矩阵 $\\mathbf{H}$ 的本征值。由于 $\\mathbf{H}$ 是对称且三对角的，其本征值可以非常高效地计算出来。$\\mathbf{H}$ 的最低 $K$ 个本征值对应于量子系统前 $K$ 个能级的数值估计值 $E_n^{(\\mathrm{num})}$，其中 $n \\in \\{0, 1, \\dots, K-1\\}$。\n\n最后，将这些数值本征值与精确的解析本征值 $E_n^{(\\mathrm{exact})} = \\hbar \\omega (n + \\frac{1}{2})$ 进行比较。数值近似的质量通过最低 $K$ 个态的最大绝对相对误差来量化：\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n < K} \\left| \\frac{E_n^{(\\mathrm{num})} - E_n^{(\\mathrm{exact})}}{E_n^{(\\mathrm{exact})}} \\right|\n$$\n实现中将使用 `scipy.linalg.eigh_tridiagonal` 函数，该函数专门为求解对称三对角矩阵的本征值进行了优化。我们将为每个测试用例请求最低的 $K$ 个本征值，计算精确值，然后计算 $\\varepsilon_{\\max}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the stationary Schrödinger boundary value problem for the quantum\n    harmonic oscillator using a finite difference method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (hbar, m, omega, L, N, K)\n    test_cases = [\n        (1.0, 1.0, 1.0, 8.0, 300, 6),\n        (1.0, 1.0, 1.0, 6.0, 60, 4),\n        (1.0, 1.0, 2.3, 8.0, 300, 5),\n        (1.0, 1.0, 1.0, 3.0, 300, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        hbar, m, omega, L, N, K = case\n\n        # 1. Discretize the spatial domain [-L, L] with N interior points.\n        # The total number of intervals is N+1.\n        delta_x = 2.0 * L / (N + 1)\n        \n        # Grid of N interior points x_i for i=1, ..., N.\n        # The numpy array will be 0-indexed, corresponding to i=1...N.\n        x_interior = np.linspace(-L + delta_x, L - delta_x, N)\n\n        # 2. Construct the discrete Hamiltonian matrix H as a tridiagonal matrix.\n        # H is the sum of the kinetic matrix T and potential matrix V.\n\n        # The potential energy V(x) = 0.5 * m * omega^2 * x^2 evaluated\n        # at the interior grid points gives the diagonal of V.\n        potential_diagonal = 0.5 * m * (omega**2) * (x_interior**2)\n\n        # The finite difference approximation of the kinetic energy operator\n        # gives the diagonal and off-diagonal elements of T.\n        # T_ii = hbar^2 / (m * delta_x^2)\n        # T_{i, i-1} = T_{i, i+1} = -hbar^2 / (2 * m * delta_x^2)\n        kinetic_diag_term = hbar**2 / (m * delta_x**2)\n        kinetic_off_diag_term = -hbar**2 / (2.0 * m * delta_x**2)\n\n        # The main diagonal of H is the sum of the diagonals of T and V.\n        main_diagonal = kinetic_diag_term + potential_diagonal\n        \n        # The off-diagonal of H is the same as the off-diagonal of T.\n        off_diagonal = np.full(N - 1, kinetic_off_diag_term)\n\n        # 3. Solve the eigenvalue problem for the lowest K eigenvalues.\n        # eigh_tridiagonal is highly efficient for symmetric tridiagonal matrices.\n        # 'select=\"i\"' and 'select_range=(0, K-1)' computes the K smallest\n        # eigenvalues (indices 0 to K-1). Eigenvalues are returned in ascending order.\n        eigenvalues_numerical = eigh_tridiagonal(\n            main_diagonal, \n            off_diagonal, \n            select='i', \n            select_range=(0, K - 1), \n            eigvals_only=True\n        )\n\n        # 4. Calculate the corresponding exact eigenvalues for comparison.\n        # E_n = hbar * omega * (n + 0.5) for n = 0, 1, ..., K-1.\n        n_levels = np.arange(K)\n        eigenvalues_exact = hbar * omega * (n_levels + 0.5)\n\n        # 5. Compute the maximum absolute relative error over the K levels.\n        relative_errors = np.abs((eigenvalues_numerical - eigenvalues_exact) / eigenvalues_exact)\n        max_relative_error = np.max(relative_errors)\n        \n        results.append(max_relative_error)\n\n    # Final print statement in the exact required format.\n    # Format each number in scientific notation with 6 significant digits (1 before, 5 after decimal).\n    formatted_results = [f\"{res:.5e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2377652"}, {"introduction": "物理学中的许多边值问题本质上是非线性的，并可能展现出多重解等复杂行为。本练习介绍打靶法，它巧妙地将边值问题（BVP）转化为一个初值问题（IVP）和一个求根问题 [@problem_id:2377656]。通过这个实践，你将学会如何处理非线性BVP，并直观地揭示其解的非唯一性这一迷人现象。", "problem": "考虑一个有限区间上的非线性常微分方程边值问题：求一个满足以下条件的函数 $y(x)$\n$$\ny''(x) + y(x)^3 = 0 \\quad \\text{for } x \\in [0,L], \\quad \\text{with} \\quad y(0)=0, \\; y(L)=0,\n$$\n其中 $L>0$ 是一个给定的长度。该问题是一个单位质量粒子在四次势 $V(y)=\\tfrac{1}{4}y^4$ 中运动的模型，其中 $x$ 扮演时间的角色。从经典力学和常微分方程的第一性原理出发，完成以下任务。\n\n1) 从牛顿第二定律和单位质量的机械能定义出发，利用势 $V(y)=\\tfrac{1}{4}y^4$ 来证明，具有初始条件 $y(0)=0$ 和 $y'(0)=s$ 的初值问题其能量是守恒的\n$$\nE = \\tfrac{1}{2}\\,[y'(x)]^2 + \\tfrac{1}{4}\\, [y(x)]^4,\n$$\n并且，对于 $s>0$ 的情况，解 $y(x)$ 是关于 $x$ 的周期函数，并在由能量决定的对称转折点 $\\pm A$ 之间振荡。然后，仅使用这些基本事实（不引用任何预先推导的周期公式），定性地论证为何对于一个固定的 $L$，该边值问题可以存在多个不同的解：初始斜率 $s$ 的不同选择可以产生不同轨迹，在这些轨迹中，一个或多个半振荡恰好吻合区间 $[0,L]$，并且都满足相同的最终边界条件 $y(L)=0$。\n\n2) 实现一个打靶法，以数值方式揭示这种非唯一性。将初始斜率 $s=y'(0)$ 视为一个可调节的打靶参数，并定义残差\n$$\nR(s;L) := y(L;s),\n$$\n其中 $y(x;s)$ 是满足 $y(0)=0$ 和 $y'(0)=s$ 的初值问题的解。使用一个数值稳定的常微分方程积分器求解与二阶方程等价的一阶系统，并使用一个稳健的基于区间搜索的一维求根器来定位 $R(s;L)=0$ 的不同正根。具体而言：\n- 将二阶方程转换为一阶系统 $y_1' = y_2$, $y_2' = -y_1^3$，其中 $y_1(0)=0$ 且 $y_2(0)=s$。\n- 对于每个给定的 $L$，计算两个最小的、不同的正打靶值 $s_1(L)$ 和 $s_2(L)$，使得 $s_2(L) > s_1(L) > 0$ 且 $|R(s_k;L)| \\le \\varepsilon$（容差 $\\varepsilon = 10^{-8}$）。\n- 排除平凡解 $s=0$。\n\n3) 测试集。在以下三组域长度上运行你的程序：\n- $L_1 = 1.00$，\n- $L_2 = 1.20$，\n- $L_3 = 0.75$。\n对于每个 $L_i$，返回列表 $[s_1(L_i), s_2(L_i)]$，四舍五入到 $6$ 位小数。你的最终程序输出必须是单行，包含一个用方括号括起来的、以逗号分隔的结果列表，顺序为 $L_1, L_2, L_3$，例如：\n$[[s_1(L_1),s_2(L_1)],[s_1(L_2),s_2(L_2)],[s_1(L_3),s_2(L_3)]]$。\n所有数字必须以十进制表示法书写。不应打印任何额外文本。\n\n附加实现要求：\n- 使用一个标准的自适应步长常微分方程求解器，其绝对和相对容差不大于 $10^{-9}$。\n- 使用一个区间求根方法，其对 $s$ 的绝对解容差不大于 $10^{-10}$。\n- 通过在足够大的 $s$ 区间内进行符号变化扫描来确保稳健性，从而为每个 $L_i$ 分离出至少两个不同的正根。", "solution": "所述问题已经过验证，被认定具有科学依据、良态的 (well-posed)、客观且内部一致。这是一个计算物理和非线性动力学中的标准问题，涉及保守系统的边值问题（BVP）求解。所有必需的数据、方程和约束条件均已提供。因此，该问题被视为有效。我们接下来提供一个完整的解。\n\n按照要求，解答分为两部分：第一部分是从第一性原理出发的理论论证，第二部分是为解决该问题而设计的数值打靶法的描述。\n\n**1. 理论论证与定性分析**\n\n该问题涉及一个单位质量（$m=1$）的粒子在一个由势能函数 $V(y)$ 导出的力 $F(y)$ 作用下的运动。牛顿第二定律指出 $ma = F$，其中加速度为 $a = y''(x)$，$x$ 代表时间。该力是保守力，由 $F(y) = -V'(y)$ 给出。对于给定的势 $V(y) = \\frac{1}{4}y^4$，相应的力为 $F(y) = -\\frac{d}{dy}(\\frac{1}{4}y^4) = -y^3$。将这些代入 $m=1$ 的牛顿定律，得到：\n$$\n(1) y''(x) = -y(x)^3\n$$\n整理后得到指定的常微分方程 (ODE)：\n$$\ny''(x) + y(x)^3 = 0.\n$$\n这证实了控制方程的物理来源。\n\n为了证明机械能守恒，我们将该 ODE 乘以速度 $y'(x)$：\n$$\ny''(x) y'(x) + y(x)^3 y'(x) = 0.\n$$\n此表达式等价于能量对时间的全导数。注意到 $y'' y' = \\frac{d}{dx}(\\frac{1}{2}[y'(x)]^2)$ 且 $y^3 y' = \\frac{d}{dx}(\\frac{1}{4}[y(x)]^4)$，我们得到：\n$$\n\\frac{d}{dx} \\left( \\frac{1}{2}[y'(x)]^2 + \\frac{1}{4}[y(x)]^4 \\right) = 0.\n$$\n这意味着括号内的量，即总机械能 $E$，是一个运动常量：\n$$\nE = \\frac{1}{2}[y'(x)]^2 + \\frac{1}{4}[y(x)]^4 = \\text{constant}.\n$$\n能量 $E$ 由初始条件决定。对于具有 $y(0)=0$ 和 $y'(0)=s$ 的初值问题 (IVP)，能量为：\n$$\nE = \\frac{1}{2}[y'(0)]^2 + \\frac{1}{4}[y(0)]^4 = \\frac{1}{2}s^2 + \\frac{1}{4}(0)^4 = \\frac{1}{2}s^2.\n$$\n对于任何 $s > 0$，能量 $E > 0$。粒子的运动受势能的限制。振荡的转折点，记为 $\\pm A$，发生在速度 $y'(x)$ 为零的地方。在这些点上，动能为零，所有能量都是势能：$E = V(A) = \\frac{1}{4}A^4$。将两个能量表达式相等，得到：\n$$\n\\frac{1}{2}s^2 = \\frac{1}{4}A^4 \\implies A = (2s^2)^{1/4}.\n$$\n粒子从 $y(0)=0$ 处以正速度 $s$ 开始运动，朝正转折点 $+A$ 移动，然后反向，以速度 $-s$ 经过 $y=0$，到达负转折点 $-A$，最终返回到 $y=0$。这个循环构成了一个周期性运动。\n\nBVP 解的非唯一性源于 IVP 解的周期性。边界条件 $y(L)=0$ 要求粒子在时间 $x=L$ 时位于原点。从 $y(0)=0$ 出发，粒子在经过一个半周期、两个半周期（一个完整周期）、三个半周期等等之后再次到达 $y=0$。设 $T_{1/2}(s)$ 表示与初始斜率 $s$ 相对应的振荡的半周期。如果区间长度 $L$ 是半周期的整数倍，则边界条件 $y(L)=0$ 得到满足：\n$$\nL = k \\cdot T_{1/2}(s) \\quad \\text{for } k = 1, 2, 3, \\dots\n$$\n这个非谐振子的周期取决于其能量，因此也取决于 $s$。通过改变 $s$，我们改变了周期。对于一个固定的长度 $L$，上述方程成为一个关于 $s$ 的隐式方程。这个方程很可能可以对不同的 $s$ 值求解，每个 $s$ 值对应一个不同的整数 $k$。对于 $k=1$，我们寻找一个初始斜率 $s_1$，使得粒子在区间 $[0, L]$ 内恰好完成其第一个半振荡。这产生了基解，一个单拱形。对于 $k=2$，我们寻找另一个斜率 $s_2$，使得粒子在 $[0, L]$ 内完成两个半振荡（一个全波）。这些不同的值 $s_1, s_2, \\dots$ 都产生了解 $y(x; s_k)$，它们都满足两个边界条件 $y(0)=0$ 和 $y(L)=0$，从而解释了 BVP 存在多个非平凡解的原因。\n\n**2. 数值设计：打靶法**\n\n为了用数值方法找到这些不同的初始斜率，我们采用打靶法。该方法将 BVP 重新构造为一个求根问题。\n\n打靶参数是未知的初始斜率，$s = y'(0)$。\nIVP 定义为：\n$$\ny''(x) + y(x)^3 = 0, \\quad y(0)=0, \\quad y'(0)=s.\n$$\n为了数值求解，我们将二阶 ODE 转换为等价的一阶系统。设 $y_1(x) = y(x)$ 和 $y_2(x) = y'(x)$。该系统为：\n$$\n\\begin{cases}\ny_1'(x) = y_2(x) \\\\\ny_2'(x) = -y_1(x)^3\n\\end{cases}\n$$\n在 $x=0$ 处的初始条件为：\n$$\n\\begin{pmatrix} y_1(0) \\\\ y_2(0) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ s \\end{pmatrix}.\n$$\n我们将此系统从 $x=0$ 积分到 $x=L$。在 $x=L$ 处的解，我们记作 $y(L;s)$，它依赖于 $s$ 的选择。第二个边界条件 $y(L)=0$ (或 $y_1(L)=0$) 仅对特定的 $s$ 值成立。我们定义一个残差函数 $R(s;L)$，它衡量在最终边界上的不匹配程度：\n$$\nR(s;L) = y_1(L;s).\n$$\n问题现在就变成了寻找方程 $R(s;L) = 0$ 的根。\n\n数值步骤如下：\n1.  **定义残差函数**：创建一个函数，对于给定的 $s$ 和 $L$，该函数使用高精度、自适应步长的 ODE 积分器（例如 `scipy.integrate.solve_ivp`，其绝对和相对容差设为 $10^{-10}$）从 $x=0$ 到 $x=L$ 对 IVP 进行数值求解。该函数返回 $y_1(L)$ 的值。\n2.  **确定根的区间**：正如定性分析所论证的，残差 $R(s;L)$ 将是 $s$ 的一个振荡函数。为了找到它的根，我们首先需要将它们隔离在区间内。我们通过在一系列 $s$ 网格点上评估 $R(s;L)$ 并识别出相邻点对 $(s_a, s_b)$ 来实现这一点，在这些点对上 $R(s_a;L)$ 和 $R(s_b;L)$ 符号相反。每个这样的区间 $[s_a, s_b]$ 都保证至少包含一个根。\n3.  **求解根**：对于找到的每个区间 $[s_a, s_b]$，使用一个稳健的一维区间求根器（例如 Brent 方法，`scipy.optimize.brentq`）来高精度地定位根 $s_k$（对 $s$ 的容差设为 $10^{-11}$）。\n4.  **收集并报告结果**：我们对每个给定的长度 $L_i$ 应用此过程，以找到两个最小的、不同的正根 $s_1(L_i)$ 和 $s_2(L_i)$，将它们四舍五入到指定精度，并按要求格式化输出。平凡解 $s=0$ 被明确排除。\n\n这种高保真度 ODE 求解器和可靠的求根算法的结合，为确定非线性 BVP 的非唯一解提供了一种稳健而精确的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear BVP y'' + y^3 = 0 with y(0)=0, y(L)=0\n    using a shooting method to find the first two non-trivial positive\n    initial slopes s = y'(0) for given lengths L.\n    \"\"\"\n\n    # --- 1. Define the core components of the shooting method ---\n\n    # ODE system: y' = f(x, y), where y = [y_1, y_2] = [y, y']\n    def ode_system(t, y):\n        \"\"\"First-order system for y'' = -y^3\"\"\"\n        return [y[1], -y[0]**3]\n\n    # Residual function R(s; L) = y(L; s)\n    def residual(s, L):\n        \"\"\"\n        Computes the residual R(s;L) = y(L;s) by solving the IVP.\n\n        Args:\n            s (float): The initial slope y'(0), our shooting parameter.\n            L (float): The length of the interval [0, L].\n\n        Returns:\n            float: The value of y(L), which we want to be zero.\n        \"\"\"\n        if s == 0:\n            return 0.0 # Trivial solution y(x)=0 for all x\n\n        # Initial conditions for the IVP: y(0)=0, y'(0)=s\n        y0 = [0.0, s]\n        \n        # Integration interval\n        t_span = [0, L]\n        \n        # High-precision ODE solver settings\n        atol = 1e-10\n        rtol = 1e-10\n\n        # Solve the initial value problem\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=t_span,\n            y0=y0,\n            method='DOP853',\n            atol=atol,\n            rtol=rtol,\n        )\n        \n        # Return the final value of y(x), which is y_1(L)\n        # sol.y is a 2xN array. We need the first component at the last time step.\n        return sol.y[0, -1]\n\n    # --- 2. Implement the root-finding logic ---\n\n    def find_shooting_values(L, num_roots=2):\n        \"\"\"\n        Finds the first `num_roots` positive values of s for a given L.\n        \"\"\"\n        roots = []\n        \n        # Scan for sign changes to find brackets for the roots.\n        # The required s values increase as L decreases. The scan range\n        # must be large enough to find the required number of roots.\n        s_scan_points = np.linspace(0.1, 100.0, 500)\n        r_values = np.array([residual(s, L) for s in s_scan_points])\n        \n        # Find intervals where the sign of the residual changes\n        for i in range(len(s_scan_points) - 1):\n            if np.sign(r_values[i]) != np.sign(r_values[i+1]):\n                s_a, s_b = s_scan_points[i], s_scan_points[i+1]\n                \n                try:\n                    # Use a robust bracketing root-finder\n                    root = brentq(\n                        residual, \n                        a=s_a, \n                        b=s_b, \n                        args=(L,), \n                        xtol=1e-11 # Tolerance on the root s\n                    )\n                    roots.append(root)\n                    \n                    if len(roots) == num_roots:\n                        break\n                except ValueError:\n                    # brentq can fail if signs are not opposite, though our check prevents this.\n                    continue\n        \n        if len(roots) < num_roots:\n            raise RuntimeError(f\"Could not find {num_roots} roots for L={L}. Try increasing the scan range for s.\")\n        \n        return sorted(roots)\n\n    # --- 3. Execute for the test suite ---\n\n    # Define the test cases from the problem statement.\n    test_cases = [1.00, 1.20, 0.75]\n    \n    all_results = []\n    \n    for L_val in test_cases:\n        # Find the two smallest positive shooting values\n        s1, s2 = find_shooting_values(L_val, num_roots=2)\n        \n        # Round to 6 decimal places as required\n        result_pair = [round(s1, 6), round(s2, 6)]\n        all_results.append(result_pair)\n    \n    # Format the final output string exactly as specified\n    # e.g., [[val1,val2],[val3,val4]]\n    output_str = \"[\" + \",\".join([str(pair) for pair in all_results]) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n```", "id": "2377656"}, {"introduction": "最具挑战性的一些问题涉及“自由”或“移动”边界，即问题的求解域本身就是解的一部分。本练习探讨经典的“斯特凡问题”，通过一个巧妙的相似性变换，将一个复杂的自由边值问题简化为求解一个决定边界运动的超越方程 [@problem_id:2377639]。这个高级实践展示了如何融合解析洞察力与数值方法，来攻克看似棘手的物理难题。", "problem": "考虑在半无限半直线上的经典一维单相 Stefan 熔化问题。一个初始温度为熔化温度 $T_m$ 的半无限固相占据 $x>0$ 的区域。对于 $t>0$， $x=0$ 处的边界保持在恒定温度 $T_s$（其中 $T_s>T_m$），于是在 $0<x<s(t)$ 区域产生一个液相，与 $x=s(t)$ 处的固相分离，其中 $s(t)$ 是未知的移动界面。假设液相具有恒定的物性参数：密度 $\\rho$、比热容 $c$、导热系数 $k$ 和热扩散率 $\\alpha=k/(\\rho c)$。液相温度 $T(x,t)$ 在 $0<x<s(t)$ 上满足热方程 $T_t=\\alpha T_{xx}$，边界条件为 $T(0,t)=T_s$ 和 $T(s(t),t)=T_m$，而 $x>s(t)$ 的固相保持在温度 $T_m$。移动界面处的能量平衡由 Stefan 条件给出：$\\rho L \\, s'(t)=-k\\,T_x(x=s(t)^-,t)$，其中 $L$ 是熔化潜热，上标 $^-$ 表示从液相一侧取极限。\n\n使用上述数学模型，所有量均以国际单位制表示，为下列材料参数和测试用例确定界面位置 $s(t)$：\n- 材料参数（不随时间变化）：$\\rho = 1000\\,\\mathrm{kg/m^3}$，$c = 4180\\,\\mathrm{J/(kg\\cdot K)}$，$k = 0.6\\,\\mathrm{W/(m\\cdot K)}$，$L = 334000\\,\\mathrm{J/kg}$，$T_m = 273.15\\,\\mathrm{K}$，以及 $\\alpha = k/(\\rho c)$。\n- 边界温度和评估时间的测试组（每对 $(T_s,t)$ 均应独立处理）：\n  1. $(T_s,t)=\\left(283.15\\,\\mathrm{K},\\,3600\\,\\mathrm{s}\\right)$，\n  2. $(T_s,t)=\\left(273.65\\,\\mathrm{K},\\,3600\\,\\mathrm{s}\\right)$，\n  3. $(T_s,t)=\\left(303.15\\,\\mathrm{K},\\,3600\\,\\mathrm{s}\\right)$，\n  4. $(T_s,t)=\\left(283.15\\,\\mathrm{K},\\,10\\,\\mathrm{s}\\right)$。\n\n对于每个测试用例，计算 $s(t)$ 的值（单位为米）。将每个数值答案以米为单位表示，并四舍五入到六位小数。\n\n您的程序必须生成一行输出，其中包含测试组的结果，顺序与上面列出的顺序相同，形式为一个用方括号括起来的逗号分隔列表。例如，输出格式必须与 $[a,b,c,d]$ 完全一样，其中每个条目都四舍五入到六位小数，并且没有附加文本。此问题不涉及角度，也不需要角度单位。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n\n在区域 $0 < x < s(t)$ 中，液相温度 $T(x,t)$ 的控制偏微分方程是热方程：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\n边界条件为：\n$$\nT(0, t) = T_s, \\quad t>0\n$$\n$$\nT(s(t), t) = T_m, \\quad t>0\n$$\n初始条件是 $x>0$ 的固相温度为 $T_m$。液相在 $t>0$ 时形成，因此界面的初始位置是 $s(0)=0$。\n\n$x=s(t)$ 处移动界面上的 Stefan 条件是：\n$$\n\\rho L \\frac{ds}{dt} = -k \\left. \\frac{\\partial T}{\\partial x} \\right|_{x=s(t)^-}\n$$\n给定的材料参数如下：\n- 密度：$\\rho = 1000\\,\\mathrm{kg/m^3}$\n- 比热容：$c = 4180\\,\\mathrm{J/(kg\\cdot K)}$\n- 导热系数：$k = 0.6\\,\\mathrm{W/(m\\cdot K)}$\n- 熔化潜热：$L = 334000\\,\\mathrm{J/kg}$\n- 熔化温度：$T_m = 273.15\\,\\mathrm{K}$\n- 热扩散率定义为 $\\alpha = k/(\\rho c)$。\n\n测试用例是四对 $(T_s, t)$：\n1. $(T_s,t)=\\left(283.15\\,\\mathrm{K},\\,3600\\,\\mathrm{s}\\right)$\n2. $(T_s,t)=\\left(273.65\\,\\mathrm{K},\\,3600\\,\\mathrm{s}\\right)$\n3. $(T_s,t)=\\left(303.15\\,\\mathrm{K},\\,3600\\,\\mathrm{s}\\right)$\n4. $(T_s,t)=\\left(283.15\\,\\mathrm{K},\\,10\\,\\mathrm{s}\\right)$\n\n**步骤2：使用提取的已知条件进行验证**\n\n该问题是一个经典的一维单相 Stefan 问题。\n- **科学依据：**该模型基于应用于热传导和相变过程的能量守恒基本原理。热方程和 Stefan 条件是该领域的经典方程。所提供的所有参数都符合物理实际，与水/冰的参数相对应。\n- **适定性：**这是一个数理物理学中的标准问题，有已知的求解方法，可以得到唯一的结果。\n- **客观性：**问题以精确的、定量的术语陈述。\n- **完备性：**提供了获得唯一解所需的所有必要的物理常数和边界/初始条件。\n\n**步骤3：结论与行动**\n\n该问题是有效的。将推导严格的解析解。\n\n**求解推导**\n\n此问题接受相似性解。我们引入一个相似性变量 $\\eta$：\n$$\n\\eta = \\frac{x}{2\\sqrt{\\alpha t}}\n$$\n我们寻找形式为 $T(x,t) = f(\\eta)$ 的温度解。$T$ 的导数为：\n$$\n\\frac{\\partial T}{\\partial t} = f'(\\eta) \\frac{\\partial \\eta}{\\partial t} = f'(\\eta) \\left( -\\frac{x}{4\\sqrt{\\alpha} t^{3/2}} \\right) = -\\frac{\\eta}{2t} f'(\\eta)\n$$\n$$\n\\frac{\\partial T}{\\partial x} = f'(\\eta) \\frac{\\partial \\eta}{\\partial x} = \\frac{1}{2\\sqrt{\\alpha t}} f'(\\eta)\n$$\n$$\n\\frac{\\partial^2 T}{\\partial x^2} = \\frac{1}{4\\alpha t} f''(\\eta)\n$$\n将这些代入热方程 $T_t = \\alpha T_{xx}$，得到：\n$$\n-\\frac{\\eta}{2t} f'(\\eta) = \\alpha \\left( \\frac{1}{4\\alpha t} f''(\\eta) \\right) \\implies f''(\\eta) + 2\\eta f'(\\eta) = 0\n$$\n这是一个关于 $f(\\eta)$ 的二阶常微分方程。\n\n移动界面的位置 $s(t)$ 必须与相似性变换一致。这要求 $s(t)$ 与 $\\sqrt{t}$ 成正比。我们定义一个无量纲常数 $\\lambda$ 使得：\n$$\ns(t) = 2\\lambda\\sqrt{\\alpha t}\n$$\n在此位置，相似性变量的值为常数 $\\eta = \\lambda$。\n\n$T(x,t)$ 的边界条件被转换为 $f(\\eta)$ 的边界条件：\n- 在 $x=0$ 处，我们有 $\\eta=0$。因此，$T(0,t) = T_s \\implies f(0) = T_s$。\n- 在 $x=s(t)$ 处，我们有 $\\eta=\\lambda$。因此，$T(s(t),t) = T_m \\implies f(\\lambda) = T_m$。\n\n通过两次连续积分，可以找到常微分方程 $f'' + 2\\eta f' = 0$ 的通解。解的形式为：\n$$\nf(\\eta) = A \\cdot \\mathrm{erf}(\\eta) + B\n$$\n其中 $\\mathrm{erf}(\\eta) = \\frac{2}{\\sqrt{\\pi}} \\int_0^\\eta e^{-u^2} du$ 是误差函数，$A$ 和 $B$ 是常数。\n\n应用 $f(\\eta)$ 的边界条件：\n- $f(0) = T_s \\implies A \\cdot \\mathrm{erf}(0) + B = T_s \\implies B = T_s$。\n- $f(\\lambda) = T_m \\implies A \\cdot \\mathrm{erf}(\\lambda) + T_s = T_m \\implies A = \\frac{T_m - T_s}{\\mathrm{erf}(\\lambda)}$。\n\n因此，液相中的温度分布为：\n$$\nT(x,t) = T_s + (T_m-T_s) \\frac{\\mathrm{erf}\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right)}{\\mathrm{erf}(\\lambda)}\n$$\n现在我们应用 Stefan 条件，这需要导数 $s'(t)$ 和 $T_x(x,t)$：\n$$\ns'(t) = \\frac{d}{dt} (2\\lambda\\sqrt{\\alpha t}) = \\lambda\\sqrt{\\frac{\\alpha}{t}}\n$$\n$$\n\\frac{\\partial T}{\\partial x} = \\frac{T_m-T_s}{\\mathrm{erf}(\\lambda)} \\cdot \\frac{d}{dx} \\left( \\mathrm{erf}\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right) \\right) = \\frac{T_m-T_s}{\\mathrm{erf}(\\lambda)} \\cdot \\frac{2}{\\sqrt{\\pi}} e^{-\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right)^2} \\cdot \\frac{1}{2\\sqrt{\\alpha t}}\n$$\n在界面 $x=s(t)$（其中 $\\eta=\\lambda$）处计算温度梯度：\n$$\n\\left. \\frac{\\partial T}{\\partial x} \\right|_{x=s(t)^-} = \\frac{T_m-T_s}{\\mathrm{erf}(\\lambda)} \\frac{e^{-\\lambda^2}}{\\sqrt{\\pi\\alpha t}}\n$$\n将这些代入 Stefan 条件 $\\rho L s'(t) = -k T_x(s(t),t)$：\n$$\n\\rho L \\left(\\lambda\\sqrt{\\frac{\\alpha}{t}}\\right) = -k \\left( \\frac{T_m-T_s}{\\mathrm{erf}(\\lambda)} \\frac{e^{-\\lambda^2}}{\\sqrt{\\pi\\alpha t}} \\right)\n$$\n简化并整理各项：\n$$\n\\rho L \\lambda \\sqrt{\\frac{\\alpha}{t}} = k \\frac{T_s-T_m}{\\mathrm{erf}(\\lambda)} \\frac{e^{-\\lambda^2}}{\\sqrt{\\pi\\alpha t}}\n$$\n$$\n\\rho L \\lambda \\alpha \\sqrt{\\pi} \\mathrm{erf}(\\lambda) = k(T_s-T_m) e^{-\\lambda^2}\n$$\n使用热扩散率的定义 $\\alpha = k/(\\rho c)$：\n$$\n\\rho L \\lambda \\frac{k}{\\rho c} \\sqrt{\\pi} \\mathrm{erf}(\\lambda) = k(T_s-T_m) e^{-\\lambda^2}\n$$\n$$\n\\frac{L\\lambda\\sqrt{\\pi}}{c} \\mathrm{erf}(\\lambda) = (T_s-T_m) e^{-\\lambda^2}\n$$\n这就得到了关于未知常数 $\\lambda$ 的最终超越方程：\n$$\n\\frac{e^{-\\lambda^2}}{\\lambda \\mathrm{erf}(\\lambda)} = \\frac{L \\sqrt{\\pi}}{c(T_s - T_m)}\n$$\n对于每个测试用例，我们必须数值求解此方程以得到 $\\lambda$。方程右侧的项对于给定的参数集是一个常数。设该常数为 $C_{st}$。对于 $\\lambda > 0$，左侧的函数是单调的，保证了唯一的正解。一旦确定了 $\\lambda$，就可以使用 $s(t) = 2\\lambda\\sqrt{\\alpha t}$ 计算界面位置。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the one-phase Stefan problem for the given material parameters\n    and test cases.\n    \"\"\"\n\n    # Material parameters in SI units\n    rho = 1000.  # kg/m^3\n    c = 4180.    # J/(kg*K)\n    k = 0.6      # W/(m*K)\n    L = 334000.  # J/kg\n    T_m = 273.15 # K\n\n    # Calculate thermal diffusivity\n    alpha = k / (rho * c)\n\n    # Test suite of boundary temperatures and evaluation times\n    test_cases = [\n        # (T_s in K, t in s)\n        (283.15, 3600.0),\n        (273.65, 3600.0),\n        (303.15, 3600.0),\n        (283.15, 10.0),\n    ]\n\n    results = []\n    \n    for T_s, t in test_cases:\n        # Check for the trivial case to avoid division by zero.\n        # This problem assumes T_s > T_m.\n        if T_s <= T_m:\n            results.append(0.0)\n            continue\n\n        # The transcendental equation for lambda is F(lambda) = C\n        # where F(lambda) = exp(-lambda^2) / (lambda * erf(lambda))\n        # and C = L * sqrt(pi) / (c * (T_s - T_m))\n        \n        # Calculate the constant part of the equation\n        const_C = (L * np.sqrt(np.pi)) / (c * (T_s - T_m))\n\n        # Define the function whose root we need to find, g(lambda) = F(lambda) - C = 0\n        def g(lam):\n            if lam <= 0:\n                # The function diverges at lambda=0, return a large positive number\n                return np.inf\n            return np.exp(-lam**2) / (lam * erf(lam)) - const_C\n        \n        # The function g(lambda) is strictly decreasing for lambda > 0.\n        # g(lambda -> 0+) -> +inf\n        # g(lambda -> inf) -> -const_C\n        # A root is guaranteed in (0, inf). We use a reasonably large bracket.\n        bracket = [1e-9, 10.0]\n        \n        # Solve for lambda using a robust root-finding algorithm\n        sol = root_scalar(g, bracket=bracket, method='brentq')\n        lambda_val = sol.root\n\n        # Calculate the interface position s(t)\n        s_t = 2 * lambda_val * np.sqrt(alpha * t)\n        \n        # Round to 6 decimal places as required\n        results.append(round(s_t, 6))\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2377639"}]}