{"hands_on_practices": [{"introduction": "动手实践的第一步是亲手实现一个方法。这个练习将指导你构建一个可重用的、基于类的 Python 求解器，能够处理不同阶数的 Adams–Bashforth 方法。通过为一系列具有已知精确解的初值问题计算数值解，你将不仅掌握该方法的核心公式，还将学习到处理多步法所必需的“启动”程序的实际操作，并验证你代码的正确性。[@problem_id:2371225]", "problem": "构建一个完整、可运行的程序，该程序定义一个用于显式 Adams–Bashforth 多步法的基于类的求解器，并用它来积分几个初值问题。求解器必须维护其内部状态，该状态由最近的右端项求值结果组成，顺序为 $\\left[f_n,f_{n-1},\\dots\\right]$，其中 $f_n=f\\left(t_n,y_n\\right)$。求解器必须支持恒定步长以及 $k \\in \\{1,2,3,4\\}$ 的阶数。所有变量均应视为无量纲。角度（若出现）必须以弧度为单位进行解释。\n\n对于下文描述的每个测试用例，程序必须使用固定的步长 $h$ 和指定的 Adams–Bashforth 阶数 $k$，对给定的初值问题从 $t=t_0$ 到 $t=t_{\\mathrm{final}}$ 进行数值积分。对每个测试用例，按如下方式计算一个标量误差：对于标量问题，误差为绝对值 $|y\\left(t_{\\mathrm{final}}\\right)-y_{\\mathrm{exact}}\\left(t_{\\mathrm{final}}\\right)|$；对于向量问题，误差为欧几里得范数 $\\left\\|y\\left(t_{\\mathrm{final}}\\right)-y_{\\mathrm{exact}}\\left(t_{\\mathrm{final}}\\right)\\right\\|_2$。随后，你的程序必须输出单行结果，该结果是一个包含四个误差值的、以逗号分隔的 Python 风格列表，其顺序与下方测试用例的顺序一致。\n\n测试用例集规范：\n\n- 测试用例 1 (标量, 线性, 阶数 $k=1$)：\n  - 微分方程：$\\dfrac{dy}{dt}=-y$。\n  - 初始条件：$y(0)=1$ 于 $t_0=0$。\n  - 最终时间：$t_{\\mathrm{final}}=1$。\n  - 步长：$h=0.1$。\n  - 精确解：$y_{\\mathrm{exact}}(t)=e^{-t}$。\n  - 要求计算的误差：$|y(1)-e^{-1}|$。\n\n- 测试用例 2 (标量, 线性, 阶数 $k=2$)：\n  - 微分方程：$\\dfrac{dy}{dt}=-y$。\n  - 初始条件：$y(0)=1$ 于 $t_0=0$。\n  - 最终时间：$t_{\\mathrm{final}}=1$。\n  - 步长：$h=0.1$。\n  - 精确解：$y_{\\mathrm{exact}}(t)=e^{-t}$。\n  - 要求计算的误差：$|y(1)-e^{-1}|$。\n\n- 测试用例 3 (标量, 非线性, 阶数 $k=3$)：\n  - 微分方程：$\\dfrac{dy}{dt}=-y^3$。\n  - 初始条件：$y(0)=1$ 于 $t_0=0$。\n  - 最终时间：$t_{\\mathrm{final}}=1$。\n  - 步长：$h=0.05$。\n  - 精确解：$y_{\\mathrm{exact}}(t)=\\dfrac{1}{\\sqrt{1+2t}}$。\n  - 要求计算的误差：$|y(1)-1/\\sqrt{3}|$。\n\n- 测试用例 4 (向量, 线性旋转, 阶数 $k=4$)：\n  - 微分方程：$\\dfrac{d}{dt}\\begin{bmatrix}u\\\\v\\end{bmatrix}=\\begin{bmatrix}0 & -\\omega\\\\ \\omega & 0\\end{bmatrix}\\begin{bmatrix}u\\\\v\\end{bmatrix}$ 其中 $\\omega=1$。\n  - 初始条件：$\\begin{bmatrix}u(0)\\\\v(0)\\end{bmatrix}=\\begin{bmatrix}1\\\\0\\end{bmatrix}$ 于 $t_0=0$。\n  - 最终时间：$t_{\\mathrm{final}}=\\dfrac{\\pi}{2}$。\n  - 步长：$h=\\dfrac{\\pi}{400}$。\n  - 精确解：$\\begin{bmatrix}u_{\\mathrm{exact}}(t)\\\\v_{\\mathrm{exact}}(t)\\end{bmatrix}=\\begin{bmatrix}\\cos(t)\\\\\\sin(t)\\end{bmatrix}$。\n  - 要求计算的误差：$\\left\\|\\begin{bmatrix}u\\left(\\frac{\\pi}{2}\\right)\\\\v\\left(\\frac{\\pi}{2}\\right)\\end{bmatrix}-\\begin{bmatrix}0\\\\1\\end{bmatrix}\\right\\|_2$。\n\n最终输出格式规范：\n\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序固定为测试用例 $\\left[1,2,3,4\\right]$ 的顺序。例如，一个语法有效的行形如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个浮点数。请勿在该行前后打印任何额外文本。", "solution": "问题陈述已经过严格验证。所有给定信息，包括四个不同测试用例的微分方程、初始条件、积分参数和精确解，都已被提取和核实。其数学和物理前提是合理的。所指定的常微分方程是标准的，且其提供的精确解是正确的。任务是为阶数 $k \\in \\{1,2,3,4\\}$ 实现一个显式 Adams–Bashforth 多步求解器，这在数值分析中是一个明确定义的问题。\n\n问题陈述中对于多步法（其中 $k > 1$）的启动过程存在一个微小的不明确之处。一个 $k$ 步法需要 $k$ 个导数的历史值 $f_{n}, f_{n-1}, \\dots, f_{n-k+1}$，以计算下一步的值 $y_{n+1}$。为了开始积分，前 $k-1$ 个点 $(t_1, y_1), \\dots, (t_{k-1}, y_{k-1})$ 必须由另一种自启动方法生成。问题没有指明使用何种方法。这种省略是此类问题的共同特点，通常期望实现者选择一个标准的、在科学上站得住脚的方法。对于本解答，选择经典的四阶 Runge-Kutta (RK4) 方法用于启动阶段。其单步特性和 $O(h^4)$ 的精度使其成为一个稳健且合适的选择，用以为高达4阶的 Adams–Bashforth 方法生成初始历史值。经过此番澄清，该问题被认为是完整的、一致的且适定的。我们继续进行解答。\n\n求解初值问题 $\\frac{dy}{dt} = f(t,y)$（其中 $y(t_0) = y_0$）的显式 $k$ 步 Adams–Bashforth 方法由以下迭代公式定义：\n$$\ny_{n+1} = y_n + h \\sum_{i=0}^{k-1} b_{k,i} f(t_{n-i}, y_{n-i})\n$$\n其中 $h$ 是恒定步长，$y_n$ 是在时间 $t_n = t_0 + nh$ 时 $y(t_n)$ 的数值近似，且 $f_{n-i} = f(t_{n-i}, y_{n-i})$。对于所需的阶数 $k=1, 2, 3, 4$，其系数 $b_{k,i}$ 如下：\n\n对于 $k=1$（前向欧拉法）：\n$$\ny_{n+1} = y_n + h f_n\n$$\n单个系数为 $b_{1,0} = 1$。\n\n对于 $k=2$：\n$$\ny_{n+1} = y_n + h \\left( \\frac{3}{2} f_n - \\frac{1}{2} f_{n-1} \\right)\n$$\n系数为 $b_{2,0} = \\frac{3}{2}$ 和 $b_{2,1} = -\\frac{1}{2}$。\n\n对于 $k=3$：\n$$\ny_{n+1} = y_n + \\frac{h}{12} \\left( 23 f_n - 16 f_{n-1} + 5 f_{n-2} \\right)\n$$\n系数为 $b_{3,0} = \\frac{23}{12}$，$b_{3,1} = -\\frac{16}{12}$ 和 $b_{3,2} = \\frac{5}{12}$。\n\n对于 $k=4$：\n$$\ny_{n+1} = y_n + \\frac{h}{24} \\left( 55 f_n - 59 f_{n-1} + 37 f_{n-2} - 9 f_{n-3} \\right)\n$$\n系数为 $b_{4,0} = \\frac{55}{24}$，$b_{4,1} = -\\frac{59}{24}$，$b_{4,2} = \\frac{37}{24}$ 和 $b_{4,3} = -\\frac{9}{24}$。\n\n实现将被封装在一个名为 `AdamsBashforthSolver` 的类中。求解器的构造函数 `__init__` 将初始化状态（$t$, $y$）并处理启动过程。对于给定的阶数 $k>1$，它将执行 $k-1$ 步 RK4 方法来计算点 $(y_1, y_2, \\ldots, y_{k-1})$，并填充所需的函数求值历史记录 $[f_{k-1}, f_{k-2}, \\ldots, f_0]$。从 $(t_n, y_n)$ 开始单步计算的 RK4 公式为：\n$$\n\\begin{align*}\nk_1 &= f(t_n, y_n) \\\\\nk_2 &= f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1) \\\\\nk_3 &= f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_2) \\\\\nk_4 &= f(t_n + h, y_n + h k_3) \\\\\ny_{n+1} &= y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\n启动阶段之后，求解器的状态将包括当前时间 $t_{k-1}$、当前解 $y_{k-1}$ 以及导数求值历史 $[f_{k-1}, f_{k-2}, \\ldots, f_0]$。一个 `step` 方法将使用相应的 Adams–Bashforth 公式将解推进一个时间步。这涉及到计算历史 $f$ 值的加权和。一个 `integrate` 方法将协调整个过程，通过重复调用 `step` 方法，直到达到最终积分时间 $t_{\\mathrm{final}}$。\n\n程序将定义四个右端项函数，为每个测试用例设置参数，并为每个用例实例化求解器。程序将调用 `integrate` 方法以获得最终的数值解 $y(t_{\\mathrm{final}})$。之后，将按规定计算误差：对于标量问题，误差为绝对差 $|y(t_{\\mathrm{final}}) - y_{\\mathrm{exact}}(t_{\\mathrm{final}})|$；对于向量问题，误差为欧几里得范数 $\\|y(t_{\\mathrm{final}}) - y_{\\mathrm{exact}}(t_{\\mathrm{final}})\\|_2$。四个用例计算出的误差将被收集起来，并以要求的格式打印。", "answer": "```python\nimport numpy as np\n\nclass AdamsBashforthSolver:\n    \"\"\"\n    A class-based solver for explicit Adams–Bashforth multistep methods.\n    \"\"\"\n    AB_COEFFS = {\n        1: np.array([1.0]),\n        2: np.array([3.0/2.0, -1.0/2.0]),\n        3: np.array([23.0/12.0, -16.0/12.0, 5.0/12.0]),\n        4: np.array([55.0/24.0, -59.0/24.0, 37.0/24.0, -9.0/24.0])\n    }\n\n    def __init__(self, f, y0, t0, h, k):\n        \"\"\"\n        Initializes the Adams-Bashforth solver.\n\n        Args:\n            f (callable): The right-hand side function f(t, y) of the ODE.\n            y0 (float or np.ndarray): The initial condition y(t0).\n            t0 (float): The initial time.\n            h (float): The step size.\n            k (int): The order of the Adams-Bashforth method (1, 2, 3, or 4).\n        \"\"\"\n        if k not in self.AB_COEFFS:\n            raise ValueError(\"Order k must be in {1, 2, 3, 4}\")\n\n        self.f = f\n        self.y0 = np.array(y0, dtype=float)\n        self.t0 = float(t0)\n        self.h = float(h)\n        self.k = int(k)\n        \n        self.coeffs = self.AB_COEFFS[self.k]\n        \n        # Initialize state\n        self.t = self.t0\n        self.y = self.y0\n        \n        # f_history stores [f_n, f_{n-1}, ..., f_{n-k+1}]\n        self.f_history = []\n        \n        # Startup procedure to generate initial history for k>1\n        self._startup()\n\n    def _rk4_step(self, t, y):\n        \"\"\"Performs a single RK4 step.\"\"\"\n        k1 = self.f(t, y)\n        k2 = self.f(t + 0.5 * self.h, y + 0.5 * self.h * k1)\n        k3 = self.f(t + 0.5 * self.h, y + 0.5 * self.h * k2)\n        k4 = self.f(t + self.h, y + self.h * k3)\n        y_next = y + (self.h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n        t_next = t + self.h\n        return t_next, y_next\n\n    def _startup(self):\n        \"\"\"\n        Generates the first k-1 points using RK4 to populate f_history.\n        \"\"\"\n        # First evaluation at (t0, y0)\n        f0 = self.f(self.t0, self.y0)\n        self.f_history.insert(0, f0)\n        \n        # If k > 1, perform k-1 RK4 steps\n        if self.k > 1:\n            for _ in range(self.k - 1):\n                t_next, y_next = self._rk4_step(self.t, self.y)\n                self.t = t_next\n                self.y = y_next\n                f_next = self.f(self.t, self.y)\n                self.f_history.insert(0, f_next)\n\n    def step(self):\n        \"\"\"\n        Advances the solution by one step using the Adams-Bashforth formula.\n        \"\"\"\n        # Ensure f_history has the correct size\n        f_hist_array = np.array(self.f_history)\n        \n        # Calculate the weighted sum for the AB step\n        # For scalar y, f_hist_array is (k,), for vector y it is (k, dim)\n        # We need to dot coeffs with f_hist_array.\n        # np.dot handles this if f_hist_array is (dim, k)\n        if self.y.ndim > 0: # Vector case\n            ab_sum = np.dot(f_hist_array.T, self.coeffs)\n        else: # Scalar case\n            ab_sum = np.dot(self.coeffs, f_hist_array)\n\n        y_next = self.y + self.h * ab_sum\n        t_next = self.t + self.h\n        \n        # Update state\n        self.y = y_next\n        self.t = t_next\n        \n        # Update history\n        f_next = self.f(self.t, self.y)\n        self.f_history.insert(0, f_next)\n        if len(self.f_history) > self.k:\n            self.f_history.pop()\n\n    def integrate(self, t_final):\n        \"\"\"\n        Integrates the ODE from the current time to t_final.\n        \"\"\"\n        num_total_steps = int(round((t_final - self.t0) / self.h))\n        # Startup phase performed k-1 steps.\n        num_ab_steps = num_total_steps - (self.k - 1)\n        \n        for _ in range(num_ab_steps):\n            self.step()\n            \n        return self.y\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # --- Define RHS functions for the test cases ---\n    def f_case12(t, y):\n        # dy/dt = -y\n        return -y\n\n    def f_case3(t, y):\n        # dy/dt = -y^3\n        return -y**3\n\n    def f_case4(t, y):\n        # d/dt [u,v] = [0,-1; 1,0] * [u,v]\n        omega = 1.0\n        A = np.array([[0, -omega], [omega, 0]])\n        return A @ y\n\n    # --- Test suite specification ---\n    test_cases = [\n        # Case 1\n        {\n            'f': f_case12, 'y0': 1.0, 't0': 0.0, 't_final': 1.0, 'h': 0.1, 'k': 1,\n            'y_exact_final': np.exp(-1.0)\n        },\n        # Case 2\n        {\n            'f': f_case12, 'y0': 1.0, 't0': 0.0, 't_final': 1.0, 'h': 0.1, 'k': 2,\n            'y_exact_final': np.exp(-1.0)\n        },\n        # Case 3\n        {\n            'f': f_case3, 'y0': 1.0, 't0': 0.0, 't_final': 1.0, 'h': 0.05, 'k': 3,\n            'y_exact_final': 1.0 / np.sqrt(3.0)\n        },\n        # Case 4\n        {\n            'f': f_case4, 'y0': np.array([1.0, 0.0]), 't0': 0.0, 't_final': np.pi / 2.0, \n            'h': np.pi / 400.0, 'k': 4,\n            'y_exact_final': np.array([0.0, 1.0])\n        }\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        solver = AdamsBashforthSolver(\n            f=case['f'],\n            y0=case['y0'],\n            t0=case['t0'],\n            h=case['h'],\n            k=case['k']\n        )\n        \n        y_final = solver.integrate(case['t_final'])\n        \n        y_exact = case['y_exact_final']\n        \n        if i == 3: # Vector case\n            error = np.linalg.norm(y_final - y_exact)\n        else: # Scalar cases\n            error = np.abs(y_final - y_exact)\n            \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2371225"}, {"introduction": "现在，我们将运用所学技能挑战一个计算物理学中的经典问题：洛伦兹系统。这个练习要求你使用四阶 Adams–Bashforth 方法模拟这个著名的混沌系统，并探索计算中的一个核心挑战——有限精度算术的影响。通过对比单精度（32位）和双精度（64位）浮点数下的仿真结果，你将亲眼见证“蝴蝶效应”，理解数值误差在混沌系统长期预测中的放大效应及其深刻含义。[@problem_id:2371228]", "problem": "考虑三维 Lorenz 系统，它由自治常微分方程 $\\frac{d\\mathbf{y}}{dt}=\\mathbf{f}(\\mathbf{y})$ 定义，其状态为 $\\mathbf{y}(t)=[x(t),y(t),z(t)]^\\top$，矢量场为\n$$\n\\mathbf{f}(\\mathbf{y})=\n\\begin{bmatrix}\n\\sigma\\,(y-x)\\\\\nx\\,(\\rho-z)-y\\\\\nx\\,y-\\beta\\,z\n\\end{bmatrix},\n$$\n其中参数为 $\\sigma=10$，$\\rho=28$ 和 $\\beta=8/3$，初始条件为 $\\mathbf{y}(0)=[1,1,1]^\\top$。时间是无量纲的。\n\n您必须使用固定的步长 $h>0$，通过显式四阶四步 Adams–Bashforth 方法（AB4）对该系统进行积分。AB4 的递推关系式为\n$$\n\\mathbf{y}_{n+1}=\\mathbf{y}_n+h\\left(\\frac{55}{24}\\mathbf{f}_n-\\frac{59}{24}\\mathbf{f}_{n-1}+\\frac{37}{24}\\mathbf{f}_{n-2}-\\frac{9}{24}\\mathbf{f}_{n-3}\\right),\n$$\n其中 $\\mathbf{f}_k=\\mathbf{f}(\\mathbf{y}_k)$ 且 $\\mathbf{y}_k\\approx \\mathbf{y}(t_k)$，而 $t_k=t_0+k\\,h$ 且 $t_0=0$。为获得前三步 $\\mathbf{y}_1$、$\\mathbf{y}_2$ 和 $\\mathbf{y}_3$，请使用同样固定步长 $h$ 的经典四阶 Runge–Kutta (RK4) 单步法，其在自治情况下的定义为\n$$\n\\begin{aligned}\n\\mathbf{k}_1&=\\mathbf{f}(\\mathbf{y}_n),\\\\\n\\mathbf{k}_2&=\\mathbf{f}\\left(\\mathbf{y}_n+\\frac{h}{2}\\mathbf{k}_1\\right),\\\\\n\\mathbf{k}_3&=\\mathbf{f}\\left(\\mathbf{y}_n+\\frac{h}{2}\\mathbf{k}_2\\right),\\\\\n\\mathbf{k}_4&=\\mathbf{f}\\left(\\mathbf{y}_n+h\\,\\mathbf{k}_3\\right),\\\\\n\\mathbf{y}_{n+1}&=\\mathbf{y}_n+\\frac{h}{6}\\left(\\mathbf{k}_1+2\\,\\mathbf{k}_2+2\\,\\mathbf{k}_3+\\mathbf{k}_4\\right).\n\\end{aligned}\n$$\n\n定义两个数值解，它们使用相同的 AB4 格式、相同的初始条件和相同的固定步长 $h$ 计算，但采用不同的浮点数算法：\n- 一个双精度解 $\\mathbf{y}^{(64)}(t)$，完全在 IEEE $64$ 位二进制浮点数算法（通常称为双精度）下计算。\n- 一个单精度解 $\\mathbf{y}^{(32)}(t)$，完全在 IEEE $32$ 位二进制浮点数算法（通常称为单精度）下计算。\n\n对于单精度计算，RK4 启动和 AB4 递推中的每一次算术运算和存储量都必须以 $32$ 位精度执行和存储；特别是，在每个完整步骤之后，状态向量必须四舍五入到最接近的可表示的 $32$ 位浮点数。\n\n对于给定的总积分时间 $T>0$，将分离时间 $\\tau_\\epsilon$ 定义为两个数值解之差的欧几里得范数首次超过指定阈值 $\\epsilon>0$ 的最早离散时间 $t_k=k\\,h$：\n$$\n\\tau_\\epsilon=\\min\\{t_k:\\ \\|\\mathbf{y}^{(64)}_k-\\mathbf{y}^{(32)}_k\\|_2>\\epsilon\\},\n$$\n约定如果在 $0\\le k\\le N$（其中 $N=T/h$ 为整数）内没有出现这样的 $t_k$，则 $\\tau_\\epsilon=T$。\n\n实现上述过程，并为以下每个测试用例计算 $\\tau_\\epsilon$。在每种情况下，均使用上面给出的相同的 Lorenz 参数和初始条件，并假设 $T/h$ 是一个整数。\n\n- 测试用例 1：$h=10^{-3}$，$T=20$，$\\epsilon=10^{-2}$。\n- 测试用例 2：$h=5\\times 10^{-4}$，$T=30$，$\\epsilon=10^{-2}$。\n- 测试用例 3：$h=2\\times 10^{-3}$，$T=20$，$\\epsilon=10^{-3}$。\n- 测试用例 4：$h=10^{-3}$，$T=2$，$\\epsilon=1$。\n\n您的程序应生成单行输出，其中包含结果。结果是一个逗号分隔的十进制数列表，保留小数点后六位，按测试用例的相同顺序用方括号括起来（例如，形式为 $\\texttt{[0.123456,0.234567,0.345678,0.456789]}$ 的一行）。时间是无量纲的，因此输出中不需要物理单位。", "solution": "所提出的问题是一项有效的计算物理练习。它具有科学依据、提法明确且客观。它要求对 Lorenz 系统（一种确定性混沌的经典模型）进行数值积分，以研究其对浮点精度的敏感性。这是数值分析和动力系统研究中的一个基本课题。所有参数、方法和评估标准都定义得足够清晰和严谨，能够得到唯一且可验证的解。\n\n目标是确定“分离时间” $\\tau_\\epsilon$，即用不同浮点精度计算的两个 Lorenz 系统数值解，其差异达到指定量 $\\epsilon$ 所需的时间。一个解 $\\mathbf{y}^{(64)}$ 使用标准的 $64$ 位双精度算法计算，作为高精度参考。另一个解 $\\mathbf{y}^{(32)}$ 使用 $32$ 位单精度算法计算，所有常数、变量和中间结果都限制在此较低精度下。这种设置旨在展示微小舍入误差的指数级放大，这是混沌系统的一个标志，即著名的蝴蝶效应。\n\n要积分的系统是 Lorenz 系统，由一阶自治常微分方程 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 给出，其中 $\\mathbf{y}(t) = [x(t), y(t), z(t)]^\\top$，矢量场 $\\mathbf{f}$ 定义为：\n$$\n\\mathbf{f}(\\mathbf{y}) =\n\\begin{bmatrix}\n\\sigma(y-x) \\\\\nx(\\rho-z) - y \\\\\nxy - \\beta z\n\\end{bmatrix}\n$$\n参数固定在经典的混沌值：$\\sigma=10$, $\\rho=28$, $\\beta=8/3$。积分从初始条件 $\\mathbf{y}(0) = [1, 1, 1]^\\top$ 开始。\n\n数值积分格式为显式四阶 Adams-Bashforth (AB4) 方法。作为一个多步法，它不是自启动的。它需要四个先前函数求值的历史记录 $\\mathbf{f}_n, \\mathbf{f}_{n-1}, \\mathbf{f}_{n-2}, \\mathbf{f}_{n-3}$，以从当前状态 $\\mathbf{y}_n$ 计算下一个状态 $\\mathbf{y}_{n+1}$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{24}(55\\mathbf{f}_n - 59\\mathbf{f}_{n-1} + 37\\mathbf{f}_{n-2} - 9\\mathbf{f}_{n-3})\n$$\n此处，$h$ 是固定时间步长，$\\mathbf{y}_k \\approx \\mathbf{y}(kh)$，且 $\\mathbf{f}_k = \\mathbf{f}(\\mathbf{y}_k)$。为了生成所需的历史记录，积分的前三步（从 $\\mathbf{y}_0$ 求 $\\mathbf{y}_1, \\mathbf{y}_2, \\mathbf{y}_3$）使用经典的四阶 Runge-Kutta (RK4) 方法执行。RK4 是一种单步法，其用于自治系统的公式为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{f}(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 &= \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1\\right) \\\\\n\\mathbf{k}_3 &= \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_2\\right) \\\\\n\\mathbf{k}_4 &= \\mathbf{f}\\left(\\mathbf{y}_n + h\\mathbf{k}_3\\right) \\\\\n\\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n每个测试用例的程序实现如下：\n1. 初始化两个并行模拟，一个采用 $64$ 位精度（`numpy.float64`），另一个采用 $32$ 位精度（`numpy.float32`）。所有系统参数、初始条件、积分常数和状态向量都相应地设置类型。\n2. 对于 $k=0, 1, 2$，分别使用 RK4 方法从 $\\mathbf{y}_k^{(64)}$ 和 $\\mathbf{y}_k^{(32)}$ 计算状态 $\\mathbf{y}_{k+1}^{(64)}$ 和 $\\mathbf{y}_{k+1}^{(32)}$。函数求值 $\\mathbf{f}_k^{(64)}$ 和 $\\mathbf{f}_k^{(32)}$ 被存储下来。\n3. 对于所有后续步骤 $k \\ge 3$ 直至总步数 $N = T/h$，使用 AB4 方法计算状态 $\\mathbf{y}_{k+1}^{(64)}$ 和 $\\mathbf{y}_{k+1}^{(32)}$，该方法利用各自历史记录中存储的四个最新函数求值。\n4. 在每个步骤 $k$ 之后，计算状态之间差异的欧几里得范数 $\\|\\mathbf{y}_{k+1}^{(64)} - \\mathbf{y}_{k+1}^{(32)}\\|_2$。为了进行此比较，将 $32$ 位向量强制转换为 $64$ 位精度，以确保比较本身不会成为误差源。\n5. 分离时间 $\\tau_\\epsilon$ 是该范数首次超过阈值 $\\epsilon$ 的时间 $t_{k+1} = (k+1)h$。如果到最终时间 $T$ 仍未超过阈值，则 $\\tau_\\epsilon = T$。\n\n这个严谨的程序能够直接测量混沌系统中由有限精度算法引起的轨迹发散。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-3, 20.0, 1e-2),    # Test case 1\n        (5e-4, 30.0, 1e-2),    # Test case 2\n        (2e-3, 20.0, 1e-3),    # Test case 3\n        (1e-3, 2.0, 1.0),      # Test case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        h, T, epsilon = case\n        tau_epsilon = compute_separation_time(h, T, epsilon)\n        results.append(tau_epsilon)\n\n    # Format results to six decimal places for the final output.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_separation_time(h, T, epsilon):\n    \"\"\"\n    Computes the separation time for a given set of parameters.\n\n    Args:\n        h (float): The step size.\n        T (float): The total integration time.\n        epsilon (float): The separation threshold.\n\n    Returns:\n        float: The separation time tau_epsilon.\n    \"\"\"\n    # --- Setup for 64-bit (double precision) simulation ---\n    dtype64 = np.float64\n    y64 = np.array([1.0, 1.0, 1.0], dtype=dtype64)\n    sigma64, rho64, beta64 = dtype64(10.0), dtype64(28.0), dtype64(8.0/3.0)\n    h64 = dtype64(h)\n    ab_coeffs64 = np.array([55.0/24.0, -59.0/24.0, 37.0/24.0, -9.0/24.0], dtype=dtype64)\n    f_hist64 = deque(maxlen=4)\n\n    # --- Setup for 32-bit (single precision) simulation ---\n    dtype32 = np.float32\n    y32 = np.array([1.0, 1.0, 1.0], dtype=dtype32)\n    sigma32, rho32, beta32 = dtype32(10.0), dtype32(28.0), dtype32(8.0/3.0)\n    h32 = dtype32(h)\n    ab_coeffs32 = np.array([55.0/24.0, -59.0/24.0, 37.0/24.0, -9.0/24.0], dtype=dtype32)\n    f_hist32 = deque(maxlen=4)\n    \n    # --- Lorenz vector field function, typed for precision ---\n    def lorenz_f(y_vec, sigma, rho, beta, dtype):\n        x, y_comp, z = y_vec\n        dxdt = sigma * (y_comp - x)\n        dydt = x * (rho - z) - y_comp\n        dzdt = x * y_comp - beta * z\n        return np.array([dxdt, dydt, dzdt], dtype=dtype)\n\n    num_steps = int(round(T / h))\n\n    for k in range(num_steps):\n        # I. Evaluate f at the current step for both precisions\n        fk_64 = lorenz_f(y64, sigma64, rho64, beta64, dtype64)\n        f_hist64.append(fk_64)\n\n        fk_32 = lorenz_f(y32, sigma32, rho32, beta32, dtype32)\n        f_hist32.append(fk_32)\n\n        # II. Step forward using RK4 (startup) or AB4 (main)\n        if k  3:\n            # RK4 step for 64-bit\n            k1_64 = fk_64\n            k2_64 = lorenz_f(y64 + h64/dtype64(2.0) * k1_64, sigma64, rho64, beta64, dtype64)\n            k3_64 = lorenz_f(y64 + h64/dtype64(2.0) * k2_64, sigma64, rho64, beta64, dtype64)\n            k4_64 = lorenz_f(y64 + h64 * k3_64, sigma64, rho64, beta64, dtype64)\n            y64_next = y64 + h64/dtype64(6.0) * (k1_64 + dtype64(2.0)*k2_64 + dtype64(2.0)*k3_64 + k4_64)\n\n            # RK4 step for 32-bit\n            k1_32 = fk_32\n            k2_32 = lorenz_f(y32 + h32/dtype32(2.0) * k1_32, sigma32, rho32, beta32, dtype32)\n            k3_32 = lorenz_f(y32 + h32/dtype32(2.0) * k2_32, sigma32, rho32, beta32, dtype32)\n            k4_32 = lorenz_f(y32 + h32 * k3_32, sigma32, rho32, beta32, dtype32)\n            y32_next = y32 + h32/dtype32(6.0) * (k1_32 + dtype32(2.0)*k2_32 + dtype32(2.0)*k3_32 + k4_32)\n        else:\n            # AB4 step for 64-bit (f_hist has f_n, f_{n-1}, f_{n-2}, f_{n-3})\n            term64 = (ab_coeffs64[0] * f_hist64[3] +\n                      ab_coeffs64[1] * f_hist64[2] +\n                      ab_coeffs64[2] * f_hist64[1] +\n                      ab_coeffs64[3] * f_hist64[0])\n            y64_next = y64 + h64 * term64\n            \n            # AB4 step for 32-bit\n            term32 = (ab_coeffs32[0] * f_hist32[3] +\n                      ab_coeffs32[1] * f_hist32[2] +\n                      ab_coeffs32[2] * f_hist32[1] +\n                      ab_coeffs32[3] * f_hist32[0])\n            y32_next = y32 + h32 * term32\n\n        # III. Update state vectors\n        y64 = y64_next\n        y32 = y32_next\n\n        # IV. Check for separation\n        diff_norm = np.linalg.norm(y64 - y32.astype(dtype64))\n        if diff_norm > epsilon:\n            return (k + 1) * h\n\n    return T\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2371228"}]}