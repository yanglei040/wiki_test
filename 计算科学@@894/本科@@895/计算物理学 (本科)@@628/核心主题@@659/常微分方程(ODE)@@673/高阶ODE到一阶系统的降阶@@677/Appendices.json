{"hands_on_practices": [{"introduction": "在深入研究具体的物理模型之前，掌握将高阶常微分方程（ODE）转化为一阶系统的核心数学方法至关重要。本练习旨在将这一转换过程抽象成一个通用的、可复用的计算函数。通过完成此任务，您将能够巩固该核心算法，为将其应用于各种复杂的物理问题打下坚实的基础。[@problem_id:2433640]", "problem": "你的任务是编写一个完整的程序，该程序从一个显式高阶常微分方程(ODE)构造一个数值一阶系统，并在一个指定的测试套件上评估其正确性。常微分方程(ODE)是一种包含未知函数及其关于单个自变量的导数的关系。在本任务中，该ODE以显式$n$阶形式给出\n$$\ny^{(n)}(t) \\;=\\; G\\!\\big(t,\\,y(t),\\,y^{(1)}(t),\\,\\dots,\\,y^{(n-1)}(t)\\big),\n$$\n其中 $n \\in \\mathbb{N}$，$t \\in \\mathbb{R}$ 是时间，$G$ 是一个已知函数。你的程序必须实现一个函数，在给定整数 $n \\geq 1$ 和函数 $G$ 的情况下，返回等价一阶系统的数值右端项。使用这个函数来计算所提供测试套件的输出。所有角度必须以弧度为单位。输出中不涉及物理单位；按要求报告无量纲的量。\n\n所需构造函数的定义：\n- 输入：一个整数 $n \\geq 1$ 和一个可调用对象 $G$，该对象接受恰好 $n+1$ 个实数参数 $(t,x_0,\\dots,x_{n-1})$，对应于n阶ODE $y^{(n)}(t)=G(t,y(t),\\dots,y^{(n-1)}(t))$ 中的显式右端项。\n- 输出：一个可调用对象 $F$，它将 $(t,X)$ 映射到 $\\mathbb{R}^n$ 中的一个向量，其中 $X=(x_0,\\dots,x_{n-1})$ 代表 $(y(t),y^{(1)}(t),\\dots,y^{(n-1)}(t))$，且\n$$\nF(t,X) \\;=\\; \\big(x_1,\\;x_2,\\;\\dots,\\;x_{n-1},\\;G(t,x_0,\\dots,x_{n-1})\\big).\n$$\n\n测试套件规范：\n对于每个测试用例，设 $T>0$ 为最终时间，$\\{t_j\\}_{j=0}^{200}$ 是在 $[0,T]$ 上的201个均匀间隔点。对于每个用例，你必须：\n- 使用给定的初始状态 $X(0)=(y(0),y^{(1)}(0),\\dots,y^{(n-1)}(0))$，将相应的一阶系统从 $t=0$ 数值演化到 $t=T$。\n- 计算主变量 $y(t)$ 在网格 $\\{t_j\\}$ 上的最大绝对误差，即\n$$\nE \\;=\\; \\max_{0 \\le j \\le 200}\\,\\big|\\,y_{\\text{num}}(t_j) - y_{\\text{exact}}(t_j)\\,\\big|.\n$$\n- 将三个得出的误差报告为四舍五入到6位小数的浮点数。\n\n所有三角函数的参数都以弧度为单位。\n\n测试用例：\n- 用例1 (二阶线性振子)：$n=2$，参数 $\\omega=2.0$。方程为\n$$\ny^{(2)}(t) + \\omega^2\\,y(t) \\;=\\; 0,\n$$\n即\n$$\ny^{(2)}(t) \\;=\\; -\\omega^2\\,y(t).\n$$\n初始条件：$y(0)=1.0$, $y^{(1)}(0)=0.0$。最终时间：$T=3.0$。精确解：\n$$\ny_{\\text{exact}}(t) \\;=\\; \\cos\\!\\big(\\omega\\,t\\big).\n$$\n\n- 用例2 (三阶标量方程)：$n=3$。方程为\n$$\ny^{(3)}(t) \\;=\\; -\\,y(t).\n$$\n初始条件：$y(0)=0.0$, $y^{(1)}(0)=1.0$, $y^{(2)}(0)=0.0$。最终时间：$T=1.0$。精确解是具有这些初始数据的齐次线性ODE的唯一解。你必须使用从特征方程 $r^3+1=0$ 推导出的闭式精确表达式来计算 $y_{\\text{exact}}(t)$ 以进行误差计算。\n\n- 用例3 (四阶多项式动力学)：$n=4$。方程为\n$$\ny^{(4)}(t) \\;=\\; 0.\n$$\n初始条件：$y(0)=1.0$, $y^{(1)}(0)=2.0$, $y^{(2)}(0)=3.0$, $y^{(3)}(0)=4.0$。最终时间：$T=2.0$。精确解是与这些在 $t=0$ 处的初始导数一致的唯一三次多项式。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含三个四舍五入的误差，以逗号分隔的列表形式，并用方括号括起来，顺序为用例1、2、3。例如，一个有效的输出行如下所示\n\"[0.000123,0.000456,0.000789]\".\n\n你的程序必须是自包含的，并且不得需要任何用户输入或外部文件。角度必须以弧度为单位，所有输出均为四舍五入到6位小数的无量纲数。", "solution": "问题陈述是有效的。它提出了一个计算数学中的良定任务，特别是高阶常微分方程(ODE)的数值解法。所指定的方法论——降阶为一阶系统——是一种标准且基础的技术。该问题具有科学依据、客观，并提供了进行求解所需的所有必要信息。测试用例是来自物理学和数学的经典示例，其精确解是已知的，从而可以对数值方法的准确性进行定量评估。\n\n核心原理是将一个显式n阶ODE\n$$\ny^{(n)}(t) = G\\big(t, y(t), y^{(1)}(t), \\dots, y^{(n-1)}(t)\\big)\n$$\n变换为一个等价的n个一阶ODE组成的系统。这是通过定义一个状态向量 $X(t) \\in \\mathbb{R}^n$ 来实现的：\n$$\nX(t) = \\begin{pmatrix} x_0(t) \\\\ x_1(t) \\\\ \\vdots \\\\ x_{n-1}(t) \\end{pmatrix} = \\begin{pmatrix} y(t) \\\\ y^{(1)}(t) \\\\ \\vdots \\\\ y^{(n-1)}(t) \\end{pmatrix}\n$$\n这个状态向量的时间演化由一个一阶系统 $\\frac{d}{dt}X(t) = F(t, X(t))$ 控制，其中函数 $F: \\mathbb{R} \\times \\mathbb{R}^n \\to \\mathbb{R}^n$ 定义为：\n$$\n\\frac{d}{dt} \\begin{pmatrix} x_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-2} \\\\ x_{n-1} \\end{pmatrix} = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_{n-1} \\\\ G(t, x_0, x_1, \\dots, x_{n-1}) \\end{pmatrix}\n$$\n这个结构直接来自于状态变量的定义，其中对于 $k = 0, \\dots, n-2$，有 $\\frac{d}{dt}x_k = \\frac{d}{dt}y^{(k)} = y^{(k+1)} = x_{k+1}$，而最后一个分量由原始ODE给出：$\\frac{d}{dt}x_{n-1} = \\frac{d}{dt}y^{(n-1)} = y^{(n)} = G(t, y, y', \\dots, y^{(n-1)})$。\n\n解决方案将按以下方式实现：\n1. 创建一个问题中指定的构造函数。该函数将接受阶数 $n$ 和右端函数 $G$，并返回系统函数 $F(t, X)$。\n2. 对于每个测试用例，将定义相应的参数（$n$、$G$、初始条件 $X(0)$、最终时间 $T$）和精确解析解 $y_{\\text{exact}}(t)$。\n3. 将使用 `scipy.integrate` 库中的 `solve_ivp` 函数获得数值解，这是一个适用于此类初值问题的鲁棒自适应求解器。将在区间 $[0, T]$ 内的201个均匀间隔的时间点 $t_j$ 上计算积分。\n4. 计算最大绝对误差 $E = \\max_{j} |y_{\\text{num}}(t_j) - y_{\\text{exact}}(t_j)|$，其中 $y_{\\text{num}}(t_j)$ 是状态向量在时间 $t_j$ 的第一个分量。\n5. 将收集所有三个用例的误差，并以指定格式报告。\n\n每个测试用例的详细信息如下：\n\n用例1：二阶线性振子\nODE 为 $y^{(2)}(t) + \\omega^2 y(t) = 0$，其中 $\\omega = 2.0$。这等价于 $y^{(2)}(t) = -4y(t)$。\n阶数为 $n=2$。状态向量为 $X = (y, y') = (x_0, x_1)$。\n函数 $G$ 为 $G(t, x_0, x_1) = -4x_0$。\n系统为 $\\frac{d}{dt}(x_0, x_1) = (x_1, -4x_0)$。\n初始条件为 $X(0) = (y(0), y'(0)) = (1.0, 0.0)$。\n积分区间为 $[0, 3.0]$。\n精确解为 $y_{\\text{exact}}(t) = \\cos(2t)$。\n\n用例2：三阶标量方程\nODE为 $y^{(3)}(t) = -y(t)$。\n阶数为 $n=3$。状态向量为 $X = (y, y', y'') = (x_0, x_1, x_2)$。\n函数 $G$ 为 $G(t, x_0, x_1, x_2) = -x_0$。\n系统为 $\\frac{d}{dt}(x_0, x_1, x_2) = (x_1, x_2, -x_0)$。\n初始条件为 $X(0) = (y(0), y'(0), y''(0)) = (0.0, 1.0, 0.0)$。\n积分区间为 $[0, 1.0]$。\n为了找到精确解，我们求解特征方程 $r^3 + 1 = 0$。根为 $r_1 = -1$，$r_2 = \\frac{1}{2} + i\\frac{\\sqrt{3}}{2}$ 和 $r_3 = \\frac{1}{2} - i\\frac{\\sqrt{3}}{2}$。通解为 $y(t) = C_1 e^{-t} + e^{t/2}(C_2 \\cos(\\frac{\\sqrt{3}}{2}t) + C_3 \\sin(\\frac{\\sqrt{3}}{2}t))$。应用初始条件可得到常数 $C_1 = -1/3$，$C_2 = 1/3$ 和 $C_3 = \\sqrt{3}/3$。\n因此，精确解为 $y_{\\text{exact}}(t) = -\\frac{1}{3}e^{-t} + \\frac{1}{3}e^{t/2}\\cos(\\frac{\\sqrt{3}}{2}t) + \\frac{\\sqrt{3}}{3}e^{t/2}\\sin(\\frac{\\sqrt{3}}{2}t)$。\n\n用例3：四阶多项式动力学\nODE为 $y^{(4)}(t) = 0$。\n阶数为 $n=4$。状态向量为 $X = (y, y', y'', y''') = (x_0, x_1, x_2, x_3)$。\n函数 $G$ 为 $G(t, x_0, x_1, x_2, x_3) = 0$。\n系统为 $\\frac{d}{dt}(x_0, x_1, x_2, x_3) = (x_1, x_2, x_3, 0)$。\n初始条件为 $X(0) = (y(0), y'(0), y''(0), y'''(0)) = (1.0, 2.0, 3.0, 4.0)$。\n积分区间为 $[0, 2.0]$。\n精确解可通过对 $y^{(4)}(t)=0$ 积分四次得到。这给出一个三次多项式 $y(t) = at^3 + bt^2 + ct + d$。系数由初始条件确定：$y(t) = \\frac{y'''(0)}{6}t^3 + \\frac{y''(0)}{2}t^2 + y'(0)t + y(0)$。\n代入给定值：$a = 4/6 = 2/3$，$b = 3/2 = 1.5$，$c = 2$，$d = 1$。\n精确解为 $y_{\\text{exact}}(t) = \\frac{2}{3}t^3 + \\frac{3}{2}t^2 + 2t + 1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution of the three test cases.\n    \"\"\"\n\n    def construct_first_order_system(n, G):\n        \"\"\"\n        Constructs the right-hand side function for the equivalent first-order system.\n\n        Args:\n            n (int): The order of the ODE.\n            G (callable): The function G(t, y, y', ..., y^(n-1)).\n\n        Returns:\n            callable: A function F(t, X) for the first-order system dX/dt = F(t, X).\n        \"\"\"\n        def F(t, X):\n            if not isinstance(X, np.ndarray):\n                X = np.array(X)\n            \n            derivatives = np.zeros(n)\n            # dx_i/dt = x_{i+1} for i = 0 to n-2\n            if n > 1:\n                derivatives[:n-1] = X[1:]\n            # dx_{n-1}/dt = G(t, x_0, ..., x_{n-1})\n            derivatives[n-1] = G(t, *X)\n            return derivatives\n        return F\n\n    def run_test_case(n, G, X0, T, y_exact_func):\n        \"\"\"\n        Runs a single test case: solves the ODE and computes the error.\n\n        Args:\n            n (int): Order of the ODE.\n            G (callable): The right-hand side function of the n-th order ODE.\n            X0 (list or np.ndarray): Initial conditions [y(0), y'(0), ...].\n            T (float): Final time.\n            y_exact_func (callable): Function for the exact solution y_exact(t).\n\n        Returns:\n            float: Maximum absolute error over the time grid.\n        \"\"\"\n        # Construct the first-order system\n        F = construct_first_order_system(n, G)\n\n        # Define time grid\n        t_span = (0, T)\n        t_eval = np.linspace(0, T, 201)\n\n        # Solve the IVP\n        sol = solve_ivp(F, t_span, X0, t_eval=t_eval, rtol=1e-8, atol=1e-10)\n\n        # Extract numerical solution for y(t)\n        y_num = sol.y[0]\n\n        # Compute exact solution at grid points\n        y_exact = y_exact_func(t_eval)\n        \n        # Compute maximum absolute error\n        error = np.max(np.abs(y_num - y_exact))\n        \n        return error\n\n    # Test Case 1: Second-order linear oscillator\n    w1 = 2.0\n    case1_params = {\n        \"n\": 2,\n        \"G\": lambda t, y, y_prime: -w1**2 * y,\n        \"X0\": [1.0, 0.0],\n        \"T\": 3.0,\n        \"y_exact_func\": lambda t: np.cos(w1 * t)\n    }\n\n    # Test Case 2: Third-order scalar equation\n    def y_exact_case2(t):\n        C1 = -1.0/3.0\n        C2 = 1.0/3.0\n        C3 = np.sqrt(3.0)/3.0\n        omega = np.sqrt(3.0)/2.0\n        return (C1 * np.exp(-t) + \n                np.exp(t/2.0) * (C2 * np.cos(omega * t) + C3 * np.sin(omega * t)))\n\n    case2_params = {\n        \"n\": 3,\n        \"G\": lambda t, y, y1, y2: -y,\n        \"X0\": [0.0, 1.0, 0.0],\n        \"T\": 1.0,\n        \"y_exact_func\": y_exact_case2\n    }\n\n    # Test Case 3: Fourth-order polynomial dynamics\n    y0, y1, y2, y3 = 1.0, 2.0, 3.0, 4.0\n    case3_params = {\n        \"n\": 4,\n        \"G\": lambda t, y, y_1, y_2, y_3: 0.0,\n        \"X0\": [y0, y1, y2, y3],\n        \"T\": 2.0,\n        \"y_exact_func\": lambda t: (y3/6.0)*t**3 + (y2/2.0)*t**2 + y1*t + y0\n    }\n    \n    test_cases = [case1_params, case2_params, case3_params]\n    \n    results = []\n    for params in test_cases:\n        error = run_test_case(\n            params[\"n\"],\n            params[\"G\"],\n            params[\"X0\"],\n            params[\"T\"],\n            params[\"y_exact_func\"]\n        )\n        results.append(error)\n\n    # Format output to 6 decimal places as strings and join them\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2433640"}, {"introduction": "物理学中的许多高阶常微分方程源于基本的物理原理。本练习将引导您体验一个完整的建模流程：从费马原理（Fermat's principle）出发，利用变分法推导出描述光线路径的二阶常微分方程，然后运用我们学到的转化方法对其进行数值求解。这个实践将抽象的数学技巧与真实的物理建模过程紧密地联系在一起，展示了如何从第一性原理出发解决计算问题。[@problem_id:2433582]", "problem": "一束单色光线在笛卡尔坐标平面中传播。根据费马原理，光程泛函由积分 $S = \\int n(y)\\,ds$ 给出，其中 $ds = \\sqrt{dx^2 + dy^2}$，$n(y)$ 是仅取决于横向坐标 $y$ 的折射率。将光线路径参数化为 $y(x)$，其定义域为区间 $x \\in [0,L]$。初始位置和方向为 $y(0) = y_0$ 及与 $x$ 轴正方向的初始夹角 $\\theta_0$，这意味着 $y'(0) = \\tan(\\theta_0)$。距离单位必须为米，角度单位必须为弧度。\n\n从泛函 $S = \\int n(y)\\sqrt{1+y'(x)^2}\\,dx$ 出发，依据第一性原理推导出 $y(x)$ 的控制常微分方程，并将其简化为一个适合数值求解的一阶系统，状态变量为 $y(x)$ 和 $v(x) = y'(x)$。对于下方的每个测试用例，计算在 $x=L$ 处的横向位置 $y(L)$（单位为米）和出射角 $\\theta(L)$（单位为弧度）。\n\n测试套件（每个测试用例指定一个折射率剖面 $n(y)$、其参数以及初始和终端条件）：\n\n- 测试用例 A（基准，均匀介质）：\n  - $n(y) = n_0$，其中 $n_0 = 1.5$。\n  - $y_0 = 0.0\\,\\mathrm{m}$，$\\theta_0 = 0.1\\,\\mathrm{rad}$，$L = 0.2\\,\\mathrm{m}$。\n\n- 测试用例 B（线性渐变折射率）：\n  - $n(y) = n_0 + a\\,y$，其中 $n_0 = 1.0$，$a = 0.5\\,\\mathrm{m}^{-1}$。\n  - $y_0 = 0.0\\,\\mathrm{m}$，$\\theta_0 = 0.2\\,\\mathrm{rad}$，$L = 0.5\\,\\mathrm{m}$。\n\n- 测试用例 C（抛物线渐变折射率，小曲率）：\n  - $n(y) = n_0\\left(1 - \\dfrac{1}{2}(g\\,y)^2\\right)$，其中 $n_0 = 1.6$，$g = 3.0\\,\\mathrm{m}^{-1}$。\n  - $y_0 = 0.01\\,\\mathrm{m}$，$\\theta_0 = -0.15\\,\\mathrm{rad}$，$L = 0.3\\,\\mathrm{m}$。\n\n- 测试用例 D（传播长度为零的边界条件）：\n  - $n(y) = n_0 + a\\,y$，其中 $n_0 = 1.2$，$a = 1.0\\,\\mathrm{m}^{-1}$。\n  - $y_0 = 0.02\\,\\mathrm{m}$，$\\theta_0 = 0.3\\,\\mathrm{rad}$，$L = 0.0\\,\\mathrm{m}$。\n\n您的程序必须将所有测试用例的结果输出到单行中，格式为一个包含在方括号内的逗号分隔列表。每个测试用例的结果本身必须是一个双元素列表 $[y(L), \\theta(L)]$，两个值都四舍五入到六位小数。因此，最终输出格式必须为\n$[[y_A(L), \\theta_A(L)],[y_B(L), \\theta_B(L)],[y_C(L), \\theta_C(L)],[y_D(L), \\theta_D(L)]]$\n，无任何附加文本。", "solution": "该问题陈述在科学上是合理的、适定的和客观的。它基于光学的基本费马原理和用于推导运动方程的变分法标准数学框架。每个测试用例所需的所有参数和条件都已提供。该问题是计算物理学中与高阶常微分方程（ODE）降阶相关的标准练习。因此，该问题是有效的，并将提供解答。\n\n目标是确定光线 $y(x)$ 在折射率 $n(y)$ 可变的介质中的轨迹。根据费马原理，光线遵循的路径会使光程取极值，光程由泛函 $S$ 给出：\n$$\nS[y] = \\int n(y) \\, ds\n$$\n其中 $ds = \\sqrt{dx^2 + dy^2}$ 是无穷小弧长。将路径参数化为 $y(x)$，我们可以写作 $ds = \\sqrt{1 + (y'(x))^2} \\, dx$，其中 $y'(x) = dy/dx$。泛函变为：\n$$\nS[y] = \\int_{0}^{L} n(y(x)) \\sqrt{1 + (y'(x))^2} \\, dx\n$$\n这是一个经典的变分法问题。被积函数 $F(y, y') = n(y)\\sqrt{1 + (y')^2}$ 是该系统的拉格朗日量。使该积分取极值的路径 $y(x)$ 必须满足欧拉-拉格朗日方程：\n$$\n\\frac{\\partial F}{\\partial y} - \\frac{d}{dx}\\left(\\frac{\\partial F}{\\partial y'}\\right) = 0\n$$\n我们计算 $F(y, y') = n(y)\\sqrt{1 + (y')^2}$ 所需的偏导数：\n$$\n\\frac{\\partial F}{\\partial y} = \\frac{dn}{dy} \\sqrt{1 + (y')^2} = n'(y) \\sqrt{1 + (y')^2}\n$$\n$$\n\\frac{\\partial F}{\\partial y'} = n(y) \\frac{y'}{\\sqrt{1 + (y')^2}}\n$$\n将这些代入欧拉-拉格朗日方程，得到光线方程：\n$$\nn'(y) \\sqrt{1 + (y')^2} - \\frac{d}{dx}\\left( \\frac{n(y)y'}{\\sqrt{1 + (y')^2}} \\right) = 0\n$$\n为了得到关于 $y(x)$ 的显式二阶常微分方程，我们必须计算对 $x$ 的全导数。让我们先重新整理方程：\n$$\n\\frac{d}{dx}\\left( \\frac{n(y)y'}{\\sqrt{1 + (y')^2}} \\right) = n'(y) \\sqrt{1 + (y')^2}\n$$\n对被求导的项应用链式法则 $\\frac{d}{dx} = y' \\frac{\\partial}{\\partial y} + y'' \\frac{\\partial}{\\partial y'}$，然后求解 $y''$，经过代数简化后，我们得到以下二阶常微分方程：\n$$\ny'' = \\frac{n'(y)}{n(y)} \\left(1 + (y')^2\\right)\n$$\n这就是光线路径 $y(x)$ 的控制微分方程。\n\n接下来的任务是将这个二阶常微分方程简化为一个由两个一阶常微分方程组成的系统。我们按要求引入状态变量：$u_1(x) = y(x)$ 和 $u_2(x) = v(x) = y'(x)$。状态向量为 $\\mathbf{u}(x) = [u_1(x), u_2(x)]^T$。我们寻求一个形式为 $d\\mathbf{u}/dx = \\mathbf{f}(x, \\mathbf{u})$ 的系统。\n\n系统的第一个方程直接来自 $u_2(x)$ 的定义：\n$$\n\\frac{du_1}{dx} = \\frac{dy}{dx} = y' = v = u_2\n$$\n第二个方程通过将状态变量代入控制常微分方程得到：\n$$\n\\frac{du_2}{dx} = \\frac{dv}{dx} = y'' = \\frac{n'(y)}{n(y)} (1 + (y')^2) = \\frac{n'(u_1)}{n(u_1)} (1 + u_2^2)\n$$\n因此，一阶系统为：\n$$\n\\frac{d}{dx}\\begin{pmatrix} y \\\\ v \\end{pmatrix} = \\begin{pmatrix} v \\\\ \\frac{n'(y)}{n(y)}(1+v^2) \\end{pmatrix}\n$$\n在 $x=0$ 处的初始条件为 $y(0) = y_0$ 和与 x 轴的夹角 $\\theta_0$。初始斜率为 $y'(0) = v(0) = \\tan(\\theta_0)$。因此，用于数值积分的初始状态向量为：\n$$\n\\mathbf{u}(0) = \\begin{pmatrix} y(0) \\\\ v(0) \\end{pmatrix} = \\begin{pmatrix} y_0 \\\\ \\tan(\\theta_0) \\end{pmatrix}\n$$\n这个初值问题可以使用像龙格-库塔族这样的标准方法从 $x=0$ 到 $x=L$ 进行数值求解。积分后，我们得到最终状态向量 $\\mathbf{u}(L) = [y(L), v(L)]^T$。最终的横向位置是 $y(L)$。最终角度 $\\theta(L)$ 由最终斜率 $v(L) = y'(L) = \\tan(\\theta(L))$ 求得，即 $\\theta(L) = \\arctan(v(L))$。\n\n对于每个测试用例，必须为系统提供相应的函数 $n(y)$ 及其导数 $n'(y) = dn/dy$。\n- 用例 A ($n(y)=n_0$)：$n'(y) = 0$。系统变为 $y' = v$, $v' = 0$。这得到 $v(x) = v_0$ 和 $y(x) = y_0 + v_0 x$，表示一条直线，可解析求解。\n- 用例 B ($n(y)=n_0 + a\\,y$)：$n'(y) = a$。\n- 用例 C ($n(y)=n_0(1 - \\frac{1}{2}(g\\,y)^2)$)：$n'(y) = -n_0 g^2 y$。\n- 用例 D ($L=0$)：这是一个平凡情况，传播距离为零，因此最终状态与初始状态相同。$y(L)=y(0)$ 且 $\\theta(L)=\\theta(0)$。\n\n用例 B 和 C 通常没有简单的解析解，需要进行数值积分。所提供的程序将为这些用例实现一个数值求解器。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# No other libraries outside the Python standard library are permitted.\n\ndef solve():\n    \"\"\"\n    Solves the ray equation for different refractive index profiles.\n    Derives the ODE from Fermat's principle, reduces it to a first-order system,\n    and solves it numerically for the given test cases.\n    \"\"\"\n\n    # Define refractive index functions and their derivatives for each case\n    def n_A(y, n0, **kwargs):\n        return n0\n\n    def dn_dy_A(y, n0, **kwargs):\n        return 0.0\n\n    def n_B_D(y, n0, a, **kwargs):\n        return n0 + a * y\n\n    def dn_dy_B_D(y, n0, a, **kwargs):\n        return a\n    \n    def n_C(y, n0, g, **kwargs):\n        return n0 * (1.0 - 0.5 * (g * y)**2)\n\n    def dn_dy_C(y, n0, g, **kwargs):\n        return -n0 * g**2 * y\n\n    def ray_ode_system(x, u, n_func, dn_dy_func, params):\n        \"\"\"\n        Defines the first-order system for the ray equation.\n        u = [y, v], where v = y'.\n        y'' = (n'(y)/n(y)) * (1 + (y')^2)\n        \"\"\"\n        y, v = u\n        \n        n_val = n_func(y, **params)\n        dn_dy_val = dn_dy_func(y, **params)\n        \n        # Avoid potential division by zero, though not expected for these test cases.\n        if abs(n_val) < 1e-12:\n            # At n=0, physics is singular. Stop integration.\n            # Here we can return a large number to signify an error or NaN.\n            # However, for given parameters, n(y) is always positive.\n            dv_dx = np.nan\n        else:\n            dv_dx = (dn_dy_val / n_val) * (1.0 + v**2)\n            \n        return [v, dv_dx]\n\n    test_cases = [\n        {'id': 'A', 'n_func': n_A, 'dn_dy_func': dn_dy_A, 'params': {'n0': 1.5}, 'y0': 0.0, 'theta0': 0.1, 'L': 0.2},\n        {'id': 'B', 'n_func': n_B_D, 'dn_dy_func': dn_dy_B_D, 'params': {'n0': 1.0, 'a': 0.5}, 'y0': 0.0, 'theta0': 0.2, 'L': 0.5},\n        {'id': 'C', 'n_func': n_C, 'dn_dy_func': dn_dy_C, 'params': {'n0': 1.6, 'g': 3.0}, 'y0': 0.01, 'theta0': -0.15, 'L': 0.3},\n        {'id': 'D', 'n_func': n_B_D, 'dn_dy_func': dn_dy_B_D, 'params': {'n0': 1.2, 'a': 1.0}, 'y0': 0.02, 'theta0': 0.3, 'L': 0.0},\n    ]\n\n    output_parts = []\n    \n    for case in test_cases:\n        y0, theta0, L = case['y0'], case['theta0'], case['L']\n        v0 = np.tan(theta0)\n\n        y_L = 0.0\n        theta_L = 0.0\n\n        if L == 0.0:\n            # Case D: Zero propagation distance, final state is initial state\n            y_L = y0\n            theta_L = theta0\n        elif case['id'] == 'A':\n            # Case A: Uniform medium, analytical solution (straight line)\n            # v' = 0 -> v(x) = v0. y' = v0 -> y(x) = y0 + v0*x\n            y_L = y0 + L * v0\n            theta_L = theta0\n        else:\n            # Cases B and C: Numerical integration\n            initial_state = [y0, v0]\n            \n            sol = solve_ivp(\n                ray_ode_system,\n                [0.0, L],\n                initial_state,\n                args=(case['n_func'], case['dn_dy_func'], case['params']),\n                method='DOP853',  # A high-accuracy solver\n                rtol=1e-9,\n                atol=1e-12\n            )\n            \n            y_L, v_L = sol.y[:, -1]\n            theta_L = np.arctan(v_L)\n\n        # Format each result as a string '[y,theta]' with 6 decimal places.\n        y_L_str = f\"{y_L:.6f}\"\n        theta_L_str = f\"{theta_L:.6f}\"\n        output_parts.append(f\"[{y_L_str},{theta_L_str}]\")\n\n    # Combine all results into the final required format.\n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "2433582"}, {"introduction": "本练习是一个高级挑战，它展示了我们将高阶常微分方程降阶的方法在处理复杂物理现象时的强大功能与精妙之处。经典的亚伯拉罕-洛伦兹（Abraham-Lorentz）力模型会产生一个包含三阶导数的常微分方程，其数学解中存在被称为“失控解”（runaway solutions）的非物理行为。此练习要求您不仅要执行标准降阶，还需巧妙地处理一个特殊的边界条件，并实施一个精巧的数值策略来获得物理上真实有意义的结果，从而磨练您的物理直觉和高级计算技能。[@problem_id:2433622]", "problem": "考虑一个非相对论性的点电子，在没有磁场的情况下，沿着一个空间维度在给定的外部电场 $E(t)$ 下运动。该电子的电荷为 $q=-e$，质量为 $m=m_e$。亚伯拉罕-洛伦兹辐射反作用模型指出，净力等于外力与一个辐射反作用项之和，该反作用项与加速度的时间导数成正比。从牛顿第二定律和辐射反作用模型出发，位置 $x(t)$ 的控制方程是一个关于时间的三阶常微分方程，涉及 $x(t)$、$\\dot{x}(t)$、$\\ddot{x}(t)$ 和 $\\dddot{x}(t)$。您的任务是：\n\n- 通过引入适当的状态变量，推导出一个与该三阶方程等价的一阶常微分方程组。明确指出这些状态变量、它们的物理意义，以及它们各自的一阶时间导数如何用其他变量和外部电场表示。\n- 解释并采用一个具有物理动机的边界条件以消除发散（指数增长）解，并说明该条件如何改变问题的适定性。\n- 基于此一阶系统，实现一个稳健的数值策略，以计算几种给定外部电场下的最终位置 $x(T)$。您的实现必须是一个完整的、可运行的程序，无需用户输入，能数值积分所需的系统，并按以下描述的精确格式打印所要求的结果。\n\n使用的基本原理和常数：\n- 牛顿第二定律：$m\\,\\ddot{x}(t)=F_{\\text{net}}(t)$。\n- 外部电场力：$F_{\\text{ext}}(t)=q\\,E(t)$。\n- 亚伯拉罕-洛伦兹辐射反作用模型：$F_{\\text{rr}}(t)=m\\,\\tau\\,\\dot{a}(t)$，其中 $a(t)=\\ddot{x}(t)$，$\\tau$ 是一个常数，由下式给出\n$$\n\\tau=\\frac{2\\,e^2}{3\\,4\\pi\\,\\varepsilon_0\\,m\\,c^3}.\n$$\n- 在代码中需要数值使用的国际单位制（SI）物理常数：\n    - 基本电荷 $e=1.602176634\\times 10^{-19}$ 库仑。\n    - 电子质量 $m_e=9.1093837015\\times 10^{-31}$ 千克。\n    - 真空介电常数 $\\varepsilon_0=8.8541878128\\times 10^{-12}$ 法拉每米。\n    - 光速 $c=299792458$ 米每秒。\n\n初始和边界条件：\n- 使用 $x(0)=0$ 米 和 $\\dot{x}(0)=0$ 米每秒。\n- 施加物理上可接受的非发散条件，即当 $t\\to +\\infty$ 时 $a(t)\\to 0$。对于实际计算，在一个足够大的有限时间 $T$（此时 $E(t)$ 可忽略不计）处强制施加 $a(T)=0$。\n\n数值策略要求：\n- 为获得一个稳定、精确且满足非发散条件的计算结果，将三阶方程简化为关于变量 $x(t)$、$v(t)=\\dot{x}(t)$ 和 $a(t)=\\ddot{x}(t)$ 的一阶系统。然后，利用 $a(t)$ 的方程是线性和时间一阶的这一事实，在给定 $E(t)$ 和 $a(T)=0$ 的约束下，计算在 $[0,T]$ 上的 $a(t)$。接下来，利用 $v(t)$ 和 $x(t)$ 关于 $a(t)$ 的定义，计算它们在 $[0,T]$ 上的值。您可以使用任何与上述物理要求一致的、科学上合理的离散化和常微分方程积分方法。\n- 不使用角度；无需指定角度单位。\n- 所有报告的位置必须以米为单位表示。\n\n测试组：\n您的程序必须针对以下三种外部电场分别计算 $x(T)$。在每种情况下，根据上述常数定义亚伯拉罕-洛伦兹特征时间 $\\tau$，并用它来构建电场和最终时间 $T$。令 $U=\\frac{T}{\\tau}$ 表示无量纲的最终时间。\n\n1. 高斯脉冲（理想平滑脉冲）：\n   - 电场：$E(t)=E_0\\exp\\!\\left(-\\dfrac{(t-t_c)^2}{2\\,\\sigma^2}\\right)$。\n   - 参数：$E_0=1.0\\times 10^6$ 伏特每米，$t_c=10\\,\\tau$，$\\sigma=3\\,\\tau$，$U=40$，因此 $T=U\\,\\tau$。\n\n2. 阻尼正弦波（带衰减的振荡驱动）：\n   - 电场：$E(t)=E_0\\,\\sin(\\omega t)\\,\\exp\\!\\left(-\\dfrac{t}{T_{\\text{env}}}\\right)$。\n   - 参数：$E_0=1.0\\times 10^6$ 伏特每米，$\\omega=\\dfrac{0.2}{\\tau}$ 弧度每秒，$T_{\\text{env}}=15\\,\\tau$，$U=60$，因此 $T=U\\,\\tau$。\n\n3. 零电场（边缘情况）：\n   - 电场：对于所有 $t$，$E(t)=0$。\n   - 参数：$U=10$，因此 $T=U\\,\\tau$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，即 $[x_1,x_2,x_3]$，其中 $x_k$ 是测试用例 $k$ 的最终位置 $x(T)$（单位为米），表示为标准字符串格式的浮点小数（打印输出中不含单位）。", "solution": "问题陈述已经过分析并被认定为有效。这是一个计算物理学中的适定性问题，基于经典电动力学的既定（尽管是简化的）原理。其表述是自洽的、客观的，并为在规定的物理边界条件下获得唯一解提供了所有必要信息。我现在将开始推导和构建数值解。\n\n非相对论性电子的运动遵循牛顿第二定律，其中净力是外部电场力与亚伯拉罕-洛伦兹辐射反作用力之和。方程为：\n$$\nm\\,\\ddot{x}(t) = F_{\\text{net}}(t) = F_{\\text{ext}}(t) + F_{\\text{rr}}(t)\n$$\n此处，$m$ 是电子质量，$x(t)$ 是其位置，$F_{\\text{ext}}(t) = q\\,E(t)$ 是来自电场 $E(t)$ 的外力（电荷 $q=-e$），而 $F_{\\text{rr}}(t) = m\\,\\tau\\,\\dot{a}(t)$ 是辐射反作用力。量 $a(t) = \\ddot{x}(t)$ 是加速度，$\\tau = \\frac{2\\,e^2}{3\\,4\\pi\\,\\varepsilon_0\\,m\\,c^3}$ 是辐射反作用的特征时间常数。代入这些表达式得到控制方程：\n$$\nm\\,\\ddot{x}(t) = q\\,E(t) + m\\,\\tau\\,\\dddot{x}(t)\n$$\n这是一个关于位置 $x(t)$ 的三阶线性常微分方程。通常将其写成最高阶导数在等式一边的形式：\n$$\n\\dddot{x}(t) - \\frac{1}{\\tau}\\ddot{x}(t) = \\frac{q}{m\\,\\tau}E(t)\n$$\n\n为对此方程进行数值求解，我们将其降阶为一个一阶微分方程组。我们引入一个状态向量 $\\mathbf{y}(t)$，其分量是具有物理意义的位置、速度和加速度。设状态变量为：\n- $y_1(t) = x(t)$：位置\n- $y_2(t) = v(t) = \\dot{x}(t)$：速度\n- $y_3(t) = a(t) = \\ddot{x}(t)$：加速度\n\n然后，这些状态变量的一阶时间导数可以用状态变量自身和外部驱动函数 $E(t)$ 来表示。前两个是定义：\n$$\n\\dot{y}_1(t) = \\dot{x}(t) = v(t) = y_2(t)\n$$\n$$\n\\dot{y}_2(t) = \\dot{v}(t) = a(t) = y_3(t)\n$$\n第三个方程由控制三阶常微分方程代入状态变量得到：\n$$\n\\dot{y}_3(t) = \\dot{a}(t) = \\dddot{x}(t) = \\frac{1}{\\tau}\\ddot{x}(t) + \\frac{q}{m\\,\\tau}E(t) = \\frac{1}{\\tau}y_3(t) + \\frac{q}{m\\,\\tau}E(t)\n$$\n因此，等价的一阶系统是：\n$$\n\\frac{d}{dt}\n\\begin{pmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_2 \\\\\ny_3 \\\\\n\\frac{1}{\\tau}y_3 + \\frac{q}{m\\,\\tau}E(t)\n\\end{pmatrix}\n$$\n\n加速度的方程 $\\dot{a}(t) - \\frac{1}{\\tau}a(t) = \\frac{q}{m\\,\\tau}E(t)$ 有一个齐次部分 $\\dot{a}_h(t) - \\frac{1}{\\tau}a_h(t) = 0$，其解为 $a_h(t) = C\\,e^{t/\\tau}$（$C$为某个常数）。该解随时间指数增长，被称为“发散”解。这种行为是非物理的；在没有持续增长的外力的情况下，电子的加速度不应无限增长。问题陈述正确地要求采用一个物理条件来消除这种非物理行为，即当 $t \\to \\infty$ 时 $a(t) \\to 0$。此条件迫使常数 $C$ 为零，从而从无限多的数学解族中选出唯一物理上可接受的解。对于在有限区间 $[0, T]$ 上的数值计算，其中 $T$ 的选择使得当 $t \\ge T$ 时 $E(t)$ 可忽略不计，此条件被施加为 $a(T)=0$。\n\n两个初始条件 $x(0)=0$ 和 $\\dot{x}(0)=0$ 与最终边界条件 $a(T)=0$ 的组合使问题成为一个边值问题，而非简单的初值问题。数值策略必须尊重这种结构。该问题是解耦的。$a(t)$ 的方程可以首先独立于 $x(t)$ 和 $v(t)$ 求解，因为它不依赖于它们。我们必须求解带有终值条件的 $a(t)$ 的线性一阶方程。对此的标准技术是时间反转。令 $s = T-t$，这意味着 $t=T-s$ 且 $\\frac{d}{dt} = -\\frac{d}{ds}$。$a(t(s))$ 的常微分方程变为：\n$$\n-\\frac{da}{ds} = \\frac{1}{\\tau}a(s) + \\frac{q}{m\\,\\tau}E(T-s)\n$$\n整理后得到一个关于 $a(s)$ 的标准初值问题：\n$$\n\\frac{da}{ds} = -\\frac{1}{\\tau}a(s) - \\frac{q}{m\\,\\tau}E(T-s)\n$$\n边界条件 $a(t=T)=0$ 变成一个初始条件 $a(s=0)=0$。此方程可以使用标准的数值求解器（如龙格-库塔法）稳健地从 $s=0$ 积分到 $s=T$。其结果是在区间 $[0, T]$ 上的函数 $a(s)$。将得到的值数组反转即可得到在区间 $[0, T]$ 上的解 $a(t)$。\n\n一旦在离散时间网格上数值确定了加速度 $a(t)$，就可以通过逐次积分并使用初始条件 $v(0)=0$ 和 $x(0)=0$ 来获得速度 $v(t)$ 和位置 $x(t)$：\n$$\nv(t) = v(0) + \\int_0^t a(t') dt' = \\int_0^t a(t') dt'\n$$\n$$\nx(t) = x(0) + \\int_0^t v(t') dt' = \\int_0^t v(t') dt'\n$$\n这些积分是数值执行的。例如，累积梯形法是合适的。最终位置 $x(T)$ 是 $x(t)$ 数值积分得到的最后一个值。至此，数值解的设计完成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Solves the Abraham-Lorentz equation of motion for an electron for three test cases\n    and prints the final positions.\n    \"\"\"\n    # Physical constants in SI units\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs\n    M_ELECTRON = 9.1093837015e-31 # Electron mass in Kilograms\n    EPSILON_0 = 8.8541878128e-12  # Vacuum permittivity in Farads/meter\n    C_LIGHT = 299792458.0         # Speed of light in meters/second\n\n    # Derived constants\n    Q = -E_CHARGE\n    M = M_ELECTRON\n    # Abraham-Lorentz characteristic time\n    TAU = (2 * E_CHARGE**2) / (3 * 4 * np.pi * EPSILON_0 * M * C_LIGHT**3)\n    # Pre-calculated coefficient for the ODE\n    Q_OVER_M_TAU = Q / (M * TAU)\n\n    def compute_final_position(E_func, T, num_points):\n        \"\"\"\n        Computes the final position x(T) for a given electric field and duration.\n\n        Args:\n            E_func (callable): A function E(t) for the external electric field.\n            T (float): The final time for the simulation.\n            num_points (int): The number of points for the time grid.\n\n        Returns:\n            float: The final position x(T) in meters.\n        \"\"\"\n        # Set up a uniform time grid for the simulation.\n        t_grid = np.linspace(0.0, T, num_points)\n\n        # Define the ODE for a(s) where s = T - t.\n        # This transforms the final value problem into an initial value problem.\n        # da/ds = -a/tau - (q/(m*tau)) * E(T-s)\n        def a_ode(s, a_vec):\n            a = a_vec[0]\n            return [-a / TAU - Q_OVER_M_TAU * E_func(T - s)]\n\n        # The time-reversed variable s runs from 0 to T. We ask the solver\n        # to evaluate the solution on a grid for s that corresponds to our t_grid.\n        s_eval = np.linspace(0.0, T, num_points)\n\n        # Solve the IVP for a(s) from s=0 to s=T with initial condition a(s=0)=0.\n        # We use RK45, a standard adaptive Runge-Kutta method.\n        sol = solve_ivp(a_ode, [0.0, T], [0.0], method='RK45', t_eval=s_eval)\n        \n        a_s = sol.y[0]\n        \n        # The solution a(t) is a(s) reversed in time.\n        a_t = a_s[::-1]\n        \n        # Integrate a(t) to get v(t) with v(0)=0.\n        # cumulative_trapezoid produces an array one element shorter than the input.\n        # By setting initial=0, it prepends a 0 and returns an array of the same size.\n        v_t = cumulative_trapezoid(a_t, t_grid, initial=0.0)\n        \n        # Integrate v(t) to get x(t) with x(0)=0.\n        x_t = cumulative_trapezoid(v_t, t_grid, initial=0.0)\n        \n        # The final position is the last element of the integrated array.\n        return x_t[-1]\n\n    # Test Case 1: Gaussian pulse\n    E0_1 = 1.0e6\n    tc_1 = 10.0 * TAU\n    sigma_1 = 3.0 * TAU\n    U_1 = 40.0\n    T_1 = U_1 * TAU\n    def E1(t):\n        return E0_1 * np.exp(-((t - tc_1)**2) / (2.0 * sigma_1**2))\n    \n    # Test Case 2: Damped sinusoid\n    E0_2 = 1.0e6\n    omega_2 = 0.2 / TAU\n    T_env_2 = 15.0 * TAU\n    U_2 = 60.0\n    T_2 = U_2 * TAU\n    def E2(t):\n        # Piecewise definition to handle large arguments in exp for t<0 from E(T-s)\n        if t < 0:\n            return 0.0\n        return E0_2 * np.sin(omega_2 * t) * np.exp(-t / T_env_2)\n\n    # Test Case 3: Zero field\n    U_3 = 10.0\n    T_3 = U_3 * TAU\n    def E3(t):\n        return 0.0\n\n    # Number of points for each simulation.\n    # A higher density of points is used to ensure accuracy,\n    # chosen proportional to the dimensionless simulation time U.\n    points_per_tau = 2000\n    num_points_1 = int(U_1 * points_per_tau) + 1\n    num_points_2 = int(U_2 * points_per_tau) + 1\n    num_points_3 = int(U_3 * points_per_tau) + 1\n        \n    test_cases = [\n        (E1, T_1, num_points_1),\n        (E2, T_2, num_points_2),\n        (E3, T_3, num_points_3),\n    ]\n\n    results = []\n    for case in test_cases:\n        E_func, T, n_pts = case\n        x_final = compute_final_position(E_func, T, n_pts)\n        results.append(x_final)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2433622"}]}