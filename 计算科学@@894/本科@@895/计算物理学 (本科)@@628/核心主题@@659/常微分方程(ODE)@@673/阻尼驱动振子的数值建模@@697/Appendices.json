{"hands_on_practices": [{"introduction": "现实世界中的系统永远不会被完美隔离。本练习将探讨当我们在振子模型中加入一个随机波动的力（噪声）时会发生什么，这种情况在从微观粒子运动到电子电路的各种系统中都非常普遍。你将学习如何数值求解一个随机微分方程（SDE），并利用功率谱分析来理解系统如何响应确定性驱动力和随机噪声。[@problem_id:2419810]", "problem": "考虑一个受到外部随机力作用的经典阻尼驱动谐振子。从牛顿第二定律出发：总力等于质量乘以加速度。设位置为 $x(t)$，速度为 $v(t) = dx/dt$，质量为 $m$，线性粘性阻尼系数为 $c$，弹簧常数为 $k$，外部驱动力为 $F(t) = F_0 \\cos(\\omega_d t) + \\eta(t)$，其中 $\\eta(t)$ 是一个零均值高斯白噪声过程，其自相关为 $\\langle \\eta(t)\\eta(t')\\rangle = 2 D \\delta(t-t')$。运动方程为\n$$\nm \\frac{d^2 x}{dt^2} + c \\frac{dx}{dt} + k x = F_0 \\cos(\\omega_d t) + \\eta(t).\n$$\n您必须推导一种数值方法来模拟位置时间序列，然后分析其频率内容。您的开发过程必须遵守以下约束和步骤。\n\n1) 通过引入 $v(t) = dx/dt$ 并为 $(x,v)$ 写出方程组，来推导一阶随机微分方程（SDE）系统。使用指定的加性白噪声力 $\\eta(t)$。然后，您必须基于第一性原理，使用针对随机微分方程的 Euler–Maruyama 格式，构建一个离散时间积分器，以固定的时间步长 $\\Delta t$ 将 $(x,v)$ 向前演化。明确使用独立同分布的标准正态变量来模拟维纳增量，并将连续时间噪声强度 $D$ 与离散时间更新关联起来。\n\n2) 实现一个模拟，对于下面的每个参数集，从 $t=0$ 到 $t=T$ 以固定的步长 $\\Delta t$ 进行积分，起始条件为 $x(0)=0$ 和 $v(0)=0$。为伪随机数生成器使用确定性种子以确保每次运行的可复现性；对于测试用例索引 $i=0,1,2,3$，使用种子 $12345 + i$。在计算任何频谱量之前，丢弃持续时间为 $T_{\\text{burn}}$ 的初始“暂态”段。所有角度和角频率都必须以弧度为单位，时间以秒为单位。\n\n3) 按照以下步骤，从模拟的后暂态段计算位置的单边功率谱：\n- 从保留的 $x(t)$ 中移除样本均值。\n- 对保留的样本应用汉宁窗（Hann window）以减少频谱泄漏，其中对于 $n=0,\\dots,N-1$ 的汉宁窗 $w(n)$ 为 $w(n) = \\tfrac{1}{2}\\left(1-\\cos\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$。\n- 使用快速傅里叶变换（FFT）算法计算离散傅里叶变换以获得频域表示，并通过取非负频率处的幅值平方来形成单边功率谱。设采样间隔为 $\\Delta t$，对应的非负频率网格为 $f_k$，则将角频率网格定义为 $\\omega_k = 2\\pi f_k$，以弧度/秒表示。\n- 为确定响应的特征频率，在搜索频带 $\\omega \\in [\\omega_{\\min}, \\omega_{\\max}]$ 内（其中 $\\omega_{\\min} = 0.1$ 且 $\\omega_{\\max} = 4.0$），找到位置 $x(t)$ 的单边功率谱达到其最大值时的角频率 $\\omega_{\\text{peak}}$ （以弧度/秒为单位）。将 $\\omega=0$ 处的直流（DC）分量排除在考虑范围之外。\n\n4) 对于每个测试用例，您的程序必须输出单个浮点数 $\\omega_{\\text{peak}}$（以弧度/秒为单位），四舍五入到三位小数。将所有四个结果聚合到一行中，形成一个逗号分隔的 Python 风格列表，例如 $[1.000,0.950, \\dots]$，不含空格。\n\n物理单位：\n- 使用国际单位制：$m$ 的单位是千克，$c$ 的单位是千克/秒，$k$ 的单位是牛顿/米，$F_0$ 的单位是牛顿，$D$ 的单位是牛顿平方秒，时间的单位是秒，角频率的单位是弧度/秒。\n- 以弧度/秒为单位报告 $\\omega_{\\text{peak}}$。\n\n角度单位：所有角度和角频率都必须以弧度为单位。\n\n最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $[\\omega_{\\text{peak},1},\\omega_{\\text{peak},2},\\omega_{\\text{peak},3},\\omega_{\\text{peak},4}]$。\n\n测试套件和参数集：\n- 对所有情况，使用总时间 $T=60$，时间步长 $\\Delta t = 10^{-3}$，以及预烧（burn-in）持续时间 $T_{\\text{burn}}=10$。对所有情况，自然角频率由 $\\omega_0 = \\sqrt{k/m}$ 确定，阻尼比由 $\\zeta = c/(2\\sqrt{km})$ 确定。\n- 情况1（典型驱动，有噪声）：$m=1.0, c=0.25, k=1.0, F_0=1.0, \\omega_d=0.9, D=0.02$。\n- 情况2（确定性驱动，无噪声）：$m=1.0, c=0.25, k=1.0, F_0=1.0, \\omega_d=0.8, D=0.0$。\n- 情况3（强阻尼）：$m=1.0, c=2.0, k=1.0, F_0=1.0, \\omega_d=1.2, D=0.03$。\n- 情况4（仅噪声的共振整形）：$m=1.0, c=0.2, k=1.0, F_0=0.0, \\omega_d=1.0, D=0.05$。\n\n覆盖性设计：\n- 情况1探讨了共振附近的典型欠阻尼、有噪声的驱动响应。\n- 情况2测试了随机项消失的边界情况，验证了频谱峰值与确定性驱动频率对齐。\n- 情况3测试了响应展宽的近临界阻尼系统。\n- 情况4测试了没有确定性驱动的边缘情况，其中频谱完全由对白加速度噪声的线性响应所塑造。\n\n您的任务：实现上述要求，并输出列表 $[\\omega_{\\text{peak},1},\\omega_{\\text{peak},2},\\omega_{\\text{peak},3},\\omega_{\\text{peak},4}]$，每个条目四舍五入到三位小数，单行输出，无额外文本。", "solution": "所提出的问题是有效的，因为它在科学上基于经典力学和随机过程的原理，其参数和条件完备，问题陈述清晰，并以客观、正式的语言表述。我们开始进行求解。\n\n该问题要求对一个受到附加随机力作用的阻尼驱动谐振子进行数值模拟。分析过程分三个阶段进行：首先，将控制方程重构为一阶随机微分方程（SDE）组；其次，推导并实现一个合适的数值积分方案；第三，对模拟出的位置时间序列进行频谱分析。\n\n运动方程如下：\n$$\nm \\frac{d^2 x}{dt^2} + c \\frac{dx}{dt} + k x = F_0 \\cos(\\omega_d t) + \\eta(t)\n$$\n其中 $m$ 是质量，$c$ 是阻尼系数，$k$ 是弹簧常数，$F_0$ 和 $\\omega_d$ 是确定性驱动力的振幅和角频率，而 $\\eta(t)$ 是一个高斯白噪声过程，其自相关为 $\\langle \\eta(t)\\eta(t')\\rangle = 2D\\delta(t-t')$。\n\n首先，我们将这个二阶方程转换为一个包含两个一阶SDE的方程组。设状态变量为位置 $x_1(t) = x(t)$ 和速度 $x_2(t) = v(t) = dx/dt$。该系统为：\n$$\n\\frac{dx_1}{dt} = x_2\n$$\n$$\n\\frac{dx_2}{dt} = -\\frac{k}{m} x_1 - \\frac{c}{m} x_2 + \\frac{F_0}{m} \\cos(\\omega_d t) + \\frac{1}{m} \\eta(t)\n$$\n该系统可以用SDE的语言来表达，将白噪声项 $\\eta(t) dt$ 解释为一个缩放后的维纳过程 $dW'_t$ 的增量。过程 $W'(t)$ 的方差随时间线性增长，使得在时间间隔 $dt$ 内的增量 $dW'_t$ 的方差为 $\\langle (dW'_t)^2 \\rangle = 2D dt$。因此，SDE系统为：\n$$\ndx_1 = x_2 dt\n$$\n$$\ndx_2 = \\left( -\\frac{k}{m} x_1 - \\frac{c}{m} x_2 + \\frac{F_0}{m} \\cos(\\omega_d t) \\right) dt + \\frac{\\sqrt{2D}}{m} dW_t\n$$\n其中 $dW_t$ 是标准维纳过程的增量，满足 $\\langle (dW_t)^2 \\rangle = dt$。\n\n接下来，我们使用 Euler-Maruyama 格式以固定的时间步长 $\\Delta t$ 对此SDE系统进行离散化。设在时间 $t_n = n \\Delta t$ 的状态为 $(x_n, v_n)$。在下一个时间步 $t_{n+1} = (n+1) \\Delta t$ 的状态可近似为：\n$$\nx_{n+1} = x_n + v_n \\Delta t\n$$\n$$\nv_{n+1} = v_n + \\left( -\\frac{k}{m} x_n - \\frac{c}{m} v_n + \\frac{F_0}{m} \\cos(\\omega_d t_n) \\right) \\Delta t + \\frac{\\sqrt{2D}}{m} \\Delta W_n\n$$\n离散维纳增量 $\\Delta W_n$ 是一个从均值为 $0$、方差为 $\\Delta t$ 的正态分布中抽取的随机变量。因此，我们可以写成 $\\Delta W_n = \\sqrt{\\Delta t} Z_n$，其中 $Z_n$ 是从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取的随机变量。速度的最终更新规则是：\n$$\nv_{n+1} = v_n + \\left( -\\frac{k}{m} x_n - \\frac{c}{m} v_n + \\frac{F_0}{m} \\cos(\\omega_d n \\Delta t) \\right) \\Delta t + \\frac{\\sqrt{2D \\Delta t}}{m} Z_n\n$$\n这些方程被用来从初始条件 $x(0)=0$ 和 $v(0)=0$ 开始模拟系统的时间演化。\n\n最后，我们对模拟出的位置时间序列 $x(t)$ 进行频谱分析。模拟的初始段，即持续时间为 $T_{\\text{burn}}$ 的部分，被丢弃，以确保系统已达到统计稳态。对于信号的剩余部分，其长度为 $N$：\n1. 减去位置数据的样本均值以移除任何直流偏移。\n2. 对去趋势后的信号应用汉宁窗（Hann window）$w(n) = \\frac{1}{2}(1-\\cos(\\frac{2\\pi n}{N-1}))$，其中 $n = 0, \\dots, N-1$。这种锥化处理减少了由信号的有限时长引起的频谱泄漏。\n3. 计算加窗信号的快速傅里叶变换（FFT）。为提高效率，我们使用实值FFT变体。\n4. 单边功率谱通过计算复数FFT系数的幅值平方得到。\n5. 构建角频率网格 $\\omega_k = 2\\pi f_k$，其中 $f_k$ 是与FFT频点对应的离散频率。\n6. 通过在指定的搜索频带 $\\omega \\in [0.1, 4.0]$ rad/s 内找到功率谱的最大值，来确定峰值角频率 $\\omega_{\\text{peak}}$。\n对所提供的四个参数集中的每一个都重复此过程，并使用指定的随机数生成器种子以保证可复现性。然后报告所得的 $\\omega_{\\text{peak}}$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import rfft, rfftfreq\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a damped, driven harmonic oscillator\n    with stochastic forcing and finding the peak frequency of its power spectrum.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, c, k, F0, wd, D)\n        (1.0, 0.25, 1.0, 1.0, 0.9, 0.02),  # Case 1\n        (1.0, 0.25, 1.0, 1.0, 0.8, 0.0),   # Case 2\n        (1.0, 2.0,  1.0, 1.0, 1.2, 0.03),  # Case 3\n        (1.0, 0.2,  1.0, 0.0, 1.0, 0.05),  # Case 4\n    ]\n\n    # Simulation and analysis parameters\n    T = 60.0  # Total simulation time in seconds\n    dt = 1e-3  # Timestep in seconds\n    T_burn = 10.0  # Burn-in time in seconds\n    omega_min = 0.1  # Search band minimum angular frequency in rad/s\n    omega_max = 4.0  # Search band maximum angular frequency in rad/s\n\n    N_total = int(T / dt)\n    N_burn = int(T_burn / dt)\n    N_signal = N_total - N_burn\n    \n    time_pts = np.arange(0, T, dt)\n    \n    results = []\n    for i, params in enumerate(test_cases):\n        m, c, k, F0, wd, D = params\n        seed = 12345 + i\n        rng = np.random.default_rng(seed)\n\n        x = np.zeros(N_total)\n        v = np.zeros(N_total)\n        \n        # Initial conditions x(0)=0, v(0)=0 are set by np.zeros\n\n        # Pre-compute coefficients for the integration loop\n        c1 = -k / m\n        c2 = -c / m\n        c3 = F0 / m\n        stochastic_term_coeff = np.sqrt(2 * D * dt) / m\n        \n        # Euler-Maruyama integration\n        for n in range(N_total - 1):\n            t_n = time_pts[n]\n            Z_n = rng.normal(0.0, 1.0)\n            \n            # Update velocity first\n            v_drift = (c1 * x[n] + c2 * v[n] + c3 * np.cos(wd * t_n))\n            v_stochastic = stochastic_term_coeff * Z_n\n            v[n+1] = v[n] + v_drift * dt + v_stochastic\n            \n            # Update position using velocity at step n\n            x[n+1] = x[n] + v[n] * dt\n            \n        # --- Spectral Analysis ---\n        x_signal = x[N_burn:]\n        \n        # 1. Remove sample mean\n        x_signal_detrended = x_signal - np.mean(x_signal)\n        \n        # 2. Apply Hann window\n        hann_window = np.hanning(N_signal)\n        x_windowed = x_signal_detrended * hann_window\n        \n        # 3. Compute FFT for real input\n        yf = rfft(x_windowed)\n        xf = rfftfreq(N_signal, dt)\n        \n        # 4. Form angular frequencies and one-sided power spectrum\n        omega = 2.0 * np.pi * xf\n        power_spectrum = np.abs(yf)**2\n        \n        # 5. Find peak frequency in the specified band\n        search_indices = np.where((omega >= omega_min)  (omega = omega_max))\n        \n        peak_idx_local = np.argmax(power_spectrum[search_indices])\n        peak_idx_global = search_indices[0][peak_idx_local]\n        \n        omega_peak = omega[peak_idx_global]\n        \n        results.append(f\"{omega_peak:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2419810"}, {"introduction": "虽然线性弹簧力（$F=-kx$）是一个很好的近似，但许多真实弹簧在拉伸时会变得更硬或更软。本练习引入了一个非线性力项 $\\alpha x^3$，将我们的系统转变为一个杜芬振子（Duffing oscillator）。你将研究这种非线性如何导致驱动力与振子之间的相位延迟依赖于驱动振幅，这是一个在纯线性系统中不存在的特性。[@problem_id:2419785]", "problem": "考虑一个受迫、阻尼、非线性振子，其运动由以下常微分方程 (ODE) 描述：\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) + \\alpha\\,x^{3}(t) = F_{0}\\cos(\\omega t),\n$$\n其中质量为 $m$，阻尼系数为 $c$，线性刚度为 $k$，三次刚度为 $\\alpha$，驱动振幅为 $F_{0}$，驱动角频率为 $\\omega$。采用以下国际单位制 (SI) 中的固定参数值：$m = 1.0\\,\\mathrm{kg}$，$c = 0.3\\,\\mathrm{kg/s}$，$k = 1.0\\,\\mathrm{N/m}$，$\\alpha = 1.0\\,\\mathrm{N/m^{3}}$ 以及 $\\omega = 1.2\\,\\mathrm{rad/s}$。初始条件为 $x(0) = 0.0\\,\\mathrm{m}$ 和 $\\dot{x}(0) = 0.0\\,\\mathrm{m/s}$，时间 $t$ 的单位为 $\\mathrm{s}$。驱动器与振子之间的相位滞后 $\\delta$ 定义如下。在稳态下，位移 $x(t)$ 在长度为 $T_{\\mathrm{w}}$ 的有限平均窗口上，其基波（角频率为 $\\omega$）的同相和正交投影由下式定义：\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\cos(\\omega t)\\,dt, \\qquad\nB = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\sin(\\omega t)\\,dt,\n$$\n并设\n$$\n\\delta = \\operatorname{atan2}(B, A),\n$$\n如果计算值为负，则通过加上 $2\\pi$ 将其映射到区间 $[0, 2\\pi)$ 内。平均计算必须在瞬态衰减后进行，使用 $t_{0} = 200.0\\,\\mathrm{s}$ 和窗口 $T_{\\mathrm{w}} = N_{\\mathrm{avg}} \\,\\frac{2\\pi}{\\omega}$，其中 $N_{\\mathrm{avg}} = 20$。角度必须以弧度表示。您的任务是针对以下每个驱动振幅 $F_{0}$（单位为 $\\mathrm{N}$）计算相位滞后 $\\delta$：$F_{0} \\in \\{\\,0.05,\\,0.20,\\,0.50,\\,0.80\\,\\}$。使用上面给出的 $(m,c,k,\\alpha,\\omega)$ 的固定值和初始条件，并在从 $t_0$ 开始的指定平均窗口上计算定义 $A$ 和 $B$ 的积分。\n\n测试套件与答案规范：\n- 使用上面给出的四个驱动振幅 $F_{0}$ 作为测试套件。\n- 对每种情况，生成一个对应于相位滞后 $\\delta$（单位为弧度）的实数，并按规定映射到 $[0, 2\\pi)$。\n- 最终程序输出必须为一行，其中包含与测试用例相对应的四个 $\\delta$ 值，顺序与所列顺序相同，并四舍五入到恰好 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[0.123456,1.234567,2.345678,3.456789]$。", "solution": "问题陈述已经过验证，并被认定为有效。它描述了一个受迫、阻尼 Duffing 振子的适定初值问题，这是非线性动力学研究中的一个典范系统。所有参数、初始条件和分析步骤都以科学和数学的严谨性进行了定义。不存在矛盾、歧义或事实性错误。\n\n任务是计算非线性振子响应 $x(t)$ 与驱动力之间的稳态相位滞后 $\\delta$。其控制方程为二阶常微分方程 (ODE)：\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) + \\alpha\\,x^{3}(t) = F_{0}\\cos(\\omega t)\n$$\n求解需要采用数值方法，其步骤如下。\n\n首先，我们将二阶常微分方程转换为一个由两个一阶常微分方程组成的系统。我们定义一个状态向量 $\\mathbf{y}(t) = [y_1(t), y_2(t)]^T$，其中 $y_1(t) = x(t)$ 代表位置，$y_2(t) = \\dot{x}(t)$ 代表速度。该状态向量的时间演化由以下系统给出：\n$$\n\\dot{\\mathbf{y}}(t) = \n\\begin{pmatrix} \\dot{y}_1(t) \\\\ \\dot{y}_2(t) \\end{pmatrix} =\n\\begin{pmatrix} y_2(t) \\\\ \\frac{1}{m} \\left( F_{0}\\cos(\\omega t) - c\\,y_2(t) - k\\,y_1(t) - \\alpha\\,y_1^3(t) \\right) \\end{pmatrix}\n$$\n该系统需在初始条件 $x(0) = y_1(0) = 0.0\\,\\mathrm{m}$ 和 $\\dot{x}(0) = y_2(0) = 0.0\\,\\mathrm{m/s}$ 下求解。给定的参数为 $m = 1.0\\,\\mathrm{kg}$，$c = 0.3\\,\\mathrm{kg/s}$，$k = 1.0\\,\\mathrm{N/m}$，$\\alpha = 1.0\\,\\mathrm{N/m^{3}}$ 以及 $\\omega = 1.2\\,\\mathrm{rad/s}$。该问题需要针对驱动振幅 $F_{0}$ 的四个不同值 $F_{0} \\in \\{0.05, 0.20, 0.50, 0.80\\}\\,\\mathrm{N}$ 进行求解。\n\n此初值问题 (IVP) 使用适当的算法进行数值求解。`scipy.integrate.solve_ivp` 函数实现了一种高阶自适应步长 Runge-Kutta 方法（例如 `RK45`），是完成此项任务的合适选择。积分必须在一个足够长的时间区间上进行，以使瞬态衰减并覆盖指定的平均窗口。积分区间为从 $t=0$ 到 $t_{f} = t_{0} + T_{w}$。平均计算的开始时间为 $t_{0} = 200.0\\,\\mathrm{s}$，窗口持续时间为 $T_{\\mathrm{w}} = N_{\\mathrm{avg}} \\frac{2\\pi}{\\omega}$，其中 $N_{\\mathrm{avg}} = 20$。这得出 $t_{f} = 200.0 + 20 \\frac{2\\pi}{1.2} \\approx 304.7198\\,\\mathrm{s}$。为便于后续的积分计算，ODE 求解器被配置为生成密集输出，从而为解 $x(t)$ 提供一个连续的插值函数。\n\n一旦获得了 $x(t)$ 的数值解，就计算同相和正交投影 $A$ 和 $B$。它们被定义为稳态响应的傅里叶基波系数：\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\cos(\\omega t)\\,dt\n$$\n$$\nB = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\sin(\\omega t)\\,dt\n$$\n这些定积分使用稳健的数值积分方法进行数值计算。`scipy.integrate.quad` 函数采用自适应数值积分方案，是一个极佳的选择。它作用于被积函数，其中的 $x(t)$ 由 `solve_ivp` 输出的插值函数提供。\n\n最后，根据系数 $A$ 和 $B$ 使用双参数反正切函数确定相位滞后 $\\delta$：\n$$\n\\delta = \\operatorname{atan2}(B, A)\n$$\n`atan2` 的使用能将角度正确定位在相应的象限，从而得到一个在 $(-\\pi, \\pi]$ 范围内的结果。根据问题规定，此值随后通过对任何负结果加上 $2\\pi$ 来映射到区间 $[0, 2\\pi)$ 内。\n\n对每个指定的 $F_0$ 值，重复这整个过程——常微分方程的数值求解、用于计算 $A$ 和 $B$ 的积分的数值评估以及 $\\delta$ 的计算。最终的数值结果四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\n\ndef solve():\n    \"\"\"\n    Solves the damped, driven Duffing oscillator equation for several forcing\n    amplitudes and computes the steady-state phase lag for each case.\n    \"\"\"\n\n    # --- Define problem parameters in SI units ---\n    m = 1.0        # mass (kg)\n    c = 0.3        # damping coefficient (kg/s)\n    k = 1.0        # linear stiffness (N/m)\n    alpha = 1.0    # cubic stiffness (N/m^3)\n    omega = 1.2    # driving angular frequency (rad/s)\n\n    # --- Define simulation and analysis parameters ---\n    x0 = 0.0       # initial position (m)\n    v0 = 0.0       # initial velocity (m/s)\n    y0 = [x0, v0]  # initial state vector [x, v]\n\n    t0 = 200.0     # start time for averaging (s)\n    N_avg = 20     # number of cycles for averaging\n    T_w = N_avg * (2 * np.pi / omega)  # averaging window duration (s)\n    t_final = t0 + T_w               # end time for simulation\n\n    # --- Test cases for forcing amplitude ---\n    test_cases_F0 = [0.05, 0.20, 0.50, 0.80]  # (N)\n\n    results = []\n\n    def duffing_ode_system(t, y, F0):\n        \"\"\"\n        Defines the system of first-order ODEs for the Duffing oscillator.\n        y[0] = x (position), y[1] = v (velocity).\n        \"\"\"\n        x, v = y\n        # Equation: m*x_ddot + c*v + k*x + alpha*x^3 = F0*cos(omega*t)\n        # Transformed to: x_ddot = (F0*cos(omega*t) - c*v - k*x - alpha*x^3) / m\n        dv_dt = (F0 * np.cos(omega * t) - c * v - k * x - alpha * x**3) / m\n        return [v, dv_dt]\n\n    for F0 in test_cases_F0:\n        # Numerically solve the ODE system.\n        # dense_output=True creates an interpolant for the solution,\n        # which is needed for accurate quadrature.\n        # Stricter tolerances are used for higher accuracy of the final result.\n        solution = solve_ivp(\n            fun=lambda t, y: duffing_ode_system(t, y, F0),\n            t_span=(0, t_final),\n            y0=y0,\n            dense_output=True,\n            method='RK45',\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        # The solution object `sol.sol` is a callable interpolating function.\n        x_t = lambda t: solution.sol(t)[0]\n\n        # Define the integrands for the Fourier projections A and B.\n        integrand_A = lambda t: x_t(t) * np.cos(omega * t)\n        integrand_B = lambda t: x_t(t) * np.sin(omega * t)\n\n        # Compute the integrals using `scipy.integrate.quad`.\n        # `quad` returns (integral_value, error_estimate), we only need the value.\n        A_integral, _ = quad(integrand_A, t0, t_final)\n        B_integral, _ = quad(integrand_B, t0, t_final)\n\n        # Calculate the A and B coefficients based on their definition.\n        A = (2 / T_w) * A_integral\n        B = (2 / T_w) * B_integral\n\n        # Calculate the phase lag delta using atan2(B, A).\n        delta = np.arctan2(B, A)\n\n        # Map delta from (-pi, pi] to the required interval [0, 2pi).\n        if delta  0:\n            delta += 2 * np.pi\n\n        results.append(delta)\n\n    # Format the final output string to exactly 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2419785"}, {"introduction": "一个简单的确定性系统能否表现出随机行为？本练习通过一个适应性的振子模型来模拟滴水的水龙头，该模型具有变化的质量和当水滴下落时的“重置”条件。通过模拟不同流速下的系统，你将揭示著名的通往混沌的倍周期分岔路径，这是现代物理学中的一个基本概念，它揭示了隐藏在简单规则中的复杂性。[@problem_id:2419756]", "problem": "您的任务是构建一个完整、可运行的程序，通过阻尼驱动振子的视角对滴水的水龙头进行数值模拟。该模型根据牛顿第二定律构建，并基于以下简化且广泛使用的假设：当一滴水附着在水龙头上时，其行为如同一个连接到线性弹簧和阻尼器的质点，并受到恒定的引力作用。水龙头以恒定的流率增加质量，当伸长量超过一个与质量相关的断裂阈值时，水滴便会脱离。脱离后，会有一小部分残留物作为下一滴水滴的“种子”。这种设定是一个标准的计算物理练习，并导出了一个带有状态重置的非自治常微分方程 (ODE)。目标是模拟随流率变化的动力学过程，并提取暂态之后不同滴水间隔时间的数量，从而揭示一个倍周期序列。\n\n从牛顿第二定律以及线性阻尼和线性弹性的定义出发。当水滴附着时，假设如下：\n- 相对于水龙头的水滴位置是一个向下测量的标量位移 $x(t)$，其速度为 $v(t) = \\frac{dx}{dt}$。\n- 瞬时质量 $m(t)$ 以恒定的流入速率 $q$ 增加，即 $\\frac{dm}{dt} = q$。\n- 水滴所受的力来自重力、线性弹簧和线性阻尼器，其系数分别为 $g$、$\\kappa$ 和 $\\gamma$。\n- 假设新加入的质量附着时其相对动量效应可忽略不计，这给出了一个常用的近似，其中方程左侧使用 $m(t)\\,x''(t)$ 而没有额外的射流动量项。\n\n在这些假设下，附着时的控制方程为\n$$\n\\frac{dx}{dt} = v, \\quad \n\\frac{dv}{dt} = \\frac{m(t)\\,g - \\gamma\\,v - \\kappa\\,x}{m(t)}, \\quad\n\\frac{dm}{dt} = q.\n$$\n当伸长量 $x(t)$ 从下方达到阈值 $x_{\\mathrm{break}}(m)$ 时，发生断裂（脱离），其中\n$$\nx_{\\mathrm{break}}(m) = x_0 - \\beta\\,m,\n$$\n$x_0$ 和 $\\beta$ 是正常数。在脱离时刻 $t_d$，状态被重置，以模拟附着在水龙头颈部的残余质量，并为下一滴水滴设定一个松弛、静止的初始条件：\n$$\nx(t_d^+) = 0, \\quad v(t_d^+) = 0, \\quad m(t_d^+) = \\alpha\\,m(t_d^-),\n$$\n其中 $0  \\alpha  1$ 是残余质量分数，上标 $^-$ 和 $^+$ 分别表示事件发生前后的极限。\n\n您的任务是：\n1) 根据牛顿第二定律，在所述假设下，论证上述 ODE 系统和重置规则的合理性。阐明可变质量如何进入加速度方程，以及为什么所选的简化在此情境下是合适的。\n2) 设计并实现一个稳健的事件驱动数值积分器，用以：\n   - 积分 ODE 直到检测到 $x$ 递增的断裂事件 $x(t) - x_{\\mathrm{break}}(m(t)) = 0$。\n   - 应用重置规则并继续模拟以生成一个长的滴水时间序列。\n3) 对于每个指定的流率 $q$，计算滴水间隔时间 $\\Delta t_n = t_{n} - t_{n-1}$。舍弃初始暂态，然后在给定的容差内确定存在的不同滴水间隔时间的数量，该数量是周期-$k$ 行为（例如，周期-1 为 $k=1$，倍周期后为 $k=2$ 等）的整数诊断量。使用一个结合了绝对和相对分量的容差，以避免因数值噪声导致的错误区分。\n4) 使用以下用于振子和断裂模型的无量纲参数，并指定流率的测试组：\n   - 振子参数：$\\kappa = 1.0$，$\\gamma = 0.05$，$g = 0.34$。\n   - 断裂参数：$x_0 = 0.50$，$\\beta = 0.10$，$\\alpha = 0.30$。\n   - 最初始的初始条件：$x(0) = 0$，$v(0) = 0$，$m(0) = 0.40$。\n   - 流率测试组（四种情况）：$q \\in \\{\\,0.010,\\,0.025,\\,0.050,\\,0.080\\,\\}$。\n   - 积分足够长的时间，以观察每种情况下至少 $N_{\\mathrm{total}} = 60$ 滴水，舍弃前 $N_{\\mathrm{trans}} = 30$ 滴作为暂态，并分析接下来的 $N_{\\mathrm{keep}} = 30$ 滴。\n   - 使用一个检测容差，该容差使用规则“若 $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$，则属于同一组”将滴水间隔时间 $\\Delta t$ 聚类为不同的组，其中 $\\varepsilon_{\\mathrm{abs}}=10^{-3}$ 和 $\\varepsilon_{\\mathrm{rel}}=10^{-3}$。\n5) 您的程序必须产生单行输出，包含一个逗号分隔的整数列表，并用方括号括起来（例如，“[1,2,4,1]”），其中每个整数是按上述顺序为相应流率计数的不同滴水间隔时间数量。\n\n该问题必须纯粹用数学和算法术语来解决，以便可以用任何编程语言实现。以上所有量均为无量纲，因此不需要进行物理单位转换。确保参数的科学真实性，并在您的解决方案中讨论为什么该方法能捕捉到倍周期序列。每个测试用例的最终答案是量化在暂态后发现的不同滴水间隔时间的整数。", "solution": "所提出的问题是计算物理学中的一个有效练习。它在科学上是合理的、良定的，并且所有必要的参数和条件都已指明。它将一个复杂的物理现象——滴水的水龙头——标准地简化为一个带有状态重置的非自治常微分方程组，这是一个已知会展现出倍周期分岔和混沌现象的模型。我们将进行严谨的推导和算法设计。\n\n首先，我们必须从基本原理出发来论证控制方程的合理性。所描述的系统是一个质量 $m(t)$ 随时间变化的质点。对于可变质量物体，牛顿第二定律最普遍的表述是动量 $\\vec{p}$ 的变化率等于合外力 $\\vec{F}_{\\mathrm{ext}}$，即 $\\vec{F}_{\\mathrm{ext}} = \\frac{d\\vec{p}}{dt}$。在我们的-维系统中，动量为 $p(t) = m(t)v(t)$，其中 $v(t) = \\frac{dx}{dt}$ 是速度。应用微分的乘法法则，我们得到：\n$$\n\\frac{dp}{dt} = \\frac{d(mv)}{dt} = m(t)\\frac{dv}{dt} + v(t)\\frac{dm}{dt} = m(t)a(t) + v(t)q\n$$\n其中 $a(t) = \\frac{dv}{dt}$ 是加速度，$\\frac{dm}{dt} = q$ 是恒定的质量流入速率。$v(t)q$ 项表示将流入的流体（假设其初始垂直速度为零）加速到水滴当前速度 $v(t)$ 所需的力。问题陈述指导我们使用一个常见的简化，即忽略这个“射流动量”项。如果速度 $v(t)$ 很小，或者如果主动力学主要由其他力主导（通常是这种情况），这是一个合理的近似。在此简化下，牛顿第二定律简化为：\n$$\nm(t)a(t) \\approx F_{\\mathrm{ext}}\n$$\n作用在质量上的外力是重力（$F_g = m(t)g$）、线性弹簧的恢复力（$F_s = -\\kappa x$）和线性粘性阻尼力（$F_d = -\\gamma v$）。弹簧常数为 $\\kappa$，阻尼系数为 $\\gamma$，$g$ 是重力加速度。位移 $x$ 是从水龙头向下测量的，所以引力为正。这些力的总和是：\n$$\nF_{\\mathrm{ext}} = m(t)g - \\kappa x - \\gamma v\n$$\n将此与动量变化率的简化表达式相等，得到水滴的运动方程：\n$$\nm(t)\\frac{dv}{dt} = m(t)g - \\kappa x - \\gamma v\n$$\n两边除以瞬时质量 $m(t)$ 得到加速度：\n$$\n\\frac{dv}{dt} = g - \\frac{\\gamma}{m(t)}v - \\frac{\\kappa}{m(t)}x\n$$\n这正是所提供的方程。该方程与定义式 $\\frac{dx}{dt} = v$ 和 $\\frac{dm}{dt} = q$ 结合，构成了一个包含三个耦合的、一阶的、非自治的常微分方程组。该系统是非自治的，因为加速度方程中 $v$ 和 $x$ 的系数通过质量 $m(t) = m(0) + qt$ 显式地依赖于时间。\n\n模拟通过积分该系统直至发生断裂事件来进行。断裂的条件是伸长量 $x(t)$ 达到一个与质量相关的阈值 $x_{\\mathrm{break}}(m) = x_0 - \\beta m$。其物理直觉是，随着水滴变重，表面张力越来越难以支持大的伸长量。因此，事件函数为 $ G(t, x, m) = x(t) - x_{\\mathrm{break}}(m(t)) = 0$。我们关心的是 $x(t)$ 从下方穿越此阈值的事件，所以我们必须检测一个递增方向上的零点穿越。\n\n在脱离时刻 $t_d$，系统状态被重置。新的水滴以零位移和零速度开始，即 $x(t_d^+) = 0$ 和 $v(t_d^+) = 0$。这是一个简化，假设残余流体瞬间稳定到静止状态。至关重要的是，并非所有质量都脱离。在断裂时，水滴质量 $m(t_d^-)$ 的一部分 $\\alpha$ 仍然附着在水龙头上：$m(t_d^+) = \\alpha m(t_d^-)$。这个残余质量 $m(t_d^+)$ 作为下一滴水滴的初始条件，并在连续的滴水事件之间提供了“记忆”。正是这种记忆，加上重置机制的非线性特性和质量流入的驱动力，使得系统能够展现出复杂的动力学。第 $n$ 滴水在形成时的质量 $m_n(0)$ 取决于第 $n-1$ 滴水在断裂时的质量 $m_{n-1}(t_{\\text{rupture}})$。这就创建了一个从一滴到下一滴的映射，对于某些参数范围（例如流率 $q$），该映射会经历倍周期级联，这是通往混沌之路的一个标志。对于低流率 $q$，系统会稳定到一个周期-1 的极限环，其中每滴水都相同，滴水之间的时间间隔是恒定的。当 $q$ 增加时，系统可能会分岔到一个周期-2 的环，其中滴水间隔时间（和水滴大小）在两个不同的值之间交替。进一步增加 $q$ 会导致周期-4、周期-8，并最终导致混沌行为，其中滴水间隔时间呈现随机性。我们的任务是为给定的 $q$ 值计算这些不同的滴水间隔时间。\n\n算法如下：\n1.  为 ODE 系统定义一个函数：$\\frac{dY}{dt} = F(t, Y)$，其中 $Y = [x, v, m]^T$。\n2.  为断裂条件 $x - (x_0 - \\beta m) = 0$ 定义一个事件函数。该函数必须是终端事件，并检测从负到正的穿越。\n3.  对于测试组中的每个流率 $q$：\n    a. 初始化状态向量 $Y_0 = [0, 0, 0.40]^T$，当前时间 $t_{\\mathrm{current}} = 0$，以及一个用于存储滴水时间的列表 `drip_times`。\n    b. 循环 $N_{\\mathrm{total}} = 60$ 次以收集 60 滴水的数据。\n        i. 使用数值 ODE 求解器（例如 `scipy.integrate.solve_ivp`）从 $t_{\\mathrm{current}}$ 和当前状态开始积分系统，直到触发断裂事件。\n        ii. 记录事件时间 $t_{\\mathrm{event}}$。将其添加到 `drip_times`。\n        iii. 根据重置规则更新状态向量：$x_{\\mathrm{new}} = 0$，$v_{\\mathrm{new}} = 0$，$m_{\\mathrm{new}} = \\alpha \\cdot m_{\\mathrm{event}}$，其中 $m_{\\mathrm{event}}$ 是断裂时的质量。新的当前时间是 $t_{\\mathrm{current}} = t_{\\mathrm{event}}$。\n    c. 计算滴水间隔时间 $\\Delta t_i = \\text{drip\\_times}[i] - \\text{drip\\_times}[i-1]$，其中 $i=1, \\dots, N_{\\mathrm{total}}-1$。我们还需要第一个间隔 $\\text{drip\\_times}[0] - 0$。这将产生 $N_{\\mathrm{total}}$ 个间隔。\n    d. 舍弃前 $N_{\\mathrm{trans}} = 30$ 个间隔作为暂态动力学。\n    e. 分析随后的 $N_{\\mathrm{keep}} = 30$ 个间隔。为了计算不同值的数量，对时间间隔进行排序并遍历排序后的列表，根据指定的容差 $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$ 将彼此接近的值分组计数。一个简单的方法是计算在排序列表中，一个元素与前一个元素存在显著差异的次数。\n    f. 将此计数记录为给定 $q$ 的结果。\n4.  按指定格式化最终的计数列表。\n这种稳健的、事件驱动的方法正确地模拟了物理过程，并能够准确地确定系统的周期性行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically models a dripping faucet to observe period-doubling.\n\n    The model treats a growing water drop as a damped, driven harmonic oscillator\n    with variable mass. The system is described by a non-autonomous ODE with\n    state resets upon drop detachment. This function simulates the dynamics for\n    a set of flow rates and determines the periodicity of the drip intervals.\n    \"\"\"\n\n    # Define physical and numerical parameters as per the problem statement.\n    # Oscillator parameters\n    kappa = 1.0  # Spring constant\n    gamma = 0.05 # Damping coefficient\n    g = 0.34     # Gravitational acceleration\n\n    # Rupture and reset parameters\n    x0 = 0.50    # Rupture threshold constant\n    beta = 0.10  # Rupture threshold mass dependency\n    alpha = 0.30 # Residual mass fraction\n\n    # Initial conditions for the very first drop\n    x_init = 0.0\n    v_init = 0.0\n    m_init = 0.40\n\n    # Simulation control\n    N_total = 60  # Total number of drips to simulate per case\n    N_trans = 30  # Number of transient drips to discard\n    \n    # Tolerance for clustering inter-drip times\n    eps_abs = 1e-3\n    eps_rel = 1e-3\n    \n    # Test suite of flow rates\n    test_cases = [0.010, 0.025, 0.050, 0.080]\n\n    results = []\n\n    # ODE system definition: dy/dt = f(t, y)\n    # y = [x, v, m]\n    def ode_system(t, y, q_val):\n        x, v, m = y\n        # Avoid division by zero if mass is ever zero, though m_init > 0.\n        if m = 0:\n            return [0.0, 0.0, q_val]\n        \n        dxdt = v\n        dvdt = g - (gamma * v / m) - (kappa * x / m)\n        dmdt = q_val\n        return [dxdt, dvdt, dmdt]\n\n    # Event function: fires when x(t) = x_break(m(t))\n    # x_break(m) = x0 - beta * m\n    def rupture_event(t, y, q_val):\n        x, v, m = y\n        return x - (x0 - beta * m)\n    \n    rupture_event.terminal = True  # Stop integration at the event\n    rupture_event.direction = 1    # Event triggers when x is increasing\n\n    # Main loop over each flow rate\n    for q_flow in test_cases:\n        \n        # Initialize state for this test case\n        current_time = 0.0\n        y_current = np.array([x_init, v_init, m_init])\n        \n        drip_times = []\n\n        # Simulate N_total drips\n        for _ in range(N_total):\n            # Define a sufficiently long time span for the next drip\n            t_span = (current_time, current_time + 100.0)\n            \n            # Integrate until the next rupture event\n            sol = solve_ivp(\n                fun=lambda t, y: ode_system(t, y, q_flow),\n                t_span=t_span,\n                y0=y_current,\n                events=lambda t, y: rupture_event(t, y, q_flow),\n                dense_output=True,\n                max_step=0.1\n            )\n            \n            # Check if an event was found\n            if sol.t_events[0].size > 0:\n                event_time = sol.t_events[0][0]\n                drip_times.append(event_time)\n                \n                # State at the moment of rupture\n                y_event = sol.sol(event_time)\n                m_rupture = y_event[2]\n                \n                # Apply reset rules\n                current_time = event_time\n                y_current = np.array([0.0, 0.0, alpha * m_rupture])\n            else:\n                # Should not happen with given parameters and t_span\n                # Break if no drip is found in the time window\n                break\n\n        # Analyze the collected drip times\n        if len(drip_times)  N_total:\n             # If simulation failed, append an error code (e.g., -1)\n             results.append(-1)\n             continue\n        \n        # Calculate inter-drip times\n        all_times = np.insert(np.array(drip_times), 0, 0.0)\n        inter_drip_times = np.diff(all_times)\n\n        # Discard transients and keep the part for analysis\n        analysis_times = inter_drip_times[N_trans:]\n\n        if len(analysis_times) == 0:\n            results.append(0)\n            continue\n        \n        # Cluster the inter-drip times to count distinct values\n        sorted_times = np.sort(analysis_times)\n        \n        num_distinct_times = 1\n        # The first time interval starts the first cluster\n        cluster_representative = sorted_times[0]\n        \n        for i in range(1, len(sorted_times)):\n            dt_current = sorted_times[i]\n            dt_prev = sorted_times[i-1]\n            \n            # Check if current time is \"far\" from previous one using the tolerance rule\n            tolerance = max(eps_abs, eps_rel * max(abs(dt_current), abs(dt_prev)))\n            if abs(dt_current - dt_prev) > tolerance:\n                num_distinct_times += 1\n        \n        results.append(num_distinct_times)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419756"}]}