{"hands_on_practices": [{"introduction": "经典的简谐振子模型通常假设质量恒定不变。然而在许多现实系统中，例如一个振动的弹簧上连接着一个消耗燃料的火箭，质量会随时间变化。这个练习将引导你探索这类非自治系统（non-autonomous system）的动力学，其运动方程的系数是随时间变化的：$m(t)\\ddot{x} + kx = 0$。通过这个实践 [@problem_id:2420164]，你将学会如何使用数值方法求解那些固有频率本身在演变的系统，这是超越教科书理想模型的关键一步。", "problem": "一个附着在线性弹簧上的质点，在弹簧恢复力的作用下沿一维运动。该质点的质量不是恒定的，而是随时间变化：$m(t) > 0$。被排出的质量与剩余质量具有相同的瞬时速度，因此不产生推力。不存在其他力。使用国际单位制（SI单位）：位置单位为米，质量单位为千克，时间单位为秒，弹簧常数单位为牛顿/米。时间以秒为单位。\n\n从第一性原理出发，动力学遵循牛顿第二定律，该定律应用于剩余质量，其中弹簧的恢复力是唯一的作用力。喷射出的质量相对于主体质量没有相对速度，因此力平衡方程仅包含弹簧力和剩余质量的惯性项。使用此物理模型，为以下每个测试用例计算运动 $x(t)$，每个用例都给定了初始条件和指定的质量函数 $m(t)$。\n\n测试用例集：\n1. 恒定质量（参考用例）：\n   - 弹簧常数：$k = 4\\,\\mathrm{N/m}$\n   - 质量：$m(t) = m_0$，其中 $m_0 = 1\\,\\mathrm{kg}$\n   - $t = 0$ 时的初始条件：$x(0) = 0.1\\,\\mathrm{m}$，$v(0) = 0\\,\\mathrm{m/s}$\n   - 最终时间：$t_{\\mathrm{end}} = \\pi\\,\\mathrm{s}$\n2. 线性递减质量：\n   - 弹簧常数：$k = 2\\,\\mathrm{N/m}$\n   - 质量：$m(t) = m_0 - \\beta t$，其中 $m_0 = 2\\,\\mathrm{kg}$，$\\beta = 0.1\\,\\mathrm{kg/s}$\n   - $t = 0$ 时的初始条件：$x(0) = 0\\,\\mathrm{m}$，$v(0) = 1.0\\,\\mathrm{m/s}$\n   - 最终时间：$t_{\\mathrm{end}} = 5\\,\\mathrm{s}$\n3. 指数级质量损失至剩余质量：\n   - 弹簧常数：$k = 10\\,\\mathrm{N/m}$\n   - 质量：$m(t) = m_{\\mathrm{res}} + (m_0 - m_{\\mathrm{res}})\\exp(-\\alpha t)$，其中 $m_0 = 5\\,\\mathrm{kg}$，$m_{\\mathrm{res}} = 1\\,\\mathrm{kg}$，$\\alpha = 1\\,\\mathrm{s^{-1}}$\n   - $t = 0$ 时的初始条件：$x(0) = 0.2\\,\\mathrm{m}$，$v(0) = -0.5\\,\\mathrm{m/s}$\n   - 最终时间：$t_{\\mathrm{end}} = 3\\,\\mathrm{s}$\n4. 早期快速质量下降（平滑且有下界）：\n   - 弹簧常数：$k = 3\\,\\mathrm{N/m}$\n   - 质量：$m(t) = m_{\\mathrm{res}} + (m_0 - m_{\\mathrm{res}})\\exp\\!\\left(-\\left(\\frac{t}{t_c}\\right)^2\\right)$，其中 $m_0 = 3\\,\\mathrm{kg}$，$m_{\\mathrm{res}} = 1.5\\,\\mathrm{kg}$，$t_c = 0.2\\,\\mathrm{s}$\n   - $t = 0$ 时的初始条件：$x(0) = 0.05\\,\\mathrm{m}$，$v(0) = 0\\,\\mathrm{m/s}$\n   - 最终时间：$t_{\\mathrm{end}} = 2\\,\\mathrm{s}$\n\n您的任务是编写一个完整的、可运行的程序，该程序为每个测试用例计算最终位置 $x(t_{\\mathrm{end}})$（单位：米）和最终速度 $v(t_{\\mathrm{end}})$（单位：米/秒）。每对数值均应四舍五入到六位小数。\n\n最终输出格式：\n- 生成单行输出，其中包含一个含有四个列表的列表，每个内部列表对应一个测试用例，并按上述顺序排列。\n- 每个内部列表的形式必须为 $[x(t_{\\mathrm{end}}), v(t_{\\mathrm{end}})]$，其中两个条目均四舍五入到六位小数，单位分别为米和米/秒。\n- 例如，格式必须严格为 $[[x_1,v_1],[x_2,v_2],[x_3,v_3],[x_4,v_4]]$，其中每个 $x_i$ 和 $v_i$ 都是一个四舍五入到六位小数的十进制数。\n\n所有计算和结果都必须使用国际单位制。本问题不涉及角度。本问题不使用百分比。所提供的测试用例集涵盖了恒定质量的参考情况、缓慢的线性质量减少、指数级趋近于一个剩余质量，以及在保持严格为正的同时发生的快速初始下降。输出要求为实数。", "solution": "所提交的问题陈述已经过严格验证，并被确定为有效。该问题具有科学依据，数学上是适定的、客观的，并为求解提供了完整且一致的信息集。该物理模型虽然是真实世界场景的简化，但其定义清晰且数学上自洽。因此，将提供一个解决方案。\n\n所描述的物理系统是一个具有时变质量 $m(t)$ 的一维谐振子。其运动方程源自适用于变质量系统的牛顿第二定律。物体在时间 $t$ 的总动量由 $\\mathbf{p}(t) = m(t)\\mathbf{v}(t)$ 给出。根据牛顿第二定律，系统动量的时间变化率等于净外力 $\\mathbf{F}_{\\mathrm{ext}}$。\n\n对于变质量物体，该定律的一般形式为 $\\mathbf{F}_{\\mathrm{ext}} = \\frac{d\\mathbf{p}}{dt} = \\frac{d(m\\mathbf{v})}{dt} = m\\frac{d\\mathbf{v}}{dt} + \\frac{dm}{dt}\\mathbf{v}$。然而，此形式仅在特定参考系中有效，并需要仔细考虑被喷射质量所携带的动量。一个更通用、更稳健的公式是 Tsiolkovsky 火箭方程：$\\mathbf{F}_{\\mathrm{ext}} + \\mathbf{u}\\frac{dm}{dt} = m\\frac{d\\mathbf{v}}{dt}$，其中 $\\mathbf{u}$ 是喷射质量相对于主体速度 $\\mathbf{v}$ 的相对速度。\n\n问题明确指出：“被排出的质量与剩余质量具有相同的瞬时速度，因此不产生推力。”此陈述意味着在惯性参考系中，被喷射质量的速度与主体在喷射瞬间的速度相同。因此，它们的相对速度为零，即 $\\mathbf{u} = 0$。将此条件代入通用方程，得到 $\\mathbf{F}_{\\mathrm{ext}} = m(t)\\frac{d\\mathbf{v}}{dt}$。\n\n作用在质量上的唯一外力是来自弹簧的线性恢复力，该力由胡克定律（Hooke's Law）给出：$F_{x} = -kx$，其中 $k$ 是弹簧常数，$x$ 是偏离平衡位置的位移。因此，一维运动方程为：\n$$\nm(t)\\frac{d^2x}{dt^2} = -kx(t)\n$$\n该方程可以重排为二阶线性常微分方程（ODE）的标准形式：\n$$\n\\ddot{x}(t) + \\frac{k}{m(t)}x(t) = 0\n$$\n该方程描述了角频率 $\\omega(t) = \\sqrt{k/m(t)}$ 随时间变化的振荡。对于所给出的 $m(t)$ 的一般形式，不易获得解析解，因此需要采用数值方法。\n\n为了数值求解此 ODE，我们首先将这个二阶方程转换为一个由两个一阶 ODE 组成的系统。我们定义状态向量 $\\mathbf{y}(t)$ 如下：\n$$\n\\mathbf{y}(t) = \\begin{pmatrix} y_1(t) \\\\ y_2(t) \\end{pmatrix} = \\begin{pmatrix} x(t) \\\\ \\dot{x}(t) \\end{pmatrix}\n$$\n其中 $y_1$ 是位置，$y_2$ 是速度 $v(t)$。此状态向量的时间演化由以下系统描述：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\begin{pmatrix} \\dot{y_1}(t) \\\\ \\dot{y_2}(t) \\end{pmatrix} = \\begin{pmatrix} y_2(t) \\\\ -\\frac{k}{m(t)}y_1(t) \\end{pmatrix}\n$$\n每个测试用例都构成一个初值问题（IVP），其初始状态 $\\mathbf{y}(0) = [x(0), v(0)]^T$ 是已知的。\n\n该 ODE 系统使用高保真度的数值积分器求解。SciPy 库中的 `solve_ivp` 函数是一个合适的工具，因为它实现了如 Dormand-Prince (RK45) 方法等稳健的自适应步长算法。这一选择确保了解的计算具有高精度和数值稳定性。为保证数值误差远小于所要求的六位小数输出精度，我们为求解器指定了严格的相对和绝对误差容限（分别为 $rtol=10^{-9}$ 和 $atol=10^{-12}$）。\n\n计算流程如下：\n1. 对四个测试用例中的每一个，定义其相应的参数（$k$）、质量函数（$m(t)$）、初始条件（$x_0, v_0$）和最终时间（$t_{\\mathrm{end}}$）。\n2. 实现代表 ODE 系统右侧的函数 $\\mathbf{f}(t, \\mathbf{y})$。\n3. 调用 `solve_ivp` 函数，从初始状态 $\\mathbf{y}(0)$ 开始，在时间区间 $[0, t_{\\mathrm{end}}]$ 上对系统进行积分。\n4. 配置求解器，使其仅返回最终时间 $t_{\\mathrm{end}}$ 处的状态向量。\n5. 从解中提取最终的位置 $x(t_{\\mathrm{end}})$ 和速度 $v(t_{\\mathrm{end}})$。\n6. 按照问题陈述的要求，将这两个值四舍五入到六位小数。\n7. 对所有测试用例重复此过程，并将最终结果汇总并格式化为所要求的列表的列表的字符串表示形式。\n\n对于第一个测试用例（恒定质量），方程简化为标准的简谐振子方程 $\\ddot{x} + \\omega^2 x = 0$，其中 $\\omega = \\sqrt{k/m} = \\sqrt{4/1} = 2\\,\\mathrm{rad/s}$。对于给定的初始条件（$x(0)=0.1, v(0)=0$），其解析解为 $x(t) = 0.1\\cos(2t)$。在 $t_{\\mathrm{end}}=\\pi$ 时，精确解为 $x(\\pi) = 0.1 \\cos(2\\pi) = 0.1$ 和 $v(\\pi) = -0.2 \\sin(2\\pi) = 0$。这个已知结果是验证数值实现正确性的一个关键基准。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes the final position and velocity for a simple harmonic oscillator\n    with time-varying mass for four different test cases.\n    \"\"\"\n    # Define test cases using a list of dictionaries for clarity.\n    # Each dictionary contains all parameters for a single simulation.\n    test_cases = [\n        # 1. Constant mass (reference case)\n        {\n            \"k\": 4.0,\n            \"mass_func\": lambda t: 1.0,\n            \"ic\": [0.1, 0.0],\n            \"t_end\": np.pi,\n        },\n        # 2. Linearly decreasing mass\n        {\n            \"k\": 2.0,\n            \"mass_func\": lambda t: 2.0 - 0.1 * t,\n            \"ic\": [0.0, 1.0],\n            \"t_end\": 5.0,\n        },\n        # 3. Exponential mass loss to a residual mass\n        {\n            \"k\": 10.0,\n            \"mass_func\": lambda t: 1.0 + (5.0 - 1.0) * np.exp(-1.0 * t),\n            \"ic\": [0.2, -0.5],\n            \"t_end\": 3.0,\n        },\n        # 4. Rapid early mass drop\n        {\n            \"k\": 3.0,\n            \"mass_func\": lambda t: 1.5 + (3.0 - 1.5) * np.exp(-(t / 0.2)**2),\n            \"ic\": [0.05, 0.0],\n            \"t_end\": 2.0,\n        }\n    ]\n\n    all_results = []\n\n    # Iterate through each test case and solve the ODE\n    for case in test_cases:\n        k = case[\"k\"]\n        mass_func = case[\"mass_func\"]\n        ic = case[\"ic\"]\n        t_span = (0.0, case[\"t_end\"])\n\n        # Define the system of first-order ODEs: y' = f(t, y)\n        # where y = [x, v] is the state vector [position, velocity].\n        def system_rhs(t, y):\n            x, v = y\n            m_t = mass_func(t)\n            # The equation of motion is m(t)*x'' + k*x = 0\n            # So, x'' = dv/dt = -(k/m(t)) * x\n            dxdt = v\n            dvdt = -(k / m_t) * x\n            return [dxdt, dvdt]\n\n        # Use solve_ivp for numerical integration.\n        # RK45 is the default adaptive method (Dormand-Prince).\n        # Tighter tolerances are used for higher accuracy to ensure the\n        # six-decimal-place requirement is met reliably.\n        sol = solve_ivp(\n            system_rhs,\n            t_span,\n            ic,\n            method='RK45',\n            t_eval=[case[\"t_end\"]], # We only need the solution at the final time\n            rtol=1e-9,\n            atol=1e-12\n        )\n\n        # The solution 'sol.y' is a 2x1 array containing [x_final, v_final]\n        final_state = sol.y[:, -1]\n        \n        # Round the results to six decimal places as specified.\n        x_final = round(final_state[0], 6)\n        v_final = round(final_state[1], 6)\n        \n        # Python's round() can produce -0.0, which we normalize to 0.0 for consistency.\n        if x_final == -0.0:\n            x_final = 0.0\n        if v_final == -0.0:\n            v_final = 0.0\n            \n        all_results.append([x_final, v_final])\n\n    # Format the final output string exactly as required: [[x1,v1],[x2,v2],...]\n    # This construction ensures no spaces are included, matching the format.\n    inner_strs = [f\"[{x},{v}]\" for x, v in all_results]\n    final_output = f\"[{','.join(inner_strs)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2420164"}, {"introduction": "我们通常在惯性参考系中分析物理问题，但如果在一个加速运动的参考系（例如一辆加速的汽车）中观察一个振子，它的行为会如何？这个练习将你带入非惯性系的世界，探索因参考系加速而产生的“虚拟力”（fictitious force）概念。运动方程将演变为一个受迫振子方程 $m\\ddot{x} + kx = -ma_F(t)$ [@problem_id:2420174]。你将亲手实现速度 Verlet 算法——一种强大的、保持系统几何结构的辛积分器——来求解此问题，从而加深对参考系变换和数值积分稳定性的理解。", "problem": "考虑一个一维质量-弹簧系统，该系统从一个原点经历预设的随时间变化的加速度的匀速平移参考点进行观测。令 $x_{\\mathrm{I}}(t)$ 表示质量的惯性坐标，令 $X_{\\mathrm{F}}(t)$ 表示加速参考系原点的惯性坐标，其参考系加速度为 $a_{\\mathrm{F}}(t)=d^{2}X_{\\mathrm{F}}/dt^{2}$。定义参考系相对坐标 $x(t)=x_{\\mathrm{I}}(t)-X_{\\mathrm{F}}(t)$。该质量为 $m$，连接到一个刚度为 $k$ 的线性弹簧上，弹簧的另一端刚性固定在加速参考系的原点上，因此在参考系中弹簧力与 $-x(t)$ 成正比。根据牛顿第二定律和 $x(t)$ 的定义，加速参考系中的运动方程是一个受迫简谐振子，形式如下：\n$$\nm\\,\\frac{d^{2}x}{dt^{2}} + k\\,x = -\\,m\\,a_{\\mathrm{F}}(t).\n$$\n角度单位必须是 $\\mathrm{rad}$，时间单位是 $\\mathrm{s}$，质量单位是 $\\mathrm{kg}$，距离单位是 $\\mathrm{m}$，加速度单位是 $\\mathrm{m/s^{2}}$，刚度单位是 $\\mathrm{N/m}$。\n\n任务。编写一个完整的、可运行的程序，该程序：\n- 使用二阶、时间可逆的辛方法（速度 Verlet 格式）对下面指定的四个测试案例的运动方程进行数值积分。\n- 对于每个测试案例，仅使用模拟轨迹计算如下定义的单个标量诊断量。除非另有说明，否则使用模拟时间区间的最后 $20\\%$ 作为“结束窗口”，在该窗口中评估时间平均量以近似稳态行为。将“时间平均”解释为窗口内采样时间点上的离散平均。\n\n数值积分要求：\n- 使用速度 Verlet 方法和固定时间步长 $\\Delta t$：\n  1. 给定时间 $t_{n}$ 时的 $x_{n}$、$v_{n}$、$a_{n}$，更新位置\n  $$\n  x_{n+1} = x_{n} + v_{n}\\,\\Delta t + \\tfrac{1}{2}a_{n}\\,\\Delta t^{2}.\n  $$\n  2. 计算新步长的加速度\n  $$\n  a_{n+1} = -\\frac{k}{m}\\,x_{n+1} - a_{\\mathrm{F}}(t_{n+1}).\n  $$\n  3. 更新速度\n  $$\n  v_{n+1} = v_{n} + \\tfrac{1}{2}\\,(a_{n}+a_{n+1})\\,\\Delta t.\n  $$\n- 初始化 $a_{0}=-\\frac{k}{m}\\,x_{0}-a_{\\mathrm{F}}(0)$。\n- 总时间步数为 $N=\\lfloor T/\\Delta t \\rfloor$，模拟从 $t=0$ 运行到 $t=N\\,\\Delta t \\approx T$。\n\n要计算的诊断量：\n- 对于结束窗口上的位置“时间平均”，计算 $\\overline{x}_{\\mathrm{end}} = \\frac{1}{M}\\sum_{j} x_{j}$，其中求和遍历最后 $M$ 个样本。\n- 对于结束窗口上的“振幅”，计算半峰峰值振幅 $A_{\\mathrm{pp}} = \\tfrac{1}{2}\\left(\\max x_{j} - \\min x_{j}\\right)$。\n- 对于“相对能量漂移”，将参考系中的机械能定义为 $E(t)=\\tfrac{1}{2}m v^{2}(t)+\\tfrac{1}{2}k x^{2}(t)$，并报告最终能量与初始能量之间的绝对相对变化，即 $\\left|E(T)-E(0)\\right|/E(0)$，表示为一个纯数（小数，无单位）。\n- 对于已知驱动频率 $\\Omega$ 下的“频率响应振幅”，使用结束窗口数据 $\\{(t_{j},x_{j})\\}$ 计算投影\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\sum_{j} x_{j}\\,\\sin(\\Omega t_{j})\\,\\Delta t,\\quad\nB = \\frac{2}{T_{\\mathrm{w}}}\\sum_{j} x_{j}\\,\\cos(\\Omega t_{j})\\,\\Delta t,\n$$\n其中 $T_{\\mathrm{w}}$ 是结束窗口的持续时间，并报告 $\\sqrt{A^{2}+B^{2}}$。\n\n测试套件。运行以下四个案例。在所有案例中，使用初始条件 $x(0)=x_{0}$ 和 $v(0)=v_{0}$ 以及指定的分段平滑 $a_{\\mathrm{F}}(t)$：\n\n- 案例 1（恒定加速度参考系；稳态偏移）。参数：$m=1\\,\\mathrm{kg}$，$k=4\\,\\mathrm{N/m}$，$a_{\\mathrm{F}}(t)=a_{0}$，其中 $a_{0}=1\\,\\mathrm{m/s^{2}}$，$x_{0}=0\\,\\mathrm{m}$，$v_{0}=0\\,\\mathrm{m/s}$，$T=20\\,\\mathrm{s}$，$\\Delta t=0.005\\,\\mathrm{s}$。需要输出的诊断量：$\\overline{x}_{\\mathrm{end}}$，单位为 $\\mathrm{m}$。\n- 案例 2（惯性参考系；能量检验）。参数：$m=1\\,\\mathrm{kg}$，$k=9\\,\\mathrm{N/m}$，$a_{\\mathrm{F}}(t)=0\\,\\mathrm{m/s^{2}}$，$x_{0}=0.1\\,\\mathrm{m}$，$v_{0}=0\\,\\mathrm{m/s}$，$T=20\\,\\mathrm{s}$，$\\Delta t=0.005\\,\\mathrm{s}$。需要输出的诊断量：$\\left|E(T)-E(0)\\right|/E(0)$，以小数形式（无单位）。\n- 案例 3（阶跃加速度参考系；围绕偏移平衡点的振荡）。参数：$m=1\\,\\mathrm{kg}$，$k=4\\,\\mathrm{N/m}$，$a_{\\mathrm{F}}(t)=a_{0}\\,H(t)$，其中 $a_{0}=1\\,\\mathrm{m/s^{2}}$，$H(t)$ 是 Heaviside 阶跃函数，满足 $t<0$ 时 $H(t)=0$，$t\\ge 0$ 时 $H(t)=1$，$x_{0}=0\\,\\mathrm{m}$，$v_{0}=0\\,\\mathrm{m/s}$，$T=20\\,\\mathrm{s}$，$\\Delta t=0.005\\,\\mathrm{s}$。需要输出的诊断量：在结束窗口上计算的 $A_{\\mathrm{pp}}$，单位为 $\\mathrm{m}$。\n- 案例 4（正弦加速参考系；离共振响应）。参数：$m=1\\,\\mathrm{kg}$，$k=4\\,\\mathrm{N/m}$，$a_{\\mathrm{F}}(t)=A\\,\\sin(\\Omega t)$，其中 $A=1\\,\\mathrm{m/s^{2}}$，$\\Omega=1.5\\,\\mathrm{rad/s}$，$x_{0}=0\\,\\mathrm{m}$，$v_{0}=0\\,\\mathrm{m/s}$，$T=60\\,\\mathrm{s}$，$\\Delta t=0.005\\,\\mathrm{s}$。需要输出的诊断量：在已知驱动频率 $\\Omega$ 下使用结束窗口计算的频率响应振幅 $\\sqrt{A^{2}+B^{2}}$，单位为 $\\mathrm{m}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含案例 1 到 4 的四个结果，按顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $[\\overline{x}_{\\mathrm{end}},\\,\\text{drift},\\,A_{\\mathrm{pp}},\\,\\text{amp}]$。将第一个、第三个和第四个结果以 $\\mathrm{m}$ 为单位表示，第二个结果表示为纯小数（无单位）。将每个数字格式化为小数点后恰好 $6$ 位。", "solution": "所提出的问题是经典力学中一个适定的初值问题，具体涉及受迫简谐振子的动力学。该问题在科学上是合理的，所有参数、方程、初始条件和数值程序都得到了明确无误的定义。指定的任务是使用速度 Verlet 方法进行数值积分，并为四个不同的物理场景计算特定的诊断量。问题是有效的，并且可以构建一个完整的解决方案。\n\n质量位置 $x(t)$ 相对于加速参考系的控制运动方程由牛顿第二定律给出，其中包含一个惯性力项：\n$$\nm\\,\\frac{d^{2}x}{dt^{2}} + k\\,x = -m\\,a_{\\mathrm{F}}(t)\n$$\n这可以重写为关于加速度 $a(t) = d^2x/dt^2$ 的标准二阶常微分方程（ODE）：\n$$\na(t) = -\\frac{k}{m}\\,x(t) - a_{\\mathrm{F}}(t)\n$$\n该 ODE 必须从初始条件 $x(0) = x_0$ 和 $v(0) = v_0$ 开始进行数值求解，其中 $v(t) = dx/dt$。\n\n解决方案的核心是该运动方程的数值积分。问题要求使用速度 Verlet 算法，这是一种二阶、时间可逆的辛积分器。辛积分器特别适用于哈密顿系统，例如保守力学系统，因为它们在长时间积分中不会表现出长期的能量漂移。相反，总能量的误差保持有界。该特性在案例 2 中得到了明确的测试。\n\n速度 Verlet 算法以大小为 $\\Delta t$ 的离散时间步进行。给定时间 $t_n$ 时的状态 $(x_n, v_n, a_n)$，下一个时间步 $t_{n+1} = t_n + \\Delta t$ 时的状态计算如下：\n1.  首先，使用当前速度和加速度将位置更新到下一个完整时间步：\n    $$\n    x_{n+1} = x_{n} + v_{n}\\,\\Delta t + \\frac{1}{2}a_{n}\\,\\Delta t^{2}\n    $$\n2.  接下来，在新的位置 $x_{n+1}$ 和新的时间 $t_{n+1}$ 计算加速度 $a_{n+1}$：\n    $$\n    a_{n+1} = -\\frac{k}{m}\\,x_{n+1} - a_{\\mathrm{F}}(t_{n+1})\n    $$\n3.  最后，使用新旧加速度的平均值更新速度，这使得该方法具有时间对称性并确保其二阶精度：\n    $$\n    v_{n+1} = v_{n} + \\frac{1}{2}\\,(a_{n}+a_{n+1})\\,\\Delta t\n    $$\n模拟在 $t_0=0$ 处初始化，初始值为 $x_0$、$v_0$ 和初始加速度 $a_0 = -\\frac{k}{m}x_0 - a_{\\mathrm{F}}(0)$。该过程重复 $N = \\lfloor T/\\Delta t \\rfloor$ 步，生成时间序列的位置 $x_j$、速度 $v_j$ 和时间 $t_j$，其中 $j=0, 1, \\dots, N$。\n\n获得最终结果的总体算法如下：\n1.  对于四个测试案例中的每一个，定义具体参数（$m, k, T, \\Delta t$）、初始条件（$x_0, v_0$）以及随时间变化的参考系加速度函数 $a_{\\mathrm{F}}(t)$。\n2.  实现一个通用的模拟函数，该函数执行如上所述的速度 Verlet 积分循环，并存储每一步的时间、位置和速度。\n3.  为每个测试案例执行此模拟，以生成轨迹数据 $(t_j, x_j, v_j)$。\n4.  对于每个案例，将指定的诊断计算应用到生成的轨迹上。用于时间平均诊断的“结束窗口”指的是最后 $20\\%$ 的数据点，对应于时间区间 $[0.8T, T]$。\n\n具体的诊断量计算如下：\n-   **案例 1：时间平均位置 $\\overline{x}_{\\mathrm{end}}$**。这是结束窗口内位置值 $x_j$ 的算术平均值。它测量稳态平衡位置。从解析上看，对于恒定力，平衡点位于 $x_{\\mathrm{eq}} = -m a_0 / k = -(1\\,\\mathrm{kg})(1\\,\\mathrm{m/s^2}) / (4\\,\\mathrm{N/m}) = -0.25\\,\\mathrm{m}$。\n-   **案例 2：相对能量漂移**。参考系中的机械能为 $E(t) = \\frac{1}{2}mv^2(t) + \\frac{1}{2}kx^2(t)$。漂移为 $|E(t_N) - E(t_0)|/E(t_0)$。对于此案例，$a_{\\mathrm{F}}(t)=0$，因此系统是保守的，该诊断量测量了数值积分器保持能量守恒的能力。\n-   **案例 3：振幅 $A_{\\mathrm{pp}}$**。这是结束窗口内最大和最小位置值之差的一半。系统从原点静止开始，受到一个恒定力，使其围绕新的平衡点振荡。这种振荡的解析振幅是 $|x_0 - x_{\\mathrm{eq}}| = |0 - (-0.25\\,\\mathrm{m})| = 0.25\\,\\mathrm{m}$。\n-   **案例 4：频率响应振幅**。将结束窗口中的轨迹数据投影到驱动频率 $\\Omega$ 的正弦基函数上，以找到稳态响应的振幅。求和 $A = \\frac{2}{T_{\\mathrm{w}}}\\sum_{j} x_{j}\\,\\sin(\\Omega t_{j})\\,\\Delta t$ 和 $B = \\frac{2}{T_{\\mathrm{w}}}\\sum_{j} x_{j}\\,\\cos(\\Omega t_{j})\\,\\Delta t$ 是傅里叶系数的离散近似。振幅为 $\\sqrt{A^2+B^2}$。理论稳态振幅为 $A_{\\mathrm{theory}}=|A_{\\mathrm{forcing}}|/|\\omega_0^2-\\Omega^2|$，其中 $\\omega_0=\\sqrt{k/m}$，$A_{\\mathrm{forcing}}$ 是加速度项的振幅。对于此案例，$A_{\\mathrm{theory}} = (1\\,\\mathrm{m/s^2}) / |(2\\,\\mathrm{rad/s})^2 - (1.5\\,\\mathrm{rad/s})^2| = 1/1.75 \\approx 0.571428\\,\\mathrm{m}$。\n\n最终的实现将把这些步骤封装在一个 Python 脚本中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four test cases for a forced simple harmonic oscillator\n    using the velocity Verlet method and computes specified diagnostics.\n    \"\"\"\n\n    def run_simulation(m, k, a_F_func, x0, v0, T, dt):\n        \"\"\"\n        Integrates the equation of motion using the velocity Verlet scheme.\n        \n        Equation: m*d^2x/dt^2 + k*x = -m*a_F(t)\n                  a(t) = -(k/m)*x(t) - a_F(t)\n        \n        Args:\n            m (float): Mass in kg.\n            k (float): Spring stiffness in N/m.\n            a_F_func (callable): Frame acceleration function a_F(t) in m/s^2.\n            x0 (float): Initial position in m.\n            v0 (float): Initial velocity in m/s.\n            T (float): Total simulation time in s.\n            dt (float): Time step in s.\n\n        Returns:\n            tuple: (t, x, v) arrays for time, position, and velocity.\n        \"\"\"\n        N = int(T / dt)\n        \n        t = np.linspace(0, N * dt, N + 1)\n        x = np.zeros(N + 1)\n        v = np.zeros(N + 1)\n        a = np.zeros(N + 1)\n\n        # Initial conditions\n        x[0] = x0\n        v[0] = v0\n        a[0] = -(k / m) * x[0] - a_F_func(t[0])\n\n        # Velocity Verlet integration loop\n        for n in range(N):\n            # 1. Update position\n            x[n+1] = x[n] + v[n] * dt + 0.5 * a[n] * dt**2\n            \n            # 2. Compute acceleration at the new step\n            a[n+1] = -(k / m) * x[n+1] - a_F_func(t[n+1])\n            \n            # 3. Update velocity\n            v[n+1] = v[n] + 0.5 * (a[n] + a[n+1]) * dt\n            \n        return t, x, v\n\n    # --- Test Cases ---\n\n    results = []\n\n    # Case 1: Constant-acceleration frame; steady offset\n    params1 = {'m': 1.0, 'k': 4.0, 'a_F_func': lambda t: 1.0, \n               'x0': 0.0, 'v0': 0.0, 'T': 20.0, 'dt': 0.005}\n    t1, x1, v1 = run_simulation(**params1)\n    N1 = int(params1['T'] / params1['dt'])\n    start_index1 = int(0.8 * N1)\n    x1_end = x1[start_index1:]\n    x_bar_end = np.mean(x1_end)\n    results.append(x_bar_end)\n\n    # Case 2: Inertial frame; energy check\n    params2 = {'m': 1.0, 'k': 9.0, 'a_F_func': lambda t: 0.0, \n               'x0': 0.1, 'v0': 0.0, 'T': 20.0, 'dt': 0.005}\n    t2, x2, v2 = run_simulation(**params2)\n    m2, k2 = params2['m'], params2['k']\n    E = 0.5 * m2 * v2**2 + 0.5 * k2 * x2**2\n    E0 = E[0]\n    Ef = E[-1]\n    if E0 == 0:\n        rel_energy_drift = 0.0\n    else:\n        rel_energy_drift = np.abs(Ef - E0) / E0\n    results.append(rel_energy_drift)\n    \n    # Case 3: Step-acceleration frame; oscillation about shifted equilibrium\n    params3 = {'m': 1.0, 'k': 4.0, 'a_F_func': lambda t: 1.0, # H(t)=1 for t>=0\n               'x0': 0.0, 'v0': 0.0, 'T': 20.0, 'dt': 0.005}\n    t3, x3, v3 = run_simulation(**params3)\n    N3 = int(params3['T'] / params3['dt'])\n    start_index3 = int(0.8 * N3)\n    x3_end = x3[start_index3:]\n    A_pp = 0.5 * (np.max(x3_end) - np.min(x3_end))\n    results.append(A_pp)\n\n    # Case 4: Sinusoidally accelerating frame; off-resonant response\n    A_force = 1.0\n    Omega = 1.5\n    params4 = {'m': 1.0, 'k': 4.0, 'a_F_func': lambda t: A_force * np.sin(Omega * t), \n               'x0': 0.0, 'v0': 0.0, 'T': 60.0, 'dt': 0.005}\n    t4, x4, v4 = run_simulation(**params4)\n    N4 = int(params4['T'] / params4['dt'])\n    start_index4 = int(0.8 * N4)\n    \n    t4_end = t4[start_index4:]\n    x4_end = x4[start_index4:]\n    \n    Tw = params4['T'] * 0.2\n    dt4 = params4['dt']\n\n    # Projections\n    A_proj_sum_term = x4_end * np.sin(Omega * t4_end)\n    B_proj_sum_term = x4_end * np.cos(Omega * t4_end)\n    \n    A_proj = (2.0 / Tw) * np.sum(A_proj_sum_term) * dt4\n    B_proj = (2.0 / Tw) * np.sum(B_proj_sum_term) * dt4\n    \n    freq_response_amp = np.sqrt(A_proj**2 + B_proj**2)\n    results.append(freq_response_amp)\n\n\n    # Final print statement in the exact required format.\n    # Format each number to exactly 6 digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2420174"}, {"introduction": "在选择数值方法时，我们不仅关心其准确性，更要关注其稳定性。一个看似合理的简单算法，有时可能会导致结果出现灾难性的“爆炸”。本练习将带你深入剖析一个数值积分方案的内部机制 [@problem_id:2439910]，通过分析其核心的“放大矩阵” $G$ 来判断其稳定性。你将直观地看到一个不稳定的方法如何导致能量无界增长，并探索如何通过引入一个非物理的“人工阻尼”来抑制这种不稳定性，同时理解这背后关于稳定性、准确性和物理保真度之间的深刻权衡。", "problem": "一个物理上无阻尼的一维质量-弹簧系统由二阶常微分方程(ODE) $m \\ddot{x}(t) + k x(t) = 0$ 控制，其中 $m$ 是质量，$k$ 是弹簧常数。考虑使用状态 $(x,v)$ 的一阶形式，其中 $x$ 是位移，$v$ 是速度：\n- $x'(t) = v(t)$,\n- $v'(t) = -\\frac{k}{m} x(t)$。\n\n所研究的数值格式使用包含一个大小为 $\\gamma \\ge 0$ 的非物理粘性项的线性单步映射来更新离散时间下的状态：\n- $x_{n+1} = x_{n} + h\\, v_{n}$,\n- $v_{n+1} = v_{n} + h\\left(-\\frac{k}{m} x_{n} - \\frac{\\gamma}{m} v_{n}\\right)$,\n其中 $h$ 是时间步长。此更新可以写成矩阵乘法 $\\begin{bmatrix}x_{n+1} \\\\ v_{n+1}\\end{bmatrix} = G \\begin{bmatrix}x_n \\\\ v_n\\end{bmatrix}$，其中\n$$\nG = \\begin{bmatrix}\n1 & h\\\\\n- h\\,\\omega_0^2 & 1 - h\\,\\frac{\\gamma}{m}\n\\end{bmatrix}, \\quad \\omega_0 = \\sqrt{\\frac{k}{m}}.\n$$\n定义谱半径 $\\rho(G)$ 为矩阵 $G$ 的特征值的最大模。定义在步骤 $n$ 的离散机械能为\n$$\nE_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2.\n$$\n真实的无阻尼系统（在连续ODE中 $\\gamma = 0$）能量守恒，因此对于任何物理时间 $T$，$E_{\\text{true}}(T) = E_0$。为了量化由非物理阻尼和时间步进共同引入的建模和离散化误差，定义在最终时间 $T$ 的相对能量误差为\n$$\n\\varepsilon = \\frac{E_N - E_0}{E_0}, \\quad N = \\frac{T}{h},\n$$\n其中 $N$ 是整数步数。\n\n对于下述每个测试用例，您的程序必须计算：\n- 谱半径 $\\rho(G)$，\n- 一个稳定性标志 $s$，如果 $\\rho(G) < 1$ 则等于 $1$，否则等于 $0$，\n- 从初始条件 $x(0) = 1.0$ 和 $v(0) = 0.0$ 开始，将给定更新精确迭代 $N$ 步后，在时间 $T$ 得到的相对能量误差 $\\varepsilon$。\n\n所有参数具有以下物理单位：$m$ 的单位是千克，$k$ 的单位是牛顿/米，$\\gamma$ 的单位是千克/秒，$h$ 和 $T$ 的单位是秒。输出 $\\rho(G)$ 和 $\\varepsilon$ 是无量纲的。\n\n使用以下测试套件，其中每个用例指定 $(m,k,\\gamma,h,T)$：\n- 用例 1: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $0$ $,$ $0.1$ $,$ $10$ $\\,)$。\n- 用例 2: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $0.2$ $,$ $0.1$ $,$ $10$ $\\,)$。\n- 用例 3: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $0$ $,$ $1.0$ $,$ $10$ $\\,)$。\n- 用例 4: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $1.5$ $,$ $1.0$ $,$ $10$ $\\,)$。\n- 用例 5: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $1.0$ $,$ $1.0$ $,$ $10$ $\\,)$。\n\n最终输出格式：\n- 对于每个用例，输出一个列表 $[\\rho, s, \\varepsilon]$，其中 $\\rho$ 和 $\\varepsilon$ 四舍五入到 $6$ 位小数，$s$ 是整数 $0$ 或 $1$。\n- 您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，每个用例一个子列表，顺序与上文相同。例如：$[\\,[\\rho_1,s_1,\\varepsilon_1],[\\rho_2,s_2,\\varepsilon_2],\\dots\\,]$。", "solution": "问题陈述已经过验证，被认为是科学合理的、适定的和客观的。它提出了一个计算物理学中的标准练习，涉及对简谐振子的数值积分格式的分析。该问题是自洽的，提供了所有必要的参数、初始条件和定义。其中没有矛盾、歧义或事实不准确之处。因此，我们可以着手求解。\n\n任务是为每个给定的参数集 $(m, k, \\gamma, h, T)$ 计算三个量：放大矩阵 $G$ 的谱半径 $\\rho(G)$、一个稳定性标志 $s$，以及在持续时间为 $T$ 的模拟后的相对能量误差 $\\varepsilon$。\n\n首先，我们处理谱半径 $\\rho(G)$ 和稳定性标志 $s$ 的计算。数值格式以线性单步映射的形式给出：\n$$\n\\begin{bmatrix}x_{n+1} \\\\ v_{n+1}\\end{bmatrix} = G \\begin{bmatrix}x_n \\\\ v_n\\end{bmatrix}\n$$\n其中 $G$ 是放大矩阵，定义为：\n$$\nG = \\begin{bmatrix}\n1 & h\\\\\n- h\\,\\omega_0^2 & 1 - h\\,\\frac{\\gamma}{m}\n\\end{bmatrix}, \\quad \\omega_0 = \\sqrt{\\frac{k}{m}}\n$$\n这个线性迭代过程的稳定性由 $G$ 的特征值决定。当且仅当谱半径 $\\rho(G)$ 严格小于 $1$ 时，系统是渐近稳定的。谱半径定义为 $G$ 的特征值的绝对值（模）的最大值：\n$$\n\\rho(G) = \\max_i |\\lambda_i|\n$$\n其中 $\\lambda_i$ 是特征方程 $\\det(G - \\lambda I) = 0$ 的解。该方程为：\n$$\n\\lambda^2 - \\text{Tr}(G)\\lambda + \\det(G) = 0\n$$\n其中迹 $\\text{Tr}(G) = 2 - h\\frac{\\gamma}{m}$，行列式 $\\det(G) = 1 - h\\frac{\\gamma}{m} + h^2\\omega_0^2$。然后使用二次公式求出特征值。对于每个测试用例，我们构造矩阵 $G$ 并数值计算其特征值。然后确定谱半径 $\\rho(G)$。根据这个值赋予防稳定性标志 $s$：\n$$\ns = \\begin{cases} 1 & \\text{if } \\rho(G) < 1 \\\\ 0 & \\text{if } \\rho(G) \\ge 1 \\end{cases}\n$$\n\n接下来，我们计算相对能量误差 $\\varepsilon$。在步骤 $n$ 的离散机械能定义为 $E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2$。初始状态给定为 $(x_0, v_0) = (1.0, 0.0)$，所以初始能量是：\n$$\nE_0 = \\frac{1}{2} m (0.0)^2 + \\frac{1}{2} k (1.0)^2 = \\frac{1}{2} k\n$$\n模拟总时间为 $T$，时间步长为 $h$，对应 $N = T/h$ 步。由于更新规则是线性映射，在最终步骤 $N$ 的状态由下式给出：\n$$\n\\begin{bmatrix}x_{N} \\\\ v_{N}\\end{bmatrix} = G^N \\begin{bmatrix}x_0 \\\\ v_0\\end{bmatrix}\n$$\n其中 $G^N$ 是矩阵 $G$ 的 $N$ 次幂。这提供了一种无需执行 $N$ 次迭代的显式循环即可找到最终状态 $(x_N, v_N)$ 的高效方法。计算出最终状态后，最终能量 $E_N$ 的计算方式如下：\n$$\nE_N = \\frac{1}{2} m v_N^2 + \\frac{1}{2} k x_N^2\n$$\n相对能量误差 $\\varepsilon$ 量化了与真实系统能量守恒原理的偏差，其计算方式如下：\n$$\n\\varepsilon = \\frac{E_N - E_0}{E_0}\n$$\n这个量捕捉了前向欧拉格式的离散化误差和人工阻尼项 $\\gamma$ 的建模误差的综合影响。\n\n每个测试用例的总体流程是：首先构造 $G$，计算其特征值以找到 $\\rho(G)$ 和 $s$；然后计算 $G^N$ 以找到最终状态 $(x_N,v_N)$；最后计算能量 $E_N$ 和 $E_0$ 以确定 $\\varepsilon$。然后收集并格式化所要求的输出。", "answer": "```python\n# Full and runnable Python 3 code.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases.\n    For each case, it computes the spectral radius rho(G), a stability flag s,\n    and the relative energy error epsilon.\n    \"\"\"\n    test_cases = [\n        # (m, k, gamma, h, T)\n        (1.0, 1.0, 0.0, 0.1, 10.0),\n        (1.0, 1.0, 0.2, 0.1, 10.0),\n        (1.0, 1.0, 0.0, 1.0, 10.0),\n        (1.0, 1.0, 1.5, 1.0, 10.0),\n        (1.0, 1.0, 1.0, 1.0, 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, gamma, h, T = case\n        \n        # 1. Compute spectral radius and stability flag\n        omega0_sq = k / m\n        G = np.array([\n            [1.0, h],\n            [-h * omega0_sq, 1.0 - h * gamma / m]\n        ], dtype=np.float64)\n        \n        eigenvalues = np.linalg.eigvals(G)\n        rho = np.max(np.abs(eigenvalues))\n        s = 1 if rho  1.0 else 0\n        \n        # 2. Compute relative energy error\n        x0 = 1.0\n        v0 = 0.0\n        \n        E0 = 0.5 * m * v0**2 + 0.5 * k * x0**2\n        \n        # Ensure N is an integer, handling potential float inaccuracies\n        N = int(round(T / h))\n        \n        state_initial = np.array([x0, v0], dtype=np.float64)\n\n        if N == 0:\n            state_final = state_initial\n        else:\n            # Efficiently compute G^N * state_initial\n            G_N = np.linalg.matrix_power(G, N)\n            state_final = G_N @ state_initial\n        \n        xN, vN = state_final[0], state_final[1]\n        \n        EN = 0.5 * m * vN**2 + 0.5 * k * xN**2\n        \n        # Avoid division by zero if E0 is 0\n        if E0 == 0:\n            eps = 0.0 if EN == 0 else float('inf')\n        else:\n            eps = (EN - E0) / E0\n            \n        # 3. Format results as specified\n        rho_rounded = round(rho, 6)\n        eps_rounded = round(eps, 6)\n        \n        results.append(f\"[{rho_rounded},{s},{eps_rounded}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2439910"}]}