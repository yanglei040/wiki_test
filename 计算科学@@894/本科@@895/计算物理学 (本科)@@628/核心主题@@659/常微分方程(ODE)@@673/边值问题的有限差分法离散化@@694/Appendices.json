{"hands_on_practices": [{"introduction": "我们从一个基础的一维边值问题开始。本练习超越了基本的离散化，引入了理查森外推法 (Richardson extrapolation) 这一强大的技术来提高数值解的精度。通过结合两种不同网格分辨率的结果，你将学习如何系统地减小截断误差，从而在不改变底层有限差分格式的情况下获得更高阶的精度 [@problem_id:2392773]。", "problem": "考虑单位区间上的两点边值问题：求一个函数 $u(x)$，使得\n$$\nu''(x) = -\\sin(\\pi x), \\quad x \\in (0,1), \\qquad u(0)=0,\\quad u(1)=0,\n$$\n其中 $\\sin(\\cdot)$ 函数使用弧度制。设 $n$ 为 $[0,1]$ 上均匀网格的内部网格点数，其网格间距为 $h = \\frac{1}{n+1}$，节点为 $x_i = i h$，$i=0,1,\\ldots,n+1$。在此网格上，使用标准的二阶中心有限差分来近似 $u''(x)$，精确施加 Dirichlet 边值条件 $u(0)=0$ 和 $u(1)=0$，然后求解得到的关于内部未知数的线性系统。\n\n接下来，通过将网格间距减半来加密网格（即，使用一个有 $m = 2n+1$ 个内部点的网格，这样加密后的间距为 $h/2$，并且加密后的内部节点与粗网格的节点重合）。在加密后的网格上求解相同的离散问题。假设主截断误差与 $h^2$ 成正比，使用 Richardson 外推法将两个数值解结合起来，以在粗网格内部节点上获得一个更高精度的近似解。\n\n使用精确解析解 $u_{\\text{exact}}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$ 来量化精度。对于下面指定的每个测试用例，计算在粗网格内部节点上求值的 Richardson 外推解的最大绝对误差，即：\n$$\nE_\\infty = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - \\frac{\\sin(\\pi x_i)}{\\pi^2} \\right|.\n$$\n\n测试套件：\n- 用例 1：$n=1$。\n- 用例 2：$n=4$。\n- 用例 3：$n=10$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含上述用例的三个结果 $E_\\infty$，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如，$ [e_1,e_2,e_3] $）。每个 $e_k$ 都必须是一个实数（一个浮点值）。不应打印任何额外文本。", "solution": "所给出的问题是微分方程领域中一个适定的两点边值问题 (BVP)。它具有科学依据，并包含了获得唯一数值解所需的所有信息。所提出的方法，即采用有限差分和 Richardson 外推法，是计算物理学中的一种标准且有效的技术。因此，该问题是有效的，并将给出解答。\n\n该问题是要求解一个函数 $u(x)$，使其满足以下二阶常微分方程和边值条件：\n$$\nu''(x) = -\\sin(\\pi x), \\quad x \\in (0,1)\n$$\n$$\nu(0)=0, \\quad u(1)=0\n$$\n其解析解为 $u_{\\text{exact}}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$，这可以通过直接求导和代入进行验证。\n\n第一步是使用均匀网格对区域 $[0,1]$ 进行离散化。对于给定的整数 $n$，我们定义 $n$ 个内部网格点。网格间距为 $h = \\frac{1}{n+1}$，网格节点为 $x_i = ih$，$i=0, 1, \\ldots, n+1$。在这些节点上的解值记为 $u_i = u(x_i)$。边值条件规定了 $u_0 = 0$ 和 $u_{n+1} = 0$。我们旨在求出未知值 $u_i$，$i=1, 2, \\ldots, n$。\n\n在内部节点 $x_i$ 处的二阶导数 $u''(x)$ 可用二阶精度的中心有限差分公式来近似：\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n将此近似式代入原始微分方程，可得到关于未知数 $u_i$ 的代数方程组：\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = -\\sin(\\pi x_i), \\quad \\text{for } i = 1, 2, \\ldots, n\n$$\n重新整理此方程，我们得到：\n$$\nu_{i-1} - 2u_i + u_{i+1} = -h^2 \\sin(\\pi x_i)\n$$\n结合边值条件（$u_0=0$ 和 $u_{n+1}=0$），我们可以写出第一个和最后一个内部节点的方程：\n对于 $i=1$：$u_0 - 2u_1 + u_2 = -h^2 \\sin(\\pi x_1) \\implies -2u_1 + u_2 = -h^2 \\sin(\\pi x_1)$。\n对于 $i=n$：$u_{n-1} - 2u_n + u_{n+1} = -h^2 \\sin(\\pi x_n) \\implies u_{n-1} - 2u_n = -h^2 \\sin(\\pi x_n)$。\n\n这 $n$ 个方程构成一个形如 $A \\mathbf{u} = \\mathbf{b}$ 的线性方程组，其中 $\\mathbf{u} = [u_1, u_2, \\ldots, u_n]^T$ 是内部节点上未知解值的向量。矩阵 $A$ 是一个 $n \\times n$ 的对称三对角矩阵，向量 $\\mathbf{b}$ 是右端项。\n$$\nA = \\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 \\\\\n1 & -2 & 1 & \\cdots & 0 \\\\\n0 & 1 & -2 & \\ddots & \\vdots \\\\\n\\vdots & \\vdots & \\ddots & -2 & 1 \\\\\n0 & 0 & \\cdots & 1 & -2\n\\end{pmatrix}, \\quad \\mathbf{b} = -h^2 \\begin{pmatrix}\n\\sin(\\pi x_1) \\\\\n\\sin(\\pi x_2) \\\\\n\\vdots \\\\\n\\sin(\\pi x_n)\n\\end{pmatrix}\n$$\n该线性系统是对角占优的，因此有唯一解，可以使用标准的数值线性代数方法求解。\n\n题目要求使用 Richardson 外推法来提高解的精度。中心差分格式的全局误差有一个关于 $h$ 的偶数次幂的渐近展开式：\n$$\nu_h(x) = u_{\\text{exact}}(x) + C_1(x)h^2 + C_2(x)h^4 + \\dots\n$$\n其中 $u_h(x)$ 是在网格间距为 $h$ 时计算得到的点 $x$ 处的数值解。\n\n我们计算两个数值解：\n1. 粗网格解 $\\mathbf{u}_h$，在具有 $n$ 个内部点、间距为 $h = \\frac{1}{n+1}$ 的网格上计算。\n2. 细网格解 $\\mathbf{u}_{h/2}$，在具有 $m = 2n+1$ 个内部点、间距为 $h/2 = \\frac{1}{m+1}$ 的网格上计算。\n\n在一个粗网格节点 $x_i$ 上，我们有关于精确解 $u_{\\text{exact}}(x_i)$ 的以下近似：\n$$\nu_h(x_i) \\approx u_{\\text{exact}}(x_i) + C_1(x_i)h^2\n$$\n$$\nu_{h/2}(x_i) \\approx u_{\\text{exact}}(x_i) + C_1(x_i)(h/2)^2 = u_{\\text{exact}}(x_i) + \\frac{1}{4}C_1(x_i)h^2\n$$\n我们可以通过代数组合这两个表达式来消去主误差项 $C_1(x_i)h^2$。将第二个方程乘以 4，再减去第一个方程，得到：\n$$\n4u_{h/2}(x_i) - u_h(x_i) \\approx 3u_{\\text{exact}}(x_i)\n$$\n这就得到了 Richardson 外推解 $u_{\\text{RE}}(x_i)$，其误差阶为 $O(h^4)$：\n$$\nu_{\\text{RE}}(x_i) = \\frac{4u_{h/2}(x_i) - u_h(x_i)}{3}\n$$\n对粗网格上的每个节点 $x_i$（$i = 1, \\ldots, n$）都执行此外推。注意，粗网格节点 $\\{x_i\\}$ 是细网格节点的一个子集。具体来说，粗网格节点 $x_i = i h$ 对应于位置相同的细网格节点，即细网格上的第 $(2i)$ 个内部节点。\n\n最后一步是量化外推解的精度。对于每个测试用例，我们计算在粗网格内部点上的最大绝对误差 $E_\\infty$：\n$$\nE_\\infty = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - u_{\\text{exact}}(x_i) \\right| = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - \\frac{\\sin(\\pi x_i)}{\\pi^2} \\right|\n$$\n对每个测试值 $n$，计算步骤如下：\n1.  求解具有 $n$ 个内部点的粗网格上的 BVP，得到 $\\mathbf{u}_h$。\n2.  求解具有 $m=2n+1$ 个内部点的细网格上的 BVP，得到 $\\mathbf{u}_{h/2}$。\n3.  从 $\\mathbf{u}_{h/2}$ 中提取与粗网格位置对应的值。\n4.  计算 Richardson 外推解向量 $\\mathbf{u}_{\\text{RE}}$。\n5.  计算在粗网格点上的精确解。\n6.  计算最大绝对误差 $E_\\infty$。\n\n该过程将针对指定的测试用例进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(n):\n    \"\"\"\n    Solves the BVP u''(x) = -sin(pi*x) on [0,1] with u(0)=u(1)=0\n    using a centered finite difference scheme with n interior points.\n\n    Args:\n        n (int): The number of interior grid points.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The solution vector u at the interior points.\n            - np.ndarray: The x-coordinates of the interior points.\n    \"\"\"\n    if n == 0:\n        return np.array([]), np.array([])\n    \n    # Grid spacing\n    h = 1.0 / (n + 1)\n    \n    # Interior grid points\n    x_interior = np.linspace(h, 1.0 - h, n)\n    \n    # Construct the right-hand side vector b\n    b = -h**2 * np.sin(np.pi * x_interior)\n    \n    # Construct the tridiagonal matrix A\n    A = np.diag(-2 * np.ones(n)) + np.diag(np.ones(n - 1), k=1) + np.diag(np.ones(n - 1), k=-1)\n    \n    # Solve the linear system Au = b\n    u = np.linalg.solve(A, b)\n    \n    return u, x_interior\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for all test cases and print the result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 4, 10]\n\n    results = []\n    for n in test_cases:\n        # 1. Solve on coarse mesh\n        u_coarse, x_coarse = solve_bvp(n)\n        \n        # 2. Solve on fine mesh\n        m = 2 * n + 1\n        u_fine, _ = solve_bvp(m)\n        \n        # 3. Extract fine solution at coarse grid points\n        # The coarse grid points correspond to every second point of the fine grid's interior.\n        # Python indices are 0-based. The i-th coarse point (i=0 to n-1) is at the same\n        # spatial location as the (2i+1)-th fine point (index 2i+1).\n        # This corresponds to slicing u_fine with [1::2].\n        u_fine_at_coarse_points = u_fine[1::2]\n\n        # 4. Apply Richardson extrapolation\n        # u_RE = (4 * u_h/2 - u_h) / 3\n        u_re = (4.0 * u_fine_at_coarse_points - u_coarse) / 3.0\n        \n        # 5. Compute exact solution at coarse grid points\n        u_exact = np.sin(np.pi * x_coarse) / (np.pi**2)\n        \n        # 6. Calculate the maximum absolute error\n        max_error = np.max(np.abs(u_re - u_exact))\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2392773"}, {"introduction": "在一维概念的基础上，本练习将带你进入二维世界，求解经典的拉普拉斯方程，该方程控制着静电势等物理现象。你将着手处理二维区域的离散化，构建相应的五点差分格式，并管理由此产生的大型稀疏线性系统。这项练习是将在更高维度上应用有限差分方法解决广泛物理问题的基础 [@problem_id:2392730]。", "problem": "考虑一个方形区域内的静电势场，该区域在没有自由电荷的情况下由静电学规律控制。其基本原理是，在静电学中，电场满足 $ \\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0 $ 且 $ \\mathbf{E} = -\\nabla \\phi $。对于一个 $ \\rho = 0 $（无自由电荷）的区域，电势 $ \\phi(x,y) $ 满足二维拉普拉斯方程 $ \\nabla^2 \\phi = 0 $，并带有狄利克雷边界条件（即在边界上电势为固定值）。您需要使用有限差分法 (FDM) 和二阶中心差分来离散化此边值问题，从而获得一个关于内部网格点值的线性系统，并对其进行数值求解。\n\n一个边长为 $ L $ (单位：米) 的方形盒子，其右侧壁 (位于 $ x = L $) 保持在固定电势 $ V_0 $ (单位：伏特)，而其他三面壁 (位于 $ x = 0 $、$ y = 0 $ 和 $ y = L $) 接地，电势为 $ 0 $ 伏特。使用一个每方向包含 $ N $ 个网格点的均匀网格（包括边界），因此网格间距为 $ h = L / (N-1) $。令 $ \\phi_{i,j} $ 表示网格点 $ (x_i, y_j) = (i h, j h) $ 处的离散电势，其中 $ i, j \\in \\{0, 1, \\dots, N-1\\} $。内部未知量是那些 $ i, j \\in \\{1, 2, \\dots, N-2\\} $ 的值。使用二阶中心差分来近似 $ \\nabla^2 \\phi $，为内部值 $ \\phi_{i,j} $ 建立得到的线性系统，施加四面壁上的狄利克雷边界条件，并求解电势。\n\n您的程序必须：\n- 构建与均匀网格上的二阶中心差分近似相对应的五点模板离散拉普拉斯算子。\n- 根据狄利克雷边界条件，将边界值一致地整合到右手边，其中位于 $ x=L $ 的右侧壁电势为 $ \\phi = V_0 $，其他三面壁的电势为 $ \\phi = 0 $。\n- 求解关于内部未知量的线性系统。\n- 提取并报告几何中心 $ (x,y) = (L/2, L/2) $ 处的电势。假设 $ N $ 为奇数，以使几何中心与一个网格点重合。以伏特为单位报告中心点的值。\n\n物理单位：电势必须以伏特为单位报告，表示为四舍五入到六位小数的十进制浮点数。\n\n角度单位：不涉及角度。\n\n您的程序应使用以下测试套件，每个测试用例指定为一个元组 $ (L, N, V_0) $，其中 $ L $ 的单位是米，$ V_0 $ 的单位是伏特：\n- 测试 $ 1 $：$ (L, N, V_0) = (1.0, 3, 1.0) $\n- 测试 $ 2 $：$ (L, N, V_0) = (1.0, 5, 1.0) $\n- 测试 $ 3 $：$ (L, N, V_0) = (1.0, 21, 2.0) $\n\n对于每个测试，计算一个浮点数：几何中心处的 $ \\phi $值（以伏特为单位），四舍五入到六位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按上述测试顺序排列。例如，格式必须与 $ [r_1,r_2,r_3] $ 完全一样，其中每个 $ r_k $ 是一个小数点后有六位的十进制浮点数。", "solution": "所给出的问题是静电学中一个经典的边值问题，具体是在具有指定狄利克雷边界条件的方形域中求解二维拉普拉斯方程。该问题具有科学依据，是适定的，并包含了数值求解所需的所有必要信息。因此，该问题被视为有效。\n\n在无电荷区域 ($\\rho=0$) 中，静电势 $\\phi(x,y)$ 的控制偏微分方程是拉普拉斯方程：\n$$\n\\nabla^2 \\phi(x,y) = \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} = 0\n$$\n求解域是一个边长为 $L$ 的正方形，由 $x \\in [0, L]$ 和 $y \\in [0, L]$ 定义。边界条件为狄利克雷类型，意味着电势在边界上是固定的：\n- $\\phi(x,0) = 0$ (底壁)\n- $\\phi(x,L) = 0$ (顶壁)\n- $\\phi(0,y) = 0$ (左壁)\n- $\\phi(L,y) = V_0$ (右壁)\n\n为对此问题进行数值求解，我们采用有限差分法 (FDM)。首先，将连续域离散化为一系列均匀的网格点 $(x_i, y_j)$，其中 $x_i = i h$，$y_j = j h$。网格间距 $h$由 $h = L / (N-1)$ 给出，其中 $N$ 是每个方向上的网格点数。网格索引 $i$ 和 $j$ 的范围是从 $0$ 到 $N-1$。网格点 $(x_i, y_j)$ 处的电势记为 $\\phi_{i,j}$。\n\n二阶偏导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{h^2}\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial y^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{h^2}\n$$\n将这些近似代入每个内部网格点（其中 $i, j \\in \\{1, 2, \\dots, N-2\\}$）的拉普拉斯方程，得到：\n$$\n\\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{h^2} + \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{h^2} = 0\n$$\n两边乘以 $h^2$ 并重新整理各项，得到五点模板方程。该方程表明，一个内部点的电势是其四个最近邻点电势的平均值：\n$$\n4\\phi_{i,j} - \\phi_{i+1,j} - \\phi_{i-1,j} - \\phi_{i,j+1} - \\phi_{i,j-1} = 0\n$$\n这个方程必须对所有 $M = (N-2)^2$ 个内部点都成立。这组方程构成了一个形如 $A\\vec{\\Phi} = \\vec{b}$ 的线性方程组，其中 $\\vec{\\Phi}$ 是一个包含内部点未知电势 $\\phi_{i,j}$ 的向量。\n\n为了构建该系统，我们必须将二维的未知数网格展平为一维向量 $\\vec{\\Phi}$。这需要一个一致的映射。我们使用列主序，其中未知数 $\\phi_{i,j}$ (此处 $i, j \\in \\{1, \\dots, N-2\\}$) 的索引 $k$ 由 $k = (i-1)(N-2) + (j-1)$ 给出。\n\n矩阵 $A$ 是一个 $M \\times M$ 的矩阵，表示未知电势的系数。大小为 $M$ 的向量 $\\vec{b}$ 包含由已知边界值产生的项。对于一个内部点 $(i,j)$，方程被重新整理为：\n$$\n4\\phi_{i,j} - \\phi_{i-1,j} - \\phi_{i+1,j} - \\phi_{i,j-1} - \\phi_{i,j-1} = b_{i,j}\n$$\n当一个相邻点 $(i', j')$ 位于边界上时，其电势 $\\phi_{i',j'}$ 是已知的。该项被移到方程的右边。\n- 对于邻近左壁的点 ($i=1$)，$\\phi_{0,j}=0$ 项是已知的。\n- 对于邻近底壁的点 ($j=1$)，$\\phi_{i,0}=0$ 项是已知的。\n- 对于邻近顶壁的点 ($j=N-2$)，$\\phi_{i,N-1}=0$ 项是已知的。\n这些零电势边界对右手边的向量 $\\vec{b}$ 没有贡献。\n- 对于邻近右壁的点 ($i=N-2$)，$\\phi_{N-1,j}=V_0$ 项是已知的。对于这样的点，方程变为 $4\\phi_{N-2,j} - \\phi_{N-3,j} - \\phi_{N-2,j-1} - \\phi_{N-2,j+1} = V_0$。\n\n因此，向量 $\\vec{b}$ 的分量在所有点上都为零，除了那些邻近右壁（其中 $i = N-2$）的点，其值为 $V_0$。矩阵 $A$ 具有稀疏的块三对角结构，主对角线上为 $4$，在某些对应于网格中相邻点的非对角线上为 $-1$。\n\n一旦矩阵 $A$ 和向量 $\\vec{b}$ 构建完成，就求解线性系统 $A\\vec{\\Phi} = \\vec{b}$ 以得到未知电势的向量 $\\vec{\\Phi}$。\n\n最后一步是提取方形域几何中心 $(L/2, L/2)$ 处的电势。由于指定 $N$ 是奇数，中心点与一个网格点 $(x_{i_c}, y_{j_c})$ 重合，其索引为 $i_c = j_c = (N-1)/2$。对于 $N \\ge 3$，这些索引落在内部点的范围 $\\{1, \\dots, N-2\\}$ 内。该点的电势是解向量 $\\vec{\\Phi}$ 的一个元素，可以使用相同的索引映射来定位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_laplace(L, N, V0):\n    \"\"\"\n    Solves the 2D Laplace equation on a square grid using the Finite Difference Method.\n\n    Args:\n        L (float): Side length of the square domain in meters.\n        N (int): Number of grid points in each direction.\n        V0 (float): Potential on the right wall in volts.\n\n    Returns:\n        float: The potential at the geometric center of the grid.\n    \"\"\"\n    # Number of interior grid points in one dimension.\n    N_int = N - 2\n\n    # If N <= 2, there are no interior points to solve for.\n    if N_int <= 0:\n        # A grid with N=1 or N=2 has no interior. The problem statement implies N>=3.\n        # For N=3, the center is the only interior point. Its value can be calculated\n        # as V0/4. A general solution is implemented anyway.\n        if N == 1: # A single point can't have these conflicting BCs.\n           return 0.0\n        return 0.0\n\n    # Total number of unknown interior potentials.\n    M = N_int * N_int\n\n    # Initialize the matrix A and vector b for the linear system A*phi = b.\n    A = np.zeros((M, M))\n    b = np.zeros(M)\n\n    # Function to map 2D interior grid indices (ii, jj) to a 1D vector index k.\n    # We use 0-indexed interior indices: ii, jj in [0, N_int-1].\n    # These correspond to original grid indices i=ii+1, j=jj+1.\n    # The mapping is column-major for consistency with (x,y) -> (i,j).\n    map_k = lambda ii, jj: ii * N_int + jj\n\n    for ii in range(N_int):  # Corresponds to x-direction grid index i = ii + 1\n        for jj in range(N_int):  # Corresponds to y-direction grid index j = jj + 1\n            k = map_k(ii, jj)\n\n            # The discrete Laplace equation is:\n            # 4*phi_i,j - phi_i-1,j - phi_i+1,j - phi_i,j-1 - phi_i,j+1 = 0\n            # We move known boundary values to the right-hand side (vector b).\n\n            # Main diagonal from the term 4*phi_i,j\n            A[k, k] = 4\n\n            # Neighbor in negative x-direction (i-1, j)\n            if ii > 0:  # Neighbor is an interior point\n                A[k, map_k(ii - 1, jj)] = -1\n            else:  # Neighbor is on the boundary x=0 (i=0), where phi=0\n                b[k] += 0.0\n\n            # Neighbor in positive x-direction (i+1, j)\n            if ii < N_int - 1:  # Neighbor is an interior point\n                A[k, map_k(ii + 1, jj)] = -1\n            else:  # Neighbor is on the boundary x=L (i=N-1), where phi=V0\n                b[k] += V0\n\n            # Neighbor in negative y-direction (i, j-1)\n            if jj > 0:  # Neighbor is an interior point\n                A[k, map_k(ii, jj - 1)] = -1\n            else:  # Neighbor is on the boundary y=0 (j=0), where phi=0\n                b[k] += 0.0\n\n            # Neighbor in positive y-direction (i, j+1)\n            if jj < N_int - 1:  # Neighbor is an interior point\n                A[k, map_k(ii, jj + 1)] = -1\n            else:  # Neighbor is on the boundary y=L (j=N-1), where phi=0\n                b[k] += 0.0\n    \n    # Solve the linear system for the unknown interior potentials.\n    phi_sol = np.linalg.solve(A, b)\n\n    # Find the potential at the geometric center.\n    # Since N is odd, the center (L/2, L/2) is a grid point.\n    center_grid_idx = (N - 1) // 2\n    \n    # Convert grid index to 0-indexed interior index.\n    ii_center = center_grid_idx - 1\n    jj_center = center_grid_idx - 1\n    \n    # Get the 1D vector index for the center point.\n    k_center = map_k(ii_center, jj_center)\n\n    return phi_sol[k_center]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 3, 1.0),\n        (1.0, 5, 1.0),\n        (1.0, 21, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, V0 = case\n        center_potential = solve_laplace(L, N, V0)\n        # Round the result to six decimal places as required.\n        results.append(f\"{center_potential:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2392730"}, {"introduction": "这项综合性练习将挑战你从解决特定问题转向设计一个通用且稳健的计算工具。你将为一个广泛的一维边值问题类别实现一个通用求解器，处理可变系数和多种类型的边界条件（狄利克雷、诺伊曼和罗宾）。此练习强调代码抽象和稳健实现，这是任何计算科学家都应具备的关键技能 [@problem_id:2392775]。", "problem": "您需要设计并实现一个通用有限差分求解器，用于求解闭区间上的线性、二阶、自伴随边值问题。控制方程为守恒形式的稳态一维线性微分方程：\n$$\n- \\frac{d}{dx}\\!\\left(p(x)\\,\\frac{du}{dx}\\right) + q(x)\\,u(x) = r(x), \\quad x \\in [a,b].\n$$\n函数 $u(x)$ 是未知的，而 $p(x)$、$q(x)$ 和 $r(x)$ 是已知函数，且在 $[a,b]$ 上有 $p(x) \\gt 0$。您必须支持在 $x=a$ 和 $x=b$ 两端的以下类型的边界条件：\n- 狄利克雷 (Dirichlet)：$u = \\text{value}$，\n- 诺伊曼 (Neumann)：$u' = \\text{value}$，\n- 罗宾 (Robin)：$\\alpha\\,u + \\beta\\,u' = \\gamma$，其中 $\\alpha$、$\\beta$ 和 $\\gamma$ 是给定常数。\n\n您的任务是：\n- 基于通量差分，使用 $p(x)$ 的中点取值和梯度的中心差分，推导出内部算子的稳定二阶精度有限差分格式。\n- 推导适用于诺伊曼和罗宾边界条件的 $u'(a)$ 和 $u'(b)$ 的二阶精度单侧边界格式。\n- 实现一个求解器，它接受 $p(x)$、$q(x)$ 和 $r(x)$ 的任意 Python 可调用对象；实数 $a$、$b$；一个指定均匀网格子区间数量的整数 $N \\ge 2$；以及两端的边界条件规范，并返回网格点和数值解向量。\n\n您可以用于推导的基本原理：\n- 导数作为差商极限的定义以及标准泰勒展开。\n- 将守恒算子 $-\\frac{d}{dx}(p\\,u')$ 解释为通量的负散度。\n- 从泰勒级数推导出的广泛使用的中心和单侧有限差分公式。\n\n您的程序必须在以下四个测试用例上验证求解器，每个用例都在一个包含 $N$ 个子区间、步长为 $h = (b-a)/N$ 的均匀网格上进行，并且必须计算网格上与所提供的各用例解析解相比的最大绝对误差。\n\n测试套件：\n- 案例 1 (狄利克雷–狄利克雷，常数 $p$，无反应项):\n  - 区域：$[a,b] = [0,1]$，选择 $N = 200$。\n  - 系数：$p(x) = 1$, $q(x) = 0$, $r(x) = \\sin(\\pi x)$。\n  - 边界条件：$u(0) = 0$, $u(1) = 0$。\n  - 解析解：$u_\\text{exact}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$。\n- 案例 2 (狄利克雷–诺伊曼，常数 $p$，正反应项):\n  - 区域：$[a,b] = [0,1]$，选择 $N = 200$。\n  - 系数：$p(x) = 1$, $q(x) = 1$, $r(x) = 0$。\n  - 边界条件：$u(0) = e^0 = 1$, $u'(1) = e^1$。\n  - 解析解：$u_\\text{exact}(x) = e^x$。\n- 案例 3 (罗宾–罗宾，可变 $p$ 和 $q$):\n  - 区域：$[a,b] = [0,1]$，选择 $N = 200$。\n  - 系数：$p(x) = 1 + x$, $q(x) = x^2$, $r(x) = 1 + 4x + x^3 - x^4$。\n  - $x=0$ 处的边界条件：$\\alpha_L = 2$, $\\beta_L = 1$, $\\gamma_L = 1$；$x=1$ 处的边界条件：$\\alpha_R = 3$, $\\beta_R = -1$, $\\gamma_R = 1$。\n  - 解析解：$u_\\text{exact}(x) = x(1-x)$。\n- 案例 4 (诺伊曼–诺伊曼，常系数且严格正反应项以确保唯一性):\n  - 区域：$[a,b] = [0,1]$，选择 $N = 80$。\n  - 系数：$p(x) = 2$, $q(x) = 5$, $r(x) = 7 \\cos(x)$。\n  - 边界条件：$u'(0) = 0$, $u'(1) = -\\sin(1)$。\n  - 解析解：$u_\\text{exact}(x) = \\cos(x)$。\n\n数值要求和输出：\n- 使用具有 $N$ 个子区间和 $N+1$ 个节点的均匀网格，并使用中点取值 $p(x_i \\pm h/2)$ 来近似半节点处的 $p$。\n- 对于内部节点 $x_i$，$i \\in \\{1,2,\\dots,N-1\\}$，使用通量差分离散化守恒形式，以获得一个三对角矩阵的贡献部分。\n- 对于诺伊曼和罗宾边界条件，使用二阶单侧近似公式：\n  - 左导数：$u'(a) \\approx \\dfrac{-3u_0 + 4u_1 - u_2}{2h}$，\n  - 右导数：$u'(b) \\approx \\dfrac{3u_N - 4u_{N-1} + u_{N-2}}{2h}$。\n- 您的程序必须为每个用例计算所有网格节点上的最大绝对误差，然后生成单行输出，其中包含一个按用例1到4的顺序排列、用方括号括起来的逗号分隔的四个误差列表。将每个误差表示为浮点数。为保持一致性，打印前将每个误差四舍五入到八位小数。", "solution": "所给出的问题是一个线性、二阶、自伴随常微分方程，是 Sturm-Liouville 问题的一种形式，定义在具有指定边界条件的闭区间 $[a, b]$ 上。控制方程为：\n$$\n- \\frac{d}{dx}\\!\\left(p(x)\\,\\frac{du}{dx}\\right) + q(x)\\,u(x) = r(x)\n$$\n其中 $p(x) > 0$。我们的任务是为这个边值问题 (BVP) 开发一个二阶精度的有限差分求解器。推导过程如下。\n\n首先，我们建立一个均匀的计算网格。将区域 $[a, b]$ 离散化为 $N$ 个等宽的子区间，宽度为 $h = (b-a)/N$。这会产生 $N+1$ 个网格点（或节点），索引从 $i=0$ 到 $i=N$，其位置为 $x_i = a + i h$。我们的目标是确定未知函数 $u(x)$ 在这些节点上的近似值，记为 $u_i \\approx u(x_i)$。\n\n该方法的核心是在网格的内部节点（即 $i \\in \\{1, 2, \\dots, N-1\\}$）处对微分算子进行离散化。该算子以守恒形式给出，这表明可以基于通量 $F(x) = -p(x) \\frac{du}{dx}$ 进行离散化。该微分方程可以写成 $-\\frac{dF}{dx} + q(x)u(x) = r(x)$。\n\n在内部节点 $x_i$ 处，我们使用在网格单元中点 $x_{i \\pm 1/2} = x_i \\pm h/2$ 处计算的通量的中心差分来近似 $-\\frac{dF}{dx}$ 项：\n$$\n\\left. -\\frac{dF}{dx} \\right|_{x_i} \\approx -\\frac{F(x_{i+1/2}) - F(x_{i-1/2})}{h}\n$$\n这是一个二阶精度的近似。通量 $F$ 本身必须在这些中点处进行近似。我们对以中点为中心的导数 $\\frac{du}{dx}$ 使用中心差分：\n$$\n\\left. \\frac{du}{dx} \\right|_{x_{i+1/2}} \\approx \\frac{u(x_{i+1}) - u(x_i)}{h} = \\frac{u_{i+1} - u_i}{h}\n$$\n$$\n\\left. \\frac{du}{dx} \\right|_{x_{i-1/2}} \\approx \\frac{u(x_i) - u(x_{i-1})}{h} = \\frac{u_i - u_{i-1}}{h}\n$$\n问题规定系数 $p(x)$ 在中点 $p_{i \\pm 1/2} = p(x_{i \\pm 1/2})$ 处取值。因此，通量可近似为：\n$$\nF_{i+1/2} \\approx -p_{i+1/2} \\frac{u_{i+1} - u_i}{h}\n$$\n$$\nF_{i-1/2} \\approx -p_{i-1/2} \\frac{u_i - u_{i-1}}{h}\n$$\n将这些通量近似值代入 $-\\frac{dF}{dx}$ 的方程中，得到：\n$$\n\\left. -\\frac{dF}{dx} \\right|_{x_i} \\approx -\\frac{1}{h} \\left( -p_{i+1/2} \\frac{u_{i+1} - u_i}{h} - \\left(-p_{i-1/2} \\frac{u_i - u_{i-1}}{h}\\right) \\right) = \\frac{1}{h^2} \\left( p_{i+1/2}(u_{i+1} - u_i) - p_{i-1/2}(u_i - u_{i-1}) \\right)\n$$\n将此结果与控制方程中在 $x_i$ 处取值的其他项重新组合，我们得到内部节点的完整离散方程：\n$$\n\\frac{1}{h^2} \\left[ -p_{i-1/2} u_{i-1} + (p_{i-1/2} + p_{i+1/2}) u_i - p_{i+1/2} u_{i+1} \\right] + q(x_i) u_i = r(x_i)\n$$\n通过合并与 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 相关的项，我们得到第 $i$ 行的线性代数方程：\n$$\n\\left( -\\frac{p_{i-1/2}}{h^2} \\right) u_{i-1} + \\left( \\frac{p_{i-1/2} + p_{i+1/2}}{h^2} + q_i \\right) u_i + \\left( -\\frac{p_{i+1/2}}{h^2} \\right) u_{i+1} = r_i\n$$\n其中 $q_i = q(x_i)$ 且 $r_i = r(x_i)$。这为 $N+1$ 个未知数 $\\{u_0, u_1, \\dots, u_N\\}$ 提供了 $N-1$ 个方程。剩下的两个方程由 $x_0=a$ 和 $x_N=b$ 处的边界条件推导得出。\n\n现在我们构建边界节点（$i=0$ 和 $i=N$）的方程。\n\n**左边界 $x_0 = a$ (第 0 行):**\n- **狄利克雷 (Dirichlet) 条件：** $u(a) = \\gamma_L$。\n  此条件直接实现为 $u_0 = \\gamma_L$。第一个方程是 $1 \\cdot u_0 = \\gamma_L$。\n- **诺伊曼 (Neumann) 条件：** $u'(a) = \\gamma_L$。\n  我们使用所提供的二阶精度单侧向前差分公式：\n  $$u'(a) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h} = \\gamma_L$$\n  这得出了线性方程：$-3u_0 + 4u_1 - u_2 = 2h\\gamma_L$。\n- **罗宾 (Robin) 条件：** $\\alpha_L u(a) + \\beta_L u'(a) = \\gamma_L$。\n  将相同的单侧公式代入 $u'(a)$：\n  $$\\alpha_L u_0 + \\beta_L \\left(\\frac{-3u_0 + 4u_1 - u_2}{2h}\\right) = \\gamma_L$$\n  两边乘以 $2h$ 并分组各项，得到方程：\n  $$(2h\\alpha_L - 3\\beta_L)u_0 + (4\\beta_L)u_1 - \\beta_L u_2 = 2h\\gamma_L$$\n\n**右边界 $x_N = b$ (第 N 行):**\n- **狄利克雷 (Dirichlet) 条件：** $u(b) = \\gamma_R$。\n  这简单地表示为 $u_N = \\gamma_R$。最后一个方程是 $1 \\cdot u_N = \\gamma_R$。\n- **诺伊曼 (Neumann) 条件：** $u'(b) = \\gamma_R$。\n  我们使用所提供的二阶精度单侧向后差分公式：\n  $$u'(b) \\approx \\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h} = \\gamma_R$$\n  这得出了线性方程：$u_{N-2} - 4u_{N-1} + 3u_N = 2h\\gamma_R$。\n- **罗宾 (Robin) 条件：** $\\alpha_R u(b) + \\beta_R u'(b) = \\gamma_R$。\n  将单侧公式代入 $u'(b)$：\n  $$\\alpha_R u_N + \\beta_R \\left(\\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h}\\right) = \\gamma_R$$\n  两边乘以 $2h$ 并分组各项，得到方程：\n  $$\\beta_R u_{N-2} - (4\\beta_R)u_{N-1} + (2h\\alpha_R + 3\\beta_R)u_N = 2h\\gamma_R$$\n\n这些方程共同构成了一个包含 $N+1$ 个未知数的 $N+1$ 个线性方程组，可以写成矩阵形式 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$。矩阵 $A$ 和向量 $\\mathbf{b}$ 是逐行构建的。\n\n- **行 $i=1, \\dots, N-1$ (内部):**\n  $A_{i, i-1} = -p_{i-1/2}/h^2$\n  $A_{i, i} = (p_{i-1/2} + p_{i+1/2})/h^2 + q_i$\n  $A_{i, i+1} = -p_{i+1/2}/h^2$\n  $b_i = r_i$\n\n- **行 0 (左边界):**\n  - 狄利克雷 ($\\gamma_L$): $A_{0,0}=1$, $b_0=\\gamma_L$。\n  - 诺伊曼 ($\\gamma_L$): $A_{0,0}=-3$, $A_{0,1}=4$, $A_{0,2}=-1$, $b_0=2h\\gamma_L$。\n  - 罗宾 ($\\alpha_L, \\beta_L, \\gamma_L$): $A_{0,0}=2h\\alpha_L-3\\beta_L$, $A_{0,1}=4\\beta_L$, $A_{0,2}=-\\beta_L$, $b_0=2h\\gamma_L$。\n\n- **行 N (右边界):**\n  - 狄利克雷 ($\\gamma_R$): $A_{N,N}=1$, $b_N=\\gamma_R$。\n  - 诺伊曼 ($\\gamma_R$): $A_{N,N-2}=1$, $A_{N,N-1}=-4$, $A_{N,N}=3$, $b_N=2h\\gamma_R$。\n  - 罗宾 ($\\alpha_R, \\beta_R, \\gamma_R$): $A_{N,N-2}=\\beta_R$, $A_{N,N-1}=-4\\beta_R$, $A_{N,N}=2h\\alpha_R+3\\beta_R$, $b_N=2h\\gamma_R$。\n\n$A$ 的所有其他元素均为零。得到的矩阵 $A$ 是稀疏且带状的。对于指定的问题参数，该系统是非奇异的，并有唯一解 $\\mathbf{u} = A^{-1}\\mathbf{b}$，可以使用标准的线性代数求解器求得。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(p, q, r, a, b, N, bc_left, bc_right):\n    \"\"\"\n    Solves a linear, second-order, self-adjoint BVP using finite differences.\n\n    Equation: -(p(x)u')' + q(x)u(x) = r(x) on [a, b]\n\n    Args:\n        p (callable): Coefficient function p(x).\n        q (callable): Coefficient function q(x).\n        r (callable): Source function r(x).\n        a (float): Left boundary of the domain.\n        b (float): Right boundary of the domain.\n        N (int): Number of subintervals in the uniform grid.\n        bc_left (tuple): Left boundary condition.\n            - ('dirichlet', gamma): u(a) = gamma\n            - ('neumann', gamma): u'(a) = gamma\n            - ('robin', alpha, beta, gamma): alpha*u(a) + beta*u'(a) = gamma\n        bc_right (tuple): Right boundary condition (similar format).\n\n    Returns:\n        tuple: (x, u) where x is the grid and u is the numerical solution.\n    \"\"\"\n    if N < 2:\n        raise ValueError(\"N must be at least 2.\")\n\n    h = (b - a) / N\n    x = np.linspace(a, b, N + 1)\n    \n    A = np.zeros((N + 1, N + 1))\n    rhs = np.zeros(N + 1)\n\n    # Interior points (i = 1, ..., N-1)\n    for i in range(1, N):\n        x_i = x[i]\n        p_minus_half = p(x_i - h / 2)\n        p_plus_half = p(x_i + h / 2)\n        \n        A[i, i-1] = -p_minus_half / h**2\n        A[i, i] = (p_minus_half + p_plus_half) / h**2 + q(x_i)\n        A[i, i+1] = -p_plus_half / h**2\n        rhs[i] = r(x_i)\n\n    # Left boundary condition (i = 0)\n    bc_type_left = bc_left[0]\n    if bc_type_left == 'dirichlet':\n        gamma_L = bc_left[1]\n        A[0, 0] = 1\n        rhs[0] = gamma_L\n    elif bc_type_left == 'neumann':\n        gamma_L = bc_left[1]\n        A[0, 0] = -3\n        A[0, 1] = 4\n        A[0, 2] = -1\n        rhs[0] = 2 * h * gamma_L\n    elif bc_type_left == 'robin':\n        alpha_L, beta_L, gamma_L = bc_left[1:]\n        A[0, 0] = 2 * h * alpha_L - 3 * beta_L\n        A[0, 1] = 4 * beta_L\n        A[0, 2] = -beta_L\n        rhs[0] = 2 * h * gamma_L\n    else:\n        raise ValueError(f\"Unknown left boundary condition type: {bc_type_left}\")\n\n    # Right boundary condition (i = N)\n    bc_type_right = bc_right[0]\n    if bc_type_right == 'dirichlet':\n        gamma_R = bc_right[1]\n        A[N, N] = 1\n        rhs[N] = gamma_R\n    elif bc_type_right == 'neumann':\n        gamma_R = bc_right[1]\n        A[N, N-2] = 1\n        A[N, N-1] = -4\n        A[N, N] = 3\n        rhs[N] = 2 * h * gamma_R\n    elif bc_type_right == 'robin':\n        alpha_R, beta_R, gamma_R = bc_right[1:]\n        A[N, N-2] = beta_R\n        A[N, N-1] = -4 * beta_R\n        A[N, N] = 2 * h * alpha_R + 3 * beta_R\n        rhs[N] = 2 * h * gamma_R\n    else:\n        raise ValueError(f\"Unknown right boundary condition type: {bc_type_right}\")\n\n    u = np.linalg.solve(A, rhs)\n    return x, u\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (Dirichlet–Dirichlet)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 200,\n            'p': lambda x: 1.0,\n            'q': lambda x: 0.0,\n            'r': lambda x: np.sin(np.pi * x),\n            'bc_left': ('dirichlet', 0.0),\n            'bc_right': ('dirichlet', 0.0),\n            'u_exact': lambda x: np.sin(np.pi * x) / (np.pi**2)\n        },\n        # Case 2 (Dirichlet–Neumann)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 200,\n            'p': lambda x: 1.0,\n            'q': lambda x: 1.0,\n            'r': lambda x: 0.0,\n            'bc_left': ('dirichlet', 1.0),\n            'bc_right': ('neumann', np.e),\n            'u_exact': lambda x: np.exp(x)\n        },\n        # Case 3 (Robin–Robin)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 200,\n            'p': lambda x: 1.0 + x,\n            'q': lambda x: x**2,\n            'r': lambda x: 1.0 + 4.0*x + x**3 - x**4,\n            'bc_left': ('robin', 2.0, 1.0, 1.0),\n            'bc_right': ('robin', 3.0, -1.0, 1.0),\n            'u_exact': lambda x: x * (1.0 - x)\n        },\n        # Case 4 (Neumann–Neumann)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 80,\n            'p': lambda x: 2.0,\n            'q': lambda x: 5.0,\n            'r': lambda x: 7.0 * np.cos(x),\n            'bc_left': ('neumann', 0.0),\n            'bc_right': ('neumann', -np.sin(1.0)),\n            'u_exact': lambda x: np.cos(x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        x_grid, u_numerical = solve_bvp(\n            p=case['p'],\n            q=case['q'],\n            r=case['r'],\n            a=case['a'],\n            b=case['b'],\n            N=case['N'],\n            bc_left=case['bc_left'],\n            bc_right=case['bc_right']\n        )\n        \n        u_analytic = case['u_exact'](x_grid)\n        \n        # Compute maximum absolute error\n        max_abs_error = np.max(np.abs(u_numerical - u_analytic))\n        \n        # Round to 8 decimal places as required\n        results.append(round(max_abs_error, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2392775"}]}