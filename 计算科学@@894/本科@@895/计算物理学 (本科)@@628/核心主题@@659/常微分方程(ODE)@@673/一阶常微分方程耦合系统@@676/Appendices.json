{"hands_on_practices": [{"introduction": "许多物理系统，如谐振子，都会经历能量耗散。虽然线性阻尼模型在教学中很常见，但现实世界中的阻尼力（如流体动力学中的拖拽力）往往与速度呈非线性关系。本练习将探讨一个带有二次速度阻尼的振子，这是一种更符合物理实际的模型 [@problem_id:2444882]。通过这个实践，你将练习如何将一个二阶非线性常微分方程转换为一阶方程组，并学习如何通过分析系统的能量演化来验证数值解的物理合理性。", "problem": "一个带与速度平方成正比阻尼的一维质点弹簧振子，其运动由如下二阶常微分方程 (ODE) 决定，其中的阻尼力是非线性的：$$m\\,\\ddot{x}(t) + k\\,x(t) + b\\,\\dot{x}(t)\\lvert \\dot{x}(t)\\rvert = 0,$$ 其中 $x(t)$ 是位移，$\\dot{x}(t)$ 是速度， $m$ 是质量，$k$ 是弹簧常数， $b \\ge 0$ 是非线性阻尼系数。通过设置 $m=1$ 在无量纲单位下进行计算。通过定义状态向量 $y(t) = \\big(x(t), v(t)\\big)$（其中 $v(t) = \\dot{x}(t)$），将此方程转换为一个耦合一阶常微分方程组。该方程组为 $$\\dot{x}(t) = v(t), \\quad \\dot{v}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert.$$\n\n定义机械能 $$E(t) = \\tfrac{1}{2}v(t)^2 + \\tfrac{1}{2}k\\,x(t)^2.$$ 对于下面的每一组参数，使用初始条件 $x(0)=A$ 和 $v(0)=V_0$，对系统从时间 $t=0$ 积分到时间 $t=T$。对于每种情况，计算三个量：\n1) 末态与初态能量之比 $R = E(T)/E(0)$，四舍五入到六位小数，\n2) 一个布尔值 $M$，表示沿计算出的轨迹的离散能量序列在每步绝对容差 $\\tau = 10^{-9}$ 内是否非递增，即对于所有连续的采样时间，是否满足 $E_{n+1} \\le E_n + \\tau$，\n3) 在 $t \\in [0,T]$ 区间内，$x(t)$ 的过零点整数数量 $Z$（计算 $x$ 的符号变化次数；$x$ 的绝对值低于某个阈值的点应被视为零，以避免将数值噪声计入；你必须使用 $10^{-8}$ 的固定绝对阈值）。\n\n使用以下参数集测试套件，每个参数集指定为 $(A, V_0, b, k, T)$：\n- 情况 1：$(1, 0, 0, 1, 40)$，\n- 情况 2：$(1, 0, 0.1, 1, 40)$，\n- 情况 3：$(1, 0, 1, 1, 40)$，\n- 情况 4：$(0, 2, 0.5, 1, 40)$，\n- 情况 5：$(2, 0, 0.5, 1, 40)$。\n\n你的程序必须输出单行结果，其中包含一个列表，每个案例对应一个结果，每个结果是按顺序排列的列表 $[R,M,Z]$。因此，总输出必须是形如\n[[R1,M1,Z1],[R2,M2,Z2],[R3,M3,Z3],[R4,M4,Z4],[R5,M5,Z5]]\n的单行文本，不含任何附加文本。所有计算和输出都是无量纲的，不需要物理单位。", "solution": "所给出的问题是计算物理学中一个定义明确的初值问题，需要对一个耦合一阶常微分方程组 (ODEs) 进行数值积分。该问题有科学依据，内部逻辑一致，并包含了求解唯一解所需的所有必要信息。因此，该问题被认定是有效的。\n\n带二次阻尼的一维质点弹簧振子的控制方程如下：\n$$m\\,\\ddot{x}(t) + k\\,x(t) + b\\,\\dot{x}(t)\\lvert \\dot{x}(t)\\rvert = 0$$\n其中，$x(t)$ 是位移，$m$ 是质量，$k$ 是弹簧常数，$b$ 是非线性阻尼系数。问题指定通过设置质量 $m=1$ 来使用无量纲单位。\n\n为了数值求解这个二阶常微分方程，我们将其转换为一个由两个一阶常微分方程组成的方程组。我们定义一个状态向量 $y(t)$ 及其分量如下：\n$$y(t) = \\begin{pmatrix} y_0(t) \\\\ y_1(t) \\end{pmatrix} = \\begin{pmatrix} x(t) \\\\ v(t) \\end{pmatrix}$$\n其中 $v(t) = \\dot{x}(t)$ 是速度。这些分量的时间导数构成了以下方程组：\n$$\n\\begin{align*}\n\\dot{y_0}(t) &= \\dot{x}(t) = v(t) = y_1(t) \\\\\n\\dot{y_1}(t) &= \\dot{v}(t) = \\ddot{x}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert = -k\\,y_0(t) - b\\,y_1(t)\\lvert y_1(t)\\rvert\n\\end{align*}\n$$\n给定初始条件 $y(0) = (x(0), v(0)) = (A, V_0)$，这个方程组 $\\dot{y}(t) = f(t, y(t))$ 可以被数值积分。\n\n系统的总机械能定义为动能和势能之和：\n$$E(t) = \\frac{1}{2}m\\,v(t)^2 + \\frac{1}{2}k\\,x(t)^2$$\n当 $m=1$ 时，方程变为：\n$$E(t) = \\frac{1}{2}v(t)^2 + \\frac{1}{2}k\\,x(t)^2$$\n能量变化率 $\\dot{E}(t)$ 揭示了阻尼力的耗散性质。将 $E(t)$ 对时间求导，得到：\n$$\\dot{E}(t) = v(t)\\,\\dot{v}(t) + k\\,x(t)\\,\\dot{x}(t)$$\n代入 $\\dot{x}(t) = v(t)$ 和 $\\dot{v}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert$：\n$$\\dot{E}(t) = v(t) \\left( -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert \\right) + k\\,x(t)\\,v(t)$$\n$$\\dot{E}(t) = -k\\,x(t)v(t) - b\\,v(t)^2\\lvert v(t)\\rvert + k\\,x(t)v(t)$$\n$$\\dot{E}(t) = -b\\,v(t)^2\\lvert v(t)\\rvert$$\n由于阻尼系数 $b \\ge 0$ 且项 $v(t)^2\\lvert v(t)\\rvert \\ge 0$，能量变化率 $\\dot{E}(t)$ 总是小于或等于零。这证实了机械能是时间的非递增函数。仅当 $b=0$ 时能量守恒。这一物理原理为通过单调性检查 $M$ 来验证数值解提供了基础。\n\n解将通过使用一个高精度数值积分器来获得。`scipy.integrate.solve_ivp` 函数非常适合这项任务。为确保所需计算的精度，特别是能量单调性检查（容差为 $\\tau=10^{-9}$）和过零点计数，求解器需要使用严格的相对和绝对容差（例如 $10^{-12}$）。此外，必须在精细的时间网格上评估解，以便可靠地捕捉所有过零点。\n\n每个测试案例的算法如下：\n1.  将常微分方程组定义为一个 Python 函数 `f(t, y, b, k)`。\n2.  使用 `scipy.integrate.solve_ivp` 函数，根据给定的初始条件 $(A, V_0)$ 和参数 $(b, k)$，对系统从 $t=0$ 积分到 $t=T$。使用 `t_eval` 参数指定一个密集的评估时间网格。\n3.  根据 $x(t_i)$ 和 $v(t_i)$ 的数值解，计算所需的量：\n    a.  **能量比 ($R$)**：计算初始能量 $E(0) = \\frac{1}{2}V_0^2 + \\frac{1}{2}kA^2$ 和末态能量 $E(T) = \\frac{1}{2}v(T)^2 + \\frac{1}{2}k\\,x(T)^2$。该比率为 $R = E(T)/E(0)$，四舍五入到六位小数。\n    b.  **能量单调性 ($M$)**：计算每个时间步 $t_i$ 的能量 $E(t_i)$。遍历该序列并验证是否对于所有的 $i$ 都满足 $E(t_{i+1}) \\le E(t_i) + \\tau$，其中容差 $\\tau = 10^{-9}$。如果所有步都满足此条件，则 $M$ 为 `True`，否则为 `False`。\n    c.  **过零点 ($Z$)**：为计算 $x(t)$ 穿过零点的次数，我们首先过滤位置数组 $x(t_i)$，移除那些绝对值低于指定阈值 $10^{-8}$ 的点。这可以防止将零附近的数值噪声计为过零点。然后，我们计算这个过滤后数组中连续元素符号变化的次数。通过检查连续元素的乘积是否为负来稳健地实现这一点。\n\n将此过程应用于五个指定的参数集中的每一个，以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the mass-spring oscillator problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (A, V0, b, k, T)\n    test_cases = [\n        (1.0, 0.0, 0.0, 1.0, 40.0),   # Case 1\n        (1.0, 0.0, 0.1, 1.0, 40.0),   # Case 2\n        (1.0, 0.0, 1.0, 1.0, 40.0),   # Case 3\n        (0.0, 2.0, 0.5, 1.0, 40.0),   # Case 4\n        (2.0, 0.0, 0.5, 1.0, 40.0),   # Case 5\n    ]\n\n    results = []\n    \n    # Define constants from the problem\n    energy_monotonicity_tolerance = 1e-9\n    zero_crossing_threshold = 1e-8\n    \n    # Number of points for the time evaluation grid.\n    # A high number is chosen to ensure accuracy for zero-crossing and monotonicity checks.\n    num_points = 20001\n            \n    for case in test_cases:\n        A, V0, b, k, T = case\n\n        # Define the system of first-order ODEs\n        # y[0] = x, y[1] = v\n        # dx/dt = v\n        # dv/dt = -k*x - b*v*|v|\n        def ode_system(t, y, b_param, k_param):\n            x, v = y\n            dxdt = v\n            dvdt = -k_param * x - b_param * v * abs(v)\n            return [dxdt, dvdt]\n\n        # Set initial conditions\n        y0 = [A, V0]\n        \n        # Set time span and evaluation points\n        t_span = [0, T]\n        t_eval = np.linspace(t_span[0], t_span[1], num_points)\n\n        # Solve the ODE system\n        # Use tight tolerances for high accuracy\n        sol = solve_ivp(\n            ode_system, \n            t_span, \n            y0, \n            args=(b, k), \n            t_eval=t_eval, \n            rtol=1e-12, \n            atol=1e-12,\n            method='DOP853' # A high-order accurate method\n        )\n        \n        x_t = sol.y[0, :]\n        v_t = sol.y[1, :]\n\n        # 1. Calculate final-to-initial energy ratio (R)\n        E_t = 0.5 * v_t**2 + 0.5 * k * x_t**2\n        E0 = E_t[0]\n        ET = E_t[-1]\n        \n        # Handle the theoretical case of zero initial energy to avoid division by zero.\n        # This is not triggered by the given test cases.\n        if E0 == 0:\n            R = 0.0 if ET == 0 else float('inf')\n        else:\n            R = round(ET / E0, 6)\n\n        # 2. Check for energy monotonicity (M)\n        M = True\n        for i in range(len(E_t) - 1):\n            if E_t[i+1] > E_t[i] + energy_monotonicity_tolerance:\n                M = False\n                break\n        \n        # 3. Count zero-crossings (Z)\n        # Filter out values whose magnitude is below the threshold\n        x_filtered = x_t[np.abs(x_t) > zero_crossing_threshold]\n        \n        if len(x_filtered)  2:\n            Z = 0\n        else:\n            # A sign change occurs where sign(x_i) != sign(x_{i+1})\n            Z = np.sum(np.sign(x_filtered[:-1]) != np.sign(x_filtered[1:]))\n\n        results.append([R, M, Z])\n\n    # Final print statement in the exact required format.\n    # repr() produces a string representation that includes brackets and commas.\n    # .replace(\" \", \"\") removes all spaces to match the required dense format.\n    print(repr(results).replace(\" \", \"\"))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2444882"}, {"introduction": "物理世界的许多动态过程并非完全连续，而是由平滑演化和瞬时事件（如碰撞或切换）共同构成。这个“混合动力系统”的例子是一个在重力场中弹跳的小球 [@problem_id:2444852]。本练习将引导你模拟这个过程，你需要在求解常微分方程的同时，精确地检测并处理小球与地面碰撞的离散事件。掌握这种事件驱动的模拟方法，对于解决工程、机器人学和物理学中的众多实际问题至关重要。", "problem": "考虑一个在均匀引力场中进行一维垂直运动的刚性质点小球。设垂直位置为 $y(t)$（单位：米），垂直速度为 $v(t)$（单位：米/秒）。在与位于 $y=0$ 的完全刚性水平地面发生碰撞之间，其运动遵循牛顿第二定律，并可考虑线性空气阻力，从而得到以下耦合的一阶常微分方程组 (ODEs)：\n$$\n\\frac{d y}{d t} = v, \\qquad \\frac{d v}{d t} = -g - \\frac{c}{m} v,\n$$\n其中，$g$ 是重力加速度的大小（单位：米/秒²），$c$ 是线性阻力系数（单位：千克/秒），$m$ 是质量（单位：千克）。当 $y(t) = 0$ 且 $v(t^{-})  0$ 时，发生一次碰撞，此时碰撞后的速度满足以下碰撞映射：\n$$\nv(t^{+}) = - e \\, v(t^{-}),\n$$\n其中 $0 \\le e  1$ 是恢复系数（无量纲）。位置是连续的，因此 $y(t^{+}) = y(t^{-}) = 0$。对于 $e=0$ 的特殊情况，在第一次碰撞后，小球在所有后续时间都保持在 $y(t)=0$ 且 $v(t)=0$ 的状态。\n\n给定初始条件 $y(0) = y_0$ 和 $v(0) = v_0$，模拟运动直至指定的最终时间 $T$，并为每组参数确定以下内容：\n- 在区间 $[0,T]$ 内发生的总碰撞次数 $N$。\n- 最终位置 $y(T)$（单位：米）。\n- 最终速度 $v(T)$（单位：米/秒）。\n\n所有输出必须使用国际单位制 (SI)。报告 $y(T)$（单位：米）和 $v(T)$（单位：米/秒）。将 $y(T)$ 和 $v(T)$ 表示为四舍五入到恰好六位小数的值。整数 $N$ 应作为整数报告，无需四舍五入。本问题不涉及角度。\n\n所有情况均使用以下恒定重力加速度：$g = 9.81$ 米/秒²。\n\n待评估的测试用例参数集，每个参数集指定为 $(y_0, v_0, e, c, m, T)$，单位为 $(\\text{m}, \\text{m/s}, -, \\text{kg/s}, \\text{kg}, \\text{s})$：\n- 案例 A（一般情况，无阻力）：$(y_0, v_0, e, c, m, T) = (10.0, 0.0, 0.8, 0.0, 1.0, 5.0)$。\n- 案例 B（存在线性阻力，初始速度向上）：$(y_0, v_0, e, c, m, T) = (2.0, 1.0, 0.9, 0.1, 0.2, 3.0)$。\n- 案例 C（完全非弹性碰撞）：$(y_0, v_0, e, c, m, T) = (1.0, 0.0, 0.0, 0.0, 1.0, 2.0)$。\n- 案例 D（时间范围短，预计无碰撞）：$(y_0, v_0, e, c, m, T) = (0.5, 4.0, 0.7, 0.0, 1.0, 0.3)$。\n\n您的程序必须为每个案例计算三元组 $[N, y(T), v(T)]$，其中 $N$ 是一个整数，$y(T)$ 和 $v(T)$ 是四舍五入到六位小数的浮点数。最终的程序输出必须将四个案例的结果按照上面列出的相同顺序汇总为单行，其格式必须完全为一个由方括号括起来的、用逗号分隔的列表之列表。例如，输出应如下所示：\n$[ [N_A, y_A, v_A], [N_B, y_B, v_B], [N_C, y_C, v_C], [N_D, y_D, v_D] ]$\n其中 $y_{\\cdot}$ 的单位是米，$v_{\\cdot}$ 的单位是米/秒，每个浮点数都四舍五入到六位小数，每个 $N$ 都是整数。", "solution": "垂直运动遵循牛顿第二定律，将其建模为耦合的一阶常微分方程组 (ODEs) 是标准做法。设 $y(t)$ 表示垂直位置，$v(t)$ 表示垂直速度。运动学关系得出 $\\frac{d y}{d t} = v$。动力学方程源于牛顿第二定律，$m \\frac{d v}{d t} = - m g - c v$，其中作用力包括大小为 $m g$ 的重力和与运动方向相反的线性阻力 $c v$。方程两边同除以 $m$ 得到以下一阶系统：\n$$\n\\frac{d y}{d t} = v, \\qquad \\frac{d v}{d t} = -g - \\frac{c}{m} v.\n$$\n\n地面是位于 $y=0$ 处的一个不可穿透边界；因此，当解在向下速度 $v(t^{-})  0$ 的情况下达到 $y=0$ 时，会发生一次机械碰撞。我们将碰撞建模为瞬时发生的，并使用恢复系数 $e \\in [0,1)$ 来缩放碰撞时的法向相对速度。碰撞后的速度为\n$$\nv(t^{+}) = - e \\, v(t^{-}),\n$$\n而在整个碰撞过程中位置保持连续，$y(t^{+}) = y(t^{-}) = 0$。对于 $e=0$ 的情况，能量在第一次碰撞时被最大程度地耗散，速度变为零；刚性地面随后会阻止其穿透，因此小球在第一次碰撞后的所有后续时间都保持在 $y=0$ 和 $v=0$ 的状态，这与第一次碰撞后 $t$ 时刻的 $y(t)=0$ 和 $v(t)=0$ 相一致。\n\n这是一个混合动力系统：在开集 $\\{ y  0\\}$ 上由常微分方程组控制的连续演化，以及在边界 $\\{ y = 0, v  0\\}$ 上 $v$ 的离散跳变。为模拟其运动直至最终时间 $T$，我们原则上按以下步骤进行：\n- 从初始条件 $(y(0), v(0)) = (y_0, v_0)$ 开始。\n- 当 $y(t)  0$ 时，随时间向前演化该常微分方程组。这个演化是适定的，因为方程组的右端项关于 $(y,v)$ 是 Lipschitz 连续的。\n- 检测到第一个满足 $y(t_\\star) = 0$ 且 $v(t_\\star^{-})  0$ 的时刻 $t_\\star$。在此刻，应用碰撞映射得到 $(y(t_\\star^{+}), v(t_\\star^{+})) = (0, - e \\, v(t_\\star^{-}))$. 将碰撞计数器 $N$ 加一。\n- 从 $(0, v(t_\\star^{+}))$ 重新开始常微分方程的演化。如果 $e=0$，则第一次碰撞后 $v(t_\\star^{+}) = 0$，系统将在所有后续时间粘滞在 $y=0, v=0$ 的状态；因此对于任何 $T \\ge t_\\star$，可以直接设置 $(y(T), v(T)) = (0,0)$ 且 $N=1$。\n- 重复连续演化和离散碰撞更新的过程，直到达到最终时间 $T$。最终状态 $(y(T), v(T))$ 是在时间 $T$ 获得的状态，总碰撞次数 $N$ 是在区间 $[0, T]$ 内碰撞事件的计数。\n\n在两次碰撞之间，如果需要，可以写出精确解的闭式形式。例如，在线性阻力情况下，速度的解是\n$$\nv(t) = \\left(v(t_0) + \\frac{m g}{c}\\right) e^{-\\frac{c}{m}(t - t_0)} - \\frac{m g}{c},\n$$\n而相应的位置可通过对 $v(t)$ 进行一次积分得到。然而，由于碰撞发生在未知时刻，一个能够检测到 $y(t)$ 何时达到 0（从上方且 $v0$）并随后应用碰撞规则的通用数值方法是最稳健的途径。事件条件是简单的 $y(t) = 0$ 加上要求的速度符号。每个事件都会触发离散跳变 $v \\mapsto -e v$ 并将计数 $N$ 加一。\n\n对于每个测试案例，输入 $(y_0, v_0, e, c, m, T)$ 以国际单位制 (SI) 指定，且 $g = 9.81$ 米/秒² 是固定值。对每个案例，模拟得出：\n- 在 $[0, T]$ 内的碰撞次数整数 $N$。\n- 最终状态 $(y(T), v(T))$，单位分别为米和米/秒。\n\n最后，将 $y(T)$ 和 $v(T)$ 四舍五入到六位小数。按照给定测试用例的顺序，将这四个三元组汇总成一个单行的列表之列表，并以所要求的确切格式打印。该方法直接实现了弹跳球的物理模型，该模型包含飞行过程中的耗散（通过线性阻力）和碰撞时的耗散（通过恢复系数），并被表述为一个带有边界触发状态重置的耦合一阶常微分方程组。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef simulate_case(y0, v0, e, c, m, T, g=9.81):\n    \"\"\"\n    Simulate the hybrid ODE system for a bouncing ball with linear drag and\n    coefficient of restitution e, up to time T.\n\n    Parameters:\n        y0 (float): initial height [m]\n        v0 (float): initial vertical velocity [m/s]\n        e (float): coefficient of restitution in [0,1)\n        c (float): linear drag coefficient [kg/s]\n        m (float): mass [kg]\n        T (float): final time [s]\n        g (float): gravitational acceleration [m/s^2]\n\n    Returns:\n        (N, yT, vT): number of impacts, final height, final velocity\n    \"\"\"\n    # Continuous dynamics between impacts: dy/dt = v, dv/dt = -g - (c/m) v\n    c_over_m = c / m if m != 0 else 0.0\n\n    def f(t, s):\n        y, v = s\n        return np.array([v, -g - c_over_m * v])\n\n    # Event for hitting the ground from above (downward crossing)\n    def ground_event(t, s):\n        # Event when y = 0; we only want downward crossings to avoid spurious triggers\n        return s[0]\n\n    ground_event.terminal = True\n    ground_event.direction = -1.0\n\n    # Initialize\n    t = 0.0\n    s = np.array([y0, v0], dtype=float)\n    impacts = 0\n\n    # If initially below ground (should not happen), project to ground\n    if s[0]  0.0:\n        s[0] = 0.0\n\n    # Main loop: integrate piecewise between impacts until time T\n    while t  T:\n        # If at ground with nonpositive velocity, and e == 0 implies sticking immediately.\n        # Otherwise, evolve as usual; the event function will handle impacts properly.\n        # Integrate until next event or final time\n        sol = solve_ivp(\n            f,\n            (t, T),\n            s,\n            method=\"RK45\",\n            rtol=1e-10,\n            atol=1e-12,\n            events=ground_event,\n            dense_output=False,\n            max_step=np.inf\n        )\n\n        # Update current time and state to the end of this segment\n        t = float(sol.t[-1])\n        s = sol.y[:, -1].copy()\n\n        # Numerical safety: avoid tiny negative heights from integration error\n        if s[0]  0 and abs(s[0])  1e-12:\n            s[0] = 0.0\n\n        # If an impact occurred, apply the restitution law\n        if sol.t_events and len(sol.t_events[0]) > 0:\n            # At the event, y = 0 by definition. Use the state at event time for pre-impact velocity.\n            t_event = float(sol.t_events[0][-1])\n            # The solver state at the last time equals the event state because terminal=True\n            # But to be robust, force y to exactly 0 at event.\n            s[0] = 0.0\n            v_pre = float(sol.y[1, -1])\n            # Only count true downward impacts (v_pre  0)\n            if v_pre  0.0:\n                impacts += 1\n                # Apply impact map\n                v_post = -e * v_pre\n                # Handle perfectly inelastic case: stick at ground after first impact\n                if e == 0.0:\n                    # Remain at rest at the ground for the rest of the interval\n                    s = np.array([0.0, 0.0], dtype=float)\n                    t = T\n                    break\n                else:\n                    s = np.array([0.0, v_post], dtype=float)\n                    # Proceed to integrate from the event time\n                    t = t_event\n            else:\n                # No valid downward impact; continue\n                pass\n\n        # If no impact and we reached final time, exit\n        if t >= T or (not sol.t_events) or (len(sol.t_events[0]) == 0):\n            # Already updated t and s to end of integration segment\n            if t >= T:\n                break\n            # Otherwise, continue; loop will integrate the remaining time\n            # If the solver ended early without event due to numerical reasons, continue\n            # But with given settings, this should not happen.\n            pass\n\n    # Ensure we have the state at T: If we exited due to reaching T during integration, s is already at T.\n    # If we exited due to e == 0 sticking, s is set to [0, 0] at T.\n    yT, vT = float(s[0]), float(s[1])\n\n    return impacts, yT, vT\n\ndef fmt_float(x):\n    # Round to six decimals and avoid printing negative zero\n    if abs(x)  0.5e-6:\n        x = 0.0\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (y0, v0, e, c, m, T)\n    test_cases = [\n        (10.0, 0.0, 0.8, 0.0, 1.0, 5.0),  # Case A\n        (2.0, 1.0, 0.9, 0.1, 0.2, 3.0),   # Case B\n        (1.0, 0.0, 0.0, 0.0, 1.0, 2.0),   # Case C\n        (0.5, 4.0, 0.7, 0.0, 1.0, 0.3),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        y0, v0, e, c, m, T = case\n        N, yT, vT = simulate_case(y0, v0, e, c, m, T, g=9.81)\n        # Round the floats to exactly six decimal places for output\n        results.append([N, fmt_float(yT), fmt_float(vT)])\n\n    # Build the exact required single-line output as a list of lists\n    # Ensure integers are printed as integers, floats with six decimals\n    out_items = []\n    for item in results:\n        N_str = str(item[0])\n        y_str = item[1]\n        v_str = item[2]\n        out_items.append(f\"[{N_str},{y_str},{v_str}]\")\n    print(f\"[{','.join(out_items)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2444852"}, {"introduction": "从单个物体的运动到多体系统的复杂相互作用，是物理建模中的一次重要飞跃。本练习将带你重现计算物理学史上著名的费米-帕斯塔-乌拉姆-钦戈（FPU）实验 [@problem_id:2444879]。你将模拟一个由非线性弹簧连接的振子链，这不仅是构建和求解大规模耦合常微分方程组的绝佳实践，更将引导你通过对能量在不同模式间的分配进行分析，揭示出与直觉相悖的、令人惊讶的“FPU回归”现象。这个练习充分体现了数值模拟作为科学发现工具的强大力量。", "problem": "考虑一个一维的 Fermi-Pasta-Ulam-Tsingou (FPUT) $\\alpha$-模型，该模型由一条包含 $N$ 个相同质点的链组成，具有固定边界条件，质点间通过包含弱非线性修正的最近邻弹簧相连。令 $u_n(t)$ 表示第 $n$ 个质点在时间 $t$ 相对于其平衡位置的位移（其中 $n \\in \\{1,2,\\dots,N\\}$），并令 $v_n(t) = \\dot{u}_n(t)$ 表示其速度。链的两端满足固定边界条件 $u_0(t) = 0$ 和 $u_{N+1}(t) = 0$（对所有 $t$ 成立）。假设单位质量和单位线性弹簧常数，因此所有量均为无量纲量。\n\n运动方程为以下耦合一阶系统：\n$\n\\dot{u}_n = v_n,\n$\n$\n\\dot{v}_n = \\left(u_{n+1} - 2u_n + u_{n-1}\\right) + \\alpha\\left[\\left(u_{n+1} - u_n\\right)^2 - \\left(u_n - u_{n-1}\\right)^2\\right],\n$\n其中 $n \\in \\{1,2,\\dots,N\\}$，且 $u_0 = 0$，$u_{N+1} = 0$。$\\alpha$ 是非线性参数。\n\n定义相应纯线性链（即 $\\alpha = 0$）的线性简正模为：\n$\n\\phi_k(n) = \\sqrt{\\frac{2}{N+1}} \\sin\\!\\left(\\frac{k\\pi n}{N+1}\\right),\n$\n其模态频率为：\n$\n\\omega_k = 2\\sin\\!\\left(\\frac{k\\pi}{2(N+1)}\\right),\n$\n其中 $k \\in \\{1,2,\\dots,N\\}$。对于任意状态 $\\{u_n,v_n\\}_{n=1}^N$，定义线性模态坐标为：\n$\nq_k = \\sum_{n=1}^{N} u_n \\, \\phi_k(n), \\quad p_k = \\sum_{n=1}^{N} v_n \\, \\phi_k(n),\n$\n以及相关的线性模态能量：\n$\nE_k = \\frac{1}{2}\\left(p_k^2 + \\omega_k^2 q_k^2\\right).\n$\n令 $E_{\\mathrm{sum}}(t) = \\sum_{k=1}^{N} E_k(t)$，并令 $E_1(t)$ 表示第一模态的能量。初始条件为第一线性模态的单模激发，初始速度为零：\n$\nu_n(0) = A \\sin\\!\\left(\\frac{\\pi n}{N+1}\\right), \\quad v_n(0) = 0,\n$\n其中 $n \\in \\{1,2,\\dots,N\\}$，$A$ 是初始振幅。\n\n定义一个回归检测准则如下。给定容差参数 $\\epsilon \\in (0,1)$ 和 $\\eta \\in (0,1)$ 以及一个时间上限 $T_{\\max}  0$，如果存在时间 $t_a$ 和 $t_b$ 满足 $0  t_a  t_b \\le T_{\\max}$ 且符合以下条件，则称观测到了回归：\n- 偏离：$E_1(t_a)/E_{\\mathrm{sum}}(t_a) \\le 1 - \\eta$，\n- 返回：$E_1(t_b)/E_{\\mathrm{sum}}(t_b) \\ge 1 - \\epsilon$，\n并且 $t_b$ 是在某个偏离时间 $t_a$ 之后，满足返回条件的最小时间。回归时间定义为 $t_b$。如果在区间 $(0, T_{\\max}]$ 内不存在这样的 $t_b$，则回归时间定义为 $-1$。\n\n所有量均为无量纲量。所有时间均以无量纲单位的实数形式报告。\n\n测试套件。对于以下每一组参数 $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta)$，计算上述定义的回归时间：\n- 情况1：$(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,0.25,\\,0.3,\\,300,\\,0.1,\\,0.1)$。\n- 情况2：$(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,0,\\,0.3,\\,100,\\,0.1,\\,0.1)$。\n- 情况3：$(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,1.0,\\,0.3,\\,300,\\,0.1,\\,0.1)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含上述三种情况的回归时间，形式为用方括号括起来的逗号分隔列表，例如 $[t_1,t_2,t_3]$。其中每个 $t_i$ 是一个无量纲单位的实数，如果在指定的时间上限内未观测到回归，则其值为 $-1$。", "solution": "所给出的问题是计算物理学中一个适定且科学上合理的练习。它要求对 Fermi-Pasta-Ulam-Tsingou (FPUT) $\\alpha$-模型的运动方程进行数值积分，然后在线性简正模空间中分析系统轨迹，以确定回归时间。该问题是自洽的，所有参数、方程、初始条件和分析标准都有明确定义。它是非线性动力学研究中的一个典型问题，没有任何科学或逻辑上的缺陷。因此，我们可以着手求解。\n\n问题的核心是求解一个包含 $2N$ 个耦合一阶常微分方程 (ODE) 的系统。令系统的状态由一个向量 $Y(t) \\in \\mathbb{R}^{2N}$ 表示，其中 $Y = [u_1, \\dots, u_N, v_1, \\dots, v_N]^T$。分量 $u_n(t)$ 是 $N$ 个质点的位移，而 $v_n(t) = \\dot{u}_n(t)$ 是其速度。系统的时间演化由 $\\dot{Y}(t) = f(t, Y)$ 控制。函数 $f(t, Y)$ 源自运动方程：\n$$\n\\dot{u}_n = v_n\n$$\n$$\n\\dot{v}_n = (u_{n+1} - 2u_n + u_{n-1}) + \\alpha\\left[(u_{n+1} - u_n)^2 - (u_n - u_{n-1})^2\\right]\n$$\n这些方程对 $n \\in \\{1, \\dots, N\\}$ 成立，并带有固定边界条件 $u_0(t) = 0$ 和 $u_{N+1}(t) = 0$。状态向量的导数 $\\dot{Y}$ 可以通过将其前 $N$ 个分量设为 $[v_1, \\dots, v_N]$，后 $N$ 个分量设为 $[\\dot{v}_1, \\dots, \\dot{v}_N]$ 来构造，其中 $\\dot{v}_n$ 使用上述公式计算。在数值实现中，通过创建一个填充后的位移数组 $[0, u_1, \\dots, u_N, 0]$ 来处理边界条件。\n\n为了解决这个初值问题，我们采用一个高质量的数值 ODE 求解器。SciPy 库中的 `solve_ivp` 函数是一个合适的选择，因为它提供了鲁棒的、自适应步长的积分方法（例如 Runge-Kutta-Fehlberg 方法，RK45），适用于该系统的振荡特性。我们设置了严格的相对和绝对误差容限（例如 $10^{-9}$），以确保数值轨迹在指定的时间上限 $T_{\\max}$ 内是准确的。利用 `dense_output=True` 选项可以获得解的连续表示，从而可以在高频率的时间点上进行求值分析。\n\n初始条件被指定为第一线性简正模的纯激发，且初始速度为零：\n$$\nu_n(0) = A \\sin\\left(\\frac{\\pi n}{N+1}\\right), \\quad v_n(0) = 0\n$$\n这定义了初始状态向量 $Y(0)$。\n\n在将系统从 $t=0$ 积分到 $t=T_{\\max}$ 后，必须在线性简正模的基下分析所得的轨迹 $\\{u_n(t), v_n(t)\\}$。模态坐标 $(q_k, p_k)$ 通过线性变换得到：\n$$\nq_k(t) = \\sum_{n=1}^{N} u_n(t) \\phi_k(n), \\quad p_k(t) = \\sum_{n=1}^{N} v_n(t) \\phi_k(n)\n$$\n其中 $\\phi_k(n) = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{k\\pi n}{N+1}\\right)$ 是标准正交的模态形状。这个变换可以高效地通过矩阵-向量乘积来计算，$q(t) = T u(t)$ 和 $p(t) = T v(t)$，其中 $T$ 是变换矩阵，其元素为 $T_{kn} = \\phi_k(n)$。\n\n根据这些模态坐标，可以计算出线性模态能量 $E_k(t)$：\n$$\nE_k(t) = \\frac{1}{2}\\left(p_k(t)^2 + \\omega_k^2 q_k(t)^2\\right)\n$$\n其中 $\\omega_k = 2\\sin\\left(\\frac{k\\pi}{2(N+1)}\\right)$ 是线性模态频率。我们关心的量是第一模态的能量与所有线性模态能量之和的比值，$R(t) = E_1(t) / E_{\\mathrm{sum}}(t)$，其中 $E_{\\mathrm{sum}}(t) = \\sum_{k=1}^{N} E_k(t)$。需要注意的是，对于非线性系统（$\\alpha \\ne 0$），$E_{\\mathrm{sum}}(t)$ 不是一个守恒量，这与系统的真实总哈密顿量不同。\n\n最后，通过分析比值 $R(t)$ 的时间序列来确定回归时间。根据问题定义，我们必须找到最小的时间 $t_b \\in (0, T_{\\max}]$，使得 $R(t_b) \\ge 1 - \\epsilon$，并且其条件是在此之前存在某个时间 $t_a \\in (0, t_b)$ 使得 $R(t_a) \\le 1 - \\eta$。实现方式是遍历计算出的时间点，首先等待满足“偏离”条件（$R(t) \\le 1 - \\eta$），然后搜索第一个满足“返回”条件（$R(t) \\ge 1 - \\epsilon$）的后续时间。如果在此时间上限内没有发生这样的事件序列，则回归时间定义为 $-1$。\n\n对于 $\\alpha=0$ 的特殊情况（情况2），系统是线性的，简正模之间不发生耦合。由于初始条件只激发了第一模态，所有能量将始终保持在该模态中。因此，对于 $k  1$，$E_k(t) = 0$，而 $E_1(t)$ 是一个常数。比值 $R(t)$ 对所有 $t$ 恒等于 $1$。因此，偏离条件 $R(t) \\le 1 - \\eta$（对于 $\\eta  0$）永远不会被满足，根据定义，回归时间为 $-1$。这个已知的解析结果为我们对问题的理解提供了一个宝贵的验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef find_recurrence_time(N, alpha, A, T_max, epsilon, eta):\n    \"\"\"\n    Computes the FPUT recurrence time for a given set of parameters.\n    \"\"\"\n    # For the linear case (alpha=0), the modes are uncoupled.\n    # The initial condition is a pure mode 1 excitation, so energy never leaves\n    # mode 1. The departure condition is never met.\n    if alpha == 0:\n        return -1.0\n\n    # 1. Pre-calculate constants for the given N\n    N_plus_1 = N + 1\n    k = np.arange(1, N + 1)\n    n = np.arange(1, N + 1)\n    \n    # Square of angular frequencies for linear modes\n    omega_k_sq = (2 * np.sin(k * np.pi / (2 * N_plus_1)))**2\n    \n    # Modal transformation matrix T_kn = phi_k(n)\n    k_col = k[:, np.newaxis]\n    n_row = n[np.newaxis, :]\n    T_matrix = np.sqrt(2 / N_plus_1) * np.sin(k_col * np.pi * n_row / N_plus_1)\n    \n    # 2. Define the initial state vector Y0 = [u0, v0]\n    u0 = A * np.sin(np.pi * n / N_plus_1)\n    v0 = np.zeros(N)\n    Y0 = np.concatenate((u0, v0))\n    \n    # 3. Define the derivative function for the ODE system\n    def fput_eom(t, Y, N_val, alpha_val):\n        u = Y[:N_val]\n        v = Y[N_val:]\n        \n        dudt = v\n        \n        # Pad u with fixed boundaries u_0 = 0, u_{N+1} = 0\n        u_padded = np.concatenate(([0], u, [0]))\n        \n        # Linear part of acceleration\n        accel_linear = u_padded[2:] - 2 * u_padded[1:-1] + u_padded[:-2]\n        \n        # Nonlinear part of acceleration\n        diff_u = np.diff(u_padded)  # u_{i+1} - u_i\n        accel_nonlinear = alpha_val * (diff_u[1:]**2 - diff_u[:-1]**2)\n        \n        dvdt = accel_linear + accel_nonlinear\n        \n        return np.concatenate((dudt, dvdt))\n\n    # 4. Integrate the ODE system using a high-precision solver\n    sol = solve_ivp(\n        fput_eom, \n        [0, T_max], \n        Y0, \n        args=(N, alpha), \n        dense_output=True, \n        rtol=1e-9,  # Relative tolerance\n        atol=1e-9   # Absolute tolerance\n    )\n    \n    # 5. Post-process the solution to find recurrence\n    # Evaluate the solution on a fine time grid for analysis\n    num_eval_points = int(T_max * 20) + 1  # Use a fine grid for accuracy\n    t_eval = np.linspace(0, T_max, num_eval_points)\n    Y_t = sol.sol(t_eval)\n    \n    u_t = Y_t[:N, :]\n    v_t = Y_t[N:, :]\n    \n    # Transform to modal coordinates (q, p)\n    q_t = T_matrix @ u_t\n    p_t = T_matrix @ v_t\n    \n    # Calculate linear modal energies E_k(t)\n    # The term omega_k_sq[:, np.newaxis] ensures correct broadcasting\n    E_k_t = 0.5 * (p_t**2 + omega_k_sq[:, np.newaxis] * q_t**2)\n    \n    E1_t = E_k_t[0, :]\n    E_sum_t = np.sum(E_k_t, axis=0)\n    \n    # To prevent division by zero, although not expected for this problem\n    E_sum_t[E_sum_t == 0] = 1.0\n    \n    ratio_t = E1_t / E_sum_t\n    \n    # 6. Find the recurrence time based on the problem's definition\n    departure_threshold = 1.0 - eta\n    return_threshold = 1.0 - epsilon\n    \n    departure_observed = False\n    for i, t in enumerate(t_eval):\n        if t == 0:\n            continue\n        \n        # Check for departure condition\n        if not departure_observed and ratio_t[i] = departure_threshold:\n            departure_observed = True\n            \n        # If departed, check for return condition\n        if departure_observed and ratio_t[i] >= return_threshold:\n            return round(t, 4)  # Return first time return condition is met after departure\n            \n    return -1.0  # No recurrence found within T_max\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, alpha, A, T_max, epsilon, eta)\n        (8, 0.25, 0.3, 300, 0.1, 0.1),\n        (8, 0.0, 0.3, 100, 0.1, 0.1),\n        (8, 1.0, 0.3, 300, 0.1, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        recurrence_time = find_recurrence_time(*case)\n        results.append(recurrence_time)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2444879"}]}