{"hands_on_practices": [{"introduction": "理论学习的最佳伙伴是动手实践。本节的第一个练习将引导您解决量子力学中最基础也最重要的模型之一：一维无限深势阱，也就是“盒子中的粒子”问题。我们将从薛定谔方程出发，利用有限差分法将其转化为一个矩阵本征值问题，并构建哈密顿量矩阵。这个练习的核心不仅在于求解，更在于通过与精确解析解的比较，来量化分析数值方法的收敛速度，这是计算科学中验证模型可靠性的基石。[@problem_id:2960274]", "problem": "实现一个程序，通过离散化不含时 Schrödinger 方程来模拟区间 $[0,L]$ 上的一维无限深势阱（也称为“盒中粒子”模型）。离散化时，需使用二阶中心有限差分法来近似二阶导数，并在 $x=0$ 和 $x=L$ 处施加 Dirichlet 边界条件。从第一性原理出发，以不含时 Schrödinger 方程和无限深势阱的定义为起点，构建离散的哈密顿算符，计算其在一系列网格间距下的特征值，并将计算出的能级 $E_n$ 与从底层微分方程推导出的精确连续解进行比较。定量分析离散化误差与网格间距的关系，并估计收敛率指数。\n\n要求：\n- 物理模型：\n  - 在 $[0,L]$ 区间内，质量为 $m$ 的粒子处于无限深势阱中的不含时 Schrödinger 方程应被用作基本出发点。边界条件为 $\\psi(0)=0$ 和 $\\psi(L)=0$。\n  - 用作参考的连续能级 $E_n$ 必须通过从第一性原理出发求解此边值问题得到，不能在推理过程中引用任何未经推导的简化公式。一旦您通过推导建立了分析表达式，您的程序就可以使用它。\n- 离散化：\n  - 使用包含 $M$ 个内部点的均匀网格，网格间距为 $h=L/(M+1)$。\n  - 在内部点上应用标准的二阶中心有限差分近似来处理二阶导数，并通过从未知向量中省略边界节点来隐式地施加 Dirichlet 边界条件。\n  - 构建与内部节点上的动能算符相对应的离散哈密顿矩阵 $H$。\n- 数值计算：\n  - 对于每组指定的参数，计算第 $n$ 个离散能量 $E_n^{(h)}$，它等于离散哈密顿矩阵 $H$ 的第 $n$ 个特征值（按升序排列）。\n  - 计算绝对误差 $|E_n^{(h)}-E_n|$，其中 $E_n$ 是对应相同 $n$、$L$ 和 $m$ 的精确连续能量。\n  - 对于每个测试用例，通过改变 $M$ 来在一系列值上改变网格间距 $h$，并通过对 $\\log |E_n^{(h)}-E_n|$ 与 $\\log h$ 进行最小二乘拟合，来估计经验关系 $|E_n^{(h)}-E_n|\\approx C\\,h^p$ 中的指数 $p$。报告拟合得到的斜率 $p$。\n- 单位：\n  - 所有计算必须在国际单位制（SI）下进行。$L$ 的单位为米，$m$ 的单位为千克，能量的单位为焦耳。\n  - 使用约化普朗克常数值 $\\hbar = 1.054571817\\times 10^{-34}\\ \\mathrm{J\\cdot s}$ 和电子质量 $m_e=9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$。\n  - 当测试套件中 $L$ 以纳米为单位指定时，使用 $1\\ \\mathrm{nm}=1.0\\times 10^{-9}\\ \\mathrm{m}$ 进行转换。\n- 输出：\n  - 您的程序应产生一行输出，包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是测试用例 $i$ 的拟合斜率 $p$，四舍五入到三位小数。\n\n测试套件：\n- 使用以下用例，每个用例指定为一个元组 $\\left(L_{\\mathrm{nm}}, n, [M_1,M_2,M_3,M_4]\\right)$，其中 $L_{\\mathrm{nm}}$ 以纳米为单位，在计算中必须转换为米：\n  - 用例 1：$\\left(1.0,\\,1,\\,[20,\\,40,\\,80,\\,160]\\right)$。\n  - 用例 2：$\\left(0.5,\\,5,\\,[50,\\,100,\\,200,\\,400]\\right)$。\n  - 用例 3：$\\left(2.0,\\,1,\\,[3,\\,6,\\,12,\\,24]\\right)$。\n- 对于所有用例，使用 $m=m_e$。\n- 最终输出格式：\n  - 一行，包含三个拟合斜率的列表 $[r_1,r_2,r_3]$，每个斜率四舍五入到三位小数，无其他附加文本。", "solution": "问题陈述经评估，被确定为有效。它提出了一个计算量子力学中的标准、适定 (well-posed) 的问题，该问题在科学上是合理的、自洽的且客观的。它没有矛盾或含糊之处。因此，我将进行完整的推导和解答。\n\n任务是数值求解一维无限深势阱中粒子的不含时 Schrödinger 方程，分析离散化误差，并确定数值方法的经验收敛阶。\n\n**1. 连续问题的解析解**\n\n第一性原理是质量为 $m$ 的粒子在势 $V(x)$ 中的不含时 Schrödinger 方程：\n$$\n\\hat{H}\\psi(x) = \\left[-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right]\\psi(x) = E\\psi(x)\n$$\n对于长度为 $L$ 的无限深势阱，在定义域 $[0, L]$ 上的势 $V(x)$ 定义为：\n$$\nV(x) = \\begin{cases} 0 & \\text{if } 0  x  L \\\\ \\infty  \\text{otherwise} \\end{cases}\n$$\n边界上的无限大势能意味着粒子不能存在于区间 $(0, L)$ 之外。因此波函数 $\\psi(x)$ 的连续性要求施加 Dirichlet 边界条件：\n$$\n\\psi(0) = 0 \\quad \\text{and} \\quad \\psi(L) = 0\n$$\n在势阱内部，其中 $V(x)=0$，Schrödinger 方程简化为：\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2} = E\\psi(x)\n$$\n这个方程可以重排为经典的简谐振子方程形式：\n$$\n\\frac{d^2\\psi(x)}{dx^2} + k^2\\psi(x) = 0, \\quad \\text{where } k = \\frac{\\sqrt{2mE}}{\\hbar}\n$$\n这个二阶常微分方程的通解是：\n$$\n\\psi(x) = A\\sin(kx) + B\\cos(kx)\n$$\n应用第一个边界条件 $\\psi(0) = 0$：\n$$\n\\psi(0) = A\\sin(0) + B\\cos(0) = B = 0\n$$\n因此，解必须具有 $\\psi(x) = A\\sin(kx)$ 的形式。应用第二个边界条件 $\\psi(L) = 0$：\n$$\n\\psi(L) = A\\sin(kL) = 0\n$$\n非平凡解要求 $A \\neq 0$，这意味着 $\\sin(kL)$ 必须为零。当 $kL$ 是 $\\pi$ 的整数倍时，此条件满足：\n$$\nkL = n\\pi, \\quad \\text{for } n = 1, 2, 3, \\ldots\n$$\n量子数 $n$ 必须是正整数，因为 $n=0$ 会导致 $k=0$ 和一个平凡波函数 $\\psi(x)=0$。这使波数量子化为 $k_n = \\frac{n\\pi}{L}$。将此代入 $k$ 的定义：\n$$\n\\left(\\frac{n\\pi}{L}\\right)^2 = \\frac{2mE_n}{\\hbar^2}\n$$\n求解能量 $E_n$ 即可得到一维无限深势阱中粒子的精确、量子化的能级：\n$$\nE_n = \\frac{n^2\\pi^2\\hbar^2}{2mL^2}\n$$\n这个 $E_n$ 的解析表达式将作为精确参考，用于与数值结果进行比较。\n\n**2. Schrödinger 方程的离散化**\n\n为了数值求解该问题，我们将空间域 $[0, L]$ 离散化为一个均匀网格。我们定义 $M$ 个内部点，使得总点数为 $M+2$。网格间距为 $h = \\frac{L}{M+1}$，网格点为 $x_i = i \\cdot h$，其中 $i=0, 1, \\dots, M+1$。在这些离散点上的波函数记为 $\\psi_i = \\psi(x_i)$。边界条件明确为 $\\psi_0=0$ 和 $\\psi_{M+1}=0$。\n\n二阶导数算符 $\\frac{d^2}{dx^2}$ 在每个内部点 $x_i$ 处使用二阶中心有限差分格式进行近似：\n$$\n\\left.\\frac{d^2\\psi}{dx^2}\\right|_{x=x_i} \\approx \\frac{\\psi(x_i+h) - 2\\psi(x_i) + \\psi(x_i-h)}{h^2} = \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}\n$$\n将此近似代入内部点 $i$（其中 $i=1, \\dots, M$）的 Schrödinger 方程中：\n$$\n-\\frac{\\hbar^2}{2m} \\left( \\frac{\\psi_{i-1} - 2\\psi_i + \\psi_{i+1}}{h^2} \\right) = E^{(h)}\\psi_i\n$$\n这里，$E^{(h)}$ 表示能量特征值的数值近似，它依赖于网格间距 $h$。重排此表达式，我们得到：\n$$\n\\left(-\\frac{\\hbar^2}{2mh^2}\\right)\\psi_{i-1} + \\left(\\frac{\\hbar^2}{mh^2}\\right)\\psi_i + \\left(-\\frac{\\hbar^2}{2mh^2}\\right)\\psi_{i+1} = E^{(h)}\\psi_i\n$$\n这代表了关于未知值 $\\psi_1, \\dots, \\psi_M$ 的一个包含 $M$ 个耦合线性方程的方程组。\n\n**3. 离散哈密顿矩阵**\n\n离散化得到的方程组可以写成矩阵特征值问题 $\\mathbf{H}\\vec{\\psi} = E^{(h)}\\vec{\\psi}$。向量 $\\vec{\\psi}$ 是 $(\\psi_1, \\psi_2, \\dots, \\psi_M)^T$，$\\mathbf{H}$ 是哈密顿算符的 $M \\times M$ 矩阵表示，称为离散哈密顿量。\n\n让我们定义动能缩放因子 $T = \\frac{\\hbar^2}{2mh^2}$。每个节点 $i$ 的方程变为：\n$$\n-T\\psi_{i-1} + 2T\\psi_i - T\\psi_{i+1} = E^{(h)}\\psi_i\n$$\n使用边界条件 $\\psi_0 = 0$ 和 $\\psi_{M+1}=0$，对于 $i=1, \\dots, M$ 的方程组产生一个对称三对角矩阵 $\\mathbf{H}$：\n$$\n\\mathbf{H} = \\begin{pmatrix}\n2T  -T  0  \\cdots  0 \\\\\n-T  2T  -T  \\cdots  0 \\\\\n0  -T  2T  \\ddots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  -T \\\\\n0  0  \\cdots  -T  2T\n\\end{pmatrix}\n$$\n该矩阵 $\\mathbf{H}$ 的特征值对应于离散能级 $E_n^{(h)}$。第 $n$ 个特征值（按升序排列）是第 $n$ 个能级 $E_n$ 的数值近似。\n\n**4. 收敛性分析**\n\n中心差分格式具有 $O(h^2)$ 阶的截断误差。对于如此的自伴随特征值问题，特征值的误差预计会表现出相同的收敛阶。因此，我们预计数值能量和精确能量之间的绝对误差会随网格间距 $h$ 按如下方式缩放：\n$$\n|E_n^{(h)} - E_n| \\approx C h^p\n$$\n其中 $p$ 是收敛率指数，我们预期其值为 $2$。为了通过经验方法找到 $p$，我们对误差方程取自然对数：\n$$\n\\ln\\left(|E_n^{(h)} - E_n|\\right) \\approx \\ln(C) + p \\ln(h)\n$$\n这揭示了 $\\ln(\\text{误差})$ 与 $\\ln(h)$ 之间的线性关系。通过计算一系列减小的网格间距 $h$ （对应于增大的 $M$）的误差，并对 $(\\ln(h), \\ln(\\text{误差}))$ 数据进行线性最小二乘拟合，所得直线的斜率即为 $p$ 的一个估计值。这一过程在提供的代码中实现，以满足问题要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D particle-in-a-box problem numerically and analyzes convergence.\n    \"\"\"\n    # Define physical constants in SI units\n    HBAR = 1.054571817e-34  # Reduced Planck constant in J*s\n    M_E = 9.1093837015e-31   # Electron mass in kg\n    NM_TO_M = 1.0e-9         # Nanometer to meter conversion factor\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L_nm, n, [M_1, M_2, M_3, M_4])\n    test_cases = [\n        (1.0, 1, [20, 40, 80, 160]),\n        (0.5, 5, [50, 100, 200, 400]),\n        (2.0, 1, [3, 6, 12, 24]),\n    ]\n\n    results = []\n    \n    # Process each test case\n    for case in test_cases:\n        L_nm, n, M_list = case\n        \n        # Set parameters for the current case\n        L = L_nm * NM_TO_M  # Convert box length to meters\n        m = M_E             # Set mass to electron mass\n\n        # Calculate the exact analytical energy for level n\n        E_n_exact = (n**2 * np.pi**2 * HBAR**2) / (2 * m * L**2)\n\n        log_h_vals = []\n        log_error_vals = []\n\n        # Iterate over the specified numbers of interior grid points (M)\n        for M in M_list:\n            # Calculate grid spacing h\n            h = L / (M + 1)\n\n            # Construct the discrete Hamiltonian matrix H\n            # T is the kinetic energy scaling factor: hbar^2 / (2*m*h^2)\n            T = HBAR**2 / (2 * m * h**2)\n            \n            # The matrix H has 2T on the main diagonal and -T on the adjacent diagonals\n            main_diag = np.full(M, 2 * T)\n            off_diag = np.full(M - 1, -T)\n            H = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n            # Compute eigenvalues of the symmetric matrix H.\n            # np.linalg.eigh is efficient and returns sorted eigenvalues.\n            eigenvalues = np.linalg.eigh(H)[0]\n            \n            # The numerical energy E_n is the n-th eigenvalue (0-indexed)\n            E_n_h = eigenvalues[n - 1]\n\n            # Calculate the absolute error and store its logarithm\n            error = np.abs(E_n_h - E_n_exact)\n            log_error_vals.append(np.log(error))\n            \n            # Store the logarithm of the grid spacing\n            log_h_vals.append(np.log(h))\n\n        # Perform a linear least-squares fit on the log-log data.\n        # log(error) = p * log(h) + log(C)\n        # np.polyfit with degree 1 returns the slope (p) and intercept (log(C)).\n        p, _ = np.polyfit(log_h_vals, log_error_vals, 1)\n        results.append(p)\n\n    # Format the results to three decimal places as required.\n    rounded_results = [round(r, 3) for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, rounded_results))}]\")\n\nsolve()\n```", "id": "2960274"}, {"introduction": "掌握了基本数值求解方法后，我们可以将其作为一个“虚拟实验室”来探索更深层次的物理规律。在这个练习中，我们将研究具有对称势的量子谐振子系统。理论上，对称势的哈密顿量算符 $\\hat{H}$ 与宇称算符 $\\hat{\\Pi}$ 对易，其能量本征态因此具有确定的宇称性（偶性或奇性）。通过数值计算来验证这一基本物理原理，并观察网格的不对称性如何引入微小的“宇称破缺”误差，将加深您对物理理论和数值模拟之间关系的理解。[@problem_id:2393165]", "problem": "考虑一个质量为 $m$ 的粒子在势能 $V(x)$ 中的一维不含时薛定谔方程，\n$$\\hat{H}\\,\\psi(x) \\equiv \\left(-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right)\\psi(x) = E\\,\\psi(x).$$\n如果势能是对称的，即 $V(-x)=V(x)$，那么哈密顿算符 $\\hat{H}$ 与由 $(\\hat{\\Pi}\\psi)(x) = \\psi(-x)$ 定义的宇称算符 $\\hat{\\Pi}$ 对易。因此，每个精确的能量本征函数都可以被选择为具有确定的宇称（偶宇称或奇宇称），对于非简并能谱，宇称在相差一个全局符号的情况下是固定的。\n\n在无量纲单位制中进行计算，其中 $\\hbar=1$，$m=1$，角频率 $\\omega=1$。使用谐振子势能\n$$V(x) = \\frac{1}{2}\\,x^2.$$\n将构型空间限制在有限区间 $[-L,L]$ 内，其中 $L = 8$，并施加齐次狄利克雷边界条件 $\\psi(-L) = \\psi(L) = 0$。在此区间上，使用具有 $N$ 个内部点的均匀网格，通过有限差分法离散化哈密顿算符。设 $\\Delta x$ 为均匀网格间距。对于每个测试用例，计算能量最低的 $K$ 个能量本征对 $(E_j,\\psi_j)$，其中 $j \\in \\{0,1,\\dots,K-1\\}$，并按 $E_j$ 递增排序。将每个离散的本征矢量归一化到连续谱范数，使得\n$$\\sum_{i=1}^{N} \\left|\\psi_j(x_i)\\right|^2\\,\\Delta x = 1.$$\n对于每个归一化的本征矢量，定义离散宇称重叠\n$$P_j \\equiv \\sum_{i=1}^{N} \\psi_j(x_i)\\,\\psi_j(-x_i)\\,\\Delta x,$$\n由于在 $[-L,L]$ 上构造的具有 $N$ 个内部点的均匀网格的特性，点 $-x_i$ 与某个网格点重合，该求和通过配对镜像索引来计算。在对称哈密顿算符的精确计算中，对于偶宇称本征函数，我们期望 $P_j = +1$，对于奇宇称本征函数，我们期望 $P_j = -1$。将态 $j$ 的宇称破缺误差定义为\n$$\\varepsilon_j \\equiv 1 - |P_j|,$$\n并为给定的测试用例定义\n$$\\varepsilon_{\\max} \\equiv \\max_{0 \\le j \\le K-1} \\varepsilon_j.$$\n同时定义一个布尔指示符 $A$，当且仅当对于 $j=0,1,\\dots,K-1$，$P_j$ 的符号序列 $\\mathrm{sgn}(P_j)$ 以 $+1,-1,+1,-1,\\dots$ 的形式交替时，该指示符为真。\n\n编写一个完整的程序，使用二阶有限差分法在均匀网格上对以下测试集（所有用例中 $K=4$ 固定）执行上述计算：\n- 测试用例 1：$N=101$。\n- 测试用例 2：$N=100$。\n- 测试用例 3：$N=1200$。\n\n所有计算都必须在所述的无量纲单位制中执行。您的程序必须生成单行输出，其中包含聚合结果，格式为方括号内的逗号分隔列表，顺序如下：\n$$[\\;A_1,\\ \\varepsilon_{\\max,1},\\ A_2,\\ \\varepsilon_{\\max,2},\\ A_3,\\ \\varepsilon_{\\max,3}\\;],$$\n其中 $A_t$ 和 $\\varepsilon_{\\max,t}$ 分别表示测试用例 $t \\in \\{1,2,3\\}$ 的交替布尔值和最大宇称破缺误差。布尔值必须是字面值，误差必须是实数。不应打印任何额外文本。", "solution": "所提出的问题要求对量子谐振子的一维不含时薛定谔方程进行数值求解。其控制方程为\n$$ \\hat{H}\\,\\psi(x) = \\left(-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right)\\psi(x) = E\\,\\psi(x) $$\n我们在一个无量纲系统中进行操作，其中 $\\hbar=1$ 且 $m=1$。势能为谐振子势能 $V(x) = \\frac{1}{2}x^2$。该问题定义在有限区间 $x \\in [-L, L]$ 上，其中 $L=8$，并受齐次狄利克雷边界条件 $\\psi(-L) = \\psi(L) = 0$ 的约束。\n\n主要任务是使用二阶有限差分法在均匀网格上离散化这个连续问题，并分析所得数值本征函数的宇称性质。在区间 $[-L, L]$ 上构建一个具有 $N$ 个内部点的均匀网格。包括两个边界点在内，该网格共有 $N+2$ 个点，网格间距为 $\\Delta x = \\frac{2L}{N+1}$。内部网格点位于 $x_i = -L + i\\Delta x$，其中 $i \\in \\{1, 2, \\dots, N\\}$。\n\n在网格点 $x_i$ 处波函数的二阶导数由二阶中心差分公式近似：\n$$ \\frac{d^2\\psi}{dx^2}\\bigg|_{x_i} \\approx \\frac{\\psi(x_{i-1}) - 2\\psi(x_i) + \\psi(x_{i+1})}{(\\Delta x)^2} $$\n将此式代入薛定谔方程，并令 $\\psi_i = \\psi(x_i)$，我们得到一个关于内部点的线性方程组：\n$$ -\\frac{1}{2(\\Delta x)^2} (\\psi_{i-1} - 2\\psi_i + \\psi_{i+1}) + V(x_i)\\psi_i = E\\psi_i $$\n该系统可以表示为矩阵本征值问题 $H\\vec{\\psi} = E\\vec{\\psi}$，其中 $\\vec{\\psi}$ 是由波函数值组成的列向量 $(\\psi_1, \\psi_2, \\dots, \\psi_N)^T$。$N \\times N$ 的离散化哈密顿矩阵 $H$ 是一个实对称三对角矩阵，其元素为：\n$$\nH_{ij} =\n\\begin{cases}\n\\frac{1}{(\\Delta x)^2} + V(x_i)  \\text{if } i=j \\\\\n-\\frac{1}{2(\\Delta x)^2}  \\text{if } |i-j|=1 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n边界条件 $\\psi_0 = \\psi(-L) = 0$ 和 $\\psi_{N+1} = \\psi(L) = 0$ 被并入 $i=1$ 和 $i=N$ 的方程中。\n\n此本征值问题通过数值方法求解，以找到能量最低的 $K=4$ 个本征对 $(E_j, \\vec{\\psi}_j)$。用于对称矩阵的标准数值本征求解器，如 `scipy.linalg.eigh`，返回根据欧几里得L2范数归一化的本征矢量，即 $\\sum_{i=1}^{N} |v_{j,i}|^2 = 1$。问题要求归一化到连续谱范数，即 $\\sum_{i=1}^{N} |\\psi_{j,i}|^2 \\Delta x = 1$。如果 $v_j$ 是从求解器得到的本征矢量，则正确归一化的本征矢量是 $\\psi_j = v_j / \\sqrt{\\Delta x}$。\n\n利用归一化的本征矢量，我们计算离散宇称重叠 $P_j$。网格的构建方式使得对于任何点 $x_i$，其反射点 $-x_i$ 也是一个网格点，具体来说是 $-x_i = x_{N+1-i}$。重叠定义为：\n$$ P_j = \\sum_{i=1}^{N} \\psi_j(x_i)\\,\\psi_j(-x_i)\\,\\Delta x = \\sum_{i=1}^{N} \\psi_{j,i}\\,\\psi_{j,N+1-i}\\,\\Delta x $$\n代入归一化关系 $\\psi_{j,i} = v_{j,i}/\\sqrt{\\Delta x}$，我们得到一个更简单的计算表达式：\n$$ P_j = \\sum_{i=1}^{N} \\frac{v_{j,i}}{\\sqrt{\\Delta x}}\\frac{v_{j,N+1-i}}{\\sqrt{\\Delta x}}\\Delta x = \\sum_{i=1}^{N} v_{j,i}\\,v_{j,N+1-i} $$\n这是求解器输出的本征矢量 $v_j$ 与其反转版本的点积。\n\n对于对称势的真实本征函数，宇称是确定的，这意味着 $P_j$ 将恰好为 $+1$（偶）或 $-1$（奇）。数值离散化，特别是在一个关于原点非点对称的网格上（当 $N$ 为偶数时发生），可能会引入破坏这种对称性的误差。宇称破缺误差由 $\\varepsilon_j = 1 - |P_j|$ 来量化。我们计算前 $K=4$ 个态中该误差的最大值 $\\varepsilon_{\\max}$。\n\n最后，我们确定布尔指示符 $A$，当且仅当对于前 $K=4$ 个态，其宇称重叠的符号遵循谐振子预期的交替序列时，该指示符为真：$\\mathrm{sgn}(P_0)=+1$, $\\mathrm{sgn}(P_1)=-1$, $\\mathrm{sgn}(P_2)=+1$, $\\mathrm{sgn}(P_3)=-1$。\n\n该算法针对三个测试用例执行：$N=101$（奇数点，网格包含原点）、$N=100$（偶数）和 $N=1200$（偶数）。每个用例的结果 $[A, \\varepsilon_{\\max}]$ 被汇总到一个单一的输出列表中。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [101, 100, 1200]\n    L = 8.0\n    K = 4\n    \n    all_results = []\n\n    for N in test_cases:\n        # Step 1: Set up the grid and potential\n        dx = (2 * L) / (N + 1)\n        x_interior = np.linspace(-L + dx, L - dx, N)\n        V_interior = 0.5 * x_interior**2\n\n        # Step 2: Construct the Hamiltonian matrix H\n        diag_elements = 1.0 / (dx**2) + V_interior\n        off_diag_element = -1.0 / (2 * dx**2)\n        \n        H = np.diag(diag_elements)\n        H += np.diag(np.full(N - 1, off_diag_element), k=1)\n        H += np.diag(np.full(N - 1, off_diag_element), k=-1)\n\n        # Step 3: Solve the eigenvalue problem\n        # eigh is for Hermitian matrices and returns sorted eigenvalues\n        # and corresponding eigenvectors as columns.\n        # Eigenvectors are L2-normalized: sum(v_i^2) = 1.\n        eigenvalues, eigenvectors = eigh(H)\n\n        parities = []\n        errors = []\n\n        # Step 4: Analyze the lowest K eigenvectors\n        for j in range(K):\n            # v_j is the eigenvector from the solver\n            v_j = eigenvectors[:, j]\n\n            # As derived, P_j = sum(v_j * reversed(v_j))\n            # The indexing v_j[::-1] reverses the vector.\n            P_j = np.sum(v_j * v_j[::-1])\n            parities.append(P_j)\n\n            # Calculate the parity-breaking error\n            error_j = 1.0 - np.abs(P_j)\n            errors.append(error_j)\n\n        # Step 5: Calculate aggregated results for the test case\n        eps_max = np.max(errors)\n        \n        # Check for the specific alternating sign sequence +1, -1, +1, -1...\n        signs = np.sign(parities)\n        expected_signs = np.array([(-1)**j for j in range(K)])\n        \n        A = np.array_equal(signs, expected_signs)\n\n        all_results.extend([A, eps_max])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2393165"}, {"introduction": "在实际的科学研究中，我们往往只对系统的某个或某几个特定能态感兴趣，而对整个哈密顿量矩阵进行完全对角化来求解所有本征态，在计算上是低效甚至不可行的。本练习将介绍一种更高级、更高效的算法：带位移的逆迭代法。您将学习如何使用这种方法，通过一个巧妙选择的能量“位移” $\\sigma$，来精确并快速地找到离它最近的那个高能本征态。掌握这种目标明确的求解策略，是从“能算”到“会算”的关键一步，对于处理大规模计算问题至关重要。[@problem_id:2393207]", "problem": "要求您使用有限差分离散化和带位移的反向迭代算法，在不进行完全对角化的情况下，计算一维定态薛定谔哈密顿量的一个特定的高能束缚态本征值。请完全在无量纲单位下进行计算，此时不含时薛定谔方程为 $-\\frac{d^{2}\\psi}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x)$，并在区域端点处采用狄利克雷边界条件。您的任务是：(i) 在均匀网格上推导出一个相容的二阶中心有限差分离散格式，该格式能产生一个实对称三对角哈密顿矩阵；(ii) 实现带实数位移的反向迭代算法，以求解所需的目标高能本征对；(iii) 将您的实现应用于下面的测试集，并报告所要求的数值。\n\n请从以下基础出发：无量纲单位下的不含时薛定谔方程 $-\\frac{d^{2}\\psi}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x)$，狄利克雷边界条件 $\\psi(x_{\\min})=\\psi(x_{\\max})=0$ 的定义，以及在均匀网格上二阶导数由邻近网格点值的线性组合来近似的标准中心有限差分思想。不要假设任何预先推导好的离散哈密顿量，而应根据这些原理和定义明确地推导它。您必须解释如何在离散系统中施加边界条件。\n\n实现带标量位移 $\\,\\sigma\\,$ 的反向迭代法，以求解最接近 $\\,\\sigma\\,$ 的一个本征对 $(E,\\psi)$，方法如下：选择一个初始非零向量，重复求解线性方程组 $(H-\\sigma I)\\,y^{(k)} = x^{(k)}$，归一化 $x^{(k+1)} = y^{(k)}/\\|y^{(k)}\\|_{2}$，并在每次迭代中通过瑞利商 $\\rho^{(k)} = \\frac{(x^{(k)})^{T} H x^{(k)}}{(x^{(k)})^{T} x^{(k)}}$ 估算本征值。使用残差范数 $\\|H x^{(k)} - \\rho^{(k)} x^{(k)}\\|_{2}$ 作为停止判据。您的实现必须利用 $H$ 的稀疏和三对角特性。\n\n您必须将程序应用于以下测试集。在每种情况下，均在闭区间 $[x_{\\min},x_{\\max}]$ 上使用一个包含 $N$ 个内部点的均匀网格，并采用狄利克雷边界条件。在内部网格上逐点构造 $V(x)$。使用指定的位移 $\\,\\sigma\\,$，并返回收敛的瑞利商作为数值本征值估计 $\\widehat{E}$。\n\n- 测试 A (无限深势阱中的粒子，有解析谱)：$[x_{\\min},x_{\\max}] = [0,1]$，$N = 600$，$V(x) \\equiv 0$，目标量子数 $n = 30$，位移 $\\sigma = \\left(\\frac{n\\pi}{x_{\\max}-x_{\\min}}\\right)^{2}$。精确的连续谱能量为 $E_{n} = \\left(\\frac{n\\pi}{x_{\\max}-x_{\\min}}\\right)^{2}$。为此测试报告两个数：数值本征值 $\\widehat{E}_{\\mathrm{box}}$ 和绝对误差 $|\\widehat{E}_{\\mathrm{box}}-E_{n}|$。\n- 测试 B (谐振子，有解析谱)：$[x_{\\min},x_{\\max}] = [-8,8]$，$N = 800$，$V(x) = x^{2}$，目标量子数 $n = 25$，位移 $\\sigma = 2n+1$。精确的连续谱能量为 $E_{n} = 2n+1$。报告两个数：数值本征值 $\\widehat{E}_{\\mathrm{ho}}$ 和绝对误差 $|\\widehat{E}_{\\mathrm{ho}}-E_{n}|$。\n- 测试 C (双势阱，不要求解析谱)：$[x_{\\min},x_{\\max}] = [-6,6]$，$N = 800$，$V(x) = (x^{2}-4)^{2}$，位移 $\\sigma = 30$。报告一个数：数值本征值 $\\widehat{E}_{\\mathrm{dw}}$。\n\n您的程序必须输出单行，其中包含一个逗号分隔的 Python 风格列表，结果按以下顺序排列：\n$[\\widehat{E}_{\\mathrm{box}},\\ |\\widehat{E}_{\\mathrm{box}}-E_{n}|,\\ \\widehat{E}_{\\mathrm{ho}},\\ |\\widehat{E}_{\\mathrm{ho}}-E_{n}|,\\ \\widehat{E}_{\\mathrm{dw}}]$。\n所有五个条目都必须是实数。由于问题已完全无量纲化，因此不需要物理单位。最后一行必须精确地打印为表示该列表的文本（例如，$[1.0,2.0,3.0,4.0,5.0]$）。", "solution": "该问题是计算量子力学中的一个标准练习，其提法是恰当的、有科学依据且内部一致的。我们将首先从基本原理出发推导必要的离散形式，然后概述用于实现的数值算法，从而解决该问题。\n\n目标是求解一维无量纲不含时薛定谔方程特定本征对 $(E, \\psi)$ 的数值近似解：\n$$\n-\\frac{d^2\\psi}{dx^2} + V(x)\\psi(x) = E\\psi(x)\n$$\n波函数 $\\psi(x)$ 满足狄利克雷边界条件，即 $\\psi(x_{\\min}) = 0$ 和 $\\psi(x_{\\max}) = 0$。\n\n**第一部分：哈密顿量的有限差分离散化**\n\n我们首先将连续微分算符，即哈密顿量 $H = -\\frac{d^2}{dx^2} + V(x)$，转换为离散的矩阵表示。我们在定义域 $[x_{\\min}, x_{\\max}]$ 上定义一个均匀网格。假设有 $N$ 个内部网格点。这将区间划分为 $N+1$ 个等宽的子区间。因此，网格间距为 $h = (x_{\\max} - x_{\\min})/(N+1)$。网格点位于 $x_j = x_{\\min} + j \\cdot h$，其中 $j = 0, 1, \\dots, N+1$。我们要求解波函数的内部点是 $x_1, \\dots, x_N$。波函数在网格点 $x_j$ 的值表示为 $\\psi_j \\equiv \\psi(x_j)$。边界条件施加了 $\\psi_0 = 0$ 和 $\\psi_{N+1} = 0$。\n\n二阶导数算符 $\\frac{d^2}{dx^2}$ 使用二阶中心差分公式进行近似。该公式由 $\\psi(x)$ 在点 $x_j$ 附近的泰勒级数展开推导而来：\n$$\n\\psi(x_j \\pm h) = \\psi(x_j) \\pm h\\frac{d\\psi}{dx}\\bigg|_{x_j} + \\frac{h^2}{2!}\\frac{d^2\\psi}{dx^2}\\bigg|_{x_j} \\pm \\frac{h^3}{3!}\\frac{d^3\\psi}{dx^3}\\bigg|_{x_j} + O(h^4)\n$$\n将 $\\psi(x_j+h)$ 和 $\\psi(x_j-h)$ 的表达式相加，奇数阶导数项会相互抵消：\n$$\n\\psi(x_j+h) + \\psi(x_j-h) = 2\\psi(x_j) + h^2\\frac{d^2\\psi}{dx^2}\\bigg|_{x_j} + O(h^4)\n$$\n整理后得到二阶导数的近似表达式：\n$$\n\\frac{d^2\\psi}{dx^2}\\bigg|_{x_j} = \\frac{\\psi(x_{j+1}) - 2\\psi(x_j) + \\psi(x_{j-1})}{h^2} + O(h^2)\n$$\n这是一个二阶精确的近似。将其代入每个内部网格点 $x_j$ （其中 $j=1, \\dots, N$）的薛定谔方程中：\n$$\n-\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{h^2} + V(x_j)\\psi_j = E\\psi_j\n$$\n重新整理此方程，将与线性算符相关的项分离到左侧：\n$$\n-\\frac{1}{h^2}\\psi_{j-1} + \\left(\\frac{2}{h^2} + V_j\\right)\\psi_j - \\frac{1}{h^2}\\psi_{j+1} = E\\psi_j\n$$\n其中我们定义 $V_j \\equiv V(x_j)$。这个由 $N$ 个线性方程组成的方程组可以写成矩阵本征值形式 $H\\vec{\\psi} = E\\vec{\\psi}$，其中 $\\vec{\\psi} = [\\psi_1, \\psi_2, \\dots, \\psi_N]^T$ 是内部点上波函数值的向量。\n\n我们来考察邻近边界的点的方程：\n对于 $j=1$：$-\\frac{1}{h^2}\\psi_0 + (\\frac{2}{h^2} + V_1)\\psi_1 - \\frac{1}{h^2}\\psi_2 = E\\psi_1$。由于 $\\psi_0=0$，方程变为 $(\\frac{2}{h^2} + V_1)\\psi_1 - \\frac{1}{h^2}\\psi_2 = E\\psi_1$。\n对于 $j=N$：$-\\frac{1}{h^2}\\psi_{N-1} + (\\frac{2}{h^2} + V_N)\\psi_N - \\frac{1}{h^2}\\psi_{N+1} = E\\psi_N$。由于 $\\psi_{N+1}=0$，方程变为 $-\\frac{1}{h^2}\\psi_{N-1} + (\\frac{2}{h^2} + V_N)\\psi_N = E\\psi_N$。\n\n这些方程定义了 $N \\times N$ 离散哈密顿矩阵 $H$ 的元素：\n-   对角元素：$H_{j,j} = \\frac{2}{h^2} + V_j$，其中 $j=1, \\dots, N$。\n-   非对角元素：$H_{j,j+1} = H_{j+1,j} = -\\frac{1}{h^2}$，其中 $j=1, \\dots, N-1$。\n-   所有其他元素均为零。\n\n由此得到的矩阵 $H$ 是一个实对称三对角矩阵，符合要求。\n\n**第二部分：带位移的反向迭代算法**\n\n为了找到一个特定的本征对 $(E, \\vec{\\psi})$，使其本征值 $E$ 最接近给定的实数位移 $\\sigma$，我们采用带位移的反向迭代算法。这是一种强大的技术，可以避免对矩阵 $H$ 进行计算成本高昂的完全对角化。该方法等效于对矩阵 $(H - \\sigma I)^{-1}$ 应用幂迭代法。$(H - \\sigma I)^{-1}$ 的本征值为 $(\\lambda_i - \\sigma)^{-1}$，其中 $\\lambda_i$ 是 $H$ 的本征值。对应于模最大的本征值 $(\\lambda_k - \\sigma)^{-1}$ 的本征向量，与 $H$ 的对应于最接近 $\\sigma$ 的本征值 $\\lambda_k$ 的本征向量是相同的。\n\n该算法流程如下：\n1.  选择一个大小为 $N$ 的初始非零随机向量 $\\vec{x}^{(0)}$。将其归一化：$\\vec{x}^{(0)} \\leftarrow \\vec{x}^{(0)}/\\|\\vec{x}^{(0)}\\|_2$。\n2.  从 $k=0, 1, 2, \\dots$ 开始迭代，直至收敛：\n    a. 求解线性方程组 $(H - \\sigma I)\\vec{y}^{(k)} = \\vec{x}^{(k)}$，得到向量 $\\vec{y}^{(k)}$。\n    b. 归一化结果向量，以获得本征向量的下一个近似值：$\\vec{x}^{(k+1)} = \\vec{y}^{(k)}/\\|\\vec{y}^{(k)}\\|_2$。\n3.  向量序列 $\\vec{x}^{(k)}$ 收敛于所求的本征向量。\n\n矩阵 $A = H - \\sigma I$ 也是三对角且对称的。关键步骤是求解 $A\\vec{y}^{(k)} = \\vec{x}^{(k)}$，这个步骤可以使用专门的三对角求解器（如 Thomas 算法）在 $O(N)$ 时间复杂度内高效完成，而不是采用通用的 $O(N^3)$ 矩阵求逆方法。\n\n在每次迭代 $k$ 中，相应的本征值 $E$ 使用瑞利商进行估算：\n$$\n\\rho^{(k+1)} = \\frac{(\\vec{x}^{(k+1)})^T H \\vec{x}^{(k+1)}}{(\\vec{x}^{(k+1)})^T \\vec{x}^{(k+1)}} = (\\vec{x}^{(k+1)})^T H \\vec{x}^{(k+1)}\n$$\n第二个等号成立，因为 $\\vec{x}^{(k+1)}$ 是单位归一化的。\n\n当状态不再发生显著变化时，即达到收敛。一个稳健的停止判据是残差向量的范数小于一个很小的容差 $\\epsilon$：\n$$\n\\|H\\vec{x}^{(k+1)} - \\rho^{(k+1)}\\vec{x}^{(k+1)}\\|_2  \\epsilon\n$$\n对于实现而言，量级为 $\\epsilon = 10^{-12}$ 的容差是合适的。\n\n**第三部分：应用于测试案例**\n\n现在将推导出的方法应用于三个指定的测试案例。对于每个案例，我们构造网格、势能向量 $V_j$ 和三对角哈密顿量 $H$。然后，使用给定的位移 $\\sigma$，我们执行反向迭代算法以找到收敛的瑞利商，它就是我们的数值本征值估计 $\\widehat{E}$。对于测试 A 和 B，将此数值结果与已知的解析能量进行比较，以计算绝对误差。实现中将使用为三对角系统优化的库函数，以确保计算效率。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef compute_eigenvalue(\n    x_min: float,\n    x_max: float,\n    N: int,\n    V_func,\n    sigma: float,\n    max_iter: int = 100,\n    tolerance: float = 1e-12,\n):\n    \"\"\"\n    Computes an eigenvalue of the 1D Schrödinger equation near a shift sigma.\n\n    Args:\n        x_min: Minimum of the spatial domain.\n        x_max: Maximum of the spatial domain.\n        N: Number of interior grid points.\n        V_func: A function that takes a numpy array of x values and returns the potential.\n        sigma: The energy shift for the inverse iteration.\n        max_iter: Maximum number of iterations.\n        tolerance: Convergence tolerance for the residual norm.\n\n    Returns:\n        The converged eigenvalue estimate.\n    \"\"\"\n    # 1. Set up the grid\n    h = (x_max - x_min) / (N + 1)\n    x_grid = np.linspace(x_min, x_max, N + 2)[1:-1] # Interior points\n\n    # 2. Construct the Hamiltonian matrix H's diagonals\n    V_values = V_func(x_grid)\n    main_diag_H = 2.0 / h**2 + V_values\n    off_diag_H_val = -1.0 / h**2\n\n    # 3. Set up the matrix for the linear system in inverse iteration: A = H - sigma*I\n    # Scipy's solve_banded requires the matrix in a specific banded format.\n    # For a symmetric tridiagonal matrix (l=1, u=1), the 'ab' array has shape (2, N).\n    # ab[0, 1:] is the upper diagonal, ab[1, :] is the main diagonal.\n    # Since our matrix H - sigma*I is symmetric, we can represent it this way.\n    # However, for clarity and generality, we use the (l+u+1, N) format where l=1, u=1.\n    ab_shifted = np.zeros((3, N))\n    ab_shifted[0, 1:] = off_diag_H_val  # Super-diagonal\n    ab_shifted[1, :]  = main_diag_H - sigma  # Main diagonal\n    ab_shifted[2, :-1] = off_diag_H_val  # Sub-diagonal\n    \n    # 4. Inverse Iteration\n    # Initialize a random normalized vector\n    x_k = np.random.rand(N)\n    x_k /= np.linalg.norm(x_k)\n\n    converged_eigenvalue = 0.0\n    for _ in range(max_iter):\n        # a. Solve (H - sigma*I) * y_k = x_k\n        y_k = solve_banded((1, 1), ab_shifted, x_k)\n\n        # b. Normalize to get the next eigenvector approximation\n        norm_y = np.linalg.norm(y_k)\n        if norm_y == 0:\n            # This should not happen with a proper shift\n            raise RuntimeError(\"Norm of iterate is zero, cannot normalize.\")\n        x_k_plus_1 = y_k / norm_y\n        \n        # c. Calculate Rayleigh quotient for the eigenvalue estimate\n        # H*x can be calculated efficiently without forming the full matrix H\n        Hx = np.zeros(N)\n        Hx[1:-1] = (off_diag_H_val * x_k_plus_1[:-2] +\n                    main_diag_H[1:-1] * x_k_plus_1[1:-1] +\n                    off_diag_H_val * x_k_plus_1[2:])\n        Hx[0] = main_diag_H[0] * x_k_plus_1[0] + off_diag_H_val * x_k_plus_1[1]\n        Hx[-1] = off_diag_H_val * x_k_plus_1[-2] + main_diag_H[-1] * x_k_plus_1[-1]\n        \n        rho = np.dot(x_k_plus_1, Hx)\n        converged_eigenvalue = rho\n\n        # d. Check for convergence using the residual norm\n        residual_norm = np.linalg.norm(Hx - rho * x_k_plus_1)\n        if residual_norm  tolerance:\n            break\n\n        x_k = x_k_plus_1\n    \n    return converged_eigenvalue\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    results = []\n\n    # Test A: Particle in a box\n    x_min_a, x_max_a = 0.0, 1.0\n    N_a = 600\n    n_a = 30\n    V_a = lambda x: 0.0 * x  # Potential is zero everywhere\n    L_a = x_max_a - x_min_a\n    E_analytic_a = (n_a * np.pi / L_a)**2\n    sigma_a = E_analytic_a\n    \n    E_hat_box = compute_eigenvalue(x_min_a, x_max_a, N_a, V_a, sigma_a)\n    error_box = abs(E_hat_box - E_analytic_a)\n    results.append(E_hat_box)\n    results.append(error_box)\n    \n    # Test B: Harmonic oscillator\n    x_min_b, x_max_b = -8.0, 8.0\n    N_b = 800\n    n_b = 25\n    V_b = lambda x: x**2\n    E_analytic_b = 2.0 * n_b + 1.0\n    sigma_b = E_analytic_b\n    \n    E_hat_ho = compute_eigenvalue(x_min_b, x_max_b, N_b, V_b, sigma_b)\n    error_ho = abs(E_hat_ho - E_analytic_b)\n    results.append(E_hat_ho)\n    results.append(error_ho)\n\n    # Test C: Double well potential\n    x_min_c, x_max_c = -6.0, 6.0\n    N_c = 800\n    V_c = lambda x: (x**2 - 4.0)**2\n    sigma_c = 30.0\n\n    E_hat_dw = compute_eigenvalue(x_min_c, x_max_c, N_c, V_c, sigma_c)\n    results.append(E_hat_dw)\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2393207"}]}