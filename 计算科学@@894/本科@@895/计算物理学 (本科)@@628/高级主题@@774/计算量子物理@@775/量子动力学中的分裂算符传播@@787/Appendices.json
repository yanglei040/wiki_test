{"hands_on_practices": [{"introduction": "我们将从最基础的量子系统——自由粒子——开始。这项练习将指导你数值模拟一个高斯波包的含时演化过程。通过追踪其在位置和动量上的不确定度，你将直接观察到量子力学基石之一的海森堡不确定性原理的体现，从而巩固你对物理概念和分裂算符谱方法（split-operator spectral method）的理解 [@problem_id:2452266]。", "problem": "考虑一个一维、非相对论、无自旋的量子粒子，质量为 $m$，被限制在长度为 $L$ 的周期性区间内，使用哈特里原子单位制（因此 $\\hbar=1$ 且 $m=1$）。其动力学由含时薛定谔方程决定\n$$\ni \\,\\frac{\\partial}{\\partial t}\\,\\psi(x,t) \\;=\\; \\hat{H}\\,\\psi(x,t), \\qquad \\hat{H} \\;=\\; \\frac{\\hat{p}^2}{2 m}, \\qquad \\hat{p} \\;=\\; -\\,i\\,\\frac{\\partial}{\\partial x},\n$$\n在区间 $x\\in[-L/2,L/2)$ 上满足周期性边界条件。初始波函数为归一化的的高斯波包\n$$\n\\psi(x,0) \\;=\\; \\left(\\frac{1}{2\\pi\\,\\sigma_x^2}\\right)^{1/4}\\,\\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\,\\sigma_x^2}\\right)\\,\\exp\\!\\left(i\\,p_0\\,(x-x_0)\\right),\n$$\n其中位置空间宽度参数为 $\\sigma_x>0$，平均位置为 $x_0$，平均动量为 $p_0$。\n\n对于每个时间 $t$，定义位置和动量的期望值与方差如下：\n$$\n\\langle x\\rangle_t \\;=\\; \\int_{-L/2}^{L/2} \\psi^*(x,t)\\,x\\,\\psi(x,t)\\,dx,\\quad\n\\langle x^2\\rangle_t \\;=\\; \\int_{-L/2}^{L/2} \\psi^*(x,t)\\,x^2\\,\\psi(x,t)\\,dx,\n$$\n$$\n\\langle p\\rangle_t \\;=\\; \\int_{-L/2}^{L/2} \\psi^*(x,t)\\,\\Big(-i\\,\\frac{\\partial}{\\partial x}\\Big)\\,\\psi(x,t)\\,dx,\\quad\n\\langle p^2\\rangle_t \\;=\\; \\int_{-L/2}^{L/2} \\psi^*(x,t)\\,\\Big(-\\frac{\\partial^2}{\\partial x^2}\\Big)\\,\\psi(x,t)\\,dx,\n$$\n以及相关的标准差\n$$\n\\Delta x(t) \\;=\\; \\sqrt{\\langle x^2\\rangle_t - \\langle x\\rangle_t^2},\\qquad\n\\Delta p(t) \\;=\\; \\sqrt{\\langle p^2\\rangle_t - \\langle p\\rangle_t^2}.\n$$\n所有量均采用原子单位制；时间必须以原子时间单位处理，动量以原子动量单位处理，长度以玻尔半径处理。海森堡不确定性原理指出，对于所有 $t$，\n$$\n\\Delta x(t)\\,\\Delta p(t) \\;\\ge\\; \\frac{1}{2}.\n$$\n\n任务：对于以下参数集的测试套件，使用在 $[-L/2,L/2)$ 上有 $N$ 个格点的空间离散化方法，根据上述薛定谔方程在周期性域上精确演化 $\\psi(x,t)$。对于每个参数集，计算在指定时间 $\\{t_k\\}$ 处的值列表 $\\{\\Delta x(t_k)\\,\\Delta p(t_k)\\}$，然后计算最小值 $S=\\min_k \\Delta x(t_k)\\,\\Delta p(t_k)$，并使用数值容差 $\\tau=10^{-3}$ 将其与 $1/2$进行比较。对于每个测试案例，返回布尔值 $S \\ge 1/2 - \\tau$。\n\n使用以下测试套件，其中所有数字均以原子单位制表示：\n- 案例 1：$L=100.0$, $N=4096$, $\\sigma_x=1.0$, $x_0=0.0$, $p_0=0.0$, 时间 $t\\in\\{0.0,\\,1.0,\\,2.0,\\,5.0,\\,10.0\\}$。\n- 案例 2：$L=100.0$, $N=4096$, $\\sigma_x=0.2$, $x_0=0.0$, $p_0=0.0$, 时间 $t\\in\\{0.0,\\,0.2,\\,0.5,\\,1.0,\\,2.0\\}$。\n- 案例 3：$L=100.0$, $N=4096$, $\\sigma_x=3.0$, $x_0=-10.0$, $p_0=2.0$, 时间 $t\\in\\{0.0,\\,1.0,\\,5.0,\\,10.0,\\,20.0\\}$。\n- 案例 4：$L=100.0$, $N=4096$, $\\sigma_x=0.5$, $x_0=20.0$, $p_0=5.0$, 时间 $t\\in\\{0.0,\\,0.5,\\,1.0,\\,2.0,\\,5.0\\}$。\n\n最终输出格式：你的程序应生成单行输出，其中包含案例1到4的布尔结果的逗号分隔列表，并用方括号括起来，不含空格，例如，\"[True,False,True,True]\"。", "solution": "问题陈述已解析和验证。\n\n已知条件：\n一个一维、非相对论、无自旋的量子粒子，质量 $m=1$，采用哈特里原子单位制，其中 $\\hbar=1$。该粒子被限制在由 $x \\in [-L/2, L/2)$ 定义的长度为 $L$ 的周期性区间内。其控制方程是含时薛定谔方程（TDSE）：\n$$\ni \\,\\frac{\\partial}{\\partial t}\\,\\psi(x,t) \\;=\\; \\hat{H}\\,\\psi(x,t)\n$$\n其自由粒子哈密顿量为：\n$$\n\\hat{H} \\;=\\; \\frac{\\hat{p}^2}{2 m}, \\qquad \\hat{p} \\;=\\; -\\,i\\,\\frac{\\partial}{\\partial x}\n$$\n$t=0$ 时的初始态是归一化的高斯波包：\n$$\n\\psi(x,0) \\;=\\; \\left(\\frac{1}{2\\pi\\,\\sigma_x^2}\\right)^{1/4}\\,\\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\,\\sigma_x^2}\\right)\\,\\exp\\!\\left(i\\,p_0\\,(x-x_0)\\right)\n$$\n可观测量由在定义域 $[-L/2, L/2)$ 上的标准期望值积分定义。位置和动量的标准差分别为 $\\Delta x(t)$ 和 $\\Delta p(t)$。任务是数值演化该系统，在指定时间 $t_k$ 计算不确定性乘积 $\\Delta x(t_k)\\,\\Delta p(t_k)$，找出最小值 $S = \\min_k \\Delta x(t_k)\\,\\Delta p(t_k)$，并验证对于容差 $\\tau=10^{-3}$ 是否有 $S \\ge 1/2 - \\tau$。提供了四个具有特定参数（$L, N, \\sigma_x, x_0, p_0, \\{t_k\\}$）的测试案例。\n\n验证结论：\n该问题在科学上和数学上是合理的。它描述了量子动力学中的一个基本问题：自由粒子的时间演化。所有概念、方程和参数都定义明确，并与量子力学原理一致。要求“精确演化……使用空间离散化”被理解为使用谱方法，如分裂算符傅里叶方法。对于自由粒子，该方法对于离散化系统是数值精确的。该问题是适定的、客观的且计算上可行的。初始高斯形式定义在无限域上，但对于给定的参数，它很好地局域在周期性盒子内，因此将其用作周期域上的初始状态是有效的近似。我们将着手求解。\n\n基于原理的求解设计：\n\n含时薛定谔方程的解 $\\psi(x,t) = e^{-i\\hat{H}t}\\psi(x,0)$，可以使用谱方法在动量本征态基底上高效计算。哈密顿量 $\\hat{H} = \\hat{p}^2/(2m)$ 在动量（傅里叶）基下是对角的。在长度为 $L$ 的周期域上，动量算符的本征函数是平面波 $\\phi_k(x) = \\frac{1}{\\sqrt{L}} e^{ikx}$，其中波矢 $k$ 被量子化为 $k_n = 2\\pi n/L$（$n$ 为整数）。\n\n哈密顿量在这些基态上的作用是简单的乘法：$\\hat{H} \\phi_k(x) = \\frac{k^2}{2m} \\phi_k(x)$。因此，时间演化算符 $e^{-i\\hat{H}t}$ 在此基底上的作用也是简单的乘法：$e^{-i\\hat{H}t} \\phi_k(x) = e^{-i\\frac{k^2}{2m}t} \\phi_k(x)$。\n\n被称为分裂算符傅里叶方法的数值算法，通过快速傅里叶变换（FFT）利用了这一特性，FFT能高效地在位置和动量表象之间转换波函数。\n\n步骤如下：\n\n1.  **离散化与初始态制备**：\n    空间域 $x \\in [-L/2, L/2)$ 被离散化为 $N$ 个格点 $x_j$，间距为 $\\Delta x = L/N$。在这些格点上计算初始波函数 $\\psi(x,0)$。给定的 $\\psi(x,0)$ 解析形式在技术上是在无限域上归一化的。对于我们的有限周期域，我们必须在网格上进行数值归一化：\n    $$\n    \\psi_j(0) = \\frac{\\phi_j}{\\sqrt{\\sum_{l=0}^{N-1} |\\phi_l|^2 \\Delta x}}\n    $$\n    其中 $\\phi_j$ 是在 $x_j$ 处计算的未归一化的高斯波包。这确保了初始态满足概率守恒条件 $\\int |\\psi|^2 dx \\approx \\sum_j |\\psi_j(0)|^2 \\Delta x = 1$。\n\n2.  **傅里叶空间中的时间演化**：\n    对于每个所需的时间 $t_k$，从初始态 $\\psi(x,0)$ 计算波函数 $\\psi(x, t_k)$：\n    a. 使用FFT将初始态变换到动量表象：$\\tilde{\\psi}(k, 0) = \\mathcal{F}\\{\\psi(x, 0)\\}$。相应的动量网格 $k_n$ 由空间离散化通过 $k = 2\\pi \\cdot \\text{fftfreq}(N, \\Delta x)$ 确定。\n    b. 通过与对角的时间演化算符相乘，在动量空间中演化状态：\n        $$\n        \\tilde{\\psi}(k, t_k) = \\tilde{\\psi}(k, 0) \\cdot e^{-i \\frac{k^2}{2m} t_k}\n        $$\n        因为我们使用的是哈特里原子单位制，所以 $m=1$。\n    c. 使用逆FFT将状态变换回位置表象：$\\psi(x, t_k) = \\mathcal{F}^{-1}\\{\\tilde{\\psi}(k, t_k)\\}$。`numpy` 的 FFT 和 IFFT 函数是互逆的，确保了状态向量的范数在整个演化过程中保持不变。\n\n3.  **可观测量的计算**：\n    对于每个演化后的状态 $\\psi(x, t_k)$，我们计算所需的标准差 $\\Delta x(t_k)$ 和 $\\Delta p(t_k)$。\n\n    a. **位置不确定性 $\\Delta x(t_k)$**：期望值 $\\langle x \\rangle_{t_k}$ 和 $\\langle x^2 \\rangle_{t_k}$ 通过数值积分（在格点上求和）计算，如问题陈述中所定义：\n        $$\n        \\langle x \\rangle_{t_k} \\approx \\sum_j x_j |\\psi_j(t_k)|^2 \\Delta x\n        $$\n        $$\n        \\langle x^2 \\rangle_{t_k} \\approx \\sum_j x_j^2 |\\psi_j(t_k)|^2 \\Delta x\n        $$\n        位置方差为 $\\Delta x(t_k)^2 = \\langle x^2 \\rangle_{t_k} - \\langle x \\rangle_{t_k}^2$。在周期域上定义位置坐标 $x_j$ 时需要特别小心，因为这会影响期望值的计算，特别是当波包接近或穿过边界 $x = \\pm L/2$ 时。\n\n    b. **动量不确定性 $\\Delta p(t_k)$**：动量可观测量在动量表象中计算最为方便和准确。对于自由粒子，动量分布 $|\\tilde{\\psi}(k, t)|^2$ 不随时间变化，因为演化算符是一个纯相位因子。因此，$\\Delta p(t)$ 对所有 $t$ 都是恒定的。我们可以从初始态 $\\tilde{\\psi}(k, 0)$ 计算一次：\n        $$\n        \\langle p \\rangle \\approx \\frac{\\sum_n k_n |\\tilde{\\psi}_n(0)|^2}{\\sum_n |\\tilde{\\psi}_n(0)|^2}\n        $$\n        $$\n        \\langle p^2 \\rangle \\approx \\frac{\\sum_n k_n^2 |\\tilde{\\psi}_n(0)|^2}{\\sum_n |\\tilde{\\psi}_n(0)|^2}\n        $$\n        动量方差为 $\\Delta p^2 = \\langle p^2 \\rangle - \\langle p \\rangle^2$。这种计算是稳健的，因为它直接从动量概率分布中计算均值和方差。\n\n4.  **对照海森堡不确定性原理进行验证**：\n    对于每个测试案例，生成不确定性乘积列表 $\\{\\Delta x(t_k)\\Delta p(t_k)\\}$。找到最小值 $S$。初始态是一个最小不确定性波包，对于它有 $\\Delta x(0) \\Delta p(0) = 1/2$。对于自由粒子，$\\Delta p$ 是恒定的，而 $\\Delta x$ 随时间增加（波包展宽）。因此，最小不确定性乘积必然出现在 $t=0$ 时。数值模拟必须确认 $S \\ge 1/2 - \\tau$。预计所有情况的结果都为 `True`，因为这是对基本的海森堡不确定性原理的数值验证。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum mechanics problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: L=100.0, N=4096, sigma_x=1.0, x0=0.0, p0=0.0, times\n        (100.0, 4096, 1.0, 0.0, 0.0, [0.0, 1.0, 2.0, 5.0, 10.0]),\n        # Case 2: L=100.0, N=4096, sigma_x=0.2, x0=0.0, p0=0.0, times\n        (100.0, 4096, 0.2, 0.0, 0.0, [0.0, 0.2, 0.5, 1.0, 2.0]),\n        # Case 3: L=100.0, N=4096, sigma_x=3.0, x0=-10.0, p0=2.0, times\n        (100.0, 4096, 3.0, -10.0, 2.0, [0.0, 1.0, 5.0, 10.0, 20.0]),\n        # Case 4: L=100.0, N=4096, sigma_x=0.5, x0=20.0, p0=5.0, times\n        (100.0, 4096, 0.5, 20.0, 5.0, [0.0, 0.5, 1.0, 2.0, 5.0]),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        results.append(run_simulation(*case_params))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(L, N, sigma_x, x0, p0, times):\n    \"\"\"\n    Performs the quantum simulation for a single parameter set.\n    \"\"\"\n    # Mass m=1 and h_bar=1 in Hartree atomic units\n    m = 1.0\n    h_bar = 1.0\n    \n    # 1. Discretization\n    # Spatial grid\n    dx = L / N\n    x = np.arange(N) * dx - L / 2.0\n\n    # Momentum grid\n    # fftfreq provides frequency f. Wavevector k = 2*pi*f. Momentum p = h_bar*k.\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # 2. Initial State Preparation\n    # Unnormalized initial wavepacket\n    psi0_unnormalized = np.exp(-((x - x0)**2) / (4.0 * sigma_x**2)) * \\\n                        np.exp(1j * p0 * (x - x0))\n\n    # Numerically normalize the state on the discrete grid\n    norm_factor = np.sqrt(np.sum(np.abs(psi0_unnormalized)**2) * dx)\n    psi0 = psi0_unnormalized / norm_factor\n\n    # 3. Calculate Momentum Uncertainty (constant for free particle)\n    psi0_k = np.fft.fft(psi0)\n    prob_k = np.abs(psi0_k)**2\n    k_norm = np.sum(prob_k)\n\n    # Expectation values for momentum\n    exp_p = np.sum(k * prob_k) / k_norm\n    exp_p2 = np.sum(k**2 * prob_k) / k_norm\n    \n    # Standard deviation of momentum\n    var_p = exp_p2 - exp_p**2\n    delta_p = np.sqrt(var_p)\n\n    uncertainty_products = []\n\n    # 4. Time Evolution and Observable Calculation\n    for t in times:\n        # Evolve in momentum space\n        time_evolution_operator = np.exp(-1j * (k**2) / (2.0 * m) * t)\n        psi_k_t = psi0_k * time_evolution_operator\n\n        # Transform back to position space\n        psi_t = np.fft.ifft(psi_k_t)\n        \n        # Calculate position uncertainty\n        prob_x = np.abs(psi_t)**2\n        \n        # Expectation values for position\n        # Normalization of psi_t is preserved by the unitary evolution\n        # so we can use the integral approximation sum(...)*dx directly.\n        # np.sum(prob_x)*dx should be 1.0\n        exp_x = np.sum(x * prob_x) * dx\n        exp_x2 = np.sum(x**2 * prob_x) * dx\n\n        # Standard deviation of position\n        var_x = exp_x2 - exp_x**2\n        delta_x = np.sqrt(var_x)\n\n        # Calculate and store the uncertainty product\n        uncertainty_products.append(delta_x * delta_p)\n\n    # 5. Final Verification\n    S = np.min(uncertainty_products)\n    tau = 1e-3\n    \n    # The Heisenberg Uncertainty Principle states delta_x * delta_p >= h_bar / 2\n    # With h_bar = 1, this is >= 0.5\n    return S >= (h_bar / 2.0 - tau)\n\nsolve()\n```", "id": "2452266"}, {"introduction": "在掌握了基础知识之后，我们将处理一个更真实、更具动态性的问题：原子与强激光场的相互作用。这项实践引入了“复吸收势”（Complex Absorbing Potential, CAP）这一关键技术，用以模拟开放量子系统并计算电离概率。你将实现一个适用于含时势的分裂算符方法，亲眼见证激光如何从原子中剥离电子，这是现代物理学中的一个基本过程 [@problem_id:2421319]。", "problem": "实现一个一维数值求解器，用于求解含时薛定谔方程，并使用复吸收势 (Complex Absorbing Potential) 来模拟软核氢原子在强激光场中的电离过程。计算完全在原子单位下进行，其中 $\\hbar = 1$，$m_e = 1$，$e = 1$。概率是无量纲的，无需单位。三角函数中出现的角度必须以弧度为单位。\n\n出发点与核心定义：\n- 含时薛定谔方程为 $i \\,\\partial_t \\psi(x,t) = \\hat{H}(t)\\,\\psi(x,t)$，其中哈密顿量 $\\hat{H}(t) = \\hat{T} + V(x) + x\\,E(t) - i\\,W(x)$。$\\hat{T} = -\\tfrac{1}{2}\\partial_x^2$ 是动能算符，$V(x)$ 是软核库仑势，$E(t)$ 是偶极（长度）规范下的激光电场，$W(x) \\ge 0$ 是复吸收势 (CAP)，用于在区域边界附近衰减出射的概率。\n- 软核势为 $V(x) = -\\dfrac{1}{\\sqrt{x^2 + a^2}}$，其中软化参数 $a > 0$。\n- 激光场是一个有限时长的脉冲，其包络为 $E(t) = E_0\\,\\sin^2\\!\\big(\\pi t/T\\big)\\cos(\\omega t)$（当 $0 \\le t \\le T$ 时），在其他情况下 $E(t) = 0$。角频率为 $\\omega$，总脉冲持续时间为 $T$。\n- 复吸收势为 $W(x) = \\eta \\left(\\dfrac{|x| - x_{\\mathrm{cap}}}{x_{\\max} - x_{\\mathrm{cap}}}\\right)^m$（当 $|x| \\ge x_{\\mathrm{cap}}$ 时），以及 $W(x) = 0$（当 $|x| < x_{\\mathrm{cap}}$ 时）。其中 $\\eta \\ge 0$ 控制吸收强度，$m \\ge 1$ 是一个偶数整数指数，$x_{\\max}$ 是半区域尺寸。\n\n你的任务：\n1. 在具有 $N$ 个点和间距 $\\Delta x$ 的均匀网格 $x_j$ 上对空间进行离散化。对动能传播子使用周期谱表示（通过离散傅里叶变换），并对演化算符在时间上应用对称二阶 Trotter-Suzuki 分裂。由此产生的算法应交替执行半步的势能演化和整步的动能算符演化，并在每个时间步内使用时间中心处的电场 $E(t + \\Delta t/2)$ 进行计算。CAP $W(x)$ 必须以乘法形式包含在位置空间势能因子中。\n2. 使用 $\\hat{T}$ 的有限差分表示和一个稀疏本征求解器来获得最低本征向量，从而构建初始态 $\\psi(x,0)$ 作为无场哈密顿量 $\\hat{H}_0 = \\hat{T} + V(x)$ 的归一化基态。相对于离散 $L^2$ 内积进行归一化，即确保 $\\sum_j |\\psi_j|^2 \\Delta x = 1$。\n3. 在包含激光场和 CAP 的哈密顿量作用下，将 $\\psi(x,t)$ 从 $t=0$ 传播到 $t=T$。通过吸收的模来定义电离概率，$P_{\\mathrm{ion}} = 1 - \\|\\psi(T)\\|_2^2$，其中 $\\|\\psi(T)\\|_2^2 = \\sum_j |\\psi_j(T)|^2 \\Delta x$；这等于在整个传播过程中被非厄米 CAP 移除的总模，并作为电离通量的代理。\n4. 实现该求解器，并为以下每个测试用例计算 $P_{\\mathrm{ion}}$。所有测试均使用相同的空间和时间离散化。激光相位以弧度为单位。\n\n使用的离散化和模型参数：\n- 网格点数：$N = 512$ 个点。\n- 网格间距：$\\Delta x = 0.3$，因此 $x_{\\max} = N \\Delta x / 2$ 且 $x \\in [-x_{\\max}, x_{\\max})$。\n- 软核参数：$a = 1.0$。\n- 时间步长：$\\Delta t = 0.1$。\n- 角频率：$\\omega = 0.057$。\n- 周期数：$n_{\\mathrm{cyc}} = 2$，因此总持续时间 $T = n_{\\mathrm{cyc}} \\times \\dfrac{2\\pi}{\\omega}$。\n- CAP 参数：吸收层宽度 $L_{\\mathrm{cap}} = 20.0$，因此 $x_{\\mathrm{cap}} = x_{\\max} - L_{\\mathrm{cap}}$；指数 $m = 2$。\n- 动量空间中的动能算符：$\\exp\\!\\big(-i \\tfrac{k^2}{2} \\Delta t\\big)$，其中 $k$ 是与所选网格和离散傅里叶变换一致的离散波数。\n\n测试套件：\n- 情况 A（无激光，开启 CAP）：$E_0 = 0.0$，$\\eta = 1.0$。\n- 情况 B（中等强度激光，开启 CAP）：$E_0 = 0.08$，$\\eta = 1.0$。\n- 情况 C（与 B 相同的激光，关闭 CAP）：$E_0 = 0.08$，$\\eta = 0.0$。\n\n对于每种情况，计算在 $t = T$ 时的最终吸收概率 $P_{\\mathrm{ion}}$，结果为浮点数。你的程序必须生成单行输出，其中包含三个结果，以逗号分隔的列表形式用方括号括起来，顺序固定为 [情况 A, 情况 B, 情况 C]。每个结果表示为四舍五入到小数点后六位的小数。例如，像 [$0.000001$, $0.123456$, $0.000000$] 这样的输出是可以接受的。不应打印任何其他输出。", "solution": "所提出的问题是计算量子力学中一个良定义的初值问题，需要对一维含时薛定谔方程 (TDSE) 进行数值求解。所有给定的方程、参数和数值步骤都是强场物理领域的标准做法，并且在科学上是合理、一致且完整的。因此，该问题被认定为有效，并将提供解答。\n\n问题的核心是模拟量子力学波函数 $\\psi(x,t)$ 的时间演化，其演化由 TDSE 控制：\n$$\ni \\frac{\\partial}{\\partial t}\\psi(x,t) = \\hat{H}(t)\\psi(x,t)\n$$\n哈密顿量 $\\hat{H}(t)$ 由几个部分组成：\n$$\n\\hat{H}(t) = \\hat{T} + V(x) + V_{\\mathrm{laser}}(x,t) + V_{\\mathrm{CAP}}(x)\n$$\n其中：\n-   $\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}$ 是动能算符（在原子单位中，$\\hbar=1$ 且电子质量 $m_e=1$）。\n-   $V(x) = -\\frac{1}{\\sqrt{x^2 + a^2}}$ 是软核库仑势，它对 $x=0$ 处的奇点进行了正则化。\n-   $V_{\\mathrm{laser}}(x,t) = x E(t)$ 是在偶极近似和长度规范下与激光电场 $E(t)$ 的相互作用。电场由 $E(t) = E_0\\sin^2(\\pi t/T)\\cos(\\omega t)$ 给出（当 $t \\in [0, T]$ 时），在其他情况下为零。\n-   $V_{\\mathrm{CAP}}(x) = -iW(x)$ 是复吸收势 (CAP)，这是一个非厄米项，旨在吸收出射的概率流，从而模拟电离。$W(x)$ 的形式被给定为在网格边界附近的多项式斜坡。\n\n求解过程分为三个主要阶段：空间和时间离散化、初始态的确定以及波函数的时间传播。\n\n**1. 离散化与数值表示**\n\n我们将空间域离散化为一个包含 $N$ 个点的均匀网格，$x_j = -x_{\\max} + j\\Delta x$（对于 $j = 0, 1, \\dots, N-1$），其中 $\\Delta x$ 是网格间距，$x_{\\max} = N\\Delta x/2$。波函数变成一个向量 $\\psi_j(t) = \\psi(x_j, t)$。势算符 $V(x)$、$V_{\\mathrm{laser}}(x,t)$ 和 $V_{\\mathrm{CAP}}(x)$ 在此位置空间表示中是对角的；它们的作用是简单的逐元素相乘。\n\n动能算符 $\\hat{T}$ 在位置空间中不是对角的。其作用在动量空间中计算最为高效，因为在动量空间中它是一个对角算符。位置空间和动量空间之间的转换通过离散傅里叶变换 (DFT) 及其逆变换 (IDFT) 实现。动量空间（或 k 空间）的网格点 $k_n$ 由 DFT 的属性决定。对于我们的空间网格，相应的波数由 `scipy.fft.fftfreq(N, d=dx) * 2 * np.pi` 给出。在此基底下，动能算符的作用是乘以 $\\hat{T}_k = \\frac{k^2}{2}$。\n\n**2. 初始态计算**\n\n系统从无场哈密顿量 $\\hat{H}_0 = \\hat{T} + V(x)$ 的基态开始。为了找到这个状态，我们求解不含时薛定谔方程 $\\hat{H}_0 \\phi = E \\phi$。这是一个本征值问题。我们在空间网格上构建 $\\hat{H}_0$ 的矩阵表示。为此，我们使用二阶有限差分近似来表示动能算符：\n$$\n\\frac{\\partial^2\\psi}{\\partial x^2}\\bigg|_{x_j} \\approx \\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{\\Delta x^2}\n$$\n这将 $\\hat{T}$ 变成一个稀疏三对角矩阵（由于周期性边界条件，角落有元素）。势 $V(x)$ 变成一个对角矩阵，其元素为 $V(x_j)$。最终的哈密顿矩阵 $\\mathbf{H}_0$ 是稀疏的。我们使用稀疏本征求解器 `scipy.sparse.linalg.eigs` 来找到对应于最低本征值（基态能量）的本征向量。然后根据离散内积对得到的本征向量进行归一化：$\\sum_{j=0}^{N-1} |\\psi_j(0)|^2 \\Delta x = 1$。这个归一化的向量就是我们的初始态 $\\psi(x,0)$。\n\n**3. 使用分步算符法进行时间传播**\n\n波函数从时间 $t$ 到 $t+\\Delta t$ 的演化形式上由 $\\psi(t+\\Delta t) = \\exp(-i \\hat{H}_{\\text{eff}} \\Delta t) \\psi(t)$ 给出，其中 $\\hat{H}_{\\text{eff}}$ 是该时间步内的有效哈密顿量。由于动能算符 $\\hat{T}$ 和各种势算符不对易，我们不能简单地对它们的和进行指数化。我们采用对称二阶 Trotter-Suzuki 分解来处理演化算符：\n$$\n\\hat{U}(\\Delta t) = e^{-i\\hat{H}\\Delta t} \\approx e^{-i\\hat{B}\\frac{\\Delta t}{2}} e^{-i\\hat{A}\\Delta t} e^{-i\\hat{B}\\frac{\\Delta t}{2}} + O(\\Delta t^3)\n$$\n在这里，我们将哈密顿量分解为动能部分 $\\hat{A} = \\hat{T}$ 和总势能部分 $\\hat{B}(t) = V(x) + xE(t) - iW(x)$。$\\hat{A}$ 和 $\\hat{B}$ 的传播子分别在动量空间和位置空间中易于应用。\n\n从 $t$ 到 $t+\\Delta t$ 的单个时间步算法如下：\n1. 计算时间步中心的总势能，$V_{\\text{full}}(x, t+\\Delta t/2) = V(x) + x E(t+\\Delta t/2) - iW(x)$。\n2. 在位置空间中应用前半步的势能传播子：\n    $$ \\psi'(x) = e^{-i V_{\\text{full}}(x, t+\\Delta t/2) \\frac{\\Delta t}{2}} \\psi(x,t) $$\n3. 使用快速傅里叶变换 (FFT) 将结果变换到动量空间：$\\tilde{\\psi}'(k) = \\text{FFT}[\\psi'(x)]$。\n4. 在动量空间中应用整步的动能传播子：\n    $$ \\tilde{\\psi}''(k) = e^{-i \\frac{k^2}{2} \\Delta t} \\tilde{\\psi}'(k) $$\n5. 使用逆快速傅里叶变换 (IFFT) 将其变换回位置空间：$\\psi''(x) = \\text{IFFT}[\\tilde{\\psi}''(k)]$。\n6. 在位置空间中应用后半步的势能传播子，以获得该步骤的最终状态：\n    $$ \\psi(x,t+\\Delta t) = e^{-i V_{\\text{full}}(x, t+\\Delta t/2) \\frac{\\Delta t}{2}} \\psi''(x) $$\n这个序列在激光脉冲的总持续时间 $T$ 内重复进行。\n\n**4. 电离概率的计算**\n\n哈密顿量中的 CAP 项 $-iW(x)$ 是非厄米的，导致波函数模的不守恒，即 $\\|\\psi(t)\\|_2^2 = \\sum_j |\\psi_j(t)|^2 \\Delta x$ 不守恒。模的衰减率由 $\\frac{d}{dt} \\|\\psi\\|^2 = -2 \\langle \\psi | W | \\psi \\rangle$ 给出，由于 $W(x) \\ge 0$，该值非正。在模拟时间 $[0, T]$ 内被 CAP 吸收的总模可作为总电离概率 $P_{\\mathrm{ion}}$ 的度量。鉴于初始态是归一化的，即 $\\|\\psi(0)\\|_2^2 = 1$，电离概率为：\n$$\nP_{\\mathrm{ion}} = 1 - \\|\\psi(T)\\|_2^2 = 1 - \\sum_{j=0}^{N-1} |\\psi_j(T)|^2 \\Delta x\n$$\n该量将针对问题陈述中指定的三个测试用例进行计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg as sla\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Solves the 1D TDSE for a soft-core hydrogen atom in a laser field,\n    calculates ionization probability for three test cases, and prints the results.\n    \"\"\"\n\n    # --- 1. Define physical and numerical parameters ---\n    # Discretization\n    N = 512              # Number of grid points\n    dx = 0.3             # Grid spacing\n    dt = 0.1             # Time step\n    \n    # Grid construction\n    x_max = N * dx / 2.0\n    x = np.arange(-x_max, x_max, dx)\n\n    # Momentum space grid (k-space)\n    # The factor 2*pi is necessary for the angular frequency definition of k in physics\n    k = 2.0 * np.pi * fft.fftfreq(N, d=dx)\n\n    # Physical parameters\n    a = 1.0              # Soft-core parameter\n    omega = 0.057        # Laser angular frequency\n    n_cyc = 2.0          # Number of laser cycles\n    T = n_cyc * (2.0 * np.pi / omega) # Total pulse duration\n    \n    # CAP parameters\n    L_cap = 20.0         # Width of the absorbing layer\n    m_cap = 2            # Exponent of the CAP\n    x_cap = x_max - L_cap\n\n    # --- 2. Define potentials and operators ---\n    \n    # Soft-core potential\n    V_sc = -1.0 / np.sqrt(x**2 + a**2)\n\n    # Laser electric field envelope\n    def E_laser(t, E0):\n        if 0 <= t <= T:\n            return E0 * (np.sin(np.pi * t / T)**2) * np.cos(omega * t)\n        else:\n            return 0.0\n\n    # Complex Absorbing Potential (CAP)\n    def W_cap(eta):\n        W = np.zeros(N)\n        # Condition |x| >= x_cap\n        mask = np.abs(x) >= x_cap\n        # The region where the CAP is active\n        active_x = np.abs(x[mask])\n        W[mask] = eta * ((active_x - x_cap) / (x_max - x_cap))**m_cap\n        return W\n\n    # Kinetic energy propagator in k-space\n    K_prop = np.exp(-1j * (k**2 / 2.0) * dt)\n\n    # --- 3. Calculate initial state (ground state of H0) ---\n    def get_initial_state():\n        \"\"\"\n        Computes the normalized ground state of the field-free Hamiltonian\n        H0 = T + V(x) using a finite-difference eigensolver.\n        \"\"\"\n        # Kinetic operator T = -1/2 * d^2/dx^2 using centered 2nd-order finite difference\n        # with periodic boundary conditions\n        diag = np.ones(N) * (-2.0)\n        off_diag = np.ones(N - 1)\n        # Create tridiagonal part\n        T_matrix = sparse.diags([off_diag, diag, off_diag], [-1, 0, 1], shape=(N, N))\n        # Add periodic boundary corners\n        T_matrix.setdiag(1, N - 1)\n        T_matrix.setdiag(1, -N + 1)\n        T_matrix *= -0.5 / dx**2\n        \n        # Potential operator V_sc as a sparse diagonal matrix\n        V_matrix = sparse.diags([V_sc], [0])\n        \n        # Field-free Hamiltonian H0\n        H0 = T_matrix + V_matrix\n        \n        # Find the ground state (eigenstate with the smallest real eigenvalue)\n        # We ask for a few eigenvalues around 0 to ensure we get the ground state\n        # The true ground state energy is negative.\n        eigenvalues, eigenvectors = sla.eigs(H0, k=5, which='SR')\n        \n        ground_state_index = np.argmin(np.real(eigenvalues))\n        psi0 = eigenvectors[:, ground_state_index]\n\n        # Normalize the wavefunction: integral |psi|^2 dx = 1\n        norm = np.sqrt(np.sum(np.abs(psi0)**2) * dx)\n        psi0_normalized = psi0 / norm\n        \n        return psi0_normalized\n\n    # --- 4. Define the time propagation function ---\n    def run_simulation(psi0, E0, eta):\n        \"\"\"\n        Propagates the initial wavefunction psi0 in time from t=0 to t=T.\n        \"\"\"\n        psi = np.copy(psi0).astype(np.complex128)\n        \n        # Pre-calculate time-independent part of potential\n        W = W_cap(eta)\n        V_base = V_sc - 1j * W\n        \n        num_steps = int(np.ceil(T / dt))\n        \n        for i in range(num_steps):\n            t = i * dt\n            \n            # Symmetric Trotter splitting requires field at t + dt/2\n            E_mid = E_laser(t + dt / 2.0, E0)\n            \n            V_full = V_base + x * E_mid\n            V_prop = np.exp(-1j * V_full * dt / 2.0)\n            \n            # (1) First half-step in potential\n            psi = V_prop * psi\n            \n            # (2) Full step in kinetic energy (in k-space)\n            psi_k = fft.fft(psi)\n            psi_k = K_prop * psi_k\n            psi = fft.ifft(psi_k)\n            \n            # (3) Second half-step in potential\n            psi = V_prop * psi\n\n        # Calculate final norm and ionization probability\n        final_norm_sq = np.sum(np.abs(psi)**2) * dx\n        p_ion = 1.0 - final_norm_sq\n        \n        return p_ion\n\n    # --- 5. Run test cases and format output ---\n    test_cases = [\n        # Case A: E0=0.0, eta=1.0 (CAP on, no laser)\n        (0.0, 1.0),\n        # Case B: E0=0.08, eta=1.0 (CAP on, strong laser)\n        (0.08, 1.0),\n        # Case C: E0=0.08, eta=0.0 (CAP off, strong laser)\n        (0.08, 0.0),\n    ]\n\n    results = []\n    # Calculate initial state once, as it is the same for all cases\n    initial_state = get_initial_state()\n\n    for E0_case, eta_case in test_cases:\n        p_ion_result = run_simulation(initial_state, E0_case, eta_case)\n        # Format to 6 decimal places as requested\n        results.append(f\"{p_ion_result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2421319"}, {"introduction": "分裂算符方法的强大之处在于它不仅限于线性的薛定谔方程。在最后的这项练习中，你将把该技术应用于求解描述玻色-爱因斯坦凝聚体的非线性Gross-Pitaevskii方程。通过使用虚时演化法，你将学习如何寻找多体系统的基态并计算其化学势，这充分展示了该方法在凝聚态物理等领域的广泛适用性 [@problem_id:2441319]。", "problem": "您需要实现一个完整的、可运行的程序，将分裂算符（时间分裂谱）方法应用于一维空间中的非线性 Gross-Pitaevskii 方程，其中有效势取决于演化中的波函数。您的任务是，对于一小组测试用例，通过归一化虚时演化计算得到的定态的化学势，并以指定格式在单行中输出结果。\n\n从一维时间相关的 Gross-Pitaevskii 方程开始，使用无量纲单位，其中约化普朗克常数和粒子质量均为1，即 $\\hbar = 1$ 和 $m = 1$：\n$$\n\\mathrm{i}\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} \\;+\\; V_{\\mathrm{ext}}(x) \\;+\\; g\\,|\\psi(x,t)|^2 \\right] \\psi(x,t).\n$$\n通过将 $t$ 替换为 $-\\,\\mathrm{i}\\,\\tau$ 在虚时中进行演化以获得定态基态，并在每个时间步后对波函数强制进行归一化，以使 $\\int |\\psi(x,\\tau)|^2\\,\\mathrm{d}x = 1$。使用一个二阶精度的对称分裂算符格式，该格式在傅里叶空间中的动能算符与实空间中的外部势和非线性势之和之间交替进行。在有限区域上，使用与离散傅里叶变换一致的周期性边界条件。\n\n对于一个给定的最终归一化状态 $\\psi(x)$，使用由定态 Gross-Pitaevskii 方程所隐含的定义来计算定态解的化学势 $\\mu$，\n$$\n\\mu\\,\\psi(x) \\;=\\; \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} \\;+\\; V_{\\mathrm{ext}}(x) \\;+\\; g\\,|\\psi(x)|^2 \\right]\\psi(x),\n$$\n并将 $\\mu$ 表示为根据 $\\psi(x)$ 及其梯度计算出的标量。所有积分必须在数值网格上通过适当的黎曼和进行近似，动能贡献所需空间导数的计算方式必须与所选网格上的傅里叶表示一致。\n\n所有量均为无量纲单位，因此您的程序必须以无量纲能量单位输出化学势。\n\n为以下一维空间中的参数集测试套件实现您的程序：\n- 案例 A（线性谐振子，基准检查）：\n  - 外部势 $V_{\\mathrm{ext}}(x) = \\tfrac{1}{2}\\,\\omega^2 x^2$，其中 $\\omega = 1.0$。\n  - 相互作用强度 $g = 0.0$。\n  - 区域长度 $L = 20.0$，采用周期性边界条件，网格点数 $N = 512$，因此 $\\Delta x = L/N$。\n  - 虚时间步长 $\\Delta \\tau = 0.001$，步数 $N_{\\mathrm{steps}} = 2500$。\n  - 初始波函数：归一化高斯函数 $\\psi(x,0) \\propto \\exp\\!\\big(-x^2/(2\\sigma^2)\\big)$，其中 $\\sigma = 1.0$，归一化至 $\\int |\\psi(x,0)|^2\\,\\mathrm{d}x = 1$。\n- 案例 B（排斥性非线性谐振子）：\n  - 外部势 $V_{\\mathrm{ext}}(x) = \\tfrac{1}{2}\\,\\omega^2 x^2$，其中 $\\omega = 1.0$。\n  - 相互作用强度 $g = 1.0$。\n  - 区域长度 $L = 20.0$，采用周期性边界条件，网格点数 $N = 512$。\n  - 虚时间步长 $\\Delta \\tau = 0.001$，步数 $N_{\\mathrm{steps}} = 2500$。\n  - 初始波函数：归一化高斯函数，其中 $\\sigma = 1.0$，归一化至1。\n- 案例 C（周期性盒子，均匀定态）：\n  - 外部势 $V_{\\mathrm{ext}}(x) = 0$。\n  - 相互作用强度 $g = 2.0$。\n  - 区域长度 $L = 10.0$，采用周期性边界条件，网格点数 $N = 512$。\n  - 虚时间步长 $\\Delta \\tau = 0.001$，步数 $N_{\\mathrm{steps}} = 10$。\n  - 初始波函数：均匀函数 $\\psi(x,0) = 1/\\sqrt{L}$，使其精确归一化。\n\n您的程序必须：\n- 对每个案例，使用虚时间步长上为二阶的对称分裂算符格式演化至最终时间，并在每个时间步后进行归一化以维持 $\\int |\\psi|^2\\,\\mathrm{d}x = 1$。\n- 根据最终的归一化状态，为每个案例计算化学势 $\\mu$。\n- 生成单行输出，包含由方括号括起来的三个结果的逗号分隔列表，例如 $\\texttt{[0.500000,1.234567,0.200000]}$，每个值四舍五入到 $6$ 位小数。\n\n约束和实现细节：\n- 空间网格：$x_j = x_{\\min} + j\\,\\Delta x$，其中 $x_{\\min} = -L/2$，$j = 0,1,\\dots,N-1$，以及 $\\Delta x = L/N$。\n- 波数：用于动能步和谱导数计算的 $k$-网格必须与离散傅里叶变换和周期性边界条件一致。\n- 算法必须是完全自包含的，且不得读取任何输入。\n- 您的程序必须计算并按要求的输出格式返回上述三个案例的化学势。\n\n您的最终程序必须是一个完整的、可运行的脚本，仅打印一行内容：一个格式为 $\\texttt{[}\\mu_A,\\mu_B,\\mu_C\\texttt{]}$ 的列表，其中每个条目四舍五入到 $6$ 位小数。", "solution": "该问题要求实现一种数值算法，以找到一维 Gross-Pitaevskii 方程（GPE）的定态基态，并计算其相应的化学势 $\\mu$。指定的方法是使用二阶对称分裂算符格式的虚时演化。\n\n时间相关的GPE方程如下：\n$$\n\\mathrm{i}\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; \\hat{H}\\psi(x,t) \\;=\\; \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} \\;+\\; V_{\\mathrm{ext}}(x) \\;+\\; g\\,|\\psi(x,t)|^2 \\right] \\psi(x,t)\n$$\n其中质量 $m$ 和约化普朗克常数 $\\hbar$ 均设为 1。哈密顿算符 $\\hat{H}$ 由动能算符 $\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}$ 和势能算符 $\\hat{V}(x, \\psi) = V_{\\mathrm{ext}}(x) + g\\,|\\psi(x,t)|^2$ 组成，后者包含一个依赖于波函数自身密度的项。\n\n为了找到基态，我们采用虚时演化的方法。这是通过替换 $t \\to -i\\tau$ 实现的，它将薛定谔方程转换为关于虚时变量 $\\tau$ 的扩散型方程：\n$$\n\\frac{\\partial \\psi(x,\\tau)}{\\partial \\tau} \\;=\\; -\\hat{H}\\psi(x,\\tau)\n$$\n此方程在一个小时间步长 $\\Delta\\tau$ 内的形式解是 $\\psi(x, \\tau+\\Delta\\tau) = e^{-\\hat{H}\\Delta\\tau}\\psi(x,\\tau)$。当使用此规则对任意初始状态进行演化时，对应于较高能量本征态的分量比基态分量衰减得更快。通过重复应用演化算符并在每一步重新归一化波函数，状态会收敛到基态，即具有最低本征值的 $\\hat{H}$ 的本征态。\n\n演化算符 $e^{-\\hat{H}\\Delta\\tau} = e^{-(\\hat{T} + \\hat{V})\\Delta\\tau}$ 难以直接计算，因为动能算符 $\\hat{T}$ 和势能算符 $\\hat{V}$ 不对易（$\\left[\\hat{T}, \\hat{V}\\right] \\neq 0$）。分裂算符方法通过分离动能和势能的演化来近似总演化。采用了一种二阶精度的对称分裂，也称为 Strang 分裂：\n$$\ne^{-(\\hat{T} + \\hat{V})\\Delta\\tau} \\approx e^{-\\hat{V}\\Delta\\tau/2} \\, e^{-\\hat{T}\\Delta\\tau} \\, e^{-\\hat{V}\\Delta\\tau/2} + O(\\Delta\\tau^3)\n$$\n对于从 $\\tau$ 到 $\\tau + \\Delta\\tau$ 的单个时间步，此格式按算法实现如下：\n\n1.  **势能半步：** 首先，波函数在势能算符下演化半个步长 $\\Delta\\tau/2$。此操作在位置空间是局域的，相当于一次简单的乘法。对于非线性GPE，必须使用当前状态 $\\psi(x,\\tau)$ 来计算势能：\n    $$\n    \\psi'(x) = e^{-(V_{\\mathrm{ext}}(x) + g|\\psi(x,\\tau)|^2)\\Delta\\tau/2} \\psi(x,\\tau)\n    $$\n2.  **动能全步：** 动能算符 $\\hat{T}$ 在动量（或 $k$）空间中是局域的。使用快速傅里叶变换（FFT）可以最有效地执行演化。状态 $\\psi'(x)$ 被变换到傅里叶空间，$\\tilde{\\psi}'(k) = \\mathcal{F}\\{\\psi'(x)\\}$。在此基底下，动能算符是对角的，$\\hat{T}_k = k^2/2$，因此演化是一次乘法：\n    $$\n    \\tilde{\\psi}''(k) = e^{-k^2\\Delta\\tau/2} \\tilde{\\psi}'(k)\n    $$\n    然后将结果变换回位置空间：$\\psi''(x) = \\mathcal{F}^{-1}\\{\\tilde{\\psi}''(k)\\}$。波矢网格 $k_j$ 必须与空间网格 $x_j$ 一致，这可以通过使用 `fftfreq` 函数来实现，其中 $k_j = 2\\pi f_j$，$f_j$ 是离散频率。对于长度为 $L$、有 $N$ 个点且网格间距为 $\\Delta x = L/N$ 的空间区域，波矢为 $k = 2\\pi \\cdot \\texttt{fftfreq}(N, d=\\Delta x)$。\n\n3.  **势能半步（第二次）：** 最后在势能算符下再演化半个步长 $\\Delta\\tau/2$，以完成对称步。为确保对称性和稳定性，使用更新后的波函数 $\\psi''(x)$ 重新计算势能：\n    $$\n    \\psi(x, \\tau+\\Delta\\tau)_{\\text{un-norm}} = e^{-(V_{\\mathrm{ext}}(x) + g|\\psi''(x)|^2)\\Delta\\tau/2} \\psi''(x)\n    $$\n4.  **归一化：** 由于虚时演化不保持范数，因此必须在每个完整步骤后对波函数进行重新归一化，以维持物理约束 $\\int |\\psi|^2 dx = 1$。积分通过黎曼和来近似：$I = \\sum_j |\\psi_j|^2 \\Delta x$。然后将波函数更新为 $\\psi_j \\to \\psi_j / \\sqrt{I}$。\n\n经过足够数量的步数 $N_{\\mathrm{steps}}$ 后，波函数 $\\psi(x)$ 收敛到定态基态。化学势 $\\mu$ 是与该状态对应的本征值，由定态 GPE 定义：$\\hat{H}\\psi(x) = \\mu\\psi(x)$。$\\mu$ 的值通过计算哈密顿算符对于最终归一化状态的期望值得到：\n$$\n\\mu = \\langle \\psi | \\hat{H} | \\psi \\rangle = \\int \\psi^*(x) \\hat{H} \\psi(x) \\, dx\n$$\n该期望值是三部分能量贡献之和：\n- **动能：** $E_{kin} = \\int \\psi^*(x) \\left(-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}\\right) \\psi(x) \\, dx$。这在傅里叶空间中可以高效计算：$E_{kin} = \\int \\tilde{\\psi}^*(k) \\left(\\frac{k^2}{2}\\right) \\tilde{\\psi}(k) \\, dk$。在数值上，这等于 $\\sum_j |\\tilde{\\psi}_j|^2 \\frac{k_j^2}{2}$（使用适当的FFT归一化），或者更直接地，通过将动能算符作用于 $\\psi$ 并计算内积：$E_{kin} \\approx \\Delta x \\sum_j \\psi_j^* \\mathcal{F}^{-1}\\{ (k^2/2) \\mathcal{F}\\{\\psi_j\\} \\}$。\n- **外部势能：** $E_{pot, ext} = \\int V_{\\mathrm{ext}}(x) |\\psi(x)|^2 \\, dx$。这通过求和 $\\Delta x \\sum_j V_{\\mathrm{ext}}(x_j) |\\psi_j|^2$ 来近似。\n- **相互作用能：** $E_{int} = \\int g |\\psi(x)|^4 \\, dx$。这通过求和 $\\Delta x \\sum_j g |\\psi_j|^4$ 来近似。\n\n化学势是这三者之和 $\\mu = E_{kin} + E_{pot, ext} + E_{int}$。该算法被应用于指定的三个测试案例中的每一个，从而得出它们各自的化学势。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef compute_mu(params):\n    \"\"\"\n    Computes the chemical potential for a given Gross-Pitaevskii equation setup\n    using imaginary-time propagation with a split-operator method.\n\n    Args:\n        params (dict): A dictionary containing all simulation parameters:\n            - L (float): Domain length.\n            - N (int): Number of grid points.\n            - g (float): Interaction strength.\n            - V_ext_func (callable): Function for the external potential V_ext(x).\n            - dt (float): Imaginary time step (delta_tau).\n            - N_steps (int): Number of propagation steps.\n            - psi0_func (callable): Function for the initial wavefunction psi(x, 0).\n\n    Returns:\n        float: The computed chemical potential, mu.\n    \"\"\"\n    # Unpack parameters\n    L = params[\"L\"]\n    N = params[\"N\"]\n    g = params[\"g\"]\n    V_ext_func = params[\"V_ext_func\"]\n    dt = params[\"dt\"]\n    N_steps = params[\"N_steps\"]\n    psi0_func = params[\"psi0_func\"]\n\n    # 1. Setup spatial and momentum grids\n    dx = L / N\n    x = np.linspace(-L / 2, L / 2 - dx, N)\n    k = 2 * np.pi * fftfreq(N, d=dx)\n\n    # 2. Setup kinetic operator and time-evolution propagators\n    T_k = 0.5 * k**2\n    kinetic_propagator = np.exp(-T_k * dt)\n    V_ext = V_ext_func(x)\n\n    # 3. Setup initial wavefunction and normalize it\n    psi = psi0_func(x).astype(np.complex128)\n    norm_sq = np.sum(np.abs(psi)**2) * dx\n    psi = psi / np.sqrt(norm_sq)\n\n    # 4. Imaginary time evolution loop\n    for _ in range(N_steps):\n        # Symmetric split-operator step: V/2, T, V/2\n        \n        # First half-step in potential\n        V_eff = V_ext + g * np.abs(psi)**2\n        psi *= np.exp(-V_eff * dt / 2.0)\n\n        # Full step in kinetic energy (in Fourier space)\n        psi_k = fft(psi)\n        psi_k *= kinetic_propagator\n        psi = ifft(psi_k)\n\n        # Second half-step in potential\n        V_eff = V_ext + g * np.abs(psi)**2\n        psi *= np.exp(-V_eff * dt / 2.0)\n\n        # Renormalize the wavefunction after the full step\n        norm_sq = np.sum(np.abs(psi)**2) * dx\n        psi /= np.sqrt(norm_sq)\n\n    # 5. Calculate the chemical potential mu from the final stationary state\n    # mu = <psi|H|psi> = <T> + <V_ext> + <V_int>\n    \n    # Kinetic energy expectation value\n    psi_k = fft(psi)\n    T_psi = ifft(T_k * psi_k)\n    E_kin = np.sum(np.conj(psi) * T_psi).real * dx\n    \n    # External potential energy expectation value\n    E_pot_ext = np.sum(V_ext * np.abs(psi)**2).real * dx\n    \n    # Interaction energy expectation value\n    E_int = np.sum(g * np.abs(psi)**4).real * dx\n    \n    mu = E_kin + E_pot_ext + E_int\n\n    return mu\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Linear harmonic oscillator (g=0)\n        {\n            \"L\": 20.0, \"N\": 512, \"g\": 0.0, \"omega\": 1.0, \"sigma\": 1.0,\n            \"dt\": 0.001, \"N_steps\": 2500,\n            \"V_ext_func\": lambda x, w=1.0: 0.5 * w**2 * x**2,\n            \"psi0_func\": lambda x, s=1.0: np.exp(-x**2 / (2 * s**2))\n        },\n        # Case B: Repulsive nonlinear harmonic oscillator (g>0)\n        {\n            \"L\": 20.0, \"N\": 512, \"g\": 1.0, \"omega\": 1.0, \"sigma\": 1.0,\n            \"dt\": 0.001, \"N_steps\": 2500,\n            \"V_ext_func\": lambda x, w=1.0: 0.5 * w**2 * x**2,\n            \"psi0_func\": lambda x, s=1.0: np.exp(-x**2 / (2 * s**2))\n        },\n        # Case C: Periodic box, uniform state\n        {\n            \"L\": 10.0, \"N\": 512, \"g\": 2.0,\n            \"dt\": 0.001, \"N_steps\": 10,\n            \"V_ext_func\": lambda x: np.zeros_like(x),\n            \"psi0_func\": lambda x, L=10.0: np.full_like(x, 1.0 / np.sqrt(L))\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        mu = compute_mu(case_params)\n        results.append(mu)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2441319"}]}