{"hands_on_practices": [{"introduction": "散射理论中的一个基本任务是计算相位移动，它描述了波函数在与势相互作用后所经历的相位变化。本练习 [@problem_id:2432197] 将引导你处理一个平滑的势阶，这种势通常没有解析解，因此必须采用数值方法。你将通过实现“打靶法”来直接求解定态薛定谔方程，这是一种解决量子力学中边值问题的强大而直观的技术。", "problem": "计算一个一维非相对论性量子粒子从左侧入射到一个由逻辑斯谛形式给出的平滑阶梯（软边）势时的散射相移。以不含时薛定谔方程为起点。完全在无量纲单位下进行计算，选择约化普朗克常数的平方除以两倍质量为单位一，即设 $\\hbar^2/(2m)=1$，使得定态薛定谔方程简化为\n$$\n-\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n或等价地\n$$\n\\psi''(x) = \\left(V(x)-E\\right)\\psi(x).\n$$\n该平滑势为\n$$\nV(x) = \\frac{V_0}{1+\\exp\\left(-a\\,(x-x_0)\\right)},\n$$\n其中 $V_0$、$a>0$ 和 $x_0$ 为实参数。该势渐近于 $V(x\\to -\\infty)\\to 0$ 和 $V(x\\to +\\infty)\\to V_0$。一个能量为 $E>0$ 的粒子从左侧入射。在远左渐近区，波函数表现为入射的右行平面波和反射的左行平面波的叠加，\n$$\n\\psi(x\\to -\\infty) \\sim e^{i k x} + r\\,e^{-i k x},\\quad k=\\sqrt{E}.\n$$\n在远右渐近区，对于 $E>V_0$，波函数表现为透射的右行平面波，\n$$\n\\psi(x\\to +\\infty) \\sim t\\,e^{i q x},\\quad q=\\sqrt{E-V_0},\n$$\n而对于 $0<E<V_0$，则表现为倏逝衰减，\n$$\n\\psi(x\\to +\\infty) \\sim t\\,e^{-\\kappa x},\\quad \\kappa=\\sqrt{V_0-E}.\n$$\n将散射相移 $\\delta(E)$（以弧度为单位）定义如下：\n- 对于 $0<E<V_0$，定义 $\\delta(E)=\\arg\\left(r(E)\\right)$，即复反射振幅 $r(E)$ 的辐角。\n- 对于 $E>V_0$，定义 $\\delta(E)=\\arg\\left(t(E)\\right)$，即复透射振幅 $t(E)$ 的辐角。\n\n任务：仅从薛定谔方程、所述的渐近行为和概率流守恒出发，通过数值求解薛定谔方程并匹配相应的渐近形式，来推导、实现并计算 $\\delta(E)$。不得引用该势的任何 $r$ 或 $t$ 的闭式表达式。使用稳健的数值方法来积分二阶常微分方程，并通过渐近匹配提取复振幅。角度必须以弧度为单位报告。您的程序必须完全自包含，不接受任何输入，并按下面指定的方式打印最终结果。\n\n数值实现细节：\n- 在上述的无量纲单位下进行计算（无需物理单位转换）。\n- 使用有限计算域 $[L,R]$，其中 $L=x_0-W$，$R=x_0+W$，取 $W=12/a$，以使 $V(x)$ 在 $x=L$ 和 $x=R$ 处指数级地接近其渐近值。\n- 从 $x=L$ 积分到 $x=R$，并通过施加适当的右渐近条件来确定 $r$（以及在需要时确定 $t$）。\n\n测试套件：按以下确切顺序评估并输出以下四种情况的相移。每种情况都是一个元组 $(V_0,a,x_0,E)$。\n- 情况 1：$(V_0,a,x_0,E)=\\left(1.0,\\,1.5,\\,0.0,\\,0.2\\right)$。\n- 情况 2：$(V_0,a,x_0,E)=\\left(1.0,\\,0.7,\\,-1.0,\\,0.95\\right)$。\n- 情况 3：$(V_0,a,x_0,E)=\\left(1.0,\\,2.0,\\,0.5,\\,1.5\\right)$。\n- 情况 4：$(V_0,a,x_0,E)=\\left(0.5,\\,3.0,\\,0.0,\\,0.05\\right)$。\n\n所需输出的规范：\n- 最终输出必须是单行，包含一个 Python 风格的列表，内含四个浮点数，每个数对应四种情况下相应的 $\\delta(E)$，以弧度为单位，四舍五入到小数点后六位，并与上面列出的顺序相同。例如，输出必须具有以下形式：\n$[d_1,d_2,d_3,d_4]$\n使用逗号分隔，无空格。", "solution": "所述问题具有科学依据，提法得当且客观。它提出了一个计算量子力学中的标准任务，可以使用已有的数值方法解决。继续进行求解。\n\n基本原理是一维不含时薛定谔方程，在指定的无量纲单位（$\\hbar^2/(2m)=1$）下，其形式为：\n$$\n\\psi''(x) = \\left(V(x) - E\\right)\\psi(x)\n$$\n此处，$\\psi(x)$ 是复值波函数，$E$ 是粒子能量，$V(x)$ 是平滑阶梯势：\n$$\nV(x) = \\frac{V_0}{1 + \\exp(-a(x - x_0))}\n$$\n其中 $V_0$、$a>0$ 和 $x_0$ 是实参数。\n\n为了便于数值求解，这个二阶常微分方程（ODE）被转换为一个包含两个一阶常微分方程的方程组。我们定义一个状态向量 $\\mathbf{y}(x)$ 如下：\n$$\n\\mathbf{y}(x) = \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix}\n$$\n相应的一阶方程组是：\n$$\n\\frac{d}{dx}\\mathbf{y}(x) = \\begin{pmatrix} \\psi'(x) \\\\ (V(x) - E)\\psi(x) \\end{pmatrix}\n$$\n该方程组使用打靶法进行数值求解。我们在计算域 $[L, R]$ 上从右边界 $x=R$ 向左边界 $x=L$ 积分。选择这种向后积分方式是因为其具有更优的数值稳定性，特别是对于倏逝解。该域由 $L=x_0-W$ 和 $R=x_0+W$ 定义，其中 $W=12/a$，这确保了 $V(L) \\approx 0$ 和 $V(R) \\approx V_0$，从而证实了使用渐近形式作为边界条件的合理性。\n\n分析方法根据粒子能量 $E$ 与势垒高度 $V_0$ 之间的关系而有所不同。\n\n情况1：全反射 ($0 < E < V_0$)\n当能量低于势垒时，粒子无法在 $x \\to +\\infty$ 区域传播。波函数必须指数衰减：$\\psi(x) \\sim t\\,e^{-\\kappa x}$，其中 $\\kappa = \\sqrt{V_0 - E}$。我们通过基于此渐近形式设置初始条件，在 $x=R$ 处开始数值积分。由于此阶段总归一化常数是任意的，我们可以设系数 $t=1$。因此，在 $x=R$ 处的初始状态向量是实数：\n$$\n\\mathbf{y}(R) = \\begin{pmatrix} \\psi(R) \\\\ \\psi'(R) \\end{pmatrix} = \\begin{pmatrix} e^{-\\kappa R} \\\\ -\\kappa e^{-\\kappa R} \\end{pmatrix}\n$$\n有了这些实数初始条件和一个实势 $V(x)$，从 $x=R$ 到 $x=L$ 的 ODE 方程组的数值积分会产生一个实值解，提供 $\\psi_{num}(L)$ 和 $\\psi'_{num}(L)$ 的实数值。在左侧渐近区 ($x \\to -\\infty$)，波函数是入射波 $e^{ikx}$ 和反射波 $r e^{-ikx}$ 的叠加，其中 $k=\\sqrt{E}$。我们将计算得到的实数解在 $x=L$ 处与一般复数形式 $C(e^{ikx} + r e^{-ikx})$ 相匹配，其中 $C$ 为某个复常数。这得到方程组：\n$$\n\\psi_{num}(L) = C (e^{ikL} + r e^{-ikL})\n$$\n$$\n\\psi'_{num}(L) = C (i k e^{ikL} - i k r e^{-ikL})\n$$\n通过消去 $C$ 来求解这个包含两个方程和单个未知数 $r$ 的方程组，得到反射振幅：\n$$\nr = e^{2ikL} \\frac{i k \\psi_{num}(L) - \\psi'_{num}(L)}{i k \\psi_{num}(L) + \\psi'_{num}(L)}\n$$\n根据此情况的定义，相移是该复数的辐角：$\\delta(E) = \\arg(r)$。概率流守恒要求 $|r|=1$，这是由推导出的 $r$ 表达式在数学上保证的性质。\n\n情况2：透射 ($E > V_0$)\n当能量超过势垒时，粒子可以在整个空间中传播。在右侧渐近区的波函数是一个透射平面波，$\\psi(x) \\sim t\\,e^{iqx}$，其中 $q = \\sqrt{E-V_0}$。为了确定透射振幅 $t$，我们将入射波归一化为单位振幅。我们首先积分一个试探解 $\\psi_{num}(x)$，该试探解通过将其透射部分设为 $e^{iqx}$ 来定义。在 $x=R$ 处的相应初始条件是复数：\n$$\n\\mathbf{y}(R) = \\begin{pmatrix} \\psi(R) \\\\ \\psi'(R) \\end{pmatrix} = \\begin{pmatrix} e^{iqR} \\\\ iq e^{iqR} \\end{pmatrix}\n$$\n向后积分到 $x=L$ 提供了复数值 $\\psi_{num}(L)$ 和 $\\psi'_{num}(L)$。在左侧渐近区，这个数值解的形式为 $\\psi_{num}(x) \\sim A_{num} e^{ikx} + B_{num} e^{-ikx}$，其中 $A_{num}$ 是右行分量的振幅，$B_{num}$ 是左行分量的振幅。我们通过在 $x=L$ 处进行匹配来求解这些系数：\n$$\n\\psi_{num}(L) = A_{num} e^{ikL} + B_{num} e^{-ikL}\n$$\n$$\n\\psi'_{num}(L) = i k A_{num} e^{ikL} - i k B_{num} e^{-ikL}\n$$\n求解入射振幅 $A_{num}$ 可得：\n$$\nA_{num} = \\frac{1}{2} e^{-ikL} \\left( \\psi_{num}(L) + \\frac{\\psi'_{num}(L)}{ik} \\right)\n$$\n通过对我们的数值解进行归一化，使得入射振幅为1，即可得到真实的物理波函数：$\\psi_{phys}(x) = \\psi_{num}(x) / A_{num}$。因此，透射振幅为 $t=1/A_{num}$。此情况的相移定义为 $\\delta(E) = \\arg(t)$。\n\n每个测试用例 $(V_0, a, x_0, E)$ 的算法是首先通过比较 $E$ 和 $V_0$ 来确定物理情景，然后在 $x=R$ 处设置适当的初始条件，将 ODE 方程组数值积分到 $x=L$，最后使用得到的 $\\psi(L)$ 和 $\\psi'(L)$ 的值来计算 $r$ 或 $t$，并提取所需的相移。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to compute phase shifts for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (V0, a, x0, E)\n        (1.0, 1.5, 0.0, 0.2),\n        (1.0, 0.7, -1.0, 0.95),\n        (1.0, 2.0, 0.5, 1.5),\n        (0.5, 3.0, 0.0, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        phase_shift = calculate_phase_shift(*case)\n        results.append(f\"{phase_shift:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n\ndef calculate_phase_shift(v0, a, x0, e):\n    \"\"\"\n    Calculates the scattering phase shift for a particle in a logistic potential.\n    \n    The function solves the time-independent Schrödinger equation numerically using a\n    shooting method, integrating backwards in space from a region where the\n    asymptotic solution is simple. It then matches the solution at the other\n    end of the domain to find the reflection or transmission amplitude and\n    computes the corresponding phase shift.\n\n    Args:\n        v0 (float): Potential step height V_0.\n        a (float): Steepness of the potential.\n        x0 (float): Center of the potential step.\n        e (float): Energy of the incident particle.\n\n    Returns:\n        float: The scattering phase shift in radians.\n    \"\"\"\n    # Define the potential function V(x)\n    def potential(x):\n        return v0 / (1.0 + np.exp(-a * (x - x0)))\n\n    # Define the system of first-order ODEs: y' = f(x, y)\n    # y[0] = psi(x), y[1] = psi'(x)\n    def schrodinger_odes(x, y):\n        psi, psi_prime = y\n        # The second derivative of psi is (V(x) - E) * psi\n        psi_double_prime = (potential(x) - e) * psi\n        return [psi_prime, psi_double_prime]\n\n    # Set up the computational domain [L, R]\n    w = 12.0 / a\n    x_l = x0 - w\n    x_r = x0 + w\n    \n    # Define integration span (backwards from R to L)\n    t_span = [x_r, x_l]\n\n    # Incident wave number\n    k = np.sqrt(e)\n\n    if e  v0:\n        # Regime 1: Total reflection (0  E  V0)\n        kappa = np.sqrt(v0 - e)\n        \n        # Initial conditions at x_r for a decaying real exponential\n        psi_r = np.exp(-kappa * x_r)\n        psi_prime_r = -kappa * psi_r\n        y0 = [psi_r, psi_prime_r]\n        \n        # Solve the Initial Value Problem from R to L\n        sol = solve_ivp(schrodinger_odes, t_span, y0, method='RK45', rtol=1e-9, atol=1e-9)\n        \n        # Extract solution at x_l. sol.y[:, -1] is the state at the final time point.\n        psi_l, psi_prime_l = sol.y[:, -1]\n        \n        # Calculate reflection coefficient r\n        # r = exp(2ikL) * (ik*psi_L - psi'_L) / (ik*psi_L + psi'_L)\n        numerator = 1j * k * psi_l - psi_prime_l\n        denominator = 1j * k * psi_l + psi_prime_l\n        r = np.exp(2j * k * x_l) * (numerator / denominator)\n        \n        # Phase shift is the argument of r\n        delta = np.angle(r)\n        \n    else:  # E >= V0\n        # Regime 2: Transmission (E > V0)\n        q = np.sqrt(e - v0)\n        \n        # Initial conditions at x_r for a forward-propagating complex plane wave\n        psi_r = np.exp(1j * q * x_r)\n        psi_prime_r = 1j * q * psi_r\n        y0 = [psi_r, psi_prime_r]\n        \n        # Solve the IVP from R to L\n        sol = solve_ivp(schrodinger_odes, t_span, y0, method='RK45', rtol=1e-9, atol=1e-9)\n        \n        # Extract complex solution at x_l\n        psi_l_num, psi_prime_l_num = sol.y[:, -1]\n\n        # Calculate the incident amplitude A_num by matching at x_l\n        # A_num = 0.5 * exp(-ikL) * (psi_L + psi'_L / (ik))\n        a_num = 0.5 * np.exp(-1j * k * x_l) * (psi_l_num + psi_prime_l_num / (1j * k))\n        \n        # Transmission coefficient t = 1.0 / A_num\n        t = 1.0 / a_num\n        \n        # Phase shift is the argument of t\n        delta = np.angle(t)\n\n    return delta\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2432197"}, {"introduction": "在处理复杂或任意形状的势垒时，将势垒分解为一系列更简单的片段是一种非常有效的方法。本练习 [@problem_id:2432228] 关注于一个叠加了正弦波纹的势垒，模拟了晶体或超晶格中的周期性微扰。你将学习并应用传递矩阵法，通过矩阵乘法将每个薄片的散射效应组合起来，这是一种在介观物理和纳米电子学中用于模拟一维异质结构的基石技术。", "problem": "一个质量为 $m$ 的非相对论量子粒子在一维空间中运动，其行为由不含时薛定谔方程描述。该粒子从一个长度为 $L$ 的有限势垒区域散射，该区域内的势能是一个高度为 $V_0$ 的基础势垒上叠加了一个正弦波纹。势垒占据 $x \\in [0,L]$ 区间，其势为 $V(x) = V_0 + A \\sin(k x)$，而在势垒之外，即 $x  0$ 和 $x  L$ 的区域，势为零 $V(x) = 0$。使用由 $\\hbar^2/(2m) = 1$ 定义的无量纲单位，从而能量和长度均为无量纲量，且局域波数满足 $q(x) = \\sqrt{E - V(x)}$，其中对于经典禁区，使用复数平方根的主支。粒子以能量 $E  0$ 从左侧入射，我们关心的物理量是透射系数 $T(E)$，其定义为远离势垒区域的透射概率流与入射概率流之比。\n\n从不含时薛定谔方程\n$$\n-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n以及概率流 $J(x)$ 的定义出发，并利用波函数 $\\psi(x)$ 及其一阶导数 $d\\psi/dx$ 在常数势区域交界处的连续性，推导出一个数值稳定的计算方法，以求得给定势垒的透射系数 $T(E)$。你的推导必须从这些基本要素开始，最终得出一个算法。该算法通过组合许多薄均匀势垒切片的作用，将左右两侧的渐近波振幅联系起来，并强制仅从左侧入射。使用复数值的局域波数来处理经典禁区切片，并确保渐近区域之间的通量归一化是正确的。你必须采用一个数值上鲁棒的程序来处理转折点的存在，以避免在切片边界处出现 $E \\approx V(x)$ 时的奇异性。\n\n将你的方法实现为一个完整、可运行的程序，该程序：\n- 将势垒 $[0,L]$ 离散化为 $N$ 个等宽的薄切片，并在每个切片内将 $V(x)$ 近似为常数（在切片中心点计算 $V(x)$）。\n- 组合多个 $2\\times 2$ 转移操作，这些操作强制了跨切片界面的连续性以及在切片内部的传播，从而获得入射和出射平面波振幅之间的整体映射关系。\n- 从组合的映射关系中计算透射系数 $T(E)$，并进行正确的流归一化。在局域波数的数值计算中，给能量 $E$ 加上一个小的正虚部调节项 $+\\mathrm{i}\\eta$（其中 $\\eta$ 严格为正且 $\\eta \\ll 1$），以避免 $E \\approx V(x)$ 时的奇异性，并实现正确的出射波条件。\n- 使用固定的势垒长度 $L = 1$。\n- 使用足够精细的离散化 $N$ 以解析测试套件中最大 $k$ 对应的波纹，同时保持数值稳定性。为所有测试用例选择一个唯一的 $N$ 值。\n\n你的程序必须计算下面指定测试套件中每种能量的 $T(E)$，并将报告的每个透射率四舍五入到 $6$ 位小数。\n\n测试套件（每个测试用例是一个元组 $(V_0,A,k,L,\\{E\\text{ 列表}\\})$，单位如上定义；此处所有用例中 $L=1$）：\n- 用例 1 (正常路径，中等波纹): $(V_0,A,k,L,\\{E\\}) = (0.5, 0.1, 16\\pi, 1, \\{0.2, 0.5, 0.8, 1.2\\})$.\n- 用例 2 (边界情况，无波纹简化为方势垒): $(V_0,A,k,L,\\{E\\}) = (0.6, 0.0, 6\\pi, 1, \\{0.2, 0.61, 1.0\\})$.\n- 用例 3 (边缘情况，快速波纹): $(V_0,A,k,L,\\{E\\}) = (0.4, 0.2, 40\\pi, 1, \\{0.3, 0.7\\})$.\n- 用例 4 (边缘情况，无基础势垒的波纹): $(V_0,A,k,L,\\{E\\}) = (0.0, 0.3, 8\\pi, 1, \\{0.05, 0.2, 0.5\\})$.\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。其中每个元素对应一个测试用例，其本身是该用例中各能量下的透射系数值列表，顺序与上文所列一致。例如，输出格式必须如下所示\n$[[$t_{1,1}$,$t_{1,2}$,\\dots],[$t_{2,1}$,\\dots],\\dots]$,\n其中每个 $t_{i,j}$ 是一个四舍五入到 $6$ 位小数的浮点数。", "solution": "所提出的问题是单维量子散射理论中的一个标准练习，其表述在科学上是合理的、适定的和完整的。因此，它被认为是一个有效的问题。我们按照要求，基于转移矩阵法进行数值解的严格推导。\n\n我们的出发点是质量为 $m$、能量为 $E$ 的粒子在势 $V(x)$ 中的不含时薛定谔方程：\n$$\n-\\frac{\\hbar^2}{2m} \\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n使用指定的无量纲单位，其中 $\\hbar^2/(2m) = 1$，方程简化为：\n$$\n-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x) \\quad \\implies \\quad \\frac{d^2\\psi(x)}{dx^2} + (E - V(x))\\,\\psi(x) = 0\n$$\n我们定义局域波数 $q(x) = \\sqrt{E - V(x)}$。问题指定使用一个小的正虚部调节项 $\\eta$，因此我们将 $E$ 替换为复能量 $E_{comp} = E + i\\eta$。这确保了局域波数 $q(x) = \\sqrt{E_{comp} - V(x)}$ 永远不为零，从而解决了在经典转折点 $E = V(x)$ 处可能出现的奇异性问题。这里使用复数平方根的主支。\n\n该数值方法的核心是将势垒区域 $x \\in [0, L]$ 离散化为 $N$ 个宽度相等的连续切片，每个切片的宽度为 $\\Delta x = L/N$。在从 $x_j = j\\Delta x$ 到 $x_{j+1} = (j+1)\\Delta x$ 的每个切片 $j$ 内部，我们将势 $V(x)$ 近似为一个常数 $V_j$，其值在切片中点计算：$V_j = V(x_j + \\Delta x/2)$。因此，每个切片内的局域波数也是一个常数，记为 $q_j = \\sqrt{E_{comp} - V_j}$。\n\n在势为常数的切片 $j$ 中，薛定谔方程是一个简谐振子方程：\n$$\n\\frac{d^2\\psi(x)}{dx^2} + q_j^2\\,\\psi(x) = 0\n$$\n该切片内 $\\psi(x)$ 的通解是振荡函数或指数函数的线性组合，可以用切片起点 $x_j$ 处的初始条件来表示。系统在任意点 $x$ 的状态可以用一个包含波函数及其导数的矢量来描述：$\\vec{\\Psi}(x) = \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix}$。\n\n在给定 $x_j$ 处的状态下，切片内 $x$ 点的解为：\n$$\n\\psi(x) = \\psi(x_j)\\cos(q_j(x-x_j)) + \\frac{\\psi'(x_j)}{q_j}\\sin(q_j(x-x_j))\n$$\n$$\n\\psi'(x) = -q_j\\psi(x_j)\\sin(q_j(x-x_j)) + \\psi'(x_j)\\cos(q_j(x-x_j))\n$$\n在切片末端 $x = x_{j+1} = x_j + \\Delta x$ 处对该解求值，我们得到切片边界处状态矢量之间的线性关系：$\\vec{\\Psi}(x_{j+1}) = P_j \\vec{\\Psi}(x_j)$。矩阵 $P_j$ 是切片 $j$ 的传播矩阵或转移矩阵：\n$$\nP_j = \\begin{pmatrix} \\cos(q_j \\Delta x)  \\frac{\\sin(q_j \\Delta x)}{q_j} \\\\ -q_j \\sin(q_j \\Delta x)  \\cos(q_j \\Delta x) \\end{pmatrix}\n$$\n使用复数调节项 $\\eta$ 确保了 $q_j \\neq 0$，因此项 $\\sin(q_j \\Delta x)/q_j$ 总是良定义的。\n\n由于波函数 $\\psi(x)$ 及其导数 $\\psi'(x)$ 必须处处连续，状态矢量 $\\vec{\\Psi}(x)$ 在切片之间的边界上也是连续的。因此，为了找到 $x=0$ 和 $x=L$ 处状态之间的关系，我们只需按顺序组合所有切片的转移矩阵：\n$$\n\\vec{\\Psi}(L) = P_{N-1} P_{N-2} \\cdots P_1 P_0 \\vec{\\Psi}(0)\n$$\n设势垒的总转移矩阵为 $M = P_{N-1} P_{N-2} \\cdots P_0$。那么 $\\vec{\\Psi}(L) = M \\vec{\\Psi}(0)$。每个 $P_j$ 的行列式为 $\\cos^2(q_j \\Delta x) + \\sin^2(q_j \\Delta x) = 1$，所以总矩阵 $M$ 的行列式也为1，即 $\\det(M)=1$。\n\n接下来，我们将势垒边界处的状态矢量与渐近平面波解联系起来。粒子从左侧入射。\n对于 $x  0$（区域I），$V(x)=0$。波函数是入射波和反射波的叠加：$\\psi_I(x) = A e^{i k_0 x} + B e^{-i k_0 x}$，其中 $k_0 = \\sqrt{E_{comp}}$。\n对于 $x  L$（区域III），$V(x)=0$。波函数仅包含一个透射波：$\\psi_{III}(x) = C e^{i k_0 (x-L)}$。为了方便，在 $x=L$ 处选择了这个相位。\n\n根据这些形式，我们计算 $x=0$ 和 $x=L$ 处的状态矢量：\n在 $x=0$ 处：$\\psi(0) = A+B$ 且 $\\psi'(0) = i k_0 (A-B)$。\n在 $x=L$ 处：$\\psi(L) = C$ 且 $\\psi'(L) = i k_0 C$。\n\n现在我们可以通过对总转移矩阵关系式求逆来用透射振幅 $C$ 表示渐近振幅 $(A, B)$：$\\vec{\\Psi}(0) = M^{-1} \\vec{\\Psi}(L)$。由于 $\\det(M)=1$，逆矩阵很简单：$M^{-1} = \\begin{pmatrix} M_{22}  -M_{12} \\\\ -M_{21}  M_{11} \\end{pmatrix}$。\n代入边界条件：\n$$\n\\begin{pmatrix} A+B \\\\ i k_0 (A-B) \\end{pmatrix} = \\begin{pmatrix} M_{22}  -M_{12} \\\\ -M_{21}  M_{11} \\end{pmatrix} \\begin{pmatrix} C \\\\ i k_0 C \\end{pmatrix}\n$$\n这得到两个线性方程：\n1) $\\: A+B = (M_{22} - i k_0 M_{12}) C$\n2) $\\: A-B = \\frac{1}{i k_0}(-M_{21} + i k_0 M_{11}) C$\n\n将这两个方程相加，消去 $B$，得到 $2A$ 的表达式：\n$$\n2A = \\left( (M_{11} + M_{22}) - i k_0 M_{12} - \\frac{M_{21}}{i k_0} \\right) C\n$$\n透射系数 $T$ 是透射概率流与入射概率流之比。对于平面波 $e^{ikx}$，概率流与 $k$ 成正比。由于入射区和透射区的波数 $k_0$ 相同，$T$ 简化为振幅平方之比：$T = |C/A|^2$。从 $2A$ 的表达式中，我们求出 $C/A$：\n$$\n\\frac{C}{A} = \\frac{2}{M_{11} + M_{22} - i k_0 M_{12} + i \\frac{M_{21}}{k_0}}\n$$\n因此，透射系数为：\n$$\nT(E) = \\left| \\frac{2}{M_{11} + M_{22} - i k_0 M_{12} + i M_{21}/k_0} \\right|^2\n$$\n该公式与计算总转移矩阵 $M$ 的过程相结合，提供了一个完整且数值稳定的算法，用于计算任何给定能量 $E$ 的透射系数。\n\n实现的算法如下：\n1. 对于给定的一组参数 $(V_0, A, k, L, E)$，设置数值常数 $N$（切片数）和 $\\eta$（调节项）。$N=1000$ 的值足以解析势函数中最快的振荡，而 $\\eta=10^{-8}$ 是一个合适的调节项。\n2. 创建 $N$ 个切片中点的网格，并计算每个切片的势 $V_j$。\n3. 对于每个能量 $E$，计算 $E_{comp} = E + i\\eta$ 以及对应的波数 $k_0$ 和所有切片的 $q_j$。\n4. 将总转移矩阵 $M$ 初始化为 $2 \\times 2$ 的单位矩阵。\n5. 从 $j=0$ 到 $N-1$ 迭代，使用公式计算切片矩阵 $P_j$，并通过左乘更新总矩阵：$M_{new} = P_j \\cdot M_{old}$。这能正确计算出乘积 $M = P_{N-1} \\cdots P_0$。\n6. 使用最终矩阵 $M$ 的元素和波数 $k_0$，根据推导出的公式计算 $T(E)$。\n7. 对测试用例中的所有能量重复此过程。\n8. 按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum scattering problem for the specified test cases.\n    \"\"\"\n    \n    # Test suite from the problem statement.\n    test_cases = [\n        (0.5, 0.1, 16.0 * np.pi, 1.0, [0.2, 0.5, 0.8, 1.2]),\n        (0.6, 0.0, 6.0 * np.pi, 1.0, [0.2, 0.61, 1.0]),\n        (0.4, 0.2, 40.0 * np.pi, 1.0, [0.3, 0.7]),\n        (0.0, 0.3, 8.0 * np.pi, 1.0, [0.05, 0.2, 0.5]),\n    ]\n    \n    # Global numerical parameters\n    N = 1000  # Number of slices for discretization\n    eta = 1e-8  # Small imaginary regulator for energy\n\n    all_results = []\n    for V0, A, k_ripple, L, E_list in test_cases:\n        case_results = []\n        dx = L / N\n        x_centers = (np.arange(N) + 0.5) * dx\n        V_slices = V0 + A * np.sin(k_ripple * x_centers)\n\n        for E in E_list:\n            if E = 0:\n                # For E=0 and V(x)>=0 far away, T=0. Handle E=0 separately\n                # to avoid issues if V_slices contains negative values near E=0.\n                # The problem statement specifies E > 0, but E=0.05 is close.\n                # A small positive E is fine with the general method.\n                if E == 0.0:\n                    case_results.append(0.0)\n                    continue\n\n            E_comp = E + 1j * eta\n            \n            # Wavenumber in asymptotic regions (V=0)\n            k0 = np.sqrt(E_comp)\n            \n            # Wavenumbers in each slice of the barrier\n            q_slices = np.sqrt(E_comp - V_slices)\n            \n            # Initialize total transfer matrix as the identity matrix\n            M_total = np.identity(2, dtype=np.complex128)\n            \n            # Compose the total transfer matrix by multiplying slice matrices\n            # M_total = P_{N-1} * ... * P_1 * P_0\n            for j in range(N):\n                qj = q_slices[j]\n                \n                # Pre-calculate cos and sin for the slice propagation matrix\n                cos_qdx = np.cos(qj * dx)\n                sin_qdx = np.sin(qj * dx)\n                \n                # Propagation matrix for slice j\n                # Pj = [[cos(qj*dx), sin(qj*dx)/qj],\n                #       [-qj*sin(qj*dx), cos(qj*dx)]]\n                Pj = np.array([\n                    [cos_qdx, sin_qdx / qj],\n                    [-qj * sin_qdx, cos_qdx]\n                ], dtype=np.complex128)\n                \n                # Left-multiply to build up the total matrix P_{j} * ... * P_{0}\n                M_total = Pj @ M_total\n            \n            # Extract elements of the total transfer matrix M\n            M11, M12, M21, M22 = M_total[0, 0], M_total[0, 1], M_total[1, 0], M_total[1, 1]\n            \n            # Calculate C/A using the derived formula\n            # C/A = 2 / (M11 + M22 - i*k0*M12 + i*M21/k0)\n            C_over_A = 2.0 / (M11 + M22 - 1j * k0 * M12 + 1j * M21 / k0)\n            \n            # Transmission coefficient T = |C/A|^2\n            transmission = np.abs(C_over_A)**2\n            \n            case_results.append(transmission)\n            \n        all_results.append(case_results)\n    \n    # Format the final output string as specified\n    # Example: [[0.123456,0.789012],[0.456789,...]]\n    outer_list_str = []\n    for res_list in all_results:\n        inner_list_str = ','.join([f\"{t:.6f}\" for t in res_list])\n        outer_list_str.append(f\"[{inner_list_str}]\")\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2432228"}, {"introduction": "本章的最后一个练习将我们从静态散射问题带入动态的量子世界。我们将通过求解含时薛定谔方程 ($i\\hbar \\frac{\\partial}{\\partial t} \\psi = \\hat{H}\\psi$) 来设计一个“量子回旋镖”，即一个可以捕获并反转波包运动方向的含时势阱 [@problem_id:2432194]。为此，你将实现基于快速傅里叶变换 (FFT) 的分裂算符法，这不仅是现代计算物理中模拟量子动力学的核心方法，还将让你直观地体验到量子控制的迷人魅力。", "problem": "您必须编写一个完整的、可运行的程序，对一维空间中时变势的量子散射进行数值模拟，并评估一个设计好的势场是否能像“量子回旋镖”一样，捕获一个波包并将其送回其初始位置。从一维空间中非相对论性粒子的含时薛定谔方程出发，\n$$\ni \\hbar \\,\\frac{\\partial}{\\partial t} \\psi(x,t) \\;=\\; \\left[ -\\frac{\\hbar^2}{2m}\\,\\frac{\\partial^2}{\\partial x^2} + V(x,t) \\right] \\psi(x,t).\n$$\n使用无量纲化的自然单位制，其中约化普朗克常数 $\\hbar = 1$ 且质量 $m = 1$，方程变为\n$$\ni \\,\\frac{\\partial}{\\partial t} \\psi(x,t) \\;=\\; \\left[ -\\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2} + V(x,t) \\right] \\psi(x,t).\n$$\n计算域为长度为 $L$ 的周期性区间，其中 $x \\in [-L/2, L/2)$ 在一个包含 $N_x$ 个点的均匀网格上离散化，空间步长为 $\\Delta x = L/N_x$，时间步长为 $\\Delta t$。使用基于算符分解的分裂算符 (Strang) 方法，该方法在 $\\Delta t$ 上具有二阶精度：\n$$\ne^{-i \\Delta t \\,\\left(T+V\\right)} \\;\\approx\\; e^{-i \\frac{\\Delta t}{2} V(t+\\Delta t/2)} \\; e^{-i \\Delta t \\, T} \\; e^{-i \\frac{\\Delta t}{2} V(t+\\Delta t/2)},\n$$\n其中动能算符为 $T = -\\frac{1}{2}\\,\\partial_x^2$，势能算符为乘以 $V(x,t)$。使用波数网格 $k_n = \\frac{2\\pi}{L} n$（其中 $n \\in \\{-N_x/2,\\dots,N_x/2-1\\}$，这与标准快速傅里叶变换定义返回的一致）在傅里叶空间中实现 $e^{-i \\Delta t \\, T}$，使得平面波按相位 $e^{-i \\Delta t \\, k^2 / 2}$ 演化。为避免周期性边界导致的非物理环绕效应，通过向 $V(x,t)$ 添加一个虚势 $-i \\eta(x)$，在计算域的两个边缘附近设置一个弱复吸收层。其中 $\\eta(x) \\ge 0$ 是一个平滑函数，仅在靠近 $x \\approx \\pm L/2$、宽度为 $L_{\\text{abs}}$ 的边界层内非零。\n\n初始状态必须是一个归一化的高斯波包，\n$$\n\\psi(x,0) \\;=\\; \\left(\\frac{1}{\\pi \\sigma_0^2}\\right)^{1/4} \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma_0^2} \\right) \\exp\\!\\left( i k_0 (x-x_0) \\right),\n$$\n其参数如下所述。设设计的时变势为一个移动的谐振子陷阱，旨在捕获并将波包带回：\n$$\nV(x,t) \\;=\\; \\frac{1}{2}\\,\\Omega^2 \\, \\big(x - x_c(t)\\big)^2 \\, A(t) \\;-\\; i\\,\\eta(x).\n$$\n在此，$\\Omega$ 是陷阱的角频率（控制约束强度），$x_c(t)$ 是陷阱中心，$A(t)$ 是一个平滑包络，用于开启和关闭陷阱。将陷阱中心定义为分段线性轨迹，该轨迹首先与初始波包一同移动，然后反向，将其送回原点附近：\n$$\nx_c(t) \\;=\\;\n\\begin{cases}\nx_0 + k_0 \\, t,  0 \\le t \\le t_{\\text{turn}},\\\\\nx_0 + k_0 \\, t_{\\text{turn}} \\;-\\; u_{\\text{return}}\\,\\big(t - t_{\\text{turn}}\\big),  t  t_{\\text{turn}}.\n\\end{cases}\n$$\n将平滑的开关包络定义为独立的上升和下降斜坡函数的乘积，\n$$\nA(t) \\;=\\; R_{\\text{on}}(t)\\,R_{\\text{off}}(t),\n$$\n其中\n$$\nR_{\\text{on}}(t) \\;=\\;\n\\begin{cases}\n0,  t  t_{\\text{on}},\\\\\n\\sin^2\\!\\Big( \\dfrac{\\pi}{2} \\,\\dfrac{t - t_{\\text{on}}}{\\Delta_{\\text{on}}} \\Big),  t_{\\text{on}} \\le t \\le t_{\\text{on}} + \\Delta_{\\text{on}},\\\\\n1,  t  t_{\\text{on}} + \\Delta_{\\text{on}},\n\\end{cases}\n\\qquad\nR_{\\text{off}}(t) \\;=\\;\n\\begin{cases}\n1,  t  t_{\\text{off,start}},\\\\\n\\cos^2\\!\\Big( \\dfrac{\\pi}{2} \\,\\dfrac{t - t_{\\text{off,start}}}{\\Delta_{\\text{off}}} \\Big),  t_{\\text{off,start}} \\le t \\le t_{\\text{off,start}} + \\Delta_{\\text{off}},\\\\\n0,  t  t_{\\text{off,start}} + \\Delta_{\\text{off}}.\n\\end{cases}\n$$\n吸收层的剖面必须为\n$$\n\\eta(x) \\;=\\; \\eta_0 \\left[ \\Theta\\!\\big(x_L - x\\big)\\,\\left(\\frac{x_L-x}{L_{\\text{abs}}}\\right)^m + \\Theta\\!\\big(x - x_R\\big)\\,\\left(\\frac{x - x_R}{L_{\\text{abs}}}\\right)^m \\right],\n$$\n其中 $x_L = -\\frac{L}{2} + L_{\\text{abs}}$, $x_R = \\frac{L}{2} - L_{\\text{abs}}$, $\\Theta$ 是亥维赛德阶跃函数 (Heaviside step function)，$m \\in \\mathbb{N}$ 是一个偶数整数。\n\n您必须模拟直到最终时刻 $T$ 的时间演化，并对于每个指定的参数集，计算在终点时位于固定阈值位置 $x_{\\text{th}}$ 左侧的概率分数：\n$$\nP_{\\text{left}} \\;=\\; \\frac{\\displaystyle \\int_{-\\frac{L}{2}}^{x_{\\text{th}}}\\! |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{-\\frac{L}{2}}^{\\frac{L}{2}}\\! |\\psi(x,T)|^2 \\, dx}.\n$$\n将 $P_{\\text{left}}$ 解释为一个诊断指标：接近 $1$ 的值表示成功地“回旋”返回原点附近，而接近 $0$ 的值表示未能返回。\n\n在所有运行中，使用以下固定的数值参数（以上述无量纲单位表示）：域长度 $L = 200$，网格大小 $N_x = 1024$，时间步长 $\\Delta t = 0.03$，最终时间 $T = 45$，吸收层宽度 $L_{\\text{abs}} = 30$，吸收层强度 $\\eta_0 = 0.01$，吸收层幂次 $m = 2$，阈值 $x_{\\text{th}} = -20$。初始波包参数：中心 $x_0 = -30$，宽度 $\\sigma_0 = 2$，波数 $k_0 = 1$。\n\n实现以下三个测试案例。除非明确说明，否则所有参数均为上述共享值。每个案例指定了陷阱参数 $(\\Omega, t_{\\text{on}}, \\Delta_{\\text{on}}, t_{\\text{turn}}, u_{\\text{return}}, t_{\\text{off,start}}, \\Delta_{\\text{off}})$：\n\n- 案例 A（预期成功，绝热捕获与返回）：$\\Omega = 0.5$, $t_{\\text{on}} = 2$, $\\Delta_{\\text{on}} = 10$, $t_{\\text{turn}} = 24$, $u_{\\text{return}} = 1.2$, $t_{\\text{off,start}} = 35$, $\\Delta_{\\text{off}} = 10$。\n\n- 案例 B（弱陷阱，预期捕获失败）：$\\Omega = 0.05$, $t_{\\text{on}} = 2$, $\\Delta_{\\text{on}} = 10$, $t_{\\text{turn}} = 24$, $u_{\\text{return}} = 1.2$, $t_{\\text{off,start}} = 35$, $\\Delta_{\\text{off}} = 10$。\n\n- 案例 C（强但突变的陷阱，预期部分/非绝热捕获）：$\\Omega = 0.5$, $t_{\\text{on}} = 2$, $\\Delta_{\\text{on}} = 1$, $t_{\\text{turn}} = 24$, $u_{\\text{return}} = 1.2$, $t_{\\text{off,start}} = 44$, $\\Delta_{\\text{off}} = 1$。\n\n您的程序必须为每个案例计算 $P_{\\text{left}}$，并生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序为 [案例 A, 案例 B, 案例 C]。每个值都必须四舍五入到小数点后六位，并以小数形式表示（而非百分比）。例如，输出格式必须类似于\n`[0.812345,0.012300,0.456700]`。", "solution": "所提出的问题是计算量子力学中一个有效且适定 (well-posed) 的练习。它要求数值求解一维含时薛定谔方程 (TDSE)，以模拟量子波包与时变势相互作用的动力学。该问题具有科学依据，提供了精确的数学公式、一个标准且稳健的数值方法（分裂算符 FFT），以及一套用于实现的完整参数。问题中没有矛盾、歧义或缺失的信息。我现在将详细描述解决方法。\n\n控制方程是在无量纲单位下的 TDSE，其中 $\\hbar=1$ 且粒子质量 $m=1$：\n$$ i \\,\\frac{\\partial}{\\partial t} \\psi(x,t) \\;=\\; \\hat{H}(t) \\psi(x,t) \\;=\\; \\left[ -\\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2} + V(x,t) \\right] \\psi(x,t) $$\n这里，$\\hat{H}(t)$ 是含时哈密顿量，是动能算符 $\\hat{T} = -\\frac{1}{2}\\partial_x^2$ 和势能算符 $\\hat{V}(t)$（即乘以 $V(x,t)$）之和。\n\n在一个小时间步长 $\\Delta t$ 内，形式解由时间演化算符的作用给出，即 $\\psi(t+\\Delta t) = \\hat{U}(t+\\Delta t, t) \\psi(t)$。由于 $\\hat{T}$ 和 $\\hat{V}(t)$ 不对易，且 $\\hat{H}(t)$ 是含时的，我们使用一个对 $\\hat{U}$ 的近似。问题指定了二阶对称 Strang 分裂方法，该方法将演化算符近似为：\n$$ \\hat{U}(t+\\Delta t, t) \\approx e^{-i \\frac{\\Delta t}{2} \\hat{V}(t+\\frac{\\Delta t}{2})} \\; e^{-i \\Delta t \\, \\hat{T}} \\; e^{-i \\frac{\\Delta t}{2} \\hat{V}(t+\\frac{\\Delta t}{2})} $$\n此公式规定了将波函数 $\\psi(x)$ 从时间 $t_n$ 传播到 $t_{n+1} = t_n + \\Delta t$ 的算法：\n1.  **第一步：势能部分：** 将势能算符作用半个时间步长。这在位置空间中是一个乘法操作。为保持二阶精度，势能在时间间隔的中点 $t_n + \\Delta t/2$ 处进行求值。\n    $$ \\psi'(x) = e^{-i \\frac{\\Delta t}{2} V(x, t_n + \\frac{\\Delta t}{2})} \\psi(x, t_n) $$\n2.  **第二步：动能部分：** 将动能算符作用一个完整的时间步长。此操作在傅里叶（动量）空间中执行效率最高。动能算符 $\\hat{T} = -\\frac{1}{2}\\partial_x^2$ 在傅里叶域中变为简单的乘以 $\\frac{k^2}{2}$。过程如下：\n    a.  计算波函数的正向快速傅里叶变换 (FFT)：$\\tilde{\\psi}'(k) = \\mathcal{F}[\\psi'(x)]$。\n    b.  乘以动能相位因子：$\\tilde{\\psi}''(k) = e^{-i \\Delta t \\frac{k^2}{2}} \\tilde{\\psi}'(k)$。\n    c.  计算逆 FFT：$\\psi''(x) = \\mathcal{F}^{-1}[\\tilde{\\psi}''(k)]$。\n3.  **第三步：势能部分：** 将势能算符作用第二个半时间步长，使用与第一步中相同的位于中点的势能。\n    $$ \\psi(x, t_{n+1}) = e^{-i \\frac{\\Delta t}{2} V(x, t_n + \\frac{\\Delta t}{2})} \\psi''(x) $$\n这个三步序列构成了一次时间演化迭代。从 $t=0$ 到最终时间 $T$ 不断重复此过程。\n\n模拟在离散网格上进行。空间域 $x \\in [-L/2, L/2)$ 被离散为 $N_x$ 个点，间距为 $\\Delta x = L/N_x$。用于 FFT 的相应波数网格由 $k_n = \\frac{2\\pi}{L} n$ 给出，其中整数 $n \\in \\{-N_x/2, \\dots, N_x/2-1\\}$，这可以方便地使用标准数值库函数（如 `numpy.fft.fftfreq`）生成。\n\n模拟的各个组成部分构建如下：\n- **初始状态：** $t=0$ 时的初始波函数是一个高斯波包：\n  $$ \\psi(x,0) \\;=\\; \\left(\\frac{1}{\\pi \\sigma_0^2}\\right)^{1/4} \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma_0^2} \\right) \\exp\\!\\left( i k_0 (x-x_0) \\right) $$\n  此函数在离散空间网格 `x` 上求值，以初始化模拟。\n- **含时势：** 势 $V(x,t)$ 包括两部分：代表移动谐振子陷阱的实部和代表吸收边界的虚部。\n  $$ V(x,t) \\;=\\; \\underbrace{\\frac{1}{2}\\,\\Omega^2 \\, \\big(x - x_c(t)\\big)^2 \\, A(t)}_{V_{\\text{trap}}(x,t)} \\;-\\; i\\,\\underbrace{\\eta(x)}_{\\text{absorber}} $$\n  吸收项 $\\eta(x)$ 是静态的，被设计成一个多项式函数，在域边缘 $x = \\pm L/2$ 附近平滑地开启，以防止周期性边界产生非物理反射。陷阱部分需要在每个时间步计算陷阱中心 $x_c(t)$ 和振幅 $A(t)$，它们由问题陈述中指定的分段函数定义。这些函数将被实现，以在所需时间 $t_n + \\Delta t/2$ 处计算其值。\n\n最后，在将系统演化到最终时间 $T$ 后，计算我们关心的量 $P_{\\text{left}}$。这是 $x  x_{\\text{th}}$ 区域的积分概率密度与整个域上的总积分概率密度之比。\n$$ P_{\\text{left}} \\;=\\; \\frac{\\displaystyle \\int_{-\\frac{L}{2}}^{x_{\\text{th}}}\\! |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{-\\frac{L}{2}}^{\\frac{L}{2}}\\! |\\psi(x,T)|^2 \\, dx} $$\n积分通过在离散网格点上的数值求和来近似。分母是波函数在时刻 $T$ 的总范数，由于虚势的吸收作用，该值将小于其初始值 1。分子是类似的求和，但仅限于网格点 $x_j  x_{\\text{th}}$。\n\n程序将被构造成对三个测试案例中的每一个执行此模拟，并收集每个案例计算出的 $P_{\\text{left}}$。最终输出将是这些值的格式化列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum boomerang problem by simulating the Time-Dependent\n    Schrödinger Equation using the split-operator method.\n    \"\"\"\n\n    # --- Fixed Numerical and Physical Parameters ---\n    L = 200.0         # Domain length\n    Nx = 1024         # Number of grid points\n    dt = 0.03         # Time step\n    T_final = 45.0    # Final time\n    L_abs = 30.0      # Absorber width\n    eta0 = 0.01       # Absorber strength\n    m_abs = 2         # Absorber power (must be even integer)\n    x_th = -20.0      # Threshold position for P_left calculation\n\n    # --- Initial Wave Packet Parameters ---\n    x0 = -30.0        # Initial position\n    sigma0 = 2.0      # Initial width\n    k0 = 1.0          # Initial wave number\n\n    # --- Test Cases ---\n    # Parameters: (Omega, t_on, Delta_on, t_turn, u_return, t_off_start, Delta_off)\n    test_cases = [\n        # Case A: Intended success\n        (0.5, 2.0, 10.0, 24.0, 1.2, 35.0, 10.0),\n        # Case B: Weak trap, intended failure\n        (0.05, 2.0, 10.0, 24.0, 1.2, 35.0, 10.0),\n        # Case C: Abrupt trap, partial capture\n        (0.5, 2.0, 1.0, 24.0, 1.2, 44.0, 1.0),\n    ]\n\n    # --- Spatial and Wave Number Grids ---\n    dx = L / Nx\n    x = np.linspace(-L / 2, L / 2, Nx, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n\n    # --- Kinetic Energy Operator in Fourier Space ---\n    T_op_fourier = np.exp(-1j * (k**2 / 2.0) * dt)\n    \n    # --- Helper Functions for Time-Dependent Potential ---\n    \n    def get_trap_center(t, t_turn, u_return):\n        if t = t_turn:\n            return x0 + k0 * t\n        else:\n            return x0 + k0 * t_turn - u_return * (t - t_turn)\n\n    def get_envelope_A(t, t_on, Delta_on, t_off_start, Delta_off):\n        # On-ramp\n        if t  t_on:\n            R_on = 0.0\n        elif t = t_on + Delta_on:\n            R_on = np.sin(0.5 * np.pi * (t - t_on) / Delta_on)**2\n        else:\n            R_on = 1.0\n        \n        # Off-ramp\n        if t  t_off_start:\n            R_off = 1.0\n        elif t = t_off_start + Delta_off:\n            R_off = np.cos(0.5 * np.pi * (t - t_off_start) / Delta_off)**2\n        else:\n            R_off = 0.0\n            \n        return R_on * R_off\n\n    # --- Absorber Potential ---\n    xL = -L / 2 + L_abs\n    xR = L / 2 - L_abs\n    eta = np.zeros_like(x)\n    \n    left_mask = x  xL\n    eta[left_mask] = eta0 * ((xL - x[left_mask]) / L_abs)**m_abs\n\n    right_mask = x > xR\n    eta[right_mask] = eta0 * ((x[right_mask] - xR) / L_abs)**m_abs\n\n    V_absorber = -1j * eta\n\n    results = []\n    \n    for case_params in test_cases:\n        Omega, t_on, Delta_on, t_turn, u_return, t_off_start, Delta_off = case_params\n\n        # --- Initial Wave Function ---\n        norm_factor = (1.0 / (np.pi * sigma0**2))**0.25\n        psi = norm_factor * np.exp(-(x - x0)**2 / (2 * sigma0**2)) * np.exp(1j * k0 * (x-x0))\n        \n        # --- Time Evolution Loop ---\n        num_steps = int(T_final / dt)\n        for i in range(num_steps):\n            t_mid = (i + 0.5) * dt\n            \n            # --- Construct Potential at Mid-Step Time ---\n            xc_t = get_trap_center(t_mid, t_turn, u_return)\n            A_t = get_envelope_A(t_mid, t_on, Delta_on, t_off_start, Delta_off)\n            V_trap = 0.5 * Omega**2 * (x - xc_t)**2 * A_t\n            V_total = V_trap + V_absorber\n            \n            V_op = np.exp(-1j * V_total * dt / 2.0)\n            \n            # --- Split-Operator Steps ---\n            # 1. Half-step in potential\n            psi = V_op * psi\n            \n            # 2. Full-step in kinetic energy (in Fourier space)\n            psi_f = np.fft.fft(psi)\n            psi_f = T_op_fourier * psi_f\n            psi = np.fft.ifft(psi_f)\n            \n            # 3. Second half-step in potential\n            psi = V_op * psi\n            \n        # --- Calculate P_left ---\n        prob_density = np.abs(psi)**2\n        total_prob = np.sum(prob_density) * dx\n        \n        left_region_mask = x  x_th\n        left_prob = np.sum(prob_density[left_region_mask]) * dx\n        \n        p_left = left_prob / total_prob if total_prob > 1e-12 else 0.0\n        results.append(f\"{p_left:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2432194"}]}