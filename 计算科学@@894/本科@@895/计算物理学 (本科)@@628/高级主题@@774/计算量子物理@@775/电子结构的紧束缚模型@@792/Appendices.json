{"hands_on_practices": [{"introduction": "为了开始我们的动手实践之旅，我们将模拟晶体中最基本的量子现象之一：电子的运动。这个练习将探索一个高斯波包在简单一维紧束缚链中的时间演化过程 [@problem_id:2446520]。通过追踪波包的位置和宽度，你将对群速度和量子色散等概念获得直接而实际的理解，从而在理论能带结构与载流子的真实空间动力学之间建立起一座桥梁。", "problem": "考虑一个由 $N$ 个原子格点构成的一维（$1$D）环，其由具有周期性边界条件的最近邻紧束缚（TB）哈密顿量描述。该哈密顿量作用于单粒子波函数 $\\lvert \\psi(t) \\rangle$，并在格点基 $\\lvert n \\rangle$（其中 $n \\in \\{0,1,\\dots,N-1\\}$ 且 $\\lvert n+N \\rangle \\equiv \\lvert n \\rangle$）上定义为\n$$\n\\hat{H} = -J \\sum_{n=0}^{N-1} \\left( \\lvert n \\rangle \\langle n+1 \\rvert + \\lvert n+1 \\rangle \\langle n \\rvert \\right),\n$$\n其中 $J>0$ 是跃迁能量。实时间演化由含时薛定谔方程决定\n$$\ni \\hbar \\frac{d}{dt} \\lvert \\psi(t) \\rangle = \\hat{H} \\lvert \\psi(t) \\rangle.\n$$\n在时间 $t=0$ 时，系统被制备在一个归一化高斯波包中，该波包在格点表象中以格点 $n_0$ 为中心，宽度参数为 $\\sigma$，载波矢为 $k_0$，\n$$\n\\psi_n(0) = \\mathcal{N} \\exp\\!\\left(-\\frac{(n-n_0)^2}{4 \\sigma^2}\\right) \\exp(i k_0 n),\n$$\n其中 $\\mathcal{N}$ 是归一化常数，且 $n \\in \\{0,1,\\dots,N-1\\}$。在格点 $n$ 处的概率为 $P_n(t)=\\lvert \\psi_n(t) \\rvert^2$。将时间 $t$ 时的平均位置和方差定义为\n$$\n\\langle n \\rangle_t = \\sum_{n=0}^{N-1} n\\, P_n(t), \\qquad\n\\mathrm{Var}(t) = \\sum_{n=0}^{N-1} \\left(n - \\langle n \\rangle_t \\right)^2 P_n(t).\n$$\n假设在下述参数选择下，波包保持良好局域，不会环绕环，因此上述使用整数坐标 $n$ 的定义是有效的。\n\n仅从上述定义、含时薛定谔方程以及平移不变的最近邻紧束缚链具有平面波本征态这一事实出发，推导一个算法来计算精确的时间演化 $\\lvert \\psi(t) \\rangle$ 并评估波包的弥散。您还必须通过对晶格平移不变性所产生的单粒子能带能量进行微分，来获得给定波矢 $k$ 下的解析群速度 $v_g$，并将其与有限时间间隔内数值测量的平均速度进行比较。\n\n实现一个程序，对于下述测试套件中的每一组参数，计算两个量：\n- 弥散比 $r = \\mathrm{Var}(t_\\mathrm{f}) / \\mathrm{Var}(0)$。\n- 绝对群速度误差 $\\Delta v = \\left| \\frac{\\langle n \\rangle_{t_\\mathrm{f}} - \\langle n \\rangle_{0}}{t_\\mathrm{f}} - v_g(k_0) \\right|$。\n\n约定和单位：使用无量纲晶格单位，其中晶格间距 $a=1$ 且约化普朗克常数 $\\hbar=1$。能量以 $J$ 为单位，时间以 $\\hbar/J$ 为单位，位置以晶格格点为单位。所有角度，包括 $k_0$，都必须以弧度为单位。\n\n您的程序必须产生单行输出，其中包含所有结果，形式为逗号分隔的列表，并用方括号括起，每个测试用例的两个数字按顺序展平为 $[r_1,\\Delta v_1,r_2,\\Delta v_2,\\dots]$。每个数字必须四舍五入到六位小数。\n\n测试套件（每个元组为 $(N,J,\\sigma,k_0,t_\\mathrm{f})$；在所有情况中使用 $n_0 = \\lfloor N/2 \\rfloor$；$k_0$ 以弧度为单位）：\n- 情况 $1$（一般情况）：$(256, 1.0, 12.0, \\pi/3, 40.0)$。\n- 情况 $2$（能带边缘群速度）：$(256, 1.0, 12.0, 0.0, 40.0)$。\n- 情况 $3$（窄波包，更强弥散）：$(256, 1.0, 2.0, \\pi/4, 40.0)$。\n- 情况 $4$（不同跃迁，宽波包）：$(512, 0.5, 20.0, \\pi/2, 60.0)$。\n\n您的程序应产生单行输出，其中包含结果，形式为逗号分隔的列表，并用方括号括起，顺序为 $[r_1,\\Delta v_1,r_2,\\Delta v_2,r_3,\\Delta v_3,r_4,\\Delta v_4]$，每个值在上述约定下为无量纲量，并四舍五入到六位小数。", "solution": "所提出的问题是计算量子力学中的一个标准、适定的练习，特别是关于一维紧束缚模型中波包动力学的模拟。它在科学上是合理的，并提供了所有必要信息。因此，我们可以直接进行解的推导和实现。\n\n问题的核心在于对给定的初始态求解含时薛定谔方程（TDSE）。哈密顿量与时间无关，这使得基于谱分解的方法能够高效且精确（达到机器精度）地求解。TDSE 给出为\n$$ i \\hbar \\frac{d}{dt} \\lvert \\psi(t) \\rangle = \\hat{H} \\lvert \\psi(t) \\rangle $$\n其中晶格常数 $a=1$ 且 $\\hbar=1$。其形式解为\n$$ \\lvert \\psi(t) \\rangle = e^{-i \\hat{H} t} \\lvert \\psi(0) \\rangle $$\n其中 $e^{-i \\hat{H} t}$ 是时间演化算符。对于大的 $N$，直接计算该矩阵指数在计算上是不可行的。一个更有效的策略是在哈密顿量的本征态基中进行计算，在该基中算符是对角的。\n\n首先，我们将哈密顿量对角化。该系统是一个具有周期性边界条件的 $N$ 个格点的环，这意味着它具有平移不变性。如问题所述，这类系统的本征态是离散的平面波，或称为 Bloch 态，由下式给出\n$$ \\lvert \\phi_q \\rangle = \\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1} e^{iqn} \\lvert n \\rangle $$\n周期性边界条件 $\\lvert n+N \\rangle = \\lvert n \\rangle$ 将允许的波矢 $q$ 量子化。为使波函数是单值的，我们需要 $e^{iq(n+N)} = e^{iqn}$，这意味着 $e^{iqN} = 1$。解为\n$$ q = \\frac{2\\pi m}{N}, \\qquad m \\in \\{0, 1, \\dots, N-1\\} $$\n为了找到与这些本征态相对应的能量本征值 $E(q)$，我们将哈密顿量 $\\hat{H} = -J \\sum_{n} (\\lvert n \\rangle \\langle n+1 \\rvert + \\lvert n+1 \\rangle \\langle n \\rvert)$ 作用于 $\\lvert \\phi_q \\rangle$：\n$$ \\hat{H} \\lvert \\phi_q \\rangle = \\frac{-J}{\\sqrt{N}} \\sum_{n=0}^{N-1} e^{iqn} \\left( \\lvert n+1 \\rangle + \\lvert n-1 \\rangle \\right) $$\n通过对求和重新索引，我们得到\n$$ \\hat{H} \\lvert \\phi_q \\rangle = \\frac{-J}{\\sqrt{N}} \\sum_{n=0}^{N-1} \\left( e^{iq(n-1)} + e^{iq(n+1)} \\right) \\lvert n \\rangle = -J(e^{-iq} + e^{iq}) \\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1} e^{iqn} \\lvert n \\rangle $$\n这简化为本征值方程 $\\hat{H} \\lvert \\phi_q \\rangle = E(q) \\lvert \\phi_q \\rangle$，其能量色散关系为：\n$$ E(q) = -2J \\cos(q) $$\n\n有了完备的本征态 $\\lvert \\phi_q \\rangle$ 和本征值 $E(q)$ 集合，我们就可以表示时间演化。任何态矢量都可以在此基中展开。初始态 $\\lvert \\psi(0) \\rangle = \\sum_{n=0}^{N-1} \\psi_n(0) \\lvert n \\rangle$ 被投影到本征基上：\n$$ \\lvert \\psi(0) \\rangle = \\sum_q c_q(0) \\lvert \\phi_q \\rangle $$\n其中系数 $c_q(0)$ 由交叠 $c_q(0) = \\langle \\phi_q \\lvert \\psi(0) \\rangle$ 给出。代入态的表达式，我们得到\n$$ c_q(0) = \\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1} e^{-iqn} \\psi_n(0) $$\n该表达式在相差一个归一化因子的前提下，是初始波函数分量 $\\psi_n(0)$ 的离散傅里叶变换（DFT）。这些系数的时间演化很简单：\n$$ c_q(t) = c_q(0) e^{-iE(q)t} $$\n为了得到时间 $t$ 时在格点基中的波函数 $\\lvert \\psi(t) \\rangle = \\sum_n \\psi_n(t) \\lvert n \\rangle$，我们执行逆变换：\n$$ \\psi_n(t) = \\langle n \\lvert \\psi(t) \\rangle = \\sum_q \\langle n \\lvert \\phi_q \\rangle c_q(t) = \\frac{1}{\\sqrt{N}} \\sum_q e^{iqn} c_q(t) $$\n这是一个离散傅里叶逆变换（IDFT）。\n\n因此，计算 $\\lvert \\psi(t) \\rangle$ 的算法如下：\n1.  构建 $n \\in \\{0, 1, \\dots, N-1\\}$ 的初始态矢量 $[\\psi_n(0)]$。给定形式为 $\\psi_n(0) = \\mathcal{N} \\exp(- (n-n_0)^2 / (4\\sigma^2) ) \\exp(ik_0n)$，其中 $\\mathcal{N}$ 是一个常数，其选择需满足 $\\sum_n |\\psi_n(0)|^2 = 1$。\n2.  计算 $[\\psi_n(0)]$ 的 DFT 以获得动量空间系数 $[\\tilde{\\psi}_q(0)]$。在计算上，这是通过快速傅里叶变换（FFT）算法完成的。\n3.  对于每个 $q$，计算能量 $E(q) = -2J \\cos(q)$。波矢集合 $\\{q\\}$ 对应于 FFT 算法使用的频率。\n4.  演化动量空间波函数：$[\\tilde{\\psi}_q(t)] = [\\tilde{\\psi}_q(0)] \\odot [e^{-iE(q)t}]$，其中 $\\odot$ 表示逐元素相乘。\n5.  计算 $[\\tilde{\\psi}_q(t)]$ 的 IDFT（通过逆 FFT）以获得最终态矢量 $[\\psi_n(t)]$。\n\n一旦波函数 $\\psi_n(0)$ 和 $\\psi_n(t_\\mathrm{f})$ 已知，我们就可以计算所需的可观测量。\n在格点 $n$ 处的概率为 $P_n(t) = |\\psi_n(t)|^2$。平均位置 $\\langle n \\rangle_t$ 和方差 $\\mathrm{Var}(t)$ 根据其定义计算：\n$$ \\langle n \\rangle_t = \\sum_{n=0}^{N-1} n P_n(t), \\quad \\mathrm{Var}(t) = \\sum_{n=0}^{N-1} (n - \\langle n \\rangle_t)^2 P_n(t) $$\n问题假设没有环绕效应，这使得这些简单的求和形式是合理的。弥散比为 $r = \\mathrm{Var}(t_\\mathrm{f}) / \\mathrm{Var}(0)$。\n\n载流子动量为 $k$ 的波包的解析群速度 $v_g$ 由色散关系的导数给出，即 $v_g(k) = dE(k)/dk$。这里，我们有\n$$ v_g(k) = \\frac{d}{dk}(-2J \\cos k) = 2J \\sin k $$\n我们在初始载波矢 $k_0$ 处计算该值。数值测量的平均速度计算为平均位置的总位移除以所用时间：$(\\langle n \\rangle_{t_\\mathrm{f}} - \\langle n \\rangle_0) / t_\\mathrm{f}$。绝对误差 $\\Delta v$ 是数值速度与解析群速度 $v_g(k_0)$ 之间差值的绝对值。此过程将应用于提供的每一组参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the tight-binding wave packet dynamics problem\n    for a given set of test cases.\n    \"\"\"\n    # Test suite: (N, J, sigma, k0, tf)\n    # k0 is in radians.\n    test_cases = [\n        (256, 1.0, 12.0, np.pi/3, 40.0),\n        (256, 1.0, 12.0, 0.0, 40.0),\n        (256, 1.0, 2.0, np.pi/4, 40.0),\n        (512, 0.5, 20.0, np.pi/2, 60.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, J, sigma, k0, tf = case\n        \n        # In dimensionless units, hbar=1, a=1.\n        \n        # 1. Construct the initial state\n        n0 = N // 2\n        n_coords = np.arange(N, dtype=float)\n        \n        # Position differences for Gaussian, using direct coordinates as per problem statement\n        # assuming no wrap-around for initial packet shape.\n        pos_diff = n_coords - n0\n        \n        # Unnormalized Gaussian wave packet\n        psi_n_0_un = np.exp(-pos_diff**2 / (4 * sigma**2)) * np.exp(1j * k0 * n_coords)\n        \n        # Normalize the wave function\n        norm_const = np.sqrt(np.sum(np.abs(psi_n_0_un)**2))\n        psi_n_0 = psi_n_0_un / norm_const\n        \n        # 2. Calculate initial observables\n        P_n_0 = np.abs(psi_n_0)**2\n        # Ensure probability is normalized to 1, guarding against floating point dust\n        P_n_0 /= np.sum(P_n_0)\n        \n        mean_n_0 = np.sum(n_coords * P_n_0)\n        var_0 = np.sum((n_coords - mean_n_0)**2 * P_n_0)\n\n        # 3. Time evolution using split-step Fourier method\n        # a. Go to momentum space\n        psi_q_0 = np.fft.fft(psi_n_0)\n        \n        # b. Define momentum grid and energy dispersion\n        # np.fft.fftfreq provides the correct frequencies for np.fft.fft\n        # d=1 corresponds to lattice spacing a=1\n        q_vals = 2 * np.pi * np.fft.fftfreq(N, d=1.0)\n        E_q = -2 * J * np.cos(q_vals)\n        \n        # c. Evolve in momentum space\n        time_evolution_operator = np.exp(-1j * E_q * tf)\n        psi_q_tf = psi_q_0 * time_evolution_operator\n        \n        # d. Go back to position space\n        psi_n_tf = np.fft.ifft(psi_q_tf)\n        \n        # 4. Calculate final observables\n        P_n_tf = np.abs(psi_n_tf)**2\n        P_n_tf /= np.sum(P_n_tf)\n        \n        mean_n_tf = np.sum(n_coords * P_n_tf)\n        var_tf = np.sum((n_coords - mean_n_tf)**2 * P_n_tf)\n        \n        # 5. Calculate required quantities\n        # a. Dispersion ratio r\n        if var_0 == 0:\n            # This case should not happen for sigma > 0\n            r = np.inf if var_tf > 0 else 1.0\n        else:\n            r = var_tf / var_0\n            \n        # b. Group velocity error Delta_v\n        # Analytical group velocity\n        vg_analytical = 2 * J * np.sin(k0)\n        \n        # Numerical group velocity\n        if tf == 0:\n            v_numerical = 0.0 # No motion if no time has passed\n        else:\n            v_numerical = (mean_n_tf - mean_n_0) / tf\n            \n        delta_v = np.abs(v_numerical - vg_analytical)\n        \n        results.extend([r, delta_v])\n\n    # Final print statement in the exact required format.\n    # Format each result to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2446520"}, {"introduction": "真实的晶体绝非完美，那么缺陷是如何影响其电子特性的呢？这个练习将我们从一个完美的晶格带入一个含有空位的晶格，并引入了局域态密度（LDOS）这一关键概念，它对于理解扫描隧道显微镜（STM）等实验中的测量至关重要。通过这个实践，你将学习如何对缺陷进行数值建模，并计算它们对可观测电子性质的影响 [@problem_id:2446549]，从而亲眼见证一个原子的缺失如何显著改变局域的电子环境。", "problem": "考虑一个由最近邻紧束缚哈密顿量描述的、具有开放边界条件的二维正方晶格。设晶格的线性尺寸为 $N$，因此纯净系统中的总格点数为 $N^2$。设所有格点的在位能为 $\\varepsilon_{i}=0$，最近邻跃迁振幅为 $t>0$。在能量单位中取 $t=1$，并对晶格格点 $(x,y)$ 采用从零开始的坐标系，其中 $x \\in \\{0, \\dots, N-1\\}$ 且 $y \\in \\{0, \\dots, N-1\\}$。二次量子化的哈密顿量为\n$$\n\\hat{H}=\\sum_{i}\\varepsilon_{i}\\,\\hat{c}_{i}^{\\dagger}\\hat{c}_{i}-t\\sum_{\\langle i,j\\rangle}\\left(\\hat{c}_{i}^{\\dagger}\\hat{c}_{j}+\\hat{c}_{j}^{\\dagger}\\hat{c}_{i}\\right),\n$$\n其中 $\\varepsilon_{i}=0$ 且为开放边界条件（不存在环绕邻居）。引入一个单空位缺陷，方法是将坐标为 $(x_{v},y_{v})$ 的格点从希尔伯特空间中完全移除（这等效于该格点上的在位势趋于无穷大的极限情况）。定义在格点 $r$ 和能量 $E$ 处的局域态密度 (LDOS) 为\n$$\n\\rho_{r}(E)=\\sum_{n}\\left|\\psi_{n}(r)\\right|^{2}\\,\\delta(E-E_{n}),\n$$\n其中 $E_{n}$ 和 $\\psi_{n}(r)$ 分别是单粒子哈密顿量的本征值和归一化本征态振幅。为获得数值上良定的值，使用半峰半宽为 $\\eta>0$ 的归一化洛伦兹函数对狄拉克 $\\delta$ 函数进行正则化，\n$$\n\\delta(E) \\to \\delta_{\\eta}(E) = \\frac{1}{\\pi}\\frac{\\eta}{E^2+\\eta^2}.\n$$\n对于给定的一组参数 $(N,E,\\eta,(x_{v},y_{v}),(x_{p},y_{p}))$，其中 $(x_{p},y_{p})$ 是一个不同于空位的探针格点，计算有缺陷晶格与纯净晶格在探针格点处局域态密度的差值，\n$$\n\\Delta\\rho(E) \\equiv \\rho^{\\text{defect}}_{(x_{p},y_{p})}(E) - \\rho^{\\text{pristine}}_{(x_{p},y_{p})}(E),\n$$\n其中能量以 $t$ 为单位。\n\n您的任务是编写一个完整的、可运行的程序，该程序针对下方的每个测试用例，构建相应的哈密顿矩阵（纯净矩阵和移除空位后的缺陷矩阵），使用洛伦兹展宽 $\\eta$ 计算指定探针格点和能量下的局域态密度，并以浮点数形式输出 $\\Delta\\rho(E)$。\n\n请使用以下测试套件。所有坐标均从零开始。所有能量均以 $t$ 为单位（$t=1$）。展宽 $\\eta$ 是一个使用相同能量单位的正实数。\n\n- 测试用例 $1$：$(N=\\;10,\\;E=\\;0.0,\\;\\eta=\\;0.05,\\;(x_{v},y_{v})=(5,5),\\;(x_{p},y_{p})=(5,4))$。\n- 测试用例 $2$：$(N=\\;10,\\;E=\\;3.9,\\;\\eta=\\;0.05,\\;(x_{v},y_{v})=(1,1),\\;(x_{p},y_{p})=(8,8))$。\n- 测试用例 $3$：$(N=\\;6,\\;E=\\;5.0,\\;\\eta=\\;0.05,\\;(x_{v},y_{v})=(2,3),\\;(x_{p},y_{p})=(2,2))$。\n- 测试用例 $4$：$(N=\\;8,\\;E=\\;0.0,\\;\\eta=\\;0.05,\\;(x_{v},y_{v})=(0,0),\\;(x_{p},y_{p})=(1,0))$。\n\n您的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个浮点数结果都需四舍五入到恰好六位小数，并按顺序对应于上述测试用例。例如，输出必须采用以下格式：\n$\n[\\Delta\\rho_{1},\\Delta\\rho_{2},\\Delta\\rho_{3},\\Delta\\rho_{4}],\n$\n其中每个 $\\Delta\\rho_{k}$ 都四舍五入到六位小数。", "solution": "所提出的问题是计算凝聚态物理学中一个标准的、定义明确的练习。它在科学上是合理的，包含了所有必要信息，并且没有矛盾或歧义。因此，该问题被认定为有效。我们将着手进行解答。\n\n目标是计算二维正方晶格中，由于在格点 $(x_{v},y_{v})$ 处引入单个空位，而在指定探针格点 $(x_{p},y_{p})$ 引起的局域态密度 (LDOS) 的变化，记为 $\\Delta\\rho(E)$：\n$$\n\\Delta\\rho(E) \\equiv \\rho^{\\text{defect}}_{(x_{p},y_{p})}(E) - \\rho^{\\text{pristine}}_{(x_{p},y_{p})}(E)\n$$\n该分析需要对纯净系统和缺陷系统进行分别处理。\n\n首先，我们必须为尺寸为 $N \\times N$ 的正方晶格构建单粒子哈密顿矩阵。格点由坐标 $(x,y)$ 索引，其中 $x, y \\in \\{0, 1, \\dots, N-1\\}$。为得到矩阵表示，我们将这些二维坐标映射到一个一维索引 $i$。这里使用标准的行主序映射：\n$$\ni(x,y) = y \\cdot N + x\n$$\n总格点数为 $N^2$，因此索引 $i$ 的范围是从 $0$ 到 $N^2-1$。哈密顿量由下式给出：\n$$\n\\hat{H} = \\sum_{i}\\varepsilon_{i}\\,\\hat{c}_{i}^{\\dagger}\\hat{c}_{i} - t\\sum_{\\langle i,j\\rangle}\\left(\\hat{c}_{i}^{\\dagger}\\hat{c}_{j} + \\hat{c}_{j}^{\\dagger}\\hat{c}_{i}\\right)\n$$\n在单粒子基中，矩阵元 $H_{ij}$ 由 $\\langle i | \\hat{H} | j \\rangle$ 给出。在位能 $\\varepsilon_i = 0$ 且跃迁振幅 $t=1$ 的情况下，矩阵元为：\n$$\nH_{ij} =\n\\begin{cases}\n0 & \\text{if } i = j \\\\\n-1 & \\text{if sites } i \\text{ and } j \\text{ are nearest neighbors} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n这定义了纯净哈密顿矩阵 $H^{\\text{pristine}}$，它是一个 $N^2 \\times N^2$ 的实对称矩阵。\n\n接下来，我们考虑在 $(x_v, y_v)$ 处有空位的系统。该缺陷通过从希尔伯特空间中移除相应格点来建模。如果空位格点的索引是 $v_{\\text{idx}} = y_v \\cdot N + x_v$，则缺陷哈密顿量 $H^{\\text{defect}}$ 可通过从 $H^{\\text{pristine}}$ 中删除第 $v_{\\text{idx}}$ 行和第 $v_{\\text{idx}}$ 列得到。所得矩阵的尺寸为 $(N^2-1) \\times (N^2-1)$。\n\n在索引为 $p$ 的探针格点和能量为 $E$ 处的局域态密度由以下正则化公式给出：\n$$\n\\rho_{p}(E) = \\sum_{n} |\\psi_{n}(p)|^2 \\frac{1}{\\pi} \\frac{\\eta}{(E-E_n)^2 + \\eta^2}\n$$\n其中 $E_n$ 是本征值，$\\psi_n(p)$ 是第 $n$ 个归一化本征向量在格点 $p$ 上的振幅。为计算此值，我们必须对角化相应的哈密顿矩阵。\n\n对于纯净系统：\n$1$. 构建 $N^2 \\times N^2$ 矩阵 $H^{\\text{pristine}}$。\n$2$. 数值求解本征值问题 $H^{\\text{pristine}}\\psi_n = E_n \\psi_n$，以获得本征值集合 $\\{E_n\\}$ 和相应的本征向量矩阵 $\\Psi$，其中第 $n$ 列是向量 $\\psi_n$。\n$3$. 确定探针格点的索引 $p_{\\text{idx}} = y_p \\cdot N + x_p$。\n$4$. 振幅平方 $|\\psi_n(p_{\\text{idx}})|^2$ 是本征向量矩阵 $\\Psi$ 第 $p_{\\text{idx}}$ 行元素的平方。\n$5$. 使用公式计算 $\\rho^{\\text{pristine}}_{(x_p,y_p)}(E)$。\n\n对于缺陷系统：\n$1$. 通过从 $H^{\\text{pristine}}$ 中移除与空位索引 $v_{\\text{idx}} = y_v \\cdot N + x_v$ 对应的行和列，构建 $(N^2-1) \\times (N^2-1)$ 矩阵 $H^{\\text{defect}}$。\n$2$. 求解 $H^{\\text{defect}}$ 的本征值问题，以获得本征值 $\\{E'_m\\}$ 和本征向量 $\\{\\psi'_m\\}$。\n$3$. 在缺陷系统的基中，探针格点的索引 $p'_{\\text{idx}}$ 必须进行调整。如果 $p_{\\text{idx}} > v_{\\text{idx}}$，则 $p'_{\\text{idx}} = p_{\\text{idx}} - 1$。否则，如果 $p_{\\text{idx}} < v_{\\text{idx}}$，则 $p'_{\\text{idx}} = p_{\\text{idx}}$。根据问题陈述，$p_{\\text{idx}} = v_{\\text{idx}}$ 的情况是被排除的。\n$4$. 使用本征值 $\\{E'_m\\}$、本征向量振幅 $|\\psi'_m(p'_{\\text{idx}})|^2$ 以及相同的能量 $E$ 和展宽 $\\eta$ 来计算 $\\rho^{\\text{defect}}_{(x_p,y_p)}(E)$。\n\n最后，计算差值 $\\Delta\\rho(E)$。数值实现将利用 `numpy.linalg.eigh`，该函数对于实对称矩阵的对角化非常高效。局域态密度的求和可以通过向量化操作高效地计算。\n\n每个测试用例的计算流程如下：\n$1$. 给定 $(N, E, \\eta, (x_v, y_v), (x_p, y_p))$。\n$2$. 构建纯净哈密顿量 $H^{\\text{pristine}}$。\n$3$. 对角化 $H^{\\text{pristine}}$ 并计算 $\\rho^{\\text{pristine}}$。\n$4$. 构建缺陷哈密顿量 $H^{\\text{defect}}$。\n$5$. 对角化 $H^{\\text{defect}}$ 并计算 $\\rho^{\\text{defect}}$。\n$6$. 计算差值 $\\Delta\\rho(E) = \\rho^{\\text{defect}} - \\rho^{\\text{pristine}}$。\n\n此方法论将应用于问题陈述中提供的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the change in Local Density of States (LDOS) for a 2D tight-binding model\n    with a single vacancy.\n    \"\"\"\n\n    test_cases = [\n        # (N, E, eta, (xv, yv), (xp, yp))\n        (10, 0.0, 0.05, (5, 5), (5, 4)),\n        (10, 3.9, 0.05, (1, 1), (8, 8)),\n        (6, 5.0, 0.05, (2, 3), (2, 2)),\n        (8, 0.0, 0.05, (0, 0), (1, 0)),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_ldos = calculate_delta_ldos(*case)\n        results.append(delta_ldos)\n\n    # Format the results as required: rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef calculate_ldos(hamiltonian, probe_idx, E, eta):\n    \"\"\"\n    Calculates the Local Density of States (LDOS) at a specific probe site.\n    \n    Args:\n        hamiltonian (np.ndarray): The single-particle Hamiltonian matrix.\n        probe_idx (int): The 1D index of the probe site.\n        E (float): The energy at which to calculate the LDOS.\n        eta (float): The Lorentzian broadening parameter.\n\n    Returns:\n        float: The calculated LDOS value.\n    \"\"\"\n    if hamiltonian.shape[0] == 0:\n        return 0.0\n\n    # Diagonalize the Hamiltonian. eigh is for Hermitian matrices.\n    eigenvalues, eigenvectors = np.linalg.eigh(hamiltonian)\n    \n    # Get the squared eigenvector amplitudes at the probe site for all eigenstates.\n    psi_p_sq = eigenvectors[probe_idx, :]**2\n    \n    # Calculate the Lorentzian term for each eigenvalue.\n    lorentzian_terms = eta / ((E - eigenvalues)**2 + eta**2)\n    \n    # Compute the LDOS by summing the contributions from all eigenstates.\n    ldos = (1.0 / math.pi) * np.sum(psi_p_sq * lorentzian_terms)\n    \n    return ldos\n\ndef build_hamiltonian(N, t=1.0):\n    \"\"\"\n    Builds the tight-binding Hamiltonian matrix for an N x N square lattice\n    with open boundary conditions.\n\n    Args:\n        N (int): The linear size of the lattice.\n        t (float): The nearest-neighbor hopping amplitude.\n\n    Returns:\n        np.ndarray: The N^2 x N^2 Hamiltonian matrix.\n    \"\"\"\n    num_sites = N * N\n    hamiltonian = np.zeros((num_sites, num_sites), dtype=float)\n    \n    for i in range(num_sites):\n        # Map 1D index 'i' back to 2D coordinates (x, y)\n        y = i // N\n        x = i % N\n        \n        # Hopping to the right neighbor (x+1, y)\n        if x + 1 < N:\n            j = i + 1\n            hamiltonian[i, j] = -t\n            hamiltonian[j, i] = -t\n            \n        # Hopping to the neighbor below (x, y+1)\n        if y + 1 < N:\n            j = i + N\n            hamiltonian[i, j] = -t\n            hamiltonian[j, i] = -t\n            \n    return hamiltonian\n\ndef calculate_delta_ldos(N, E, eta, vacancy_coords, probe_coords):\n    \"\"\"\n    Calculates the difference in LDOS between a defective and a pristine lattice.\n\n    Args:\n        N (int): Linear size of the lattice.\n        E (float): Energy for LDOS calculation.\n        eta (float): Lorentzian broadening.\n        vacancy_coords (tuple): (xv, yv) coordinates of the vacancy.\n        probe_coords (tuple): (xp, yp) coordinates of the probe site.\n\n    Returns:\n        float: The value of Delta_rho(E).\n    \"\"\"\n    # Hopping parameter t=1, on-site energy epsilon=0\n    t = 1.0\n\n    # --- Pristine System ---\n    H_pristine = build_hamiltonian(N, t)\n    \n    xp, yp = probe_coords\n    p_idx = yp * N + xp\n    \n    ldos_pristine = calculate_ldos(H_pristine, p_idx, E, eta)\n\n    # --- Defective System ---\n    xv, yv = vacancy_coords\n    v_idx = yv * N + xv\n    \n    # Create the defective Hamiltonian by removing the vacancy row and column\n    H_defect = np.delete(H_pristine, v_idx, axis=0)\n    H_defect = np.delete(H_defect, v_idx, axis=1)\n    \n    # Adjust the probe index for the smaller defective matrix\n    if p_idx > v_idx:\n        p_idx_defect = p_idx - 1\n    else: # p_idx < v_idx, as they cannot be equal\n        p_idx_defect = p_idx\n        \n    ldos_defect = calculate_ldos(H_defect, p_idx_defect, E, eta)\n    \n    # --- Calculate the difference ---\n    delta_ldos = ldos_defect - ldos_pristine\n    \n    return delta_ldos\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2446549"}, {"introduction": "现在，让我们迈向凝聚态物理的前沿。除了简单的导电性，能带结构本身还可以拥有“拓扑”性质，这些性质带来了全新而奇特的物理现象。这个练习介绍了蜂窝晶格上的Haldane模型——拓扑绝缘体的奠基模型之一，并引入了陈数（Chern number）这一拓扑不变量的概念。通过数值计算陈数，你将亲自接触到拓扑物态这一迷人领域 [@problem_id:2446546]，并理解紧束缚模型如何描述那些对局域微扰不敏感的奇异物质相，这也是拓扑态的一个核心特征。", "problem": "您需要编写一个完整的程序，用于构建蜂窝晶格上 Haldane 模型的布洛赫哈密顿量，并计算指定参数集下低能（占据）能带的陈数。所有能量均采用无量纲的紧束缚单位，角度必须使用弧度制。最终要求输出为单行，其中包含给定测试集的计算陈数列表，其格式严格要求为方括号内以逗号分隔的列表（例如，“[1,0,-1]”）。\n\nHaldane 模型是一个定义在蜂窝晶格上的双能带紧束缚模型，其具有由子晶格 $A$ 和 $B$ 标记的双格点基矢。该模型包含振幅为 $t_1$ 的最近邻跃迁、振幅为 $t_2 e^{i \\phi}$ 的复数次近邻跃迁（该跃迁在每个原胞净磁通量为零的情况下破坏时间反演对称性），以及一个破坏反演对称性的子晶格交错在位势 $M$。\n\n使用以下蜂窝晶格几何结构。将最近邻距离设为单位长度。从子晶格 $A$ 到子晶格 $B$ 的三个最近邻位移矢量为\n$$\n\\boldsymbol{\\delta}_1 = (0,-1),\\quad\n\\boldsymbol{\\delta}_2 = \\left(\\frac{\\sqrt{3}}{2},\\frac{1}{2}\\right),\\quad\n\\boldsymbol{\\delta}_3 = \\left(-\\frac{\\sqrt{3}}{2},\\frac{1}{2}\\right).\n$$\n连接同一子晶格上格点的三个次近邻位移矢量为\n$$\n\\mathbf{a}_1 = \\boldsymbol{\\delta}_2 - \\boldsymbol{\\delta}_3 = (\\sqrt{3}, 0),\\quad\n\\mathbf{a}_2 = \\boldsymbol{\\delta}_3 - \\boldsymbol{\\delta}_1 = \\left(-\\frac{\\sqrt{3}}{2}, \\frac{3}{2}\\right),\\quad\n\\mathbf{a}_3 = \\boldsymbol{\\delta}_1 - \\boldsymbol{\\delta}_2 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{3}{2}\\right).\n$$\n为蜂窝结构的三角布拉菲晶格选择如下的原初布拉菲晶格矢量\n$$\n\\mathbf{R}_1 = \\mathbf{a}_1,\\quad \\mathbf{R}_2 = \\mathbf{a}_1 + \\mathbf{a}_2.\n$$\n倒格矢 $\\mathbf{G}_1$ 和 $\\mathbf{G}_2$ 由以下条件定义\n$$\n\\mathbf{R}_i \\cdot \\mathbf{G}_j = 2\\pi \\delta_{ij}.\n$$\n布洛赫动量 $\\mathbf{k}$ 位于由 $\\mathbf{G}_1$ 和 $\\mathbf{G}_2$ 张成的平行四边形所定义的第一布里渊区内。\n\n在 $(A,B)$ 子晶格基下，布洛赫哈密顿量 $H(\\mathbf{k})$ 是一个 $2\\times 2$ 的厄米矩阵，其矩阵元为\n$$\nH_{AA}(\\mathbf{k}) = M + 2 t_2 \\sum_{j=1}^{3} \\cos(\\phi)\\,\\cos(\\mathbf{k}\\cdot \\mathbf{a}_j) - 2 t_2 \\sum_{j=1}^{3} \\sin(\\phi)\\,\\sin(\\mathbf{k}\\cdot \\mathbf{a}_j),\n$$\n$$\nH_{BB}(\\mathbf{k}) = -M + 2 t_2 \\sum_{j=1}^{3} \\cos(\\phi)\\,\\cos(\\mathbf{k}\\cdot \\mathbf{a}_j) + 2 t_2 \\sum_{j=1}^{3} \\sin(\\phi)\\,\\sin(\\mathbf{k}\\cdot \\mathbf{a}_j),\n$$\n$$\nH_{AB}(\\mathbf{k}) = t_1 \\sum_{j=1}^{3} \\exp(i\\,\\mathbf{k}\\cdot \\boldsymbol{\\delta}_j),\\qquad H_{BA}(\\mathbf{k}) = \\overline{H_{AB}(\\mathbf{k})}.\n$$\n令 $|u_-(\\mathbf{k})\\rangle$ 表示 $H(\\mathbf{k})$ 对应其较低本征值 $E_-(\\mathbf{k})$ 的归一化占据带本征矢量。\n\n占据带的陈数定义为\n$$\n\\mathcal{C} = \\frac{1}{2\\pi} \\int_{\\mathrm{BZ}} \\mathcal{F}_{12}(\\mathbf{k})\\, d^2 k,\n$$\n其中 $\\mathcal{F}_{12}(\\mathbf{k})$ 是由 $|u_-(\\mathbf{k})\\rangle$ 构建的贝里曲率，积分遍及第一布里渊区。您的程序必须计算 $\\mathcal{C}$ 的一个数值近似值，并将其四舍五入到最近的整数后返回。\n\n角度必须使用弧度制。没有物理单位；所有量均为无量纲。\n\n测试集。对于每一行，参数为 $(t_1, t_2, \\phi, M)$:\n-   情况 1：$(1.0, 0.1, \\$\\tfrac{\\pi}{2}\\$, 0.0)$\n-   情况 2：$(1.0, 0.1, \\$\\tfrac{\\pi}{2}\\$, 0.7)$\n-   情况 3：$(1.0, 0.1, \\$-\\tfrac{\\pi}{2}\\$, 0.0)$\n-   情况 4：$(1.0, 0.0, \\$\\tfrac{\\pi}{3}\\$, 0.0)$\n-   情况 5：$(1.0, 0.2, 0.0, 0.1)$\n\n最终输出格式。您的程序应生成单行输出，其中按规定顺序包含所有情况的结果，格式为方括号内以逗号分隔的列表，每个条目为占据带的整数陈数，例如，“[c1,c2,c3,c4,c5]”。", "solution": "本题要求计算蜂窝晶格上 Haldane 模型占据带的陈数。这将通过在第一布里渊区（BZ）上对贝里曲率进行数值积分来完成。\n\n首先，我们验证问题陈述的有效性。所有提供的数据，包括模型参数、晶格矢量和哈密顿量表达式，均与关于 Haldane 模型的既有文献一致。该问题在科学上是合理的、适定的、客观的，并包含足够的信息以获得唯一解。晶格几何和布里渊区的定义是标准的。该任务是计算凝聚态物理中的一个典范问题。因此，该问题被认为是有效的。\n\n对于一个双能带系统，布洛赫哈密顿量 $H(\\mathbf{k})$ 通常可以以泡利矩阵 $\\boldsymbol{\\sigma} = (\\sigma_x, \\sigma_y, \\sigma_z)$ 为基底表示为：\n$$\nH(\\mathbf{k}) = d_0(\\mathbf{k}) I + \\mathbf{d}(\\mathbf{k}) \\cdot \\boldsymbol{\\sigma}\n$$\n其中 $I$ 是 $2 \\times 2$ 的单位矩阵，$\\mathbf{d}(\\mathbf{k}) = (d_x(\\mathbf{k}), d_y(\\mathbf{k}), d_z(\\mathbf{k}))$ 是布洛赫动量 $\\mathbf{k}$ 的一个矢量函数。其矩阵形式为：\n$$\nH(\\mathbf{k}) = \\begin{pmatrix} d_0(\\mathbf{k}) + d_z(\\mathbf{k}) & d_x(\\mathbf{k}) - i d_y(\\mathbf{k}) \\\\ d_x(\\mathbf{k}) + i d_y(\\mathbf{k}) & d_0(\\mathbf{k}) - d_z(\\mathbf{k}) \\end{pmatrix}\n$$\n通过将此通用形式与给定的哈密顿量矩阵元 $H_{AA}(\\mathbf{k})$、$H_{BB}(\\mathbf{k})$ 和 $H_{AB}(\\mathbf{k})$ 进行比较，我们可以确定 $\\mathbf{d}(\\mathbf{k})$ 的分量：\n$$\nd_0(\\mathbf{k}) = \\frac{1}{2}(H_{AA}(\\mathbf{k}) + H_{BB}(\\mathbf{k})) = 2 t_2 \\cos(\\phi) \\sum_{j=1}^{3} \\cos(\\mathbf{k} \\cdot \\mathbf{a}_j)\n$$\n$$\nd_x(\\mathbf{k}) = \\text{Re}(H_{AB}(\\mathbf{k})) = t_1 \\sum_{j=1}^{3} \\cos(\\mathbf{k} \\cdot \\boldsymbol{\\delta}_j)\n$$\n$$\nd_y(\\mathbf{k}) = -\\text{Im}(H_{AB}(\\mathbf{k})) = -t_1 \\sum_{j=1}^{3} \\sin(\\mathbf{k} \\cdot \\boldsymbol{\\delta}_j)\n$$\n$$\nd_z(\\mathbf{k}) = \\frac{1}{2}(H_{AA}(\\mathbf{k}) - H_{BB}(\\mathbf{k})) = M - 2 t_2 \\sin(\\phi) \\sum_{j=1}^{3} \\sin(\\mathbf{k} \\cdot \\mathbf{a}_j)\n$$\n该哈密顿量的本征值为 $E_\\pm(\\mathbf{k}) = d_0(\\mathbf{k}) \\pm |\\mathbf{d}(\\mathbf{k})|$，其中 $|\\mathbf{d}(\\mathbf{k})| = \\sqrt{d_x(\\mathbf{k})^2 + d_y(\\mathbf{k})^2 + d_z(\\mathbf{k})^2}$。我们关心的是低能（占据）带，它对应于本征值 $E_-(\\mathbf{k})$ 及其相关的本征矢量 $|u_-(\\mathbf{k})\\rangle$。\n\n陈数 $\\mathcal{C}$ 是能带结构的一个拓扑不变量，定义为贝里曲率 $\\mathcal{F}_{12}(\\mathbf{k})$ 在第一布里渊区上的积分：\n$$\n\\mathcal{C} = \\frac{1}{2\\pi} \\int_{\\mathrm{BZ}} \\mathcal{F}_{12}(\\mathbf{k})\\, d^2k\n$$\n通过其定义（涉及本征矢量的导数）直接计算贝里曲率在数值上是不稳定的。一种更稳健且广泛使用的数值计算方法是由 Fukui、Hatsugai 和 Suzuki 提出的方法。该方法将布里渊区离散化，并将陈数计算为局域规范不变的量（格点相位）之和。\n\n算法如下：\n1.  定义原初布拉菲晶格矢量 $\\mathbf{R}_1$ 和 $\\mathbf{R}_2$，并由此定义满足 $\\mathbf{R}_i \\cdot \\mathbf{G}_j = 2\\pi \\delta_{ij}$ 的倒格矢 $\\mathbf{G}_1$ 和 $\\mathbf{G}_2$。使用所提供的矢量：\n    $\\mathbf{R}_1 = (\\sqrt{3}, 0)$ 和 $\\mathbf{R}_2 = (\\frac{\\sqrt{3}}{2}, \\frac{3}{2})$。\n    可求得倒格矢为 $\\mathbf{G}_1 = (\\frac{2\\pi}{\\sqrt{3}}, -\\frac{2\\pi}{3})$ 和 $\\mathbf{G}_2 = (0, \\frac{4\\pi}{3})$。\n2.  将由 $\\mathbf{G}_1$ 和 $\\mathbf{G}_2$ 张成的平行四边形所代表的第一布里渊区离散化为一个 $N \\times N$ 的均匀格网。格网上的一个点由 $\\mathbf{k}_{nm} = \\frac{n}{N}\\mathbf{G}_1 + \\frac{m}{N}\\mathbf{G}_2$ 给出，其中整数 $n, m \\in [0, N-1]$。$N=100$ 的格网尺寸足以获得精确结果。\n3.  对格网上的每个点 $\\mathbf{k}_{nm}$，构建哈密顿量矩阵 $H(\\mathbf{k}_{nm})$ 并数值计算其本征值和本征矢量。存储与较低本征值 $E_-(\\mathbf{k}_{nm})$ 对应的本征矢量 $|u_{nm}\\rangle$。\n4.  定义格网上相邻点之间的连接变量（link variable），表示基态波函数的交叠：\n    $$\n    U_{1,nm} = \\langle u_{nm} | u_{n+1,m} \\rangle \\qquad U_{2,nm} = \\langle u_{nm} | u_{n,m+1} \\rangle\n    $$\n    此处，索引对 $N$ 取模，以在布里渊区环面上实施周期性边界条件。k 空间矢量为 $\\mathbf{k}_{n+1,m} = \\mathbf{k}_{nm} + \\mathbf{G}_1/N$ 和 $\\mathbf{k}_{n,m+1} = \\mathbf{k}_{nm} + \\mathbf{G}_2/N$。\n5.  对于格网上的每个基本格点 $(n,m)$（plaquette），计算格点相位，它是穿过该格点的贝里曲率通量的离散模拟：\n    $$\n    F_{nm} = \\arg\\left( U_{1,nm} U_{2,n+1,m} U_{1,n,m+1}^* U_{2,nm}^* \\right)\n    $$\n    复变函数宗量 $\\arg(z)$ 的取值范围必须在 $(-\\pi, \\pi]$ 内。\n6.  总陈数是所有格点上这些局域相位之和，再用 $2\\pi$ 归一化：\n    $$\n    \\mathcal{C} = \\frac{1}{2\\pi} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} F_{nm}\n    $$\n    由于有能隙能带的陈数保证为整数，因此将数值结果四舍五入到最近的整数，以消除有限精度误差。\n\n给出的程序实现了这一数值方案。它定义了一个函数，用以为给定的一组参数 $(t_1, t_2, \\phi, M)$ 和动量 $\\mathbf{k}$ 构建哈密顿量。然后，它遍历每个测试用例，构建本征矢量的格网，计算格点相位的总和，并算出陈数。所有测试用例的最终结果被收集起来，并以指定格式打印。计算中使用的矢量为：\n$\\boldsymbol{\\delta}_1 = (0,-1)$，$\\boldsymbol{\\delta}_2 = (\\frac{\\sqrt{3}}{2},\\frac{1}{2})$，$\\boldsymbol{\\delta}_3 = (-\\frac{\\sqrt{3}}{2},\\frac{1}{2})$。\n$\\mathbf{a}_1 = (\\sqrt{3}, 0)$，$\\mathbf{a}_2 = (-\\frac{\\sqrt{3}}{2}, \\frac{3}{2})$，$\\mathbf{a}_3 = (-\\frac{\\sqrt{3}}{2}, -\\frac{3}{2})$。\n所有计算均按规定使用无量纲量进行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Chern number of the Haldane model for a suite of test cases.\n    \"\"\"\n\n    # Define the honeycomb lattice geometry vectors\n    sqrt3 = np.sqrt(3.0)\n    delta1 = np.array([0.0, -1.0])\n    delta2 = np.array([sqrt3 / 2.0, 1.0 / 2.0])\n    delta3 = np.array([-sqrt3 / 2.0, 1.0 / 2.0])\n    deltas = [delta1, delta2, delta3]\n\n    a1 = delta2 - delta3\n    a2 = delta3 - delta1\n    a3 = delta1 - delta2\n    a_vecs = [a1, a2, a3]\n\n    # Define primitive reciprocal lattice vectors\n    # R1 = a1, R2 = a1 + a2\n    # G1, G2 are defined by R_i . G_j = 2*pi*delta_ij\n    # G1 = (2*pi/sqrt3, -2*pi/3)\n    # G2 = (0, 4*pi/3)\n    G1 = np.array([2.0 * np.pi / sqrt3, -2.0 * np.pi / 3.0])\n    G2 = np.array([0.0, 4.0 * np.pi / 3.0])\n\n    # Numerical parameters\n    N_k = 100  # Grid size for Brillouin zone discretization\n\n    test_cases = [\n        # (t1, t2, phi, M)\n        (1.0, 0.1, np.pi / 2.0, 0.0),\n        (1.0, 0.1, np.pi / 2.0, 0.7),\n        (1.0, 0.1, -np.pi / 2.0, 0.0),\n        (1.0, 0.0, np.pi / 3.0, 0.0),\n        (1.0, 0.2, 0.0, 0.1),\n    ]\n\n    results = []\n    for t1, t2, phi, M in test_cases:\n        \n        k_grid_points = np.zeros((N_k, N_k, 2))\n        for n in range(N_k):\n            for m in range(N_k):\n                k_grid_points[n, m] = (n / N_k) * G1 + (m / N_k) * G2\n\n        eigenvectors = np.zeros((N_k, N_k, 2), dtype=np.complex128)\n\n        for n in range(N_k):\n            for m in range(N_k):\n                k = k_grid_points[n, m]\n                \n                # Calculate sums for Hamiltonian components\n                sum_exp_k_delta = np.sum([np.exp(1j * np.dot(k, d)) for d in deltas])\n                \n                cos_k_a = [np.cos(np.dot(k, a)) for a in a_vecs]\n                sin_k_a = [np.sin(np.dot(k, a)) for a in a_vecs]\n\n                # Hamiltonian matrix elements\n                H_AA = M + 2.0 * t2 * np.cos(phi) * np.sum(cos_k_a) - 2.0 * t2 * np.sin(phi) * np.sum(sin_k_a)\n                H_BB = -M + 2.0 * t2 * np.cos(phi) * np.sum(cos_k_a) + 2.0 * t2 * np.sin(phi) * np.sum(sin_k_a)\n                H_AB = t1 * sum_exp_k_delta\n                H_BA = np.conjugate(H_AB)\n\n                H = np.array([[H_AA, H_AB], [H_BA, H_BB]])\n\n                # Diagonalize the Hamiltonian\n                # eigh ensures real eigenvalues and returns normalized eigenvectors\n                eigenvalues, evecs = np.linalg.eigh(H)\n                \n                # Store the eigenvector for the lower band (occupied band)\n                eigenvectors[n, m] = evecs[:, 0]\n\n        total_berry_phase = 0.0\n        for n in range(N_k):\n            for m in range(N_k):\n                # Get eigenvectors for the four corners of the plaquette\n                u_nm = eigenvectors[n, m]\n                u_n1m = eigenvectors[(n + 1) % N_k, m]\n                u_nm1 = eigenvectors[n, (m + 1) % N_k]\n                u_n1m1 = eigenvectors[(n + 1) % N_k, (m + 1) % N_k]\n\n                # Compute link variables\n                U1_nm = np.vdot(u_nm, u_n1m)\n                U2_nm = np.vdot(u_nm, u_nm1)\n                \n                # Need links from neighboring sites to complete the plaquette\n                U1_nm1 = np.vdot(u_nm1, u_n1m1)\n                U2_n1m = np.vdot(u_n1m, u_n1m1)\n                \n                # Compute plaquette phase (local Berry curvature)\n                # F = arg( U1(n,m) U2(n+1,m) U1(n,m+1)* U2(n,m)* )\n                # Plaquette gauge field must be gauge invariant\n                plaquette_val = U1_nm * U2_n1m * np.conjugate(U1_nm1) * np.conjugate(U2_nm)\n                \n                # np.angle returns argument in [-pi, pi]\n                berry_phase_nm = np.angle(plaquette_val)\n                total_berry_phase += berry_phase_nm\n\n        # The Chern number is the sum of phases divided by 2*pi\n        chern_number = total_berry_phase / (2.0 * np.pi)\n        \n        # Round to the nearest integer\n        results.append(int(np.round(chern_number)))\n    \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2446546"}]}