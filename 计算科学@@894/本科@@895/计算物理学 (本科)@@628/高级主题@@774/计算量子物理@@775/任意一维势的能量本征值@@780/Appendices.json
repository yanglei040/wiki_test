{"hands_on_practices": [{"introduction": "要将量子力学的连续微分方程转化为可计算的问题，最直接的方法之一是空间离散化。在此实践中，我们将采用这种基础性的矩阵方法 [@problem_id:2388919]。通过将一维薛定谔方程在一个均匀网格上近似，我们能把哈密顿算符表示为一个矩阵，其本征值和本征向量就对应着系统的能级和波函数。这个练习不仅能让你掌握将微分算子矩阵化的核心技能，还能通过分析所得波函数的宇称，将数值计算结果与对称性等基本量子原理联系起来。", "problem": "本题要求计算一个一维量子粒子在形似字母“W”的双势阱中运动的低阶能量本征值，并判断相应本征函数的对称性。目标是基于不含时薛定谔方程，实现一个数值计算流程，并设计一个程序，使其能够针对一组小的测试参数值，输出明确指定的量化结果。\n\n首先，从质量为 $m$、约化普朗克常数为 $\\hbar$ 的粒子的不含时薛定谔方程开始：\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2 \\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n并在无量纲单位（其中 $\\hbar^2/(2m) = 1$）下进行计算，此时方程变为：\n$$\n-\\,\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\n在有限区间 $x\\in[-L,L]$ 上施加齐次狄利克雷边界条件 $\\psi(-L)=\\psi(L)=0$，该区间需足够大，以确保束缚态波函数在边界处衰减至可忽略的值。在 $[-L,L]$ 上构建一个均匀网格，并使用标准的中心差分近似来表示二阶导数，从而推导出离散的矩阵本征值问题。求解所得的对称三对角矩阵本征问题，以获得最低的几个本征值 $E$ 和相应的归一化本征矢量 $\\psi$。确保对于给定的参数，该数值方法是稳定且收敛的。\n\n将“W”形势阱定义为一个四次双势阱，并可带有一个小的线性倾斜项：\n$$\nV(x) = a\\,(x^2 - b^2)^2 + \\varepsilon\\,x,\n$$\n当 $\\varepsilon=0$ 时，该势阱在 $x=\\pm b$ 处有两个极小值，在 $x=0$ 处有一个中心势垒。使用一个关于 $x=0$ 对称的网格，以便可以直接检验宇称。\n\n为分析每个本征函数 $\\psi(x)$ 的对称性，我们用宇称算符 $\\hat{P}$（定义为 $(\\hat{P}\\psi)(x)=\\psi(-x)$）的期望值来表征它，即：\n$$\n\\langle \\hat{P} \\rangle = \\frac{\\int_{-L}^{L}\\psi(x)\\,\\psi(-x)\\,dx}{\\int_{-L}^{L}|\\psi(x)|^2\\,dx}.\n$$\n对于一个完全偶的本征函数，$\\langle \\hat{P} \\rangle = +1$；对于一个完全奇的本征函数，$\\langle \\hat{P} \\rangle = -1$；而对于对称性破缺的态，$\\langle \\hat{P} \\rangle$ 的值将偏离 $\\pm 1$。在具有对称节点的均匀网格上，对于归一化的本征矢量，可通过计算该本征矢量与其反向副本的离散内积（经过适当归一化）来近似这个期望值。\n\n所有能量值必须以所选的无量纲单位（其中 $\\hbar^2/(2m)=1$）报告，并且所有最终数值结果必须四舍五入到 $6$ 位小数。\n\n实现一个完整的程序，该程序能够：\n1. 在内部网格点上，根据齐次狄利克雷边界条件（在 $x=\\pm L$ 处），构建与离散化算符 $-\\,d^2/dx^2 + V(x)$ 对应的三对角哈密顿矩阵。\n2. 计算最低的 $4$ 个本征值和归一化的本征矢量。\n3. 如上所述，为这 $4$ 个本征矢量计算宇称期望值 $\\langle \\hat{P} \\rangle$。\n4. 对每个测试用例，生成一行输出，按指定格式汇总结果。\n\n使用以下三个测试用例，每个用例均采用相同的数值离散化参数：\n- 区间半长度 $L = 6$，内部网格点数 $N = 1200$（在 $[-L, L]$ 上的均匀网格，离散算符不包括边界点）。\n- 势函数参数 $(a,b,\\varepsilon)$:\n  1. $(a,b,\\varepsilon)=(1.0,\\,1.0,\\,0.0)$，对称双势阱。\n  2. $(a,b,\\varepsilon)=(1.0,\\,1.0,\\,0.05)$，弱倾斜双势阱。\n  3. $(a,b,\\varepsilon)=(0.5,\\,1.5,\\,0.0)$，更宽、更缓和的对称双势阱。\n\n对于每个测试用例，你的程序必须计算最低的 $4$ 个能量值和对应的 $4$ 个宇称期望值。所有报告的数字均四舍五入到 $6$ 位小数。你的程序应生成单行输出，其中包含一个由列表组成的列表，每个内部列表首先包含 $4$ 个能量值，然后是 $4$ 个宇称期望值，格式如下：\n[[E0,E1,E2,E3,P0,P1,P2,P3],[...用例2的结果...],[...用例3的结果...]]\n其中每个 $E_k$ 和 $P_k$ 都是四舍五入到 $6$ 位小数的浮点数。所有能量值均采用 $\\hbar^2/(2m)=1$ 定义的无量纲单位。", "solution": "我们从一维粒子的不含时薛定谔方程入手：\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2 \\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\n采用无量纲约定 $\\hbar^2/(2m)=1$，方程简化为：\n$$\n-\\,\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\n我们将计算限制在有限区间 $x\\in[-L,L]$ 内，并施加齐次狄利克雷边界条件 $\\psi(-L)=\\psi(L)=0$。对于足够强的束缚势，束缚态波函数会迅速衰减，因此选择一个较大的 $L$ 可以确保边界误差可忽略不计。\n\n为了进行离散化，我们在 $[-L,L]$ 上设置一个包含 $N$ 个内部点的均匀网格，不包括端点以直接强制 $\\psi(\\pm L)=0$。设网格间距为 $\\Delta x = 2L/(N+1)$，内部节点为：\n$$\nx_i = -L + i\\,\\Delta x,\\quad i=1,2,\\dots,N.\n$$\n使用标准的中心差分（二阶精度）近似来表示二阶导数：\n$$\n\\psi''(x_i) \\approx \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2},\n$$\n微分算符 $-\\,d^2/dx^2$ 映射为一个三对角矩阵，其主对角线元素为 $2/(\\Delta x)^2$，次对角线元素为 $-1/(\\Delta x)^2$。势函数 $V(x)$ 作为 $V(x_i)$ 加到主对角线上。因此，作用于矢量 $\\boldsymbol{\\psi} = (\\psi_1,\\dots,\\psi_N)^\\top$ 的离散哈密顿量是一个 $N\\times N$ 的对称三对角矩阵：\n$$\nH = T + U,\\quad T = \\frac{1}{(\\Delta x)^2}\\,\\mathrm{tridiag}(-1,\\,2,\\,-1),\\quad U=\\mathrm{diag}\\big(V(x_1),\\dots,V(x_N)\\big).\n$$\n离散本征问题\n$$\nH\\,\\boldsymbol{\\psi} = E\\,\\boldsymbol{\\psi}\n$$\n近似了连续谱的束缚态问题。因为对于束缚势 $V(x)$，$H$ 是实对称且严格对角占优的，其谱是实数，最低的本征对近似了真实的能量和本征函数。我们使用三对角矩阵本征求解器计算最低的 $4$ 个本征值，以获得高效率和数值稳定性。\n\n我们选择“W”形势阱为：\n$$\nV(x) = a\\,(x^2 - b^2)^2 + \\varepsilon\\,x,\n$$\n其参数 $(a,b,\\varepsilon)$ 由每个测试用例指定。当 $\\varepsilon=0$ 时，势函数是偶函数，其本征函数具有确定的宇称（偶或奇）。当 $\\varepsilon\\neq 0$ 时，宇称对称性被破坏，本征函数既非纯偶也非纯奇。\n\n为量化对称性，我们计算宇称算符 $\\hat{P}$（定义为 $(\\hat{P}\\psi)(x)=\\psi(-x)$）的期望值：\n$$\n\\langle \\hat{P} \\rangle = \\frac{\\int_{-L}^{L} \\psi(x)\\,\\psi(-x)\\,dx}{\\int_{-L}^{L}|\\psi(x)|^2\\,dx}.\n$$\n在一个对称的均匀网格上，其节点为 $\\{x_i\\}_{i=1}^N$，本征矢量分量为 $\\{\\psi_i\\}_{i=1}^N$ 并在欧几里得意义上归一化（即 $\\sum_i |\\psi_i|^2 = 1$），离散近似使用反向索引来实现 $x\\mapsto -x$。因为分子和分母都带有相同的均匀求积权重 $\\Delta x$，该因子在比率中被消去。因此，我们计算：\n$$\n\\langle \\hat{P} \\rangle \\approx \\sum_{i=1}^{N} \\psi_i\\,\\psi_{N+1-i},\n$$\n对于一个严格的偶态，该值等于 $+1$；对于一个严格的奇态，该值等于 $-1$；随着对称性逐渐被破坏或数值误差累积，该值会向 $0$ 偏离。标准对称本征求解器返回的本征矢量在欧几里得范数下是标准正交的，这确保了分母为 $1$。\n\n算法总结：\n1. 选择 $L$ 和 $N$；计算 $\\Delta x = 2L/(N+1)$ 和内部网格点 $x_i$。\n2. 对每个测试用例，计算 $V(x_i)$ 并组装主对角线元素 $d_i = 2/(\\Delta x)^2 + V(x_i)$ 和次对角线元素 $e_i = -1/(\\Delta x)^2$。\n3. 使用一个三对角对称本征求解器计算最低的 $4$ 个本征对 $\\{(E_k,\\boldsymbol{\\psi}^{(k)})\\}_{k=0}^3$。\n4. 对每个本征矢量，计算宇称期望值 $\\langle \\hat{P} \\rangle_k \\approx \\sum_i \\psi^{(k)}_i \\psi^{(k)}_{N+1-i}$。\n5. 将所有 $E_k$ 和 $\\langle \\hat{P} \\rangle_k$ 四舍五入到 $6$ 位小数。\n6. 输出一行，包含一个由三个列表组成的列表，每个测试用例一个，格式为 [E0,E1,E2,E3,P0,P1,P2,P3]。\n\n数值参数和测试集：\n- 对所有用例，使用 $L=6$ 和 $N=1200$。\n- 三种势函数参数 $(a,b,\\varepsilon)$:\n  1. $(1.0,\\,1.0,\\,0.0)$，对称双势阱。\n  2. $(1.0,\\,1.0,\\,0.05)$，弱倾斜势阱。\n  3. $(0.5,\\,1.5,\\,0.0)$，对称、更宽的势阱。\n\n所有输出均为无量纲能量和宇称期望值，单位为 $\\hbar^2/(2m)=1$，并四舍五入到 $6$ 位小数。最终程序构建哈密顿矩阵，求解最低的 $4$ 个本征对，计算宇称诊断值，并以指定的聚合格式将结果打印为单行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef compute_spectrum_and_parity(a, b, eps, L=6.0, N=1200, k=4):\n    # Uniform grid setup: N interior points between -L and L\n    dx = 2.0 * L / (N + 1)\n    x = np.linspace(-L + dx, L - dx, N)\n\n    # Define the W-shaped double-well potential with optional tilt\n    V = a * (x**2 - b**2)**2 + eps * x\n\n    # Build tridiagonal Hamiltonian H = T + V:\n    # T main diagonal: 2/dx^2, off-diagonals: -1/dx^2\n    t_main = (2.0 / dx**2) * np.ones(N)\n    t_off = (-1.0 / dx**2) * np.ones(N - 1)\n\n    # Add potential to main diagonal\n    d = t_main + V\n    e = t_off\n\n    # Solve for the lowest k eigenpairs of the symmetric tridiagonal matrix\n    # eigh_tridiagonal returns eigenvalues in ascending order\n    w, v = eigh_tridiagonal(d, e, select='i', select_range=(0, k - 1))\n\n    # Ensure eigenvectors are column-wise (N x k). eigh_tridiagonal guarantees this.\n    # Compute parity expectation <P> = sum_i psi_i * psi_{N+1-i}\n    # Since eigenvectors are Euclidean-normalized (sum psi_i^2 = 1), no extra normalization factor needed.\n    parities = []\n    for j in range(k):\n        vec = v[:, j]\n        p = float(np.dot(vec, vec[::-1]))\n        parities.append(p)\n\n    # Round results to 6 decimals as required\n    energies_rounded = [float(f\"{val:.6f}\") for val in w]\n    parities_rounded = [float(f\"{val:.6f}\") for val in parities]\n\n    # Return combined list [E0,E1,E2,E3,P0,P1,P2,P3]\n    return energies_rounded + parities_rounded\n\ndef solve():\n    # Define the test cases from the problem statement: (a, b, eps)\n    test_cases = [\n        (1.0, 1.0, 0.0),   # symmetric double well\n        (1.0, 1.0, 0.05),  # weakly tilted well\n        (0.5, 1.5, 0.0),   # wider, softer symmetric double well\n    ]\n\n    # Fixed numerical parameters\n    L = 6.0\n    N = 1200\n    k = 4\n\n    results = []\n    for a, b, eps in test_cases:\n        res = compute_spectrum_and_parity(a, b, eps, L=L, N=N, k=k)\n        results.append(res)\n\n    # Format the final output exactly as a single line of comma-separated lists.\n    # Each inner list: [E0,E1,E2,E3,P0,P1,P2,P3], numbers rounded to 6 decimals.\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n\n    output = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2388919"}, {"introduction": "除了直接对角化哈密顿矩阵，还有一种求解本征值问题的强大范式，即“打靶法” (shooting method) [@problem_id:2422745]。这种方法巧妙地将寻找能量本征值的问题转化为一个根寻找问题：我们尝试不同的能量 $E$，积分薛定谔方程，并检查在边界远处波函数是否满足物理条件（即衰减为零）。本练习将引导你使用这种方法求解非谐振子的能级，这不仅能加深你对边值问题数值解法的理解，还将锻炼你应用数值积分和求根算法解决实际物理问题的能力。", "problem": "考虑一个质量为 $m$ 的粒子在非谐势 $V(x) = \\tfrac{1}{2} m \\omega^2 x^2 + \\tfrac{1}{4} \\lambda x^4$ 中运动的一维定态薛定谔方程。其基本定律为\n$$\n-\\frac{\\hbar^2}{2 m} \\frac{d^2 \\psi}{d x^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n其中 $\\hbar$ 是约化普朗克常数，$\\psi(x)$ 是束缚态波函数，$E$ 是能量本征值。采用标准谐振子标度进行无量纲化：长度为 $x_0 = \\sqrt{\\hbar/(m \\omega)}$，能量为 $E_0 = \\hbar \\omega$。定义无量纲坐标 $\\xi = x / x_0$、无量纲能量 $\\varepsilon = E / E_0$ 以及无量纲非谐性参数 $\\alpha = \\lambda \\hbar /(m^2 \\omega^3)$。证明薛定谔方程可简化为如下无量纲形式\n$$\n-\\frac{1}{2}\\,\\frac{d^2 \\psi}{d \\xi^2} + \\left(\\tfrac{1}{2}\\,\\xi^2 + \\tfrac{1}{4}\\,\\alpha\\,\\xi^4\\right)\\psi(\\xi) = \\varepsilon\\,\\psi(\\xi),\n$$\n并等价地化为如下初值形式\n$$\n\\frac{d \\psi}{d \\xi} = \\phi,\\qquad \\frac{d \\phi}{d \\xi} = \\left(\\xi^2 + \\tfrac{1}{2}\\,\\alpha\\,\\xi^4 - 2 \\varepsilon\\right)\\psi,\n$$\n其中 $\\phi = d\\psi/d\\xi$。\n\n利用在偶势场中束缚态的物理宇称来设定在 $\\xi = 0$ 处的初始条件。对于最低的偶宇称态，设 $\\psi(0) = 1$ 和 $\\phi(0) = 0$。对于最低的奇宇称态，设 $\\psi(0) = 0$ 和 $\\phi(0) = 1$。在这两种情况下，总体归一化系数是任意的，不影响能量本征值的计算。\n\n你的任务是计算两个最低的束缚态能量，即最低的偶宇称态和最低的奇宇称态。为此，你需要实现一个打靶法，该方法将 $\\varepsilon$ 视为未知参数，并使用一个开放的求根方案在有限的定义域截断处施加边界条件。具体来说：\n\n- 对上述系统，使用固定的均匀步长 $h = 0.005$ 从 $\\xi = 0$ 积分到一个有限边界 $\\xi = L$（$L = 10$）。使用一个标准的、能处理平滑函数的显式数值积分器（例如，四阶 Runge–Kutta 格式），针对给定的试验 $\\varepsilon$ 和宇称，计算出 $\\psi(L;\\varepsilon)$。\n- 对于给定的宇称，将打靶残差定义为 $F(\\varepsilon) = \\psi(L;\\varepsilon)$。正确的本征值满足 $F(\\varepsilon) = 0$，因为一个可归一化的束缚态会衰减，使得在一个足够大但有限的 $L$ 处，$\\psi$ 的值小到可以忽略不计。\n- 使用一种开放的求根方法，具体来说是割线法（该方法仅使用函数值），来求解关于 $\\varepsilon$ 的方程 $F(\\varepsilon) = 0$。请勿使用区间法。当满足 $|\\Delta \\varepsilon| < 10^{-10}$ 或 $|F(\\varepsilon)| < 10^{-8}$，或达到最大迭代次数 $50$ 次时，终止割线法迭代。\n\n所有能量均以无量纲单位 $E_0 = \\hbar \\omega$ 报告，即直接报告 $\\varepsilon$ 的值。将每个报告的能量值四舍五入到 $6$ 位小数。\n\n测试套件与覆盖范围：\n- 在 $\\hbar = 1$ 的无量纲化下，使用以下三组参数 $(m,\\omega,\\lambda)$ 来定义 $\\alpha = \\lambda \\hbar /(m^2 \\omega^3)$。\n  - 案例 A （谐振子极限，边界情况）：$(m,\\omega,\\lambda) = (1,1,0)$。\n  - 案例 B （弱非谐性，理想路径）：$(m,\\omega,\\lambda) = (1,1,0.2)$。\n  - 案例 C （中等非谐性）：$(m,\\omega,\\lambda) = (1,1,0.5)$。\n对每个案例，计算并返回以 $E_0$ 为单位的最低偶宇称态能量和最低奇宇称态能量。因此，程序每个案例产生 $2$ 个数，总共产生 $6$ 个数。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为：[even_A, odd_A, even_B, odd_B, even_C, odd_C]，其中每个条目是相应计算出的 $\\varepsilon$ 值，并四舍五入到 $6$ 位小数。\n- 不允许有任何其他输出。", "solution": "所给出的问题是计算量子力学中一个标准的、适定的练习。它在科学上是合理的，内部逻辑一致，并包含了确定唯一解所需的所有必要信息。在详细介绍数值解法之前，我将首先进行此部分的推导。\n\n**1. 薛定谔方程的无量纲化**\n\n出发点是质量为 $m$ 的粒子在势 $V(x)$ 中的一维定态薛定谔方程：\n$$\n-\\frac{\\hbar^2}{2m} \\frac{d^2 \\psi}{d x^2} + \\left(\\frac{1}{2} m \\omega^2 x^2 + \\frac{1}{4} \\lambda x^4\\right)\\psi(x) = E\\,\\psi(x)\n$$\n我们给定了长度的特征尺度 $x_0 = \\sqrt{\\hbar/(m \\omega)}$ 和能量的特征尺度 $E_0 = \\hbar \\omega$。我们引入无量纲变量 $\\xi = x/x_0$ 和 $\\varepsilon = E/E_0$。\n\n根据链式法则，导数的变换关系如下：\n$$\n\\frac{d}{dx} = \\frac{d\\xi}{dx} \\frac{d}{d\\xi} = \\frac{1}{x_0} \\frac{d}{d\\xi}\n$$\n$$\n\\frac{d^2}{dx^2} = \\frac{d}{dx}\\left(\\frac{1}{x_0} \\frac{d}{d\\xi}\\right) = \\frac{1}{x_0^2} \\frac{d^2}{d\\xi^2}\n$$\n将 $x = \\xi x_0$，$E = \\varepsilon E_0$ 以及二阶导数代入原方程，得到：\n$$\n-\\frac{\\hbar^2}{2m} \\left(\\frac{1}{x_0^2} \\frac{d^2 \\psi}{d\\xi^2}\\right) + \\left(\\frac{1}{2} m \\omega^2 (x_0 \\xi)^2 + \\frac{1}{4} \\lambda (x_0 \\xi)^4\\right)\\psi = (\\varepsilon E_0)\\psi\n$$\n为进行简化，我们将整个方程除以能量标度 $E_0 = \\hbar \\omega$：\n$$\n-\\frac{\\hbar^2}{2m E_0 x_0^2} \\frac{d^2 \\psi}{d\\xi^2} + \\left(\\frac{m \\omega^2 x_0^2}{2 E_0} \\xi^2 + \\frac{\\lambda x_0^4}{4 E_0} \\xi^4\\right)\\psi = \\varepsilon\\psi\n$$\n现在，我们使用 $x_0$ 和 $E_0$ 的定义来计算各项系数：\n- 二阶导数项的系数：\n$$\n-\\frac{\\hbar^2}{2m (\\hbar\\omega) (\\hbar/(m\\omega))} = -\\frac{\\hbar^2 m \\omega}{2m \\hbar^2 \\omega} = -\\frac{1}{2}\n$$\n- $\\xi^2$ 项的系数：\n$$\n\\frac{m \\omega^2 (\\hbar/(m\\omega))}{2 (\\hbar\\omega)} = \\frac{m \\omega^2 \\hbar}{2 m \\omega \\hbar \\omega} = \\frac{1}{2}\n$$\n- $\\xi^4$ 项的系数：\n$$\n\\frac{\\lambda x_0^4}{4 E_0} = \\frac{\\lambda (\\hbar/(m\\omega))^2}{4 (\\hbar\\omega)} = \\frac{\\lambda \\hbar^2}{4 m^2 \\omega^2 \\hbar \\omega} = \\frac{\\lambda \\hbar}{4 m^2 \\omega^3} = \\frac{1}{4} \\alpha\n$$\n其中 $\\alpha = \\lambda \\hbar / (m^2 \\omega^3)$ 是无量纲非谐性参数。\n\n综合这些系数，我们得到所要求的无量纲方程，该方程由此得到验证：\n$$\n-\\frac{1}{2}\\,\\frac{d^2 \\psi}{d \\xi^2} + \\left(\\frac{1}{2}\\,\\xi^2 + \\frac{1}{4}\\,\\alpha\\,\\xi^4\\right)\\psi(\\xi) = \\varepsilon\\,\\psi(\\xi)\n$$\n为了将这个二阶常微分方程（ODE）转换为一个一阶常微分方程组，我们首先分离出二阶导数项：\n$$\n\\frac{d^2 \\psi}{d \\xi^2} = 2 \\left(\\frac{1}{2}\\,\\xi^2 + \\frac{1}{4}\\,\\alpha\\,\\xi^4 - \\varepsilon\\right)\\psi = \\left(\\xi^2 + \\frac{1}{2}\\,\\alpha\\,\\xi^4 - 2\\varepsilon\\right)\\psi\n$$\n通过定义 $\\phi(\\xi) = d\\psi/d\\xi$，我们得到以下方程组：\n$$\n\\frac{d\\psi}{d\\xi} = \\phi(\\xi)\n$$\n$$\n\\frac{d\\phi}{d\\xi} = \\left(\\xi^2 + \\frac{1}{2}\\,\\alpha\\,\\xi^4 - 2\\varepsilon\\right)\\psi(\\xi)\n$$\n该方程组也得到验证。\n\n**2. 数值方法**\n\n问题是找到能量本征值 $\\varepsilon$，使得波函数 $\\psi(\\xi)$ 在物理上是可接受的，即是可归一化的。这要求当 $\\xi \\to \\pm\\infty$ 时，$\\psi(\\xi) \\to 0$。该问题使用打靶法来求解。\n\n势 $V(x)$ 是一个偶函数，因此其本征函数必须具有确定的宇称（偶宇称或奇宇称）。我们可以利用这种对称性，从 $\\xi=0$ 开始向外积分。\n- 对于 **偶宇称态**，$\\psi(-\\xi) = \\psi(\\xi)$，这意味着在原点处的导数为零：$\\phi(0) = d\\psi/d\\xi|_{\\xi=0} = 0$。由于薛定谔方程的线性性质，我们可以设置 $\\psi(0) = 1$。\n- 对于 **奇宇称态**，$\\psi(-\\xi) = -\\psi(\\xi)$，这意味着 $\\psi(0)=0$。为了获得非平凡解，我们必须有一个非零的斜率，所以我们设置导数 $\\phi(0) = 1$。\n\n打靶法在于将能量 $\\varepsilon$ 视为一个可变参数。对于一个试验值 $\\varepsilon$，我们求解从 $\\xi=0$ 到一个足够大的边界 $\\xi=L$ 的初值问题。物理条件 $\\psi(\\xi \\to \\infty) = 0$ 由数值条件 $\\psi(L) = 0$ 来近似。因此，我们定义一个残差函数 $F(\\varepsilon) = \\psi(L; \\varepsilon)$，问题就简化为寻找 $F(\\varepsilon) = 0$ 的根。\n\n算法如下：\n1.  **定义 ODE 系统**：一个函数将代表状态向量 $\\mathbf{y} = [\\psi, \\phi]^T$ 的一阶系统的右侧。\n    $$ \\frac{d\\mathbf{y}}{d\\xi} = f(\\xi, \\mathbf{y}; \\varepsilon, \\alpha) = \\begin{bmatrix} \\phi \\\\ (\\xi^2 + \\frac{1}{2}\\alpha\\xi^4 - 2\\varepsilon)\\psi \\end{bmatrix} $$\n2.  **积分 ODE**：问题要求使用一个显式数值积分器。一个标准的四阶 Runge-Kutta (RK4) 方法是合适的，并将被实现。从基于所需宇称的初始状态 $\\mathbf{y}(0)$ 开始，系统以 $h=0.005$ 的步长从 $\\xi=0$ 积分到 $\\xi=L=10$。积分的结果是所选 $\\varepsilon$ 对应的 $\\psi(L)$ 值。此函数 $\\varepsilon \\mapsto \\psi(L; \\varepsilon)$ 即为我们的打靶函数 $F(\\varepsilon)$。\n3.  **求根**：问题指定使用割线法（一种开放的求根方案）来求解 $F(\\varepsilon) = 0$。给定两个能量的初始猜测值 $\\varepsilon_{k-1}$ 和 $\\varepsilon_k$，下一个近似值 $\\varepsilon_{k+1}$ 通过以下递推关系找到：\n    $$ \\varepsilon_{k+1} = \\varepsilon_k - F(\\varepsilon_k) \\frac{\\varepsilon_k - \\varepsilon_{k-1}}{F(\\varepsilon_k) - F(\\varepsilon_{k-1})} $$\n    迭代持续进行，直到满足指定的收敛标准之一：$|\\varepsilon_{k+1} - \\varepsilon_k| < 10^{-10}$ 或 $|F(\\varepsilon_{k+1})| < 10^{-8}$，或超过最大迭代次数 $50$ 次。\n    必须审慎地选择 $\\varepsilon$ 的初始猜测值。对于谐振子情况（$\\alpha=0$），精确的本征值为 $\\varepsilon_n = n + 1/2$。最低的偶宇称态对应于 $n=0$（$\\varepsilon_0=0.5$），最低的奇宇称态对应于 $n=1$（$\\varepsilon_1=1.5$）。这些值是我们进行猜测的绝佳起点。当 $\\alpha > 0$ 时，势阱变得更陡峭，这会使能级升高。因此，对于非谐情况，初始猜测值应选择得比其谐振子对应值稍高。\n\n4.  **计算所有案例**：对从测试案例中得出的三个 $\\alpha$ 值，以及对偶宇称和奇宇称两种情况，重复整个过程，以找到六个所需的能量本征值。\n\n实现将包含一个主驱动函数，该函数会遍历参数集和宇称。此函数将调用一个割线法求解器，而该求解器又会反复调用一个 RK4 积分例程来评估打靶函数 $F(\\varepsilon)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the two lowest bound-state energies for an anharmonic oscillator\n    using a shooting method with a secant root-finder.\n    \"\"\"\n    \n    # Problem Constants\n    L = 10.0\n    h = 0.005\n    \n    # Secant Method Parameters\n    MAX_ITER = 50\n    TOL_EPS = 1e-10\n    TOL_F = 1e-8\n\n    def get_derivatives(xi, state, epsilon, alpha):\n        \"\"\"\n        Computes the derivatives for the ODE system.\n        state = [psi, phi], where phi = d(psi)/d(xi)\n        \"\"\"\n        psi, phi = state\n        d_psi_d_xi = phi\n        d_phi_d_xi = (xi**2 + 0.5 * alpha * xi**4 - 2.0 * epsilon) * psi\n        return np.array([d_psi_d_xi, d_phi_d_xi])\n\n    def solve_ode_rk4(initial_state, epsilon, alpha):\n        \"\"\"\n        Solves the ODE system from xi=0 to xi=L using RK4.\n        Returns the final value of psi(L).\n        This is the shooting function F(epsilon).\n        \"\"\"\n        state = np.array(initial_state, dtype=float)\n        num_steps = int(L / h)\n        \n        for i in range(num_steps):\n            xi = i * h\n            \n            k1 = h * get_derivatives(xi, state, epsilon, alpha)\n            k2 = h * get_derivatives(xi + 0.5 * h, state + 0.5 * k1, epsilon, alpha)\n            k3 = h * get_derivatives(xi + 0.5 * h, state + 0.5 * k2, epsilon, alpha)\n            k4 = h * get_derivatives(xi + h, state + k3, epsilon, alpha)\n            \n            state += (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n            \n        return state[0] # Return psi(L)\n\n    def find_energy_secant(initial_state, e_guesses, alpha):\n        \"\"\"\n        Finds the energy eigenvalue using the secant method.\n        \"\"\"\n        e_prev, e_curr = e_guesses\n        f_prev = solve_ode_rk4(initial_state, e_prev, alpha)\n        f_curr = solve_ode_rk4(initial_state, e_curr, alpha)\n\n        for _ in range(MAX_ITER):\n            if abs(f_curr) < TOL_F:\n                return e_curr\n            \n            delta_e = e_curr - e_prev\n            if abs(delta_e) < TOL_EPS:\n                return e_curr\n            \n            # Avoid division by zero or a very small number\n            if abs(f_curr - f_prev) < 1e-15:\n                # If function values are too close, the method may fail.\n                # This indicates either convergence or a problem.\n                # For this problem, it's likely convergence.\n                return e_curr\n            \n            e_next = e_curr - f_curr * delta_e / (f_curr - f_prev)\n            \n            e_prev, e_curr = e_curr, e_next\n            f_prev, f_curr = f_curr, solve_ode_rk4(initial_state, e_curr, alpha)\n            \n        return e_curr\n\n    # Define the test cases from the problem statement.\n    # We set hbar = 1, so alpha = lambda / (m^2 * omega^3)\n    test_cases = [\n        # Case A: (m, omega, lambda) = (1, 1, 0)\n        (1.0, 1.0, 0.0),\n        # Case B: (m, omega, lambda) = (1, 1, 0.2)\n        (1.0, 1.0, 0.2),\n        # Case C: (m, omega, lambda) = (1, 1, 0.5)\n        (1.0, 1.0, 0.5),\n    ]\n\n    results = []\n    \n    # Initial conditions for even and odd states\n    ic_even = [1.0, 0.0]  # psi(0)=1, phi(0)=0\n    ic_odd = [0.0, 1.0]   # psi(0)=0, phi(0)=1\n\n    # Initial guesses for energy eigenvalues (e_prev, e_curr)\n    # Based on QHO energies (0.5, 1.5) and perturbation theory\n    # (energy increases with alpha)\n    guesses = {\n        'A': {'even': (0.4, 0.6), 'odd': (1.4, 1.6)},\n        'B': {'even': (0.5, 0.7), 'odd': (1.6, 1.8)},\n        'C': {'even': (0.6, 0.8), 'odd': (1.7, 1.9)},\n    }\n    case_labels = ['A', 'B', 'C']\n\n    for i, case in enumerate(test_cases):\n        m, omega, lamb = case\n        case_label = case_labels[i]\n        \n        # In the problem, hbar=1 for test cases\n        alpha = lamb / (m**2 * omega**3)\n        \n        # Lowest even state energy\n        e_guesses_even = guesses[case_label]['even']\n        even_energy = find_energy_secant(ic_even, e_guesses_even, alpha)\n        results.append(f\"{even_energy:.6f}\")\n        \n        # Lowest odd state energy\n        e_guesses_odd = guesses[case_label]['odd']\n        odd_energy = find_energy_secant(ic_odd, e_guesses_odd, alpha)\n        results.append(f\"{odd_energy:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2422745"}, {"introduction": "在掌握了分析给定系统的技能后，一个更高级的挑战是“反问题”：设计一个系统以实现特定的性质。本次实践正是这样一个设计挑战 [@problem_id:2388915]，我们的目标是构建一个特定形状的势阱，并精确调节其深度 $V_0$，使其恰好包含预设数量的束缚态。为此，我们将学习并实现一种高效的本征值计数方法（Sturm 序列）和一种鲁棒的参数搜索算法（二分法），这充分展示了计算物理学如何在量子层面从分析走向设计。", "problem": "设计并实现一个程序，该程序使用量子力学第一性原理和数值分析方法，构建一维“漏斗”势的单参数族，并自动调节深度参数以产生指定数量的束缚态。在无量纲单位制下进行计算，其中 $\\hbar^{2}/(2m)=1$，此时不含时薛定谔方程为\n$$\n- \\frac{d^{2}\\psi(x)}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\n假设当 $|x|\\to\\infty$ 时 $V(x)\\to 0$，则束缚态被定义为能量本征值 $E$ 严格小于 $0$ 的态。考虑光滑的“漏斗”势族\n$$\nV(x;V_{0},b,p) = -\\frac{V_{0}}{1+\\left(\\frac{|x|}{b}\\right)^{p}},\n$$\n其中深度参数 $V_{0}>0$，宽度尺度 $b>0$，形状参数 $p>0$。在有限区间 $[-L,L]$（其中 $L\\gg b$）上，施加齐次狄利克雷边界条件 $\\psi(-L)=\\psi(L)=0$，并使用标准的二阶中心有限差分近似法在间距为 $h$ 的均匀网格上对二阶导数算符进行离散化。这样可以得到一个实对称三对角哈密顿矩阵，其对角元为 $a_{i} = 2/h^{2} + V(x_{i})$，非对角元为 $-1/h^{2}$。对于给定的 $V_{0}$，使用 Sylvester 惯性定律以及对称三对角矩阵的 Sturm 序列特性，来计算严格小于阈值 $\\lambda=0$ 的本征值的数量。然后，仅利用能谱相对于势阱深度 $V_{0}$ 的单调性，实现一个稳健的二分程序，找到使 $E<0$ 的本征值数量等于目标值 $N_{\\mathrm{target}}$ 的最小 $V_{0}$。\n\n您可以使用的基本原理包括：不含时薛定谔方程、对于在无穷远处消失的势，束缚态定义为 $E<0$、有限差分近似法，以及用于计算低于某个偏移量的本征值数量的 Sturm 序列/惯性定律方法。\n\n物理单位：由于选择了 $\\hbar^{2}/(2m)=1$，所有量都应视为无量纲量。程序必须报告四舍五入到小数点后六位的 $V_{0}$ 值（无量纲）。\n\n离散化要求：\n- 选择 $L$ 为 $L=\\alpha\\,b$，其中 $\\alpha$ 是一个固定的、足够大的值，以近似 $|x|\\to\\infty$ 的边界；选择 $h$ 为 $h=\\beta\\,b$，其中 $\\beta$ 是一个固定的、足够小的值，以解析束缚态波函数。对于本作业，请使用 $\\alpha = 20$ 和 $\\beta = 0.01$。\n- 在构建具有狄利克雷边界条件（在 $x=\\pm L$ 处）的三对角哈密顿时，仅使用内部网格点。\n\n算法要求：\n- 实现一个函数，在给定主对角元数组 $a_{i}$ 和恒定的非对角元大小 $|b_{\\mathrm{FD}}|=1/h^{2}$ 的情况下，使用 Sturm 递归式\n$$\nd_{1} = a_{1}-\\lambda,\\quad d_{k} = (a_{k}-\\lambda) - \\frac{b_{\\mathrm{FD}}^{2}}{d_{k-1}}\\quad\\text{对于 }k\\ge 2,\n$$\n返回严格小于 $\\lambda=0$ 的本征值数量，并计算有多少个 $d_{k}$ 为负数。当 $|d_{k-1}|$ 变得非常小时，需要实现数值保护措施以处理除法运算，同时避免不必要地改变符号。\n- 在 $V_{0}$ 上实现一个二分例程，首先限定区间，然后分离出使小于 $0$ 的本征值数量等于 $N_{\\mathrm{target}}$ 的最小 $V_{0}$。从 $V_{0,\\mathrm{low}}=0$ 开始，并通过乘以 2 的方式增加 $V_{0,\\mathrm{high}}$，直到满足区间限定条件。当区间宽度小于容差 $\\varepsilon_{V}$ 时终止；对于本作业，请使用 $\\varepsilon_{V}=10^{-8}$。\n\n测试套件与要求输出：\n- 使用以下测试用例，每个用例由 $(N_{\\mathrm{target}}, b, p)$ 指定，均为无量纲单位：\n    - 情况 A (理想情形): $(5, 1.0, 2.0)$。\n    - 情况 B (宽漏斗): $(5, 2.0, 2.0)$。\n    - 情况 C (陡峭核心): $(5, 1.0, 6.0)$。\n    - 情况 D (窄漏斗): $(5, 0.5, 2.0)$。\n- 对于每种情况，使用上述程序计算并返回得到恰好 $N_{\\mathrm{target}}$ 个束缚态的最小 $V_{0}$，计算时使用 $L=\\alpha\\,b$ (其中 $\\alpha=20$) 和 $h=\\beta\\,b$ (其中 $\\beta=0.01$)。最终的程序输出必须是单行文本，包含一个由四个 $V_{0}$ 值组成的逗号分隔列表，每个值四舍五入到小数点后六位，并用方括号括起来，例如，“[vA,vB,vC,vD]”。", "solution": "所提出的问题是计算量子力学中一个定义明确的练习，要求确定一个能产生特定数量束缚态的势参数 $V_0$。该问题有科学依据，内部逻辑一致，并且不需要任何超出所提供信息之外的知识。因此，该问题是有效的，并允许进行严格求解。\n\n其物理基础是一维不含时薛定谔方程，在指定的无量纲单位制下（$\\hbar^2/(2m)=1$），该方程为：\n$$\n- \\frac{d^{2}\\psi(x)}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n所考虑的势是“漏斗”势 $V(x; V_0, b, p) = -V_0 / (1 + (|x|/b)^p)$。束缚态是能量本征值 $E < 0$ 的解。对于任意势，求解此本征值问题需要采用数值方法。指定的方法涉及在有限空间域上对问题进行离散化。\n\n变量 $x$ 的连续域被替换为有限区间 $[-L, L]$，其中 $L$ 被选择得足够大（$L = \\alpha b$ 且 $\\alpha=20$）以近似无限域。施加了齐次狄利克雷边界条件 $\\psi(-L) = \\psi(L) = 0$。该区间被离散化为一个均匀网格，间距为 $h = \\beta b$（其中 $\\beta=0.01$）。网格点为 $x_i = -L + i \\cdot h$，其中 $i=0, 1, \\dots, N_{\\mathrm{grid}}$，$N_{\\mathrm{grid}} = 2L/h$。在 $M = N_{\\mathrm{grid}}-1$ 个内部点上求解 $\\psi(x)$。\n\n二阶导数算符使用二阶中心差分格式进行近似：\n$$\n\\frac{d^2\\psi}{dx^2}\\bigg|_{x=x_i} \\approx \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}\n$$\n其中 $\\psi_i \\equiv \\psi(x_i)$。将此代入薛定谔方程，将该微分方程转化为矩阵本征值方程 $H\\vec{\\psi} = E\\vec{\\psi}$。此处，$H$ 是一个大小为 $M \\times M$ 的实对称三对角矩阵，其元为：\n-   对角元：$a_i = \\frac{2}{h^2} + V(x_i)$，对于 $i=1, \\dots, M$。\n-   非对角元：$b_{i, i\\pm 1} = -\\frac{1}{h^2}$。\n\n目标是找到矩阵 $H$ 小于 $0$ 的本征值的数量。问题指定使用 Sturm 序列法，而非计算成本高昂的完全对角化。该方法基于 Sylvester 惯性定律，能在 $O(M)$ 次操作内确定对称三对角矩阵低于给定偏移量 $\\lambda$ 的本征值数量。小于 $\\lambda$ 的本征值数量等于通过以下递推关系计算出的序列 $\\{d_k\\}_{k=1}^M$ 中负项的数量：\n$$\nd_1 = a_1 - \\lambda\n$$\n$$\nd_k = (a_k - \\lambda) - \\frac{b_{\\mathrm{FD}}^2}{d_{k-1}}, \\quad \\text{对于 } k=2, \\dots, M\n$$\n其中 $b_{\\mathrm{FD}} = -1/h^2$ 是非对角元。对于本问题，偏移量为 $\\lambda=0$。为了处理 $d_{k-1}$ 项在数值上为零的情况，可将其替换为一个小的正数，以防止除零错误，同时不会错误地改变符号计数。此过程可为给定的势深 $V_0$ 得出束缚态的数量 $N(V_0)$。\n\n束缚态数量 $N(V_0)$ 是 $V_0$ 的单调不减函数，这是量子力学变分原理的一个推论。这个关键属性使得可以使用二分搜索算法高效地找到使 $N(V_0) = N_{\\mathrm{target}}$ 的最小 $V_0$。搜索过程如下：\n1.  **区间限定**：找到一个包含目标 $V_0$ 的区间 $[V_{0,\\mathrm{low}}, V_{0,\\mathrm{high}}]$。我们从 $V_{0,\\mathrm{low}} = 0$ 开始，此时 $N(0)=0$。通过从一个猜测值（例如 $V_{0,\\mathrm{high}}=1.0$）开始，并重复将其加倍，直到 $N(V_{0,\\mathrm{high}}) \\ge N_{\\mathrm{target}}$，来找到上界 $V_{0,\\mathrm{high}}$。\n2.  **二分法**：该区间被迭代优化。在每一步中，测试中点 $V_{0,\\mathrm{mid}} = (V_{0,\\mathrm{low}} + V_{0,\\mathrm{high}})/2$。如果 $N(V_{0,\\mathrm{mid}}) < N_{\\mathrm{target}}$，说明势阱还不够深，因此我们更新 $V_{0,\\mathrm{low}} = V_{0,\\mathrm{mid}}$。如果 $N(V_{0,\\mathrm{mid}}) \\ge N_{\\mathrm{target}}$，说明势阱足够深，因此我们更新 $V_{0,\\mathrm{high}} = V_{0,\\mathrm{mid}}$ 以继续寻找最小值。\n重复此过程，直到区间宽度 $(V_{0,\\mathrm{high}} - V_{0,\\mathrm{low}})$ 小于指定的容差 $\\varepsilon_V = 10^{-8}$。最终答案是得到的上界 $V_{0,\\mathrm{high}}$。\n\n该算法被实现来处理每个提供的测试用例 $(N_{\\mathrm{target}}, b, p)$，并以要求的格式报告计算出的 $V_0$ 值（四舍五入到小数点后六位）。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the calculation of V0 for each case and prints the final result.\n    \"\"\"\n\n    # Global constants defined in the problem statement\n    ALPHA = 20.0\n    BETA = 0.01\n    EPSILON_V = 1e-8\n    # Small number to safeguard against division by zero in the Sturm sequence.\n    STURM_SAFEGUARD = 1e-30\n\n    def sturm_count_eigenvalues_below_shift(diag, off_diag_sq, shift):\n        \"\"\"\n        Counts the number of eigenvalues of a symmetric tridiagonal matrix\n        that are strictly less than a given shift.\n\n        Args:\n            diag (np.ndarray): The main diagonal of the matrix.\n            off_diag_sq (float): The square of the constant off-diagonal element.\n            shift (float): The energy threshold for counting eigenvalues.\n\n        Returns:\n            int: The number of eigenvalues less than the shift.\n        \"\"\"\n        count = 0\n        \n        # Initialize the first term of the Sturm sequence\n        d_prev = diag[0] - shift\n        if d_prev < 0:\n            count += 1\n        \n        # Safeguard for d_prev being numerically zero\n        if abs(d_prev) < STURM_SAFEGUARD:\n            d_prev = STURM_SAFEGUARD\n        \n        # Iterate through the rest of the sequence\n        for i in range(1, len(diag)):\n            d_k = (diag[i] - shift) - off_diag_sq / d_prev\n            if d_k < 0:\n                count += 1\n            \n            # Safeguard for d_k being numerically zero\n            if abs(d_k) < STURM_SAFEGUARD:\n                d_k = STURM_SAFEGUARD\n            \n            d_prev = d_k\n            \n        return count\n\n    def get_bound_state_count(V0, b, p):\n        \"\"\"\n        Sets up the discrete Hamiltonian and counts the number of bound states (E < 0).\n\n        Args:\n            V0 (float): The depth parameter of the potential.\n            b (float): The width parameter of the potential.\n            p (float): The shape parameter of the potential.\n\n        Returns:\n            int: The number of bound states for the given potential.\n        \"\"\"\n        # 1. Define discretization parameters based on b\n        L = ALPHA * b\n        h = BETA * b\n        \n        # 2. Set up the spatial grid (interior points only)\n        num_interior_points = int(round(2 * L / h)) - 1\n        x = np.linspace(-L + h, L - h, num_interior_points)\n        \n        # 3. Calculate the potential on the grid\n        V = -V0 / (1.0 + (np.abs(x) / b)**p)\n        \n        # 4. Define the Hamiltonian matrix elements\n        h_sq = h * h\n        diagonal = 2.0 / h_sq + V\n        off_diagonal_squared = (1.0 / h_sq)**2\n        \n        # 5. Count eigenvalues below the bound state threshold (E=0)\n        return sturm_count_eigenvalues_below_shift(diagonal, off_diagonal_squared, 0.0)\n\n    def find_minimal_V0(N_target, b, p):\n        \"\"\"\n        Finds the smallest V0 that produces exactly N_target bound states\n        using a bisection search algorithm.\n\n        Args:\n            N_target (int): The target number of bound states.\n            b (float): The width parameter of the potential.\n            p (float): The shape parameter of the potential.\n\n        Returns:\n            float: The minimal V0 value.\n        \"\"\"\n        # Phase 1: Bracket the solution\n        V_low = 0.0\n        \n        # For N_target=0, V0=0 is the trivial solution.\n        # For N_target > 0, V0=0 gives 0 states.\n        if N_target == 0:\n            return 0.0\n\n        # Start with a reasonable guess for V_high and expand until it's large enough.\n        V_high = 1.0\n        while get_bound_state_count(V_high, b, p) < N_target:\n            V_low = V_high\n            V_high *= 2.0\n            # Safety break to prevent an infinite loop in unforeseen circumstances.\n            if V_high > 1e6:\n                raise RuntimeError(\"Bracketing search for V0 failed to converge.\")\n\n        # Phase 2: Bisection to find the precise V0\n        while (V_high - V_low) > EPSILON_V:\n            V_mid = V_low + (V_high - V_low) / 2.0\n            \n            # Prevent getting stuck if precision limit is reached\n            if V_mid == V_low or V_mid == V_high:\n                break\n            \n            num_states = get_bound_state_count(V_mid, b, p)\n            \n            if num_states < N_target:\n                # Potential well is not deep enough\n                V_low = V_mid\n            else: # num_states >= N_target\n                # Potential is deep enough, this could be the answer, or a smaller V0 works\n                V_high = V_mid\n                \n        # V_high is the upper bound of the final interval, representing the smallest V0\n        # that yields N_target states.\n        return V_high\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (N_target, b, p)\n        (5, 1.0, 2.0),  # Case A: happy path\n        (5, 2.0, 2.0),  # Case B: wide funnel\n        (5, 1.0, 6.0),  # Case C: steep core\n        (5, 0.5, 2.0),  # Case D: narrow funnel\n    ]\n\n    results = []\n    for case in test_cases:\n        N_target, b, p = case\n        V0_result = find_minimal_V0(N_target, b, p)\n        results.append(V0_result)\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2388915"}]}