{"hands_on_practices": [{"introduction": "在量子力学中，一个核心任务是求解系统在外部微扰（如电场）下的能谱。本练习将引导你使用矩阵对角化这一强大技术来解决这个问题。我们将学习如何在一个有限的、由未受扰动谐振子本征态构成的基组中，构建一个受扰动系统的哈密顿量矩阵 $H$。通过求解该矩阵的本征值，我们不仅能精确地计算出新的能级，还能深入理解基组截断对数值精度带来的影响，这是计算物理中的一个基本考量。[@problem_id:2431866]", "problem": "考虑一个一维量子谐振子(QHO)，其质量为 $m$，角频率为 $\\omega$，粒子电荷为 $q$，受到一个沿坐标 $x$ 方向、大小为 $\\mathcal{E}$ 的空间均匀静电场的作用。其哈密顿量由下式给出\n$$\n\\hat{H} = \\frac{\\hat{p}^2}{2m} + \\frac{1}{2} m \\omega^2 \\hat{x}^2 - q \\mathcal{E}\\,\\hat{x}.\n$$\n在无量纲谐振子单位制下进行计算，该单位制定义为 $\\hbar=1$, $m=1$, $\\omega=1$ 且 $q=1$。在此单位制中，能量以 $\\hbar\\omega$ 为单位，长度以 $\\sqrt{\\hbar/(m\\omega)}$ 为单位，电场强度 $\\mathcal{E}$ 是无量纲的。在此单位制下，未受扰动的量子谐振子(QHO)的本征能量为 $E_n^{(0)} = n + \\tfrac{1}{2}$，其中 $n \\in \\{0,1,2,\\dots\\}$。\n\n你的任务是，对于给定的有限基底大小 $N$ 和场强 $\\mathcal{E}$，计算最低的 $k$ 个谐振子能级的数值能量位移 $\\Delta E_n^{\\text{num}}(\\mathcal{E}) = E_n(\\mathcal{E}) - E_n^{(0)}$，并将其与弱场微扰理论预测的二次斯塔克位移进行比较。在该单位制下，此位移对于所有 $n$ 均为 $\\Delta E_n^{\\text{pert}}(\\mathcal{E}) = -\\tfrac{\\mathcal{E}^2}{2}$。对于每个指定的测试用例 $(\\mathcal{E}, N, k)$，计算前 $k$ 个能级的最大绝对偏差，\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n \\le k-1} \\left| \\Delta E_n^{\\text{num}}(\\mathcal{E}) - \\Delta E_n^{\\text{pert}}(\\mathcal{E}) \\right|,\n$$\n该值以无量纲能量单位表示。\n\n使用以下参数值构成的测试套件，这些参数共同探测了零场边界情况、弱场下的一致性、更大基底下改进的收敛性，以及一个截断应力边缘情况：\n- 测试 1: $(\\mathcal{E}, N, k) = (0.0, 20, 5)$。\n- 测试 2: $(\\mathcal{E}, N, k) = (0.05, 20, 5)$。\n- 测试 3: $(\\mathcal{E}, N, k) = (0.2, 30, 5)$。\n- 测试 4: $(\\mathcal{E}, N, k) = (1.0, 12, 5)$。\n\n你的程序必须输出一行内容，包含上述四个测试的 $\\varepsilon_{\\max}$ 值，形式为一个用方括号括起来的逗号分隔列表，每个值都四舍五入到10位小数，例如 $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$。在指定的单位制下，所有量都是无量纲的，因此无需报告物理单位。角度没有出现，因此不需要角度单位。不使用百分比；任何分数形式的量都必须表示为小数或不带百分号的分数。", "solution": "所述问题是有效的。这是一个计算量子力学中的适定问题 (well-posed problem)，它具有科学依据、是客观的，并包含了求解所需的所有信息。我们将着手解决它。\n\n任务是求解在静电场作用下的一维量子谐振子(QHO)的能级。该系统的哈密顿量由下式给出：\n$$\n\\hat{H} = \\frac{\\hat{p}^2}{2m} + \\frac{1}{2} m \\omega^2 \\hat{x}^2 - q \\mathcal{E}\\,\\hat{x}\n$$\n我们在无量纲单位制下工作，其中 $\\hbar=1, m=1, \\omega=1$ 且 $q=1$。哈密顿量简化为：\n$$\n\\hat{H} = \\left(\\frac{\\hat{p}^2}{2} + \\frac{1}{2} \\hat{x}^2\\right) - \\mathcal{E}\\,\\hat{x} = \\hat{H}_0 + \\hat{V}\n$$\n其中 $\\hat{H}_0$ 是未受扰动的量子谐振子(QHO)的哈密顿量，而 $\\hat{V} = -\\mathcal{E}\\hat{x}$ 是由电场 $\\mathcal{E}$ 引起的微扰势。\n\n对于此类问题，标准的数值方法是将哈密顿量在一个合适的基底中表示为矩阵，然后求出其本征值。自然的选择是使用未受扰动的哈密顿量的本征态集 $\\{|n\\rangle\\}$ 作为基底，其中 $n \\in \\{0, 1, 2, \\dots\\}$。这些态满足 $\\hat{H}_0|n\\rangle = E_n^{(0)}|n\\rangle$，其未受扰动的能量为 $E_n^{(0)} = n + \\frac{1}{2}$。\n\n在实践中，我们必须将这个无限维的基底截断到一个有限大小，比如 $N$。因此，我们将在截断后的基底 $\\{|0\\rangle, |1\\rangle, \\dots, |N-1\\rangle\\}$ 中进行计算。哈密顿量由一个 $N \\times N$ 矩阵表示，其矩阵元为 $H_{m,n} = \\langle m|\\hat{H}|n\\rangle$。\n\n矩阵元的计算如下：\n$$\nH_{m,n} = \\langle m|\\hat{H}_0|n\\rangle + \\langle m|\\hat{V}|n\\rangle = E_n^{(0)}\\delta_{m,n} - \\mathcal{E}\\langle m|\\hat{x}|n\\rangle\n$$\n为了求得位置算符 $\\hat{x}$ 的矩阵元，我们用下降算符 ($\\hat{a}$) 和上升算符 ($\\hat{a}^\\dagger$) 来表示它。在我们选择的单位制中，$\\hat{x} = \\frac{1}{\\sqrt{2}}(\\hat{a} + \\hat{a}^\\dagger)$。这些算符对基态的作用是众所周知的：\n$$\n\\hat{a}|n\\rangle = \\sqrt{n}|n-1\\rangle \\quad \\text{和} \\quad \\hat{a}^\\dagger|n\\rangle = \\sqrt{n+1}|n+1\\rangle\n$$\n这导出了 $\\hat{x}$ 的矩阵元：\n$$\n\\langle m|\\hat{x}|n\\rangle = \\frac{1}{\\sqrt{2}} \\left( \\sqrt{n}\\langle m|n-1\\rangle + \\sqrt{n+1}\\langle m|n+1\\rangle \\right) = \\frac{1}{\\sqrt{2}} \\left( \\sqrt{n}\\delta_{m,n-1} + \\sqrt{n+1}\\delta_{m,n+1} \\right)\n$$\n唯一的非零元位于次对角线 ($m=n-1$) 和超对角线 ($m=n+1$) 上。\n\n因此，完整的哈密顿矩阵 $H$ 是一个实对称三对角矩阵，对于 $m,n \\in \\{0, 1, \\dots, N-1\\}$，其矩阵元如下：\n- 对角元： $H_{n,n} = E_n^{(0)} = n + \\frac{1}{2}$\n- 非对角元： $H_{n,n+1} = H_{n+1,n} = -\\mathcal{E} \\langle n|\\hat{x}|n+1\\rangle = -\\mathcal{E} \\sqrt{\\frac{n+1}{2}}$\n\n数值计算得到的能级 $E_n^{\\text{num}}(\\mathcal{E})$ 是这个 $N \\times N$ 矩阵的本征值。我们的任务是计算这些本征值中最低的 $k$ 个。\n\n问题要求将数值能量位移 $\\Delta E_n^{\\text{num}}(\\mathcal{E}) = E_n^{\\text{num}}(\\mathcal{E}) - E_n^{(0)}$ 与二阶微扰理论的结果 $\\Delta E_n^{\\text{pert}}(\\mathcal{E}) = -\\frac{\\mathcal{E}^2}{2}$ 进行比较。一个重要的物理洞见是，对于这个特定系统，微扰理论的结果实际上是精确的。这可以通过对哈密顿量中的势能项进行配方看出：\n$$\nV(\\hat{x}) = \\frac{1}{2}\\hat{x}^2 - \\mathcal{E}\\hat{x} = \\frac{1}{2}(\\hat{x}^2 - 2\\mathcal{E}\\hat{x} + \\mathcal{E}^2) - \\frac{\\mathcal{E}^2}{2} = \\frac{1}{2}(\\hat{x} - \\mathcal{E})^2 - \\frac{\\mathcal{E}^2}{2}\n$$\n完整的哈密顿量是 $\\hat{H} = \\frac{\\hat{p}^2}{2} + \\frac{1}{2}(\\hat{x} - \\mathcal{E})^2 - \\frac{\\mathcal{E}^2}{2}$。这是一个势能最低点从 $x=0$ 平移到 $x=\\mathcal{E}$ 的量子谐振子(QHO)的哈密顿量，再加上一个大小为 $-\\frac{\\mathcal{E}^2}{2}$ 的恒定能量偏移。一个简单的坐标平移不会改变相对于新最低点的能谱。因此，精确的能量本征值为 $E_n(\\mathcal{E}) = (n + \\frac{1}{2}) - \\frac{\\mathcal{E}^2}{2}$。\n\n因此，精确的能量位移为 $\\Delta E_n^{\\text{exact}}(\\mathcal{E}) = E_n(\\mathcal{E}) - E_n^{(0)} = -\\frac{\\mathcal{E}^2}{2}$，这与为 $\\Delta E_n^{\\text{pert}}(\\mathcal{E})$ 提供的公式是相同的。因此，待计算的量，\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n \\le k-1} \\left| \\Delta E_n^{\\text{num}}(\\mathcal{E}) - \\Delta E_n^{\\text{pert}}(\\mathcal{E}) \\right|\n$$\n代表了对最低 $k$ 个态使用数值对角化方法所产生的最大绝对误差，这个误差源于将无限维希尔伯特空间截断为大小为 $N$ 的有限基底。\n\n每个测试用例 $(\\mathcal{E}, N, k)$ 的计算步骤如下：\n1. 对于给定的基底大小 $N$，构建三对角哈密顿矩阵的对角元和非对角元。\n2. 如果 $\\mathcal{E}=0$，则矩阵是纯对角的，因此 $E_n^{\\text{num}} = n+\\frac{1}{2}$。位移 $\\Delta E_n^{\\text{num}}$ 和 $\\Delta E_n^{\\text{pert}}$ 均为零，因此 $\\varepsilon_{\\max}=0$。\n3. 如果 $\\mathcal{E} \\neq 0$，使用一个高效的数值算法，例如 `scipy.linalg.eigh_tridiagonal`，来计算该 $N \\times N$ 矩阵的最低 $k$ 个本征值。这些值即为 $E_n^{\\text{num}}(\\mathcal{E})$，其中 $n=0, \\dots, k-1$。\n4. 对这 $k$ 个能级计算数值位移 $\\Delta E_n^{\\text{num}}(\\mathcal{E}) = E_n^{\\text{num}}(\\mathcal{E}) - (n+\\frac{1}{2})$。\n5. 计算每个能级与精确位移的偏差：$|\\Delta E_n^{\\text{num}}(\\mathcal{E}) - (-\\frac{\\mathcal{E}^2}{2})|$。\n6. 结果 $\\varepsilon_{\\max}$ 是这 $k$ 个偏差中的最大值。\n将实施此程序来评估指定的测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the quantum harmonic oscillator in a static electric field problem\n    by numerical diagonalization and compares it to the exact result.\n    \"\"\"\n    # Test cases: (Electric Field E, Basis Size N, Number of levels k)\n    test_cases = [\n        (0.0, 20, 5),\n        (0.05, 20, 5),\n        (0.2, 30, 5),\n        (1.0, 12, 5),\n    ]\n\n    results = []\n\n    for E_field, N, k in test_cases:\n        # For a zero field, the Hamiltonian matrix is already diagonal.\n        # The eigenvalues are exactly the unperturbed ones, so the numerical\n        # shift is zero. The perturbative shift is also zero.\n        # Thus, the deviation is exactly zero.\n        if E_field == 0.0:\n            eps_max = 0.0\n            results.append(f\"{eps_max:.10f}\")\n            continue\n\n        # Construct the components of the tridiagonal Hamiltonian matrix.\n        # H_nn = n + 0.5\n        diag = np.arange(N, dtype=float) + 0.5\n        \n        # H_{n, n+1} = -E * sqrt((n+1)/2)\n        off_diag = -E_field * np.sqrt((np.arange(N - 1, dtype=float) + 1.0) / 2.0)\n\n        # Diagonalize the tridiagonal Hamiltonian to find the lowest k eigenvalues.\n        # The 'select' and 'select_range' arguments allow for an efficient\n        # calculation of only the desired subset of eigenvalues.\n        E_num = eigh_tridiagonal(\n            diag, off_diag, eigvals_only=True, select='i', select_range=(0, k - 1)\n        )\n\n        # Unperturbed energies for the lowest k levels.\n        E0 = np.arange(k, dtype=float) + 0.5\n\n        # Numerical energy shift for each level.\n        delta_E_num = E_num - E0\n\n        # The \"perturbative\" shift is exact for the QHO Stark effect.\n        delta_E_pert = -E_field**2 / 2.0\n\n        # Calculate the absolute deviation for each of the k levels.\n        deviations = np.abs(delta_E_num - delta_E_pert)\n\n        # Find the maximum deviation among the k levels.\n        eps_max = np.max(deviations)\n\n        # Store the result formatted to 10 decimal places.\n        results.append(f\"{eps_max:.10f}\")\n\n    # Print the final list of results in the required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2431866"}, {"introduction": "从静态的能级结构转向动态的量子世界，模拟波包的时间演化是理解量子力学的关键一步。本实践将介绍分裂算符傅里叶变换法（split-operator FFT method），这是一种求解含时薛定谔方程的高效算法。我们将应用此方法模拟奇特而深刻的量子芝诺效应，通过计算来直观感受频繁的测量如何“冻结”一个量子系统的演化，从而为量子测量这一核心概念提供一个可操作的视角。[@problem_id:2431890]", "problem": "您将从含时薛定谔方程出发，使用分裂算符算法，对一维量子谐振子的量子芝诺效应（QZE）进行完整的数值模拟。在无量纲单位制下进行计算，其中约化普朗克常数 $\\hbar$、质量 $m$ 和振子角频率 $\\omega$ 均设为 $\\hbar = m = \\omega = 1$。因此，哈密顿量为 $H = \\frac{p^2}{2} + \\frac{x^2}{2}$。目标是证明对初态进行频繁的投影测量会抑制系统从该状态演化出去。\n\n基本原理：\n- 含时薛定谔方程为 $i \\frac{\\partial}{\\partial t} \\psi(x,t) = H \\psi(x,t)$，其中 $H = T + V$，$T = \\frac{p^2}{2}$，$V = \\frac{x^2}{2}$。\n- 在一个小时间步长 $\\Delta t$ 内的幺正时间演化算符为 $U(\\Delta t) \\approx e^{-i V \\Delta t/2} \\, e^{-i T \\Delta t} \\, e^{-i V \\Delta t/2}$（二阶对称Trotter–Suzuki分解或分裂算符近似）。\n- 动能项在动量空间中是对角的，而势能项在位置空间中是对角的。使用快速傅里叶变换（FFT）在这些表示之间切换。\n\n待实现的算法：\n- 在均匀网格 $x \\in [-L, L)$ 上离散化空间，该网格有 $N_x$ 个点，间距为 $\\Delta x = 2L/N_x$。通过角波数 $k = 2\\pi \\cdot \\text{fftfreq}(N_x, \\Delta x)$ 构建相应的离散动量网格 $p$，并在 $\\hbar=1$ 的单位制下认定 $p=k$。\n- 初始化一个以 $(x_0, p_0)$ 为中心的类相干态高斯波包：\n  $$\\psi_0(x) = \\pi^{-1/4} \\exp\\!\\left(-\\frac{(x-x_0)^2}{2}\\right) \\exp\\!\\left(i p_0 x\\right),$$\n  并使用包含 $\\Delta x$ 的离散内积对其进行数值归一化。\n- 为时间增量 $\\Delta t$ 实现分裂算符步骤，此过程使用快速傅里叶变换 (FFT) 及其逆变换，在位置空间中应用势能因子，在动量空间中应用动能因子。\n- 为模拟对初态的重复投影测量，对于给定的总时间 $T$ 和在等间隔 $\\Delta t = T/N$ 下进行的整数次测量 $N$，按以下步骤操作：\n  1. 对于每个 $j=1,\\dots,N$，从初态 $\\psi_0(x)$ 开始，进行幺正演化 $\\Delta t$ 时间，得到 $\\psi_{\\text{pre}}(x)$。\n  2. 使用离散内积 $\\langle \\phi | \\psi \\rangle \\approx \\sum_x \\phi^*(x)\\psi(x)\\,\\Delta x$ 计算复数交叠 $c_j = \\langle \\psi_0 | \\psi_{\\text{pre}} \\rangle$。\n  3. 将累积存活概率乘以 $|c_j|^2$ 进行更新。\n  4. 通过将测量后状态替换为对初态的归一化投影来施加测量，即，将状态重置为 $\\psi_0(x)$。\n- 报告 $N$ 次测量后的累积存活概率。所有概率均为无量纲；将结果报告为小数，四舍五入到小数点后六位。\n\n数值规格：\n- 使用 $N_x = 2048$ 和 $L = 12.0$。使用带标准正交化的FFT以保持数值幺正性。\n- 对所有测试用例使用相同的空间网格和算符。\n\n测试套件：\n对于下面的每个参数集 $(T, N, x_0, p_0)$，计算如上所述的 $N$ 次投影测量后的累积存活概率。所有量均为无量纲。程序必须生成单行输出，其中包含所有测试用例的结果，按顺序排列，形式为方括号内由逗号分隔的列表，每个浮点数四舍五入到小数点后六位。\n\n- 用例 $1$：$T = 1.0$，$N = 1$，$x_0 = 1.0$，$p_0 = 0.0$。\n- 用例 $2$：$T = 1.0$，$N = 10$，$x_0 = 1.0$，$p_0 = 0.0$。\n- 用例 $3$：$T = 1.0$，$N = 50$，$x_0 = 1.0$，$p_0 = 0.0$。\n- 用例 $4$：$T = 1.0$，$N = 200$，$x_0 = 1.0$，$p_0 = 0.0$。\n- 用例 $5$：$T = 1.0$，$N = 50$，$x_0 = 0.0$，$p_0 = 1.0$。\n- 用例 $6$：$T = 0.0$，$N = 10$，$x_0 = 1.0$，$p_0 = 0.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，形式为方括号内由逗号分隔的列表（例如，$[r_1,r_2,\\dots,r_6]$），其中每个 $r_i$ 是用例 $i$ 的存活概率，四舍五入到小数点后六位。", "solution": "所述问题已经过验证，被认定为科学上合理、提法恰当且内部一致。它是一个计算量子物理学中的标准练习。我们将继续进行解的推导和实现。\n\n支配量子系统动力学的基本方程是含时薛定谔方程（TDSE）：\n$$\ni \\hbar \\frac{\\partial}{\\partial t} \\psi(x,t) = H \\psi(x,t)\n$$\n在问题给定的 $\\hbar=m=\\omega=1$ 的无量纲单位制下，一维量子谐振子的哈密顿量为：\n$$\nH = \\frac{p^2}{2m} + \\frac{1}{2}m\\omega^2 x^2 \\rightarrow H = \\frac{p^2}{2} + \\frac{x^2}{2}\n$$\n此处，$p = -i \\frac{\\partial}{\\partial x}$ 是动量算符。哈密顿量被分为动能项 $T = \\frac{p^2}{2}$ 和势能项 $V = \\frac{x^2}{2}$，使得 $H = T + V$。\n\n对于不含时哈密顿量，TDSE的正式解由幺正时间演化算符 $U(t) = e^{-iHt/\\hbar}$ 给出。在我们的单位制下，这变为 $U(t) = e^{-iHt}$。对于一个微小的时间步长 $\\Delta t$，状态演化为 $\\psi(x, t+\\Delta t) = e^{-iH\\Delta t} \\psi(x,t)$。\n\n由于动能算符 $T$ 和势能算符 $V$ 不对易（$[T, V] \\neq 0$），它们的和的指数不能简单地分解。我们采用二阶对称Trotter-Suzuki分解（也称为分裂算符方法）来近似演化算符：\n$$\nU(\\Delta t) = e^{-i(T+V)\\Delta t} \\approx e^{-iV\\Delta t/2} e^{-iT\\Delta t} e^{-iV\\Delta t/2} + \\mathcal{O}(\\Delta t^3)\n$$\n该近似是幺正的，并且在 $\\Delta t$ 上具有二阶精度。其数值实现依赖于这样一个事实：势能算符 $V$ 在位置基 $\\{|x\\rangle\\}$ 中是对角的，而动能算符 $T$ 在动量基 $\\{|p\\rangle\\}$ 中是对角的。我们可以使用快速傅里叶变换（FFT）及其逆变换在这些基之间高效切换。FFT算法将离散化的位置表示 $\\psi(x_j)$ 与离散化的动量（波数）表示 $\\tilde{\\psi}(p_k)$ 联系起来。问题指定使用标准正交FFT（`norm=\"ortho\"`），这确保了离散版本的Parseval定理成立，且变换是幺正的，从而保持了态矢量的范数。\n\n单个时间步长 $\\Delta t$ 的算法流程如下：\n1.  在位置空间中应用前半步的势能演化：$\\psi'(x) = e^{-iV(x)\\Delta t/2} \\psi(x)$。\n2.  使用FFT将状态变换到动量空间：$\\tilde{\\psi'}(p) = \\text{FFT}[\\psi'(x)]$。\n3.  在动量空间中应用完整的动能演化：$\\tilde{\\psi''}(p) = e^{-iT(p)\\Delta t} \\tilde{\\psi'}(p)$。\n4.  使用逆FFT将状态变换回位置空间：$\\psi''(x) = \\text{iFFT}[\\tilde{\\psi''}(p)]$。\n5.  在位置空间中应用后半步的势能演化：$\\psi(x, t+\\Delta t) = e^{-iV(x)\\Delta t/2} \\psi''(x)$。\n\n计算网格定义在空间域 $x \\in [-L, L)$ 上，有 $N_x$ 个点，网格间距为 $\\Delta x = 2L/N_x$。相应的动量网格由角波数 $k = 2\\pi \\cdot \\text{fftfreq}(N_x, \\Delta x)$ 构成，在我们的单位制中 $p=k$。\n\n初始状态是一个归一化的高斯波包，即谐振子的一个相干态：\n$$\n\\psi_0(x) = C \\exp\\left(-\\frac{(x-x_0)^2}{2}\\right) \\exp\\left(i p_0 x\\right)\n$$\n解析归一化常数为 $C = \\pi^{-1/4}$，但在数值实现中，我们在离散网格上计算状态，并使用离散内积 $\\langle \\phi | \\psi \\rangle = \\sum_{j} \\phi^*(x_j) \\psi(x_j) \\Delta x$ 对其进行归一化。范数为 $\\|\\psi\\| = \\sqrt{\\langle\\psi|\\psi\\rangle}$，归一化后的状态为 $\\psi_0(x) / \\|\\psi_0\\|$。\n\n量子芝诺效应（QZE）的模拟涉及重复的投影测量。对于总时间 $T$ 和 $N$ 次测量，两次测量之间的时间间隔为 $\\Delta t = T/N$。指定的协议如下：对于 $N$ 个时间间隔中的每一个，系统从初始状态 $\\psi_0$ 开始，演化时间 $\\Delta t$ 到达状态 $\\psi_{\\text{pre}} = U(\\Delta t)\\psi_0$，然后被投影回 $\\psi_0$。系统“存活”这一个步骤（即演化后被发现处于状态 $\\psi_0$）的概率是 $P_{\\Delta t} = |\\langle\\psi_0|\\psi_{\\text{pre}}\\rangle|^2 = |\\langle\\psi_0|U(\\Delta t)|\\psi_0\\rangle|^2$。\n\n由于该过程指定每个测量周期都从相同的初始状态 $\\psi_0$ 开始，因此每个周期的存活概率是相同的。因此，$N$ 次此类测量后的累积存活概率是各次概率的乘积，可简化为 $(P_{\\Delta t})^N$。\n\n因此，对于每个测试用例 $(T, N, x_0, p_0)$ 的计算任务是：\n1.  如果 $T=0$，存活概率恰好为 $1$，因为 $\\Delta t=0$ 且 $U(0)=\\mathbb{I}$。\n2.  如果 $T>0$，计算 $\\Delta t = T/N$。\n3.  构建空间网格 $x$ 和动量网格 $p$。\n4.  构建并数值归一化初始状态 $\\psi_0(x)$。\n5.  构建离散演化算符 $e^{-iV(x)\\Delta t/2}$ 和 $e^{-iT(p)\\Delta t}$。\n6.  应用一次分裂算符方法，将 $\\psi_0$ 演化 $\\Delta t$ 时间，得到 $\\psi_{\\text{pre}}$。\n7.  计算单步存活概率 $P_{\\Delta t} = |\\langle\\psi_0|\\psi_{\\text{pre}}\\rangle|^2$。\n8.  最终结果是 $(P_{\\Delta t})^N$。\n\n这个过程将演示量子芝诺效应（QZE）：对于固定的 $T$，随着 $N$ 的增加，$\\Delta t$ 减小，$U(\\Delta t)$ 趋近于单位算符，$P_{\\Delta t}$ 趋近于 $1$，总存活概率 $(P_{\\Delta t})^N$ 趋近于一个极限值，该值大于在时间 $T$ 内进行单次不间断演化的存活概率。对于非常大的 $N$，这个极限是 $1$，表明频繁的测量“冻结”了系统的演化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the survival probability of a quantum harmonic oscillator\n    under repeated projective measurements (Quantum Zeno Effect).\n    \"\"\"\n\n    # Numerical specification\n    Nx = 2048\n    L = 12.0\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (T, N, x_0, p_0)\n        (1.0, 1, 1.0, 0.0),\n        (1.0, 10, 1.0, 0.0),\n        (1.0, 50, 1.0, 0.0),\n        (1.0, 200, 1.0, 0.0),\n        (1.0, 50, 0.0, 1.0),\n        (0.0, 10, 1.0, 0.0),\n    ]\n\n    # Set up spatial and momentum grids\n    dx = 2 * L / Nx\n    x = np.linspace(-L, L, Nx, endpoint=False)\n    # In our units (hbar=1), p = k = 2*pi*f\n    p = 2 * np.pi * np.fft.fftfreq(Nx, dx)\n\n    # Define potential and kinetic energy functions\n    V_x = 0.5 * x**2\n    T_p = 0.5 * p**2\n    \n    results = []\n\n    for T, N, x0, p0 in test_cases:\n        # Trivial case: no time evolution\n        if T == 0.0:\n            results.append(1.0)\n            continue\n        \n        # Calculate time step for evolution between measurements\n        dt = T / N\n\n        # Construct initial state psi_0 (unnormalized)\n        psi0_unnormalized = np.exp(-0.5 * (x - x0)**2) * np.exp(1j * p0 * x)\n        \n        # Numerically normalize the initial state\n        norm_sq = np.sum(np.abs(psi0_unnormalized)**2) * dx\n        psi0 = psi0_unnormalized / np.sqrt(norm_sq)\n\n        # Construct split-operator factors for one time step dt\n        V_op_half = np.exp(-1j * V_x * dt / 2.0)\n        T_op = np.exp(-1j * T_p * dt)\n\n        # --- Single step of unitary evolution ---\n        # 1. Apply first half-potential step\n        psi_evolved = V_op_half * psi0\n        \n        # 2. FFT to momentum space\n        psi_evolved = np.fft.fft(psi_evolved, norm=\"ortho\")\n        \n        # 3. Apply kinetic step\n        psi_evolved = T_op * psi_evolved\n        \n        # 4. Inverse FFT back to position space\n        psi_evolved = np.fft.ifft(psi_evolved, norm=\"ortho\")\n        \n        # 5. Apply second half-potential step\n        psi_pre = V_op_half * psi_evolved\n\n        #\n        # --- Calculate cumulative survival probability ---\n        #\n        # Survival probability for a single interval dt\n        # P(dt) = |<psi_0|U(dt)|psi_0>|^2\n        overlap = np.vdot(psi0, psi_pre) * dx\n        prob_single_step = np.abs(overlap)**2\n\n        # Cumulative probability after N measurements is (P(dt))^N\n        # due to the reset to psi_0 at each step.\n        cumulative_prob = prob_single_step ** N\n\n        results.append(cumulative_prob)\n\n    # Format the final output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2431890"}, {"introduction": "对于更复杂的量子系统，传统的矩阵对角化或网格方法往往由于计算资源的指数增长而变得不可行。本练习将带你进入随机方法的世界，介绍一种强大的前沿技术——变分蒙特卡罗（Variational Monte Carlo, VMC）方法。通过结合量子力学中的变分原理和统计学中的随机抽样，我们将学习如何为一个试探波函数 $\\psi_T(x, \\alpha)$ 优化参数 $\\alpha$，以估算系统的基态能量。这个实践不仅展示了一种解决高维问题的有效策略，也揭示了统计物理思想在量子计算中的深刻应用。[@problem_id:2431867]", "problem": "考虑一个一维量子谐振子，其哈密顿量为\n$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + \\frac{1}{2} m \\omega^2 x^2,\n$$\n其中 $m$ 是质量，$\\omega$ 是角频率，$\\hbar$ 是约化普朗克常数。设试探波函数为\n$$\n\\psi_T(x,\\alpha) = e^{-\\alpha x^2},\n$$\n其中变分参数 $\\alpha \\gt 0$。对于给定的 $\\alpha$，变分能量泛函为\n$$\nE(\\alpha) = \\frac{\\int_{-\\infty}^{\\infty} \\psi_T(x,\\alpha) \\, \\hat{H} \\, \\psi_T(x,\\alpha) \\, dx}{\\int_{-\\infty}^{\\infty} |\\psi_T(x,\\alpha)|^2 \\, dx}.\n$$\n定义概率密度\n$$\n\\rho_\\alpha(x) \\propto |\\psi_T(x,\\alpha)|^2 = e^{-2\\alpha x^2},\n$$\n以及相应的局域能量\n$$\nE_L(x;\\alpha) = \\frac{\\hat{H}\\psi_T(x,\\alpha)}{\\psi_T(x,\\alpha)}.\n$$\n变分能量可以表示为期望值\n$$\nE(\\alpha) = \\mathbb{E}_{x \\sim \\rho_\\alpha}[E_L(x;\\alpha)].\n$$\n在本问题中，您必须通过从 $\\rho_\\alpha(x)$ 进行统计抽样来数值估算 $E(\\alpha)$，并确定在指定区间内使该估算值最小化的 $\\alpha$ 值。过程中，使用自然单位制，令 $\\hbar = 1$。所有能量均以该单位制报告，并将所有报告的浮点数四舍五入到 $6$ 位小数。\n\n对于下述测试套件中的每个测试用例，通过在一个闭区间 $[\\alpha_{\\min}, \\alpha_{\\max}]$ 上的 $N_\\alpha$ 个均匀网格点上计算 $E(\\alpha)$ 来估计使能量最小化的 $\\alpha$，并选择具有最小估计能量的网格点。对于每个网格点 $\\alpha$，通过对从 $\\rho_ \\alpha(x) \\propto e^{-2\\alpha x^2}$ 中抽取的 $N_{\\text{samples}}$ 个独立样本 $x$ 计算得到的 $E_L(x;\\alpha)$ 的算术平均值来近似 $E(\\alpha)$。在生成独立样本时，请使用提供的随机种子以确保可复现性。对于每个测试用例，输出数对 $[\\alpha_{\\text{opt}}, E(\\alpha_{\\text{opt}})]$，其中 $\\alpha_{\\text{opt}}$ 是使能量最小化的网格点值。\n\n使用以下测试套件。对于每个用例，参数以 $(m,\\omega,\\alpha_{\\min},\\alpha_{\\max},N_\\alpha,N_{\\text{samples}},\\text{seed})$ 的形式给出：\n- 用例 $1$：$(m=\\;1.0,\\;\\omega=\\;1.0,\\;\\alpha_{\\min}=\\;0.2,\\;\\alpha_{\\max}=\\;1.0,\\;N_\\alpha=\\;41,\\;N_{\\text{samples}}=\\;50000,\\;\\text{seed}=\\;12345)$。\n- 用例 $2$：$(m=\\;2.0,\\;\\omega=\\;0.5,\\;\\alpha_{\\min}=\\;0.2,\\;\\alpha_{\\max}=\\;0.9,\\;N_\\alpha=\\;36,\\;N_{\\text{samples}}=\\;50000,\\;\\text{seed}=\\;24680)$。\n- 用例 $3$：$(m=\\;0.5,\\;\\omega=\\;3.0,\\;\\alpha_{\\min}=\\;0.3,\\;\\alpha_{\\max}=\\;1.2,\\;N_\\alpha=\\;46,\\;N_{\\text{samples}}=\\;50000,\\;\\text{seed}=\\;98765)$。\n- 用例 $4$ (样本较少的边缘情况)：$(m=\\;1.0,\\;\\omega=\\;2.0,\\;\\alpha_{\\min}=\\;0.5,\\;\\alpha_{\\max}=\\;1.5,\\;N_\\alpha=\\;26,\\;N_{\\text{samples}}=\\;5000,\\;\\text{seed}=\\;13579)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例对应一个双元素列表 $[\\alpha_{\\text{opt}}, E(\\alpha_{\\text{opt}})]$，两个条目都四舍五入到 $6$ 位小数。例如，包含两个用例的输出应如下所示：$[[\\alpha_1,E_1],[\\alpha_2,E_2]]$，其中用数值替换。在此问题中，输出必须是包含按上述用例顺序排列的四个此类数对的单行文本。", "solution": "本问题是计算量子物理学中的一个标准练习，具体涉及应用变分蒙特卡洛（Variational Monte Carlo, VMC）方法来确定一维量子谐振子的基态能量。在继续之前，有必要进行严格的验证。\n\n该问题基于量子力学的变分原理，使用高斯试探波函数 $\\psi_T(x, \\alpha) = e^{-\\alpha x^2}$。该方法涉及通过统计抽样的方式，数值计算哈密顿量的期望值，该期望值表示为对构型空间的积分。所有组成部分——哈密顿量、试探波函数、变分能量泛函 $E(\\alpha)$ 的定义，以及将其重构为局域能量 $E_L(x; \\alpha)$ 的期望值——都是标准且科学合理的。参数和目标都以足够的精度指定，且没有内部矛盾。因此，该问题被认为是 **有效的**，可以构建解决方案。\n\n该方法的核心是为一组变分参数 $\\alpha$ 计算变分能量 $E(\\alpha)$。此能量定义为局域能量 $E_L(x;\\alpha)$ 在概率分布 $\\rho_\\alpha(x) \\propto |\\psi_T(x,\\alpha)|^2$ 上的期望值。\n\n首先，我们必须推导局域能量 $E_L(x;\\alpha)$ 的解析表达式。局域能量定义为：\n$$\nE_L(x;\\alpha) = \\frac{\\hat{H}\\psi_T(x,\\alpha)}{\\psi_T(x,\\alpha)}\n$$\n哈密顿量为 $\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + \\frac{1}{2} m \\omega^2 x^2$。试探波函数为 $\\psi_T(x,\\alpha) = e^{-\\alpha x^2}$。我们计算 $\\psi_T$ 的必要导数：\n$$\n\\frac{d\\psi_T}{dx} = -2\\alpha x e^{-\\alpha x^2}\n$$\n$$\n\\frac{d^2\\psi_T}{dx^2} = \\frac{d}{dx}(-2\\alpha x e^{-\\alpha x^2}) = -2\\alpha e^{-\\alpha x^2} + 4\\alpha^2 x^2 e^{-\\alpha x^2} = (4\\alpha^2 x^2 - 2\\alpha)e^{-\\alpha x^2}\n$$\n将哈密顿算符 $\\hat{H}$ 应用于 $\\psi_T$ 可得：\n$$\n\\hat{H}\\psi_T(x,\\alpha) = -\\frac{\\hbar^2}{2m}(4\\alpha^2 x^2 - 2\\alpha)e^{-\\alpha x^2} + \\frac{1}{2} m \\omega^2 x^2 e^{-\\alpha x^2}\n$$\n$$\n\\hat{H}\\psi_T(x,\\alpha) = \\left(\\frac{\\hbar^2\\alpha}{m} - \\frac{2\\hbar^2\\alpha^2}{m} x^2 + \\frac{1}{2} m \\omega^2 x^2 \\right) e^{-\\alpha x^2}\n$$\n除以 $\\psi_T(x,\\alpha) = e^{-\\alpha x^2}$ 得到局域能量：\n$$\nE_L(x;\\alpha) = \\frac{\\hbar^2\\alpha}{m} + \\left(\\frac{1}{2} m \\omega^2 - \\frac{2\\hbar^2\\alpha^2}{m}\\right)x^2\n$$\n根据问题陈述，我们在 $\\hbar = 1$ 的自然单位制下工作。表达式简化为：\n$$\nE_L(x;\\alpha) = \\frac{\\alpha}{m} + \\left(\\frac{1}{2} m \\omega^2 - \\frac{2\\alpha^2}{m}\\right)x^2\n$$\n这就是要在抽样位置 $x$ 处求值的函数。\n\n接下来，我们讨论抽样过程。变分能量 $E(\\alpha)$ 是 $E_L(x;\\alpha)$ 关于概率密度 $\\rho_\\alpha(x) \\propto |\\psi_T(x,\\alpha)|^2 = e^{-2\\alpha x^2}$ 的期望值。该密度函数对应于均值 $\\mu = 0$ 的正态（高斯）分布。正态分布 $N(\\mu, \\sigma^2)$ 的概率密度函数为 $\\frac{1}{\\sqrt{2\\pi\\sigma^2}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$。比较 $\\mu=0$ 时的指数项：\n$$\n-2\\alpha x^2 = -\\frac{x^2}{2\\sigma^2}\n$$\n由此，我们推导出抽样分布的方差：$2\\alpha = \\frac{1}{2\\sigma^2}$，这意味着 $\\sigma^2 = \\frac{1}{4\\alpha}$。因此，标准差为 $\\sigma = \\frac{1}{2\\sqrt{\\alpha}}$。这是一个关键结果：为了从 $\\rho_\\alpha(x)$ 中抽样，必须从均值为 $0$、标准差为 $\\frac{1}{2\\sqrt{\\alpha}}$ 的正态分布中生成随机数。\n\n对于给定的测试用例 $(m, \\omega, \\alpha_{\\min}, \\alpha_{\\max}, N_\\alpha, N_{\\text{samples}}, \\text{seed})$，解决该问题的数值算法如下：\n$1$. 在区间 $[\\alpha_{\\min}, \\alpha_{\\max}]$ 上构建一个包含 $N_\\alpha$ 个参数 $\\alpha$ 值的均匀网格。\n$2$. 对该网格上的每个 $\\alpha$ 值，估算其变分能量 $E(\\alpha)$。\n$3$. 为了估算 $E(\\alpha)$，从正态分布 $N(\\mu=0, \\sigma^2 = 1/(4\\alpha))$ 中抽取 $N_{\\text{samples}}$ 个独立随机变量 $\\{x_i\\}$。\n$4$. 对每个样本 $x_i$，使用推导出的公式计算局域能量 $E_L(x_i; \\alpha)$。\n$5$. 变分能量的估计值是这些局域能量的算术平均值：\n$$\nE(\\alpha) \\approx \\bar{E}(\\alpha) = \\frac{1}{N_{\\text{samples}}} \\sum_{i=1}^{N_{\\text{samples}}} E_L(x_i; \\alpha)\n$$\n$6$. 计算完网格上所有 $\\alpha$ 的 $\\bar{E}(\\alpha)$ 后，找出产生最小能量 $\\bar{E}(\\alpha_{\\text{opt}})$ 的 $\\alpha_{\\text{opt}}$ 值。\n$7$. 数对 $[\\alpha_{\\text{opt}}, \\bar{E}(\\alpha_{\\text{opt}})]$ 构成该测试用例的结果。\n\n实现将利用 `numpy` 库进行高效的数组操作及其随机数生成器。为每个测试用例创建一个独立的随机数生成器实例，并使用提供的种子值进行初始化，以确保可复现性。最终的数值结果，即 $\\alpha_{\\text{opt}}$ 及其对应的能量，按要求四舍五入到 $6$ 位小数。整个过程是使用基本统计方法对变分原理的直接而稳健的实现。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(m, w, alpha_min, alpha_max, N_alpha, N_samples, seed):\n    \"\"\"\n    Performs Variational Monte Carlo to find the optimal alpha and ground state energy.\n\n    Args:\n        m (float): Mass of the particle.\n        w (float): Angular frequency of the oscillator.\n        alpha_min (float): Minimum of the alpha search range.\n        alpha_max (float): Maximum of the alpha search range.\n        N_alpha (int): Number of grid points for alpha.\n        N_samples (int): Number of samples for Monte Carlo integration.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A two-element list containing the optimal alpha and the minimum energy.\n    \"\"\"\n    # Initialize a random number generator for reproducibility for this case\n    rng = np.random.default_rng(seed)\n\n    # Create the grid of alpha values\n    alpha_grid = np.linspace(alpha_min, alpha_max, N_alpha)\n\n    # Array to store the estimated energies for each alpha\n    estimated_energies = np.empty(N_alpha)\n\n    # Loop over each alpha in the grid\n    for i, alpha in enumerate(alpha_grid):\n        # The sampling distribution is a normal distribution N(0, sigma^2)\n        # where the variance sigma^2 = 1 / (4*alpha).\n        # The standard deviation is sigma = 1 / (2 * sqrt(alpha)).\n        sigma = 1.0 / (2.0 * np.sqrt(alpha))\n\n        # Generate N_samples from the normal distribution\n        x_samples = rng.normal(loc=0.0, scale=sigma, size=N_samples)\n\n        # Calculate the local energy for each sample.\n        # The expression for local energy E_L with hbar = 1 is:\n        # E_L(x;alpha) = alpha/m + (0.5*m*w^2 - 2*alpha^2/m) * x^2\n        # This is computed in a vectorized way for efficiency.\n        kinetic_term = alpha / m\n        potential_term_coeff = 0.5 * m * w**2 - 2.0 * alpha**2 / m\n        local_energies = kinetic_term + potential_term_coeff * np.square(x_samples)\n\n        # The estimated energy E(alpha) is the mean of the local energies\n        estimated_energies[i] = np.mean(local_energies)\n\n    # Find the index of the minimum energy on the grid\n    min_energy_idx = np.argmin(estimated_energies)\n\n    # The optimal alpha and corresponding minimum energy are at that index\n    alpha_opt = alpha_grid[min_energy_idx]\n    min_energy = estimated_energies[min_energy_idx]\n\n    return [alpha_opt, min_energy]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (m, omega, alpha_min, alpha_max, N_alpha, N_samples, seed)\n    test_cases = [\n        (1.0, 1.0, 0.2, 1.0, 41, 50000, 12345),\n        (2.0, 0.5, 0.2, 0.9, 36, 50000, 24680),\n        (0.5, 3.0, 0.3, 1.2, 46, 50000, 98765),\n        (1.0, 2.0, 0.5, 1.5, 26, 5000, 13579)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        all_results.append(result)\n\n    # Format the final output string according to the specification:\n    # [[alpha1,E1],[alpha2,E2],...] with no spaces and 6 decimal places.\n    output_parts = [f\"[{alpha:.6f},{energy:.6f}]\" for alpha, energy in all_results]\n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2431867"}]}