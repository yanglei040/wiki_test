{"hands_on_practices": [{"introduction": "要真正掌握 Hartree-Fock (HF) 方法，最好的起点莫过于一次“纸上谈兵”的计算。这个练习将引导你手动计算氦（He）原子在极小基组下的能量，让你亲手构建 Fock 矩阵并应用 RHF 的核心方程 [@problem_id:2400276]。通过这个基础实践，你不仅能加深对 Fock 算符、密度矩阵和总能表达式的理解，还能为你后续编写更复杂的计算程序奠定坚实的直观基础。", "problem": "考虑一个孤立的氦原子，其核电荷为 $Z=2$。使用闭壳层限制性哈特里–福克 (RHF) 自洽场 (SCF) 方法，在由单个归一化 $1s$ 型函数 $\\chi_{1}$ 组成的最小斯莱特型轨道收缩3个高斯函数 (STO-3G) 原子轨道基组中进行处理。计算在哈特里原子单位下进行，其中 $\\hbar = m_e = e = 4\\pi \\varepsilon_0 = 1$，并假设基组是标准正交的，即 $S_{11}=1$。该体系有两个电子占据同一个空间轨道。\n\n给定以下关于原子轨道 $\\chi_{1}$ 的单电子和双电子积分：\n- 单电子（核心）积分：$h_{11}=\\langle \\chi_{1} | \\hat{T} + \\hat{V}_{\\text{ne}} | \\chi_{1} \\rangle = -2.038$。\n- 双电子库仑积分：$(11|11)=\\langle \\chi_{1}\\chi_{1} | r_{12}^{-1} | \\chi_{1}\\chi_{1} \\rangle = 1.216$。\n\n仅使用限制性哈特里–福克理论形式，利用这些数据手动构建福克矩阵元 $F_{11}$，然后计算氦原子在该基组下的总RHF电子能量 $E$。以Hartree为单位表示最终能量，并将答案四舍五入到四位有效数字。你最终报告的结果必须是一个单一的数字。", "solution": "本题要求计算氦原子在最小STO-3G基组下的总限制性哈特里–福克 (RHF) 电子能量。该问题定义明确且具有科学依据。所有必要的数据均已提供。\n\n该体系是一个有 $N=2$ 个电子的闭壳层原子。两个电子都占据同一个空间轨道，我们将其表示为 $\\psi_{1}$。这个空间轨道是作为原子轨道的线性组合 (LCAO) 构建的。在这种情况下，基组是最小的，仅由一个归一化的 $1s$ 型函数 $\\chi_{1}$ 组成。因此，展开是平凡的：\n$$ \\psi_{1} = c_{11} \\chi_{1} $$\n空间轨道的归一化条件是 $\\langle \\psi_1 | \\psi_1 \\rangle = 1$。展开后得到：\n$$ \\langle c_{11} \\chi_{1} | c_{11} \\chi_{1} \\rangle = |c_{11}|^2 \\langle \\chi_{1} | \\chi_{1} \\rangle = |c_{11}|^2 S_{11} = 1 $$\n我们已知基组是标准正交的，意味着重叠矩阵元 $S_{11} = 1$。这意味着 $|c_{11}|^2 = 1$。我们可以选择实数且为正的系数 $c_{11}=1$，这意味着空间轨道与基函数相同：\n$$ \\psi_{1} = \\chi_{1} $$\n第一步是构建福克矩阵。对于闭壳层RHF计算，福克矩阵 $\\mathbf{F}$ 的元素由以下公式给出：\n$$ F_{\\mu\\nu} = h_{\\mu\\nu} + \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda|\\nu\\sigma) \\right] $$\n其中 $h_{\\mu\\nu}$ 是单电子（核心）积分，$(\\mu\\nu|\\lambda\\sigma)$ 是双电子排斥积分，而 $P_{\\lambda\\sigma}$ 是密度矩阵的元素。指标 $\\mu, \\nu, \\lambda, \\sigma$ 指的是基函数。在本问题中，我们只有一个基函数 $\\chi_{1}$，所以所有指标都必须是 $1$。\n\n密度矩阵元素 $P_{\\lambda\\sigma}$ 定义为：\n$$ P_{\\lambda\\sigma} = 2 \\sum_{i=1}^{N/2} c_{\\lambda i}^{*} c_{\\sigma i} $$\n其中求和是对已占据的空间轨道进行的。这里，我们有一个已占据的轨道（$i=1$），包含 $N=2$ 个电子，并且系数为 $c_{11}=1$。因此，唯一非零的密度矩阵元素是：\n$$ P_{11} = 2 c_{11}^{*} c_{11} = 2(1)(1) = 2 $$\n现在我们可以构建福克矩阵的单个元素 $F_{11}$：\n$$ F_{11} = h_{11} + \\sum_{\\lambda=1} \\sum_{\\sigma=1} P_{\\lambda\\sigma} \\left[ (11|\\lambda\\sigma) - \\frac{1}{2}(1\\lambda|1\\sigma) \\right] $$\n当 $\\lambda=1$ 和 $\\sigma=1$ 时，表达式简化为：\n$$ F_{11} = h_{11} + P_{11} \\left[ (11|11) - \\frac{1}{2}(11|11) \\right] = h_{11} + \\frac{1}{2} P_{11} (11|11) $$\n代入 $P_{11}=2$：\n$$ F_{11} = h_{11} + \\frac{1}{2}(2)(11|11) = h_{11} + (11|11) $$\n我们已知积分值为 $h_{11} = -2.038$ 和 $(11|11) = 1.216$。现在我们可以计算 $F_{11}$ 的数值：\n$$ F_{11} = -2.038 + 1.216 = -0.822 $$\n下一步是计算总RHF电子能量 $E$。用密度矩阵和福克矩阵表示总能量的通用公式是：\n$$ E = \\frac{1}{2} \\sum_{\\mu\\nu} P_{\\mu\\nu} (h_{\\mu\\nu} + F_{\\mu\\nu}) $$\n对于我们的最小基组体系，此求和化简为一项：\n$$ E = \\frac{1}{2} P_{11} (h_{11} + F_{11}) $$\n代入已知的 $P_{11}$、$h_{11}$ 的值以及计算出的 $F_{11}$ 的值：\n$$ E = \\frac{1}{2} (2) (-2.038 + (-0.822)) = 1 \\times (-2.860) = -2.860 $$\n总电子能量为 $E = -2.860$ Hartree。\n\n或者，对于一个在单个空间轨道 $\\psi_1$ 中的双电子体系，总能量由电子哈密顿量的期望值给出：\n$$ E = \\langle \\Psi | \\hat{H}_{\\text{el}} | \\Psi \\rangle $$\n其中斯莱特行列式为 $\\Psi = \\frac{1}{\\sqrt{2}}|\\psi_1\\alpha \\psi_1\\beta|$ 且 $\\hat{H}_{\\text{el}} = \\hat{h}_1 + \\hat{h}_2 + r_{12}^{-1}$。计算结果为：\n$$ E = 2 \\langle \\psi_1 | \\hat{h} | \\psi_1 \\rangle + \\langle \\psi_1 \\psi_1 | r_{12}^{-1} | \\psi_1 \\psi_1 \\rangle $$\n由于 $\\psi_1 = \\chi_1$，这变为：\n$$ E = 2 h_{11} + (11|11) $$\n代入给定值：\n$$ E = 2(-2.038) + 1.216 = -4.076 + 1.216 = -2.860 $$\n两种方法得到相同的结果。题目要求答案保留四位有效数字。结果 $-2.860$ 已经有四位有效数字。", "answer": "$$\n\\boxed{-2.860}\n$$", "id": "2400276"}, {"introduction": "在手动推导了基本方程之后，下一步自然是将这些数学公式转化为一个可以工作的计算机程序。本实践要求你从零开始实现限制性 (RHF) 和非限制性 (UHF) Hartree-Fock 的自洽场 (SCF) 求解器 [@problem_id:2400234]。通过对一个闭壳层体系同时进行 RHF 和 UHF 计算，你将能够通过数值结果验证一个核心概念：对于没有自旋极化的体系，更普适的 UHF 方法会自然地收敛到更简洁的 RHF 解。", "problem": "从第一性原理出发，实现一个自洽场（Self-Consistent Field, SCF）求解器，该求解器需同时支持限制性哈特里-福克（Restricted Hartree–Fock, RHF）和非限制性哈特里-福克（Unrestricted Hartree–Fock, UHF）方法。该求解器用于处理一个闭壳层、双电子的原子或离子体系。该体系具有一个位于坐标原点的点核，电荷为 $Z$，所有计算均在原子单位下进行。使用一组固定的、实数的、归一化的、共同中心于原子核的 $s$ 型高斯基函数。每个基函数由一个正指数 $\\alpha_i$ 定义，其空间形式为 $\\phi_i(\\mathbf{r}) = \\mathcal{N}(\\alpha_i)\\,e^{-\\alpha_i r^2}$，其中 $r = \\lVert \\mathbf{r} \\rVert$，而 $\\mathcal{N}(\\alpha_i)$ 是归一化常数。体系的总电子数为 $N_{\\mathrm{e}} = 2$，其中自旋向上和自旋向下的电子数分别为 $N_{\\alpha} = 1$ 和 $N_{\\beta} = 1$。所有计算必须在原子单位下执行。由于只有一个原子核，经典的核-核排斥能为零。\n\n令单电子哈密顿算符为 $\\hat{h} = -\\frac{1}{2}\\nabla^2 - \\frac{Z}{r}$。使用它们的定义表达式构建所有的单电子积分和双电子排斥积分：\n- 重叠积分 $S_{ij} = \\int \\phi_i(\\mathbf{r})\\,\\phi_j(\\mathbf{r})\\,\\mathrm{d}^3 \\mathbf{r}$。\n- 动能积分 $T_{ij} = \\int \\phi_i(\\mathbf{r})\\left(-\\frac{1}{2}\\nabla^2\\right)\\phi_j(\\mathbf{r})\\,\\mathrm{d}^3 \\mathbf{r}$。\n- 核吸引积分 $V_{ij} = \\int \\phi_i(\\mathbf{r})\\left(-\\frac{Z}{r}\\right)\\phi_j(\\mathbf{r})\\,\\mathrm{d}^3 \\mathbf{r}$。\n- 化学家记法下的双电子积分 $(ij|kl) = \\int\\int \\phi_i(\\mathbf{r}_1)\\phi_j(\\mathbf{r}_1)\\frac{1}{\\lVert \\mathbf{r}_1 - \\mathbf{r}_2 \\rVert}\\phi_k(\\mathbf{r}_2)\\phi_l(\\mathbf{r}_2)\\,\\mathrm{d}^3 \\mathbf{r}_1\\,\\mathrm{d}^3 \\mathbf{r}_2$。\n\n使用这些积分来构成核心哈密顿矩阵 $h_{ij} = T_{ij} + V_{ij}$、重叠矩阵 $S_{ij}$ 和电子排斥积分张量 $(ij|kl)$。\n\n在原子轨道基组下构建RHF和UHF的SCF方程。在 RHF 方法中，对闭壳层构型使用一个与自旋无关的福克矩阵（Fock matrix）和一个无自旋的密度矩阵。在 UHF 方法中，构建独立的 $\\alpha$ 和 $\\beta$ 福克矩阵及密度矩阵，其中交换算符仅在相同自旋通道内作用。求解关于重叠度规的福克矩阵的广义本征值问题，以获得正则分子轨道和轨道能量。迭代直至密度矩阵收敛。\n\n对于每个测试用例，在收敛后：\n- 计算收敛后的 $\\alpha$ 和 $\\beta$ 密度矩阵之间矩阵元素的最大绝对差，即 $\\max_{i,j}\\lvert P^{\\alpha}_{ij} - P^{\\beta}_{ij} \\rvert$。\n- 计算收敛后的 $\\alpha$ 和 $\\beta$ 轨道能量之间的最大绝对差，即 $\\max_k \\lvert \\varepsilon^{\\alpha}_k - \\varepsilon^{\\beta}_k \\rvert$。\n- 计算收敛后的总 UHF 和 RHF 能量之间的绝对差（单位为 Hartree），即 $\\lvert E_{\\mathrm{UHF}} - E_{\\mathrm{RHF}} \\rvert$。\n\n所有能量值均以 Hartree 为单位表示，并将每个测试用例的这三个量以实数形式报告。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个结果本身是一个包含上述三个浮点数的列表，顺序如上所述，例如：\"[[x11,x12,x13],[x21,x22,x23],...]\"，不含额外的空格或文本。\n\n使用以下包含三组参数的测试套件，每组由一个核电荷 $Z$ 和一个高斯指数列表 $\\{\\alpha_i\\}$ 指定：\n1. $Z = 2$, $\\{\\alpha\\} = [0.50]$。\n2. $Z = 2$, $\\{\\alpha\\} = [0.20, 0.80]$。\n3. $Z = 3$, $\\{\\alpha\\} = [0.15, 0.50, 1.20]$。\n\n程序必须根据上述定义实现 SCF 过程，并为该测试套件生成所要求的输出。对于这些闭壳层体系，预期的物理行为是，非限制性哈特里-福克（UHF）解会塌缩到限制性哈特里-福克（RHF）解，从而得到相同的 $\\alpha$ 和 $\\beta$ 轨道及能量；您的数值结果应通过返回在合理容差范围内与零在数值上无法区分的值来反映这一点。所有角度（如果出现）必须以弧度为单位。所有能量必须以 Hartree 为单位报告，在输出字符串中为不带单位的浮点数。", "solution": "该问题已经过验证，并被确认为有效。这是一个计算量子物理学中定义明确的问题，基于已建立的科学原理（Hartree-Fock 理论），并为其求解提供了所有必要信息。问题中不存在矛盾、歧义或事实性错误。任务是从第一性原理出发，为一个双电子原子系统实现限制性和非限制性哈特里-福克自洽场（SCF）方法。\n\n### 1. 理论框架\n\n所考虑的体系是一个具有核电荷 $Z$ 的双电子原子或离子，其电子哈密顿量在原子单位下为：\n$$\n\\hat{H} = \\sum_{i=1}^{2} \\left( -\\frac{1}{2}\\nabla_i^2 - \\frac{Z}{r_i} \\right) + \\frac{1}{r_{12}} = \\sum_{i=1}^{2} \\hat{h}(i) + \\frac{1}{r_{12}}\n$$\n其中 $\\hat{h}(i)$ 是电子 $i$ 的核心哈密顿量，$r_{12} = \\lVert \\mathbf{r}_1 - \\mathbf{r}_2 \\rVert$ 是电子间距离。对于单原子核，核-核排斥能为零。\n\n在 Hartree-Fock 近似中，多电子波函数被近似为单个斯莱特行列式（Slater determinant）。分子轨道（MOs），$\\psi_a$，表示为原子轨道（AOs），$\\phi_i$的线性组合：\n$$\n\\psi_a(\\mathbf{r}) = \\sum_{i=1}^{K} C_{ia} \\phi_i(\\mathbf{r})\n$$\n基函数 $\\{\\phi_i\\}$ 被指定为中心在原点的实数、归一化的 s 型高斯函数：\n$$\n\\phi_i(\\mathbf{r}) = \\mathcal{N}(\\alpha_i)\\,e^{-\\alpha_i r^2} = \\left(\\frac{2\\alpha_i}{\\pi}\\right)^{3/4} e^{-\\alpha_i r^2}\n$$\n其中 $\\alpha_i$ 是第 $i$ 个基函数的指数，$\\mathcal{N}(\\alpha_i)$ 是其归一化常数。\n\n### 2. 积分计算\n\nHartree-Fock 方程的求解需要计算高斯基函数上的单电子和双电子积分。对于中心在原点的 s 型高斯函数，这些积分有解析的闭合形式表达式。\n\n- **重叠积分 ($S_{ij}$)**：\n$$\nS_{ij} = \\int \\phi_i(\\mathbf{r}) \\phi_j(\\mathbf{r}) d^3\\mathbf{r} = \\left( \\frac{2\\sqrt{\\alpha_i\\alpha_j}}{\\alpha_i+\\alpha_j} \\right)^{3/2}\n$$\n\n- **动能积分 ($T_{ij}$)**：\n$$\nT_{ij} = \\int \\phi_i(\\mathbf{r}) \\left(-\\frac{1}{2}\\nabla^2\\right) \\phi_j(\\mathbf{r}) d^3\\mathbf{r} = \\frac{3\\alpha_i\\alpha_j}{\\alpha_i+\\alpha_j} S_{ij}\n$$\n\n- **核吸引积分 ($V_{ij}$)**：\n$$\nV_{ij} = \\int \\phi_i(\\mathbf{r}) \\left(-\\frac{Z}{r}\\right) \\phi_j(\\mathbf{r}) d^3\\mathbf{r} = -Z \\mathcal{N}(\\alpha_i)\\mathcal{N}(\\alpha_j) \\frac{2\\pi}{\\alpha_i+\\alpha_j} = -Z \\frac{2\\left(4\\alpha_i\\alpha_j\\right)^{3/4}}{\\sqrt{\\pi}(\\alpha_i+\\alpha_j)}\n$$\n\n- **双电子排斥积分 (ERI) ($ij|kl$)**:\n$$\n(ij|kl) = \\iint \\phi_i(\\mathbf{r}_1)\\phi_j(\\mathbf{r}_1) \\frac{1}{r_{12}} \\phi_k(\\mathbf{r}_2)\\phi_l(\\mathbf{r}_2) d^3\\mathbf{r}_1 d^3\\mathbf{r}_2 = \\mathcal{N}_i\\mathcal{N}_j\\mathcal{N}_k\\mathcal{N}_l \\frac{2\\pi^{5/2}}{(\\alpha_i+\\alpha_j)(\\alpha_k+\\alpha_l)\\sqrt{\\alpha_i+\\alpha_j+\\alpha_k+\\alpha_l}}\n$$\n其中 $\\mathcal{N}_i, \\mathcal{N}_j, \\mathcal{N}_k, \\mathcal{N}_l$ 分别是各自的归一化常数。\n\n核心哈密顿矩阵 $H_{\\mathrm{core}}$ 是通过将动能积分矩阵和核吸引积分矩阵相加构建的：$H_{\\mathrm{core}} = T + V$。\n\n### 3. 自洽场 (SCF) 过程\n\nSCF 过程通过迭代方式优化分子轨道系数 $\\{C_{ia}\\}$ 的集合，直到电子能量和密度矩阵收敛。\n\n**A. 闭壳层体系的限制性哈特里-福克 (RHF)**\n\n对于闭壳层体系 ($N_\\alpha = N_\\beta$)，RHF 对自旋向上和自旋向下的电子使用同一套空间轨道。该电子态有 $N_e/2$ 个双占据轨道。其核心方程是 Roothaan-Hall 方程：\n$$\nFC = SCE\n$$\n其中 $F$ 是福克矩阵， $C$ 是分子轨道系数矩阵， $S$ 是原子轨道重叠矩阵， $E$ 是轨道能量 $\\varepsilon_a$ 的对角矩阵。福克矩阵由下式给出：\n$$\nF = H_{\\mathrm{core}} + G(D)\n$$\n矩阵 $G$ 表示平均双电子势，其元素为：\n$$\nG_{ij} = \\sum_{k,l} D_{kl} \\left[ 2(ij|kl) - (ik|jl) \\right]\n$$\n这里，$D$ 是无自旋密度矩阵，由 $N_e/2$ 个占据轨道的分子轨道系数定义：\n$$\nD_{kl} = \\sum_{a=1}^{N_e/2} C_{ka} C_{la}^*\n$$\n总 RHF 电子能量由下式给出：\n$$\nE_{\\mathrm{RHF}} = \\sum_{i,j} D_{ij} (H_{\\mathrm{core},ij} + F_{ij}) = \\mathrm{Tr}[D(H_{\\mathrm{core}} + F)]\n$$\n\n**B. 非限制性哈特里-福克 (UHF)**\n\nUHF 允许自旋向上 ($\\alpha$) 和自旋向下 ($\\beta$) 的电子使用不同的空间轨道。这导致了两个耦合的 Roothaan-Hall 方程：\n$$\nF^\\alpha C^\\alpha = S C^\\alpha E^\\alpha \\quad \\text{和} \\quad F^\\beta C^\\beta = S C^\\beta E^\\beta\n$$\n每个自旋的福克矩阵为：\n$$\nF^\\sigma = H_{\\mathrm{core}} + J(P^T) - K(P^\\sigma) \\quad (\\sigma = \\alpha, \\beta)\n$$\n其中 $P^\\alpha$ 和 $P^\\beta$ 分别是 $\\alpha$ 和 $\\beta$ 电子的密度矩阵，$P^T = P^\\alpha + P^\\beta$ 是总密度矩阵。库仑 ($J$) 和交换 ($K$) 矩阵的元素为：\n$$\nJ_{ij} = \\sum_{k,l} P^T_{lk} (ij|kl) \\qquad (K^\\sigma)_{ij} = \\sum_{k,l} P^\\sigma_{lk} (ik|jl)\n$$\n自旋密度矩阵由各自的分子轨道系数构建：\n$$\nP^\\alpha_{kl} = \\sum_{a=1}^{N_\\alpha} C^\\alpha_{ka} (C^\\alpha_{la})^* \\qquad P^\\beta_{kl} = \\sum_{a=1}^{N_\\beta} C^\\beta_{ka} (C^\\beta_{la})^*\n$$\n总 UHF 电子能量为：\n$$\nE_{\\mathrm{UHF}} = \\frac{1}{2}\\sum_{i,j} \\left[ (P^\\alpha+P^\\beta)_{ji} H_{\\mathrm{core},ij} + P^\\alpha_{ji}F^\\alpha_{ij} + P^\\beta_{ji}F^\\beta_{ij} \\right] = \\frac{1}{2} \\left(\\mathrm{Tr}[P^T H_{\\mathrm{core}}] + \\mathrm{Tr}[P^\\alpha F^\\alpha] + \\mathrm{Tr}[P^\\beta F^\\beta] \\right)\n$$\n\n### 4. 算法实现\n\nRHF 和 UHF 都通过迭代法求解：\n1.  **计算积分**：计算并存储所有单电子（$S, T, V$）和双电子（$ij|kl$）积分。构成 $H_{\\mathrm{core}}$。\n2.  **初始猜测**：通过对角化核心哈密顿量来获得密度矩阵的初始猜测。求解广义本征值问题 $H_{\\mathrm{core}}C = SCE$，并使用对应于最低能量的分子轨道来构建初始密度矩阵。对于 UHF，初始猜测是对称的，$P^\\alpha_0 = P^\\beta_0$。\n3.  **SCF 循环**：\n    a. 使用当前的密度矩阵构建福克矩阵（对于 UHF 则是多个矩阵）。\n    b. 求解广义本征值问题 $FC=SCE$ 以获得新的分子轨道系数和轨道能量。\n    c. 根据占据轨道（RHF 为 $N_e/2=1$，UHF 为 $N_\\alpha=1, N_\\beta=1$）的分子轨道系数形成新的密度矩阵。\n    d. 检查收敛性。如果两次迭代之间密度矩阵元素的最大绝对变化小于某个阈值（例如 $10^{-9}$），则停止过程。\n    e. 如果未收敛，将新旧密度矩阵混合以帮助稳定，并重复循环。\n4.  **后 SCF**：一旦收敛，计算总电子能量和所需的可观测量。对于指定的闭壳层体系，UHF 解预期会塌缩到 RHF 解，意味着 $P^\\alpha \\approx P^\\beta$，$\\varepsilon^\\alpha_k \\approx \\varepsilon^\\beta_k$，以及 $E_{\\mathrm{UHF}} \\approx E_{\\mathrm{RHF}}$。程序将计算这些量之间的最大绝对差。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh, inv, sqrtm\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'Z': 2, 'alphas': [0.50]},\n        {'Z': 2, 'alphas': [0.20, 0.80]},\n        {'Z': 3, 'alphas': [0.15, 0.50, 1.20]},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        Z = case['Z']\n        alphas = np.array(case['alphas'])\n        num_basis = len(alphas)\n        n_elec = 2\n        n_alpha = 1\n        n_beta = 1\n\n        # 1. Compute integrals\n        S, T, V, eri = compute_integrals(alphas, Z)\n        H_core = T + V\n\n        # 2. Run RHF and UHF\n        rhf_E, D_conv, _ = run_rhf(H_core, eri, S, n_elec, num_basis)\n        uhf_E, P_alpha_conv, P_beta_conv, eps_alpha, eps_beta = run_uhf(\n            H_core, eri, S, n_alpha, n_beta, num_basis\n        )\n\n        # 3. Compute final quantities\n        diff_P = np.max(np.abs(P_alpha_conv - P_beta_conv))\n        diff_eps = np.max(np.abs(eps_alpha - eps_beta))\n        diff_E = np.abs(uhf_E - rhf_E)\n        \n        all_results.append([diff_P, diff_eps, diff_E])\n    \n    # Format output as specified: \"[[x11,x12,x13],[x21,x22,x23],...]\"\n    result_str = \",\".join([f\"[{v[0]},{v[1]},{v[2]}]\" for v in all_results])\n    print(f\"[{result_str}]\")\n\n\ndef compute_integrals(alphas, Z):\n    \"\"\"\n    Computes all one- and two-electron integrals for s-type Gaussians at the origin.\n    \"\"\"\n    num_basis = len(alphas)\n    S = np.zeros((num_basis, num_basis))\n    T = np.zeros((num_basis, num_basis))\n    V = np.zeros((num_basis, num_basis))\n    eri = np.zeros((num_basis, num_basis, num_basis, num_basis))\n\n    # One-electron integrals\n    for i in range(num_basis):\n        for j in range(num_basis):\n            alpha_i = alphas[i]\n            alpha_j = alphas[j]\n            \n            # Overlap\n            S[i, j] = (2 * np.sqrt(alpha_i * alpha_j) / (alpha_i + alpha_j))**1.5\n            \n            # Kinetic\n            T[i, j] = 3 * alpha_i * alpha_j / (alpha_i + alpha_j) * S[i, j]\n            \n            # Nuclear Attraction\n            term1 = 2 * (4 * alpha_i * alpha_j)**0.75\n            term2 = np.sqrt(np.pi) * (alpha_i + alpha_j)\n            V[i, j] = -Z * term1 / term2\n    \n    # Two-electron integrals (ERI)\n    for i in range(num_basis):\n        for j in range(num_basis):\n            for k in range(num_basis):\n                for l in range(num_basis):\n                    alpha_i, alpha_j, alpha_k, alpha_l = alphas[i], alphas[j], alphas[k], alphas[l]\n                    p = alpha_i + alpha_j\n                    q = alpha_k + alpha_l\n                    \n                    term1 = 16 * (alpha_i * alpha_j * alpha_k * alpha_l)**0.75\n                    term2 = np.sqrt(np.pi) * p * q * np.sqrt(p + q)\n                    eri[i, j, k, l] = term1 / term2\n    \n    return S, T, V, eri\n\n\ndef run_rhf(H_core, eri, S, n_elec, num_basis):\n    \"\"\"\n    Performs the RHF-SCF calculation.\n    \"\"\"\n    max_iter = 100\n    conv_tol = 1e-9\n    mixing_alpha = 0.5\n    n_occ = n_elec // 2\n\n    # Initial guess\n    _, C = eigh(H_core, S)\n    D = C[:, :n_occ] @ C[:, :n_occ].T\n\n    for i in range(max_iter):\n        D_old = D.copy()\n        \n        # Build G matrix\n        J = np.einsum('kl,ijkl->ij', D, eri)\n        K = np.einsum('kl,ikjl->ij', D, eri)\n        G = 2 * J - K\n        \n        # Form Fock matrix\n        F = H_core + G\n        \n        # Solve Roothaan-Hall equations\n        eps, C = eigh(F, S)\n        \n        # Form new density matrix\n        D = C[:, :n_occ] @ C[:, :n_occ].T\n        \n        # Damping/Mixing\n        D = (1 - mixing_alpha) * D_old + mixing_alpha * D\n        \n        # Check convergence\n        if np.max(np.abs(D - D_old)) < conv_tol:\n            break\n            \n    # Calculate final energy\n    E = np.sum(D * (H_core + F))\n    \n    return E, D, eps\n\n\ndef run_uhf(H_core, eri, S, n_alpha, n_beta, num_basis):\n    \"\"\"\n    Performs the UHF-SCF calculation.\n    \"\"\"\n    max_iter = 100\n    conv_tol = 1e-9\n    mixing_alpha = 0.5\n\n    # Initial guess (symmetric)\n    _, C = eigh(H_core, S)\n    P_alpha = C[:, :n_alpha] @ C[:, :n_alpha].T\n    P_beta = C[:, :n_beta] @ C[:, :n_beta].T\n\n    for i in range(max_iter):\n        P_alpha_old = P_alpha.copy()\n        P_beta_old = P_beta.copy()\n        \n        P_total = P_alpha + P_beta\n        \n        # Build J and K matrices\n        J = np.einsum('lk,ijkl->ij', P_total, eri)\n        K_alpha = np.einsum('lk,ikjl->ij', P_alpha, eri)\n        K_beta = np.einsum('lk,ikjl->ij', P_beta, eri)\n        \n        # Form Fock matrices\n        F_alpha = H_core + J - K_alpha\n        F_beta = H_core + J - K_beta\n        \n        # Solve Roothaan-Hall equations for each spin\n        eps_alpha, C_alpha = eigh(F_alpha, S)\n        eps_beta, C_beta = eigh(F_beta, S)\n        \n        # Form new density matrices\n        P_alpha = C_alpha[:, :n_alpha] @ C_alpha[:, :n_alpha].T\n        P_beta = C_beta[:, :n_beta] @ C_beta[:, :n_beta].T\n        \n        # Damping/Mixing\n        P_alpha = (1 - mixing_alpha) * P_alpha_old + mixing_alpha * P_alpha\n        P_beta = (1 - mixing_alpha) * P_beta_old + mixing_alpha * P_beta\n        \n        # Check convergence\n        delta = max(np.max(np.abs(P_alpha - P_alpha_old)), \n                    np.max(np.abs(P_beta - P_beta_old)))\n        if delta < conv_tol:\n            break\n            \n    # Calculate final energy\n    E = 0.5 * (np.sum(P_total * H_core) + np.sum(P_alpha * F_alpha) + np.sum(P_beta * F_beta))\n    \n    return E, P_alpha, P_beta, eps_alpha, eps_beta\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2400234"}, {"introduction": "拥有一个基本的 SCF 求解器后，你将很快发现在某些情况下，简单的迭代过程可能难以收敛，这是 SCF 计算中的一个常见挑战。本练习将向你介绍一种强大的收敛辅助技术——能级移动 (level shifting) [@problem_id:2400252]。通过对一个专门设计的“困难”体系应用该技术，你将探索它如何通过调整虚轨道的能量来稳定迭代过程，并最终让你掌握一个使计算工具更加稳健和可靠的重要方法。", "problem": "考虑一个闭壳层、限制性Hartree–Fock (RHF) 自洽场 (SCF) 问题，该问题在一个维度为 $2$ 的最小、正交归一的原子轨道基上求解（即，重叠矩阵为单位矩阵）。两个电子以双占据方式占据能量最低的分子轨道。单电子核心哈密顿矩阵 $H$（以Hartree原子单位）和以化学家记法 $(\\mu\\nu\\mid\\lambda\\sigma)$ 表示的非零双电子排斥积分如下所示：\n- 单电子矩阵 $H$（对称）：$H_{11}=0$，$H_{22}=0$，$H_{12}=H_{21}=0.05$（均以Hartree为单位）。\n- 唯一的非零双电子积分（以Hartree为单位），所有其他积分由置换对称性定义：\n  1. $(11\\mid 11)=0.7$,\n  2. $(22\\mid 22)=0.7$,\n  3. $(11\\mid 22)=(22\\mid 11)=0.6$,\n  4. $(12\\mid 12)=(21\\mid 21)=0.5$,\n  5. $(12\\mid 21)=(21\\mid 12)=0.2$.\n\n设自旋求和密度矩阵为 $P\\in\\mathbb{R}^{2\\times 2}$，由已占分子轨道列向量 $c_{\\text{occ}}\\in\\mathbb{R}^{2}$ 构造，表达式为 $P=2\\,c_{\\text{occ}}c_{\\text{occ}}^{\\mathsf{T}}$，其中 $\\lVert c_{\\text{occ}}\\rVert_2=1$。RHF Fock矩阵 $F$ 定义为\n$$\nF_{\\mu\\nu} \\;=\\; H_{\\mu\\nu} \\;+\\; \\sum_{\\lambda,\\sigma} P_{\\lambda\\sigma}\\,\\Big[(\\mu\\nu\\mid\\lambda\\sigma) \\;-\\; \\tfrac{1}{2}(\\mu\\lambda\\mid\\nu\\sigma)\\Big] \\quad \\text{for } \\mu,\\nu\\in\\{1,2\\}.\n$$\n\n能级移动的引入如下。给定一个能级移动参数 $\\Delta\\ge 0$，在每次SCF迭代中，利用上一次迭代得到的已占分子轨道，构成到虚轨道子空间的投影算符 $Q_{\\mathrm{virt}}=I - c_{\\text{occ}}c_{\\text{occ}}^{\\mathsf{T}}$，并构造一个能级移动后的Fock矩阵\n$$\nF^{(\\Delta)} \\;=\\; F \\;+\\; \\Delta\\,Q_{\\mathrm{virt}}.\n$$\n下一次迭代的已占分子轨道是 $F^{(\\Delta)}$ 的最小特征值对应的归一化特征向量。$c_{\\text{occ}}$ 的初始猜测是单电子矩阵 $H$ 的最小特征值对应的归一化特征向量。收敛的定义为 $\\max_{\\,\\mu,\\nu}\\lvert P_{\\mu\\nu}^{(k)}-P_{\\mu\\nu}^{(k-1)}\\rvert < \\tau$，其中 $P^{(k)}$ 是第 $k$ 次迭代的密度矩阵，容差 $\\tau=10^{-12}$。同时，施加 $M=200$ 次迭代的硬性上限；如果在 $M$ 次迭代内未达到收敛，则声明为不收敛。\n\n任务。对于每个指定的能级移动参数 $\\Delta$，执行上述定义的带能级移动的RHF SCF过程，并返回达到收敛所需的迭代次数；如果该过程在 $M$ 次迭代内不收敛，则为该情况返回整数 $-1$。\n\n使用以下能级移动参数测试套件（以Hartree为单位）：$\\Delta\\in\\{0.0,\\,0.3,\\,0.6,\\,1.0,\\,5.0\\}$。\n\n要求的最终输出格式。您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔的整数列表（例如，“[1,-1,3,2,1]”），其顺序与测试套件相同。这些整数代表收敛所需的迭代次数，其中 $-1$ 表示在 $M$ 次迭代内未收敛。所有内部能量均以Hartree为单位；迭代次数无单位。", "solution": "问题陈述经过了严格验证，被认为是科学上可靠、定义良好且没有矛盾或歧义的。它提出了一个标准的计算物理问题，涉及限制性Hartree–Fock (RHF) 自洽场 (SCF) 方法，并辅以能级移动技术来帮助收敛。因此，我们将继续提供完整的解答。\n\n该问题要求计算，对于一个双电子、双轨道模型体系，在给定一组能级移动参数 $\\Delta$ 的情况下，SCF过程收敛所需的迭代次数。陈述中指出基是正交归一的，这意味着重叠矩阵 $S$ 是单位矩阵，$S = I$。这将普适的Roothaan-Hall方程 $FC = SCE$ 简化为标准的特征值问题 $FC = CE$。\n\nRHF方法旨在为闭壳层分子的电子结构寻找一个自洽解。该方法的核心是Fock矩阵 $F$ 的迭代构建和对角化。Fock矩阵是一种有效的单电子哈密顿量，其中电子-电子相互作用以平均的、平均场的方式处理。其在原子轨道基中的矩阵元由所给公式给出：\n$$\nF_{\\mu\\nu} = H_{\\mu\\nu} + \\sum_{\\lambda,\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu\\mid\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda\\mid\\nu\\sigma) \\right]\n$$\n此处，$H$ 是核心哈密顿量，代表一个电子的动能和核吸引能。项 $(\\mu\\nu\\mid\\lambda\\sigma)$ 是化学家记法中的双电子排斥积分 (ERI)。$P$ 是自旋求和密度矩阵。对于一个具有 $N$ 个电子且这些电子处于双占据轨道的体系，$P$ 由已占分子轨道系数矩阵 $C_{\\text{occ}}$ 构造成 $P = 2C_{\\text{occ}}C_{\\text{occ}}^{\\dagger}$。在我们的情况下，只有一个由向量 $c_{\\text{occ}}$ 代表的已占分子轨道，因此表达式变为 $P = 2c_{\\text{occ}}c_{\\text{occ}}^{\\mathsf{T}}$。\n\nSCF过程如下：\n1.  **初始猜测**：需要一个对分子轨道（以及密度矩阵 $P$）的初始猜测。如题目所指定，一个标准的选择是对角化核心哈密顿量 $H$。将对应于最低特征值的特征向量作为初始的已占分子轨道 $c_{\\text{occ}}^{(0)}$。由此，构造初始密度矩阵 $P^{(0)}$。\n\n2.  **迭代精化**：该过程进入一个循环，每次迭代 $k$ 包括：\n    a. **构造Fock矩阵**：使用上一次迭代得到的密度矩阵 $P^{(k-1)}$ 构建一个新的Fock矩阵 $F^{(k-1)}$。\n    b. **应用能级移动**：使用能级移动方案修改Fock矩阵。该技术旨在改善或保证收敛，尤其是在容易出现振荡的情况下。构造一个到虚（未占）轨道空间的投影算符 $Q_{\\mathrm{virt}} = I - c_{\\text{occ}}^{(k-1)}(c_{\\text{occ}}^{(k-1)})^{\\mathsf{T}}$。然后，能级移动后的Fock矩阵为 $F^{(\\Delta)} = F^{(k-1)} + \\Delta\\,Q_{\\mathrm{virt}}$。这会在能量上对虚轨道施加大小为 $\\Delta$ 的惩罚，增大了已占和虚轨道特征值之间的能隙，从而稳定了计算过程。\n    c. **求解特征值问题**：对能级移动后的Fock矩阵 $F^{(\\Delta)}$ 进行对角化。对应于最低特征值的特征向量成为新的已占分子轨道 $c_{\\text{occ}}^{(k)}$。\n    d. **更新密度矩阵**：由 $c_{\\text{occ}}^{(k)}$ 构造一个新的密度矩阵 $P^{(k)}$。\n\n3.  **收敛检查**：重复该过程，直到连续迭代之间的密度矩阵变化小于指定的容差 $\\tau$。收敛条件由 $\\max_{\\mu,\\nu} \\left| P_{\\mu\\nu}^{(k)} - P_{\\mu\\nu}^{(k-1)} \\right| < \\tau$ 给出。如果在最大迭代次数 $M$ 内未达到收敛，则计算终止并被认为是不收敛的。\n\n具体的数值实现将涉及以下步骤：\n- 核心哈密顿量 $H$ 是一个 $2 \\times 2$ 矩阵：\n$$\nH = \\begin{pmatrix} 0 & 0.05 \\\\ 0.05 & 0 \\end{pmatrix}\n$$\n- 双电子积分 $(\\mu\\nu\\mid\\lambda\\sigma)$（其中 $\\mu, \\nu, \\lambda, \\sigma \\in \\{1, 2\\}$）将被存储在一个 $2 \\times 2 \\times 2 \\times 2$ 的张量中。根据问题陈述和置换对称性填充非零元素。\n- SCF循环将对每个给定的 $\\Delta \\in \\{0.0, 0.3, 0.6, 1.0, 5.0\\}$ 值执行。所有情况的初始猜测都相同。\n- Fock矩阵的双电子部分，$G_{\\mu\\nu} = \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu\\mid\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda\\mid\\nu\\sigma) \\right]$，可以通过张量缩并（例如，使用 `numpy.einsum`）高效计算。类库仑项为 $J_{\\mu\\nu} = \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} (\\mu\\nu\\mid\\lambda\\sigma)$，类交换项为 $K_{\\mu\\nu} = \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} (\\mu\\lambda\\mid\\nu\\sigma)$，因此 $G = J - \\frac{1}{2}K$。\n- 矩阵对角化将使用一个鲁棒的数值库函数来执行，例如 `scipy.linalg.eigh`，它适用于对称矩阵，并能方便地按升序返回特征值。\n- 迭代次数将被跟踪并返回。如果循环在达到最大迭代次数 $M=200$ 后仍未满足收敛标准，则返回数值 $-1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_eri_tensor():\n    \"\"\"\n    Constructs the full 2x2x2x2 two-electron repulsion integral (ERI) tensor\n    from the unique non-zero values provided in the problem statement.\n    The indexing is 0-based, corresponding to the problem's 1-based orbital indices.\n    \"\"\"\n    # ERI tensor in chemist's notation (mu nu | lambda sigma)\n    ERI = np.zeros((2, 2, 2, 2))\n    \n    # (11|11) = 0.7\n    ERI[0, 0, 0, 0] = 0.7\n    # (22|22) = 0.7\n    ERI[1, 1, 1, 1] = 0.7\n    \n    # (11|22) = (22|11) = 0.6\n    ERI[0, 0, 1, 1] = 0.6\n    ERI[1, 1, 0, 0] = 0.6\n    \n    # (12|12) = (21|21) = 0.5\n    ERI[0, 1, 0, 1] = 0.5\n    ERI[1, 0, 1, 0] = 0.5\n    \n    # (12|21) = (21|12) = 0.2\n    ERI[0, 1, 1, 0] = 0.2\n    ERI[1, 0, 0, 1] = 0.2\n    \n    # Other integrals are zero based on the problem statement implying that\n    # any integral not derivable by permutation from the given list is zero.\n    \n    return ERI\n\ndef run_rhf_scf(delta, H, ERI, tau, max_iter):\n    \"\"\"\n    Performs the Restricted Hartree-Fock Self-Consistent Field (RHF-SCF)\n    calculation for a given level-shift parameter.\n\n    Args:\n        delta (float): The level-shift parameter value.\n        H (np.ndarray): The core Hamiltonian matrix.\n        ERI (np.ndarray): The two-electron repulsion integral tensor.\n        tau (float): The convergence tolerance.\n        max_iter (int): The maximum number of SCF iterations.\n\n    Returns:\n        int: The number of iterations to converge, or -1 if not converged.\n    \"\"\"\n    dim = H.shape[0]\n    I = np.identity(dim)\n\n    # 1. Initial Guess Generation\n    # Diagonalize the core Hamiltonian H to get the initial guess for MO coefficients.\n    # eigh returns eigenvalues in ascending order.\n    _, eigvecs_h = eigh(H)\n    \n    # The occupied MO is the eigenvector corresponding to the lowest eigenvalue.\n    # Reshape to ensure it is a column vector.\n    c_occ = eigvecs_h[:, 0].reshape(dim, 1)\n\n    # Construct the initial spin-summed density matrix P.\n    P = 2.0 * (c_occ @ c_occ.T)\n\n    # 2. SCF Iterative Procedure\n    for k in range(1, max_iter + 1):\n        P_old = P\n\n        # Build Fock Matrix F = H + G\n        # G = J - 0.5 * K\n        # J_uv = sum_ls P_ls * (uv|ls) -> Coulomb part\n        # K_uv = sum_ls P_ls * (ul|vs) -> Exchange part\n        \n        J = np.einsum('ls,uvls->uv', P_old, ERI)\n        # Transpose ERI for the exchange term calculation\n        K = np.einsum('ls,ulvs->uv', P_old, ERI.transpose(0, 2, 1, 3))\n        \n        F = H + J - 0.5 * K\n\n        # Apply Level Shifting\n        # Q_virt is the projector onto the virtual space: I - P_occ\n        # where P_occ = c_occ @ c_occ.T\n        Q_virt = I - (c_occ @ c_occ.T)\n        F_shifted = F + delta * Q_virt\n\n        # Diagonalize the shifted Fock matrix to find new orbitals\n        _, eigvecs_f = eigh(F_shifted)\n        c_occ = eigvecs_f[:, 0].reshape(dim, 1)\n\n        # Update Density Matrix with the new occupied MO\n        P = 2.0 * (c_occ @ c_occ.T)\n\n        # Check for convergence by comparing the maximum absolute change in the\n        # density matrix elements against the tolerance.\n        delta_P = np.max(np.abs(P - P_old))\n        \n        if delta_P < tau:\n            return k  # SCF procedure has converged.\n\n    return -1  # Did not converge within the maximum number of iterations.\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It sets up the problem, runs the SCF procedure for each level-shift\n    parameter, and prints the results in the required format.\n    \"\"\"\n    # Define problem parameters from the statement\n    H = np.array([[0.0, 0.05], [0.05, 0.0]])\n    ERI = get_eri_tensor()\n    tau = 1e-12\n    max_iter = 200\n    \n    test_cases = [0.0, 0.3, 0.6, 1.0, 5.0]\n\n    results = []\n    for delta in test_cases:\n        iterations = run_rhf_scf(delta, H, ERI, tau, max_iter)\n        results.append(iterations)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400252"}]}