{"hands_on_practices": [{"introduction": "理论是基础，但真正的理解来自于实践。本节的第一个练习将引导你从最基本的原理出发，构建一个打靶法求解器。我们将首先把连续的薛定谔方程 $-\\psi''(x) + V(x)\\psi(x) = E\\psi(x)$ 离散化为一组差分方程，然后通过迭代这个差分关系来“发射”波函数，并最终通过寻找边界条件不匹配函数的零点来确定束缚态能量。这个练习 [@problem_id:2437421] 是掌握打靶法核心思想和数值实现技巧的基石。", "problem": "您必须从第一性原理出发，编写一个完整的、可运行的程序。该程序通过在格点上对空间进行离散化，并对由此产生的差分方程组执行打靶法，来数值求解有限深方势阱中粒子的一维、不含时的 Schrödinger 方程。计算时使用简化的无量纲单位制，其中 $\\hbar^2/(2m)=1$，因此控制方程为\n$$\n-\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n其中有限深方势阱的势函数为\n$$\nV(x) = \\begin{cases}\n-D, & |x| \\le a,\\\\\n0, & |x| > a,\n\\end{cases}\n$$\n对于给定的半宽 $a>0$ 和深度 $D>0$。使用有限计算域 $x \\in [-L, L]$，并采用齐次狄利克雷边界条件 $\\psi(-L)=0$ 和 $\\psi(L)=0$。在这些简化单位中，所有量都是无量纲的，因此最终答案中无需包含物理单位。\n\n从该微分方程和这些边界条件出发，推导出一个在均匀格点 $x_i = x_{\\min} + i\\,\\Delta x$（其中 $\\Delta x = (x_{\\max}-x_{\\min})/(N-1)$ 且 $N \\ge 3$）上的一致的二阶中心差分离散格式。然后，实现一种打靶法，对于一个试探能量 $E$，将差分方程从左边界 $x_{\\min}=-L$ 推进到右边界 $x_{\\max}=L$。使用左边界的边界值和一个非零的初始斜率来开始递推，并将右边界上 $\\psi$ 的终值定义为失配函数。接着，在失配函数改变符号的子区间上，使用一个稳健的区间法（例如，二分法），将区间 $(-D, 0)$ 内的束缚态能量 $E<0$ 作为该失配函数的单根进行包围和精确求解。实现数值保护措施（例如，在需要时重标定解）以防止在打靶迭代过程中发生溢出。您的程序必须：\n- 为每个测试用例构建势函数 $V(x)$。\n- 在格点上离散化方程，并对得到的差分方程实现打靶法。\n- 在粗略网格上扫描能量区间 $(-D,0)$ 以识别失配函数的符号变化，然后应用区间求根方法将每个根收敛到严格的容差。\n- 对每个测试用例，返回找到的束缚态能量列表，按升序（从最小的负值到最大的负值）排序，并四舍五入到六位小数。\n\n测试套件。使用以下参数集，它们共同涵盖了一个具有多个束缚态的典型深势阱、一个接近阈值的浅势阱以及一个窄而深的势阱：\n- 用例 1：$a=1.0$, $D=25.0$, $L=10\\,a$, $N=2001$，粗略能量扫描分辨率为在 $(-D,0)$ 上取 $M=600$ 个采样点。\n- 用例 2：$a=1.0$, $D=1.0$, $L=12\\,a$, $N=2001$，粗略能量扫描分辨率为 $M=600$。\n- 用例 3：$a=0.3$, $D=50.0$, $L=10\\,a$, $N=2001$，粗略能量扫描分辨率为 $M=600$。\n\n数值与算法约束：\n- 使用均匀格点和二阶中心差分推导离散更新。不要使用闭合形式的超越量子化条件；目标是实现格点打靶法。\n- 在 $x=\\pm L$ 处使用齐次狄利克雷边界条件。\n- 在失配函数改变符号的区间上实现区间包围加二分法。\n- 为稳定递推，当 $|\\psi|$ 的值超过一个较大的阈值时，应包含一个重标定步骤。此重标定必须保持波函数在右边界的符号，因此不影响根的区间包围。\n- 在输出前将每个报告的能量四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素本身是对应一个测试用例的浮点数列表。例如，包含两个测试用例的输出可能看起来像 `[[e_{1,1},e_{1,2}], [e_{2,1}]]`，但在这里您必须提供上面指定的三个测试用例的结果。", "solution": "用户提供了一个有效且适定的计算量子力学问题。任务是通过实现数值打靶法，求解一维有限深方势阱中粒子的束缚态能量本征值。\n\n该问题由简化的无量纲单位制下不含时的 Schrödinger 方程（TISE）控制，其中 $\\hbar^2/(2m)=1$：\n$$\n-\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n势函数 $V(x)$ 是一个深度为 $D>0$、半宽为 $a>0$ 的有限深方势阱：\n$$\nV(x) = \\begin{cases}\n-D, & |x| \\le a,\\\\\n0, & |x| > a,\n\\end{cases}\n$$\n该问题在有限计算域 $x \\in [-L, L]$ 上求解，边界条件为齐次狄利克雷条件 $\\psi(-L)=0$ 和 $\\psi(L)=0$。我们感兴趣的是满足 $-D < E < 0$ 的束缚态能量。\n\n解的构建遵循以下步骤：对控制方程进行离散化，实现打靶法将其构建为一个求根问题，并应用一个稳健的求根算法来确定能量本征值。\n\n首先，我们将 Schrödinger 方程离散化。连续的空间坐标 $x$ 被一个包含 $N$ 个点的均匀格点所替代，$x_i = -L + i\\Delta x$，$i=0, 1, \\dots, N-1$，其中网格间距为 $\\Delta x = 2L/(N-1)$。波函数的二阶导数 $\\psi''(x)$ 在每个格点 $x_i$ 处使用二阶精度的中心差分公式进行近似：\n$$\n\\psi''(x_i) \\approx \\frac{\\psi(x_{i+1}) - 2\\psi(x_i) + \\psi(x_{i-1})}{(\\Delta x)^2}\n$$\n令 $\\psi_i = \\psi(x_i)$ 和 $V_i = V(x_i)$，我们将此近似代入 TISE：\n$$\n-\\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2} + V_i \\psi_i = E \\psi_i\n$$\n这是一个线性差分方程。为了实现打靶法，我们将其重排为一个递推关系，从而可以根据前两个值 $\\psi_i$ 和 $\\psi_{i-1}$ 计算出 $\\psi_{i+1}$：\n$$\n\\psi_{i+1} - 2\\psi_i + \\psi_{i-1} = -(\\Delta x)^2 (V_i - E)\\psi_i \\\\\n\\psi_{i+1} = (2 + (\\Delta x)^2 (V_i - E))\\psi_i - \\psi_{i-1}\n$$\n这个递推关系构成了我们数值积分的核心。\n\n接下来，我们应用打靶法。该问题是一个两点边值问题，条件为 $\\psi_0=0$ 和 $\\psi_{N-1}=0$。打靶法将其视为一个初值问题。我们固定一个试探能量 $E$，强制满足左边界条件，然后积分或“打靶”穿过整个区域到达右边界。之后检查右边界上的值。\n\n递推的初始条件是 $\\psi_0$ 和 $\\psi_1$。左边界条件给出 $\\psi_0 = 0$。第二个值 $\\psi_1$ 决定了波函数的初始斜率，$\\psi'(-L) \\approx (\\psi_1-\\psi_0)/\\Delta x = \\psi_1/\\Delta x$。由于零斜率将导致平凡解 $\\psi(x)=0$，我们必须为 $\\psi_1$ 选择一个非零值。TISE 的线性意味着波函数的整体归一化是任意的，因此任何小的非零选择都是有效的。我们选择 $\\psi_1 = \\Delta x$，这对应于初始斜率为1。\n\n对于给定的试探能量 $E$，我们从 $i=1$ 到 $N-2$ 迭代递推关系以计算整个波函数。右边界的值 $\\psi_{N-1}$ 通常不为零。我们将失配函数 $f(E)$ 定义为这个终值：\n$$\nf(E) = \\psi_{N-1}(E)\n$$\n能量本征值是使该函数为零的特定能量值 $E$，即 $f(E)=0$，从而满足右边界条件。\n\n此过程中的一个关键问题是数值稳定性。在经典禁区（$V(x) > E$），真实解呈指数衰减。然而，数值递推也允许存在一个指数增长的解。由于有限的浮点精度，这个增长分量最终将占主导地位并导致溢出。为了解决这个问题，我们引入一个重标定步骤。在迭代过程中，如果波函数值的大小 $|\\psi_i|$ 超过一个很大的阈值，我们就将前一个值和当前值除以此阈值。这可以将数值保持在可管理的范围内，而不会改变波函数的符号或其零点的位置，从而保持了求根过程的完整性。\n\n最后，我们求解 $f(E)$ 的根。我们感兴趣的能量位于区间 $(-D, 0)$ 内。\n1.  在 $(-D, 0)$ 上均匀分布一个包含 $M$ 个能量点的粗略网格。在每个点上计算失配函数 $f(E)$ 的值。\n2.  我们扫描结果，寻找相邻能量点之间的符号变化。根据介值定理，如果一个区间 $[E_j, E_{j+1}]$ 满足 $f(E_j) \\cdot f(E_{j+1}) < 0$，则该区间保证包含至少一个根。\n3.  对于每个这样的有根区间，我们应用二分法。这是一种迭代算法，它反复将搜索区间减半，同时确保根始终被包围在内，从而以所需的数值容差稳健地收敛到能量本征值。\n\n这个结合了离散化、打靶法、数值稳定和稳健求根的系统性程序被用来求解所提供的每个测试用例的束缚态能量。然后，将每个用例发现的能量按升序排序并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A strict Russian professor does not tolerate floating-point overflow.\n# RESCALE_THRESHOLD prevents the wavefunction from growing uncontrollably\n# in classically forbidden regions.\nRESCALE_THRESHOLD = 1e10\n\n# Tolerance for the bisection root-finding method.\nBISECTION_TOL = 1e-12\n\ndef create_potential(x: np.ndarray, a: float, D: float) -> np.ndarray:\n    \"\"\"\n    Constructs the finite square well potential V(x).\n    \n    Args:\n        x (np.ndarray): Array of spatial coordinates.\n        a (float): Half-width of the well.\n        D (float): Depth of the well.\n\n    Returns:\n        np.ndarray: The potential V(x) at each point in x.\n    \"\"\"\n    V = np.zeros_like(x)\n    V[np.abs(x) <= a] = -D\n    return V\n\ndef bisection(f, a: float, b: float, tol: float = BISECTION_TOL) -> float | None:\n    \"\"\"\n    Finds a root of function f in the interval [a, b] using the bisection method.\n    \n    Args:\n        f (callable): The function for which to find a root.\n        a (float): The lower bound of the interval.\n        b (float): The upper bound of the interval.\n        tol (float): The desired tolerance for the root.\n\n    Returns:\n        float | None: The root if found, otherwise None.\n    \"\"\"\n    fa = f(a)\n    if fa == 0.0:\n        return a\n    fb = f(b)\n    if fb == 0.0:\n        return b\n    if fa * fb > 0:\n        # A change of sign is required to guarantee a root.\n        return None\n\n    while (b - a) > tol:\n        c = a + (b - a) / 2.0\n        fc = f(c)\n        if fc == 0.0:\n            return c\n        if fa * fc < 0:\n            b = c\n        else:\n            a = c\n            fa = fc  # Optimization: reuse f(c) as the new f(a)\n    return (a + b) / 2.0\n\ndef solve_case(a: float, D: float, L: float, N: int, M: int) -> list[float]:\n    \"\"\"\n    Solves for the bound-state energies of the finite potential well for one case.\n    \n    Args:\n        a (float): Half-width of the well.\n        D (float): Depth of the well.\n        L (float): Half-width of the computational domain.\n        N (int): Number of points in the spatial grid.\n        M (int): Number of points in the coarse energy scan.\n\n    Returns:\n        list[float]: A sorted list of bound-state energies, rounded to 6 decimals.\n    \"\"\"\n    # 1. Setup the spatial grid and potential\n    x = np.linspace(-L, L, N)\n    delta_x = x[1] - x[0]\n    V = create_potential(x, a, D)\n\n    # 2. Define the mismatch function using a factory pattern\n    def mismatch_function_factory(V_grid, n_points, dx):\n        def mismatch(E: float) -> float:\n            \"\"\"\n            Calculates the value of the wavefunction at the right boundary psi(L)\n            for a given trial energy E.\n            \"\"\"\n            # The recurrence relation is:\n            # psi_{i+1} = (2 + (dx^2)*(V_i - E))*psi_i - psi_{i-1}\n            # The term g_i = (dx^2)*(V_i - E) is pre-calculated.\n            g = dx**2 * (V_grid - E)\n            \n            # Initial conditions: psi_0 = 0, psi_1 = dx (for initial slope of 1)\n            p_prev = 0.0\n            p_curr = dx\n            \n            # Use recurrence to \"shoot\" across the grid\n            for i in range(1, n_points - 1):\n                p_next = (2.0 + g[i]) * p_curr - p_prev\n                \n                p_prev = p_curr\n                p_curr = p_next\n\n                # Stabilization: Rescale to prevent overflow\n                if abs(p_curr) > RESCALE_THRESHOLD:\n                    p_prev /= RESCALE_THRESHOLD\n                    p_curr /= RESCALE_THRESHOLD\n            \n            return p_curr  # Mismatch is the value at x=L\n        return mismatch\n\n    mismatch = mismatch_function_factory(V, N, delta_x)\n\n    # 3. Coarse energy scan to find intervals containing roots\n    # Epsilon prevents scanning E=-D or E=0, where solutions might be special.\n    epsilon = 1e-9\n    E_scan = np.linspace(-D + epsilon, -epsilon, M)\n    m_vals = np.array([mismatch(E) for E in E_scan])\n\n    # 4. Find brackets where the mismatch function changes sign\n    root_brackets = []\n    for i in range(M - 1):\n        if m_vals[i] * m_vals[i+1] < 0:\n            root_brackets.append((E_scan[i], E_scan[i+1]))\n\n    # 5. Refine each root using the bisection method\n    energies = []\n    for e_low, e_high in root_brackets:\n        energy = bisection(mismatch, e_low, e_high, tol=BISECTION_TOL)\n        if energy is not None:\n            energies.append(energy)\n    \n    # 6. Sort and round the final results\n    return [round(e, 6) for e in sorted(energies)]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1: Deep well, multiple states\n        {'a': 1.0, 'D': 25.0, 'L_factor': 10.0, 'N': 2001, 'M': 600},\n        # Case 2: Shallow well, near threshold\n        {'a': 1.0, 'D': 1.0, 'L_factor': 12.0, 'N': 2001, 'M': 600},\n        # Case 3: Narrow, deep well\n        {'a': 0.3, 'D': 50.0, 'L_factor': 10.0, 'N': 2001, 'M': 600},\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case['a'] * case['L_factor']\n        result = solve_case(case['a'], case['D'], L, case['N'], case['M'])\n        results.append(result)\n\n    # Format the final output string to match the problem specification,\n    # specifically producing a list of lists of floats without extra spaces.\n    # For example: [[-24.51,-23.05],[-0.6],[-48.24,-43.12]]\n    formatted_results = [str(res).replace(' ', '') for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2437421"}, {"introduction": "在掌握了基本实现后，我们可以探索更高效、更巧妙的打靶法策略。这个练习将介绍如何利用势函数的对称性来简化计算。对于像有限深方势阱这样的对称势 $V(x)=V(-x)$，其本征函数必然具有确定的宇称（奇或偶），这使得我们可以只在一半大小的空间域内积分，并施加更简单的初始条件。此外，本练习 [@problem_id:2437420] 还引入了并行计算的思想，将能量搜索区间分割给多个处理器同时进行，这极大地提高了寻找多个本征值的效率。", "problem": "要求您设计并实现一种并行打靶法，用于在无量纲单位制下计算一维有限深方势阱的束缚态本征值。在该单位制中，约化普朗克常数的平方除以两倍粒子质量为1，即 $\\hbar^2/(2m)=1$。考虑对于定态波函数 $u(x)$ 的不含时薛定谔方程，\n$$\n-\\frac{d^2 u}{dx^2} + V(x)\\,u(x) = E\\,u(x),\n$$\n该方程等价于\n$$\n\\frac{d^2 u}{dx^2} = \\big(V(x)-E\\big)\\,u(x).\n$$\n势 $V(x)$ 是一个深度为 $V_0>0$、半宽为 $a>0$ 的有限深方势阱，\n$$\nV(x) = \\begin{cases}\n-\\,V_0, & |x|\\le a,\\\\\n0, & |x|>a.\n\\end{cases}\n$$\n束缚态的能量 $E$ 严格介于 $-V_0$ 和 $0$ 之间，即 $-V_0 < E < 0$。由于势是偶函数，本征函数具有确定的宇称。对于偶宇称态，在 $x=0$ 处施加初值条件 $u(0)=1, u'(0)=0$。对于奇宇称态，施加 $u(0)=0, u'(0)=1$。这些初值条件固定了一种适用于打靶法的任意归一化。\n\n基本原理和数值方法。在渐近区域 $x\\to+\\infty$（其中 $V(x)=0$ 且 $E<0$），束缚态解以 $u(x)\\propto e^{-\\kappa x}$ 的形式衰减，衰减常数为 $\\kappa=\\sqrt{-E}$。因此，对于一个正确的本征值 $E$，当 $x$ 很大时，对数导数满足 $u'(x)/u(x)\\to -\\kappa$。利用这一点，在一个很大但有限的 $x_{\\max}>a$ 处定义一个失配函数，\n$$\nF(E) \\equiv \\frac{u'(x_{\\max})}{u(x_{\\max})} + \\sqrt{-E},\n$$\n该函数通过对指定宇称的初值问题从 $x=0$ 积分到 $x=x_{\\max}$ 来计算。本征值对应于 $F(E)$ 的零点。\n\n并行方案设计要求。将能量区间 $(-V_0,0)$ 划分成 $P$ 个独立的子区间。将每个子区间分配给一个单独的处理器，该处理器独立且并行地对两种宇称执行以下操作：\n- 在其分配的子区间内的网格上对 $F(E)$ 进行采样，以定位指示可能零点的符号变化，\n- 通过一个仅使用函数符号信息的稳健求根方法（例如，二分法）来精确化每个符号变化区间，\n- 返回在该子区间内找到的精确根（候选本征值）列表。\n\n所有处理器完成后，合并并排序所有候选值，在一个小容差范围内移除重复值（以处理子区间边界的情况），并为测试用例输出唯一的本征值集合。仅使用实数运算。不出现角度；不需要角度单位。所有物理量都是无量纲的。所有本征值都使用 $\\hbar^2/(2m)=1$ 所蕴含的无量纲能量单位表示，并四舍五入到六位小数。\n\n实现约束。\n- 对于给定的 $E$ 和宇称，使用固定步长的显式积分器将系统 $\\frac{d}{dx}\\begin{pmatrix}u\\\\u'\\end{pmatrix}=\\begin{pmatrix}u'\\\\(V(x)-E)u\\end{pmatrix}$ 从 $x=0$ 推进到 $x_{\\max}$。选择足够大的 $x_{\\max}$，以使渐近区域 $V(x)=0$ 能被充分采样。\n- 为保证数值稳定性，您可以在积分过程中对 $(u,u')$ 进行常数因子重整化；这不会改变对数导数。\n- 在扫描 $E$ 时，避免使用有限深势阱的任何解析超越方程；算法必须仅从初值积分和 $F(E)$ 的符号变化出发。\n\n测试集。您的程序必须计算并报告以下每个参数集的本征值，每个参数集都被视为一个独立的测试用例：\n- 情况 A (理想路径): $V_0=50.0$, $a=1.0$, $P=8$。\n- 情况 B (近阈值浅势阱): $V_0=2.0$, $a=1.0$, $P=4$。\n- 情况 C (较宽且中等深度的势阱): $V_0=20.0$, $a=2.0$, $P=10$。\n\n对于每种情况：\n- 使用 $x_{\\max}=20.0$。\n- 使用固定积分步长 $\\Delta x=0.02$。\n- 在每个子区间中，在 $M=60$ 个等间距的能量点上对 $F(E)$ 进行采样以检测符号变化，然后通过二分法对每个区间进行精确化，直到区间宽度小于 $\\varepsilon_E=10^{-6}$ 或 $|F(E)|<\\varepsilon_F=10^{-6}$。\n- 当合并不同子区间和宇称的候选值时，如果 $|E_1-E_2|<\\delta_{\\text{merge}}=10^{-3}$，则将两个能量 $E_1$ 和 $E_2$ 视为相同。\n\n最终输出规格。您的程序应生成单行输出，其中包含三个测试用例的结果，格式为列表的列表，每个内部列表包含该用例已排序（升序）的本征值，四舍五入到六位小数。格式必须是单行，由方括号括起的逗号分隔列表，内部列表也由方括号括起。例如，包含两个用例的输出可能看起来像 `[[e_{1,1},e_{1,2}],[e_{2,1}]]`。您的程序必须精确地打印这样一行。\n\n每个独立数值的预期数据类型是浮点数。不出现百分比或角度，因此除了指定的无量纲能量单位外，不需要特殊的单位说明。设计涵盖：\n- 一个通用情况（情况 A），\n- 一个接近 $E\\to 0$ 边界的浅束缚态情况（情况 B），\n- 一个具有多个态的较宽势阱（情况 C）。", "solution": "问题陈述经评估有效。其科学上合理，问题定义明确，并为计算量子力学中的一个数值任务提供了完整且一致的规范。该问题没有矛盾、歧义和事实错误。因此，我们可以着手解决。\n\n该问题要求计算一维有限深方势阱的束缚态能量本征值。控制方程是在 $\\hbar^2/(2m) = 1$ 的无量纲单位制下的不含时薛定谔方程 (TISE)：\n$$\n-\\frac{d^2 u}{dx^2} + V(x)u(x) = E u(x)\n$$\n势 $V(x)$ 由下式给出：\n$$\nV(x) = \\begin{cases}\n-V_0, & |x| \\le a \\\\\n0, & |x| > a\n\\end{cases}\n$$\n其中 $V_0 > 0$是势阱深度，$a > 0$ 是半宽。束缚态对应于波函数 $u(x)$ 是平方可积的解，对于此势，这要求能量 $E$ 在范围 $-V_0 < E < 0$ 内。\n\nTISE 是一个二阶常微分方程 (ODE)。为了将其作为初值问题 (IVP) 求解，我们将其重写为一个一阶常微分方程组。令 $\\mathbf{y}(x) = \\begin{pmatrix} u(x) \\\\ u'(x) \\end{pmatrix}$。则该系统为：\n$$\n\\frac{d\\mathbf{y}}{dx} = \\frac{d}{dx}\\begin{pmatrix} u \\\\ u' \\end{pmatrix} = \\begin{pmatrix} u' \\\\ (V(x) - E)u \\end{pmatrix}\n$$\n由于势 $V(x)$ 是一个偶函数 ($V(x) = V(-x)$)，本征函数 $u(x)$ 必须具有确定的宇称（偶宇称或奇宇称）。这使我们能够通过在定义域 $x \\ge 0$ 上积分并施加适当的初值条件来解决问题：\n- 对于偶宇称态：$u(0) = 1$, $u'(0) = 0$。\n- 对于奇宇称态：$u(0) = 0$, $u'(0) = 1$。\n归一化是任意的，其选择是为了方便打靶法。\n\n打靶法的核心是找到使此 IVP 的解满足无穷远处边界条件的能量 $E$。对于束缚态，$u(x)$ 必须在 $x \\to \\infty$ 时衰减为零。在区域 $|x| > a$ 中，势 $V(x)=0$，TISE 变为 $\\frac{d^2 u}{dx^2} = -E u(x)$。当 $E < 0$ 时，通解为 $u(x) = A e^{\\kappa x} + B e^{-\\kappa x}$，其中 $\\kappa = \\sqrt{-E} > 0$。为使解在 $x \\to +\\infty$ 时有界，增长指数项的系数 $A$ 必须为零。因此，解必须渐近表现为 $u(x) \\propto e^{-\\kappa x}$。这意味着波函数的对数导数必须满足：\n$$\n\\frac{u'(x)}{u(x)} \\to -\\kappa = -\\sqrt{-E} \\quad \\text{当 } x \\to \\infty \\text{ 时}\n$$\n我们可以定义一个失配函数 $F(E)$，它在一个很大但有限的匹配点 $x_{\\max} > a$ 处，衡量一个尝试能量 $E$ 的解未能满足此边界条件的程度：\n$$\nF(E) = \\frac{u'(x_{\\max})}{u(x_{\\max})} + \\sqrt{-E}\n$$\n能量本征值正是方程 $F(E) = 0$ 的根。\n\n指定的算法是一种用于寻找这些根的并行打靶法。总的能量搜索区间 $(-V_0, 0)$ 被划分为 $P$ 个更小的、独立的子区间。对每个子区间和每种宇称，按如下方式进行搜索：\n1.  **ODE 积分**：为了对给定的能量 $E$ 计算 $F(E)$，使用固定步长的显式欧拉积分器将一阶 ODE 系统从 $x=0$ 积分到 $x_{\\max}$。给定在步长 $x_n$ 处的状态 $(u_n, u'_n)$，在 $x_{n+1} = x_n + \\Delta x$ 处的状态近似为：\n    $$\n    u_{n+1} = u_n + \\Delta x \\cdot u'_n\n    $$\n    $$\n    u'_{n+1} = u'_n + \\Delta x \\cdot (V(x_n) - E) u_n\n    $$\n    在积分过程中，解向量 $(u, u')$ 可能会变得非常大，导致浮点溢出。为确保数值稳定性，如果其模长变得过大，则在每一步对向量进行重整化，这不影响对数导数。\n\n2.  **求根区间**：在每个子区间内，在 $M$ 个等距点上对函数 $F(E)$ 进行采样。两个连续点之间的符号变化 $F(E_i) \\cdot F(E_{i+1}) < 0$ 表明在区间 $[E_i, E_{i+1}]$ 内存在一个根。这个区间称为一个根区间。\n\n3.  **根的精确化**：每个根区间被传递给一个二分法算法。二分法是一种稳健的求根方法，它通过反复将区间减半来保持根被包围。此过程持续进行，直到区间宽度小于公差 $\\varepsilon_E$ 或失配函数绝对值小于公差 $\\varepsilon_F$。\n\n4.  **结果聚合**：在处理完所有子区间和两种宇称后，收集到的本征值被合并。候选值列表被排序，并且通过将满足 $|E_1 - E_2|$ 小于合并公差 $\\delta_{\\text{merge}}$ 的两个能量 $E_1$ 和 $E_2$ 视为相同，来移除在子区间边界附近找到的重复根。\n\n此过程应用于三个测试用例，使用指定的数值参数：$x_{\\max}=20.0$, $\\Delta x=0.02$, $M=60$, $\\varepsilon_E=10^{-6}$, $\\varepsilon_F=10^{-6}$, 以及 $\\delta_{\\text{merge}}=10^{-3}$。最终结果是每种情况下排好序的、唯一的本征值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        # (V0, a, P)\n        (50.0, 1.0, 8),   # Case A\n        (2.0, 1.0, 4),    # Case B\n        (20.0, 2.0, 10),  # Case C\n    ]\n\n    # Common numerical parameters from the problem statement\n    params = {\n        'x_max': 20.0,\n        'dx': 0.02,\n        'M': 60,\n        'tol_E': 1e-6,\n        'tol_F': 1e-6,\n        'tol_merge': 1e-3,\n    }\n\n    all_results = []\n    for V0, a, P in test_cases:\n        eigenvalues = _find_eigenvalues_for_case(V0, a, P, **params)\n        all_results.append([f\"{eig:.6f}\" for eig in eigenvalues])\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join([\"[\" + \",\".join(map(str, res)) + \"]\" for res in all_results]) + \"]\"\n    print(output_str)\n\n\ndef _potential(x, V0, a):\n    \"\"\"Calculates the finite square well potential V(x).\"\"\"\n    if abs(x) <= a:\n        return -V0\n    return 0.0\n\n\ndef _integrate_schrodinger(E, parity, V0, a, x_max, dx):\n    \"\"\"\n    Integrates the Schrodinger equation for a given energy and parity.\n    Uses a fixed-step explicit Euler method.\n    \"\"\"\n    # Initial conditions at x=0\n    if parity == 'even':\n        u, du_dx = 1.0, 0.0\n    else:  # odd\n        u, du_dx = 0.0, 1.0\n    \n    # Renormalization threshold to prevent overflow\n    renorm_threshold = 1e20\n\n    x_points = np.arange(0, x_max, dx)\n    for x in x_points:\n        # Explicit Euler step\n        u_new = u + dx * du_dx\n        du_dx_new = du_dx + dx * (_potential(x, V0, a) - E) * u\n        u, du_dx = u_new, du_dx_new\n\n        # Renormalization to maintain numerical stability\n        if abs(u) > renorm_threshold or abs(du_dx) > renorm_threshold:\n            norm = np.sqrt(u**2 + du_dx**2)\n            if norm > 0:\n                u /= norm\n                du_dx /= norm\n\n    return u, du_dx\n\n\ndef _mismatch_function_F(E, parity, V0, a, x_max, dx):\n    \"\"\"\n    Calculates the mismatch function F(E) for the shooting method.\n    \"\"\"\n    if E >= 0:\n        # Bound states must have E < 0, handle edge case of E approaching 0.\n        return np.inf\n\n    u_xmax, du_dx_xmax = _integrate_schrodinger(E, parity, V0, a, x_max, dx)\n\n    if abs(u_xmax) < 1e-30:  # Avoid division by zero, indicates a vertical asymptote\n        return np.inf\n\n    kappa = np.sqrt(-E)\n    return du_dx_xmax / u_xmax + kappa\n\n\ndef _bisection(func, E1, E2, tol_E, tol_F):\n    \"\"\"\n    Performs bisection to find a root of func in the bracket [E1, E2].\n    \"\"\"\n    f1 = func(E1)\n    f2 = func(E2)\n\n    if f1 * f2 >= 0:\n        return None  # Not a valid bracket\n\n    if f1 > f2: # Ensure E1 is the lower bound of F\n        E1, E2 = E2, E1\n        \n    while (E2 - E1) > tol_E:\n        E_mid = (E1 + E2) / 2.0\n        f_mid = func(E_mid)\n\n        if abs(f_mid) < tol_F:\n            return E_mid\n\n        if f_mid < 0:\n            E1 = E_mid\n        else:\n            E2 = E_mid\n            \n    return (E1 + E2) / 2.0\n\n\ndef _find_eigenvalues_for_case(V0, a, P, x_max, dx, M, tol_E, tol_F, tol_merge):\n    \"\"\"\n    Implements the full parallel shooting algorithm for a single test case.\n    The \"parallel\" aspect is simulated by iterating through independent subranges.\n    \"\"\"\n    E_min_total, E_max_total = -V0, 0.0\n    subrange_width = (E_max_total - E_min_total) / P\n    \n    candidate_eigenvalues = []\n\n    # This loop simulates P processors working in parallel\n    for i in range(P):\n        E_sub_min = E_min_total + i * subrange_width\n        E_sub_max = E_min_total + (i + 1) * subrange_width\n        \n        # This inner loop covers both parities for each subrange\n        for parity in ['even', 'odd']:\n            \n            # Create a lambda for the function to be solved in this sub-problem\n            mismatch_func = lambda E: _mismatch_function_F(E, parity, V0, a, x_max, dx)\n\n            # Sample F(E) on a grid to find sign changes (brackets)\n            # Use M points strictly inside the subrange to avoid boundary issues\n            energy_grid = np.linspace(E_sub_min, E_sub_max, M + 2)[1:-1]\n            F_values = [mismatch_func(E) for E in energy_grid]\n\n            for j in range(len(energy_grid) - 1):\n                if F_values[j] * F_values[j+1] < 0:\n                    # Found a bracket, refine it with bisection\n                    E1, E2 = energy_grid[j], energy_grid[j+1]\n                    root = _bisection(mismatch_func, E1, E2, tol_E, tol_F)\n                    if root is not None:\n                        candidate_eigenvalues.append(root)\n\n    # Merge results: sort and remove duplicates\n    if not candidate_eigenvalues:\n        return []\n\n    candidate_eigenvalues.sort()\n    \n    unique_eigenvalues = [candidate_eigenvalues[0]]\n    for i in range(1, len(candidate_eigenvalues)):\n        if abs(candidate_eigenvalues[i] - unique_eigenvalues[-1]) > tol_merge:\n            unique_eigenvalues.append(candidate_eigenvalues[i])\n            \n    return unique_eigenvalues\n\n# Execute the main function when the script is run\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2437420"}, {"introduction": "计算物理学的魅力不仅在于求解方程，更在于通过计算来验证和加深对物理原理的理解。我们在上一个练习中利用了对称势的宇称性质，现在是时候用数值实验来严格地验证这一基本原理了。这个练习 [@problem_id:2388895] 要求你计算不同对称性势函数下的本征函数，并定量地分析它们的宇称。虽然本练习采用矩阵对角化这一高效求解多个本征态的替代方法，但其核心目标是让你亲手验证对称性与宇称不变性之间的深刻联系，从而巩固你在量子力学问题求解中的物理直觉。", "problem": "编写一个完整的、可运行的程序，该程序从一维空间中的时间无关薛定谔方程出发，\n$$\n\\hat{H}\\,\\psi(x) \\;=\\; E\\,\\psi(x),\\qquad \\hat{H} \\;=\\; -\\,\\frac{\\hbar^2}{2m}\\,\\frac{d^2}{dx^2} \\;+\\; V(x),\n$$\n计算在边界值为零的有限区间上，几种指定势的最低 $K$ 个能量本征值及其对应的正交归一本征函数，然后定量地验证以下论断：对于任何满足 $V(x)=V(-x)$ 的对称势，其本征函数必须具有确定的宇称（偶宇称或奇宇称）。使用约化普朗克常数 $\\hbar = 1$ 和质量 $m = 1$ 的单位制，并将空间域取为 $x \\in [-L,L]$，其中 $L = 8$，施加边界条件 $\\psi(-L)=\\psi(L)=0$。对于下面测试套件中列出的每种势，您必须得出前 $K=6$ 个束缚态（即按能量递增顺序的六个最小能量本征值，计入简并度）的结果。\n\n对于每个计算出的本征函数 $\\psi_n(x)$，定义归一化宇称相关器\n$$\np_n \\;=\\; \\frac{\\int_{-L}^{L} \\psi_n(x)\\,\\psi_n(-x)\\,dx}{\\int_{-L}^{L} |\\psi_n(x)|^2\\,dx}.\n$$\n一个本征函数具有确定宇称的充要条件是 $|p_n|=1$。在数值上，如果 $|p_n|\\ge \\tau$（阈值 $\\tau = 0.99$），则声明 $\\psi_n(x)$ 具有确定宇称。对于每种势，报告一个包含 $K$ 个布尔值 $b_n$ 的列表，其中如果 $|p_n|\\ge \\tau$ 则 $b_n$ 为真，否则为假。\n\n测试套件（按所列顺序评估）：\n- 情况 A（对称，谐振子）：$V(x)=\\tfrac{1}{2}\\,\\omega^2 x^2$，其中 $\\omega=1$。\n- 情况 B（对称，四次双势阱）：$V(x)=x^4 - 2x^2$。\n- 情况 C（对称，有限深方势阱）：如果 $|x|<a$，则 $V(x) = -V_0$；否则 $V(x)=0$。其中 $V_0=5$，$a=1.5$。\n- 情况 D（非对称对照）：$V(x)=\\tfrac{1}{2}\\,\\omega^2 x^2 + c\\,x$，其中 $\\omega=1$，$c=1$。\n\n所有计算必须使用上述指定的单位制进行；在此体系下，距离是无量纲的，能量也应在同一无量纲系统中解释。不涉及角度。您的程序必须输出单行，其中包含一个由四个内部列表（每个对应一种情况，按 A、B、C、D 的顺序）组成的列表，每个内部列表按本征值递增的顺序列出 $K=6$ 个布尔值，格式为用方括号括起来的逗号分隔列表，不含任何空格。具体来说，您的程序应精确地生成一行格式为 `[booleans_case_A,booleans_case_B,booleans_case_C,booleans_case_D]` 的内容，其中每个 `booleans_case_*` 本身是一个用方括号括起来的、包含 $K=6$ 个 `true` 或 `false` 值（使用编程语言的布尔字面量）的逗号分隔列表，例如：`[[true,true,true,true,true,true],[...],[...],[...]]`，但请使用您所用语言的规范布尔值大写形式。因此，每个测试用例的答案必须是一个包含 $K=6$ 个布尔值的列表，最终输出是这些列表组成的列表，打印在单行上，不含任何额外的字符或空格。", "solution": "经评估，问题陈述有效。它以量子力学原理为科学基础，特别是时间无关薛定谔方程。该问题提法恰当、客观，并包含了获得唯一数值解所需的所有信息。任务是计算几种一维势的最低能量本征态，并验证势的对称性与其本征函数宇称之间的关系。\n\n控制方程是一维时间无关薛定谔方程：\n$$ \\hat{H}\\psi(x) = E\\psi(x) $$\n其中 $E$ 是能量本征值，$\\psi(x)$ 是对应的本征函数。哈密顿算符 $\\hat{H}$ 由下式给出：\n$$ \\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x) $$\n问题指定了使用约化普朗克常数 $\\hbar=1$ 和质量 $m=1$ 的单位制。因此，哈密顿算符简化为：\n$$ \\hat{H} = -\\frac{1}{2}\\frac{d^2}{dx^2} + V(x) $$\n系统被限制在有限区间 $x \\in [-L, L]$（其中 $L=8$）内，并服从零边界条件 $\\psi(-L) = \\psi(L) = 0$。这种配置等效于一个在宽度为 $2L$ 的无限深方势阱中的粒子，阱内还有一个附加势 $V(x)$。\n\n为数值求解此本征值问题，我们采用有限差分法。将空间域 $[-L, L]$ 离散化为 $N+1$ 个等距点 $x_j = -L + j \\cdot \\Delta x$，其中 $j=0, 1, \\dots, N$。网格间距为 $\\Delta x = \\frac{2L}{N}$。本征函数在网格点 $x_j$ 处的值记为 $\\psi_j = \\psi(x_j)$。边界条件意味着 $\\psi_0 = 0$ 和 $\\psi_N = 0$。我们必须求解 $N-1$ 个内部点上的函数值。\n\n动能项中的二阶导数使用三点中心差分公式进行近似：\n$$ \\frac{d^2\\psi}{dx^2}\\bigg|_{x=x_j} \\approx \\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{(\\Delta x)^2} $$\n将此近似代入每个内部网格点 $x_j$（其中 $j=1, \\dots, N-1$）的薛定谔方程，得到一个线性方程组：\n$$ -\\frac{1}{2}\\left(\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{(\\Delta x)^2}\\right) + V(x_j)\\psi_j = E\\psi_j $$\n这可以重排为矩阵本征值问题的标准形式 $\\mathbf{H}\\vec{\\psi} = E\\vec{\\psi}$。此处，$\\vec{\\psi}$ 是未知函数值 $(\\psi_1, \\psi_2, \\dots, \\psi_{N-1})^T$ 的列向量，$\\mathbf{H}$ 是一个大小为 $(N-1) \\times (N-1)$ 的实对称三对角矩阵。其元素定义为：\n$$\n\\mathbf{H}_{j,k} =\n\\begin{cases}\n\\frac{1}{(\\Delta x)^2} + V(x_j) & \\text{if } j=k \\\\\n-\\frac{1}{2(\\Delta x)^2} & \\text{if } j=k\\pm 1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n该矩阵方程的解提供了能量本征值 $E_n$ 和相应本征函数 $\\vec{\\psi}_n$ 的离散近似。本次计算使用了一个专为对称三对角矩阵设计的、数值稳定且高效的算法，即 `scipy.linalg.eigh_tridiagonal`。我们寻求最低的 $K=6$ 个本征值及其关联的本征向量。\n\n该问题要求验证量子力学的一个定理：对于对称势 $V(x)=V(-x)$，哈密顿算符 $\\hat{H}$ 与宇称算符 $\\mathcal{P}$（其中 $\\mathcal{P}f(x) = f(-x)$）对易，因此它们共享一套共同的本征函数。所以，$\\hat{H}$ 的本征函数可以被选择为具有确定宇称的函数，即它们要么是偶函数（$\\psi(-x) = \\psi(x)$），要么是奇函数（$\\psi(-x) = -\\psi(x)$），只要能级不是简并的。对于简并能级，总可以构造出一组具有确定宇称的本征函数基。\n\n为了定量评估一个数值计算出的本征函数 $\\psi_n(x)$ 的宇称，计算归一化宇称相关器 $p_n$：\n$$ p_n = \\frac{\\int_{-L}^{L} \\psi_n(x)\\,\\psi_n(-x)\\,dx}{\\int_{-L}^{L} |\\psi_n(x)|^2\\,dx} $$\n对于一个真正的偶函数，$p_n=1$；对于一个真正的奇函数，$p_n=-1$。对于任何具有确定宇称的函数，都有 $|p_n|=1$。在离散数值近似中，积分被网格点上的求和所取代。通过选择奇数个总点（$N+1$），网格被构建为关于 $x=0$ 对称，以确保 $x_{N-j} = -x_j$。相关器变为：\n$$ p_n \\approx \\frac{\\sum_{j=0}^{N} \\psi_{n,j} \\psi_{n, N-j}}{\\sum_{j=0}^{N} |\\psi_{n,j}|^2} $$\n其中 $\\psi_{n,j}$ 是包含零边界在内的完整离散本征函数向量的分量。数值求解器返回的本征向量是归一化的，使得分母的和为 $1$。计算简化为本征向量与其反转版本的点积。\n如果 $|p_n| \\ge \\tau$（给定阈值 $\\tau = 0.99$），则认为一个本征函数具有确定宇称。\n\n算法按以下步骤进行：对于 4 种势的每一种情况，构建并对角化相应的哈密顿矩阵，以找到最低的 $K=6$ 个本征对。对于每个得到的本征函数，计算其宇称相关器 $p_n$ 并与阈值 $\\tau$ 进行比较，以生成一个布尔值。最终输出是一个包含这 4 个布尔值列表的列表。\n\n前 3 种势（情况 A、B、C）是对称的，因此它们的本征函数预期会具有确定宇称，从而得出一个全为 `True` 的列表。第四种势（情况 D）是非对称的，因此其本征函数预期不具有确定宇称，应得到一个全为 `False` 的列表。这为物理原理和数值实现都提供了一个清晰的检验。使用足够精细的网格（例如，使用 $N=2000$ 个区间，即 $N+1=2001$ 个点）来确保高精度并最小化数值误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-independent Schrödinger equation for several potentials,\n    and verifies the parity of the resulting eigenfunctions.\n    \"\"\"\n    \n    # Global parameters as defined in the problem statement\n    L = 8.0\n    K = 6\n    tau = 0.99\n    \n    # Numerical parameters for the finite difference method\n    # Use an odd number of points to have a grid point at x=0\n    num_points = 2001 \n    \n    # Define the potential functions for the test suite\n    def potential_A(x):\n        # Symmetric harmonic oscillator: V(x) = 1/2 * omega^2 * x^2 with omega=1\n        omega = 1.0\n        return 0.5 * omega**2 * x**2\n\n    def potential_B(x):\n        # Symmetric quartic double well: V(x) = x^4 - 2.0 * x**2\n        return x**4 - 2.0 * x**2\n\n    def potential_C(x):\n        # Symmetric finite square well\n        V0 = 5.0\n        a = 1.5\n        return np.where(np.abs(x) < a, -V0, 0.0)\n\n    def potential_D(x):\n        # Non-symmetric control: V(x) = 1/2 * omega^2 * x^2 + c*x\n        omega = 1.0\n        c = 1.0\n        return 0.5 * omega**2 * x**2 + c * x\n\n    test_cases = [potential_A, potential_B, potential_C, potential_D]\n\n    all_results = []\n\n    # Setup the spatial grid\n    # Grid spans from -L to L with num_points total points\n    x_grid = np.linspace(-L, L, num_points)\n    dx = x_grid[1] - x_grid[0]\n    \n    # We solve on the interior grid, excluding the boundaries\n    interior_x_grid = x_grid[1:-1]\n    num_interior_points = len(interior_x_grid)\n\n    # Pre-calculate constant kinetic energy terms\n    kinetic_diag = 1.0 / dx**2\n    kinetic_offdiag = -1.0 / (2.0 * dx**2)\n\n    for pot_func in test_cases:\n        # Evaluate the potential on the interior grid\n        V = pot_func(interior_x_grid)\n        \n        # Construct the tridiagonal Hamiltonian matrix components\n        # Diagonal elements: H_jj = T_jj + V_j\n        diagonal = kinetic_diag + V\n        \n        # Off-diagonal elements (constant for this stencil)\n        off_diagonal = np.full(num_interior_points - 1, kinetic_offdiag)\n        \n        # Solve the eigenvalue problem for the lowest K eigenvalues/eigenvectors.\n        # eigh_tridiagonal returns them sorted by eigenvalue.\n        _, eigenvectors = eigh_tridiagonal(diagonal, off_diagonal, select='i', select_range=(0, K - 1))\n        \n        case_booleans = []\n        for i in range(K):\n            # Get the i-th eigenvector (column)\n            eigenvector = eigenvectors[:, i]\n            \n            # Construct the full wavefunction on the grid, including boundaries\n            # where psi is zero.\n            psi_full = np.concatenate(([0.0], eigenvector, [0.0]))\n            \n            # The eigenvectors from eigh_tridiagonal are L2-normalized to 1.\n            # The denominator of the parity correlator is sum(|psi|^2), which is 1.\n            # So, p_n is just the anumerator.\n            # The numerator is the dot product of psi(x) with psi(-x).\n            # On our symmetric grid, psi(-x) corresponds to the reversed vector.\n            p_n = np.dot(psi_full, psi_full[::-1])\n            \n            # Check if the absolute value of the parity correlator meets the threshold\n            has_definite_parity = abs(p_n) >= tau\n            case_booleans.append(has_definite_parity)\n            \n        all_results.append(case_booleans)\n\n    # Format the final output string as per the problem specification\n    string_lists = []\n    for bool_list in all_results:\n        # Convert list of booleans [True, False] to string \"[true,false]\"\n        string_lists.append(f\"[{','.join(map(str, bool_list)).lower()}]\")\n    \n    # Combine the case results into the final format \"[[...],[...],...]\"\n    final_output = f\"[{','.join(string_lists)}]\"\n    \n    # Print the single-line result\n    print(final_output)\n\nsolve()\n```", "id": "2388895"}]}