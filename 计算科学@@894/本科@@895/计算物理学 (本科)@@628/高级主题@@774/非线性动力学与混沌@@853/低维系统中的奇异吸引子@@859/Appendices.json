{"hands_on_practices": [{"introduction": "混沌最明确的标志是对初始条件的敏感依赖性，而最大李雅普诺夫指数 $\\lambda_{max}$ 是量化这一点的基本工具。一个正的 $\\lambda_{max}$ 值证实了邻近轨道会呈指数级发散，这是混沌系统的典型特征。第一个练习 [@problem_id:2443507] 将指导你从第一性原理出发，为一个经典的离散时间混沌映射计算 $\\lambda_{max}$，为任何非线性动力学学习者构建一项核心技能。", "problem": "考虑在简单奇异吸引子文献中（包括 Julien C. Sprott 的目录）经常研究的一类二维自治离散时间二次多项式映射族。该族的一个通用成员定义如下：\n$$\n\\begin{aligned}\nx_{n+1} &= a_0 + a_1 x_n + a_2 y_n + a_3 x_n^2 + a_4 x_n y_n + a_5 y_n^2,\\\\\ny_{n+1} &= b_0 + b_1 x_n + b_2 y_n + b_3 x_n^2 + b_4 x_n y_n + b_5 y_n^2,\n\\end{aligned}\n$$\n其中 $x_n \\in \\mathbb{R}$ 和 $y_n \\in \\mathbb{R}$ 表示离散时间步长 $n \\in \\mathbb{Z}_{\\ge 0}$ 时的状态，系数 $\\{a_i\\}_{i=0}^5$ 和 $\\{b_i\\}_{i=0}^5$ 是实常数。该映射的雅可比矩阵 $J(x,y)$ 为\n$$\nJ(x,y)=\n\\begin{bmatrix}\n\\frac{\\partial x_{n+1}}{\\partial x_n} & \\frac{\\partial x_{n+1}}{\\partial y_n}\\\\[6pt]\n\\frac{\\partial y_{n+1}}{\\partial x_n} & \\frac{\\partial y_{n+1}}{\\partial y_n}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_1 + 2 a_3 x + a_4 y & a_2 + a_4 x + 2 a_5 y\\\\\nb_1 + 2 b_3 x + b_4 y & b_2 + b_4 x + 2 b_5 y\n\\end{bmatrix}.\n$$\n\n您的任务是仅使用第一性原理，为该族的几个特定实例计算最大李雅普诺夫指数（Largest Lyapunov Exponent, LLE）。从离散时间动力系统的定义以及李雅普诺夫指数作为邻近轨道分离的渐近指数率的定义出发。利用雅可比矩阵进行线性化来演化一个无穷小切向量，并周期性地对其进行重新归一化以避免数值溢出，同时累积平均对数拉伸。您不得使用任何用于计算李雅普诺夫指数的闭式简化公式；相反，您必须通过迭代映射及其雅可比矩阵来实现计算。\n\n定义和要求：\n- 对于沿轨道 $\\{(x_n,y_n)\\}_{n=0}^{N}$ 求值的离散映射 $F:\\mathbb{R}^2 \\to \\mathbb{R}^2$，其最大李雅普诺夫指数 $\\lambda_{\\max}$ 定义为\n$$\n\\lambda_{\\max} = \\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{n=0}^{N-1} \\ln \\left\\| J(x_n,y_n)\\, \\mathbf{v}_n \\right\\|,\n$$\n其中 $\\mathbf{v}_n$ 是一个单位切向量，它通过线性化 $\\mathbf{v}_{n+1} \\propto J(x_n,y_n)\\, \\mathbf{v}_n$ 进行演化，并在每一步应用归一化 $\\|\\mathbf{v}_{n+1}\\|=1$，而 $\\|\\cdot\\|$ 是欧几里得范数。\n- 丢弃最初的 $N_{\\text{trans}}$ 次迭代的瞬态，以确保在累加求和之前轨道已处于吸引子上，然后在 $N_{\\text{iter}}$ 次迭代上进行平均。\n- 以奈特/迭代（自然对数底 $e$）为单位报告每个 $\\lambda_{\\max}$，结果为浮点数，四舍五入到 $6$ 位小数。\n\n实现一个程序，对下面的每个测试用例执行以下操作：\n1. 按指定初始化 $(x_0,y_0)$。\n2. 迭代映射 $N_{\\text{trans}}$ 步，不累加李雅普诺夫和。\n3. 初始化一个单位切向量 $\\mathbf{v}_0$（您可以使用归一化后的 $\\mathbf{v}_0 = (1,0)$）。\n4. 进行 $N_{\\text{iter}}$ 步，在每次迭代中：\n   - 计算 $J(x_n,y_n)$。\n   - 计算 $\\mathbf{w} = J(x_n,y_n)\\,\\mathbf{v}_n$、其范数 $\\|\\mathbf{w}\\|$，并累加 $\\ln \\|\\mathbf{w}\\|$。\n   - 设置 $\\mathbf{v}_{n+1} = \\mathbf{w}/\\|\\mathbf{w}\\|$。\n   - 通过二次映射更新 $(x_{n+1},y_{n+1})$。\n5. 返回累加和除以 $N_{\\text{iter}}$ 的结果作为 $\\lambda_{\\max}$。\n\n测试套件：\n- 案例 1（Sprott 目录中常见的 Hénon 型系数），参数为 $a = 1.4$, $b = 0.3$：\n  - 映射： $x_{n+1} = 1 + y_n - a x_n^2$, $y_{n+1} = b x_n$。\n  - 系数：$a_0=1$, $a_1=0$, $a_2=1$, $a_3=-a$, $a_4=0$, $a_5=0$；$b_0=0$, $b_1=b$, $b_2=0$, $b_3=0$, $b_4=0$, $b_5=0$。\n  - 初始条件：$(x_0,y_0)=(0,0)$。\n  - 瞬态迭代次数：$N_{\\text{trans}}=1000$。\n  - 平均长度：$N_{\\text{iter}}=100000$。\n- 案例 2（结构相同但非线性减弱），参数为 $a = 1.2$, $b = 0.3$：\n  - 系数定义同案例 1，但 $a=1.2$, $b=0.3$。\n  - 初始条件：$(x_0,y_0)=(0,0)$。\n  - 瞬态迭代次数：$N_{\\text{trans}}=1000$。\n  - 平均长度：$N_{\\text{iter}}=100000$。\n- 案例 3（面积收缩减弱），参数为 $a = 1.4$, $b = 0.1$：\n  - 系数定义同案例 1，但 $a=1.4$, $b=0.1$。\n  - 初始条件：$(x_0,y_0)=(0,0)$。\n  - 瞬态迭代次数：$N_{\\text{trans}}=1000$。\n  - 平均长度：$N_{\\text{iter}}=100000$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是相应测试用例计算出的最大李雅普诺夫指数，四舍五入到 $6$ 位小数，单位为奈特/迭代。\n\n此问题不涉及角度。所有量均为无量纲量，李雅普诺夫指数必须以奈特/迭代为单位报告。最终输出必须严格遵循指定格式的单行文本，不得包含任何额外文本。", "solution": "对所述问题进行验证。\n\n**步骤 1：提取的既定信息**\n- **系统**：一个二维二次映射 $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$，由 $\\mathbf{z}_{n+1} = F(\\mathbf{z}_n)$ 给出，其中 $\\mathbf{z}_n = (x_n, y_n)^T$。\n  - 通用形式：\n    $x_{n+1} = a_0 + a_1 x_n + a_2 y_n + a_3 x_n^2 + a_4 x_n y_n + a_5 y_n^2$\n    $y_{n+1} = b_0 + b_1 x_n + b_2 y_n + b_3 x_n^2 + b_4 x_n y_n + b_5 y_n^2$\n  - 雅可比矩阵：\n    $J(x,y) = \\begin{bmatrix} a_1 + 2 a_3 x + a_4 y & a_2 + a_4 x + 2 a_5 y \\\\ b_1 + 2 b_3 x + b_4 y & b_2 + b_4 x + 2 b_5 y \\end{bmatrix}$\n- **最大李雅普诺夫指数 (LLE) 定义**：$\\lambda_{\\max} = \\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{n=0}^{N-1} \\ln \\| J(x_n,y_n)\\, \\mathbf{v}_n \\|$，其中 $\\mathbf{v}_{n+1} = J(x_n,y_n)\\,\\mathbf{v}_n / \\|J(x_n,y_n)\\,\\mathbf{v}_n\\|$。\n- **数值计算步骤**：\n  - 初始状态：$(x_0, y_0)$ 按指定。\n  - 瞬态迭代次数：$N_{\\text{trans}}$。\n  - 平均迭代次数：$N_{\\text{iter}}$。\n  - 初始切向量：$\\mathbf{v}_0$ 是一个单位向量，例如，归一化后的 $(1,0)$。\n- **测试用例**：所有用例均使用 Hénon 型映射：$x_{n+1} = 1 + y_n - a x_n^2$, $y_{n+1} = b x_n$。\n  - 所有用例的初始条件：$(x_0,y_0)=(0,0)$。\n  - 所有用例的迭代次数：$N_{\\text{trans}}=1000$, $N_{\\text{iter}}=100000$。\n  - 案例 1：$a = 1.4$, $b = 0.3$。\n  - 案例 2：$a = 1.2$, $b = 0.3$。\n  - 案例 3：$a = 1.4$, $b = 0.1$。\n- **输出**：一个 $\\lambda_{\\max}$ 值的列表，四舍五入到 6 位小数，单位为奈特/迭代。\n\n**步骤 2：验证**\n- **科学基础**：该问题在动力系统理论和混沌理论中有坚实的科学基础。李雅普诺夫指数的计算是该领域的典型技术。\n- **适定性**：问题清晰地定义了动力系统、待计算量 ($\\lambda_{\\max}$) 以及包含所有必要参数（$N_{\\text{trans}}$、$N_{\\text{iter}}$、初始条件）的数值算法。有限和近似是计算理论极限的标准实用方法。\n- **一致性**：为上下文提供了映射的通用形式及​​其雅可比矩阵。测试用例中使用的具体映射，即 Hénon 型映射，是此通用形式的一个特例。其系数为 $a_0=1, a_2=1, a_3=-a, b_1=b$，所有其他系数均为零。根据这些系数值，从具体映射导出的雅可比矩阵 $J(x,y) = \\begin{bmatrix} -2ax & 1 \\\\ b & 0 \\end{bmatrix}$ 与给出的通用雅可比公式一致。整个设置完全自洽且一致。\n\n**步骤 3：结论**\n该问题是有效的。它是一个精确、科学上合理且适定性良好的计算任务。我将继续进行解答。\n\n---\n\n该问题要求从第一性原理计算离散时间动力系统的最大李雅普诺夫指数 ($\\lambda_{\\max}$)。这是计算物理学中的一个基本练习，用于探测系统对初始条件的敏感性，而这是混沌的一个决定性特征。\n\n一个正的最大李雅普诺夫指数，$\\lambda_{\\max} > 0$，表示无限接近的轨道平均以指数速率 $e^{\\lambda_{\\max}}$ 分离。这是混沌动力学的数学标志。我们的任务是为指定的二维二次映射实现计算此量的标准算法。\n\n系统在离散时间 $n$ 的状态由向量 $\\mathbf{z}_n = (x_n, y_n)^T$ 给出。其演化由非线性映射 $\\mathbf{z}_{n+1} = F(\\mathbf{z}_n)$ 控制。考虑两个邻近的初始点 $\\mathbf{z}_0$ 和 $\\mathbf{z}_0 + \\delta\\mathbf{z}_0$，其中 $\\delta\\mathbf{z}_0$ 是一个无穷小位移向量。经过一次迭代，分离向量根据映射的线性化进行演化：\n$$\n\\delta\\mathbf{z}_1 = F(\\mathbf{z}_0 + \\delta\\mathbf{z}_0) - F(\\mathbf{z}_0) \\approx J(\\mathbf{z}_0) \\delta\\mathbf{z}_0,\n$$\n其中 $J(\\mathbf{z}_0)$ 是 $F$ 在 $\\mathbf{z}_0$ 处求值的雅可比矩阵。经过 $N$ 次迭代后，分离向量变为：\n$$\n\\delta\\mathbf{z}_N \\approx J(\\mathbf{z}_{N-1}) \\cdots J(\\mathbf{z}_1) J(\\mathbf{z}_0) \\delta\\mathbf{z}_0.\n$$\n最大李雅普诺夫指数由该分离向量的模长 $\\|\\delta\\mathbf{z}_N\\|$ 在 $N \\to \\infty$ 时的最大指数增长率定义。\n\n直接计算雅可比矩阵的乘积在数值上是不稳定的。一种稳健的方法，也是我们必须实现的方法，是沿轨道演化一个切向量 $\\mathbf{v}_n$ 并周期性地对其进行重新归一化。这可以避免数值溢出，并确保该向量与最大拉伸方向对齐。算法如下：\n\n1. 初始化状态 $\\mathbf{z}_0=(x_0, y_0)$ 和一个单位长度的切向量 $\\mathbf{v}_0$，例如 $\\mathbf{v}_0 = (1, 0)^T$。\n2. 迭代映射 $N_{\\text{trans}}$ 步，使轨道收敛到其吸引子上。这确保了计算出的指数是系统长期行为的特征，而不是初始瞬态的特征。因此，对于 $n = 0, \\dots, N_{\\text{trans}}-1$，我们计算 $\\mathbf{z}_{n+1} = F(\\mathbf{z}_n)$。\n3. 瞬态过后，开始进行 $N_{\\text{iter}}$ 步的累积阶段。对于 $n = N_{\\text{trans}}, \\dots, N_{\\text{trans}}+N_{\\text{iter}}-1$：\n    a. 使用线性化演化切向量一步：$\\mathbf{w}_n = J(\\mathbf{z}_n) \\mathbf{v}_n$。\n    b. 这个新向量的长度 $s_n = \\|\\mathbf{w}_n\\|$ 代表沿 $\\mathbf{v}_n$ 方向的局部拉伸因子。将该值的对数 $\\ln(s_n)$ 累加到一个总和中。\n    c. 为下一次迭代将向量重新归一化为单位长度：$\\mathbf{v}_{n+1} = \\mathbf{w}_n / s_n$。\n    d. 将状态演化到轨道上的下一个点：$\\mathbf{z}_{n+1} = F(\\mathbf{z}_n)$。\n4. 最大李雅普诺夫指数是累积的对数拉伸的平均值：\n    $$\n    \\lambda_{\\max} \\approx \\frac{1}{N_{\\text{iter}}} \\sum_{i=0}^{N_{\\text{iter}}-1} \\ln(s_i).\n    $$\n\n对于问题中给出的具体 Hénon 型映射，我们有：\n- 映射 $F(x,y)$:\n  $x_{n+1} = 1 + y_n - a x_n^2$\n  $y_{n+1} = b x_n$\n- 雅可比矩阵 $J(x,y)$:\n  $$\n  J(x,y) = \\begin{bmatrix} -2ax_n & 1 \\\\ b & 0 \\end{bmatrix}\n  $$\n将对三个测试用例中的每一个实施此过程，使用给定的参数 $a$、$b$、初始条件 $(x_0, y_0)=(0,0)$ 以及迭代次数 $N_{\\text{trans}}=1000$ 和 $N_{\\text{iter}}=100000$。每个案例的结果将按要求四舍五入到 6 位小数。使用 NumPy 能够高效地处理向量和矩阵运算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the largest Lyapunov exponent (LLE) for several instances of the Hénon map.\n    The final output is a single line containing a comma-separated list of results.\n    \"\"\"\n\n    def compute_lle(a, b, x0, y0, N_trans, N_iter):\n        \"\"\"\n        Calculates the LLE for a given set of Hénon map parameters.\n\n        Args:\n            a (float): The 'a' parameter of the Hénon map.\n            b (float): The 'b' parameter of the Hénon map.\n            x0 (float): Initial x-coordinate.\n            y0 (float): Initial y-coordinate.\n            N_trans (int): Number of transient iterations to discard.\n            N_iter (int): Number of iterations for averaging the LLE.\n\n        Returns:\n            float: The computed largest Lyapunov exponent.\n        \"\"\"\n        x, y = x0, y0\n\n        # Transient phase to let the trajectory settle onto the attractor\n        for _ in range(N_trans):\n            x_next = 1.0 + y - a * x * x\n            y_next = b * x\n            x, y = x_next, y_next\n\n        # Initialization for Lyapunov exponent calculation\n        # Start with an arbitrary normalized tangent vector\n        v = np.array([1.0, 0.0])\n        log_stretch_sum = 0.0\n\n        # Main loop for LLE calculation\n        for _ in range(N_iter):\n            # Evolve state\n            x_next = 1.0 + y - a * x * x\n            y_next = b * x\n\n            # Jacobian matrix at the current point (x, y)\n            # J = [[-2*a*x, 1.0], [b, 0.0]]\n            J = np.array([[-2.0 * a * x, 1.0], [b, 0.0]])\n\n            # Evolve the tangent vector by matrix multiplication\n            w = J @ v\n\n            # Calculate the norm (stretching factor)\n            norm_w = np.linalg.norm(w)\n            \n            # Accumulate the logarithm of the stretching factor\n            if norm_w > 0: # Avoid log(0) in case of collapse to a fixed point\n                log_stretch_sum += np.log(norm_w)\n            \n            # Re-normalize the tangent vector for the next iteration\n            v = w / norm_w\n\n            # Update the state for the next iteration\n            x, y = x_next, y_next\n\n        # The LLE is the average of the logarithmic stretches\n        lle = log_stretch_sum / N_iter\n        return lle\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: a = 1.4, b = 0.3 (Classic Hénon)\n        (1.4, 0.3),\n        # Case 2: a = 1.2, b = 0.3\n        (1.2, 0.3),\n        # Case 3: a = 1.4, b = 0.1\n        (1.4, 0.1),\n    ]\n\n    # Shared parameters for all test cases\n    N_transient = 1000\n    N_iterations = 100000\n    initial_x = 0.0\n    initial_y = 0.0\n\n    results = []\n    for a, b in test_cases:\n        # Calculate the LLE for the current case\n        result = compute_lle(a, b, initial_x, initial_y, N_transient, N_iterations)\n        # Round the result to 6 decimal places\n        results.append(round(result, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443507"}, {"introduction": "虽然最大李雅普诺夫指数可以识别混沌，但完整的李雅普诺夫指数谱提供了更全面的动力学图像，描述了相空间中的体积如何拉伸和收缩。在这个练习中 [@problem_id:2443522]，我们将从离散映射转向一个连续流——著名的洛伦兹系统。你将实现标准的数值方法来计算整个李雅普诺夫谱，并验证其关键的理论特性，例如与沿流方向相关的零指数。", "problem": "计算三维洛伦兹系统的完整李雅普诺夫谱，并验证奇异吸引子的标准特征。洛伦兹系统是由以下常微分方程（ODE）给出的自治系统：\n$$\n\\dot{x} = \\sigma (y - x), \\quad\n\\dot{y} = x(\\rho - z) - y, \\quad\n\\dot{z} = x y - \\beta z,\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是实参数，$(x,y,z)$ 是状态变量。轨道 $x(t)$ 的李雅普诺夫谱 $(\\lambda_1,\\lambda_2,\\lambda_3)$ 是由满足变分方程的切向流 $W(t)$ 定义的：\n$$\n\\dot{W}(t) = J(x(t))\\,W(t), \\qquad W(0)=I,\n$$\n其中 $J(x)$ 是沿轨道求值的矢量场的雅可比矩阵，$I$ 是单位矩阵。若 $s_1(t)\\ge s_2(t)\\ge s_3(t)>0$ 表示 $W(t)$ 的奇异值，则李雅普诺夫指数为：\n$$\n\\lambda_i = \\lim_{t\\to\\infty} \\frac{1}{t}\\,\\ln s_i(t), \\quad i\\in\\{1,2,3\\}.\n$$\n对于一个光滑流，李雅普诺夫指数之和等于矢量场沿轨道的散度的长时间平均值。对于洛伦兹系统，其散度为常数，由下式给出：\n$$\n\\nabla\\cdot f = -\\sigma - 1 - \\beta,\n$$\n因此\n$$\n\\lambda_1+\\lambda_2+\\lambda_3 = -\\sigma - 1 - \\beta.\n$$\n你的任务是为下面的每个测试用例计算 $(\\lambda_1,\\lambda_2,\\lambda_3)$，并对每个用例返回一个布尔值，该值表示以下两个条件是否同时成立：\n- 符号模式条件：$\\lambda_1 > 0$，$|\\lambda_2| \\le \\delta_0$，且 $\\lambda_3 < 0$，其中 $\\delta_0 = 0.1$。\n- 和一致性条件：$\\left|(\\lambda_1+\\lambda_2+\\lambda_3) - \\big(-\\sigma - 1 - \\beta\\big)\\right| \\le \\delta_\\Sigma$，其中 $\\delta_\\Sigma = 0.5$。\n\n使用以下测试套件。在每个用例中，从初始条件 $(x(0),y(0),z(0))$ 开始积分，舍弃持续时间为 $T_{\\text{trans}}$ 的初始暂态，然后在随后持续时间为 $T_{\\text{avg}}$ 的区间上通过时间平均来估计李雅普诺夫指数：\n- 用例 1：$\\sigma=10$，$\\rho=28$，$\\beta=8/3$，$(x(0),y(0),z(0))=(1,1,1)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=100$。\n- 用例 2：$\\sigma=10$，$\\rho=28$，$\\beta=8/3$，$(x(0),y(0),z(0))=(5,5,5)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=100$。\n- 用例 3：$\\sigma=10$，$\\rho=35$，$\\beta=8/3$，$(x(0),y(0),z(0))=(1,1,1)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=100$。\n- 用例 4：$\\sigma=10$，$\\rho=20$，$\\beta=8/3$，$(x(0),y(0),z(0))=(1,1,1)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=100$。\n- 用例 5：$\\sigma=10$，$\\rho=28$，$\\beta=8/3$，$(x(0),y(0),z(0))=(1,1,1)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=40$。\n\n你的程序应产生一行输出，包含一个由五个布尔值组成的、用逗号分隔并用方括号括起来的列表（例如，“[True,False,True,True,False]”）。不允许有其他任何输出。本问题不涉及物理单位。本问题不涉及角度。如上所述，所有容差检查都应使用绝对值表示。", "solution": "洛伦兹系统是一个由以下矢量场定义的光滑三维自治流：\n$$\nf(x,y,z) = \\big(\\sigma(y-x),\\,x(\\rho - z) - y,\\,xy - \\beta z\\big).\n$$\n其雅可比矩阵为：\n$$\nJ(x,y,z) = \n\\begin{pmatrix}\n-\\sigma & \\sigma & 0\\\\\n\\rho - z & -1 & -x\\\\\ny & x & -\\beta\n\\end{pmatrix}.\n$$\n李雅普诺夫指数用于量化无穷小扰动的渐近指数增长率。设 $x(t)$ 为一个解轨道，$W(t)$ 为变分方程的基本矩阵：\n$$\n\\dot{W}(t) = J(x(t))\\,W(t), \\qquad W(0)=I.\n$$\n如果 $s_i(t)$ 是按非递增顺序排列的 $W(t)$ 的奇异值，那么根据定义：\n$$\n\\lambda_i = \\lim_{t\\to\\infty} \\frac{1}{t}\\ln s_i(t), \\quad i=1,2,3.\n$$\n这个定义与坐标无关，并且源于第一性原理：将非线性流沿轨道线性化，并追踪切向量的增长。\n\n一个关键的恒等式将李雅普诺夫指数之和与矢量场的散度联系起来。Liouville 公式指出：\n$$\n\\frac{d}{dt}\\ln\\det W(t) = \\operatorname{tr}\\left(J(x(t))\\right).\n$$\n积分并除以 $t$ 可得：\n$$\n\\frac{1}{t}\\ln\\det W(t) = \\frac{1}{t}\\int_0^t \\operatorname{tr}(J(x(s)))\\,ds.\n$$\n当 $t\\to\\infty$ 时，左侧收敛于 $\\lambda_1+\\lambda_2+\\lambda_3$（因为 $\\det W$ 是奇异值的乘积），而右侧收敛于散度的长时间平均值。对于洛伦兹系统，$\\operatorname{tr} J = -\\sigma - 1 - \\beta$ 是一个常数，因此：\n$$\n\\lambda_1+\\lambda_2+\\lambda_3 = -\\sigma - 1 - \\beta.\n$$\n为了数值计算完整谱，需要将基流 $x(t)$ 与切向流 $W(t)$ 一同积分。直接演化 $W(t)$ 会因指数增长和衰减而导致严重的病态问题。标准的、基于原理的解决方法是使用正交-三角（QR）分解，周期性地将 $W(t)$ 分解为正交-三角形式：\n$$\nW(t_k) = Q_k R_k,\n$$\n其中 $Q_k$ 是正交矩阵，$R_k$ 是对角元素为正的上三角矩阵。$R_k$ 的对角线体现了该区间上的局部拉伸因子，我们需要累加这些对角元素的对数。具体来说，如果两次重新正交化之间的时间间隔为 $\\Delta t$，并且 $R_k$ 是在第 $k$ 个区间上获得的，那么经过 $N$ 个这样的区间后，李雅普诺夫指数可通过下式估计：\n$$\n\\hat{\\lambda}_i = \\frac{1}{N\\,\\Delta t} \\sum_{k=1}^{N} \\ln\\left(\\left|R_k(i,i)\\right|\\right), \\quad i=1,2,3.\n$$\n将这些估计值按非递增顺序排序，即可得到 $(\\lambda_1,\\lambda_2,\\lambda_3)$。\n\n为进行验证，每个测试用例需要进行两项检查：\n- 奇异吸引子所期望的符号模式是 $\\lambda_1>0$，$\\lambda_2\\approx 0$，且 $\\lambda_3<0$。考虑到有限时间估计的误差，我们要求 $|\\lambda_2|\\le \\delta_0$，其中 $\\delta_0=0.1$。\n- 指数之和必须与精确的散度恒等式一致，即 $\\left|(\\lambda_1+\\lambda_2+\\lambda_3) - \\big(-\\sigma - 1 - \\beta\\big)\\right|\\le \\delta_\\Sigma$，其中 $\\delta_\\Sigma=0.5$。\n\n对于经典的混沌洛伦兹参数 $\\sigma=10$，$\\rho=28$，$\\beta=8/3$，已知的渐近值约为 $\\lambda_1\\approx 0.9$，$\\lambda_2\\approx 0$ 和 $\\lambda_3\\approx -14.6$，其和约为 $-13.7$，这与 $-\\sigma-1-\\beta = -13.\\overline{6}$ 一致。根据遍历性，同一吸引子上的不同初始条件会产生相同的谱。将 $\\rho$ 增加到 $\\rho=35$ 时，系统仍处于混沌状态并保持该符号模式。将 $\\rho$ 减小到 $\\rho=20$ 会进入一个非混沌区域，其中 $\\lambda_1<0$，因此符号模式测试会失败，尽管和恒等式仍然成立。\n\n从算法上讲，程序积分洛伦兹常微分方程及其变分方程，对切矩阵应用周期性的正交-三角（QR）重新正交化，在舍弃初始暂态 $T_{\\text{trans}}$ 后，在平均区间 $T_{\\text{avg}}$ 上累加对数拉伸因子以估计李雅普诺夫指数，对指数进行排序，并使用给定的容差评估这两个条件。最终的输出是一个包含五个布尔值的列表，每个值对应一个测试用例，表示两个条件是否都满足。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef lorenz_and_variational(t, y, sigma, rho, beta):\n    \"\"\"\n    y contains [x, y, z, W_flattened(9)]\n    Returns derivatives for the Lorenz system and the variational matrix W.\n    \"\"\"\n    x, yv, z = y[0], y[1], y[2]\n    W = y[3:].reshape(3, 3)\n\n    # Lorenz dynamics\n    dx = sigma * (yv - x)\n    dy = x * (rho - z) - yv\n    dz = x * yv - beta * z\n\n    # Jacobian of the Lorenz system\n    J = np.array([\n        [-sigma,   sigma,     0.0],\n        [rho - z,  -1.0,     -x   ],\n        [yv,       x,       -beta ]\n    ], dtype=float)\n\n    # Variational equation: dW/dt = J * W\n    dW = J @ W\n\n    deriv = np.empty(12, dtype=float)\n    deriv[0:3] = [dx, dy, dz]\n    deriv[3:] = dW.reshape(9)\n    return deriv\n\ndef integrate_step_with_qr(x_state, Q, h, sigma, rho, beta, rtol=1e-6, atol=1e-9, method='RK45'):\n    \"\"\"\n    Integrate the augmented system for time h starting from state x_state and\n    tangent basis Q. Return the next state, next orthonormal basis, and the\n    diagonal of R from QR factorization of the transported basis.\n    \"\"\"\n    y0 = np.empty(12, dtype=float)\n    y0[0:3] = x_state\n    y0[3:] = (Q).reshape(9)\n\n    sol = solve_ivp(\n        lorenz_and_variational,\n        t_span=(0.0, h),\n        y0=y0,\n        args=(sigma, rho, beta),\n        method=method,\n        rtol=rtol,\n        atol=atol\n    )\n    yf = sol.y[:, -1]\n    xf = yf[0:3]\n    Wf = yf[3:].reshape(3, 3)\n\n    # QR decomposition to re-orthonormalize\n    Qn, R = np.linalg.qr(Wf)\n    # Ensure numerical stability: avoid zero diagonals for log\n    diagR = np.diag(R)\n    # Accumulate logs of absolute diagonal entries\n    abs_diag = np.abs(diagR)\n    # Protect against extremely small values\n    eps = 1e-300\n    abs_diag = np.maximum(abs_diag, eps)\n\n    return xf, Qn, np.log(abs_diag)\n\ndef lyapunov_spectrum(sigma, rho, beta, x0, T_trans, T_avg, dt_re=0.05):\n    \"\"\"\n    Compute the full Lyapunov spectrum (lambda1 >= lambda2 >= lambda3)\n    for the Lorenz system with given parameters and initial condition.\n    Discard an initial transient T_trans, then average over T_avg.\n    \"\"\"\n    # Ensure T_trans and T_avg are multiples of dt_re for clean stepping\n    n_trans = int(round(T_trans / dt_re))\n    n_avg = int(round(T_avg / dt_re))\n    # Initialize state and tangent basis\n    x = np.array(x0, dtype=float)\n    Q = np.eye(3, dtype=float)\n\n    # Transient phase (do not accumulate)\n    for _ in range(n_trans):\n        x, Q, _ = integrate_step_with_qr(x, Q, dt_re, sigma, rho, beta)\n\n    # Averaging phase (accumulate)\n    sum_logs = np.zeros(3, dtype=float)\n    for _ in range(n_avg):\n        x, Q, logs = integrate_step_with_qr(x, Q, dt_re, sigma, rho, beta)\n        sum_logs += logs\n\n    # Estimate exponents\n    lambdas = sum_logs / (n_avg * dt_re)\n    # Sort in nonincreasing order\n    lambdas_sorted = np.sort(lambdas)[::-1]\n    return lambdas_sorted\n\ndef verify_case(sigma, rho, beta, x0, T_trans, T_avg, delta_zero=0.1, delta_sum=0.5):\n    lambdas = lyapunov_spectrum(sigma, rho, beta, x0, T_trans, T_avg)\n    lam1, lam2, lam3 = lambdas[0], lambdas[1], lambdas[2]\n    # Sign pattern condition\n    ok_signs = (lam1 > 0.0) and (abs(lam2) = delta_zero) and (lam3  0.0)\n    # Sum consistency condition\n    target_sum = -(sigma + 1.0 + beta)\n    ok_sum = abs((lam1 + lam2 + lam3) - target_sum) = delta_sum\n    return ok_signs and ok_sum\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (sigma, rho, beta, (x0,y0,z0), T_trans, T_avg)\n        (10.0, 28.0, 8.0/3.0, (1.0, 1.0, 1.0), 5.0, 100.0),  # Case 1\n        (10.0, 28.0, 8.0/3.0, (5.0, 5.0, 5.0), 5.0, 100.0),  # Case 2\n        (10.0, 35.0, 8.0/3.0, (1.0, 1.0, 1.0), 5.0, 100.0),  # Case 3\n        (10.0, 20.0, 8.0/3.0, (1.0, 1.0, 1.0), 5.0, 100.0),  # Case 4 (nonchaotic)\n        (10.0, 28.0, 8.0/3.0, (1.0, 1.0, 1.0), 5.0, 40.0),   # Case 5 (shorter average)\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, rho, beta, x0, T_trans, T_avg = case\n        result = verify_case(sigma, rho, beta, x0, T_trans, T_avg, delta_zero=0.1, delta_sum=0.5)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2443522"}, {"introduction": "奇异吸引子不仅仅是混沌的，它们还具有复杂的、分形的几何结构。卡普兰-约克维度 (Kaplan-Yorke dimension) $D_{\\mathrm{KY}}$ 提供了一种强有力的方法，直接从吸引子的李雅普诺夫谱来估算其分形维数。这最后一个练习 [@problem_id:2443485] 直接建立在前一个练习的基础上，要求你使用计算出的李雅普诺夫谱来计算洛伦兹吸引子的 $D_{\\mathrm{KY}}$，并探索这个复杂性度量如何随着系统进入更深的混沌状态而变化。", "problem": "要求您从第一性原理出发，研究洛伦兹系统的卡普兰-约克（KY）维度对控制参数的依赖关系。考虑以下洛伦兹常微分方程组（ODEs）\n$$\n\\dot{x} = \\sigma (y - x),\\quad\n\\dot{y} = x(\\rho - z) - y,\\quad\n\\dot{z} = x y - \\beta z,\n$$\n其中参数固定为 $ \\sigma = 10 $，$ \\beta = \\frac{8}{3} $，以及一个可变的控制参数 $ \\rho  0 $。设初始条件为 $ (x(0),y(0),z(0)) = (1,1,1) $。本问题中的所有量均为无量纲。\n\n设 $ \\phi^t(\\mathbf{x}_0) $ 表示从 $ \\mathbf{x}_0 \\in \\mathbb{R}^3 $ 出发、在时间 $ t $ 的流映射。沿轨道 $ \\mathbf{x}(t) $ 的流的线性化由以下变分方程控制\n$$\n\\frac{d}{dt}\\,\\delta \\mathbf{x}(t) = J(\\mathbf{x}(t))\\,\\delta \\mathbf{x}(t),\n$$\n其中 $ J(\\mathbf{x}) $ 是矢量场的雅可比矩阵，\n$$\nJ(x,y,z) =\n\\begin{pmatrix}\n-\\sigma  \\sigma  0 \\\\\n\\rho - z  -1  -x \\\\\ny  x  -\\beta\n\\end{pmatrix}.\n$$\n\n将三个李雅普诺夫指数 $ \\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3 $ 定义为沿一条典型轨道，变分方程基本矩阵解的奇异值的渐近指数增长率。使用这些指数，将卡普兰-约克维度 $ D_{\\mathrm{KY}} $ 定义为\n$$\nS_j = \\sum_{i=1}^{j} \\lambda_i,\\quad j \\in \\{1,2,3\\},\\quad\nj^\\star = \\max\\{ j \\in \\{0,1,2,3\\} \\,:\\, S_j \\ge 0\\},\\quad S_0 \\equiv 0,\n$$\n和\n$$\nD_{\\mathrm{KY}} =\n\\begin{cases}\n0,  j^\\star = 0, \\\\\nj^\\star + \\dfrac{S_{j^\\star}}{|\\lambda_{j^\\star+1}|},  j^\\star \\in \\{1,2\\}.\n\\end{cases}\n$$\n\n任务：对于下面测试套件中指定的每个 $ \\rho $ 值，沿始于 $ (1,1,1) $ 的轨道，根据变分方程计算三个李雅普诺夫指数，然后计算上面定义的相应卡普兰-约克维度 $ D_{\\mathrm{KY}} $。您的程序必须从第一性原理出发，数值近似定义中包含的长时间极限，并生成所要求的输出。\n\n确保任务良定的数值规范：\n- 使用 $ \\Delta t = 0.01 $ 的固定时间步长来演化基本轨道和变分动力学。\n- 在估计渐近量时，舍弃持续时间为 $ T_{\\mathrm{trans}} = 50 $ （即 $ 5000 $ 步）的初始暂态过程。\n- 在暂态过程之后，使用持续时间为 $ T_{\\mathrm{acc}} = 250 $ （即 $ 25000 $ 步）的数据累积区间来估计李雅普诺夫指数。\n- 不涉及角度；无需角度单位。\n- 没有物理单位；所有量均为无量纲。\n\n测试套件（不同区域）：\n- 稳定的原点：$ \\rho = 0.5 $。\n- 稳定的非平凡平衡点：$ \\rho = 20.0 $。\n- 接近混沌的临界点：$ \\rho = 24.0 $。\n- 经典混沌区域：$ \\rho = 28.0 $。\n- 更强的混沌：$ \\rho = 35.0 $。\n- 远混沌区域：$ \\rho = 160.0 $。\n\n答案规范：\n- 对于列表 $ [0.5, 20.0, 24.0, 28.0, 35.0, 160.0] $ 中的每个 $ \\rho $ 值，输出相应的 $ D_{\\mathrm{KY}} $，四舍五入到小数点后三位。\n- 最终输出格式必须是单行，包含一个由方括号括起来的逗号分隔列表，其结果顺序与测试套件相同。例如，$ [d_1,d_2,d_3,d_4,d_5,d_6] $，其中每个 $ d_k $ 是一个小数点后恰好有三位数字的浮点数。", "solution": "所述问题是有效的。这是一个基于动力系统理论和计算物理学既定原理的、定义明确的计算任务。它在科学上是合理的、内容是自洽的，并且没有歧义。洛伦兹系统、李雅普诺夫指数和卡普兰-约克维度都是标准的研究课题。我们将给出一个完整的解决方案。\n\n目标是针对一组给定的控制参数 $\\rho$，计算洛伦兹系统的卡普兰-约克维度 $D_{\\mathrm{KY}}$。该系统由以下三个耦合的常微分方程组（ODEs）描述：\n$$\n\\dot{x} = \\sigma (y - x) \\\\\n\\dot{y} = x(\\rho - z) - y \\\\\n\\dot{z} = x y - \\beta z\n$$\n其中参数固定为 $\\sigma = 10$ 和 $\\beta = \\frac{8}{3}$。系统状态由向量 $\\mathbf{x}(t) = (x(t), y(t), z(t))^{\\mathrm{T}}$ 给出。\n\n卡普兰-约克维度是系统李雅普诺夫指数 $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$ 的函数。这些指数表征了相空间中邻近轨道发散或收敛的平均指数率。它们通过流的线性化来形式化定义，该线性化由变分方程描述：\n$$\n\\frac{d}{dt}\\delta\\mathbf{x} = J(\\mathbf{x}(t))\\delta\\mathbf{x}\n$$\n此处，$\\delta\\mathbf{x}$ 是一个无穷小扰动向量，$J(\\mathbf{x})$ 是矢量场的雅可比矩阵，具体如下：\n$$\nJ(x,y,z) =\n\\begin{pmatrix}\n-\\sigma  \\sigma  0 \\\\\n\\rho - z  -1  -x \\\\\ny  x  -\\beta\n\\end{pmatrix}\n$$\n李雅普诺夫指数之和等于雅可比矩阵的迹的时间平均值。对于洛伦兹系统，其迹是恒定的：$\\mathrm{Tr}(J) = -\\sigma - 1 - \\beta = -10 - 1 - 8/3 \\approx -13.67$。这意味着该系统是耗散的，相空间中任何初始条件集合的体积都会随时间收缩，这是奇异吸引子存在的必要条件。因此，一条典型轨道的指数之和为负：$S_3 = \\lambda_1 + \\lambda_2 + \\lambda_3  0$。\n\n为数值计算李雅普诺夫指数，我们必须同时对系统的状态方程和变分方程进行积分。我们演化一组初始时为标准正交的扰动向量，这些向量构成矩阵 $\\mathbf{V}(t)$ 的列。初始系统状态为 $\\mathbf{x}(0) = (1, 1, 1)^{\\mathrm{T}}$，初始扰动矩阵为单位矩阵 $\\mathbf{V}(0) = \\mathbf{I}$。状态和扰动根据以下方程在一个时间步长 $\\Delta t$ 内演化：\n$$\n\\dot{\\mathbf{x}} = \\mathbf{F}(\\mathbf{x}) \\\\\n\\dot{\\mathbf{V}} = J(\\mathbf{x}(t))\\mathbf{V}(t)\n$$\n对 $\\mathbf{V}(t)$ 的直接积分在数值上是不稳定的，因为列向量会指数级增长并与最大指数的方向对齐。为解决此问题，在每个时间步结束时应用重新正交化程序。我们将采用的标准方法是QR分解。\n\n算法流程如下：\n1. 初始化状态 $\\mathbf{x}_0 = (1, 1, 1)^{\\mathrm{T}}$ 和一个标准正交矩阵 $\\mathbf{V}_0 = \\mathbf{I}_{3 \\times 3}$。初始化一个向量 $\\mathbf{L} = (0, 0, 0)^{\\mathrm{T}}$ 以累积缩放因子的对数。\n\n2. 将 $\\mathbf{x}(t)$ 和 $\\mathbf{V}(t)$ 的组合系统（共 $3+9=12$ 个ODE）在一个时间步长 $\\Delta t = 0.01$ 内进行积分，以获得 $\\mathbf{x}_1$ 和 $\\mathbf{V}'_1$。问题指定了固定的时间步长但未指定积分方法。一阶欧拉法较为原始；为获得更优的精度和稳定性，我们使用四阶龙格-库塔（RK4）方法。\n\n3. 在该步结束时，对演化后的扰动矩阵进行QR分解：$\\mathbf{V}'_1 = \\mathbf{Q}_1 \\mathbf{R}_1$，其中 $\\mathbf{Q}_1$ 是一个正交矩阵，$\\mathbf{R}_1$ 是一个上三角矩阵。\n\n4. $\\mathbf{R}_1$ 的对角元素，即 $R_{1,11}$、$R_{1,22}$ 和 $R_{1,33}$，代表了扰动向量在时间间隔 $\\Delta t$ 内的增长因子。累积这些对角元素绝对值的对数。下一步的矩阵 $\\mathbf{V}$ 被重置为正交矩阵 $\\mathbf{Q}_1$。为确保 $\\mathbf{V}$ 保持为右手坐标基且对数的参数为正，我们通过将任何负号吸收到 $\\mathbf{Q}$ 的列中来强制 $\\mathbf{R}$ 的对角线元素为正。\n\n5. 重复步骤2-4，总迭代次数对应于指定的暂态时间 $T_{\\mathrm{trans}} = 50$ 和累积时间 $T_{\\mathrm{acc}} = 250$。对数和仅在 $T_{\\mathrm{acc}}$ 区间内累积。\n\n6. 模拟结束后，根据累积的和计算李雅普诺夫指数：\n$$ \\lambda_i = \\frac{1}{T_{\\mathrm{acc}}} L_i = \\frac{1}{T_{\\mathrm{acc}}} \\sum_{k} \\ln |R_{k,ii}| $$\n求和遍及累积周期内的所有步骤。QR算法自然地得出指数，只要初始向量具有通用方向，$\\lambda_1$ 就与 $i=1$ 时的 $R_{ii}$ 相关联。\n\n7. 计算出指数 $\\lambda_1, \\lambda_2, \\lambda_3$ 后，使用提供的公式计算卡普兰-约克维度 $D_{\\mathrm{KY}}$。设 $S_j = \\sum_{i=1}^j \\lambda_i$ 且 $S_0=0$。找到 $j^\\star = \\max\\{j \\in \\{0, 1, 2, 3\\} : S_j \\ge 0\\}$。由于 $S_3  0$，$j^\\star$ 最大只能是 $2$。\n   - 如果 $j^\\star=0$ （即 $\\lambda_1  0$），则 $D_{\\mathrm{KY}} = 0$。这表示一个稳定的不动点。\n   - 如果 $j^\\star=1$ （即 $\\lambda_1 \\ge 0$ 且 $S_2  0$），则 $D_{\\mathrm{KY}} = 1 + S_1 / |\\lambda_2|$。这通常表示一个极限环。\n   - 如果 $j^\\star=2$ （即 $S_2 \\ge 0$），则 $D_{\\mathrm{KY}} = 2 + S_2 / |\\lambda_3|$。这表示一个奇异吸引子。\n\n对测试套件中的每个 $\\rho$ 值都将执行此程序，并将所得的 $D_{\\mathrm{KY}}$ 报告到小数点后三位。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Kaplan-Yorke dimension for the Lorenz system for various\n    values of the control parameter rho.\n    \"\"\"\n    # System parameters and numerical specifications\n    SIGMA = 10.0\n    BETA = 8.0 / 3.0\n    DT = 0.01\n    T_TRANS = 50.0\n    T_ACC = 250.0\n    N_TRANS = int(T_TRANS / DT)\n    N_ACC = int(T_ACC / DT)\n    \n    # Test suite for the parameter rho\n    test_rhos = [0.5, 20.0, 24.0, 28.0, 35.0, 160.0]\n    results = []\n\n    def lorenz_system_and_variational(full_state, rho):\n        \"\"\"\n        Computes the time derivative of the extended 12-dimensional state vector,\n        which includes the Lorenz system variables (x, y, z) and the 3x3\n        matrix of perturbation vectors V.\n        \"\"\"\n        x, y, z = full_state[:3]\n        V = full_state[3:].reshape((3, 3))\n\n        # Lorenz system ODEs\n        d_xyz = np.array([\n            SIGMA * (y - x),\n            x * (rho - z) - y,\n            x * y - BETA * z\n        ])\n\n        # Jacobian matrix J(x,y,z)\n        J = np.array([\n            [-SIGMA, SIGMA, 0.0],\n            [rho - z, -1.0, -x],\n            [y, x, -BETA]\n        ])\n\n        # Variational equation dV/dt = J * V\n        d_V = J @ V\n        \n        # Return the flattened 12-element derivative vector\n        return np.concatenate((d_xyz, d_V.flatten()))\n\n    def rk4_step(f, y, dt, rho):\n        \"\"\"\n        Performs a single step of the fourth-order Runge-Kutta method.\n        \"\"\"\n        k1 = f(y, rho)\n        k2 = f(y + dt / 2.0 * k1, rho)\n        k3 = f(y + dt / 2.0 * k2, rho)\n        k4 = f(y + dt * k3, rho)\n        return y + dt / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    for rho in test_rhos:\n        # Initial conditions for each run\n        # State vector [x, y, z]\n        xyz_state = np.array([1.0, 1.0, 1.0])\n        # Perturbation matrix V, initialized to identity\n        v_state = np.identity(3)\n        # Combined 12-element state vector\n        full_state = np.concatenate((xyz_state, v_state.flatten()))\n        \n        # Accumulator for logarithms of stretching factors\n        lyap_sum = np.zeros(3)\n        \n        total_steps = N_TRANS + N_ACC\n        for step in range(total_steps):\n            # Evolve the combined state by one time step\n            full_state = rk4_step(lorenz_system_and_variational, full_state, DT, rho)\n\n            # Extract the evolved perturbation matrix\n            v_prime = full_state[3:].reshape((3, 3))\n            \n            # Orthonormalize using QR decomposition\n            Q, R = np.linalg.qr(v_prime)\n            \n            # The diagonal of R contains the stretching factors.\n            # To ensure the logarithm is well-defined and the new basis Q\n            # maintains orientation, we force R's diagonal elements to be positive.\n            # Any negative sign is absorbed into the corresponding column of Q.\n            signs = np.sign(np.diag(R))\n            signs[signs == 0] = 1 # Avoid issues with zero on the diagonal\n            Q = Q @ np.diag(signs)\n            R_diag_abs = np.abs(np.diag(R))\n            \n            # Reset the perturbation part of the state to the new orthonormal basis\n            full_state[3:] = Q.flatten()\n            \n            # Accumulate after the transient period\n            if step >= N_TRANS:\n                # Add logarithm of stretching factors to the sum\n                lyap_sum += np.log(R_diag_abs)\n\n        # Calculate the Lyapunov exponents\n        lyap_exponents = lyap_sum / T_ACC\n        \n        # The QR procedure naturally orders the exponents lambda_1 >= lambda_2 >= ...\n        # But to be safe, we sort them\n        lyap_exponents.sort()\n        lyap_exponents = lyap_exponents[::-1]\n        lambda1, lambda2, lambda3 = lyap_exponents[0], lyap_exponents[1], lyap_exponents[2]\n        \n        # Calculate sums S_j for Kaplan-Yorke dimension formula\n        S1 = lambda1\n        S2 = lambda1 + lambda2\n        \n        # Determine j_star\n        j_star = 0\n        if S1 >= 0:\n            j_star = 1\n            if S2 >= 0:\n                j_star = 2\n        \n        # Calculate Kaplan-Yorke dimension D_KY\n        D_KY = 0.0\n        if j_star == 1:\n            # Avoid division by zero, though unlikely for stable limit cycles\n            if abs(lambda2) > 1e-12:\n                D_KY = 1.0 + S1 / abs(lambda2)\n            else:\n                D_KY = 1.0\n        elif j_star == 2:\n            # Avoid division by zero, though lambda3 is strongly negative in chaos\n            if abs(lambda3) > 1e-12:\n                D_KY = 2.0 + S2 / abs(lambda3)\n            else:\n                D_KY = 2.0\n        \n        results.append(f\"{D_KY:.3f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2443485"}]}