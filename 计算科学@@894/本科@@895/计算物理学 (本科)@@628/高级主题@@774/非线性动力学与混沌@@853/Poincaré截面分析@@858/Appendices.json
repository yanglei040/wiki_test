{"hands_on_practices": [{"introduction": "本实践旨在巩固庞加莱截面与系统哈密顿量之间的基本联系。对于一个简单保守系统，相空间中的不变曲线就是其能量等值线，例如哈密顿量 $H(q,p)=E$ 所定义的曲线。通过从一个已知的椭圆截面出发反向推导其物理模型，你将亲手验证这一核心原理，并深刻理解这些几何形状如何直接描绘系统的能量景观。[@problem_id:2427582]", "problem": "考虑一个具有单自由度的不含时哈密顿系统，其正则坐标为 $(q,p)$。对于此类系统，在 Poincaré 截面上观察到的不变曲线与哈密顿量在 $(q,p)$ 平面上的恒定能量等值线重合。在某一特定能量下，实验获得的 Poincaré 截面显示出一条由椭圆方程给出的不变曲线：\n$$(\\tfrac{q}{2})^{2}+(\\tfrac{p}{3})^{2}=1.$$\n假设使用无量纲单位，质量为单位质量，且哈密顿量是可分离为动能和势能的最简单的正定二次型，\n$$H(q,p)=\\tfrac{1}{2}p^{2}+\\tfrac{1}{2}k q^{2},$$\n其中 $k>0$ 待定，需使得给定的椭圆恰好是其一条恒能曲线。确定 $H(q,p)$ 的显式闭合形式表达式。\n\n请用 $(q,p)$ 的单个解析表达式给出最终答案，使用无量纲单位。无需四舍五入。", "solution": "对问题陈述进行严格验证。\n\n步骤 1：提取已知条件。\n- 一个具有单自由度的不含时哈密顿系统，其正则坐标为 $(q,p)$。\n- 来自 Poincaré 截面的一条特定不变曲线由椭圆方程给出：$(\\frac{q}{2})^{2}+(\\frac{p}{3})^{2}=1$。\n- 假设使用无量纲单位，质量为单位质量。哈密顿量的形式为 $H(q,p)=\\frac{1}{2}p^{2}+\\frac{1}{2}k q^{2}$。\n- 参数 $k$ 为正，即 $k>0$。\n- 任务是找到 $H(q,p)$ 的显式闭合形式表达式。\n\n步骤 2：使用提取的已知条件进行验证。\n- 科学依据：该问题描述了一个简谐振子，这是经典力学中的一个基本模型。相空间中的恒能面与系统轨迹之间的对应关系是哈密顿动力学的核心原则。所给定的哈密顿量形式对于单位质量的谐振子是标准形式。该问题在科学上是合理的。\n- 适定性：该问题提供了一个带有一个未知参数 $k$ 的哈密顿量函数形式，以及一个约束条件（特定能级集的方程）。这些信息足以唯一确定 $k$ 和哈密顿量。该问题是适定的。\n- 客观性：该问题以精确、定量的术语陈述，没有歧义或主观论断。\n\n步骤 3：结论与行动。\n该问题是有效的，因为它在科学上合理、适定、客观，并包含足够的信息以获得唯一解。我将继续推导解答。\n\n问题陈述，对于一个单自由度的不含时哈密顿系统，相空间中的恒定能量等值线就是不变曲线。哈密顿量以简谐振子的形式给出：\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{1}{2}k q^{2}$$\n其中 $k>0$ 是一个待定常数。一条恒能曲线由方程 $H(q,p) = E$ 定义，其中 $E$ 为某个恒定能量。\n$$\\frac{1}{2}p^{2} + \\frac{1}{2}k q^{2} = E$$\n由于哈密顿量是平方和且 $k>0$，它是一个正定二次型。对于给定的非平凡椭圆，能量必须为正，即 $E>0$。为了将此方程与椭圆的标准形式进行比较，我们两边同除以 $E$：\n$$\\frac{p^{2}}{2E} + \\frac{k q^{2}}{2E} = 1$$\n该方程可以重写为椭圆的典范式 $\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1$：\n$$\\left(\\frac{q}{\\sqrt{\\frac{2E}{k}}}\\right)^{2} + \\left(\\frac{p}{\\sqrt{2E}}\\right)^{2} = 1$$\n该方程描述了对于给定哈密顿量形式的所有可能的恒能曲线族。\n\n问题提供了一条实验确定的不变曲线，它必须对应于一个特定的能级。该曲线的方程为：\n$$\\left(\\frac{q}{2}\\right)^{2} + \\left(\\frac{p}{3}\\right)^{2} = 1$$\n通过比较这两个椭圆表达式，我们可以令 $q$ 和 $p$ 方向的半轴相等。\n$q$ 方向的半轴给出方程：\n$$\\sqrt{\\frac{2E}{k}} = 2$$\n$p$ 方向的半轴给出方程：\n$$\\sqrt{2E} = 3$$\n这为两个未知数 $E$ 和 $k$ 提供了一个包含两个方程的方程组。从第二个方程，我们可以解出这条特定不变曲线的能量 $E$。两边平方得到：\n$$2E = 9 \\implies E = \\frac{9}{2}$$\n现在，我们将这个 $E$ 的值代入第一个方程来求解 $k$：\n$$\\sqrt{\\frac{2\\left(\\frac{9}{2}\\right)}{k}} = 2$$\n$$\\sqrt{\\frac{9}{k}} = 2$$\n将此方程两边平方得到：\n$$\\frac{9}{k} = 4$$\n解出 $k$，我们得到：\n$$k = \\frac{9}{4}$$\n这个值满足条件 $k>0$。问题要求的是哈密顿量 $H(q,p)$ 的显式闭合形式表达式，而不是所观察到的特定曲线的能量。我们现在将已确定的 $k$ 值代回哈密顿量的一般形式：\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{1}{2}\\left(\\frac{9}{4}\\right)q^{2}$$\n简化此表达式得到哈密顿量的最终形式：\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{9}{8}q^{2}$$\n这就是当 $E = \\frac{9}{2}$ 时，生成给定椭圆作为其恒能曲线的哈密顿量。", "answer": "$$\\boxed{\\frac{1}{2}p^{2} + \\frac{9}{8}q^{2}}$$", "id": "2427582"}, {"introduction": "在理解了简单系统中的直接联系后，我们来挑战一个更复杂的混沌系统。本练习将指导你完成为经典的 Hénon-Heiles 模型生成庞加莱截面的完整计算流程。你将实践常微分方程 ($ODE$) 的数值积分和事件检测，这些都是探索混沌动力学中涌现出的复杂分形结构所必需的核心计算技能。[@problem_id:2427559]", "problem": "考虑一个无量纲单位下的双自由度 Hénon-Heiles 哈密顿系统，\n$$\nH(q_1,q_2,p_1,p_2) = \\frac{1}{2}\\left(p_1^2 + p_2^2 + q_1^2 + q_2^2\\right) + q_1^2 q_2 - \\frac{1}{3} q_2^3.\n$$\n其运动方程源于哈密顿方程。在 $(q_2,p_2)$ 子空间中定义一个单参数旋转截面坐标族，由下式给出：\n$$\n\\begin{pmatrix}\nu \\\\\nv\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos \\theta & \\sin \\theta \\\\\n- \\sin \\theta & \\cos \\theta\n\\end{pmatrix}\n\\begin{pmatrix}\nq_2 \\\\\np_2\n\\end{pmatrix},\n$$\n其中角度 $\\theta$ 以弧度为单位。Poincaré 截面超曲面由条件 $u=0$ 定义，其横向穿越方向受限于 $v>0$。在每次此类穿越时，记录点对 $(q_1,p_1)$。\n\n对于给定的总能量 $E>0$，按如下方式在能量壳上构造初始条件。固定 $q_1(0)=0$。选择一个小的正振幅 $\\alpha$ 和一个小的偏移量 $\\delta$，并设置\n$$\nq_2^{\\star} = -\\alpha \\sin \\theta, \\quad p_2^{\\star} = \\alpha \\cos \\theta,\n$$\n然后施加一个位移\n$$\nq_2(0) = q_2^{\\star} - \\delta \\cos \\theta, \\quad p_2(0) = p_2^{\\star} - \\delta \\sin \\theta,\n$$\n使得 $u(0) = -\\delta  0$ 且 $v(0)=\\alpha > 0$。通过取正根，由能量约束 $H(q_1(0),q_2(0),p_1(0),p_2(0))=E$ 来确定 $p_1(0)$，\n$$\np_1(0) = \\sqrt{\\,2\\left[E - \\left(\\frac{1}{2}\\left(q_1(0)^2 + q_2(0)^2\\right) + q_1(0)^2 q_2(0) - \\frac{1}{3}q_2(0)^3\\right) - \\frac{1}{2}p_2(0)^2\\right]\\,}.\n$$\n演化轨迹并检测在 $t>0$ 时（不包括 $t=0$）前 $N$ 个满足 $v>0$ 的穿越超曲面 $u=0$ 的事件。在每次此类穿越时，收集相应的 $(q_1,p_1)$ 点对。\n\n角度 $\\theta$ 必须以弧度为单位指定。所有量纲均与上述哈密顿量使用相同的无量纲单位。每个测试用例所需的输出是前 $N$ 个记录的点对 $(q_1,p_1)$ 的列表，其中每个数字都四舍五入到六位小数。\n\n使用以下测试套件，它为每个案例指定了 $(E,\\theta,\\alpha,\\delta,T,N)$，其中 $T$ 是最大积分时间，$N$ 是要返回的穿越次数：\n- 案例 A（一般角度截面）： $(0.118,\\ \\pi/6,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$.\n- 案例 B（边界方向 $\\theta=0$）： $(0.125,\\ 0,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$.\n- 案例 C（接近逃逸阈值 $E \\approx 1/6$）： $(0.166,\\ 1.2,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$.\n- 案例 D（边界方向 $\\theta=\\pi/2$）： $(0.10,\\ \\pi/2,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$.\n\n您的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果本身是一个包含 $N$ 个双元素列表 $[q_1,p_1]$ 的列表，每个浮点数都四舍五入到六位小数。确切格式为\n$$\n\\big[\\, [ [q_{1,1},p_{1,1}], \\dots, [q_{1,N},p_{1,N}] ],\\ [ [q_{2,1},p_{2,1}], \\dots, [q_{2,N},p_{2,N}] ],\\ [ [q_{3,1},p_{3,1}], \\dots, [q_{3,N},p_{3,N}] ],\\ [ [q_{4,1},p_{4,1}], \\dots, [q_{4,N},p_{4,N}] ] \\,\\big],\n$$\n该行中任何地方都不能有空格。角度以弧度为单位，所有物理量均为无量纲。将所有报告的数字四舍五入到六位小数。", "solution": "该问题是有效的。它提出了一个计算物理学中明确定义的任务，具体是使用 Poincaré 截面分析 Hénon-Heiles 系统。该问题具有科学依据、内容自洽，并且所有参数和初始条件都得到了明确的指定。\n\nHénon-Heiles 系统由以下哈密顿量描述：\n$$\nH(q_1, q_2, p_1, p_2) = \\frac{1}{2}(p_1^2 + p_2^2 + q_1^2 + q_2^2) + q_1^2 q_2 - \\frac{1}{3} q_2^3\n$$\n系统的动力学由哈密顿方程 $\\dot{q}_i = \\partial H / \\partial p_i$ 和 $\\dot{p}_i = -\\partial H / \\partial q_i$ 控制。对于状态向量 $\\mathbf{y}(t) = [q_1(t), q_2(t), p_1(t), p_2(t)]^T$，这些方程为：\n$$\n\\begin{aligned}\n\\dot{q}_1 = p_1 \\\\\n\\dot{q}_2 = p_2 \\\\\n\\dot{p}_1 = -q_1 - 2q_1 q_2 = -q_1(1 + 2q_2) \\\\\n\\dot{p}_2 = -q_2 - q_1^2 + q_2^2\n\\end{aligned}\n$$\n这构成了一个由四个耦合的一阶常微分方程 (ODEs) 组成的系统。总能量 $E = H(\\mathbf{y}(t))$ 是一个守恒量，这一事实可用于监控数值积分的准确性。\n\nPoincaré 截面定义在相空间的一个超曲面上。在此问题中，该截面在 $(q_2, p_2)$ 子空间的一个旋转坐标系中定义：\n$$\n\\begin{pmatrix} u \\\\ v \\end{pmatrix} = \\begin{pmatrix} \\cos \\theta  \\sin \\theta \\\\ -\\sin \\theta  \\cos \\theta \\end{pmatrix} \\begin{pmatrix} q_2 \\\\ p_2 \\end{pmatrix}\n$$\n截面由条件 $u = q_2 \\cos \\theta + p_2 \\sin \\theta = 0$ 给出。只有当穿越事件满足附加条件 $v = -q_2 \\sin \\theta + p_2 \\cos \\theta > 0$ 时才被记录。\n\n求解方法涉及将运动方程的数值积分与事件检测机制相结合，以识别轨迹何时穿过 Poincaré 截面。步骤如下：\n\n1.  **初始化**：对于由参数 $(E, \\theta, \\alpha, \\delta, T, N)$ 指定的每个测试用例，构造初始状态向量 $\\mathbf{y}(0) = [q_1(0), q_2(0), p_1(0), p_2(0)]^T$。\n    -   $q_1(0) = 0$.\n    -   $q_2(0) = -\\alpha \\sin \\theta - \\delta \\cos \\theta$.\n    -   $p_2(0) = \\alpha \\cos \\theta - \\delta \\sin \\theta$.\n    -   $p_1(0)$ 通过求解能量守恒方程 $H(\\mathbf{y}(0)) = E$ 并取其正根来确定：\n        $$\n        p_1(0) = \\sqrt{2E - p_2(0)^2 - q_2(0)^2 + \\frac{2}{3}q_2(0)^3}\n        $$\n    构造的初始状态使得 $u(0) = -\\delta  0$，这意味着我们关心的是轨迹从 $u0$ 区域移动到 $u>0$ 区域的穿越事件。\n\n2.  **数值积分**：从 $t=0$ 到最大时间 $t=T$，对常微分方程组进行时间上的正向积分。由于混沌系统对初始条件和积分误差高度敏感，因此需要高阶自适应步长积分器来保证精度。带有 `DOP853` 方法和严格误差容限（例如，相对容限 $rtol=10^{-11}$ 和绝对容限 $atol=10^{-12}$）的 `scipy.integrate.solve_ivp` 函数适合此目的。\n\n3.  **事件检测**：使用 `solve_ivp` 积分器的事件检测功能来寻找 $u(t_i) = 0$ 的时间点 $t_i > 0$。事件函数为 $g(t, \\mathbf{y}) = u(q_2(t), p_2(t)) = y_2(t) \\cos\\theta + y_4(t) \\sin\\theta$。我们指定一个正向穿越方向，这意味着只有当 $g(t, \\mathbf{y})$ 从负值穿越零到正值时，事件才被触发。这对应于轨迹以 $\\dot{u}>0$ 的方式刺穿截面。\n\n4.  **数据收集**：对于在时间 $t_i$ 找到的每个事件，评估系统在该时间点的状态 $\\mathbf{y}(t_i)$。然后检查条件 $v(t_i) > 0$。如果满足此条件，则记录点对 $(q_1(t_i), p_1(t_i))$。重复此过程，直到收集到 $N$ 个这样的点对。\n\n5.  **输出格式化**：将每个测试用例收集到的点对四舍五入到六位小数，并格式化为指定的字符串表示形式。\n\n具体实现将包括一个用于 Hénon-Heiles 运动方程的函数，一个用于定义依赖于参数的事件函数 $u(t)$ 的函数或类，以及一个根据上述步骤处理每个测试用例的主循环。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the Poincaré section points of the Hénon-Heiles system for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (E, theta, alpha, delta, T, N)\n    test_cases = [\n        (0.118, np.pi/6, 0.05, 1e-6, 200, 5),\n        (0.125, 0.0, 0.05, 1e-6, 200, 5),\n        (0.166, 1.2, 0.05, 1e-6, 200, 5),\n        (0.10, np.pi/2, 0.05, 1e-6, 200, 5),\n    ]\n\n    all_results_str = []\n\n    def henon_heiles_eom(t, y):\n        \"\"\"\n        Equations of motion for the Hénon-Heiles system.\n        y = [q1, q2, p1, p2]\n        \"\"\"\n        q1, q2, p1, p2 = y\n        dq1_dt = p1\n        dq2_dt = p2\n        dp1_dt = -q1 * (1 + 2 * q2)\n        dp2_dt = -q2 - q1**2 + q2**2\n        return [dq1_dt, dq2_dt, dp1_dt, dp2_dt]\n\n    for E, theta, alpha, delta, T, N in test_cases:\n        # Calculate initial conditions\n        sin_theta, cos_theta = np.sin(theta), np.cos(theta)\n        \n        q1_0 = 0.0\n        q2_0 = -alpha * sin_theta - delta * cos_theta\n        p2_0 = alpha * cos_theta - delta * sin_theta\n        \n        # Ensure argument of sqrt is non-negative\n        p1_0_sq_arg = 2 * E - p2_0**2 - q2_0**2 + (2/3) * q2_0**3\n        if p1_0_sq_arg  0:\n            # This should not happen with the given test cases\n            p1_0 = 0.0 \n        else:\n            p1_0 = np.sqrt(p1_0_sq_arg)\n\n        y0 = [q1_0, q2_0, p1_0, p2_0]\n\n        # Define event function for Poincare section\n        def poincare_section_event(t, y, theta):\n            q2, p2 = y[1], y[3]\n            return q2 * np.cos(theta) + p2 * np.sin(theta)\n        \n        poincare_section_event.terminal = False\n        poincare_section_event.direction = 1  # Detect crossing from negative to positive\n\n        # Integrate ODE\n        sol = solve_ivp(\n            fun=lambda t, y: henon_heiles_eom(t, y),\n            t_span=(0, T),\n            y0=y0,\n            method='DOP853',\n            events=lambda t, y: poincare_section_event(t, y, theta),\n            dense_output=True,\n            rtol=1e-11,\n            atol=1e-12,\n        )\n        \n        # Collect results\n        crossings = []\n        if sol.t_events[0].size > 0:\n            for t_event in sol.t_events[0]:\n                if len(crossings) >= N:\n                    break\n                y_event = sol.sol(t_event)\n                q1, q2, p1, p2 = y_event\n\n                # Check the v > 0 condition\n                v = -q2 * sin_theta + p2 * cos_theta\n                if v > 0:\n                    crossings.append([float(q1), float(p1)])\n\n        # Format the result for the current case\n        case_str = f\"[{','.join([f'[{p[0]:.6f},{p[1]:.6f}]' for p in crossings])}]\"\n        all_results_str.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n\n```", "id": "2427559"}, {"introduction": "计算结果的可靠性取决于你所使用的数值方法。这最后一个练习将探讨计算物理中的一个关键问题：积分器和步长的选择如何影响混沌系统（如 Duffing 振子）的模拟结果。通过定量比较不同方法生成的庞加莱截面，你将更深刻地体会到数值误差的存在，并理解为获得可靠的科学模拟而选择合适方法的重要性。[@problem_id:2427621]", "problem": "您将研究时间积分方法的选择如何影响受迫杜芬振子的庞加莱截面几何形状。杜芬振子由二阶方程 $$\\frac{d^2 x}{dt^2} + \\delta \\frac{dx}{dt} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t),$$ 导出的自治一阶系统所控制，该系统改写为 $$\\frac{dx}{dt} = v,\\quad \\frac{dv}{dt} = -\\delta v - \\alpha x - \\beta x^3 + \\gamma \\cos(\\phi),\\quad \\frac{d\\phi}{dt} = \\omega,$$ 其中 $x$ 是位移，$v$ 是速度，$\\phi$ 是驱动相位。相对于驱动的庞加莱截面是在 $\\phi$ 为 $2\\pi$ 整数倍的时刻采样的状态集。您的任务是实现并比较两种数值时间积分器，即显式欧拉法和经典的四阶龙格-库塔法，并量化它们的数值误差如何扭曲混沌杜芬吸引子的庞加莱截面。\n\n从常微分方程初值问题的基本定义、作为固定相位频闪采样的庞加莱映射概念，以及用于时间步进的确定性数值积分开始。除了应用于 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y},t)$ 的显式欧拉法和经典四阶龙格-库塔法的标准更新规则外，不要假定任何专用公式。\n\n对于杜芬振子中的混沌现象，请使用以下物理上合理且被广泛研究的参数集：$$\\alpha = -1.0,\\ \\beta = 1.0,\\ \\delta = 0.3,\\ \\gamma = 0.37,\\ \\omega = 1.2.$$ 使用初始条件 $$x(0) = 0,\\ v(0) = 0,\\ \\phi(0) = 0.$$ 将 $t$ 解释为秒，$\\phi$ 解释为弧度，并将 $x$ 和 $v$ 视为无量纲。通过检测与 $k \\in \\mathbb{Z}_{\\ge 1}$ 的 $\\phi = 2\\pi k$ 的连续穿越点来构建庞加莱截面，并使用时间步之间的线性插值来对精确穿越时刻的状态进行采样。丢弃前 $200$ 个穿越点作为暂态，然后收集接下来的 $300$ 个庞加莱点 $\\{(x_k, v_k)\\}$。\n\n为了量化两个庞加莱截面 $\\mathcal{A} = \\{(x_i, v_i)\\}_{i=1}^{N}$ 和 $\\mathcal{B} = \\{(x'_j, v'_j)\\}_{j=1}^{M}$ 之间的几何差异，请计算对称平均最近邻距离 $$D(\\mathcal{A},\\mathcal{B}) = \\tfrac{1}{2}\\left(\\frac{1}{N}\\sum_{i=1}^{N} \\min_{1 \\le j \\le M} \\sqrt{(x_i - x'_j)^2 + (v_i - v'_j)^2} + \\frac{1}{M}\\sum_{j=1}^{M} \\min_{1 \\le i \\le N} \\sqrt{(x'_j - x_i)^2 + (v'_j - v_i)^2}\\right).$$\n\n为上述自治系统同时实现显式欧拉法和经典的四阶龙格-库塔法，并为以下四个测试用例计算庞加莱截面。在所有情况下，将 $D(\\mathcal{A},\\mathcal{B})$ 报告为一个四舍五入到 $6$ 位小数的浮点数。时间步长 $h$ 以秒为单位。\n\n测试套件：\n- 用例 1 (正常情况)：比较步长 $h = 0.02$ 时的显式欧拉法与经典四阶龙格-库塔法。\n- 用例 2 (更粗步长)：比较步长 $h = 0.05$ 时的显式欧拉法与经典四阶龙格-库塔法。\n- 用例 3 (方法一致性控制)：比较步长 $h = 0.02$ 的经典四阶龙格-库塔法与步长 $h = 0.01$ 的经典四阶龙格-库塔法。\n- 用例 4 (欧拉法自洽性)：比较步长 $h = 0.02$ 的显式欧拉法与步长 $h = 0.01$ 的显式欧拉法。\n\n角度单位必须是弧度。最终输出必须是四个浮点数，每个浮点数等于相应情况下四舍五入到 $6$ 位小数的 $D(\\mathcal{A},\\mathcal{B})$ 值。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4]”），不含任何附加文本。\n\n确保科学真实性：使用线性插值、确定性步进和所述参数值精确构建庞加莱截面的相位穿越点，并以双精度执行所有计算。每个测试用例的答案都是无单位的浮点数，因为它们是无量纲 $(x,v)$ 平面中的距离。在整个过程中，角度必须以弧度为单位，时间必须以秒为单位。", "solution": "所提出的问题要求通过分析两种数值积分方案——显式欧拉法和经典四阶龙格-库塔法——对计算出的受迫杜芬振子庞加莱截面的影响，来进行定量比较。此分析属于计算动力学领域以及混沌系统模拟中数值伪影的研究范畴。该问题定义明确，有科学依据，并为严谨的解决方案提供了所有必要的规范。\n\n基础物理系统是受迫杜芬振子，这是一个关于位移 $x(t)$ 的二阶非线性常微分方程（ODE）：\n$$\n\\frac{d^2 x}{dt^2} + \\delta \\frac{dx}{dt} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t)\n$$\n为便于数值积分，通过定义状态向量 $\\mathbf{y}(t) = [x(t), v(t), \\phi(t)]^T$，该方程被转换为一个由三个一阶常微分方程组成的自治系统。其中，$v = dx/dt$ 是速度，$\\phi = \\omega t$ 是外部驱动的相位。该系统由 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 给出：\n$$\n\\frac{dx}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = -\\delta v - \\alpha x - \\beta x^3 + \\gamma \\cos(\\phi)\n$$\n$$\n\\frac{d\\phi}{dt} = \\omega\n$$\n问题指定了产生混沌行为的参数：$\\alpha = -1.0$，$\\beta = 1.0$，$\\delta = 0.3$，$\\gamma = 0.37$ 和 $\\omega = 1.2$。初始条件设置为 $\\mathbf{y}(0) = [0, 0, 0]^T$。\n\n采用数值积分方法在离散时间步长上近似求解轨迹 $\\mathbf{y}(t)$。我们考虑一个时间步长 $h$。在时间 $t_{n+1} = t_n + h$ 的状态由在时间 $t_n$ 的状态近似得出。\n\n首先，显式欧拉法是一种一阶方法，其更新规则定义为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\cdot \\mathbf{f}(\\mathbf{y}_n)\n$$\n此方法简单，但其局部截断误差为 $O(h^2)$ 阶，全局误差为 $O(h)$ 阶，这使得它对于刚性或混沌系统而言相对不准确且可能不稳定。\n\n其次，经典四阶龙格-库塔法（RK4）提供了一个更精确的近似。它是一种四阶方法，全局误差为 $O(h^4)$ 阶。其更新规则由下式给出：\n$\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$\n其中中间斜率为：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1)\n$$\n$$\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2)\n$$\n$$\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h \\mathbf{k}_3)\n$$\n\n庞加莱截面提供了一种在较低维度空间中可视化系统动力学的方法。对于这个周期性驱动系统，我们使用频闪映射，在驱动相位 $\\phi$ 每次穿过 $2\\pi$ 的倍数时对状态 $(x, v)$ 进行采样。由于 $\\phi(0)=0$ 且 $\\dot{\\phi}=\\omega$ 是一个正常数，我们监测轨迹并在时刻 $t_k$ 记录状态，使得对于整数 $k \\ge 1$，有 $\\phi(t_k) = 2\\pi k$。一个从 $t_n$ 时刻的 $\\mathbf{y}_n$ 到 $t_{n+1}$ 时刻的 $\\mathbf{y}_{n+1}$ 的数值时间步长可能会跨越这样一个穿越点。如果对于某个整数 $k$，有 $\\phi_n  2\\pi k \\le \\phi_{n+1}$，则发生了一次穿越。庞加莱截面上的状态 $(x^*, v^*)$ 是通过线性插值找到的。插值因子 $\\theta \\in [0, 1]$ 由相位计算得出：\n$$\n\\theta = \\frac{2\\pi k - \\phi_n}{\\phi_{n+1} - \\phi_n}\n$$\n插值后的状态则为：\n$$\nx^* = (1 - \\theta)x_n + \\theta x_{n+1}\n$$\n$$\nv^* = (1 - \\theta)v_n + \\theta v_{n+1}\n$$\n丢弃前 $200$ 个点以确保轨迹已经稳定在吸引子上，然后收集随后的 $300$ 个点以形成庞加莱截面。\n\n为了量化两个庞加莱截面 $\\mathcal{A} = \\{(x_i, v_i)\\}_{i=1}^{N}$ 和 $\\mathcal{B} = \\{(x'_j, v'_j)\\}_{j=1}^{M}$（其中 $N = M = 300$）之间的几何差异，我们计算指定的对称平均最近邻距离 $D(\\mathcal{A},\\mathcal{B})$：\n$$\nD(\\mathcal{A},\\mathcal{B}) = \\frac{1}{2}\\left(\\frac{1}{N}\\sum_{i=1}^{N} \\min_{1 \\le j \\le M} \\|\\mathbf{p}_i - \\mathbf{p}'_j\\|_2 + \\frac{1}{M}\\sum_{j=1}^{M} \\min_{1 \\le i \\le N} \\|\\mathbf{p}'_j - \\mathbf{p}_i\\|_2\\right)\n$$\n其中 $\\mathbf{p}_i = (x_i, v_i)$ 和 $\\mathbf{p}'_j = (x'_j, v'_j)$，$\\|\\cdot\\|_2$ 是欧几里得距离。该度量计算一个集合中每个点到另一个集合中最近邻点的平均距离，并对结果进行对称化。它提供了一个稳健的度量，用于衡量两个点云的对齐程度。\n\n整个算法流程如下：对于四个测试用例中的每一个，我们使用指定的方法和时间步长生成两个庞加莱截面。对于每个截面，我们从初始条件积分系统，检测相位穿越，进行插值以找到经过 $200$ 个暂态点后的 $300$ 个吸引子点，并存储这些点。然后，我们计算两个生成的点集之间的距离 $D(\\mathcal{A}, \\mathcal{B})$，并报告四舍五入到 $6$ 位小数的值。此过程系统地评估了数值方法选择和步长对混沌吸引子几何结构的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Computes Poincaré sections of the Duffing oscillator and compares them\n    using a symmetric average nearest-neighbor distance.\n    \"\"\"\n\n    def generate_poincare_section(method, h, params):\n        \"\"\"\n        Generates a Poincaré section for the Duffing oscillator using a specified\n        integration method and step size.\n\n        Args:\n            method (str): The integration method, 'euler' or 'rk4'.\n            h (float): The time step.\n            params (dict): Dictionary of oscillator parameters.\n\n        Returns:\n            numpy.ndarray: An array of shape (300, 2) containing the (x, v)\n                           coordinates of the Poincaré section points.\n        \"\"\"\n        alpha = params['alpha']\n        beta = params['beta']\n        delta = params['delta']\n        gamma = params['gamma']\n        omega = params['omega']\n\n        def f(y):\n            \"\"\"The ODE function dy/dt = f(y) for the Duffing system.\"\"\"\n            x, v, phi = y\n            dxdt = v\n            dvdt = -delta * v - alpha * x - beta * x**3 + gamma * np.cos(phi)\n            dphidt = omega\n            return np.array([dxdt, dvdt, dphidt], dtype=np.float64)\n\n        y = np.array([0.0, 0.0, 0.0], dtype=np.float64)  # Initial state [x, v, phi]\n\n        poincare_points = []\n        num_transient = 200\n        total_points = num_transient + 300\n        \n        two_pi = 2.0 * np.pi\n\n        while len(poincare_points)  total_points:\n            y_prev = y\n            \n            if method == 'euler':\n                y = y_prev + h * f(y_prev)\n            elif method == 'rk4':\n                k1 = f(y_prev)\n                k2 = f(y_prev + 0.5 * h * k1)\n                k3 = f(y_prev + 0.5 * h * k2)\n                k4 = f(y_prev + h * k3)\n                y = y_prev + (h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            \n            phi_prev = y_prev[2]\n            phi_curr = y[2]\n\n            crossings_prev_count = np.floor(phi_prev / two_pi)\n            crossings_curr_count = np.floor(phi_curr / two_pi)\n\n            if crossings_curr_count > crossings_prev_count:\n                for k in range(int(crossings_prev_count) + 1, int(crossings_curr_count) + 1):\n                    if len(poincare_points) >= total_points:\n                        break\n                    \n                    phi_target = k * two_pi\n                    \n                    # Linear interpolation factor\n                    theta = (phi_target - phi_prev) / (phi_curr - phi_prev)\n                    \n                    # Interpolate x and v to the exact crossing time\n                    x_cross = y_prev[0] + theta * (y[0] - y_prev[0])\n                    v_cross = y_prev[1] + theta * (y[1] - y_prev[1])\n                    \n                    poincare_points.append([x_cross, v_cross])\n\n        return np.array(poincare_points[num_transient:], dtype=np.float64)\n\n    def compute_distance(set_A, set_B):\n        \"\"\"\n        Computes the symmetric average nearest-neighbor distance between two point sets.\n        \"\"\"\n        dist_matrix = cdist(set_A, set_B)\n        \n        nn_dist_A_to_B = np.min(dist_matrix, axis=1)\n        nn_dist_B_to_A = np.min(dist_matrix, axis=0)\n        \n        avg_A_to_B = np.mean(nn_dist_A_to_B)\n        avg_B_to_A = np.mean(nn_dist_B_to_A)\n        \n        return 0.5 * (avg_A_to_B + avg_B_to_A)\n\n    params = {\n        'alpha': -1.0, 'beta': 1.0, 'delta': 0.3,\n        'gamma': 0.37, 'omega': 1.2\n    }\n\n    test_cases = [\n        # Case 1: Euler h=0.02 vs RK4 h=0.02\n        {'method1': 'euler', 'h1': 0.02, 'method2': 'rk4', 'h2': 0.02},\n        # Case 2: Euler h=0.05 vs RK4 h=0.05\n        {'method1': 'euler', 'h1': 0.05, 'method2': 'rk4', 'h2': 0.05},\n        # Case 3: RK4 h=0.02 vs RK4 h=0.01\n        {'method1': 'rk4', 'h1': 0.02, 'method2': 'rk4', 'h2': 0.01},\n        # Case 4: Euler h=0.02 vs Euler h=0.01\n        {'method1': 'euler', 'h1': 0.02, 'method2': 'euler', 'h2': 0.01}\n    ]\n\n    # Pre-compute all required sections to avoid redundant calculations\n    computations_to_run = set()\n    for case in test_cases:\n        computations_to_run.add((case['method1'], case['h1']))\n        computations_to_run.add((case['method2'], case['h2']))\n    \n    generated_sections = {\n        (method, h): generate_poincare_section(method, h, params)\n        for method, h in computations_to_run\n    }\n    \n    results = []\n    for case in test_cases:\n        set_A = generated_sections[(case['method1'], case['h1'])]\n        set_B = generated_sections[(case['method2'], case['h2'])]\n        \n        dist = compute_distance(set_A, set_B)\n        results.append(f\"{dist:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2427621"}]}