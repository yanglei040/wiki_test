{"hands_on_practices": [{"introduction": "要理解分岔图，第一步是学习如何通过计算来生成它们。本实践将引导你完成一个核心算法：对参数 $r$ 进行采样，对每个 $r$ 值迭代映射以找到其长期行为，并收集这些点。这个练习利用一个特定的度量方法，来探索当参数分辨率增加时（模拟“放大”效应），计算出的分岔图会发生怎样的变化。[@problem_id:2376483]", "problem": "您需要通过在更高参数分辨率下重新计算一维逻辑斯蒂映射的分岔图，来计算其标量诊断量。这一过程模拟了对控制参数轴上某个区域的“放大”操作。考虑由逻辑斯蒂映射定义的离散时间动力系统\n$$\nx_{n+1} = r\\,x_n\\,(1 - x_n),\n$$\n其中 $r$ 是一个实值控制参数，对于迭代指数 $n \\in \\mathbb{N}$，$x_n \\in [0,1]$。对于给定的控制参数闭区间 $[r_{\\min}, r_{\\max}]$，定义一个包含 $N_r$ 个参数样本的均匀网格为\n$$\n\\{r_i\\}_{i=1}^{N_r},\\quad r_i = r_{\\min} + \\frac{i-1}{N_r-1}\\,(r_{\\max} - r_{\\min}),\n$$\n其中 $N_r \\in \\mathbb{N}$ 且 $N_r \\ge 1$。对于每个参数值 $r_i$，系统从一个初始条件 $x_0 \\in (0,1)$ 开始，总共迭代 $N_{\\text{trans}} + K$ 步，其中 $N_{\\text{trans}} \\in \\mathbb{N}$ 表示要舍弃的瞬态迭代次数，$K \\in \\mathbb{N}$ 表示要保留的后续迭代次数。对于每个 $r_i$，定义保留迭代值的均值为\n$$\n\\overline{x}(r_i) = \\frac{1}{K}\\sum_{j=1}^{K} x_{N_{\\text{trans}}+j}(r_i),\n$$\n其中 $x_{n}(r_i)$ 表示在参数 $r_i$ 下生成的序列。定义粗分辨率图均值为\n$$\nM_{\\text{coarse}} = \\frac{1}{N_r}\\sum_{i=1}^{N_r} \\overline{x}(r_i).\n$$\n为了模拟具有更高参数分辨率的“放大”重计算，在同一区间 $[r_{\\min}, r_{\\max}]$ 上定义一个精细化网格，其参数为\n$$\nN_r^{(\\text{refined})} = q\\,N_r,\n$$\n其中 $q \\in \\mathbb{N}$ 是一个精细化因子。使用相同的 $x_0$、$N_{\\text{trans}}$ 和 $K$，计算\n$$\nM_{\\text{refined}} = \\frac{1}{N_r^{(\\text{refined})}} \\sum_{i=1}^{N_r^{(\\text{refined})}} \\overline{x}(r_i^{(\\text{refined})})\n$$\n在精细化网格 $\\{r_i^{(\\text{refined})}\\}$ 上进行计算。对于每种情况，报告其绝对差\n$$\nD = \\left| M_{\\text{refined}} - M_{\\text{coarse}} \\right|.\n$$\n\n您的程序必须为以下每个测试用例计算 $D$，每个用例以有序七元组 $(r_{\\min}, r_{\\max}, N_r, q, N_{\\text{trans}}, K, x_0)$ 的形式给出：\n\n- 用例 $1$：$(2.8, 3.0, 200, 4, 800, 200, 0.5)$。\n- 用例 $2$：$(3.569, 3.571, 400, 5, 1200, 256, 0.5)$。\n- 用例 $3$：$(3.7, 3.8, 500, 3, 1000, 256, 0.5)$。\n- 用例 $4$：$(3.99, 4.0, 600, 2, 1000, 256, 0.5)$。\n- 用例 $5$：$(3.5, 3.5, 300, 1, 500, 128, 0.123456)$。\n\n以上所有实数均为无量纲。计算不涉及角度。对于每个用例，计算 $D$ 作为一个实数。您的程序应生成单行输出，其中包含这五个值，按上述用例顺序列出，形式为逗号分隔的列表，并用方括号括起来，例如\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5].\n$$", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于已建立的离散动力系统理论，特别是逻辑斯蒂映射，这是混沌研究中的一个典范模型。该问题是良构的，所有必要的参数、定义和函数都已明确无误地给出。所要求的计算是客观的，并且在计算上是可行的。未发现任何科学、逻辑或结构上的缺陷。\n\n任务是计算一个标量诊断量 $D$，它表示在更高参数分辨率下重新计算时，分岔图片段均值的变化。问题的核心在于对由以下递推关系给出的逻辑斯蒂映射进行数值模拟：\n$$\nx_{n+1} = r\\,x_n\\,(1 - x_n),\n$$\n针对一系列控制参数值 $r$。\n\n解决方案是围绕一个系统化且数值稳健的算法构建的。对于每个测试用例 $(r_{\\min}, r_{\\max}, N_r, q, N_{\\text{trans}}, K, x_0)$，总体流程是计算两个量，$M_{\\text{coarse}}$ 和 $M_{\\text{refined}}$，然后求出它们的绝对差。\n\n这些均值 $M$ 的计算被封装在一个专用函数中。该函数将参数区间 $[r_{\\min}, r_{\\max}]$、网格点数（$N_r$ 或 $N_r^{(\\text{refined})}$）、迭代次数 $N_{\\text{trans}}$ 和 $K$，以及初始条件 $x_0$ 作为输入。\n\n算法流程如下：\n$1$. 在区间 $[r_{\\min}, r_{\\max}]$ 上构建一个均匀的参数值网格 $\\{r_i\\}$。对于一个大小为 $N$ 的网格，点由 $r_i = r_{\\min} + \\frac{i-1}{N-1}\\,(r_{\\max} - r_{\\min})$ 给出，其中 $i=1, \\dots, N$。这一步通过 `numpy.linspace` 实现，该函数能正确生成此类网格。\n\n$2$. 对于网格中的每个参数值 $r_i$，对逻辑斯蒂映射进行迭代。此过程的结构旨在高效处理所需的大量计算。每个 $r_i$ 的计算是相互独立的。这种“易并行”结构是一个关键的观察点。我们利用 `numpy` 库提供的向量化操作来利用这一点。我们不使用缓慢的、先遍历每个 $r_i$ 再遍历时间的嵌套循环结构，而是使用一个状态向量 $X = [x(r_1), x(r_2), \\dots, x(r_{N})]^T$。整个状态向量在每个时间步 $n$ 根据逐元素操作 $X_{n+1} = R \\odot X_n \\odot (1 - X_n)$ 同步更新，其中 $R$ 是参数值向量，$\\odot$ 表示逐元素乘法。\n\n$3$. 对于每个 $r_i$，舍弃前 $N_{\\text{trans}}$ 个迭代值。这被称为瞬态阶段，它允许系统状态稳定到其吸引子上。在向量化实现中，这对应于对状态向量 $X$ 执行 $N_{\\text{trans}}$ 次更新。\n\n$4$. 瞬态阶段之后，生成接下来的 $K$ 个迭代值。这些迭代值，记为 $x_{N_{\\text{trans}}+j}(r_i)$（其中 $j=1, \\dots, K$），代表了系统在吸引子上的长期行为。对每个 $r_i$ 的这些值进行求和。\n\n$5$. 对于每个 $r_i$，通过将上一步得到的和除以 $K$ 来计算保留迭代值的均值 $\\overline{x}(r_i)$：\n$$\n\\overline{x}(r_i) = \\frac{1}{K}\\sum_{j=1}^{K} x_{N_{\\text{trans}}+j}(r_i).\n$$\n在向量化实现中，这对应于将和向量逐元素除以标量 $K$。\n\n$6$. 最终的图均值 $M$ 是通过对参数网格上所有单个的保留迭代均值 $\\overline{x}(r_i)$ 求平均来计算的：\n$$\nM = \\frac{1}{N}\\sum_{i=1}^{N} \\overline{x}(r_i).\n$$\n这一步通过对 $\\overline{x}(r_i)$ 值的向量使用 `numpy.mean` 来高效计算。\n\n整个过程针对粗网格参数（$N_r$ 个点）执行一次以获得 $M_{\\text{coarse}}$，然后针对精细化网格参数（$N_r^{(\\text{refined})} = q\\,N_r$ 个点）再执行一次以获得 $M_{\\text{refined}}$。测试用例的最终结果是绝对差 $D = |M_{\\text{refined}} - M_{\\text{coarse}}|$。在 $r_{\\min} = r_{\\max}$ 的特殊情况下，两个网格都由相同的点组成，导致 $M_{\\text{coarse}} = M_{\\text{refined}}$，因此 $D=0$，这是正确的。实现使用 64 位浮点运算 (`numpy.float64`) 来确保数值精度和稳健性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_diagram_mean(r_min, r_max, num_r, N_trans, K, x0):\n    \"\"\"\n    Computes the mean of retained-iterate means over a grid of parameters r.\n    This corresponds to M_coarse or M_refined in the problem statement.\n    The implementation is vectorized using numpy for efficiency.\n    \n    Args:\n        r_min (float): The minimum value of the control parameter r.\n        r_max (float): The maximum value of the control parameter r.\n        num_r (int): The number of points in the parameter grid.\n        N_trans (int): The number of transient iterations to discard.\n        K (int): The number of subsequent iterations to retain and average.\n        x0 (float): The initial condition for the iteration.\n\n    Returns:\n        float: The computed diagram mean (M_coarse or M_refined).\n    \"\"\"\n    # 1. Construct the uniform grid of parameter values {r_i}.\n    r_values = np.linspace(r_min, r_max, num=num_r, dtype=np.float64)\n\n    # Initialize the state vector x. Each element corresponds to a value in r_values.\n    x_values = np.full(num_r, x0, dtype=np.float64)\n\n    # 2. Iterate to discard transient states (transient phase).\n    # The calculation is vectorized across all r values.\n    # The logistic map equation is x_{n+1} = r * x_n * (1 - x_n).\n    for _ in range(N_trans):\n        x_values = r_values * x_values * (1.0 - x_values)\n\n    # 3. Iterate to collect retained states and compute their sum (retained phase).\n    sum_of_retained_x = np.zeros(num_r, dtype=np.float64)\n    for _ in range(K):\n        x_values = r_values * x_values * (1.0 - x_values)\n        sum_of_retained_x += x_values\n\n    # 4. Compute the mean of retained states for each r_i.\n    # This creates a vector of \\overline{x}(r_i).\n    retained_iterate_means = sum_of_retained_x / K\n\n    # 5. Compute the final mean M over all r_i values.\n    diagram_mean = np.mean(retained_iterate_means)\n\n    return diagram_mean\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (r_min, r_max, N_r, q, N_trans, K, x0)\n    test_cases = [\n        (2.8, 3.0, 200, 4, 800, 200, 0.5),\n        (3.569, 3.571, 400, 5, 1200, 256, 0.5),\n        (3.7, 3.8, 500, 3, 1000, 256, 0.5),\n        (3.99, 4.0, 600, 2, 1000, 256, 0.5),\n        (3.5, 3.5, 300, 1, 500, 128, 0.123456),\n    ]\n\n    results = []\n    for case in test_cases:\n        r_min, r_max, N_r, q, N_trans, K, x0 = case\n        \n        # Calculate M_coarse using the coarse grid parameters.\n        M_coarse = compute_diagram_mean(r_min, r_max, N_r, N_trans, K, x0)\n        \n        # Determine the size of the refined grid.\n        N_r_refined = q * N_r\n        \n        # Calculate M_refined using the refined grid parameters.\n        M_refined = compute_diagram_mean(r_min, r_max, N_r_refined, N_trans, K, x0)\n        \n        # Compute the absolute difference D.\n        D = abs(M_refined - M_coarse)\n        results.append(D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2376483"}, {"introduction": "在学会生成分岔图后，我们可以开始分析其关键特征。本练习聚焦于一种特定类型的分岔——叉式分岔(pitchfork bifurcation)，这是许多物理系统中一种基本的行为变化模式。通过对临界点附近的行为进行数值分析，你将学会如何提取“临界指数” $\\beta$——这是一个描述系统如何变化的普适性常数，它不依赖于系统的具体细节。[@problem_id:2376529]", "problem": "考虑一个一维系统，该系统经历一个由实参数 $r$ 控制的超临界叉式分岔。在临界值 $r_c$ 附近，该系统可以用范式表示为连续时间流 $dx/dt = (r-r_c)x - a x^3$ 或离散时间迭代映射 $x_{n+1} = r x_n - a x_n^3$，其中 $a>0$ 是一个实常数。在这两种情况下，不动点 $x^\\star$ 被定义为满足不动点方程的实数值：\n$$\n(r - r_c) x^\\star - a (x^\\star)^3 = 0.\n$$\n对于 $r>r_c$，对称破缺分支包含两个非零不动点 $x_+(r)>0$ 和 $x_-(r)<0$。定义这些新不动点之间的距离为\n$$\nd(r) = \\lvert x_+(r) - x_-(r) \\rvert.\n$$\n您的任务是数值确定临界指数 $\\beta$。根据以下关系式，该指数表征了当 $r \\downarrow r_c$ 时，$d(r)$ 如何随与临界点的距离 $(r-r_c)$ 进行标度变化：\n$$\nd(r) \\propto (r - r_c)^\\beta \\quad \\text{as } r \\downarrow r_c.\n$$\n对于下方的每个测试用例，使用指定的参数值列表 $r = r_c + \\varepsilon$（其中给定了 $\\varepsilon>0$），- 为所有列出的 $r$ 计算 $d(r)$，并根据这些数据为该测试用例生成 $\\beta$ 的单个数值估计。不涉及物理单位。\n\n测试套件（每个测试用例包含 $(r_c, a, \\{\\varepsilon\\})$）：\n- 测试用例 1: $r_c = 0$, $a = 1$, 且 $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$。\n- 测试用例 2: $r_c = 0$, $a = 2$, 且 $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$。\n- 测试用例 3: $r_c = 1$, $a = 1$, 且 $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$。\n- 测试用例 4: $r_c = -0.5$, $a = 3$, 且 $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$。\n\n对于每个测试用例：\n1. 对于每个列出的 $\\varepsilon$，设置 $r = r_c + \\varepsilon$。\n2. 仅使用上述不动点定义，找到两个非零不动点 $x_+(r)$ 和 $x_-(r)$ 并计算 $d(r)$。\n3. 从集合 $\\{(\\varepsilon, d(r_c+\\varepsilon))\\}$ 中，为该测试用例确定 $\\beta$ 的单个数值估计。\n\n您的程序应产生单行输出，其中包含 $\\beta$ 的四个估计值（每个测试用例一个，按上述顺序排列），四舍五入到三位小数，并以逗号分隔列表的形式用方括号括起来，例如 $[0.500,0.500,0.500,0.500]$。", "solution": "首先对问题陈述进行强制性验证程序。\n\n**步骤1：提取的已知条件**\n- **系统定义**：一个经历超临界叉式分岔的一维系统，由控制参数 $r$、临界值 $r_c$ 和一个正实常数 $a > 0$ 描述。\n- **不动点方程**：系统的不动点 $x^\\star$ 由方程 $(r - r_c) x^\\star - a (x^\\star)^3 = 0$ 定义。\n- **对称破缺不动点**：对于 $r > r_c$，存在两个非零不动点，记为 $x_+(r) > 0$ 和 $x_-(r) < 0$。\n- **距离定义**：这些点之间的距离是 $d(r) = \\lvert x_+(r) - x_-(r) \\rvert$。\n- **标度律**：断言当 $r$ 从上方趋近于 $r_c$ ($r \\downarrow r_c$) 时，距离 $d(r)$ 服从标度律 $d(r) \\propto (r - r_c)^\\beta$。\n- **目标**：为几个测试用例数值估计临界指数 $\\beta$。\n- **步骤**：对于每个测试用例 $(r_c, a, \\{\\varepsilon\\})$，计算点集 $\\{(\\varepsilon, d(r_c+\\varepsilon))\\}$，并由此为 $\\beta$ 生成单个估计值。\n- **测试用例**：\n    - 测试用例 1: ($r_c = 0$, $a = 1$, $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$).\n    - 测试用例 2: ($r_c = 0$, $a = 2$, $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$).\n    - 测试用例 3: ($r_c = 1$, $a = 1$, $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$).\n    - 测试用例 4: ($r_c = -0.5$, $a = 3$, $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$).\n\n**步骤2：验证**\n- **科学依据**：该问题基于超临界叉式分岔的范式，这是动力系统与混沌理论中的一个典范概念。在连续相变附近，使用临界指数 $\\beta$ 来表征序参量（此处由 $d(r)$ 代表）的标度行为，是统计力学和非线性物理中的标准做法。该问题在根本上是可靠的。\n- **良定性**：该问题是良定的。不动点方程是一个简单的代数方程，其求解是直接的。从幂律关系中估计指数是一个标准的数值练习。所有必要的参数和数据点都已提供。该问题是自洽且无歧义的。一个关于流与映射的不同不动点方程的潜在混淆点，因明确给出了要使用的方程——$(r - r_c) x^\\star - a (x^\\star)^3 = 0$——而变得无关紧要。\n\n**步骤3：结论**\n该问题有效。这是计算物理学中一个定义明确的练习，它同时考验了解析理解能力和数值计算熟练度。我们可以继续进行求解。\n\n**求解推导**\n\n求解需要两个阶段：首先是解析处理以理解理论基础，其次是设计数值程序以满足问题的具体要求。\n\n**1. 解析解**\n\n问题的核心在于不动点方程：\n$$\n(r - r_c) x^\\star - a (x^\\star)^3 = 0\n$$\n该方程可以因式分解为：\n$$\nx^\\star \\left( (r - r_c) - a (x^\\star)^2 \\right) = 0\n$$\n在 $r > r_c$（且给定 $a > 0$）的条件下，该方程产生三个不动点的实数解：\n1. 平凡不动点，对所有 $r$ 都存在：$x^\\star_0 = 0$。\n2. 来自第二个因子的两个非平凡不动点：$(r - r_c) - a (x^\\star)^2 = 0$。这给出 $(x^\\star)^2 = \\frac{r - r_c}{a}$。\n解是：\n$$\nx^\\star = \\pm \\sqrt{\\frac{r - r_c}{a}}\n$$\n这些是对称破缺不动点，我们将其识别为 $x_+(r)$ 和 $x_-(r)$：\n$$\nx_+(r) = \\sqrt{\\frac{r - r_c}{a}} \\quad \\text{和} \\quad x_-(r) = -\\sqrt{\\frac{r - r_c}{a}}\n$$\n这两点之间的距离 $d(r)$ 于是为：\n$$\nd(r) = |x_+(r) - x_-(r)| = \\left| \\sqrt{\\frac{r - r_c}{a}} - \\left(-\\sqrt{\\frac{r - r_c}{a}}\\right) \\right| = \\left| 2 \\sqrt{\\frac{r - r_c}{a}} \\right|\n$$\n由于 $r > r_c$ 且 $a > 0$，该表达式为实数且为正。因此：\n$$\nd(r) = \\frac{2}{\\sqrt{a}} (r - r_c)^{1/2}\n$$\n将此解析结果与所要求的标度形式 $d(r) \\propto (r - r_c)^\\beta$ 相比较，我们可以立即并精确地确定临界指数：\n$$\n\\beta = \\frac{1}{2}\n$$\n这个理论值对于任何由此范式描述的超临界叉式分岔都是普适的，与 $r_c$ 和 $a$ 的具体值无关。\n\n**2. 数值估计方法**\n\n问题要求对 $\\beta$ 进行数值估计。从幂律关系中确定指数的标准且稳健的方法是对该方程的对数形式进行线性回归。\n设标度关系为 $d = C \\cdot \\varepsilon^\\beta$，其中 $\\varepsilon = r - r_c$，$C$ 是一个比例常数（此处，$C=2/\\sqrt{a}$）。对两边取自然对数，可将方程线性化：\n$$\n\\ln(d) = \\ln(C \\cdot \\varepsilon^\\beta) = \\ln(C) + \\beta \\ln(\\varepsilon)\n$$\n这是一个直线方程 $Y = mX + b$，其中：\n- 因变量：$Y = \\ln(d(\\varepsilon))$\n- 自变量：$X = \\ln(\\varepsilon)$\n- 斜率：$m = \\beta$\n- 截距：$b = \\ln(C)$\n\n对于每个测试用例，我们都有一组给定的 $\\varepsilon$ 值。我们首先计算相应的 $d(r_c + \\varepsilon) = 2\\sqrt{\\varepsilon/a}$ 值。这就提供了一组数据点 $(\\varepsilon_i, d_i)$。然后，我们将这些点转换为它们的对数对应点 $(X_i, Y_i) = (\\ln(\\varepsilon_i), \\ln(d_i))$。\n\n通过这些对数数据点的最佳拟合直线的斜率 $\\beta$ 可用最小二乘法（线性回归）求得。对于一组 $N$ 个数据点 $(X_i, Y_i)$，斜率的公式是：\n$$\n\\beta = \\frac{N \\sum(X_i Y_i) - (\\sum X_i)(\\sum Y_i)}{N \\sum(X_i^2) - (\\sum X_i)^2}\n$$\n该实现将为4个测试用例中的每一个计算此值。由于数据点是由精确的解析公式生成的，因此不存在实验噪声或高阶项污染。因此，数值拟合得到的 $\\beta$ 值在浮点精度范围内必须等于 $0.5$。所有测试用例的计算应得出相同的指数，从而证实 $\\beta$ 的普适性。最终结果将按要求四舍五入到3位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the problem of numerically estimating the critical exponent beta\n    for a supercritical pitchfork bifurcation for four different test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (r_c, a, list_of_epsilons)\n    test_cases = [\n        (0.0, 1.0, [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2]),\n        (0.0, 2.0, [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2]),\n        (1.0, 1.0, [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2]),\n        (-0.5, 3.0, [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2]),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        r_c, a, epsilons = case\n        \n        # Convert list of epsilons to a numpy array for vectorized operations\n        eps_array = np.array(epsilons)\n        \n        # 1. Calculate d(r) for each epsilon\n        # The fixed-point equation is (r - r_c)x - ax^3 = 0.\n        # Let epsilon = r - r_c. Then epsilon*x - a*x^3 = 0.\n        # x(epsilon - ax^2) = 0.\n        # Non-zero solutions are x = +/- sqrt(epsilon/a).\n        # x_plus = sqrt(epsilon/a), x_minus = -sqrt(epsilon/a).\n        # d = |x_plus - x_minus| = 2 * sqrt(epsilon/a).\n        d_values = 2 * np.sqrt(eps_array / a)\n        \n        # 2. Prepare data for linear regression\n        # The scaling law is d = C * epsilon^beta.\n        # Taking the log: ln(d) = ln(C) + beta * ln(epsilon).\n        # This is a linear relationship. We fit ln(d) vs ln(epsilon).\n        # The slope of the line is the exponent beta.\n        log_eps = np.log(eps_array)\n        log_d = np.log(d_values)\n        \n        # 3. Perform linear regression to find the slope (beta)\n        # scipy.stats.linregress returns (slope, intercept, r-value, p-value, stderr)\n        lin_reg_result = stats.linregress(log_eps, log_d)\n        beta_estimate = lin_reg_result.slope\n        \n        results.append(beta_estimate)\n\n    # Final print statement in the exact required format.\n    # Results are rounded to three decimal places.\n    print(f\"[{','.join([f'{res:.3f}' for res in results])}]\")\n\nsolve()\n\n```", "id": "2376529"}, {"introduction": "由于计算机的有限精度，对混沌系统的计算模拟存在固有的局限性。本练习通过比较使用单精度（`float`）和双精度（`double`）数值模拟逻辑斯蒂映射，来探索“对初始条件的敏感依赖性”所带来的实际后果。这项实践突显了微小的数值误差如何在混沌区域导致宏观上的巨大差异，这是每位计算科学家都必须掌握的关键一课。[@problem_id:2376515]", "problem": "要求您通过比较在两种精度下获得的渐近分布，来量化数值浮点精度对混沌区逻辑斯蒂映射（logistic map）计算出的分岔图的影响。考虑由以下迭代定义的逻辑斯蒂映射\n$$\nx_{n+1} = f_r(x_n) = r\\,x_n\\,(1 - x_n),\n$$\n其中控制参数 $r \\in [0,4]$，状态 $x_n \\in [0,1]$。对于一个固定的 $r$，分岔图是当 $n \\to \\infty$ 时 $x_n$ 所访问的值的渐近集合。在实践中，这个集合可以通过在丢弃初始瞬态后对迭代值进行采样来近似。浮点精度会影响计算出的迭代值，从而影响分岔图。您将比较由电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) $754$ 标准化的二进制32位（单精度）和二进制64位（双精度）浮点格式下的结果。\n\n对于每个指定的 $r$ 值，您的程序必须实现以下步骤：\n- 使用固定的初始条件 $x_0 = 0.123456789$。\n- 对于每种精度（二进制32位和二进制64位），迭代逻辑斯蒂映射 $N_{\\mathrm{discard}} = 5000$ 步以丢弃瞬态，然后继续迭代 $N_{\\mathrm{keep}} = 4096$ 步以采样渐近行为。\n- 使用一个覆盖区间 $[0,1]$ 的含 $B = 256$ 个分箱的均匀直方图来近似 $[0,1]$ 上的渐近分布。设两种精度下的归一化直方图密度分别为 $\\{p_i\\}_{i=1}^{B}$ 和 $\\{q_i\\}_{i=1}^{B}$，其中归一化使得 $\\sum_{i=1}^{B} p_i \\,\\Delta = 1$ 和 $\\sum_{i=1}^{B} q_i \\,\\Delta = 1$，分箱宽度 $\\Delta = 1/B$。\n- 计算两个近似不变分布之间的差异，即离散 $L^1$ 距离\n$$\nD_{L^1}(r) = \\sum_{i=1}^{B} \\left| p_i - q_i \\right| \\, \\Delta.\n$$\n\n此问题不涉及任何物理单位或角度；所有量均为无量纲实数。为了数值的可复现性，将每个 $D_{L^1}(r)$ 四舍五入到 $6$ 位小数。\n\n测试套件：\n- 使用以下 $r$ 值，这些值探测了混沌区的不同深度以及一个边界情况：\n  - $r_1 = 3.6$\n  - $r_2 = 3.9$\n  - $r_3 = 3.99$\n  - $r_4 = 4.0$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 $[D_{L^1}(r_1), D_{L^1}(r_2), D_{L^1}(r_3), D_{L^1}(r_4)]$，每个值都四舍五入到 $6$ 位小数。例如，输出行应如下所示\n$$\n[\\text{value}_1,\\text{value}_2,\\text{value}_3,\\text{value}_4].\n$$\n每个条目唯一接受的数据类型是浮点数。不应打印任何额外的文本或行。", "solution": "所述问题是有效的。它有科学依据，算法上定义明确，并且为获得唯一的数值解提供了所有必要的参数。任务是计算用两种不同的浮点精度模拟逻辑斯蒂映射时，其渐近行为之间的差异。\n\n逻辑斯蒂映射是一个离散时间动力系统，由以下迭代方程定义：\n$$\nx_{n+1} = f_r(x_n) = r \\, x_n \\, (1 - x_n)\n$$\n其中 $n$ 是迭代指数，$x_n \\in [0, 1]$ 是系统在第 $n$ 步的状态，$r \\in [0, 4]$ 是控制参数。对于某些 $r$ 值，特别是在 $r \\gtrsim 3.57$ 的范围内，系统表现出混沌行为。在混沌区，系统对初始条件具有敏感依赖性，这意味着初始状态 $x_0$ 的无穷小差异会导致轨迹呈指数级发散。由有限精度浮点运算引入的数值舍入误差在每次迭代中都充当了这种微小差异，导致数值计算的轨迹偏离真实的数学轨迹，并且在使用不同精度时彼此之间也会发生偏离。\n\n目标是通过比较吸引子的近似不变概率分布来量化这种发散。对于每个给定的 $r$ 值，通过以下计算过程实现：\n\n1.  **并行模拟**：执行两次独立的逻辑斯蒂映射模拟。\n    - 第一次模拟使用单精度浮点数（根据 IEEE $754$ 标准的二进制32位格式），在指定的计算环境中对应于 `numpy.float32`。\n    - 第二次模拟使用双精度浮点数（二进制64位格式），对应于 `numpy.float64`。\n    - 为保持一致性，在每次模拟开始时，状态变量 $x_n$ 和参数 $r$ 都被显式转换为相应的精度。\n\n2.  **轨迹生成**：对于每种精度：\n    - 模拟从初始条件 $x_0 = 0.123456789$ 开始。\n    - 映射被迭代 $N_{\\mathrm{discard}} = 5000$ 步。这些初始迭代值被丢弃，以确保轨迹已收敛到系统的吸引子，并且不再受瞬态动力学的影响。\n    - 然后，映射再迭代 $N_{\\mathrm{keep}} = 4096$ 步。收集这些步骤中的状态值 $\\{x_n\\}$。这 $4096$ 个点构成了吸引子的一个数值样本。\n\n3.  **分布近似**：收集的样本用于近似吸引子的不变概率密度。\n    - 对两个收集到的数据系列（一个用于单精度，一个用于双精度）中的每一个，都构建一个直方图。\n    - 将域 $[0, 1]$ 划分为 $B = 256$ 个均匀的分箱，每个分箱的宽度为 $\\Delta = 1/B$。\n    - 直方图被归一化以表示概率密度，从而为单精度生成密度集 $\\{p_i\\}_{i=1}^{B}$，为双精度生成密度集 $\\{q_i\\}_{i=1}^{B}$。这种归一化确保了 $\\sum_{i=1}^{B} p_i \\Delta = 1$ 和 $\\sum_{i=1}^{B} q_i \\Delta = 1$。带有 `density=True` 参数的 `numpy.histogram` 函数能正确执行此归一化。\n\n4.  **差异计算**：使用离散 $L^1$ 距离来量化两个所得概率分布之间的差异，定义如下：\n    $$\n    D_{L^1}(r) = \\sum_{i=1}^{B} | p_i - q_i | \\Delta\n    $$\n    该度量对每个分箱的概率密度绝对差进行求和，并按分箱宽度加权。它提供了两个分布之间总变差的度量。$D_{L^1}(r)=0$ 的值表示分布相同，而 $D_{L^1}(r)=2$ 的值则对应于完全不相交的分布。\n\n对于每个测试的 $r$ 值，最终计算出的 $D_{L^1}(r)$ 值按要求四舍五入到 $6$ 位小数。该算法针对 $r$ 值的测试套件实现：$r_1 = 3.6$、$r_2 = 3.9$、$r_3 = 3.99$ 和 $r_4 = 4.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the L1 distance between asymptotic distributions of the logistic map\n    generated using single and double floating-point precision.\n    \"\"\"\n\n    def generate_series(r, x0, n_discard, n_keep, precision):\n        \"\"\"\n        Generates a time series from the logistic map for a given precision.\n\n        Args:\n            r (float): The control parameter of the logistic map.\n            x0 (float): The initial condition.\n            n_discard (int): The number of transient steps to discard.\n            n_keep (int): The number of steps to record for the series.\n            precision (type): The numpy float type (e.g., np.float32, np.float64).\n\n        Returns:\n            np.ndarray: The array of recorded state values.\n        \"\"\"\n        # Cast parameter and initial state to the specified precision.\n        r_prec = precision(r)\n        x = precision(x0)\n        one = precision(1.0)\n\n        # Discard the initial transient iterations.\n        for _ in range(n_discard):\n            x = r_prec * x * (one - x)\n\n        # Record the subsequent iterations to sample the attractor.\n        series = np.zeros(n_keep, dtype=precision)\n        for i in range(n_keep):\n            x = r_prec * x * (one - x)\n            series[i] = x\n\n        return series\n\n    # Problem parameters\n    test_cases = [3.6, 3.9, 3.99, 4.0]\n    initial_condition = 0.123456789\n    num_discard = 5000\n    num_keep = 4096\n    num_bins = 256\n\n    results = []\n\n    for r_val in test_cases:\n        # Generate time series for both single (32-bit) and double (64-bit) precision.\n        series_32 = generate_series(r_val, initial_condition, num_discard, num_keep, np.float32)\n        series_64 = generate_series(r_val, initial_condition, num_discard, num_keep, np.float64)\n\n        # Define histogram parameters.\n        hist_range = (0.0, 1.0)\n        bin_width = 1.0 / num_bins\n\n        # Compute normalized histograms (probability densities).\n        p_density, _ = np.histogram(series_32, bins=num_bins, range=hist_range, density=True)\n        q_density, _ = np.histogram(series_64, bins=num_bins, range=hist_range, density=True)\n        \n        # Calculate the discrete L1 distance.\n        l1_distance = np.sum(np.abs(p_density - q_density)) * bin_width\n\n        # Round the result to 6 decimal places.\n        results.append(round(l1_distance, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2376515"}]}