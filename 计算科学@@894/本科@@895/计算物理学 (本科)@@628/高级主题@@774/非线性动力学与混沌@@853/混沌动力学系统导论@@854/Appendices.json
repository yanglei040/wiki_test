{"hands_on_practices": [{"introduction": "尽管混沌系统的单个轨迹是不可预测的，但其长期行为通常遵循稳定的统计规律。我们可以将不变密度$p(x)$理解为系统在长时间演化后，在状态空间中某个点$x$附近被发现的概率。这个练习 [@problem_id:2403543] 将指导你通过计算机模拟，亲手验证这一核心概念，你会为逻辑斯谛映射在$r=4$的完全混沌状态下生成一个迭代值的分布直方图，并将其与已知的精确理论解进行比较，从而深刻理解混沌的统计特性。", "problem": "考虑由递推关系 $x_{n+1} = r\\,x_n(1 - x_n)$ 定义的一维逻辑斯蒂映射，其中 $r = 4$，初始条件为 $x_0 \\in (0,1)$。当 $r=4$ 时，已知这个离散时间动力系统在单位区间上表现出混沌行为。迭代值所访问的值的不变密度 $p(x)$ 由 $p(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}$ (对于 $x \\in (0,1)$) 给出，其他情况下 $p(x)=0$。对于给定的正整数 $B$，将 $[0,1]$ 均匀划分为 $B$ 个区间，其边界为 $0 = e_0 < e_1 < \\dots < e_B = 1$，其中 $e_k = \\frac{k}{B}$。将这些区间解释为半开区间 $[e_k, e_{k+1})$ (对于 $k = 0,1,\\dots,B-2$)，最后一个区间为 $[e_{B-1}, e_B]$。对于指定的非负整数老化期 $M$ 和正整数样本大小 $N$，生成迭代序列 $\\{x_{M+1}, x_{M+2}, \\dots, x_{M+N}\\}$，并构建经验区间概率向量 $\\mathbf{p}^{\\text{emp}} \\in \\mathbb{R}^B$，其第 $k$ 个分量是这 $N$ 个值中落入第 $k$ 个区间的比例。令理论区间概率向量 $\\mathbf{p}^{\\text{th}} \\in \\mathbb{R}^B$ 定义为\n$$\np^{\\text{th}}_k = \\int_{e_k}^{e_{k+1}} p(x)\\,dx \\quad \\text{对于 } k = 0,1,\\dots,B-1,\n$$\n其中 $p(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}$，并且用于计算该积分的任何反三角函数的角度单位必须是弧度。仅使用上述数学定义。对于下方的每个测试用例，计算标量\n$$\nE = \\sum_{k=0}^{B-1} \\left| p^{\\text{emp}}_k - p^{\\text{th}}_k \\right|,\n$$\n即经验与理论区间概率向量之间的 $\\ell^1$ 距离。\n\n您的程序必须为以下每个测试用例计算 $E$。在每个元组中，参数以 $(N, M, B, x_0)$ 的形式给出，其中 $r=4$ 固定不变：\n\n- 测试 1: $(N=\\;200000,\\; M=\\;5000,\\; B=\\;400,\\; x_0=\\;0.123456789)$。\n- 测试 2: $(N=\\;100000,\\; M=\\;1000,\\; B=\\;200,\\; x_0=\\;10^{-12})$。\n- 测试 3: $(N=\\;\\;\\;5000,\\; M=\\;\\;500,\\; B=\\;\\;50,\\; x_0=\\;0.37)$。\n- 测试 4: $(N=\\;100000,\\; M=\\;1000,\\; B=\\;200,\\; x_0=\\;0.999999123)$。\n\n所有迭代值和计算都是无量纲的。在适用的情况下，角度以弧度表示。要求的最终输出为一行，包含与上述测试相对应的四个 $E$ 值，每个值四舍五入到六位小数，形式为用方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_i$ 是小数点后有六位数字的十进制数。您的程序必须只输出此单行格式的内容。", "solution": "问题陈述经评估有效。它具有科学依据，提法恰当且客观。它提出了混沌动力系统研究中的一个标准计算练习，特别是逻辑斯蒂映射的遍历性质。唯一解所需的所有定义、参数和条件均已提供，无歧义或矛盾。我们将直接进行求解。\n\n该问题要求计算逻辑斯蒂映射的经验生成概率分布与其理论对应分布之间的 $\\ell^1$ 距离（表示为 $E$）。逻辑斯蒂映射由以下递推关系给出：\n$$\nx_{n+1} = r x_n (1 - x_n)\n$$\n其中参数 $r$ 固定为 $r=4$。对于由元组 $(N, M, B, x_0)$ 定义的每个测试用例，其中 $N$ 是样本大小，$M$ 是老化期计数，$B$ 是区间数量，$x_0$ 是初始条件，我们必须执行以下步骤。\n\n首先，我们必须生成经验数据。从初始条件 $x_0 \\in (0,1)$ 开始，我们迭代该映射。舍弃前 $M$ 个迭代值，以使系统状态收敛到吸引子，从而有效消除初始条件的瞬态效应。随后，我们生成并存储 $N$ 个迭代值，形成集合 $\\{x_{M+1}, x_{M+2}, \\dots, x_{M+N}\\}$。\n\n其次，我们构建经验概率向量 $\\mathbf{p}^{\\text{emp}} \\in \\mathbb{R}^B$。将区间 $[0,1]$ 划分为 $B$ 个均匀的区间。区间边界为 $e_k = k/B$ (对于 $k \\in \\{0, 1, \\dots, B\\}$)。第 $k$ 个区间（对于 $k \\in \\{0, 1, ..., B-1\\}$）是半开区间 $[e_k, e_{k+1})$，而最后一个区间则为 $[e_{B-1}, e_B]$。我们计算落入每个区间 $k$ 的迭代值数量 $c_k$。则区间 $k$ 的经验概率由以下分数给出：\n$$\np^{\\text{emp}}_k = \\frac{c_k}{N}\n$$\n\n第三，我们必须确定理论概率向量 $\\mathbf{p}^{\\text{th}} \\in \\mathbb{R}^B$。对于 $r=4$ 的逻辑斯蒂映射，其迭代值的不变概率密度函数已知为：\n$$\np(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}\n$$\n（对于 $x \\in (0,1)$）。一个迭代值落入区间 $k$ 的理论概率是该密度函数在该区间上的积分：\n$$\np^{\\text{th}}_k = \\int_{e_k}^{e_{k+1}} p(x) \\,dx = \\int_{k/B}^{(k+1)/B} \\frac{1}{\\pi\\sqrt{x(1-x)}} \\,dx\n$$\n该积分可以解析求解。令 $F(x)$ 为 $p(x)$ 的反导数。我们进行换元，$x = \\sin^2(\\theta)$，则 $dx = 2\\sin(\\theta)\\cos(\\theta)\\,d\\theta$。通过此换元，不定积分变为：\n$$\nF(x) = \\int \\frac{1}{\\pi\\sqrt{\\sin^2(\\theta)(1-\\sin^2(\\theta))}} (2\\sin(\\theta)\\cos(\\theta)\\,d\\theta) = \\int \\frac{2}{\\pi} \\,d\\theta = \\frac{2}{\\pi}\\theta + C\n$$\n代回 $\\theta = \\arcsin(\\sqrt{x})$，我们得到反导数：\n$$\nF(x) = \\frac{2}{\\pi}\\arcsin(\\sqrt{x})\n$$\n根据微积分基本定理，区间 $k$ 的理论概率为：\n$$\np^{\\text{th}}_k = F(e_{k+1}) - F(e_k) = \\frac{2}{\\pi} \\left( \\arcsin\\left(\\sqrt{\\frac{k+1}{B}}\\right) - \\arcsin\\left(\\sqrt{\\frac{k}{B}}\\right) \\right)\n$$\n根据规定，反正弦函数的角度单位均为弧度。\n\n最后，我们计算所需的误差度量 $E$，即两个概率向量之间的 $\\ell^1$ 距离：\n$$\nE = \\sum_{k=0}^{B-1} \\left| p^{\\text{emp}}_k - p^{\\text{th}}_k \\right|\n$$\n此过程被算法化实现，并应用于四个指定的测试用例。然后将结果按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted result.\n    \"\"\"\n\n    def calculate_error(N, M, B, x0):\n        \"\"\"\n        Calculates the error metric E for a single test case.\n\n        Args:\n            N (int): Sample size.\n            M (int): Burn-in count.\n            B (int): Number of bins.\n            x0 (float): Initial condition.\n\n        Returns:\n            float: The calculated L1 error E.\n        \"\"\"\n        r = 4.0\n\n        # Step 1: Generate the sequence of iterates for the logistic map.\n        # Use float64 for precision.\n        x = np.float64(x0)\n        \n        # Burn-in phase to let the system settle onto the attractor.\n        for _ in range(M):\n            x = r * x * (1.0 - x)\n\n        # Sampling phase.\n        iterates = np.zeros(N, dtype=np.float64)\n        for i in range(N):\n            x = r * x * (1.0 - x)\n            iterates[i] = x\n\n        # Step 2: Calculate the empirical probability vector p_emp.\n        # np.histogram correctly handles the half-open intervals on the right,\n        # which matches the problem's specification.\n        counts, _ = np.histogram(iterates, bins=B, range=(0.0, 1.0))\n        p_emp = counts / N\n\n        # Step 3: Calculate the theoretical probability vector p_th.\n        # The bin edges are e_k = k/B.\n        bin_edges = np.linspace(0.0, 1.0, B + 1, dtype=np.float64)\n        \n        # The antiderivative is F(x) = (2/pi) * arcsin(sqrt(x)).\n        # We evaluate F at all bin edges.\n        F_at_edges = (2.0 / np.pi) * np.arcsin(np.sqrt(bin_edges))\n        \n        # p_th_k = F(e_{k+1}) - F(e_k). This is vectorized for efficiency.\n        p_th = F_at_edges[1:] - F_at_edges[:-1]\n\n        # Step 4: Calculate the L1 error metric E.\n        E = np.sum(np.abs(p_emp - p_th))\n        \n        return E\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200000, 5000, 400, 0.123456789),\n        (100000, 1000, 200, 10**-12),\n        (5000, 500, 50, 0.37),\n        (100000, 1000, 200, 0.999999123),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, B, x0 = case\n        result = calculate_error(N, M, B, x0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2403543"}, {"introduction": "混沌系统的参数空间并非完全混乱，而是充满了复杂的结构。在混沌的“海洋”中，常常点缀着被称为“周期窗口”的有序“岛屿”，其中最著名的就是周期-3窗口。这个练习 [@problem_id:2403610] 不仅能帮助你精确地定位这些有序区域，更重要的是，它揭示了计算物理学中的一个关键挑战：如何区分真正的混沌与极高周期的轨道，并让你体会到高精度计算在研究动力系统时的必要性。", "problem": "您将使用高精度算术来研究逻辑斯谛映射，以分辨周期窗口和邻近的混沌行为。考虑由递推关系 $x_{n+1} = f_r(x_n)$ 定义的一维离散时间映射，其中 $f_r(x) = r\\,x\\,(1 - x)$，$r$ 是一个实值控制参数，且 $x_n \\in [0,1]$。如果一个点 $x^\\star$ 满足 $x^\\star = f_r(x^\\star)$，则该点是一个不动点。更一般地，一个（最小）周期为 $k$ 的周期轨道是一个由不同点组成的集合 $\\{x_0^\\star, x_1^\\star, \\dots, x_{k-1}^\\star\\}$，使得对所有 $i$ 都有 $f_r(x_i^\\star) = x_{(i+1)\\bmod k}^\\star$，并且不存在更小的正整数 $m < k$ 具有此性质。在数值计算中，如果一个轨道在经过一段暂态过程后，其序列在指定的容差范围内以周期 $k$ 重复，我们就说该轨道周期为 $k$。\n\n您的任务是编写一个完整的程序，针对著名的周期3窗口附近的几个指定 $r$ 值，使用高精度算术来确定吸引集的最小检测周期，并报告每种情况下的结果。程序必须遵守以下规范。\n\n- 数学模型与数值设置：\n  - 使用逻辑斯谛映射 $x_{n+1} = r\\,x_n\\,(1 - x_n)$。\n  - 对所有迭代值和中间运算使用至少80位十进制数字精度的以10为基数的高精度算术。\n  - 使用初始条件 $x_0 = 0.5$。\n  - 演化映射 $N_{\\text{trans}}$ 步（$N_{\\text{trans}} = 3000$）作为暂态过程，以接近吸引集。\n  - 暂态过程之后，收集连续 $L$ 个迭代值（$L = 2048$）用于周期检测。\n\n- 周期检测准则：\n  - 对于范围 $1 \\le k \\le K_{\\max}$（$K_{\\max} = 24$）内的每个候选周期 $k$，计算所收集数据块尾部段上的最大前向回归差异：\n    $$E(k) = \\max_{n \\in \\{L - M, L - M + 1, \\dots, L - 1 - k\\}} \\left| x_{n+k} - x_n \\right|,$$\n    其中 $M = 512$。\n  - 如果存在一个最小的 $k$ 使得 $E(k) < \\varepsilon$，则宣布检测到的周期为该 $k$。否则，为此测试目的，宣布轨道为非周期的，并报告 $0$。\n  - 使用容差 $\\varepsilon = 10^{-40}$。\n\n- 要求的输出：\n  - 对于每个参数 $r$，输出一个整数：根据上述规则检测到的最小周期 $k$，如果在 $K_{\\max}$ 内未检测到周期，则输出 $0$。\n  - 将所有测试用例的结果聚合到程序打印的单行中，格式为一个用方括号括起来的、无空格的逗号分隔列表。例如，包含五个结果的输出行必须具有 $[a,b,c,d,e]$ 的形式。\n\n- 角度单位：不适用，因为不涉及角度。\n\n- 测试套件：\n  使用以下参数值，这些值被选择用于探测周期3窗口附近不同区域的动态：\n  - 情况 A（略低于左边界，通常为混沌）：$r = 3.82830$。\n  - 情况 B（刚进入周期3窗口的左侧）：$r = 3.82845$。\n  - 情况 C（深入窗口内部）：$r = 3.83900$。\n  - 情况 D（靠近窗口内的右侧积累点）：$r = 3.84130$。\n  - 情况 E（略高于右边界，通常为混沌）：$r = 3.84160$。\n\n您的程序必须严格按照规定实现高精度算术和周期检测方法，并生成单行输出，将五个情况检测到的最小周期格式化为 $[k_A,k_B,k_C,k_D,k_E]$，其中每个 $k_\\cdot$ 都是一个整数。", "solution": "该问题要求对逻辑斯谛映射进行数值研究，这是一个展现有序与混沌的典型系统范例。其动力学由离散时间递推关系控制：\n$$ x_{n+1} = f_r(x_n) = r \\, x_n \\, (1 - x_n) $$\n其中 $x_n \\in [0,1]$ 是系统在时间步 $n$ 的状态，$r$ 是一个控制参数。我们的目标是确定著名的周期3窗口附近几个给定 $r$ 值下吸引子的最小周期。\n\n首先，确认问题陈述的有效性。提取所有给定条件：映射函数 $f_r(x)$、初始条件 $x_0 = 0.5$、暂态步数 $N_{\\text{trans}} = 3000$、数据收集长度 $L = 2048$、周期检测参数 $M = 512$ 和 $K_{\\max} = 24$、容差 $\\varepsilon = 10^{-40}$、一组 $r$ 参数，以及至少80位十进制数字的高精度要求。该问题在科学上基于动力系统理论，其提法良好，算法清晰且具确定性，并以客观、明确的语言陈述。不存在矛盾、缺失数据或其他使其无效的缺陷。因此，可以构建一个解决方案。\n\n问题的核心在于区分周期性行为和混沌行为。在混沌区域，邻近的轨迹会呈指数级发散，这种现象被称为对初始条件的敏感依赖性。标准的浮点算术（例如，64位`double`精度）精度有限（约15-17位十进制数字），会引入舍入误差，而这些误差会被混沌动力学放大，可能导致对吸引子周期性的错误分类。为克服此问题，题目强制要求使用至少80位十进制数字的高精度算术。这确保了数值轨迹在足够长的时间内忠实于真实的数学轨迹，从而能够可靠地区分高周期轨道和真正非周期（混沌）的轨道。这将使用 Python 的 `decimal` 模块来实现，精度上下文将设置为一个大于80的值，以在不损失所需精度的情况下适应中间计算。\n\n对于每个 $r$ 值，指定的算法分三个阶段进行。\n\n阶段1：暂态移除。模拟从一个固定的初始条件 $x_0 = 0.5$ 开始。执行并舍弃前 $N_{\\text{trans}} = 3000$ 次迭代。这是必要的，因为初始状态通常不在系统的吸引子上（系统经过长时间演化后趋向的点集）。这些暂态步骤使得轨道能够稳定到吸引子上。\n\n阶段2：数据收集。暂态阶段结束后，计算并存储接下来的 $L = 2048$ 个迭代值到一个序列中。记该序列为 $\\{y_i\\}_{i=0}^{L-1}$，其中 $y_i = x_{N_{\\text{trans}} + i}$。此序列代表了吸引子上的一个轨道片段。\n\n阶段3：周期检测。为找到吸引子的最小周期，我们在收集的序列内测试其周期性。对于从1到最大值 $K_{\\max} = 24$ 的每个候选周期 $k$，我们检查序列在 $k$ 步后是否近似重复。该准则基于在所收集数据的尾部段上计算的最大前向回归差异 $E(k)$：\n$$ E(k) = \\max_{i \\in \\{L - M, \\dots, L - 1 - k\\}} |y_{i+k} - y_i| $$\n这里，$L = 2048$，$M = 512$。检查在序列的后半部分（索引从 $1536$ 到 $2047-k$）进行，以进一步确保系统已充分稳定。绝对差 $|y_{i+k} - y_i|$ 衡量了轨道与周期为 $k$ 的重复状态的接近程度。如果这些差异的最大值 $E(k)$ 小于一个非常严格的容差 $\\varepsilon = 10^{-40}$，我们就断定该轨道存在一个数值周期 $k$。由于我们从 $k=1$ 开始按升序测试 $k$，第一个满足此条件的值将是所检测到的最小周期。如果对所有直到 $K_{\\max}$ 的 $k$ 值完成循环后该条件仍未满足，则该轨道被分类为非周期的（或周期大于 $K_{\\max}$），其周期报告为 $0$。\n\n整个过程独立地应用于五个指定的 $r$ 值中的每一个。然后将得到的整数周期聚合并格式化为所要求的输出字符串。所选择的测试用例旨在探测不同的动力学区域：周期3窗口外的混沌行为、稳定的周期3轨道本身，以及在返回混沌之前窗口内发生的倍周期分岔级联。", "answer": "```python\nimport decimal\n\ndef solve():\n    \"\"\"\n    Investigates the logistic map for several r-values near the period-3 window\n    using high-precision arithmetic to determine the attractor's period.\n    \"\"\"\n\n    # --- Problem Specifications ---\n    \n    # Mathematical model and numerical setup\n    # Logistic map: x_{n+1} = r * x_n * (1 - x_n)\n    PRECISION = 85  # Set precision > 80 decimal digits as required.\n    X0 = decimal.Decimal('0.5')\n    N_TRANS = 3000\n    L = 2048\n\n    # Period detection criterion\n    K_MAX = 24\n    M = 512\n    EPSILON = decimal.Decimal('1e-40')\n\n    # Test suite of r parameters\n    test_cases_r = [\n        \"3.82830\",  # Case A: Just below the period-3 window (chaotic)\n        \"3.82845\",  # Case B: Just inside the period-3 window\n        \"3.83900\",  # Case C: Well inside the period-3 window\n        \"3.84130\",  # Case D: Near the period-doubling cascade within the window\n        \"3.84160\",  # Case E: Just above the period-3 window (chaotic)\n    ]\n    \n    # Set the precision for all subsequent decimal calculations.\n    decimal.getcontext().prec = PRECISION\n    \n    results = []\n\n    # Iterate through each test case for the parameter r.\n    for r_str in test_cases_r:\n        r = decimal.Decimal(r_str)\n        x = X0\n        \n        # --- Stage 1: Evolve past the transient ---\n        # Discard the first N_TRANS iterates to allow the orbit to settle on the attractor.\n        for _ in range(N_TRANS):\n            x = r * x * (decimal.Decimal(1) - x)\n            \n        # --- Stage 2: Collect a block of iterates ---\n        # Store the next L iterates for period analysis.\n        iterates = []\n        for _ in range(L):\n            x = r * x * (decimal.Decimal(1) - x)\n            iterates.append(x)\n            \n        # --- Stage 3: Period detection ---\n        detected_period = 0\n        \n        # Test for periods k from 1 to K_MAX.\n        for k in range(1, K_MAX + 1):\n            max_discrepancy = decimal.Decimal(0)\n            \n            # Calculate E(k), the maximal forward recurrence discrepancy.\n            # The loop over i runs from L - M to L - 1 - k.\n            # The Python range `range(start, end)` goes up to `end - 1`.\n            start_index = L - M\n            end_index = L - k\n            \n            for i in range(start_index, end_index):\n                discrepancy = abs(iterates[i + k] - iterates[i])\n                if discrepancy > max_discrepancy:\n                    max_discrepancy = discrepancy\n\n            # If the discrepancy is below the tolerance, we have found the minimal period.\n            if max_discrepancy < EPSILON:\n                detected_period = k\n                break # Minimal period found, exit the loop over k.\n                \n        results.append(detected_period)\n\n    # Format and print the final output as a single comma-separated list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403610"}, {"introduction": "现在，让我们将探索从一维实数线扩展到二维复平面。逻辑斯谛映射$x_{n+1} = rx_n(1-x_n)$是更广泛的二次映射族的一员，其中最著名的是$z_{n+1} = z_n^2 + c$，这里的$z$和$c$都是复数。这个练习 [@problem_id:2403617] 将引导你探索著名的Mandelbrot集，即所有能使迭代保持有界的复参数$c$的集合。你将亲手实现基础的“逃逸时间”算法，这是生成这个著名分形图像和理解复动力学稳定性的关键工具。", "problem": "实现一个完整、可运行的程序，通过测试哪些复参数 $c \\in \\mathbb{C}$ 能使复二次映射的临界轨道保持有界，来探索曼德博集合。该复二次映射由迭代式 $z_{n+1} = f_c(z_n) = z_n^2 + c$ 定义，临界初始条件为 $z_0 = 0$。曼德博集合是所有使得轨道 $\\{z_n\\}_{n=0}^{\\infty}$ 有界的参数 $c$ 的集合。\n\n使用以下基本依据：\n- 迭代规则 $z_{n+1} = z_n^2 + c$ 定义了 $\\mathbb{C}$ 上的一个离散时间动力系统。\n- 复数 $z$ 的模为 $|z| = \\sqrt{\\operatorname{Re}(z)^2 + \\operatorname{Im}(z)^2}$。\n- 如果在迭代过程中 $|z_n|$ 的值在任何时候超过了一个固定的逃逸半径 $R$，那么该轨道将发散到无穷大。对于二次映射族 $z^2 + c$，一个经过充分检验的标准事实是，取 $R = 2$ 即可：如果存在某个 $n$ 使得 $|z_n| > 2$，那么 $z$ 的轨道就会发散到无穷大。\n\n您的任务是：\n1. 实现一个函数，对于给定的参数 $c$，从 $z_0 = 0$ 开始迭代 $z_{n+1} = z_n^2 + c$，并根据以下数值判据返回一个布尔值，以指示轨道是否保持有界：\n   - 使用逃逸半径 $R = 2$。\n   - 使用最大迭代次数 $N = 10000$。\n   - 如果存在 $n \\in \\{0,1,2,\\dots,N-1\\}$ 使得 $|z_n| > R$，则声明轨道为无界。否则，声明为有界。\n2. 将您的函数应用于下面列出的参数测试套件，并计算每个参数的布尔结果，其中 $\\mathrm{True}$ 表示“在 $N$ 次迭代内有界”，$\\mathrm{False}$ 表示“在 $N$ 次迭代内逃逸”。\n3. 虚数单位是 $i = \\sqrt{-1}$，任何复数在复指数形式中的辐角都应以弧度为单位进行解释。本问题不涉及物理单位。\n\n测试套件（按此确切顺序进行评估）：\n- $c_1 = 0 + 0 i$\n- $c_2 = -1 + 0 i$\n- $c_3 = -2 + 0 i$\n- $c_4 = 0.25 + 0 i$\n- $c_5 = 1 + 0 i$\n- $c_6 = 0.26 + 0 i$\n- $c_7 = 0.28 + 0.207846 i$\n- $c_8 = 0.5 + 0.5 i$\n\n为覆盖度设计：\n- $c_1$ 是一个简单的内点。\n- $c_2$ 会使临界轨道产生一个已知的有界周期为2的循环。\n- $c_3$ 和 $c_4$ 是实轴上的边界情况。\n- $c_5$ 和 $c_6$ 是实轴上的外点（其中 $c_6$ 靠近尖点）。\n- $c_7$ 是一个非实的内点，其构造使其位于主心形线内。\n- $c_8$ 是一个快速逃逸的非实点。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的布尔值列表。例如，输出必须类似于 $[\\mathrm{True},\\mathrm{False},\\dots]$，但实际输出字符串中逗号后没有空格。具体来说，您的程序必须只生成一行：\n- 一个表示 Python 风格列表的字符串，包含与测试套件顺序相同的 $8$ 个布尔值，例如 $[\\mathrm{True},\\mathrm{True},\\dots]$。\n\n程序无需用户输入，也不应读取或写入任何外部文件。所有计算都必须使用标准的双精度复数运算来完成。在复数运算中隐式涉及的角度均以弧度为单位。没有需要报告的物理单位。最终程序必须是自包含且确定性的。", "solution": "问题陈述经过严格审查，被确定为**有效**。它在科学上基于已建立的复动力系统数学理论，定义和约束条件清晰完整，问题阐述得当，并以客观、正式的语言表达。任务是实现一个标准算法，用于确定给定参数集是否属于曼德博集合。\n\n该问题围绕复二次映射的迭代展开，其定义为：\n$$\nz_{n+1} = f_c(z_n) = z_n^2 + c\n$$\n其中 $z_n$ 和 $c$ 是复数，即 $z, c \\in \\mathbb{C}$。对于每个参数 $c$，此方程定义了一个离散时间动力系统。\n\n曼德博集合，记作 $\\mathcal{M}$，是所有使得临界点 $z_0 = 0$ 的轨道保持有界的参数 $c$ 的集合。临界点是指导数 $f_c'(z) = 2z = 0$ 为零的点，即 $z=0$。这个临界轨道 $\\{z_n\\}_{n=0}^{\\infty}$（其中 $z_0=0$）的行为是该系统结构的基础。\n\n复动力学中的一个关键定理为有界性提供了一个实用的判据。该定理指出，如果任何迭代的模 $|z_n|$ 超过值 $2$，则该轨道保证发散到无穷大。因此，轨道有界的充要条件是对于所有 $n \\ge 0$ 都有 $|z_n| \\le 2$。\n\n这为测试成员资格是否属于 $\\mathcal{M}$ 的数值算法提供了基础。由于我们无法执行无限次迭代，因此我们使用有限步近似。对于给定的参数 $c$，我们从 $z_0 = 0$ 开始迭代该映射最多 $N$ 步。如果在任何步骤 $k < N$ 时，满足条件 $|z_k| > R$（其中 $R=2$ 是逃逸半径），我们就将该轨道分类为无界，并断定 $c \\notin \\mathcal{M}$。如果在 $N$ 次迭代后模仍未超过 $R$，我们则声明该轨道为有界，从而提供一个近似结论 $c \\in \\mathcal{M}$。\n\n本问题的具体参数如下：\n-   初始条件：$z_0 = 0 + 0i$。\n-   最大迭代次数：$N = 10000$。\n-   逃逸半径：$R = 2$。\n\n需要实现的算法如下：\n\n对于给定的复参数 $c$：\n1.  初始化复数变量 $z$ 为 $z_0 = 0$。\n2.  对 $n$ 从 $0$ 到 $N - 1$ 进行迭代：\n    a.  检查逃逸条件：$|z| > R$ 是否成立？请注意，检查 $|z|^2 > R^2$ 在计算上是等效且更高效的，在我们的情况下即为 $\\operatorname{Re}(z)^2 + \\operatorname{Im}(z)^2 > 4$。如果满足此条件，则轨道无界。函数终止并返回 $\\mathrm{False}$。\n    b.  如果未满足逃逸条件，则使用规则 $z \\leftarrow z^2 + c$ 更新 $z$。\n3.  如果循环完成而逃逸条件从未满足，则对于此数值测试而言，该轨道被认为是有界的。函数终止并返回 $\\mathrm{True}$。\n\n此过程将应用于测试套件中指定的全部 $8$ 个复参数：\n-   $c_1 = 0 + 0i$\n-   $c_2 = -1 + 0i$\n-   $c_3 = -2 + 0i$\n-   $c_4 = 0.25 + 0i$\n-   $c_5 = 1 + 0i$\n-   $c_6 = 0.26 + 0i$\n-   $c_7 = 0.28 + 0.207846i$\n-   $c_8 = 0.5 + 0.5i$\n\n最终输出将是一个布尔值列表，每个值对应一个参数，表示有界性测试的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Mandelbrot set membership problem for a given test suite.\n    \"\"\"\n\n    def is_bounded(c, max_iter=10000, radius=2.0):\n        \"\"\"\n        Tests if the orbit of z_n+1 = z_n^2 + c starting from z_0 = 0 remains\n        bounded within a given number of iterations.\n\n        Args:\n            c (complex): The parameter of the quadratic map.\n            max_iter (int): The maximum number of iterations.\n            radius (float): The escape radius.\n\n        Returns:\n            bool: True if the orbit is bounded within max_iter, False otherwise.\n        \"\"\"\n        z = np.complex128(0)\n        # It is more efficient to compare squared moduli to avoid sqrt.\n        radius_sq = radius * radius\n\n        for _ in range(max_iter):\n            # Check the escape condition using squared modulus.\n            if z.real**2 + z.imag**2 > radius_sq:\n                return False\n            # Update z\n            z = z*z + c\n        \n        # If the loop completes, the orbit is considered bounded.\n        return True\n\n    # Define the test cases from the problem statement.\n    # We use np.complex128 to be explicit about using double-precision complex numbers.\n    test_cases = [\n        np.complex128(0, 0),          # c_1\n        np.complex128(-1, 0),         # c_2\n        np.complex128(-2, 0),         # c_3\n        np.complex128(0.25, 0),       # c_4\n        np.complex128(1, 0),          # c_5\n        np.complex128(0.26, 0),       # c_6\n        np.complex128(0.28, 0.207846),# c_7\n        np.complex128(0.5, 0.5)        # c_8\n    ]\n\n    results = []\n    for c_param in test_cases:\n        result = is_bounded(c_param)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format is a string representing a Python list of booleans,\n    # with no spaces after commas. e.g., [True,False,True]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403617"}]}