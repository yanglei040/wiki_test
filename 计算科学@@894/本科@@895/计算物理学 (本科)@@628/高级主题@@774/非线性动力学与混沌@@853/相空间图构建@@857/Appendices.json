{"hands_on_practices": [{"introduction": "不动点是任何相图的基本骨架，代表了系统的平衡状态。本练习将引导你完成一个分析过程：为二维系统定位这些关键点并确定其稳定性。通过掌握零斜线和雅可比矩阵的使用，你将获得理解整体动力学行为基础的局部动力学特性的核心技能。[@problem_id:2426866]", "problem": "考虑以下常微分方程 (ODEs) 的自治平面系统\n$$\n\\dot{x} = x\\left(6 - x - 2y\\right), \\qquad \\dot{y} = y\\left(7 - 2x - y\\right),\n$$\n该系统在相平面的第一象限上定义了一个二维相流。不动点是任意满足 $\\dot{x} = 0$ 和 $\\dot{y} = 0$ 的点 $\\left(x^{\\ast}, y^{\\ast}\\right)$。在点 $\\left(x, y\\right)$ 处，矢量场的雅可比矩阵是方程组右端项关于 $x$ 和 $y$ 的一阶偏导数所构成的 $2 \\times 2$ 矩阵。\n\n求出满足 $x^{\\ast} > 0$ 和 $y^{\\ast} > 0$ 的唯一不动点，然后计算在该不动点处雅可比矩阵的迹。请以最简精确值的形式给出最终答案。请勿对答案进行四舍五入。", "solution": "首先对问题陈述进行验证。这是一个动力系统数学分析中的标准且适定的问题，具体来说是一个竞争性 Lotka-Volterra 模型。该问题具有科学依据，内容完备，客观公正，没有明显缺陷。因此，该问题被认定为有效，我们将着手进行解答。\n\n该自治平面常微分方程系统由下式给出：\n$$\n\\dot{x} = x\\left(6 - x - 2y\\right)\n$$\n$$\n\\dot{y} = y\\left(7 - 2x - y\\right)\n$$\n不动点，记为 $\\left(x^{\\ast}, y^{\\ast}\\right)$，是相空间中系统处于静止状态的点，即满足 $\\dot{x} = 0$ 和 $\\dot{y} = 0$。此条件产生以下代数方程组：\n$$\nx\\left(6 - x - 2y\\right) = 0\n$$\n$$\ny\\left(7 - 2x - y\\right) = 0\n$$\n问题要求找到坐标皆为严格正数（$x^{\\ast} > 0$ 和 $y^{\\ast} > 0$）的唯一不动点。此要求排除了任何 $x=0$ 或 $y=0$ 的解。因此，我们必须求解由非零因子导出的以下线性方程组：\n$$\n6 - x - 2y = 0 \\quad \\implies \\quad x + 2y = 6\n$$\n$$\n7 - 2x - y = 0 \\quad \\implies \\quad 2x + y = 7\n$$\n这是一个简单的二元一次线性方程组。由第二个方程，我们可以用 $x$ 表示 $y$：\n$$\ny = 7 - 2x\n$$\n将此表达式代入第一个方程，得到：\n$$\nx + 2\\left(7 - 2x\\right) = 6\n$$\n求解 $x$：\n$$\nx + 14 - 4x = 6\n$$\n$$\n-3x = 6 - 14\n$$\n$$\n-3x = -8\n$$\n$$\nx^{\\ast} = \\frac{8}{3}\n$$\n现在，我们将此 $x^{\\ast}$ 的值代回 $y$ 的表达式中：\n$$\ny^{\\ast} = 7 - 2\\left(\\frac{8}{3}\\right) = 7 - \\frac{16}{3} = \\frac{21}{3} - \\frac{16}{3} = \\frac{5}{3}\n$$\n因此，具有正坐标的唯一不动点是 $\\left(x^{\\ast}, y^{\\ast}\\right) = \\left(\\frac{8}{3}, \\frac{5}{3}\\right)$。\n\n下一步是计算在该不动点处矢量场的雅可比矩阵。设矢量场为 $F(x, y) = (f(x, y), g(x, y))$，其中 $f(x, y) = \\dot{x} = 6x - x^2 - 2xy$ 且 $g(x, y) = \\dot{y} = 7y - 2xy - y^2$。雅可比矩阵定义为：\n$$\nJ(x, y) = \\begin{pmatrix} \\frac{\\partial f}{\\partial x} & \\frac{\\partial f}{\\partial y} \\\\ \\frac{\\partial g}{\\partial x} & \\frac{\\partial g}{\\partial y} \\end{pmatrix}\n$$\n我们计算所需的一阶偏导数：\n$$\n\\frac{\\partial f}{\\partial x} = \\frac{\\partial}{\\partial x}\\left(6x - x^2 - 2xy\\right) = 6 - 2x - 2y\n$$\n$$\n\\frac{\\partial f}{\\partial y} = \\frac{\\partial}{\\partial y}\\left(6x - x^2 - 2xy\\right) = -2x\n$$\n$$\n\\frac{\\partial g}{\\partial x} = \\frac{\\partial}{\\partial x}\\left(7y - 2xy - y^2\\right) = -2y\n$$\n$$\n\\frac{\\partial g}{\\partial y} = \\frac{\\partial}{\\partial y}\\left(7y - 2xy - y^2\\right) = 7 - 2x - 2y\n$$\n所以雅可比矩阵是：\n$$\nJ(x, y) = \\begin{pmatrix} 6 - 2x - 2y & -2x \\\\ -2y & 7 - 2x - 2y \\end{pmatrix}\n$$\n我们必须在不动点 $\\left(\\frac{8}{3}, \\frac{5}{3}\\right)$ 处计算该矩阵。一种更直接的计算不动点处对角元素的方法是利用不动点条件本身。对于 $\\frac{\\partial f}{\\partial x}$，我们有：\n$$\n\\frac{\\partial f}{\\partial x} = (6 - x - 2y) - x\n$$\n根据定义，在不动点 $\\left(x^{\\ast}, y^{\\ast}\\right)$ 处，项 $(6 - x^{\\ast} - 2y^{\\ast})$ 等于 $0$。因此：\n$$\nJ_{11}\\left(x^{\\ast}, y^{\\ast}\\right) = -x^{\\ast} = -\\frac{8}{3}\n$$\n同理，对于 $\\frac{\\partial g}{\\partial y}$：\n$$\n\\frac{\\partial g}{\\partial y} = (7 - 2x - y) - y\n$$\n在不动点处，项 $(7 - 2x^{\\ast} - y^{\\ast})$ 也等于 $0$。于是：\n$$\nJ_{22}\\left(x^{\\ast}, y^{\\ast}\\right) = -y^{\\ast} = -\\frac{5}{3}\n$$\n雅可比矩阵的迹 $\\text{Tr}(J)$ 是其对角元素之和，即 $J_{11} + J_{22}$。\n$$\n\\text{Tr}\\left(J\\left(x^{\\ast}, y^{\\ast}\\right)\\right) = -\\frac{8}{3} + \\left(-\\frac{5}{3}\\right) = \\frac{-8 - 5}{3} = -\\frac{13}{3}\n$$\n这就是所求的最简精确值。", "answer": "$$\n\\boxed{-\\frac{13}{3}}\n$$", "id": "2426866"}, {"introduction": "一旦我们确定了鞍点，下一步就是追踪构建全局相图结构的关键路径：稳定与不稳定流形。本练习将转向计算方法，你将通过在时间上向前和向后积分轨迹来数值近似这些关键曲线。这种实践对于可视化相空间中不同区域是如何连接和分离至关重要。[@problem_id:2426894]", "problem": "你需要编写一个完整的、可运行的程序，通过数值计算鞍点的稳定和不稳定流形，来构建一个二维动力系统的相空间图。该程序必须实现并积分一个二维自治常微分方程，并自动提取所计算流形的量化诊断指标。不需要绘图或文件输入/输出；你的程序必须生成单行文本输出，其中包含针对指定初始偏移测试集的数值指标。\n\n考虑由以下一阶方程定义的保守平面系统：\n$$\n\\frac{dx}{dt} = y, \\quad \\frac{dy}{dt} = x - x^{3}.\n$$\n该系统在原点处有一个鞍点平衡。在原点的雅可比矩阵为\n$$\nJ(0,0) = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix},\n$$\n其特征值为 $+1$ 和 $-1$，对应的单位特征向量分别沿着 $(1,1)$ 和 $(1,-1)$ 方向。鞍点的稳定流形和不稳定流形分别定义为当 $t \\to +\\infty$ 和 $t \\to -\\infty$ 时轨迹趋近于鞍点的点集。该系统是哈密顿系统，其守恒能量为\n$$\nH(x,y) = \\frac{y^{2}}{2} - \\frac{x^{2}}{2} + \\frac{x^{4}}{4},\n$$\n因此轨迹位于 $H$ 的等值线上。构成鞍点全局稳定和不稳定流形的分界线曲线是等值线 $H(x,y) = 0$。\n\n你的任务是：\n- 根据上述基本定义，通过对初始条件进行积分来构建离开原点并进入第一象限的不稳定流形，以及相应的稳定流形的数值近似。这些初始条件需与相应的线性特征方向相切，并位于分界线能级 $H=0$ 上。不要使用任何显式的、预先构造的流形公式；通过强制 $H(x,y)=0$ 以及在原点附近与相应特征方向相切的条件来计算初始条件。\n- 对于第一象限中的不稳定流形分支，向前积分直到轨迹首次返回水平轴，即从正值穿越到零直到 $y=0$。记录此次穿越点的 $x$ 坐标。\n- 对于从第四象限趋近于原点的稳定流形分支，向后积分（等效于对时间反向的系统进行积分），直到轨迹首次从负值到达 $y=0$。记录此次穿越点的 $x$ 坐标。\n- 对两个分支，通过计算 $H(x(t),y(t))$ 在数值积分段上与其初始能量值的最大绝对偏差，来量化你的数值轨迹对分界线的遵循程度。此外，通过计算初始条件处的系统矢量场与相关特征向量之间的夹角，来量化与线性特征向量的局部对齐程度。该夹角必须以弧度报告。\n\n设计你的程序以执行以下包含三个初始偏移的测试集，每个偏移由一个小的正标量 $\\varepsilon$ 指定，它设定了沿相应特征方向距原点的初始距离，同时保持在分界线 $H=0$ 上：\n- 情况 1： $\\varepsilon = 10^{-6}$。\n- 情况 2： $\\varepsilon = 10^{-3}$。\n- 情况 3： $\\varepsilon = 10^{-2}$。\n\n实现要求和约定：\n- 对于第一象限中的不稳定分支，选择一个初始条件 $(x_{0},y_{0})$，其中 $x_{0} = \\varepsilon$, $y_{0} > 0$，位于等值线 $H=0$ 上，并在原点处与不稳定特征方向相切。向前积分直到首次从正值穿越到零穿过 $y=0$。为避免起始时的平凡穿越，你必须对 $y=0$ 条件使用方向敏感的事件检测，并且只检测 $y$ 值减小的穿越。使用足够长的最终积分时间，以确保所有给定的 $\\varepsilon$ 都能检测到穿越。预期的穿越点 $x$ 坐标在 $\\sqrt{2}$ 附近；你的程序必须计算测得的穿越点 $x$ 与 $\\sqrt{2}$ 之间的绝对差。\n- 对于第四象限中的稳定分支，选择一个初始条件 $(x_{0},y_{0})$，其中 $x_{0} = \\varepsilon$, $y_{0} < 0$，位于等值线 $H=0$ 上，并在原点处与稳定特征方向相切。向后积分直到首次从负值穿越到零穿过 $y=0$，并计算测得的穿越点 $x$ 与 $\\sqrt{2}$ 之间的绝对差。\n- 仅对于不稳定分支，计算在 $(x_{0},y_{0})$ 处评估的系统矢量场与原点处单位不稳定特征向量之间的夹角（以弧度为单位）。将此夹角报告为非负的弧度值。\n- 仅对于不稳定分支，报告在积分轨迹段上哈密顿量 $H$ 与其初始值的最大绝对偏差。由于初始条件位于 $H=0$ 上，这即是该段上 $H$ 的最大绝对值。\n\n所有角度必须以弧度报告。没有物理单位。\n\n数值规格：\n- 使用带有自适应步长和事件检测功能的精确时间积分器。\n- 使用足够大的积分时域以确保所有情况都能达到首次 $y=0$ 穿越，例如在向前或向后方向上的最大时间为 $T_{\\max} = 50$。\n- 使用足够严格的容差来解析流形和事件。\n\n最终输出格式：\n- 对于测试集中的每个 $\\varepsilon$，你的程序必须按以下顺序输出一个包含四个浮点数的列表：$[\\text{不稳定顶点误差}, \\text{不稳定角度误差}, \\text{不稳定最大能量偏差}, \\text{稳定顶点误差}]$。\n- 将三种情况的结果汇总到打印到标准输出的单行中，该行包含一个由三个按情况分的列表组成的列表，例如 $[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],[r_{31},r_{32},r_{33},r_{34}]]$，其中每个 $r_{ij}$ 都是一个浮点数。打印时，数值必须四舍五入到六位有效数字。\n\n你的程序不得读取任何输入，并且除了所需的单行输出外，不得产生任何其他输出。", "solution": "所提出的问题是计算非线性动力学中的一个标准练习，并已被验证为科学上合理、适定且客观的。它要求对一个二维哈密顿系统进行稳定和不稳定流形的数值构建，并计算特定的量化指标。我们继续进行求解。\n\n该系统由以下自治常微分方程定义：\n$$\n\\frac{dx}{dt} = \\dot{x} = y\n$$\n$$\n\\frac{dy}{dt} = \\dot{y} = x - x^3\n$$\n该系统是保守的，源自哈密顿函数 $H(x,y)$：\n$$\nH(x,y) = \\frac{y^2}{2} - \\frac{x^2}{2} + \\frac{x^4}{4}\n$$\n动力学被约束在该哈密顿量的等值线上。通过设置 $\\dot{x}=0$ 和 $\\dot{y}=0$ 来找到平衡点，这得到 $y=0$ 和 $x - x^3 = 0$。解为 $(0,0)$, $(1,0)$ 和 $(-1,0)$。我们关注的是原点处的平衡点 $(0,0)$。\n\n原点的稳定性由矢量场 $F(x,y) = (y, x-x^3)$ 的雅可比矩阵确定：\n$$\nJ(x,y) = \\begin{pmatrix} \\frac{\\partial \\dot{x}}{\\partial x} & \\frac{\\partial \\dot{x}}{\\partial y} \\\\ \\frac{\\partial \\dot{y}}{\\partial x} & \\frac{\\partial \\dot{y}}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ 1 - 3x^2 & 0 \\end{pmatrix}\n$$\n在原点，它变为：\n$$\nJ(0,0) = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}\n$$\n特征值 $\\lambda$ 由 $\\det(J - \\lambda I) = 0$ 得出，即 $\\lambda^2 - 1 = 0$，所以 $\\lambda_{1,2} = \\pm 1$。存在一个正特征值和一个负特征值证实了原点是一个鞍点。对于不稳定特征值 $\\lambda_u = +1$ 的特征向量是 $\\vec{v}_u \\propto (1,1)$，对于稳定特征值 $\\lambda_s = -1$ 的特征向量是 $\\vec{v}_s \\propto (1,-1)$。这些特征向量分别定义了不稳定流形和稳定流形的局部方向。\n\n全局流形，也就是相空间的分界线，对应于穿过鞍点的特定能级。在原点处评估哈密顿量得到 $H(0,0)=0$。因此，稳定流形和不稳定流形位于由 $H(x,y)=0$ 定义的曲线上。\n\n为了数值计算流形的一个分支，我们必须选择一个初始条件 $(x_0, y_0)$，它沿着相应的特征向量方向从鞍点做无穷小位移，并位于分界线能级上。问题指定了一个由小参数 $\\varepsilon$ 表征的位移。\n\n对于第一象限 ($x>0, y>0$) 中的不稳定流形分支，我们设置 $x_0 = \\varepsilon$。条件 $H(\\varepsilon, y_0) = 0$ 给出：\n$$\n\\frac{y_0^2}{2} - \\frac{\\varepsilon^2}{2} + \\frac{\\varepsilon^4}{4} = 0 \\implies y_0^2 = \\varepsilon^2 - \\frac{\\varepsilon^4}{2}\n$$\n由于我们在第一象限，我们取正根：\n$$\ny_0 = \\sqrt{\\varepsilon^2 - \\frac{\\varepsilon^4}{2}} = \\varepsilon \\sqrt{1 - \\frac{\\varepsilon^2}{2}}\n$$\n对于小的 $\\varepsilon$，泰勒展开显示 $y_0 \\approx \\varepsilon(1 - \\varepsilon^2/4) \\approx \\varepsilon$。因此，初始点 $(x_0, y_0)$ 近似为 $(\\varepsilon, \\varepsilon)$，它与不稳定特征向量方向 $(1,1)$ 相切。我们对这个初始条件进行时间正向积分 ($t>0$)，直到轨迹首次穿过x轴，即 $y=0$。当同宿环闭合时，可以找到穿越点 $x_{cross}$。在分界线上，这发生在 $H(x,0) = 0$ 时，这意味着 $-\\frac{x^2}{2} + \\frac{x^4}{4} = 0$。非零解是 $x = \\pm\\sqrt{2}$。第一象限的分支将在 $x = \\sqrt{2}$ 处穿越。第一个指标是与此精确值的偏差：$|x_{cross} - \\sqrt{2}|$。\n\n对于从第四象限 ($x>0, y<0$) 趋近于原点的稳定流形分支，我们同样设置 $x_0 = \\varepsilon$。条件 $H(\\varepsilon, y_0) = 0$ 要求取负根：\n$$\ny_0 = -\\sqrt{\\varepsilon^2 - \\frac{\\varepsilon^4}{2}} = -\\varepsilon \\sqrt{1 - \\frac{\\varepsilon^2}{2}}\n$$\n对于小的 $\\varepsilon$，$y_0 \\approx -\\varepsilon$，初始点 $(x_0, y_0)$ 近似为 $(\\varepsilon, -\\varepsilon)$，与稳定特征向量方向 $(1,-1)$ 相切。为了追踪这个远离原点的流形，我们必须进行时间反向积分 ($t<0$)。根据对称性，在 $y=0$ 轴上的穿越点 $x_{cross}$ 也应在 $x=\\sqrt{2}$。最终的指标是 $|x_{cross} - \\sqrt{2}|$。\n\n其余指标是为不稳定分支计算的。角度误差量化了初始点 $(x_0, y_0)$ 处的真实矢量场与线性近似（特征向量 $\\vec{v}_u=(1,1)$）的对齐程度。矢量场为 $\\vec{F}(x_0, y_0) = (y_0, x_0 - x_0^3)$。$\\vec{F}$ 和 $\\vec{v}_u$ 之间的夹角 $\\theta$ 使用点积公式计算：\n$$\n\\theta = \\arccos\\left(\\frac{\\vec{F}(x_0, y_0) \\cdot \\vec{v}_u}{||\\vec{F}(x_0, y_0)|| \\cdot ||\\vec{v}_u||}\\right)\n$$\n能量偏差衡量了数值积分器的准确性。由于初始条件精确地位于 $H=0$ 等值线上，沿计算出的轨迹段的哈密顿量的最大绝对值 $\\max_t |H(x(t), y(t))|$ 量化了累积的数值误差。\n\n数值实现将使用一个高精度、自适应步长的微分方程求解器，该求解器配备事件检测功能，以精确定位 $y=0$ 的穿越点。`scipy.integrate.solve_ivp` 适合此目的。对测试集中的每个 $\\varepsilon$ 值执行积分，并按要求计算和格式化四个指定的指标。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef format_float(val):\n    \"\"\"Formats a float to 6 significant figures in scientific notation if needed.\"\"\"\n    return f\"{val:.6g}\"\n\ndef solve():\n    \"\"\"\n    Computes stable and unstable manifolds for a 2D dynamical system,\n    and extracts quantitative diagnostics for a suite of initial offsets.\n    \"\"\"\n    test_cases = [1e-6, 1e-3, 1e-2]\n    all_results = []\n    \n    # The ODE system dx/dt = y, dy/dt = x - x^3\n    def diffeq(t, state):\n        x, y = state\n        return [y, x - x**3]\n\n    # Hamiltonian H(x,y) = y^2/2 - x^2/2 + x^4/4\n    def hamiltonian(x, y):\n        return 0.5 * y**2 - 0.5 * x**2 + 0.25 * x**4\n\n    # Event for y=0 crossing with y decreasing\n    def event_y_zero_down(t, state):\n        return state[1]\n    event_y_zero_down.terminal = True\n    event_y_zero_down.direction = -1\n\n    # Event for y=0 crossing with y increasing\n    def event_y_zero_up(t, state):\n        return state[1]\n    event_y_zero_up.terminal = True\n    event_y_zero_up.direction = 1\n\n    # Theoretical x-crossing on the separatrix\n    x_apex_theoretical = np.sqrt(2.0)\n\n    # Unit unstable eigenvector direction\n    evec_u = np.array([1.0, 1.0])\n\n    # Numerical integration settings\n    t_max = 50.0\n    rtol = 1e-12\n    atol = 1e-12\n\n    for eps in test_cases:\n        case_results = []\n\n        # --- Unstable Manifold (Q1) ---\n        x0_u = eps\n        y0_u = eps * np.sqrt(1.0 - 0.5 * eps**2)\n        ic_u = [x0_u, y0_u]\n\n        # Integrate forward in time\n        sol_u = solve_ivp(\n            diffeq, [0, t_max], ic_u,\n            events=event_y_zero_down,\n            dense_output=True,\n            rtol=rtol, atol=atol\n        )\n\n        unstable_apex_error = np.nan\n        unstable_angle_error = np.nan\n        unstable_max_energy_deviation = np.nan\n\n        if sol_u.status == 1 and sol_u.t_events[0].size > 0:\n            # Metric 1: Apex error\n            x_cross_u = sol_u.y_events[0][0, 0]\n            unstable_apex_error = np.abs(x_cross_u - x_apex_theoretical)\n\n            # Metric 2: Angle error at initial condition\n            vf_at_ic = np.array([y0_u, x0_u - x0_u**3])\n            cos_theta = np.dot(vf_at_ic, evec_u) / (np.linalg.norm(vf_at_ic) * np.linalg.norm(evec_u))\n            # Clip to handle potential floating point inaccuracies for arccos\n            cos_theta = np.clip(cos_theta, -1.0, 1.0)\n            unstable_angle_error = np.arccos(cos_theta)\n\n            # Metric 3: Max energy deviation\n            h_values = hamiltonian(sol_u.y[0, :], sol_u.y[1, :])\n            unstable_max_energy_deviation = np.max(np.abs(h_values))\n\n        # --- Stable Manifold (Q4) ---\n        x0_s = eps\n        y0_s = -eps * np.sqrt(1.0 - 0.5 * eps**2)\n        ic_s = [x0_s, y0_s]\n\n        # Integrate backward in time\n        sol_s = solve_ivp(\n            diffeq, [0, -t_max], ic_s,\n            events=event_y_zero_up,\n            dense_output=True,\n            rtol=rtol, atol=atol\n        )\n\n        stable_apex_error = np.nan\n        if sol_s.status == 1 and sol_s.t_events[0].size > 0:\n            # Metric 4: Apex error\n            x_cross_s = sol_s.y_events[0][0, 0]\n            stable_apex_error = np.abs(x_cross_s - x_apex_theoretical)\n        \n        case_results = [\n            unstable_apex_error,\n            unstable_angle_error,\n            unstable_max_energy_deviation,\n            stable_apex_error\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    formatted_results = []\n    for row in all_results:\n        formatted_row = f\"[{','.join([format_float(v) for v in row])}]\"\n        formatted_results.append(formatted_row)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2426894"}, {"introduction": "虽然我们的理论模型通常是连续的，但它们在计算机上的实现却是离散和有限的，这一事实会带来深远的影响。本练习将直面这一现实，通过比较一种混沌映射在理想整数运算下与在有限浮点精度下的动力学差异，来检验计算精度对相图结构的影响。通过这种对比，你将对数值伪影以及计算相图的可靠性有更深刻的认识。[@problem_id:2426915]", "problem": "构建一个计算实验，用以分析有限精度运算如何影响阿诺德猫映射的相空间图。阿诺德猫映射是作用于二维环面上的线性映射，由矩阵 $A = \\begin{pmatrix}1 & 1 \\\\ 1 & 2\\end{pmatrix}$ 定义，通过 $z_{n+1} = A z_n \\bmod 1$ 作用于单位正方形中的一个点 $z_n = (x_n,y_n)$（采用环面等同）。在大小为 $N$ 的离散环面上进行精确整数运算时，相空间可以表示为格点 $\\{0,1,\\dots,N-1\\}^2$，其更新规则为 $(x_{n+1},y_{n+1}) \\equiv (x_n+y_n, x_n + 2 y_n) \\bmod N$。在连续环面上进行浮点运算时，人们以有限精度计算 $z_{n+1} = A z_n \\bmod 1$，并且为了构建分辨率为 $N$ 的离散相空间图，将一个连续点 $(x,y)$ 分箱到单元格索引 $(\\lfloor N x \\rfloor, \\lfloor N y \\rfloor)$。\n\n从以下基本事实出发：(i) 行列式为1的线性映射在整数上是可逆的且保持面积，以及 (ii) 浮点运算仅能表示实数的一个有限子集，并在每次操作中引入舍入误差，您将设计一个程序，在 $N \\times N$ 网格上构建并比较三种诱导映射：\n- 一种精确整数运算诱导映射 $f_{\\text{int}}: \\{0,\\dots,N-1\\}^2 \\to \\{0,\\dots,N-1\\}^2$，由 $f_{\\text{int}}(x,y) = \\big((x+y) \\bmod N, (x+2y) \\bmod N\\big)$ 给出。\n- 一种浮点（32位）诱导映射 $f_{32}: \\{0,\\dots,N-1\\}^2 \\to \\{0,\\dots,N-1\\}^2$，通过将 $(x,y)$ 解释为单位环面中的 $(x/N, y/N)$，使用单精度浮点运算通过 $z \\mapsto A z \\bmod 1$ 演化一步，然后通过 $\\big(\\lfloor N x \\rfloor, \\lfloor N y \\rfloor\\big)$ 分箱到整数。\n- 一种浮点（64位）诱导映射 $f_{64}$，其定义类似，但使用双精度浮点运算。\n\n对于测试套件中的每个 $N$，您必须计算以下可量化的性质，这些性质表征了诱导离散动力系统的长期和全局结构：\n1. $f_{\\text{int}}$ 的双射性质：一个布尔值，指示每个网格点是否恰好有一个原像（等价地，$f_{\\text{int}}$ 是否是 $N^2$ 个状态的一个置换）。\n2. $f_{\\text{int}}$ 的最大环长度：由 $f_{\\text{int}}$ 在 $N^2$ 个状态上诱导的函数图中的最大有向环的长度。\n3. 对于 $f_{32}$：\n   - 不可达状态的数量（在 $f_{32}$ 下入度为零的网格单元）。\n   - 所有状态中的最大入度。\n   - 其函数图中的最大环长度。\n4. 对于 $f_{64}$：与第3项中相同的三个量。\n\n所有计算都是纯粹基于整数和浮点数的数学运算，不涉及任何物理单位或角度。\n\n测试套件：\n- 情况1：$N = 16$。\n- 情况2：$N = 31$。\n- 情况3：$N = 64$。\n\n您的程序必须：\n- 为每个 $N$ 精确实现所定义的三种诱导映射。\n- 对每种情况，按以下顺序生成包含八个结果的列表：\n  1. $f_{\\text{int}}$ 双射性质 (布尔值),\n  2. $f_{\\text{int}}$ 最大环长度 (整数),\n  3. $f_{32}$ 不可达状态 (整数),\n  4. $f_{32}$ 最大入度 (整数),\n  5. $f_{32}$ 最大环长度 (整数),\n  6. $f_{64}$ 不可达状态 (整数),\n  7. $f_{64}$ 最大入度 (整数),\n  8. $f_{64}$ 最大环长度 (整数)。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表，列表被方括号包围。每个测试用例表示为一个按指定顺序列出的内部列表，例如：\"[[b1,c1,u32_1,m32_1,l32_1,u64_1,m64_1,l64_1],[b2,c2,u32_2,m32_2,l32_2,u64_2,m64_2,l64_2],[b3,c3,u32_3,m32_3,l32_3,u64_3,m64_3,l64_3]]\"。输出行中不得有任何空格。\n\n约束与说明：\n- 算法必须从上述定义出发，不得使用特定 $N$ 的预先计算的性质。\n- 环长度定义为有向环上不同状态的数量；在一个每个节点的出度均为一的函数图中，每个弱连通分量都包含恰好一个有向环，任何树（如果存在）都汇入环中。\n- 通过使用等价于逐分量应用 $x \\mapsto x - \\lfloor x \\rfloor$ 的定义来确保浮点取模运算的数值稳定性，并以目标精度执行操作。", "solution": "该问题要求对阿诺德猫映射在不同算术系统下的行为进行计算分析：精确整数运算与有限精度浮点运算（单精度和双精度）。目标是量化当映射在 $N \\times N$ 网格上离散化时，其相空间图发生的结构性变化。\n\n**1. 理论框架**\n\n阿诺德猫映射是二维环面 $\\mathbb{T}^2 = \\mathbb{R}^2 / \\mathbb{Z}^2$ 的一个线性自同构。它由变换 $z \\mapsto A z \\pmod 1$ 定义，其中 $z = (x,y)$ 且 $A = \\begin{pmatrix} 1 & 1 \\\\ 1 & 2 \\end{pmatrix}$。用 $N \\times N$ 的离散状态网格 $\\{ (i/N, j/N) \\}_{i,j=0}^{N-1}$ 铺砌单位正方形，并考虑在整数格点 $\\{0, 1, \\dots, N-1\\}^2$ 上的动力学，便得到了待研究的三种诱导映射。\n\n**映射1：精确整数运算 ($f_{\\text{int}}$)**\n映射 $f_{\\text{int}}: \\mathbb{Z}_N^2 \\to \\mathbb{Z}_N^2$ 由线性变换 $(x,y) \\mapsto (x+y, x+2y) \\pmod N$ 定义。这是由矩阵 $A$ 表示的在模 $\\mathbb{Z}_N^2$ 上的一个变换。环上线性代数的一个基本定理指出，这样的映射是双射（一个置换）的充要条件是其行列式在模 $N$ 整数环 $\\mathbb{Z}_N$ 中是可逆元。矩阵 $A$ 的行列式是 $\\det(A) = (1)(2) - (1)(1) = 1$。因为对于任何整数 $N \\geq 1$，$\\gcd(1, N) = 1$，所以该行列式在 $\\mathbb{Z}_N$ 中恒为可逆元。因此，对于任何 $N$，映射 $f_{\\text{int}}$ 都是在 $N^2$ 个状态的有限集上的可逆变换。这意味着 $f_{\\text{int}}$ 恒为一个置换。因此 $f_{\\text{int}}$ 的相空间由一组不相交的环构成。每个状态都恰好属于一个环，并有唯一的原像。因此，不可达状态的数量必定为 $0$，最大入度必定为 $1$。我们对双射性质的计算检验将用于验证这一理论结果以及我们实现的正确性。\n\n**映射2和3：浮点运算 ($f_{32}, f_{64}$)**\n映射 $f_{32}$ 和 $f_{64}$ 通过一个多步过程构建：\n1.  将一个整数网格点 $(x,y)$ 映射到单位正方形中的一个连续坐标：$(x', y') = (x/N, y/N)$。\n2.  使用有限精度算术（32位或64位）应用变换：$(x'', y'') = (x'+y', x'+2y')$。\n3.  逐分量应用模 $1$ 运算，例如，$x''' = x'' - \\lfloor x'' \\rfloor$。\n4.  将得到的连续点分箱回到整数网格：$(\\lfloor N x''' \\rfloor, \\lfloor N y''' \\rfloor)$。\n\n这个过程在每次算术运算中都不可避免地引入了舍入误差。有限精度的浮点数只能表示实数的一个离散子集。结果是，原始映射的性质无法被保持。诱导映射 $f_{32}$ 和 $f_{64}$ 不再是线性的，也不能保证是双射。由于数值崩塌，多个不同的初始状态可能会被映射到同一个最终状态，从而导致某些状态的入度大于 $1$。反过来，这意味着某些状态的入度将为 $0$，成为“不可达”状态或“伊甸园”状态。长期动力学行为预期会收敛到吸引子，在有限状态空间中，吸引子必定是环。这些环通常比在精确整数系统中观察到的环短得多，并且相空间图的特征是这些吸引盆。浮点运算的精度（32位与64位）直接影响这些效应的严重程度；更高的精度预期能更好地逼近理想的动力学行为，但无法消除根本问题。\n\n**2. 算法实现**\n\n为了计算所需的性质，我们将每种诱导映射建模为在一个包含 $N^2$ 个顶点的集合上的函数图。顶点代表网格单元，我们可以方便地通过映射 $(x,y) \\to i = x + N \\cdot y$ 将其扁平化为一个单一的整数索引 $i \\in \\{0, \\dots, N^2-1\\}$。\n\n**2.1. 函数图构建**\n对于每个映射 $f \\in \\{f_{\\text{int}}, f_{32}, f_{64}\\}$，我们构建一个大小为 $N^2$ 的后继数组 `F`。`F[i]` 存储了状态 `i` 在一步演化后所到达的状态的扁平化索引。这通过遍历每个状态 $i=0, \\dots, N^2-1$，将其反扁平化为其 $(x,y)$ 坐标，应用各自的映射函数，并存储结果状态的扁平化索引来完成。\n-   $f_{\\text{int}}$ 的实现使用标准整数算术和 `%` 运算符进行取模运算。\n-   $f_{32}$ 和 $f_{64}$ 的实现明确使用 `numpy.float32` 和 `numpy.float64` 数据类型，以确保计算在指定精度下执行。首先执行计算 $(x/N, y/N)$。然后进行矩阵乘法。模 $1$ 运算实现为 $u \\mapsto u - \\text{np.floor}(u)$。最后，结果乘以 $N$ 并使用 `np.floor` 进行分箱。\n\n**2.2. 图分析**\n一旦某个映射的后继数组 `F` 被构建，我们就分析其结构以提取所需的度量指标。\n\n**入度和不可达性：**\n每个状态（顶点）的入度是映射到它的其他状态的数量。我们可以通过创建后继数组 `F` 中值的直方图，来同时高效地计算所有状态的入度。`numpy.bincount` 函数非常适合这项任务。计算出 `in_degree` 数组后，不可达状态的数量就是等于 $0$ 的条目数，最大入度是该数组中的最大值。对于 $f_{\\text{int}}$，如果不可达状态的数量为 $0$ 且最大入度为 $1$，则其双射性质得到确认。\n\n**最大环长度：**\n一个函数图由一个或多个弱连通分量组成，每个分量恰好包含一个有向环。为了找到最大环长度，我们对图进行遍历。我们使用一个 `visited` 数组来跟踪哪些状态已被分配到一个分量。\n我们遍历所有状态 $i = 0, \\dots, N^2-1$。如果状态 `i` 未被访问，我们从它开始一次新的遍历。从 `i` 开始遍历期间，我们跟踪当前路径中的节点及其距起点的距离（`path` 字典）。我们沿着后继链接 `curr = F[curr]` 前进，直到遇到一个之前访问过的节点。\n-   如果重新遇到的节点是在*当前遍历期间*被访问的，我们就找到了一个环。其长度是当前路径长度减去该节点首次被看到时的路径长度。如果这个环更大，我们就更新全局最大环长度。\n-   如果重新遇到的节点是作为*前一个分量遍历*的一部分被访问的，那么我们当前的路径是一棵汇入一个先前已分析过的环的树。没有找到新的环。\n在遍历期间访问的所有节点都被标记上当前分量的ID，以防止重复处理。这种系统性的方法保证了每个环都被恰好找到一次，并且最大长度得以确定。", "answer": "```python\nimport numpy as np\n\ndef get_functional_graph(N, map_func, dtype=None):\n    \"\"\"\n    Constructs the functional graph (successor array) for a given map on an N x N grid.\n\n    Args:\n        N (int): The grid size.\n        map_func (function): The function defining the map.\n        dtype (numpy.dtype, optional): The floating-point precision to use.\n\n    Returns:\n        numpy.ndarray: An array where F[i] is the successor of state i.\n    \"\"\"\n    num_states = N * N\n    next_state = np.zeros(num_states, dtype=np.int64)\n\n    # Vectorized implementation for speed\n    indices = np.arange(num_states)\n    x = indices % N\n    y = indices // N\n\n    if dtype is not None:\n        x_next, y_next = map_func(x, y, N, dtype)\n    else:\n        x_next, y_next = map_func(x, y, N)\n\n    next_state = (x_next + N * y_next).astype(np.int64)\n    \n    return next_state\n\ndef analyze_graph(F, N):\n    \"\"\"\n    Analyzes a functional graph to find unreachable states, max in-degree, and largest cycle length.\n\n    Args:\n        F (numpy.ndarray): The successor array of the graph.\n        N (int): The grid size.\n\n    Returns:\n        tuple: (unreachable_states, max_indegree, largest_cycle_length).\n    \"\"\"\n    num_states = N * N\n    if num_states == 0:\n        return 0, 0, 0\n\n    # In-degree and unreachability analysis\n    in_degree = np.bincount(F, minlength=num_states)\n    unreachable_states = np.sum(in_degree == 0)\n    max_indegree = np.max(in_degree)\n\n    # Cycle analysis\n    largest_cycle_length = 0\n    visited = np.zeros(num_states, dtype=np.int32)  # 0: unvisited, >0: component_id\n    component_id = 1\n\n    for i in range(num_states):\n        if visited[i] > 0:\n            continue\n\n        path = {}  # node -> path length from start of trace\n        curr = i\n        k = 0\n        while visited[curr] == 0:\n            visited[curr] = component_id\n            path[curr] = k\n            curr = F[curr]\n            k += 1\n\n        if visited[curr] == component_id:\n            # Cycle found in the current component\n            cycle_len = k - path[curr]\n            if cycle_len > largest_cycle_length:\n                largest_cycle_length = cycle_len\n\n        component_id += 1\n\n    return int(unreachable_states), int(max_indegree), int(largest_cycle_length)\n\n# Map definitions (vectorized)\ndef f_int(x, y, N):\n    x_next = (x + y) % N\n    y_next = (x + 2 * y) % N\n    return x_next, y_next\n\ndef f_float(x, y, N, dtype):\n    N_f = dtype(N)\n    one_f = dtype(1)\n    two_f = dtype(2)\n\n    x_c = x.astype(dtype) / N_f\n    y_c = y.astype(dtype) / N_f\n\n    x_next_c = x_c + y_c\n    y_next_c = x_c + two_f * y_c\n\n    # Modulo 1 operation\n    x_next_c -= np.floor(x_next_c)\n    y_next_c -= np.floor(y_next_c)\n\n    # Binning\n    x_next = np.floor(N_f * x_next_c)\n    y_next = np.floor(N_f * y_next_c)\n\n    return x_next, y_next\n\ndef solve_for_N(N):\n    \"\"\"\n    Solves the problem for a single value of N.\n    \"\"\"\n    # Integer map analysis\n    F_int = get_functional_graph(N, f_int)\n    unreachable_int, max_indegree_int, lcl_int = analyze_graph(F_int, N)\n    is_bijection = (unreachable_int == 0) and (max_indegree_int == 1)\n\n    # Float32 map analysis\n    F_32 = get_functional_graph(N, f_float, dtype=np.float32)\n    unreachable_32, max_indegree_32, lcl_32 = analyze_graph(F_32, N)\n\n    # Float64 map analysis\n    F_64 = get_functional_graph(N, f_float, dtype=np.float64)\n    unreachable_64, max_indegree_64, lcl_64 = analyze_graph(F_64, N)\n\n    return [\n        is_bijection, lcl_int,\n        unreachable_32, max_indegree_32, lcl_32,\n        unreachable_64, max_indegree_64, lcl_64\n    ]\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the final result.\n    \"\"\"\n    test_cases = [16, 31, 64]\n    \n    all_results = []\n    for N in test_cases:\n        results_for_N = solve_for_N(N)\n        all_results.append(results_for_N)\n        \n    # Format the output string according to the problem specification.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]'.replace('True', 'True').replace('False', 'False') for res in all_results)}]\"\n    print(output_str.replace(\" \",\"\"))\n\nsolve()\n```", "id": "2426915"}]}