{"hands_on_practices": [{"introduction": "逻辑斯蒂映射在 $r=4$ 时表现出完全的混沌行为，但令人惊讶的是，这种情况下的动力学可以通过一个巧妙的变量替换得到精确求解。通过引入变换 $x_n = \\sin^2(\\theta_n)$，我们将一个复杂的非线性迭代问题转化为一个简单的角度线性演化问题。这个练习旨在揭示混沌系统背后隐藏的有序结构，并展示数学变换在简化复杂问题中的强大威力 [@problem_id:2409501]。", "problem": "考虑由以下递推关系定义的逻辑斯蒂映射：\n$$x_{n+1} = 4 x_n (1 - x_n),$$\n其中整数 $n \\ge 0$，初始条件为 $x_0 \\in (0,1)$。为每个 $n$ 引入一个角变量 $\\theta_n \\in [0,\\pi)$，使得\n$$x_n = \\sin^2(\\theta_n),$$\n其中初始角 $\\theta_0 \\in [0,\\pi)$ 的选择满足 $x_0 = \\sin^2(\\theta_0)$。请确定 $\\theta_{n+1}$ 关于 $\\theta_n$ 的精确演化律，必要时将角度对 $\\pi$ 取模以使其保持在 $[0,\\pi)$ 区间内。然后，将 $x_N$ 表示为 $\\theta_0$ 和非负整数 $N$ 的函数的闭合形式。请以 $\\theta_0$ 和 $N$ 的单个闭合形式解析表达式给出最终答案。", "solution": "问题陈述已经过验证，被认为是科学上可靠、适定、客观且自洽的。它提出了非线性动力学研究中的一个标准问题，特别是参数值对应于完全发展的混沌状态的逻辑斯蒂映射。将提供一个解答。\n\n该系统由逻辑斯蒂映射的递推关系描述：\n$$x_{n+1} = 4 x_n (1 - x_n)$$\n初始条件为 $x_0 \\in (0,1)$，整数索引 $n \\ge 0$。根据题目要求，我们使用变换 $x_n = \\sin^2(\\theta_n)$，其中 $\\theta_n \\in [0, \\pi)$。\n\n首先，我们确定角变量 $\\theta_n$ 的演化律。我们将该变换代入递推关系中：\n$$x_{n+1} = 4 \\sin^2(\\theta_n) (1 - \\sin^2(\\theta_n))$$\n使用基本三角恒等式 $\\cos^2(\\alpha) + \\sin^2(\\alpha) = 1$，我们将 $(1 - \\sin^2(\\theta_n))$ 替换为 $\\cos^2(\\theta_n)$：\n$$x_{n+1} = 4 \\sin^2(\\theta_n) \\cos^2(\\theta_n)$$\n这个表达式可以被重排为一个乘积的平方：\n$$x_{n+1} = (2 \\sin(\\theta_n) \\cos(\\theta_n))^2$$\n我们认出括号中的项是正弦的二倍角恒等式，$\\sin(2\\alpha) = 2 \\sin(\\alpha) \\cos(\\alpha)$。应用此恒等式可得：\n$$x_{n+1} = (\\sin(2\\theta_n))^2 = \\sin^2(2\\theta_n)$$\n根据变换的定义，我们也有 $x_{n+1} = \\sin^2(\\theta_{n+1})$。令这两个关于 $x_{n+1}$ 的表达式相等，我们得到：\n$$\\sin^2(\\theta_{n+1}) = \\sin^2(2\\theta_n)$$\n由于 $\\theta_{n+1}$ 必须位于区间 $[0, \\pi)$ 内，这个方程意味着 $\\theta_{n+1}$ 与 $2\\theta_n$ 的关系是相差 $\\pi$ 的整数倍。具体来说，$\\theta_n$ 的演化律是在圆 $\\mathbb{R}/\\pi\\mathbb{Z}$ 上的二倍映射（或称伯努利移位映射）：\n$$\\theta_{n+1} = 2\\theta_n \\pmod{\\pi}$$\n这意味着 $\\theta_{n+1}$ 是 $2\\theta_n$ 除以 $\\pi$ 后的余数，结果落在 $[0,\\pi)$ 区间内。这就是 $\\theta_{n+1}$ 关于 $\\theta_n$ 的精确演化律。\n\n接下来，我们寻求 $x_N$ 的闭合形式表达式。为此，我们首先解出 $\\theta_n$ 的递推关系。关系式 $\\theta_{n+1} \\equiv 2\\theta_n \\pmod{\\pi}$ 是一个简单的模 $\\pi$ 的几何级数。我们可以通过迭代来求解它：\n$$\\theta_1 \\equiv 2\\theta_0 \\pmod{\\pi}$$\n$$\\theta_2 \\equiv 2\\theta_1 \\equiv 2(2\\theta_0) \\equiv 2^2\\theta_0 \\pmod{\\pi}$$\n$$\\theta_3 \\equiv 2\\theta_2 \\equiv 2(2^2\\theta_0) \\equiv 2^3\\theta_0 \\pmod{\\pi}$$\n通过归纳法，很容易看出通项 $\\theta_N$ 由下式给出：\n$$\\theta_N \\equiv 2^N \\theta_0 \\pmod{\\pi}$$\n这个同余关系意味着 $\\theta_N$ 可以写成 $\\theta_N = 2^N\\theta_0 - k\\pi$ 的形式，其中整数 $k$ 的选择使得结果映射到区间 $[0, \\pi)$ 内。\n\n最后，我们将 $x_N$ 表示为 $\\theta_0$ 和 $N$ 的函数。我们将 $\\theta_N$ 的结果代回到变换 $x_N = \\sin^2(\\theta_N)$ 中：\n$$x_N = \\sin^2(2^N \\theta_0 - k\\pi)$$\n正弦函数具有性质 $\\sin(\\alpha - k\\pi) = (-1)^k \\sin(\\alpha)$。因此，正弦函数的平方是以 $\\pi$ 为周期的：\n$$\\sin^2(\\alpha - k\\pi) = ((-1)^k \\sin(\\alpha))^2 = (-1)^{2k} \\sin^2(\\alpha) = \\sin^2(\\alpha)$$\n将此性质应用于我们关于 $x_N$ 的表达式，项 $-k\\pi$ 对其值没有影响。\n$$x_N = \\sin^2(2^N \\theta_0)$$\n这就是所求的 $x_N$ 作为初始角 $\\theta_0$ 和迭代次数 $N$ 的函数的闭合形式解析表达式。", "answer": "$$\\boxed{\\sin^2(2^N \\theta_0)}$$", "id": "2409501"}, {"introduction": "理论上的数学模型与计算机上的数值模拟之间存在着重要差异。虽然理想化的逻辑斯蒂映射在 $r=4$ 时是混沌的，但在有限精度的计算机上，其行为会因状态空间的离散化而发生根本性改变。这个练习将引导你探索这种差异，通过在一个有限网格上模拟该系统，你将证明任何轨迹最终都将变为周期性的，这是计算科学中的一个基本而深刻的结论 [@problem_id:2409551]。", "problem": "考虑由以下递推关系定义的逻辑斯蒂映射\n$$ x_{n+1} = r\\,x_n\\,(1 - x_n), $$\n其中控制参数固定为 $r = 4$，初始条件为 $x_0 \\in [0,1]$。为了以一种通用且与语言无关的方式对有限精度算术进行建模，固定一个精度参数 $B \\in \\mathbb{N}$ 并定义 $N = 2^B$。容许的状态空间是均匀网格\n$$ \\mathcal{G}_B = \\left\\{ \\frac{k}{N} \\,\\middle|\\, k \\in \\{0,1,2,\\dots,N\\} \\right\\}。 $$\n定义量化器 $Q_B:[0,1]\\to \\mathcal{G}_B$ 为\n$$ Q_B(y) = \\frac{\\mathrm{round}(N\\,y)}{N}， $$\n其中 $\\mathrm{round}(\\cdot)$ 表示四舍五入到最近的整数，若结果恰为 .5 则舍入到最近的偶数。有限精度逻辑斯蒂映射 $F_B:\\mathcal{G}_B \\to \\mathcal{G}_B$ 为\n$$ F_B(x) = Q_B\\!\\left(4\\,x\\,(1-x)\\right)。 $$\n设轨迹为 $x_{n+1} = F_B(x_n)$，其中 $x_0 \\in \\mathcal{G}_B$。定义轨迹的最终周期（也称为循环长度）为任意有限瞬态之后周期部分的长度 $ \\lambda \\in \\mathbb{N} $。\n\n任务：\n1) 仅使用第一性原理，证明对于每个固定的 $B \\in \\mathbb{N}$ 和每个初始条件 $x_0 \\in \\mathcal{G}_B$，在 $F_B$ 下的轨迹最终是周期的，即它有一个有限的瞬态长度，然后以某个有限周期 $\\lambda$ 重复。\n\n2) 对于以下测试套件，通过对形式为 $x_0 = k/N$（其中 $k \\in \\{1,2,\\dots,S_B\\}$）的 $S_B$ 个初始条件计算最终周期 $\\lambda$ 的平均值：\n- 情况 A：$B = 8$，$S_B = 200$。\n- 情况 B：$B = 12$，$S_B = 200$。\n- 情况 C：$B = 16$，$S_B = 200$。\n将每个平均值报告为一个实数，四舍五入到恰好 $3$ 位小数。\n\n3) 边界情况（单一种子的最终周期）：\n- 情况 D：$B = 8$，$x_0 = 0$。\n- 情况 E：$B = 8$，$x_0 = \\frac{1}{2}$（即 $k = N/2$）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 [情况 A, 情况 B, 情况 C, 情况 D, 情况 E]。对于情况 A–C，输出四舍五入到恰好 $3$ 位小数的平均值。对于情况 D–E，输出最终周期为整数。例如，输出应如下所示\n\"[10.123,40.321,160.654,1,1]\"。\n不应打印任何其他文本。", "solution": "首先对问题陈述的有效性进行严格审查。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **逻辑斯蒂映射：** $x_{n+1} = r\\,x_n\\,(1 - x_n)$\n- **参数：** $r = 4$\n- **精度参数：** $B \\in \\mathbb{N}$\n- **网格大小：** $N = 2^B$\n- **状态空间：** $\\mathcal{G}_B = \\left\\{ \\frac{k}{N} \\,\\middle|\\, k \\in \\{0,1,2,\\dots,N\\} \\right\\}$\n- **量化器：** $Q_B(y) = \\frac{\\mathrm{round}(N\\,y)}{N}$，其中平局情况舍入到最近的偶数。\n- **有限精度映射：** $F_B(x) = Q_B\\!\\left(4\\,x\\,(1-x)\\right)$\n- **轨迹：** $x_{n+1} = F_B(x_n)$，其中 $x_0 \\in \\mathcal{G}_B$。\n- **最终周期 ($\\lambda$)：** 轨迹周期部分的长度。\n- **任务 1：** 证明对于任意 $B$和 $x_0 \\in \\mathcal{G}_B$，所有轨迹最终都是周期的。\n- **任务 2：** 计算以下情况的平均最终周期：\n    - 情况 A：$B = 8$，对 $x_0 = k/N$（其中 $k \\in \\{1, \\dots, 200\\}$）进行平均。\n    - 情况 B：$B = 12$，对 $x_0 = k/N$（其中 $k \\in \\{1, \\dots, 200\\}$）进行平均。\n    - 情况 C：$B = 16$，对 $x_0 = k/N$（其中 $k \\in \\{1, \\dots, 200\\}$）进行平均。\n- **任务 3：** 计算以下情况的最终周期：\n    - 情况 D：$B = 8, x_0 = 0$。\n    - 情况 E：$B = 8, x_0 = \\frac{1}{2}$。\n- **输出格式：** 逗号分隔的列表 `[A, B, C, D, E]`，其中 A-C 四舍五入到 $3$ 位小数。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，研究了有限精度对著名混沌系统——逻辑斯蒂映射的影响。这是计算物理学和非线性动力学中的一个标准课题。所有术语都经过了精确的数学定义。映射 $F_B$ 是定义在有限状态空间上的一个确定性函数，这是一个适定结构。任务是具体的、客观的，并且在计算上是可行的。该问题没有违反任何科学合理性或逻辑一致性原则。它是完整且明确的。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。我们继续进行求解。\n\n---\n\n### 解决方案\n\n该问题包含两项任务：一项理论证明和一组数值计算。\n\n**任务 1：最终周期性的证明**\n\n这一证明是状态空间 $\\mathcal{G}_B$ 有限性的直接推论。\n对于一个固定的精度参数 $B \\in \\mathbb{N}$，网格大小为 $N = 2^B$。状态空间定义为 $\\mathcal{G}_B = \\left\\{ \\frac{k}{N} \\,\\middle|\\, k \\in \\{0,1,2,\\dots,N\\} \\right\\}$。该集合中不同状态的数量，即其基数，为 $|\\mathcal{G}_B| = N+1 = 2^B+1$。对于任何自然数 $B$，这都是一个有限量。\n\n函数 $F_B$ 的构造使其将状态空间 $\\mathcal{G}_B$ 映射到自身，即 $F_B: \\mathcal{G}_B \\to \\mathcal{G}_B$。对于任何初始状态 $x_0 \\in \\mathcal{G}_B$，其轨迹是一个无限的状态序列 $x_0, x_1, x_2, \\dots$，其中每个 $x_n = F_B(x_{n-1}) \\in \\mathcal{G}_B$。\n\n我们有一个从有限的可能性集合中抽取的无限状态序列。根据鸽巢原理，至少有一个状态必须被访问超过一次。设 $x_j$ 是序列中第一个重复先前状态（比如 $x_i$，$i < j$）的状态。令这对索引 $(i, j)$ 满足 $i$ 最小化。\n\n因此，状态序列为 $x_0, x_1, \\dots, x_{i-1}, \\left(x_i, x_{i+1}, \\dots, x_{j-1}\\right), \\dots$。\n段落 $x_0, \\dots, x_{i-1}$ 是轨迹的瞬态部分，其长度为有限值 $i$。\n段落 $x_i, \\dots, x_{j-1}$ 构成一个循环。由于映射 $F_B$ 是确定性的，状态 $x_j=x_i$ 必然会跟随 $x_{j+1} = F_B(x_j) = F_B(x_i) = x_{i+1}$，并且后续状态将以相同的顺序重复。这确立了序列在瞬态部分之后的周期性。这个循环的长度，即最终周期，是 $\\lambda = j-i$。\n\n由于在有限状态空间上的任何轨迹都保证存在这样的索引 $i$ 和 $j$，因此在 $F_B$ 下的每个轨迹最终都是周期的。证明完毕。\n\n**任务 2 & 3：计算算法**\n\n为了计算最终周期 $\\lambda$，我们必须在给定初始条件生成的轨迹中检测循环。一个稳健且高效的方法是 Floyd 循环查找算法，也称为“龟兔赛跑”算法。\n\n为确保计算精度并在模拟过程中避免浮点表示错误，我们在整数集合 $\\{0, 1, \\dots, N\\}$ 上重构动力学。每个状态 $x_n \\in \\mathcal{G}_B$ 由一个整数 $k_n$ 唯一表示，使得 $x_n = k_n / N$。分数上的映射 $F_B$ 导出一个相应的整数映射 $f_B(k_n) = k_{n+1}$。\n从 $x_{n+1} = F_B(x_n)$ 开始，我们代入 $x_n = k_n/N$ 和 $x_{n+1} = k_{n+1}/N$：\n$$\n\\frac{k_{n+1}}{N} = Q_B\\left(4 \\frac{k_n}{N} \\left(1 - \\frac{k_n}{N}\\right)\\right) = \\frac{\\mathrm{round}\\left(N \\cdot 4 \\frac{k_n}{N} \\frac{N-k_n}{N}\\right)}{N}\n$$\n这给出了基于整数的递推关系：\n$$\nk_{n+1} = f_B(k_n) = \\mathrm{round}\\left(\\frac{4 k_n (N-k_n)}{N}\\right)\n$$\n问题指定 $\\mathrm{round}(\\cdot)$ 通过选择最近的偶数来处理平局情况。`numpy.round` 函数符合此标准。\n\n将 Floyd 算法应用于由 $k_{n+1} = f_B(k_n)$ 生成的序列 $k_0, k_1, k_2, \\dots$，过程分为三个标准阶段：\n1.  **碰撞检测：** 初始化一个“乌龟”指针（一次前进一步）和一个“兔子”指针（一次前进两步）。它们最终必将在循环内的某个状态上相遇。\n2.  **循环起点识别：** 一个指针重置到初始状态 $k_0$，而另一个指针保持在碰撞点。然后两者都一次前进一步。它们的下一个相遇点是循环的第一个状态 $k_\\mu$。步数 $\\mu$ 是瞬态长度。\n3.  **周期计算：** 一个指针从 $k_\\mu$ 开始一次前进一步，直到它返回到 $k_\\mu$。所需的步数就是循环长度 $\\lambda$。\n\n此算法被实现用于解决测试案例。对于情况 A-C，计算了指定初始条件范围内的平均 $\\lambda$。对于情况 D-E，确定了单个初始条件的 $\\lambda$。结果按要求格式化。", "answer": "```python\nimport numpy as np\n\ndef find_eventual_period(B: int, k0: int) -> int:\n    \"\"\"\n    Computes the eventual period of the finite-precision logistic map trajectory.\n\n    The algorithm uses Floyd's cycle-finding algorithm (tortoise and hare)\n    on an integer representation of the state space to avoid floating-point issues.\n\n    Args:\n        B: The precision parameter, defining N = 2**B.\n        k0: The initial state represented as an integer k, where x_0 = k/N.\n\n    Returns:\n        The length of the eventual periodic cycle (lambda).\n    \"\"\"\n    N = 2**B\n\n    # The finite-precision map on the integer state space {0, 1, ..., N}.\n    # The rounding rule \"ties to nearest even\" is correctly implemented by np.round().\n    def f(k: int) -> int:\n        # Use floating point for the division, which is safe as the state 'k' is\n        # always an integer, ensuring exact comparisons.\n        val = 4.0 * k * (N - k) / N\n        return int(np.round(val))\n\n    # Floyd's Algorithm\n    # Phase 1: Find a point in the cycle.\n    # The tortoise moves one step at a time, the hare moves two.\n    try:\n        tortoise = f(k0)\n        hare = f(f(k0))\n    except (OverflowError, ValueError):\n        # In rare cases with very large B, intermediate products might overflow standard Python integers\n        # before the division. For the given constraints, this is not an issue.\n        # This is a safeguard for general application.\n        return -1 \n\n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(f(hare))\n\n    # Phase 2: Find the start of the cycle.\n    # The number of steps 'mu' is the length of the transient part.\n    mu = 0\n    tortoise = k0\n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(hare)\n        mu += 1\n\n    # Phase 3: Find the length of the cycle (the eventual period, lambda).\n    # Start from the first element of the cycle and count steps until return.\n    lam = 1\n    hare = f(tortoise)\n    while tortoise != hare:\n        hare = f(hare)\n        lam += 1\n\n    return lam\n\ndef compute_average_period(B: int, S_B: int) -> float:\n    \"\"\"\n    Computes the average eventual period over a range of initial conditions.\n\n    Args:\n        B: The precision parameter.\n        S_B: The number of initial conditions to test (k from 1 to S_B).\n\n    Returns:\n        The average period.\n    \"\"\"\n    periods = []\n    for k in range(1, S_B + 1):\n        period = find_eventual_period(B, k)\n        periods.append(period)\n    \n    return np.mean(periods)\n\ndef solve():\n    \"\"\"\n    Solves the given problem by computing results for all five cases\n    and printing them in the specified format.\n    \"\"\"\n    # Case A: B = 8, S_B = 200\n    avg_A = compute_average_period(B=8, S_B=200)\n\n    # Case B: B = 12, S_B = 200\n    avg_B = compute_average_period(B=12, S_B=200)\n\n    # Case C: B = 16, S_B = 200\n    avg_C = compute_average_period(B=16, S_B=200)\n\n    # Case D: B = 8, x_0 = 0 (k=0)\n    period_D = find_eventual_period(B=8, k0=0)\n\n    # Case E: B = 8, x_0 = 1/2 (k = N/2)\n    N_E = 2**8\n    k0_E = N_E // 2\n    period_E = find_eventual_period(B=8, k0=k0_E)\n\n    # Construct the final output string as per requirements.\n    results = [\n        f\"{avg_A:.3f}\",\n        f\"{avg_B:.3f}\",\n        f\"{avg_C:.3f}\",\n        str(period_D),\n        str(period_E)\n    ]\n    \n    # Print the single-line output.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2409551"}, {"introduction": "对于逻辑斯蒂映射的大多数参数 $r$ 值，并不存在简单的解析解，我们必须依赖强大的数值方法来探索其动力学。本练习将指导你开发一个通用的算法，用于系统性地寻找周期轨道——这些轨道是理解系统动力学结构的基本骨架。你将学习如何将牛顿-拉夫逊方法与链式法则相结合，以高效地定位任意周期长度 $n$ 的吸引轨道，这是动力系统研究中一项核心的计算技能 [@problem_id:2409563]。", "problem": "考虑定义在单位区间 $[0,1]$ 上的逻辑斯蒂映射，其函数为 $f_{r}(x) = r x (1 - x)$，其中控制参数 $r \\in [0,4]$。对于正整数 $n$，用 $f_{r}^{n}(x)$ 表示 $f_{r}$ 自身的 $n$ 次复合。如果一个点 $x^{\\star} \\in [0,1]$ 满足 $f_{r}^{n}(x^{\\star}) = x^{\\star}$，并且对于每个整除 $n$ 且小于 $n$ 的正整数 $d$ 都有 $f_{r}^{d}(x^{\\star}) \\neq x^{\\star}$，则该点被称为素周期为 $n$ 的周期点。此类周期点的稳定性由乘子 $\\lambda_{n}(x^{\\star}) = (f_{r}^{n})'(x^{\\star})$ 来刻画，当 $|\\lambda_{n}(x^{\\star})| < 1$ 时，该周期点是吸引的。\n\n您的任务是开发一个完整、可运行的程序，对于给定的 $(r,n)$，该程序能高效地找到逻辑斯蒂映射在 $[0,1]$ 上的所有不同的吸引素周期 $n$ 轨道。算法必须从适用于计算物理和动力系统的第一性原理出发：函数复合的定义、导数的链式法则以及用于求解非线性方程的牛顿-拉夫逊方法。关键思想是搜索方程 $F_{n}(x) = f_{r}^{n}(x) - x = 0$ 的解，其中使用导数 $F'_{n}(x) = (f_{r}^{n})'(x) - 1$，该导数通过沿 $x$ 的 $n$ 步轨道应用链式法则来高效计算。您还必须确保报告的每个解都是素周期的（即，精确周期为 $n$）和吸引的（即，满足 $|(f_{r}^{n})'(x)| < 1$），并且轨道在点的循环排列下是唯一的（已去重）。\n\n程序必须纯粹用数学术语实现以下计算步骤，不依赖任何外部数据：\n- 在 $[0,1]$ 中使用多个初始猜测值。\n- 对于每个初始猜测值，对 $F_{n}(x) = 0$ 应用牛顿-拉夫逊迭代，其导数基于 $(f_{r}^{n})'(x)$，该导数通过沿迭代序列 $x, f_{r}(x), f_{r}^{2}(x), \\dots, f_{r}^{n-1}(x)$ 应用链式法则计算。\n- 仅当候选根 $x^{\\star}$ 满足以下条件时才接受它：$|F_{n}(x^{\\star})|$ 低于一个严格的容差，$x^{\\star} \\in [0,1]$，周期是素周期的（即不存在更小的因子 $d$ 使得 $f_{r}^{d}(x^{\\star}) \\approx x^{\\star}$），并且轨道是吸引的，满足 $|(f_{r}^{n})'(x^{\\star})| < 1$。\n- 将所有找到的根分组为 $[0,1]$ 上不同的吸引素周期 $n$ 轨道，其中如果两个根在 $f_{r}$ 作用下的前向 $n$ 元组在数值容差范围内、在循环排列下是重合的，则它们属于同一轨道。\n- 返回不同吸引素周期 $n$ 轨道的数量。\n\n不涉及角度。不涉及物理单位。所有数值输出必须是标准十进制表示的实数。\n\n测试套件和要求输出：\n- 使用以下参数情况：$(r,n) = (0.5, 1)$、$(2.5, 1)$、$(3.2, 2)$、$(3.83, 3)$、$(4.0, 1)$。\n- 对于每种情况，您的程序必须计算一个整数：在 $[0,1]$ 中找到的不同吸引素周期 $n$ 轨道的数量。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[a,b,c,d,e]$），其顺序与上面列出的情况相同。\n\n您的最终程序必须是自包含的，不需要任何输入，并且只能使用指定的环境。", "solution": "该问题是有效的。这是一个计算动力系统领域中的良置问题（well-posed problem），它基于与逻辑斯蒂映射相关的既定数学原理和定义。其目标明确，所提供的信息足以按要求从第一性原理构建数值解。\n\n核心任务是为定义在区间 $[0,1]$ 上的逻辑斯蒂映射（函数为 $f_{r}(x) = r x (1 - x)$）找到不同吸引素周期 $n$ 轨道的数量。如果一个点 $x^{\\star}$ 满足方程 $f_{r}^{n}(x^{\\star}) = x^{\\star}$，那么它就是周期为 $n$ 的轨道的一部分，其中 $f_{r}^{n}$ 表示函数 $f_{r}$ 的第 $n$ 次迭代。这可以改写为寻找非线性方程 $F_{n}(x) = f_{r}^{n}(x) - x = 0$ 的根。\n\n为求解此方程，牛顿-拉夫逊方法是一种合适且强大的数值技术。该方法的迭代公式为：\n$$x_{k+1} = x_{k} - \\frac{F_{n}(x_{k})}{F'_{n}(x_{k})}$$\n其中 $x_{k}$ 是第 $k$ 次迭代的估计值。需要导数 $F'_{n}(x)$，即 $F'_{n}(x) = (f_{r}^{n})'(x) - 1$。\n\n该算法基于以下原理构建：\n\n1.  **高效的函数和导数求值**：$f_{r}^{n}(x)$ 的直接解析表达式是一个 $2^n$ 次多项式，对于中等大小的 $n$ 而言，其计算也是不可行的。因此，$f_{r}^{n}(x)$ 及其导数 $(f_{r}^{n})'(x)$ 都是沿着点 $x_0$ 的轨道进行数值计算的。\n    -   为计算 $f_{r}^{n}(x_0)$，生成序列 $x_1 = f_r(x_0)$, $x_2 = f_r(x_1)$, $\\dots$, $x_n = f_r(x_{n-1})$。结果就是 $x_n$。\n    -   为计算导数 $(f_{r}^{n})'(x_0)$，将链式法则应用于复合函数 $f_{r}^{n}(x) = f_r(f_r(\\dots f_r(x)\\dots))$。这会得到 $f_r$ 在轨道序列中每个点上的一阶导数的乘积：\n        $$\\lambda_{n}(x_0) = (f_{r}^{n})'(x_0) = \\prod_{i=0}^{n-1} f'_{r}(x_i) = \\prod_{i=0}^{n-1} r(1 - 2x_i)$$\n        这个乘积 $\\lambda_{n}(x_0)$ 也是轨道的稳定性乘子。\n\n2.  **通过牛顿-拉夫逊搜索进行根查找**：牛顿-拉夫逊方法从区间 $[0,1]$ 上大量均匀分布的起始点开始。这种全面的搜索策略增加了找到所有吸引轨道的概率。对于每个初始猜测值，迭代过程将持续进行，直到连续迭代之间的变化量低于严格容差 $\\epsilon$（例如 $\\epsilon = 10^{-12}$）或达到最大迭代次数。\n\n3.  **候选根的验证**：一旦牛顿-拉夫逊方法收敛到一个潜在的根 $x^{\\star}$，它将经过一个严格的多阶段验证过程：\n    -   **收敛性**：首先通过检查 $|f_{r}^{n}(x^{\\star}) - x^{\\star}| < \\epsilon$ 来确认 $x^{\\star}$ 确实是一个根。\n    -   **稳定性**：只有当其乘子的绝对值小于 1 时，轨道才是吸引的。我们必须计算 $\\lambda_{n}(x^{\\star})$ 并验证 $|\\lambda_{n}(x^{\\star})| < 1$。对应于排斥或中性轨道（$|\\lambda_{n}(x^{\\star})| \\geq 1$）的根将被丢弃。\n    -   **素周期性**：为确保轨道的素周期恰好为 $n$，我们必须验证它不属于周期更小的轨道 $d$，其中 $d$ 是 $n$ 的一个真因子（$d|n$ 且 $d < n$）。对于每个这样的 $d$，我们检查 $|f_{r}^{d}(x^{\\star}) - x^{\\star}| > \\epsilon$ 是否成立。如果该条件对任何 $d$ 不成立，则该根属于一个周期为 $d$ 的轨道，应被丢弃。\n\n4.  **轨道去重**：从不同的初始猜测值出发，牛顿-拉夫逊方法可能会收敛到属于同一周期轨道的不同点上。为只计算不同轨道的数量，去重程序是必要的。当找到一个经过验证的根 $x^{\\star}$ 时，会生成其完整轨道 $\\{x^{\\star}, f_r(x^{\\star}), \\dots, f_r^{n-1}(x^{\\star})\\}$。通过对其点进行数值排序，可以创建该轨道的规范表示。然后将此排序后的列表与先前找到的唯一轨道集合进行比较。只有当新轨道与任何已存储的轨道在数值上不接近（在容差范围内，例如 $10^{-9}$）时，才将其添加到集合中。\n\n在搜索完成后，不同、吸引、素周期为 $n$ 的轨道的最终数量就是集合中唯一轨道的总数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # Scipy is not used as the Newton-Raphson solver is implemented from first principles.\n\ndef find_proper_divisors(n):\n    \"\"\"\n    Finds all proper divisors of an integer n (divisors other than n).\n    \"\"\"\n    if n <= 1:\n        return []\n    \n    divisors = {1}\n    for i in range(2, int(np.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(list(divisors))\n\ndef find_attracting_orbits(r, n):\n    \"\"\"\n    Finds the number of distinct attracting primitive period-n orbits for the logistic map\n    f_r(x) = r*x*(1-x).\n\n    Args:\n        r (float): The control parameter of the logistic map.\n        n (int): The period of the orbits to find.\n\n    Returns:\n        int: The number of distinct attracting primitive period-n orbits.\n    \"\"\"\n    # Define numerical parameters for the solver\n    num_guesses = 20000\n    max_newton_iter = 50\n    conv_tol = 1e-12  # Tolerance for root convergence and verification\n    dedup_tol = 1e-9   # Tolerance for orbit point comparison during deduplication\n\n    # Define the logistic map and its first derivative\n    f = lambda x: r * x * (1.0 - x)\n    f_prime = lambda x: r * (1.0 - 2.0 * x)\n\n    proper_divisors = find_proper_divisors(n)\n    found_orbits = []\n\n    # Use a grid of initial guesses in (0, 1) to avoid potential issues at boundaries\n    initial_guesses = np.linspace(1e-4, 1.0 - 1e-4, num_guesses)\n\n    for x_init in initial_guesses:\n        x_k = x_init\n        \n        # Newton-Raphson iteration to find a root of F_n(x) = f^n(x) - x = 0\n        for _ in range(max_newton_iter):\n            if not (0.0 <= x_k <= 1.0):\n                break # Iteration left the domain of interest\n\n            # Generate the orbit sequence x_0, x_1, ..., x_{n-1} starting from x_k\n            orbit_seq = [x_k]\n            current_x = x_k\n            try:\n                for _ in range(n - 1):\n                    current_x = f(current_x)\n                    orbit_seq.append(current_x)\n            except (OverflowError, ValueError):\n                break # Sequence diverged or resulted in math error\n            \n            x_n = f(current_x)\n\n            # Compute the derivative (multiplier) (f^n)'(x_k) using the chain rule\n            multiplier = 1.0\n            try:\n                for point in orbit_seq:\n                    multiplier *= f_prime(point)\n            except (OverflowError, ValueError):\n                break\n\n            # Define F_n(x_k) and its derivative F_n'(x_k)\n            fn_x = x_n - x_k\n            fn_prime_x = multiplier - 1.0\n\n            if abs(fn_prime_x) < 1e-12: # Avoid division by zero or unstable updates\n                break\n\n            x_k_plus_1 = x_k - fn_x / fn_prime_x\n\n            # Check for convergence\n            if abs(x_k_plus_1 - x_k) < conv_tol:\n                x_k = x_k_plus_1\n                break\n            \n            x_k = x_k_plus_1\n        else:\n            # The loop finished without converging, try next initial guess\n            continue\n        \n        # --- Validation of the candidate root x_star = x_k ---\n        x_star = x_k\n\n        # 1. Domain Check: Must be in [0, 1]\n        if not (0.0 <= x_star <= 1.0):\n            continue\n\n        # 2. Convergence Check: Verify |f^n(x_star) - x_star| is small\n        current_x = x_star\n        try:\n            for _ in range(n):\n                current_x = f(current_x)\n        except (OverflowError, ValueError):\n            continue\n        if abs(current_x - x_star) > conv_tol:\n            continue\n            \n        # 3. Stability Check: The multiplier |(f^n)'(x_star)| must be less than 1\n        orbit_seq = [x_star]\n        current_x = x_star\n        try:\n            for _ in range(n - 1):\n                current_x = f(current_x)\n                orbit_seq.append(current_x)\n        except (OverflowError, ValueError):\n            continue\n        \n        multiplier = 1.0\n        try:\n            for point in orbit_seq:\n                multiplier *= f_prime(point)\n        except (OverflowError, ValueError):\n            continue\n        if abs(multiplier) >= 1.0:\n            continue\n            \n        # 4. Primitivity Check: f^d(x_star) is not close to x_star for any proper divisor d\n        is_primitive = True\n        for d in proper_divisors:\n            current_x = x_star\n            try:\n                for _ in range(d):\n                    current_x = f(current_x)\n            except (OverflowError, ValueError):\n                is_primitive = False\n                break\n            if abs(current_x - x_star) < conv_tol:\n                is_primitive = False\n                break\n        if not is_primitive:\n            continue\n\n        # --- The root is valid. Add its orbit to the list after deduplication ---\n        new_orbit_sorted = sorted(orbit_seq)\n\n        # Check if this orbit is a duplicate of one already found\n        is_duplicate = False\n        for existing_orbit in found_orbits:\n            # Use allclose for element-wise comparison with absolute tolerance\n            if np.allclose(new_orbit_sorted, existing_orbit, rtol=0, atol=dedup_tol):\n                is_duplicate = True\n                break\n        \n        if not is_duplicate:\n            found_orbits.append(new_orbit_sorted)\n            \n    return len(found_orbits)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each, and print the\n    final results in the specified format.\n    \"\"\"\n    # The set of test cases (r, n) provided in the problem statement.\n    test_cases = [\n        (0.5, 1),\n        (2.5, 1),\n        (3.2, 2),\n        (3.83, 3),\n        (4.0, 1),\n    ]\n\n    results = []\n    for r, n in test_cases:\n        count = find_attracting_orbits(r, n)\n        results.append(count)\n\n    # Print the final results in the required format: [res1,res2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main solver function.\nsolve()\n```", "id": "2409563"}]}