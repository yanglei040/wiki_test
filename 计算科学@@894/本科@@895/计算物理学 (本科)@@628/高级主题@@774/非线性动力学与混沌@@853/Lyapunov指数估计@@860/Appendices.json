{"hands_on_practices": [{"introduction": "掌握李雅普诺夫指数$ (\\lambda) $最直观的方法，是直接观察两个初始状态极为接近的轨迹如何随时间演化而分离。这个练习将引导你通过一个经典的混沌动力学模型——逻辑斯蒂映射 (logistic map)——来进行一次直接的数值估算 [@problem_id:1940452]。通过计算分离距离的指数增长率，你将对李雅普诺夫指数如何量化系统对初始条件的敏感依赖性（即“蝴蝶效应”）建立起一个具体而深刻的理解。", "problem": "逻辑斯蒂映射由迭代方程 $x_{n+1} = r x_n (1 - x_n)$ 给出，它是一个能表现出混沌行为的简单数学模型。它常被用来模拟种群动态，其中 $x_n$ 表示第 $n$ 代的归一化种群大小，$r$ 是与增长率相关的参数。\n\n混沌系统的一个关键特征是其对初始条件的极端敏感性。这种敏感性由李雅普诺夫指数 $\\lambda$ 来量化。对于从两个非常接近的初始点 $x_0$ 和 $y_0 = x_0 + \\delta_0$ 开始的两条轨迹，经过 $n$ 次迭代后，它们的偏离量 $\\delta_n = y_n - x_n$ 在平均情况下预期会呈指数级增长，当迭代次数 $n$ 足够大时，遵循关系式 $|\\delta_n| \\approx |\\delta_0| \\exp(n\\lambda)$。\n\n考虑增长参数设为 $r=3.7$ 的逻辑斯蒂映射。从两个非常接近的初始条件开始进行两次数值模拟：\n- 轨迹A从 $x_0=0.5$ 开始\n- 轨迹B从 $y_0 = 0.5 + 10^{-8}$ 开始\n\n系统演化 $n=20$ 次迭代后，两条轨迹的状态分别为 $x_{20} = 0.852310$ 和 $y_{20} = 0.852313$。\n\n使用这些数值，估算该系统的李雅普诺夫指数 $\\lambda$。将最终答案保留到三位有效数字。", "solution": "该问题要求使用提供的两条初始接近轨迹的数据，估算当 $r=3.7$ 时逻辑斯蒂映射的李雅普诺夫指数 $\\lambda$。\n\n初始偏离量 $\\delta_0$ 与经过 $n$ 次迭代后的偏离量 $\\delta_n$ 之间的关系由下式给出：\n$$|\\delta_n| \\approx |\\delta_0| \\exp(n\\lambda)$$\n\n我们的目标是解此方程求出 $\\lambda$。首先，我们分离出指数项：\n$$\\frac{|\\delta_n|}{|\\delta_0|} \\approx \\exp(n\\lambda)$$\n\n接下来，我们对等式两边取自然对数以消去指数函数：\n$$\\ln\\left(\\frac{|\\delta_n|}{|\\delta_0|}\\right) \\approx n\\lambda$$\n\n最后，我们解出 $\\lambda$：\n$$\\lambda \\approx \\frac{1}{n} \\ln\\left(\\frac{|\\delta_n|}{|\\delta_0|}\\right)$$\n\n现在，我们必须根据给定信息计算 $\\delta_0$ 和 $\\delta_n$ 的值。\n\n初始条件为 $x_0=0.5$ 和 $y_0 = 0.5 + 10^{-8}$。初始偏离量 $\\delta_0$ 是：\n$$\\delta_0 = y_0 - x_0 = (0.5 + 10^{-8}) - 0.5 = 10^{-8}$$\n其绝对值为 $|\\delta_0| = 10^{-8}$。\n\n经过 $n=20$ 次迭代后的状态为 $x_{20} = 0.852310$ 和 $y_{20} = 0.852313$。最终偏离量 $\\delta_{20}$ 是：\n$$\\delta_{20} = y_{20} - x_{20} = 0.852313 - 0.852310 = 0.000003$$\n其绝对值为 $|\\delta_{20}| = 0.000003 = 3 \\times 10^{-6}$。\n\n现在我们可以将这些值及 $n=20$ 代入 $\\lambda$ 的表达式中：\n$$\\lambda \\approx \\frac{1}{20} \\ln\\left(\\frac{|\\delta_{20}|}{|\\delta_0|}\\right) = \\frac{1}{20} \\ln\\left(\\frac{3 \\times 10^{-6}}{10^{-8}}\\right)$$\n\n我们先来计算对数的真数（即对数内的项）：\n$$\\frac{3 \\times 10^{-6}}{10^{-8}} = 3 \\times 10^{-6 - (-8)} = 3 \\times 10^2 = 300$$\n\n现在，将此结果代回 $\\lambda$ 的表达式中：\n$$\\lambda \\approx \\frac{1}{20} \\ln(300)$$\n\n使用计算器，我们得到 $\\ln(300)$ 的值：\n$$\\ln(300) \\approx 5.7037824744$$\n\n因此，$\\lambda$ 的估算值为：\n$$\\lambda \\approx \\frac{5.7037824744}{20} \\approx 0.2851891237$$\n\n题目要求答案保留三位有效数字。\n第一个有效数字是2，第二个是8，第三个是5。后一位数字是1，小于5，因此我们向下舍入（即，不改变最后一个有效数字）。\n$$\\lambda \\approx 0.285$$", "answer": "$$\\boxed{0.285}$$", "id": "1940452"}, {"introduction": "正的李雅普诺夫指数是混沌的标志，那么在一个稳定、可预测的系统中，它又代表什么呢？这个练习将探讨非混沌动力学下的情况 [@problem_id:2064908]。我们将研究逻辑斯蒂映射在另一参数下表现出的稳定周期2轨道，你将分析并计算稳定轨道上的李雅普诺夫指数。这个过程会揭示负的李雅普诺夫指数的物理意义——它表示轨迹会收敛到一个稳定的吸引子上，从而标志着系统的可预测性和稳定性。", "problem": "一个非线性数字振荡器状态的简化模型由离散的一维逻辑斯蒂映射描述，其方程为：\n$$x_{n+1} = f(x_n) = r x_n (1 - x_n)$$\n其中 $x_n$ 表示在时间步长 $n$ 时振荡器的归一化状态，且 $x_n \\in [0, 1]$。该系统的行为由参数 $r$ 控制。对于特定的参数值 $r = 3.2$，系统在经过一个瞬态阶段后，会稳定到一个稳定的周期-2 轨道。一个周期-2 轨道是两个不同点的集合 $\\{p_1, p_2\\}$，系统会在这两个点之间无限交替：$f(p_1) = p_2$ 且 $f(p_2) = p_1$。\n\n您的任务是计算这个稳定的周期-2 轨道的有限时间李雅普诺夫指数。\n\n将您的最终答案四舍五入到四位有效数字。", "solution": "我们已知逻辑斯蒂映射 $f(x)=r x (1 - x)$，其中 $r=3.2$，并且系统稳定在一个满足 $f(p_{1})=p_{2}$ 和 $f(p_{2})=p_{1}$ 的稳定周期-2 轨道 $\\{p_{1},p_{2}\\}$ 上。对于一个周期-2 轨道，在一个完整周期内每次迭代的有限时间李雅普诺夫指数为\n$$\n\\lambda=\\frac{1}{2}\\left[\\ln|f'(p_{1})|+\\ln|f'(p_{2})|\\right]=\\frac{1}{2}\\ln\\left|f'(p_{1})f'(p_{2})\\right|.\n$$\n对于逻辑斯蒂映射，其导数为 $f'(x)=r(1-2x)$。因此\n$$\nf'(p_{1})f'(p_{2})=r^{2}(1-2p_{1})(1-2p_{2})=r^{2}\\left[1-2(p_{1}+p_{2})+4 p_{1}p_{2}\\right].\n$$\n对于逻辑斯蒂映射的周期-2 点（不包括不动点），其显式表达式为\n$$\np_{1,2}=\\frac{r+1\\pm\\sqrt{(r-3)(r+1)}}{2r}.\n$$\n由此，对称和为\n$$\nS=p_{1}+p_{2}=\\frac{r+1}{r},\\qquad P=p_{1}p_{2}=\\frac{r+1}{r^{2}}.\n$$\n因此，\n$$\nf'(p_{1})f'(p_{2})=r^{2}\\left[1-2\\frac{r+1}{r}+4\\frac{r+1}{r^{2}}\\right]\n=r^{2}\\left[\\frac{-r^{2}+2r+4}{r^{2}}\\right]=-r^{2}+2r+4.\n$$\n因此，该周期-2 轨道的有限时间李雅普诺夫指数为\n$$\n\\lambda=\\frac{1}{2}\\ln\\left|-r^{2}+2r+4\\right|.\n$$\n代入 $r=3.2$ 得\n$$\n-r^{2}+2r+4=-10.24+6.4+4=0.16,\n$$\n所以\n$$\n\\lambda=\\frac{1}{2}\\ln(0.16)=\\ln(0.4)\\approx -0.9162907319.\n$$\n四舍五入到四位有效数字，结果为 $-0.9163$。", "answer": "$$\\boxed{-0.9163}$$", "id": "2064908"}, {"introduction": "对于高维的复杂系统，仅仅追踪一对轨迹已不足以全面刻画其动力学特性，我们需要一个更强大的工具来计算完整的李雅普诺夫谱。这项高级实践将指导你编程实现一种通用算法——切线动力学结合QR分解方法，来计算系统的整个李雅普诺夫指数谱 [@problem_id:2410203]。通过将该方法应用于行为已知的系统（如谐振子），你不仅能构建一个强大的计算分析工具，还能验证其准确性，并深刻理解完整的指数谱如何揭示相空间中所有方向的动力学演化特征。", "problem": "你的任务是设计并实现一个完整的程序，该程序使用切动力学方法为有限维自治常微分方程估计李雅普诺夫谱，并将其应用于一个小型测试套件。目的是验证对于具有无理数频率比的非耦合谐振子的可积、准周期运动，在报告最大的两个指数时，其谱近似为 $\\left(0, 0\\right)$，并将其与一个耗散的阻尼振子进行对比。所有计算都将以无量纲单位进行，因此不需要进行物理单位转换。\n\n基本依据是自治系统 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x})$ 的李雅普诺夫指数定义，其中 $\\mathbf{x} \\in \\mathbb{R}^d$ 且 $\\mathbf{f}:\\mathbb{R}^d \\rightarrow \\mathbb{R}^d$ 是连续可微的。一个李雅普诺夫指数 $\\lambda$ 刻画了由变分方程 $\\dot{\\delta\\mathbf{x}} = \\mathbf{J}(\\mathbf{x})\\,\\delta\\mathbf{x}$ 控制的无穷小扰动的平均指数增长率，其中 $\\mathbf{J}(\\mathbf{x}) = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}}$ 是雅可比矩阵。为了估计最大的 $k$ 个指数，需要沿着基准轨道演化 $k$ 个线性无关的扰动向量，使用正交-三角 (QR) 分解定期对它们进行正交归一化，并将上三角因子中膨胀因子的对数累加起来。将累加和除以流逝时间，即可得到这些指数。\n\n你的程序必须从这些原理出发实现以下内容，且不依赖任何预先推导出的李雅普诺夫指数专用公式：\n\n1. 为基准系统 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x})$ 和相关的切动力学 $\\dot{\\mathbf{M}} = \\mathbf{J}(\\mathbf{x})\\,\\mathbf{M}$ 实现数值时间积分，其中 $\\mathbf{M} \\in \\mathbb{R}^{d \\times k}$ 汇集了 $k$ 个扰动列向量。使用固定步长的显式四阶 Runge–Kutta 方法。与基准积分器一致地，在每个 Runge–Kutta 中间阶段计算雅可比矩阵 $\\mathbf{J}(\\mathbf{x})$。\n\n2. 在每个步骤之后，对当前的 $\\mathbf{M}$ 执行一次 QR 分解，将上三角因子对角线元素绝对值的自然对数累加到运行总和中，并用正交归一因子替换 $\\mathbf{M}$，以防止数值溢出或崩塌。\n\n3. 在积分结束时，将每个累加和除以总流逝时间，以估计相应的李雅普诺夫指数。\n\n实现此算法并将其应用于以下测试套件。每个测试用例都指定了维度 $d$、向量场 $\\mathbf{f}$ 及其雅可比矩阵 $\\mathbf{J}$、初始条件 $\\mathbf{x}_0$、步长 $h$、总时间 $T$ 以及要估计的指数数量 $k$。所有角度和三角量（如有）均以弧度解释。将报告的每个指数四舍五入到 6 位小数。\n\n- 测试用例 A (正常路径，准周期保守运动)：两个具有无理数频率比的非耦合谐振子。状态 $\\mathbf{x} = (x_1, v_1, x_2, v_2) \\in \\mathbb{R}^4$。动力学方程：$\\dot{x}_1 = v_1$, $\\dot{v}_1 = -\\omega_1^2 x_1$, $\\dot{x}_2 = v_2$, $\\dot{v}_2 = -\\omega_2^2 x_2$。使用 $\\omega_1 = 1$, $\\omega_2 = \\sqrt{2}$；初始状态 $\\mathbf{x}_0 = (1, 0, 0.5, 0.3)$；步长 $h = 0.01$；总时间 $T = 500$；报告最大的 $k = 2$ 个指数。\n\n- 测试用例 B (边界条件，有理数频率比)：两个具有有理数频率比的非耦合谐振子。状态和动力学方程与测试 A 相同，但 $\\omega_1 = 1$, $\\omega_2 = 2$；初始状态 $\\mathbf{x}_0 = (1, 0, -0.25, 0.4)$；步长 $h = 0.01$；总时间 $T = 300$；报告最大的 $k = 2$ 个指数。\n\n- 测试用例 C (边缘情况，耗散焦点)：一个在 $\\mathbb{R}^2$ 中的阻尼谐振子，状态为 $\\mathbf{x} = (x, v)$。动力学方程：$\\dot{x} = v$, $\\dot{v} = -\\omega^2 x - 2 \\zeta \\omega v$。使用 $\\omega = 3$, $\\zeta = 0.2$；初始状态 $\\mathbf{x}_0 = (1, 0)$；步长 $h = 0.001$；总时间 $T = 50$；报告最大的 $k = 1$ 个指数。\n\n对于每个测试用例，你的程序必须生成所要求的李雅普诺夫指数估计值。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个用方括号括起来的、由四舍五入后的指数组成的逗号分隔列表。例如，对于三个测试用例，一个有效的输出形状形式为 $[[a,b],[c,d],[e]]$，其中 $a$、$b$、$c$、$d$ 和 $e$ 是四舍五入到 6 位小数的数字。最终输出必须是且仅是这种格式的一行。", "solution": "该问题陈述经评估后被认定为有效。它在计算物理学领域提出了一个定义明确且有科学依据的任务：使用切动力学方法为几个常微分方程系统估计李雅普诺夫谱。系统、参数和数值步骤都得到了完整而明确的指定。该问题是客观的，没有任何事实或逻辑上的不一致之处。\n\n该问题的理论基础是对由以下形式的自治常微分方程 (ODE) 描述的动力学系统中轨道稳定性的研究：\n$$\n\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x})\n$$\n其中 $\\mathbf{x} \\in \\mathbb{R}^d$ 是状态向量，$\\mathbf{f}$ 是一个连续可微的向量场。对轨道 $\\mathbf{x}(t)$ 的一个无穷小扰动 $\\delta\\mathbf{x}$ 的长期演化由以下变分方程控制：\n$$\n\\dot{\\delta\\mathbf{x}} = \\mathbf{J}(\\mathbf{x}(t)) \\delta\\mathbf{x}\n$$\n其中 $\\mathbf{J}(\\mathbf{x}) = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}}$ 是沿着轨道计算的雅可比矩阵。李雅普诺夫指数 $\\{\\lambda_i\\}$ 是此类扰动幅度的平均指数增长率。\n\n待实现的算法，通常称为 Benettin-Galgani-Giorgilli-Strelcyn 算法，是计算李雅普诺夫谱的一种标准数值方法。它涉及对基准系统和一组 $k$ 个切向量进行同步积分，这些切向量会周期性地重新正交归一化，以防止数值上崩塌到最大扩张方向上。\n\n流程如下：\n\n1.  **增广系统的构建**：我们构建一个增广常微分方程组，它既包含状态向量 $\\mathbf{x} \\in \\mathbb{R}^d$，也包含一个矩阵 $\\mathbf{M} \\in \\mathbb{R}^{d \\times k}$，该矩阵的列是我们希望跟踪的 $k$ 个切向量。初始矩阵 $\\mathbf{M}(0)$ 通常选择为一组正交归一的向量，例如前 $k$ 个标准基向量。要积分的完整系统是：\n    $$\n    \\begin{cases}\n    \\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x}) \\\\\n    \\dot{\\mathbf{M}} = \\mathbf{J}(\\mathbf{x})\\,\\mathbf{M}\n    \\end{cases}\n    $$\n\n2.  **数值积分**：该增广系统使用数值方法在一个小的时间步长 $h$ 上进行积分。问题指定了四阶 Runge-Kutta (RK4) 方法。设时间 $t_n$ 时的状态为 $(\\mathbf{x}_n, \\mathbf{M}_n)$。执行一个 RK4 步骤以找到时间 $t_{n+1} = t_n + h$ 时的状态。关键在于，在状态空间中与向量场 $\\mathbf{f}$ 相同的中间点上计算雅可比矩阵 $\\mathbf{J}$。对于耦合系统，RK4 的更新如下：\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_{1x} = h \\mathbf{f}(\\mathbf{x}_n) \\\\\n    \\mathbf{K}_{1M} = h \\mathbf{J}(\\mathbf{x}_n) \\mathbf{M}_n \\\\\n    \\mathbf{k}_{2x} = h \\mathbf{f}(\\mathbf{x}_n + \\frac{1}{2}\\mathbf{k}_{1x}) \\\\\n    \\mathbf{K}_{2M} = h \\mathbf{J}(\\mathbf{x}_n + \\frac{1}{2}\\mathbf{k}_{1x}) (\\mathbf{M}_n + \\frac{1}{2}\\mathbf{K}_{1M}) \\\\\n    \\mathbf{k}_{3x} = h \\mathbf{f}(\\mathbf{x}_n + \\frac{1}{2}\\mathbf{k}_{2x}) \\\\\n    \\mathbf{K}_{3M} = h \\mathbf{J}(\\mathbf{x}_n + \\frac{1}{2}\\mathbf{k}_{2x}) (\\mathbf{M}_n + \\frac{1}{2}\\mathbf{K}_{2M}) \\\\\n    \\mathbf{k}_{4x} = h \\mathbf{f}(\\mathbf{x}_n + \\mathbf{k}_{3x}) \\\\\n    \\mathbf{K}_{4M} = h \\mathbf{J}(\\mathbf{x}_n + \\mathbf{k}_{3x}) (\\mathbf{M}_n + \\mathbf{K}_{3M}) \\\\\n    \\end{aligned}\n    $$\n    然后更新状态：\n    $$\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{1}{6}(\\mathbf{k}_{1x} + 2\\mathbf{k}_{2x} + 2\\mathbf{k}_{3x} + \\mathbf{k}_{4x})\n    $$\n    并且，正交归一化之前的切矩阵为：\n    $$\n    \\mathbf{M}_{n+1}^{\\text{pre}} = \\mathbf{M}_n + \\frac{1}{6}(\\mathbf{K}_{1M} + 2\\mathbf{K}_{2M} + 2\\mathbf{K}_{3M} + \\mathbf{K}_{4M})\n    $$\n    对于给定的测试用例，雅可比矩阵是常数，这简化了上述方案，因为 $\\mathbf{J}(\\mathbf{x})$ 不会改变。然而，一个通用的实现必须遵循完整的流程。\n\n3.  **正交归一化与累加**：在每个积分步骤之后，演化后的矩阵 $\\mathbf{M}_{n+1}^{\\text{pre}}$ 使用 QR 分解进行重新正交归一化：\n    $$\n    \\mathbf{M}_{n+1}^{\\text{pre}} = \\mathbf{Q}_{n+1} \\mathbf{R}_{n+1}\n    $$\n    其中 $\\mathbf{Q}_{n+1}$ 是一个正交归一矩阵，$\\mathbf{R}_{n+1}$ 是一个上三角矩阵。下一步的切向量矩阵被设置为 $\\mathbf{M}_{n+1} = \\mathbf{Q}_{n+1}$。$\\mathbf{R}_{n+1}$ 的对角元素，记为 $R_{n+1, ii}$，衡量了由切向量张成的子空间的局部膨胀率。它们绝对值的自然对数被累加到运行总和 $\\mathbf{s}$ 中，每个指数对应一个总和：\n    $$\n    s_i \\leftarrow s_i + \\ln(|R_{n+1, ii}|) \\quad \\text{for } i = 1, \\dots, k\n    $$\n\n4.  **李雅普诺夫指数估计**：在积分了总时间 $T = N \\cdot h$ 后，李雅普诺夫指数通过将累加和除以总时间来估计：\n    $$\n    \\lambda_i \\approx \\frac{s_i}{T} = \\frac{1}{T} \\sum_{n=1}^{N} \\ln(|R_{n,ii}|)\n    $$\n    这个过程自然地按降序得出指数，即 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_k$。\n\n提供的测试用例可作为极好的验证点。\n对于测试用例 A (准周期) 和 B (周期)，系统描述的是非耦合谐振子。这些是保守的哈密顿系统，其相空间体积是守恒的。雅可比矩阵的迹为零。理论预测，对于这类可积系统，所有的李雅普诺夫指数都为零。数值结果应该是一个非常接近 0 的值向量。\n对于测试用例 C (阻尼振子)，系统是线性和耗散的。李雅普诺夫指数是（常数）雅可比矩阵特征值的实部。特征方程是 $\\det(\\mathbf{J} - \\lambda\\mathbf{I}) = 0$，得到 $\\lambda^2 + 2\\zeta\\omega\\lambda + \\omega^2 = 0$。对于 $\\zeta  1$，根是 $\\lambda = -\\zeta\\omega \\pm \\sqrt{(\\zeta\\omega)^2 - \\omega^2} = -\\zeta\\omega \\pm i\\omega\\sqrt{1-\\zeta^2}$。当 $\\omega=3$ 且 $\\zeta=0.2$ 时，其实部为 $-\\zeta\\omega = -0.2 \\times 3 = -0.6$。由于系统是二维的，所以有两个指数，它们都等于 -0.6。因此，最大的指数是 -0.6。算法应该收敛到这个值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef estimate_lyapunov_spectrum(f, jacobian_func, x0, h, T, k):\n    \"\"\"\n    Estimates the first k Lyapunov exponents of a dynamical system.\n\n    Args:\n        f (callable): The vector field of the system, f(x).\n        jacobian_func (callable): The Jacobian of the system, J(x).\n        x0 (list or np.ndarray): The initial condition for the state vector.\n        h (float): The time step for the integration.\n        T (float): The total integration time.\n        k (int): The number of Lyapunov exponents to estimate.\n    \"\"\"\n    d = len(x0)\n    x = np.array(x0, dtype=np.float64)\n    # Initialize k orthonormal tangent vectors (d x k matrix)\n    M = np.eye(d, k, dtype=np.float64)\n\n    # Accumulator for the logarithms of the diagonal elements of R\n    log_r_diag_sum = np.zeros(k, dtype=np.float64)\n\n    num_steps = int(T / h)\n\n    for _ in range(num_steps):\n        # Store state and tangent matrix for RK4\n        x_n = x\n        M_n = M\n\n        # --- RK4 Step for the augmented system (x, M) ---\n        \n        # k1\n        x_k1 = f(x_n)\n        J_k1 = jacobian_func(x_n)\n        M_k1 = J_k1 @ M_n\n\n        # k2\n        x_at_k2 = x_n + 0.5 * h * x_k1\n        J_k2 = jacobian_func(x_at_k2)\n        x_k2 = f(x_at_k2)\n        M_k2 = J_k2 @ (M_n + 0.5 * h * M_k1)\n\n        # k3\n        x_at_k3 = x_n + 0.5 * h * x_k2\n        J_k3 = jacobian_func(x_at_k3)\n        x_k3 = f(x_at_k3)\n        M_k3 = J_k3 @ (M_n + 0.5 * h * M_k2)\n\n        # k4\n        x_at_k4 = x_n + h * x_k3\n        J_k4 = jacobian_func(x_at_k4)\n        x_k4 = f(x_at_k4)\n        M_k4 = J_k4 @ (M_n + h * M_k3)\n\n        # Update state vector x\n        x = x_n + (h / 6.0) * (x_k1 + 2.0 * x_k2 + 2.0 * x_k3 + x_k4)\n\n        # Update tangent matrix M before orthonormalization\n        M_pre_qr = M_n + (h / 6.0) * (M_k1 + 2.0 * M_k2 + 2.0 * M_k3 + M_k4)\n        \n        # --- QR Decomposition and Accumulation ---\n        \n        # Orthonormalize the evolved tangent vectors\n        Q, R = qr(M_pre_qr, mode='economic')\n\n        # Accumulate the sum of logarithms of the diagonal elements of R\n        log_r_diag_sum += np.log(np.abs(np.diag(R)))\n\n        # Update the tangent matrix with the new orthonormal basis\n        M = Q\n\n    # Calculate the Lyapunov exponents\n    lyapunov_exponents = log_r_diag_sum / T\n\n    return lyapunov_exponents\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A: Uncoupled harmonic oscillators, irrational frequency ratio\n        {\n            \"f\": lambda x: np.array([x[1], -1.0**2 * x[0], x[3], -(np.sqrt(2))**2 * x[2]]),\n            \"J\": lambda x: np.array([[0, 1, 0, 0], [-1.0**2, 0, 0, 0], [0, 0, 0, 1], [0, 0, -(np.sqrt(2))**2, 0]]),\n            \"x0\": [1.0, 0.0, 0.5, 0.3],\n            \"h\": 0.01,\n            \"T\": 500.0,\n            \"k\": 2,\n        },\n        # Test Case B: Uncoupled harmonic oscillators, rational frequency ratio\n        {\n            \"f\": lambda x: np.array([x[1], -1.0**2 * x[0], x[3], -2.0**2 * x[2]]),\n            \"J\": lambda x: np.array([[0, 1, 0, 0], [-1.0**2, 0, 0, 0], [0, 0, 0, 1], [0, 0, -2.0**2, 0]]),\n            \"x0\": [1.0, 0.0, -0.25, 0.4],\n            \"h\": 0.01,\n            \"T\": 300.0,\n            \"k\": 2,\n        },\n        # Test Case C: Damped harmonic oscillator\n        {\n            \"f\": lambda x: np.array([x[1], -3.0**2 * x[0] - 2.0 * 0.2 * 3.0 * x[1]]),\n            \"J\": lambda x: np.array([[0, 1], [-3.0**2, -2.0 * 0.2 * 3.0]]),\n            \"x0\": [1.0, 0.0],\n            \"h\": 0.001,\n            \"T\": 50.0,\n            \"k\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        exponents = estimate_lyapunov_spectrum(\n            f=case[\"f\"],\n            jacobian_func=case[\"J\"],\n            x0=case[\"x0\"],\n            h=case[\"h\"],\n            T=case[\"T\"],\n            k=case[\"k\"],\n        )\n        # Round the results to 6 decimal places as required\n        rounded_exponents = [round(le, 6) for le in exponents]\n        results.append(rounded_exponents)\n\n    # Final print statement in the exact required format.\n    # Format each sublist of results into a string like \"[num1,num2]\"\n    formatted_parts = [f\"[{','.join(map(str, res))}]\" for res in results]\n    # Join the parts into the final string like \"[[...],[...],[...]]\"\n    print(f\"[[{','.join(formatted_parts)}]]\")\n\nsolve()\n```", "id": "2410203"}]}