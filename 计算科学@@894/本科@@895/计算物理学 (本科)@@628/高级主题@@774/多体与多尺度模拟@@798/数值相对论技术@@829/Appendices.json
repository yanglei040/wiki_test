{"hands_on_practices": [{"introduction": "在模拟致密天体（如中子星并合）时，准确描述物质的行为至关重要。这个练习将带你实现一个相对论流体动力学的一维黎曼求解器（Riemann solver），这是现代有限体积数值方法的核心组件。通过这个实践，你将掌握处理双曲守恒律（hyperbolic conservation laws）的基本技巧，为模拟爱因斯坦方程中的物质源项打下坚实基础。[@problem_id:2420558]", "problem": "构造一个完整、可运行的程序，该程序为一组给定的左、右原始状态，计算平直时空中一维狭义相对论流体动力学的单元交界面数值通量。使用自然单位制，其中光速 $c = 1$，因此所有物理量均为无量纲。该程序必须实现理想流体在伽马律状态方程下的重子数和能量-动量守恒，并返回在初始时刻位于 $x = 0$ 处、存在左状态和右状态之间间断的交界面上的守恒数值通量。程序必须独立处理每个测试用例，并为每个用例输出一个包含三个浮点数的列表，该列表按 $[F_D, F_S, F_\\tau]$ 的顺序表示通量分量。最终输出必须以单行形式呈现，该行包含一个由各测试用例结果列表组成的列表。\n\n系统定义如下。设原始变量为静质量密度 $\\rho$、压强 $p$ 和沿 $x$ 方向的流体速度 $v$。洛伦兹因子为 $W = 1/\\sqrt{1 - v^2}$。比内能为 $\\epsilon$，理想伽马律状态方程通过 $p = (\\Gamma - 1)\\,\\rho\\,\\epsilon$ 关联压强和内能，其中 $\\Gamma$ 是绝热指数。比焓为 $h = 1 + \\epsilon + p/\\rho$，利用状态方程，它也可以写成 $h = 1 + \\Gamma\\,p/((\\Gamma - 1)\\,\\rho)$。\n\n定义守恒变量如下\n- $D = \\rho\\,W$，\n- $S = \\rho\\,h\\,W^2\\,v$，\n- $\\tau = \\rho\\,h\\,W^2 - p - D$。\n\n沿 $x$ 方向对应的物理通量为\n- $F_D = D\\,v$，\n- $F_S = S\\,v + p$，\n- $F_\\tau = S - D\\,v$。\n\n设相对论声速为 $c_s$，由 $c_s^2 = \\Gamma\\,p / (\\rho\\,h)$ 定义，并假设 $0 \\le c_s < 1$。对于一维流动，实验室参考系中的特征速度为\n- $\\lambda_+ = (v + c_s)/(1 + v\\,c_s)$,\n- $\\lambda_- = (v - c_s)/(1 - v\\,c_s)$,\n- $\\lambda_0 = v$。\n\n对于左、右状态之间交界面上的单元交界面数值通量的双信号近似，定义左、右边界信号速度为\n- $S_L = \\min\\{\\lambda_-^{(L)}, \\lambda_-^{(R)}\\}$，\n- $S_R = \\max\\{\\lambda_+^{(L)}, \\lambda_+^{(R)}\\}$，\n其中，上标 $(L)$ 和 $(R)$ 分别表示根据左、右原始状态计算出的量。那么，如果所有信号都朝一个方向移动，单元交界面数值通量 $\\mathbf{F}^\\ast$ 即为迎风通量，否则由双信号公式给出：\n- 如果 $S_L \\ge 0$，则 $\\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_L)$。\n- 否则，如果 $S_R \\le 0$，则 $\\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_R)$。\n- 否则，\n$$\n\\mathbf{F}^\\ast = \\frac{S_R\\,\\mathbf{F}(\\mathbf{U}_L) - S_L\\,\\mathbf{F}(\\mathbf{U}_R) + S_L\\,S_R\\,(\\mathbf{U}_R - \\mathbf{U}_L)}{S_R - S_L}.\n$$\n此处 $\\mathbf{U} = [D, S, \\tau]$ 且 $\\mathbf{F}(\\mathbf{U}) = [F_D, F_S, F_\\tau]$。\n\n您的程序必须为以下每个测试用例计算 $\\mathbf{F}^\\ast$。所有量均为无量纲，与 $c=1$ 一致。计算中不涉及角度，因此不需要角度单位。要求的输出是浮点数。最终输出格式必须是单行，包含一个子列表的列表，每个子列表对应一个测试用例，并且等于根据上述定义计算出的 $[F_D, F_S, F_\\tau]$。\n\n测试套件（每个用例指定 $(\\Gamma; \\rho_L, p_L, v_L; \\rho_R, p_R, v_R)$）：\n- 用例 1：$(\\Gamma = 5/3;\\ \\rho_L = 1.0,\\ p_L = 1.0,\\ v_L = 0.0;\\ \\rho_R = 0.125,\\ p_R = 0.1,\\ v_R = 0.0)$。\n- 用例 2：$(\\Gamma = 5/3;\\ \\rho_L = 1.0,\\ p_L = 1000.0,\\ v_L = 0.0;\\ \\rho_R = 1.0,\\ p_R = 0.01,\\ v_R = 0.0)$。\n- 用例 3：$(\\Gamma = 5/3;\\ \\rho_L = 1.0,\\ p_L = 1.0,\\ v_L = 0.5;\\ \\rho_R = 1.0,\\ p_R = 1.0,\\ v_R = -0.5)$。\n- 用例 4：$(\\Gamma = 4/3;\\ \\rho_L = 1.0,\\ p_L = 1.0,\\ v_L = 0.2;\\ \\rho_R = 1.0,\\ p_R = 1.0,\\ v_R = 0.2)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。列表中的每个条目都是一个包含三个浮点数 $[F_D, F_S, F_\\tau]$ 的子列表，并按测试套件用例的顺序排列，例如：$[[f_{D,1}, f_{S,1}, f_{\\tau,1}],[f_{D,2}, f_{S,2}, f_{\\tau,2}],\\dots]$。", "solution": "问题陈述已经过分析，并被认为是有效的。它提出了一个计算物理学领域中的适定且有科学依据的问题，特别是在狭义相对论流体动力学领域。所提供的方程、定义和测试用例是自洽、一致的，并且源于已建立的理论。任务是为一个指定的物理系统实现一个标准的数值算法，即双信号（或HLL）近似黎曼求解器。\n\n解决方案是通过为每个测试用例实现以下计算序列来构建的。每个测试用例包含一个交界面上的左状态 $(\\rho_L, p_L, v_L)$ 和右状态 $(\\rho_R, p_R, v_R)$，以及一个给定的绝热指数 $\\Gamma$。\n\n首先，对于任何给定的具有原始变量 $(\\rho, p, v)$ 的状态，我们必须计算一组派生量。\n洛伦兹因子 $W$ 由下式给出\n$$W = \\frac{1}{\\sqrt{1 - v^2}}$$\n对于伽马律气体，比焓 $h$ 为\n$$h = 1 + \\epsilon + \\frac{p}{\\rho} = 1 + \\frac{p}{(\\Gamma - 1)\\rho} + \\frac{p}{\\rho} = 1 + \\frac{\\Gamma p}{(\\Gamma - 1)\\rho}$$\n相对论声速 $c_s$ 由其平方确定\n$$c_s^2 = \\frac{\\Gamma p}{\\rho h}$$\n一维流动的特征波速 $\\lambda_{\\pm}$ 由相对论速度加法给出：\n$$\\lambda_+ = \\frac{v + c_s}{1 + v c_s}, \\quad \\lambda_- = \\frac{v - c_s}{1 - v c_s}$$\n\n其次，利用这些量，我们计算守恒变量向量 $\\mathbf{U}$和相应的通量向量 $\\mathbf{F}$。\n守恒变量定义为：\n- $D = \\rho W$ （守恒静质量密度）\n- $S = \\rho h W^2 v$ （$x$ 方向的动量密度）\n- $\\tau = \\rho h W^2 - p - D$ （总能量密度减去静质量密度）\n因此，状态向量为 $\\mathbf{U} = [D, S, \\tau]^T$。\n\n$x$ 方向的物理通量向量为：\n- $F_D = D v$\n- $F_S = S v + p$\n- $F_\\tau = S - D v$\n因此，通量向量为 $\\mathbf{F}(\\mathbf{U}) = [F_D, F_S, F_\\tau]^T$。\n\n此过程应用于左状态（用上标 $(L)$ 表示）和右状态（用上标 $(R)$ 表示），以获得状态向量 $\\mathbf{U}_L, \\mathbf{U}_R$ 和通量向量 $\\mathbf{F}_L, \\mathbf{F}_R$。我们还为每个状态计算特征速度 $\\lambda_{\\pm}^{(L)}$ 和 $\\lambda_{\\pm}^{(R)}$。\n\n第三，计算跨越交界面的HLL型数值通量 $\\mathbf{F}^\\ast$。这需要估算限定黎曼扇的最小和最大信号速度 $S_L$ 和 $S_R$。它们的定义如下：\n$$S_L = \\min\\left\\{\\lambda_-^{(L)}, \\lambda_-^{(R)}\\right\\}$$\n$$S_R = \\max\\left\\{\\lambda_+^{(L)}, \\lambda_+^{(R)}\\right\\}$$\n\n数值通量 $\\mathbf{F}^\\ast$ 则由以下三种情况之一给出：\n1. 如果所有信号都向右传播 ($S_L \\ge 0$)，通量由左状态决定（迎风格式）：\n$$ \\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_L) $$\n2. 如果所有信号都向左传播 ($S_R \\le 0$)，通量由右状态决定：\n$$ \\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_R) $$\n3. 如果信号向两个方向传播 ($S_L < 0 < S_R$)，通量是状态和通量的加权平均：\n$$ \\mathbf{F}^\\ast = \\frac{S_R \\mathbf{F}(\\mathbf{U}_L) - S_L \\mathbf{F}(\\mathbf{U}_R) + S_L S_R (\\mathbf{U}_R - \\mathbf{U}_L)}{S_R - S_L} $$\n\n程序必须对问题陈述中提供的每个测试用例执行此完整算法，并按规定格式化输出。在适用的情况下，实现将使用向量运算以提高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the intercell numerical flux for 1D special relativistic hydrodynamics.\n    \"\"\"\n    # Test cases: (gamma; rho_L, p_L, v_L; rho_R, p_R, v_R)\n    test_cases = [\n        (5.0/3.0, 1.0, 1.0, 0.0, 0.125, 0.1, 0.0),\n        (5.0/3.0, 1.0, 1000.0, 0.0, 1.0, 0.01, 0.0),\n        (5.0/3.0, 1.0, 1.0, 0.5, 1.0, 1.0, -0.5),\n        (4.0/3.0, 1.0, 1.0, 0.2, 1.0, 1.0, 0.2),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        gamma, rho_l, p_l, v_l, rho_r, p_r, v_r = case\n        \n        # This function encapsulates the conversion from primitive to conservative variables\n        # and calculation of characteristic speeds.\n        def get_state_quantities(rho, p, v, g):\n            if v*v >= 1.0:\n                raise ValueError(\"Velocity must be less than the speed of light (1).\")\n\n            # Lorentz factor\n            W_sq = 1.0 / (1.0 - v*v)\n            W = np.sqrt(W_sq)\n            \n            # Specific enthalpy\n            h = 1.0 + g * p / ((g - 1.0) * rho)\n            \n            # Conservative variables U = [D, S, tau]\n            D = rho * W\n            S = rho * h * W_sq * v\n            tau = rho * h * W_sq - p - D\n            U = np.array([D, S, tau])\n            \n            # Physical fluxes F = [F_D, F_S, F_tau]\n            F_D = D * v\n            F_S = S * v + p\n            F_tau = S - D * v\n            F = np.array([F_D, F_S, F_tau])\n            \n            # Sound speed squared and characteristic speeds\n            cs_sq = g * p / (rho * h)\n            if cs_sq >= 1.0:\n                # This check ensures physical sound speed.\n                # It should not be triggered by the problem's EOS definition for p, rho > 0.\n                raise ValueError(\"Sound speed squared must be less than 1.\")\n            cs = np.sqrt(cs_sq)\n            \n            lambda_p = (v + cs) / (1.0 + v * cs)\n            lambda_m = (v - cs) / (1.0 - v * cs)\n            \n            return U, F, lambda_p, lambda_m\n\n        # Calculate quantities for left and right states\n        U_l, F_l, lambda_p_l, lambda_m_l = get_state_quantities(rho_l, p_l, v_l, gamma)\n        U_r, F_r, lambda_p_r, lambda_m_r = get_state_quantities(rho_r, p_r, v_r, gamma)\n        \n        # Determine bounding signal speeds\n        S_L = min(lambda_m_l, lambda_m_r)\n        S_R = max(lambda_p_l, lambda_p_r)\n        \n        # Calculate numerical flux F_star\n        if S_L >= 0.0:\n            F_star = F_l\n        elif S_R <= 0.0:\n            F_star = F_r\n        else:\n            # Check for S_R - S_L being zero to avoid division by zero\n            # This would only happen if S_R=S_L=0, a very specific case\n            # not expected in these problems, as it would imply cs=0 and v=0 for both states.\n            denom = S_R - S_L\n            if abs(denom) < 1e-15: # Safety check for division by zero\n                 # If S_R = S_L, the upwind/downwind conditions should have caught it.\n                 # If S_R = S_L and S_L < 0 < S_R is false.\n                 # This branch should not be taken in a consistent setup.\n                 # A possible edge case is S_R = S_L = 0.\n                 # In SRHD, for waves to have zero speed, v=cs=0.\n                 # This would imply F_L=F_R=[0, p, 0].\n                 # We can simply take the average or one of them. For instance F_L.\n                 F_star = F_l\n            else:\n                 F_star = (S_R * F_l - S_L * F_r + S_L * S_R * (U_r - U_l)) / denom\n\n        results.append(F_star.tolist())\n\n    # Format the final output string as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2420558"}, {"introduction": "掌握了物质的演化，我们现在将注意力转向引力本身。这个练习要求你构建一个完整的“粒子-网格”（Particle-Mesh）模拟程序，在一个简化的 $2+1$ 维时空中模拟两个质点间的引力相互作用。你将学习如何使用快速傅里叶变换（FFT）高效求解引力场方程，并通过一个完整的“场求解-粒子推进”循环，亲身体验“物质告诉时空如何弯曲，时空告诉物质如何运动”这一广义相对论的核心思想。[@problem_id:2420566]", "problem": "要求您实现一个完全可运行的程序，该程序在一个周期性方形域中对一个简化的弱场$2+1$维引力玩具模型进行数值演化，捕捉由均匀网格上的平滑高斯源表示的两个局域化“点质量”之间的有效相互作用。目标是使用受数值相对论启发的技朧来模拟正碰和掠碰，并根据计算出的轨迹，判断两个质量体是否在指定的邻近阈值下发生碰撞。所有计算必须在无量纲的几何化单位中进行，其中引力耦合和光速被归一化，最终输出中无需进行物理单位转换。\n\n起点和建模假设：\n- 在弱场、慢速极限下使用爱因斯坦场方程，对空间度规采用共形平坦拟设，并假设引力势很小。在此极限下，并且在引力辐射可忽略的$2+1$维空间中，场方程简化为标量势$\\Phi$与表面质量密度$\\rho$耦合的泊松型约束。这产生形如\n$$\n\\nabla^2 \\Phi = \\kappa \\,\\rho,\n$$\n的椭圆型约束，其中$\\kappa$是一个无量纲耦合常数，您应将其视为固定的正值。假设一个边长为$L$的周期性方形域，并采用与周期性边界条件一致的谱方法在每个时间步求解此椭圆型约束。\n- 将每个“点质量”表示为宽度为$\\sigma$，中心位于其瞬时位置$\\boldsymbol{x}_p(t)$的归一化高斯函数，使其积分质量等于预设的$m_p$。用\n$$\n\\frac{d \\boldsymbol{v}}{dt} = -\\nabla \\Phi,\\qquad \\frac{d \\boldsymbol{x}}{dt} = \\boldsymbol{v},\n$$\n来近似慢速运动的测地线方程，这在该体系下与线性化引力一致。使用二阶精度辛（蛙跳）积分器来演化粒子的位置和速度。\n\n数值方法要求：\n- 将方形域离散化为一个均匀的$N\\times N$网格，网格间距为$\\Delta x = L/N$。\n- 在每个步骤中，将$\\rho(\\boldsymbol{x})$构建为两个高斯函数的和，其总质量分别为$m_1$和$m_2$，每个高斯函数的宽度均为$\\sigma$：\n$$\n\\rho(\\boldsymbol{x}) = \\sum_{p=1}^{2} \\frac{m_p}{2\\pi \\sigma^2}\\exp\\!\\left(-\\frac{\\|\\boldsymbol{x}-\\boldsymbol{x}_p\\|_{\\text{per}}^2}{2\\sigma^2}\\right),\n$$\n其中$\\|\\cdot\\|_{\\text{per}}$表示周期性边界下的最小镜像范数。\n- 使用快速傅里叶变换（FFT）在傅里叶空间中求解椭圆型约束：对于波矢$\\boldsymbol{k}=(k_x,k_y)$，\n$$\n-|\\boldsymbol{k}|^2 \\,\\widehat{\\Phi}(\\boldsymbol{k}) = \\kappa\\, \\widehat{\\rho}(\\boldsymbol{k})\\quad\\Rightarrow\\quad \\widehat{\\Phi}(\\boldsymbol{k}) = -\\kappa \\frac{\\widehat{\\rho}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2},\n$$\n其中设置零模以满足$\\widehat{\\Phi}(\\boldsymbol{0})=0$（势的定义仅相差一个常数）。使用以下方式获得加速度场：\n$$\n\\boldsymbol{a}(\\boldsymbol{x}) = -\\nabla \\Phi(\\boldsymbol{x}),\\quad \\text{通过谱方法实现为}\\quad \\widehat{\\partial_i \\Phi} = i\\,k_i\\,\\widehat{\\Phi}。\n$$\n- 使用与周期性环绕一致的双线性插值，将加速度$\\boldsymbol{a}$从网格插值到粒子位置。\n\n时间积分：\n- 使用蛙跳格式（踢-漂移-踢）：\n  1. 根据当前粒子位置，通过上述场求解方法计算$\\boldsymbol{a}^n = \\boldsymbol{a}(\\boldsymbol{x}^n)$。\n  2. 半步踢：$\\boldsymbol{v}^{n+\\tfrac{1}{2}} = \\boldsymbol{v}^n + \\tfrac{\\Delta t}{2}\\,\\boldsymbol{a}^n$。\n  3. 漂移：$\\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t\\,\\boldsymbol{v}^{n+\\tfrac{1}{2}}$（应用周期性环绕以保持在域内）。\n  4. 在$\\boldsymbol{x}^{n+1}$处重新计算场以获得$\\boldsymbol{a}^{n+1}$，并完成踢步：$\\boldsymbol{v}^{n+1} = \\boldsymbol{v}^{n+\\tfrac{1}{2}} + \\tfrac{\\Delta t}{2}\\,\\boldsymbol{a}^{n+1}$。\n- 在整个演化过程中，使用周期性域的最小镜像约定来跟踪瞬时粒子间距：\n$$\nd(t) = \\left\\|\\left[\\boldsymbol{x}_1(t)-\\boldsymbol{x}_2(t)\\right]_{\\text{per}}\\right\\|_2.\n$$\n将在模拟区间内，如果$\\min_t d(t) < 2\\sigma$，则定义为发生“碰撞”。\n\n测试套件规范：\n使用以下三个测试用例，全部采用无量纲几何化单位，具有相同的全局数值参数$N$、 $L$、 $\\sigma$和$\\kappa$，但粒子质量和初始条件不同。对于每种情况，演化固定的步数，并判断是否发生碰撞，返回一个布尔值。\n\n所有情况的全局数值参数：\n- 网格大小: $N = 64$。\n- 域大小: $L = 1.0$。\n- 高斯宽度: $\\sigma = 0.02$。\n- 耦合常数: $\\kappa = 0.1$。\n- 时间步长: $\\Delta t = 0.002$。\n- 步数: $n_{\\text{steps}} = 300$。\n\n情况 A（正碰，等质量）：\n- 质量: $m_1 = 0.5$, $m_2 = 0.5$。\n- 初始位置: $\\boldsymbol{x}_1(0) = (0.3,\\,0.5)$, $\\boldsymbol{x}_2(0) = (0.7,\\,0.5)$。\n- 初始速度: $\\boldsymbol{v}_1(0) = (0.08,\\,0.0)$, $\\boldsymbol{v}_2(0) = (-0.08,\\,0.0)$。\n\n情况 B（掠碰，等质量，较大碰撞参数）：\n- 质量: $m_1 = 0.5$, $m_2 = 0.5$。\n- 初始位置: $\\boldsymbol{x}_1(0) = (0.3,\\,0.4)$, $\\boldsymbol{x}_2(0) = (0.7,\\,0.6)$。\n- 初始速度: $\\boldsymbol{v}_1(0) = (0.08,\\,0.0)$, $\\boldsymbol{v}_2(0) = (-0.08,\\,0.0)$。\n\n情况 C（正碰，极小质量）：\n- 质量: $m_1 = 0.02$, $m_2 = 0.02$。\n- 初始位置: $\\boldsymbol{x}_1(0) = (0.3,\\,0.5)$, $\\boldsymbol{x}_2(0) = (0.7,\\,0.5)$。\n- 初始速度: $\\boldsymbol{v}_1(0) = (0.08,\\,0.0)$, $\\boldsymbol{v}_2(0) = (-0.08,\\,0.0)$。\n\n答案规范和输出格式：\n- 对于每个测试用例，计算由最小间距是否满足$\\min_t d(t) < 2\\sigma$所定义的布尔碰撞指示器。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，按A、B、C的顺序列出三种情况的结果（例如，“[True,False,False]”）。由于这些是布尔值，它们是无单位的，必须打印为纯布尔值。", "solution": "问题陈述是有效的。它提出了一个定义明确的计算物理任务，该任务基于经典场论和数值分析的既定原理。该模型虽然经过简化，却是引力动力学研究中的一个标准玩具问题，通常被称为粒子-网格（PM）模拟。所有参数、初始条件、方程和数值方法都以足够的清晰度和精确度给出，可以得出一个唯一的、可验证的解。我们将继续构建该算法。\n\n问题的核心是在自生引力场下模拟N体问题，这里是$N=2$个粒子。力的计算不是通过直接对求和，而是通过场介导的方法。模拟循环通过大小为$\\Delta t$的离散时间步，推进系统状态——粒子$p=1, 2$的位置$\\boldsymbol{x}_p(t)$和速度$\\boldsymbol{v}_p(t)$。每个时间步包括两个主要阶段：首先，根据粒子当前位置计算其受力；其次，使用这些力来更新其位置和速度。\n\n首先，我们处理加速度场$\\boldsymbol{a} = -\\nabla \\Phi$的计算。这需要在边长为$L$的周期性方形域上求解二维泊松方程，\n$$\n\\nabla^2 \\Phi(\\boldsymbol{x}) = \\kappa \\,\\rho(\\boldsymbol{x}),\n$$\n源项$\\rho(\\boldsymbol{x})$是由两个粒子产生的表面质量密度。问题指定了采用具有$N \\times N$个点的均匀网格的基于网格的方法。\n\n密度场是通过将每个粒子的质量分布到网格上来构建的。每个粒子都是平滑的高斯分布，而不是真正的点质量，以避免奇异性。任意点$\\boldsymbol{x}$处的密度由下式给出\n$$\n\\rho(\\boldsymbol{x}) = \\sum_{p=1}^{2} \\frac{m_p}{2\\pi \\sigma^2}\\exp\\!\\left(-\\frac{\\|\\boldsymbol{x}-\\boldsymbol{x}_p\\|_{\\text{per}}^2}{2\\sigma^2}\\right).\n$$\n这里，$\\|\\boldsymbol{x}-\\boldsymbol{x}_p\\|_{\\text{per}}$是最小镜像约定下的距离，它正确地处理了域的周期性。为了实现这一点，对于每个网格点$\\boldsymbol{x}_{ij}$，我们计算其到每个粒子$\\boldsymbol{x}_p$的最短距离，并对高斯贡献求和。对于一个分离向量$\\Delta\\boldsymbol{x} = \\boldsymbol{x}_{ij}-\\boldsymbol{x}_p$，其周期性对应量是通过将其每个分量$\\Delta x_k$映射到区间$[-L/2, L/2]$来找到的。\n\n在网格上离散化密度场$\\rho_{ij}$后，我们求解势$\\Phi$。周期性边界条件的使用使得基于快速傅里叶变换（FFT）的谱方法异常高效。我们将泊松方程变换到傅里叶空间。拉普拉斯算子$\\nabla^2$的傅里叶变换是$\\mathcal{F}\\{\\nabla^2 f\\} = -|\\boldsymbol{k}|^2 \\widehat{f}(\\boldsymbol{k})$，其中$\\boldsymbol{k}=(k_x, k_y)$是波矢。对于大小为$N$、域长为$L$的网格，离散波矢由$k_i = 2\\pi n_i/L$给出，其中$n_i$是从$-N/2$到$N/2-1$的整数。场方程在傅里叶空间中对每个模式$\\boldsymbol{k}$都变成一个代数方程：\n$$\n-|\\boldsymbol{k}|^2 \\,\\widehat{\\Phi}(\\boldsymbol{k}) = \\kappa\\, \\widehat{\\rho}(\\boldsymbol{k}).\n$$\n由此解出势的傅里叶系数：\n$$\n\\widehat{\\Phi}(\\boldsymbol{k}) = -\\kappa \\frac{\\widehat{\\rho}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2}.\n$$\n对于零频模式$\\boldsymbol{k}=\\boldsymbol{0}$，分母$|\\boldsymbol{k}|^2$为零。这个奇异点反映了势的定义只相差一个任意常数的事实。问题指定了物理选择$\\widehat{\\Phi}(\\boldsymbol{0}) = 0$，这将势的空间平均值设为零。对于所有其他模式，该除法是良定义的。\n\n一旦$\\widehat{\\Phi}(\\boldsymbol{k})$已知，我们就可以找到加速度场$\\boldsymbol{a} = -\\nabla\\Phi$。在傅里叶空间中，梯度算子$\\nabla$对应于乘以$i\\boldsymbol{k}$。因此，加速度向量的傅里叶变换是\n$$\n\\widehat{\\boldsymbol{a}}(\\boldsymbol{k}) = -i\\boldsymbol{k}\\,\\widehat{\\Phi}(\\boldsymbol{k}).\n$$\n对分量$\\widehat{a}_x(\\boldsymbol{k})$和$\\widehat{a}_y(\\boldsymbol{k})$应用二维逆FFT，可以得到离散网格上的加速度场分量$a_x(\\boldsymbol{x})$和$a_y(\\boldsymbol{x})$。\n\n然而，粒子并不位于网格点上。为了找到粒子连续位置$\\boldsymbol{x}_p$处的加速度，我们必须从网格上的加速度场进行插值。按照规定，使用双线性插值。该方法使用包围$\\boldsymbol{x}_p$的单元格的四个最近网格点上的值的加权平均来近似$\\boldsymbol{x}_p$处的值。这种插值也必须遵守周期性边界条件，这可以通过使用像`scipy.ndimage.map_coordinates`这样的库函数并设为周期性环绕模式来稳健地处理。\n\n有了一个在任意时间步$n$计算加速度$\\boldsymbol{a}(\\boldsymbol{x}^n)$的方法，我们就可以使用指定的二阶蛙跳积分器（踢-漂移-踢变体）来演化粒子动力学。这种辛格式非常适合哈密顿系统，因为它表现出良好的长期守恒性质。更新过程如下：\n1.  计算初始加速度：$\\boldsymbol{a}^n = \\boldsymbol{a}(\\boldsymbol{x}^n)$。\n2.  速度的半步踢：$\\boldsymbol{v}^{n+\\frac{1}{2}} = \\boldsymbol{v}^n + \\frac{\\Delta t}{2}\\,\\boldsymbol{a}^n$。\n3.  位置的完整漂移：$\\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t\\,\\boldsymbol{v}^{n+\\frac{1}{2}}$。然后使用模运算符将位置环绕回域$[0, L) \\times [0, L)$内。\n4.  在新位置重新计算加速度：$\\boldsymbol{a}^{n+1} = \\boldsymbol{a}(\\boldsymbol{x}^{n+1})$。\n5.  速度的第二个半步踢：$\\boldsymbol{v}^{n+1} = \\boldsymbol{v}^{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\,\\boldsymbol{a}^{n+1}$。\n\n这就构成了一个完整的时间步。该过程重复$n_{\\text{steps}}$次迭代。在整个模拟过程中，我们监控两个粒子之间的分离距离，$d(t) = \\|\\boldsymbol{x}_1(t)-\\boldsymbol{x}_2(t)\\|_{\\text{per}}$。如果在整个演化过程中观测到的最小距离$\\min_t d(t)$低于阈值$2\\sigma$，则记录为一次“碰撞”。每个测试用例的最终输出是一个布尔值，指示此条件是否被满足。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import map_coordinates\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print results.\n    \"\"\"\n\n    # Global numerical parameters for all cases\n    N = 64\n    L = 1.0\n    sigma = 0.02\n    kappa = 0.1\n    dt = 0.002\n    n_steps = 300\n    collision_threshold = 2.0 * sigma\n\n    test_cases = [\n        # Case A: Head-on, equal masses\n        {\n            'masses': np.array([0.5, 0.5]),\n            'positions': np.array([[0.3, 0.5], [0.7, 0.5]]),\n            'velocities': np.array([[0.08, 0.0], [-0.08, 0.0]])\n        },\n        # Case B: Grazing, equal masses\n        {\n            'masses': np.array([0.5, 0.5]),\n            'positions': np.array([[0.3, 0.4], [0.7, 0.6]]),\n            'velocities': np.array([[0.08, 0.0], [-0.08, 0.0]])\n        },\n        # Case C: Head-on, very small masses\n        {\n            'masses': np.array([0.02, 0.02]),\n            'positions': np.array([[0.3, 0.5], [0.7, 0.5]]),\n            'velocities': np.array([[0.08, 0.0], [-0.08, 0.0]])\n        }\n    ]\n\n    results = []\n    \n    # Memoize grid and wavenumber calculations as they are constant for all runs\n    grid_coords = np.linspace(0, L, N, endpoint=False)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    k_freq = np.fft.fftfreq(N, d=L / N) * 2 * np.pi\n    kx, ky = np.meshgrid(k_freq, k_freq)\n    ksq = kx**2 + ky**2\n    ksq[0, 0] = 1.0  # Placeholder to avoid division-by-zero warning\n\n    for case in test_cases:\n        collided = run_simulation(\n            case, N, L, sigma, kappa, dt, n_steps, collision_threshold,\n            xx, yy, kx, ky, ksq\n        )\n        results.append(collided)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_acceleration(positions, masses, N, L, sigma, kappa, xx, yy, kx, ky, ksq):\n    \"\"\"\n    Computes acceleration on particles using a particle-mesh FFT method.\n    \"\"\"\n    # 1. Deposit mass density onto the grid\n    rho = np.zeros((N, N), dtype=float)\n    for p_idx in range(len(masses)):\n        pos = positions[p_idx]\n        mass = masses[p_idx]\n        \n        # Calculate periodic distance from each grid point to the particle\n        dx = xx - pos[0]\n        dy = yy - pos[1]\n        dx -= L * np.round(dx / L)\n        dy -= L * np.round(dy / L)\n        dist_sq = dx**2 + dy**2\n        \n        normalization = mass / (2 * np.pi * sigma**2)\n        rho += normalization * np.exp(-dist_sq / (2 * sigma**2))\n\n    # 2. Solve for potential in Fourier space\n    rho_hat = np.fft.fft2(rho)\n    phi_hat = -kappa * rho_hat / ksq\n    phi_hat[0, 0] = 0.0  # Set zero mode of potential to zero\n\n    # 3. Compute acceleration field in Fourier space and transform back\n    ax_hat = -1j * kx * phi_hat\n    ay_hat = -1j * ky * phi_hat\n    ax_grid = np.real(np.fft.ifft2(ax_hat))\n    ay_grid = np.real(np.fft.ifft2(ay_hat))\n\n    # 4. Interpolate acceleration to particle positions using bilinear interpolation\n    # with periodic wrapping\n    # map_coordinates requires coordinates in index space (not world space)\n    # and in (row, col) which corresponds to (y, x) order.\n    particle_coords_idx = positions / (L / N)\n    coords = particle_coords_idx.T[::-1, :]\n    \n    ax_interp = map_coordinates(ax_grid, coords, order=1, mode='wrap')\n    ay_interp = map_coordinates(ay_grid, coords, order=1, mode='wrap')\n    \n    return np.vstack((ax_interp, ay_interp)).T\n\ndef get_periodic_distance(pos1, pos2, L_domain):\n    \"\"\"Calculates the minimum-image distance.\"\"\"\n    delta = pos1 - pos2\n    delta -= L_domain * np.round(delta / L_domain)\n    return np.linalg.norm(delta)\n\ndef run_simulation(case, N, L, sigma, kappa, dt, n_steps, threshold, xx, yy, kx, ky, ksq):\n    \"\"\"\n    Evolves the system for a single test case.\n    \"\"\"\n    positions = case['positions'].copy()\n    velocities = case['velocities'].copy()\n    masses = case['masses']\n    \n    min_dist = get_periodic_distance(positions[0], positions[1], L)\n\n    # Compute initial acceleration to start the leapfrog integrator\n    accel_n = compute_acceleration(positions, masses, N, L, sigma, kappa, xx, yy, kx, ky, ksq)\n\n    for _ in range(n_steps):\n        # 1. Half-kick for velocity\n        vel_half = velocities + (dt / 2.0) * accel_n\n        \n        # 2. Full drift for position\n        positions_n1 = positions + dt * vel_half\n        positions_n1 %= L  # Apply periodic boundary conditions\n\n        # 3. Recompute acceleration at new positions\n        accel_n1 = compute_acceleration(positions_n1, masses, N, L, sigma, kappa, xx, yy, kx, ky, ksq)\n        \n        # 4. Second half-kick for velocity\n        velocities_n1 = vel_half + (dt / 2.0) * accel_n1\n\n        # Update state for the next iteration\n        positions = positions_n1\n        velocities = velocities_n1\n        accel_n = accel_n1\n\n        # Track minimum distance\n        dist = get_periodic_distance(positions[0], positions[1], L)\n        if dist < min_dist:\n            min_dist = dist\n\n    return min_dist < threshold\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2420566"}, {"introduction": "数值模拟产生了大量数据，但其本身并非物理洞见，真正的挑战在于如何从中提取有意义的物理量。在这个练习中，你将扮演一个理论天体物理学家的角色，利用孤立视界（isolated horizon）形式，编写一个诊断程序来计算黑洞的自旋。这个过程不仅能让你熟悉数值积分等实用技术，更能让你深刻理解如何将抽象的几何定义（如视界面积 $A$）与可观测的物理属性（如质量 $M$ 和自旋 $J$）联系起来。[@problem_id:2420583]", "problem": "您必须编写一个完整、自包含的程序，在$G=c=1$的几何化单位制下，使用孤立视界形式体系实现一种准局部黑洞自旋诊断。考虑单个黑洞，其表观视界为轴对称的拓扑球面，面积半径为$R$，因此球面面积为$A=4\\pi R^2$，面积元为$\\mathrm{d}A = R^2 \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$，其中球面角$\\theta\\in[0,\\pi]$和$\\phi\\in[0,2\\pi)$以弧度为单位。与一个轴对称矢量场相关的自旋角动量由孤立视界积分定义：\n$$\nJ \\equiv \\frac{1}{8\\pi}\\int_{S} \\omega_a \\,\\phi^a\\,\\mathrm{d}A,\n$$\n其中缩并 $\\omega_a \\phi^a$ 是视界上的一个给定标量函数。通过面积关系定义不可约质量：\n$$\nM_{\\mathrm{irr}} \\equiv \\sqrt{\\frac{A}{16\\pi}},\n$$\n并通过下式定义 Christodoulou 质量：\n$$\nM^2 \\equiv M_{\\mathrm{irr}}^2 + \\frac{J^2}{4 M_{\\mathrm{irr}}^2}。\n$$\n无量纲自旋参数为：\n$$\n\\chi \\equiv \\frac{|J|}{M^2}。\n$$\n在此单位制下，所有物理量均为无量纲。\n\n您的程序必须针对下方的每个测试用例，在球面上使用指定的 $\\omega_a \\phi^a$ 数值计算 $J$ 的积分，计算 $M_{\\mathrm{irr}}$ 和 $M$，并输出相应的 $\\chi$。角度 $\\theta$ 和 $\\phi$ 必须解释为弧度。最终结果必须四舍五入到六位小数。\n\n测试套件。对每个用例，使用给定的面积半径 $R$ 和指定的标量函数 $f(\\theta,\\phi)\\equiv \\omega_a \\phi^a$：\n- 用例 1：$R=1$，$f(\\theta,\\phi)=\\alpha$ 其中 $\\alpha=1$。\n- 用例 2：$R=3$，$f(\\theta,\\phi)=0$。\n- 用例 3：$R=2$，$f(\\theta,\\phi)=\\alpha\\sin^2\\theta$ 其中 $\\alpha=\\tfrac{3}{4}$。\n- 用例 4：$R=\\tfrac{3}{2}$，$f(\\theta,\\phi)=\\alpha\\sin^2\\theta\\cos(2\\phi)$ 其中 $\\alpha=2$。\n\n最终输出格式要求。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是对应测试用例的 $\\chi$ 值，按顺序排列，并四舍五入到六位小数。例如，一个可接受的格式是 $[\\chi_1,\\chi_2,\\chi_3,\\chi_4]$，其中每个 $\\chi_i$ 是一个小数点后有六位数字的浮点数。", "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于广义相对论的原理，特别是用于黑洞准局部表征的孤立视界形式体系。所提供的自旋角动量、不可约质量和 Christodoulou 质量的定义在此背景下是标准的。该问题是适定的，提供了所有必要的数据和方程，可以为每个测试用例得出唯一且有意义的解。语言客观而精确。\n\n问题的核心是为一系列轴对称黑洞的表观视界计算无量纲自旋参数 $\\chi$。这需要一个多步计算过程，从给定的面积半径 $R$ 和视界面上的标量函数 $f(\\theta,\\phi) \\equiv \\omega_a \\phi^a$ 开始。\n\n基本物理量定义如下：\n球形视界的表面积是 $A = 4\\pi R^2$。\n不可约质量 $M_{\\mathrm{irr}}$ 通过面积定义：\n$$ M_{\\mathrm{irr}} \\equiv \\sqrt{\\frac{A}{16\\pi}} $$\n代入 $A$ 的表达式，我们得到一个更简单的关系：\n$$ M_{\\mathrm{irr}} = \\sqrt{\\frac{4\\pi R^2}{16\\pi}} = \\sqrt{\\frac{R^2}{4}} = \\frac{R}{2} $$\n这个简化很有用。不可约质量代表了黑洞质能中无法通过 Penrose 过程提取的部分。\n\n自旋角动量 $J$ 由面积分给出：\n$$ J \\equiv \\frac{1}{8\\pi}\\int_{S} f(\\theta,\\phi)\\,\\mathrm{d}A $$\n其中 $f(\\theta,\\phi) = \\omega_a \\phi^a$。球坐标下的面积元为 $\\mathrm{d}A = R^2 \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$。该积分变为：\n$$ J = \\frac{1}{8\\pi} \\int_{0}^{2\\pi} \\int_{0}^{\\pi} f(\\theta, \\phi) R^2 \\sin\\theta \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi = \\frac{R^2}{8\\pi} \\int_{0}^{2\\pi} \\mathrm{d}\\phi \\int_{0}^{\\pi} f(\\theta, \\phi) \\sin\\theta \\, \\mathrm{d}\\theta $$\n该积分将按照问题规定进行数值计算。\n\nChristodoulou 质量 $M$ 代表了在无穷远处测量的黑洞总质能，它由 Christodoulou-Ruffini 质量公式定义：\n$$ M^2 \\equiv M_{\\mathrm{irr}}^2 + \\frac{J^2}{4 M_{\\mathrm{irr}}^2} $$\n代入我们关于 $M_{\\mathrm{irr}}$ 的表达式：\n$$ M^2 = \\left(\\frac{R}{2}\\right)^2 + \\frac{J^2}{4 \\left(\\frac{R}{2}\\right)^2} = \\frac{R^2}{4} + \\frac{J^2}{R^2} $$\n\n最后，无量纲自旋参数 $\\chi$ 计算如下：\n$$ \\chi \\equiv \\frac{|J|}{M^2} $$\n在此理论框架内，$\\chi=0$ 的值对应于不旋转的（类 Schwarzschild）黑洞，而 $\\chi=1$ 对应于极大旋转的（极端类 Kerr）黑洞。\n\n每个测试用例的计算步骤如下：\n1. 为 $J$ 的数值积分定义被积函数。令其为 $I(\\theta, \\phi) = f(\\theta, \\phi)\\sin\\theta$。\n2. 使用 `scipy.integrate.dblquad` 函数数值计算二重积分 $\\mathcal{I} = \\int_{0}^{2\\pi} \\mathrm{d}\\phi \\int_{0}^{\\pi} I(\\theta, \\phi) \\, \\mathrm{d}\\theta$。调用结构为 `dblquad(lambda theta, phi: I(theta, phi), 0, 2*pi, 0, pi)`。\n3. 计算 $J = \\frac{R^2}{8\\pi} \\mathcal{I}$。\n4. 计算 $M^2 = \\frac{R^2}{4} + \\frac{J^2}{R^2}$。\n5. 计算 $\\chi = \\frac{|J|}{M^2}$。请注意，如果 $R=0$，则 $M^2$ 和 $J^2$ 项中的分母都将为零，但所有给定的测试用例都具有 $R > 0$。类似地，如果 $M^2=0$，则意味着 $R=0$ 且 $J=0$，这是一个此处不存在的平凡情况。\n6. 最终的 $\\chi$ 值四舍五入到六位小数以供输出。\n\n我们现在将此步骤应用于每个测试用例。\n\n**用例 1：** $R=1$，$f(\\theta,\\phi)=1$。\n- $J_1 = \\frac{1^2}{8\\pi} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} (1) \\sin\\theta \\, \\mathrm{d}\\theta = \\frac{1}{8\\pi} \\cdot (2\\pi) \\cdot (2) = \\frac{4\\pi}{8\\pi} = \\frac{1}{2}$。\n- $M_1^2 = \\frac{1^2}{4} + \\frac{(1/2)^2}{1^2} = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2}$。\n- $\\chi_1 = \\frac{|1/2|}{1/2} = 1$。结果：$1.000000$。\n\n**用例 2：** $R=3$，$f(\\theta,\\phi)=0$。\n- 被积函数为零，因此积分为零。因此，$J_2 = 0$。\n- 这对应于一个不旋转的黑洞。\n- $M_2^2 = \\frac{3^2}{4} + \\frac{0^2}{3^2} = \\frac{9}{4}$。\n- $\\chi_2 = \\frac{0}{9/4} = 0$。结果：$0.000000$。\n\n**用例 3：** $R=2$，$f(\\theta,\\phi)=\\frac{3}{4}\\sin^2\\theta$。\n- $J_3 = \\frac{2^2}{8\\pi} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} \\frac{3}{4}\\sin^2\\theta \\sin\\theta \\, \\mathrm{d}\\theta = \\frac{4}{8\\pi} \\frac{3}{4} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} \\sin^3\\theta \\, \\mathrm{d}\\theta$。\n- 积分 $\\int_0^{\\pi} \\sin^3\\theta\\,\\mathrm{d}\\theta = 4/3$。积分 $\\int_0^{2\\pi} \\mathrm{d}\\phi = 2\\pi$。\n- $J_3 = \\frac{3}{8\\pi} \\cdot (2\\pi) \\cdot (4/3) = 1$。\n- $M_3^2 = \\frac{2^2}{4} + \\frac{1^2}{2^2} = 1 + \\frac{1}{4} = \\frac{5}{4} = 1.25$。\n- $\\chi_3 = \\frac{|1|}{5/4} = \\frac{4}{5} = 0.8$。结果：$0.800000$。\n\n**用例 4：** $R=\\frac{3}{2}$，$f(\\theta,\\phi)=2\\sin^2\\theta\\cos(2\\phi)$。\n- $J_4 = \\frac{(3/2)^2}{8\\pi} \\int_0^{2\\pi} \\int_0^{\\pi} 2\\sin^2\\theta\\cos(2\\phi) \\sin\\theta \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi$。\n- 积分是可分离的：$J_4 \\propto \\left(\\int_0^{\\pi} \\sin^3\\theta \\, \\mathrm{d}\\theta \\right) \\left(\\int_0^{2\\pi} \\cos(2\\phi) \\, \\mathrm{d}\\phi \\right)$。\n- 关于 $\\phi$ 的积分是 $\\int_0^{2\\pi} \\cos(2\\phi) \\, \\mathrm{d}\\phi = \\left[\\frac{\\sin(2\\phi)}{2}\\right]_0^{2\\pi} = 0$。\n- 因此，$J_4 = 0$。\n- $\\chi_4 = 0$。结果：$0.000000$。\n\n所提供的程序使用数值积分精确地实现了这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Solves for the dimensionless spin parameter for a set of black hole test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (R, f_func) where R is the areal radius and\n    # f_func is the scalar function f(theta, phi) = omega_a * phi^a.\n    test_cases = [\n        (1.0, lambda theta, phi: 1.0),\n        (3.0, lambda theta, phi: 0.0),\n        (2.0, lambda theta, phi: (3.0/4.0) * np.sin(theta)**2),\n        (1.5, lambda theta, phi: 2.0 * np.sin(theta)**2 * np.cos(2*phi))\n    ]\n\n    results = []\n    for R, f_func in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        chi = calculate_spin_parameter(R, f_func)\n        results.append(chi)\n\n    # Format the final results as strings with six decimal places.\n    results_str = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\ndef calculate_spin_parameter(R, f_func):\n    \"\"\"\n    Calculates the dimensionless spin parameter chi for a given black hole horizon.\n\n    Args:\n        R (float): The areal radius of the apparent horizon.\n        f_func (callable): A function f(theta, phi) representing the scalar omega_a * phi^a.\n\n    Returns:\n        float: The dimensionless spin parameter chi.\n    \"\"\"\n    if R <= 0:\n        # Physical radius must be positive.\n        return 0.0\n\n    # 1. Calculate Spin Angular Momentum J\n    # J = (1 / 8*pi) * integral_S(f * dA)\n    # dA = R^2 * sin(theta) * d(theta) * d(phi)\n    # J = (R^2 / 8*pi) * integral_{phi=0}^{2pi} integral_{theta=0}^{pi} f(theta, phi) * sin(theta) d(theta) d(phi)\n    \n    # Define the integrand for the numerical integration.\n    # dblquad integrates func(y, x), where y is the first argument.\n    # Here, y = theta, x = phi.\n    integrand = lambda theta, phi: f_func(theta, phi) * np.sin(theta)\n\n    # Perform the numerical double integration.\n    # Outer integral (phi) from 0 to 2*pi.\n    # Inner integral (theta) from 0 to pi.\n    integral_val, _ = dblquad(integrand, 0, 2*np.pi, 0, np.pi)\n    \n    J = (R**2 / (8 * np.pi)) * integral_val\n\n    # 2. Calculate Irreducible Mass M_irr\n    # M_irr = sqrt(A / 16*pi), where A = 4*pi*R^2\n    # This simplifies to M_irr = R / 2\n    M_irr = R / 2.0\n\n    # 3. Calculate Christodoulou Mass M\n    # M^2 = M_irr^2 + J^2 / (4 * M_irr^2)\n    try:\n        M_squared = M_irr**2 + J**2 / (4 * M_irr**2)\n    except ZeroDivisionError:\n        # This case happens if M_irr is zero, which means R is zero.\n        # For J=0, M^2=0, chi is undefined. For J!=0, M-squared is infinite.\n        # We handle R=0 at the start. So this should not be reached.\n        return np.nan\n\n    # 4. Calculate Dimensionless Spin Parameter chi\n    # chi = |J| / M^2\n    if M_squared == 0:\n        # M_squared is zero only if R=0 and J=0.\n        # A non-rotating point mass has chi=0.\n        return 0.0\n\n    chi = np.abs(J) / M_squared\n    \n    return chi\n\nsolve()\n```", "id": "2420583"}]}