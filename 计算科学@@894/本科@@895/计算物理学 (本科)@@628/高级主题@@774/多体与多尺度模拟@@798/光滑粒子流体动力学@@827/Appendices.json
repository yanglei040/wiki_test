{"hands_on_practices": [{"introduction": "SPH方法的核心在于对邻近粒子的贡献进行加权求和，以近似连续场。由于平滑核具有紧致支撑（compact support）的特性，我们只需考虑局部邻域内的粒子，但对所有粒子对进行朴素的$O(N^2)$搜索是低效的。本练习 [@problem_id:2416285] 旨在通过实现一个基于K-D树的高效邻居搜索算法来计算SPH密度，这是掌握任何大规模SPH模拟性能优化的基本实践。", "problem": "在光滑粒子流体动力学 (Smoothed Particle Hydrodynamics, SPH) 中，像质量密度这样的连续介质场通过对离散粒子的加权求和来近似。其基础起点是对一个连续介质积分的粒子近似：给定粒子位置 $\\{\\mathbf{r}_j\\}$、粒子质量 $\\{m_j\\}$ 和一个光滑长度为 $h$ 的光滑核函数 $W(\\mathbf{r}, h)$，粒子 $i$ 处的密度通过求和近似为 $\\rho_i \\approx \\sum_j m_j \\, W(\\mathbf{r}_i - \\mathbf{r}_j, h_i)$。一个广泛使用的选择是具有紧支集的三维三次样条核函数。对于三维空间，记 $r = \\lVert \\mathbf{r} \\rVert$，$q = r/h$，并使用\n$$\nW(r,h) = \\frac{1}{\\pi h^3} \\times\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3,  0 \\le q  1, \\\\\n\\frac{1}{4} (2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n该核函数具有半径为 $2h$ 的紧支集，因此只有在 $r \\le 2h$ 范围内的粒子才会对给定粒子产生影响。对于 $N$ 个粒子，朴素的全对邻居搜索需要检查所有 $N(N-1)/2$ 个粒子对，这在计算上是成本高昂的。k维树 (K-D tree) 数据结构在空间中组织点，以实现高效的范围查询。通过仅在核函数支集半径内查询，可以在保持上述定义的精确SPH求和的同时，加速密度计算。你必须实现一个程序，对于几个指定的测试用例，在粒子位置上构建一个K-D树，并为每个粒子计算：\n- SPH密度 $\\rho_i = \\sum_{j \\in \\mathcal{N}_i} m_j \\, W(\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert, h_i)$，使用三维三次样条核函数，其中 $\\mathcal{N}_i$ 是通过在 $\\mathbf{r}_i$ 周围进行半径为 $2 h_i$ 的半径查询返回的邻居，并且求和包括粒子自身（在 $r=0$ 时的自身贡献）。\n- 由K-D树在核函数支集内返回的邻居数量 $\\lvert \\mathcal{N}_i \\rvert$，其条件是 $r \\le 2h_i$。\n\n使用以下完整指定的测试套件。所有位置都是三维的，并以千秒差距 (kpc) 表示。所有质量都以太阳质量 (M$_\\odot$) 表示。所有光滑长度都以千秒差距 (kpc) 表示。密度必须以太阳质量/立方千秒差距 (M$_\\odot$/kpc$^3$) 报告。本问题中不使用角度。测试套件包含3个用例：\n\n- 测试用例1（具有统一光滑长度的普通星团）：位置\n$[\\,[0.0, 0.0, 0.0],\\,[0.3, 0.0, 0.0],\\,[0.0, 0.4, 0.0],\\,[0.0, 0.0, 0.5],\\,[1.2, 0.0, 0.0]\\,]$，质量 $[\\,1.0,\\,1.0,\\,2.0,\\,1.0,\\,1.0\\,]$，以及统一的光滑长度 $h=0.5$。\n- 测试用例2（邻居恰好在核函数支集边界上）：位置 $[\\,[0.0, 0.0, 0.0],\\,[0.4, 0.0, 0.0]\\,]$，质量 $[\\,1.0,\\,1.0\\,]$，以及统一的光滑长度 $h=0.2$。\n- 测试用例3（每个粒子具有可变的光滑长度）：位置 $[\\,[0.0, 0.0, 0.0],\\,[0.6, 0.0, 0.0],\\,[1.3, 0.0, 0.0]\\,]$，质量 $[\\,1.0,\\,2.0,\\,1.0\\,]$，以及每个粒子的光滑长度 $[\\,0.5,\\,0.3,\\,0.7\\,]$。\n\n你的任务：\n- 完全按照上述定义实现三维三次样条核函数。\n- 为每个测试用例构建一个K-D树，以找到每个粒子 $i$ 在半径 $2 h_i$ 内的所有邻居。\n- 使用核函数 $W$ 为每个粒子计算 $\\rho_i$，并包含自身贡献。\n- 报告每个粒子在每个测试用例中的密度和邻居数量 $\\lvert \\mathcal{N}_i \\rvert$。\n\n单位和格式要求：\n- 密度以 M$_\\odot$/kpc$^3$ 表示，并将每个密度值四舍五入到6位小数。\n- 邻居数量必须是整数。\n- 你的程序必须生成单行输出，包含一个由逗号分隔并用方括号括起来的结果列表。每个测试用例的结果必须是两个列表的列表：第一个列表是该测试用例中每个粒子的密度（浮点数，四舍五入到6位小数），第二个列表是每个粒子的邻居数量（整数）。例如，整体输出格式为 $[\\,[\\,[\\rho_{1,1}, \\rho_{1,2}, \\dots],\\,[c_{1,1}, c_{1,2}, \\dots]\\,],\\,[\\,[\\rho_{2,1}, \\dots],\\,[c_{2,1}, \\dots]\\,],\\,[\\,[\\rho_{3,1}, \\dots],\\,[c_{3,1}, \\dots]\\,]\\,]$，其中索引 $(t,i)$ 表示测试用例 $t$ 中的粒子 $i$。\n- 程序必须完全自包含，测试套件需硬编码，且不得读取任何输入。\n\n从第一性原理出发，从SPH求和的定义和核函数的紧支集特性开始设计你的算法，以论证使用半径为 $2 h_i$ 的半径查询的合理性。然后实现基于K-D树的邻居搜索，以计算给定测试套件所需的输出。确保逻辑对于 $r = 2h_i$ 的边界情况以及对于每个粒子可变的光滑长度都是正确的。最终输出必须是遵循上述确切格式的单行文本。", "solution": "对问题陈述进行验证。\n\n**第1步：提取已知信息**\n- **物理模型**：光滑粒子流体动力学 (SPH) 密度估计。\n- **目标量**：粒子密度 $\\rho_i$。\n- **公式**：$\\rho_i = \\sum_{j \\in \\mathcal{N}_i} m_j \\, W(\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert, h_i)$。\n- **光滑核函数**：一个三维三次样条核函数，定义如下。设 $r = \\lVert \\mathbf{r} \\rVert$ 和 $q = r/h$。\n$$\nW(r,h) = \\frac{1}{\\pi h^3} \\times\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3,  0 \\le q  1, \\\\\n\\frac{1}{4} (2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n- **计算方法**：必须使用k维树(K-D树)进行邻居搜索。该搜索是在每个粒子 $\\mathbf{r}_i$ 周围进行半径为 $2h_i$ 的半径查询。\n- **每个粒子的输出**：\n    1. SPH密度 $\\rho_i$，包含自身贡献。\n    2. 通过半径查询得到的邻居数量 $|\\mathcal{N}_i|$，其条件是 $r \\le 2h_i$。\n- **常量和单位**：位置以千秒差距 (kpc) 为单位，质量以太阳质量 ($M_\\odot$) 为单位，光滑长度以 kpc 为单位。密度必须是 $M_\\odot$/kpc$^3$。\n- **测试用例**：\n    - **用例1**：位置 $\\mathbf{r} = [\\,[0.0, 0.0, 0.0],\\,[0.3, 0.0, 0.0],\\,[0.0, 0.4, 0.0],\\,[0.0, 0.0, 0.5],\\,[1.2, 0.0, 0.0]\\,]$，质量 $m = [\\,1.0,\\,1.0,\\,2.0,\\,1.0,\\,1.0\\,]$，统一光滑长度 $h=0.5$。\n    - **用例2**：位置 $\\mathbf{r} = [\\,[0.0, 0.0, 0.0],\\,[0.4, 0.0, 0.0]\\,]$，质量 $m = [\\,1.0,\\,1.0\\,]$，统一光滑长度 $h=0.2$。\n    - **用例3**：位置 $\\mathbf{r} = [\\,[0.0, 0.0, 0.0],\\,[0.6, 0.0, 0.0],\\,[1.3, 0.0, 0.0]\\,]$，质量 $m = [\\,1.0,\\,2.0,\\,1.0\\,]$，每个粒子的光滑长度 $h = [\\,0.5,\\,0.3,\\,0.7\\,]$。\n- **输出格式**：一个单行字符串，表示一个嵌套列表：$[\\,[\\,[\\text{densities}_1], [\\text{counts}_1]\\,], \\dots\\,]$。密度将被四舍五入到6位小数。\n\n**第2步：使用提取的已知信息进行验证**\n- **科学依据**：该问题在计算天体物理学领域有坚实的基础。SPH是一种标准的数值方法。三次样条核函数是一种常规选择，其性质已得到充分理解。使用K-D树进行邻居查找是优化SPH计算的典范方法。\n- **良态性**：问题在数学上和算法上都是良态的。输入已完全指定。要计算的函数定义明确，没有歧义。对于给定的输入和规定的方法，存在唯一的结果。\n- **客观性**：问题使用精确、客观和形式化的语言陈述。\n\n问题表述是完整的、一致的且科学上合理的。未发现任何缺陷。\n\n**第3步：结论与行动**\n问题有效。将构建一个解决方案。\n\n**基于原理的设计与解决方案**\n\n目标是计算由一组离散粒子采样的质量密度场。在光滑粒子流体动力学(SPH)中，任何连续场 $A(\\mathbf{r})$ 都通过与光滑核函数 $W$ 进行卷积来近似。在粒子 $i$ 的位置 $\\mathbf{r}_i$ 处，密度 $\\rho(\\mathbf{r}_i)$ 的粒子近似由以下求和给出：\n$$\n\\rho_i = \\rho(\\mathbf{r}_i) \\approx \\sum_{j=1}^{N} m_j W(\\mathbf{r}_i - \\mathbf{r}_j, h_i)\n$$\n其中 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 分别是粒子 $i$ 和 $j$ 的位置矢量，$m_j$ 是粒子 $j$ 的质量，$N$ 是粒子总数，而 $W$ 是与粒子 $i$ 关联的特征光滑长度为 $h_i$ 的光滑核函数。\n\n指定的三维三次样条核函数被定义为无量纲距离 $q = r/h$ 的函数，其中 $r = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$。该核函数的一个关键性质是其*紧支集*。定义明确指出，对于 $q \\ge 2$（等价于 $r \\ge 2h$），$W(r,h) = 0$。这意味着只有与粒子 $i$ 的距离在 $2h_i$ 以内的粒子才能对其密度产生非零贡献。因此，对所有 $N$ 个粒子的求和可以被限制为仅对该支集半径内的“邻居”粒子求和：\n$$\n\\rho_i = \\sum_{j \\in \\mathcal{N}_i} m_j W(\\mathbf{r}_i - \\mathbf{r}_j, h_i), \\quad \\text{其中 } \\mathcal{N}_i = \\{j \\mid \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert  2h_i\\}\n$$\n问题将邻居搜索条件指定为 $r \\le 2h_i$。由于当 $q=2$（即$r=2h_i$）时核函数为零，因此包含恰好在支集半径边界上的粒子不会改变密度值，但对于按要求正确计算邻居数量是必要的。\n\n为每个粒子寻找邻居的朴素全对搜索将需要大约 $N(N-1)/2$ 次距离计算，导致总体计算复杂度为 $O(N^2)$。对于大的 $N$，这是令人望而却步的。问题要求使用更高效的方法，即k维树(K-D树)。K-D树是一种用于在k维空间中组织点的空间分割数据结构。对于我们的三维问题，它允许进行高效的范围查询（也称为球查询）。通过在粒子位置集合 $\\{\\mathbf{r}_j\\}$ 上构建K-D树，我们可以为每个粒子 $i$ 查询该树，以找到以 $\\mathbf{r}_i$ 为中心、半径为 $R_i = 2h_i$ 的球内的所有粒子。此操作比 $O(N^2)$ 快得多，其构建树和执行所有查询的平均情况复杂度接近 $O(N \\log N)$。\n\n因此，算法如下：\n1.  对于每个测试用例，获取粒子位置并构建一个K-D树。`scipy.spatial.KDTree` 类适合此目的。\n2.  初始化空列表，用于存储当前测试用例最终计算出的密度和邻居数量。\n3.  遍历每个粒子 $i$（从 $0$ 到 $N-1$）。\n    a.  确定当前粒子的光滑长度 $h_i$。对于测试用例3，这是特定于粒子的；对于用例1和2，它对所有粒子都是一个统一的值。\n    b.  定义支集半径 $R_i = 2h_i$。\n    c.  使用K-D树的 `query_ball_point` 方法，以位置 $\\mathbf{r}_i$ 和半径 $R_i$ 查询，找到所有邻居粒子（包括粒子 $i$ 自身）的索引。\n    d.  邻居数量 $|\\mathcal{N}_i|$ 是查询返回的索引列表的长度。存储此整数值。\n    e.  将粒子 $i$ 的密度 $\\rho_i$ 初始化为 $0.0$。\n    f.  遍历步骤3c中找到的邻居粒子的索引 $j$。\n        i.   检索邻居粒子 $j$ 的质量 $m_j$ 和位置 $\\mathbf{r}_j$。\n        ii.  计算距离 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$。\n        iii. 计算无量纲距离 $q = r_{ij} / h_i$。注意，当 $h_i=0$ 时这将是未定义的，但问题只提供了正的光滑长度。\n        iv.  根据 $q$ 的值，使用其分段定义来评估核函数 $W(r_{ij}, h_i)$。必须包含归一化因子 $\\frac{1}{\\pi h_i^3}$。\n        v.   将贡献 $m_j W(r_{ij}, h_i)$ 加到 $\\rho_i$ 上。\n    g.  遍历完所有邻居后，存储 $\\rho_i$ 的最终值。\n4.  处理完测试用例中的所有粒子后，将密度列表和邻居数量列表收集到该用例的单一结构中。\n5.  对所有测试用例重复此过程，并按指定格式化最终输出。\n\n此过程正确地实现了使用高效的K-D树进行邻居查找的SPH密度计算，遵循了三次样条核函数的紧支集特性，并处理了统一和可变的光滑长度。测试用例2中强调的 $r=2h_i$ 处的边界条件得到了正确处理：该粒子被计为邻居，但其对密度的贡献为零。", "answer": "```python\nimport numpy as np\nfrom scipy.spatial import KDTree\n\ndef solve():\n    \"\"\"\n    Solves the SPH density calculation problem for the specified test suite.\n    \"\"\"\n\n    # Fully specified test suite\n    test_suite = [\n        {\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], [0.3, 0.0, 0.0], [0.0, 0.4, 0.0],\n                [0.0, 0.0, 0.5], [1.2, 0.0, 0.0]\n            ]),\n            \"masses\": np.array([1.0, 1.0, 2.0, 1.0, 1.0]),\n            \"h_values\": 0.5\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.4, 0.0, 0.0]]),\n            \"masses\": np.array([1.0, 1.0]),\n            \"h_values\": 0.2\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.6, 0.0, 0.0], [1.3, 0.0, 0.0]]),\n            \"masses\": np.array([1.0, 2.0, 1.0]),\n            \"h_values\": np.array([0.5, 0.3, 0.7])\n        }\n    ]\n\n    def kernel_3d_cubic_spline(r, h):\n        \"\"\"\n        Computes the value of the 3D cubic spline smoothing kernel.\n        \n        Args:\n            r (float): The distance between particles.\n            h (float): The smoothing length.\n\n        Returns:\n            float: The kernel value W(r, h).\n        \"\"\"\n        if h = 0:\n            return 0.0\n\n        sigma = 1.0 / (np.pi * h**3)\n        q = r / h\n        \n        if 0 = q  1:\n            return sigma * (1.0 - 1.5 * q**2 + 0.75 * q**3)\n        elif 1 = q  2:\n            return sigma * (0.25 * (2.0 - q)**3)\n        else: # q >= 2\n            return 0.0\n\n    all_results = []\n\n    for case in test_suite:\n        positions = case[\"positions\"]\n        masses = case[\"masses\"]\n        h_values_input = case[\"h_values\"]\n        num_particles = len(positions)\n\n        # Handle both uniform and per-particle smoothing lengths\n        if isinstance(h_values_input, (int, float)):\n            h_values = np.full(num_particles, h_values_input)\n        else:\n            h_values = h_values_input\n\n        # Build the K-D tree on particle positions\n        kdtree = KDTree(positions)\n\n        case_densities = []\n        case_neighbor_counts = []\n\n        for i in range(num_particles):\n            pos_i = positions[i]\n            h_i = h_values[i]\n            \n            # Query for neighbors within the compact support radius 2*h_i\n            # The query condition is r = 2*h_i\n            support_radius = 2.0 * h_i\n            neighbor_indices = kdtree.query_ball_point(pos_i, r=support_radius)\n            \n            neighbor_count = len(neighbor_indices)\n            case_neighbor_counts.append(neighbor_count)\n            \n            # Calculate SPH density\n            density_i = 0.0\n            for j in neighbor_indices:\n                pos_j = positions[j]\n                mass_j = masses[j]\n                \n                # Calculate distance between particles i and j\n                distance_rij = np.linalg.norm(pos_i - pos_j)\n                \n                # Calculate kernel contribution and add to density\n                kernel_val = kernel_3d_cubic_spline(distance_rij, h_i)\n                density_i += mass_j * kernel_val\n            \n            case_densities.append(round(density_i, 6))\n            \n        all_results.append([case_densities, case_neighbor_counts])\n\n    # Format the final output string exactly as required\n    # Creates a string representation like \"[[[...],[...]],[[...],[...]]]\"\n    # using the list's default str conversion, which is then joined.\n    result_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2416285"}, {"introduction": "在流体动力学中计算作用力，例如由压力梯度产生的力，需要我们计算物理量的空间导数。在SPH中，物理量的导数是通过对粒子贡献进行加权求和来近似的，其权重为平滑核的导数。本练习 [@problem_id:2439500] 深入探讨了精确计算导数的关键任务，通过比较不同平滑核（例如标准三次样条核和高阶五次样条核）的性能，来揭示核函数的复杂性与数值精度之间的权衡。", "problem": "实现一个程序，该程序针对一维平滑粒子流体动力学（SPH），使用两种紧支集核函数（标准三次样条和五次样条）来构建标量场的二阶导数近似。您必须从第一性原理推导所需的公式并实现它们。此比较必须在周期性域上进行，使用等间距粒子和差分一致的SPH二阶导数算子。所有量均为无量纲，角度以弧度为单位。\n\n从SPH的基本基础开始：通过一个归一化的、正值的、具有紧支集和平滑长度 $h$ 的径向对称核函数 $W(r,h)$ 来近似函数 $f(x)$，以及通过对粒子体积求和来替代积分的SPH方法。使用以下原则：\n- 导数的核函数近似是通过对卷积积分内的核函数进行微分得到的。\n- 对于具有均匀间距 $\\Delta x$ 和恒定密度的离散粒子，粒子体积为 $V = \\Delta x$。\n- 为避免零阶误差，请使用基于核函数二阶导数的差分一致的离散二阶导数算子。\n\n您的任务：\n1. 从SPH卷积积分和在 $[0,L)$ 上的周期性边界条件下的均匀采样出发，推导出一个在粒子位置 $x_i$ 处离散的、差分一致的二阶导数算子，其形式为\n   $$ f''(x_i) \\approx \\sum_{j} V \\, \\big(f(x_j) - f(x_i)\\big) \\, \\frac{\\partial^2}{\\partial x^2} W\\!\\big(|x_i - x_j|, h\\big), $$\n   其中 $V = \\Delta x$，$x_j$ 是粒子位置，求和包含核函数支集内的所有邻近粒子。解释为什么在一维情况下，当 $r = |x|$ 时，对于 $r \\neq 0$，有 $\\frac{\\partial^2}{\\partial x^2}W(r,h) = \\frac{d^2}{dr^2}W(r,h)$。\n\n2. 在一维中实现标准三次样条核函数和五次样条核函数，每个都具有正确的归一化和紧支集，并推导它们的一维二阶径向导数 $d^2W/dr^2$ 作为 $q = r/h$ 和 $h$ 的函数。三次样条的支集半径为 $2h$，五次样条的支集半径为 $3h$。您必须在您的解答中提供您用于两种核函数及其二阶导数的分段多项式表达式。\n\n3. 使用任务1中的算子，对以下测试套件近似 $f''(x)$。在所有情况下，使用周期性边界条件、等间距粒子，并使用给定的 $\\eta$ 设定 $h = \\eta \\, \\Delta x$；角度以弧度为单位。\n   - 情况A（单模）：$L = 1$，$N = 200$，$\\eta = 1.2$，$f(x) = \\sin(2\\pi x)$，因此精确的二阶导数为 $f''(x) = - (2\\pi)^2 \\sin(2\\pi x)$。\n   - 情况B（双模叠加）：$L = 1$，$N = 256$，$\\eta = 1.0$，$f(x) = \\sin(2\\pi x) + 0.5 \\sin(6\\pi x)$，因此精确的二阶导数为 $f''(x) = - (2\\pi)^2 \\sin(2\\pi x) - 0.5 \\, (6\\pi)^2 \\sin(6\\pi x)$。\n   - 情况C（更粗的采样，更小的平滑）：$L = 1$，$N = 64$，$\\eta = 0.7$，$f(x) = \\sin(2\\pi x)$，精确的二阶导数与情况A相同。\n   - 情况D（局域高斯函数）：$L = 1$，$N = 400$，$\\eta = 1.0$，$f(x) = \\exp\\!\\big(-\\frac{(x - 0.3)^2}{2 \\sigma^2}\\big)$，其中 $\\sigma = 0.05$，因此精确的二阶导数为 $f''(x) = f(x)\\Big(\\frac{(x - 0.3)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\Big)$。\n\n4. 对每种情况，计算每个核函数的相对均方根（RMS）误差，\n   $$ \\varepsilon = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\big(\\hat f_i'' - f_i''\\big)^2}}{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\big(f_i''\\big)^2}}, $$\n   其中 $\\hat f_i''$ 是SPH近似值，$f_i''$ 是精确值。对每种情况，报告三次和五次样条核函数的误差对，每个误差都四舍五入到六位小数，并报告一个布尔值，指示五次样条误差是否严格小于三次样条误差。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的子列表列表，每个测试用例一个子列表，顺序为 A、B、C、D。\n- 每个子列表的形式必须为 $[e_{\\mathrm{cubic}}, e_{\\mathrm{quintic}}, b]$，其中 $e_{\\mathrm{cubic}}$ 和 $e_{\\mathrm{quintic}}$ 是四舍五入到六位小数的相对RMS误差，$b$ 是一个布尔值，如果 $e_{\\mathrm{quintic}}  e_{\\mathrm{cubic}}$ 则为 $True$，否则为 $False$。\n- 示例模式（非实际值）：$[[0.012345,0.006789,True],[\\dots],\\dots]$。\n\n所有输出中，误差为无量纲浮点数，比较为布尔值，并且单行必须只包含此列表。不应打印任何其他文本。", "solution": "所述问题具有科学依据，提法恰当且自成体系。它是在计算物理学领域的一个标准练习，具体涉及使用平滑粒子流体动力学（SPH）方法进行导数的数值近似。所有需要的数据和定义都已提供，没有明显的矛盾或含糊之处。因此，我们直接进行推导和求解。\n\n任务是使用两种不同的平滑核函数，为标量场的二阶导数 $f''(x)$ 构建并评估一个一维SPH近似。问题的核心在于SPH算子和核函数本身的正确表述。\n\n首先，我们推导指定的SPH二阶导数算子。SPH的基础是函数 $f(x)$ 的核函数近似，表示为与平滑核函数 $W$ 的卷积：\n$$ \\langle f(x) \\rangle = \\int_{\\Omega} f(x') W(|x-x'|, h) \\, dx' $$\n此处，$W$ 是一个归一化的核函数，其紧支集由平滑长度 $h$ 定义。二阶导数的近似 $\\langle f''(x) \\rangle$ 是通过将此积分表达式对 $x$ 微分两次得到的。假设 $W$ 具有足够的光滑性，我们可以将微分算子移到积分号内：\n$$ \\langle f''(x) \\rangle = \\int_{\\Omega} f(x') \\frac{\\partial^2}{\\partial x^2} W(|x-x'|, h) \\, dx' $$\n为了得到数值方法，该积分被离散化为对一组位于位置 $x_j$ 的“粒子”的求和。每个粒子携带场的值 $f(x_j)$，并代表一个小体积 $V_j$。对于间距为 $\\Delta x$ 的均匀一维粒子分布，每个粒子代表的体积为 $V = \\Delta x$。因此，积分被替换为求和：\n$$ f''(x_i) \\approx \\sum_{j} V f(x_j) \\frac{\\partial^2}{\\partial x^2} W(|x_i-x_j|, h) $$\n这是一个标准的SPH二阶导数公式。然而，众所周知，由于离散化误差，它存在零阶误差，即对于常数场它不完全为零。问题指定了一个更优的、差分一致的公式：\n$$ f''(x_i) \\approx \\sum_{j} V \\left( f(x_j) - f(x_i) \\right) \\frac{\\partial^2}{\\partial x^2} W(|x_i - x_j|, h) $$\n这种形式的优点是显而易见的。如果 $f(x)$ 是一个常数函数 $f(x)=C$，那么对所有 $j$ 都有 $f(x_j) - f(x_i) = 0$。因此，求和得出 $f''(x_i) \\approx 0$，这正是精确结果。该算子修正了零阶不一致性。\n\n该算子需要计算 $\\frac{\\partial^2}{\\partial x^2} W(r, h)$，其中 $r = |x_i - x_j|$。令 $\\Delta x = x_i - x_j$。关于 $\\Delta x$ 的二阶偏导数与关于 $r=|\\Delta x|$ 的二阶常导数之间的关系可以通过链式法则找到。\n$$ \\frac{\\partial W}{\\partial \\Delta x} = \\frac{dW}{dr} \\frac{\\partial r}{\\partial \\Delta x} = \\frac{dW}{dr} \\text{sgn}(\\Delta x) $$\n再次对 $\\Delta x$ 微分，使用乘积法则得到：\n$$ \\frac{\\partial^2 W}{\\partial (\\Delta x)^2} = \\left( \\frac{d^2W}{dr^2} \\frac{\\partial r}{\\partial \\Delta x} \\right) \\text{sgn}(\\Delta x) + \\frac{dW}{dr} \\frac{\\partial}{\\partial \\Delta x} (\\text{sgn}(\\Delta x)) = \\frac{d^2W}{dr^2} (\\text{sgn}(\\Delta x))^2 + \\frac{dW}{dr} (2\\delta(\\Delta x)) $$\n对于任何不同的粒子对 $i \\neq j$，我们有 $\\Delta x \\neq 0$，因此 $r \\neq 0$。在这种情况下，$(\\text{sgn}(\\Delta x))^2 = 1$，且狄拉克δ函数项 $\\delta(\\Delta x)$ 为零。粒子 $j=i$ 对和的贡献为零，因为 $f(x_i) - f(x_i) = 0$。因此，对于所有对求和有贡献的项，以下恒等式成立：\n$$ \\frac{\\partial^2}{\\partial x^2} W(|x_i-x_j|, h) = \\frac{d^2 W}{dr^2}(r, h) \\quad \\text{对于 } r = |x_i-x_j| \\neq 0 $$\n\n接下来，我们具体说明核函数及其二阶导数。令 $q=r/h$ 为无量纲距离。\n\n**1. 三次样条核函数**\n此核函数的支集半径为 $2h$。一维归一化形式为：\n$$ W(r, h) = \\frac{1}{h} \\begin{cases} \\frac{2}{3} - q^2 + \\frac{1}{2}q^3  0 \\le q  1 \\\\ \\frac{1}{6}(2-q)^3  1 \\le q \\le 2 \\\\ 0  q  2 \\end{cases} $$\n其关于 $r$ 的二阶导数通过 $\\frac{d^2W}{dr^2} = \\frac{1}{h^3}\\frac{d^2}{dq^2}(hW)$ 求得。这给出：\n$$ \\frac{d^2W}{dr^2} = \\frac{1}{h^3} \\begin{cases} -2 + 3q  0 \\le q  1 \\\\ 2-q  1 \\le q \\le 2 \\\\ 0  q  2 \\end{cases} $$\n\n**2. 五次样条核函数**\n此核函数提供更高阶的精度，并具有更大的支集半径 $3h$。一维归一化形式为：\n$$ W(r, h) = \\frac{1}{120h} \\begin{cases} (3-q)^5 - 6(2-q)^5 + 15(1-q)^5  0 \\le q  1 \\\\ (3-q)^5 - 6(2-q)^5  1 \\le q  2 \\\\ (3-q)^5  2 \\le q \\le 3 \\\\ 0  q  3 \\end{cases} $$\n其关于 $r$ 的二阶导数为：\n$$ \\frac{d^2W}{dr^2} = \\frac{1}{6h^3} \\begin{cases} (3-q)^3 - 6(2-q)^3 + 15(1-q)^3  0 \\le q  1 \\\\ (3-q)^3 - 6(2-q)^3  1 \\le q  2 \\\\ (3-q)^3  2 \\le q \\le 3 \\\\ 0  q  3 \\end{cases} $$\n这些公式被实现用来计算在指定测试案例中每个粒子位置 $x_i$ 的SPH近似 $\\hat{f}_i''$。域是周期性的，所以粒子间的距离使用最小镜像约定计算：$r_{ij} = \\min(|x_i-x_j|, L-|x_i-x_j|)$。每个核函数的精度由相对均方根（RMS）误差 $\\varepsilon$ 来量化：\n$$ \\varepsilon = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\big(\\hat f_i'' - f_i''\\big)^2}}{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\big(f_i''\\big)^2}} $$\n其中 $\\hat f_i''$ 是SPH近似值，$f_i''$ 是在 $x_i$ 处二阶导数的解析值。下面的程序为给定的测试套件执行这些计算。", "answer": "```python\nimport numpy as np\n\ndef d2W_cubic_dr2(r, h):\n    \"\"\"\n    Computes the second derivative of the 1D cubic spline kernel.\n    The kernel has support 2h.\n    \"\"\"\n    q = r / h\n    factor = 1.0 / (h ** 3)\n    val = 0.0\n    if q  1.0:\n        val = -2.0 + 3.0 * q\n    elif q  2.0:\n        val = 2.0 - q\n    return factor * val\n\ndef d2W_quintic_dr2(r, h):\n    \"\"\"\n    Computes the second derivative of the 1D quintic spline kernel.\n    The kernel has support 3h.\n    \"\"\"\n    q = r / h\n    # Normalization factor for d2W/dr2 is (1/120) * 20 / h^3 = 1 / (6*h^3)\n    factor = 1.0 / (6.0 * (h ** 3))\n    val = 0.0\n    if q  1.0:\n        val = (3.0 - q)**3 - 6.0 * (2.0 - q)**3 + 15.0 * (1.0 - q)**3\n    elif q  2.0:\n        val = (3.0 - q)**3 - 6.0 * (2.0 - q)**3\n    elif q  3.0:\n        val = (3.0 - q)**3\n    return factor * val\n\ndef calculate_f_double_prime_sph(x, f_vals, L, h, kernel_d2W_dr2, support_factor):\n    \"\"\"\n    Calculates the SPH approximation of the second derivative using a\n    difference-consistent operator.\n    \"\"\"\n    N = len(x)\n    dx = L / N\n    V = dx\n    f_pp_sph = np.zeros(N)\n    \n    support_radius = support_factor * h\n\n    for i in range(N):\n        sum_val = 0.0\n        for j in range(N):\n            if i == j:\n                continue\n            \n            dist_ij = x[i] - x[j]\n            # Apply periodic boundary conditions using minimum image convention\n            dist_ij -= L * np.round(dist_ij / L)\n            r = np.abs(dist_ij)\n\n            if r  support_radius:\n                d2W = kernel_d2W_dr2(r, h)\n                sum_val += (f_vals[j] - f_vals[i]) * d2W\n        \n        f_pp_sph[i] = V * sum_val\n        \n    return f_pp_sph\n\ndef compute_relative_rms_error(approx, exact):\n    \"\"\"\n    Computes the relative root-mean-square error.\n    \"\"\"\n    numerator = np.sqrt(np.mean((approx - exact)**2))\n    denominator = np.sqrt(np.mean(exact**2))\n    if denominator == 0:\n        return 0.0 if numerator == 0 else np.inf\n    return numerator / denominator\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'L': 1.0, 'N': 200, 'eta': 1.2, \n         'f': lambda x: np.sin(2 * np.pi * x),\n         'f_pp': lambda x: -(2 * np.pi)**2 * np.sin(2 * np.pi * x)},\n        # Case B\n        {'L': 1.0, 'N': 256, 'eta': 1.0, \n         'f': lambda x: np.sin(2 * np.pi * x) + 0.5 * np.sin(6 * np.pi * x),\n         'f_pp': lambda x: -(2 * np.pi)**2 * np.sin(2 * np.pi * x) - 0.5 * (6 * np.pi)**2 * np.sin(6 * np.pi * x)},\n        # Case C\n        {'L': 1.0, 'N': 64, 'eta': 0.7, \n         'f': lambda x: np.sin(2 * np.pi * x),\n         'f_pp': lambda x: -(2 * np.pi)**2 * np.sin(2 * np.pi * x)},\n        # Case D\n        {'L': 1.0, 'N': 400, 'eta': 1.0, \n         'f': lambda x, sigma=0.05: np.exp(-(x - 0.3)**2 / (2 * sigma**2)),\n         'f_pp': lambda x, sigma=0.05: np.exp(-(x - 0.3)**2 / (2 * sigma**2)) * (((x - 0.3)**2 / sigma**4) - (1 / sigma**2))}\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        L = case['L']\n        N = case['N']\n        eta = case['eta']\n        f_func = case['f']\n        f_pp_func = case['f_pp']\n        \n        dx = L / N\n        h = eta * dx\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        f_vals = f_func(x)\n        f_pp_exact = f_pp_func(x)\n\n        # Cubic spline calculation\n        f_pp_cubic = calculate_f_double_prime_sph(x, f_vals, L, h, d2W_cubic_dr2, 2.0)\n        error_cubic = compute_relative_rms_error(f_pp_cubic, f_pp_exact)\n        \n        # Quintic spline calculation\n        f_pp_quintic = calculate_f_double_prime_sph(x, f_vals, L, h, d2W_quintic_dr2, 3.0)\n        error_quintic = compute_relative_rms_error(f_pp_quintic, f_pp_exact)\n        \n        is_quintic_better = error_quintic  error_cubic\n        \n        results.append([round(error_cubic, 6), round(error_quintic, 6), is_quintic_better])\n        \n    output_parts = []\n    for res_list in results:\n        part = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n        output_parts.append(part)\n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2439500"}, {"introduction": "要随时间演化一个SPH系统，需要一个时间积分器，而对于显式格式，时间步长$\\Delta t$的选择对模拟的稳定性和准确性至关重要。一个固定的、过小的时间步长会浪费计算资源，而过大的时间步长则会导致数值不稳定。本练习 [@problem_id:2439517] 提供了设计和实现一个可变时间步长控制器的实践经验，该控制器基于多个物理约束（包括CFL条件、力条件和粘性扩散条件）来动态调整$\\Delta t$，这是任何稳健高效的SPH代码都不可或缺的组成部分。", "problem": "您的任务是为一个显式光滑粒子流体动力学（SPH）时间积分器实现一个可变时间步长控制器。该控制器基于三个基本稳定性和准确性考量：一个库朗-弗里德里希斯-列维（Courant–Friedrichs–Lewy, CFL）条件、一个力（加速度）条件以及一个粘性扩散条件。您的解决方案必须从与双曲型和抛物型问题的显式方法以及经典运动学相一致的第一性原理出发，并推导出您将在每次迭代中为时间步长实现的精确表达式。场景为一维，具有统一的光滑长度，程序应仅对时间变量进行积分，同时随时间采样预设的最大场量。所有物理量必须在国际单位制（SI）下处理，时间应始终以秒为单位进行计算和报告。\n\n推导起点：仅使用以下基本原理作为您的根本出发点。\n- 双曲型系统中的特征信号传播：信息以特征速度传播，因此一个稳定的显式步长必须受到空间分辨率与最大信号速度之比的限制。\n- 在一个时间步长内恒定加速度下的运动学：为保持准确性，匀加速下的位移必须相对于空间分辨率保持较小。\n- 应用于抛物型扩散的显式格式的稳定性极限：时间步长必须有界，其界限与空间分辨率的平方成正比，与运动粘度成反比。\n\n假设以下建模设置：\n- 光滑长度 $h$ 是恒定且统一的。\n- 最大信号速度被建模为声速与对流速度之和，因此瞬时最大信号速度为 $s(t) = c + \\lvert v_{\\max}(t)\\rvert$，其中 $c$ 是（恒定的）声速，$v_{\\max}(t)$ 是随时间变化的最大粒子速度大小。\n- 最大加速度大小 $a_{\\max}(t)$ 是随时间变化的。\n- 运动粘度 $\\nu$ 是恒定且统一的。\n- 每个时间步长分别为三个限制使用一个安全系数 $C_{\\mathrm{CFL}}$、$C_{\\mathrm{force}}$ 和 $C_{\\mathrm{visc}}$，每个系数都严格介于 $0$ 和 $1$ 之间。\n\n根据上述原理，推导出在时间 $t$ 的三个候选时间步长的显式公式：一个用 $h$ 和 $s(t)$ 表示的双曲型（CFL）界限，一个用 $h$ 和 $a_{\\max}(t)$ 表示的基于力的界限，以及一个用 $h$ 和 $\\nu$ 表示的粘性扩散界限。然后，实现一个显式的时间推进控制器，该控制器从 $t=0$ 开始，重复执行以下操作：\n- 在当前时间 $t$ 评估三个候选界限；\n- 选择三者中的最小者作为下一个时间增量 $\\Delta t$（通过按CFL、力、粘性的顺序选择第一个来打破平局）；\n- 使用整数代码记录该步中哪个界限起限制作用：$0$ 代表CFL，$1$ 代表力，$2$ 代表粘性；\n- 将时间推进 $\\Delta t$；\n- 当 $t$ 到达指定的结束时间 $T_{\\mathrm{end}}$ 时停止（您必须确保 $t$ 不超过 $T_{\\mathrm{end}}$；如有必要，截断最后一步以精确在 $T_{\\mathrm{end}}$ 结束，但使用未截断的候选界限对限制器进行分类）。\n\n稳健地处理边界情况：如果在任何时候 $a_{\\max}(t)=0$，基于力的界限应被视为 $+\\infty$；如果 $\\nu=0$，粘性界限应被视为 $+\\infty$。您可以假设 $c>0$，因此CFL界限总是有界的。$v_{\\max}(t)$ 和 $a_{\\max}(t)$ 的评估由下面给出的平滑时间函数定义。此问题中不出现角度。没有百分比量。\n\n为进行测试和保证可复现性，请使用以下包含三个案例的测试套件。在每个案例中，最大速度和加速度由以下公式指定：\n- $v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right)$,\n- $a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}}$,\n所有参数如下所示。时间单位为秒，长度单位为米，速度单位为米/秒，加速度单位为米/秒^2，运动粘度单位为米^2/秒。安全系数是无量纲的。\n\n测试案例1（通用混合机制）：\n- $h = 0.01$ 米, $c = 5.0$ 米/秒, $\\nu = 1.0\\times 10^{-6}$ 米$^{2}$/秒,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.10$ 秒,\n- $v_{0} = 0.0$ 米/秒, $A_{v} = 3.0$ 米/秒, $\\tau_{v} = 0.02$ 秒,\n- $a_{0} = 0.0$ 米/秒$^{2}$, $A_{a} = 4000.0$ 米/秒$^{2}$, $\\tau_{a} = 0.015$ 秒.\n\n测试案例2（粘性限制且加速度为零）：\n- $h = 0.01$ 米, $c = 5.0$ 米/秒, $\\nu = 0.5$ 米$^{2}$/秒,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.05$ 秒,\n- $v_{0} = 0.0$ 米/秒, $A_{v} = 3.0$ 米/秒, $\\tau_{v} = 0.02$ 秒,\n- $a_{0} = 0.0$ 米/秒$^{2}$, $A_{a} = 0.0$ 米/秒$^{2}$, $\\tau_{a} = 0.01$ 秒.\n\n测试案例3（CFL限制且粘度为零）：\n- $h = 0.005$ 米, $c = 30.0$ 米/秒, $\\nu = 0.0$ 米$^{2}$/秒,\n- $C_{\\mathrm{CFL}} = 0.30$, $C_{\\mathrm{force}} = 0.30$, $C_{\\mathrm{visc}} = 0.30$,\n- $T_{\\mathrm{end}} = 0.010$ 秒,\n- $v_{0} = 0.0$ 米/秒, $A_{v} = 1.5$ 米/秒, $\\tau_{v} = 0.01$ 秒,\n- $a_{0} = 0.0$ 米/秒$^{2}$, $A_{a} = 5000.0$ 米/秒$^{2}$, $\\tau_{a} = 0.005$ 秒.\n\n程序要求：\n- 完全按照描述实现可变时间步长控制器。\n- 对每个测试案例，生成一个整数代码列表，指明从 $t=0$ 到 $t=T_{\\mathrm{end}}$ 的每次迭代中，是哪个界限限制了时间步长。\n- 您的程序应生成单行输出，其中包含所有三个测试案例的结果，格式为Python字面量形式的列表的列表，以逗号分隔，例如 $\\left[\\left[\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个限制器代码列表，用一对总方括号括起，并以逗号分隔，例如 $\\left[\\left[\\ell_{1,1}, \\ell_{1,2}, \\dots\\right], \\left[\\ell_{2,1}, \\ell_{2,2}, \\dots\\right], \\left[\\ell_{3,1}, \\ell_{3,2}, \\dots\\right]\\right]$，其中每个 $\\ell_{i,j}$ 是 $\\left\\{0,1,2\\right\\}$ 中的一个整数。", "solution": "所提出的问题是有效的。它在科学上基于偏微分方程数值方法（特别是光滑粒子流体动力学，SPH）的原理。该问题是适定的、客观的，并为实现一个确定性的时间步进算法提供了一套完整且一致的数据和指令。我们现在将进行推导和求解。\n\n目标是为显式SPH模拟构建一个可变时间步长控制器。每一步的时间增量 $\\Delta t$ 被选为从稳定性与准确性考量推导出的三个候选值中的最小值：库朗-弗里德里希斯-列维（CFL）条件、一个基于力的加速度限制和一个粘性扩散限制。\n\n让我们根据所提供的第一性原理推导这三个时间步长界限的表达式。SPH方法的特征空间分辨率由光滑长度 $h$ 给出。\n\n1.  **CFL（双曲型）时间步长, $\\Delta t_{\\mathrm{CFL}}$**\n第一条原理基于双曲型系统显式方法的稳定性。信息或物理信号以特征速度传播。为了保证稳定性，数值依赖域必须包含物理依赖域。在SPH背景下，这意味着在单个时间步长 $\\Delta t$ 内，信息传播的距离不应超过局部相互作用距离，该距离与光滑长度 $h$ 的量级相同。最大信号传播速度 $s(t)$ 由声速 $c$ 和最大粒子速度大小 $|v_{\\max}(t)|$ 之和给出。\n该条件表示为：\n$$ \\Delta t \\le C_{\\mathrm{CFL}} \\frac{h}{s(t)} $$\n其中 $C_{\\mathrm{CFL}}$ 是一个安全系数，通常小于 $1$。代入给定的 $s(t) = c + |v_{\\max}(t)|$ 表达式，我们从CFL条件中获得候选时间步长：\n$$ \\Delta t_{\\mathrm{CFL}}(t) = C_{\\mathrm{CFL}} \\frac{h}{c + |v_{\\max}(t)|} $$\n\n2.  **基于力（运动学）的时间步长, $\\Delta t_{\\mathrm{force}}$**\n第二条原理通过限制单个时间步长内粒子因加速度产生的位移来确保准确性。该原理指出，此位移应相对于空间分辨率 $h$ 保持较小。一个粒子在恒定加速度 $a_{\\max}(t)$ 作用下，经过时间 $\\Delta t$ 后的位移是 $\\frac{1}{2}a_{\\max}(t)(\\Delta t)^2$。将此原理形式化的标准SPH准则对时间步长进行如下限制：\n$$ \\frac{1}{2} a_{\\max}(t) (\\Delta t)^2 \\le \\alpha h $$\n其中 $a_{\\max}(t)$ 是系统中加速度的最大值，$\\alpha$ 是一个小的无量纲常数。对 $\\Delta t$ 进行整理得到 $\\Delta t \\le \\sqrt{2\\alpha h / a_{\\max}(t)}$。这通常写作以下形式：\n$$ \\Delta t \\le C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\n其中 $C_{\\mathrm{force}}$ 是一个用户定义的安全系数。我们将采用这一标准形式作为所述原理的直接实现。因此，基于力的时间步长为：\n$$ \\Delta t_{\\mathrm{force}}(t) = C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\n此表达式仅在 $a_{\\max}(t) > 0$ 时有效。如果 $a_{\\max}(t) = 0$，则没有需要限制的加速度，因此该条件对时间步长没有上限约束。在这种情况下，我们将 $\\Delta t_{\\mathrm{force}}$ 视为无穷大。\n\n3.  **粘性扩散时间步长, $\\Delta t_{\\mathrm{visc}}$**\n第三条原理来自对形如 $\\partial u/\\partial t = \\nu \\nabla^2 u$ 的抛物型扩散方程的显式数值格式的稳定性分析，其中 $\\nu$ 是运动粘度。对于一个简单的前向时间、中心空间（FTCS）离散化，其稳定性条件是 $\\Delta t \\le (\\Delta x)^2/(2\\nu)$。在SPH中，空间分辨率 $\\Delta x$ 被光滑长度 $h$ 替代。这种稳定性约束的一般形式是：\n$$ \\Delta t \\le C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\n其中 $C_{\\mathrm{visc}}$ 是一个安全系数，它考虑了常数前置因子（如 $1/2$）和粘性项的特定SPH离散化的其他细节。问题直接提供了这个系数。因此，粘性时间步长是：\n$$ \\Delta t_{\\mathrm{visc}} = C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\n请注意，如果 $\\nu$ 和 $h$ 是常数，则此时间步长也是常数。如果 $\\nu = 0$，则不存在粘性，此约束不适用。因此，在这种情况下，我们将 $\\Delta t_{\\mathrm{visc}}$ 视为无穷大。\n\n**时间积分算法**\n模拟从初始时间 $t=0$ 进行到最终时间 $T_{\\mathrm{end}}$。在每一步，从时间 $t$ 开始，算法如下：\n1.  使用指定的函数评估随时间变化的最大速度和加速度 $v_{\\max}(t)$ 和 $a_{\\max}(t)$：\n    $$ v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right) $$\n    $$ a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}} $$\n2.  计算三个候选时间步长：$\\Delta t_{\\mathrm{CFL}}(t)$、$\\Delta t_{\\mathrm{force}}(t)$ 和 $\\Delta t_{\\mathrm{visc}}$。\n3.  确定当前迭代的限制性时间步长：\n    $$ \\Delta t_{\\mathrm{chosen}} = \\min(\\Delta t_{\\mathrm{CFL}}, \\Delta t_{\\mathrm{force}}, \\Delta t_{\\mathrm{visc}}) $$\n4.  识别哪个条件是限制性条件。我们使用整数代码：$0$ 代表CFL，$1$ 代表力，$2$ 代表粘性。平局打破规则是按此指定顺序选择第一个。该代码被记录用于当前步骤。\n5.  推进模拟时间。时间增量 $\\Delta t_{\\mathrm{step}}$ 被设置为 $\\Delta t_{\\mathrm{chosen}}$。然而，为确保模拟精确在 $T_{\\mathrm{end}}$ 结束，如有必要，最后一步将被截断。也就是说，如果 $t + \\Delta t_{\\mathrm{chosen}} \\ge T_{\\mathrm{end}}$，当前步是最后一步，时间被推进到 $T_{\\mathrm{end}}$。否则，时间推进 $\\Delta t_{\\mathrm{chosen}}$：$t \\leftarrow t + \\Delta t_{\\mathrm{chosen}}$。只要 $t  T_{\\mathrm{end}}$，循环就继续。最后一步的限制器代码由未截断的 $\\Delta t_{\\mathrm{chosen}}$ 决定。\n\n对每个测试案例实施此程序，以生成一系列限制器代码。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a variable time-step controller for an explicit SPH simulation.\n    The controller uses CFL, force, and viscous stability criteria.\n    \"\"\"\n\n    def run_simulation(h, c, nu, C_cfl, C_force, C_visc, T_end, v0, Av, tau_v, a0, Aa, tau_a):\n        \"\"\"\n        Runs a single SPH time-stepping simulation for a given set of parameters.\n        \n        Returns a list of integer codes indicating the limiter at each step.\n        \"\"\"\n\n        # Define the time-dependent functions for maximum velocity and acceleration\n        def v_max_func(t):\n            # The problem statement defines v_max(t) which may not be a magnitude, but\n            # all test cases result in v_max(t) >= 0. The CFL condition uses |v_max(t)|.\n            if tau_v > 0:\n                return v0 + Av * (1.0 - np.exp(-t / tau_v))\n            return v0 + Av # Case for tau_v -> 0 or t -> inf\n\n        def a_max_func(t):\n            if tau_a > 0:\n                return a0 + Aa * np.exp(-t / tau_a)\n            return a0 # Case for tau_a -> 0 or t -> inf\n\n        t = 0.0\n        limiters = []\n\n        # The loop must continue as long as the current time is less than the end time.\n        while t  T_end:\n            # 1. Evaluate maximum velocity and acceleration at the current time t\n            current_v_max = v_max_func(t)\n            current_a_max = a_max_func(t)\n\n            # 2. Calculate the three candidate time steps\n            \n            # CFL (Hyperbolic) Condition\n            # s(t) = c + |v_max(t)|\n            # c > 0 is assumed, so s_t is always positive.\n            s_t = c + abs(current_v_max)\n            dt_cfl = C_cfl * h / s_t\n\n            # Force (Kinematic) Condition\n            if current_a_max > 0.0:\n                dt_force = C_force * np.sqrt(h / current_a_max)\n            else:\n                dt_force = np.inf\n\n            # Viscous Diffusion Condition\n            if nu > 0.0:\n                dt_visc = C_visc * h**2 / nu\n            else:\n                dt_visc = np.inf\n\n            # 3. Determine the limiting time step and its corresponding code\n            dt_candidates = [dt_cfl, dt_force, dt_visc]\n            \n            # np.argmin implements the required tie-breaking rule (first minimum is chosen)\n            limiter_code = int(np.argmin(dt_candidates))\n            dt_chosen = dt_candidates[limiter_code]\n            \n            # 4. Record the limiter code for the current step\n            limiters.append(limiter_code)\n\n            # 5. Advance the simulation time.\n            # Truncate the last step to ensure t does not exceed T_end.\n            if t + dt_chosen >= T_end:\n                t = T_end\n            else:\n                t += dt_chosen\n        \n        return limiters\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general mixed regime)\n        {'h': 0.01, 'c': 5.0, 'nu': 1.0e-6, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.10, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 4000.0, 'tau_a': 0.015},\n        # Case 2 (viscous-limited with zero acceleration)\n        {'h': 0.01, 'c': 5.0, 'nu': 0.5, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.05, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 0.0, 'tau_a': 0.01},\n        # Case 3 (CFL-limited with zero viscosity)\n        {'h': 0.005, 'c': 30.0, 'nu': 0.0, 'C_cfl': 0.30, 'C_force': 0.30, 'C_visc': 0.30, 'T_end': 0.010, 'v0': 0.0, 'Av': 1.5, 'tau_v': 0.01, 'a0': 0.0, 'Aa': 5000.0, 'tau_a': 0.005},\n    ]\n\n    results = []\n    for case in test_cases:\n        limiters = run_simulation(**case)\n        results.append(limiters)\n\n    # Format the output as a compact Python literal string for a list of lists.\n    # e.g., [[1,2,3],[4],[5,6]]\n    # This construction ensures no spaces are included, matching the example format style.\n    inner_lists_str = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2439517"}]}