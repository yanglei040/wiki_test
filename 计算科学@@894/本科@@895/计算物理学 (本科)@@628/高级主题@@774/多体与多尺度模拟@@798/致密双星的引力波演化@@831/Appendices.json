{"hands_on_practices": [{"introduction": "本节的第一个实践将带领你模拟双星系统旋近过程中的核心特征——频率“啁啾”（chirp）。你将从能量守恒的基本物理原理出发，推导出引力波频率 $f(t)$ 随时间演化的微分方程。这项练习的核心是运用经典的四阶龙格-库塔（RK4）方法对该方程进行数值求解，并探究数值仿真的一个关键问题：计算误差如何依赖于积分步长 $\\Delta t$ [@problem_id:2399139]。", "problem": "考虑一个等质量的致密双星系统，其在圆形轨道上运动并辐射引力波（GW）。您将使用牛顿轨道动力学和能量平衡，在四极近似下对此系统的旋进过程进行建模，并研究累积引力波相位的数值误差如何随固定的时间步长变化。您的程序必须实现一个固定步长积分器来演化该系统，将计算出的相位与使用极小步长计算的高精度参考值进行比较，并报告绝对相位误差与步长的函数关系。\n\n物理设置和基本依据：\n- 设系统成员的质量为 $m_1 = m_2 = 1.4 \\, M_\\odot$，其中 $M_\\odot$ 是太阳质量。\n- 使用国际单位制（SI）中的标准常数：$G = 6.67430 \\times 10^{-11} \\ \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$，$c = 2.99792458 \\times 10^{8} \\ \\mathrm{m \\, s^{-1}}$，以及 $M_\\odot = 1.98847 \\times 10^{30} \\ \\mathrm{kg}$。\n- 假设轨道为圆形，并使用牛顿引力，其中开普勒定律将轨道频率 $f_{\\mathrm{orb}}$ 和轨道间距 $r$ 联系起来：$(2\\pi f_{\\mathrm{orb}})^2 r^3 = G (m_1 + m_2)$。\n- 该双星系统的引力束缚能为 $E = - \\dfrac{G m_1 m_2}{2 r}$。\n- 对于圆形轨道双星，其引力波辐射光度（功率）的主导项为 $P_{\\mathrm{GW}} = \\dfrac{32}{5} \\dfrac{G^4}{c^5} \\dfrac{m_1^2 m_2^2 (m_1 + m_2)}{r^5}$。\n- 引力波频率是轨道频率的两倍，即 $f(t) = 2 f_{\\mathrm{orb}}(t)$，且引力波相位满足 $\\dfrac{d\\phi}{dt} = 2\\pi f(t)$。\n\n任务：\n1. 严格基于上述关系式和能量平衡定律 $\\dfrac{dE}{dt} = - P_{\\mathrm{GW}}$，推导出一个关于 $\\dfrac{df}{dt}$ 的显式演化方程，该方程仅用啁啾质量和瞬时引力波频率 $f(t)$ 表示。在没有推导的情况下，不得假设或引用任何现成结果。\n2. 使用经典的四阶龙格－库塔法，实现一个固定步长的常微分方程（ODE）求解器，用以积分 $(\\phi(t), f(t))$ 的耦合系统：\n   - 初始条件：$f(0) = f_0$ 和 $\\phi(0) = 0$，其中 $f_0 = 30 \\ \\mathrm{Hz}$。\n   - 积分至最终时间 $T_{\\mathrm{end}} = 40 \\ \\mathrm{s}$。\n   - 角度单位必须是弧度，频率单位是 $\\mathrm{Hz}$，时间单位是 $\\mathrm{s}$，质量单位是 $\\mathrm{kg}$。\n3. 使用相同的积分方案和一个非常小的固定步长 $\\,\\Delta t_{\\mathrm{ref}} = 10^{-3} \\ \\mathrm{s}$，计算在 $t = T_{\\mathrm{end}}$ 时的高精度参考相位 $\\phi_{\\mathrm{ref}}$。\n4. 对于每个给定的步长 $\\Delta t$，计算在 $t = T_{\\mathrm{end}}$ 时的绝对相位误差，其定义为 $|\\phi_{\\Delta t} - \\phi_{\\mathrm{ref}}|$，其中 $\\phi_{\\Delta t}$ 是使用步长 $\\Delta t$ 得到的相位。\n5. 您的实现必须在数值上是自洽的：如果 $T_{\\mathrm{end}}$ 不是 $\\Delta t$ 的整数倍，则最后一个 RK4 步长必须使用剩余的时间，以确保相位恰好在 $t = T_{\\mathrm{end}}$ 时刻被计算。\n\n测试套件：\n- 使用以下固定步长 $\\Delta t$（单位：秒）：$[0.5, 0.25, 0.1, 0.05, 0.025]$。\n- 对于上述每个 $\\Delta t$，以浮点数形式输出在 $t = T_{\\mathrm{end}}$ 时的绝对相位误差（单位：弧度），并四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，“[x1,x2,x3,x4,x5]”）。具体来说，请按照与上述五个 $\\Delta t$ 值相同的顺序列出五个四舍五入后的绝对相位误差。", "solution": "该问题陈述科学合理、定义明确且客观。它描述了计算天体物理学中的一个标准问题：使用后牛顿近似模拟致密双星系统的旋进阶段。所有物理定律、常数和初始条件均已提供，构成了一个完整且一致的初值问题。该任务涉及推导控制微分方程和分析积分方案的数值误差，是计算物理学中的一项基本练习。因此，该问题是有效的，并将提供一个解决方案。\n\n解决方案分三个阶段进行。首先，我们推导引力波频率的演化方程。其次，我们描述数值积分方案。第三，我们概述用于计算相位演化及其数值误差的实现方法。\n\n**1. 频率演化方程的推导**\n\n目标是推导出 $\\dfrac{df}{dt}$ 的表达式，该表达式用引力波频率 $f$ 和系统的啁啾质量 $\\mathcal{M}$ 来表示。我们从所提供的物理关系式开始。\n\n能量平衡定律指出，双星系统轨道能量 $E$ 的变化率等于引力波辐射功率 $P_{\\mathrm{GW}}$ 的负值：\n$$\n\\dfrac{dE}{dt} = -P_{\\mathrm{GW}}\n$$\n我们可以使用链式法则来求 $\\dfrac{df}{dt}$：\n$$\n\\dfrac{df}{dt} = \\dfrac{df}{dE} \\dfrac{dE}{dt} = -\\dfrac{df}{dE} P_{\\mathrm{GW}}\n$$\n为了继续推导，我们必须将 $E$ 和 $P_{\\mathrm{GW}}$ 都表示为 $f$ 的函数。这需要将轨道间距 $r$ 表示为 $f$ 的函数。\n\n根据圆形轨道的开普勒第三定律和关系式 $f = 2f_{\\mathrm{orb}}$，我们有：\n$$\n(2\\pi f_{\\mathrm{orb}})^2 r^3 = G(m_1 + m_2) \\implies \\left(2\\pi \\frac{f}{2}\\right)^2 r^3 = GM\n$$\n其中 $M = m_1 + m_2$ 是总质量。化简并求解 $r$ 可得：\n$$\nr = \\left( \\dfrac{GM}{(\\pi f)^2} \\right)^{1/3} = (GM)^{1/3}(\\pi f)^{-2/3}\n$$\n现在将这个 $r$ 的表达式代入能量 $E$ 和功率 $P_{\\mathrm{GW}}$ 的公式中。\n轨道能量为：\n$$\nE = -\\dfrac{G m_1 m_2}{2r} = -\\dfrac{G m_1 m_2}{2} (GM)^{-1/3} (\\pi f)^{2/3} = -\\dfrac{1}{2} G^{2/3} m_1 m_2 M^{-1/3} (\\pi f)^{2/3}\n$$\n引力波功率为：\n$$\nP_{\\mathrm{GW}} = \\dfrac{32}{5} \\dfrac{G^4}{c^5} \\dfrac{m_1^2 m_2^2 M}{r^5} = \\dfrac{32}{5} \\dfrac{G^4}{c^5} m_1^2 m_2^2 M \\left( (GM)^{1/3}(\\pi f)^{-2/3} \\right)^{-5}\n$$\n$$\nP_{\\mathrm{GW}} = \\dfrac{32}{5} \\dfrac{G^4}{c^5} m_1^2 m_2^2 M (GM)^{-5/3} (\\pi f)^{10/3} = \\dfrac{32}{5c^5} G^{7/3} (m_1 m_2)^2 M^{-2/3} (\\pi f)^{10/3}\n$$\n有了 $E(f)$ 和 $P_{\\mathrm{GW}}(f)$，我们现在可以计算 $\\dfrac{df}{dt}$。首先，我们计算 $E$ 对 $f$ 的导数：\n$$\n\\frac{dE}{df} = \\frac{d}{df} \\left( -\\dfrac{1}{2} G^{2/3} m_1 m_2 M^{-1/3} (\\pi f)^{2/3} \\right) = -\\frac{1}{3} G^{2/3} m_1 m_2 M^{-1/3} \\pi^{2/3} f^{-1/3}\n$$\n因此，$\\dfrac{df}{dE} = \\left(\\dfrac{dE}{df}\\right)^{-1} = -3 G^{-2/3} (m_1 m_2)^{-1} M^{1/3} \\pi^{-2/3} f^{1/3}$。\n现在，我们将所有部分组合起来：\n$$\n\\frac{df}{dt} = \\frac{df}{dE} \\frac{dE}{dt} = \\left( -3 G^{-2/3} (m_1 m_2)^{-1} M^{1/3} \\pi^{-2/3} f^{1/3} \\right) \\times \\left( - \\dfrac{32}{5c^5} G^{7/3} (m_1 m_2)^2 M^{-2/3} \\pi^{10/3} f^{10/3} \\right)\n$$\n化简各项：\n$$\n\\frac{df}{dt} = \\frac{96}{5c^5} (m_1 m_2) G^{5/3} M^{-1/3} \\pi^{8/3} f^{11/3}\n$$\n问题要求最终表达式用啁啾质量 $\\mathcal{M}$ 来表示，其定义为 $\\mathcal{M} = \\dfrac{(m_1 m_2)^{3/5}}{(m_1+m_2)^{1/5}}$。我们可以看到，$\\mathcal{M}^{5/3} = \\left(\\dfrac{(m_1 m_2)^{3/5}}{M^{1/5}}\\right)^{5/3} = \\dfrac{m_1 m_2}{M^{1/3}}$。这个质量组合恰好出现在我们的 $\\dfrac{df}{dt}$ 表达式中。\n将此代入，我们得到最终的演化方程：\n$$\n\\dfrac{df}{dt} = \\dfrac{96}{5 c^5} (G\\mathcal{M})^{5/3} \\pi^{8/3} f^{11/3}\n$$\n这个表达式是正确的标准结果，并且是严格地从问题给定的关系式推导出来的。\n\n**2. 数值方法和方程组**\n\n该双星系统的演化由关于状态向量 $\\mathbf{y}(t) = [\\phi(t), f(t)]^T$ 的一对耦合一阶常微分方程（ODE）描述。\n$$\n\\dfrac{d\\mathbf{y}}{dt} = \\begin{pmatrix} d\\phi/dt \\\\ df/dt \\end{pmatrix} = \\mathbf{F}(f) = \\begin{pmatrix} 2\\pi f \\\\ \\mathcal{K} f^{11/3} \\end{pmatrix}\n$$\n其中 $\\mathcal{K} = \\dfrac{96}{5 c^5} (G\\mathcal{M})^{5/3} \\pi^{8/3}$ 是一个常数。该系统是自治的，因为导数仅依赖于状态变量，而不显式地依赖于时间 $t$。初始条件为 $\\mathbf{y}(0) = [0, f_0]^T$。\n\n为了数值求解这个系统，我们采用经典的四阶龙格－库塔（RK4）方法。给定在时间 $t_n$ 的状态 $\\mathbf{y}_n$，在时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $\\mathbf{y}_{n+1}$ 按如下方式计算：\n$$\n\\begin{align*}\n\\mathbf{k}_1 &= \\mathbf{F}(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 &= \\mathbf{F}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= \\mathbf{F}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= \\mathbf{F}(\\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{align*}\n请注意，对于我们的系统，导数仅依赖于 $f$，而不依赖于 $\\phi$。\n\n**3. 实现策略**\n\n实现过程遵循一个清晰的程序，以满足问题的要求。\n1.  **常数和参数**：所有物理常数（$G, c, M_\\odot$）和问题参数（$m_1, m_2, f_0, T_{\\mathrm{end}}$）都在国际单位制（SI）中定义。啁啾质量 $\\mathcal{M}$ 由 $m_1$ 和 $m_2$ 计算得出，$df/dt$ 方程中的常数因子 $\\mathcal{K}$ 被预先计算。\n2.  **ODE 求解器**：一个函数实现 RK4 积分循环。它将初始条件和步长 $\\Delta t$ 作为输入。循环从 $t=0$ 运行到 $t=T_{\\mathrm{end}}$。按照规定，为确保积分恰好在 $T_{\\mathrm{end}}$ 终止，最后一个步长使用 `h = min(Δt, T_end - t)` 进行调整。\n3.  **参考解**：通过使用一个非常小的时间步长 $\\Delta t_{\\mathrm{ref}} = 10^{-3} \\ \\mathrm{s}$ 运行积分器，计算出高精度的参考相位 $\\phi_{\\mathrm{ref}}$。\n4.  **误差计算**：程序遍历指定的测试步长 $\\Delta t$ 列表。对于每个 $\\Delta t$，它运行积分器以找到最终相位 $\\phi_{\\Delta t}$。然后计算绝对误差 $|\\phi_{\\Delta t} - \\phi_{\\mathrm{ref}}|$。\n5.  **输出**：将计算出的误差收集到一个列表中，四舍五入到六位小数，并以指定格式打印。已知 RK4 方法的全局截断误差为 $O((\\Delta t)^4)$ 阶。我们预期计算出的相位误差也将按此比例缩放。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave inspiral problem, calculates phase errors\n    for different step sizes, and prints the results.\n    \"\"\"\n    # Physical constants in SI units\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    c = 2.99792458e8   # m s^-1\n    M_SUN = 1.98847e30 # kg\n\n    # Problem parameters\n    m1_msun = 1.4\n    m2_msun = 1.4\n    f0 = 30.0  # Hz\n    T_end = 40.0 # s\n    phi0 = 0.0 # rad\n\n    # Test suite and reference step size\n    dt_steps = [0.5, 0.25, 0.1, 0.05, 0.025] # s\n    dt_ref = 1e-3 # s\n\n    # --- Derived physical quantities ---\n    m1 = m1_msun * M_SUN\n    m2 = m2_msun * M_SUN\n    \n    # In the equal mass case m1=m2=m, M=2m, mu=m/2\n    # The chirp mass M_chirp = (m1*m2)^(3/5) / (m1+m2)^(1/5)\n    # simplifies to m / (2^(1/5))\n    m = m1 \n    chirp_mass = m / (2.0**(1.0/5.0))\n\n    # Pre-calculate the constant factor in the df/dt equation\n    # df/dt = K * f^(11/3)\n    K_FACTOR = (96.0 / 5.0) * (np.pi**(8.0/3.0) / c**5) * ((G * chirp_mass)**(5.0/3.0))\n\n    def derivatives(y):\n        \"\"\"\n        Computes the derivatives [d(phi)/dt, df/dt] for the ODE system.\n        y is a numpy array [phi, f].\n        \"\"\"\n        phi, f = y\n        dphi_dt = 2.0 * np.pi * f\n        df_dt = K_FACTOR * f**(11.0 / 3.0)\n        return np.array([dphi_dt, df_dt])\n\n    def integrate_inspiral(f_initial, phi_initial, t_final, dt):\n        \"\"\"\n        Integrates the ODE system using the RK4 method.\n        \n        Args:\n            f_initial (float): Initial GW frequency in Hz.\n            phi_initial (float): Initial GW phase in radians.\n            t_final (float): Final integration time in seconds.\n            dt (float): Fixed time step for integration.\n\n        Returns:\n            float: The final accumulated GW phase in radians.\n        \"\"\"\n        t = 0.0\n        y = np.array([phi_initial, f_initial])\n\n        while t < t_final:\n            # Ensure the last step ends exactly at t_final\n            h = min(dt, t_final - t)\n            \n            # Classical 4th-order Runge-Kutta step\n            k1 = derivatives(y)\n            k2 = derivatives(y + 0.5 * h * k1)\n            k3 = derivatives(y + 0.5 * h * k2)\n            k4 = derivatives(y + h * k3)\n            \n            y += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += h\n            \n        return y[0] # Return the final phase phi\n\n    # 1. Compute the high-accuracy reference phase\n    phi_ref = integrate_inspiral(f0, phi0, T_end, dt_ref)\n\n    # 2. Compute phase for each step size and calculate error\n    errors = []\n    for dt in dt_steps:\n        phi_dt = integrate_inspiral(f0, phi0, T_end, dt)\n        error = abs(phi_dt - phi_ref)\n        errors.append(round(error, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, errors))}]\")\n\n\nsolve()\n```", "id": "2399139"}, {"introduction": "在掌握了如何模拟轨道演化之后，我们将更进一步，将抽象的轨道参数与实际可观测的引力波信号联系起来。在此练习中，你将利用已仿真的轨道数据，构建源的四极矩，并由此计算出探测器所能接收到的引力波应变 $h(t)$。最终，你将通过数值方法验证一个基本但至关重要的物理事实：引力波的频率是轨道频率的两倍，即 $f_{\\text{GW}} = 2f_{\\text{orb}}$ [@problem_id:2399179]。", "problem": "一个圆形的、无自旋的致密双星系统可以在牛顿极限和引力辐射的前导阶四极矩近似下进行建模。您将从第一性原理出发，构建一个数值实验，该实验能够生成准圆形旋进过程的引力波应变，提取其瞬时频率，并将其与轨道频率进行比较，以验证其倍频特性。目标是在构建过程中不预先假设引力波频率是轨道频率两倍这一关系，而是在数值容差范围内，通过数值方法验证在整个演化过程中，引力波频率始终是轨道频率的两倍。\n\n使用的基本原理：\n- 点质量的牛顿二体动力学：一个由质量为 $m_1$ 和 $m_2$ 的两个天体组成的双星系统，其总质量为 $M = m_1 + m_2$，折合质量为 $\\mu = \\dfrac{m_1 m_2}{M}$。对于一个瞬时圆形轨道，若其间距为 $a(t)$，则轨道角频率为 $\\omega(t) = \\sqrt{\\dfrac{G M}{a(t)^3}}$，轨道相位演化遵循 $\\dfrac{d\\phi}{dt} = \\omega(t)$。\n- 圆形旋进的能量平衡（Peters 公式）的前导四极阶：由于引力波的发射，双星轨道根据以下公式收缩\n$$\n\\frac{da}{dt} = - \\frac{64}{5} \\frac{G^3}{c^5} \\frac{\\mu M^2}{a^3}.\n$$\n- 远场中的四极辐射与横向无迹（TT）规范：无迹质量四极矩张量为\n$$\nI_{ij}(t) = \\sum_A m_A \\left(x_A^i x_A^j - \\frac{1}{3}\\delta_{ij}\\, \\mathbf{x}_A^2\\right),\n$$\n在质心系中，该公式简化为 $I_{ij}(t) = \\mu \\left(r_i r_j - \\dfrac{1}{3}\\delta_{ij} r^2\\right)$，其中 $\\mathbf{r} = \\mathbf{x}_1 - \\mathbf{x}_2$。在光度距离为 $D$ 处，TT 规范下的引力波度规微扰为\n$$\nh_{ij}^{\\mathrm{TT}}(t) = \\frac{2 G}{c^4 D} \\frac{d^2 I_{ij}^{\\mathrm{TT}}(t)}{dt^2}.\n$$\n对于一个沿单位视线方向 $\\hat{\\mathbf{n}}$ 的观测者，定义标准正交偏振基矢 $\\hat{\\mathbf{p}}$ 和 $\\hat{\\mathbf{q}}$，使得 $\\{\\hat{\\mathbf{p}}, \\hat{\\mathbf{q}}, \\hat{\\mathbf{n}}\\}$ 构成右手系，且满足 $\\hat{\\mathbf{p}} \\cdot \\hat{\\mathbf{n}} = 0$ 和 $\\hat{\\mathbf{q}} \\cdot \\hat{\\mathbf{n}} = 0$。然后，通过投影到 $e_+^{ij} = p^i p^j - q^i q^j$ 上，可获得加号偏振：\n$$\nh_{+}(t) = \\frac{2 G}{c^4 D}\\, e_+^{ij}\\, \\frac{d^2 I_{ij}(t)}{dt^2}.\n$$\n\n任务：\n- 实现一个程序，该程序：\n  1. 通过在均匀时间网格上使用固定的时间步长 $\\,\\Delta t\\,$ 和四阶 Runge–Kutta 方法积分以下耦合系统，来演化双星系统的准圆形旋进过程\n     $$\n     \\frac{d\\phi}{dt} = \\sqrt{\\frac{G M}{a^3}},\\quad\n     \\frac{da}{dt} = - \\frac{64}{5} \\frac{G^3}{c^5} \\frac{\\mu M^2}{a^3}\n     $$\n  2. 根据质心系中的相对位置 $\\mathbf{r}(t) = a(t)[\\cos\\phi(t), \\sin\\phi(t), 0]$ 构建无迹质量四极矩 $I_{ij}(t)$。\n  3. 在均匀网格上使用中心差分格式，数值计算二阶时间导数 $\\,\\dfrac{d^2 I_{ij}}{dt^2}\\,$。\n  4. 通过相对于轨道角动量（$z$ 轴）的倾角 $\\iota$ 和方位角 $0$ 来定义观测者方向，即 $\\hat{\\mathbf{n}} = (\\sin\\iota, 0, \\cos\\iota)$，并使用 $\\hat{\\mathbf{p}} = (\\cos\\iota, 0, -\\sin\\iota)$ 和 $\\hat{\\mathbf{q}} = (0, 1, 0)$ 来构建 $e_+^{ij}$。\n  5. 通过将 $e_+^{ij}$ 与 $\\,\\dfrac{d^2 I_{ij}}{dt^2}\\,$ 进行缩并，并乘以因子 $\\,\\dfrac{2G}{c^4 D}\\,$，来形成 $h_{+}(t)$。\n  6. 通过希尔伯特变换计算解析信号，对其相位 $\\psi(t)$ 进行解缠，然后求导，从 $h_{+}(t)$ 中提取瞬时引力波频率 $f_{\\mathrm{GW}}(t)$：$f_{\\mathrm{GW}}(t) = \\dfrac{1}{2\\pi} \\dfrac{d\\psi}{dt}$。\n  7. 在相同的时间网格上（与二阶导数格式对齐）计算轨道频率 $f_{\\mathrm{orb}}(t) = \\dfrac{1}{2\\pi} \\sqrt{\\dfrac{G M}{a(t)^3}}$。\n  8. 计算比值 $R(t) = \\dfrac{f_{\\mathrm{GW}}(t)}{f_{\\mathrm{orb}}(t)}$，并对每个测试案例报告一个单一的总结性数值，该数值等于 $R(t)$ 在时间序列中心部分的（舍弃最初和最后 10% 的样本以避免微分和希尔伯特变换的边界效应）中位数。为进一步提高稳健性，排除解析信号包络振幅 $A(t)$ 满足 $A(t) < \\alpha A_{\\max}$（其中 $\\alpha = 0.05$）的点。\n\n数值细节和单位：\n- 所有物理量均使用国际单位制：质量单位为千克，间距单位为米，时间单位为秒，角度单位为弧度，距离单位为米。\n- 对每个测试案例，设置均匀样本数为 $N = 8192$，并选择时间步长为 $\\Delta t = \\dfrac{1}{256 f_{\\mathrm{orb},0}}$，其中 $f_{\\mathrm{orb},0}$ 是根据初始间距 $a_0$ 计算的初始轨道频率。\n- 最终答案是无单位浮点数（无量纲比值）。\n\n测试套件：\n- 案例 1：$m_1 = 1.4\\,M_\\odot$, $m_2 = 1.4\\,M_\\odot$, $a_0 = 5.0\\times 10^7\\,\\mathrm{m}$, $\\iota = 0.0\\,\\mathrm{rad}$, $D = 1.0\\times 10^{23}\\,\\mathrm{m}$。\n- 案例 2：$m_1 = 30\\,M_\\odot$, $m_2 = 10\\,M_\\odot$, $a_0 = 2.0\\times 10^8\\,\\mathrm{m}$, $\\iota = \\pi/3\\,\\mathrm{rad}$, $D = 1.0\\times 10^{23}\\,\\mathrm{m}$。\n- 案例 3：$m_1 = 1.4\\,M_\\odot$, $m_2 = 10\\,M_\\odot$, $a_0 = 1.0\\times 10^8\\,\\mathrm{m}$, $\\iota = \\pi/2\\,\\mathrm{rad}$, $D = 1.0\\times 10^{23}\\,\\mathrm{m}$。\n\n要求的输出：\n- 您的程序应产生单行输出，其中包含三个测试案例的结果，格式为一个包含在方括号中的、由逗号分隔的浮点数列表，例如 `\"[r_1,r_2,r_3]\"`，其中每个 $r_i$ 是对应测试案例的 $R(t)$ 的中位数。请以标准十进制表示法报告浮点数。期望值应接近整数 2。\n\n角度单位：\n- 所有角度必须以弧度为单位。\n\n物理单位规格：\n- 所有量均以国际单位制计算，最终输出为无量纲值。\n\n不应读取用户输入；所有参数必须严格按照上述规定在代码中定义。", "solution": "该问题陈述经过严格验证，并被认定是有效的。其科学基础植根于牛顿力学原理以及由广义相对论描述的致密双星系统的引力辐射的前导阶近似。该问题是适定的，为获得唯一且有意义的解所需的一套完整且一致的微分方程、数值参数和程序步骤均已提供。该任务是计算天体物理学中的一个标准数值实验。\n\n问题的核心是数值验证“双星系统发射的引力波频率是其轨道频率的两倍”这一理论预测。这将通过从第一性原理出发构建解来实现，而无需预先假设此关系。\n\n双星系统的演化由两个耦合的一阶常微分方程（ODE）建模。第一个方程描述轨道相位 $\\phi(t)$ 的变化，由轨道角频率 $\\omega(t)$ 驱动：\n$$\n\\frac{d\\phi}{dt} = \\omega(t) = \\sqrt{\\frac{G M}{a(t)^3}}\n$$\n其中 $G$ 是引力常数，$M = m_1 + m_2$ 是双星系统的总质量，$a(t)$ 是瞬时轨道间距。第二个 ODE 描述了由于引力波发射导致的轨道间距衰减。在前导（四极）阶，这由 Peters 公式给出：\n$$\n\\frac{da}{dt} = - \\frac{64}{5} \\frac{G^3}{c^5} \\frac{\\mu M^2}{a^3}\n$$\n其中 $\\mu = \\frac{m_1 m_2}{M}$ 是折合质量，$c$ 是光速。此 ODE 系统定义了一个准圆形旋进过程。我们使用四阶龙格-库塔（RK4）方法和固定的时间步长 $\\Delta t$ 对该系统进行数值积分，以获得轨道状态的时间序列 $(a(t), \\phi(t))$。\n\n根据轨道轨迹，我们构建引力波形。在轨道平面（$z=0$）内的相对位置矢量为 $\\mathbf{r}(t) = (a(t)\\cos\\phi(t), a(t)\\sin\\phi(t), 0)$。在此阶数下，引力辐射的源是时变的质量四极矩。质心系中的无迹质量四极矩张量由下式给出：\n$$\nI_{ij}(t) = \\mu \\left( r_i(t) r_j(t) - \\frac{1}{3}\\delta_{ij} r(t)^2 \\right)\n$$\n其中 $r_i$ 是 $\\mathbf{r}$ 的分量，$r^2 = a^2$。横向无迹（TT）规范下的引力波应变张量与四极矩张量的二阶时间导数成正比。对于位于光度距离 $D$ 处的观测者，应变为：\n$$\nh_{ij}^{\\mathrm{TT}}(t) = \\frac{2 G}{c^4 D} \\frac{d^2 I_{ij}^{\\mathrm{TT}}(t)}{dt^2}\n$$\n我们使用二阶中心差分格式，从时间序列 $I_{ij}(t)$ 数值计算二阶时间导数 $\\ddot{I}_{ij}(t)$：\n$$\n\\frac{d^2 f(t)}{dt^2} \\approx \\frac{f(t+\\Delta t) - 2f(t) + f(t-\\Delta t)}{(\\Delta t)^2}\n$$\n可观测的波形取决于观测者的视线 $\\hat{\\mathbf{n}}$ 和所选的偏振基 $\\{\\hat{\\mathbf{p}}, \\hat{\\mathbf{q}}\\}$。问题指定了 $\\hat{\\mathbf n} = (\\sin\\iota, 0, \\cos\\iota)$、$\\hat{\\mathbf p} = (\\cos\\iota, 0, -\\sin\\iota)$ 和 $\\hat{\\mathbf q} = (0, 1, 0)$，其中 $\\iota$ 是倾角。加号偏振应变 $h_+(t)$ 是通过将 $\\ddot{I}_{ij}(t)$ 投影到偏振张量 $e_+^{ij} = p^i p^j - q^i q^j$ 上得到的：\n$$\nh_{+}(t) = \\frac{2 G}{c^4 D} e_+^{ij} \\ddot{I}_{ij}(t)\n$$\n\n为了从合成的波形 $h_+(t)$ 中提取瞬时引力波频率 $f_{\\mathrm{GW}}(t)$，我们使用解析信号的概念。解析信号 $z(t)$ 是一个复数时间序列，其实部是原始信号，虚部是原始信号的希尔伯特变换 $\\mathcal{H}[h_+](t)$：\n$$\nz(t) = h_+(t) + i \\mathcal{H}[h_+](t) = A(t) e^{i\\psi(t)}\n$$\n波的瞬时相位是 $\\psi(t)$，它由 $z(t)$ 的辐角得到，并通过解缠算法使其连续。瞬时角频率则是该相位的随时间导数，$\\omega_{\\mathrm{GW}}(t) = d\\psi(t)/dt$，我们使用另一个中心差分格式进行数值计算。所需频率为 $f_{\\mathrm{GW}}(t) = \\omega_{\\mathrm{GW}}(t) / (2\\pi)$。\n\n最后，我们进行验证。我们直接从演化出的间距 $a(t)$ 计算理论轨道频率：\n$$\nf_{\\mathrm{orb}}(t) = \\frac{1}{2\\pi} \\sqrt{\\frac{G M}{a(t)^3}}\n$$\n然后在公共时间网格上计算比值 $R(t) = f_{\\mathrm{GW}}(t) / f_{\\mathrm{orb}}(t)$。为确保结果的稳健性，我们舍弃最初和最后 10% 的样本，以减轻数值微分和希尔伯特变换带来的边界效应。此外，我们应用一个振幅过滤器，排除波形包络 $A(t)$ 小于其最大值 5% 的点，因为低振幅区域的相位可能难以精确确定。对每个测试案例，报告最终滤波后比值的中位数。这个中位数预期会非常接近 2。", "answer": "```python\nimport numpy as np\nfrom scipy import signal\nfrom scipy.constants import G, c\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave evolution problem for three test cases.\n    \"\"\"\n    \n    # Physical constants\n    M_SOLAR = 1.98847e30  # Solar mass in kg\n\n    # Numerical parameters\n    N_SAMPLES = 8192\n    SAMPLING_FACTOR = 256.0\n    \n    # Test cases\n    test_cases = [\n        {\n            \"m1_solar\": 1.4, \"m2_solar\": 1.4, \"a0\": 5.0e7,\n            \"iota\": 0.0, \"D\": 1.0e23,\n        },\n        {\n            \"m1_solar\": 30.0, \"m2_solar\": 10.0, \"a0\": 2.0e8,\n            \"iota\": np.pi / 3, \"D\": 1.0e23,\n        },\n        {\n            \"m1_solar\": 1.4, \"m2_solar\": 10.0, \"a0\": 1.0e8,\n            \"iota\": np.pi / 2, \"D\": 1.0e23,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters and convert to SI units\n        m1 = case[\"m1_solar\"] * M_SOLAR\n        m2 = case[\"m2_solar\"] * M_SOLAR\n        a0 = case[\"a0\"]\n        iota = case[\"iota\"]\n        dist = case[\"D\"]\n\n        # Derived masses\n        M = m1 + m2\n        mu = (m1 * m2) / M\n\n        # Initial conditions and time grid\n        f_orb_0 = (1 / (2 * np.pi)) * np.sqrt(G * M / a0**3)\n        dt = 1 / (SAMPLING_FACTOR * f_orb_0)\n        time_grid = np.linspace(0, (N_SAMPLES - 1) * dt, N_SAMPLES)\n\n        # Arrays to store evolution\n        a_t = np.zeros(N_SAMPLES)\n        phi_t = np.zeros(N_SAMPLES)\n        a_t[0] = a0\n        phi_t[0] = 0.0\n\n        # ODE system coefficients\n        Ca = (64/5) * (G**3 / c**5) * mu * M**2\n        Cphi = np.sqrt(G * M)\n\n        # ODE functions\n        def f_a(a_val):\n            return -Ca * a_val**-3\n\n        def f_phi(a_val):\n            return Cphi * a_val**-1.5\n\n        # RK4 integration\n        for i in range(N_SAMPLES - 1):\n            a_i, phi_i = a_t[i], phi_t[i]\n            \n            k1a = f_a(a_i)\n            k1phi = f_phi(a_i)\n\n            k2a = f_a(a_i + 0.5 * dt * k1a)\n            k2phi = f_phi(a_i + 0.5 * dt * k1a)\n\n            k3a = f_a(a_i + 0.5 * dt * k2a)\n            k3phi = f_phi(a_i + 0.5 * dt * k2a)\n            \n            k4a = f_a(a_i + dt * k3a)\n            k4phi = f_phi(a_i + dt * k3a)\n\n            a_t[i+1] = a_i + (dt/6.0) * (k1a + 2*k2a + 2*k3a + k4a)\n            phi_t[i+1] = phi_i + (dt/6.0) * (k1phi + 2*k2phi + 2*k3phi + k4phi)\n\n        # Construct Quadrupole Tensor I_ij\n        x = a_t * np.cos(phi_t)\n        y = a_t * np.sin(phi_t)\n        r_sq = a_t**2\n        \n        I11 = mu * (x**2 - r_sq / 3.0)\n        I22 = mu * (y**2 - r_sq / 3.0)\n        I33 = mu * (-r_sq / 3.0)\n        I12 = mu * x * y\n        I13 = np.zeros_like(a_t)\n        I23 = np.zeros_like(a_t)\n        \n        # Second time derivative via finite difference\n        # Stencil: (f[t+dt] - 2f[t] + f[t-dt]) / dt^2\n        # This reduces array length by 2\n        ddot_I11 = (I11[2:] - 2 * I11[1:-1] + I11[:-2]) / dt**2\n        ddot_I22 = (I22[2:] - 2 * I22[1:-1] + I22[:-2]) / dt**2\n        ddot_I33 = (I33[2:] - 2 * I33[1:-1] + I33[:-2]) / dt**2\n        ddot_I12 = (I12[2:] - 2 * I12[1:-1] + I12[:-2]) / dt**2\n\n        # Polarization tensor e_plus_ij\n        cos_i, sin_i = np.cos(iota), np.sin(iota)\n        e_plus = np.zeros((3, 3))\n        e_plus[0, 0] = cos_i**2\n        e_plus[1, 1] = -1.0\n        e_plus[2, 2] = sin_i**2\n        \n        # Construct h_plus(t)\n        h_plus_t = (2 * G / (c**4 * dist)) * (\n            e_plus[0, 0] * ddot_I11 +\n            e_plus[1, 1] * ddot_I22 +\n            e_plus[2, 2] * ddot_I33\n            # Symmetries in I_ij and e_plus mean we only need these terms\n        )\n\n        # Extract instantaneous frequency f_GW\n        analytic_signal = signal.hilbert(h_plus_t)\n        amplitude_gw = np.abs(analytic_signal)\n        phase_gw = np.unwrap(np.angle(analytic_signal))\n        \n        # Differentiate phase via finite difference: (psi[t+dt]-psi[t-dt])/(2*dt)\n        # This reduces array length by 2\n        omega_gw_t = (phase_gw[2:] - phase_gw[:-2]) / (2 * dt)\n        f_gw_t = omega_gw_t / (2 * np.pi)\n\n        # Align orbital frequency array\n        # f_gw_t corresponds to original time grid [2:-2]\n        a_t_aligned = a_t[2:-2]\n        f_orb_t = (1 / (2 * np.pi)) * np.sqrt(G * M / a_t_aligned**3)\n        \n        # Form ratio R(t)\n        ratio_t = f_gw_t / f_orb_t\n        \n        # Process the ratio: trim boundaries and filter by amplitude\n        num_pts = len(ratio_t)\n        start_idx = int(0.1 * num_pts)\n        end_idx = num_pts - start_idx\n        \n        ratio_slice = ratio_t[start_idx:end_idx]\n        \n        # Align amplitude for filtering\n        # amplitude_gw corresponds to time grid [1:-1]\n        # ratio_t corresponds to time grid [2:-2]\n        # So, align amplitude_gw by taking its [1:-1] slice\n        amplitude_aligned = amplitude_gw[1:-1]\n        amplitude_slice = amplitude_aligned[start_idx:end_idx]\n        \n        amplitude_max = np.max(amplitude_gw)\n        \n        # Apply amplitude filter\n        mask = amplitude_slice >= 0.05 * amplitude_max\n        \n        filtered_ratio = ratio_slice[mask]\n        \n        if len(filtered_ratio) > 0:\n            median_ratio = np.median(filtered_ratio)\n        else: # Should not happen with these parameters\n            median_ratio = np.nan\n            \n        results.append(median_ratio)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399179"}, {"introduction": "真实的引力波信号比主导模式要复杂，它包含了能揭示更多物理细节的“高次谐波”。为了研究这些微弱的信号成分，我们需要先从数据中精确地“滤除”掉强大的主导模式。本练习将指导你构建一个包含多种模式的合成信号，并应用最小二乘法设计一个滤波器，以提取出主导模式之外的残余信号，这正是引力波数据分析中的一项核心技能 [@problem_id:2399144]。", "problem": "您的任务是构建并应用一个数学上明确定义的引力波滤波器，从一个合成的致密双星旋近（inspiral）应变时间序列中移除主导的球谐模，以研究仅包含次主导高阶模的残差。\n\n您将在时域中将旋近引力波应变建模为多个模式的总和。主导模式是 $(l,m)=(2,2)$ 模，其瞬时引力波频率为 $f_{22}(t)$，相位为 $\\Phi_{22}(t)$。次主导模式的瞬时相位根据其 $m$ 值被视为主导 $(2,2)$ 相位的整数比，即，对于模式 $(3,3)$ 使用 $\\Phi_{33}(t) = \\tfrac{3}{2}\\,\\Phi_{22}(t) + \\delta_{33}$，对于模式 $(2,1)$ 使用 $\\Phi_{21}(t) = \\tfrac{1}{2}\\,\\Phi_{22}(t) + \\delta_{21}$。总的探测器应变被建模为这些模式的线性叠加，具有旋近过程的前导阶振幅和固定的相对模式权重：\n$$\ns(t) \\;=\\; h_{22}(t) \\;+\\; h_{33}(t) \\;+\\; h_{21}(t),\n$$\n其中\n$$\nh_{22}(t) \\;=\\; A_{22}(t)\\,\\cos\\!\\big(\\Phi_{22}(t)\\big), \\quad\nh_{33}(t) \\;=\\; r_{33}\\,A_{22}(t)\\,\\cos\\!\\big(\\Phi_{33}(t)\\big), \\quad\nh_{21}(t) \\;=\\; r_{21}\\,A_{22}(t)\\,\\cos\\!\\big(\\Phi_{21}(t)\\big).\n$$\n\n在旋近阶段，主导模式的振幅 $A_{22}(t)$ 和主导模式的频率 $f_{22}(t)$ 在前导阶由以下公式给出\n$$\nA_{22}(t) \\;=\\; \\frac{\\big(4\\,G\\,\\mathcal{M}/c^2\\big)^{5/3}\\,\\big(\\pi\\,f_{22}(t)\\big)^{2/3}}{D},\n$$\n$$\n\\frac{\\mathrm{d} f_{22}}{\\mathrm{d} t} \\;=\\; \\frac{96}{5}\\,\\pi^{8/3}\\,\\left(\\frac{G\\,\\mathcal{M}}{c^3}\\right)^{5/3} f_{22}^{11/3}(t),\n$$\n主导模式的相位遵循\n$$\n\\frac{\\mathrm{d}\\Phi_{22}}{\\mathrm{d}t} \\;=\\; 2\\pi\\,f_{22}(t), \\qquad \\Phi_{22}(t_0) = 0.\n$$\n这里 $G$ 是引力常数，$c$ 是光速，$\\mathcal{M}$ 是啁啾质量，定义为\n$$\n\\mathcal{M} \\;=\\; \\frac{(m_1 m_2)^{3/5}}{(m_1 + m_2)^{1/5}}.\n$$\n源的距离为 $D$。所有物理常数和参数必须使用国际单位制（SI）。使用 $G = 6.67430\\times 10^{-11}$，$c = 2.99792458\\times 10^{8}$，太阳质量 $M_{\\odot} = 1.98847\\times 10^{30}$，以及 $1\\,\\mathrm{Mpc} = 3.085677581491367\\times 10^{22}\\,\\mathrm{m}$。质量 $m_1$ 和 $m_2$ 以 $M_{\\odot}$ 为单位指定，必须转换为千克。距离以百万秒差距为单位指定，必须转换为米。频率单位为赫兹，时间单位为秒，相位单位为弧度。\n\n通过从给定的初始主导模式频率 $f_{22}(t_0)=f_0$ 到给定的终止频率 $f_{1}$ 进行数值积分，在采样率（单位：赫兹）为 $f_s$ 的均匀时间网格上构建时间序列。均匀时间步长为 $\\Delta t = 1/f_s$。瞬时主导模式频率 $f_{22}(t)$ 使用上述常微分方程进行演化。相位 $\\Phi_{22}(t)$ 通过对其时间导数积分获得。次主导模式的相位 $\\Phi_{33}(t)$ 和 $\\Phi_{21}(t)$ 根据 $\\Phi_{22}(t)$ 构建，如前所述，具有固定的偏移量 $\\delta_{33}$ 和 $\\delta_{21}$（单位：弧度）。\n\n按如下方式定义主导模式移除滤波器。考虑双参数波形族\n$$\n\\hat{h}_{22}(t; S,\\varphi) \\;=\\; S\\,A_{22}(t)\\,\\cos\\!\\big(\\Phi_{22}(t) + \\varphi\\big),\n$$\n其中 $S$ 和 $\\varphi$ 是实数参数。选择使离散时间最小二乘误差最小的 $S^\\star$ 和 $\\varphi^\\star$\n$$\nE(S,\\varphi) \\;=\\; \\sum_{n=0}^{N-1} \\Big(s(t_n) - \\hat{h}_{22}(t_n; S,\\varphi)\\Big)^2,\n$$\n其中 $t_n = t_0 + n\\,\\Delta t$，$N$ 是在 $f_{22}(t)$ 首次达到 $f_1$ 之前累积的总样本数。定义残差\n$$\nr(t) \\;=\\; s(t) \\;-\\; \\hat{h}_{22}(t; S^\\star,\\varphi^\\star).\n$$\n\n对于每个测试用例，计算比率\n$$\nR \\;=\\; \\frac{\\mathrm{RMS}\\big(r(t)\\big)}{\\mathrm{RMS}\\big(s(t)\\big)},\n$$\n其中对于具有 $N$ 个样本的离散时间序列 $x(t_n)$，\n$$\n\\mathrm{RMS}(x) \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} x^2(t_n)}.\n$$\n将 $R$ 报告为一个浮点数，四舍五入到六位小数（无单位）。\n\n使用采样率 $f_s = 4096$。\n\n实现您的程序，为以下三个测试用例计算 $R$ （所有距离 $D$ 以百万秒差距为单位，所有质量以 $M_{\\odot}$ 为单位，所有相位偏移以弧度为单位）：\n\n- 测试用例1（一般情况）：$m_1 = 30$, $m_2 = 30$, $D = 500$, $f_0 = 30$, $f_1 = 150$, $r_{33} = 0.2$, $r_{21} = 0.1$, $\\delta_{33} = 0.3$, $\\delta_{21} = -0.5$。\n- 测试用例2（不等质量，更强的高阶模）：$m_1 = 35$, $m_2 = 20$, $D = 300$, $f_0 = 25$, $f_1 = 200$, $r_{33} = 0.35$, $r_{21} = 0.15$, $\\delta_{33} = 0.1$, $\\delta_{21} = -0.2$。\n- 测试用例3（无高阶模的边界情况）：$m_1 = 20$, $m_2 = 20$, $D = 400$, $f_0 = 40$, $f_1 = 120$, $r_{33} = 0.0$, $r_{21} = 0.0$, $\\delta_{33} = 0.0$, $\\delta_{21} = 0.0$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试用例相同，例如，“[result1,result2,result3]”。每个结果必须是该测试用例的 $R$ 值，按规定四舍五入到六位小数。不应打印其他任何文本。", "solution": "该问题陈述是一项有效的计算物理学任务。它在科学上基于广义相对论中用于描述致密双星旋近引力波的后牛顿近似。该问题定义明确，提供了所有必要的物理参数、微分方程、初始条件以及清晰的计算目标定义。它客观且使用标准的、无歧义的术语。因此，我们将着手提供一个完整的解决方案。\n\n问题的核心是生成一个合成的引力波信号，应用一个最小二乘滤波器来移除其主导分量，并量化该滤波器的性能。解决方案的结构如下：\n1.  将物理参数转换为国际单位制（SI）单位，并计算派生常数。\n2.  对常微分方程（ODE）系统进行数值积分，以生成主导模式频率和相位的时间演化。\n3.  通过叠加主导的 $(l,m)=(2,2)$ 模式以及次主导的 $(3,3)$ 和 $(2,1)$ 模式，构建完整的引力波应变时间序列 $s(t)$。\n4.  推导并应用一个线性最小二乘滤波器，以从信号中最佳地减去主导的 $(2,2)$ 模式。\n5.  计算最终的性能指标 $R$，定义为残差信号的均方根（RMS）与原始信号的均方根之比。\n\n**1. 物理参数和常数**\n\n首先，将所有输入参数转换为国际单位制单位。给定的质量 $m_1$ 和 $m_2$（以太阳质量 $M_{\\odot}$ 为单位）被转换为千克（kg）。距离 $D$（以百万秒差距 Mpc 为单位）被转换为米（m）。控制旋近过程的关键物理参数是啁啾质量 $\\mathcal{M}$，其定义为：\n$$\n\\mathcal{M} = \\frac{(m_1 m_2)^{3/5}}{(m_1 + m_2)^{1/5}}\n$$\n我们使用给定的引力常数 $G$、光速 $c$、太阳质量 $M_{\\odot}$ 和百万秒差距到米的转换因子。\n\n**2. 数值波形生成**\n\n双星系统的演化由一个包含两个耦合的一阶常微分方程的系统描述，该系统针对主导模式的瞬时频率 $f_{22}(t)$ 和相位 $\\Phi_{22}(t)$：\n$$\n\\frac{\\mathrm{d} f_{22}}{\\mathrm{d} t} = K_f \\cdot f_{22}^{11/3}(t)\n$$\n$$\n\\frac{\\mathrm{d}\\Phi_{22}}{\\mathrm{d}t} = 2\\pi f_{22}(t)\n$$\n其中常数 $K_f$ 由 $K_f = \\frac{96}{5}\\pi^{8/3}\\left(\\frac{G\\mathcal{M}}{c^3}\\right)^{5/3}$ 给出。\n\n我们在步长为 $\\Delta t = 1/f_s$ 的均匀时间网格上数值求解这个系统，其中 $f_s$ 是采样频率。一种简单且足够的方法是前向欧拉法。从初始条件 $t_0=0$、$f_{22}(t_0)=f_0$ 和 $\\Phi_{22}(t_0)=0$ 开始，我们对每个时间步 $n$ 进行如下迭代：\n$$\nf_{22}(t_{n+1}) = f_{22}(t_n) + \\Delta t \\cdot K_f \\cdot f_{22}^{11/3}(t_n)\n$$\n$$\n\\Phi_{22}(t_{n+1}) = \\Phi_{22}(t_n) + \\Delta t \\cdot 2\\pi f_{22}(t_n)\n$$\n积分过程一直进行到频率 $f_{22}(t)$ 首次达到或超过终止频率 $f_1$。每一步的 $t_n$、$f_{22}(t_n)$ 和 $\\Phi_{22}(t_n)$ 的值都被存储起来，形成离散的时间序列。\n\n**3. 应变时间序列构建**\n\n在已知频率和相位演化的情况下，我们构建完整的信号 $s(t_n)$。主导模式的振幅 $A_{22}(t)$ 取决于瞬时频率：\n$$\nA_{22}(t) = K_A \\cdot f_{22}^{2/3}(t), \\quad \\text{其中} \\quad K_A = \\frac{\\big(4\\,G\\,\\mathcal{M}/c^2\\big)^{5/3}\\,\\big(\\pi\\big)^{2/3}}{D}\n$$\n然后计算各个模式的贡献：\n$$\nh_{22}(t_n) = A_{22}(t_n) \\cos\\big(\\Phi_{22}(t_n)\\big)\n$$\n次主导模式的相位由主导模式的相位构建：\n$$\n\\Phi_{33}(t_n) = \\frac{3}{2}\\Phi_{22}(t_n) + \\delta_{33}\n$$\n$$\n\\Phi_{21}(t_n) = \\frac{1}{2}\\Phi_{22}(t_n) + \\delta_{21}\n$$\n它们各自的波形为：\n$$\nh_{33}(t_n) = r_{33} A_{22}(t_n) \\cos\\big(\\Phi_{33}(t_n)\\big)\n$$\n$$\nh_{21}(t_n) = r_{21} A_{22}(t_n) \\cos\\big(\\Phi_{21}(t_n)\\big)\n$$\n总的观测信号是线性叠加：\n$$\ns(t_n) = h_{22}(t_n) + h_{33}(t_n) + h_{21}(t_n)\n$$\n\n**4. 通过最小二乘法进行主导模式滤波**\n\n我们的目标是找到参数 $S^\\star$ 和 $\\varphi^\\star$，使得模板 $\\hat{h}_{22}(t; S,\\varphi) = S A_{22}(t) \\cos(\\Phi_{22}(t) + \\varphi)$ 能够最好地拟合数据 $s(t_n)$。这是通过最小化平方误差之和来实现的。\n\n为了将这个非线性问题转化为线性问题，我们使用三角恒等式 $\\cos(\\alpha + \\beta) = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta$ 来展开模板：\n$$\n\\hat{h}_{22}(t; S,\\varphi) = S \\Big( \\cos(\\Phi_{22}(t))\\cos(\\varphi) - \\sin(\\Phi_{22}(t))\\sin(\\varphi) \\Big) A_{22}(t)\n$$\n我们可以重新组合各项，并将模板写成两个基函数的线性组合：\n$$\n\\hat{h}_{22}(t) = (S\\cos\\varphi) \\cdot \\big[ A_{22}(t)\\cos(\\Phi_{22}(t)) \\big] - (S\\sin\\varphi) \\cdot \\big[ A_{22}(t)\\sin(\\Phi_{22}(t)) \\big]\n$$\n现在，我们定义两个基向量：\n- $u(t_n) = A_{22}(t_n)\\cos(\\Phi_{22}(t_n))$\n- $v(t_n) = A_{22}(t_n)\\sin(\\Phi_{22}(t_n))$\n\n并定义两个新的线性系数：\n- $C_1 = S\\cos\\varphi$\n- $C_2 = S\\sin\\varphi$\n\n这样，模板就变成了 $\\hat{h}_{22}(t_n) = C_1 u(t_n) - C_2 v(t_n)$。最小二乘误差则变为：\n$$\nE(C_1, C_2) = \\sum_{n=0}^{N-1} \\Big(s(t_n) - (C_1 u(t_n) - C_2 v(t_n))\\Big)^2\n$$\n通过分别对 $C_1$ 和 $C_2$ 求偏导并令其为零（$\\partial E/\\partial C_1 = 0$ 和 $\\partial E/\\partial C_2 = 0$），我们得到一个关于最优系数 $(C_1^\\star, C_2^\\star)$ 的 $2 \\times 2$ 线性方程组。引入两个时间序列 $x$ 和 $y$ 的点积表示法 $\\langle x, y \\rangle = \\sum_n x_n y_n$，该系统为：\n$$\n\\begin{pmatrix} \\langle u, u \\rangle & -\\langle u, v \\rangle \\\\ -\\langle u, v \\rangle & \\langle v, v \\rangle \\end{pmatrix}\n\\begin{pmatrix} C_1 \\\\ C_2 \\end{pmatrix}\n=\n\\begin{pmatrix} \\langle s, u \\rangle \\\\ -\\langle s, v \\rangle \\end{pmatrix}\n$$\n解这个系统可以得到最优系数 $(C_1^\\star, C_2^\\star)$。\n\n**5. 残差和性能指标计算**\n\n然后使用最优系数构建最佳拟合的主导模式波形：\n$$\n\\hat{h}_{22}(t_n; S^\\star,\\varphi^\\star) = C_1^\\star u(t_n) - C_2^\\star v(t_n)\n$$\n残差信号 $r(t_n)$ 是从原始信号中减去这个拟合波形后剩下的部分：\n$$\nr(t_n) = s(t_n) - \\hat{h}_{22}(t_n; S^\\star,\\varphi^\\star)\n$$\n最后，我们计算性能指标 $R$。对于长度为 $N$ 的离散时间序列 $x(t_n)$，其均方根为 $\\mathrm{RMS}(x) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} x_n^2}$。比率 $R$ 为：\n$$\nR = \\frac{\\mathrm{RMS}\\big(r\\big)}{\\mathrm{RMS}\\big(s\\big)}\n$$\n将此过程应用于每个测试用例，并报告得到的 $R$ 值，四舍五入到六位小数。对于次主导模式不存在（$r_{33}=r_{21}=0$）的特殊情况，信号 $s(t)$ 与基函数 $u(t)$ 完全相同。最小二乘问题的解析解是 $C_1^\\star=1, C_2^\\star=0$，这会得到零残差和 $R=0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave filtering problem for the specified test cases.\n    \"\"\"\n    \n    # Physical constants in SI units\n    G = 6.67430e-11  # Gravitational constant (m^3 kg^-1 s^-2)\n    C = 2.99792458e8   # Speed of light (m/s)\n    M_SOLAR = 1.98847e30 # Solar mass (kg)\n    MPC_TO_M = 3.085677581491367e22 # Megaparsec to meter conversion\n\n    def solve_one_case(m1, m2, D, f0, f1, r33, r21, d33, d21, fs):\n        \"\"\"\n        Computes the residual-to-signal RMS ratio R for a single test case.\n        \"\"\"\n        # 1. Parameter conversion and pre-computation\n        m1_kg = m1 * M_SOLAR\n        m2_kg = m2 * M_SOLAR\n        D_m = D * MPC_TO_M\n        dt = 1.0 / fs\n\n        # Chirp mass calculation\n        M_chirp_si = ((m1_kg * m2_kg)**(3.0/5.0)) / ((m1_kg + m2_kg)**(1.0/5.0))\n\n        # Constant for frequency evolution ODE\n        K_f = (96.0 / 5.0) * np.pi**(8.0/3.0) * (G * M_chirp_si / C**3)**(5.0/3.0)\n        \n        # Constant for amplitude calculation\n        K_A = ((4.0 * G * M_chirp_si / C**2)**(5.0/3.0) * np.pi**(2.0/3.0)) / D_m\n\n        # 2. Numerical integration using forward Euler method\n        t_n = 0.0\n        f_n = f0\n        phi_n = 0.0\n\n        times, freqs, phases = [], [], []\n\n        while f_n < f1:\n            times.append(t_n)\n            freqs.append(f_n)\n            phases.append(phi_n)\n\n            # Euler step for the system of ODEs\n            f_dot = K_f * f_n**(11.0 / 3.0)\n            phi_dot = 2.0 * np.pi * f_n\n            \n            f_n += f_dot * dt\n            phi_n += phi_dot * dt\n            t_n += dt\n        \n        freqs_ts = np.array(freqs)\n        phases_ts = np.array(phases)\n\n        # 3. Waveform Generation\n        A22_ts = K_A * freqs_ts**(2.0/3.0)\n        \n        phi22 = phases_ts\n        phi33 = 1.5 * phi22 + d33\n        phi21 = 0.5 * phi22 + d21\n\n        h22 = A22_ts * np.cos(phi22)\n        h33 = r33 * A22_ts * np.cos(phi33)\n        h21 = r21 * A22_ts * np.cos(phi21)\n        \n        s_ts = h22 + h33 + h21\n\n        # 4. Least-Squares Minimization\n        # Define basis functions for the linear fit\n        u_ts = A22_ts * np.cos(phi22)\n        v_ts = A22_ts * np.sin(phi22)\n\n        # Assemble and solve the 2x2 linear system M * C = V\n        # consistent with the template h_hat = C1*u - C2*v\n        V = np.array([np.dot(s_ts, u_ts), -np.dot(s_ts, v_ts)])\n        M = np.array([\n            [np.dot(u_ts, u_ts), -np.dot(u_ts, v_ts)],\n            [-np.dot(u_ts, v_ts), np.dot(v_ts, v_ts)]\n        ])\n        \n        # Handle the case where M is singular (e.g., if v_ts is all zeros)\n        if np.linalg.det(M) == 0:\n             # This can happen if the waveform is extremely short, u and v become linearly dependent.\n             # Or in the special case of r33=r21=0, s_ts=u_ts, v_ts is not relevant.\n             # A full solution would use pseudoinverse, but for this problem,\n             # direct solution is sufficient if we handle the edge case.\n             if np.dot(u_ts, u_ts) != 0:\n                C1_star = np.dot(s_ts, u_ts) / np.dot(u_ts, u_ts)\n                C2_star = 0.0\n                C_opt = np.array([C1_star, C2_star])\n             else:\n                C_opt = np.array([0.0, 0.0]) # Should not happen\n        else:\n            C_opt = np.linalg.solve(M, V)\n\n        C1_star, C2_star = C_opt\n    \n        # 5. Calculate Residual and RMS ratio\n        # Reconstruct the best-fit dominant mode waveform\n        h22_hat = C1_star * u_ts - C2_star * v_ts\n        \n        # Calculate the residual\n        r_ts = s_ts - h22_hat\n        \n        # Calculate RMS values\n        rms_s = np.sqrt(np.mean(s_ts**2))\n        rms_r = np.sqrt(np.mean(r_ts**2))\n        \n        # The ratio R. Handle potential division by zero.\n        if rms_s == 0:\n            return 0.0\n            \n        R = rms_r / rms_s\n        return R\n\n    # Sampling rate\n    fs = 4096.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m1, m2, D, f0, f1, r33, r21, d33, d21)\n        (30.0, 30.0, 500.0, 30.0, 150.0, 0.2, 0.1, 0.3, -0.5),\n        (35.0, 20.0, 300.0, 25.0, 200.0, 0.35, 0.15, 0.1, -0.2),\n        (20.0, 20.0, 400.0, 40.0, 120.0, 0.0, 0.0, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_one_case(*case, fs=fs)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # Each result is a float formatted to six decimal places.\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2399144"}]}