{"hands_on_practices": [{"introduction": "恒温器算法本质上是反馈控制系统，其稳定性是实现可靠模拟的关键。该练习通过一个带有时间延迟的简化恒温器模型，让您深入探究反馈延迟——一个在实际控制系统中常见的问题——如何影响算法的稳定性。通过实现其动力学演化，您将亲身体验并理解耦合强度 $1/\\tau$ 和延迟 $\\Delta t_{\\mathrm{delay}}$ 等参数对系统收敛至目标温度 $T_0$ 的影响。[@problem_id:2446284]", "problem": "您被要求研究一个通过缩放速度来尝试控制动能温度的离散时间恒温器。考虑一个离散时间恒温器，其时间步长为 $\\Delta t$，时间常数为 $\\tau$，目标恒定温度为 $T_0$。该系统采用约化单位，其中玻尔兹曼常数设为 $1$（无需物理单位）。在步数索引 $n \\in \\mathbb{Z}$ 处，令 $T_n$ 表示瞬时动能温度。该恒温器通过一个因子重新缩放速度，该因子的平方为\n$$\ns_n^2 = 1 + \\frac{\\Delta t}{\\tau} \\left(\\frac{T_0}{T_{n-m}} - 1\\right),\n$$\n其中 $m \\in \\mathbb{N}_0$ 表示以步数为单位的整数延迟，对应于物理延迟 $\\Delta t_{\\mathrm{delay}} = m \\,\\Delta t$。温度随之更新为\n$$\nT_{n+1} = s_n^2 \\, T_n.\n$$\n假设延迟是时间步长的精确整数倍，因此 $m = \\Delta t_{\\mathrm{delay}}/\\Delta t \\in \\mathbb{N}_0$。假设对于 $n \\le 0$ 的延迟历史由 $T_n = T_{\\mathrm{init}}$ 初始化。对于给定的参数集，当且仅当 $n \\to \\infty$ 时 $T_n \\to T_0$，系统是稳定的。\n\n您必须编写一个完整的、可运行的程序。该程序需对每个给定的参数集，模拟上述递推关系 $N$ 步，并按如下方式对稳定性进行分类。定义绝对相对偏差序列 $r_n = \\left|\\frac{T_n}{T_0} - 1\\right|$。令 $K = \\lfloor 0.2 N \\rfloor$。当且仅当最后 $K$ 步中 $r_n$ 的最大值严格小于给定的容差 $\\mathrm{tol}$ 时，该参数集被分类为稳定。\n\n您的程序必须对每个测试用例严格按照上述规定执行递推，并生成一行包含所需格式的布尔结果列表的输出。请使用以下测试套件，其中所有数值均以约化单位给出：\n\n- 情况 1：$(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 2\\times 10^{-3},\\, 0\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$。\n- 情况 2：$(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 2\\times 10^{-3},\\, 1\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$。\n- 情况 3：$(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 2\\times 10^{-3},\\, 2\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$。\n- 情况 4：$(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 2\\times 10^{-3},\\, 3\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$。\n- 情况 5：$(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 1.53846153846\\times 10^{-3},\\, 2\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[True,False,True,False,True]”）。", "solution": "提交审查的问题陈述是有效的。它提出了一个计算物理学中定义明确、有科学依据的问题。该问题要求对一个离散时间延迟反馈系统进行数值模拟，该系统是分子动力学模拟中使用的 Berendsen 恒温器的一个简化模型。所有必要的参数、初始条件、递推关系以及对稳定性的精确操作性定义都已提供。该问题是自洽的，没有逻辑矛盾或含糊之处。\n\n问题的核心是确定一个由非线性延迟递推关系描述的温度控制算法的稳定性。在第 $n$ 步的温度 $T_n$ 由以下方程组决定：\n$$\nT_{n+1} = s_n^2 \\, T_n\n$$\n其中速度缩放因子的平方 $s_n^2$ 由下式给出\n$$\ns_n^2 = 1 + \\frac{\\Delta t}{\\tau} \\left(\\frac{T_0}{T_{n-m}} - 1\\right).\n$$\n此处，$\\Delta t$ 是时间步长，$\\tau$ 是恒温器的时间常数，$T_0$ 是目标温度，而 $m = \\Delta t_{\\mathrm{delay}}/\\Delta t$ 是以离散步数表示的反馈延迟。对于非正步数索引，其历史由 $T_k = T_{\\mathrm{init}}$ (对所有 $k \\le 0$) 给出。\n\n结合这些方程，我们得到关于温度的单一递推关系：\n$$\nT_{n+1} = T_n \\left(1 + \\frac{\\Delta t}{\\tau} \\left(\\frac{T_0}{T_{n-m}} - 1\\right)\\right).\n$$\n这是一个离散动力系统。此类系统的稳定性可以通过在其不动点周围进行线性化来从理论上研究。该递推关系的不动点显然是 $T_n = T_0$ (对所有 $n$ 而言)，因为这会得到 $T_{n+1} = T_0(1+0) = T_0$。\n\n为了分析线性稳定性，我们引入一个小的扰动 $\\epsilon_n$，使得 $T_n = T_0(1 + \\epsilon_n)$。将此代入递推关系，并针对小的 $\\epsilon_n$ 进行线性化（即，使用 $(1+\\epsilon_{n-m})^{-1} \\approx 1 - \\epsilon_{n-m}$ 并舍弃 $\\epsilon^2$ 及更高阶的项），得到扰动的线性递推关系：\n$$\n\\epsilon_{n+1} \\approx \\epsilon_n - \\frac{\\Delta t}{\\tau} \\epsilon_{n-m}.\n$$\n我们定义无量纲常数 $C = \\Delta t/\\tau$。线性递推关系变为：\n$$\n\\epsilon_{n+1} - \\epsilon_n + C \\epsilon_{n-m} = 0.\n$$\n寻找形式为 $\\epsilon_n = \\lambda^n$ 的解，我们得到特征方程：\n$$\n\\lambda^{n+1} - \\lambda^n + C \\lambda^{n-m} = 0.\n$$\n两边同除以 $\\lambda^{n-m}$（假设 $\\lambda \\ne 0$），我们得到：\n$$\n\\lambda^{m+1} - \\lambda^m + C = 0.\n$$\n当且仅当该多项式的所有根 $\\lambda$ 的模都严格小于 $1$（即 $|\\lambda| < 1$）时，系统是线性稳定的。例如，对于 $m=2$ 和 $C=0.5$，可以证明存在模为 $|\\lambda|=1$ 的根，这使得系统处于稳定性的边界上。对于 $C>0.5$，系统变得不稳定。这一理论分析可作为指导，但问题要求进行直接模拟。\n\n需要实现的算法是温度演化的直接模拟。\n1.  初始化一个大小为 $N+1$ 的数组 `T` 以存储温度 $T_0, T_1, \\dots, T_N$。将 $T_0$ 的值设置为 $T_{\\mathrm{init}}$。\n2.  对步数索引 $n$ 从 $0$ 到 $N-1$ 进行迭代。在每一步中：\n    a. 确定延迟温度 $T_{n-m}$。如果 $n-m < 0$，其值为 $T_{\\mathrm{init}}$。否则，从数组 `T` 的索引 $n-m$ 处获取。\n    b. 使用 $T_{n-m}$ 的值计算缩放因子 $s_n^2$。\n    c. 计算下一个温度 $T_{n+1} = s_n^2 T_n$ 并将其存储在数组 `T` 的索引 $n+1$ 处。\n    d. 一个稳健的实现必须考虑 $T_{n-m} \\le 0$ 的情况，这会使缩放因子无定义。在这种极端不稳定的情况下，后续温度被设置为非数字（`NaN`）以表示失败。\n3.  完成 $N$ 步后，根据提供的数值准则评估稳定性。令 $K = \\lfloor 0.2N \\rfloor$。\n4.  对模拟的最后 $K$ 步（即 $n \\in \\{N-K+1, \\dots, N\\}$）计算绝对相对偏差集合 $r_n = \\left| \\frac{T_n}{T_0} - 1 \\right|$。\n5.  如果该偏差集合包含非有限值（例如 `inf` 或 `NaN`），则系统被分类为不稳定。\n6.  否则，找出该集合中的最大值 $\\max(r_n)$。当且仅当该最大值严格小于给定的容差 $\\mathrm{tol}$ 时，该参数集被分类为稳定。\n\n对测试套件中提供的每组参数执行此过程。最终输出是一个布尔值列表（`True` 代表稳定，`False` 代表不稳定），其格式需符合指定要求。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the thermostat stability problem by simulating the temperature evolution\n    for each test case and applying the specified stability criterion.\n    \"\"\"\n    test_cases = [\n        # Case 1: (dt, tau, dt_delay, T0, T_init, N, tol)\n        (1e-3, 2e-3, 0e-3, 1.0, 2.0, 20000, 1e-3),\n        # Case 2\n        (1e-3, 2e-3, 1e-3, 1.0, 2.0, 20000, 1e-3),\n        # Case 3\n        (1e-3, 2e-3, 2e-3, 1.0, 2.0, 20000, 1e-3),\n        # Case 4\n        (1e-3, 2e-3, 3e-3, 1.0, 2.0, 20000, 1e-3),\n        # Case 5\n        (1e-3, 1.53846153846e-3, 2e-3, 1.0, 2.0, 20000, 1e-3),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        dt, tau, dt_delay, T0, T_init, N, tol = case\n\n        # Calculate integer delay m\n        # Using round to be robust against floating point inaccuracies,\n        # then casting to int.\n        m = int(round(dt_delay / dt))\n\n        # Array to store temperature history from T_0 to T_N\n        T = np.zeros(N + 1, dtype=np.float64)\n        T[0] = T_init\n\n        # Pre-calculate ratio for efficiency\n        dt_div_tau = dt / tau\n\n        # Simulation loop from n=0 to N-1 to compute T_1,...,T_N\n        for n in range(N):\n            # Get the delayed temperature T_{n-m}\n            # For n-m < 0, use the initial temperature history\n            if n - m < 0:\n                T_delayed = T_init\n            else:\n                T_delayed = T[n - m]\n\n            # If T_delayed is non-positive, the system is highly unstable.\n            # The scaling factor would be undefined or infinite.\n            # We mark subsequent temperatures as NaN and break.\n            if T_delayed <= 0:\n                T[n+1:] = np.nan\n                break\n\n            # Calculate the scaling factor squared\n            s_squared = 1 + dt_div_tau * (T0 / T_delayed - 1)\n            \n            # Update the temperature\n            T[n+1] = s_squared * T[n]\n\n        # Stability classification\n        K = int(0.2 * N)\n        \n        # Check stability on the last K steps of the simulation.\n        # Indices are N-K+1, ..., N. Slice is T[N-K+1:].\n        last_K_T = T[N - K + 1:]\n\n        # If any values in the final window are not finite, the system is unstable.\n        if not np.all(np.isfinite(last_K_T)):\n            is_stable = False\n        else:\n            # Calculate absolute relative deviations r_n\n            r_values = np.abs(last_K_T / T0 - 1)\n            max_r = np.max(r_values)\n            # Classify stability based on the tolerance\n            is_stable = max_r < tol\n\n        results.append(is_stable)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The map(str,...) is used to get \"True\" and \"False\" strings correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2446284"}, {"introduction": "在处理大规模分子动力学模拟时，并行计算，特别是空间区域分解，是不可或缺的技术。此练习聚焦于一个关键的实现挑战：全局恒温器（如 Nosé-Hoover）依赖于整个系统的全局属性（如总动能 $K$），而这与并行计算中每个处理器只能直接访问局部信息的特性相矛盾。通过量化一个幼稚的、纯局部实现的恒温器所产生的误差，您将具体理解为何在并行代码中，全局通信对于正确实现这类物理算法至关重要。[@problem_id:2446283]", "problem": "您需要编写一个完整、可运行的程序，用于在几种指定情况下，评估全局 Nosé–Hoover 恒温器在空间区域分解下的一致性。考虑一个一维粒子系统，其粒子质量为 $\\{m_j\\}$，速度为 $\\{v_j\\}$，该系统耦合到一个单一的全局 Nosé–Hoover 恒温器变量 $\\zeta$，其恒温器质量参数为 $Q$。该系统的维度为一，因此自由度 (DOF) 的数量为 $g = N$，其中 $N$ 是粒子数。瞬时总动能为\n$$\nK = \\sum_{j=1}^{N} \\frac{1}{2} m_j v_j^2 \\, .\n$$\n全局 Nosé–Hoover 恒温器遵循以下方程：\n$$\n\\dot{\\zeta} = \\frac{2 K - g \\, k_{\\mathrm{B}} \\, T_0}{Q} \\, ,\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T_0$ 是目标温度。请使用 $k_{\\mathrm{B}}$ 的精确值 $1.380649\\times 10^{-23}\\,\\mathrm{J/K}$。\n\n在空间区域分解中，$N$ 个粒子被划分为 $M$ 个不相交的子区域，其索引集为 $\\{\\mathcal{D}_i\\}_{i=1}^{M}$，其中每个 $\\mathcal{D}_i$ 都是一个粒子索引的集合。定义子区域 $i$ 中的局域动能为\n$$\nK_i = \\sum_{j \\in \\mathcal{D}_i} \\frac{1}{2} m_j v_j^2 \\, ,\n$$\n局域自由度为 $g_i = |\\mathcal{D}_i|$。一个忽略了全局耦合的不一致的局域实现会按如下方式计算每个子区域的恒温器速率：\n$$\n\\dot{\\zeta}_i^{\\mathrm{local}} = \\frac{2 K_i - g_i \\, k_{\\mathrm{B}} \\, T_0}{Q} \\, .\n$$\n对于每个测试用例，计算以下两个量：\n- 根据上述定义计算的正确的全局恒温器速率 $\\dot{\\zeta}$，单位为 $\\mathrm{s}^{-2}$。\n- 最大绝对偏差\n$$\n\\Delta_{\\max} = \\max_{1 \\le i \\le M} \\left| \\dot{\\zeta}_i^{\\mathrm{local}} - \\dot{\\zeta} \\right| \\, ,\n$$\n单位为 $\\mathrm{s}^{-2}$，它量化了因使用局域子区域量而非必需的全局量所引入的不一致性。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[\\dot{\\zeta}^{(1)}, \\Delta_{\\max}^{(1)}, \\dot{\\zeta}^{(2)}, \\Delta_{\\max}^{(2)}, \\ldots] \\, ,\n$$\n其中上标表示测试用例编号。所有报告的数值均以 $\\mathrm{s}^{-2}$ 为单位，并四舍五入到 $10^{-6}$。\n\n请使用以下测试套件（所有输入均采用国际单位制，速度单位为 $\\mathrm{m/s}$，质量单位为 $\\mathrm{kg}$，温度单位为 $\\mathrm{K}$，$Q$ 的单位为 $\\mathrm{J\\,s^2}$）：\n\n- 测试用例 $1$（一般情况）：\n  - $N = 4$，\n  - 质量：$[1.0\\times 10^{-26},\\, 2.0\\times 10^{-26},\\, 1.5\\times 10^{-26},\\, 0.5\\times 10^{-26}]\\,\\mathrm{kg}$，\n  - 速度：$[500.0,\\, -300.0,\\, 100.0,\\, 0.0]\\,\\mathrm{m/s}$，\n  - $T_0 = 300.0\\,\\mathrm{K}$，\n  - $Q = 1.0\\times 10^{-20}\\,\\mathrm{J\\,s^2}$，\n  - 分解：$\\mathcal{D}_1 = \\{1,2\\}$，$\\mathcal{D}_2 = \\{3,4\\}$（此描述中索引是基于 1 的；在基于 0 的索引中，它们是 $[0,1]$ 和 $[2,3]$）。\n\n- 测试用例 $2$（零动能的边界情况）：\n  - $N = 3$，\n  - 质量：$[1.0\\times 10^{-26},\\, 1.0\\times 10^{-26},\\, 1.0\\times 10^{-26}]\\,\\mathrm{kg}$，\n  - 速度：$[0.0,\\, 0.0,\\, 0.0]\\,\\mathrm{m/s}$，\n  - $T_0 = 100.0\\,\\mathrm{K}$，\n  - $Q = 1.0\\times 10^{-21}\\,\\mathrm{J\\,s^2}$，\n  - 分解：$\\mathcal{D}_1 = \\{1,2\\}$，$\\mathcal{D}_2 = \\{3\\}$（基于 0 的索引：$[0,1]$ 和 $[2]$）。\n\n- 测试用例 $3$（单个粒子的边界情况）：\n  - $N = 1$，\n  - 质量：$[1.0\\times 10^{-26}]\\,\\mathrm{kg}$，\n  - 速度：$[400.0]\\,\\mathrm{m/s}$，\n  - $T_0 = 300.0\\,\\mathrm{K}$，\n  - $Q = 1.0\\times 10^{-20}\\,\\mathrm{J\\,s^2}$，\n  - 分解：$\\mathcal{D}_1 = \\{1\\}$（基于 0 的索引：$[0]$）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\dot{\\zeta}^{(1)}, \\Delta_{\\max}^{(1)}, \\dot{\\zeta}^{(2)}, \\Delta_{\\max}^{(2)}, \\dot{\\zeta}^{(3)}, \\Delta_{\\max}^{(3)}]$，每个数值都以 $\\mathrm{s}^{-2}$ 为单位并四舍五入到 $10^{-6}$。", "solution": "所提出的问题是计算物理学中的一个直观练习，适合用于检验学生对分子动力学模拟中恒温算法的理解。该问题定义明确，科学上合理，并提供了所有必要的参数。我们将直接进行求解。\n\n全局恒温器（如 Nosé–Hoover 恒温器）的核心原理是，它与一个全局的、系统范围的属性耦合——在本例中，即所有粒子的总动能。恒温器的目的是调节这个全局能量，以维持整个系统的目标温度 $T_0$，而不是维持其各个部分的温度。在并行代码中，使用空间区域分解的一种朴素实现可能会错误地仅使用局域属性，尝试对每个子区域进行局域恒温。本问题要求我们量化这种有缺陷的局域方法与正确的全局方法相比所产生的误差或不一致性。\n\n让我们精确地定义所需的各个量。该系统由 $N$ 个粒子组成，其质量为 $\\{m_j\\}_{j=1}^N$，一维速度为 $\\{v_j\\}_{j=1}^N$。常数 $k_{\\mathrm{B}}$ 代表玻尔兹曼常数，给定值为 $1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$。\n\n系统的总动能是所有粒子的总和：\n$$\nK = \\sum_{j=1}^{N} \\frac{1}{2} m_j v_j^2\n$$\n这个一维系统的自由度数量 $g$ 就是粒子数，即 $g=N$。\n\n对于具有质量参数 $Q$ 的全局 Nosé–Hoover 恒温器变量 $\\zeta$，其正确的运动方程由下式给出：\n$$\n\\dot{\\zeta} = \\frac{2K - g k_{\\mathrm{B}} T_0}{Q}\n$$\n这是全局一致的速率，我们必须为每个测试用例计算此值。\n\n系统被划分为 $M$ 个不相交的子区域，其粒子索引集为 $\\{\\mathcal{D}_i\\}_{i=1}^{M}$。对于每个子区域 $i$，可以定义其局域动能 $K_i$ 和局域自由度数量 $g_i$：\n$$\nK_i = \\sum_{j \\in \\mathcal{D}_i} \\frac{1}{2} m_j v_j^2\n\\quad \\text{和} \\quad\ng_i = |\\mathcal{D}_i|\n$$\n通过简单的代数运算可以看出 $\\sum_{i=1}^{M} K_i = K$ 和 $\\sum_{i=1}^{M} g_i = g$。\n\n对于每个子区域 $i$，一个不一致的局域恒温器速率 $\\dot{\\zeta}_i^{\\mathrm{local}}$ 会被错误地计算为：\n$$\n\\dot{\\zeta}_i^{\\mathrm{local}} = \\frac{2K_i - g_i k_{\\mathrm{B}} T_0}{Q}\n$$\n这个表达式从根本上是错误的，因为恒温器变量 $\\zeta$ 是一个单一的全局实体。系统的不同部分不能也不应尝试以不同的速率驱动它。不一致性由最大绝对偏差 $\\Delta_{\\max}$ 来衡量：\n$$\n\\Delta_{\\max} = \\max_{1 \\le i \\le M} \\left| \\dot{\\zeta}_i^{\\mathrm{local}} - \\dot{\\zeta} \\right|\n$$\n\n计算流程如下：\n1.  对于每个测试用例，读取输入：$N$, $\\{m_j\\}$, $\\{v_j\\}$, $T_0$, $Q$, 以及子区域分解 $\\{\\mathcal{D}_i\\}$。\n2.  计算总动能 $K$。\n3.  计算总自由度 $g=N$。\n4.  使用其定义计算正确的全局恒温器速率 $\\dot{\\zeta}$。\n5.  对于每个子区域 $\\mathcal{D}_i$：\n    a. 计算局域动能 $K_i$。\n    b. 计算局域自由度 $g_i$。\n    c. 计算不正确的局域速率 $\\dot{\\zeta}_i^{\\mathrm{local}}$。\n6.  计算绝对偏差集合 $\\{|\\dot{\\zeta}_i^{\\mathrm{local}} - \\dot{\\zeta}|\\}$。\n7.  从该集合中确定最大值 $\\Delta_{\\max}$。\n8.  记录 $\\dot{\\zeta}$ 和 $\\Delta_{\\max}$ 的结果，并四舍五入到 $10^{-6}\\,\\mathrm{s}^{-2}$。\n\n我们将此流程应用于指定的测试用例。\n\n**测试用例 1：**\n- $N=4$, $g=4$, $T_0 = 300.0\\,\\mathrm{K}$, $Q = 1.0 \\times 10^{-20}\\,\\mathrm{J\\,s^2}$。\n- 质量：$m = [1.0, 2.0, 1.5, 0.5] \\times 10^{-26}\\,\\mathrm{kg}$。\n- 速度：$v = [500.0, -300.0, 100.0, 0.0]\\,\\mathrm{m/s}$。\n- 分解：$\\mathcal{D}_1=\\{1, 2\\}$, $\\mathcal{D}_2=\\{3, 4\\}$。\n- 总动能 $K = \\frac{1}{2}\\sum m_j v_j^2 = 2.225 \\times 10^{-21}\\,\\mathrm{J}$。\n- 全局速率 $\\dot{\\zeta} = (2K - g k_{\\mathrm{B}} T_0)/Q = (2 \\times 2.225 \\times 10^{-21} - 4 \\times 1.380649 \\times 10^{-23} \\times 300.0) / (1.0 \\times 10^{-20}) \\approx -1.211779\\,\\mathrm{s}^{-2}$。\n- 子区域 1：$g_1=2$, $K_1 = 2.15 \\times 10^{-21}\\,\\mathrm{J}$, $\\dot{\\zeta}_1^{\\mathrm{local}} \\approx -0.398389\\,\\mathrm{s}^{-2}$。\n- 子区域 2：$g_2=2$, $K_2 = 7.5 \\times 10^{-23}\\,\\mathrm{J}$, $\\dot{\\zeta}_2^{\\mathrm{local}} \\approx -0.813389\\,\\mathrm{s}^{-2}$。\n- 偏差：$|\\dot{\\zeta}_1^{\\mathrm{local}} - \\dot{\\zeta}| \\approx 0.813389\\,\\mathrm{s}^{-2}$, $|\\dot{\\zeta}_2^{\\mathrm{local}} - \\dot{\\zeta}| \\approx 0.398389\\,\\mathrm{s}^{-2}$。\n- $\\Delta_{\\max} \\approx 0.813389\\,\\mathrm{s}^{-2}$。\n\n**测试用例 2：**\n- $N=3$, $g=3$, $T_0 = 100.0\\,\\mathrm{K}$, $Q = 1.0 \\times 10^{-21}\\,\\mathrm{J\\,s^2}$。\n- 所有速度均为零，因此总动能 $K=0\\,\\mathrm{J}$。\n- 全局速率 $\\dot{\\zeta} = (0 - g k_{\\mathrm{B}} T_0)/Q = (-3 \\times 1.380649 \\times 10^{-23} \\times 100.0) / (1.0 \\times 10^{-21}) \\approx -4.141947\\,\\mathrm{s}^{-2}$。\n- 子区域 1 ($\\mathcal{D}_1=\\{1, 2\\}$)：$g_1=2$, $K_1=0\\,\\mathrm{J}$, $\\dot{\\zeta}_1^{\\mathrm{local}} \\approx -2.761298\\,\\mathrm{s}^{-2}$。\n- 子区域 2 ($\\mathcal{D}_2=\\{3\\}$)：$g_2=1$, $K_2=0\\,\\mathrm{J}$, $\\dot{\\zeta}_2^{\\mathrm{local}} \\approx -1.380649\\,\\mathrm{s}^{-2}$。\n- 偏差：$|\\dot{\\zeta}_1^{\\mathrm{local}} - \\dot{\\zeta}| \\approx 1.380649\\,\\mathrm{s}^{-2}$, $|\\dot{\\zeta}_2^{\\mathrm{local}} - \\dot{\\zeta}| \\approx 2.761298\\,\\mathrm{s}^{-2}$。\n- $\\Delta_{\\max} \\approx 2.761298\\,\\mathrm{s}^{-2}$。\n\n**测试用例 3：**\n- $N=1$, $g=1$, $T_0 = 300.0\\,\\mathrm{K}$, $Q = 1.0 \\times 10^{-20}\\,\\mathrm{J\\,s^2}$。\n- 系统只有一个粒子，因此只有一个“子区域”，即整个系统。\n- 总动能 $K = \\frac{1}{2}(1.0 \\times 10^{-26}\\,\\mathrm{kg})(400.0\\,\\mathrm{m/s})^2 = 8.0 \\times 10^{-22}\\,\\mathrm{J}$。\n- 全局速率 $\\dot{\\zeta} = (2K - g k_{\\mathrm{B}} T_0)/Q = (2 \\times 8.0 \\times 10^{-22} - 1 \\times 1.380649 \\times 10^{-23} \\times 300.0) / (1.0 \\times 10^{-20}) \\approx -0.254195\\,\\mathrm{s}^{-2}$。\n- 对于单个子区域，$g_1=g=1$, $K_1=K$，因此 $\\dot{\\zeta}_1^{\\mathrm{local}} = \\dot{\\zeta}$。\n- 偏差必然为零：$\\Delta_{\\max} = 0.0\\,\\mathrm{s}^{-2}$。\n\n此分析证实，朴素的局域实现会导致不一致性，除非子区域中每个自由度的动能分布恰好与全局平均值完全匹配，或者在只有一个区域的平凡情况下。要实现一个正确的并行实现，需要通过全局通信（例如求和或 \"Allreduce\" 操作）来计算单个全局恒温器所需的总动能。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the global Nosé-Hoover thermostat rate and the maximum deviation\n    from an inconsistent local implementation for several test cases.\n    \"\"\"\n    # Boltzmann constant in J/K\n    K_B = 1.380649e-23\n\n    # Define the test cases from the problem statement.\n    # Note: Decomposition indices are 0-based.\n    test_cases = [\n        {\n            \"N\": 4,\n            \"masses\": np.array([1.0e-26, 2.0e-26, 1.5e-26, 0.5e-26]),\n            \"velocities\": np.array([500.0, -300.0, 100.0, 0.0]),\n            \"T0\": 300.0,\n            \"Q\": 1.0e-20,\n            \"decomposition\": [np.array([0, 1]), np.array([2, 3])]\n        },\n        {\n            \"N\": 3,\n            \"masses\": np.array([1.0e-26, 1.0e-26, 1.0e-26]),\n            \"velocities\": np.array([0.0, 0.0, 0.0]),\n            \"T0\": 100.0,\n            \"Q\": 1.0e-21,\n            \"decomposition\": [np.array([0, 1]), np.array([2])]\n        },\n        {\n            \"N\": 1,\n            \"masses\": np.array([1.0e-26]),\n            \"velocities\": np.array([400.0]),\n            \"T0\": 300.0,\n            \"Q\": 1.0e-20,\n            \"decomposition\": [np.array([0])]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        masses = case[\"masses\"]\n        velocities = case[\"velocities\"]\n        T0 = case[\"T0\"]\n        Q = case[\"Q\"]\n        decomposition = case[\"decomposition\"]\n\n        # Calculate per-particle kinetic energies\n        particle_kinetic_energies = 0.5 * masses * velocities**2\n\n        # --- Global calculation (correct) ---\n        # Total kinetic energy K\n        K_global = np.sum(particle_kinetic_energies)\n        # Global degrees of freedom g\n        g_global = N\n        # Global thermostat rate zeta_dot\n        zeta_dot_global = (2 * K_global - g_global * K_B * T0) / Q\n        \n        # --- Local calculations (inconsistent) ---\n        zeta_dot_locals = []\n        for subdomain_indices in decomposition:\n            # Local kinetic energy K_i\n            K_local = np.sum(particle_kinetic_energies[subdomain_indices])\n            # Local degrees of freedom g_i\n            g_local = len(subdomain_indices)\n            # Local thermostat rate zeta_dot_i\n            zeta_dot_local = (2 * K_local - g_local * K_B * T0) / Q\n            zeta_dot_locals.append(zeta_dot_local)\n        \n        # --- Deviation calculation ---\n        deviations = np.abs(np.array(zeta_dot_locals) - zeta_dot_global)\n        # Maximum absolute deviation Delta_max\n        # If there are no subdomains, max would fail. This case is not tested.\n        # If there is one subdomain, deviation is 0, so max is 0.\n        delta_max = np.max(deviations) if len(deviations) > 0 else 0.0\n\n        results.append(zeta_dot_global)\n        results.append(delta_max)\n\n    # Final print statement in the exact required format.\n    # Numbers are formatted to 6 decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2446283"}, {"introduction": "恒温器的应用远不止维持系统平衡，它们也是驱动系统进入非平衡态以研究输运行为的强大工具。本实践将引导您构建一个完整的非平衡分子动力学（NEMD）模拟，其中恒温器被用作热源和热沉，在系统两端建立温度梯度。您将亲手实现一个粒子链的动力学、在边界施加温度控制，并最终测量由此产生的稳态热流 $J$，从而将抽象的算法与真实材料属性（如热导率）的计算联系起来。[@problem_id:2446245]", "problem": "考虑一个一维链，由 $N$ 个质量为 $m$ 的相同粒子组成，这些粒子沿一条直线排列，并由刚度为 $k$、静息长度为 $a$ 的相同谐振子弹簧连接。设粒子 $i$ 的位置为 $x_i(t)$ (其中 $i \\in \\{1,\\dots,N\\}$)，其两端固定在 $x_0(t) \\equiv 0$ 和 $x_{N+1}(t) \\equiv (N+1)a$ 的锚点上。总势能为\n$$\nU(x_0,\\dots,x_{N+1}) = \\sum_{i=0}^{N} \\tfrac{1}{2} k \\left(x_{i+1}-x_i-a\\right)^2,\n$$\n其运动方程为\n$$\nm \\,\\ddot{x}_i(t) = -\\frac{\\partial U}{\\partial x_i} = k\\left(x_{i-1}(t) + x_{i+1}(t) - 2 x_i(t)\\right), \\quad i=1,\\dots,N.\n$$\n最左侧的粒子 $i=1$ 和最右侧的粒子 $i=N$ 分别耦合到独立的 Berendsen 恒温器，以试图维持各自的动能温度 $T_1$ 和 $T_2$。在一维空间中，具有 $n_{\\mathrm{dof}}$ 个自由度的粒子组的瞬时动能温度由能量均分关系定义\n$$\n\\tfrac{1}{2} n_{\\mathrm{dof}} k_{\\mathrm{B}} T = \\sum \\tfrac{1}{2} m v^2,\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$v$ 表示速度。对于一维空间中的单个恒温粒子，$n_{\\mathrm{dof}}=1$，其瞬时动能温度等于 $T = m v^2/k_{\\mathrm{B}}$。Berendsen 恒温器在时间步长 $\\Delta t$ 内，通过一个标量因子 $\\lambda$ 来重新调节其粒子组的速度 $v$，该因子由下式给出\n$$\n\\lambda = \\sqrt{1 + \\frac{\\Delta t}{\\tau_T}\\left(\\frac{T_0}{T}-1\\right)},\n$$\n其中 $\\tau_T$ 是恒温器耦合时间，$T_0$ 是目标温度（左侧粒子为 $T_1$，右侧粒子为 $T_2$）。在每个积分时间步之后，对最左侧和最右侧的粒子应用速度重缩放 $v \\leftarrow \\lambda v$。设 $\\Delta K_{\\mathrm{L}}$ 表示在一个时间步内，仅因此次重缩放导致的最左侧粒子动能的变化；左侧恒温器注入的瞬时功率近似为 $\\Delta K_{\\mathrm{L}}/\\Delta t$。在稳态下，通过链的热流等于左侧恒温器注入的平均功率，也等于右侧恒温器提取的功率的绝对值。将测量的稳态热流 $J$ 定义为在指定测量窗口内 $\\Delta K_{\\mathrm{L}}/\\Delta t$ 的时间平均值，并约定当能量由左侧恒温器注入链中时，$J$ 为正值。\n\n使用简约单位，使得 $m=1$, $k=1$, $a=1$, $k_{\\mathrm{B}}=1$。在时间 $t=0$ 时的初始条件为\n$$\nx_i(0) = i a,\\quad i=1,\\dots,N,\n$$\n以及具有空间正弦分布的确定性速度，\n$$\nv_i(0) = V_0 \\sin\\!\\left(\\frac{\\pi i}{N+1}\\right),\\quad i=1,\\dots,N,\n$$\n其中\n$$\nV_0 = \\sqrt{\\frac{2 T_{\\mathrm{mid}}}{m}},\\quad T_{\\mathrm{mid}}=\\frac{T_1+T_2}{2}.\n$$\n使用恒定的时间步长 $\\Delta t$ 对系统进行演化，总模拟时间为 $t_{\\mathrm{tot}}$。舍弃持续时间为 $t_{\\mathrm{trans}}$ 的初始瞬态区间，然后在剩余时间内计算 $J$ 作为 $\\Delta K_{\\mathrm{L}}/\\Delta t$ 的时间平均值。以简约单位的能量/时间表示 $J$ 的最终答案，并将每个值四舍五入到三位小数。\n\n测试组。对于下面的每个参数元组 $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}})$，计算相应的稳态热流 $J$：\n- 情况 1: $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (32, 2.0, 1.0, 0.1, 0.001, 50.0, 20.0)$。\n- 情况 2: $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (32, 1.5, 1.5, 0.1, 0.001, 50.0, 20.0)$。\n- 情况 3: $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (8, 3.0, 0.5, 0.02, 0.001, 50.0, 20.0)$。\n- 情况 4: $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (16, 2.5, 0.5, 1.0, 0.001, 80.0, 40.0)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个结果 $[J_1,J_2,J_3,J_4]$，形式为用方括号括起来的逗号分隔列表，顺序与上述情况一致，每个 $J_i$ 均以简约单位表示并四舍五入到三位小数。", "solution": "该问题已经过验证。\n\n**第 1 步：提取已知条件**\n- **系统**：一个由 $N$ 个质量为 $m$ 的相同粒子组成的一维链。这些粒子由刚度为 $k$、静息长度为 $a$ 的谐振子弹簧连接。\n- **边界条件**：链的两端固定，锚点位于 $x_0(t) \\equiv 0$ 和 $x_{N+1}(t) \\equiv (N+1)a$。\n- **势能**：总势能由 $U(x_0,\\dots,x_{N+1}) = \\sum_{i=0}^{N} \\tfrac{1}{2} k \\left(x_{i+1}-x_i-a\\right)^2$ 给出。\n- **运动方程**：粒子 $i$ 的动力学由 $m \\,\\ddot{x}_i(t) = k\\left(x_{i-1}(t) + x_{i+1}(t) - 2 x_i(t)\\right)$ 描述，其中 $i=1,\\dots,N$。\n- **恒温器**：第一个 ($i=1$) 和最后一个 ($i=N$) 粒子分别耦合到目标温度为 $T_1$ 和 $T_2$ 的独立 Berendsen 恒温器。\n- **瞬时温度**：对于一维空间中的单个粒子，瞬时动能温度为 $T = m v^2/k_{\\mathrm{B}}$。\n- **速度重缩放**：恒温器通过因子 $\\lambda = \\sqrt{1 + \\frac{\\Delta t}{\\tau_T}\\left(\\frac{T_0}{T}-1\\right)}$ 来重缩放速度 $v$，其中 $\\tau_T$ 是耦合时间，$T_0$ 是目标温度。\n- **热流 ($J$)**：定义为左侧恒温器注入的瞬时功率 $P_L(t) = \\Delta K_{\\mathrm{L}}/\\Delta t$ 的时间平均值，其中 $\\Delta K_{\\mathrm{L}}$ 是在一个时间步 $\\Delta t$ 内由于恒温器重缩放而导致的最左侧粒子的动能变化。该平均值在稳态测量窗口内计算。\n- **简约单位**：模拟使用 $m=1$、$k=1$、$a=1$ 和 $k_{\\mathrm{B}}=1$ 的单位。\n- **初始条件 ($t=0$)**：\n    - 位置：$x_i(0) = i a$，对于 $i=1,\\dots,N$。\n    - 速度：$v_i(0) = V_0 \\sin\\!\\left(\\frac{\\pi i}{N+1}\\right)$，其中 $V_0 = \\sqrt{\\frac{2 T_{\\mathrm{mid}}}{m}}$ 且 $T_{\\mathrm{mid}}=\\frac{T_1+T_2}{2}$。\n- **模拟参数**：系统使用时间步长 $\\Delta t$ 演化，总时间为 $t_{\\mathrm{tot}}$。初始的 $t_{\\mathrm{trans}}$ 时段作为瞬态阶段被舍弃。\n- **测试用例**：\n    1. $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (32, 2.0, 1.0, 0.1, 0.001, 50.0, 20.0)$\n    2. $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (32, 1.5, 1.5, 0.1, 0.001, 50.0, 20.0)$\n    3. $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (8, 3.0, 0.5, 0.02, 0.001, 50.0, 20.0)$\n    4. $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (16, 2.5, 0.5, 1.0, 0.001, 80.0, 40.0)$\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题描述了一个用于研究热传导的非平衡分子动力学模拟。这是计算物理学中一个标准且成熟的问题。\n- **科学合理性**：谐振子链模型、从势能推导出的运动方程、Berendsen 恒温器的概念，以及通过恒温器功率定义热流的方法，在根本上都是合理的，并在该领域被广泛使用。\n- **适定性**：该问题是适定的。系统由一组具有指定初始条件的二阶常微分方程描述。其轨迹存在唯一解。待计算的量，即时间平均热流，也被明确定义。\n- **客观性与完整性**：该问题使用精确、客观的语言进行陈述，并提供了进行模拟所需的所有数据和方程。系统和模拟协议的所有参数都已明确给出。使用简约单位简化了数值计算方面，且不失一般性。所提供的参数，包括积分时间步长 $\\Delta t = 0.001$，在物理上是合理的，并能确保数值稳定性。在简约单位下，链的最高频率为 $\\omega_{\\max} < 2$，对应的周期为 $T_{\\min} > \\pi$。时间步长 $\\Delta t = 0.001 \\ll T_{\\min}$，满足常用积分算法的稳定性准则。\n\n**第 3 步：结论与行动**\n该问题被认定为**有效**。将根据指定原理，通过数值模拟构建一个解决方案。\n\n**解决方案设计**\n\n该问题通过对系统动力学进行直接数值模拟来解决。解决方案的核心包括三个部分：用于运动方程的数值积分器、恒温过程的实现，以及时间平均热流的计算。\n\n**1. 系统初始化**\n在简约单位下，常数为 $m=1$、$k=1$、$a=1$ 和 $k_B=1$。对于给定的测试用例 $(N, T_1, T_2, \\dots)$，$N$ 个粒子的初始状态按如下方式初始化：\n- 粒子 $i$ 的位置为 $x_i(0) = i$。\n- 粒子 $i$ 的速度为 $v_i(0) = V_0 \\sin(\\frac{\\pi i}{N+1})$，其中 $V_0 = \\sqrt{2 T_{\\mathrm{mid}}}$ 且 $T_{\\mathrm{mid}} = (T_1+T_2)/2$。\n这些状态被存储在 NumPy 数组中，以便进行高效计算。\n\n**2. 数值积分**\n运动方程是一组耦合的二阶常微分方程。选择速度 Verlet 算法，因其具有数值稳定性、时间可逆性和辛性质，这些特性对于力学中的长时间模拟非常有利。对于每个时间步 $\\Delta t$，位置 $x_i(t)$ 和速度 $v_i(t)$ 更新为 $x_i(t+\\Delta t)$ 和 $v_i(t+\\Delta t)$。该算法分两个阶段进行：\n\n首先，速度更新半步，位置更新一整步：\n$$\n\\vec{v}(t + \\tfrac{1}{2}\\Delta t) = \\vec{v}(t) + \\vec{a}(t) \\frac{\\Delta t}{2}\n$$\n$$\n\\vec{x}(t + \\Delta t) = \\vec{x}(t) + \\vec{v}(t + \\tfrac{1}{2}\\Delta t) \\Delta t\n$$\n接下来，使用新的位置 $\\vec{x}(t+\\Delta t)$ 重新计算加速度 $\\vec{a}(t+\\Delta t)$。加速度由下式给出：\n$$\na_i = x_{i-1} + x_{i+1} - 2x_i, \\quad \\text{for } i \\in \\{2, \\ldots, N-1\\}\n$$\n对于 $i=1$ 和 $i=N$，有特定的边界表达式：\n$$\na_1 = x_0 + x_2 - 2x_1 = 0 + x_2 - 2x_1\n$$\n$$\na_N = x_{N-1} + x_{N+1} - 2x_N = x_{N-1} + (N+1) - 2x_N\n$$\n最后，速度更新第二个半步：\n$$\n\\vec{v}(t + \\Delta t) = \\vec{v}(t + \\tfrac{1}{2}\\Delta t) + \\vec{a}(t + \\Delta t) \\frac{\\Delta t}{2}\n$$\n\n**3. 恒温器应用**\n在每个完整的积分步骤之后，对粒子 $1$ 和 $N$ 应用 Berendsen 恒温器。\n对于粒子 $1$，其速度为 $v_1$，目标温度为 $T_1$：\n1.  计算瞬时动能温度：$T_{curr,1} = m v_1^2 / k_B = v_1^2$。\n2.  计算速度缩放因子 $\\lambda_1$。为防止出现除以零或对负数取平方根（当速度波动较大时可能发生）等数值问题，该公式的实现具有鲁棒性：\n    $$\n    \\lambda_1 = \\sqrt{\\max\\left(0, 1 + \\frac{\\Delta t}{\\tau_T}\\left(\\frac{T_1}{T_{curr,1} + \\epsilon}-1\\right)\\right)}\n    $$\n    其中 $\\epsilon$ 是一个很小的正常数，用于处理 $T_{curr,1}=0$ 的情况。\n3.  存储缩放前的动能：$K_{old,1} = \\frac{1}{2}m v_1^2 = 0.5 v_1^2$。\n4.  重缩放速度：$v_1 \\leftarrow \\lambda_1 v_1$。\n5.  计算缩放后的动能：$K_{new,1} = 0.5 (\\lambda_1 v_1)^2$。\n对粒子 $N$ 及其速度 $v_N$ 和目标温度 $T_2$ 应用相同的过程，但其动能变化不需要用于热流计算。\n\n**4. 热流计算**\n热流 $J$ 是左侧恒温器注入的平均功率。在一个时间步 $\\Delta t$ 内注入的瞬时功率近似为 $P_L = (K_{new,1} - K_{old,1}) / \\Delta t$。在瞬态时间 $t_{\\mathrm{trans}}$ 之后的每个步骤，该功率都会被累加。总模拟时间为 $t_{\\mathrm{tot}}$。积分总步数为 $N_{steps,tot} = t_{\\mathrm{tot}} / \\Delta t$，瞬态步数为 $N_{steps,trans} = t_{\\mathrm{trans}} / \\Delta t$。热流 $J$ 是 $P_L$ 在测量窗口内的平均值：\n$$\nJ = \\frac{1}{N_{steps,tot} - N_{steps,trans}} \\sum_{step=N_{steps,trans}}^{N_{steps,tot}-1} P_L(step)\n$$\n对每个测试用例重复此过程，并将最终结果四舍五入到三位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, T1, T2, tau_T, dt, t_tot, t_trans):\n    \"\"\"\n    Performs a non-equilibrium molecular dynamics simulation of heat transport\n    in a 1D harmonic chain with Berendsen thermostats at the ends.\n\n    Args:\n        N (int): Number of particles in the chain.\n        T1 (float): Target temperature for the left thermostat.\n        T2 (float): Target temperature for the right thermostat.\n        tau_T (float): Thermostat coupling time constant.\n        dt (float): Integration time step.\n        t_tot (float): Total simulation time.\n        t_trans (float): Transient time to be discarded for averaging.\n\n    Returns:\n        float: The calculated steady-state heat flux J.\n    \"\"\"\n    # System parameters in reduced units\n    m = 1.0\n    k = 1.0\n    a = 1.0\n    k_B = 1.0\n\n    # Initial conditions\n    # Particle indices from 1 to N\n    i_vals = np.arange(1, N + 1, dtype=float)\n    \n    # Initial positions x_i(0) = i*a\n    x = i_vals * a\n    \n    # Initial velocities v_i(0)\n    T_mid = (T1 + T2) / 2.0\n    V0 = np.sqrt(2.0 * T_mid / m)\n    v = V0 * np.sin(np.pi * i_vals / (N + 1.0))\n\n    # Simulation time steps\n    num_total_steps = int(t_tot / dt)\n    num_trans_steps = int(t_trans / dt)\n\n    # Use a padded position array for easier force calculation\n    # xp[0] is x_0, xp[N+1] is x_{N+1}\n    xp = np.zeros(N + 2)\n    xp[0] = 0.0\n    xp[N + 1] = (N + 1.0) * a\n    \n    # Initial accelerations\n    xp[1:-1] = x\n    # a_i = (k/m) * (x_{i-1} + x_{i+1} - 2x_i)\n    acc = (k / m) * (xp[:-2] + xp[2:] - 2 * xp[1:-1])\n\n    # Measurement variables\n    total_power_injected = 0.0\n    measurement_steps = 0\n\n    # Main simulation loop (Velocity Verlet)\n    for step in range(num_total_steps):\n        # 1. Update velocities for half a time step\n        v += 0.5 * acc * dt\n\n        # 2. Update positions for a full time step\n        x += v * dt\n\n        # 3. Update accelerations using new positions\n        xp[1:-1] = x\n        acc = (k / m) * (xp[:-2] + xp[2:] - 2 * xp[1:-1])\n\n        # 4. Update velocities for the remaining half time step\n        v += 0.5 * acc * dt\n\n        # 5. Apply Berendsen thermostats\n        # Left thermostat (particle i=1, index 0)\n        v1_sq = v[0]**2\n        T_curr_1 = (m * v1_sq) / k_B\n        \n        # Robust calculation of scaling factor\n        # Add a small epsilon to prevent division by zero for T_curr=0\n        arg1 = 1.0 + (dt / tau_T) * (T1 / (T_curr_1 + 1e-15) - 1.0)\n        lambda_1 = np.sqrt(max(0.0, arg1))\n        \n        K_old_L = 0.5 * m * v[0]**2\n        v[0] *= lambda_1\n        K_new_L = 0.5 * m * v[0]**2\n        \n        delta_K_L = K_new_L - K_old_L\n        power_L = delta_K_L / dt\n        \n        # Right thermostat (particle i=N, index N-1)\n        vN_sq = v[-1]**2\n        T_curr_N = (m * vN_sq) / k_B\n        \n        argN = 1.0 + (dt / tau_T) * (T2 / (T_curr_N + 1e-15) - 1.0)\n        lambda_N = np.sqrt(max(0.0, argN))\n        v[-1] *= lambda_N\n\n        # 6. Accumulate heat flux after transient phase\n        if step >= num_trans_steps:\n            total_power_injected += power_L\n            measurement_steps += 1\n\n    # Calculate average heat flux J\n    if measurement_steps > 0:\n        J = total_power_injected / measurement_steps\n    else:\n        J = 0.0\n        \n    return J\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 2.0, 1.0, 0.1, 0.001, 50.0, 20.0),\n        (32, 1.5, 1.5, 0.1, 0.001, 50.0, 20.0),\n        (8, 3.0, 0.5, 0.02, 0.001, 50.0, 20.0),\n        (16, 2.5, 0.5, 1.0, 0.001, 80.0, 40.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T1, T2, tau_T, dt, t_tot, t_trans = case\n        J = run_simulation(N, T1, T2, tau_T, dt, t_tot, t_trans)\n        # Round the result to three decimal places.\n        results.append(str(round(J, 3)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver.\nsolve()\n\n```", "id": "2446245"}]}