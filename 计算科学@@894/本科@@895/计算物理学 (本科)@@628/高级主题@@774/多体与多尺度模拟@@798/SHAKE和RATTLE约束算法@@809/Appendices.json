{"hands_on_practices": [{"introduction": "在分子动力学模拟中，一些化学键非常坚硬，其高频振动要求我们使用极小的时间步长，这使得计算成本非常高昂。约束算法通过用刚性约束代替这些坚硬的键来解决这个问题，从而有效地“冻结”了系统中的快速振动。这个练习将让你直接比较两种建模方法：使用简谐势的柔性键和使用 RATTLE 算法的刚性键。通过亲手实现这两种方法，你将深刻体会到约束算法在计算效率上的巨大优势，并理解其在现代模拟中被广泛应用的原因。[@problem_id:2436794]", "problem": "考虑一个由两个质量为 $m$ 的相同质点组成的平面系统，其运动被约束在二维空间内。设粒子位置为 $\\mathbf{r}_1(t)$ 和 $\\mathbf{r}_2(t)$，速度为 $\\mathbf{v}_1(t)$ 和 $\\mathbf{v}_2(t)$。不存在外场。质心初始位于原点。初始位置为 $\\mathbf{r}_1(0)=(-L/2,0)$ 和 $\\mathbf{r}_2(0)=(+L/2,0)$。初始速度为 $\\mathbf{v}_1(0)=(0,v_0)$ 和 $\\mathbf{v}_2(0)=(0,-v_0)$，因此相对速度与连接两个质点的直线相切。键长参数为 $L>0$。\n\n用两种不同的方式对两个质点之间的键进行建模：\n\n- 模型 A（刚性键）：完整约束为 $g(\\mathbf{r}_1,\\mathbf{r}_2)=\\|\\mathbf{r}_2-\\mathbf{r}_1\\|-L=0$，在所有时间 $t$ 均成立。\n- 模型 B（硬键）：势能为 $U(\\mathbf{r}_1,\\mathbf{r}_2)=\\tfrac{1}{2}k(\\|\\mathbf{r}_2-\\mathbf{r}_1\\|-L)^2$，刚度为 $k>0$。\n\n设模拟总时间为 $T>0$，模型 A 和模型 B 的时间步长分别为 $\\Delta t_{\\mathrm{A}}$ 和 $\\Delta t_{\\mathrm{B}}$。对于每个模型，使用给定的均匀时间步长，将系统从 $t=0$ 演化到 $t=T$。对于每个模型，计算：\n\n- 时间步数 $N_{\\mathrm{A}}=\\lceil T/\\Delta t_{\\mathrm{A}}\\rceil$ 和 $N_{\\mathrm{B}}=\\lceil T/\\Delta t_{\\mathrm{B}}\\rceil$。\n- 均方根键长偏差\n$$\n\\varepsilon_{\\mathrm{rms}}=\\sqrt{\\frac{1}{N+1}\\sum_{n=0}^{N}\\left(\\|\\mathbf{r}_2(t_n)-\\mathbf{r}_1(t_n)\\|-L\\right)^2},\n$$\n以米为单位，其中 $N$ 是相应的步数，$t_n=n\\,\\Delta t$。\n- 绝对能量漂移\n$$\n\\Delta E=\\left|E(T)-E(0)\\right| \\quad \\text{单位为焦耳},\n$$\n对于模型 A，总能量是总动能 $E=\\tfrac{1}{2}m\\|\\mathbf{v}_1\\|^2+\\tfrac{1}{2}m\\|\\mathbf{v}_2\\|^2$；对于模型 B，总能量是动能和势能之和 $E=\\tfrac{1}{2}m\\|\\mathbf{v}_1\\|^2+\\tfrac{1}{2}m\\|\\mathbf{v}_2\\|^2+U$。\n\n使用以下测试套件。每个测试用例以国际单位制（SI units）提供 $(m,L,k,v_0,T,\\Delta t_{\\mathrm{A}},\\Delta t_{\\mathrm{B}})$：\n\n1. 测试用例 1：$m=1.99264687992 \\times 10^{-26}\\,\\text{kg}$，$L=1.0 \\times 10^{-10}\\,\\text{m}$，$k=5.0 \\times 10^{2}\\,\\text{N/m}$，$v_0=1.0 \\times 10^{3}\\,\\text{m/s}$，$T=5.0 \\times 10^{-14}\\,\\text{s}$，$\\Delta t_{\\mathrm{A}}=5.0 \\times 10^{-16}\\,\\text{s}$，$\\Delta t_{\\mathrm{B}}=5.0 \\times 10^{-17}\\,\\text{s}$。\n2. 测试用例 2：$m=1.99264687992 \\times 10^{-26}\\,\\text{kg}$，$L=1.0 \\times 10^{-10}\\,\\text{m}$，$k=5.0 \\times 10^{3}\\,\\text{N/m}$，$v_0=1.0 \\times 10^{3}\\,\\text{m/s}$，$T=5.0 \\times 10^{-14}\\,\\text{s}$，$\\Delta t_{\\mathrm{A}}=5.0 \\times 10^{-16}\\,\\text{s}$，$\\Delta t_{\\mathrm{B}}=1.0 \\times 10^{-17}\\,\\text{s}$。\n3. 测试用例 3：$m=1.99264687992 \\times 10^{-26}\\,\\text{kg}$，$L=1.0 \\times 10^{-10}\\,\\text{m}$，$k=5.0 \\times 10^{3}\\,\\text{N/m}$，$v_0=0.0\\,\\text{m/s}$，$T=5.0 \\times 10^{-14}\\,\\text{s}$，$\\Delta t_{\\mathrm{A}}=5.0 \\times 10^{-16}\\,\\text{s}$，$\\Delta t_{\\mathrm{B}}=1.0 \\times 10^{-17}\\,\\text{s}$。\n\n对于上述顺序中的每个测试用例，您的程序必须按此确切顺序生成以下六个结果：\n\n1. $N_{\\mathrm{A}}$，作为整数。\n2. $N_{\\mathrm{B}}$，作为整数。\n3. 模型 A 的 $\\varepsilon_{\\mathrm{rms}}$，以米为单位，作为浮点数。\n4. 模型 B 的 $\\varepsilon_{\\mathrm{rms}}$，以米为单位，作为浮点数。\n5. 模型 A 的 $\\Delta E$，以焦耳为单位，作为浮点数。\n6. 模型 B 的 $\\Delta E$，以焦耳为单位，作为浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有三个测试用例的所有结果，形式为单个、扁平的、逗号分隔的列表，并用方括号括起来，顺序如上所述，并为每个测试用例重复。例如，一个包含三个测试用例的输出形式为 $[\\text{case1\\_value1},\\text{case1\\_value2},\\ldots,\\text{case3\\_value6}]$。所有距离必须以米为单位，所有能量必须以焦耳为单位。此问题中不出现角度。任何答案中均不含百分比。", "solution": "该问题是良定的、有科学依据且客观的。它提出了一个计算物理学中的标准练习：使用两种不同的粒子间键模型来模拟一个双体系统（双原子分子）。所有的初始条件、参数和评估指标都已明确定义。因此，该问题是有效的，下面提供了解决方案。\n\n### 基于原理的设计\n\n该系统由两个质量为 $m$ 的相同质点组成。在没有外力的情况下，质心（CM）速度是守恒的。给定初始条件 $\\mathbf{r}_1(0)=(-L/2,0)$, $\\mathbf{r}_2(0)=(+L/2,0)$ 和 $\\mathbf{v}_1(0)=(0,v_0)$, $\\mathbf{v}_2(0)=(0,-v_0)$，质心最初静止于原点，并将在所有时间 $t$ 保持在该位置。该系统的动力学可以完全由相对坐标 $\\mathbf{r}(t)=\\mathbf{r}_2(t)-\\mathbf{r}_1(t)$ 来描述。相对运动的初始条件是 $\\mathbf{r}(0) = (L, 0)$ 和 $\\mathbf{v}(0) = (0, -2v_0)$。初始相对速度垂直于键轴，表明系统被设置为旋转。\n\n该问题要求使用两种模型模拟该系统，为此我们选择了在分子动力学中以其稳定性和准确性而著称的合适的数值积分算法。\n\n#### 模型 A：刚性键\n\n在此模型中，键长是一个完整约束：$g(\\mathbf{r}_1, \\mathbf{r}_2) = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\| - L = 0$。该约束必须在所有时间都得到满足。一个用于积分带完整约束的运动方程的标准且稳健的方法是 **RATTLE** 算法。RATTLE 是速度Verlet算法的一种改进，它通过拉格朗日乘子引入约束力，确保位置约束 $g=0$ 和速度约束 $\\dot{g}=0$ 在每个时间步长都得到满足。\n\n由于没有外力或由势能派生的力，算法得以简化。一个基于蛙跳式Verlet方案的RATTLE常见实现，在每个时间步长 $\\Delta t$ 的执行过程如下：\n\n1.  **无约束位置更新**：首先，通过使用当前速度 $\\mathbf{v}_i(t)$ 推进旧位置 $\\mathbf{r}_i(t)$ 来计算新的无约束位置 $\\mathbf{r}'_i$：\n    $$\n    \\mathbf{r}'_i = \\mathbf{r}_i(t) + \\mathbf{v}_i(t) \\Delta t\n    $$\n2.  **SHAKE 校正**：无约束位置 $\\mathbf{r}'_i$ 通常会违反键长约束。SHAKE 过程用于校正这些位置。对每个粒子的校正都沿着键轴方向。对于双粒子系统，这是一个简单的几何校正。设 $\\mathbf{r}'_{21} = \\mathbf{r}'_2 - \\mathbf{r}'_1$。校正后的位置 $\\mathbf{r}_i(t+\\Delta t)$ 为：\n    $$\n    \\mathbf{r}_1(t+\\Delta t) = \\mathbf{r}'_1 + \\alpha \\mathbf{r}'_{21} \\quad ; \\quad \\mathbf{r}_2(t+\\Delta t) = \\mathbf{r}'_2 - \\alpha \\mathbf{r}'_{21}\n    $$\n    其中选择校正因子 $\\alpha$ 以强制执行约束：\n    $$\n    \\alpha = \\frac{1}{2} \\left(1 - \\frac{L}{\\|\\mathbf{r}'_{21}\\|}\\right)\n    $$\n3.  **临时速度更新**：根据新的校正后位置和旧位置之间的变化来计算临时速度：\n    $$\n    \\mathbf{v}'_i = \\frac{\\mathbf{r}_i(t+\\Delta t) - \\mathbf{r}_i(t)}{\\Delta t}\n    $$\n4.  **RATTLE 校正**：必须校正这些临时速度以满足速度约束 $\\dot{g} = (\\mathbf{r}_2-\\mathbf{r}_1)\\cdot(\\mathbf{v}_2-\\mathbf{v}_1) = 0$。该校正移除了平行于键轴的相对速度分量。最终速度 $\\mathbf{v}_i(t+\\Delta t)$ 由以下公式给出：\n    $$\n    \\mathbf{v}_1(t+\\Delta t) = \\mathbf{v}'_1 - \\gamma \\mathbf{r}_{21}(t+\\Delta t) \\quad ; \\quad \\mathbf{v}_2(t+\\Delta t) = \\mathbf{v}'_2 + \\gamma \\mathbf{r}_{21}(t+\\Delta t)\n    $$\n    其中 $\\mathbf{r}_{21}(t+\\Delta t) = \\mathbf{r}_2(t+\\Delta t) - \\mathbf{r}_1(t+\\Delta t)$，因子 $\\gamma$ 为：\n    $$\n    \\gamma = - \\frac{\\mathbf{v}'_{21} \\cdot \\mathbf{r}_{21}(t+\\Delta t)}{2 \\|\\mathbf{r}_{21}(t+\\Delta t)\\|^2} = - \\frac{(\\mathbf{v}'_2 - \\mathbf{v}'_1) \\cdot \\mathbf{r}_{21}(t+\\Delta t)}{2L^2}\n    $$\n此过程确保在满足约束的同时保持良好的能量守恒性，能量守恒性由 $\\Delta E$ 衡量。均方根偏差 $\\varepsilon_{\\mathrm{rms}}$ 将量化满足位置约束时的微小数值误差。\n\n#### 模型 B：硬键\n\n在此模型中，键由一个谐波势 $U = \\frac{1}{2}k(\\|\\mathbf{r}_2-\\mathbf{r}_1\\|-L)^2$ 表示。这定义了粒子间的保守力：\n$$\n\\mathbf{F}_1 = -\\nabla_{\\mathbf{r}_1} U = k(\\|\\mathbf{r}_{21}\\|-L) \\frac{\\mathbf{r}_{21}}{\\|\\mathbf{r}_{21}\\|} \\quad ; \\quad \\mathbf{F}_2 = -\\mathbf{F}_1\n$$\n其中 $\\mathbf{r}_{21} = \\mathbf{r}_2 - \\mathbf{r}_1$。这是一个具有确定势能的标准N体问题。**速度Verlet**算法是该系统的绝佳选择。它是一个辛积分器，这意味着它具有有利的长期能量守恒特性。一个时间步长 $\\Delta t$ 的算法如下：\n\n1.  **半步速度更新**：使用时间 $t$ 的力将速度从 $t$ 更新到 $t+\\Delta t/2$：\n    $$\n    \\mathbf{v}_i(t+\\Delta t/2) = \\mathbf{v}_i(t) + \\frac{\\mathbf{F}_i(t)}{m} \\frac{\\Delta t}{2}\n    $$\n2.  **全步位置更新**：使用半步速度将位置从 $t$ 更新到 $t+\\Delta t$：\n    $$\n    \\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\mathbf{v}_i(t+\\Delta t/2) \\Delta t\n    $$\n3.  **力计算**：使用新位置 $\\mathbf{r}_i(t+\\Delta t)$ 计算新的力 $\\mathbf{F}_i(t+\\Delta t)$。\n4.  **第二半步速度更新**：使用新的力将速度从 $t+\\Delta t/2$ 更新到 $t+\\Delta t$：\n    $$\n    \\mathbf{v}_i(t+\\Delta t) = \\mathbf{v}_i(t+\\Delta t/2) + \\frac{\\mathbf{F}_i(t+\\Delta t)}{m} \\frac{\\Delta t}{2}\n    $$\n该算法演化系统的轨迹，并据此计算度量 $\\varepsilon_{\\mathrm{rms}}$ 和 $\\Delta E$。对于此模型，总能量包括动能和势能项。时间步长 $\\Delta t_{\\mathrm{B}}$ 必须足够小，以解析高频键振动，其特征周期约为 $2\\pi\\sqrt{m/(2k)}$。\n\n### 度量计算\n\n对于两个模型，模拟都运行 $N = \\lceil T/\\Delta t \\rceil$ 步。在每一步 $n=0, 1, \\dots, N$，计算键长以用于计算均方根偏差 $\\varepsilon_{\\mathrm{rms}}$。在 $t=0$ 和 $t=N\\Delta t$ 时计算总能量 $E$，以求得绝对能量漂移 $\\Delta E = |E(t=N\\Delta t)-E(0)|$。", "answer": "```python\nimport numpy as np\n\ndef simulate_model_A(m, L, v0, T, dt):\n    \"\"\"\n    Simulates a two-particle system with a rigid bond using the RATTLE algorithm.\n    \"\"\"\n    N = int(np.ceil(T / dt))\n    \n    r1 = np.array([-L / 2, 0.0], dtype=np.float64)\n    r2 = np.array([L / 2, 0.0], dtype=np.float64)\n    v1 = np.array([0.0, v0], dtype=np.float64)\n    v2 = np.array([0.0, -v0], dtype=np.float64)\n    \n    bond_devs_sq = [(np.linalg.norm(r2 - r1) - L)**2]\n    \n    E0 = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    \n    for _ in range(N):\n        # Unconstrained position update (Verlet-I style)\n        r1_unc = r1 + v1 * dt\n        r2_unc = r2 + v2 * dt\n        \n        # SHAKE correction for positions\n        r21_unc = r2_unc - r1_unc\n        norm_r21_unc = np.linalg.norm(r21_unc)\n        \n        if norm_r21_unc == 0.0:\n            alpha = 0.0\n        else:\n            alpha = 0.5 * (1.0 - L / norm_r21_unc)\n        \n        correction = alpha * r21_unc\n        r1_new = r1_unc + correction\n        r2_new = r2_unc - correction\n        \n        # Provisional velocity update\n        v1_prov = (r1_new - r1) / dt\n        v2_prov = (r2_new - r2) / dt\n        \n        # RATTLE correction for velocities\n        r21_new = r2_new - r1_new\n        v21_prov = v2_prov - v1_prov\n        \n        # Note: ||r21_new|| should be L. Using L*L for stability.\n        r21_dot_v21 = np.dot(r21_new, v21_prov)\n        \n        gamma = -r21_dot_v21 / (2.0 * L**2)\n        \n        vel_correction = gamma * r21_new\n        v1_new = v1_prov - vel_correction\n        v2_new = v2_prov + vel_correction\n        \n        # Update state for next step\n        r1, r2, v1, v2 = r1_new, r2_new, v1_new, v2_new\n        \n        bond_devs_sq.append((np.linalg.norm(r2 - r1) - L)**2)\n        \n    Ef = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    \n    eps_rms = np.sqrt(np.mean(bond_devs_sq))\n    delta_E = np.abs(Ef - E0)\n    \n    return eps_rms, delta_E\n\ndef simulate_model_B(m, L, k, v0, T, dt):\n    \"\"\"\n    Simulates a two-particle system with a stiff bond using the Velocity Verlet algorithm.\n    \"\"\"\n    N = int(np.ceil(T / dt))\n    \n    r1 = np.array([-L / 2, 0.0], dtype=np.float64)\n    r2 = np.array([L / 2, 0.0], dtype=np.float64)\n    v1 = np.array([0.0, v0], dtype=np.float64)\n    v2 = np.array([0.0, -v0], dtype=np.float64)\n    \n    def get_forces(r1_p, r2_p):\n        r21_p = r2_p - r1_p\n        dist = np.linalg.norm(r21_p)\n        if dist == 0.0:\n            return np.zeros(2, dtype=np.float64), np.zeros(2, dtype=np.float64)\n        force_mag = k * (dist - L)\n        f1 = force_mag * (r21_p / dist)\n        return f1, -f1\n\n    dist_init = np.linalg.norm(r2 - r1)\n    bond_devs_sq = [(dist_init - L)**2]\n    \n    U0 = 0.5 * k * (dist_init - L)**2\n    K0 = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    E0 = K0 + U0\n\n    f1, f2 = get_forces(r1, r2)\n    \n    for _ in range(N):\n        # Velocity Verlet integrator\n        v1_half = v1 + (f1 / m) * (dt / 2.0)\n        v2_half = v2 + (f2 / m) * (dt / 2.0)\n        \n        r1_new = r1 + v1_half * dt\n        r2_new = r2 + v2_half * dt\n        \n        f1_new, f2_new = get_forces(r1_new, r2_new)\n        \n        v1_new = v1_half + (f1_new / m) * (dt / 2.0)\n        v2_new = v2_half + (f2_new / m) * (dt / 2.0)\n        \n        # Update state for next step\n        r1, r2, v1, v2 = r1_new, r2_new, v1_new, v2_new\n        f1, f2 = f1_new, f2_new\n        \n        bond_devs_sq.append((np.linalg.norm(r2 - r1) - L)**2)\n\n    dist_f = np.linalg.norm(r2 - r1)\n    Uf = 0.5 * k * (dist_f - L)**2\n    Kf = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    Ef = Kf + Uf\n    \n    eps_rms = np.sqrt(np.mean(bond_devs_sq))\n    delta_E = np.abs(Ef - E0)\n    \n    return eps_rms, delta_E\n\n\ndef solve():\n    test_cases = [\n        (1.99264687992e-26, 1.0e-10, 5.0e2, 1.0e3, 5.0e-14, 5.0e-16, 5.0e-17),\n        (1.99264687992e-26, 1.0e-10, 5.0e3, 1.0e3, 5.0e-14, 5.0e-16, 1.0e-17),\n        (1.99264687992e-26, 1.0e-10, 5.0e3, 0.0, 5.0e-14, 5.0e-16, 1.0e-17)\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        m, L, k, v0, T, dt_A, dt_B = case\n        \n        NA = int(np.ceil(T / dt_A))\n        NB = int(np.ceil(T / dt_B))\n        \n        eps_A, dE_A = simulate_model_A(m, L, v0, T, dt_A)\n        eps_B, dE_B = simulate_model_B(m, L, k, v0, T, dt_B)\n        \n        all_results.extend([NA, NB, eps_A, eps_B, dE_A, dE_B])\n\n    # Format output as a single flat list\n    # Use 'g' format for floating point numbers to avoid unnecessary trailing zeros\n    # and to use scientific notation where appropriate.\n    formatted_results = [f\"{x:.15g}\" if isinstance(x, float) else str(x) for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2436794"}, {"introduction": "用于校正原子位置以满足约束条件的 SHAKE 算法，本质上是一个迭代过程。该算法能否成功收敛以及收敛速度的快慢，取决于系统的特性和模拟参数的选择。在此实践中，你将深入探究 SHAKE 迭代方法的收敛行为。你将首先从第一性原理出发，推导出控制每一步迭代中约束误差如何减小的数学关系。通过分析这一关系，你将揭示积分步长 $\\Delta t$ 与键的自然振动周期之比如何影响算法的收敛性，这对于在实际模拟中选择稳定的时间步长和诊断收敛问题至关重要。[@problem_id:2436783]", "problem": "考虑两个质量相等的点粒子，它们受到一个单一的完整距离约束，该约束将其间距固定在一个预设的键长上。假设在一个无约束预测步结束时，两个粒子的位置由一个相对位移矢量表示，其模的平方为 $s = \\lVert \\mathbf{r}_{12} \\rVert^{2}$。完整约束为 $g(\\mathbf{r}) = \\lVert \\mathbf{r}_{12} \\rVert^{2} - L^{2} = 0$，其中 $L$ 是目标键长。经典的 SHAKE（一种由 Ryckaert、Ciccotti 和 Berendsen 为分子动力学引入的约束投影方法）位置校正应用了一种基于拉格朗日乘数的更新。对于单一距离约束和相等质量的情况，其迭代线性化形式可以写为对相对矢量 $\\mathbf{r}_{12}$ 的更新，形式为 $\\mathbf{r}_{12}^{(k+1)} = \\mathbf{r}_{12}^{(k)} + \\delta \\mathbf{r}_{12}^{(k)}$，其中 $\\delta \\mathbf{r}_{12}^{(k)}$ 与 $\\mathbf{r}_{12}^{(k)}$ 成正比。如果将当前的长度平方误差表示为 $e_{k} = \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^{2} - L^{2}$，则所引发的单约束 SHAKE 迭代会产生一个非线性递推关系 $e_{k+1} = \\Phi(e_{k},L)$。你必须从约束的定义、约束的梯度以及线性化的拉格朗日乘数校正步出发，依据第一性原理推导出这个关系。\n\n你的任务是研究将长度平方误差减小到预设容差以下所需的 SHAKE 迭代次数如何依赖于时间步长与特征键周期时间尺度的比率。使用以下建模假设，使问题自洽且在无量纲单位下普遍适用：\n\n- 假设质量相等且存在单一距离约束 $g(\\mathbf{r}) = \\lVert \\mathbf{r}_{12} \\rVert^{2} - L^{2} = 0$。\n- 使用从带有拉格朗日乘数的完整约束推导出的迭代、线性化的 SHAKE 位置投影步。\n- 设提供给 SHAKE 迭代的初始长度平方误差模型为 $e_{0} = C L^{2} \\left(\\frac{\\Delta t}{T}\\right)^{2}$，其中 $\\Delta t$ 是时间步长，$T$ 是特征键周期时间尺度（例如，振动周期），$C$ 是一个因最快键合运动的运动学而产生的无量纲常数。为明确起见，取 $C = 4\\pi^2$，这对应于当无约束预测器未能提供角频率为 $\\omega = \\frac{2\\pi}{T}$ 的圆周键合运动的向心加速度时，在一个时间步长内产生的主阶偏差。\n- 在无量纲单位下工作，令 $L = 1$，因此所有长度平方误差都是无量纲的。收敛的容差是一个直接应用于 $e_k$ 的相对长度平方误差阈值 $\\tau$，即当 $e_k \\le \\tau$ 时停止迭代。使用 $\\tau = 10^{-12}$。\n\n从牛顿第二定律和通过拉格朗日乘数强制执行的完整约束的定义出发，首先在上述假设下推导出单约束 SHAKE 迭代的显式标量递推关系 $e_{k+1} = \\Phi(e_k,L)$。然后，编写一个完整、可运行的程序，对于下面列出的每个测试用例，计算所需的最小非负整数迭代次数 $N$，使得经过 $N$ 次 SHAKE 迭代后，长度平方误差满足 $e_N \\le \\tau$。\n\n测试套件（每一项指定比率 $\\Delta t / T$）：\n- 情况 A: $\\Delta t / T = 0$\n- 情况 B: $\\Delta t / T = \\frac{1}{50}$\n- 情况 C: $\\Delta t / T = \\frac{1}{20}$\n- 情况 D: $\\Delta t / T = \\frac{1}{10}$\n- 情况 E: $\\Delta t / T = \\frac{1}{5}$\n- 情况 F: $\\Delta t / T = \\frac{1}{2}$\n- 情况 G: $\\Delta t / T = 1$\n\n程序要求：\n- 使用推导出的标量递推关系 $e_{k+1} = \\Phi(e_k,L)$，并设 $L = 1$ 和 $C = 4\\pi^2$，实现单约束迭代 SHAKE 对长度平方误差的更新。\n- 对于每个测试用例，初始化 $e_0 = C \\left(\\frac{\\Delta t}{T}\\right)^{2}$ 并进行迭代，直到 $e_k \\le \\tau$（其中 $\\tau = 10^{-12}$），并计算最小迭代次数 $N$。\n- 程序必须输出一行，其中包含情况 A 到 G 的七个整数 $N$，按顺序排列，作为一个用方括号括起来的逗号分隔列表，例如 `[n_{A},n_{B},n_{C},n_{D},n_{E},n_{F},n_{G}]`。\n\n此公式中没有物理单位；所有量在构造上都是无量纲的。角度（通过 $\\pi$）以弧度处理。最终输出为整数。", "solution": "所述问题在科学上是合理的、提法得当且客观的。它提出了一个关于 SHAKE 算法收敛性质的计算物理学标准练习。该问题是完整的、一致的，并要求基于已建立的数学和物理学原理给出解决方案。因此，该问题是有效的，我将着手解决。\n\n任务有两个方面：首先，从第一性原理出发，为一个简单的双粒子系统推导迭代 SHAKE 过程中长度平方误差的标量递推关系；其次，对这个递推关系进行数值实现，以确定在不同条件下收敛所需的迭代次数。\n\n设两个质量相等的粒子 $m_1 = m_2 = m$ 的位置分别为 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$。完整约束固定了它们之间的距离：\n$$g(\\mathbf{r}_1, \\mathbf{r}_2) = (\\mathbf{r}_1 - \\mathbf{r}_2) \\cdot (\\mathbf{r}_1 - \\mathbf{r}_2) - L^2 = \\lVert \\mathbf{r}_{12} \\rVert^2 - L^2 = 0$$\n其中 $\\mathbf{r}_{12} = \\mathbf{r}_1 - \\mathbf{r}_2$ 是相对位置矢量，$L$ 是预设的键长。\n\nSHAKE 算法是一个迭代过程，用于修正经过无约束积分步更新后的位置，使之满足约束方程。设 $\\mathbf{r}_i^{(k)}$ 是粒子 $i$ 在校正过程第 $k$ 次迭代时的位置，其中 $\\mathbf{r}_i^{(0)}$ 是无约束的预测位置。每一步的校正量 $\\delta \\mathbf{r}_i^{(k)} = \\mathbf{r}_i^{(k+1)} - \\mathbf{r}_i^{(k)}$ 被假定为与在 $\\mathbf{r}^{(k)}$ 处计算的约束函数梯度成正比。对于单个约束，这表示为：\n$$\\delta \\mathbf{r}_i^{(k)} = \\frac{\\lambda_k}{m_i} \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)})$$\n其中 $\\lambda_k$ 是每次迭代时确定的拉格朗日乘数。\n\n拉格朗日乘数 $\\lambda_k$ 是通过在当前位置 $\\mathbf{r}^{(k)}$ 周围对约束方程进行线性化得到的。我们要求 $g(\\mathbf{r}^{(k+1)}) = g(\\mathbf{r}^{(k)} + \\delta \\mathbf{r}^{(k)}) = 0$。一阶泰勒展开得到：\n$$g(\\mathbf{r}^{(k)}) + \\sum_{i=1}^{2} \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)}) \\cdot \\delta \\mathbf{r}_i^{(k)} \\approx 0$$\n代入 $\\delta \\mathbf{r}_i^{(k)}$ 的表达式：\n$$g(\\mathbf{r}^{(k)}) + \\lambda_k \\sum_{i=1}^{2} \\frac{1}{m_i} \\lVert \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)}) \\rVert^2 = 0$$\n求解 $\\lambda_k$ 得到迭代拉格朗日乘数的一般表达式：\n$$\\lambda_k = - \\frac{g(\\mathbf{r}^{(k)})}{\\sum_{i=1}^{2} \\frac{1}{m_i} \\lVert \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)}) \\rVert^2}$$\n\n现在，我们将此形式应用于我们的特定系统。约束函数 $g(\\mathbf{r}_{12}) = \\lVert \\mathbf{r}_{12} \\rVert^2 - L^2$ 的梯度是：\n$$\\nabla_{\\mathbf{r}_1} g = 2\\mathbf{r}_{12}$$\n$$\\nabla_{\\mathbf{r}_2} g = -2\\mathbf{r}_{12}$$\n使用 $m_1=m_2=m$，$\\lambda_k$ 表达式中的分母变为：\n$$\\sum_{i=1}^{2} \\frac{1}{m_i} \\lVert \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}_{12}^{(k)}) \\rVert^2 = \\frac{1}{m} \\lVert 2\\mathbf{r}_{12}^{(k)} \\rVert^2 + \\frac{1}{m} \\lVert -2\\mathbf{r}_{12}^{(k)} \\rVert^2 = \\frac{4}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 + \\frac{4}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 = \\frac{8}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2$$\n在第 $k$ 次迭代时计算的约束函数本身为 $g(\\mathbf{r}_{12}^{(k)}) = \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2$。\n将这些代入 $\\lambda_k$ 的表达式中：\n$$\\lambda_k = - \\frac{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2}{\\frac{8}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2}$$\n\n相对位置矢量 $\\mathbf{r}_{12}$ 的更新规则由单个粒子的更新导出：\n$$\\mathbf{r}_{12}^{(k+1)} = \\mathbf{r}_1^{(k+1)} - \\mathbf{r}_2^{(k+1)} = (\\mathbf{r}_1^{(k)} + \\delta \\mathbf{r}_1^{(k)}) - (\\mathbf{r}_2^{(k)} + \\delta \\mathbf{r}_2^{(k)}) = \\mathbf{r}_{12}^{(k)} + (\\delta \\mathbf{r}_1^{(k)} - \\delta \\mathbf{r}_2^{(k)})$$\n使用梯度表达式：\n$$\\delta \\mathbf{r}_1^{(k)} - \\delta \\mathbf{r}_2^{(k)} = \\frac{\\lambda_k}{m} (2\\mathbf{r}_{12}^{(k)}) - \\frac{\\lambda_k}{m} (-2\\mathbf{r}_{12}^{(k)}) = \\frac{4\\lambda_k}{m} \\mathbf{r}_{12}^{(k)}$$\n因此，矢量更新规则为：\n$$\\mathbf{r}_{12}^{(k+1)} = \\mathbf{r}_{12}^{(k)} + \\frac{4\\lambda_k}{m} \\mathbf{r}_{12}^{(k)} = \\mathbf{r}_{12}^{(k)} \\left(1 + \\frac{4\\lambda_k}{m}\\right)$$\n代入已导出的 $\\lambda_k$ 表达式：\n$$\\mathbf{r}_{12}^{(k+1)} = \\mathbf{r}_{12}^{(k)} \\left(1 + \\frac{4}{m} \\left( - \\frac{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2}{\\frac{8}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2} \\right) \\right) = \\mathbf{r}_{12}^{(k)} \\left(1 - \\frac{1}{2} \\frac{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2}{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2} \\right)$$\n为了找到长度平方误差 $e_k = \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2$ 的递推关系，我们取矢量更新方程的模的平方：\n$$\\lVert \\mathbf{r}_{12}^{(k+1)} \\rVert^2 = \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 \\left(1 - \\frac{1}{2} \\frac{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2}{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2} \\right)^2$$\n让我们引入误差定义 $\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 = e_k + L^2$。下一个误差是 $e_{k+1} = \\lVert \\mathbf{r}_{12}^{(k+1)} \\rVert^2 - L^2$。\n$$e_{k+1} + L^2 = (e_k + L^2) \\left(\\frac{e_k + 2L^2}{2(e_k + L^2)}\\right)^2 = (e_k + L^2) \\frac{(e_k + 2L^2)^2}{4(e_k + L^2)^2} = \\frac{(e_k + 2L^2)^2}{4(e_k + L^2)}$$\n$$e_{k+1} + L^2 = \\frac{e_k^2 + 4e_k L^2 + 4L^4}{4(e_k + L^2)}$$\n分离出 $e_{k+1}$：\n$$e_{k+1} = \\frac{e_k^2 + 4e_k L^2 + 4L^4}{4(e_k + L^2)} - L^2 = \\frac{e_k^2 + 4e_k L^2 + 4L^4 - 4L^2(e_k + L^2)}{4(e_k + L^2)}$$\n$$e_{k+1} = \\frac{e_k^2 + 4e_k L^2 + 4L^4 - 4e_k L^2 - 4L^4}{4(e_k + L^2)}$$\n这简化为长度平方误差的最终递推关系：\n$$e_{k+1} = \\frac{e_k^2}{4(e_k + L^2)}$$\n这个关系表明 SHAKE 算法对于小误差（$e_k \\ll L^2$）具有二次收敛性，此时 $e_{k+1} \\approx e_k^2 / (4L^2)$。\n\n有了这个推导出的递推关系，我们按照问题陈述的要求进行数值计算。我们使用 $L=1$，$C = 4\\pi^2$，以及收敛容差 $\\tau = 10^{-12}$。每个测试用例的初始误差是 $e_0 = C (\\Delta t / T)^2$。我们寻找最小的非负整数 $N$，使得 $e_N \\le \\tau$。最终答案中列出的程序实现了这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SHAKE iteration problem for a suite of test cases.\n    It calculates the number of iterations N required for the squared-length\n    error to fall below a specified tolerance.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is the ratio of timestep to characteristic period, dt/T.\n    test_cases = [\n        0.0,          # Case A\n        1.0 / 50.0,   # Case B\n        1.0 / 20.0,   # Case C\n        1.0 / 10.0,   # Case D\n        1.0 / 5.0,    # Case E\n        1.0 / 2.0,    # Case F\n        1.0,          # Case G\n    ]\n\n    results = []\n    for dt_T_ratio in test_cases:\n        n_iterations = calculate_shake_iterations(dt_T_ratio)\n        results.append(n_iterations)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_shake_iterations(dt_T_ratio: float) -> int:\n    \"\"\"\n    Computes the minimal number of SHAKE iterations N for convergence.\n\n    Args:\n        dt_T_ratio: The ratio of the timestep dt to the characteristic\n                    bond period T.\n\n    Returns:\n        The minimal non-negative integer number of iterations N.\n    \"\"\"\n    # Parameters from the problem statement\n    l_bond = 1.0  # Dimensionless bond length\n    const_c = 4.0 * np.pi**2\n    tolerance = 1.0e-12\n\n    # Initial squared-length error e_0\n    # e_0 = C * L^2 * (dt/T)^2\n    e_k = const_c * (l_bond**2) * (dt_T_ratio**2)\n\n    # The problem asks for the minimal non-negative integer N such that e_N <= tau.\n    # We must first check the condition for N = 0.\n    if e_k <= tolerance:\n        return 0\n\n    n = 0\n    # The derived recurrence is e_{k+1} = e_k^2 / (4 * (e_k + L^2))\n    # Since L=1, this is e_{k+1} = e_k^2 / (4 * (e_k + 1))\n    # We iterate until the error is below the tolerance.\n    while True:\n        # Since e_0 is non-negative, and the recurrence maintains non-negativity,\n        # e_k will always be non-negative.\n        e_k = e_k**2 / (4.0 * (e_k + l_bond**2))\n        n += 1\n        if e_k <= tolerance:\n            return n\n\n# Execute the main function.\nsolve()\n```", "id": "2436783"}]}