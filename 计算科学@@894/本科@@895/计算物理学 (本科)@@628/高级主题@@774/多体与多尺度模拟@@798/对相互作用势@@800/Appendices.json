{"hands_on_practices": [{"introduction": "第一个动手实践将带你深入探究对势相互作用的核心——势能面。你将确定一个由 Lennard-Jones 势相互作用的小粒子团簇的最稳定（基态）构型。这个练习 [@problem_id:2423729] 对于理解几何构型如何决定能量稳定性至关重要，并介绍了能量最小化这一计算化学和物理学的基石任务。", "problem": "您需要编写一个完整的、可运行的程序，该程序使用约化的 Lennard-Jones (LJ) 单位，确定并比较一个由 $N=13$ 个通过 Lennard-Jones 对势相互作用的粒子组成的团簇在两种高度对称构型下的最低对势能。这两种构型分别是 $N=13$ 的二十面体团簇和 $N=13$ 的面心立方 (FCC) 立方八面体团簇，每种构型都包含一个位于原点的粒子，并由12个位于相应多面体顶点的粒子包围。所有能量必须以约化的 LJ 能量单位（即以 $\\varepsilon$ 为单位）报告，所有距离必须以约化的 LJ 距离单位（即以 $\\sigma$ 为单位）报告，如果使用角度，则必须以弧度为单位。\n\n基础原理：\n- 两个相距为 $r$ 的粒子之间的 Lennard-Jones 对势为\n$$\nU(r)=4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6}\\right].\n$$\n- 对于一个包含 $N$ 个粒子、位置为 $\\{\\mathbf{r}_i\\}_{i=1}^{N}$ 的系统，其总势能为\n$$\nE=\\sum_{1\\le i<j\\le N}U\\!\\left(\\left\\lVert \\mathbf{r}_i-\\mathbf{r}_j\\right\\rVert\\right).\n$$\n- 刚性平移和旋转不会改变任何粒子间的距离，因此，总能量在刚性运动下保持不变。\n\n您的任务是：\n- 为这两个 $N=13$ 的模板构建坐标：\n  - 二十面体 (Icosahedral)：一个粒子位于原点，12个粒子位于由规范笛卡尔坐标集 $\\{(0,\\pm 1,\\pm \\varphi),(\\pm 1,\\pm \\varphi,0),(\\pm \\varphi,0,\\pm 1)\\}$ 定义的正二十面体的顶点上，其中 $\\varphi=(1+\\sqrt{5})/2$。\n  - 面心立方 (FCC) 立方八面体 (Face-Centered Cubic (FCC) cuboctahedral)：一个粒子位于原点，12个粒子位于由 $(0,\\pm 1,\\pm 1)$ 的所有不同排列给出的顶点上。\n- 将每个模板视为通过一个应用于所有坐标的正比例因子 $s>0$ 进行均匀缩放的构型。\n- 仅从上述定义出发，推导出均匀缩放构型的总能量作为 $s$ 的函数，并利用此函数确定使每个模板总能量最小化的 $s$ 值。通过设置 $\\varepsilon=\\sigma=1$ 将所有结果以约化的 LJ 单位表示。\n- 科学地论证为什么能量在刚性旋转和平移下保持不变。\n\n数值和算法要求：\n- 实现计算以下总和的算法\n$$\nS_6=\\sum_{1\\le i<j\\le N}\\frac{1}{r_{ij,0}^{6}},\\qquad S_{12}=\\sum_{1\\le i<j\\le N}\\frac{1}{r_{ij,0}^{12}},\n$$\n其中 $r_{ij,0}$ 是未缩放模板（$s=1$）中的对距离。使用这些总和来确定每个模板的能量最小化比例因子 $s^\\star$ 及相应的最小化能量。所有计算必须在约化单位下进行，即 $\\varepsilon=\\sigma=1$。\n- 通过计算对优化后的二十面体构型进行固定的刚性旋转和刚性平移后的能量，来验证能量不变性。使用绕与 $(1,2,3)$ 成比例的轴旋转角度 $\\theta=0.789$ 的旋转，以及平移向量 $(0.3,-1.1,2.0)$。角度必须以弧度为单位。\n\n测试套件和输出规范：\n- 使用以下测试用例，并按指定顺序生成所要求的输出。最终输出必须是单行文本，包含一个逗号分隔的 Python 风格列表，无任何多余文本。该列表必须包含：\n  1. 二十面体构型的最小化总能量（浮点数）。\n  2. FCC 立方八面体构型的最小化总能量（浮点数）。\n  3. 一个布尔值，指示二十面体构型的最小化能量是否严格低于 FCC 立方八面体构型的最小化能量。\n  4. 一个布尔值，指示二十面体构型的能量在指定的刚性旋转下是否保持不变（在 $10^{-10}$ 绝对能量单位的容差范围内）。\n  5. 一个布尔值，指示二十面体构型的能量在指定的刚性平移下是否保持不变（在 $10^{-10}$ 绝对能量单位的容差范围内）。\n  6. 一个布尔值，指示对于二十面体构型，在 $s=0.5\\,s^\\star$ 时的能量是否高于最小化能量。\n  7. 一个布尔值，指示对于二十面体构型，在 $s=2.0\\,s^\\star$ 时的能量是否高于最小化能量。\n- 角度输入以弧度为单位。能量必须以约化的 LJ 能量单位（即以 $\\varepsilon$ 为单位）表示。距离以约化的 LJ 距离单位（即以 $\\sigma$ 为单位）表示。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 \"[result1,result2,result3,result4,result5,result6,result7]\"。浮点数必须精确打印到小数点后 $8$ 位。\n\n在所有步骤中确保科学真实性和内部一致性。您的程序必须是完全确定性的，不需要用户输入，并且能够直接运行。", "solution": "问题陈述经评估有效。它在科学上基于计算物理学的原理，特别是使用 Lennard-Jones 势来模拟原子团簇的能量学。该问题定义明确，为确定性解法提供了所有必要的定义、常数和清晰的目标。其语言客观，结构逻辑一致，没有矛盾或含糊之处。\n\n一个由 $N$ 个粒子通过 Lennard-Jones (LJ) 对势相互作用的系统的总势能 $E$ 由所有唯一粒子对 $(i, j)$ 的总和给出：\n$$\nE = \\sum_{1 \\le i < j \\le N} U(\\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert)\n$$\n在约化单位中，能量单位 $\\varepsilon=1$ 且长度单位 $\\sigma=1$，LJ 势简化为：\n$$\nU(r) = 4 \\left[ \\left(\\frac{1}{r}\\right)^{12} - \\left(\\frac{1}{r}\\right)^{6} \\right]\n$$\n问题考虑的是通过一个正因子 $s > 0$ 均匀缩放基础坐标模板 $\\{\\mathbf{r}_{i,0}\\}$ 生成的构型。第 $i$ 个粒子的位置是 $\\mathbf{r}_i = s \\cdot \\mathbf{r}_{i,0}$。因此，粒子 $i$ 和 $j$ 之间的距离 $r_{ij}$ 也被 $s$ 缩放：\n$$\nr_{ij} = \\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert = \\left\\lVert s \\cdot \\mathbf{r}_{i,0} - s \\cdot \\mathbf{r}_{j,0} \\right\\rVert = s \\left\\lVert \\mathbf{r}_{i,0} - \\mathbf{r}_{j,0} \\right\\rVert = s \\cdot r_{ij,0}\n$$\n其中 $r_{ij,0}$ 是未缩放模板中的距离（即 $s=1$ 时）。\n\n将此缩放后的距离代入能量表达式，总能量 $E$ 成为 $s$ 的函数：\n$$\nE(s) = \\sum_{1 \\le i < j \\le N} 4 \\left[ \\left(\\frac{1}{s \\cdot r_{ij,0}}\\right)^{12} - \\left(\\frac{1}{s \\cdot r_{ij,0}}\\right)^{6} \\right]\n$$\n通过提出包含 $s$ 的项，我们可以将团簇的几何结构与缩放分离开来：\n$$\nE(s) = 4 \\left[ \\frac{1}{s^{12}} \\sum_{1 \\le i < j \\le N} \\frac{1}{r_{ij,0}^{12}} - \\frac{1}{s^6} \\sum_{1 \\le i < j \\le N} \\frac{1}{r_{ij,0}^6} \\right]\n$$\n我们定义几何和 $S_{12}$ 和 $S_6$，它们仅依赖于固定的模板几何结构：\n$$\nS_{12} = \\sum_{1 \\le i < j \\le N} \\frac{1}{r_{ij,0}^{12}}, \\qquad S_6 = \\sum_{1 \\le i < j \\le N} \\frac{1}{r_{ij,0}^6}\n$$\n总能量作为比例因子 $s$ 的函数，可以优雅地表示为：\n$$\nE(s) = 4 \\left( \\frac{S_{12}}{s^{12}} - \\frac{S_6}{s^6} \\right)\n$$\n为找到使能量最小化的比例因子 $s^\\star$，我们必须求解 $E(s)$ 对 $s$ 的导数为零时的 $s$：\n$$\n\\frac{dE}{ds} = 4 \\left( -12 \\frac{S_{12}}{s^{13}} + 6 \\frac{S_6}{s^7} \\right) = 0\n$$\n求解 $s$（我们记为 $s^\\star$）可得：\n$$\n12 \\frac{S_{12}}{(s^\\star)^{13}} = 6 \\frac{S_6}{(s^\\star)^7} \\implies 2 S_{12} = S_6 (s^\\star)^6 \\implies (s^\\star)^6 = \\frac{2 S_{12}}{S_6}\n$$\n因此，最优比例因子为：\n$$\ns^\\star = \\left( \\frac{2 S_{12}}{S_6} \\right)^{1/6}\n$$\n最小能量 $E^\\star = E(s^\\star)$ 可通过将 $(s^\\star)^6$ 和 $(s^\\star)^{12} = ( (s^\\star)^6 )^2 = \\left(\\frac{2 S_{12}}{S_6}\\right)^2$ 代回能量函数求得：\n$$\nE^\\star = 4 \\left( S_{12} \\left[ \\left(\\frac{S_6}{2 S_{12}}\\right)^2 \\right] - S_6 \\left[ \\frac{S_6}{2 S_{12}} \\right] \\right) = 4 \\left( \\frac{S_6^2}{4 S_{12}} - \\frac{S_6^2}{2 S_{12}} \\right) = 4 \\left( -\\frac{S_6^2}{4 S_{12}} \\right)\n$$\n这简化为缩放结构的最小势能：\n$$\nE^\\star = -\\frac{S_6^2}{S_{12}}\n$$\n这一基本结果表明，最小能量完全由未缩放粒子构型的几何特性决定。\n\n总能量在刚性运动（平移和旋转）下的不变性是势能仅依赖于粒子间距离的直接结果。\n- **平移不变性**：假设每个粒子的位置向量 $\\mathbf{r}_i$ 被一个常数向量 $\\mathbf{v}$ 平移到一个新位置 $\\mathbf{r}_i' = \\mathbf{r}_i + \\mathbf{v}$。任意两个粒子之间的向量差保持不变：$\\mathbf{r}_i' - \\mathbf{r}_j' = (\\mathbf{r}_i + \\mathbf{v}) - (\\mathbf{r}_j + \\mathbf{v}) = \\mathbf{r}_i - \\mathbf{r}_j$。因此，距离 $\\left\\lVert \\mathbf{r}_i' - \\mathbf{r}_j' \\right\\rVert = \\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert$ 是不变的。由于所有对距离都未改变，总能量 $E$ 保持不变。\n- **旋转不变性**：假设每个粒子的位置向量 $\\mathbf{r}_i$ 通过一个旋转矩阵 $R$ 变换，得到一个新位置 $\\mathbf{r}_i' = R \\mathbf{r}_i$。旋转是等距变换，意味着它们保持距离不变。两个旋转后点之间的距离平方是 $\\left\\lVert \\mathbf{r}_i' - \\mathbf{r}_j' \\right\\rVert^2 = \\left\\lVert R(\\mathbf{r}_i - \\mathbf{r}_j) \\right\\rVert^2 = (\\mathbf{r}_i - \\mathbf{r}_j)^T R^T R (\\mathbf{r}_i - \\mathbf{r}_j)$。由于 $R$ 是一个正交矩阵，$R^T R = I$（单位矩阵），所以 $\\left\\lVert \\mathbf{r}_i' - \\mathbf{r}_j' \\right\\rVert^2 = \\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert^2$。标量距离得以保持，因此总能量 $E$ 是不变的。\n\n计算流程如下：\n1.  生成 $N=13$ 二十面体和 FCC 立方八面体团簇的未缩放坐标。二十面体顶点使用黄金比例 $\\varphi = (1+\\sqrt{5})/2$。\n2.  对每个模板，计算所有唯一的对距离 $r_{ij,0}$，并用它们来计算几何和 $S_6$ 与 $S_{12}$。\n3.  使用推导出的公式 $E^\\star = -S_6^2 / S_{12}$ 计算每种构型的最小化能量 $E^\\star$。\n4.  对于二十面体团簇，计算最优比例因子 $s^\\star_{ico}$ 并缩放模板坐标以获得能量最小化的位置 $\\{\\mathbf{r}_i^\\star\\}$。\n5.  通过对优化的二十面体坐标应用指定的旋转（绕轴 $(1,2,3)$ 旋转角度 $\\theta=0.789$ 弧度）和平移（向量 $(0.3,-1.1,2.0)$）来验证能量不变性。计算变换后坐标的能量，并与原始最小化能量在 $10^{-10}$ 的容差范围内进行比较。\n6.  最后，计算二十面体构型在 $s = 0.5 s^\\star_{ico}$ 和 $s = 2.0 s^\\star_{ico}$ 时的能量，以确认这些能量高于最小值，这与势阱的性质相符。\n所有计算均在约化的 LJ 单位（$\\varepsilon=1$, $\\sigma=1$）下进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nfrom scipy.spatial.distance import pdist\n\ndef solve():\n    \"\"\"\n    Computes and compares the minimum potential energies for N=13\n    Lennard-Jones clusters in icosahedral and FCC cuboctahedral configurations.\n    \"\"\"\n\n    def get_cluster_coordinates(name: str) -> np.ndarray:\n        \"\"\"Generates the template coordinates for a given cluster type.\"\"\"\n        if name == 'icosahedron':\n            phi = (1.0 + np.sqrt(5.0)) / 2.0\n            vertices = [\n                (0, 1, phi), (0, 1, -phi), (0, -1, phi), (0, -1, -phi),\n                (1, phi, 0), (1, -phi, 0), (-1, phi, 0), (-1, -phi, 0),\n                (phi, 0, 1), (-phi, 0, 1), (phi, 0, -1), (-phi, 0, -1)\n            ]\n        elif name == 'fcc_cuboctahedron':\n            vertices = [\n                (1, 1, 0), (1, -1, 0), (-1, 1, 0), (-1, -1, 0),\n                (1, 0, 1), (1, 0, -1), (-1, 0, 1), (-1, 0, -1),\n                (0, 1, 1), (0, 1, -1), (0, -1, 1), (0, -1, -1)\n            ]\n        else:\n            raise ValueError(\"Unknown cluster name\")\n\n        coords = np.array([(0.0, 0.0, 0.0)] + vertices, dtype=np.float64)\n        return coords\n\n    def compute_geometric_sums(coords: np.ndarray) -> tuple[float, float]:\n        \"\"\"Computes the geometric sums S6 and S12 from coordinates.\"\"\"\n        # pdist computes the condensed distance matrix (upper triangle)\n        distances = pdist(coords)\n        \n        # Element-wise exponentiation\n        inv_dists_6 = np.power(distances, -6)\n        inv_dists_12 = np.power(distances, -12)\n\n        s6 = np.sum(inv_dists_6)\n        s12 = np.sum(inv_dists_12)\n        \n        return s6, s12\n\n    def calculate_total_energy(coords: np.ndarray) -> float:\n        \"\"\"Computes the total LJ potential energy for a set of coordinates.\"\"\"\n        distances = pdist(coords)\n        inv_dists_6 = np.power(distances, -6)\n        inv_dists_12 = np.power(distances, -12)\n        energy = 4.0 * (np.sum(inv_dists_12) - np.sum(inv_dists_6))\n        return energy\n\n    # --- Icosahedral Cluster ---\n    coords_ico_0 = get_cluster_coordinates('icosahedron')\n    S6_ico, S12_ico = compute_geometric_sums(coords_ico_0)\n    E_ico_min = -S6_ico**2 / S12_ico\n    s_ico_star = (2 * S12_ico / S6_ico)**(1/6)\n\n    # --- FCC Cuboctahedral Cluster ---\n    coords_fcc_0 = get_cluster_coordinates('fcc_cuboctahedron')\n    S6_fcc, S12_fcc = compute_geometric_sums(coords_fcc_0)\n    E_fcc_min = -S6_fcc**2 / S12_fcc\n\n    # 1. Minimized energy for icosahedral configuration\n    result1 = E_ico_min\n    \n    # 2. Minimized energy for FCC cuboctahedral configuration\n    result2 = E_fcc_min\n\n    # 3. Boolean: Is icosahedral energy lower than FCC?\n    result3 = result1 < result2\n\n    # --- Verification for Icosahedral Cluster ---\n    coords_ico_opt = coords_ico_0 * s_ico_star\n    E_ref = calculate_total_energy(coords_ico_opt)\n\n    # 4. Rotation Invariance Test\n    theta = 0.789\n    axis = np.array([1.0, 2.0, 3.0])\n    rot_vec = theta * axis / np.linalg.norm(axis)\n    rotation = Rotation.from_rotvec(rot_vec)\n    coords_ico_rot = rotation.apply(coords_ico_opt)\n    E_rot = calculate_total_energy(coords_ico_rot)\n    result4 = np.isclose(E_ref, E_rot, rtol=0, atol=1e-10)\n\n    # 5. Translation Invariance Test\n    trans_vec = np.array([0.3, -1.1, 2.0])\n    coords_ico_trans = coords_ico_opt + trans_vec\n    E_trans = calculate_total_energy(coords_ico_trans)\n    result5 = np.isclose(E_ref, E_trans, rtol=0, atol=1e-10)\n    \n    # --- Energy Landscape Test for Icosahedral Cluster ---\n    # Energy function E(s) = 4 * (S12/s^12 - S6/s^6)\n    \n    # 6. Energy at s = 0.5 * s_star\n    s1 = 0.5 * s_ico_star\n    E_s1 = 4.0 * (S12_ico / s1**12 - S6_ico / s1**6)\n    result6 = E_s1 > E_ico_min\n\n    # 7. Energy at s = 2.0 * s_star\n    s2 = 2.0 * s_ico_star\n    E_s2 = 4.0 * (S12_ico / s2**12 - S6_ico / s2**6)\n    result7 = E_s2 > E_ico_min\n\n    results = [result1, result2, result3, result4, result5, result6, result7]\n\n    # Format the final output string\n    formatted_results = [\n        f\"{results[0]:.8f}\",\n        f\"{results[1]:.8f}\",\n        str(results[2]),\n        str(results[3]),\n        str(results[4]),\n        str(results[5]),\n        str(results[6])\n    ]\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2423729"}, {"introduction": "在静态能量概念的基础上，这个实践将你带入分子动力学（MD）模拟的动态世界。你将实现一个粒子在排斥势下相互作用的模拟，并观察它们随时间的运动。这个练习 [@problem_id:2423746] 将指导你如何从势函数推导力，如何实现数值积分器来求解牛顿运动方程，以及如何处理边界条件——这些都是模拟任何粒子系统所需的核心技能。", "problem": "您的任务是推导并实现一种纯排斥的成对相互作用势，适用于在受限立方体体积内模拟粒子的“反重力”爆炸。请在无量纲单位下进行计算，以使所有报告的结果均为无量纲数。受限体积是一个边长为 $L$ 的立方体，由 $[0,L]^3$ 定义，其壁面为镜面反射（完全弹性）。所有粒子具有相等的质量 $m$。\n\n起点和定义：\n- 从应用于每个粒子 $i$ 的牛顿第二定律 $\\mathbf{F}_i = m \\,\\ddot{\\mathbf{r}}_i$ 和保守力的定义 $\\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} U$ 开始，其中 $U$ 是总势能。\n- 对于相距 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$ 的粒子 $i$ 和 $j$，使用一种纯排斥、软核、反比距离势：\n$$\nV(r_{ij}) = \\frac{C}{\\sqrt{r_{ij}^2 + s^2}},\n$$\n其中 $C > 0$ 且 $s > 0$。总势能为 $U = \\sum_{i<j} V(r_{ij})$。\n- 从 $V(r_{ij})$ 推导由粒子 $j$ 施加于粒子 $i$ 的显式成对力，进而推导出总加速度 $\\ddot{\\mathbf{r}}_i$。\n\n时间积分：\n- 基于泰勒展开，推导出一个与分子动力学 (MD) 一致的、用于更新位置和速度的二阶精度、时间可逆的更新规则。使用时间步长为 $\\Delta t$ 的速度 Verlet 算法。\n- 在墙壁处施加镜面反射：当一个粒子穿过外法线为 $\\hat{\\mathbf{n}}$ 的墙壁时，其速度瞬时映射为 $\\mathbf{v} \\mapsto \\mathbf{v} - 2(\\mathbf{v}\\cdot \\hat{\\mathbf{n}})\\hat{\\mathbf{n}}$，其位置被反射回 $[0,L]^3$ 区域内。\n\n能量：\n- 将总能量定义为\n$$\nE = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}_i \\rVert^2 + \\sum_{i<j} V(r_{ij}).\n$$\n对于在某个时间区间内没有墙壁碰撞的模拟，速度 Verlet 方法应近似地使 $E$ 守恒，其误差随着 $\\Delta t \\to 0$ 而减小。\n\n实现要求：\n- 严格按照上述定义，实现所推导的力、加速度和带有反射边界条件的速度 Verlet 积分器。\n- 对所有测试用例使用以下固定的全局参数：$m = 1$，$C = 1$，$s = 0.1$，$L = 10$。\n- 即使单个时间步导致粒子穿过边界超过一个墙壁厚度，也应稳健地处理反射；确保在单个步骤中，沿某个轴的每次穿越都会导致相应速度分量的一次反转，并计为一次反射事件。\n\n测试套件：\n实现四个独立的模拟，采用以下初始条件和时间积分设置。每个模拟从时间 $t=0$ 开始，使用给定的 $\\Delta t$ 和恒定的时间步数 $N_{\\text{steps}} = T / \\Delta t$ 推进到 $t = T$（假设 $T$ 是 $\\Delta t$ 的整数倍）。\n\n- 测试 $1$（双体排斥，间距增长）：\n  - $N = 2$。\n  - 初始位置：$\\mathbf{r}_1(0) = (4.0, 5.0, 5.0)$，$\\mathbf{r}_2(0) = (6.0, 5.0, 5.0)$。\n  - 初始速度：$\\mathbf{v}_1(0) = (0.0, 0.0, 0.0)$，$\\mathbf{v}_2(0) = (0.0, 0.0, 0.0)$。\n  - $\\Delta t = 1.0 \\times 10^{-3}$，$T = 0.5$。\n  - 要求的结果：最终的中心距 $r_{12}(T)$，以浮点数形式表示。\n\n- 测试 $2$（无墙壁碰撞时的能量守恒）：\n  - $N = 3$。\n  - 将三个粒子放置在平面 $z=5.0$ 上、以 $(5.0, 5.0, 5.0)$ 为中心的一个边长为 $a = 1.0$ 的等边三角形的顶点上。设 $R = a/\\sqrt{3}$。使用：\n    - $\\mathbf{r}_1(0) = (5.0 + R, 5.0, 5.0)$，\n    - $\\mathbf{r}_2(0) = (5.0 - R/2, 5.0 + (\\sqrt{3}/2)R, 5.0)$，\n    - $\\mathbf{r}_3(0) = (5.0 - R/2, 5.0 - (\\sqrt{3}/2)R, 5.0)$。\n  - 初始速度：全部为零，$\\mathbf{v}_i(0) = (0.0, 0.0, 0.0)$ 对于 $i \\in \\{1,2,3\\}$。\n  - $\\Delta t = 5.0 \\times 10^{-4}$，$T = 0.2$。\n  - 要求的结果：最终时刻的绝对相对能量误差 $\\left|E(T) - E(0)\\right| / E(0)$，以浮点数形式表示。\n\n- 测试 $3$（单粒子墙壁反射）：\n  - $N = 1$。\n  - 初始位置：$\\mathbf{r}_1(0) = (2.0, 5.0, 5.0)$。\n  - 初始速度：$\\mathbf{v}_1(0) = (3.0, 0.0, 0.0)$。\n  - $\\Delta t = 1.0 \\times 10^{-3}$，$T = 3.0$。\n  - 要求的结果：最终速度的 $x$ 分量 $v_{1x}(T)$，以浮点数形式表示。\n\n- 测试 $4$（多体“爆炸”与墙壁接触运动学）：\n  - $N = 8$。\n  - 初始位置：以 $(5.0, 5.0, 5.0)$ 为中心、边长为 $0.2$ 的立方体的八个顶点，即在 $(5.0, 5.0, 5.0)$ 的基础上加上所有 $(\\pm 0.1, \\pm 0.1, \\pm 0.1)$ 的偏移组合。\n  - 初始速度：全部为零。\n  - $\\Delta t = 1.0 \\times 10^{-3}$，$T = 1.5$。\n  - 要求的结果：在运行期间，所有粒子在所有轴上累积的墙壁反射总次数，以整数形式表示。每次因穿越墙壁导致的速度分量反转计为一次反射。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按顺序排列的四个测试结果，格式为方括号内的逗号分隔列表，例如 $[r_{12}(T),\\epsilon_E,v_{1x}(T),N_{\\text{refl}}]$，其中 $\\epsilon_E$ 表示测试 $2$ 的相对能量误差，$N_{\\text{refl}}$ 表示测试 $4$ 的反射次数。", "solution": "我们已对问题陈述进行了严格审查，认定其具有科学依据，定义明确且客观。该问题是计算物理领域的一个标准练习，特别是在分子动力学（MD）范畴内，其基础是经典力学的基本原理。所有必需的参数、初始条件和数学定义均已提供，构成了一个待模拟系统的完整且无矛盾的描述。所用术语，包括“反重力”的隐喻用法，都经过了充分的数学严谨性界定，从而可以得出一个唯一的、可形式化的解。因此，我们可以着手进行推导和实现。\n\n### 1. 力与加速度的推导\n\n系统动力学由牛顿第二定律 $\\mathbf{F}_i = m \\ddot{\\mathbf{r}}_i$ 支配，其中作用于粒子 $i$ 的力 $\\mathbf{F}_i$ 是保守力，因此可以从总势能 $U$ 推导得出。\n$$\n\\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} U\n$$\n总势能 $U$ 是所有唯一的粒子对 $(i, j)$（其中 $i < j$）的成对势 $V(r_{ij})$ 之和。\n$$\nU = \\sum_{i<j} V(r_{ij}) = \\frac{1}{2} \\sum_{i \\neq j} V(r_{ij})\n$$\n成对势为软核反比距离势，形式如下：\n$$\nV(r_{ij}) = \\frac{C}{\\sqrt{r_{ij}^2 + s^2}} = C (r_{ij}^2 + s^2)^{-1/2}\n$$\n其中 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$ 是粒子 $i$ 和 $j$ 之间的欧几里得距离。\n\n为了求出作用于特定粒子（例如粒子 $k$）的力，我们计算 $U$ 相对于 $\\mathbf{r}_k$ 的梯度。$U$ 的求和式中仅有其中一个下标为 $k$ 的项才依赖于 $\\mathbf{r}_k$。\n$$\n\\mathbf{F}_k = - \\nabla_{\\mathbf{r}_k} \\left( \\sum_{j \\neq k} V(r_{kj}) \\right) = - \\sum_{j \\neq k} \\nabla_{\\mathbf{r}_k} V(r_{kj})\n$$\n我们应用梯度的链式法则：$\\nabla_{\\mathbf{r}_k} V(r_{kj}) = \\frac{dV}{dr_{kj}} \\nabla_{\\mathbf{r}_k} r_{kj}$。\n距离函数的梯度为 $\\nabla_{\\mathbf{r}_k} r_{kj} = \\nabla_{\\mathbf{r}_k} \\lVert \\mathbf{r}_k - \\mathbf{r}_j \\rVert = \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{\\lVert \\mathbf{r}_k - \\mathbf{r}_j \\rVert} = \\frac{\\mathbf{r}_{kj}}{r_{kj}} = \\hat{\\mathbf{r}}_{kj}$。\n势能对距离的导数为：\n$$\n\\frac{dV}{dr} = C \\left(-\\frac{1}{2}\\right) (r^2 + s^2)^{-3/2} (2r) = -C \\frac{r}{(r^2 + s^2)^{3/2}}\n$$\n结合这些结果，粒子 $j$ 施加于粒子 $k$ 的力为：\n$$\n\\mathbf{F}_{kj} = -\\left( -C \\frac{r_{kj}}{(r_{kj}^2 + s^2)^{3/2}} \\right) \\hat{\\mathbf{r}}_{kj} = C \\frac{r_{kj}}{(r_{kj}^2 + s^2)^{3/2}} \\frac{\\mathbf{r}_{kj}}{r_{kj}} = C \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{(\\lVert \\mathbf{r}_k - \\mathbf{r}_j \\rVert^2 + s^2)^{3/2}}\n$$\n粒子 $k$ 所受的总力是来自所有其他粒子的力的矢量和：\n$$\n\\mathbf{F}_k = \\sum_{j \\neq k} \\mathbf{F}_{kj} = C \\sum_{j \\neq k} \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{(\\lVert \\mathbf{r}_k - \\mathbf{r}_j \\rVert^2 + s^2)^{3/2}}\n$$\n由此，粒子 $k$ 的加速度由 $\\mathbf{a}_k = \\ddot{\\mathbf{r}}_k = \\mathbf{F}_k / m$ 给出：\n$$\n\\mathbf{a}_k(t) = \\frac{C}{m} \\sum_{j \\neq k} \\frac{\\mathbf{r}_k(t) - \\mathbf{r}_j(t)}{(\\lVert \\mathbf{r}_k(t) - \\mathbf{r}_j(t) \\rVert^2 + s^2)^{3/2}}\n$$\n此表达式用于计算每个时间步的加速度。\n\n### 2. 数值积分：速度 Verlet 算法\n\n该问题要求一个二阶精度、时间可逆的积分器。速度 Verlet 算法满足这些要求。该算法将系统状态从 $(\\mathbf{r}(t), \\mathbf{v}(t))$ 推进到 $(\\mathbf{r}(t+\\Delta t), \\mathbf{v}(t+\\Delta t))$。给定位置 $\\mathbf{r}_n = \\mathbf{r}(t_n)$、速度 $\\mathbf{v}_n = \\mathbf{v}(t_n)$ 和加速度 $\\mathbf{a}_n = \\mathbf{a}(t_n)$，下一个时间步 $t_{n+1} = t_n + \\Delta t$ 的状态按以下方式计算：\n\n1.  **位置更新：**首先，使用当前速度和加速度，将位置推进一个完整的时间步 $\\Delta t$。\n    $$\n    \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t + \\frac{1}{2}\\mathbf{a}_n \\Delta t^2\n    $$\n2.  **力/加速度更新：**使用新计算出的位置 $\\mathbf{r}_{n+1}$ 来计算力，进而得到加速度 $\\mathbf{a}_{n+1}$。\n    $$\n    \\mathbf{a}_{n+1} = \\frac{\\mathbf{F}(\\mathbf{r}_{n+1})}{m}\n    $$\n3.  **速度更新：**最后，使用旧加速度和新加速度的平均值来更新速度。\n    $$\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\\Delta t\n    $$\n对于合适的 $\\Delta t$，该方案是数值稳定的，并且对于保守系统，它能在长时间内保持能量守恒，其误差与 $\\Delta t^2$ 成正比。在实现中，我们使用一个等效但计算上更方便的“蛙跳”（leapfrog）变体：\n\n1.  计算半步速度：$\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{1}{2}\\mathbf{a}_n \\Delta t$。\n2.  完全更新位置：$\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_{n+1/2} \\Delta t$。\n3.  （对 $\\mathbf{r}_{n+1}$ 和 $\\mathbf{v}_{n+1/2}$ 应用边界条件）。\n4.  使用 $\\mathbf{r}_{n+1}$ 计算新的加速度 $\\mathbf{a}_{n+1}$。\n5.  完成速度更新：$\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{1}{2}\\mathbf{a}_{n+1} \\Delta t$。\n\n### 3. 边界条件：镜面反射\n\n粒子被限制在一个立方体盒子 $[0, L]^3$ 内。当一个粒子的轨迹穿过边界时，它会发生镜面（完全弹性）反射。这是一个瞬时事件，它会反转粒子垂直于墙壁的速度分量，同时将其位置反射回域内。此过程保持粒子的动能守恒。\n\n反射逻辑必须在积分步骤内部应用。在位置更新之后（蛙跳 Verlet 算法的第2步），我们检查每个粒子在每个坐标轴 $d \\in \\{x, y, z\\}$ 上的新位置。设 $r_{i,d}$ 为粒子 $i$ 位置的 $d$ 分量，$v_{i,d}$ 为相应的速度分量。\n\n-   如果 $r_{i,d} < 0$：粒子穿过了下边界。我们将其位置反射为 $r_{i,d}' = -r_{i,d}$，并反转其速度分量 $v_{i,d}' = -v_{i,d}$。\n-   如果 $r_{i,d} > L$：粒子穿过了上边界。我们将其位置反射为 $r_{i,d}' = 2L - r_{i,d}$，并反转其速度分量 $v_{i,d}' = -v_{i,d}$。\n\n如果一个粒子的试验位置离盒子太远，以至于其第一次反射后仍然在盒子外面（例如，$r_{i,d} < -L$ 或 $r_{i,d} > 2L$），则必须在单个时间步内重复应用此过程。使用一个 `while` 循环来确保最终位置严格位于 $[0, L]^3$ 内部。每次速度反转事件在测试 $4$ 中计为一次反射。此反射应用于半步速度 $\\mathbf{v}_{n+1/2}$，然后才用它来计算最终速度 $\\mathbf{v}_{n+1}$。\n\n### 4. 总能量\n\n系统的总能量 $E$ 是动能 $K$ 和势能 $U$ 的和。\n$$\nE = K + U = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}_i \\rVert^2 + \\sum_{i<j} \\frac{C}{\\sqrt{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^2 + s^2}}\n$$\n对于一个保守系统，$E$ 必须是恒定的。数值积分器会引入微小误差，因此我们预期 $E$ 是近似守恒的。在测试 $2$ 中，没有发生墙壁碰撞，因此 $E$ 的任何变化都归因于积分器的离散化误差。绝对相对能量误差计算为 $\\left|E(T) - E(0)\\right| / |E(0)|$。注意，由于初始速度为零，所以 $E(0) = U(0)$，且 $U(0) > 0$。\n\n### 5. 模拟算法\n\n整个模拟过程如下：\n1.  **初始化**：根据测试用例设置粒子位置 $\\mathbf{r}_0$ 和速度 $\\mathbf{v}_0$。设置时间 $t=0$。将反射计数器初始化为 $0$。\n2.  **初始力计算**：根据 $\\mathbf{r}_0$ 计算初始加速度 $\\mathbf{a}_0$。\n3.  **时间演化循环**：对于从 $n=0$ 到 $N_{\\text{steps}}-1$ 的每个时间步：\n    a. 使用速度 Verlet 算法更新位置和半步速度。\n    b. 应用镜面反射边界条件，根据需要更新位置、半步速度和反射计数器。\n    c. 根据该步骤的最终位置计算新的加速度。\n    d. 更新全步速度以完成积分步骤。\n4.  **最终结果**：在循环于时间 $T$ 结束之后，提取所需的可观测量（最终距离、能量误差、最终速度或总反射次数）。\n\n此过程是确定性的，当使用指定的参数和初始条件正确实现时，将产生问题陈述所要求的唯一结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... (Not used)\n\ndef solve():\n    \"\"\"\n    Main function to run the four simulation test cases and print the results.\n    \"\"\"\n\n    class MD_Simulator:\n        \"\"\"\n        A class to perform Molecular Dynamics simulations based on the problem statement.\n        \"\"\"\n        def __init__(self, r0, v0, m=1.0, C=1.0, s=0.1, L=10.0):\n            self.N = r0.shape[0]  # Number of particles\n            self.pos = np.array(r0, dtype=np.float64)\n            self.vel = np.array(v0, dtype=np.float64)\n            \n            self.m = m\n            self.C = C\n            self.s = s\n            self.L = L\n            \n            self.acc = self._calculate_accelerations()\n            self.reflection_count = 0\n\n        def _calculate_accelerations(self):\n            \"\"\"Calculates accelerations on all particles due to pairwise forces.\"\"\"\n            if self.N < 2:\n                return np.zeros_like(self.pos)\n            \n            # Vectorized calculation of pairwise forces\n            displacements = self.pos[:, np.newaxis, :] - self.pos[np.newaxis, :, :]\n            dist_sq = np.sum(displacements**2, axis=2)\n            np.fill_diagonal(dist_sq, np.inf) # Avoid self-interaction division by zero\n            \n            # Force magnitude factor: C * (r^2 + s^2)^(-3/2)\n            denom = (dist_sq + self.s**2)**1.5\n            force_mag_factor = self.C / denom\n            \n            # Acceleration = Force / mass\n            # accel_i = sum_j (force_mag_factor_ij * displacement_ij) / m\n            accel = np.sum(force_mag_factor[:, :, np.newaxis] * displacements, axis=1) / self.m\n            return accel\n\n        def _apply_boundary_conditions(self):\n            \"\"\"Applies specular reflection boundary conditions.\"\"\"\n            for i in range(self.N):\n                for d in range(3): # x, y, z dimensions\n                    # Using a while loop to handle multiple boundary crossings in one step\n                    while self.pos[i, d] < 0 or self.pos[i, d] > self.L:\n                        self.reflection_count += 1\n                        if self.pos[i, d] < 0:\n                            self.pos[i, d] = -self.pos[i, d]\n                            self.vel[i, d] = -self.vel[i, d]\n                        else: # pos[i, d] > L\n                            self.pos[i, d] = 2 * self.L - self.pos[i, d]\n                            self.vel[i, d] = -self.vel[i, d]\n\n\n        def step(self, dt):\n            \"\"\"Advances the simulation by one time step dt using Velocity Verlet.\"\"\"\n            # 1. First half of velocity update\n            self.vel += 0.5 * self.acc * dt\n            \n            # 2. Position update\n            self.pos += self.vel * dt\n            \n            # 3. Apply boundary conditions\n            self._apply_boundary_conditions()\n            \n            # 4. Calculate new accelerations\n            self.acc = self._calculate_accelerations()\n            \n            # 5. Second half of velocity update\n            self.vel += 0.5 * self.acc * dt\n\n        def get_total_energy(self):\n            \"\"\"Calculates the total energy (kinetic + potential) of the system.\"\"\"\n            # Kinetic Energy\n            kinetic_energy = 0.5 * self.m * np.sum(self.vel**2)\n            \n            # Potential Energy\n            potential_energy = 0.0\n            if self.N >= 2:\n                r_ij_sq = np.sum((self.pos[:, np.newaxis, :] - self.pos[np.newaxis, :, :])**2, axis=2)\n                # Sum over unique pairs (i < j)\n                i_lower = np.tril_indices(self.N, -1)\n                potential_energy = self.C * np.sum(1.0 / np.sqrt(r_ij_sq[i_lower] + self.s**2))\n\n            return kinetic_energy + potential_energy\n\n    results = []\n\n    # --- Test 1: Two-body repulsion ---\n    r0_1 = np.array([[4.0, 5.0, 5.0], [6.0, 5.0, 5.0]])\n    v0_1 = np.zeros_like(r0_1)\n    dt1, T1 = 1.0e-3, 0.5\n    n_steps1 = int(T1 / dt1)\n    sim1 = MD_Simulator(r0_1, v0_1)\n    for _ in range(n_steps1):\n        sim1.step(dt1)\n    r12_final = np.linalg.norm(sim1.pos[0] - sim1.pos[1])\n    results.append(r12_final)\n    \n    # --- Test 2: Energy conservation ---\n    a = 1.0\n    R = a / np.sqrt(3)\n    r0_2 = np.array([\n        [5.0 + R, 5.0, 5.0],\n        [5.0 - R/2.0, 5.0 + (np.sqrt(3)/2.0)*R, 5.0],\n        [5.0 - R/2.0, 5.0 - (np.sqrt(3)/2.0)*R, 5.0],\n    ])\n    v0_2 = np.zeros_like(r0_2)\n    dt2, T2 = 5.0e-4, 0.2\n    n_steps2 = int(T2 / dt2)\n    sim2 = MD_Simulator(r0_2, v0_2)\n    E0 = sim2.get_total_energy()\n    for _ in range(n_steps2):\n        sim2.step(dt2)\n    ET = sim2.get_total_energy()\n    rel_energy_error = np.abs(ET - E0) / E0\n    results.append(rel_energy_error)\n\n    # --- Test 3: Single-particle wall reflection ---\n    r0_3 = np.array([[2.0, 5.0, 5.0]])\n    v0_3 = np.array([[3.0, 0.0, 0.0]])\n    dt3, T3 = 1.0e-3, 3.0\n    n_steps3 = int(T3 / dt3)\n    sim3 = MD_Simulator(r0_3, v0_3)\n    for _ in range(n_steps3):\n        sim3.step(dt3)\n    final_vx = sim3.vel[0, 0]\n    results.append(final_vx)\n\n    # --- Test 4: Many-body explosion ---\n    offsets = np.array([\n        [-0.1, -0.1, -0.1], [-0.1, -0.1,  0.1], [-0.1,  0.1, -0.1], [-0.1,  0.1,  0.1],\n        [ 0.1, -0.1, -0.1], [ 0.1, -0.1,  0.1], [ 0.1,  0.1, -0.1], [ 0.1,  0.1,  0.1]\n    ])\n    r0_4 = np.array([5.0, 5.0, 5.0]) + offsets\n    v0_4 = np.zeros_like(r0_4)\n    dt4, T4 = 1.0e-3, 1.5\n    n_steps4 = int(T4 / dt4)\n    sim4 = MD_Simulator(r0_4, v0_4)\n    for _ in range(n_steps4):\n        sim4.step(dt4)\n    total_reflections = sim4.reflection_count\n    results.append(total_reflections)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2423746"}, {"introduction": "我们最后的实践将运用统计力学的框架，把微观的对势世界与宏观的可观测性质联系起来。通过分析一个具有方势阱相互作用的一维流体模型，你将推导并计算诸如密度和压缩率等热力学量。这个练习 [@problem_id:2423726] 展示了统计力学如何从底层的相互作用规则出发，预测多体系统的集体行为，从而实现了从粒子动力学到热力学的跨越。", "problem": "考虑一个一维系统，其中包含硬核直径为 $\\sigma&gt;0$ 的全同粒子，它们被限制在一条直线上运动。两个粒子中心相距为 $r$ 时的对间相互作用势是一个方阱势，由以下公式给出：\n$$\nu(r)=\n\\begin{cases}\n+\\infty, & r&lt;\\sigma,\\\\\n-\\varepsilon, & \\sigma\\le r&lt;\\lambda\\sigma,\\\\\n0, & r\\ge \\lambda\\sigma,\n\\end{cases}\n$$\n其中，阱深 $\\varepsilon\\ge 0$，作用范围参数 $\\lambda$ 满足 $1&lt;\\lambda\\le 2$。该系统处于绝对温度为 $T$、外压为 $P$ 的等温等压系综中。设 $\\beta=1/(k_{\\mathrm{B}}T)$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n\n由于系统的一维有序性以及 $1&lt;\\lambda\\le 2$ 的条件，只有最近邻粒子对之间才能有吸引相互作用。在等温等压系综中，定义最近邻粒子中心间距为随机变量 $r\\ge \\sigma$，其概率密度正比于 $\\exp[-\\beta u(r)]\\exp[-\\beta P r]$。\n\n定义以下无量纲可观测量：\n- 约化数密度 $\\rho^\\ast=\\rho\\,\\sigma$，其中 $\\rho$ 是粒子中心的数密度（单位长度内的粒子数）。\n- 零波数静态结构因子 $S(0)=\\rho\\,k_{\\mathrm{B}}T\\,\\kappa_T$，其中 $\\kappa_T$ 是定温下的等温压缩率。\n\n您必须：\n1. 使用 $\\sigma$ 作为长度单位。中间推导过程中的所有距离都应理解为相对于 $\\sigma$ 的值。所有输出结果均应以无量纲数的形式报告。\n2. 在所述假设下，于等温等压系综中精确处理该系统。从统计力学的基本定义出发，表达单个最近邻间距所需的配分函数，并从适当的累积量生成函数的导数中求得 $\\langle r\\rangle$ 和 $\\mathrm{Var}(r)$。使用这些值计算 $\\rho^\\ast=\\sigma/\\langle r\\rangle$ 和 $S(0)=\\mathrm{Var}(r)/\\langle r\\rangle^2$。\n3. 对于下方测试用例中的每组参数，计算 $(\\rho^\\ast,S(0))$，并将每个数值结果四舍五入到六位小数。\n\n测试用例（每个案例由 $(\\beta\\varepsilon,\\lambda,\\beta P \\sigma)$ 指定）：\n- 案例 A: $(0.0,\\,1.5,\\,1.0)$\n- 案例 B: $(1.0,\\,1.5,\\,1.0)$\n- 案例 C: $(3.0,\\,1.5,\\,1.0)$\n- 案例 D: $(1.0,\\,2.0,\\,1.0)$\n- 案例 E: $(1.0,\\,1.5,\\,0.1)$\n- 案例 F: $(1.0,\\,1.5,\\,10.0)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由逗号分隔的六个条目的列表，每个条目是一个双元素列表 $[\\rho^\\ast,S(0)]$，依次对应案例 A 到 F。整个输出必须是包含在方括号中的单个列表，且不含空格。例如，包含两个假设条目的输出应如下所示：`[[0.500000,0.250000],[0.600000,0.200000],...]`。", "solution": "该问题陈述已经过验证，被认定为具有科学依据、问题明确且内容完备。它描述了一维统计力学中一个标准的、精确可解的模型。所有给出的定义和关系都是正确的。未检测到不一致或含糊之处。因此，我们可以继续进行推导和求解。\n\n该系统由在一条直线上通过方阱势相互作用的粒子组成。由于一维有序性和作用范围约束 $1 < \\lambda \\le 2$，只有最近邻相互作用不为零。系统处于等温等压(NPT)系综中。问题要求确定约化数密度 $\\rho^\\ast$ 和零波数静态结构因子 $S(0)$。\n\n首先，我们按照指示使用无量纲单位。设硬核直径 $\\sigma$ 为长度单位。我们定义无量纲间距为 $x = r/\\sigma$。热力学参数被无量纲化为 $\\varepsilon^* = \\beta \\varepsilon$ 和 $P^* = \\beta P \\sigma$。在这些单位中，势能 $\\beta u(x\\sigma)$ 为：\n$$\n\\beta u(x\\sigma)=\n\\begin{cases}\n+\\infty, & x<1,\\\\\n-\\varepsilon^*, & 1 \\le x < \\lambda,\\\\\n0, & x \\ge 1,\n\\end{cases}\n$$\n由于硬核排斥作用，$x \\ge 1$。\n\n最近邻间距 $x$ 的概率密度函数正比于在等压系综中单个间距能量的玻尔兹曼因子，即 $u(x\\sigma) + P r = u(x\\sigma) + (P\\sigma)x$。单个间距的相关配分函数，我们记为 $I(P^*, \\varepsilon^*, \\lambda)$，由对所有可能间距 $x \\ge 1$ 的积分给出：\n$$\nI(P^*) = \\int_1^\\infty \\exp[-\\beta u(x\\sigma) - P^* x] dx\n$$\n根据势能的分段定义，该积分可拆分为：\n$$\nI(P^*) = \\int_1^{\\lambda} \\exp[-(-\\varepsilon^*)] \\exp[-P^* x] dx + \\int_{\\lambda}^{\\infty} \\exp[-0] \\exp[-P^* x] dx\n$$\n$$\nI(P^*) = e^{\\varepsilon^*} \\int_1^{\\lambda} e^{-P^* x} dx + \\int_{\\lambda}^{\\infty} e^{-P^* x} dx\n$$\n对于 $P^* > 0$，这些标准指数积分的计算结果为：\n$$\n\\int_1^{\\lambda} e^{-P^* x} dx = \\frac{1}{P^*} (e^{-P^*} - e^{-P^*\\lambda})\n$$\n$$\n\\int_{\\lambda}^{\\infty} e^{-P^* x} dx = \\frac{1}{P^*} e^{-P^*\\lambda}\n$$\n代入这些结果，我们得到配分函数的表达式：\n$$\nI(P^*) = e^{\\varepsilon^*} \\left[ \\frac{1}{P^*} (e^{-P^*} - e^{-P^*\\lambda}) \\right] + \\frac{1}{P^*} e^{-P^*\\lambda} = \\frac{1}{P^*} \\left[ e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda} \\right]\n$$\n此函数的对数 $\\ln I(P^*)$ 是随机变量 $x$ 关于参数 $-P^*$ 的累积量生成函数。累积量，即均值 $\\langle x \\rangle$ 和方差 $\\mathrm{Var}(x)$，可以通过微分得到。\n一阶累积量是均值 $\\langle x \\rangle$：\n$$\n\\langle x \\rangle = -\\frac{\\partial}{\\partial P^*} \\ln I(P^*)\n$$\n二阶累积量是方差 $\\mathrm{Var}(x) = \\langle x^2 \\rangle - \\langle x \\rangle^2$：\n$$\n\\mathrm{Var}(x) = \\frac{\\partial^2}{\\partial (P^*)^2} \\ln I(P^*) = -\\frac{\\partial \\langle x \\rangle}{\\partial P^*}\n$$\n首先，我们计算 $\\ln I(P^*)$：\n$$\n\\ln I(P^*) = -\\ln P^* + \\ln \\left( e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda} \\right)\n$$\n对 $P^*$ 微分求 $\\langle x \\rangle$：\n$$\n\\langle x \\rangle = -\\left[ -\\frac{1}{P^*} + \\frac{-e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)(-\\lambda)e^{-P^*\\lambda}}{e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda}} \\right] = \\frac{1}{P^*} + \\frac{e^{\\varepsilon^*-P^*} - \\lambda(e^{\\varepsilon^*}-1)e^{-P^*\\lambda}}{e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda}}\n$$\n为求方差，我们将 $\\langle x \\rangle$ 对 $P^*$ 微分并取负值。设 $D_0 = e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda}$。则 $\\langle x \\rangle = 1/P^* + N_1/D_0$，其中 $N_1 = e^{\\varepsilon^*-P^*} - \\lambda(e^{\\varepsilon^*}-1)e^{-P^*\\lambda}$。\n$$\n\\mathrm{Var}(x) = -\\frac{\\partial \\langle x \\rangle}{\\partial P^*} = -\\left(-\\frac{1}{(P^*)^2} + \\frac{\\partial}{\\partial P^*}\\left(\\frac{N_1}{D_0}\\right)\\right) = \\frac{1}{(P^*)^2} - \\frac{N_1'D_0 - N_1D_0'}{D_0^2}\n$$\n在进行微分和大量代数化简后，分数的分子变为：\n$$\nN_1'D_0 - N_1D_0' = (\\lambda - 1)^2 (e^{\\varepsilon^*}-1) e^{\\varepsilon^*-P^*(1+\\lambda)}\n$$\n这给出了方差的最终表达式：\n$$\n\\mathrm{Var}(x) = \\frac{1}{(P^*)^2} - \\frac{(\\lambda-1)^2 (e^{\\varepsilon^*}-1) e^{\\varepsilon^*-P^*(1+\\lambda)}}{\\left(e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda}\\right)^2}\n$$\n所需求的可观测量与这些矩相关。约化数密度为 $\\rho^\\ast = \\rho\\sigma$。由于数密度 $\\rho=1/\\langle r \\rangle$，我们有 $\\rho^\\ast = \\sigma/\\langle r \\rangle = \\sigma/(\\sigma\\langle x \\rangle) = 1/\\langle x \\rangle$。对于这个一维系统，零波数静态结构因子为 $S(0) = \\mathrm{Var}(r)/\\langle r \\rangle^2 = \\sigma^2 \\mathrm{Var}(x) / (\\sigma^2 \\langle x \\rangle^2) = \\mathrm{Var}(x)/\\langle x \\rangle^2$。\n\n有了这些解析表达式，我们现在可以为每个测试用例计算数值了。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for reduced density and static structure factor for a 1D square-well fluid.\n    \"\"\"\n    # Test suite: each case is specified by (beta*epsilon, lambda, beta*P*sigma)\n    test_cases = [\n        # Case A: (beta_eps, lambda, beta_P_sigma)\n        (0.0, 1.5, 1.0),\n        # Case B\n        (1.0, 1.5, 1.0),\n        # Case C\n        (3.0, 1.5, 1.0),\n        # Case D\n        (1.0, 2.0, 1.0),\n        # Case E\n        (1.0, 1.5, 0.1),\n        # Case F\n        (1.0, 1.5, 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_star, lam, p_star = case\n\n        # For the case eps_star == 0, the model simplifies to a hard-rod fluid.\n        if eps_star == 0.0:\n            mean_x = 1.0 / p_star + 1.0\n            var_x = 1.0 / p_star**2\n        else:\n            # Numerically stable calculation using np.expm1(x) for exp(x) - 1\n            exp_eps_star_m1 = np.expm1(eps_star)\n            \n            # Common terms in the expressions\n            term_A = np.exp(eps_star - p_star)\n            term_B = exp_eps_star_m1 * np.exp(-p_star * lam)\n\n            # Denominator D_0\n            D0 = term_A - term_B\n            \n            # Calculate mean of dimensionless separation <x>\n            mean_x_numerator = term_A - lam * term_B\n            mean_x = 1.0 / p_star + mean_x_numerator / D0\n            \n            # Calculate variance of dimensionless separation Var(x)\n            var_x_frac_numerator = (lam - 1.0)**2 * exp_eps_star_m1 * np.exp(eps_star - p_star * (1.0 + lam))\n            var_x = (1.0 / p_star**2) - (var_x_frac_numerator / D0**2)\n\n        # Calculate final observables\n        # rho_star = sigma / <r> = 1 / <x>\n        rho_star = 1.0 / mean_x\n        # S(0) = Var(r) / <r>^2 = Var(x) / <x>^2\n        s0 = var_x / mean_x**2\n\n        # Round to six decimal places as required\n        results.append([round(rho_star, 6), round(s0, 6)])\n\n    # Format the output string\n    # E.g., [[0.5,0.25],[0.6,0.2],...]\n    output_str = \"[\" + \",\".join([f\"[{r[0]:.6f},{r[1]:.6f}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2423726"}]}