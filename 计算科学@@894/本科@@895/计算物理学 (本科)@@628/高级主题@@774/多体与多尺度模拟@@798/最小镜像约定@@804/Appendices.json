{"hands_on_practices": [{"introduction": "掌握了最小镜像约定的基本概念后，首要的实践任务就是将其付诸代码。本练习将指导你为一个正交模拟盒子实现最小镜像约定，这是分子模拟中最常见的情景。通过处理一系列精心设计的测试案例，包括跨越周期性边界的粒子对，你将巩固对核心算法的理解，并为更复杂的模拟挑战奠定坚实的基础。[@problem_id:2458300]", "problem": "你需要编写一个完整、可运行的程序，以演示在分子动力学 (MD) 模拟中，周期性边界条件下最小镜像约定的效果。该程序必须以两种方式计算正交周期性模拟盒子中两个粒子间的欧几里得距离：(1) 忽略周期性的朴素欧几里得距离，和 (2) 应用最小镜像约定后的欧几里得距离。距离必须以纳米 (nm) 为单位，并报告四舍五入到恰好六位小数的结果。\n\n背景与基本原理：在采用周期性边界条件 (PBC) 的分子动力学 (MD) 模拟中，使用有限模拟盒子的无限平铺来模拟宏观体系的行为。两个粒子间的物理距离被解释为一个粒子与另一个粒子的任意周期性镜像之间的最小距离。其底层的几何规则源自欧几里得距离的定义和晶格的平移对称性。对于边长为 $L_x$、$L_y$ 和 $L_z$ 的正交盒子，通过沿每个轴选择整数倍的盒子长度平移，以最小化位移矢量的欧几里得范数，即可获得最小距离。你的程序必须实现此规则。\n\n你的任务：\n- 定义一个函数，给定两个 $3$ 维位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$（单位为纳米）以及盒子长度 $(L_x,L_y,L_z)$（单位为纳米），该函数返回两个值：\n  1) 朴素欧几里得距离 $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$，单位为 nm，\n  2) 最小镜像约定距离 $d_{\\text{mic}}$，单位为 nm，通过对位移分量进行 $(L_x,L_y,L_z)$ 整数倍的平移以最小化范数来获得。\n- 将盒子视为正交且坐标轴对齐。\n- 位置可能位于主盒子区间之外。你的实现仍必须使用周期性正确计算 $d_{\\text{mic}}$。\n- 为了使你的实现清晰，请在程序内包含一个多行伪代码字符串（不打印），概述你所实现的最小镜像约定逻辑。\n\n数值和单位要求：\n- 所有距离必须以纳米 (nm) 为单位。\n- 报告的距离需四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n你的程序必须按规定顺序为以下 $5$ 个测试案例中的每一个计算 $[d_{\\text{naive}}, d_{\\text{mic}}]$。\n\n1) 顺利情况，盒子内的小分离：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) 沿一个轴穿越周期性边界：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) 各向异性盒子和沿多个轴的包裹：\n- 盒子：$(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) 沿一个轴恰好为半个盒子长度的分离（临界情况）：\n- 盒子：$(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) 位置在主盒子区间之外：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,-0.1\\,\\text{nm},\\,-0.1\\,\\text{nm},\\,-0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的、逗号分隔的配对列表。每个配对对应于指定顺序的一个测试案例，并且必须采用 $[d_{\\text{naive}},d_{\\text{mic}}]$ 的形式，两个值都需四舍五入到纳米单位下的恰好 $6$ 位小数。输出中不得有空格。\n- 例如，要求的整体格式类似于 $[[a_1,b_1],[a_2,b_2],\\dots]$，其中每个 $a_k$ 和 $b_k$ 是纳米单位下且具有恰好 $6$ 位小数的浮点数。", "solution": "所提出的问题是计算统计力学中的一个基础练习，具体涉及在分子动力学 (MD) 模拟中实现周期性边界条件 (PBC)。PBC 的使用是一种标准且必要的技术，通过模拟少量有限的粒子来近似宏观系统的性质。它减轻了小系统中本会占主导地位的严重表面效应。这个问题的核心是正确计算粒子间距离，这由最小镜像约定 (MIC) 决定。\n\n该问题陈述清晰，科学依据充分，并为得出唯一且可验证的解提供了所有必要数据。我们将进行严谨的推导和实现。\n\n设正交模拟盒子由一组对应于边长的三个正交矢量定义，$\\mathbf{L} = (L_x, L_y, L_z)$。两个粒子 $i$ 和 $j$ 的位置由矢量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 给出。\n\n首先，我们定义朴素欧几里得距离 $d_{\\text{naive}}$。这是非周期性三维欧几里得空间中的标准距离。它根据位移矢量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$ 的范数计算得出。\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\n其中 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$。此计算忽略了模拟盒子的周期性，并将系统视为孤立在真空中。\n\n其次，我们处理最小镜像约定距离 $d_{\\text{mic}}$。在周期性系统中，模拟盒子在所有方向上无限复制。位于位置 $\\mathbf{r}$ 的粒子在位置 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$ 处有一个无限的周期性镜像晶格，其中 $n_x, n_y, n_z$ 是任意整数。粒子 $i$ 和粒子 $j$ 之间的物理距离是粒子 $i$ 与粒子 $j$ 的*任何*周期性镜像之间的最短距离。\n\n在数学上，这表示为：\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\n对于正交盒子，范数的最小化可以对每个笛卡尔分量独立进行。让我们考虑位移矢量的 $x$ 分量，$\\Delta x = x_j - x_i$。我们必须找到一个整数 $n_x$ 来最小化 $|\\Delta x - n_x L_x|$。当 $n_x$ 是最接近比率 $\\Delta x / L_x$ 的整数时，即可实现这一点。这就是“最近整数函数”，通常表示为 $\\text{nint}(s)$ 或通过 `round(s)` 实现。\n\n因此，经 MIC 调整的位移分量 $\\Delta x'$ 为：\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\n这个公式正确地将位移矢量分量“包裹”到区间 $[-L_x/2, L_x/2]$ 内。同样的逻辑也适用于 $y$ 和 $z$ 分量。完整的经 MIC 调整的位移矢量 $\\Delta\\mathbf{r}'$ 则是：\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\n此矢量运算是稳健的，并且能正确处理粒子坐标可能位于主模拟盒子之外的情况，因为只有它们的相对位移才重要。\n\n最小镜像距离 $d_{\\text{mic}}$ 是这个调整后位移矢量的欧几里得范数：\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\n所提供的测试案例将使用这一既定方法来解决。实现将利用 `numpy` 库进行高效的矢量运算。对于每个测试案例，我们将计算 $d_{\\text{naive}}$ 和 $d_{\\text{mic}}$，并按要求将结果四舍五入到恰好 $6$ 位小数进行报告。对于位移恰好为半个盒子长度的特殊情况，例如 $\\Delta x = L_x/2$，`round` 函数会进行处理（例如，在 `numpy` 中，通常会四舍五入到最近的偶数），但无论调整后位移的符号选择如何，最终的距离都是唯一的 $L_x/2$。对于 $\\Delta x = L_x/2$，$\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$。其大小是明确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "虽然正交盒子很常见，但许多先进的模拟（例如在恒定压力下）会采用形状可变的三斜盒子。在这种更一般化的情况下，简单的逐分量校正会失效，我们必须采用一种更根本和强大的方法。这个练习将引导你通过分数坐标变换来实现适用于任意三斜晶胞的最小镜像约定，从而将你的理解从一个简单的几何技巧提升到一个关于晶格变换的普适性原理。[@problem_id:2414062]", "problem": "要求您为一个通用的三斜（非正交）周期性模拟盒子实现最小镜像约定（MIC）。对于任意一对点，MIC 定义了它们在模拟晶胞的中心周期性镜像中的唯一位移代表。模拟盒子由一个满秩晶格矩阵 $H \\in \\mathbb{R}^{3 \\times 3}$ 指定，其列是三个 Bravais 晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 的笛卡尔坐标。对于任意两个笛卡尔位置矢量为 $\\mathbf{r}_i, \\mathbf{r}_j \\in \\mathbb{R}^3$ 的点，其原始位移为 $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。在周期性边界条件下，周期性镜像之间相差一个晶格平移 $H \\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。MIC 旨在通过合适的整数晶格平移，寻找到位于模拟晶胞中心镜像中的位移 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$。\n\n从周期性边界条件的基本定义出发：两个笛卡尔位置矢量 $\\mathbf{r}$ 和 $\\mathbf{r}'$ 代表同一个物理点，当且仅当存在某个 $\\mathbf{n} \\in \\mathbb{Z}^3$ 使得 $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$。利用此定义推导出一个数值稳定且通用的算法，通过在分数坐标 $\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$ 中进行计算，并将 $\\mathbf{s}$ 规约到分数坐标空间的中心平行六面体内，从而计算三斜盒子的 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$。明确说明在规约分数坐标分量时如何处理半整数的临界情况，并证明您的选择是合理的，以确保规约后的每个分数坐标分量都位于一个长度为 1 的半开区间内。\n\n您的程序必须实现所推导的算法，并将其应用于以下测试套件。在每个案例中，$H$ 由其列向量给出，位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以笛卡尔坐标给出。您的代码必须为每个案例计算 MIC 位移矢量 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 的笛卡尔坐标及其欧几里得范数 $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$。\n\n测试套件（每个矩阵和矢量均以笛卡尔分量表示）：\n\n- 案例 1（正交立方体）：\n  - $H = \\begin{bmatrix} 10 & 0 & 0 \\\\ 0 & 10 & 0 \\\\ 0 & 0 & 10 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (1, 2, 3)$,\n  - $\\mathbf{r}_j = (9, 9, 9)$.\n- 案例 2（三斜剪切 I）：\n  - $\\mathbf{a} = (10, 0, 0)$, $\\mathbf{b} = (2, 8, 0)$, $\\mathbf{c} = (1, 1, 6)$,\n  - $H = \\begin{bmatrix} 10 & 2 & 1 \\\\ 0 & 8 & 1 \\\\ 0 & 0 & 6 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (1, 1, 1)$,\n  - $\\mathbf{r}_j = (9, 7, 5)$.\n- 案例 3（边界临界情况处理）：\n  - $\\mathbf{a} = (8, 0, 0)$, $\\mathbf{b} = (1, 7, 0)$, $\\mathbf{c} = (2, 1, 9)$,\n  - $H = \\begin{bmatrix} 8 & 1 & 2 \\\\ 0 & 7 & 1 \\\\ 0 & 0 & 9 \\end{bmatrix}$,\n  - 令 $\\mathbf{s} = (0.5, -0.5, 0.5)$ 并定义 $\\mathbf{r} = H \\mathbf{s}$,\n  - $\\mathbf{r}_i = (0, 0, 0)$,\n  - $\\mathbf{r}_j = \\mathbf{r}$.\n- 案例 4（三斜剪切 II）：\n  - $\\mathbf{a} = (5, 0, 0)$, $\\mathbf{b} = (4, 5, 0)$, $\\mathbf{c} = (3, 2, 5)$,\n  - $H = \\begin{bmatrix} 5 & 4 & 3 \\\\ 0 & 5 & 2 \\\\ 0 & 0 & 5 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (4.9, 0.1, 0.1)$,\n  - $\\mathbf{r}_j = (0.2, 4.9, 0.2)$.\n\n最终输出规格：\n- 对于每个案例，输出一个包含四个实数的列表：$\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 的三个笛卡尔分量，后跟其欧几里得范数 $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$。\n- 将每个实数四舍五入到 6 位小数。\n- 您的程序应生成单行输出，其中包含四个案例的结果，格式为 Python 风格的列表之列表，例如：$[\\,[x_1,y_1,z_1,n_1],[x_2,y_2,z_2,n_2],[x_3,y_3,z_3,n_3],[x_4,y_4,z_4,n_4]\\,]$。", "solution": "所提出的问题是构想并实现一个通用算法，用于在三斜周期性体系中计算最小镜像约定（MIC）位移矢量。这是计算物理学中的一个基本任务，尤其是在分子动力学和蒙特卡洛模拟中。该问题陈述在科学上是合理的、定义明确的，并为得出唯一解提供了充分的信息。\n\n首先，我们建立理论基础。一个三斜模拟晶胞由三个线性无关的晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 定义，它们构成了晶格矩阵 $H = [\\mathbf{a}, \\mathbf{b}, \\mathbf{c}] \\in \\mathbb{R}^{3 \\times 3}$ 的列。由于周期性边界条件，一个笛卡尔位置矢量为 $\\mathbf{r}$ 的点具有无限多个等效的周期性镜像，由 $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$ 给出，其中 $\\mathbf{n} = (n_1, n_2, n_3)^T$ 是任意整数矢量，$\\mathbf{n} \\in \\mathbb{Z}^3$。\n\n从点 $\\mathbf{r}_i$ 到点 $\\mathbf{r}_j$ 的位移矢量也非唯一。原始位移为 $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。任何等效位移由 $\\Delta \\mathbf{r}' = \\mathbf{r}_j' - \\mathbf{r}_i = (\\mathbf{r}_j + H\\mathbf{n}) - \\mathbf{r}_i = \\Delta \\mathbf{r} + H\\mathbf{n}$ 给出，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。最小镜像约定旨在寻找这组矢量中的唯一代表，记作 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$，它与原点“最接近”。在一个通用的三斜晶胞中，这意味着找到位于中心 Wigner-Seitz 原胞内的矢量，该原胞是空间中比任何其他晶格点更靠近原点晶格点的点的轨迹。\n\n直接对所有 $\\mathbf{n} \\in \\mathbb{Z}^3$ 最小化范数 $\\|\\Delta \\mathbf{r} + H\\mathbf{n}\\|_2$ 在计算上是复杂的。一种更稳健且高效的方法，如问题所建议的，是在分数（或标度）坐标中操作。一个笛卡尔矢量 $\\mathbf{v}$ 通过线性变换 $\\mathbf{s} = H^{-1} \\mathbf{v}$ 转换为分数坐标 $\\mathbf{s}$。$\\mathbf{s}$ 的分量表示 $\\mathbf{v}$ 为晶格矢量的线性组合。\n\n让我们将此应用于位移矢量：\n$$\n\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} (\\mathbf{r}_j - \\mathbf{r}_i)\n$$\n位移的任意周期性镜像 $\\Delta \\mathbf{r} - H\\mathbf{n}$ 转换为分数坐标为：\n$$\nH^{-1} (\\Delta \\mathbf{r} - H\\mathbf{n}) = H^{-1} \\Delta \\mathbf{r} - H^{-1}H\\mathbf{n} = \\mathbf{s} - \\mathbf{n}\n$$\n这表明，在笛卡尔空间中在周期性镜像之间移动，等价于将分数坐标矢量移动一个整数矢量。问题现在简化为找到一个整数矢量 $\\mathbf{n}$，使得规约后的分数矢量 $\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\mathbf{n}$ 的分量位于分数坐标空间中的一个中心单位晶胞内。此中心晶胞的标准选择是每个分量的范围为 $[-0.5, 0.5]$。\n\n要将任意分数坐标分量 $s_k$ 映射到其中心镜像 $s_{k, \\mathrm{MIC}}$，我们必须找到一个整数 $n_k$ 使得 $s_{k, \\mathrm{MIC}} = s_k - n_k \\in [-0.5, 0.5)$。选择一个半开区间，如 $[-0.5, 0.5)$，对于确保唯一映射并解决分量恰好处在边界（半整数）上的歧义至关重要。满足此条件的整数 $n_k$ 是最接近 $s_k$ 的整数。这可以在算法上计算。一种寻找 $n_k$ 并执行规约的标准且数值稳定的方法是：\n$$\ns_{k, \\mathrm{MIC}} = s_k - \\lfloor s_k + 0.5 \\rfloor\n$$\n此操作正确处理了半整数值的临界情况。例如，如果 $s_k = 2.5$，则 $s_{k, \\mathrm{MIC}} = 2.5 - \\lfloor 2.5 + 0.5 \\rfloor = 2.5 - \\lfloor 3.0 \\rfloor = 2.5 - 3 = -0.5$。如果 $s_k = -1.5$，则 $s_{k, \\mathrm{MIC}} = -1.5 - \\lfloor -1.5 + 0.5 \\rfloor = -1.5 - \\lfloor -1.0 \\rfloor = -1.5 - (-1) = -0.5$。这将上边界 $0.5$ 一致地映射到下边界 $-0.5$，确保规约后的分数分量 $s_{k, \\mathrm{MIC}}$ 全部位于半开区间 $[-0.5, 0.5)$ 内。此选择的合理性在于其计算上的简洁性，以及它能保证对任何浮点输入都产生唯一结果。\n\n完整的算法如下：\n1. 计算笛卡尔坐标下的原始位移矢量：$\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。\n2. 将 $\\Delta \\mathbf{r}$ 转换为分数坐标：$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$。这需要计算晶格矩阵 $H$ 的逆矩阵。\n3. 在分数坐标空间中应用最小镜像条件，将每个分量 $s_k$ 规约到区间 $[-0.5, 0.5)$：$\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\lfloor \\mathbf{s} + 0.5 \\rfloor$，其中运算是逐元素执行的。\n4. 将规约后的分数矢量转换回笛卡尔坐标：$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}}$。\n5. 计算最终矢量的欧几里得范数：$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(\\Delta \\mathbf{r}_{\\mathrm{MIC}}) \\cdot (\\Delta \\mathbf{r}_{\\mathrm{MIC}})}$。\n\n该算法普遍适用于任何由满秩矩阵 $H$ 描述的周期性晶胞，包括正交和通用三斜形式。我们现在将其应用于指定的测试案例。\n\n案例 1：$H = \\begin{bmatrix} 10 & 0 & 0 \\\\ 0 & 10 & 0 \\\\ 0 & 0 & 10 \\end{bmatrix}$, $\\mathbf{r}_i = (1, 2, 3)$, $\\mathbf{r}_j = (9, 9, 9)$。\n$\\Delta \\mathbf{r} = (8, 7, 6)$.\n$H^{-1} = \\begin{bmatrix} 0.1 & 0 & 0 \\\\ 0 & 0.1 & 0 \\\\ 0 & 0 & 0.1 \\end{bmatrix}$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = (0.8, 0.7, 0.6)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.8 - 1, 0.7 - 1, 0.6 - 1) = (-0.2, -0.3, -0.4)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-2, -3, -4)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-2)^2+(-3)^2+(-4)^2} = \\sqrt{29} \\approx 5.385165$.\n\n案例 2：$H = \\begin{bmatrix} 10 & 2 & 1 \\\\ 0 & 8 & 1 \\\\ 0 & 0 & 6 \\end{bmatrix}$, $\\mathbf{r}_i = (1, 1, 1)$, $\\mathbf{r}_j = (9, 7, 5)$。\n$\\Delta \\mathbf{r} = (8, 6, 4)$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (0.6, 0.666667, 0.666667)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.6 - 1, 0.666667 - 1, 0.666667 - 1) = (-0.4, -0.333333, -0.333333)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5, -3, -2)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5)^2+(-3)^2+(-2)^2} = \\sqrt{38} \\approx 6.164414$.\n\n案例 3：$H = \\begin{bmatrix} 8 & 1 & 2 \\\\ 0 & 7 & 1 \\\\ 0 & 0 & 9 \\end{bmatrix}$, $\\mathbf{r}_i = (0, 0, 0)$, $\\mathbf{r}_j = H(0.5, -0.5, 0.5)^T$.\n$\\Delta \\mathbf{r} = \\mathbf{r}_j$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} \\mathbf{r}_j = (0.5, -0.5, 0.5)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.5 - \\lfloor 1.0 \\rfloor, -0.5 - \\lfloor 0.0 \\rfloor, 0.5 - \\lfloor 1.0 \\rfloor) = (-0.5, -0.5, -0.5)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5.5, -4.0, -4.5)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5.5)^2+(-4)^2+(-4.5)^2} = \\sqrt{66.5} \\approx 8.154753$.\n\n案例 4：$H = \\begin{bmatrix} 5 & 4 & 3 \\\\ 0 & 5 & 2 \\\\ 0 & 0 & 5 \\end{bmatrix}$, $\\mathbf{r}_i = (4.9, 0.1, 0.1)$, $\\mathbf{r}_j = (0.2, 4.9, 0.2)$.\n$\\Delta \\mathbf{r} = (-4.7, 4.8, 0.1)$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (-1.7136, 0.952, 0.02)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (-1.7136 - \\lfloor -1.2136 \\rfloor, 0.952 - \\lfloor 1.452 \\rfloor, 0.02 - \\lfloor 0.52 \\rfloor) = (0.2864, -0.048, 0.02)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (1.3, -0.2, 0.1)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{1.3^2+(-0.2)^2+0.1^2} = \\sqrt{1.74} \\approx 1.319091$.\n\n实现将遵循此推导出的过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Minimum Image Convention displacement for a series of test cases\n    in triclinic periodic boundary conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"H\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"r_i\": np.array([1.0, 2.0, 3.0]),\n            \"r_j\": np.array([9.0, 9.0, 9.0])\n        },\n        {\n            \"H\": np.array([\n                [10.0, 2.0, 1.0],\n                [0.0, 8.0, 1.0],\n                [0.0, 0.0, 6.0]\n            ]),\n            \"r_i\": np.array([1.0, 1.0, 1.0]),\n            \"r_j\": np.array([9.0, 7.0, 5.0])\n        },\n        {\n            \"H\": np.array([\n                [8.0, 1.0, 2.0],\n                [0.0, 7.0, 1.0],\n                [0.0, 0.0, 9.0]\n            ]),\n            \"r_i\": np.array([0.0, 0.0, 0.0]),\n            \"r_j\": np.dot(\n                np.array([\n                    [8.0, 1.0, 2.0],\n                    [0.0, 7.0, 1.0],\n                    [0.0, 0.0, 9.0]\n                ]),\n                np.array([0.5, -0.5, 0.5])\n            )\n        },\n        {\n            \"H\": np.array([\n                [5.0, 4.0, 3.0],\n                [0.0, 5.0, 2.0],\n                [0.0, 0.0, 5.0]\n            ]),\n            \"r_i\": np.array([4.9, 0.1, 0.1]),\n            \"r_j\": np.array([0.2, 4.9, 0.2])\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        H = case[\"H\"]\n        r_i = case[\"r_i\"]\n        r_j = case[\"r_j\"]\n\n        # Step 1: Calculate the raw displacement vector in Cartesian coordinates.\n        delta_r = r_j - r_i\n\n        # Step 2: Convert delta_r to fractional coordinates.\n        H_inv = np.linalg.inv(H)\n        s = H_inv @ delta_r\n\n        # Step 3: Apply the minimum image condition in fractional space.\n        # This maps each component to the interval [-0.5, 0.5).\n        # s_mic = s - n, where n is the nearest integer vector to s.\n        # This is equivalent to s_mic = s - round(s).\n        # A numerically stable way to implement rounding to the nearest integer\n        # with a consistent tie-breaking rule (x.5 -> x-1) is s - floor(s + 0.5)\n        s_mic = s - np.floor(s + 0.5)\n\n        # Step 4: Convert the reduced fractional vector back to Cartesian coordinates.\n        delta_r_mic = H @ s_mic\n\n        # Step 5: Compute the Euclidean norm of the final vector.\n        norm_mic = np.linalg.norm(delta_r_mic)\n\n        # Format the result for the final output string.\n        result_vector = [\n            delta_r_mic[0],\n            delta_r_mic[1],\n            delta_r_mic[2],\n            norm_mic\n        ]\n        \n        # Round each number to 6 decimal places and format as a string list.\n        formatted_vector = [f\"{val:.6f}\" for val in result_vector]\n        results_as_strings.append(f\"[{','.join(formatted_vector)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2414062"}, {"introduction": "最小镜像约定的应用远不止计算孤立粒子间的距离，它对于分析跨越周期性边界的宏观结构（如聚合物链）的性质至关重要。当一条长链“缠绕”穿过模拟盒子时，其首尾两端的坐标可能在盒子中看起来很近。这个练习挑战你思考如何正确计算这条链的真实首尾距离，揭示了逐个键矢量地应用最小镜像约定以“解开”分子构象的重要性。[@problem_id:2460073]", "problem": "在一次分子动力学模拟中，一个包含 $N$ 个单体的聚合物被置于一个边长为 $L$ 的立方模拟盒子中，并采用周期性边界条件 (PBC)。存储的单体笛卡尔坐标 $\\mathbf{r}_0,\\mathbf{r}_1,\\dots,\\mathbf{r}_{N-1}$ 是经过折叠的，使得每个笛卡尔分量都位于区间 $[0,L)$ 内。该聚合物可能比 $L$ 更长，并可能多次穿过盒子边界。最小镜像约定 (MIC) 的定义如下：对于任意两个位置之间的位移 $\\Delta \\mathbf{r}$，$\\mathrm{MIC}(\\Delta \\mathbf{r})$ 是在周期性边界条件下与之等价且具有最小欧几里得范数的唯一位移矢量（等价地，每个笛卡尔分量取值于 $(-L/2,L/2]$ 区间内）。\n\n端到端距离定义为从单体 0 到单体 $N-1$ 的展开的端到端矢量的欧几里得范数，即通过对存储的坐标加上或减去 $L$ 的适当整数倍，使聚合物跨越边界后变得连续所得到的矢量范数。\n\n对于一条可能比 $L$ 长的链，在周期性边界条件下，下列哪个表达式能直接从折叠坐标 $\\{\\mathbf{r}_i\\}$ 和 $L$ 计算出正确的端到端距离？\n\nA. $d \\;=\\; \\left\\|\\, \\mathrm{MIC}\\!\\left(\\mathbf{r}_{N-1}-\\mathbf{r}_0\\right) \\right\\|$\n\nB. $d \\;=\\; \\left\\|\\, \\displaystyle\\sum_{i=0}^{N-2} \\mathrm{MIC}\\!\\left(\\mathbf{r}_{i+1}-\\mathbf{r}_i\\right) \\right\\|$\n\nC. $d \\;=\\; \\left\\|\\, \\mathbf{r}_{N-1}-\\mathbf{r}_0 \\right\\|$\n\nD. $d \\;=\\; \\left\\|\\, \\displaystyle\\sum_{i=0}^{N-2} \\left(\\mathbf{r}_{i+1}-\\mathbf{r}_i\\right) \\right\\|$", "solution": "在尝试求解之前，需对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 系统：一个包含 $N$ 个单体的聚合物。\n- 模拟盒子：立方体，边长为 $L$。\n- 边界条件：周期性边界条件 (PBC)。\n- 单体位置：一组存储的笛卡尔坐标，$\\mathbf{r}_0, \\mathbf{r}_1, \\dots, \\mathbf{r}_{N-1}$。\n- 坐标折叠：任何 $\\mathbf{r}_i$ 的每个笛卡尔分量都位于区间 $[0, L)$ 内。\n- 聚合物构象：该聚合物可能比 $L$ 更长，并可能多次穿过盒子边界。\n- 最小镜像约定 (MIC)：对于任意位移 $\\Delta \\mathbf{r}$，矢量 $\\mathrm{MIC}(\\Delta \\mathbf{r})$ 是在 PBC 下等价的、具有最小欧几里得范数的唯一位移，其每个笛卡尔分量都在区间 $(-L/2, L/2]$ 内。\n- 端到端距离的定义：从单体 0 到单体 $N-1$ 的*展开的*端到端矢量的欧几里得范数。这个展开的矢量是通过使聚合物链跨越边界处连续而得到的。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题设置在分子动力学模拟的背景下，这是计算化学和物理学中的一种标准方法。周期性边界条件 (PBC)、折叠坐标和最小镜像约定 (MIC) 的概念是该领域的基本原理，并且定义正确。\n- **适定性：** 该问题对需要计算的量（展开链的端到端距离）给出了清晰明确的定义，并要求使用给定的折叠坐标来计算它。所有必要的信息和定义都已提供。基于这些原理存在唯一的解。\n- **客观性：** 语言正式且精确。定义是数学性的，没有主观性。\n\n**步骤 3：结论与行动**\n问题陈述在科学上是合理的、适定的和客观的。它不包含任何逻辑矛盾或含糊之处。因此，该问题是**有效的**。下面将推导解决方案。\n\n**求解推导**\n\n让 $\\mathbf{R}_i$ 表示第 $i$ 个单体的*展开的*笛卡尔位置矢量。链是空间中一系列点 $\\mathbf{R}_0, \\mathbf{R}_1, \\dots, \\mathbf{R}_{N-1}$。问题将端到端距离 $d$ 定义为展开的端到端矢量 $\\mathbf{V}_{\\text{e2e}}$ 的欧几里得范数：\n$$\n\\mathbf{V}_{\\text{e2e}} = \\mathbf{R}_{N-1} - \\mathbf{R}_0\n$$\n$$\nd = \\left\\| \\mathbf{V}_{\\text{e2e}} \\right\\| = \\left\\| \\mathbf{R}_{N-1} - \\mathbf{R}_0 \\right\\|\n$$\n展开的端到端矢量可以表示为展开的键矢量 $(\\mathbf{R}_{i+1} - \\mathbf{R}_i)$ 的伸缩求和：\n$$\n\\mathbf{V}_{\\text{e2e}} = \\sum_{i=0}^{N-2} (\\mathbf{R}_{i+1} - \\mathbf{R}_i)\n$$\n存储的坐标 $\\mathbf{r}_i$ 是 $\\mathbf{R}_i$ 的折叠版本。这意味着对于每个坐标分量 $\\alpha \\in \\{x, y, z\\}$，我们有 $r_{i\\alpha} = R_{i\\alpha} \\pmod L$。\n\n我们的任务是仅使用折叠坐标 $\\{\\mathbf{r}_i\\}$ 和盒子长度 $L$ 来计算 $\\mathbf{V}_{\\text{e2e}}$。为此，我们必须从折叠坐标 $\\mathbf{r}_i$ 和 $\\mathbf{r}_{i+1}$ 重构出每个真实的键矢量 $\\mathbf{R}_{i+1} - \\mathbf{R}_i$。\n\n考虑从折叠坐标计算出的位移矢量 $\\Delta\\mathbf{r}_i = \\mathbf{r}_{i+1} - \\mathbf{r}_i$。该矢量的分量位于 $(-L, L)$ 区间内。由于当单体穿过边界时坐标会发生折叠，这个矢量通常不是真实的物理键矢量 $\\mathbf{R}_{i+1} - \\mathbf{R}_i$。\n\n最小镜像约定 (MIC) 就是为了解决这个问题而设计的。当应用于两个粒子之间的位移时，$\\mathrm{MIC}(\\mathbf{r}_{i+1} - \\mathbf{r}_i)$ 会找到连接单体 $i$ 的位置和单体 $i+1$ 的位置（或其某个周期性镜像）的最短矢量。对于聚合物链，一个标准的假设是共价键很短，具体来说，相邻单体之间的距离在所有维度上都小于 $L/2$。在此条件下，MIC 能正确识别出真实的物理键矢量。\n$$\n\\mathbf{R}_{i+1} - \\mathbf{R}_i = \\mathrm{MIC}(\\mathbf{r}_{i+1} - \\mathbf{r}_i)\n$$\n将此代入总端到端矢量的表达式中，我们得到正确的重构公式：\n$$\n\\mathbf{V}_{\\text{e2e}} = \\sum_{i=0}^{N-2} \\mathrm{MIC}(\\mathbf{r}_{i+1} - \\mathbf{r}_i)\n$$\n最后，端到端距离 $d$ 是这个重构矢量的欧几里得范数：\n$$\nd = \\left\\| \\sum_{i=0}^{N-2} \\mathrm{MIC}(\\mathbf{r}_{i+1} - \\mathbf{r}_i) \\right\\|\n$$\n这个过程通过对一系列真实的键矢量求和，正确地展开了整条链，即使链的总长度是盒子边长 $L$ 的许多倍，该方法也有效。\n\n**选项评估**\n\n**A. $d \\;=\\; \\left\\|\\, \\mathrm{MIC}\\!\\left(\\mathbf{r}_{N-1}-\\mathbf{r}_0\\right) \\right\\|$**\n该表达式计算了第一个和最后一个单体折叠位置之间的位移矢量，然后应用 MIC。这会得到在考虑所有周期性镜像的情况下，单体 0 和单体 $N-1$ 之间可能的最短距离。然而，这忽略了这两点之间聚合物链的连通性。如果聚合物链环绕周期性盒子，其真实的端到端矢量可能比端点位移的 MIC 大得多。此计算找到的是两个独立粒子之间的距离，而不是连接它们的聚合物的端到端距离。\n结论：**不正确**。\n\n**B. $d \\;=\\; \\left\\|\\, \\displaystyle\\sum_{i=0}^{N-2} \\mathrm{MIC}\\!\\left(\\mathbf{r}_{i+1}-\\mathbf{r}_i\\right) \\right\\|$**\n该表达式遵循了上面推导的精确逻辑。它首先计算每个键的真实物理矢量 $\\mathrm{MIC}(\\mathbf{r}_{i+1}-\\mathbf{r}_i)$。然后，它将这些键矢量相加，以重构出完整的、展开的端到端矢量。最后，它计算所得矢量的范数。这正确地考虑了聚合物的路径，包括任何对周期性边界的穿越。\n结论：**正确**。\n\n**C. $d \\;=\\; \\left\\|\\, \\mathbf{r}_{N-1}-\\mathbf{r}_0 \\right\\|$**\n该表达式计算了末端单体折叠坐标之间位移矢量的范数。它没有应用 MIC，因此甚至没有找到端点之间的最短距离。例如，如果 $L=10$，$\\mathbf{r}_0 = (1,0,0)$ 且 $\\mathbf{r}_{N-1}=(9,0,0)$，此公式给出的距离是 $8$，而通过周期性边界的最小距离是 $2$。更根本的是，与选项 A 一样，它完全忽略了聚合物链的路径。这仅对不穿越任何边界的短链有效，而这与问题陈述中链可以比 $L$ 长相矛盾。\n结论：**不正确**。\n\n**D. $d \\;=\\; \\left\\|\\, \\displaystyle\\sum_{i=0}^{N-2} \\left(\\mathbf{r}_{i+1}-\\mathbf{r}_i\\right) \\right\\|$**\n范数内的求和是一个伸缩级数：\n$$\n\\sum_{i=0}^{N-2} (\\mathbf{r}_{i+1}-\\mathbf{r}_i) = (\\mathbf{r}_1-\\mathbf{r}_0) + (\\mathbf{r}_2-\\mathbf{r}_1) + \\dots + (\\mathbf{r}_{N-1}-\\mathbf{r}_{N-2}) = \\mathbf{r}_{N-1} - \\mathbf{r}_0\n$$\n因此，此表达式在数学上与选项 C 完全相同：$d = \\|\\mathbf{r}_{N-1}-\\mathbf{r}_0\\|$。正如在对选项 C 的分析中确定的那样，这是不正确的。对折叠位移矢量的求和抵消了所有中间单体的位置，未能重构出真实的链路径。\n结论：**不正确**。", "answer": "$$\\boxed{B}$$", "id": "2460073"}]}