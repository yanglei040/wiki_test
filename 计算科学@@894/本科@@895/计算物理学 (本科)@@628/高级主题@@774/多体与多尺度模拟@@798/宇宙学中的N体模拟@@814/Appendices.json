{"hands_on_practices": [{"introduction": "宇宙学模拟需要追踪数以百万计的粒子，直接计算所有粒子对之间的引力（复杂度为 $O(N^2)$）是不可行的。本实践将介绍一种强大的粒子-网格（Particle-Mesh, PM）方法，它通过在网格上使用快速傅里叶变换（FFT）求解泊松方程，极大地加快了引力计算速度。通过亲手实现这个求解器，你将掌握大规模结构模拟的核心引擎之一 [@problem_id:2416244]。", "problem": "实现一个完整的二维粒子-网格 (Particle-Mesh, PM) 求解器，使用快速傅里叶变换 (Fast Fourier Transform, FFT) 方法求解具有周期性边界条件的牛顿宇宙学泊松方程。其控制方程是三维泊松方程，应用于一个沿某一轴具有平移不变性的构型，因此场和源仅依赖于两个空间坐标：\n$$\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x}),$$\n在方形区域上具有周期性边界条件。在代码单位下进行计算，盒子边长 $L = 1$，引力常数 $G = 1$。在此设定下，$\\rho(\\mathbf{x})$ 是由粒子通过质量分配产生的单位面积质量密度场，或直接在网格上指定为解析函数，而 $\\phi(\\mathbf{x})$ 是引力势。加速度场由下式给出\n$$\\mathbf{a}(\\mathbf{x}) = - \\nabla \\phi(\\mathbf{x}).$$\n从周期性网格上的离散傅里叶变换和牛顿引力的基本定义出发，推导谱解法，使您能够通过 FFT 从密度场计算加速度场。不要使用任何预先存在的势核或力核；直接根据控制方程和傅里叶变换的定义推导并实现它们。使用“单元云” (Cloud-In-Cell, CIC) 质量分配方案将粒子质量沉积到网格上，并使用相同的 CIC 权重将网格加速度插值回粒子位置，以最小化网格引起的自相互作用力。根据宇宙学惯例，通过强制零均值源来一致地处理零波数（平均密度）模式：将 $\\mathbf{k}=\\mathbf{0}$ 模式设为零，以确保引力势没有均匀或线性增长的分量。\n\n您的程序必须：\n- 在大小为 $N \\times N$ 的均匀二维网格上实现周期性边界条件，其中 $N$ 是2的幂。\n- 实现 CIC 质量分配方案，将粒子质量映射到域 $[0,L)\\times[0,L)$ (其中 $L=1$) 上的网格化密度场 $\\rho_{i,j}$。\n- 实现基于 FFT 的谱泊松求解器，以获取势 $\\phi$ 进而得到 $\\mathbf{a}=-\\nabla\\phi$，或者直接在傅里叶空间中从 $\\rho$ 计算加速度场 $\\mathbf{a}$。\n- 使用与质量分配相同的 CIC 权重，将加速度场从网格插值回粒子位置。\n- 使用双精度浮点运算。\n\n设计一个确定性的测试套件来验证实现的不同方面。使用以下四个测试用例 (全部在代码单位下，且 $L=1$，$G=1$)：\n- 测试 A (傅里叶模式求解器精度)：在 $N=64$ 的网格上，将密度场解析地设为 $\\rho(x,y) = \\cos(2\\pi x)$。通过您的谱方法求解势 $\\phi(x,y)$，并将其与控制方程和周期性边界条件所蕴含的精确解进行比较。计算所有网格点上的最大绝对误差，\n$$\\varepsilon_{\\mathrm{mode}} = \\max_{i,j} \\left| \\phi_{\\mathrm{num}}(x_i,y_j) - \\phi_{\\mathrm{exact}}(x_i,y_j) \\right|,$$\n并以浮点数形式报告 $\\varepsilon_{\\mathrm{mode}}$。\n- 测试 B (远离边界的双粒子对称性)：在 $N=64$ 的网格上，在位置 $(x_1,y_1)=(0.25,0.5)$ 和 $(x_2,y_2)=(0.75,0.5)$ 放置两个等质量粒子，质量为 $m_1=m_2 = \\tfrac{1}{2}$。使用 CIC 将其质量沉积到网格，减去平均密度，计算网格加速度，并将加速度插值回粒子位置。将对称性误差定义为\n$$\\varepsilon_{\\mathrm{sym}} = \\frac{\\max\\!\\left(\\left\\|\\mathbf{a}_1+\\mathbf{a}_2\\right\\|, \\, |a_{1,y}|+|a_{2,y}|\\right)}{\\max\\!\\left(\\left\\|\\mathbf{a}_1\\right\\|, \\left\\|\\mathbf{a}_2\\right\\|\\right)},$$\n并以浮点数形式报告 $\\varepsilon_{\\mathrm{sym}}$。\n- 测试 C (多粒子净力一致性)：在 $N=64$ 的网格上，将 $N_{\\mathrm{p}}=200$ 个粒子放置在 $[0,1)\\times[0,1)$ 内均匀抽样的位置上，其质量相等，为 $m_i = 1/N_{\\mathrm{p}}$。通过 CIC 进行质量沉积，减去平均密度，计算加速度网格，并插值到粒子位置。计算净质量加权加速度的大小，\n$$\\varepsilon_{\\mathrm{net}} = \\left\\| \\sum_{i=1}^{N_{\\mathrm{p}}} m_i \\, \\mathbf{a}_i \\right\\|,$$\n并以浮点数形式报告 $\\varepsilon_{\\mathrm{net}}$。\n- 测试 D (周期性环绕对称性)：在 $N=64$ 的网格上，在位置 $(x_1,y_1)=(0.01,0.5)$ 和 $(x_2,y_2)=(0.99,0.5)$ 放置两个等质量粒子，质量为 $m_1=m_2=\\tfrac{1}{2}$，这两个粒子被周期性边界分隔。重复 CIC 质量沉积、平均密度减除、加速度计算和插值过程。计算并报告与测试 B 中相同的对称性误差 $\\varepsilon_{\\mathrm{sym,wrap}}$。\n\n本问题不使用角度单位。所有量均为指定的无量纲代码单位。您的程序必须按顺序计算测试 A、B、C 和 D 的四个标量结果，并生成单行输出，其中包含这四个值，格式为方括号内的逗号分隔列表，例如\n`[v_A,v_B,v_C,v_D]`。\n每个值都必须以标准浮点表示法的小数形式打印。\n\n您的实现必须是完整和自包含的，并且不得读取任何外部输入。测试 C 中的随机粒子位置必须使用固定的种子生成，以确保确定性。", "solution": "用户提供了一个计算物理学中有效且适定的问题。任务是实现一个用于求解具有周期性边界条件的牛顿泊松方程的二维粒子-网格 (PM) 求解器，并用一套特定的测试来验证它。该问题具有科学依据，算法具体，并为确定性实现提供了所有必要的参数。\n\n解决方案首先推导求解泊松方程的谱方法，然后解释质量分配和力插值方案。最后，概述了数值算法，该算法构成了所提供代码的基础。\n\n### 1. 泊松方程和谱方法\n\n控制方程是由质量密度分布 $\\rho(\\mathbf{x})$ 产生的引力势 $\\phi(\\mathbf{x})$ 的二维泊松方程：\n$$ \\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x}) $$\n其中 $\\mathbf{x} = (x, y)$ 是空间坐标，$\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 是拉普拉斯算子，$G$ 是引力常数。问题设置在具有周期性边界条件的方形域 $[0, L) \\times [0, L)$ 中。我们在代码单位下工作，其中 $L=1$，$G=1$。\n\n谱方法利用了傅里叶变换的性质，傅里叶变换可将微分算子对角化。函数 $f(\\mathbf{x})$ 的连续傅里叶变换定义为 $\\hat{f}(\\mathbf{k}) = \\int f(\\mathbf{x}) e^{-i \\mathbf{k} \\cdot \\mathbf{x}} d\\mathbf{x}$。将其应用于泊松方程，拉普拉斯项变为：\n$$ \\mathcal{F}\\{\\nabla^2 \\phi(\\mathbf{x})\\} = -\\|\\mathbf{k}\\|^2 \\hat{\\phi}(\\mathbf{k}) = -(k_x^2 + k_y^2) \\hat{\\phi}(\\mathbf{k}) $$\n这里，$\\mathbf{k}=(k_x, k_y)$ 是波矢。因此，傅里叶空间中的泊松方程是一个代数方程：\n$$ -k^2 \\hat{\\phi}(\\mathbf{k}) = 4\\pi G \\hat{\\rho}(\\mathbf{k}) $$\n其中 $k^2 = \\|\\mathbf{k}\\|^2$。这给出了傅里叶空间中引力势的解：\n$$ \\hat{\\phi}(\\mathbf{k}) = - \\frac{4\\pi G \\hat{\\rho}(\\mathbf{k})}{k^2} $$\n加速度场 $\\mathbf{a}(\\mathbf{x}) = -\\nabla \\phi(\\mathbf{x})$ 也可以在傅里叶空间中找到。梯度算子 $\\nabla$ 变换为乘以 $i\\mathbf{k}$：\n$$ \\hat{\\mathbf{a}}(\\mathbf{k}) = -i\\mathbf{k} \\hat{\\phi}(\\mathbf{k}) = -i\\mathbf{k} \\left( -\\frac{4\\pi G \\hat{\\rho}(\\mathbf{k})}{k^2} \\right) = i \\frac{4\\pi G \\mathbf{k}}{k^2} \\hat{\\rho}(\\mathbf{k}) $$\n这允许直接从密度计算加速度，这通常更有效率。\n\n在 $\\mathbf{k}=\\mathbf{0}$ 处出现奇点，其中 $k^2=0$。这对应于平均密度模式（直流分量）。对于周期性边界条件，只有当净源为零时，即 $\\int \\rho(\\mathbf{x}) d\\mathbf{x} = 0$，泊松方程才有解，这意味着 $\\hat{\\rho}(\\mathbf{k=0}) = 0$。在宇宙学模拟中，人们考虑的是均匀平均密度周围的密度起伏。通过减去这个平均值，我们确保 $\\hat{\\rho}(\\mathbf{0}) = 0$。因此，$\\mathbf{k}=\\mathbf{0}$ 模式对力没有贡献，所以我们可以设置 $\\hat{\\phi}(\\mathbf{0}) = 0$ 和 $\\hat{\\mathbf{a}}(\\mathbf{0}) = \\mathbf{0}$。\n\n### 2. 离散化和数值实现\n\n连续域在均匀的 $N \\times N$ 网格上进行离散化，网格间距为 $h=L/N$。函数 $f(\\mathbf{x})$ 由其在网格节点上的值 $f_{i,j} = f(i h, j h)$ 表示。傅里叶变换被离散傅里叶变换 (DFT) 取代，后者使用快速傅里叶变换 (FFT) 算法高效计算。\n\n网格函数 $f_{i,j}$ 的 DFT 为：\n$$ \\hat{f}_{k_x, k_y} = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} f_{i,j} e^{-2\\pi i (k_x i / N + k_y j / N)} $$\n与整数频率指数 $(k_x, k_y)$ 对应的离散波矢由 $\\mathbf{k} = (\\frac{2\\pi}{L} k'_x, \\frac{2\\pi}{L} k'_y)$ 给出，其中 $k'_x, k'_y$ 是大致范围从 $-N/2$ 到 $N/2$ 的整数波数。\n\n谱求解器算法如下：\n1.  获取网格上的离散密度场 $\\rho_{i,j}$。\n2.  计算其 DFT，$\\hat{\\rho}_{k_x,k_y} = \\text{FFT}(\\rho_{i,j})$。\n3.  通过设置 $\\hat{\\rho}_{0,0} = 0$ 来强制零平均密度。\n4.  在傅里叶空间中，计算势或加速度的变换。对于加速度，其分量为：\n    $$ \\hat{a}_{x; k_x, k_y} = \\left( i \\frac{4\\pi G k_x}{k_x^2 + k_y^2} \\right) \\hat{\\rho}_{k_x, k_y}, \\quad \\hat{a}_{y; k_x, k_y} = \\left( i \\frac{4\\pi G k_y}{k_x^2 + k_y^2} \\right) \\hat{\\rho}_{k_x, k_y} $$\n    对于 $\\mathbf{k} \\ne \\mathbf{0}$，且 $\\hat{\\mathbf{a}}_{0,0} = \\mathbf{0}$。括号中的项是谱响应函数或核。\n5.  对 $\\hat{a}_{x}$ 和 $\\hat{a}_{y}$ 进行逆 DFT，以获得网格上的加速度分量 $a_{x; i,j}$ 和 $a_{y; i,j}$。\n    $$ \\mathbf{a}_{i,j} = \\text{IFFT}(\\hat{\\mathbf{a}}_{k_x,k_y}) $$\n\n### 3. 质量分配和力插值\n\n在粒子-网格模拟中，粒子代表离散的质量块。密度场 $\\rho_{i,j}$是通过将每个粒子的质量分配到网格上来获得的。“单元云” (Cloud-In-Cell, CIC) 方案是一种二阶质量分配方法。对于位于位置 $\\mathbf{x}_p = (x_p, y_p)$、质量为 $m_p$ 的粒子，我们确定其所在的网格单元，其左下角位于 $(i,j) = (\\lfloor x_p/h \\rfloor, \\lfloor y_p/h \\rfloor)$。粒子的质量使用从双线性插值得出的权重分布到周围的四个网格节点上。粒子在其单元内的分数位移为 $\\delta_x = (x_p/h) - i$ 和 $\\delta_y = (y_p/h) - j$。质量分配如下：\n- 分配到节点 $(i,j)$：$m_p (1-\\delta_x)(1-\\delta_y)$\n- 分配到节点 $(i+1,j)$：$m_p \\delta_x(1-\\delta_y)$\n- 分配到节点 $(i,j+1)$：$m_p (1-\\delta_x)\\delta_y$\n- 分配到节点 $(i+1,j+1)$：$m_p \\delta_x \\delta_y$\n索引按模 $N$ 处理以遵循周期性边界条件。在对所有粒子的贡献求和后，网格质量 $M_{i,j}$ 通过 $\\rho_{i,j} = M_{i,j}/h^2$ 转换为密度。\n\n一旦在网格上计算出加速度场 $\\mathbf{a}_{i,j}$，粒子原始位置 $\\mathbf{x}_p$ 处的加速度 $\\mathbf{a}_p$ 就通过从网格插值得到。为确保动量守恒并抵消虚假的自相互作用力，插值必须使用与质量分配相同的权重方案。因此，粒子位置处的加速度为：\n$$ \\mathbf{a}_p = (1-\\delta_x)(1-\\delta_y)\\mathbf{a}_{i,j} + \\delta_x(1-\\delta_y)\\mathbf{a}_{i+1,j} + (1-\\delta_x)\\delta_y\\mathbf{a}_{i,j+1} + \\delta_x\\delta_y\\mathbf{a}_{i+1,j+1} $$\n\n### 4. 验证测试\n\n问题指定了四个测试来验证实现：\n- **测试 A：** 使用解析密度场 $\\rho(x,y) = \\cos(2\\pi x)$，其对应的势为 $\\phi(x,y) = -(1/\\pi)\\cos(2\\pi x)$。这测试了谱泊松求解器本身的精度，独立于粒子-网格操作。数值解应与解析解在机器精度范围内匹配。\n- **测试 B：** 在盒子中对称地放置两个粒子。根据对称性，粒子对上的净力应为零，每个粒子上的力应纯粹沿着连接它们的直线。这测试了 PM 力的计算和 CIC 方案的对称性。\n- **测试 C：** 使用大量随机放置的粒子。对于一个孤立系统，内力之和必须为零（牛顿第三定律的体现）。该测试测量净质量加权加速度的大小 $\\left\\| \\sum m_i \\mathbf{a}_i \\right\\|$，对于正确的实现，该值应接近于零。\n- **测试 D：** 与测试 B 类似，但将粒子放置在靠近周期性边界的位置。这专门测试 CIC 分配和插值步骤中周期性环绕的正确实现。\n\n实现将遵循这些原则来计算每个测试用例所需的误差度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests a 2D Particle-Mesh (PM) solver.\n    \"\"\"\n\n    class PM_Solver:\n        \"\"\"\n        A 2D Particle-Mesh solver for the Poisson equation with periodic BCs.\n        \"\"\"\n        def __init__(self, N, L=1.0, G=1.0):\n            \"\"\"\n            Initializes the solver.\n            Args:\n                N (int): Grid size (N x N).\n                L (float): Box side length.\n                G (float): Gravitational constant.\n            \"\"\"\n            if not (N > 0 and (N & (N-1) == 0)):\n                # This is not strictly required by the mathematics but is a problem constraint\n                # pass\n                a = 1 \n            \n            self.N = N\n            self.L = float(L)\n            self.G = float(G)\n            self.h = self.L / self.N\n            self.dtype = np.float64\n\n            # Pre-compute wavevectors\n            k_freq = np.fft.fftfreq(self.N, d=self.h)\n            k_phys = 2.0 * np.pi * k_freq\n            kx_phys, ky_phys = np.meshgrid(k_phys, k_phys, indexing='ij')\n\n            # Pre-compute spectral kernels\n            k_sq = kx_phys**2 + ky_phys**2\n            \n            # Kernel for potential: -1/k^2\n            self.potential_kernel = np.zeros_like(k_sq, dtype=self.dtype)\n            nonzero = k_sq != 0\n            self.potential_kernel[nonzero] = -1.0 / k_sq[nonzero]\n\n            # Kernel for acceleration: i*k_x/k^2 and i*k_y/k^2\n            self.accel_kernel_x = np.zeros_like(k_sq, dtype=np.complex128)\n            self.accel_kernel_y = np.zeros_like(k_sq, dtype=np.complex128)\n            self.accel_kernel_x[nonzero] = 1j * kx_phys[nonzero] / k_sq[nonzero]\n            self.accel_kernel_y[nonzero] = 1j * ky_phys[nonzero] / k_sq[nonzero]\n\n\n        def _assign_mass(self, particles):\n            \"\"\"\n            Assigns particle mass to the grid using Cloud-In-Cell (CIC).\n            \"\"\"\n            mass_grid = np.zeros((self.N, self.N), dtype=self.dtype)\n            for m_p, x_p, y_p in particles:\n                # Position in grid units\n                pos_gu = np.array([x_p, y_p]) / self.h\n                \n                # Bottom-left grid cell index and fractional displacement\n                idx = np.floor(pos_gu).astype(int)\n                delta = pos_gu - idx\n                \n                # Get indices of 4 cells, with periodic wrapping\n                ix, iy = idx[0], idx[1]\n                ixp1 = (ix + 1) % self.N\n                iyp1 = (iy + 1) % self.N\n\n                # CIC weights\n                w_ij = (1.0 - delta[0]) * (1.0 - delta[1])\n                w_ip1j = delta[0] * (1.0 - delta[1])\n                w_ijp1 = (1.0 - delta[0]) * delta[1]\n                w_ip1jp1 = delta[0] * delta[1]\n\n                # Assign mass\n                mass_grid[ix, iy] += m_p * w_ij\n                mass_grid[ixp1, iy] += m_p * w_ip1j\n                mass_grid[ix, iyp1] += m_p * w_ijp1\n                mass_grid[ixp1, iyp1] += m_p * w_ip1jp1\n            \n            density_grid = mass_grid / (self.h**2)\n            return density_grid\n\n        def _interpolate_accel(self, accel_x_grid, accel_y_grid, particles):\n            \"\"\"\n            Interpolates acceleration from grid to particle positions using CIC.\n            \"\"\"\n            accels = []\n            for _, x_p, y_p in particles:\n                pos_gu = np.array([x_p, y_p]) / self.h\n                idx = np.floor(pos_gu).astype(int)\n                delta = pos_gu - idx\n            \n                ix, iy = idx[0], idx[1]\n                ixp1 = (ix + 1) % self.N\n                iyp1 = (iy + 1) % self.N\n\n                w_ij = (1.0 - delta[0]) * (1.0 - delta[1])\n                w_ip1j = delta[0] * (1.0 - delta[1])\n                w_ijp1 = (1.0 - delta[0]) * delta[1]\n                w_ip1jp1 = delta[0] * delta[1]\n\n                a_x = (w_ij * accel_x_grid[ix, iy] +\n                       w_ip1j * accel_x_grid[ixp1, iy] +\n                       w_ijp1 * accel_x_grid[ix, iyp1] +\n                       w_ip1jp1 * accel_x_grid[ixp1, iyp1])\n                \n                a_y = (w_ij * accel_y_grid[ix, iy] +\n                       w_ip1j * accel_y_grid[ixp1, iy] +\n                       w_ijp1 * accel_y_grid[ix, iyp1] +\n                       w_ip1jp1 * accel_y_grid[ixp1, iyp1])\n                \n                accels.append(np.array([a_x, a_y], dtype=self.dtype))\n            \n            return np.array(accels)\n\n        def get_potential(self, density_grid):\n            \"\"\"\n            Calculates potential from a density grid.\n            \"\"\"\n            rho_k = np.fft.fft2(density_grid.astype(self.dtype))\n            phi_k = 4.0 * np.pi * self.G * self.potential_kernel * rho_k\n            phi = np.fft.ifft2(phi_k)\n            return phi.real\n\n        def get_particle_accel(self, particles):\n            \"\"\"\n            Calculates acceleration on particles.\n            \"\"\"\n            density_grid = self._assign_mass(particles)\n            rho_k = np.fft.fft2(density_grid.astype(self.dtype))\n            rho_k[0, 0] = 0.0 # Enforce zero mean density\n\n            ax_k = 4.0 * np.pi * self.G * self.accel_kernel_x * rho_k\n            ay_k = 4.0 * np.pi * self.G * self.accel_kernel_y * rho_k\n\n            ax_grid = np.fft.ifft2(ax_k).real\n            ay_grid = np.fft.ifft2(ay_k).real\n\n            particle_accels = self._interpolate_accel(ax_grid, ay_grid, particles)\n            return particle_accels\n\n    # --- Problem Parameters ---\n    N = 64\n    L = 1.0\n    G = 1.0\n\n    solver = PM_Solver(N=N, L=L, G=G)\n    results = []\n\n    # --- Test A: Fourier-mode solver accuracy ---\n    x_coords = np.arange(N, dtype=solver.dtype) * solver.h\n    rho_analytic = np.cos(2.0 * np.pi * x_coords)\n    rho_grid_A = np.zeros((N, N), dtype=solver.dtype)\n    rho_grid_A[:, :] = rho_analytic[:, np.newaxis]\n    \n    phi_num = solver.get_potential(rho_grid_A)\n    phi_exact = -(1.0 / np.pi) * rho_grid_A\n    \n    eps_mode = np.max(np.abs(phi_num - phi_exact))\n    results.append(eps_mode)\n\n    # --- Test B: two-particle symmetry away from boundaries ---\n    particles_B = [\n        (0.5, 0.25, 0.5), # (mass, x, y)\n        (0.5, 0.75, 0.5)\n    ]\n    accels_B = solver.get_particle_accel(particles_B)\n    a1_B, a2_B = accels_B[0], accels_B[1]\n    norm_a1_B = np.linalg.norm(a1_B)\n    norm_a2_B = np.linalg.norm(a2_B)\n\n    num_B = max(np.linalg.norm(a1_B + a2_B), abs(a1_B[1]) + abs(a2_B[1]))\n    den_B = max(norm_a1_B, norm_a2_B)\n    eps_sym = num_B / den_B if den_B != 0 else 0.0\n    results.append(eps_sym)\n    \n    # --- Test C: net-force consistency for many particles ---\n    Np_C = 200\n    np.random.seed(1234) # Fixed seed for determinism\n    positions_C = np.random.rand(Np_C, 2).astype(solver.dtype)\n    masses_C = np.full(Np_C, 1.0/Np_C, dtype=solver.dtype)\n    particles_C = [(masses_C[i], positions_C[i,0], positions_C[i,1]) for i in range(Np_C)]\n\n    accels_C = solver.get_particle_accel(particles_C)\n    net_force = np.sum(masses_C[:, np.newaxis] * accels_C, axis=0)\n    eps_net = np.linalg.norm(net_force)\n    results.append(eps_net)\n    \n    # --- Test D: periodic wrap symmetry ---\n    particles_D = [\n        (0.5, 0.01, 0.5),\n        (0.5, 0.99, 0.5)\n    ]\n    accels_D = solver.get_particle_accel(particles_D)\n    a1_D, a2_D = accels_D[0], accels_D[1]\n    norm_a1_D = np.linalg.norm(a1_D)\n    norm_a2_D = np.linalg.norm(a2_D)\n    \n    num_D = max(np.linalg.norm(a1_D + a2_D), abs(a1_D[1]) + abs(a2_D[1]))\n    den_D = max(norm_a1_D, norm_a2_D)\n    eps_sym_wrap = num_D / den_D if den_D != 0 else 0.0\n    results.append(eps_sym_wrap)\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2416244"}, {"introduction": "N体模拟会产生海量的粒子位置数据，但我们如何从这些数据中识别出像暗物质晕这样由引力束缚而成的结构呢？本练习将指导你实现“友邻”（Friends-of-Friends, FoF）算法，这是一种经典的渗流方法，用于将粒子分组到不同的晕中 [@problem_id:2416288]。掌握此技术是分析模拟输出、并将其与观测到的星系和星系团联系起来的关键第一步。", "problem": "在一个周期性的三维立方体区域内，实现一个具有可变连接长度参数的“朋友的朋友”（Friends-of-Friends, FoF）晕寻找器。从以下基本定义开始。设在一个边长为$L$、具有周期性边界条件的立方体盒子内，有$N$个粒子，其共动位置为$\\{\\mathbf{x}_i\\}_{i=1}^{N}$。全局数密度为 $n = N / L^3$。平均粒子间距为 $\\bar{\\ell} = n^{-1/3}$。每个粒子$i$被分配一个无量纲的连接长度因子$b_i$，该粒子的绝对连接长度定义为 $\\ell_i = b_i \\, \\bar{\\ell}$。粒子连通性的无向图定义如下：如果两个粒子$i$和$j$在最小镜像约定下的共动距离不大于它们各自连接长度的算术平均值，则它们相连，即最小镜像距离$r_{ij}$满足 $r_{ij} \\le \\tfrac{1}{2}(\\ell_i + \\ell_j)$。一个晕是此无向图的一个连通分量。将所有连通分量（包括孤立点）都视为晕。所有位置均以无量纲的共动盒子单位表示，所有距离均以与$L$相同的单位表示。不需要物理单位。\n\n你的任务是编写一个完整、可运行的程序，该程序能够：\n- 对每个测试用例，根据$N$和$L$计算$\\bar{\\ell}$。\n- 对每个粒子，计算$\\ell_i = b_i \\, \\bar{\\ell}$。\n- 使用周期性边界条件，通过最小镜像约定计算所有两两之间的距离$r_{ij}$：对于位移矢量$\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$，对其分量进行环绕处理 $\\Delta x \\mapsto \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$，对$\\Delta y$和$\\Delta z$也进行类似处理，然后$r_{ij} = \\|\\Delta \\mathbf{x}\\|_2$。\n- 当且仅当$r_{ij} \\le \\tfrac{1}{2}(\\ell_i + \\ell_j)$时，在$i$和$j$之间构造一条无向边。\n- 找到所有连通分量，并报告每个分量的大小（一个正整数），对每个测试用例按非递增顺序排序。\n\n基于上述定义和基本运动学（$\\mathbf{v} = d\\mathbf{x}/dt$）（在需要证明空间距离时使用），从第一性原理设计你的实现，不要使用任何预打包的图或聚类例程。每个测试用例的正确性标准是连通分量大小的列表。\n\n使用以下包含三个用例的测试套件。对于每个用例，程序应按规定计算晕的大小并汇总结果。\n\n测试用例A（两个紧凑且分离良好的粒子团）：\n- 盒子大小：$L = 2.0$。\n- 粒子数：$N = 8$。\n- 粒子位置 $\\mathbf{x}_i$（无量纲）：\n  - $\\mathbf{x}_1 = (\\,0.20,\\,0.20,\\,0.20\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.25,\\,0.20,\\,0.22\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.20,\\,0.26,\\,0.20\\,)$,\n  - $\\mathbf{x}_4 = (\\,0.24,\\,0.25,\\,0.24\\,)$,\n  - $\\mathbf{x}_5 = (\\,1.60,\\,1.60,\\,1.60\\,)$,\n  - $\\mathbf{x}_6 = (\\,1.65,\\,1.60,\\,1.58\\,)$,\n  - $\\mathbf{x}_7 = (\\,1.60,\\,1.66,\\,1.60\\,)$,\n  - $\\mathbf{x}_8 = (\\,1.58,\\,1.62,\\,1.64\\,)$.\n- 每个粒子的连接参数 $b_i$：\n  - 对所有 $i \\in \\{1,\\dots,8\\}$，$b_i = 0.20$。\n\n测试用例B（跨越盒子边界的周期性边界连接）：\n- 盒子大小：$L = 1.0$。\n- 粒子数：$N = 6$。\n- 粒子位置 $\\mathbf{x}_i$（无量纲）：\n  - $\\mathbf{x}_1 = (\\,0.05,\\,0.50,\\,0.50\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.07,\\,0.48,\\,0.52\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.04,\\,0.52,\\,0.49\\,)$,\n  - $\\mathbf{x}_4 = (\\,0.95,\\,0.50,\\,0.50\\,)$,\n  - $\\mathbf{x}_5 = (\\,0.93,\\,0.51,\\,0.49\\,)$,\n  - $\\mathbf{x}_6 = (\\,0.96,\\,0.48,\\,0.52\\,)$.\n- 每个粒子的连接参数 $b_i$：\n  - 对所有 $i \\in \\{1,\\dots,6\\}$，$b_i = 0.25$。\n\n测试用例C（可变的 $b_i$ 抑制了近对之间的连接）：\n- 盒子大小：$L = 1.0$。\n- 粒子数：$N = 4$。\n- 粒子位置 $\\mathbf{x}_i$（无量纲）：\n  - $\\mathbf{x}_1 = (\\,0.10,\\,0.10,\\,0.10\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.16,\\,0.10,\\,0.10\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.70,\\,0.70,\\,0.70\\,)$,\n  - $\\mathbf{x}_4 = (\\,0.74,\\,0.70,\\,0.70\\,)$.\n- 每个粒子的连接参数 $b_i$：\n  - $b_1 = 0.05$,\n  - $b_2 = 0.05$,\n  - $b_3 = 0.20$,\n  - $b_4 = 0.20$.\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由列表组成的列表，每个内部列表对应一个测试用例，包含该用例的晕大小，并按非递增顺序排序。例如，输出应类似于 $[[\\dots],[\\dots],[\\dots]]$，且仅包含整数。不应打印任何其他文本。", "solution": "我们通过将数密度、平均粒子间距和周期性距离的核心定义与图连通性分析相结合来构建解决方案。\n\n1. 定义和输入。对于一个边长为$L$、包含$N$个粒子的周期性立方体区域，全局数密度为 $n = N / L^3$。平均粒子间距为 $\\bar{\\ell} = n^{-1/3} = \\left( \\dfrac{L^3}{N} \\right)^{1/3} = \\dfrac{L}{N^{1/3}}$。每个粒子$i$被分配一个无量纲的单粒子因子$b_i$，因此其绝对连接长度为 $\\ell_i = b_i \\, \\bar{\\ell}$。\n\n2. 最小镜像距离。对于位于位置$\\mathbf{x}_i$和$\\mathbf{x}_j$的两个粒子，我们首先构造位移矢量$\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$。为了在最小镜像约定下实施周期性边界条件，我们对每个笛卡尔分量进行环绕处理：如果$\\Delta x$是$x$分量，则设置\n$$\n\\Delta x \\leftarrow \\Delta x - L \\cdot \\mathrm{round}\\!\\left(\\frac{\\Delta x}{L}\\right),\n$$\n对$y$和$z$分量也进行类似处理。最小镜像距离为 $r_{ij} = \\|\\Delta \\mathbf{x}\\|_2 = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}$。\n\n3. 连接准则。具有可变连接长度的“朋友的朋友”构造在粒子$i$和$j$之间的距离不超过其各自连接长度的对称平均值时，使用一条无向边连接它们：\n$$\nr_{ij} \\le \\frac{1}{2}\\left(\\ell_i + \\ell_j\\right).\n$$\n当$b_i \\ne b_j$时，这强制执行了一个一致的、对称的规则。\n\n4. 图和晕。通过上述不等式定义的边集，晕是在$N$个顶点上产生的无向图的连通分量。我们使用不相交集并集（也称为并查集）或广度优先搜索来识别分量；两者都是可接受的。每个粒子都恰好属于一个分量；大小为1的分量（孤立点）也包括在内。\n\n5. 每个测试用例的算法步骤。\n- 计算$N$和$L$，然后计算$\\bar{\\ell} = L / N^{1/3}$。\n- 对$i=1,\\dots,N$，计算$\\ell_i = b_i \\bar{\\ell}$。\n- 对于所有$i<j$的无序对$(i,j)$，使用最小镜像约定计算$r_{ij}$。\n- 如果$r_{ij} \\le \\tfrac{1}{2}(\\ell_i+\\ell_j)$，则添加一条无向边（等效地，在并查集数据结构中执行一次合并操作）。\n- 处理完所有对后，提取分量的大小并按非递增顺序排序。\n\n6. 应用于测试套件。\n- 测试用例A：$L = 2.0$，$N = 8$，因此$\\bar{\\ell} = L / N^{1/3} = 2.0 / 8^{1/3} = 2.0 / 2 = 1.0$。对于所有$i$，$b_i = 0.20$，所有$\\ell_i = 0.20$。粒子团内部的距离为$\\mathcal{O}(0.05)$–$\\mathcal{O}(0.1)$，满足$r_{ij} \\le 0.20$。粒子团之间的距离在最小镜像约定下$\\gtrsim 1.0$，这违反了$r_{ij} \\le 0.20$。因此，存在两个大小均为4的晕，得到排序后的列表$[4,4]$。\n\n- 测试用例B：$L = 1.0$，$N = 6$，因此$\\bar{\\ell} = L / N^{1/3} \\approx 1.0 / 6^{1/3} \\approx 0.550321$。当$b_i = 0.25$时，对于所有$i$，我们有$\\ell_i \\approx 0.137580$。在$x \\approx 0.05$附近的粒子与在$x \\approx 0.95$附近的粒子周期性地接近，跨越边界的距离满足$r_{ij} \\lesssim 0.11$，因此对于多个跨边界对，$r_{ij} \\le 0.137580$成立，将所有六个粒子连接成一个单独的晕。结果是$[6]$。\n\n- 测试用例C：$L = 1.0$，$N = 4$，因此$\\bar{\\ell} \\approx 1.0 / 4^{1/3} \\approx 0.629961$。对于粒子1和2，$b_1 = b_2 = 0.05$，所以$\\ell_1 = \\ell_2 \\approx 0.031498$；它们的距离约为$0.06$，这违反了$r_{12} \\le 0.031498$，所以它们没有被连接。对于粒子3和4，$b_3 = b_4 = 0.20$，所以$\\ell_3 = \\ell_4 \\approx 0.125992$，它们的距离约为$0.04$，这满足$r_{34} \\le 0.125992$，所以它们形成了一个大小为2的晕。$\\{1,2\\}$和$\\{3,4\\}$之间的交叉距离很大，混合阈值如$\\tfrac{1}{2}(\\ell_1+\\ell_3) \\approx 0.078745$也远低于这些距离，从而阻止了任何桥接。因此，排序后的大小为$[2,1,1]$。\n\n7. 输出格式。将三个用例的结果汇总成一个列表的列表，并单行打印，例如$[[\\dots],[\\dots],[\\dots]]$，不附加任何额外文本。\n\n下面的程序精确地遵循了这些步骤，为指定的测试套件计算结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef min_image_displacement(dx, L):\n    \"\"\"\n    Apply the minimum-image convention component-wise to a displacement vector dx\n    in a cubic periodic box of side length L.\n    \"\"\"\n    return dx - L * np.round(dx / L)\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = np.arange(n, dtype=int)\n        self.size = np.ones(n, dtype=int)\n\n    def find(self, x):\n        # Path compression\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra == rb:\n            return\n        # Union by size\n        if self.size[ra] < self.size[rb]:\n            ra, rb = rb, ra\n        self.parent[rb] = ra\n        self.size[ra] += self.size[rb]\n\ndef fof_variable_b(positions, L, b_values):\n    \"\"\"\n    Compute Friends-of-Friends halos with variable per-particle b-values.\n\n    positions: (N,3) numpy array of particle positions within [0,L).\n    L: float, box size (periodic).\n    b_values: (N,) numpy array of dimensionless linking-length factors.\n\n    Returns a list of component sizes sorted in nonincreasing order.\n    \"\"\"\n    positions = np.asarray(positions, dtype=float)\n    b_values = np.asarray(b_values, dtype=float)\n    N = positions.shape[0]\n    # Mean interparticle separation\n    lbar = L / (N ** (1.0 / 3.0))\n    # Per-particle linking lengths\n    l_i = b_values * lbar\n\n    # Build union-find structure\n    dsu = DisjointSetUnion(N)\n\n    # Check all pairs\n    for i in range(N - 1):\n        # Vectorized differences to all j>i\n        diffs = positions[i+1:] - positions[i]\n        # Apply minimum image to each component\n        diffs = min_image_displacement(diffs, L)\n        # Euclidean distances\n        rij = np.linalg.norm(diffs, axis=1)\n        # Thresholds: (l_i + l_j)/2\n        thresholds = 0.5 * (l_i[i] + l_i[i+1:])\n        # Determine links\n        links = rij <= thresholds\n        linked_js = np.where(links)[0] + (i + 1)\n        for j in linked_js:\n            dsu.union(i, j)\n\n    # Compute component sizes\n    roots, counts = np.unique([dsu.find(k) for k in range(N)], return_counts=True)\n    sizes = list(counts.astype(int))\n    sizes.sort(reverse=True)\n    return sizes\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case A\n    L_A = 2.0\n    positions_A = np.array([\n        [0.20, 0.20, 0.20],\n        [0.25, 0.20, 0.22],\n        [0.20, 0.26, 0.20],\n        [0.24, 0.25, 0.24],\n        [1.60, 1.60, 1.60],\n        [1.65, 1.60, 1.58],\n        [1.60, 1.66, 1.60],\n        [1.58, 1.62, 1.64],\n    ], dtype=float)\n    b_A = np.full(positions_A.shape[0], 0.20, dtype=float)\n\n    # Test case B\n    L_B = 1.0\n    positions_B = np.array([\n        [0.05, 0.50, 0.50],\n        [0.07, 0.48, 0.52],\n        [0.04, 0.52, 0.49],\n        [0.95, 0.50, 0.50],\n        [0.93, 0.51, 0.49],\n        [0.96, 0.48, 0.52],\n    ], dtype=float)\n    b_B = np.full(positions_B.shape[0], 0.25, dtype=float)\n\n    # Test case C\n    L_C = 1.0\n    positions_C = np.array([\n        [0.10, 0.10, 0.10],\n        [0.16, 0.10, 0.10],\n        [0.70, 0.70, 0.70],\n        [0.74, 0.70, 0.70],\n    ], dtype=float)\n    b_C = np.array([0.05, 0.05, 0.20, 0.20], dtype=float)\n\n    test_cases = [\n        (positions_A, L_A, b_A),\n        (positions_B, L_B, b_B),\n        (positions_C, L_C, b_C),\n    ]\n\n    results = []\n    for positions, L, bvals in test_cases:\n        sizes = fof_variable_b(positions, L, bvals)\n        results.append(sizes)\n\n    # Final print statement in the exact required format.\n    # Print a list of lists with integers only, single line.\n    # Ensure no extra spaces for strict formatting.\n    def list_to_str(lst):\n        if isinstance(lst, list):\n            return \"[\" + \",\".join(list_to_str(x) for x in lst) + \"]\"\n        else:\n            return str(int(lst))\n    print(list_to_str(results))\n\nsolve()\n```", "id": "2416288"}, {"introduction": "在模拟中识别出物质晕后，一个关键问题随之而来：这些结构在物理上是真实的吗？本实践将探讨如何使用统计力学中的一个基本定理——维里定理，来评估你模拟出的物质晕的稳定性 [@problem_id:2416301]。通过计算系统的动能 $T$ 和势能 $U$，并检验其是否满足 $2T + U = 0$ 的条件，你可以验证模拟的晕是否处于动态平衡状态。", "problem": "你需要编写一个完整、可运行的程序，来构建确定性的、孤立的、自引力粒子系统，该系统代表理想化的暗物质晕，并通过报告几种指定情况下的无量纲维里残差，来定量检验维里定理条件 $2T + U = 0$。所有量均采用无量纲的 N 体单位，其中引力常数 $G = 1$，所有角度均以弧度为单位。输出应为无量纲的实数。\n\n考虑一个由 $N$ 个等质量粒子组成的系统，总质量为 $M$，在牛顿引力下建模，并采用长度为 $\\epsilon > 0$ 的 Plummer 型引力软化。设粒子位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，速度为 $\\{\\mathbf{v}_i\\}_{i=1}^N$。定义质心参考系中的动能为\n$$\nT = \\frac{1}{2} \\, m \\sum_{i=1}^N \\left\\lVert \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{cm}} \\right\\rVert^2, \\quad \\text{其中} \\quad \\mathbf{v}_{\\mathrm{cm}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{v}_i,\n$$\n其中 $m = M/N$。定义软化引力势能为\n$$\nU = - G \\sum_{1 \\le i < j \\le N} \\frac{m^2}{\\sqrt{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^2 + \\epsilon^2}}.\n$$\n对于一个在平方反比力作用下的稳定、孤立系统，维里定理预测 $2T + U = 0$。\n\n初始条件按如下方式完全确定性地指定。\n\n- 位置：对于给定的 $N$ 和外部尺度 $R > 0$，将粒子 $k \\in \\{1,\\dots,N\\}$ 置于球坐标角度和半径\n$$\nq_k = \\frac{k}{N+1}, \\quad r_k = R \\, q_k, \\quad \\theta_k = \\arccos(1 - 2 q_k), \\quad \\phi_k = \\frac{2\\pi k}{\\varphi},\n$$\n其中 $\\varphi = \\frac{1+\\sqrt{5}}{2}$ 是黄金比例。其笛卡尔坐标位置为\n$$\n\\mathbf{r}_k = r_k \\begin{bmatrix} \\cos \\phi_k \\, \\sin \\theta_k \\\\ \\sin \\phi_k \\, \\sin \\theta_k \\\\ \\cos \\theta_k \\end{bmatrix}.\n$$\n\n- 速度：对于给定的非负无量纲因子 $f$，通过以下方式为每个粒子定义一个确定性的切线方向\n$$\n\\hat{\\mathbf{t}}_k = \\frac{\\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k}{\\lVert \\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k \\rVert} \\quad \\text{若 } \\lVert \\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k \\rVert > 10^{-12}, \\quad \\text{否则} \\quad \\hat{\\mathbf{t}}_k = \\frac{\\mathbf{e}_x \\times \\hat{\\mathbf{r}}_k}{\\lVert \\mathbf{e}_x \\times \\hat{\\mathbf{r}}_k \\rVert},\n$$\n其中 $\\hat{\\mathbf{r}}_k = \\mathbf{r}_k / \\lVert \\mathbf{r}_k \\rVert$，$\\mathbf{e}_z = [0,0,1]^T$ 且 $\\mathbf{e}_x = [1,0,0]^T$。构建基础切向场 $\\mathbf{u}_k = r_k \\, \\hat{\\mathbf{t}}_k$ 及其平均值 $\\mathbf{u}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{k=1}^N \\mathbf{u}_k$，并选择一个标量 $s \\ge 0$，使得质心动能等于\n$$\nT_{\\mathrm{target}} = f^2 \\left(-\\frac{U}{2}\\right).\n$$\n具体而言，设置\n$$\n\\mathbf{v}_k = s \\left(\\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}}\\right), \\quad \\text{其中} \\quad s = \\sqrt{\\frac{2 T_{\\mathrm{target}}}{m \\sum_{k=1}^N \\lVert \\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}} \\rVert^2}},\n$$\n并当 $T_{\\mathrm{target}} = 0$ 时，将 $s$ 解读为 $0$。\n\n- 软化：使用 Plummer 软化长度 $\\epsilon = \\eta \\, R$，其中 $\\eta$ 是一个指定的无量纲分数。\n\n对于下述每个测试用例，计算无量纲维里残差\n$$\n\\nu = \\frac{2T + U}{\\lvert U \\rvert}.\n$$\n\n您的程序必须实现上述确定性构建过程，并为以下测试套件中的每个用例生成 $\\nu$ 的值：\n\n- 用例 $1$：$N = 64$，$M = 1.0$，$R = 1.0$，$\\eta = 0.05$，$f = 1.0$。\n- 用例 $2$：$N = 8$，$M = 2.0$，$R = 0.5$，$\\eta = 0.1$，$f = 0.5$。\n- 用例 $3$：$N = 2$，$M = 1.0$，$R = 1.0$，$\\eta = 0.01$，$f = 0.0$。\n- 用例 $4$：$N = 3$，$M = 1.0$，$R = 1.5$，$\\eta = 0.2$，$f = 1.2$。\n\n最终输出格式：您的程序应生成单行输出，其中包含结果，格式为逗号分隔的浮点数列表，保留六位小数，并用方括号括起来，顺序与上述用例相同（例如，“[0.000000,-0.750000,-1.000000,0.440000]”）。", "solution": "问题陈述已经过严格验证。所有给定条件、定义和约束都已提取和分析。该问题被认定为有效。它在科学上以牛顿力学为基础，内部逻辑一致，且方法论上定义明确。它提出了一个清晰、确定性的算法，用于构建一个 N 体系统并随后计算一个物理可观测量。为测试用例提供的参数在物理上是合理的，在计算上是可行的。可以直接从问题定义中推导出的解析关系 $\\nu = f^2 - 1$，是数值实现的一个关键验证目标。该问题是计算物理学中的一个有效练习，旨在检验理论理解和实现准确性。我们将着手构建解决方案。\n\n任务是为几个指定的多粒子系统计算维里残差 $\\nu = \\frac{2T + U}{\\lvert U \\rvert}$。这需要系统地、分步地构建每个系统的初始条件（位置和速度），然后计算总动能 ($T$) 和总势能 ($U$) 。\n\n首先，我们为给定用例建立系统参数：粒子数 $N$、总质量 $M$、外部尺度半径 $R$、软化分数 $\\eta$ 和动能因子 $f$。引力常数给定为 $G=1$。由此，我们推导出每个粒子的质量 $m = M/N$ 和 Plummer 软化长度 $\\epsilon = \\eta R$。\n\n生成粒子位置 $\\{\\mathbf{r}_k\\}_{k=1}^N$ 是第一步。这个过程是确定性的。对于由 $k \\in \\{1, \\dots, N\\}$ 索引的每个粒子，我们计算一个中间变量 $q_k = \\frac{k}{N+1}$。该变量用于定义粒子的球坐标：半径 $r_k = R \\, q_k$、极角 $\\theta_k = \\arccos(1 - 2 q_k)$ 和方位角 $\\phi_k = \\frac{2\\pi k}{\\varphi}$，其中 $\\varphi = \\frac{1+\\sqrt{5}}{2}$ 是黄金比例。这种分布点的方法是球体上斐波那契螺旋线的一种变体，可产生相当均匀的角度分布。径向分布是一个简单的线性斜坡。然后使用标准变换将球坐标转换为笛卡尔坐标 $\\mathbf{r}_k = [x_k, y_k, z_k]^T$：\n$$\n\\mathbf{r}_k = r_k \\begin{pmatrix} \\cos \\phi_k \\sin \\theta_k \\\\ \\sin \\phi_k \\sin \\theta_k \\\\ \\cos \\theta_k \\end{pmatrix}.\n$$\n\n一旦所有粒子位置已知，我们就可以计算系统的总势能 $U$。势能是在软化引力势下成对相互作用的总和。公式为：\n$$\nU = - G \\sum_{1 \\le i < j \\le N} \\frac{m^2}{\\sqrt{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^2 + \\epsilon^2}}.\n$$\n求和遍历所有唯一的粒子对 $(i, j)$（其中 $i < j$）以避免重复计算相互作用。分母中的项 $\\epsilon^2$ 是 Plummer 软化，它防止势能在粒子间距非常近时发散到负无穷大。对于任何具有 $N \\ge 2$ 的系统，$U$ 都将是负值。\n\n接下来，我们确定速度。该程序旨在为系统赋予与其势能相关的特定动能。目标动能定义为 $T_{\\mathrm{target}} = f^2 \\left(-\\frac{U}{2}\\right)$。因子 $f$ 相对于维里平衡（其中 $T = -U/2$）所需的能量来缩放初始动能。\n\n为了生成能产生此动能的速度，我们首先定义一个确定性的速度场，然后对其进行缩放。对于每个粒子 $k$，构造一个切向方向矢量 $\\hat{\\mathbf{t}}_k$。该矢量与粒子的位置矢量 $\\hat{\\mathbf{r}}_k = \\mathbf{r}_k / \\lVert \\mathbf{r}_k \\rVert$ 正交。它是通过与固定的 z 轴单位矢量 $\\mathbf{e}_z = [0,0,1]^T$ 的叉积计算的：\n$$\n\\hat{\\mathbf{t}}_k = \\frac{\\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k}{\\lVert \\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k \\rVert}.\n$$\n包含了一个数值稳定性检查，用于处理 $\\hat{\\mathbf{r}}_k$ 与 $\\mathbf{e}_z$ 几乎共线的情况，此时改用与 $\\mathbf{e}_x = [1,0,0]^T$ 的叉积。然后定义一个基础速度场为 $\\mathbf{u}_k = r_k \\, \\hat{\\mathbf{t}}_k$。\n\n为确保最终系统的净动量为零，速度在基础场 $\\mathbf{u}_k$ 的质心参考系中设置。我们计算平均值 $\\mathbf{u}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{k=1}^N \\mathbf{u}_k$，并定义一组未缩放的、零质心速度 $\\mathbf{u}'_k = \\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}}$。最终速度通过缩放这些矢量获得，$\\mathbf{v}_k = s \\, \\mathbf{u}'_k$，其中选择标量 $s \\ge 0$ 以满足目标动能。质心参考系中的动能为 $T = \\frac{1}{2} m \\sum_{k=1}^N \\lVert \\mathbf{v}_k \\rVert^2$（因为根据构造，最终质心速度为零）。代入 $\\mathbf{v}_k = s(\\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}})$ 并设置 $T = T_{\\mathrm{target}}$，得到缩放因子的表达式：\n$$\ns = \\sqrt{\\frac{2 T_{\\mathrm{target}}}{m \\sum_{k=1}^N \\lVert \\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}} \\rVert^2}}.\n$$\n如果 $T_{\\mathrm{target}} = 0$（当 $f=0$ 时发生），则 $s=0$，所有粒子都处于静止状态。\n\n在完全确定了速度 $\\{\\mathbf{v}_k\\}_{k=1}^N$ 之后，计算系统的实际动能 $T$。它在质心参考系中定义：\n$$\nT = \\frac{1}{2} \\, m \\sum_{i=1}^N \\left\\lVert \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{cm}} \\right\\rVert^2, \\quad \\text{其中} \\quad \\mathbf{v}_{\\mathrm{cm}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{v}_i.\n$$\n根据构造，$\\mathbf{v}_{\\mathrm{cm}}$ 在解析上为零，但显式计算和减去它可以提供数值稳健性。计算出的 $T$ 值应在机器精度范围内等于 $T_{\\mathrm{target}}$。\n\n最后，使用计算出的 $T$ 和 $U$ 值计算无量纲维里残差 $\\nu$：\n$$\n\\nu = \\frac{2T + U}{\\lvert U \\rvert}.\n$$\n由于 $U<0$，这等价于 $\\nu = -(2T+U)/U$。如解析检验所示，由于 $T$ 被构造成 $T = f^2(-U/2)$，我们期望 $\\nu = f^2 - 1$。数值实现必须为每个测试用例复现这一结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_virial_residual(N, M, R, eta, f):\n    \"\"\"\n    Constructs a deterministic N-body system and calculates its virial residual.\n\n    Args:\n        N (int): Number of particles.\n        M (float): Total mass of the system.\n        R (float): Outer scale radius.\n        eta (float): Dimensionless softening fraction.\n        f (float): Dimensionless factor for target kinetic energy.\n\n    Returns:\n        float: The dimensionless virial residual nu.\n    \"\"\"\n    # 1. System constants and derived parameters\n    G = 1.0\n    phi_const = (1.0 + np.sqrt(5.0)) / 2.0\n    m = M / float(N)\n    epsilon = eta * R\n\n    # 2. Generate particle positions\n    k = np.arange(1, N + 1, dtype=np.float64)\n    q_k = k / (N + 1.0)\n    r_k = R * q_k\n    theta_k = np.arccos(1.0 - 2.0 * q_k)\n    phi_k = 2.0 * np.pi * k / phi_const\n\n    x = r_k * np.sin(theta_k) * np.cos(phi_k)\n    y = r_k * np.sin(theta_k) * np.sin(phi_k)\n    z = r_k * np.cos(theta_k)\n    positions = np.vstack((x, y, z)).T  # Shape: (N, 3)\n\n    # 3. Calculate potential energy U\n    if N < 2:\n        U = 0.0\n    else:\n        # Use broadcasting to get all pairwise squared distances efficiently\n        r_diff = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        dist_sq = np.sum(r_diff**2, axis=-1)\n        \n        # Get indices for the upper triangle of the distance matrix to sum unique pairs\n        i_upper, j_upper = np.triu_indices(N, k=1)\n        \n        pairwise_dist = np.sqrt(dist_sq[i_upper, j_upper] + epsilon**2)\n        U = -G * m**2 * np.sum(1.0 / pairwise_dist)\n\n    # 4. Calculate target kinetic energy\n    T_target = f**2 * (-U / 2.0)\n\n    # 5. Generate particle velocities\n    if T_target < 1e-15: # Handles f=0 case and avoids precision issues\n        velocities = np.zeros((N, 3))\n    else:\n        # Normalize position vectors to get unit vectors r_hat\n        r_norms = np.linalg.norm(positions, axis=1, keepdims=True)\n        r_hat = positions / r_norms\n\n        # Define canonical basis vectors\n        ez = np.array([0.0, 0.0, 1.0])\n        ex = np.array([1.0, 0.0, 0.0])\n\n        # Calculate tangential directions t_hat\n        c_z = np.cross(ez, r_hat)\n        c_z_norms = np.linalg.norm(c_z, axis=1, keepdims=True)\n        t_hat = np.zeros_like(positions)\n        \n        # Numerically stable case (not near z-axis)\n        mask_stable = (c_z_norms > 1e-12).flatten()\n        if np.any(mask_stable):\n            t_hat[mask_stable] = c_z[mask_stable] / c_z_norms[mask_stable]\n\n        # Fallback for particles near z-axis\n        mask_unstable = ~mask_stable\n        if np.any(mask_unstable):\n            c_x = np.cross(ex, r_hat[mask_unstable])\n            c_x_norms = np.linalg.norm(c_x, axis=1, keepdims=True)\n            t_hat[mask_unstable] = c_x / c_x_norms\n\n        # Base tangential velocity field u\n        u = r_k[:, np.newaxis] * t_hat\n        \n        # Make field have zero center of mass\n        u_cm = np.mean(u, axis=0)\n        u_prime = u - u_cm\n        \n        # Calculate velocity scaling factor s\n        s_sq_denom = m * np.sum(np.linalg.norm(u_prime, axis=1)**2)\n        \n        if s_sq_denom < 1e-15:\n            # This should not occur for N>1 with this position generator\n            s = 0.0\n        else:\n            s = np.sqrt(2.0 * T_target / s_sq_denom)\n\n        velocities = s * u_prime\n\n    # 6. Calculate actual kinetic energy T in the center-of-mass frame\n    v_cm = np.mean(velocities, axis=0)\n    v_prime = velocities - v_cm\n    T = 0.5 * m * np.sum(np.linalg.norm(v_prime, axis=1)**2)\n    \n    # 7. Calculate the dimensionless virial residual\n    if np.abs(U) < 1e-15:\n        # Unlikely for N>1, but handles division by zero\n        return 0.0\n\n    nu = (2.0 * T + U) / np.abs(U)\n    \n    return nu\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, M, R, eta, f)\n        (64, 1.0, 1.0, 0.05, 1.0),\n        (8, 2.0, 0.5, 0.1, 0.5),\n        (2, 1.0, 1.0, 0.01, 0.0),\n        (3, 1.0, 1.5, 0.2, 1.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, R, eta, f = case\n        result = calculate_virial_residual(N, M, R, eta, f)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2416301"}]}