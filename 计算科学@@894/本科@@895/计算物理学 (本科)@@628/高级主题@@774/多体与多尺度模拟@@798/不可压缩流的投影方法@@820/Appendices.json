{"hands_on_practices": [{"introduction": "投影步不仅仅是为了满足零散度约束而执行的数学流程；它在矢量场几何学中有着深刻的物理意义。本练习将投影算子视为一个正交投影，其作用是分离并移除速度场中的无旋（梯度）分量。通过这样做，它使流场的动能最小化，你将通过解析证明和数值验证来体验这一特性。[@problem_id:2430752]", "problem": "考虑一个在二维周期性域上的不可压缩流体。设该域为方形区域 $[0,2\\pi]\\times[0,2\\pi]$，且在两个方向上均具有周期性边界条件。设 $\\vec{u}(\\vec{x})$ 表示一个足够光滑的速度场，并定义动能为\n$$\nE[\\vec{u}] \\;=\\; \\int_{[0,2\\pi]^2} \\frac{1}{2}\\, \\lvert \\vec{u}(\\vec{x}) \\rvert^2 \\,\\mathrm{d}\\vec{x}.\n$$\n在不可压缩流的投影框架中，给定一个中间速度场 $\\vec{u}^{\\star}$，连续投影步通过求解一个标量场 $p$ 来生成一个无散速度场 $\\vec{u}^{\\mathrm{proj}}$，该标量场 $p$ 满足\n$$\n\\nabla^2 p \\;=\\; \\nabla\\cdot \\vec{u}^{\\star}, \\quad \\text{and} \\quad \\vec{u}^{\\mathrm{proj}} \\;=\\; \\vec{u}^{\\star} - \\nabla p,\n$$\n其中 $p$ 满足周期性边界条件，并为保证唯一性进行零均值归一化。所有三角函数中的角度均以弧度为单位。\n\n任务：\n1. 从基本原理证明，连续投影步在以下意义上是能量耗散的：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] \\;\\le\\; E[\\vec{u}^{\\star}],\n$$\n且等号成立的充要条件是 $\\nabla\\cdot \\vec{u}^{\\star} = 0$。\n\n2. 实现一个程序，对于下面列出的每个指定测试用例，在 $[0,2\\pi]\\times[0,2\\pi]$ 上的 $N\\times N$ 均匀网格点上构建速度场 $\\vec{u}^{\\star}$，应用一个数值上一致的离散投影步以获得离散无散速度场 $\\vec{u}^{\\mathrm{proj}}$，并计算动能的相对变化量\n$$\n\\delta \\;=\\; \\frac{E_h[\\vec{u}^{\\mathrm{proj}}] - E_h[\\vec{u}^{\\star}]}{E_h[\\vec{u}^{\\star}]},\n$$\n其中 $E_h[\\cdot]$ 是 $E[\\cdot]$ 在均匀网格上的标准矩形法则离散近似：\n$$\nE_h[\\vec{u}] \\;=\\; \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\frac{1}{2}\\left( u_x(x_i,y_j)^2 + u_y(x_i,y_j)^2 \\right)\\,\\Delta x\\,\\Delta y,\n$$\n其中 $\\Delta x = 2\\pi/N$ 和 $\\Delta y = 2\\pi/N$，且 $(x_i,y_j) = (i\\,\\Delta x, j\\,\\Delta y)$。\n\n测试套件（每个测试用例指定了 $N$ 和 $\\vec{u}^{\\star}$ 的解析形式；所有场都在 $[0,2\\pi]\\times[0,2\\pi]$ 上定义并具有周期性）：\n\n- 测试用例 A (无散输入)：\n  - 网格: $N = 64$.\n  - 流函数: $\\psi(x,y) = \\sin(x)\\cos(y)$.\n  - 速度: $\\vec{u}^{\\star}(x,y) = \\left(-\\partial_y \\psi(x,y), \\;\\partial_x \\psi(x,y)\\right)$.\n\n- 测试用例 B (纯无旋输入)：\n  - 网格: $N = 32$.\n  - 势函数: $\\phi(x,y) = \\sin(3x) + \\cos(2y)$.\n  - 速度: $\\vec{u}^{\\star}(x,y) = \\nabla \\phi(x,y)$.\n\n- 测试用例 C (混合输入：无散加无旋)：\n  - 网格: $N = 48$.\n  - 流函数: $\\psi(x,y) = \\sin(x)\\cos(y)$.\n  - 势函数: $\\phi(x,y) = \\sin(3x) + \\cos(2y)$.\n  - 混合系数: $\\alpha = 0.5$.\n  - 速度: $\\vec{u}^{\\star}(x,y) = \\left(-\\partial_y \\psi(x,y), \\;\\partial_x \\psi(x,y)\\right) + \\alpha\\,\\nabla \\phi(x,y)$.\n\n- 测试用例 D (均匀流，无散)：\n  - 网格: $N = 16$.\n  - 速度: $\\vec{u}^{\\star}(x,y) = (1.0,\\,-0.5)$.\n\n对于每个测试用例，您的程序必须计算上述定义的单个标量 $\\delta$。您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的十进制数列表，每个数精确到 10 位小数，用方括号括起来，顺序为 $[\\delta_A,\\delta_B,\\delta_C,\\delta_D]$。例如，一个可接受的输出格式是\n$[\\delta_A,\\delta_B,\\delta_C,\\delta_D]$\n其中每个 $\\delta$ 都精确到 10 位小数。不需要物理单位；所有量均为无量纲。", "solution": "该问题被验证为有科学依据、良定且客观。这是计算流体动力学中的一个标准问题。我们着手处理这两个任务。\n\n**任务1：能量耗散的证明**\n\n我们被要求证明投影步是能量耗散的，即 $E[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]$，并且等号成立的充要条件是初始场 $\\vec{u}^{\\star}$ 已经是无散的，即 $\\nabla\\cdot \\vec{u}^{\\star} = 0$。\n\n投影后的速度场 $\\vec{u}^{\\mathrm{proj}}$ 的动能定义为：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\mathrm{proj}}|^2 \\, \\mathrm{d}\\vec{x}\n$$\n其中 $\\Omega = [0, 2\\pi] \\times [0, 2\\pi]$ 是周期性域。\n\n根据定义，投影后的速度由 $\\vec{u}^{\\mathrm{proj}} = \\vec{u}^{\\star} - \\nabla p$ 给出。将其代入能量表达式可得：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\star} - \\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n我们展开被积函数中的范数平方项：\n$$\n|\\vec{u}^{\\star} - \\nabla p|^2 = (\\vec{u}^{\\star} - \\nabla p) \\cdot (\\vec{u}^{\\star} - \\nabla p) = |\\vec{u}^{\\star}|^2 - 2 \\vec{u}^{\\star} \\cdot \\nabla p + |\\nabla p|^2\n$$\n将此代回能量积分中：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\star}|^2 \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} + \\int_{\\Omega} \\frac{1}{2} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n第一项是中间场 $E[\\vec{u}^{\\star}]$ 的能量。所以我们有：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} + \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n让我们分析交叉项 $\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x}$。我们使用分部积分，在多维情况下，这依赖于散度定理。我们使用散度的乘积法则：$\\nabla \\cdot (p \\vec{u}^{\\star}) = (\\nabla p) \\cdot \\vec{u}^{\\star} + p (\\nabla \\cdot \\vec{u}^{\\star})$。重新整理可得：\n$$\n\\vec{u}^{\\star} \\cdot \\nabla p = \\nabla \\cdot (p \\vec{u}^{\\star}) - p (\\nabla \\cdot \\vec{u}^{\\star})\n$$\n在域 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = \\int_{\\Omega} \\nabla \\cdot (p \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} p (\\nabla \\cdot \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x}\n$$\n根据散度定理，散度在闭域（或周期性域，其边界项会相互抵消）上的积分等于零。因此，$\\int_{\\Omega} \\nabla \\cdot (p \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x} = 0$。\n方程简化为：\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} p (\\nabla \\cdot \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x}\n$$\n根据问题陈述，压力场 $p$ 是通过求解泊松方程 $\\nabla^2 p = \\nabla \\cdot \\vec{u}^{\\star}$ 得到的。将其代入：\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x}\n$$\n我们再次对右侧应用分部积分。使用恒等式 $\\nabla\\cdot(p\\nabla p) = \\nabla p \\cdot \\nabla p + p \\nabla^2 p = |\\nabla p|^2 + p\\nabla^2 p$：\n$$\n\\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x} = \\int_{\\Omega} \\nabla\\cdot(p\\nabla p) \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n同样，散度项 $\\nabla\\cdot(p\\nabla p)$ 在周期性域上的积分也为零。剩下：\n$$\n\\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n将此结果代回我们的交叉项表达式中：\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\left( - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} \\right) = \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n现在我们回到 $E[\\vec{u}^{\\mathrm{proj}}]$ 的表达式：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} + \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n被积函数 $|\\nabla p|^2$ 是一个实值量的平方，因此是非负的。所以，积分 $\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} \\ge 0$。\n这直接意味着：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]\n$$\n证明的第一部分到此结束。\n\n对于等号成立的条件，$E[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}]$ 当且仅当减去项为零时成立：\n$$\n\\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} = 0\n$$\n由于被积函数 $|\\nabla p|^2$ 是非负的，且函数 $p$ 被假定为足够光滑，该等式只有在被积函数处处恒等于零时才成立。即，对于所有 $\\vec{x} \\in \\Omega$，都有 $|\\nabla p(\\vec{x})|^2 = 0$，这意味着 $\\nabla p(\\vec{x}) = \\vec{0}$。\n这意味着标量场 $p$ 在整个域上必须是一个常数。\n问题陈述指出 $p$ 满足零均值归一化条件 $\\int_{\\Omega} p \\, \\mathrm{d}\\vec{x} = 0$。如果 $p$ 是一个常数 $C$，那么 $\\int_{\\Omega} C \\, \\mathrm{d}\\vec{x} = C \\cdot \\text{Area}(\\Omega) = 0$，这意味着 $C=0$。\n所以，对于所有 $\\vec{x}$，都有 $p(\\vec{x}) = 0$。\n\n如果 $p(\\vec{x})=0$，那么泊松方程 $\\nabla^2 p = \\nabla \\cdot \\vec{u}^{\\star}$ 变为 $\\nabla^2 (0) = 0 = \\nabla \\cdot \\vec{u}^{\\star}$。因此，如果 $\\nabla \\cdot \\vec{u}^{\\star} = 0$，等号成立。\n\n反之，如果 $\\nabla \\cdot \\vec{u}^{\\star} = 0$，我们必须求解带有周期性边界条件和零均值归一化的齐次泊松方程 $\\nabla^2 p = 0$。该问题的唯一解是 $p(\\vec{x}) = 0$。这意味着 $\\nabla p = \\vec{0}$，因此能量减去项 $\\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}$ 为零。这导致 $E[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}]$。\n\n因此，我们证明了 $E[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]$，且等号当且仅当 $\\nabla \\cdot \\vec{u}^{\\star} = 0$ 时成立。这表明投影算子将矢量场正交投影到无散场子空间上，通过移除纯梯度分量来最小化动能。\n\n**任务2：数值实现**\n\n数值实现应用了投影算子的离散版本，使用的是谱方法，该方法对于周期性问题具有很高的精度。算法步骤如下：\n\n1.  为每个测试用例构建网格和初始速度场 $\\vec{u}^{\\star}$。\n2.  计算初始离散动能 $E_h[\\vec{u}^{\\star}]$。\n3.  对 $\\vec{u}^{\\star}$ 的分量进行二维快速傅里叶变换（FFT），得到 $\\hat{u}^{\\star}_x$ 和 $\\hat{u}^{\\star}_y$。\n4.  计算散度的傅里叶变换，$\\widehat{\\nabla\\cdot \\vec{u}^{\\star}} = i k_x \\hat{u}^{\\star}_x + i k_y \\hat{u}^{\\star}_y$，其中 $k_x$ 和 $k_y$ 是对应于离散网格的整数波数。\n5.  在傅里叶空间中求解泊松方程 $\\nabla^2 p = \\nabla\\cdot \\vec{u}^{\\star}$。方程变为 $-(k_x^2 + k_y^2)\\hat{p} = \\widehat{\\nabla\\cdot \\vec{u}^{\\star}}$。压力的傅里叶系数解为 $\\hat{p} = \\frac{i k_x \\hat{u}^{\\star}_x + i k_y \\hat{u}^{\\star}_y}{k_x^2 + k_y^2}$。通过设置 $\\hat{p}(0,0)=0$ 来处理 $k_x=k_y=0$ 处的奇点，这也强制执行了 $p$ 的零均值条件。\n6.  计算压力梯度的傅里叶变换，$\\widehat{\\nabla p} = (i k_x \\hat{p}, i k_y \\hat{p})$。\n7.  应用二维逆傅里叶变换（IFFT）以在物理空间中获得压力梯度 $\\nabla p$。\n8.  计算投影后的速度场 $\\vec{u}^{\\mathrm{proj}} = \\vec{u}^{\\star} - \\nabla p$。\n9.  计算最终离散动能 $E_h[\\vec{u}^{\\mathrm{proj}}]$。\n10. 计算能量的相对变化量 $\\delta = (E_h[\\vec{u}^{\\mathrm{proj}}] - E_h[\\vec{u}^{\\star}]) / E_h[\\vec{u}^{\\star}]$。\n\n对所提供的四个测试用例中的每一个都实施此过程。\n- 用例 A 和 D 涉及解析上无散的场。计算出的 $\\delta$ 应接近于 0，任何非零值都是由浮点精度限制引起的。\n- 用例 B 涉及一个纯梯度场。投影应导致零速度场，$\\delta$ 应非常接近 -1。\n- 用例 C 是一个混合场。投影移除了梯度分量，导致一个负的 $\\delta$，其值取决于无散部分和无旋部分的相对能量。解析预测值为 $\\delta = -13/17 \\approx -0.7647$。数值结果应非常接近此值。\n\n提供的 Python 代码实现了该算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the projection problem for four test cases and computes the\n    relative change in kinetic energy.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 'A', 'N': 64, 'type': 'streamfunction'},\n        {'id': 'B', 'N': 32, 'type': 'potential'},\n        {'id': 'C', 'N': 48, 'type': 'mixed'},\n        {'id': 'D', 'N': 16, 'type': 'uniform'}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        L = 2.0 * np.pi\n        dx = L / N\n        dy = L / N\n        \n        # Create grid\n        x = np.arange(N) * dx\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        u_star_x = np.zeros((N, N))\n        u_star_y = np.zeros((N, N))\n\n        # Construct the intermediate velocity field u_star for each test case\n        if case['type'] == 'streamfunction':\n            # Case A: Divergence-free input\n            # psi(x,y) = sin(x)cos(y)\n            # u = -d_y psi = sin(x)sin(y)\n            # v =  d_x psi = cos(x)cos(y)\n            u_star_x = np.sin(xx) * np.sin(yy)\n            u_star_y = np.cos(xx) * np.cos(yy)\n        elif case['type'] == 'potential':\n            # Case B: Purely irrotational input\n            # phi(x,y) = sin(3x) + cos(2y)\n            # u = d_x phi = 3cos(3x)\n            # v = d_y phi = -2sin(2y)\n            u_star_x = 3.0 * np.cos(3.0 * xx)\n            u_star_y = -2.0 * np.sin(2.0 * yy)\n        elif case['type'] == 'mixed':\n            # Case C: Mixed input\n            alpha = 0.5\n            # Solenoidal part from streamfunction psi(x,y) = sin(x)cos(y)\n            u_psi_x = np.sin(xx) * np.sin(yy)\n            u_psi_y = np.cos(xx) * np.cos(yy)\n            # Irrotational part from potential phi(x,y) = sin(3x) + cos(2y)\n            u_phi_x = 3.0 * np.cos(3.0 * xx)\n            u_phi_y = -2.0 * np.sin(2.0 * yy)\n            u_star_x = u_psi_x + alpha * u_phi_x\n            u_star_y = u_psi_y + alpha * u_phi_y\n        elif case['type'] == 'uniform':\n            # Case D: Uniform flow, divergence-free\n            u_star_x = np.full((N, N), 1.0)\n            u_star_y = np.full((N, N), -0.5)\n\n        # Calculate discrete kinetic energy E_h[u_star]\n        E_star = 0.5 * np.sum(u_star_x**2 + u_star_y**2) * dx * dy\n        \n        if E_star == 0.0:\n            # This case will not be hit by the problem's test suite\n            results.append(0.0)\n            continue\n            \n        # Perform projection using Fourier spectral method\n        \n        # Wavenumbers (integer values)\n        k = np.fft.fftfreq(N) * N\n        kx, ky = np.meshgrid(k, k, indexing='ij')\n\n        # FFT of the velocity field\n        u_star_x_hat = np.fft.fft2(u_star_x)\n        u_star_y_hat = np.fft.fft2(u_star_y)\n        \n        # Divergence in Fourier space\n        div_u_star_hat = 1j * kx * u_star_x_hat + 1j * ky * u_star_y_hat\n        \n        # Solve Poisson equation for pressure p in Fourier space\n        # - (kx^2 + ky^2) * p_hat = div_u_star_hat\n        ksq = kx**2 + ky**2\n        \n        # Inverse of -(k^2) operator, with singularity at k=0 handled\n        # ksq_inv_neg will be -1/ksq for k != 0, and 0 for k = 0\n        ksq_inv_neg = np.zeros_like(ksq)\n        non_zero_k = ksq > 0\n        ksq_inv_neg[non_zero_k] = -1.0 / ksq[non_zero_k]\n        \n        p_hat = div_u_star_hat * ksq_inv_neg\n        \n        # The zero-mean pressure condition corresponds to p_hat[0,0] = 0,\n        # which is automatically satisfied by the above procedure since ksq_inv_neg[0,0] = 0.\n        \n        # Gradient of p in Fourier space\n        grad_p_x_hat = 1j * kx * p_hat\n        grad_p_y_hat = 1j * ky * p_hat\n        \n        # Transform gradient back to physical space.\n        # The result must be real; .real discards negligible imaginary parts from numerical error.\n        grad_p_x = np.fft.ifft2(grad_p_x_hat).real\n        grad_p_y = np.fft.ifft2(grad_p_y_hat).real\n        \n        # Compute the projected velocity field\n        u_proj_x = u_star_x - grad_p_x\n        u_proj_y = u_star_y - grad_p_y\n        \n        # Calculate discrete kinetic energy E_h[u_proj]\n        E_proj = 0.5 * np.sum(u_proj_x**2 + u_proj_y**2) * dx * dy\n        \n        # Calculate relative change in kinetic energy delta\n        delta = (E_proj - E_star) / E_star\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2430752"}, {"introduction": "在掌握了投影的基本特性之后，下一步是构建一个可用的求解器。本练习将指导你为一个简化的粘性流问题实现一个完整的分步投影法。你将学习构建其关键组成部分：一个针对物理项（如粘性）的显式更新步骤，以及一个在周期性网格上使用快速傅里叶变换（FFT）来强制不可压缩性的投影步骤。[@problem_id:2416659]", "problem": "实现一个自洽的数值实验，通过投影法对粘性流强制施加不可压缩性约束，并测量离散散度误差的演化。在二维空间的一个方形周期性域上，使用无量纲变量进行计算。物理模型是牛顿粘性流体的不可压缩Navier–Stokes方程，其无量纲形式表示为线动量守恒和质量守恒：速度场 $\\mathbf{u}(x,y,t)$ 满足 $\\partial_t \\mathbf{u} + (\\mathbf{u}\\cdot \\nabla)\\mathbf{u} = -\\nabla p + \\nu \\nabla^2 \\mathbf{u}$ 和 $\\nabla \\cdot \\mathbf{u} = 0$。对于本任务，您将舍去平流项，以分离粘性效应和不可压缩性约束的影响，得到 $\\partial_t \\mathbf{u} = -\\nabla p + \\nu \\nabla^2 \\mathbf{u}$ 且 $\\nabla \\cdot \\mathbf{u} = 0$。在空间上使用周期性方形域 $[0,1]\\times[0,1]$，时间上使用区间 $[0,T]$，其中时间 $t$ 是无量纲的。\n\n使用一个包含 $N \\times N$ 个点的均匀笛卡尔网格来离散空间域，其中 $\\Delta x = 1/N$，并且在两个方向上都采用周期性边界条件。使用步长为 $\\Delta t$ 的欧拉前向时间步进方法显式更新粘性项。在每个时间步，通过将粘性更新加到当前速度上来计算一个试探速度 $\\mathbf{u}^\\ast$，然后通过将 $\\mathbf{u}^\\ast$ 投影到一个离散无散场上（通过压力项实现），对更新后的速度 $\\mathbf{u}^{n+1}$ 强制施加不可压缩性条件。利用快速傅里叶变换（FFT）在傅里叶空间中求解周期性边界条件下的压力泊松方程，并应用投影，使得更新后的速度在连续意义上是无散度的。使用以下离散算子：\n\n- 对于离散散度算子，使用二阶中心差分。对于表示速度分量的网格函数 $u_{i,j}$ 和 $v_{i,j}$，在网格点 $(i,j)$ 处的离散散度定义为\n$$\n(\\nabla \\cdot \\mathbf{u})_{i,j} = \\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta x} + \\frac{v_{i,j+1} - v_{i,j-1}}{2\\Delta x}\n$$\n采用周期性索引。\n\n- 对每个速度分量使用标准的二阶中心有限差分拉普拉斯算子，\n$$\n(\\nabla^2 f)_{i,j} = \\frac{f_{i+1,j} - 2 f_{i,j} + f_{i-1,j}}{\\Delta x^2} + \\frac{f_{i,j+1} - 2 f_{i,j} + f_{i,j-1}}{\\Delta x^2}\n$$\n采用周期性索引。\n\n- 通过在周期性网格上的傅里叶空间中求解压力泊松方程来强制实现不可压缩性。通过使用快速傅里叶变换（FFT）将试探速度转换到傅里叶空间，应用正交投影以移除纵向（无旋）分量，然后逆变换回来，以此实现Helmholtz–Hodge投影。\n\n初始条件由一个无散场和一个梯度场相加构成。定义一个流函数 $\\psi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$，设置螺线管分量为 $\\mathbf{u}_{\\text{sol}} = \\left(\\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x}\\right)$，并从标量势 $\\phi_0(x,y) = \\beta \\cos(2\\pi x)\\cos(2\\pi y)$ 中增加一个梯度分量，使得完整的初始速度为 $\\mathbf{u}(x,y,0) = \\mathbf{u}_{\\text{sol}} + \\nabla \\phi_0$。这里 $\\beta$ 是一个无量纲振幅参数。所有变量都是无量纲的，因此输出中不要求物理单位。\n\n数值稳定性要求：由于粘性项是显式处理的，请确保当 $\\nu > 0$ 时，时间步长满足二维扩散方程的标准稳定性条件 $\\Delta t \\le \\Delta x^2/(4\\nu)$。如果给定的 $\\Delta t$ 超过此界限，则将其限制为最大的稳定值 $\\Delta t_{\\text{cap}} = \\Delta x^2/(4\\nu)$，并使用该限制后的 $\\Delta t$ 进行积分。\n\n误差度量：在每个时间步，应用投影后，使用上述中心差分算子计算离散散度，并测量其离散均方根（RMS）范数\n$$\n\\|\\nabla \\cdot \\mathbf{u}\\|_{2} = \\sqrt{\\frac{1}{N^2}\\sum_{i,j} \\left[(\\nabla \\cdot \\mathbf{u})_{i,j}\\right]^2}.\n$$\n在进行任何投影或时间步进之前，也计算初始范数 $\\|\\nabla \\cdot \\mathbf{u}(t=0)\\|_{2}$。跟踪每次投影后随时间变化的范数序列，并分析其演化。\n\n测试套件：针对以下三组参数集运行您的程序，所有情况均在域 $[0,1]\\times[0,1]$ 上，采用周期性边界条件和指定的初始条件。\n\n- 情况A（理想路径）：$N = 64$, $\\nu = 0.01$, $\\Delta t = 0.001$, $T = 0.1$, $\\beta = 0.2$。\n- 情况B（粗糙网格）：$N = 16$, $\\nu = 0.05$, $\\Delta t = 0.01$, $T = 0.1$, $\\beta = 0.3$。\n- 情况C（零粘度边界情况）：$N = 32$, $\\nu = 0$, $\\Delta t = 0.005$, $T = 0.1$, $\\beta = 0.5$。\n\n对于每种情况，输出一个包含四个条目的列表：\n$[\\|\\nabla \\cdot \\mathbf{u}(t=0)\\|_{2}, \\|\\nabla \\cdot \\mathbf{u}(t=T)\\|_{2}, \\max_{n}\\|\\nabla \\cdot \\mathbf{u}(t_n)\\|_{2}, \\text{mono}]$，其中前三个是四舍五入到八位小数的浮点数，而 $\\text{mono}$ 是一个整数指示符，如果投影后范数序列在 $n$ 上是单调不增的（允许在浮点容差范围内相等），则其值为 $1$，否则为 $0$。\n\n最终输出格式：您的程序应生成单行输出，其中包含三个案例的结果，形式为一个无空格、逗号分隔的列表的列表，例如\n$[[a_1,a_2,a_3,m_1],[b_1,b_2,b_3,m_2],[c_1,c_2,c_3,m_3]]$\n其中每个 $a_i$、$b_i$、$c_i$ 是一个四舍五入到八位小数的浮点数，每个 $m_i$ 是 $0$ 或 $1$。", "solution": "该问题已经过验证，被认定是有效的。它构成了一个适定的计算流体力学数值实验，所有必要的参数、方程和条件都已给出。其表述在科学上是合理的，基于Navier–Stokes方程的原理以及有限差分和用于投影的光谱技术等标准数值方法。\n\n问题陈述的一个显著特点是离散散度算子的定义：\n$$\n(\\nabla \\cdot \\mathbf{u})_{i,j} = \\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta x} + \\frac{v_{i,j+1} - v_{i,j-1}}{2\\Delta x}\n$$\n其中u和v分别是对应空间坐标x和y的速度分量，网格索引(j,i)对应于(x,y)。该表达式对应于$\\partial_y u + \\partial_x v$，而不是标准的散度定义$\\partial_x u + \\partial_y v$。从物理角度来看，这个选择是不寻常的。然而，由于问题陈述是一套形式化的指令，解题过程将严格遵守此定义，并将其视为待测量的量。投影步骤必须强制实现不可压缩性，根据“应用正交投影以移除纵向（无旋）分量”的指令，其目标被解释为真实的散度，即$\\nabla \\cdot \\mathbf{u} = \\partial_x u + \\partial_y v = 0$。投影所针对的量与测量的量之间的这种差异是该数值实验的核心特征。\n\n解题过程如下。\n\n**1. 控制方程与时间积分**\n\n物理模型是在周期性域$[0,1] \\times [0,1]$上的线性化不可压缩Navier–Stokes系统：\n$$\n\\partial_t \\mathbf{u} = -\\nabla p + \\nu \\nabla^2 \\mathbf{u} \\quad \\text{其中} \\quad \\nabla \\cdot \\mathbf{u} = 0\n$$\n我们采用分数步长（投影）法，并对粘性项使用欧拉前向格式。每个从$t_n$到$t_{n+1}=t_n+\\Delta t$的时间步分为两个阶段：\n\n*   **粘性步骤**：通过对粘性项进行显式积分，计算出一个中间的非螺线管速度场$\\mathbf{u}^\\ast$：\n    $$\n    \\mathbf{u}^\\ast = \\mathbf{u}^n + \\Delta t \\, \\nu \\nabla^2 \\mathbf{u}^n\n    $$\n*   **投影步骤**：将中间速度$\\mathbf{u}^\\ast$投影到无散场空间，以获得新时间层上的速度$\\mathbf{u}^{n+1}$。这通过Helmholtz–Hodge分解$\\mathbf{u}^\\ast = \\mathbf{u}^{n+1} + \\nabla \\Phi$完成，其中$\\nabla \\cdot \\mathbf{u}^{n+1} = 0$。这意味着存在一个类压力势$\\Phi$（通过$\\Phi = \\Delta t \\, p^{n+1}$与压力$p$相关），它满足泊松方程：\n    $$\n    \\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\ast\n    $$\n    校正后的速度则为$\\mathbf{u}^{n+1} = \\mathbf{u}^\\ast - \\nabla \\Phi$。\n\n**2. 空间离散化与傅里叶实现**\n\n空间域在间距为$\\Delta x = 1/N$的均匀$N \\times N$网格上离散化。\n\n*   **粘性项**：每个速度分量上的拉普拉斯算子$\\nabla^2$使用指定的标准二阶五点模板进行离散化：\n    $$\n    (\\nabla^2 f)_{i,j} = \\frac{f_{i,j+1} + f_{i,j-1} + f_{i+1,j} + f_{i-1,j} - 4 f_{i,j}}{\\Delta x^2}\n    $$\n*   **投影步骤**：在周期性域上求解泊松方程，最高效的方法是在傅里叶空间中进行。投影操作$\\mathbf{u}^{n+1} = \\mathcal{P}(\\mathbf{u}^\\ast)$直接应用于中间速度的傅里叶变换$\\hat{\\mathbf{u}}^\\ast(\\mathbf{k})$。傅里叶空间中的投影算子移除了$\\hat{\\mathbf{u}}^\\ast$中与波矢量$\\mathbf{k}=(k_x, k_y)$平行的分量，该分量对应于场的无旋（梯度）部分。\n    $$\n    \\hat{\\mathbf{u}}^{n+1}(\\mathbf{k}) = \\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{u}}^\\ast(\\mathbf{k})) = \\hat{\\mathbf{u}}^\\ast(\\mathbf{k}) - \\frac{\\hat{\\mathbf{u}}^\\ast(\\mathbf{k}) \\cdot \\mathbf{k}}{|\\mathbf{k}|^2} \\mathbf{k}\n    $$\n    此操作对所有波矢量$\\mathbf{k} \\neq \\mathbf{0}$执行。对应于$\\mathbf{k}=\\mathbf{0}$的平均流分量根据定义其散度为零，因此保持不变：$\\hat{\\mathbf{u}}^{n+1}(\\mathbf{0}) = \\hat{\\mathbf{u}}^\\ast(\\mathbf{0})$。波矢量由网格导出，即$k_x = 2\\pi m / L_x$ 和 $k_y = 2\\pi n / L_y$，其中$m,n$是整数模数，域大小为$L_x = L_y = 1$。离散速度场$\\mathbf{u}^{n+1}$通过快速傅里叶逆变换（IFFT）恢复。\n\n**3. 初始条件与误差度量**\n\n初始速度场$\\mathbf{u}(x,y,0)$由一个来自流函数$\\psi = \\sin(2\\pi x)\\sin(2\\pi y)$的螺线管（无散）分量和一个来自势函数$\\phi_0 = \\beta \\cos(2\\pi x)\\cos(2\\pi y)$的梯度分量相加构成：\n$$\n\\mathbf{u}(x,y,0) = \\left( \\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x} \\right) + \\left( \\frac{\\partial \\phi_0}{\\partial x}, \\frac{\\partial \\phi_0}{\\partial y} \\right)\n$$\n这得到解析形式：\n$$\nu(x,y,0) = (2\\pi \\sin(2\\pi x)\\cos(2\\pi y)) - (2\\pi\\beta \\sin(2\\pi x)\\cos(2\\pi y))\n$$\n$$\nv(x,y,0) = (-2\\pi \\cos(2\\pi x)\\sin(2\\pi y)) - (2\\pi\\beta \\cos(2\\pi x)\\sin(2\\pi y))\n$$\n误差由指定的“散度”算子的离散均方根（RMS）范数来量化：\n$$\n\\|\\nabla \\cdot \\mathbf{u}\\|_{2} = \\sqrt{\\frac{1}{N^2}\\sum_{i,j=0}^{N-1} \\left[(\\nabla \\cdot \\mathbf{u})_{i,j}\\right]^2}\n$$\n在整个模拟时间直到$t=T$的过程中，对初始场和每个投影步骤之后都计算此度量。\n\n**4. 算法摘要**\n\n1.  对于每个测试案例，定义参数$N, \\nu, \\Delta t, T, \\beta$。\n2.  检查显式扩散的Courant–Friedrichs–Lewy (CFL)稳定性条件$\\Delta t \\le \\Delta x^2/(4\\nu)$，并在必要时限制$\\Delta t$。\n3.  在$N \\times N$网格上构建初始速度场$u^0, v^0$。\n4.  计算并存储初始散度范数$\\|\\nabla \\cdot \\mathbf{u}(t=0)\\|_{2}$。\n5.  开始时间步进循环，对于$n=0, 1, \\dots, N_{\\text{steps}}-1$：\n    a. 计算显式粘性更新以得到$\\mathbf{u}^\\ast = (u^\\ast, v^\\ast)$。\n    b. 变换到傅里叶空间：$\\hat{u}^\\ast = \\text{FFT}(u^\\ast)$, $\\hat{v}^\\ast = \\text{FFT}(v^\\ast)$。\n    c. 在傅里叶空间中应用投影算子以得到$\\hat{u}^{n+1}, \\hat{v}^{n+1}$。\n    d. 逆变换回物理空间：$u^{n+1} = \\text{IFFT}(\\hat{u}^{n+1}), v^{n+1} = \\text{IFFT}(\\hat{v}^{n+1})$。\n    e. 计算并存储散度范数$\\|\\nabla \\cdot \\mathbf{u}^{n+1}\\|_{2}$。\n6.  从收集到的投影后范数序列中，确定$t=T$时的范数、序列中的最大范数，以及该序列是否单调不增。\n7.  按照指定格式化这四个结果值，用于最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft2, ifft2, fftfreq\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    def is_monotonic_nonincreasing(arr, tol=1e-9):\n        \"\"\"\n        Checks if a sequence is monotonically non-increasing within a tolerance.\n        Returns 1 if true, 0 otherwise.\n        \"\"\"\n        if len(arr) < 2:\n            return 1\n        # np.diff computes arr[i+1] - arr[i].\n        # We check if arr[i+1] <= arr[i], equivalent to arr[i+1] - arr[i] <= tol.\n        return 1 if np.all(np.diff(arr) <= tol) else 0\n\n    def run_case(N, nu, dt, T, beta):\n        \"\"\"\n        Runs a single numerical experiment case.\n        \"\"\"\n        # 1. Grid and Parameters\n        dx = 1.0 / N\n        x = np.linspace(0.0, 1.0, N, endpoint=False)\n        X, Y = np.meshgrid(x, x, indexing='xy') # X: cols(axis=1), Y: rows(axis=0)\n\n        # Stability condition for explicit diffusion\n        if nu > 0:\n            dt_cap = dx**2 / (4.0 * nu)\n            if dt > dt_cap:\n                dt = dt_cap\n        \n        # Ensure the simulation ends exactly at T\n        n_steps = math.ceil(T / dt) if dt > 0 else 0\n        if n_steps > 0:\n            dt = T / n_steps\n\n        # 2. Initial Condition\n        # u = u_sol + u_pot = 2*pi*sin(2*pi*x)*cos(2*pi*y) - 2*pi*beta*sin(2*pi*x)*cos(2*pi*y)\n        u_sol_x = 2.0 * np.pi * np.sin(2.0 * np.pi * X) * np.cos(2.0 * np.pi * Y)\n        u_pot_x = -2.0 * np.pi * beta * np.sin(2.0 * np.pi * X) * np.cos(2.0 * np.pi * Y)\n        u = u_sol_x + u_pot_x\n        # v = v_sol + v_pot = -2*pi*cos(2*pi*x)*sin(2*pi*y) - 2*pi*beta*cos(2*pi*x)*sin(2*pi*y)\n        v_sol_y = -2.0 * np.pi * np.cos(2.0 * np.pi * X) * np.sin(2.0 * np.pi * Y)\n        v_pot_y = -2.0 * np.pi * beta * np.cos(2.0 * np.pi * X) * np.sin(2.0 * np.pi * Y)\n        v = v_sol_y + v_pot_y\n\n        # 3. Discrete Operators\n        def laplacian(f):\n            # 5-point stencil for periodic boundaries\n            return (np.roll(f, 1, axis=0) + np.roll(f, -1, axis=0) +\n                    np.roll(f, 1, axis=1) + np.roll(f, -1, axis=1) - 4.0 * f) / dx**2\n\n        def specified_divergence(u_comp, v_comp):\n            # As per problem: (u_{i+1,j}-u_{i-1,j})/(2dx) + (v_{i,j+1}-v_{i,j-1})/(2dx)\n            # Assuming (i,j) -> (row, col) -> (y,x) in numpy indexing\n            # This is d(u)/dy + d(v)/dx\n            du_dy = (np.roll(u_comp, -1, axis=0) - np.roll(u_comp, 1, axis=0)) / (2.0 * dx)\n            dv_dx = (np.roll(v_comp, -1, axis=1) - np.roll(v_comp, 1, axis=1)) / (2.0 * dx)\n            return du_dy + dv_dx\n\n        # 4. Initial divergence norm\n        div_u0 = specified_divergence(u, v)\n        norm_div_initial = np.sqrt(np.mean(div_u0**2))\n        \n        # Wavenumbers for projection (domain size L=1)\n        k_vals = 2.0 * np.pi * fftfreq(N, d=1.0/N)\n        kx_grid, ky_grid = np.meshgrid(k_vals, k_vals, indexing='xy')\n        ksq = kx_grid**2 + ky_grid**2\n        inv_ksq = np.divide(1.0, ksq, out=np.zeros_like(ksq), where=(ksq != 0))\n\n        post_projection_norms = []\n\n        # 5. Time-stepping loop\n        for _ in range(n_steps):\n            # Viscous step\n            if nu > 0:\n                u_star = u + dt * nu * laplacian(u)\n                v_star = v + dt * nu * laplacian(v)\n            else:\n                u_star = u\n                v_star = v\n            \n            # Projection step in Fourier space\n            u_hat = fft2(u_star)\n            v_hat = fft2(v_star)\n            \n            # Project out the longitudinal component (using true divergence d_x u + d_y v)\n            longitudinal_comp = (u_hat * kx_grid + v_hat * ky_grid) * inv_ksq\n            \n            u_hat_new = u_hat - longitudinal_comp * kx_grid\n            v_hat_new = v_hat - longitudinal_comp * ky_grid\n            \n            u = np.real(ifft2(u_hat_new))\n            v = np.real(ifft2(v_hat_new))\n\n            # Measure discrete divergence error\n            div_un = specified_divergence(u, v)\n            norm_div_n = np.sqrt(np.mean(div_un**2))\n            post_projection_norms.append(norm_div_n)\n\n        # 6. Final metrics\n        norm_div_final = post_projection_norms[-1] if post_projection_norms else norm_div_initial\n        norm_div_max = max(post_projection_norms) if post_projection_norms else norm_div_initial\n        is_mono = is_monotonic_nonincreasing(post_projection_norms)\n\n        return [\n            round(norm_div_initial, 8),\n            round(norm_div_final, 8),\n            round(norm_div_max, 8),\n            is_mono\n        ]\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # Case A: N, nu, dt, T, beta\n        (64, 0.01, 0.001, 0.1, 0.2), \n        # Case B\n        (16, 0.05, 0.01, 0.1, 0.3),  \n        # Case C\n        (32, 0.0, 0.005, 0.1, 0.5),   \n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(*case)\n        results.append(result)\n\n    # Format final output as a comma-separated list of lists\n    result_str = \",\".join([str(r) for r in results])\n    result_str = result_str.replace(\" \", \"\") # Remove spaces\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2416659"}, {"introduction": "一个数值正确的算法如果不稳定，仍然可能失败。最后一个练习处理显式时间推进方案中的关键概念——数值稳定性，这是计算流体动力学中的一个常见挑战。你将实现一个完整的求解器，并根据著名的Courant-Friedrichs-Lewy（CFL）平流条件和显式扩散稳定性极限来测试其稳定性，从而学习如何选择合适的时间步长 $\\Delta t$ 以确保你的模拟是可靠的。[@problem_id:2430800]", "problem": "考虑在周期性方形域 $\\Omega = [0,1]\\times[0,1]$ 上的无量纲不可压缩纳维–斯托克斯方程，其速度场为 $\\mathbf{u}(x,y,t) = (u(x,y,t), v(x,y,t))$，压力为 $p(x,y,t)$：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + \\nabla \\cdot (\\mathbf{u}\\otimes \\mathbf{u}) + \\nabla p = \\nu \\nabla^2 \\mathbf{u}, \\qquad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n其中运动粘度 $\\nu \\ge 0$。初始条件由标量流函数 $\\psi(x,y) = A \\sin(2\\pi x)\\sin(2\\pi y)$ 指定，速度通过 $\\mathbf{u}(x,y,0) = \\left(\\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x}\\right)$ 获得。因此，\n$$\nu(x,y,0) = 2\\pi A \\sin(2\\pi x)\\cos(2\\pi y), \\qquad v(x,y,0) = -2\\pi A \\cos(2\\pi x)\\sin(2\\pi y).\n$$\n在一个均匀的笛卡尔网格上，$x$ 方向有 $N_x$ 个点，$y$ 方向有 $N_y$ 个点，网格间距为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。考虑一个一阶投影法，在单个时间增量 $\\Delta t$ 内通过两个子步骤推进速度：一个预测步，应用条件稳定的显式平流项和条件稳定的显式扩散项；一个校正步，通过求解周期域上的压力泊松方程并将中间速度投影到无散子空间来强制不可压缩性。所有量均为无量纲；无需物理单位。\n\n定义以下稳定性判据，以将计算运行分类为稳定或不稳定：\n\n- 将时间层 $n$ 的多维库朗数定义为\n$$\nC_{i,j}^{(n)} \\;=\\; \\left|\\frac{u_{i,j}^{(n)}\\,\\Delta t}{\\Delta x}\\right| \\;+\\; \\left|\\frac{v_{i,j}^{(n)}\\,\\Delta t}{\\Delta y}\\right|,\n$$\n并令 $C_{\\max}^{(n)} = \\max_{i,j} C_{i,j}^{(n)}$。当且仅当 $C_{\\max}^{(n)} \\le 1$ 时，时间层 $n$ 的平流子步骤被认为是稳定的。\n\n- 当且仅当 $\\nu = 0$ 或者当 $\\nu > 0$ 时不等式\n$$\n\\Delta t \\;\\le\\; \\frac{\\min(\\Delta x, \\Delta y)^2}{4\\,\\nu}\n$$\n成立，显式扩散子步骤被认为是稳定的。\n\n一个完整的、包含 $N_{\\text{steps}} = \\left\\lceil T_{\\text{end}}/\\Delta t \\right\\rceil$ 个时间步的运行被分类为稳定，当且仅当对于所有时间层 $n \\in \\{0,1,\\dots,N_{\\text{steps}}-1\\}$，平流判据满足 $C_{\\max}^{(n)} \\le 1$ 且扩散判据成立（其中当 $\\nu = 0$ 时扩散判据自然成立），并且数值解保持有限（不产生非数值（Not-a-Number））。否则，该运行被分类为不稳定。\n\n测试套件。对于下面的每个参数元组 $(N_x,N_y,\\nu,\\Delta t,T_{\\text{end}},A)$，运行时间积分并报告一个布尔值，以指示其根据上述判据的稳定性。\n\n- 情况 $1$：$(N_x,N_y,\\nu,\\Delta t,T_{\\text{end}},A) = (64,64,0.01,0.0004,0.05,1.0)$。\n- 情况 $2$：$(N_x,N_y,\\nu,\\Delta t,T_{\\text{end}},A) = (64,64,0.00001,0.01,0.05,1.0)$。\n- 情况 $3$：$(N_x,N_y,\\nu,\\Delta t,T_{\\text{end}},A) = (64,64,0.1,0.001,0.02,0.5)$。\n- 情况 $4$：$(N_x,N_y,\\nu,\\Delta t,T_{\\text{end}},A) = (64,64,0.01,0.0024,0.05,1.0)$。\n- 情况 $5$：$(N_x,N_y,\\nu,\\Delta t,T_{\\text{end}},A) = (64,64,0.0,0.001,0.05,1.5)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,\\dots]$），其中每个 $result_k$ 是一个布尔值，对应于上面所列顺序的第 $k$ 个情况。本问题不涉及角度。由于所有量都是无量纲的，因此不需要物理单位。", "solution": "该问题具有科学依据，是适定的、客观的。它为使用标准数值方法在周期域上模拟不可压缩纳维–斯托克斯方程提供了完整的规范。所有参数、初始条件和稳定性判据都得到了明确定义。因此，该问题是有效的，并将提供一个解。\n\n在周期域 $\\Omega = [0,1]\\times[0,1]$ 上，无量纲不可压缩纳维–斯托克斯方程\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + \\nabla \\cdot (\\mathbf{u}\\otimes \\mathbf{u}) + \\nabla p = \\nu \\nabla^2 \\mathbf{u}, \\qquad \\nabla \\cdot \\mathbf{u} = 0\n$$\n的数值解是通过一阶分步法实现的，该方法通常称为投影法。此方法将速度和压力的更新解耦。时间积分通过一阶精度且显式的前向欧拉格式进行。对于周期网格上的空间离散化，采用伪谱法，利用快速傅里叶变换（FFT）来高效、高精度地计算空间导数。\n\n投影法的核心思想是将从时间 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的更新分为两个子步骤：\n\n1.  **预测步**：通过在时间上推进解来计算一个中间速度场 $\\mathbf{u}^*$，此步骤只考虑显式平流项和扩散项，忽略了压力梯度。\n    $$\n    \\frac{\\mathbf{u}^* - \\mathbf{u}^n}{\\Delta t} = - \\nabla \\cdot (\\mathbf{u}^n \\otimes \\mathbf{u}^n) + \\nu \\nabla^2 \\mathbf{u}^n\n    $$\n    此处，$\\mathbf{u}^n$ 是时间 $t^n$ 时的速度。所得的速度场 $\\mathbf{u}^*$ 通常不满足不可压缩性约束，即 $\\nabla \\cdot \\mathbf{u}^* \\neq 0$。\n\n2.  **投影步**：将中间速度 $\\mathbf{u}^*$ 投影到无散向量场空间上，以获得下一个时间层的速度 $\\mathbf{u}^{n+1}$。根据 Hodge-Helmholtz 分解，任何向量场 $\\mathbf{u}^*$ 都可以分解为一个无散部分（$\\mathbf{u}^{n+1}$）和一个无旋部分（一个标量势 $\\nabla \\phi$ 的梯度）。对于纳维–斯托克斯方程，这个标量势与压力相关，从而得到关系式：\n    $$\n    \\mathbf{u}^{n+1} = \\mathbf{u}^* - \\Delta t \\nabla p^{n+1}\n    $$\n    为了求得压力 $p^{n+1}$，我们对上述方程取散度，以在 $\\mathbf{u}^{n+1}$ 上强制施加不可压缩性约束：\n    $$\n    \\nabla \\cdot \\mathbf{u}^{n+1} = \\nabla \\cdot \\mathbf{u}^* - \\Delta t \\nabla \\cdot (\\nabla p^{n+1})\n    $$\n    由于我们要求 $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$，这就产生了一个关于压力的泊松方程：\n    $$\n    \\nabla^2 p^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^*\n    $$\n\n整个算法在傅里叶空间中实现，以利用FFT的特性。网格上的函数 $f(x,y)$ 被变换为其傅里叶表示 $\\hat{f}(k_x, k_y)$。在傅里叶空间中，微分算子变成了代数运算：\n$$\n\\mathcal{F}\\left(\\frac{\\partial f}{\\partial x}\\right) = i k_x \\hat{f}, \\quad \\mathcal{F}\\left(\\frac{\\partial f}{\\partial y}\\right) = i k_y \\hat{f}, \\quad \\mathcal{F}\\left(\\nabla^2 f\\right) = -(k_x^2 + k_y^2)\\hat{f} = -|K|^2 \\hat{f}\n$$\n其中 $k_x$ 和 $k_y$ 是对应于空间网格的波数。对于长度为 $L=1$ 且有 $N$ 个点的域，波数为 $k = 2\\pi m$，其中整数频率 $m \\in [-N/2, N/2-1]$。\n\n为提高效率，时间步进算法几乎完全在傅里叶空间中执行，具体如下：\n设 $\\mathbf{u}^n = (u^n, v^n)$ 为时间 $t^n$ 时的速度场。\n\n1.  **稳定性检查**：在计算更新之前，在物理空间中检查稳定性判据。\n    -   计算库朗数 $C_{i,j}^{(n)} = \\Delta t (|u_{i,j}^{(n)}|/\\Delta x + |v_{i,j}^{(n)}|/\\Delta y)$ 及其最大值 $C_{\\max}^{(n)}$。如果 $C_{\\max}^{(n)} > 1$，则宣布运行不稳定。\n    -   如果 $\\nu > 0$，检查扩散稳定性判据：$\\Delta t \\le \\min(\\Delta x, \\Delta y)^2 / (4\\nu)$。如果违反此条件，则宣布运行不稳定。\n    -   检查速度场是否包含任何非有限值（`NaN` 或 `inf`）。如果是，则运行不稳定。\n\n2.  **傅里叶空间中的预测步**：\n    -   在物理空间中计算非线性项 $u^2$、$v^2$ 和 $uv$。\n    -   将速度分量和非线性项变换到傅里叶空间：$\\hat{u}^n, \\hat{v}^n, \\widehat{u^2}, \\widehat{v^2}, \\widehat{uv}$。\n    -   计算动量方程右侧项（RHS）的傅里叶变换，其中包括平流（保守形式）和扩散：\n        $$\n        \\widehat{\\text{RHS}}_u = - \\left( i k_x \\widehat{u^2} + i k_y \\widehat{uv} \\right) - \\nu |K|^2 \\hat{u}^n\n        $$\n        $$\n        \\widehat{\\text{RHS}}_v = - \\left( i k_x \\widehat{uv} + i k_y \\widehat{v^2} \\right) - \\nu |K|^2 \\hat{v}^n\n        $$\n    -   计算中间速度 $\\mathbf{u}^*$ 的傅里叶变换：\n        $$\n        \\hat{u}^* = \\hat{u}^n + \\Delta t \\cdot \\widehat{\\text{RHS}}_u\n        $$\n        $$\n        \\hat{v}^* = \\hat{v}^n + \\Delta t \\cdot \\widehat{\\text{RHS}}_v\n        $$\n\n3.  **傅里叶空间中的投影步**：\n    -   求解压力泊松方程。首先，计算 $\\mathbf{u}^*$ 散度的傅里叶变换：\n        $$\n        \\mathcal{F}(\\nabla \\cdot \\mathbf{u}^*) = i k_x \\hat{u}^* + i k_y \\hat{v}^*\n        $$\n    -   泊松方程 $\\nabla^2 p^{n+1} = (\\nabla \\cdot \\mathbf{u}^*) / \\Delta t$ 在傅里叶空间中变为 $-|K|^2 \\hat{p}^{n+1} = \\mathcal{F}(\\nabla \\cdot \\mathbf{u}^*) / \\Delta t$。我们求解 $\\hat{p}^{n+1}$：\n        $$\n        \\hat{p}^{n+1} = -\\frac{1}{\\Delta t} \\frac{i k_x \\hat{u}^* + i k_y \\hat{v}^*}{|K|^2}\n        $$\n        对于零波数模式（$k_x = k_y = 0$），其中 $|K|^2 = 0$，分子也为零，这反映了周期性泊松问题的可解性条件。我们设置 $\\hat{p}^{n+1}(0,0) = 0$，这对应于将平均压力设置为零。\n\n4.  **傅里叶空间中的校正步**：\n    -   通过减去压力梯度来更新速度场，所有操作均在傅里叶空间中进行：\n        $$\n        \\hat{u}^{n+1} = \\hat{u}^* - \\Delta t (i k_x \\hat{p}^{n+1})\n        $$\n        $$\n        \\hat{v}^{n+1} = \\hat{v}^* - \\Delta t (i k_y \\hat{p}^{n+1})\n        $$\n\n5.  **完成步骤**：使用逆FFT将新的速度分量 $\\hat{u}^{n+1}$ 和 $\\hat{v}^{n+1}$ 转换回物理空间以获得 $\\mathbf{u}^{n+1}$，然后进入下一个时间步。如果运行完成所有时间步且未违反任何稳定性判据，则将其分类为稳定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(Nx, Ny, nu, dt, T_end, A):\n    \"\"\"\n    Runs a single simulation of the 2D incompressible Navier-Stokes equations\n    and returns a boolean indicating if the run was stable.\n    \"\"\"\n    # Grid and domain setup\n    dx = 1.0 / Nx\n    dy = 1.0 / Ny\n    x = np.linspace(0, 1.0 - dx, Nx, dtype=np.float64)\n    y = np.linspace(0, 1.0 - dy, Ny, dtype=np.float64)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    # Wavenumber setup for FFT-based derivatives\n    kx = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n    ky = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n    Kx, Ky = np.meshgrid(kx, ky, indexing='xy')\n    K2 = Kx**2 + Ky**2\n    # Inverse Laplacian operator in Fourier space, with safe division\n    K2_inv = np.divide(1.0, K2, out=np.zeros_like(K2), where=K2 != 0)\n\n    # Initial conditions\n    u = (2 * np.pi * A * np.sin(2 * np.pi * X) * np.cos(2 * np.pi * Y)).astype(np.float64)\n    v = (-2 * np.pi * A * np.cos(2 * np.pi * X) * np.sin(2 * np.pi * Y)).astype(np.float64)\n\n    # Time-stepping\n    num_steps = int(np.ceil(T_end / dt))\n    \n    # Diffusion stability criterion\n    diffusion_stable = True\n    if nu > 0:\n        min_dx_sq = min(dx, dy)**2\n        if dt > min_dx_sq / (4.0 * nu):\n            diffusion_stable = False\n    \n    if not diffusion_stable:\n        return False\n\n    for n in range(num_steps):\n        # --- Stability Check ---\n        # 1. Advection (CFL) condition\n        cfl = np.abs(u) * dt / dx + np.abs(v) * dt / dy\n        if np.max(cfl) > 1.0:\n            return False\n            \n        # 2. Check for finiteness of the solution\n        if not (np.isfinite(u).all() and np.isfinite(v).all()):\n            return False\n\n        # --- Predictor Step (in Fourier Space) ---\n        u_hat = np.fft.fft2(u)\n        v_hat = np.fft.fft2(v)\n\n        # Advection terms (conservative form)\n        uu_hat = np.fft.fft2(u * u)\n        uv_hat = np.fft.fft2(u * v)\n        vv_hat = np.fft.fft2(v * v)\n\n        adv_u_hat = -(1j * Kx * uu_hat + 1j * Ky * uv_hat)\n        adv_v_hat = -(1j * Kx * uv_hat + 1j * Ky * vv_hat)\n\n        # Diffusion terms\n        diff_u_hat = -nu * K2 * u_hat\n        diff_v_hat = -nu * K2 * v_hat\n\n        # Combine RHS and predict intermediate velocity u_star\n        u_star_hat = u_hat + dt * (adv_u_hat + diff_u_hat)\n        v_star_hat = v_hat + dt * (adv_v_hat + diff_v_hat)\n\n        # --- Projection Step (in Fourier Space) ---\n        # Solve Poisson equation for pressure\n        div_u_star_hat = 1j * Kx * u_star_hat + 1j * Ky * v_star_hat\n        p_hat = -div_u_star_hat * K2_inv / dt\n\n        # Correct velocity to enforce incompressibility\n        u_new_hat = u_star_hat - dt * (1j * Kx * p_hat)\n        v_new_hat = v_star_hat - dt * (1j * Ky * p_hat)\n\n        # Transform back to physical space for the next iteration\n        u = np.real(np.fft.ifft2(u_new_hat))\n        v = np.real(np.fft.ifft2(v_new_hat))\n\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, nu, dt, T_end, A)\n        (64, 64, 0.01, 0.0004, 0.05, 1.0),     # Case 1\n        (64, 64, 0.00001, 0.01, 0.05, 1.0),    # Case 2\n        (64, 64, 0.1, 0.001, 0.02, 0.5),      # Case 3\n        (64, 64, 0.01, 0.0024, 0.05, 1.0),    # Case 4\n        (64, 64, 0.0, 0.001, 0.05, 1.5),      # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        is_stable = run_simulation(*case)\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results)).replace('True', 'True').replace('False', 'False')}]\")\n\nsolve()\n```", "id": "2430800"}]}