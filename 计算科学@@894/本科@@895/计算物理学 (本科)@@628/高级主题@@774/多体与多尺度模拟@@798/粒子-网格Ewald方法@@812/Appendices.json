{"hands_on_practices": [{"introduction": "粒子-网格(Particle-Mesh)方法的核心是将离散的粒子属性映射到连续的网格场上。这个练习将实践这一基本技能，不仅应用于静电荷，还扩展到计算局部质量密度和应力张量场等更普适的物理量。通过这个练习，你将深入理解粒子-网格转换的普适性，并掌握从微观粒子数据计算宏观场量的关键技术[@problem_id:2424437]。", "problem": "您的任务是，本着 Particle-Mesh Ewald (PME) 方法的精神，推导并实现一种粒子到网格的算法，用于在周期性立方体域中根据粒子数据计算局域场。其目标是通过使用 Particle-Mesh Ewald (PME) 中常用的紧支撑分配函数，将粒子和对偶量分配到均匀网格上，从而计算该网格上的质量密度场和构型应力张量场。该方法必须从微观场的基本定义出发，然后使用一阶B样条分配（也称为 cloud-in-cell）离散化到网格上。所有量均采用约化的无量纲单位。\n\n基本原理：\n- 微观质量密度由分布 $ \\rho(\\mathbf{r}) = \\sum_{i=1}^{N} m_i \\, \\delta(\\mathbf{r} - \\mathbf{r}_i) $ 定义，其中 $ m_i $ 和 $ \\mathbf{r}_i $ 分别是粒子 $ i $ 的质量和位置，$ \\delta(\\cdot) $ 是狄拉克δ函数。\n- 静态构型（速度为零）的 Irving–Kirkwood (IK) 构型应力张量场定义为 $ \\boldsymbol{\\sigma}(\\mathbf{r}) = - \\dfrac{1}{2} \\sum_{i \\neq j} \\int_{0}^{1} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} \\, \\delta\\!\\left(\\mathbf{r} - \\mathbf{r}_i + s \\, \\mathbf{r}_{ij}\\right) \\, ds $，其中 $ \\mathbf{r}_{ij} $ 是从粒子 $ i $ 到 $ j $ 的最小镜像分离矢量，$ \\mathbf{F}_{ij} $ 是 $ j $ 对 $ i $ 的作用力，$ \\otimes $ 表示外积。\n\n任务1（推导）：从上述定义出发，将狄拉克δ函数 $ \\delta(\\cdot) $ 替换为 Particle-Mesh Ewald (PME) 中使用的一阶基数B样条（cloud-in-cell）的可分离紧支撑分配函数 $ W(\\mathbf{r}) = w(x) \\, w(y) \\, w(z) $。请明确推导以下离散网格公式：\n- 在边长为 $ L $、具有 $ N \\times N \\times N $ 个节点且间距为 $ h = L/N $ 的周期性立方体均匀网格上，由整数 $ (i,j,k) $ 索引的网格节点处的网格质量密度值 $ \\rho_{i,j,k} $。您的离散公式必须满足精确的质量守恒，即 $ \\sum_{i,j,k} \\rho_{i,j,k} \\, h^3 = \\sum_{\\ell=1}^{N_p} m_\\ell $，其中 $ N_p $ 是粒子数。\n- 使用 Irving–Kirkwood 线积分的中点近似法，计算网格构型应力张量值 $ \\boldsymbol{\\sigma}_{i,j,k} $，即将每对粒子的贡献分配到连接两个粒子的最小镜像线段的中点。证明当使用相同的分配函数 $ W $ 进行分配时，体积积分 $ \\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} \\, h^3 $ 等于全局维里张量 $ \\mathbf{W} = - \\dfrac{1}{2} \\sum_{i \\neq j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} $。\n\n任务2（算法设计）：使用您推导的离散公式，\n- 在边长为 $ L $ 的立方体上实现周期性边界条件，其最小镜像分离矢量为 $ \\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i - L \\, \\mathrm{round}\\!\\left((\\mathbf{r}_j - \\mathbf{r}_i)/L\\right) $，并逐分量应用。\n- 使用在截断半径 $ r_c $ 处截断的 Lennard-Jones 对力，其势能为 $ U(r) = 4 \\, \\varepsilon \\left[ \\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6 \\right] $，力为 $ \\mathbf{F}(r) = - \\dfrac{dU}{dr} \\, \\hat{\\mathbf{r}} $，并仅对 $ r < r_c $ 的粒子对计算力。不要应用尾部校正或移位；使用直接截断法。假设速度为零，因此应力的动能部分恒为零。\n\n任务3（实现与输出）：编写一个完整、可运行的程序，该程序：\n- 构建网格，并使用一阶B样条分配（cloud-in-cell）来分配质量密度和构型应力张量。\n- 对下面的每个测试用例，计算三个标量诊断量：\n  1) 网格上的总质量，$ M_{\\mathrm{grid}} = \\sum_{i,j,k} \\rho_{i,j,k} \\, h^3 $。\n  2) 最大网格密度值 $ \\max_{i,j,k} \\rho_{i,j,k} $。\n  3) 体积积分后的网格应力与解析全局维里张量之差的弗罗贝尼乌斯范数，$ \\left\\| \\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} \\, h^3 - \\mathbf{W} \\right\\|_F $。\n\n所有量都是无量纲的。不使用角度。不使用百分比。\n\n测试套件：\n- 用例A（通用多粒子）：$ L = 1.0 $, $ N = 8 $, $ \\varepsilon = 1.0 $, $ \\sigma = 0.2 $, $ r_c = 0.5 $。粒子：质量 $ [1.0, 2.0, 1.5] $，位置 $ \\{ [0.2, 0.3, 0.4], [0.8, 0.1, 0.9], [0.5, 0.5, 0.5] \\} $。\n- 用例B（边界环绕单粒子）：$ L, N, \\varepsilon, \\sigma, r_c $ 同上。粒子：质量 $ [1.0] $，位置 $ \\{ [0.99, 0.01, 0.49] \\} $。\n- 用例C（最小镜像近邻对）：$ L, N, \\varepsilon, \\sigma, r_c $ 同上。粒子：质量 $ [1.0, 1.0] $，位置 $ \\{ [0.95, 0.5, 0.5], [0.05, 0.5, 0.5] \\} $。\n- 用例D（空系统）：$ L, N, \\varepsilon, \\sigma, r_c $ 同上。粒子：质量 $ [\\,] $，位置 $ \\{ \\, \\} $。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，结果按以下顺序排列：\n  $ [ M_{\\mathrm{grid}}^{(A)}, \\max \\rho^{(A)}, \\Delta \\sigma^{(A)}, M_{\\mathrm{grid}}^{(B)}, \\max \\rho^{(B)}, \\Delta \\sigma^{(B)}, M_{\\mathrm{grid}}^{(C)}, \\max \\rho^{(C)}, \\Delta \\sigma^{(C)}, M_{\\mathrm{grid}}^{(D)}, \\max \\rho^{(D)}, \\Delta \\sigma^{(D)} ] $，\n  其中 $ \\Delta \\sigma $ 表示上文定义的应力差异的弗罗贝尼乌斯范数。例如，格式必须类似于 $ [r_1,r_2,\\dots,r_{12}] $，包含 $ 12 $ 个浮点数。", "solution": "所提出的问题是计算物理学中一个明确定义的任务，要求推导和实现一种用于计算质量密度和构型应力场的粒子到网格算法。它在科学上基于统计力学原理和标准数值方法（粒子-网格法）。该问题是自洽的，提供了所有必要的定义、参数和测试数据。因此，该问题被认为是有效的，并有必要提供完整的解决方案。\n\n推导和实现将按要求分两个阶段进行：首先，从所提供的连续定义中推导出离散公式；其次，开发一种数值算法来计算所需的诊断量。\n\n### 任务1：离散网格公式的推导\n\n给定一个边长为 $L$ 的周期性立方体域，其上有一个 $N \\times N \\times N$ 的均匀网格，网格间距为 $h = L/N$。\n\n#### 1.1. 质量密度场\n\n微观质量密度定义为：\n$$\n\\rho(\\mathbf{r}) = \\sum_{p=1}^{N_p} m_p \\, \\delta(\\mathbf{r} - \\mathbf{r}_p)\n$$\n其中 $m_p$ 和 $\\mathbf{r}_p$ 分别是粒子 $p$ 的质量和位置，$\\delta(\\cdot)$ 是狄拉克δ函数。\n\n为了离散化这个表达式，我们用一个连续的、紧支撑的分配函数 $W(\\mathbf{r})$ 来代替狄拉克δ函数。由此产生的平滑密度场 $\\rho_{\\text{smooth}}(\\mathbf{r})$ 为：\n$$\n\\rho_{\\text{smooth}}(\\mathbf{r}) = \\sum_{p=1}^{N_p} m_p \\, W(\\mathbf{r} - \\mathbf{r}_p)\n$$\n问题指定了使用一阶基数B样条（Cloud-in-Cell 或 CIC）分配函数。该函数是可分离的，$W(\\mathbf{r}) = w(x)w(y)w(z)$。对于网格间距 $h$，一维核函数是一个三角（或“帽状”）函数：\n$$\nw(u) = \\frac{1}{h} \\max\\left(0, 1 - \\frac{|u|}{h}\\right)\n$$\n因子 $1/h$ 确保 $\\int_{-\\infty}^{\\infty} w(u) \\, du = 1$，从而使得 $\\int_{\\mathbb{R}^3} W(\\mathbf{r}) \\, d^3\\mathbf{r} = 1$。\n\n在保证质量守恒的粒子-网格方法中，标准做法不是通过采样 $\\rho_{\\text{smooth}}(\\mathbf{r})$ 来定义基于网格的密度 $\\rho_{i,j,k}$，而是通过将质量分配到网格上来实现。设 $M_{i,j,k}$ 是分配给网格节点 $\\mathbf{r}_{i,j,k} = (ih, jh, kh)$ 的总质量。该节点的密度定义为：\n$$\n\\rho_{i,j,k} = \\frac{M_{i,j,k}}{h^3}\n$$\n质量 $M_{i,j,k}$ 是通过将每个粒子 $m_p$ 的质量根据从B样条导出的无量纲权重函数分配到其相邻的网格节点上计算的。设一个粒子位于位置 $\\mathbf{r}_p$。其缩放坐标为 $\\mathbf{s}_p = \\mathbf{r}_p/h$。设 $\\mathbf{n}_p = (\\lfloor s_p^x \\rfloor, \\lfloor s_p^y \\rfloor, \\lfloor s_p^z \\rfloor)$ 为粒子在负方向上最近的网格节点的整数索引（“基准”节点）。粒子在此基准单元内的分数坐标为 $\\mathbf{u}_p = \\mathbf{s}_p - \\mathbf{n}_p$。\n\nCIC方案将粒子质量 $m_p$ 分配给包含该粒子的单元的 $2^3=8$ 个网格节点。对于距离 $\\mathbf{n}_p$ 有偏移 $(\\delta_x, \\delta_y, \\delta_z)$ （其中 $\\delta_x, \\delta_y, \\delta_z \\in \\{0, 1\\}$）的节点，其权重为：\n$$\nS(\\mathbf{u}_p, \\boldsymbol{\\delta}) = \\big( (1-u_p^x)^{1-\\delta_x}(u_p^x)^{\\delta_x} \\big) \\big( (1-u_p^y)^{1-\\delta_y}(u_p^y)^{\\delta_y} \\big) \\big( (1-u_p^z)^{1-\\delta_z}(u_p^z)^{\\delta_z} \\big)\n$$\n从粒子 $p$ 分配到网格节点 $\\mathbf{k} = \\mathbf{n}_p + \\boldsymbol{\\delta}$ 的质量为 $m_p S(\\mathbf{u}_p, \\boldsymbol{\\delta})$。节点 $\\mathbf{k}$ 上的总质量是所有粒子的贡献之和：\n$$\nM_{\\mathbf{k}} = \\sum_{p=1}^{N_p} m_p S(\\mathbf{u}_p, \\boldsymbol{\\delta}_{\\mathbf{k},p})\n$$\n其中 $\\boldsymbol{\\delta}_{\\mathbf{k},p}$ 是节点 $\\mathbf{k}$ 相对于粒子 $p$ 的基准节点的相对索引。\n\n**质量守恒证明：** 我们必须证明 $\\sum_{i,j,k} \\rho_{i,j,k} \\, h^3 = \\sum_{p=1}^{N_p} m_p$。\n代入 $\\rho_{i,j,k}$ 的定义：\n$$\n\\sum_{i,j,k} \\rho_{i,j,k} h^3 = \\sum_{i,j,k} \\left( \\frac{M_{i,j,k}}{h^3} \\right) h^3 = \\sum_{i,j,k} M_{i,j,k}\n$$\n这是分配到所有网格节点的总质量。通过交换求和顺序：\n$$\n\\sum_{i,j,k} M_{i,j,k} = \\sum_{i,j,k} \\sum_{p=1}^{N_p} (\\text{从 } p \\text{ 到 } i,j,k \\text{ 的质量}) = \\sum_{p=1}^{N_p} m_p \\left( \\sum_{i,j,k} p \\text{ 的权重} \\right)\n$$\n对于任何粒子 $p$，其分配权重在所有网格节点上的总和为 $\\sum_{\\delta_x,\\delta_y,\\delta_z \\in \\{0,1\\}} S(\\mathbf{u}_p, \\boldsymbol{\\delta}) = 1$。这是因为 $\\sum_{\\delta_x=0}^1 (1-u_p^x)^{1-\\delta_x}(u_p^x)^{\\delta_x} = (1-u_p^x)+u_p^x = 1$，并且这对每个维度都成立。因此，权重之和为 $1 \\times 1 \\times 1 = 1$。\n由此，我们证明了守恒定律：\n$$\n\\sum_{i,j,k} \\rho_{i,j,k} h^3 = \\sum_{p=1}^{N_p} m_p (1) = \\sum_{p=1}^{N_p} m_p\n$$\n\n#### 1.2. 构型应力张量场\n\n静态构型的 Irving-Kirkwood 构型应力张量为：\n$$\n\\boldsymbol{\\sigma}(\\mathbf{r}) = - \\frac{1}{2} \\sum_{i \\neq j} \\int_{0}^{1} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} \\, \\delta(\\mathbf{r} - \\mathbf{r}_i - s \\mathbf{r}_{ij}) \\, ds\n$$\n其中 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ 是最小镜像分离矢量，$\\mathbf{F}_{ij}$ 是粒子 $j$ 对粒子 $i$ 的作用力。符号 $\\otimes$ 表示外积。\n\n我们用分配函数 $W(\\cdot)$ 替换 $\\delta(\\cdot)$，并对积分使用中点近似法。积分 $\\int_0^1 f(s) ds$ 近似为 $f(1/2)$。这使得 $s=1/2$。对 $(i,j)$ 这对粒子进行分配的位置变为 $\\mathbf{r}_i + \\frac{1}{2}\\mathbf{r}_{ij} = \\frac{\\mathbf{r}_i+\\mathbf{r}_j}{2}$，即连接粒子的线段的中点。\n平滑应力场近似为：\n$$\n\\boldsymbol{\\sigma}_{\\text{smooth}}(\\mathbf{r}) \\approx - \\frac{1}{2} \\sum_{i \\neq j} (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) W(\\mathbf{r} - (\\mathbf{r}_i+\\mathbf{r}_j)/2)\n$$\n对 $i \\neq j$ 的求和将每个粒子对的相互作用计算了两次。考虑粒子 $i$ 和 $j$ 之间相互作用的贡献。其项为 $(i,j)$ 和 $(j,i)$。为这个单一相互作用分配的量是：\n$$\n\\mathbf{T}_{ij} = -\\frac{1}{2} (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) - \\frac{1}{2} (\\mathbf{r}_{ji} \\otimes \\mathbf{F}_{ji})\n$$\n根据牛顿第三定律 $\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$ 和矢量恒等式 $\\mathbf{r}_{ji} = -\\mathbf{r}_{ij}$，第二项变为 $-\\frac{1}{2} ((-\\mathbf{r}_{ij}) \\otimes (-\\mathbf{F}_{ij})) = -\\frac{1}{2} (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij})$。因此：\n$$\n\\mathbf{T}_{ij} = -(\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) = \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ji}\n$$\n这个张量量代表了粒子对相互作用的全部贡献，被分配到单一位置 $\\mathbf{r}_{mid} = (\\mathbf{r}_i+\\mathbf{r}_j)/2$。\n\n与质量密度类似，我们将网格应力张量 $\\boldsymbol{\\sigma}_{i,j,k}$ 定义为在节点 $(i,j,k)$ 处分配的总应力二元并积（我们表示为 $\\boldsymbol{\\Sigma}_{i,j,k}$）除以单元体积 $h^3$：\n$$\n\\boldsymbol{\\sigma}_{i,j,k} = \\frac{\\boldsymbol{\\Sigma}_{i,j,k}}{h^3}\n$$\n这里，$\\boldsymbol{\\Sigma}_{i,j,k}$ 是通过对所有唯一的粒子对 $(i<j)$ 的贡献求和来计算的。对于每一对，量 $\\mathbf{T}_{ij} = \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ji}$ 使用与质量相同的CIC权重方案，分配到其中心点 $\\mathbf{r}_{mid}$ 周围的8个网格单元上。\n\n**维里等价性证明：** 我们必须证明 $\\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} h^3$ 等于全局维里张量 $\\mathbf{W} = - \\frac{1}{2} \\sum_{i \\neq j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}$。\n体积积分后的网格应力为：\n$$\n\\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} h^3 = \\sum_{i,j,k} \\left( \\frac{\\boldsymbol{\\Sigma}_{i,j,k}}{h^3} \\right) h^3 = \\sum_{i,j,k} \\boldsymbol{\\Sigma}_{i,j,k}\n$$\n这是在整个网格上所有分配的二元并积的总和。通过将求和顺序从节点改为粒子对：\n$$\n\\sum_{i,j,k} \\boldsymbol{\\Sigma}_{i,j,k} = \\sum_{p<q} \\left( \\sum_{i,j,k} \\text{从粒子对 } (p,q) \\text{ 到 } i,j,k \\text{ 的二元并积} \\right)\n$$\n对于单个粒子对 $(p,q)$，括号中的项是 $\\mathbf{T}_{pq}$ 乘以其在所有网格节点上的分配权重之和。如同对质量的证明一样，这个和恰好是 $1$。\n$$\n\\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} h^3 = \\sum_{p<q} \\mathbf{T}_{pq} (1) = \\sum_{p<q} \\mathbf{r}_{pq} \\otimes \\mathbf{F}_{qp}\n$$\n现在我们分析解析的全局维里 $\\mathbf{W}$：\n$$\n\\mathbf{W} = - \\frac{1}{2} \\sum_{i \\neq j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} = - \\frac{1}{2} \\sum_{i<j} \\left( (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) + (\\mathbf{r}_{ji} \\otimes \\mathbf{F}_{ji}) \\right)\n$$\n使用 $\\mathbf{r}_{ji}=-\\mathbf{r}_{ij}$ 和 $\\mathbf{F}_{ji}=-\\mathbf{F}_{ij}$，$(j,i)$ 的项是 $\\mathbf{r}_{ji} \\otimes \\mathbf{F}_{ji} = (-\\mathbf{r}_{ij}) \\otimes (-\\mathbf{F}_{ij}) = \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}$。所以括号内的表达式是 $2(\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij})$。\n$$\n\\mathbf{W} = - \\frac{1}{2} \\sum_{i<j} 2 (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) = - \\sum_{i<j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} = \\sum_{i<j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ji}\n$$\n这恰好是从网格应力求和得到的结果。因此，离散公式精确地守恒了全局维里：\n$$\n\\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} h^3 = \\mathbf{W}\n$$\n数值实现应该显示一个等于零（在浮点精度范围内）的差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the particle-to-mesh problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (general multi-particle)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([1.0, 2.0, 1.5]),\n            \"positions\": np.array([[0.2, 0.3, 0.4], [0.8, 0.1, 0.9], [0.5, 0.5, 0.5]])\n        },\n        # Case B (boundary wrap single particle)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([1.0]),\n            \"positions\": np.array([[0.99, 0.01, 0.49]])\n        },\n        # Case C (minimum-image close pair)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([1.0, 1.0]),\n            \"positions\": np.array([[0.95, 0.5, 0.5], [0.05, 0.5, 0.5]])\n        },\n        # Case D (empty system)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([]),\n            \"positions\": np.array([])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        N_grid = case[\"N_grid\"]\n        epsilon = case[\"epsilon\"]\n        sigma = case[\"sigma\"]\n        r_c = case[\"r_c\"]\n        masses = case[\"masses\"]\n        positions = case[\"positions\"]\n        \n        num_particles = len(masses)\n        h = L / N_grid\n        h_inv = 1.0 / h\n\n        # Initialize grids for deposited mass (M_k) and stress (Sigma_k)\n        mass_grid = np.zeros((N_grid, N_grid, N_grid))\n        stress_grid = np.zeros((N_grid, N_grid, N_grid, 3, 3))\n        \n        # --- Mass Deposition ---\n        if num_particles > 0:\n            for p_idx in range(num_particles):\n                m_p = masses[p_idx]\n                r_p = positions[p_idx]\n                \n                s_p = r_p * h_inv\n                base_idx = np.floor(s_p).astype(int)\n                frac_coord = s_p - base_idx\n                \n                # Cloud-in-Cell (CIC) weights\n                w = np.zeros((2, 3))\n                w[0, :] = 1.0 - frac_coord\n                w[1, :] = frac_coord\n\n                for di in range(2):\n                    for dj in range(2):\n                        for dk in range(2):\n                            weight = w[di, 0] * w[dj, 1] * w[dk, 2]\n                            grid_idx = (base_idx + np.array([di, dj, dk])) % N_grid\n                            mass_grid[grid_idx[0], grid_idx[1], grid_idx[2]] += m_p * weight\n        \n        # --- Stress Deposition and Analytic Virial ---\n        analytic_virial = np.zeros((3, 3))\n\n        if num_particles > 1:\n            for i in range(num_particles):\n                for j in range(i + 1, num_particles):\n                    # Minimum image convention\n                    r_ij_raw = positions[j] - positions[i]\n                    r_ij = r_ij_raw - L * np.round(r_ij_raw / L)\n                    r_sq = np.dot(r_ij, r_ij)\n                    \n                    if 0 < r_sq < r_c**2:\n                        r = np.sqrt(r_sq)\n                        \n                        # Lennard-Jones force calculation\n                        # F_ji = force on particle j due to i\n                        s_over_r_2 = (sigma / r)**2\n                        s_over_r_6 = s_over_r_2**3\n                        s_over_r_12 = s_over_r_6**2\n                        \n                        force_magnitude = 24.0 * epsilon / r * (2.0 * s_over_r_12 - s_over_r_6)\n                        F_ji = (force_magnitude / r) * r_ij\n                        \n                        # Contribution to analytic virial: r_ij (x) F_ji\n                        virial_pair = np.outer(r_ij, F_ji)\n                        analytic_virial += virial_pair\n                        \n                        # Deposition onto grid at midpoint\n                        r_mid = positions[i] + 0.5 * r_ij\n                        # Ensure midpoint is within [0, L)\n                        r_mid = r_mid - L * np.floor(r_mid / L)\n\n                        s_mid = r_mid * h_inv\n                        base_idx = np.floor(s_mid).astype(int)\n                        frac_coord = s_mid - base_idx\n                        \n                        w = np.zeros((2, 3))\n                        w[0, :] = 1.0 - frac_coord\n                        w[1, :] = frac_coord\n\n                        for di in range(2):\n                            for dj in range(2):\n                                for dk in range(2):\n                                    weight = w[di, 0] * w[dj, 1] * w[dk, 2]\n                                    grid_idx = (base_idx + np.array([di, dj, dk])) % N_grid\n                                    stress_grid[grid_idx[0], grid_idx[1], grid_idx[2]] += virial_pair * weight\n\n        # --- Calculate Diagnostics ---\n        \n        # 1. Total mass on the mesh\n        # M_grid = sum(rho_ijk * h^3) = sum( (M_ijk/h^3) * h^3 ) = sum(M_ijk)\n        total_mass_grid = np.sum(mass_grid)\n        \n        # 2. Maximum grid density value\n        # rho_ijk = M_ijk / h^3\n        if num_particles > 0:\n            rho_grid_density = mass_grid / (h**3)\n            max_rho = np.max(rho_grid_density)\n        else:\n            max_rho = 0.0\n\n        # 3. Frobenius norm of stress difference\n        # W_grid = sum(sigma_ijk * h^3) = sum( (Sigma_ijk/h^3) * h^3 ) = sum(Sigma_ijk)\n        grid_virial = np.sum(stress_grid, axis=(0, 1, 2))\n        stress_diff = grid_virial - analytic_virial\n        stress_norm = np.linalg.norm(stress_diff, 'fro')\n        \n        results.extend([total_mass_grid, max_rho, stress_norm])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "2424437"}, {"introduction": "要真正掌握PME方法，必须理解其公式如何从第一性原理推导而来。本练习挑战你为具有对数相互作用的二维系统推导倒易空间核，这在等离子体物理或二维引力等领域中很常见。通过这个理论推导，你将巩固对泊松方程、高斯屏蔽思想以及它们如何通过傅里叶变换最终形成PME倒易空间部分的理解[@problem_id:2424403]。", "problem": "考虑在一个边长为 $L$、具有周期性边界条件的二维方形区域中，有 $N$ 个点电荷，其电荷量为 $\\{q_{j}\\}_{j=1}^{N}$，位置为 $\\{\\mathbf{r}_{j}\\}_{j=1}^{N}$。假设系统整体呈电中性，即 $\\sum_{j=1}^{N} q_{j} = 0$。基本相互作用是对数形式的：电势 $\\phi(\\mathbf{r})$ 满足二维泊松方程 $\\Delta \\phi(\\mathbf{r}) = -2\\pi \\rho(\\mathbf{r})$，因此两个单位电荷之间的对势与 $-\\ln r$ 成正比，其中 $r = |\\mathbf{r}|$。在粒子网格 Ewald (Particle–Mesh Ewald, PME) 方法中，我们为每个点电荷引入一个高斯屏蔽电荷密度，其宽度（Ewald）参数为 $\\alpha > 0$，由下式给出\n$$\n\\rho_{G}(\\mathbf{r}) = \\frac{\\alpha^{2}}{\\pi}\\,\\exp\\!\\big(-\\alpha^{2} r^{2}\\big),\n$$\n并将长程势定义为以 $\\rho_{G} * \\rho$ 为源的屏蔽泊松方程的周期解，其中 $*$ 表示卷积，$\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} q_{j}\\,\\delta(\\mathbf{r}-\\mathbf{r}_{j})$ 是微观电荷密度。\n\n设二维离散傅里叶模式为 $\\mathbf{k} = \\frac{2\\pi}{L}(m_{x}, m_{y})$，其中 $(m_{x}, m_{y}) \\in \\mathbb{Z}^{2}$，并为域上的周期函数 $f(\\mathbf{r})$ 定义傅里叶系数\n$$\n\\hat{f}(\\mathbf{k}) = \\int_{[0,L)^{2}} f(\\mathbf{r})\\,\\exp\\!\\big(-i\\,\\mathbf{k}\\cdot\\mathbf{r}\\big)\\,d^{2}\\mathbf{r}\n\\quad\\text{及}\\quad\nf(\\mathbf{r}) = \\frac{1}{L^{2}} \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k})\\,\\exp\\!\\big(i\\,\\mathbf{k}\\cdot\\mathbf{r}\\big).\n$$\n记 $k = |\\mathbf{k}|$。在倒易空间中，PME 长程势通过一个核函数 $\\hat{G}(\\mathbf{k})$ 写为 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{G}(\\mathbf{k})\\,\\hat{\\rho}(\\mathbf{k})$（对于 $\\mathbf{k} \\neq \\mathbf{0}$）。推导 $\\hat{G}(\\mathbf{k})$（对于 $\\mathbf{k} \\neq \\mathbf{0}$）关于 $\\alpha$ 和 $k$ 的精确闭式解析表达式。您的最终答案必须是仅含 $k$ 和 $\\alpha$ 的单一表达式。不要包含 $\\mathbf{k} = \\mathbf{0}$ 模式。不需要进行数值计算。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件。\n- 一个包含 $N$ 个点电荷的系统，其电荷量为 $\\{q_{j}\\}_{j=1}^{N}$，位置为 $\\{\\mathbf{r}_{j}\\}_{j=1}^{N}$。\n- 域是边长为 $L$ 的二维方形区域，具有周期性边界条件。\n- 系统呈电中性：$\\sum_{j=1}^{N} q_{j} = 0$。\n- 二维泊松方程为 $\\Delta \\phi(\\mathbf{r}) = -2\\pi \\rho(\\mathbf{r})$。\n- 微观电荷密度为 $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} q_{j}\\,\\delta(\\mathbf{r}-\\mathbf{r}_{j})$。\n- 高斯屏蔽电荷密度定义为 $\\rho_{G}(\\mathbf{r}) = \\frac{\\alpha^{2}}{\\pi}\\,\\exp(-\\alpha^{2} r^{2})$，其中 $r = |\\mathbf{r}|$。\n- 长程势的源是卷积 $\\rho_{G} * \\rho$。\n- 离散傅里叶模式为 $\\mathbf{k} = \\frac{2\\pi}{L}(m_{x}, m_{y})$，其中 $(m_{x}, m_{y}) \\in \\mathbb{Z}^{2}$。\n- 提供了傅里叶变换的约定：$\\hat{f}(\\mathbf{k}) = \\int_{[0,L)^{2}} f(\\mathbf{r})\\,\\exp(-i\\,\\mathbf{k}\\cdot\\mathbf{r})\\,d^{2}\\mathbf{r}$ 和 $f(\\mathbf{r}) = \\frac{1}{L^{2}} \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k})\\,\\exp(i\\,\\mathbf{k}\\cdot\\mathbf{r})$。\n- 倒易空间中长程势的关系式为 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{G}(\\mathbf{k})\\,\\hat{\\rho}(\\mathbf{k})$（对于 $\\mathbf{k} \\neq \\mathbf{0}$），其中 $k=|\\mathbf{k}|$。\n- 目标是推导核函数 $\\hat{G}(\\mathbf{k})$ 的表达式。\n\n步骤 2：使用提取的已知条件进行验证。\n该问题具有科学依据。它描述了用于二维对数相互作用系统的粒子网格 Ewald (PME) 方法的倒易空间部分的数学公式，这是计算物理学中一种标准且成熟的技术。泊松方程、电荷密度和傅里叶变换的约定都是标准的，并且内部一致。\n\n该问题是适定的。它要求基于一组清晰的定义和物理方程，推导一个特定的数学量，即傅里叶空间核函数 $\\hat{G}(\\mathbf{k})$。排除 $\\mathbf{k}=\\mathbf{0}$ 模式是一个关键且正确的规定，它避免了泊松算子格林函数中的奇点，并确保了在给定的电中性条件下问题是适定的。\n\n该问题是客观的，其术语是精确的。它不包含任何会妨碍严谨推导的主观论断、歧义或缺失信息。\n\n步骤 3：结论与行动。\n该问题被判定为 **有效**。我们继续进行推导。\n\n电势的长程分量 $\\phi^{\\mathrm{LR}}(\\mathbf{r})$ 被定义为屏蔽泊松方程的解。该方程的源是微观电荷密度 $\\rho(\\mathbf{r})$ 与高斯屏蔽密度 $\\rho_{G}(\\mathbf{r})$ 的卷积。我们将这个长程源密度表示为 $\\rho^{\\mathrm{LR}}(\\mathbf{r}) = (\\rho * \\rho_{G})(\\mathbf{r})$。因此，控制方程为：\n$$\n\\Delta \\phi^{\\mathrm{LR}}(\\mathbf{r}) = -2\\pi \\rho^{\\mathrm{LR}}(\\mathbf{r})\n$$\n为了解这个方程，我们将其变换到傅里叶空间。拉普拉斯算子 $\\Delta$ 作用于一个函数的傅里叶变换，在倒易空间中相当于乘以 $-k^{2}$，其中 $k = |\\mathbf{k}|$。对该方程两边进行傅里叶变换，得到：\n$$\n\\widehat{\\Delta \\phi^{\\mathrm{LR}}}(\\mathbf{k}) = -k^{2} \\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k})\n$$\n右边变为：\n$$\n\\mathcal{F}\\{-2\\pi \\rho^{\\mathrm{LR}}(\\mathbf{r})\\} = -2\\pi \\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k})\n$$\n因此，傅里叶空间中的泊松方程为：\n$$\n-k^{2} \\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = -2\\pi \\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k})\n$$\n对于 $\\mathbf{k} \\neq \\mathbf{0}$，我们可以解出 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k})$：\n$$\n\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k})\n$$\n接下来，我们利用卷积定理，该定理指出两个函数卷积的傅里叶变换是它们各自傅里叶变换的乘积。源 $\\rho^{\\mathrm{LR}}$ 是一个卷积，所以其傅里叶变换为：\n$$\n\\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k}) \\hat{\\rho}_{G}(\\mathbf{k})\n$$\n这里，$\\hat{\\rho}(\\mathbf{k})$ 是微观电荷密度的傅里叶变换，$\\hat{\\rho}_{G}(\\mathbf{k})$ 是高斯屏蔽密度的傅里叶变换。将此代入 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k})$ 的表达式中，得到：\n$$\n\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\hat{\\rho}_{G}(\\mathbf{k}) \\hat{\\rho}(\\mathbf{k})\n$$\n问题陈述通过核函数 $\\hat{G}(\\mathbf{k})$ 将倒易空间势定义为 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{G}(\\mathbf{k})\\,\\hat{\\rho}(\\mathbf{k})$。通过直接比较，我们确定核函数为：\n$$\n\\hat{G}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\hat{\\rho}_{G}(\\mathbf{k})\n$$\n最后一步是计算屏蔽密度 $\\rho_{G}(\\mathbf{r})$ 的傅里叶变换。由于 $\\rho_{G}(\\mathbf{r}) = \\frac{\\alpha^{2}}{\\pi}\\exp(-\\alpha^{2} r^{2})$ 是一个快速衰减的函数，其傅里叶变换通过在整个空间 $\\mathbb{R}^{2}$ 上积分来计算：\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\int_{\\mathbb{R}^{2}} \\frac{\\alpha^{2}}{\\pi}\\exp(-\\alpha^{2} r^{2}) \\exp(-i \\mathbf{k} \\cdot \\mathbf{r}) d^{2}\\mathbf{r}\n$$\n用笛卡尔坐标表示，即 $\\mathbf{r} = (x,y)$ 和 $\\mathbf{k} = (k_{x}, k_{y})$，该积分可以分离：\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\frac{\\alpha^{2}}{\\pi} \\left( \\int_{-\\infty}^{\\infty} \\exp(-\\alpha^{2} x^{2} - i k_{x} x) dx \\right) \\left( \\int_{-\\infty}^{\\infty} \\exp(-\\alpha^{2} y^{2} - i k_{y} y) dy \\right)\n$$\n这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^{2} - bx) dx = \\sqrt{\\frac{\\pi}{a}}\\exp(\\frac{b^{2}}{4a})$。对于 $x$ 的积分，我们有 $a=\\alpha^{2}$ 和 $b=ik_{x}$。结果是：\n$$\n\\int_{-\\infty}^{\\infty} \\exp(-\\alpha^{2} x^{2} - i k_{x} x) dx = \\sqrt{\\frac{\\pi}{\\alpha^{2}}} \\exp\\left(\\frac{(ik_{x})^{2}}{4\\alpha^{2}}\\right) = \\frac{\\sqrt{\\pi}}{\\alpha} \\exp\\left(-\\frac{k_{x}^{2}}{4\\alpha^{2}}\\right)\n$$\n$y$ 上的积分形式相同。结合 $x$ 和 $y$ 的积分结果：\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\frac{\\alpha^{2}}{\\pi} \\left( \\frac{\\sqrt{\\pi}}{\\alpha} \\exp\\left(-\\frac{k_{x}^{2}}{4\\alpha^{2}}\\right) \\right) \\left( \\frac{\\sqrt{\\pi}}{\\alpha} \\exp\\left(-\\frac{k_{y}^{2}}{4\\alpha^{2}}\\right) \\right)\n$$\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\frac{\\alpha^{2}}{\\pi} \\frac{\\pi}{\\alpha^{2}} \\exp\\left(-\\frac{k_{x}^{2} + k_{y}^{2}}{4\\alpha^{2}}\\right) = \\exp\\left(-\\frac{k^{2}}{4\\alpha^{2}}\\right)\n$$\n这是一个众所周知的结果，即归一化高斯函数的傅里叶变换是另一个高斯函数。\n\n最后，我们将其代回到核函数 $\\hat{G}(\\mathbf{k})$ 的表达式中：\n$$\n\\hat{G}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\exp\\left(-\\frac{k^{2}}{4\\alpha^{2}}\\right)\n$$\n这就是所要求的、适用于 $\\mathbf{k} \\neq \\mathbf{0}$ 的倒易空间 PME 核函数的闭式表达式。", "answer": "$$\n\\boxed{\\frac{2\\pi}{k^2} \\exp\\left(-\\frac{k^2}{4\\alpha^2}\\right)}\n$$", "id": "2424403"}, {"introduction": "许多真实世界的物理系统并非完全周期性的，这要求我们对标准PME方法进行修改。本练习将引导你解决一个极具挑战性的问题：模拟被限制在两块接地导体板之间的带电粒子系统。你需要修改PME框架中的泊松方程求解器，以处理这种周期性与狄利克雷边界条件混合的情况，这不仅能展示谱方法的高度灵活性的，也让你能将PME方法应用于更复杂的静电环境中[@problem_id:2424449]。", "problem": "要求您从第一性原理出发，为一个被限制在两块平行的接地导电板之间的点电荷系统，实现一个简化的粒子-网格 Ewald (PME) 长程静电计算。两块导电板平行于 $xy$ 平面，分别位于 $z=0$ 和 $z=L_z$，为静电势施加狄利克雷边界条件 $\\,\\phi(x,y,0)=\\phi(x,y,L_z)=0\\,$。该系统在 $x$ 和 $y$ 方向上具有周期性，盒子长度分别为 $L_x$ 和 $L_y$。您的目标是使用一个遵循这些边界条件的离散泊松求解器，计算完全由基于网格的长程场所产生的粒子所受电场力。\n\n基本原理：\n- 从微分形式的高斯定律和真空中的静电本构关系出发：$\\nabla\\cdot \\mathbf{E} = \\rho/\\varepsilon_0$ 和 $\\mathbf{E}=-\\nabla\\phi$，二者结合得到泊松方程 $\\nabla^2 \\phi = -\\rho/\\varepsilon_0$。\n- 使用规则的笛卡尔网格，其网格间距为 $\\Delta x=L_x/N_x$、$\\Delta y=L_y/N_y$ 和 $\\Delta z=L_z/(N_z-1)$，其中 $N_x$、$N_y$ 是 $x$ 和 $y$ 方向（周期性）的网格点数，$N_z$ 是 $z$ 方向包括两个边界平面 $z=0$ 和 $z=L_z$（狄利克雷）在内的网格点数。内部平面集的索引为 $k=1,\\dots,N_z-2$。\n- 使用云中单元格法 (Cloud-in-Cell, CIC) 将电荷分配到网格，并从网格将场插值回粒子位置，这两种操作都与网格保持一致。\n- 使用混合谱方法求解离散泊松方程：在 $x$ 和 $y$ 方向使用离散傅里叶变换（周期性），在 $z$ 方向使用离散正弦变换（狄利克雷）。对于 $x$ 和 $y$ 方向，离散拉普拉斯算子的本征值为 $\\lambda_x(p) = \\left(2\\cos\\left(2\\pi p/N_x\\right)-2\\right)/\\Delta x^2$（其中 $p=0,\\dots,N_x-1$）和 $\\lambda_y(q) = \\left(2\\cos\\left(2\\pi q/N_y\\right)-2\\right)/\\Delta y^2$（其中 $q=0,\\dots,N_y-1$）。对于具有狄利克雷边界条件的 $z$ 方向，在内部节点上使用离散正弦基，其本征值为 $\\lambda_z(m) = \\left(2\\cos\\left(\\pi m/(N_z-1)\\right)-2\\right)/\\Delta z^2$（其中 $m=1,\\dots,N_z-2$）。总本征值为 $\\lambda(p,q,m)=\\lambda_x(p)+\\lambda_y(q)+\\lambda_z(m)$。\n- 在谱空间中，求解 $\\lambda\\,\\Phi = -\\widehat{\\rho}/\\varepsilon_0$ 得到 $\\Phi$，其中 $\\widehat{\\rho}$ 是内部 $z$ 平面上的变换后电荷密度，$\\Phi$ 是这些内部平面上的变换后电势。然后进行逆变换以获得整个网格上的 $\\phi$，通过构造使得边界平面上的 $\\phi=0$。\n- 使用有限差分法计算电场分量，在 $x$ 和 $y$ 方向使用周期性差分，在 $z$ 方向内部使用中心差分；在 $z$ 边界上，使用单边二阶差分来近似 $\\partial\\phi/\\partial z$，与狄利克雷边界条件保持一致。\n\n数值与物理规格：\n- 使用真空介电常数 $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$。\n- 所有粒子电荷单位必须是库仑（Coulombs），位置单位是米（meters），输出的力单位是牛顿（Newtons）。\n- 您只需计算通过在网格上求解具有所述边界条件的泊松方程而得到的基于网格的长程力。不要包含任何显式的短程或自相互作用修正；此举的目的是测试通过网格求解中的边界条件来正确引入导电板。\n\n算法要求：\n- 实现将每个位于位置 $\\mathbf{r}_\\ell$ 的点电荷 $q_\\ell$ 分配到其最近的八个网格节点的 CIC 分配算法。在 $x$ 和 $y$ 方向使用周期性环绕。在 $z$ 方向，通过限制插值索引，将电荷分配限制在内部平面 $k=1,\\dots,N_z-2$上，使得没有电荷被分配到边界节点 $k=0$ 或 $k=N_z-1$；尽管在靠近板的区域进行了限制，仍需归一化权重以使其在 $z$ 方向上的总和为 $1$。\n- 使用上述混合谱方法和给定的本征值，在网格上求解离散泊松方程。在 $z$ 内部使用具有标准正交归一化的 I 型离散正弦变换。\n- 在所有网格节点上计算电场 $\\mathbf{E}=-\\nabla\\phi$，使用以下公式：\n  - $E_x(i,j,k) = -\\left(\\phi(i+1,j,k)-\\phi(i-1,j,k)\\right)/(2\\Delta x)$，其中 $i$ 采用周期性环绕，\n  - $E_y(i,j,k) = -\\left(\\phi(i,j+1,k)-\\phi(i,j-1,k)\\right)/(2\\Delta y)$，其中 $j$ 采用周期性环绕，\n  - $E_z(i,j,0) = -\\left(4\\phi(i,j,1)-\\phi(i,j,2)\\right)/(2\\Delta z)$，\n  - $E_z(i,j,N_z-1) = -\\left(-4\\phi(i,j,N_z-2)+\\phi(i,j,N_z-3)\\right)/(2\\Delta z)$，\n  - $E_z(i,j,k) = -\\left(\\phi(i,j,k+1)-\\phi(i,j,k-1)\\right)/(2\\Delta z)$，其中 $k=1,\\dots,N_z-2$。\n- 使用与电荷分配相同的 CIC 权重和相同的 $z$ 方向限制策略，将电场 $\\mathbf{E}$ 从网格插值到每个粒子位置，然后计算力 $\\mathbf{F}_\\ell = q_\\ell \\mathbf{E}(\\mathbf{r}_\\ell)$。\n\n测试套件：\n对所有测试用例使用以下通用的网格和盒子参数：\n- $N_x=N_y=16$, $N_z=32$。\n- $L_x=L_y=4.0\\times 10^{-9}\\,\\mathrm{m}$, $L_z=4.0\\times 10^{-9}\\,\\mathrm{m}$。\n\n设 $e=1.602176634\\times 10^{-19}\\,\\mathrm{C}$。定义四个测试用例：\n\n- 用例 1（对称性检查）：一个电荷为 $q=+e$ 的粒子位于 $\\left(L_x/2,\\,L_y/2,\\,L_z/2\\right)$。\n- 用例 2（近板吸引）：一个电荷为 $q=+e$ 的粒子位于 $\\left(0.7L_x,\\,0.3L_y,\\,0.5\\times 10^{-9}\\,\\mathrm{m}\\right)$。\n- 用例 3（跨中平面的偶极子）：两个粒子，$q_1=+e$ 位于 $\\left(L_x/2-0.3\\times 10^{-9}\\,\\mathrm{m},\\,L_y/2,\\,L_z/2+0.4\\times 10^{-9}\\,\\mathrm{m}\\right)$，$q_2=-e$ 位于 $\\left(L_x/2+0.3\\times 10^{-9}\\,\\mathrm{m},\\,L_y/2,\\,L_z/2-0.4\\times 10^{-9}\\,\\mathrm{m}\\right)$。\n- 用例 4（两个同种电荷靠近相对的板）：两个粒子，$q_1=+e$ 位于 $\\left(L_x/3,\\,L_y/3,\\,0.6\\times 10^{-9}\\,\\mathrm{m}\\right)$，$q_2=+e$ 位于 $\\left(2L_x/3,\\,2L_y/3,\\,L_z-0.6\\times 10^{-9}\\,\\mathrm{m}\\right)$。\n\n最终输出规格：\n- 您的程序必须按顺序为每个用例计算每个粒子（按用例中列出的顺序）的力的分量 $(F_x,F_y,F_z)$，单位为牛顿。\n- 将所有用例的结果汇总到一个扁平的浮点数列表中，顺序为\n  $\\left[F_{x,1}^{(1)},F_{y,1}^{(1)},F_{z,1}^{(1)},F_{x,1}^{(2)},F_{y,1}^{(2)},F_{z,1}^{(2)},\\dots\\right]$，其中上标表示用例编号，下标表示该用例内的粒子索引。\n- 每个数以牛顿为单位表示，并四舍五入到 $6$ 位有效数字。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,...]”）。", "solution": "用户要求实现一种简化的粒子-网格 Ewald (PME) 方法，用于计算位于两块接地的导电板之间的点电荷所受的长程静电力。该问题需要从第一性原理出发，遵循一套详细的算法和物理规格来解决。\n\n### 问题验证\n\n首先，对问题陈述进行严格的验证。\n\n**1. 提取已知条件：**\n- **物理**：泊松方程 $\\nabla^2 \\phi = -\\rho/\\varepsilon_0$，具有混合边界条件：$x$ 和 $y$ 方向为周期性边界条件，$z=0$ 和 $z=L_z$ 为狄利克雷边界条件（$\\phi=0$）。\n- **离散化**：在尺寸为 $L_x \\times L_y \\times L_z$ 的盒子中使用尺寸为 $N_x \\times N_y \\times N_z$ 的规则笛卡尔网格。网格间距为 $\\Delta x=L_x/N_x$、$\\Delta y=L_y/N_y$ 和 $\\Delta z=L_z/(N_z-1)$。\n- **数值方法**：\n    - 使用云中单元格法 (Cloud-in-Cell, CIC) 进行电荷分配和场插值，并对 $z$ 方向靠近边界处采用特定的“限制”和“归一化”规则。\n    - 采用混合谱求解器：对 $xy$ 平面使用二维离散傅里叶变换 (DFT)，对 $z$ 方向的内部网格点 ($k=1, \\dots, N_z-2$) 使用离散正弦变换 (DST)。\n    - 提供了变换空间中离散拉普拉斯算子本征值（$\\lambda_x, \\lambda_y, \\lambda_z$）的具体公式。\n    - 电场 $\\mathbf{E} = -\\nabla\\phi$ 通过指定的有限差分模板计算（内部使用中心差分，边界使用二阶单边差分）。\n- **参数**：给定了 $\\varepsilon_0$、$e$、盒子尺寸（$L_x, L_y, L_z$）和网格尺寸（$N_x, N_y, N_z$）的值。\n- **测试用例**：定义了四种特定的点电荷配置。\n- **输出**：一个包含所有粒子所有力分量的扁平列表，格式化为 $6$ 位有效数字。\n\n**2. 验证评估：**\n- **科学基础**：该问题牢固地植根于经典静电学和计算物理学中求解偏微分方程的成熟数值方法。所提出的方法是 PME 的一个有效变体，尽管是简化的，但特别适用于平板几何构型。\n- **适定的**：该问题是适定的。使用混合谱方法求解具有给定边界条件的泊松方程，可以得到电势的唯一解。指定的离散拉普拉斯算子本征值 $\\lambda(p,q,m) = \\lambda_x(p) + \\lambda_y(q) + \\lambda_z(m)$ 始终非零。具体来说，对于给定的索引范围，$\\lambda_x(p) \\le 0$，$\\lambda_y(q) \\le 0$，且 $\\lambda_z(m) < 0$，确保它们的和始终严格为负。这保证了在谱空间中的除法运算总是有效的。\n- **客观与完整**：问题以精确、客观的语言陈述。所有必要的参数、方程和算法步骤均已提供。关于 CIC 的“限制”过程存在轻微的模糊性，我们将其解释为将越界的网格索引映射到最近的有效内部索引（$1$ 或 $N_z-2$）。该过程被指定在电荷分配和场插值中一致使用，从而保持了算法的自洽性。\n- **未检测到其他缺陷**：该问题在科学上并无不健全、不可形式化、矛盾、不切实际或不可验证之处。\n\n**3. 结论：**\n该问题是**有效的**。可以按照指定的程序构建一个完整的解决方案。\n\n### 求解推导\n\n求解过程遵循概述的算法。核心步骤是：(1) 将电荷分配到网格，(2) 在网格上求解泊松方程，(3) 从电势计算电场，以及 (4) 将电场插值回粒子位置以求得力。\n\n**1. 网格与参数设置**\n我们定义模拟盒子和网格参数。盒子尺寸为 $L_x, L_y, L_z$，网格尺寸为 $N_x, N_y, N_z$。网格间距为 $\\Delta x = L_x/N_x$，$\\Delta y = L_y/N_y$，$\\Delta z = L_z/(N_z-1)$。物理常数 $\\varepsilon_0$ 和 $e$ 按规定使用。\n\n**2. 电荷分配 (CIC)**\n对于每个电荷为 $q_\\ell$、位置为 $\\mathbf{r}_\\ell = (x_\\ell, y_\\ell, z_\\ell)$ 的粒子，我们将其电荷映射到网格上。\n首先，我们计算粒子的分数坐标和基准网格索引：\n- $u_x = x_\\ell / \\Delta x$, $i_{base} = \\lfloor u_x \\rfloor \\pmod{N_x}$, $d_x = u_x - \\lfloor u_x \\rfloor$\n- $u_y = y_\\ell / \\Delta y$, $j_{base} = \\lfloor u_y \\rfloor \\pmod{N_y}$, $d_y = u_y - \\lfloor u_y \\rfloor$\n- $u_z = z_\\ell / \\Delta z$, $k_{base} = \\lfloor u_z \\rfloor$, $d_z = u_z - k_{base}$\n\n电荷 $q_\\ell$ 被分配到 8 个最近的网格点。对于网格点 $(i_{base}+di, j_{base}+dj, k_{base}+dk)$（其中 $di, dj, dk \\in \\{0, 1\\}$），其权重为 $w_x(di)w_y(dj)w_z(dk)$，其中 $w_x(0) = 1-d_x$， $w_x(1)=d_x$，对于 $y,z$ 也是如此。\n电荷被沉积到一个尺寸为 $N_x \\times N_y \\times (N_z-2)$ 的内部网格 $\\rho$ 上，对应于物理平面 $k=1, \\dots, N_z-2$。根据问题的“限制”指令，任何目标 $z$ 索引 $k$ 超出 $[1, N_z-2]$ 范围的分配都会被重定向到最近的有效索引。这通过限制目标索引来实现：$k_{target} = \\text{clip}(k, 1, N_z-2)$。最后，电荷网格除以单元体积 $V_{cell} = \\Delta x \\Delta y \\Delta z$ 得到电荷密度。\n\n**3. 在谱空间中求解泊松方程**\n离散泊松方程通过混合谱方法求解。\n电荷密度网格 $\\rho(i, j, k')$（其中 $k' = k-1$ 是内部网格的索引，$k' \\in [0, N_z-3]$）变换如下：\n- 沿 $x$ 和 $y$ 轴应用二维快速傅里叶变换 (FFT)。\n- 沿 $z$ 轴应用一种特殊的离散正弦变换 (DST)。问题暗示了基于本征函数 $\\sin(\\frac{\\pi m k}{N_z-1})$ 的 DST，用于内部点 $k=1, \\dots, N_z-2$。这是一种特定类型的 DST，我们通过与标准正交变换矩阵 $S_{mk} = \\sqrt{\\frac{2}{N_z-1}} \\sin(\\frac{\\pi m k}{N_z-1})$ 进行矩阵乘法来实现。\n\n变换后的密度 $\\widehat{\\rho}(p,q,m)$ 现在位于谱域中。我们使用提供的公式构建拉普拉斯算子本征值网格 $\\lambda(p,q,m) = \\lambda_x(p) + \\lambda_y(q) + \\lambda_z(m)$：\n$$ \\lambda_x(p) = \\frac{2\\cos(2\\pi p/N_x) - 2}{\\Delta x^2}, \\quad p \\in [0, N_x-1] $$\n$$ \\lambda_y(q) = \\frac{2\\cos(2\\pi q/N_y) - 2}{\\Delta y^2}, \\quad q \\in [0, N_y-1] $$\n$$ \\lambda_z(m) = \\frac{2\\cos(\\pi m/(N_z-1)) - 2}{\\Delta z^2}, \\quad m \\in [1, N_z-2] $$\n然后通过代数除法找到变换后的电势 $\\Phi$：\n$$ \\Phi(p,q,m) = -\\frac{\\widehat{\\rho}(p,q,m)}{\\varepsilon_0 \\lambda(p,q,m)} $$\n这个除法是适定的，因为 $\\lambda(p,q,m) < 0$。\n通过应用逆变换，可以恢复实空间中内部网格上的电势 $\\phi(i,j,k')$：先进行逆 DST（与正向 DST 相同，因为矩阵 $S$ 是对称且正交的），然后进行二维逆 FFT。通过用零填充边界平面 $k=0$ 和 $k=N_z-1$ 的内部解，形成尺寸为 $N_x \\times N_y \\times N_z$ 的完整电势网格 $\\phi$，从而满足狄利克雷条件。\n\n**4. 电场计算**\n使用指定的有限差分法在整个网格上计算电场 $\\mathbf{E} = -\\nabla\\phi$：\n- $E_x, E_y$：使用周期性边界条件的中心差分。例如，$E_x(i,j,k) = -(\\phi_{i+1,j,k} - \\phi_{i-1,j,k})/(2\\Delta x)$。\n- $E_z$：对于内部点 $k \\in [1, N_z-2]$ 使用中心差分，在边界 $k=0$ 和 $k=N_z-1$ 处使用二阶单边模板，这些模板考虑了 $\\phi=0$ 的边界条件。\n$$ E_z(i,j,0) = -\\frac{4\\phi_{i,j,1} - \\phi_{i,j,2}}{2\\Delta z} $$\n$$ E_z(i,j,N_z-1) = -\\frac{-4\\phi_{i,j,N_z-2} + \\phi_{i,j,N_z-3}}{2\\Delta z} $$\n\n**5. 力插值**\n使用与电荷分配步骤中相同的 CIC 权重和 $z$ 轴限制逻辑，将电场 $\\mathbf{E}$ 从网格插值回每个粒子的位置 $\\mathbf{r}_\\ell$。这确保了一致性并保持动量守恒。粒子所受的力则为 $\\mathbf{F}_\\ell = q_\\ell \\mathbf{E}(\\mathbf{r}_\\ell)$。\n\n**案例1：合理性检查**\n对于位于盒子正中心 $(L_x/2, L_y/2, L_z/2)$ 的单个电荷，由于对称性，其受力必须为零。$x, y$ 方向的周期性镜像以及由 $z$ 方向导电板引起的镜像电荷所产生的力将在该中心点完美抵消。实现必须重现这个 $\\mathbf{F}=(0,0,0)$ 的结果，作为对代码正确性的关键验证。", "answer": "```python\nimport numpy as np\n\ndef format_to_sig_figs(value, sig_figs):\n    \"\"\"Formats a number to a specified number of significant figures.\"\"\"\n    if value == 0:\n        return '0.0'\n    \n    # Use 'g' format specifier which is designed for significant figures\n    # and handles scientific notation appropriately.\n    return f\"{value:.{sig_figs}g}\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the PME problem for the given test cases.\n    \"\"\"\n    # Physical and numerical constants\n    EPS0 = 8.854187817e-12  # F/m\n    E_CHARGE = 1.602176634e-19  # C\n\n    # Common mesh and box parameters\n    NX, NY, NZ = 16, 16, 32\n    LX, LY, LZ = 4.0e-9, 4.0e-9, 4.0e-9\n\n    test_cases_defs = [\n        # Case 1: Symmetry check\n        {\"charges\": [E_CHARGE], \"positions\": np.array([[LX / 2, LY / 2, LZ / 2]])},\n        # Case 2: Near-plate attraction\n        {\"charges\": [E_CHARGE], \"positions\": np.array([[0.7 * LX, 0.3 * LY, 0.5e-9]])},\n        # Case 3: Dipole across mid-plane\n        {\n            \"charges\": [E_CHARGE, -E_CHARGE],\n            \"positions\": np.array([\n                [LX / 2 - 0.3e-9, LY / 2, LZ / 2 + 0.4e-9],\n                [LX / 2 + 0.3e-9, LY / 2, LZ / 2 - 0.4e-9]\n            ]),\n        },\n        # Case 4: Two like charges near opposite plates\n        {\n            \"charges\": [E_CHARGE, E_CHARGE],\n            \"positions\": np.array([\n                [LX / 3, LY / 3, 0.6e-9],\n                [2 * LX / 3, 2 * LY / 3, LZ - 0.6e-9]\n            ]),\n        },\n    ]\n\n    all_forces = []\n\n    for case_def in test_cases_defs:\n        forces = compute_pme_forces(\n            case_def[\"charges\"],\n            case_def[\"positions\"],\n            (LX, LY, LZ),\n            (NX, NY, NZ),\n            EPS0,\n        )\n        all_forces.extend(forces.flatten())\n\n    # Format results to 6 significant figures\n    formatted_results = [format_to_sig_figs(f, 6) for f in all_forces]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_pme_forces(charges, positions, L, N, eps0):\n    \"\"\"\n    Computes mesh-based electrostatic forces using the specified PME algorithm.\n    \"\"\"\n    LX, LY, LZ = L\n    NX, NY, NZ = N\n    \n    dx = LX / NX\n    dy = LY / NY\n    dz = LZ / (NZ - 1)\n    \n    # 1. Charge Assignment (CIC)\n    rho = np.zeros((NX, NY, NZ - 2))\n    \n    # Store weights for force interpolation\n    particle_weights = []\n\n    for idx, (q, pos) in enumerate(zip(charges, positions)):\n        weights_info = {}\n        # Fractional coordinates and base indices\n        ux, uy, uz = pos[0] / dx, pos[1] / dy, pos[2] / dz\n        \n        ix_base, iy_base, iz_base = int(np.floor(ux)), int(np.floor(uy)), int(np.floor(uz))\n        dx_frac, dy_frac, dz_frac = ux - ix_base, uy - iy_base, uz - iz_base\n        \n        weights_info['bases'] = (ix_base, iy_base, iz_base)\n        weights_info['fracs'] = (dx_frac, dy_frac, dz_frac)\n        \n        # Distribute charge to 8 nearest grid points\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    i = (ix_base + di) % NX\n                    j = (iy_base + dj) % NY\n                    k_physical = iz_base + dk\n                    \n                    # Clamp z-index to interior planes [1, NZ-2]\n                    k_clamped = np.clip(k_physical, 1, NZ - 2)\n                    k_rho = k_clamped - 1 # Index for rho array\n\n                    wx = (1 - dx_frac) if di == 0 else dx_frac\n                    wy = (1 - dy_frac) if dj == 0 else dy_frac\n                    wz = (1 - dz_frac) if dk == 0 else dz_frac\n                    \n                    rho[i, j, k_rho] += q * wx * wy * wz\n\n        particle_weights.append(weights_info)\n\n    rho /= (dx * dy * dz)  # Convert to charge density\n\n    # 2. Solve Poisson Equation\n    # 2a. Fourier transform in x, y\n    rho_hat_xy = np.fft.fft2(rho, axes=(0, 1))\n\n    # 2b. Custom Discrete Sine Transform in z\n    N_interior = NZ - 2\n    S = np.zeros((N_interior, N_interior))\n    m_vals = np.arange(1, N_interior + 1)\n    k_vals = np.arange(1, N_interior + 1)\n    arg = np.pi * m_vals[:, None] * k_vals[None, :] / (NZ - 1)\n    S = np.sqrt(2.0 / (NZ - 1)) * np.sin(arg)\n\n    # Einstein summation for applying DST matrix to all (i,j) slices\n    rho_hat = np.einsum('ijk,lk->ijl', rho_hat_xy, S, optimize=True)\n\n    # 2c. Solve in spectral space\n    p = np.fft.fftfreq(NX) * NX\n    q = np.fft.fftfreq(NY) * NY\n    m = np.arange(1, NZ - 1)\n\n    lambda_x = (2 * np.cos(2 * np.pi * p / NX) - 2) / dx**2\n    lambda_y = (2 * np.cos(2 * np.pi * q / NY) - 2) / dy**2\n    lambda_z = (2 * np.cos(np.pi * m / (NZ - 1)) - 2) / dz**2\n\n    lambda_total = (lambda_x[:, None, None] + lambda_y[None, :, None] + lambda_z[None, None, :])\n    \n    # Avoid division by zero (although lambda_total is never zero here)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        phi_hat = -rho_hat / (eps0 * lambda_total)\n    \n    # Handle the mode p=0, q=0 if needed (not an issue here because lambda_z is always < 0)\n    if NX > 0 and NY > 0 : phi_hat[0, 0, :] = 0.0 + 0.0j\n\n\n    # 2d. Inverse transforms\n    # Inverse DST (S is its own inverse)\n    phi_xy = np.einsum('ijk,lk->ijl', phi_hat, S, optimize=True)\n    \n    # Inverse FFT\n    phi_interior = np.fft.ifft2(phi_xy, axes=(0, 1)).real\n    \n    phi = np.zeros((NX, NY, NZ))\n    phi[:, :, 1:-1] = phi_interior\n\n    # 3. Calculate Electric Field\n    Ex = - (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * dx)\n    Ey = - (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * dy)\n    \n    Ez = np.zeros_like(phi)\n    # Interior\n    Ez[:, :, 1:-1] = - (phi[:, :, 2:] - phi[:, :, :-2]) / (2 * dz)\n    # Boundaries (phi is 0 on boundaries)\n    Ez[:, :, 0] = - (4 * phi[:, :, 1] - phi[:, :, 2]) / (2 * dz)\n    Ez[:, :, -1] = - (-4 * phi[:, :, -2] + phi[:, :, -3]) / (2 * dz)\n\n    # 4. Interpolate Field and Calculate Force\n    forces = np.zeros((len(charges), 3))\n    for idx, (q, weights_info) in enumerate(zip(charges, particle_weights)):\n        # Retrieve weights and indices for this particle\n        ix_base, iy_base, iz_base = weights_info['bases']\n        dx_frac, dy_frac, dz_frac = weights_info['fracs']\n        \n        E_particle = np.zeros(3)\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    i = (ix_base + di) % NX\n                    j = (iy_base + dj) % NY\n                    k_physical = iz_base + dk\n                    \n                    # Use the same clamping on the FULL field grid\n                    k_clamped = np.clip(k_physical, 0, NZ-1)\n                    # Note: Original problem described clamping to interior [1, NZ-2]\n                    # This could be interpreted for interpolation as well. Let's be consistent\n                    # with the charge assignment clamping that operated on k in [1, NZ-2].\n                    # Let's re-read: \"interpolate E from the mesh... using the same CIC weights and\n                    # the same clamping strategy in z.\" The field E is defined on the full grid,\n                    # so clamping indices can be done on the full grid. Let's use the same clamping\n                    # logic as for charge deposition for full consistency.\n                    k_interp_idx = np.clip(k_physical, 1, NZ-2)\n\n                    wx = (1 - dx_frac) if di == 0 else dx_frac\n                    wy = (1 - dy_frac) if dj == 0 else dy_frac\n                    wz = (1 - dz_frac) if dk == 0 else dz_frac\n                    \n                    weight = wx * wy * wz\n                    E_particle[0] += Ex[i, j, k_interp_idx] * weight\n                    E_particle[1] += Ey[i, j, k_interp_idx] * weight\n                    E_particle[2] += Ez[i, j, k_interp_idx] * weight\n        \n        forces[idx, :] = q * E_particle\n        \n    return forces\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2424449"}]}