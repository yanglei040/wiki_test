{"hands_on_practices": [{"introduction": "流函数-涡量方法的核心在于求解泊松方程 $\\nabla^2 \\psi = -\\omega$。本练习将引导你从最基础也最重要的部分入手：在一个简单的矩形域上，使用一种稳健且广泛应用的数值方法——有限差分法结合逐次超松弛（SOR）迭代法——来求解这个方程。通过“人造解”方法，你不仅可以验证自己代码的正确性，还能亲手探索如何通过调整参数来优化迭代求解器的收敛性能，这是计算物理中的一项基本功。", "problem": "您的任务是设计并实现一个完整的求解器，用于求解不可压缩流的流函数-涡量公式中的二维流函数方程，并凭经验研究逐次超松弛 (Successive Over-Relaxation, SOR) 方法中松弛参数的影响。\n\n基本原理。在二维不可压缩流中，定义流函数 $\\psi(x,y)$，使得速度分量为 $u = \\partial \\psi/\\partial y$ 和 $v = -\\partial \\psi/\\partial x$，标量涡量为 $\\omega = \\partial v/\\partial x - \\partial u/\\partial y$。这些定义构成了流函数的泊松方程，\n$$\n\\nabla^2 \\psi = -\\omega.\n$$\n考虑单位正方形域 $\\Omega = (0,1)\\times(0,1)$，其边界 $\\partial \\Omega$ 上具有齐次 Dirichlet 边界条件 $ \\psi = 0 $。\n\n人造解。为获得已知的右侧项，考虑人造流函数\n$$\n\\psi^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y),\n$$\n其对应的\n$$\n\\omega(x,y) = -\\nabla^2 \\psi^\\star(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y).\n$$\n因此，需求解的问题是\n$$\n\\nabla^2 \\psi(x,y) = -\\omega(x,y) = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) \\quad \\text{在 } \\Omega \\text{ 中},\n$$\n以及在 $ \\partial \\Omega $ 上 $ \\psi = 0 $。其精确解为 $ \\psi^\\star $。\n\n离散化。使用均匀的笛卡尔网格，每个坐标方向上有 $N$ 个内部点，网格间距为 $h = 1/(N+1)$，并在内部网格点上使用标准的五点有限差分格式对拉普拉斯算子进行离散化。在边界网格点上强制施加 $ \\psi = 0 $。\n\n迭代求解器。实现逐次超松弛 (Successive Over-Relaxation, SOR) 方法来求解离散的泊松方程。使用基于离散残差无穷范数的停止准则\n$$\nr_{i,j} = \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} + \\omega_{i,j},\n$$\n即，当 $\\max_{i,j} |r_{i,j}| < \\varepsilon$ 时停止迭代。使用零场作为 $\\psi$ 的初始猜测。\n\n实证研究。对于一组固定的候选松弛参数 $ \\alpha \\in \\{1.0, 1.5, 1.7, 1.9\\} $，测量每个 $ \\alpha $ 值达到残差无穷范数容差 $ \\varepsilon $ 所需的 SOR 迭代次数。如果在指定的最大迭代次数内方法未能达到容差，则在选择最佳 $ \\alpha $ 时将该次运行视为不收敛。在收敛的候选项中，将迭代次数最少的 $ \\alpha $ 定义为经验最优松弛参数（若迭代次数相同，则选择较小的 $ \\alpha $）。\n\n测试套件。在以下三种情况下运行您的程序：\n- 情况 A (理想路径): $ N = 7 $, $ \\varepsilon = 10^{-8} $。\n- 情况 B (中等网格): $ N = 15 $, $ \\varepsilon = 10^{-8} $。\n- 情况 C (较大网格): $ N = 31 $, $ \\varepsilon = 10^{-8} $。\n\n对于所有情况，使用相同的候选集 $ \\alpha \\in \\{1.0, 1.5, 1.7, 1.9\\} $ 以及相同的人造右侧项和边界条件。每次 SOR 运行最多使用 $ 20000 $ 次迭代。\n\n程序行为要求。您的程序必须：\n- 对于每个 $ N $，根据人造解在网格上构建右侧项 $ \\omega $。\n- 对每个候选 $ \\alpha $，使用 SOR 方法求解离散泊松方程，直到满足残差准则或达到最大迭代次数。\n- 对于每个测试用例，根据上述平局决胜规则，将候选 $ \\alpha $ 中的经验最优值作为浮点数返回，并四舍五入到三位小数。\n\n最终输出格式。您的程序应生成单行输出，其中按顺序包含情况 A、B 和 C 的经验最优 $ \\alpha $ 值，形式为用方括号括起来的逗号分隔列表。例如，输出必须类似于\n[1.500,1.700,1.900]\n此问题不涉及物理单位，并且三角函数中出现的所有角度，根据所用函数的定义，均以弧度为单位。\n\n您的程序必须是一个完整的、可运行的实现，无需外部输入。它必须遵守稍后指定的执行环境，并与上述输出格式完全匹配。", "solution": "所提出的问题是计算物理学中一个明确定义的练习，具体涉及使用迭代有限差分法求解椭圆型偏微分方程。任务是在单位正方形域上求解流函数 $\\psi$ 的泊松方程，分析逐次超松弛 (SOR) 方法的性能，并确定经验最优的松弛参数。问题陈述在科学上是合理的，内容是自洽的，算法上是精确的。因此，它被认为是有效的，并将按陈述进行求解。\n\n控制方程是流函数 $\\psi(x,y)$ 的二维泊松方程：\n$$\n\\nabla^2 \\psi = -\\omega\n$$\n其中 $\\omega$ 是标量涡量。域是单位正方形 $\\Omega = (0,1) \\times (0,1)$，边界条件为齐次 Dirichlet 条件，即在边界 $\\partial\\Omega$ 上 $\\psi = 0$。采用人造解方法进行验证，其中精确解被指定为 $\\psi^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。这意味着涡量源项为 $\\omega(x,y) = -\\nabla^2 \\psi^\\star(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。\n\n第一步是离散化连续问题。采用均匀的笛卡尔网格，每个坐标方向有 $N$ 个内部点。网格间距为 $h = 1/(N+1)$。网格点由 $(x_i, y_j) = (ih, jh)$ 表示，其中索引 $i, j \\in \\{0, 1, \\dots, N+1\\}$。未知值为内部点上的流函数 $\\psi_{i,j} = \\psi(x_i, y_j)$，其中 $i, j \\in \\{1, \\dots, N\\}$。在边界上，即 $i=0, i=N+1, j=0,$ 或 $j=N+1$ 时，值固定为 $\\psi_{i,j} = 0$。\n\n在每个内部网格点 $(i,j)$ 处，使用标准的二阶精度五点有限差分模板来近似拉普拉斯算子 $\\nabla^2$：\n$$\n\\nabla^2 \\psi \\bigg|_{(x_i,y_j)} \\approx \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2}\n$$\n将此代入控制方程 $\\nabla^2 \\psi = -\\omega$ 中，得到关于未知值 $\\psi_{i,j}$ 的线性代数方程组：\n$$\n\\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} = -\\omega_{i,j}\n$$\n其中 $\\omega_{i,j} = 2\\pi^2 \\sin(\\pi x_i)\\sin(\\pi y_j)$。\n\n该线性系统使用逐次超松弛 (SOR) 方法求解。SOR 是一种加速 Gauss-Seidel 方法收敛的迭代技术。对于由 $k$ 索引的每次迭代，通过遍历所有内部网格点来计算下一次迭代的 $\\psi_{i,j}$ 值，即 $\\psi_{i,j}^{(k+1)}$。$\\psi_{i,j}$ 的更新规则是：\n$$\n\\psi_{i,j}^{(k+1)} = (1 - \\alpha)\\psi_{i,j}^{(k)} + \\frac{\\alpha}{4} \\left( \\psi_{i-1,j}^{(k+1)} + \\psi_{i,j-1}^{(k+1)} + \\psi_{i+1,j}^{(k)} + \\psi_{i,j+1}^{(k)} + h^2 \\omega_{i,j} \\right)\n$$\n这里，$\\alpha$ 是松弛参数。对于采用字典序扫描（例如，先遍历 $i$ 从 $1$ 到 $N$，再遍历 $j$ 从 $1$ 到 $N$）的原地实现，该公式使用了当前迭代中最近更新的值 $\\psi_{i-1,j}^{(k+1)}$ 和 $\\psi_{i,j-1}^{(k+1)}$，以及来自上一次迭代的值 $\\psi_{i+1,j}^{(k)}$ 和 $\\psi_{i,j+1}^{(k)}$。此更新的一个实现是：\n$$\n\\psi_{i,j} \\leftarrow (1-\\alpha)\\psi_{i,j} + \\frac{\\alpha}{4}(\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} + h^2 \\omega_{i,j})\n$$\n整个场的初始猜测为 $\\psi^{(0)} = 0$。\n\n迭代过程持续进行，直到满足停止准则。该准则基于离散残差的无穷范数 $\\|r\\|_\\infty = \\max_{i,j} |r_{i,j}|$。每个内部点的残差定义为：\n$$\nr_{i,j} = \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} + \\omega_{i,j}\n$$\n在每次完整的 SOR 扫描之后，计算所有内部点的残差，并将其最大绝对值与指定的容差 $\\varepsilon$ 进行比较。当 $\\|r\\|_\\infty < \\varepsilon$ 时，迭代停止。如果在最大迭代次数内未满足此条件，则该次运行被视为不收敛。\n\n问题的最后一部分是一项实证研究，旨在从集合 $\\{1.0, 1.5, 1.7, 1.9\\}$ 中为三种不同的网格尺寸（$N=7$，$N=15$ 和 $N=31$）找到最优松弛参数 $\\alpha$。对于每种网格尺寸，SOR 求解器都会使用每个候选 $\\alpha$ 运行一次。记录收敛所需的迭代次数。经验最优的 $\\alpha$ 是在所有收敛运行中导致迭代次数最少的那个值。如果出现平局，则通过选择较小的 $\\alpha$ 值来决胜。最终程序将为每个测试用例执行此过程，并报告所确定的最优 $\\alpha$ 值。", "answer": "```python\nimport numpy as np\n\ndef sor_solver(N: int, alpha: float, epsilon: float, max_iter: int) -> int:\n    \"\"\"\n    Solves the 2D Poisson equation using the Successive Over-Relaxation (SOR) method.\n\n    Args:\n        N: Number of interior grid points in each direction.\n        alpha: The relaxation parameter.\n        epsilon: The convergence tolerance for the residual.\n        max_iter: The maximum number of iterations allowed.\n\n    Returns:\n        The number of iterations required for convergence, or max_iter + 1 if\n        the method did not converge.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    h_sq = h * h\n    \n    # Initialize psi grid (N+2 x N+2) with zeros for boundaries and initial guess.\n    psi = np.zeros((N + 2, N + 2), dtype=float)\n    \n    # Set up the source term omega on the grid.\n    # Grid coordinates including boundaries.\n    xy = np.linspace(0.0, 1.0, N + 2)\n    # Use meshgrid for vectorized computation of omega.\n    # 'ij' indexing matches the loop order (i=rows, j=cols).\n    X, Y = np.meshgrid(xy, xy, indexing='ij')\n    omega = 2.0 * (np.pi**2) * np.sin(np.pi * X) * np.sin(np.pi * Y)\n\n    for k in range(max_iter):\n        # Perform one full SOR sweep over the interior points.\n        # This loop is inherently sequential.\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                term = (\n                    psi[i + 1, j] + psi[i - 1, j] +\n                    psi[i, j + 1] + psi[i, j - 1] +\n                    h_sq * omega[i, j]\n                )\n                psi[i, j] = (1.0 - alpha) * psi[i, j] + (alpha / 4.0) * term\n        \n        # Calculate the residual on the interior grid after the sweep using vectorization.\n        laplacian_psi = (\n            psi[2:, 1:-1] + psi[:-2, 1:-1] +\n            psi[1:-1, 2:] + psi[1:-1, :-2]\n            - 4.0 * psi[1:-1, 1:-1]\n        )\n        # Slicing omega to match the interior grid dimensions.\n        residual_grid = laplacian_psi / h_sq + omega[1:-1, 1:-1]\n        \n        # Compute the infinity norm of the residual.\n        max_residual = np.max(np.abs(residual_grid))\n        \n        # Check for convergence.\n        if max_residual < epsilon:\n            return k + 1  # Return number of iterations performed.\n\n    # Return a value indicating non-convergence.\n    return max_iter + 1\n\ndef find_optimal_alpha(N: int, epsilon: float, alphas: list, max_iter: int) -> float:\n    \"\"\"\n    Finds the empirically optimal alpha from a candidate list for a given problem setup.\n\n    Args:\n        N: Number of interior grid points.\n        epsilon: Convergence tolerance.\n        alphas: List of candidate relaxation parameters.\n        max_iter: Maximum number of iterations.\n\n    Returns:\n        The optimal alpha value.\n    \"\"\"\n    results = []\n    for alpha in alphas:\n        iterations = sor_solver(N, alpha, epsilon, max_iter)\n        # Only consider convergent runs.\n        if iterations <= max_iter:\n            results.append((alpha, iterations))\n\n    # Sort results first by iteration count (ascending), then by alpha (ascending)\n    # to handle the tie-breaking rule.\n    results.sort(key=lambda x: (x[1], x[0]))\n    \n    # The optimal alpha is the first element after sorting.\n    if results:\n        return results[0][0]\n    else:\n        # This case implies no candidate alpha converged.\n        # It should not happen for the given problem parameters.\n        # Returning a placeholder value.\n        return -1.0\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final output.\n    \"\"\"\n    # Test suite parameters from the problem statement.\n    test_cases = [\n        {'N': 7},   # Case A\n        {'N': 15},  # Case B\n        {'N': 31},  # Case C\n    ]\n    epsilon = 1e-8\n    candidate_alphas = [1.0, 1.5, 1.7, 1.9]\n    max_iter = 20000\n\n    optimal_alpha_results = []\n    for case in test_cases:\n        N = case['N']\n        opt_alpha = find_optimal_alpha(N, epsilon, candidate_alphas, max_iter)\n        optimal_alpha_results.append(opt_alpha)\n\n    # Format the final output string as required.\n    output_str = f\"[{','.join([f'{alpha:.3f}' for alpha in optimal_alpha_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2443760"}, {"introduction": "在掌握了求解泊松方程的基本数值方法后，我们进一步将目光投向更真实的物理场景：模拟一个涡旋的流动。本练习将介绍一种在周期性问题中极为精准高效的数值工具——基于快速傅里叶变换（FFT）的谱方法。你将通过实践学习如何利用一个高斯函数来“正则化”一个理想的点涡，并通过将数值结果与解析解进行比较来开展收敛性分析 [@problem_id:2443769]，这是验证和确认任何科学计算模拟可靠性的基石。", "problem": "考虑一个边长为 $L$ 的方形域中的二维不可压缩流，该流场具有双周期边界条件。设流函数 $\\psi(x,y)$ 和涡量 $\\omega(x,y)$ 通过流函数-涡量公式关联\n$$\\nabla^2 \\psi(x,y) = -\\omega(x,y),$$\n速度场 $\\mathbf{u}(x,y)$ 由下式给出\n$$\\mathbf{u}(x,y) = \\left(\\frac{\\partial \\psi}{\\partial y}(x,y),\\,-\\frac{\\partial \\psi}{\\partial x}(x,y)\\right).$$\n一个位于域中心 $(L/2,L/2)$、环量为 $\\Gamma$ 的点涡，在均匀的 $N\\times N$ 网格上被一个标准差为 $\\sigma(N)$ 的归一化高斯涡量分布所近似：\n$$\\omega(x,y) = \\frac{\\Gamma}{2\\pi \\sigma(N)^2}\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{L}{2})^2+(y-\\tfrac{L}{2})^2}{2\\,\\sigma(N)^2}\\right),$$\n其中正则化宽度通过网格间距 $h=L/N$ 进行缩放：\n$$\\sigma(N) = c\\,h,$$\n其中 $c>0$ 是每个测试用例指定的常数。无界点涡的解析方位速度大小为\n$$u_\\theta^{\\text{exact}}(r) = \\frac{\\Gamma}{2\\pi r},\\quad r>0,$$\n其中 $r$ 是与涡旋中心的距离。对于指定列表中的每个网格尺寸 $N$，通过将 $\\mathbf{u}(x,y)$ 投影到以 $(L/2,L/2)$ 为中心的局部方位方向上，计算数值方位速度 $u_\\theta^{\\text{num}}$，并评估以下环形区域上的均方根误差：\n$$r_{\\min}(N) \\le r \\le r_{\\max},\\quad r_{\\min}(N) = \\alpha\\,\\sigma(N),\\quad r_{\\max} = \\beta\\,L,$$\n误差计算公式为：\n$$E(N) = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M}\\left(u_\\theta^{\\text{num}}(\\mathbf{x}_m)-u_\\theta^{\\text{exact}}(r_m)\\right)^2},$$\n其中 $\\{\\mathbf{x}_m\\}_{m=1}^M$ 是所有其到 $(L/2,L/2)$ 的距离 $r_m$ 满足环形区域判据的网格点。设 $h=L/N$。对于每个测试用例，通过对所提供的一组 $N$ 值的 $(\\log h,\\log E(N))$ 数据进行线性拟合，估计观测到的收敛阶 $p$，并报告其斜率 $p$。\n\n所有量均为无量纲。如果在内部引入了角度，不应报告。要求的输出是实数。\n\n测试套件：\n- 用例 A: $\\Gamma=1$, $L=1$, $N\\in\\{32,64,128,256\\}$, $c=2$, $\\alpha=3$, $\\beta=0.25$.\n- 用例 B: $\\Gamma=1$, $L=1$, $N\\in\\{32,64,128,256\\}$, $c=0.5$, $\\alpha=6$, $\\beta=0.2$.\n- 用例 C: $\\Gamma=1$, $L=2$, $N\\in\\{32,64,128,256\\}$, $c=1$, $\\alpha=4$, $\\beta=0.5$.\n\n最终输出格式：\n你的程序应生成单行输出，其中包含三个估计的收敛阶，按用例 A、B、C 的顺序排列在一个逗号分隔的列表中，并用方括号括起来，例如，“[pA,pB,pC]”。输出必须是实数。", "solution": "用户提供了一个计算物理问题，在尝试求解之前必须对其进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：流函数 $\\psi(x,y)$ 和涡量 $\\omega(x,y)$ 之间的关系由泊松方程 $\\nabla^2 \\psi(x,y) = -\\omega(x,y)$ 给出。\n- **区域**：一个边长为 $L$ 的二维方形域，具有双周期边界条件。\n- **速度场**：速度 $\\mathbf{u}(x,y)$ 从流函数导出，公式为 $\\mathbf{u}(x,y) = \\left(\\frac{\\partial \\psi}{\\partial y}(x,y),\\,-\\frac{\\partial \\psi}{\\partial x}(x,y)\\right)$。\n- **涡量源**：一个点涡由以 $(L/2, L/2)$ 为中心的高斯分布建模：\n$$ \\omega(x,y) = \\frac{\\Gamma}{2\\pi \\sigma(N)^2}\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{L}{2})^2+(y-\\tfrac{L}{2})^2}{2\\,\\sigma(N)^2}\\right) $$\n- **正则化宽度**：标准差 $\\sigma(N)$ 通过网格间距 $h=L/N$ 和一个常数 $c>0$ 进行缩放：$\\sigma(N) = c\\,h$。\n- **解析基准**：对于 $r>0$，无界点涡的解析方位速度为 $u_\\theta^{\\text{exact}}(r) = \\frac{\\Gamma}{2\\pi r}$。\n- **误差度量**：均方根(RMS)误差 $E(N)$ 在由 $r_{\\min}(N) \\le r \\le r_{\\max}$ 定义的环形区域上计算，其中 $r_{\\min}(N) = \\alpha\\,\\sigma(N)$ 且 $r_{\\max} = \\beta\\,L$：\n$$ E(N) = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M}\\left(u_\\theta^{\\text{num}}(\\mathbf{x}_m)-u_\\theta^{\\text{exact}}(r_m)\\right)^2} $$\n求和遍及环形区域内的所有 $M$ 个网格点 $\\{\\mathbf{x}_m\\}$。\n- **收敛阶**：收敛阶 $p$ 将通过对数据 $(\\log h, \\log E(N))$ 进行线性拟合，从其斜率估计得出。\n- **测试用例**：\n    - **用例 A**：$\\Gamma=1$, $L=1$, $N\\in\\{32,64,128,256\\}$, $c=2$, $\\alpha=3$, $\\beta=0.25$。\n    - **用例 B**：$\\Gamma=1$, $L=1$, $N\\in\\{32,64,128,256\\}$, $c=0.5$, $\\alpha=6$, $\\beta=0.2$。\n    - **用例 C**：$\\Gamma=1$, $L=2$, $N\\in\\{32,64,128,256\\}$, $c=1$, $\\alpha=4$, $\\beta=0.5$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题依据指定标准进行验证。\n\n- **科学基础**：该问题在计算流体力学原理方面有坚实的基础。流函数-涡量公式是分析二维不可压缩流的标准方法。使用正则化的“涡斑”（即高斯分布）来表示点涡是涡方法中处理奇异点的有效且常见的技术。所选择的求解泊松方程和进行微分的方法（鉴于周期性域，暗示为谱方法）是此类问题中的先进方法。\n- **适定性**：该问题是适定的。带周期性边界条件的泊松方程是可解的，前提是源项的平均值为零。一个标准流程，即减去平均涡量，确保了这一点。后续计算速度、误差和收敛阶的步骤都有明确的数学定义，并能导出唯一结果。\n- **客观性**：该问题以精确、客观的数学语言陈述。所有参数都已定义和量化。没有主观或模糊的陈述。\n- **缺陷清单**：该问题未违反任何无效性标准。它在科学上是合理的、可形式化的、完整的、可行的、结构良好的且可验证的。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将提供一个解决方案。\n\n### 基于原理的设计\n该问题的解决方案涉及对一系列网格分辨率进行数值模拟，然后分析由此产生的误差以确定收敛阶。\n\n1.  **离散化**：将连续域 $[0, L] \\times [0, L]$ 离散化为一个间距为 $h=L/N$ 的均匀 $N \\times N$ 网格。网格点位于 $(x_i, y_j) = (i h, j h)$，其中 $i, j = 0, \\dots, N-1$。\n\n2.  **涡量计算**：在每个网格点上计算高斯涡量分布 $\\omega(x,y)$。涡旋中心位于 $(L/2, L/2)$，对于给定的参数，该函数已足够局域化，无需进行周期求和。\n\n3.  **泊松方程求解器**：问题的核心是在双周期域上求解 $\\nabla^2 \\psi = -\\omega$。快速傅里叶变换 (FFT) 为此任务提供了一种高效且精确的谱方法。\n    - 将方程变换到傅里叶空间：$\\widehat{\\nabla^2 \\psi} = \\widehat{-\\omega}$。\n    - 拉普拉斯算子的傅里叶变换是乘以符号 $-|\\mathbf{k}|^2 = -(k_x^2 + k_y^2)$，其中 $\\mathbf{k}=(k_x, k_y)$ 是波数向量。\n    - 这给出了流函数傅里叶系数的代数关系：$\\hat{\\psi}(\\mathbf{k}) = \\frac{\\hat{\\omega}(\\mathbf{k})}{k_x^2 + k_y^2}$。\n    - 周期性泊松方程的相容性条件要求源项的积分（或均值）为零。由于 $\\int \\omega \\,dA = \\Gamma \\neq 0$，我们使用源 $\\omega' = \\omega - \\bar{\\omega}$ 来求解修正场 $\\psi'$，其中 $\\bar{\\omega} = \\frac{1}{L^2}\\int\\omega\\,dA$ 是平均涡量。这能确保 $\\hat{\\omega'}(\\mathbf{k}=0)=0$。$\\psi$ 中由此产生的常数偏移不影响速度场，因为速度场取决于其导数。\n    - 在 $\\mathbf{k}=0$ 时，分母 $k_x^2+k_y^2$ 为零。由于 $\\hat{\\omega'}(0)=0$，这导致了 $0/0$ 的不定式，对应于 $\\psi$ 的任意平均值。我们通过设置 $\\hat{\\psi}(0)=0$ 来解决此问题。\n    - 然后通过二维逆FFT恢复离散流函数 $\\psi(x_i, y_j)$。\n\n4.  **速度计算**：为保证一致性和准确性，速度分量 $u = \\partial\\psi/\\partial y$ 和 $v = -\\partial\\psi/\\partial x$ 也采用谱方法计算。在傅里叶空间中，微分对应于乘以 $i\\mathbf{k}$。\n    - $\\hat{u}(\\mathbf{k}) = i k_y \\hat{\\psi}(\\mathbf{k})$\n    - $\\hat{v}(\\mathbf{k}) = -i k_x \\hat{\\psi}(\\mathbf{k})$\n    - 速度场 $u(x_i,y_j)$ 和 $v(x_i,y_j)$ 通过逆FFT获得。\n\n5.  **误差分析**：\n    - 在指定环形区域内的每个网格点上，通过将数值速度矢量 $\\mathbf{u}^{\\text{num}}=(u,v)$ 投影到局部方位单位矢量 $\\hat{\\mathbf{\\theta}} = (- (y-L/2)/r, (x-L/2)/r)$ 上，来计算数值方位速度 $u_\\theta^{\\text{num}}$，其中 $r$ 是与域中心的距离。\n    - 通过将 $u_\\theta^{\\text{num}}$ 与点涡的解析解 $u_\\theta^{\\text{exact}}(r) = \\Gamma/(2\\pi r)$ 在环形区域内的所有网格点上进行比较，计算均方根误差 $E(N)$。\n\n6.  **收敛阶**：主要误差来源是“正则化误差”——即高斯斑的速度场与理想点涡速度场之间的差异。对于像高斯分布这样的对称斑点，其一阶矩为零，但二阶矩非零且与 $\\sigma^2$ 成比例，涡方法理论预测，当 $r \\gg \\sigma$ 时，速度误差与 $\\sigma^2$ 成正比。由于 $\\sigma = c h$，误差 $E(N)$ 预计与 $h^2$ 成比例。这意味着收敛阶为 $p=2$。数值实验将通过对 $(\\log h, \\log E(N))$ 进行线性回归来测量此斜率 $p$。其关系为 $\\log E(N) = p \\log h + \\text{常量}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the convergence analysis problem for the stream function-vorticity formulation.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case A: (Gamma, L, N_values, c, alpha, beta)\n        (1.0, 1.0, [32, 64, 128, 256], 2.0, 3.0, 0.25),\n        # Case B: (Gamma, L, N_values, c, alpha, beta)\n        (1.0, 1.0, [32, 64, 128, 256], 0.5, 6.0, 0.2),\n        # Case C: (Gamma, L, N_values, c, alpha, beta)\n        (1.0, 2.0, [32, 64, 128, 256], 1.0, 4.0, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma, L, N_values, c, alpha, beta = case\n        \n        errors = []\n        h_values = []\n\n        for N in N_values:\n            # 1. Grid and Parameters Setup\n            h = L / N\n            sigma = c * h\n            \n            # Create a uniform grid.\n            x = np.arange(N) * h\n            # meshgrid creates coordinates matrices from coordinate vectors.\n            XX, YY = np.meshgrid(x, x, indexing='ij')\n\n            # 2. Vorticity Field Calculation\n            # Compute coordinates relative to the domain center (L/2, L/2).\n            dx = XX - L / 2\n            dy = YY - L / 2\n            r_sq = dx**2 + dy**2\n            \n            # Evaluate the Gaussian vorticity distribution on the grid.\n            omega = (gamma / (2 * np.pi * sigma**2)) * np.exp(-r_sq / (2 * sigma**2))\n\n            # 3. Solve Poisson Equation using FFT\n            # The source term for the periodic Poisson equation must have zero mean.\n            omega_prime = omega - np.mean(omega)\n            omega_hat = np.fft.fft2(omega_prime)\n\n            # Define angular wavenumbers for the spectral method.\n            k = 2 * np.pi * np.fft.fftfreq(N, d=h)\n            kx, ky = np.meshgrid(k, k, indexing='ij')\n            \n            # The Laplacian operator in Fourier space is -|k|^2.\n            K_sq = kx**2 + ky**2\n            \n            # Solve for the stream function in Fourier space.\n            # Avoid division by zero at k=0. The numerator is zero anyway.\n            # np.divide is used here to suppress warnings.\n            psi_hat = np.divide(omega_hat, K_sq, out=np.zeros_like(omega_hat), where=(K_sq!=0))\n            \n            # The mean of the stream function is arbitrary; set to zero.\n            psi_hat[0, 0] = 0\n\n            # 4. Velocity Field Calculation\n            # Compute derivatives in Fourier space by multiplying with ik.\n            u_hat = 1j * ky * psi_hat\n            v_hat = -1j * kx * psi_hat\n\n            # Transform velocity field back to real space.\n            u = np.real(np.fft.ifft2(u_hat))\n            v = np.real(np.fft.ifft2(v_hat))\n\n            # 5. Error Calculation\n            r = np.sqrt(r_sq)\n            \n            # Define the evaluation annulus.\n            r_min = alpha * sigma\n            r_max = beta * L\n            annulus_mask = (r >= r_min) & (r <= r_max)\n\n            # Filter points that are within the annulus.\n            r_annulus = r[annulus_mask]\n            \n            # Project numerical velocity vector onto the local azimuthal direction.\n            u_annulus = u[annulus_mask]\n            v_annulus = v[annulus_mask]\n            dx_annulus = dx[annulus_mask]\n            dy_annulus = dy[annulus_mask]\n            \n            # The azimuthal unit vector is (-dy/r, dx/r) for CCW.\n            u_theta_num = u_annulus * (-dy_annulus / r_annulus) + v_annulus * (dx_annulus / r_annulus)\n            \n            # Analytical velocity for an unbounded point vortex.\n            u_theta_exact = gamma / (2 * np.pi * r_annulus)\n            \n            # Compute the Root-Mean-Square error.\n            error_sq = (u_theta_num - u_theta_exact)**2\n            rms_error = np.sqrt(np.mean(error_sq))\n            \n            errors.append(rms_error)\n            h_values.append(h)\n\n        # 6. Convergence Order Estimation\n        # Perform a linear fit on log-log data to find the slope p.\n        log_h = np.log(h_values)\n        log_E = np.log(errors)\n        \n        p, _ = np.polyfit(log_h, log_E, 1)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "2443769"}, {"introduction": "现实世界中的流体问题很少发生在简单的方形区域内。这个高级练习将向你展示如何利用强大的数学工具来处理复杂的几何边界。我们将运用保形变换，巧妙地将一个物理空间中的波浪状通道映射到一个计算空间中的简单矩形域上。你将在这个矩形域上，采用一种结合了谱方法和有限差分法的混合方法来求解变换后的方程 [@problem_id:2443755]。这个练习完美地展示了如何将优雅的数学变换与高效的数值方法相结合，以解决看似棘手的复杂问题。", "problem": "考虑由流函数-涡量公式建模的稳态、不可压缩、二维粘性流。令物理平面为坐标为 $z = x + i y$ 的复平面，计算平面为坐标为 $\\zeta = \\xi + i \\eta$ 的复平面。给定一个共形映射 $z = f(\\zeta)$，它将计算平面中的矩形 $\\{ (\\xi,\\eta) \\mid 0 \\le \\xi \\le 2\\pi,\\ 0 \\le \\eta \\le H \\}$ 映射到物理平面中的一个波状通道。该映射为\n$$\nf(\\zeta) = \\zeta + i a e^{i \\zeta},\n$$\n其复导数为\n$$\nf'(\\zeta) = 1 - a e^{i \\zeta}.\n$$\n假设 $|a| < 1$，因此 $f$ 在该矩形上是共形且单射的。令物理平面中的流函数为 $\\psi(x,y)$，并定义其在计算平面上的拉回为 $\\Psi(\\xi,\\eta) = \\psi(x(\\xi,\\eta), y(\\xi,\\eta))$。\n\n在流函数-涡量变量下，稳态、不可压缩、二维粘性流由泊松方程控制\n$$\n- \\nabla_{z}^{2} \\psi(x,y) = \\omega(x,y),\n$$\n其中 $\\omega(x,y)$ 是标量涡量，$\\nabla_{z}^{2}$ 是关于物理坐标 $(x,y)$ 的拉普拉斯算子。在共形映射下，拉普拉斯算子根据度量因子 $h(\\xi,\\eta) = |f'(\\zeta)|$ 进行变换，且满足\n$$\n\\nabla_{z}^{2} \\psi(x,y) = \\frac{1}{h(\\xi,\\eta)^{2}} \\nabla_{\\zeta}^{2} \\Psi(\\xi,\\eta).\n$$\n因此，在计算平面中，流函数满足\n$$\n\\nabla_{\\zeta}^{2} \\Psi(\\xi,\\eta) = - h(\\xi,\\eta)^{2} \\, \\omega(x(\\xi,\\eta), y(\\xi,\\eta)).\n$$\n\n边界条件：在底部和顶部边界之间施加一个线性的流函数降，这对应于计算带中的一个恒定体积流率。具体来说，设置\n$$\n\\Psi(\\xi,0) = 0,\\quad \\Psi(\\xi,H) = Q,\n$$\n且在 $\\xi$ 方向上具有周期 $2\\pi$。在无量纲单位中，令 $Q = 1$。定义辅助函数 $B(\\eta) = Q \\, \\eta / H$，使得 $\\Psi(\\xi,\\eta) = \\Phi(\\xi,\\eta) + B(\\eta)$，并且 $\\Phi$ 满足齐次狄利克雷条件 $\\Phi(\\xi,0) = \\Phi(\\xi,H) = 0$ 以及在 $\\xi$ 方向上的周期性。\n\n任务：从上述基本定义和变换出发，在计算平面中实现一个计算求解器，该求解器能够：\n\n- 使用 $N_{\\xi}$ 个在 $[0, 2\\pi)$ 上的等距点和 $N_{\\eta}$ 个在 $[0,H]$ 上的等距点来离散化矩形 $\\{(\\xi,\\eta)\\}$，其中 $N_{\\xi} = 64$ 和 $N_{\\eta} = 65$。\n- 在 $\\xi$ 方向上使用傅里叶谱方法离散（快速傅里叶变换 (FFT)），在 $\\eta$ 方向上使用二阶中心有限差分法离散，以求解\n$$\n\\frac{\\partial^{2} \\Phi}{\\partial \\xi^{2}} + \\frac{\\partial^{2} \\Phi}{\\partial \\eta^{2}} = - h(\\xi,\\eta)^{2}\\, \\omega(x(\\xi,\\eta), y(\\xi,\\eta)),\n$$\n其中 $\\eta = 0$ 和 $\\eta = H$ 上为齐次狄利克雷条件，在 $\\xi$ 方向上具有周期性。\n- 在求解出 $\\Phi$ 后，重构 $\\Psi = \\Phi + B$。\n- 通过计算残差\n$$\n\\mathcal{R}(\\xi,\\eta) = \\frac{1}{h(\\xi,\\eta)^{2}} \\left( \\frac{\\partial^{2} \\Psi}{\\partial \\xi^{2}} + \\frac{\\partial^{2} \\Psi}{\\partial \\eta^{2}} \\right) + \\omega(x(\\xi,\\eta), y(\\xi,\\eta)),\n$$\n来验证解，并报告内部网格点 $\\{ (\\xi_{i}, \\eta_{j}) \\mid i \\in \\{0,\\dots,N_{\\xi}-1\\},\\ j \\in \\{1,\\dots,N_{\\eta}-2\\} \\}$ 上 $\\mathcal{R}$ 的最大绝对值。\n\n在测试套件中，使用物理平面中的以下涡量场 $\\omega(x,y)$，每个都以无量纲单位表示，并默认 $x$ 是 $2\\pi$ 周期的：\n\n- 情况 A: $a = 0$, $H = 1$, $\\omega(x,y) = 0$。\n- 情况 B: $a = 0$, $H = 1$, $\\omega(x,y) = \\sin(x) \\sin(\\pi y)$。\n- 情况 C: $a = 0.15$, $H = 1$, $\\omega(x,y) = 0$。\n- 情况 D: $a = 0.15$, $H = 1$, $\\omega(x,y) = \\sin(x) \\sin(\\pi y)$。\n- 情况 E: $a = 0.30$, $H = 2$, $\\omega(x,y) = \\cos(2 x) \\sin\\!\\left(\\pi y / H\\right)$。\n\n你的程序必须：\n\n- 实现共形映射 $f(\\zeta) = \\zeta + i a e^{i \\zeta}$ 及其导数 $f'(\\zeta)$，以在计算网格上计算 $x(\\xi,\\eta)$、$y(\\xi,\\eta)$ 和 $h(\\xi,\\eta) = |f'(\\zeta)|$。\n- 对每种情况，在计算平面中求解泊松问题并评估残差 $\\mathcal{R}$。\n- 对每种情况，计算一个等于内部网格点上最大绝对残差的浮点数。\n\n最终输出格式：你的程序应该生成单行输出，其中包含五个结果，形式为方括号内的逗号分隔列表，每个浮点数都格式化为小数点后六位的科学记数法（例如，$[1.234567\\mathrm{e}{-04},2.000000\\mathrm{e}{-06},\\dots]$）。不应打印任何其他输出。\n\n所有量都是无量纲的，因此不需要物理单位，除了周期性的 $\\xi$ 坐标（其根据构造以弧度为单位）外，没有其他角度。正确性的标准是残差值的微小程度。测试套件为：\n\n- 情况 A: $(a,H,\\omega) = (0,1,\\text{零})$。\n- 情况 B: $(a,H,\\omega) = (0,1,\\sin(x)\\sin(\\pi y))$。\n- 情况 C: $(a,H,\\omega) = (0.15,1,\\text{零})$。\n- 情况 D: $(a,H,\\omega) = (0.15,1,\\sin(x)\\sin(\\pi y))$。\n- 情况 E: $(a,H,\\omega) = (0.30,2,\\cos(2x)\\sin(\\pi y/H))$。\n\n你的代码必须是完全自包含的，且不得读取任何输入。它必须实现上述算法，并按指定格式输出所需的单行结果。", "solution": "问题陈述已经过仔细审查，并被认定为有效。这是一个计算物理学中的适定问题，其基础是流体动力学和数值分析的既定原理。所提供的参数和条件是完整、一致且科学合理的。因此，我们将着手进行求解。\n\n目标是在计算矩形 $\\{(\\xi,\\eta) \\mid 0 \\le \\xi < 2\\pi, 0 \\le \\eta \\le H \\}$ 中求解流函数 $\\Psi(\\xi,\\eta)$。控制方程是通过共形映射 $z=f(\\zeta)$ 从物理流函数-涡量公式推导出的泊松方程：\n$$\n\\nabla_{\\zeta}^{2} \\Psi(\\xi,\\eta) = -h(\\xi,\\eta)^{2} \\, \\omega(x(\\xi,\\eta), y(\\xi,\\eta))\n$$\n其中 $\\nabla_{\\zeta}^{2} = \\frac{\\partial^2}{\\partial \\xi^2} + \\frac{\\partial^2}{\\partial \\eta^2}$ 是计算坐标系中的拉普拉斯算子，$h(\\xi,\\eta) = |f'(\\zeta)|$ 是映射的度量因子，而 $\\omega$ 是物理涡量场。\n\n边界条件在 $\\xi$ 方向上是周期的，在 $\\eta$ 方向上是狄利克雷的：$\\Psi(\\xi,0) = 0$ 和 $\\Psi(\\xi,H) = Q$。为了处理非齐次狄利克雷条件，我们将流函数分解为 $\\Psi(\\xi,\\eta) = \\Phi(\\xi,\\eta) + B(\\eta)$，其中 $B(\\eta) = Q \\eta / H$。函数 $\\Phi$ 随后必须满足齐次狄利克雷条件 $\\Phi(\\xi,0) = 0$ 和 $\\Phi(\\xi,H) = 0$，并在 $\\xi$ 方向上保持周期性。由于 $B(\\eta)$ 在 $\\eta$ 上是线性的，其拉普拉斯算子为零，即 $\\nabla_{\\zeta}^{2} B(\\eta) = d^2B/d\\eta^2 = 0$。因此，问题简化为求解关于 $\\Phi$ 的以下泊松方程：\n$$\n\\frac{\\partial^{2} \\Phi}{\\partial \\xi^{2}} + \\frac{\\partial^{2} \\Phi}{\\partial \\eta^{2}} = -h(\\xi,\\eta)^{2} \\, \\omega(x(\\xi,\\eta), y(\\xi,\\eta)) \\equiv F(\\xi,\\eta)\n$$\n在计算域上，使用齐次边界条件。\n\n采用一种混合数值方法，利用边界条件的性质。$\\xi$ 方向的周期性表明可以使用基于傅里叶级数表示的谱方法：\n$$\n\\Phi(\\xi,\\eta) = \\sum_{k=-\\infty}^{\\infty} \\hat{\\Phi}_k(\\eta) e^{ik\\xi}\n$$\n其中 $k$ 是整数波数。将此展开式代入 $\\Phi$ 的泊松方程，可将偏微分方程解耦为一组独立的常微分方程 (ODEs)，每个波数 $k$ 对应一个：\n$$\n\\frac{d^2 \\hat{\\Phi}_k}{d\\eta^2} - k^2 \\hat{\\Phi}_k(\\eta) = \\hat{F}_k(\\eta)\n$$\n此处，$\\hat{\\Phi}_k(\\eta)$ 和 $\\hat{F}_k(\\eta)$ 分别是 $\\Phi(\\xi,\\eta)$ 和 $F(\\xi,\\eta)$ 关于 $\\xi$ 的傅里叶系数。对于所有的 $k$，$\\Phi$ 的边界条件变换为 $\\hat{\\Phi}_k(0) = 0$ 和 $\\hat{\\Phi}_k(H) = 0$。\n\n数值求解过程如下：\n首先，将计算域离散化为 $N_\\xi \\times N_\\eta$ 个点的网格，$(\\xi_i, \\eta_j)$，其中 $\\xi_i = i (2\\pi/N_\\xi)$ 对于 $i \\in \\{0, \\dots, N_\\xi-1\\}$，$\\eta_j = j(H/(N_\\eta-1))$ 对于 $j \\in \\{0, \\dots, N_\\eta-1\\}$。在此网格上，我们计算物理坐标 $(x_{ij}, y_{ij})$、度量因子 $h_{ij}$ 以及方程右侧函数 $F_{ij}$。\n\n其次，对于每个对应固定 $\\eta_j$ 的网格行，使用快速傅里叶变换 (FFT) 算法将右侧的离散形式 $F_{ij}$ 变换到傅里叶空间，得到离散傅里叶系数 $\\hat{F}_{k,j}$。\n\n第三，对于每个离散波数 $k$，使用二阶中心有限差分格式在内部网格点 $j \\in \\{1, \\dots, N_\\eta-2\\}$ 上对 $\\eta$ 方向进行离散化：\n$$\n\\frac{\\hat{\\Phi}_{k,j+1} - 2\\hat{\\Phi}_{k,j} + \\hat{\\Phi}_{k,j-1}}{(\\Delta\\eta)^2} - k^2 \\hat{\\Phi}_{k,j} = \\hat{F}_{k,j}\n$$\n其中 $\\Delta\\eta = H/(N_\\eta-1)$ 是 $\\eta$ 方向的网格间距。这个近似与边界条件 $\\hat{\\Phi}_{k,0} = 0$ 和 $\\hat{\\Phi}_{k,N_\\eta-1} = 0$ 相结合，形成一个关于未知向量 $(\\hat{\\Phi}_{k,1}, \\dots, \\hat{\\Phi}_{k,N_\\eta-2})^T$ 的线性代数方程组。该系统的系数矩阵是三对角的、对称的且对角占优的，这保证了唯一解的存在，并允许使用带状矩阵求解器进行高效求解。\n\n第四，在求解所有波数 $k$ 的三对角系统后，我们获得了傅里叶系数 $\\hat{\\Phi}_{k,j}$ 的完整网格。然后对每一行（固定的 $j$）应用逆 FFT，将解变换回计算空间域，得到 $\\Phi_{ij}$ 的离散解。\n\n第五，通过加上线性背景流来重构完整的流函数：$\\Psi_{ij} = \\Phi_{ij} + B(\\eta_j)$。\n\n最后，为验证实现的正确性，计算残差 $\\mathcal{R}$：\n$$\n\\mathcal{R}(\\xi,\\eta) = \\frac{1}{h(\\xi,\\eta)^{2}} \\left( \\frac{\\partial^{2} \\Psi}{\\partial \\xi^{2}} + \\frac{\\partial^{2} \\Psi}{\\partial \\eta^{2}} \\right) + \\omega(x(\\xi,\\eta), y(\\xi,\\eta))\n$$\n拉普拉斯算子 $\\nabla_\\zeta^2 \\Psi$ 中的导数采用与求解器一致的方式进行数值计算：$\\xi$ 方向的导数通过 FFT 进行谱方法计算，而 $\\eta$ 方向的导数使用二阶中心有限差分计算。在所有内部网格点上，该残差的最大绝对值可作为衡量解精度的稳健指标。对于正确的实现，其期望值是一个很小的数，在有解析解的情况下接近机器精度，否则受离散误差的限制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    N_xi = 64\n    N_eta = 65\n    Q = 1.0\n\n    test_cases = [\n        # Case A: (a, H, omega_func)\n        (0.0, 1.0, lambda x, y, H: 0.0),\n        # Case B\n        (0.0, 1.0, lambda x, y, H: np.sin(x) * np.sin(np.pi * y)),\n        # Case C\n        (0.15, 1.0, lambda x, y, H: 0.0),\n        # Case D\n        (0.15, 1.0, lambda x, y, H: np.sin(x) * np.sin(np.pi * y)),\n        # Case E\n        (0.30, 2.0, lambda x, y, H: np.cos(2 * x) * np.sin(np.pi * y / H)),\n    ]\n\n    results = []\n    for a, H, omega_func in test_cases:\n        residual = solve_poisson_case(a, H, omega_func, N_xi, N_eta, Q)\n        results.append(f\"{residual:.6e}\")\n    \n    print(f\"[{','.join(results)}]\")\n\ndef solve_poisson_case(a, H, omega_func, N_xi, N_eta, Q):\n    \"\"\"\n    Solves the Poisson equation for a single test case.\n    \n    Returns:\n        float: The maximum absolute residual over the interior grid points.\n    \"\"\"\n    # 1. Grid and coordinate setup\n    xi = np.linspace(0, 2 * np.pi, N_xi, endpoint=False)\n    eta = np.linspace(0, H, N_eta, endpoint=True)\n    delta_xi = 2 * np.pi / N_xi\n    delta_eta = H / (N_eta - 1)\n    \n    XI, ETA = np.meshgrid(xi, eta, indexing='xy') # (N_eta, N_xi) arrays\n\n    # 2. Conformal map, physical coordinates, and metric factor\n    ZETA = XI + 1j * ETA\n    Z = ZETA + 1j * a * np.exp(1j * ZETA)\n    X, Y = Z.real, Z.imag\n    \n    dZ_dZETA = 1 - a * np.exp(1j * ZETA)\n    h_sq = np.abs(dZ_dZETA)**2\n    \n    # 3. Right-hand side of the Poisson equation for Phi\n    omega = omega_func(X, Y, H)\n    F = -h_sq * omega\n    \n    # 4. Forward FFT of the RHS\n    F_hat = np.fft.fft(F, axis=1)\n    \n    # 5. Solve tridiagonal systems in Fourier space\n    k_vec = np.fft.fftfreq(N_xi) * N_xi # Integer wavenumbers\n    Phi_hat = np.zeros_like(F_hat, dtype=np.complex128)\n    \n    num_interior_eta = N_eta - 2\n    if num_interior_eta > 0:\n        # Construct the banded matrix diagonals\n        ab = np.zeros((3, num_interior_eta), dtype=float)\n        ab[0, 1:] = 1.0 / delta_eta**2  # Super-diagonal\n        ab[2, :-1] = 1.0 / delta_eta**2  # Sub-diagonal\n        \n        for k_idx, k in enumerate(k_vec):\n            # Main diagonal depends on wavenumber k\n            ab[1, :] = -(k**2 + 2.0 / delta_eta**2)\n            \n            # RHS vector for this wavenumber\n            RHS_k = F_hat[1:-1, k_idx]\n            \n            # Solve the banded system\n            sol = solve_banded((1, 1), ab, RHS_k)\n            Phi_hat[1:-1, k_idx] = sol\n            \n    # 6. Inverse FFT to find Phi\n    Phi = np.fft.ifft(Phi_hat, axis=1).real\n    \n    # 7. Reconstruct the full stream function Psi\n    B = Q * ETA / H\n    Psi = Phi + B\n    \n    # 8. Compute the residual to verify the solution\n    # d^2(Psi)/d(xi)^2 using spectral differentiation\n    Psi_hat = np.fft.fft(Psi, axis=1)\n    d2Psi_dxi2_hat = -(k_vec**2) * Psi_hat\n    d2Psi_dxi2 = np.fft.ifft(d2Psi_dxi2_hat, axis=1).real\n    \n    # d^2(Psi)/d(eta)^2 using second-order centered finite differences\n    d2Psi_deta2 = np.zeros_like(Psi)\n    d2Psi_deta2[1:-1, :] = (Psi[2:, :] - 2*Psi[1:-1, :] + Psi[:-2, :]) / delta_eta**2\n    \n    # Laplacian in computational coordinates\n    Laplacian_Psi = d2Psi_dxi2 + d2Psi_deta2\n    \n    # Residual: R = (1/h^2) * Laplacian(Psi) + omega\n    Residual = Laplacian_Psi / h_sq + omega\n    \n    # Maximum absolute residual over interior points\n    max_abs_residual = np.max(np.abs(Residual[1:-1, :]))\n    \n    return max_abs_residual\n\nsolve()\n```", "id": "2443755"}]}