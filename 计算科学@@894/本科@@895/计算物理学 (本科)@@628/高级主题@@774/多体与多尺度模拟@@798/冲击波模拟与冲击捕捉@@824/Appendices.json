{"hands_on_practices": [{"introduction": "评估激波捕捉格式时，仅仅目测激波的尖锐度是不够的，因为它具有主观性。本练习 [@problem_id:1761739] 引入了一个定量的“梯度加权展宽”度量，让你能够客观地比较不同数值格式在处理不连续性时产生的数值扩散。通过这个实践，你将学会如何量化一个关键的数值误差来源，并加深对激波模拟保真度的理解。", "problem": "一位计算流体动力学 (CFD) 工程师正在分析两种不同数值格式在捕捉激波方面的性能。测试算例涉及空间域 $x \\in [0, 2]$ 上的一维无粘伯格斯方程 $\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2}u^2\\right) = 0$。时刻 $t=0$ 的初始条件为一个阶跃间断，描述为当 $x  0.5$ 时 $u(x,0) = 2$，当 $x \\ge 0.5$ 时 $u(x,0) = 1$。\n\n模拟运行至最终时刻 $t_f$，此时其精确解为位于 $x_s = 1.1$ 处的单个激波。从格式 A 和格式 B 获得的数值解，虽然捕捉到了激波，但表现出不同程度的数值耗散，这会使间断变得模糊。该工程师发现，所得的数值剖面可以用以下解析函数精确建模：\n\n- 格式 A 剖面：$u_A(x) = 1.5 - 0.5 \\tanh\\left(\\frac{x - 1.1}{W_A}\\right)$，宽度参数 $W_A = 0.0125$。\n- 格式 B 剖面：$u_B(x) = 1.5 - 0.5 \\tanh\\left(\\frac{x - 1.1}{W_B}\\right)$，宽度参数 $W_B = 0.0075$。\n\n为了定量比较这种作为数值耗散表现的模糊效应，该工程师定义了一个“梯度加权展宽”度量 $M$，由下式给出：\n$$M = \\int_{0}^{2} (x - x_s)^2 \\left| \\frac{du}{dx} \\right| dx$$\n鉴于激波剖面高度局域化在 $x_s = 1.1$ 附近，将积分限从 $[0, 2]$ 扩展到 $(-\\infty, \\infty)$ 所引入的误差可以忽略不计。为了方便您的计算，您可以使用以下标准定积分恒等式：\n$$\\int_{-\\infty}^{\\infty} y^2 \\operatorname{sech}^2(y) dy = \\frac{\\pi^2}{6}$$\n\n计算两种格式的梯度加权展宽之比 $M_A / M_B$。将最终答案四舍五入到三位有效数字。", "solution": "我们用通用剖面 $u(x)=1.5-0.5\\,\\tanh\\!\\left(\\frac{x-x_{s}}{W}\\right)$ 来处理这两种格式，其中 $W=W_{A}$ 或 $W_{B}$，且 $x_{s}=1.1$。梯度加权展宽为\n$$\nM=\\int_{0}^{2}(x-x_{s})^{2}\\left|\\frac{du}{dx}\\right|dx.\n$$\n由于剖面局域化在 $x_{s}$ 附近，我们可以将积分限扩展到 $(-\\infty,\\infty)$ 而不会产生显著误差：\n$$\nM=\\int_{-\\infty}^{\\infty}(x-x_{s})^{2}\\left|\\frac{du}{dx}\\right|dx.\n$$\n使用 $\\frac{d}{dx}\\tanh(z)=\\operatorname{sech}^{2}(z)\\,\\frac{dz}{dx}$ 对 $u(x)$ 求导：\n$$\n\\frac{du}{dx}=-0.5\\,\\operatorname{sech}^{2}\\!\\left(\\frac{x-x_{s}}{W}\\right)\\cdot\\frac{1}{W}.\n$$\n因此\n$$\n\\left|\\frac{du}{dx}\\right|=\\frac{0.5}{W}\\,\\operatorname{sech}^{2}\\!\\left(\\frac{x-x_{s}}{W}\\right).\n$$\n代入 $y=\\frac{x-x_{s}}{W}$，可得 $x-x_{s}=Wy$ 和 $dx=W\\,dy$。那么\n$$\nM=\\int_{-\\infty}^{\\infty}(Wy)^{2}\\left(\\frac{0.5}{W}\\operatorname{sech}^{2}(y)\\right)W\\,dy\n=\\frac{1}{2}W^{2}\\int_{-\\infty}^{\\infty}y^{2}\\operatorname{sech}^{2}(y)\\,dy.\n$$\n使用给定的恒等式 $\\int_{-\\infty}^{\\infty}y^{2}\\operatorname{sech}^{2}(y)\\,dy=\\frac{\\pi^{2}}{6}$，我们得到\n$$\nM=\\frac{\\pi^{2}}{12}W^{2}.\n$$\n因此，对于这两种格式，\n$$\n\\frac{M_{A}}{M_{B}}=\\left(\\frac{W_{A}}{W_{B}}\\right)^{2}\n=\\left(\\frac{0.0125}{0.0075}\\right)^{2}\n=\\left(\\frac{5}{3}\\right)^{2}\n=\\frac{25}{9}\\approx 2.78,\n$$\n结果四舍五入到三位有效数字。", "answer": "$$\\boxed{2.78}$$", "id": "1761739"}, {"introduction": "对于非线性守恒律，并非所有间断解都是物理上允许的；只有满足“熵条件”的激波才是真实的。本练习 [@problem_id:2448972] 要求你为一个模型方程（伯格斯方程）实现一个求解器，并计算数值熵的产生率。这个实践将帮助你理解如何通过编程来验证一个数值格式是否符合基本的物理原理，这是区分物理真实解与非物理数值伪影的关键。", "problem": "考虑周期性区域 $[0,1]$ 上的一维标量守恒律，\n$$\n\\partial_t u(x,t) + \\partial_x f\\big(u(x,t)\\big) = 0,\n$$\n其通量为 $f(u) = \\tfrac{1}{2}u^2$ (无粘伯格斯方程)。设初始条件为 $u(x,0) = \\sin(2\\pi x)$，适用于所有 $x \\in [0,1]$。该区域被均匀划分为 $N_x$ 个单元，单元宽度为 $\\Delta x = 1/N_x$。用 $u_i^n$ 表示在单元索引 $i \\in \\{0,1,\\dots,N_x-1\\}$ 和时间层 $t^n$ 处 $u$ 的单元平均近似，并采用周期性边界条件。其演化通过一个守恒型有限体积更新来计算：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right),\n$$\n其中 $F_{i+\\tfrac{1}{2}}^n$ 是一个相容的数值通量，使用左右界面状态 $u_L = u_i^n$ 和 $u_R = u_{i+1}^n$（采用周期性索引）在单元 $i$ 和 $i+1$ 之间的界面处进行计算。将使用两种不同的数值通量选择：\n\n- 选择 A (无粘伯格斯方程的精确黎曼求解器通量)：对于 $u_L \\le u_R$ (稀疏波情况)，\n$$\nF_{i+\\tfrac{1}{2}}^n =\n\\begin{cases}\n\\tfrac{1}{2}u_L^2,  \\text{若 } u_L \\ge 0,\\\\\n\\tfrac{1}{2}u_R^2,  \\text{若 } u_R \\le 0,\\\\\n0,  \\text{若 } u_L  0  u_R,\n\\end{cases}\n$$\n对于 $u_L > u_R$ (激波情况)，其激波速度为 $s = \\dfrac{f(u_R) - f(u_L)}{u_R - u_L} = \\dfrac{u_L + u_R}{2}$,\n$$\nF_{i+\\tfrac{1}{2}}^n =\n\\begin{cases}\n\\tfrac{1}{2}u_L^2,  \\text{若 } s \\ge 0,\\\\\n\\tfrac{1}{2}u_R^2,  \\text{若 } s  0.\n\\end{cases}\n$$\n\n- 选择 B (两步预估-校正中心格式)：定义界面预估状态\n$$\nu_{i+\\tfrac{1}{2}}^{n+\\tfrac{1}{2}} = \\tfrac{1}{2}\\left(u_i^n + u_{i+1}^n\\right) - \\tfrac{\\Delta t}{2\\Delta x}\\left(f(u_{i+1}^n) - f(u_i^n)\\right),\n$$\n然后更新\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(f\\Big(u_{i+\\tfrac{1}{2}}^{n+\\tfrac{1}{2}}\\Big) - f\\Big(u_{i-\\tfrac{1}{2}}^{n+\\tfrac{1}{2}}\\Big)\\right).\n$$\n\n对于时间步进，使用一个显式时间步 $\\Delta t$，它满足给定数值 $\\lambda \\in (0,1)$ 的 Courant-Friedrichs-Lewy (CFL) 条件，\n$$\n\\Delta t = \\lambda \\frac{\\Delta x}{\\max_i |u_i^n|},\n$$\n并约定如果 $\\max_i |u_i^n| = 0$，则 $\\Delta t = \\lambda \\Delta x$。\n\n定义凸熵和相应的熵通量为\n$$\n\\eta(u) = \\tfrac{1}{2}u^2, \\qquad q(u) = \\tfrac{1}{3}u^3.\n$$\n对于周期性区域，定义在时间层 $n$ 的离散总熵为\n$$\nE^n = \\sum_{i=0}^{N_x-1}\\eta(u_i^n)\\,\\Delta x.\n$$\n对于一个最终时间 $T > 0$，定义在 $[0,T]$ 上的平均数值熵产生率为\n$$\n\\Pi = \\frac{E^0 - E^N}{T},\n$$\n其中 $t^N \\approx T$ 是最终数值时间，$E^N$ 是最终离散熵。同时定义一个熵增计数器\n$$\nC = \\#\\left\\{n \\in \\{0,1,\\dots,N-1\\} \\,\\middle|\\, E^{n+1} - E^n > \\tau \\right\\},\n$$\n容差为 $\\tau = 10^{-12}$。\n\n请实现一个程序，对下方测试套件中每个指定的参数集，使用有限体积法和指定的通量选择，从周期性边界条件下的 $[0,1]$ 上的初始条件 $u(x,0) = \\sin(2\\pi x)$ 开始，使用上述定义的自适应 $\\Delta t$ 进行时间推进，直到达到时间 $T$（裁剪最后一步以使最终时间恰好等于 $T$），计算出数对 $[\\Pi, C]$。输出必须按如下规定进行汇总。\n\n测试套件 (每个条目是一个元组 $(\\text{flux\\_choice}, N_x, \\lambda, T)$)：\n- 测试 1：$(\\text{\"A\"}, 400, 0.9, 0.30)$。\n- 测试 2：$(\\text{\"B\"}, 400, 0.9, 0.30)$。\n- 测试 3：$(\\text{\"A\"}, 400, 0.9, 0.05)$。\n- 测试 4：$(\\text{\"B\"}, 100, 0.9, 0.30)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个结果本身是一个双元素列表 $[\\Pi, C]$，其顺序与测试套件中的顺序相同，例如：\n$[[\\Pi_1,C_1],[\\Pi_2,C_2],[\\Pi_3,C_3],[\\Pi_4,C_4]]$。", "solution": "目标是通过测量数值熵产生来探究无粘伯格斯方程中数值激波捕捉的物理正确性。我们从第一性原理出发：弱解的守恒律和熵不等式，然后构建守恒型有限体积离散格式，最后为熵行为定义一个可测量的诊断标准。\n\n- 守恒律和通量。模型是\n$$\n\\partial_t u + \\partial_x f(u) = 0, \\quad f(u) = \\tfrac{1}{2}u^2.\n$$\n对于足够光滑的 $u$，守恒律意味着周期性区域上任意凸熵 $\\eta(u)$ 的积分演化遵循\n$$\n\\partial_t \\eta(u) + \\partial_x q(u) = 0, \\quad q'(u) = \\eta'(u) f'(u),\n$$\n对于 $\\eta(u) = \\tfrac{1}{2}u^2$ 我们有 $q(u) = \\tfrac{1}{3}u^3$。对于包含不连续性（激波）的 $u$，物理上可接受的弱解满足熵不等式\n$$\n\\partial_t \\eta(u) + \\partial_x q(u) \\le 0,\n$$\n因此，在周期性边界条件下，总熵 $\\int_0^1 \\eta(u)\\,dx$ 必须随时间非增。\n\n- 有限体积离散化。我们将区域离散为 $N_x$ 个宽度为 $\\Delta x = 1/N_x$ 的均匀单元。令 $u_i^n$ 表示单元 $i$ 在时间层 $n$ 的单元平均值。守恒型更新为\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right),\n$$\n其中 $F_{i+\\tfrac{1}{2}}^n$ 是一个关于相邻状态 $u_L = u_i^n$ 和 $u_R = u_{i+1}^n$ 的相容数值通量函数。周期性边界条件通过模 $N_x$ 的索引来强制执行。\n\n考虑两种通量构造方法：\n\n1. 无粘伯格斯方程的精确黎曼求解器通量 (选择 A)。具有初始左右状态 $(u_L,u_R)$ 的黎曼问题，其解要么是稀疏波 ($u_L \\le u_R$)，要么是激波 ($u_L > u_R$)。对于伯格斯方程，Godunov 通量可以显式写出。在稀疏波情况下，\n$$\nF(u_L,u_R) =\n\\begin{cases}\n\\tfrac{1}{2}u_L^2,  \\text{若 } u_L \\ge 0,\\\\\n\\tfrac{1}{2}u_R^2,  \\text{若 } u_R \\le 0,\\\\\n0,  \\text{若 } u_L  0  u_R,\n\\end{cases}\n$$\n在激波情况下，激波速度为 $s = \\dfrac{u_L + u_R}{2}$，从而得到\n$$\nF(u_L,u_R) =\n\\begin{cases}\n\\tfrac{1}{2}u_L^2,  \\text{若 } s \\ge 0,\\\\\n\\tfrac{1}{2}u_R^2,  \\text{若 } s  0.\n\\end{cases}\n$$\n对于凸的 $f$，此通量是单调且满足熵条件的。\n\n2. 两步预估-校正中心格式 (选择 B)。Richtmyer 两步 Lax–Wendroff 方法通过中点重构和通量差分来形成界面预估状态，\n$$\nu_{i+\\tfrac{1}{2}}^{n+\\tfrac{1}{2}} = \\tfrac{1}{2}\\left(u_i^n + u_{i+1}^n\\right) - \\tfrac{\\Delta t}{2\\Delta x}\\left(f(u_{i+1}^n) - f(u_i^n)\\right),\n$$\n然后使用在这些预估状态下计算的物理通量 $f$ 进行守恒更新，\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(f\\Big(u_{i+\\tfrac{1}{2}}^{n+\\tfrac{1}{2}}\\Big) - f\\Big(u_{i-\\tfrac{1}{2}}^{n+\\tfrac{1}{2}}\\Big)\\right).\n$$\n该方法对光滑解具有二阶精度，但非单调，并且可能在激波附近产生色散振荡，从而可能在局部时间上违反熵不等式。\n\n- 时间步进与稳定性。对于显式格式，Courant-Friedrichs-Lewy (CFL) 条件限制了时间步长。对于波速为 $a(u)=f'(u)=u$ 的伯格斯方程，一个安全的自适应时间步长是\n$$\n\\Delta t = \\lambda \\frac{\\Delta x}{\\max_i |u_i^n|},\n$$\n其中 $\\lambda \\in (0,1)$ 是一个预设值。如果 $\\max_i |u_i^n|=0$，我们使用 $\\Delta t = \\lambda \\Delta x$。为匹配预设的最终时间 $T$，最后的时间步会被裁剪，使得 $t^{n+1} = T$ 精确成立。\n\n- 离散熵诊断。定义离散总熵\n$$\nE^n = \\sum_{i=0}^{N_x-1} \\eta(u_i^n)\\,\\Delta x, \\quad \\eta(u) = \\tfrac{1}{2}u^2.\n$$\n对于周期性区域上的光滑精确解，$E(t)$ 是常数；当激波形成时，$E(t)$ 是非增的。一个作为激波捕捉方法在物理上正确的离散格式，除了可能在数值容差范围内，不应增加 $E^n$。我们测量：\n1. 在 $[0,T]$ 上的平均数值熵产生率，\n$$\n\\Pi = \\frac{E^0 - E^N}{T},\n$$\n在激波形成前，该值应接近 $0$；在激波发展后，该值应为正。\n2. 一个熵增计数器\n$$\nC = \\#\\big\\{ n \\,\\big|\\, E^{n+1} - E^n  \\tau \\big\\},\n$$\n其阈值设为一个较小的值 $\\tau = 10^{-12}$，用于统计总熵增加超过数值舍入误差的时间步数。对于满足熵条件的方法，$C$ 应为 $0$ 或非常小；对于激波附近的非单调方法，$C$ 可能为正。\n\n- 初始条件和激波形成时间。对于初始条件 $u(x,0) = \\sin(2\\pi x)$，解在第一个激波形成时间之前保持光滑，激波形成时间为\n$$\nt_s = \\frac{1}{\\max_x \\big(-\\partial_x u(x,0)\\big)} = \\frac{1}{2\\pi}.\n$$\n因此，$T = 0.05$ 是在激波形成之前，而 $T = 0.30$ 是在激波发展之后。\n\n- 对于给定测试用例 $(\\text{flux\\_choice}, N_x, \\lambda, T)$ 计算 $[\\Pi, C]$ 的算法步骤如下：\n1. 初始化一个包含 $N_x$ 个单元的均匀网格，采用周期性索引，并设置 $u_i^0 = \\sin\\big(2\\pi x_i\\big)$，其中 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$。\n2. 设置 $t^0 = 0$，计算 $E^0 = \\sum_i \\tfrac{1}{2}(u_i^0)^2 \\Delta x$，并设置 $C=0$。\n3. 当 $t^n  T$ 时，计算 $\\Delta t = \\lambda \\Delta x/\\max_i |u_i^n|$ (如果最大值为零则为 $\\lambda \\Delta x$) 并进行裁剪，使得 $t^{n+1} = \\min\\{t^n + \\Delta t, T\\}$，其中使用的 $\\Delta t = t^{n+1} - t^n$。\n4. 使用选择 A 或选择 B 的数值通量/界面更新方法计算 $u^{n+1}$。\n5. 计算 $E^{n+1} = \\sum_i \\tfrac{1}{2}(u_i^{n+1})^2 \\Delta x$，如果 $E^{n+1} - E^n  \\tau$ (其中 $\\tau = 10^{-12}$)，则将 $C$ 加一。\n6. 设置 $n \\leftarrow n+1$ 并重复。\n7. 最后，报告 $\\Pi = (E^0 - E^N)/T$ 和 $C$。\n\n- 测试套件覆盖范围。这四个参数集探究了：\n  - 一个激波后状态，使用单调、满足熵条件的通量 (选择 A, $N_x=400$, $\\lambda=0.9$, $T=0.30$)，预期会产生正的 $\\Pi$ 和接近 $0$ 的 $C$。\n  - 一个激波后状态，使用非单调的中心方法 (选择 B, $N_x=400$, $\\lambda=0.9$, $T=0.30$)，该方法可能表现出振荡并产生正的 $C$。\n  - 一个激波前状态 (选择 A, $N_x=400$, $\\lambda=0.9$, $T=0.05$)，预期会产生接近 $0$ 的 $\\Pi$ 和较小的 $C$。\n  - 在激波后状态使用较粗的网格和中心方法 (选择 B, $N_x=100$, $\\lambda=0.9$, $T=0.30$)，这会增强色散效应并可能增加 $C$。\n\n程序必须按以下格式输出一行包含结果列表的单行文本\n$$\n\\big[ [\\Pi_1, C_1], [\\Pi_2, C_2], [\\Pi_3, C_3], [\\Pi_4, C_4] \\big].\n$$", "answer": "```python\nimport numpy as np\n\ndef flux_burgers(u):\n    return 0.5 * u * u\n\ndef godunov_flux_array(u):\n    \"\"\"\n    Compute Godunov fluxes F_{i+1/2} for Burgers' equation on a periodic grid.\n    u: array of cell averages u_i\n    returns array F of size N with F[i] = flux at interface between i and i+1\n    \"\"\"\n    ul = u\n    ur = np.roll(u, -1)\n    f_ul = 0.5 * ul * ul\n    f_ur = 0.5 * ur * ur\n    F = np.empty_like(u)\n\n    # Rarefaction case: ul = ur\n    rare = ul = ur\n    # Subcases for rarefaction\n    cond1 = rare  (ul >= 0)\n    cond2 = rare  (ur = 0)\n    cond3 = rare  (ul  0)  (ur > 0)\n\n    F[cond1] = f_ul[cond1]\n    F[cond2] = f_ur[cond2]\n    F[cond3] = 0.0\n\n    # Shock case: ul > ur\n    shock = ~rare\n    s = 0.5 * (ul + ur)  # shock speed\n    cond4 = shock  (s >= 0)\n    cond5 = shock  (s  0)\n    F[cond4] = f_ul[cond4]\n    F[cond5] = f_ur[cond5]\n\n    return F\n\ndef step_choice_A(u, dt, dx):\n    \"\"\"One FV step with Godunov flux (Choice A).\"\"\"\n    F = godunov_flux_array(u)\n    return u - (dt / dx) * (F - np.roll(F, 1))\n\ndef step_choice_B(u, dt, dx):\n    \"\"\"One FV step with Richtmyer two-step Lax-Wendroff (Choice B).\"\"\"\n    f_u = flux_burgers(u)\n    u_iphalf = 0.5 * (u + np.roll(u, -1)) - 0.5 * (dt / dx) * (np.roll(f_u, -1) - f_u)\n    f_half = flux_burgers(u_iphalf)\n    return u - (dt / dx) * (f_half - np.roll(f_half, 1))\n\ndef run_case(choice, Nx, CFL, T, tau=1e-12):\n    # Grid and initial condition u(x,0) = sin(2*pi*x) sampled at cell centers\n    x = (np.arange(Nx) + 0.5) / Nx\n    u = np.sin(2.0 * np.pi * x).astype(float)\n    dx = 1.0 / Nx\n    t = 0.0\n\n    # Initial entropy\n    E0 = 0.5 * np.sum(u * u) * dx\n    E_prev = E0\n    C_increase = 0\n\n    # Time stepping loop\n    while t  T - 1e-15:\n        max_speed = np.max(np.abs(u))\n        if max_speed  1e-14:\n            dt = CFL * dx\n        else:\n            dt = CFL * dx / max_speed\n        if t + dt > T:\n            dt = T - t\n\n        if choice == \"A\":\n            u_new = step_choice_A(u, dt, dx)\n        elif choice == \"B\":\n            u_new = step_choice_B(u, dt, dx)\n        else:\n            raise ValueError(\"Unknown flux choice\")\n\n        # Entropy and counter\n        E_new = 0.5 * np.sum(u_new * u_new) * dx\n        if (E_new - E_prev) > tau:\n            C_increase += 1\n\n        u = u_new\n        E_prev = E_new\n        t += dt\n\n    E_final = E_prev\n    Pi = (E0 - E_final) / T\n    return [Pi, C_increase]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (flux_choice, Nx, CFL, T)\n    test_cases = [\n        (\"A\", 400, 0.9, 0.30),\n        (\"B\", 400, 0.9, 0.30),\n        (\"A\", 400, 0.9, 0.05),\n        (\"B\", 100, 0.9, 0.30),\n    ]\n\n    results = []\n    for case in test_cases:\n        choice, Nx, CFL, T = case\n        res = run_case(choice, Nx, CFL, T, tau=1e-12)\n        # Convert to [float,int] with reasonable float formatting by default\n        results.append([res[0], res[1]])\n\n    # Final print statement in the exact required format.\n    # Ensure only the list is printed.\n    # Convert inner lists to string with default float formatting\n    def entry_to_str(entry):\n        return f\"[{entry[0]},{entry[1]}]\"\n    print(f\"[{','.join(entry_to_str(e) for e in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2448972"}, {"introduction": "模拟极端物理情景，如气体向完美真空膨胀，是检验数值求解器鲁棒性的关键测试。在这种密度和压力趋于零的极限情况下，许多标准数值方法会失效。本练习 [@problem_id:2437084] 要求你构建一个能够稳健处理真空状态的一维欧拉方程求解器，并将其数值结果与理论解进行对比，这将让你深入理解在物理极限条件下确保数值方法稳定性和准确性的重要性。", "problem": "您将设计并实现一个一维激波捕捉求解器，用于求解可压缩欧拉方程，该求解器能够稳健地处理初始真空状态。目标是计算一个初始右侧为空的黎曼问题中真空边界的数值传播速度，并将其与从第一性原理推导出的理论预测进行比较。实现必须是一个完整、可运行的程序。\n\n从比热比为 $\\gamma$ 的量热完全气体的一维欧拉方程的守恒律形式开始：\n- 质量守恒：$\\partial_t \\rho + \\partial_x (\\rho u) = 0$。\n- 动量守恒：$\\partial_t (\\rho u) + \\partial_x (\\rho u^2 + p) = 0$。\n- 总能量守恒：$\\partial_t E + \\partial_x \\left(u (E + p)\\right) = 0$。\n- 状态方程：$E = \\dfrac{p}{\\gamma - 1} + \\dfrac{1}{2}\\rho u^2$。\n\n使用均匀的有限体积网格在一个有界区间上对这些方程进行离散化，并采用透射（零梯度）边界条件。使用带有 Rusanov (局部 Lax–Friedrichs) 数值通量的一阶显式方法。时间步长必须满足基于最大信号速度 $s = |u| + a$ 的 Courant–Friedrichs–Lewy 稳定条件，其中 $a = \\sqrt{\\gamma p / \\rho}$ 是当地声速。通过最小保正修正来稳健地处理真空状态，该修正以物理上一致的方式将负值限制为零，从而确保密度和压力始终保持非负。\n\n初始条件：一个黎曼问题，具有左态 $(\\rho_L, u_L, p_L)$ 和右真空态 $(\\rho_R, u_R, p_R) = (0, 0, 0)$，在 $x=0$ 处存在间断。计算域是对称的，$[x_L, x_R] = [-L, L]$，其中当 $x  0$ 时应用左态，当 $x \\ge 0$ 时应用右真空态。仿真是无量纲的；所有要求的数值量都应以无量纲数的形式报告。\n\n您必须：\n- 实现带有 Rusanov 通量的有限体积求解器。\n- 强制执行 Courant–Friedrichs–Lewy 时间步长 $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / \\max_i (|u_i| + a_i)$，且不超过到达最终时间 $t_{\\text{final}}$ 的剩余时间。\n- 在每侧使用一个虚拟单元来应用透射边界条件。\n- 在每次更新后应用最小保正修正：强制 $\\rho \\ge 0$；如果在任何 $\\rho  0$ 的单元中计算出的压力 $p = (\\gamma-1)\\left(E - \\tfrac{1}{2}\\rho u^2\\right)$ 为负，则通过设置 $E \\leftarrow \\tfrac{1}{2}\\rho u^2$ 将该单元的内能重置为零，这意味着 $p \\leftarrow 0$。\n- 到达 $t_{\\text{final}}$ 后，将阵面位置估计为密度 $\\rho(x)  \\rho_{\\text{th}}$ (阈值 $\\rho_{\\text{th}} = 10^{-6}$) 的最大单元中心 $x$，并计算数值阵面速度 $\\hat{v}_{\\text{num}} = x_{\\text{front}}/t_{\\text{final}}$。\n- 独立地，根据气体动力学的第一性原理和中心化稀疏波进入真空的特征线分析，推导出以 $(\\rho_L,u_L,p_L,\\gamma)$ 表示的向真空膨胀的理论边界（尾部）速度，并在您的代码中使用该表达式计算 $\\hat{v}_{\\text{th}}$ 以进行比较。\n- 对于误差度量，使用绝对误差 $|\\hat{v}_{\\text{num}} - \\hat{v}_{\\text{th}}|$。\n\n测试套件。为以下四组参数运行求解器；为确保精度，下面的所有符号和数字均使用 LaTeX 格式：\n- 情况 A (一般情况):\n  - $\\gamma = 1.4$, $\\rho_L = 1.0$, $u_L = 0.0$, $p_L = 1.0$,\n  - $[x_L,x_R] = [-1.0, 1.0]$, $N = 400$ 个单元, $\\mathrm{CFL} = 0.4$, $t_{\\text{final}} = 0.05$。\n  - 此情况的输出：绝对误差 $|\\hat{v}_{\\text{num}} - \\hat{v}_{\\text{th}}|$，以浮点数形式表示。\n- 情况 B (近 Courant 极限的稳健性和保正性):\n  - $\\gamma = 1.4$, $\\rho_L = 1.0$, $u_L = 0.0$, $p_L = 1.0$,\n  - $[x_L,x_R] = [-1.0, 1.0]$, $N = 200$ 个单元, $\\mathrm{CFL} = 0.95$, $t_{\\text{final}} = 0.05$。\n  - 此情况的输出：一个布尔值，指示在 $t_{\\text{final}}$ 时所有单元的密度和压力是否满足 $\\rho \\ge 0$ 和 $p \\ge 0$。\n- 情况 C (较弱的左态):\n  - $\\gamma = 1.4$, $\\rho_L = 0.125$, $u_L = 0.0$, $p_L = 0.1$,\n  - $[x_L,x_R] = [-1.0, 1.0]$, $N = 400$ 个单元, $\\mathrm{CFL} = 0.4$, $t_{\\text{final}} = 0.05$。\n  - 此情况的输出：绝对误差 $|\\hat{v}_{\\text{num}} - \\hat{v}_{\\text{th}}|$，以浮点数形式表示。\n- 情况 D (不同的比热比):\n  - $\\gamma = \\dfrac{5}{3}$, $\\rho_L = 1.0$, $u_L = 0.0$, $p_L = 1.0$,\n  - $[x_L,x_R] = [-1.0, 1.0]$, $N = 400$ 个单元, $\\mathrm{CFL} = 0.4$, $t_{\\text{final}} = 0.05$。\n  - 此情况的输出：绝对误差 $|\\hat{v}_{\\text{num}} - \\hat{v}_{\\text{th}}|$，以浮点数形式表示。\n\n最终输出格式。您的程序必须打印单行，其中包含一个 Python 风格的列表，按顺序汇总四种情况的结果 [情况 A 结果, 情况 B 结果, 情况 C 结果, 情况 D 结果]。例如，输出必须是形如 $[r_A, r_B, r_C, r_D]$ 的单行，其中 $r_A$、$r_C$ 和 $r_D$ 是浮点数（无量纲），$r_B$ 是一个布尔值。不得打印任何额外文本。", "solution": "所提出的问题是有效的。这是一个计算流体动力学中的适定问题，基于欧拉方程的基本原理和标准数值方法。所有必要的参数和条件都已提供，目标清晰且科学上可验证。\n\n该问题需要两部分分析：真空边界传播速度的理论推导和验证该理论的数值模拟。\n\n首先，我们推导向真空膨胀的阵面的理论速度。该问题描述了一维欧拉方程的黎曼问题，左侧为高压气体，右侧为真空。控制方程为：\n$$ \\partial_t \\mathbf{U} + \\partial_x \\mathbf{F}(\\mathbf{U}) = 0 $$\n其中守恒变量的状态向量 $\\mathbf{U}$ 和通量向量 $\\mathbf{F}(\\mathbf{U})$ 为：\n$$ \\mathbf{U} = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ E \\end{pmatrix}, \\quad \\mathbf{F}(\\mathbf{U}) = \\begin{pmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u(E+p) \\end{pmatrix} $$\n这里，$\\rho$ 是密度，$u$ 是速度，$p$ 是压力，$E$ 是单位体积的总能量，它们通过量热完全气体的状态方程相关联：\n$$ E = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2 $$\n黎曼问题的解是自相似的，仅依赖于变量 $\\xi = x/t$。在 $x=0$ 处，左态 $(\\rho_L, u_L, p_L)$ 和右真空态 $(\\rho_R, u_R, p_R) = (0, 0, 0)$ 之间的初始间断演变为一个中心化稀疏波。该波平滑地将左态连接到真空。\n\n稀疏波的动力学由特征线法描述。对于欧拉方程，沿着 $C_{\\pm}$ 特征线（速度为 $\\lambda_{\\pm} = u \\pm a$）的黎曼不变量是恒定的。声速为 $a = \\sqrt{\\gamma p / \\rho}$。沿着一条 $C_{-}$ 特征线，量 $u + \\frac{2a}{\\gamma-1}$ 是常数。这个不变量必须在整个稀疏扇中保持不变。因此，扇内任意点 $(\\rho, u, p)$ 的该值必须等于其在未扰动的左态中的值：\n$$ u + \\frac{2a}{\\gamma-1} = u_L + \\frac{2a_L}{\\gamma-1} $$\n其中 $a_L = \\sqrt{\\gamma p_L / \\rho_L}$。\n\n稀疏波的尾部是膨胀气体和真空之间的边界。在此边界上，密度和压力降至零，因此声速也变为零（$a_{tail} = 0$）。该边界的速度由当地特征速度 $\\lambda_{+} = u_{tail} + a_{tail}$ 给出。由于 $a_{tail}=0$，真空阵面的速度就是该点的流体速度 $u_{tail}$。\n\n将 $a=a_{tail}=0$ 代入黎曼不变量方程，得到尾部的速度：\n$$ u_{tail} + \\frac{2(0)}{\\gamma-1} = u_L + \\frac{2a_L}{\\gamma-1} $$\n$$ u_{tail} = u_L + \\frac{2a_L}{\\gamma-1} $$\n因此，真空边界的理论速度 $\\hat{v}_{\\text{th}}$ 为：\n$$ \\hat{v}_{\\text{th}} = u_L + \\frac{2}{\\gamma-1} \\sqrt{\\frac{\\gamma p_L}{\\rho_L}} $$\n这就是用于与数值结果进行比较的表达式。\n\n接下来，我们描述数值求解器。采用有限体积法在单元宽度为 $\\Delta x$ 的均匀网格上求解。欧拉方程的半离散形式是：\n$$ \\frac{d\\mathbf{U}_i}{dt} = - \\frac{1}{\\Delta x} (\\mathbf{F}_{i+1/2} - \\mathbf{F}_{i-1/2}) $$\n其中 $\\mathbf{U}_i$ 是单元 $i$ 中的单元平均状态向量，$\\mathbf{F}_{i\\pm1/2}$ 是单元界面上的数值通量。时间积分使用一阶显式欧拉方法：\n$$ \\mathbf{U}_i^{n+1} = \\mathbf{U}_i^n - \\frac{\\Delta t}{\\Delta x} (\\mathbf{F}_{i+1/2} - \\mathbf{F}_{i-1/2}) $$\n数值通量是 Rusanov (或局部 Lax-Friedrichs) 通量，由下式给出：\n$$ \\mathbf{F}_{i+1/2} = \\frac{1}{2}\\left(\\mathbf{F}(\\mathbf{U}_i) + \\mathbf{F}(\\mathbf{U}_{i+1})\\right) - \\frac{s_{i+1/2}}{2}\\left(\\mathbf{U}_{i+1} - \\mathbf{U}_i\\right) $$\n局部波速估计 $s_{i+1/2}$ 是界面处的最大信号速度：\n$$ s_{i+1/2} = \\max(|u_i| + a_i, |u_{i+1}| + a_{i+1}) $$\n时间步长 $\\Delta t$ 受 Courant-Friedrichs-Lewy (CFL) 条件的限制：\n$$ \\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{\\max_i(|u_i| + a_i)} $$\n使用计算域两端各一个虚拟单元来应用透射（零梯度）边界条件。\n\n该问题的一个关键方面是稳健地处理真空状态。当 $\\rho \\to 0$ 时，$p \\to 0$ 且 $a \\to 0$。数值格式可能会产生非物理的负密度或负压力。在每个时间步之后应用指定的保正修正：\n1. 强制密度非负：$\\rho_i \\leftarrow \\max(\\rho_i, 0)$。实际上，由于 Rusanov 格式的性质，在合适的 CFL 条件下密度应保持非负，但此操作可以处理任何浮点数下溢。在实现中，使用一个非常小的正下限值以防止除以零。\n2. 修正负压力：如果在 $\\rho_i  0$ 的单元中计算出的压力 $p_i = (\\gamma-1)(E_i - \\frac{1}{2}\\rho_i u_i^2)$ 变为负值，则该单元的内能被重置为零。这意味着 $p_i \\leftarrow 0$，并且总能量被更新为纯动能：$E_i \\leftarrow \\frac{1}{2}\\rho_i u_i^2$。\n\n在模拟运行至最终时间 $t_{\\text{final}}$ 后，估计数值阵面速度 $\\hat{v}_{\\text{num}}$。阵面位置 $x_{\\text{front}}$ 被确定为密度 $\\rho$ 超过一个小的阈值 $\\rho_{\\text{th}} = 10^{-6}$ 的最右侧单元的中心。然后，数值速度为 $\\hat{v}_{\\text{num}} = x_{\\text{front}} / t_{\\text{final}}$。接着为指定的测试用例计算绝对误差 $|\\hat{v}_{\\text{num}} - \\hat{v}_{\\text{th}}|$。对于情况 B，检查最终密度和压力场的正性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D Euler solver.\n    \"\"\"\n    RHO, MOM, ENE = 0, 1, 2  # Indices for conserved variables\n\n    def _conserved_to_primitive(U, gamma):\n        \"\"\"\n        Converts a matrix of conserved variables U to primitive variables rho, u, p.\n        U is a (3, M) array.\n        \"\"\"\n        rho = U[RHO, :]\n        mom = U[MOM, :]\n        ene = U[ENE, :]\n        \n        # Handle vacuum state rho=0\n        u = np.divide(mom, rho, out=np.zeros_like(mom), where=rho > 1e-12)\n        p = (gamma - 1) * (ene - 0.5 * mom * u)\n        \n        # Clamp pressure to be non-negative for physical consistency\n        p = np.maximum(p, 0.0)\n        return rho, u, p\n\n    def _get_flux(U, gamma, u, p):\n        \"\"\"\n        Computes the flux vector F from conserved variables U and some primitive variables.\n        U is a (3, M) array, u and p are (M,) arrays.\n        \"\"\"\n        F = np.zeros_like(U)\n        F[RHO, :] = U[MOM, :]\n        F[MOM, :] = U[RHO, :] * u**2 + p\n        F[ENE, :] = u * (U[ENE, :] + p)\n        return F\n\n    def solve_case(gamma, rho_L, u_L, p_L, L, N, CFL, t_final, rho_th, task):\n        \"\"\"\n        Solves a single case of the Riemann problem with vacuum.\n        \"\"\"\n        dx = 2.0 * L / N\n        x = np.linspace(-L + dx / 2.0, L - dx / 2.0, N)\n\n        # Initialize state vector U with ghost cells\n        U = np.zeros((3, N + 2))\n        \n        # Set initial conditions in the interior domain\n        rho_init = np.where(x  0, rho_L, 0.0)\n        u_init = np.where(x  0, u_L, 0.0)\n        p_init = np.where(x  0, p_L, 0.0)\n        \n        # Convert to conserved variables\n        U[RHO, 1:N+1] = rho_init\n        U[MOM, 1:N+1] = rho_init * u_init\n        U[ENE, 1:N+1] = p_init / (gamma - 1) + 0.5 * rho_init * u_init**2\n        \n        t = 0.0\n        while t  t_final:\n            # Apply transmissive (zero-gradient) boundary conditions\n            U[:, 0] = U[:, 1]\n            U[:, N+1] = U[:, N]\n\n            # Decode primitive variables from conserved state\n            rho_all, u_all, p_all = _conserved_to_primitive(U, gamma)\n\n            # Calculate sound speed\n            a_all = np.sqrt(gamma * p_all / rho_all, out=np.zeros_like(rho_all), where=rho_all > 1e-12)\n            \n            # CFL condition for time step\n            max_speed = np.max(np.abs(u_all) + a_all)\n            if max_speed == 0: max_speed = 1e-6\n            dt = CFL * dx / max_speed\n            dt = min(dt, t_final - t)\n\n            # Rusanov (local Lax-Friedrichs) flux calculation\n            U_L = U[:, :-1]\n            U_R = U[:, 1:]\n            \n            rho_L_if, u_L_if, p_L_if = _conserved_to_primitive(U_L, gamma)\n            rho_R_if, u_R_if, p_R_if = _conserved_to_primitive(U_R, gamma)\n\n            a_L_if = np.sqrt(gamma * p_L_if / rho_L_if, out=np.zeros_like(rho_L_if), where=rho_L_if > 1e-12)\n            a_R_if = np.sqrt(gamma * p_R_if / rho_R_if, out=np.zeros_like(rho_R_if), where=rho_R_if > 1e-12)\n\n            F_L = _get_flux(U_L, gamma, u_L_if, p_L_if)\n            F_R = _get_flux(U_R, gamma, u_R_if, p_R_if)\n\n            s_half = np.maximum(np.abs(u_L_if) + a_L_if, np.abs(u_R_if) + a_R_if)\n            F_half = 0.5 * (F_L + F_R) - 0.5 * s_half[np.newaxis, :] * (U_R - U_L)\n\n            # Update state with first-order explicit Euler\n            U[:, 1:N+1] -= (dt / dx) * (F_half[:, 1:] - F_half[:, :-1])\n\n            # Positivity-preserving correction for pressure\n            rho_new = U[RHO, 1:N+1]\n            mom_new = U[MOM, 1:N+1]\n            ene_new = U[ENE, 1:N+1]\n\n            # Clamp density to be non-negative (robustness for floating point)\n            U[RHO, 1:N+1] = np.maximum(rho_new, 0.0)\n            rho_new = U[RHO, 1:N+1]\n\n            u_new = np.divide(mom_new, rho_new, out=np.zeros_like(mom_new), where=rho_new > 1e-12)\n            p_new = (gamma - 1) * (ene_new - 0.5 * rho_new * u_new**2)\n\n            # Find cells with negative pressure and positive density\n            neg_p_mask = (p_new  0)  (rho_new > 1e-12)\n            \n            # Reset internal energy to zero for those cells\n            ene_new[neg_p_mask] = 0.5 * mom_new[neg_p_mask]**2 / rho_new[neg_p_mask]\n            U[ENE, 1:N+1] = ene_new\n\n            t += dt\n\n        # Post-processing and analysis\n        rho_final = U[RHO, 1:N+1]\n        \n        if task == 'positivity':\n            _, _, p_final = _conserved_to_primitive(U[:, 1:N+1], gamma)\n            return bool(np.all(rho_final >= 0) and np.all(p_final >= 0))\n        elif task == 'error':\n            # Numerical front speed\n            front_indices = np.where(rho_final > rho_th)[0]\n            if len(front_indices) > 0:\n                x_front = x[front_indices[-1]]\n                v_num = x_front / t_final\n            else:\n                v_num = 0.0\n\n            # Theoretical front speed\n            a_L = np.sqrt(gamma * p_L / rho_L) if rho_L > 0 else 0.0\n            v_th = u_L + (2.0 * a_L) / (gamma - 1.0)\n            \n            return abs(v_num - v_th)\n        return None\n\n\n    test_cases = [\n        # Case A\n        {'gamma': 1.4, 'rho_L': 1.0, 'u_L': 0.0, 'p_L': 1.0, 'L': 1.0, 'N': 400, 'CFL': 0.4, 't_final': 0.05, 'rho_th': 1e-6, 'task': 'error'},\n        # Case B\n        {'gamma': 1.4, 'rho_L': 1.0, 'u_L': 0.0, 'p_L': 1.0, 'L': 1.0, 'N': 200, 'CFL': 0.95, 't_final': 0.05, 'rho_th': 1e-6, 'task': 'positivity'},\n        # Case C\n        {'gamma': 1.4, 'rho_L': 0.125, 'u_L': 0.0, 'p_L': 0.1, 'L': 1.0, 'N': 400, 'CFL': 0.4, 't_final': 0.05, 'rho_th': 1e-6, 'task': 'error'},\n        # Case D\n        {'gamma': 5.0/3.0, 'rho_L': 1.0, 'u_L': 0.0, 'p_L': 1.0, 'L': 1.0, 'N': 400, 'CFL': 0.4, 't_final': 0.05, 'rho_th': 1e-6, 'task': 'error'},\n    ]\n\n    results = [solve_case(**case) for case in test_cases]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2437084"}]}