{"hands_on_practices": [{"introduction": "从微观状态计算宏观属性是分子动力学 (MD) 的核心目标之一，而压力 $P$ 是一个关键的例子。本练习将引导你应用维里定理从单个系统快照中计算瞬时压力。更重要的是，它通过对比正确和错误的处理方式，突显了在周期性边界条件 (Periodic Boundary Conditions, PBC) 下使用最小镜像约定 (minimum image convention) 的决定性作用，帮助你掌握避免常见模拟错误的关键技能。[@problem_id:2414258]", "problem": "要求您在一个立方周期性模拟盒子中，为一个三维 Lennard-Jones 流体实现力学路径的压力计算。目标有两方面：使用维里定理和正确的周期性处理方法来计算瞬时压力，并与此同时，计算一个因故意错误处理周期性边界条件而产生的错误压力，以揭示此类错误的影响。您的最终程序必须是一个单一、完整、可运行的脚本，该脚本仅使用指定的环境，并为给定的测试套件打印所需的输出。\n\n所有计算都必须使用 Lennard-Jones 约化单位，其中能量标度 $\\epsilon$ 和长度标度 $\\sigma$ 设置为 $\\epsilon = 1$ 和 $\\sigma = 1$，玻尔兹曼常数 $k_{\\mathrm{B}} = 1$。所有压力均以 $\\epsilon/\\sigma^{3}$ 为单位表示。使用球形截断半径 $r_{\\mathrm{c}} = 2.5\\,\\sigma$，不移动势能也不应用尾部校正。\n\n从基本定律和核心定义出发：\n- 牛顿第二定律 $m \\,\\mathrm{d}^{2}\\mathbf{r}/\\mathrm{d}t^{2} = \\mathbf{f}$ 以及成对中心力的概念，\n- 对于通过对势相互作用的 $N$ 个粒子，经典维里定理计算压力的力学路径，\n- 边长为 $L$ 的立方盒子中的周期性边界条件，\n\n推导出一个算法，用于在给定温度 $T$ 下计算单个构型的瞬时压力 $P$。压力必须包含理想气体贡献项 $\\rho k_{\\mathrm{B}} T$（其中数密度 $\\rho = N/V$，体积 $V = L^{3}$），以及一个构型维里项。该维里项是通过对所有不同的粒子对 $i<j$ 求和得到的，其中使用的对力由 Lennard-Jones 势产生\n$$\nu(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],\\quad \\text{for } r < r_{\\mathrm{c}},\n$$\n否则 $u(r)=0$。此处 $r$ 是两个粒子之间的标量距离。若有角度，则通过以弧度为单位的向量点积隐式表示。\n\n实现两种算法：\n- 正确的算法：在边长为 $L$ 的立方周期性盒子中，使用最小镜像约定计算对分离矢量 $\\mathbf{r}_{ij}$，即对每个笛卡尔分量 $\\alpha \\in \\{x,y,z\\}$，\n$$\n\\Delta r_{\\alpha} \\leftarrow \\Delta r_{\\alpha} - L\\ \\mathrm{round}\\!\\left(\\frac{\\Delta r_{\\alpha}}{L}\\right),\n$$\n然后求得 $r = \\|\\mathbf{r}_{ij}\\|$，仅当 $r < r_{\\mathrm{c}}$ 时才包含该粒子对，根据 $- \\mathrm{d}u/\\mathrm{d}r$ 计算对力，并使用基于点积 $\\mathbf{r}_{ij}\\cdot \\mathbf{f}_{ij}$ 的力学定义累加构型维里。最后，加上理想气体项 $\\rho k_{\\mathrm{B}} T$。\n- 错误的算法（故意为之）：不使用最小镜像约定，直接将原始差值作为对分离矢量，并使用该原始距离来判断截断和计算维里贡献。保持所有其他步骤相同。这种对周期性的不正确处理是唯一故意的错误。\n\n科学和数值细节及要求：\n- 使用约化单位，$k_{\\mathrm{B}}=\\epsilon=\\sigma=1$，并以 $\\epsilon/\\sigma^3$ 为单位报告压力。\n- 使用从给定势能推导出的 Lennard-Jones 力，并在 $r_{\\mathrm{c}}$ 处应用硬截断；不应用任何长程校正。\n- 最终的数值输出必须四舍五入到六位小数。\n\n测试套件（每个测试用例独立定义 $L$、$T$ 和粒子位置）：\n- 测试 A（理想路径，无跨边界相互作用）：$L=10.0$，$T=1.2$，$N=3$ 的粒子位置，\n  - $\\mathbf{r}_{1}=(1.0,\\,1.0,\\,1.0)$,\n  - $\\mathbf{r}_{2}=(2.0,\\,2.0,\\,2.0)$,\n  - $\\mathbf{r}_{3}=(3.0,\\,3.0,\\,3.0)$.\n- 测试 B（存在跨边界粒子对以暴露错误）：$L=4.0$，$T=0.5$，$N=2$ 的粒子位置，\n  - $\\mathbf{r}_{1}=(0.2,\\,0.1,\\,0.1)$,\n  - $\\mathbf{r}_{2}=(3.1,\\,0.1,\\,0.1)$.\n- 测试 C（混合相互作用，包括一个跨边界的对角线粒子对）：$L=5.0$，$T=1.0$，$N=4$ 的粒子位置，\n  - $\\mathbf{r}_{1}=(0.2,\\,0.2,\\,0.2)$,\n  - $\\mathbf{r}_{2}=(4.3,\\,0.2,\\,0.2)$,\n  - $\\mathbf{r}_{3}=(2.5,\\,2.5,\\,2.5)$,\n  - $\\mathbf{r}_{4}=(3.6,\\,2.5,\\,2.5)$.\n\n您的程序必须：\n- 实现上述指定的正确和错误两种算法。\n- 对于每个测试用例，计算两个浮点数：正确的压力和错误的压力，单位为 $\\epsilon/\\sigma^3$，每个都四舍五入到六位小数。\n- 生成单行输出，包含一个以逗号分隔的列表的列表，其格式必须完全符合 `“[ [P_correct_A,P_erroneous_A],[P_correct_B,P_erroneous_B],[P_correct_C,P_erroneous_C] ]”`，其中每个浮点数显示六位小数。例如：“[[0.123456,0.000001],[...],[...]]”。\n\n最终输出为纯数值浮点数；不应打印任何单位或符号。在任何矢量运算中，弧度的使用都是隐式的，不需要明确的角度输出。", "solution": "问题陈述有效。它提出了一个计算物理学中明确定义的任务，该任务基于统计力学和分子模拟的原理。所有必要的参数和定义都已提供，并且没有科学或逻辑上的不一致之处。我们将着手提供完整的解决方案。\n\n目标是计算周期性立方盒子中 Lennard-Jones 流体的瞬时压力。在一个体积为 $V$、温度为 $T$ 的系统中，包含 $N$ 个粒子的压力 $P$ 由维里定理给出。其一般表达式为：\n$$\nP = \\rho k_{\\mathrm{B}} T + \\frac{1}{3V} \\left\\langle \\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{f}_i^{\\text{int}} \\right\\rangle\n$$\n此处，$\\rho = N/V$ 是数密度，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$\\mathbf{r}_i$ 是粒子 $i$ 的位置，$\\mathbf{f}_i^{\\text{int}}$ 是系统中所有其他粒子对粒子 $i$ 作用的总内力。尖括号 $\\langle \\cdot \\rangle$ 表示时间平均，对于瞬时压力，这一项被省略。\n\n粒子 $i$ 上的总内力是对力之和：$\\mathbf{f}_i^{\\text{int}} = \\sum_{j \\ne i} \\mathbf{f}_{ij}$，其中 $\\mathbf{f}_{ij}$ 是粒子 $j$ 对粒子 $i$ 的作用力。维里项可以重写为对所有唯一的粒子对 $(i,j)$（其中 $i<j$）的求和：\n$$\n\\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{f}_i^{\\text{int}} = \\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\sum_{j \\ne i} \\mathbf{f}_{ij} = \\sum_{i<j} (\\mathbf{r}_i \\cdot \\mathbf{f}_{ij} + \\mathbf{r}_j \\cdot \\mathbf{f}_{ji})\n$$\n根据牛顿第三定律，$\\mathbf{f}_{ji} = -\\mathbf{f}_{ij}$。因此，求和式变为：\n$$\n\\sum_{i<j} (\\mathbf{r}_i - \\mathbf{r}_j) \\cdot \\mathbf{f}_{ij} = \\sum_{i<j} (-\\mathbf{r}_{ij}) \\cdot \\mathbf{f}_{ij}\n$$\n其中 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ 是从粒子 $i$ 指向粒子 $j$ 的分离矢量。力 $\\mathbf{f}_{ij}$ 由对势 $u(r_{ij})$ 导出，即 $\\mathbf{f}_{ij} = -\\nabla_{\\mathbf{r}_i} u(r_{ij})$。对于中心势，这可以表示为：\n$$\n\\mathbf{f}_{ij} = -\\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}} = \\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\frac{\\mathbf{r}_{ij}}{r_{ij}}\n$$\n将此代入对维里表达式，得到：\n$$\n(-\\mathbf{r}_{ij}) \\cdot \\mathbf{f}_{ij} = (-\\mathbf{r}_{ij}) \\cdot \\left(\\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\frac{\\mathbf{r}_{ij}}{r_{ij}}\\right) = -r_{ij} \\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}}\n$$\n因此，压力公式为：\n$$\nP = \\rho k_{\\mathrm{B}} T + \\frac{1}{3V} \\sum_{i<j} \\left\\langle -r_{ij} \\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\right\\rangle = \\rho k_{\\mathrm{B}} T - \\frac{1}{3V} \\sum_{i<j} \\left\\langle r_{ij} \\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\right\\rangle\n$$\n这个推导基于标准约定，其中内维里为 $\\sum \\mathbf{r}_i \\cdot \\mathbf{f}_i^{\\text{int}}$。一个等价的公式从 $P = \\rho k_B T + \\frac{1}{3V} \\sum_{i<j} \\langle \\mathbf{r}_{ij} \\cdot \\mathbf{f}_{ji} \\rangle$ 出发，它会导出相同的最终表达式。如果混淆定义，很容易出现符号错误。我们将采用后一种正确的形式。\n\nLennard-Jones 势由以下公式给出：\n$$\nu(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\n其对 $r$ 的导数为：\n$$\n\\frac{\\mathrm{d}u}{\\mathrm{d}r} = 4\\epsilon \\left[-12\\frac{\\sigma^{12}}{r^{13}} + 6\\frac{\\sigma^{6}}{r^{7}}\\right]\n$$\n因此，对维里项 $r (\\mathrm{d}u/\\mathrm{d}r)$ 为：\n$$\nr \\frac{\\mathrm{d}u}{\\mathrm{d}r} = 4\\epsilon \\left[-12\\left(\\frac{\\sigma}{r}\\right)^{12} + 6\\left(\\frac{\\sigma}{r}\\right)^{6}\\right] = -24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\n题目指定了约化单位，其中 $\\epsilon=1$，$\\sigma=1$，$k_{\\mathrm{B}}=1$。盒子是边长为 $L$ 的立方体，所以 $V=L^3$。势能在截断半径 $r_{\\mathrm{c}}=2.5\\sigma=2.5$ 处被截断。单个构型的压力方程变为：\n$$\nP = \\frac{N T}{L^3} - \\frac{1}{3L^3} \\sum_{\\substack{i<j \\\\ r_{ij} < r_{\\mathrm{c}}}} \\left(-24 \\left[2r_{ij}^{-12} - r_{ij}^{-6}\\right]\\right)\n$$\n$$\nP = \\frac{N T}{L^3} + \\frac{8}{L^3} \\sum_{\\substack{i<j \\\\ r_{ij} < r_{\\mathrm{c}}}} \\left(2r_{ij}^{-12} - r_{ij}^{-6}\\right)\n$$\n这是用于实现的核心公式。正确算法和错误算法之间的区别仅在于分离矢量 $\\mathbf{r}_{ij}$ 及其大小 $r_{ij}$ 的计算方式。\n\n**正确的算法（使用周期性边界条件）：**\n对于每一对粒子 $(i, j)$（其中 $i<j$）：\n1. 计算原始分离矢量 $\\Delta\\mathbf{r}_{\\text{raw}} = \\mathbf{r}_j - \\mathbf{r}_i$。\n2. 对每个分量 $\\alpha \\in \\{x, y, z\\}$ 应用最小镜像约定 (MIC) 来找到周期性盒子中的分离矢量 $\\mathbf{r}_{ij}$：\n   $$\n   \\Delta r_{\\alpha} \\leftarrow \\Delta r_{\\alpha}^{\\text{raw}} - L \\cdot \\mathrm{round}\\!\\left(\\frac{\\Delta r_{\\alpha}^{\\text{raw}}}{L}\\right)\n   $$\n3. 计算距离的平方 $r_{ij}^2 = (\\Delta r_x)^2 + (\\Delta r_y)^2 + (\\Delta r_z)^2$。\n4. 如果 $r_{ij}^2 < r_{\\mathrm{c}}^2$，则计算其对维里和的贡献。否则，贡献为零。\n\n**错误的算法（不使用周期性边界条件）：**\n对于每一对粒子 $(i, j)$（其中 $i<j$）：\n1. 计算原始分离矢量 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。\n2. 不应用最小镜像约定。\n3. 计算距离的平方 $r_{ij}^2 = (\\Delta r_x)^2 + (\\Delta r_y)^2 + (\\Delta r_z)^2$。\n4. 如果 $r_{ij}^2 < r_{\\mathrm{c}}^2$，则使用此原始距离计算其对维里和的贡献。\n\n该实现将把这两个过程应用于提供的测试用例。首先计算总构型维里 $W = \\sum_{i<j, r_{ij}<r_c} 24(2r_{ij}^{-12} - r_{ij}^{-6})$，然后最终压力计算为 $P = \\frac{NT}{L^3} + \\frac{W}{3L^3}$。然而，由于推导过程中的符号校正，我们的公式是 $P = \\frac{NT}{L^3} - \\frac{1}{3L^3}\\sum W_{pair}$，其中 $W_{pair} = r \\frac{du}{dr} = -24(2r^{-12} - r^{-6})$。这等价于 $P = \\frac{NT}{L^3} + \\frac{8}{L^3} \\sum (2r^{-12} - r^{-6})$。两者在数学上是等价的。为直接起见，我们将实现后者。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_pressure(L, T, positions, use_pbc):\n    \"\"\"\n    Computes the instantaneous pressure of a Lennard-Jones fluid.\n\n    Args:\n        L (float): Edge length of the cubic simulation box.\n        T (float): Temperature of the system.\n        positions (np.ndarray): Nx3 array of particle positions.\n        use_pbc (bool): If True, use minimum image convention. If False, use raw coordinates.\n\n    Returns:\n        float: The computed instantaneous pressure.\n    \"\"\"\n    N = len(positions)\n    V = L**3\n    rho = N / V\n    \n    # Lennard-Jones reduced unit constants\n    rc = 2.5\n    rc2 = rc**2\n    \n    # Ideal gas contribution to pressure\n    ideal_pressure = rho * T\n\n    # Configurational contribution to pressure\n    configurational_virial_sum = 0.0\n    \n    # Loop over all unique pairs of particles\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate separation vector\n            rij_vec = positions[j] - positions[i]\n            \n            # Apply minimum image convention if required\n            if use_pbc:\n                rij_vec = rij_vec - L * np.round(rij_vec / L)\n            \n            # Calculate squared distance\n            r2 = np.sum(rij_vec**2)\n            \n            # Apply cutoff\n            if r2 < rc2:\n                # Calculate r^-6 and r^-12 (optimized to avoid repeated power calculations)\n                r_inv2 = 1.0 / r2\n                r_inv6 = r_inv2**3\n                r_inv12 = r_inv6**2\n                \n                # Pair virial contribution r * (du/dr) = -24 * [2*(sigma/r)^12 - (sigma/r)^6]\n                # The term in the pressure sum is 24 * [2*r^-12 - r^-6] / (3V)\n                # or 8 * [2*r^-12 - r^-6] / V\n                pair_virial_term = 2.0 * r_inv12 - r_inv6\n                configurational_virial_sum += pair_virial_term\n\n    # P = rho*kB*T + (1/3V) * sum(rij . fij)\n    # With the LJ potential, this simplifies to:\n    # P = rho*T + (8/V) * sum_pairs(2*r_ij^-12 - r_ij^-6)\n    configurational_pressure = (8.0 / V) * configurational_virial_sum\n    \n    total_pressure = ideal_pressure + configurational_pressure\n    \n    return total_pressure\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A\n        {\n            \"L\": 10.0,\n            \"T\": 1.2,\n            \"positions\": np.array([\n                [1.0, 1.0, 1.0],\n                [2.0, 2.0, 2.0],\n                [3.0, 3.0, 3.0]\n            ])\n        },\n        # Test B\n        {\n            \"L\": 4.0,\n            \"T\": 0.5,\n            \"positions\": np.array([\n                [0.2, 0.1, 0.1],\n                [3.1, 0.1, 0.1]\n            ])\n        },\n        # Test C\n        {\n            \"L\": 5.0,\n            \"T\": 1.0,\n            \"positions\": np.array([\n                [0.2, 0.2, 0.2],\n                [4.3, 0.2, 0.2],\n                [2.5, 2.5, 2.5],\n                [3.6, 2.5, 2.5]\n            ])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        T = case[\"T\"]\n        positions = case[\"positions\"]\n        \n        # Calculate correct pressure (with PBC)\n        p_correct = compute_pressure(L, T, positions, use_pbc=True)\n        \n        # Calculate erroneous pressure (without PBC)\n        p_erroneous = compute_pressure(L, T, positions, use_pbc=False)\n        \n        # Store results rounded to 6 decimal places as strings\n        all_results.append([f\"{p_correct:.6f}\", f\"{p_erroneous:.6f}\"])\n\n    # Format the final output string\n    # e.g., \"[[0.123456,0.000001],[...],[...]]\"\n    result_str = \"[\" + \",\".join([f\"[{c},{e}]\" for c, e in all_results]) + \"]\"\n    \n    print(result_str)\n\nsolve()\n```", "id": "2414258"}, {"introduction": "分子动力学模拟产生的轨迹构成了对某个统计系综的抽样，其涨落蕴含着丰富的物理信息。本练习的核心是统计力学中的一个深刻原理——涨落-耗散定理，它将微观量（能量 $E$）的涨落与宏观响应函数（定容热容 $C_V$）联系起来。通过处理模拟产生的能量时间序列数据，你将亲身体验如何应用这一基本定理来计算关键热力学性质，从而架起理论与实际数据分析之间的桥梁。[@problem_id:2414232]", "problem": "给定来自对一个经典多粒子系统的四个独立的恒定粒子数、恒定体积、恒定温度（粒子数-体积-温度 (NVT)）模拟的瞬时总能量的有限时间序列。假设模拟是遍历的，并在固定温度下对正则系综进行抽样。总能量用 $E$ 表示，绝对温度用 $T$ 表示，玻尔兹曼常数用 $k_B$ 表示。使用 $k_B = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$。在整个过程中，将提供的能量列表视为每种情况的完整数据集。所有能量的单位为焦耳，所有温度的单位为开尔文。所求的量是定容热容 $C_V$，以焦耳/开尔文表示。使用将 $C_V$ 与平衡态能量矩联系起来的正则系综涨落关系，结合系综平均的定义，并通过对提供的有限集合进行算术平均来评估这些平均值。具体来说，如果 $\\{E_i\\}_{i=1}^M$ 是包含 $M$ 个抽样能量的列表，则使用 $\\langle f(E)\\rangle \\approx \\frac{1}{M}\\sum_{i=1}^M f(E_i)$。\n\n待使用的正则系综关系是\n$$\nC_V \\;=\\; \\frac{\\langle E^2\\rangle - \\langle E\\rangle^2}{k_B\\,T^2}.\n$$\n\n对于每个测试用例，计算 $C_V$（单位：$\\mathrm{J/K}$），并以科学记数法报告每个结果，四舍五入到六位有效数字。\n\n测试套件：\n\n- 案例 1 (正常路径)：$T = 300\\ \\mathrm{K}$，能量列表为\n$[\\,1.14\\times 10^{-19},\\ 1.16\\times 10^{-19},\\ 1.18\\times 10^{-19},\\ 1.20\\times 10^{-19},\\ 1.22\\times 10^{-19},\\ 1.24\\times 10^{-19},\\ 1.26\\times 10^{-19},\\ 1.14\\times 10^{-19},\\ 1.16\\times 10^{-19},\\ 1.18\\times 10^{-19},\\ 1.20\\times 10^{-19},\\ 1.22\\times 10^{-19},\\ 1.24\\times 10^{-19},\\ 1.26\\times 10^{-19}\\,]\\ \\mathrm{J}$。\n\n- 案例 2 (边界：零涨落)：$T = 300\\ \\mathrm{K}$，能量列表为\n$[\\,8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20}\\,]\\ \\mathrm{J}$。\n\n- 案例 3 (温度标度检查)：$T = 600\\ \\mathrm{K}$，能量列表为\n$[\\,9.9\\times 10^{-20},\\ 1.01\\times 10^{-19},\\ 1.03\\times 10^{-19},\\ 1.05\\times 10^{-19},\\ 1.07\\times 10^{-19},\\ 1.09\\times 10^{-19},\\ 1.11\\times 10^{-19},\\ 9.9\\times 10^{-20},\\ 1.01\\times 10^{-19},\\ 1.03\\times 10^{-19},\\ 1.05\\times 10^{-19},\\ 1.07\\times 10^{-19},\\ 1.09\\times 10^{-19},\\ 1.11\\times 10^{-19}\\,]\\ \\mathrm{J}$。\n\n- 案例 4 (边缘：极小样本量)：$T = 250\\ \\mathrm{K}$，能量列表为\n$[\\,4.8\\times 10^{-20},\\ 5.2\\times 10^{-20}\\,]\\ \\mathrm{J}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，按案例 1 到 4 的顺序排列，例如\n$[r_1,r_2,r_3,r_4]$,\n其中每个 $r_i$ 是以 $\\mathrm{J/K}$ 为单位计算出的 $C_V$ 值，四舍五入到六位有效数字并以科学记数法打印。", "solution": "在粒子数和体积固定的正则系综中，系统与一个绝对温度为 $T$ 的热浴处于热平衡状态。能量为 $E$ 的一个微观状态的概率与 $\\exp(-\\beta E)$ 乘以态密度成正比，其中 $\\beta = 1/(k_B T)$。配分函数是 $Z(\\beta) = \\sum_{\\text{states}} \\exp(-\\beta E)$。系综平均能量是 $\\langle E \\rangle = -\\partial \\ln Z / \\partial \\beta$。定容热容定义为 $C_V = (\\partial \\langle E \\rangle / \\partial T)_V$。使用 $\\beta = 1/(k_B T)$ 和链式法则，\n$$\n\\frac{\\partial}{\\partial T} = \\frac{\\partial \\beta}{\\partial T}\\,\\frac{\\partial}{\\partial \\beta} = -\\frac{1}{k_B T^2}\\,\\frac{\\partial}{\\partial \\beta}.\n$$\n因此，\n$$\nC_V = \\left(\\frac{\\partial \\langle E \\rangle}{\\partial T}\\right)_V = -\\frac{1}{k_B T^2}\\,\\frac{\\partial \\langle E \\rangle}{\\partial \\beta}.\n$$\n使用 $\\langle E \\rangle = -\\partial \\ln Z / \\partial \\beta$，我们得到\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = -\\frac{\\partial^2 \\ln Z}{\\partial \\beta^2} = \\langle E^2 \\rangle - \\langle E \\rangle^2,\n$$\n这是正则系综中 $E$ 的方差。结合这些表达式可得到涨落-耗散关系\n$$\nC_V = \\frac{\\langle E^2 \\rangle - \\langle E \\rangle^2}{k_B T^2}.\n$$\n对于来自粒子数-体积-温度 (NVT) 模拟的有限遍历时间序列 $\\{E_i\\}_{i=1}^M$，系综平均值可通过算术平均值来近似，\n$$\n\\langle E \\rangle \\approx \\frac{1}{M}\\sum_{i=1}^M E_i,\\qquad \\langle E^2 \\rangle \\approx \\frac{1}{M}\\sum_{i=1}^M E_i^2.\n$$\n因此，根据给定数据，$C_V$ 的一个估计量是\n$$\nC_V \\approx \\frac{\\left(\\frac{1}{M}\\sum_{i=1}^M E_i^2\\right) - \\left(\\frac{1}{M}\\sum_{i=1}^M E_i\\right)^2}{k_B T^2}.\n$$\n\n将此应用于每个案例。\n\n案例 1：令 $M=14$，$T = 300\\ \\mathrm{K}$，能量列表（单位：焦耳）为\n$[\\,1.14\\times 10^{-19},\\ 1.16\\times 10^{-19},\\ 1.18\\times 10^{-19},\\ 1.20\\times 10^{-19},\\ 1.22\\times 10^{-19},\\ 1.24\\times 10^{-19},\\ 1.26\\times 10^{-19},\\ 1.14\\times 10^{-19},\\ 1.16\\times 10^{-19},\\ 1.18\\times 10^{-19},\\ 1.20\\times 10^{-19},\\ 1.22\\times 10^{-19},\\ 1.24\\times 10^{-19},\\ 1.26\\times 10^{-19}\\,]$。根据列表关于 $1.20\\times 10^{-19}\\ \\mathrm{J}$ 的对称性，样本均值为 $\\langle E \\rangle \\approx 1.20\\times 10^{-19}\\ \\mathrm{J}$。将 $E_i$ 写为 $E_i = E_0 + d x_i$，其中 $E_0 = 1.20\\times 10^{-19}\\ \\mathrm{J}$，$d = 2.0\\times 10^{-21}\\ \\mathrm{J}$，且 $x_i \\in \\{-3,-2,-1,0,1,2,3\\}$ 重复两次，我们有 $\\langle x \\rangle = 0$ 和 $\\langle x^2 \\rangle = 4$。那么 $\\langle E^2 \\rangle - \\langle E \\rangle^2 \\approx d^2 \\langle x^2 \\rangle = 4 d^2 = 1.6\\times 10^{-41}\\ \\mathrm{J}^2$。在 $k_B T^2 = (1.380649 \\times 10^{-23}\\ \\mathrm{J/K}) \\times 300^2 \\approx 1.24258 \\times 10^{-18}\\ \\mathrm{J^2/K}$ 的情况下，\n$$\nC_V \\approx \\frac{1.6\\times 10^{-41}\\ \\mathrm{J}^2}{1.2425841\\times 10^{-18}\\ \\mathrm{J^2/K}} \\approx 1.2878719\\times 10^{-23}\\ \\mathrm{J/K},\n$$\n四舍五入到六位有效数字为 $1.28787\\times 10^{-23}\\ \\mathrm{J/K}$。\n\n案例 2：$T = 300\\ \\mathrm{K}$，所有能量均等于 $8.0\\times 10^{-20}\\ \\mathrm{J}$。那么 $\\langle E^2 \\rangle - \\langle E \\rangle^2 \\approx 0$，所以\n$$\nC_V \\approx 0\\ \\mathrm{J/K}.\n$$\n\n案例 3：$T = 600\\ \\mathrm{K}$，能量为 $E_i = E_0 + d x_i$，其中 $E_0 = 1.05\\times 10^{-19}\\ \\mathrm{J}$，$d = 4.0\\times 10^{-21}\\ \\mathrm{J}$，且 $x_i$ 的模式与案例 1 相同。那么 $\\langle E^2 \\rangle - \\langle E \\rangle^2 \\approx 4 d^2 = 6.4\\times 10^{-41}\\ \\mathrm{J}^2$，并且 $k_B T^2 = (1.380649 \\times 10^{-23}\\ \\mathrm{J/K}) \\times 600^2 \\approx 4.97034 \\times 10^{-18}\\ \\mathrm{J^2/K}$。因此，\n$$\nC_V \\approx \\frac{6.4\\times 10^{-41}\\ \\mathrm{J}^2}{4.9703364\\times 10^{-18}\\ \\mathrm{J^2/K}} \\approx 1.2878719\\times 10^{-23}\\ \\mathrm{J/K},\n$$\n四舍五入到六位有效数字为 $1.28787\\times 10^{-23}\\ \\mathrm{J/K}$。\n\n案例 4：$T = 250\\ \\mathrm{K}$，能量为 $[\\,4.8\\times 10^{-20},\\ 5.2\\times 10^{-20}\\,]\\ \\mathrm{J}$。样本均值为 $\\langle E \\rangle \\approx 5.0\\times 10^{-20}\\ \\mathrm{J}$。中心化后的值为 $\\pm 2.0\\times 10^{-21}\\ \\mathrm{J}$。因此 $\\langle E^2 \\rangle - \\langle E \\rangle^2 \\approx (2.0\\times 10^{-21})^2 = 4.0\\times 10^{-42}\\ \\mathrm{J}^2$。在 $k_B T^2 = (1.380649 \\times 10^{-23}\\ \\mathrm{J/K}) \\times 250^2 \\approx 8.62906 \\times 10^{-19}\\ \\mathrm{J^2/K}$ 的情况下，\n$$\nC_V \\approx \\frac{4.0\\times 10^{-42}\\ \\mathrm{J}^2}{8.62905625\\times 10^{-19}\\ \\mathrm{J^2/K}} \\approx 4.6355011\\times 10^{-24}\\ \\mathrm{J/K},\n$$\n四舍五入到六位有效数字为 $4.63550\\times 10^{-24}\\ \\mathrm{J/K}$。\n\n程序应根据提供的列表使用所述关系直接计算这些值，并打印单行 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 以 $\\mathrm{J/K}$ 为单位，四舍五入到六位有效数字并用科学记数法表示。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nKB = 1.380649e-23  # J/K\n\ndef heat_capacity_from_fluctuations(energies, T):\n    # energies: numpy array in J, T in K\n    e = energies.astype(float)\n    mean_e = np.mean(e)\n    var_e = np.mean((e - mean_e) ** 2)  # ensemble variance estimate via finite-sample arithmetic mean\n    Cv = var_e / (KB * (T ** 2))\n    return Cv\n\ndef format_scientific_sig(x, sig=6):\n    # Format x in scientific notation with exactly 'sig' significant figures.\n    # Always produce one digit before the decimal point.\n    import math\n    if x == 0.0:\n        # Construct 0.00000...e+00 with (sig-1) decimals after the dot\n        return \"0.\" + \"0\"*(sig-1) + \"e+00\"\n    sign = \"-\" if x < 0 else \"\"\n    ax = abs(x)\n    exp = int(math.floor(math.log10(ax)))\n    mant = ax / (10 ** exp)\n    # round mantissa to have sig significant digits => (sig-1) digits after decimal\n    mant_rounded = round(mant, sig - 1)\n    # Handle rounding overflow like 9.99999 -> 10.00000\n    if mant_rounded >= 10.0:\n        mant_rounded /= 10.0\n        exp += 1\n    return f\"{sign}{mant_rounded:.{sig-1}f}e{exp:+03d}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"T\": 300.0,\n            \"E\": np.array([\n                1.14e-19, 1.16e-19, 1.18e-19, 1.20e-19, 1.22e-19, 1.24e-19, 1.26e-19,\n                1.14e-19, 1.16e-19, 1.18e-19, 1.20e-19, 1.22e-19, 1.24e-19, 1.26e-19\n            ])\n        },\n        # Case 2\n        {\n            \"T\": 300.0,\n            \"E\": np.array([8.0e-20] * 8)\n        },\n        # Case 3\n        {\n            \"T\": 600.0,\n            \"E\": np.array([\n                9.9e-20, 1.01e-19, 1.03e-19, 1.05e-19, 1.07e-19, 1.09e-19, 1.11e-19,\n                9.9e-20, 1.01e-19, 1.03e-19, 1.05e-19, 1.07e-19, 1.09e-19, 1.11e-19\n            ])\n        },\n        # Case 4\n        {\n            \"T\": 250.0,\n            \"E\": np.array([4.8e-20, 5.2e-20])\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        Cv = heat_capacity_from_fluctuations(case[\"E\"], case[\"T\"])  # J/K\n        results.append(format_scientific_sig(Cv, sig=6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2414232"}, {"introduction": "虽然许多系统可以用适合固定时间步长积分器的连续势来建模，但一些基本模型（如硬球或硬杆）涉及不连续的相互作用。对于这类系统，事件驱动分子动力学 (event-driven molecular dynamics) 提供了一种精确且高效的替代方法，它将系统从一次碰撞事件精确地推进到下一次。通过为一维硬杆系统编写模拟程序，你将掌握事件驱动算法的独特逻辑，这是一种与常见的时间步进方法互补的强大技术，它将加深你对分子动力学方法论的理解。[@problem_id:2414281]", "problem": "您的任务是为一维全同硬杆的分子动力学构建并实现一个完整的计算模型。考虑一个从位置 $x=0$ 到位置 $x=L$ 的一维区间，其中包含 $N$ 个长度为 $a$、质量为 $m$ 的全同硬杆。每根硬杆由其中心坐标 $x_i(t)$ 和速度 $v_i(t)$ 表示，其中 $i\\in\\{1,\\dots,N\\}$。系统不受外力作用。这些硬杆是理想刚体，不能重叠。当两根硬杆碰撞时，碰撞是瞬时的、完全弹性的。当一根硬杆与位于 $x=0$ 或 $x=L$ 的墙壁碰撞时，碰撞是瞬时的、完全弹性的。假设所有质量相等，且运动仅限于此一维直线上。\n\n物理规则如下：\n- 在两次碰撞之间，每个中心以恒定速度运动，因此 $x_i(t)$ 随时间线性演化。\n- 硬杆不能穿过墙壁；其中心坐标在任何时候都必须满足 $x_i(t)\\in[a/2,L-a/2]$。\n- 在两个全同质量物体之间的任何完全弹性碰撞中，碰撞后的速度通过交换两根碰撞硬杆的碰撞前速度得到。\n- 在硬杆与墙壁的任何完全弹性碰撞中，碰撞后的速度通过将碰撞前速度的符号反向得到，同时其中心保持在允许的区间内。\n\n所有物理量必须使用国际单位制（SI单位）。位置必须以米表示，速度以米/秒表示，时间以秒表示。所有初始中心位置是严格递增且不重叠的。此问题中不涉及角度量。\n\n您的任务是编写一个完整的、可运行的程序，该程序为下面每个指定的测试用例计算在时间 $T$ 时的最终中心位置列表 $\\{x_i(T)\\}_{i=1}^N$（单位为米），并按硬杆的初始索引（与严格递增的初始位置一致）排序。每个测试用例中的每个最终位置必须精确到小数点后六位。您的程序不能读取任何输入，并且必须打印单行输出，该输出将所有测试用例的结果聚合为一个由方括号括起的、逗号分隔的列表，其中每个元素本身是该测试用例的最终位置列表（也由方括号括起并以逗号分隔）。打印的行不得包含任何空格。例如，如果有两个测试用例，其最终位置列表分别为 $[x_{1,1},x_{1,2}]$ 和 $[x_{2,1}]$，则输出形式必须为 $[[x_{1,1},x_{1,2}],[x_{2,1}]]$, 并使用要求的舍入规则。\n\n请使用以下测试套件，其设计旨在覆盖一般行为、墙壁反射、对碰撞以及不同碰撞类型的序列。在每种情况下，报告所有最终中心位置（单位为米），并精确到小数点后六位。\n\n- 测试用例 $1$（一般多粒子演化）：$N=3$，$L=10.0\\,\\mathrm{m}$，$a=1.0\\,\\mathrm{m}$，$T=10.0\\,\\mathrm{s}$，初始中心位置 $[1.000000\\,\\mathrm{m},4.000000\\,\\mathrm{m},7.000000\\,\\mathrm{m}]$，初始速度 $[1.000000\\,\\mathrm{m/s},-0.500000\\,\\mathrm{m/s},0.200000\\,\\mathrm{m/s}]$。\n- 测试用例 $2$（单根硬杆与墙壁反射）：$N=1$，$L=5.0\\,\\mathrm{m}$，$a=0.5\\,\\mathrm{m}$，$T=1.0\\,\\mathrm{s}$，初始中心位置 $[1.000000\\,\\mathrm{m}]$，初始速度 $[-2.000000\\,\\mathrm{m/s}]$。\n- 测试用例 $3$（两根硬杆迎头碰撞）：$N=2$，$L=4.0\\,\\mathrm{m}$，$a=0.6\\,\\mathrm{m}$，$T=1.0\\,\\mathrm{s}$，初始中心位置 $[1.000000\\,\\mathrm{m},2.500000\\,\\mathrm{m}]$，初始速度 $[1.000000\\,\\mathrm{m/s},-1.000000\\,\\mathrm{m/s}]$。\n- 测试用例 $4$（墙壁反射后发生硬杆-硬杆碰撞的序列）：$N=3$，$L=6.0\\,\\mathrm{m}$，$a=1.0\\,\\mathrm{m}$，$T=5.0\\,\\mathrm{s}$，初始中心位置 $[0.700000\\,\\mathrm{m},2.000000\\,\\mathrm{m},3.500000\\,\\mathrm{m}]$，初始速度 $[-1.000000\\,\\mathrm{m/s},0.000000\\,\\mathrm{m/s},-0.200000\\,\\mathrm{m/s}]$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个由方括号括起且无空格的逗号分隔列表。每个元素是针对一个测试用例的、由方括号括起的逗号分隔的最终中心位置列表，其中每个数字都以米为单位，并精确到小数点后六位。对于上述四个测试用例，输出必须类似于 $[[x_{1,1},x_{1,2},x_{1,3}],[x_{2,1}],[x_{3,1},x_{3,2}],[x_{4,1},x_{4,2},x_{4,3}]]$，其中每个 $x_{k,j}$ 是按规定舍入并以米表示的十进制数。", "solution": "所提出的问题是计算物理学中的一个标准练习，具体来说是一维硬杆气体的模拟。这是一个基于经典力学原理的、适定的问题。我的职责是验证其前提，如果前提有效，则提供一个严谨的、算法上合理的解决方案。\n\n**问题验证**\n\n首先，我已检查了问题陈述的逻辑一致性、科学合理性和完整性。\n给定条件是：\n- 一个长度为 $L$ 的一维空间。\n- $N$ 个长度为 $a$、质量为 $m$ 的全同硬杆。\n- 硬杆 $i$ 的状态由其中心位置 $x_i(t)$ 和速度 $v_i(t)$ 描述。\n- 每个硬杆 $i$ 的中心被限制在区间 $[a/2, L-a/2]$ 内。\n- 碰撞之间的运动是匀速的：$x_i(t)$ 是线性的。\n- 碰撞规则已提供：\n    1. 对于两根硬杆之间的碰撞，它们的速度会相互交换。这与一维空间中两个全同质量物体的弹性碰撞一致，其中动量守恒和动能守恒决定了 $v_i' = v_j$ 和 $v_j' = v_i$。\n    2. 对于硬杆与墙壁之间的碰撞，硬杆的速度反向。这对应于完全弹性反射。\n- 每个测试用例所需的所有参数（$N$, $L$, $a$, $T$）和初始条件（$x_i(0)$, $v_i(0)$）都已指定。\n\n该问题具有科学依据，是一个经典的物理模型系统。为所有测试用例提供的初始条件在物理上是有效的；硬杆不重叠且在指定边界内。一个潜在的模糊性可能来自于同时发生的碰撞（即超过两个粒子在同一瞬间碰撞）。对所提供的测试用例的分析揭示了一个同时事件的实例，但这些事件涉及不相交的粒子集合。此类情况是明确的，可以被一致地解决。因此，该问题被认定为有效。\n\n**方法论：事件驱动模拟**\n\n该系统的动力学是分段线性的，状态变化仅在离散的时间点（即碰撞时）发生。这种结构适合采用事件驱动的模拟方法，对于这类问题，该方法比固定时间步长法效率更高、更准确。模拟通过计算到下一个碰撞事件的时间、将系统状态推进到该时刻，然后通过更新相关粒子的速度来解决碰撞，从而进行。\n\n在任何时间 $t$，系统的状态由位置和速度集合 $\\{x_i(t), v_i(t)\\}_{i=1}^N$ 给出。在事件之间，硬杆 $i$ 的位置根据自由粒子的运动方程演化：\n$$x_i(t + \\Delta t) = x_i(t) + v_i(t) \\Delta t$$\n\n模拟的核心是确定到下一个事件的时间间隔 $\\Delta t$。事件有两种类型：两个相邻硬杆之间的碰撞，以及硬杆与墙壁的碰撞。\n\n**1. 硬杆-硬杆碰撞时间**\n\n两个相邻硬杆 $i$ 和 $i+1$（假设 $x_i < x_{i+1}$）之间的碰撞发生在它们中心之间的距离等于其长度 $a$ 时，即 $x_{i+1}(t) - x_i(t) = a$。设当前时间为 $t_{curr}$，位置为 $x_i$ 和 $x_{i+1}$，速度为 $v_i$ 和 $v_{i+1}$。我们寻求时间间隔 $\\Delta t$ 使得：\n$$x_{i+1}(t_{curr} + \\Delta t) - x_i(t_{curr} + \\Delta t) = a$$\n$$(x_{i+1} + v_{i+1}\\Delta t) - (x_i + v_i\\Delta t) = a$$\n求解 $\\Delta t$，我们得到对 $(i, i+1)$ 的碰撞时间：\n$$\\Delta t_{i,i+1} = \\frac{x_{i+1} - x_i - a}{v_i - v_{i+1}}$$\n只有当硬杆相互靠近时，碰撞才可能发生，这意味着相对速度 $v_i - v_{i+1}$ 必须为正。由于初始间距 $x_{i+1} - x_i$ 大于 $a$，分子为正。因此，我们只考虑 $\\Delta t_{i,i+1} > 0$ 的情况。在一个硬杆不能相互穿过的一维系统中，一根硬杆只能与其直接相邻的硬杆碰撞。因此，我们只需要为 $i \\in \\{1, \\dots, N-1\\}$ 的相邻对 $(i, i+1)$ 计算碰撞时间。\n\n**2. 硬杆-墙壁碰撞时间**\n\n当硬杆 $i$ 的中心到达其允许区域 $[a/2, L-a/2]$ 的边界时，它会与墙壁碰撞。\n- 与左墙（位于 $x=0$）的碰撞：中心到达 $x_i = a/2$。\n  $$x_i + v_i \\Delta t = a/2 \\implies \\Delta t_{i,L} = \\frac{a/2 - x_i}{v_i}$$\n  对于未来的碰撞，$\\Delta t_{i,L}$ 必须为正。由于 $x_i > a/2$，分子为负，因此只有当 $v_i < 0$ 时才可能发生碰撞。\n- 与右墙（位于 $x=L$）的碰撞：中心到达 $x_i = L-a/2$。\n  $$x_i + v_i \\Delta t = L - a/2 \\implies \\Delta t_{i,R} = \\frac{L - a/2 - x_i}{v_i}$$\n  对于未来的碰撞，$\\Delta t_{i,R}$ 必须为正。由于 $x_i < L-a/2$，分子为正，因此只有当 $v_i > 0$ 时才可能发生碰撞。\n\n**模拟算法**\n\n模拟通过在一个循环中执行以下步骤，来从时间 $t=0$ 迭代到 $T$：\n\n1.  初始化系统状态：模拟时间 $t \\leftarrow 0$，位置 $x_i \\leftarrow x_i(0)$，以及速度 $v_i \\leftarrow v_i(0)$。\n2.  当 $t < T$ 时：\n    a. 计算所有可能的未来碰撞时间：所有相邻对的 $\\Delta t_{i,i+1}$，以及所有硬杆的 $\\Delta t_{i,L}$, $\\Delta t_{i,R}$。只收集正的、非零的结果。必须使用一个小的正容差（$\\epsilon > 0$）进行时间比较，以避免由浮点运算引起的无限循环。\n    b. 找到这些有效碰撞时间中的最小值 $\\Delta t_{min}$。如果没有未来碰撞的可能，则将 $\\Delta t_{min}$ 设为无穷大。\n    c. 确定下一次演化的时间步长：$\\Delta t_{step} = \\min(\\Delta t_{min}, T - t)$。\n    d. 演化系统状态：推进当前时间 $t \\leftarrow t + \\Delta t_{step}$，并更新所有位置：$x_i \\leftarrow x_i + v_i \\Delta t_{step}$ 对于所有 $i \\in \\{1, \\dots, N\\}$。\n    e. 如果发生了碰撞（即 $\\Delta t_{step} = \\Delta t_{min}$），则识别出在此时刻发生的所有碰撞事件。对于每个事件，根据碰撞规则更新相关粒子的速度：\n        - 对于 $i$ 和 $j$ 之间的硬杆-硬杆碰撞：$v_i' = v_j$ 和 $v_j' = v_i$。\n        - 对于涉及硬杆 $i$ 的墙壁碰撞：$v_i' = -v_i$。\n        如果多个不相交的碰撞同时发生，则应用所有相应的速度更新。\n3.  循环终止时，报告最终位置 $\\{x_i(T)\\}$。\n\n该算法保证系统从一个事件精确地演化到下一个事件，从而提供精确的轨迹。实现应使用具有足够精度的浮点数，并在比较中小心处理以确保正确性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D hard rod dynamics problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {'N': 3, 'L': 10.0, 'a': 1.0, 'T': 10.0, 'x0': [1.0, 4.0, 7.0], 'v0': [1.0, -0.5, 0.2]},\n        {'N': 1, 'L': 5.0, 'a': 0.5, 'T': 1.0, 'x0': [1.0], 'v0': [-2.0]},\n        {'N': 2, 'L': 4.0, 'a': 0.6, 'T': 1.0, 'x0': [1.0, 2.5], 'v0': [1.0, -1.0]},\n        {'N': 3, 'L': 6.0, 'a': 1.0, 'T': 5.0, 'x0': [0.7, 2.0, 3.5], 'v0': [-1.0, 0.0, -0.2]},\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        a = case['a']\n        T = case['T']\n        \n        x = np.array(case['x0'], dtype=float)\n        v = np.array(case['v0'], dtype=float)\n        \n        t = 0.0\n        # A small tolerance to prevent re-collision and floating point issues\n        epsilon = 1e-12\n\n        while T - t > epsilon:\n            \n            collision_times = []\n            \n            # Rod-rod collision times\n            for i in range(N - 1):\n                v_rel = v[i] - v[i+1]\n                if v_rel > 0:\n                    dist = x[i+1] - x[i] - a\n                    dt = dist / v_rel\n                    if dt > epsilon:\n                        collision_times.append({'dt': dt, 'type': 'rod-rod', 'indices': (i, i+1)})\n\n            # Rod-wall collision times\n            left_bound = a / 2.0\n            right_bound = L - a / 2.0\n            for i in range(N):\n                if v[i] < 0:\n                    dt = (left_bound - x[i]) / v[i]\n                    if dt > epsilon:\n                        collision_times.append({'dt': dt, 'type': 'wall', 'indices': (i, 'left')})\n                elif v[i] > 0:\n                    dt = (right_bound - x[i]) / v[i]\n                    if dt > epsilon:\n                        collision_times.append({'dt': dt, 'type': 'wall', 'indices': (i, 'right')})\n\n            if not collision_times:\n                dt_step = T - t\n            else:\n                min_dt = min(event['dt'] for event in collision_times)\n                dt_step = min(min_dt, T - t)\n            \n            # Advance system\n            x += v * dt_step\n            t += dt_step\n\n            # If a collision occurred, resolve it\n            if dt_step < T - t + epsilon and collision_times:\n                # Find all events happening at min_dt\n                v_pre_collision = v.copy()\n                events_to_resolve = [event for event in collision_times if abs(event['dt'] - min_dt) < epsilon]\n                \n                for event in events_to_resolve:\n                    if event['type'] == 'rod-rod':\n                        i, j = event['indices']\n                        v[i], v[j] = v_pre_collision[j], v_pre_collision[i]\n                    elif event['type'] == 'wall':\n                        i, _ = event['indices']\n                        v[i] = -v_pre_collision[i]\n        \n        all_results.append(list(x))\n\n    # Format the final output string exactly as required\n    formatted_results = []\n    for res_list in all_results:\n        s = '[' + ','.join(f'{val:.6f}' for val in res_list) + ']'\n        formatted_results.append(s)\n    \n    print('[' + ','.join(formatted_results) + ']')\n\nsolve()\n```", "id": "2414281"}]}