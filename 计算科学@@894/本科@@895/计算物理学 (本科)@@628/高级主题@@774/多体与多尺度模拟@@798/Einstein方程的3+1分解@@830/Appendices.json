{"hands_on_practices": [{"introduction": "3+1分解方法的第一步是将时空视为一系列三维空间“切片”的集合。此方法的一个关键步骤是理解这些单个切片的几何特性。本练习将引导你计算三维里奇标量 $R$，它是描述给定空间度规 $\\gamma_{ij}$ 内蕴曲率的基本量度 [@problem_id:2370101]。", "problem": "给定与广义相对论（GR）的 $(3+1)$ 分解中空间超曲面上的空间度规 $\\gamma_{ij}$ 相关的三维里奇标量 $R$。请考虑以下两族空间度规，每一族都依赖于参数和坐标时间 $t$：\n\n1) Bianchi I 族（均匀、各向异性、空间平坦）：\n对于每个固定的 $t$，空间度规为\n$$\n\\gamma_{ij}(t,\\mathbf{x})=\\mathrm{diag}\\left(a_1(t)^2,\\,a_2(t)^2,\\,a_3(t)^2\\right),\n$$\n其标度因子\n$$\na_i(t)=a_{i0}\\,e^{H_i t},\n$$\n其中 $a_{i0}>0$ 和 $H_i$ 是常数。在每个切片上，度规分量与空间坐标 $\\mathbf{x}=(x,y,z)$ 无关。\n\n2) 共形平坦、高斯凸起族（非均匀）：\n对于每个固定的 $t$，空间度规为\n$$\n\\gamma_{ij}(t,\\mathbf{x})=\\psi(t,\\mathbf{x})^4\\,\\delta_{ij},\n$$\n其中\n$$\n\\psi(t,\\mathbf{x})=1+\\varepsilon\\,\\cos(\\omega t)\\,\\exp\\!\\left(-\\frac{x^2+y^2+z^2}{\\sigma^2}\\right),\n$$\n其中 $\\varepsilon$、$\\omega>0$ 和 $\\sigma>0$ 是常数。\n\n任务：对于下面指定的每一组参数，计算空间度规 $\\gamma_{ij}$ 在空间点 $\\mathbf{x}=\\mathbf{0}$ 和所列出的坐标时间 $t$ 处的三维里奇标量 $R$。将所有量视为无量纲。角度必须以弧度为单位进行解释。您的程序必须以实数（浮点数）形式输出结果。\n\n测试套件（每一项都是一个独立的测试用例）：\n- 测试 1（共形平坦、高斯凸起）：\n  - $\\varepsilon=0.1$, $\\sigma=1.0$, $\\omega=1.0$, $t=0.0$。\n- 测试 2（Bianchi I）：\n  - $a_{10}=1.2$, $a_{20}=1.1$, $a_{30}=0.9$, $H_1=0.10$, $H_2=-0.05$, $H_3=0.20$, $t=3.0$。\n- 测试 3（共形平坦、高斯凸起）：\n  - $\\varepsilon=0.2$, $\\sigma=0.75$, $\\omega=1.0$, $t=\\pi/2$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。这些条目必须是测试 1、测试 2 和测试 3 在 $\\mathbf{x}=\\mathbf{0}$ 处的三个里奇标量值 $R$，按此顺序排列，并表示为无量纲实数。", "solution": "问题陈述已经过验证，被认为是科学上可靠、适定且客观的。它展示了微分几何应用于广义相对论的一个标准计算，特别是在 $3+1$ 形式的背景下。所有必要的参数和条件都已提供。我现在开始推导解答。\n\n任务是针对两类度规，在指定的坐标时间 $t$ 和空间位置 $\\mathbf{x}$ 处，计算空间度规 $\\gamma_{ij}$ 的三维里奇标量 $R$。\n\n**情况 1：Bianchi I 度规（测试 2）**\n\nBianchi I 族的空间度规由下式给出：\n$$\n\\gamma_{ij}(t,\\mathbf{x})=\\mathrm{diag}\\left(a_1(t)^2,\\,a_2(t)^2,\\,a_3(t)^2\\right)\n$$\n该度规的关键特性是其分量 $\\gamma_{ij}$ 仅是坐标时间 $t$ 的函数；它们没有空间依赖性。问题正确地指出，此度规描述了一个空间平坦的几何。\n\n空间里奇标量 $R$ 由黎曼曲率张量 $R^i_{~jkl}$ 构成，而黎曼曲率张量又由克里斯托费尔符号 $\\Gamma^k_{ij}$ 及其空间导数构成。克里斯托费尔符号定义为：\n$$\n\\Gamma^k_{ij} = \\frac{1}{2}\\gamma^{kl}\\left(\\partial_i \\gamma_{jl} + \\partial_j \\gamma_{il} - \\partial_l \\gamma_{ij}\\right)\n$$\n这里，$\\partial_i$ 表示对空间坐标 $x^i$ 的偏导数。由于 $\\gamma_{ij}$ 与所有空间坐标 $(x,y,z)$ 无关，因此度规分量的所有空间导数都恒等于零：\n$$\n\\partial_k \\gamma_{ij} = 0 \\quad \\forall i,j,k \\in \\{1,2,3\\}\n$$\n因此，所有克里斯托费尔符号都为零：$\\Gamma^k_{ij} = 0$。\n因此，黎曼张量 $R^i_{~jkl} = \\partial_k \\Gamma^i_{~jl} - \\partial_l \\Gamma^i_{~jk} + \\Gamma^p_{~jl} \\Gamma^i_{~pk} - \\Gamma^p_{~jk} \\Gamma^i_{~pl}$ 恒等于零。这意味着里奇张量 $R_{ij} = R^k_{~ikj}$ 和里奇标量 $R = \\gamma^{ij}R_{ij}$ 也恒等于零。\n$$\nR = 0\n$$\n此结果与参数 $a_{i0}$、$H_i$ 和时间 $t$ 的值无关。因此，对于测试 2，里奇标量为 $0.0$。\n\n**情况 2：共形平坦、高斯凸起度规（测试 1 和测试 3）**\n\n该度规以共形平坦形式给出：\n$$\n\\gamma_{ij}(t,\\mathbf{x})=\\psi(t,\\mathbf{x})^4\\,\\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是平坦的欧几里得度规。对于形式为 $\\gamma_{ij} = \\Phi^4 \\eta_{ij}$（其中 $\\eta_{ij}$ 是平坦度规）的 3 维维数，里奇标量 $R$ 由标准公式给出：\n$$\nR = -8\\Phi^{-5}\\Delta_{\\eta}\\Phi\n$$\n在我们的问题中，共形因子是 $\\Phi = \\psi$，背景度规是平坦的欧几里得度规，因此 $\\Delta_{\\eta}$ 是笛卡尔坐标系中的标准拉普拉斯算子，$\\Delta = \\partial_x^2 + \\partial_y^2 + \\partial_z^2$。公式为：\n$$\nR = -8\\psi^{-5}\\Delta\\psi\n$$\n函数 $\\psi$ 由下式给出：\n$$\n\\psi(t,\\mathbf{x})=1+\\varepsilon\\,\\cos(\\omega t)\\,\\exp\\!\\left(-\\frac{x^2+y^2+z^2}{\\sigma^2}\\right) = 1+\\varepsilon\\,\\cos(\\omega t)\\,\\exp\\!\\left(-\\frac{r^2}{\\sigma^2}\\right)\n$$\n其中 $r^2 = x^2+y^2+z^2$。为求 $R$，我们首先计算 $\\psi$ 的拉普拉斯值。令 $C(t) = \\varepsilon\\cos(\\omega t)$。\n$$\n\\Delta\\psi = \\Delta\\left(1+C(t)e^{-r^2/\\sigma^2}\\right) = C(t)\\Delta\\left(e^{-r^2/\\sigma^2}\\right)\n$$\n高斯函数的拉普拉斯算子是一个标准结果：\n$$\n\\Delta\\left(e^{-r^2/\\sigma^2}\\right) = \\left(-\\frac{6}{\\sigma^2} + \\frac{4r^2}{\\sigma^4}\\right) e^{-r^2/\\sigma^2}\n$$\n因此，$\\psi$ 的拉普拉斯值为：\n$$\n\\Delta\\psi = \\varepsilon\\cos(\\omega t)\\left(-\\frac{6}{\\sigma^2} + \\frac{4r^2}{\\sigma^4}\\right) e^{-r^2/\\sigma^2}\n$$\n问题要求在空间原点 $\\mathbf{x}=\\mathbf{0}$ 处计算 $R$ 的值，这对应于 $r=0$。\n在 $r=0$ 处，$\\psi$ 和 $\\Delta\\psi$ 的表达式显著简化：\n$$\n\\psi(t, \\mathbf{0}) = 1+\\varepsilon\\,\\cos(\\omega t)\\,e^0 = 1+\\varepsilon\\,\\cos(\\omega t)\n$$\n$$\n\\Delta\\psi(t, \\mathbf{0}) = \\varepsilon\\cos(\\omega t)\\left(-\\frac{6}{\\sigma^2} + 0\\right)e^0 = -\\frac{6\\varepsilon\\cos(\\omega t)}{\\sigma^2}\n$$\n将这些代入原点处的里奇标量公式：\n$$\nR(t, \\mathbf{0}) = -8 \\left( \\psi(t, \\mathbf{0}) \\right)^{-5} \\left( \\Delta\\psi(t, \\mathbf{0}) \\right) = -8 \\left( 1+\\varepsilon\\cos(\\omega t) \\right)^{-5} \\left( -\\frac{6\\varepsilon\\cos(\\omega t)}{\\sigma^2} \\right)\n$$\n这可以简化为用于计算的最终表达式：\n$$\nR(t, \\mathbf{0}) = \\frac{48 \\varepsilon \\cos(\\omega t)}{\\sigma^2 (1+\\varepsilon \\cos(\\omega t))^{5}}\n$$\n\n我们现在将此公式应用于具体的测试用例。\n\n**测试 1：**\n参数：$\\varepsilon=0.1$, $\\sigma=1.0$, $\\omega=1.0$, $t=0.0$。\n$\\cos(\\omega t) = \\cos(1.0 \\times 0.0) = \\cos(0) = 1$。\n$$\nR = \\frac{48 \\times 0.1 \\times 1}{1.0^2 \\times (1+0.1 \\times 1)^{5}} = \\frac{4.8}{(1.1)^5} = \\frac{4.8}{1.61051} \\approx 2.97998647\n$$\n\n**测试 3：**\n参数：$\\varepsilon=0.2$, $\\sigma=0.75$, $\\omega=1.0$, $t=\\pi/2$。\n$\\cos(\\omega t) = \\cos(1.0 \\times \\pi/2) = \\cos(\\pi/2)$。\n从解析上看，$\\cos(\\pi/2) = 0$。这意味着 $R$ 表达式的分子为零，因此 $R=0.0$。由于 $\\pi$ 的浮点表示，数值计算将得到一个非常接近于零的值。\n\n**结果总结：**\n- 测试 1（共形平坦）：$R \\approx 2.97998647$\n- 测试 2（Bianchi I）：$R = 0.0$\n- 测试 3（共形平坦）：$R \\approx 0.0$（数值上，为一个 $10^{-15}$ 数量级的值）\n\n最终值将由程序计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the 3-Ricci scalar R for given spatial metrics at specified points.\n    \"\"\"\n    \n    # Define the test cases from the problem statement. The order must be preserved.\n    test_cases = [\n        {\n            \"type\": \"conformally_flat\",\n            \"params\": {\"eps\": 0.1, \"sigma\": 1.0, \"omega\": 1.0, \"t\": 0.0}\n        },\n        {\n            \"type\": \"bianchi_i\",\n            \"params\": {\n                \"a10\": 1.2, \"a20\": 1.1, \"a30\": 0.9,\n                \"H1\": 0.10, \"H2\": -0.05, \"H3\": 0.20,\n                \"t\": 3.0\n            }\n        },\n        {\n            \"type\": \"conformally_flat\",\n            \"params\": {\"eps\": 0.2, \"sigma\": 0.75, \"omega\": 1.0, \"t\": np.pi / 2.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"type\"] == \"bianchi_i\":\n            # For a spatially flat Bianchi I metric, the spatial Ricci scalar R is always 0.\n            # The metric components are independent of spatial coordinates, leading to\n            # zero Christoffel symbols and thus a zero Riemann tensor.\n            result = 0.0\n            results.append(result)\n        \n        elif case[\"type\"] == \"conformally_flat\":\n            # For a conformally flat metric gamma_ij = psi^4 * delta_ij, the Ricci scalar\n            # at the origin x=0 is given by the formula:\n            # R(t, 0) = (48 * eps * cos(omega*t)) / (sigma^2 * (1 + eps * cos(omega*t))^5)\n            \n            p = case[\"params\"]\n            eps = p[\"eps\"]\n            sigma = p[\"sigma\"]\n            omega = p[\"omega\"]\n            t = p[\"t\"]\n            \n            cos_wt = np.cos(omega * t)\n            \n            # The denominator is guaranteed to be non-zero for the given test cases\n            # as 1 + eps*cos(wt) > 0 for small epsilon.\n            numerator = 48.0 * eps * cos_wt\n            denominator = (sigma**2) * ((1.0 + eps * cos_wt)**5)\n            \n            # Note: For t=pi/2, cos_wt is numerically close to zero but not exactly zero\n            # due to floating point representation of pi, leading to a result of order 1e-16.\n            # This is the correct numerical result.\n            result = numerator / denominator\n            results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2370101"}, {"introduction": "理解了单个空间切片的几何后，下一步是探究这些切片如何随时间“堆叠”。退移函数 $\\alpha$ 控制着相邻切片间固有时流逝的速率。本练习将让你探索一种被称为“测地切片”的特定选择（其中 $\\alpha=1$），并揭示其引人注目的物理后果——坐标线向奇点汇聚的趋势 [@problem_id:2370126]。", "problem": "考虑一个由 Schwarzschild 解描述的球对称真空时空，并将其用 $3+1$ (Arnowitt–Deser–Misner, ADM) 分解来表述。在这种分解中，时空度规由 lapse 函数 $\\alpha$、shift 向量 $\\beta^i$ 和空间度规 $\\gamma_{ij}$ 写出。在测地切片中，lapse 函数被固定为常数值 $\\alpha = 1$，因此时间坐标测量的是沿着与空间超曲面正交的世界线汇的固有时。在一个与 Schwarzschild 几何一致且能穿透视界的表示中，这个选择对应于一种切片，其中正交观测者遵循从空间无穷远处静止开始自由下落的类时测地线。\n\n您的任务是基于这些基本原理进行推理，并构建一个最小的自洽模型，以捕捉测地切片如何使坐标线趋向于向奇点汇聚。按以下步骤进行。\n\n1) 从 Schwarzschild 时空和 $3+1$ 分解的定义（lapse 函数 $\\alpha$、shift 向量 $\\beta^i$、空间度规 $\\gamma_{ij}$）出发，使用测地切片条件 $\\alpha = 1$，并考虑从空间无穷远处静止开始径向向内下落的类时测地线汇。在球对称静态真空时空中，使用径向运动的测地线方程和适当的守恒量，推导一个自由下落观测者的面积半径 $r(t)$ 所满足的常微分方程，其中 $t$ 是坐标时，由于 $\\alpha = 1$ 而等于观测者的固有时。求解这个常微分方程，得到用 $t=0$ 时的初始面积半径 $r_0$ 和质量参数 $M$ 表示的 $r(t)$。在几何化单位制中进行计算，其中引力常数 $G$ 和光速 $c$ 均设为 $1$。\n\n2) 为了量化汇聚，考虑一个由初始面积半径 $r_0$ 标记的此类径向测地线的单参数族（汇）。令 $r(t;r_0)$ 表示在 $t=0$ 时面积半径为 $r_0$ 的测地线在时间 $t$ 的面积半径。在固定的 $t$ 下，定义径向映射的雅可比行列式 $J(t;r_0) = \\partial r(t;r_0)/\\partial r_0$。在球对称中，一个薄共动壳层的物理体积与 $r^2 \\mathrm{d}r$ 成正比，因此定义共动体积缩放因子\n$$\nS(t;r_0) = \\frac{r(t;r_0)^2 \\, J(t;r_0)}{r_0^2},\n$$\n该因子衡量一个小的共动壳层的体积相对于其初始体积的变化。推导 $S(t;r_0)$ 的闭式表达式，并确定 $S(t;r_0)$ 达到零的有限时间 $t_{\\mathrm{sing}}(r_0, M)$，这标志着测地线汇在物理奇点处完全汇聚。将 $t_{\\mathrm{sing}}$ 和 $S(t;r_0)$ 仅用 $r_0$、$M$ 和 $t$ 表示。在几何化单位制中，$t$ 和 $M$ 具有相同的量纲；时间以 $M$ 为单位报告，半径使用与 $M$ 相同的长度单位。\n\n3) 将测地切片更新实现为一个程序，对于给定的质量 $M$、初始面积半径 $r_0$ 和时间 $t \\ge 0$，该程序评估以下输出：\n- 面积半径 $r(t;r_0)$，使用与 $M$ 相同的长度单位。\n- 无量纲的共动体积缩放因子 $S(t;r_0)$。\n如果 $t \\ge t_{\\mathrm{sing}}(r_0, M)$，则取 $r(t;r_0) = 0$ 和 $S(t;r_0) = 0$ 来表示测地线汇已在奇点处汇聚。所有计算必须在 $G = c = 1$ 的几何化单位制中进行。不需要角度。\n\n测试套件和答案规范：\n使用以下五个测试用例，每个用例指定为三元组 $(M, r_0, t)$，所有量均采用 $G = c = 1$ 的几何化单位：\n- 测试 1：$(M, r_0, t) = (1.0, 10.0, 1.0)$。\n- 测试 2：$(M, r_0, t) = (1.0, 4.0, \\tfrac{1}{2} \\, t_{\\mathrm{sing}}(4.0, 1.0))$。\n- 测试 3：$(M, r_0, t) = (1.0, 2.0, 0.99 \\, t_{\\mathrm{sing}}(2.0, 1.0))$。\n- 测试 4：$(M, r_0, t) = (1.0, 3.0, 1.5 \\, t_{\\mathrm{sing}}(3.0, 1.0))$。\n- 测试 5：$(M, r_0, t) = (2.0, 100.0, 1.0)$。\n\n您的程序应为每个测试用例计算浮点数对 $(r(t;r_0), S(t;r_0))$，并将所有五个用例的结果汇总到一行输出中，形式为用方括号括起来的逗号分隔列表，顺序为\n$[r_1, S_1, r_2, S_2, r_3, S_3, r_4, S_4, r_5, S_5]$，\n其中 $r_k$ 和 $S_k$ 对应于测试用例 $k$。所有数字必须以指定单位打印为十进制浮点数。程序必须是自包含的，并且不需要任何输入。", "solution": "我们从时空的 $3+1$ (Arnowitt–Deser–Misner, ADM) 分解开始，其中线元可以写为\n$$\n\\mathrm{d}s^2 = -\\alpha^2 \\mathrm{d}t^2 + \\gamma_{ij} \\left( \\mathrm{d}x^i + \\beta^i \\mathrm{d}t \\right) \\left( \\mathrm{d}x^j + \\beta^j \\mathrm{d}t \\right),\n$$\n其中 $\\alpha$ 是 lapse 函数，$\\beta^i$ 是 shift 向量，$\\gamma_{ij}$ 是空间度规。在测地切片中，lapse 函数固定为 $\\alpha = 1$，因此时间坐标 $t$ 是沿着与空间切片正交的世界线汇测量的固有时。\n\n对于 Schwarzschild 时空（真空、球对称、渐近平直，质量参数为 $M$），存在一种与 $\\alpha = 1$ 一致且能穿透视界的度规形式，即 Painlevé–Gullstrand 切片。在这种切片中，正交观测者从空间无穷远处静止开始径向自由下落；他们的世界线是类时测地线。我们将利用这些径向测地线的性质来构建一个用于汇聚的最小模型。\n\n步骤 1：在 $\\alpha=1$ 的测地切片中的径向测地线。\n考虑一条从空间无穷远处静止开始的径向类时测地线。在 Schwarzschild 时空中，由于其定常性，沿着测地线存在一个单位质量守恒能量 $E$。对于从无穷远处静止开始的自由下落，有 $E = 1$。在一个适用于这些测地线且 $\\alpha = 1$ 的穿透视界的度规形式中，坐标时 $t$ 等于沿测地线的固有时，因为正交观测者与测地线汇是共动的。对于径向运动，面积半径 $r$ 满足测地线方程，利用 $E = 1$ 和球对称性，可推得有效的一维运动方程\n$$\n\\frac{\\mathrm{d}r}{\\mathrm{d}t} = - \\sqrt{\\frac{2 M}{r}},\n$$\n其中负号对应于向内下落。此方程可以通过组合四维速度 $u^\\mu$ 的 $E = -u_t$ 和归一化条件 $u^\\mu u_\\mu = -1$，并利用在所选切片中坐标时等于沿测地线汇的固有时这一事实得到。平方根源于 Schwarzschild 几何中径向自由下落的类牛顿有效势，而此处坐标时与固有时相等是适用于该汇的 $\\alpha=1$ 测地切片的一个特有性质。\n\n这个常微分方程是可分离的。写作\n$$\n\\frac{\\mathrm{d}r}{\\mathrm{d}t} = - \\sqrt{2 M} \\, r^{-1/2}.\n$$\n两边同乘以 $r^{1/2}$：\n$$\nr^{1/2} \\, \\mathrm{d}r = - \\sqrt{2 M} \\, \\mathrm{d}t.\n$$\n注意\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left( r^{3/2} \\right) = \\frac{3}{2} r^{1/2} \\frac{\\mathrm{d}r}{\\mathrm{d}t}.\n$$\n因此，\n$$\n\\frac{2}{3} \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left( r^{3/2} \\right) = - \\sqrt{2 M}.\n$$\n从 $t = 0$ 且 $r(0) = r_0$ 积分到某个 $t \\ge 0$：\n$$\n\\frac{2}{3} \\left[ r(t)^{3/2} - r_0^{3/2} \\right] = - \\sqrt{2 M} \\, t.\n$$\n整理可得\n$$\nr(t)^{3/2} = r_0^{3/2} - \\frac{3}{2} \\sqrt{2 M} \\, t,\n$$\n因此显式解为\n$$\nr(t; r_0, M) = \\left( r_0^{3/2} - \\frac{3}{2} \\sqrt{2 M} \\, t \\right)^{2/3}.\n$$\n该解在括号内变为零之前有效。$r$ 达到零的有限时间是到达奇点的时间\n$$\nt_{\\mathrm{sing}}(r_0, M) = \\frac{2}{3} \\frac{r_0^{3/2}}{\\sqrt{2 M}}.\n$$\n当 $t \\ge t_{\\mathrm{sing}}$ 时，该公式会产生非实数或非物理的值；在物理上，测地线汇到达了奇点。在我们的模型中，当 $t \\ge t_{\\mathrm{sing}}$ 时，我们取 $r(t) = 0$。\n\n步骤 2：由共动体积缩放因子量化的汇聚。\n考虑一个由初始面积半径 $r_0$ 标记的此类径向测地线的汇。在固定的 $t$ 下，映射 $r_0 \\mapsto r(t;r_0, M)$ 的雅可比行列式为\n$$\nJ(t; r_0, M) = \\frac{\\partial r(t; r_0, M)}{\\partial r_0}.\n$$\n从显式解出发，\n$$\nr(t) = \\left( r_0^{3/2} - A t \\right)^{2/3}, \\quad \\text{其中 } A \\equiv \\frac{3}{2} \\sqrt{2 M}.\n$$\n对 $r_0$ 求导：\n$$\nJ(t; r_0, M) = \\frac{2}{3} \\left( r_0^{3/2} - A t \\right)^{-1/3} \\cdot \\frac{3}{2} r_0^{1/2} = r_0^{1/2} \\left( r_0^{3/2} - A t \\right)^{-1/3}.\n$$\n在球对称中，位于面积半径 $r$ 处、厚度为 $\\mathrm{d}r$ 的薄壳的固有体积与 $4 \\pi r^2 \\mathrm{d}r$ 成比例。因此，一个由厚度 $\\mathrm{d}r_0$ 标记的共动壳层的体积与 $r^2 J \\, \\mathrm{d}r_0$ 成正比。相对于与 $r_0^2 \\mathrm{d}r_0$ 成正比的初始体积，共动体积缩放因子为\n$$\nS(t; r_0, M) = \\frac{r(t; r_0, M)^2 \\, J(t; r_0, M)}{r_0^2}.\n$$\n代入 $r(t)$ 和 $J$ 的表达式：\n$$\nS(t; r_0, M) = \\frac{\\left( r_0^{3/2} - A t \\right)^{4/3} \\cdot r_0^{1/2} \\left( r_0^{3/2} - A t \\right)^{-1/3}}{r_0^2}\n= \\frac{r_0^{1/2}}{r_0^2} \\left( r_0^{3/2} - A t \\right)\n= r_0^{-3/2} \\left( r_0^{3/2} - A t \\right).\n$$\n化简得\n$$\nS(t; r_0, M) = 1 - \\frac{A t}{r_0^{3/2}} = 1 - \\frac{\\tfrac{3}{2} \\sqrt{2 M} \\, t}{r_0^{3/2}}.\n$$\n这个表达式是关于 $t$ 的线性函数，从 $S(0; r_0, M) = 1$ 开始，并在恰好到达奇点的时间 $t_{\\mathrm{sing}}(r_0, M) = \\dfrac{2}{3} \\dfrac{r_0^{3/2}}{\\sqrt{2 M}}$ 时达到零。当 $t \\ge t_{\\mathrm{sing}}$ 时，我们在模型中设置 $S = 0$，以反映共动壳层体积在奇点处的坍缩。\n\n步骤 3：算法与数值考虑。\n给定 $(M, r_0, t)$，其中 $M > 0$，$r_0 > 0$，$t \\ge 0$：\n- 计算 $A = \\dfrac{3}{2} \\sqrt{2 M}$。\n- 计算 $t_{\\mathrm{sing}} = \\dfrac{2}{3} \\dfrac{r_0^{3/2}}{\\sqrt{2 M}}$。\n- 如果 $t \\ge t_{\\mathrm{sing}}$，则设 $r = 0$ 且 $S = 0$。\n- 否则，计算 $r = \\left( r_0^{3/2} - A t \\right)^{2/3}$ 和 $S = 1 - \\dfrac{A t}{r_0^{3/2}}$。\n\n所有量均采用 $G = c = 1$ 的几何化单位。半径和时间的单位与 $M$ 的单位相同（例如，$M$ 的倍数）。输出要求为浮点数。不涉及角度。\n\n测试套件覆盖范围的基本原理：\n- 测试 1 $(M, r_0, t) = (1.0, 10.0, 1.0)$：一个远离奇点的通用“理想路径”情况。\n- 测试 2 $(M, r_0, t) = (1.0, 4.0, \\tfrac{1}{2} t_{\\mathrm{sing}})$：检查精确的中点缩放 $S = \\tfrac{1}{2}$。\n- 测试 3 $(M, r_0, t) = (1.0, 2.0, 0.99 \\, t_{\\mathrm{sing}})$：接近奇点的行为，此时 $S \\approx 0.01$ 且 $r$ 很小。\n- 测试 4 $(M, r_0, t) = (1.0, 3.0, 1.5 \\, t_{\\mathrm{sing}})$：超过奇点时间，模型规定 $(r, S) = (0, 0)$。\n- 测试 5 $(M, r_0, t) = (2.0, 100.0, 1.0)$：大半径和较大质量，以验证短时间内的弱汇聚。\n\n最终的程序直接实现这些公式，并按规定格式将串联的结果打印为单行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef singularity_time(M: float, r0: float) -> float:\n    \"\"\"\n    Compute t_sing = (2/3) * r0^(3/2) / sqrt(2M) in geometrized units (G=c=1).\n    \"\"\"\n    return (2.0 / 3.0) * (r0 ** 1.5) / np.sqrt(2.0 * M)\n\ndef evolve_geodesic_geodesic_slicing(M: float, r0: float, t: float) -> tuple[float, float]:\n    \"\"\"\n    Geodesic slicing (alpha=1) radial free-fall in Schwarzschild (Painleve-Gullstrand congruence).\n    Given M, initial areal radius r0, and time t >= 0, return:\n      r(t) = max( (r0^(3/2) - (3/2)*sqrt(2M)*t)^(2/3), 0 )\n      S(t) = max( 1 - ((3/2)*sqrt(2M)*t)/r0^(3/2), 0 )\n    \"\"\"\n    # Guard for physical domain\n    if M <= 0.0 or r0 <= 0.0 or t < 0.0:\n        # For robustness, return NaNs if parameters are unphysical\n        return (float('nan'), float('nan'))\n\n    A = 1.5 * np.sqrt(2.0 * M)\n    tsing = singularity_time(M, r0)\n\n    if t >= tsing:\n        return (0.0, 0.0)\n\n    # Compute r(t) and S(t)\n    parent = r0 ** 1.5 - A * t\n    # Numerical safety: parent should be positive here\n    parent = max(parent, 0.0)\n    r_t = parent ** (2.0 / 3.0)\n    S_t = 1.0 - (A * t) / (r0 ** 1.5)\n    # Clip small negative due to roundoff\n    if S_t < 0.0 and S_t > -1e-14:\n        S_t = 0.0\n    return (r_t, S_t)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is (M, r0, t)\n    tests = []\n    # Test 1: (1.0, 10.0, 1.0)\n    tests.append((1.0, 10.0, 1.0))\n    # Test 2: (1.0, 4.0, 0.5 * t_sing(4.0, 1.0))\n    M2, r02 = 1.0, 4.0\n    t2 = 0.5 * singularity_time(M2, r02)\n    tests.append((M2, r02, t2))\n    # Test 3: (1.0, 2.0, 0.99 * t_sing(2.0, 1.0))\n    M3, r03 = 1.0, 2.0\n    t3 = 0.99 * singularity_time(M3, r03)\n    tests.append((M3, r03, t3))\n    # Test 4: (1.0, 3.0, 1.5 * t_sing(3.0, 1.0))\n    M4, r04 = 1.0, 3.0\n    t4 = 1.5 * singularity_time(M4, r04)\n    tests.append((M4, r04, t4))\n    # Test 5: (2.0, 100.0, 1.0)\n    tests.append((2.0, 100.0, 1.0))\n\n    results = []\n    for (M, r0, t) in tests:\n        r_t, S_t = evolve_geodesic_geodesic_slicing(M, r0, t)\n        results.append(r_t)\n        results.append(S_t)\n\n    # Final print statement in the exact required format.\n    # Ensure standard decimal representation\n    formatted = \",\".join(f\"{x:.12g}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2370126"}, {"introduction": "3+1分解的最终目标是将爱因斯坦方程转化为一组可以进行数值求解的演化方程。本练习旨在连接理论与计算，你将通过实施有限差分法来求解一个简化的波动方程。通过这个过程，你将亲身体验到数值相对论现代模拟的核心技术，例如稳定性和收敛性分析 [@problem_id:2370142]。", "problem": "您需要实现标量波方程的数值演化，该方程源于爱因斯坦方程 $3+1$ 分解的一个简单情形。考虑闵可夫斯基时空，其中 lapse 函数 $\\alpha=1$，shift 向量 $\\beta^{i}=0$，空间度规 $\\gamma_{ij}=\\delta_{ij}$。在这些条件下，对于一个标量场 $\\phi(x,t)$，协变波方程简化为一维标量波方程\n$$\\partial_{t}^{2}\\phi(x,t)=c^{2}\\,\\partial_{x}^{2}\\phi(x,t)。$$\n通过定义辅助变量 $\\Pi(x,t)=\\partial_{t}\\phi(x,t)$ 来引入时间上一阶形式，以获得如下系统\n$$\\partial_{t}\\phi(x,t)=\\Pi(x,t),\\qquad \\partial_{t}\\Pi(x,t)=c^{2}\\,\\partial_{x}^{2}\\phi(x,t)。$$\n在周期性区域 $x\\in[0,2\\pi]$ 上进行计算，波速 $c=1$。使用以下初始数据\n$$\\phi(x,0)=\\sin(kx),\\qquad \\Pi(x,0)=0,$$\n波数 $k=1$。在时间 $t$ 的精确解是\n$$\\phi_{\\text{exact}}(x,t)=\\cos(ckt)\\,\\sin(kx)=\\cos(t)\\,\\sin(x)。$$\n\n您的任务是为一个具有 $N$ 个点和周期性边界条件的均匀网格，实现两种不同的中心有限差分格式来计算空间二阶导数 $\\partial_{x}^{2}\\phi$：\n- 二阶精度格式：\n$$\\partial_{x}^{2}\\phi(x_{i})\\approx\\frac{\\phi_{i-1}-2\\phi_{i}+\\phi_{i+1}}{\\Delta x^{2}}。$$\n- 四阶精度格式：\n$$\\partial_{x}^{2}\\phi(x_{i})\\approx\\frac{-\\phi_{i-2}+16\\phi_{i-1}-30\\phi_{i}+16\\phi_{i+1}-\\phi_{i+2}}{12\\,\\Delta x^{2}}。$$\n\n使用任何相容且稳定的时间积分器，將系统从 $t=0$ 演化到指定的最终时间 $T$。将 $\\phi$ 在时间 $T$ 的离散 $L^{2}$ 误差定义为\n$$E(N)=\\left(\\Delta x\\sum_{i=0}^{N-1}\\left[\\phi_{i}(T)-\\phi_{\\text{exact}}(x_{i},T)\\right]^{2}\\right)^{1/2}。$$\n给定一对分辨率 $(N_{\\text{coarse}},N_{\\text{fine}})$，其中 $N_{\\text{fine}}=2N_{\\text{coarse}}$，将观测收敛率定义为\n$$p=\\frac{\\log\\left(E(N_{\\text{coarse}})/E(N_{\\text{fine}})\\right)}{\\log\\left(\\Delta x_{\\text{coarse}}/\\Delta x_{\\text{fine}}\\right)}。$$\n\n按如下方式评估稳定性：如果在演化过程中，任何数值变为非有限值，或者离散能量\n$$\\mathcal{E}(t)=\\frac{1}{2}\\int_{0}^{2\\pi}\\left[\\Pi(x,t)^{2}+c^{2}\\left(\\partial_{x}\\phi(x,t)\\right)^{2}\\right]\\mathrm{d}x$$\n相对于其初始值增长超过固定的 10 倍，则声明该次运行不稳定。在离散设置中，使用与 $\\partial_{x}^{2}\\phi$ 相同形式阶数的中心差分格式来近似 $\\partial_{x}\\phi$，并用间距为 $\\Delta x$ 的黎曼和来近似积分。\n\n对于下面的每个测试用例，使用一个类库朗因子 $\\lambda=\\Delta t/\\Delta x$ 来设置时间步长 $\\Delta t=\\lambda\\,\\Delta x/c$，并积分到指定的 $T$。如果粗分辨率或细分辨率的运行任何一个不稳定，则将该测试用例的收敛率报告为非数字（not-a-number）。\n\n实现您的程序以运行以下测试套件并汇总结果：\n- 测试 A（正常路径，二阶）：格式阶数 $s=2$，$\\lambda=0.4$，$(N_{\\text{coarse}},N_{\\text{fine}})=(64,128)$，$T=1.0$。\n- 测试 B（正常路径，四阶）：格式阶数 $s=4$，$\\lambda=0.4$，$(N_{\\text{coarse}},N_{\\text{fine}})=(64,128)$，$T=1.0$。\n- 测试 C（边界情况，不稳定）：格式阶数 $s=4$，$\\lambda=3.0$，$(N_{\\text{coarse}},N_{\\text{fine}})=(64,128)$，$T=1.0$。\n\n您的程序应生成单行输出，其中包含测试 A、B 和 C 的观测收敛率，按此顺序以逗号分隔的列表形式，并用方括号括起来（例如，$\"[p_{A},p_{B},p_{C}]\"$)。使用 IEEE 非数字值来表示测试的不稳定性（即，打印一个可以解析为浮点非数字的值）。", "solution": "所述问题是有效的。它具有科学依据，论证严谨，客观，并为计算物理学中的一个标准数值分析练习提供了一套完整、自包含的指令。它没有任何数学或物理上的不一致之处。因此，我将继续提供一个解决方案。\n\n该问题要求数值演化一维标量波方程，该方程以时间上一阶系统的形式呈现：\n$$\n\\partial_{t}\\phi(x,t)=\\Pi(x,t) \\\\\n\\partial_{t}\\Pi(x,t)=c^{2}\\,\\partial_{x}^{2}\\phi(x,t)\n$$\n计算在周期性区域 $x \\in [0, 2\\pi]$ 上进行，波速 $c=1$。初始数据为 $\\phi(x,0)=\\sin(kx)$ 和 $\\Pi(x,0)=0$，波数 $k=1$。\n\n首先，我们将空间域离散化为一个包含 $N$ 个点的均匀网格 $x_i = i\\Delta x$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = 2\\pi/N$。连续场 $\\phi(x,t)$ 和 $\\Pi(x,t)$ 由其在网格上的值表示，记作 $\\phi_i(t)$ 和 $\\Pi_i(t)$。\n\n空间二阶导数项 $\\partial_{x}^{2}\\phi$ 使用一个 $s$ 阶的有限差分格式来近似。这将偏微分方程组转化为一个大型的耦合常微分方程（ODE）组：\n$$\n\\frac{d\\phi_i(t)}{dt} = \\Pi_i(t) \\\\\n\\frac{d\\Pi_i(t)}{dt} = c^2 (\\mathcal{D}_x^2 \\phi)_i(t)\n$$\n其中 $(\\mathcal{D}_x^2 \\phi)_i$ 表示将离散二阶导数算子应用于向量 $\\phi = (\\phi_0, \\phi_1, \\dots, \\phi_{N-1})$ 在网格点 $i$ 上的值。对于 $s=2$ 阶的格式，算子为：\n$$\n(\\mathcal{D}_x^2 \\phi)_i = \\frac{\\phi_{i-1} - 2\\phi_i + \\phi_{i+1}}{\\Delta x^2}\n$$\n对于 $s=4$ 阶的格式，算子为：\n$$\n(\\mathcal{D}_x^2 \\phi)_i = \\frac{-\\phi_{i-2} + 16\\phi_{i-1} - 30\\phi_i + 16\\phi_{i+1} - \\phi_{i+2}}{12\\Delta x^2}\n$$\n周期性边界条件意味着索引是以 $N$ 为模进行解释的。例如，$\\phi_{-1} = \\phi_{N-1}$ 且 $\\phi_{N} = \\phi_{0}$。这可以通过数组滚动操作高效实现。\n\n为了在时间上将这个常微分方程组从 $t=0$ 积分到最终时间 $T$，我们使用经典的四阶 Runge-Kutta（RK4）方法。这是一个鲁棒且足够高阶的积分器，可确保时间离散化误差不会污染空间收敛率的测量。我们系统的状态向量是 $Y(t) = (\\phi_0, \\dots, \\phi_{N-1}, \\Pi_0, \\dots, \\Pi_{N-1})^T$。RK4 方法将解从时间 $t_n$推进到 $t_{n+1} = t_n + \\Delta t$ 的过程如下：\n$$\n\\begin{align*}\nK_1 &= F(Y(t_n)) \\\\\nK_2 &= F(Y(t_n) + \\frac{\\Delta t}{2} K_1) \\\\\nK_3 &= F(Y(t_n) + \\frac{\\Delta t}{2} K_2) \\\\\nK_4 &= F(Y(t_n) + \\Delta t K_3) \\\\\nY(t_{n+1}) &= Y(t_n) + \\frac{\\Delta t}{6} (K_1 + 2K_2 + 2K_3 + K_4)\n\\end{align*}\n$$\n其中 $F(Y)$ 代表我们常微分方程组的右侧。时间步长 $\\Delta t$ 由类库朗因子 $\\lambda$ 决定，即 $\\Delta t = \\lambda \\Delta x / c$。\n\n演化的稳定性通过两个标准进行监控。首先，我们检查状态向量 $\\phi_i(t)$ 或 $\\Pi_i(t)$ 中的任何数值是否变为非有限值（例如 NaN 或无穷大）。其次，我们监控系统的离散能量，对于一个稳定、非耗散的格式，能量应该近似守恒。离散能量是连续泛函的近似：\n$$\n\\mathcal{E}(t) = \\frac{1}{2}\\int_{0}^{2\\pi}\\left[\\Pi(x,t)^{2}+c^{2}\\left(\\partial_{x}\\phi(x,t)\\right)^{2}\\right]\\mathrm{d}x \\approx \\frac{\\Delta x}{2} \\sum_{i=0}^{N-1} \\left[ \\Pi_i(t)^2 + c^2 ((\\mathcal{D}_x \\phi)_i(t))^2 \\right]\n$$\n离散一阶导数算子 $\\mathcal{D}_x$ 的精度阶数 $s$ 必须与二阶导数算子 $\\mathcal{D}_x^2$ 相同。对于 $s=2$，我们使用中心差分格式：\n$$\n(\\mathcal{D}_x \\phi)_i = \\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}\n$$\n对于 $s=4$：\n$$\n(\\mathcal{D}_x \\phi)_i = \\frac{-\\phi_{i+2} + 8\\phi_{i+1} - 8\\phi_{i-1} + \\phi_{i-2}}{12\\Delta x}\n$$\n如果在任何时间步，能量 $\\mathcal{E}(t)$ 相对于其初始值 $\\mathcal{E}(0)$ 增长超过 10 倍，则该模拟被标记为不稳定。\n\n对于每个测试用例，我们执行两次模拟：一次使用粗分辨率 $N_{\\text{coarse}}$，一次使用细分辨率 $N_{\\text{fine}}=2N_{\\text{coarse}}$。如果任一运行不稳定，则结果报告为非数字（NaN）。否则，我们计算两个分辨率在最终时间 $T$ 的离散 $L^2$ 误差：\n$$\nE(N) = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left[\\phi_i(T) - \\phi_{\\text{exact}}(x_i, T)\\right]^2\\right)^{1/2}\n$$\n其中 $\\phi_{\\text{exact}}(x,t)=\\cos(ct)\\sin(kx)$。然后观测收敛率 $p$ 计算如下：\n$$\np = \\frac{\\log(E(N_{\\text{coarse}})/E(N_{\\text{fine}}))}{\\log(\\Delta x_{\\text{coarse}}/\\Delta x_{\\text{fine}})} = \\frac{\\log(E(N_{\\text{coarse}})/E(N_{\\text{fine}}))}{\\log(2)}\n$$\n分母为 $\\log(2)$ 是因为 $N_{\\text{fine}} = 2N_{\\text{coarse}}$ 意味着 $\\Delta x_{\\text{coarse}} = 2\\Delta x_{\\text{fine}}$。实现过程将按照描述，为空间导数、时间演化和收敛性分析创建函数。", "answer": "```python\nimport numpy as np\n\ndef d_phi_dx_stencil(phi, dx, order):\n    \"\"\"Computes the first spatial derivative using a centered stencil.\"\"\"\n    if order == 2:\n        # 2nd-order stencil: (phi_{i+1} - phi_{i-1}) / (2*dx)\n        return (np.roll(phi, -1) - np.roll(phi, 1)) / (2.0 * dx)\n    elif order == 4:\n        # 4th-order stencil: (-phi_{i+2} + 8*phi_{i+1} - 8*phi_{i-1} + phi_{i-2}) / (12*dx)\n        return (-np.roll(phi, -2) + 8.0 * np.roll(phi, -1) - 8.0 * np.roll(phi, 1) + np.roll(phi, 2)) / (12.0 * dx)\n    else:\n        raise ValueError(\"Unsupported stencil order for d_phi_dx.\")\n\ndef d2_phi_dx2_stencil(phi, dx, order):\n    \"\"\"Computes the second spatial derivative using a centered stencil.\"\"\"\n    if order == 2:\n        # 2nd-order stencil: (phi_{i-1} - 2*phi_i + phi_{i+1}) / dx^2\n        return (np.roll(phi, 1) - 2.0 * phi + np.roll(phi, -1)) / (dx**2)\n    elif order == 4:\n        # 4th-order stencil: (-phi_{i-2} + 16*phi_{i-1} - 30*phi_i + 16*phi_{i+1} - phi_{i-2}) / (12*dx^2)\n        return (-np.roll(phi, 2) + 16.0 * np.roll(phi, 1) - 30.0 * phi + 16.0 * np.roll(phi, -1) - np.roll(phi, -2)) / (12.0 * dx**2)\n    else:\n        raise ValueError(\"Unsupported stencil order for d2_phi_dx2.\")\n\ndef calculate_energy(phi, Pi, dx, c, order):\n    \"\"\"Computes the discrete energy of the system.\"\"\"\n    dphi_dx = d_phi_dx_stencil(phi, dx, order)\n    integrand = Pi**2 + c**2 * dphi_dx**2\n    return 0.5 * np.sum(integrand) * dx\n\ndef evolve(N, T_final, lambda_cfl, stencil_order, c, k):\n    \"\"\"\n    Evolves the scalar wave equation from t=0 to T_final.\n    Returns the final state phi and an instability flag.\n    \"\"\"\n    L = 2.0 * np.pi\n    dx = L / N\n    x = np.linspace(0, L, N, endpoint=False)\n    \n    # Initial conditions\n    phi = np.sin(k * x)\n    Pi = np.zeros(N)\n\n    # Time step from Courant-like factor\n    dt = lambda_cfl * dx / c\n    num_steps = int(np.ceil(T_final / dt))\n    dt = T_final / num_steps  # Adjust dt to hit T_final exactly\n\n    # Stability check setup\n    initial_energy = calculate_energy(phi, Pi, dx, c, stencil_order)\n    if initial_energy == 0: initial_energy = 1.0e-15 # Avoid division by zero if starts at rest with zero grad\n    is_unstable = False\n\n    # RHS of the ODE system dY/dt = F(Y)\n    def rhs(phi_state, Pi_state):\n        dphi_dt = Pi_state\n        dPi_dt = c**2 * d2_phi_dx2_stencil(phi_state, dx, stencil_order)\n        return dphi_dt, dPi_dt\n\n    # RK4 time integration loop\n    for _ in range(num_steps):\n        # k1\n        dphi_dt1, dPi_dt1 = rhs(phi, Pi)\n        \n        # k2\n        phi_k2 = phi + 0.5 * dt * dphi_dt1\n        Pi_k2 = Pi + 0.5 * dt * dPi_dt1\n        dphi_dt2, dPi_dt2 = rhs(phi_k2, Pi_k2)\n\n        # k3\n        phi_k3 = phi + 0.5 * dt * dphi_dt2\n        Pi_k3 = Pi + 0.5 * dt * dPi_dt2\n        dphi_dt3, dPi_dt3 = rhs(phi_k3, Pi_k3)\n\n        # k4\n        phi_k4 = phi + dt * dphi_dt3\n        Pi_k4 = Pi + dt * dPi_dt3\n        dphi_dt4, dPi_dt4 = rhs(phi_k4, Pi_k4)\n\n        # Update state\n        phi += (dt / 6.0) * (dphi_dt1 + 2 * dphi_dt2 + 2 * dphi_dt3 + dphi_dt4)\n        Pi += (dt / 6.0) * (dPi_dt1 + 2 * dPi_dt2 + 2 * dPi_dt3 + dPi_dt4)\n\n        # Stability checks\n        if not np.all(np.isfinite(phi)) or not np.all(np.isfinite(Pi)):\n            is_unstable = True\n            break\n        \n        current_energy = calculate_energy(phi, Pi, dx, c, stencil_order)\n        if current_energy > 10.0 * initial_energy:\n            is_unstable = True\n            break\n            \n    return phi, is_unstable\n\ndef run_convergence_test(s, lambda_cfl, N_pair, T, c, k):\n    \"\"\"\n    Runs a coarse and fine simulation to calculate the convergence rate.\n    \"\"\"\n    N_coarse, N_fine = N_pair\n    \n    # Coarse run\n    phi_coarse, unstable_coarse = evolve(N=N_coarse, T_final=T, lambda_cfl=lambda_cfl, stencil_order=s, c=c, k=k)\n    \n    # Fine run\n    phi_fine, unstable_fine = evolve(N=N_fine, T_final=T, lambda_cfl=lambda_cfl, stencil_order=s, c=c, k=k)\n    \n    if unstable_coarse or unstable_fine:\n        return np.nan\n\n    # Calculate L2 error for coarse grid\n    L = 2.0 * np.pi\n    dx_coarse = L / N_coarse\n    x_coarse = np.linspace(0, L, N_coarse, endpoint=False)\n    phi_exact_coarse = np.cos(c * k * T) * np.sin(k * x_coarse)\n    error_coarse = np.sqrt(dx_coarse * np.sum((phi_coarse - phi_exact_coarse)**2))\n\n    # Calculate L2 error for fine grid\n    dx_fine = L / N_fine\n    x_fine = np.linspace(0, L, N_fine, endpoint=False)\n    phi_exact_fine = np.cos(c * k * T) * np.sin(k * x_fine)\n    error_fine = np.sqrt(dx_fine * np.sum((phi_fine - phi_exact_fine)**2))\n    \n    # Calculate convergence rate\n    # The refinement ratio of grid spacing is dx_coarse / dx_fine = 2\n    if error_fine == 0.0 or error_coarse == 0.0:\n      return np.inf # Avoid log(0)\n    \n    convergence_rate = np.log(error_coarse / error_fine) / np.log(2.0)\n    \n    return convergence_rate\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints results.\n    \"\"\"\n    c = 1.0\n    k = 1.0\n    \n    test_cases = [\n        # Test A: s=2, stable\n        {'s': 2, 'lambda': 0.4, 'N_pair': (64, 128), 'T': 1.0},\n        # Test B: s=4, stable\n        {'s': 4, 'lambda': 0.4, 'N_pair': (64, 128), 'T': 1.0},\n        # Test C: s=4, unstable\n        {'s': 4, 'lambda': 3.0, 'N_pair': (64, 128), 'T': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        p = run_convergence_test(s=case['s'], lambda_cfl=case['lambda'], \n                                 N_pair=case['N_pair'], T=case['T'], c=c, k=k)\n        results.append(p)\n    \n    # Format the float/nan results into the required string representation\n    result_str = [f\"{r:.6f}\" if not np.isnan(r) else \"nan\" for r in results]\n\n    print(f\"[{','.join(result_str)}]\")\n\nsolve()\n```", "id": "2370142"}]}