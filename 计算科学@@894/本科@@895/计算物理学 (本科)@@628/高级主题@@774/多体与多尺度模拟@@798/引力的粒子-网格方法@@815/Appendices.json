{"hands_on_practices": [{"introduction": "粒子-网格（PM）方法的核心是在网格上高效地求解引力场，这等价于求解泊松方程。本练习将指导你从基本原理出发，为二维宇宙推导并实现一个基于快速傅里叶变换（FFT）的泊松方程求解器。通过亲自推导与维度相关的格林函数 $\\tilde{G}(\\vec{k})$，你将深刻理解引力定律在不同维度下的表现形式，并为构建任何 PM 代码打下坚实的物理和算法基础 [@problem_id:2424811]。", "problem": "您的任务是构建一个完整、可运行的程序，该程序使用粒子-网格方法，实现一个基于二维快速傅里叶变换 (FFT) 的牛顿引力泊松求解器。您的任务是从第一性原理出发进行推导，并实现适用于二维宇宙的正确傅里叶空间格林函数，推导的起点是通过泊松方程将质量密度与引力势联系起来的基本定律。随后，您必须在具有已知解析解的、精心设计的测试场上验证您的实现。\n\n基本原理：在连续二维域中，由表面质量密度 $\\Sigma(\\vec{r})$ 产生的牛顿引力势 $\\phi(\\vec{r})$ 由泊松方程联系，该方程的选择必须与空间维度以及拉普拉斯算子作用于对数函数的恒等式保持一致。使用恒等式 $\\nabla^2 \\ln r = 2\\pi \\delta^{(2)}(\\vec{r})$ 和引力势的定义，在二维空间中建立 $\\nabla^2 \\phi$ 和 $\\Sigma$ 之间的关系。在傅里叶空间中，拉普拉斯算子变为乘以 $-|\\vec{k}|^2$，与格林函数的卷积变为乘以其傅里叶变换。您的任务是基于此原理，推导正确的二维傅里叶空间格林函数 $\\tilde{G}(\\vec{k})$，以替代三维表达式 $\\tilde{G}(\\vec{k}) = -4\\pi G/|\\vec{k}|^2$。\n\n实现设置：考虑一个边长为 $L$ 的方形、周期性二维域，在 $N \\times N$ 个点的均匀网格上进行离散化。使用快速傅里叶变换实现的离散傅里叶变换，在傅里叶空间中求解泊松方程。设网格间距为 $\\Delta x = L/N$。使用一维离散频率定义，其中 $k$ 分量由实空间间距 $d=\\Delta x$ 构建：对每个轴，将离散角波数定义为 $k_\\alpha = 2\\pi \\,\\mathrm{fftfreq}(N, d=\\Delta x)$，其中 $\\alpha \\in \\{x,y\\}$，然后构成 $|\\vec{k}|^2 = k_x^2 + k_y^2$。您必须通过强制势为零均值来处理零模 $\\vec{k}=\\vec{0}$（将对应的傅里叶空间格林函数设置为零，并在变换前减去实空间中密度场的均值）。\n\n您的程序必须：\n- 推导并实现正确的二维引力傅里叶空间格林函数 $\\tilde{G}(\\vec{k})$。\n- 构建一个求解器，对于给定的表面密度场 $\\Sigma(x,y)$，通过将减去均值的密度的傅里叶变换乘以 $\\tilde{G}(\\vec{k})$ 并进行逆变换，来计算引力势 $\\phi(x,y)$。\n- 此外，使用傅里叶空间中的谱方法求导，即利用傅里叶空间中 $\\partial/\\partial x \\leftrightarrow i k_x$ 和 $\\partial/\\partial y \\leftrightarrow i k_y$ 的性质，计算引力加速度场 $\\vec{g}(x,y) = -\\nabla \\phi(x,y)$。\n\n单位：使用无量纲代码单位，引力常数 $G=1$。所有要求的输出都是无量纲实数。\n\n角度单位：所有三角函数必须使用弧度。\n\n测试套件和要求输出：您的程序必须在周期性方形域上运行以下四个测试用例，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n\n所有测试的域和常数：$N=64$, $L=1$, $G=1$。\n\n令 $x_i = i\\,\\Delta x$ 和 $y_j = j\\,\\Delta x$，其中 $i,j \\in \\{0,1,\\dots,N-1\\}$，且 $\\Delta x = L/N$。使用 $\\cos\\left(2\\pi m x/L\\right)$ 和 $\\cos\\left(2\\pi n y/L\\right)$ 定义余弦场。\n\n- 测试 1（标准测试，一维余弦）：表面密度 $\\Sigma(x,y) = A \\cos\\left(2\\pi m x/L\\right)$，其中 $A=1, m=1, n=0$。使用您的求解器计算数值势 $\\phi_{\\mathrm{num}}(x,y)$。使用正确的二维泊松关系以及余弦函数是周期域上拉普拉斯算子本征函数的事实，独立推导与此 $\\Sigma(x,y)$ 对应的解析势 $\\phi_{\\mathrm{an}}(x,y)$。输出最大绝对误差 $E_1 = \\max_{i,j} \\left| \\phi_{\\mathrm{num}}(x_i,y_j) - \\phi_{\\mathrm{an}}(x_i,y_j) \\right|$，作为一个浮点数。\n\n- 测试 2（二维余弦模式）：表面密度 $\\Sigma(x,y) = A \\cos\\left(2\\pi m x/L\\right)\\cos\\left(2\\pi n y/L\\right)$，其中 $A=0.5, m=3, n=2$。计算数值势并与此场的解析推导势 $\\phi_{\\mathrm{an}}(x,y)$ 进行比较。输出 $E_2 = \\max_{i,j} \\left| \\phi_{\\mathrm{num}}(x_i,y_j) - \\phi_{\\mathrm{an}}(x_i,y_j) \\right|$，作为一个浮点数。\n\n- 测试 3（通过加速度进行矢量场检查）：表面密度 $\\Sigma(x,y) = A \\cos\\left(2\\pi m x/L\\right)\\cos\\left(2\\pi n y/L\\right)$，其中 $A=0.8, m=5, n=1$。使用您的求解器，通过势的谱方法梯度计算数值加速度分量 $g_{x,\\mathrm{num}}(x,y)$ 和 $g_{y,\\mathrm{num}}(x,y)$。独立推导此场的解析加速度分量 $g_{x,\\mathrm{an}}(x,y)$ 和 $g_{y,\\mathrm{an}}(x,y)$，并输出两个分量上的最大绝对误差 $E_3 = \\max\\left\\{\\max_{i,j} \\left| g_{x,\\mathrm{num}} - g_{x,\\mathrm{an}} \\right|,\\; \\max_{i,j} \\left| g_{y,\\mathrm{num}} - g_{y,\\mathrm{an}} \\right|\\right\\}$，作为一个浮点数。\n\n- 测试 4（零模处理边界情况）：表面密度 $\\Sigma(x,y) = A$，其中 $A=7$。在减去均值并将格林函数的 $\\vec{k}=\\vec{0}$ 模式设置为零后，在周期域上，势应恒定为零。计算数值势 $\\phi_{\\mathrm{num}}(x,y)$ 并输出均方根值 $E_4 = \\sqrt{\\frac{1}{N^2}\\sum_{i,j} \\phi_{\\mathrm{num}}(x_i,y_j)^2}$，作为一个浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含按 $[E_1,E_2,E_3,E_4]$ 顺序排列、用方括号括起来的逗号分隔结果列表。例如，一个有效的输出行为 `[0.0,0.0,0.0,0.0]` 形式。所有四个输出都必须是无量纲单位的浮点数，并由您所用编程语言的默认字符串转换进行四舍五入。不应打印任何额外文本。", "solution": "所述问题是计算物理学中一个明确定义的练习。它要求使用谱方法，特别是快速傅里叶变换 (FFT)，为周期域上的二维引力泊松方程构建一个数值求解器。该问题具有科学依据，内部一致，并提供了一套清晰可验证的测试用例。我们将开始进行求解。\n\n基本任务是求解泊松方程，该方程将引力势 $\\phi$ 与表面质量密度 $\\Sigma$ 联系起来。\n\n首先，我们必须确定二维宇宙中泊松方程的正确形式。问题引导我们使用二维空间中拉普拉斯算子作用于对数函数的恒等式 $\\nabla^2 \\ln(r) = 2\\pi \\delta^{(2)}(\\vec{r})$，其中 $r=|\\vec{r}|$ 是到原点的距离，$\\delta^{(2)}(\\vec{r})$ 是二维狄拉克$\\delta$函数。在二维空间中，引力呈现 $1/r$ 依赖关系，导致势随 $\\ln(r)$ 变化。对于位于原点的点质量 $m$，表面密度为 $\\Sigma(\\vec{r}) = m \\delta^{(2)}(\\vec{r})$，势为 $\\phi(\\vec{r}) = G m \\ln(r)$，其中 $G$ 是引力常数。\n\n对该势取拉普拉斯算子，我们得到：\n$$\n\\nabla^2 \\phi(\\vec{r}) = \\nabla^2 (G m \\ln r) = G m \\nabla^2(\\ln r) = G m (2\\pi \\delta^{(2)}(\\vec{r}))\n$$\n通过用 $\\Sigma(\\vec{r}) / m$ 替换 $\\delta^{(2)}(\\vec{r})$，我们获得了点质量的关系式：\n$$\n\\nabla^2 \\phi(\\vec{r}) = 2\\pi G \\Sigma(\\vec{r})\n$$\n根据叠加原理，该方程对任意质量分布 $\\Sigma(\\vec{r})$ 都成立。这就是二维引力的泊松方程。在问题指定的无量纲单位（其中$G=1$）下，它简化为：\n$$\n\\nabla^2 \\phi(\\vec{r}) = 2\\pi \\Sigma(\\vec{r})\n$$\n\n我们的目标是使用傅里叶方法求解这个偏微分方程。傅里叶变换定义为 $\\tilde{f}(\\vec{k}) = \\mathcal{F}\\{f(\\vec{r})\\} = \\int f(\\vec{r}) e^{-i\\vec{k}\\cdot\\vec{r}} d^2r$。傅里叶变换的一个关键性质是它将微分运算转换成乘法运算。具体来说，拉普拉斯算子的变换是：\n$$\n\\mathcal{F}\\{\\nabla^2 f(\\vec{r})\\} = -|\\vec{k}|^2 \\tilde{f}(\\vec{k})\n$$\n其中 $|\\vec{k}|^2 = k_x^2 + k_y^2$ 是波矢 $\\vec{k}$ 的模平方。\n\n对我们泊松方程的两边应用傅里叶变换，我们得到：\n$$\n\\mathcal{F}\\{\\nabla^2 \\phi\\} = \\mathcal{F}\\{2\\pi \\Sigma\\}\n$$\n$$\n-|\\vec{k}|^2 \\tilde{\\phi}(\\vec{k}) = 2\\pi \\tilde{\\Sigma}(\\vec{k})\n$$\n这个代数方程可以求解出势的傅里叶变换 $\\tilde{\\phi}(\\vec{k})$：\n$$\n\\tilde{\\phi}(\\vec{k}) = \\left(\\frac{-2\\pi}{|\\vec{k}|^2}\\right) \\tilde{\\Sigma}(\\vec{k})\n$$\n实空间中的卷积问题在傅里叶空间中变为简单的乘法。乘以变换后密度的项就是傅里叶空间格林函数 $\\tilde{G}(\\vec{k})$。因此，对于 $G=1$ 的二维引力：\n$$\n\\tilde{G}(\\vec{k}) = \\frac{-2\\pi}{|\\vec{k}|^2}\n$$\n在 $\\vec{k}=\\vec{0}$ 处存在一个奇点。这反映了一个物理事实：势的绝对值是任意的；只有势差才具有物理意义。对于具有周期性边界条件的系统，可以通过要求势具有零均值来获得唯一解。这转换为傅里叶空间中的 $\\tilde{\\phi}(\\vec{k}=\\vec{0}) = 0$。我们通过两种方法实现这一点：\n1.  在进行傅里叶变换之前，减去密度场的均值：$\\Sigma'(\\vec{r}) = \\Sigma(\\vec{r}) - \\langle \\Sigma \\rangle$。这确保了 $\\tilde{\\Sigma}'(\\vec{k}=\\vec{0})=0$。\n2.  将格林函数在原点处显式地设置为零：$\\tilde{G}(\\vec{k}=\\vec{0}) = 0$。\n\n对于在边长为 $L$ 的域上的离散 $N \\times N$ 网格上的数值实现，连续傅里叶变换被离散傅里叶变换 (DFT) 所取代，并通过 FFT 算法实现。离散波矢由 $k_\\alpha = 2\\pi \\, \\mathrm{fftfreq}(N, d=\\Delta x)$ 给出，对应每个轴 $\\alpha \\in \\{x, y\\}$，其中 $\\Delta x = L/N$ 是网格间距。\n\n从密度场 $\\Sigma(x_i, y_j)$ 计算势 $\\phi(x_i, y_j)$ 的完整算法如下：\n1. 计算离散网格坐标和波矢。\n2. 在网格上构建离散密度场 $\\Sigma$。\n3. 减去均值：$\\Sigma' = \\Sigma - \\frac{1}{N^2} \\sum_{i,j} \\Sigma_{i,j}$。\n4. 计算减去均值后的密度的二维DFT：$\\tilde{\\Sigma}' = \\mathrm{FFT2}(\\Sigma')$。\n5. 构建离散傅里叶空间格林函数 $\\tilde{G}(k_x, k_y) = -2\\pi/(k_x^2 + k_y^2)$，并将 $(k_x, k_y)=(0,0)$ 处的值设为 $0$。\n6. 在傅里叶空间中相乘：$\\tilde{\\phi}(k_x, k_y) = \\tilde{G}(k_x, k_y) \\tilde{\\Sigma}'(k_x, k_y)$。\n7. 计算二维逆DFT以获得实空间中的势：$\\phi = \\mathrm{IFFT2}(\\tilde{\\phi})$。结果将在数值精度误差范围内为实值。\n\n引力加速度场 $\\vec{g} = -\\nabla\\phi$ 也可以在傅里叶空间中高效地计算。梯度算子的变换为 $\\mathcal{F}\\{\\nabla f\\} = i\\vec{k} \\tilde{f}(\\vec{k})$。因此，加速度的傅里叶分量为：\n$$\n\\tilde{g}_x(\\vec{k}) = -i k_x \\tilde{\\phi}(\\vec{k})\n$$\n$$\n\\tilde{g}_y(\\vec{k}) = -i k_y \\tilde{\\phi}(\\vec{k})\n$$\n然后，通过分别对 $\\tilde{g}_x$ 和 $\\tilde{g}_y$ 应用逆DFT，得到实空间加速度分量 $g_x$ 和 $g_y$。\n\n我们用解析解验证此实现。测试用例使用余弦函数，它们是周期域上拉普拉斯算子的本征函数。对于密度形式为 $\\Sigma(x,y) = A \\cos(2\\pi m x/L)\\cos(2\\pi n y/L)$，满足 $\\nabla^2 \\phi = 2\\pi \\Sigma$ 且均值为零的相应势为：\n$$\n\\phi_{\\mathrm{an}}(x,y) = -\\frac{A L^2}{2\\pi(m^2+n^2)} \\cos(2\\pi m x/L)\\cos(2\\pi n y/L)\n$$\n对于 $(m,n) \\neq (0,0)$。相应的加速度分量通过对此势取负梯度得到：\n$$\ng_{x,\\mathrm{an}}(x,y) = -\\frac{A L m}{m^2+n^2} \\sin(2\\pi m x/L)\\cos(2\\pi n y/L)\n$$\n$$\ng_{y,\\mathrm{an}}(x,y) = -\\frac{A L n}{m^2+n^2} \\cos(2\\pi m x/L)\\sin(2\\pi n y/L)\n$$\n这些解析解为衡量数值求解器精度的提供了真实值。对于均匀密度测试用例，减去均值会得到一个零场，其势也必须为零。这种情况下的数值误差量化了求解器对零模的处理能力。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 2D FFT-based Poisson solver for Newtonian gravity and validates it.\n    \"\"\"\n    # Domain and constants for all tests\n    N = 64\n    L = 1.0\n    G = 1.0 # Set to 1 as per problem statement\n\n    # Discretization\n    dx = L / N\n    x = np.arange(N) * dx\n    y = np.arange(N) * dx\n    \n    # Grid coordinates. Use 'xy' indexing for intuitive array layout.\n    # Sigma[i, j] will correspond to Sigma(x_j, y_i)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # Frequencies\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    kx, ky = np.meshgrid(k_1d, k_1d, indexing='xy')\n\n    # Fourier-space Green's function for 2D Poisson equation \\nabla^2\\phi = 2\\pi*G*\\Sigma\n    k_sq = kx**2 + ky**2\n    \n    # Suppress division by zero warning for the k=0 case\n    with np.errstate(divide='ignore', invalid='ignore'):\n        green_k = -2 * np.pi * G / k_sq\n    \n    # Handle the k=0 mode (DC component)\n    green_k[0, 0] = 0.0\n\n    # Define a helper function for the solver core\n    def poisson_solver(Sigma):\n        # Subtract mean to enforce zero-mean potential\n        Sigma_mean_subtracted = Sigma - np.mean(Sigma)\n        \n        # Forward FFT\n        Sigma_k = np.fft.fft2(Sigma_mean_subtracted)\n        \n        # Solve in Fourier space\n        phi_k = green_k * Sigma_k\n        \n        # Inverse FFT to get potential\n        phi_num = np.fft.ifft2(phi_k).real\n        \n        return phi_num, phi_k\n\n    # Test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'A': 1.0, 'm': 1, 'n': 0},\n        {'id': 2, 'A': 0.5, 'm': 3, 'n': 2},\n        {'id': 3, 'A': 0.8, 'm': 5, 'n': 1},\n        {'id': 4, 'A': 7.0, 'm': 0, 'n': 0}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A = case['A']\n        m = case['m']\n        n = case['n']\n\n        if case['id'] <= 3: # Cosine-based density fields\n            # The general form is A * cos(2*pi*m*x/L) * cos(2*pi*n*y/L),\n            # with n=0 for Test 1.\n            term_x = np.cos(2 * np.pi * m * xx / L)\n            term_y = np.cos(2 * np.pi * n * yy / L)\n            Sigma = A * term_x * term_y\n            \n            # Solve numerically\n            phi_num, phi_k = poisson_solver(Sigma)\n\n            if case['id'] == 1 or case['id'] == 2:\n                # Analytic potential\n                k_norm_sq_mode = m**2 + n**2\n                C = -A * L**2 / (2 * np.pi * G * k_norm_sq_mode)\n                phi_an = C * term_x * term_y\n                \n                # Calculate error E1 or E2\n                error = np.max(np.abs(phi_num - phi_an))\n                results.append(error)\n            \n            elif case['id'] == 3:\n                # Compute numerical acceleration\n                gx_k = -1j * kx * phi_k\n                gy_k = -1j * ky * phi_k\n                gx_num = np.fft.ifft2(gx_k).real\n                gy_num = np.fft.ifft2(gy_k).real\n\n                # Analytic acceleration\n                k_norm_sq_mode = m**2 + n**2\n                C_gx = -A * L * m / (G * k_norm_sq_mode)\n                C_gy = -A * L * n / (G * k_norm_sq_mode)\n\n                gx_an = C_gx * np.sin(2 * np.pi * m * xx / L) * np.cos(2 * np.pi * n * yy / L)\n                gy_an = C_gy * np.cos(2 * np.pi * m * xx / L) * np.sin(2 * np.pi * n * yy / L)\n\n                # Calculate error E3\n                error_gx = np.max(np.abs(gx_num - gx_an))\n                error_gy = np.max(np.abs(gy_num - gy_an))\n                error = max(error_gx, error_gy)\n                results.append(error)\n\n        elif case['id'] == 4: # Constant density field\n            Sigma = np.full((N, N), A)\n            \n            # Solve numerically. The mean subtraction should make Sigma=0.\n            phi_num, _ = poisson_solver(Sigma)\n            \n            # The potential should be identically zero, up to machine precision.\n            # Calculate RMS error E4.\n            error = np.sqrt(np.mean(phi_num**2))\n            results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424811"}, {"introduction": "在计算出网格上的引力后，下一步是根据引力来更新粒子的运动。这个实践将引导你从一个静态的场求解器过渡到一个完整的动态模拟。你将学习使用蛙跳积分法来演化粒子轨迹，并探索数值模拟中至关重要的稳定性问题，特别是 Courant-Friedrichs-Lewy (CFL) 条件 [@problem_id:2424803]。通过亲手操作并观察违反稳定性条件导致的后果，你将获得关于如何选择合适的时间步长 $\\Delta t$ 以确保模拟结果可靠的宝贵实践经验。", "problem": "要求您实现一个完整的、自包含的程序，该程序模拟一维自引力的粒子-网格 (PM) 方法，并用它来研究当 Courant–Friedrichs–Lewy (CFL) 条件被故意违反时，显式时间积分的数值稳定性。PM 方法代表粒子-网格 (Particle–Mesh)，稳定性条件是 Courant–Friedrichs–Lewy (CFL)。所有物理量均为无量纲。空间域是周期性的，长度为 $L=1$。网格包含 $N_g=256$ 个均匀间隔的单元，单元宽度为 $\\Delta x=L/N_g$。系统中有 $N_p=8192$ 个粒子，每个粒子的质量为 $m_i=1/N_p$，其初始位置为 $x_i(0)=\\left(i+\\tfrac{1}{2}\\right)\\,L/N_p$，其中 $i=0,1,\\dots,N_p-1$。初始速度为 $v_i(0)=v_0 \\sin\\!\\left(2\\pi x_i(0)/L\\right)$，其中 $v_0=0.5$。引力常数为 $G=1$。系统的演化由牛顿方程 $\\,\\ddot{x}_i(t)=a\\!\\left(x_i(t),t\\right)\\,$ 决定，其中加速度场 $a(x,t)$ 是通过在网格上求解引力势 $\\phi(x,t)$ 的泊松方程得到的：$$\\frac{\\mathrm{d}^2 \\phi}{\\mathrm{d}x^2}(x,t) = 4\\pi G \\left(\\rho(x,t)-\\bar{\\rho}\\right),$$ 该方程具有周期性边界条件和零均值势（即 $\\phi$ 的 $k=0$ 傅里叶模态被设为零）。此处，$\\rho(x,t)$ 是通过使用云中单元（CIC）插值法将粒子质量分配到网格上得到的质量密度，而 $\\bar{\\rho}$ 是 $\\rho(x,t)$ 的空间平均值。加速度为 $a(x,t)=-\\mathrm{d}\\phi/\\mathrm{d}x$。粒子所在位置的加速度是通过使用相同的云中单元（CIC）格式将网格加速度插值回粒子位置得到的。时间积分必须使用一个二阶精度、显式、时间可逆的牛顿方程积分器执行 $N_{\\text{steps}}=300$ 步。程序必须运行四次模拟，这些模拟仅在时间步长 $\\Delta t$ 的选择上有所不同。定义初始 CFL 比率为 $$r_0=\\frac{\\Delta t\\,\\max_i |v_i(0)|}{\\Delta x}=\\frac{\\Delta t\\,v_0}{\\Delta x}.$$ 四次模拟必须使用选定的 $\\Delta t$，使得 $r_0$ 从集合 $\\{0.2,\\,0.9,\\,1.2,\\,2.5\\}$ 中取值（即，对于每个列出的 $r_0$，设置 $\\Delta t=r_0\\,\\Delta x/v_0$）。对于每次模拟，按如下方式确定一个布尔稳定性指示符。一次运行被声明为稳定，当且仅当对于所有步数 $n=0,1,\\dots,N_{\\text{steps}}-1$，以下所有条件都得到满足： - 在任何时候，任何粒子或网格量中都没有出现浮点数的“非数值”(Not-a-Number) 或无穷大。 - 如果 $v_{i,n+\\tfrac{1}{2}}$ 表示在第 $n$ 步的时间中点评估的粒子速度，那么每步路径长度约束成立：$$\\max_i \\left|v_{i,n+\\tfrac{1}{2}}\\right|\\,\\Delta t \\le \\theta\\,\\Delta x,$$ 其中 $\\theta=0.9$。 - 在整个运行过程中，最大粒子速率满足 $$\\max_{n}\\max_i |v_{i,n}| \\le \\gamma\\,v_0,$$ 其中 $\\gamma=10$。 - 网格密度场在以下意义上保持有界：$$\\max_{n}\\left(\\frac{\\max_j \\rho_j^{(n)}}{\\bar{\\rho}}\\right) \\le \\eta,$$ 其中 $\\eta=100$，$\\rho_j^{(n)}$ 是第 $n$ 步时单元 $j$ 的密度，$\\bar{\\rho}$ 是恒定的平均密度。您的程序必须按 $r_0$ 值 $\\{0.2,\\,0.9,\\,1.2,\\,2.5\\}$ 的顺序输出四次模拟的稳定性指示符，形式为包含在方括号中的、由逗号分隔的布尔值列表的单行，例如 $[{\\rm True},{\\rm False},{\\rm True},{\\rm False}]$。不允许任何外部输入，也不涉及任何物理单位；所有量都是无量纲的。测试套件是四个初始 CFL 比率 $r_0 \\in \\{0.2,\\,0.9,\\,1.2,\\,2.5\\}$ 的集合，它探究了一个远在稳定性极限内的典型情况、一个接近边界的情况、一个轻度违反的情况以及一个严重违反的情况。最终输出格式必须是严格按照指定格式包含布尔值列表的一行。", "solution": "该问题要求实现一个用于粒子自引力系统的一维粒子-网格 (PM) 模拟，以研究显式时间积分方案的数值稳定性。问题陈述的有效性已得到确认，因为它是科学上合理的、良定的，并且为可复现的计算实验提供了所有必要的参数和条件。\n\n解决方案的核心是 PM 方法，这是一种混合技术，它利用了拉格朗日方法和欧拉方法的优点。粒子位置和速度在连续相空间中被跟踪（拉格朗日方法），而长程引力则在离散网格上计算（欧拉方法）。对于 $N_p$ 个粒子，该方法避免了直接求和方法计算上成本过高的 $O(N_p^2)$ 复杂度，代之以一系列由快速傅里叶变换 (FFT) 主导的更高效操作，对于大小为 $N_g$ 的网格，其复杂度为 $O(N_g \\log N_g)$。\n\n该模拟演化一个包含 $N_p=8192$ 个粒子的系统，每个粒子的质量为 $m_i = 1/N_p$，它们位于长度为 $L=1$ 的一维周期性域上。粒子被初始化为均匀间距 $x_i(0)=\\left(i+\\tfrac{1}{2}\\right)\\,L/N_p$ 和振幅为 $v_0=0.5$ 的正弦速度剖面 $v_i(0)=v_0 \\sin\\!\\left(2\\pi x_i(0)/L\\right)$。演化由牛顿运动方程 $\\ddot{x}_i(t) = a(x_i(t), t)$ 控制。加速度场 $a(x,t)$ 源于引力势 $\\phi(x,t)$，后者是通过在具有 $N_g=256$ 个单元的网格上求解泊松方程得到的。\n\n模拟以离散时间步进行，主要计算循环包括三个阶段：时间积分、力计算和稳定性监控。\n\n**时间积分：蛙跳 (Kick-Drift-Kick) 格式**\n为更新粒子的位置和速度，我们采用一种称为蛙跳格式的二阶精度、显式且时间可逆的积分器。其 踢-漂移-踢 (KDK) 形式特别适用于引力动力学，因为它是辛的，意味着它随时间保持相空间体积元。设 $x_n$ 和 $v_n$ 分别为时间 $t_n = n\\Delta t$ 时的位置和速度。从第 $n$ 步到第 $n+1$ 步的更新过程如下：\n1.  **速度的半步“踢” (kick):** $v_{n+1/2} = v_n + a_n \\cdot \\frac{\\Delta t}{2}$\n2.  **位置的整步“漂移” (drift):** $x_{n+1} = x_n + v_{n+1/2} \\cdot \\Delta t$\n3.  **计算新加速度:** $a_{n+1} = a(x_{n+1})$\n4.  **速度的第二个半步“踢” (kick):** $v_{n+1} = v_{n+1/2} + a_{n+1} \\cdot \\frac{\\Delta t}{2}$\n此处，$v_{n+1/2}$ 代表在时间中点 $t_n + \\Delta t/2$ 的速度。对于第一步，执行一个初始的半步“踢” $v_{1/2} = v_0 + a_0\\Delta t/2$ 来使速度相对于位置错开，从而建立蛙跳格式的交错结构。\n\n**力计算循环**\n每一步所需的加速度 $a_n = a(x_n)$ 在网格上计算，然后插值到粒子位置。\n\n1.  **质量分配 (粒子到网格):** 将粒子质量分配到计算网格的节点上以获得质量密度场 $\\rho(x,t)$。我们使用 云中单元 (CIC) 格式，这是一种二阶插值方法。对于一个位于网格节点 $j$ 和 $j+1$ 之间的粒子 (位置为 $x_p$)，其质量 $m_p$ 根据距离线性地分配给这两个节点。如果网格间距为 $\\Delta x$，权重为 $w_j = 1 - (x_p/\\Delta x - \\lfloor x_p/\\Delta x \\rfloor)$ 和 $w_{j+1} = 1 - w_j$。每个网格节点 $j$ 上的质量是所有粒子贡献的总和。然后网格密度为 $\\rho_j = M_j/\\Delta x$。该格式起到低通滤波器的作用，在网格间距的尺度上平滑密度场。\n\n2.  **泊松方程求解器 (FFT):** 引力势 $\\phi(x,t)$ 通过求解泊松方程得到，该方程为 $\\frac{\\mathrm{d}^2 \\phi}{\\mathrm{d}x^2} = 4\\pi G (\\rho(x,t)-\\bar{\\rho})$，其中 $\\bar{\\rho} = N_p m_i/L = 1$ 是平均密度。减去平均密度可确保源项的空间平均值为零，这对于周期性域上的良定问题是必要的。我们在傅里叶空间中求解此方程，其中微分变成了代数乘法。应用傅里叶变换 $\\mathcal{F}$ 可得：\n    $$ \\mathcal{F}\\left[\\frac{\\mathrm{d}^2 \\phi}{\\mathrm{d}x^2}\\right] (k) = (ik)^2 \\hat{\\phi}(k) = -k^2 \\hat{\\phi}(k) $$\n    其中 $k$ 是波数，$\\hat{\\phi}(k)=\\mathcal{F}[\\phi(x)](k)$。方程变为：\n    $$ -k^2 \\hat{\\phi}(k) = 4\\pi G \\hat{\\rho}_{\\text{over}}(k) $$\n    其中 $\\hat{\\rho}_{\\text{over}}$ 是超密度 $\\rho(x,t)-\\bar{\\rho}$ 的傅里叶变换。傅里叶空间中势的解为：\n    $$ \\hat{\\phi}(k) = - \\frac{4\\pi G \\hat{\\rho}_{\\text{over}}(k)}{k^2} \\quad \\text{for } k \\neq 0 $$\n    对于 $k=0$ 模（直流分量），问题指定 $\\hat{\\phi}(0)=0$。根据构造，超密度的 $\\hat{\\rho}_{\\text{over}}(0)=0$，避免了奇异性。\n\n3.  **加速度计算 (FFT):** 加速度场 $a(x,t) = -\\frac{\\mathrm{d}\\phi}{\\mathrm{d}x}$ 也在傅里叶空间中计算。导数的变换为 $\\hat{a}(k) = -ik \\hat{\\phi}(k)$。代入 $\\hat{\\phi}(k)$ 的表达式：\n    $$ \\hat{a}(k) = ik \\left( \\frac{4\\pi G \\hat{\\rho}_{\\text{over}}(k)}{k^2} \\right) = \\frac{4\\pi i G \\hat{\\rho}_{\\text{over}}(k)}{k} \\quad \\text{for } k \\neq 0 $$\n    并且因为 $\\hat{\\phi}(0)=0$，所以 $\\hat{a}(0)=0$。然后，通过对 $\\hat{a}(k)$ 应用逆 FFT 恢复网格上的加速度场 $a_j$。\n\n4.  **力插值 (网格到粒子):** 每个粒子位置 $x_i$ 处的加速度是从基于网格的加速度场 $a_j$ 插值得到的。为确保动量守恒，使用与质量分配相同的 CIC 权重格式进行反向操作。位置为 $x_p$ 的粒子的加速度是其两侧网格节点上加速度的加权平均：$a_p = a_j w_j + a_{j+1} w_{j+1}$。\n\n**稳定性分析**\n模拟针对四种不同的时间步长 $\\Delta t$ 运行，分别对应于初始 Courant–Friedrichs–Lewy (CFL) 比率 $r_0 = \\Delta t v_0 / \\Delta x$ 为 $\\{0.2, 0.9, 1.2, 2.5\\}$。对于每次运行，在每个时间步 $n$ 都会监控几个稳定性标准：\n- **数值完整性：** 模拟不得产生任何浮点 `NaN` 或 `infinity` 值。这是对灾难性失败的基本检查。\n- **路径长度约束：** $\\max_i |v_{i,n+\\tfrac{1}{2}}|\\,\\Delta t \\le \\theta\\,\\Delta x$，其中 $\\theta=0.9$。这是一个严格的类 CFL 条件，确保没有粒子在单个时间步内移动超过一个网格单元的 $\\theta$ 分数。违反该条件会导致力计算中的混叠误差，是导致不稳定的主要原因。\n- **速度增长：** $\\max_{n,i} |v_{i,n}| \\le \\gamma\\,v_0$，其中 $\\gamma=10$。这可以防止非物理的失控动能增长。\n- **密度对比度：** $\\max_{n,j} (\\rho_j^{(n)}/\\bar{\\rho}) \\le \\eta$，其中 $\\eta=100$。这用于检查是否形成过度致密的结构，这可能导致数值奇异点。\n\n当且仅当在整个 $N_{\\text{steps}}=300$ 步的运行过程中所有四个条件都得到满足时，一次模拟才被认为是稳定的。路径长度约束 $\\frac{\\max|v_{n+1/2}|}{v_0} r_0 \\le \\theta$ 意味着对于 $v \\approx v_0$，稳定性要求 $r_0 \\le \\theta=0.9$。因此，我们预计 $r_0=1.2$ 和 $r_0=2.5$ 的模拟会立即失败。$r_0=0.9$ 的情况临界地处于稳定性边界上，并且由于引力坍缩导致粒子速度不可避免地超过其初始值，预计也会失败。$r_0=0.2$ 的情况应该会一直处于稳定区域内。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main solver function to run simulations for all test cases and print results.\n    \"\"\"\n    \n    def run_simulation(r0: float) -> bool:\n        \"\"\"\n        Runs a single 1D Particle-Mesh simulation for a given initial CFL ratio r0.\n\n        Args:\n            r0: The initial Courant-Friedrichs-Lewy (CFL) ratio.\n\n        Returns:\n            A boolean indicating whether the simulation remained stable.\n        \"\"\"\n        # --- Problem Parameters ---\n        L = 1.0  # Domain length\n        Ng = 256  # Number of grid cells\n        Np = 8192  # Number of particles\n        v0 = 0.5  # Initial velocity amplitude\n        G = 1.0  # Gravitational constant\n        N_steps = 300  # Number of time steps\n\n        # --- Stability Check Parameters ---\n        theta = 0.9  # Path length constraint factor\n        gamma = 10.0  # Max velocity factor\n        eta = 100.0  # Max density ratio\n\n        # --- Derived Constants ---\n        dx = L / Ng  # Grid cell width\n        m = 1.0 / Np  # Particle mass\n        rho_mean = 1.0  # Mean density: (Np * m) / L\n        dt = r0 * dx / v0  # Time step\n\n        # --- Helper function for acceleration calculation ---\n        def get_accel_and_density(pos: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n            \"\"\"\n            Calculates particle accelerations and grid density using the PM method.\n            \"\"\"\n            # 1. Mass Assignment (Particle-to-Mesh) using CIC\n            grid_mass = np.zeros(Ng, dtype=np.float64)\n            pos_in_grid_units = pos / dx\n            j = np.floor(pos_in_grid_units).astype(int)\n            w_right = pos_in_grid_units - j\n            w_left = 1.0 - w_right\n            \n            # Use np.add.at for safe atomistic addition\n            np.add.at(grid_mass, j % Ng, m * w_left)\n            np.add.at(grid_mass, (j + 1) % Ng, m * w_right)\n\n            grid_density = grid_mass / dx\n\n            # 2. Solve Poisson's Equation in Fourier Space\n            overdensity = grid_density - rho_mean\n            overdensity_hat = fft.fft(overdensity)\n            \n            wavenumbers = 2.0 * np.pi * fft.fftfreq(Ng, d=dx)\n            \n            phi_hat = np.zeros_like(overdensity_hat)\n            k_sq = wavenumbers**2\n            \n            # Solve for phi_hat, handling k=0 case\n            non_zero_k = wavenumbers != 0\n            phi_hat[non_zero_k] = -4.0 * np.pi * G * overdensity_hat[non_zero_k] / k_sq[non_zero_k]\n            \n            # 3. Calculate Acceleration in Fourier Space\n            accel_hat = -1j * wavenumbers * phi_hat\n            \n            # 4. Transform Acceleration to Real Space\n            grid_accel = fft.ifft(accel_hat).real\n\n            # 5. Interpolate Acceleration to Particles (Mesh-to-Particle) using CIC\n            particle_accel = grid_accel[j % Ng] * w_left + grid_accel[(j + 1) % Ng] * w_right\n            \n            return particle_accel, grid_density\n        \n        # --- Initialization ---\n        particle_pos = (np.arange(Np, dtype=np.float64) + 0.5) * L / Np\n        particle_vel = v0 * np.sin(2.0 * np.pi * particle_pos / L)\n        \n        max_vel_history = [np.max(np.abs(particle_vel))]\n\n        try:\n            # Use np.errstate to catch floating point errors as exceptions\n            with np.errstate(all='raise'):\n                # --- Initial force calculation and half-step kick ---\n                accel, grid_density = get_accel_and_density(particle_pos)\n                \n                # Check initial density constraint\n                if np.max(grid_density) / rho_mean > eta:\n                    return False\n                \n                vel_half = particle_vel + accel * (dt / 2.0)\n                \n                # --- Main Time Integration Loop ---\n                for _ in range(N_steps):\n                    # --- Stability Check 1: Path Length (CFL) ---\n                    if np.max(np.abs(vel_half)) * dt > theta * dx:\n                        return False\n                    \n                    # --- Drift (full step) ---\n                    particle_pos += vel_half * dt\n                    particle_pos %= L  # Periodic boundary conditions\n                    \n                    # --- Force Calculation ---\n                    accel, grid_density = get_accel_and_density(particle_pos)\n\n                    # --- Stability Check 2: Density Contrast ---\n                    if np.max(grid_density) / rho_mean > eta:\n                        return False\n\n                    # --- Kick (full step for next half-step velocity) ---\n                    vel_half_next = vel_half + accel * dt\n\n                    # --- Store velocity at full step for max velocity check ---\n                    vel_full = (vel_half + vel_half_next) / 2.0\n                    max_vel_history.append(np.max(np.abs(vel_full)))\n                    \n                    # Update velocity for next iteration\n                    vel_half = vel_half_next\n\n        except FloatingPointError:\n            # --- Stability Check 3: NaN/inf detection ---\n            return False\n            \n        # --- Stability Check 4: Max velocity over entire run ---\n        if max(max_vel_history) > gamma * v0:\n            return False\n            \n        # If all checks passed for all steps\n        return True\n\n    # Define the test cases from the problem statement.\n    test_cases = [0.2, 0.9, 1.2, 2.5]\n    \n    results = [run_simulation(r0) for r0 in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424803"}, {"introduction": "纯粹的 PM 方法虽然高效，但在解析近距离粒子对之间的引力时精度有限。本练习介绍了一种更高级的混合算法——粒子-粒子-粒子-网格（P³M）方法，以弥补这一不足。你将实现一个简化的 P³M 算法，它将用于计算长程力的 PM 方法与用于计算短程（同一网格内）力的直接粒子对求和方法相结合 [@problem_id:2424778]。这个练习将向你展示“力分解”这一强大的计算物理策略，让你朝着构建更高保真度的模拟代码迈出重要一步。", "problem": "实现一个完整的程序，该程序使用一种混合定义，计算在周期性立方体域中一组粒子上的总引力加速度。该混合定义结合了基于网格的长程场与仅限于占据相同网格单元的粒子对之间的直接短程贡献。立方体域是单位立方体 $[0,1)^3$，具有周期性边界条件，所有量均采用代码单位，其中引力常数 $G=1$。目标是为每个指定的测试用例计算一个标量结果，该结果等于所有粒子的总加速度的欧几里得范数之和。将每个结果表示为代码单位的小数浮点数。\n\n粒子 $i$ 上的总加速度 $\\mathbf{a}_i^{\\mathrm{tot}}$ 定义为\n$$\n\\mathbf{a}_i^{\\mathrm{tot}} \\equiv \\mathbf{a}_i^{\\mathrm{PM}} + \\mathbf{a}_i^{\\mathrm{PP}},\n$$\n其中 $\\mathbf{a}_i^{\\mathrm{PM}}$ 是一个粒子-网格（particle–mesh）长程场，$\\mathbf{a}_i^{\\mathrm{PP}}$ 是一个仅限于相同网格单元内粒子对之间的直接粒子-粒子（particle–particle）短程项。长程场 $\\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x})$ 的定义如下。\n\n1. 假设有 $N$ 个粒子，其位置为 $\\mathbf{x}_p \\in [0,1)^3$，质量为 $m_p$，其中 $p=1,\\dots,N$。令 $N_g$ 为每个维度的网格点数，均匀网格间距为 $h \\equiv 1/N_g$。通过云中单元（CIC）分配方法在网格上定义质量密度场。将一维云中单元（CIC）权重表示为\n$$\nw(\\Delta) \\equiv \\begin{cases}\n1 - |\\Delta|/h, & \\text{if } |\\Delta| < h,\\\\\n0, & \\text{otherwise,}\n\\end{cases}\n$$\n三维形状函数为\n$$\nW_{\\mathrm{CIC}}(\\mathbf{x}-\\mathbf{x}_p) \\equiv w(x-x_p)\\,w(y-y_p)\\,w(z-z_p).\n$$\n令 $\\rho(\\mathbf{x}_{ijk})$ 为节点索引 $(i,j,k)$ 处的网格密度，其中 $\\mathbf{x}_{ijk}$ 是节点位置。密度由三线性分配定义\n$$\n\\rho(\\mathbf{x}_{ijk}) \\equiv \\sum_{p=1}^{N} \\frac{m_p}{h^3}\\, W_{\\mathrm{CIC}}(\\mathbf{x}_{ijk}-\\mathbf{x}_p),\n$$\n其中索引按模 $N_g$ 进行周期性解释。\n\n2. 定义零均值密度 $\\rho^\\star(\\mathbf{x}_{ijk}) \\equiv \\rho(\\mathbf{x}_{ijk}) - \\bar{\\rho}$，其中\n$$\n\\bar{\\rho} \\equiv \\frac{1}{N_g^3} \\sum_{i,j,k} \\rho(\\mathbf{x}_{ijk}).\n$$\n\n3. 令 $\\widehat{\\rho^\\star}(\\mathbf{k})$ 为 $\\rho^\\star(\\mathbf{x}_{ijk})$ 的三维离散傅里叶变换，使用标准离散频率。令角波矢量分量为 $k_x \\equiv 2\\pi n_x$，$k_y \\equiv 2\\pi n_y$，$k_z \\equiv 2\\pi n_z$，其中 $n_\\alpha$ 是在间距为 $h\\equiv 1/N_g$ 的网格上进行离散傅里叶变换返回的整数频率。令 $k^2 \\equiv k_x^2 + k_y^2 + k_z^2$。将加速度场的傅里叶分量定义为\n$$\n\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k}) \\equiv \\begin{cases}\n\\mathbf{0}, & \\text{if } \\mathbf{k}=\\mathbf{0},\\\\\n\\mathrm{i}\\,4\\pi\\,G\\,\\dfrac{\\mathbf{k}}{k^2}\\,\\widehat{\\rho^\\star}(\\mathbf{k}), & \\text{otherwise.}\n\\end{cases}\n$$\n令 $\\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk})$ 通过对 $\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k})$ 进行逆变换得到。\n\n4. 通过使用相同的云中单元（CIC）权重将网格场插值到粒子位置，定义粒子 $i$ 上的长程加速度：\n$$\n\\mathbf{a}_i^{\\mathrm{PM}} \\equiv \\sum_{i,j,k} \\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk}) \\, W_{\\mathrm{CIC}}(\\mathbf{x}_{ijk}-\\mathbf{x}_i).\n$$\n\n短程项通过对同一网格单元内的粒子对进行直接求和来定义。令基准单元索引映射为\n$$\n\\mathbf{b}(\\mathbf{x}) \\equiv \\left(\\left\\lfloor N_g x \\right\\rfloor,\\left\\lfloor N_g y \\right\\rfloor,\\left\\lfloor N_g z \\right\\rfloor\\right) \\bmod N_g.\n$$\n令 $\\varepsilon>0$ 为一个软化长度。对于满足 $\\mathbf{b}(\\mathbf{x}_i)=\\mathbf{b}(\\mathbf{x}_j)$ 的每个无序对 $\\{i,j\\}$（其中 $i\\neq j$），定义其贡献为\n$$\n\\mathbf{a}_{i\\leftarrow j}^{\\mathrm{PP}} \\equiv - G\\, m_j\\, \\frac{\\mathbf{r}_{ij}}{\\left(\\|\\mathbf{r}_{ij}\\|^2 + \\varepsilon^2\\right)^{3/2}}, \\quad \\text{其中 } \\mathbf{r}_{ij}\\equiv \\mathbf{x}_i-\\mathbf{x}_j,\n$$\n并设\n$$\n\\mathbf{a}_i^{\\mathrm{PP}} \\equiv \\sum_{\\substack{j\\neq i\\\\ \\mathbf{b}(\\mathbf{x}_j)=\\mathbf{b}(\\mathbf{x}_i)}} \\mathbf{a}_{i\\leftarrow j}^{\\mathrm{PP}}.\n$$\n请注意，分离矢量 $\\mathbf{r}_{ij}$ 无需进行任何周期性图像环绕处理，因为同单元条件确保了对于每个分量 $\\alpha\\in\\{x,y,z\\}$ 都有 $|\\Delta_\\alpha|<h$。\n\n对于一个给定的测试用例，具有指定的 $N$、$\\{m_p\\}_{p=1}^N$、$\\{\\mathbf{x}_p\\}_{p=1}^N$、$N_g$ 和 $\\varepsilon$，计算标量\n$$\nS \\equiv \\sum_{i=1}^{N} \\left\\| \\mathbf{a}_i^{\\mathrm{tot}} \\right\\|,\n$$\n其中 $\\|\\cdot\\|$ 表示 $\\mathbb{R}^3$中的欧几里得范数。将 $S$ 用代码单位表示为一个四舍五入到10位小数的浮点数。\n\n使用以下参数值的测试套件：\n\n- 测试用例 1 (一般情况，两个粒子在同一单元，另一个在别处):\n  - $N=3$, $N_g=16$, $\\varepsilon=10^{-3}$。\n  - 质量 $(m_1,m_2,m_3)=\\left(1.0,\\,1.0,\\,2.5\\right)$。\n  - 位置 $\\mathbf{x}_1=\\left(0.10,\\,0.10,\\,0.10\\right)$, $\\mathbf{x}_2=\\left(0.12,\\,0.10,\\,0.10\\right)$, $\\mathbf{x}_3=\\left(0.80,\\,0.80,\\,0.80\\right)$。\n\n- 测试用例 2 (边界相邻的粒子对，位于不同单元，无直接短程贡献):\n  - $N=2$, $N_g=8$, $\\varepsilon=2\\times 10^{-3}$。\n  - 质量 $(m_1,m_2)=\\left(1.0,\\,1.5\\right)$。\n  - 位置 $\\mathbf{x}_1=\\left(0.499,\\,0.25,\\,0.25\\right)$, $\\mathbf{x}_2=\\left(0.501,\\,0.25,\\,0.25\\right)$。\n\n- 测试用例 3 (单个单元内有多个粒子，涉及多个直接相互作用):\n  - $N=3$, $N_g=8$, $\\varepsilon=3\\times 10^{-3}$。\n  - 质量 $(m_1,m_2,m_3)=\\left(0.5,\\,1.0,\\,0.75\\right)$。\n  - 位置 $\\mathbf{x}_1=\\left(0.70,\\,0.10,\\,0.90\\right)$, $\\mathbf{x}_2=\\left(0.72,\\,0.09,\\,0.89\\right)$, $\\mathbf{x}_3=\\left(0.715,\\,0.105,\\,0.905\\right)$。\n\n- 测试用例 4 (单个粒子，用于探查零均值长程场的行为):\n  - $N=1$, $N_g=16$, $\\varepsilon=10^{-3}$。\n  - 质量 $m_1=\\left(1.0\\right)$。\n  - 位置 $\\mathbf{x}_1=\\left(0.33,\\,0.66,\\,0.50\\right)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与测试用例的顺序相同。列表中的每个元素必须是该测试用例的 $S$ 值，四舍五入到10位小数。例如，输出格式应与 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$ 完全一样，不含任何额外文本。", "solution": "该问题要求实现一种混合的粒子-网格 (PM) 和粒子-粒子 (PP) 方法，以计算周期性立方体域中的引力加速度。该问题定义明确，科学上可靠，并提供了所有必要的参数和方程。这是计算物理学中的一个标准问题，特别是在N体模拟领域。我将进行详细的、分步的求解。\n\n粒子 $i$ 上的总加速度是长程 PM 分量和短程 PP 分量之和：\n$$\n\\mathbf{a}_i^{\\mathrm{tot}} = \\mathbf{a}_i^{\\mathrm{PM}} + \\mathbf{a}_i^{\\mathrm{PP}}\n$$\n最终结果是这些总加速度在所有粒子上的大小之和，$S = \\sum_{i=1}^{N} \\left\\| \\mathbf{a}_i^{\\mathrm{tot}} \\right\\|$。我们将设置引力常数 $G = 1$。\n\n**第1部分：粒子-网格 (PM) 加速度**\n\nPM 分量通过四个阶段计算：质量分配、傅里叶空间场求解、傅里叶逆变换和力插值。\n\n**阶段1.1：质量分配**\n首先，我们将 $N$ 个粒子的质量离散化到一个大小为 $N_g \\times N_g \\times N_g$ 的均匀网格上。域是单位立方体 $[0,1)^3$，所以网格间距为 $h = 1/N_g$。我们使用云中单元（CIC）分配方案。位于位置 $\\mathbf{x}_p$ 的粒子对其最近的8个网格节点的密度有贡献。对每个节点的贡献由一个云（一个以粒子为中心、边长为 $h$ 的立方体）与网格单元的体积重叠部分进行加权。\n\n一维 CIC 权重函数由下式给出：\n$$\nw(\\Delta) = \\max(0, 1 - |\\Delta|/h)\n$$\n其中 $\\Delta$ 是沿一个轴从粒子到网格节点的距离。对于位于 $\\mathbf{x}_{ijk}$ 的节点，相对于位于 $\\mathbf{x}_p$ 的粒子的三维权重，是一维权重的乘积：\n$$\nW_{\\mathrm{CIC}}(\\mathbf{x}_{ijk} - \\mathbf{x}_p) = w(x_{ijk} - x_p) w(y_{ijk} - y_p) w(z_{ijk} - z_p)\n$$\n网格节点 $\\mathbf{x}_{ijk}$ 处的质量密度 $\\rho$ 是所有粒子贡献的总和，并按单元体积 $h^3$ 进行归一化：\n$$\n\\rho(\\mathbf{x}_{ijk}) = \\frac{1}{h^3} \\sum_{p=1}^{N} m_p W_{\\mathrm{CIC}}(\\mathbf{x}_{ijk} - \\mathbf{x}_p)\n$$\n索引按模 $N_g$ 进行周期性处理。\n\n**阶段1.2：傅里叶空间求解**\n引力势 $\\phi$ 通过泊松方程 $\\nabla^2\\phi = 4\\pi G \\rho$ 与质量密度相关联。为在周期性域中求解此方程，我们使用傅里叶变换。首先，我们计算平均密度 $\\bar{\\rho}$ 并将其减去，以获得零均值密度涨落场 $\\rho^\\star = \\rho - \\bar{\\rho}$。这一步对于周期性系统至关重要，以确保平均引力为零，从而正确处理傅里叶空间中的 $\\mathbf{k}=\\mathbf{0}$ 模式。\n$$\n\\bar{\\rho} = \\frac{1}{N_g^3} \\sum_{i,j,k=0}^{N_g-1} \\rho(\\mathbf{x}_{ijk})\n$$\n在傅里叶空间中，泊松方程变成一个代数关系。令 $\\widehat{\\rho^\\star}(\\mathbf{k})$ 为 $\\rho^\\star(\\mathbf{x}_{ijk})$ 的离散傅里叶变换 (DFT)。加速度场 $\\mathbf{a} = -\\nabla\\phi$ 的 DFT 由下式给出：\n$$\n\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k}) = -i\\mathbf{k}\\widehat{\\phi}(\\mathbf{k}) = -i\\mathbf{k} \\left( \\frac{4\\pi G \\widehat{\\rho^\\star}(\\mathbf{k})}{-k^2} \\right) = i 4\\pi G \\frac{\\mathbf{k}}{k^2} \\widehat{\\rho^\\star}(\\mathbf{k})\n$$\n其中 $\\mathbf{k} = (k_x, k_y, k_z)$ 是波矢量， $k^2 = \\|\\mathbf{k}\\|^2$。波矢量由网格确定：对于单位立方体，$k_\\alpha = 2\\pi n_\\alpha$，其中 $n_\\alpha$ 是来自 DFT 的整数频率。对于 $\\mathbf{k}=\\mathbf{0}$，势是未定义的，但由于我们使用 $\\rho^\\star$，$\\widehat{\\rho^\\star}(\\mathbf{k}=\\mathbf{0})=0$，因此我们定义 $\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k}=\\mathbf{0})=\\mathbf{0}$。\n\n**阶段1.3：逆变换**\n网格上的实空间加速度场 $\\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk})$ 是通过对 $\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k})$ 的每个分量应用离散傅里叶逆变换 (IDFT) 得到的。\n$$\n\\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk}) = \\text{IDFT} \\left[ \\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k}) \\right]\n$$\n\n**阶段1.4：力插值**\n最后，通过将基于网格的加速度场插值回粒子位置，可以找到位于位置 $\\mathbf{x}_i$ 的粒子 $i$ 上的 PM 加速度。这是使用与质量分配相同的 CIC 加权方案完成的，这确保了动量守恒：\n$$\n\\mathbf{a}_i^{\\mathrm{PM}} = \\sum_{i,j,k} \\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk}) W_{\\mathrm{CIC}}(\\mathbf{x}_{ijk} - \\mathbf{x}_i)\n$$\n\n**第2部分：粒子-粒子 (PP) 加速度**\n\nPP 分量负责处理网格上分辨率较差的短程相互作用。问题将此项定义为对驻留在同一网格单元内的粒子对的直接求和。\n\n首先，我们将每个粒子与一个基准网格单元索引关联起来 $\\mathbf{b}(\\mathbf{x}) = (\\lfloor N_g x \\rfloor, \\lfloor N_g y \\rfloor, \\lfloor N_g z \\rfloor) \\pmod{N_g}$。对于满足 $\\mathbf{b}(\\mathbf{x}_i) = \\mathbf{b}(\\mathbf{x}_j)$ 的任意两个不同粒子 $i$ 和 $j$，计算直接作用力。粒子 $i$ 因粒子 $j$ 而产生的加速度由软化的牛顿引力定律给出：\n$$\n\\mathbf{a}_{i\\leftarrow j}^{\\mathrm{PP}} = -G m_j \\frac{\\mathbf{r}_{ij}}{(\\|\\mathbf{r}_{ij}\\|^2 + \\varepsilon^2)^{3/2}}\n$$\n其中 $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$ 是直接分离矢量，$\\varepsilon$ 是软化长度，用于防止在小间距处出现奇异点。粒子 $i$ 上的总 PP 加速度是同一单元中所有其他粒子 $j$ 的贡献之和：\n$$\n\\mathbf{a}_i^{\\mathrm{PP}} = \\sum_{\\substack{j \\neq i \\\\ \\mathbf{b}(\\mathbf{x}_j) = \\mathbf{b}(\\mathbf{x}_i)}} \\mathbf{a}_{i\\leftarrow j}^{\\mathrm{PP}}\n$$\n\n**第3部分：最终计算**\n\n对于每个粒子 $i$，通过将两个分量相加来计算总加速度：$\\mathbf{a}_i^{\\mathrm{tot}} = \\mathbf{a}_i^{\\mathrm{PM}} + \\mathbf{a}_i^{\\mathrm{PP}}$。要计算的最终量是这些总加速度矢量的欧几里得范数的标量和：\n$$\nS = \\sum_{i=1}^{N} \\left\\| \\mathbf{a}_i^{\\mathrm{tot}} \\right\\| = \\sum_{i=1}^{N} \\sqrt{(a_{i,x}^{\\mathrm{tot}})^2 + (a_{i,y}^{\\mathrm{tot}})^2 + (a_{i,z}^{\\mathrm{tot}})^2}\n$$\n此过程将应用于每个提供的测试用例。", "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef _compute_s(N, masses, positions, Ng, eps):\n    \"\"\"\n    Computes the total gravitational acceleration sum S for a set of particles.\n    \"\"\"\n    G = 1.0\n    h = 1.0 / Ng\n\n    # --- Part 1: Particle-Mesh (PM) Acceleration ---\n\n    # 1.1: Mass Assignment (CIC)\n    rho = np.zeros((Ng, Ng, Ng), dtype=np.float64)\n    for p in range(N):\n        m_p = masses[p]\n        pos_p = positions[p]\n        \n        scaled_pos = pos_p * Ng\n        base_idx = np.floor(scaled_pos).astype(int)\n        frac_pos = scaled_pos - base_idx\n\n        # Distribute mass to 8 neighboring nodes\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    node_idx = (\n                        (base_idx[0] + di) % Ng,\n                        (base_idx[1] + dj) % Ng,\n                        (base_idx[2] + dk) % Ng,\n                    )\n\n                    # Trilinear weight\n                    wx = (1 - di) * (1 - frac_pos[0]) + di * frac_pos[0]\n                    wy = (1 - dj) * (1 - frac_pos[1]) + dj * frac_pos[1]\n                    wz = (1 - dk) * (1 - frac_pos[2]) + dk * frac_pos[2]\n                    weight = wx * wy * wz\n                    \n                    rho[node_idx] += m_p * weight / (h**3)\n\n    # 1.2: Fourier-Space Field Solution\n    rho_mean = np.mean(rho)\n    rho_star = rho - rho_mean\n    rho_star_k = np.fft.fftn(rho_star)\n\n    # Generate k-vectors\n    k_freq = np.fft.fftfreq(Ng, h) * (2 * np.pi)\n    Kx, Ky, Kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    K2 = Kx**2 + Ky**2 + Kz**2\n\n    # Avoid division by zero for k=0 mode\n    # The numerator rho_star_k[0,0,0] is already zero, but this is safer\n    K2[0, 0, 0] = 1.0\n    \n    # Fourier-space acceleration field\n    # a_hat = i * 4 * pi * G * k / k^2 * rho_star_k\n    prefactor = 1j * 4 * np.pi * G / K2\n    a_pm_k_x = prefactor * Kx * rho_star_k\n    a_pm_k_y = prefactor * Ky * rho_star_k\n    a_pm_k_z = prefactor * Kz * rho_star_k\n\n    # Set k=0 mode to zero explicitly\n    a_pm_k_x[0, 0, 0] = 0.0\n    a_pm_k_y[0, 0, 0] = 0.0\n    a_pm_k_z[0, 0, 0] = 0.0\n    \n    # 1.3: Inverse Transform to get grid-based acceleration\n    a_pm_grid_x = np.real(np.fft.ifftn(a_pm_k_x))\n    a_pm_grid_y = np.real(np.fft.ifftn(a_pm_k_y))\n    a_pm_grid_z = np.real(np.fft.ifftn(a_pm_k_z))\n    a_pm_grid = np.stack((a_pm_grid_x, a_pm_grid_y, a_pm_grid_z), axis=-1)\n\n    # 1.4: Force Interpolation (CIC)\n    a_pm = np.zeros((N, 3), dtype=np.float64)\n    for p in range(N):\n        pos_p = positions[p]\n        \n        scaled_pos = pos_p * Ng\n        base_idx = np.floor(scaled_pos).astype(int)\n        frac_pos = scaled_pos - base_idx\n        \n        accel_p = np.zeros(3, dtype=np.float64)\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    node_idx = (\n                        (base_idx[0] + di) % Ng,\n                        (base_idx[1] + dj) % Ng,\n                        (base_idx[2] + dk) % Ng,\n                    )\n                    \n                    wx = (1 - di) * (1 - frac_pos[0]) + di * frac_pos[0]\n                    wy = (1 - dj) * (1 - frac_pos[1]) + dj * frac_pos[1]\n                    wz = (1 - dk) * (1 - frac_pos[2]) + dk * frac_pos[2]\n                    weight = wx * wy * wz\n                    \n                    accel_p += a_pm_grid[node_idx] * weight\n        a_pm[p] = accel_p\n\n    # --- Part 2: Particle-Particle (PP) Acceleration ---\n    \n    cell_map = defaultdict(list)\n    for p in range(N):\n        cell_idx = tuple(np.floor(positions[p] * Ng).astype(int))\n        cell_map[cell_idx].append(p)\n    \n    a_pp = np.zeros((N, 3), dtype=np.float64)\n    for cell_idx, particles_in_cell in cell_map.items():\n        if len(particles_in_cell) > 1:\n            for i, j in combinations(particles_in_cell, 2):\n                rij = positions[i] - positions[j]\n                r_sq = np.sum(rij**2)\n                dist_cubed = (r_sq + eps**2)**1.5\n                \n                # Acceleration on i due to j\n                accel_on_i = -G * masses[j] * rij / dist_cubed\n                # Acceleration on j due to i (by Newton's 3rd law symmetry)\n                accel_on_j = G * masses[i] * rij / dist_cubed\n                \n                a_pp[i] += accel_on_i\n                a_pp[j] += accel_on_j\n\n    # --- Part 3: Final Calculation ---\n    \n    a_tot = a_pm + a_pp\n    norms = np.linalg.norm(a_tot, axis=1)\n    S = np.sum(norms)\n\n    return S\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 3, \"Ng\": 16, \"eps\": 1e-3,\n            \"masses\": np.array([1.0, 1.0, 2.5]),\n            \"positions\": np.array([\n                [0.10, 0.10, 0.10],\n                [0.12, 0.10, 0.10],\n                [0.80, 0.80, 0.80]\n            ])\n        },\n        {\n            \"N\": 2, \"Ng\": 8, \"eps\": 2e-3,\n            \"masses\": np.array([1.0, 1.5]),\n            \"positions\": np.array([\n                [0.499, 0.25, 0.25],\n                [0.501, 0.25, 0.25]\n            ])\n        },\n        {\n            \"N\": 3, \"Ng\": 8, \"eps\": 3e-3,\n            \"masses\": np.array([0.5, 1.0, 0.75]),\n            \"positions\": np.array([\n                [0.70, 0.10, 0.90],\n                [0.72, 0.09, 0.89],\n                [0.715, 0.105, 0.905]\n            ])\n        },\n        {\n            \"N\": 1, \"Ng\": 16, \"eps\": 1e-3,\n            \"masses\": np.array([1.0]),\n            \"positions\": np.array([\n                [0.33, 0.66, 0.50]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _compute_s(\n            case[\"N\"], case[\"masses\"], case[\"positions\"], case[\"Ng\"], case[\"eps\"]\n        )\n        results.append(f\"{result:.10f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2424778"}]}