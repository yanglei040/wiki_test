{"hands_on_practices": [{"introduction": "在分子动力学模拟中，准确计算粒子间的作用力是驱动系统演化的关键。本练习将引导你完成从埃瓦尔德能量表达式到具体作用力计算的核心步骤。通过对总能量进行解析微分，你将推导出实空间和倒易空间中每个粒子所受的力，并编写代码来解决具体问题 [@problem_id:2390985]。这个过程不仅能加深你对埃瓦尔德求和法内部机制的理解，也是掌握任何基于能量的力场模拟的基础。", "problem": "考虑一个系统，其中包含 $N$ 个点电荷，其电荷量为 $\\{q_i\\}_{i=1}^N$，位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$。这些点电荷位于一个边长为 $L$ 的立方模拟单元内，并采用周期性边界条件 (PBC)。在约化静电单位下进行计算，其中 $4\\pi\\varepsilon_0 = 1$，因此所有能量和力都无需额外的物理常数来表示。距离单位应解释为纳米 (nm)，力必须以 $e^2\\,\\mathrm{nm}^{-2}$ 的约化单位报告。假设在无穷远处存在导电（锡箔）边界条件。\n\n从三维周期性立方单元的标准 Ewald 分裂总静电能出发，该体系具有高斯屏蔽参数 $\\alpha > 0$、实空间截断半径 $r_{\\mathrm{cut}}$ 和倒易空间截断 $k_{\\max}$。使用将能量分解为实空间项、倒易空间项和自能项的常规方法。在倒易空间中，将倒易晶格矢量集定义为 $\\mathbf{k} = \\frac{2\\pi}{L}\\,\\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$，并且只包含满足 $0 < \\lVert \\mathbf{k} \\rVert \\le k_{\\max}$ 的矢量。将结构因子定义为 $S(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{i \\mathbf{k}\\cdot \\mathbf{r}_j}$。在实空间中，对粒子间位移矢量使用最小镜像约定，并且当且仅当最小镜像距离 $r_{ij}$ 满足 $r_{ij} \\le r_{\\mathrm{cut}}$ 时，才将该粒子对包含在实空间求和中。假设 $r_{\\mathrm{cut}} \\le L/2$，因此在实空间中每个粒子对最多有一个镜像有贡献。在能量计算中必须考虑自能项，但请注意，在这些条件下，它对力没有贡献。\n\n您的任务是：对 Ewald 总能量相对于 $\\mathbf{r}_i$ 进行解析求导，以获得作用在每个粒子上的总力 $\\mathbf{F}_i$，并实现一个程序来为以下每个测试用例计算这些力。在中间计算中出现的任何角度（如有）都应以弧度为单位。\n\n测试套件（每个用例都严格保持电中性）：\n\n- 用例 A（通用构型）：\n  - $L = 1.0\\,\\mathrm{nm}$，$\\alpha = 5.0\\,\\mathrm{nm}^{-1}$，$r_{\\mathrm{cut}} = 0.49\\,\\mathrm{nm}$，$k_{\\max} = 25.132741228718345\\,\\mathrm{nm}^{-1}$。\n  - $N = 2$，电荷 $[+1,-1]$，位置 (单位 $\\mathrm{nm}$)：$\\mathbf{r}_1 = (0.0, 0.0, 0.0)$，$\\mathbf{r}_2 = (0.3, 0.0, 0.0)$。\n- 用例 B（边界附近的多个电荷）：\n  - $L = 1.0\\,\\mathrm{nm}$，$\\alpha = 5.0\\,\\mathrm{nm}^{-1}$，$r_{\\mathrm{cut}} = 0.49\\,\\mathrm{nm}$，$k_{\\max} = 25.132741228718345\\,\\mathrm{nm}^{-1}$。\n  - $N = 4$，电荷 $[+1,+1,-1,-1]$，位置 (单位 $\\mathrm{nm}$)：\n    $\\mathbf{r}_1 = (0.1, 0.1, 0.1)$，\n    $\\mathbf{r}_2 = (0.9, 0.1, 0.1)$，\n    $\\mathbf{r}_3 = (0.1, 0.9, 0.1)$，\n    $\\mathbf{r}_4 = (0.9, 0.9, 0.1)$。\n- 用例 C（边界距离的边缘情况）：\n  - $L = 1.0\\,\\mathrm{nm}$，$\\alpha = 7.0\\,\\mathrm{nm}^{-1}$，$r_{\\mathrm{cut}} = 0.50\\,\\mathrm{nm}$，$k_{\\max} = 31.41592653589793\\,\\mathrm{nm}^{-1}$。\n  - $N = 2$，电荷 $[+1,-1]$，位置 (单位 $\\mathrm{nm}$)：$\\mathbf{r}_1 = (0.25, 0.25, 0.25)$，$\\mathbf{r}_2 = (0.75, 0.25, 0.25)$。\n\n对于每个测试用例，计算力矢量 $\\{\\mathbf{F}_i\\}_{i=1}^N$，单位为约化单位 $e^2\\,\\mathrm{nm}^{-2}$。对于数值报告，将每个笛卡尔分量四舍五入到八位小数。\n\n最终输出格式：您的程序必须生成单行输出，其中包含一个 Python 风格的列表的列表。每个子列表对应一个测试用例，并包含按粒子索引和笛卡尔分量排序的展平的、逗号分隔的、四舍五入后的力分量，格式为 $[F_{x,1},F_{y,1},F_{z,1},F_{x,2},F_{y,2},F_{z,2},\\dots]$。请删除打印行中的所有空格。例如，包含两个用例的一行应类似于 [[${0.1}$,${0.0}$,${0.0}$,${-0.1}$,${0.0}$,${0.0}$],[${\\dots}$]]，但使用的是这些测试用例的实际计算数值。", "solution": "所提出的问题是计算物理学中一个标准的、适定性良好的练习，涉及使用 Ewald 求和方法计算静电力。该问题在科学上是合理的、内容自洽，并且所有参数都得到了明确指定。因此，该问题被视为有效，下面将给出完整解答。\n\n目标是计算一个包含 $N$ 个点电荷的周期性系统中每个粒子 $i$ 受到的力 $\\mathbf{F}_i$。力是总静电势能 $U$ 相对于粒子位置矢量 $\\mathbf{r}_i$ 的负梯度：\n$$\n\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U\n$$\nEwald 方法将总能量 $U$ 划分为三个分量：一个短程实空间项 ($U_{\\text{real}}$)、一个长程倒易空间项 ($U_{\\text{recip}}$) 和一个自能校正项 ($U_{\\text{self}}$)。单位被约化，使得 $4\\pi\\varepsilon_0 = 1$。\n$$\nU = U_{\\text{real}} + U_{\\text{recip}} + U_{\\text{self}}\n$$\n粒子 $i$ 所受的力也相应地划分为：\n$$\n\\mathbf{F}_i = \\mathbf{F}_{i, \\text{real}} + \\mathbf{F}_{i, \\text{recip}} + \\mathbf{F}_{i, \\text{self}}\n$$\n我们将通过对相应的能量项进行解析求导来推导每个力分量的表达式。\n\n自能项由下式给出：\n$$\nU_{\\text{self}} = -\\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{j=1}^N q_j^2\n$$\n该项相对于粒子位置是一个常数。因此，其梯度为零，对力没有贡献：\n$$\n\\mathbf{F}_{i, \\text{self}} = -\\nabla_{\\mathbf{r}_i} U_{\\text{self}} = \\mathbf{0}\n$$\n\n对于最小镜像距离 $r_{ij} = |\\mathbf{r}_{ij}|$ 在指定截断半径 $r_{\\text{cut}}$ 内的粒子对 $(i,j)$，其实空间能量贡献为：\n$$\nU_{\\text{real}} = \\frac{1}{2} \\sum_{i \\ne j, r_{ij} \\le r_{\\text{cut}}} q_i q_j \\frac{\\text{erfc}(\\alpha r_{ij})}{r_{ij}}\n$$\n其中 $\\text{erfc}(x)$ 是互补误差函数。作用在粒子 $i$ 上的力通过对该和式相对于 $\\mathbf{r}_i$ 求导得到。只有涉及粒子 $i$ 的项有贡献。\n$$\n\\mathbf{F}_{i, \\text{real}} = -\\nabla_{\\mathbf{r}_i} \\sum_{j \\ne i, r_{ij} \\le r_{\\text{cut}}} q_i q_j \\frac{\\text{erfc}(\\alpha r_{ij})}{r_{ij}}\n$$\n应用链式法则，$\\nabla_{\\mathbf{r}_i} f(r_{ij}) = (\\frac{df}{dr_{ij}}) \\nabla_{\\mathbf{r}_i} r_{ij} = (\\frac{df}{dr_{ij}}) \\frac{\\mathbf{r}_{ij}}{r_{ij}}$，其中 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ 是最小镜像位移矢量。我们必须对函数 $g(r) = q_i q_j \\text{erfc}(\\alpha r)/r$ 求导：\n$$\n\\frac{d}{dr} \\left( \\frac{\\text{erfc}(\\alpha r)}{r} \\right) = -\\frac{\\text{erfc}(\\alpha r)}{r^2} + \\frac{1}{r} \\left(-\\frac{2\\alpha}{\\sqrt{\\pi}}e^{-\\alpha^2 r^2}\\right)\n$$\n综合这些部分，作用在粒子 $i$ 上的实空间力为：\n$$\n\\mathbf{F}_{i, \\text{real}} = \\sum_{j \\ne i, r_{ij} \\le r_{\\text{cut}}} q_i q_j \\left[ \\frac{\\text{erfc}(\\alpha r_{ij})}{r_{ij}^2} + \\frac{2\\alpha}{\\sqrt{\\pi} r_{ij}} e^{-\\alpha^2 r_{ij}^2} \\right] \\frac{\\mathbf{r}_{ij}}{r_{ij}}\n$$\n\n倒易空间能量由对倒易晶格矢量 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$（其中 $\\mathbf{n} \\in \\mathbb{Z}^3$ 为整数矢量）的求和给出。对于具有导电边界条件的电中性系统，$\\mathbf{k}=\\mathbf{0}$ 项被排除。\n$$\nU_{\\text{recip}} = \\frac{2\\pi}{L^3} \\sum_{0 < |\\mathbf{k}| \\le k_{\\max}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} |S(\\mathbf{k})|^2\n$$\n其中 $k=|\\mathbf{k}|$，$S(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{i\\mathbf{k}\\cdot\\mathbf{r}_j}$ 是结构因子。为了求力，我们对 $\\mathbf{r}_i$ 求导。唯一对 $\\mathbf{r}_i$ 的依赖存在于 $|S(\\mathbf{k})|^2 = S(\\mathbf{k})S(-\\mathbf{k})$ 中。\n$$\n\\nabla_{\\mathbf{r}_i} |S(\\mathbf{k})|^2 = (\\nabla_{\\mathbf{r}_i} S(\\mathbf{k})) S(-\\mathbf{k}) + S(\\mathbf{k}) (\\nabla_{\\mathbf{r}_i} S(-\\mathbf{k}))\n$$\n结构因子的梯度为 $\\nabla_{\\mathbf{r}_i} S(\\mathbf{k}) = i\\mathbf{k} q_i e^{i\\mathbf{k}\\cdot\\mathbf{r}_i}$ 和 $\\nabla_{\\mathbf{r}_i} S(-\\mathbf{k}) = -i\\mathbf{k} q_i e^{-i\\mathbf{k}\\cdot\\mathbf{r}_i}$。将它们代入可得：\n$$\n\\nabla_{\\mathbf{r}_i} |S(\\mathbf{k})|^2 = i\\mathbf{k} q_i \\left( e^{i\\mathbf{k}\\cdot\\mathbf{r}_i} S(-\\mathbf{k}) - e^{-i\\mathbf{k}\\cdot\\mathbf{r}_i} S(\\mathbf{k}) \\right)\n$$\n该表达式可简化为：\n$$\n\\nabla_{\\mathbf{r}_i} |S(\\mathbf{k})|^2 = -2 q_i \\mathbf{k} \\sum_{j=1}^N q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i-\\mathbf{r}_j))\n$$\n因此，倒易空间力为：\n$$\n\\mathbf{F}_{i, \\text{recip}} = -\\nabla_{\\mathbf{r}_i} U_{\\text{recip}} = \\frac{4\\pi q_i}{L^3} \\sum_{0 < |\\mathbf{k}| \\le k_{\\max}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\sum_{j=1}^N q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i-\\mathbf{r}_j))\n$$\n为了提高计算效率，使用三角恒等式将对 $j$ 的内层求和展开：\n$$\n\\sum_{j=1}^N q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i-\\mathbf{r}_j)) = \\sin(\\mathbf{k}\\cdot\\mathbf{r}_i)\\left(\\sum_j q_j \\cos(\\mathbf{k}\\cdot\\mathbf{r}_j)\\right) - \\cos(\\mathbf{k}\\cdot\\mathbf{r}_i)\\left(\\sum_j q_j \\sin(\\mathbf{k}\\cdot\\mathbf{r}_j)\\right)\n$$\n令 $C(\\mathbf{k}) = \\sum_j q_j \\cos(\\mathbf{k}\\cdot\\mathbf{r}_j)$ 且 $S_{\\text{sum}}(\\mathbf{k}) = \\sum_j q_j \\sin(\\mathbf{k}\\cdot\\mathbf{r}_j)$。作用在粒子 $i$ 上的倒易空间力的最终表达式为：\n$$\n\\mathbf{F}_{i, \\text{recip}} = \\frac{4\\pi q_i}{L^3} \\sum_{0 < |\\mathbf{k}| \\le k_{\\max}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\left( \\sin(\\mathbf{k}\\cdot\\mathbf{r}_i) C(\\mathbf{k}) - \\cos(\\mathbf{k}\\cdot\\mathbf{r}_i) S_{\\text{sum}}(\\mathbf{k}) \\right)\n$$\n具体实现将通过以下步骤进行：首先，计算截断半径内所有粒子对的实空间力贡献；然后，通过对指定的 $\\mathbf{k}$ 矢量集求和来计算倒易空间贡献。为了优化计算，对于每个 $\\mathbf{k}$，求和项 $C(\\mathbf{k})$ 和 $S_{\\text{sum}}(\\mathbf{k})$ 会被预先计算。最终的力是这两个分量的和。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Computes electrostatic forces on systems of point charges using Ewald summation.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"L\": 1.0,\n            \"alpha\": 5.0,\n            \"r_cut\": 0.49,\n            \"k_max\": 25.132741228718345,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.3, 0.0, 0.0]])\n        },\n        # Case B\n        {\n            \"L\": 1.0,\n            \"alpha\": 5.0,\n            \"r_cut\": 0.49,\n            \"k_max\": 25.132741228718345,\n            \"charges\": np.array([1.0, 1.0, -1.0, -1.0]),\n            \"positions\": np.array([\n                [0.1, 0.1, 0.1],\n                [0.9, 0.1, 0.1],\n                [0.1, 0.9, 0.1],\n                [0.9, 0.9, 0.1]\n            ])\n        },\n        # Case C\n        {\n            \"L\": 1.0,\n            \"alpha\": 7.0,\n            \"r_cut\": 0.50,\n            \"k_max\": 31.41592653589793,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[0.25, 0.25, 0.25], [0.75, 0.25, 0.25]])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        alpha = case[\"alpha\"]\n        r_cut = case[\"r_cut\"]\n        k_max = case[\"k_max\"]\n        charges = case[\"charges\"]\n        positions = case[\"positions\"]\n        \n        N = len(charges)\n        forces = np.zeros_like(positions)\n\n        # Real-space forces\n        for i in range(N):\n            for j in range(i + 1, N):\n                rij_vec = positions[i] - positions[j]\n                \n                # Minimum Image Convention\n                rij_vec = rij_vec - L * np.round(rij_vec / L)\n                \n                rij = np.linalg.norm(rij_vec)\n\n                # Check if within cutoff and non-zero distance\n                if 1e-9 < rij <= r_cut:\n                    q_i = charges[i]\n                    q_j = charges[j]\n                    \n                    term1 = erfc(alpha * rij) / rij**2\n                    term2 = (2.0 * alpha / np.sqrt(np.pi) / rij) * np.exp(-alpha**2 * rij**2)\n                    \n                    f_magnitude = q_i * q_j * (term1 + term2)\n                    f_vec = f_magnitude * (rij_vec / rij)\n                    \n                    forces[i] += f_vec\n                    forces[j] -= f_vec\n\n        # Reciprocal-space forces\n        n_max_int = int(np.floor(k_max * L / (2.0 * np.pi)))\n        \n        k_vecs = []\n        nx_vals = np.arange(-n_max_int, n_max_int + 1)\n        k_max_sq = k_max**2\n\n        for nx in nx_vals:\n            for ny in nx_vals:\n                for nz in nx_vals:\n                    if nx == 0 and ny == 0 and nz == 0:\n                        continue\n                    n_vec = np.array([nx, ny, nz])\n                    k_vec = (2.0 * np.pi / L) * n_vec\n                    k_sq = np.dot(k_vec, k_vec)\n                    if k_sq <= k_max_sq:\n                        k_vecs.append(k_vec)\n        \n        if not k_vecs:\n            # Handle case where no k-vectors are generated\n            case_results = [round(comp, 8) for comp in forces.flatten()]\n            all_results.append(case_results)\n            continue\n\n        k_vecs_arr = np.array(k_vecs)\n        k_sq_vals = np.sum(k_vecs_arr**2, axis=1)\n\n        # Vectorized calculation of cosine and sine sums\n        # k_dot_r has shape (num_k, N)\n        k_dot_r = np.dot(k_vecs_arr, positions.T)\n        \n        cos_k_dot_r = np.cos(k_dot_r)\n        sin_k_dot_r = np.sin(k_dot_r)\n        \n        # C_k and S_k sums over particles j, shape (num_k,)\n        C_k_vals = np.sum(charges[np.newaxis, :] * cos_k_dot_r, axis=1)\n        S_k_vals = np.sum(charges[np.newaxis, :] * sin_k_dot_r, axis=1)\n        \n        # Prefactor for force calculation for each k, shape (num_k,)\n        prefactor_k = (4.0 * np.pi / L**3) * np.exp(-k_sq_vals / (4.0 * alpha**2)) / k_sq_vals\n\n        for i in range(N):\n            q_i = charges[i]\n            \n            # Dot product of all k vectors with position r_i, shape (num_k,)\n            k_dot_ri = np.dot(k_vecs_arr, positions[i])\n            \n            sin_k_dot_ri = np.sin(k_dot_ri)\n            cos_k_dot_ri = np.cos(k_dot_ri)\n            \n            # The term in brackets in the force formula, shape (num_k,)\n            term_in_brackets = sin_k_dot_ri * C_k_vals - cos_k_dot_ri * S_k_vals\n            \n            # Combines scalar terms and vector k via broadcasting\n            # (num_k, 1) * (num_k, 3) -> (num_k, 3)\n            force_contrib_per_k = (prefactor_k * term_in_brackets)[:, np.newaxis] * k_vecs_arr\n            \n            # Sum over all k-vectors to get total reciprocal force on particle i\n            F_recip_i = q_i * np.sum(force_contrib_per_k, axis=0)\n            \n            forces[i] += F_recip_i\n\n        case_results = [round(comp, 8) for comp in forces.flatten()]\n        all_results.append(case_results)\n\n    # Format the final output string\n    results_str_parts = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2390985"}, {"introduction": "一个正确的周期性系统模拟，其物理结果不应依赖于坐标系的原点选择，也不应因粒子靠近模拟盒子的“边界”而产生人为的赝象。本练习设计了一系列巧妙的测试，旨在验证你的埃瓦尔德求和实现是否满足平移不变性这一基本物理要求 [@problem_id:2390997]。通过比较等效但位置不同的粒子构型所产生的力，你将学会如何系统地检验代码的正确性，确保模拟结果的物理可靠性。", "problem": "您将使用 Ewald 求和方法实现三维周期性静电计算，以评估位于立方模拟盒边缘附近点电荷所受的力，并验证结果没有边界效应。您必须从第一性原理出发，以库仑定律和周期性边界条件的定义为基础，推导出一个计算算法。该算法通过平滑屏蔽过程将相互作用分解为短程的实空间贡献和长程的倒易空间贡献。您必须假设采用导电（锡箔）边界条件。所有计算都将使用约化的无量纲单位，其中库仑前置因子为1，即 $1/(4\\pi\\epsilon_0) = 1$，并且不需要进行物理单位转换。没有需要报告的角度。所有数值答案必须以原始十进制数的形式打印，不带任何单位。\n\n起始原理和定义：\n- 系统是一个边长为 $L$ 的立方盒子，具有三维周期性边界条件（PBC）。对于位于位置 $\\mathbf{r}_i \\in [0,L)^3$ 的任何粒子和位于位置 $\\mathbf{r}_j \\in [0,L)^3$ 的任何不同粒子，其相互作用包括所有经 $\\mathbf{n}L$（其中 $\\mathbf{n} \\in \\mathbb{Z}^3$）位移的晶格镜像。\n- 点电荷的静电势遵循库仑定律，周期性系统中的总能量是条件收敛的，除非总电荷为零。您必须限制在净电荷为中性的构型，即 $\\sum_i q_i = 0$。\n- Ewald 方法引入了一个由参数 $\\alpha > 0$ 控制的高斯平滑屏蔽，将相互作用分解为一个对近邻镜像的快速衰减的实空间求和，以及一个对波矢 $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{m}$（其中 $\\mathbf{m} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$，省略 $\\mathbf{k} = \\mathbf{0}$）的互补的倒易空间求和。实空间求和在半径 $r_\\mathrm{cut} > 0$ 处截断，倒易空间求和通过将整数矢量分量限制在 $|m_x|,|m_y|,|m_z| \\le k_\\mathrm{max}$ 内进行截断。\n\n您的任务：\n- 根据上述原理，推导出一个显式且数值稳定的算法，使用 Ewald 求和计算每个粒子 $i$ 所受的静电力 $\\mathbf{F}_i$，包括实空间和倒易空间的贡献以及自相互作用校正。使用导电边界条件，因此不包含额外的表面项。该算法必须精确地遵守周期性边界条件。\n- 在一个程序中实现该算法，以评估以下测试套件。所有位置都在区间 $[0,L)$ 中给出，所有量都是无量纲的。所有测试均使用相同的立方盒子边长 $L = 10.0$。在需要时使用互补误差函数。设 $\\pi$ 为通常的数学常数。\n\n用于基准评估的全局 Ewald 参数：\n- 对于基准计算，使用 $\\alpha = 0.35$，$r_\\mathrm{cut} = 4.5$ 和 $k_\\mathrm{max} = 6$。\n- 对于备用参数测试，使用 $\\alpha' = 0.28$，$r_\\mathrm{cut}' = 4.5$ 和 $k_\\mathrm{max}' = 8$。\n\n测试系统：\n1. 系统 $\\mathcal{S}_\\mathrm{edge}$ （两个相反电荷位于跨越边界的边缘附近）：\n   - 电荷：$q_1 = +1.0$，$q_2 = -1.0$。\n   - 位置：$\\mathbf{r}_1 = (9.8, 5.0, 5.0)$，$\\mathbf{r}_2 = (0.2, 5.0, 5.0)$。\n2. 系统 $\\mathcal{S}_\\mathrm{center}$ （电荷相同，最小镜像间距相同，位于远离边缘的中心）：\n   - 电荷：$q_1 = +1.0$，$q_2 = -1.0$。\n   - 位置：$\\mathbf{r}_1 = (0.2, 5.0, 5.0)$，$\\mathbf{r}_2 = (0.6, 5.0, 5.0)$。\n3. 用于不变性测试的平移向量：$\\mathbf{t} = (3.7, 0.0, -1.1)$，通过 $\\mathbf{r}_i \\mapsto (\\mathbf{r}_i + \\mathbf{t}) \\bmod L$ 按分量应用。\n\n待计算的量：\n- 设 $\\mathbf{F}^{(\\mathrm{edge})}$ 表示使用 $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$ 计算的系统 $\\mathcal{S}_\\mathrm{edge}$ 的力。\n- 设 $\\mathbf{F}^{(\\mathrm{center})}$ 表示使用 $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$ 计算的系统 $\\mathcal{S}_\\mathrm{center}$ 的力。\n- 设 $\\mathbf{F}^{(\\mathrm{trans})}$ 表示在应用平移 $\\mathbf{t}$ 并将位置包裹回盒子后，使用 $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$ 计算的系统 $\\mathcal{S}_\\mathrm{edge}$ 的力。\n- 设 $\\mathbf{F}^{(\\mathrm{alt})}$ 表示使用备用参数 $(\\alpha', r_\\mathrm{cut}', k_\\mathrm{max}')$ 计算的系统 $\\mathcal{S}_\\mathrm{edge}$ 的力。\n\n根据这些值，计算以下四个标量诊断值：\n- $D_1$：$\\mathbf{F}^{(\\mathrm{edge})}$ 和 $\\mathbf{F}^{(\\mathrm{center})}$ 之间的最大分量绝对差值，即 $D_1 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{center})}_{i,a}\\right|$。\n- $D_2$：系统 $\\mathcal{S}_\\mathrm{edge}$ 中净力向量的欧几里得范数，对两个粒子求和，即 $D_2 = \\left\\|\\sum_{i=1}^2 \\mathbf{F}^{(\\mathrm{edge})}_i \\right\\|_2$。\n- $D_3$：$\\mathbf{F}^{(\\mathrm{edge})}$ 和 $\\mathbf{F}^{(\\mathrm{trans})}$ 之间的最大分量绝对差值，即 $D_3 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{trans})}_{i,a}\\right|$。\n- $D_4$：使用基准参数和备用参数计算的 $\\mathbf{F}^{(\\mathrm{edge})}$ 之间的最大分量绝对差值，即 $D_4 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{alt})}_{i,a}\\right|$。\n\n结果解读指南：\n- 较小的 $D_1$ 值证实，将电荷放置在边界附近与等效的中心构型产生相同的力，表明没有边界效应。\n- 较小的 $D_2$ 值证实，在导电边界条件下，中性系统的总力为零，这符合平移不变性的要求。\n- 较小的 $D_3$ 值证实了力在全局平移和周期性包裹下的不变性。\n- 较小的 $D_4$ 值证实，在数值截断误差范围内，物理结果与任意选择的分解参数无关。\n\n最终输出格式：\n- 您的程序必须打印单行，其中包含四个结果，格式为用方括号括起来的逗号分隔列表，顺序为 $[D_1, D_2, D_3, D_4]$。例如，一个有效的输出格式是 $[0.0001,2.3e-06,0.0,1.2e-05]$。\n\n约束和说明：\n- 您必须直接实现 Ewald 力的计算。不要调用任何黑箱静电学求解器。您可以使用标准数值库来计算指数函数和互补误差函数等基本函数。\n- 仅使用电中性系统；所有提供的测试均满足 $\\sum_i q_i = 0$。\n- 使用指定的截断参数 $(r_\\mathrm{cut}, k_\\mathrm{max})$ 确保数值稳定性和合理的收敛性。", "solution": "我们以库仑定律和周期性边界条件的定义为基础进行计算，然后推导 Ewald 分解，以获得力的数值收敛算法。推导中的所有符号均指代 $1/(4\\pi\\epsilon_0) = 1$ 的约化无量纲量。\n\n基本原理：\n- 库仑定律给出了电荷 $q_i$ 和 $q_j$ 之间的对势为 $\\phi(\\mathbf{r}) = q_j / \\|\\mathbf{r}\\|$，其中 $\\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$。\n- 在边长为 $L$ 的周期性立方盒子中，相互作用是对所有晶格镜像的求和，这只是条件收敛的。Ewald 的方法通过引入一个由 $\\alpha > 0$ 控制的高斯屏蔽密度来对其进行正则化，该密度将相互作用分解为快速收敛的实空间级数和倒易空间级数。\n\nEwald 分解：\n我们加上并减去一个宽度由 $\\alpha > 0$ 控制的中和高斯分布。一个被屏蔽点电荷的势分解为一个短程贡献（其衰减类似于互补误差函数）和一个长程贡献（可通过傅里叶分量表示）。对于中性系统，在导电边界条件下，省略 $\\mathbf{k} = \\mathbf{0}$ 分量。\n\n力的表达式概念推导：\n- 实空间。定义 $\\mathbf{R} = \\mathbf{r}_i - \\mathbf{r}_j + \\mathbf{n}L$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$，且 $R = \\|\\mathbf{R}\\|$。在屏蔽表示中，对势为 $q_j \\operatorname{erfc}(\\alpha R)/R$。粒子 $i$ 上的力为 $\\mathbf{F}_{ij}^{(\\mathrm{real})} = -q_i \\nabla_i \\left[q_j \\operatorname{erfc}(\\alpha R)/R\\right]$。使用乘法法则和 $\\frac{d}{dR}\\operatorname{erfc}(\\alpha R) = -\\frac{2\\alpha}{\\sqrt{\\pi}} e^{-\\alpha^2 R^2}$，以及恒等式 $\\nabla_i R = \\mathbf{R}/R$，我们得到\n$$\n\\mathbf{F}_{ij}^{(\\mathrm{real})} = q_i q_j \\left( \\frac{\\operatorname{erfc}(\\alpha R)}{R^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 R^2}}{R^2} \\right) \\mathbf{R}.\n$$\n为了提高数值效率，此和在 $R \\le r_\\mathrm{cut}$ 处截断，因为被忽略的尾部衰减非常快。\n\n- 倒易空间。设 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$，其中整数三元组 $\\mathbf{m} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$。在 $\\mathbf{r}_i$ 处的倒易空间势为\n$$\n\\phi^{(\\mathrm{rec})}(\\mathbf{r}_i) = \\frac{1}{V}\\sum_{\\mathbf{k}\\ne\\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} \\sum_j q_j e^{i \\mathbf{k}\\cdot (\\mathbf{r}_i - \\mathbf{r}_j)},\n$$\n其中 $V = L^3$ 且 $k = \\|\\mathbf{k}\\|$。力为 $\\mathbf{F}_i^{(\\mathrm{rec})} = -q_i \\nabla_i \\phi^{(\\mathrm{rec})}(\\mathbf{r}_i)$。求导会从 $e^{i \\mathbf{k}\\cdot \\mathbf{r}_i}$ 产生一个因子 $i\\mathbf{k}$，并使用正弦函数得到一个明显的实数形式：\n$$\n\\mathbf{F}_i^{(\\mathrm{rec})} = \\frac{4\\pi}{V}\\, q_i \\sum_{\\mathbf{k}\\ne\\mathbf{0}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\left[\\sum_j q_j \\sin\\left(\\mathbf{k}\\cdot (\\mathbf{r}_i - \\mathbf{r}_j)\\right)\\right] \\mathbf{k}.\n$$\n为了高效计算，我们使用恒等式 $\\sum_j q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i - \\mathbf{r}_j)) = \\sin(\\mathbf{k}\\cdot \\mathbf{r}_i)\\sum_j q_j \\cos(\\mathbf{k}\\cdot \\mathbf{r}_j) - \\cos(\\mathbf{k}\\cdot \\mathbf{r}_i)\\sum_j q_j \\sin(\\mathbf{k}\\cdot \\mathbf{r}_j)$，所以我们只需要每个 $\\mathbf{k}$ 的全局结构因子。\n\n- 自相互作用项。Ewald 能量中的自相互作用校正为 $- \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_i q_i^2$，其相对于粒子位置的梯度为零。因此，自相互作用项对力没有贡献，在计算力时可以省略。\n\n导电边界条件：\n- 对于导电（锡箔）边界，$\\mathbf{k} = \\mathbf{0}$ 项被舍弃，并且没有表面（偶极）校正。系统必须是电中性的，即 $\\sum_i q_i = 0$，以避免发散。\n\n算法设计：\n1. 输入粒子位置 $\\{\\mathbf{r}_i\\}$、电荷 $\\{q_i\\}$、盒子长度 $L$ 以及 Ewald 参数 $\\alpha$、$r_\\mathrm{cut}$、$k_\\mathrm{max}$。\n2. 实空间力：\n   - 确定整数边界 $n_\\mathrm{max} = \\lceil r_\\mathrm{cut}/L \\rceil$；遍历 $\\mathbf{n} \\in \\{-n_\\mathrm{max},\\ldots,n_\\mathrm{max}\\}^3$。\n   - 对于每个无序对 $(i,j)$，其中 $i<j$，计算 $\\mathbf{R} = \\mathbf{r}_i - \\mathbf{r}_j + \\mathbf{n}L$、其范数 $R$，如果 $R > 0$ 且 $R \\le r_\\mathrm{cut}$，则使用以下公式累加对称的对力：\n   $$\n   f(R) = \\frac{\\operatorname{erfc}(\\alpha R)}{R^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 R^2}}{R^2},\\qquad \\Delta\\mathbf{F} = q_i q_j f(R) \\mathbf{R}.\n   $$\n   - 将 $+\\Delta\\mathbf{F}$ 加到 $\\mathbf{F}_i$ 上，将 $-\\Delta\\mathbf{F}$ 加到 $\\mathbf{F}_j$ 上。\n3. 倒易空间力：\n   - 生成所有整数三元组 $\\mathbf{m}$，其中 $-k_\\mathrm{max} \\le m_x,m_y,m_z \\le k_\\mathrm{max}$，不包括 $\\mathbf{m}=\\mathbf{0}$。对每个 $\\mathbf{m}$，构建 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$、$k^2 = \\mathbf{k}\\cdot \\mathbf{k}$ 和系数\n   $$\n   c(\\mathbf{k}) = \\frac{4\\pi}{V}\\,\\frac{e^{-k^2/(4\\alpha^2)}}{k^2}.\n   $$\n   - 计算结构因子 $C(\\mathbf{k}) = \\sum_j q_j \\cos(\\mathbf{k}\\cdot \\mathbf{r}_j)$ 和 $S(\\mathbf{k}) = \\sum_j q_j \\sin(\\mathbf{k}\\cdot \\mathbf{r}_j)$。\n   - 对每个粒子 $i$，计算 $s_i = \\sin(\\mathbf{k}\\cdot \\mathbf{r}_i)$ 和 $c_i = \\cos(\\mathbf{k}\\cdot \\mathbf{r}_i)$，然后累加\n   $$\n   \\Delta \\mathbf{F}_i = q_i\\, c(\\mathbf{k})\\, \\left( s_i\\, C(\\mathbf{k}) - c_i\\, S(\\mathbf{k}) \\right)\\, \\mathbf{k}.\n   $$\n4. 总力为 $\\mathbf{F}_i = \\mathbf{F}_i^{(\\mathrm{real})} + \\mathbf{F}_i^{(\\mathrm{rec})}$，对每个 $i$ 均如此。\n5. 验证诊断：\n   - 计算 $D_1$，即在基准参数下，系统 $\\mathcal{S}_\\mathrm{edge}$ 和 $\\mathcal{S}_\\mathrm{center}$ 的力的最大绝对分量差。\n   - 计算 $D_2$，即在基准参数下，系统 $\\mathcal{S}_\\mathrm{edge}$ 的净力的欧几里得范数。\n   - 计算 $D_3$，即在基准参数下，系统 $\\mathcal{S}_\\mathrm{edge}$ 与其全局平移并包裹后的版本的力的最大绝对分量差。\n   - 计算 $D_4$，即在基准参数和备用参数下，系统 $\\mathcal{S}_\\mathrm{edge}$ 的力的最大绝对分量差。\n\n数值考虑：\n- 对于 $L=10.0$ 的这个小系统，选择 $\\alpha = 0.35$、 $r_\\mathrm{cut} = 4.5$ 和 $k_\\mathrm{max} = 6$ 在实空间和倒易空间截断误差之间取得了合理的平衡。备用参数 $\\alpha' = 0.28$、$r_\\mathrm{cut}' = 4.5$、$k_\\mathrm{max}' = 8$ 将更多的工作转移到倒易空间，计算出的力应该非常接近，从而验证了参数的鲁棒性。\n- 所有测试系统的净电荷均为零，满足 $\\sum_i q_i = 0$ 的要求，这是 Ewald 求和在导电边界条件下收敛所必需的。\n- 不变性预期：将所有位置平移任意向量 $\\mathbf{t}$ 并对 $L$ 取模，不会改变 $\\mathbf{R}$ 集合的距离或相位因子集合 $e^{i\\mathbf{k}\\cdot \\mathbf{r}}$（除了一个公共相位，它会在力的表达式中抵消），因此力是不变的。同样，将一个在周期性下等效的构型居中，应产生无法区分的力。因此 $D_1$、$D_2$ 和 $D_3$ 应该很小（在截断误差内接近机器精度），$D_4$ 也应该很小，以确认参数的鲁棒性。\n\n程序实现了上述算法，构建了指定的测试用例，通过 Ewald 求和计算 $\\mathbf{F}$，评估 $D_1$、$D_2$、$D_3$ 和 $D_4$，并将其作为单行列表 $[D_1, D_2, D_3, D_4]$ 打印出来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef ewald_forces(positions, charges, L, alpha, rcut, kmax):\n    \"\"\"\n    Compute Ewald forces for a 3D periodic cubic box with conducting boundary conditions.\n    positions: (N,3) array in [0,L)\n    charges: (N,) array, must sum to zero\n    L: box length\n    alpha: Ewald splitting parameter\n    rcut: real-space cutoff\n    kmax: maximum integer index for reciprocal vectors\n    Returns: (N,3) array of forces\n    \"\"\"\n    positions = np.asarray(positions, dtype=float)\n    charges = np.asarray(charges, dtype=float)\n    N = positions.shape[0]\n    assert positions.shape == (N, 3)\n    assert charges.shape == (N,)\n    # Neutrality check\n    if abs(np.sum(charges)) > 1e-12:\n        raise ValueError(\"System is not neutral; Ewald summation diverges.\")\n    forces = np.zeros_like(positions)\n    V = L**3\n    pi = np.pi\n    sqrt_pi = np.sqrt(pi)\n\n    # Real-space sum\n    nmax = int(np.ceil(rcut / L))\n    # Precompute image shifts\n    shifts = []\n    for nx in range(-nmax, nmax + 1):\n        for ny in range(-nmax, nmax + 1):\n            for nz in range(-nmax, nmax + 1):\n                shifts.append(np.array([nx, ny, nz], dtype=int))\n    shifts = np.array(shifts, dtype=int)\n\n    for i in range(N - 1):\n        ri = positions[i]\n        qi = charges[i]\n        for j in range(i + 1, N):\n            rj = positions[j]\n            qj = charges[j]\n            qiqj = qi * qj\n            # Loop over lattice vectors within cutoff\n            for nvec in shifts:\n                # Displacement including image\n                Rvec = ri - rj + L * nvec\n                R2 = np.dot(Rvec, Rvec)\n                if R2 == 0.0:\n                    continue\n                R = np.sqrt(R2)\n                if R <= rcut:\n                    aR = alpha * R\n                    erfc_term = erfc(aR)\n                    exp_term = np.exp(-(aR * aR))\n                    # Force scalar factor\n                    f = erfc_term / (R2 * R) + (2.0 * alpha / sqrt_pi) * exp_term / R2\n                    fij = qiqj * f * Rvec\n                    forces[i] += fij\n                    forces[j] -= fij\n\n    # Reciprocal-space sum\n    # Generate k-vectors\n    ms = np.arange(-kmax, kmax + 1, dtype=int)\n    k_list = []\n    for mx in ms:\n        for my in ms:\n            for mz in ms:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue\n                m = np.array([mx, my, mz], dtype=float)\n                kvec = (2.0 * np.pi / L) * m\n                ksq = np.dot(kvec, kvec)\n                if ksq == 0.0:\n                    continue\n                k_list.append((kvec, ksq))\n    # Structure factors and force accumulation\n    # Precompute dot products k·r for all k and all particles can be memory heavy; loop over k\n    for kvec, ksq in k_list:\n        # Coefficient c(k)\n        ck = (4.0 * np.pi / V) * np.exp(-ksq / (4.0 * alpha * alpha)) / ksq\n        # Structure factors\n        kr = positions @ kvec  # shape (N,)\n        cos_kr = np.cos(kr)\n        sin_kr = np.sin(kr)\n        Ck = np.sum(charges * cos_kr)\n        Sk = np.sum(charges * sin_kr)\n        # Per-particle contributions\n        s_i = sin_kr\n        c_i = cos_kr\n        # term = (s_i * Ck - c_i * Sk)\n        term = (s_i * Ck - c_i * Sk) * charges * ck  # shape (N,)\n        # Add to forces: term[:, None] * kvec\n        forces += term[:, None] * kvec\n\n    return forces\n\ndef translate_and_wrap(positions, tvec, L):\n    \"\"\"Translate positions by tvec and wrap back into [0,L).\"\"\"\n    pos_new = positions + np.asarray(tvec, dtype=float)\n    pos_new = pos_new % L\n    return pos_new\n\ndef max_abs_componentwise_diff(A, B):\n    \"\"\"Max absolute component-wise difference between two (N,3) arrays.\"\"\"\n    return float(np.max(np.abs(A - B)))\n\ndef solve():\n    # Define global parameters\n    L = 10.0\n    alpha = 0.35\n    rcut = 4.5\n    kmax = 6\n\n    alpha_alt = 0.28\n    rcut_alt = 4.5\n    kmax_alt = 8\n\n    # Define systems\n    charges = np.array([+1.0, -1.0], dtype=float)\n\n    # Edge configuration (across boundary)\n    r_edge = np.array([\n        [9.8, 5.0, 5.0],\n        [0.2, 5.0, 5.0],\n    ], dtype=float)\n\n    # Centered configuration with same minimum-image separation (0.4 along +x)\n    r_center = np.array([\n        [0.2, 5.0, 5.0],\n        [0.6, 5.0, 5.0],\n    ], dtype=float)\n\n    # Translation vector\n    tvec = np.array([3.7, 0.0, -1.1], dtype=float)\n\n    # Compute forces with baseline parameters\n    F_edge = ewald_forces(r_edge, charges, L, alpha, rcut, kmax)\n    F_center = ewald_forces(r_center, charges, L, alpha, rcut, kmax)\n\n    # D1: max componentwise difference between edge and center\n    D1 = max_abs_componentwise_diff(F_edge, F_center)\n\n    # D2: norm of total force for edge system\n    total_force_edge = np.sum(F_edge, axis=0)\n    D2 = float(np.linalg.norm(total_force_edge))\n\n    # D3: translation invariance\n    r_edge_trans = translate_and_wrap(r_edge, tvec, L)\n    F_trans = ewald_forces(r_edge_trans, charges, L, alpha, rcut, kmax)\n    D3 = max_abs_componentwise_diff(F_edge, F_trans)\n\n    # D4: parameter invariance (alternate parameters)\n    F_alt = ewald_forces(r_edge, charges, L, alpha_alt, rcut_alt, kmax_alt)\n    D4 = max_abs_componentwise_diff(F_edge, F_alt)\n\n    results = [D1, D2, D3, D4]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2390997"}, {"introduction": "埃瓦尔德求和法的效率和精度高度依赖于所选的参数，特别是实空间截断半径 $r_{\\text{cut}}$ 和倒易空间截断半径 $k_{\\text{cut}}$。理想的参数选择可以在保证精度的前提下最大限度地减少计算量。本练习将通过系统地改变这些截断参数，并与一个高度收敛的“精确”结果进行比较，来量化截断误差对力计算的影响 [@problem_id:2390969]。完成此练习后，你将对如何选择合适的埃瓦尔德参数以在计算成本和模拟精度之间取得最佳平衡有更深刻的认识。", "problem": "实现一个完整的程序，量化在三维周期性、电中性体系中，埃瓦尔德求和力计算中的截断误差与实空间截断半径 $r_{cut}$ 和倒易空间截断 $k_{cut}$ 的函数关系。请在约化无量纲单位下进行计算，其中立方模拟盒子的边长为 $L$，元电荷设为1，库仑前因子 $1/(4\\pi \\varepsilon_0)$ 也设为1。因此，所有量均为无量纲。目标是为几个指定的截断选择，生成一个数值稳定且可复现的均方根相对力误差估计。\n\n请从基本静电学和周期性边界条件出发：在一个边长为 $L$ 的立方区域内，点电荷 $\\{q_i\\}$ 位于位置 $\\{\\mathbf{r}_i\\}$，并具有完全周期性边界条件。粒子 $i$ 上精确的静电力是通过求解具有三重周期格林函数的泊松方程得到的，这等效于对所有布拉菲晶格镜像的库仑相互作用进行求和。为了使长程求和绝对收敛且在实践中可计算，请使用经典的埃瓦尔德分解方法，即在每个粒子周围加上和减去一个宽度参数为 $\\alpha$ 的球对称高斯屏蔽电荷密度。这将力分解为一个短程的实空间部分（从直接空间中的屏蔽势获得）和一个平滑的长程倒易空间部分（从互补屏蔽的傅里叶变换获得）。自相互作用修正会移除每个电荷与其自身屏蔽云之间的相互作用；它对力没有贡献。\n\n您的任务是：\n- 从第一性原理出发，推导在埃瓦尔德分解下，由埃瓦尔德分裂参数 $\\alpha$ 参数化的对力的实空间和倒易空间表达式，并以数值稳健的方式实现它们。\n- 通过枚举整数分量的正格子矢量 $\\mathbf{n}=(n_x,n_y,n_z)$ 来实现实空间力求和，使得镜像位移 $\\mathbf{r}_{ij} + L\\mathbf{n}$ 的大小严格小于 $r_{cut}$。这里 $\\mathbf{r}_{ij}=\\mathbf{r}_i-\\mathbf{r}_j$，中心原胞对应于 $\\mathbf{n}=\\mathbf{0}$。排除 $\\mathbf{n}=\\mathbf{0}$ 时的自作用项 $i=j$。\n- 通过枚举非零倒易格矢 $\\mathbf{k}=\\frac{2\\pi}{L}\\mathbf{m}$（其中 $\\mathbf{m}=(m_x,m_y,m_z)$ 是整数三元组）且满足 $\\lVert \\mathbf{k}\\rVert < k_{cut}$，并通过累加电荷分布的平滑结构因子的贡献来实现倒易空间力求和。使用导电边界条件（无穷远处净电场为零），并假设整体电中性以避免任何 $\\mathbf{k}=\\mathbf{0}$ 项。\n- 对于每组参数，使用相同的 $\\alpha$ 但采用较大的截断值 $r_{cut}^{ref}$ 和 $k_{cut}^{ref}$ 来计算一个高度收敛的“参考”力，然后用指定的 $(r_{cut},k_{cut})$ 计算截断力。使用这些来评估所有粒子上的均方根相对力误差：\n$$\n\\mathrm{RMSRE}=\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\frac{\\lVert \\mathbf{F}_i^{(trunc)}-\\mathbf{F}_i^{(ref)}\\rVert}{\\max\\{\\lVert \\mathbf{F}_i^{(ref)}\\rVert,\\epsilon\\}}\\right)^2}\\,,\n$$\n其中 $\\epsilon$ 是一个小的正则化子，以避免除以零。将此误差以无量纲浮点数的形式报告。\n\n所有计算中使用的系统规格：\n- 粒子数：$N=4$。\n- 盒子长度：$L=1.0$。\n- 粒子电荷：$(q_1,q_2,q_3,q_4)=(+1,-1,+1,-1)$。\n- 粒子位置（在主晶胞中，隐含周期性镜像）：$\\mathbf{r}_1=(0.10,0.10,0.10)$, $\\mathbf{r}_2=(0.40,0.20,0.70)$, $\\mathbf{r}_3=(0.80,0.90,0.30)$, $\\mathbf{r}_4=(0.65,0.25,0.95)$。\n- 对于每个 $\\alpha$ 的参考计算，使用 $r_{cut}^{ref}=3.0$ 和 $k_{cut}^{ref}=50.0$。\n- 在误差定义中使用正则化子 $\\epsilon=10^{-12}$。\n\n实现以下埃瓦尔德参数集的测试套件 $(\\alpha,r_{cut},k_{cut})$：\n- 情况 A: $(\\alpha,r_{cut},k_{cut})=(5.0,1.5,20.0)$。\n- 情况 B: $(\\alpha,r_{cut},k_{cut})=(5.0,0.5,20.0)$。\n- 情况 C: $(\\alpha,r_{cut},k_{cut})=(5.0,1.5,6.0)$。\n- 情况 D: $(\\alpha,r_{cut},k_{cut})=(5.0,0.0,20.0)$。\n- 情况 E: $(\\alpha,r_{cut},k_{cut})=(5.0,2.5,0.0)$。\n- 情况 F: $(\\alpha,r_{cut},k_{cut})=(2.5,1.5,20.0)$。\n\n您的程序必须：\n- 按照描述实现埃瓦尔德力计算，仅使用提供的系统和参数集。\n- 对于每种情况，使用相应的参考截断计算均方根相对力误差。\n- 生成单行输出，包含从 A 到 F 的六个结果，形式为逗号分隔的列表，并用方括号括起来。每个浮点数必须四舍五入到小数点后$6$位，并以科学记数法表示（例如，$\"[1.234567e-03,2.000000e+00,3.140000e+00]\"$)。\n\n所有计算均在约化无量纲单位下进行。角度（在内部通过点积产生）以弧度为单位，但您无需报告任何角度。最终程序必须完全自包含，不需要任何输入。最终输出是指定格式的纯数字，不带单位。请确保数值稳定性，并通过遵守上述截断规则来避免在实空间和倒易空间求和中出现冗余的双重计数。", "solution": "所提出的问题是计算物理学中一个标准的、定义明确的练习。它在科学上是合理的、自包含的，并且为获得唯一的数值解所需的所有参数都已提供。系统被指定为电中性（$\\sum_i q_i = +1 -1 +1 -1 = 0$），这与在倒易空间求和中省略 $\\mathbf{k}=\\mathbf{0}$ 项的指令是一致的。因此，该问题是有效的。我们将着手进行推导和实现。\n\n目标是计算一个边长为 $L$ 的立方周期盒子内一组位置为 $\\{\\mathbf{r}_i\\}$ 的 $N$ 个点电荷 $\\{q_i\\}$ 上的静电力。粒子 $i$ 上的静电力由总势能 $U$ 导出，即 $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U$。周期性电荷晶格的能量由以下条件收敛级数给出：\n$$\nU = \\frac{1}{2} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\sideset{}{'}{\\sum}_{i,j=1}^{N} \\frac{q_i q_j}{|\\mathbf{r}_{ij} + L\\mathbf{n}|}\n$$\n其中 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$，$\\mathbf{n}$ 是表示周期性镜像的整数矢量。求和上的撇号表示对于主晶胞（$\\mathbf{n}=\\mathbf{0}$），排除 $i=j$ 的项。库仑相互作用 $1/r$ 的长程性质导致这个级数的收敛缓慢且有条件。\n\n埃瓦尔德求和方法通过将相互作用分裂为两个快速收敛的部分来解决这个问题。这是通过在每个点电荷上加上和减去一个屏蔽电荷分布（通常是高斯分布）来实现的。库仑势使用涉及互补误差函数 $\\mathrm{erfc}(x)$ 和误差函数 $\\mathrm{erf}(x)$ 的恒等式进行分裂：\n$$\n\\frac{1}{r} = \\underbrace{\\frac{\\mathrm{erfc}(\\alpha r)}{r}}_{\\text{短程}} + \\underbrace{\\frac{\\mathrm{erf}(\\alpha r)}{r}}_{\\text{长程}}\n$$\n参数 $\\alpha$ 控制高斯函数的宽度和分裂后势的作用范围。粒子 $i$ 上的力因此分解为实空间贡献、倒易空间贡献和自相互作用修正：\n$$\n\\mathbf{F}_i = \\mathbf{F}_i^{\\text{real}} + \\mathbf{F}_i^{\\text{recip}} + \\mathbf{F}_i^{\\text{self}}\n$$\n\n**1. 实空间力 ($\\mathbf{F}_i^{\\text{real}}$)**\n\n实空间贡献源于通过短程势的直接、对相互作用。势能项为：\n$$\nU_{\\text{real}} = \\frac{1}{2} \\sum_{\\mathbf{n}} \\sideset{}{'}{\\sum}_{i,j} q_i q_j \\frac{\\mathrm{erfc}(\\alpha |\\mathbf{r}_{ij,n}|)}{|\\mathbf{r}_{ij,n}|}\n$$\n其中 $\\mathbf{r}_{ij,n} = \\mathbf{r}_{ij} + L\\mathbf{n}$。粒子 $i$ 由于与粒子 $j$（及其所有镜像）的相互作用而受到的力，是通过取负梯度得到的。令 $\\mathbf{r} = \\mathbf{r}_{ij,n}$。对力为 $\\mathbf{F}_{ij}(\\mathbf{r}) = -q_i q_j \\nabla \\frac{\\mathrm{erfc}(\\alpha r)}{r}$。使用链式法则 $\\nabla f(r) = \\frac{df}{dr} \\frac{\\mathbf{r}}{r}$ 和导数 $\\frac{d}{dr}\\left(\\frac{\\mathrm{erfc}(\\alpha r)}{r}\\right) = -\\frac{\\mathrm{erfc}(\\alpha r)}{r^2} - \\frac{2\\alpha}{\\sqrt{\\pi}}e^{-\\alpha^2 r^2}\\frac{1}{r}$，我们得到：\n$$\n\\mathbf{F}_{ij}(\\mathbf{r}) = q_i q_j \\left[ \\frac{\\mathrm{erfc}(\\alpha r)}{r^3} + \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r^2} \\right] \\mathbf{r}\n$$\n粒子 $i$ 上的总实空间力是在截断距离 $r_{\\text{cut}}$ 内对所有其他粒子 $j$ 和所有周期性晶格镜像 $\\mathbf{n}$ 的求和：\n$$\n\\mathbf{F}_i^{\\text{real}} = \\sum_{j=1}^{N} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} ' q_i q_j \\left[ \\frac{\\mathrm{erfc}(\\alpha |\\mathbf{r}_{ij,n}|)}{|\\mathbf{r}_{ij,n}|^3} + \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 |\\mathbf{r}_{ij,n}|^2}}{|\\mathbf{r}_{ij,n}|^2} \\right] \\mathbf{r}_{ij,n}\n$$\n求和仅限于所有满足 $0 < |\\mathbf{r}_{ij,n}| < r_{\\text{cut}}$ 的对 $(j, \\mathbf{n})$。撇号表示如果 $\\mathbf{n}=\\mathbf{0}$，则 $j \\neq i$。\n\n**2. 倒易空间力 ($\\mathbf{F}_i^{\\text{recip}}$)**\n\n势的长程部分是平滑的，可以使用傅里叶级数在倒易空间中高效计算。势能贡献为：\n$$\nU_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} |S(\\mathbf{k})|^2\n$$\n其中 $V=L^3$ 是盒子体积，$\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ 是对应整数矢量 $\\mathbf{m}$ 的倒易格矢，而 $S(\\mathbf{k}) = \\sum_j q_j e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}$ 是结构因子。对于电中性体系，$\\mathbf{k}=\\mathbf{0}$ 项为零。粒子 $i$ 上的力是 $\\mathbf{F}_i^{\\text{recip}} = -\\nabla_{\\mathbf{r}_i} U_{\\text{recip}}$。对 $\\mathbf{r}_i$ 取梯度得到：\n$$\n\\mathbf{F}_i^{\\text{recip}} = -\\frac{1}{2V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} \\nabla_{\\mathbf{r}_i}|S(\\mathbf{k})|^2\n$$\n结构因子平方的梯度是 $\\nabla_{\\mathbf{r}_i}|S(\\mathbf{k})|^2 = -2 q_i \\mathbf{k} \\sum_j q_j \\sin(\\mathbf{k} \\cdot (\\mathbf{r}_i - \\mathbf{r}_j))$。这导出了倒易空间力的最终表达式：\n$$\n\\mathbf{F}_i^{\\text{recip}} = \\frac{4\\pi q_i}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}, \\|\\mathbf{k}\\| < k_{\\text{cut}}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\left[ \\sum_{j=1}^{N} q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{ij}) \\right] \\mathbf{k}\n$$\n为了提高计算效率，内层求和可以使用 $\\sin(A-B) = \\sin A \\cos B - \\cos A \\sin B$ 展开：\n$$\n\\sum_{j=1}^{N} q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{ij}) = \\sin(\\mathbf{k} \\cdot \\mathbf{r}_i) \\left( \\sum_{j=1}^{N} q_j \\cos(\\mathbf{k} \\cdot \\mathbf{r}_j) \\right) - \\cos(\\mathbf{k} \\cdot \\mathbf{r}_i) \\left( \\sum_{j=1}^{N} q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_j) \\right)\n$$\n这允许预先计算对 $j$ 的求和，从而降低计算复杂度。\n\n**3. 自相互作用修正 ($\\mathbf{F}_i^{\\text{self}}$)**\n\n埃瓦尔德分裂引入了每个电荷与其自身屏蔽高斯函数之间的相互作用。这个非物理的能量必须被减去。自相互作用能为 $U_{\\text{self}} = -\\frac{\\alpha}{\\sqrt{\\pi}} \\sum_i q_i^2$。由于此项与粒子位置无关，其梯度为零，因此力的贡献也为零：\n$$\n\\mathbf{F}_i^{\\text{self}} = -\\nabla_{\\mathbf{r}_i} U_{\\text{self}} = \\mathbf{0}\n$$\n\n**4. 误差量化**\n\n该算法涉及为每个粒子计算总力 $\\mathbf{F}_i = \\mathbf{F}_i^{\\text{real}} + \\mathbf{F}_i^{\\text{recip}}$，首先是对于一组给定的截断参数 $(r_{\\text{cut}}, k_{\\text{cut}})$ 得到 $\\mathbf{F}^{(trunc)}$，然后是对于一组高度收敛的参考截断参数 $(r_{\\text{cut}}^{\\text{ref}}, k_{\\text{cut}}^{\\text{ref}})$ 得到 $\\mathbf{F}^{(ref)}$。然后按如下方式计算均方根相对力误差（RMSRE）：\n$$\n\\mathrm{RMSRE}=\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\frac{\\lVert \\mathbf{F}_i^{(trunc)}-\\mathbf{F}_i^{(ref)}\\rVert}{\\max\\{\\lVert \\mathbf{F}_i^{(ref)}\\rVert,\\epsilon\\}}\\right)^2}\n$$\n该量值提供了一个因实空间和倒易空间求和截断而损失的精度的度量。实现将遵循这些推导出的公式来评估指定测试用例的RMSRE。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the Ewald summation error analysis.\n    It solves the problem as stated, computing the RMS relative force error for several\n    parameter sets and printing the results in the specified format.\n    \"\"\"\n    # System specification\n    N = 4\n    L = 1.0\n    charges = np.array([+1.0, -1.0, +1.0, -1.0])\n    positions = np.array([\n        [0.10, 0.10, 0.10],\n        [0.40, 0.20, 0.70],\n        [0.80, 0.90, 0.30],\n        [0.65, 0.25, 0.95]\n    ])\n    epsilon_reg = 1e-12\n\n    # Test cases: (alpha, r_cut, k_cut)\n    test_cases = [\n        (5.0, 1.5, 20.0),  # Case A\n        (5.0, 0.5, 20.0),  # Case B\n        (5.0, 1.5, 6.0),   # Case C\n        (5.0, 0.0, 20.0),  # Case D\n        (5.0, 2.5, 0.0),   # Case E\n        (2.5, 1.5, 20.0),  # Case F\n    ]\n\n    # Reference calculation parameters\n    r_cut_ref = 3.0\n    k_cut_ref = 50.0\n\n    def calculate_ewald_force(alpha, r_cut, k_cut):\n        \"\"\"\n        Calculates the electrostatic forces on all particles using Ewald summation.\n        \n        Args:\n            alpha (float): Ewald splitting parameter.\n            r_cut (float): Real-space cutoff distance.\n            k_cut (float): Reciprocal-space cutoff magnitude.\n            \n        Returns:\n            numpy.ndarray: An (N, 3) array of force vectors for each particle.\n        \"\"\"\n        # --- Real-Space Contribution ---\n        F_real = np.zeros((N, 3))\n        if r_cut > 0:\n            n_max = int(np.ceil(r_cut / L))\n            for i in range(N):\n                for j in range(N):\n                    qiqj = charges[i] * charges[j]\n                    rij = positions[i] - positions[j]\n                    for nx in range(-n_max, n_max + 1):\n                        for ny in range(-n_max, n_max + 1):\n                            for nz in range(-n_max, n_max + 1):\n                                if i == j and nx == 0 and ny == 0 and nz == 0:\n                                    continue\n                                \n                                box_vec = L * np.array([nx, ny, nz])\n                                r_vec = rij + box_vec\n                                r_mag = np.linalg.norm(r_vec)\n\n                                if r_mag < r_cut:\n                                    ar = alpha * r_mag\n                                    term1 = erfc(ar) / r_mag**3\n                                    term2 = (2.0 * alpha / np.sqrt(np.pi)) * np.exp(-ar**2) / r_mag**2\n                                    force_vec = qiqj * (term1 + term2) * r_vec\n                                    F_real[i] += force_vec\n\n        # --- Reciprocal-Space Contribution ---\n        F_recip = np.zeros((N, 3))\n        V = L**3\n        if k_cut > 0:\n            m_max = int(np.ceil(k_cut * L / (2 * np.pi)))\n            for mx in range(-m_max, m_max + 1):\n                for my in range(-m_max, m_max + 1):\n                    for mz in range(-m_max, m_max + 1):\n                        if mx == 0 and my == 0 and mz == 0:\n                            continue\n\n                        m_vec = np.array([mx, my, mz])\n                        k_vec = (2 * np.pi / L) * m_vec\n                        k_sq = np.dot(k_vec, k_vec)\n\n                        if np.sqrt(k_sq) < k_cut:\n                            # Structure factor components\n                            k_dot_r = np.dot(positions, k_vec)\n                            C_sum = np.sum(charges * np.cos(k_dot_r))\n                            S_sum = np.sum(charges * np.sin(k_dot_r))\n\n                            prefac = (4 * np.pi / V) * np.exp(-k_sq / (4 * alpha**2)) / k_sq\n\n                            # Force on each particle i\n                            sin_kr_i = np.sin(k_dot_r)\n                            cos_kr_i = np.cos(k_dot_r)\n                            factor_i = charges * (C_sum * sin_kr_i - S_sum * cos_kr_i)\n                            \n                            F_recip += prefac * np.outer(factor_i, k_vec)\n        \n        return F_real + F_recip\n\n    results = []\n    for case in test_cases:\n        alpha, r_cut, k_cut = case\n\n        # Calculate force with truncated parameters\n        F_trunc = calculate_ewald_force(alpha, r_cut, k_cut)\n        \n        # Calculate force with reference parameters (using the same alpha)\n        F_ref = calculate_ewald_force(alpha, r_cut_ref, k_cut_ref)\n        \n        # Calculate Root-Mean-Square Relative Error (RMSRE)\n        sum_sq_rel_err = 0.0\n        for i in range(N):\n            delta_F_norm = np.linalg.norm(F_trunc[i] - F_ref[i])\n            F_ref_norm = np.linalg.norm(F_ref[i])\n            \n            denominator = max(F_ref_norm, epsilon_reg)\n            relative_error = delta_F_norm / denominator\n            sum_sq_rel_err += relative_error**2\n        \n        rmsre = np.sqrt(sum_sq_rel_err / N)\n        results.append(rmsre)\n\n    # Format and print the final output as a single line\n    output_str = \",\".join([f\"{res:.6e}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2390969"}]}