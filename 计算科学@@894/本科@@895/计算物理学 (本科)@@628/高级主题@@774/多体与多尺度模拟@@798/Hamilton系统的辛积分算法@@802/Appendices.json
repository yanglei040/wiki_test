{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式就是动手实践。让我们从一个经典物理问题开始：抛体运动。这个练习将指导你使用位置-Verlet算法，一步步地计算一个物体在恒定重力场中的运动轨迹 [@problem_id:1713079]。通过这个基础练习，你将熟悉辛积分器最核心的迭代过程，为理解其更深刻的性质打下坚实基础。", "problem": "在计算物理学中，一项常见的任务是模拟粒子在力作用下的运动。辛积分器是一类特别适用于此任务的数值方法，因为它们在长期模拟中能较好地保持系统总能量守恒。\n\n考虑一个在匀强引力场中做二维运动 $(x,y)$ 的粒子。该粒子的轨迹将使用位置Verlet算法进行模拟。在离散时间步 $n$，粒子位置矢量 $\\vec{r}_n$ 和速度矢量 $\\vec{v}_n$ 的更新规则如下：\n$$ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_n \\Delta t + \\frac{1}{2} \\vec{a}(\\vec{r}_n) (\\Delta t)^2 $$\n$$ \\vec{v}_{n+1} = \\vec{v}_n + \\frac{1}{2} (\\vec{a}(\\vec{r}_n) + \\vec{a}(\\vec{r}_{n+1})) \\Delta t $$\n其中 $\\Delta t$ 是时间步长，$\\vec{a}(\\vec{r})$ 是加速度矢量，它可能取决于位置 $\\vec{r}$。\n\n该粒子受到一个恒定的竖直向下引力加速度，由矢量 $\\vec{g} = (0, -g)$ 描述。在时间 $t_0 = 0$ 时，粒子的初始位置为 $\\vec{r}_0 = (0, 0)$，初始速度为 $\\vec{v}_0 = (12.5 \\text{ m/s}, 25.0 \\text{ m/s})$。\n\n使用以下常数：\n- 引力加速度大小：$g = 9.80 \\text{ m/s}^2$\n- 时间步长：$\\Delta t = 1.20 \\text{ s}$\n\n计算粒子在时间 $t_2 = 2\\Delta t$ 时的位置矢量分量 $(x_2, y_2)$ 和速度矢量分量 $(v_{x,2}, v_{y,2})$。\n\n你的答案应包含 $x_2, y_2, v_{x,2}, v_{y,2}$ 四个分量的数值，并严格按照此顺序排列。最终答案的位置以米为单位，速度以米/秒为单位，每个数值均需保留三位有效数字。", "solution": "目标是使用位置Verlet算法，求解粒子在两个时间步长之后的位置 $\\vec{r}_2 = (x_2, y_2)$ 和速度 $\\vec{v}_2 = (v_{x,2}, v_{y,2})$。\n\n题目说明粒子处于匀强引力场中，因此其加速度是恒定的，不依赖于位置。对于任何位置 $\\vec{r}$，加速度矢量为 $\\vec{a}(\\vec{r}) = \\vec{g} = (0, -g)$。这意味着 $\\vec{a}(\\vec{r}_n) = \\vec{a}(\\vec{r}_{n+1}) = (0, -g)$。\n\n这简化了速度更新规则：\n$$ \\vec{v}_{n+1} = \\vec{v}_n + \\frac{1}{2} ((0, -g) + (0, -g)) \\Delta t = \\vec{v}_n + (0, -g) \\Delta t $$\n位置更新规则为：\n$$ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_n \\Delta t + \\frac{1}{2} (0, -g) (\\Delta t)^2 $$\n\n给定 $n=0$ 时的初始条件：\n$\\vec{r}_0 = (x_0, y_0) = (0, 0)$\n$\\vec{v}_0 = (v_{x,0}, v_{y,0}) = (12.5, 25.0)$\n常数为 $g = 9.80$ 和 $\\Delta t = 1.20$。\n\n**步骤1：计算时间 $t_1 = \\Delta t$ 时的状态（即 $n=1$）。**\n\n我们使用 $n=0$ 时的更新规则。\n对于位置 $\\vec{r}_1 = (x_1, y_1)$：\nx分量的更新为：\n$x_1 = x_0 + v_{x,0} \\Delta t + \\frac{1}{2}(0)(\\Delta t)^2 = 0 + (12.5 \\text{ m/s})(1.20 \\text{ s}) = 15.0 \\text{ m}$\ny分量的更新为：\n$y_1 = y_0 + v_{y,0} \\Delta t + \\frac{1}{2}(-g)(\\Delta t)^2 = 0 + (25.0 \\text{ m/s})(1.20 \\text{ s}) - \\frac{1}{2}(9.80 \\text{ m/s}^2)(1.20 \\text{ s})^2$\n$y_1 = 30.0 \\text{ m} - \\frac{1}{2}(9.80 \\text{ m/s}^2)(1.44 \\text{ s}^2) = 30.0 \\text{ m} - 7.056 \\text{ m} = 22.944 \\text{ m}$\n所以，$\\vec{r}_1 = (15.0, 22.944)$ m。\n\n对于速度 $\\vec{v}_1 = (v_{x,1}, v_{y,1})$：\nx分量的更新为：\n$v_{x,1} = v_{x,0} + (0)\\Delta t = 12.5 \\text{ m/s}$\ny分量的更新为：\n$v_{y,1} = v_{y,0} - g \\Delta t = 25.0 \\text{ m/s} - (9.80 \\text{ m/s}^2)(1.20 \\text{ s}) = 25.0 \\text{ m/s} - 11.76 \\text{ m/s} = 13.24 \\text{ m/s}$\n所以，$\\vec{v}_1 = (12.5, 13.24)$ m/s。\n\n**步骤2：计算时间 $t_2 = 2\\Delta t$ 时的状态（即 $n=2$）。**\n\n现在我们使用 $n=1$ 时的更新规则，以及我们刚计算出的状态 $(\\vec{r}_1, \\vec{v}_1)$。\n对于位置 $\\vec{r}_2 = (x_2, y_2)$：\nx分量的更新为：\n$x_2 = x_1 + v_{x,1} \\Delta t + \\frac{1}{2}(0)(\\Delta t)^2 = 15.0 \\text{ m} + (12.5 \\text{ m/s})(1.20 \\text{ s}) = 15.0 \\text{ m} + 15.0 \\text{ m} = 30.0 \\text{ m}$\ny分量的更新为：\n$y_2 = y_1 + v_{y,1} \\Delta t + \\frac{1}{2}(-g)(\\Delta t)^2 = 22.944 \\text{ m} + (13.24 \\text{ m/s})(1.20 \\text{ s}) - \\frac{1}{2}(9.80 \\text{ m/s}^2)(1.20 \\text{ s})^2$\n$y_2 = 22.944 \\text{ m} + 15.888 \\text{ m} - 7.056 \\text{ m} = 31.776 \\text{ m}$\n所以，$\\vec{r}_2 = (30.0, 31.776)$ m。\n\n对于速度 $\\vec{v}_2 = (v_{x,2}, v_{y,2})$：\nx分量的更新为：\n$v_{x,2} = v_{x,1} + (0)\\Delta t = 12.5 \\text{ m/s}$\ny分量的更新为：\n$v_{y,2} = v_{y,1} - g \\Delta t = 13.24 \\text{ m/s} - (9.80 \\text{ m/s}^2)(1.20 \\text{ s}) = 13.24 \\text{ m/s} - 11.76 \\text{ m/s} = 1.48 \\text{ m/s}$\n所以，$\\vec{v}_2 = (12.5, 1.48)$ m/s。\n\n**步骤3：整理最终答案**\n\n计算出的分量为：\n$x_2 = 30.0$ m\n$y_2 = 31.776$ m\n$v_{x,2} = 12.5$ m/s\n$v_{y,2} = 1.48$ m/s\n\n将每个值四舍五入到三位有效数字：\n$x_2 = 30.0$\n$y_2 \\approx 31.8$\n$v_{x,2} = 12.5$\n$v_{y,2} = 1.48$\n\n最终答案应为这四个值，按 $x_2, y_2, v_{x,2}, v_{y,2}$ 的顺序排列。", "answer": "$$\\boxed{\\begin{pmatrix} 30.0 & 31.8 & 12.5 & 1.48 \\end{pmatrix}}$$", "id": "1713079"}, {"introduction": "仅仅会用算法是不够的，理解其背后的原理更为关键。“辛”积分器的“辛”字，源于其保持哈密顿系统相空间流形上的辛2-形式 ($d\\mathbf{q} \\wedge d\\mathbf{p}$) 不变的几何特性，这在二维相空间中直观表现为面积保持。这个练习 [@problem_id:2444632] 通过一个简单而深刻的数值实验，让你亲眼见证辛积分器与非辛积分器在保持相空间面积上的巨大差异。这将帮助你从根本上理解辛积分器为何能提供卓越的长期稳定性。", "problem": "考虑一个二维谐振子，其哈密顿量为 $H(x,p)=\\dfrac{p^2}{2 m}+\\dfrac{1}{2} k x^2$，其中 $m=1$，$k=\\omega^2$，$x$ 是位置坐标，$p$ 是共轭动量。其哈密顿运动方程为 $\\dot{x}=p$ 和 $\\dot{p}=-\\omega^2 x$。定义如下两个时间步长为 $h$ 的离散时间单步映射：\n- 映射 $\\mathcal{F}$ (一个显式前向步)：$x_{n+1}=x_n+h\\,p_n$，$p_{n+1}=p_n-h\\,\\omega^2 x_n$。\n- 映射 $\\mathcal{S}$ (一个半隐式步)：$p_{n+1}=p_n-h\\,\\omega^2 x_n$，$x_{n+1}=x_n+h\\,p_{n+1}$。\n设 $\\mathcal{C}_0$ 是 $(x,p)$ 相平面中的一个闭凸多边形，其 $M$ 个顶点 $\\{(x_j(0),p_j(0))\\}_{j=0}^{M-1}$ 按逆时针排序，由下式给出：\n$$\nx_j(0)=R\\cos\\theta_j,\\quad p_j(0)=R\\sin\\theta_j,\\quad \\theta_j=\\dfrac{2\\pi j}{M},\n$$\n其中 $j\\in\\{0,1,\\dots,M-1\\}$，所有角度均以弧度为单位。所有量均为无量纲量。\n\n对于给定的映射 $\\mathcal{M}\\in\\{\\mathcal{F},\\mathcal{S}\\}$ 和一个正整数 $N$，定义 $\\mathcal{C}_N$ 为将 $\\mathcal{M}$ 的 $N$ 个连续步骤应用于 $\\mathcal{C}_0$ 的每个顶点所得到的多边形，并保持顶点顺序。定义多边形面积泛函\n$$\nA[\\mathcal{C}]=\\dfrac{1}{2}\\left|\\sum_{j=0}^{M-1}\\left(x_j\\,p_{j+1}-x_{j+1}\\,p_j\\right)\\right|,\n$$\n其中索引是循环的，$x_M\\equiv x_0$ 且 $p_M\\equiv p_0$。对于下面的每个测试用例，计算当 $\\mathcal{M}=\\mathcal{F}$ 和 $\\mathcal{M}=\\mathcal{S}$ 时的面积比 $A[\\mathcal{C}_N]/A[\\mathcal{C}_0]$。\n\n使用以下参数集 $(\\omega,h,N,M,R)$ 的测试套件：\n- 测试 $1$：$(\\omega,h,N,M,R)=\\left(1,\\,0.1,\\,100,\\,128,\\,1\\right)$。\n- 测试 $2$：$(\\omega,h,N,M,R)=\\left(1,\\,0.5,\\,20,\\,128,\\,1\\right)$。\n- 测试 $3$：$(\\omega,h,N,M,R)=\\left(2,\\,0.1,\\,100,\\,128,\\,1\\right)$。\n- 测试 $4$：$(\\omega,h,N,M,R)=\\left(1,\\,0.01,\\,1000,\\,128,\\,1\\right)$。\n\n你的程序必须对每个测试用例按所列顺序生成两个浮点数：首先是映射 $\\mathcal{F}$ 的面积比，然后是映射 $\\mathcal{S}$ 的面积比。将每个数字四舍五入到6位小数。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中包含所有按顺序排列的结果，即\n$$\n\\left[\\rho^{(\\mathcal{F})}_1,\\rho^{(\\mathcal{S})}_1,\\rho^{(\\mathcal{F})}_2,\\rho^{(\\mathcal{S})}_2,\\rho^{(\\mathcal{F})}_3,\\rho^{(\\mathcal{S})}_3,\\rho^{(\\mathcal{F})}_4,\\rho^{(\\mathcal{S})}_4\\right],\n$$\n其中 $\\rho^{(\\mathcal{M})}_i=A[\\mathcal{C}_N]/A[\\mathcal{C}_0]$ 代表第 $i$ 个测试用例和映射 $\\mathcal{M}$ 的结果。本问题不涉及物理单位，所有角度必须以弧度为单位。", "solution": "该问题要求计算一个多边形在谐振子的两种不同数值积分方案下演化后的相空间面积之比。对 $M$ 个顶点中的每一个进行 $N$ 个时间步的直接模拟是一种有效但计算效率低下的方法。通过分析这些映射的代数性质，可以找到一个更具洞察力的解决方案。\n\n设系统在相空间中的状态用向量 $z = (x, p)^T$ 表示。哈密顿运动方程为 $\\dot{x} = \\partial H / \\partial p = p/m$ 和 $\\dot{p} = -\\partial H / \\partial x = -kx$。当 $m=1$ 和 $k=\\omega^2$ 时，我们有 $\\dot{z} = A z$，其中 $A = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix}$。映射 $\\mathcal{F}$ 和 $\\mathcal{S}$ 是对此线性系统流的离散近似。\n\n映射 $\\mathcal{F}$ 和 $\\mathcal{S}$ 都是从时间步 $n$ 的状态 $(x_n, p_n)$ 到时间步 $n+1$ 的状态 $(x_{n+1}, p_{n+1})$ 的线性变换。我们可以将它们表示为矩阵形式 $z_{n+1} = M z_n$。\n\n对于映射 $\\mathcal{F}$ (显式前向欧拉法)：\n$$\n\\begin{cases}\nx_{n+1} = x_n + h\\,p_n \\\\\np_{n+1} = p_n - h\\,\\omega^2 x_n\n\\end{cases}\n\\implies\n\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} =\n\\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}\n$$\n因此，单步演化矩阵为 $M_{\\mathcal{F}} = \\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}$。\n\n对于映射 $\\mathcal{S}$ (半隐式欧拉法)：\n$$\n\\begin{cases}\np_{n+1} = p_n - h\\,\\omega^2 x_n \\\\\nx_{n+1} = x_n + h\\,p_{n+1} = x_n + h(p_n - h\\omega^2 x_n) = (1-h^2\\omega^2)x_n + h p_n\n\\end{cases}\n$$\n$$\n\\implies\n\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} =\n\\begin{pmatrix} 1-h^2\\omega^2 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}\n$$\n单步演化矩阵为 $M_{\\mathcal{S}} = \\begin{pmatrix} 1-h^2\\omega^2 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}$。\n\n经过 $N$ 步后，从初始状态 $z_0$ 到最终状态 $z_N$ 的变换由 $z_N = (M_{\\mathcal{M}})^N z_0$ 给出，其中 $\\mathcal{M} \\in \\{\\mathcal{F}, \\mathcal{S}\\}$。这是一个线性变换，我们称其矩阵为 $T = (M_{\\mathcal{M}})^N$。\n\n具有顶点 $\\{(x_j, p_j)\\}_{j=0}^{M-1}$ 的多边形 $\\mathcal{C}$ 的面积由鞋带公式给出：\n$$\nA[\\mathcal{C}]=\\dfrac{1}{2}\\left|\\sum_{j=0}^{M-1}\\left(x_j\\,p_{j+1}-x_{j+1}\\,p_j\\right)\\right|\n$$\n当一个多边形经过一个矩阵为 $T$ 的线性变换时，其面积 $A$ 变为 $A' = |\\det(T)| A$。在我们的问题中，初始多边形 $\\mathcal{C}_0$ 的顶点 $\\{z_j(0)\\}$ 变换为最终多边形 $\\mathcal{C}_N$ 的顶点 $\\{z_j(N) = T z_j(0)\\}$。因此，最终多边形的面积为 $A[\\mathcal{C}_N] = |\\det(T)| A[\\mathcal{C}_0]$。\n\n所求的面积比为：\n$$\n\\dfrac{A[\\mathcal{C}_N]}{A[\\mathcal{C}_0]} = |\\det(T)| = |\\det((M_{\\mathcal{M}})^N)| = |\\det(M_{\\mathcal{M}})|^N\n$$\n这个结果与初始多边形的具体几何形状无关，即参数 $M$ 和 $R$ 与最终的比值无关。我们只需要计算单步矩阵的行列式。\n\n对于映射 $\\mathcal{F}$：\n$$\n\\det(M_{\\mathcal{F}}) = (1)(1) - (h)(-h\\omega^2) = 1 + h^2\\omega^2\n$$\n面积比为 $\\rho^{(\\mathcal{F})} = (1 + h^2\\omega^2)^N$。由于 $h > 0$ 且 $\\omega > 0$，该值总是大于 $1$，表明面积呈指数增长。该映射不是辛映射。\n\n对于映射 $\\mathcal{S}$：\n$$\n\\det(M_{\\mathcal{S}}) = (1-h^2\\omega^2)(1) - (h)(-h\\omega^2) = 1 - h^2\\omega^2 + h^2\\omega^2 = 1\n$$\n面积比为 $\\rho^{(\\mathcal{S})} = (1)^N = 1$。该映射对于任意参数选择都能精确地保持相空间面积，因此是一个辛映射。\n\n我们现在将这些公式应用于给定的测试用例。\n\n测试 $1$：$(\\omega,h,N,M,R)=\\left(1,\\,0.1,\\,100,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.1)^2(1)^2)^{100} = (1.01)^{100} \\approx 2.704814$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\n测试 $2$：$(\\omega,h,N,M,R)=\\left(1,\\,0.5,\\,20,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.5)^2(1)^2)^{20} = (1.25)^{20} \\approx 86.736174$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\n测试 $3$：$(\\omega,h,N,M,R)=\\left(2,\\,0.1,\\,100,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.1)^2(2)^2)^{100} = (1.04)^{100} \\approx 50.504948$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\n测试 $4$：$(\\omega,h,N,M,R)=\\left(1,\\,0.01,\\,1000,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.01)^2(1)^2)^{1000} = (1.0001)^{1000} \\approx 1.105116$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\n这些计算将在提供的程序结构中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analytically calculating the area ratios for the two maps.\n    The area ratio for a polygon under a linear map T is given by |det(T)|.\n    For N steps, the transformation is T = M^N, where M is the one-step matrix.\n    The area ratio is |det(M^N)| = |det(M)|^N.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (omega, h, N, M, R)\n    test_cases = [\n        (1.0, 0.1, 100, 128, 1.0),\n        (1.0, 0.5, 20, 128, 1.0),\n        (2.0, 0.1, 100, 128, 1.0),\n        (1.0, 0.01, 1000, 128, 1.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        omega, h, N, M, R = case\n\n        # --- Map F (Explicit Euler) ---\n        # The one-step matrix M_F has determinant det(M_F) = 1 + h^2 * omega^2.\n        # The area ratio after N steps is (det(M_F))^N.\n        det_M_F = 1.0 + h**2 * omega**2\n        rho_F = np.power(det_M_F, N)\n\n        # --- Map S (Symplectic Euler) ---\n        # The one-step matrix M_S has determinant det(M_S) = 1.\n        # The area ratio after N steps is (det(M_S))^N = 1^N = 1.\n        rho_S = 1.0\n\n        # Append the rounded results for the current test case.\n        results.append(round(rho_F, 6))\n        results.append(round(rho_S, 6))\n\n    # Final print statement in the exact required format.\n    # The output is a single line, comma-separated list of numbers in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2444632"}, {"introduction": "除了保持相空间几何结构，许多优秀的辛积分器还具备另一个重要特性：时间对称性。这意味着从初始状态正向演化一段时间，再反向演化同样长的时间，系统应该精确地回到原点。这个练习 [@problem_id:2444614] 设计了一个“前进再后退”的数值实验，让你量化比较Verlet积分器与常用的高精度非辛积分器（四阶龙格-库塔法）在时间可逆性上的表现。通过这个实践，你将明白为何对于需要长期模拟的物理系统，时间对称的辛积分器是更可靠的选择。", "problem": "考虑一个一维谐振子，其哈密顿量为 $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k}{2}q^2$，其中 $q$ 是位置，$p$ 是动量，$m$ 是质量，$k$ 是劲度系数。其动力学行为由哈密顿方程决定。从时间 $t=0$ 时的初始状态 $(q_0,p_0)$ 开始，为给定的时间步进方法定义如下的数值可逆性定量诊断：首先对系统以大小为 $h$ 的均匀步长进行 $N$ 步时间正向积分，得到 $(q_N,p_N)$；然后从 $(q_N,p_N)$ 开始，以大小为 $-h$ 的均匀步长进行 $N$ 步时间反向积分，得到 $(\\tilde{q}_0,\\tilde{p}_0)$。数值可逆性误差是欧几里得范数 $E=\\sqrt{(\\tilde{q}_0-q_0)^2+(\\tilde{p}_0-p_0)^2}$。\n\n编写一个完整、可运行的程序，为以下两种积分器计算这个正向再反向的数值可逆性误差 $E$：\n- 经典四阶 Runge–Kutta 方法（四阶 Runge–Kutta (RK4)），\n- 速度 Verlet 辛格式。\n\n本问题中所有量均为无量纲，因此所有数值结果都应报告为无量纲实数。你的程序必须为两种积分器和以下每个测试用例（由 $(m,k,q_0,p_0,h,N)$ 指定）计算误差 $E$：\n1. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.1,\\,100\\right)$，一个通用情况。\n2. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.01,\\,1000\\right)$，一个小时间步长情况。\n3. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,1.9,\\,100\\right)$，一个接近谐振子稳定性边界的大时间步长情况。\n4. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.05,\\,10000\\right)$，一个长时间积分。\n5. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,0.2,\\,-0.3,\\,0.37,\\,0\\right)$，一个零步长的边界条件情况。\n6. $(m,k,q_0,p_0,h,N)=\\left(2.0,\\,0.5,\\,0.3,\\,0.7,\\,0.07,\\,1234\\right)$，一个非平凡的质量和刚度。\n\n对于每个测试用例，计算两个误差：$E_{\\mathrm{RK4}}$ 和 $E_{\\mathrm{Verlet}}$。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，顺序为\n$[E_{\\mathrm{RK4}}^{(1)},E_{\\mathrm{Verlet}}^{(1)},E_{\\mathrm{RK4}}^{(2)},E_{\\mathrm{Verlet}}^{(2)},\\dots,E_{\\mathrm{RK4}}^{(6)},E_{\\mathrm{Verlet}}^{(6)}]$,\n其中上标表示测试用例的编号。每个数字必须四舍五入到 $12$ 位小数。\n\n你的实现必须从给定的 $H(q,p)$ 的哈密顿方程出发，使用指定的两种积分器，不依赖任何外部数据。不涉及角度。最终输出必须严格匹配指定的单行格式。", "solution": "该问题要求对一维谐振子，就两种积分器——四阶 Runge-Kutta 方法和速度 Verlet 方法——的数值可逆性进行对比分析。我们首先建立运动控制方程。\n\n系统由哈密顿量 $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k}{2}q^2$ 描述，其中 $q$ 是位置，$p$ 是动量，$m$ 是质量，$k$ 是劲度系数。所有量均为无量纲。动力学行为由哈密顿方程决定：\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial q} = -kq $$\n这是一个由两个耦合的一阶常微分方程组成的系统。我们可以用向量 $\\mathbf{y}(t) = [q(t), p(t)]^T$ 来表示系统状态。运动方程可以写成紧凑形式 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$，其中向量场 $\\mathbf{f}$ 由下式给出：\n$$ \\mathbf{f}(\\mathbf{y}) = \\mathbf{f}(q, p) = \\begin{pmatrix} p/m \\\\ -kq \\end{pmatrix} $$\n我们的任务是使用两种不同的方法对该系统进行数值积分。\n\n首先，我们考虑经典的四阶 Runge-Kutta (RK4) 方法。给定在时间 $t_n$ 的状态 $\\mathbf{y}_n$，通过一个大小为 $h$ 的单步计算在时间 $t_{n+1} = t_n + h$ 的状态 $\\mathbf{y}_{n+1}$ 的公式如下：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\n其中中间阶段定义为：\n$$ \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) $$\n$$ \\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1) $$\n$$ \\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_2) $$\n$$ \\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h\\mathbf{k}_3) $$\n注意，在实现中，因子 $h$ 通常在最后阶段应用。RK4 方法是一种通用的显式积分器，其局部截断误差为 $O(h^5)$ 阶，导致全局误差为 $O(h^4)$ 阶。然而，它不是一个辛积分器，这意味着它通常不保持哈密顿系统的几何结构。因此，它不是时间可逆的。\n\n其次，我们考虑速度 Verlet 方法。该方法是专门为可分离形式 $H(q,p) = T(p) + V(q)$ 的哈密顿系统设计的，我们的谐振子哈密顿量满足此形式，其中 $T(p)=p^2/(2m)$ 且 $V(q)=kq^2/2$。从 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的单步算法如下：\n$1$. 更新动量半步，使用力 $F(q) = -\\partial V/\\partial q = -kq$：\n$$ p_{n+1/2} = p_n + \\frac{h}{2} F(q_n) = p_n - \\frac{h}{2} k q_n $$\n$2$. 使用半步动量更新位置一个整步：\n$$ q_{n+1} = q_n + h \\frac{p_{n+1/2}}{m} $$\n$3$. 使用新的力 $F(q_{n+1})$ 更新动量最后半步：\n$$ p_{n+1} = p_{n+1/2} + \\frac{h}{2} F(q_{n+1}) = p_{n+1/2} - \\frac{h}{2} k q_{n+1} $$\n速度 Verlet 方法的局部截断误差为 $O(h^3)$ 阶，全局误差为 $O(h^2)$ 阶。它在哈密顿力学中的关键优势在于它是一个辛积分器。此性质的一个关键推论是该方法是时间可逆的（或对称的）。\n\n数值可逆性误差 $E$ 就是为了直接测试这个性质而设计的。设 $\\Phi_h$ 是将系统推进一个大小为 $h$ 的步长的数值映射。其过程如下：\n$1$. 从初始状态 $\\mathbf{y}_0 = (q_0, p_0)$ 开始正向积分 $N$ 步，得到 $\\mathbf{y}_N = \\Phi_h^N(\\mathbf{y}_0)$。\n$2$. 从 $\\mathbf{y}_N$ 开始，使用步长 $-h$ 反向积分 $N$ 步，得到 $\\tilde{\\mathbf{y}}_0 = \\Phi_{-h}^N(\\mathbf{y}_N)$。\n$3$. 误差是欧几里得距离 $E = \\|\\tilde{\\mathbf{y}}_0 - \\mathbf{y}_0\\| = \\sqrt{(\\tilde{q}_0-q_0)^2+(\\tilde{p}_0-p_0)^2}$。\n\n对于一个时间可逆的积分器，一个正向步和一个反向步的精确复合是单位映射：$\\Phi_{-h} \\circ \\Phi_h = \\mathrm{Id}$。此性质可以延伸到任意步数，因此有 $\\Phi_{-h}^N \\circ \\Phi_h^N = \\mathrm{Id}$。因此，对于速度 Verlet 方法，在精确算术下，我们期望 $\\tilde{\\mathbf{y}}_0 = \\mathbf{y}_0$。因此计算出的误差 $E_{\\mathrm{Verlet}}$ 应该为零，或者是一个可归因于浮点精度误差累积的非常小的数。\n\n对于非对称的 RK4 方法，$\\Phi_{-h} \\circ \\Phi_h \\neq \\mathrm{Id}$。正向-反向积分将不会返回到初始状态。由此产生的误差 $E_{\\mathrm{RK4}}$ 将不为零，并为该方法缺乏可逆性提供一个定量度量。预期该误差将依赖于步长 $h$ 和步数 $N$。\n\n程序将实现这两种算法，根据正向-反向程序将它们应用于指定的测试用例，并计算误差 $E$。对于测试用例5，其中 $N=0$，不执行任何积分步骤。因此，$\\mathbf{y}_N = \\mathbf{y}_0$ 并且 $\\tilde{\\mathbf{y}}_0 = \\mathbf{y}_N = \\mathbf{y}_0$，导致两种方法的误差 $E=0$，这是平凡的结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical reversibility error for RK4 and Velocity Verlet integrators\n    for a 1D harmonic oscillator across several test cases.\n    \"\"\"\n\n    test_cases = [\n        # (m, k, q0, p0, h, N)\n        (1.0, 1.0, 1.0, 0.0, 0.1, 100),       # 1. General case\n        (1.0, 1.0, 1.0, 0.0, 0.01, 1000),     # 2. Small time step\n        (1.0, 1.0, 1.0, 0.0, 1.9, 100),       # 3. Large time step\n        (1.0, 1.0, 1.0, 0.0, 0.05, 10000),    # 4. Long-time integration\n        (1.0, 1.0, 0.2, -0.3, 0.37, 0),      # 5. Zero steps\n        (2.0, 0.5, 0.3, 0.7, 0.07, 1234),     # 6. Nontrivial parameters\n    ]\n\n    def rk4_step(q, p, h, m, k):\n        \"\"\"Performs a single RK4 step for the harmonic oscillator.\"\"\"\n        \n        # k1\n        k1q = p / m\n        k1p = -k * q\n\n        # k2\n        q2 = q + 0.5 * h * k1q\n        p2 = p + 0.5 * h * k1p\n        k2q = p2 / m\n        k2p = -k * q2\n\n        # k3\n        q3 = q + 0.5 * h * k2q\n        p3 = p + 0.5 * h * k2p\n        k3q = p3 / m\n        k3p = -k * q3\n\n        # k4\n        q4 = q + h * k3q\n        p4 = p + h * k3p\n        k4q = p4 / m\n        k4p = -k * q4\n        \n        q_new = q + (h / 6.0) * (k1q + 2.0 * k2q + 2.0 * k3q + k4q)\n        p_new = p + (h / 6.0) * (k1p + 2.0 * k2p + 2.0 * k3p + k4p)\n        \n        return q_new, p_new\n\n    def verlet_step(q, p, h, m, k):\n        \"\"\"Performs a single Velocity Verlet step for the harmonic oscillator.\"\"\"\n        \n        force_initial = -k * q\n        p_half = p + 0.5 * h * force_initial\n        q_new = q + h * (p_half / m)\n        force_final = -k * q_new\n        p_new = p_half + 0.5 * h * force_final\n        \n        return q_new, p_new\n\n    def compute_reversibility_error(integrator_step, m, k, q0, p0, h, N):\n        \"\"\"\n        Computes the forward-then-backward numerical reversibility error E.\n        \"\"\"\n        if N == 0:\n            return 0.0\n\n        q, p = q0, p0\n        \n        # Forward integration\n        for _ in range(N):\n            q, p = integrator_step(q, p, h, m, k)\n        \n        # Backward integration\n        for _ in range(N):\n            q, p = integrator_step(q, p, -h, m, k)\n            \n        q_tilde_0, p_tilde_0 = q, p\n        \n        error = np.sqrt((q_tilde_0 - q0)**2 + (p_tilde_0 - p0)**2)\n        return error\n\n    results = []\n    for case in test_cases:\n        m, k, q0, p0, h, N = case\n        \n        m, k, q0, p0, h = float(m), float(k), float(q0), float(p0), float(h)\n        N = int(N)\n        \n        error_rk4 = compute_reversibility_error(rk4_step, m, k, q0, p0, h, N)\n        error_verlet = compute_reversibility_error(verlet_step, m, k, q0, p0, h, N)\n        \n        results.append(round(error_rk4, 12))\n        results.append(round(error_verlet, 12))\n    \n    final_output = \",\".join(map(str, results))\n    print(f\"[{final_output}]\")\n\nsolve()\n```", "id": "2444614"}]}