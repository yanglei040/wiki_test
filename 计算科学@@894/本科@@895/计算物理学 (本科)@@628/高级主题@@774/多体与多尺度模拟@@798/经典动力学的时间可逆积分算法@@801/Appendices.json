{"hands_on_practices": [{"introduction": "理论是深刻的，但没有什么比亲眼见证其运作更具说服力。我们的第一个动手实践将对比辛积分器（如此处使用的速度 Verlet 算法）和一种广泛使用但非辛的高阶积分器（四阶龙格－库塔法或 RK4）的性能 [@problem_id:2446756]。我们将这个对比应用于一个经典的物理问题——天体轨道力学，在这个问题中，能量的微小误差会随着时间的推移累积，导致轨道形状和大小发生巨大的、非物理性的改变。通过这个练习，你将通过编码直观地理解为何时间可逆与辛性质对于长时程模拟的能量守恒至关重要。", "problem": "实现并比较两种用于平面内牛顿二体运动的数值积分器，一种是时间可逆和辛的（速度 Verlet），另一种是显式四阶但非时间可逆的（四阶龙格-库塔方法 (RK4)）。考虑一个质量为 $m=1\\ \\mathrm{kg}$ 的测试粒子，在标准引力参数为 $\\mu = G M = 1.32712440018\\times 10^{20}\\ \\mathrm{m^3/s^2}$ 的固定中心天体的引力场中运动。其运动方程为以下一阶系统：\n$$\n\\dot{\\mathbf{r}}(t) = \\mathbf{v}(t),\\qquad \\dot{\\mathbf{v}}(t) = -\\frac{\\mu}{\\|\\mathbf{r}(t)\\|^3}\\,\\mathbf{r}(t),\n$$\n总比机械能为\n$$\nE(t) = \\frac{1}{2}\\,\\|\\mathbf{v}(t)\\|^2 - \\frac{\\mu}{\\|\\mathbf{r}(t)\\|},\n$$\n该能量在连续动力学中是精确守恒的。使用初始位置 $\\mathbf{r}_0 = (r_0,0)$（其中 $r_0 = 1.495978707\\times 10^{11}\\ \\mathrm{m}$）和每个测试案例中指定的初始速度 $\\mathbf{v}_0 = (0, v_{\\mathrm{init}})$。半径为 $r_0$ 的圆形轨道速度为 $v_{\\mathrm{circ}} = \\sqrt{\\mu/r_0}$。\n\n在下述每个测试案例中，使用两种积分器模拟二维空间中的运动。对于每次模拟，以大小为 $\\Delta t$ 的均匀时间步长推进，直至总时间 $T$。将步数定义为 $N=\\left\\lfloor T/\\Delta t \\right\\rfloor$，并精确推进 $N$ 步。计算比能的绝对相对漂移：\n$$\n\\varepsilon = \\left|\\frac{E_N - E_0}{|E_0|}\\right|,\n$$\n其中 $E_0$ 是初始比能，$E_N$ 是 $N$ 步后的比能。报告速度 Verlet 方法和四阶龙格-库塔 (RK4) 方法的 $\\varepsilon$ 值。\n\n全程使用国际单位制 (SI)，距离单位为 $\\mathrm{m}$，时间单位为 $\\mathrm{s}$，能量（比能）单位为 $\\mathrm{J/kg}$。角度（如果内部出现）应以弧度为单位。最终输出为无量纲数。\n\n测试套件：\n- 案例 1（圆形轨道，小步长）：$v_{\\mathrm{init}} = v_{\\mathrm{circ}}$，$\\Delta t = 86400\\ \\mathrm{s}$，$T = 50\\times 365.25\\times 86400\\ \\mathrm{s}$。\n- 案例 2（圆形轨道，大步长）：$v_{\\mathrm{init}} = v_{\\mathrm{circ}}$，$\\Delta t = 5\\times 86400\\ \\mathrm{s}$，$T = 200\\times 365.25\\times 86400\\ \\mathrm{s}$。\n- 案例 3（椭圆轨道，更大偏心率）：$v_{\\mathrm{init}} = 0.7\\, v_{\\mathrm{circ}}$，$\\Delta t = 86400\\ \\mathrm{s}$，$T = 100\\times 365.25\\times 86400\\ \\mathrm{s}$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的六个数字按以下顺序排列：$[\\varepsilon_{\\mathrm{Verlet,1}}, \\varepsilon_{\\mathrm{RK4,1}}, \\varepsilon_{\\mathrm{Verlet,2}}, \\varepsilon_{\\mathrm{RK4,2}}, \\varepsilon_{\\mathrm{Verlet,3}}, \\varepsilon_{\\mathrm{RK4,3}}]$。每个数字都用标准浮点表示法表示；科学记数法也是可接受的。结果是无量纲实数。", "solution": "该问题陈述已经过严格验证，被认定具有科学依据、问题适定且客观。它代表了计算物理学和天体力学中的一个标准练习，所有必要的参数和条件都已明确指定。不存在逻辑不一致、事实错误或含糊不清之处。因此，我们将着手提供一个完整的解决方案。\n\n该问题要求为平面内的经典牛顿二体问题实现并比较两种数值积分方案。所研究的系统是一个围绕固定中心质量体运行的测试粒子。其动力学由以下一阶常微分方程组控制：\n$$\n\\dot{\\mathbf{r}}(t) = \\mathbf{v}(t)\n$$\n$$\n\\dot{\\mathbf{v}}(t) = \\mathbf{a}(\\mathbf{r}(t)) = -\\frac{\\mu}{\\|\\mathbf{r}(t)\\|^3}\\,\\mathbf{r}(t)\n$$\n在此，$\\mathbf{r}(t)$ 是位置矢量，$\\mathbf{v}(t)$ 是速度矢量，$\\mu$ 是中心天体的标准引力参数。在精确的连续动力学中，一个关键的守恒量是比机械能：\n$$\nE = \\frac{1}{2}\\,\\|\\mathbf{v}\\|^2 - \\frac{\\mu}{\\|\\mathbf{r}\\|}\n$$\n数值积分器不会精确地守恒该量。我们的目标是量化两种不同方法的数值误差：速度 Verlet 算法和经典的四阶龙格-库塔方法。误差由 $N$ 个积分步后的绝对相对能量漂移 $\\varepsilon = \\left|\\frac{E_N - E_0}{|E_0|}\\right|$ 来衡量。\n\n我们将离散时间点定义为 $t_n = n \\Delta t$，其中 $\\Delta t$ 是恒定时间步长。系统在时间 $t_n$ 的状态是 $(\\mathbf{r}_n, \\mathbf{v}_n)$。\n\n**1. 速度 Verlet 积分器**\n\n速度 Verlet 算法是几何积分器家族的一员。它被特别设计成辛几何和时间可逆的，这使得它对于如本问题所考虑的哈密顿系统具有优异的长期稳定性。它不完全精确地守恒能量，但能量误差保持有界，并围绕初始值振荡，不显示长期漂移。该算法具有二阶精度。\n\n给定状态 $(\\mathbf{r}_n, \\mathbf{v}_n)$，计算 $(\\mathbf{r}_{n+1}, \\mathbf{v}_{n+1})$ 的一步速度 Verlet 算法按以下步骤进行：\n1.  计算当前位置的加速度：$\\mathbf{a}_n = \\mathbf{a}(\\mathbf{r}_n)$。\n2.  将速度更新半步：$\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{a}_n$。\n3.  使用此中间速度将位置更新一整步：$\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\Delta t \\, \\mathbf{v}_{n+1/2}$。\n4.  计算新位置的加速度：$\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{r}_{n+1})$。\n5.  将速度更新剩余的半步：$\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{\\Delta t}{2} \\mathbf{a}_{n+1}$。\n\n在实现时，这些步骤常被结合成以下形式：\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t + \\frac{1}{2} \\mathbf{a}(\\mathbf{r}_n) \\Delta t^2\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2} (\\mathbf{a}(\\mathbf{r}_n) + \\mathbf{a}(\\mathbf{r}_{n+1})) \\Delta t\n$$\n\n**2. 四阶龙格-库塔 (RK4) 积分器**\n\n经典的四阶龙格-库塔方法是一种广泛使用的显式积分器，以其在给定步长下的高精度而闻名。其局部截断误差的阶数为 $O(\\Delta t^5)$，全局误差的阶数为 $O(\\Delta t^4)$。然而，RK4 不是辛的。因此，对于哈密顿系统，它通常会在能量上引入一个系统性的或长期的漂移，这种漂移会随着长时间的积分而累积。\n\n对于我们的系统 $\\dot{\\mathbf{r}}=\\mathbf{v}$ 和 $\\dot{\\mathbf{v}}=\\mathbf{a}(\\mathbf{r})$，我们定义状态矢量 $\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$ 和函数 $\\mathbf{f}(\\mathbf{y}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{r}))$。从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的 RK4 更新为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n中间阶段 $\\mathbf{k}_i = (\\mathbf{k}_{ri}, \\mathbf{k}_{vi})$（对于 $i=1, 2, 3, 4$）计算如下：\n- 阶段 1：\n$$ \\mathbf{k}_{r1} = \\mathbf{v}_n \\qquad \\mathbf{k}_{v1} = \\mathbf{a}(\\mathbf{r}_n) $$\n- 阶段 2：\n$$ \\mathbf{k}_{r2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{v1} \\qquad \\mathbf{k}_{v2} = \\mathbf{a}\\left(\\mathbf{r}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{r1}\\right) $$\n- 阶段 3：\n$$ \\mathbf{k}_{r3} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{v2} \\qquad \\mathbf{k}_{v3} = \\mathbf{a}\\left(\\mathbf{r}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{r2}\\right) $$\n- 阶段 4：\n$$ \\mathbf{k}_{r4} = \\mathbf{v}_n + \\Delta t \\, \\mathbf{k}_{v3} \\qquad \\mathbf{k}_{v4} = \\mathbf{a}\\left(\\mathbf{r}_n + \\Delta t \\, \\mathbf{k}_{r3}\\right) $$\n然后，通过组合这些阶段计算位置和速度的最终更新：\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_{r1} + 2\\mathbf{k}_{r2} + 2\\mathbf{k}_{r3} + \\mathbf{k}_{r4})\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_{v1} + 2\\mathbf{k}_{v2} + 2\\mathbf{k}_{v3} + \\mathbf{k}_{v4})\n$$\n\n**3. 测试案例的执行**\n\n对于每个指定的测试案例，我们执行以下步骤：\n1.  确定物理和模拟参数：$\\mu = 1.32712440018 \\times 10^{20}\\ \\mathrm{m^3/s^2}$，$r_0 = 1.495978707 \\times 10^{11}\\ \\mathrm{m}$，以及案例特定的 $v_{\\mathrm{init}}$、$\\Delta t$ 和 $T$ 值。\n2.  计算圆形轨道速度 $v_{\\mathrm{circ}} = \\sqrt{\\mu/r_0}$ 和初始速度 $\\mathbf{v}_0 = (0, v_{\\mathrm{init}})$。初始位置为 $\\mathbf{r}_0 = (r_0, 0)$。\n3.  计算初始比能 $E_0 = E(\\mathbf{r}_0, \\mathbf{v}_0)$。对于束缚轨道，$E_0 < 0$。\n4.  确定积分步数 $N = \\lfloor T/\\Delta t \\rfloor$。\n5.  运行两个独立的模拟，一个使用速度 Verlet，一个使用 RK4。每个模拟都从 $(\\mathbf{r}_0, \\mathbf{v}_0)$ 开始，并精确运行 $N$ 步。\n6.  $N$ 步后，获得最终状态 $(\\mathbf{r}_{N,\\text{Verlet}}, \\mathbf{v}_{N,\\text{Verlet}})$ 和 $(\\mathbf{r}_{N,\\text{RK4}}, \\mathbf{v}_{N,\\text{RK4}})$。\n7.  计算最终能量 $E_{N,\\text{Verlet}}$ 和 $E_{N,\\text{RK4}}$。\n8.  为每种方法计算绝对相对能量漂移 $\\varepsilon$ 并存储结果。\n\n该比较将突显辛积分器与非辛积分器在哈密顿系统长期模拟中的根本区别。预计速度 Verlet 积分器在多个轨道周期内将展示出更优越的能量守恒特性，即使其局部误差比 RK4 更大；而 RK4 的更高阶精度可能会因能量中长期误差的累积而被削弱。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Velocity Verlet and RK4 integrators for the\n    Newtonian two-body problem, reporting the relative energy drift.\n    \"\"\"\n    # Physical and astronomical constants\n    MU_SUN = 1.32712440018e20  # Standard gravitational parameter of the Sun (m^3/s^2)\n    R0_EARTH = 1.495978707e11   # 1 Astronomical Unit (m)\n    DAY_S = 86400.0            # Seconds in one mean solar day\n    YEAR_S = 365.25 * DAY_S    # Seconds in one Julian year\n\n    # --- Core Physics and Numerical Functions ---\n\n    def acceleration(r_vec):\n        \"\"\"Computes gravitational acceleration vector.\"\"\"\n        dist = np.linalg.norm(r_vec)\n        if dist == 0:\n            # Avoid division by zero at the singularity, though it should not be reached.\n            return np.zeros_like(r_vec)\n        return -MU_SUN * r_vec / dist**3\n\n    def specific_energy(r_vec, v_vec):\n        \"\"\"Computes specific mechanical energy.\"\"\"\n        dist = np.linalg.norm(r_vec)\n        if dist == 0:\n            return np.inf\n        return 0.5 * np.dot(v_vec, v_vec) - MU_SUN / dist\n\n    def velocity_verlet_step(r, v, dt):\n        \"\"\"Performs a single step of the Velocity Verlet integration.\"\"\"\n        a_current = acceleration(r)\n        r_new = r + v * dt + 0.5 * a_current * dt**2\n        a_new = acceleration(r_new)\n        v_new = v + 0.5 * (a_current + a_new) * dt\n        return r_new, v_new\n\n    def rk4_step(r, v, dt):\n        \"\"\"Performs a single step of the RK4 integration.\"\"\"\n        # k1\n        k1_r = v\n        k1_v = acceleration(r)\n\n        # k2\n        r2 = r + 0.5 * dt * k1_r\n        k2_r = v + 0.5 * dt * k1_v\n        k2_v = acceleration(r2)\n\n        # k3\n        r3 = r + 0.5 * dt * k2_r\n        k3_r = v + 0.5 * dt * k2_v\n        k3_v = acceleration(r3)\n\n        # k4\n        r4 = r + dt * k3_r\n        k4_r = v + dt * k3_v\n        k4_v = acceleration(r4)\n\n        # Combine stages\n        r_new = r + (dt / 6.0) * (k1_r + 2*k2_r + 2*k3_r + k4_r)\n        v_new = v + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n        return r_new, v_new\n\n    # --- Test Suite Setup ---\n    v_circ = np.sqrt(MU_SUN / R0_EARTH)\n\n    test_cases = [\n        # Case 1 (circular, fine step)\n        {'v_init_factor': 1.0, 'dt': 1.0 * DAY_S, 'T': 50.0 * YEAR_S},\n        # Case 2 (circular, coarse step)\n        {'v_init_factor': 1.0, 'dt': 5.0 * DAY_S, 'T': 200.0 * YEAR_S},\n        # Case 3 (elliptical, more eccentric)\n        {'v_init_factor': 0.7, 'dt': 1.0 * DAY_S, 'T': 100.0 * YEAR_S},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # --- Simulation Setup for the current case ---\n        v_init = case['v_init_factor'] * v_circ\n        dt = case['dt']\n        T = case['T']\n        \n        # Initial conditions\n        r0 = np.array([R0_EARTH, 0.0])\n        v0 = np.array([0.0, v_init])\n        \n        num_steps = int(T / dt) # As per problem spec: N = floor(T/dt)\n        \n        # Initial energy\n        E0 = specific_energy(r0, v0)\n\n        # --- Velocity Verlet Simulation ---\n        r_v, v_v = r0.copy(), v0.copy()\n        for _ in range(num_steps):\n            r_v, v_v = velocity_verlet_step(r_v, v_v, dt)\n        \n        E_N_verlet = specific_energy(r_v, v_v)\n        epsilon_verlet = abs((E_N_verlet - E0) / E0)\n        results.append(epsilon_verlet)\n        \n        # --- RK4 Simulation ---\n        r_rk, v_rk = r0.copy(), v0.copy()\n        for _ in range(num_steps):\n            r_rk, v_rk = rk4_step(r_rk, v_rk, dt)\n\n        E_N_rk4 = specific_energy(r_rk, v_rk)\n        epsilon_rk4 = abs((E_N_rk4 - E0) / E0)\n        results.append(epsilon_rk4)\n\n    # --- Final Output ---\n    # Convert results to string representation for printing\n    result_str = [f\"{res:.10e}\" for res in results]\n    print(f\"[{','.join(result_str)}]\")\n\nsolve()\n```", "id": "2446756"}, {"introduction": "上一个练习确立了 Verlet 算法在长时程能量稳定性方面的优势，但这并不意味着它是万无一失的。这个实践将引导我们探索一个关键的警示：即使是理论上优越的算法也存在实际的局限性 [@problem_id:2446795]。我们将研究一种称为“数值共振”的现象，当积分的时间步长 $\\Delta t$ 与系统的固有振动频率 $\\omega$ 不恰当地耦合时，即使是辛积分器也会变得不稳定。理解并能够预测这种稳定性边界（由条件 $|\\omega \\Delta t| \\le 2$ 给出）对于在任何真实世界的模拟中选择一个安全有效的时间步长都至关重要。", "problem": "设计并实现一个完整程序，用于探测一个时间可逆积分器在处理一维经典谐振子（其哈密顿量为 $H(x,p)=\\dfrac{p^2}{2m}+\\dfrac{1}{2}m\\omega^2 x^2$）时，因离散时间步长共振而导致的性能下降问题。\n\n使用无量纲单位，设 $m=1$，并以不带物理单位的形式表示所有量。角度和角频率应以弧度为单位，时间单位与角频率的无量纲单位相同（因此 $\\omega$ 的单位是弧度/单位时间）。该振子遵循哈密顿方程 $\\dot{x}=p/m$ 和 $\\dot{p}=-m\\omega^2 x$。\n\n为了在不同实现中产生一致且可测试的结果，请使用以下关于位置的时间可逆二阶差分方程，在均匀时间网格 $t_n=n\\,\\Delta t$ 上演化系统：\n$$\nx_{n+1}=2x_n-x_{n-1}-(\\omega\\Delta t)^2\\,x_n,\n$$\n其初始数据在 $t_0=0$ 时给定为 $x_0=x(0)$ 和 $v_0=\\dot{x}(0)$。通过以下方式初始化序列：\n$$\nx_1=x_0+\\Delta t\\,v_0-\\tfrac{1}{2}(\\omega\\Delta t)^2\\,x_0.\n$$\n在每个网格索引 $n\\ge 1$ 处，通过中心差分定义离散速度：\n$$\nv_n=\\frac{x_{n+1}-x_{n-1}}{2\\Delta t}.\n$$\n将索引 $n$ 处的离散能量定义为：\n$$\nE_n=\\dfrac{1}{2}v_n^2+\\dfrac{1}{2}\\omega^2 x_n^2,\n$$\n并将参考能量 $E_0$ 定义为精确的初始值：\n$$\nE_0=\\dfrac{1}{2}v_0^2+\\dfrac{1}{2}\\omega^2 x_0^2.\n$$\n对于一个固定的最终时间 $T_{\\mathrm{final}}$，将序列推进到满足 $N\\,\\Delta t\\le T_{\\mathrm{final}}$ 的最大整数索引 $N$。在索引 $n=1,2,\\ldots,N-1$ 上，测量最大相对能量偏差：\n$$\n\\varepsilon_{\\max}=\\max_{1\\le n\\le N-1}\\frac{|E_n-E_0|}{E_0}.\n$$\n为了稳健地检测由时间步长共振引起的数值不稳定性，请采纳以下发散约定：如果在任何步骤 $n$ 中，量值 $|x_n|$ 超过 $10^6$，则终止积分，并为该测试用例报告标量值 $10^6$ 以代替 $\\varepsilon_{\\max}$。\n\n您的程序必须为以下测试套件评估 $\\varepsilon_{\\max}$，该套件固定了振子参数，仅改变时间步长：\n- 自然频率 $\\omega=1$。\n- 初始条件 $x_0=1$ 和 $v_0=0$。\n- 最终时间 $T_{\\mathrm{final}}=200\\cdot 2\\pi$。\n- 时间步长 $\\Delta t$ 在集合 $\\{\\;0.1,\\;1.0,\\;1.9,\\;2.0,\\;2.1\\;\\}$ 中。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其顺序与所列的时间步长相对应。列表中的每个数字必须是十进制浮点值，四舍五入到 $6$ 位有效数字，并根据需要使用定点或科学记数法表示。对于触发发散约定的情况，按规定输出四舍五入到 $6$ 位有效数字的 $10^6$。输出格式必须严格为\n[res_0,res_1,res_2,res_3,res_4]\n，不含空格，且顺序与上述时间步长相同。", "solution": "问题陈述是有效的。这是一个适定且有科学依据的计算物理学练习，旨在研究用于经典谐振子的时间可逆积分器的数值稳定性。所有参数、方程和评估标准都清晰而精确地给出，足以得出一个唯一且可验证的解。\n\n所考虑的系统是一个一维谐振子，其哈密顿量为 $H(x,p)=\\dfrac{p^2}{2m}+\\dfrac{1}{2}m\\omega^2 x^2$。在无量纲单位和质量 $m=1$ 的情况下，哈密顿方程简化为 $\\dot{x}=p$ 和 $\\dot{p}=-\\omega^2 x$，两者结合得到标准的二阶常微分方程 $\\ddot{x} + \\omega^2 x = 0$。\n\n数值积分格式由时刻 $t_n = n\\Delta t$ 时位置 $x_n$ 的二阶差分方程指定：\n$$\nx_{n+1}=2x_n-x_{n-1}-(\\omega\\Delta t)^2\\,x_n\n$$\n这是一个标准的显式时间可逆积分器，称为 Størmer-Verlet 方法（以其位置Verlet形式）。其主要优点是能够极好地长期保持一个伪哈密顿量，这使得稳定振荡的能量误差有界，而不同于像 Runge-Kutta 等非辛方法常表现出的长期漂移。\n\n这个线性差分格式的稳定性至关重要。我们可以通过代入 $x_n = z^n$ 形式的试探解来分析它，从而得到特征方程：\n$$\nz^2 - \\left(2 - (\\omega\\Delta t)^2\\right) z + 1 = 0\n$$\n为使数值解保持有界，该二次方程的根 $z$ 必须位于复平面的单位圆上，即 $|z|=1$。根由以下公式给出：\n$$\nz_{\\pm} = \\frac{\\left(2 - (\\omega\\Delta t)^2\\right) \\pm \\sqrt{\\left(2 - (\\omega\\Delta t)^2\\right)^2 - 4}}{2}\n$$\n条件 $|z|=1$ 要求判别式为非正：\n$$\n\\left(2 - (\\omega\\Delta t)^2\\right)^2 - 4 \\le 0 \\implies -2 \\le 2 - (\\omega\\Delta t)^2 \\le 2\n$$\n这可以简化为 $(\\omega\\Delta t)^2 \\le 4$，即 Verlet 方法著名的稳定性条件：\n$$\n|\\omega \\Delta t| \\le 2\n$$\n当 $|\\omega \\Delta t| > 2$ 时，一个根的模大于1，导致数值解指数发散。当 $|\\omega \\Delta t| = 2$ 时是数值共振。此时，特征方程在 $z=-1$ 处有一个二重根，通解形式为 $x_n = (A + Bn)(-1)^n$，预示着振幅会线性增长。\n\n问题要求对 $\\omega=1$ 和几个不同的 $\\Delta t$ 值进行评估：\n1.  $\\Delta t \\in \\{0.1, 1.0, 1.9\\}$: 此处，$|\\omega \\Delta t| < 2$，因此积分处于稳定区域。我们预期离散能量 $E_n$ 会出现有界的振荡误差。该误差的量级预计会随着 $\\Delta t$ 的增大而增大。\n2.  $\\Delta t = 2.0$: 此处，$|\\omega \\Delta t| = 2$，即共振条件。然而，给定的特定初始化方法 $x_1=x_0+\\Delta t\\,v_0-\\tfrac{1}{2}(\\omega\\Delta t)^2\\,x_0$，结合初始条件 $x_0=1, v_0=0$，导致 $x_1 = 1 - \\frac{1}{2}(1 \\cdot 2)^2(1) = 1-2 = -1$。后续序列变为 $x_n = (-1)^n$。对于这个特殊的非一般性轨道，离散速度 $v_n = (x_{n+1}-x_{n-1})/(2\\Delta t)$ 恒为零，离散能量 $E_n$ 始终精确等于初始能量 $E_0$。因此，最大相对能量偏差 $\\varepsilon_{\\max}$ 将精确为零。\n3.  $\\Delta t = 2.1$: 此处，$|\\omega \\Delta t| > 2$，因此积分不稳定。位置 $x_n$ 将呈指数级增长，预计模拟将因触发发散条件 $|x_n| > 10^6$ 而终止。\n\n该解是通过直接转换给定算法来实现的。对于每个指定的 $\\Delta t$，步骤如下：\n- 使用给定的参数初始化系统：$\\omega=1, x_0=1, v_0=0$。\n- 计算总步数 $N = \\lfloor T_{\\mathrm{final}} / \\Delta t \\rfloor$，其中 $T_{\\mathrm{final}}=400\\pi$。\n- 计算参考能量 $E_0 = \\frac{1}{2}v_0^2+\\frac{1}{2}\\omega^2 x_0^2 = 0.5$。\n- 根据问题说明初始化前两个位置 $x_0$ 和 $x_1$。\n- 从 $n=1$ 迭代到 $N-1$：\n    - 使用 Verlet 更新规则计算下一个位置 $x_{n+1}$。\n    - 检查是否发散。如果 $|x_n| > 10^6$，则此 $\\Delta t$ 的误差设为 $10^6$，并终止此情况的模拟。\n    - 使用中心差分公式计算离散速度 $v_n$。\n    - 计算离散能量 $E_n$。\n    - 更新迄今为止观测到的最大相对能量偏差 $\\varepsilon_{\\max}$。\n    - 为下一次迭代更新位置。\n- 存储当前 $\\Delta t$ 的最终 $\\varepsilon_{\\max}$ 值。\n最终的结果列表随后按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_num(n):\n    \"\"\"\n    Formats a number to 6 significant figures, with special handling\n    for the divergence value 1.0e6 to ensure it is represented\n    with 6 significant figures in scientific notation.\n    \"\"\"\n    if n == 1.0e6:\n        return \"1.00000e+06\"\n    return f\"{n:.6g}\"\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting time-step resonance for a harmonic oscillator\n    integrated with the Størmer-Verlet method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.1, 1.0, 1.9, 2.0, 2.1]\n\n    # Fixed parameters for the oscillator\n    omega = 1.0\n    x0 = 1.0\n    v0 = 0.0\n    T_final = 200.0 * 2.0 * np.pi\n    divergence_threshold = 1.0e6\n\n    results = []\n\n    # Calculate exact initial energy\n    E0 = 0.5 * v0**2 + 0.5 * omega**2 * x0**2\n    # Prevent division by zero if E0 is zero, although not the case here.\n    if E0 == 0:\n        E0 = 1.0 \n\n    for dt in test_cases:\n        # Determine the total number of steps\n        N = int(T_final / dt)\n\n        # Initialize variables for the simulation\n        max_rel_err = 0.0\n        diverged = False\n\n        # Set initial positions\n        x_prev = x0\n        \n        # Calculate x1 using the specified second-order initialization\n        wdt2 = (omega * dt)**2\n        x_curr = x0 + dt * v0 - 0.5 * wdt2 * x0\n\n        # Time-stepping loop from n=1 to N-1 to compute E_n up to E_{N-1}\n        for n in range(1, N):\n            # Check for divergence\n            if abs(x_curr) > divergence_threshold:\n                max_rel_err = divergence_threshold\n                diverged = True\n                break\n            \n            # Calculate next position using the Verlet update rule\n            x_next = (2.0 - wdt2) * x_curr - x_prev\n            \n            # Calculate discrete velocity and energy at step n\n            # v_n is defined by the centered difference at time t_n\n            v_n = (x_next - x_prev) / (2.0 * dt)\n            E_n = 0.5 * v_n**2 + 0.5 * omega**2 * x_curr**2\n            \n            # Calculate relative energy deviation and update the maximum\n            rel_err = abs(E_n - E0) / E0\n            if rel_err > max_rel_err:\n                max_rel_err = rel_err\n            \n            # Update positions for the next step\n            x_prev = x_curr\n            x_curr = x_next\n        \n        if not diverged and N > 0 and abs(x_curr) > divergence_threshold:\n            # Final check in case the last computed step diverged\n            max_rel_err = divergence_threshold\n\n        results.append(max_rel_err)\n\n    # Format results to 6 significant figures\n    formatted_results = [format_num(r) for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2446795"}, {"introduction": "在掌握了辛积分器的核心优势和局限性之后，我们的最后一个练习将深入探讨一个微妙但关键的实现细节。我们将注意力转向位置 Verlet 算法，这是一种需要为第一步积分进行“启动（bootstrapping）”的常见变体 [@problem_id:2446800]。本练习旨在比较两种不同的启动方法——一种是简单的欧拉法，另一种是与算法阶数一致的二阶泰勒展开法。通过这个实践，你将发现，即使是初始步骤中的一个看似微小的选择，也会对整个模拟过程的精度和能量守恒产生深远影响，从而深刻体会到算法实现一致性的重要性。", "problem": "构造一个完整、可运行的程序，用于比较在使用时间反演位置Verlet积分器传播一维经典谐振子时，第一步构造（引导）方法的选择对长期数值轨迹的影响。考虑一个质量为 $m$ 的质点在势 $V(x) = \\tfrac{1}{2} k x^{2}$ 中运动，因此其加速度为 $a(x) = -\\tfrac{k}{m} x$。精确角频率为 $\\omega = \\sqrt{\\tfrac{k}{m}}$，对于初始条件 $x(0)=x_{0}$ 和 $v(0)=v_{0}$，其精确解为\n$$\nx_{\\mathrm{exact}}(t) = x_{0} \\cos(\\omega t) + \\frac{v_{0}}{\\omega} \\sin(\\omega t),\n\\qquad\nv_{\\mathrm{exact}}(t) = -x_{0}\\,\\omega \\sin(\\omega t) + v_{0} \\cos(\\omega t).\n$$\n所有角度必须以弧度为单位。所有物理量必须使用国际单位制（SI）表示：位置以米为单位，速度以米每秒为单位，质量以千克为单位，刚度以牛顿每米为单位，时间以秒为单位。在时间 $t$ 的机械能为\n$$\nE(t) = \\tfrac{1}{2} m\\, v(t)^{2} + \\tfrac{1}{2} k\\, x(t)^{2}.\n$$\n对于具有固定时间步长 $\\Delta t$ 的离散时间 $t_{n} = n\\,\\Delta t$，使用位置Verlet递推关系：\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} + a(x_{n})\\,(\\Delta t)^{2}, \\quad \\text{其中 } a(x_{n}) = -\\frac{k}{m}\\,x_{n}.\n$$\n此更新需要给定 $x_{0}$ 和 $v_{0}$ 后的第一步 $x_{1}$。比较以下两种第一步构造方法：\n- Euler 引导：$x_{1}^{\\mathrm{E}} = x_{0} + v_{0}\\,\\Delta t$。\n- 二阶 Taylor 引导：$x_{1}^{\\mathrm{T}} = x_{0} + v_{0}\\,\\Delta t + \\tfrac{1}{2}\\,a(x_{0})\\,(\\Delta t)^{2}$。\n\n对于给定的参数集，使用每种引导方法模拟 $N$ 步，直到时间 $T = N\\,\\Delta t$，并为每种引导方法计算以下两个无量纲诊断量：\n- 最终相对位置误差，定义为\n$$\n\\varepsilon_{x} = \\frac{\\left|x_{N} - x_{\\mathrm{exact}}(T)\\right|}{A}, \\quad \\text{其中 } A = \\sqrt{x_{0}^{2} + \\left(\\frac{v_{0}}{\\omega}\\right)^{2}}.\n$$\n- 轨迹上的最大相对能量偏差，定义为\n$$\n\\varepsilon_{E}^{\\max} = \\max_{1 \\le n \\le N-1} \\frac{\\left|E_{n} - E_{0}\\right|}{E_{0}},\n$$\n其中 $E_{0} = \\tfrac{1}{2} m\\, v_{0}^{2} + \\tfrac{1}{2} k\\, x_{0}^{2}$ 且 $E_{n} = \\tfrac{1}{2} m\\, v_{n}^{2} + \\tfrac{1}{2} k\\, x_{n}^{2}$，$v_{n}$ 是通过中心有限差分 $v_{n} = \\dfrac{x_{n+1} - x_{n-1}}{2\\,\\Delta t}$ (对于 $1 \\le n \\le N-1$) 得到的。如果 $E_{0} = 0$，则定义 $\\varepsilon_{E}^{\\max} = 0$。\n\n您的程序必须实现此设置，并为以下以国际单位制（SI）表示的参数集测试套件生成结果：\n- 测试集 A (理想情况)：$m = 1$, $k = 1$, $x_{0} = 1$, $v_{0} = 0$, $\\Delta t = 0.1$, $N = 10000$。\n- 测试集 B (接近离散方案的稳定性边界)：$m = 1$, $k = 25$, $x_{0} = 1$, $v_{0} = 0.5$, $\\Delta t = 0.39$, $N = 8000$。\n- 测试集 C (纯动能启动)：$m = 1$, $k = 1$, $x_{0} = 0$, $v_{0} = 1$, $\\Delta t = 0.05$, $N = 20000$。\n\n对于每个测试集，按以下顺序输出包含四个数字的列表：\n$[\\varepsilon_{x}^{\\mathrm{E}}, \\varepsilon_{x}^{\\mathrm{T}}, \\varepsilon_{E,\\mathrm{E}}^{\\max}, \\varepsilon_{E,\\mathrm{T}}^{\\max}]$，其中上标 $\\mathrm{E}$ 和 $\\mathrm{T}$ 分别代表 Euler 引导和 Taylor 引导。\n程序的最终输出必须为单行，包含所有三个测试集的结果，形式为这些列表的逗号分隔列表，不含空格，例如：\n$[[a_{1},a_{2},a_{3},a_{4}],[b_{1},b_{2},b_{3},b_{4}],[c_{1},c_{2},c_{3},c_{4}]]$。\n每个数字必须以至少 $6$ 位有效数字的小数形式打印。所有报告的诊断量都是无量纲的，必须以小数形式打印（不要使用百分号）。", "solution": "问题陈述已经过验证，被认为是科学上合理、适定且无歧义的。这是一个计算物理学中的标准练习，适合进行严格分析。我们现在开始进行求解。\n\n该问题要求对应用于一维谐振子的位置Verlet积分器的两种引导方法进行比较研究。系统由一个质量为 $m$ 的物体在势 $V(x) = \\frac{1}{2} k x^2$ 中运动定义，其运动方程为 $\\ddot{x} = -\\frac{k}{m} x$。动力学特性由自然角频率 $\\omega = \\sqrt{k/m}$ 决定。\n\n位置Verlet算法是一种二阶、时间反演且辛的积分器。其对于离散时间步 $t_n = n \\Delta t$ 的递推关系由下式给出\n$$\nx_{n+1} = 2 x_n - x_{n-1} + a(x_n) (\\Delta t)^2,\n$$\n其中 $x_n \\approx x(t_n)$，$a(x_n) = -\\frac{k}{m} x_n$ 是在位置 $x_n$ 处的加速度。这是一个三项递推关系，意味着计算第 $n+1$ 步的位置 $x_{n+1}$ 需要前面两步的位置 $x_n$ 和 $x_{n-1}$。为启动积分，我们给定 $t=0$ 时的初始状态 $(x_0, v_0)$。由此我们有 $x_0$，但我们需要一个 $x_1$ 的值来开始对于 $n \\ge 1$ 的迭代过程。$x_1$ 的选择就是引导问题。\n\n该问题提出了两种确定 $x_1$ 的方法：\n\n1.  **Euler 引导**：$x_1^{\\mathrm{E}} = x_0 + v_0 \\Delta t$。这是一个针对位置的一阶前向 Euler 步。\n2.  **二阶 Taylor 引导**：$x_1^{\\mathrm{T}} = x_0 + v_0 \\Delta t + \\frac{1}{2} a(x_0) (\\Delta t)^2$。这对应于位置 $x(\\Delta t)$ 的二阶 Taylor 级数展开。\n\nVerlet 积分器的理论基础在于围绕时间 $t_n$ 的两个 Taylor 级数展开式之和：\n$$\nx(t_n + \\Delta t) = x(t_n) + \\dot{x}(t_n)\\Delta t + \\frac{1}{2}\\ddot{x}(t_n)(\\Delta t)^2 + \\frac{1}{6}\\dddot{x}(t_n)(\\Delta t)^3 + \\mathcal{O}((\\Delta t)^4)\n$$\n$$\nx(t_n - \\Delta t) = x(t_n) - \\dot{x}(t_n)\\Delta t + \\frac{1}{2}\\ddot{x}(t_n)(\\Delta t)^2 - \\frac{1}{6}\\dddot{x}(t_n)(\\Delta t)^3 + \\mathcal{O}((\\Delta t)^4)\n$$\n将这两个方程相加可以消去奇数次幂的导数项，得到：\n$$\nx(t_n + \\Delta t) + x(t_n - \\Delta t) = 2x(t_n) + \\ddot{x}(t_n)(\\Delta t)^2 + \\mathcal{O}((\\Delta t)^4)\n$$\n将 $x_{n \\pm 1}$ 视为 $x(t_n \\pm \\Delta t)$，将 $a(x_n)$ 视为 $\\ddot{x}(t_n)$，我们便得到了位置Verlet公式。该方法的局部截断误差为 $\\mathcal{O}((\\Delta t)^4)$，从而导致全局误差为 $\\mathcal{O}((\\Delta t)^2)$。\n\n关键在于，此推导揭示了该方法的精度和时间反演性等理想属性都依赖于这种对称结构。必须谨慎选择引导步骤，以免破坏这种结构。\n\n用于 $x_1$ 的二阶 Taylor 引导方法，\n$$\nx_1^\\mathrm{T} = x_0 + v_0 \\Delta t + \\frac{1}{2}a(x_0)(\\Delta t)^2,\n$$\n是直接从 $x(\\Delta t)$ 的二阶 Taylor 展开式推导出来的。这与 Verlet 积分器本身的阶数是一致的。\n\n相比之下，Euler 引导，\n$$\nx_1^\\mathrm{E} = x_0 + v_0 \\Delta t,\n$$\n仅为一阶近似。它在第一步就引入了量级为 $\\frac{1}{2}a(x_0)(\\Delta t)^2$ 的误差。这个初始误差的阶数低于与积分器相符的阶数，它会在整个模拟过程中传播，并预计会降低整体精度，特别是长期能量守恒性。Verlet 方法因其出色的长期能量稳定性（数值能量不会系统性漂移，而是在真实值附近振荡）而备受推崇。不一致的引导方法会破坏这一特性。\n\n对于初始位置处于平衡点 $x_0=0$ 的特殊情况，初始加速度也为零 $a(x_0)=0$。在这种情况下，项 $\\frac{1}{2} a(x_0) (\\Delta t)^2$ 消失，两种引导方法产生相同的结果：$x_1^{\\mathrm{E}} = x_1^{\\mathrm{T}} = v_0 \\Delta t$。因此，对于 $x_0=0$ 的测试集 C，两种引导方法的数值轨迹和所有派生的诊断量必须完全相同。\n\n实现将按以下方式进行：将构造一个通用函数，使用位置Verlet算法传播轨迹 $N$ 步。该函数将接受物理参数（$m, k, x_0, v_0, \\Delta t, N$）和一个用于选择引导方法的标志。对于三个测试集中的每一个，此模拟将运行两次，每种引导方法一次。\n\n在每次模拟运行（生成位置轨迹 $\\{x_n\\}_{n=0}^N$）之后，将计算所需的诊断量。\n- 最终相对位置误差 $\\varepsilon_x$ 需要计算在时间 $T = N \\Delta t$ 时的精确位置，由 $x_{\\mathrm{exact}}(T) = x_0 \\cos(\\omega T) + \\frac{v_0}{\\omega} \\sin(\\omega T)$ 给出，以及振幅 $A = \\sqrt{x_0^2 + (v_0/\\omega)^2}$。误差则为 $\\varepsilon_x = |x_N - x_{\\mathrm{exact}}(T)| / A$。\n- 最大相对能量偏差 $\\varepsilon_E^{\\max}$ 需要计算在 $n \\in [1, N-1]$ 范围内的数值速度 $v_n$ 和能量 $E_n$。速度使用中心差分公式 $v_n = \\frac{x_{n+1} - x_{n-1}}{2 \\Delta t}$ 计算，这与 Verlet 方案的时间反演性一致。每一步的能量为 $E_n = \\frac{1}{2}mv_n^2 + \\frac{1}{2}kx_n^2$。然后通过取轨迹上 $|E_n - E_0|/E_0$ 的最大值来找到该诊断量，其中 $E_0 = \\frac{1}{2}mv_0^2 + \\frac{1}{2}kx_0^2$。\n\n每个测试集的计算结果将按规定格式化和呈现。预期的结果是，Taylor 引导将始终产生更小的误差，尤其是在能量偏差方面，除非在像测试集 C 这样两种方法在数学上等效的情况下。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n\n    # Test cases are defined as tuples: (m, k, x0, v0, dt, N)\n    test_cases = [\n        # Test set A (happy path)\n        (1.0, 1.0, 1.0, 0.0, 0.1, 10000),\n        # Test set B (near-stability edge)\n        (1.0, 25.0, 1.0, 0.5, 0.39, 8000),\n        # Test set C (purely kinetic start)\n        (1.0, 1.0, 0.0, 1.0, 0.05, 20000),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        m, k, x0, v0, dt, N = params\n        \n        # Run with Euler bootstrap\n        x_euler = propagate_trajectory(m, k, x0, v0, dt, N, 'euler')\n        eps_x_euler, eps_E_max_euler = compute_diagnostics(m, k, x0, v0, dt, N, x_euler)\n\n        # Run with Taylor bootstrap\n        x_taylor = propagate_trajectory(m, k, x0, v0, dt, N, 'taylor')\n        eps_x_taylor, eps_E_max_taylor = compute_diagnostics(m, k, x0, v0, dt, N, x_taylor)\n        \n        case_results = [eps_x_euler, eps_x_taylor, eps_E_max_euler, eps_E_max_taylor]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    formatted_case_results = []\n    for res_list in all_results:\n        # Use scientific notation to ensure at least 6 significant digits\n        formatted_list = [f\"{v:.15e}\" for v in res_list]\n        formatted_case_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output)\n\ndef propagate_trajectory(m, k, x0, v0, dt, N, bootstrap_method):\n    \"\"\"\n    Generates a trajectory using the position Verlet integrator.\n\n    Args:\n        m (float): Mass.\n        k (float): Spring constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        N (int): Number of steps.\n        bootstrap_method (str): 'euler' or 'taylor'.\n\n    Returns:\n        np.array: Array of positions [x_0, x_1, ..., x_N].\n    \"\"\"\n    x = np.zeros(N + 1)\n    x[0] = x0\n    \n    # Acceleration function\n    accel_factor = -k / m\n    def a(pos):\n        return accel_factor * pos\n\n    # First step (bootstrapping)\n    if bootstrap_method == 'euler':\n        x[1] = x0 + v0 * dt\n    elif bootstrap_method == 'taylor':\n        a0 = a(x0)\n        x[1] = x0 + v0 * dt + 0.5 * a0 * dt**2\n    else:\n        raise ValueError(\"Invalid bootstrap method specified.\")\n\n    # Main integration loop\n    dt_sq = dt**2\n    for n in range(1, N):\n        x[n+1] = 2 * x[n] - x[n-1] + a(x[n]) * dt_sq\n        \n    return x\n\ndef compute_diagnostics(m, k, x0, v0, dt, N, x_trajectory):\n    \"\"\"\n    Computes final position error and max energy deviation.\n\n    Args:\n        m (float): Mass.\n        k (float): Spring constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        N (int): Number of steps.\n        x_trajectory (np.array): Position trajectory.\n\n    Returns:\n        tuple: (eps_x, eps_E_max)\n    \"\"\"\n    omega = np.sqrt(k / m)\n\n    # 1. Final relative position error (eps_x)\n    T = N * dt\n    x_exact_T = x0 * np.cos(omega * T) + (v0 / omega) * np.sin(omega * T)\n    \n    amp_sq_term_v = v0 / omega\n    amplitude = np.sqrt(x0**2 + amp_sq_term_v**2)\n    \n    x_N = x_trajectory[N]\n    \n    if amplitude == 0.0:\n        # Trivial case: x0=0, v0=0. System is static.\n        eps_x = 0.0\n    else:\n        eps_x = np.abs(x_N - x_exact_T) / amplitude\n\n    # 2. Maximum relative energy deviation (eps_E_max)\n    E0 = 0.5 * m * v0**2 + 0.5 * k * x0**2\n    \n    if E0 == 0.0:\n        return eps_x, 0.0\n\n    max_rel_E_dev = 0.0\n    # Loop from n=1 to N-1\n    for n in range(1, N):\n        # Centered difference for velocity v_n\n        v_n = (x_trajectory[n+1] - x_trajectory[n-1]) / (2 * dt)\n        \n        # Energy E_n\n        E_n = 0.5 * m * v_n**2 + 0.5 * k * x_trajectory[n]**2\n        \n        rel_E_dev = np.abs(E_n - E0) / E0\n        if rel_E_dev > max_rel_E_dev:\n            max_rel_E_dev = rel_E_dev\n            \n    eps_E_max = max_rel_E_dev\n    \n    return eps_x, eps_E_max\n\nsolve()\n\n```", "id": "2446800"}]}