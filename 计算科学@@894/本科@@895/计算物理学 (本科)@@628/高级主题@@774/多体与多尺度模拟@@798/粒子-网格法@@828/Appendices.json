{"hands_on_practices": [{"introduction": "第一个实践是我们动手探索的基石。你将从头开始实现一个完整的一维静电粒子模拟（PIC）程序，涵盖整个计算循环。通过加入一个光致电离源项，我们超越了简单的粒子动力学，模拟一个更真实的物理系统——等离子体的动态生成 [@problem_id:2424112]。完成这项练习将为你深入理解 PIC 模拟的基本机制奠定坚实的基础。", "problem": "实现一种一维静电粒子云网格（PIC）方法，该方法具有周期性边界条件，并包含一个光电离源项，该源项从静止、均匀的中性气体中在空间上均匀地产生新的电子-离子对。该算法必须是自洽的：电荷被沉积到网格上，电场由 Gauss 定律得到，粒子由专用于静电学的 Lorentz 力推动。新的电子-离子对根据确定性速率定律和固定的随机种子，在每个时间步随机地创建。\n\n基本原理：\n- 对每个带电粒子使用 Newton 第二定律 $m \\, dv/dt = q \\, E(x,t)$ 和运动学 $dx/dt = v$。\n- 在静电条件下，对长度为 $L$ 的域使用一维 Gauss 定律 $\\partial E/\\partial x = \\rho/\\varepsilon_0$，并施加周期性边界条件。\n- 光电离的源项是一个均匀的体积对生成率 $S$，定义为 $S = \\sigma \\, \\Phi \\, n_n$，其中 $\\sigma$ 是光电离截面，$\\Phi$ 是光子通量，$n_n$ 是中性气体数密度。在每个时间步 $\\Delta t$ 内，在长度为 $L$ 的域中（假设单位横截面积），期望生成的真实粒子对数量为 $S \\, L \\, \\Delta t$。\n- 使用权重为 $W$ 的宏粒子，使得每个宏粒子代表 $W$ 个真实粒子。因此，每个时间步期望生成的宏粒子对数量为 $\\mu = (S \\, L \\, \\Delta t)/W$。\n\n数值规格：\n- 用 $N_g$ 个均匀分布的网格节点和周期性边界条件来表示长度为 $L$ 的一维域。\n- 使用一致的一阶（细胞内云）格式，从电子和离子宏粒子中将电荷密度 $\\rho(x)$ 沉积到网格上。对于电子，每个宏粒子的电荷为 $q_e = -e \\, W$；对于离子，每个宏粒子的电荷为 $q_i = +e \\, W$，其中 $e$ 是基本电荷。除以单元体积 $V_{\\text{cell}} = \\Delta x$（单位横截面积），使得 $\\rho$ 的单位为 $\\mathrm{C/m^3}$。\n- 在周期性边界条件下，求解电场 $E(x)$ 使其满足 $\\partial E/\\partial x = \\rho/\\varepsilon_0$。通过强制 $E(x)$ 的平均值为零来维持周期性可解性条件。\n- 使用与电荷沉积相同的的一阶形函数，将 $E(x)$ 从网格插值回粒子位置。\n- 使用时间中心蛙跳格式来推进粒子的速度和位置：\n  - $v^{n+1/2} = v^{n-1/2} + (q/m) \\, E(x^n) \\, \\Delta t$\n  - $x^{n+1} = x^n + v^{n+1/2} \\, \\Delta t$\n  对位置施加周期性边界条件。\n- 在每个时间步，创建新的宏电子-离子对：\n  - 计算 $\\mu = (S \\, L \\, \\Delta t)/W$，其中 $S = \\sigma \\, \\Phi \\, n_n$。\n  - 通过概率取整生成新宏粒子对的实际数量：令 $n_{\\text{base}} = \\lfloor \\mu \\rfloor$ 且 $f = \\mu - \\lfloor \\mu \\rfloor$。以概率 $f$ 额外增加一对。为新粒子对使用在 $[0,L)$ 上独立、均匀分布的随机位置，并将其初始蛙跳速度设置为零。使用固定的伪随机数生成器种子 $42$，以确保结果是可复现的。\n\n要使用的物理常数（国际单位制）：\n- 基本电荷 $e = 1.602176634 \\times 10^{-19}\\,\\mathrm{C}$。\n- 电子质量 $m_e = 9.1093837015 \\times 10^{-31}\\,\\mathrm{kg}$。\n- 离子质量 $m_i = 6.6335209 \\times 10^{-26}\\,\\mathrm{kg}$（代表单电离氩）。\n- 真空介电常数 $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}\\,\\mathrm{F/m}$。\n\n初始化和边界条件：\n- 开始时域内没有带电粒子。\n- 场和粒子均采用周期性边界条件。\n- 使用单位横截面积，因此有效域体积为 $L$。\n\n任务：\n- 实现上述算法，并针对下面的指定测试套件运行它。\n- 对于每个测试用例，在精确推进 $N_t$ 个时间步后，报告存在的宏电子总数（一个整数）。无需报告位置、速度或场。\n- 该问题不涉及角度。\n- 最终结果中不需要物理单位，因为输出是计数（无量纲）。\n\n测试套件（每个元组编码了 $(L, N_g, \\Delta t, N_t, \\sigma, \\Phi, n_n, W)$）：\n1. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 1.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 5.0\\times 10^{20}\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 1.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 5.0\\times 10^{4})$。\n2. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 1.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 0.0\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 1.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 5.0\\times 10^{4})$。\n3. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 2.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 1.0\\times 10^{21}\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 2.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 2.0\\times 10^{5})$。\n4. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 1.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 5.0\\times 10^{20}\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 1.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 1.0\\times 10^{7})$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_i$ 是测试用例 $i$ 的最终宏电子数（整数）。", "solution": "该问题是计算等离子体物理学中一个定义良好且科学上合理的任务。它要求实现一个一维静电粒子云网格（PIC）代码。该模型包含周期性边界条件和一个光电离源项，该源项会随时间在模拟域中引入新的电子-离子对。问题本身是内容完整的，提供了所有必要的物理定律、数值方法、物理常数和测试参数。它没有矛盾或含糊之处。因此，我们着手提供一个完整的解决方案。\n\n该算法的核心是 PIC 循环，它自洽地模拟了带电粒子与它们共同产生的电场之间的相互作用。这个循环在每个离散时间步 $\\Delta t$ 执行。我们从描述离散化域开始，然后详细说明 PIC 循环的每一步。\n\n**系统离散化**\n\n长度为 $L$ 的一维空间域被离散化为 $N_g$ 个宽度均匀的网格单元 $\\Delta x = L/N_g$。网格节点位于位置 $x_j = j \\Delta x$（对于 $j = 0, 1, \\dots, N_g-1$）。定义在网格上的物理量，如电荷密度 $\\rho$ 和电场 $E$，在这些节点上被离散化。模拟以时长为 $\\Delta t$ 的离散时间步前进。\n\n**粒子云网格（PIC）循环**\n\n模拟开始时没有带电粒子。在每个时间步 $n$，执行以下操作序列，总共执行 $N_t$ 步。\n\n**1. 源项：粒子创建**\n静止中性气体的光电离会产生新的电子-离子对。体积生成率由 $S = \\sigma \\Phi n_n$ 给出，其中 $\\sigma$ 是光电离截面，$\\Phi$ 是光子通量，$n_n$ 是中性气体密度。对于长度为 $L$ 且单位横截面积的一维域，每个时间步 $\\Delta t$ 创建的真实粒子对总数为 $S L \\Delta t$。\n\n每个计算宏粒子代表 $W$ 个真实粒子。因此，在一个时间步内预期创建的新宏粒子对数量为：\n$$\n\\mu = \\frac{S L \\Delta t}{W}\n$$\n为了确保统计上正确的注入率，我们采用概率取整。在给定时间步内创建的粒子对数 $N_{\\text{new}}$ 确定如下：\n$$\nN_{\\text{new}} = \\lfloor \\mu \\rfloor + \\begin{cases} 1 & \\text{以概率 } f \\\\ 0 & \\text{以概率 } 1-f \\end{cases}\n$$\n其中 $f = \\mu - \\lfloor \\mu \\rfloor$ 是 $\\mu$ 的小数部分。这通过从 $[0, 1)$ 上的均匀分布中抽取一个随机数 $r$ 来实现，如果 $r < f$，则额外增加一对。固定的随机种子确保了可复现性。对于每个新对，一个电子和一个离子在相同的随机位置 $x_{\\text{new}}$ 被创建，该位置从 $[0, L)$ 中均匀抽取。它们用于蛙跳积分器的初始速度被设置为零。\n\n**2. 电荷沉积（散射）**\n等离子体的连续电荷分布由一组离散的宏粒子表示。这些粒子的电荷必须沉积到网格上以计算电荷密度 $\\rho_j$。我们使用一阶，或称为细胞内云（CIC）权函数格式。\n\n对于一个电荷为 $q_p$、位于位置 $x_p$ 的粒子 $p$，我们首先确定其左侧最近的网格节点的索引 $j = \\lfloor x_p / \\Delta x \\rfloor$。粒子的电荷被分配到这个节点和右侧相邻的节点 $j+1$ 之间（采用周期性环绕，即索引 $(j+1) \\pmod{N_g}$）。分配给每个节点的电荷分数由线性权重确定。设 $h = (x_p/\\Delta x) - j$ 为距左侧节点的归一化距离。电荷贡献为：\n$$\n\\delta \\rho'_{j} = q_p (1-h)\n$$\n$$\n\\delta \\rho'_{(j+1) \\pmod{N_g}} = q_p h\n$$\n每个网格节点上的总电荷 $\\rho'_j$ 是所有粒子（电子和离子，其电荷分别为 $q_e = -eW$ 和 $q_i = +eW$）贡献之和。然后，通过除以单元体积，得到节点 $j$ 处的电荷密度 $\\rho_j$。在我们的一维单位面积情况下，单元体积就是单元宽度 $\\Delta x$：\n$$\n\\rho_j = \\frac{\\rho'_j}{\\Delta x}\n$$\n\n**3. 场求解器**\n在网格上已知电荷密度 $\\rho_j$ 后，我们使用一维 Gauss 定律在静电条件下求解电场 $E_j$：\n$$\n\\frac{\\partial E}{\\partial x} = \\frac{\\rho}{\\varepsilon_0}\n$$\n对于周期性域，使用快速傅里叶变换（FFT）的谱方法是高效且准确的。在傅里叶空间中，空间导数 $\\partial/\\partial x$ 变为乘以 $ik$，其中 $k$ 是波数。变换 Gauss 定律得到：\n$$\nik \\hat{E}(k) = \\frac{\\hat{\\rho}(k)}{\\varepsilon_0}\n$$\n其中 $\\hat{E}(k)$ 和 $\\hat{\\rho}(k)$ 分别是电场和电荷密度的傅里叶变换。\n\n我们可以求解电场的傅里叶分量：\n$$\n\\hat{E}(k) = \\frac{\\hat{\\rho}(k)}{ik\\varepsilon_0} = -i \\frac{\\hat{\\rho}(k)}{k\\varepsilon_0}, \\quad \\text{对于 } k \\neq 0\n$$\n对于 $k=0$（直流）分量，分母为零。周期性系统的可解性条件要求域中的净电荷为零，这意味着 $\\hat{\\rho}(k=0) = 0$。这个条件在这里得到满足，因为我们总是创建电子-离子对，从而维持电中性。问题规定平均电场必须为零，这对应于设置 $\\hat{E}(k=0) = 0$。\n\n数值步骤如下：\n1. 计算电荷密度的离散傅里叶变换：$\\hat{\\rho}_m = \\text{FFT}(\\rho_j)$。\n2. 对于每个离散波数 $k_m$（其中 $m$ 是频率指数），计算 $\\hat{E}_m$。设置 $\\hat{E}_0 = 0$。\n3. 计算傅里叶逆变换以获得网格上的电场：$E_j = \\text{IFFT}(\\hat{E}_m)$。结果必须是实数，因此由于数值误差产生的任何微小虚部都应舍弃。\n\n**4. 场插值（收集）**\n为了更新粒子速度，必须在每个粒子的位置 $x_p$ 处计算电场。这通过将基于网格的场 $E_j$ 插值回粒子位置来实现。为确保动量守恒并防止自作用力，插值方案必须与电荷沉积方案一致。因此，我们使用相同的一阶（CIC）权函数：\n$$\nE(x_p) = E_j (1-h) + E_{(j+1) \\pmod{N_g}} h\n$$\n其中 $j = \\lfloor x_p / \\Delta x \\rfloor$ 和 $h = (x_p/\\Delta x) - j$ 与沉积步骤中的相同。\n\n**5. 粒子推进器**\n每个粒子的运动由 Newton 第二定律支配，力由 Lorentz 力给出，在这种静电情况下简化为 $F = qE$。运动方程为：\n$$\n\\frac{d\\vec{v}}{dt} = \\frac{q}{m} \\vec{E}, \\quad \\frac{d\\vec{x}}{dt} = \\vec{v}\n$$\n这些方程使用时间中心蛙跳算法进行积分，该算法以其长期稳定性和二阶精度而闻名。速度定义在半整数时间步（$t^{n-1/2}, t^{n+1/2}, \\dots$），位置定义在整数时间步（$t^n, t^{n+1}, \\dots$）。更新规则是：\n$$\nv_p^{n+1/2} = v_p^{n-1/2} + \\frac{q_p}{m_p} E(x_p^n) \\Delta t\n$$\n$$\nx_p^{n+1} = x_p^n + v_p^{n+1/2} \\Delta t\n$$\n位置更新后，应用周期性边界条件：$x_p^{n+1} \\leftarrow x_p^{n+1} \\pmod L$。这完成了一个 PIC 算法的循环。整个过程重复 $N_t$ 个时间步。最终要求的输出是模拟结束时宏电子的总数。", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D electrostatic PIC simulation.\n    \"\"\"\n    test_cases = [\n        (0.1, 64, 1.0e-11, 50, 1.0e-22, 5.0e20, 1.0e19, 5.0e4),\n        (0.1, 64, 1.0e-11, 50, 1.0e-22, 0.0, 1.0e19, 5.0e4),\n        (0.1, 64, 1.0e-11, 50, 2.0e-22, 1.0e21, 2.0e19, 2.0e5),\n        (0.1, 64, 1.0e-11, 50, 1.0e-22, 5.0e20, 1.0e19, 1.0e7),\n    ]\n\n    results = []\n    for params in test_cases:\n        final_electron_count = run_pic_simulation(*params)\n        results.append(final_electron_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_pic_simulation(L, N_g, dt, N_t, sigma, Phi, n_n, W):\n    \"\"\"\n    Executes a one-dimensional electrostatic Particle-In-Cell simulation.\n\n    Args:\n        L (float): Domain length (m).\n        N_g (int): Number of grid nodes.\n        dt (float): Time step duration (s).\n        N_t (int): Total number of time steps.\n        sigma (float): Photoionization cross section (m^2).\n        Phi (float): Photon flux (m^-2 s^-1).\n        n_n (float): Neutral gas number density (m^-3).\n        W (float): Macro-particle weight.\n\n    Returns:\n        int: Total number of macro-electrons at the end of the simulation.\n    \"\"\"\n    # Physical constants\n    E_CHARGE = 1.602176634e-19\n    M_E = 9.1093837015e-31\n    M_I = 6.6335209e-26\n    EPS_0 = 8.8541878128e-12\n\n    # Grid parameters\n    dx = L / N_g\n\n    # Source term calculation\n    S = sigma * Phi * n_n\n    mu = (S * L * dt) / W\n    mu_base = int(mu)\n    mu_frac = mu - mu_base\n\n    # Pre-allocate particle arrays\n    # A safe upper bound for the number of particles is estimated\n    max_new_per_step = mu_base + 1\n    max_particles = max_new_per_step * N_t + 10 # Add a small buffer\n    \n    pos_e = np.zeros(max_particles)\n    vel_e = np.zeros(max_particles)\n    n_elec = 0\n    \n    pos_i = np.zeros(max_particles)\n    vel_i = np.zeros(max_particles)\n    n_ions = 0\n    \n    # Initialize random number generator with fixed seed\n    rng = np.random.default_rng(42)\n\n    # Pre-calculate FFT wavenumbers\n    k_fft = 2 * np.pi * fft.fftfreq(N_g, d=dx)\n    \n    # Main simulation loop\n    for _ in range(N_t):\n        # 1. Source: Create new particles\n        num_new = mu_base\n        if rng.random() < mu_frac:\n            num_new += 1\n\n        if num_new > 0:\n            # Add new electrons\n            start_idx_e = n_elec\n            end_idx_e = n_elec + num_new\n            pos_e[start_idx_e:end_idx_e] = rng.random(size=num_new) * L\n            vel_e[start_idx_e:end_idx_e] = 0.0 # Initial leapfrog velocity is zero\n            n_elec = end_idx_e\n\n            # Add new ions\n            start_idx_i = n_ions\n            end_idx_i = n_ions + num_new\n            pos_i[start_idx_i:end_idx_i] = pos_e[start_idx_e:end_idx_e] # Same position\n            vel_i[start_idx_i:end_idx_i] = 0.0\n            n_ions = end_idx_i\n\n        if n_elec == 0:\n            continue\n        \n        # Slices for active particles\n        active_pos_e = pos_e[:n_elec]\n        active_vel_e = vel_e[:n_elec]\n        active_pos_i = pos_i[:n_ions]\n        active_vel_i = vel_i[:n_ions]\n\n        # 2. Charge Deposition (Scatter)\n        rho_grid = np.zeros(N_g)\n\n        # Electrons\n        q_e = -E_CHARGE * W\n        norm_pos_e = active_pos_e / dx\n        i1_e = np.floor(norm_pos_e).astype(int)\n        h_e = norm_pos_e - i1_e\n        i2_e = (i1_e + 1) % N_g\n        np.add.at(rho_grid, i1_e, q_e * (1.0 - h_e))\n        np.add.at(rho_grid, i2_e, q_e * h_e)\n\n        # Ions\n        q_i = E_CHARGE * W\n        norm_pos_i = active_pos_i / dx\n        i1_i = np.floor(norm_pos_i).astype(int)\n        h_i = norm_pos_i - i1_i\n        i2_i = (i1_i + 1) % N_g\n        np.add.at(rho_grid, i1_i, q_i * (1.0 - h_i))\n        np.add.at(rho_grid, i2_i, q_i * h_i)\n        \n        rho_grid /= dx # Convert charge to charge density\n\n        # 3. Field Solve\n        rho_k = fft.fft(rho_grid)\n        E_k = np.zeros_like(rho_k)\n        \n        # Avoid division by zero for k=0\n        non_zero_k = k_fft != 0\n        E_k[non_zero_k] = -1j * rho_k[non_zero_k] / (k_fft[non_zero_k] * EPS_0)\n        \n        E_grid = np.real(fft.ifft(E_k))\n\n        # 4. Field Interpolation (Gather)\n        # Electrons\n        E_p_e = E_grid[i1_e] * (1.0 - h_e) + E_grid[i2_e] * h_e\n        # Ions\n        E_p_i = E_grid[i1_i] * (1.0 - h_i) + E_grid[i2_i] * h_i\n\n        # 5. Particle Push\n        # Electrons\n        active_vel_e += (q_e / M_E) * E_p_e * dt\n        active_pos_e += active_vel_e * dt\n        pos_e[:n_elec] = active_pos_e % L\n        \n        # Ions\n        active_vel_i += (q_i / M_I) * E_p_i * dt\n        active_pos_i += active_vel_i * dt\n        pos_i[:n_ions] = active_pos_i % L\n        \n    return n_elec\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2424112"}, {"introduction": "建立了一个可运行的模拟之后，我们现在转向一个关键问题：我们的数值场求解器的精度如何？本练习将引导你通过计算求解器的离散格林函数来分析 PIC 方法的核心 [@problem_id:2424113]。这种强大的技术使我们能够量化网格和有限差分算子如何导致数值解偏离理想的连续介质中的 $1/r$ 势，从而揭示出诸如数值各向异性等重要的效应。", "problem": "您的任务是开发一个完整的、可运行的程序，该程序为周期性边界条件下的均匀笛卡尔网格上的三维静电胞中粒子 (PIC) 求解器构建并分析离散格林函数。您的 PIC 求解器使用拉普拉斯算子的二阶中心差分离散，并在傅里叶空间中求解泊松方程。\n\n从基本原理开始：麦克斯韦方程组的静电极限导出了泊松方程 $\\nabla^2 \\phi(\\mathbf{x}) = -\\rho(\\mathbf{x})/\\varepsilon_0$。在一个间距为 $h$、具有周期性边界条件的均匀网格上，二阶离散拉普拉斯算子近似于 $\\nabla^2$。离散格林函数 $G_d(\\mathbf{r})$ 定义为，当在原点放置一个单位点电荷时，由指定的离散求解器和网格计算出的网格点上的电势响应。在胞中粒子 (PIC) 方法中，由粒子到网格的分配和场到粒子的插值所隐含的有限粒子尺寸，通过所选形状函数的傅里叶变换的平方，修正了波数空间中的有效源和测量。\n\n在您的程序中实现以下内容：\n\n1) 为一个大小为 $N \\times N \\times N$ 的均匀周期性三维网格构建离散格林函数，使用二阶中心差分拉普拉斯算子结合谱方法（离散傅里叶变换）对泊松方程进行求逆。通过将波数零模设置为零来强制执行零均值条件，从而在周期性边界条件下唯一地定义电势。\n\n2) 包含粒子形状的影响。使用 $m$ 阶一维B-样条形状函数，其傅里叶变换为 $S_m(k) = \\left[\\operatorname{sinc}\\!\\left(\\frac{k h}{2}\\right)\\right]^{m+1}$，其中 $\\operatorname{sinc}(x) = \\frac{\\sin x}{x}$。假设粒子到网格的沉积和网格到粒子的插值使用相同的形状函数，因此有效谱响应乘以 $\\lvert S_m(\\mathbf{k}) \\rvert^2 = \\prod_{i=x,y,z}\\left[\\operatorname{sinc}\\!\\left(\\frac{k_i h}{2}\\right)\\right]^{2(m+1)}$。对于最近网格点 (NGP) 使用 $m=0$，对于单元云 (CIC) 使用 $m=1$。\n\n3) 在无量纲晶格单位下工作，以便与连续介质格林函数进行比较。令 $\\hat{\\mathbf{r}} = \\mathbf{r}/h$ 为晶格坐标。通过有效谱格林函数的逆离散傅里叶变换定义无量纲离散格林函数 $\\hat{G}_d(\\hat{\\mathbf{r}})$。将 $\\hat{G}_d(\\hat{\\mathbf{r}})$ 与连续介质表达式 $\\hat{G}_c(\\hat{r}) = \\frac{1}{4\\pi \\hat{r}}$ 进行比较（经过适当缩放后，此表达式对应于物理上的 $1/(4\\pi r)$）。您报告的所有度量都必须是无量纲的。\n\n4) 分析各向异性与连续介质解的偏差：\n   - 根据整数平方距离 $s = i^2 + j^2 + k^2$ 将网格点分组为球壳，其中 $(i,j,k)$ 是与源点的最短周期性位移。对于每个半径为 $\\hat{r} = \\sqrt{s}$ 的壳层，计算：\n     a) 该壳层上 $\\hat{G}_d$ 值的壳层平均值 $\\overline{G}_s$ 和壳层标准差 $\\sigma_s$。\n     b) 壳层各向异性，定义为 $\\sigma_s / \\overline{G}_s$。\n     c) 壳层相对误差 $\\delta_s = \\overline{G}_s / \\hat{G}_c(\\hat{r}) - 1$。\n   - 仅考虑 $\\hat{r}_{\\min} < \\hat{r} < \\hat{r}_{\\max}$ 范围内的壳层，以避免原点的奇异单元并减少周期性镜像的影响。使用 $\\hat{r}_{\\min} = 1.5$ 和 $\\hat{r}_{\\max} = N/4$。\n   - 为每种情况报告两个全局度量：最大壳层各向异性和壳层相对误差的均方根 $\\sqrt{\\langle \\delta_s^2 \\rangle}$，在所考虑的壳层上进行均匀平均。这两个度量都是无量纲的。\n\n5) 使用以下参数集测试套件来检验您的实现：\n   - 情况 1 (标准情形): $N = 32$, $h = 1.0$, shape = NGP。\n   - 情况 2 (形状函数效应): $N = 32$, $h = 1.0$, shape = CIC。\n   - 情况 3 (分辨率/间距变化): $N = 48$, $h = 0.5$, shape = CIC。\n\n您的程序必须对所有情况执行计算，并打印单行，其中包含六个浮点数的平铺列表：按顺序为每种情况打印最大壳层各向异性，后跟均方根相对误差。要求的最终输出格式为单行：\n\"[a1,e1,a2,e2,a3,e3]\"\n其中每个数字都精确到小数点后六位。例如，一个语法正确的输出可能看起来像 \"[0.123456,0.012345,0.234567,0.023456,0.345678,0.034567]\"。报告的量是无量纲的，因此在输出中不需要也不允许使用物理单位。", "solution": "该问题要求为周期性笛卡尔网格上的三维静电胞中粒子 (PIC) 求解器构建和分析离散格林函数。分析将重点关注量化由网格、有限差分算子和粒子形状函数引入的各向异性以及与连续介质解的偏差。\n\n基本方程是泊松方程，它描述了给定电荷密度 $\\rho(\\mathbf{x})$ 下的静电势 $\\phi(\\mathbf{x})$：\n$$ \\nabla^2 \\phi(\\mathbf{x}) = -\\frac{\\rho(\\mathbf{x})}{\\varepsilon_0} $$\n我们考虑一个大小为 $N \\times N \\times N$，网格间距为 $h$ 的均匀笛卡尔网格。网格上的位置由 $\\mathbf{r}_{\\mathbf{j}} = (j_x h, j_y h, j_z h)$ 表示，其中 $\\mathbf{j} = (j_x, j_y, j_z)$ 是一个整数索引三元组。电势和电荷密度在该网格上离散化为 $\\phi_{\\mathbf{j}} = \\phi(\\mathbf{r}_{\\mathbf{j}})$ 和 $\\rho_{\\mathbf{j}} = \\rho(\\mathbf{r}_{\\mathbf{j}})$。\n\n拉普拉斯算子 $\\nabla^2$ 使用二阶精度中心差分模板进行近似。在三维空间中，作用于网格点 $\\mathbf{j}$ 的电势的离散算子 $D^2$ 为：\n$$ (D^2 \\phi)_{\\mathbf{j}} = \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_x} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_x}}{h^2} + \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_y} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_y}}{h^2} + \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_z} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_z}}{h^2} $$\n其中 $\\mathbf{e}_x, \\mathbf{e}_y, \\mathbf{e}_z$ 是沿网格轴的单位矢量。\n据此，离散泊松方程为 $(D^2 \\phi)_{\\mathbf{j}} = -\\rho_{\\mathbf{j}}/\\varepsilon_0$。\n\n由于存在周期性边界条件，该系统在傅里叶空间中可以被高效求解。网格量 $f_{\\mathbf{j}}$ 的离散傅里叶变换 (DFT) 是 $\\tilde{f}_{\\mathbf{n}} = \\sum_{\\mathbf{j}} f_{\\mathbf{j}} e^{-i \\mathbf{k}_{\\mathbf{n}} \\cdot \\mathbf{r}_{\\mathbf{j}}}$，其中离散波矢量为 $\\mathbf{k}_{\\mathbf{n}} = (2\\pi n_x/(Nh), 2\\pi n_y/(Nh), 2\\pi n_z/(Nh))$，对于整数模式索引 $\\mathbf{n}=(n_x, n_y, n_z)$。DFT 将类卷积的差分算子转换为简单的乘法。离散拉普拉斯算子的傅里叶表示（特征值）为：\n$$ \\hat{D}^2(\\mathbf{k}_{\\mathbf{n}}) = \\sum_{i \\in \\{x,y,z\\}} \\frac{2}{h^2} (\\cos(k_{n_i} h) - 1) = -\\frac{4}{h^2} \\sum_{i \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{k_{n_i} h}{2}\\right) $$\n代入 $k_{n_i}$ 的表达式，这变为：\n$$ \\hat{D}^2(\\mathbf{n}) = -\\frac{4}{h^2} \\sum_{i \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_i}{N}\\right) $$\n傅里叶空间中的离散泊松方程为 $\\hat{D}^2(\\mathbf{n}) \\tilde{\\phi}_{\\mathbf{n}} = -\\tilde{\\rho}_{\\mathbf{n}}/\\varepsilon_0$。\n\n离散格林函数 $G_d$ 是对放置在原点网格点 $\\mathbf{j}=(0,0,0)$ 上的单个单位点电荷 $q=1$ 的电势响应。这对应于离散电荷密度 $\\rho_{\\mathbf{j}} = \\delta_{\\mathbf{j}0} / h^3$，其中 $\\delta_{\\mathbf{j}0}$ 是克罗内克 $\\delta$ 函数，$h^3$ 是单元体积。该源的 DFT 是一个常数，即 $\\tilde{\\rho}_{\\mathbf{n}} = 1/h^3$。\n\n在 PIC 模拟中，粒子间的相互作用通过粒子形状函数被平滑，该函数用于将电荷分配到网格以及将场插值回粒子。对于一个分配函数 $W(\\mathbf{x})$ 和一个插值函数 $I(\\mathbf{x})$，一个测试粒子感受到的来自源粒子的有效势是通过求解器和这两个滤波器进行调节的。在傅里叶空间中，这导致相互作用被因子 $\\tilde{I}^*(\\mathbf{k})\\tilde{W}(\\mathbf{k})$ 修正。问题指出，分配和插值函数是相同的 $m$ 阶 B-样条函数，即 $W=I=S_m$，其傅里叶变换是实数。因此，有效相互作用被 $|S_m(\\mathbf{k})|^2$ 修正。问题给出的形式为：\n$$ S_m(k) = \\left[\\operatorname{sinc}\\left(\\frac{kh}{2}\\right)\\right]^{m+1} \\quad \\text{其中 } \\operatorname{sinc}(x) = \\frac{\\sin x}{x} $$\n三维空间中的总修正因子为 $\\lvert S_m(\\mathbf{k}) \\rvert^2 = \\prod_{i=x,y,z}\\left[\\operatorname{sinc}\\!\\left(\\frac{k_i h}{2}\\right)\\right]^{2(m+1)}$。\n\n综合这些元素，描述粒子-粒子相互作用的有效谱势 $\\tilde{G}_{d, \\text{eff}}$ 为：\n$$ \\tilde{G}_{d, \\text{eff}}(\\mathbf{n}) = \\frac{-\\tilde{\\rho}_{\\mathbf{n}}/\\varepsilon_0}{\\hat{D}^2(\\mathbf{n})} |S_m(\\mathbf{k}_{\\mathbf{n}})|^2 = \\frac{-(1/h^3)/\\varepsilon_0}{-\\frac{4}{h^2} \\sum_i \\sin^2(\\frac{\\pi n_i}{N})} \\prod_j \\left[\\operatorname{sinc}\\left(\\frac{\\pi n_j}{N}\\right)\\right]^{2(m+1)} $$\n$$ \\tilde{G}_{d, \\text{eff}}(\\mathbf{n}) = \\frac{1}{4 \\varepsilon_0 h} \\frac{\\prod_j \\left[\\operatorname{sinc}(\\pi n_j/N)\\right]^{2(m+1)}}{\\sum_i \\sin^2(\\pi n_i/N)} $$\n我们寻求一个无量纲格林函数 $\\hat{G}_d$。连续介质格林函数是 $G_c(r) = 1/(4\\pi\\varepsilon_0 r)$。无量纲比较函数给定为 $\\hat{G}_c(\\hat{r}) = 1/(4\\pi\\hat{r})$，其中 $\\hat{r}=r/h$。这表明需要进行 $4\\pi\\varepsilon_0 h$ 的归一化并设置 $\\varepsilon_0=1/(4\\pi)$。一个更直接的方法是定义无量纲谱格林函数 $\\hat{\\tilde{G}}_d(\\mathbf{n})$，当其变换到实空间后，可以与 $\\hat{G}_c(\\hat{r})$ 进行比较。从 $\\tilde{G}_{d, \\text{eff}}$ 的表达式中，我们可以构建一个不依赖于 $h$ 和 $\\varepsilon_0$ 的无量纲谱函数：\n$$ \\hat{\\tilde{G}}_d(\\mathbf{n}) = \\frac{\\prod_{j \\in \\{x,y,z\\}} \\left[\\operatorname{sinc}(\\pi n_j/N)\\right]^{2(m+1)}}{4 \\sum_{i \\in \\{x,y,z\\}} \\sin^2(\\pi n_i/N)} $$\n对于 $\\mathbf{n}=(0,0,0)$ 的模式，其分母为零，代表平均势。对于具有隐式电荷中性的周期性系统，此模式被设为零，即 $\\hat{\\tilde{G}}_d(\\mathbf{0}) = 0$。\n\n计算步骤如下：\n1. 对于给定的网格大小 $N$ 和形状阶数 $m$，为所有模式索引 $\\mathbf{n}$ 构建三维数组 $\\hat{\\tilde{G}}_d(\\mathbf{n})$。\n2. 通过对 $\\hat{\\tilde{G}}_d(\\mathbf{n})$ 执行三维逆离散傅里叶变换 (DFT)，计算实空间无量纲格林函数 $\\hat{G}_d(\\hat{\\mathbf{r}})$。\n3. 为了分析结果，将网格点按距原点的恒定平方距离 $s = i^2+j^2+k^2$ 分组到壳层中，其中 $(i,j,k)$ 是最短的周期性位移。壳层半径为 $\\hat{r} = \\sqrt{s}$。\n4. 对每个在 $1.5 < \\hat{r} < N/4$ 范围内的壳层，我们计算：\n   - 该壳层上 $\\hat{G}_d$ 值的壳层平均值 $\\overline{G}_s$ 和标准差 $\\sigma_s$。\n   - 壳层各向异性 $\\alpha_s = \\sigma_s / \\overline{G}_s$。\n   - 连续介质值 $\\hat{G}_c(\\hat{r}) = 1/(4\\pi\\hat{r})$。\n   - 壳层相对误差 $\\delta_s = \\overline{G}_s / \\hat{G}_c(\\hat{r}) - 1$。\n5. 最后，我们在所有考虑的壳层上计算两个全局度量：最大壳层各向异性 $\\max(\\alpha_s)$ 和壳层相对误差的均方根 $\\sqrt{\\langle \\delta_s^2 \\rangle}$。这两个无量纲量为每个测试案例计算。", "answer": "```python\nimport numpy as np\n\ndef calculate_metrics(N, h, shape_str):\n    \"\"\"\n    Constructs and analyzes the discrete Green's function for a 3D PIC solver.\n\n    Args:\n        N (int): The number of grid points in each dimension.\n        h (float): The grid spacing (not used in the dimensionless calculation but kept for parameter consistency).\n        shape_str (str): The particle shape function, \"NGP\" or \"CIC\".\n\n    Returns:\n        tuple[float, float]: A tuple containing the maximum shell anisotropy and the RMS relative error.\n    \"\"\"\n    if shape_str == 'NGP':\n        m = 0\n    elif shape_str == 'CIC':\n        m = 1\n    else:\n        raise ValueError(\"Invalid shape string. Must be 'NGP' or 'CIC'.\")\n\n    # 1. Create wave-number index grid\n    n_coords_1d = np.fft.fftfreq(N) * N\n    nx, ny, nz = np.meshgrid(n_coords_1d, n_coords_1d, n_coords_1d, indexing='ij')\n\n    # 2. Numerator: Shape function factor |S_m(k)|^2\n    # np.sinc(x) computes sin(pi*x)/(pi*x). We need sinc(pi*n/N) = sin(pi*n/N)/(pi*n/N).\n    # This corresponds to np.sinc(n/N).\n    sinc_arg_x = nx / N\n    sinc_arg_y = ny / N\n    sinc_arg_z = nz / N\n\n    sinc_val_x = np.sinc(sinc_arg_x)\n    sinc_val_y = np.sinc(sinc_arg_y)\n    sinc_val_z = np.sinc(sinc_arg_z)\n\n    shape_factor_sq = (sinc_val_x * sinc_val_y * sinc_val_z)**(2 * (m + 1))\n\n    # 3. Denominator: Fourier representation of the -Laplacian operator\n    # Denom = 4 * sum(sin^2(pi*n_i/N))\n    K_sq = 4 * (np.sin(np.pi * nx / N)**2 + \n                np.sin(np.pi * ny / N)**2 + \n                np.sin(np.pi * nz / N)**2)\n\n    # 4. Spectral Green's function, handling k=0 singularity\n    with np.errstate(divide='ignore', invalid='ignore'):\n        G_k = shape_factor_sq / K_sq\n    \n    G_k[0, 0, 0] = 0.0 # Set DC mode to zero\n    \n    # 5. Inverse FFT to get real-space Green's function\n    G_r = np.real(np.fft.ifftn(G_k))\n\n    # 6. Analysis of anisotropy and error\n    r_min = 1.5\n    r_max = N / 4.0\n\n    # Create coordinate grid for distance calculation. fftshift centers the result.\n    G_r_shifted = np.fft.fftshift(G_r)\n    coords_1d = np.arange(-N // 2, N // 2)\n    ix, iy, iz = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n    s = ix**2 + iy**2 + iz**2\n    \n    # Group grid points into shells by squared distance 's'\n    shell_data = {}\n    unique_s_values = np.unique(s)\n    \n    for s_val in unique_s_values:\n        if s_val == 0:\n            continue\n        \n        r_val = np.sqrt(s_val)\n        \n        if r_min < r_val < r_max:\n            indices = np.where(s == s_val)\n            g_d_values = G_r_shifted[indices]\n            \n            mean_g = np.mean(g_d_values)\n            std_g = np.std(g_d_values)\n            \n            anisotropy = 0.0\n            if abs(mean_g) > 1e-16: # Avoid division by zero\n                anisotropy = std_g / mean_g\n            \n            g_c = 1.0 / (4.0 * np.pi * r_val)\n            rel_error = mean_g / g_c - 1.0\n            \n            shell_data[s_val] = {\n                'anisotropy': anisotropy, \n                'rel_error_sq': rel_error**2\n            }\n\n    # 7. Compute final global metrics\n    anisotropies = [d['anisotropy'] for d in shell_data.values()]\n    rel_errors_sq = [d['rel_error_sq'] for d in shell_data.values()]\n    \n    max_anisotropy = 0.0\n    if anisotropies:\n        max_anisotropy = np.max(anisotropies)\n        \n    rms_rel_error = 0.0\n    if rel_errors_sq:\n        rms_rel_error = np.sqrt(np.mean(rel_errors_sq))\n        \n    return max_anisotropy, rms_rel_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (32, 1.0, \"NGP\"),\n        (32, 1.0, \"CIC\"),\n        (48, 0.5, \"CIC\"),\n    ]\n\n    results = []\n    for N, h, shape in test_cases:\n        max_anisotropy, rms_rel_error = calculate_metrics(N, h, shape)\n        results.append(max_anisotropy)\n        results.append(rms_rel_error)\n\n    # Format the final output string\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2424113"}, {"introduction": "正确性和准确性至关重要，但对于大规模模拟而言，计算速度同样关键。最后一个实践将我们的重点转移到性能优化上，这是任何计算科学家都必须掌握的一项重要技能。你将探索内存访问模式如何影响性能，并实现粒子排序算法（包括先进的比特反转技术）来改善缓存一致性 [@problem_id:2424079]。这项练习展示了物理核心之外的算法选择如何极大地影响模拟的实际可行性。", "problem": "一维静电粒子模拟 (Particle-In-Cell, PIC) 方法模拟一组计算粒子，这些粒子将物理量沉积到规则的网格单元上。考虑一个由 $N_{\\mathrm{c}}$ 个单元组成的离散网格，其索引为整数 $i \\in \\{0,1,\\dots,N_{\\mathrm{c}}-1\\}$。每个粒子 $p \\in \\{1,2,\\dots,N_{\\mathrm{p}}\\}$ 都与一个网格单元索引 $i_p \\in \\{0,1,\\dots,N_{\\mathrm{c}}-1\\}$ 相关联。粒子的遍历顺序由 $\\{1,2,\\dots,N_{\\mathrm{p}}\\}$ 的一个排列 $\\pi$ 表示。定义缓存一致性代价泛函 (cache-coherency cost functional)\n$$\nJ(\\pi) \\equiv \\sum_{k=1}^{N_{\\mathrm{p}}-1} \\left|\\, i_{\\pi(k+1)} - i_{\\pi(k)} \\,\\right|.\n$$\n您需要对三种遍历顺序评估此泛函：\n- 原始顺序 $\\pi_{\\mathrm{orig}}$ (给定的粒子单元索引序列)。\n- 单元排序顺序 $\\pi_{\\mathrm{cell}}$，即多重集 $\\{i_p\\}$ 的任一非递减排序。\n- 比特反转顺序 $\\pi_{\\mathrm{br}}$，其定义如下。令 $b \\equiv \\lceil \\log_2 N_{\\mathrm{c}} \\rceil$。对于任何单元索引 $i \\in \\{0,1,\\dots,N_{\\mathrm{c}}-1\\}$，写出其 $b$ 位二进制表示（必要时包含前导零），反转这 $b$ 位的顺序，并将结果解释为一个非负整数 $r_b(i) \\in \\{0,1,\\dots,2^b-1\\}$。比特反转顺序 $\\pi_{\\mathrm{br}}$ 是按非递减键 $r_b(i_p)$ 对粒子进行的任一稳定排序。\n\n您的任务是编写一个完整的程序，对下面的每个测试用例，计算并返回整数三元组 $[J(\\pi_{\\mathrm{orig}}), J(\\pi_{\\mathrm{cell}}), J(\\pi_{\\mathrm{br}})]$。\n\n使用以下参数值测试套件：\n- 测试用例 1：$N_{\\mathrm{c}} = 8$，粒子单元索引列表 $[\\,0,7,0,7,0,7,0,7\\,]$。\n- 测试用例 2：$N_{\\mathrm{c}} = 6$，粒子单元索引列表 $[\\,0,5,1,4,2,3\\,]$。\n- 测试用例 3：$N_{\\mathrm{c}} = 1$，粒子单元索引列表 $[\\,0,0,0,0\\,]$。\n- 测试用例 4：$N_{\\mathrm{c}} = 8$，粒子单元索引列表 $[\\,0,4,0,4,2,6,2,6,1,5,1,5,3,7,3,7\\,]$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果列表，该列表为逗号分隔并用方括号括起，其中每个测试用例的结果本身是按 $[J(\\pi_{\\mathrm{orig}}),J(\\pi_{\\mathrm{cell}}),J(\\pi_{\\mathrm{br}})]$ 顺序排列的包含三个整数的列表。例如，一个有效的输出形如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。", "solution": "问题陈述已经过验证，被认为是科学严谨、定义明确且客观的。它在计算物理领域内，特别是在粒子模拟 (PIC) 方法的性能优化方面，提出了一个明确定义的计算任务。所有需要的数据和定义均已提供，且该问题存在唯一可验证的解。因此，我们可以着手推导和实现解决方案。\n\n目标是为分布在一维网格上的一组粒子计算缓存一致性代价泛函 $J(\\pi)$。该网格由 $N_{\\mathrm{c}}$ 个单元组成，共有 $N_{\\mathrm{p}}$ 个粒子。每个粒子的位置由其单元索引给出，粒子的遍历由一个排列 $\\pi$ 描述。代价泛函定义为：\n$$\nJ(\\pi) \\equiv \\sum_{k=1}^{N_{\\mathrm{p}}-1} \\left|\\, i_{\\pi(k+1)} - i_{\\pi(k)} \\,\\right|\n$$\n此处，$i_{\\pi(k)}$ 表示由 $\\pi$ 定义的有序序列中第 $k$ 个粒子的单元索引。我们的任务是为三种不同的遍历顺序评估此泛函：原始顺序 ($\\pi_{\\mathrm{orig}}$)、单元排序顺序 ($\\pi_{\\mathrm{cell}}$) 和比特反转顺序 ($\\pi_{\\mathrm{br}}$)。\n\n设给定的粒子单元索引序列由列表 $I = [c_1, c_2, \\dots, c_{N_{\\mathrm{p}}}]$ 表示。\n\n1.  **原始顺序代价 ($J(\\pi_{\\mathrm{orig}})$)**\n    原始遍历顺序对应于按输入列表中的给定顺序处理粒子。因此，$\\pi_{\\mathrm{orig}}$ 是单位排列，意味着单元索引序列就是 $I$。代价可直接根据定义计算：\n    $$\n    J(\\pi_{\\mathrm{orig}}) = \\sum_{k=1}^{N_{\\mathrm{p}}-1} |c_{k+1} - c_k|\n    $$\n    这是通过对输入列表中所有相邻元素的绝对差求和来计算的。\n\n2.  **单元排序顺序代价 ($J(\\pi_{\\mathrm{cell}})$)**\n    此顺序通过按单元索引对粒子进行非递减排序来实现。设排序后的单元索引列表为 $I' = [c'_1, c'_2, \\dots, c'_{N_{\\mathrm{p}}}]$，其中 $c'_1 \\le c'_2 \\le \\dots \\le c'_{N_{\\mathrm{p}}}$。代价泛函变为：\n    $$\n    J(\\pi_{\\mathrm{cell}}) = \\sum_{k=1}^{N_{\\mathrm{p}}-1} |c'_{k+1} - c'_k|\n    $$\n    由于排序后列表的非递减性质，对所有 $k$ 都有 $c'_{k+1} - c'_k \\ge 0$。因此，绝对值运算是多余的：\n    $$\n    J(\\pi_{\\mathrm{cell}}) = \\sum_{k=1}^{N_{\\mathrm{p}}-1} (c'_{k+1} - c'_k)\n    $$\n    这是一个伸缩级数求和：\n    $$\n    J(\\pi_{\\mathrm{cell}}) = (c'_2 - c'_1) + (c'_3 - c'_2) + \\dots + (c'_{N_{\\mathrm{p}}} - c'_{N_{\\mathrm{p}}-1}) = c'_{N_{\\mathrm{p}}} - c'_1\n    $$\n    代价就是粒子列表中存在的最大和最小单元索引之差。\n\n3.  **比特反转顺序代价 ($J(\\pi_{\\mathrm{br}})$)**\n    这种排序需要一个多步骤的过程。首先，我们确定表示任何单元索引所需的比特数，由 $b = \\lceil \\log_2 N_{\\mathrm{c}} \\rceil$ 给出。对于单元索引 $i \\in \\{0, 1, \\dots, N_{\\mathrm{c}}-1\\}$，我们通过以下步骤定义一个键 $r_b(i)$：\n    - 将整数 $i$ 转换为其 $b$ 位二进制字符串表示，必要时用前导零填充。\n    - 反转此字符串中比特位的顺序。\n    - 将得到的二进制字符串转换回整数。这就是键 $r_b(i)$。\n    对于 $N_{\\mathrm{c}}=1$ 的特殊情况，我们有 $b=0$，并定义 $r_0(0) = 0$。\n\n    接下来，我们根据这些键对粒子进行排序。问题指定了稳定排序，意味着如果两个粒子具有相同的键，它们在原始序列中的相对顺序必须在排序后的序列中得到保留。\n    设原始单元索引列表为 $I = [c_1, c_2, \\dots, c_{N_{\\mathrm{p}}}]$，对应的键为 $K = [r_b(c_1), r_b(c_2), \\dots, r_b(c_{N_{\\mathrm{p}}})]$。我们基于 $K$ 中的值对粒子索引 $\\{1, 2, \\dots, N_{\\mathrm{p}}\\}$ 进行排序，同时保持稳定性。这会产生一个新的粒子排列，从而得到一个新的单元索引序列 $I_{\\mathrm{br}}$。随后，通过将代价泛函应用于这个新列表 $I_{\\mathrm{br}}$ 来计算代价 $J(\\pi_{\\mathrm{br}})$：\n    $$\n    J(\\pi_{\\mathrm{br}}) = \\sum_{k=1}^{N_{\\mathrm{p}}-1} |I_{\\mathrm{br}, k+1} - I_{\\mathrm{br}, k}|\n    $$\n    其中 $I_{\\mathrm{br}, k}$是比特反转排序后列表的第 $k$ 个元素。\n\n实现将系统地将这三个过程应用于所提供的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the cache-coherency cost functional for three different\n    particle traversal orders in a 1D PIC simulation context.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, [0, 7, 0, 7, 0, 7, 0, 7]),\n        (6, [0, 5, 1, 4, 2, 3]),\n        (1, [0, 0, 0, 0]),\n        (8, [0, 4, 0, 4, 2, 6, 2, 6, 1, 5, 1, 5, 3, 7, 3, 7]),\n    ]\n\n    results = []\n\n    def bit_reverse(i, num_bits):\n        \"\"\"\n        Reverses the bottom num_bits of an integer i.\n        \"\"\"\n        if num_bits == 0:\n            return 0\n        bin_str = bin(i)[2:].zfill(num_bits)\n        rev_bin_str = bin_str[::-1]\n        return int(rev_bin_str, 2)\n\n    def calculate_cost(arr):\n        \"\"\"\n        Calculates the cost functional for a given sequence of cell indices.\n        \"\"\"\n        if arr.size < 2:\n            return 0\n        return np.sum(np.abs(np.diff(arr)))\n\n    for Nc, I_list in test_cases:\n        I = np.array(I_list, dtype=np.int64)\n        Np = I.size\n\n        if Np < 2:\n            results.append([0, 0, 0])\n            continue\n        \n        # 1. Original order cost\n        J_orig = calculate_cost(I)\n\n        # 2. Cell-sorted order cost\n        # The cost is simply max(I) - min(I).\n        J_cell = np.max(I) - np.min(I)\n\n        # 3. Bit-reversed order cost\n        if Nc > 1:\n            # b = ceil(log2(Nc)), which can be computed using bit_length\n            b = (Nc - 1).bit_length()\n        else:\n            b = 0\n            \n        # Compute keys for each particle\n        keys = np.array([bit_reverse(val, b) for val in I])\n        \n        # Perform a stable sort of particle indices based on keys\n        # numpy.argsort with kind='stable' preserves relative order for equal keys.\n        sorted_indices = np.argsort(keys, kind='stable')\n        \n        # Create the new list of cell indices\n        I_br = I[sorted_indices]\n        \n        # Calculate cost for the bit-reversed order\n        J_br = calculate_cost(I_br)\n\n        results.append([int(J_orig), int(J_cell), int(J_br)])\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    final_output_str = str(results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "2424079"}]}