{"hands_on_practices": [{"introduction": "在实现单元列表算法时，首要任务是确保其正确性，即不能遗漏任何可能发生相互作用的粒子对。此练习将引导你思考一个基本但至关重要的问题：对于包含不同大小粒子的系统，我们应如何设置单元格的大小？通过分析这个问题 [@problem_id:2416939]，你将掌握确保邻居搜索算法万无一失的核心设计原则。", "problem": "在一个三维（$3$D）多分散球形颗粒的离散元方法（DEM）模拟中，一个周期性立方体域内有 $N$ 个颗粒。颗粒 $i$ 的半径为 $r_i$，其中 $r_{\\min} = \\min_i r_i$ 且 $r_{\\max} = \\max_i r_i$。仅当两个颗粒中心距小于或等于其半径之和时，它们才通过接触力相互作用，即中心距 $d_{ij}$ 满足 $d_{ij} \\le r_i + r_j$。使用一个边长为 $a$ 的均匀立方单元链表（cell-linked list）进行邻居搜索。对于每个颗粒，候选邻居被认为是位于同一单元以及 $26$ 个相邻单元中的所有颗粒。没有额外的缓冲（“skin”）：邻居数据结构在每个时间步都会重建，并且只搜索这 $27$ 个单元。\n\n哪个选项最能说明如何根据颗粒尺寸设置 $a$，以保证在保持邻居枚举最小化的同时，不会遗漏任何接触对？\n\nA. 将 $a$ 设置为最小颗粒直径，即 $a = 2 r_{\\min}$，以保持每个单元的占用率较低。\n\nB. 将 $a$ 设置为至少与最大颗粒直径一样大，即 $a \\ge 2 r_{\\max}$，这样任何接触对都必然位于相同或相邻的单元中；取更小的 $a$ 可能会遗漏接触。\n\nC. 将 $a$ 设置为平均颗粒直径，即 $a = 2 \\langle r \\rangle$，以在平均水平上平衡精度和成本。\n\nD. 将 $a$ 设置为几何平均直径，即 $a = 2 \\sqrt{r_{\\min} r_{\\max}}$，因为它能界定大多数成对中心距。", "solution": "在尝试求解之前，必须首先验证问题陈述的科学性和逻辑完整性。\n\n### 第 1 步：提取已知条件\n- 模拟方法：离散元方法（DEM）。\n- 系统：$N$ 个多分散球形颗粒位于一个三维周期性立方体域中。\n- 颗粒半径：$r_i$，最小半径为 $r_{\\min}$，最大半径为 $r_{\\max}$。\n- 相互作用条件：如果两个颗粒 $i$ 和 $j$ 的中心距 $d_{ij}$ 满足 $d_{ij} \\le r_i + r_j$，则它们处于接触状态。\n- 邻居搜索算法：采用边长为 $a$ 的均匀立方单元链表。\n- 搜索模板：对于任何给定颗粒，在其自身单元及 $26$ 个相邻单元（一个 $3 \\times 3 \\times 3$ 的单元块）中搜索候选邻居。\n- 重建策略：邻居数据结构在每个时间步重建，不带任何额外缓冲或“skin”。\n- 目标：确定单元边长 $a$ 的条件，以保证在保持邻居枚举最小化的同时，绝不会遗漏任何接触对。\n\n### 第 2 步：使用提取的条件进行验证\n该问题描述了多颗粒系统中一个标准的短程相互作用场景，以及使用单元链表（或单元网格）方法进行高效邻居查找。这是计算物理和分子动力学模拟中的一个基本和典型问题。其组成部分如下：\n- **科学依据：** 该设置基于 DEM 和计算几何的既定原理。球体的接触条件和单元列表算法都是标准的。该问题在科学上是合理的。\n- **适定性：** 该问题要求给出单元尺寸 $a$ 的必要条件，以确保邻居搜索算法在特定搜索模板下的正确性。目标明确：保证正确性，同时力求高效（“最小化枚举”）。对于这个定义明确的问题，存在一个唯一的可推导条件。\n- **客观性：** 该问题使用该领域通用的精确技术语言进行描述。没有歧义或主观性。\n\n问题陈述没有科学或事实上的不健全之处，是形式化和相关的，是完整的，对于计算模型是现实的，是适定的，并且是科学上可验证的。\n\n### 第 3 步：结论与行动\n问题陈述有效。下面将推导解决方案。\n\n### 解决方案推导\n采用单元链表法将寻找相互作用对的计算复杂度从 $O(N^2)$ 降低到 $O(N)$。该方法的正确性取决于单元尺寸 $a$ 的选择。问题规定，对于一个给定的颗粒，我们在以其所在单元为中心的 $3 \\times 3 \\times 3$ 单元块中搜索其邻居。这意味着，如果要将两个颗粒识别为潜在的相互作用对，它们必须位于最多是相邻的单元中。\n\n设两个颗粒 $i$ 和 $j$ 的中心位置向量为 $\\vec{p}_i = (x_i, y_i, z_i)$ 和 $\\vec{p}_j = (x_j, y_j, z_j)$。单元网格与笛卡尔坐标轴对齐。位于位置 $(x, y, z)$ 的颗粒被分配到索引为 $(\\lfloor x/a \\rfloor, \\lfloor y/a \\rfloor, \\lfloor z/a \\rfloor)$ 的单元中。\n\n为了使邻居搜索成功，如果两个颗粒 $i$ 和 $j$ 接触，它们沿每个维度的单元索引的绝对差值必须最多为 $1$。即：\n$$|\\lfloor x_i/a \\rfloor - \\lfloor x_j/a \\rfloor| \\le 1$$\n$$|\\lfloor y_i/a \\rfloor - \\lfloor y_j/a \\rfloor| \\le 1$$\n$$|\\lfloor z_i/a \\rfloor - \\lfloor z_j/a \\rfloor| \\le 1$$\n\n如果例如在 $x$ 方向上的间距 $|x_i - x_j|$ 大到足以使颗粒被放置在不相邻的单元中，即 $|\\lfloor x_i/a \\rfloor - \\lfloor x_j/a \\rfloor| > 1$，则会错过一次接触。如果 $|x_i - x_j| > a$，就可能发生这种情况。例如，如果颗粒 $i$ 位于 $x_i = k \\cdot a - \\epsilon$，而颗粒 $j$ 位于 $x_j = (k+1) \\cdot a + \\epsilon$ (对于某个小的 $\\epsilon > 0$)，则它们之间的距离 $|x_i - x_j| \\approx a$。它们的单元索引将是 $\\lfloor x_i/a \\rfloor = k-1$ 和 $\\lfloor x_j/a \\rfloor = k+1$，相差为 $2$。\n\n为保证对于任何相互作用对都不会发生这种情况，它们中心沿任何笛卡尔坐标轴的间距必须小于或等于单元尺寸 $a$。让 $\\Delta x = |x_i - x_j|$、$\\Delta y = |y_i - y_j|$ 且 $\\Delta z = |z_i - z_j|$。保证找到该对的条件是：\n$$\\max(\\Delta x, \\Delta y, \\Delta z) \\le a$$\n\n接触条件为 $d_{ij} = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2} \\le r_i + r_j$。当 $\\Delta y = \\Delta z = 0$ 时，$\\Delta x$ 达到其可能的最大值，此时 $\\Delta x = d_{ij}$。因此，最大分量间距受最大总间距的限制：$\\Delta x \\le d_{ij}$。\n\n总之，对于任意两个接触的颗粒 $i$ 和 $j$，我们有：\n$$\\Delta x \\le d_{ij} \\le r_i + r_j$$\n\n为了确保对于*所有*可能的接触对都有 $\\Delta x \\le a$，$a$ 必须大于或等于右侧表达式可能的最大值。可能的最大接触距离发生在系统中两个最大的颗粒之间，即两个半径为 $r_{\\max}$ 的颗粒。它们的最大间距是 $r_{\\max} + r_{\\max} = 2 r_{\\max}$。\n\n因此，对 $a$ 的条件必须是：\n$$a \\ge \\max_{i,j \\text{ in contact}} (r_i + r_j)$$\n我们必须考虑的最坏情况是两个最大的颗粒刚好接触。\n$$a \\ge r_{\\max} + r_{\\max} = 2 r_{\\max}$$\n\n如果 $a < 2 r_{\\max}$，我们可以构造一个反例。假设两个半径均为 $r_{\\max}$ 的颗粒接触并沿 $x$ 轴对齐。它们的中心相距 $2 r_{\\max}$。如果我们选择 $a$ 使得 $a < 2 r_{\\max}$，就有可能将这两个颗粒放置在 $x$ 坐标为 $x_i = k \\cdot a - \\epsilon$ 和 $x_j = x_i + 2 r_{\\max}$ 的位置。如果 $a < 2 r_{\\max}$，那么 $x_j$ 可能会落入单元 $k+2$ 或更远的单元，而 $x_i$ 则在单元 $k-1$ 中。这样接触就会被遗漏。\n\n为了保持邻居枚举最小化，应选择满足正确性标准的最小可能单元尺寸 $a$。这意味着选择等式，$a = 2 r_{\\max}$。然而，条件本身是不等式 $a \\ge 2 r_{\\max}$。\n\n### 逐项分析\n\n**A. 将 $a$ 设置为最小颗粒直径，即 $a = 2 r_{\\min}$，以保持每个单元的占用率较低。**\n这个选择是有缺陷的。在 $r_{\\max} > r_{\\min}$ 的多分散系统中，我们可能会有 $a = 2 r_{\\min} < 2 r_{\\max}$。如推导所示，如果 $a < 2 r_{\\max}$，两个半径为 $r_{\\max}$ 的接触颗粒有可能被放置在不相邻的单元中。这将违反搜索保证。因此，该选项是**错误的**。\n\n**B. 将 $a$ 设置为至少与最大颗粒直径一样大，即 $a \\ge 2 r_{\\max}$，这样任何接触对都必然位于相同或相邻的单元中；取更小的 $a$ 可能会遗漏接触。**\n该陈述与推导出的条件完全一致。如果 $a \\ge 2 r_{\\max}$，那么对于任何接触对 $(i, j)$，其中心沿任一轴向（例如 $\\Delta x$）的间距满足 $\\Delta x \\le d_{ij} \\le r_i + r_j \\le 2 r_{\\max} \\le a$。由于 $\\Delta x \\le a$、$\\Delta y \\le a$和 $\\Delta z \\le a$，可以保证这两个颗粒位于相同或相邻的单元中。关于取更小的 $a$ 可能会遗漏接触的说法也是正确的，如最坏情况场景所示。该选项是**正确的**。\n\n**C. 将 $a$ 设置为平均颗粒直径，即 $a = 2 \\langle r \\rangle$，以在平均水平上平衡精度和成本。**\n使用平均值 $\\langle r \\rangle$ 来建立严格保证是不正确的。在任何非单分散系统中，$r_{\\max} > \\langle r \\rangle$。因此，此选择意味着 $a = 2 \\langle r \\rangle < 2 r_{\\max}$。这无法处理两个大颗粒接触的最坏情况，并可能导致相互作用被遗漏。问题要求的是保证，而不是平均情况下的性能。因此，该选项是**错误的**。\n\n**D. 将 $a$ 设置为几何平均直径，即 $a = 2 \\sqrt{r_{\\min} r_{\\max}}$，因为它能界定大多数成对中心距。**\n与算术平均值类似，几何平均值提供了集中趋势的度量。对于 $r_{\\min} < r_{\\max}$，我们有 $\\sqrt{r_{\\min} r_{\\max}} < r_{\\max}$。这意味着 $a = 2 \\sqrt{r_{\\min} r_{\\max}} < 2 r_{\\max}$，这是一个不充分的条件。保证必须覆盖所有情况，而不是“大多数”情况。两个半径为 $r_{\\max}$ 的颗粒接触的最坏情况将无法被正确处理。因此，该选项是**错误的**。", "answer": "$$\\boxed{B}$$", "id": "2416939"}, {"introduction": "将单元列表方法应用于具有周期性边界条件（PBC）的系统时，会出现新的挑战，尤其是在模拟盒子尺寸 $L$ 相对于相互作用截断半径 $r_c$ 较小的情况下。这个练习 [@problem_id:2416982] 探讨了在这种“小盒子”极限下确保邻居搜索正确性的不同策略。解决这个问题将帮助你预见并处理在真实模拟代码中由边界条件引起的常见复杂情况。", "problem": "一个边长为 $L$ 的三维立方模拟盒子，采用周期性边界条件（PBC），其中包含 $N$ 个粒子。这些粒子通过在截断半径 $r_c$ 处截断的短程对势相互作用。你计划使用一种链式网格（单元列表）邻居搜索方法，该方法将盒子在每个维度上划分为 $n$ 个单元，每个立方单元的边长为 $a=L/n$，其中 $n$ 是一个正整数。邻居搜索必须找到所有最小镜像距离小于或等于 $r_c$ 的粒子对，且每个相互作用的粒子对必须只被计算一次。考虑 $L<3r_c$ 的情况。\n\n在这种情况的周期性边界条件下，以下哪种策略是正确且充分的？选择所有适用项。\n\nA. 当 $2r_c \\le L < 3r_c$ 时，选择 $n=2$ 以使得 $a=L/2>r_c$。对每个单元，搜索标准的 $3 \\times 3 \\times 3$ 模板（单元自身以及所有面、边、角相邻的邻居单元），邻居单元索引对 $2$ 取模以实施 PBC。使用“半壳层”约定（例如，在同一单元内只考虑 $j>i$，以及只考虑邻居单元的一个固定子集）以避免重复计算。\n\nB. 对于任何 $L<3r_c$ 的情况，强制 $n=3$ 并仅使用标准的 $3 \\times 3 \\times 3$ 模板总是充分的，因为它覆盖了每个方向上一个单元内的所有邻居，而与 $a$ 无关。\n\nC. 当 $r_c<L<2r_c$ 时，设置 $n=1$，这样所有粒子都占据一个单一单元（$a=L$）。使用最小镜像约定计算所有不同粒子对之间的距离；限制为 $j>i$ 以避免重复计算。这在 PBC 下能产生正确的邻居检测。\n\nD. 当 $L \\le 2r_c$ 时，必须将盒子显式地复制成一个 $3 \\times 3 \\times 3$ 的超胞，并在那里构建单元列表；否则，靠近原始盒子相对面的粒子对将被漏掉。\n\nE. 当 $2r_c<L<3r_c$ 且 $n=2$ 以使得 $a=L/2>r_c$ 时，邻居模板必须包含 $5 \\times 5 \\times 5$ 个单元（每个维度上的偏移量为 $-2,-1,0,1,2$），以考虑在 PBC 下可能跨越两个面的环绕情况；在这种情况下，标准的 $3 \\times 3 \\times 3$ 模板是不充分的。", "solution": "问题陈述描述了一个标准的计算物理场景，涉及在带有周期性边界条件（PBC）的立方盒子中对粒子使用链式网格邻居搜索算法。所提出策略的有效性取决于该算法的基本原理，特别是在指定的“小盒子”情况，即盒子边长 $L$ 小于势截断半径 $r_c$ 的三倍，也就是 $L < 3r_c$。\n\n标准链式网格方法采用 $3 \\times 3 \\times 3$ 的邻居单元模板，其正确性的首要条件是单元边长 $a$ 必须大于或等于截断半径 $r_c$，即 $a \\ge r_c$。由于盒子在每个维度上被划分为 $n$ 个单元，我们有 $a = L/n$。该条件变为 $L/n \\ge r_c$，等价于 $n \\le L/r_c$。如果这个条件不满足，即 $a < r_c$，那么距离小于 $r_c$ 的粒子可能存在于非直接相邻的单元中，这使得 $3 \\times 3 \\times 3$ 模板不充分。在这种情况下，搜索模板必须被扩展，以包含与中心单元距离在 $r_c$ 内的所有单元。周期性边界条件的正确实现不是通过显式复制盒子，而是通过使用模运算来环绕处理单元索引。对于维度 $k$ 中索引为 $c_k$ 的单元，其偏移量为 $\\delta_k$ 的邻居索引为 $(c_k + \\delta_k) \\pmod n$。为避免将每对相互作用计算两次，必须使用“半壳层”或类似的约定，例如，对每个中心单元只搜索 $26$ 个邻居单元中的一个特定子集。\n\n问题陈述已经过验证，被认定具有科学依据、提法恰当且客观。我们现在开始评估每个提出的策略。\n\nA. 当 $2r_c \\le L < 3r_c$ 时，选择 $n=2$ 以使得 $a=L/2>r_c$。对每个单元，搜索标准的 $3 \\times 3 \\times 3$ 模板（单元自身以及所有面、边、角相邻的邻居单元），邻居单元索引对 $2$ 取模以实施 PBC。使用“半壳层”约定（例如，在同一单元内只考虑 $j>i$，以及只考虑邻居单元的一个固定子集）以避免重复计算。\n\n提出的情况是 $2r_c \\le L < 3r_c$。该策略建议将每个维度的单元数设置为 $n=2$。这得到的单元边长为 $a = L/2$。由给定条件 $2r_c \\le L$，两边除以 $2$ 可得 $r_c \\le L/2$，即 $r_c \\le a$。选项中提到的严格不等式 $a > r_c$ 是这个有效范围的一个子集。由于基本条件 $a \\ge r_c$ 得到满足，使用标准的 $3 \\times 3 \\times 3$ 邻居单元模板确实是正确且充分的，可以找到所有相互作用的粒子对。使用对 $n=2$ 取模的环绕单元索引是处理单元网格周期性边界条件的正确方法。提及使用半壳层约定来避免重复计算粒子对相互作用（例如，对于同一单元内的粒子，只检查 $j>i$ 的粒子对 $(i,j)$，并且只检查邻居单元的一个非冗余子集）是正确实现所必需的细节。这个策略是完全合理的。\n结论：**正确**。\n\nB. 对于任何 $L<3r_c$ 的情况，强制 $n=3$ 并仅使用标准的 $3 \\times 3 \\times 3$ 模板总是充分的，因为它覆盖了每个方向上一个单元内的所有邻居，而与 $a$ 无关。\n\n该策略建议对于任何 $L < 3r_c$ 的情况都设置 $n=3$。单元边长将为 $a = L/3$。由条件 $L < 3r_c$，我们得到 $L/3 < r_c$，即 $a < r_c$。如前所述，如果单元尺寸 $a$ 小于截断半径 $r_c$，标准的 $3 \\times 3 \\times 3$ 模板是不充分的。两个粒子之间的距离可能小于 $r_c$，但它们却位于非直接相邻的单元中。例如，一个位于单元边界的粒子，可能与两格之外的另一个粒子距离在 $r_c$ 之内。所提供的理由（“因为它覆盖了每个方向上一个单元内的所有邻居”）只是描述了 $3 \\times 3 \\times 3$ 模板的作用，但未能认识到当 $a < r_c$ 时这是不充分的。因此，这个策略存在根本性缺陷。\n结论：**错误**。\n\nC. 当 $r_c<L<2r_c$ 时，设置 $n=1$，这样所有粒子都占据一个单一单元（$a=L$）。使用最小镜像约定计算所有不同粒子对之间的距离；限制为 $j>i$ 以避免重复计算。这在 PBC 下能产生正确的邻居检测。\n\n在 $r_c < L < 2r_c$ 的情况下，该策略建议使用 $n=1$。这将使得单元边长 $a = L$。整个模拟盒子变成了一个单一的单元。标准链式网格方法的条件 $a \\ge r_c$ 变为 $L \\ge r_c$，这在指定的范围 $r_c < L$ 内是满足的。只有一个单元时，“邻居单元”的概念指的是盒子自身的周期性镜像。对该单元及其邻居的搜索等同于对盒子内 $N$ 个粒子进行全对检查，其中每对 $(\\vec{r}_i, \\vec{r}_j)$ 之间的距离使用最小镜像约定（MIC）计算。MIC 通过寻找一个粒子与另一个粒子的所有周期性镜像之间的最短距离，正确地处理了周期性边界条件。将粒子对索引限制为 $j>i$ 是避免重复计算的标准程序。虽然在计算上等同于一个暴力的 $O(N^2)$ 算法，但这个过程保证是正确的。\n结论：**正确**。\n\nD. 当 $L \\le 2r_c$ 时，必须将盒子显式地复制成一个 $3 \\times 3 \\times 3$ 的超胞，并在那里构建单元列表；否则，靠近原始盒子相对面的粒子对将被漏掉。\n\n这个选项声称，对于 $L \\le 2r_c$ 的情况，必须将模拟盒子显式复制成一个包含 $27$ 个原始系统副本的 $3 \\times 3 \\times 3$ 超胞。这是错误的。一个正确实现的链式网格算法通过环绕处理单元索引来高效地处理周期性边界条件，如选项 A 的分析中所述。这种算术环绕处理可以正确地识别跨越周期性边界的粒子对，而无需创建一个庞大的、显式的超胞。声称否则会“漏掉”粒子对的说法是不正确的；它反映了对现代模拟代码中如何实现 PBC 的误解。选项 A 和 C 中描述的过程是这一必要性声明的反例。显式复制是一种概念上简单但在计算上浪费的方法，并非必需。\n结论：**错误**。\n\nE. 当 $2r_c<L<3r_c$ 且 $n=2$ 以使得 $a=L/2>r_c$ 时，邻居模板必须包含 $5 \\times 5 \\times 5$ 个单元（每个维度上的偏移量为 $-2,-1,0,1,2$），以考虑在 PBC 下可能跨越两个面的环绕情况；在这种情况下，标准的 $3 \\times 3 \\times 3$ 模板是不充分的。\n\n这个选项的初始设置与选项 A 相同：$2r_c < L < 3r_c$ 且 $n=2$。这意味着 $a = L/2 > r_c$。如前所述，条件 $a > r_c$ 正是使标准 $3 \\times 3 \\times 3$ 模板变得充分的要求。声称该模板*不充分*并且需要一个更大的 $5 \\times 5 \\times 5$ 模板的说法，与链式网格算法的基本原理直接矛盾。只有当 $a < r_c$ 时，才需要更大的模板。此外，当 $n=2$ 时，由于单元索引使用模 $2$ 算术，使用高达 $\\pm 2$ 的偏移量是多余的。例如，偏移量 $\\delta_x = 2$ 等价于偏移量 $\\delta_x = 0$，因为 $2 \\pmod 2 = 0$。偏移量 $\\delta_x = -1$ 等价于 $\\delta_x = 1$，因为 $-1 \\pmod 2 = 1$。所提出的 $5 \\times 5 \\times 5$ 模板在这种情况下既不必要也无意义。\n结论：**错误**。", "answer": "$$\\boxed{AC}$$", "id": "2416982"}, {"introduction": "为了模拟百万甚至数十亿粒子的系统，并行计算是不可或缺的。本练习 [@problem_id:2416963] 将带你实践一种标准的并行化技术——区域分解法，用于邻居搜索。你将设计一个算法，将模拟区域分配给不同的处理器，并通过管理“幽灵”粒子（ghost particles）来正确处理跨越处理器边界的相互作用，同时避免重复计算。", "problem": "给定一个边长为 $L_x$ 和 $L_y$ 的二维周期性区域，其中包含 $N$ 个位置固定的质点 $\\{(x_i,y_i)\\}_{i=1}^N$。当且仅当两个粒子 $i$ 和 $j$ 在周期性区域上遵循最小镜像约定的欧几里得距离小于或等于一个指定的截断半径 $r_c$ 时，它们构成一个相互作用对。最小镜像距离定义如下：对于任意坐标差 $\\Delta x = x_j - x_i$，其周期性差值为 $\\Delta x' = \\Delta x - \\operatorname{round}\\left(\\frac{\\Delta x}{L_x}\\right)L_x$。类似地，$\\Delta y' = y_j - y_i - \\operatorname{round}\\left(\\frac{y_j - y_i}{L_y}\\right)L_y$。它们之间的距离为 $d_{ij} = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2}$。一个唯一的相互作用对是满足 $d_{ij} \\le r_c$ 的任意无序索引对 $(i,j)$，其中 $1 \\le i < j \\le N$。\n\n该区域在逻辑上被分解为 $P_x$ 个不重叠的子区域，这是通过沿 $x$ 方向将区间 $[0,L_x)$ 划分为宽度为 $L_x/P_x$ 的等宽条带实现的，并在 $x=0$ 和 $x=L_x$ 处施加周期性边界条件。对于 $k \\in \\{0,1,\\dots,P_x-1\\}$，第 $k$ 个子区域在 $x$ 方向上占据区间 $[k L_x/P_x,(k+1)L_x/P_x)$，在 $y$ 方向上占据整个区间 $[0,L_y)$。每个子区域通过在其左右 $x$ 边界各增加一个宽度为 $r_c$ 的幽灵区域来增强其局部粒子，导入任何其周期性 $x$ 坐标与任一边界的距离在 $r_c$ 之内的粒子。枚举相互作用对时，必须确保每个满足 $d_{ij} \\le r_c$ 的无序对 $(i,j)$（其中 $1 \\le i < j \\le N$）在全局范围内被精确计数一次，尽管幽灵区域会引入重复。\n\n您的程序必须针对下面的每个测试用例，使用一种遵循上述子区域分解和幽灵区域描述的算法，计算整个区域内唯一相互作用对的总数。所有坐标都使用相同的任意长度单位， $r_c$、$L_x$ 和 $L_y$ 也使用该单位。程序在与截断半径进行比较时，必须使用判据 $d_{ij} \\le r_c$。\n\n您的程序要使用的测试套件：\n- 测试用例 $1$ (一般情况): $L_x = 10.0$, $L_y = 10.0$, $r_c = 2.1$, $P_x = 3$，粒子位置由有序列表给出\n$\\left[(1.0,1.0),(2.5,1.0),(3.9,1.0),(4.8,9.5),(4.8,0.6),(9.6,5.0),(0.4,5.0),(6.7,5.0)\\right]$。\n- 测试用例 $2$ (边界与等值情况): $L_x = 8.0$, $L_y = 8.0$, $r_c = 2.0$, $P_x = 2$，粒子位置为\n$\\left[(0.5,0.5),(7.5,0.5),(4.0,4.0),(6.0,4.0)\\right]$。\n- 测试用例 $3$ (含有空子区域的稀疏情况): $L_x = 5.0$, $L_y = 5.0$, $r_c = 0.9$, $P_x = 4$，粒子位置为\n$\\left[(0.2,0.2),(2.6,4.7),(4.8,2.5)\\right]$。\n\n最终输出格式：您的程序应生成单行文本，其中包含所有三个测试用例的结果，形式为用方括号括起的逗号分隔列表，顺序与上述测试用例相同。每个结果必须是等于唯一相互作用对数量的整数，因此输出格式必须为 $[\\text{n}_1,\\text{n}_2,\\text{n}_3]$，其中每个 $\\text{n}_k$ 是一个整数。", "solution": "所呈现的问题是一个有效的计算物理练习。它具有科学依据、定义明确且客观。它描述了一种在分子模拟中用于高效计算短程相互作用的标准区域分解技术。所有参数和条件都已指定，从而可以得到唯一且可验证的解。我们将着手进行求解。\n\n该问题要求我们计算一个二维周期性区域内唯一相互作用粒子对的总数。任务的核心是实现一种基于区域分解的并行计算策略，其中区域被划分为多个纵向条带（子区域）。为了正确处理跨越子区域边界的相互作用，每个子区域不仅必须考虑其“局部”粒子，还必须考虑来自相邻区域的“幽灵”粒子。\n\n解决方案所依据的基本原理如下：\n\n1.  **最小镜像约定 (MIC)**：在周期性系统中，一个粒子与每个其他粒子的最近周期性镜像相互作用。距离计算必须考虑周期性边界。对于一个大小为 $L_x \\times L_y$ 的区域中坐标差为 $\\Delta x$ 和 $\\Delta y$ 的粒子对，MIC规定有效分离矢量分量为 $\\Delta x' = \\Delta x - L_x \\cdot \\operatorname{round}(\\frac{\\Delta x}{L_x})$ 和 $\\Delta y' = \\Delta y - L_y \\cdot \\operatorname{round}(\\frac{\\Delta y}{L_y})$。距离则为 $d_{ij} = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2}$。如果 $d_{ij} \\le r_c$（其中 $r_c$ 是截断半径），则发生相互作用。为提高计算效率，我们将比较距离的平方：$d_{ij}^2 \\le r_c^2$。\n\n2.  **区域分解**：全局区域沿 $x$ 轴被分解为 $P_x$ 个子区域。每个粒子根据其 $x$ 坐标被唯一地分配到一个“属主”或“局部”子区域。这种分配是排他的；坐标为 $x_i$ 的粒子 $i$ 属于子区域 $k$，如果 $x_i \\in [k \\cdot L_x/P_x, (k+1) \\cdot L_x/P_x)$。\n\n3.  **幽灵区域**：对于位于子区域 $k$ 中的粒子 $i$，任何与之相互作用的伙伴 $j$ 都必须位于距离 $r_c$ 之内。这意味着它们的周期性 $x$ 距离最多为 $r_c$。因此，为了找到涉及其局部粒子的所有对，子区域 $k$ 只需要从其自身边界导入一层宽度为 $r_c$ 的“幽灵层”内的粒子副本（幽灵粒子）。\n\n4.  **唯一对计数**：为防止对 $(i, j)$ 的重复计数（例如，子区域 $k$ 计数了 $(i, j)$，而子区域 $m$ 也计数了 $(j, i)$），需要一个严格的计数协议。一个通用且正确的约定是将计数对 $(i, j)$ 的责任分配给“拥有”索引较小粒子的子区域。该算法的结构如下：子区域 $k$ 遍历其局部粒子 $i$。对于每个这样的 $i$，它在其扩展区域内检查与所有其他粒子 $j$（包括局部和幽灵粒子）的相互作用，但仅当原始粒子索引满足 $i < j$ 时才计数该对。这保证了每个唯一的对 $(i, j)$ 都会被拥有粒子 $i$ 的子区域精确地考虑计数一次。\n\n该算法对每个测试用例按以下步骤进行：\n\n1.  **初始化**：对于一个给定的测试用例，其参数为 $L_x, L_y, r_c, P_x$ 以及 $N$ 个粒子位置，我们将总配对数初始化为 $0$。我们计算截断半径的平方 $r_c^2$ 和每个子区域的宽度 $W = L_x / P_x$。\n\n2.  **粒子归属**：将 $N$ 个粒子中的每一个分配给一个属主子区域。对于位于位置 $(x_i, y_i)$ 的粒子 $i$，其属主子区域索引 $k$ 计算为 $k = \\lfloor x_i / W \\rfloor$。我们必须确保将 $k$ 裁剪到范围 $[0, P_x-1]$ 内。\n\n3.  **子区域迭代**：我们从 $0$ 到 $P_x-1$ 遍历每个子区域 $k$。\n\n4.  **识别局部和幽灵粒子**：对于当前子区域 $k$，我们首先确定其局部粒子的索引集合 $L_k$。然后，我们构建一个更大的索引集合 $S_k$，该集合包含子区域扩展区域内的所有粒子。子区域 $k$ 覆盖 $[k \\cdot W, (k+1) \\cdot W)$，其沿 $x$ 轴的扩展区域为 $[k \\cdot W - r_c, (k+1) \\cdot W + r_c)$。如果粒子 $j$ 在位置 $x_j$ 的任何周期性镜像 $x_j + m \\cdot L_x$（其中 $m \\in \\{-1, 0, 1\\}$）落在此区间内，则该粒子属于此扩展区域。\n\n5.  **对计数**：对于当前子区域 $k$，我们遍历其每个局部粒子 $i \\in L_k$。对于每个 $i$，我们再遍历所有满足索引条件 $i < j$ 的粒子 $j \\in S_k$。对于每个这样的对 $(i, j)$，我们计算其最小镜像约定下的平方距离 $d_{ij}^2$。如果 $d_{ij}^2 \\le r_c^2$，则将总配对数加一。\n\n6.  **最终结果**：在遍历所有子区域后，累积的总配对数即为该测试用例的最终答案。对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(Lx, Ly, rc, Px, positions):\n    \"\"\"\n    Computes the number of interacting pairs for a single test case\n    using a domain decomposition algorithm.\n    \"\"\"\n    particles = np.array(positions, dtype=np.float64)\n    N = len(particles)\n    if N == 0:\n        return 0\n        \n    rc_sq = rc**2\n    subdomain_width = Lx / Px\n\n    # Assign each particle to an owner subdomain based on its x-coordinate.\n    # The interval for subdomain k is [k*width, (k+1)*width).\n    # np.floor(x / width) correctly assigns particles to subdomains.\n    # We clip to handle the case where a particle might be exactly at x=Lx.\n    owner = np.floor(particles[:, 0] / subdomain_width).astype(int)\n    owner = np.clip(owner, 0, Px - 1)\n\n    total_pairs = 0\n    box_dims = np.array([Lx, Ly])\n\n    def mic_dist_sq(p1, p2):\n        \"\"\"Calculates the squared Euclidean distance under the Minimum Image Convention.\"\"\"\n        delta = p2 - p1\n        # This implements delta' = delta - L * round(delta/L)\n        delta -= box_dims * np.round(delta / box_dims)\n        return np.dot(delta, delta)\n\n    # Iterate through each subdomain\n    for k in range(Px):\n        # Identify particles local to this subdomain\n        local_indices = np.where(owner == k)[0]\n        \n        # If the subdomain is empty, no pairs will be counted by it.\n        if len(local_indices) == 0:\n            continue\n\n        # Identify all particles in the extended subdomain (local + ghosts)\n        # The extended region for subdomain k is [xmin - rc, xmax + rc).\n        xmin = k * subdomain_width\n        xmax = (k + 1) * subdomain_width\n        ext_min = xmin - rc\n        ext_max = xmax + rc\n\n        subdomain_particle_indices = []\n        for j in range(N):\n            x_j = particles[j, 0]\n            # Check if particle j or its periodic images fall in the extended region.\n            # Checking images at m=-1, 0, 1 is sufficient for rc  Lx/2, a safe assumption.\n            if (ext_min = x_j  ext_max) or \\\n               (ext_min = x_j + Lx  ext_max) or \\\n               (ext_min = x_j - Lx  ext_max):\n                subdomain_particle_indices.append(j)\n        \n        # Count pairs according to the rule:\n        # Particle i must be local to subdomain k.\n        # Particle j can be local or ghost.\n        # The index condition i  j ensures each pair is counted only once.\n        for i in local_indices:\n            for j in subdomain_particle_indices:\n                if i  j:\n                    if mic_dist_sq(particles[i], particles[j]) = rc_sq:\n                        total_pairs += 1\n\n    return total_pairs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"Lx\": 10.0, \"Ly\": 10.0, \"rc\": 2.1, \"Px\": 3,\n            \"positions\": [(1.0, 1.0), (2.5, 1.0), (3.9, 1.0), (4.8, 9.5), \n                          (4.8, 0.6), (9.6, 5.0), (0.4, 5.0), (6.7, 5.0)]\n        },\n        # Test case 2\n        {\n            \"Lx\": 8.0, \"Ly\": 8.0, \"rc\": 2.0, \"Px\": 2,\n            \"positions\": [(0.5, 0.5), (7.5, 0.5), (4.0, 4.0), (6.0, 4.0)]\n        },\n        # Test case 3\n        {\n            \"Lx\": 5.0, \"Ly\": 5.0, \"rc\": 0.9, \"Px\": 4,\n            \"positions\": [(0.2, 0.2), (2.6, 4.7), (4.8, 2.5)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        num_pairs = solve_case(\n            case[\"Lx\"], case[\"Ly\"], case[\"rc\"], case[\"Px\"], case[\"positions\"]\n        )\n        results.append(num_pairs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2416963"}]}