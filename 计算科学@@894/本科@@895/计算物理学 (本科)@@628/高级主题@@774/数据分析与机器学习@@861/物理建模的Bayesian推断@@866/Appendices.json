{"hands_on_practices": [{"introduction": "我们从一个物理学中的经典问题开始：根据盖革计数器的读数推断放射性衰变率。这个练习是掌握贝叶斯推断核心流程的绝佳起点，它将引导你为物理参数（衰变率 $\\lambda$）选择合适的似然函数（泊松分布）和先验分布（伽马分布）。通过这个实践，你将亲手实现贝叶斯更新过程，直观地理解先验知识如何通过实验数据得到更新，从而形成更精确的后验认知 [@problem_id:2375997]。", "problem": "一台盖革计数器记录来自一个固定放射源的离散探测计数。该探测过程被建模为一个恒定衰变率 $\\lambda$（单位为 $\\mathrm{s^{-1}}$）的均匀泊松过程。在长度为 $\\{t_i\\}$（单位为 $\\mathrm{s}$）的非重叠时间窗口上，计数 $\\{k_i\\}$ 在给定 $\\lambda$ 的条件下被假定为条件独立的，其中 $k_i$ 服从 $\\mathrm{Poisson}(\\lambda t_i)$ 分布。\n\n假设 $\\lambda$ 的先验分布遵循形状参数为 $\\alpha_0$、速率参数为 $\\beta_0$ 的伽马分布，其密度函数参数化为\n$$\np(\\lambda \\mid \\alpha_0,\\beta_0) = \\frac{\\beta_0^{\\alpha_0}}{\\Gamma(\\alpha_0)} \\lambda^{\\alpha_0 - 1} e^{-\\beta_0 \\lambda}, \\quad \\lambda > 0,\n$$\n其中 $\\alpha_0 > 0$ 是无量纲的，而 $\\beta_0 > 0$ 的单位是 $\\mathrm{s}$。\n\n任务：对于下方的每个测试用例，计算后验均值 $\\mathbb{E}[\\lambda \\mid \\{(t_i,k_i)\\}]$，单位为 $\\mathrm{s^{-1}}$。将每个结果以 $\\mathrm{s^{-1}}$ 为单位表示，并四舍五入到六位小数。\n\n测试套件：\n- 案例1（一般情况）：计数 $k = (1,0,2)$，持续时间 $t = (1.0,2.0,3.0)\\,\\mathrm{s}$，先验 $\\alpha_0 = 1.0$，$\\beta_0 = 1.0\\,\\mathrm{s}$。\n- 案例2（零计数）：计数 $k = (0,0)$，持续时间 $t = (10.0,20.0)\\,\\mathrm{s}$，先验 $\\alpha_0 = 2.0$，$\\beta_0 = 5.0\\,\\mathrm{s}$。\n- 案例3（长曝光，高计数）：计数 $k = (130,250,410)$，持续时间 $t = (100.0,200.0,300.0)\\,\\mathrm{s}$，先验 $\\alpha_0 = 0.5$，$\\beta_0 = 0.1\\,\\mathrm{s}$。\n- 案例4（极短窗口）：计数 $k = (0,1)$，持续时间 $t = (0.001,0.002)\\,\\mathrm{s}$，先验 $\\alpha_0 = 1.0$，$\\beta_0 = 1.0\\,\\mathrm{s}$。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含四个案例的结果，以逗号分隔的列表形式包含在方括号内，按案例1、案例2、案例4的顺序排列。例如，一个有效的格式是 $[x_1,x_2,x_3,x_4]$，其中每个 $x_j$ 是以 $\\mathrm{s^{-1}}$ 为单位、四舍五入到六位小数的后验均值。", "solution": "所述问题是有效的。它在科学上基于核物理和贝叶斯统计的原理，问题提法良好，并包含了获得唯一解所需的所有必要信息。我们将进行推导。\n\n目标是求出泊松过程衰变率参数 $\\lambda$ 的后验均值。此项任务的基础是贝叶斯定理，该定理指出后验概率与似然和先验概率的乘积成正比。\n$$\np(\\text{参数} \\mid \\text{数据}) \\propto p(\\text{数据} \\mid \\text{参数}) \\cdot p(\\text{参数})\n$$\n在此问题中，参数是 $\\lambda$，数据我们表示为 $\\mathcal{D}$，由一组观测值 $\\{ (t_i, k_i) \\}_{i=1}^N$ 组成，其中 $k_i$ 是在长度为 $t_i$ 的时间间隔内的探测计数值。\n\n首先，我们定义似然函数 $p(\\mathcal{D} \\mid \\lambda)$。问题陈述，每个计数 $k_i$ 均从参数为 $\\lambda t_i$ 的泊松分布中抽取。单个观测值的概率质量函数为：\n$$\nP(k_i \\mid \\lambda, t_i) = \\frac{(\\lambda t_i)^{k_i} e^{-\\lambda t_i}}{k_i!}\n$$\n鉴于观测值是条件独立的，整个数据集 $\\mathcal{D}$ 的似然是各个概率的乘积：\n$$\np(\\mathcal{D} \\mid \\lambda) = \\prod_{i=1}^{N} P(k_i \\mid \\lambda, t_i) = \\prod_{i=1}^{N} \\frac{(\\lambda t_i)^{k_i} e^{-\\lambda t_i}}{k_i!}\n$$\n在贝叶斯分析中，我们关心的是似然函数相对于参数 $\\lambda$ 的函数形式。因此，我们可以舍弃不依赖于 $\\lambda$ 的项，将它们并入一个归一化常数中。\n$$\np(\\mathcal{D} \\mid \\lambda) \\propto \\prod_{i=1}^{N} (\\lambda t_i)^{k_i} e^{-\\lambda t_i} = \\left( \\prod_{i=1}^{N} t_i^{k_i} \\right) \\left( \\prod_{i=1}^{N} \\lambda^{k_i} \\right) \\left( \\prod_{i=1}^{N} e^{-\\lambda t_i} \\right)\n$$\n$$\np(\\mathcal{D} \\mid \\lambda) \\propto \\lambda^{\\sum_{i=1}^{N} k_i} e^{-\\lambda \\sum_{i=1}^{N} t_i}\n$$\n我们定义总计数 $K = \\sum_{i=1}^{N} k_i$ 和总观测时间 $T = \\sum_{i=1}^{N} t_i$。似然函数简化为：\n$$\np(\\mathcal{D} \\mid \\lambda) \\propto \\lambda^K e^{-\\lambda T}\n$$\n\n接下来，我们考虑 $\\lambda$ 的先验分布，它被给定为一个形状参数为 $\\alpha_0 > 0$ 和速率参数为 $\\beta_0 > 0$ 的伽马分布。\n$$\np(\\lambda \\mid \\alpha_0, \\beta_0) = \\frac{\\beta_0^{\\alpha_0}}{\\Gamma(\\alpha_0)} \\lambda^{\\alpha_0 - 1} e^{-\\beta_0 \\lambda}\n$$\n先验分布的核，忽略归一化常数，为：\n$$\np(\\lambda \\mid \\alpha_0, \\beta_0) \\propto \\lambda^{\\alpha_0 - 1} e^{-\\beta_0 \\lambda}\n$$\n\n现在，我们将似然函数和先验分布结合起来，求出后验分布 $p(\\lambda \\mid \\mathcal{D}, \\alpha_0, \\beta_0)$：\n$$\np(\\lambda \\mid \\mathcal{D}, \\alpha_0, \\beta_0) \\propto p(\\mathcal{D} \\mid \\lambda) \\cdot p(\\lambda \\mid \\alpha_0, \\beta_0)\n$$\n$$\np(\\lambda \\mid \\mathcal{D}, \\alpha_0, \\beta_0) \\propto (\\lambda^K e^{-\\lambda T}) \\cdot (\\lambda^{\\alpha_0 - 1} e^{-\\beta_0 \\lambda}) = \\lambda^{K + \\alpha_0 - 1} e^{-(\\beta_0 + T)\\lambda}\n$$\n此表达式是伽马分布的核。这证实了伽马分布是泊松似然的共轭先验，意味着后验分布也是一个伽马分布。这个后验伽马分布的参数，我们记为 $\\alpha_N$ 和 $\\beta_N$，可以通过观察得到：\n$$\n\\alpha_N = \\alpha_0 + K = \\alpha_0 + \\sum_{i=1}^{N} k_i\n$$\n$$\n\\beta_N = \\beta_0 + T = \\beta_0 + \\sum_{i=1}^{N} t_i\n$$\n任务是计算后验均值 $\\mathbb{E}[\\lambda \\mid \\mathcal{D}]$。服从形状参数为 $\\alpha$ 和速率参数为 $\\beta$ 的伽马分布的随机变量 $X$ 的期望值是 $\\mathbb{E}[X] = \\alpha/\\beta$。将此应用于我们的后验分布，我们得到 $\\lambda$ 的后验均值：\n$$\n\\mathbb{E}[\\lambda \\mid \\mathcal{D}] = \\frac{\\alpha_N}{\\beta_N} = \\frac{\\alpha_0 + \\sum k_i}{\\beta_0 + \\sum t_i}\n$$\n这就是求解的通用公式。我们现在将其应用于每个指定的测试用例。\n\n案例1：$k = (1, 0, 2)$，$t = (1.0, 2.0, 3.0)\\,\\mathrm{s}$，$\\alpha_0 = 1.0$，$\\beta_0 = 1.0\\,\\mathrm{s}$。\n$\\sum k_i = 1+0+2=3$。\n$\\sum t_i = 1.0+2.0+3.0=6.0\\,\\mathrm{s}$。\n$\\mathbb{E}[\\lambda \\mid \\mathcal{D}] = \\frac{1.0 + 3}{1.0 + 6.0} = \\frac{4.0}{7.0} \\approx 0.571429\\,\\mathrm{s^{-1}}$。\n\n案例2：$k = (0, 0)$，$t = (10.0, 20.0)\\,\\mathrm{s}$，$\\alpha_0 = 2.0$，$\\beta_0 = 5.0\\,\\mathrm{s}$。\n$\\sum k_i = 0+0=0$。\n$\\sum t_i = 10.0+20.0=30.0\\,\\mathrm{s}$。\n$\\mathbb{E}[\\lambda \\mid \\mathcal{D}] = \\frac{2.0 + 0}{5.0 + 30.0} = \\frac{2.0}{35.0} \\approx 0.057143\\,\\mathrm{s^{-1}}$。\n\n案例3：$k = (130, 250, 410)$，$t = (100.0, 200.0, 300.0)\\,\\mathrm{s}$，$\\alpha_0 = 0.5$，$\\beta_0 = 0.1\\,\\mathrm{s}$。\n$\\sum k_i = 130+250+410=790$。\n$\\sum t_i = 100.0+200.0+300.0=600.0\\,\\mathrm{s}$。\n$\\mathbb{E}[\\lambda \\mid \\mathcal{D}] = \\frac{0.5 + 790}{0.1 + 600.0} = \\frac{790.5}{600.1} \\approx 1.317280\\,\\mathrm{s^{-1}}$。\n\n案例4：$k = (0, 1)$，$t = (0.001, 0.002)\\,\\mathrm{s}$，$\\alpha_0 = 1.0$，$\\beta_0 = 1.0\\,\\mathrm{s}$。\n$\\sum k_i = 0+1=1$。\n$\\sum t_i = 0.001+0.002=0.003\\,\\mathrm{s}$。\n$\\mathbb{E}[\\lambda \\mid \\mathcal{D}] = \\frac{1.0 + 1}{1.0 + 0.003} = \\frac{2.0}{1.003} \\approx 1.994018\\,\\mathrm{s^{-1}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the posterior mean of a Poisson rate parameter for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: k=(1,0,2), t=(1.0,2.0,3.0), a0=1.0, b0=1.0\n        {'k': [1, 0, 2], 't': [1.0, 2.0, 3.0], 'a0': 1.0, 'b0': 1.0},\n        # Case 2: k=(0,0), t=(10.0,20.0), a0=2.0, b0=5.0\n        {'k': [0, 0], 't': [10.0, 20.0], 'a0': 2.0, 'b0': 5.0},\n        # Case 3: k=(130,250,410), t=(100.0,200.0,300.0), a0=0.5, b0=0.1\n        {'k': [130, 250, 410], 't': [100.0, 200.0, 300.0], 'a0': 0.5, 'b0': 0.1},\n        # Case 4: k=(0,1), t=(0.001,0.002), a0=1.0, b0=1.0\n        {'k': [0, 1], 't': [0.001, 0.002], 'a0': 1.0, 'b0': 1.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        # The posterior distribution for lambda is a Gamma distribution with\n        # updated parameters alpha_N and beta_N.\n        # alpha_N = alpha_0 + sum(k_i)\n        # beta_N = beta_0 + sum(t_i)\n        # The posterior mean E[lambda | data] is alpha_N / beta_N.\n\n        # Calculate total counts and total time\n        total_counts = np.sum(case['k'])\n        total_time = np.sum(case['t'])\n        \n        # Get prior parameters\n        alpha_0 = case['a0']\n        beta_0 = case['b0']\n        \n        # Calculate posterior parameters\n        alpha_n = alpha_0 + total_counts\n        beta_n = beta_0 + total_time\n        \n        # Calculate posterior mean\n        posterior_mean = alpha_n / beta_n\n        \n        # Format the result as a string rounded to six decimal places.\n        # The format specifier \"{:.6f}\" handles both rounding and formatting.\n        results.append(f\"{posterior_mean:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2375997"}, {"introduction": "在掌握了单参数估计后，我们将挑战一个更复杂的场景：利用一系列罗盘读数来绘制局部磁场的二维分量。这个练习将带你进入线性高斯模型的贝叶斯推断领域，这是解决众多科学与工程问题的基石。你将学习如何使用向量和矩阵来构建模型，并体会先验分布在其中扮演的重要角色——它不仅代表了先验知识，还能对模型进行正则化，确保在数据不理想的情况下也能得到稳健的解 [@problem_id:2376023]。", "problem": "您将处理一个物理传感场景，任务是仅使用在不同仪器方向上采集的类似罗盘的标量读数，通过贝叶斯推断来估计地球磁场矢量的水平分量。设想一个理想化的单轴磁传感器，它被刚性地固定在一个平台上。在一个已知的偏航方向角 $\\theta_k$（以弧度为单位）下，传感器报告一个标量读数 $m_k$（单位为微特斯拉，$\\mu$T），该读数等于局部水平磁场在其体坐标系传感轴上的投影，并受到加性噪声的干扰。水平磁场矢量在局部东-北坐标系中表示为 $\\mathbf{B} = [B_x, B_y]^\\top$，其中 $B_x$ 指向东，$B_y$ 指向北。测量模型为\n$$\nm_k = B_x \\cos(\\theta_k) + B_y \\sin(\\theta_k) + \\varepsilon_k,\n$$\n其中 $\\varepsilon_k$ 是独立同分布的高斯噪声项，其均值为零，标准差 $\\sigma$ 已知。假设场分量服从零均值各向同性高斯先验分布，\n$$\n[B_x, B_y]^\\top \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_0^2 \\mathbf{I}_2).\n$$\n您的任务是首先从第一性原理进行推导，然后实现一个程序，用以计算一系列给定测试用例中 $B_x$ 和 $B_y$ 的贝叶斯后验均值估计。该程序不得读取输入；它必须将提供的测试套件作为常量包含在内并使用。程序应使用上述指定的高斯先验和似然来计算每个测试用例的后验均值，并为每个用例输出 $[\\hat{B}_x, \\hat{B}_y]$ 对。\n\n所有角度必须以弧度处理；所有磁场值必须以微特斯拉（$\\mu$T）表示。每个分量的最终报告估计值必须四舍五入到三位小数。为保证数值稳定性，即使方向角密集聚集，您的方法也必须保持良定义；特别地，先验必须对推断过程进行正则化，以确保后验是良定义的。\n\n需要实现和求解的测试套件：\n- 测试用例 1（方向分布良好，中等噪声）：使用角度（弧度）$[0, \\pi/4, \\pi/2, 3\\pi/4, \\pi, 5\\pi/4, 3\\pi/2, 7\\pi/4]$，测量值（$\\mu$T）$[25.5, -11.4066, -38.8, -46.3619, -24.9, 10.6066, 38.5, 46.2619]$，噪声标准差 $\\sigma = 1.0$（$\\mu$T），先验标准差 $\\sigma_0 = 100.0$（$\\mu$T）。\n- 测试用例 2（方向密集聚集，中低噪声）：使用角度（弧度）$[0.15, 0.20, 0.25, 0.30, 0.35]$，测量值（$\\mu$T）$[17.2596, 20.03415, 21.85932, 24.42936, 26.48858]$，噪声标准差 $\\sigma = 0.5$（$\\mu$T），先验标准差 $\\sigma_0 = 100.0$（$\\mu$T）。\n- 测试用例 3（正交方向，极低噪声，最少数据）：使用角度（弧度）$[0.0, 1.5707963267948966]$，测量值（$\\mu$T）$[-29.98, 14.97]$，噪声标准差 $\\sigma = 0.1$（$\\mu$T），先验标准差 $\\sigma_0 = 100.0$（$\\mu$T）。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的 $B_x$ 和 $B_y$ 的四舍五入后验均值的双元素列表。例如，总体格式必须是\n$$\n[[\\hat{B}_{x,1}, \\hat{B}_{y,1}], [\\hat{B}_{x,2}, \\hat{B}_{y,2}], [\\hat{B}_{x,3}, \\hat{B}_{y,3}]]\n$$\n每个数字都四舍五入到三位小数并以 $\\mu$T 表示，但不打印单位。该行不得包含任何其他文本。", "solution": "所提出的问题是贝叶斯推断在线性高斯状态估计问题中的一个典范应用，这是计算物理学和工程学中的一项基本任务。该问题是适定的，有科学依据，并为获得唯一解提供了所有必要信息。我们从第一性原理开始推导。\n\n待估计的状态是水平磁场矢量，表示为 $\\mathbf{B} = [B_x, B_y]^\\top$。测量值由一个线性模型控制。对于一组 $N$ 个测量值，我们有如下系统：\n$$\n\\mathbf{m} = \\mathbf{H}\\mathbf{B} + \\boldsymbol{\\varepsilon}\n$$\n其中 $\\mathbf{m} = [m_1, m_2, \\dots, m_N]^\\top$ 是标量测量矢量，$\\boldsymbol{\\varepsilon} = [\\varepsilon_1, \\varepsilon_2, \\dots, \\varepsilon_N]^\\top$ 是测量噪声矢量，$\\mathbf{H}$ 是尺寸为 $N \\times 2$ 的观测矩阵。$\\mathbf{H}$ 的第 $k$ 行对应第 $k$ 次测量，由 $[\\cos(\\theta_k), \\sin(\\theta_k)]$ 给出。\n\n问题给出了状态矢量 $\\mathbf{B}$ 的先验分布和噪声 $\\boldsymbol{\\varepsilon}$ 的分布。\n$\\mathbf{B}$ 的先验是一个零均值各向同性高斯分布：\n$$\np(\\mathbf{B}) = \\mathcal{N}(\\mathbf{B} | \\boldsymbol{\\mu}_0, \\boldsymbol{\\Sigma}_0)\n$$\n其先验均值为 $\\boldsymbol{\\mu}_0 = \\mathbf{0} = [0, 0]^\\top$，先验协方差为 $\\boldsymbol{\\Sigma}_0 = \\sigma_0^2 \\mathbf{I}_2$，其中 $\\mathbf{I}_2$ 是 $2 \\times 2$ 的单位矩阵。\n\n测量噪声项 $\\varepsilon_k$ 是独立同分布 (i.i.d.) 的高斯变量，均值为零，方差为 $\\sigma^2$，即 $\\varepsilon_k \\sim \\mathcal{N}(0, \\sigma^2)$。因此，噪声矢量 $\\boldsymbol{\\varepsilon}$ 服从多元高斯分布 $\\mathcal{N}(\\boldsymbol{\\varepsilon} | \\mathbf{0}, \\mathbf{R})$，其中测量噪声协方差矩阵为 $\\mathbf{R} = \\sigma^2 \\mathbf{I}_N$。\n\n根据测量模型，给定状态 $\\mathbf{B}$ 时观测到 $\\mathbf{m}$ 的似然也是高斯分布：\n$$\np(\\mathbf{m}|\\mathbf{B}) = \\mathcal{N}(\\mathbf{m} | \\mathbf{H}\\mathbf{B}, \\mathbf{R})\n$$\n这是因为 $\\mathbf{m}$ 是高斯变量 $\\boldsymbol{\\varepsilon}$ 的线性变换（$\\boldsymbol{\\varepsilon} = \\mathbf{m} - \\mathbf{H}\\mathbf{B}$）。\n\n我们的目标是使用贝叶斯定理来找到状态的后验分布 $p(\\mathbf{B}|\\mathbf{m})$：\n$$\np(\\mathbf{B}|\\mathbf{m}) \\propto p(\\mathbf{m}|\\mathbf{B}) p(\\mathbf{B})\n$$\n由于先验和似然都是高斯分布，后验分布也是高斯分布。我们将其表示为 $p(\\mathbf{B}|\\mathbf{m}) = \\mathcal{N}(\\mathbf{B} | \\boldsymbol{\\mu}_N, \\boldsymbol{\\Sigma}_N)$，其中 $\\boldsymbol{\\mu}_N$ 是后验均值，$\\boldsymbol{\\Sigma}_N$ 是后验协方差。\n\n在线性高斯模型中，后验参数的标准公式为：\n$$\n\\boldsymbol{\\Sigma}_N^{-1} = \\boldsymbol{\\Sigma}_0^{-1} + \\mathbf{H}^\\top \\mathbf{R}^{-1} \\mathbf{H}\n$$\n$$\n\\boldsymbol{\\mu}_N = \\boldsymbol{\\Sigma}_N (\\boldsymbol{\\Sigma}_0^{-1}\\boldsymbol{\\mu}_0 + \\mathbf{H}^\\top \\mathbf{R}^{-1} \\mathbf{m})\n$$\n代入我们特定的先验和噪声参数：$\\boldsymbol{\\mu}_0 = \\mathbf{0}$，$\\boldsymbol{\\Sigma}_0^{-1} = (\\sigma_0^2 \\mathbf{I}_2)^{-1} = \\frac{1}{\\sigma_0^2}\\mathbf{I}_2$，以及 $\\mathbf{R}^{-1} = (\\sigma^2 \\mathbf{I}_N)^{-1} = \\frac{1}{\\sigma^2}\\mathbf{I}_N$。\n\n后验协方差的逆（或后验精度矩阵）变为：\n$$\n\\boldsymbol{\\Sigma}_N^{-1} = \\frac{1}{\\sigma_0^2}\\mathbf{I}_2 + \\frac{1}{\\sigma^2}\\mathbf{H}^\\top \\mathbf{H}\n$$\n后验均值，即我们期望的估计值 $\\hat{\\mathbf{B}}$，是：\n$$\n\\hat{\\mathbf{B}} = \\boldsymbol{\\mu}_N = \\boldsymbol{\\Sigma}_N \\left(\\left(\\frac{1}{\\sigma_0^2}\\mathbf{I}_2\\right)\\mathbf{0} + \\mathbf{H}^\\top \\left(\\frac{1}{\\sigma^2}\\mathbf{I}_N\\right) \\mathbf{m}\\right) = \\boldsymbol{\\Sigma}_N \\left(\\frac{1}{\\sigma^2}\\mathbf{H}^\\top \\mathbf{m}\\right)\n$$\n代入 $\\boldsymbol{\\Sigma}_N^{-1}$ 的表达式：\n$$\n\\hat{\\mathbf{B}} = \\left( \\frac{1}{\\sigma_0^2}\\mathbf{I}_2 + \\frac{1}{\\sigma^2}\\mathbf{H}^\\top \\mathbf{H} \\right)^{-1} \\left(\\frac{1}{\\sigma^2}\\mathbf{H}^\\top \\mathbf{m}\\right)\n$$\n为简化起见，我们可以将逆矩阵内部的表达式乘以 $\\sigma^2$，并将逆矩阵外部的项也乘以 $\\sigma^2$：\n$$\n\\hat{\\mathbf{B}} = \\left( \\sigma^2 \\left( \\frac{1}{\\sigma_0^2}\\mathbf{I}_2 + \\frac{1}{\\sigma^2}\\mathbf{H}^\\top \\mathbf{H} \\right) \\right)^{-1} \\left(\\sigma^2 \\frac{1}{\\sigma^2}\\mathbf{H}^\\top \\mathbf{m}\\right)\n$$\n$$\n\\hat{\\mathbf{B}} = \\left( \\frac{\\sigma^2}{\\sigma_0^2}\\mathbf{I}_2 + \\mathbf{H}^\\top \\mathbf{H} \\right)^{-1} \\mathbf{H}^\\top \\mathbf{m}\n$$\n这就是 $\\mathbf{B}$ 的后验均值估计的最终表达式。项 $\\frac{\\sigma^2}{\\sigma_0^2}\\mathbf{I}_2$ 起到正则化项的作用。它为矩阵 $\\mathbf{H}^\\top \\mathbf{H}$ 的对角线增加了一个小的正值，确保了待求逆的矩阵始终是正定的，因而是可逆的。这对于数值稳定性至关重要，尤其是在 $\\mathbf{H}$ 的列近似共线（即方向角 $\\theta_k$ 密集聚集）的情况下，这种情况会使 $\\mathbf{H}^\\top \\mathbf{H}$ 变得病态或奇异。\n\n需要实现的算法如下：\n1. 对每个测试用例，定义数据向量 $\\boldsymbol{\\theta}$ 和 $\\mathbf{m}$，以及参数 $\\sigma$ 和 $\\sigma_0$。\n2. 构建 $N \\times 2$ 的观测矩阵 $\\mathbf{H}$，其中第 $k$ 行为 $[\\cos(\\theta_k), \\sin(\\theta_k)]$。\n3. 计算正则化参数 $\\lambda = (\\sigma/\\sigma_0)^2$。\n4. 计算 $2 \\times 2$ 矩阵 $\\mathbf{A} = \\mathbf{H}^\\top \\mathbf{H} + \\lambda \\mathbf{I}_2$。\n5. 计算 $2 \\times 1$ 向量 $\\mathbf{b} = \\mathbf{H}^\\top \\mathbf{m}$。\n6. 求解线性系统 $\\mathbf{A} \\hat{\\mathbf{B}} = \\mathbf{b}$ 以得到 $\\hat{\\mathbf{B}}$，这等价于计算 $\\hat{\\mathbf{B}} = \\mathbf{A}^{-1}\\mathbf{b}$。\n7. 所得向量 $\\hat{\\mathbf{B}} = [\\hat{B}_x, \\hat{B}_y]^\\top$ 即为后验均值估计。然后将其分量四舍五入到三位小数以供报告。\n此过程将应用于指定的三个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Bayesian posterior mean estimates for the horizontal components\n    of the Earth's magnetic field vector for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"angles\": np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4]),\n            \"measurements\": np.array([25.5, -11.4066, -38.8, -46.3619, -24.9, 10.6066, 38.5, 46.2619]),\n            \"sigma\": 1.0,\n            \"sigma0\": 100.0,\n        },\n        {\n            \"angles\": np.array([0.15, 0.20, 0.25, 0.30, 0.35]),\n            \"measurements\": np.array([17.2596, 20.03415, 21.85932, 24.42936, 26.48858]),\n            \"sigma\": 0.5,\n            \"sigma0\": 100.0,\n        },\n        {\n            \"angles\": np.array([0.0, 1.5707963267948966]),\n            \"measurements\": np.array([-29.98, 14.97]),\n            \"sigma\": 0.1,\n            \"sigma0\": 100.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        angles = case[\"angles\"]\n        measurements = case[\"measurements\"]\n        sigma = case[\"sigma\"]\n        sigma0 = case[\"sigma0\"]\n\n        # 1. Construct the observation matrix H.\n        # H has shape (N, 2), where N is the number of measurements.\n        H = np.vstack((np.cos(angles), np.sin(angles))).T\n\n        # 2. Compute the regularization parameter lambda.\n        lambda_reg = (sigma / sigma0)**2\n        \n        # 3. Compute H_transpose * H and H_transpose * m.\n        H_T_H = H.T @ H\n        H_T_m = H.T @ measurements\n        \n        # 4. Form the matrix A = H_T_H + lambda * I.\n        # np.identity(2) creates a 2x2 identity matrix.\n        A = H_T_H + lambda_reg * np.identity(2)\n        \n        # 5. Solve for the posterior mean B_hat = A_inverse * H_T_m.\n        # np.linalg.inv computes the inverse of matrix A.\n        # The @ operator performs matrix multiplication.\n        B_hat = np.linalg.inv(A) @ H_T_m\n        \n        # 6. Store the result.\n        # The problem does not require rounding at this stage, but rounding\n        # is performed for the final output string formatting.\n        results.append(B_hat.tolist())\n\n    # Final print statement in the exact required format.\n    # The format is [[Bx1,By1],[Bx2,By2],[Bx3,By3]] with numbers\n    # rounded to three decimals and no spaces.\n    results_str = []\n    for res_pair in results:\n        bx_str = f\"{res_pair[0]:.3f}\"\n        by_str = f\"{res_pair[1]:.3f}\"\n        results_str.append(f\"[{bx_str},{by_str}]\")\n    \n    final_output = f\"[{','.join(results_str)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2376023"}, {"introduction": "最后，我们将时间维度引入贝叶斯推断，学习如何追踪一个动态系统。在这个练习中，你将为一个在走廊中移动的机器人实现一个一维贝叶斯滤波器（即卡尔曼滤波器），根据其运动指令和带噪声的位置传感器读数，实时估计它的位置。通过从头构建这个滤波器，你将深刻理解现代追踪与导航技术的核心——优雅的“预测-更新”循环，并掌握如何随时间流逝，将动态模型与不完美的测量数据进行融合 [@problem_id:2376024]。", "problem": "你的任务是实现一个一维贝叶斯滤波器，使用带噪声的距离传感器读数来跟踪一个机器人在一条笔直走廊中的位置。物理状态是沿一个轴的位置。动力学被建模为一个带有加性高斯过程噪声的离散时间运动学模型，而测量则被建模为带有加性高斯噪声的位置观测值。所有距离必须以米为单位。你的程序必须在处理每个测试用例给定的控制输入和测量序列后，计算出最终的后验均值位置和最终的后验方差。最终答案必须以后验均值为米，后验方差为平方米表示，并四舍五入到六位小数。\n\n请使用以下物理和统计建模假设作为基本基础：\n- 时间步 $t$ 的隐藏状态是位置 $x_t$，单位为米。\n- 控制输入 $u_t$ 是时间步 $t$ 的指令位移，单位为米。\n- 过程模型是 $x_t = x_{t-1} + u_t + w_t$，其中 $w_t \\sim \\mathcal{N}(0, \\sigma_q^2)$ 用于建模未建模的扰动和执行不确定性，$\\sigma_q$ 的单位为米。\n- 测量模型是 $z_t = x_t + v_t$，其中 $v_t \\sim \\mathcal{N}(0, \\sigma_r^2)$ 用于建模传感器噪声，$\\sigma_r$ 的单位为米。\n- 在 $t=0$ 时的先验是高斯分布 $x_0 \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$，其中 $\\mu_0$ 的单位为米，$\\sigma_0$ 的单位为米。\n\n你必须从贝叶斯法则以及高斯分布在线性变换和乘积下的性质来推导你的算法。除了这些基本原理外，不要假设任何捷径公式。你的实现必须为每个测试用例计算出在处理完整个控制和测量序列后的最终后验均值 $\\mu_T$（单位米）和最终后验方差 $\\sigma_T^2$（单位平方米）。\n\n测试套件：\n对于每个测试用例，给定 $(\\mu_0, \\sigma_0, \\sigma_q, \\sigma_r, \\{u_t\\}_{t=1}^T, \\{z_t\\}_{t=1}^T)$，其中所有距离单位为米，标准差单位也为米。对每个案例，按顺序在所有 $T$ 个步骤上应用贝叶斯滤波器，并返回最终的后验均值和方差。\n\n- 案例 1（通用运动，中等噪声）：\n  - 初始先验：$\\mu_0 = 0.0$，$\\sigma_0 = 1.5$。\n  - 噪声尺度：$\\sigma_q = 0.4$，$\\sigma_r = 0.8$。\n  - 控制：$[0.9, 1.1, 1.0, 0.95, 1.05]$。\n  - 测量：$[0.7, 2.1, 2.9, 3.8, 5.1]$。\n\n- 案例 2（静止机器人，精确传感器，不确定先验）：\n  - 初始先验：$\\mu_0 = 2.0$，$\\sigma_0 = 3.0$。\n  - 噪声尺度：$\\sigma_q = 0.5$，$\\sigma_r = 0.2$。\n  - 控制：$[0.0, 0.0, 0.0]$。\n  - 测量：$[2.2, 1.9, 2.1]$。\n\n- 案例 3（移动机器人，高过程噪声，精确传感器）：\n  - 初始先验：$\\mu_0 = -1.0$，$\\sigma_0 = 0.5$。\n  - 噪声尺度：$\\sigma_q = 1.5$，$\\sigma_r = 0.4$。\n  - 控制：$[0.5, 0.5, 0.5, 0.5]$。\n  - 测量：$[-0.6, 0.2, 1.1, 2.3]$。\n\n- 案例 4（移动机器人，低过程噪声，非常嘈杂的传感器）：\n  - 初始先验：$\\mu_0 = 5.0$，$\\sigma_0 = 0.3$。\n  - 噪声尺度：$\\sigma_q = 0.2$，$\\sigma_r = 3.0$。\n  - 控制：$[-0.5, -0.5, -0.5]$。\n  - 测量：$[4.6, 4.0, 3.1]$。\n\n要求输出：\n- 对每个案例，计算并返回两个浮点数：最终后验均值 $\\mu_T$（单位米）和最终后验方差 $\\sigma_T^2$（单位平方米），两者均四舍五入到六位小数。\n- 你的程序应该生成单行输出，其中包含按顺序排列的所有结果，形式为一个由逗号分隔并用方括号括起来的列表，顺序为：$\\left[\\mu_T^{(1)}, \\sigma_T^{2(1)}, \\mu_T^{(2)}, \\sigma_T^{2(2)}, \\mu_T^{(3)}, \\sigma_T^{2(3)}, \\mu_T^{(4)}, \\sigma_T^{2(4)}\\right]$。\n\n此问题不涉及角度单位。确保实现是通用的，从第一性原理推导，并且所有报告的距离单位为米，方差单位为平方米。不应读取任何用户输入；程序必须按原样运行并以指定格式打印四个案例的最终结果。", "solution": "问题陈述经评估有效。它构成了计算物理和状态估计领域中一个定义明确、有科学依据的问题。模型、参数和边界条件均被明确指定，从而可以推导和实现一个唯一、可验证的解。该问题要求为带有高斯噪声的线性系统实现一个一维贝叶斯滤波器，这即经典的卡尔曼滤波器。\n\n该解法源于递归贝叶斯估计的基本原理。系统的状态是机器人的一维位置 $x_t$。关于此状态的置信度由一个概率分布表示。鉴于过程模型和测量模型是线性的，且所有噪声源都是高斯的，一个初始的高斯置信度将在所有后续时间步中作为高斯分布进行传播。一个高斯分布由其均值 $\\mu$ 和方差 $\\sigma^2$ 完全描述。因此，问题简化为递归地更新这两个参数。\n\n对于每个离散时间增量，递归更新过程包括两个相继的步骤：一个**预测**步骤，后跟一个**校正**步骤。\n\n令时间 $t-1$ 时状态的后验分布（给定截至该点的所有测量值）为 $p(x_{t-1}|z_{1:t-1}) = \\mathcal{N}(x_{t-1}; \\mu_{t-1}, \\sigma_{t-1}^2)$。在 $t=0$ 时的初始状态由先验分布 $p(x_0) = \\mathcal{N}(x_0; \\mu_0, \\sigma_0^2)$ 给出。\n\n**1. 预测步骤（时间更新）**\n\n此步骤基于 $t-1$ 时的分布和控制输入 $u_t$ 来预测 $t$ 时的状态分布。这产生了当前时间步的先验分布 $p(x_t|z_{1:t-1})$。此分布通过应用全概率定律，对 $x_{t-1}$ 进行边际化得到：\n$$p(x_t|z_{1:t-1}) = \\int p(x_t|x_{t-1}, u_t) p(x_{t-1}|z_{1:t-1}) dx_{t-1}$$\n过程模型给定为 $x_t = x_{t-1} + u_t + w_t$，带有高斯过程噪声 $w_t \\sim \\mathcal{N}(0, \\sigma_q^2)$。这定义了转移概率为 $p(x_t|x_{t-1}, u_t) = \\mathcal{N}(x_t; x_{t-1} + u_t, \\sigma_q^2)$。我们实际上是在对两个高斯分布进行卷积。两个独立高斯随机变量之和也是一个高斯随机变量。\n\n预测分布的均值，记作 $\\bar{\\mu}_t$，是各组成变量均值之和：\n$$ \\bar{\\mu}_t = E[x_{t-1} + u_t + w_t] = E[x_{t-1}] + u_t + E[w_t] = \\mu_{t-1} + u_t + 0 $$\n$$ \\bar{\\mu}_t = \\mu_{t-1} + u_t $$\n预测分布的方差 $\\bar{\\sigma}_t^2$，是各方差之和，因为变量是独立的：\n$$ \\bar{\\sigma}_t^2 = Var(x_{t-1} + u_t + w_t) = Var(x_{t-1}) + Var(u_t) + Var(w_t) = \\sigma_{t-1}^2 + 0 + \\sigma_q^2 $$\n$$ \\bar{\\sigma}_t^2 = \\sigma_{t-1}^2 + \\sigma_q^2 $$\n因此，预测置信度，或时间 $t$ 的先验，是 $p(x_t|z_{1:t-1}) = \\mathcal{N}(x_t; \\bar{\\mu}_t, \\bar{\\sigma}_t^2)$。\n\n**2. 校正步骤（测量更新）**\n\n此步骤通过整合新的测量值 $z_t$ 来修正预测的置信度。应用贝叶斯法则来计算后验分布 $p(x_t|z_{1:t})$：\n$$ p(x_t|z_{1:t}) = p(x_t|z_t, z_{1:t-1}) = \\frac{p(z_t|x_t, z_{1:t-1}) p(x_t|z_{1:t-1})}{p(z_t|z_{1:t-1})} $$\n假设测量值 $z_t$ 在给定当前状态 $x_t$ 的条件下与过去的测量值条件独立，这可以简化为：\n$$ p(x_t|z_{1:t}) \\propto p(z_t|x_t) p(x_t|z_{1:t-1}) $$\n后验与似然和先验的乘积成正比。测量模型是 $z_t = x_t + v_t$，其中 $v_t \\sim \\mathcal{N}(0, \\sigma_r^2)$。因此，似然函数是 $p(z_t|x_t) = \\mathcal{N}(z_t; x_t, \\sigma_r^2)$。作为 $x_t$ 的函数，这与一个以 $z_t$ 为中心的高斯分布，即 $\\mathcal{N}(x_t; z_t, \\sigma_r^2)$ 成正比。\n\n我们必须找到后验分布 $\\mathcal{N}(x_t; \\mu_t, \\sigma_t^2)$ 的参数，该分布由先验 $\\mathcal{N}(x_t; \\bar{\\mu}_t, \\bar{\\sigma}_t^2)$ 和似然 $\\mathcal{N}(x_t; z_t, \\sigma_r^2)$ 的乘积得到。两个高斯分布乘积的均值和方差由下式给出：\n$$ \\frac{1}{\\sigma_t^2} = \\frac{1}{\\bar{\\sigma}_t^2} + \\frac{1}{\\sigma_r^2} \\implies \\sigma_t^2 = \\frac{\\bar{\\sigma}_t^2 \\sigma_r^2}{\\bar{\\sigma}_t^2 + \\sigma_r^2} $$\n$$ \\mu_t = \\sigma_t^2 \\left( \\frac{\\bar{\\mu}_t}{\\bar{\\sigma}_t^2} + \\frac{z_t}{\\sigma_r^2} \\right) $$\n这些是高斯融合的标准方程。为了获得更好的数值稳定性和概念上的洞察力，它们通常使用卡尔曼增益 $K_t$ 进行重写：\n$$ K_t = \\frac{\\bar{\\sigma}_t^2}{\\bar{\\sigma}_t^2 + \\sigma_r^2} $$\n卡尔曼增益 $K_t \\in [0, 1]$ 表示给予新测量值的相对权重。高增益表示更信任测量值，而低增益表示更信任预测值。使用 $K_t$，后验均值 $\\mu_t$ 和方差 $\\sigma_t^2$ 的更新方程为：\n$$ \\mu_t = \\bar{\\mu}_t + K_t (z_t - \\bar{\\mu}_t) $$\n$$ \\sigma_t^2 = (1 - K_t) \\bar{\\sigma}_t^2 $$\n算法从初始状态 $(\\mu_0, \\sigma_0^2)$ 开始，并为每个时间步 $t=1, \\dots, T$ 递归地应用预测和校正步骤。问题提供了标准差 $\\sigma_0, \\sigma_q, \\sigma_r$，必须将它们平方以得出这些方程所需的方差。最终值 $(\\mu_T, \\sigma_T^2)$ 即为解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _run_single_filter(params):\n    \"\"\"\n    Runs the 1D Kalman filter for a single test case.\n    \n    Args:\n        params (tuple): A tuple containing all parameters for the test case:\n                        (mu0, sigma0, sigma_q, sigma_r, controls, measurements).\n    \n    Returns:\n        tuple: A tuple containing the final posterior mean and variance.\n    \"\"\"\n    mu0, sigma0, sigma_q, sigma_r, controls, measurements = params\n    \n    # Initialize state mean and variance. The equations use variance, so we\n    # must square the standard deviations provided in the problem statement.\n    mu = float(mu0)\n    sigma_sq = float(sigma0)**2\n    \n    # Pre-calculate noise variances\n    sigma_q_sq = float(sigma_q)**2\n    sigma_r_sq = float(sigma_r)**2\n    \n    # Iterate through each time step, applying the filter equations\n    for u, z in zip(controls, measurements):\n        # 1. Prediction Step (Time Update)\n        # Predict the next state mean based on the control input.\n        mu_bar = mu + u\n        # Predict the next state variance by adding the process noise variance.\n        sigma_sq_bar = sigma_sq + sigma_q_sq\n        \n        # 2. Correction Step (Measurement Update)\n        # Compute the Kalman gain. This term balances the weight between the\n        # prediction and the measurement.\n        kalman_gain = sigma_sq_bar / (sigma_sq_bar + sigma_r_sq)\n        \n        # Update the state mean estimate using the measurement. The term\n        # (z - mu_bar) is the measurement innovation or residual.\n        mu = mu_bar + kalman_gain * (z - mu_bar)\n        \n        # Update the state variance (uncertainty).\n        sigma_sq = (1 - kalman_gain) * sigma_sq_bar\n        \n    return mu, sigma_sq\n\ndef solve():\n    \"\"\"\n    Defines the test cases, runs the filter for each, and prints the results\n    in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mu0, sigma0, sigma_q, sigma_r, controls, measurements)\n    test_cases = [\n        # Case 1: General motion, moderate noise\n        (0.0, 1.5, 0.4, 0.8, [0.9, 1.1, 1.0, 0.95, 1.05], [0.7, 2.1, 2.9, 3.8, 5.1]),\n        # Case 2: Stationary robot, precise sensor, uncertain prior\n        (2.0, 3.0, 0.5, 0.2, [0.0, 0.0, 0.0], [2.2, 1.9, 2.1]),\n        # Case 3: Moving robot, high process noise, accurate sensor\n        (-1.0, 0.5, 1.5, 0.4, [0.5, 0.5, 0.5, 0.5], [-0.6, 0.2, 1.1, 2.3]),\n        # Case 4: Moving robot, low process noise, very noisy sensor\n        (5.0, 0.3, 0.2, 3.0, [-0.5, -0.5, -0.5], [4.6, 4.0, 3.1]),\n    ]\n\n    results = []\n    # Process each test case\n    for case in test_cases:\n        mu_final, sigma_sq_final = _run_single_filter(case)\n        \n        # Append the final mean and variance, formatted to six decimal places, to the results list.\n        results.append(f\"{mu_final:.6f}\")\n        results.append(f\"{sigma_sq_final:.6f}\")\n\n    # Final print statement must produce only the specified single-line format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "2376024"}]}