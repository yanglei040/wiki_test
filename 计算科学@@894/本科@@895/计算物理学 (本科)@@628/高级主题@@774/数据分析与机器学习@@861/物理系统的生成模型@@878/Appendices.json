{"hands_on_practices": [{"introduction": "本练习是理解生成模型核心机制的基础。我们将通过一个经典的物理场景——谐振子系统的玻尔兹曼分布——来实践正态化流 (Normalizing Flow) 的基本原理。这个实践旨在揭示变量变换公式在概率密度转换中的力量，展示如何将一个简单的基础分布（如高斯分布）精确地变换为一个具有明确物理意义的目标分布 [@problem_id:2398415]。通过这个可解析求解的例子，你将为掌握更复杂的生成模型打下坚实的基础。", "problem": "实现一个完整、可运行的程序，构建一个归一化流，将一个简单的高斯基分布转换为玻尔兹曼分布。该玻尔兹曼分布描述一个一维双粒子系统，粒子间存在谐波相互作用，系统采用约化单位，其中玻尔兹曼常数等于1。考虑两个粒子，其在一维空间中的位置为 $x_1$ 和 $x_2$。势能由下式给出\n$$\nU(x_1,x_2) = \\frac{1}{2} k \\, (x_1 - x_2)^2 + \\frac{1}{2} k_0 \\, (x_1^2 + x_2^2),\n$$\n其中 $k$ 和 $k_0$ 为刚度常数。在温度 $T$ 下，状态向量 $x = (x_1,x_2)^\\top \\in \\mathbb{R}^2$ 的玻尔兹曼分布为\n$$\np(x) = \\frac{1}{Z} \\exp\\!\\left(-\\frac{U(x)}{T}\\right),\n$$\n其中 $Z$ 是配分函数，所有量均采用约化无量纲单位，玻尔兹曼常数等于 $1$。基分布是标准正态分布\n$$\nq_0(z) = \\mathcal{N}(0, I_2)\n$$\n对于 $z \\in \\mathbb{R}^2$。实现一个归一化流，它是一个双射、可微的映射 $f_\\theta : \\mathbb{R}^2 \\to \\mathbb{R}^2$，将 $z \\sim q_0$ 变换为 $x = f_\\theta(z)$，其模型密度为\n$$\nq_\\theta(x) = q_0\\!\\big(f_\\theta^{-1}(x)\\big)\\,\\left|\\det J_{f_\\theta^{-1}}(x)\\right|,\n$$\n其中 $J_{f_\\theta^{-1}}(x)$ 是逆映射的雅可比矩阵。将流约束为线性和可逆的，$x = L z + b$，其中 $L \\in \\mathbb{R}^{2\\times 2}$ 是可逆矩阵且 $b \\in \\mathbb{R}^2$。\n\n从第一性原理出发，将指定势能的玻尔兹曼分布表示为一个具有显式均值和协方差的多元正态分布，并选择 $L$ 和 $b$，使得推前分布 $q_\\theta$ 精确地等于玻尔兹曼分布。然后，对于下面的每个测试用例，以闭合形式计算 Kullback–Leibler 散度，\n$$\nD_{\\mathrm{KL}}\\!\\big(q_\\theta \\,\\|\\, p\\big) = \\frac{1}{2}\\left(\\operatorname{tr}\\!\\big(\\Sigma_p^{-1} \\Sigma_\\theta\\big) + (\\mu_p - \\mu_\\theta)^\\top \\Sigma_p^{-1} (\\mu_p - \\mu_\\theta) - d + \\ln\\frac{\\det \\Sigma_p}{\\det \\Sigma_\\theta}\\right),\n$$\n其中 $d = 2$，$\\mu_\\theta, \\Sigma_\\theta$ 是 $q_\\theta$ 的均值和协方差，而 $\\mu_p, \\Sigma_p$ 是 $p$ 的均值和协方差。为每个测试用例报告一个实数，即计算出的 $D_{\\mathrm{KL}}$ 的十进制值。\n\n测试套件（每个元组为 $(k, k_0, T)$）：\n- 用例 1: $(1.0, 1.0, 1.0)$\n- 用例 2: $(0.0, 1.0, 0.5)$\n- 用例 3: $(0.5, 5.0, 2.0)$\n- 用例 4: $(5.0, 0.1, 1.5)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的四个 $D_{\\mathrm{KL}}$ 值列表。例如，包含四个值的输出应如下所示\n$$\n[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4],\n$$\n其中每个 $\\alpha_i$ 是一个十进制数。不允许有其他输出或文本。", "solution": "该问题要求构建一个线性归一化流，将一个标准二元高斯基分布转换为一个用于双粒子系统的目标玻尔兹曼分布。首先必须确定问题陈述的有效性。\n\n**问题验证**\n\n**第1步：提取已知条件**\n- 势能：$U(x_1,x_2) = \\frac{1}{2} k \\, (x_1 - x_2)^2 + \\frac{1}{2} k_0 \\, (x_1^2 + x_2^2)$\n- 状态向量：$x = (x_1, x_2)^\\top \\in \\mathbb{R}^2$\n- 玻尔兹曼分布（目标）：$p(x) = \\frac{1}{Z} \\exp(-\\frac{U(x)}{T})$\n- 基分布：$q_0(z) = \\mathcal{N}(0, I_2)$\n- 归一化流映射：$x = f_\\theta(z) = L z + b$，其中 $L \\in \\mathbb{R}^{2\\times 2}$ 是可逆矩阵且 $b \\in \\mathbb{R}^2$。\n- 模型分布：$q_\\theta(x) = q_0(f_\\theta^{-1}(x))\\,|\\det J_{f_\\theta^{-1}}(x)|$\n- 约束：选择 $L$ 和 $b$，使得 $q_\\theta(x) = p(x)$ 精确成立。\n- Kullback–Leibler 散度公式：$D_{\\mathrm{KL}}(q_\\theta \\,\\|\\, p) = \\frac{1}{2}\\left(\\operatorname{tr}(\\Sigma_p^{-1} \\Sigma_\\theta) + (\\mu_p - \\mu_\\theta)^\\top \\Sigma_p^{-1} (\\mu_p - \\mu_\\theta) - d + \\ln\\frac{\\det \\Sigma_p}{\\det \\Sigma_\\theta}\\right)$，其中 $d = 2$。\n- 测试用例 $(k, k_0, T)$: $(1.0, 1.0, 1.0)$、$(0.0, 1.0, 0.5)$、$(0.5, 5.0, 2.0)$、$(5.0, 0.1, 1.5)$。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于统计力学（玻尔兹曼分布）、线性代数和概率论（多元正态分布、概率密度的变量替换公式、Kullback-Leibler 散度）。应用归一化流来模拟物理分布是计算物理学中的一种标准技术。所有提供的公式都是正确且标准的。\n- **适定性：** 这个问题是适定的。它要求证明目标分布是一个多元高斯分布，然后找到一个线性变换的参数，该变换将一个标准高斯分布映射到这个目标分布。这是一个可解问题，其所得分布的参数具有唯一解。计算KL散度的要求也是明确定义的。\n- **客观性：** 问题陈述使用了精确、客观的数学语言，没有主观或模糊的术语。\n\n**第3步：结论与行动**\n该问题有效。它具有科学合理性、适定性和客观性。将提供一个完整的解决方案。\n\n**基于原理的解决方案**\n\n目标是构建一个线性归一化流 $x = Lz + b$，将基分布 $q_0(z) = \\mathcal{N}(z | 0, I_2)$ 变换为一个与目标玻尔兹曼分布 $p(x)$ 完全相同的模型分布 $q_\\theta(x)$。我们将首先将 $p(x)$ 和 $q_\\theta(x)$ 表征为多元正态分布，然后匹配它们的参数。\n\n**1. 目标分布 $p(x)$ 的表征**\n\n势能 $U(x)$ 是坐标 $x_1$ 和 $x_2$ 的二次型。我们将其表示为矩阵形式。\n$$\nU(x_1,x_2) = \\frac{1}{2} k (x_1^2 - 2x_1x_2 + x_2^2) + \\frac{1}{2} k_0 (x_1^2 + x_2^2) = \\frac{1}{2} (k+k_0)x_1^2 - k x_1 x_2 + \\frac{1}{2} (k+k_0)x_2^2\n$$\n这可以写成 $U(x) = \\frac{1}{2} x^\\top H x$，其中 $x = \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix}$，$H$ 是势能的海森矩阵，由下式给出：\n$$\nH = \\begin{pmatrix} k+k_0 & -k \\\\ -k & k+k_0 \\end{pmatrix}\n$$\n目标玻尔兹曼分布为 $p(x) = \\frac{1}{Z} \\exp(-\\frac{U(x)}{T}) = \\frac{1}{Z} \\exp(-\\frac{1}{2T} x^\\top H x)$。这是一个多元正态分布 $\\mathcal{N}(\\mu_p, \\Sigma_p)$ 的概率密度函数，其通常由下式给出：\n$$\np(x) = \\frac{1}{\\sqrt{(2\\pi)^d \\det \\Sigma_p}} \\exp\\left(-\\frac{1}{2} (x - \\mu_p)^\\top \\Sigma_p^{-1} (x - \\mu_p)\\right)\n$$\n通过比较指数部分，我们可以确定均值 $\\mu_p$ 和逆协方差（精度）矩阵 $\\Sigma_p^{-1}$。我们指数中缺少 $x$ 的线性项，这意味着均值向量为零：\n$$\n\\mu_p = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n精度矩阵被确定为：\n$$\n\\Sigma_p^{-1} = \\frac{1}{T} H = \\frac{1}{T} \\begin{pmatrix} k+k_0 & -k \\\\ -k & k+k_0 \\end{pmatrix}\n$$\n协方差矩阵是精度矩阵的逆，$\\Sigma_p = ( \\Sigma_p^{-1} )^{-1} = T H^{-1}$。对于给定的测试用例，$H$ 是可逆的。因此，目标分布 $p(x)$ 是一个零均值的多元正态分布，$p(x) = \\mathcal{N}(x | 0, \\Sigma_p)$。\n\n**2. 模型分布 $q_\\theta(x)$ 的表征**\n\n基随机变量 $z$ 服从标准正态分布，$z \\sim \\mathcal{N}(0, I_2)$。归一化流定义了一个新的随机变量 $x = Lz + b$。这是一个高斯变量的仿射变换，所以 $x$ 也是高斯分布的。\n模型分布 $q_\\theta(x)$ 的均值是：\n$$\n\\mu_\\theta = \\mathbb{E}[x] = \\mathbb{E}[Lz + b] = L\\mathbb{E}[z] + b = L \\cdot 0 + b = b\n$$\n模型分布的协方差是：\n$$\n\\Sigma_\\theta = \\text{Cov}(x) = \\text{Cov}(Lz + b) = L \\, \\text{Cov}(z) \\, L^\\top = L I_2 L^\\top = LL^\\top\n$$\n因此，模型分布是 $q_\\theta(x) = \\mathcal{N}(x | b, LL^\\top)$。\n\n**3. 匹配分布并计算KL散度**\n\n问题要求我们选择流参数 $L$ 和 $b$，使得 $q_\\theta(x)$ 与 $p(x)$ 完全相同。这需要匹配它们各自的均值和协方差矩阵：\n$$\n\\mu_\\theta = \\mu_p \\implies b = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n$$\n\\Sigma_\\theta = \\Sigma_p \\implies LL^\\top = \\Sigma_p\n$$\n由于 $\\Sigma_p = T H^{-1}$ 对于给定的参数（因为 $T>0$ 且 $H$ 是正定的）是一个对称正定矩阵，总能找到一个合适的矩阵 $L$，例如，通过 Cholesky 分解。\n\n通过这样选择参数，模型分布与目标分布完全相同：$q_\\theta(x) = p(x)$。Kullback-Leibler散度衡量了两个分布之间的差异性。对于任何分布 $P$，$P$ 与自身的KL散度为零：$D_{\\mathrm{KL}}(P \\,\\|\\, P) = \\int P(x) \\log\\frac{P(x)}{P(x)} dx = \\int P(x) \\log(1) dx = 0$。\n\n我们可以使用为两个多元正态分布 $q_\\theta = \\mathcal{N}(\\mu_\\theta, \\Sigma_\\theta)$ 和 $p = \\mathcal{N}(\\mu_p, \\Sigma_p)$ 提供的公式来验证这一点：\n$$\nD_{\\mathrm{KL}}(q_\\theta \\,\\|\\, p) = \\frac{1}{2}\\left(\\operatorname{tr}(\\Sigma_p^{-1} \\Sigma_\\theta) + (\\mu_p - \\mu_\\theta)^\\top \\Sigma_p^{-1} (\\mu_p - \\mu_\\theta) - d + \\ln\\frac{\\det \\Sigma_p}{\\det \\Sigma_\\theta}\\right)\n$$\n代入我们匹配的参数 $\\mu_\\theta = \\mu_p$ 和 $\\Sigma_\\theta = \\Sigma_p$：\n- 迹项变为 $\\operatorname{tr}(\\Sigma_p^{-1} \\Sigma_p) = \\operatorname{tr}(I_d) = d$。\n- 均值差项变为 $(\\mu_p - \\mu_p)^\\top \\Sigma_p^{-1} (\\mu_p - \\mu_p) = 0$。\n- 对数行列式项变为 $\\ln\\frac{\\det \\Sigma_p}{\\det \\Sigma_p} = \\ln(1) = 0$。\n\n将这些代入公式，其中 $d=2$：\n$$\nD_{\\mathrm{KL}}(q_\\theta \\,\\|\\, p) = \\frac{1}{2}(d + 0 - d + 0) = \\frac{1}{2}(2 - 2) = 0\n$$\n只要 $k$、$k_0$ 和 $T$ 定义了一个有效的（非退化的）高斯分布，这个结果就与它们的具体值无关。因为问题明确说明要构建流以使分布完全匹配，所以对于所有测试用例，KL散度必须为 $0$。该实现将进行数值计算以证实这一分析结论。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the KL divergence for each test case.\n\n    The analytical derivation shows that if the normalizing flow parameters are\n    chosen to perfectly match the target Boltzmann distribution, the KL divergence\n    must be exactly zero. This program confirms this result numerically for\n    the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 1.0, 1.0),  # Case 1: (k, k_0, T)\n        (0.0, 1.0, 0.5),  # Case 2\n        (0.5, 5.0, 2.0),  # Case 3\n        (5.0, 0.1, 1.5),  # Case 4\n    ]\n\n    results = []\n    d = 2  # Dimensionality of the system\n\n    for case in test_cases:\n        k, k0, T = case\n\n        # 1. Define the parameters of the target Boltzmann distribution p(x).\n        # The potential is U(x) = 1/2 * x^T H x.\n        # The distribution p(x) is a multivariate normal N(mu_p, Sigma_p).\n        \n        # The mean is zero due to the form of the potential.\n        mu_p = np.array([0.0, 0.0])\n\n        # The inverse covariance matrix is Sigma_p^-1 = (1/T) * H, where H is the Hessian.\n        H = np.array([[k + k0, -k], \n                      [-k, k + k0]])\n        \n        # Check for non-invertible Hessian (though not expected for test cases)\n        if np.linalg.det(H) == 0:\n            # This would indicate a non-physical or degenerate system.\n            # For the given cases, det(H) = k0 * (2k + k0), which is > 0.\n            # Handle as an error, though we expect it not to occur.\n            results.append(np.nan) \n            continue\n\n        Sigma_p_inv = (1.0 / T) * H\n        \n        # The covariance matrix is the inverse of the precision matrix.\n        Sigma_p = np.linalg.inv(Sigma_p_inv)\n\n        # 2. Define the parameters of the model distribution q_theta(x).\n        # The problem states to choose the linear flow x = Lz + b such that\n        # the model distribution q_theta(x) exactly equals the target p(x).\n        # This means we must match their means and covariances.\n        mu_theta = mu_p\n        Sigma_theta = Sigma_p\n\n        # 3. Compute the KL divergence using the provided formula.\n        # D_KL(q_theta || p) = 0.5 * ( tr(Sigma_p^-1 * Sigma_theta) + \n        #                              (mu_p - mu_theta)^T * Sigma_p^-1 * (mu_p - mu_theta) -\n        #                              d + log(det(Sigma_p) / det(Sigma_theta)) )\n\n        # Since mu_theta = mu_p and Sigma_theta = Sigma_p, the terms simplify:\n        # trace_term = tr(Sigma_p^-1 * Sigma_p) = tr(I) = d\n        # mean_term = (0)^T * ... * (0) = 0\n        # log_det_term = log(det(Sigma_p) / det(Sigma_p)) = log(1) = 0\n        # D_KL = 0.5 * (d + 0 - d + 0) = 0\n        \n        # We perform the full numerical computation to verify.\n        \n        trace_term = np.trace(Sigma_p_inv @ Sigma_theta)\n        \n        mu_diff = mu_p - mu_theta\n        mean_term = mu_diff.T @ Sigma_p_inv @ mu_diff\n        \n        det_p = np.linalg.det(Sigma_p)\n        det_theta = np.linalg.det(Sigma_theta)\n        \n        # Handle potential division by zero or log of non-positive, though not expected here.\n        if det_theta = 0 or det_p = 0:\n            log_det_term = np.nan\n        else:\n            log_det_term = np.log(det_p / det_theta)\n        \n        dkl = 0.5 * (trace_term + mean_term - d + log_det_term)\n        \n        # The result should be numerically very close to 0.0.\n        results.append(dkl)\n\n    # Final print statement in the exact required format.\n    # We format the numbers to represent them as standard decimals.\n    print(f\"[{','.join(map(lambda x: f'{x:.1f}', results))}]\")\n\nsolve()\n\n```", "id": "2398415"}, {"introduction": "此最终实践将带你探索物理学中生成模型最前沿的应用之一：从原始数据中发现物理定律。我们的目标不再是简单地模拟系统的状态，而是更进一步，训练一个模型来直接从双摆运动的模拟视频中辨识出其底层的拉格朗日量 $\\mathcal{L}(q, \\dot{q})$ [@problem_id:2398396]。这个练习将抽象的最小作用量原理与具体的计算任务相结合，演示了如何将物理先验知识嵌入学习过程，从而揭示驱动系统动力学的“源代码”。", "problem": "你的任务是构建一个完整的、可运行的程序，展示如何仅使用数值方法和核心物理原理，直接从合成视频数据中训练一个参数化生成模型，以学习平面双摆的拉格朗日量 $\\mathcal{L}(q,\\dot{q})$。你的程序必须能够从模拟的动态过程中合成视频，从这些视频中推断出广义坐标，并通过在时间上强制执行欧拉-拉格朗日方程，来拟合拉格朗日模型的未知参数。\n\n其基本依据是平稳作用量原理和欧拉-拉格朗日方程。对于一个具有广义坐标 $q$ 的力学系统，其作用量为 $S[q]=\\int \\mathcal{L}(q,\\dot{q})\\,dt$，其动态遵循 $\\frac{d}{dt}\\left(\\frac{\\partial \\mathcal{L}}{\\partial \\dot{q}}\\right)-\\frac{\\partial \\mathcal{L}}{\\partial q}=\\mathbf{0}$，其中 $\\mathcal{L}=T-V$，$T$ 是动能，$V$ 是势能。该模型必须以此为基础推导，并使用有效的数值近似和线性代数求解。\n\n待学习的模型类别：使用一个双摆，其摆锤质量分别为 $m_1$ 和 $m_2$，长度分别为 $l_1$ 和 $l_2$，重力加速度为 $g$。为打破全局质量尺度的简并性，通过总质量进行无量纲化，并使用以下未知参数对拉格朗日量进行参数化：\n- $\\alpha \\in (0,1)$ 是由 $\\alpha = \\frac{m_2}{m_1+m_2}$ 定义的质量分数，因此 $m_1 = 1-\\alpha$ 且 $m_2=\\alpha$，\n- $l_10$，$l_20$ 且 $g0$。\n\n你的程序必须：\n- 使用欧拉-拉格朗日方程所蕴含的常微分方程(ODEs)的精确数值积分，为给定的物理参数模拟双摆的基准动态，其中角度单位为弧度，时间单位为秒。\n- 渲染尺寸为 $64\\times 64$ 像素的合成灰度视频帧，在黑暗背景上显示两个明亮的圆形摆锤，编码器从中恢复摆锤的质心并重建角度时间序列 $q(t)=(\\theta_1(t),\\theta_2(t))$。枢轴点必须固定在图像坐标 $(32,8)$ 像素处，图像的 y 轴向下递增，像素到米的比例因子必须在你的代码中说明。所有长度单位必须是米。\n- 使用恒定时间步长 $\\Delta t$（单位：秒）的中心有限差分法估算 $\\dot{q}(t)$ 和 $\\ddot{q}(t)$。你必须使用弧度作为角度单位，秒作为时间单位。\n- 通过最小化一个从欧拉-拉格朗日方程导出的数据一致性残差来拟合未知参数 $(\\alpha,l_1,l_2,g)$，即从视频中测量的 $\\ddot{q}(t)$ 与由参数化拉格朗日量所蕴含的加速度 $\\ddot{q}_{\\text{model}}(q(t),\\dot{q}(t);\\alpha,l_1,l_2,g)$ 之间的差异。通过平滑变换对受约束的参数进行重新参数化，使得优化变量在 $\\mathbb{R}$ 中不受约束，从而使用一个数值稳定的无约束优化器。\n- 所有角度均使用弧度，所有长度和时间分别使用米和秒。重力加速度必须以 $\\text{m/s}^2$ 为单位进行学习。内部表示的学习参数也必须使用这些单位。\n\n测试套件和要求的输出：\n- 你必须使用以下三个测试用例来生成视频、进行训练，然后报告每个用例的成功或失败。每个测试用例都指定了基准参数、初始条件、模拟持续时间 $T$（单位：秒）和固定的时间步长 $\\Delta t$（单位：秒）。在评估时，真实的 $(m_1,m_2)$ 必须映射到 $\\alpha=\\frac{m_2}{m_1+m_2}$，但用于生成视频的正向模拟必须使用实际的物理参数 $(m_1,m_2)$。\n\n  1. 用例 A (常规良态用例)：\n     - 真实参数：$m_1=1.0\\,\\text{kg}$，$m_2=1.0\\,\\text{kg}$，$l_1=1.0\\,\\text{m}$，$l_2=1.0\\,\\text{m}$，$g=9.81\\,\\text{m/s}^2$。\n     - 初始条件：$\\theta_1(0)=0.8\\,\\text{rad}$，$\\theta_2(0)=-0.2\\,\\text{rad}$，$\\dot{\\theta}_1(0)=0.0\\,\\text{rad/s}$，$\\dot{\\theta}_2(0)=0.0\\,\\text{rad/s}$。\n     - 持续时间与采样：$T=4.0\\,\\text{s}$，$\\Delta t=0.02\\,\\text{s}$。\n     - 视频噪声：向像素强度添加独立的零均值高斯噪声，标准差为 $0.02$，然后裁剪到 $[0,1]$ 范围。\n\n  2. 用例 B (非对称长度和质量)：\n     - 真实参数：$m_1=1.0\\,\\text{kg}$，$m_2=0.5\\,\\text{kg}$，$l_1=1.2\\,\\text{m}$，$l_2=0.8\\,\\text{m}$，$g=9.81\\,\\text{m/s}^2$。\n     - 初始条件：$\\theta_1(0)=1.2\\,\\text{rad}$，$\\theta_2(0)=-1.0\\,\\text{rad}$，$\\dot{\\theta}_1(0)=0.0\\,\\text{rad/s}$，$\\dot{\\theta}_2(0)=0.0\\,\\text{rad/s}$。\n     - 持续时间与采样：$T=4.0\\,\\text{s}$，$\\Delta t=0.02\\,\\text{s}$。\n     - 视频噪声：与用例 A 相同的高斯噪声。\n\n  3. 用例 C (小角度边界情形)：\n     - 真实参数：$m_1=1.0\\,\\text{kg}$，$m_2=1.0\\,\\text{kg}$，$l_1=1.0\\,\\text{m}$，$l_2=1.0\\,\\text{m}$，$g=9.81\\,\\text{m/s}^2$。\n     - 初始条件：$\\theta_1(0)=0.1\\,\\text{rad}$，$\\theta_2(0)=0.05\\,\\text{rad}$，$\\dot{\\theta}_1(0)=0.0\\,\\text{rad/s}$，$\\dot{\\theta}_2(0)=0.0\\,\\text{rad/s}$。\n     - 持续时间与采样：$T=6.0\\,\\text{s}$，$\\Delta t=0.02\\,\\text{s}$。\n     - 视频噪声：与用例 A 相同的高斯噪声。\n\n- 对于每个用例，在训练后，计算学习到的参数 $(\\hat{\\alpha},\\hat{l}_1,\\hat{l}_2,\\hat{g})$。当且仅当以下所有条件同时成立时，宣布成功：\n  - $|\\hat{\\alpha}-\\alpha_{\\text{true}}|\\leq \\tau_{\\alpha}$，\n  - $\\left|\\frac{\\hat{l}_1-l_{1,\\text{true}}}{l_{1,\\text{true}}}\\right|\\leq \\tau_{\\ell}$ and $\\left|\\frac{\\hat{l}_2-l_{2,\\text{true}}}{l_{2,\\text{true}}}\\right|\\leq \\tau_{\\ell}$，\n  - $\\left|\\frac{\\hat{g}-g_{\\text{true}}}{g_{\\text{true}}}\\right|\\leq \\tau_{g}$。\n  用例 A 使用 $(\\tau_{\\alpha},\\tau_{\\ell},\\tau_{g})=(0.05,0.05,0.05)$，用例 B 使用 $(0.08,0.08,0.08)$，用例 C 使用 $(0.15,0.15,0.10)$。\n\n最终输出格式：\n- 你的程序必须生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 A、B、C 的顺序排列结果。每个条目必须是该用例的布尔成功指示符。例如，你的程序应该打印一行类似 $[True,False,True]$ 的内容。\n\n角度单位要求：\n- 所有角度必须以弧度表示和计算。\n\n物理单位要求：\n- 所有长度单位必须是米，时间单位是秒，重力加速度单位是 $\\text{m/s}^2$。所有模拟和学习到的参数必须在内部遵循这些单位。不得使用其他单位。", "solution": "所提出的问题是计算物理和系统辨识领域的一个有效练习。它在科学上基于经典拉格朗日力学，是适定的，具有明确的目标和充足的数据，并且其结构能够得到唯一且有意义的解。任务是从合成视频数据中逆向工程出双摆的物理参数。这个过程模拟了一个真实的科学研究，即通过强制与基本物理定律保持一致，从观测数据中推断出模型。我现在将提供正式的解决方案。\n\n该问题的核心在于平稳作用量原理，该原理指出，力学系统的动态遵循一条使作用量积分 $S = \\int \\mathcal{L}(q, \\dot{q}) dt$ 取极值的路径。拉格朗日量 $\\mathcal{L}$ 是动能 $T$ 和势能 $V$ 之间的差值。由此产生的运动方程即欧拉-拉格朗日方程：\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial \\mathcal{L}}{\\partial \\dot{q}_i}\\right) - \\frac{\\partial \\mathcal{L}}{\\partial q_i} = 0\n$$\n对于每个广义坐标 $q_i$。\n\n对于一个平面双摆，其摆锤质量为 $m_1$ 和 $m_2$，摆杆长度为 $l_1$ 和 $l_2$，广义坐标为角度 $q = (\\theta_1, \\theta_2)$。动能 $T$ 和势能 $V$（以枢轴点为原点，重力沿负 y 方向作用）为：\n$$\nT = \\frac{1}{2}(m_1+m_2)l_1^2 \\dot{\\theta}_1^2 + \\frac{1}{2}m_2 l_2^2 \\dot{\\theta}_2^2 + m_2 l_1 l_2 \\dot{\\theta}_1 \\dot{\\theta}_2 \\cos(\\theta_1 - \\theta_2)\n$$\n$$\nV = -(m_1+m_2)g l_1 \\cos \\theta_1 - m_2 g l_2 \\cos \\theta_2\n$$\n拉格朗日量为 $\\mathcal{L} = T - V$。由 $\\mathcal{L}$ 推导出的欧拉-拉格朗日方程对于将 $\\mathcal{L}$ 乘以一个常数是不变的。我们利用这一点，通过除以总质量 $M_{\\text{tot}} = m_1+m_2$ 来消除质量尺度的简并性。我们定义质量分数 $\\alpha = m_2/M_{\\text{tot}} \\in (0,1)$，因此 $m_1/M_{\\text{tot}} = 1-\\alpha$。缩放后的拉格朗日量 $\\mathcal{L}' = \\mathcal{L}/M_{\\text{tot}}$ 取决于可辨识的参数 $(\\alpha, l_1, l_2, g)$：\n$$\n\\mathcal{L}' = \\frac{1}{2}l_1^2 \\dot{\\theta}_1^2 + \\frac{1}{2}\\alpha l_2^2 \\dot{\\theta}_2^2 + \\alpha l_1 l_2 \\dot{\\theta}_1 \\dot{\\theta}_2 \\cos(\\theta_1 - \\theta_2) + g l_1 \\cos \\theta_1 + \\alpha g l_2 \\cos \\theta_2\n$$\n将欧拉-拉格朗日方程应用于 $\\mathcal{L}'$ 会得到一个二阶常微分方程组，可以表示为矩阵形式 $M'(q) \\ddot{q} = f'(q, \\dot{q})$，其中：\n$$\nM'(q) = \\begin{pmatrix} l_1^2  \\alpha l_1 l_2 \\cos(\\theta_1 - \\theta_2) \\\\ \\alpha l_1 l_2 \\cos(\\theta_1 - \\theta_2)  \\alpha l_2^2 \\end{pmatrix}\n$$\n$$\nf'(q, \\dot{q}) = \\begin{pmatrix} \\alpha l_1 l_2 \\sin(\\theta_1 - \\theta_2) \\dot{\\theta}_2^2 - g l_1 \\sin \\theta_1 \\\\ -\\alpha l_1 l_2 \\sin(\\theta_1 - \\theta_2) \\dot{\\theta}_1^2 - \\alpha g l_2 \\sin \\theta_2 \\end{pmatrix}\n$$\n因此，角加速度由 $\\ddot{q}_{\\text{model}} = (M'(q))^{-1} f'(q, \\dot{q})$ 给出。这个方程构成了我们生成模型的基础。\n\n学习参数 $(\\alpha, l_1, l_2, g)$ 的算法步骤如下：\n\n1.  **数据生成**：对于每个测试用例，我们首先模拟“基准”动态。使用真实的物理参数 $(m_1, m_2, l_1, l_2, g)$ 和初始条件，我们使用 `scipy.integrate.solve_ivp` 在指定的时间段 $T$ 内以时间步长 $\\Delta t$ 对运动方程 $\\ddot{q} = M(q)^{-1}f(q, \\dot{q})$（使用未缩放的、含实际质量的 $M, f$）进行数值积分。由此产生的角度时间序列 $(\\theta_1(t_i), \\theta_2(t_i))$ 用于渲染一系列 $64 \\times 64$ 像素的灰度视频帧。每一帧都是通过将摆锤建模为具有高斯强度分布的亮盘，并放置在其相应的笛卡尔坐标处来生成的。然后向像素值添加高斯噪声，并将其裁剪到 $[0, 1]$ 范围内。\n\n2.  **从视频中提取状态**：合成的视频作为观测数据。我们必须从每一帧中恢复系统的状态 $q = (\\theta_1, \\theta_2)$。这通过以下步骤实现：\n    a. 对图像进行阈值处理，以分离出与摆锤对应的亮像素。\n    b. 使用 `scipy.ndimage.label` 识别两个独立的摆锤区域。\n    c. 使用 `scipy.ndimage.center_of_mass` 计算每个摆锤的精确中心。\n    d. 使用已知的枢轴点位置和像素到米的比例，将质心的笛卡尔像素坐标转换回角度 $(\\theta_1, \\theta_2)$。使用 `numpy.unwrap` 对角度进行解缠绕，以处理在 $\\pm\\pi$ 处的周期性，确保微分的连续性。\n\n3.  **数值微分**：从提取的角度时间序列 $q(t)$ 中，我们使用数值有限差分法估计角速度 $\\dot{q}(t)$ 和角加速度 $\\ddot{q}(t)$。为此，我们使用 `numpy.gradient` 函数，该函数对内部点采用二阶中心差分。\n\n4.  **通过优化进行参数推断**：学习问题被表述为找到参数集 $\\vec{p} = (\\alpha, l_1, l_2, g)$，以最小化从视频中测得的加速度 $\\ddot{q}_{\\text{data}}$ 与我们的物理模型预测的加速度 $\\ddot{q}_{\\text{model}}$ 之间的差异。目标是最小化损失函数 $L$，定义为所有时间步长的平方误差之和：\n    $$\n    L(\\vec{p}) = \\sum_{i} \\| \\ddot{q}_{\\text{data}}(t_i) - \\ddot{q}_{\\text{model}}(q(t_i), \\dot{q}(t_i); \\vec{p}) \\|^2_2\n    $$\n    参数是受约束的：$\\alpha \\in(0,1)$，$l_1  0$，$l_2  0$ 和 $g  0$。为了使用无约束优化算法（`scipy.optimize.minimize` 及 `L-BFGS-B` 方法），我们对搜索空间进行了重新参数化。设无约束的优化变量为 $(p_\\alpha, p_{l1}, p_{l2}, p_g) \\in \\mathbb{R}^4$。物理参数通过平滑可逆的映射恢复：\n    -   $\\alpha = \\sigma(p_\\alpha) = \\frac{1}{1 + e^{-p_\\alpha}}$ (Sigmoid 函数)\n    -   $l_1 = e^{p_{l1}}$，$l_2 = e^{p_{l2}}$，$g = e^{p_g}$ (指数函数)\n    优化从一个合理的初始猜测（例如，$\\alpha=0.5, l_1=1.0, l_2=1.0, g=9.8$）开始，并迭代调整参数以最小化损失函数，从而找到能够最好地解释观测动态的物理参数。\n\n最后，将学习到的参数 $(\\hat{\\alpha}, \\hat{l}_1, \\hat{l}_2, \\hat{g})$ 与真实值进行比较，使用指定的相对和绝对误差容限来确定每个用例的推断是否成功。", "answer": "```python\n# Final, runnable code for the strict Russian professor.\n# This program trains a parametric generative model of a double pendulum\n# from synthetic video data.\n\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import minimize\nfrom scipy.ndimage import label, center_of_mass\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for learning double pendulum parameters.\n    \"\"\"\n    \n    # --- Constants for Video Rendering and Coordinate Extraction ---\n    IMG_SIZE = 64\n    PIVOT_POS = np.array([32, 8]) # (x, y) in pixels\n    PIXELS_PER_METER = 15.0 # This scale fits the pendulum within the frame\n    BOB_RADIUS_PIXELS = 3.0\n    VIDEO_NOISE_STD = 0.02\n    COORD_EXTRACT_THRESHOLD = 0.3\n\n    # --- Physics and Model Implementation ---\n\n    def eom_for_simulation(t, y, m1, m2, l1, l2, g):\n        \"\"\"Equations of motion for the double pendulum for ODE solver.\"\"\"\n        th1, th2, dth1, dth2 = y\n        \n        m12 = m1 + m2\n        c12 = np.cos(th1 - th2)\n        s12 = np.sin(th1 - th2)\n        s1 = np.sin(th1)\n        s2 = np.sin(th2)\n\n        M = np.array([\n            [m12 * l1**2, m2 * l1 * l2 * c12],\n            [m2 * l1 * l2 * c12, m2 * l2**2]\n        ])\n        \n        f = np.array([\n            -m2 * l1 * l2 * s12 * dth2**2 - m12 * g * l1 * s1,\n            m2 * l1 * l2 * s12 * dth1**2 - m2 * g * l2 * s2\n        ])\n        \n        try:\n            ddth1, ddth2 = np.linalg.solve(M, f)\n        except np.linalg.LinAlgError:\n            # Fallback for singular matrix, though unlikely for this system\n            ddth1, ddth2 = 0.0, 0.0\n\n        return [dth1, dth2, ddth1, ddth2]\n\n    def get_model_accelerations(params_vec, q, q_dot):\n        \"\"\"Calculates accelerations from the parametric model.\"\"\"\n        alpha, l1, l2, g = params_vec\n        th1, th2 = q\n        dth1, dth2 = q_dot\n\n        c12 = np.cos(th1 - th2)\n        s12 = np.sin(th1 - th2)\n        s1 = np.sin(th1)\n        s2 = np.sin(th2)\n        \n        M_prime = np.array([\n            [l1**2, alpha * l1 * l2 * c12],\n            [alpha * l1 * l2 * c12, alpha * l2**2]\n        ])\n        \n        f_prime = np.array([\n            alpha * l1 * l2 * s12 * dth2**2 - g * l1 * s1,\n            -alpha * l1 * l2 * s12 * dth1**2 - alpha * g * l2 * s2\n        ])\n        \n        try:\n            return np.linalg.solve(M_prime, f_prime)\n        except np.linalg.LinAlgError:\n            return np.array([0.0, 0.0])\n\n    # --- Data Generation and Processing ---\n\n    def simulate_pendulum(p, ic, t_span, dt):\n        \"\"\"Simulates dynamics to get ground truth angle time series.\"\"\"\n        t_eval = np.arange(0, t_span, dt)\n        sol = solve_ivp(\n            eom_for_simulation,\n            [0, t_span],\n            ic,\n            args=(p['m1'], p['m2'], p['l1'], p['l2'], p['g']),\n            t_eval=t_eval,\n            method='RK45'\n        )\n        return sol.t, sol.y.T[:, :2]\n\n    def render_video(q_ts, l1, l2):\n        \"\"\"Renders synthetic video frames from angle time series.\"\"\"\n        frames = []\n        yy, xx = np.mgrid[:IMG_SIZE, :IMG_SIZE]\n        r_sq = BOB_RADIUS_PIXELS ** 2\n        \n        for th1, th2 in q_ts:\n            pos1_m = np.array([l1 * np.sin(th1), l1 * np.cos(th1)])\n            pos2_m = pos1_m + np.array([l2 * np.sin(th2), l2 * np.cos(th2)])\n            \n            p1_pix = PIVOT_POS + pos1_m * PIXELS_PER_METER\n            p2_pix = PIVOT_POS + pos2_m * PIXELS_PER_METER\n            \n            d1_sq = (xx - p1_pix[0])**2 + (yy - p1_pix[1])**2\n            d2_sq = (xx - p2_pix[0])**2 + (yy - p2_pix[1])**2\n            \n            frame = np.exp(-d1_sq / (2 * r_sq)) + np.exp(-d2_sq / (2 * r_sq))\n            frame += np.random.normal(0, VIDEO_NOISE_STD, frame.shape)\n            frame = np.clip(frame, 0, 1)\n            frames.append(frame)\n            \n        return np.array(frames)\n\n    def extract_coords(video):\n        \"\"\"Extracts angle time series from video frames.\"\"\"\n        q_extracted = []\n        for frame in video:\n            blobs = frame > COORD_EXTRACT_THRESHOLD\n            labeled_blobs, num_labels = label(blobs)\n            \n            if num_labels  2:\n                # If blobs not resolved, use previous frame's data or skip. Here, we skip.\n                if len(q_extracted) > 0: q_extracted.append(q_extracted[-1]); \n                continue\n\n            centers = center_of_mass(blobs, labeled_blobs, range(1, num_labels + 1))\n            # Sort centers by size of blob to handle occasional noise blobs\n            blob_sizes = [np.sum(labeled_blobs == i) for i in range(1, num_labels + 1)]\n            top_two_indices = np.argsort(blob_sizes)[-2:]\n            centers = [centers[i] for i in top_two_indices]\n\n            # Identify bob 1 (closer to pivot)\n            p1_pix, p2_pix = sorted(centers, key=lambda c: np.linalg.norm(np.array(c)[::-1] - PIVOT_POS))\n            \n            v1_pix = np.array(p1_pix)[::-1] - PIVOT_POS\n            v2_pix = np.array(p2_pix)[::-1] - p1_pix[::-1]\n            \n            v1_m = v1_pix / PIXELS_PER_METER\n            v2_m = v2_pix / PIXELS_PER_METER\n            \n            th1 = np.arctan2(v1_m[0], v1_m[1])\n            th2 = np.arctan2(v2_m[0], v2_m[1])\n            \n            q_extracted.append([th1, th2])\n        \n        q_ts = np.array(q_extracted)\n        # Unwrap angles to handle jumps from -pi to pi\n        return np.unwrap(q_ts, axis=0)\n\n    # --- Parameter Inference ---\n\n    def loss_function(p_opt, q_ts, q_dot_ts, q_ddot_ts):\n        \"\"\"Loss function for optimization, comparing model vs. data accelerations.\"\"\"\n        # Reparameterize from unconstrained R^4 to physical parameters\n        alpha = 1.0 / (1.0 + np.exp(-p_opt[0])) # Sigmoid\n        l1, l2, g = np.exp(p_opt[1:]) # Exponential\n        \n        total_error = 0.0\n        for i in range(len(q_ts)):\n            q, q_dot, q_ddot_data = q_ts[i], q_dot_ts[i], q_ddot_ts[i]\n            q_ddot_model = get_model_accelerations([alpha, l1, l2, g], q, q_dot)\n            total_error += np.sum((q_ddot_data - q_ddot_model)**2)\n        \n        return total_error\n\n    def train_model(q_ts, dt):\n        \"\"\"Fits the model to find physical parameters.\"\"\"\n        q_dot_ts = np.gradient(q_ts, dt, axis=0)\n        q_ddot_ts = np.gradient(q_dot_ts, dt, axis=0)\n        \n        # Initial guess for unconstrained parameters\n        # Corresponds to alpha=0.5, l1=1.0, l2=1.0, g=9.8\n        p_opt_0 = np.array([0.0, np.log(1.0), np.log(1.0), np.log(9.8)])\n        \n        res = minimize(\n            loss_function,\n            p_opt_0,\n            args=(q_ts, q_dot_ts, q_ddot_ts),\n            method='L-BFGS-B'\n        )\n        \n        # Decode learned parameters\n        p_learned = res.x\n        alpha_hat = 1.0 / (1.0 + np.exp(-p_learned[0]))\n        l1_hat, l2_hat, g_hat = np.exp(p_learned[1:])\n        \n        return {'alpha': alpha_hat, 'l1': l1_hat, 'l2': l2_hat, 'g': g_hat}\n\n    def evaluate_success(learned, true, tol):\n        \"\"\"Checks if learned parameters are within tolerance.\"\"\"\n        alpha_err = np.abs(learned['alpha'] - true['alpha'])\n        l1_rel_err = np.abs((learned['l1'] - true['l1']) / true['l1'])\n        l2_rel_err = np.abs((learned['l2'] - true['l2']) / true['l2'])\n        g_rel_err = np.abs((learned['g'] - true['g']) / true['g'])\n        \n        return (alpha_err = tol['alpha'] and \n                l1_rel_err = tol['ell'] and \n                l2_rel_err = tol['ell'] and \n                g_rel_err = tol['g'])\n\n    # --- Test Cases ---\n    \n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"params\": {'m1': 1.0, 'm2': 1.0, 'l1': 1.0, 'l2': 1.0, 'g': 9.81},\n            \"ic\": [0.8, -0.2, 0.0, 0.0],\n            \"sim\": {'T': 4.0, 'dt': 0.02},\n            \"tols\": {'alpha': 0.05, 'ell': 0.05, 'g': 0.05}\n        },\n        {\n            \"name\": \"Case B\",\n            \"params\": {'m1': 1.0, 'm2': 0.5, 'l1': 1.2, 'l2': 0.8, 'g': 9.81},\n            \"ic\": [1.2, -1.0, 0.0, 0.0],\n            \"sim\": {'T': 4.0, 'dt': 0.02},\n            \"tols\": {'alpha': 0.08, 'ell': 0.08, 'g': 0.08}\n        },\n        {\n            \"name\": \"Case C\",\n            \"params\": {'m1': 1.0, 'm2': 1.0, 'l1': 1.0, 'l2': 1.0, 'g': 9.81},\n            \"ic\": [0.1, 0.05, 0.0, 0.0],\n            \"sim\": {'T': 6.0, 'dt': 0.02},\n            \"tols\": {'alpha': 0.15, 'ell': 0.15, 'g': 0.10}\n        }\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        p_true = case['params']\n        p_true_alpha = p_true['m2'] / (p_true['m1'] + p_true['m2'])\n        \n        # 1. Simulate dynamics\n        t_true, q_true_ts = simulate_pendulum(p_true, case['ic'], case['sim']['T'], case['sim']['dt'])\n        \n        # 2. Render video\n        video = render_video(q_true_ts, p_true['l1'], p_true['l2'])\n        \n        # 3. Extract coordinates\n        q_extracted_ts = extract_coords(video)\n        \n        # 4. Train model\n        p_learned = train_model(q_extracted_ts, case['sim']['dt'])\n        \n        # 5. Evaluate\n        true_params_for_eval = {'alpha': p_true_alpha, 'l1': p_true['l1'], 'l2': p_true['l2'], 'g': p_true['g']}\n        success = evaluate_success(p_learned, true_params_for_eval, case['tols'])\n        results.append(success)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n\n```", "id": "2398396"}]}