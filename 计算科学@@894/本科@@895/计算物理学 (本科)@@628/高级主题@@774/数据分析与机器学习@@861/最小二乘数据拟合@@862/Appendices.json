{"hands_on_practices": [{"introduction": "理论学习的最佳伙伴是动手实践。这个练习将最小二乘法的基本原理应用于一个经典的地球科学问题：利用铷-锶（Rb-Sr）等时线法测定岩石年龄。本练习旨在演示如何通过简单的线性回归，从一组数据点中精确提取关键物理参数（即等时线的斜率），并利用该参数计算出具有重要科学意义的量（岩石的年龄）。这是一个连接统计拟合与深刻物理结论的绝佳范例。[@problem_id:2408074]", "problem": "给定来自同一岩石样品中不同单矿物的多组铷-锶（Rb-Sr）地质年代学同位素比值数据。对于每一组数据，通过绘制现今比值 $y = (^{87}\\mathrm{Sr}/^{86}\\mathrm{Sr})$ 相对于 $x = (^{87}\\mathrm{Rb}/^{86}\\mathrm{Sr})$ 的关系图来定义一条等时线。在铷-87发生放射性衰变的情况下，线性关系\n$$\ny = b + m x\n$$\n成立，其中 $b = (^{87}\\mathrm{Sr}/^{86}\\mathrm{Sr})_{\\mathrm{initial}}$，且\n$$\nm = e^{\\lambda t} - 1,\n$$\n式中 $\\lambda$ 为衰变常数，$t$ 为年龄。使用 $\\lambda = 1.42 \\times 10^{-11}\\ \\mathrm{yr}^{-1}$，并使用自然对数。年龄可根据拟合斜率 $\\hat{m}$ 通过下式计算得出：\n$$\n\\hat{t} = \\frac{\\ln(1 + \\hat{m})}{\\lambda}.\n$$\n对于下面的每一组数据集，请通过对数据点 $\\{(x_i, y_i)\\}$ 进行最小二乘法线性拟合，确定其最佳拟合年龄 $\\hat{t}$。将每个最终年龄以百万年（Ma）为单位表示，并以浮点数形式四舍五入到两位小数。\n\n测试套件（每组数据集都是独立的）：\n\n- 数据集 A（一般情况）：\n  - $x$ 值： $[0.20, 0.80, 1.50, 2.50, 3.50, 5.00]$\n  - $y$ 值： $[0.702682, 0.713377, 0.725843, 0.743711, 0.761738, 0.788617]$\n- 数据集 B（零斜率边界情况）：\n  - $x$ 值： $[0.00, 0.50, 1.00, 1.50, 3.00]$\n  - $y$ 值： $[0.704700, 0.704700, 0.704700, 0.704700, 0.704700]$\n- 数据集 C（更古老的岩石；更宽的数据分布）：\n  - $x$ 值： $[0.30, 1.20, 2.80, 4.50, 7.50, 10.00]$\n  - $y$ 值： $[0.712295, 0.747371, 0.809941, 0.877448, 0.993603, 1.091396]$\n- 数据集 D（窄 $x$ 值分布；条件数检查）：\n  - $x$ 值： $[0.95, 0.98, 1.02, 1.05, 1.07]$\n  - $y$ 值： $[0.732715, 0.733462, 0.734507, 0.735274, 0.735825]$\n\n您的程序必须处理所有四个数据集，计算最佳拟合斜率 $\\hat{m}$，并使用上述公式将其转换为年龄 $\\hat{t}$，然后返回以百万年（Ma）为单位的年龄，结果四舍五入到两位小数。本问题不涉及角度。本问题不出现百分比。\n\n最终输出格式：您的程序应生成单行输出，其中包含数据集 A、B、C 和 D 的年龄（按此顺序），形式为方括号括起来的逗号分隔列表，例如：[1250.00, 0.00, 2700.00, 1800.00]。", "solution": "问题陈述已经过评估，被认为是有效的。它在科学上基于放射性衰变和地质年代学原理，在数学上是适定的，并为获得唯一解提供了所有必要信息。我们将着手进行推导和计算。\n\n目标是根据几组同位素比值的测量数据来确定岩石的年龄 $t$。所提供的数据是数据对 $(x_i, y_i)$，其中 $x_i = (^{87}\\mathrm{Rb}/^{86}\\mathrm{Sr})_i$ 且 $y_i = (^{87}\\mathrm{Sr}/^{86}\\mathrm{Sr})_i$ 代表不同的矿物样品 $i$。其物理模型基础是等时线方程，该方程预测了这些变量之间存在线性关系：\n$$\ny = b + mx\n$$\n在此，$b$ 代表岩石形成时（$t=0$）的初始同位素比值 $(^{87}\\mathrm{Sr}/^{86}\\mathrm{Sr})_{\\mathrm{initial}}$，而斜率 $m$ 通过放射性衰变方程与岩石年龄 $t$ 相关联：\n$$\nm = e^{\\lambda t} - 1\n$$\n其中 $\\lambda$ 是 $^{87}\\mathrm{Rb}$ 的衰变常数。\n\n任务要求根据给定的实验数据，为该线性模型找出最佳拟合参数。指定的方法是标准的非加权线性最小二乘回归。该方法确定斜率 $\\hat{m}$ 和截距 $\\hat{b}$，以最小化垂直残差的平方和 $S$：\n$$\nS = \\sum_{i=1}^{N} (y_i - (\\hat{m}x_i + \\hat{b}))^2\n$$\n使 $S$ 最小化的斜率 $\\hat{m}$ 的值由以下公式给出：\n$$\n\\hat{m} = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n$$\n其中 $N$ 是数据点的数量，$\\bar{x}$ 是 $x_i$ 值的均值，$\\bar{y}$ 是 $y_i$ 值的均值。只要 $x_i$ 值存在变化，该公式就提供一个唯一解，这对于所有给定的数据集都成立。截距 $\\hat{b}$ 可以通过 $\\hat{b} = \\bar{y} - \\hat{m}\\bar{x}$ 计算，但在确定年龄时并不需要。\n\n一旦计算出给定数据集的最佳拟合斜率 $\\hat{m}$，就可以通过反解斜率和年龄之间的关系来求得年龄 $\\hat{t}$。从 $\\hat{m} = e^{\\lambda \\hat{t}} - 1$ 出发，我们重新整理方程：\n$$\n1 + \\hat{m} = e^{\\lambda \\hat{t}}\n$$\n对两边取自然对数，得到：\n$$\n\\ln(1 + \\hat{m}) = \\ln(e^{\\lambda \\hat{t}}) = \\lambda \\hat{t}\n$$\n由此，我们解出年龄 $\\hat{t}$：\n$$\n\\hat{t} = \\frac{\\ln(1 + \\hat{m})}{\\lambda}\n$$\n问题指定了衰变常数 $\\lambda = 1.42 \\times 10^{-11}\\ \\mathrm{yr}^{-1}$。使用这个值，计算出的年龄 $\\hat{t}$ 的单位是年。最终要求是将年龄以百万年（Ma）为单位表示，这需要除以 $10^6$：\n$$\n\\hat{t}_{\\text{Ma}} = \\frac{\\hat{t}}{10^6} = \\frac{\\ln(1 + \\hat{m})}{\\lambda \\times 10^6}\n$$\n然后将结果四舍五入到两位小数。该过程将通过计算算法系统地应用于四个数据集中的每一个，以确保精度。对于数据集 B 的特殊情况，$y_i$ 值为常数，这正确地意味着斜率 $\\hat{m}=0$，因此年龄 $\\hat{t}=0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Rb-Sr isochron age for multiple geological data sets.\n    \n    The age is determined by performing a linear least-squares fit on the\n    isotope ratio data to find the slope of the isochron, then using the\n    slope to calculate the age based on the radioactive decay equation.\n    \"\"\"\n    \n    # Define the physical constant and test cases.\n    \n    # Decay constant for Rubidium-87 in yr^-1.\n    LAMBDA_RB87 = 1.42e-11\n    \n    # Isotope ratio data for four different rock samples.\n    # Each data set is a tuple of (x_values, y_values).\n    test_cases = [\n        # Data set A (general case)\n        (\n            [0.20, 0.80, 1.50, 2.50, 3.50, 5.00],\n            [0.702682, 0.713377, 0.725843, 0.743711, 0.761738, 0.788617]\n        ),\n        # Data set B (boundary with zero slope)\n        (\n            [0.00, 0.50, 1.00, 1.50, 3.00],\n            [0.704700, 0.704700, 0.704700, 0.704700, 0.704700]\n        ),\n        # Data set C (older rock; broader spread)\n        (\n            [0.30, 1.20, 2.80, 4.50, 7.50, 10.00],\n            [0.712295, 0.747371, 0.809941, 0.877448, 0.993603, 1.091396]\n        ),\n        # Data set D (narrow x spread; conditioning check)\n        (\n            [0.95, 0.98, 1.02, 1.05, 1.07],\n            [0.732715, 0.733462, 0.734507, 0.735274, 0.735825]\n        )\n    ]\n    \n    results = []\n    \n    for x_data, y_data in test_cases:\n        # Convert data to numpy arrays for numerical processing.\n        x = np.array(x_data)\n        y = np.array(y_data)\n        \n        # Perform linear regression to find the slope (m) of the line y = mx + b.\n        # np.polyfit with degree 1 fits a line and returns [slope, intercept].\n        # We only need the slope for the age calculation.\n        slope, _ = np.polyfit(x, y, 1)\n        \n        # The slope m is related to age t by m = exp(lambda * t) - 1.\n        # We solve for t: t = ln(1 + m) / lambda.\n        # A slope of 0 (or very close) will result in an age of 0, as log(1)=0.\n        # This handles Data set B correctly.\n        if 1 + slope = 0:\n            # This case is physically unrealistic for Rb-Sr dating but included for robustness.\n            # An age cannot be calculated. For this problem, we can assume slope > -1.\n            # We will treat this as an error or undefined age. \n            # However, problem data guarantees non-negative slope.\n            age_yr = np.nan\n        else:\n            age_yr = np.log(1 + slope) / LAMBDA_RB87\n            \n        # Convert age from years to million years (Ma).\n        age_ma = age_yr / 1e6\n        \n        # Format the result to two decimal places and add to the list.\n        results.append(f\"{age_ma:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2408074"}, {"introduction": "虽然线性模型十分强大，但真实的物理世界本质上往往是非线性的。本练习将带你进入非线性拟合的领域，挑战处理一个比理想气体定律更切合实际的气体模型——范德瓦尔斯方程。由于模型参数（例如，表示分子间吸引力的 $a$ 和分子自身体积的 $b$）与可观测量（压力 $P$）之间呈非线性关系，你将需要使用数值优化工具来寻找最佳参数估计。这个过程不仅能让你掌握处理非线性模型的关键技能，还能让你体验在拟合中施加物理约束的重要性。[@problem_id:2408017]", "problem": "给定一摩尔实际气体的范德瓦尔斯状态方程，\n$$(P + \\tfrac{a}{V^2})(V - b) = R\\,T,$$\n其中 $P$ 是压力，$V$ 是摩尔体积，$T$ 是绝对温度，$R$ 是普适气体常数，$a$ 和 $b$ 是表征与理想气体行为偏差的未知参数。等效地，作为 $(V,T,a,b)$ 函数的模型压力为\n$$P_{\\text{model}}(V,T;a,b) = \\frac{R\\,T}{V - b} - \\frac{a}{V^2}.$$\n使用普适气体常数 $R = 8.31446261815324\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$（请注意，$\\mathrm{J} = \\mathrm{Pa\\,m^3}$，因此当 $V$ 的单位为 $\\mathrm{m^3\\,mol^{-1}}$ 且 $T$ 的单位为 $\\mathrm{K}$ 时，$P$ 的单位为 $\\mathrm{Pa}$）。对于下述每个数据集，我们通过已知的基准参数 $(a_\\star,b_\\star)$ 以及一组指定的温度和摩尔体积来定义合成的压力-体积-温度（PVT）数据。每个压力数据点都由 $P_i = P_{\\text{model}}(V_i,T_i;a_\\star,b_\\star)$ 精确生成，不添加任何噪声。\n\n对于每个数据集，你的任务是：给定三元组列表 $\\{(T_i,V_i,P_i)\\}_{i=1}^N$，确定估计值 $(\\hat a,\\hat b)$，以最小化压力残差平方和\n$$S(a,b) = \\sum_{i=1}^{N}\\big(P_i - P_{\\text{model}}(V_i,T_i;a,b)\\big)^2,$$\n并满足物理约束条件 $a \\ge 0$ 和 $0 \\le b  \\min_i V_i$。报告 $\\hat a$（单位 $\\mathrm{Pa\\,m^6\\,mol^{-2}}$）和 $\\hat b$（单位 $\\mathrm{m^3\\,mol^{-1}}$）的值。\n\n测试套件定义（三个数据集）：\n- 数据集 $\\mathrm{A}$：\n  - 基准参数：$a_\\star = 0.1390\\,\\mathrm{Pa\\,m^6\\,mol^{-2}}$，$b_\\star = 3.913\\times 10^{-5}\\,\\mathrm{m^3\\,mol^{-1}}$。\n  - 温度：$\\{300\\,\\mathrm{K}, 350\\,\\mathrm{K}, 400\\,\\mathrm{K}\\}$。\n  - 摩尔体积：$\\{1.50\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}, 2.00\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}, 3.00\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}\\}$。\n  - 数据点：所有 9 种温度和体积的组合；$P_i$ 由模型使用 $(a_\\star,b_\\star)$ 精确计算得出。\n- 数据集 $\\mathrm{B}$：\n  - 基准参数：$a_\\star = 3.41\\times 10^{-3}\\,\\mathrm{Pa\\,m^6\\,mol^{-2}}$，$b_\\star = 2.37\\times 10^{-5}\\,\\mathrm{m^3\\,mol^{-1}}$。\n  - 温度：$\\{300\\,\\mathrm{K}, 600\\,\\mathrm{K}\\}$。\n  - 摩尔体积：$\\{1.00\\times 10^{-2}\\,\\mathrm{m^3\\,mol^{-1}}, 2.00\\times 10^{-2}\\,\\mathrm{m^3\\,mol^{-1}}, 5.00\\times 10^{-2}\\,\\mathrm{m^3\\,mol^{-1}}\\}$。\n  - 数据点：所有 6 种温度和体积的组合；$P_i$ 由模型使用 $(a_\\star,b_\\star)$ 精确计算得出。\n- 数据集 $\\mathrm{C}$：\n  - 基准参数：$a_\\star = 0.3592\\,\\mathrm{Pa\\,m^6\\,mol^{-2}}$，$b_\\star = 4.267\\times 10^{-5}\\,\\mathrm{m^3\\,mol^{-1}}$。\n  - 温度：$\\{350\\,\\mathrm{K}\\}$。\n  - 摩尔体积：$\\{1.20\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}, 2.50\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}\\}$。\n  - 数据点：在单一温度下的 2 个体积值；$P_i$ 由模型使用 $(a_\\star,b_\\star)$ 精确计算得出。\n\n要求的最终输出格式：\n- 按 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$ 的顺序，对每个数据集输出数对 $[\\hat a,\\hat b]$，两个数值均使用指定的国际单位制（SI），且每个数值均四舍五入至 $6$ 位有效数字。\n- 你的程序应生成单行输出，其中包含由方括号括起来的、以逗号分隔的三个数对列表，例如 $\\bigl[[\\hat{a}_{\\mathrm{A}},\\hat{b}_{\\mathrm{A}}], [\\hat{a}_{\\mathrm{B}},\\hat{b}_{\\mathrm{B}}], [\\hat{a}_{\\mathrm{C}},\\hat{b}_{\\mathrm{C}}]\\bigr]$，不含任何额外文本。", "solution": "所提出的问题是有效的。这是一个定义明确的计算物理任务，涉及热力学基本模型——范德瓦尔斯状态方程的参数估计。所有必需的数据、常数和约束条件都已提供，该问题在科学上是合理的、客观的且内部一致的。\n\n问题的核心是确定范德瓦尔斯模型的最优参数 $(\\hat{a}, \\hat{b})$，使其能最佳地复现给定的压力-体积-温度（$PVT$）数据集。模型压力由下式给出\n$$P_{\\text{model}}(V,T;a,b) = \\frac{R\\,T}{V - b} - \\frac{a}{V^2}$$\n其中 $R$ 是普适气体常数，$T$ 是温度，$V$ 是摩尔体积。待确定的参数是 $a$（表示分子间引力）和 $b$（表示每摩尔的排斥体积）。\n\n“最佳拟合”的标准是最小化残差平方和 $S(a,b)$：\n$$S(a,b) = \\sum_{i=1}^{N}\\big(P_i - P_{\\text{model}}(V_i,T_i;a,b)\\big)^2$$\n其中 $\\{ (T_i, V_i, P_i) \\}_{i=1}^N$ 是 $N$ 个数据点。这是一个非线性最小二乘优化问题。其非线性源于模型对参数 $b$ 的依赖，体现在 $(V-b)^{-1}$ 项中。因此，标准的线性回归方法不适用。\n\n此问题的一个关键方面是，压力数据 $P_i$ 是由模型本身使用已知的基准参数 $(a_\\star, b_\\star)$ 合成生成的，不含噪声。这意味着可以实现完美拟合，目标函数 $S(a,b)$ 的全局最小值恰好为零，并在 $(a,b) = (a_\\star, b_\\star)$ 处取得。因此，任务简化为通过数值方法恢复这些已知参数，这可作为对所选优化算法鲁棒性的有效测试。\n\n数值解是通过一个非线性最小二乘求解器实现的。SciPy 库中的 `scipy.optimize.least_squares` 函数非常适合此目的。该函数旨在最小化残差向量的 $L_2$ 范数。我们定义残差向量 $\\mathbf{r}(a,b)$，其分量为：\n$$r_i(a,b) = P_i - \\left( \\frac{R\\,T_i}{V_i - b} - \\frac{a}{V_i^2} \\right)$$\n然后，优化器找到使 $||\\mathbf{r}||^2 = S(a,b)$ 最小化的参数 $(\\hat{a}, \\hat{b})$。\n\n优化过程必须遵守问题中指定的物理约束：\n1.  $a \\ge 0$：分子间引力项为非负。\n2.  $0 \\le b  \\min_i V_i$：排斥体积 $b$ 必须为非负，并且在物理上不能超过数据集中最小的摩尔体积 $V_i$。\n\n这些约束在优化过程中作为参数的界限被施加：$a \\in [0, \\infty)$ 和 $b \\in [0, \\min_i V_i)$。\n\n对于迭代式非线性求解器，需要为参数提供一个初始猜测值。一个合乎逻辑的起点是理想气体极限，此时对理想气体定律没有修正。这对应于初始猜测值 $(a_0, b_0) = (0, 0)$。\n\n对每个数据集的处理流程如下：\n1.  从指定的范围构建数据点集合 $(T_i, V_i)$。\n2.  使用给定的基准参数 $(a_\\star, b_\\star)$ 和范德瓦尔斯模型计算相应的压力值 $P_i$。\n3.  调用 `scipy.optimize.least_squares` 求解器，并传入已定义的残差函数、初始猜测值 $(0,0)$ 以及从约束条件导出的物理界限。\n4.  对于数据集 A（$N=9$）和 B（$N=6$），系统是超定的（$N2$），这是最小二乘拟合的标准情况。对于数据集 C（$N=2$），系统是恰定的，这意味着我们在求解一个包含两个未知数的两个非线性方程组。最小二乘法具有通用性，可以正确处理所有这些情况。\n5.  提取得到的最优参数 $(\\hat{a}, \\hat{b})$。由于数据不含噪声，在求解器的容差范围内，这些估计值预计与基准参数 $(a_\\star, b_\\star)$ 在数值上是相同的。\n6.  最后，将估计出的参数 $\\hat{a}$ 和 $\\hat{b}$ 四舍五入到六位有效数字，并按照指定的科学记数法格式化，以用于最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves for the van der Waals parameters (a, b) for three different datasets\n    using nonlinear least-squares fitting.\n    \"\"\"\n    R = 8.31446261815324  # Universal gas constant in J mol^-1 K^-1\n\n    test_cases = [\n        {\n            \"a_star\": 0.1390,\n            \"b_star\": 3.913e-5,\n            \"T_vals\": np.array([300.0, 350.0, 400.0]),\n            \"V_vals\": np.array([1.50e-3, 2.00e-3, 3.00e-3]),\n        },\n        {\n            \"a_star\": 3.41e-3,\n            \"b_star\": 2.37e-5,\n            \"T_vals\": np.array([300.0, 600.0]),\n            \"V_vals\": np.array([1.00e-2, 2.00e-2, 5.00e-2]),\n        },\n        {\n            \"a_star\": 0.3592,\n            \"b_star\": 4.267e-5,\n            \"T_vals\": np.array([350.0]),\n            \"V_vals\": np.array([1.20e-3, 2.50e-3]),\n        },\n    ]\n\n    def p_model(params, T, V, R_const):\n        \"\"\"Calculates pressure using the van der Waals model.\"\"\"\n        a, b = params\n        return R_const * T / (V - b) - a / (V**2)\n\n    def residuals(params, T, V, P_data, R_const):\n        \"\"\"Calculates the residuals between model predictions and data.\"\"\"\n        return P_data - p_model(params, T, V, R_const)\n\n    formatted_results = []\n\n    for case in test_cases:\n        # 1. Generate the synthetic PVT data\n        T_grid, V_grid = np.meshgrid(case[\"T_vals\"], case[\"V_vals\"])\n        T_data = T_grid.flatten()\n        V_data = V_grid.flatten()\n        \n        true_params = [case[\"a_star\"], case[\"b_star\"]]\n        P_data = p_model(true_params, T_data, V_data, R)\n\n        # 2. Set up and run the optimization\n        # Initial guess: ideal gas limit (a=0, b=0)\n        x0 = [0.0, 0.0]\n        \n        # Physical constraints as bounds for the solver\n        min_V = np.min(V_data)\n        bounds = ([0.0, 0.0], [np.inf, min_V])\n\n        # Find the parameters that minimize the sum of squared residuals\n        result = optimize.least_squares(\n            residuals,\n            x0,\n            bounds=bounds,\n            args=(T_data, V_data, P_data, R),\n            method='trf'  # Trust Region Reflective algorithm, good for bounds\n        )\n        \n        a_hat, b_hat = result.x\n\n        # 3. Format the results to 6 significant figures\n        # The '.5e' format specifier ensures scientific notation with 1 digit\n        # before the decimal and 5 after, for a total of 6 significant figures.\n        a_hat_str = f\"{a_hat:.5e}\"\n        b_hat_str = f\"{b_hat:.5e}\"\n        \n        formatted_results.append(f\"[{a_hat_str},{b_hat_str}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2408017"}, {"introduction": "在科学研究中，我们常常需要整合来自多个独立实验的数据，以便更精确地测定一个普适的物理常数。这个练习模拟了一个典型场景：分析多个独立的衰变实验数据，这些实验被认为遵循着相同的物理规律，即拥有一个共同的衰变寿命 $\\tau$ 和一个共同的背景噪声率 $B$。本练习将指导你运用“全局拟合”这一强大技术，通过构建一个包含所有数据集的总目标函数，来同时估计每个实验特有的参数（振幅 $A_k$）和所有实验共享的全局参数。这种方法能够最大限度地利用所有可用信息，显著提高共享参数的估计精度，是现代科学数据分析的基石之一。[@problem_id:2408092]", "problem": "给定多个独立的数据集，每个数据集都测量一个带有恒定背景的衰减信号。其通用物理模型是：探测器的计数率信号由于单一粒子种类的存在而随时间指数衰减，该粒子种类在所有实验中具有相同的寿命，并且所有探测器共享一个恒定的背景率。对于索引为 $k$ 的数据集，在时间 $t_{k,i}$ 的测量得到观测计数率 $y_{k,i}$，其报告的标准差为 $\\sigma_{k,i}$。其正向模型为\n$$\ny_{k,i} \\approx A_k \\, e^{-t_{k,i}/\\tau} + B,\n$$\n其中 $A_k$ 是特定于数据集的振幅，$\\tau$ 是所有数据集共享的寿命，而 $B$ 是所有数据集共享的背景率。假设测量误差是加性的、独立的高斯误差，且标准差 $\\sigma_{k,i}$ 已知。在这些假设下，最大似然原理等同于最小化加权残差平方和。也就是说，估计的参数需最小化\n$$\nS(\\{A_k\\}, \\tau, B) = \\sum_{k} \\sum_{i} \\left( \\frac{y_{k,i} - \\left(A_k e^{-t_{k,i}/\\tau} + B\\right)}{\\sigma_{k,i}} \\right)^2.\n$$\n您的任务是编写一个完整的、可运行的程序，在每个测试案例中，使用加权最小二乘法 (WLS) 同时拟合所有数据集，以找到最佳拟合的共享寿命 $\\tau$ 和背景 $B$，同时允许每个数据集拥有其自身的振幅 $A_k$。根据物理意义约束参数：$A_k \\ge 0$，$ \\tau  0$ 和 $B \\ge 0$。优化过程必须直接最小化与上述模型对应的加权残差平方和，并将 $\\tau$ 和 $B$ 视为同一测试案例中所有数据集的共享参数。\n\n物理单位：将每个时间 $t$ 解读为秒，每个计数率 $y$ 解读为计数/秒。报告寿命 $\\tau$（单位：秒）和背景 $B$（单位：计数/秒）。将报告的每个数字四舍五入到小数点后三位。\n\n测试套件。对于下方的每个测试案例，程序必须同时拟合该案例中给出的所有数据集，并仅输出最佳拟合的共享 $\\tau$ 和共享 $B$，四舍五入到小数点后三位。\n\n测试案例 1（两个数据集，中等噪声，良态）：\n- 数据集 1：时间 $t_{1} = (0, 0.5, 1.0, 1.5, 2.0, 3.0)$，观测值 $y_{1} = (5.51, 4.38, 3.55, 2.86, 2.36, 1.62)$，不确定度 $\\sigma_{1} = (0.05, 0.05, 0.05, 0.05, 0.05, 0.05)$。\n- 数据集 2：时间 $t_{2} = (0, 0.7, 1.4, 2.1, 2.8, 3.5)$，观测值 $y_{2} = (3.49, 2.62, 2.00, 1.54, 1.25, 1.03)$，不确定度 $\\sigma_{2} = (0.08, 0.08, 0.08, 0.08, 0.08, 0.08)$。\n\n测试案例 2（一个振幅较小的数据集，测试 $B$ 的可辨识性）：\n- 数据集 1：时间 $t_{1} = (0, 0.5, 1.0, 1.5, 2.0)$，观测值 $y_{1} = (2.31, 1.50, 1.04, 0.75, 0.57)$，不确定度 $\\sigma_{1} = (0.02, 0.02, 0.02, 0.02, 0.02)$。\n- 数据集 2：时间 $t_{2} = (0, 1.0, 2.0, 3.0)$，观测值 $y_{2} = (0.49, 0.38, 0.33, 0.31)$，不确定度 $\\sigma_{2} = (0.01, 0.01, 0.01, 0.01)$。\n\n测试案例 3（三个数据集，具有不同的时间覆盖范围和不确定度）：\n- 数据集 1：时间 $t_{1} = (0, 1.0, 2.0, 3.0, 5.0)$，观测值 $y_{1} = (5.21, 4.05, 3.26, 2.67, 1.97)$，不确定度 $\\sigma_{1} = (0.03, 0.03, 0.03, 0.03, 0.03)$。\n- 数据集 2：时间 $t_{2} = (0.5, 1.5, 2.5, 4.0, 6.0)$，观测值 $y_{2} = (2.46, 2.12, 1.86, 1.60, 1.39)$，不确定度 $\\sigma_{2} = (0.05, 0.05, 0.05, 0.05, 0.05)$。\n- 数据集 3：时间 $t_{3} = (0, 0.2, 0.4, 0.6, 0.8, 1.0)$，观测值 $y_{3} = (7.19, 6.82, 6.44, 6.11, 5.79, 5.49)$，不确定度 $\\sigma_{3} = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含：测试案例 1 的拟合 $\\tau$ 和 $B$，然后是测试案例 2 的拟合 $\\tau$ 和 $B$，接着是测试案例 3 的拟合 $\\tau$ 和 $B$。每个数字都需四舍五入到小数点后三位，并采用上文指定的单位。例如，输出结构必须是 $[\\tau_1, B_1, \\tau_2, B_2, \\tau_3, B_3]$。", "solution": "所提出的问题是计算物理学中的一个标准练习：通过非线性最小二乘法将物理模型拟合到实验数据，从而进行参数估计。具体而言，我们的任务是对多个数据集进行全局分析，这些数据集被假定共享某些模型参数。该过程必须是稳健的，并基于可靠的统计学原理。\n\n验证步骤已确认该问题是适定的、科学上合理的且信息完整的。我们接下来着手求解。\n\n对于第 $k$ 个数据集，在时间 $t_{k,i}$ 的观测计数率 $y_{k,i}$ 的物理模型如下：\n$$\nf(t_{k,i}; A_k, \\tau, B) = A_k e^{-t_{k,i}/\\tau} + B\n$$\n此处，$A_k$是特定于数据集 $k$ 的振幅，而寿命 $\\tau$ 和恒定背景 $B$ 是全局参数，在单个测试案例中对所有数据集都是共同的。\n\n假设测量值受到独立的、加性的、已知标准差为 $\\sigma_{k,i}$ 的高斯噪声影响。在此假设下，最大似然原理等同于最小化加权残差平方和，这也被称为卡方（$\\chi^2$）统计量。因此，需要最小化的目标函数是：\n$$\nS(\\{A_k\\}, \\tau, B) = \\sum_{k} \\sum_{i} w_{k,i} \\left[ y_{k,i} - f(t_{k,i}; A_k, \\tau, B) \\right]^2\n$$\n其中权重是方差的倒数，$w_{k,i} = 1/\\sigma_{k,i}^2$。展开模型函数，我们得到：\n$$\nS(\\{A_k\\}, \\tau, B) = \\sum_{k} \\sum_{i} \\left( \\frac{y_{k,i} - \\left(A_k e^{-t_{k,i}/\\tau} + B\\right)}{\\sigma_{k,i}} \\right)^2\n$$\n这是一个非线性优化问题。对于一个包含 $N_d$ 个数据集的给定测试案例，所有待确定的参数集合为 $\\{A_1, A_2, \\dots, A_{N_d}, \\tau, B\\}$。总参数数量为 $N_d+2$。我们可以将这些参数表示为单个向量 $\\mathbf{p}$：\n$$\n\\mathbf{p} = (A_1, A_2, \\dots, A_{N_d}, \\tau, B)^T\n$$\n问题就变为找到使目标函数 $S(\\mathbf{p})$ 最小化的参数向量 $\\mathbf{p}^*$：\n$$\n\\mathbf{p}^* = \\underset{\\mathbf{p}}{\\operatorname{argmin}} S(\\mathbf{p})\n$$\n该最小化过程必须在以下物理约束条件下进行：\n$$\nA_k \\ge 0 \\quad \\forall k \\in \\{1, \\dots, N_d\\}\n\\\\\n\\tau  0\n\\\\\nB \\ge 0\n$$\n\n为了解决这个有约束的非线性优化问题，我们采用一种数值拟牛顿法，具体是在 `scipy.optimize.minimize` 函数中实现的带箱型约束的 Broyden–Fletcher–Goldfarb–Shanno 算法 (L-BFGS-B)。该方法非常适合此类问题。\n\n每个测试案例的求解过程如下：\n1.  **数据聚合**：收集属于单个测试案例的所有数据集 $(t_k, y_k, \\sigma_k)$。数据集的数量 $N_d$ 决定了参数空间的维度。\n2.  **目标函数实现**：构造一个 Python 函数，用于在给定参数向量 $\\mathbf{p}$ 和聚合数据的情况下计算 $S(\\mathbf{p})$。该函数将 $\\mathbf{p}$ 解析为单个振幅 $\\{A_k\\}$、寿命 $\\tau$ 和背景 $B$，然后计算所有数据集中所有数据点的加权残差平方总和。\n3.  **初始化**：迭代优化算法需要一个参数的初始猜测值 $\\mathbf{p}_0$。虽然 L-BFGS-B 方法相对稳健，但一个合理的起始点可以提高收敛速度和可靠性。我们设计一个简单的自动化策略来生成 $\\mathbf{p}_0$：\n    -   初始背景 $B_0$ 取所有观测数据点 $y_{k,i}$ 中的最小值。\n    -   初始寿命 $\\tau_0$ 估计为实验总时间跨度的一部分。\n    -   每个初始振幅 $A_{k,0}$ 根据相应数据集的第一个数据点，并扣除估计的背景来估算：$A_{k,0} \\approx y_{k, \\text{first}} - B_0$。所有初始估计值都向下取整到一个小的正数，以满足非负约束。\n4.  **约束实施**：将物理约束转化为优化算法的箱型边界。对于每个 $A_k$ 和 $B$，下界为 $0$，上界为无穷大。对于 $\\tau$，下界必须严格为正；我们使用一个小的机器精度值（例如，$10^{-9}$）来实际强制 $\\tau  0$。\n5.  **优化**：调用 `scipy.optimize.minimize` 函数，并传入目标函数、初始猜测向量 $\\mathbf{p}_0$、`L-BFGS-B` 方法和定义的边界。该函数会迭代地优化参数估计值，直到满足收敛标准。\n6.  **结果提取**：成功收敛后，优化器返回最优参数向量 $\\mathbf{p}^*$。所需的共享寿命 $\\tau^*$ 和背景 $B^*$ 是该向量的最后两个分量。\n\n将此过程系统地应用于提供的三个测试案例中的每一个。收集每个案例的 $\\tau$ 和 $B$ 的最终结果，然后按指定格式进行格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves a series of global data fitting problems for exponential decay.\n\n    Each test case involves one or more datasets that are fit simultaneously\n    to a model y = A_k * exp(-t/tau) + B, where tau and B are shared across\n    datasets within a test case.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        [\n            (np.array([0, 0.5, 1.0, 1.5, 2.0, 3.0]), np.array([5.51, 4.38, 3.55, 2.86, 2.36, 1.62]), np.array([0.05, 0.05, 0.05, 0.05, 0.05, 0.05])),\n            (np.array([0, 0.7, 1.4, 2.1, 2.8, 3.5]), np.array([3.49, 2.62, 2.00, 1.54, 1.25, 1.03]), np.array([0.08, 0.08, 0.08, 0.08, 0.08, 0.08]))\n        ],\n        # Test Case 2\n        [\n            (np.array([0, 0.5, 1.0, 1.5, 2.0]), np.array([2.31, 1.50, 1.04, 0.75, 0.57]), np.array([0.02, 0.02, 0.02, 0.02, 0.02])),\n            (np.array([0, 1.0, 2.0, 3.0]), np.array([0.49, 0.38, 0.33, 0.31]), np.array([0.01, 0.01, 0.01, 0.01]))\n        ],\n        # Test Case 3\n        [\n            (np.array([0, 1.0, 2.0, 3.0, 5.0]), np.array([5.21, 4.05, 3.26, 2.67, 1.97]), np.array([0.03, 0.03, 0.03, 0.03, 0.03])),\n            (np.array([0.5, 1.5, 2.5, 4.0, 6.0]), np.array([2.46, 2.12, 1.86, 1.60, 1.39]), np.array([0.05, 0.05, 0.05, 0.05, 0.05])),\n            (np.array([0, 0.2, 0.4, 0.6, 0.8, 1.0]), np.array([7.19, 6.82, 6.44, 6.11, 5.79, 5.49]), np.array([0.02, 0.02, 0.02, 0.02, 0.02, 0.02]))\n        ]\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        num_datasets = len(case)\n\n        # Objective function for the current test case\n        def objective_function(p):\n            # p = [A1, A2, ..., Ak, tau, B]\n            amplitudes = p[:num_datasets]\n            tau = p[num_datasets]\n            B = p[num_datasets + 1]\n            \n            total_chi_squared = 0.0\n            for k in range(num_datasets):\n                t_k, y_k, sigma_k = case[k]\n                A_k = amplitudes[k]\n                \n                y_model_k = A_k * np.exp(-t_k / tau) + B\n                residuals = (y_k - y_model_k) / sigma_k\n                total_chi_squared += np.sum(residuals**2)\n            \n            return total_chi_squared\n\n        # Automated initial guesses\n        B_guess = np.min([np.min(d[1]) for d in case])\n        max_time = np.max([np.max(d[0]) for d in case])\n        tau_guess = max_time / 2.0 if max_time > 0 else 1.0\n\n        A_guesses = []\n        for k in range(num_datasets):\n            y_first = case[k][1][0]\n            A_guess = max(1e-6, y_first - B_guess)\n            A_guesses.append(A_guess)\n            \n        p0 = A_guesses + [tau_guess, B_guess]\n\n        # Parameter bounds based on physical constraints\n        # Ak >= 0, tau > 0, B >= 0\n        bounds = [(0, None)] * num_datasets  # Bounds for A_k\n        bounds.append((1e-9, None))           # Bound for tau\n        bounds.append((0, None))              # Bound for B\n\n        # Perform the optimization\n        res = minimize(objective_function, p0, method='L-BFGS-B', bounds=bounds)\n        \n        # Extract optimal shared parameters tau and B\n        optimal_tau = res.x[num_datasets]\n        optimal_B = res.x[num_datasets + 1]\n        \n        results.append(optimal_tau)\n        results.append(optimal_B)\n\n    # Format the final output string\n    print(f\"[{','.join(f'{x:.3f}' for x in results)}]\")\n\nsolve()\n```", "id": "2408092"}]}