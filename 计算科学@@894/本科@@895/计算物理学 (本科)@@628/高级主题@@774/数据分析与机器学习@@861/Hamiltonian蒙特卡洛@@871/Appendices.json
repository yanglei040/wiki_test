{"hands_on_practices": [{"introduction": "哈密顿蒙特卡洛（HMC）的巧妙之处在于它将一个抽象的采样问题转化为一个具体的物理系统模拟。这个模拟的核心驱动力——引导采样器探索概率空间的“力”——直接来源于目标概率分布的对数。本练习旨在实践这关键的第一步：为一个给定的目标分布计算势能 $U(q)$ 的梯度，这是执行哈密顿动力学所必需的力项 [@problem_id:791690]。", "problem": "在哈密顿蒙特卡洛 (HMC)（一种马尔可夫链蒙特卡洛 (MCMC) 方法）的背景下，我们的目标是通过引入一个辅助动量变量 $p$ 来从目标概率分布 $\\pi(q)$ 中进行采样。系统的状态由 $(q, p)$ 描述，其动力学由一个哈密顿量 $H(q, p) = U(q) + K(p)$ 控制。\n\n势能 $U(q)$ 被定义为目标概率密度的负对数，相差一个加性常数：$U(q) = -\\log \\pi(q)$。动能 $K(p)$ 通常被定义为 $K(p) = \\frac{p^2}{2m}$，其中 $m$ 是一个“质量”参数。\n\n系统随时间的演化由哈密顿方程描述：\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -\\frac{\\partial U}{\\partial q}\n$$\n项 $-\\frac{\\partial U}{\\partial q}$ 充当一个引导采样器轨迹的“力”。实现 HMC 的一个关键步骤是为这个力项（即势能的梯度）推导出解析表达式。\n\n考虑从自由度为 $\\nu > 0$ 的单变量 Student t-分布中采样。随机变量 $q$ 的概率密度函数 (PDF) 由下式给出：\n$$\n\\pi(q) = \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\sqrt{\\nu\\pi} \\, \\Gamma\\left(\\frac{\\nu}{2}\\right)} \\left(1 + \\frac{q^2}{\\nu}\\right)^{-\\frac{\\nu+1}{2}}\n$$\n其中 $\\Gamma(\\cdot)$ 是伽马函数。\n\n请针对此目标分布，推导势能梯度 $\\frac{\\partial U}{\\partial q}$ 的表达式。你的最终表达式应使用位置变量 $q$ 和自由度参数 $\\nu$ 来表示。", "solution": "我们有势能\n$$\nU(q)=-\\ln\\pi(q)\n=-\\ln\\Bigl[\\tfrac{\\Gamma\\bigl(\\tfrac{\\nu+1}{2}\\bigr)}{\\sqrt{\\nu\\pi}\\,\\Gamma\\bigl(\\tfrac{\\nu}{2}\\bigr)}\\Bigr]\n+\\frac{\\nu+1}{2}\\ln\\Bigl(1+\\frac{q^2}{\\nu}\\Bigr)\\,.\n$$\n前置因子是关于 $q$ 的常数，因此，若忽略一个加性常数，则有：\n$$\nU(q)=\\frac{\\nu+1}{2}\\ln\\Bigl(1+\\frac{q^2}{\\nu}\\Bigr)\\,.\n$$\n对 $q$ 求导：\n\n$$\n\\frac{\\partial U}{\\partial q}\n=\\frac{\\nu+1}{2}\\cdot\\frac{1}{1+\\tfrac{q^2}{\\nu}}\\cdot\\frac{d}{dq}\\Bigl(\\tfrac{q^2}{\\nu}\\Bigr)\n=\\frac{\\nu+1}{2}\\cdot\\frac{1}{1+\\tfrac{q^2}{\\nu}}\\cdot\\frac{2q}{\\nu}\n=\\frac{(\\nu+1)\\,q}{\\nu+q^2}\\,.\n$$", "answer": "$$\\boxed{\\frac{(\\nu+1)\\,q}{\\nu+q^2}}$$", "id": "791690"}, {"introduction": "在确定了驱动系统的“力”之后，下一步便是模拟粒子在相空间中的运动轨迹。由于精确求解哈密顿方程通常不可行，我们采用数值积分方法，其中蛙跳法因其保持相空间体积和时间可逆性的优良特性而成为标准选择。本练习将引导你手动完成一个完整的蛙跳积分步骤，让你亲身体验位置和动量变量如何交错更新，从而加深对 HMC 核心算法的理解 [@problem_id:791880]。", "problem": "在哈密顿蒙特卡洛（HMC）这一流行的马尔可夫链蒙特卡洛方法的背景下，我们通过在扩展的状态空间 $(\\mathbf{q}, \\mathbf{p})$ 上模拟哈密顿动力学来对目标概率分布 $\\pi(\\mathbf{q})$ 进行采样。其中，$\\mathbf{q}$ 是位置向量（我们感兴趣的变量），而 $\\mathbf{p}$ 是一个辅助动量向量。\n\n哈密顿量 $H(\\mathbf{q}, \\mathbf{p})$ 是势能 $U(\\mathbf{q}) = -\\log \\pi(\\mathbf{q}) - C$（其中 C 是一个常数）与动能 $K(\\mathbf{p})$ 的和。该系统的演化由 Hamilton 方程决定：\n$$ \\frac{d\\mathbf{q}}{dt} = \\frac{\\partial H}{\\partial \\mathbf{p}}, \\quad \\frac{d\\mathbf{p}}{dt} = -\\frac{\\partial H}{\\partial \\mathbf{q}} $$\n这些方程使用辛积分器（最常用的是蛙跳法）进行数值积分。一个步长为 $\\epsilon$ 的蛙跳步通过以下三个顺序更新，将状态 $(\\mathbf{q}(t), \\mathbf{p}(t))$ 更新为 $(\\mathbf{q}(t+\\epsilon), \\mathbf{p}(t+\\epsilon))$：\n1.  动量的半步更新： $\\mathbf{p}(t+\\epsilon/2) = \\mathbf{p}(t) - \\frac{\\epsilon}{2} \\nabla_{\\mathbf{q}} U(\\mathbf{q}(t))$\n2.  位置的整步更新： $\\mathbf{q}(t+\\epsilon) = \\mathbf{q}(t) + \\epsilon \\mathbf{M}^{-1} \\mathbf{p}(t+\\epsilon/2)$\n3.  动量的第二个半步更新： $\\mathbf{p}(t+\\epsilon) = \\mathbf{p}(t+\\epsilon/2) - \\frac{\\epsilon}{2} \\nabla_{\\mathbf{q}} U(\\mathbf{q}(t+\\epsilon))$\n\n考虑一个二维系统，其中 $\\mathbf{q} = (q_1, q_2)^T$ 且 $\\mathbf{p} = (p_1, p_2)^T$。其势能和动能由下式给出：\n$$ U(\\mathbf{q}) = \\frac{1}{2}(q_1^2 + q_2^2) - c q_1 q_2 $$\n$$ K(\\mathbf{p}) = \\frac{1}{2m_1}p_1^2 + \\frac{1}{2m_2}p_2^2 $$\n此处，$c$、$m_1$ 和 $m_2$ 均为正常数，并有附加约束 $|c|<1$。动能对应于一个对角质量矩阵 $\\mathbf{M} = \\text{diag}(m_1, m_2)$。\n\n系统从初始状态 $(\\mathbf{q}_0, \\mathbf{p}_0)$ 开始，其中 $\\mathbf{q}_0 = (q_0, 0)^T$ 且 $\\mathbf{p}_0 = (0, p_0)^T$。\n\n你的任务是计算经过一个步长为 $\\epsilon$ 的蛙跳积分步骤后，提议状态 $(\\mathbf{q}', \\mathbf{p}')$ 的动量向量的第一个分量 $p'_1$。", "solution": "1. 在 q₀=(q₀,0) 处的梯度：\n   ∇U(q₀) = (q₀ − c·0,\\;0 − c·q₀) = (q₀, −c q₀).\n\n2. 动量半步更新：\n   $$p_{1/2}\n     = (0,p_0) - \\frac{\\epsilon}{2}(q_0,\\,-c q_0)\n     = \\Bigl(-\\frac{\\epsilon}{2}q_0,\\;p_0 + \\frac{c\\epsilon}{2}q_0\\Bigr).$$\n\n3. 位置整步更新 (M⁻¹=diag(1/m₁,1/m₂))：\n   $$q'=\n     \\begin{pmatrix}q_0 \\\\ 0\\end{pmatrix}\n     +\\epsilon\n     \\begin{pmatrix}1/m_1 & 0\\\\0 &1/m_2\\end{pmatrix}\n     p_{1/2}\n     =\\begin{pmatrix}\n       q_0 - \\frac{\\epsilon^2}{2m_1}q_0\\\\\n       \\frac{\\epsilon}{m_2}\\Bigl(p_0+\\frac{c\\epsilon}{2}q_0\\Bigr)\n      \\end{pmatrix}.$$\n   因此\n   $$q'_1=q_0\\Bigl(1-\\frac{\\epsilon^2}{2m_1}\\Bigr),\\quad\n     q'_2=\\frac{\\epsilon p_0}{m_2}+\\frac{c\\epsilon^2q_0}{2m_2}.$$\n\n4. 在 q′ 处的梯度：\n   $$\\frac{\\partial U}{\\partial q_1}\\bigg|_{q'}=q'_1 - c q'_2.$$\n\n5. p₁ 的第二个半步更新：\n   $$p'_1\n     = p_{1/2,1}-\\frac{\\epsilon}{2}(q'_1 - c q'_2)\n     = -\\frac{\\epsilon}{2}q_0\n       -\\frac{\\epsilon}{2}\\Bigl[q_0\\Bigl(1-\\tfrac{\\epsilon^2}{2m_1}\\Bigr)\n       -c\\Bigl(\\tfrac{\\epsilon p_0}{m_2}+\\tfrac{c\\epsilon^2q_0}{2m_2}\\Bigr)\\Bigr].$$\n\n6. 展开并合并各项：\n   合并 −ε/2q₀ 项，展开括号：\n   $$p'_1\n     = -\\epsilon q_0\n       +\\frac{\\epsilon^3q_0}{4m_1}\n       +\\frac{c^2\\epsilon^3q_0}{4m_2}\n       +\\frac{c\\epsilon^2p_0}{2m_2}.$$", "answer": "$$\\boxed{-\\epsilon q_0 + \\frac{\\epsilon^3 q_0}{4m_1} + \\frac{c^2 \\epsilon^3 q_0}{4m_2} + \\frac{c \\epsilon^2 p_0}{2m_2}}$$", "id": "791880"}, {"introduction": "掌握了基本力和积分步骤后，是时候将所有部分整合起来，构建一个完整的 HMC 采样器了。这个综合性练习要求你编写程序，对一个具有挑战性的、含有近奇异点势能的分布进行采样。通过解决这个实际问题，你将直面数值稳定性、步长选择与接受率之间的权衡等在 HMC 实际应用中的核心挑战 [@problem_id:2399525]。", "problem": "您需要设计并实现一个哈密顿蒙特卡洛采样器，以研究近奇异势对数值稳定性和接受行为的影响。工作将在一个一维空间中进行，质量等于$1$。您的推导必须严格基于哈密顿方程和Metropolis–Hastings法则，并从第一性原理出发。\n\n考虑一维吸引性库仑势的一个正则化且具有约束性的版本。将势能定义为\n$$\nU(q;a) \\equiv \\frac{1}{2}\\,q^2 - \\frac{c}{\\sqrt{q^2 + a^2}},\n$$\n其中 $c = 1$。参数 $a > 0$ 软化了 $q=0$ 处的奇异点，而二次项确保了目标分布的可归一性。目标概率密度与 $\\exp\\!\\left(-U(q;a)\\right)$ 成正比。使用动能\n$$\nK(p) \\equiv \\frac{1}{2} p^2,\n$$\n使得哈密顿量为 $H(q,p) \\equiv U(q;a) + K(p)$。\n\n您的任务是：\n- 为与 $H(q,p)$ 相关的哈密顿方程推导一个时间可逆、保体积的积分器，该积分器需与哈密顿蒙特卡洛所需的性质一致。您的构建应基于哈密顿方程导出的分裂原理，并避免任何非辛离散化。\n- 通过对 $U(q;a)$ 关于 $q$ 求导来计算力项。\n- 实现一个哈密顿蒙特卡洛核：给定当前位置 $q$，从零均值和单位方差的高斯分布中抽取一个新的动量 $p$，使用给定的步长 $\\epsilon$ 和步数 $L$ 对哈密顿动力学进行积分，然后使用轨迹开始和结束时的精确哈密顿量 $H(q,p)$ 应用Metropolis–Hastings接受/拒绝步骤。\n- 对于每个提议，通过追踪离散路径上访问过的 $q$ 的最小绝对值，并将其与固定阈值 $\\delta$ 进行比较，记录数值轨迹是否接近了软化奇异点。\n- 对于每组参数，在固定的 $N$ 次提议后，报告三个指标：接受率、平均哈密顿量绝对误差（所有提议的 $\\lvert \\Delta H \\rvert$ 的平均值），以及其数值轨迹满足 $\\min \\lvert q \\rvert &lt; \\delta$ 的提议所占的比例。\n\n必须使用的约束和固定选择：\n- 使用 $c = 1$ 和质量等于 $1$。\n- 每组参数使用 $N = 300$ 次哈密顿蒙特卡洛提议。\n- 使用阈值 $\\delta = 10^{-2}$。\n- 使用固定的随机数生成器种子 $12345$ 以确保可复现性。如果您选择在不同测试用例中改变种子，您必须以一种有文档记录的确定性方式进行，该方式仅依赖于测试用例索引和固定的基础种子。\n- 为了保证接受步骤的数值稳定性，请在对数空间中进行比较，利用接受条件等价于比较 $\\log u$ 与 $- \\Delta H$ 这一事实，其中 $u$ 从 $(0,1)$ 上的均匀分布中抽取。\n- 每个测试用例的初始位置 $q_0$ 在下方的测试套件中指定。始终从此 $q_0$ 开始马尔可夫链，并运行恰好 $N$ 次提议，不移除预烧期（burn-in）。\n\n参数值测试套件：\n- 情况 1：$\\epsilon = 0.05$, $L = 50$, $a = 0.1$, $q_0 = 1.0$。\n- 情况 2：$\\epsilon = 0.2$, $L = 50$, $a = 0.1$, $q_0 = 1.0$。\n- 情况 3：$\\epsilon = 0.05$, $L = 50$, $a = 0.001$, $q_0 = 0.1$。\n- 情况 4：$\\epsilon = 0.2$, $L = 50$, $a = 0.001$, $q_0 = 0.1$。\n\n指标定义：\n- 接受率是 $N$ 次提议中被接受的提议所占的比例，表示为 $[0,1]$ 范围内的小数。\n- 平均哈密顿量绝对误差是 $N$ 次提议的 $\\lvert \\Delta H \\rvert$ 的算术平均值，其中 $\\Delta H \\equiv H(q^{\\star},p^{\\star}) - H(q,p)$ 是数值轨迹终点和起点之间的哈密顿量变化，无论是否接受。\n- 近奇异点比例是其数值轨迹至少在一个离散积分步骤中满足 $\\min \\lvert q \\rvert &lt; \\delta$ 的提议所占的比例。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号内以逗号分隔的列表。每个测试用例的结果本身必须是按顺序排列的三个小数的列表：$[$接受率$, $平均哈密顿量绝对误差$, $近奇异点比例$]$，四舍五入到恰好 $6$ 位小数。例如，您的程序必须打印如下形式的内容：\n$$\n\\big[\\,[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]\\,\\big],\n$$\n其中每个 $a_i$、$b_i$、$c_i$ 都是四舍五入到 $6$ 位的小数。不应打印任何额外文本。", "solution": "问题陈述已经过评估并被确定为有效。这是一个在计算物理学领域中提法恰当、有科学依据的问题，包含了获得唯一确定性解所需的所有必要信息。我将继续进行推导和实现。\n\n主要任务是为一维空间中一个由特定势能函数控制的单位质量（$m=1$）粒子构建一个哈密顿蒙特卡洛（HMC）采样器。目标是分析在控制数值积分步长和与势奇异点接近程度的不同参数下，该采样器的性能。\n\n系统的哈密顿量 $H(q,p)$ 是动能 $K(p)$ 和势能 $U(q;a)$ 的总和：\n$$\nH(q,p) = K(p) + U(q;a)\n$$\n给定 $m=1$，动能为：\n$$\nK(p) = \\frac{1}{2} p^2\n$$\n势能给定为：\n$$\nU(q;a) = \\frac{1}{2}q^2 - \\frac{c}{\\sqrt{q^2 + a^2}}\n$$\n其中常数 $c=1$。参数 $a > 0$ 对类库仑吸引项进行正则化，防止在 $q=0$ 处出现真正的奇异点。二次项 $\\frac{1}{2}q^2$ 确保了目标概率密度 $\\pi(q) \\propto \\exp(-U(q;a))$ 是可归一化的。\n\n描述系统在相空间 $(q,p)$ 中演化的哈密顿运动方程为：\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -\\frac{\\partial U}{\\partial q}\n$$\n项 $-\\frac{\\partial U}{\\partial q}$ 是力 $F(q)$。我们计算这个导数：\n$$\n\\frac{\\partial U}{\\partial q} = \\frac{\\partial}{\\partial q} \\left(\\frac{1}{2}q^2 - (q^2 + a^2)^{-1/2}\\right) = q - \\left(-\\frac{1}{2}\\right)(q^2 + a^2)^{-3/2}(2q) = q + \\frac{q}{(q^2 + a^2)^{3/2}}\n$$\n因此，力为：\n$$\nF(q;a) = -q - \\frac{q}{(q^2 + a^2)^{3/2}}\n$$\n\n为了对这些动力学进行数值模拟，需要一个辛积分器。Leapfrog（或Störmer-Verlet）方法是一个标准选择，因为它既是时间可逆的也是保体积的，这些性质对HMC算法的正确性至关重要。该方法源于哈密顿演化算子的二阶Trotter-Suzuki分解，它将演化过程分解为在哈密顿量的动能和势能部分作用下的一系列步骤。一个大小为 $\\epsilon$ 的leapfrog步骤按如下方式更新位置 $q$ 和动量 $p$：\n$1$。对动量进行半步更新：\n$$\np(t + \\epsilon/2) = p(t) + F(q(t);a) \\cdot \\frac{\\epsilon}{2}\n$$\n$2$。对位置进行全步更新：\n$$\nq(t + \\epsilon) = q(t) + p(t + \\epsilon/2) \\cdot \\epsilon\n$$\n$3$。对动量进行第二次半步更新：\n$$\np(t + \\epsilon) = p(t + \\epsilon/2) + F(q(t+\\epsilon);a) \\cdot \\frac{\\epsilon}{2}\n$$\n为生成长度为 $L\\epsilon$ 的轨迹，此过程需迭代 $L$ 次。为了计算效率，相邻步骤的完整动量更新可以合并。\n\n对于每个提议，HMC算法从给定的位置 $q_{current}$ 开始，按以下步骤进行：\n$1$。 **动量采样**：从其条件分布中抽取一个新的动量 $p_{current}$。由于 $K(p) = p^2/2$，该分布为标准高斯分布，即 $p_{current} \\sim \\mathcal{N}(0, 1)$。\n$2$。 **轨迹积分**：从 $(q_{current}, p_{current})$ 开始，系统以步长 $\\epsilon$ 演化 $L$ 个leapfrog步骤。这会产生一个提议状态 $(q_{proposal}, p_{proposal})$。在此积分过程中，我们必须沿着离散路径 $q_0, q_1, \\ldots, q_L$ 追踪位置的最小绝对值 $\\min_i |q_i|$。\n$3$。 **Metropolis-Hastings接受**：根据哈密顿量的变化 $\\Delta H = H(q_{proposal}, p_{proposal}) - H(q_{current}, p_{current})$ 来接受或拒绝该提议。接受概率为 $\\alpha = \\min(1, \\exp(-\\Delta H))$。这种简单的形式之所以有效，是因为leapfrog积分器是保体积且时间可逆的。时间可逆性意味着，如果从 $(q_{proposal}, -p_{proposal})$ 开始并沿时间反向积分，将会恢复到 $(q_{current}, -p_{current})$，这使得提议在适当意义上是对称的。从 $U(0,1)$ 中抽取一个随机变量 $u$，如果 $u < \\exp(-\\Delta H)$（或等价地 $\\log u < -\\Delta H$），则接受提议。如果接受，新状态为 $q_{proposal}$；否则，状态保持为 $q_{current}$。\n\n对于每个测试用例的 $N=300$ 次提议，我们将记录三个量：（1）提议是否被接受，（2）哈密顿量绝对误差 $|\\Delta H|$，以及（3）轨迹的最小绝对位置是否低于阈值 $\\delta = 10^{-2}$。最终报告的指标将是这些量在所有 $N$ 次提议上的平均值。实现将按照规定使用固定的随机种子以确保可复现性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs a Hamiltonian Monte Carlo simulation for a 1D particle\n    with a regularized Coulomb-like potential, as specified in the problem statement.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    C_CONST = 1.0\n    N_PROPOSALS = 300\n    DELTA_THRESHOLD = 1e-2\n    BASE_SEED = 12345\n\n    # --- Test Suite ---\n    test_cases = [\n        # (epsilon, L, a, q0)\n        (0.05, 50, 0.1, 1.0),\n        (0.2, 50, 0.1, 1.0),\n        (0.05, 50, 0.001, 0.1),\n        (0.2, 50, 0.001, 0.1),\n    ]\n\n    all_results = []\n\n    # --- Physics and HMC Functions ---\n    def potential_energy(q, a):\n        \"\"\"Computes the potential energy U(q;a).\"\"\"\n        return 0.5 * q**2 - C_CONST / np.sqrt(q**2 + a**2)\n\n    def kinetic_energy(p):\n        \"\"\"Computes the kinetic energy K(p).\"\"\"\n        return 0.5 * p**2\n\n    def hamiltonian(q, p, a):\n        \"\"\"Computes the total energy H(q,p).\"\"\"\n        return potential_energy(q, a) + kinetic_energy(p)\n\n    def force(q, a):\n        \"\"\"Computes the force F = -dU/dq.\"\"\"\n        return -q - (C_CONST * q) / (q**2 + a**2)**(3/2)\n\n    for i, case in enumerate(test_cases):\n        epsilon, L, a, q0 = case\n        \n        # Use a deterministic seed for each case to ensure reproducibility\n        rng = np.random.default_rng(BASE_SEED + i)\n\n        q_current = q0\n        \n        accepted_count = 0\n        total_abs_h_error = 0.0\n        near_singularity_count = 0\n        \n        for _ in range(N_PROPOSALS):\n            # 1. Momentum Resampling\n            p_current = rng.normal(0, 1)\n\n            # Store initial state for MH step\n            q_initial, p_initial = q_current, p_current\n            h_initial = hamiltonian(q_initial, p_initial, a)\n\n            # --- 2. Trajectory Integration (Leapfrog) ---\n            q_prop, p_prop = q_initial, p_initial\n            \n            # Track if trajectory approaches singularity\n            min_abs_q = abs(q_prop)\n\n            # Initial half-step for momentum\n            p_prop += 0.5 * epsilon * force(q_prop, a)\n\n            # L-1 full steps for position and momentum\n            for _ in range(L - 1):\n                q_prop += epsilon * p_prop\n                min_abs_q = min(min_abs_q, abs(q_prop))\n                p_prop += epsilon * force(q_prop, a)\n            \n            # Final full step for position\n            q_prop += epsilon * p_prop\n            min_abs_q = min(min_abs_q, abs(q_prop))\n\n            # Final half-step for momentum\n            p_prop += 0.5 * epsilon * force(q_prop, a)\n            \n            # Record if trajectory passed the threshold\n            if min_abs_q  DELTA_THRESHOLD:\n                near_singularity_count += 1\n\n            # --- 3. Metropolis-Hastings Acceptance Step ---\n            h_proposal = hamiltonian(q_prop, p_prop, a)\n            delta_h = h_proposal - h_initial\n            total_abs_h_error += abs(delta_h)\n\n            # Acceptance check in log space for numerical stability\n            if np.log(rng.uniform(0, 1))  -delta_h:\n                q_current = q_prop\n                accepted_count += 1\n            # If rejected, q_current remains unchanged\n\n        # Calculate metrics for this test case\n        acceptance_rate = accepted_count / N_PROPOSALS\n        mean_abs_h_error = total_abs_h_error / N_PROPOSALS\n        near_singularity_fraction = near_singularity_count / N_PROPOSALS\n        \n        all_results.append([\n            acceptance_rate, \n            mean_abs_h_error, \n            near_singularity_fraction\n        ])\n\n    # Format the final output string exactly as required\n    outer_parts = []\n    for res in all_results:\n        inner_str = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\"\n        outer_parts.append(inner_str)\n    final_output_str = f\"[{','.join(outer_parts)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2399525"}]}