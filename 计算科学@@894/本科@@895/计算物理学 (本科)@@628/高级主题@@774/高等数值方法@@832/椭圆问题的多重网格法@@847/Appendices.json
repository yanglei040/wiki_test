{"hands_on_practices": [{"introduction": "在深入研究多重网格方法之前，了解求解椭圆型问题的其他快速算法是很有帮助的。本练习将引导你使用快速傅里叶变换（FFT）来求解周期性域上的泊松方程，其核心原理是利用拉普拉斯算子在周期域上的本征函数是傅里叶模式这一特性，从而在傅里叶空间中将微分方程转化为简单的代数方程。通过实现一个高效的基于 FFT 的求解器，你将对多重网格等先进方法所追求的性能基准有更深刻的认识，并从谱方法的角度理解问题的结构 [@problem_id:2415805]。", "problem": "编写一个完整、可运行的程序，通过求解一组给定右端项的泊松方程，来计算一个周期性三维网格上的引力势。使用一个边长为 $1$ 的周期性立方体域，坐标 $x,y,z \\in [0,1)$。在该域上使用一个包含 $N \\times N \\times N$ 个点的均匀笛卡尔网格，网格间距为 $h = 1/N$，并在所有面上施加周期性边界条件。考虑无量纲化的泊松方程\n$$\n\\nabla^2 \\phi(x,y,z) = f(x,y,z),\n$$\n并附加规范条件，即 $\\phi$ 的空间平均值为零，也就是\n$$\n\\frac{1}{|\\Omega|}\\int_{\\Omega}\\phi(x,y,z)\\,dx\\,dy\\,dz = 0,\n$$\n其中 $|\\Omega| = 1$ 是域的体积。该方程应在离散意义上进行解释，使用网格上的标准 $7$ 点周期性有限差分拉普拉斯算子：\n$$\n(L_h \\phi)_{i,j,k} = \\frac{1}{h^2}\\Big(\\phi_{i+1,j,k}+\\phi_{i-1,j,k}+\\phi_{i,j+1,k}+\\phi_{i,j-1,k}+\\phi_{i,j,k+1}+\\phi_{i,j,k-1}-6\\phi_{i,j,k}\\Big),\n$$\n其中，为了施加周期性，指数在每个方向上均对 $N$ 取模。网格点应位于 $(x_i,y_j,z_k) = (i/N, j/N, k/N)$，其中整数 $i,j,k \\in \\{0,1,\\dots,N-1\\}$。\n\n对于下述的每个测试用例，您的程序必须计算满足零平均值规范的离散泊松方程 $L_h \\phi_h = f_h$ 的数值近似解 $\\phi_h$，然后报告一个指定的标量值。所有量都是无量纲的。角度（若有）以弧度为单位。最终输出必须是单独一行，其中包含一个由方括号括起来的、包含三个浮点数值的逗号分隔列表，顺序与下方给出的测试用例一致，且不含任何额外文本。\n\n测试套件（每个用例指定 $N$ 和一个右端项 $f(x,y,z)$；通过在网格上对 $f$ 采样并以数值方式减去其平均值来定义 $f_h$，从而使离散相容性条件成立）：\n\n- 用例 $1$：$N=16$。定义\n$$\nf(x,y,z) = \\sin(2\\pi x)\\sin(2\\pi y)\\sin(2\\pi z).\n$$\n对于此用例，同时定义连续解析参考场\n$$\n\\phi_{\\mathrm{ref}}(x,y,z) = -\\frac{1}{(2\\pi)^2\\cdot 3}\\sin(2\\pi x)\\sin(2\\pi y)\\sin(2\\pi z),\n$$\n它在连续统中求解 $\\nabla^2 \\phi_{\\mathrm{ref}} = f$ 且均值为零。计算出数值解 $\\phi_h$ 后，报告离散均方根（RMS）误差\n$$\nE_1 = \\left(\\frac{1}{N^3}\\sum_{i,j,k}\\left(\\phi_h(i,j,k)-\\phi_{\\mathrm{ref}}(x_i,y_j,z_k)\\right)^2\\right)^{1/2}.\n$$\n\n- 用例 $2$：$N=32$。定义\n$$\nf(x,y,z) = \\sin(2\\pi x)\\sin(2\\pi y) + \\frac{1}{2}\\sin(4\\pi z).\n$$\n对于此用例，同时定义连续解析参考场\n$$\n\\phi_{\\mathrm{ref}}(x,y,z) = -\\frac{1}{(2\\pi)^2\\cdot 2}\\sin(2\\pi x)\\sin(2\\pi y) - \\frac{1}{2}\\cdot\\frac{1}{(4\\pi)^2}\\sin(4\\pi z),\n$$\n它在连续统中求解 $\\nabla^2 \\phi_{\\mathrm{ref}} = f$ 且均值为零。计算出数值解 $\\phi_h$ 后，报告离散均方根（RMS）误差\n$$\nE_2 = \\left(\\frac{1}{N^3}\\sum_{i,j,k}\\left(\\phi_h(i,j,k)-\\phi_{\\mathrm{ref}}(x_i,y_j,z_k)\\right)^2\\right)^{1/2}.\n$$\n\n- 用例 $3$：$N=8$。定义\n$$\nf(x,y,z) \\equiv 0.\n$$\n在此用例中，施加规范条件后的精确连续解恒为零。计算出数值解 $\\phi_h$ 后，报告离散 RMS 幅值\n$$\nE_3 = \\left(\\frac{1}{N^3}\\sum_{i,j,k}\\left(\\phi_h(i,j,k)\\right)^2\\right)^{1/2}.\n$$\n\n您的程序必须生成单行输出，按顺序包含三个结果 $[E_1,E_2,E_3]$。例如，一个有效的输出行应如下所示\n\"[0.00123,0.00045,0.0]\"。", "solution": "所提出的问题是在一个周期性立方体域上对三维泊松方程 $\\nabla^2 \\phi = f$ 进行数值求解。该问题定义明确、有科学依据，并为获得唯一解提供了所有必要信息。这是计算物理学中的一个标准问题，我们将给出一个完整的解法。\n\n在周期性域上求解常系数线性偏微分方程最有效的方法是使用快速傅里叶变换（FFT）。周期性边界条件和拉普拉斯算子的结构意味着离散傅里叶模式（复指数函数）是离散拉普拉斯算子的精确本征函数。这一性质使得实空间中的耦合线性代数方程组可以被转换为傅里叶空间中一组独立的代数方程，从而可以被轻易求解。\n\n问题是在一个大小为 $N \\times N \\times N$ 的均匀笛卡尔网格上求解离散泊松方程 $L_h \\phi_h = f_h$。网格间距为 $h=1/N$。离散场 $\\phi_h$ 由网格点 $(x_i, y_j, z_k) = (i/N, j/N, k/N)$ 上的值 $\\phi_{i,j,k}$ 表示，其中整数 $i,j,k \\in \\{0, 1, \\dots, N-1\\}$。7 点离散拉普拉斯算子 $L_h$ 由下式给出：\n$$\n(L_h \\phi)_{i,j,k} = \\frac{1}{h^2}\\Big(\\phi_{i+1,j,k}+\\phi_{i-1,j,k}+\\phi_{i,j+1,k}+\\phi_{i,j-1,k}+\\phi_{i,j,k+1}+\\phi_{i,j,k-1}-6\\phi_{i,j,k}\\Big)\n$$\n其中，为了施加周期性，指数对 $N$ 取模。\n\n我们将三维离散傅里叶变换（DFT）应用于方程 $L_h \\phi_h = f_h$。DFT 将实空间网格函数 $\\psi_{i,j,k}$ 转换为其傅里叶空间表示 $\\hat{\\psi}_{p,q,r}$，其中 $(p,q,r)$ 是整数频率指数。卷积算子 $L_h$ 在实空间中的作用在傅里叶空间中变为简单的乘法：\n$$\n\\hat{L}_{p,q,r} \\hat{\\phi}_{p,q,r} = \\hat{f}_{p,q,r}\n$$\n这里，$\\hat{L}_{p,q,r}$ 是算子 $L_h$ 的本征值，对应于频率向量为 $(p,q,r)$ 的离散傅里叶模式。这些本征值可以通过将 $L_h$ 应用于本征函数 $\\exp(2\\pi i (pi/N + qj/N + rk/N))$ 来找到，其结果为：\n$$\n\\hat{L}_{p,q,r} = \\frac{1}{h^2} \\left( e^{2\\pi i p/N} + e^{-2\\pi i p/N} + e^{2\\pi i q/N} + e^{-2\\pi i q/N} + e^{2\\pi i r/N} + e^{-2\\pi i r/N} - 6 \\right)\n$$\n使用关系式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，本征值为：\n$$\n\\hat{L}_{p,q,r} = \\frac{2}{h^2} \\left[ \\cos\\left(\\frac{2\\pi p}{N}\\right) + \\cos\\left(\\frac{2\\pi q}{N}\\right) + \\cos\\left(\\frac{2\\pi r}{N}\\right) - 3 \\right]\n$$\n势 $\\phi_h$ 的傅里叶系数的解随后通过除法求得：\n$$\n\\hat{\\phi}_{p,q,r} = \\frac{\\hat{f}_{p,q,r}}{\\hat{L}_{p,q,r}}\n$$\n对于零频模式，即 $(p,q,r) = (0,0,0)$，此过程会遇到奇异点。对于此模式，$\\hat{L}_{0,0,0} = \\frac{2}{h^2} (\\cos(0) + \\cos(0) + \\cos(0) - 3) = 0$。除以零是未定义的。这反映了一个事实：在全周期域上的泊松方程只有在源项 $f_h$ 满足相容性条件时才可解。离散相容性条件是源项在整个网格上的和必须为零：$\\sum_{i,j,k} f_{i,j,k} = 0$。在傅里叶空间中，这对应于零频分量为零：$\\hat{f}_{0,0,0} = 0$。问题陈述正确地要求通过从离散源项 $f_h$ 中以数值方式减去其平均值来强制执行此条件。\n\n当 $\\hat{f}_{0,0,0} = 0$ 时，零模式的方程变为 $0 \\cdot \\hat{\\phi}_{0,0,0} = 0$，这意味着 $\\hat{\\phi}_{0,0,0}$ 是不确定的。这对应于可以在势 $\\phi$ 上添加任意常数的自由度。问题通过施加一个规范条件来解决此模糊性：$\\phi$ 的空间平均值必须为零。对于离散解 $\\phi_h$，这意味着 $\\sum_{i,j,k} \\phi_{i,j,k} = 0$，这等价于将其零频分量设置为零：$\\hat{\\phi}_{0,0,0} = 0$。\n\n完整的算法如下：\n1. 对于给定的网格尺寸 $N$ 和源函数 $f(x,y,z)$，通过在网格点 $(x_i, y_j, z_k)$ 上对 $f$ 求值来创建离散源场 $f_h$。\n2. 通过从 $f_h$ 中减去平均值来强制满足相容性条件：$f_h \\leftarrow f_h - \\frac{1}{N^3} \\sum_{i,j,k} f_{i,j,k}$。\n3. 对修改后的 $f_h$ 进行三维 FFT 计算，以获得 $\\hat{f}_{p,q,r}$。\n4. 构建本征值的三维数组 $\\hat{L}_{p,q,r}$。\n5. 对于所有非零频率 $(p,q,r) \\neq (0,0,0)$，计算解的傅里叶系数 $\\hat{\\phi}_{p,q,r} = \\hat{f}_{p,q,r} / \\hat{L}_{p,q,r}$。\n6. 将解的零频分量设置为零，即 $\\hat{\\phi}_{0,0,0} = 0$，以满足规范条件。\n7. 对 $\\hat{\\phi}_{p,q,r}$ 进行三维逆 FFT 计算，以获得实空间中的解 $\\phi_h$。由于源项是实数且算子是对称的，解 $\\phi_h$ 必须是实数。我们取 IFFT 结果的实部，以舍弃由浮点算术误差产生的可忽略的虚部。\n8. 最后，对于每个测试用例，使用计算出的数值解 $\\phi_h$ 来计算指定的标量值（$E_1, E_2, E_3$）。\n\n此过程将为所提供的三个测试用例实现。对于用例 1 和 2，我们计算相对于所提供解析解的均方根（RMS）误差。对于用例 3，源为零，精确解也为零，我们报告计算出的数值解的 RMS 幅值，该值应接近于浮点精度。", "answer": "```python\nimport numpy as np\n\ndef solve_poisson_fft(N, f_func, phi_ref_func=None):\n    \"\"\"\n    Solves the 3D periodic Poisson equation using the FFT method.\n\n    Args:\n        N (int): The number of grid points in each dimension.\n        f_func (callable): A function f(x, y, z) for the right-hand side.\n        phi_ref_func (callable, optional): A function phi_ref(x, y, z) for\n            the analytical reference solution. If None, the RMS magnitude of\n            the solution is computed instead of the error.\n\n    Returns:\n        float: The computed RMS error or RMS magnitude.\n    \"\"\"\n    # 1. Define grid parameters and coordinates.\n    h = 1.0 / N\n    indices = np.indices((N, N, N))\n    x = indices[0] * h\n    y = indices[1] * h\n    z = indices[2] * h\n\n    # 2. Construct discrete source term f_h and enforce compatibility.\n    f_h = f_func(x, y, z)\n    f_h -= np.mean(f_h)\n\n    # 3. Compute the 3D FFT of the source term.\n    f_k = np.fft.fftn(f_h)\n\n    # 4. Construct the array of eigenvalues for the discrete Laplacian.\n    # The frequencies are p/N, where p are integer wave numbers.\n    freq_unit = np.fft.fftfreq(N)\n    p_N, q_N, r_N = np.meshgrid(freq_unit, freq_unit, freq_unit, indexing='ij')\n\n    L_k = (2.0 / h**2) * (np.cos(2 * np.pi * p_N) +\n                           np.cos(2 * np.pi * q_N) +\n                           np.cos(2 * np.pi * r_N) - 3.0)\n\n    # 5. Solve for Fourier coefficients of phi, handling the k=0 singularity.\n    phi_k = np.zeros_like(f_k, dtype=complex)\n    \n    # Create a mask for non-zero frequencies.\n    # L_k is zero at (0,0,0), but f_k is also zero there due to mean subtraction.\n    # The result phi_k[0,0,0] should be 0 due to the gauge condition.\n    # We only compute the division for non-zero k.\n    non_zero_k_mask = (L_k != 0)\n    phi_k[non_zero_k_mask] = f_k[non_zero_k_mask] / L_k[non_zero_k_mask]\n    \n    # Explicitly enforce the gauge condition phi_k[0,0,0]=0\n    # This is already handled by initializing phi_k to zeros and dividing only\n    # for non_zero_k, but we state it for clarity.\n    phi_k[0, 0, 0] = 0.0\n\n    # 6. Compute the inverse 3D FFT to get the real-space solution.\n    phi_h = np.real(np.fft.ifftn(phi_k))\n\n    # 7. Calculate and return the required scalar quantity.\n    if phi_ref_func:\n        phi_ref = phi_ref_func(x, y, z)\n        # RMS Error\n        rms_val = np.sqrt(np.mean((phi_h - phi_ref)**2))\n    else:\n        # RMS Magnitude\n        rms_val = np.sqrt(np.mean(phi_h**2))\n        \n    return rms_val\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define functions for test cases\n    # Case 1: N=16\n    def f1(x, y, z):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y) * np.sin(2 * np.pi * z)\n\n    def phi_ref1(x, y, z):\n        return -1.0 / (3.0 * (2 * np.pi)**2) * f1(x, y, z)\n\n    # Case 2: N=32\n    def f2(x, y, z):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y) + 0.5 * np.sin(4 * np.pi * z)\n\n    def phi_ref2(x, y, z):\n        term1 = -1.0 / (2.0 * (2 * np.pi)**2) * np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        term2 = -0.5 / ((4 * np.pi)**2) * np.sin(4 * np.pi * z)\n        return term1 + term2\n\n    # Case 3: N=8\n    def f3(x, y, z):\n        return np.zeros_like(x)\n\n    test_cases = [\n        {'N': 16, 'f_func': f1, 'phi_ref_func': phi_ref1},\n        {'N': 32, 'f_func': f2, 'phi_ref_func': phi_ref2},\n        {'N': 8, 'f_func': f3, 'phi_ref_func': None}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_poisson_fft(case['N'], case['f_func'], case['phi_ref_func'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2415805"}, {"introduction": "在了解了 FFT 求解器之后，我们现在来解决本章的核心主题：构建一个多重网格求解器，它在适用性上比依赖于特定边界条件的方法更为广泛。本实践将指导你从零开始实现一个完整的几何多重网格 V-循环，包括用于衰减高频误差的平滑器，以及在粗糙网格上处理低频误差的网格传递算子（限制和延拓）。通过亲手实现，你将揭开多重网格方法高效的奥秘，并理解其不同组件之间的协同作用 [@problem_id:2415837]。", "problem": "考虑单位正方形上的二维椭圆偏微分方程 (PDE)，其带有齐次 Dirichlet 边界条件 (DBC)：\n$$\n-\\Delta u(x,y) = f(x,y) \\quad \\text{for } (x,y)\\in (0,1)\\times (0,1), \\qquad u(x,y)=0 \\quad \\text{on } \\partial([0,1]\\times[0,1]).\n$$\n使用包含 $N\\times N$ 个未知数的均匀笛卡尔网格对内部区域进行离散化，网格间距为 $h=1/(N+1)$，并使用标准的 5 点有限差分格式来表示离散负拉普拉斯算子。设右端项 $f$ 是一个点源，该点源位于与某个网格节点重合的点上，并被建模为 Dirac delta 函数。在网格上，通过一个离散的 Kronecker delta 来表示此点源，并进行缩放以在连续极限下保持单位积分，即，在选定的网格节点 $(i_{0},j_{0})$ 处设置 $f_{i_{0},j_{0}}=1/h^{2}$，而在其他地方设置 $f_{i,j}=0$。在下文所有情况中，索引 $(i,j)$ 指的是内部网格索引，$i,j\\in\\{0,1,\\dots,N-1\\}$，其对应的物理位置为 $(x_{i},y_{j})=((i+1)h,(j+1)h)$。\n\n你的任务是为该离散化所产生的线性系统实现一个几何多重网格 V-循环求解器。请从以下基本要素出发：\n- 在内部区域上，采用 5 点有限差分格式得到的、与 $-\\Delta$ 对应的离散算子由下式给出：\n$$\n(Au)_{i,j}=\\frac{4u_{i,j}-u_{i+1,j}-u_{i-1,j}-u_{i,j+1}-u_{i,j-1}}{h^{2}},\n$$\n其中齐次 DBC 通过将内部区域以外的值视为零来施加。\n- 位于 $(i_{0},j_{0})$ 且具有单位积分的点源的 Kronecker-delta 表示法要求 $f_{i_{0},j_{0}}=1/h^{2}$，从而使得 $\\sum_{i,j} f_{i,j} h^{2}=1$。\n\n设计一个 V-循环，在每一层级上：\n- 使用权重为 $\\omega=2/3$ 的加权 Jacobi 光滑化进行 $\\nu_{1}$ 次前光滑步骤和 $\\nu_{2}$ 次后光滑步骤。取 $\\nu_{1}=\\nu_{2}=3$。加权 Jacobi 更新公式为：\n$$\nu \\leftarrow u + \\omega D^{-1}(f-Au),\n$$\n其中 $D$ 是 $A$ 的对角部分，即 $D_{i,j}=4/h^{2}$，因此 $D^{-1}=(h^{2}/4)I$。\n- 采用全加权限制算子将细网格残差转移到粗网格。\n- 采用双线性插值对粗网格误差修正量进行延拓。\n- 通过标准粗化进行递归，内部尺寸由 $N\\mapsto(N-1)/2$，并假设 $N$ 的形式为 $2^{\\ell}-1$。在 $N\\le 3$ 的最粗层级，通过对离散算子进行直接稠密求解来精确求解线性系统。\n\n在每次完整的 V-循环后，使用相对残差来量化稳健性：\n$$\n\\rho = \\frac{\\lVert r \\rVert_{2}}{\\lVert f \\rVert_{2}}, \\quad r=f-Au,\n$$\n其中 $\\lVert\\cdot\\rVert_{2}$ 是欧几里得范数。从零初始猜测开始迭代 V-循环，直到 $\\rho \\le \\epsilon$ 或已执行最大 $K$ 次循环为止。报告每个测试用例最终达到的 $\\rho$ 值。\n\n测试套件。为以下参数集实现并运行您的求解器，这些参数集共同探测了理想路径、近边界行为、多点源叠加以及较小网格的边缘情况：\n- 情况 1：$N=63$，一个点源位于 $(i_{0},j_{0})=(31,31)$，容差 $\\epsilon=10^{-8}$，最大循环次数 $K=20$。\n- 情况 2：$N=63$，一个点源位于 $(i_{0},j_{0})=(1,1)$，容差 $\\epsilon=10^{-8}$，最大循环次数 $K=20$。\n- 情况 3：$N=31$，两个点源位于 $(i_0, j_0) \\in \\{(7,7), (23,23)\\}$，两处的值均设为 $1/h^{2}$，容差 $\\epsilon=10^{-8}$，最大循环次数 $K=20$。\n- 情况 4：$N=31$，一个点源位于 $(i_{0},j_{0})=(0,0)$，容差 $\\epsilon=10^{-8}$，最大循环次数 $K=20$。\n\n最终输出格式。您的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔的浮点数列表，每个浮点数是相应情况下最终的相对残差 $\\rho$，并四舍五入到 6 位有效数字（例如，`[3.2e-07,1.1e-09, \\dots]`）。不应打印任何其他文本。", "solution": "所提出的问题是计算物理学中一项有效且适定的任务。它要求为在单位正方形上、带有齐次 Dirichlet 边界条件的二维 Poisson 方程 $-\\Delta u = f$ 的有限差分格式离散化所产生的线性系统 $Au = f$ 实现一个几何多重网格 V-循环求解器。该问题具有科学依据、内容自洽，并且所有参数和算法都以足够的精度进行了规定，足以实现唯一的实施方案。\n\n多重网格方法的核心原理是通过在一个粗化网格的层次结构上求解误差，来加速基本迭代求解器（即“光滑子”）的收敛速度。误差的高频分量可以由细网格上的光滑子有效衰减，而低频分量则在粗网格上求解，在粗网格上，这些低频分量表现为高频，从而可以被有效衰减。V-循环是遍历此网格层次结构的一种特定的递归算法。\n\n解决方案的结构如下：首先，我们定义多重网格算法的各个组成部分——离散算子、光滑子以及网格转移算子（限制和延拓）。然后，我们将这些部分组合成递归的 V-循环过程。\n\n**1. 离散化与算子**\n\n连续问题在一个具有 $N \\times N$ 个内部点和网格尺寸 $h = 1/(N+1)$ 的均匀网格上进行离散化。解 $u$ 和右端项 $f$ 表示为 $N \\times N$ 的数组。离散负拉普拉斯算子 $A$ 由 5 点格式给出：\n$$\n(Au)_{i,j} = \\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2}\n$$\n对于内部索引 $i,j \\in \\{0, 1, \\dots, N-1\\}$。齐次 Dirichlet 边界条件通过将此内部范围外的任何索引对 $(i,j)$ 的 $u_{i,j}$ 值设为 0 来施加。\n\n**2. 加权 Jacobi 光滑子**\n\n光滑子的作用是减少高频误差。我们使用加权 Jacobi 方法。单个光滑步骤的更新公式为：\n$$\nu \\leftarrow u + \\omega D^{-1}(f - Au)\n$$\n此处，$r = f - Au$ 是残差。矩阵 $D$ 是 $A$ 的对角部分，对于所有内部点，其值恒为 $D_{i,j} = 4/h^2$。因此，其逆是一个标量乘法：$D^{-1} = (h^2/4)I$。选择权重 $\\omega = 2/3$ 是因为它对该特定算子具有良好的光滑特性。我们在粗化前执行 $\\nu_1 = 3$ 次预光滑步骤，在从粗网格校正后执行 $\\nu_2 = 3$ 次后光滑步骤。\n\n**3. 网格转移算子**\n\n网格转移算子在细网格和粗网格之间移动数据。网格层次结构由尺寸为 $N = 2^\\ell - 1$ 的网格的标准粗化规则定义，其中一个尺寸为 $N_{\\text{fine}}$ 的细网格被映射到一个尺寸为 $N_{\\text{coarse}} = (N_{\\text{fine}} - 1)/2$ 的粗网格。\n\n**限制 ($R$)：**细网格残差 $r^{\\text{fine}}$ 被转移到粗网格，以构成粗网格误差方程的右端项，$r^{\\text{coarse}} = R r^{\\text{fine}}$。我们使用全加权限制，其中一个粗网格点的值是 9 个相应细网格点值的加权平均。以细网格点 $(2I+1, 2J+1)$ 为中心的粗网格点 $(I,J)$ 的计算格式为：\n$$\nr^{\\text{coarse}}_{I,J} = \\frac{1}{16} \\sum_{i,j \\in \\{-1,0,1\\}} w_{i,j} r^{\\text{fine}}_{2I+1+i, 2J+1+j}, \\quad \\text{with weights } W = \\begin{pmatrix} 1 & 2 & 1 \\\\ 2 & 4 & 2 \\\\ 1 & 2 & 1 \\end{pmatrix}\n$$\n\n**延拓 ($P$)：**在粗网格上求解误差方程后，得到的误差修正量 $e^{\\text{coarse}}$ 必须被插值回细网格：$e^{\\text{fine}} = P e^{\\text{coarse}}$。我们使用双线性插值。一个粗网格点的值 $e^{\\text{coarse}}_{I,J}$ 被用来确定一个 $2 \\times 2$ 细网格点块中的值。\n- 与粗网格点重合的细网格点的值直接复制：$e^{\\text{fine}}_{2I+1, 2J+1} = e^{\\text{coarse}}_{I,J}$。\n- 沿水平边的细网格点的值是两个粗网格邻居的平均值：$e^{\\text{fine}}_{2I+1, 2J} = \\frac{1}{2}(e^{\\text{coarse}}_{I,J} + e^{\\text{coarse}}_{I,J-1})$。\n- 沿垂直边的细网格点的值是两个粗网格邻居的平均值：$e^{\\text{fine}}_{2I, 2J+1} = \\frac{1}{2}(e^{\\text{coarse}}_{I,J} + e^{\\text{coarse}}_{I-1,J})$。\n- 位于中心位置的细网格点是四个粗网格邻居的平均值：$e^{\\text{fine}}_{2I, 2J} = \\frac{1}{4}(e^{\\text{coarse}}_{I,J} + e^{\\text{coarse}}_{I-1,J} + e^{\\text{coarse}}_{I,J-1} + e^{\\text{coarse}}_{I-1,J-1})$。\n边界条件通过假设粗网格外部的值为零来处理。\n\n**4. V-循环算法**\n\n在网格层级 $k$ 上求解 $A^k u^k = f^k$ 的单个 V-循环被递归地定义如下：\n\n1.  **基本情况：**如果网格是最粗的（在此例中为 $N_k \\le 3$），则直接求解系统 $A^k u^k = f^k$。这包括构建小型的稠密矩阵 $A^k$ 并使用像 LU 分解这样的标准线性求解器。\n2.  **递归步骤（对于较细的网格）：**\n    a. **预光滑：**对 $u^k$ 的当前近似解应用 $\\nu_1 = 3$ 步加权 Jacobi 光滑子。\n    $$\n    u^k \\leftarrow \\text{Smooth}^{\\nu_1}(A^k, f^k, u^k)\n    $$\n    b. **计算残差：**在细网格上计算残差：$r^k = f^k - A^k u^k$。\n    c. **限制：**将残差转移到下一个更粗的层级 $k+1$。\n    $$\n    r^{k+1} = R r^k\n    $$\n    d. **粗网格求解：**在粗网格上求解残差方程 $A^{k+1} e^{k+1} = r^{k+1}$，以得到误差修正量 $e^{k+1}$。这是通过对 V-循环算法进行递归调用来完成的，其中误差的初始猜测为零。\n    $$\n    e^{k+1} = \\text{V-cycle}(A^{k+1}, r^{k+1}, \\text{initial guess } 0)\n    $$\n    e. **延拓：**将计算出的误差修正量插值回细网格。\n    $$\n    e^k = P e^{k+1}\n    $$\n    f. **校正：**更新细网格解。\n    $$\n    u^k \\leftarrow u^k + e^k\n    $$\n    g. **后光滑：**对校正后的解应用 $\\nu_2 = 3$ 步加权 Jacobi 光滑子。\n    $$\n    u^k \\leftarrow \\text{Smooth}^{\\nu_2}(A^k, f^k, u^k)\n    $$\nV-循环过程以零初始猜测 $u=0$ 启动，并进行迭代，直到相对残差 $\\rho = \\lVert f-Au \\rVert_2 / \\lVert f \\rVert_2$ 低于容差 $\\epsilon = 10^{-8}$ 或达到最大循环次数 $K=20$ 为止。最终达到的 $\\rho$ 值将被报告。", "answer": "```python\nimport numpy as np\n\nclass VCycleSolver:\n    \"\"\"\n    A geometric multigrid V-cycle solver for the 2D Poisson equation.\n    \"\"\"\n    def __init__(self, omega=2/3, nu1=3, nu2=3, coarsest_n=3):\n        self.omega = omega\n        self.nu1 = nu1\n        self.nu2 = nu2\n        self.coarsest_n = coarsest_n\n        self._coarsest_matrices = {}\n\n    def _apply_A(self, u, h):\n        \"\"\"Applies the 5-point stencil discrete Laplacian operator.\"\"\"\n        u_padded = np.pad(u, 1, mode='constant', constant_values=0)\n        # 4*u_ij - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\n        laplacian = (4 * u -\n                     (u_padded[1:-1, 2:] + u_padded[1:-1, :-2] +\n                      u_padded[2:, 1:-1] + u_padded[:-2, 1:-1]))\n        return laplacian / (h**2)\n\n    def _weighted_jacobi(self, u, f, h, nu):\n        \"\"\"Performs `nu` steps of weighted Jacobi smoothing.\"\"\"\n        D_inv = h**2 / 4.0\n        for _ in range(nu):\n            r = f - self._apply_A(u, h)\n            u += self.omega * D_inv * r\n        return u\n\n    def _restrict(self, r_fine):\n        \"\"\"Performs full-weighting restriction.\"\"\"\n        # Stencil: 1/16 * [[1, 2, 1], [2, 4, 2], [1, 2, 1]]\n        r_coarse = (\n            4 * r_fine[1::2, 1::2] +\n            2 * (r_fine[1::2, 0:-1:2] + r_fine[1::2, 2::2] +\n                 r_fine[0:-1:2, 1::2] + r_fine[2::2, 1::2]) +\n            1 * (r_fine[0:-1:2, 0:-1:2] + r_fine[0:-1:2, 2::2] +\n                 r_fine[2::2, 0:-1:2] + r_fine[2::2, 2::2])\n        ) / 16.0\n        return r_coarse\n\n    def _prolongate(self, e_coarse):\n        \"\"\"Performs bilinear interpolation for prolongation.\"\"\"\n        Nc = e_coarse.shape[0]\n        Nf = 2 * Nc + 1\n        e_fine = np.zeros((Nf, Nf))\n\n        # Direct injection\n        e_fine[1::2, 1::2] = e_coarse\n\n        # Pad for easier interpolation\n        e_coarse_padded = np.pad(e_coarse, 1, mode='constant', constant_values=0)\n\n        # Interpolate vertical edges (average of horizontal neighbors)\n        e_fine[1::2, 0::2] = 0.5 * (e_coarse_padded[1:-1, :-1] + e_coarse_padded[1:-1, 1:])\n\n        # Interpolate horizontal edges (average of vertical neighbors)\n        e_fine[0::2, 1::2] = 0.5 * (e_coarse_padded[:-1, 1:-1] + e_coarse_padded[1:, 1:-1])\n\n        # Interpolate center points (average of 4 diagonal neighbors)\n        e_fine[0::2, 0::2] = 0.25 * (e_coarse_padded[:-1, :-1] + e_coarse_padded[:-1, 1:] +\n                                     e_coarse_padded[1:, :-1] + e_coarse_padded[1:, 1:])\n        return e_fine\n\n    def _get_coarsest_A(self, N, h):\n        \"\"\"Builds and caches the matrix for the coarsest grid.\"\"\"\n        if N in self._coarsest_matrices:\n            return self._coarsest_matrices[N]\n\n        size = N * N\n        if size == 0:\n            return np.zeros((0, 0))\n            \n        T_n = np.diag(np.full(N, 4.0)) - np.diag(np.ones(N - 1), 1) - np.diag(np.ones(N - 1), -1)\n        A = (np.kron(np.eye(N), T_n) +\n             np.kron(np.diag(np.ones(N - 1), 1), -np.eye(N)) +\n             np.kron(np.diag(np.ones(N - 1), -1), -np.eye(N)))\n        A /= h**2\n        self._coarsest_matrices[N] = A\n        return A\n\n    def _solve_coarsest(self, f, N, h):\n        \"\"\"Directly solves the system on the coarsest grid.\"\"\"\n        if N == 0:\n            return np.zeros((0,0))\n        A = self._get_coarsest_A(N, h)\n        u_vec = np.linalg.solve(A, f.flatten())\n        return u_vec.reshape((N, N))\n\n    def run_v_cycle(self, u, f, N):\n        \"\"\"Executes one recursive V-cycle.\"\"\"\n        h = 1.0 / (N + 1)\n\n        # 1. Base case: solve directly on coarsest grid\n        if N = self.coarsest_n:\n            return self._solve_coarsest(f, N, h)\n\n        # 2. Pre-smoothing\n        u = self._weighted_jacobi(u, f, h, self.nu1)\n\n        # 3. Compute residual\n        r = f - self._apply_A(u, h)\n\n        # 4. Restrict residual\n        r_coarse = self._restrict(r)\n\n        # 5. Solve coarse-grid error equation recursively\n        Nc = (N - 1) // 2\n        e_coarse_initial = np.zeros((Nc, Nc))\n        e_coarse = self.run_v_cycle(e_coarse_initial, r_coarse, Nc)\n\n        # 6. Prolongate error correction\n        e_fine = self._prolongate(e_coarse)\n\n        # 7. Correct fine-grid solution\n        u += e_fine\n\n        # 8. Post-smoothing\n        u = self._weighted_jacobi(u, f, h, self.nu2)\n\n        return u\n\n    def solve_system(self, N, f, tol, max_cycles):\n        \"\"\"Iteratively solves the system using V-cycles.\"\"\"\n        u = np.zeros((N, N))\n        h = 1.0 / (N + 1)\n        \n        norm_f = np.linalg.norm(f.flatten())\n        if norm_f == 0:\n            return 0.0\n\n        r = f - self._apply_A(u, h)\n        rel_res = np.linalg.norm(r.flatten()) / norm_f\n\n        for _ in range(max_cycles):\n            if rel_res = tol:\n                break\n            u = self.run_v_cycle(u, f, N)\n            r = f - self._apply_A(u, h)\n            rel_res = np.linalg.norm(r.flatten()) / norm_f\n        \n        return rel_res\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'N': 63, 'sources': [(31, 31)]},\n        {'N': 63, 'sources': [(1, 1)]},\n        {'N': 31, 'sources': [(7, 7), (23, 23)]},\n        {'N': 31, 'sources': [(0, 0)]},\n    ]\n    epsilon = 1e-8\n    K = 20\n\n    solver = VCycleSolver(omega=2/3, nu1=3, nu2=3)\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        sources = case['sources']\n        \n        h = 1.0 / (N + 1)\n        f = np.zeros((N, N))\n        for i0, j0 in sources:\n            f[i0, j0] = 1.0 / h**2\n        \n        final_rho = solver.solve_system(N, f, epsilon, K)\n        results.append(f\"{final_rho:.6g}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2415837"}, {"introduction": "实现了一个功能完备的多重网格求解器后，下一步自然是分析其性能，尤其是在并行计算环境中的表现。在本练习中，你将使用一个解析性能模型来探索多重网格关键组件（并行平滑器）的可扩展性，研究问题规模 $n_0$、核心数 $p$、内存带宽 $B$ 和通信开销等因素如何影响并行加速比 $S$ 和效率 $E$。这一实践将你的关注点从算法实现转向性能工程，帮助你识别常见的性能瓶颈，并理解为何理论上高效的算法在实践中可能无法完美扩展 [@problem_id:2415818]。", "problem": "考虑在方形网格上使用标准五点有限差分格式离散化的二维泊松方程及狄利克雷边界条件。在多重网格V循环中，每个网格层级上都应用了红黑高斯-赛德尔光滑子。设最细层级的内部网格有 $n_0 \\times n_0$ 个点，并在每个空间方向上以因子 $2$ 进行粗化，使得层级 $\\ell$ 每个维度上有 $n_\\ell = \\max\\left(2, \\left\\lfloor \\frac{n_0}{2^\\ell} \\right\\rfloor \\right)$ 个内部点，总共有 $N_\\ell = n_\\ell^2$ 个内部点。假设在每个V循环中，每个层级上进行总共 $n_{\\mathrm{sweeps}} = \\nu_1 + \\nu_2$ 次扫描的光滑处理。\n\n红黑高斯-赛德尔方法在每次扫描中先更新一半的点（红点集），然后更新另一半的点（黑点集）。假设一次点更新需要 $w_f$ 次浮点运算，并与主存之间传输 $w_m$ 字节的数据。计算在具有 $p$ 个相同核心的多核中央处理器（CPU）上运行，每个核心能够维持 $f_{\\mathrm{core}}$ 的浮点运算速率（单位：浮点运算/秒），共享的持续内存带宽为 $B$（单位：字节/秒）。一次全局屏障同步的延迟为 $\\tau_b$（单位：秒），每个颜色阶段的调度/启动开销延迟为 $\\tau_\\ell$（单位：秒）。文本中不出现角度；不需要特定的角度单位。所有时间参数均以秒为单位。\n\n对于给定的层级 $\\ell$ 和核心数 $p$，定义每种颜色的有效并发度为\n$$\nc_\\ell(p) = \\min\\left(p, \\frac{N_\\ell}{2}\\right).\n$$\n在层级 $\\ell$ 上，一次光滑扫描的计算受限时间为\n$$\nT^{(\\mathrm{comp})}_\\ell(p) = \\frac{N_\\ell \\, w_f}{f_{\\mathrm{core}} \\, c_\\ell(p)}.\n$$\n在层级 $\\ell$ 上，一次光滑扫描的内存受限时间为\n$$\nT^{(\\mathrm{mem})}_\\ell = \\frac{N_\\ell \\, w_m}{B}.\n$$\n在层级 $\\ell$ 上，一次扫描的基础时间为\n$$\nT^{(\\mathrm{base})}_\\ell(p) = \\max\\left( T^{(\\mathrm{comp})}_\\ell(p), \\, T^{(\\mathrm{mem})}_\\ell \\right).\n$$\n每次扫描有两个颜色阶段，因此产生如下开销\n$$\nT^{(\\mathrm{bar})}(p) = \\mathbf{1}_{\\{p1\\}} \\cdot 2 \\, \\tau_b, \\qquad\nT^{(\\mathrm{sched})}(p) = \\mathbf{1}_{\\{p1\\}} \\cdot 2 \\, \\tau_\\ell,\n$$\n其中 $\\mathbf{1}_{\\{p1\\}}$ 在 $p1$ 时为 $1$，否则为 $0$。在层级 $\\ell$ 上，一次扫描的总光滑时间为\n$$\nT_\\ell(p) = T^{(\\mathrm{base})}_\\ell(p) + T^{(\\mathrm{bar})}(p) + T^{(\\mathrm{sched})}(p).\n$$\n设一个V循环中的总光滑子时间为\n$$\nT_{\\mathrm{total}}(p) = \\sum_{\\ell} n_{\\mathrm{sweeps}} \\, T_\\ell(p).\n$$\n定义并行加速比和效率为\n$$\nS = \\frac{T_{\\mathrm{total}}(1)}{T_{\\mathrm{total}}(p)}, \\qquad E = \\frac{S}{p}.\n$$\n为识别开销来源，报告以下相对于 $T_{\\mathrm{total}}(p)$ 的分数：\n- 屏障分数：\n$$\nF_{\\mathrm{bar}} = \\frac{\\sum_{\\ell} n_{\\mathrm{sweeps}} \\, T^{(\\mathrm{bar})}(p)}{T_{\\mathrm{total}}(p)}.\n$$\n- 调度分数：\n$$\nF_{\\mathrm{sched}} = \\frac{\\sum_{\\ell} n_{\\mathrm{sweeps}} \\, T^{(\\mathrm{sched})}(p)}{T_{\\mathrm{total}}(p)}.\n$$\n- 并行度限制分数（在计算受限情况下由于并发度不足 $c_\\ell(p)  p$ 造成的损失）：\n对于每个层级 $\\ell$，定义在可以使用完全并发度 $p$ 时的理想计算受限扫描时间为\n$$\nT^{(\\mathrm{comp,ideal})}_\\ell(p) = \\frac{N_\\ell \\, w_f}{f_{\\mathrm{core}} \\, p}.\n$$\n那么每层级的损失为\n$$\nL_\\ell(p) = \n\\begin{cases}\nT^{(\\mathrm{comp})}_\\ell(p) - T^{(\\mathrm{comp,ideal})}_\\ell(p),  \\text{若 } T^{(\\mathrm{comp})}_\\ell(p) \\ge T^{(\\mathrm{mem})}_\\ell, \\\\\n0,  \\text{其他情况}.\n\\end{cases}\n$$\n总分数为\n$$\nF_{\\mathrm{plim}} = \\frac{\\sum_{\\ell} n_{\\mathrm{sweeps}} \\, L_\\ell(p)}{T_{\\mathrm{total}}(p)}.\n$$\n\n你的任务是编写一个完整的、可运行的程序，对于下面指定的测试套件，计算每个测试用例的列表 $[S, E, F_{\\mathrm{bar}}, F_{\\mathrm{sched}}, F_{\\mathrm{plim}}]$，并打印单行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的列表，该列表本身由多个列表组成，并包含在一对方括号内，例如 $[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5]]$。所有报告值必须是浮点数，并四舍五入到小数点后恰好 $6$ 位。不应打印任何其他文本。\n\n除非明确覆盖，否则对所有测试用例使用以下参数值：\n- 每次更新的成本：$w_f = 10$ 次浮点运算， $w_m = 48$ 字节。\n- 光滑子扫描次数：$\\nu_1 = 2$，$\\nu_2 = 1$，因此 $n_{\\mathrm{sweeps}} = 3$。\n- 机器参数：$f_{\\mathrm{core}} = 2 \\times 10^{9}$ 次浮点运算/秒， $B = 4 \\times 10^{10}$ 字节/秒，$\\tau_b = 2 \\times 10^{-6}$ 秒，$\\tau_\\ell = 5 \\times 10^{-6}$ 秒。\n\n测试套件（每个用例由 $(n_0, p)$ 指定）：\n- 用例 1：$(n_0, p) = (512, 1)$。\n- 用例 2：$(n_0, p) = (512, 4)$。\n- 用例 3：$(n_0, p) = (512, 16)$。\n- 用例 4：$(n_0, p) = (128, 16)$。\n- 用例 5：$(n_0, p) = (32, 64)$。\n\n你的程序应生成单行输出，其中包含结果，格式为包含在方括号内的逗号分隔列表，按上述测试用例的顺序排列，其中每个元素本身是五个浮点值 $[S, E, F_{\\mathrm{bar}}, F_{\\mathrm{sched}}, F_{\\mathrm{plim}}]$ 的列表，并四舍五入到小数点后 $6$ 位。", "solution": "问题陈述已经过严格验证，并被确定为有效。它基于一个清晰、明确且科学上合理的多重网格光滑子（一种计算物理学中的标准算法）性能模型，提出了一个适定的计算任务。所有必要的参数和定义均已提供，不存在矛盾或歧义。因此，我们可以着手解决问题。\n\n目标是使用给定的分析性能模型，为多重网格V循环光滑子计算一组并行性能指标。这些指标包括并行加速比 ($S$)、效率 ($E$)，以及归因于屏障同步 ($F_{\\mathrm{bar}}$)、调度开销 ($F_{\\mathrm{sched}}$) 和并行度不足 ($F_{\\mathrm{plim}}$) 的总时间分数。此计算将针对几个测试用例进行，每个测试用例由最细网格尺寸 $n_0$ 和处理器核心数 $p$ 定义。\n\n计算过程通过直接实现所提供的公式来构建。单个测试用例 $(n_0, p)$ 的计算总体结构如下：\n\n首先，我们必须确定网格层级结构。V循环在一系列网格上操作，从最细的层级 $\\ell=0$ 开始，该层级有 $n_0 \\times n_0$ 个内部点。每个后续层级 $\\ell+1$ 是通过将层级 $\\ell$ 上的网格以因子2进行粗化得到的。层级 $\\ell$ 上每个维度的内部点数由 $n_\\ell = \\max\\left(2, \\left\\lfloor \\frac{n_0}{2^\\ell} \\right\\rfloor \\right)$ 给出。V循环一直进行到网格尺寸不再减小为止，这发生在 $n_\\ell=2$ 时。我们生成网格尺寸序列 $\\{n_\\ell\\}$（$\\ell = 0, 1, 2, \\dots$），直到满足此条件。\n\n第二，对于层级结构中的每个层级 $\\ell$ 和给定的核心数 $p$，我们计算一次光滑扫描的总时间 $T_\\ell(p)$。这涉及几个步骤：\n1.  计算内部点总数：$N_\\ell = n_\\ell^2$。\n2.  确定每种颜色的有效并发度：$c_\\ell(p) = \\min\\left(p, \\frac{N_\\ell}{2}\\right)$。这反映了红黑光滑子在其两个阶段中每个阶段并行处理 $\\frac{N_\\ell}{2}$ 个点。\n3.  计算一次扫描的计算受限时间：$T^{(\\mathrm{comp})}_\\ell(p) = \\frac{N_\\ell \\, w_f}{f_{\\mathrm{core}} \\, c_\\ell(p)}$。此模型假设性能受限于可用核心的浮点能力。\n4.  计算一次扫描的内存受限时间：$T^{(\\mathrm{mem})}_\\ell = \\frac{N_\\ell \\, w_m}{B}$。此模型假设性能受限于内存带宽。\n5.  一次扫描的基础时间是这两者中的最大值：$T^{(\\mathrm{base})}_\\ell(p) = \\max\\left( T^{(\\mathrm{comp})}_\\ell(p), \\, T^{(\\mathrm{mem})}_\\ell \\right)$。这是一个标准的屋顶线模型假设。\n6.  计算一次扫描的并行开销。由于每次扫描包含两个阶段（红和黑），每个阶段都可能发生一次屏障和调度事件。总开销为 $T^{(\\mathrm{bar})}(p) = \\mathbf{1}_{\\{p1\\}} \\cdot 2 \\, \\tau_b$ 和 $T^{(\\mathrm{sched})}(p) = \\mathbf{1}_{\\{p1\\}} \\cdot 2 \\, \\tau_\\ell$，其中 $\\mathbf{1}_{\\{p1\\}}$ 是指示函数，在 $p1$ 时为 $1$，在 $p=1$ 时为 $0$。\n7.  层级 $\\ell$ 上一次扫描的总时间是基础时间与开销之和：$T_\\ell(p) = T^{(\\mathrm{base})}_\\ell(p) + T^{(\\mathrm{bar})}(p) + T^{(\\mathrm{sched})}(p)$。\n\n第三，我们计算一个完整V循环的总光滑子时间 $T_{\\mathrm{total}}(p)$。这是所有层级扫描时间之和，再乘以每层的扫描次数 $n_{\\mathrm{sweeps}}$：\n$$\nT_{\\mathrm{total}}(p) = n_{\\mathrm{sweeps}} \\sum_{\\ell} T_\\ell(p)\n$$\n\n第四，我们计算由于并行度不足而损失的总时间。对于每个层级 $\\ell$，此损失 $L_\\ell(p)$ 仅在扫描是计算受限 ($T^{(\\mathrm{comp})}_\\ell(p) \\ge T^{(\\mathrm{mem})}_\\ell$) 且独立任务数少于核心数 ($c_\\ell(p)  p$) 时发生。损失是实际计算时间与假设所有 $p$ 个核心都可被使用时的理想时间之差：\n$$\nL_\\ell(p) = \n\\begin{cases}\nT^{(\\mathrm{comp})}_\\ell(p) - \\frac{N_\\ell \\, w_f}{f_{\\mathrm{core}} \\, p},  \\text{若 } T^{(\\mathrm{comp})}_\\ell(p) \\ge T^{(\\mathrm{mem})}_\\ell, \\\\\n0,  \\text{其他情况}.\n\\end{cases}\n$$\nV循环中总的并行度限制损失为 $L_{\\mathrm{total}}(p) = n_{\\mathrm{sweeps}} \\sum_{\\ell} L_\\ell(p)$。\n\n最后，我们计算所需的性能指标。\n1.  为求得加速比 $S$，我们需要串行执行时间 $T_{\\mathrm{total}}(1)$。这通过对 $p=1$ 应用上述整个过程来计算。然后，加速比为 $S = \\frac{T_{\\mathrm{total}}(1)}{T_{\\mathrm{total}}(p)}$。\n2.  效率为 $E = \\frac{S}{p}$。\n3.  开销分数通过将各开销分量在所有层级上求和，乘以 $n_{\\mathrm{sweeps}}$，然后用总时间 $T_{\\mathrm{total}}(p)$ 进行归一化来计算：\n    $F_{\\mathrm{bar}} = \\frac{n_{\\mathrm{sweeps}} \\sum_{\\ell} T^{(\\mathrm{bar})}(p)}{T_{\\mathrm{total}}(p)}$\n    $F_{\\mathrm{sched}} = \\frac{n_{\\mathrm{sweeps}} \\sum_{\\ell} T^{(\\mathrm{sched})}(p)}{T_{\\mathrm{total}}(p)}$\n    $F_{\\mathrm{plim}} = \\frac{L_{\\mathrm{total}}(p)}{T_{\\mathrm{total}}(p)}$\n\n对于 $p=1$ 的特殊情况，开销 $T^{(\\mathrm{bar})}(1)$、$T^{(\\mathrm{sched})}(1)$ 和 $L_\\ell(1)$ 均为零。因此，$S=1$，$E=1$，且所有开销分数均为 0。\n\n此完整过程将被实现并应用于问题陈述中指定的每个测试用例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes parallel performance metrics for a multigrid V-cycle smoother\n    based on a provided analytical performance model.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    W_F = 10.0  # FLOPs per point update\n    W_M = 48.0  # Bytes per point update\n    N_SWEEPS = 3.0  # n_sweeps = nu_1 + nu_2 = 2 + 1\n    F_CORE = 2.0e9  # FLOPS per core per second\n    B = 4.0e10  # Bytes per second (memory bandwidth)\n    TAU_B = 2.0e-6  # seconds (barrier latency)\n    TAU_L = 5.0e-6  # seconds (scheduling latency)\n\n    # --- Test Suite ---\n    test_cases = [\n        (512, 1),\n        (512, 4),\n        (512, 16),\n        (128, 16),\n        (32, 64),\n    ]\n\n    def calculate_performance_components(n0, p):\n        \"\"\"\n        Calculates total time and overhead components for a given n0 and p.\n        \"\"\"\n        # Generate grid hierarchy\n        n_levels = []\n        n_current = n0\n        if n_current > 0:\n            n_levels.append(n_current)\n        while n_current > 2:\n            n_next = max(2, n_current // 2)\n            if n_next  n_current:\n                n_levels.append(n_next)\n                n_current = n_next\n            else:\n                break\n        \n        num_levels = len(n_levels)\n        total_time = 0.0\n        total_loss_plim = 0.0\n        \n        # Overheads are independent of level, calculated once\n        t_bar_p = 2.0 * TAU_B if p > 1 else 0.0\n        t_sched_p = 2.0 * TAU_L if p > 1 else 0.0\n\n        for n_l in n_levels:\n            N_l = float(n_l**2)\n            \n            # Concurrency\n            c_l_p = min(p, N_l / 2.0)\n            \n            # Compute-limited time\n            # Handle c_l_p = 0 case for very small grids (Nl=1, not possible here as min n_l is 2)\n            t_comp_l_p = (N_l * W_F) / (F_CORE * c_l_p) if c_l_p > 0 else float('inf')\n            \n            # Memory-limited time\n            t_mem_l = (N_l * W_M) / B\n            \n            # Base sweep time\n            t_base_l_p = max(t_comp_l_p, t_mem_l)\n            \n            # Total sweep time per level\n            t_l_p = t_base_l_p + t_bar_p + t_sched_p\n            total_time += t_l_p\n            \n            # Parallelism-limit loss\n            if t_comp_l_p >= t_mem_l:\n                t_comp_ideal_l_p = (N_l * W_F) / (F_CORE * p) if p > 0 else float('inf')\n                loss_l_p = t_comp_l_p - t_comp_ideal_l_p\n                total_loss_plim += loss_l_p\n\n        total_time *= N_SWEEPS\n        total_loss_plim *= N_SWEEPS\n        \n        total_barrier_time = N_SWEEPS * num_levels * t_bar_p\n        total_sched_time = N_SWEEPS * num_levels * t_sched_p\n\n        return total_time, total_barrier_time, total_sched_time, total_loss_plim\n\n    results = []\n    for n0, p in test_cases:\n        if p == 1:\n            # For p=1, S=1, E=1, and all overhead fractions are 0 by definition\n            results.append([1.0, 1.0, 0.0, 0.0, 0.0])\n            continue\n            \n        # Calculate for p=1 (serial baseline)\n        T_total_1, _, _, _ = calculate_performance_components(n0, 1)\n\n        # Calculate for given p\n        T_total_p, T_bar_total, T_sched_total, L_plim_total = calculate_performance_components(n0, p)\n        \n        if T_total_p == 0: # Avoid division by zero\n            S = 0.0\n            E = 0.0\n            F_bar = 0.0\n            F_sched = 0.0\n            F_plim = 0.0\n        else:\n            S = T_total_1 / T_total_p\n            E = S / p\n            F_bar = T_bar_total / T_total_p\n            F_sched = T_sched_total / T_total_p\n            F_plim = L_plim_total / T_total_p\n            \n        results.append([S, E, F_bar, F_sched, F_plim])\n\n    # Format output as specified\n    formatted_results = []\n    for res_list in results:\n        formatted_numbers = [f\"{v:.6f}\" for v in res_list]\n        formatted_results.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2415818"}]}