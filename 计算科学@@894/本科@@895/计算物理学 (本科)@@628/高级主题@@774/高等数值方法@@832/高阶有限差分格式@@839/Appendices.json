{"hands_on_practices": [{"introduction": "理论是基础，但真正的理解来自于实践。本练习将指导你完整地经历一个高阶紧致差分格式的生命周期：从推导系数，到编写代码实现，再到通过数值实验验证其精度和分析其谱属性。这个全面的练习是掌握高阶格式基础的基石，它将理论与实际计算紧密地联系起来。[@problem_id:2401303]", "problem": "请实现一个紧致有限差分法，用于在周期性均匀网格上逼近一阶导数，并仅使用可从 Taylor 级数和 Fourier 分析推导出的原理来分析其谱特性。\n\n您必须基于以下基本原理进行推导：\n- 一个足够光滑的函数 $f$ 在点 $x$ 处的一阶导数定义为 $f^{\\prime}(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}$。\n- 一个光滑函数在点 $x$ 处的 Taylor 级数展开为 $f(x \\pm h) = f(x) \\pm h f^{\\prime}(x) + \\frac{h^{2}}{2} f^{\\prime\\prime}(x) \\pm \\frac{h^{3}}{6} f^{(3)}(x) + \\frac{h^{4}}{24} f^{(4)}(x) \\pm \\frac{h^{5}}{120} f^{(5)}(x) + \\cdots$。\n- 在间距为 $h$ 的周期性均匀网格 $x_{j} = x_{0} + j h$ 上，一个离散 Fourier 模为 $e^{i k x_{j}}$，其中 $i$ 是虚数单位，$k$ 是波数。无量纲波数为 $\\theta = k h$，单位是弧度。\n\n任务 A (推导紧致格式的系数):\n- 假设一个用于一阶导数的隐式、三点、对称紧致 Padé 格式，其形式为 $\\alpha f^{\\prime}_{i-1} + f^{\\prime}_{i} + \\alpha f^{\\prime}_{i+1} = \\frac{\\beta}{h} \\left(f_{i+1} - f_{i-1}\\right)$，其中 $\\alpha$ 和 $\\beta$ 是与 $h$ 和索引 $i$ 无关的常数。\n- 使用关于点 $x_{i}$ 的 Taylor 级数相容性，确定 $\\alpha$ 和 $\\beta$，使得截断误差为 $h^4$ 阶，即格式达到四阶精度。\n\n任务 B (在周期性网格上实现):\n- 在带有周期性边界条件的定义域 $[0,1)$ 上，使用任务 A 中推导出的系数 $(\\alpha,\\beta)$，构建由紧致格式所蕴含的线性系统，以便从 $N$ 个点组成的均匀网格上的函数采样值向量 $\\boldsymbol{f}$ 计算离散导数向量 $\\boldsymbol{d}$。\n- 由于周期性，作用于 $\\boldsymbol{d}$ 的矩阵是三对角的，并带有回卷（循环）项。\n\n任务 C (观测精度阶测试):\n- 使用函数 $f(x) = \\sin(2 \\pi x)$ 及其精确导数 $f^{\\prime}(x) = 2 \\pi \\cos(2 \\pi x)$，在定义域 $[0,1)$ 上，针对 $N \\in \\{32, 64, 128\\}$，计算离散导数与精确导数之间的最大范数误差 $E_{\\infty}(N)$。\n- 计算观测精度阶 $p_{32 \\to 64} = \\log_{2}\\left( \\frac{E_{\\infty}(32)}{E_{\\infty}(64)} \\right)$ 和 $p_{64 \\to 128} = \\log_{2}\\left( \\frac{E_{\\infty}(64)}{E_{\\infty}(128)} \\right)$。\n\n任务 D (谱色散和耗散分析):\n- 对于一个周期性、线性、位移不变的离散导数算子，一个 Fourier 模 $e^{i k x}$ 是其特征函数：应用该算子会得到 $i \\tilde{k} e^{i k x}$，其中 $\\tilde{k}$ 为某个修正波数。将无量纲修正波数定义为 $\\tilde{\\theta} = \\tilde{k} h$。\n- 使用对紧致格式的 Fourier 分析，将 $\\tilde{\\theta}$ 表示为 $\\theta$ 和 $(\\alpha,\\beta)$ 的函数。然后，对于测试角度 $\\theta \\in \\{0.1, 0.5, 1.0, 1.5, 2.5\\}$ (单位均为弧度)，计算绝对色散误差 $|\\tilde{\\theta} - \\theta|$，并按给定顺序列出。\n- 通过在 $[0,\\pi]$ (包含端点) 范围内均匀采样一组密集的角度 $\\theta$ (单位为弧度)，并计算样本上 $\\tilde{\\theta}$ 虚部的最大绝对值，来评估数值耗散。将此最大值报告为单个浮点数。\n\n测试套件与要求的最终输出：\n- 您的程序必须按顺序运行以下测试套件并汇总结果：\n  1. 计算任务 C 中的 $p_{32 \\to 64}$。\n  2. 计算任务 C 中的 $p_{64 \\to 128}$。\n  3. 计算任务 D 中针对 $\\theta \\in \\{0.1, 0.5, 1.0, 1.5, 2.5\\}$ (弧度)的绝对色散误差列表。\n  4. 计算任务 D 中的最大耗散度量，定义为在 $[0,\\pi]$ 上包含 1001 个点的均匀网格的 $\\theta$ 值上， $\\tilde{\\theta}$ 虚部的最大绝对值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，第三个条目本身也是一个列表，即，采用以下确切格式：\"[p32_64,p64_128,[e_theta0.1,e_theta0.5,e_theta1.0,e_theta1.5,e_theta2.5],max_dissipation]\"。\n- 所有角度均以弧度为单位。本问题不涉及物理单位。\n\n您的实现必须是完全自包含的，使用周期性边界条件，并且不得依赖任何外部数据或用户输入。数值线性代数必须仅使用允许的库来执行，并且您的输出值必须是浮点数。请通过 Taylor 相容性推导系数 $(\\alpha,\\beta)$，并通过对已实现的格式进行 Fourier 分析来计算修正波数，而不是导入任何预制表格中的公式，以确保科学真实性。", "solution": "所提出的问题是计算物理学中一个标准的、良构的练习，涉及高阶有限差分格式的推导、实现和分析。所有提供的信息都是自包含的、有科学依据且客观的。各项任务逻辑结构清晰，并导向一个唯一、可验证的解。因此，该问题被认为是有效的，并将提供完整的解答。\n\n目标是为周期性均匀网格上的一阶导数构建并分析一个四阶紧致有限差分格式。分析将按规定分为四个部分进行：系数推导、实现细节、精度的数值验证，以及色散和耗散特性的谱分析。\n\n**部分 A：紧致格式系数的推导**\n\n给定一个用于一阶导数 $f'_{i} \\approx d_{i}$ 的对称三点紧致格式：\n$$\n\\alpha d_{i-1} + d_{i} + \\alpha d_{i+1} = \\frac{\\beta}{h} \\left(f_{i+1} - f_{i-1}\\right)\n$$\n其中 $f_i = f(x_i)$，$d_i = f'(x_i)$，$h$ 是均匀网格间距。为了找到能得到四阶精度格式的系数 $\\alpha$ 和 $\\beta$，我们使用在点 $x_i$ 附近的 Taylor 级数展开来强制相容性。\n格式中的各项展开如下：\n$$\nf_{i\\pm1} = f(x_i \\pm h) = f_i \\pm h f'_i + \\frac{h^2}{2} f''_i \\pm \\frac{h^3}{6} f^{(3)}_i + \\frac{h^4}{24} f^{(4)}_i \\pm \\frac{h^5}{120} f^{(5)}_i + O(h^6)\n$$\n$$\nd_{i\\pm1} = f'(x_i \\pm h) = f'_i \\pm h f''_i + \\frac{h^2}{2} f^{(3)}_i \\pm \\frac{h^3}{6} f^{(4)}_i + \\frac{h^4}{24} f^{(5)}_i + O(h^5)\n$$\n将这些展开式代入格式方程，我们分别分析左侧（LHS）和右侧（RHS）。\n\nLHS:\n\\begin{align*}\n\\alpha d_{i-1} + d_{i} + \\alpha d_{i+1} &= \\alpha \\left(f'_i - h f''_i + \\frac{h^2}{2} f^{(3)}_i - \\frac{h^3}{6} f^{(4)}_i + \\frac{h^4}{24} f^{(5)}_i\\right) + f'_i \\\\\n&\\quad+ \\alpha \\left(f'_i + h f''_i + \\frac{h^2}{2} f^{(3)}_i + \\frac{h^3}{6} f^{(4)}_i + \\frac{h^4}{24} f^{(5)}_i\\right) + O(h^5) \\\\\n&= (1+2\\alpha)f'_i + \\alpha h^2 f^{(3)}_i + \\frac{\\alpha h^4}{12} f^{(5)}_i + O(h^6)\n\\end{align*}\n\nRHS:\n\\begin{align*}\n\\frac{\\beta}{h} (f_{i+1} - f_{i-1}) &= \\frac{\\beta}{h} \\left( (f_i + h f'_i + \\frac{h^2}{2}f''_i + \\frac{h^3}{6}f^{(3)}_i + \\frac{h^4}{24}f^{(4)}_i + \\frac{h^5}{120}f^{(5)}_i) \\right. \\\\\n&\\quad \\left. - (f_i - h f'_i + \\frac{h^2}{2}f''_i - \\frac{h^3}{6}f^{(3)}_i + \\frac{h^4}{24}f^{(4)}_i - \\frac{h^5}{120}f^{(5)}_i) \\right) + O(h^5) \\\\\n&= \\frac{\\beta}{h} \\left( 2h f'_i + \\frac{2h^3}{6}f^{(3)}_i + \\frac{2h^5}{120}f^{(5)}_i \\right) + O(h^5) \\\\\n&= 2\\beta f'_i + \\frac{\\beta h^2}{3} f^{(3)}_i + \\frac{\\beta h^4}{60} f^{(5)}_i + O(h^5)\n\\end{align*}\n\n为达到可能的最高精度阶，我们令 LHS 和 RHS 上对应导数项的系数相等。\n\\begin{itemize}\n    \\item $f'_i$ 的系数： $1+2\\alpha = 2\\beta$\n    \\item $f^{(3)}_i$ 的系数： $\\alpha = \\frac{\\beta}{3}$\n\\end{itemize}\n这构成了关于 $\\alpha$ 和 $\\beta$ 的一个二元线性方程组。将第二个方程代入第一个方程得到：\n$$\n1 + 2\\alpha = 2(3\\alpha) = 6\\alpha \\implies 1 = 4\\alpha \\implies \\alpha = \\frac{1}{4}\n$$\n由此，我们求得 $\\beta$：\n$$\n\\beta = 3\\alpha = 3 \\left(\\frac{1}{4}\\right) = \\frac{3}{4}\n$$\n该格式由 $\\alpha = 1/4$ 和 $\\beta = 3/4$ 定义。\n\n截断误差 $\\tau$ 的主项是第一个未被抵消的项，它涉及 $f^{(5)}_i$：\n$$\n\\tau = \\left( \\frac{\\beta h^4}{60} - \\frac{\\alpha h^4}{12} \\right) f^{(5)}_i = h^4 \\left( \\frac{3/4}{60} - \\frac{1/4}{12} \\right) f^{(5)}_i = h^4 \\left( \\frac{3}{240} - \\frac{5}{240} \\right) f^{(5)}_i = -\\frac{2h^4}{240} f^{(5)}_i = -\\frac{h^4}{120} f^{(5)}_i\n$$\n局部截断误差为 $O(h^4)$，因此该格式是四阶精度的。\n\n**部分 B：在周期性网格上的实现**\n\n对于定义域 $[0,1)$ 上一个具有 $N$ 个点 $x_j = j h$（其中 $j=0, \\dots, N-1$，$h=1/N$）的网格，该紧致格式为离散导数向量 $\\boldsymbol{d} = [d_0, d_1, \\dots, d_{N-1}]^T$ 定义了一个线性系统。在每个网格点 $j$ 处的方程为：\n$$\n\\frac{1}{4}d_{j-1} + d_j + \\frac{1}{4}d_{j+1} = \\frac{3}{4h}(f_{j+1} - f_{j-1})\n$$\n由于周期性边界条件，索引按模 $N$ 计算。该系统可以写成矩阵形式 $A \\boldsymbol{d} = \\boldsymbol{b}$，其中：\n\\begin{itemize}\n    \\item $A$ 是一个 $N \\times N$ 的循环矩阵，由其第一行 $[\\text{1}, \\alpha, 0, \\dots, 0, \\alpha]$ 定义：\n    $$\n    A = \\begin{pmatrix}\n    1 & \\alpha & 0 & \\cdots & 0 & \\alpha \\\\\n    \\alpha & 1 & \\alpha & \\cdots & 0 & 0 \\\\\n    0 & \\alpha & 1 & \\cdots & 0 & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & 1 & \\alpha \\\\\n    \\alpha & 0 & 0 & \\cdots & \\alpha & 1\n    \\end{pmatrix}\n    $$\n    \\item $\\boldsymbol{b}$ 是右侧向量，其元素为 $b_j = \\frac{\\beta}{h}(f_{j+1} - f_{j-1})$。\n\\end{itemize}\n这个循环线性系统可以被高效求解，从而得到数值导数 $\\boldsymbol{d}$。\n\n**部分 C：精度的数值验证**\n\n为验证理论上的四阶精度，我们在定义域 $[0,1)$ 上计算函数 $f(x) = \\sin(2\\pi x)$ 的数值导数，其精确导数为 $f'(x) = 2\\pi\\cos(2\\pi x)$。我们使用网格规模 $N \\in \\{32, 64, 128\\}$。误差使用最大范数度量：\n$$\nE_{\\infty}(N) = \\max_{j=0,\\dots,N-1} |d_j - f'(x_j)|\n$$\n在两个网格分辨率 $N_1$ 和 $N_2=2N_1$ 之间，观测精度阶 $p$ 计算如下：\n$$\np = \\log_2 \\left( \\frac{E_{\\infty}(N_1)}{E_{\\infty}(N_2)} \\right)\n$$\n对于一个四阶格式，我们期望 $p \\approx 4$。\n\n**部分 D：谱分析**\n\n离散算子的谱特性通过将其应用于单个 Fourier 模 $f_j = e^{ikx_j} = e^{i\\theta j}$ 来分析，其中 $\\theta=kh$ 是无量纲波数。数值微分算子 $\\mathcal{D}$ 对此模的变换为 $\\mathcal{D}(e^{i\\theta j}) = i\\tilde{k} e^{i\\theta j} = \\frac{i\\tilde{\\theta}}{h} e^{i\\theta j}$，其中 $\\tilde{\\theta} = \\tilde{k}h$ 是修正波数。精确导数给出 $ik e^{ikx_j} = \\frac{i\\theta}{h}e^{i\\theta j}$。\n\n将 $f_j = e^{i\\theta j}$ 和 $d_j = \\frac{i\\tilde{\\theta}}{h} e^{i\\theta j}$ 代入格式方程：\n$$\n\\alpha \\frac{i\\tilde{\\theta}}{h} e^{i\\theta(j-1)} + \\frac{i\\tilde{\\theta}}{h} e^{i\\theta j} + \\alpha \\frac{i\\tilde{\\theta}}{h} e^{i\\theta(j+1)} = \\frac{\\beta}{h} \\left( e^{i\\theta(j+1)} - e^{i\\theta(j-1)} \\right)\n$$\n除以 $\\frac{i}{h}e^{i\\theta j}$ 得到：\n$$\n\\tilde{\\theta}(\\alpha e^{-i\\theta} + 1 + \\alpha e^{i\\theta}) = \\frac{\\beta}{i} (e^{i\\theta} - e^{-i\\theta})\n$$\n使用 Euler 恒等式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos\\theta$ 和 $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$：\n$$\n\\tilde{\\theta}(1 + 2\\alpha\\cos\\theta) = \\frac{\\beta}{i}(2i\\sin\\theta) = 2\\beta\\sin\\theta\n$$\n求解修正波数 $\\tilde{\\theta}$：\n$$\n\\tilde{\\theta}(\\theta) = \\frac{2\\beta \\sin\\theta}{1 + 2\\alpha \\cos\\theta}\n$$\n代入 $\\alpha = 1/4$ 和 $\\beta = 3/4$：\n$$\n\\tilde{\\theta}(\\theta) = \\frac{2(3/4) \\sin\\theta}{1 + 2(1/4) \\cos\\theta} = \\frac{3/2 \\sin\\theta}{1 + 1/2 \\cos\\theta} = \\frac{3 \\sin\\theta}{2 + \\cos\\theta}\n$$\n\n数值色散误差是修正波数与精确波数之差，即 $|\\tilde{\\theta} - \\theta|$。我们为指定的 $\\theta$ 值计算此误差。\n\n数值耗散与修正波数的虚部 $\\text{Im}(\\tilde{\\theta})$ 有关。对于一个作用在实数 $\\theta$ 上的、具有实系数的对称格式，其产生的 $\\tilde{\\theta}$ 是纯实数。这一点从其解析形式中可以明显看出。因此，对于所有 $\\theta \\in [0, \\pi]$，$\\text{Im}(\\tilde{\\theta}) = 0$。这表明该格式是无耗散的，即它不会人为地衰减波的振幅。在给定范围内计算虚部最大绝对值将通过得到 0.0 的值来证实这一点。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_circulant\n\ndef solve():\n    \"\"\"\n    Derives, implements, and analyzes a fourth-order compact finite difference scheme.\n    \"\"\"\n    # Task A: Coefficients derived from Taylor series analysis.\n    # alpha * f'_{i-1} + f'_{i} + alpha * f'_{i+1} = (beta/h) * (f_{i+1} - f_{i-1})\n    # For fourth-order accuracy, alpha = 1/4 and beta = 3/4.\n    alpha = 1.0 / 4.0\n    beta = 3.0 / 4.0\n\n    # Task C: Observed order of accuracy test\n    grid_sizes = [32, 64, 128]\n    errors = {}\n\n    for N in grid_sizes:\n        # Construct grid on [0, 1)\n        h = 1.0 / N\n        x = np.arange(N) * h\n\n        # Test function and its exact derivative\n        f_vals = np.sin(2 * np.pi * x)\n        d_exact = 2 * np.pi * np.cos(2 * np.pi * x)\n\n        # Task B: Construct and solve the linear system\n        # A * d = b, where A is a circulant matrix\n        \n        # Construct the right-hand side vector b\n        # b_j = (beta/h) * (f_{j+1} - f_{j-1})\n        f_plus_1 = np.roll(f_vals, -1)\n        f_minus_1 = np.roll(f_vals, 1)\n        b = (beta / h) * (f_plus_1 - f_minus_1)\n\n        # The matrix A is circulant. Its first column defines it completely.\n        # First column of A is [1, alpha, 0, ..., 0, alpha]\n        A_col = np.zeros(N)\n        A_col[0] = 1.0\n        A_col[1] = alpha\n        A_col[-1] = alpha\n        \n        # Solve the circulant system A * d = b for the numerical derivative d\n        d_numerical = solve_circulant(A_col, b)\n\n        # Compute the maximum-norm error\n        errors[N] = np.max(np.abs(d_numerical - d_exact))\n\n    # Compute observed orders of accuracy\n    p32_64 = np.log2(errors[32] / errors[64])\n    p64_128 = np.log2(errors[64] / errors[128])\n\n    # Task D: Spectral dispersion and dissipation analysis\n    # Modified wavenumber function derived analytically\n    def modified_wavenumber(theta):\n        # With alpha=1/4 and beta=3/4, tilde_theta = (3*sin(theta)) / (2 + cos(theta))\n        return (3.0 * np.sin(theta)) / (2.0 + np.cos(theta))\n\n    # Compute dispersion errors\n    thetas_test = np.array([0.1, 0.5, 1.0, 1.5, 2.5])\n    mod_thetas_test = modified_wavenumber(thetas_test)\n    dispersion_errors = np.abs(mod_thetas_test - thetas_test).tolist()\n\n    # Compute maximum dissipation\n    # The scheme is non-dissipative, so Im(tilde_theta) is analytically zero.\n    # The calculation is performed as requested by the problem statement.\n    thetas_dissipation = np.linspace(0, np.pi, 1001)\n    mod_thetas_dissipation = modified_wavenumber(thetas_dissipation)\n    # The imaginary part is zero due to the analytical form (real inputs, real outputs).\n    # np.imag is used for formal correctness.\n    max_dissipation = np.max(np.abs(np.imag(mod_thetas_dissipation)))\n\n    # Final assembly of results in the required format\n    # The third item is a list, which needs to be stringified without spaces.\n    disp_err_str = str(dispersion_errors).replace(\" \", \"\")\n    \n    # The f-string will use the string representation of each element.\n    # The final list of results printed will have the required format.\n    final_results = [p32_64, p64_128, disp_err_str, max_dissipation]\n    \n    print(f\"[{final_results[0]},{final_results[1]},{final_results[2]},{final_results[3]}]\")\n\nsolve()\n```", "id": "2401303"}, {"introduction": "在一维问题中获得了坚实的基础后，自然要探索这些概念如何推广到更高维度。这个练习将我们带入二维世界，并引入一个多维问题独有的挑战：数值各向异性，即模拟的精度会随波传播方向的改变而变化。通过这个实践，你将学会如何推导和量化这种效应，这对于评估和选择用于二维或三维模拟的数值格式至关重要。[@problem_id:2401296]", "problem": "您的任务是分析在均匀二维笛卡尔网格上半离散标量波动方程的数值色散关系所蕴含的相速度的方向依赖性。考虑以下半离散模型\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\left(D_{xx} + D_{yy}\\right) u,\n$$\n其中 $u = u(x,y,t)$，$c > 0$ 是一个恒定的波速，$D_{xx}$ 和 $D_{yy}$ 分别是沿 $x$ 轴和 $y$ 轴的离散二阶导数算子，它们由定义在两个方向上网格间距均为 $h > 0$ 的均匀网格上的中心、对称、高阶有限差分格式确定。一维二阶导数格式由系数 $\\{c_m\\}$ 指定如下，其中 $m$ 为以 $h$ 的整数倍表示的网格偏移量的索引：\n\n- 2 阶格式（三点）：\n$$\nc_0 = -2,\\quad c_{\\pm 1} = 1.\n$$\n\n- 4 阶格式（五点）：\n$$\nc_0 = -\\frac{5}{2},\\quad c_{\\pm 1} = \\frac{4}{3},\\quad c_{\\pm 2} = -\\frac{1}{12}.\n$$\n\n- 6 阶格式（七点）：\n$$\nc_0 = -\\frac{49}{18},\\quad c_{\\pm 1} = \\frac{3}{2},\\quad c_{\\pm 2} = -\\frac{3}{20},\\quad c_{\\pm 3} = \\frac{1}{90}.\n$$\n\n二维算子定义为沿每个坐标轴应用的相同一维算子之和，即\n$$\n\\left(D_{xx} + D_{yy}\\right) u_{i,j} = \\frac{1}{h^2}\\left(\\sum_{m=-M}^{M} c_m\\, u_{i+m,j} + \\sum_{m=-M}^{M} c_m\\, u_{i,j+m}\\right),\n$$\n其中，2阶格式对应 $M = 1$，4阶格式对应 $M = 2$，6阶格式对应 $M = 3$。\n\n定义无量纲波数大小 $\\xi = k h$，其中 $k = \\sqrt{k_x^2 + k_y^2}$ 是物理波矢量的模，并通过角度 $\\theta \\in [0,\\pi/2]$ 定义传播方向，使得 $k_x = k \\cos\\theta$ 和 $k_y = k \\sin\\theta$。对于每一对 $(\\text{阶数}, \\xi)$，定义由该半离散模型得到的归一化相速度 $v_p(\\theta)/c$，并由此定义各向异性因子\n$$\n\\mathcal{A} = \\frac{\\max_{\\theta \\in \\Theta} \\left(v_p(\\theta)/c\\right) - \\min_{\\theta \\in \\Theta} \\left(v_p(\\theta)/c\\right)}{\\frac{1}{|\\Theta|}\\sum_{\\theta \\in \\Theta} \\left(v_p(\\theta)/c\\right)},\n$$\n其中有限角度集合 $\\Theta$ 为\n$$\n\\Theta = \\left\\{0,\\ \\frac{\\pi}{12},\\ \\frac{\\pi}{6},\\ \\frac{\\pi}{4},\\ \\frac{\\pi}{3},\\ \\frac{5\\pi}{12},\\ \\frac{\\pi}{2}\\right\\},\n$$\n$|\\Theta|$ 是该集合中角度的数量。所有角度都必须以弧度处理。\n\n您的任务是编写一个程序，该程序对下面给出的每个测试用例 $(\\text{阶数}, \\xi)$，计算上述定义的各向异性因子 $\\mathcal{A}$。最终答案必须是浮点数。由于结果是无量纲的，因此不需要物理单位。输出值必须四舍五入到小数点后六位。\n\n测试套件（每个条目是一对 $(\\text{阶数}, \\xi)$）：\n$$\n\\begin{aligned}\n&(\\ 4,\\ \\tfrac{\\pi}{2}\\ ),\\\\\n&(\\ 6,\\ \\tfrac{\\pi}{8}\\ ),\\\\\n&(\\ 6,\\ \\ 0.8\\,\\pi\\ ),\\\\\n&(\\ 2,\\ \\tfrac{\\pi}{2}\\ ).\n\\end{aligned}\n$$\n\n最终输出格式：您的程序应生成单行输出，其中包含与上述列表顺序相同的测试用例结果，格式为方括号内以逗号分隔的列表，例如，\n$$\n[\\ \\text{result}_1,\\ \\text{result}_2,\\ \\text{result}_3,\\ \\text{result}_4\\ ].\n$$\n每个 $\\text{result}_i$ 必须四舍五入到小数点后六位。", "solution": "所述问题在科学上是合理的、自洽的且适定的。它提出了一个偏微分方程数值方法分析中的标准任务：研究数值色散。所有必要的定义、方程和参数都已明确给出。因此，我们可以着手求解。\n\n目标是为二维标量波动方程的有限差分格式计算其数值相速度的各向异性因子 $\\mathcal{A}$。该分析需要为给定的半离散系统推导出数值色散关系。\n\n半离散波动方程由下式给出\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\left(D_{xx} + D_{yy}\\right) u\n$$\n其中 $D_{xx}$ 和 $D_{yy}$ 是在间距为 $h$ 的均匀网格上定义的二阶导数高阶中心有限差分算子。\n\n为了找到数值色散关系，我们将形式为\n$$\nu_{i,j}(t) = \\hat{u} e^{i(k_x x_i + k_y y_j - \\omega t)}\n$$\n的单色平面波解代入半离散方程中。这里，$(x_i, y_j) = (ih, jh)$ 是网格点坐标，$(k_x, k_y)$ 是波矢量，$\\omega$ 是角频率。\n\n左侧（LHS）的时间导数变为：\n$$\n\\frac{\\partial^2 u_{i,j}}{\\partial t^2} = (-\\omega^2) u_{i,j}(t)\n$$\n\n右侧（RHS）的空间算子作用于波解的空间部分。我们来考虑一维算子 $D_{xx}$ 对 $u_{i,j}$ 的作用：\n$$\nD_{xx} u_{i,j} = \\frac{1}{h^2} \\sum_{m=-M}^{M} c_m u_{i+m,j} = \\frac{1}{h^2} \\sum_{m=-M}^{M} c_m \\left( \\hat{u} e^{i(k_x(i+m)h + k_y j h - \\omega t)} \\right)\n$$\n$$\nD_{xx} u_{i,j} = \\frac{u_{i,j}}{h^2} \\sum_{m=-M}^{M} c_m e^{i k_x m h}\n$$\n由于格式系数是对称的，$c_{-m} = c_m$，求和可以简化为：\n$$\n\\sum_{m=-M}^{M} c_m e^{i k_x m h} = c_0 + \\sum_{m=1}^{M} c_m (e^{i m k_x h} + e^{-i m k_x h}) = c_0 + \\sum_{m=1}^{M} 2 c_m \\cos(m k_x h)\n$$\n对于 $D_{yy}$ 算子，存在一个类似的表达式。因此，完整的二维算子的作用是：\n$$\n\\left(D_{xx} + D_{yy}\\right) u_{i,j} = \\frac{u_{i,j}}{h^2} \\left[ \\left(c_0 + \\sum_{m=1}^{M} 2 c_m \\cos(m k_x h)\\right) + \\left(c_0 + \\sum_{m=1}^{M} 2 c_m \\cos(m k_y h)\\right) \\right]\n$$\n\n将左侧和右侧代回半离散方程，并除以 $u_{i,j}$，得到数值色散关系：\n$$\n-\\omega^2 = \\frac{c^2}{h^2} \\left[ 2c_0 + \\sum_{m=1}^{M} 2 c_m \\left( \\cos(m k_x h) + \\cos(m k_y h) \\right) \\right]\n$$\n$$\n\\omega^2 = -\\frac{c^2}{h^2} \\left[ 2c_0 + 2\\sum_{m=1}^{M} c_m \\left( \\cos(m k_x h) + \\cos(m k_y h) \\right) \\right]\n$$\n数值相速度定义为 $v_p = \\omega/k$，其中 $k = \\sqrt{k_x^2 + k_y^2}$ 是波数大小。我们关心的是归一化相速度 $v_p/c$。根据色散关系，我们有：\n$$\n\\left(\\frac{v_p}{c}\\right)^2 = \\frac{\\omega^2}{c^2 k^2} = -\\frac{1}{(kh)^2} \\left[ 2c_0 + 2\\sum_{m=1}^{M} c_m \\left( \\cos(m k_x h) + \\cos(m k_y h) \\right) \\right]\n$$\n使用问题中的定义，$\\xi = kh$，$k_x = k \\cos\\theta$ 和 $k_y = k \\sin\\theta$，我们得到 $k_x h = \\xi \\cos\\theta$ 和 $k_y h = \\xi \\sin\\theta$。将这些代入表达式中，得到对于给定的无量纲波数 $\\xi$，归一化相速度作为传播角 $\\theta$ 的函数的最终公式：\n$$\n\\frac{v_p(\\theta)}{c} = \\frac{1}{\\xi} \\sqrt{- \\left[ 2c_0 + 2\\sum_{m=1}^{M} c_m \\left( \\cos(m \\xi \\cos\\theta) + \\cos(m \\xi \\sin\\theta) \\right) \\right]}\n$$\n$M$ 的值取决于格式的阶数：2阶格式对应 $M=1$，4阶格式对应 $M=2$，6阶格式对应 $M=3$。系数 $\\{c_m\\}$ 在问题描述中已给出。\n\n对于每个测试用例 $(\\text{阶数}, \\xi)$，计算步骤如下：\n1. 根据给定的阶数，选择合适的格式系数 $\\{c_m\\}$ 和相应的最大偏移量 $M$。\n2. 定义离散角度集合 $\\Theta = \\left\\{0, \\frac{\\pi}{12}, \\frac{\\pi}{6}, \\frac{\\pi}{4}, \\frac{\\pi}{3}, \\frac{5\\pi}{12}, \\frac{\\pi}{2}\\right\\}$。\n3. 对于每个角度 $\\theta \\in \\Theta$，使用上面推导的公式计算归一化相速度 $v_p(\\theta)/c$。这将得到一组 7 个相速度值。\n4. 计算这 7 个值的最大值、最小值和算术平均值。\n5. 根据其定义计算各向异性因子 $\\mathcal{A}$：\n   $$\n   \\mathcal{A} = \\frac{\\max_{\\theta \\in \\Theta} \\left(v_p(\\theta)/c\\right) - \\min_{\\theta \\in \\Theta} \\left(v_p(\\theta)/c\\right)}{\\frac{1}{|\\Theta|}\\sum_{\\theta \\in \\Theta} \\left(v_p(\\theta)/c\\right)}\n   $$\n6. 将 $\\mathcal{A}$ 的最终结果四舍五入到小数点后六位。\n\n提供的 Python 代码实现了该算法，以求解指定的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_stencil_coeffs(order: int) -> dict[int, float]:\n    \"\"\"\n    Returns the finite difference stencil coefficients for a given order.\n    The dictionary keys are the offset index 'm'.\n    \"\"\"\n    if order == 2:\n        # M = 1\n        return {0: -2.0, 1: 1.0}\n    elif order == 4:\n        # M = 2\n        return {0: -5.0/2.0, 1: 4.0/3.0, 2: -1.0/12.0}\n    elif order == 6:\n        # M = 3\n        return {0: -49.0/18.0, 1: 3.0/2.0, 2: -3.0/20.0, 3: 1.0/90.0}\n    else:\n        raise ValueError(f\"Unsupported stencil order: {order}\")\n\ndef calculate_anisotropy(order: int, xi: float) -> float:\n    \"\"\"\n    Calculates the anisotropy factor for a given stencil order and\n    nondimensional wavenumber xi.\n    \"\"\"\n    coeffs = get_stencil_coeffs(order)\n    M = order // 2\n\n    # The set of angles Theta for evaluation\n    thetas = np.array([\n        0, np.pi/12, np.pi/6, np.pi/4, np.pi/3, 5*np.pi/12, np.pi/2\n    ])\n\n    # Nondimensional wavenumber components\n    xi_x = xi * np.cos(thetas)\n    xi_y = xi * np.sin(thetas)\n\n    # Calculate the term inside the square root of the dispersion relation\n    # S = - [2*c0 + sum_{m=1 to M} 2*cm*(cos(m*xi_x) + cos(m*xi_y))]\n    sum_term = np.zeros_like(thetas, dtype=float)\n    for m in range(1, M + 1):\n        sum_term += 2 * coeffs[m] * (np.cos(m * xi_x) + np.cos(m * xi_y))\n    \n    S = - (2 * coeffs[0] + sum_term)\n\n    # Ensure argument of sqrt is non-negative (can be slightly negative from fp error)\n    S = np.maximum(S, 0)\n    \n    # Handle the case xi=0 to avoid division by zero, although not in test cases.\n    # For xi -> 0, v_p/c -> 1 for all directions, thus anisotropy is 0.\n    if np.isclose(xi, 0.0):\n        return 0.0\n        \n    # Calculate the normalized phase speed v_p/c\n    vp_c = (1.0 / xi) * np.sqrt(S)\n    \n    # Calculate the anisotropy factor A\n    vp_c_max = np.max(vp_c)\n    vp_c_min = np.min(vp_c)\n    vp_c_mean = np.mean(vp_c)\n\n    # Avoid division by zero if mean phase speed is zero\n    if np.isclose(vp_c_mean, 0.0):\n        return 0.0\n\n    anisotropy = (vp_c_max - vp_c_min) / vp_c_mean\n    return anisotropy\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (order, xi)\n        (4, np.pi / 2.0),\n        (6, np.pi / 8.0),\n        (6, 0.8 * np.pi),\n        (2, np.pi / 2.0),\n    ]\n\n    results = []\n    for order, xi in test_cases:\n        anisotropy_factor = calculate_anisotropy(order, xi)\n        results.append(anisotropy_factor)\n\n    # Final print statement in the exact required format.\n    # Formatting to exactly six digits after the decimal point.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2401296"}, {"introduction": "谱分析中的修正波数 $\\tilde{k}$ 看似抽象，但它对波的传播有着非常具体的影响。这个终极实践旨在连接抽象理论与可观测的物理现象，你将设计一个数值实验来直接测量波包的群速度。通过将你的测量结果与从格式谱属性中推导出的理论预测进行比较，你将深刻理解为什么谱分析对于实际模拟如此重要。[@problem_id:2401300]", "problem": "要求您设计、推导并实现一个计算实验，用以测量由一维线性平流方程平流的调制波包的群速度，并将其与高阶中心有限差分空间离散化所导致的理论群速度进行比较。\n\n考虑在区间 $[0,L]$ 上具有周期性边界条件的一维平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0,\n$$\n其中 $u=u(x,t)$ 是复值函数，$c$ 是恒定波速，$x \\in [0,L]$，$t \\ge 0$。空间离散化在具有 $N$ 个点和间距 $\\Delta x=L/N$ 的均匀网格上进行。时间演化使用一种稳定的显式方法计算。初始条件是一个高斯调制平面波（一个波包），其载波波束为 $k_0$，包络宽度为 $\\sigma$，中心位于 $x_0$：\n$$\nu(x,0) = \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma^2} \\right) \\exp\\!\\left(i k_0 (x-x_0)\\right).\n$$\n您需要测量波包包络的质心，并由此数值推断其群速度，然后将其与所选高阶有限差分格式所对应的理论群速度进行比较。\n\n您的解决方案和代码必须体现以下基本基础和推导任务：\n- 从平流方程的线性性质和常系数特性以及解的傅里叶表示出发。对于采用名义阶数 $p \\in \\{2,4,6\\}$ 的中心有限差分近似来处理一阶导数的半离散线方法，其空间离散算子是与一个反对称模板的卷积。对于傅里叶模 $e^{i k x}$，该算子的符号是一个纯虚数 $i\\,\\widetilde{k}(k)$，其中 $\\widetilde{k}(k)$ 是修正波数。因此，对于一个傅里叶模，半离散系统为 $\\frac{d\\widehat{u}}{dt} + i\\,c\\,\\widetilde{k}(k)\\widehat{u}=0$，这意味着数值色散关系为 $\\omega_{\\text{num}}(k)=c\\,\\widetilde{k}(k)$，理论群速度为 $v_{g,\\text{theory}}(k)=\\frac{d\\omega_{\\text{num}}}{dk}(k)$。\n- 对于一个用于一阶导数的 $p$ 阶显式中心有限差分模板，其权重为 $\\{w_m\\}_{m=1}^M$，使得\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_i} \\approx \\frac{1}{\\Delta x}\\sum_{m=1}^{M} w_m \\left(u_{i+m}-u_{i-m}\\right),\n$$\n其离散傅里叶符号为 $i\\,\\widetilde{k}(k)$，其中\n$$\n\\widetilde{k}(k) = \\frac{1}{\\Delta x} \\sum_{m=1}^{M} 2 w_m \\sin(m \\theta), \\quad \\theta = k\\,\\Delta x,\n$$\n因此\n$$\nv_{g,\\text{theory}}(k) = c \\sum_{m=1}^M m \\cdot (2 w_m) \\cos(m\\theta), \\quad \\theta=k\\,\\Delta x.\n$$\n在实现之前，您必须推导出名义阶数 $p=2,4,6$ 的显式权重 $\\{w_m\\}$。\n\n数值实验设计约束：\n- 使用区域长度 $L=2\\pi$ 米，波速 $c=1$ 米/秒，网格点数 $N=1024$，以及周期性边界条件。角度必须以弧度为单位处理。时间积分采用四阶 Runge–Kutta (RK4) 方法，固定时间步长 $\\Delta t=\\mu\\,\\Delta x/c$，Courant–Friedrichs–Lewy (CFL) 数 $\\mu=0.2$。积分至最终时间 $T=1.5$ 秒。设 $x_0=L/3$ 米，$\\sigma=L/20$ 米。\n- 为确保载波在网格上可分辨且具有周期性，设 $k_0 = 2\\pi m_0/L$，其中 $m_0$ 为整数。\n- 通过使用非负权重 $|u(x,t)|^2$ 和在 $[0,L]$ 上的循环（周期性）均值来追踪包络的质心，以正确处理环绕效应，从而估计测量的群速度 $v_{g,\\text{measured}}$。计算 $v_{g,\\text{measured}} = \\Delta x_{\\text{cm}}/T$，其中 $\\Delta x_{\\text{cm}}$ 是初始质心和最终质心之间的最短周期性位移。\n- 根据您推导的公式，计算所选阶数 $p$ 和载波波数 $k_0$ 的理论群速度 $v_{g,\\text{theory}}$。\n- 对于每个测试用例，报告绝对误差 $|v_{g,\\text{measured}} - v_{g,\\text{theory}}|$，单位为米/秒，结果为浮点数，四舍五入到六位小数。\n\n测试套件：\n使用以下参数集，每个用例是一个参数对 $(p,m_0)$：\n- 用例 A（理想路径）： $(p,m_0)=(6,24)$。\n- 用例 B（低阶比较）： $(p,m_0)=(4,24)$。\n- 用例 C（小波数极限）： $(p,m_0)=(6,4)$。\n- 用例 D（高波数边缘情况）： $(p,m_0)=(6,128)$。\n\n您的程序应生成单行输出，其中包含按 [用例A,用例B,用例C,用例D] 顺序排列的结果，形式为逗号分隔的列表并用方括号括起来，例如，“[0.000123,0.000456,0.000789,0.000012]”。每个条目必须是绝对误差，单位为米/秒，并四舍五入到六位小数。", "solution": "所述问题是计算物理学中一个适定且科学上合理的练习。它要求推导、实现和分析一个用于线性平流方程的数值格式，重点关注数值色散现象。该问题是自洽的，所有参数和方法都已明确指定。我们将着手进行解答。\n\n基本方程是用于复值场 $u(x,t)$ 的一维线性平流方程，由\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\n给出，定义在周期性区域 $x \\in [0,L]$ 上。常数 $c$ 是精确连续系统的相速度和群速度。该偏微分方程的线性性质允许解由形式为 $u_k(x,t) = \\widehat{u}_k(t) e^{i k x}$ 的傅里叶模叠加而成，其中 $k$ 是波数。将这样一个模代入方程，得到振幅 $\\widehat{u}_k(t)$ 的常微分方程：\n$$\n\\frac{d\\widehat{u}_k}{dt} + c (i k) \\widehat{u}_k = 0\n$$\n其解为 $\\widehat{u}_k(t) = \\widehat{u}_k(0) e^{-i c k t}$。这给出了精确的色散关系 $\\omega(k) = c k$。相应的群速度控制着波包的传播，为 $v_g(k) = \\frac{d\\omega}{dk} = c$。在精确系统中，所有波都以相同的速度 $c$ 传播而无失真，这意味着它是非色散的。\n\n我们分析在空间上离散但在时间上连续的系统（线方法）。空间区域被离散化为 $N$ 个点 $x_j = j \\Delta x$，其中 $j = 0, \\dots, N-1$，$\\Delta x = L/N$。空间导数 $\\frac{\\partial u}{\\partial x}$ 由一个 $p$ 阶中心有限差分算子 $D_x$ 来近似。对于网格函数 $u_j(t) = u(x_j, t)$，半离散系统为：\n$$\n\\frac{du_j}{dt} + c (D_x u)_j = 0\n$$\n算子 $D_x$ 是与一个反对称模板的线性卷积。当应用于离散傅里叶模 $e^{i k x_j}$ 时，其作用等同于乘以一个纯虚数 $i \\widetilde{k}(k)$，其中 $\\widetilde{k}(k)$ 是*修正波数*。傅里叶模的半离散方程变为：\n$$\n\\frac{d\\widehat{u}_k}{dt} + c (i \\widetilde{k}(k)) \\widehat{u}_k = 0\n$$\n这产生了一个数值色散关系 $\\omega_{\\text{num}}(k) = c \\widetilde{k}(k)$。于是，数值群速度为 $v_{g,\\text{num}}(k) = \\frac{d\\omega_{\\text{num}}}{dk}$。因为 $\\widetilde{k}(k)$ 通常不等于 $k$，所以数值群速度 $v_{g,\\text{num}}$ 依赖于 $k$，这一现象被称为数值色散。\n\n问题指定了一种形式为 ... 的中心模板：\n$$\n(D_x u)_i = \\frac{1}{\\Delta x} \\sum_{m=1}^{M} w_m (u_{i+m} - u_{i-m})\n$$\n为了确定未知权重 $\\{w_m\\}$，我们使用 $u(x \\pm m\\Delta x)$ 在 $x$ 点的泰勒级数展开：\n$$\nu(x+m\\Delta x) - u(x-m\\Delta x) = \\sum_{n=0}^{\\infty} \\frac{2(m\\Delta x)^{2n+1}}{(2n+1)!} \\frac{d^{2n+1}u}{dx^{2n+1}}\n$$\n将此代入有限差分公式并除以 $\\Delta x$ 可得：\n$$\n(D_x u)(x) = \\sum_{m=1}^{M} w_m \\sum_{n=0}^{\\infty} \\frac{2 m^{2n+1}(\\Delta x)^{2n}}{(2n+1)!} u^{(2n+1)}(x)\n$$\n重排求和顺序，我们得到算子关于 $u$ 的导数的表达式：\n$$\n(D_x u)(x) = \\left( \\sum_{m=1}^{M} 2m w_m \\right) u'(x) + \\left( \\sum_{m=1}^{M} \\frac{m^3 w_m}{3} \\right) (\\Delta x)^2 u'''(x) + \\left( \\sum_{m=1}^{M} \\frac{m^5 w_m}{75} \\right) (\\Delta x)^4 u^{(5)}(x) + \\dots\n$$\n对于一个 $p$ 阶精确的格式，我们要求 $u'(x)$ 的系数为 $1$，而 $u'''(x), u^{(5)}(x), \\dots, u^{(p-1)}(x)$ 的系数为 $0$。这就产生了一个关于权重 $w_m$ 的线性方程组。\n\n对于 $p=2$ ($M=1$):\n$2(1)w_1 = 1 \\implies w_1 = 1/2$。\n\n对于 $p=4$ ($M=2$):\n$2w_1 + 4w_2 = 1$\n$w_1 + 8w_2 = 0$\n解此方程组可得 $w_1 = 2/3$ 和 $w_2 = -1/12$。\n\n对于 $p=6$ ($M=3$):\n$2w_1 + 4w_2 + 6w_3 = 1$\n$w_1 + 8w_2 + 27w_3 = 0$\n$w_1 + 32w_2 + 243w_3 = 0$\n解此方程组可得 $w_1 = 3/4$, $w_2 = -3/20$, and $w_3 = 1/60$。\n\n接着，我们推导理论群速度。将该模板应用于模式 $e^{i k x}$ 在 $x_j$ 处，我们发现：\n$$\nD_x e^{ikx_j} = \\frac{1}{\\Delta x} \\sum_{m=1}^M w_m (e^{ik(x_j+m\\Delta x)} - e^{ik(x_j-m\\Delta x)}) = e^{ikx_j} \\frac{1}{\\Delta x} \\sum_{m=1}^M w_m (e^{imk\\Delta x} - e^{-imk\\Delta x})\n$$\n使用欧拉公式 $e^{i\\phi}-e^{-i\\phi} = 2i\\sin(\\phi)$，并令 $\\theta = k\\Delta x$：\n$$\nD_x e^{ikx_j} = e^{ikx_j} \\frac{2i}{\\Delta x} \\sum_{m=1}^M w_m \\sin(m\\theta)\n$$\n这证实了符号是 $i\\widetilde{k}(k)$，其中修正波数为 $\\widetilde{k}(k) = \\frac{2}{\\Delta x} \\sum_{m=1}^M w_m \\sin(m\\theta)$。\n数值色散关系为 $\\omega_{\\text{num}}(k) = c \\widetilde{k}(k)$。理论群速度是它关于 $k$ 的导数：\n$$\nv_{g,\\text{theory}}(k) = \\frac{d\\omega_{\\text{num}}}{dk} = c \\frac{d\\widetilde{k}}{dk} = c \\frac{d\\widetilde{k}}{d\\theta} \\frac{d\\theta}{dk} = c \\left( \\frac{2}{\\Delta x} \\sum_{m=1}^M w_m \\cdot m\\cos(m\\theta) \\right) \\Delta x\n$$\n$$\nv_{g,\\text{theory}}(k) = c \\sum_{m=1}^M 2 m w_m \\cos(m k \\Delta x)\n$$\n使用推导出的权重，我们获得以下显式公式：\n对于 $p=2$： $v_{g,\\text{theory}}(k) = c \\cos(k \\Delta x)$。\n对于 $p=4$： $v_{g,\\text{theory}}(k) = c \\left( \\frac{4}{3} \\cos(k \\Delta x) - \\frac{1}{3} \\cos(2 k \\Delta x) \\right)$。\n对于 $p=6$： $v_{g,\\text{theory}}(k) = c \\left( \\frac{3}{2} \\cos(k \\Delta x) - \\frac{3}{5} \\cos(2 k \\Delta x) + \\frac{1}{10} \\cos(3 k \\Delta x) \\right)$。\n这些公式将用于计算每个测试用例的理论群速度。\n\n数值实验设计如下。\n区域为 $L=2\\pi$，有 $N=1024$ 个点，得到 $\\Delta x = 2\\pi/1024$。波速为 $c=1$。\n初始条件是一个波包 $u(x,0) = \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma^2} \\right) \\exp\\!\\left(i k_0 (x-x_0)\\right)$，其中 $x_0=L/3$，$\\sigma=L/20$，载波波数 $k_0 = 2\\pi m_0/L = m_0$。\n半离散系统 $\\frac{d\\mathbf{u}}{dt} = -c D_x \\mathbf{u}$ 使用经典的四阶 Runge-Kutta (RK4) 方法进行时间积分，固定时间步长 $\\Delta t = \\mu \\Delta x / c$，其中 $\\mu=0.2$。积分进行到 $T=1.5$。\n空间导数项 $D_x \\mathbf{u}$ 使用快速傅里叶变换 (FFT) 高效计算。该操作是一个周期性卷积，在傅里叶空间中变成简单的乘法： $D_x \\mathbf{u} = \\mathcal{F}^{-1}\\{ i \\widetilde{k}(\\mathbf{k}) \\mathcal{F}\\{\\mathbf{u}\\} \\}$，其中 $\\mathbf{k}$ 是离散网格波数的向量。\n群速度通过追踪波包的包络来测量。概率密度 $|u(x,t)|^2$ 的质心是衡量波包位置的一个鲁棒指标。对于周期性区域，质心 $x_{\\text{cm}}$ 通过一阶循环矩的辐角计算得出：\n$$\nx_{\\text{cm}}(t) = \\frac{L}{2\\pi} \\arg\\left( \\sum_{j=0}^{N-1} |u(x_j, t)|^2 e^{i 2\\pi x_j/L} \\right)\n$$\n`arg` 函数返回一个在 $(-\\pi, \\pi]$ 区间内的值，该值映射到位置区间 $(-L/2, L/2]$。为了保持一致性，我们将其映射到 $[0, L)$。\n计算初始和最终位置 $x_{\\text{cm}}(0)$ 和 $x_{\\text{cm}}(T)$。最短周期性位移是 $\\Delta x_{\\text{cm}} = ( (x_{\\text{cm}}(T) - x_{\\text{cm}}(0) + L/2) \\pmod L ) - L/2$。测量的群速度则为 $v_{g,\\text{measured}} = \\Delta x_{\\text{cm}} / T$。\n最后，为每个测试用例计算绝对误差 $|v_{g,\\text{measured}} - v_{g,\\text{theory}}(k_0)|$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, derives, and implements a computational experiment to measure \n    the group velocity of a modulated wave packet and compare it with the \n    theoretical group velocity from a high-order finite difference scheme.\n    \"\"\"\n\n    # -- Problem Parameters --\n    L = 2.0 * np.pi  # Domain length (meters)\n    c = 1.0          # Wave speed (m/s)\n    N = 1024         # Number of grid points\n    mu = 0.2         # CFL number\n    T = 1.5          # Final time (seconds)\n    x0 = L / 3.0     # Initial packet center (meters)\n    sigma = L / 20.0 # Packet width (meters)\n\n    # -- Discretization --\n    dx = L / N\n    x = np.linspace(0, L, N, endpoint=False)\n    dt = mu * dx / c\n    n_steps = int(np.ceil(T / dt))\n\n    # Grid wavenumbers\n    k_vec = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # -- Stencil Weights for Centered Difference Schemes --\n    # P_map: M, weights\n    p_map = {\n        2: (1, [1/2]),\n        4: (2, [2/3, -1/12]),\n        6: (3, [3/4, -3/20, 1/60])\n    }\n\n    def get_rhs(u, p):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete equation:\n        du/dt = -c * D_x(u)\n        using a p-th order finite difference scheme via FFT.\n        \"\"\"\n        M, weights = p_map[p]\n        \n        # Compute the modified wavenumber k_tilde\n        k_tilde = np.zeros_like(k_vec)\n        for m in range(1, M + 1):\n            w_m = weights[m-1]\n            k_tilde += 2 * w_m * np.sin(m * k_vec * dx) / dx\n        \n        # The symbol of the derivative operator is i*k_tilde\n        u_hat = np.fft.fft(u)\n        rhs_hat = -c * 1j * k_tilde * u_hat\n        \n        return np.fft.ifft(rhs_hat)\n\n    def rk4_step(u, p, dt_val):\n        \"\"\"Performs a single RK4 step.\"\"\"\n        k1 = get_rhs(u, p)\n        k2 = get_rhs(u + dt_val * k1 / 2.0, p)\n        k3 = get_rhs(u + dt_val * k2 / 2.0, p)\n        k4 = get_rhs(u + dt_val * k3, p)\n        return u + dt_val * (k1 + 2*k2 + 2*k3 + k4) / 6.0\n\n    def get_center_of_mass(u):\n        \"\"\"\n        Computes the circular center of mass for the envelope |u|^2.\n        \"\"\"\n        density = np.abs(u)**2\n        # Use phase of the first circular moment\n        # Z = sum(rho_j * exp(i * 2*pi*j / N))\n        Z = np.sum(density * np.exp(1j * 2 * np.pi * np.arange(N) / N))\n        # angle(Z) is in [-pi, pi], corresponds to position in [-L/2, L/2]\n        # map to [0, L)\n        position = (np.angle(Z) * L / (2 * np.pi)) % L\n        return position\n\n    def get_theoretical_group_velocity(k0, p):\n        \"\"\"\n        Computes the theoretical group velocity for wavenumber k0 and order p.\n        \"\"\"\n        M, weights = p_map[p]\n        theta = k0 * dx\n        \n        vg_theory = 0.0\n        for m in range(1, M + 1):\n            w_m = weights[m-1]\n            vg_theory += (2 * m * w_m) * np.cos(m * theta)\n            \n        return c * vg_theory\n\n    def solve_for_case(p, m0):\n        \"\"\"\n        Runs the simulation and computes the error for a given test case.\n        \"\"\"\n        # -- Initial Condition --\n        k0 = 2.0 * np.pi * m0 / L\n        # Ensure x-x0 is periodic for the phase part.\n        dist = x - x0\n        phase = k0 * dist\n        envelope = np.exp(-(dist**2) / (2 * sigma**2))\n        u = envelope * np.exp(1j * phase)\n\n        # -- Get Initial Position --\n        x_cm_initial = get_center_of_mass(u)\n\n        # -- Time Integration --\n        u_final = u.copy()\n        for _ in range(n_steps):\n            u_final = rk4_step(u_final, p, dt)\n\n        # -- Get Final Position and Measured Velocity --\n        x_cm_final = get_center_of_mass(u_final)\n        \n        # Shortest periodic displacement\n        displacement = x_cm_final - x_cm_initial\n        delta_x_cm = (displacement + L/2) % L - L/2\n        \n        vg_measured = delta_x_cm / (n_steps * dt)\n\n        # -- Get Theoretical Velocity --\n        vg_theory = get_theoretical_group_velocity(k0, p)\n        \n        # -- Compute Absolute Error --\n        error = np.abs(vg_measured - vg_theory)\n        return round(error, 6)\n\n    # -- Test Suite --\n    test_cases = [\n        (6, 24),    # Case A\n        (4, 24),    # Case B\n        (6, 4),     # Case C\n        (6, 128),   # Case D\n    ]\n\n    results = []\n    for p_val, m0_val in test_cases:\n        result = solve_for_case(p_val, m0_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2401300"}]}