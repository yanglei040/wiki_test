{"hands_on_practices": [{"introduction": "在许多大规模科学计算问题中，我们遇到的矩阵 $A$ 如此巨大，以至于无法在内存中显式存储。幸运的是，我们通常只需要计算矩阵与向量的乘积 $Ax$。本练习将引导你实践 Arnoldi 迭代中的一个核心思想——“无矩阵”方法，你将通过函数调用的方式（而非直接的矩阵乘法）来实现算子 $A$ 的作用，并将其应用于几种不同类型的算子。通过这个练习，你将掌握 Arnoldi 迭代的基础实现，并为解决现实世界中的大规模计算物理问题打下坚实的基础 [@problem_id:2373518]。", "problem": "您的任务是计算几个实非对称线性算子的谱半径的近似值，且仅能使用算子作用于向量的能力。对于一个维度为 $n$ 的有限维实向量空间，设 $A:\\mathbb{R}^n \\to \\mathbb{R}^n$ 是一个线性算子。对于一个选定的正整数 $m$ 和一个非零的起始向量 $v_0 \\in \\mathbb{R}^n$，考虑 $m$ 维 Krylov 子空间 $K_m(A, v_0) = \\mathrm{span}\\{v_0, A v_0, A^2 v_0, \\dots, A^{m-1} v_0\\}$。令 $V_m \\in \\mathbb{R}^{n \\times m}$ 表示 $K_m(A, v_0)$ 的一个列标准正交基，并令 $H_m = V_m^\\top A V_m \\in \\mathbb{R}^{m \\times m}$ 表示 $A$ 在此子空间上的正交投影。定义 Ritz 值为 $H_m$ 的特征值，并定义谱半径的 Ritz 估计为这些 Ritz 值中的最大模。$A$ 的真实谱半径为 $\\rho(A) = \\max\\{|\\lambda| : \\lambda \\in \\sigma(A)\\}$，其中 $\\sigma(A)$ 是 $A$ 的谱。\n\n您的程序必须对下面列出的每个测试用例，使用规定的初始向量，计算 Ritz 估计（由 $H_m$ 的特征值计算得出）与真实谱半径 $\\rho(A)$ 之间的绝对误差。程序不得直接访问 $A$ 的矩阵元素；它只能使用 $A$ 作用于向量的功能。三角函数中的所有角度都应解释为弧度。最终输出必须是单行文本，包含一个浮点数列表，对应每个测试用例的绝对误差，并四舍五入到八位小数。\n\n请使用以下测试套件。在每个用例中，初始向量 $v_0 \\in \\mathbb{R}^n$ 的分量定义为\n$$\n(v_0)_i = \\sin(i) + \\tfrac{1}{2}\\cos(2 i), \\quad i=1,2,\\dots,n,\n$$\n随后将其归一化至单位欧几里得范数 $\\|(v_0)\\|_2 = 1$。\n\n- 测试用例 1 (三对角 Toeplitz 算子):\n  - 维度: $n = 80$。\n  - 参数: $a = 1$, $b = 2$, $c = \\tfrac{1}{2}$。\n  - 算子作用: 对任意 $x \\in \\mathbb{R}^n$，定义 $y = A x \\in \\mathbb{R}^n$ 如下\n    $$\n    y_1 = a x_1 + b x_2,\\quad\n    y_i = c x_{i-1} + a x_i + b x_{i+1}\\ \\text{for}\\ i=2,\\dots,n-1,\\quad\n    y_n = c x_{n-1} + a x_n.\n    $$\n  - 子空间维度: $m = 25$。\n  - 真实谱半径: 对于此算子，特征值为 $a + 2\\sqrt{b c}\\cos\\left(\\tfrac{j\\pi}{n+1}\\right)$ (对 $j=1,2,\\dots,n$)，因此\n    $$\n    \\rho(A) = \\max\\Big\\{\\left|a + 2\\sqrt{b c}\\right|,\\ \\left|a - 2\\sqrt{b c}\\right|\\Big\\}.\n    $$\n\n- 测试用例 2 (Jordan 块):\n  - 维度: $n = 60$。\n  - 参数: $\\lambda = 3$。\n  - 算子作用: 对任意 $x \\in \\mathbb{R}^n$，定义 $y = A x \\in \\mathbb{R}^n$ 如下\n    $$\n    y_i = \\lambda x_i + x_{i+1}\\ \\text{for}\\ i=1,2,\\dots,n-1,\\quad\n    y_n = \\lambda x_n.\n    $$\n  - 子空间维度: $m = 15$。\n  - 真实谱半径: $\\rho(A) = |\\lambda|$。\n\n- 测试用例 3 (具有对角谱的相似变换):\n  - 维度: $n = 50$。\n  - 对角谱: 定义 $d_{\\max} = 5$, $d_{\\min} = 1$, 以及\n    $$\n    d_i = d_{\\min} + (d_{\\max} - d_{\\min})\\frac{n - i}{n - 1},\\quad i=1,2,\\dots,n.\n    $$\n    令 $D \\in \\mathbb{R}^{n \\times n}$ 为对角项是 $d_i$ 的对角矩阵。\n  - 相似矩阵: 定义 $S \\in \\mathbb{R}^{n \\times n}$ 如下\n    $$\n    S_{ij} = \\delta_{ij} + 10^{-2}\\sin\\!\\Big(\\frac{(i)(j)}{n+1}\\Big),\\quad i,j=1,2,\\dots,n,\n    $$\n    其中 $\\delta_{ij}$ 是 Kronecker delta。\n  - 算子作用: 对任意 $x \\in \\mathbb{R}^n$，定义 $y = A x$ 为 $y = S D S^{-1} x$。\n  - 子空间维度: $m = 30$。\n  - 真实谱半径: $\\rho(A) = \\max_i |d_i| = d_{\\max}$。\n\n- 测试用例 4 (标量倍数单位矩阵的带状幂零扰动):\n  - 维度: $n = 100$。\n  - 参数: $\\alpha = 2$，带宽 $p = 3$。\n  - 算子作用: 对任意 $x \\in \\mathbb{R}^n$，定义 $y = A x \\in \\mathbb{R}^n$ 如下\n    $$\n    y = \\alpha x + \\sum_{k=1}^{p} N_k x,\n    $$\n    其中当 $i=1,2,\\dots,n-k$ 时，$(N_k x)_i = x_{i+k}$，而当 $i>n-k$ 时，$(N_k x)_i = 0$。\n  - 子空间维度: $m = 50$。\n  - 真实谱半径: 由于 $A = \\alpha I + N$ 且 $N$ 是幂零的，所以 $\\rho(A) = |\\alpha|$。\n\n对于每个测试用例，计算绝对误差\n$$\n\\varepsilon = \\left|\\max_{\\mu \\in \\sigma(H_m)} |\\mu| - \\rho(A)\\right|,\n$$\n其中 $H_m$ 是 $A$ 在由归一化 $v_0$ 生成的 $m$ 维 Krylov 子空间上的正交投影。如果由于精确或近似的 breakdown（分解），Krylov 子空间的维度严格小于 $m$，则在构建 $H_m$ 时使用实际构建的子空间维度。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试用例的顺序排列，每个数字都四舍五入到八位小数（例如，$[0.12345678,0.00000000,0.5,1.23456789]$）。不应打印任何其他文本。", "solution": "该问题要求计算线性算子 $A$ 的真实谱半径与通过 Arnoldi 迭代获得的近似值之间的绝对误差。谱半径 $\\rho(A)$ 定义为 $A$ 的特征值的最大绝对值。Arnoldi 迭代是一种数值方法，用于寻找一个一般的、通常是大型稀疏的非对称矩阵或线性算子的部分特征值。一个关键约束是，算子 $A$ 只能通过其对向量的作用来访问，即作为一个函数，对于给定的 $x$ 返回 $Ax$。\n\nArnoldi 迭代为 Krylov 子空间 $K_m(A, v_1) = \\mathrm{span}\\{v_1, A v_1, A^2 v_1, \\dots, A^{m-1} v_1\\}$ 构建了一个标准正交基，其中 $v_1$ 是单位范数的起始向量， $m$ 是子空间的维度。设标准正交基向量是矩阵 $V_m = [v_1, v_2, \\dots, v_m] \\in \\mathbb{R}^{n \\times m}$ 的列。该过程还生成一个 $m \\times m$ 的上 Hessenberg 矩阵 $H_m$，它表示算子 A 在 Krylov 子空间上的正交投影：$H_m = V_m^\\top A V_m$。\n\n这个较小矩阵 $H_m$ 的特征值，记为 $\\{\\mu_k\\}_{k=1}^m$，被称为 Ritz 值。它们可作为原始算子 $A$ 特征值的近似值。$A$ 的谱半径的 Ritz 估计由 $\\hat{\\rho}_m(A) = \\max_{k=1,\\dots,m} |\\mu_k|$ 给出。目标是为几个测试用例计算绝对误差 $\\varepsilon = |\\hat{\\rho}_m(A) - \\rho(A)|$。\n\n基 $V_m$ 和矩阵 $H_m$ 的构建是通过一个稳定的 Gram-Schmidt 正交化过程来完成的。给定一个归一化的起始向量 $v_1$，该算法对 $j=1, 2, \\dots, m$ 按以下步骤进行：\n1. 计算 Krylov 序列中的下一个向量: $w \\gets A v_j$。\n2. 将 $w$ 与先前生成的基向量 $\\{v_1, \\dots, v_j\\}$ 正交化。这通过对 $i = 1, \\dots, j$ 进行迭代来实现：\n   a. 计算投影系数: $h_{ij} \\gets v_i^\\top w$。\n   b. 减去投影: $w \\gets w - h_{ij} v_i$。\n3. 得到的向量 $w$ 的范数是 Hessenberg 矩阵的下一个次对角线元素: $h_{j+1, j} \\gets \\|w\\|_2$。\n4. 如果 $h_{j+1, j}$ 在数值上为零，则表示发生了 breakdown。Krylov 子空间在 $A$ 的作用下是不变的，其维度为 $j$，小于所期望的 $m$。算法终止，得到的投影是一个 $j \\times j$ 的矩阵。\n5. 如果没有发生 breakdown，则将新向量归一化以获得下一个基向量: $v_{j+1} \\gets w / h_{j+1, j}$。\n\n$i \\in \\{1,\\dots,j\\}$ 的系数 $h_{ij}$ 和 $h_{j+1,j}$ 构成了 $(m+1) \\times m$ 上 Hessenberg 矩阵 $\\tilde{H}_m$ 的元素。所需的矩阵 $H_m$ 是 $\\tilde{H}_m$ 的上部 $m \\times m$ 子矩阵。\n\n对于每个测试用例，实现需要一个特定的函数来计算算子 $A$ 对任意向量 $x$ 的作用。初始向量 $v_0$ 的分量定义为 $(v_0)_i = \\sin(i) + \\frac{1}{2}\\cos(2i)$ (对 $i=1, \\dots, n$)，然后将其归一化为 $v_1 = v_0/\\|v_0\\|_2$ 来开始迭代。\n\n-   **测试用例 1 (三对角 Toeplitz 算子)**：该算子的作用由一个简单的模板定义，可以使用向量运算高效实现。真实谱半径由基于其参数 $a, b, c$ 的解析公式给出。\n-   **测试用例 2 (Jordan 块)**：该算子作用对应于乘以一个矩阵 $J = \\lambda I + N$，其中 $N$ 是在第一超对角线上为 1 的幂零矩阵。其对向量的作用很容易计算。真实谱半径就是 $|\\lambda|$。\n-   **测试用例 3 (相似变换)**：算子为 $A = S D S^{-1}$，其中 $D$ 是对角矩阵，$S$ 是一个指定的稠密矩阵。其作用 $y = A x$ 必须按一系列操作计算：首先，求解线性系统 $S z = x$ 以获得 $z=S^{-1}x$；其次，计算元素级乘积 $w=Dz$；最后，计算矩阵向量乘积 $y=Sw$。真实谱半径是 $D$ 的对角元素的最大绝对值。\n-   **测试用例 4 (扰动单位阵)**：算子为 $A = \\alpha I + N$，其中 $N$ 是移位算子的和，使其成为一个严格上三角矩阵，因此是幂零矩阵。$A$ 的所有特征值都等于 $\\alpha$，所以 $\\rho(A) = |\\alpha|$。其作用通过缩放输入向量并加上其移位版本来计算。\n\n对于每种情况，执行 Arnoldi 迭代来构建 $H_m$。数值计算 $H_m$ 的特征值，其最大模给出了 Ritz 估计 $\\hat{\\rho}_m(A)$。然后将其与已知的真实谱半径 $\\rho(A)$ 进行比较，以求得所需的绝对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef arnoldi_iteration(A_op, v_start, m):\n    \"\"\"\n    Performs Arnoldi iteration to find the Hessenberg projection H_m.\n    This implementation uses a modified Gram-Schmidt process for stability.\n\n    Args:\n        A_op: A function that computes A @ x.\n        v_start: The normalized starting vector of size n.\n        m: The desired dimension of the Krylov subspace.\n\n    Returns:\n        H: The m_eff x m_eff upper Hessenberg matrix, where m_eff = m is\n           the effective dimension upon breakdown.\n    \"\"\"\n    n = v_start.shape[0]\n    V = np.zeros((n, m + 1), dtype=np.float64)\n    H = np.zeros((m + 1, m), dtype=np.float64)\n    \n    # A small tolerance for breakdown detection\n    tolerance = np.finfo(np.float64).eps * n\n    \n    V[:, 0] = v_start\n    \n    for j in range(m):\n        w = A_op(V[:, j])\n        \n        # Orthogonalize w against the existing basis V using modified Gram-Schmidt\n        for i in range(j + 1):\n            h_ij = np.dot(V[:, i], w)\n            w -= h_ij * V[:, i]\n            H[i, j] = h_ij\n        \n        h_jp1_j = np.linalg.norm(w)\n        \n        if h_jp1_j  tolerance:\n            # Breakdown: Krylov subspace has dimension j+1\n            m_eff = j + 1\n            return H[:m_eff, :m_eff]\n            \n        H[j + 1, j] = h_jp1_j\n        V[:, j + 1] = w / h_jp1_j\n        \n    return H[:m, :m]\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases.\n    \"\"\"\n    # Define operator factories and true spectral radii for each test case\n    \n    def get_op1(n, params):\n        a, b, c = params['a'], params['b'], params['c']\n        def op(x):\n            y = np.zeros_like(x)\n            y[0] = a * x[0] + b * x[1]\n            y[1:-1] = c * x[:-2] + a * x[1:-1] + b * x[2:]\n            y[-1] = c * x[-2] + a * x[-1]\n            return y\n        return op\n    \n    def get_op2(n, params):\n        lam = params['lambda']\n        def op(x):\n            y = np.zeros_like(x)\n            y[:-1] = lam * x[:-1] + x[1:]\n            y[-1] = lam * x[-1]\n            return y\n        return op\n        \n    def get_op3(n, params):\n        d_max, d_min = params['d_max'], params['d_min']\n        i_vec = np.arange(1, n + 1)\n        d = d_min + (d_max - d_min) * (n - i_vec) / (n - 1)\n        \n        i_v = i_vec[:, None]\n        j_h = i_vec[None, :]\n        S = np.eye(n) + 1e-2 * np.sin(i_v * j_h / (n + 1))\n        \n        # Return a closure that has pre-computed S and d\n        def op(x):\n            # y = S * D * S_inv * x\n            z = np.linalg.solve(S, x)\n            w = d * z\n            y = S @ w\n            return y\n        return op\n\n    def get_op4(n, params):\n        alpha, p = params['alpha'], params['p']\n        def op(x):\n            y = alpha * x.copy()\n            for k in range(1, p + 1):\n                y[:n-k] += x[k:]\n            return y\n        return op\n\n    test_cases = [\n        {\n            \"n\": 80, \"m\": 25, \"params\": {\"a\": 1.0, \"b\": 2.0, \"c\": 0.5},\n            \"A_op_factory\": get_op1,\n            \"true_rho\": lambda p: max(abs(p['a'] + 2 * np.sqrt(p['b'] * p['c'])), \n                                      abs(p['a'] - 2 * np.sqrt(p['b'] * p['c'])))\n        },\n        {\n            \"n\": 60, \"m\": 15, \"params\": {\"lambda\": 3.0},\n            \"A_op_factory\": get_op2,\n            \"true_rho\": lambda p: abs(p['lambda'])\n        },\n        {\n            \"n\": 50, \"m\": 30, \"params\": {\"d_max\": 5.0, \"d_min\": 1.0},\n            \"A_op_factory\": get_op3,\n            \"true_rho\": lambda p: p['d_max']\n        },\n        {\n            \"n\": 100, \"m\": 50, \"params\": {\"alpha\": 2.0, \"p\": 3},\n            \"A_op_factory\": get_op4,\n            \"true_rho\": lambda p: abs(p['alpha'])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n, m, params = case[\"n\"], case[\"m\"], case[\"params\"]\n        \n        # 1. Define initial vector\n        i_vals = np.arange(1, n + 1)\n        v0_unnormalized = np.sin(i_vals) + 0.5 * np.cos(2 * i_vals)\n        v0_norm = np.linalg.norm(v0_unnormalized)\n        v0_normalized = v0_unnormalized / v0_norm\n\n        # 2. Get operator and true spectral radius\n        A_op = case[\"A_op_factory\"](n, params)\n        true_rho = case[\"true_rho\"](params)\n        \n        # 3. Run Arnoldi iteration\n        H_m = arnoldi_iteration(A_op, v0_normalized, m)\n        \n        # 4. Compute Ritz estimate and error\n        if H_m.shape[0] > 0:\n            ritz_values = np.linalg.eigvals(H_m)\n            ritz_rho = np.max(np.abs(ritz_values))\n        else: # This case happens if m=0 or breakdown with j=0\n            ritz_rho = 0.0\n\n        error = abs(ritz_rho - true_rho)\n        results.append(f\"{error:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2373518"}, {"introduction": "掌握了 Arnoldi 迭代的基本实现后，我们来探讨一个更深层次的挑战：非正规矩阵。对于这类矩阵，其矩阵幂的范数 $\\|A^k\\|_2$ 可能会在最终衰减之前经历显著的瞬时增长，这种行为与 Arnoldi 迭代的收敛性能密切相关。在本练习中，你将亲手构造非正规度可调的矩阵，并量化其瞬时增长行为与 Arnoldi 迭代收敛速度之间的关系。这个实践将帮助你深入理解，为何仅仅观察谱半径 $\\rho(A)$ 不足以预测迭代方法的表现，并学会从矩阵的非正规性这一更深层面的性质来分析算法的收敛性 [@problem_id:2373528]。", "problem": "您必须编写一个完整且可运行的程序，构建特定的非对称矩阵，其幂在最终衰减之前会表现出显著的瞬态增长。然后，程序需要量化此行为与 Arnoldi 迭代（用于近似主导特征值的大小）收敛性之间的关联。您的程序必须显式地实现 Arnoldi 过程，不得调用任何用于 Krylov 方法的内置特征求解器。所有计算均为纯数学计算，不涉及任何物理单位或角度。\n\n从以下基本定义开始：\n- 一个方阵 $A \\in \\mathbb{C}^{n \\times n}$ 的谱半径为 $\\rho(A) \\equiv \\max \\{ |\\lambda| : \\lambda \\text{ 是 } A \\text{ 的一个特征值} \\}$。\n- 谱范数是 $\\|A\\|_2 \\equiv \\sigma_{\\max}(A)$，即 $A$ 的最大奇异值。\n- 如果 $A^\\ast A \\neq A A^\\ast$，则矩阵 $A$ 是非正规的，其中 $A^\\ast$ 表示共轭转置。\n- 由 $A$ 和一个非零向量 $b$ 生成的 $m$ 步 Krylov 子空间是 $\\mathcal{K}_m(A,b) \\equiv \\text{span}\\{ b, Ab, A^2 b, \\dots, A^{m-1} b \\}$。\n- Arnoldi 迭代构造 $\\mathcal{K}_m(A,b)$ 的一个标准正交基 $V_m$ 和一个上 Hessenberg 矩阵 $H_m \\in \\mathbb{C}^{m \\times m}$，使得在最小二乘意义上 $A V_m \\approx V_m H_m$。$H_m$ 的特征值被称为 Ritz 值，用于近似 $A$ 的特征值。\n\n通过相似变换 $A = V \\Lambda V^{-1}$ 来构造测试矩阵，其中特征值是预设的，并带有一个可调的非正规性参数。设 $n \\in \\mathbb{N}$，并通过以下公式定义实特征值 $\\{\\lambda_i\\}_{i=1}^n$：\n$$\n\\lambda_i \\equiv 0.95 - 0.75 \\cdot \\frac{i-1}{n-1}, \\quad i = 1,2,\\dots,n,\n$$\n因此 $\\rho(A) = \\max_i |\\lambda_i| = 0.95  1$。为构造 $V$，首先通过对一个具有固定种子的随机高斯矩阵进行瘦 QR 分解来形成一个正交矩阵 $Q$，然后用一个由 $\\gamma  0$ 控制的几何级数来缩放其列：\n$$\nV \\equiv Q D_\\gamma, \\quad D_\\gamma \\equiv \\mathrm{diag}\\big(\\gamma^{0}, \\gamma^{1}, \\dots, \\gamma^{n-1}\\big).\n$$\n当 $\\gamma = 1$ 时，$V$ 是正交的，$A$ 是正规的；当 $\\gamma  1$ 时，$V$ 是病态的，且 $A$ 变得越来越非正规。\n\n对于下面测试套件中的每个测试矩阵 $A$，计算两个量：\n1. 瞬态增长因子\n$$\nG \\equiv \\max_{1 \\le k \\le K_{\\max}} \\frac{\\|A^k\\|_2}{\\rho(A)^k}.\n$$\n该值衡量了相对于渐近衰减率 $\\rho(A)^k$ 的最坏情况放大倍数。因为所有 $\\lambda_i$ 都满足 $|\\lambda_i|  1$，$\\|A^k\\|_2$ 最终会随 $k$ 的增加而衰减，但对于非正规矩阵 $A$，它可能在 $k$ 取值适中时显著增长。\n2. Arnoldi 收敛指数 $m_\\ast$，定义为满足以下条件的最小 $m \\in \\{1,2,\\dots,m_{\\max}\\}$：$H_m$ 的模最大的 Ritz 值（记为 $\\lambda_{\\text{Ritz}}^{(m)}$）满足\n$$\n\\left|\\,|\\lambda_{\\text{Ritz}}^{(m)}| - \\rho(A)\\,\\right| \\le \\varepsilon.\n$$\n如果在 $m_{\\max}$ 之内不存在这样的 $m$，或者如果 Arnoldi 过程在达到 $m_{\\max}$ 之前崩溃，则设 $m_\\ast \\equiv -1$。\n\n使用修正的 Gram–Schmidt 正交化实现 Arnoldi 迭代。使用一个固定的起始向量 $b$，该向量从标准正态分布中抽取，然后归一化为单位欧几里得范数。\n\n测试套件（四个标量和一个向量完全指定了所有情况）：\n- 矩阵大小：$n = 20$。\n- 特征值：如上定义的 $\\lambda_i$。\n- 随机种子：对于 $Q$，使用种子 $12345$；对于 $b$，使用种子 $54321$。\n- 增长范围：$K_{\\max} = 60$。\n- Arnoldi 限制与容差：$m_{\\max} = 20$，$\\varepsilon = 10^{-6}$。\n- 非正规性参数：$\\gamma \\in \\{1.0, 1.5, 2.5\\}$。\n\n您的程序必须产生单行输出，其中包含一个列表，每个测试用例对应一个条目，顺序与所列 $\\gamma$ 值相同。每个条目本身必须是一个双元素列表 $[G_{\\mathrm{rounded}}, m_\\ast]$，其中 $G_{\\mathrm{rounded}}$ 是 $G$ 四舍五入到小数点后三位的结果，$m_\\ast$ 是如上定义的整数。因此，最终打印的行必须具有以下形式：\n$$\n\\big[ [G_1, m_{\\ast,1}], [G_2, m_{\\ast,2}], [G_3, m_{\\ast,3}] \\big],\n$$\n没有额外的空白字符，也没有附加的文本。", "solution": "矩阵幂出现瞬态增长的根本机制是非正规性。如果一个矩阵 $A$ 可通过酉（实数情况下为正交）相似变换对角化，那么对于所有 $k$，都有 $\\|A^k\\|_2 = \\rho(A)^k$，因为谱范数在酉相似下不变，且正规矩阵的谱范数等于其特征值中的最大模。因此，对于所有特征值严格位于单位圆盘内部的正规矩阵 $A$，$\\|A^k\\|_2$ 会随着 $k$ 的增加而单调衰减。\n\n然而，如果 $A$ 是非正规的，那么在由 $\\rho(A)^k$ 决定的最终衰减发生之前，$\\|A^k\\|_2$ 可能在 $k$ 取值适中时表现出显著增长。最简单的分析示例是使用一个 Jordan 块。考虑 $A = \\alpha I + N$，其中 $\\alpha \\in \\mathbb{C}$ 满足 $|\\alpha|  1$，$N$ 是一个严格上三角矩阵，其第一条超对角线上为一，其他位置为零，因此 $N$ 是幂零的。使用二项式恒等式，\n$$\nA^k = (\\alpha I + N)^k = \\sum_{j=0}^{k} \\binom{k}{j} \\alpha^{k-j} N^j,\n$$\n并注意到当 $j$ 小于等于矩阵大小时，$N^j$ 在第 $j$ 条超对角线上为一，可以看到 $\\|A^k\\|_2$ 包含量级为 $\\binom{k}{j} |\\alpha|^{k-j}$ 的项。由于多项式因子的存在，这些项在 $|\\alpha|^k$ 的几何衰减占主导地位之前会随 $k$ 初始增长。这会产生一个瞬态增长，其峰值大致与 $k$ 的多项式乘以 $|\\alpha|^k$ 成比例，当 $|\\alpha|$ 接近 $1$ 时，在大致为 $1/(-\\log|\\alpha|)$ 的某个适中 $k$ 值处达到最大值。\n\n在计算实践中，精确的 Jordan 块很罕见；相反，当一个可对角化矩阵在分解 $A = V \\Lambda V^{-1}$ 中有一个病态的特征向量矩阵 $V$ 时，就会出现强烈的非正规性。在这种情况下，$A$ 的伪谱很大，范数 $\\|A^k\\|_2$ 可能瞬态增长。一种实用的参数化方法是设 $V = Q D_\\gamma$，其中 $Q$ 是通过对一个高斯随机矩阵进行瘦 QR 分解得到的正交矩阵，而 $D_\\gamma = \\mathrm{diag}(\\gamma^0,\\gamma^1,\\dots,\\gamma^{n-1})$。当 $\\gamma = 1$ 时，$V$ 是正交的，$A$ 是正规的。当 $\\gamma  1$ 时，$V$ 变得越来越病态，$A$ 在保持相同特征值的同时也变得越来越非正规。\n\n现在我们将此与 Arnoldi 迭代联系起来。Arnoldi 过程通过对 $b$ 重复应用 $A$ 并进行 Gram-Schmidt 正交化，为 Krylov 子空间 $\\mathcal{K}_m(A,b)$ 构建一个标准正交基 $V_m$。该过程产生一个 $m \\times m$ 的上 Hessenberg 矩阵 $H_m = V_m^\\ast A V_m$，其特征值（Ritz 值）近似于 $A$ 的特征值。由模最大的 Ritz 值对主导特征值大小 $\\rho(A)$ 的近似通常随着 $m$ 的增加而改善。然而，对于非正规矩阵，Krylov 子空间在初始阶段可能由与瞬态增长相关的方向主导，而不是渐近的特征向量对齐方向，这导致 Ritz 值向真实谱半径的收敛速度变慢。因此，我们预期存在一种关联：更大的瞬态增长因子 $G \\equiv \\max_{1 \\le k \\le K_{\\max}} \\|A^k\\|_2 / \\rho(A)^k$ 往往与 Arnoldi 迭代在容差范围内近似 $\\rho(A)$ 所需的更大最小 $m$ 值相关。\n\n程序中的算法设计直接遵循以下原则：\n1.  对测试套件，固定 $n$、特征值 $\\{\\lambda_i\\}$、用于可复现性的种子以及非正规性参数 $\\gamma$。从使用指定种子生成的高斯矩阵的瘦 QR 分解中构建 $Q$。对于每个 $\\gamma$，形成 $V = Q D_\\gamma$ 并计算 $A = V \\Lambda V^{-1}$。这样，$A$ 的特征值就精确为 $\\{\\lambda_i\\}$，因此谱半径 $\\rho(A) = \\max_i |\\lambda_i|$ 在我们的构造中等于 $0.95$。\n2.  通过重复乘法对 $k = 1, 2, \\dots, K_{\\max}$ 迭代计算 $A^k$ 来计算瞬态增长因子 $G$，将 $\\|A^k\\|_2$ 评估为最大奇异值（即谱范数），并记录 $\\max_k \\|A^k\\|_2 / \\rho(A)^k$。由于 $\\rho(A)  1$，$\\|A^k\\|_2$ 最终会衰减，因此当 $A$ 非正规时，最大值会在一个中等大小的 $k$ 处达到。\n3.  用修正的 Gram-Schmidt 方法实现 Arnoldi 过程，以生成 $V_m$ 和 $H_m$，直至 $m_{\\max}$。在每个 $m$ 步，计算 $H_m$ 的特征值作为 Ritz 值，并选择模最大的一个。找到最小的 $m$，使得该模与 $\\rho(A)$ 之间的绝对误差小于或等于容差 $\\varepsilon$。如果找不到这样的 $m$，或者如果在达到 $m_{\\max}$ 之前发生崩溃，则报告 $m_\\ast = -1$。\n4.  汇总所有指定 $\\gamma$ 值的结​​果。当 $\\gamma = 1$（正规情况）时，瞬态增长因子 $G$ 应接近 $1$，Arnoldi 收敛指数 $m_\\ast$ 应相对较小。随着 $\\gamma$ 的增加，$G$ 通常会增长到 $1$ 以上，$m_\\ast$ 也趋于增加，这反映了非正规性对 Arnoldi 收敛的影响。\n\n最后，程序打印单行结果列表，格式完全符合要求：一个包含三个双元素列表 $[G_{\\mathrm{rounded}}, m_\\ast]$ 的列表，按测试套件中 $\\gamma$ 值的顺序排列。", "answer": "```python\nimport numpy as np\n\ndef build_Q_from_seed(n: int, seed: int) - np.ndarray:\n    rng = np.random.default_rng(seed)\n    X = rng.standard_normal((n, n))\n    Q, _ = np.linalg.qr(X)  # Thin QR; Q is orthonormal\n    return Q\n\ndef build_V(Q: np.ndarray, gamma: float) - np.ndarray:\n    n = Q.shape[0]\n    scales = gamma ** np.arange(n, dtype=float)\n    D = np.diag(scales)\n    return Q @ D\n\ndef build_A_from_V_lambda(V: np.ndarray, lambdas: np.ndarray) - np.ndarray:\n    # A = V * diag(lambdas) * V^{-1}\n    n = V.shape[0]\n    Vinv = np.linalg.inv(V)\n    return V @ np.diag(lambdas) @ Vinv\n\ndef spectral_radius(lambdas: np.ndarray) - float:\n    return float(np.max(np.abs(lambdas)))\n\ndef spectral_norm(A: np.ndarray) - float:\n    # 2-norm via largest singular value\n    # Use SVD with no vectors for stability on small n\n    s = np.linalg.svd(A, compute_uv=False)\n    return float(s[0])\n\ndef transient_growth_factor(A: np.ndarray, rho: float, Kmax: int) - float:\n    n = A.shape[0]\n    Apow = np.eye(n)\n    max_ratio = 0.0\n    for k in range(1, Kmax + 1):\n        Apow = Apow @ A\n        norm_Ak = spectral_norm(Apow)\n        denom = rho ** k\n        # Avoid division by extremely small numbers; rho^k  0 since rho0; here rho=0.950.\n        ratio = norm_Ak / denom if denom != 0.0 else np.inf\n        if ratio  max_ratio:\n            max_ratio = ratio\n    return max_ratio\n\ndef arnoldi_modified_gram_schmidt(A: np.ndarray, b: np.ndarray, m_max: int):\n    n = A.shape[0]\n    V = np.zeros((n, m_max + 1))\n    H = np.zeros((m_max + 1, m_max))\n    beta = np.linalg.norm(b)\n    if beta == 0.0:\n        raise ValueError(\"Starting vector b must be nonzero.\")\n    V[:, 0] = b / beta\n    m_effective = 0\n    for j in range(m_max):\n        w = A @ V[:, j]\n        # Modified Gram-Schmidt\n        for i in range(j + 1):\n            H[i, j] = np.dot(V[:, i].conj(), w)\n            w = w - H[i, j] * V[:, i]\n        # Optional one-step reorthogonalization for numerical stability\n        for i in range(j + 1):\n            h_correction = np.dot(V[:, i].conj(), w)\n            H[i, j] += h_correction\n            w = w - h_correction * V[:, i]\n        h_next = np.linalg.norm(w)\n        H[j + 1, j] = h_next\n        m_effective = j + 1\n        if h_next = 1e-14:\n            # Happy breakdown: Krylov subspace is invariant; stop early\n            break\n        V[:, j + 1] = w / h_next\n    return V[:, :m_effective + 1], H[:m_effective + 1, :m_effective]\n\ndef arnoldi_convergence_index(A: np.ndarray, b: np.ndarray, rho: float, m_max: int, tol: float) - int:\n    V, H_full = arnoldi_modified_gram_schmidt(A, b, m_max)\n    # H_full has shape (m_eff+1, m_eff); number of completed Arnoldi steps is m_eff\n    m_eff = H_full.shape[1]\n    m_star = -1\n    for m in range(1, m_eff + 1):\n        Hm = H_full[:m, :m]\n        ritz = np.linalg.eigvals(Hm)\n        # Choose Ritz value with largest modulus\n        idx = int(np.argmax(np.abs(ritz)))\n        ritz_max = ritz[idx]\n        err = abs(abs(ritz_max) - rho)\n        if err = tol:\n            m_star = m\n            break\n    # If we didn't reach m_max due to breakdown and no convergence, return -1\n    if m_star == -1 and m_eff  m_max:\n        return -1\n    # If we reached m_max and still no convergence, also return -1\n    return m_star\n\ndef solve():\n    # Test suite parameters\n    n = 20\n    # Define eigenvalues: lambda_i = 0.95 - 0.75 * (i-1)/(n-1), i=1..n\n    lam = np.array([0.95 - 0.75 * (i) / (n - 1) for i in range(0, n)], dtype=float)\n    rho = spectral_radius(lam)\n    seed_Q = 12345\n    seed_b = 54321\n    Kmax = 60\n    m_max = 20\n    tol = 1e-6\n    gammas = [1.0, 1.5, 2.5]\n\n    # Build Q and starting vector b\n    Q = build_Q_from_seed(n, seed_Q)\n    rng_b = np.random.default_rng(seed_b)\n    b = rng_b.standard_normal(n)\n    b_norm = np.linalg.norm(b)\n    if b_norm == 0.0:\n        b[0] = 1.0\n        b_norm = 1.0\n    b = b / b_norm\n\n    results = []\n    for gamma in gammas:\n        V = build_V(Q, gamma)\n        A = build_A_from_V_lambda(V, lam)\n        G = transient_growth_factor(A, rho, Kmax)\n        m_star = arnoldi_convergence_index(A, b, rho, m_max, tol)\n        # Round G to three decimals\n        G_round = round(G + 1e-12, 3)  # small epsilon to stabilize rounding\n        results.append([G_round, m_star])\n\n    # Print in exact required format: no spaces\n    out = \"[\" + \",\".join(f\"[{res[0]},{res[1]}]\" for res in results) + \"]\"\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2373528"}, {"introduction": "在实际应用中，我们往往需要的不仅仅是最大的一个特征值，而是多个具有最大模的特征对。然而，一个简单的重启 Arnoldi 算法会反复收敛到同一个主导特征对，效率低下。本练习将向你介绍一种高级且实用的技术：“锁定与放缩”（locking and deflation）。你将通过在一个重启的 Arnoldi 框架中实现该机制，强制算法在已收敛的特征向量构成的子空间的正交补空间中进行搜索，从而高效地逐个“解锁”新的特征对。通过这个实践，你将从基础实现迈向构建一个更接近于工业级科学计算库（如 ARPACK）的、功能更强大的特征值求解器 [@problem_id:2373565]。", "problem": "实现一个完整且可运行的程序，比较两种近似给定实非对称矩阵最大模特征对的方法：一种方法维护一个已收敛的近似特征向量集合，并强制与该集合正交（带锁定的降维）；另一种方法在重启过程中不维护这样的锁定集。目标是量化锁定机制如何在获得指定数量的主特征对时，减少所需的矩阵-向量乘积次数。您的程序必须是确定性的，且不得读取输入。\n\n您需遵循以下规范。\n\n1) 数学设定。\n\n- 设 $A \\in \\mathbb{R}^{n \\times n}$ 为一个实非对称矩阵。对于任意非零向量 $u \\in \\mathbb{C}^{n}$ 及标量 $\\theta \\in \\mathbb{C}$，一个近似特征对 $(\\theta,u)$ 的残差定义为 $r \\equiv A u - \\theta u$。残差范数为 $\\lVert r \\rVert_{2}$。\n- 对于一个满足 $\\lVert u \\rVert_{2} = 1$ 的对 $(\\theta,u)$，如果 $\\lVert A u - \\theta u \\rVert_{2} \\le \\varepsilon$（其中 $\\varepsilon$ 是给定的容差），则认为其已收敛。\n- 主特征对是指其特征值的绝对值相对于其余特征值而言是最大的。对于一个给定的数量 $k \\in \\mathbb{N}$，目标集合是与 $k$ 个最大绝对值特征值相对应的 $k$ 个特征对（数值相等时可任意选择）。\n\n2) 带与不带锁定的子空间构造。\n\n- 在迭代过程中，通过对一个初始向量重复应用 $A$ 来构造维度至多为 $m \\in \\mathbb{N}$ 的克雷洛夫子空间。每次将 $A$ 应用于一个向量计为一次矩阵-向量乘积。当一个维度至多为 $m$ 的子空间构建并处理完毕后，您可以通过丢弃该子空间并从一个新的初始向量开始来重启。这定义了一个周期。您可以执行多个周期，直到所要求的 $k$ 个主特征对收敛为止。\n- 带锁定的降维：维护一个当前已收敛的单位范数近似特征向量集合 $\\mathcal{L}$。在任何时候，确保用于扩展子空间的任何新生成向量 $w$ 对所有 $u \\in \\mathcal{L}$ 都满足 $u^{*} w = 0$（关于标准复内积正交），即将 $w$ 投影到 $\\mathrm{span}(\\mathcal{L})$ 的正交补上。当新的近似特征对收敛时，将其向量（经过标准正交化后）附加到 $\\mathcal{L}$ 中。持续此过程直到 $|\\mathcal{L}| = k$。\n- 不带锁定：在不同周期之间不维护任何 $\\mathcal{L}$。在每个周期中，识别当前子空间内收敛的近似特征对；跨周期累积它们的特征值，形成一个唯一值的集合（在绝对差小于一个小的阈值时视为相同），直到收集到 $k$ 个唯一的收敛特征值。在构造新子空间时，不对先前发现的向量进行降维。\n\n3) 子空间内的收敛性评估。\n\n- 在任何维度为 $j \\le m$ 且具有标准正交基 $V_{j} \\in \\mathbb{C}^{n \\times j}$ 的子空间中，构造一个投影矩阵 $H_{j} \\in \\mathbb{C}^{j \\times j}$，并计算其特征对 $(\\theta, y)$，其中 $y \\in \\mathbb{C}^{j}$。对于每个这样的对，构造里兹向量 $u = V_{j} y / \\lVert V_{j} y \\rVert_{2}$ 和残差范数 $\\lVert A u - \\theta u \\rVert_{2}$。使用这些残差范数和容差 $\\varepsilon$ 来判断收敛性。\n- 在任何周期内，当识别要记录（在锁定变体中为锁定）哪些已收敛的近似特征对时，优先选择与最大绝对值 $|\\theta|$ 相关联的那些，并通过将特征值的绝对差与一个小的阈值进行比较来避免计数或锁定重复项。\n\n4) 测试套件。\n\n对于每个测试用例，构造 $A$ 为 $A = S D S^{-1}$，其中 $D$ 是具有指定对角元素的对角矩阵，$S$ 是一个稠密的实矩阵，通过使用固定的种子伪随机生成，其元素在区间 $[-1,1]$ 上均匀抽取，直到获得一个可逆的 $S$。周期的所有初始向量也使用该用例的相同种子规范进行伪随机抽取，并且在锁定激活时，会被投影以与锁定集正交。所有随机抽取必须是可复现的。\n\n测试套件包含三个用例：\n\n- 用例1（理想情况）：$n = 8$, $D = [5.0, 3.0, 2.0, 1.0, 0.5, -0.2, -1.5, 4.0]$, $k = 3$, $m = 4$, $\\varepsilon = 10^{-8}$, 最大周期数 $C_{\\max} = 200$, 随机种子 $10$。\n- 用例2（相近的特征值）：$n = 10$, $D = [4.0, 3.99, 1.0, 0.1, -0.1, 2.0, -2.0, 0.5, 0.49, -3.0]$, $k = 3$, $m = 5$, $\\varepsilon = 10^{-8}$, $C_{\\max} = 200$, 随机种子 $21$。\n- 用例3（单一主导特征值，小子空间）：$n = 6$, $D = [-5.0, -1.0, -2.0, 0.1, 0.2, 0.3]$, $k = 1$, $m = 2$, $\\varepsilon = 10^{-8}$, $C_{\\max} = 200$, 随机种子 $7$。\n\n以上所有数字都是无量纲的。将任何绝对差和容差表示为实数。\n\n5) 所需输出。\n\n- 对于每个用例，运行两种方法，直到所要求的 $k$ 个主特征对根据准则 $\\lVert A u - \\theta u \\rVert_{2} \\le \\varepsilon$ 收敛，或直到达到周期上限 $C_{\\max}$。分别对不带锁定和带锁定的方法，将矩阵-向量乘积计数为跨周期子空间扩展期间发生的 $A$ 应用于向量的总次数。\n- 如果在任一方法中达到 $C_{\\max}$ 仍未满足收敛目标，则返回该方法到目前为止累积的矩阵-向量乘积次数。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个用例，输出一个双元素列表 $[M_{\\mathrm{no\\_lock}}, M_{\\mathrm{lock}}]$，其中整数分别表示不带锁定和带锁定方法的矩阵-向量乘积计数。最终格式必须是类似 $[[a,b],[c,d],[e,f]]$ 的单行，其中 $a,b,c,d,e,f$ 为整数。", "solution": "所述问题是有效的。它提出了一个在数值线性代数领域内陈述清晰、有科学依据的任务，该领域是计算物理学的基石。该问题要求对一种用于寻找非对称矩阵主特征对的重启克雷洛夫子空间方法的两种标准变体进行经验性比较。所有参数和过程的规定都足够清晰和客观，从而能够得出一个唯一且可验证的解。\n\n任务的核心是为一个给定的实非对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，近似求解指定数量 $k$ 的、与最大模特征值 $\\lambda$ 对应的特征对 $(\\lambda, u)$。基本方程是 $A u = \\lambda u$。所提出的方法是一种重启的克雷洛夫子空间迭代，它是阿诺德方法（Arnoldi method）的一个实际实现。\n\n我们首先将算法的公共组成部分形式化。该方法生成一系列克雷洛夫子空间 $\\mathcal{K}_j(A, v_1) = \\mathrm{span}\\{v_1, Av_1, \\dots, A^{j-1}v_1\\}$，其中 $v_1$ 是一个起始向量，满足 $\\lVert v_1 \\rVert_2 = 1$。阿诺德过程为 $\\mathcal{K}_j(A, v_1)$ 构建一个标准正交基 $V_j = [v_1, v_2, \\dots, v_j]$。该过程同时生成一个上Hessenberg矩阵 $H_j = V_j^* A V_j \\in \\mathbb{C}^{j \\times j}$，其中星号表示共轭转置。经过 $m$ 步后的关键阿诺德关系式为：\n$$\nA V_m = V_m H_m + h_{m+1,m} v_{m+1} e_m^T\n$$\n其中 $V_m \\in \\mathbb{C}^{n \\times m}$ 具有标准正交列，$H_m \\in \\mathbb{C}^{m \\times m}$ 是上Hessenberg矩阵，$v_{m+1}$ 是一个与 $V_m$ 的列正交的单位向量，$h_{m+1,m}$ 是一个非负标量，而 $e_m$ 是 $\\mathbb{R}^m$ 中的第 $m$ 个标准基向量。$V_m$ 的每一列都需要与 $A$ 进行一次矩阵-向量乘积，这是计算成本的主要衡量标准。\n\n从小型的 $m \\times m$ 特征问题 $H_m y_i = \\theta_i y_i$ 中，我们提取 $A$ 的近似特征对。这些被称为里兹对（Ritz pairs） $(\\theta_i, u_i)$，其中 $\\theta_i$ 是里兹值（Ritz value），而 $u_i = V_m y_i$ 是相应的里兹向量（Ritz vector）。问题要求通过检查残差范数 $\\lVert A u_i - \\theta_i u_i \\rVert_2 \\le \\varepsilon$ (其中 $\\varepsilon$ 为给定容差) 来评估收敛性。利用阿诺德关系式，可以高效地计算这个范数，而无需额外的矩阵-向量乘积：\n$$\n\\begin{aligned}\nA u_i - \\theta_i u_i = A(V_m y_i) - \\theta_i(V_m y_i) \\\\\n= (AV_m) y_i - V_m(\\theta_i y_i) \\\\\n= (V_m H_m + h_{m+1,m} v_{m+1} e_m^T) y_i - V_m(H_m y_i) \\\\\n= V_m H_m y_i + h_{m+1,m} v_{m+1} (e_m^T y_i) - V_m H_m y_i \\\\\n= (h_{m+1,m} \\cdot (y_i)_m) v_{m+1}\n\\end{aligned}\n$$\n其中 $(y_i)_m$ 是特征向量 $y_i$ 的最后一个分量。由于 $\\lVert v_{m+1} \\rVert_2 = 1$，残差范数恰好是 $\\lVert A u_i - \\theta_i u_i \\rVert_2 = |h_{m+1,m}| \\cdot |(y_i)_m|$。\n\n在构建一个维度为 $m$ 的子空间后（一个周期），该过程会重启。两种方法在如何利用前几个周期的信息上有所不同。\n\n1.  **不带锁定的方法：** 这是一个更简单的策略。每个周期都是独立的。它从一个新的、随机生成的向量 $v_1$ 开始。在一个周期内，它会识别所有收敛的里兹对。相应的里兹值 $\\theta_i$ 被收集起来。为避免重复，一个新发现的 $\\theta_i$ 只有在与所有先前找到的值足够不同时，才被添加到收敛特征值集合中，即对于集合中所有的 $\\theta_{found}$，满足 $|\\theta_i - \\theta_{found}| \\ge \\delta$，其中 $\\delta$ 是一个小的唯一性容差。当找到 $k$ 个唯一的特征值或达到最大周期数 $C_{\\max}$ 时，过程终止。这种方法可能会在连续的周期中反复找到相同的主特征对，这可能效率低下。\n\n2.  **带锁定与降维的方法：** 此方法旨在通过防止重复计算已收敛的特征对来提高效率。它维护一个由先前已收敛并“锁定”的特征向量组成的显式标准正交集 $\\mathcal{L} = \\{u_1, \\dots, u_p\\}$，其中 $p  k$。在新周期开始时，初始向量 $v_1$ 是随机生成的，然后对由 $\\mathcal{L}$ 张成的空间进行显式正交化：$v_1 \\leftarrow v_1 - \\sum_{i=1}^p (u_i^* v_1) u_i$。然后，阿诺德迭代在与 $\\mathrm{span}(\\mathcal{L})$ 正交的子空间中进行，从而有效地从问题中“降维”掉已知的特征向量。当新的里兹对收敛时，它们的里兹向量成为被锁定的候选对象。为保持 $\\mathcal{L}$ 的性质，新的候选向量 $u_{new}$ 首先与当前集合 $\\mathcal{L}$ 正交化，然后归一化后再添加。这确保了算法将其搜索集中在谱的未覆盖部分。此过程持续进行，直到 $|\\mathcal{L}| = k$。\n\n对于这两种方法，测试矩阵都构造为 $A = S D S^{-1}$，其中 $D$ 是具有指定特征值的对角矩阵，$S$ 是一个随机生成的、可逆的实矩阵。整个过程，包括矩阵生成和起始向量的选择，都通过使用固定种子的伪随机数生成器来实现确定性。为了进行公平比较，每次运行时都重新初始化生成器，以确保两种算法都使用相同的随机数序列来执行。", "answer": "```python\nimport numpy as np\n\ndef arnoldi_iteration(A, v_start, m, locked_vectors):\n    \"\"\"\n    Performs m steps of the Arnoldi iteration to build a Krylov subspace.\n    Handles explicit deflation against locked vectors.\n    \"\"\"\n    n = A.shape[0]\n    V = np.zeros((n, m + 1), dtype=np.complex128)\n    H = np.zeros((m + 1, m), dtype=np.complex128)\n    \n    mat_vec_count = 0\n    \n    # Start vector processing\n    v = v_start\n    if locked_vectors.shape[1]  0:\n        v = v - locked_vectors @ (locked_vectors.conj().T @ v)\n    \n    v_norm = np.linalg.norm(v)\n    if v_norm  1e-12:\n        return None, None, None, mat_vec_count, 0 # Start vector is in locked space\n\n    V[:, 0] = v / v_norm\n    \n    actual_m = m\n    for j in range(m):\n        # Apply operator and count\n        w = A @ V[:, j]\n        mat_vec_count += 1\n        \n        # Deflate against locked vectors\n        if locked_vectors.shape[1]  0:\n            w = w - locked_vectors @ (locked_vectors.conj().T @ w)\n            \n        # Modified Gram-Schmidt against current Krylov basis V\n        for i in range(j + 1):\n            H[i, j] = V[:, i].conj().T @ w\n            w = w - H[i, j] * V[:, i]\n            \n        H[j + 1, j] = np.linalg.norm(w)\n        \n        if H[j + 1, j]  1e-12:  # Breakdown\n            actual_m = j + 1\n            break\n            \n        V[:, j + 1] = w / H[j + 1, j]\n        \n    return V[:, :actual_m], H[:actual_m, :actual_m], H[actual_m, actual_m - 1], mat_vec_count, actual_m\n\ndef run_without_locking(A, k, m, tol, max_cycles, rng):\n    \"\"\"\n    Runs restarted Arnoldi without locking/deflation.\n    \"\"\"\n    n = A.shape[0]\n    total_mat_vecs = 0\n    found_eigenvalues = set()\n    \n    for _ in range(max_cycles):\n        if len(found_eigenvalues) = k:\n            break\n            \n        v_start = rng.random(n)\n        \n        # We pass an empty locked_vectors set, so no deflation occurs.\n        V, H, h_next, mv_cycle, actual_m = arnoldi_iteration(\n            A, v_start, m, np.zeros((n, 0))\n        )\n        \n        total_mat_vecs += mv_cycle\n        if V is None or actual_m == 0:\n            continue\n            \n        ritz_vals, ritz_vecs_H = np.linalg.eig(H)\n        \n        converged_pairs = []\n        for theta, y in zip(ritz_vals, ritz_vecs_H.T):\n            residual_norm = abs(h_next) * abs(y[-1])\n            if residual_norm  tol:\n                converged_pairs.append(theta)\n\n        # Prioritize by magnitude and add unique values\n        converged_pairs.sort(key=abs, reverse=True)\n        for theta in converged_pairs:\n            is_new = True\n            for found_val in found_eigenvalues:\n                if abs(theta - found_val)  1e-6:\n                    is_new = False\n                    break\n            if is_new and len(found_eigenvalues)  k:\n                found_eigenvalues.add(theta)\n                \n    return total_mat_vecs\n\ndef run_with_locking(A, k, m, tol, max_cycles, rng):\n    \"\"\"\n    Runs restarted Arnoldi with explicit locking and deflation.\n    \"\"\"\n    n = A.shape[0]\n    total_mat_vecs = 0\n    locked_vectors = np.zeros((n, 0), dtype=np.complex128)\n    locked_eigenvalues = []\n\n    for _ in range(max_cycles):\n        if len(locked_eigenvalues) = k:\n            break\n\n        v_start = rng.random(n)\n        \n        V, H, h_next, mv_cycle, actual_m = arnoldi_iteration(\n            A, v_start, m, locked_vectors\n        )\n        \n        total_mat_vecs += mv_cycle\n        if V is None or actual_m == 0:\n            continue\n\n        ritz_vals, ritz_vecs_H = np.linalg.eig(H)\n\n        newly_converged = []\n        for theta, y in zip(ritz_vals, ritz_vecs_H.T):\n            residual_norm = abs(h_next) * abs(y[-1])\n            is_new = True\n            for locked_val in locked_eigenvalues:\n                if abs(theta - locked_val)  1e-6:\n                    is_new = False\n                    break\n            if is_new and residual_norm  tol:\n                u = V @ y\n                newly_converged.append({'val': theta, 'vec': u / np.linalg.norm(u)})\n        \n        # Sort candidates by magnitude before attempting to lock\n        newly_converged.sort(key=lambda p: abs(p['val']), reverse=True)\n\n        for p in newly_converged:\n            if len(locked_eigenvalues) = k:\n                break\n            \n            u_candidate = p['vec']\n            # Deflate candidate against current locked set\n            u_proj = u_candidate - locked_vectors @ (locked_vectors.conj().T @ u_candidate)\n            \n            # If it's not in the span of locked vectors, add it.\n            if np.linalg.norm(u_proj)  1e-6:\n                u_ortho = (u_proj / np.linalg.norm(u_proj)).reshape(-1, 1)\n                locked_vectors = np.hstack([locked_vectors, u_ortho])\n                locked_eigenvalues.append(p['val'])\n                \n    return total_mat_vecs\n\ndef run_case(n, d_diag, k, m, tol, max_cycles, seed):\n    \"\"\"\n    Sets up a test case and runs both algorithms.\n    \"\"\"\n    # Create the test matrix A = S D S^-1\n    # Use a separate RNG for matrix generation to not interfere with start vectors\n    rng_A = np.random.default_rng(seed)\n    while True:\n        S = rng_A.uniform(-1, 1, size=(n, n))\n        if np.linalg.cond(S)  1 / np.finfo(S.dtype).eps:\n            break\n    D = np.diag(d_diag)\n    A = S @ D @ np.linalg.inv(S)\n\n    # Run without locking. Create a new RNG seeded for this run.\n    rng_no_lock = np.random.default_rng(seed)\n    mat_vec_no_lock = run_without_locking(A, k, m, tol, max_cycles, rng_no_lock)\n    \n    # Run with locking. Create another new RNG with the same seed.\n    # This ensures both algorithms use the same sequence of random start vectors.\n    rng_lock = np.random.default_rng(seed)\n    mat_vec_lock = run_with_locking(A, k, m, tol, max_cycles, rng_lock)\n    \n    return [mat_vec_no_lock, mat_vec_lock]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (8, [5.0, 3.0, 2.0, 1.0, 0.5, -0.2, -1.5, 4.0], 3, 4, 1e-8, 200, 10),\n        (10, [4.0, 3.99, 1.0, 0.1, -0.1, 2.0, -2.0, 0.5, 0.49, -3.0], 3, 5, 1e-8, 200, 21),\n        (6, [-5.0, -1.0, -2.0, 0.1, 0.2, 0.3], 1, 2, 1e-8, 200, 7),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_pair = run_case(*params)\n        all_results.append(result_pair)\n\n    formatted_results = \",\".join([f\"[{r[0]},{r[1]}]\" for r in all_results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2373565"}]}