{"hands_on_practices": [{"introduction": "我们的第一个动手实践是一个重要的警示案例。虽然我们通常期望预处理器能够改善线性系统的属性，但这并非总是如此。通过为一个简单的非对称矩阵显式计算条件数的变化，您将深刻理解到预处理的有效性并非必然，而是取决于矩阵的具体性质和所选择的范数 [@problem_id:2429417]。这个练习强调了在应用数值技术时批判性思维的重要性。", "problem": "在许多计算物理应用中，例如稳态对流扩散算子的迎风离散，所得到的线性系统可能是非对称的，且对角元具有强烈的非均衡性。一个常见的对角（雅可比）预条件子用对角元的逆来缩放矩阵的行。尽管预处理通常旨在改善迭代求解器的收敛性，但它并不总能减小矩阵在 $2$-范数下的条件数。\n\n从核心定义开始：\n- 一个非奇异矩阵 $X$ 的矩阵 $2$-范数条件数是 $\\kappa_{2}(X) = \\sigma_{\\max}(X)/\\sigma_{\\min}(X)$，其中 $\\sigma_{\\max}(X)$ 和 $\\sigma_{\\min}(X)$ 分别是 $X$ 的最大和最小奇异值。\n- $X$ 的奇异值是 $X^{\\mathsf{T}}X$ 的特征值的平方根。\n- 雅可比预条件子 $P$ 是由 $A$ 的对角线元素构成的对角矩阵，而左预处理算子是 $P^{-1}A$。\n\n考虑以下显式的 $2 \\times 2$ 矩阵\n$$\nA = \\begin{pmatrix}\n1 & 10 \\\\\n0.19 & 2\n\\end{pmatrix},\n$$\n这是一个具有显著不同对角缩放的局部迎风输运算子的简单模型。令 $P = \\operatorname{diag}(A) = \\operatorname{diag}(1, 2)$ 为雅可比预条件子，并定义 $B = P^{-1} A$。\n\n仅使用上述定义（不得假设其他公式），计算比值\n$$\nR \\equiv \\frac{\\kappa_{2}(P^{-1}A)}{\\kappa_{2}(A)} = \\frac{\\kappa_{2}(B)}{\\kappa_{2}(A)}.\n$$\n报告 $R$ 的最终数值，并四舍五入到四位有效数字。答案是无量纲的；不应包含任何单位。", "solution": "该问题陈述已经过验证，并被认为是有效的。它在数值线性代数方面有科学依据，问题提法良好，提供了所有必要的信息，并且表述客观。不存在不一致、模糊或事实错误。我们按要求进行计算。\n\n任务是计算比值 $R = \\frac{\\kappa_{2}(B)}{\\kappa_{2}(A)}$，其中 $A = \\begin{pmatrix} 1 & 10 \\\\ 0.19 & 2 \\end{pmatrix}$ 且 $B = P^{-1}A$，而 $P = \\operatorname{diag}(A)$。计算将分两个阶段进行：首先针对矩阵 $A$，然后针对矩阵 $B$。\n\n首先，我们确定条件数 $\\kappa_2(A)$。根据所给定义，$A$ 的奇异值是 $A^{\\mathsf{T}}A$ 特征值的平方根。\n$A$ 的转置是 $A^{\\mathsf{T}} = \\begin{pmatrix} 1 & 0.19 \\\\ 10 & 2 \\end{pmatrix}$。\n我们计算乘积 $A^{\\mathsf{T}}A$：\n$$\nA^{\\mathsf{T}}A = \\begin{pmatrix} 1 & 0.19 \\\\ 10 & 2 \\end{pmatrix} \\begin{pmatrix} 1 & 10 \\\\ 0.19 & 2 \\end{pmatrix} = \\begin{pmatrix} 1^2 + 0.19^2 & 1 \\cdot 10 + 0.19 \\cdot 2 \\\\ 10 \\cdot 1 + 2 \\cdot 0.19 & 10^2 + 2^2 \\end{pmatrix} = \\begin{pmatrix} 1.0361 & 10.38 \\\\ 10.38 & 104 \\end{pmatrix}\n$$\n$A^{\\mathsf{T}}A$ 的特征值（记为 $\\lambda$）是特征方程 $\\det(A^{\\mathsf{T}}A - \\lambda I) = 0$ 的根：\n$$\n(1.0361 - \\lambda)(104 - \\lambda) - (10.38)^2 = 0\n$$\n$$\n\\lambda^2 - (1.0361 + 104)\\lambda + (1.0361 \\cdot 104 - 10.38^2) = 0\n$$\n$$\n\\lambda^2 - 105.0361\\lambda + (107.7544 - 107.7444) = 0\n$$\n$$\n\\lambda^2 - 105.0361\\lambda + 0.01 = 0\n$$\n使用二次方程求根公式，特征值为 $\\lambda = \\frac{105.0361 \\pm \\sqrt{105.0361^2 - 4(0.01)}}{2}$。\n两个特征值是 $\\lambda_{\\max, A} \\approx 105.0360048$ 和 $\\lambda_{\\min, A} \\approx 9.52054 \\times 10^{-5}$。\n$A$ 的奇异值为 $\\sigma_{\\max}(A) = \\sqrt{\\lambda_{\\max, A}}$ 和 $\\sigma_{\\min}(A) = \\sqrt{\\lambda_{\\min, A}}$。\n因此，$A$ 的条件数为：\n$$\n\\kappa_2(A) = \\frac{\\sigma_{\\max}(A)}{\\sigma_{\\min}(A)} = \\sqrt{\\frac{\\lambda_{\\max, A}}{\\lambda_{\\min, A}}} \\approx \\sqrt{\\frac{105.0360048}{9.52054 \\times 10^{-5}}} \\approx \\sqrt{1103256} \\approx 1050.36\n$$\n\n接下来，我们确定条件数 $\\kappa_2(B)$。预条件子是 $P = \\operatorname{diag}(A) = \\begin{pmatrix} 1 & 0 \\\\ 0 & 2 \\end{pmatrix}$。\n其逆矩阵是 $P^{-1} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 0.5 \\end{pmatrix}$。\n预处理后的矩阵 $B$ 是：\n$$\nB = P^{-1}A = \\begin{pmatrix} 1 & 0 \\\\ 0 & 0.5 \\end{pmatrix} \\begin{pmatrix} 1 & 10 \\\\ 0.19 & 2 \\end{pmatrix} = \\begin{pmatrix} 1 & 10 \\\\ 0.095 & 1 \\end{pmatrix}\n$$\n我们对 $B$ 采用相同的步骤。其转置是 $B^{\\mathsf{T}} = \\begin{pmatrix} 1 & 0.095 \\\\ 10 & 1 \\end{pmatrix}$。\n乘积 $B^{\\mathsf{T}}B$ 是：\n$$\nB^{\\mathsf{T}}B = \\begin{pmatrix} 1 & 0.095 \\\\ 10 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 10 \\\\ 0.095 & 1 \\end{pmatrix} = \\begin{pmatrix} 1^2 + 0.095^2 & 1 \\cdot 10 + 0.095 \\cdot 1 \\\\ 10 \\cdot 1 + 1 \\cdot 0.095 & 10^2 + 1^2 \\end{pmatrix} = \\begin{pmatrix} 1.009025 & 10.095 \\\\ 10.095 & 101 \\end{pmatrix}\n$$\n$B^{\\mathsf{T}}B$ 的特征值（记为 $\\mu$）是特征方程 $\\det(B^{\\mathsf{T}}B - \\mu I) = 0$ 的根：\n$$\n(1.009025 - \\mu)(101 - \\mu) - (10.095)^2 = 0\n$$\n$$\n\\mu^2 - (1.009025 + 101)\\mu + (1.009025 \\cdot 101 - 10.095^2) = 0\n$$\n$$\n\\mu^2 - 102.009025\\mu + (101.911525 - 101.909025) = 0\n$$\n$$\n\\mu^2 - 102.009025\\mu + 0.0025 = 0\n$$\n特征值为 $\\mu = \\frac{102.009025 \\pm \\sqrt{102.009025^2 - 4(0.0025)}}{2}$。\n两个特征值是 $\\mu_{\\max, B} \\approx 102.0090005$ 和 $\\mu_{\\min, B} \\approx 2.45075 \\times 10^{-5}$。\n$B$ 的条件数为：\n$$\n\\kappa_2(B) = \\frac{\\sigma_{\\max}(B)}{\\sigma_{\\min}(B)} = \\sqrt{\\frac{\\mu_{\\max, B}}{\\mu_{\\min, B}}} \\approx \\sqrt{\\frac{102.0090005}{2.45075 \\times 10^{-5}}} \\approx \\sqrt{4162166.5} \\approx 2040.14\n$$\n\n最后，我们计算比值 $R$：\n$$\nR = \\frac{\\kappa_2(B)}{\\kappa_2(A)} \\approx \\frac{2040.14}{1050.36} \\approx 1.94233\n$$\n将最终结果四舍五入到四位有效数字，得到 $1.942$。", "answer": "$$\n\\boxed{1.942}\n$$", "id": "2429417"}, {"introduction": "物理学和网络科学中的许多问题都可以用图来建模，从而产生涉及图拉普拉斯矩阵的线性系统。这个练习通过分析用于循环图的雅可比 (Jacobi) 预处理器，架起了数值代数与图论之间的桥梁 [@problem_id:2427805]。您将分析推导出预处理后系统的精确条件数，为您提供一个清晰的理论视角，以了解预处理在高度结构化问题上是如何工作的。", "problem": "考虑一个由含 $n$ 个顶点的无向无权图产生的线性系统 $A x = b$，其中 $A$ 是图拉普拉斯算子，定义为 $A = L = D - W$。这里 $D$ 是对角度矩阵，其元素为 $D_{ii} = d_i$，$W$ 是邻接矩阵。雅可比预条件子定义为 $A$ 的对角线。对于 $n \\geq 4$ 且为偶数的循环图 $C_n$，仅使用图拉普拉斯算子和雅可比预条件子的定义，构造对称雅可比预处理算子 $\\widetilde{A} = M^{-1/2} A M^{-1/2}$，其中 $M$ 是雅可比预条件子。然后，通过分析该图的对称性所蕴含的特征结构，确定 2-范数条件数 $\\kappa_2(\\widetilde{A})$，并将其表示为关于 $n$ 的闭式函数。请给出以 $n$ 表示的单一精确解析表达式作为最终答案。无需四舍五入。", "solution": "该问题陈述已经过验证，被认为是科学上成立、适定、客观且完整的。没有可识别的缺陷。该问题是数值线性代数和图论中的一个标准练习，可以通过已建立的数学原理推导出唯一解。因此，我们可以着手求解。\n\n问题要求解循环图 $C_n$（其中 $n$ 为偶数且 $n \\ge 4$）的对称雅可比预处理图拉普拉斯算子的 2-范数条件数。预处理矩阵 $\\widetilde{A}$ 的条件数 $\\kappa_2(\\widetilde{A})$ 由其最大特征值与最小非零特征值的比值给出。\n\n首先，我们构造循环图 $C_n$ 所涉及的矩阵。对于一个有 $n$ 个顶点的无向无权循环图，每个顶点的度都为 $2$。\n度矩阵 $D$ 是一个对角矩阵，其中每个对角元素 $D_{ii}$ 是顶点 $i$ 的度。因此，对于 $C_n$，所有对角元素都是 $2$，即 $D = 2I$，其中 $I$ 是 $n \\times n$ 的单位矩阵。\n\n$C_n$ 的邻接矩阵 $W$ 的元素 $W_{ij} = 1$ 如果顶点 $i$ 和 $j$ 相连，否则 $W_{ij} = 0$。对于沿循环排列的顶点顺序 $1, 2, \\ldots, n$，顶点 $i$ 与顶点 $i-1$ 和 $i+1$ 相连（索引对 $n$ 取模，并将 $0$ 映射到 $n$）。矩阵 $W$ 是一个循环矩阵。\n\n图拉普拉斯算子 $A$ 定义为 $A = L = D - W$。代入 $D$ 的表达式，我们得到：\n$$A = 2I - W$$\n$A$ 的元素为：对所有 $i$，$A_{ii} = 2$，$A_{i, i+1} = A_{i+1, i} = -1$（最后一个元素进行环绕处理），所有其他非对角元素为 $0$。\n\n雅可比预条件子 $M$ 定义为 $A$ 的对角线。由于 $A$ 的所有对角元素都是 $2$，该预条件子为：\n$$M = \\text{diag}(A) = 2I$$\n这是一个单位矩阵的简单标量倍数，因为该图是正则的（所有顶点具有相同的度）。\n\n对称雅可比预处理算子 $\\widetilde{A}$ 由 $\\widetilde{A} = M^{-1/2} A M^{-1/2}$ 给出。我们首先计算 $M^{-1/2}$：\n$$M^{-1/2} = (2I)^{-1/2} = \\frac{1}{\\sqrt{2}}I$$\n现在，我们构造 $\\widetilde{A}$：\n$$\\widetilde{A} = \\left(\\frac{1}{\\sqrt{2}}I\\right) A \\left(\\frac{1}{\\sqrt{2}}I\\right) = \\frac{1}{2}A$$\n代入 $A = 2I - W$：\n$$\\widetilde{A} = \\frac{1}{2}(2I - W) = I - \\frac{1}{2}W$$\n\n矩阵 $\\widetilde{A}$ 是一个实对称循环矩阵。其第一行为 $(1, -1/2, 0, \\ldots, 0, -1/2)$。一个第一行为 $(c_0, c_1, \\ldots, c_{n-1})$ 的 $n \\times n$ 循环矩阵的特征值 $\\tilde{\\lambda}_j$ 由以下公式给出：\n$$\\tilde{\\lambda}_j = \\sum_{k=0}^{n-1} c_k \\omega^{jk} \\quad \\text{for } j=0, 1, \\ldots, n-1$$\n其中 $\\omega = \\exp\\left(\\frac{2\\pi i}{n}\\right)$ 是 $n$ 次本原单位根。\n\n对于 $\\widetilde{A}$，系数为 $c_0 = 1$，$c_1 = -1/2$，$c_{n-1} = -1/2$，以及对于 $k \\in \\{2, \\ldots, n-2\\}$，$c_k = 0$。因此 $\\widetilde{A}$ 的特征值为：\n$$\\tilde{\\lambda}_j = c_0 \\omega^{j \\cdot 0} + c_1 \\omega^{j \\cdot 1} + c_{n-1} \\omega^{j \\cdot (n-1)}$$\n$$\\tilde{\\lambda}_j = 1 - \\frac{1}{2}\\omega^j - \\frac{1}{2}\\omega^{j(n-1)}$$\n利用性质 $\\omega^{j(n-1)} = \\omega^{jn}\\omega^{-j} = ((\\omega^n)^j)\\omega^{-j} = 1^j \\omega^{-j} = \\omega^{-j}$，上式可简化为：\n$$\\tilde{\\lambda}_j = 1 - \\frac{1}{2}(\\omega^j + \\omega^{-j})$$\n根据欧拉公式，$\\omega^j + \\omega^{-j} = 2\\cos\\left(\\frac{2\\pi j}{n}\\right)$。因此，特征值为：\n$$\\tilde{\\lambda}_j = 1 - \\cos\\left(\\frac{2\\pi j}{n}\\right) \\quad \\text{for } j=0, 1, \\ldots, n-1$$\n图拉普拉斯算子是奇异的，所以必有一个特征值为零。对于 $j=0$，我们有 $\\tilde{\\lambda}_0 = 1 - \\cos(0) = 1 - 1 = 0$。由于图 $C_n$ 是连通的，这是唯一的零特征值。\n\n奇异矩阵 $\\widetilde{A}$ 的 2-范数条件数定义在其零空间的正交子空间上。它是最大特征值与最小非零特征值的比值。\n$$\\kappa_2(\\widetilde{A}) = \\frac{\\lambda_{\\max}(\\widetilde{A})}{\\lambda_{\\min, \\text{non-zero}}(\\widetilde{A})}$$\n非零特征值的集合是 $\\{\\tilde{\\lambda}_j \\mid j=1, 2, \\ldots, n-1\\}$。\n\n为了找到最大特征值 $\\lambda_{\\max}$，我们必须找到对于 $j \\in \\{1, \\ldots, n-1\\}$ 时 $\\tilde{\\lambda}_j = 1 - \\cos\\left(\\frac{2\\pi j}{n}\\right)$ 的最大值。这在 $\\cos\\left(\\frac{2\\pi j}{n}\\right)$ 取最小值时发生。余弦函数的最小值为 $-1$，当其自变量为 $\\pi$ 时取到。我们设 $\\frac{2\\pi j}{n} = \\pi$，得到 $j = n/2$。由于题目说明 $n$ 是 $n \\ge 4$ 的偶数，所以 $j=n/2$ 是一个在有效范围内的整数。\n$$\\lambda_{\\max} = \\tilde{\\lambda}_{n/2} = 1 - \\cos\\left(\\frac{2\\pi (n/2)}{n}\\right) = 1 - \\cos(\\pi) = 1 - (-1) = 2$$\n\n为了找到最小非零特征值 $\\lambda_{\\min, \\text{non-zero}}$，我们必须找到对于 $j \\in \\{1, \\ldots, n-1\\}$ 时 $\\tilde{\\lambda}_j = 1 - \\cos\\left(\\frac{2\\pi j}{n}\\right)$ 的最小值。这在 $\\cos\\left(\\frac{2\\pi j}{n}\\right)$ 取最大值（但小于 $1$）时发生。这发生在自变量 $\\frac{2\\pi j}{n}$ 最接近 $0$ 或 $2\\pi$ 时。这对应于 $j=1$ 和 $j=n-1$。\n$$\\lambda_{\\min, \\text{non-zero}} = \\tilde{\\lambda}_1 = 1 - \\cos\\left(\\frac{2\\pi}{n}\\right)$$\n$j=n-1$ 时的特征值是相同的：$\\tilde{\\lambda}_{n-1} = 1 - \\cos\\left(\\frac{2\\pi(n-1)}{n}\\right) = 1 - \\cos\\left(2\\pi - \\frac{2\\pi}{n}\\right) = 1 - \\cos\\left(\\frac{2\\pi}{n}\\right)$。\n\n现在，我们计算条件数：\n$$\\kappa_2(\\widetilde{A}) = \\frac{2}{1 - \\cos\\left(\\frac{2\\pi}{n}\\right)}$$\n使用三角半角恒等式 $1 - \\cos(2\\theta) = 2\\sin^2(\\theta)$，并令 $\\theta = \\frac{\\pi}{n}$，我们简化分母：\n$$1 - \\cos\\left(\\frac{2\\pi}{n}\\right) = 2\\sin^2\\left(\\frac{\\pi}{n}\\right)$$\n将此代入条件数的表达式中，得到最终结果：\n$$\\kappa_2(\\widetilde{A}) = \\frac{2}{2\\sin^2\\left(\\frac{\\pi}{n}\\right)} = \\frac{1}{\\sin^2\\left(\\frac{\\pi}{n}\\right)}$$", "answer": "$$\\boxed{\\frac{1}{\\sin^2\\left(\\frac{\\pi}{n}\\right)}}$$", "id": "2427805"}, {"introduction": "理论最终必须与实践相结合。作为我们最后的练习，我们将从解析计算转向完整的计算实现，这正是计算物理学的核心 [@problem_id:2427808]。您将实现预处理共轭梯度 (PCG) 方法，并探索在求解一个实际的各向异性扩散问题时，不同的预处理器—甚至是用于创建它们的浮点精度—如何影响算法的性能和稳定性。", "problem": "给定一系列形式为 $A x = b$ 的对称正定线性系统，这些系统源于在带Dirichlet边界条件的方形网格上，对一个各向异性扩散算子进行二维、五点有限差分格式离散化。令 $m$ 表示每个坐标方向上的内部点数（因此维度为 $n = m^2$）。系数矩阵 $A$ 由 $A = I_m \\otimes T_x + T_y \\otimes I_m$ 构成，其中 $T_x$ 和 $T_y$ 是具有常数对角线的三对角矩阵，定义为 $T_x = \\text{tridiag}(-a_x, 2 a_x, -a_x)$ 和 $T_y = \\text{tridiag}(-a_y, 2 a_y, -a_y)$，其中 $a_x$ 和 $a_y$ 严格为正。右端项 $b$ 是 $\\mathbb{R}^n$ 中的全1向量。您的任务是使用不同的预处理器实现预处理共轭梯度法，并研究浮点精度（单精度、双精度与混合精度）如何影响预处理器的稳定性和效用，这种影响通过达到固定精度所需的迭代次数来衡量。\n\n从基本原理开始：\n- 共轭梯度法通过迭代最小化误差的 $A$-能量范数来求解对称正定系统 $A x = b$，该最小化过程在由 $A$ 和残差生成的扩展Krylov子空间上进行，利用了残差的正交性和方向的 $A$-共轭性。\n- 一个对称正定的左预处理器 $M$ 将系统转换为 $M^{-1} A x = M^{-1} b$，并将内积改为 $\\langle u, v \\rangle_M = u^\\top M v$，这在实践中降低了Krylov过程中所应用算子的条件数，从而在 $M$ 是 $A$ 的一个良好近似时提高收敛速度。\n- 对于对称正定矩阵，一种标准的稀疏近似分解是零填充不完全Cholesky分解，记作 $\\text{IC}(0)$。该方法计算一个下三角因子 $L$，其稀疏模式被限制为与 $A$ 的下三角部分相同，使得 $L L^\\top \\approx A$。应用该预处理器的过程对应于通过两次三角求解 $L y = r$ 和 $L^\\top z = y$ 来计算 $z = M^{-1} r$。\n\n实现以下预处理器：\n- 无预处理器：$M = I$。\n- Jacobi预处理器：$M = \\mathrm{diag}(A)$。\n- 在双精度下计算的零填充不完全Cholesky分解：$M = L_{64} L_{64}^\\top$，其中 $L_{64}$ 使用64位浮点运算计算。\n- 在单精度下计算并使用单精度三角求解的零填充不完全Cholesky分解：$M = L_{32} L_{32}^\\top$，其中 $L_{32}$ 使用32位浮点运算计算，并在三角求解中使用32位运算进行应用。\n- 混合精度不完全Cholesky分解：如上计算 $L_{32}$，但在64位运算中进行三角求解（通过在求解前将存储的因子一次性转换为64位）。\n\n预处理共轭梯度法的所有迭代、向量内积和收敛性测试都必须在64位算术中执行。使用相对残差停止准则 $\\|r_k\\|_2 / \\|b\\|_2 \\le \\tau$，其中 $\\tau = 10^{-8}$。如果方法未能在 $k_{\\max} = 5000$ 次迭代内满足停止准则，则返回5000作为该次运行的迭代次数。\n\n对于 $\\text{IC}(0)$，如果在任何步骤中由于有限精度效应遇到非正对角元素，通过增加一个小的正对角移位来稳定它，该移位与局部对角元素的大小成比例。具体来说，如果在分解中计算的第 $i$ 步的中间值不是严格为正，则用 $d_i + \\delta$ 替换它，其中 $d_i$ 是 $A$在第 $i$ 行的对角元素，$\\delta$ 是一个与 $\\sqrt{\\varepsilon}$（其中 $\\varepsilon$ 是工作精度下的机器ε）数量级相同的小的正数。记录在计算 $L_{32}$ 时发生了多少次此类稳定化操作。\n\n测试套件。对于下列每一组参数 $(m, a_x, a_y)$：\n- 案例1：$m = 16$, $a_x = 1$, $a_y = 1$。\n- 案例2：$m = 16$, $a_x = 1$, $a_y = 10^{-3}$。\n- 案例3：$m = 16$, $a_x = 1$, $a_y = 10^{-6}$。\n\n对每种情况执行以下操作：\n- 以压缩稀疏行（CSR）格式组装 $A$。\n- 对上述定义的五种预处理器中的每一种，使用相同的 $b$（全1向量）、容差 $\\tau = 10^{-8}$ 和最大迭代次数 $k_{\\max} = 5000$ 运行预处理共轭梯度法。\n- 记录每种预处理器满足停止准则所需的迭代次数，并仅记录单精度不完全Cholesky分解计算中使用的稳定化次数。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，其中每个元素对应一个案例，并且本身是按以下顺序排列的六个整数的列表：\n$[\\text{iters\\_none}, \\text{iters\\_jacobi}, \\text{iters\\_ic64}, \\text{iters\\_ic32}, \\text{iters\\_icmix}, \\text{stabilizations\\_ic32}]$。\n例如，三个案例的输出格式如下：\n$[[n_{1,1}, n_{1,2}, n_{1,3}, n_{1,4}, n_{1,5}, s_1],[n_{2,1}, n_{2,2}, n_{2,3}, n_{2,4}, n_{2,5}, s_2],[n_{3,1}, n_{3,2}, n_{3,3}, n_{3,4}, n_{3,5}, s_3]]$\n其中每个 $n_{i,j}$ 是一个整数迭代次数，每个 $s_i$ 是案例 $i$ 中单精度 $\\text{IC}(0)$ 的整数稳定化次数。\n\n角度单位不适用。物理单位不适用。答案中的所有数值必须无单位。", "solution": "所提出的问题是一个定义明确的计算科学练习，要求实现和比较用于共轭梯度法的预处理策略。该问题有科学依据，内部一致，且不需要超出所提供信息之外的任何信息。该问题是有效的。\n\n我们的任务是求解线性系统 $A x = b$，其中矩阵 $A \\in \\mathbb{R}^{n \\times n}$（$n=m^2$）源于在 $m \\times m$ 的均匀内部点网格上对一个各向异性扩散算子进行五点有限差分格式离散化。矩阵 $A$ 是对称正定（SPD）的，由Kronecker和 $A = I_m \\otimes T_x + T_y \\otimes I_m$ 给出。矩阵 $T_x, T_y \\in \\mathbb{R}^{m \\times m}$ 是三对角矩阵，具体为 $T_x = \\text{tridiag}(-a_x, 2 a_x, -a_x)$ 和 $T_y = \\text{tridiag}(-a_y, 2 a_y, -a_y)$，其中 $a_x, a_y > 0$。右端向量 $b$ 是全1向量。\n\n解决方案将分三个阶段进行：\n1.  以适合高效计算的稀疏格式构建矩阵 $A$。\n2.  实现预处理共轭梯度（PCG）算法。\n3.  实现各种预处理器，特别关注不完全Cholesky分解及其在不同浮点精度下的数值稳定性。\n\n**1. 矩阵组装**\n\n矩阵 $A$ 使用Kronecker积来构建。给定 $m$、$a_x$ 和 $a_y$，矩阵 $T_x$ 和 $T_y$ 被组装为稀疏三对角矩阵。利用Kronecker积的性质，$I_m \\otimes T_x$ 会产生一个块对角矩阵，其中每个块都是 $T_x$。类似地，$T_y \\otimes I_m$ 会产生一个块三对角矩阵，其中对角块是 $2a_y I_m$，非对角块是 $-a_y I_m$。它们的和得到矩阵 $A$，该矩阵具有块三对角结构，每行最多包含5个非零元素。所有组装 $A$ 的计算都在64位精度（双精度）下执行。得到的矩阵以压缩稀疏行（CSR）格式存储。\n\n**2. 预处理共轭梯度（PCG）法**\n\nPCG法是求解SPD线性系统的迭代算法。它通过使用一个预处理器 $M \\approx A$ 来变换系统，从而改进了共轭梯度法，通过聚集迭代矩阵 $M^{-1}A$ 的特征值来加速收敛。该算法完全在64位算术中执行，流程如下：\n\n给定初始猜测值 $x_0$ （我们使用 $x_0 = \\mathbf{0}$）、容差 $\\tau = 10^{-8}$ 和最大迭代次数 $k_{\\max} = 5000$：\n1.  初始化残差：$r_0 = b - A x_0$。\n2.  应用预处理器：$z_0 = M^{-1} r_0$。\n3.  设置初始搜索方向：$p_0 = z_0$。\n4.  对于 $k=0, 1, 2, \\dots$ 直到收敛或达到 $k_{\\max}$：\n    a. 计算步长：$\\alpha_k = \\frac{r_k^\\top z_k}{p_k^\\top A p_k}$。\n    b. 更新解：$x_{k+1} = x_k + \\alpha_k p_k$。\n    c. 更新残差：$r_{k+1} = r_k - \\alpha_k A p_k$。\n    d. 检查收敛性：如果 $\\|r_{k+1}\\|_2 / \\|b\\|_2 \\le \\tau$，则停止并返回 $k+1$。\n    e. 应用预处理器：$z_{k+1} = M^{-1} r_{k+1}$。\n    f. 更新搜索方向：$\\beta_k = \\frac{r_{k+1}^\\top z_{k+1}}{r_k^\\top z_k}$，然后 $p_{k+1} = z_{k+1} + \\beta_k p_k$。\n\n研究的核心在于预处理步骤 $z = M^{-1} r$ 的实现。\n\n**3. 预处理器实现**\n\n我们为预处理器 $M$ 实现了五种不同的选择。\n\n-   **无预处理器**：$M = I$，单位矩阵。操作 $M^{-1}r$ 简化为 $z=r$。这对应于标准的共轭梯度法。\n-   **Jacobi预处理器**：$M = \\mathrm{diag}(A)$。这是一种简单的对角缩放。对于给定的矩阵 $A$，其对角线是恒定的，等于 $2(a_x+a_y)$。操作 $M^{-1}r$ 是一个逐分量的除法：$z_i = r_i / (2(a_x+a_y))$。\n-   **零填充不完全Cholesky分解 (IC(0))**：该预处理器计算一个近似Cholesky分解 $M = LL^\\top \\approx A$，其中下三角因子 $L$ 的稀疏模式被限制为与 $A$ 的下三角部分相同。预处理步骤 $z = M^{-1}r$ 通过求解两个三角系统来执行：$Ly=r$（前向替换）和 $L^\\top z=y$（后向替换）。\n\n    IC(0)因子 $L$ 通过以下算法计算。对于 $i=0, \\dots, n-1$：\n    $$l_{ij} = \\frac{1}{l_{jj}} \\left( a_{ij} - \\sum_{k=0}^{j-1} l_{ik} l_{jk} \\right) \\quad \\text{for } j < i \\text{ and } a_{ij} \\ne 0$$\n    $$l_{ii} = \\sqrt{a_{ii} - \\sum_{k=0}^{i-1} l_{ik}^2}$$\n    对于5点格式矩阵的图（不包含长度为3的环），和 $\\sum_{k<j} l_{ik} l_{jk}$ 总是为零。这简化了非对角元素的计算，使其变为 $l_{ij} = a_{ij} / l_{jj}$。\n\n    在有限精度算术中，$l_{ii}$ 的平方根下的项可能变为非正。为防止分解失败，我们对分解进行稳定化处理。如果 $a_{ii} - \\sum_{k<i} l_{ik}^2 \\le 0$，我们将对角值替换为 $d_i + \\delta$，其中 $d_i$ 是 $A$ 的原始对角元素，$\\delta = \\sqrt{\\varepsilon}$，$\\varepsilon$ 是工作精度下的机器ε。\n\n    我们实现了IC(0)预处理器的三个变体：\n    1.  **双精度IC(0)**：因子 $L_{64}$ 在64位算术中完全计算和应用。\n    2.  **单精度IC(0)**：将矩阵 $A$ 转换为32位精度。因子 $L_{32}$ 在32位精度下计算（使用 $\\varepsilon_{32}$ 进行稳定化），并记录稳定化次数。对 $z=M^{-1}r$ 的三角求解也在32位精度下执行：将64位的残差 $r$ 转换为32位，执行求解，然后将得到的32位向量 $z$ 转换回64位。\n    3.  **混合精度IC(0)**：因子 $L_{32}$ 的计算与单精度情况相同。然而，在PCG迭代开始前，它被转换为一个64位矩阵。随后的三角求解完全在64位算术中进行。这种方法旨在利用 $L_{32}$ 因子更快的计算速度，同时保持64位求解的数值稳定性。\n\n以下Python代码为指定的测试案例实现了这一完整过程。", "answer": "```python\nimport numpy as np\nimport scipy.sparse as sp\nfrom scipy.sparse.linalg import spsolve_triangular\n\ndef assemble_A(m, ax, ay):\n    \"\"\"\n    Assembles the 2D anisotropic diffusion matrix A using Kronecker products.\n    A = I_m kron T_x + T_y kron I_m\n    \"\"\"\n    n = m * m\n    \n    # Define T_x and T_y matrices\n    tx_diagonals = [-ax * np.ones(m - 1), 2 * ax * np.ones(m), -ax * np.ones(m - 1)]\n    ty_diagonals = [-ay * np.ones(m - 1), 2 * ay * np.ones(m), -ay * np.ones(m - 1)]\n    \n    Tx = sp.diags(tx_diagonals, [-1, 0, 1], shape=(m, m), format='csr', dtype=np.float64)\n    Ty = sp.diags(ty_diagonals, [-1, 0, 1], shape=(m, m), format='csr', dtype=np.float64)\n    \n    Im = sp.eye(m, dtype=np.float64)\n    \n    A = sp.kron(Im, Tx) + sp.kron(Ty, Im)\n    return A.tocsr()\n\ndef ic0_factor(A, precision):\n    \"\"\"\n    Computes the Incomplete Cholesky factorization with zero fill (IC(0)).\n    This implementation is correct for matrices where the graph has no cycles of length 3,\n    such as those from a 5-point finite difference stencil.\n    \n    Args:\n        A (csr_matrix): The symmetric positive definite matrix to factorize.\n        precision (dtype): The floating-point precision (np.float32 or np.float64).\n    \n    Returns:\n        L (csr_matrix): The lower triangular IC(0) factor.\n        stabilization_count (int): Number of times stabilization was applied.\n    \"\"\"\n    n = A.shape[0]\n    # Use LIL format for easier, albeit slower, element-wise modification\n    L = A.copy().tolil().astype(precision)\n    A_diag_orig = A.diagonal().astype(precision)\n    \n    eps = np.finfo(precision).eps\n    delta = np.sqrt(eps)\n    stabilization_count = 0\n\n    for i in range(n):\n        # The sum over k in the formula for l_ij is zero for 5-point stencil graph\n        # because there are no triangles (cycles of length 3).\n        # So, l_ij = a_ij / l_jj\n        row_i_cols_lt_i = sorted([j for j in L.rows[i] if j < i])\n        \n        for j in row_i_cols_lt_i:\n            if L[j, j] != 0:\n                L[i, j] = L[i, j] / L[j, j]\n\n        # Compute diagonal element l_ii\n        # l_ii^2 = a_ii - sum_{k<i} l_ik^2\n        sum_sq = 0.0\n        for k in row_i_cols_lt_i:\n             sum_sq += L[i, k]**2\n        \n        diag_val = L[i, i] - sum_sq # L[i,i] still holds original A[i,i]\n\n        if diag_val <= 0:\n            diag_val = A_diag_orig[i] + delta\n            stabilization_count += 1\n        \n        L[i, i] = np.sqrt(diag_val)\n\n    # Return a clean lower-triangular CSR matrix\n    return sp.tril(L, format='csr'), stabilization_count\n\ndef pcg(A, b, precon_func, tol, max_iter):\n    \"\"\"\n    Preconditioned Conjugate Gradient solver.\n    All vector operations and tests are in 64-bit precision.\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros(n, dtype=np.float64)\n    r = b - A.dot(x)\n    z = precon_func(r)\n    p = z.copy()\n    \n    rs_old = np.dot(r, z)\n    b_norm = np.linalg.norm(b)\n    \n    for i in range(max_iter):\n        Ap = A.dot(p)\n        alpha = rs_old / np.dot(p, Ap)\n        \n        x += alpha * p\n        r -= alpha * Ap\n        \n        if np.linalg.norm(r) / b_norm <= tol:\n            return i + 1\n            \n        z = precon_func(r)\n        rs_new = np.dot(r, z)\n        \n        beta = rs_new / rs_old\n        p = z + beta * p\n        \n        rs_old = rs_new\n        \n    return max_iter\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (16, 1.0, 1.0),\n        (16, 1.0, 1e-3),\n        (16, 1.0, 1e-6),\n    ]\n\n    results = []\n    \n    for m, ax, ay in test_cases:\n        case_results = []\n        A_64 = assemble_A(m, ax, ay)\n        n = m * m\n        b_64 = np.ones(n, dtype=np.float64)\n        tol = 1e-8\n        max_iter = 5000\n\n        # No preconditioner\n        precon_none = lambda r: r\n        iters_none = pcg(A_64, b_64, precon_none, tol, max_iter)\n        case_results.append(iters_none)\n\n        # Jacobi preconditioner\n        A_diag_64 = A_64.diagonal()\n        precon_jacobi = lambda r: r / A_diag_64\n        iters_jacobi = pcg(A_64, b_64, precon_jacobi, tol, max_iter)\n        case_results.append(iters_jacobi)\n\n        # IC(0) 64-bit\n        L64, _ = ic0_factor(A_64, np.float64)\n        precon_ic64 = lambda r: spsolve_triangular(L64.T, spsolve_triangular(L64, r, lower=True), lower=False)\n        iters_ic64 = pcg(A_64, b_64, precon_ic64, tol, max_iter)\n        case_results.append(iters_ic64)\n\n        # IC(0) 32-bit (factorization and solves in float32)\n        A_32 = A_64.astype(np.float32)\n        L32, stab_count = ic0_factor(A_32, np.float32)\n        def precon_ic32(r):\n            r_32 = r.astype(np.float32)\n            y_32 = spsolve_triangular(L32, r_32, lower=True)\n            z_32 = spsolve_triangular(L32.T, y_32, lower=False)\n            return z_32.astype(np.float64)\n        iters_ic32 = pcg(A_64, b_64, precon_ic32, tol, max_iter)\n        case_results.append(iters_ic32)\n\n        # Mixed-precision IC(0) (factor in float32, solves in float64)\n        L32_as_64 = L32.astype(np.float64)\n        precon_icmix = lambda r: spsolve_triangular(L32_as_64.T, spsolve_triangular(L32_as_64, r, lower=True), lower=False)\n        iters_icmix = pcg(A_64, b_64, precon_icmix, tol, max_iter)\n        case_results.append(iters_icmix)\n\n        case_results.append(stab_count)\n        results.append(case_results)\n\n    # Format the final output as specified\n    output_str = \"[\" + \",\".join([str(r) for r in results]) + \"]\"\n    print(output_str.replace(\" \", \"\"))\n\n\nsolve()\n```", "id": "2427808"}]}