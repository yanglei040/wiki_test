{"hands_on_practices": [{"introduction": "我们的第一个动手实践将展示傅里叶谱方法的核心优势。通过将双调和方程变换到傅里叶空间，复杂的四阶微分算子 $\\nabla^4$ 简化为了简单的代数乘法。这项练习将让你为周期性边界值问题实现一个高效的求解器，直观地感受谱方法在高阶问题上的威力 [@problem_id:2440935]。", "problem": "考虑一个周期性方形域上的二维双调和方程，\n$$\\nabla^4 u(x,y) = f(x,y), \\quad (x,y) \\in [0,1)\\times[0,1),$$\n在两个空间方向上均具有周期性边界条件。假设强迫项 $f$ 的空间平均值为零，这对于周期性边界条件下的可解性是必要的。您将构建一个基于谱方法的数值求解器，从给定的 $f$ 中恢复 $u$。\n\n使用以下基本基底。\n- 通过傅里叶级数表示足够平滑的周期函数。在周期域上，物理空间中的微分对应于傅里叶空间中乘以角波数：如果 $\\widehat{u}(\\kappa_x,\\kappa_y)$ 表示角波数 $(\\kappa_x,\\kappa_y)$ 处的傅里叶系数，那么应用空间导数 $\\partial/\\partial x$ 就对应于乘以 $i\\kappa_x$，对 $\\partial/\\partial y$ 也类似。因此，拉普拉斯算子满足 $\\widehat{\\nabla^2 u}(\\kappa_x,\\kappa_y) = -(\\kappa_x^2+\\kappa_y^2)\\widehat{u}(\\kappa_x,\\kappa_y)$。\n- 离散傅里叶变换 (DFT)，通过快速傅里叶变换 (FFT) 高效实现，通过将网格值映射到离散傅里叶系数来在均匀网格上近似这些运算。使用与广泛使用的数值库一致的标准离散傅里叶变换约定。角度以弧度为单位。\n\n设计并实现一个程序，该程序：\n- 在一个均匀的 $N\\times N$ 网格上离散化 $[0,1)\\times[0,1)$，网格点为 $x_j = j/N$ 和 $y_k = k/N$，其中整数 $j,k \\in \\{0,1,\\dots,N-1\\}$。\n- 使用离散傅里叶变换转换到傅里叶空间，在傅里叶空间中应用拉普拉斯算子两次，然后反变换回物理空间以近似 $u$。通过将 $u$ 的零傅里叶模式设置为零来强制执行零均值解。以数学上一致的方式小心处理零波数处的除法。\n- 计算均方根误差，\n$$\\mathrm{RMS}(u_{\\mathrm{num}},u_{\\mathrm{exact}})=\\sqrt{\\frac{1}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}\\left(u_{\\mathrm{num}}(x_j,y_k)-u_{\\mathrm{exact}}(x_j,y_k)\\right)^2},$$\n对于下面的每个测试用例。\n\n测试套件。对于每个用例，从指定的精确解 $u_{\\mathrm{exact}}$ 解析地构造 $f$。令 $\\pi$ 表示通常的圆周常数，并使用 $\\sin$ 和 $\\cos$ 的参数以弧度为单位的约定。通过 $\\kappa_x = 2\\pi n_x$ 和 $\\kappa_y = 2\\pi n_y$ 定义角波数，其中 $n_x$ 和 $n_y$ 分别是 $x$ 和 $y$ 方向上的整数模数。对于具有模数 $(n_x,n_y)$ 的纯傅里叶模式，双调和算子将该模式乘以 $(\\kappa_x^2+\\kappa_y^2)^2$。\n\n- 用例 A (理想路径): $N = 32$, $u_{\\mathrm{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$。那么\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\big(1^2+1^2\\big)\\right)^2\\,u_{\\mathrm{exact}}(x,y).$$\n- 用例 B (分辨率更改): $N = 64$, $u_{\\mathrm{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$。与用例 A 的 $f$ 公式相同。\n- 用例 C (不同模式的叠加): $N = 32$, $u_{\\mathrm{exact}}(x,y) = \\cos(2\\pi x) + \\cos(4\\pi y)$。那么\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\big(1^2+0^2\\big)\\right)^2\\cos(2\\pi x) \\;+\\; \\left(\\big(2\\pi\\big)^2\\big(0^2+2^2\\big)\\right)^2\\cos(4\\pi y).$$\n- 用例 D (奇数 $N$ 和混合高阶模式): $N = 33$, $u_{\\mathrm{exact}}(x,y) = \\sin(6\\pi x)\\sin(2\\pi y) - 2\\cos(2\\pi x)\\cos(6\\pi y)$。这里 $(n_x,n_y)=(3,1)$ 和 $(n_x,n_y)=(1,3)$ 都有 $n_x^2+n_y^2 = 10$，所以\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\cdot 10\\right)^2\\sin(6\\pi x)\\sin(2\\pi y) \\;-\\; 2\\left(\\big(2\\pi\\big)^2\\cdot 10\\right)^2\\cos(2\\pi x)\\cos(6\\pi y).$$\n- 用例 E (零强迫项的边界情况): $N = 40$, $u_{\\mathrm{exact}}(x,y) \\equiv 0$, 所以 $f(x,y)\\equiv 0$。\n\n你的程序应该为每个测试用例计算数值解 $u_{\\mathrm{num}}$，并以浮点数形式输出相应的均方根误差。最终输出格式：你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中 $r_i$ 是用例 $i$ 的均方根误差。不应打印任何额外文本。", "solution": "问题陈述经过仔细审查，被认为是有效的。它提出了一个来自计算物理学的适定数学问题，该问题基于偏微分方程和谱分析的既定原理。所有数据和条件都足以推导出一个唯一的、可验证的数值解。因此，我将继续提供一个完整的解决方案。\n\n问题是求解二维双调和方程，\n$$ \\nabla^4 u(x,y) = f(x,y) $$\n在一个周期域 $(x,y) \\in [0,1) \\times [0,1)$ 上。算子 $\\nabla^4$ 是双拉普拉斯算子，定义为 $\\nabla^2(\\nabla^2 u)$。域的周期性使得傅里叶级数成为表示解 $u(x,y)$ 和强迫项 $f(x,y)$ 的理想基选择。\n\n该域上一个足够平滑的周期函数 $g(x,y)$ 可以用其复傅里叶级数表示：\n$$ g(x,y) = \\sum_{n_x=-\\infty}^{\\infty} \\sum_{n_y=-\\infty}^{\\infty} \\widehat{g}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} $$\n其中 $n_x$ 和 $n_y$ 是整数波数，而 $\\widehat{g}_{n_x,n_y}$ 是复傅里叶系数。傅里叶级数的一个基本性质是，空间微分在傅里叶域中会转换为代数乘法。将拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 应用于函数 $u(x,y)$ 可得：\n$$ \\nabla^2 u(x,y) = \\sum_{n_x,n_y} \\left( (i 2\\pi n_x)^2 + (i 2\\pi n_y)^2 \\right) \\widehat{u}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} = \\sum_{n_x,n_y} -(2\\pi)^2(n_x^2 + n_y^2) \\widehat{u}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} $$\n因此，$\\nabla^2 u$ 的傅里叶系数与 $u$ 的傅里叶系数通过 $\\widehat{\\nabla^2 u}_{n_x,n_y} = -K^2 \\widehat{u}_{n_x,n_y}$ 相关联，其中 $K^2 = (2\\pi n_x)^2 + (2\\pi n_y)^2 = \\kappa_x^2 + \\kappa_y^2$ 是波矢量的模的平方。\n\n应用拉普拉斯算子两次，我们得到双调和算子在傅里叶空间中的作用：\n$$ \\widehat{\\nabla^4 u}_{n_x,n_y} = (-\\kappa_x^2 - \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} = (\\kappa_x^2 + \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} $$\n因此，原始的偏微分方程 $\\nabla^4 u = f$ 转换为关于傅里叶系数的一组代数方程：\n$$ (\\kappa_x^2 + \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} = \\widehat{f}_{n_x,n_y} $$\n我们可以求解 $\\widehat{u}_{n_x,n_y}$：\n$$ \\widehat{u}_{n_x,n_y} = \\frac{\\widehat{f}_{n_x,n_y}}{(\\kappa_x^2 + \\kappa_y^2)^2} = \\frac{\\widehat{f}_{n_x,n_y}}{(2\\pi)^4(n_x^2 + n_y^2)^2} $$\n此表达式对于除零波数模式 $(0,0)$ 之外的所有波数 $(n_x, n_y)$ 都有效。对于此模式，分母为零。相应的分子 $\\widehat{f}_{0,0}$ 表示强迫函数 $f(x,y)$ 在整个域上的空间平均值。在周期域上双调和方程可解的一个必要条件是该平均值必须为零，即 $\\widehat{f}_{0,0} = 0$。这导致 $\\widehat{u}_{0,0}$ 出现 $0/0$ 的不定形式。$\\widehat{u}_{0,0}$ 的值，即解 $u(x,y)$ 的空间平均值，不由该方程确定。为了确保解的唯一性，我们强制执行问题的约束条件，即解的平均值为零，这等价于设置 $\\widehat{u}_{0,0} = 0$。\n\n数值算法使用离散傅里叶变换 (DFT) 实现此过程的离散模拟，而 DFT 可通过快速傅里叶变换 (FFT) 高效计算。\n\n该算法按以下步骤进行：\n$1$. 将域 $[0,1) \\times [0,1)$ 在一个均匀的 $N \\times N$ 网格上离散化，网格点为 $(x_j, y_k) = (j/N, k/N)$，其中 $j, k \\in \\{0, 1, \\dots, N-1\\}$。在该网格上计算强迫函数 $f(x,y)$ 以生成矩阵 $F_{jk} = f(x_j, y_k)$。\n\n$2$. 计算矩阵 $F$ 的二维 FFT 以获得离散傅里叶系数 $\\widehat{F}$。\n$$ \\widehat{F} = \\mathrm{FFT2D}(F) $$\n\n$3$. 生成一个对应的 $N \\times N$ 离散整数波数 $(n_x, n_y)$ 网格。对于一个用 $N$ 个点离散化的长度为 $1$ 的域，与 FFT 输出数组对应的整数波数由序列 $[0, 1, \\dots, N/2-1, -N/2, \\dots, -1]$（对于偶数 $N$）或类似序列（对于奇数 $N$）给出，这可以使用像 `numpy.fft.fftfreq` 这样的库函数生成。\n\n$4$. 在傅里叶域中应用双调和算子，方法是将系数 $\\widehat{F}_{n_x,n_y}$ 除以算子符号的离散版本 $L_{n_x,n_y} = \\left( (2\\pi n_x)^2 + (2\\pi n_y)^2 \\right)^2$。零波数模式被单独处理。\n$$ \\widehat{U}_{n_x,n_y} = \\begin{cases} \\widehat{F}_{n_x,n_y} / L_{n_x,n_y} & \\text{if } (n_x, n_y) \\neq (0,0) \\\\ 0 & \\text{if } (n_x, n_y) = (0,0) \\end{cases} $$\n此步骤正确处理了奇异点问题，并强制执行了零均值解的约束。\n\n$5$. 通过对系数矩阵 $\\widehat{U}$ 应用逆二维 FFT，恢复网格上的数值解 $U_{\\mathrm{num}}$。\n$$ U_{\\mathrm{num}} = \\mathrm{real}(\\mathrm{IFFT2D}(\\widehat{U})) $$\n取实部是为了丢弃由浮点不精确性产生的可忽略的虚部。\n\n$6$. 最后，通过将网格上的数值解 $U_{\\mathrm{num}}$ 与精确解 $U_{\\mathrm{exact}}$ 进行比较，来计算均方根误差：\n$$ \\mathrm{RMS} = \\sqrt{\\frac{1}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}\\left( (U_{\\mathrm{num}})_{jk} - (U_{\\mathrm{exact}})_{jk} \\right)^2} $$\n对每个测试用例应用此程序，以得出所需的误差值。由于所有精确解都由低波数的正弦波组成，这些正弦波在指定的网格上可以被完美表示，因此预期误差在机器浮点精度的数量级。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D biharmonic equation on a periodic domain using a spectral method\n    and calculates the RMS error for several test cases.\n    \"\"\"\n    pi = np.pi\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'N': 32,\n            'u_exact': lambda x, y: np.sin(2*pi*x) * np.sin(2*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 1**2))**2 * (np.sin(2*pi*x) * np.sin(2*pi*y))\n        },\n        {\n            'N': 64,\n            'u_exact': lambda x, y: np.sin(2*pi*x) * np.sin(2*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 1**2))**2 * (np.sin(2*pi*x) * np.sin(2*pi*y))\n        },\n        {\n            'N': 32,\n            'u_exact': lambda x, y: np.cos(2*pi*x) + np.cos(4*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 0**2))**2 * np.cos(2*pi*x) + \\\n                              ((2*pi)**2 * (0**2 + 2**2))**2 * np.cos(4*pi*y)\n        },\n        {\n            'N': 33,\n            'u_exact': lambda x, y: np.sin(6*pi*x)*np.sin(2*pi*y) - 2*np.cos(2*pi*x)*np.cos(6*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * 10)**2 * np.sin(6*pi*x)*np.sin(2*pi*y) - \\\n                              2*((2*pi)**2 * 10)**2 * np.cos(2*pi*x)*np.cos(6*pi*y)\n        },\n        {\n            'N': 40,\n            'u_exact': lambda x, y: 0.0 * x, # Ensures correct shape (N, N) with all zeros\n            'f': lambda x, y: 0.0 * x\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        u_exact_func = case['u_exact']\n        f_func = case['f']\n\n        # 1. Discretize domain and create grid\n        grid_pts = np.arange(N) / N\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='xy')\n\n        # 2. Evaluate exact solution and forcing term on the grid\n        u_exact = u_exact_func(X, Y)\n        f_grid = f_func(X, Y)\n\n        # 3. Solve the PDE using the spectral method\n        \n        # 3a. Forward FFT of the forcing term\n        f_hat = np.fft.fft2(f_grid)\n\n        # 3b. Define discrete integer wavenumbers (modes) n_x, n_y\n        # Using d=1/N in fftfreq scales the result to be the integer mode number.\n        nx = np.fft.fftfreq(N, d=1/N)\n        ny = np.fft.fftfreq(N, d=1/N)\n        NX, NY = np.meshgrid(nx, ny, indexing='xy')\n\n        # 3c. Construct the biharmonic operator symbol in Fourier space\n        # L_hat = ( (2*pi*n_x)^2 + (2*pi*n_y)^2 )^2\n        op_fourier = ((2*pi*NX)**2 + (2*pi*NY)**2)**2\n\n        # 3d. Solve for u_hat, handling the zero-wavenumber mode\n        u_hat = np.zeros_like(f_hat, dtype=complex)\n        \n        # Create a mask for non-zero frequencies to avoid division by zero.\n        # The operator is zero only at the (0,0) frequency.\n        nonzero_mask = op_fourier != 0\n        u_hat[nonzero_mask] = f_hat[nonzero_mask] / op_fourier[nonzero_mask]\n\n        # The zero-mean constraint on u is enforced by setting u_hat[0,0] = 0.\n        # This is already implicitly true because f has zero mean (f_hat[0,0]~0),\n        # but setting it explicitly ensures robustness.\n        u_hat[0, 0] = 0.0\n        \n        # 3e. Inverse FFT to get numerical solution in physical space\n        u_num = np.real(np.fft.ifft2(u_hat))\n\n        # 4. Compute the root-mean-square error\n        rms_error = np.sqrt(np.mean((u_num - u_exact)**2))\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "2440935"}, {"introduction": "尽管傅里叶方法很强大，但在处理不连续函数时会遇到挑战，从而导致吉布斯现象（Gibbs phenomenon）的出现。下一个练习将通过逼近一个方波函数来探讨这个问题，并要求你实现一个Lanczos滤波器来抑制由此产生的振荡。你将定量分析减少过冲与保持过渡区陡峭度之间的权衡，这是信号处理和数值分析中的一个关键概念 [@problem_id:2440900]。", "problem": "题目要求您设计并评估一个用于不连续函数傅里叶表示的 Lanczos 谱滤波器，以抑制 Gibbs 现象，同时量化振荡抑制与空间分辨率之间的权衡。考虑在周期域 $\\left[-\\pi,\\pi\\right)$ 上定义的方波 $s(x)$：\n$$\ns(x) =\n\\begin{cases}\n1, & x \\in (0,\\pi),\\\\\n-1, & x \\in (-\\pi,0),\\\\\n\\end{cases}\n$$\n其中 $s(0)$ 和 $s(\\pm \\pi)$ 由周期性定义。设 $s(x)$ 具有标准的傅里叶级数表示：\n$$\ns(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right),\n$$\n其系数由以下积分给出：\n$$\na_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\cos(nx)\\,dx, \\quad b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\sin(nx)\\,dx.\n$$\n对于给定的正整数截断水平 $N$，定义未滤波的截断级数：\n$$\nS_N(x) = \\frac{a_0}{2} + \\sum_{n=1}^{N} \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right).\n$$\n通过应用乘法谱因子，定义 $p$ 阶 ($p \\in \\mathbb{N}_0$，非负整数) 的 Lanczos 滤波截断级数：\n$$\n\\sigma_n^{(p)} = \\left(\\mathrm{sinc}\\!\\left(\\frac{n}{N+1}\\right)\\right)^{p}, \\quad \\mathrm{sinc}(u) = \\begin{cases}\n\\frac{\\sin(\\pi u)}{\\pi u}, & u \\neq 0,\\\\\n1, & u=0,\n\\end{cases}\n$$\n得到\n$$\nS_{N,p}^{\\text{(LZ)}}(x) = \\frac{a_0}{2}\\,\\sigma_0^{(p)} + \\sum_{n=1}^{N} \\sigma_n^{(p)}\\left(a_n \\cos(nx) + b_n \\sin(nx)\\right),\n$$\n其中 $\\sigma_0^{(p)} \\equiv 1$。所有角度均应以弧度为单位。\n\n您的任务是，对于给定测试套件中的每个指定对 $(N,p)$，计算在 $M$ 个点的均匀网格上采样的 $S_{N,p}^{\\text{(LZ)}}(x)$ 的以下两个定量诊断指标：\n- 不连续点附近的振荡幅度（过冲量），定义为：\n$$\n\\mathcal{O}(N,p) = \\max\\left\\{\\,\\max_{x \\in (0,w_{\\text{ov}}]} \\left(S_{N,p}^{\\text{(LZ)}}(x) - 1\\right),\\ \\max_{x \\in [-w_{\\text{ov}},0)} \\left(-\\big(S_{N,p}^{\\text{(LZ)}}(x)+1\\big)\\right),\\ 0\\,\\right\\},\n$$\n该指标衡量在 $x=0$ 处跳跃点周围一个半宽为 $w_{\\text{ov}}$ 的对称窗口内，函数值超过上平台或低于下平台的最大正向偏离。\n- 有效过渡宽度，定义为跳跃点右侧邻域内最大斜率的倒数：\n$$\n\\mathcal{W}(N,p) = \\frac{2}{\\displaystyle \\max_{x \\in [0,w_{\\text{sl}}]} \\left|\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x)\\right|},\n$$\n该指标量化了在不连续点附近最陡峭处，穿过高度为 $2$ 的单位阶跃所需的距离（以弧度为单位）。\n\n使用均匀网格 $x_j = -\\pi + j \\Delta x$，$j=0,1,\\dots,M-1$，$\\Delta x = \\frac{2\\pi}{M}$，且 $M = 16384$。使用 $w_{\\text{ov}} = \\frac{\\pi}{4}$ 和 $w_{\\text{sl}} = \\frac{\\pi}{8}$。在评估 $\\mathcal{W}(N,p)$ 时，通过对截断的滤波级数进行逐项微分来精确计算导数，即：\n$$\n\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x) = -\\sum_{n=1}^{N} \\sigma_n^{(p)} a_n\\, n \\sin(nx) + \\sum_{n=1}^{N} \\sigma_n^{(p)} b_n\\, n \\cos(nx).\n$$\n\n测试套件。评估有序对 $(N,p)$ 列表：\n$$\n\\big[(9,0),\\ (9,1),\\ (63,0),\\ (63,1),\\ (63,2),\\ (255,1)\\big].\n$$\n\n答案规格与单位。对于每个 $(N,p)$，生成一个数对 $[\\mathcal{O}(N,p),\\ \\mathcal{W}(N,p)]$，其中 $\\mathcal{O}(N,p)$ 为无量纲实数，$\\mathcal{W}(N,p)$ 为以弧度为单位的实数。将每个实数四舍五入到 $6$ 位小数。\n\n最终输出格式。您的程序应产生单行输出，其中包含一个含有 6 个数对的列表，每个数对的格式为 $[\\text{overshoot},\\text{width}]$，整个列表用方括号括起来，数对之间用逗号分隔，无额外空格或文本。因此，最终输出必须具有以下形式：\n$$\n\\big[[\\mathcal{O}(N_1,p_1),\\mathcal{W}(N_1,p_1)],\\dots,[\\mathcal{O}(N_6,p_6),\\mathcal{W}(N_6,p_6)]\\big],\n$$\n其中所有数字都四舍五入到 6 位小数，角度以弧度为单位。", "solution": "该问题陈述已经过验证，被认为是科学上合理、适定、客观且自洽的。它提出了一个计算物理和应用数学领域的标准练习，内容涉及应用谱滤波器来减轻不连续函数傅里叶级数表示中的 Gibbs 现象。所有必要的参数、定义和评估指标都已明确无误地提供。因此，我们可以着手求解。\n\n问题的核心是分析方波的傅里叶级数，并量化 Lanczos 谱滤波器对其部分和的影响。求解过程包括三个主要步骤：首先，确定傅里叶系数的解析形式；其次，构建截断和滤波后的级数表示；第三，数值计算指定的过冲和过渡宽度诊断指标。\n\n**1. 方波的傅里叶系数**\n\n函数 $s(x)$ 在区间 $[-\\pi, \\pi)$ 上的定义如下：\n$$\ns(x) =\n\\begin{cases}\n1, & x \\in (0,\\pi),\\\\\n-1, & x \\in (-\\pi,0).\n\\end{cases}\n$$\n这是一个奇函数，满足 $s(-x) = -s(x)$。傅里叶级数由下式给出：\n$$\ns(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right).\n$$\n对于在对称区间 $[-\\pi, \\pi]$ 上积分的奇函数，其 cosine 系数 $a_n$ 恒为零。$a_n$ 的被积函数 $s(x)\\cos(nx)$ 是一个奇函数（奇函数 $\\times$ 偶函数），其在 $[-\\pi, \\pi]$ 上的积分为零。\n$$\na_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\cos(nx)\\,dx = 0, \\quad \\text{for all } n \\ge 0.\n$$\nsine 系数 $b_n$ 不为零。被积函数 $s(x)\\sin(nx)$ 是一个偶函数（奇函数 $\\times$ 奇函数），因此积分可以简化为：\n$$\nb_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\sin(nx)\\,dx = \\frac{2}{\\pi}\\int_{0}^{\\pi} s(x)\\sin(nx)\\,dx.\n$$\n将 $x \\in (0, \\pi)$ 时的 $s(x) = 1$ 代入：\n$$\nb_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} \\sin(nx)\\,dx = \\frac{2}{\\pi} \\left[-\\frac{\\cos(nx)}{n}\\right]_{0}^{\\pi} = \\frac{2}{n\\pi} \\left(-\\cos(n\\pi) + \\cos(0)\\right).\n$$\n使用恒等式 $\\cos(n\\pi) = (-1)^n$，我们得到：\n$$\nb_n = \\frac{2}{n\\pi}(1 - (-1)^n).\n$$\n当 $n$ 为偶数时，这些系数为零；当 $n$ 为奇数时，系数不为零：\n$$\nb_n =\n\\begin{cases}\n\\frac{4}{n\\pi}, & \\text{if } n \\text{ is odd},\\\\\n0, & \\text{if } n \\text{ is even}.\n\\end{cases}\n$$\n\n**2. Lanczos 滤波截断级数**\n\n由于对所有 $n$ 都有 $a_n=0$，截断的傅里叶级数 $S_N(x)$ 及其 Lanczos 滤波版本 $S_{N,p}^{\\text{(LZ)}}(x)$ 简化为仅含 sine 项的和：\n$$\nS_{N,p}^{\\text{(LZ)}}(x) = \\sum_{n=1}^{N} \\sigma_n^{(p)} b_n \\sin(nx),\n$$\n其中 Lanczos 滤波因子由 $\\sigma_n^{(p)} = \\left(\\mathrm{sinc}\\!\\left(\\frac{n}{N+1}\\right)\\right)^{p}$ 给出。这些因子的目的是在 $n$ 接近截断水平 $N$ 时平滑地减小系数 $b_n$ 的幅度，从而抑制导致 Gibbs 现象的高频振荡。当 $p=0$ 时，$\\sigma_n^{(0)}=1$，对应于未滤波的级数。当 $p > 0$ 时，滤波器的作用变得逐渐更强。\n\n计算过渡宽度需要用到滤波级数的导数。它通过逐项微分得到：\n$$\n\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x) = \\sum_{n=1}^{N} \\sigma_n^{(p)} b_n\\, n \\cos(nx).\n$$\n\n**3. 数值评估与诊断**\n\n我们将在一个覆盖域 $[-\\pi, \\pi)$ 的 $M=16384$ 个点的精细均匀网格上评估该级数及其导数。设网格点为 $x_j = -\\pi + j(2\\pi/M)$，$j = 0, 1, \\dots, M-1$。\n\n对于测试套件中的每个数对 $(N,p)$，我们执行以下计算：\n\n**a) 过冲幅度 $\\mathcal{O}(N,p)$：**\n过冲是在 $x=0$ 处不连续点附近，相对于平台值 $\\pm 1$ 的最大偏差。其计算公式为：\n$$\n\\mathcal{O}(N,p) = \\max\\left\\{\\,\\max_{x_j \\in (0,w_{\\text{ov}}]} \\left(S_{N,p}^{\\text{(LZ)}}(x_j) - 1\\right),\\ \\max_{x_j \\in [-w_{\\text{ov}},0)} \\left(-\\big(S_{N,p}^{\\text{(LZ)}}(x_j)+1\\big)\\right),\\ 0\\,\\right\\},\n$$\n其中 $w_{\\text{ov}} = \\pi/4$。我们找出落在两个窗口 $(0, \\pi/4]$ 和 $[-\\pi/4, 0)$ 内的网格点，在这些点上评估级数 $S_{N,p}^{\\text{(LZ)}}(x_j)$，并计算最大偏差。根据问题的对称性，上平台之上的过冲和下平台之下的过冲将是相等的。\n\n**b) 有效过渡宽度 $\\mathcal{W}(N,p)$：**\n过渡宽度量化了级数在穿过不连续点时的“陡峭”程度。较小的宽度意味着更陡峭的过渡，这是所期望的。它被定义为跳跃点附近最大斜率的倒数，并按总跳跃高度 $2$ 进行缩放：\n$$\n\\mathcal{W}(N,p) = \\frac{2}{\\displaystyle \\max_{x_j \\in [0,w_{\\text{sl}}]} \\left|\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x_j)\\right|},\n$$\n其中 $w_{\\text{sl}} = \\pi/8$。我们在窗口 $[0, \\pi/8]$ 内的网格点上评估导数，找到其最大绝对值，并计算宽度 $\\mathcal{W}$。增强滤波（$p>0$）预计会减小最大斜率，从而增加过渡宽度 $\\mathcal{W}$，这展示了振荡抑制与空间分辨率之间的权衡。\n\n数值实现将被向量化以提高效率。对于每个 $(N,p)$，我们预先计算系数 $b_n$和 $\\sigma_n^{(p)}$ 的数组。然后，可以通过系数向量与三角函数值矩阵（$\\sin(nx_j)$ 和 $\\cos(nx_j)$）之间的矩阵乘法，在所有网格点 $x_j$ 上评估级数及其导数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Lanczos-filtered Fourier series diagnostics for a square wave.\n    \"\"\"\n    # Problem parameters\n    M = 16384\n    w_ov = np.pi / 4\n    w_sl = np.pi / 8\n    test_cases = [\n        (9, 0),\n        (9, 1),\n        (63, 0),\n        (63, 1),\n        (63, 2),\n        (255, 1)\n    ]\n\n    # Create the uniform grid for x\n    delta_x = 2 * np.pi / M\n    x = np.arange(M) * delta_x - np.pi\n\n    final_results = []\n\n    for N, p in test_cases:\n        # Array of mode numbers from 1 to N\n        n = np.arange(1, N + 1)\n\n        # 1. Compute Fourier and filter coefficients\n        # Fourier coefficients b_n for the square wave\n        b_n = np.zeros(N)\n        odd_indices = (n % 2) != 0\n        n_odd = n[odd_indices]\n        b_n[odd_indices] = 4 / (n_odd * np.pi)\n\n        # Lanczos filter coefficients sigma_n\n        if p == 0:\n            sigma_n = np.ones(N)\n        else:\n            # np.sinc(u) calculates sin(pi*u)/(pi*u)\n            u = n / (N + 1)\n            sigma_n = np.sinc(u)**p\n\n        # Combined coefficients for the series and its derivative\n        # For S(x): c_n = sigma_n * b_n\n        c_n = sigma_n * b_n\n        # For dS/dx(x): d_n = c_n * n\n        d_n = c_n * n\n\n        # 2. Evaluate the series and its derivative on the grid\n        # Reshape for broadcasting (n as column, x as row)\n        n_col = n.reshape(-1, 1)\n        x_row = x.reshape(1, -1)\n\n        # S(x) = sum(c_n * sin(n*x))\n        sin_matrix = np.sin(n_col * x_row)\n        S_x = c_n @ sin_matrix\n\n        # dS/dx(x) = sum(d_n * cos(n*x))\n        cos_matrix = np.cos(n_col * x_row)\n        S_prime_x = d_n @ cos_matrix\n        \n        # 3. Calculate diagnostics\n        \n        # --- Overshoot O(N, p) ---\n        # Window for upper overshoot: (0, w_ov]\n        idx_upper = (x > 0) & (x <= w_ov)\n        overshoot_upper = np.max(S_x[idx_upper] - 1) if np.any(idx_upper) else -np.inf\n\n        # Window for lower overshoot: [-w_ov, 0)\n        idx_lower = (x >= -w_ov) & (x < 0)\n        overshoot_lower = np.max(-(S_x[idx_lower] + 1)) if np.any(idx_lower) else -np.inf\n\n        O = np.max([overshoot_upper, overshoot_lower, 0.0])\n\n        # --- Transition Width W(N, p) ---\n        # Window for slope: [0, w_sl]\n        idx_slope = (x >= 0) & (x <= w_sl)\n        \n        max_slope = 0.0\n        if np.any(idx_slope):\n            max_slope = np.max(np.abs(S_prime_x[idx_slope]))\n        \n        W = 2.0 / max_slope if max_slope > 0 else np.inf\n\n        final_results.append((O, W))\n\n    # 4. Format the output string as per problem specification\n    formatted_pairs = []\n    for O, W in final_results:\n        # Round each value to 6 decimal places before formatting\n        O_rounded = round(O, 6)\n        W_rounded = round(W, 6)\n        formatted_pairs.append(f\"[{O_rounded:.6f},{W_rounded:.6f}]\")\n    \n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```", "id": "2440900"}, {"introduction": "许多物理问题被定义在非周期性域上，傅里叶方法无法直接适用。这最后一个实践将引入切比雪夫谱方法（Chebyshev spectral method），用于求解矩形域上的二维泊松方程。你将学习如何处理坐标变换，使用张量积构建二维算子，并施加狄利克雷边界条件，从而将你的技能扩展到更广泛的一类问题 [@problem_id:2440925]。", "problem": "考虑一个矩形上的二维（$2$-dimensional）泊松方程，\n$$\\nabla^2 u(x,y) = f(x,y), \\quad (x,y)\\in [a_x,b_x]\\times [a_y,b_y],$$\n服从狄利克雷边界条件\n$$u(x,y) = g(x,y) \\quad \\text{for } (x,y) \\in \\partial([a_x,b_x]\\times [a_y,b_y]),$$\n其中 $\\nabla^2$ 表示关于物理坐标 $x$ 和 $y$ 的拉普拉斯算子。对于下方的每个测试用例，都指定了精确解 $u(x,y)$；请使用它来定义边界上的边界条件 $g(x,y)$ 和内部的源函数 $f(x,y) = \\nabla^2 u(x,y)$。\n\n您的任务是编写一个完整的、可运行的程序，该程序为每个测试用例在包含边界点的 $N_x \\times N_y$ 大小的张量积网格上计算 $u(x,y)$ 的数值近似解，并返回数值近似解与精确解在域内所有网格点上的最大逐点绝对误差。\n\n测试套件（每行为一个用例，提供矩形区域、网格尺寸和精确解）：\n- 用例 $1$：$[a_x,b_x]=[-1,1]$，$[a_y,b_y]=[-1,1]$，$N_x=24$，$N_y=24$，精确解\n  $$u(x,y) = \\sin(\\pi x)\\sin(\\pi y)。$$\n- 用例 $2$：$[a_x,b_x]=[0,1]$，$[a_y,b_y]=[0,2]$，$N_x=30$，$N_y=28$，精确解\n  $$u(x,y) = x(1-x)\\,y(2-y)。$$\n- 用例 $3$：$[a_x,b_x]=[-2,3]$，$[a_y,b_y]=[-1,1]$，$N_x=22$，$N_y=18$，精确解\n  $$u(x,y) = e^{x}\\,(1-y^2)。$$\n- 用例 $4$：$[a_x,b_x]=[-1,1]$，$[a_y,b_y]=[-1,1]$，$N_x=8$，$N_y=8$，精确解\n  $$u(x,y) = 0。$$\n\n对于每个用例，请在物理坐标 $(x,y)$ 中计算 $f(x,y)=\\nabla^2 u(x,y)$，并在矩形的所有边上施加由 $u(x,y)$ 导出的狄利克雷边界值。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含 $4$ 个用例的最大绝对误差列表，格式为由方括号括起来的、以逗号分隔的十进制数列表，每个数都采用科学记数法，保留 $10$ 位有效数字。例如，\n$$[1.2345678900e-06,3.2100000000e-08,9.9900000000e-10,0.0000000000e+00]。$$\n\n所有量均为无量纲，无需报告物理单位。如果中间表达式中出现任何角度，都必须以弧度为单位进行解释。最终答案必须是如上所述的无量纲实数。", "solution": "用户提供了一个有效的问题陈述。任务是使用数值方法求解矩形域上带有狄利克雷边界条件的二维泊松方程。该问题是适定的、科学上合理的，并且为四个测试用例中的每一个都提供了所有必要的参数。\n\n所选方法是切比雪夫谱配置法，该方法因其在求解平滑解问题时的高精度而闻名。该方法包括以下步骤：\n\n1.  **域映射与离散化**：物理矩形域 $[a_x,b_x]\\times[a_y,b_y]$ 被映射到规范计算域 $[-1,1]\\times[-1,1]$。然后，使用切比雪夫-高斯-洛巴托点的张量积网格对该计算域进行离散化。网格维度为每个测试用例中指定的 $N_x \\times N_y$。仿射映射定义为：\n    $$x(\\xi) = \\frac{b_x - a_x}{2} \\xi + \\frac{b_x + a_x}{2}$$\n    $$y(\\eta) = \\frac{b_y - a_y}{2} \\eta + \\frac{b_y + a_y}{2}$$\n    其中 $(\\xi, \\eta) \\in [-1,1]\\times[-1,1]$ 是计算坐标。网格点为 $\\xi_i = \\cos(\\frac{i\\pi}{N_x-1})$ 和 $\\eta_j = \\cos(\\frac{j\\pi}{N_y-1})$。\n\n2.  **变换后的方程**：拉普拉斯算子被变换到计算坐标 $(\\xi, \\eta)$ 下。根据链式法则可得：\n    $$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = \\left(\\frac{2}{b_x-a_x}\\right)^2 \\frac{\\partial^2 u}{\\partial \\xi^2} + \\left(\\frac{2}{b_y-a_y}\\right)^2 \\frac{\\partial^2 u}{\\partial \\eta^2}$$\n    令 $c_x = (2/(b_x-a_x))^2$ 和 $c_y = (2/(b_y-a_y))^2$，偏微分方程（PDE）变为 $c_x u_{\\xi\\xi} + c_y u_{\\eta\\eta} = f$。\n\n3.  **谱算子离散化**：关于 $\\xi$ 和 $\\eta$ 的偏导数使用切比雪夫微分矩阵进行近似。设 $U$ 为表示网格点上解的 $N_x \\times N_y$ 矩阵。该偏微分方程的离散形式为：\n    $$c_x D_{xx} U + c_y U D_{yy}^T = F$$\n    其中 $D_{xx}$ 和 $D_{yy}$ 分别是 $x$ 和 $y$ 方向的二阶切比雪夫微分矩阵，$F$ 是在网格点上求值的源函数矩阵。\n\n4.  **线性系统构建**：为了使用标准线性求解器，通过将 $N_x \\times N_y$ 矩阵展平为大小为 $N_x N_y$ 的向量，将矩阵方程转换为一个大型线性系统 $\\mathcal{L}\\vec{u} = \\vec{f}$。使用行主序的 `flatten` 操作和克罗内克积，算子矩阵 $\\mathcal{L}$ 构建如下：\n    $$\\mathcal{L} = c_x(D_{xx} \\otimes I_y) + c_y(I_x \\otimes D_{yy})$$\n    其中 $I_x$ 和 $I_y$ 是适当大小的单位矩阵。\n\n5.  **边界条件施加**：狄利克雷边界条件指定了 $u$ 在域边界上的值。这些条件被直接施加到线性系统中。对于每个边界网格点，矩阵 $\\mathcal{L}$ 中相应的行被修改以表示一个恒等方程，而右侧向量 $\\vec{f}$ 中的相应条目被设置为来自精确解的已知边界值。\n\n6.  **求解与误差分析**：求解所得的线性系统，得到未知的网格点值 $\\vec{u}$。将解向量重塑回一个 $N_x \\times N_y$ 的矩阵 $U_{\\text{num}}$。通过计算数值解与在相同网格上求值的精确解 $U_{\\text{exact}}$ 之间的最大逐点绝对误差来量化数值解的精度：\n    $$\\text{Error} = \\max_{i,j} |(U_{\\text{num}})_{ij} - (U_{\\text{exact}})_{ij}|$$\n\n对于每个测试用例，通过对给定的精确解 $u(x,y)$ 解析计算拉普拉斯算子，来导出源函数 $f(x,y)$：\n-   用例 $1$：$u(x,y) = \\sin(\\pi x)\\sin(\\pi y) \\implies \\nabla^2 u = -2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$。\n-   用例 $2$：$u(x,y) = x(1-x)y(2-y) \\implies \\nabla^2 u = -2y(2-y) - 2x(1-x)$。\n-   用例 $3$：$u(x,y) = e^{x}(1-y^2) \\implies \\nabla^2 u = e^x(1-y^2) - 2e^x = -e^x(1+y^2)$。\n-   用例 $4$：$u(x,y) = 0 \\implies \\nabla^2 u = 0$。\n\n以下程序为每个指定的用例实现了这一策略。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Computes the first-order Chebyshev differentiation matrix on N points.\n    \n    Args:\n        N (int): The number of collocation points.\n\n    Returns:\n        np.ndarray: The (N, N) differentiation matrix.\n    \"\"\"\n    if N <= 1:\n        return np.array([[0.0]])\n\n    x = np.cos(np.pi * np.arange(N) / (N - 1))\n    c = np.ones(N)\n    c[0] = 2.0\n    c[-1] = 2.0\n\n    # Create a broadcast-ready version of x and c\n    x_col = x[:, np.newaxis]\n    c_col = c[:, np.newaxis]\n    \n    # Compute off-diagonal elements\n    dX = x_col - x\n    D = (c_col / c) * ((-1)**(np.arange(N)[:, np.newaxis] + np.arange(N))) / (dX + np.eye(N))\n    np.fill_diagonal(D, 0.0)\n\n    # Compute diagonal elements\n    D[np.diag_indices_from(D)] = -np.sum(D, axis=1)\n\n    return D\n\ndef solve_poisson_2d(params):\n    \"\"\"\n    Solves the 2D Poisson equation on a rectangular domain using a Chebyshev spectral method.\n    \n    Args:\n        params (tuple): A tuple containing (ax, bx, ay, by, Nx, Ny, u_exact_func, f_source_func).\n\n    Returns:\n        float: The maximum pointwise absolute error.\n    \"\"\"\n    ax, bx, ay, by, Nx, Ny, u_exact_func, f_source_func = params\n    \n    # 1. Coordinate transformation factors\n    dx = bx - ax\n    dy = by - ay\n    cx = (2.0 / dx)**2\n    cy = (2.0 / dy)**2\n\n    # 2. Chebyshev differentiation matrices\n    Dx = chebyshev_diff_matrix(Nx)\n    Dxx = Dx @ Dx\n    Dy = chebyshev_diff_matrix(Ny)\n    Dyy = Dy @ Dy\n\n    # 3. Construct the 2D operator matrix using Kronecker products (row-major)\n    Ix = np.identity(Nx)\n    Iy = np.identity(Ny)\n    L_op = cx * np.kron(Dxx, Iy) + cy * np.kron(Ix, Dyy)\n\n    # 4. Create the physical grid\n    xi = np.cos(np.pi * np.arange(Nx) / (Nx - 1))\n    eta = np.cos(np.pi * np.arange(Ny) / (Ny - 1))\n    \n    # Map from computational [-1, 1] to physical [a, b]\n    # Note: xi and eta run from 1 down to -1.\n    x_1d = (bx - ax) / 2.0 * xi + (ax + bx) / 2.0\n    y_1d = (by - ay) / 2.0 * eta + (ay + by) / 2.0\n    \n    # Create a meshgrid consistent with matrix indexing ('ij')\n    X, Y = np.meshgrid(x_1d, y_1d, indexing='ij')\n\n    # 5. Evaluate source term and exact solution on the grid\n    F = f_source_func(X, Y)\n    U_exact = u_exact_func(X, Y)\n\n    # 6. Flatten RHS and prepare for boundary condition imposition\n    f_flat = F.flatten() # Row-major\n    u_exact_flat = U_exact.flatten()\n\n    # 7. Identify boundary points\n    is_bnd = np.zeros_like(X, dtype=bool)\n    is_bnd[0, :] = True\n    is_bnd[-1, :] = True\n    is_bnd[:, 0] = True\n    is_bnd[:, -1] = True\n    bnd_indices = np.where(is_bnd.flatten())[0]\n\n    # 8. Impose Dirichlet boundary conditions\n    for k in bnd_indices:\n        L_op[k, :] = 0.0\n        L_op[k, k] = 1.0\n        f_flat[k] = u_exact_flat[k]\n        \n    # 9. Solve the linear system\n    u_num_flat = np.linalg.solve(L_op, f_flat)\n    \n    # 10. Reshape solution and calculate error\n    U_num = u_num_flat.reshape((Nx, Ny))\n    max_error = np.max(np.abs(U_num - U_exact))\n    \n    return max_error\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (-1.0, 1.0, -1.0, 1.0, 24, 24,\n         lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y),\n         lambda x, y: -2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)),\n        \n        # Case 2\n        (0.0, 1.0, 0.0, 2.0, 30, 28,\n         lambda x, y: x * (1 - x) * y * (2 - y),\n         lambda x, y: -2 * y * (2 - y) - 2 * x * (1 - x)),\n        \n        # Case 3\n        (-2.0, 3.0, -1.0, 1.0, 22, 18,\n         lambda x, y: np.exp(x) * (1 - y**2),\n         lambda x, y: -np.exp(x) * (1 + y**2)),\n        \n        # Case 4\n        (-1.0, 1.0, -1.0, 1.0, 8, 8,\n         lambda x, y: 0.0 * x * y,\n         lambda x, y: 0.0 * x * y)\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_2d(case)\n        results.append(f\"{error:.10e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2440925"}]}