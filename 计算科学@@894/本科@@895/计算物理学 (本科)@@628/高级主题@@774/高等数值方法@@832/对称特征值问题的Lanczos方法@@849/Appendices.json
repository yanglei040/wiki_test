{"hands_on_practices": [{"introduction": "理论与实践的优雅结合，是计算科学最迷人的特质之一。本练习将引导你揭示Lanczos算法与经典正交多项式理论之间的深刻联系。通过为一个特殊构造的对称三对角矩阵实现Lanczos方法，你将亲手验证该算法生成的三对角矩阵$T_m$的特征多项式如何与Chebyshev多项式精确对应[@problem_id:2406049]。这个过程不仅能加深你对Lanczos三项递推关系核心的理解，更能让你体会到数值方法背后优美的数学结构。", "problem": "您将实现并分析用于实对称特征值问题的 Lanczos 方法，其中使用一个特意构造的测试矩阵，该矩阵的特征多项式与一个经典正交多项式一致。目标是将正交多项式背后的三项递推关系与 Lanczos 过程产生的三对角形式联系起来，并通过一小组测试套件对该构造进行数值验证。\n\n从以下基本原理开始：\n- 实对称矩阵的特征值问题：给定一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其特征值为实数，Lanczos 方法构造一个标准正交 Krylov 基，从而得到一个实对称三对角投影 $T_m \\in \\mathbb{R}^{m \\times m}$，其特征值（Ritz 值）近似于 $A$ 的特征值。\n- 行列式的 Laplace 展开（代数余子式展开），以及三对角矩阵的行列式遵循一个三项递推关系这一事实。\n- 通过三项递推关系在实数轴上定义经典正交多项式。特别是，对于第二类 Chebyshev 多项式 $U_k(x)$，其递推关系为 $U_0(x)=1$，$U_1(x)=2x$，以及当 $k \\ge 2$ 时，$U_k(x)=2x\\,U_{k-1}(x)-U_{k-2}(x)$。\n\n构造一个 $n \\times n$ 的实对称三对角矩阵 $A_n$，其主对角线上的元素为 $0$，第一亚对角线和第一超对角线上的元素为 $1$，即：\n$$\nA_n = \\begin{bmatrix}\n0 & 1 & 0 & \\cdots & 0 \\\\\n1 & 0 & 1 & \\ddots & \\vdots \\\\\n0 & 1 & 0 & \\ddots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & 1 \\\\\n0 & \\cdots & 0 & 1 & 0\n\\end{bmatrix}.\n$$\n从三对角矩阵的行列式展开出发，且不使用任何其他专用公式，推导出 $A_n$ 的特征多项式满足一个三项递推关系，该关系与在缩放后的自变量上求值的第二类 Chebyshev 多项式的递推关系相匹配。结论：$A_n$ 的特征多项式与经过适当缩放的 $U_n(x)$ 精确相等。\n\n为实对称矩阵 $A$ 和非零初始向量 $v_0 \\in \\mathbb{R}^n$ 实现 Lanczos 方法。该算法必须生成张成 m 阶 Krylov 子空间的标准正交向量 $v_1,\\dots,v_m$，以及由三项递推关系产生的三对角矩阵 $T_m$（其对角线元素为 $\\alpha_j$，亚/超对角线元素为 $\\beta_j$）。仅使用标准线性代数运算，并确保用于中断检查的数值稳健性。\n\n对于每个指定的测试用例，您的程序必须执行以下操作：\n\n- 如上所述构建 $A_n$。\n- 从给定的 $v_0$ 开始，运行 $m$ 次 Lanczos 迭代，生成具有元素 $\\{\\alpha_j\\}_{j=1}^m$ 和 $\\{\\beta_j\\}_{j=1}^{m-1}$ 的矩阵 $T_m$。\n- 为进行选定比较，利用 $A_n$ 的特征多项式与第二类 Chebyshev 多项式之间的恒等式，计算 $A_n$ 的精确特征值。使用这些精确特征值为 Ritz 值（$T_m$ 的特征值）定义量化误差度量。\n- 在需要时，使用行列式三项递推关系 $D_0(\\lambda)=1$，$D_1(\\lambda)=\\lambda-\\alpha_1$，以及当 $k \\ge 2$ 时 $D_k(\\lambda)=(\\lambda-\\alpha_k) D_{k-1}(\\lambda)-\\beta_{k-1}^2 D_{k-2}(\\lambda)$，在实数自变量 $\\lambda$ 处计算三对角矩阵 $T_m$ 的特征多项式的值。将其与通过其定义的三项递推关系计算的 $U_m(\\lambda/2)$ 的值进行比较。\n\n使用以下测试套件；所有向量均在 $\\mathbb{R}^n$ 中：\n- 测试用例 $1$：$n=6$, $m=6$, $v_0 = e_1$，其中 $e_1$ 是 $\\mathbb{R}^n$ 中的第一个标准基向量。将结果定义为 $T_m$ 的 Ritz 值与 $A_n$ 的精确特征值之间的最大绝对差。\n- 测试用例 $2$：$n=10$, $m=5$, $v_0 = e_1$。定义两个量：(i) 计算出的 $\\alpha_j$ 与 $0$ 的最大偏差以及计算出的 $\\beta_j$ 与 $1$ 的最大偏差，将这两个最大值中的较大者作为汇总值；以及 (ii) 在区间 $[-2.5,2.5]$ 内的 17 个均匀网格点上，$\\det(\\lambda I - T_m)$ 与 $U_m(\\lambda/2)$ 之间绝对差的最大值，二者均通过三项递推关系求值。此测试用例的结果是这两个量的最大值。\n- 测试用例 $3$：$n=20$, $m=12$, $v_0$ 是一个确定性伪随机向量，其元素从固定种子 $314159$ 的标准正态分布中抽取，然后归一化为单位欧几里得范数。将结果定义为 $T_m$ 的最大 Ritz 值与 $A_n$ 的最大精确特征值之间的绝对差。\n- 测试用例 $4$：$n=8$, $m=1$, $v_0=e_1$。将结果定义为在点集 $\\{-3,-1,0,1,3\\}$ 上 $\\det(\\lambda I - T_1)$ 与 $U_1(\\lambda/2)$ 之间的最大绝对差。\n\n所有答案都是纯数；不涉及物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的十进制数列表，按四个测试用例的顺序排列结果，例如 \"[$r_1, r_2, r_3, r_4$]\"。每个 $r_j$ 都应为一个浮点数。为便于阅读，您可以将结果四舍五入到 $10^{-12}$ 的绝对公差范围内。不应打印任何其他输出。", "solution": "所述问题在科学上是合理的、适定的和客观的。这是数值线性代数中的一个标准练习，将正交多项式理论与 Lanczos 算法的行为联系起来。所有参数和目标都已明确定义。该问题有效。我们继续进行求解。\n\n解决方案分为两个部分：首先，解析推导矩阵 $A_n$ 的特征多项式与第二类 Chebyshev 多项式之间的恒等式；其次，描述 Lanczos 方法的数值实现和对指定测试用例的评估。\n\n**1. 特征多项式的推导**\n\n设 $A_n$ 为 $n \\times n$ 的实对称三对角矩阵，定义为 $(A_n)_{i,i} = 0$，$(A_n)_{i,i+1} = (A_n)_{i+1,i} = 1$，所有其他元素均为 $0$。$A_n$ 的特征多项式为 $p_n(\\lambda) = \\det(\\lambda I_n - A_n)$。矩阵 $\\lambda I_n - A_n$ 为：\n$$\n\\lambda I_n - A_n = \\begin{bmatrix}\n\\lambda & -1 & 0 & \\cdots & 0 \\\\\n-1 & \\lambda & -1 & \\ddots & \\vdots \\\\\n0 & -1 & \\lambda & \\ddots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & -1 \\\\\n0 & \\cdots & 0 & -1 & \\lambda\n\\end{bmatrix}\n$$\n令 $p_k(\\lambda)$ 表示 $\\lambda I_n - A_n$ 的 k 阶主子矩阵（即 $\\lambda I_k - A_k$）的行列式。\n对于 $k \\ge 2$，我们可以沿最后一行使用 Laplace（代数余子式）展开来计算 $p_k(\\lambda)$。这会得到：\n$$\np_k(\\lambda) = \\lambda \\cdot p_{k-1}(\\lambda) - (-1) \\cdot \\det(M_{k,k-1})\n$$\n其中 $M_{k,k-1}$ 是移除第 k 行和第 k-1 列后得到的子矩阵。矩阵 $M_{k,k-1}$ 是一个上三角矩阵，其对角线元素为 $-1, -1, ..., -1$（k-2 个），并在非对角块结构中包含 $p_{k-2}(\\lambda)$。更简单地说，通过沿 $\\lambda I_k - A_k$ 的最后一列展开：\n$$\np_k(\\lambda) = \\lambda \\cdot p_{k-1}(\\lambda) - (-1) \\cdot \\det\\begin{pmatrix} \\lambda I_{k-2}-A_{k-2} & \\mathbf{0} \\\\ \\mathbf{c}^T & -1 \\end{pmatrix}\n$$\n这个分块下三角矩阵的行列式是 $-p_{k-2}(\\lambda)$。一个更直接的对最后一列的展开给出了来自元素 $(k,k)$ 和 $(k-1,k)$ 的项。\n位于 $(k,k)$ 的元素是 $\\lambda$，得到项 $\\lambda \\cdot p_{k-1}(\\lambda)$。\n位于 $(k-1,k)$ 的元素是 $-1$。其代数余子式为 $(-1)^{(k-1)+k}$ 乘以移除第 $k-1$ 行和第 $k$ 列后的矩阵的行列式。该矩阵是一个分块三角矩阵，其行列式为 $-1 \\cdot p_{k-2}(\\lambda)$。\n因此，其贡献为 $(-1) \\cdot (-1)^{2k-1} \\cdot (-p_{k-2}(\\lambda)) = -p_{k-2}(\\lambda)$。\n完整的递推关系为：\n$$\np_k(\\lambda) = \\lambda p_{k-1}(\\lambda) - p_{k-2}(\\lambda) \\quad \\text{for } k \\ge 2.\n$$\n我们建立基准情形：\n$p_1(\\lambda) = \\det([\\lambda]) = \\lambda$。\n$p_2(\\lambda) = \\det \\begin{pmatrix} \\lambda & -1 \\\\ -1 & \\lambda \\end{pmatrix} = \\lambda^2 - 1$。\n为启动该递推，我们需要 $p_0(\\lambda)$ 的值。使用 $k=2$ 时的递推关系：$p_2(\\lambda) = \\lambda p_1(\\lambda) - p_0(\\lambda)$，这意味着 $\\lambda^2 - 1 = \\lambda(\\lambda) - p_0(\\lambda)$，因此我们必须定义 $p_0(\\lambda) = 1$。\n\n现在，考虑由以下递推关系定义的第二类 Chebyshev 多项式 $U_k(x)$：\n$U_0(x)=1$, $U_1(x)=2x$，以及当 $k \\ge 2$ 时，$U_k(x) = 2x U_{k-1}(x) - U_{k-2}(x)$。\n我们进行替换 $\\lambda = 2x$，因此 $x = \\lambda/2$。$p_k(\\lambda)$ 的递推关系变为 $p_k(2x) = 2x p_{k-1}(2x) - p_{k-2}(2x)$。\n这在形式上与 $U_k(x)$ 的递推关系相同。我们检查序列 $\\{p_k(2x)\\}$ 的初始条件是否与 $\\{U_k(x)\\}$ 的初始条件匹配。\n- 对于 $k=0$：$p_0(2x) = 1$，与 $U_0(x)=1$ 匹配。\n- 对于 $k=1$：$p_1(2x) = 2x$，与 $U_1(x)=2x$ 匹配。\n由于递推关系和前两项都相同，我们通过归纳法得出结论，$p_k(2x) = U_k(x)$ 对所有 $k \\ge 0$ 成立。将 $x=\\lambda/2$ 代回，我们就建立了 $A_k$ 的特征多项式的恒等式：\n$$\np_k(\\lambda) = U_k(\\lambda/2).\n$$\n$A_n$ 的特征值是 $p_n(\\lambda) = 0$ 的根，也就是 $U_n(\\lambda/2)=0$ 的根。$U_n(x)$ 的根是 $x_j = \\cos\\left(\\frac{j\\pi}{n+1}\\right)$，其中 $j=1, \\dots, n$。因此，$A_n$ 的精确特征值为 $\\lambda_j = 2x_j = 2\\cos\\left(\\frac{j\\pi}{n+1}\\right)$，其中 $j=1, \\dots, n$。\n\n**2. 数值实现与分析**\n\n该实现包括四个主要部分：\n1. 一个函数，用于为给定维度 $n$ 构建矩阵 $A_n$。\n2. 为一个实对称矩阵 $A$、一个起始向量 $v_0$ 和迭代次数 $m$ 实现 Lanczos 算法。该算法生成三对角矩阵 $T_m$ 的系数 $\\{\\alpha_j\\}_{j=1}^m$ 和 $\\{\\beta_j\\}_{j=1}^{m-1}$。该过程首先对初始向量 $v_0$进行归一化，以获得第一个 Lanczos 向量 $q_1$。\n3. 一个函数，使用三项递推关系 $D_k(\\lambda)=(\\lambda-\\alpha_k) D_{k-1}(\\lambda)-\\beta_{k-1}^2 D_{k-2}(\\lambda)$（初始条件为 $D_0(\\lambda)=1$ 和 $D_1(\\lambda)=\\lambda-\\alpha_1$），在给定点 $\\lambda$ 处计算给定三对角矩阵 $T_k$ 的特征多项式 $\\det(\\lambda I_k - T_k)$ 的值。\n4. 一个函数，使用其定义的递推关系在点 $x$ 处计算 Chebyshev 多项式 $U_k(x)$ 的值。\n\n这些组件用于解决指定的四个测试用例。\n\n- 对于测试用例 1 ($n=6, m=6, v_0=e_1$)，对 $(A_n, e_1)$ 执行 n 步的 Lanczos 算法理论上会产生 $T_n=A_n$。因此，Ritz 值（$T_6$ 的特征值）应在机器精度范围内与 $A_6$ 的精确特征值相匹配。\n- 对于测试用例 2 ($n=10, m=5, v_0=e_1$)，该算法生成 $A_{10}$ 的 $5 \\times 5$ 主子矩阵，即 $A_5$。因此，系数 $\\alpha_j$ 必须为 $0$，$\\beta_j$ 必须为 $1$。$T_5 = A_5$ 的特征多项式恰好是 $U_5(\\lambda/2)$。指定的误差量应都接近于零。\n- 对于测试用例 3 ($n=20, m=12$, $v_0$ 是一个随机向量)，Lanczos 算法提供了一个近似值。$T_{12}$ 的最大 Ritz 值预计将是 $A_{20}$ 最大特征值的一个非常好的近似，因为该方法对极值特征值的收敛最快。\n- 对于测试用例 4 ($n=8, m=1, v_0=e_1$)，执行单步 Lanczos 方法。得到的矩阵是 $T_1 = [\\alpha_1]$。计算得出 $\\alpha_1 = v_1^T A v_1 = e_1^T A_8 e_1 = 0$。因此 $T_1=[0]$，其特征多项式为 $\\det(\\lambda I_1 - T_1) = \\lambda$。这与 $U_1(\\lambda/2) = 2(\\lambda/2) = \\lambda$ 完全相同。其差值在解析上为零。\n\n最终的代码实现了这些过程，并计算了每个测试用例所需的结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes the Lanczos method for a specific real symmetric matrix\n    whose characteristic polynomial corresponds to Chebyshev polynomials.\n    \"\"\"\n\n    def build_A(n):\n        \"\"\"Builds the n x n test matrix A_n.\"\"\"\n        A = np.zeros((n, n), dtype=float)\n        A += np.diag(np.ones(n - 1), k=1)\n        A += np.diag(np.ones(n - 1), k=-1)\n        return A\n\n    def lanczos_gvl(A, v_start, m):\n        \"\"\"\n        Performs m iterations of the Lanczos algorithm.\n        Based on algorithm 10.1.1 from Golub & Van Loan, \"Matrix Computations\" 4th ed.\n        \n        Args:\n            A (np.ndarray): The symmetric matrix.\n            v_start (np.ndarray): The starting vector.\n            m (int): The number of iterations.\n            \n        Returns:\n            tuple[np.ndarray, np.ndarray]: (alphas, betas) for the tridiagonal matrix T_m.\n        \"\"\"\n        n = A.shape[0]\n        q_prev = np.zeros(n, dtype=float)\n        r = v_start.copy()\n        beta = np.linalg.norm(r)\n\n        alphas = np.zeros(m, dtype=float)\n        betas = np.zeros(m - 1, dtype=float)\n\n        for j in range(m):\n            if beta < 1e-15:  # Breakdown check\n                # For this problem, breakdown is not expected.\n                # If it occurs, we would return truncated T matrix coeffs.\n                # Here we assume it runs for m steps successfully.\n                alphas = alphas[:j]\n                betas = betas[:j - 1] if j > 0 else np.array([])\n                break\n\n            q = r / beta\n            u = A @ q\n            alpha = np.dot(q, u)\n            alphas[j] = alpha\n\n            r = u - alpha * q - beta * q_prev\n\n            if j < m - 1:\n                beta_next = np.linalg.norm(r)\n                betas[j] = beta_next\n                beta = beta_next\n            \n            q_prev = q\n\n        return alphas, betas\n\n    def get_exact_eigenvalues(n):\n        \"\"\"Computes the exact eigenvalues of the matrix A_n.\"\"\"\n        j = np.arange(1, n + 1, dtype=float)\n        eigvals = 2 * np.cos(j * np.pi / (n + 1))\n        return np.sort(eigvals)\n\n    def eval_det_poly(alphas, betas, lam):\n        \"\"\"\n        Evaluates the characteristic polynomial det(lambda*I - T) of a tridiagonal matrix T\n        using the three-term recurrence for determinants.\n        \"\"\"\n        m = len(alphas)\n        if m == 0:\n            return 1.0\n        \n        d_prev = 1.0  # D_0(lambda)\n        d_curr = lam - alphas[0]  # D_1(lambda)\n\n        for k in range(1, m):\n            beta_sq = betas[k-1]**2\n            d_next = (lam - alphas[k]) * d_curr - beta_sq * d_prev\n            d_prev = d_curr\n            d_curr = d_next\n            \n        return d_curr\n\n    def eval_U(k, x):\n        \"\"\"\n        Evaluates the Chebyshev polynomial of the second kind U_k(x) via its recurrence relation.\n        \"\"\"\n        if k == 0:\n            return 1.0\n        if k == 1:\n            return 2.0 * x\n        \n        u_prev = 1.0  # U_0\n        u_curr = 2.0 * x  # U_1\n        \n        for _ in range(2, k + 1):\n            u_next = 2.0 * x * u_curr - u_prev\n            u_prev = u_curr\n            u_curr = u_next\n            \n        return u_curr\n\n    test_cases = [\n        {'n': 6, 'm': 6, 'v0_type': 'e1'},\n        {'n': 10, 'm': 5, 'v0_type': 'e1'},\n        {'n': 20, 'm': 12, 'v0_type': 'random', 'seed': 314159},\n        {'n': 8, 'm': 1, 'v0_type': 'e1'}\n    ]\n    results = []\n\n    # Test Case 1\n    params = test_cases[0]\n    n, m = params['n'], params['m']\n    A = build_A(n)\n    v0 = np.zeros(n)\n    v0[0] = 1.0\n    alphas, betas = lanczos_gvl(A, v0, m)\n    T_m = np.diag(alphas) + np.diag(betas, k=1) + np.diag(betas, k=-1)\n    ritz_values = np.linalg.eigvalsh(T_m)\n    exact_eigvals = get_exact_eigenvalues(n)\n    res1 = np.max(np.abs(ritz_values - exact_eigvals))\n    results.append(res1)\n\n    # Test Case 2\n    params = test_cases[1]\n    n, m = params['n'], params['m']\n    A = build_A(n)\n    v0 = np.zeros(n)\n    v0[0] = 1.0\n    alphas, betas = lanczos_gvl(A, v0, m)\n    \n    max_dev_alpha = np.max(np.abs(alphas)) if len(alphas) > 0 else 0.0\n    max_dev_beta = np.max(np.abs(betas - 1.0)) if len(betas) > 0 else 0.0\n    q1 = max(max_dev_alpha, max_dev_beta)\n    \n    grid = np.linspace(-2.5, 2.5, 17)\n    max_diff_poly = 0.0\n    for lam in grid:\n        det_val = eval_det_poly(alphas, betas, lam)\n        cheby_val = eval_U(m, lam / 2.0)\n        max_diff_poly = max(max_diff_poly, np.abs(det_val - cheby_val))\n    \n    res2 = max(q1, max_diff_poly)\n    results.append(res2)\n\n    # Test Case 3\n    params = test_cases[2]\n    n, m, seed = params['n'], params['m'], params['seed']\n    A = build_A(n)\n    rng = np.random.default_rng(seed)\n    v0_unnormalized = rng.standard_normal(n)\n    v0 = v0_unnormalized / np.linalg.norm(v0_unnormalized)\n    \n    alphas, betas = lanczos_gvl(A, v0, m)\n    T_m = np.diag(alphas) + np.diag(betas, k=1) + np.diag(betas, k=-1)\n    ritz_values = np.linalg.eigvalsh(T_m)\n    exact_eigvals = get_exact_eigenvalues(n)\n    \n    max_ritz = np.max(ritz_values)\n    max_exact = np.max(exact_eigvals)\n    res3 = np.abs(max_ritz - max_exact)\n    results.append(res3)\n\n    # Test Case 4\n    params = test_cases[3]\n    n, m = params['n'], params['m']\n    A = build_A(n)\n    v0 = np.zeros(n)\n    v0[0] = 1.0\n    alphas, betas = lanczos_gvl(A, v0, m)\n    \n    test_points = np.array([-3.0, -1.0, 0.0, 1.0, 3.0])\n    max_diff_poly = 0.0\n    for lam in test_points:\n        det_val = eval_det_poly(alphas, betas, lam)\n        cheby_val = eval_U(m, lam / 2.0)\n        max_diff_poly = max(max_diff_poly, np.abs(det_val - cheby_val))\n    \n    res4 = max_diff_poly\n    results.append(res4)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2406049"}, {"introduction": "Lanczos算法能够高效地生成近似特征值（即Ritz值），但这些近似的精度如何？收敛速度有多快？本练习将通过数值验证著名的Kaniel-Paige-Saad（KPS）收敛界，来回答这些关键问题[@problem_id:2406031]。你将计算真实的近似误差$e_{m} = \\lambda_{1} - \\theta_{1}^{(m)}$，并将其与理论上界$B_{m}$进行比较，从而直观地理解初始向量的选择和矩阵的谱分布如何影响算法的收敛性能。这个实践是连接算法理论与其实际表现的重要桥梁。", "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实对称矩阵，其特征值为 $\\lambda_{1} \\ge \\lambda_{2} \\ge \\cdots \\ge \\lambda_{n}$，并拥有一组标准正交特征基 $\\{u_{i}\\}_{i=1}^{n}$。对于一个非零初始向量 $v \\in \\mathbb{R}^{n}$，定义 $m \\in \\mathbb{N}$ 阶克雷洛夫子空间为\n$$\n\\mathcal{K}_{m}(A,v) = \\operatorname{span}\\{v, Av, A^{2}v, \\dots, A^{m-1}v\\}。\n$$\n$A$ 在 $\\mathcal{K}_{m}(A,v)$ 中的最大里兹值为\n$$\n\\theta_{1}^{(m)} = \\max_{x \\in \\mathcal{K}_{m}(A,v),\\, x \\ne 0} \\frac{x^{\\top} A x}{x^{\\top} x}。\n$$\n将单位范数初始向量写作 $v / \\|v\\|_{2} = \\sum_{i=1}^{n} \\alpha_{i} u_{i}$，并定义角度 $\\phi \\in [0,\\tfrac{\\pi}{2})$，满足 $\\tan \\phi = \\sqrt{\\sum_{i=2}^{n} \\alpha_{i}^{2}} / |\\alpha_{1}|$。定义\n$$\nc = \\frac{\\lambda_{2} + \\lambda_{n}}{2}, \\quad d = \\frac{\\lambda_{2} - \\lambda_{n}}{2}, \\quad t = \\frac{\\lambda_{1} - c}{d},\n$$\n并令 $T_{k}(x)$ 为 $k$ 次第一类切比雪夫多项式，对于 $x \\ge 1$ 定义为 $T_{k}(x) = \\cosh(k \\operatorname{arccosh}(x))$。最大里兹值误差的 Kaniel–Paige–Saad (KPS) 界为\n$$\n0 \\le \\lambda_{1} - \\theta_{1}^{(m)} \\le \\frac{\\left(\\lambda_{1} - \\lambda_{n}\\right) \\tan^{2}\\phi}{\\left[T_{m-1}(t)\\right]^{2}}。\n$$\n\n任务。对于下方的每个测试用例，以及每个列出的子空间阶数 $m$，数值计算最大里兹值 $\\theta_{1}^{(m)}$、误差 $e_{m} = \\lambda_{1} - \\theta_{1}^{(m)}$ 以及 KPS 界\n$$\nB_{m} = \\frac{\\left(\\lambda_{1} - \\lambda_{n}\\right) \\tan^{2}\\phi}{\\left[T_{m-1}(t)\\right]^{2}}。\n$$\n对该测试指定的集合中的所有 $m$，评估不等式 $e_{m} \\le B_{m} + \\tau$ 是否在绝对容差 $\\tau = 10^{-10}$ 下成立。为每个测试用例报告一个布尔值，指示该不等式是否对其所有的 $m$ 值都成立。在使用前，将每个初始向量 $v$ 归一化为单位欧几里得范数。角度以弧度为单位。\n\n测试套件。使用以下矩阵 $A$、初始向量 $v$ 和子空间维度集合 $M$：\n\n1. 用例 A：$n = 4$，$A = \\operatorname{diag}([5, 3, 1, -2])$，$v = [0.2, 0.5, 0.3, 0.4]$，$M = \\{1, 2, 3\\}$。\n2. 用例 B：$n = 6$，$A = \\operatorname{diag}([2.0, 1.999, 1.5, 0.5, 0.0, -1.0])$，$v = [1, 1, 1, 1, 1, 1]$，$M = \\{1, 2, 3, 4\\}$。\n3. 用例 C：$n = 5$，$A$ 是一个三对角矩阵，其元素为 $A_{ii} = 2$ (对 $i \\in \\{1, 2, 3, 4, 5\\}$)，$A_{i,i+1} = A_{i+1,i} = -1$ (对 $i \\in \\{1, 2, 3, 4\\}$)，其他 $A_{ij} = 0$, $v = [1, 2, 3, 4, 5]$, $M = \\{1, 2, 3, 4\\}$。\n4. 用例 D：$n = 5$，$A = \\operatorname{diag}([10.0, 1.0, 0.5, 0.2, 0.1])$，$v = [10^{-3}, 1.0, 0.0, 0.0, 0.0]$，$M = \\{1, 2, 3\\}$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[true_case_A, true_case_B, true_case_C, true_case_D]”）。每个条目必须是对应案例的布尔真值，按 A、B、C、D 的顺序排列，并使用编程语言的规范布尔字面量。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于数值线性代数的既定理论，特别是兰索斯方法及其对对称特征问题的收敛性质。该问题是适定的，提供了所有必要的定义、数据和约束，以得出唯一、可验证的解。其语言客观且数学上精确。因此，将提供一个解。\n\n问题的核心是数值验证通过兰索斯算法计算出的最大里兹值的 Kaniel–Paige–Saad (KPS) 误差界。这需要实现兰索斯过程以找到里兹值，然后计算理论界限以进行比较。\n\n首先，让我们形式化求取最大里兹值 $\\theta_{1}^{(m)}$ 的过程。兰索斯算法是一种迭代方法，它为克雷洛夫子空间 $\\mathcal{K}_{m}(A,v) = \\operatorname{span}\\{v, Av, \\dots, A^{m-1}v\\}$ 生成一个标准正交基。设 $v_1$ 是归一化为单位欧几里得范数的初始向量 $v$，即 $v_1 = v/\\|v\\|_2$。该算法生成一个标准正交向量序列 $\\{q_j\\}_{j=1}^m$，构成 $\\mathcal{K}_m(A, v_1)$ 的一个基。此过程的一个关键属性是，矩阵 $A$ 在此子空间上的投影（在基 $\\{q_j\\}$ 中表示）是一个 $m \\times m$ 的实对称三对角矩阵 $T_m$。\n$$\nT_m = Q_m^\\top A Q_m = \\begin{pmatrix}\n\\alpha_1 & \\beta_1 & & \\\\\n\\beta_1 & \\alpha_2 & \\ddots & \\\\\n& \\ddots & \\ddots & \\beta_{m-1} \\\\\n& & \\beta_{m-1} & \\alpha_m\n\\end{pmatrix}\n$$\n其中 $Q_m = [q_1, q_2, \\dots, q_m]$。对角线元素 $\\alpha_j$ 和非对角线元素 $\\beta_j$ 由兰索斯迭代核心的三项递推关系生成：\n$$\n\\beta_j q_{j+1} = A q_j - \\alpha_j q_j - \\beta_{j-1} q_{j-1}\n$$\n其中 $\\alpha_j = q_j^\\top A q_j$ 且 $\\beta_j = \\|A q_j - \\alpha_j q_j - \\beta_{j-1} q_{j-1}\\|_2$。我们用 $q_1 = v_1$、$\\beta_0=0$ 和 $q_0=0$ 进行初始化。\n\n这个三对角矩阵 $T_m$ 的特征值就是 $A$ 在子空间 $\\mathcal{K}_m(A,v)$ 中的里兹值。最大里兹值 $\\theta_{1}^{(m)}$ 就是 $T_m$ 的最大特征值。我们必须为每个指定的阶数 $m$ 计算这个值。\n\n其次，我们评估 KPS 界 $B_m$。其公式为：\n$$\nB_m = \\frac{(\\lambda_{1} - \\lambda_{n}) \\tan^{2}\\phi}{[T_{m-1}(t)]^{2}}\n$$\n为计算 $B_m$，我们需要从 $A$ 的特征系统中导出几个量：\n1.  $A$ 的特征值，按 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_n$ 排序。我们将计算 $A$ 的完整特征系统以获得所有的 $\\lambda_i$ 和相应的标准正交特征向量 $u_i$。对于给定的矩阵 $A$，这是一个标准的数值计算任务。\n2.  角度 $\\phi$，通过 $\\tan \\phi$ 定义。初始归一化向量 $v_1 = v/\\|v\\|_2$ 可以在 $A$ 的特征基中表示为 $v_1 = \\sum_{i=1}^{n} \\alpha_{i} u_{i}$。系数 $\\alpha_1$ 是 $v_1$ 在对应于最大特征值 $\\lambda_1$ 的特征向量 $u_1$ 上的投影，即 $\\alpha_1 = u_1^\\top v_1$。由于 $\\{u_i\\}$ 是一个标准正交基，$\\sum_{i=1}^n \\alpha_i^2 = \\|v_1\\|_2^2 = 1$。因此，项 $\\sum_{i=2}^{n} \\alpha_{i}^{2}$ 等于 $1 - \\alpha_1^2$。$\\tan^2 \\phi$ 的表达式简化为：\n    $$\n    \\tan^2\\phi = \\frac{\\sum_{i=2}^{n} \\alpha_{i}^{2}}{\\alpha_{1}^{2}} = \\frac{1 - \\alpha_1^2}{\\alpha_1^2}\n    $$\n    这是有效的，因为问题陈述中说明 $\\phi \\in [0, \\pi/2)$，这意味着 $\\alpha_1 \\ne 0$。\n3.  参数 $c = (\\lambda_2 + \\lambda_n)/2$ 和 $d = (\\lambda_2 - \\lambda_n)/2$，它们定义了一个条件参数 $t = (\\lambda_1 - c)/d$。由于 $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_n$，可以证明 $t = 1 + 2(\\lambda_1 - \\lambda_2)/(\\lambda_2 - \\lambda_n) \\ge 1$（前提是 $\\lambda_2 > \\lambda_n$，这对所有测试用例都成立）。\n4.  $k=m-1$ 次的第一类切比雪夫多项式 $T_{m-1}(t)$。对于 $t \\ge 1$，其表达式为 $T_k(t) = \\cosh(k \\operatorname{arccosh}(t))$。\n\n每个测试用例 $(A, v, M)$ 的总体流程如下：\n\n1.  给定 $A$，计算其完整特征系统以找到特征值 $\\lambda_i$ 和特征向量 $u_i$。对它们进行排序，使得 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_n$，并且特征向量矩阵的列与此顺序相对应。\n2.  归一化初始向量：$v_1 = v / \\|v\\|_2$。\n3.  计算 KPS 界的参数：\n    -   $\\alpha_1 = u_1^\\top v_1$。\n    -   $\\tan^2\\phi = (1 - \\alpha_1^2) / \\alpha_1^2$。\n    -   $c = (\\lambda_2 + \\lambda_n)/2$。\n    -   $d = (\\lambda_2 - \\lambda_n)/2$。\n    -   $t = (\\lambda_1 - c)/d$。\n4.  初始化一个布尔标志，`case_holds = true`。\n5.  遍历每个子空间阶数 $m \\in M$：\n    a. 从 $v_1$ 开始，执行 $m$ 步兰索斯算法，以生成三对角矩阵 $T_m$。\n    b. 计算 $T_m$ 的特征值。其中最大者即为里兹值 $\\theta_1^{(m)}$。\n    c. 计算真实误差 $e_m = \\lambda_1 - \\theta_1^{(m)}$。\n    d. 计算切比雪夫多项式的值 $T_{m-1}(t) = \\cosh((m-1)\\operatorname{arccosh}(t))$。\n    e. 计算 KPS 界 $B_m = (\\lambda_1 - \\lambda_n) \\tan^2\\phi / [T_{m-1}(t)]^2$。\n    f. 检查条件 $e_m \\le B_m + \\tau$ 是否在容差 $\\tau=10^{-10}$ 下成立。如果不成立，则设置 `case_holds = false` 并终止此测试用例的迭代。\n6.  该测试用例的最终结果是 `case_holds` 的值。然后为所有提供的测试用例重复此整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef build_tridiag_case_c():\n    \"\"\"Builds the specific tridiagonal matrix for Case C.\"\"\"\n    n = 5\n    A = np.zeros((n, n))\n    np.fill_diagonal(A, 2.0)\n    off_diag = np.full(n - 1, -1.0)\n    A += np.diag(off_diag, k=1)\n    A += np.diag(off_diag, k=-1)\n    return A\n\ndef chebyshev_T(k, x):\n    \"\"\"\n    Computes the Chebyshev polynomial of the first kind T_k(x) for x >= 1.\n    \"\"\"\n    if k == 0:\n        return 1.0\n    # Guard against float-point error making x slightly less than 1\n    if x < 1.0:\n        x = 1.0\n    return np.cosh(k * np.arccosh(x))\n\ndef lanczos_iteration(A, v_start, m):\n    \"\"\"\n    Performs m steps of the Lanczos iteration.\n    Returns the diagonal (alpha) and off-diagonal (beta) elements of the\n    tridiagonal matrix T_m.\n    \"\"\"\n    n = A.shape[0]\n    q = np.zeros((n, m + 1))\n    alphas = np.zeros(m)\n    betas = np.zeros(m) # betas[0] is beta_1, etc.\n\n    q[:, 0] = v_start / np.linalg.norm(v_start)\n    \n    # Lanczos 3-term recurrence\n    w_prime = A @ q[:, 0]\n    alphas[0] = q[:, 0].T @ w_prime\n    w = w_prime - alphas[0] * q[:, 0]\n    \n    for j in range(1, m):\n        betas[j-1] = np.linalg.norm(w)\n        if betas[j-1] < 1e-14: # Lucky breakdown\n             # The rest of T_m will be zero, we can stop early\n             # and return the smaller matrix's components\n             return alphas[:j], betas[:j-1]\n        \n        q[:, j] = w / betas[j-1]\n        \n        w_prime = A @ q[:, j]\n        alphas[j] = q[:, j].T @ w_prime\n        w = w_prime - alphas[j] * q[:, j] - betas[j-1] * q[:, j-1]\n\n    return alphas, betas[:-1]\n\n\ndef process_case(A, v, M, tau):\n    \"\"\"\n    Processes a single test case to verify the KPS bound.\n    \"\"\"\n    n = A.shape[0]\n    \n    # 1. Eigendecomposition of A\n    evals, evecs = np.linalg.eigh(A)\n    sort_indices = np.argsort(evals)[::-1]\n    evals = evals[sort_indices]\n    evecs = evecs[:, sort_indices]\n    \n    lambda_1 = evals[0]\n    lambda_2 = evals[1]\n    lambda_n = evals[n-1]\n    u_1 = evecs[:, 0]\n\n    # 2. Normalize starting vector\n    v_norm = v / np.linalg.norm(v)\n\n    # 3. Calculate KPS bound parameters\n    alpha_1 = np.abs(u_1.T @ v_norm)\n    if alpha_1 < 1e-15: # Starting vector is orthogonal to u_1\n        # The bound is infinite, so the inequality holds trivially.\n        return True\n        \n    tan_sq_phi = (1 - alpha_1**2) / alpha_1**2\n    \n    if abs(lambda_2 - lambda_n) < 1e-15:\n        # All eigenvalues except lambda_1 are clustered. The bound is not well-defined/infinite.\n        # This implies any finite error is below an infinite bound.\n        return True\n\n    c = (lambda_2 + lambda_n) / 2.0\n    d = (lambda_2 - lambda_n) / 2.0\n    t = (lambda_1 - c) / d\n\n    # 4. Iterate over subspace dimensions m\n    for m in M:\n        # 5a. Lanczos iteration\n        alphas, betas = lanczos_iteration(A, v_norm, m)\n\n        # 5b. Compute largest Ritz value\n        if m == 1:\n            ritz_vals = np.array([alphas[0]])\n        else:\n            ritz_vals = eigh_tridiagonal(alphas, betas, eigvals_only=True)\n        theta_1_m = np.max(ritz_vals)\n\n        # 5c. Compute error\n        e_m = lambda_1 - theta_1_m\n\n        # 5d/e. Compute KPS bound\n        T_m_minus_1_val = chebyshev_T(m - 1, t)\n        if abs(T_m_minus_1_val) < 1e-15:\n             # Bound is infinite, inequality holds\n             B_m = np.inf\n        else:\n             B_m = ((lambda_1 - lambda_n) * tan_sq_phi) / (T_m_minus_1_val**2)\n\n        # 5f. Check inequality\n        if not (e_m <= B_m + tau):\n            return False\n\n    return True\n\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    tau = 1e-10\n\n    test_cases = [\n        {\n            \"A\": np.diag(np.array([5, 3, 1, -2], dtype=float)),\n            \"v\": np.array([0.2, 0.5, 0.3, 0.4], dtype=float),\n            \"M\": {1, 2, 3},\n        },\n        {\n            \"A\": np.diag(np.array([2.0, 1.999, 1.5, 0.5, 0.0, -1.0], dtype=float)),\n            \"v\": np.ones(6, dtype=float),\n            \"M\": {1, 2, 3, 4},\n        },\n        {\n            \"A\": build_tridiag_case_c(),\n            \"v\": np.array([1, 2, 3, 4, 5], dtype=float),\n            \"M\": {1, 2, 3, 4},\n        },\n        {\n            \"A\": np.diag(np.array([10.0, 1.0, 0.5, 0.2, 0.1], dtype=float)),\n            \"v\": np.array([1e-3, 1.0, 0.0, 0.0, 0.0], dtype=float),\n            \"M\": {1, 2, 3},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"A\"], case[\"v\"], case[\"M\"], tau)\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2406031"}, {"introduction": "一个算法从理论模型走向实用工具，关键在于鲁棒的实现细节，其中最重要的就是何时终止迭代。本练习将指导你为Lanczos算法开发一个实际且高效的终止准则[@problem_id:2406056]。你将学习如何基于Ritz对$(\\theta_{i}^{(k)}, y_{i}^{(k)})$的残差范数$\\|r_{i}^{(k)}\\|_{2}$来判断收敛性，并利用一个巧妙的公式$|\\beta_{k+1}| \\cdot |u_{i,k}^{(k)}|$来高效地计算它，从而避免高昂的计算成本。完成这个练习，你将把一个基础的Lanczos迭代过程，升级为一个能够根据预设精度要求自动停止的智能求解器。", "problem": "给定一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个非零起始向量 $v_{1} \\in \\mathbb{R}^{n}$（其 $\\|v_{1}\\|_{2} = 1$），考虑 $k$ 维克雷洛夫子空间 $\\mathcal{K}_{k}(A, v_{1}) = \\mathrm{span}\\{v_{1}, A v_{1}, \\ldots, A^{k-1} v_{1}\\}$。设 $Q_{k} \\in \\mathbb{R}^{n \\times k}$ 具有构成 $\\mathcal{K}_{k}(A, v_{1})$ 的一个基的标准正交列，并设 $T_{k} = Q_{k}^{\\top} A Q_{k} \\in \\mathbb{R}^{k \\times k}$ 是 $A$ 在 $\\mathcal{K}_{k}(A, v_{1})$ 上的 Rayleigh–Ritz 投影。用 $(\\theta_{i}^{(k)}, u_{i}^{(k)})$ 表示 $T_{k}$ 的特征对（其中 $\\|u_{i}^{(k)}\\|_{2} = 1$），并通过 $y_{i}^{(k)} = Q_k u_{i}^{(k)})$（其中 $\\|y_{i}^{(k)}\\|_{2} = 1$）定义在原始空间中对应的里兹向量。对于每个里兹对 $(\\theta_{i}^{(k)}, y_{i}^{(k)})$，定义残差 $r_{i}^{(k)} = A y_{i}^{(k)} - \\theta_{i}^{(k)} y_{i}^{(k)}$ 及其范数 $\\|r_{i}^{(k)}\\|_{2}$。\n\n开发一个鲁棒的终止准则，当不等式\n$$\n\\|r_{i}^{(k)}\\|_{2} \\leq \\max\\big(\\mathrm{atol}, \\ \\mathrm{rtol} \\cdot \\max(1, |\\theta_{i}^{(k)}|)\\big)\\, \\|A\\|_{2}\n$$\n成立时，接受一个里兹对 $(\\theta_{i}^{(k)}, y_{i}^{(k)})$。其中 $\\mathrm{rtol} > 0$ 和 $\\mathrm{atol} \\ge 0$ 是用户指定的容差，$\\|A\\|_{2}$ 表示谱范数（即最大奇异值，对于对称矩阵 $A$，它等于最大的特征值绝对值）。对于给定的目标规范，令 $\\mathcal{I}_{k}$ 表示根据目标规则选择的 $r$ 个里兹值的索引集：\n- 如果目标是“最小”，则 $\\mathcal{I}_{k}$ 包含 $\\{\\theta_{i}^{(k)}\\}_{i=1}^{k}$ 中 $r$ 个代数上最小的里兹值的索引。\n- 如果目标是“最大”，则 $\\mathcal{I}_{k}$ 包含 $\\{\\theta_{i}^{(k)}\\}_{i=1}^{k}$ 中 $r$ 个代数上最大的里兹值的索引。\n\n将最小迭代次数 $k_{\\mathrm{acc}}$ 定义为满足以下条件的最小 $k \\in \\{1, 2, \\ldots, k_{\\max}\\}$：目标集 $\\mathcal{I}_{k}$ 中至少有 $r$ 个里兹对满足上述接受不等式。如果在 $k_{\\max}$ 之前不存在这样的 $k$，则定义 $k_{\\mathrm{acc}} = -1$。\n\n实现一个程序，对于下述每个测试用例，该程序构造指定的对称矩阵 $A$，使用分量为 $v_{1,j} = 1$（$j \\in \\{1,\\ldots,n\\}$）并归一化为单位 2-范数的起始向量 $v_1$，并返回相应的 $k_{\\mathrm{acc}}$ 值。\n\n测试套件：\n- 测试用例 1：$A$ 是大小为 $n = 50$ 的一维离散狄利克雷拉普拉斯算子，即一个对角线元素为 2、次对角线和超对角线元素为 -1 的三对角矩阵。目标：“最小”，$r = 2$。容差：$\\mathrm{rtol} = 10^{-8}$，$\\mathrm{atol} = 10^{-12}$。最大迭代次数 $k_{\\max} = 50$。\n- 测试用例 2：$A$ 是大小为 $n = 60$ 的对称托普利茨矩阵，定义为 $A_{ij} = \\exp\\!\\big(-((i-j)/\\sigma)^{2}\\big)$，其中 $\\sigma = 5$。目标：“最大”，$r = 1$。容差：$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-10}$。最大迭代次数 $k_{\\max} = 60$。\n- 测试用例 3：$A = c I$，其中 $c = 7$ 且大小为 $n = 20$。目标：“最小”，$r = 1$。容差：$\\mathrm{rtol} = 10^{-12}$，$\\mathrm{atol} = 0$。最大迭代次数 $k_{\\max} = 5$。\n- 测试用例 4：$A$ 是大小为 $n = 40$ 的一维离散狄利克雷拉普拉斯算子。目标：“最小”，$r = 1$。容差：$\\mathrm{rtol} = 10^{-14}$，$\\mathrm{atol} = 0$。最大迭代次数 $k_{\\max} = 5$。\n\n您的程序应生成单行输出，其中包含四个值 $[k_{\\mathrm{acc}}^{(1)}, k_{\\mathrm{acc}}^{(2)}, k_{\\mathrm{acc}}^{(3)}, k_{\\mathrm{acc}}^{(4)}]$，以逗号分隔的列表形式并用方括号括起来，顺序同上。每个 $k_{\\mathrm{acc}}^{(t)}$ 必须是一个整数，其中 $-1$ 表示在为测试用例 $t$ 规定的 $k_{\\max}$ 次迭代内未发生接受。", "solution": "所述问题是计算物理和数值线性代数领域一个定义明确的练习。它涉及 Lanczos 算法的实现，该算法用于寻找实对称矩阵的特征值，并结合了一个基于残差范数的实用终止准则。所有参数和矩阵都得到了明确的指定，该问题在科学上是合理的，其依据是矩阵计算的基本原理。因此，该问题是有效的，我们将继续提供完整的解决方案。\n\n问题的核心是 Lanczos 算法。对于给定的实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和起始向量 $v_1$（$\\|v_1\\|_2 = 1$），该算法迭代地为克雷洛夫子空间 $\\mathcal{K}_k(A, v_1) = \\mathrm{span}\\{v_1, A v_1, \\ldots, A^{k-1} v_1\\}$ 构建一个标准正交基 $\\{v_1, v_2, \\ldots, v_k\\}$。这些基向量构成的矩阵是 $Q_k = [v_1 | v_2 | \\ldots | v_k] \\in \\mathbb{R}^{n \\times k}$。\n\n该过程由一个三项递推关系控制：\n$$\n\\beta_{j+1} v_{j+1} = A v_j - \\alpha_j v_j - \\beta_j v_{j-1}\n$$\n初始条件为 $v_0 = 0$ 和 $\\beta_1 = 0$。系数确定为 $\\alpha_j = v_j^\\top A v_j$ 和 $\\beta_{j+1} = \\|A v_j - \\alpha_j v_j - \\beta_j v_{j-1}\\|_2$。这些系数构成一个对称三对角矩阵 $T_k \\in \\mathbb{R}^{k \\times k}$：\n$$\nT_k = Q_k^\\top A Q_k = \\begin{pmatrix}\n\\alpha_1 & \\beta_2 & & \\\\\n\\beta_2 & \\alpha_2 & \\ddots & \\\\\n& \\ddots & \\ddots & \\beta_k \\\\\n& & \\beta_k & \\alpha_k\n\\end{pmatrix}\n$$\n这个小矩阵 $T_k$ 的特征对 $(\\theta_i^{(k)}, u_i^{(k)})$ 被称为里兹对。里兹值 $\\theta_i^{(k)}$ 是 $A$ 的特征值的近似值，而里兹向量 $y_i^{(k)} = Q_k u_i^{(k)}$ 是 $A$ 相应特征向量的近似值。\n\n高效实现的一个关键部分是计算残差范数 $\\|r_i^{(k)}\\|_2 = \\|A y_i^{(k)} - \\theta_i^{(k)} y_i^{(k)}\\|_2$。朴素的计算方法计算成本高昂。相反，我们利用 Lanczos 分解的一个基本性质，$A Q_k = Q_k T_k + \\beta_{k+1} v_{k+1} e_k^\\top$，其中 $e_k$ 是 $\\mathbb{R}^k$ 中的第 $k$ 个标准基向量。通过代入 $y_i^{(k)} = Q_k u_i^{(k)}$ 并使用特征关系 $T_k u_i^{(k)} = \\theta_i^{(k)} u_i^{(k)}$，我们推导出：\n$$\nA y_i^{(k)} = A (Q_k u_i^{(k)}) = (Q_k T_k + \\beta_{k+1} v_{k+1} e_k^\\top) u_i^{(k)} = Q_k (T_k u_i^{(k)}) + \\beta_{k+1} v_{k+1} (e_k^\\top u_i^{(k)})\n$$\n$$\nA y_i^{(k)} = Q_k (\\theta_i^{(k)} u_i^{(k)}) + \\beta_{k+1} u_{i,k}^{(k)} v_{k+1} = \\theta_i^{(k)} (Q_k u_i^{(k)}) + \\beta_{k+1} u_{i,k}^{(k)} v_{k+1}\n$$\n其中 $u_{i,k}^{(k)}$ 是特征向量 $u_i^{(k)}$ 的第 $k$ 个（最后一个）分量。因此，残差向量为 $r_i^{(k)} = A y_i^{(k)} - \\theta_i^{(k)} y_i^{(k)} = \\beta_{k+1} u_{i,k}^{(k)} v_{k+1}$。由于 Lanczos 向量是标准正交的，残差范数可以优雅地简化为：\n$$\n\\|r_i^{(k)}\\|_2 = |\\beta_{k+1}| \\cdot |u_{i,k}^{(k)}|\n$$\n这个公式提供了一种计算成本低廉的方法，用于在每次迭代 $k$ 时检查终止准则。\n\n找到最小迭代次数 $k_{\\mathrm{acc}}$ 的整体算法如下：\n1. 对于每个测试用例，构造矩阵 $A$ 和归一化后的起始向量 $v_1$。\n2. 计算谱范数 $\\|A\\|_2$。对于对称矩阵，此范数为 $\\max(|\\lambda_{\\min}|, |\\lambda_{\\max}|)$。\n3. 对 $k$ 从 $1$ 到 $k_{\\max}$ 进行迭代。在每次迭代中：\n    a. 执行一步 Lanczos 算法计算 $\\alpha_k$ 和 $\\beta_{k+1}$，将三对角矩阵 $T_{k-1}$ 扩展为 $T_k$。\n    b. 求解 $k \\times k$ 矩阵 $T_k$ 的特征问题，以获得其完整的里兹对集合 $\\{(\\theta_i^{(k)}, u_i^{(k)})\\}_{i=1}^k$。为此，我们使用一个专门为对称三对角矩阵设计的高效求解器。\n    c. 根据测试用例中指定的“smallest”或“largest”准则，识别出 $r$ 个目标里兹对。\n    d. 对于这 $r$ 个目标对中的每一个，使用公式 $\\|r_i^{(k)}\\|_2 = |\\beta_{k+1}| |u_{i,k}^{(k)}|$ 计算残差范数。\n    e. 将此范数与阈值 $\\tau_i^{(k)} = \\max(\\mathrm{atol}, \\mathrm{rtol} \\cdot \\max(1, |\\theta_i^{(k)}|)) \\cdot \\|A\\|_2$ 进行比较。\n    f. 统计满足 $\\|r_i^{(k)}\\|_2 \\leq \\tau_i^{(k)}$ 的目标对的数量。\n4. 如果该计数大于或等于 $r$，则当前迭代次数 $k$ 即为答案 $k_{\\mathrm{acc}}$。此测试用例的搜索完成。\n5. 如果循环在 $k \\le k_{\\max}$ 的范围内结束而未满足条件，则 $k_{\\mathrm{acc}} = -1$。\n对所有四个测试用例重复此过程，以获得最终的结果向量。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef calculate_k_acc(A, v1_unnormalized, r, target, rtol, atol, k_max):\n    \"\"\"\n    Calculates the minimal Lanczos iteration count k_acc for convergence.\n    \"\"\"\n    n = A.shape[0]\n    \n    # Normalize the starting vector to have a 2-norm of 1.\n    v1 = v1_unnormalized / np.linalg.norm(v1_unnormalized)\n\n    # Pre-compute the spectral norm of A for the tolerance calculation.\n    norm_A = np.linalg.norm(A, 2)\n    \n    # Lists to store Lanczos coefficients\n    alphas = []\n    betas_offdiag = []  # Stores beta_2, beta_3, ... for T_k's off-diagonal\n\n    # Lanczos algorithm initialization\n    v_prev = np.zeros(n)\n    v_curr = v1\n    beta_curr = 0.0  # beta_1 is defined as 0\n\n    for k in range(1, k_max + 1):\n        # Perform one step of the Lanczos iteration\n        w = A @ v_curr - beta_curr * v_prev\n        \n        alpha_curr = np.dot(v_curr, w)\n        alphas.append(alpha_curr)\n        \n        w -= alpha_curr * v_curr\n        \n        v_prev = v_curr\n        beta_next = np.linalg.norm(w)\n        \n        # At iteration k, we have T_k of size k x k.\n        # Its diagonal is 'alphas' (k elements).\n        # Its off-diagonal is 'betas_offdiag' (k-1 elements).\n        diag = np.array(alphas)\n        \n        if k == 1:\n            ritz_values = diag\n            # Eigenvector of a 1x1 matrix is [1].\n            ritz_vecs = np.array([[1.0]])\n        else:\n            offdiag = np.array(betas_offdiag)\n            # eigh_tridiagonal is efficient for this task and returns sorted eigenvalues.\n            ritz_values, ritz_vecs = eigh_tridiagonal(diag, offdiag, eigvals_only=False)\n        \n        # Only check for convergence if we have at least r Ritz values.\n        if k >= r:\n            # Identify the indices of the r target Ritz pairs.\n            if target == 'smallest':\n                target_indices = range(r)\n            else:  # 'largest'\n                target_indices = range(k - r, k)\n            \n            num_converged = 0\n            for i in target_indices:\n                theta_i = ritz_values[i]\n                # Last component of the i-th eigenvector of T_k.\n                u_ik = ritz_vecs[-1, i]\n                \n                # Calculate the residual norm efficiently.\n                res_norm = abs(beta_next * u_ik)\n                \n                # Calculate the dynamic tolerance threshold.\n                threshold = max(atol, rtol * max(1.0, abs(theta_i))) * norm_A\n                \n                if res_norm <= threshold:\n                    num_converged += 1\n            \n            if num_converged >= r:\n                return k\n\n        # If breakdown occurs (beta_next is zero), the Krylov subspace is exhausted.\n        # If convergence was not declared, it means the required pairs did not converge.\n        if np.isclose(beta_next, 0.0):\n            return -1\n        \n        # Prepare for the next iteration.\n        v_curr = w / beta_next\n        beta_curr = beta_next\n        betas_offdiag.append(beta_curr)\n\n    # If the loop completes, convergence was not achieved within k_max iterations.\n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_suite = [\n        # Test case 1\n        {'n': 50, 'type': 'laplacian', 'r': 2, 'target': 'smallest', 'rtol': 1e-8, 'atol': 1e-12, 'k_max': 50},\n        # Test case 2\n        {'n': 60, 'type': 'toeplitz', 'sigma': 5.0, 'r': 1, 'target': 'largest', 'rtol': 1e-6, 'atol': 1e-10, 'k_max': 60},\n        # Test case 3\n        {'n': 20, 'type': 'identity', 'c': 7.0, 'r': 1, 'target': 'smallest', 'rtol': 1e-12, 'atol': 0.0, 'k_max': 5},\n        # Test case 4\n        {'n': 40, 'type': 'laplacian', 'r': 1, 'target': 'smallest', 'rtol': 1e-14, 'atol': 0.0, 'k_max': 5},\n    ]\n\n    results = []\n    for params in test_suite:\n        n = params['n']\n        \n        # Construct the matrix A based on the test case type.\n        if params['type'] == 'laplacian':\n            A = 2.0 * np.eye(n) - np.eye(n, k=1) - np.eye(n, k=-1)\n        elif params['type'] == 'toeplitz':\n            sigma = params['sigma']\n            indices = np.arange(n, dtype=float).reshape(-1, 1)\n            A = np.exp(-(((indices - indices.T) / sigma) ** 2))\n        elif params['type'] == 'identity':\n            c = params['c']\n            A = c * np.eye(n)\n        \n        # The unnormalized starting vector has all components equal to 1.\n        v1_unnormalized = np.ones(n)\n        \n        # Calculate k_acc for the current test case.\n        k_acc = calculate_k_acc(A, v1_unnormalized, params['r'], params['target'], params['rtol'], params['atol'], params['k_max'])\n        results.append(k_acc)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2406056"}]}