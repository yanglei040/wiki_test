{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解始于实践。本节将通过一系列动手练习，带你深入探索水平集方法的应用。第一个练习将从最基本的情况入手：一个在二维空间中以恒定法向速度 $F$ 收缩或膨胀的圆形界面。通过这个理想化的场景，我们将看到水平集偏微分方程 $\\phi_t + F |\\nabla\\phi|=0$ 如何简化为一个关于界面半径的简单常微分方程，从而让你无需复杂的数值计算就能直观地理解界面演化的核心原理。[@problem_id:2408430]", "problem": "考虑在二维空间中，一个由水平集方法 (Level Set Method, LSM) 隐式表示的封闭界面的运动。在时间 $t$ 时的界面是函数 $\\phi(x,y,t)$ 的零水平集，该函数根据偏微分方程 (Partial Differential Equation, PDE) 演化\n$$\\phi_t + F \\lvert \\nabla \\phi \\rvert = 0,$$\n其中 $F$ 是一个在空间和时间上恒定的法向速度，单位为米/秒。初始条件是到以原点为中心、半径为 $R_0$ 的圆的有向距离函数，\n$$\\phi(x,y,0) = \\sqrt{x^2 + y^2} - R_0,$$\n因此初始零水平集 $\\{\\phi=0\\}$ 是一个半径为 $R_0$ 的圆。距离单位为米，时间单位为秒，$F$ 的单位为米/秒。\n\n对于由参数 $(R_0, F, t)$ 指定的每个测试用例：\n- 计算时间 $t$ 时零水平集的半径 $R(t)$，单位为米。\n- 计算时间 $t$ 时零水平集所包围的面积 $A(t)$，单位为平方米，定义为 $A(t) = \\pi \\, R(t)^2$。\n- 计算坍缩时间 $T_c$，单位为秒，定义为半径变为零的最早时间 $t \\ge 0$。如果界面永不坍缩（例如，当 $F \\ge 0$ 时），则 $T_c$ 返回 $-1.0$。如果 $R_0 = 0$，则定义 $T_c = 0.0$。\n\n所有输出必须以上述指定单位表示，并四舍五入到六位小数。要求的最终输出格式为单行字符串，其中包含一个由方括号括起来的、以逗号分隔的各测试用例结果列表，每个测试用例的结果本身也是一个形如 $[R(t), A(t), T_c]$ 的列表。\n\n使用以下测试套件：\n- 测试 1 (收缩，坍缩前)：$(R_0, F, t) = (1.0, -0.2, 3.0)$。\n- 测试 2 (收缩，恰好在坍缩时)：$(R_0, F, t) = (1.0, -0.5, 2.0)$。\n- 测试 3 (收缩，坍缩后)：$(R_0, F, t) = (0.75, -3.0, 1.0)$。\n- 测试 4 (扩张，不坍缩)：$(R_0, F, t) = (0.6, 0.05, 10.0)$。\n- 测试 5 (初始时已坍缩)：$(R_0, F, t) = (0.0, -1.0, 0.5)$。\n\n您的程序应生成单行输出，包含由方括号括起来的、以逗号分隔的结果列表，例如：\n\"[ [R1,A1,Tc1],[R2,A2,Tc2],...[R5,A5,Tc5] ]\"\n其中每个数值均四舍五入到六位小数。", "solution": "该问题要求对由水平集方程控制的圆形界面演化过程进行解析求解。问题陈述在科学上是合理的、适定的，并包含了所有必要信息。这是一个可以推导出解析解的水平集方法的标准应用。因此，该问题是有效的。\n\n水平集函数 $\\phi(x,y,t)$ 的演化由 Hamilton-Jacobi 偏微分方程描述：\n$$ \\phi_t + F |\\nabla \\phi| = 0 $$\n其中 $\\phi_t = \\frac{\\partial \\phi}{\\partial t}$，$\\nabla \\phi$ 是 $\\phi$ 相对于空间变量 $(x,y)$ 的梯度。$F$ 是一个恒定的法向速度。\n\n初始条件将界面指定为以原点为中心、半径为 $R_0$ 的圆。函数 $\\phi(x,y,0)$ 被给出为到该圆的有向距离函数：\n$$ \\phi(x,y,0) = \\sqrt{x^2 + y^2} - R_0 $$\n零水平集 $\\{\\phi=0\\}$ 确实是圆 $x^2 + y^2 = R_0^2$。\n\n由于初始条件的径向对称性以及恒定且空间均匀的速度 $F$，演化中的界面在所有时间 $t \\ge 0$ 内都将保持为圆形。这个圆的半径，我们称之为 $R(t)$，将是时间的函数。因此，我们可以为解 $\\phi(x,y,t)$ 提出一个拟设，使其保持为一个到半径随时间变化的圆 $R(t)$ 的有向距离函数形式：\n$$ \\phi(x,y,t) = \\sqrt{x^2 + y^2} - R(t) $$\n为了与初始条件保持一致，必须有 $R(0) = R_0$。\n\n现在我们将此拟设代入偏微分方程。首先，我们计算所需的导数。令 $r = \\sqrt{x^2+y^2}$，则 $\\phi(r, t) = r - R(t)$。\n关于时间 $t$ 的偏导数为：\n$$ \\phi_t = \\frac{\\partial}{\\partial t} \\left( \\sqrt{x^2 + y^2} - R(t) \\right) = - \\frac{dR}{dt} = -R'(t) $$\n$\\phi$ 的梯度为：\n$$ \\nabla \\phi = \\left( \\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y} \\right) = \\left( \\frac{x}{\\sqrt{x^2+y^2}}, \\frac{y}{\\sqrt{x^2+y^2}} \\right) = \\left( \\frac{x}{r}, \\frac{y}{r} \\right) $$\n梯度的模为：\n$$ |\\nabla \\phi| = \\sqrt{\\left(\\frac{x}{r}\\right)^2 + \\left(\\frac{y}{r}\\right)^2} = \\sqrt{\\frac{x^2+y^2}{r^2}} = 1 $$\n这是有向距离函数的一个基本性质：其梯度的模为单位长度（原点处除外，那里是一个奇点）。\n\n将 $\\phi_t$ 和 $|\\nabla \\phi|$ 的表达式代入水平集方程，得到：\n$$ -R'(t) + F(1) = 0 $$\n$$ R'(t) = F $$\n这是一个关于 $R(t)$ 的简单的一阶常微分方程。我们可以通过对时间从 $0$ 到 $t$ 进行积分来求解它：\n$$ \\int_0^t R'(\\tau) d\\tau = \\int_0^t F d\\tau $$\n$$ R(t) - R(0) = F t $$\n使用初始条件 $R(0) = R_0$，我们得到半径演化的解：\n$$ R(t) = R_0 + F t $$\n物理半径不能为负。如果 $R_0 + F t$ 变为负值，则表示界面已经坍缩并消失。在这种情况下，（已不存在的）零水平集的半径为 $0$。因此，在时间 $t$ 时界面的物理真实半径是：\n$$ R(t) = \\max(0, R_0 + F t) $$\n\n有了 $R(t)$ 的这个解析解，我们就可以确定其他所需的量。\n\n1.  **半径 $R(t)$**：在时间 $t$ 时的半径（单位为米）由 $R(t) = \\max(0, R_0 + F t)$ 给出。\n\n2.  **面积 $A(t)$**：圆形界面所包围的面积（单位为平方米）为 $A(t) = \\pi R(t)^2$。\n\n3.  **坍缩时间 $T_c$**：这是使得 $R(t)=0$ 成立的最早时间 $t \\ge 0$。我们令 $R_0 + F t = 0$，解得 $t = -R_0/F$。此计算必须根据给定的规则进行解释：\n    -   如果 $R_0=0$，圆已经处于坍缩状态。问题指定 $T_c = 0.0$。\n    -   如果 $R_0 > 0$ 且 $F \\ge 0$，半径是不减的，永远不会达到 $0$。问题指定 $T_c = -1.0$。\n    -   如果 $R_0 > 0$ 且 $F < 0$，圆正在收缩。坍缩将发生在正时间 $T_c = -R_0/F$。\n\n现在将这些推导出的公式应用于每个测试用例。\n- **测试 1**：$(R_0, F, t) = (1.0, -0.2, 3.0)$。\n  $R(3.0) = \\max(0, 1.0 + (-0.2)(3.0)) = \\max(0, 0.4) = 0.4$ 米。\n  $A(3.0) = \\pi (0.4)^2 = 0.16\\pi \\approx 0.502655$ 平方米。\n  $T_c = -1.0 / (-0.2) = 5.0$ 秒。\n\n- **测试 2**：$(R_0, F, t) = (1.0, -0.5, 2.0)$。\n  $R(2.0) = \\max(0, 1.0 + (-0.5)(2.0)) = \\max(0, 0.0) = 0.0$ 米。\n  $A(2.0) = \\pi (0.0)^2 = 0.0$ 平方米。\n  $T_c = -1.0 / (-0.5) = 2.0$ 秒。\n\n- **测试 3**：$(R_0, F, t) = (0.75, -3.0, 1.0)$。\n  $T_c = -0.75 / (-3.0) = 0.25$ 秒。\n  由于 $t=1.0 > T_c=0.25$，圆已经坍缩。\n  $R(1.0) = \\max(0, 0.75 + (-3.0)(1.0)) = \\max(0, -2.25) = 0.0$ 米。\n  $A(1.0) = \\pi (0.0)^2 = 0.0$ 平方米。\n\n- **测试 4**：$(R_0, F, t) = (0.6, 0.05, 10.0)$。\n  $R(10.0) = \\max(0, 0.6 + (0.05)(10.0)) = \\max(0, 1.1) = 1.1$ 米。\n  $A(10.0) = \\pi (1.1)^2 = 1.21\\pi \\approx 3.801327$ 平方米。\n  由于 $F \\ge 0$，界面永不坍缩，所以 $T_c = -1.0$ 秒。\n\n- **测试 5**：$(R_0, F, t) = (0.0, -1.0, 0.5)$。\n  由于 $R_0=0$，问题规定 $T_c=0.0$ 秒。\n  $R(0.5) = \\max(0, 0.0 + (-1.0)(0.5)) = \\max(0, -0.5) = 0.0$ 米。\n  $A(0.5) = \\pi (0.0)^2 = 0.0$ 平方米。\n\n代码实现将把这些解析结果编码化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the level set problem for a circular interface.\n\n    The problem describes a circular interface evolving with a constant normal\n    speed F. The radius R(t) of the circle at time t can be found by\n    solving the ODE R'(t) = F with initial condition R(0) = R0.\n    This gives R_candidate(t) = R0 + F*t.\n\n    The physical radius cannot be negative, so R(t) = max(0, R0 + F*t).\n    The area is A(t) = pi * R(t)^2.\n    The collapse time Tc is the time when R(t) first becomes 0.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R0, F, t)\n        (1.0, -0.2, 3.0),  # Test 1: shrinking, before collapse\n        (1.0, -0.5, 2.0),  # Test 2: shrinking, exactly at collapse\n        (0.75, -3.0, 1.0), # Test 3: shrinking, after collapse\n        (0.6, 0.05, 10.0), # Test 4: expanding, no collapse\n        (0.0, -1.0, 0.5),  # Test 5: already collapsed initially\n    ]\n\n    results = []\n    for case in test_cases:\n        R0, F, t = case\n\n        # 1. Compute the radius R(t)\n        # The radius evolution is R(t) = R0 + F*t, but physical radius is non-negative.\n        R_t = max(0.0, R0 + F * t)\n\n        # 2. Compute the area A(t)\n        A_t = np.pi * R_t**2\n\n        # 3. Compute the collapse time T_c\n        # As per problem definition:\n        # If R0 = 0, Tc = 0.0\n        # If R0 > 0 and F >= 0, never collapses, Tc = -1.0\n        # If R0 > 0 and F < 0, collapses at Tc = -R0 / F\n        if R0 == 0.0:\n            T_c = 0.0\n        elif F >= 0.0:\n            T_c = -1.0\n        else: # R0 > 0 and F < 0\n            T_c = -R0 / F\n\n        # Round all results to six decimal places\n        R_t_rounded = round(R_t, 6)\n        A_t_rounded = round(A_t, 6)\n        T_c_rounded = round(T_c, 6)\n\n        # Format the result for a single case as requested: [R,A,Tc]\n        # with no spaces.\n        case_result_str = (\n            f\"[{R_t_rounded},{A_t_rounded},{T_c_rounded}]\"\n        )\n        results.append(case_result_str)\n\n    # Final print statement in the exact required format:\n    # \"[ [R1,A1,Tc1],[R2,A2,Tc2],... ]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2408430"}, {"introduction": "在掌握了简单界面的解析演化后，我们将进入更真实、更具挑战性的数值模拟领域。水平集方法最强大的能力之一便是能自然地处理界面的拓扑变化，例如分裂和合并。本练习将模拟一个椭圆形细胞在非均匀速度场 $F(x,y)$ 作用下的分裂过程，这要求你构建一个完整的数值求解器，包括实现处理变号速度场的一阶戈杜诺夫（Godunov）格式，并应用周期性重初始化来保持数值稳定性。[@problem_id:2408442]", "problem": "要求您实现一个水平集方法（Level Set Method, LSM）模拟，以模拟一个初始为椭圆的封闭界面的分裂过程。该演化过程由一个空间相关的法向速度所控制。您必须推导出一个稳定、单调、一阶迎风（Godunov型）格式来离散化这个 Hamilton–Jacobi 偏微分方程（PDE），并用代码实现。目标是测试演化中的界面是否经历拓扑变化（分裂），该变化通过模拟结束时内部相的连通分量数量来量化。此处所有量均为无量纲量，无需物理单位。\n\n水平集函数的演化由以下偏微分方程给出\n$$\n\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0,\n$$\n其中 $\\phi(x,y,t)$ 是一个标量场，使得演化中的界面是其零等值线 $\\{\\phi = 0\\}$，内部区域为 $\\{\\phi \\le 0\\}$。速度场与空间相关，其形式规定如下\n$$\nF(x,y) = \\beta - \\alpha \\exp\\!\\left(-\\frac{y^2}{s^2}\\right).\n$$\n这里，$\\alpha$、$\\beta$ 和 $s$ 均为严格正参数。计算域为正方形 $[-1,1] \\times [-1,1]$，并在均匀的笛卡尔网格上进行离散化。\n\n初始条件：\n- 初始界面是一个由以下隐式方程给出的椭圆：\n$$\n\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1,\n$$\n并且初始水平集场 $\\phi(x,y,0)$ 的构造必须满足在椭圆内部 $\\phi \\le 0$，在外部 $\\phi > 0$。为了数值稳定性，您必须在 $t=0$ 时以及在模拟过程中周期性地将 $\\phi$ 重新初始化为符号距离函数。重新初始化可以通过任何能够生成零水平集近似符号距离场的一致性方法来完成；一种常用方法是对二值化的内部掩码 $\\{\\phi \\le 0\\}$ 计算欧几里得距离变换（Euclidean Distance Transform, EDT）。\n\n离散化与稳定性要求：\n- 使用在具有网格间距 $\\Delta x$ 和 $\\Delta y$ 的均匀网格上的单边有限差分，推导并实现一个与 $F(x,y)$ 符号相一致的 $\\lvert \\nabla \\phi \\rvert$ 的一阶单调迎风（Godunov）近似。\n- 使用显式前向 Euler 时间积分器，其时间步长 $\\Delta t$ 满足从 Hamilton-Jacobi 偏微分方程的特征速度推导出的 Courant–Friedrichs–Lewy (CFL) 稳定性约束。您必须选择\n$$\n\\Delta t = \\mathrm{CFL} \\times \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert},\n$$\n其中常数 $\\mathrm{CFL}$ 满足 $0 < \\mathrm{CFL} \\le 1$。\n- 通过在边界处使用适当的单边差分或数值复制，来数值化地应用齐次 Neumann 边界条件（法向导数为零）。\n\n拓扑查询：\n- 在每次模拟结束时，使用网格上的 4-连通性计算内部集合 $\\{\\phi \\le 0\\}$ 的连通分量数量。\n\n您的程序必须实现以下内容，并为指定的测试套件生成所需的输出。不允许用户输入；所有参数都嵌入在代码中。\n\n实现要求：\n- 在 $[-1,1] \\times [-1,1]$ 上构建一个具有 $N \\times N$ 个节点的均匀网格，其中 $N \\ge 5$，网格间距为 $\\Delta x = \\Delta y = \\frac{2}{N-1}$。\n- 从半轴为 $a$ 和 $b$ 的椭圆初始化 $\\phi(x,y,0)$，使其内部满足 $\\phi \\le 0$。然后在 $t=0$ 时将其重新初始化为符号距离场。\n- 使用 PDE $\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0$、$\\lvert \\nabla \\phi \\rvert$ 的单调迎风 Godunov 离散化以及由 CFL 条件决定的稳定时间步长 $\\Delta t$ 的前向 Euler 时间积分来演化 $\\phi$。\n- 在时间步进过程中周期性地重新初始化 $\\phi$，以在界面附近维持 $\\lvert \\nabla \\phi \\rvert \\approx 1$。\n- 在最后一个时间步之后，用 4-连通性计算 $\\{\\phi \\le 0\\}$ 的连通分量数量。\n\n测试套件：\n为以下每组参数运行模拟；报告每种情况下最终时刻的内部连通分量数量。\n\n- 情况 A（预期分裂为两个）：$N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 1.1$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, Euler步数 $= 220$, 每 5 步重新初始化一次。\n- 情况 B（预期保持一个分量）：$N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 0.1$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, Euler步数 $= 220$, 每 5 步重新初始化一次。\n- 情况 C（临界情况，分裂时间不足）：$N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 0.35$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, Euler步数 $= 100$, 每 5 步重新初始化一次。\n- 情况 D（强分裂）：$N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 1.3$, $\\beta = 0.20$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, Euler步数 $= 260$, 每 5 步重新初始化一次。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与上述测试用例相同。每个条目是一个等于内部连通分量数量的整数。例如，一个有效的输出形式为\n$\n[n_A, n_B, n_C, n_D]\n$\n其中 $n_A$、$n_B$、$n_C$ 和 $n_D$ 是整数。\n\n约束和说明：\n- 您不得使用任何外部数据或用户输入。\n- 本规范中所有以数学形式出现的变量、函数、运算符和数字均用 LaTeX 书写。\n- 该算法必须从水平集方法、Hamilton-Jacobi 方程、单调迎风离散化和 Courant-Friedrichs-Lewy 条件的核心定义中推导得出。", "solution": "所提出的问题是计算物理学中一个适定的初边值问题，它具有科学依据，形式规范，且目标明确。它包含了进行数值求解所需的所有必要信息。因此，该问题被认为是有效的。\n\n任务是求解水平集方程，这是一种 Hamilton-Jacobi 偏微分方程（PDE）：\n$$\n\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0\n$$\n函数 $\\phi(x,y,t)$ 是水平集函数，其零等值线 $\\phi=0$ 代表移动的界面。$\\phi \\le 0$ 的区域被定义为封闭界面的“内部”。函数 $F(x,y)$ 是界面在其外法线方向上的速度。\n\n求解过程涉及在空间和时间上离散化该偏微分方程，并对一个初始条件进行演化。\n\n1.  **计算域和网格离散化**\n    计算域是一个正方形 $[-1,1] \\times [-1,1]$。我们引入一个包含 $N \\times N$ 个节点的均匀笛卡尔网格。网格节点 $(x_i, y_j)$ 的坐标由下式给出：\n    $$\n    x_i = -1 + i \\Delta x, \\quad i = 0, \\ldots, N-1\n    $$\n    $$\n    y_j = -1 + j \\Delta y, \\quad j = 0, \\ldots, N-1\n    $$\n    其中网格间距为 $\\Delta x = \\Delta y = \\frac{2}{N-1}$。水平集函数由其在该网格上的值 $\\phi_{i,j}(t) \\approx \\phi(x_i, y_j, t)$ 表示。\n\n2.  **初始条件和重新初始化**\n    初始界面是由 $\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1$ 定义的椭圆。一个简单的初始水平集函数选择是 $\\phi(x,y,0) = \\frac{x^2}{a^2} + \\frac{y^2}{b^2} - 1$。\n    为了数值稳定性和准确性，水平集函数理想情况下应为符号距离函数（SDF），意味着它满足 $|\\nabla\\phi| = 1$。初始函数不是一个SDF。因此，我们必须在 $t=0$ 时及之后周期性地对其进行重新初始化。\n    重新初始化的执行方式如下：\n    - 创建一个区分内部（$\\phi \\le 0$）和外部（$\\phi > 0$）的二值掩码。\n    - 计算每个网格点到相对区域最近点的欧几里得距离。这通过使用快速欧几里得距离变换（EDT）算法来完成。\n    - 新的 $\\phi$ 是通过为内部点赋予负距离、为外部点赋予正距离来构建的。具体来说，$\\phi_{\\text{new}} = \\text{dist}_{\\text{out}} - \\text{dist}_{\\text{in}}$，其中 $\\text{dist}_{\\text{in}}$ 是内部点到外部的距离，而 $\\text{dist}_{\\text{out}}$ 是外部点到内部的距离。\n\n3.  **空间离散化：一阶 Godunov 格式**\n    该 PDE 是一个形式为 $\\phi_t + H(\\nabla \\phi) = 0$ 的 Hamilton-Jacobi 方程，其哈密顿量为 $H(\\nabla \\phi) = F(x,y)|\\nabla \\phi|$。此类方程的解可能会出现激波或尖角，需要一种能够正确处理信息传播方向（迎风）的数值格式。Godunov 型格式通过使用一个单调的数值哈密顿量来实现这一点。\n    对于哈密顿量 $H(p,q) = F\\sqrt{p^2+q^2}$，其中 $p=\\phi_x$ 且 $q=\\phi_y$，用于网格函数 $\\phi_{i,j}$ 的 Godunov 数值哈密顿量 $H_{num}$ 具有以下形式：\n    $$\n    H_{num} = F_{i,j}^+ \\sqrt{D_x^{\\text{upw},+}{}^2 + D_y^{\\text{upw},+}{}^2} + F_{i,j}^- \\sqrt{D_x^{\\text{upw},-}{}^2 + D_y^{\\text{upw},-}{}^2}\n    $$\n    其中 $F_{i,j}^+ = \\max(F_{i,j}, 0)$ 且 $F_{i,j}^- = \\min(F_{i,j}, 0)$。项 $D$ 表示迎风梯度的平方范数。\n    - 如果 $F > 0$（扩张），信息从内部（$\\phi<0$）传播到外部（$\\phi>0$）。格式必须“迎风”地看向内部。\n    - 如果 $F < 0$（收缩），信息从外部传播到内部。格式必须“迎风”地看向外部。\n\n    设 $\\phi_x^- = (\\phi_{i,j} - \\phi_{i-1,j})/\\Delta x$ 为后向差分，$\\phi_x^+ = (\\phi_{i+1,j} - \\phi_{i,j})/\\Delta x$ 为前向差分，对 $y$ 方向类似。Godunov 格式表示为：\n    $$\n    H_{num}(\\phi_{i,j}) = \\max(F_{i,j}, 0) \\sqrt{A} + \\min(F_{i,j}, 0) \\sqrt{B}\n    $$\n    其中\n    $$\n    A = [\\max(\\phi_x^-, 0)]^2 + [\\min(\\phi_x^+, 0)]^2 + [\\max(\\phi_y^-, 0)]^2 + [\\min(\\phi_y^+, 0)]^2\n    $$\n    $$\n    B = [\\max(\\phi_x^+, 0)]^2 + [\\min(\\phi_x^-, 0)]^2 + [\\max(\\phi_y^+, 0)]^2 + [\\min(\\phi_y^-, 0)]^2\n    $$\n    该公式根据局部导数的符号和速度场 $F$ 的符号正确地选择差分方向。\n\n4.  **时间离散化和稳定性**\n    我们使用显式前向 Euler 格式来在时间上更新解：\n    $$\n    \\frac{\\phi_{i,j}^{n+1} - \\phi_{i,j}^n}{\\Delta t} + H_{num}(\\phi_{i,j}^n) = 0 \\implies \\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\Delta t \\cdot H_{num}(\\phi_{i,j}^n)\n    $$\n    该格式仅在时间步长 $\\Delta t$ 满足 Courant-Friedrichs-Lewy (CFL) 条件时才是稳定的。对于这个 Hamilton-Jacobi 方程，特征速度是 $\\max_{x,y}|F(x,y)|$。CFL 条件为：\n    $$\n    \\Delta t \\le \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert}\n    $$\n    问题指定使用一个 CFL 数，$0 < \\mathrm{CFL} \\le 1$，使得：\n    $$\n    \\Delta t = \\mathrm{CFL} \\times \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert}\n    $$\n\n5.  **边界条件**\n    应用齐次 Neumann 边界条件 $\\frac{\\partial \\phi}{\\partial n} = 0$，其中 $n$ 是计算域边界的外法线。对于一阶格式，这可以通过将域外“虚拟单元”中的值设置为与其相邻的边界单元的值相等来实现。这有效地使跨越边界的单边有限差分为零。在数值上，这通过在计算空间导数之前用边界值填充 $\\phi$ 网格来实现。\n\n6.  **拓扑分析**\n    在最后一个时间步之后，确定演化后界面的拓扑结构。这是通过分析内部集合 $S = \\{(i,j) | \\phi_{i,j} \\le 0\\}$ 来完成的。我们使用标准的标记算法，采用 4-连通性（只考虑上、下、左、右邻居为连通）来计算此集合中连通分量的数量。所分配的不同标签的数量对应于独立对象的数量。\n\n实现将针对问题陈述中提供的每个测试用例遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to run the Level Set Method simulations for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: (N, a, b, alpha, beta, s, CFL, num_steps, reinit_freq)\n        (101, 0.7, 0.3, 1.1, 0.25, 0.2, 0.5, 220, 5),\n        # Case B:\n        (101, 0.7, 0.3, 0.1, 0.25, 0.2, 0.5, 220, 5),\n        # Case C:\n        (101, 0.7, 0.3, 0.35, 0.25, 0.2, 0.5, 100, 5),\n        # Case D:\n        (101, 0.7, 0.3, 1.3, 0.20, 0.2, 0.5, 260, 5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(N, a, b, alpha, beta, s, CFL, num_steps, reinit_freq):\n    \"\"\"\n    Executes a single LSM simulation for a given set of parameters.\n    \"\"\"\n    # 1. Grid setup\n    domain_size = 2.0\n    dx = domain_size / (N - 1)\n    dy = dx  # Square grid\n    x = np.linspace(-1.0, 1.0, N)\n    y = np.linspace(-1.0, 1.0, N)\n    X, Y = np.meshgrid(x, y)\n\n    # 2. Initial condition: Ellipse\n    phi = (X**2 / a**2) + (Y**2 / b**2) - 1.0\n\n    # 3. Reinitialization to Signed Distance Function (SDF)\n    def reinitialize(p, grid_spacing):\n        mask_in = p <= 0\n        dist_in = ndimage.distance_transform_edt(mask_in, sampling=[grid_spacing, grid_spacing])\n        dist_out = ndimage.distance_transform_edt(~mask_in, sampling=[grid_spacing, grid_spacing])\n        return dist_out - dist_in\n    \n    phi = reinitialize(phi, dx)\n    \n    # 4. Speed field F(x,y)\n    F = beta - alpha * np.exp(-(Y**2) / s**2)\n    max_F_abs = np.max(np.abs(F))\n\n    # 5. Time step from CFL condition\n    dt = CFL * dx / max_F_abs\n\n    # 6. Main evolution loop\n    for step in range(num_steps):\n        # Apply Neumann boundary conditions via padding\n        phi_padded = np.pad(phi, pad_width=1, mode='edge')\n\n        # Compute one-sided differences on the interior grid\n        # These correspond to derivatives on the original phi grid\n        phi_x_m = (phi_padded[1:-1, 1:-1] - phi_padded[1:-1, :-2]) / dx\n        phi_x_p = (phi_padded[1:-1, 2:]   - phi_padded[1:-1, 1:-1]) / dx\n        phi_y_m = (phi_padded[1:-1, 1:-1] - phi_padded[:-2, 1:-1]) / dy\n        phi_y_p = (phi_padded[2:,   1:-1] - phi_padded[1:-1, 1:-1]) / dy\n\n        # Godunov numerical Hamiltonian H\n        F_pos = np.maximum(F, 0)\n        F_neg = np.minimum(F, 0)\n        \n        # Gradient term for F > 0 (upwind from interior)\n        grad_norm_sq_up = (np.maximum(phi_x_m, 0)**2 + \n                           np.minimum(phi_x_p, 0)**2 + \n                           np.maximum(phi_y_m, 0)**2 + \n                           np.minimum(phi_y_p, 0)**2)\n        \n        # Gradient term for F < 0 (upwind from exterior)\n        grad_norm_sq_down = (np.maximum(phi_x_p, 0)**2 + \n                             np.minimum(phi_x_m, 0)**2 + \n                             np.maximum(phi_y_p, 0)**2 + \n                             np.minimum(phi_y_m, 0)**2)\n\n        H = F_pos * np.sqrt(grad_norm_sq_up) + F_neg * np.sqrt(grad_norm_sq_down)\n\n        # Forward Euler time update\n        phi -= dt * H\n\n        # Periodic reinitialization\n        if (step + 1) % reinit_freq == 0:\n            phi = reinitialize(phi, dx)\n\n    # 7. Topological query: count connected components\n    # The set {phi <= 0} represents the interior\n    interior_mask = phi <= 0\n    # ndimage.label default structure gives 4-connectivity for 2D\n    _, num_components = ndimage.label(interior_mask)\n    \n    return num_components\n\nsolve()\n```", "id": "2408442"}, {"introduction": "水平集方法背后的数学原理——哈密顿-雅可比方程（Hamilton-Jacobi equations）——有着广泛的应用。其中，一个重要的静态变体是程函方程（Eikonal equation）$\\lvert \\nabla T \\rvert F = 1$，它描述了波前到达各点的时间 $T$。通过求解程函方程，我们可以找到从起点到任意点的最短时间，并由此反向追踪出最短路径。这个练习将水平集方法的思想应用到了一个全新的领域：路径规划，你将使用快速行进法（Fast Marching Method）在有障碍物的地图上找到最短路径，这展示了计算物理工具在机器人学和优化问题中的巨大潜力。[@problem_id:2408447]", "problem": "您需要实现一种基于水平集演化的计算方法，用于在二维笛卡尔网格上计算绕过障碍物的最短时间路径。其基本原理是惠更斯原理和哈密顿-雅可比理论：从源点发出的波前以局部速度传播，其到达时间满足一个程函方程。设界面由一个水平集函数隐式表示，到达时间函数记为 $T(x,y)$。您将构建一个程序，通过求解具有适当边界和障碍物条件的程函方程，来隐式地演化波前并计算最短时间路径。\n\n数学模型：\n- 考虑一个在两个方向上具有均匀间距 $h>0$ 的矩形网格，索引 $(i,j)$ 对应于笛卡尔点 $(x_i,y_j)$。\n- 令 $F(i,j)$ 表示网格单元 $(i,j)$ 处的局部速度，其中 $F(i,j)=0$ 表示不可穿越的障碍物，$F(i,j)>0$ 表示可通行空间。您必须使用 $h=1$ 网格单位。\n- 从指定源点 $S$ 开始并以法向速度 $F$ 演化的波前的到达时间 $T(i,j)$ 由程函方程决定\n$$\n\\lvert \\nabla T \\rvert \\, F \\,=\\, 1,\n$$\n受边界条件 $T(S)=0$ 和在不连通区域 $T=\\infty$ 的约束。这源于传播波前的哈密顿-雅可比公式和惠更斯构造。\n- 通过在障碍物内部设置 $F=0$ 并将演化限制在其补集上来施加障碍物。您必须使用正确的程函方程迎风离散格式和一个遵循因果关系的单调求解器来计算网格上的 $T$。\n\n算法约束：\n- 您必须在网格上使用 $\\lvert \\nabla T \\rvert$ 的单调迎风离散格式，并使用一种标签设置法（例如，使用二叉堆实现的快速行进法）来计算网格上的 $T(i,j)$。局部更新必须根据已接受的迎风邻居点进行计算，以确保特征线不会使信息向后传递。\n- 计算出 $T$ 之后，通过在离散网格上沿着计算出的到达时间进行局部下降，从目标位置 $E$ 重建回到 $S$ 的路径。使用八邻域下降法，总是移动到到达时间严格更小的邻居点，并将路径上的物理行进时间作为路径积分进行累加\n$$\n\\mathcal{T}_{\\text{path}} \\approx \\sum_k \\frac{\\Delta s_k}{F_k},\n$$\n其中 $\\Delta s_k$ 是连续网格单元中心之间的欧几里得距离（以网格单位计），$F_k$ 是局部速度（对一步所涉及的两个单元的速度使用算术平均值）。当路径到达 $S$ 或不存在严格递减的邻居点时，此重建过程必须终止。\n\n数值离散要求：\n- 各处均使用 $h=1$。\n- 在每个网格点使用迎风二次更新。设 $a$ 和 $b$ 分别为 $x$ 和 $y$ 方向上已接受邻居的最小到达时间。当 $f = 1/F(i,j)$ 且 $h=1$ 时，正确的单调更新公式为\n$$\nT^\\star =\n\\begin{cases}\n\\min(a,b) + f h, & \\text{if } \\lvert a - b \\rvert \\,\\ge\\, f h,\\\n\\dfrac{a + b + \\sqrt{2 (f h)^2 - (a - b)^2}}{2}, & \\text{otherwise}.\n\\end{cases}\n$$\n如果只有一个迎风邻居存在，则使用 $T^\\star = a + f h$。如果不存在迎风邻居，则试探值保持为 $+\\infty$。\n- 将起始单元 $S$ 视为已接受状态，其到达时间 $T(S)=0$，并将其有效邻居初始化为试探点。\n\n单位与输出：\n- 所有距离和时间均以网格单位表示，其中 $h=1$，并且由于速度在此是无量纲的，时间也使用相同的单位。报告时间时，四舍五入到三位小数。\n- 对于每个测试用例，您的程序必须计算：\n  1.  一个布尔值，指示目标是否可达（即，$T(E)$ 是有限的，且起点和终点都不在障碍物单元内）。\n  2.  由程函求解器产生的到达时间 $T(E)$，四舍五入到三位小数。\n  3.  通过在 $T$ 上进行八邻域最速下降并按规定累加 $\\Delta s / F$ 得到的重建路径行进时间 $\\mathcal{T}_{\\text{path}}$，四舍五入到三位小数。如果目标不可达，则两个时间均返回 $-1.0$。\n- 最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个条目。每个条目必须是包含三个元素的列表，顺序为 [reachable_boolean, arrival_time_float, reconstructed_time_float]。例如：\"[[True,12.000,11.970],[False,-1.0,-1.0]]\"。实际数字必须与您程序的计算结果相匹配。\n\n测试套件：\n实现以下五个案例，其中 $h=1$，行列使用从零开始的整数索引 $(i,j)$。在每个案例中，计算域为大小为 $(N_y,N_x)$ 的完整网格；障碍物在给定的索引范围内是闭合的。\n\n- 案例 1（绕墙的顺利路径）：$(N_y,N_x)=(60,60)$。起点 $S=(5,5)$。终点 $E=(50,45)$。在所有可通行区域设置 $F(i,j)=1$。设置一道垂直障碍墙，覆盖行 $i \\in \\{10,\\ldots,50\\}$ 和列 $j \\in \\{30,31,32\\}$。\n- 案例 2（边界条件起点等于终点）：$(N_y,N_x)=(20,20)$。起点 $S=(10,10)$。终点 $E=(10,10)$。无障碍物。$F=1$。\n- 案例 3（狭窄通道）：$(N_y,N_x)=(50,50)$。起点 $S=(40,10)$。终点 $E=(10,40)$。$F=1$。在行 $i=25$ 处设置一道水平墙，覆盖所有列 $j \\in \\{0,\\ldots,49\\}$，但在 $j=25$ 处留有一个单格间隙（该单元可通行）。\n- 案例 4（被墙包围的不可达目标）：$(N_y,N_x)=(30,30)$。起点 $S=(2,2)$。终点 $E=(15,15)$。$F=1$。设置一个闭合的方形环状墙，由所有满足 $i \\in \\{10,\\ldots,20\\}$ 和 $j \\in \\{10,\\ldots,20\\}$ 的单元组成，但只有位于该正方形周边的单元是障碍物；正方形内部是自由空间。这会在严格位于环内的终点周围形成一个无法穿透的包围圈。\n- 案例 5（变速避障）：$(N_y,N_x)=(80,80)$。起点 $S=(10,10)$。终点 $E=(70,70)$。除一个速度为 $F=0.5$ 的慢速矩形带（覆盖行 $i \\in \\{30,\\ldots,60\\}$ 和列 $j \\in \\{20,\\ldots,60\\}$）外，所有地方的 $F=1$。无障碍物。\n\n您的程序必须计算这五个案例的结果，并按指定格式打印包含汇总结果的单行输出。所有计算必须仅使用指定的库和 Python 标准库完成，无用户输入，无外部文件。不涉及角度。距离和时间必须如指定的那样，以网格单位表示并四舍五入到三位小数。", "solution": "该问题要求在具有障碍物和可变行进速度的二维笛卡尔网格上计算最短时间路径。这是计算物理学和机器人学中的一个经典问题，可以使用基于水平集的方法来解决，该方法对传播的波前进行建模。该方法的核心是求解程函方程，这是一个从哈密顿-雅可比理论推导出的非线性偏微分方程。\n\n一个以法向速度 $F(x,y)$ 传播的波前的到达时间 $T(x,y)$ 的控制方程是程函方程：\n$$\n\\lvert \\nabla T \\rvert F = 1\n$$\n这可以重写为 $\\lvert \\nabla T \\rvert = s$，其中 $s = 1/F$ 是局部慢度（单位距离所需的时间）。边界条件是源点 $S$ 处 $T(S) = 0$。我们的任务是在离散网格上求解这个方程，然后重建最优路径。\n\n在网格上求解程函方程的标准且最高效的方法是快速行进法（Fast Marching Method, FMM）。FMM 是一种标签设置算法，结构上类似于用于在图上寻找最短路径的 Dijkstra 算法。它通过从源点向外构建解，并遵循因果关系，正确地捕捉了波前传播的物理过程。该方法系统地将网格点分为三类：\n- **已接受** (或 `FROZEN`): 到达时间 $T$ 已被计算并被认为是最终值的点。\n- **试探** (或 `NARROW BAND`): `已接受` 点的邻居，已为其计算了试探性的到达时间。这些点构成了活动波前。\n- **远离**: 所有其他点，其到达时间在波前到达之前实际上是无限大。\n\nFMM 算法流程如下：\n$1$. 初始化网格。将所有点 $(i,j)$ 的到达时间 $T(i,j)$ 设为 $\\infty$，并将其状态设为 `远离`。定义速度场 $F(i,j)$，障碍物处 $F(i,j)=0$。\n$2$. 设置源点条件。将源点 $S$ 的状态设为 `已接受`，其到达时间 $T(S)=0$。\n$3$. 初始化活动波前。将 $S$ 的有效（非障碍物）邻居指定为 `试探` 点。使用简单的一维更新 $T = T(S) + h/F = 1/F$（因为 $h=1$ 且 $T(S)=0$）计算它们的初始到达时间。将这些点添加到以其到达时间为键的最小优先级队列（小顶堆）中。\n$4$. 演化波前。当优先级队列不为空时，提取具有最小到达时间的 `试探` 点 $(i,j)$。此点被提升到 `已接受` 集合。\n$5$. 更新邻居。对于新接受的点 $(i,j)$ 的每个尚未 `已接受` 且非障碍物的邻居 $(i',j')$：\n    a. 为 $(i',j')$ 计算一个新的试探性到达时间 $T^\\star$。这是通过使用 $(i',j')$ 的已 `已接受` 邻居来求解程函方程的离散版本来完成的。\n    b. 如果这个新时间 $T^\\star$ 小于当前时间 $T(i',j')$，则更新 $T(i',j') = T^\\star$ 并更新其在优先级队列中的条目。如果该点之前是 `远离` 状态，现在会作为 `试探` 点被添加到队列中。\n\n点 $(i,j)$ 的数值更新规则 $T^\\star$ 源于程函方程 $(\\partial T / \\partial x)^2 + (\\partial T / \\partial y)^2 = (1/F)^2$ 的迎风离散。使用网格间距 $h=1$ 的一阶迎风差分，该方程变为：\n$$\n\\left( T_{i,j} - a \\right)^2 + \\left( T_{i,j} - b \\right)^2 = \\left( \\frac{1}{F_{i,j}} \\right)^2\n$$\n其中 $a = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $b = \\min(T_{i,j-1}, T_{i,j+1})$ 分别是 x 和 y 方向上已接受邻居的最小到达时间。求解这个关于 $T_{i,j}$ 的二次方程即可得到更新值。问题提供了正确的单调更新公式，该公式处理了所有情况。令 $f = 1/F(i,j)$ 且 $h=1$，更新后的到达时间 $T^\\star$ 为：\n$$\nT^\\star =\n\\begin{cases}\n\\min(a,b) + f, & \\text{if } \\lvert a - b \\rvert \\ge f \\\\\n\\dfrac{a + b + \\sqrt{2 f^2 - (a - b)^2}}{2}, & \\text{otherwise}\n\\end{cases}\n$$\n第一种情况对应于特征线（信息流动的路径）主要来自一个方向的情形。如果只有一个迎风邻居存在（例如，$a$ 是有限的但 $b$ 是无限的），则更新简化为一维传播：$T^\\star = a + f$。\n\n一旦整个网格的到达时间场 $T$ 计算完毕，就可以从目标点 $E$ 重建回源点 $S$ 的最短时间路径。这是通过在 $T$ 曲面上执行梯度下降来实现的。从 $E$ 开始，通过迭代地移动到到达时间严格最小的邻居来向后追溯路径。\n过程如下：\n$1$. 从当前点 $P_k = E$ 开始。\n$2$. 检查 $P_k$ 的所有 $8$ 个邻居。找到满足 $T(P_{k+1}) < T(P_k)$ 且到达时间最小的邻居 $P_{k+1}$。\n$3$. 如果不存在这样的邻居，路径终止。这只应该在 $P_k=S$ 时发生。\n$4$. 重建路径上的总行进时间 $\\mathcal{T}_{\\text{path}}$ 是各段行进时间之和：\n$$\n\\mathcal{T}_{\\text{path}} = \\sum_k \\frac{\\Delta s_k}{F_k}\n$$\n这里，$\\Delta s_k$ 是路径上连续单元 $P_k$ 和 $P_{k+1}$ 中心之间的欧几里得距离。当 $h=1$ 时，轴向移动的 $\\Delta s_k=1$，对角线移动的 $\\Delta s_k=\\sqrt{2}$。$F_k$ 是单元 $P_k$ 和 $P_{k+1}$ 速度的算术平均值。\n\n目标 $E$ 的可达性由两个条件决定：起点 $S$ 和终点 $E$ 都不能位于障碍物内（即 $F(S)>0$ 且 $F(E)>0$），并且在 FMM 算法完成后，目标点的到达时间 $T(E)$ 必须是有限的。如果 $T(E)$ 是无限的，则意味着 $E$ 位于一个被障碍物与 $S$ 隔开的区域中。", "answer": "```python\nimport numpy as np\nimport heapq\n\n# Constants for status grid\nFAR_AWAY = 0\nTRIAL = 1\nACCEPTED = 2\n\ndef calculate_update(i, j, T, status, F, Ny, Nx):\n    \"\"\"\n    Calculates the updated arrival time T at point (i,j) based on its\n    accepted neighbors, using the specified upwind quadratic formula.\n    \"\"\"\n    h = 1.0\n    \n    if F[i, j] == 0:\n        return np.inf\n    \n    f = h / F[i, j]\n\n    # Find minimum accepted neighbor times in x and y directions\n    t_neighbors_x = []\n    if i > 0 and status[i-1, j] == ACCEPTED:\n        t_neighbors_x.append(T[i-1, j])\n    if i < Ny - 1 and status[i+1, j] == ACCEPTED:\n        t_neighbors_x.append(T[i+1, j])\n\n    t_neighbors_y = []\n    if j > 0 and status[i, j-1] == ACCEPTED:\n        t_neighbors_y.append(T[i, j-1])\n    if j < Nx - 1 and status[i, j+1] == ACCEPTED:\n        t_neighbors_y.append(T[i, j+1])\n    \n    a = min(t_neighbors_x) if t_neighbors_x else np.inf\n    b = min(t_neighbors_y) if t_neighbors_y else np.inf\n\n    if a == np.inf and b == np.inf:\n        return np.inf\n    elif a == np.inf:\n        return b + f\n    elif b == np.inf:\n        return a + f\n    else:\n        if abs(a - b) >= f:\n            return min(a, b) + f\n        else:\n            discriminant = 2 * (f**2) - (a - b)**2\n            if discriminant < 0:\n                # Should not happen with a correct FMM sequence, but as a fallback\n                return min(a, b) + f\n            return (a + b + np.sqrt(discriminant)) / 2.0\n\ndef run_fmm(Ny, Nx, start_pos, F):\n    \"\"\"\n    Implements the Fast Marching Method to solve the Eikonal equation.\n    \"\"\"\n    T = np.full((Ny, Nx), np.inf, dtype=float)\n    status = np.full((Ny, Nx), FAR_AWAY, dtype=int)\n    pq = [] # Min-heap priority queue: (time, (i, j))\n\n    # Initialize start point as accepted\n    T[start_pos] = 0.0\n    status[start_pos] = ACCEPTED\n    \n    # Initialize valid neighbors of the start point as trial\n    si, sj = start_pos\n    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        ni, nj = si + di, sj + dj\n        if 0 <= ni < Ny and 0 <= nj < Nx and F[ni, nj] > 0:\n            h = 1.0\n            t_neighbor = T[start_pos] + h / F[ni, nj]\n            if t_neighbor < T[ni, nj]:\n                T[ni, nj] = t_neighbor\n                status[ni, nj] = TRIAL\n                heapq.heappush(pq, (t_neighbor, (ni, nj)))\n\n    # Main FMM loop\n    while pq:\n        time, (i, j) = heapq.heappop(pq)\n\n        if status[i, j] == ACCEPTED:\n            continue\n\n        status[i, j] = ACCEPTED\n\n        # Update neighbors of the newly accepted point\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = i + di, j + dj\n\n            if not (0 <= ni < Ny and 0 <= nj < Nx):\n                continue\n\n            if status[ni, nj] == ACCEPTED or F[ni, nj] == 0:\n                continue\n\n            t_new = calculate_update(ni, nj, T, status, F, Ny, Nx)\n\n            if t_new < T[ni, nj]:\n                T[ni, nj] = t_new\n                status[ni, nj] = TRIAL\n                heapq.heappush(pq, (t_new, (ni, nj)))\n    return T\n\ndef reconstruct_path(T, F, start_pos, end_pos):\n    \"\"\"\n    Reconstructs the path by gradient descent on the arrival time grid T\n    and computes the total travel time.\n    \"\"\"\n    if end_pos == start_pos:\n        return 0.0\n\n    Ny, Nx = T.shape\n    current_pos = end_pos\n    total_time = 0.0\n\n    while current_pos != start_pos:\n        i, j = current_pos\n        min_t = T[i, j]\n        best_neighbor = None\n\n        # 8-neighbor search for steepest descent\n        for di in [-1, 0, 1]:\n            for dj in [-1, 0, 1]:\n                if di == 0 and dj == 0:\n                    continue\n                \n                ni, nj = i + di, j + dj\n                if not (0 <= ni < Ny and 0 <= nj < Nx):\n                    continue\n\n                if T[ni, nj] < min_t:\n                    min_t = T[ni, nj]\n                    best_neighbor = (ni, nj)\n        \n        if best_neighbor is None:\n            # Path is stuck, should not happen for a reachable target.\n            return -1.0 \n\n        prev_pos = current_pos\n        current_pos = best_neighbor\n\n        dist = np.sqrt((current_pos[0] - prev_pos[0])**2 + (current_pos[1] - prev_pos[1])**2)\n        speed_avg = (F[prev_pos] + F[current_pos]) / 2.0\n        \n        if speed_avg > 0:\n            total_time += dist / speed_avg\n        else:\n            # Should not happen as path should not enter obstacles.\n            return -1.0 \n            \n    return total_time\n\ndef solve():\n    test_cases = [\n        # Case 1: detour around wall\n        {'Ny': 60, 'Nx': 60, 'S': (5, 5), 'E': (50, 45), 'F_base': 1.0,\n         'obstacles': [{'type': 'rect', 'region': (slice(10, 51), slice(30, 33)), 'val': 0.0}]},\n        # Case 2: start equals end\n        {'Ny': 20, 'Nx': 20, 'S': (10, 10), 'E': (10, 10), 'F_base': 1.0, 'obstacles': []},\n        # Case 3: narrow passage\n        {'Ny': 50, 'Nx': 50, 'S': (40, 10), 'E': (10, 40), 'F_base': 1.0,\n         'obstacles': [{'type': 'rect', 'region': (25, slice(None)), 'val': 0.0},\n                       {'type': 'point', 'region': (25, 25), 'val': 1.0}]},\n        # Case 4: unreachable target\n        {'Ny': 30, 'Nx': 30, 'S': (2, 2), 'E': (15, 15), 'F_base': 1.0,\n         'obstacles': [{'type': 'rect', 'region': (10, slice(10, 21)), 'val': 0.0},\n                       {'type': 'rect', 'region': (20, slice(10, 21)), 'val': 0.0},\n                       {'type': 'rect', 'region': (slice(10, 21), 10), 'val': 0.0},\n                       {'type': 'rect', 'region': (slice(10, 21), 20), 'val': 0.0}]},\n        # Case 5: variable speed\n        {'Ny': 80, 'Nx': 80, 'S': (10, 10), 'E': (70, 70), 'F_base': 1.0,\n         'obstacles': [{'type': 'rect', 'region': (slice(30, 61), slice(20, 61)), 'val': 0.5}]}\n    ]\n\n    results = []\n    for case in test_cases:\n        Ny, Nx, S, E = case['Ny'], case['Nx'], case['S'], case['E']\n        F = np.full((Ny, Nx), case['F_base'], dtype=float)\n        \n        for obs in case['obstacles']:\n            F[obs['region']] = obs['val']\n\n        # Check if Start/End points are in an obstacle\n        if F[S] == 0 or F[E] == 0:\n            results.append([False, -1.0, -1.0])\n            continue\n        \n        # Run FMM to compute arrival times\n        T = run_fmm(Ny, Nx, S, F)\n        \n        arrival_time = T[E]\n\n        if np.isinf(arrival_time):\n            reachable = False\n            reconstructed_time = -1.0\n            arrival_time = -1.0\n        else:\n            reachable = True\n            reconstructed_time = reconstruct_path(T, F, S, E)\n\n        results.append([reachable, arrival_time, reconstructed_time])\n\n    # Format output as specified\n    output_parts = []\n    for res in results:\n        is_reachable, arr_time, recon_time = res\n        if is_reachable:\n            part = f\"[{is_reachable},{arr_time:.3f},{recon_time:.3f}]\"\n        else:\n            part = f\"[{is_reachable},{arr_time:.1f},{recon_time:.1f}]\"\n        output_parts.append(part)\n        \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2408447"}]}