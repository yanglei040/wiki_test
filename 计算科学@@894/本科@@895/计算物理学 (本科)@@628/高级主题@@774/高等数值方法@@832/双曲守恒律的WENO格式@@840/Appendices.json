{"hands_on_practices": [{"introduction": "本练习将带您深入WENO格式成功的核心：其自动检测间断并自适应调整重构模板的能力。通过数值方法研究当网格在急剧跳跃处加密时，非线性权重 $\\omega_k$ 的行为，您将具体地理解该格式如何在光滑区域保持高阶精度，同时在激波处避免伪振荡。该实践对于掌握“本质无振荡”属性至关重要。[@problem_id:2450629]", "problem": "考虑标量双曲守恒律 $u_{t} + f(u)_{x} = 0$，其平流输运通量为线性函数 $f(u) = a u$，其中 $a > 0$ 是一个恒定的平流速度。您将分析应用于不连续初始条件的、针对左偏置界面值的 Jiang–Shu 五阶加权本质无振荡 (WENO) 重构中的非线性权重 $\\omega_{k}$ 的行为。目的是确定当网格在间断处加密时，$\\omega_{k}$ 如何作为网格分辨率 $\\Delta x$ 的函数而变化。\n\n您必须使用以下基本设置和假设，这些在计算物理学中是双曲守恒律的标准设置和假设：\n- 使用标量平流方程 $u_{t} + a u_{x} = 0$（其中 $a > 0$）以及用于计算界面 $x_{i+\\frac{1}{2}}$ 处状态的左偏置五阶WENO重构（Jiang–Shu 公式）。\n- 非线性权重 $\\omega_{k}$ 由光滑度指标计算得出，这些指标惩罚跨越间断的模板，并倾向于局部光滑的模板。计算中使用一个小的正参数 $\\varepsilon$ 以避免除零，并使用指数 $p$ 来控制敏感度。\n- 线性权重 $d_{k}$ 的总和为 $1$，并且对应于光滑区域中的最优线性五阶格式。\n\n将初始数据定义为黎曼阶跃：\n- 对于 $x < 0$，$u(x) = 0$；对于 $x > 0$，$u(x) = 1$；且 $u(0) = \\tfrac{1}{2}$。\n\n采用由以下公式定义的均匀节点网格：\n- $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$，其中 $j \\in \\mathbb{Z}$ 且 $\\Delta x > 0$，因此界面位于任意整数 $m$ 的 $x = m \\Delta x$ 处。\n- 对于每个选定的界面位置 $x = m \\Delta x$，使用五点模板 $\\{u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}\\}$（其中 $i = m - 1$）在该界面上重构左偏置五阶WENO值，使得界面为 $x_{i+\\frac{1}{2}} = (i+1)\\Delta x = m \\Delta x$。\n- 假设 $a > 0$，因此应用左偏置重构。使用点值 $u_{j} = u(x_{j})$。\n\n使用WENO-JS权重的标准参数：\n- 线性权重 $d_{0} = 0.1$, $d_{1} = 0.6$, $d_{2} = 0.3$。\n- 小参数 $\\varepsilon = 10^{-6}$。\n- 指数 $p = 2$。\n\n您的任务：\n- 对于下面指定的每个测试用例，计算指定界面处的非线性权重向量 $\\left[\\omega_{0}, \\omega_{1}, \\omega_{2}\\right]$。每个 $\\omega_{k}$ 必须以浮点数形式返回，并四舍五入到 $6$ 位小数。\n\n测试套件：\n- 使用以下网格间距 $\\Delta x \\in \\{0.5, 0.25, 0.125\\}$ 和界面偏移量 $m \\in \\{-2, 0, 1\\}$。\n- 这将按以下顺序列出 $9$ 个测试用例：\n    1. $(\\Delta x, m) = (0.5, -2)$\n    2. $(\\Delta x, m) = (0.25, -2)$\n    3. $(\\Delta x, m) = (0.125, -2)$\n    4. $(\\Delta x, m) = (0.5, 0)$\n    5. $(\\Delta x, m) = (0.25, 0)$\n    6. $(\\Delta x, m) = (0.125, 0)$\n    7. $(\\Delta x, m) = (0.5, 1)$\n    8. $(\\Delta x, m) = (0.25, 1)$\n    9. $(\\Delta x, m) = (0.125, 1)$\n\n实现说明：\n- 将标量场值视为上述定义的不连续函数的逐点采样 $u_{j} = u(x_{j})$。特别地，为了完整性指定了 $u(0) = \\tfrac{1}{2}$，但由于 $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$，在这些测试用例中没有网格节点恰好位于 $x = 0$ 处。\n- 使用与三个尺寸为 $3$ 的子模板相关联的标准五阶WENO-JS光滑度指标和权重定义。不要引入替代的光滑度指标或映射权重；请使用原始的 Jiang–Shu 形式。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 每个条目必须是对应测试用例的列表 $\\left[\\omega_{0}, \\omega_{1}, \\omega_{2}\\right]$，其中每个权重都四舍五入到 $6$ 位小数。\n- 具体来说，输出应类似于单个 Python 风格的列表的列表，例如：$[[\\omega_{0}^{(1)},\\omega_{1}^{(1)},\\omega_{2}^{(1)}],[\\omega_{0}^{(2)},\\omega_{1}^{(2)},\\omega_{2}^{(2)}],\\dots,[\\omega_{0}^{(9)},\\omega_{1}^{(9)},\\omega_{2}^{(9)}]]$。\n\n不涉及物理单位；报告纯数字。不使用角度。不使用百分比。最终输出必须严格遵循上述描述，仅为一行，无任何附加文本。", "solution": "我们分析用于线性平流的标量双曲守恒律的 Jiang–Shu 五阶加权本质无振荡 (WENO) 格式的非线性权重 $\\omega_{k}$。基本基础包括：标量平流方程 $u_{t} + a u_{x} = 0$ 且 $a > 0$（一个双曲守恒律），以及WENO-JS非线性权重的核心定义，该权重由光滑度指标计算得出，这些指标测量子模板上的局部变化并据此混合线性权重。\n\n原理和定义：\n- 对于 $a > 0$，左偏置重构基于五个节点值 $\\{u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}\\}$ 提供界面 $x_{i+\\frac{1}{2}}$ 处的近似值。\n- 五阶WENO-JS方法在三个子模板 $S_{0} = \\{i-2,i-1,i\\}$、$S_{1} = \\{i-1,i,i+1\\}$、$S_{2} = \\{i,i+1,i+2\\}$ 上构建三个二次多项式，并关联总和为 $1$ 的线性权重 $d_{0} = 0.1$、$d_{1} = 0.6$、$d_{2} = 0.3$。\n- Jiang–Shu 光滑度指标 $\\beta_{k}$ 通过平方导数的离散近似来量化每个子模板上的局部光滑度。非线性权重定义为\n$$\n\\alpha_{k} = \\frac{d_{k}}{(\\varepsilon + \\beta_{k})^{p}}, \\quad \\omega_{k} = \\frac{\\alpha_{k}}{\\alpha_{0} + \\alpha_{1} + \\alpha_{2}},\n$$\n其中 $\\varepsilon = 10^{-6}$ 且 $p = 2$。\n\n网格几何与采样：\n- 节点为 $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$，因此对于整数 $m$，界面位于 $x = m \\Delta x$，其中 $x_{i+\\frac{1}{2}} = (i+1)\\Delta x$ 对应于 $i = m - 1$。\n- 初始条件是黎曼阶跃：当 $x < 0$ 时 $u(x) = 0$，当 $x > 0$ 时 $u(x) = 1$，且 $u(0) = \\tfrac{1}{2}$。对于所选节点 $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$，没有节点恰好位于 $x=0$ 处，因此不采样 $u(0)$。\n\n基于第一性原理的间断附近行为：\n- WENO机制会增加解光滑的子模板（$\\beta_{k}$较小）的权重 $\\omega_{k}$，并减少跨越间断的子模板（$\\beta_{k}$较大）的权重。只要重构方向由 $a$ 的符号确定，此行为就与具体的通量无关。\n- 考虑位于 $x = 0$ 的界面，对应于 $m = 0$ 和 $i = -1$。涉及的五个节点位置为 $x_{-3} = (-2.5)\\Delta x$, $x_{-2} = (-1.5)\\Delta x$, $x_{-1} = (-0.5)\\Delta x$, $x_{0} = (0.5)\\Delta x$, $x_{1} = (1.5)\\Delta x$。采样值为 $u_{-3} = 0$, $u_{-2} = 0$, $u_{-1} = 0$, $u_{0} = 1$, $u_{1} = 1$。最左边的子模板 $S_{0} = \\{-3,-2,-1\\}$ 严格位于左侧，数据在此处为常数；因此其光滑度指标满足 $\\beta_{0} = 0$。其他子模板 $S_{1}$ 和 $S_{2}$ 跨越了间断，它们的光滑度指标是 $O(1)$ 的常数，其值取决于跳跃幅度，但与 $\\Delta x$ 无关，因为采样值在跳跃处是分段常数。\n- 当 $\\varepsilon$ 固定且非常小时，这会得到 $\\alpha_{0} = d_{0}/\\varepsilon^{p}$，与 $\\alpha_{1}$ 和 $\\alpha_{2}$ 相比极大，因此 $\\omega_{0} \\approx 1$, $\\omega_{1} \\approx 0$, $\\omega_{2} \\approx 0$。重要的是，这个结论与 $\\Delta x$ 无关，因为在网格加密过程中，跨越跳跃的模板上的指标保持为 $O(1)$，而光滑模板的指标对于此采样保持为 $0$。\n- 考虑位于 $x = \\Delta x$ 的界面，对应于 $m = 1$ 和 $i = 0$。五个节点位于 $x_{-2} = (-1.5)\\Delta x$, $x_{-1} = (-0.5)\\Delta x$, $x_{0} = (0.5)\\Delta x$, $x_{1} = (1.5)\\Delta x$, $x_{2} = (2.5)\\Delta x$，采样值为 $u_{-2} = 0$, $u_{-1} = 0$, $u_{0} = 1$, $u_{1} = 1$, $u_{2} = 1$。现在最右边的子模板 $S_{2} = \\{0,1,2\\}$ 严格位于右侧光滑区域；因此 $\\beta_{2} = 0$ 且 $\\omega_{2} \\approx 1$, $\\omega_{0}, \\omega_{1} \\approx 0$，这同样与 $\\Delta x$ 无关。\n- 考虑一个离间断足够远的界面，位于完全光滑的左侧区域，例如 $x = -2\\Delta x$，此时 $m = -2$ 且 $i = -3$。五个节点都严格位于间断的左侧，因此所有采样值均为 $0$，且每个光滑度指标都满足 $\\beta_{k} = 0$。在这种情况下，非线性权重精确地退化为线性权重：\n$$\n\\alpha_{k} = \\frac{d_{k}}{\\varepsilon^{p}}, \\quad \\sum_{k=0}^{2} \\alpha_{k} = \\frac{1}{\\varepsilon^{p}} \\sum_{k=0}^{2} d_{k} = \\frac{1}{\\varepsilon^{p}},\n$$\n因此，对于 $k \\in \\{0,1,2\\}$，有 $\\omega_{k} = d_{k}$，这同样与 $\\Delta x$ 无关。\n\n因此，对于这种不连续的初始条件和节点采样，理论预期是：\n- 在 $m = 0$（界面位于间断处）时，$\\omega_{0} \\to 1$ 且 $\\omega_{1}, \\omega_{2} \\to 0$，与 $\\Delta x$ 无关。\n- 在 $m = 1$（界面向右一个单元）时，$\\omega_{2} \\to 1$ 且 $\\omega_{0}, \\omega_{1} \\to 0$，与 $\\Delta x$ 无关。\n- 在 $m = -2$（界面在光滑区域中向左两个单元）时，对所有 $k$ 均有 $\\omega_{k} = d_{k}$，与 $\\Delta x$ 无关。\n\n用于计算测试套件的算法设计：\n- 对于每个测试用例 $(\\Delta x, m)$，设置 $i = m - 1$。通过采样 $u_{j} = u(x_{j})$（其中 $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$）和定义的分段常数阶跃函数 $u(x)$ 来构建五点向量 $\\{u_{i-2},u_{i-1},u_{i},u_{i+1},u_{i+2}\\}$。\n- 使用基于未除差分的标准离散公式，计算子模板 $S_{0},S_{1},S_{2}$ 上的 Jiang–Shu 光滑度指标 $(\\beta_{0},\\beta_{1},\\beta_{2})$。这些指标是非负的，并且在常数数据上精确为零。\n- 使用 $d_{0} = 0.1, d_{1} = 0.6, d_{2} = 0.3, \\varepsilon = 10^{-6}, p = 2$ 构建 $\\alpha_{k} = d_{k}/(\\varepsilon + \\beta_{k})^{p}$，然后归一化为 $\\omega_{k} = \\alpha_{k}/\\sum_{j=0}^{2}\\alpha_{j}$。\n- 将每个 $\\omega_{k}$ 四舍五入到 $6$ 位小数以供报告。\n\n定性结果和数值：\n- 对于 $(\\Delta x, m) = (0.5, -2)$, $(0.25, -2)$, $(0.125, -2)$，所有五个点都位于左侧光滑区域，且 $u_{j} = 0$，因此归一化后精确地有 $(\\omega_{0},\\omega_{1},\\omega_{2}) = (0.1, 0.6, 0.3)$，所以报告值为 $[0.1, 0.6, 0.3]$。\n- 对于 $(\\Delta x, m) = (0.5, 0)$, $(0.25, 0)$, $(0.125, 0)$，只有最左边的子模板是光滑的；因此 $(\\omega_{0},\\omega_{1},\\omega_{2}) \\approx (1, 0, 0)$；四舍五入到 $6$ 位小数后得到 $[1.0, 0.0, 0.0]$。\n- 对于 $(\\Delta x, m) = (0.5, 1)$, $(0.25, 1)$, $(0.125, 1)$，只有最右边的子模板是光滑的；因此 $(\\omega_{0},\\omega_{1},\\omega_{2}) \\approx (0, 0, 1)$；四舍五入到 $6$ 位小数后得到 $[0.0, 0.0, 1.0]$。\n\n这些结果从第一性原理和计算两方面证实，对于给定的节点采样和固定的 $\\varepsilon$，跨越间断时，WENO-JS非线性权重会饱和到完全位于光滑区域一侧的模板上，并且这种饱和效应实际上与 $\\Delta x$ 无关。在完全光滑的区域，权重退化为线性权重，也与 $\\Delta x$ 无关。", "answer": "```python\nimport numpy as np\n\ndef weno_js_weights(u_im2, u_im1, u_i, u_ip1, u_ip2, eps=1e-6, p=2):\n    \"\"\"\n    Compute WENO-JS (5th order, left-biased) nonlinear weights at an interface\n    using point values u_{i-2},...,u_{i+2}. Returns [omega0, omega1, omega2].\n    \"\"\"\n    # Smoothness indicators (Jiang–Shu) for left-biased reconstruction\n    beta0 = (13.0/12.0)*(u_im2 - 2.0*u_im1 + u_i)**2 + 0.25*(u_im2 - 4.0*u_im1 + 3.0*u_i)**2\n    beta1 = (13.0/12.0)*(u_im1 - 2.0*u_i + u_ip1)**2 + 0.25*(u_im1 - u_ip1)**2\n    beta2 = (13.0/12.0)*(u_i - 2.0*u_ip1 + u_ip2)**2 + 0.25*(3.0*u_i - 4.0*u_ip1 + u_ip2)**2\n\n    d0, d1, d2 = 0.1, 0.6, 0.3\n\n    alpha0 = d0 / (eps + beta0)**p\n    alpha1 = d1 / (eps + beta1)**p\n    alpha2 = d2 / (eps + beta2)**p\n\n    asum = alpha0 + alpha1 + alpha2\n    omega0 = alpha0 / asum\n    omega1 = alpha1 / asum\n    omega2 = alpha2 / asum\n    return [omega0, omega1, omega2]\n\ndef step_ic(x):\n    # u(x) = 0 for x<0, 1 for x>0, 0.5 for x==0\n    if x > 0.0:\n        return 1.0\n    elif x < 0.0:\n        return 0.0\n    else:\n        return 0.5\n\ndef weights_for_case(dx, m):\n    \"\"\"\n    Nodes: x_j = (j + 0.5) * dx\n    Interface at x = m * dx corresponds to i = m - 1, interface is between i and i+1.\n    Left-biased WENO uses stencil u_{i-2},...,u_{i+2}.\n    \"\"\"\n    i = m - 1\n    # Collect nodal values u_{i-2} ... u_{i+2}\n    us = []\n    for j in range(i-2, i+3):\n        xj = (j + 0.5) * dx\n        us.append(step_ic(xj))\n    omega = weno_js_weights(us[0], us[1], us[2], us[3], us[4])\n    # Round to 6 decimals as required\n    omega = [float(f\"{w:.6f}\") for w in omega]\n    return omega\n\ndef solve():\n    # Define the test cases from the problem statement: 9 cases\n    dxs = [0.5, 0.25, 0.125]\n    ms = [-2, 0, 1]\n    test_cases = []\n    # Order: for each m in [-2,0,1], sweep dxs in order listed to match the problem ordering\n    # The problem lists in blocks: (dx,-2) for all dxs, then (dx,0), then (dx,1).\n    for m in [-2, 0, 1]:\n        for dx in [0.5, 0.25, 0.125]:\n            test_cases.append((dx, m))\n\n    results = []\n    for dx, m in test_cases:\n        omega = weights_for_case(dx, m)\n        results.append(omega)\n\n    # Final print statement: a single line list of lists\n    # Format exactly as a Python-style list of lists with commas.\n    inner = \",\".join(\"[\" + \",\".join(str(v) for v in trip) + \"]\" for trip in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2450629"}, {"introduction": "一个稳健的空间离散格式（如WENO）必须与合适的时间步进方法相结合，才能构成一个稳定且精确的求解器。本练习将探索保强稳定性（Strong-Stability-Preserving, SSP）龙格-库塔方法的关键概念，这类方法旨在保持空间格式的稳定性（如无振荡性）。您将为一个包含激波的问题实现并比较不同的时间积分器，亲眼观察为什么SSP方法对于可靠的激波捕捉模拟至关重要。[@problem_id:2450643]", "problem": "考虑一维标量双曲守恒律，由无粘伯格斯方程（inviscid Burgers equation）给出\n$$\nu_t + \\left(\\tfrac{1}{2}u^2\\right)_x = 0,\n$$\n该方程定义在周期性空间区域 $[-1,1]$ 上，初始数据为\n$$\nu(x,0) = \\begin{cases}\n1, & x < 0,\\\\\n0, & x \\ge 0.\n\\end{cases}\n$$\n设空间网格为均匀网格，有 $N=400$ 个点覆盖 $[-1,1)$，网格间距为 $\\Delta x = 2/N$。使用周期性边界条件。空间离散化采用五阶加权本质无振荡（WENO, Weighted Essentially Non-Oscillatory）重构，并结合全局 Lax–Friedrichs 通量分裂，其中在当前阶段状态下使用界 $\\alpha=\\max_i |u_i|$。定义半离散算子 $L(u)$，用此 WENO 通量在单元节点上逼近 $- \\partial_x f(u)$，其中 $f(u)=\\tfrac{1}{2}u^2$。时间上使用显式 Runge–Kutta (RK) 方法进行推进。考虑以下显式时间积分器：前向欧拉法（FE, Forward Euler）、二阶强稳定性保持 Runge–Kutta 方法（SSPRK2, second-order Strong-Stability-Preserving Runge–Kutta）、三阶强稳定性保持 Runge–Kutta 方法（SSPRK3, third-order Strong-Stability-Preserving Runge–Kutta）以及经典的四阶 Runge–Kutta 方法（RK4, classical fourth-order Runge–Kutta）。强稳定性保持（SSP, Strong-Stability-Preserving）属性通过离散总变差在时间上的单调性来评估。\n\n定义状态 $u\\in\\mathbb{R}^N$ 的离散总变差为\n$$\n\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} \\left|u_{i+1}-u_i\\right|,\n$$\n其中采用周期性索引 $u_N \\equiv u_0$。设每个完整时间步开始时，时间步长由 Courant–Friedrichs–Lewy 数 $\\mathrm{CFL}$ 根据以下公式确定\n$$\n\\Delta t = \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_i |u_i|},\n$$\n并进行裁剪以确保不超过到达最终时间 $T$ 的剩余时间。使用固定的最终时间 $T=0.2$。对于每个完整时间步，按时间顺序记录每个中间 RK 阶段状态和步末状态的 $\\mathrm{TV}$ 值序列。如果在每次比较中，记录的序列在容差 $\\varepsilon=10^{-8}$ 内是单调不增的，则称该次运行是“$\\mathrm{TV}$不增”的。也就是说，对于记录序列中每对连续的值，后一个值小于或等于前一个值加上 $\\varepsilon$。\n\n实现一个程序，对每个测试用例，从 $t=0$ 积分到 $t=T$，并返回一个布尔值，该值指示记录的总变差序列是否如上文定义的单调不增。使用以下测试套件，其中每个测试用例是一个对 $(\\text{方法名称}, \\mathrm{CFL})$，方法名称是字符串 \"FE\"、\"SSPRK2\"、\"SSPRK3\"、\"RK4\" 之一：\n- $($\"SSPRK3\", $0.4)$,\n- $($\"SSPRK2\", $0.8)$,\n- $($\"FE\", $0.4)$,\n- $($\"RK4\", $0.8)$,\n- $($\"RK4\", $0.9)$,\n- $($\"SSPRK3\", $0.9)$,\n- $($\"FE\", $0.9)$.\n\n您的程序应生成单行输出，其中包含按所列顺序排列的测试用例结果，格式为方括号内由逗号分隔的布尔字面量列表，不含空格。例如，输出应如下所示\n$$\n[true,false,...]\n$$\n尽管实际的布尔值应为您的程序针对指定测试套件计算出的值。", "solution": "该问题要求对一维无粘伯格斯方程进行数值求解，这是一维标量双曲守恒律的典型例子：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2}u^2\\right) = 0\n$$\n该方程定义在周期性空间区域 $x \\in [-1, 1]$ 上，初始数据为阶跃函数：\n$$\nu(x,0) = \\begin{cases} 1, & x < 0 \\\\ 0, & x \\ge 0 \\end{cases}\n$$\n我们需要研究几种显式 Runge-Kutta 时间积分格式与高阶空间离散化方法耦合时的总变差（TV）稳定性。\n\n首先，该问题在空间上通过有限体积法在包含 $N=400$ 个单元的均匀网格上进行离散，网格间距为 $\\Delta x = 2/N$。这产生了一个常微分方程组（ODEs）：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x}(\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2}) \\equiv L(u)_i\n$$\n其中 $u_i(t)$ 是第 $i$ 个单元内的单元平均解，$\\hat{f}_{i+1/2}$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。\n\n数值通量 $\\hat{f}_{i+1/2}$ 是通过五阶加权本质无振荡（WENO）方法结合全局 Lax-Friedrichs 通量分裂来构造的。通量函数 $f(u) = \\frac{1}{2}u^2$ 被分裂为其正部和负部：\n$$\nf^+(u) = \\frac{1}{2}(f(u) + \\alpha u), \\quad f^-(u) = \\frac{1}{2}(f(u) - \\alpha u)\n$$\n其中 $\\alpha = \\max_i |f'(u_i)| = \\max_i |u_i|$ 是最大特征速度的全局估计。数值通量是这些分裂通量重构后的和：\n$$\n\\hat{f}_{i+1/2} = \\hat{f}^+_{i+1/2} + \\hat{f}^-_{i+1/2}\n$$\n分裂通量分量 $\\hat{f}^+_{i+1/2}$ 是根据单元平均值 $\\{f^+(u_j)\\}$，使用左偏模板重构的，因为其对应的特征速度是非负的。相反，$\\hat{f}^-_{i+1/2}$ 是根据 $\\{f^-(u_j)\\}$，使用右偏模板重构的，因为其特征速度是非正的。这构成了迎风离散格式。\n\n在界面 $x_{i+1/2}$ 处的值的五阶 WENO 重构是三个三阶多项式重构的非线性凸组合。对于用于 $\\hat{f}^+_{i+1/2}$ 的左偏情况，该值来自覆盖单元 $\\{i-2, i-1, i\\}$、$\\{i-1, i, i+1\\}$ 和 $\\{i, i+1, i+2\\}$ 的模板。组合权重（记为 $\\omega_k$）是基于每个模板的光滑度指标 $\\beta_k$ 计算的。这些指标衡量了每个模板上重构多项式的振荡程度。对于一组通用值 $\\{v_j\\}$，光滑度指标由以下公式给出：\n$$\n\\begin{aligned}\n\\beta_0 &= \\frac{13}{12}(v_{i-2} - 2v_{i-1} + v_i)^2 + \\frac{1}{4}(v_{i-2} - 4v_{i-1} + 3v_i)^2 \\\\\n\\beta_1 &= \\frac{13}{12}(v_{i-1} - 2v_i + v_{i+1})^2 + \\frac{1}{4}(v_{i-1} - v_{i+1})^2 \\\\\n\\beta_2 &= \\frac{13}{12}(v_i - 2v_{i+1} + v_{i+2})^2 + \\frac{1}{4}(3v_i - 4v_{i+1} + v_{i+2})^2\n\\end{aligned}\n$$\n非线性权重则为 $\\omega_k = \\gamma_k / (\\beta_k + \\varepsilon)^2$，其中 $\\{\\gamma_k\\} = \\{0.1, 0.6, 0.3\\}$ 是最优线性权重，$\\varepsilon$ 是一个为避免除以零而设的小参数。归一化后，$\\tilde{\\omega}_k = \\omega_k / \\sum_j \\omega_j$，最终重构的值为 $\\sum_k \\tilde{\\omega}_k p_k$，其中 $p_k$ 是在界面处求值的、来自模板 $k$ 的重构多项式的值。用于 $\\hat{f}^-_{i+1/2}$ 的右偏重构是通过利用格式在反转数据数组上的对称性来实现的。\n\n得到的半离散系统 $\\frac{du}{dt} = L(u)$ 使用四种显式 Runge-Kutta 方法之一进行时间积分：\n1.  **前向欧拉法 (FE):** 一阶方法，$u^{n+1} = u^n + \\Delta t L(u^n)$。\n2.  **SSPRK2:** 一种二阶强稳定性保持方法。\n    $$\n    \\begin{aligned}\n    u^{(1)} &= u^n + \\Delta t L(u^n) \\\\\n    u^{n+1} &= \\frac{1}{2}u^n + \\frac{1}{2}(u^{(1)} + \\Delta t L(u^{(1)}))\n    \\end{aligned}\n    $$\n3.  **SSPRK3:** 一种三阶强稳定性保持方法。\n    $$\n    \\begin{aligned}\n    u^{(1)} &= u^n + \\Delta t L(u^n) \\\\\n    u^{(2)} &= \\frac{3}{4}u^n + \\frac{1}{4}(u^{(1)} + \\Delta t L(u^{(1)})) \\\\\n    u^{n+1} &= \\frac{1}{3}u^n + \\frac{2}{3}(u^{(2)} + \\Delta t L(u^{(2)}))\n    \\end{aligned}\n    $$\n4.  **经典 RK4:** 经典的四阶 Runge-Kutta 方法，通常不具备 SSP 性质。\n    $$\n    \\begin{aligned}\n    k_1 &= L(u^n) \\\\\n    k_2 &= L(u^n + \\frac{\\Delta t}{2} k_1) \\\\\n    k_3 &= L(u^n + \\frac{\\Delta t}{2} k_2) \\\\\n    k_4 &= L(u^n + \\Delta t k_3) \\\\\n    u^{n+1} &= u^n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{aligned}\n    $$\n    为了检查其总变差特性，我们需要跟踪所有中间阶段的状态。这些状态是：初始状态 $u^n$，用于计算 $k_2$ 的状态 $u^n + \\frac{\\Delta t}{2} k_1$，用于计算 $k_3$ 的状态 $u^n + \\frac{\\Delta t}{2} k_2$，用于计算 $k_4$ 的状态 $u^n + \\Delta t k_3$，以及最终状态 $u^{n+1}$。\n\n时间步长 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 条件确定：$\\Delta t = \\mathrm{CFL} \\frac{\\Delta x}{\\max_i |u_i|}$。\n\n问题的核心是评估这些格式的“TV不增”性质。离散总变差定义为 $\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} |u_{i+1} - u_i|$，其中采用周期性索引 $u_N \\equiv u_0$。对于每个完整的时间步，我们必须记录步初、每个中间 RK 阶段以及步末解的 TV。对于给定的方法和 CFL 数，当且仅当在此序列中每对连续记录值的 $TV_{k+1} \\le TV_k + \\varepsilon$（其中 $\\varepsilon=10^{-8}$ 是一个小容差）时，模拟运行才被视为“TV不增”。此检查在每个时间步都会执行，直到最终时间 $T=0.2$。例如，经典 RK4 的非 SSP 性质可能导致中间阶段的 TV 超过前一阶段的 TV，从而违反此条件，尤其是在较大的 CFL 数下。SSP 方法专门设计用于防止这种行为，前提是 CFL 数在方法的 SSP 限制范围内。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the specified test suite.\n    \"\"\"\n    # Problem Constants\n    N = 400\n    DOMAIN_START = -1.0\n    DOMAIN_END = 1.0\n    T_FINAL = 0.2\n    TV_TOLERANCE = 1e-8\n    WENO_EPS = 1e-40\n\n    DX = (DOMAIN_END - DOMAIN_START) / N\n    x = np.linspace(DOMAIN_START, DOMAIN_END, N, endpoint=False)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        (\"SSPRK3\", 0.4),\n        (\"SSPRK2\", 0.8),\n        (\"FE\", 0.4),\n        (\"RK4\", 0.8),\n        (\"RK4\", 0.9),\n        (\"SSPRK3\", 0.9),\n        (\"FE\", 0.9),\n    ]\n\n    # --- WENO5 Implementation ---\n    # Based on the formulation by Jiang and Shu (1996)\n    \n    # Precompute constants for vectorized WENO flux calculation\n    C_p0 = np.array([1./3., -7./6., 11./6.])\n    C_p1 = np.array([-1./6., 5./6., 1./3.])\n    C_p2 = np.array([1./3., 5./6., -1./6.])\n    D_L = np.array([0.1, 0.6, 0.3])\n\n    def weno5_flux_reconstruction(v):\n        \"\"\"\n        Computes the 5th-order left-biased WENO flux reconstruction.\n        This is a vectorized implementation for performance.\n        \"\"\"\n        v_padded = np.pad(v, (3, 3), 'wrap')\n        \n        v_m2 = v_padded[1:-5]\n        v_m1 = v_padded[2:-4]\n        v_0  = v_padded[3:-3]\n        v_p1 = v_padded[4:-2]\n        v_p2 = v_padded[5:-1]\n\n        # Smoothness indicators (beta)\n        beta0 = 13./12. * (v_m2 - 2*v_m1 + v_0)**2 + 0.25 * (v_m2 - 4*v_m1 + 3*v_0)**2\n        beta1 = 13./12. * (v_m1 - 2*v_0 + v_p1)**2 + 0.25 * (v_m1 - v_p1)**2\n        beta2 = 13./12. * (v_0 - 2*v_p1 + v_p2)**2 + 0.25 * (3*v_0 - 4*v_p1 + v_p2)**2\n        \n        # Nonlinear weights (alpha -> omega)\n        alpha0 = D_L[0] / (WENO_EPS + beta0)**2\n        alpha1 = D_L[1] / (WENO_EPS + beta1)**2\n        alpha2 = D_L[2] / (WENO_EPS + beta2)**2\n        sum_alpha = alpha0 + alpha1 + alpha2\n        \n        w0 = alpha0 / sum_alpha\n        w1 = alpha1 / sum_alpha\n        w2 = alpha2 / sum_alpha\n        \n        # Reconstructed fluxes from each sub-stencil\n        p0 = C_p0[0]*v_m2 + C_p0[1]*v_m1 + C_p0[2]*v_0\n        p1 = C_p1[0]*v_m1 + C_p1[1]*v_0  + C_p1[2]*v_p1\n        p2 = C_p2[0]*v_0  + C_p2[1]*v_p1  + C_p2[2]*v_p2\n        \n        return w0*p0 + w1*p1 + w2*p2\n\n    def spatial_operator_L(u):\n        \"\"\"\n        Computes the semi-discrete operator L(u) = -d/dx(f(u)).\n        \"\"\"\n        alpha = np.max(np.abs(u))\n        \n        f = 0.5 * u**2\n        f_plus = 0.5 * (f + alpha * u)\n        f_minus = 0.5 * (f - alpha * u)\n        \n        # Reconstruct positive flux (left-biased)\n        f_hat_plus = weno5_flux_reconstruction(f_plus)\n        \n        # Reconstruct negative flux (right-biased) using symmetry\n        f_minus_rev = f_minus[::-1]\n        f_hat_minus_rev = weno5_flux_reconstruction(f_minus_rev)\n        f_hat_minus = f_hat_minus_rev[::-1]\n        \n        # Total numerical flux at interfaces i+1/2\n        f_hat = f_hat_plus + f_hat_minus\n        \n        # Finite volume difference\n        f_hat_im12 = np.roll(f_hat, 1)\n        \n        return -(f_hat - f_hat_im12) / DX\n\n    def total_variation(u):\n        \"\"\"Computes the total variation of a state vector.\"\"\"\n        return np.sum(np.abs(u - np.roll(u, -1)))\n\n    # --- Time Stepper Implementations ---\n    def step_fe(u, dt, L_op):\n        tv0 = total_variation(u)\n        u_next = u + dt * L_op(u)\n        tv1 = total_variation(u_next)\n        return u_next, [tv0, tv1]\n\n    def step_ssprk2(u, dt, L_op):\n        tv0 = total_variation(u)\n        u1 = u + dt * L_op(u)\n        tv1 = total_variation(u1)\n        u_next = 0.5 * u + 0.5 * (u1 + dt * L_op(u1))\n        tv2 = total_variation(u_next)\n        return u_next, [tv0, tv1, tv2]\n\n    def step_ssprk3(u, dt, L_op):\n        tv0 = total_variation(u)\n        u1 = u + dt * L_op(u)\n        tv1 = total_variation(u1)\n        u2 = 0.75 * u + 0.25 * (u1 + dt * L_op(u1))\n        tv2 = total_variation(u2)\n        u_next = (1./3.) * u + (2./3.) * (u2 + dt * L_op(u2))\n        tv3 = total_variation(u_next)\n        return u_next, [tv0, tv1, tv2, tv3]\n\n    def step_rk4(u, dt, L_op):\n        tv0 = total_variation(u)\n        k1 = L_op(u)\n        stage1 = u + dt/2. * k1\n        tv1 = total_variation(stage1)\n        k2 = L_op(stage1)\n        stage2 = u + dt/2. * k2\n        tv2 = total_variation(stage2)\n        k3 = L_op(stage2)\n        stage3 = u + dt * k3\n        tv3 = total_variation(stage3)\n        k4 = L_op(stage3)\n        u_next = u + dt/6. * (k1 + 2*k2 + 2*k3 + k4)\n        tv4 = total_variation(u_next)\n        return u_next, [tv0, tv1, tv2, tv3, tv4]\n\n    stepper_map = {\n        \"FE\": step_fe,\n        \"SSPRK2\": step_ssprk2,\n        \"SSPRK3\": step_ssprk3,\n        \"RK4\": step_rk4,\n    }\n\n    results = []\n    for method_name, cfl in test_cases:\n        # Initial condition\n        u = np.where(x < 0, 1.0, 0.0)\n        \n        t = 0.0\n        is_tv_nonincreasing = True\n        stepper = stepper_map[method_name]\n\n        while t < T_FINAL:\n            max_u_abs = np.max(np.abs(u))\n            # Prevent division by zero if u is all zero\n            if max_u_abs < 1e-12: \n                break \n            \n            dt = cfl * DX / max_u_abs\n            dt = min(dt, T_FINAL - t)\n            \n            u_next, tv_sequence = stepper(u, dt, spatial_operator_L)\n            \n            for i in range(len(tv_sequence) - 1):\n                if tv_sequence[i+1] > tv_sequence[i] + TV_TOLERANCE:\n                    is_tv_nonincreasing = False\n                    break\n            \n            if not is_tv_nonincreasing:\n                break\n                \n            u = u_next\n            t += dt\n            \n        results.append(is_tv_nonincreasing)\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\")\n    print(output_str)\n\n# Run the simulation\nsolve()\n```", "id": "2450643"}, {"introduction": "虽然像WENO-5这样的高阶格式在每个网格点上的计算成本比简单的低阶方法更高，但它们的真正优势在于能够用显著更少的网格点达到所需的精度。本练习将指导您定量比较五阶WENO格式与一个二阶格式在求解一个光滑问题时，达到特定误差容限所需的计算功。这个分析揭示了在科学计算中开发和使用复杂高阶方法的现实理由。[@problem_id:2450605]", "problem": "考虑一维线性平流方程，这是一个双曲守恒律的原型，由 $u_t + a u_x = 0$ 给出，定义在周期性域 $x \\in [0,1)$ 上，其中平流速度 $a > 0$ 为常数。初始条件为光滑三角波 $u(x,0) = \\sin(2\\pi k x)$，其中 $k$ 为整数空间频率。由于平移不变性和周期性，时间 $T$ 时的精确解为 $u(x,T) = \\sin(2\\pi k (x - a T))$。所有角度必须以弧度为单位进行解释，且不需要物理单位。\n\n您的任务是编写一个完整的、可运行的程序。对于几个指定的测试用例，该程序需要确定一个增加了线性人工黏性项的二阶中心差分格式，是否能以比五阶加权本质无振荡 (WENO-5) 格式更低的计算成本达到目标精度。使用方法线进行时间积分，时间推进方法为三阶强稳定保持 Runge–Kutta (SSP-RK3) 方法。假设采用周期性边界条件。\n\n实现以下两种空间离散化方法：\n\n- 带有人工黏性的中心差分格式 (CAV)：对平流导数 $u_x$ 采用中心近似，并结合一个与 $\\lvert a \\rvert$ 和用户指定的无量纲系数 $\\beta$ 成正比的附加线性人工黏性项。对中心导数和人工黏性项均使用宽度为 3 的标准对称模板，以确保在光滑区域内该方法具有一致的二阶精度。\n\n- 五阶加权本质无振荡格式 (WENO-5)：采用标准的在光滑区域具有五阶精度的 Jiang–Shu 重构，使用单侧偏置模板为迎风通量构造界面值，并结合守恒通量差分形式。使用与线性平流一致的 Lax–Friedrichs 型通量分裂，以及带有小正则化参数 $\\varepsilon$ 和幂次 $p = 2$ 的标准非线性权。设 $a > 0$，因此只需要迎风偏置重构。\n\n时间步进与稳定性：\n\n- 两种格式均使用三阶段的 SSP-RK3。\n- 两种格式均使用 Courant–Friedrichs–Lewy (CFL) 数 $\\text{CFL} = 0.4$。\n- 在具有 $N$ 个点和间距 $\\Delta x = 1/N$ 的均匀网格上，使用时间步长 $\\Delta t = \\text{CFL} \\, \\Delta x / \\lvert a \\rvert$。使用大小为 $\\Delta t$ 的步长从 $t=0$ 推进到 $t=T$，仅调整最后一步以确保精确到达 $t=T$。\n\n误差度量：\n\n- 使用时间 $T$ 时的离散 $L^1$ 误差：$E = \\frac{1}{N} \\sum_{i=0}^{N-1} \\lvert u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\rvert$，其中 $x_i = i \\Delta x$。\n\n计算成本模型：\n\n- 将总计算功定义为在所有 Runge–Kutta 阶段和时间步中，评估空间算子（右端项）所使用的浮点加法和乘法计数。在此模型中，加法和减法均计为一次加法操作；乘法、除法和整数次幂运算均计为一次乘法操作。时间积分阶段混合、循环开销和三角函数求值的操作不计入成本；只计算每个阶段的空间算子求值。\n- 对于 CAV 格式，假设在每个网格点上，空间算子的每次求值使用 $4$ 次加法和 $4$ 次乘法（总计 $8$ 次操作）。\n- 对于 WENO-5 格式，假设在每个界面上，重构迎风通量的每次求值使用 $28$ 次加法和 $46$ 次乘法，并且每个单元的通量差分组合额外使用 $1$ 次加法和 $1$ 次乘法（即每个网格点每次空间算子求值总计 $76$ 次操作）。\n- 设 $s = 3$ 为 SSP-RK3 的阶段数。如果所用的时间步数为 $n_t$，则对于一个有 $N$ 个点的网格，总功为 $W = s \\, n_t \\, N \\, \\mathcal{C}$，其中 CAV 的 $\\mathcal{C}$ 为 $8$，WENO-5 的 $\\mathcal{C}$ 为 $76$。\n\n精度目标与网格选择：\n\n- 对于每个格式和测试用例，从序列 $N \\in \\{32,64,128,256,512,1024,2048,4096\\}$ 中找到使离散 $L^1$ 误差小于或等于指定容差 $\\tau$ 的最小网格尺寸 $N$。如果在 $N=4096$ 之前都未找到这样的 $N$，则宣布该格式对于该测试用例不成功。\n- 对于使用最小 $N$ 的成功运行，使用上述成本模型计算总功 $W$，其中 $n_t$ 由达到时间 $T$ 所需的时间步进确定。\n\n测试套件：\n\n- 使用平流速度 $a = 1$、最终时间 $T = 1$ 和域长度 $1$。\n- 使用以下三个测试用例，每个用例指定为一个元组 $(k,\\tau,\\beta)$：\n  - 用例 1：$(k,\\tau,\\beta) = (1, 5 \\times 10^{-2}, 0.5)$。\n  - 用例 2：$(k,\\tau,\\beta) = (1, 10^{-6}, 0.5)$。\n  - 用例 3：$(k,\\tau,\\beta) = (3, 10^{-4}, 0.5)$。\n\n程序所需行为：\n\n- 对于每个测试用例，在上述条件下，并假设两种格式在该测试用例下均成功，确定 CAV 格式是否能以比 WENO-5 格式严格更低的总功 $W$ 达到目标容差。\n- 如果其中一种格式在允许的网格尺寸内未能满足容差，则将该用例的比较结果视为 $\\text{False}$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个布尔值，顺序与上面列出的顺序相同。例如，一个有效的输出行格式为 `[true,false,true]`。", "solution": "所提供的问题被评估为**有效的**。它代表了计算物理学中一个适定且有科学依据的练习，特别是在双曲偏微分方程的数值解方面。所有参数、方法和评估标准都得到了明确且客观的定义，从而能够得出一个唯一且可验证的解。该问题要求比较二阶和五阶数值格式之间的计算效率，这是数值分析中的一个标准且有意义的问题。\n\n该问题围绕一维线性平流方程展开：\n$$\nu_t + a u_x = 0\n$$\n该方程定义在周期性域 $x \\in [0,1)$ 上，平流速度 $a > 0$ 为常数。初始条件是光滑正弦波 $u(x,0) = \\sin(2\\pi k x)$。精确解由一个简单的平移给出：\n$$\nu(x,T) = \\sin(2\\pi k (x - aT))\n$$\n我们的任务是比较带有人工黏性的二阶中心格式 (CAV) 和五阶加权本质无振荡 (WENO-5) 格式。比较的依据是达到指定精度容差 $\\tau$ 所需的计算功。\n\n采用方法线，首先将空间导数离散化，得到一个关于时间的常微分方程组 (ODE)，然后使用三阶强稳定保持 Runge-Kutta (SSP-RK3) 方法求解该方程组。\n\n### 空间离散格式\n\n设计算域被离散为 $N$ 个均匀的网格单元，单元中心为 $x_i = i \\Delta x$，其中 $i=0, \\dots, N-1$，且 $\\Delta x = 1/N$。单元 $i$ 上的解记为 $u_i$。方程的半离散形式为 $\\frac{du_i}{dt} = L(u)_i$，其中 $L(u)_i$ 是离散化的空间算子。\n\n**1. 带有人工黏性的中心差分 (CAV)**\n\nCAV 格式的空间算子结合了对流项的标准二阶中心差分和线性人工耗散项。问题指定的公式可解释如下：\n$$\nL_{\\text{CAV}}(u)_i = -a \\frac{u_{i+1} - u_{i-1}}{2\\Delta x} - \\nu_{\\text{num}} \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta x)^2}\n$$\n其中数值黏性系数 $\\nu_{\\text{num}}$ 由 $\\beta |a| \\Delta x$ 给出。参数 $\\beta$ 是一个用户定义的无量纲系数。将其代入方程，算子变为：\n$$\nL_{\\text{CAV}}(u)_i = -a \\frac{u_{i+1} - u_{i-1}}{2\\Delta x} - \\beta |a| \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x}\n$$\n对于光滑解，这是一个空间上二阶精度的格式。通过确保所有指数对 $N$ 取模来处理周期性边界条件，即 $u_{N} = u_0$ 且 $u_{-1} = u_{N-1}$。\n\n**2. 五阶加权本质无振荡 (WENO-5) 格式**\n\nWENO-5 格式在一个守恒型有限差分框架下实现：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x}(\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2})\n$$\n其中 $\\hat{f}_{i+1/2}$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。物理通量为 $f(u) = au$。由于 $a > 0$，信息从左向右传播，因此适用迎风偏置格式。通量使用 Lax-Friedrichs 方法进行分裂，其中 $f(u) = f^+(u) + f^-(u)$。对于 $a > 0$，这简化为 $f^+(u) = f(u) = au$ 和 $f^-(u) = 0$。因此，界面上的数值通量仅依赖于左侧（迎风侧）的重构：\n$$\n\\hat{f}_{i+1/2} = a u_{i+1/2}^L\n$$\n其中 $u_{i+1/2}^L$ 是在界面 $x_{i+1/2}$ 处，根据左侧单元的值对解 $u$ 进行的五阶 WENO 重构。该重构是三个在较小模板上的三阶多项式重构的非线性组合：\n$$\nu_{i+1/2}^L = w_0 \\hat{u}^{(0)}_{i+1/2} + w_1 \\hat{u}^{(1)}_{i+1/2} + w_2 \\hat{u}^{(2)}_{i+1/2}\n$$\n候选重构 $\\hat{u}^{(r)}_{i+1/2}$ 给出如下：\n\\begin{align*}\n\\hat{u}^{(0)}_{i+1/2} &= \\frac{1}{3}u_{i-2} - \\frac{7}{6}u_{i-1} + \\frac{11}{6}u_i \\\\\n\\hat{u}^{(1)}_{i+1/2} &= -\\frac{1}{6}u_{i-1} + \\frac{5}{6}u_i + \\frac{2}{6}u_{i+1} \\\\\n\\hat{u}^{(2)}_{i+1/2} &= \\frac{2}{6}u_i + \\frac{5}{6}u_{i+1} - \\frac{1}{6}u_{i+2}\n\\end{align*}\n非线性权 $w_r$ 依赖于光滑度指标 $IS_r$，后者衡量解在每个子模板上的变化：\n$$\nw_r = \\frac{\\alpha_r}{\\sum_{j=0}^2 \\alpha_j} \\quad \\text{其中} \\quad \\alpha_r = \\frac{d_r}{(\\varepsilon + IS_r)^p}\n$$\n理想权为 $d_0=0.1$、$d_1=0.6$、$d_2=0.3$，正则化参数设为 $\\varepsilon=10^{-6}$，幂次为 $p=2$。光滑度指标 $IS_r$ 是基于每个模板内 $u_i$ 值的缩放差分平方和的标准公式。\n\n### 时间积分与稳定性\n\n该常微分方程组使用三阶段 SSP-RK3 格式在时间上推进。给定 $\\frac{du}{dt} = L(u)$，从时间 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的一个步长为：\n\\begin{align*}\nu^{(1)} &= u^n + \\Delta t L(u^n) \\\\\nu^{(2)} &= \\frac{3}{4} u^n + \\frac{1}{4} \\left( u^{(1)} + \\Delta t L(u^{(1)}) \\right) \\\\\nu^{n+1} &= \\frac{1}{3} u^n + \\frac{2}{3} \\left( u^{(2)} + \\Delta t L(u^{(2)}) \\right)\n\\end{align*}\n时间步长 $\\Delta t$ 受 Courant-Friedrichs-Lewy (CFL) 稳定性条件的约束，即 $\\Delta t = \\text{CFL} \\frac{\\Delta x}{|a|}$，其中固定 $\\text{CFL}=0.4$。\n\n### 评估流程\n\n对于每个测试用例和每个格式（CAV 和 WENO-5），执行以下流程：\n1.  遍历指定的网格尺寸 $N \\in \\{32, 64, \\dots, 4096\\}$。\n2.  对于给定的 $N$，配置模拟：创建网格，设置初始条件，并确定时间步长 $\\Delta t$。\n3.  运行从 $t=0$ 到 $t=T$ 的模拟。步数固定为 $n_t = \\lceil T/\\Delta t \\rceil$，每步的大小为 $\\Delta t' = T/n_t$ 以确保精确到达最终时间。\n4.  计算 $T$ 时刻的离散 $L^1$ 误差：$E = \\frac{1}{N} \\sum_{i=0}^{N-1} |u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i, T)|$。\n5.  如果 $E \\le \\tau$，则这是满足精度要求的最小网格尺寸。对该格式的搜索停止。\n6.  总计算功 $W$ 使用提供的模型计算：$W = s \\cdot n_t \\cdot N \\cdot \\mathcal{C}$，其中 $s=3$ 是 RK 阶段数，$\\mathcal{C}$ 是每个阶段每个网格点的操作成本（$\\mathcal{C}_{\\text{CAV}}=8$，$\\mathcal{C}_{\\text{WENO-5}}=76$）。\n7.  如果循环完成而未能满足容差，则该格式在该测试用例中被视为“不成功”。\n\n最后，对于每个测试用例，布尔结果由条件 $(W_{\\text{CAV}} < W_{\\text{WENO-5}})$ 且（两种格式均成功）确定。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run the specified test cases and print the result.\n    \"\"\"\n    # Problem parameters\n    a = 1.0  # Advection speed\n    T = 1.0  # Final time\n    domain_length = 1.0\n    cfl = 0.4\n    grid_sizes = [32, 64, 128, 256, 512, 1024, 2048, 4096]\n    ssp_stages_s = 3\n    op_cost_cav = 8\n    op_cost_weno5 = 76\n\n    # Test suite\n    test_cases = [\n        # (k, tau, beta)\n        (1, 5e-2, 0.5),\n        (1, 1e-6, 0.5),\n        (3, 1e-4, 0.5),\n    ]\n\n    results = []\n    for k, tau, beta in test_cases:\n        # Run analysis for CAV scheme\n        work_cav, success_cav = run_analysis(\n            'CAV', k, tau, beta, a, T, domain_length, cfl, grid_sizes, ssp_stages_s, op_cost_cav)\n\n        # Run analysis for WENO-5 scheme\n        work_weno5, success_weno5 = run_analysis(\n            'WENO5', k, tau, beta, a, T, domain_length, cfl, grid_sizes, ssp_stages_s, op_cost_weno5)\n\n        # Comparison logic\n        if success_cav and success_weno5:\n            results.append(work_cav < work_weno5)\n        else:\n            results.append(False)\n\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\ndef run_analysis(scheme_type, k, tau, beta, a, T, domain_len, cfl, grid_sizes, s, cost_per_op):\n    \"\"\"\n    Finds the minimum grid size to meet tolerance and computes the work.\n    \"\"\"\n    for N in grid_sizes:\n        dx = domain_len / N\n        dt_cfl = cfl * dx / np.abs(a)\n        \n        # Adjust dt to land exactly at T\n        num_steps = int(np.ceil(T / dt_cfl))\n        dt = T / num_steps\n\n        # Grid and initial condition\n        x = np.linspace(0, domain_len, N, endpoint=False)\n        u0 = np.sin(2 * np.pi * k * x)\n\n        # Time integration\n        u_final = time_stepper(u0, N, dx, dt, num_steps, a, beta, scheme_type)\n\n        # Error calculation\n        u_exact = np.sin(2 * np.pi * k * (x - a * T))\n        l1_error = np.mean(np.abs(u_final - u_exact))\n\n        if l1_error <= tau:\n            # Success: calculate work and return\n            total_work = s * num_steps * N * cost_per_op\n            return total_work, True\n\n    # Failure: tolerance not met for any grid size\n    return float('inf'), False\n\ndef time_stepper(u, N, dx, dt, num_steps, a, beta, scheme_type):\n    \"\"\"\n    Performs time integration using SSP-RK3.\n    \"\"\"\n    u_current = u.copy()\n\n    if scheme_type == 'CAV':\n        rhs_func = lambda u_state: rhs_cav(u_state, a, dx, beta)\n    elif scheme_type == 'WENO5':\n        rhs_func = lambda u_state: rhs_weno5(u_state, a, dx)\n    else:\n        raise ValueError(\"Unknown scheme type\")\n\n    for _ in range(num_steps):\n        # SSP-RK3 stages\n        u1 = u_current + dt * rhs_func(u_current)\n        u2 = 0.75 * u_current + 0.25 * (u1 + dt * rhs_func(u1))\n        u_current = (1/3) * u_current + (2/3) * (u2 + dt * rhs_func(u2))\n\n    return u_current\n\ndef rhs_cav(u, a, dx, beta):\n    \"\"\"\n    Computes the RHS for the CAV scheme.\n    \"\"\"\n    u_p1 = np.roll(u, -1)\n    u_m1 = np.roll(u, 1)\n\n    advection_term = -a * (u_p1 - u_m1) / (2 * dx)\n    viscosity_term = -beta * np.abs(a) * (u_p1 - 2 * u + u_m1) / dx\n    \n    return advection_term + viscosity_term\n\ndef rhs_weno5(u, a, dx):\n    \"\"\"\n    Computes the RHS for the WENO-5 scheme.\n    \"\"\"\n    # Since a > 0, we only need the upwind flux from the left.\n    # The flux function is f(u) = a*u.\n    # We reconstruct u to get u_L at interfaces, then flux is a * u_L.\n    \n    u_m2 = np.roll(u, 2)\n    u_m1 = np.roll(u, 1)\n    u_p1 = np.roll(u, -1)\n    u_p2 = np.roll(u, -2)\n\n    # Smoothness indicators (IS_r)\n    eps = 1e-6\n    p = 2.0\n    \n    # Stencil 0: {i-2, i-1, i}\n    is0 = (13/12) * (u_m2 - 2*u_m1 + u)**2 + 0.25 * (u_m2 - 4*u_m1 + 3*u)**2\n    # Stencil 1: {i-1, i, i+1}\n    is1 = (13/12) * (u_m1 - 2*u + u_p1)**2 + 0.25 * (u_m1 - u_p1)**2\n    # Stencil 2: {i, i+1, i+2}\n    is2 = (13/12) * (u - 2*u_p1 + u_p2)**2 + 0.25 * (3*u - 4*u_p1 + u_p2)**2\n    \n    # Ideal weights\n    d0, d1, d2 = 0.1, 0.6, 0.3\n    \n    # Nonlinear weights (alpha_r and w_r)\n    alpha0 = d0 / (eps + is0)**p\n    alpha1 = d1 / (eps + is1)**p\n    alpha2 = d2 / (eps + is2)**p\n    \n    w_sum = alpha0 + alpha1 + alpha2\n    w0 = alpha0 / w_sum\n    w1 = alpha1 / w_sum\n    w2 = alpha2 / w_sum\n\n    # Candidate reconstructions for u at i+1/2 from left\n    u_rec0 = (1/3)*u_m2 - (7/6)*u_m1 + (11/6)*u\n    u_rec1 = -(1/6)*u_m1 + (5/6)*u + (2/6)*u_p1\n    u_rec2 = (2/6)*u + (5/6)*u_p1 - (1/6)*u_p2\n\n    # Reconstructed value u^L_{i+1/2} for all i\n    u_L_iph = w0 * u_rec0 + w1 * u_rec1 + w2 * u_rec2\n\n    # The flux at i+1/2 is a * u^L_{i+1/2}\n    flux_iph = a * u_L_iph\n    \n    # Flux at i-1/2 is the rolled version of flux_iph\n    flux_imh = np.roll(flux_iph, 1)\n\n    return -(flux_iph - flux_imh) / dx\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2450605"}]}