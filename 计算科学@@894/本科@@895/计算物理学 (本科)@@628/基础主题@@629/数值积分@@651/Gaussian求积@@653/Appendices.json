{"hands_on_practices": [{"introduction": "高斯求积公式，例如高斯-勒让德求积，通常是在一个标准化的区间 $[-1, 1]$ 上定义的。因此，在实际应用中，一个至关重要的预备步骤是将任意区间 $[a, b]$ 上的积分变换到这个标准形式。本练习将引导你完成这个基本的变量替换，这是应用任何标准求积法则前都必须掌握的技能。[@problem_id:2175481]", "problem": "在数值分析中，许多用于近似计算定积分的标准算法，例如高斯-勒让德求积法，都是在标准区间（通常是 $[-1, 1]$）上定义的。\n\n要将这些算法应用于任意区间 $[a, b]$ 上的积分，首先需要进行线性变量替换，以将积分映射到标准形式。\n\n考虑定积分 $I = \\int_{0}^{2} \\sin(t) \\, dt$。我们需要使用一种方法对此积分进行数值计算，该方法要求积分的形式为 $I = \\int_{-1}^{1} g(x) \\, dx$。\n\n确定经过此变换所得到的函数 $g(x)$ 的解析表达式。", "solution": "我们需要使用线性变量替换，将积分从区间 $[0,2]$ 变换到区间 $[-1,1]$。对于一个一般的积分 $I=\\int_{a}^{b} f(t)\\,dt$，从 $x\\in[-1,1]$ 到 $t\\in[a,b]$ 的标准线性映射为\n$$\nt=\\frac{b-a}{2}\\,x+\\frac{a+b}{2},\n$$\n这意味着\n$$\ndt=\\frac{b-a}{2}\\,dx.\n$$\n根据变量替换定理，\n$$\nI=\\int_{a}^{b} f(t)\\,dt=\\int_{-1}^{1} f\\!\\left(\\frac{b-a}{2}\\,x+\\frac{a+b}{2}\\right)\\,\\frac{b-a}{2}\\,dx.\n$$\n因此，若要将积分写成 $I=\\int_{-1}^{1} g(x)\\,dx$ 的形式，我们可以确定\n$$\ng(x)=\\frac{b-a}{2}\\,f\\!\\left(\\frac{b-a}{2}\\,x+\\frac{a+b}{2}\\right).\n$$\n\n对于本问题，$a=0$, $b=2$ 且 $f(t)=\\sin(t)$。因此，\n$$\n\\frac{b-a}{2}=1,\\qquad \\frac{a+b}{2}=1,\n$$\n所以\n$$\ng(x)=1\\cdot \\sin\\!\\left(1\\cdot x+1\\right)=\\sin(x+1).\n$$\n这就得到了所需的形式 $I=\\int_{-1}^{1} \\sin(x+1)\\,dx$。", "answer": "$$\\boxed{\\sin(x+1)}$$", "id": "2175481"}, {"introduction": "将积分区间标准化之后，我们就可以应用高斯求积法则了。本练习将具体展示一个两点高斯-勒让德求积的应用，并突出其最强大的特性之一：对特定次数内的多项式能够进行精确积分。通过这个实践，你将巩固对高斯求积法为何如此高效的理解。[@problem_id:2665798]", "problem": "在一维固体力学中，考虑一个用于有限元法 (FEM) 的两节点等参杆单元。令母坐标表示为 $\\xi \\in [-1,1]$。假设与某一虚拟变形模式相关的单位雅可比的无量纲内能密度由二次函数 $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$ 给出。该模式对无量纲内虚功的单元贡献为积分\n$$\nI = \\int_{-1}^{1} u(\\xi)\\, \\mathrm{d}\\xi.\n$$\n使用在 $[-1,1]$ 上、节点为 $\\xi = \\pm 1/\\sqrt{3}$、权重为 $w = 1$ 的两点高斯-勒让德求积法则，通过求积法计算 $I$。然后，通过直接根据黎曼积分的定义计算积分的解析值来验证求积的精确性。将 $I$ 的值报告为一个纯数（无量纲）。由于结果是精确的，因此无需四舍五入。", "solution": "问题要求计算函数 $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$ 的积分 $I = \\int_{-1}^{1} u(\\xi)\\, \\mathrm{d}\\xi$。必须使用两种方法进行计算以作比较：两点高斯-勒让德求积法和直接解析积分法。\n\n首先，我们应用两点高斯-勒让德求积法则。在区间 $[-1,1]$ 上，该求积法的一般形式为：\n$$\n\\int_{-1}^{1} f(\\xi)\\, \\mathrm{d}\\xi \\approx \\sum_{i=1}^{n} w_i f(\\xi_i)\n$$\n对于两点法则（$n=2$），节点为 $\\xi_1 = -\\frac{1}{\\sqrt{3}}$ 和 $\\xi_2 = \\frac{1}{\\sqrt{3}}$，相应的权重为 $w_1 = 1$ 和 $w_2 = 1$。被积函数为 $f(\\xi) = u(\\xi) = 3\\xi^{2} + 2\\xi + 1$。\n\n我们在每个求积节点上计算函数 $u(\\xi)$ 的值：\n在 $\\xi_1 = -\\frac{1}{\\sqrt{3}}$ 处：\n$$\nu\\left(-\\frac{1}{\\sqrt{3}}\\right) = 3\\left(-\\frac{1}{\\sqrt{3}}\\right)^{2} + 2\\left(-\\frac{1}{\\sqrt{3}}\\right) + 1 = 3\\left(\\frac{1}{3}\\right) - \\frac{2}{\\sqrt{3}} + 1 = 1 - \\frac{2}{\\sqrt{3}} + 1 = 2 - \\frac{2}{\\sqrt{3}}\n$$\n在 $\\xi_2 = \\frac{1}{\\sqrt{3}}$ 处：\n$$\nu\\left(\\frac{1}{\\sqrt{3}}\\right) = 3\\left(\\frac{1}{\\sqrt{3}}\\right)^{2} + 2\\left(\\frac{1}{\\sqrt{3}}\\right) + 1 = 3\\left(\\frac{1}{3}\\right) + \\frac{2}{\\sqrt{3}} + 1 = 1 + \\frac{2}{\\sqrt{3}} + 1 = 2 + \\frac{2}{\\sqrt{3}}\n$$\n现在，我们计算积分的近似值，记为 $I_{GQ}$：\n$$\nI_{GQ} = w_1 u(\\xi_1) + w_2 u(\\xi_2) = (1) \\left(2 - \\frac{2}{\\sqrt{3}}\\right) + (1) \\left(2 + \\frac{2}{\\sqrt{3}}\\right)\n$$\n$$\nI_{GQ} = 2 - \\frac{2}{\\sqrt{3}} + 2 + \\frac{2}{\\sqrt{3}} = 4\n$$\n使用两点高斯求积法得到的积分值为 $4$。\n\n接下来，我们通过使用微积分基本定理以解析方式计算积分的精确值来进行验证。\n$$\nI = \\int_{-1}^{1} (3\\xi^{2} + 2\\xi + 1)\\, \\mathrm{d}\\xi\n$$\n被积函数的原函数是：\n$$\n\\int (3\\xi^{2} + 2\\xi + 1)\\, \\mathrm{d}\\xi = 3\\frac{\\xi^{3}}{3} + 2\\frac{\\xi^{2}}{2} + \\xi + C = \\xi^{3} + \\xi^{2} + \\xi + C\n$$\n计算在积分限 $\\xi = -1$ 和 $\\xi = 1$ 之间的定积分：\n$$\nI = \\left[ \\xi^{3} + \\xi^{2} + \\xi \\right]_{-1}^{1} = \\left( (1)^{3} + (1)^{2} + (1) \\right) - \\left( (-1)^{3} + (-1)^{2} + (-1) \\right)\n$$\n$$\nI = (1 + 1 + 1) - (-1 + 1 - 1) = (3) - (-1) = 3 + 1 = 4\n$$\n积分的精确解析值为 $4$。\n\n两点高斯求积法的结果 $I_{GQ} = 4$ 与精确的解析结果 $I = 4$ 相匹配。这是预料之中的。一个具有 $n$ 个点的高斯-勒让德求积法则可以精确地对最高为 $2n-1$ 次的多项式进行积分。在本问题中，$n=2$，因此该法则对于任何最高为 $2(2)-1 = 3$ 次的多项式都必须是精确的。被积函数 $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$ 是一个二次多项式。由于 $2 \\le 3$，求积法得出了精确结果。验证过程证实了这一理论原理。因此，所求的 $I$ 值为 $4$。", "answer": "$$\\boxed{4}$$", "id": "2665798"}, {"introduction": "对于光滑的解析函数，高斯求积展现出惊人的（指数级）收敛速度。但如果被积函数不光滑，情况会如何呢？这个计算练习邀请你研究一个带有“扭结”（一阶导数不连续）的函数的收敛率，探索该方法的性能如何优雅地降级为较慢的代数收敛率。这是一个观察数值方法局限性和行为的绝佳实践。[@problem_id:2397754]", "problem": "考虑函数 $f(x)=\\lvert x-c\\rvert$ 在区间 $[-1,1]$ 上的积分，其中 $c\\in(-1,1)$ 为固定参数。设 $I(c)$ 表示该积分的精确值，设 $Q_n(c)$ 表示在 $[-1,1]$ 上使用勒让德权重的 $n$ 点高斯求积近似值。定义绝对误差为 $E_n(c)=\\lvert Q_n(c)-I(c)\\rvert$。研究 $E_n(c)$ 关于 $n$ 的经验代数收敛率如何依赖于 $c$ 相对于求积节点的位置。\n\n您的程序必须：\n- 根据第一性原理计算精确积分 $I(c)$。\n- 对整数集 $\\{2,3,4,\\dots,80\\}$ 中的每个 $n$，计算 $Q_n(c)$ 和绝对误差 $E_n(c)$。\n- 对于每个固定的 $c$，通过对偶数子序列 $\\{n\\in\\mathbb{N}: n\\in\\{2,4,6,\\dots,80\\}\\}$ 和奇数子序列 $\\{n\\in\\mathbb{N}: n\\in\\{3,5,7,\\dots,79\\}\\}$ 的 $(\\log n,\\log E_n(c))$ 数据分别拟合一条直线，来估计两个经验代数收敛率 $p_{\\mathrm{even}}(c)$ 和 $p_{\\mathrm{odd}}(c)$。使用 $\\log E_n(c)$ 相对于 $\\log n$ 的最小二乘斜率 $\\hat{s}$，并将经验收敛率定义为 $p=-\\hat{s}$。为避免浮点饱和，拟合时应排除任何满足 $E_n(c)\\le 10^{-14}$ 的数据点对 $(n,E_n(c))$；如果剩余的数据点少于 3 个，则使用所有可用数据点进行拟合，不作排除。\n- 在速率估计中，所有对数均使用自然对数。\n\n使用以下参数值测试套件：\n- $c_1=0$，\n- $c_2=0.1$，\n- $c_3=0.5773502691896257$。\n\n对于测试套件中的每个 $c_j$，计算并报告数据对 $\\big(p_{\\mathrm{even}}(c_j),\\,p_{\\mathrm{odd}}(c_j)\\big)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序和格式如下：\n$[p_{\\mathrm{even}}(c_1),p_{\\mathrm{odd}}(c_1),p_{\\mathrm{even}}(c_2),p_{\\mathrm{odd}}(c_2),p_{\\mathrm{even}}(c_3),p_{\\mathrm{odd}}(c_3)]$.\n所有报告的值都必须是实数值（无单位），本任务不涉及角度。最终输出必须为单行，且不得包含任何附加文本。", "solution": "任务是研究 $n$ 点高斯-勒让德求积法在计算函数 $f(x) = \\lvert x-c \\rvert$ 在区间 $[-1, 1]$ 上的积分时的经验代数收敛率。函数 $f(x)$ 是连续的，但其一阶导数 $f'(x) = \\text{sgn}(x-c)$ 在 $x=c$ 处有一个跳跃间断点。众所周知，这种缺乏光滑性的特点会将高阶求积法则的收敛率从（对解析函数而言的）指数级降低到代数级。我们假设误差按 $E_n(c) \\propto n^{-p}$ 的形式缩放，其中 $E_n(c)$ 是 $n$ 点求积法则的绝对误差，$p$ 是代数收敛率。\n\n首先，我们确定积分的精确值，记为 $I(c)$。对于 $c \\in (-1, 1)$，我们在不可微点 $x=c$ 处将积分拆分：\n$$\nI(c) = \\int_{-1}^{1} \\lvert x-c \\rvert \\, dx = \\int_{-1}^{c} -(x-c) \\, dx + \\int_{c}^{1} (x-c) \\, dx\n$$\n计算这些初等积分可得：\n$$\nI(c) = \\left[ cx - \\frac{x^2}{2} \\right]_{-1}^{c} + \\left[ \\frac{x^2}{2} - cx \\right]_{c}^{1}\n$$\n$$\nI(c) = \\left( (c^2 - \\frac{c^2}{2}) - (-c - \\frac{1}{2}) \\right) + \\left( (\\frac{1}{2} - c) - (\\frac{c^2}{2} - c^2) \\right)\n$$\n$$\nI(c) = \\left( \\frac{c^2}{2} + c + \\frac{1}{2} \\right) + \\left( \\frac{1}{2} - c + \\frac{c^2}{2} \\right) = c^2 + 1\n$$\n这个解析结果 $I(c) = c^2+1$ 是用于与数值近似值进行比较的基准。\n\n该积分的 $n$ 点高斯-勒让德求积近似值 $Q_n(c)$ 由以下求和公式给出：\n$$\nQ_n(c) = \\sum_{i=1}^{n} w_i f(x_i) = \\sum_{i=1}^{n} w_i \\lvert x_i - c \\rvert\n$$\n其中 $\\{x_i\\}_{i=1}^n$ 是 $n$ 阶勒让德多项式 $P_n(x)$ 的根，$\\{w_i\\}_{i=1}^n$ 是相应的求积权重。于是，绝对误差为 $E_n(c) = \\lvert Q_n(c) - I(c) \\rvert$。\n\n对于具有此类奇点（一阶导数存在跳跃）的函数，理论分析表明其渐近收敛率为 $E_n(c) = O(n^{-2})$，因此我们预计会发现 $p \\approx 2$。然而，题目要求的是一个经验收敛率，我们必须根据数值数据进行计算。分析需要对偶数和奇数的 $n$ 分别进行。这一区分非常重要，因为高斯-勒让德求积的节点分布在 $n$ 为偶数和奇数时具有不同的对称性。具体来说，当 $n$ 为奇数时，$x=0$ 总是一个节点，这对于 $c=0$ 的情况尤为关键。\n\n为了估计收敛率 $p$，我们假设模型为 $E_n(c) = A n^{-p}$，其中 $A$ 为某个常数。对该关系式取自然对数，得到一个线性方程：\n$$\n\\ln(E_n(c)) = \\ln(A) - p \\ln(n)\n$$\n该方程的形式为 $y = b + sx$，其中 $y = \\ln(E_n(c))$，$x = \\ln(n)$，截距为 $b = \\ln(A)$，斜率为 $s = -p$。题目要求我们使用最小二乘法为数据点 $(\\ln(n), \\ln(E_n(c)))$ 找到最佳拟合线的斜率 $s$。然后，经验收敛率由 $p = -s$ 给出。\n\n计算流程如下：\n1. 对于测试套件中的每个 $c$ 值 $\\{0, 0.1, 0.5773502691896257\\}$，我们计算精确积分 $I(c) = c^2+1$。\n2. 我们遍历 $n \\in \\{2, 3, \\ldots, 80\\}$。在每次迭代中，我们计算 $n$ 个高斯-勒让德节点和权重，计算求积近似值 $Q_n(c)$，并求出误差 $E_n(c)$。\n3. 收集数据对 $(n, E_n(c))$，并根据 $n$ 的奇偶性将其分为两个子序列。\n4. 对每个子序列（偶数和奇数），我们对对数转换后的数据 $(\\ln(n), \\ln(E_n(c)))$ 执行线性回归。应用特定的数据筛选规则：拟合时排除任何满足 $E_n(c) \\le 10^{-14}$ 的数据点，除非这样做会使得剩余数据点少于 3 个，在这种情况下，则使用所有数据点。\n5. 得到线性拟合的斜率 $s$。收敛率则为 $p_{\\mathrm{even}}(c) = -s_{\\mathrm{even}}$ 和 $p_{\\mathrm{odd}}(c) = -s_{\\mathrm{odd}}$。\n6. 按照指定格式报告最终得到的六个值 $(p_{\\mathrm{even}}(c_1), p_{\\mathrm{odd}}(c_1), \\ldots)$。\n\n以下程序实现了这整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_rate(n_values, E_values, min_points=3, threshold=1e-14):\n    \"\"\"\n    Estimates the algebraic convergence rate p from E ~ n^(-p).\n\n    This is done by a linear least-squares fit on log-log data.\n    The rate p is the negative of the slope of log(E) vs log(n).\n    \n    Args:\n        n_values (np.ndarray): Array of integer orders n.\n        E_values (np.ndarray): Array of corresponding errors E_n.\n        min_points (int): The minimum number of points required for a filtered fit.\n        threshold (float): The error threshold for filtering.\n    \n    Returns:\n        float: The estimated convergence rate p.\n    \"\"\"\n    # Ensure there are enough points to attempt a fit\n    if len(n_values) < 2:\n        return np.nan\n\n    # Filter out points where the error is at or below the floating-point precision limit.\n    # This prevents these points from corrupting the log-log fit.\n    mask = E_values > threshold\n    \n    if np.sum(mask) < min_points:\n        # If filtering leaves too few points, use all available points as per the rule.\n        x_fit = np.log(n_values)\n        y_fit = np.log(E_values)\n    else:\n        # Use the filtered data for the fit.\n        x_fit = np.log(n_values[mask])\n        y_fit = np.log(E_values[mask])\n\n    # Check again if there are enough points for polyfit after filtering.\n    if len(x_fit) < 2:\n        return np.nan\n\n    # Perform a linear fit (degree 1 polynomial) to the log-log data.\n    # The slope is the first element of the returned coefficients.\n    slope = np.polyfit(x_fit, y_fit, 1)[0]\n    \n    # The convergence rate p is the negative of the slope.\n    return -slope\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as stated.\n    - Computes exact and approximate integrals.\n    - Calculates errors for n-point Gaussian quadrature.\n    - Estimates convergence rates for even and odd n subsequences.\n    \"\"\"\n    # Test suite of parameter values for c.\n    test_cases = [\n        0.0,\n        0.1,\n        0.5773502691896257,  # This is 1/sqrt(3)\n    ]\n\n    # The range of n for the quadrature rule.\n    n_range = np.arange(2, 81)\n    \n    all_results = []\n    \n    for c in test_cases:\n        # Compute the exact integral I(c) = c^2 + 1.\n        I_c = c**2 + 1.0\n        \n        # Lists to store n and the corresponding errors for even and odd subsequences.\n        n_even, E_even = [], []\n        n_odd, E_odd = [], []\n        \n        # Compute errors for each n in the specified range.\n        for n in n_range:\n            # Get the n-point Gauss-Legendre quadrature nodes and weights.\n            nodes, weights = np.polynomial.legendre.leggauss(n)\n            \n            # Compute the quadrature approximation Q_n(c) for f(x) = |x-c|.\n            Q_n = np.sum(weights * np.abs(nodes - c))\n            \n            # Compute the absolute error.\n            E_n = np.abs(Q_n - I_c)\n            \n            # Separate the results into even and odd subsequences.\n            if n % 2 == 0:\n                n_even.append(n)\n                E_even.append(E_n)\n            else:\n                n_odd.append(n)\n                E_odd.append(E_n)\n        \n        # Estimate the convergence rates for both subsequences.\n        p_even = estimate_rate(np.array(n_even), np.array(E_even))\n        p_odd = estimate_rate(np.array(n_odd), np.array(E_odd))\n        \n        all_results.extend([p_even, p_odd])\n\n    # Print the final results in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "2397754"}]}