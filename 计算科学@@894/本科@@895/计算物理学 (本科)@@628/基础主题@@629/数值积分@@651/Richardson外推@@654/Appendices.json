{"hands_on_practices": [{"introduction": "第一个练习将理查森外推法直接应用于一个熟悉的场景。在许多计算模拟中，仅仅通过减小步长 $h$ 来获得高精度结果，其计算成本可能非常高。这个问题将演示如何巧妙地结合两次不同步长（$h_1$ 和 $h_2$）的模拟结果，从而得到一个更精确的真实值估计，特别是针对一个具有一阶误差 $O(h)$ 的数值方法 [@problem_id:2197893]。", "problem": "一个航空航天工程师团队正在开发一个计算机模拟程序，以预测一个探测器在新发现的系外行星上的最终着陆速度。该模拟采用一种数值积分算法来求解运动方程。已知所使用的主要数值方法的全局截断误差为一阶，通常表示为 $O(h)$，其中 $h$ 是模拟的时间步长。\n\n该团队使用不同的时间步长进行了两次模拟运行，以评估其结果的收敛性。\n1.  当时间步长为 $h_1 = 0.20$ 秒时，模拟预测的最终着陆速度为 $V(h_1) = 15.60$ m/s。\n2.  当时间步长减小到 $h_2 = 0.10$ 秒时，模拟得出了一个更精确的着陆速度 $V(h_2) = 15.85$ m/s。\n\n为了在不增加额外计算开销（即使用更小时间步长再次运行模拟）的情况下获得更准确的预测，该团队决定使用Richardson外推法。对两个已有的速度估计值应用Richardson外推法，以计算真实着陆速度的改进估计值。\n\n将您得到的改进速度最终答案以 m/s 为单位表示，并四舍五入到四位有效数字。", "solution": "设真实着陆速度为 $V$，时间步长为 $h$ 时的数值估计值为 $V(h)$。对于一个一阶方法，其全局截断误差模型为\n$$\nV(h) = V + C h + O(h^{2}),\n$$\n其中 $C$ 是一个与 $h$ 无关的常数。对于两个步长 $h_{1}$ 和 $h_{2}$，我们有\n$$\nV(h_{1}) = V + C h_{1} + O(h_{1}^{2}), \\quad V(h_{2}) = V + C h_{2} + O(h_{2}^{2}).\n$$\n忽略 $O(h^{2})$ 项并消去 $C$ 可得\n$$\nC \\approx \\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}}, \\quad V \\approx V(h_{2}) - C h_{2}.\n$$\n代入 $C$ 即可得到一阶方法的Richardson外推公式：\n$$\nV \\approx V(h_{2}) - h_{2}\\,\\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}} = V(h_{2}) + \\frac{V(h_{2}) - V(h_{1})}{\\frac{h_{1}}{h_{2}} - 1}.\n$$\n当 $h_{1} = 0.20$，$h_{2} = 0.10$，$V(h_{1}) = 15.60$ 且 $V(h_{2}) = 15.85$ 时，步长比为 $r = \\frac{h_{1}}{h_{2}} = 2$，因此\n$$\nV \\approx 15.85 + \\frac{15.85 - 15.60}{2 - 1} = 15.85 + 0.25 = 16.10.\n$$\n四舍五入到四位有效数字，真实着陆速度的改进估计值为 $16.10$。", "answer": "$$\\boxed{16.10}$$", "id": "2197893"}, {"introduction": "这个练习将挑战你的逆向思维，加深你对理查森外推法背后理论的理解。外推公式中的特定系数并非随意设定，它们由需要消除的误差项的阶数精确决定。通过分析一个给定的外推公式，你将需要推导出原始数值方法主导误差项 $O(h^p)$ 的阶数 $p$，从而加深你对误差消除机制如何工作的理解 [@problem_id:2197927]。", "problem": "在一个数值分析任务中，函数 $A(h)$ 提供了一个未知精确值 $L$ 的近似值。该近似依赖于一个小的正步长 $h$。已知该近似的误差遵循以下渐近关系：\n$$L = A(h) + C h^{p} + O(h^{q})$$\n其中 $C$ 是一个非零常数，$p$ 是一个表示主误差项阶数的正整数，而 $q$ 是另一个满足 $q > p$ 的整数。\n\n为了获得 $L$ 的一个更精确的估计，使用步长为 $h$ 和 $h/2$ 时的近似值执行单步 Richardson 外推。所得到的外推值记作 $R(h)$，使用以下特定公式计算：\n$$R(h) = \\frac{4A(h/2) - A(h)}{3}$$\n当 $h \\to 0$ 时，新的近似 $R(h)$ 比 $A(h)$ 更快地收敛到 $L$。通过分析该外推公式的结构，确定 $p$ 的整数值。", "solution": "我们从给定的渐近展开式开始\n$$L = A(h) + C h^{p} + O(h^{q}),$$\n其中 $C \\neq 0$，$p \\in \\mathbb{Z}_{>0}$，且 $q > p$。重新整理可得\n$$A(h) = L - C h^{p} + O(h^{q}).$$\n将 $h$ 替换为 $h/2$ 可得\n$$A(h/2) = L - C \\left(\\frac{h}{2}\\right)^{p} + O\\left(\\left(\\frac{h}{2}\\right)^{q}\\right) = L - C 2^{-p} h^{p} + O(h^{q}),$$\n因为 $O\\left((h/2)^{q}\\right) = O(h^{q})$。\n\n所提供的 Richardson 外推公式为\n$$R(h) = \\frac{4 A(h/2) - A(h)}{3}.$$\n代入 $A(h/2)$ 和 $A(h)$ 的展开式：\n$$R(h) = \\frac{4\\left(L - C 2^{-p} h^{p} + O(h^{q})\\right) - \\left(L - C h^{p} + O(h^{q})\\right)}{3}.$$\n化简分子：\n$$4L - 4 C 2^{-p} h^{p} + O(h^{q}) - L + C h^{p} - O(h^{q}) = 3L + h^{p}\\left(C - 4 C 2^{-p}\\right) + O(h^{q}).$$\n因此，\n$$R(h) = L + \\frac{h^{p}}{3} C \\left(1 - 4 \\cdot 2^{-p}\\right) + O(h^{q}).$$\n\n为使 $R(h)$ 比 $A(h)$ 收敛得更快，主误差项 $h^{p}$ 的系数必须为零，这要求\n$$1 - 4 \\cdot 2^{-p} = 0 \\quad \\Longrightarrow \\quad 4 = 2^{p} \\quad \\Longrightarrow \\quad p = 2.$$\n因此，给定外推公式的结构意味着主误差阶为 $p=2$。", "answer": "$$\\boxed{2}$$", "id": "2197927"}, {"introduction": "最后一个练习是一个综合性项目，旨在连接理论与计算物理中的实际应用。你将需要实现Verlet算法来模拟非线性摆的运动，这是一个经典的物理问题。你的任务是从模拟数据中提取一个关键的物理量——振荡周期，并对这些数值结果应用理查森外推法。这将使你能够获得一个精度显著更高的周期估计，从而展示该技术在真实科学计算工作流程中的强大威力 [@problem_id:2435010]。", "problem": "要求您设计并实现一个程序，该程序使用理查森外推法（Richardson extrapolation）来提高非线性摆振荡周期的数值估计精度，其中摆的运动通过Verlet算法进行模拟。请完全在国际单位制（SI单位）下工作。角度必须以弧度为单位，时间以秒为单位，长度以米为单位，加速度以米/秒²为单位。您的程序必须按末尾所述，产生单行输出。\n\n物理模型是长度为$L$、重力加速度为$g$的平面、无阻尼、非线性摆，其角位移$\\theta(t)$随常微分方程（ODE）演化：\n$$\n\\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\,\\sin\\!\\big(\\theta(t)\\big) = 0.\n$$\n假设初始条件为$\\theta(0) = \\theta_0$和$\\frac{d\\theta}{dt}(0) = 0$。\n\n使用速度Verlet算法（一种二阶辛方法）模拟运动，将状态变量$\\theta$和$\\omega = d\\theta/dt$以及加速度$a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$进行处理。在一个足够长的时间窗口内，以固定的时间步长$\\Delta t$演化系统，以确定振荡周期$T(\\Delta t)$。通过检测$\\theta$的两个同向（例如，两次都从正到负）的连续过零点来估计周期，并计算这两个过零点之间的时间差。使用离散时间样本之间的线性插值来估计每个过零点的时间。用更精细的时间步长$\\Delta t/2$重复模拟，以获得$T(\\Delta t/2)$。\n\n假设从速度Verlet轨迹中提取的任何平滑标量的主要阶全局离散误差与$\\mathcal{O}(\\Delta t^2)$同阶。利用这一假设，应用理查森外推法将$T(\\Delta t)$和$T(\\Delta t/2)$组合成一个改进的真实周期$T$的估计值$\\widehat{T}$，通过消除主误差项。\n\n为以下测试套件的参数集实现上述过程，这些参数集旨在探测多个区域：\n- 情况1（理想情况，中等振幅）：$L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 0.5\\,\\text{rad}$，$\\Delta t = 0.05\\,\\text{s}$。\n- 情况2（更大振幅，更强非线性）：$L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 1.2\\,\\text{rad}$，$\\Delta t = 0.05\\,\\text{s}$。\n- 情况3（近分离线边缘情况，极大振幅）：$L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 2.9\\,\\text{rad}$，$\\Delta t = 0.02\\,\\text{s}$。\n\n您的程序必须：\n- 对于每种情况，使用$\\Delta t$和$\\Delta t/2$进行模拟，从同向过零点估计$T(\\Delta t)$和$T(\\Delta t/2)$，然后计算理查森外推周期估计值$\\widehat{T}$。\n- 将每个最终周期估计值$\\widehat{T}$以秒表示，并四舍五入到$6$位小数。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含三个外推周期估计值，格式为由方括号括起来的逗号分隔列表，顺序与上述情况一致，例如$[\\widehat{T}_1,\\widehat{T}_2,\\widehat{T}_3]$。确保每个$\\widehat{T}_k$都四舍五入到$6$位小数。", "solution": "在尝试任何解决方案之前，问题陈述都经过了严格的验证。\n\n**步骤1：提取已知条件**\n\n-   **控制方程**: $\\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\,\\sin(\\theta(t)) = 0$。\n-   **初始条件**: $\\theta(0) = \\theta_0$，$\\frac{d\\theta}{dt}(0) = 0$。\n-   **数值积分器**: 速度Verlet算法。\n-   **状态变量**: $\\theta$（角位移）和 $\\omega = d\\theta/dt$（角速度）。\n-   **加速度函数**: $a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$。\n-   **周期估算方法**: $\\theta(t)$两次同向连续过零点之间的时间间隔，使用线性插值定位。\n-   **误差假设**: 从模拟中导出的量的全局离散误差与$\\mathcal{O}(\\Delta t^2)$同阶。\n-   **改进方法**: 使用时间步长$\\Delta t$和$\\Delta t/2$的结果进行理查森外推法。\n-   **测试用例1**: $L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 0.5\\,\\text{rad}$，$\\Delta t = 0.05\\,\\text{s}$。\n-   **测试用例2**: $L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 1.2\\,\\text{rad}$，$\\Delta t = 0.05\\,\\text{s}$。\n-   **测试用例3**: $L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 2.9\\,\\text{rad}$，$\\Delta t = 0.02\\,\\text{s}$。\n-   **输出格式**: 一个包含三个外推周期估计值的逗号分隔列表$[\\widehat{T}_1, \\widehat{T}_2, \\widehat{T}_3]$，每个值四舍五入到6位小数。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估。\n\n-   **科学基础**: 该问题涉及非线性摆，这是经典力学中的一个典型系统。其控制方程陈述正确。速度Verlet算法是用于此类系统的标准、稳健的辛积分器。理查森外推法是数值分析中的一种基本技术。Verlet方法具有$\\mathcal{O}(\\Delta t^2)$全局误差的假设是正确的。该问题在科学上和数学上是合理的。\n-   **适定性**: 该问题是适定的。具有指定初始条件的常微分方程有唯一解。数值方法、步长以及周期估计的程序都已明确定义。这种结构保证可以计算出唯一且有意义的解。\n-   **客观性**: 该问题以精确、客观的语言陈述。所有参数都已量化，并且所需输出的格式也已明确规定。\n-   **完整性**: 提供了所有必要信息。关于模拟“足够长的时间窗口”的指令是此类问题中的标准指令，意味着模拟必须至少跨越一个完整周期以捕获必要的数据点。这不是模糊不清，而是任务的逻辑必然要求。\n\n**步骤3：结论与行动**\n\n该问题具有科学基础、适定性、客观性和完整性。它是**有效的**。将提供一个解决方案。\n\n任务是计算非线性摆振荡周期的高精度估计值。这需要三个组成部分：动力学的数值模拟、从模拟数据中提取周期的方法，以及用于提高结果精度的外推技术。\n\n物理系统是在加速度为$g$的引力场中长度为$L$的单摆。其运动由角位移$\\theta(t)$描述。控制该运动的二阶非线性常微分方程是：\n$$\n\\frac{d^2 \\theta}{dt^2} = -\\frac{g}{L} \\sin(\\theta(t))\n$$\n我们用角度$\\theta$和角速度$\\omega = \\frac{d\\theta}{dt}$来定义系统的状态。系统从静止开始模拟，因此初始条件为$\\theta(0) = \\theta_0$和$\\omega(0) = 0$。\n\n系统的演化使用速度Verlet算法进行数值计算，这是一种二阶辛方法，非常适用于保守力学系统。给定在时间$t_n = n \\Delta t$时的状态$(\\theta_n, \\omega_n)$，其中$\\Delta t$是时间步长，在时间$t_{n+1}$的状态通过以下步骤找到：\n1.  计算与角度相关的加速度：$a_n = a(\\theta_n) = -\\frac{g}{L} \\sin(\\theta_n)$。\n2.  更新速度半步：$\\omega_{n+1/2} = \\omega_n + a_n \\frac{\\Delta t}{2}$。\n3.  使用此中间速度更新位置一个整步：$\\theta_{n+1} = \\theta_n + \\omega_{n+1/2} \\Delta t$。\n4.  计算新的加速度：$a_{n+1} = a(\\theta_{n+1}) = -\\frac{g}{L} \\sin(\\theta_{n+1})$。\n5.  更新速度第二个半步：$\\omega_{n+1} = \\omega_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2}$。\n\n振荡周期$T$通过追踪角位置$\\theta(t)$来确定。由于摆是从一个正角度$\\theta_0$静止释放的，它的第一次过零点将是朝负方向（向下）的。一个完整周期是两个连续的同向过零点之间经过的时间。我们将找到第一次向下过零和第二次向下过零的时刻。如果一个过零点发生在时间$t_{n-1}$和$t_n$之间，其中$\\theta_{n-1} > 0$且$\\theta_n \\leq 0$，我们使用线性插值来找到一个更精确的过零时间估计值$t_{cross}$：\n$$\nt_{cross} = t_{n-1} - \\theta_{n-1} \\frac{\\Delta t}{\\theta_n - \\theta_{n-1}}\n$$\n设前两次此类过零点的时刻为$t_{cross,1}$和$t_{cross,2}$。那么，对于给定的时间步长$\\Delta t$，周期的数值估计值为$T(\\Delta t) = t_{cross,2} - t_{cross,1}$。\n\n速度Verlet算法的全局误差为二阶。这意味着数值计算出的周期$T(\\Delta t)$与真实周期$T_{true}$的关系如下：\n$$\nT(\\Delta t) = T_{true} + C (\\Delta t)^2 + \\mathcal{O}(\\Delta t^4)\n$$\n其中$C$是一个与$\\Delta t$无关的常数。我们进行两次模拟：一次使用步长$\\Delta t$得到$T(\\Delta t)$，另一次使用步长$\\Delta t/2$得到$T(\\Delta t/2)$。我们有：\n$$\nT(\\Delta t/2) = T_{true} + C \\left(\\frac{\\Delta t}{2}\\right)^2 + \\mathcal{O}(\\Delta t^4) = T_{true} + \\frac{1}{4} C (\\Delta t)^2 + \\mathcal{O}(\\Delta t^4)\n$$\n我们可以通过构造这两个方程的线性组合来消除主阶$\\mathcal{O}(\\Delta t^2)$误差项。将第二个方程乘以$4$并减去第一个方程，得到：\n$$\n4T(\\Delta t/2) - T(\\Delta t) = (4T_{true} - T_{true}) + (C(\\Delta t)^2 - C(\\Delta t)^2) + \\mathcal{O}(\\Delta t^4) = 3T_{true} + \\mathcal{O}(\\Delta t^4)\n$$\n解出$T_{true}$，得到理查森外推估计值$\\widehat{T}$，其精度为$\\mathcal{O}(\\Delta t^4)$：\n$$\n\\widehat{T} = \\frac{4T(\\Delta t/2) - T(\\Delta t)}{3}\n$$\n此过程应用于每个测试用例，以获得最终的、改进的周期估计值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_period_from_simulation(L, g, theta0, dt):\n    \"\"\"\n    Simulates the nonlinear pendulum using the velocity Verlet algorithm and\n    calculates the oscillation period.\n\n    The period is determined by finding the time between two successive\n    downward zero-crossings of the angle theta, using linear interpolation\n    for precision.\n\n    Args:\n        L (float): Length of the pendulum in meters.\n        g (float): Gravitational acceleration in m/s^2.\n        theta0 (float): Initial angular displacement in radians.\n        dt (float): Time step for the simulation in seconds.\n\n    Returns:\n        float: The estimated period of oscillation in seconds.\n               Returns None if the period cannot be determined.\n    \"\"\"\n    theta = theta0\n    omega = 0.0\n    t = 0.0\n    \n    # Pre-calculate constant for acceleration\n    g_over_L = g / L\n\n    # Store previous state to detect crossing\n    theta_prev = theta\n\n    # Store times of downward zero crossings (theta from positive to negative)\n    crossing_times = []\n\n    # Estimate a safe maximum simulation time. The period increases with amplitude.\n    # The small angle period is 2*pi*sqrt(L/g). The true period is always longer.\n    # For theta0 near pi, the period can be very long.\n    # We simulate for at least 1.5 times a generous estimate of the period.\n    # Using an elliptic integral-based estimate for safety.\n    approx_period = 2.0 * np.pi * np.sqrt(L / g) * (1 + theta0**2 / 16.0)\n    if theta0 > 2.8: # Near separatrix, period grows rapidly\n        max_t = 10.0\n    else:\n        max_t = approx_period * 2.0\n    \n    # Simulation loop\n    num_steps = int(max_t / dt)\n    for _ in range(num_steps):\n        # Velocity Verlet integration step\n        accel_prev = -g_over_L * np.sin(theta)\n        omega_half = omega + 0.5 * accel_prev * dt\n        theta_next = theta + omega_half * dt\n        accel_next = -g_over_L * np.sin(theta_next)\n        omega_next = omega_half + 0.5 * accel_next * dt\n        \n        t += dt\n        theta_prev = theta\n        theta = theta_next\n        omega = omega_next\n\n        # Detect downward zero-crossing: theta from positive to non-positive\n        if theta_prev > 0 and theta = 0:\n            # Linear interpolation to find the precise crossing time t_cross\n            # Point 1: (t-dt, theta_prev), Point 2: (t, theta)\n            # Equation of line: T(th) = (t-dt) + (th - theta_prev) * dt / (theta - theta_prev)\n            # Find T at th=0:\n            t_cross = (t - dt) - theta_prev * dt / (theta - theta_prev)\n            crossing_times.append(t_cross)\n            \n            # If two downward crossings are found, calculate period and exit\n            if len(crossing_times) >= 2:\n                return crossing_times[1] - crossing_times[0]\n                \n    # This part should not be reached if max_t is sufficient\n    return None\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the Richardson-extrapolated period for each case and\n    prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # (L, g, theta0, dt)\n        (1.0, 9.81, 0.5, 0.05),\n        (1.0, 9.81, 1.2, 0.05),\n        (1.0, 9.81, 2.9, 0.02),\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        L, g, theta0, dt = case\n        \n        # Calculate period with coarse time step dt\n        T_coarse = get_period_from_simulation(L, g, theta0, dt)\n        \n        # Calculate period with fine time step dt/2\n        T_fine = get_period_from_simulation(L, g, theta0, dt / 2.0)\n        \n        if T_coarse is None or T_fine is None:\n            raise ValueError(f\"Failed to determine period for case {i+1}\")\n\n        # Apply Richardson extrapolation for a method with O(h^2) error\n        # T_extrapolated = (4 * T_fine - T_coarse) / 3\n        T_extrapolated = (4.0 * T_fine - T_coarse) / 3.0\n        \n        # Format the result to 6 decimal places\n        results.append(f\"{T_extrapolated:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2435010"}]}