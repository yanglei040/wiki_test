{"hands_on_practices": [{"introduction": "理论物理中的许多模型都始于理想化的假设，例如无限细的导线。然而，在现实世界的工程应用中，物理组件具有有限的尺寸。这个练习将带你从理想模型走向更真实的物理情景，通过对亥姆霍兹线圈的有限截面进行积分，来精确计算其中心磁场。这不仅是一个具体的计算任务，更是一个让你体会如何运用数值积分处理复杂几何形状下物理定律的绝佳机会。[@problem_id:2414964]", "problem": "一对相同的同轴圆形线圈（亥姆霍兹线圈）在系统的几何中心产生一个磁场。每个线圈都以共同的对称轴（$z$轴）为中心，分别位于 $z=\\pm R/2$ 的位置，其中 $R$ 是每个线圈的平均半径。每个线圈由 $N$ 匝紧密缠绕的导线组成，载有沿相同方位角方向的稳恒电流 $I$。线圈匝数均匀分布在一个以半径为 $R$ 的圆为中心的有限矩形截面上，该截面的径向半宽为 $w_r \\ge 0$，轴向半高为 $w_z \\ge 0$。在每个线圈的局部柱坐标系中，该矩形截面在径向上的范围为 $\\rho \\in [R-w_r,\\, R+w_r]$，在相对于线圈中心平面的轴向上的范围为 $\\zeta \\in [-w_z,\\, w_z]$。假设电流密度对应于整个截面上均匀的匝数密度。磁场将在原点 $\\mathbf{r}=\\mathbf{0}$ 处进行计算。\n\n设 $\\mu_0$ 为磁常数（真空磁导率）。对于一个半径为 $\\rho$、载有电流 $I$ 的薄圆环，在距离其所在平面轴向距离为 $z$ 的对称轴上，磁场的大小为\n$$\nB_{\\text{loop}}(\\rho,z) \\;=\\; \\frac{\\mu_0\\, I\\, \\rho^2}{2\\left(\\rho^2+z^2\\right)^{3/2}}.\n$$\n对于具有有限矩形截面的线圈，将其建模为匝数密度为 $n_A$（单位：匝/单位面积）的无穷小匝在矩形上均匀分布的连续体。单个线圈的总匝数为 $N$。若 $w_r>0$ 且 $w_z>0$，则 $n_A = \\dfrac{N}{(2w_r)(2w_z)}$。若 $w_r=0$ 且 $w_z=0$，则将线圈解释为一个位于线圈中心平面、半径为 $R$、匝数为 $N$ 的薄圆环。\n\n定义原点处由两个线圈产生的总磁场大小为 $B(0)$，它是位于 $z=+R/2$ 和 $z=-R/2$ 的两个相同线圈的轴向分量贡献之和。所有距离以米为单位，电流以安培为单位，磁场以特斯拉为单位。\n\n您的任务是编写一个完整的、可运行的程序，为以下测试套件中的每个参数集计算 $B(0)$。如果 $w_r=0$ 且 $w_z=0$，则将线圈视为一个有 $N$ 匝的薄圆环。在下面提供的所有其他情况中，$w_r>0$ 且 $w_z>0$。使用 $\\mu_0 = 4\\pi\\times 10^{-7}\\,\\text{N}\\,\\text{A}^{-2}$。\n\n测试套件（每个元组为 $(N, I, R, w_r, w_z)$）：\n- 案例1（边界情况，薄线圈）：$(200,\\;1.5,\\;0.25,\\;0.0,\\;0.0)$\n- 案例2（有限截面，小厚度）：$(200,\\;1.5,\\;0.25,\\;0.01,\\;0.01)$\n- 案例3（有限截面，较厚）：$(100,\\;2.0,\\;0.30,\\;0.03,\\;0.02)$\n\n您的程序必须生成单行输出，其中包含三个结果 $[B_1,B_2,B_3]$（单位为特斯拉），$B_k$ 是案例 $k$ 的 $B(0)$ 的值。每个 $B_k$ 必须以十进制浮点数的形式打印（单位为特斯拉），并四舍五入到10位有效数字。本问题不涉及角度。最终输出格式必须是严格的单行，包含一个用方括号括起来的逗号分隔列表，例如：$[0.001234567,0.001111111,0.0009876543]$（此处的值仅为示例）。", "solution": "问题陈述已经过严格评估，并被确定为 **有效**。它构成了一个计算物理学领域，特别是静磁学领域中的适定问题。该问题具有科学依据，内部一致，并为计算唯一解提供了所有必要信息。任务是通过对载流细丝连续分布的贡献进行积分，计算亥姆霍兹线圈系统中心的磁场，其中线圈具有有限的矩形截面。\n\n控制该问题的基本原理是 Biot-Savart 定律。半径为 $\\rho$、载有电流 $I_{\\text{loop}}$ 的单个圆形回路，在其轴线上距离回路平面轴向距离为 $z'$ 处的磁场由下式给出：\n$$\nB_{\\text{loop}}(\\rho, z') = \\frac{\\mu_0 I_{\\text{loop}} \\rho^2}{2\\left(\\rho^2 + (z')^2\\right)^{3/2}}\n$$\n场方向沿对称轴。对于指定的亥姆霍兹线圈配置，两个线圈都在原点产生轴向磁场，并且这些贡献相长叠加。\n\n为了考虑线圈的有限截面，每个线圈被建模为无穷小电流环的连续体。线圈共有 $N$ 匝，载有电流 $I$。对于由径向半宽 $w_r > 0$ 和轴向半高 $w_z > 0$ 定义的非零截面，其截面积为 $A = (2w_r)(2w_z) = 4w_r w_z$。线圈匝数是均匀分布的，匝数密度为 $n_A = N/A = N/(4w_r w_z)$ 匝/单位面积。\n\n在半径为 $\\rho$、轴向位置为 $z'$ 处的截面内的一个无穷小面积元 $d\\rho dz'$，对应一个包含 $n_A d\\rho dz'$ 匝的无穷小回路。该回路承载的等效电流为 $dI_{\\text{loop}} = I \\cdot (n_A d\\rho dz')$。此元件在原点产生的磁场微分 $dB_z$ 为：\n$$\ndB_z(\\rho, z') = \\frac{\\mu_0 (I n_A d\\rho dz') \\rho^2}{2\\left(\\rho^2 + (z')^2\\right)^{3/2}} = \\frac{\\mu_0 I N}{8 w_r w_z} \\frac{\\rho^2}{\\left(\\rho^2 + (z')^2\\right)^{3/2}} d\\rho dz'\n$$\n来自单个线圈的总磁场可以通过对其截面积分此表达式得到。第一个线圈的中心位于 $z_c = +R/2$，因此其截面范围为 $\\rho \\in [R-w_r, R+w_r]$ 和 $z' \\in [R/2-w_z, R/2+w_z]$。其贡献 $B_1$ 为：\n$$\nB_1 = \\frac{\\mu_0 I N}{8 w_r w_z} \\int_{R-w_r}^{R+w_r} \\int_{R/2-w_z}^{R/2+w_z} \\frac{\\rho^2}{\\left(\\rho^2 + (z')^2\\right)^{3/2}} dz' d\\rho\n$$\n第二个线圈的中心位于 $z_c = -R/2$，其截面范围为 $z' \\in [-R/2-w_z, -R/2+w_z]$。其贡献为 $B_2$。由于被积函数是关于 $z'$ 的偶函数，通过简单的变量替换可以表明，对第二个线圈的积分与第一个相同。因此，$B_2 = B_1$。\n\n原点处的总磁场是两个线圈贡献之和：\n$$\nB(0) = B_1 + B_2 = 2 B_1 = \\frac{\\mu_0 I N}{4 w_r w_z} \\int_{R-w_r}^{R+w_r} \\int_{R/2-w_z}^{R/2+w_z} \\frac{\\rho^2}{\\left(\\rho^2 + (z')^2\\right)^{3/2}} dz' d\\rho\n$$\n该表达式对有限截面（$w_r > 0$, $w_z > 0$）有效，并需要进行数值计算。\n\n当 $w_r=0$ 且 $w_z=0$ 时，会出现一个特殊情况。此时线圈被视为一个半径为 $R$、匝数为 $N$ 的理想薄环。这样一个位于轴向位置 $z=R/2$ 的线圈产生的磁场为：\n$$\nB_1 = \\frac{\\mu_0 (NI) R^2}{2\\left(R^2 + (R/2)^2\\right)^{3/2}} = \\frac{\\mu_0 N I R^2}{2\\left(5R^2/4\\right)^{3/2}} = \\frac{\\mu_0 N I R^2}{2(5\\sqrt{5}/8)R^3} = \\frac{4\\mu_0 N I}{5\\sqrt{5}R}\n$$\n因此，理想亥姆霍兹线圈在原点处的总磁场为：\n$$\nB(0) = 2 B_1 = \\frac{8\\mu_0 N I}{5\\sqrt{5}R} = \\left(\\frac{4}{5}\\right)^{3/2} \\frac{\\mu_0 N I}{R}\n$$\n该解析公式用于案例1。对于案例2和案例3，有限截面的二重积分使用标准的二维求积程序进行数值计算。以下程序实现了这一逻辑，以确定每个指定测试案例的磁场。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\nfrom scipy.constants import mu_0\n\ndef solve():\n    \"\"\"\n    Computes the magnetic field at the center of a Helmholtz coil system\n    for different coil cross-section geometries.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, I, R, w_r, w_z) corresponding to:\n    # N: number of turns per coil\n    # I: current in amperes\n    # R: mean radius in meters\n    # w_r: radial half-width in meters\n    # w_z: axial half-height in meters\n    test_cases = [\n        (200, 1.5, 0.25, 0.0, 0.0),    # Case 1 (boundary, thin coils)\n        (200, 1.5, 0.25, 0.01, 0.01), # Case 2 (finite cross-section, small thickness)\n        (100, 2.0, 0.30, 0.03, 0.02), # Case 3 (finite cross-section, thicker)\n    ]\n\n    results = []\n\n    # The integrand is derived from the Biot-Savart law for a circular loop.\n    # integrand(z', rho) = rho^2 / (rho^2 + z'^2)^(3/2)\n    integrand = lambda z_prime, rho: rho**2 / (rho**2 + z_prime**2)**1.5\n\n    for case in test_cases:\n        N, I, R, w_r, w_z = case\n        \n        B0 = 0.0\n        \n        # Case 1: Ideal thin loop (w_r=0, w_z=0)\n        # This case has a simple analytical solution for an ideal Helmholtz coil.\n        if w_r == 0 and w_z == 0:\n            # B(0) = (4/5)^(3/2) * mu_0 * N * I / R\n            # This is equivalent to B(0) = 8 * mu_0 * N * I / (5 * sqrt(5) * R)\n            B0 = (8 * mu_0 * N * I) / (5 * np.sqrt(5) * R)\n        \n        # Cases 2  3: Finite rectangular cross-section (w_r > 0, w_z > 0)\n        # This requires numerical integration.\n        else:\n            # The total field at the origin is B(0) = 2 * B_coil_1 due to symmetry.\n            # B_coil_1 is the field from the coil at z > 0, given by an integral\n            # over its cross-section.\n            # B(0) = (mu_0 * I * N) / (4 * w_r * w_z) * Integral[... d_rho d_z']\n            prefactor = (mu_0 * I * N) / (2 * w_r * 2 * w_z)\n            \n            # Integration limits for one coil (the one at z > 0)\n            rho_min, rho_max = R - w_r, R + w_r\n            # z_prime represents the absolute axial coordinate of the differential loop\n            z_prime_min, z_prime_max = R / 2 - w_z, R / 2 + w_z\n\n            # Perform the double integral over one coil's cross-section.\n            # dblquad calculates integral(rho_min to rho_max) of\n            # [integral(g(rho) to h(rho)) of integrand(z', rho) dz'] d_rho.\n            # The order of arguments to the lambda is (y, x), which we map to (z_prime, rho).\n            integral_val, _ = dblquad(\n                integrand,\n                rho_min,\n                rho_max,\n                lambda rho: z_prime_min,\n                lambda rho: z_prime_max\n            )\n            \n            # The total field is due to BOTH coils, so we multiply by 2.\n            # B(0) = 2 * [ (mu_0 * I * N) / (8 * w_r * w_z) * integral_val ]\n            B0 = (mu_0 * I * N) / (4 * w_r * w_z) * integral_val\n\n        # Format result to 10 significant digits as specified and append to list of results.\n        # The '.10g' format specifier handles this requirement correctly.\n        results.append(f\"{B0:.10g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2414964"}, {"introduction": "超越单纯的数值计算，本练习将引导你使用计算工具来验证物理学中最深刻的定律之一——高斯定律。你将通过对一个包围点电荷的立方体表面进行数值积分，来计算电通量，并将其与高斯定律的精确理论预测进行比较。这个过程将加深你对“通量”这一核心概念的理解，并直观地展示数值方法在验证和探索基本物理原理方面的强大能力。[@problem_id:2415017]", "problem": "要求您编写一个完整的、可运行的程序，该程序用于数值计算通过一个闭合立方体表面的总电通量，并将结果与高斯定律的预测值进行比较。在真空环境下，使用国际单位制 (SI) 进行计算。所有涉及通量的物理答案必须以 $\\mathrm{N \\cdot m^2/C}$ 为单位表示。\n\n一个位于真空、位置为 $\\mathbf{r}_0 = (x_q,y_q,z_q)$、电荷量为 $q$ 的点电荷，产生的电场由库仑定律给出：\n$$\n\\mathbf{E}(\\mathbf{r}) = \\frac{1}{4\\pi \\varepsilon_0}\\,\\frac{q\\,(\\mathbf{r}-\\mathbf{r}_0)}{\\lVert \\mathbf{r}-\\mathbf{r}_0\\rVert^3},\n$$\n其中 $\\varepsilon_0$ 是真空介电常数。通过闭合曲面 $S$ 的总电通量 $\\Phi$ 定义为\n$$\n\\Phi = \\iint_S \\mathbf{E}\\cdot d\\mathbf{A},\n$$\n其中 $d\\mathbf{A}$ 是向外的面元。高斯定律指出，对于一个点电荷，通过任何闭合曲面的精确通量为\n$$\n\\Phi_{\\text{exact}} = \\frac{q_{\\text{enclosed}}}{\\varepsilon_0},\n$$\n其中，如果电荷严格位于闭合曲面内部，则 $q_{\\text{enclosed}}=q$；如果严格位于外部，则 $q_{\\text{enclosed}}=0$。此处不考虑电荷恰好位于曲面上的情况。\n\n设闭合曲面为一个轴对齐的立方体，其边长为 $L0$，中心位于 $\\mathbf{c}=(c_x,c_y,c_z)$，因此其六个面是平面 $x=c_x\\pm L/2$、$y=c_y\\pm L/2$ 和 $z=c_z\\pm L/2$，法线向外。\n\n您的程序必须：\n- 通过对六个面进行积分，数值计算曲面积分 $\\Phi=\\iint_S \\mathbf{E}\\cdot d\\mathbf{A}$。不要假定任何对称性简化。\n- 通过测试 $(x_q,y_q,z_q)$ 是否严格位于开立方体 $(c_x-L/2,c_x+L/2)\\times(c_y-L/2,c_y+L/2)\\times(c_z-L/2,c_z+L/2)$ 内部，来确定 $q_{\\text{enclosed}}$。\n- 对每个测试用例，计算绝对误差 $\\Delta=\\lvert \\Phi-\\Phi_{\\text{exact}}\\rvert$。\n- 在最终输出中，将每个 $\\Delta$ 以 $\\mathrm{N \\cdot m^2/C}$ 为单位表示，并将每个值以科学记数法四舍五入到六位有效数字。\n\n使用真空介电常数 $\\varepsilon_0=8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$，并假设所有量均使用标准国际单位制 (SI) 值。如果您的数值方法内部使用角度，则必须以弧度为单位。\n\n测试套件：您的程序必须评估以下用例，其中 $L$ 的单位是 $\\mathrm{m}$，位置单位是 $\\mathrm{m}$，$q$ 的单位是 $\\mathrm{C}$。\n- 用例 1：$\\mathbf{c}=(0,0,0)$，$L=2$，$\\mathbf{r}_0=(0,0,0)$，$q=1.0\\times 10^{-6}$。\n- 用例 2：$\\mathbf{c}=(0,0,0)$，$L=2$，$\\mathbf{r}_0=(3,0,0)$，$q=1.0\\times 10^{-6}$。\n- 用例 3：$\\mathbf{c}=(0.2,-0.1,0.3)$，$L=1.4$，$\\mathbf{r}_0=(0.8,-0.1,0.3)$，$q=-2.0\\times 10^{-6}$。\n- 用例 4：$\\mathbf{c}=(1.0,1.0,1.0)$，$L=0.5$，$\\mathbf{r}_0=(1.1,1.1,1.1)$，$q=5.0\\times 10^{-7}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表的第 $k$ 个条目是第 $k$ 个用例的绝对误差 $\\Delta$，单位为 $\\mathrm{N \\cdot m^2/C}$，并以科学记数法四舍五入到六位有效数字。例如，包含四个结果的输出行必须如下所示：\n$$\n[\\text{d}_1,\\text{d}_2,\\text{d}_3,\\text{d}_4]\n$$\n其中每个 $\\text{d}_k$ 都以科学记数法打印，并有六位有效数字。", "solution": "该问题陈述已经过严格验证，被认为是有效的。它构成了一个适定的计算物理练习，科学上是合理的，并提供了一套完整的参数和明确的目标。因此，我们将着手提供一个完整的解决方案。目标是数值计算通过闭合立方体表面的电通量，并将此结果与高斯定律给出的精确理论值进行比较。\n\n由位于位置 $\\mathbf{r}_0 = (x_q, y_q, z_q)$ 的点电荷 $q$ 产生的电场 $\\mathbf{E}$ 由库仑定律给出：\n$$\n\\mathbf{E}(\\mathbf{r}) = k_e q \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert^3}\n$$\n其中 $\\mathbf{r}=(x,y,z)$ 是观测点，$k_e = \\frac{1}{4\\pi\\varepsilon_0}$ 是库仑常数，$\\varepsilon_0$ 是真空介电常数。\n\n通过闭合曲面 $S$ 的总电通量 $\\Phi$ 是电场的曲面积分：\n$$\n\\Phi = \\iint_S \\mathbf{E} \\cdot d\\mathbf{A}\n$$\n在此问题中，曲面 $S$ 是一个轴对齐的立方体，边长为 $L$，中心位于 $\\mathbf{c} = (c_x, c_y, c_z)$。该闭合曲面由六个平面组成。总通量是通过这六个面中每一个面的通量之和：\n$$\n\\Phi = \\sum_{i=1}^{6} \\Phi_i = \\sum_{i=1}^{6} \\iint_{S_i} \\mathbf{E} \\cdot d\\mathbf{A}_i\n$$\n其中 $S_i$ 是第 $i$ 个面的表面。\n\n要计算通过单个面的通量，我们必须定义被积函数 $\\mathbf{E} \\cdot d\\mathbf{A}$ 以及积分限。让我们考虑一个通用的面。对于轴对齐的立方体，每个面由一个常数坐标（例如，$x = c_x + L/2$）定义，并具有一个与某个坐标轴平行的向外法向量 $\\mathbf{\\hat{n}}$。面元为 $d\\mathbf{A} = \\mathbf{\\hat{n}} \\, du \\, dv$，其中 $u$ 和 $v$ 是覆盖该平面的两个积分变量。则通过该面的通量为：\n$$\n\\Phi_i = \\iint_{S_i} (\\mathbf{E} \\cdot \\mathbf{\\hat{n}}) \\, du \\, dv\n$$\n被积函数 $\\mathbf{E} \\cdot \\mathbf{\\hat{n}}$ 可以更明确地表示。代入 $\\mathbf{E}(\\mathbf{r})$ 的表达式：\n$$\n\\mathbf{E}(\\mathbf{r}(u,v)) \\cdot \\mathbf{\\hat{n}} = k_e q \\frac{(\\mathbf{r}(u,v) - \\mathbf{r}_0) \\cdot \\mathbf{\\hat{n}}}{\\lVert \\mathbf{r}(u,v) - \\mathbf{r}_0 \\rVert^3}\n$$\n其中 $\\mathbf{r}(u,v)$ 是面 $S_i$ 上一点的位置矢量。例如，对于 $x = c_x + L/2$ 的面，法线为 $\\mathbf{\\hat{n}}=(1,0,0)$，积分变量为 $(u,v)=(y,z)$，位置矢量为 $\\mathbf{r}(y,z) = (c_x + L/2, y, z)$。$y$ 和 $z$ 的积分限分别为 $[c_y - L/2, c_y + L/2]$ 和 $[c_z - L/2, c_z + L/2]$。该公式系统地应用于所有六个面。\n\n每个二维积分 $\\Phi_i$ 的计算都使用自适应求积算法进行数值求解。`scipy.integrate.dblquad` 函数适用于此目的。该函数迭代地细化网格，以在矩形域上对给定的二维函数积分达到所需的精度。由于问题陈述保证电荷 $q$ 绝不会恰好位于曲面 $S$ 上，因此被积函数在每个面 $S_i$ 上都是连续且良态的，从而确保了数值积分的可靠性。\n\n总通量的数值结果 $\\Phi_{\\text{numerical}} = \\sum_i \\Phi_i$ 随后与高斯定律给出的精确理论值 $\\Phi_{\\text{exact}}$进行比较：\n$$\n\\Phi_{\\text{exact}} = \\frac{q_{\\text{enclosed}}}{\\varepsilon_0}\n$$\n为了确定 $q_{\\text{enclosed}}$，我们执行一个简单的几何包含测试。当且仅当电荷 $q$ 的坐标 $(x_q, y_q, z_q)$ 严格位于立方体体积内部时，该电荷被包含，此时 $q_{\\text{enclosed}} = q$。这个条件可以正式表述为：\n$$\n(c_x - L/2  x_q  c_x + L/2) \\land (c_y - L/2  y_q  c_y + L/2) \\land (c_z - L/2  z_q  c_z + L/2)\n$$\n如果此条件不满足，则电荷在立方体外部，此时 $q_{\\text{enclosed}} = 0$。\n\n最后，计算数值计算通量与精确通量之间的绝对误差 $\\Delta$，以评估我们数值方法的准确性：\n$$\n\\Delta = \\lvert \\Phi_{\\text{numerical}} - \\Phi_{\\text{exact}} \\rvert\n$$\n此过程将应用于问题中指定的每个测试用例。所得误差 $\\Delta$ 量化了我们的数值积分对通量基本定义的计算结果与高斯定律这个强大而简洁的陈述的吻合程度。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Physical constants in SI units\n    EPSILON_0 = 8.8541878128e-12  # Vacuum permittivity in F/m\n    K_E = 1.0 / (4.0 * np.pi * EPSILON_0)  # Coulomb's constant\n\n    # Test suite: (center, side_length, charge_position, charge_magnitude)\n    test_cases = [\n        # Case 1: Charge at center, inside\n        ((0.0, 0.0, 0.0), 2.0, (0.0, 0.0, 0.0), 1.0e-6),\n        # Case 2: Charge outside\n        ((0.0, 0.0, 0.0), 2.0, (3.0, 0.0, 0.0), 1.0e-6),\n        # Case 3: Charge inside, off-center\n        ((0.2, -0.1, 0.3), 1.4, (0.8, -0.1, 0.3), -2.0e-6),\n        # Case 4: Charge inside, near corner\n        ((1.0, 1.0, 1.0), 0.5, (1.1, 1.1, 1.1), 5.0e-7),\n    ]\n\n    results = []\n    for c_tuple, L, r0_tuple, q in test_cases:\n        c = np.array(c_tuple)\n        r0 = np.array(r0_tuple)\n        \n        # Calculate numerical flux by integrating over the six faces\n        numerical_flux = calculate_numerical_flux(c, L, r0, q, K_E)\n        \n        # Determine exact flux from Gauss's Law\n        h = L / 2.0\n        is_inside = (\n            (c[0] - h  r0[0]  c[0] + h) and\n            (c[1] - h  r0[1]  c[1] + h) and\n            (c[2] - h  r0[2]  c[2] + h)\n        )\n        q_enclosed = q if is_inside else 0.0\n        exact_flux = q_enclosed / EPSILON_0\n        \n        # Compute the absolute error\n        error = abs(numerical_flux - exact_flux)\n        \n        # Format result to 6 significant figures in scientific notation\n        # Precision p-1 for p significant digits, so 5 for 6 sig figs.\n        results.append(f\"{error:.5e}\")\n\n    # Print an output line in the required format\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_numerical_flux(c, L, r0, q, K_E):\n    \"\"\"\n    Numerically computes the total electric flux through a cubical surface.\n\n    Args:\n        c (np.ndarray): Center of the cube (cx, cy, cz).\n        L (float): Side length of the cube.\n        r0 (np.ndarray): Position of the point charge (xq, yq, zq).\n        q (float): Magnitude of the point charge.\n        K_E (float): Coulomb's constant.\n\n    Returns:\n        float: The total numerical flux.\n    \"\"\"\n    h = L / 2.0\n    total_flux = 0.0\n\n    # Define the six faces of the cube.\n    # Each tuple contains: (fixed_dim_idx, sign, integration_dims_indices)\n    # fixed_dim_idx: 0 for x, 1 for y, 2 for z\n    # sign: +1 for positive-side face, -1 for negative-side face\n    # integration_dims: indices of the two integration variables\n    faces = [\n        (0,  1, (1, 2)),  # Right face (x = cx + h)\n        (0, -1, (1, 2)),  # Left face  (x = cx - h)\n        (1,  1, (0, 2)),  # Top face   (y = cy + h)\n        (1, -1, (0, 2)),  # Bottom face(y = cy - h)\n        (2,  1, (0, 1)),  # Front face (z = cz + h)\n        (2, -1, (0, 1)),  # Back face  (z = cz - h)\n    ]\n\n    for fixed_dim, sign, int_dims in faces:\n        fixed_coord_val = c[fixed_dim] + sign * h\n        u_idx, v_idx = int_dims\n        \n        u_min, u_max = c[u_idx] - h, c[u_idx] + h\n        v_min, v_max = c[v_idx] - h, c[v_idx] + h\n\n        def integrand(v, u):\n            # `u` and `v` are the integration variables on the face.\n            # dblquad expects the function signature func(inner_var, outer_var)\n            # Here, v is inner, u is outer.\n            r_surf = np.zeros(3)\n            r_surf[fixed_dim] = fixed_coord_val\n            r_surf[u_idx] = u\n            r_surf[v_idx] = v\n            \n            vec_r = r_surf - r0\n            dist_sq = vec_r @ vec_r\n\n            if dist_sq == 0:\n                # Charge is on the integration path point, which is guaranteed\n                # not to happen for the overall surface but might be sampled\n                # by the quadrature. Return 0 to avoid division by zero.\n                return 0.0\n            \n            dist = np.sqrt(dist_sq)\n\n            # The integrand is the component of E normal to the surface: E . n_hat\n            # E . n_hat = (K_E * q * vec_r / dist^3) . n_hat\n            # vec_r . n_hat is simply the component of vec_r along the normal.\n            vec_r_dot_n_hat = vec_r[fixed_dim] * sign\n            \n            return K_E * q * vec_r_dot_n_hat / (dist**3)\n\n        flux_face, _ = dblquad(\n            integrand,\n            u_min, u_max,       # outer integration limits (u)\n            lambda u: v_min,    # inner integration lower limit (v)\n            lambda u: v_max     # inner integration upper limit (v)\n        )\n        total_flux += flux_face\n\n    return total_flux\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2415017"}, {"introduction": "一个强大的工具若要被有效使用，我们必须了解其局限性。此练习是一个思想实验，旨在挑战你对数值积分方法的理解。通过分析一个在数学上构造的、连续但处处不可导的二维魏尔斯特拉斯函数，你将探讨为何某些标准数值方法（如高斯求积和自适应方案）会遇到困难，而另一些方法（如蒙特卡洛方法）则表现得更为稳健。这有助于培养一种批判性思维，即在应用任何算法之前，都需要审视问题本身的数学特性。[@problem_id:2414968]", "problem": "考虑以下定义在单位正方形 $[0,1]^2$ 上的二维（$2$D）Weierstrass 型函数：\n$$\nf(x,y) \\;=\\; \\sum_{n=0}^{\\infty} a^n\\Big(\\cos\\!\\big(\\pi\\, b^n x\\big) + \\cos\\!\\big(\\pi\\, b^n y\\big)\\Big),\n$$\n其参数为 $a=\\tfrac{1}{2}$ 和 $b=9$（因此 $0a1$，$b$ 是一个奇整数，且 $a\\,b1$），这使得 $f$ 在每个坐标上都是连续且处处不可微的。令\n$$\nI \\;=\\; \\iint_{[0,1]^2} f(x,y)\\, \\mathrm{d}x\\,\\mathrm{d}y.\n$$\n要求你评估 $I$ 的值以及应用于此被积函数的数值积分方法的稳定性。\n\n选择所有正确的陈述。\n\nA. 积分的精确值为 $0$。\n\nB. 一个基于 $[0,1]^2$ 上 $N$ 个独立同分布均匀样本的简单 Monte Carlo (MC) 估计量对于 $I$ 是无偏的，并且其标准误差以 $N^{-1/2}$ 的比例缩放。\n\nC. 每个维度上的张量积 $n$ 点 Gauss–Legendre 求积对所有 $n$ 都精确地计算出 $I$，因为 $f$ 是具有整数频率的余弦函数之和。\n\nD. 使用 Sobol 序列的准 Monte Carlo (QMC) 方法可以被证明对这个 $f$ 收敛，其确定性误差为 $N^{-1}$ 阶，因为 $f$ 是有界且连续的。\n\nE. 一种基于局部误差估计进行加密的自适应细分方案可能无法得出 $I$ 的稳定估计，除非加密进行到单元尺寸达到 $b^{-m}$ 数量级（对于足够大的 $m$），因为 $f$ 包含任意高频率的分量。", "solution": "所述问题在数学上是适定的，并且有科学依据。它提出了一个关于二维 Weierstrass 型函数的解析和数值性质的严谨问题，这是高等分析和计算科学中的一个标准课题。我们将进行全面的推导和分析。\n\n首先，我们确定积分 $I$ 的精确值。积分定义为：\n$$\nI \\;=\\; \\iint_{[0,1]^2} f(x,y)\\, \\mathrm{d}x\\,\\mathrm{d}y\n$$\n其中被积函数为：\n$$\nf(x,y) \\;=\\; \\sum_{n=0}^{\\infty} a^n\\Big(\\cos\\!\\big(\\pi\\, b^n x\\big) + \\cos\\!\\big(\\pi\\, b^n y\\big)\\Big)\n$$\n参数为 $a=\\tfrac{1}{2}$ 和 $b=9$。\n\n定义 $f(x,y)$ 的级数在定义域 $[0,1]^2$ 上一致收敛。这可以通过 Weierstrass M-检验来确定。级数中每一项的绝对值都有界：\n$$\n\\left| a^n\\Big(\\cos\\!\\big(\\pi\\, b^n x\\big) + \\cos\\!\\big(\\pi\\, b^n y\\big)\\Big) \\right| \\le a^n (1+1) = 2a^n\n$$\n由于 $a = \\tfrac{1}{2}$，我们有 $0  a  1$，并且几何级数 $\\sum_{n=0}^{\\infty} 2a^n$ 收敛。因为 $f(x,y)$ 的级数一致收敛，我们可以合法地交换求和与积分的顺序：\n$$\nI \\;=\\; \\sum_{n=0}^{\\infty} a^n \\iint_{[0,1]^2} \\Big(\\cos(\\pi b^n x) + \\cos(\\pi b^n y)\\Big) \\,\\mathrm{d}x\\,\\mathrm{d}y\n$$\n根据积分的线性性质，这变成：\n$$\nI \\;=\\; \\sum_{n=0}^{\\infty} a^n \\left( \\iint_{[0,1]^2} \\cos(\\pi b^n x) \\,\\mathrm{d}x\\,\\mathrm{d}y + \\iint_{[0,1]^2} \\cos(\\pi b^n y) \\,\\mathrm{d}x\\,\\mathrm{d}y \\right)\n$$\n积分是可分离的。让我们计算第一部分：\n$$\n\\iint_{[0,1]^2} \\cos(\\pi b^n x) \\,\\mathrm{d}x\\,\\mathrm{d}y \\;=\\; \\left( \\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x \\right) \\left( \\int_0^1 1 \\,\\mathrm{d}y \\right)\n$$\n第二个因子是 $\\int_0^1 1 \\,\\mathrm{d}y = 1$。第一个因子是：\n$$\n\\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x \\;=\\; \\left[ \\frac{\\sin(\\pi b^n x)}{\\pi b^n} \\right]_0^1 \\;=\\; \\frac{\\sin(\\pi b^n)}{\\pi b^n}\n$$\n这对于 $b^n \\neq 0$ 成立，而当 $b=9$ 且 $n \\ge 0$ 时，这个条件是满足的。\n参数 $b=9$ 是一个整数。因此，对于所有整数 $n \\ge 0$，$b^n = 9^n$ 也是一个整数。任何 $\\pi$ 的整数倍的正弦值为零。因此，对于所有 $n \\ge 0$，$\\sin(\\pi b^n) = 0$。\n这意味着：\n$$\n\\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x = 0 \\quad \\text{for all } n \\ge 0.\n$$\n根据对称性，关于 $y$ 的积分也为零。因此，$I$ 的级数中每一项都为零：\n$$\nI \\;=\\; \\sum_{n=0}^{\\infty} a^n (0 + 0) = 0.\n$$\n\n确定了积分的精确值为 $0$ 之后，我们现在来评估每个陈述。\n\n**A. 积分的精确值为 $0$。**\n如上所示，直接的解析计算证实了 $I=0$。\n结论：**正确**。\n\n**B. 一个基于 $[0,1]^2$ 上 $N$ 个独立同分布均匀样本的简单 Monte Carlo (MC) 估计量对于 $I$ 是无偏的，并且其标准误差以 $N^{-1/2}$ 的比例缩放。**\n$I$ 的简单 Monte Carlo 估计量是 $\\hat{I}_N = \\frac{1}{N} \\sum_{i=1}^N f(\\mathbf{u}_i)$，其中 $\\mathbf{u}_i$ 是来自 $[0,1]^2$ 上均匀分布的独立同分布随机向量。\n如果估计量的期望值等于真实值 $I$，那么该估计量是无偏的。根据期望的线性性质：\n$$\n\\mathbb{E}[\\hat{I}_N] = \\mathbb{E}\\left[ \\frac{1}{N} \\sum_{i=1}^N f(\\mathbf{u}_i) \\right] = \\frac{1}{N} \\sum_{i=1}^N \\mathbb{E}[f(\\mathbf{u}_i)] = \\mathbb{E}[f(\\mathbf{u}_1)] = \\iint_{[0,1]^2} f(x,y) p(x,y) \\,\\mathrm{d}x\\,\\mathrm{d}y\n$$\n由于在单位正方形上概率密度函数为 $p(x,y)=1$，所以 $\\mathbb{E}[\\hat{I}_N] = I$。该估计量对于任何可积函数都是无偏的，而 $f$ 正是可积的。\n估计量的标准误差是 $\\sigma_f / \\sqrt{N}$，其中 $\\sigma_f^2$ 是函数的方差，$\\sigma_f^2 = \\iint_{[0,1]^2} f(x,y)^2 \\,\\mathrm{d}x\\,\\mathrm{d}y - I^2$。为了使标准误差以 $N^{-1/2}$ 的比例缩放，方差 $\\sigma_f^2$ 必须是有限的。函数 $f$ 在紧集 $[0,1]^2$ 上是连续的，因此它是有界的。令 $M$ 为 $|f(x,y)|$ 的上确界。那么 $\\iint f(x,y)^2 \\,\\mathrm{d}x\\,\\mathrm{d}y \\le \\iint M^2 \\,\\mathrm{d}x\\,\\mathrm{d}y = M^2  \\infty$。方差是有限的。\n因此，中心极限定理适用，均值的标准误差以 $N^{-1/2}$ 的速度收敛。\n结论：**正确**。\n\n**C. 每个维度上的张量积 $n$ 点 Gauss–Legendre 求积对所有 $n$ 都精确地计算出 $I$，因为 $f$ 是具有整数频率的余弦函数之和。**\n这个陈述包含两部分：关于精确性的声明和其理由。\n让我们分析这个声明。在 $[-1,1]$ 上的 $n$ 点 Gauss-Legendre 求积对于任何奇函数都是精确的，因为积分值为 $0$ 并且对称的节点和权重使得求和结果为 $0$。我们必须分析典型项的积分 $\\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x$。我们通过 $x = (u+1)/2$ 将积分区间 $[0,1]$ 映射到 $[-1,1]$。积分变为 $\\frac{1}{2} \\int_{-1}^1 \\cos(\\pi b^n (u+1)/2) \\,\\mathrm{d}u$。被积函数是 $g(u) = \\cos(\\pi b^n/2 + \\pi b^n u/2)$。由于 $b=9$，$b^n$ 对于所有 $n \\ge 0$ 都是奇整数。对于任何奇整数 $k$，$\\cos(k\\pi/2 + \\theta) = -\\sin(k\\pi/2)\\sin(\\theta) = \\mp \\sin(\\theta)$。所以 $g(u)$ 是 $u$ 的奇函数。Gauss-Legendre 求积法则应用于对称区间上的奇函数时，得到的结果恰好是 $0$。由于这对 $f(x,y)$ 级数中的每一项都成立，张量积法则也得到 $0$，这正是 $I$ 的精确值。所以这个声明是正确的。\n现在，我们必须仔细审查其理由：“因为 $f$ 是具有整数频率的余弦函数之和。”这种措辞很可能指的是在 $\\cos(\\pi k x)$ 中，参数 $k=b^n$ 是一个整数。这个性质意味着 $\\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x = 0$。然而，这并不足以保证*求积*的精确性。考虑一个 $b$ 是偶数的情况，例如 $b=2$。对于 $n \\ge 1$，频率仍为整数，并且 $\\int_0^1 \\cos(2\\pi x)\\,\\mathrm{d}x=0$。但变换后的被积函数是 $\\cos(\\pi(u+1)) = -\\cos(\\pi u)$，一个偶函数。一个 $n$ 点求积法则通常不会对这个积分得到 $0$。例如，在 $[0,1]$ 上的 1 点法则使用节点 $x=1/2$ 和权重 $1$，得到 $\\cos(2\\pi \\cdot 1/2) = -1 \\neq 0$。精确性关键依赖于 $b^n$ 是一个**奇**整数，而所给出的理由没有抓住这一条件。这个推理是有缺陷和不完整的。\n结论：**不正确**。\n\n**D. 使用 Sobol 序列的准 Monte Carlo (QMC) 方法可以被证明对这个 $f$ 收敛，其确定性误差为 $N^{-1}$ 阶，因为 $f$ 是有界且连续的。**\nQMC 方法的误差由 Koksma-Zaremba 不等式界定，即 $|I - \\hat{I}_N| \\le V_{HK}(f) \\cdot D_N^*$，其中 $V_{HK}(f)$ 是 Hardy 和 Krause 意义下的 $f$ 的全变差，而 $D_N^*$ 是点集的星偏差。对于 $d=2$ 维的 Sobol 序列，$D_N^* = O(N^{-1}(\\log N)^2)$。所声称的 $O(N^{-1})$ 误差界只有在函数具有有限的 Hardy-Krause 变差时才能达到。给定函数 $f(x,y)$ 被描述为连续但处处不可微。此类函数具有无穷大的变差。Weierstrass 函数是一个典型例子，对于这类函数，标准的 QMC 误差界没有用，并且 QMC 方法表现不佳。对于连续函数，收敛率不保证优于 MC 方法。对于仅是 Hölder 连续且指数为 $\\alpha$ 的函数，QMC 误差的阶为 $O(N^{-\\alpha})$。对于这个 Weierstrass 函数，Hölder 指数为 $\\alpha = -\\log(a)/\\log(b) = \\log(2)/\\log(9) \\approx 0.315$。这意味着收敛率远差于 $O(N^{-1})$。理由 “因为 $f$ 是有界且连续的” 也是错误的；这些条件本身只能保证 QMC 估计收敛到积分值，但不能保证任何特定的收敛率。\n结论：**不正确**。\n\n**E. 一种基于局部误差估计进行加密的自适应细分方案可能无法得出 $I$ 的稳定估计，除非加密进行到单元尺寸达到 $b^{-m}$ 数量级（对于足够大的 $m$），因为 $f$ 包含任意高频率的分量。**\n自适应求积程序依赖于局部误差估计器，这些估计器通常基于比较不同阶数法则的结果，或者基于细分一个区间并将总和与原始估计进行比较。这些估计器只有在给定单元内被积函数足够光滑（例如，具有若干阶连续导数）时才能可靠地工作。函数 $f(x,y)$ 是连续但处处不可微的，在所有尺度上都表现出自相似的分形结构。当自适应算法加密一个单元时，新的、更小的单元中的被积函数与父单元中的一样不光滑和振荡。这违反了局部光滑性的基本假设。因此，误差估计器是不可靠的：它们可能极不准确，导致算法无法收敛、因无限加密而耗尽内存资源，或以错误的结果提前终止。这种病态现象的原因确实是存在具有任意高频率（以 $b^n$ 增长）和不可忽略的振幅（$a^n$）的分量 $\\cos(\\pi b^n x)$。为了分辨一个频率与 $b^m$ 成正比的分量，单元尺寸必须小于相应的波长，即 $b^{-m}$ 的数量级。这个陈述准确地描述了标准自适应求积在这种病态函数上的失效模式。\n结论：**正确**。", "answer": "$$\\boxed{ABE}$$", "id": "2414968"}]}