{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。要真正掌握反常积分的数值计算，最好的方法就是亲自动手解决问题。本节提供了一系列精心设计的实践练习，从处理无限积分域到应对各种奇点，旨在逐步培养你解决实际科学问题的能力。我们将从一个源于物理学基本守恒定律的直观问题开始。\n\n    第一个练习是关于热方程的格林函数（或称基本解），它描述了热量如何从一个点源扩散开来 [@problem_id:2419418]。一个关键的物理原则是，热量（或在概率论中的总概率）在扩散过程中必须守恒。这个练习要求你通过在一维和二维空间中对格林函数进行积分，来数值验证这一定律。这不仅能巩固你处理无限积分域的技巧，还能让你体验到如何利用对称性（如此处的极坐标变换）来简化并解决多维积分问题。", "problem": "考虑一维和二维空间中扩散（热）方程的基本解（格林函数）。对于正常数扩散系数 $D$ 和时间 $t>0$，一维格林函数为\n$$\nG_{1}(x,t;D)=\\frac{1}{\\sqrt{4\\pi D t}}\\exp\\!\\left(-\\frac{x^{2}}{4Dt}\\right),\n$$\n定义于 $x\\in\\mathbb{R}$，二维格林函数为\n$$\nG_{2}(\\mathbf{r},t;D)=\\frac{1}{4\\pi D t}\\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^{2}}{4Dt}\\right),\n$$\n定义于 $\\mathbf{r}\\in\\mathbb{R}^{2}$。对于这些基本解，总“能量”（总概率质量）守恒的数学表述是，其在整个空间域上的对应的反常积分等于 $1$，即：\n$$\nI_{1}(D,t)=\\int_{-\\infty}^{\\infty} G_{1}(x,t;D)\\,dx,\n\\quad\nI_{2}(D,t)=\\iint_{\\mathbb{R}^{2}} G_{2}(\\mathbf{r},t;D)\\,d^{2}\\mathbf{r},\n$$\n守恒定律要求对于所有 $D>0$ 和 $t>0$，都有 $I_{1}(D,t)=1$ 和 $I_{2}(D,t)=1$。\n\n你的任务是编写一个完整、可运行的程序，分别对给定的一维和二维空间参数值 $(D,t)$，数值计算这些反常积分，并返回计算结果。程序必须通过在全域 $\\mathbb{R}$ 和 $\\mathbb{R}^{2}$ 上进行数值积分来计算 $I_{1}(D,t)$ 和 $I_{2}(D,t)$，不得使用任何闭式原函数。\n\n测试用例：\n- 情况 $1$（一维）：$D=0.5$，$t=2.0$；计算 $I_{1}(D,t)$。\n- 情况 $2$（二维）：$D=1.0$，$t=0.1$；计算 $I_{2}(D,t)$。\n- 情况 $3$（二维，小时间）：$D=1.0$，$t=10^{-4}$；计算 $I_{2}(D,t)$。\n- 情况 $4$（一维，大时间和扩散系数）：$D=3.0$，$t=100.0$；计算 $I_{1}(D,t)$。\n- 情况 $5$（二维，小扩散系数）：$D=10^{-3}$，$t=5.0$；计算 $I_{2}(D,t)$。\n\n你的程序必须生成单行输出，其中包含按上述情况顺序排列的结果，形式为方括号内以逗号分隔的列表。每个结果都必须是精确到小数点后 $10$ 位的浮点数。例如，输出格式必须为\n$[r_{1},r_{2},r_{3},r_{4},r_{5}]$，\n其中 $r_{k}$ 是情况 $k$ 的舍入后数值。", "solution": "该问题要求对两个反常积分 $I_1$ 和 $I_2$ 进行数值计算，这两个积分分别表示一维和二维扩散方程基本解的总概率质量。这个问题是适定的、科学上合理的且是完整的。扩散过程内含的守恒定律决定了对于任何有效参数 $D>0$ 和 $t>0$，这些积分的解析值都精确为 $1$。我们的任务是通过数值方法验证这一性质。\n\n数值方法将依赖于 `scipy.integrate.quad` 函数，该函数实现了一种适用于反常积分的稳健自适应求积算法。\n\n对于一维情况，要计算的积分是\n$$\nI_{1}(D,t)=\\int_{-\\infty}^{\\infty} G_{1}(x,t;D)\\,dx = \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{4\\pi D t}}\\exp\\!\\left(-\\frac{x^{2}}{4Dt}\\right) dx\n$$\n这个积分通过将被积函数 $G_1(x, t; D)$ 和定义域 $(-\\infty, \\infty)$ 传递给数值求积程序直接计算。\n\n对于二维情况，直接对\n$$\nI_{2}(D,t)=\\iint_{\\mathbb{R}^{2}} G_{2}(\\mathbf{r},t;D)\\,d^{2}\\mathbf{r} = \\iint_{\\mathbb{R}^{2}} \\frac{1}{4\\pi D t}\\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^{2}}{4Dt}\\right) d^{2}\\mathbf{r}\n$$\n进行数值积分效率低下。一个更优的方法是将积分变换到极坐标 $(r, \\theta)$，其中 $\\|\\mathbf{r}\\| = r$，面积元为 $d^{2}\\mathbf{r} = r\\,dr\\,d\\theta$。积分域 $\\mathbb{R}^2$ 对应于 $r \\in [0, \\infty)$ 和 $\\theta \\in [0, 2\\pi)$。积分变换为\n$$\nI_{2}(D, t) = \\int_0^{2\\pi} \\int_0^{\\infty} \\frac{1}{4\\pi D t}\\exp\\left(-\\frac{r^2}{4Dt}\\right) r\\,dr\\,d\\theta\n$$\n由于被积函数不依赖于 $\\theta$，角向积分是平凡的，结果为一个 $2\\pi$ 因子。这将问题简化为单个一维积分：\n$$\nI_{2}(D, t) = \\frac{2\\pi}{4\\pi D t} \\int_0^{\\infty} r \\exp\\left(-\\frac{r^2}{4Dt}\\right) dr = \\frac{1}{2Dt} \\int_0^{\\infty} r \\exp\\left(-\\frac{r^2}{4Dt}\\right) dr\n$$\n然后，这个在定义域 $[0, \\infty)$ 上的简化积分便可以高效且精确地进行数值计算。\n\n程序将处理所提供的 5 个测试用例：\n1.  一维：$D=0.5$，$t=2.0$\n2.  二维：$D=1.0$，$t=0.1$\n3.  二维：$D=1.0$，$t=10^{-4}$\n4.  一维：$D=3.0$，$t=100.0$\n5.  二维：$D=10^{-3}$，$t=5.0$\n\n它将为每种情况选择合适的积分方法（一维或极坐标简化后的二维）。最终的数值结果将被精确到小数点后 10 位，并以指定的列表格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Numerically evaluates the improper integrals for the Green's functions\n    of the 1D and 2D diffusion equations for specified test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple contains: (dimensionality, D, t)\n    test_cases = [\n        (1, 0.5, 2.0),\n        (2, 1.0, 0.1),\n        (2, 1.0, 1e-4),\n        (1, 3.0, 100.0),\n        (2, 10**-3, 5.0)\n    ]\n\n    # Define the integrand for the 1D case, G_1(x, t; D).\n    def g1_integrand(x, D, t):\n        \"\"\"Integrand for the 1D Green's function G_1.\"\"\"\n        denominator = 4.0 * D * t\n        prefactor = 1.0 / np.sqrt(np.pi * denominator)\n        return prefactor * np.exp(-x**2 / denominator)\n\n    # Define the integrand for the 2D case after reduction to 1D via polar coordinates.\n    # This corresponds to f(r) = (r / (2*D*t)) * exp(-r^2 / (4*D*t)).\n    def g2_integrand_polar(r, D, t):\n        \"\"\"Integrand for the 2D Green's function in polar coordinates.\"\"\"\n        denominator = 4.0 * D * t\n        prefactor = r / (2.0 * D * t)\n        return prefactor * np.exp(-r**2 / denominator)\n\n    results = []\n    for case in test_cases:\n        dim, D, t = case\n        \n        integral_value = 0.0\n        if dim == 1:\n            # Perform the 1D improper integral from -inf to +inf.\n            integral_value, _ = quad(g1_integrand, -np.inf, np.inf, args=(D, t))\n        else:  # dim == 2\n            # Perform the 1D improper integral from 0 to +inf for the polar-reduced problem.\n            integral_value, _ = quad(g2_integrand_polar, 0, np.inf, args=(D, t))\n        \n        results.append(integral_value)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to 10 decimal places.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "2419418"}, {"introduction": "在掌握了处理无限积分域的基本方法后，我们来挑战一个更复杂的场景。某些积分不仅定义在无限的区间上，其被积函数在区间的端点或内部还可能趋于无穷，即存在所谓的“奇点”（singularity）。这个练习将带你处理一个同时具有无限积分域和端点奇点的典型情况。\n\n    本题要求计算一个伽玛（Gamma）分布随机变量对数的期望值，即 $\\mathbb{E}[\\ln X]$ [@problem_id:2419387]。这类计算在信息论和统计力学等领域中非常常见。这里的积分 $\\int_0^{\\infty} \\ln(x) f(x;k) dx$ 同时存在两种“反常”特性：积分上限为无穷大，且在 $x=0$ 处由于对数项 $\\ln(x)$ 的存在而产生了一个奇点。成功解决这个问题，需要依赖一个能够有效处理这类可积奇点的鲁棒的数值积分程序。", "problem": "给定一个无量纲的随机变量 $X$，它服从形状参数为 $k&gt;0$ 且尺度参数为单位1的伽马分布。其概率密度函数为\n$$\nf(x;k)=\\frac{x^{k-1}e^{-x}}{\\Gamma(k)}, \\quad x&gt;0,\n$$\n其中 $\\Gamma(k)$ 是由下式定义的伽马函数\n$$\n\\Gamma(k)=\\int_0^{\\infty} x^{k-1}e^{-x}\\,dx.\n$$\n您的任务是编写一个完整的程序来数值计算期望\n$$\n\\mathbb{E}[\\ln X]=\\int_0^{\\infty} \\ln(x)\\, f(x;k)\\,dx\n$$\n对于每个指定的 $k$ 值。由于其无穷定义域以及在 $x=0$ 处的对数奇异性，该积分为瑕积分。计算每个值时，绝对数值误差不得超过 $10^{-10}$，然后将最终报告的值四舍五入到 $12$ 位小数。\n\n测试组（需要评估的形状参数 $k$）：\n- $k=\\tfrac{1}{2}$\n- $k=1$\n- $k=\\tfrac{3}{2}$\n- $k=10$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与上面列出的顺序相同。每个条目必须四舍五入到 $12$ 位小数。例如，一个包含四个结果的输出应如下所示\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$", "solution": "该问题要求数值计算期望值 $\\mathbb{E}[\\ln X]$，其中 $X$ 是一个随机变量，服从给定形状参数 $k>0$ 和单位尺度参数的伽马分布。其概率密度函数（PDF）为\n$$\nf(x;k) = \\frac{x^{k-1}e^{-x}}{\\Gamma(k)}, \\quad x > 0.\n$$\n该期望由积分定义\n$$\n\\mathbb{E}[\\ln X] = \\int_0^{\\infty} \\ln(x) f(x;k) \\,dx = \\frac{1}{\\Gamma(k)} \\int_0^{\\infty} \\ln(x) x^{k-1} e^{-x} \\,dx.\n$$\n必须对指定的 $k$ 值进行此积分的计算：$k=\\frac{1}{2}$、$k=1$、$k=\\frac{3}{2}$ 和 $k=10$。\n\n首先，我们分析该积分。由于两个显著特征：无穷的积分上限和在下限 $x=0$ 处的潜在奇异点，它是一个反常积分。被积函数分子（我们记作 $g(x;k) = \\ln(x) x^{k-1} e^{-x}$）在 $x=0$ 附近的行为主要由项 $\\ln(x) x^{k-1}$ 决定。对于某个小的 $\\epsilon > 0$，已知积分 $\\int_0^{\\epsilon} \\ln(x) x^{k-1} dx$ 收敛的充要条件是 $x$ 的幂大于 $-1$，即 $k-1 > -1$，可简化为 $k>0$。由于问题陈述保证了 $k>0$，因此在 $x=0$ 处的奇异点是可积的。在积分上限处，当 $x \\to \\infty$ 时，指数项 $e^{-x}$ 趋于零的速度比任何多项式或对数项 $\\ln(x) x^{k-1}$ 的增长速度都快。这确保了积分在区间 $[0, \\infty)$ 上的收敛性。\n\n因此，该问题是一个适定的数值积分任务。需要一个稳健的数值求积算法来以所需精度处理这些特性。`scipy.integrate.quad` 函数是 FORTRAN 库 QUADPACK 的 Python 接口，非常适合此目的。它专门用于计算定积分，包括那些具有无穷积分限和在积分区间边界处有可积奇异点的积分。\n\n计算策略如下：\n$1$. 对每个给定的 $k$ 值，我们定义对应于期望公式分子的被积函数 $I_{\\text{num}}(x, k) = \\ln(x) x^{k-1} e^{-x}$。先对该函数进行积分，然后再除以 $\\Gamma(k)$，这样做在数值上更为稳定。\n$2$. 我们使用 `scipy.integrate.quad` 来计算积分 $J(k) = \\int_0^{\\infty} I_{\\text{num}}(x, k) \\,dx$ 的值。为确保最终绝对误差不超过所要求的 $10^{-10}$ 容差，我们为 `quad` 函数指定一个更严格的容差，例如 `epsabs`=$10^{-13}$。\n$3$. 我们使用 `scipy.special.gamma` 中提供的高精度实现来计算伽马函数 $\\Gamma(k)$ 的值。\n$4$. 最终的期望值通过除法 $\\mathbb{E}[\\ln X] = \\frac{J(k)}{\\Gamma(k)}$ 获得。\n\n一个已确立的数学恒等式表明，该期望等于双伽马函数 $\\psi(k)$，它被定义为伽马函数的对数导数：\n$$\n\\psi(k) = \\frac{d}{dk} \\ln\\Gamma(k) = \\frac{\\Gamma'(k)}{\\Gamma(k)}.\n$$\n此恒等式通过对 $\\Gamma(k)$ 的积分定义关于 $k$ 求导得出，这一操作的合理性由控制收敛定理保证：\n$$\n\\Gamma'(k) = \\frac{d}{dk} \\int_0^{\\infty} x^{k-1} e^{-x} \\,dx = \\int_0^{\\infty} \\frac{\\partial}{\\partial k} (x^{k-1} e^{-x}) \\,dx = \\int_0^{\\infty} (\\ln x) x^{k-1} e^{-x} \\,dx.\n$$\n将此结果除以 $\\Gamma(k)$ 便可证实 $\\mathbb{E}[\\ln X] = \\psi(k)$。这个解析解在 `scipy.special.psi` 中可用，可作为一个明确的基准，用于验证我们数值积分的正确性。例如，当 $k=1$ 时，期望为 $\\psi(1) = -\\gamma$，其中 $\\gamma \\approx 0.5772156649$ 是欧拉-马斯刻若尼常数。当 $k=\\frac{1}{2}$ 时，期望为 $\\psi(\\frac{1}{2}) = -\\gamma - 2\\ln 2 \\approx -1.9635100260$。所开发的程序必须通过直接积分高精度地复现这些值，而不仅仅是调用预定义的 `psi` 函数。\n\n程序将遍历测试用例列表 $k \\in \\{\\frac{1}{2}, 1, \\frac{3}{2}, 10\\}$。对于每个 $k$，它将执行如上所述的数值积分。在格式化输出之前，每个用例的最终计算值将根据问题陈述的要求四舍五入到 $12$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Computes the expectation E[ln X] for a Gamma-distributed random variable X\n    with shape parameter k and unit scale.\n    \"\"\"\n    # Define the test cases for the shape parameter k.\n    test_cases = [0.5, 1.0, 1.5, 10.0]\n\n    results = []\n    \n    # The expectation is given by the integral of ln(x) * f(x;k) over (0, inf),\n    # where f(x;k) is the Gamma PDF. This is equivalent to:\n    # (1 / Gamma(k)) * integral[ln(x) * x**(k-1) * exp(-x) dx].\n    # We will numerically integrate the numerator and then divide by Gamma(k).\n\n    for k in test_cases:\n        # Define the numerator of the integrand as a function of x and k.\n        # This function is passed to the quadrature routine.\n        def numerator_integrand(x, k_val):\n            # This expression is singular at x=0 for k<=1, but the singularity\n            # is integrable, and `scipy.integrate.quad` is designed to handle this.\n            return np.log(x) * x**(k_val - 1) * np.exp(-x)\n            \n        # Compute the integral of the numerator from 0 to infinity.\n        # A high precision is requested for the integration routine to ensure\n        # the final absolute error is below the required 1e-10.\n        integral_numerator, _ = integrate.quad(\n            numerator_integrand,\n            0,\n            np.inf,\n            args=(k,),\n            epsabs=1e-13,\n            epsrel=1e-13\n        )\n        \n        # Compute the value of the Gamma function for the denominator.\n        gamma_val = special.gamma(k)\n        \n        # Calculate the final expectation value.\n        expectation = integral_numerator / gamma_val\n        \n        # Round the result to 12 decimal places as per the problem specification.\n        rounded_result = round(expectation, 12)\n        results.append(rounded_result)\n        \n    # The final output must be a single line containing a comma-separated\n    # list of results enclosed in square brackets.\n    # The str() conversion of the rounded floats provides the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419387"}, {"introduction": "最后，我们将探讨一个更高级的例子，它展示了一种强大的“混合”分析-数值方法。面对复杂的被积函数，纯粹的数值方法可能效率低下或难以收敛，而巧妙地结合解析分析往往能另辟蹊径。这个练习就是这种思想的绝佳体现。\n\n    本题提供了一个著名的黎曼Zeta函数 $\\zeta(s)$ 的积分表达式，其被积函数包含一个“小数部分”函数 $\\{x\\} = x - \\lfloor x \\rfloor$ [@problem_id:2419436]。这个函数在每个整数点都存在跳跃间断，使得被积函数在无限的积分域上包含了无穷多个间断点。直接对这样的函数进行数值积分是极具挑战性的。此练习引导你采用一种更为优雅的策略：首先将这个反常积分分解为一系列在单位区间上的正常积分之和，然后对每个子区间上的积分进行精确的解析求解，最终通过数值方法对得到的无穷级数进行求和，直至满足预设的精度要求。这种将积分问题转化为级数求和问题的技巧，对于处理周期性或分段定义的被积函数尤其有效。", "problem": "给定黎曼 zeta 函数对实数参数 $s$（其中 $s&gt;1$）的积分表示：\n$$\n\\zeta(s) \\;=\\; \\frac{s}{s-1} \\;-\\; s \\int_{1}^{\\infty} \\big(x - \\lfloor x \\rfloor\\big)\\, x^{-s-1}\\, dx,\n$$\n其中 $\\lfloor x \\rfloor$ 是不大于 $x$ 的最大整数，而小数部分定义为 $\\{x\\} = x - \\lfloor x \\rfloor$。\n\n编写一个完整的、可运行的程序，对每个指定的 $s$ 值，数值计算反常积分\n$$\nI(s) \\;=\\; \\int_{1}^{\\infty} \\{x\\}\\, x^{-s-1}\\, dx,\n$$\n然后计算\n$$\n\\zeta(s) \\;=\\; \\frac{s}{s-1} \\;-\\; s\\, I(s).\n$$\n您的计算必须对满足 $s&gt;1$ 的实数输入有效，并确保 $\\zeta(s)$ 最终值的绝对误差不超过 $10^{-12}$。\n\n使用以下 $s$ 的输入值集合（测试集）：\n- $s = 3.5$\n- $s = 4$\n- $s = 6$\n- $s = 8$\n- $s = 10$\n\n对于每个输入 $s$，您的程序必须输出相应的 $\\zeta(s)$ 数值，该值需四舍五入到小数点后恰好 $12$ 位。\n\n最终输出格式：您的程序应生成一行输出，其中包含测试集的结果，按上述顺序列出，形式为用方括号括起来的、无空格的逗号分隔列表。例如，输出必须具有以下形式\n$$\n[\\zeta(3.5),\\zeta(4),\\zeta(6),\\zeta(8),\\zeta(10)],\n$$\n其中每个条目是四舍五入到小数点后 12 位的十进制数。", "solution": "我们从给定的表示形式开始，该形式对 $s>1$ 的实数 $s$ 有效：\n$$\n\\zeta(s) \\;=\\; \\frac{s}{s-1} \\;-\\; s \\int_{1}^{\\infty} \\{x\\}\\, x^{-s-1}\\, dx,\n$$\n其中 $\\{x\\} = x - \\lfloor x \\rfloor$ 是小数部分。积分\n$$\nI(s) \\;=\\; \\int_{1}^{\\infty} \\{x\\}\\, x^{-s-1}\\, dx\n$$\n是反常积分，因为其定义域无界，并且被积函数在每个整数 $x \\in \\{1,2,3,\\dots\\}$ 处都有跳跃间断点。为了从第一性原理计算 $I(s)$，我们利用了 $\\{x\\}$ 是周期为 1 的分段线性和周期性函数的性质。通过将积分区间划分为单位区间，我们得到\n$$\nI(s) \\;=\\; \\sum_{n=1}^{\\infty} \\int_{n}^{n+1} (x-n)\\, x^{-s-1}\\, dx.\n$$\n每个子积分都是在有限区间上的正常积分，其中被积函数是连续的。所需的两个基本不定积分是\n$$\n\\int x^{-s}\\, dx \\;=\\; \\frac{x^{1-s}}{1-s} \\quad (s\\neq 1), \\qquad \\int x^{-s-1}\\, dx \\;=\\; -\\frac{x^{-s}}{s} \\quad (s>0).\n$$\n因此，对于每个整数 $n \\ge 1$，\n$$\n\\int_{n}^{n+1} (x-n)\\, x^{-s-1}\\, dx\n\\;=\\;\n\\left[\\frac{x^{1-s}}{1-s}\\right]_{x=n}^{x=n+1}\n\\;-\\;\nn \\left[-\\frac{x^{-s}}{s}\\right]_{x=n}^{x=n+1}\n$$\n$$\n\\;=\\;\n\\frac{(n+1)^{1-s} - n^{1-s}}{1-s}\n\\;-\\;\n\\frac{n\\big(n^{-s} - (n+1)^{-s}\\big)}{s}.\n$$\n因此，\n$$\nI(s) \\;=\\; \\sum_{n=1}^{\\infty}\n\\left(\n\\frac{(n+1)^{1-s} - n^{1-s}}{1-s}\n-\n\\frac{n\\big(n^{-s} - (n+1)^{-s}\\big)}{s}\n\\right).\n$$\n这种表示将反常积分简化为一个由显式项构成的收敛级数。为了进行数值计算，我们在第 $N$ 项之后截断级数，由此产生的截断误差 $R_N(s)$ 为：\n$$ R_N(s) = \\sum_{n=N+1}^{\\infty} \\int_{n}^{n+1} \\{x\\}\\, x^{-s-1}\\, dx $$\n由于对所有 $x$ 都有 $0 \\le \\{x\\}  1$，我们可以为这个尾项误差设定一个简单的上界：\n$$ R_N(s) \\le \\int_{N+1}^{\\infty} 1 \\cdot x^{-s-1}\\, dx = \\left[-\\frac{x^{-s}}{s}\\right]_{N+1}^{\\infty} = \\frac{(N+1)^{-s}}{s}. $$\n问题要求 $\\zeta(s)$ 的最终绝对误差不超过 $10^{-12}$。由于 $\\zeta(s) = \\frac{s}{s-1} - s I(s)$，$\\zeta(s)$ 的误差 $\\Delta\\zeta$ 与 $I(s)$ 的误差 $\\Delta I$ 之间的关系是 $|\\Delta\\zeta| = s |\\Delta I|$。因此，我们需要将 $I(s)$ 的误差控制在 $|\\Delta I| \\le 10^{-12}/s$ 以内。\n将截断误差的上界与此要求相结合，我们得到一个安全的停止准则：当\n$$ \\frac{(n+1)^{-s}}{s}  \\frac{10^{-12}}{s} \\quad \\text{或等价地} \\quad (n+1)^{-s}  10^{-12} $$\n时，我们就可以停止求和，因为此时未计算的尾项贡献已经足够小。在实际实现中，我们通常使用一个更严格的界，例如将容差减半，为浮点舍入误差留出余地。\n\n基于原理的算法设计：\n- 将反常积分分解为单位区间上的和，每个区间上的积分都可以如上所示以闭合形式求值。\n- 在累加级数时使用补偿求和方案（例如 Kahan 求和）以减轻在相加许多小数时产生的浮点舍入误差。\n- 在加上索引为 $n$ 的项之后，使用界\n$$\n\\int_{n+1}^{\\infty} \\{x\\}\\, x^{-s-1}\\, dx \\;\\le\\; \\frac{(n+1)^{-s}}{s}\n$$\n来判断剩余的尾项是否低于目标容差。一旦该界低于所选容差，就可以停止求和。\n\n对于所要求的测试集，数值结果（四舍五入到小数点后 12 位）如下：\n- 对于 $s=3.5$：$\\zeta(3.5) \\approx 1.126733867317$。\n- 对于 $s=4$：$\\zeta(4) = \\dfrac{\\pi^{4}}{90} \\approx 1.082323233711$。\n- 对于 $s=6$：$\\zeta(6) = \\dfrac{\\pi^{6}}{945} \\approx 1.017343061984$。\n- 对于 $s=8$：$\\zeta(8) = \\dfrac{\\pi^{8}}{9450} \\approx 1.004077356198$。\n- 对于 $s=10$：$\\zeta(10) = \\dfrac{\\pi^{10}}{93555} \\approx 1.000994575128$。\n\n程序实现了这一过程，将其应用于 $s\\in\\{3.5,4,6,8,10\\}$，并以要求的方括号、逗号分隔的格式打印单行结果，其中每个值都精确四舍五入到小数点后 12 位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef zeta_via_integral(s: float, atol: float = 1e-12) - float:\n    \"\"\"\n    Compute zeta(s) for real s1 using the integral representation:\n        zeta(s) = s/(s-1) - s * I(s)\n    where\n        I(s) = integral_1^∞ {x} x^{-s-1} dx\n    We evaluate I(s) as a convergent sum of closed-form interval contributions.\n    The truncation uses a safe tail bound: integral_N^∞ {x} x^{-s-1} dx = N^{-s}/s.\n    \"\"\"\n    if s = 1.0:\n        raise ValueError(\"s must be  1 for the given integral representation.\")\n    # Compensated summation (Kahan) for numerical stability\n    total = 0.0\n    comp = 0.0\n    n = 1\n    # The final error in zeta is s * error_I(s). We want s * error_I(s)  atol.\n    # The tail error of I(s) is bounded by (n+1)**(-s) / s.\n    # So we need s * [(n+1)**(-s) / s] = (n+1)**(-s)  atol.\n    # We use atol/2 to be conservative with roundoff.\n    stop_threshold = atol / 2.0\n    # To avoid excessive loops for very small tolerances or small s, also set a hard cap\n    # that is more than sufficient for the given test suite.\n    max_n = 10_000_000\n\n    one_minus_s = 1.0 - s\n    inv_s = 1.0 / s\n\n    while True:\n        # Closed-form integral over [n, n+1):\n        # term = ((n+1)^(1-s) - n^(1-s)) / (1-s) - n * (n^{-s} - (n+1)^{-s}) / s\n        n_float = float(n)\n        np1 = n_float + 1.0\n\n        n_pow_1_minus_s = n_float ** (1.0 - s)\n        np1_pow_1_minus_s = np1 ** (1.0 - s)\n        n_pow_minus_s = n_float ** (-s)\n        np1_pow_minus_s = np1 ** (-s)\n\n        first = (np1_pow_1_minus_s - n_pow_1_minus_s) / one_minus_s\n        second = (n_pow_1_minus_s - n_float * np1_pow_minus_s) * inv_s\n        term = first - second\n\n        # Kahan summation\n        y = term - comp\n        t = total + y\n        comp = (t - total) - y\n        total = t\n\n        # Tail bound check on the error of zeta(s)\n        zeta_tail_bound = np1_pow_minus_s \n        if zeta_tail_bound  stop_threshold:\n            break\n\n        n += 1\n        if n  max_n:\n            # Safety break; for the given test suite this should never trigger.\n            break\n\n    I_s = total\n    zeta_val = s / (s - 1.0) - s * I_s\n    return zeta_val\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [3.5, 4.0, 6.0, 8.0, 10.0]\n\n    results = []\n    for s in test_cases:\n        # We adjust the atol sent to the function to account for the factor 's'\n        # in the error propagation, ensuring the final zeta error is  1e-12.\n        # However, the implemented logic already handles this correctly.\n        val = zeta_via_integral(s, atol=1e-12)\n        # Round to exactly 12 digits after the decimal point\n        results.append(f\"{val:.12f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2419436"}]}