{"hands_on_practices": [{"introduction": "第一个练习将牛顿-科特斯公式直接应用于一个经典的物理问题：计算旋转体的体积。通过实现复合辛普森3/8法则，你将练习如何将一个数值积分公式转化为可运行的计算机程序。这是任何计算科学家的关键技能，它填平了理论公式与实际结果之间的鸿沟。[@problem_id:2418036]", "problem": "编写一个完整、可运行的程序，通过使用三阶闭合 Newton–Cotes 求积法则（通常称为 Simpson $3/8$ 法则）近似计算相应的定积分，来求出曲线 $y=\\mathrm{e}^{-x^{2}}$ 在有限区间 $[a,b]$ 上绕 $x$ 轴旋转生成的旋转体的体积。该程序不得接受任何输入，且必须硬编码一组参数三元组 $(a,b,n)$ 作为测试套件，其中 $a$ 和 $b$ 是指定积分区间的实数，$n$ 是指定子区间数量的正整数。数字 $n$ 必须是 $3$ 的正整数倍。对于每个测试用例，程序必须以浮点数形式生成体积的数值近似值。此问题不涉及任何角度。输出中不需要物理单位。\n\n使用以下测试套件，表示为三元组 $(a,b,n)$ 的列表：\n- 案例 1：$(a,b,n)=\\big(0,1,300\\big)$。\n- 案例 2：$(a,b,n)=\\big(0,1,3\\big)$。\n- 案例 3：$(a,b,n)=\\big(-1,1,300\\big)$。\n- 案例 4：$(a,b,n)=\\big(0,10^{-3},3\\big)$。\n- 案例 5：$(a,b,n)=\\big(0.5,0.5,3\\big)$。\n\n您的程序必须应用 Simpson $3/8$ 法则，使用绕 $x$ 轴旋转的旋转体体积的标准公式，来近似计算每个案例的体积。程序的最终输出必须为单行，其中包含一个 Python 风格的列表，内有按上述案例顺序排列的五个结果，每个结果都以科学记数法打印，小数点后恰好有 $12$ 位数字，并且没有附加文本。例如，输出格式必须类似单行\n[result1,result2,result3,result4,result5]\n其中每个结果都是一个以科学记数法格式化的浮点数，小数点后恰好有 $12$ 位数字（例如，$\\texttt{1.234000000000e+00}$），并且列表中没有空格。\n\n要求的最终输出类型是打印在单行上的包含 $5$ 个浮点数的列表，如上所述。程序不得打印任何其他内容。", "solution": "所给问题是使用一种特定的数值求积方法，即复合 Simpson $3/8$ 法则，来计算一个旋转体的体积。该问题定义明确、科学上合理且内部一致。我们将开始其形式化求解。\n\n由函数 $y = g(x)$ 定义的曲线在区间 $[a, b]$ 上绕 $x$ 轴旋转所生成的旋转体体积 $V$ 由以下定积分给出：\n$$ V = \\int_a^b \\pi [g(x)]^2 \\, dx $$\n在本题中，函数被指定为 $g(x) = \\mathrm{e}^{-x^{2}}$。将其代入体积公式，我们得到需要计算的积分为：\n$$ V = \\int_a^b \\pi \\left(\\mathrm{e}^{-x^{2}}\\right)^2 \\, dx = \\int_a^b \\pi \\mathrm{e}^{-2x^{2}} \\, dx $$\n该积分没有以初等函数表示的封闭形式解。因此，如题目规定，需要进行数值近似。问题要求使用复合 Simpson $3/8$ 法则。\n\n设被积函数记为 $f(x) = \\pi \\mathrm{e}^{-2x^{2}}$。我们的任务是近似计算积分 $I = \\int_a^b f(x) \\, dx$。\n复合 Simpson $3/8$ 法则是通过将积分区间 $[a, b]$ 划分成 $n$ 个等宽的子区间来推导的，其中 $n$ 必须是 $3$ 的正整数倍。每个子区间的宽度为 $h = \\frac{b-a}{n}$。该区间被点 $x_i = a + i h$（$i = 0, 1, 2, \\ldots, n$）所分割。\n\n复合辛普森 3/8 法则是通过对连续的三个子区间组应用基本 Simpson $3/8$ 法则并求和而形成的。在区间 $[x_k, x_{k+3}]$ 上的基本法则是：\n$$ \\int_{x_k}^{x_{k+3}} f(x) \\, dx \\approx \\frac{3h}{8} [f(x_k) + 3f(x_{k+1}) + 3f(x_{k+2}) + f(x_{k+3})] $$\n对从 $i=0$ 到 $n/3-1$ 的整个积分范围内的三子区间组 $[x_{3i}, x_{3i+3}]$ 的这些近似值求和，我们得到复合公式：\n$$ I = \\sum_{i=0}^{(n/3) - 1} \\int_{x_{3i}}^{x_{3i+3}} f(x) \\, dx \\approx \\sum_{i=0}^{(n/3) - 1} \\frac{3h}{8} [f(x_{3i}) + 3f(x_{3i+1}) + 3f(x_{3i+2}) + f(x_{3i+3})] $$\n对整个和式展开并合并同类项，得到复合 Simpson 3/8 法则的通用公式：\n$$ I \\approx \\frac{3h}{8} \\left[ f(x_0) + 3f(x_1) + 3f(x_2) + 2f(x_3) + 3f(x_4) + \\ldots + 3f(x_{n-1}) + f(x_n) \\right] $$\n系数的模式为 $\\{1, 3, 3, 2, 3, 3, 2, \\ldots, 2, 3, 3, 1\\}$。更正式地，积分近似值 $I_S$ 为：\n$$ I_S = \\frac{3h}{8} \\left( f(x_0) + f(x_n) + 2 \\sum_{j=1}^{n/3 - 1} f(x_{3j}) + 3 \\sum_{i \\in \\{1, \\dots, n-1\\}, i \\pmod 3 \\neq 0} f(x_i) \\right) $$\n对于括号内的和式，一种高效的算法表达是：\n$$ S = \\sum_{i=0}^{n} w_i f(x_i) $$\n其中权重 $w_i$ 定义为：\n$$ w_i = \\begin{cases} 1 & \\text{如果 } i=0 \\text{ 或 } i=n \\\\ 2 & \\text{如果 } i \\pmod 3 = 0 \\text{ 且 } 0 < i < n \\\\ 3 & \\text{如果 } i \\pmod 3 \\neq 0 \\text{ 且 } 0 < i < n \\end{cases} $$\n那么体积的最终近似值为 $V \\approx \\frac{3h}{8} S$。\n\n要实现的算法如下：\n1.  对于每个测试用例 $(a, b, n)$，计算步长 $h = \\frac{b-a}{n}$。注意，如果 $a = b$，则 $h = 0$，这将正确地得出体积 $V=0$。\n2.  生成从 $a$ 到 $b$（含两端）的 $n+1$ 个点 $x_i$ 的集合，即 $x_i = a + i h$，$i \\in \\{0, 1, \\dots, n\\}$。\n3.  定义被积函数 $f(x) = \\pi e^{-2x^2}$。\n4.  对所有点 $x_i$ 计算 $f(x_i)$ 的值。\n5.  使用如上定义的系数 $w_i$ 计算加权和 $S = \\sum_{i=0}^{n} w_i f(x_i)$。\n6.  计算最终的体积估计值 $V = \\frac{3h}{8} S$。\n此流程将应用于每个给定的测试用例。实现将使用向量运算以提高计算效率并减少索引错误的可能性。生成一个点数组 $x$，将函数 $f$ 按元素施加，根据规则构建一个权重数组 $w$，并通过权重和函数值的点积来计算结果，再乘以因子 $\\frac{3h}{8}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the volume of a solid of revolution using Simpson's 3/8 rule.\n    \"\"\"\n    # The problem specifies the function y = exp(-x^2) is rotated about the x-axis.\n    # The volume is given by the integral of pi * y^2.\n    # The integrand is therefore f(x) = pi * exp(-2*x^2).\n    integrand = lambda x: np.pi * np.exp(-2 * x**2)\n\n    # The test suite is given as a list of triples (a, b, n).\n    # a, b are integration limits, and n is the number of subintervals.\n    test_cases = [\n        (0.0, 1.0, 300),\n        (0.0, 1.0, 3),\n        (-1.0, 1.0, 300),\n        (0.0, 1.0e-3, 3),\n        (0.5, 0.5, 3),\n    ]\n\n    results = []\n    \n    # Process each test case.\n    for a, b, n in test_cases:\n        # The composite Simpson's 3/8 rule requires n to be a multiple of 3.\n        # This is satisfied by all test cases.\n\n        # Calculate the width of each subinterval.\n        # If a=b, h will be 0, correctly yielding a volume of 0 after multiplication.\n        h = (b - a) / n\n\n        # Generate the n+1 evaluation points for the interval [a, b].\n        x_points = np.linspace(a, b, n + 1)\n\n        # Evaluate the integrand at these points.\n        y_values = integrand(x_points)\n\n        # Construct the weight coefficients for Simpson's 3/8 rule.\n        # The pattern of weights is {1, 3, 3, 2, 3, 3, ..., 2, 3, 3, 1}.\n        weights = np.full(n + 1, 3.0)\n        weights[0] = 1.0\n        weights[-1] = 1.0\n        # For interior points with an index divisible by 3, the weight is 2.\n        # Slicing `weights[3:-1:3]` correctly targets these points for n > 3.\n        # For n=3, the slice is empty, so no change is made, which is correct.\n        weights[3:-1:3] = 2.0\n\n        # Compute the integral approximation by taking the dot product of weights\n        # and function values, then scaling by the rule's constant factor.\n        integral_approximation = (3 * h / 8) * np.dot(weights, y_values)\n        \n        results.append(integral_approximation)\n\n    # Final print statement in the exact required format.\n    # The format specifier \"{:.12e}\" ensures scientific notation with 12 digits\n    # after the decimal point.\n    output_string = \",\".join([f\"{res:.12e}\" for res in results])\n    print(f\"[{output_string}]\")\n\nsolve()\n```", "id": "2418036"}, {"introduction": "尽管固定步长的复合积分法则很强大，但它们可能会效率低下。这个练习将挑战你使用辛普森法则构建一个更智能的“自适应”积分器。你将实现一个递归算法，它能够自动在函数行为复杂的区域加密积分网格，从而以最小的计算成本达到指定的精度要求。[@problem_id:2417964]", "problem": "您的任务是实现一个基于三点闭式牛顿-柯特斯法则（辛普森法则）的自适应求积算法，用以近似计算定积分，并分析达到指定绝对容差所需的递归深度。您的实现必须是完全递归的，使用通过比较单区间近似与双子区间组合推导出的严格局部误差估计，并报告遇到的最大调用栈深度。所有三角函数的参数都应解释为弧度。\n\n基本原理：从定积分作为黎曼和极限的定义出发，并基于插值型求积法的原理：在区间 $[a,b]$ 上用一个穿过采样点的低阶多项式来近似函数 $f(x)$，然后对该多项式进行精确积分。使用三点闭式牛顿-柯特斯求积法，通过细分区间进行递归应用。通过比较在 $[a,b]$ 上的近似值与在 $[a,c]$ 和 $[c,b]$ (其中 $c=(a+b)/2$) 上的近似值之和，推导出一个终止准则，以保证返回的近似值的绝对误差不大于指定的容差 $\\,\\varepsilon\\,$。您必须设计递归过程，以传递已计算的函数值，从而避免重复计算。\n\n您的函数必须：\n- 接受一个函数 $f$、一个区间 $[a,b]$ 和一个绝对容差 $\\varepsilon>0$。\n- 基于在 $[a,b]$ 上的三点闭式牛顿-柯特斯公式以及在两个子区间 $[a,c]$ 和 $[c,b]$（其中 $c=(a+b)/2$）上的应用，使用递归自适应细化策略。\n- 使用通过比较在 $[a,b]$ 上的单区间近似和在 $[a,c]$ 与 $[c,b]$ 上的双子区间组合而获得的、有数学依据的局部误差估计，来决定是接受当前近似值还是进一步递归。\n- 以确保全局绝对误差不超过 $\\,\\varepsilon$ 的方式，在子问题之间分配容差。\n- 跟踪并返回最大调用栈深度。将顶层调用的深度定义为 $0$，每次递归调用时深度加 $1$。\n- 包含一个递归深度的硬性限制，以保证在最坏情况下的终止；如果达到此限制，则返回该分支上当前可用的最佳复合近似值。\n\n测试套件：\n实现您的程序以运行以下测试用例。对每个用例，计算近似积分值和遇到的最大递归深度。没有物理单位；仅报告无量纲的量。所有角度均以弧度为单位。\n\n- 测试 $1$：$f(x)=\\sin(x)$ 在 $[0,\\pi]$ 上，容差 $\\varepsilon=10^{-10}$。\n- 测试 $2$：$f(x)=\\exp(-x^2)$ 在 $[0,1]$ 上，容差 $\\varepsilon=10^{-8}$。\n- 测试 $3$：$f(x)=\\dfrac{1}{1+25x^2}$ 在 $[-1,1]$ 上，容差 $\\varepsilon=10^{-8}$。\n- 测试 $4$：$f(x)=x^8-x^4+1$ 在 $[0,1]$ 上，容差 $\\varepsilon=10^{-12}$。\n- 测试 $5$（边界尺度案例）：$f(x)=\\cos(x)$ 在 $[0,10^{-6}]$ 上，容差 $\\varepsilon=10^{-14}$。\n- 测试 $6$（局部特征）：$f(x)=\\exp\\!\\big(-100\\,(x-0.3)^2\\big)$ 在 $[0,1]$ 上，容差 $\\varepsilon=10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例对应一个双元素列表 $[I_{\\text{approx}},d_{\\max}]$，其中 $I_{\\text{approx}}$ 是积分的浮点近似值，$d_{\\max}$ 是最大递归深度的整数值。例如，整体输出必须类似于\n\"[[I1,d1],[I2,d2],[I3,d3],[I4,d4],[I5,d5],[I6,d6]]\"\n不含空格。请将 $I1,\\dots,I6$ 和 $d1,\\dots,d6$ 替换为您计算出的值。\n\n约束与说明：\n- 直接实现递归算法；不要依赖外部库中预构建的求积自适应功能。\n- 确保递归调用在共享节点上重用已评估的函数值，以避免重复计算。\n- 选择一个足够大的有限最大允许递归深度，以处理给定的容差，避免在典型的平滑情况下过早终止。", "solution": "该问题是有效的。它提出了计算物理学中一个明确定义的任务：实现并分析一个基于辛普森法则的自适应求积算法。该问题在科学上以数值积分和误差分析的原理为基础，内容自成体系，并提供了一套清晰客观的要求和测试用例。\n\n目标是在指定的绝对误差容差 $\\varepsilon$ 内近似计算定积分 $I = \\int_a^b f(x) dx$。所采用的方法是基于三点闭式牛顿-柯特斯公式的自适应求积，该公式通常被称为辛普森法则。\n\n首先，我们建立基本的求积法则。辛普森法则用一个二次多项式来近似被积函数 $f(x)$，该多项式在三个等距点上对 $f(x)$ 进行插值：端点 $a$ 和 $b$，以及中点 $c = (a+b)/2$。该多项式的积分为 $f(x)$ 的积分提供了一个近似值。对于单个区间 $[a, b]$ 的公式由下式给出：\n$$ S(a,b) = \\frac{b-a}{6}\\left[f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b)\\right] $$\n此近似的误差 $E = I - S(a,b)$，可通过泰勒级数展开证明为：\n$$ E(a,b) = -\\frac{(b-a)^5}{2880} f^{(4)}(\\xi) $$\n对于某个 $\\xi \\in (a,b)$。这表明辛普森法则对于最高为 3 次的多项式是精确的，因为对于此类多项式，其四阶导数 $f^{(4)}(x)$ 恒为零。\n\n为高效地达到全局误差容差 $\\varepsilon$，需要一种自适应策略。这涉及到在函数 $f(x)$ 变化更剧烈的区域将区间 $[a,b]$ 细分为更小的子区间，而在函数更平滑的区域使用较大的子区间。自适应算法的核心在于一个稳健的局部误差估计。\n\n为推导此估计，我们比较区间 $[a,b]$ 上积分的两种近似。第一种是粗略近似 $S_1$，通过在整个区间上应用一次辛普森法则获得：\n$$ S_1 = S(a,b) $$\n第二种是更精细的近似 $S_2$，通过在 $c=(a+b)/2$ 处将区间二等分，并将辛普森法则应用于每个子区间 $[a,c]$ 和 $[c,b]$ 的结果相加而获得：\n$$ S_2 = S(a,c) + S(c,b) $$\n设 $I$ 为在 $[a,b]$ 上的积分真值。$S_1$ 和 $S_2$ 的误差分别为 $E_1 = I - S_1$ 和 $E_2 = I - S_2$。如果我们假设四阶导数 $f^{(4)}(x)$ 在区间 $[a,b]$ 上近似为常数，我们就可以关联这两个误差。用于 $S_2$ 的子区间长度是 $S_1$ 的一半。辛普森法则的误差与区间长度的五次方成正比，因此 $S_2$ 的误差大约是 $S_1$ 误差的 $2 \\times (1/2)^5 = 1/16$。\n$$ E_2 \\approx \\frac{1}{16} E_1 $$\n现在我们可以使用可计算量 $S_1$ 和 $S_2$ 来估计误差：\n$$ I \\approx S_1 + E_1 \\approx S_1 + 16 E_2 $$\n$$ I \\approx S_2 + E_2 $$\n令这些关于 $I$ 的表达式相等，得到 $S_1 + 16 E_2 \\approx S_2 + E_2$，简化后为：\n$$ 15 E_2 \\approx S_2 - S_1 $$\n这为更精确的近似 $S_2$ 的误差提供了一个实用的估计：\n$$ |E_2| = |I - S_2| \\approx \\frac{|S_2 - S_1|}{15} $$\n\n递归算法按以下步骤进行。定义一个函数，用于在具有局部容差 $\\text{tol}$ 的区间 $[a,b]$ 上计算积分。\n1.  给定区间 $[a,b]$ 和预先计算的函数值 $f(a)$、$f(b)$ 和 $f(c)$（其中 $c=(a+b)/2$），计算粗略近似 $S_1$ 和精细近似 $S_2$。这需要两次新的函数求值，分别在 $[a,c]$ 和 $[c,b]$ 的中点处。为避免重复工作，所有已计算的函数值在递归中向下传递。\n2.  计算误差估计 $E_{\\text{est}} = |S_2 - S_1|/15$。\n3.  将误差估计与局部容差 $\\text{tol}$ 进行比较。如果 $E_{\\text{est}} \\le \\text{tol}$，则认为近似值 $S_2$ 对于此区间足够精确。返回（比 $S_1$ 更精确的）值 $S_2$，并且该分支上的递归终止。\n4.  如果 $E_{\\text{est}} > \\text{tol}$，则必须细化该区间。算法对两个子区间 $[a,c]$ 和 $[c,b]$ 进行递归调用。容差在两个递归调用之间分配，通常为每个调用分配 $\\text{tol}/2$ 的容差。这确保了子问题的误差总和保持在父问题的容差范围内。\n5.  将两次递归调用的结果相加，得到原始区间 $[a,b]$ 上的积分。\n6.  跟踪递归深度。初始调用深度为 $0$。每次递归调用使深度增加 $1$。函数不仅必须返回积分近似值，还必须返回其计算分支中达到的最大深度。最终的最大深度是所有分支中的最大值。\n7.  强制设置递归深度的硬性限制，以防止对于病态被积函数出现栈溢出。如果达到此限制，则返回当前最佳的近似值 ($S_2$)。\n\n这个过程保证了在整个积分域 $[a,b]$ 上的总绝对误差被控制在小于用户初始指定的容差 $\\varepsilon$ 的范围内，同时根据函数的局部行为自动调整计算量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adaptive_quadrature(f, a, b, tol, max_depth=50):\n    \"\"\"\n    Computes the definite integral of f from a to b using a recursive\n    adaptive Simpson's rule.\n\n    Args:\n        f (callable): The function to integrate.\n        a (float): The lower limit of integration.\n        b (float): The upper limit of integration.\n        tol (float): The desired absolute error tolerance.\n        max_depth (int): The maximum recursion depth.\n\n    Returns:\n        tuple[float, int]: A tuple containing the approximate integral and\n                           the maximum recursion depth reached.\n    \"\"\"\n    c = (a + b) / 2.0\n    fa = f(a)\n    fb = f(b)\n    fc = f(c)\n    integral, max_d = _adaptive_simpson_recursive(f, a, b, tol, 0, max_depth, fa, fb, fc)\n    return integral, max_d\n\ndef _adaptive_simpson_recursive(f, a, b, tol, depth, max_depth, fa, fb, fc):\n    \"\"\"\n    Recursive helper for adaptive Simpson's rule.\n    It reuses pre-computed function values fa=f(a), fb=f(b), fc=f((a+b)/2).\n    \"\"\"\n    h = b - a\n    c = (a + b) / 2.0\n    \n    # Coarse approximation S1 = S(a,b)\n    s1 = (h / 6.0) * (fa + 4.0 * fc + fb)\n\n    # Refined approximation S2 = S(a,c) + S(c,b)\n    d = (a + c) / 2.0\n    e = (c + b) / 2.0\n    fd = f(d)\n    fe = f(e)\n    \n    s_left = (h / 12.0) * (fa + 4.0 * fd + fc)\n    s_right = (h / 12.0) * (fc + 4.0 * fe + fb)\n    s2 = s_left + s_right\n\n    error_estimate = abs(s2 - s1) / 15.0\n\n    if depth >= max_depth:\n        # Depth limit reached, return best current estimate S2\n        return s2, depth\n\n    if error_estimate <= tol:\n        # Tolerance met, return S2 (more accurate)\n        return s2, depth\n\n    # Tolerance not met, recurse\n    next_depth = depth + 1\n    tol_sub = tol / 2.0\n    \n    left_integral, left_depth = _adaptive_simpson_recursive(f, a, c, tol_sub, next_depth, max_depth, fa, fc, fd)\n    right_integral, right_depth = _adaptive_simpson_recursive(f, c, b, tol_sub, next_depth, max_depth, fc, fb, fe)\n    \n    integral_sum = left_integral + right_integral\n    max_d = max(left_depth, right_depth)\n    \n    return integral_sum, max_d\n\n\ndef solve():\n    \"\"\"\n    Runs the adaptive quadrature algorithm on the defined test suite\n    and prints the results in the required format.\n    \"\"\"\n    \n    # Define test case functions\n    f1 = lambda x: np.sin(x)\n    f2 = lambda x: np.exp(-x**2)\n    f3 = lambda x: 1.0 / (1.0 + 25.0 * x**2)\n    f4 = lambda x: x**8 - x**4 + 1.0\n    f5 = lambda x: np.cos(x)\n    f6 = lambda x: np.exp(-100.0 * (x - 0.3)**2)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (f1, 0.0, np.pi, 1e-10),\n        (f2, 0.0, 1.0, 1e-8),\n        (f3, -1.0, 1.0, 1e-8),\n        (f4, 0.0, 1.0, 1e-12),\n        (f5, 0.0, 1e-6, 1e-14),\n        (f6, 0.0, 1.0, 1e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        f, a, b, tol = case\n        integral, max_depth = adaptive_quadrature(f, a, b, tol)\n        results.append([integral, max_depth])\n\n    # Format the results into the required string format \"[[I1,d1],[I2,d2],...]\"\n    formatted_results = [f\"[{i},{d}]\" for i, d in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2417964"}, {"introduction": "物理学中的许多积分都是“瑕积分”，其特点是在积分区间的端点处函数值趋于无穷，形成奇点。本实践将探讨如何使用开型牛顿-科特斯公式（如中点法则）来处理这种情况。与在端点求值的闭型公式不同，开型公式仅使用区间内部的点，从而巧妙地避开了奇点问题。[@problem_id:2418007]", "problem": "您需要编写一个完整、可运行的程序，该程序计算可能具有代数端点奇性的积分的复合开放 Newton–Cotes 求积近似值，并报告与已知解析值之间的绝对误差。对于区间 $[a,b]$ 上的可积函数 $f$ 和一个正整数 $N$，将基于0次插值（中点求积）的复合开放 Newton–Cotes 求积定义为\n$$\nQ_N[f;[a,b]] \\equiv h \\sum_{k=0}^{N-1} f\\!\\left(a + \\left(k+\\tfrac{1}{2}\\right)h\\right), \\quad h \\equiv \\frac{b-a}{N}.\n$$\n对于下方的每个测试用例，请计算近似值 $Q_N[f;[a,b]]$、精确积分\n$$\nI \\equiv \\int_a^b f(x)\\,dx,\n$$\n以及绝对误差 $E \\equiv \\lvert Q_N[f;[a,b]] - I \\rvert$。若涉及角度，则必须以弧度为单位。\n\n测试套件（每一项都指定了 $f(x)$、$[a,b]$、$N$ 和精确值 $I$）：\n- 用例1（边界最小分辨率）：$f(x)=x^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=1$，精确值 $I=2$。\n- 用例2（提高分辨率）：$f(x)=x^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=8$，精确值 $I=2$。\n- 用例3（单端点奇性下的大 $N$ 值）：$f(x)=x^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=1024$，精确值 $I=2$。\n- 用例4（右端点奇性）：$f(x)=(1-x)^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=64$，精确值 $I=2$。\n- 用例5（双端点奇性）：$f(x)=x^{-1/2}(1-x)^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=1024$，精确值 $I=\\pi$。\n- 用例6（强但可积的左端点奇性）：$f(x)=x^{-0.9}$ 在 $[a,b]=[0,1]$ 上，其中 $N=1000$，精确值 $I=10$。\n- 用例7（平滑基线，角度以弧度为单位）：$f(x)=\\sin(x)$ 在 $[a,b]=[0,\\pi]$ 上，其中 $N=100$，精确值 $I=2$。\n- 用例8（靠近奇异端点的极短区间）：$f(x)=x^{-1/2}$ 在 $[a,b]=[0,10^{-6}]$ 上，其中 $N=4$，精确值 $I=2\\sqrt{10^{-6}}$。\n\n您的程序必须按给定顺序计算上述用例的绝对误差 $E$，并生成一个单行输出，其中包含这些误差的列表，以方括号括起，并以逗号分隔。每个浮点数都应格式化为具有12位有效数字的科学记数法。例如，要求的格式为\n\"[1.23456789012e+00,3.40000000000e-05,...]\"。", "solution": "该问题陈述是计算物理和数值分析领域的一个有效练习。它要求实现并应用复合中点求积法则来近似定积分，其中包括几个涉及端点具有代数奇性的反常积分的用例。\n\n需要实现的求积法则是复合中点法则，这是一种0次的开放 Newton–Cotes 公式。对于区间 $[a,b]$ 上的一个给定可积函数 $f(x)$ 和 $N$ 个子区间，其近似值 $Q_N[f;[a,b]]$ 定义如下：\n$$\nQ_N[f;[a,b]] \\equiv h \\sum_{k=0}^{N-1} f\\!\\left(x_k\\right),\n$$\n其中步长为 $h = \\frac{b-a}{N}$，求值点 $x_k$ 是各子区间的中点，由下式给出：\n$$\nx_k = a + \\left(k+\\frac{1}{2}\\right)h, \\quad \\text{for} \\quad k \\in \\{0, 1, \\dots, N-1\\}.\n$$\n核心任务是计算绝对误差 $E = \\lvert Q_N[f;[a,b]] - I \\rvert$，其中 $I$ 是积分 $\\int_a^b f(x)\\,dx$ 的给定精确解析值。\n\n该问题的一个关键特征是存在具有端点奇性的被积函数，例如在 $[0,1]$ 上的 $f(x) = x^{-1/2}$ 或在 $[0,1]$ 上的 $f(x) = x^{-1/2}(1-x)^{-1/2}$。这些函数在一个或两个端点处的值不是有限的。复合中点法则是*开放*求积公式，意味着它不会在区间端点 $a$ 和 $b$ 处对被积函数求值。求值点集合 $\\{x_k\\}$ 严格包含在开区间 $(a,b)$ 内。第一个点是 $x_0 = a + \\frac{h}{2}$，最后一个点是 $x_{N-1} = b - \\frac{h}{2}$。这一性质至关重要，因为它确保了算法永远不会尝试在奇点处对函数求值，从而避免了除零错误和其他致命的计算问题。因此，该方法非常适合对此类反常积分进行数值近似，前提是这些积分是收敛的。测试套件中指定的所有积分确实都是收敛的。\n\n计算过程如下：\n$1$. 构建一个可重用函数来计算求积值 $Q_N[f;[a,b]]$。该函数接受被积函数 $f$、区间界限 $a$ 和 $b$ 以及子区间数量 $N$ 作为输入。\n$2$. 步长 $h$ 计算为 $(b-a)/N$。为保证数值稳定性，所有计算均使用双精度浮点算术（在 `numpy` 中为 `float64`）进行。\n$3$. 生成一个包含 $N$ 个求值点 $x_k$ 的向量。使用向量化操作（例如 `numpy` 库提供的操作）对于此任务非常高效。这些点通过公式 $a + (\\text{np.arange}(N) + 0.5) \\cdot h$ 生成。\n$4$. 在这个点向量上对被积函数 $f$ 求值，以生成一个函数值 $f(x_k)$ 的向量。\n$5$. 计算这些值的和，然后乘以 $h$，得到最终的近似值 $Q_N$。\n$6$. 对问题陈述中定义的八个测试用例中的每一个重复此过程。对于每个用例，使用相应的被积函数（表示为 `lambda` 函数）、区间、子区间数量和精确积分值。\n$7$. 对于每个用例，通过取数值近似值 $Q_N$ 与给定的精确值 $I$ 之间的绝对差来计算绝对误差 $E$。\n$8$. 然后，将生成的绝对误差列表按要求格式化为单个字符串。每个误差值都用科学记数法表示，并具有12位有效数字的精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes composite midpoint quadrature approximations for integrals\n    and calculates the absolute error against known analytic values.\n    \"\"\"\n\n    def midpoint_quadrature(f, a, b, N):\n        \"\"\"\n        Calculates the composite midpoint rule approximation for the integral of f from a to b.\n\n        Args:\n            f (callable): The integrand function.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            N (int): The number of subintervals.\n\n        Returns:\n            float: The numerical approximation of the integral.\n        \"\"\"\n        if N <= 0:\n            raise ValueError(\"Number of subintervals N must be positive.\")\n        \n        h = (b - a) / N\n        \n        # Generate the sequence of k values: 0, 1, ..., N-1\n        k = np.arange(N)\n        \n        # Calculate the midpoints of the N subintervals\n        x_k = a + (k + 0.5) * h\n        \n        # Evaluate the function at all midpoints in a vectorized manner\n        f_values = f(x_k)\n        \n        # Compute the sum and multiply by the subinterval width h\n        approximation = h * np.sum(f_values)\n        \n        return approximation\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (integrand_lambda, a, b, N, exact_I)\n    test_cases = [\n        # Case 1: boundary minimal resolution\n        (lambda x: x**(-0.5), 0.0, 1.0, 1, 2.0),\n        # Case 2: increased resolution\n        (lambda x: x**(-0.5), 0.0, 1.0, 8, 2.0),\n        # Case 3: large N on one-endpoint singularity\n        (lambda x: x**(-0.5), 0.0, 1.0, 1024, 2.0),\n        # Case 4: singularity at the right endpoint\n        (lambda x: (1.0 - x)**(-0.5), 0.0, 1.0, 64, 2.0),\n        # Case 5: singularities at both endpoints\n        (lambda x: x**(-0.5) * (1.0 - x)**(-0.5), 0.0, 1.0, 1024, np.pi),\n        # Case 6: strong but integrable left-endpoint singularity\n        (lambda x: x**(-0.9), 0.0, 1.0, 1000, 10.0),\n        # Case 7: smooth baseline, angles in radians\n        (lambda x: np.sin(x), 0.0, np.pi, 100, 2.0),\n        # Case 8: very short interval near a singular endpoint\n        (lambda x: x**(-0.5), 0.0, 1e-6, 4, 2.0 * np.sqrt(1e-6)),\n    ]\n\n    absolute_errors = []\n    for f_integrand, a_val, b_val, N_val, I_exact in test_cases:\n        # Calculate the numerical approximation Q_N\n        Q_N = midpoint_quadrature(f_integrand, a_val, b_val, N_val)\n        \n        # Compute the absolute error\n        error = np.abs(Q_N - I_exact)\n        absolute_errors.append(error)\n\n    # Format the results into the required output string.\n    # The format specifier \".12e\" ensures scientific notation with 12 digits after the decimal point, matching the example.\n    formatted_errors = [f\"{err:.12e}\" for err in absolute_errors]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_errors)}]\")\n\nsolve()\n```", "id": "2418007"}]}