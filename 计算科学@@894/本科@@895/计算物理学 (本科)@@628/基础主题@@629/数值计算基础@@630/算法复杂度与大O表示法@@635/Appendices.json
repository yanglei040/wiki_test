{"hands_on_practices": [{"introduction": "物理学中的许多问题，从星系演化到蛋白质折叠，都可以建模为 N 体问题。这个实践 [@problem_id:2372962] 将带你分析一个基础的 N 体模拟算法——蛙跳积分法（leapfrog integrator）的计算复杂度。通过分析计算每对粒子间相互作用力的“暴力”方法，你将亲身体会到为何直接模拟的计算成本会随着粒子数 $N$ 的增加而急剧增长，并理解为何开发更高效的算法（如树形码或粒子-网格方法）至关重要。", "problem": "一个分子动力学代码使用蛙跳积分器和对中心力来推进一个由$N$个质量为$m$的相同粒子组成的三维空间系统。一个大小为$\\Delta t$的完整时间步实现如下，其中粗体符号表示$\\mathbb{R}^{3}$中的向量，下标遍历所有粒子：\n\n- 半步踢：对于$i = 1,\\dots,N$，通过以下方式更新速度：\n$$\\mathbf{v}_{i} \\leftarrow \\mathbf{v}_{i} + \\frac{\\Delta t}{2}\\,\\mathbf{a}_{i}.$$\n\n- 漂移：对于$i = 1,\\dots,N$，通过以下方式更新位置：\n$$\\mathbf{x}_{i} \\leftarrow \\mathbf{x}_{i} + \\Delta t\\,\\mathbf{v}_{i}.$$\n\n- 重新计算加速度：\n  - 重置：对于$i = 1,\\dots,N$，设置\n  $$\\mathbf{a}_{i} \\leftarrow \\mathbf{0}.$$\n  - 对累加：对于$i = 1,\\dots,N-1$以及$j = i+1,\\dots,N$，计算相对位移\n  $$\\mathbf{r}_{ij} = \\mathbf{x}_{i} - \\mathbf{x}_{j},$$\n  计算形式为\n  $$\\mathbf{f}_{ij} = \\varphi\\!\\left(|\\mathbf{r}_{ij}|\\right)\\,\\mathbf{r}_{ij},$$\n  的对中心力，其中$\\varphi$是一个不依赖于$N$的固定函数，并累加\n  $$\\mathbf{a}_{i} \\leftarrow \\mathbf{a}_{i} + \\frac{\\mathbf{f}_{ij}}{m}, \\qquad \\mathbf{a}_{j} \\leftarrow \\mathbf{a}_{j} - \\frac{\\mathbf{f}_{ij}}{m}.$$\n\n- 半步踢：对于$i = 1,\\dots,N$，通过以下方式更新速度：\n$$\\mathbf{v}_{i} \\leftarrow \\mathbf{v}_{i} + \\frac{\\Delta t}{2}\\,\\mathbf{a}_{i}.$$\n\n假设：\n- 空间维度$d=3$是固定的，不随$N$变化。\n- 对于单个粒子对$(i,j)$，计算$\\varphi\\!\\left(|\\mathbf{r}_{ij}|\\right)$、形成$\\mathbf{f}_{ij}$以及应用两个加速度更新所需算术运算的次数为常数（不依赖于$N$），且使用的额外内存量也为常数。\n- 不存在邻居列表、截断、区域分解或其他改变渐进对计数的数据结构。\n- 所有算术运算都在常数时间内完成，循环开销与迭代次数呈线性关系。\n- 积分器存储数组$\\{\\mathbf{x}_{i}\\}_{i=1}^{N}$、$\\{\\mathbf{v}_{i}\\}_{i=1}^{N}$和$\\{\\mathbf{a}_{i}\\}_{i=1}^{N}$；除常数大小的参数和循环下标外，不计算任何其他数据。\n\n根据算法时间复杂度和空间复杂度的定义，确定单个时间步的总时间复杂度和上述积分器状态的总空间复杂度，结果表示为$N$的函数并使用大O表示法。将最终答案以一个包含两个元素的行矩阵形式给出，第一个元素是时间复杂度，第二个元素是空间复杂度，每个都表示为单个大O表达式。", "solution": "首先验证问题陈述的正确性和可解性。\n\n**第1步：提取已知条件**\n- 系统：$N$个质量为$m$的相同粒子，位于三维空间中。\n- 算法：大小为$\\Delta t$的蛙跳积分器的单个时间步。\n  - 第1步：半步踢速度更新：对于$i = 1,\\dots,N$，$\\mathbf{v}_{i} \\leftarrow \\mathbf{v}_{i} + \\frac{\\Delta t}{2}\\,\\mathbf{a}_{i}$。\n  - 第2步：漂移位置更新：对于$i = 1,\\dots,N$，$\\mathbf{x}_{i} \\leftarrow \\mathbf{x}_{i} + \\Delta t\\,\\mathbf{v}_{i}$。\n  - 第3步：重新计算加速度$\\mathbf{a}_i$。这包括将所有$\\mathbf{a}_i$重置为$\\mathbf{0}$，然后对所有$i<j$的唯一粒子对$(i,j)$进行对力累加。力为$\\mathbf{f}_{ij} = \\varphi(|\\mathbf{r}_{ij}|)\\,\\mathbf{r}_{ij}$，更新方式为$\\mathbf{a}_{i} \\leftarrow \\mathbf{a}_{i} + \\frac{\\mathbf{f}_{ij}}{m}$和$\\mathbf{a}_{j} \\leftarrow \\mathbf{a}_{j} - \\frac{\\mathbf{f}_{ij}}{m}$。\n  - 第4步：第二次半步踢速度更新，与第1步相同。\n- 假设：\n  - 空间维度$d=3$是固定常数。\n  - 单个粒子对的力计算和累加的计算工作量为$O(1)$（常数时间）。\n  - 不使用邻居列表等算法优化；检查所有粒子对。\n  - 算术运算为$O(1)$；循环开销与迭代次数呈线性关系。\n- 空间复杂度的数据存储：位置数组$\\{\\mathbf{x}_{i}\\}_{i=1}^{N}$、速度数组$\\{\\mathbf{v}_{i}\\}_{i=1}^{N}$和加速度数组$\\{\\mathbf{a}_{i}\\}_{i=1}^{N}$。\n\n**第2步：验证**\n该问题描述了一个标准的暴力N体模拟，使用的是速度Verlet算法，这是蛙跳积分器的一种常见变体。该场景在经典力学和计算物理学中有科学依据。问题是良定的，提供了清晰的算法和足够的假设来进行明确的复杂度分析。所有术语都已定义，前提条件是一致的。不存在伪科学、主观性或逻辑矛盾的元素。\n\n**第3步：结论**\n问题被认为是有效的。将构建一个解决方案。\n\n**时间复杂度分析**\n\n一个完整时间步的总时间复杂度是其各组成部分复杂度之和。我们将每个部分作为粒子数$N$的函数进行分析。\n\n1.  **第一个半步踢**：这一步包括一个从$i=1$到$N$的迭代循环。在循环内部，速度向量$\\mathbf{v}_{i}$被更新。由于空间维度固定为3，此向量操作涉及常数数量的浮点运算（一次标量-向量乘法和一次向量加法）。因此，循环内部的工作量是$O(1)$。此步骤的总时间复杂度是迭代次数乘以每次迭代的工作量，即$N \\times O(1) = O(N)$。\n\n2.  **漂移**：这一步的结构与第一步相同。一个循环从$i=1$到$N$，在循环内部更新位置向量$\\mathbf{x}_{i}$。对于固定维度的向量，这也是一个常数时间操作。因此，总时间复杂度为$N \\times O(1) = O(N)$。\n\n3.  **重新计算加速度**：这部分由两个子步骤组成。\n    -   **重置**：所有$N$个粒子的加速度都被设置为零向量，$\\mathbf{a}_{i} \\leftarrow \\mathbf{0}$。这是在一个从$i=1$到$N$的循环中完成的。对每个粒子来说，该操作是常数时间的。此子步骤的复杂度是$O(N)$。\n    -   **对累加**：这是计算上占主导地位的部分。算法指定了一个双重循环：`for i = 1,...,N-1`和`for j = i+1,...,N`。这个结构遍历所有唯一的粒子对$(i,j)$。此类对的总数由以下总和给出：\n    $$ \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} 1 = \\sum_{i=1}^{N-1} (N - i) = (N-1) + (N-2) + \\dots + 1 = \\frac{(N-1)N}{2} $$\n    对的数量为$\\frac{1}{2}N^2 - \\frac{1}{2}N$。对于每一对，算法计算相对位移$\\mathbf{r}_{ij}$，计算力$\\mathbf{f}_{ij}$，并更新两个加速度向量$\\mathbf{a}_i$和$\\mathbf{a}_j$。根据问题的假设，对单个粒子对的所有这些操作都花费常数时间，即$O(1)$。因此，这个子步骤的总时间复杂度是粒子对数量乘以每对的常数工作量：$(\\frac{1}{2}N^2 - \\frac{1}{2}N) \\times O(1) = O(N^2)$。\n    重新计算加速度的总复杂度是其子步骤的复杂度之和：$O(N) + O(N^2) = O(N^2)$。\n\n4.  **第二次半步踢**：这一步与第一个半步踢相同，涉及一个遍历$N$个粒子的循环，内部工作量为$O(1)$。其复杂度为$O(N)$。\n\n**总时间复杂度**：每个时间步的总时间复杂度$T(N)$是所有四个步骤的复杂度之和：\n$$ T(N) = O(N) + O(N) + O(N^2) + O(N) $$\n在大O表示法中，我们只保留最高阶项。因此，总时间复杂度为$O(N^2)$。\n\n**空间复杂度分析**\n\n空间复杂度由存储系统状态所需的内存量决定，如问题中所规定。\n\n-   **位置数据**：数组$\\{\\mathbf{x}_{i}\\}_{i=1}^{N}$存储了$N$个粒子的位置。每个位置$\\mathbf{x}_i$是$\\mathbb{R}^3$中的一个向量，需要存储3个数字（例如，双精度浮点数）。存储一个粒子位置所需的内存是恒定的。因此，所有位置所需的总内存与$N$成正比，即$O(N)$。\n\n-   **速度数据**：同样，数组$\\{\\mathbf{v}_{i}\\}_{i=1}^{N}$存储了$N$个粒子的速度。每个速度$\\mathbf{v}_i$也是一个三维向量，因此所需的总存储空间为$O(N)$。\n\n-   **加速度数据**：数组$\\{\\mathbf{a}_{i}\\}_{i=1}^{N}$存储了$N$个粒子的加速度。每个加速度$\\mathbf{a}_i$也是一个三维向量，因此所需的存储空间也为$O(N)$。\n\n**总空间复杂度**：总空间复杂度$S(N)$是这三个数组的内存需求之和。问题规定不计算其他数据，如常数大小的参数。\n$$ S(N) = O(N) + O(N) + O(N) = O(N) $$\n因此，积分器状态的总空间复杂度为$O(N)$。\n\n总而言之，时间复杂度由对力计算主导，随粒子数呈平方级增长，而空间复杂度呈线性增长，因为我们必须存储每个粒子的状态信息。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nO(N^2) & O(N)\n\\end{pmatrix}\n}\n$$", "id": "2372962"}, {"introduction": "从 N 体模拟的离散世界转向连续介质物理学，我们经常需要求解偏微分方程（PDEs）。这个练习 [@problem_id:2373011] 聚焦于一个经典的例子：使用显式有限差分法求解二维热传导方程。这个问题的核心在于揭示算法的数值稳定性条件如何深刻影响总计算成本，它将时间步长 $\\Delta t$ 与空间网格大小 $\\Delta x$ 紧密联系在一起（$\\Delta t \\propto (\\Delta x)^2$）。通过这个分析，你将理解为何对于某些问题，选择数值方法不仅仅是精度问题，更是关乎计算可行性的战略决策。", "problem": "考虑在方形域 $[0,L]\\times[0,L]$ 上对二维热传导方程进行显式有限差分时间积分，直到一个固定的最终时间 $T$。该域在均匀的笛卡尔网格上进行离散，每个空间方向上有 $M$ 个内部点，因此网格间距为 $\\Delta x = L/(M+1)$。令 $N = M^{2}$ 表示内部未知数的总数。假设在每个时间步中，算法会更新所有内部网格点，并且每次网格点更新需要恒定数量 $c_{\\mathrm{op}}$ 的浮点运算 (FLOP)，该数量与 $M$ 无关。该显式方案使用的时间步长受到稳定性的限制，为 $\\Delta t = \\kappa (\\Delta x)^{2}$，其中 $\\kappa>0$ 是一个不依赖于 $M$、$N$、$L$ 或 $T$ 的常数。\n\n仅使用这些假设，确定当 $M\\to\\infty$ 时，达到时间 $T$ 所需的 FLOP 的渐近总数，并将您的最终结果表示为仅含 $N$ 的单一 大$O$ 表达式。提供一个无单位的单一解析表达式作为最终答案。", "solution": "题目要求确定将二维热传导方程积分到固定时间 $T$ 所需的渐近总计算成本，该成本以浮点运算 (FLOP) 为单位。分析必须基于为显式有限差分方案提供的假设。\n\n首先，我们来形式化 FLOP 的总数，记为 $F_{\\text{total}}$。该总成本是达到最终时间 $T$ 所需的每时间步计算成本 $F_{\\text{step}}$ 与总时间步数 $K_{\\text{steps}}$ 的乘积。\n$$F_{\\text{total}} = F_{\\text{step}} \\times K_{\\text{steps}}$$\n\n题目陈述，在每个时间步，算法会更新所有内部网格点。内部网格点的总数给定为 $N$。更新单个网格点的成本是一个常数 $c_{\\mathrm{op}}$，它不依赖于网格大小。因此，每时间步的成本与被更新的点的数量成正比：\n$$F_{\\text{step}} = c_{\\mathrm{op}} N$$\n这意味着每步的成本为 $O(N)$ 量级。\n\n接下来，我们必须确定时间步数 $K_{\\text{steps}}$。模拟运行总时长为 $T$，每步时间前进 $\\Delta t$。因此，\n$$K_{\\text{steps}} = \\frac{T}{\\Delta t}$$\n\n分析的关键部分在于理解时间步长 $\\Delta t$ 的缩放规律。题目规定，对于这种显式方案，时间步长受到稳定性条件的限制：\n$$\\Delta t = \\kappa (\\Delta x)^2$$\n其中 $\\kappa > 0$ 是一个与离散化参数无关的常数，而 $\\Delta x$ 是网格间距。\n\n该域是一个边长为 $L$ 的正方形，在每个维度上用 $M$ 个内部点进行离散。这给出的网格间距为：\n$$\\Delta x = \\frac{L}{M+1}$$\n内部未知数的总数 $N$ 与 $M$ 的关系为 $N = M^2$。由此，对于 $M \\ge 0$，我们可以将 $M$ 表示为 $N$ 的函数，即 $M = \\sqrt{N}$。将此代入 $\\Delta x$ 的表达式中：\n$$\\Delta x = \\frac{L}{\\sqrt{N}+1}$$\n\n现在，我们可以将时间步长 $\\Delta t$ 表示为 $N$ 的函数：\n$$\\Delta t = \\kappa \\left( \\frac{L}{\\sqrt{N}+1} \\right)^2 = \\frac{\\kappa L^2}{(\\sqrt{N}+1)^2}$$\n\n利用这个 $\\Delta t$ 的表达式，总时间步数变为：\n$$K_{\\text{steps}} = \\frac{T}{\\Delta t} = \\frac{T (\\sqrt{N}+1)^2}{\\kappa L^2}$$\n\n我们感兴趣的是当 $M \\to \\infty$（对应于 $N \\to \\infty$）时的渐近行为。对于大的 $N$，项 $(\\sqrt{N}+1)^2$ 的行为类似于 $N$。更正式地说：\n$$(\\sqrt{N}+1)^2 = N + 2\\sqrt{N} + 1$$\n当 $N \\to \\infty$ 时，主导项是 $N$。因此，$K_{\\text{steps}}$ 渐近地与 $N$ 成正比：\n$$K_{\\text{steps}} = \\frac{T}{\\kappa L^2} (N + 2\\sqrt{N} + 1) = O(N)$$\n\n最后，我们可以结合 $F_{\\text{step}}$ 和 $K_{\\text{steps}}$ 的结果来求得总计算成本 $F_{\\text{total}}$：\n$$F_{\\text{total}} = F_{\\text{step}} \\times K_{\\text{steps}} = (c_{\\mathrm{op}} N) \\times \\left( \\frac{T (\\sqrt{N}+1)^2}{\\kappa L^2} \\right)$$\n我们将所有不依赖于 $N$ 的常数收集到一个单独的项中，即 $C = \\frac{c_{\\text{op}} T}{\\kappa L^2}$。\n$$F_{\\text{total}} = C \\cdot N \\cdot (\\sqrt{N}+1)^2 = C \\cdot N (N + 2\\sqrt{N} + 1) = C (N^2 + 2N^{3/2} + N)$$\n为了使用大$O$表示法，我们找出当 $N \\to \\infty$ 时 $F_{\\text{total}}$ 表达式中 $N$ 的最高次幂。多项式 $N^2 + 2N^{3/2} + N$ 中的主导项是 $N^2$。\n因此，FLOP 的渐近总数由下式给出：\n$$F_{\\text{total}} = O(N^2)$$\n此结果表明，用于二维热传导方程的显式方法的计算复杂度与未知数的数量成二次方关系。这是由稳定性准则施加的严格时间步长限制所导致的结果，该限制是抛物线型问题显式方法的一个特征。", "answer": "$$\n\\boxed{O(N^2)}\n$$", "id": "2373011"}, {"introduction": "在掌握了如何分析给定算法的复杂度后，让我们进入一个更深层次的挑战：预测并构造特定输入来引发算法的极端行为。排序是计算物理中许多预处理步骤（如建立近邻列表）的关键环节，而快速排序（Quicksort）是常用算法之一。这个实践 [@problem_id:2372995] 要求你设计特定的粒子分布，以触发快速排序算法的“最坏情况”——$O(N^2)$ 的时间复杂度，而不是其平均情况下的 $O(N \\log N)$。完成这个练习将让你对算法性能与输入数据结构之间的微妙关系有更直观和深刻的认识。", "problem": "您将处理一个形式化的空间排序任务，该任务出现在计算物理学中，用于为邻近搜索等局部性敏感操作排布粒子数据。考虑三维空间中的一个包含 $N$ 个粒子的集合，其位置为 $\\mathbf{r}_i = (x_i,y_i,z_i) \\in \\mathbb{R}^3$。每个粒子都映射到一个空间键 $K(\\mathbf{r}_i) = (x_i,y_i,z_i)$，这些键按字典序进行全序排列：对于任意的 $\\mathbf{a} = (x_a,y_a,z_a)$ 和 $\\mathbf{b} = (x_b,y_b,z_b)$，我们定义 $K(\\mathbf{a}) \\le K(\\mathbf{b})$ 当且仅当 $x_a < x_b$，或 $x_a = x_b$ 且 $y_a < y_b$，或 $x_a = x_b$、$y_a = y_b$ 且 $z_a \\le z_b$。\n\n定义一种排序算法，该算法对一个空间键数组 $A$ 进行操作，并使用确定性快速排序（采用 Lomuto 分区方案且以最后一个元素为主元）按非递减字典序对其进行排序。对于子数组 $A[\\ell..r]$，分区过程设置主元 $p = A[r]$，初始化 $i = \\ell - 1$，然后对于从 $\\ell$ 到 $r-1$ 的每个 $j$，执行一次形式为 $A[j] \\le p$ 的键比较；如果比较结果为真，则将 $i$ 递增并交换 $A[i]$ 和 $A[j]$。循环结束后，交换 $A[i+1]$ 和 $A[r]$，并返回主元索引 $i+1$。当 $\\ell < r$ 时，快速排序接着对 $A[\\ell..i]$ 和 $A[i+2..r]$ 进行递归。一次“键比较”精确地定义为在分区循环内部对形如 $K(\\cdot) \\le K(\\cdot)$ 的关系进行一次求值；不计算任何其他操作。\n\n您的任务是为下方的每个测试用例设计一个具体的粒子分布（即一个遵循所述约束的位置 $\\mathbf{r}_i$ 的有序列表），当上述排序算法应用于您的粒子的空间键时，该分布会触发算法的 $O(N^2)$ 最坏情况行为。对于每个测试用例，您必须接着将定义的算法应用于您构建的分布，并报告在整个排序过程中执行的键比较的确切数量。\n\n测试套件（每个用例都指定了 $N$ 和一个对允许的粒子坐标的约束）：\n\n- 用例 1：$N = 1$。约束：位置 $\\mathbf{r}_i$ 可以是任意实值三元组；无额外限制。\n- 用例 2：$N = 2$。约束：空间键 $K(\\mathbf{r}_i)$ 必须两两不同。\n- 用例 3：$N = 10$。约束：空间键 $K(\\mathbf{r}_i)$ 必须两两不同，并且对于所有的 $i$ 都满足 $y_i = 0$ 和 $z_i = 0$，其中 $x_i \\in \\{0,1,2,3,4,5,6,7,8,9\\}$。\n- 用例 4：$N = 10$。约束：所有空间键都相同，即 $K(\\mathbf{r}_1) = K(\\mathbf{r}_2) = \\dots = K(\\mathbf{r}_{10})$。\n- 用例 5：$N = 9$。约束：对于所有的 $i$，$x_i = 0$ 且 $z_i = 0$，而 $y_i$ 是两两不同的实数。\n\n对于每个用例，构建一个在指定算法下能达到最坏情况行为的有效粒子分布，并计算快速排序执行的键比较的总确切数量。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），$r_k$ 是用例 $k$（按 $k = 1,2,3,4,5$ 的顺序）的键比较次数的整数值。", "solution": "该任务旨在确定一个特定实现的快速排序算法的最大键比较次数，并构建能够触发此最坏情况行为的输入。该算法是确定性快速排序，使用最后一个元素作为主元和Lomuto分区方案。一次“键比较”被定义为在分区循环内对 $A[j] \\le p$ 进行一次求值。\n\n快速排序的最坏情况时间复杂度为 $O(N^2)$，它发生在分区过程持续产生最不平衡的划分时。对于一个大小为 $n$ 的子数组，Lomuto分区过程恰好执行 $n-1$ 次键比较。一次最大程度不平衡的划分会将大小为 $n$ 的数组划分为一个大小为 $n-1$ 的子问题和一个大小为 $0$ 的子问题。如果这种情况在每个递归步骤中都发生，那么对于一个初始大小为 $N$ 的数组，总比较次数（记为 $C(N)$）遵循以下递推关系：\n$$\nC(n) = (n-1) + C(n-1)\n$$\n递归的基本情况是 $C(1) = 0$，因为不满足递归条件 $\\ell < r$。展开这个递推式得到：\n$$\nC(N) = (N-1) + (N-2) + \\dots + C(1) = \\sum_{k=1}^{N-1} k = \\frac{(N-1)N}{2}\n$$\n这就是最大键比较次数的公式。\n\n我们的目标是为每个测试用例构建一个初始空间键数组，以确保在每一步都发生这种最坏情况的划分。对于 Lomuto 分区，当主元 $p = A[r]$ 是子数组 $A[\\ell..r]$ 中的最小或最大元素时，会实现最坏情况的划分。这是因为所有其他元素都将被放置在主元最终位置的一侧。为每个递归调用保证此条件的一个简单方法是提供一个已经排序的初始数组（按非递减或非递增字典序）。\n\n让我们以一个非递减有序数组为例来分析。初始主元是 $A[N-1]$，即最大元素。在 `partition` 函数中，对于所有从 $0$ 到 $N-2$ 的 $j$，比较 $A[j] \\le p$ 的结果都为真。这导致 $N-1$ 次比较。分区将主元放置在索引 $N-1$ 处，从而导致对子数组 $A[0..N-2]$ 进行递归调用，而该子数组本身也是有序的。这种模式会重复，从而产生最坏情况的比较次数。对于所有元素都相同的数组（因为条件 $A[j] \\le p$ 始终为真）以及逆序数组（主元始终是最小值），类似的分析也成立。\n\n我们现在将这个原理应用于每个测试用例。\n\n**用例 1**：$N=1$\n输入是一个大小为 1 的数组。对 `quicksort(A, 0, 0)` 的初始调用不满足条件 $\\ell < r$（因为 $0 \\not< 0$）。因此，不发生分区，也不进行任何比较。\n一个有效的粒子分布是 $\\mathbf{r}_1 = (0,0,0)$。\n比较次数：$C(1) = \\frac{1(0)}{2} = 0$。\n\n**用例 2**：$N=2$\n约束是键必须两两不同。为了触发最坏情况，我们构建一个有序的键数组。例如：$\\mathbf{r}_1 = (0,0,0)$ 和 $\\mathbf{r}_2 = (1,0,0)$。对应的键是 $K_1=(0,0,0)$ 和 $K_2=(1,0,0)$，它们是按字典序排序的。\n比较次数：$C(2) = \\frac{2(1)}{2} = 1$。\n\n**用例 3**：$N=10$\n约束是 $y_i=0$，$z_i=0$，且 $x_i \\in \\{0,1,2,3,4,5,6,7,8,9\\}$ 两两不同。字典序完全由 $x_i$ 坐标决定。我们构建一个有序分布：$\\mathbf{r}_i = (i-1, 0, 0)$，其中 $i=1, \\dots, 10$。这会得到一个有序的键数组 $A = [(0,0,0), (1,0,0), \\dots, (9,0,0)]$。\n比较次数：$C(10) = \\frac{10(9)}{2} = 45$。\n\n**用例 4**：$N=10$\n约束是所有键都相同。例如，对于所有 $i=1, ..., 10$，$\\mathbf{r}_i = (0,0,0)$。输入数组由 10 个相同的键组成。如前所述，当对所有元素都相同的子数组 $A[\\ell..r]$ 进行分区时，主元 $p=A[r]$ 等于所有其他元素。比较 $A[j] \\le p$ 的结果始终为真。这导致与有序数组相同的最大程度不平衡的划分。\n比较次数：$C(10) = \\frac{10(9)}{2} = 45$。\n\n**用例 5**：$N=9$\n约束是 $x_i=0$，$z_i=0$，且 $y_i$ 坐标两两不同。字典序完全由 $y_i$ 坐标决定。我们构建一个有序分布：$\\mathbf{r}_i = (0, i-1, 0)$，其中 $i=1, \\dots, 9$。这会得到一个有序的键数组 $A = [(0,0,0), (0,1,0), \\dots, (0,8,0)]$。\n比较次数：$C(9) = \\frac{9(8)}{2} = 36$。\n\n最终结果是为每个用例计算出的比较次数：$[0, 1, 45, 45, 36]$。以下程序实现了指定的算法，并在构建的最坏情况输入上验证了这些计数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\nclass QuickSortAnalyzer:\n    \"\"\"\n    A class to encapsulate the specified Quicksort algorithm and count key comparisons.\n    \"\"\"\n    def __init__(self):\n        self.comparisons = 0\n\n    def _compare_keys(self, key1, key2):\n        \"\"\"\n        Performs a single lexicographical comparison and increments the counter.\n        Python's tuple comparison is lexicographical, matching the problem's definition.\n        K(a) <= K(b) <=> (xa,ya,za) <= (xb,yb,zb)\n        \"\"\"\n        self.comparisons += 1\n        return key1 <= key2\n\n    def _partition(self, arr, low, high):\n        \"\"\"\n        Lomuto partition scheme using the last element as pivot.\n        \"\"\"\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if self._compare_keys(arr[j], pivot):\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        \n        # Place pivot in its final sorted position\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def _quicksort(self, arr, low, high):\n        \"\"\"\n        Recursive Quicksort algorithm as defined in the problem.\n        \"\"\"\n        if low < high:\n            # pi is the partitioning index, arr[pi] is now at the right place.\n            pi = self._partition(arr, low, high)\n\n            # Recursively sort elements before and after partition\n            self._quicksort(arr, low, pi - 1)\n            self._quicksort(arr, pi + 1, high)\n\n    def run_and_count(self, particle_distribution):\n        \"\"\"\n        Runs the Quicksort on a given particle distribution and returns the comparison count.\n        \"\"\"\n        self.comparisons = 0\n        keys = list(particle_distribution) # Make a mutable copy\n        n = len(keys)\n        if n > 0:\n            self._quicksort(keys, 0, n - 1)\n        return self.comparisons\n\ndef solve():\n    \"\"\"\n    Main function to construct test cases and compute the results.\n    \"\"\"\n    \n    # Each test case is a list of particle positions (tuples) constructed to\n    # trigger the worst-case behavior of the specified Quicksort algorithm,\n    # while adhering to the problem's constraints. The worst-case is triggered\n    # by inputs that are already sorted, reverse-sorted, or have all equal elements.\n    \n    test_cases = [\n        # Case 1: N = 1. Trivial case. sorted.\n        [(0.0, 0.0, 0.0)],\n        \n        # Case 2: N = 2. Pairwise distinct keys. Constructed as sorted.\n        [(0.0, 0.0, 0.0), (1.0, 0.0, 0.0)],\n        \n        # Case 3: N = 10. Distinct keys with y_i=z_i=0, x_i in {0..9}. Constructed as sorted.\n        [(float(i), 0.0, 0.0) for i in range(10)],\n        \n        # Case 4: N = 10. All keys identical. This also triggers the worst-case.\n        [(0.0, 0.0, 0.0)] * 10,\n        \n        # Case 5: N = 9. Distinct keys with x_i=z_i=0. Constructed by sorting y_i.\n        [(0.0, float(i), 0.0) for i in range(9)]\n    ]\n\n    analyzer = QuickSortAnalyzer()\n    results = []\n    \n    for case_data in test_cases:\n        count = analyzer.run_and_count(case_data)\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372995"}]}