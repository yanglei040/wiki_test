{"hands_on_practices": [{"introduction": "本节的第一个实践练习将带您直面浮点数算术中最基本也最令人意外的一个问题。通过一个看似简单的循环任务，您将亲手验证为何使用浮点数进行精确相等性判断 (例如 $x == 1.0$) 往往是不可靠的，甚至会导致程序失败。这个练习旨在帮助您建立对二进制表示误差的直观理解，并认识到在编写数值代码时必须谨慎处理浮点数的比较。[@problem_id:2447428]", "problem": "给定实标量 $s$、$h$ 和 $t$，以及一个正整数 $M$。考虑由 $x_0 = s$ 和 $x_{n+1} = x_n + h$（对于 $n \\ge 0$）定义的序列 $\\{x_n\\}_{n\\ge 0}$。当 $x_n$ 使用二进制浮点运算进行计算时，由于表示和舍入效应，检查 $x_n = t$ 是否成立的简单终止条件可能不可靠。您的任务是编写一个程序，该程序对每个提供的测试用例模拟浮点序列，并报告在有界模拟迭代次数内，等式 $x_n = t$ 是否曾经成立。\n\n对于每个测试用例，执行以下步骤：\n1. 在双精度浮点运算中初始化 $x_0 = s$。\n2. 对于 $n = 0,1,2,\\dots$，在浮点运算中精确检查 $x_n = t$ 是否成立。如果对于某个 $n \\le M$ 等式成立，记录满足条件的最小 $n$ 值，并终止该测试用例的模拟。\n3. 如果对于 $0 \\le n \\le M$ 均未出现等式，则在 $M$ 次增量后终止模拟。\n4. 设 $n_{\\mathrm{exec}}$ 表示您的模拟对该测试用例实际执行的增量次数，其中如果观察到等式成立，$n_{\\mathrm{exec}}$ 等于最小的 $n$ 值（若有），否则为 $M$。\n5. 使用精确实数算术计算理论精确值 $x_{\\mathrm{exact}} = s + n_{\\mathrm{exec}}\\,h$，在中间步骤不使用浮点舍入。\n6. 设 $x_{\\mathrm{float}}$ 表示您的模拟在 $n_{\\mathrm{exec}}$ 次增量后获得的浮点值。计算绝对误差 $e = |x_{\\mathrm{float}} - x_{\\mathrm{exact}}|$（作为一个实数）。\n\n对于每个测试用例，您的程序必须按顺序输出一个包含以下字段的列表：\n- 一个布尔值，表示是否存在 $n \\in \\{0,1,\\dots,M\\}$ 使得在浮点运算中 $x_n = t$。\n- 满足条件的最小 $n$ 值（如果存在）；否则为整数 $-1$。\n- 整数 $n_{\\mathrm{exec}}$。\n- $n_{\\mathrm{exec}}$ 次增量后的浮点值 $x_{\\mathrm{float}}$。\n- 理论精确值 $x_{\\mathrm{exact}}$，转换为浮点数以供报告。\n- 绝对误差 $e$，作为浮点数。\n\n使用以下五个测试用例。在所有测试用例中，均不涉及角度，也没有物理单位。以十进制书写的实数（例如 $0.1$）表示以十为基的精确实数值，而涉及 2 的幂的表达式（例如 $2^{-55}$）也表示精确实数值。\n\n- 测试用例 1（使用十进制步长的典型相等性判断失败案例）：\n  $s = 0.0$, $h = 0.1$, $t = 1.0$, $M = 12$。\n- 测试用例 2（步长可精确表示且目标可达）：\n  $s = 0.0$, $h = 0.125$, $t = 1.0$, $M = 8$。\n- 测试用例 3（步长不能整除区间）：\n  $s = 0.0$, $h = 0.3$, $t = 1.0$, $M = 10$。\n- 测试用例 4（使用十进制步长向零负向步进）：\n  $s = 1.0$, $h = -0.1$, $t = 0.0$, $M = 12$。\n- 测试用例 5（增量小于一个末位单位直至累积）：\n  $s = 1.0$, $h = 2^{-55}$, $t = 1 + 2^{-52}$, $M = 8$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应一个测试用例的列表，顺序与上述相同。例如，输出必须具有以下形式\n$[r_1,r_2,r_3,r_4,r_5]$\n其中每个 $r_i$ 是对应于测试用例 $i$ 的列表，并且该行中任何地方都不能有空格。每个列表 $r_i$ 必须具有以下形式\n$[\\text{hit}, n_{\\min}, n_{\\mathrm{exec}}, x_{\\mathrm{float}}, x_{\\mathrm{exact}}, e]$\n其字段类型如上定义。此行上的所有数字输出都必须表示为以十为基的浮点数或整数。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于数值计算的原理，问题提法清晰，具有明确的确定性过程，并且表述客观。它提出了一个关于浮点运算局限性的计算工程学中的标准但基本的问题。我们现在将继续进行解答。\n\n此问题的核心在于精确实数算术与基于计算机的浮点算术之间的根本区别，后者由 IEEE $754$ 双精度数标准规定。在模拟序列 $x_{n+1} = x_n + h$ 时，会出现两个主要的误差来源：\n\n$1$. **表示误差**：许多十进制小数，如 $0.1$ 或 $0.3$，在二进制中没有精确的有限表示。它们被存储为最接近的可表示二进制浮点数。例如，十进制数 $0.1$ 在二进制中是一个无限循环小数（$0.0001100110011\\dots_2$），必须被截断以适应双精度浮点数的 $52$ 位有效数位。这在任何计算开始之前就引入了初始误差。相反，那些可以表示为 2 的幂的有限和的数，例如 $0.125 = 1/8 = 2^{-3}$，则可以被精确表示。\n\n$2$. **舍入误差**：每次算术运算（在此例中为加法）都是以有限精度执行的。$x_n + h$ 的数学精确结果会被舍入到最接近的可表示浮点数。这个在每一步引入的小误差，经过多次迭代后会累积，导致计算出的序列 $x_n$ 偏离其理论路径。\n\n所给问题要求通过模拟来展示这些效应。方法如下：\n\n首先，我们必须仔细处理输入值。提供的测试用例参数 $s$、$h$ 和 $t$ 被定义为精确实数。为了计算理论值 $x_{\\mathrm{exact}}$，我们必须使用一个高精度算术库，以避免标准的浮点不精确性。为此，我们使用了 Python 的 `decimal` 模块，并将其配置为足够高的精度，以确保所有计算都如同精确计算一样。每个测试用例的输入都被转换为这些高精度对象。\n\n其次，对每个测试用例使用标准的双精度浮点算术（在 Python 中由 `float` 类型或 `numpy.float64` 表示）进行模拟。模拟遵循以下算法：\n$1$. 初始化浮点序列值 $x_\\text{float} \\leftarrow \\text{float}(s)$。将 `hit` 初始化为 `False`，`n_min` 初始化为 $-1$。\n$2$. 用索引 $n$ 从 $0$ 到 $M$（含）进行迭代。在每次迭代中，序列的当前值 $x_n$ 由 $x_\\text{float}$ 表示。\n$3$. 在每一步 $n$，执行精确的相等性检查：if $x_\\text{float} == \\text{float}(t)$。\n$4$. 如果等式成立，则表示已命中目标。我们将 `hit` 设为 `True`，记录当前索引为 $n_{\\mathrm{min}} = n$，将执行的增量次数设为 $n_{\\mathrm{exec}} = n$，存储 $x_\\text{float}$ 的当前值作为最终值，并终止此测试用例的模拟循环。\n$5$. 如果等式不成立且 $n < M$，则将序列推进一个步长：$x_\\text{float} \\leftarrow x_\\text{float} + \\text{float}(h)$。\n$6$. 如果循环完成而未找到等式成立的情况（即，对于所有 $n \\in \\{0, 1, \\dots, M\\}$），我们将 $n_{\\mathrm{exec}}$ 设为 $M$。$x_\\text{float}$ 的最终值是经过 $M$ 次增量后的结果。\n\n第三，在模拟确定了 $n_{\\mathrm{exec}}$ 和最终 $x_\\text{float}$ 的值之后，我们计算理论量。\n$1$. 使用高精度的 `Decimal` 对象计算精确的最终值：$x_{\\mathrm{exact}} = s_{\\mathrm{exact}} + n_{\\mathrm{exec}} \\cdot h_{\\mathrm{exact}}$。\n$2$. 于是，绝对误差为 $e = |x_\\text{float} - \\text{float}(x_\\text{exact})|$。\n\n最后，将六个所需的输出字段（`hit`、$n_{\\mathrm{min}}$、$n_{\\mathrm{exec}}$、$x_\\text{float}$、$\\text{float}(x_{\\mathrm{exact}})$ 和 $e$）为每个测试用例收集到一个列表中。\n\n具体的测试用例旨在说明不同的行为：\n- **用例 $1$、$3$ 和 $4$**：这些用例使用的步长（$h = \\pm 0.1$，$h = 0.3$）在二进制中无法精确表示。表示误差和舍入误差的累积将导致浮点序列精确地错过目标值 $t$。因此，我们预期 `hit` 为 `False`。\n- **用例 $2$**：在此用例中，$s、h、t$（`0.0`、`0.125`、`1.0`）都可以精确表示，因为 $h=2^{-3}$。所有的加法都是精确的。序列将在 $n=8$ 时精确命中目标 $t=1.0$。因此，我们预期 `hit` 为 `True`。\n- **用例 $5$**：这个用例很微妙。起始值是 $s=1.0$。对于 $1.0$ 来说，其末位单位（ULP）是 $2^{-52}$。增量是 $h = 2^{-55}$，小于 $1.0$ 的 ULP 的一半。根据 IEEE $754$ 中的“向最近偶数舍入”规则，操作 $1.0 + 2^{-55}$ 会舍入回 $1.0$。因此，模拟的 $x_n$ 值将一直停留在 $1.0$，永远不会达到目标 $t = 1.0 + 2^{-52}$。然而，精确的和确实在累积。这展示了一种显著的截断误差，即微小的增量被丢失了。我们预期 `hit` 为 `False`，并且会产生一个等于丢失增量之和的非零误差 $e$。", "answer": "```python\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Simulates a floating-point sequence and compares it with exact arithmetic.\n    \"\"\"\n    # Set a high precision for the Decimal module for \"exact\" calculations.\n    getcontext().prec = 100\n\n    def run_case_simulation(s_exact, h_exact, t_exact, M):\n        \"\"\"\n        Runs the simulation for a single test case.\n        \"\"\"\n        # Convert exact Decimal inputs to double-precision floats for simulation.\n        s_f = np.float64(s_exact)\n        h_f = np.float64(h_exact)\n        t_f = np.float64(t_exact)\n\n        x_n_float = s_f\n        hit = False\n        n_min = -1\n        \n        # Loop from n=0 to M, checking the sequence value x_n at each step.\n        for n in range(M + 1):\n            # Per problem, check for exact floating-point equality.\n            if x_n_float == t_f:\n                hit = True\n                n_min = n\n                n_exec = n\n                x_float_final = x_n_float\n                break\n            \n            # If not hit and not the last iteration, perform one increment.\n            if n < M:\n                x_n_float += h_f\n        else:  # This 'else' clause executes if the 'for' loop completes without a 'break'.\n            n_exec = M\n            # The final value is the result after M increments.\n            x_float_final = x_n_float\n\n        # Calculate the theoretical exact value and the absolute error.\n        x_exact_val = s_exact + Decimal(n_exec) * h_exact\n        error = np.abs(x_float_final - np.float64(x_exact_val))\n\n        return [hit, n_min, n_exec, x_float_final, np.float64(x_exact_val), error]\n\n    # Define test cases using Decimal for exact representation of inputs.\n    test_cases = [\n        # Test case 1: Canonical failure with decimal step.\n        (Decimal('0.0'), Decimal('0.1'), Decimal('1.0'), 12),\n        # Test case 2: Exactly representable step and reachable target.\n        (Decimal('0.0'), Decimal('0.125'), Decimal('1.0'), 8),\n        # Test case 3: Step does not subdivide the interval.\n        (Decimal('0.0'), Decimal('0.3'), Decimal('1.0'), 10),\n        # Test case 4: Negative step toward zero with decimal step.\n        (Decimal('1.0'), Decimal('-0.1'), Decimal('0.0'), 12),\n        # Test case 5: Increments below one ULP until accumulation.\n        (Decimal('1.0'), Decimal(1) / (Decimal(2)**55), Decimal(1) + Decimal(1) / (Decimal(2)**52), 8)\n    ]\n    \n    all_results = []\n    for case_params in test_cases:\n        s, h, t, M = case_params\n        result = run_case_simulation(s, h, t, M)\n        all_results.append(result)\n\n    # Format the output string to be a list of lists with no spaces.\n    # Each inner list is manually formatted to avoid spaces from default str(list).\n    result_strings = []\n    for res in all_results:\n        # Note: res[0] is a boolean, str(res[0]) is 'True' or 'False'.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]},{res[5]}]\"\n        result_strings.append(res_str)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2447428"}, {"introduction": "在理解了基本的表示误差后，我们将探讨一种更具破坏性的数值问题：灾难性相消 (catastrophic cancellation)。本练习要求您使用两种不同的数学公式来计算一个数据集的方差，其中一种是理论上等价但在数值计算中极其不稳定的“单遍”公式 $\\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$。通过比较其与稳健的“两遍”算法的结果，您将深刻体会到当处理相近的大数相减时，微小的舍入误差如何被急剧放大，从而导致结果完全错误。这项实践强调了在科学计算中选择数值稳定算法的至关重要性。[@problem_id:2447454]", "problem": "您需要实现一个完整的、可运行的程序，该程序通过比较两种计算公式，来演示在计算具有大均值和小偏差的数据集的方差时出现的灾难性相消问题。其理论基础是方差作为实值随机变量的二阶中心矩的定义，以及标准的浮点舍入模型。请使用以下事实作为出发点：\n- 对于具有有限二阶矩的实值随机变量 $X$，其方差由二阶中心矩定义：$\\operatorname{Var}(X) = \\mathbb{E}\\big[(X - \\mu)^2\\big]$，其中 $\\mu = \\mathbb{E}[X]$。\n- 对于实数，二阶原始矩满足 $\\mathbb{E}[X^2] = \\operatorname{Var}(X) + \\mu^2$。\n- 电气和电子工程师协会 (IEEE) binary64 格式（通常称为双精度）中的浮点算术近似遵循舍入模型 $\\operatorname{fl}(a \\,\\circ\\, b) = (a \\,\\circ\\, b)(1 + \\delta)$，其中 $|\\delta| \\le \\epsilon_{\\text{mach}}$，$\\epsilon_{\\text{mach}}$ 是机器ε，$\\circ$ 是一个算术运算。对两个几乎相等的数进行相减会导致灾难性抵消，从而丢失有效数字。\n\n您的程序必须：\n- 构建具有大均值和小偏差的指定数据集。\n- 在 IEEE binary64 算术中，使用两种方法计算方差：\n  1. 原始矩单遍形式：计算 $\\mathbb{E}[X]$ 和 $\\mathbb{E}[X^2]$，然后构成 $\\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$。\n  2. 中心化双遍形式：首先计算 $\\mu = \\mathbb{E}[X]$，然后在第二遍中计算 $\\mathbb{E}[(X-\\mu)^2]$。\n- 使用十进制算术计算高精度参考方差，其精度要足够高，以至于与 IEEE binary64 相比，运算中的舍入可以忽略不计。在高精度计算中使用中心矩定义 $\\mathbb{E}[(X-\\mu)^2]$。\n- 量化每种浮点方法相对于高精度参考值的绝对误差。\n- 生成单行输出，对于测试套件中的每个数据集，按顺序列出一个包含五个值的列表：单遍方差、双遍方差、高精度参考方差、单遍结果的绝对误差以及双遍结果的绝对误差。\n\n所有数据集都是纯数值的；本问题不涉及物理单位。也不涉及角度。\n\n用于覆盖正常路径、边界强调以及灾难性抵消费边缘情况的测试套件：\n- 测试 $1$（大均值周围的对称小偏差，使用整数以避免输入量化）：设 $M = 10^{8}$ 且 $D = \\{-3,-1,0,1,3\\}$。数据集为 $X = \\{ M + d \\mid d \\in D\\}$。对于精确实数，真实方差等于离差平方的平均值，即 $4$。\n- 测试 $2$（非对称小偏差，偏差均值非零）：设 $M = 10^{8}$ 且 $D = \\{0,1,2,3,4\\}$。数据集为 $X = \\{ M + d \\mid d \\in D\\}$。对于精确实数，真实方差等于 $2$。\n- 测试 $3$（样本量更大，偏差微小且平滑变化）：设 $M = 10^{8}$ 且 $D = \\left\\{ \\frac{k-500}{1000} \\;\\middle|\\; k=0,1,\\dots,999 \\right\\}$。数据集为 $X = \\{ M + d \\mid d \\in D\\}$。对于精确实数，真实方差是该算术网格的总体方差；它接近于 $1/12$ 减去微小偏差均值的平方，并且必须由您的高精度例程精确计算。\n- 测试 $4$（相对于均值，在分辨率极限附近的极端小偏差）：设 $M = 10^{8}$ 且 $D = \\{10^{-8},-10^{-8}\\}$。数据集为 $X = \\{ M + d \\mid d \\in D\\}$。对于精确实数，真实方差等于 $10^{-16}$。\n\n高精度参考要求：\n- 使用基数为十的十进制算术构建参考值，精度至少为 $p = 100$ 位。如上所述，使用 $M$ 和 $D$ 的精确十进制值构建数据集（例如，精确使用 $M = 100000000$ 以及诸如 $(k-500)/1000$ 的有理数作为精确小数）。使用双遍中心矩定义 $\\mathbb{E}[(X-\\mu)^2]$ 计算总体方差，其中 $\\mathbb{E}[\\cdot]$ 是有限集合上的算术平均值。\n\n浮点计算要求：\n- 使用数值库中的标准数组，通过 IEEE binary64（双精度）计算单遍原始矩和双遍中心矩的总体方差。不要应用任何补偿求和或数值稳定技巧；以显而易见的方式使用直接的均值和求和，以便截断和舍入误差可见。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个类 Python 列表，内含四个内部列表，按测试 $1$ 到 $4$ 的顺序，每个测试用例一个。每个内部列表必须包含五个浮点数：$[\\text{var\\_one\\_pass}, \\text{var\\_two\\_pass}, \\text{var\\_ref}, \\text{abs\\_err\\_one}, \\text{abs\\_err\\_two}]$。例如，一个语法上有效的输出行看起来像 $[[v_{11},v_{12},v_{13},e_{11},e_{12}],[v_{21},v_{22},v_{23},e_{21},e_{22}],\\dots]$，其中的数值由您的程序填充。\n\n程序不能有用户输入，也不能使用外部文件。程序必须完全确定测试数据，执行计算，并打印所需的单行输出。输出必须是浮点数。", "solution": "用户提出了一个计算工程领域的问题，要求分析方差计算中的数值稳定性。该问题是有效的、适定的，并具有科学依据。它探讨了数值方法中的一个基本问题：由于浮点运算中的灾难性抵消导致的精度损失。\n\n核心任务是比较计算数据集 $X = \\{x_1, x_2, \\dots, x_N\\}$ 总体方差的两种公式：\n\n1.  **单遍（或原始矩）公式：** 此方法源于代数恒等式 $\\operatorname{Var}(X) = \\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$。在计算上，它涉及单遍遍历数据以计算值的总和与平方的总和，然后从中计算出均值。该公式为：\n    $$ \\sigma^2 = \\frac{1}{N}\\sum_{i=1}^{N} x_i^2 - \\left(\\frac{1}{N}\\sum_{i=1}^{N} x_i\\right)^2 $$\n    虽然对于实数而言，这个公式在数学上是精确的，但当标准差 $\\sigma$ 相对于均值 $\\mu = \\mathbb{E}[X]$ 很小时，它在数值上是不稳定的。$\\mathbb{E}[X^2]$ 和 $(\\mathbb{E}[X])^2$ 这两项会变得非常接近。具体来说，$\\mathbb{E}[X^2] = \\sigma^2 + \\mu^2$，因此该公式相当于计算 $\\sigma^2 = (\\sigma^2 + \\mu^2) - \\mu^2$。当使用有限精度的浮点算术（如 IEEE binary64）进行计算时，这涉及到两个非常大且几乎相等的数相减。此操作是灾难性抵消的典型例子。两个数的首位数字相互抵消，导致结果中大部分甚至全部有效数字丢失。计算 $\\mathbb{E}[X^2]$ 和 $(\\mathbb{E}[X])^2$ 时的舍入误差（其量级约为 $\\mu^2 \\varepsilon_{\\text{mach}}$）成为最终结果的主导部分，可能产生一个高度不准确甚至为负的方差。\n\n2.  **双遍（或中心矩）公式：** 此方法更贴近方差的定义，即离均差平方的均值。它需要对数据进行两遍处理。\n    $$ \\mu = \\frac{1}{N}\\sum_{i=1}^{N} x_i $$\n    $$ \\sigma^2 = \\frac{1}{N}\\sum_{i=1}^{N} (x_i - \\mu)^2 $$\n    在第一遍中，计算均值 $\\mu$。在第二遍中，使用这个计算出的均值来找到离差平方 $(x_i - \\mu)^2$，然后对其求平均。这种方法在数值上要稳健得多。虽然仍然执行了减法 $x_i - \\mu$，但结果是一组小数（即离差）。对这些小数进行平方和求和不涉及大数相减。主要的误差来源是 $\\mu$ 的初始计算。计算出的均值 $\\hat{\\mu}$ 中的误差会传播到离差中。然而，这个误差通常很小。对于具有大均值 $M$ 和小偏差的数据，计算出的均值误差量级约为 $M\\varepsilon_{\\text{mach}}$。只要这个误差相对于真实离差的量级是小的，双遍算法就能得出准确的结果。\n\n对于此问题，还需要进行高精度参考计算。这将使用 Python 的 `decimal` 模块，并设置 $p=100$ 位的精度来完成。在此精度水平下，与标准的 binary64 浮点算术相比，舍入误差可以忽略不计，从而提供一个“基准真相”，用以比较其他两种方法的表现。\n\n程序将被构造成处理四个特定的测试用例。每个用例都使用一个具有大均值（$M=10^8$）和小偏差的数据集，旨在暴露单遍公式的数值缺陷。\n\n-   **测试 1 & 2：** 偏差是小整数。双遍方法预计将非常准确。单遍方法预计会因灾难性抵消而失败。\n-   **测试 3：** 具有平滑变化的微小有理数偏差的较大数据集。预计行为相似。\n-   **测试 4：** 偏差极小（$d = \\pm 10^{-8}$），接近 binary64 相对于均值的分辨率极限。对于 $x = M+d$， $d$ 的值小于量级为 $M$ 的数可能有的最小增量（即 $M \\cdot \\varepsilon_{\\text{mach}} \\approx 10^8 \\cdot 2.22 \\times 10^{-16} = 2.22 \\times 10^{-8}$）。因此，$\\operatorname{fl}(M+d)$ 将被舍入为 $M$ 本身。这展示了另一种误差来源：初始数据表示中的信息丢失，这将导致两种浮点方法都计算出方差为 $0$。\n\n实现将通过定义一个函数来进行，该函数接收一个数据集，使用三种方法（单遍浮点、双遍浮点和高精度参考）计算方差，计算浮点方法的绝对误差，并返回结果。将为每个测试用例调用此函数，并将收集到的结果格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Computes and compares variance using three different methods to demonstrate\n    truncation and round-off errors.\n    \"\"\"\n    # Set the precision for decimal arithmetic to 100 digits, as required.\n    getcontext().prec = 100\n\n    def analyze_dataset(M_str: str, D_list: list):\n        \"\"\"\n        Performs the full analysis for a given dataset definition.\n\n        Args:\n            M_str: The large mean component as a string for exact Decimal conversion.\n            D_list: A list of deviation values (as Decimal objects).\n\n        Returns:\n            A list containing the five required values:\n            [var_one_pass, var_two_pass, var_ref, abs_err_one, abs_err_two]\n        \"\"\"\n        # 1. High-precision reference calculation using the decimal module.\n        # This serves as the ground truth.\n        M_dec = Decimal(M_str)\n        X_dec = [M_dec + d for d in D_list]\n        N_dec = Decimal(len(X_dec))\n        \n        # Use two-pass formula for the reference calculation.\n        mu_dec = sum(X_dec) / N_dec\n        var_ref = sum([(x - mu_dec)**2 for x in X_dec]) / N_dec\n\n        # 2. Floating-point calculations using numpy (IEEE binary64).\n        # Construct the dataset using standard float64.\n        # Note: float() conversion from Decimal can introduce small errors,\n        # but the dominant error source is the variance algorithm itself.\n        X_fp = np.array([float(x) for x in X_dec], dtype=np.float64)\n        \n        # Method 1: One-pass (raw-moment) formula. Prone to catastrophic cancellation.\n        # sigma^2 = E[X^2] - (E[X])^2\n        mean_of_squares = np.mean(X_fp**2)\n        square_of_mean = np.mean(X_fp)**2\n        var_one_pass = mean_of_squares - square_of_mean\n        \n        # Method 2: Two-pass (centered-moment) formula. More numerically stable.\n        # sigma^2 = E[(X - E[X])^2]\n        mu_fp = np.mean(X_fp)\n        var_two_pass = np.mean((X_fp - mu_fp)**2)\n        \n        # 3. Quantify absolute errors.\n        abs_err_one = abs(var_one_pass - float(var_ref))\n        abs_err_two = abs(var_two_pass - float(var_ref))\n        \n        return [var_one_pass, var_two_pass, float(var_ref), abs_err_one, abs_err_two]\n\n    # --- Define and run all test cases ---\n    test_cases_defs = [\n        # Test 1: Symmetric small integer deviations. True Var = 4.\n        {'M': '1e8', 'D': [Decimal(s) for s in ['-3', '-1', '0', '1', '3']]},\n        \n        # Test 2: Non-symmetric small integer deviations. True Var = 2.\n        {'M': '1e8', 'D': [Decimal(s) for s in ['0', '1', '2', '3', '4']]},\n        \n        # Test 3: Larger sample with small rational deviations.\n        {'M': '1e8', 'D': [(Decimal(k) - Decimal(500)) / Decimal(1000) for k in range(1000)]},\n        \n        # Test 4: Extremely small deviations at the limit of float64 resolution. True Var = 1e-16.\n        {'M': '1e8', 'D': [Decimal('1e-8'), Decimal('-1e-8')]}\n    ]\n\n    all_results = []\n    for case in test_cases_defs:\n        result = analyze_dataset(case['M'], case['D'])\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, e.g., [[v1,v2,...],[v1,v2,...]]\n    formatted_inner_lists = []\n    for res_list in all_results:\n        # Format each inner list as \"[v1,v2,v3,e1,e2]\"\n        formatted_list_str = f\"[{','.join(map(str, res_list))}]\"\n        formatted_inner_lists.append(formatted_list_str)\n    \n    # Join the inner lists into the final output format \"[ [...], [...], ... ]\"\n    final_output = f\"[{','.join(formatted_inner_lists)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2447454"}, {"introduction": "认识到舍入误差的危害之后，一个自然的问题是：我们能如何应对它？这个实践练习将引导您从被动分析问题转向主动构建解决方案。您将学习并实现Kahan求和算法，这是一种“补偿性求和”方法，它通过一个巧妙的补偿变量来追踪并修正每次加法中丢失的低位精度。通过将Kahan求和与朴素求和的结果进行对比，您会发现我们能够显著提高累加长序列数值的准确性，这在金融资产回报分析、物理模拟等诸多领域都有着直接的应用价值。[@problem_id:2427731]", "problem": "您的任务属于计算经济学和金融学领域，要求量化在累加长序列小额资产回报率时浮点舍入误差的影响，并使用补偿求和算法来减轻该影响。考虑一个实值回报率序列 $\\{r_i\\}_{i=1}^n$，其数学上的精确累计回报是实数和 $S = \\sum_{i=1}^n r_i$。在使用二进制浮点运算的实际计算中，加法操作由标准浮点舍入模型建模：对于任意两个实数 $a$ 和 $b$，其和的计算值为 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入，例如对于64位二进制浮点数，$u \\approx 2^{-53}/2$。在对幅值和符号各异的长序列求和时，朴素的从左到右求和会累积舍入误差，并可能丢失低位比特，尤其是在将非常小的值加到一个大得多的部分和上时。这种现象在跨越长时期累加微小的每日回报率时具有现实意义。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n- 实现两种方法，用浮点运算对给定的有序回报率序列求和：\n  1. 朴素的从左到右求和，累加到一个单个标量中。\n  2. Kahan 补偿求和方法，该方法在不改变序列顺序的情况下，跟踪并校正因舍入而丢失的低位比特。\n- 使用精确有理数运算计算数学精确和 $S$ 的高精度基准，具体方法是：将每个回报率解释为具有固定分母 $D = 10^{16}$ 的十进制分数，并将分子作为整数求和。具体来说，对于每个小数点后最多有16位的十进制回报率 $r_i$，将其解释为精确有理数 $\\frac{\\lfloor r_i \\cdot D \\rceil}{D}$，其中对于下面提供的值，舍入是精确的（对于给定的测试套件，无需进行舍入）。然后用整数精确计算 $S = \\frac{1}{D}\\sum_{i=1}^n (r_i \\cdot D)$，并且仅为了报告绝对误差才将 $S$ 转换为浮点数。\n- 对每个测试序列，报告两个浮点数形式的绝对误差：$|S_{\\text{naive}} - S|$ 和 $|S_{\\text{Kahan}} - S|$，以及一个布尔值，该布尔值指示 Kahan 补偿求和的误差是否严格小于朴素求和的误差。\n\n重要说明：\n- 将回报率视为无单位的十进制数（不要使用百分号）。不涉及物理单位或角度单位。\n- 所有求和必须按指定顺序执行；不允许重新排序。\n- 最终输出必须将所有测试用例的结果汇总到一行，形式为方括号内包含的逗号分隔列表。此列表的每个元素本身必须是一个形式为 $[e_n, e_k, b]$ 的列表，其中 $e_n$ 是朴素求和的绝对误差（一个浮点数），$e_k$ 是 Kahan 补偿求和的绝对误差（一个浮点数），如果 $e_k < e_n$，则布尔值 $b$ 等于 $\\text{True}$，否则等于 $\\text{False}$。例如：$[[e_{n,1}, e_{k,1}, b_1],[e_{n,2}, e_{k,2}, b_2],\\dots]$。\n\n测试套件和覆盖范围：\n- 使用以下四个有序序列，每个序列都紧凑地指定为片段列表 $(v, c)$，表示值 $v$ 按顺序连续出现 $c$ 次。所有值都是十进制字符串，所有计数都是非负整数。每个值的小数点后最多有16位，因此公分母 $D = 10^{16}$ 对精确有理数求和是有效的。\n\n  1. 正常路径但易于发生抵消的序列（围绕大偏移量的小增量）：\n     - $\\left(\"1.0\",\\, 1\\right)$，然后是 $\\left(\"1e-16\",\\, 1000000\\right)$，然后是 $\\left(\"-1.0\",\\, 1\\right)$。数学上的精确和为 $S = 10^{6}\\cdot 10^{-16} = 10^{-10}$。\n  2. 围绕零的略微不平衡的小额正负回报率：\n     - $\\left(\"1e-8\",\\, 100000\\right)$，然后是 $\\left(\"-1e-8\",\\, 99999\\right)$。数学上的精确和为 $S = 10^{-8}$。\n  3. 全为零的边界情况：\n     - $\\left(\"0.0\",\\, 50000\\right)$。数学上的精确和为 $S = 0$。\n  4. 混合幅值，伴有严重抵消和许多微小项：\n     - $\\left(\"1e-16\",\\, 300000\\right)$，然后是 $\\left(\"1.0\",\\, 1\\right)$，然后是 $\\left(\"-1.0\",\\, 1\\right)$，然后是 $\\left(\"1e-16\",\\, 300000\\right)$，然后是 $\\left(\"-1e-16\",\\, 600000\\right)$。数学上的精确和为 $S = 0$。\n\n要求：\n- 按规定实现两种求和方法和精确有理数基准。\n- 对四个测试序列中的每一个，计算并报告三元组 $[|S_{\\text{naive}}-S|,\\, |S_{\\text{Kahan}}-S|,\\, (|S_{\\text{Kahan}}-S| < |S_{\\text{naive}}-S|)]$。\n- 您的程序应生成一行输出，其中包含这四个三元组的列表，格式完全如下：$[[e_{n,1},e_{k,1},b_1],[e_{n,2},e_{k,2},b_2],[e_{n,3},e_{k,3},b_3],[e_{n,4},e_{k,4},b_4]]$。", "solution": "我们从标准的加法浮点误差模型开始。设 $a$ 和 $b$ 为实数，假设我们用二进制浮点数以“舍入到最近”的方式计算它们的和。计算出的结果满足\n$$\n\\operatorname{fl}(a+b) \\;=\\; (a+b)(1+\\delta), \\quad |\\delta| \\le u,\n$$\n其中 $u$ 是单位舍入。对于64位二进制格式，有 $u \\approx 2^{-53}/2 \\approx 1.11 \\times 10^{-16}$。在对长序列 $\\{r_i\\}_{i=1}^n$ 求和时，朴素的从左到右算法通过 $s \\leftarrow \\operatorname{fl}(s + r_i)$ 对 $i=1,\\dots,n$ 更新一个运行总和 $s$。朴素求和的累积前向误差可以由后向误差分析的著名结果来界定：粗略地说，绝对误差的增长量级约为 $u$ 乘以幅值之和，即\n$$\n|s_{\\text{naive}} - S| \\lesssim \\gamma_n \\sum_{i=1}^n |r_i|, \\quad \\gamma_n = \\frac{nu}{1 - nu},\n$$\n只要 $nu < 1$，这突显了误差 $O(nu)$ 的增长以及对排序和抵消结构的敏感性。特别是，当将一个非常小的 $r_i$ 加到一个大得多的运行总和 $s$ 中时，如果 $|r_i| < \\tfrac{1}{2}\\operatorname{ulp}(s)$，那么 $s + r_i$ 会舍入回 $s$，而 $r_i$ 的低位比特实际上被丢弃了。当期限很长且由于巨额收益或亏损而产生偏移时，这种现象在累加许多微小的每日回报率时具有经济学上的重要意义。\n\n为了减轻这种损失，Kahan 补偿求和引入了一个辅助变量 $c$，用于跟踪因舍入而丢失的低位比特的动态补偿。其思想是从下一个加数中预先减去补偿，并通过上次加法中观察到的舍入误差来更新补偿。具体来说，设 $s$ 为运行总和，$c$ 为补偿，两者都初始化为0。对于每个加数 $x$，定义补偿后的加数 $y = x - c$ 并形成试探和 $t = s + y$。新的补偿是 $y$ 中未被 $t$ 捕获的部分，代数上表示为 $c \\leftarrow (t - s) - y$，运行总和更新为 $s \\leftarrow t$。在精确运算中，$(t - s) = y$，所以 $c$ 将保持为零。但在浮点运算中，$\\operatorname{fl}(t - s)$ 可能因 $s + y$ 的舍入而与 $y$ 不同，这个差值被存储在 $c$ 中，以便在下一步中反馈回来。这为丢失的低位比特提供了一阶校正，并在许多易于发生抵消的情况下显著减少误差，其误差通常基本上由一个与 $n$ 无关的 $u$ 的常数倍所界定。\n\n为了进行基准测试，我们需要一个数学精确和 $S = \\sum_{i=1}^n r_i$ 的基准。由于测试序列表示为最多有16位小数的十进制字符串，每个 $r_i$ 都可以精确地表示为分母为 $D = 10^{16}$ 的有理数。因此，如果 $r_i$ 写成十进制字符串，那么 $r_i \\cdot D$ 就是一个整数，精确和为\n$$\nS \\;=\\; \\frac{1}{D} \\sum_{i=1}^n \\left(r_i \\cdot D\\right), \\qquad D = 10^{16}.\n$$\n我们可以通过解析每个十进制字符串 $r_i$ 并乘以 $D$，使用整数运算来精确计算分子 $\\sum_{i=1}^n (r_i \\cdot D)$，并且仅在最后为了计算绝对误差 $|S_{\\text{naive}} - S|$ 和 $|S_{\\text{Kahan}} - S|$ 才将 $S$ 转换为浮点数。\n\n算法设计：\n- 实现一个生成器，按给定顺序迭代每个测试序列，为朴素求和与 Kahan 求和生成浮点值。\n- 将朴素求和实现为重复的浮点加法。\n- 实现 Kahan 补偿求和，其变量 $s$ 和 $c$ 初始化为0，并使用更新步骤\n  $$\n  y \\leftarrow x - c,\\quad t \\leftarrow s + y,\\quad c \\leftarrow (t - s) - y,\\quad s \\leftarrow t.\n  $$\n- 通过对分母为 $D = 10^{16}$ 的整数分子求和来实现精确有理数基准：对于每个片段 $(v, c)$，精确计算整数 $n_v = v \\cdot D$ 并将 $c \\cdot n_v$ 加到整数累加器中。精确和为 $S = N / D$，其中 $N$ 是整数总和。这对于给定的测试套件是有效的，因为每个 $v$ 的小数点后最多有16位，所以 $v \\cdot D$ 是一个整数。\n- 对于每个测试用例，计算绝对误差 $e_n = |S_{\\text{naive}} - S|$ 和 $e_k = |S_{\\text{Kahan}} - S|$，以及布尔值 $b = (e_k < e_n)$。\n- 为四个指定的序列按顺序生成最终的单行输出，形式为包含四个三元组 $[e_n, e_k, b]$ 的列表。\n\n测试套件解释：\n1. 序列1：$\\left(\"1.0\",\\, 1\\right)$, $\\left(\"1e-16\",\\, 1000000\\right)$, $\\left(\"-1.0\",\\, 1\\right)$。此处 $S = 10^6 \\cdot 10^{-16} = 10^{-10}$。朴素求和在将每个 $10^{-16}$ 加到 $1.0$ 上时通常会丢失精度，导致在减去最后的 $-1.0$ 后结果接近于0，而 Kahan 求和则在 $c$ 中恢复了低位比特，得出的结果接近 $10^{-10}$。\n2. 序列2：$\\left(\"1e-8\",\\, 100000\\right)$, $\\left(\"-1e-8\",\\, 99999\\right)$。此处 $S = 10^{-8}$。两种方法都应表现良好；绝对误差预计与 $S$ 相比会非常小。\n3. 序列3：$\\left(\"0.0\",\\, 50000\\right)$。此处 $S = 0$。两种方法在浮点运算中都应精确得到0，从而导致绝对误差为零。\n4. 序列4：$\\left(\"1e-16\",\\, 300000\\right)$, $\\left(\"1.0\",\\, 1\\right)$, $\\left(\"-1.0\",\\, 1\\right)$, $\\left(\"1e-16\",\\, 300000\\right)$, $\\left(\"-1e-16\",\\, 600000\\right)$。此处 $S = 0$。大量微小项与大幅度抵消交织在一起的长序列对两种方法都构成了压力；补偿方法减少了舍入误差的累积。\n\n程序必须实现这些步骤，并以完全相同的格式打印单行输出：\n$$\n\\left[\\,[e_{n,1},e_{k,1},b_1],\\,[e_{n,2},e_{k,2},b_2],\\,[e_{n,3},e_{k,3},b_3],\\,[e_{n,4},e_{k,4},b_4]\\,\\right].\n$$", "answer": "```python\nimport math\nfrom decimal import Decimal, getcontext\n\n# No external input; all parameters are embedded per the problem statement.\n\ndef naive_sum(seq_iter):\n    \"\"\"Naive left-to-right summation over an iterator of floats.\"\"\"\n    s = 0.0\n    for x in seq_iter:\n        s += x\n    return s\n\ndef kahan_sum(seq_iter):\n    \"\"\"Kahan compensated summation over an iterator of floats.\"\"\"\n    s = 0.0\n    c = 0.0\n    for x in seq_iter:\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef float_generator_from_segments(segments):\n    \"\"\"\n    Yield floats in the specified order for segments specified as\n    a list of tuples: (value_string, count_int).\n    \"\"\"\n    for v_str, cnt in segments:\n        x = float(v_str)\n        for _ in range(cnt):\n            yield x\n\ndef exact_sum_from_segments(segments, D=10**16):\n    \"\"\"\n    Compute the exact rational sum as N/D where D=10^16, by summing integer numerators.\n    Each value v_str must be a decimal with at most 16 digits after the decimal point.\n    Returns the exact sum as a float for error comparison.\n    \"\"\"\n    # Use high precision Decimal to convert values exactly, then multiply by D to get integer.\n    getcontext().prec = 50\n    D_dec = Decimal(D)\n    N = 0  # integer numerator\n    for v_str, cnt in segments:\n        v_dec = Decimal(v_str)\n        n_v = int((v_dec * D_dec).to_integral_exact())  # exact integer for given test suite\n        if cnt:\n            N += n_v * cnt\n    # Convert to float for error measurement; loss here is negligible vs measured errors\n    return N / D\n\ndef compute_case(segments):\n    \"\"\"Compute absolute errors for naive and Kahan sums against exact rational baseline.\"\"\"\n    true_sum = exact_sum_from_segments(segments)\n    nsum = naive_sum(float_generator_from_segments(segments))\n    ksum = kahan_sum(float_generator_from_segments(segments))\n    en = abs(nsum - true_sum)\n    ek = abs(ksum - true_sum)\n    return [en, ek, ek < en]\n\ndef solve():\n    # Define the test cases as per the problem statement.\n    test_cases = [\n        # 1) (\"1.0\", 1), (\"1e-16\", 1000000), (\"-1.0\", 1)\n        [(\"1.0\", 1), (\"1e-16\", 1_000_000), (\"-1.0\", 1)],\n        # 2) (\"1e-8\", 100000), (\"-1e-8\", 99999)\n        [(\"1e-8\", 100_000), (\"-1e-8\", 99_999)],\n        # 3) (\"0.0\", 50000)\n        [(\"0.0\", 50_000)],\n        # 4) (\"1e-16\", 300000), (\"1.0\", 1), (\"-1.0\", 1), (\"1e-16\", 300000), (\"-1e-16\", 600000)\n        [(\"1e-16\", 300_000), (\"1.0\", 1), (\"-1.0\", 1), (\"1e-16\", 300_000), (\"-1e-16\", 600_000)],\n    ]\n\n    results = []\n    for segments in test_cases:\n        res = compute_case(segments)\n        results.append(res)\n\n    # Print in the exact required single-line format.\n    # Convert booleans and floats to their standard string representations.\n    def fmt(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(fmt(x) for x in item) + \"]\"\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        # float or int\n        return str(item)\n\n    print(fmt(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2427731"}]}