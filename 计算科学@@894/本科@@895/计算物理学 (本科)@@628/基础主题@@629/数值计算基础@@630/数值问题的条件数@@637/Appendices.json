{"hands_on_practices": [{"introduction": "理论与实践的结合始于对物理现象的精确分析。本练习将带你进入等离子体物理学的世界，通过分析磁镜中带电粒子的运动，来理解一个决策问题是如何变得病态的。你将运用守恒定律推导出粒子被反射或透射的临界条件，并计算其敏感性，从而亲身体会当系统参数接近临界边界时，预测结果为何会变得极其困难 [@problem_id:2382061]。", "problem": "一个质量为 $m$、电荷为 $q$ 的带电粒子在一个缓慢变化的静磁场中沿着磁感线运动，该磁场从粒子起始位置的 $B_{0}$ 单调增加到磁感线上某处的最大值 $B_{\\max}$。粒子的初速率为 $v$，其初始投掷角（其速度与局部磁场之间的夹角）为 $\\alpha_{0}$，以弧度为单位。假设空间变化足够缓慢，使得第一绝热不变量（磁矩）$\\mu = m v_{\\perp}^{2}/(2 B)$ 守恒，并且总动能 $\\tfrac{1}{2} m v^{2}$ 守恒。如果粒子在磁场达到 $B_{\\max}$ 之前其平行速度达到零，则粒子发生反射。\n\n在数值实践中，可以通过评估一个标量决策函数 $m(\\alpha_{0},R)$ 来做出反射决策，该函数的符号决定了结果，其中 $R \\equiv B_{\\max}/B_{0}$。仅考虑初始投掷角 $\\alpha_{0}$ 的微扰，将决策函数关于 $\\alpha_{0}$ 的相对条件数定义为\n$$\n\\kappa(\\alpha_{0};R) \\equiv \\lim_{\\delta \\to 0} \\sup \\frac{\\left|\\delta m / m\\right|}{\\left|\\delta \\alpha_{0} / \\alpha_{0}\\right|} = \\left| \\frac{\\alpha_{0}}{m(\\alpha_{0},R)} \\frac{\\partial m}{\\partial \\alpha_{0}}(\\alpha_{0},R) \\right|.\n$$\n仅使用第一绝热不变量守恒和动能守恒，构建一个这样的 $m(\\alpha_{0},R)$，其符号可以区分反射与非反射，然后计算 $\\kappa(\\alpha_{0};R)$ 的闭式解析表达式。\n\n请以仅含 $\\alpha_{0}$ 和 $R$ 的单个闭式表达式的形式给出 $\\kappa(\\alpha_{0};R)$ 的最终答案。角度必须以弧度为单位。无须进行数值计算。", "solution": "该问题要求为磁镜中带电粒子的反射构建一个标量决策函数 $m(\\alpha_{0}, R)$，并随后计算其相对条件数 $\\kappa(\\alpha_{0};R)$。此分析将完全基于给定的守恒定律。\n\n首先，我们必须建立粒子反射的物理条件。粒子的总动能 $E = \\frac{1}{2}mv^2$ 是守恒的。该能量可以表示为与平行于磁场 $\\vec{B}$ 的运动（$v_\\|$）和垂直于磁场的运动（$v_\\perp$）相关的动能之和：\n$$\nE = \\frac{1}{2}m v^2 = \\frac{1}{2}m v_{\\|}^{2} + \\frac{1}{2}m v_{\\perp}^{2}\n$$\n由于总速率 $v$ 是恒定的，我们有 $v^2 = v_{\\|}^{2} + v_{\\perp}^{2}$。\n\n问题指出，第一绝热不变量，即磁矩 $\\mu$，也是守恒的。其定义为：\n$$\n\\mu = \\frac{\\frac{1}{2}m v_{\\perp}^{2}}{B} = \\text{constant}\n$$\n其中 $B$ 是磁场的大小。$\\mu$ 的守恒意味着比率 $\\frac{v_{\\perp}^{2}}{B}$ 在粒子的整个运动轨迹中是恒定的。我们可以将在任意点的垂直速率与磁场为 $B_{0}$ 的位置的初始值联系起来：\n$$\n\\frac{v_{\\perp}^{2}}{B} = \\frac{v_{\\perp,0}^{2}}{B_{0}}\n$$\n初始垂直速率 $v_{\\perp,0}$ 由初始总速率 $v$ 和初始投掷角 $\\alpha_{0}$ 决定：\n$$\nv_{\\perp,0} = v \\sin(\\alpha_{0})\n$$\n将此代入 $\\mu$ 的守恒方程，我们可以表达在任意磁场强度 $B$ 下的 $v_{\\perp}^{2}$：\n$$\nv_{\\perp}^{2} = v_{\\perp,0}^{2} \\frac{B}{B_{0}} = v^2 \\sin^2(\\alpha_{0}) \\frac{B}{B_{0}}\n$$\n现在，我们可以从能量守恒中找到平行速率分量 $v_{\\|}$：\n$$\nv_{\\|}^{2} = v^2 - v_{\\perp}^{2} = v^2 - v^2 \\sin^2(\\alpha_{0}) \\frac{B}{B_{0}}\n$$\n$$\nv_{\\|}^{2} = v^2 \\left( 1 - \\frac{B}{B_{0}} \\sin^2(\\alpha_{0}) \\right)\n$$\n当粒子沿磁感线的运动反向时，我们称粒子在该点发生反射，这意味着其平行速率 $v_{\\|}$ 变为零。设 $B_{\\text{refl}}$ 为此反射点的磁场强度。令 $v_{\\|}^{2} = 0$：\n$$\n0 = v^2 \\left( 1 - \\frac{B_{\\text{refl}}}{B_{0}} \\sin^2(\\alpha_{0}) \\right)\n$$\n由于 $v \\ne 0$，括号中的项必须为零：\n$$\n1 = \\frac{B_{\\text{refl}}}{B_{0}} \\sin^2(\\alpha_{0})\n$$\n求解 $B_{\\text{refl}}$ 可得：\n$$\nB_{\\text{refl}} = \\frac{B_{0}}{\\sin^2(\\alpha_{0})}\n$$\n问题指出，如果粒子在磁场达到其最大值 $B_{\\max}$ 之前，其平行速率达到零，则粒子发生反射。这意味着如果满足条件 $B_{\\text{refl}} \\le B_{\\max}$，则发生反射。\n$$\n\\frac{B_{0}}{\\sin^2(\\alpha_{0})} \\le B_{\\max}\n$$\n使用定义 $R = B_{\\max}/B_{0}$，我们可以重写这个不等式：\n$$\n\\frac{1}{\\sin^2(\\alpha_{0})} \\le \\frac{B_{\\max}}{B_{0}} = R\n$$\n$$\n1 \\le R \\sin^2(\\alpha_{0})\n$$\n这个不等式，$R \\sin^2(\\alpha_{0}) - 1 \\ge 0$，提供了反射的条件。基于此，我们可以构建所需的决策函数 $m(\\alpha_{0}, R)$，其符号决定了结果。一个合适的选择是定义该函数，使其在反射时为正，在非反射（透射）时为负。\n$$\nm(\\alpha_{0}, R) = R \\sin^2(\\alpha_{0}) - 1\n$$\n该函数正确地区分了各种情况：如果 $m > 0$，粒子反射；如果 $m  0$，粒子透射；如果 $m = 0$，则为临界情况，此时反射恰好发生在 $B = B_{\\max}$ 处。\n\n接下来，我们计算相对条件数 $\\kappa(\\alpha_{0};R)$，其定义为：\n$$\n\\kappa(\\alpha_{0};R) = \\left| \\frac{\\alpha_{0}}{m(\\alpha_{0},R)} \\frac{\\partial m}{\\partial \\alpha_{0}}(\\alpha_{0},R) \\right|\n$$\n我们需要计算 $m(\\alpha_{0}, R)$ 关于 $\\alpha_{0}$ 的偏导数：\n$$\n\\frac{\\partial m}{\\partial \\alpha_{0}} = \\frac{\\partial}{\\partial \\alpha_{0}} \\left( R \\sin^2(\\alpha_{0}) - 1 \\right)\n$$\n使用链式法则，我们得到：\n$$\n\\frac{\\partial m}{\\partial \\alpha_{0}} = R \\cdot (2 \\sin(\\alpha_{0})) \\cdot (\\cos(\\alpha_{0})) = 2R \\sin(\\alpha_{0}) \\cos(\\alpha_{0})\n$$\n使用倍角公式 $\\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta)$，上式可简化为：\n$$\n\\frac{\\partial m}{\\partial \\alpha_{0}} = R \\sin(2\\alpha_{0})\n$$\n现在，我们将 $m(\\alpha_{0}, R)$ 及其导数的表达式代回条件数的公式中：\n$$\n\\kappa(\\alpha_{0};R) = \\left| \\frac{\\alpha_{0}}{R \\sin^2(\\alpha_{0}) - 1} \\cdot (R \\sin(2\\alpha_{0})) \\right|\n$$\n这就得出了相对条件数的最终解析表达式：\n$$\n\\kappa(\\alpha_{0};R) = \\left| \\frac{\\alpha_{0} R \\sin(2\\alpha_{0})}{R \\sin^2(\\alpha_{0}) - 1} \\right|\n$$\n当分母趋近于零时，即当 $R \\sin^2(\\alpha_0) \\to 1$ 时，条件数发散。这表明，在反射恰好发生在 $B_{\\max}$ 处的临界投掷角附近，关于粒子是否反射的决策在数值上是病态的。", "answer": "$$\n\\boxed{\\left| \\frac{\\alpha_{0} R \\sin(2\\alpha_{0})}{R \\sin^2(\\alpha_{0}) - 1} \\right|}\n$$", "id": "2382061"}, {"introduction": "将抽象的数值概念应用于真实的工程场景是掌握知识的关键。在这个实践中，你将探索一个经典的空气动力学问题：翼型的失速现象。通过为一个简化的升力系数模型编写代码，你将看到在接近失速迎角时，升力系数对迎角的微小变化变得异常敏感，其条件数会急剧增大 [@problem_id:2382100]。这个练习清晰地揭示了为什么在非线性模型的临界区域进行精确仿真是一项重大挑战。", "problem": "考虑从攻角到单个翼型的二维定常升力系数的映射，该映射由以下平滑失速起始函数建模：\n$$\nC_L(\\alpha; a,\\alpha_s,\\Delta C,\\delta) \\;=\\; a\\,\\alpha \\;-\\; \\Delta C\\; S(\\alpha), \\quad\\text{with}\\quad S(\\alpha) \\;=\\; \\tfrac{1}{2}\\Big(1+\\tanh\\Big(\\frac{\\alpha-\\alpha_s}{\\delta}\\Big)\\Big)\n$$\n其中 $a0$ 是小攻角升力线斜率，单位为 radians$^{-1}$，$\\alpha_s$ 是特征失速起始角，$\\Delta C0$ 是失速过渡区的升力系数净损失，$\\delta0$ 控制过渡的急剧程度。角度必须以弧度表示。\n\n令问题“给定 $\\alpha$ 求 $C_L$”的绝对条件数定义为\n$$\n\\kappa_{\\mathrm{abs}}(\\alpha) \\;=\\; \\left|\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}(\\alpha)\\right|\n$$\n相对条件数（当 $C_L(\\alpha)\\neq 0$ 时）定义为\n$$\n\\kappa_{\\mathrm{rel}}(\\alpha) \\;=\\; \\left|\\frac{\\alpha}{C_L(\\alpha)}\\,\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}(\\alpha)\\right|\n$$\n您必须为下面列出的参数集计算这两个条件数。如果在某个情况下 $C_L(\\alpha)=0$，则将相对条件数报告为特殊浮点数值“非数”(Not-a-Number)。\n\n攻角必须以弧度为单位，并且您计算的最终数值是无量纲的。\n\n测试套件（每个案例都是一个有序的 5 元组 $(a,\\alpha_s,\\Delta C,\\delta,\\alpha)$，按所述顺序排列）：\n- 案例 1（代表性失速前）：$(6.2,\\;0.35,\\;0.8,\\;0.015,\\;0.10)$。\n- 案例 2（接近失速，急剧过渡）：$(6.2,\\;0.35,\\;0.8,\\;0.015,\\;0.35)$。\n- 案例 3（失速后，仍受失速起始影响）：$(6.2,\\;0.35,\\;0.8,\\;0.015,\\;0.42)$。\n- 案例 4（接近失速，平缓过渡）：$(6.2,\\;0.35,\\;0.8,\\;0.10,\\;0.35)$。\n- 案例 5（无失速下降，纯线性模型）：$(6.2,\\;0.35,\\;0.0,\\;0.020,\\;0.30)$。\n\n你的程序必须：\n- 对于每个测试用例，根据上述模型计算 $C_L(\\alpha)$ 及其关于 $\\alpha$ 的导数，然后按定义计算 $\\kappa_{\\mathrm{abs}}(\\alpha)$ 和 $\\kappa_{\\mathrm{rel}}(\\alpha)$。\n- 所有角度均使用弧度。\n- 生成单行输出，其中包含一个按测试套件顺序排列的逗号分隔的数对列表。每个数对必须是该案例的一个双元素列表 $[\\kappa_{\\mathrm{abs}},\\kappa_{\\mathrm{rel}}]$。因此，完整的输出行必须如下所示：\n$[[\\kappa_{\\mathrm{abs}}^{(1)},\\kappa_{\\mathrm{rel}}^{(1)}],[\\kappa_{\\mathrm{abs}}^{(2)},\\kappa_{\\mathrm{rel}}^{(2)}],\\dots]$\n用数值代替符号，并用标准浮点字面量表示“非数”(Not-a-Number)。\n\n程序不得读取任何输入。", "solution": "问题陈述经审查后确认有效。它具有科学依据、良定、客观且自洽。所提供的升力系数 $C_L$ 作为攻角 $\\alpha$ 函数的模型，是包含平滑失速过渡的空气动力升力的标准唯象表示。绝对和相对条件数的定义是数值分析中正确的标准形式。参数和测试用例在物理上是合理的，在数学上是可处理的。我们将继续进行求解。\n\n目标是为评估升力系数 $C_L(\\alpha)$ 的问题计算绝对条件数 $\\kappa_{\\mathrm{abs}}(\\alpha)$ 和相对条件数 $\\kappa_{\\mathrm{rel}}(\\alpha)$。$C_L$ 的模型由下式给出：\n$$\nC_L(\\alpha; a, \\alpha_s, \\Delta C, \\delta) = a\\alpha - \\Delta C S(\\alpha)\n$$\n其中 $S(\\alpha)$ 是失速起始函数：\n$$\nS(\\alpha) = \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\\right)\n$$\n参数包括升力线斜率 $a$、失速角 $\\alpha_s$、升力下降量 $\\Delta C$ 和过渡急剧度 $\\delta$。所有角度均以弧度为单位。\n\n条件数定义如下：\n$$\n\\kappa_{\\mathrm{abs}}(\\alpha) = \\left|\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}(\\alpha)\\right|\n$$\n$$\n\\kappa_{\\mathrm{rel}}(\\alpha) = \\left|\\frac{\\alpha}{C_L(\\alpha)}\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}(\\alpha)\\right|\n$$\n\n第一步是推导导数 $\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}$ 的解析表达式。我们对包含 $S(\\alpha)$ 的项应用链式法则。令双曲正切的参数为 $u(\\alpha) = \\frac{\\alpha - \\alpha_s}{\\delta}$。$u$ 关于 $\\alpha$ 的导数是 $\\frac{\\mathrm{d}u}{\\mathrm{d}\\alpha} = \\frac{1}{\\delta}$。双曲正切函数的导数是 $\\frac{\\mathrm{d}}{\\mathrm{d}u}\\tanh(u) = \\mathrm{sech}^2(u)$。\n应用链式法则求 $S(\\alpha)$ 的导数：\n$$\n\\frac{\\mathrm{d}S}{\\mathrm{d}\\alpha} = \\frac{\\mathrm{d}}{\\mathrm{d}\\alpha}\\left[\\frac{1}{2}\\left(1 + \\tanh(u(\\alpha))\\right)\\right] = \\frac{1}{2} \\cdot \\frac{\\mathrm{d}}{\\mathrm{d}u}\\tanh(u) \\cdot \\frac{\\mathrm{d}u}{\\mathrm{d}\\alpha} = \\frac{1}{2} \\cdot \\mathrm{sech}^2(u) \\cdot \\frac{1}{\\delta} = \\frac{1}{2\\delta}\\mathrm{sech}^2\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\n$$\n现在，我们可以对 $C_L(\\alpha)$ 的完整表达式进行微分：\n$$\n\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha} = \\frac{\\mathrm{d}}{\\mathrm{d}\\alpha}(a\\alpha) - \\Delta C \\frac{\\mathrm{d}S}{\\mathrm{d}\\alpha} = a - \\frac{\\Delta C}{2\\delta}\\mathrm{sech}^2\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\n$$\n其中 $\\mathrm{sech}(x) = 1/\\cosh(x)$。\n\n有了 $C_L(\\alpha)$ 及其导数 $\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}$ 的表达式，我们就可以写出条件数的显式公式。\n绝对条件数为：\n$$\n\\kappa_{\\mathrm{abs}}(\\alpha) = \\left|a - \\frac{\\Delta C}{2\\delta}\\mathrm{sech}^2\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\\right|\n$$\n当 $C_L(\\alpha) \\neq 0$ 时，相对条件数为：\n$$\n\\kappa_{\\mathrm{rel}}(\\alpha) = \\left|\\frac{\\alpha}{a\\alpha - \\frac{\\Delta C}{2}\\left(1 + \\tanh\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\\right)} \\left(a - \\frac{\\Delta C}{2\\delta}\\mathrm{sech}^2\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\\right)\\right|\n$$\n如果 $C_L(\\alpha) = 0$，则相对条件数未定义，我们被要求将其报告为“非数”（Not-a-Number, NaN）。\n\n计算流程是在程序中实现这些公式。对于提供的 5 个测试用例，每个用例由一个元组 $(a, \\alpha_s, \\Delta C, \\delta, \\alpha)$ 指定，执行以下步骤：\n1.  计算参数 $u = (\\alpha - \\alpha_s) / \\delta$。\n2.  使用给定模型计算 $C_L(\\alpha)$。\n3.  使用推导出的公式计算导数 $\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}$。\n4.  通过取导数的绝对值来计算 $\\kappa_{\\mathrm{abs}}(\\alpha)$。\n5.  计算 $\\kappa_{\\mathrm{rel}}(\\alpha)$。如果 $C_L(\\alpha)$ 的计算结果为 $0.0$，则结果为 NaN。否则，根据其定义进行计算。\n对于每个案例，记录得到的值对 $[\\kappa_{\\mathrm{abs}}, \\kappa_{\\mathrm{rel}}]$。最终输出是将这些值对聚合到单个列表结构中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute and relative condition numbers for a given aerodynamic\n    lift coefficient model for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is an ordered 5-tuple (a, alpha_s, delta_C, delta, alpha).\n    test_cases = [\n        (6.2, 0.35, 0.8, 0.015, 0.10),  # Case 1 (pre-stall)\n        (6.2, 0.35, 0.8, 0.015, 0.35),  # Case 2 (near stall, sharp transition)\n        (6.2, 0.35, 0.8, 0.015, 0.42),  # Case 3 (post-stall)\n        (6.2, 0.35, 0.8, 0.10, 0.35),   # Case 4 (near stall, gentle transition)\n        (6.2, 0.35, 0.0, 0.020, 0.30),  # Case 5 (linear model)\n    ]\n\n    results = []\n    for case in test_cases:\n        a, alpha_s, delta_c, delta, alpha = case\n        \n        # Argument for the hyperbolic functions\n        u = (alpha - alpha_s) / delta\n        \n        # Lift coefficient C_L(alpha)\n        # C_L = a*alpha - delta_C * S(alpha)\n        # S(alpha) = 0.5 * (1 + tanh(u))\n        c_l = a * alpha - (delta_c / 2.0) * (1.0 + np.tanh(u))\n        \n        # Derivative d(C_L)/d(alpha)\n        # d(C_L)/d(alpha) = a - (delta_C / (2*delta)) * sech^2(u)\n        # sech(u) = 1/cosh(u)\n        cosh_u = np.cosh(u)\n        # Avoid division by zero if cosh_u is somehow zero, though it's always = 1.\n        sech_u_sq = (1.0 / cosh_u)**2 if cosh_u != 0 else 0.0\n        dcl_dalpha = a - (delta_c / (2.0 * delta)) * sech_u_sq\n        \n        # Absolute condition number\n        k_abs = np.abs(dcl_dalpha)\n        \n        # Relative condition number\n        # Handle the case where C_L(alpha) is zero\n        if c_l == 0.0:\n            k_rel = np.nan\n        else:\n            k_rel = np.abs((alpha / c_l) * dcl_dalpha)\n            \n        results.append([k_abs, k_rel])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with no spaces after commas.\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2382100"}, {"introduction": "在计算科学中，识别问题只是第一步，更重要的是学会如何解决问题。本练习将引导你从诊断走向“治疗”，处理一个由偏微分方程离散化后产生的典型病态线性系统。你将为一个泊松方程的有限差分矩阵构建一个Jacobi预条件子，并定量地比较预处理前后系统条件数的变化 [@problem_id:2382055]。通过这个过程，你不仅能加深对病态问题成因的理解，还能掌握一种提高解算器鲁棒性和效率的实用技术。", "problem": "给定一个线性系统族，它由一维稳态扩散（泊松型）方程产生，该方程定义在单位区间上，并带有齐次狄利克雷边界条件。设 $k(x)  0$ 为一个标量传导率函数，并考虑在 $x \\in [0,1]$ 上的边值问题，其中 $u(0) = 0$ 且 $u(1) = 0$：\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{du}{dx}\\right) = f(x).\n$$\n使用 $n$ 个内部点和均匀的网格间距 $h = \\frac{1}{n+1}$ 对此算子进行离散化。将内部节点位置表示为 $x_i = i h$ (其中 $i = 1,2,\\dots,n$)，将交界面位置表示为 $x_{i+\\frac{1}{2}} = \\left(i+\\frac{1}{2}\\right) h$ (其中 $i = 0,1,\\dots,n$)。构造对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其元素为\n$$\nA_{i,i} = \\frac{k\\!\\left(x_{i-\\frac{1}{2}}\\right) + k\\!\\left(x_{i+\\frac{1}{2}}\\right)}{h^2}, \\quad\nA_{i,i-1} = -\\frac{k\\!\\left(x_{i-\\frac{1}{2}}\\right)}{h^2}, \\quad\nA_{i,i+1} = -\\frac{k\\!\\left(x_{i+\\frac{1}{2}}\\right)}{h^2},\n$$\n其中约定 $A_{i,i-1}$ 仅在 $i \\ge 2$ 时存在，$A_{i,i+1}$ 仅在 $i \\le n-1$ 时存在。此模板对应于一种一致的中心差分格式，该格式使用在交界面上采样的传导率来离散通量。\n\n令 Jacobi 预条件子定义为对角矩阵 $D = \\mathrm{diag}(A)$，并令对称预处理算子为\n$$\nS = D^{-\\frac{1}{2}} A D^{-\\frac{1}{2}}.\n$$\n对于任意对称正定矩阵 $X$，定义其谱条件数为\n$$\n\\kappa_2(X) = \\frac{\\lambda_{\\max}(X)}{\\lambda_{\\min}(X)},\n$$\n其中 $\\lambda_{\\max}(X)$ 和 $\\lambda_{\\min}(X)$ 分别是 $X$ 的最大和最小特征值。\n\n任务：对于下方的每个测试用例，按定义构造 $A$，构造 $D$ 和 $S$，并计算以下三元实数组\n$$\n\\Big(\\kappa_2(A), \\ \\kappa_2(S), \\ \\frac{\\kappa_2(A)}{\\kappa_2(S)}\\Big).\n$$\n将三个数字中的每一个都四舍五入到小数点后六位。\n\n测试套件（通常，将 $x$ 作为弧度使用；由于在此设置中所有量都是无量纲的，因此不需要物理单位）：\n- 测试 1 (均匀介质，中等规模)：$n = 50$，$k(x) = 1$ 对于所有 $x \\in [0,1]$。\n- 测试 2 (分段高对比度介质)：$n = 50$，$k(x) = 1$ 对于 $x  0.5$，$k(x) = 100$ 对于 $x \\ge 0.5$。\n- 测试 3 (边缘规模)：$n = 1$，$k(x) = 1 + x$ 对于 $x \\in [0,1]$。\n- 测试 4 (振荡高对比度介质)：$n = 51$，$k(x) = 100$ 如果 $\\lfloor 20 x \\rfloor$ 是偶数，并且 $k(x) = 1$ 如果 $\\lfloor 20 x \\rfloor$ 是奇数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表，按上述顺序排列。每个内部列表是该测试用例的三个四舍五入后的浮点数，例如：\n\"[[a1,b1,c1],[a2,b2,c2],[a3,b3,c3],[a4,b4,c4]]\"\n其中每个 $a_j$、$b_j$ 和 $c_j$ 都是一个小数点后有六位数字的十进制数。", "solution": "对问题陈述进行验证。\n\n步骤1：提取已知条件。\n- 方程：$-\\frac{d}{dx}\\left(k(x)\\frac{du}{dx}\\right) = f(x)$ 对于 $x \\in [0,1]$。\n- 边界条件：$u(0) = 0$，$u(1) = 0$。\n- 离散化：$n$ 个内部点，均匀网格间距 $h = \\frac{1}{n+1}$。\n- 节点：$x_i = i h$ 对于 $i = 1,2,\\dots,n$。\n- 交界面：$x_{i+\\frac{1}{2}} = \\left(i+\\frac{1}{2}\\right) h$ 对于 $i = 0,1,\\dots,n$。\n- 矩阵 $A \\in \\mathbb{R}^{n \\times n}$：对称正定，其元素为 $A_{i,i} = \\frac{k(x_{i-\\frac{1}{2}}) + k(x_{i+\\frac{1}{2}})}{h^2}$, $A_{i,i-1} = -\\frac{k(x_{i-\\frac{1}{2}})}{h^2}$, $A_{i,i+1} = -\\frac{k(x_{i+\\frac{1}{2}})}{h^2}$。\n- 预条件子：$D = \\mathrm{diag}(A)$。\n- 预处理后的矩阵：$S = D^{-\\frac{1}{2}} A D^{-\\frac{1}{2}}$。\n- 条件数：$\\kappa_2(X) = \\frac{\\lambda_{\\max}(X)}{\\lambda_{\\min}(X)}$。\n- 任务：计算 $(\\kappa_2(A), \\kappa_2(S), \\frac{\\kappa_2(A)}{\\kappa_2(S)})$，针对四个测试用例，并四舍五入到小数点后六位。\n- 测试用例：\n    1.  $n = 50$, $k(x) = 1$。\n    2.  $n = 50$, $k(x) = 1$ 对于 $x  0.5$, $k(x) = 100$ 对于 $x \\ge 0.5$。\n    3.  $n = 1$, $k(x) = 1 + x$。\n    4.  $n = 51$, $k(x) = 100$ 如果 $\\lfloor 20 x \\rfloor$ 是偶数, $k(x) = 1$ 如果 $\\lfloor 20 x \\rfloor$ 是奇数。\n\n步骤2：验证。\n该问题具有科学依据，是适定且客观的。它描述了一维泊松型方程的标准有限差分离散化，这是计算物理学中的一个基本问题。已知通过此方法在 $k(x)  0$ 的条件下生成的矩阵 $A$ 是对称且正定的，这确保了其特征值为正实数，因此其条件数 $\\kappa_2(A)$ 是良定义且大于等于 $1$ 的。Jacobi 预条件子 $D$ 是 $A$ 的对角部分，其对角元将严格为正，使得其平方根的倒数 $D^{-1/2}$ 是实数且良定义的。由此产生的对称预处理矩阵 $S$ 也是对称且正定的。所有定义和测试用例都已足够精确地指定，可以得到一个唯一的、可验证的解。因此，该问题是有效的。\n\n步骤3：行动。\n问题有效。我们继续进行求解。\n\n求解过程需要实现一个程序，为每个指定的测试用例计算矩阵 $A$ 及其经 Jacobi 预处理后的对应矩阵 $S$ 的谱条件数。方法如下。\n\n对于由内部点数 $n$ 和传导率函数 $k(x)$ 定义的每个测试用例：\n1.  首先，计算网格间距 $h = \\frac{1}{n+1}$。\n\n2.  接着，构造 $n \\times n$ 矩阵 $A$。在实现时，我们可以使用从零开始的索引，其中数组索引 $i, j$ 的范围是从 $0$ 到 $n-1$。数学上的索引 $i$ (从 $1$ 到 $n$) 对应于编程中的索引 $i-1$。\n    - 对角元素是 $A_{i,i} = \\frac{k(x_{i-\\frac{1}{2}}) + k(x_{i+\\frac{1}{2}})}{h^2}$。在程序术语中，对于从 $0$ 到 $n-1$ 的索引 `i`，这是 `A[i,i] = (k_func((i + 0.5)*h) + k_func((i + 1.5)*h)) / h**2`。\n    - 非对角元素由 $A_{i,i+1} = -\\frac{k(x_{i+\\frac{1}{2}})}{h^2}$ 和 $A_{i,i-1} = -\\frac{k(x_{i-\\frac{1}{2}})}{h^2}$ 定义。由于问题公式的对称性，$A_{i, j} = A_{j, i}$。对于从 $0$ 到 $n-2$ 的索引 `i`，上对角线元素是 `A[i,i+1] = -k_func((i + 1.5)*h) / h**2`。下对角线通过对称性填充，即 `A[i+1,i] = A[i,i+1]`。\n\n3.  Jacobi 预条件子 $D$ 是一个对角矩阵，其对角元为 $A$ 的对角元。我们提取这个对角线，即 $D_{ii} = A_{ii}$。\n\n4.  构造对称预处理矩阵 $S = D^{-\\frac{1}{2}} A D^{-\\frac{1}{2}}$。其元素由 $S_{ij} = \\frac{A_{ij}}{\\sqrt{D_{ii} D_{jj}}}$ 给出。在计算上，这是通过首先计算 $D^{-1/2}$ 的对角元素向量（即 $1/\\sqrt{A_{ii}}$），然后对矩阵 $A$ 进行缩放来实现的。$S$ 的对角元素都等于 $1$。\n\n5.  对 $X=A$ 和 $X=S$ 分别计算谱条件数 $\\kappa_2(X)$。由于 $A$ 和 $S$ 是对称正定的，它们的特征值是正实数。我们使用可靠的数值方法（例如 `numpy.linalg.eigh` 中实现的方法）计算每个矩阵的全部特征值谱。条件数是最大特征值 $\\lambda_{\\max}$ 与最小特征值 $\\lambda_{\\min}$ 的比值。\n    $$\n    \\kappa_2(X) = \\frac{\\lambda_{\\max}(X)}{\\lambda_{\\min}(X)}\n    $$\n\n6.  最后，组装分析三元组 $(\\kappa_2(A), \\kappa_2(S), \\frac{\\kappa_2(A)}{\\kappa_2(S)})$。比率 $\\frac{\\kappa_2(A)}{\\kappa_2(S)}$ 衡量了 Jacobi 预条件子在减小条件数方面的有效性。大于 $1$ 的值表示有所改进。三元组中的三个值都按要求四舍五入到小数点后六位。\n\n此过程被系统地应用于四个测试用例。\n- 测试 1 ($n=50$, $k(x)=1$)：对于常数 $k(x)$，矩阵 $A$ 是标准离散拉普拉斯算子的一个倍数。其对角阵 $D$ 是单位矩阵的一个倍数。因此，$S$ 是 $A$ 的一个缩放，它们的条件数相同，从而得到 $\\kappa_2(A) / \\kappa_2(S) = 1$。\n- 测试 2 ($n=50$，高对比度跳跃)：$k(x)$ 中的巨大跳跃导致 $A$ 元素量级的巨大变化，从而产生一个大的 $\\kappa_2(A)$。Jacobi 预条件子通过缩放每一行来缓解这种变化。我们预期 $\\kappa_2(S) \\ll \\kappa_2(A)$ 并且会有一个大的改进比。\n- 测试 3 ($n=1$)：这是一个 $1 \\times 1$ 矩阵的平凡情况。对于任何标量矩阵 $A = [c]$ (其中 $c \\ne 0$)，$\\lambda_{\\max} = \\lambda_{\\min} = c$，因此 $\\kappa_2(A) = 1$。对 $S$ 也同样成立，因此结果预期为 $(1, 1, 1)$。\n- 测试 4 ($n=51$，振荡对比度)：$k(x)$ 在 $1$ 和 $100$ 之间的快速振荡构成了一个困难的情况。$A$ 的元素及其对角阵 $D$ 显著波动，导致一个大的条件数。预计 Jacobi 预处理会提供一些好处，但其局部性可能不足以完全解决由不同长度尺度上的振荡引起的病态条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the result.\n    \"\"\"\n\n    def k_func_1(x):\n        return 1.0\n\n    def k_func_2(x):\n        return 1.0 if x  0.5 else 100.0\n\n    def k_func_3(x):\n        return 1.0 + x\n\n    def k_func_4(x):\n        # The floor of 20*x is an integer. Check if it's even or odd.\n        return 100.0 if np.floor(20.0 * x) % 2 == 0 else 1.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (50, k_func_1),\n        (50, k_func_2),\n        (1, k_func_3),\n        (51, k_func_4),\n    ]\n\n    results = []\n    for n, k_func in test_cases:\n        result_triplet = calculate_condition_numbers(n, k_func)\n        results.append(result_triplet)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{r[0]:.6f},{r[1]:.6f},{r[2]:.6f}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef calculate_condition_numbers(n, k_func):\n    \"\"\"\n    Builds matrices A and S, and computes their condition numbers.\n    \n    Args:\n        n (int): The number of interior grid points.\n        k_func (function): The conductivity function k(x).\n\n    Returns:\n        tuple: A triplet of floats (kappa_A, kappa_S, ratio).\n    \"\"\"\n\n    # For n=0, matrices are empty. Problem constraints imply n=1.\n    # For n=1, matrix is 1x1, condition number is 1, a special case.\n    if n == 1:\n        # For a 1x1 matrix, lambda_max = lambda_min, so kappa = 1.\n        # This holds for A and S.\n        return (1.0, 1.0, 1.0)\n\n    h = 1.0 / (n + 1.0)\n    \n    # Construct the matrix A\n    A = np.zeros((n, n))\n    h2 = h * h\n\n    # Vectorized calculation of k values at interfaces\n    # Interfaces are at (i + 0.5) * h for i = 0, ..., n\n    interface_x = (np.arange(n + 1) + 0.5) * h\n    k_at_interfaces = np.array([k_func(x) for x in interface_x])\n\n    for i in range(n):\n        # In mathematical notation, this is row i+1\n        # Interface indices are i and i+1, corresponding to x_{i+1/2} and x_{i+3/2}\n        k_imhalf = k_at_interfaces[i]\n        k_iphalf = k_at_interfaces[i+1]\n\n        # Diagonal entry\n        A[i, i] = (k_imhalf + k_iphalf) / h2\n        # Off-diagonal entries\n        if i  n - 1:\n            A[i, i + 1] = -k_iphalf / h2\n            A[i + 1, i] = -k_iphalf / h2 # By symmetry argument in problem description\n\n    # Eigenvalues and condition number of A\n    eigvals_A = np.linalg.eigh(A)[0]\n    kappa_A = eigvals_A[-1] / eigvals_A[0]\n\n    # Construct the symmetrically preconditioned matrix S\n    D_diag = np.diag(A)\n    D_inv_sqrt_diag = 1.0 / np.sqrt(D_diag)\n    \n    # Efficiently compute S = D^{-1/2} A D^{-1/2} using element-wise multiplication\n    # with an outer product of the scaling vector.\n    S = A * np.outer(D_inv_sqrt_diag, D_inv_sqrt_diag)\n    \n    # Eigenvalues and condition number of S\n    eigvals_S = np.linalg.eigh(S)[0]\n    kappa_S = eigvals_S[-1] / eigvals_S[0]\n    \n    # Ratio\n    ratio = kappa_A / kappa_S\n\n    return (round(kappa_A, 6), round(kappa_S, 6), round(ratio, 6))\n\nsolve()\n```", "id": "2382055"}]}