{"hands_on_practices": [{"introduction": "理论联系实践的第一步是理解测量不确定性如何通过物理公式传播。本练习将通过一个基于斯特藩-玻尔兹曼定律 ($P = \\sigma A T^4$) 的思想实验，向您展示当测量温度 $T$ 时存在一个微小的相对误差，计算出的辐射功率 $P$ 的误差会被如何放大。通过这个练习，您将掌握分析幂律关系中相对误差传播的关键技能，这是实验数据分析的一项基础。[@problem_id:2370476]", "problem": "一个热辐射实验使用斯特藩-玻尔兹曼定律测量一个理想黑体表面的总辐射功率，该定律指出辐射功率由 $P=\\sigma A T^{4}$ 给出，其中 $P$ 是功率，$\\sigma$ 是斯特藩-玻尔兹曼常数，$A$ 是发射面积，$T$ 是绝对温度。假设发射面积 $A$ 和斯特藩-玻尔兹曼常数 $\\sigma$ 是精确已知的，唯一的测量不确定度来源是温度 $T$。如果测量的温度 $T$ 的相对误差为 $1/100$，求计算出的辐射功率 $P$ 的相应相对误差。将最终答案表示为一个不带单位的小数。不要使用百分号。无需四舍五入。", "solution": "对问题陈述进行验证。\n\n**第一步：提取已知条件**\n- 控制方程是斯特藩-玻尔兹曼定律：$P = \\sigma A T^{4}$。\n- 变量 $P$ 是辐射功率。\n- 常数 $\\sigma$ 是斯特藩-玻尔兹曼常数，其值精确已知。\n- 变量 $A$ 是发射面积，其值精确已知。\n- 变量 $T$ 是绝对温度，并且是测量不确定度的唯一来源。\n- 测量的温度 $T$ 的相对误差给定为 $\\frac{1}{100}$。\n\n**第二步：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它基于物理学的基本原理——斯特藩-玻尔兹曼定律。这是一个误差传播分析中的适定问题。问题的表述客观而精确。它包含了推导唯一解所需的所有信息，明确指出 $\\sigma$ 和 $A$ 的不确定度为零。问题设定自成体系，没有矛盾或模糊之处。\n\n**第三步：结论与行动**\n该问题被认定为有效。将提供解答。\n\n辐射功率 $P$ 和绝对温度 $T$ 之间的关系由以下函数给出：\n$$P(T) = \\sigma A T^{4}$$\n在这里，斯特藩-玻尔兹曼常数 $\\sigma$ 和面积 $A$ 被认为是精确的，意味着它们相关的不确定度为零。$P$ 的不确定度完全来自对 $T$ 的测量不确定度。\n\n为了确定相对误差的传播，我们采用对数微分法，这对于幂律关系是最有效的方法。我们对等式两边取自然对数：\n$$\\ln(P) = \\ln(\\sigma A T^{4})$$\n利用对数的性质，我们可以展开右边：\n$$\\ln(P) = \\ln(\\sigma) + \\ln(A) + \\ln(T^{4})$$\n$$\\ln(P) = \\ln(\\sigma) + \\ln(A) + 4\\ln(T)$$\n接下来，我们求这个表达式的全微分，以关联变量的无穷小变化：\n$$d(\\ln(P)) = d(\\ln(\\sigma)) + d(\\ln(A)) + d(4\\ln(T))$$\n这得到：\n$$\\frac{dP}{P} = \\frac{d\\sigma}{\\sigma} + \\frac{dA}{A} + 4\\frac{dT}{T}$$\n对于小的、有限的不确定度，我们可以用有限差分（$\\delta$）来近似这些微分（$\\mathit{d}$）：\n$$\\frac{\\delta P}{P} \\approx \\frac{\\delta \\sigma}{\\sigma} + \\frac{\\delta A}{A} + 4\\frac{\\delta T}{T}$$\n这个方程用 $P$ 所依赖的量的相对误差来表示 $P$ 的相对误差。\n\n根据问题陈述，$\\sigma$ 和 $A$ 是精确已知的。这意味着它们的不确定度为零：$\\delta \\sigma = 0$ 和 $\\delta A = 0$。因此，它们的相对误差也为零：\n$$\\frac{\\delta \\sigma}{\\sigma} = 0$$\n$$\\frac{\\delta A}{A} = 0$$\n将这些代入误差传播公式，可简化为：\n$$\\frac{\\delta P}{P} \\approx 4\\frac{\\delta T}{T}$$\n这表明，计算出的功率 $P$ 的相对误差是测量的温度 $T$ 的相对误差的四倍。我们关心的是这个误差的大小。令 $\\epsilon_X = \\left| \\frac{\\delta X}{X} \\right|$ 表示量 $X$ 的相对误差的大小。那么：\n$$\\epsilon_P = \\left| \\frac{\\delta P}{P} \\right| \\approx 4 \\left| \\frac{\\delta T}{T} \\right| = 4 \\epsilon_T$$\n问题陈述中指出，温度的相对误差是 $\\frac{1}{100}$。所以，$\\epsilon_T = \\frac{1}{100}$。\n代入这个值，我们求得功率的相对误差：\n$$\\epsilon_P \\approx 4 \\times \\frac{1}{100} = \\frac{4}{100}$$\n按照要求，我们将这个结果表示为小数：\n$$\\epsilon_P = 0.04$$\n这就是计算出的辐射功率 $P$ 的相应相对误差。", "answer": "$$\n\\boxed{0.04}\n$$", "id": "2370476"}, {"introduction": "即使物理模型和数学公式完全正确，有限精度的浮点运算也会在计算中引入误差。本练习将让您亲手编写代码，来揭示一种名为“灾难性抵消”的严重数值误差，它发生在对两个几乎相等的数进行相减时。通过比较一个直接计算式和一个经过代数变换后的等价表达式 $f(a) = \\sqrt{a^2 + 1} - a$，您将直观地理解算法的数值稳定性为何至关重要。[@problem_id:2370414]", "problem": "考虑实值函数 $f(a) = \\sqrt{a^2 + 1} - a$，其中 $a \\in \\mathbb{R}_{>0}$。当 $a$ 很大时，$f(a)$ 中的减法运算涉及两个几乎相等的正数，这在标准浮点运算中可能导致灾难性抵消。将近似值 $\\tilde{y}$ 相对于参考值 $y$ 的绝对误差定义为 $| \\tilde{y} - y |$，并将相对误差定义为 $| \\tilde{y} - y | / | y |$。\n\n你的任务是编写一个完整的、可运行的程序，该程序针对 $a$ 的每个指定测试值，计算：\n1. 使用标准双精度浮点运算进行简单的直接计算 $f_{\\text{naive}}(a) = \\sqrt{a^2 + 1} - a$。\n2. 使用相同的算术方法计算一个数学上等价的参考值 $f_{\\text{ref}}(a) = \\dfrac{1}{\\sqrt{a^2 + 1} + a}$。\n\n然后，对每个 $a$ 计算绝对误差 $E_{\\text{abs}}(a) = \\left| f_{\\text{naive}}(a) - f_{\\text{ref}}(a) \\right|$ 和相对误差 $E_{\\text{rel}}(a) = \\left| f_{\\text{naive}}(a) - f_{\\text{ref}}(a) \\right| \\big/ \\left| f_{\\text{ref}}(a) \\right|$。将所有数值结果表示为无量纲数。\n\n对 $a$ 使用以下测试套件：\n- $a = 1$\n- $a = 10^{4}$\n- $a = 10^{8}$\n- $a = 10^{16}$\n- $a = 10^{-8}$\n\n最终输出格式：你的程序应产生单行输出，该输出包含一个由方括号括起来的逗号分隔列表，其顺序与测试套件相同。每个元素本身必须是一个双元素列表 $[E_{\\text{abs}}(a), E_{\\text{rel}}(a)]$。例如，具有三个测试用例的输出将类似于 $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$，其中每个 $x_i$ 和 $y_i$ 都是十进制数。", "solution": "问题要求在计算正实数 $a \\in \\mathbb{R}_{>0}$ 的函数 $f(a) = \\sqrt{a^2 + 1} - a$ 时，对数值误差进行分析。具体来说，我们必须将一种简单的计算方法与一种数学上等价但在数值上更优的方法进行比较，并使用绝对和相对误差度量来量化其差异。\n\n问题陈述已经过验证，并且科学合理、适定且客观。它展示了浮点运算中灾难性抵消的一个经典例子，这是计算科学中的一个基本课题。所有必需的定义、数据和约束均已提供。\n\n问题的核心在于函数在 $a$ 取较大值时的行为。随着 $a$ 变大，$\\sqrt{a^2 + 1}$ 项变得非常接近 $\\sqrt{a^2} = a$。例如，对于 $a=10^8$，我们有 $a^2=10^{16}$。使用二项式展开，$\\sqrt{a^2+1} = a\\sqrt{1+1/a^2} \\approx a(1 + \\frac{1}{2a^2}) = a + \\frac{1}{2a}$。对于 $a=10^8$，这等于 $10^8 + 0.5 \\times 10^{-8}$。减法 $f(a) = (a + \\frac{1}{2a}) - a$ 涉及两个几乎相同的数。标准双精度浮点运算具有有限的精度（约15-17个十进制位）。当两个几乎相等的数相减时，其前导的最高有效位会相互抵消，导致结果中的有效数字减少。这种精度损失被称为灾难性抵消。对于一个足够大的 $a$ 值，在有限精度下，$a^2+1$ 的值可能与 $a^2$ 无法区分，导致 $\\sqrt{a^2+1}$ 被计算为精确的 $a$，从而使最终结果为 $0$。\n\n为缓解此问题，我们可以对表达式进行代数重构。通过乘以并除以共轭表达式 $\\sqrt{a^2+1} + a$，我们得到一个数值稳定的形式：\n$$\nf(a) = \\sqrt{a^2 + 1} - a = (\\sqrt{a^2 + 1} - a) \\times \\frac{\\sqrt{a^2 + 1} + a}{\\sqrt{a^2 + 1} + a}\n$$\n$$\nf(a) = \\frac{(\\sqrt{a^2+1})^2 - a^2}{\\sqrt{a^2 + 1} + a} = \\frac{(a^2+1) - a^2}{\\sqrt{a^2 + 1} + a} = \\frac{1}{\\sqrt{a^2 + 1} + a}\n$$\n这个我们记为 $f_{\\text{ref}}(a)$ 的修正表达式只涉及加法和最后的除法。这些运算在数值上是稳定的。相近数相减的问题已被消除。因此，使用浮点运算计算的 $f_{\\text{ref}}(a)$ 将比简单计算的 $f_{\\text{naive}}(a) = \\sqrt{a^2+1} - a$ 得出更接近真实数学值的结果。\n\n问题要求我们计算简单公式相对于稳定公式的绝对和相对误差。我们将 $f_{\\text{ref}}(a)$ 的结果视为参考值 $y$，并将 $f_{\\text{naive}}(a)$ 的结果视为近似值 $\\tilde{y}$。\n\n绝对误差定义为：\n$$\nE_{\\text{abs}}(a) = | f_{\\text{naive}}(a) - f_{\\text{ref}}(a) |\n$$\n相对误差定义为：\n$$\nE_{\\text{rel}}(a) = \\frac{| f_{\\text{naive}}(a) - f_{\\text{ref}}(a) |}{| f_{\\text{ref}}(a) |}\n$$\n对于每个 $a$ 的测试值（$1$、$10^4$、$10^8$、$10^{16}$ 和 $10^{-8}$），计算过程如下：\n$1$. 使用双精度浮点表示法定义 $a$ 的值。\n$2$. 计算 $f_{\\text{naive}}(a) = \\sqrt{a^2 + 1} - a$。\n$3$. 计算 $f_{\\text{ref}}(a) = \\frac{1}{\\sqrt{a^2 + 1} + a}$。\n$4$. 使用第2步和第3步的结果计算 $E_{\\text{abs}}(a)$ 和 $E_{\\text{rel}}(a)$。\n\n对于较小的 $a$ 值（例如 $a=1, a=10^{-8}$），$\\sqrt{a^2+1}$ 和 $a$ 两项并不相近，因此灾难性抵消不是一个重要因素。预计误差将在机器精度的数量级。对于较大的 $a$ 值（例如 $a=10^4, a=10^8, a=10^{16}$），我们预计误差，特别是相对误差，会随着灾难性抵消效应变得更加显著而大幅增长。对于 $a=10^8$ 及更大的值，在标准双精度下，$a^2+1$ 将被舍入为 $a^2$，导致 $f_{\\text{naive}}(a)$ 的计算结果为 $0$，从而产生为 $1$ (即 $100\\%$) 的相对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the absolute and relative errors for the naive evaluation\n    of f(a) = sqrt(a^2 + 1) - a against a more numerically stable form.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1.0,\n        1.0e4,\n        1.0e8,\n        1.0e16,\n        1.0e-8,\n    ]\n\n    results = []\n    for a_val in test_cases:\n        # Ensure the value is treated as a double-precision float (numpy's default).\n        a = np.float64(a_val)\n        \n        # 1. Naive direct evaluation, prone to catastrophic cancellation for large a.\n        # f_naive(a) = sqrt(a^2 + 1) - a\n        # a**2 can cause overflow for very large a, but a=1e16 is fine.\n        # The key issue is sqrt(a^2+1) becoming indistinguishable from 'a'.\n        f_naive = np.sqrt(a**2 + 1) - a\n        \n        # 2. Mathematically equivalent reference value, numerically stable.\n        # f_ref(a) = 1 / (sqrt(a^2 + 1) + a)\n        # This form avoids subtracting nearly equal numbers.\n        f_ref = 1 / (np.sqrt(a**2 + 1) + a)\n        \n        # In the edge case where the reference value is exactly zero, which does not\n        # happen for a > 0, we would define the relative error as zero\n        # to avoid division by zero.\n        if f_ref == 0.0:\n            abs_error = np.abs(f_naive - f_ref)\n            rel_error = 0.0 if f_naive == 0.0 else np.inf\n        else:\n            # 3. Compute absolute error.\n            abs_error = np.abs(f_naive - f_ref)\n            \n            # 4. Compute relative error.\n            rel_error = abs_error / np.abs(f_ref)\n            \n        results.append([abs_error, rel_error])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) will convert each inner list [x, y] to its string\n    # representation, e.g., '[1.23, 4.56]'.\n    # ','.join(...) will create the comma-separated list of these strings.\n    # The outer f-string adds the final brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2370414"}, {"introduction": "在真实的物理模拟中，误差不仅仅发生一次，而是在每一步计算中不断累积，最终可能导致模拟结果与真实物理过程大相径庭。本练习将模拟一个简谐振子系统，并比较两种常用数值积分方法：简单的欧拉法和更精确的四阶龙格-库塔法 (RK4)。通过编程追踪误差随时间的演变，您将深刻体会到高阶数值方法在保持长期模拟稳定性和准确性方面的巨大优势。[@problem_id:2370478]", "problem": "您将编写一个完整、可运行的程序，比较两种显式时间步进格式在积分一维简谐振子运动时如何传播误差。所研究的系统由常微分方程 (ODE) $$\\frac{d^{2}x}{dt^{2}} + \\omega^{2} x = 0,$$ 控制，其中 $x$ 是作为时间 $t$ 函数的位移，$\\omega$ 是角频率。通过定义状态向量 $y(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$（其中 $v(t) = \\frac{dx}{dt}$）引入一阶系统。该 ODE 变为 $$\\frac{d}{dt}\\begin{bmatrix} x \\\\ v \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\omega^{2} x \\end{bmatrix}.$$ 初始条件为 $x(0)=x_{0}$ 和 $v(0)=v_{0}$。时间以秒为单位，位移以米为单位，速度以米/秒为单位。角频率 $\\omega$ 以弧度/秒为单位。\n\n基本依据和要求：\n- 使用上述定义性的 ODE、简谐振子的守恒性质，以及显式欧拉法和经典四阶龙格-库塔 (RK4) 时间步进方法的标准算法定义。不要假设任何未声明的稳定性属性；直接根据定义量化误差。\n- 简谐振子的精确解是通过求解具有给定初始条件的线性常系数 ODE 得出的。您必须推导并实现它，以计算每个时间的参考值。\n- 定义缩放状态 $s(t) = \\begin{bmatrix} x(t) \\\\ v(t)/\\omega \\end{bmatrix}$。当 $\\omega$ 为常数时，此缩放使得简谐振子的精确能量范数 $\\|s(t)\\|_{2}$ 保持恒定。\n- 在每个离散时间 $t_{n} = n h$（步长为 $h$），将数值方法的绝对误差定义为 $$E_{\\mathrm{abs}}(t_{n}) = \\left\\| s_{\\mathrm{num}}(t_{n}) - s_{\\mathrm{exact}}(t_{n}) \\right\\|_{2},$$ 相对误差定义为 $$E_{\\mathrm{rel}}(t_{n}) = \\frac{E_{\\mathrm{abs}}(t_{n})}{\\left\\| s_{\\mathrm{exact}}(t_{n}) \\right\\|_{2}}.$$ 此处 $\\|\\cdot\\|_{2}$ 是欧几里得范数。对于具有恒定 $\\omega$ 的简谐振子，只要 $x_{0}$ 和 $v_{0}$ 不全为零，$\\left\\| s_{\\mathrm{exact}}(t_{n}) \\right\\|_{2}$ 就等于恒定的振幅 $\\sqrt{x_{0}^{2} + \\left(v_{0}/\\omega\\right)^{2}}$。\n- 为该一阶系统实现两种积分器：显式欧拉法和经典四阶龙格-库塔法 (RK4)。对于每个测试，追踪 $n = 0, 1, \\dots, N$（其中 $N = T/h$，$T$ 是最终时间）的相对误差 $E_{\\mathrm{rel}}(t_{n})$ 的完整时间历史。然后报告每种方法的最终时间相对误差 $E_{\\mathrm{rel}}(T)$ 和整个轨迹上的最大相对误差 $\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}(t_{n})$。\n\n单位和角度规范：\n- 时间 $t$ 必须以秒为单位，位移 $x$ 以米为单位，速度 $v$ 以米/秒为单位，角频率 $\\omega$ 以弧度/秒为单位。\n- 用于精确解的三角函数必须将角度解释为弧度。\n\n测试套件和参数：\n对于每个测试用例，给定一个五元组 $(\\omega, x_{0}, v_{0}, h, T)$，其含义如上所定义。请精确使用以下四个测试用例：\n- 测试用例 1：$(\\omega, x_{0}, v_{0}, h, T) = (\\,1.0,\\, 1.0,\\, 0.0,\\, 0.01,\\, 10.0\\,)$。\n- 测试用例 2：$(\\omega, x_{0}, v_{0}, h, T) = (\\,1.0,\\, 1.0,\\, 0.0,\\, 0.1,\\, 50.0\\,)$。\n- 测试用例 3：$(\\omega, x_{0}, v_{0}, h, T) = (\\,2.0,\\, 1.0,\\, 0.0,\\, 0.05,\\, 25.0\\,)$。\n- 测试用例 4：$(\\omega, x_{0}, v_{0}, h, T) = (\\,1.0,\\, 1.0,\\, 1.0,\\, 0.25,\\, 20.0\\,)$。\n\n输出规范：\n- 对于每个测试用例，计算四个浮点数：$E_{\\mathrm{rel}}^{\\mathrm{Euler}}(T)$、$E_{\\mathrm{rel}}^{\\mathrm{RK4}}(T)$、$\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}^{\\mathrm{Euler}}(t_{n})$ 和 $\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}^{\\mathrm{RK4}}(t_{n})$。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，每个测试用例贡献一个包含上述顺序的四个浮点数的列表。最终格式必须是\n  $$\\big[ [a_{1}, b_{1}, c_{1}, d_{1}], [a_{2}, b_{2}, c_{2}, d_{2}], [a_{3}, b_{3}, c_{3}, d_{3}], [a_{4}, b_{4}, c_{4}, d_{4}] \\big].$$\n- 每个浮点值必须以科学记数法打印，并四舍五入到 $10$ 位有效数字。\n\n科学真实性和约束：\n- 对于具有给定参数的简谐振子，所有场景在物理上和数值上都是合理的。目标量是无量纲的相对误差。程序必须是自包含的，不需要任何输入，并严格遵循输出格式。", "solution": "所述问题是有效的。这是一个适定的、有科学依据的计算物理练习，要求比较两种标准数值积分格式——显式欧拉法和经典四阶龙格-库塔法——在简谐振子问题上的应用。所有参数、定义和要求都以清晰明确的方式提供。该问题是自包含的，没有逻辑矛盾或事实错误。\n\n求解过程遵循一系列逻辑步骤：首先，我们推导系统的精确解析解，它将作为基准真相。其次，我们为两种数值方法制定迭代更新规则。第三，我们定义用于比较的误差度量。最后，我们描述计算算法，以生成给定测试用例所需的输出。\n\n该系统是一个一维简谐振子，由二阶常微分方程 (ODE) 控制：\n$$\n\\frac{d^{2}x}{dt^{2}} + \\omega^{2} x = 0\n$$\n其中 $x$ 是位移，$t$ 是时间，$\\omega$ 是角频率。通过定义状态向量 $\\mathbf{y}(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$（其中 $v(t) = \\frac{dx}{dt}$ 是速度），将其转换为一个一阶 ODE 系统。系统动力学随后表示为：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y}) = \\begin{bmatrix} v \\\\ -\\omega^{2} x \\end{bmatrix}\n$$\n初始条件为 $\\mathbf{y}(0) = \\begin{bmatrix} x(0) \\\\ v(0) \\end{bmatrix} = \\begin{bmatrix} x_{0} \\\\ v_{0} \\end{bmatrix}$。\n\n此线性常系数 ODE 的精确解通过假设解的形式为 $x(t) = A \\cos(\\omega t) + B \\sin(\\omega t)$ 来求得。应用初始条件：\n$x(0) = A = x_{0}$。\n速度为 $v(t) = \\frac{dx}{dt} = -A\\omega \\sin(\\omega t) + B\\omega \\cos(\\omega t)$。\n$v(0) = B\\omega = v_{0}$，这意味着 $B = \\frac{v_{0}}{\\omega}$。\n因此，状态向量分量的精确解为：\n$$\nx_{\\mathrm{exact}}(t) = x_{0} \\cos(\\omega t) + \\frac{v_{0}}{\\omega} \\sin(\\omega t)\n$$\n$$\nv_{\\mathrm{exact}}(t) = -x_{0} \\omega \\sin(\\omega t) + v_{0} \\cos(\\omega t)\n$$\n这些函数提供了用于与数值近似值进行比较的参考值。\n\n该问题要求为系统 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 实现两种数值积分格式。对于离散时间步长 $h$，我们将时间 $t_{n} = n h$ 处的状态表示为 $\\mathbf{y}_{n}$。\n\n$1.$ **显式欧拉法**：这是一种一阶方法。下一时间步的状态 $\\mathbf{y}_{n+1}$ 通过简单的向前外插得到：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_{n} + h \\mathbf{f}(\\mathbf{y}_{n})\n$$\n以分量形式表示为：\n$$\nx_{n+1} = x_{n} + h v_{n}\n$$\n$$\nv_{n+1} = v_{n} - h \\omega^{2} x_{n}\n$$\n\n$2.$ **经典四阶龙格-库塔 (RK4) 方法**：这是一种四阶方法，以其在精度和计算成本之间的平衡而闻名。更新规则是：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_{n} + \\frac{h}{6} (\\mathbf{k}_{1} + 2\\mathbf{k}_{2} + 2\\mathbf{k}_{3} + \\mathbf{k}_{4})\n$$\n其中，中间斜率 $\\mathbf{k}_{i}$ 的计算如下：\n$$\n\\begin{aligned}\n\\mathbf{k}_{1} &= \\mathbf{f}(\\mathbf{y}_{n}) \\\\\n\\mathbf{k}_{2} &= \\mathbf{f}(\\mathbf{y}_{n} + \\frac{h}{2}\\mathbf{k}_{1}) \\\\\n\\mathbf{k}_{3} &= \\mathbf{f}(\\mathbf{y}_{n} + \\frac{h}{2}\\mathbf{k}_{2}) \\\\\n\\mathbf{k}_{4} &= \\mathbf{f}(\\mathbf{y}_{n} + h\\mathbf{k}_{3})\n\\end{aligned}\n$$\n\n为了量化误差，我们使用缩放状态向量 $\\mathbf{s}(t) = \\begin{bmatrix} x(t) \\\\ v(t)/\\omega \\end{bmatrix}$。对于精确解，此向量的欧几里得范数平方，即 $\\|\\mathbf{s}_{\\mathrm{exact}}(t)\\|_{2}^{2} = x_{\\mathrm{exact}}(t)^2 + (v_{\\mathrm{exact}}(t)/\\omega)^2$，是一个守恒量，等于常数值 $x_{0}^{2} + (v_{0}/\\omega)^{2}$。这为定义相对误差提供了一个稳定的归一化因子。\n\n在每个离散时间 $t_{n}$，绝对误差是数值和精确缩放状态之间的欧几里得距离：\n$$\nE_{\\mathrm{abs}}(t_{n}) = \\| \\mathbf{s}_{\\mathrm{num}}(t_{n}) - \\mathbf{s}_{\\mathrm{exact}}(t_{n}) \\|_{2}\n$$\n相对误差随后定义为：\n$$\nE_{\\mathrm{rel}}(t_{n}) = \\frac{E_{\\mathrm{abs}}(t_{n})}{\\| \\mathbf{s}_{\\mathrm{exact}}(t_{0}) \\|_{2}} = \\frac{\\| \\mathbf{s}_{\\mathrm{num}}(t_{n}) - \\mathbf{s}_{\\mathrm{exact}}(t_{n}) \\|_{2}}{\\sqrt{x_{0}^{2} + (v_{0}/\\omega)^{2}}}\n$$\n只要初始状态非平凡（即 $x_0$ 和 $v_0$ 不全为零），分母在整个模拟过程中保持恒定。\n\n每个测试用例的计算过程如下：\n$1.$ 设置参数 $(\\omega, x_{0}, v_{0}, h, T)$。\n$2.$ 确定步数 $N = T/h$。\n$3.$ 创建时间点数组 $t_{n} = n h$，其中 $n = 0, 1, \\dots, N$。\n$4.$ 计算所有时间点的精确解 $\\mathbf{y}_{\\mathrm{exact}}(t_{n})$。\n$5.$ 使用初始条件 $\\begin{bmatrix} x_{0} \\\\ v_{0} \\end{bmatrix}$ 初始化数值解 $\\mathbf{y}^{\\mathrm{Euler}}_{0}$ 和 $\\mathbf{y}^{\\mathrm{RK4}}_{0}$。\n$6.$ 初始化相对误差历史记录 $E_{\\mathrm{rel}}^{\\mathrm{Euler}}$ 和 $E_{\\mathrm{rel}}^{\\mathrm{RK4}}$，在 $t=0$ 时误差为 $0$。\n$7.$ 对 $n$ 从 $0$ 循环到 $N-1$：\n    a. 使用各自的更新规则计算 $\\mathbf{y}^{\\mathrm{Euler}}_{n+1}$ 和 $\\mathbf{y}^{\\mathrm{RK4}}_{n+1}$。\n    b. 在 $t_{n+1}$ 时刻，为两种方法构建缩放状态向量 $\\mathbf{s}_{\\mathrm{num}}(t_{n+1})$，并获取精确的缩放状态向量 $\\mathbf{s}_{\\mathrm{exact}}(t_{n+1})$。\n    c. 计算两种方法的 $E_{\\mathrm{rel}}(t_{n+1})$ 并记录其值。\n$8.$ 循环结束后，提取在 $t_N = T$ 时的最终相对误差，即 $E_{\\mathrm{rel}}^{\\mathrm{Euler}}(T)$ 和 $E_{\\mathrm{rel}}^{\\mathrm{RK4}}(T)$。\n$9.$ 确定整个轨迹上的最大相对误差，即 $\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}^{\\mathrm{Euler}}(t_{n})$ 和 $\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}^{\\mathrm{RK4}}(t_{n})$。\n$10.$ 按照指定格式报告这四个计算值。\n\n对所有提供的测试用例重复此过程。显式欧拉法预计会显示误差随时间增长（通常是线性的），且误差阶数为 $O(h)$。而 RK4 方法具有更高阶数，预计将在更长的时间内保持更小的误差，其误差阶数为 $O(h^4)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing Euler and RK4 integrators for a simple\n    harmonic oscillator, as specified in the problem statement.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (omega, x0, v0, h, T)\n        (1.0, 1.0, 0.0, 0.01, 10.0),\n        (1.0, 1.0, 0.0, 0.1, 50.0),\n        (2.0, 1.0, 0.0, 0.05, 25.0),\n        (1.0, 1.0, 1.0, 0.25, 20.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, x0, v0, h, T = case\n\n        # Ensure N is an integer to avoid floating-point issues in loop ranges\n        N = int(round(T / h))\n        times = np.linspace(0, T, N + 1)\n\n        # --- Define the ODE system ---\n        def f(y, omega_val):\n            \"\"\"RHS of the ODE system: dy/dt = f(y)\"\"\"\n            x, v = y\n            return np.array([v, -omega_val**2 * x])\n\n        # --- Exact Solution ---\n        # Vectorized calculation for all time points\n        x_exact = x0 * np.cos(omega * times) + (v0 / omega) * np.sin(omega * times)\n        v_exact = -x0 * omega * np.sin(omega * times) + v0 * np.cos(omega * times)\n        s_exact = np.vstack((x_exact, v_exact / omega)).T\n\n        # --- Normalization factor for relative error ---\n        norm = np.sqrt(x0**2 + (v0 / omega)**2)\n        if norm == 0:\n            # Handle trivial case, though not present in test suite\n            all_results.append([0.0, 0.0, 0.0, 0.0])\n            continue\n\n        # --- Numerical Integration ---\n        # Initialize states\n        y_euler = np.array([x0, v0])\n        y_rk4 = np.array([x0, v0])\n        \n        # Histories for relative errors (N+1 points, from t=0 to t=T)\n        rel_err_euler_hist = [0.0]\n        rel_err_rk4_hist = [0.0]\n\n        for i in range(N):\n            # Euler step\n            y_euler = y_euler + h * f(y_euler, omega)\n\n            # RK4 step\n            k1 = f(y_rk4, omega)\n            k2 = f(y_rk4 + 0.5 * h * k1, omega)\n            k3 = f(y_rk4 + 0.5 * h * k2, omega)\n            k4 = f(y_rk4 + h * k3, omega)\n            y_rk4 = y_rk4 + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # --- Error Calculation at step i+1 ---\n            # Scaled numerical states\n            s_euler_num = np.array([y_euler[0], y_euler[1] / omega])\n            s_rk4_num = np.array([y_rk4[0], y_rk4[1] / omega])\n            \n            # Exact scaled state at this time\n            s_exact_current = s_exact[i + 1]\n\n            # Absolute errors\n            abs_err_euler = np.linalg.norm(s_euler_num - s_exact_current)\n            abs_err_rk4 = np.linalg.norm(s_rk4_num - s_exact_current)\n\n            # Relative errors\n            rel_err_euler = abs_err_euler / norm\n            rel_err_rk4 = abs_err_rk4 / norm\n\n            rel_err_euler_hist.append(rel_err_euler)\n            rel_err_rk4_hist.append(rel_err_rk4)\n\n        # --- Collect results for this case ---\n        # Final-time relative errors\n        e_rel_euler_final = rel_err_euler_hist[-1]\n        e_rel_rk4_final = rel_err_rk4_hist[-1]\n        \n        # Maximum relative errors over the trajectory\n        max_e_rel_euler = max(rel_err_euler_hist)\n        max_e_rel_rk4 = max(rel_err_rk4_hist)\n\n        all_results.append([\n            e_rel_euler_final,\n            e_rel_rk4_final,\n            max_e_rel_euler,\n            max_e_rel_rk4\n        ])\n\n    # --- Final Output Formatting ---\n    # Format each number and build the final string representation\n    # Use {:.9e} to get 10 significant digits in scientific notation.\n    case_strings = []\n    for result_set in all_results:\n        formatted_nums = [f\"{num:.9e}\" for num in result_set]\n        case_strings.append(f\"[{','.join(formatted_nums)}]\")\n\n    final_output_str = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2370478"}]}