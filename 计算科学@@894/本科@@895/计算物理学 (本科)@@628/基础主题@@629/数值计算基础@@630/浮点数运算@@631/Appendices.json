{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。我们的第一个练习将深入探讨浮点数运算中的一个典型陷阱：“灾难性抵消” (catastrophic cancellation)。通过使用我们都熟悉的一元二次方程求根公式，你将亲手计算并见证一个在数学上完全正确的公式，为何会在计算机中因为两个相近的数相减而导致结果出现巨大误差 [@problem_id:2393691]。这个练习旨在帮助你建立对数值不稳定性问题的直观理解。", "problem": "考虑一个实系数二次多项式 $p(x) = x^2 - 10^8 x + 1$。本问题中的所有算术运算都在一个规格化的十进制浮点系统中进行，该系统具有$t=8$位有效数字精度，采用“舍入到最近，偶数优先”的舍入规则，并且指数范围足够大，以至于遇到的量不会发生上溢或下溢。每个基本运算（加、减、乘、除和平方根）都先被精确执行，然后根据所述规则舍入到最接近的可表示浮点数，之后才用于任何后续计算。\n\n(a) 在此浮点系统中使用标准二次求根公式，计算将作为 $p(x)=0$ 的根返回的两个浮点数。\n\n(b) 然后，仅使用对首一二次多项式精确成立的恒等式（特别是，两根之积等于 $c/a$ 这一事实），通过首先在该浮点系统中使用标准二次求根公式计算较大模的根，然后使用精确的乘积关系在该浮点系统中获得较小模的根，来计算该较小模根的数值稳定值。\n\n仅报告(b)部分得到的稳定的较小模的根作为最终答案，保留八位有效数字。请以$a \\times 10^b$（其中$1 \\leq |a| < 10$）的科学计数法形式表示您的最终答案。", "solution": "该问题要求在指定的浮点算术系统中计算一个二次多项式的根。在进行求解之前，我们必须验证问题的陈述。\n\n给定条件如下：\n1.  二次多项式为 $p(x) = x^2 - 10^8 x + 1$。由此，我们确定系数为 $a=1$、$b=-10^8$ 和 $c=1$。\n2.  算术框架是一个规格化的十进制浮点系统。\n3.  精度为$t=8$位有效数字。\n4.  舍入规则是舍入到最近，偶数优先。\n5.  不存在上溢或下溢。\n6.  每个基本算术运算（$+$, $-$, $*$, $/$, $\\sqrt{\\cdot}$）都单独进行舍入。\n\n该问题具有科学依据，是数值分析中关于有效位损失的一个标准练习。它的提法是适定的，所有必需的参数都已定义。它是客观的，其结构是合理的。因此，该问题被认为是有效的。我们开始求解。\n\n二次方程 $ax^2 + bx + c = 0$ 的根由标准二次求根公式给出：\n$$x_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$\n所有计算都在指定的浮点系统中执行，我们用 $fl(\\cdot)$ 表示。\n\n首先，我们计算判别式 $D = b^2 - 4ac$。\n系数为 $a = 1.0000000 \\times 10^0$, $b = -1.0000000 \\times 10^8$, $c = 1.0000000 \\times 10^0$。\n$b^2$ 项是 $(-10^8)^2 = 10^{16}$。这可以精确表示为 $1.0000000 \\times 10^{16}$。\n$4ac$ 项是 $4 \\times 1 \\times 1 = 4$。这可以精确表示为 $4.0000000 \\times 10^0$。\n\n我们现在必须计算减法 $fl(b^2 - 4ac) = fl(10^{16} - 4)$。为了执行此操作，必须移动较小的数以匹配较大数的指数。\n$$10^{16} - 4 = (1.0000000 \\times 10^{16}) - (0.0000000000000004 \\times 10^{16})$$\n$10^{16}$ 的尾数是 $1.0000000$。该系统存储 $t=8$ 位有效数字。减去 $4$ 影响的数字远远超出了系统的精度范围。尾数的减法是 $1.0000000 - 0.0000000000000004$，当舍入回 $8$ 位有效数字时，结果仍然是 $1.0000000$。这是一个典型的(大数)吞噬(小数)的例子。\n因此，计算出的判别式是：\n$$\\hat{D} = fl(b^2 - 4ac) = 1.0000000 \\times 10^{16}$$\n接下来，我们计算 $\\hat{D}$ 的平方根。\n$$fl(\\sqrt{\\hat{D}}) = fl(\\sqrt{1.0000000 \\times 10^{16}}) = 1.0000000 \\times 10^8$$\n这是一个精确计算。我们记此结果为 $\\hat{S} = 1.0000000 \\times 10^8$。\n\n现在，我们按照(a)部分的要求计算两个根。\n较大的根 $\\hat{x}_1$ 是使用分子中的“+”号计算的，因为 $-b = 10^8$ 是正数。\n$$\\hat{x}_1 = fl\\left(\\frac{-b + \\hat{S}}{2a}\\right) = fl\\left(\\frac{10^8 + 10^8}{2}\\right) = fl\\left(\\frac{2 \\times 10^8}{2}\\right) = 1.0000000 \\times 10^8$$\n这个计算是数值稳定的，因为它涉及两个数量级相似的正数相加。\n\n较小的根 $\\hat{x}_2$ 是使用“−”号计算的。\n$$\\hat{x}_2 = fl\\left(\\frac{-b - \\hat{S}}{2a}\\right) = fl\\left(\\frac{10^8 - 10^8}{2}\\right) = fl\\left(\\frac{0}{2}\\right) = 0$$\n这个计算遭受了灾难性抵消。两个几乎相等的数 $-b$ 和 $\\hat{S}$ 相减导致有效数字的完全丧失。计算出的根 $\\hat{x}_2=0$ 是极其不准确的。真实的小根约等于 $10^{-8}$。\n\n对于(b)部分，我们被要求使用一种数值稳定的方法。对于一个首一二次方程 $x^2 + \\frac{b}{a}x + \\frac{c}{a} = 0$，Vieta 定理指出，两根之积为 $x_1 x_2 = \\frac{c}{a}$。\n在我们的例子中，$a=1$ 且 $c=1$，所以 $x_1 x_2 = 1$。\n\n稳定的步骤是首先计算较大模的根 $\\hat{x}_1$，我们已经发现它是准确的：\n$$\\hat{x}_1 = 1.0000000 \\times 10^8$$\n然后，我们使用乘积关系来找到较小的根 $\\hat{x}'_2$：\n$$\\hat{x}'_2 = fl\\left(\\frac{c/a}{\\hat{x}_1}\\right)$$\n代入数值：\n$$\\hat{x}'_2 = fl\\left(\\frac{1}{1.0000000 \\times 10^8}\\right) = fl(1.0000000 \\times 10^{-8})$$\n数字 $1.0000000 \\times 10^{-8}$ 在指定的浮点系统中是可以精确表示的。因此，计算得出该值，没有任何舍入误差。\n稳定的较小根是：\n$$\\hat{x}'_2 = 1.0000000 \\times 10^{-8}$$\n该值是要求的最终答案，用科学计数法表示，并保留八位有效数字。", "answer": "$$\\boxed{1.0000000 \\times 10^{-8}}$$", "id": "2393691"}, {"introduction": "在理解了单次运算可能产生的灾难性抵消后，我们接下来将关注误差如何在系列运算中累积。这个练习将介绍 Kahan 求和算法，这是一种在处理大量数字求和时，能有效减少舍入误差累积的补偿求和技术 [@problem_id:2393714]。通过亲手实现该算法，并将其与简单的累加求和进行对比，你将深刻体会到在处理数量级差异巨大的数据时，选择正确的数值算法对于保证结果的准确性是多么重要。", "problem": "您需要研究浮点加法中舍入误差的累积，方法是将朴素的逐项求和与一种补偿求和方法进行对比。您必须实现一个完整的、可运行的程序。该程序针对一个固定的测试集，使用 Kahan 求和算法计算朴素浮点和与补偿和，并将两者与使用精确有理数算术计算的高精度参考值进行比较。您的程序不能读取任何输入，且必须按照下述规定打印单行输出。\n\n使用的基本原理是带有“四舍五入到最近”规则的浮点运算标准舍入误差模型：对于任意两个实数 $a$ 和 $b$，计算出的浮点加法满足 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中 $|\\delta|\\le u$，$u$ 是所选格式的单位舍入误差。您也可以利用以下事实：$n$ 个项的朴素求和在最坏情况下会累积 $O(nu)$ 数量级的舍入误差，而补偿求和技术旨在通过显式地处理因舍入而丢失的低位比特来减少主阶误差的累积。\n\n要求：\n- 实现两个对双精度实数列表进行操作的求和例程：\n  - 一个朴素求和，对每个项 $x_i$ 通过 $s \\leftarrow s + x_i$ 迭代更新一个累加和。\n  - 一个 Kahan 补偿求和，使用一个补偿变量来携带每次加法中丢失的低位信息。\n- 为了获得高精度参考值，请使用精确有理数算术（例如，使用一种将每个项 $x_i$ 表示为分数并进行精确求和的有理数类型）计算每个列表的精确和。该参考值作为实数算术中的基准真相。\n\n测试集：\n- 使用以下四个测试用例，每个用例都指定为一个有序列表。每个列表都包含大数量级的项和小数量级的项，以暴露灾难性抵消和有效数字丢失问题。\n  1. $[\\,10^{16},\\,1,\\,-10^{16}\\,]$。\n  2. $[\\,10^{16},\\,\\underbrace{1,\\,1,\\,\\dots,\\,1}_{100000\\ \\text{times}},\\,-10^{16}\\,]$。其精确数学和为 $100000$。\n  3. $[\\,1,\\,\\underbrace{10^{-16},\\,10^{-16},\\,\\dots,\\,10^{-16}}_{100000\\ \\text{times}},\\,-1\\,]$。其精确数学和为 $100000\\cdot 10^{-16}=10^{-11}$。\n  4. $[\\,10^{16},\\,\\underbrace{10^{-6},\\,10^{-6},\\,\\dots,\\,10^{-6}}_{100000\\ \\text{times}},\\,-10^{16}\\,]$。其精确数学和为 $100000\\cdot 10^{-6}=10^{-1}$。\n\n计算与比较：\n- 对每个测试用例，计算：\n  - 朴素浮点和 $s_{\\text{naive}}\\in\\mathbb{R}$。\n  - Kahan 浮点和 $s_{\\text{kahan}}\\in\\mathbb{R}$。\n  - 使用精确有理数算术计算的精确参考和 $s_{\\star}\\in\\mathbb{R}$。\n- 对每个测试用例，计算绝对误差 $e_{\\text{naive}}=\\lvert s_{\\text{naive}}-s_{\\star}\\rvert$ 和 $e_{\\text{kahan}}=\\lvert s_{\\text{kahan}}-s_{\\star}\\rvert$，并确定一个布尔标志 $\\text{better}$，当且仅当 $e_{\\text{kahan}}<e_{\\text{naive}}$ 时为真。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，列表内有四个对应于每个测试用例的记录，顺序与上述测试集相同。每条记录本身必须是一个包含四个元素的列表，顺序为 $[\\,s_{\\text{naive}},\\,s_{\\text{kahan}},\\,s_{\\star},\\,\\text{better}\\,]$，其中 $s_{\\text{naive}}$、$s_{\\text{kahan}}$ 和 $s_{\\star}$ 以浮点数形式输出，$\\text{better}$ 是一个布尔值。将这四条记录聚合到一个列表中，并将其作为单行打印，元素以逗号分隔，并用方括号括起来，例如\n  $[\\, [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,], [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,], [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,], [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,] \\,]$。\n\n注意：\n- 不涉及物理单位。\n- 不使用角度。\n- 不使用百分比；所有量均为 $\\mathbb{R}$ 中的实数。\n- 实现必须是自包含的，并且无需用户输入即可运行。使用精确有理数算术或您的语言标准库中可用的多精度工具来计算 $s_{\\star}$，以使对 $e_{\\text{naive}}$ 和 $e_{\\text{kahan}}$ 的比较有意义。", "solution": "所述问题是有效的。它在科学上基于数值分析（特别是浮点运算）的既定原则。问题定义明确，清晰地定义了要实现的算法，提供了完整的测试数据集和明确的输出格式。问题是客观的，没有矛盾或信息缺失。我们可以着手解决。\n\n所要解决的根本问题是，计算机浮点加法不满足结合律，并且会产生舍入误差。对于两个实数 $a$ 和 $b$，它们的浮点和模型为 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中相对误差 $\\lvert\\delta\\rvert$ 受单位舍入误差 $u$ 的限制。当对一个数列求和时，这些微小的误差会累积起来。本分析将对比一种朴素求和方法与一种旨在减轻这种误差累积的补偿方法。\n\n**1. 朴素求和**\n\n最直接的方法是遍历数字列表 $\\{x_i\\}_{i=1}^n$，并将和累加到一个浮点变量 $s$ 中。更新规则是 $s \\leftarrow \\operatorname{fl}(s + x_i)$。该方法的主要弱点是**大数吞小数（swamping）**。如果累加和 $s$ 的量级远大于待加项 $x_i$ 的量级，那么 $x_i$ 的贡献可能会在舍入过程中部分或完全丢失。例如，在标准双精度算术中，如果 $s \\approx 10^{16}$ 且 $x_i = 1$，则操作 $\\operatorname{fl}(10^{16} + 1)$ 的计算结果为 $10^{16}$，因为精度不足以精确表示结果。项 $x_i$ 被有效丢弃。\n\n**2. Kahan 补偿求和**\n\nKahan 求和算法是一种能显著减少舍入误差累积的技术。它维护第二个变量，即一个补偿量 $c$，用于累积每一步中产生的误差。对于输入序列中的每个项 $x_i$，该算法执行以下操作：\n1.  校正当前项：$y \\leftarrow x_i - c$。此步骤从当前项中减去先前加法累积的误差。\n2.  加到总和中：$t \\leftarrow s + y$。这是标准的浮点加法，如果 $s$ 很大，可能会丢失 $y$ 的低位比特。\n3.  恢复误差：$c \\leftarrow (t - s) - y$。这是关键步骤。项 $(t - s)$ 表示 $y$ 中已成功加到 $s$ 上的部分。通过减去原始（已校正的）项 $y$，我们分离出加法 $s+y$ 产生的舍入误差的相反数。这个误差存储在 $c$ 中。\n4.  更新总和：$s \\leftarrow t$。\n\n这个迭代过程将每次加法中丢失的“零头”带到下一次计算中，并将其合并进去，从而确保最终累积的误差比朴素求和的情况小得多。Kahan 求和的误差界为 $O(u + N\\epsilon u)$ 数量级，其中 $\\epsilon$ 与机器精度有关，这与朴素求和的最坏情况误差 $O(Nu)$ 相比是巨大的改进。\n\n**3. 精确有理数算术**\n\n为了建立一个权威的基准真相（记为 $s_{\\star}$），我们必须在没有任何浮点误差的情况下计算总和。这通过使用精确有理数算术来实现。每个以浮点值形式给出的输入数字，首先被转换为其精确的有理数表示，即分数 $p/q$，其中 $p, q \\in \\mathbb{Z}$。所有后续的加法都使用精确的分数运算法则进行，例如 $\\frac{a}{b} + \\frac{c}{d} = \\frac{ad+bc}{bd}$。此过程没有浮点系统的表示误差和计算误差，从而得出输入值的真实数学和。\n\n**评估过程**\n\n对于四个指定的测试用例中的每一个，我们计算朴素和 $s_{\\text{naive}}$、Kahan 和 $s_{\\text{kahan}}$ 以及精确参考和 $s_{\\star}$。这些测试用例经过专门设计，通过混合量级差异巨大的数字，来暴露朴素求和的失效模式，特别是大数吞小数（swamping）和灾难性抵消。然后我们计算绝对误差 $e_{\\text{naive}} = \\lvert s_{\\text{naive}} - s_{\\star} \\rvert$ 和 $e_{\\text{kahan}} = \\lvert s_{\\text{kahan}} - s_{\\star} \\rvert$。当且仅当 $e_{\\text{kahan}} < e_{\\text{naive}}$ 时，布尔标志 $\\text{better}$ 被设为 $\\text{True}$，这定量地展示了对于给定输入，Kahan 算法具有更高的准确性。最终输出的结构是一个记录列表，每个记录包含 $[s_{\\text{naive}}, s_{\\text{kahan}}, s_{\\star}, \\text{better}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy\nfrom fractions import Fraction\n\ndef naive_sum(numbers: list[float]) -> float:\n    \"\"\"\n    Computes the sum of a list of numbers using a naive iterative approach.\n    \"\"\"\n    s = 0.0\n    for x in numbers:\n        s += x\n    return s\n\ndef kahan_sum(numbers: list[float]) -> float:\n    \"\"\"\n    Computes the sum of a list of numbers using the Kahan summation algorithm\n    to reduce the accumulation of floating-point error.\n    \"\"\"\n    s = 0.0  # The running sum.\n    c = 0.0  # The compensation for lost low-order bits.\n    for x in numbers:\n        y = x - c    # c is the error from the previous sum.\n        t = s + y    # s is large, y is small, so low-order digits of y are lost.\n        c = (t - s) - y  # (t - s) recovers the high-order part of y.\n                         # Subtracting y recovers the low part, negated.\n        s = t        # Algebraically, c should be 0. But with rounding, it's not.\n    return s\n\ndef exact_sum(numbers: list[float]) -> float:\n    \"\"\"\n    Computes the exact sum of a list of floating-point numbers by\n    converting them to Fractions and using rational arithmetic.\n    \"\"\"\n    s = Fraction(0)\n    for x in numbers:\n        s += Fraction(x)\n    return float(s)\n\ndef solve():\n    \"\"\"\n    Runs the full test suite, comparing naive and Kahan summation against\n    an exact rational arithmetic reference, and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: A simple case of catastrophic cancellation.\n        [1e16, 1.0, -1e16],\n        # Case 2: Summing many small numbers in the presence of a large one.\n        [1e16] + [1.0] * 100000 + [-1e16],\n        # Case 3: Summing many tiny numbers that are smaller than machine epsilon\n        # relative to the initial sum.\n        [1.0] + [1e-16] * 100000 + [-1.0],\n        # Case 4: A similar case to #2, but with smaller additions.\n        [1e16] + [1e-6] * 100000 + [-1e16],\n    ]\n\n    results = []\n    for case_data in test_cases:\n        # Compute the sum using all three methods.\n        s_naive = naive_sum(case_data)\n        s_kahan = kahan_sum(case_data)\n        s_star = exact_sum(case_data)\n        \n        # Calculate the absolute errors for both floating-point methods.\n        e_naive = abs(s_naive - s_star)\n        e_kahan = abs(s_kahan - s_star)\n        \n        # Determine if Kahan's method produced a smaller error.\n        better = e_kahan < e_naive\n        \n        # Store the record for this test case.\n        record = [s_naive, s_kahan, s_star, better]\n        results.append(record)\n\n    # Final print statement in the exact required format.\n    # The format template from the prompt is used: print(f\"[{','.join(map(str, results))}]\")\n    # str(list) in Python automatically includes spaces, which matches the example\n    # format diagram '[ [ . , . , . , . ], ... ]'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393714"}, {"introduction": "掌握了精确计算的算法后，我们将把目光从计算本身转向实际的编程逻辑。最后一个练习将通过一个生动的恒温器模拟，展示为何直接使用 $==$ 对浮点数进行相等性比较是危险的，这也是科学与工程软件中一类常见的编程陷阱 [@problem_id:2395285]。通过这个实践，你将直观地看到在这种朴素逻辑下的失败场景，并学会使用“容差” (tolerance) 进行比较的稳健编程方法，从而将理论知识应用于解决实际问题中。", "problem": "您将编写一个完整、可运行的程序，通过一个简单的恒温器模拟，来演示为何朴素的浮点数比较模式 $\\,\\texttt{if (a/b == c)}\\,$ 是危险的。该场景是一个离散时间恒温控制器，它以步进方式将系统加热至一个设定点，并通过将近期传感器读数的平均值与该设定点进行比较，来决定何时关闭加热器。您的程序必须模拟两种控制器：一种是使用精确相等比较 $\\,a/b == c\\,$ 的朴素控制器，另一种是使用容差来判断是否达到目标的鲁棒控制器。\n\n从以下基本原理开始：\n\n1. 电气和电子工程师协会 (IEEE) 754 浮点数算术标准以二进制表示实数，并在每次运算后舍入到一个附近的可表示数。许多十进制小数，如 $\\,0.1\\,$、$\\,0.2\\,$ 和 $\\,19.95\\,$，在二进制中无法精确表示，因此加法和除法等运算会产生舍入误差。\n2. 离散时间控制器在步长 $\\,n = 0,1,2,\\dots\\,$ 处进行采样，并计算有限窗口内的平均值。该平均值的形式为 $\\,a/b\\,$，其中 $\\,a\\,$ 是浮点数读数的累加和，$\\,b\\,$ 是窗口大小（或窗口大小内可用样本的数量）。然后将此平均值与目标设定点 $\\,c\\,$进行比较。\n\n恒温器模拟模型：在每个离散步长 $\\,n\\,$，当加热器开启时，温度 $\\,T_n\\,$ 会加上一个恒定的加热增量 $\\,\\Delta\\,$。我们忽略冷却和噪声，以隔离浮点数的行为。因此，当加热器开启时，更新规则为 $\\,T_{n+1} = T_n + \\Delta\\,$，初始温度 $\\,T_0\\,$ 为给定值。第 $\\,n\\,$ 步的传感器读数记为 $\\,r_n = T_n\\,$（单位为摄氏度）。\n\n控制逻辑定义：\n\n- 朴素控制器：维护一个近期读数列表，并计算最后 $\\,m\\,$ 个读数的平均值 $\\,\\bar{r} = a/b\\,$（如果可用读数少于 $\\,m\\,$ 个，则计算所有可用读数的平均值）。加热器在第一个满足浮点数比较 $\\,\\bar{r} == c\\,$ 的步长 $\\,n\\,$ 处关闭。\n- 鲁棒控制器：在第一个满足 $\\,\\bar{r} \\ge c - \\tau\\,$（其中 $\\,\\tau > 0\\,$ 是一个很小的容差）的步长 $\\,n\\,$ 处关闭。您必须使用 $\\,\\tau = 10^{-12}\\,$。\n\n您的任务是实现一个程序，为每个测试用例模拟这两种控制器，直至达到最大步数 $\\,N_{\\text{max}}\\,$，并返回每个控制器关闭加热器所需的步数。如果某个控制器在 $\\,N_{\\text{max}}\\,$ 步内没有关闭，则为该控制器报告 $\\,{-1}\\,$。\n\n所有温度单位均为摄氏度；然而，输出是整数（步数），因此没有单位。不涉及角度。不涉及百分比。\n\n测试套件（每个用例指定为一个元组 $\\,\\left(T_0, c, \\Delta, m, N_{\\text{max}}\\right)\\,$）：\n\n1. 用例 A（理想路径，使用精确的二进制分数）：$\\,\\left(19.0,\\, 20.0,\\, 0.5,\\, 1,\\, 20\\right)\\,$。\n2. 用例 B（三个读数产生不精确的十进制平均值）：$\\,\\left(20.0,\\, 20.1,\\, 0.1,\\, 3,\\, 20\\right)\\,$。\n3. 用例 C（目标在十进制下等于一个简单的平均值，但在二进制中可能无法精确表示）：$\\,\\left(19.8,\\, 19.95,\\, 0.05,\\, 2,\\, 20\\right)\\,$。\n4. 用例 D（在精确的十进制算术中，三个值的平均值等于目标，以此强调舍入问题）：$\\,\\left(17.2,\\, 17.3,\\, 0.1,\\, 3,\\, 20\\right)\\,$。\n5. 用例 E（边界条件：已达到设定点）：$\\,\\left(21.5,\\, 21.5,\\, 0.1,\\, 4,\\, 10\\right)\\,$。\n\n模拟和输出的精确要求：\n\n1. 用读数 $\\,r_0 = T_0\\,$ 进行初始化，并在步长 $\\,n=0\\,$ 处检查两个控制器。\n2. 在加热器开启的情况下，在从 $\\,n\\,$ 到 $\\,n+1\\,$ 的每一步，更新 $\\,T_{n+1} = T_n + \\Delta\\,$，附加 $\\,r_{n+1} = T_{n+1}\\,$，并重新计算最后 $\\,m\\,$ 个读数的平均值 $\\,\\bar{r}\\,$（如果可用读数少于 $\\,m\\,$ 个，则计算所有可用读数的平均值）。在该步计算出新平均值后，立即检查控制器条件。\n3. 记录每个控制器关闭的第一个步长 $\\,n\\,$。如果在 $\\,N_{\\text{max}}\\,$ 步内没有发生关闭事件，则记录 $\\,{-1}\\,$。\n4. 对于每个测试用例，输出两个整数：朴素控制器的步数，后跟鲁棒控制器的步数。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有结果，这些结果被扁平化为一个用方括号括起来的逗号分隔列表。因此，对于上述五个用例，您将按顺序 $\\,\\left[\\text{naive}_A, \\text{robust}_A, \\text{naive}_B, \\text{robust}_B, \\dots, \\text{naive}_E, \\text{robust}_E\\right]\\,$ 输出一个长度为 $\\,10\\,$ 的列表。", "solution": "该问题要求实现一个恒温器的离散时间模拟，以证明使用浮点数进行直接相等比较的不可靠性。这是计算科学中的一个经典问题，其根源在于数字的表示原理。\n\n其基本原理是 IEEE 754 浮点数算术标准。实数以有限位数的二进制格式存储。因此，没有有限二进制表示的十进制小数，例如 $0.1$（在二进制中为 $0.0001100110011...$），无法被精确存储。每次算术运算都可能引入微小的舍入误差。当这些运算被串联起来时，例如在计算平均值的求和过程中，这些误差会累积。结果是，一个在纯数学中本应产生精确值的计算，例如 $\\sum_{i=1}^{3} (x + (i-1)\\Delta) / 3 = x+\\Delta$，在计算机中可能会产生一个与真实数学结果有无穷小差异的值。这使得直接比较 `a/b == c` 变得脆弱且很可能失败。\n\n该模拟将对一个系统的温度 $T_n$ 在离散时间步长 $n=0, 1, 2, \\dots$ 上进行建模。系统从初始温度 $T_0$ 开始。在每一步，加热器会增加一个恒定的增量 $\\Delta$，因此温度根据规则 $T_{n+1} = T_n + \\Delta$ 演变。第 $n$ 步的传感器读数就是 $r_n = T_n$。\n\n模拟了两种控制器策略来决定何时关闭加热器：\n\n1.  **朴素控制器**：该控制器计算最近读数的平均值。设 $S_n = \\{r_i | \\max(0, n-m+1) \\le i \\le n\\}$ 是在步长 $n$ 处大小为 $m$ 的平均窗口中的读数集合。窗口大小为 $\\min(n+1, m)$。平均值为 $\\bar{r}_n = \\frac{1}{|S_n|} \\sum_{r \\in S_n} r$。该控制器的逻辑是在第一个满足条件 $\\bar{r}_n == c$ 的步长 $n$ 处关闭加热器，其中 $c$ 是目标设定点。这是一种直接的浮点数比较。\n\n2.  **鲁棒控制器**：该控制器使用相同的平均值计算 $\\bar{r}_n$。然而，其关闭条件是 $\\bar{r}_n \\ge c - \\tau$，其中 $\\tau$ 是一个小的正容差，给定为 $\\tau = 10^{-12}$。这种方法承认，由于离散化和舍入，计算出的平均值可能不完全等于设定点。一旦平均值与设定点“足够接近”或略微超过设定点，它就会关闭加热器。\n\n对于每个测试用例 $(T_0, c, \\Delta, m, N_{\\text{max}})$，模拟算法按以下步骤进行：\n\n1.  初始化温度 $T_{\\text{current}} = T_0$ 和一个包含初始值 $r_0 = T_0$ 的读数列表。\n2.  将两个控制器的停止步数初始化为 $-1$。\n3.  **步长 $n=0$**：使用初始平均值 $\\bar{r}_0 = r_0$ 检查两个控制器的条件。如果某个条件满足，则将其停止步数记录为 $0$。\n4.  **步长 $n=1, \\dots, N_{\\text{max}}$**： a. 更新温度：$T_{\\text{current}} \\leftarrow T_{\\text{current}} + \\Delta$。 b. 将新读数 $r_n = T_{\\text{current}}$ 附加到读数列表中。 c. 计算最后 $\\min(n+1, m)$ 个读数的平均值 $\\bar{r}_n$。 d. 对于每个尚未停止的控制器，检查其条件。如果条件满足，则将当前步长 $n$ 记录为其停止步数。\n5.  如果在迭代到 $N_{\\text{max}}$ 后，任何控制器的停止步数仍为 $-1$，则意味着其条件从未被满足。\n\n让我们分析一个例子，用例 D：$(T_0, c, \\Delta, m) = (17.2, 17.3, 0.1, 3)$。在理想算术中：\n- 在 $n=0$ 时，$T_0 = 17.2$。平均值为 $17.2$。\n- 在 $n=1$ 时，$T_1 = 17.2 + 0.1 = 17.3$。$\\{17.2, 17.3\\}$ 的平均值为 $17.25$。\n- 在 $n=2$ 时，$T_2 = 17.3 + 0.1 = 17.4$。$\\{17.2, 17.3, 17.4\\}$ 的平均值为 $\\frac{17.2+17.3+17.4}{3} = \\frac{51.9}{3} = 17.3$。\n所以，从数学上讲，平均值在步长 $n=2$ 时等于设定点 $c=17.3$。\n\n然而，在浮点数算术中，值 $0.1$ 无法被精确表示。对这个不精确的值进行重复加法会导致累积误差。温度 $T_1$ 和 $T_2$ 及其后续的总和将不是精确的数学值。计算出的平均值 $\\bar{r}_2$ 将会是一个非常接近但并不等于 $17.3$ 的值。一个典型的浮点数结果可能是 $17.300000000000004$。\n\n-   **朴素控制器**：检查 $\\bar{r}_2 == 17.3$ 的结果将为假。随着温度继续升高，平均值将进一步偏离 $17.3$，因此朴素控制器将永远不会关闭。\n-   **鲁棒控制器**：检查 $\\bar{r}_2 \\ge 17.3 - 10^{-12}$ 的结果将为真，因为 $17.300000000000004 \\ge 17.299999999999$。鲁棒控制器在步长 $n=2$ 处正确关闭。\n\n这种差异说明了为什么基于容差的比较对于可靠的控制系统以及其他涉及浮点数的应用至关重要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the thermostat simulations and print the results.\n    \"\"\"\n    # Test suite defined in the problem statement.\n    # Each case is a tuple: (T_0, c, Delta, m, N_max)\n    test_cases = [\n        (19.0, 20.0, 0.5, 1, 20),      # Case A\n        (20.0, 20.1, 0.1, 3, 20),      # Case B\n        (19.8, 19.95, 0.05, 2, 20),    # Case C\n        (17.2, 17.3, 0.1, 3, 20),      # Case D\n        (21.5, 21.5, 0.1, 4, 10),      # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        naive_steps, robust_steps = simulate_thermostat(*case)\n        results.extend([naive_steps, robust_steps])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_thermostat(T_0, c, delta, m, N_max):\n    \"\"\"\n    Simulates naive and robust thermostat controllers for a given set of parameters.\n\n    Args:\n        T_0 (float): Initial temperature.\n        c (float): Setpoint temperature.\n        delta (float): Heating increment per step.\n        m (int): Averaging window size.\n        N_max (int): Maximum number of simulation steps.\n\n    Returns:\n        tuple[int, int]: A tuple containing the turn-off step for the naive\n                         and robust controllers, respectively. Returns -1 if\n                         a controller does not turn off within N_max steps.\n    \"\"\"\n    # Use floating-point numbers for all a-priori known physical quantities\n    T_0_f = float(T_0)\n    c_f = float(c)\n    delta_f = float(delta)\n    tau = 1e-12\n\n    # --- Naive Controller Simulation ---\n    naive_stop_step = -1\n    T_current_naive = T_0_f\n    readings_naive = [T_0_f]\n    \n    # Step n=0 check\n    if np.mean([T_0_f]) == c_f:\n        naive_stop_step = 0\n    else:\n        for n in range(1, N_max + 1):\n            T_current_naive += delta_f\n            readings_naive.append(T_current_naive)\n            \n            window_size = min(len(readings_naive), m)\n            readings_to_average = readings_naive[-window_size:]\n            avg_reading = np.mean(readings_to_average)\n\n            if avg_reading == c_f:\n                naive_stop_step = n\n                break\n    \n    # --- Robust Controller Simulation ---\n    robust_stop_step = -1\n    T_current_robust = T_0_f\n    readings_robust = [T_0_f]\n\n    # Step n=0 check\n    if np.mean([T_0_f]) >= c_f - tau:\n        robust_stop_step = 0\n    else:\n        for n in range(1, N_max + 1):\n            T_current_robust += delta_f\n            readings_robust.append(T_current_robust)\n\n            window_size = min(len(readings_robust), m)\n            readings_to_average = readings_robust[-window_size:]\n            avg_reading = np.mean(readings_to_average)\n            \n            if avg_reading >= c_f - tau:\n                robust_stop_step = n\n                break\n\n    return naive_stop_step, robust_stop_step\n\nsolve()\n```", "id": "2395285"}]}