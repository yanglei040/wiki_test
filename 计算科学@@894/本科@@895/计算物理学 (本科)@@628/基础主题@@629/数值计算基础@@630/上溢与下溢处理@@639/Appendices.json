{"hands_on_practices": [{"introduction": "高斯函数是科学和工程中最重要的函数之一。本练习将指导你实现一个“安全”的高斯概率密度函数，通过在对数空间中进行计算，可以巧妙地避免直接计算指数项时可能遇到的上溢和下溢问题 [@problem_id:2423348]。这个实践不仅解决了具体问题，更重要的是让你掌握一种在数值计算中扩展动态范围、保证结果稳定性的核心策略。", "problem": "要求您实现一个数值稳健的程序，该程序用于计算给定参数下的高斯（正态）概率密度函数，同时能处理在有限精度算术中可能导致数值下溢或上溢的极端情况。\n\n设高斯概率密度函数对于实数 $x$、实数 $\\mu$ 和严格为正的 $\\sigma$ 定义如下：\n$$\n\\operatorname{pdf}(x,\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{2}\\right).\n$$\n所有计算都必须基于电气和电子工程师协会（IEEE）754 标准所指定的标准双精度浮点格式。您必须确保关于可表示性遵循以下输出策略：\n- 如果 $\\operatorname{pdf}(x,\\mu,\\sigma)$ 的精确数学值严格小于最小的可表示的严格为正的双精度数 $2^{-1074}$，您的程序必须为该测试用例输出浮点值 $0.0$。\n- 如果 $\\operatorname{pdf}(x,\\mu,\\sigma)$ 的精确数学值严格大于最大的可表示的有限双精度数 $(2-2^{-52})\\times 2^{1023}$，您的程序必须为该测试用例输出对应于正无穷大的浮点值。\n- 否则，您的程序必须以标准双精度格式输出 $\\operatorname{pdf}(x,\\mu,\\sigma)$ 的有限浮点值。\n\n本问题不涉及物理单位，也不使用角度。\n\n测试套件和要求的输出格式：\n- 对以下参数三元组 $(x,\\mu,\\sigma)$ 的有序列表，计算 $\\operatorname{pdf}(x,\\mu,\\sigma)$ 的值：\n  1. $(0,0,1)$,\n  2. $(8,0,1)$,\n  3. $(38,0,1)$,\n  4. $(40,0,1)$,\n  5. $(0,0,10^{-320})$,\n  6. $(0,0,10^{50})$,\n  7. $\\left(-10^{308},\\,10^{308},\\,1\\right)$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表中的结果顺序与测试套件中的顺序相同，例如 $[r_1,r_2,\\dots,r_7]$，其中每个 $r_k$ 是一个符合上述可表示性策略的浮点数。不要打印任何额外的字符或行。", "solution": "如问题所述，任务是实现高斯概率密度函数 $\\operatorname{pdf}(x,\\mu,\\sigma)$ 的一个数值稳健的计算方法。该函数针对实值参数 $x$ 和 $\\mu$ 以及严格为正的实数参数 $\\sigma$ 定义，其公式为：\n$$\n\\operatorname{pdf}(x,\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{2}\\right),\n$$\n该实现必须能正确处理在使用标准双精度浮点算术进行朴素直接计算时可能导致数值上溢或下溢的情况。\n\n该问题具有科学依据、是适定的、客观的，并包含了得出唯一解所需的所有信息。这是计算科学中的一个经典问题，展示了维持数值稳定性的关键技术。因此，该问题是有效的，我们着手进行求解。\n\n开发稳健算法的基本原则是避免在浮点数范围的极限处可能发生灾难性失效的运算。对该公式的朴素实现涉及以下几个潜在的失效点：\n$1$. 如果 $\\sigma$ 非常小（趋近于零），前置因子 $\\frac{1}{\\sigma\\sqrt{2\\pi}}$ 可能会上溢。\n$2$. 如果 $\\sigma$ 非常大，前置因子可能会下溢到 $0.0$，从而丢失所有精度。\n$3$. 如果 $|x-\\mu|$ 很大而 $\\sigma$ 很小，标准化变量 $z = \\frac{x-\\mu}{\\sigma}$ 本身可能会上溢。\n$4$. 如果 $|z|$ 很大，即使 $z$ 本身是可表示的，$z^2$ 项也可能会上溢。\n$5$. 如果 $|z|$ 很大，指数项 $\\exp(-0.5 z^2)$ 可能会下溢到 $0.0$。\n\n为缓解这些问题，我们在对数空间中重构计算过程。这是数值方法中一种标准且强大的技术。我们不直接计算 $\\operatorname{pdf}$，而是首先计算其自然对数，我们将其记为 $L$：\n$$\nL = \\log(\\operatorname{pdf}(x,\\mu,\\sigma)) = \\log\\left(\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{1}{2}z^2\\right)\\right)\n$$\n利用对数的性质，该表达式可简化为各项之和：\n$$\nL = \\log\\left(\\frac{1}{\\sigma\\sqrt{2\\pi}}\\right) + \\log\\left(\\exp\\!\\left(-\\frac{1}{2}z^2\\right)\\right) \\\\\nL = -\\log(\\sigma\\sqrt{2\\pi}) - \\frac{1}{2}z^2 \\\\\nL = -\\log(\\sigma) - \\frac{1}{2}\\log(2\\pi) - \\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2\n$$\n这种形式用前置因子和指数项的对数之和替代了它们的乘积。与乘法相比，加法更不容易发生虚假的上溢和下溢，从而扩展了可以计算出有意义结果的输入动态范围。\n\n算法流程如下：\n$1$. 对于一组给定的参数 $(x, \\mu, \\sigma)$，我们首先计算对数概率密度（log-PDF）$L$ 的各项。常数项 $\\frac{1}{2}\\log(2\\pi)$ 可以预先计算。\n$2$. 我们计算 $\\log(\\sigma)$ 和标准化变量 $z = \\frac{x-\\mu}{\\sigma}$。值得注意的是，对于极端值（例如测试用例7），$x-\\mu$ 的中间计算可能会上溢。然而，正如在 `numpy` 中实现的 IEEE 754 算术，通过传播无穷大值（`inf`）来正确处理这种情况。例如，如果 $x-\\mu$ 上溢为 $-\\infty$，那么 $z$ 变为 $-\\infty$，$z^2$ 变为 $+\\infty$，指數项 $-0.5z^2$ 变为 $-\\infty$，总的对数概率密度 $L$ 也变为 $-\\infty$。这导致最终结果为 $\\exp(-\\infty) = 0.0$，这是数学上正确的极限。因此，不需要对 $z^2$ 的上溢进行特殊检查，因为标准的 `inf` 传播机制会正确处理它。\n$3$. 然后我们计算总的对数概率密度：$L = (-\\log(\\sigma) - \\frac{1}{2}\\log(2\\pi)) - \\frac{1}{2}z^2$。\n$4$. 在通过取指数计算最终结果之前，我们必须将 $L$ 与同样转换到对数空间中的指定阈值进行比较。问题根据双精度数的限制定义了上溢和下溢的边界。\n    - **上溢条件**：如果结果严格大于最大的有限双精度数 $D_{\\text{max}} = (2-2^{-52})\\times 2^{1023}$，则结果发生上溢。这等价于检查 $L > \\log(D_{\\text{max}})$。如果满足此条件，函数必须返回正无穷大。\n    - **下溢条件**：如果结果严格小于最小的正（非规格化）双精度数 $D_{\\text{min\\_sub}} = 2^{-1074}$，则结果发生下溢。这等价于检查 $L < \\log(D_{\\text{min\\_sub}}) = -1074\\log(2)$。如果满足此条件，函数必须返回 $0.0$。\n$5$. 如果 $L$ 位于这两个对数阈值之间，则结果在数值上是可表示的且计算是稳定的。然后我们计算最终的 PDF 值为 $\\exp(L)$。\n\n这种基于对数计算原理的设计确保了实现是稳健、准确的，并且遵守处理极端数值的指定策略。它能正确处理所有测试用例，包括标准输入和那些旨在导致朴素实现发生上溢或下溢的用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef robust_gaussian_pdf(x: float, mu: float, sigma: float) -> float:\n    \"\"\"\n    Computes the Gaussian probability density function in a numerically robust way.\n\n    Args:\n        x: The point at which to evaluate the PDF.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution (must be > 0).\n\n    Returns:\n        The value of the PDF, handling overflow and underflow per IEEE 754 spec.\n    \"\"\"\n    # Pre-calculated constant for efficiency and clarity.\n    # log(sqrt(2*pi))\n    LOG_SQRT_2PI = 0.5 * np.log(2.0 * np.pi)\n\n    # Thresholds for overflow and underflow in log-space, as per the problem.\n    # log(DBL_MAX)\n    LOG_MAX_FLOAT = np.log(np.finfo(np.double).max)\n    # log(2**-1074)\n    LOG_MIN_SUBNORMAL = -1074.0 * np.log(2.0)\n\n    # Per the problem statement, sigma is strictly positive. A check for sigma <= 0\n    # would be good practice in a general-purpose library, but it is not\n    # required for the given test suite.\n    \n    # Standardized variable z. Numpy's handling of large numbers will correctly\n    # propagate 'inf' if (x - mu) overflows, which leads to the correct\n    # final result of 0.0.\n    z = (x - mu) / sigma\n    \n    # Calculate the PDF in log-space to prevent intermediate over/underflow.\n    # log(pdf) = -log(sigma) - log(sqrt(2*pi)) - 0.5 * z**2\n    log_pdf = -np.log(sigma) - LOG_SQRT_2PI - 0.5 * z**2\n    \n    # Check against the specified representability thresholds.\n    if log_pdf > LOG_MAX_FLOAT:\n        return np.inf\n    \n    if log_pdf < LOG_MIN_SUBNORMAL:\n        return 0.0\n        \n    # If within representable range, compute the final value.\n    return np.exp(log_pdf)\n\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 0.0, 1.0),\n        (8.0, 0.0, 1.0),\n        (38.0, 0.0, 1.0),\n        (40.0, 0.0, 1.0),\n        (0.0, 0.0, 1e-320),\n        (0.0, 0.0, 1e50),\n        (-1e308, 1e308, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        x_val, mu_val, sigma_val = case\n        result = robust_gaussian_pdf(x_val, mu_val, sigma_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string conversion for floats, including 'inf', is correct here.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution.\nsolve()\n```", "id": "2423348"}, {"introduction": "随机游走是统计物理中模拟扩散等现象的基本模型。这个练习要求你计算一个粒子在大量步数后处于特定位置的概率，这会涉及到对巨大数值的二项式系数 $\\binom{N}{k}$ 的处理 [@problem_id:2423389]。你将学习如何利用对数伽马函数（log-gamma function） $\\ln(\\Gamma(z))$ 来代替阶乘，从而在对数域中稳定地完成计算，这是处理组合统计问题的关键计算技巧。", "problem": "您需要编写一个完整的程序，用于计算在一维离散时间格点上的随机游走中，经过给定步数后处于指定位置的概率。在每个时间步，位置以概率 $p$ 变化 $+1$，以概率 $1-p$ 变化 $-1$。设 $X_N$ 表示从第 0 步的原点出发，经过 $N$ 步后的位置。对于给定的三元组 $(N,x,p)$，其中 $N \\in \\mathbb{Z}_{\\ge 0}$，$x \\in \\mathbb{Z}$，且 $p \\in [0,1]$，计算概率 $\\mathbb{P}(X_N = x)$。您的程序必须能稳健地处理在计算组合项和幂时出现的上溢和下溢，并且当最终概率在双精度浮点运算中发生下溢时，必须返回 $0.0$。\n\n必须根据基本原理强制执行以下条件：\n- 如果 $|x| > N$，则该事件不可能发生，概率必须为 $0.0$。\n- 如果 $N + x$ 为奇数，则该事件不可能发生，概率必须为 $0.0$。\n- 对于边界情况 $p = 0$ 和 $p = 1$，其确切概率是明确定义的：当 $p = 0$ 时，当且仅当 $x = -N$ 时概率为 $1.0$，否则为 $0.0$；当 $p = 1$ 时，当且仅当 $x = +N$ 时概率为 $1.0$，否则为 $0.0$。\n\n不涉及物理单位。所有答案必须作为无量纲实数返回。不使用角度。\n\n您的程序必须为以下每个测试用例评估概率，并汇总结果：\n- $(N,x,p) = (\\,10,\\,2,\\,0.5\\,)$\n- $(N,x,p) = (\\,9,\\,2,\\,0.5\\,)$\n- $(N,x,p) = (\\,1000,\\,1000,\\,0.5\\,)$\n- $(N,x,p) = (\\,5000,\\,5000,\\,0.5\\,)$\n- $(N,x,p) = (\\,1000000,\\,0,\\,0.5\\,)$\n- $(N,x,p) = (\\,200000,\\,200,\\,0.501\\,)$\n- $(N,x,p) = (\\,1000,\\, -1000,\\, 1.0\\times 10^{-12}\\,)$\n- $(N,x,p) = (\\,1000,\\, 1000,\\, 1.0\\times 10^{-12}\\,)$\n- $(N,x,p) = (\\,50,\\, 50,\\, 1.0\\,)$\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的、逗号分隔的列表，该列表包含按上述顺序排列的 $9$ 个概率值。\n- 每个概率值都必须采用科学记数法格式，小数点后恰好有 12 位有效数字，例如：$[\\,1.234000000000e-02,\\ldots\\,]$。\n- 输出中不允许有任何额外的文本或换行。", "solution": "所述问题是有效的。它在科学上基于概率论和统计力学的原理，特别是支配离散时间随机游走的二项分布。该问题是适定的、客观的，并包含获得唯一解所需的所有信息。其核心挑战在于计算，涉及处理数值上溢和下溢，这是计算物理学中的一个标准课题。\n\n我们的任务是计算一维随机游走从原点 $X_0 = 0$ 出发，经过 $N$ 步后到达位置 $x$ 的概率 $\\mathbb{P}(X_N = x)$。在每一步，位置以概率 $p$ 变化 $+1$，以概率 $q = 1-p$ 变化 $-1$。\n\n设 $N_+$ 为向右（位置增加 1）的步数，$N_-$ 为向左（位置减少 1）的步数。总步数为 $N$。\n$$N_+ + N_- = N$$\n最终位置 $x$ 由向右和向左的步数之差给出。\n$$N_+ - N_- = x$$\n这个二元线性方程组可以解出 $N_+$ 和 $N_-$。两方程相加得到 $2N_+ = N+x$，第一个方程减去第二个方程得到 $2N_- = N-x$。因此，我们有：\n$$N_+ = \\frac{N+x}{2}$$\n$$N_- = \\frac{N-x}{2}$$\n为使 $N_+$ 和 $N_-$ 成为有效的计数，它们必须是非负整数。这带来了两个基本约束：\n1.  奇偶性约束：和 $N+x$（以及差 $N-x$）必须是偶数。如果 $N+x$ 是奇数，就不可能在 $N$ 步内到达位置 $x$，因此概率为 $0$。这等价于 $N$ 和 $x$ 必须具有相同的奇偶性这一条件。\n2.  边界约束：任一方向的步数都不能为负。这要求 $N+x \\ge 0$ 和 $N-x \\ge 0$，这等价于 $|x| \\le N$。如果目标位置 $x$ 离原点的距离超过了步数 $N$，则这是一个不可能事件，概率为 $0$。\n\n如果满足这些条件，问题就等价于在 $N$ 次伯努利试验中获得恰好 $N_+$ 次成功的概率，其中成功的概率（向右一步）是 $p$。这由二项分布描述。到达位置 $x$ 的不同路径数，等于从总共 $N$ 步中选择 $N_+$ 步向右走的方法数，这由二项式系数 $\\binom{N}{N_+}$ 给出。任何一条这样的路径的概率是 $p^{N_+} (1-p)^{N_-}$。\n\n因此，总概率是：\n$$\\mathbb{P}(X_N = x) = \\binom{N}{N_+} p^{N_+} (1-p)^{N_-}$$\n代入 $N_+$ 和 $N_-$ 的表达式：\n$$\\mathbb{P}(X_N = x) = \\binom{N}{(N+x)/2} p^{(N+x)/2} (1-p)^{(N-x)/2}$$\n\n对于较大的 $N$，直接计算该公式在数值上是不稳定的。二项式系数中的阶乘项（例如 $N!$）和幂次项（例如 $p^{N_+}$）会迅速超过标准浮点表示的限制，导致上溢或下溢。\n\n正确且稳健的计算策略是处理概率的对数。设 $P = \\mathbb{P}(X_N = x)$。我们计算 $\\ln(P)$：\n$$\\ln(P) = \\ln\\left(\\binom{N}{N_+}\\right) + N_+\\ln(p) + N_-\\ln(1-p)$$\n二项式系数的对数可以使用对数伽马函数 $\\ln(\\Gamma(z))$ 来表示，因为 $\\Gamma(k+1) = k!$。\n$$\\ln\\left(\\binom{N}{k}\\right) = \\ln(N!) - \\ln(k!) - \\ln((N-k)!) = \\ln(\\Gamma(N+1)) - \\ln(\\Gamma(k+1)) - \\ln(\\Gamma(N-k+1))$$\n这是一个数值上稳定的计算，由标准科学库（如 `scipy.special.gammaln`）提供。\n\n对数概率的最终表达式是：\n$$\\ln(P) = \\ln(\\Gamma(N+1)) - \\ln(\\Gamma(N_++1)) - \\ln(\\Gamma(N_-+1)) + N_+\\ln(p) + N_-\\ln(1-p)$$\n为了在 $p$ 非常小时提高数值精度，项 $\\ln(1-p)$ 应使用 `log1p` 函数计算，即 `log1p(-p)`。\n\n总的算法如下：\n1.  验证输入 $(N, x, p)$。检查基本条件：如果 $|x| > N$ 或 $(N+x)$ 为奇数，则概率恰好为 $0$。\n2.  处理 $p$ 的边界情况。\n    - 如果 $p=0$，则游走是确定性地向左。如果 $x = -N$，概率为 $1$，否则为 $0$。\n    - 如果 $p=1$，则游走是确定性地向右。如果 $x = N$，概率为 $1$，否则为 $0$。\n3.  如果 $0 < p < 1$，计算 $N_+ = (N+x)/2$ 和 $N_- = (N-x)/2$。\n4.  使用对数伽马公式计算对数概率 $\\ln(P)$。\n5.  通过对结果取指数来获得最终概率：$P = \\exp(\\ln(P))$。此操作能正确处理下溢：如果 $\\ln(P)$ 是一个绝对值很大的负数，$\\exp(\\ln(P))$ 在双精度运算中将正确地计算为 $0.0$。\n\n此过程确保了对各种参数范围的数值稳定和正确的评估，包括那些在朴素实现中会导致失败的参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef calculate_probability(N, x, p):\n    \"\"\"\n    Computes the probability of being at position x after N steps of a 1D random walk.\n\n    Args:\n        N (int): The total number of steps.\n        x (int): The final position.\n        p (float): The probability of stepping to the right (+1).\n\n    Returns:\n        float: The probability P(X_N = x).\n    \"\"\"\n    # Step 1: Validate inputs and check for impossible events.\n    # The parity of position x must match the parity of the number of steps N.\n    # This is equivalent to N+x (and N-x) being even.\n    if (N + x) % 2 != 0:\n        return 0.0\n    \n    # The final position cannot be further from the origin than the number of steps.\n    if abs(x) > N:\n        return 0.0\n\n    # Step 2: Handle boundary cases for probability p.\n    if p == 0.0:\n        return 1.0 if x == -N else 0.0\n    \n    if p == 1.0:\n        return 1.0 if x == N else 0.0\n\n    # Step 3: Calculate the number of right (+) and left (-) steps.\n    # These are guaranteed to be integers due to the parity check above.\n    n_plus = (N + x) // 2\n    n_minus = N - n_plus\n\n    # Step 4: Compute the log-probability to avoid overflow/underflow.\n    # The formula is: log(P) = log(C(N, n_plus)) + n_plus*log(p) + n_minus*log(1-p)\n    # The log-combinatorial term log(C(N, k)) is calculated using log-gamma functions:\n    # log(C(N, k)) = gammaln(N+1) - gammaln(k+1) - gammaln(N-k+1)\n    \n    log_comb_term = gammaln(N + 1) - gammaln(n_plus + 1) - gammaln(n_minus + 1)\n    \n    # The log-probability term is calculated using np.log and np.log1p for accuracy.\n    # np.log1p(y) calculates log(1+y) accurately for small y.\n    # Here, log(1-p) is log1p(-p).\n    log_p_term = n_plus * np.log(p) + n_minus * np.log1p(-p)\n    \n    log_prob = log_comb_term + log_p_term\n\n    # Step 5: Exponentiate to get the final probability.\n    # np.exp will handle underflow by returning 0.0 for very negative inputs.\n    return np.exp(log_prob)\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 2, 0.5),\n        (9, 2, 0.5),\n        (1000, 1000, 0.5),\n        (5000, 5000, 0.5),\n        (1000000, 0, 0.5),\n        (200000, 200, 0.501),\n        (1000, -1000, 1.0e-12),\n        (1000, 1000, 1.0e-12),\n        (50, 50, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, x, p = case\n        result = calculate_probability(int(N), int(x), float(p))\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [1.234000000000e-02,...]\n    formatted_results = [f'{r:.12e}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2423389"}, {"introduction": "在物理模拟中，验证能量等守恒量是检验算法准确性的重要手段。本练习模拟一个简单的谐振子系统，其在一个完整周期内做的净功理论上为零，但直接的数值求和会因舍入误差累积而产生漂移 [@problem_id:2423330]。通过实现并对比朴素求和与补偿求和（Kahan summation）算法，你将亲身体会到浮点数加法中精度损失的危害，并掌握一种关键的误差补偿技术，以确保长时间模拟的数值稳定性。", "problem": "考虑一个一维质簧振子，其质量为 $m$（单位：千克），弹簧常数为 $k$（单位：牛顿/米）。当其在位移振幅 $A$（单位：米）处从静止释放时，其精确运动由解析解 $x(t)=A \\cos(\\omega t)$ 和 $v(t)=-A \\omega \\sin(\\omega t)$ 给出，其中角频率为 $\\omega=\\sqrt{k/m}$（单位：弧度/秒），时间为 $t$（单位：秒）。力为 $F(t)=-k x(t)$（单位：牛顿）。瞬时功率为 $P(t)=F(t)\\,v(t)$（单位：瓦特）。由于该系统是保守系统，在任意整数个完整周期 $T=2\\pi/\\omega$ 内，所做的精确净功 $W=\\int P(t)\\,\\mathrm{d}t$ 为 $0$ 焦耳。\n\n设净功由 $N$ 个均匀时间步长的增量的离散和来近似，其中步长为 $\\Delta t=T/M$（每个周期有 $M$ 步），且总步数 $N=C M$（$C$ 为整数周期数）。定义采样时间为 $t_n=n\\,\\Delta t$，其中 $n=0,1,\\dots,N-1$。在第 $n$ 步的离散功增量为\n$$\n\\Delta W_n = F(t_n)\\,v(t_n)\\,\\Delta t \\,,\n$$\n因此，净功的离散近似值为\n$$\nW_{\\mathrm{disc}}=\\sum_{n=0}^{N-1} \\Delta W_n \\,.\n$$\n在精确算术中，对于任何整数 $C$，$W_{\\mathrm{disc}}$ 都等于 $0$ 焦耳。\n\n您的任务是编写一个完整的程序，该程序针对下方的每个测试用例，采用两种不同的浮点累加模式计算数值累加的 $W_{\\mathrm{disc}}$ 的绝对值：\n- 模式 A：一种直接的、存储在单个浮点变量中的滚动求和。\n- 模式 B：一种使用额外浮点变量的滚动求和，该变量用于携带低位舍入损失的修正值，以便将先前加法中丢失的低位比特反馈到后续的更新中。\n\n对于每个测试用例，请按顺序报告两个以焦耳为单位的浮点数：模式 A 和模式 B 下的最终 $W_{\\mathrm{disc}}$ 的绝对值。\n\n使用以下测试套件（所有量均采用国际单位制，角度采用弧度制）：\n- 测试 1：$m=1$, $k=1$, $A=1$, $C=1000$, $M=1000$。\n- 测试 2：$m=1$, $k=1$, $A=1$, $C=1000$, $M=200$。\n- 测试 3：$m=1$, $k=1$, $A=1$, $C=2000$, $M=500$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的、包含六个数字的扁平逗号分隔列表，顺序如下\n$$\n[\\ |W_{\\mathrm{A},1}|,\\ |W_{\\mathrm{B},1}|,\\ |W_{\\mathrm{A},2}|,\\ |W_{\\mathrm{B},2}|,\\ |W_{\\mathrm{A},3}|,\\ |W_{\\mathrm{B},3}|\\ ] \\,,\n$$\n其中 $|W_{\\mathrm{A},j}|$ 和 $|W_{\\mathrm{B},j}|$ 分别表示测试用例 $j$ 在模式 A 和模式 B 下累加的离散功的绝对值（单位：焦耳）。这些数字必须以十进制表示法的浮点值打印。不应打印任何其他文本。", "solution": "所提出的问题经证实是科学上合理的、适定的和客观的。它探讨了计算物理学中的一个基本问题：数值求和中浮点舍入误差的累积。所研究的系统是一个标准的简谐振子，所引用的物理原理是正确的。任务是比较两种对一个理论和为零的大量小浮点数序列进行求和的方法。这直接衡量了求和算法本身引入的数值误差。\n\n质簧系统的运动由以下参数描述：\n质量：$m$\n弹簧常数：$k$\n振幅：$A$\n角频率：$\\omega = \\sqrt{k/m}$\n位置：$x(t) = A \\cos(\\omega t)$\n速度：$v(t) = -A \\omega \\sin(\\omega t)$\n\n弹簧力 $F(t) = -k x(t)$ 所做的瞬时功率 $P(t)$ 由力与速度的乘积给出：\n$$P(t) = F(t)v(t) = (-k x(t))(-A \\omega \\sin(\\omega t)) = k A^2 \\omega \\cos(\\omega t) \\sin(\\omega t)$$\n使用三角恒等式 $\\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta)$，功率可以更紧凑地表示为：\n$$P(t) = \\frac{1}{2} k A^2 \\omega \\sin(2\\omega t)$$\n\n问题要求通过对 $N$ 个均匀时间步长上的离散功率-时间增量求和，来计算所做的净功 $W_{\\mathrm{disc}}$。模拟运行 $C$ 个完整的振荡周期，每个周期 $T = 2\\pi/\\omega$ 包含 $M$ 个步长。\n总步数：$N = C M$\n时间步长：$\\Delta t = T/M = \\frac{2\\pi}{\\omega M}$\n离散时间点：$t_n = n \\Delta t$，其中 $n = 0, 1, \\dots, N-1$。\n\n在第 $n$ 步的离散功增量为 $\\Delta W_n = P(t_n) \\Delta t$：\n$$\\Delta W_n = \\left(\\frac{1}{2} k A^2 \\omega \\sin(2\\omega t_n)\\right) \\Delta t$$\n代入 $t_n = n \\Delta t$，正弦函数的参数变为 $2\\omega (n \\Delta t) = 2\\omega n \\frac{2\\pi}{\\omega M} = \\frac{4\\pi n}{M}$。\n因此，总离散功为以下总和：\n$$W_{\\mathrm{disc}} = \\sum_{n=0}^{N-1} \\Delta W_n = \\sum_{n=0}^{CM-1} \\left(\\frac{1}{2} k A^2 \\omega \\Delta t \\right) \\sin\\left(\\frac{4\\pi n}{M}\\right)$$\n正如在验证阶段所确立的，在无限精度算术中，这个和精确为零，因为正弦函数是在其自身的整数个周期上对称采样的。然而，数值计算是使用有限精度浮点算术执行的，这会引入舍入误差。目标是量化两种不同求和算法产生的这些误差。\n\n模式 A：朴素求和法\n这是最直接的方法。使用单个浮点变量来累加总和。设 $S$ 为滚动和，初始化为 $0$。在第 $n$ 步，更新操作为 $S \\leftarrow S + \\Delta W_n$。当 $S$ 的量级远大于 $\\Delta W_n$ 的量级时，加法操作会导致 $\\Delta W_n$ 的最低有效位丢失。当 $N$ 很大时，这种现象会导致巨大的累积误差。\n\n模式 B：补偿求和法\n该方法被称为 Kahan 求和算法，旨在减轻精度损失。它使用一个额外的“补偿”变量 $c$ 来累积每次加法产生的舍入误差，并在下一次迭代中将其加回总和。\n对于每一项 $\\Delta W_n$，算法按以下步骤进行：\n1. 初始化总和 $S = 0$ 和补偿 $c = 0$。\n2. 对每个 $n = 0, \\dots, N-1$：\n   a. 创建一个修正项 $y = \\Delta W_n - c$。值 $c$ 保存了*上一步*的误差。\n   b. 尝试性地更新总和：$t = S + y$。在此操作中，$y$ 的低位比特可能会丢失。\n   c. 计算当前加法的误差：$c = (t - S) - y$。项 $(t-S)$ 在数值上恢复了 $y$ 中实际加到 $S$ 的部分。从这个结果中减去 $y$ 得到 $y$ 丢失部分的相反数。\n   d. 完成此步的总和更新：$S = t$。\n这个过程确保了舍入误差不会被丢弃，而是被带到后续项中并入计算，从而极大地提高了最终总和的准确性。\n\n该实现为每个测试用例计算 $\\omega$、$T$、$\\Delta t$ 和 $N$。然后，通过一个从 $n=0$ 到 $N-1$ 的循环计算 $\\Delta W_n$ 并更新两个独立的总和，一个用于模式 A，一个用于模式 B。最终输出将是这两种总和在三个测试用例下的绝对值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerically accumulated work for a mass-spring system\n    using two different floating-point summation algorithms and reports\n    the absolute error for each.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (m, k, A, C, M) in SI units.\n    test_cases = [\n        (1.0, 1.0, 1.0, 1000, 1000),\n        (1.0, 1.0, 1.0, 1000, 200),\n        (1.0, 1.0, 1.0, 2000, 500),\n    ]\n\n    results = []\n    for m, k, A, C, M in test_cases:\n        # Calculate derived physical and numerical parameters.\n        # N is cast to int to be used as a range limit.\n        omega = np.sqrt(k / m)\n        T = 2.0 * np.pi / omega\n        dt = T / M\n        N = int(C * M)\n\n        # Initialize accumulators for Mode A (naive) and Mode B (Kahan).\n        sum_A = 0.0\n        sum_B = 0.0\n        c_B = 0.0  # Correction term for Kahan summation.\n\n        # Pre-compute constant factors to minimize floating-point operations\n        # inside the high-iteration loop.\n        # The work increment is delta_W_n = (0.5 * k * A**2 * omega * dt) * sin(4 * pi * n / M).\n        term_factor = 0.5 * k * A**2 * omega * dt\n        arg_factor = 4.0 * np.pi / M\n\n        for n in range(N):\n            # Calculate the work increment for step n.\n            # This numerically stable form avoids multiplying a large integer n\n            # by a small float dt inside the loop.\n            arg = float(n) * arg_factor\n            term = term_factor * np.sin(arg)\n\n            # --- Mode A: Naive Summation ---\n            sum_A += term\n\n            # --- Mode B: Kahan Compensated Summation ---\n            # Correct the next term by the accumulated error from the previous sum.\n            y = term - c_B\n            # Add the corrected term to the running sum.\n            # Low-order bits of y might be lost here.\n            t = sum_B + y\n            # Recover the lost bits. (t - sum_B) is the high-part of y that was\n            # actually added, so (t - sum_B) - y gives the negative of the low-part (the error).\n            c_B = (t - sum_B) - y\n            # Update the sum for the current iteration.\n            sum_B = t\n        \n        # Append the absolute values of the final sums to the results list.\n        results.append(abs(sum_A))\n        results.append(abs(sum_B))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2423330"}]}